// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// InitSettings ;
  11: CALL 51 0 0
// if debug then
  15: LD_EXP 1
  19: IFFALSE 38
// begin PlaceSeeing ( 1 , 1 , 1 , - 372963 ) ;
  21: LD_INT 1
  23: PPUSH
  24: LD_INT 1
  26: PPUSH
  27: LD_INT 1
  29: PPUSH
  30: LD_INT 372963
  32: NEG
  33: PPUSH
  34: CALL_OW 330
// end ; SetTechnologies ;
  38: CALL 602 0 0
// SetDiplomacy ;
  42: CALL 814 0 0
// PrepareGame ;
  46: CALL 896 0 0
// end ;
  50: END
// export debug , GameType , game , disableGlobalTimer ; export mc_amer , mc_leg , mc_rus_1 , mc_rus_2 ; export playerCommander , playerForces , allyCommander , Powell , Farmer , ruOutpost , ruEscape , staticMines , baseCaptured , legDestCounter , cratesSpawns , legOfferAccepted , legChangeSide , allyDestCounter , sibBombAllowed , reinforceAllowed , commander , cratesSpawn , outpostEscape , dialogueMineDetected ; end_of_file export function InitSettings ; begin
  51: LD_INT 0
  53: PPUSH
// debug := 0 ;
  54: LD_ADDR_EXP 1
  58: PUSH
  59: LD_INT 0
  61: ST_TO_ADDR
// GameType := 1 ;
  62: LD_ADDR_EXP 2
  66: PUSH
  67: LD_INT 1
  69: ST_TO_ADDR
// Difficulty := GetMultiplayerSetting ( 0 ) ;
  70: LD_ADDR_OWVAR 67
  74: PUSH
  75: LD_INT 0
  77: PPUSH
  78: CALL_OW 426
  82: ST_TO_ADDR
// sibBombAllowed := GetMultiPlayerSetting ( 1 ) - 1 ;
  83: LD_ADDR_EXP 23
  87: PUSH
  88: LD_INT 1
  90: PPUSH
  91: CALL_OW 426
  95: PUSH
  96: LD_INT 1
  98: MINUS
  99: ST_TO_ADDR
// reinforceAllowed := GetMultiPlayerSetting ( 2 ) - 1 ;
 100: LD_ADDR_EXP 24
 104: PUSH
 105: LD_INT 2
 107: PPUSH
 108: CALL_OW 426
 112: PUSH
 113: LD_INT 1
 115: MINUS
 116: ST_TO_ADDR
// cratesSpawn := GetMultiPlayerSetting ( 3 ) ;
 117: LD_ADDR_EXP 26
 121: PUSH
 122: LD_INT 3
 124: PPUSH
 125: CALL_OW 426
 129: ST_TO_ADDR
// commander := GetMultiPlayerSetting ( 4 ) ;
 130: LD_ADDR_EXP 25
 134: PUSH
 135: LD_INT 4
 137: PPUSH
 138: CALL_OW 426
 142: ST_TO_ADDR
// if not commander then
 143: LD_EXP 25
 147: NOT
 148: IFFALSE 158
// commander := 3 ;
 150: LD_ADDR_EXP 25
 154: PUSH
 155: LD_INT 3
 157: ST_TO_ADDR
// if not debug then
 158: LD_EXP 1
 162: NOT
 163: IFFALSE 167
// exit ;
 165: GO 224
// display_strings := [ Difficulty:  & Difficulty , sibBomb:  & sibBombAllowed , reinforceAllowed:  & reinforceAllowed , cratesSpawn:  & cratesSpawn , commander:  & commander ] ;
 167: LD_ADDR_OWVAR 47
 171: PUSH
 172: LD_STRING Difficulty: 
 174: PUSH
 175: LD_OWVAR 67
 179: STR
 180: PUSH
 181: LD_STRING sibBomb: 
 183: PUSH
 184: LD_EXP 23
 188: STR
 189: PUSH
 190: LD_STRING reinforceAllowed: 
 192: PUSH
 193: LD_EXP 24
 197: STR
 198: PUSH
 199: LD_STRING cratesSpawn: 
 201: PUSH
 202: LD_EXP 26
 206: STR
 207: PUSH
 208: LD_STRING commander: 
 210: PUSH
 211: LD_EXP 25
 215: STR
 216: PUSH
 217: EMPTY
 218: LIST
 219: LIST
 220: LIST
 221: LIST
 222: LIST
 223: ST_TO_ADDR
// end ;
 224: LD_VAR 0 1
 228: RET
// every 0 0$1 trigger game and GameType = 1 and not disableGlobalTimer do
 229: LD_EXP 3
 233: PUSH
 234: LD_EXP 2
 238: PUSH
 239: LD_INT 1
 241: EQUAL
 242: AND
 243: PUSH
 244: LD_EXP 4
 248: NOT
 249: AND
 250: IFFALSE 273
 252: GO 254
 254: DISABLE
// begin enable ;
 255: ENABLE
// display_strings := [ #SkrTime , tick ] ;
 256: LD_ADDR_OWVAR 47
 260: PUSH
 261: LD_STRING #SkrTime
 263: PUSH
 264: LD_OWVAR 1
 268: PUSH
 269: EMPTY
 270: LIST
 271: LIST
 272: ST_TO_ADDR
// end ;
 273: END
// every 1 trigger cratesSpawns and game and GameType = 1 do
 274: LD_EXP 19
 278: PUSH
 279: LD_EXP 3
 283: AND
 284: PUSH
 285: LD_EXP 2
 289: PUSH
 290: LD_INT 1
 292: EQUAL
 293: AND
 294: IFFALSE 355
 296: GO 298
 298: DISABLE
// Crates ( cratesSpawns [ 1 ] [ 1 ] , cratesSpawns [ 1 ] [ 2 ] , cratesSpawns [ 1 ] [ 3 ] , cratesSpawns [ 1 ] [ 4 ] ) ;
 299: LD_EXP 19
 303: PUSH
 304: LD_INT 1
 306: ARRAY
 307: PUSH
 308: LD_INT 1
 310: ARRAY
 311: PPUSH
 312: LD_EXP 19
 316: PUSH
 317: LD_INT 1
 319: ARRAY
 320: PUSH
 321: LD_INT 2
 323: ARRAY
 324: PPUSH
 325: LD_EXP 19
 329: PUSH
 330: LD_INT 1
 332: ARRAY
 333: PUSH
 334: LD_INT 3
 336: ARRAY
 337: PPUSH
 338: LD_EXP 19
 342: PUSH
 343: LD_INT 1
 345: ARRAY
 346: PUSH
 347: LD_INT 4
 349: ARRAY
 350: PPUSH
 351: CALL 56529 0 4
 355: END
// every 1 trigger cratesSpawns and game and GameType = 1 do
 356: LD_EXP 19
 360: PUSH
 361: LD_EXP 3
 365: AND
 366: PUSH
 367: LD_EXP 2
 371: PUSH
 372: LD_INT 1
 374: EQUAL
 375: AND
 376: IFFALSE 437
 378: GO 380
 380: DISABLE
// Crates ( cratesSpawns [ 2 ] [ 1 ] , cratesSpawns [ 2 ] [ 2 ] , cratesSpawns [ 2 ] [ 3 ] , cratesSpawns [ 2 ] [ 4 ] ) ;
 381: LD_EXP 19
 385: PUSH
 386: LD_INT 2
 388: ARRAY
 389: PUSH
 390: LD_INT 1
 392: ARRAY
 393: PPUSH
 394: LD_EXP 19
 398: PUSH
 399: LD_INT 2
 401: ARRAY
 402: PUSH
 403: LD_INT 2
 405: ARRAY
 406: PPUSH
 407: LD_EXP 19
 411: PUSH
 412: LD_INT 2
 414: ARRAY
 415: PUSH
 416: LD_INT 3
 418: ARRAY
 419: PPUSH
 420: LD_EXP 19
 424: PUSH
 425: LD_INT 2
 427: ARRAY
 428: PUSH
 429: LD_INT 4
 431: ARRAY
 432: PPUSH
 433: CALL 56529 0 4
 437: END
// every 1 trigger cratesSpawns and game and GameType = 1 do
 438: LD_EXP 19
 442: PUSH
 443: LD_EXP 3
 447: AND
 448: PUSH
 449: LD_EXP 2
 453: PUSH
 454: LD_INT 1
 456: EQUAL
 457: AND
 458: IFFALSE 519
 460: GO 462
 462: DISABLE
// Crates ( cratesSpawns [ 3 ] [ 1 ] , cratesSpawns [ 3 ] [ 2 ] , cratesSpawns [ 3 ] [ 3 ] , cratesSpawns [ 3 ] [ 4 ] ) ;
 463: LD_EXP 19
 467: PUSH
 468: LD_INT 3
 470: ARRAY
 471: PUSH
 472: LD_INT 1
 474: ARRAY
 475: PPUSH
 476: LD_EXP 19
 480: PUSH
 481: LD_INT 3
 483: ARRAY
 484: PUSH
 485: LD_INT 2
 487: ARRAY
 488: PPUSH
 489: LD_EXP 19
 493: PUSH
 494: LD_INT 3
 496: ARRAY
 497: PUSH
 498: LD_INT 3
 500: ARRAY
 501: PPUSH
 502: LD_EXP 19
 506: PUSH
 507: LD_INT 3
 509: ARRAY
 510: PUSH
 511: LD_INT 4
 513: ARRAY
 514: PPUSH
 515: CALL 56529 0 4
 519: END
// every 1 trigger cratesSpawns and game and GameType = 1 do
 520: LD_EXP 19
 524: PUSH
 525: LD_EXP 3
 529: AND
 530: PUSH
 531: LD_EXP 2
 535: PUSH
 536: LD_INT 1
 538: EQUAL
 539: AND
 540: IFFALSE 601
 542: GO 544
 544: DISABLE
// Crates ( cratesSpawns [ 4 ] [ 1 ] , cratesSpawns [ 4 ] [ 2 ] , cratesSpawns [ 4 ] [ 3 ] , cratesSpawns [ 4 ] [ 4 ] ) ;
 545: LD_EXP 19
 549: PUSH
 550: LD_INT 4
 552: ARRAY
 553: PUSH
 554: LD_INT 1
 556: ARRAY
 557: PPUSH
 558: LD_EXP 19
 562: PUSH
 563: LD_INT 4
 565: ARRAY
 566: PUSH
 567: LD_INT 2
 569: ARRAY
 570: PPUSH
 571: LD_EXP 19
 575: PUSH
 576: LD_INT 4
 578: ARRAY
 579: PUSH
 580: LD_INT 3
 582: ARRAY
 583: PPUSH
 584: LD_EXP 19
 588: PUSH
 589: LD_INT 4
 591: ARRAY
 592: PUSH
 593: LD_INT 4
 595: ARRAY
 596: PPUSH
 597: CALL 56529 0 4
 601: END
// export function SetTechnologies ; var i , j , ban_techs , res_techs ; begin
 602: LD_INT 0
 604: PPUSH
 605: PPUSH
 606: PPUSH
 607: PPUSH
 608: PPUSH
// if GameType = 1 then
 609: LD_EXP 2
 613: PUSH
 614: LD_INT 1
 616: EQUAL
 617: IFFALSE 686
// begin ban_techs := [ ] ;
 619: LD_ADDR_VAR 0 4
 623: PUSH
 624: EMPTY
 625: ST_TO_ADDR
// if sibBombAllowed < 2 then
 626: LD_EXP 23
 630: PUSH
 631: LD_INT 2
 633: LESS
 634: IFFALSE 647
// ban_techs := [ tech_sibFiss ] ;
 636: LD_ADDR_VAR 0 4
 640: PUSH
 641: LD_INT 25
 643: PUSH
 644: EMPTY
 645: LIST
 646: ST_TO_ADDR
// res_techs := [ tech_oilPow , tech_oilEng , tech_tech1 , tech_tech2 , tech_tech3 , tech_gun , tech_gatling , tech_rocket ] ;
 647: LD_ADDR_VAR 0 5
 651: PUSH
 652: LD_INT 46
 654: PUSH
 655: LD_INT 47
 657: PUSH
 658: LD_INT 48
 660: PUSH
 661: LD_INT 49
 663: PUSH
 664: LD_INT 50
 666: PUSH
 667: LD_INT 39
 669: PUSH
 670: LD_INT 69
 672: PUSH
 673: LD_INT 40
 675: PUSH
 676: EMPTY
 677: LIST
 678: LIST
 679: LIST
 680: LIST
 681: LIST
 682: LIST
 683: LIST
 684: LIST
 685: ST_TO_ADDR
// end ; for i = 1 to 8 do
 686: LD_ADDR_VAR 0 2
 690: PUSH
 691: DOUBLE
 692: LD_INT 1
 694: DEC
 695: ST_TO_ADDR
 696: LD_INT 8
 698: PUSH
 699: FOR_TO
 700: IFFALSE 784
// begin if res_techs then
 702: LD_VAR 0 5
 706: IFFALSE 742
// for j in res_techs do
 708: LD_ADDR_VAR 0 3
 712: PUSH
 713: LD_VAR 0 5
 717: PUSH
 718: FOR_IN
 719: IFFALSE 740
// SetTech ( j , i , state_researched ) ;
 721: LD_VAR 0 3
 725: PPUSH
 726: LD_VAR 0 2
 730: PPUSH
 731: LD_INT 2
 733: PPUSH
 734: CALL_OW 322
 738: GO 718
 740: POP
 741: POP
// if ban_techs then
 742: LD_VAR 0 4
 746: IFFALSE 782
// for j in ban_techs do
 748: LD_ADDR_VAR 0 3
 752: PUSH
 753: LD_VAR 0 4
 757: PUSH
 758: FOR_IN
 759: IFFALSE 780
// SetTech ( j , i , state_disabled ) ;
 761: LD_VAR 0 3
 765: PPUSH
 766: LD_VAR 0 2
 770: PPUSH
 771: LD_INT 0
 773: PPUSH
 774: CALL_OW 322
 778: GO 758
 780: POP
 781: POP
// end ;
 782: GO 699
 784: POP
 785: POP
// if sibBombAllowed = 1 then
 786: LD_EXP 23
 790: PUSH
 791: LD_INT 1
 793: EQUAL
 794: IFFALSE 809
// SetTech ( tech_sibFiss , 3 , state_enabled ) ;
 796: LD_INT 25
 798: PPUSH
 799: LD_INT 3
 801: PPUSH
 802: LD_INT 1
 804: PPUSH
 805: CALL_OW 322
// end ;
 809: LD_VAR 0 1
 813: RET
// export function SetDiplomacy ; begin
 814: LD_INT 0
 816: PPUSH
// if GameType = 1 then
 817: LD_EXP 2
 821: PUSH
 822: LD_INT 1
 824: EQUAL
 825: IFFALSE 891
// begin SetAttitude ( 1 , 4 , att_friend , true ) ;
 827: LD_INT 1
 829: PPUSH
 830: LD_INT 4
 832: PPUSH
 833: LD_INT 1
 835: PPUSH
 836: LD_INT 1
 838: PPUSH
 839: CALL_OW 80
// SetAttitude ( 3 , 6 , att_friend , true ) ;
 843: LD_INT 3
 845: PPUSH
 846: LD_INT 6
 848: PPUSH
 849: LD_INT 1
 851: PPUSH
 852: LD_INT 1
 854: PPUSH
 855: CALL_OW 80
// SetAttitude ( 3 , 8 , att_friend , true ) ;
 859: LD_INT 3
 861: PPUSH
 862: LD_INT 8
 864: PPUSH
 865: LD_INT 1
 867: PPUSH
 868: LD_INT 1
 870: PPUSH
 871: CALL_OW 80
// SetAttitude ( 6 , 8 , att_friend , true ) ;
 875: LD_INT 6
 877: PPUSH
 878: LD_INT 8
 880: PPUSH
 881: LD_INT 1
 883: PPUSH
 884: LD_INT 1
 886: PPUSH
 887: CALL_OW 80
// end ; end ;
 891: LD_VAR 0 1
 895: RET
// export function PrepareGame ; var i , tmp , sources ; begin
 896: LD_INT 0
 898: PPUSH
 899: PPUSH
 900: PPUSH
 901: PPUSH
// if GameType = 1 then
 902: LD_EXP 2
 906: PUSH
 907: LD_INT 1
 909: EQUAL
 910: IFFALSE 1406
// begin game := false ;
 912: LD_ADDR_EXP 3
 916: PUSH
 917: LD_INT 0
 919: ST_TO_ADDR
// your_side := 1 ;
 920: LD_ADDR_OWVAR 2
 924: PUSH
 925: LD_INT 1
 927: ST_TO_ADDR
// mc_amer := 1 ;
 928: LD_ADDR_EXP 5
 932: PUSH
 933: LD_INT 1
 935: ST_TO_ADDR
// mc_leg := 2 ;
 936: LD_ADDR_EXP 6
 940: PUSH
 941: LD_INT 2
 943: ST_TO_ADDR
// mc_rus_1 := 3 ;
 944: LD_ADDR_EXP 7
 948: PUSH
 949: LD_INT 3
 951: ST_TO_ADDR
// mc_rus_2 := 4 ;
 952: LD_ADDR_EXP 8
 956: PUSH
 957: LD_INT 4
 959: ST_TO_ADDR
// cratesSpawns := [ [ amerCrates , 1 , 0 , [ 200 , 250 , 300 ] [ cratesSpawn ] ] , [ rusCrates , 8 , 50 , 500 ] , [ legCrates , 5 , 50 , 300 ] , [ playerCrates , [ 4 , 5 , 6 ] [ cratesSpawn ] , 30 , [ 300 , 450 , 500 ] [ cratesSpawn ] ] ] ;
 960: LD_ADDR_EXP 19
 964: PUSH
 965: LD_INT 5
 967: PUSH
 968: LD_INT 1
 970: PUSH
 971: LD_INT 0
 973: PUSH
 974: LD_INT 200
 976: PUSH
 977: LD_INT 250
 979: PUSH
 980: LD_INT 300
 982: PUSH
 983: EMPTY
 984: LIST
 985: LIST
 986: LIST
 987: PUSH
 988: LD_EXP 26
 992: ARRAY
 993: PUSH
 994: EMPTY
 995: LIST
 996: LIST
 997: LIST
 998: LIST
 999: PUSH
1000: LD_INT 13
1002: PUSH
1003: LD_INT 8
1005: PUSH
1006: LD_INT 50
1008: PUSH
1009: LD_INT 500
1011: PUSH
1012: EMPTY
1013: LIST
1014: LIST
1015: LIST
1016: LIST
1017: PUSH
1018: LD_INT 17
1020: PUSH
1021: LD_INT 5
1023: PUSH
1024: LD_INT 50
1026: PUSH
1027: LD_INT 300
1029: PUSH
1030: EMPTY
1031: LIST
1032: LIST
1033: LIST
1034: LIST
1035: PUSH
1036: LD_INT 18
1038: PUSH
1039: LD_INT 4
1041: PUSH
1042: LD_INT 5
1044: PUSH
1045: LD_INT 6
1047: PUSH
1048: EMPTY
1049: LIST
1050: LIST
1051: LIST
1052: PUSH
1053: LD_EXP 26
1057: ARRAY
1058: PUSH
1059: LD_INT 30
1061: PUSH
1062: LD_INT 300
1064: PUSH
1065: LD_INT 450
1067: PUSH
1068: LD_INT 500
1070: PUSH
1071: EMPTY
1072: LIST
1073: LIST
1074: LIST
1075: PUSH
1076: LD_EXP 26
1080: ARRAY
1081: PUSH
1082: EMPTY
1083: LIST
1084: LIST
1085: LIST
1086: LIST
1087: PUSH
1088: EMPTY
1089: LIST
1090: LIST
1091: LIST
1092: LIST
1093: ST_TO_ADDR
// sources := [ [ 190 , 193 , mat_siberit ] , [ 182 , 117 , mat_siberit ] , [ 43 , 2 , mat_siberit ] , [ 114 , 152 , mat_oil ] , [ 85 , 38 , mat_oil ] ] ;
1094: LD_ADDR_VAR 0 4
1098: PUSH
1099: LD_INT 190
1101: PUSH
1102: LD_INT 193
1104: PUSH
1105: LD_INT 3
1107: PUSH
1108: EMPTY
1109: LIST
1110: LIST
1111: LIST
1112: PUSH
1113: LD_INT 182
1115: PUSH
1116: LD_INT 117
1118: PUSH
1119: LD_INT 3
1121: PUSH
1122: EMPTY
1123: LIST
1124: LIST
1125: LIST
1126: PUSH
1127: LD_INT 43
1129: PUSH
1130: LD_INT 2
1132: PUSH
1133: LD_INT 3
1135: PUSH
1136: EMPTY
1137: LIST
1138: LIST
1139: LIST
1140: PUSH
1141: LD_INT 114
1143: PUSH
1144: LD_INT 152
1146: PUSH
1147: LD_INT 2
1149: PUSH
1150: EMPTY
1151: LIST
1152: LIST
1153: LIST
1154: PUSH
1155: LD_INT 85
1157: PUSH
1158: LD_INT 38
1160: PUSH
1161: LD_INT 2
1163: PUSH
1164: EMPTY
1165: LIST
1166: LIST
1167: LIST
1168: PUSH
1169: EMPTY
1170: LIST
1171: LIST
1172: LIST
1173: LIST
1174: LIST
1175: ST_TO_ADDR
// for i in sources do
1176: LD_ADDR_VAR 0 2
1180: PUSH
1181: LD_VAR 0 4
1185: PUSH
1186: FOR_IN
1187: IFFALSE 1222
// CreateDepositXY ( i [ 1 ] , i [ 2 ] , i [ 3 ] ) ;
1189: LD_VAR 0 2
1193: PUSH
1194: LD_INT 1
1196: ARRAY
1197: PPUSH
1198: LD_VAR 0 2
1202: PUSH
1203: LD_INT 2
1205: ARRAY
1206: PPUSH
1207: LD_VAR 0 2
1211: PUSH
1212: LD_INT 3
1214: ARRAY
1215: PPUSH
1216: CALL_OW 62
1220: GO 1186
1222: POP
1223: POP
// disableGlobalTimer := false ;
1224: LD_ADDR_EXP 4
1228: PUSH
1229: LD_INT 0
1231: ST_TO_ADDR
// ruEscape := [ 0 , [ 5 , 6 , 7 ] [ Difficulty ] ] ;
1232: LD_ADDR_EXP 15
1236: PUSH
1237: LD_INT 0
1239: PUSH
1240: LD_INT 5
1242: PUSH
1243: LD_INT 6
1245: PUSH
1246: LD_INT 7
1248: PUSH
1249: EMPTY
1250: LIST
1251: LIST
1252: LIST
1253: PUSH
1254: LD_OWVAR 67
1258: ARRAY
1259: PUSH
1260: EMPTY
1261: LIST
1262: LIST
1263: ST_TO_ADDR
// ruOutpost := [ ] ;
1264: LD_ADDR_EXP 14
1268: PUSH
1269: EMPTY
1270: ST_TO_ADDR
// staticMines := [ ] ;
1271: LD_ADDR_EXP 16
1275: PUSH
1276: EMPTY
1277: ST_TO_ADDR
// baseCaptured := false ;
1278: LD_ADDR_EXP 17
1282: PUSH
1283: LD_INT 0
1285: ST_TO_ADDR
// legDestCounter := 0 ;
1286: LD_ADDR_EXP 18
1290: PUSH
1291: LD_INT 0
1293: ST_TO_ADDR
// legOfferAccepted := false ;
1294: LD_ADDR_EXP 20
1298: PUSH
1299: LD_INT 0
1301: ST_TO_ADDR
// legChangeSide := false ;
1302: LD_ADDR_EXP 21
1306: PUSH
1307: LD_INT 0
1309: ST_TO_ADDR
// allyDestCounter := 0 ;
1310: LD_ADDR_EXP 22
1314: PUSH
1315: LD_INT 0
1317: ST_TO_ADDR
// outpostEscape := false ;
1318: LD_ADDR_EXP 27
1322: PUSH
1323: LD_INT 0
1325: ST_TO_ADDR
// dialogueMineDetected := false ;
1326: LD_ADDR_EXP 28
1330: PUSH
1331: LD_INT 0
1333: ST_TO_ADDR
// PrepareAmericans ;
1334: CALL 7604 0 0
// PrepareLegion ;
1338: CALL 5538 0 0
// PrepareRussians ;
1342: CALL 2504 0 0
// playerForces := PreparePlayer ;
1346: LD_ADDR_EXP 10
1350: PUSH
1351: CALL 8847 0 0
1355: ST_TO_ADDR
// AnimateTrees ( true ) ;
1356: LD_INT 1
1358: PPUSH
1359: CALL_OW 573
// PrepareNature ( 4 , 3 , 8 , 5 , 3 , 1 , 8 , natureGroundArea , natureWaterArea ) ;
1363: LD_INT 4
1365: PPUSH
1366: LD_INT 3
1368: PPUSH
1369: LD_INT 8
1371: PPUSH
1372: LD_INT 5
1374: PPUSH
1375: LD_INT 3
1377: PPUSH
1378: LD_INT 1
1380: PPUSH
1381: LD_INT 8
1383: PPUSH
1384: LD_INT 2
1386: PPUSH
1387: LD_INT 1
1389: PPUSH
1390: CALL 53895 0 9
// MC_Start ;
1394: CALL 63607 0 0
// SetAdditionalRussianForces ;
1398: CALL 7273 0 0
// Action ;
1402: CALL 11204 0 0
// end ; end ;
1406: LD_VAR 0 1
1410: RET
// export function CustomInitMacro ; begin
1411: LD_INT 0
1413: PPUSH
// if GameType <> 1 then
1414: LD_EXP 2
1418: PUSH
1419: LD_INT 1
1421: NONEQUAL
1422: IFFALSE 1426
// exit ;
1424: GO 2499
// MC_SetScanArea ( mc_amer , amerBase ) ;
1426: LD_EXP 5
1430: PPUSH
1431: LD_INT 3
1433: PPUSH
1434: CALL 86982 0 2
// MC_SetParkingArea ( mc_amer , amerParking ) ;
1438: LD_EXP 5
1442: PPUSH
1443: LD_INT 4
1445: PPUSH
1446: CALL 86926 0 2
// MC_SetAllowedTurretWeapons ( mc_amer , [ us_radar , us_heavy_gun , us_rocket_launcher , us_laser , us_double_laser ] ) ;
1450: LD_EXP 5
1454: PPUSH
1455: LD_INT 11
1457: PUSH
1458: LD_INT 6
1460: PUSH
1461: LD_INT 7
1463: PUSH
1464: LD_INT 9
1466: PUSH
1467: LD_INT 10
1469: PUSH
1470: EMPTY
1471: LIST
1472: LIST
1473: LIST
1474: LIST
1475: LIST
1476: PPUSH
1477: CALL 86814 0 2
// MC_SetCratesArea ( mc_amer , amerCrates ) ;
1481: LD_EXP 5
1485: PPUSH
1486: LD_INT 5
1488: PPUSH
1489: CALL 86496 0 2
// MC_SetTame ( mc_amer , amerBase ) ;
1493: LD_EXP 5
1497: PPUSH
1498: LD_INT 3
1500: PPUSH
1501: CALL 86227 0 2
// MC_SetDefenderLimit ( mc_amer , 4 ) ;
1505: LD_EXP 5
1509: PPUSH
1510: LD_INT 4
1512: PPUSH
1513: CALL 85846 0 2
// MC_SetProduceList ( mc_amer , [ [ us_medium_tracked , engine_combustion , control_remote , us_double_gun ] , [ us_medium_tracked , engine_solar , control_remote , us_laser ] , [ us_heavy_tracked , engine_combustion , control_remote , us_rocket_launcher ] , [ us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun ] , ] ) ;
1517: LD_EXP 5
1521: PPUSH
1522: LD_INT 3
1524: PUSH
1525: LD_INT 1
1527: PUSH
1528: LD_INT 2
1530: PUSH
1531: LD_INT 5
1533: PUSH
1534: EMPTY
1535: LIST
1536: LIST
1537: LIST
1538: LIST
1539: PUSH
1540: LD_INT 3
1542: PUSH
1543: LD_INT 2
1545: PUSH
1546: LD_INT 2
1548: PUSH
1549: LD_INT 9
1551: PUSH
1552: EMPTY
1553: LIST
1554: LIST
1555: LIST
1556: LIST
1557: PUSH
1558: LD_INT 4
1560: PUSH
1561: LD_INT 1
1563: PUSH
1564: LD_INT 2
1566: PUSH
1567: LD_INT 7
1569: PUSH
1570: EMPTY
1571: LIST
1572: LIST
1573: LIST
1574: LIST
1575: PUSH
1576: LD_INT 4
1578: PUSH
1579: LD_INT 1
1581: PUSH
1582: LD_INT 2
1584: PUSH
1585: LD_INT 6
1587: PUSH
1588: EMPTY
1589: LIST
1590: LIST
1591: LIST
1592: LIST
1593: PUSH
1594: EMPTY
1595: LIST
1596: LIST
1597: LIST
1598: LIST
1599: PPUSH
1600: CALL 85661 0 2
// MC_SetBuildingList ( mc_amer , [ [ b_turret , 114 , 16 , 0 ] , [ b_bunker , 110 , 12 , 0 ] ] ) ;
1604: LD_EXP 5
1608: PPUSH
1609: LD_INT 33
1611: PUSH
1612: LD_INT 114
1614: PUSH
1615: LD_INT 16
1617: PUSH
1618: LD_INT 0
1620: PUSH
1621: EMPTY
1622: LIST
1623: LIST
1624: LIST
1625: LIST
1626: PUSH
1627: LD_INT 32
1629: PUSH
1630: LD_INT 110
1632: PUSH
1633: LD_INT 12
1635: PUSH
1636: LD_INT 0
1638: PUSH
1639: EMPTY
1640: LIST
1641: LIST
1642: LIST
1643: LIST
1644: PUSH
1645: EMPTY
1646: LIST
1647: LIST
1648: PPUSH
1649: CALL 85553 0 2
// MC_SetLabKind ( mc_amer , [ b_lab_weapon , b_lab_opto , b_lab_computer , b_lab_siberium ] ) ;
1653: LD_EXP 5
1657: PPUSH
1658: LD_INT 10
1660: PUSH
1661: LD_INT 15
1663: PUSH
1664: LD_INT 12
1666: PUSH
1667: LD_INT 11
1669: PUSH
1670: EMPTY
1671: LIST
1672: LIST
1673: LIST
1674: LIST
1675: PPUSH
1676: CALL 86403 0 2
// MC_SetScanArea ( mc_leg , legBase ) ;
1680: LD_EXP 6
1684: PPUSH
1685: LD_INT 6
1687: PPUSH
1688: CALL 86982 0 2
// MC_SetParkingArea ( mc_leg , legParking ) ;
1692: LD_EXP 6
1696: PPUSH
1697: LD_INT 7
1699: PPUSH
1700: CALL 86926 0 2
// MC_SetAllowedTurretWeapons ( mc_leg , [ ar_radar , ar_gun , ar_rocket_launcher , ar_gatling_gun ] ) ;
1704: LD_EXP 6
1708: PPUSH
1709: LD_INT 30
1711: PUSH
1712: LD_INT 27
1714: PUSH
1715: LD_INT 28
1717: PUSH
1718: LD_INT 25
1720: PUSH
1721: EMPTY
1722: LIST
1723: LIST
1724: LIST
1725: LIST
1726: PPUSH
1727: CALL 86814 0 2
// MC_SetCratesArea ( mc_leg , legCrates ) ;
1731: LD_EXP 6
1735: PPUSH
1736: LD_INT 17
1738: PPUSH
1739: CALL 86496 0 2
// MC_SetTame ( mc_leg , legBase ) ;
1743: LD_EXP 6
1747: PPUSH
1748: LD_INT 6
1750: PPUSH
1751: CALL 86227 0 2
// MC_SetDefenderLimit ( mc_leg , 5 ) ;
1755: LD_EXP 6
1759: PPUSH
1760: LD_INT 5
1762: PPUSH
1763: CALL 85846 0 2
// MC_SetMinesField ( mc_leg , 10 , legMines ) ;
1767: LD_EXP 6
1771: PPUSH
1772: LD_INT 10
1774: PPUSH
1775: LD_INT 9
1777: PPUSH
1778: CALL 85324 0 3
// MC_SetBuildingList ( mc_leg , [ [ b_armoury , 157 , 144 , 0 ] , [ b_bunker , 151 , 142 , 0 ] , [ b_bunker , 161 , 144 , 0 ] , [ b_bunker , 140 , 133 , 0 ] ] ) ;
1782: LD_EXP 6
1786: PPUSH
1787: LD_INT 4
1789: PUSH
1790: LD_INT 157
1792: PUSH
1793: LD_INT 144
1795: PUSH
1796: LD_INT 0
1798: PUSH
1799: EMPTY
1800: LIST
1801: LIST
1802: LIST
1803: LIST
1804: PUSH
1805: LD_INT 32
1807: PUSH
1808: LD_INT 151
1810: PUSH
1811: LD_INT 142
1813: PUSH
1814: LD_INT 0
1816: PUSH
1817: EMPTY
1818: LIST
1819: LIST
1820: LIST
1821: LIST
1822: PUSH
1823: LD_INT 32
1825: PUSH
1826: LD_INT 161
1828: PUSH
1829: LD_INT 144
1831: PUSH
1832: LD_INT 0
1834: PUSH
1835: EMPTY
1836: LIST
1837: LIST
1838: LIST
1839: LIST
1840: PUSH
1841: LD_INT 32
1843: PUSH
1844: LD_INT 140
1846: PUSH
1847: LD_INT 133
1849: PUSH
1850: LD_INT 0
1852: PUSH
1853: EMPTY
1854: LIST
1855: LIST
1856: LIST
1857: LIST
1858: PUSH
1859: EMPTY
1860: LIST
1861: LIST
1862: LIST
1863: LIST
1864: PPUSH
1865: CALL 85553 0 2
// MC_SetProduceList ( mc_leg , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_combustion , control_manual , ar_gun ] , [ ar_medium_trike , engine_combustion , control_remote , ar_gun ] , [ ar_medium_trike , engine_combustion , control_remote , ar_gun ] , [ ar_medium_trike , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_cargo_bay ] , [ ar_medium_trike , engine_combustion , control_remote , ar_crane ] ] ) ;
1869: LD_EXP 6
1873: PPUSH
1874: LD_INT 13
1876: PUSH
1877: LD_INT 2
1879: PUSH
1880: LD_INT 1
1882: PUSH
1883: LD_INT 31
1885: PUSH
1886: EMPTY
1887: LIST
1888: LIST
1889: LIST
1890: LIST
1891: PUSH
1892: LD_INT 13
1894: PUSH
1895: LD_INT 2
1897: PUSH
1898: LD_INT 1
1900: PUSH
1901: LD_INT 31
1903: PUSH
1904: EMPTY
1905: LIST
1906: LIST
1907: LIST
1908: LIST
1909: PUSH
1910: LD_INT 13
1912: PUSH
1913: LD_INT 1
1915: PUSH
1916: LD_INT 1
1918: PUSH
1919: LD_INT 27
1921: PUSH
1922: EMPTY
1923: LIST
1924: LIST
1925: LIST
1926: LIST
1927: PUSH
1928: LD_INT 13
1930: PUSH
1931: LD_INT 1
1933: PUSH
1934: LD_INT 2
1936: PUSH
1937: LD_INT 27
1939: PUSH
1940: EMPTY
1941: LIST
1942: LIST
1943: LIST
1944: LIST
1945: PUSH
1946: LD_INT 13
1948: PUSH
1949: LD_INT 1
1951: PUSH
1952: LD_INT 2
1954: PUSH
1955: LD_INT 27
1957: PUSH
1958: EMPTY
1959: LIST
1960: LIST
1961: LIST
1962: LIST
1963: PUSH
1964: LD_INT 13
1966: PUSH
1967: LD_INT 1
1969: PUSH
1970: LD_INT 2
1972: PUSH
1973: LD_INT 28
1975: PUSH
1976: EMPTY
1977: LIST
1978: LIST
1979: LIST
1980: LIST
1981: PUSH
1982: LD_INT 13
1984: PUSH
1985: LD_INT 1
1987: PUSH
1988: LD_INT 2
1990: PUSH
1991: LD_INT 28
1993: PUSH
1994: EMPTY
1995: LIST
1996: LIST
1997: LIST
1998: LIST
1999: PUSH
2000: LD_INT 13
2002: PUSH
2003: LD_INT 1
2005: PUSH
2006: LD_INT 2
2008: PUSH
2009: LD_INT 32
2011: PUSH
2012: EMPTY
2013: LIST
2014: LIST
2015: LIST
2016: LIST
2017: PUSH
2018: LD_INT 13
2020: PUSH
2021: LD_INT 1
2023: PUSH
2024: LD_INT 2
2026: PUSH
2027: LD_INT 88
2029: PUSH
2030: EMPTY
2031: LIST
2032: LIST
2033: LIST
2034: LIST
2035: PUSH
2036: EMPTY
2037: LIST
2038: LIST
2039: LIST
2040: LIST
2041: LIST
2042: LIST
2043: LIST
2044: LIST
2045: LIST
2046: PPUSH
2047: CALL 85661 0 2
// HiddenCamera ( 165 , 156 , 8 ) ;
2051: LD_INT 165
2053: PPUSH
2054: LD_INT 156
2056: PPUSH
2057: LD_INT 8
2059: PPUSH
2060: CALL_OW 244
// MC_SetScanArea ( mc_rus_1 , rus1Base ) ;
2064: LD_EXP 7
2068: PPUSH
2069: LD_INT 15
2071: PPUSH
2072: CALL 86982 0 2
// MC_SetParkingArea ( mc_rus_1 , rus1Parking ) ;
2076: LD_EXP 7
2080: PPUSH
2081: LD_INT 16
2083: PPUSH
2084: CALL 86926 0 2
// MC_SetAllowedTurretWeapons ( mc_rus_1 , [ ru_gatling_gun , ru_rocket , ru_rocket_launcher , ru_time_lapser , ru_heavy_gun ] ) ;
2088: LD_EXP 7
2092: PPUSH
2093: LD_INT 43
2095: PUSH
2096: LD_INT 47
2098: PUSH
2099: LD_INT 45
2101: PUSH
2102: LD_INT 49
2104: PUSH
2105: LD_INT 46
2107: PUSH
2108: EMPTY
2109: LIST
2110: LIST
2111: LIST
2112: LIST
2113: LIST
2114: PPUSH
2115: CALL 86814 0 2
// MC_SetCratesArea ( mc_rus_1 , rusCrates ) ;
2119: LD_EXP 7
2123: PPUSH
2124: LD_INT 13
2126: PPUSH
2127: CALL 86496 0 2
// MC_SetTame ( mc_rus_1 , rus1Base ) ;
2131: LD_EXP 7
2135: PPUSH
2136: LD_INT 15
2138: PPUSH
2139: CALL 86227 0 2
// MC_SetDefenderLimit ( mc_rus_1 , 5 ) ;
2143: LD_EXP 7
2147: PPUSH
2148: LD_INT 5
2150: PPUSH
2151: CALL 85846 0 2
// MC_SetProduceList ( mc_rus_1 , [ [ ru_heavy_wheeled , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_heavy_wheeled , engine_combustion , control_manual , ru_heavy_gun ] , [ ru_heavy_wheeled , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_heavy_wheeled , engine_combustion , control_manual , ru_rocket ] , [ ru_heavy_wheeled , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_medium_wheeled , engine_combustion , control_computer , ru_cargo_bay ] , [ ru_medium_wheeled , engine_combustion , control_computer , ru_crane ] , ] ) ;
2155: LD_EXP 7
2159: PPUSH
2160: LD_INT 23
2162: PUSH
2163: LD_INT 1
2165: PUSH
2166: LD_INT 3
2168: PUSH
2169: LD_INT 46
2171: PUSH
2172: EMPTY
2173: LIST
2174: LIST
2175: LIST
2176: LIST
2177: PUSH
2178: LD_INT 23
2180: PUSH
2181: LD_INT 1
2183: PUSH
2184: LD_INT 1
2186: PUSH
2187: LD_INT 46
2189: PUSH
2190: EMPTY
2191: LIST
2192: LIST
2193: LIST
2194: LIST
2195: PUSH
2196: LD_INT 23
2198: PUSH
2199: LD_INT 1
2201: PUSH
2202: LD_INT 3
2204: PUSH
2205: LD_INT 45
2207: PUSH
2208: EMPTY
2209: LIST
2210: LIST
2211: LIST
2212: LIST
2213: PUSH
2214: LD_INT 23
2216: PUSH
2217: LD_INT 1
2219: PUSH
2220: LD_INT 1
2222: PUSH
2223: LD_INT 47
2225: PUSH
2226: EMPTY
2227: LIST
2228: LIST
2229: LIST
2230: LIST
2231: PUSH
2232: LD_INT 23
2234: PUSH
2235: LD_INT 1
2237: PUSH
2238: LD_INT 3
2240: PUSH
2241: LD_INT 46
2243: PUSH
2244: EMPTY
2245: LIST
2246: LIST
2247: LIST
2248: LIST
2249: PUSH
2250: LD_INT 21
2252: PUSH
2253: LD_INT 1
2255: PUSH
2256: LD_INT 3
2258: PUSH
2259: LD_INT 51
2261: PUSH
2262: EMPTY
2263: LIST
2264: LIST
2265: LIST
2266: LIST
2267: PUSH
2268: LD_INT 21
2270: PUSH
2271: LD_INT 1
2273: PUSH
2274: LD_INT 3
2276: PUSH
2277: LD_INT 52
2279: PUSH
2280: EMPTY
2281: LIST
2282: LIST
2283: LIST
2284: LIST
2285: PUSH
2286: EMPTY
2287: LIST
2288: LIST
2289: LIST
2290: LIST
2291: LIST
2292: LIST
2293: LIST
2294: PPUSH
2295: CALL 85661 0 2
// MC_SetScanArea ( mc_rus_2 , rus2Base ) ;
2299: LD_EXP 8
2303: PPUSH
2304: LD_INT 11
2306: PPUSH
2307: CALL 86982 0 2
// MC_SetParkingArea ( mc_rus_2 , rus2Parking ) ;
2311: LD_EXP 8
2315: PPUSH
2316: LD_INT 12
2318: PPUSH
2319: CALL 86926 0 2
// MC_SetAllowedTurretWeapons ( mc_rus_2 , [ ru_gatling_gun , ru_rocket , ru_rocket_launcher , ru_time_lapser , ru_heavy_gun ] ) ;
2323: LD_EXP 8
2327: PPUSH
2328: LD_INT 43
2330: PUSH
2331: LD_INT 47
2333: PUSH
2334: LD_INT 45
2336: PUSH
2337: LD_INT 49
2339: PUSH
2340: LD_INT 46
2342: PUSH
2343: EMPTY
2344: LIST
2345: LIST
2346: LIST
2347: LIST
2348: LIST
2349: PPUSH
2350: CALL 86814 0 2
// MC_SetCratesArea ( mc_rus_2 , rusCrates ) ;
2354: LD_EXP 8
2358: PPUSH
2359: LD_INT 13
2361: PPUSH
2362: CALL 86496 0 2
// MC_SetTame ( mc_rus_2 , rus2Base ) ;
2366: LD_EXP 8
2370: PPUSH
2371: LD_INT 11
2373: PPUSH
2374: CALL 86227 0 2
// MC_SetDefenderLimit ( mc_rus_2 , 4 ) ;
2378: LD_EXP 8
2382: PPUSH
2383: LD_INT 4
2385: PPUSH
2386: CALL 85846 0 2
// MC_SetTeleportExit ( mc_rus_2 , [ [ 115 , 201 ] ] ) ;
2390: LD_EXP 8
2394: PPUSH
2395: LD_INT 115
2397: PUSH
2398: LD_INT 201
2400: PUSH
2401: EMPTY
2402: LIST
2403: LIST
2404: PUSH
2405: EMPTY
2406: LIST
2407: PPUSH
2408: CALL 86552 0 2
// MC_SetProduceList ( mc_rus_2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
2412: LD_EXP 8
2416: PPUSH
2417: LD_INT 24
2419: PUSH
2420: LD_INT 3
2422: PUSH
2423: LD_INT 3
2425: PUSH
2426: LD_INT 46
2428: PUSH
2429: EMPTY
2430: LIST
2431: LIST
2432: LIST
2433: LIST
2434: PUSH
2435: LD_INT 24
2437: PUSH
2438: LD_INT 3
2440: PUSH
2441: LD_INT 3
2443: PUSH
2444: LD_INT 46
2446: PUSH
2447: EMPTY
2448: LIST
2449: LIST
2450: LIST
2451: LIST
2452: PUSH
2453: LD_INT 24
2455: PUSH
2456: LD_INT 3
2458: PUSH
2459: LD_INT 3
2461: PUSH
2462: LD_INT 46
2464: PUSH
2465: EMPTY
2466: LIST
2467: LIST
2468: LIST
2469: LIST
2470: PUSH
2471: LD_INT 24
2473: PUSH
2474: LD_INT 3
2476: PUSH
2477: LD_INT 3
2479: PUSH
2480: LD_INT 46
2482: PUSH
2483: EMPTY
2484: LIST
2485: LIST
2486: LIST
2487: LIST
2488: PUSH
2489: EMPTY
2490: LIST
2491: LIST
2492: LIST
2493: LIST
2494: PPUSH
2495: CALL 85661 0 2
// end ;
2499: LD_VAR 0 1
2503: RET
// export function PrepareRussians ; var i , b , tmp , side , sr , depot , base ; begin
2504: LD_INT 0
2506: PPUSH
2507: PPUSH
2508: PPUSH
2509: PPUSH
2510: PPUSH
2511: PPUSH
2512: PPUSH
2513: PPUSH
// PrepareNature ( 0 , 0 , 3 , 0 , 0 , 0 , 0 , rusApe , 0 ) ;
2514: LD_INT 0
2516: PPUSH
2517: LD_INT 0
2519: PPUSH
2520: LD_INT 3
2522: PPUSH
2523: LD_INT 0
2525: PPUSH
2526: LD_INT 0
2528: PPUSH
2529: LD_INT 0
2531: PPUSH
2532: LD_INT 0
2534: PPUSH
2535: LD_INT 14
2537: PPUSH
2538: LD_INT 0
2540: PPUSH
2541: CALL 53895 0 9
// side := 3 ;
2545: LD_ADDR_VAR 0 5
2549: PUSH
2550: LD_INT 3
2552: ST_TO_ADDR
// SetTech ( tech_targTeleport , side , state_researched ) ;
2553: LD_INT 38
2555: PPUSH
2556: LD_VAR 0 5
2560: PPUSH
2561: LD_INT 2
2563: PPUSH
2564: CALL_OW 322
// SetTech ( tech_gun , side , state_researched ) ;
2568: LD_INT 39
2570: PPUSH
2571: LD_VAR 0 5
2575: PPUSH
2576: LD_INT 2
2578: PPUSH
2579: CALL_OW 322
// SetTech ( tech_advMet , side , state_researched ) ;
2583: LD_INT 34
2585: PPUSH
2586: LD_VAR 0 5
2590: PPUSH
2591: LD_INT 2
2593: PPUSH
2594: CALL_OW 322
// tmp := [ [ 0 , 208 , 163 , 4 , 0 , 0 ] , [ 3 , 194 , 161 , 1 , 0 , 0 ] , [ 17 , 190 , 161 , 1 , 0 , 0 ] , [ 5 , 200 , 145 , 3 , 0 , 0 ] , [ 32 , 192 , 144 , 3 , 0 , 0 ] , [ 26 , 216 , 172 , 3 , 0 , 0 ] , [ 26 , 218 , 176 , 3 , 0 , 0 ] , [ 29 , 182 , 149 , 3 , 0 , 0 ] , [ 8 , 201 , 171 , 0 , 10 , 11 ] , [ 32 , 188 , 167 , 0 , 0 , 0 ] , [ 32 , 202 , 179 , 0 , 0 , 0 ] , [ 32 , 209 , 182 , 0 , 0 , 0 ] , [ 32 , 220 , 183 , 5 , 0 , 0 ] , [ 32 , 225 , 181 , 5 , 0 , 0 ] , [ 26 , 220 , 174 , 5 , 0 , 0 ] , [ 1 , 84 , 128 , 4 , 0 , 0 ] , [ 3 , 68 , 121 , 1 , 0 , 0 ] , [ 19 , 72 , 125 , 5 , 0 , 0 ] , [ 18 , 68 , 124 , 0 , 0 , 0 ] , [ 24 , 64 , 121 , 1 , 0 , 0 ] , [ 17 , 65 , 118 , 2 , 0 , 0 ] , [ 21 , 68 , 117 , 3 , 0 , 0 ] , [ 8 , 68 , 130 , 1 , 14 , 10 ] , [ 8 , 67 , 110 , 2 , 11 , 12 ] , [ 28 , 85 , 108 , 2 , 0 , 0 ] , [ 28 , 85 , 124 , 2 , 0 , 0 ] , [ 30 , 97 , 119 , 2 , 0 , 0 ] , [ 5 , 111 , 138 , 4 , 0 , 0 ] , [ 33 , 104 , 130 , 3 , 0 , 0 ] , [ 33 , 110 , 142 , 5 , 0 , 0 ] , [ 33 , 91 , 131 , 5 , 0 , 0 ] , [ 33 , 107 , 157 , 5 , 0 , 0 ] , [ 33 , 104 , 160 , 5 , 0 , 0 ] , [ 33 , 101 , 162 , 5 , 0 , 0 ] , [ 32 , 87 , 157 , 5 , 0 , 0 ] , [ 32 , 105 , 158 , 5 , 0 , 0 ] , [ 33 , 91 , 118 , 4 , 0 , 0 ] , [ 33 , 89 , 107 , 4 , 0 , 0 ] , [ 5 , 86 , 96 , 3 , 0 , 0 ] , [ 33 , 91 , 102 , 4 , 0 , 0 ] , [ 32 , 80 , 95 , 3 , 0 , 0 ] , [ 28 , 77 , 105 , 3 , 0 , 0 ] , [ 28 , 85 , 113 , 3 , 0 , 0 ] , [ 28 , 55 , 97 , 3 , 0 , 0 ] , [ 28 , 88 , 128 , 3 , 0 , 0 ] , [ 32 , 69 , 101 , 2 , 0 , 0 ] , [ 1 , 34 , 23 , 4 , 0 , 0 ] , [ 8 , 25 , 4 , 3 , 11 , 10 ] , [ 8 , 15 , 4 , 2 , 14 , 12 ] , [ 29 , 55 , 35 , 2 , 0 , 0 ] , [ 29 , 24 , 44 , 2 , 0 , 0 ] , [ 34 , 34 , 32 , 4 , 0 , 0 ] , [ 3 , 14 , 16 , 1 , 0 , 0 ] , [ 24 , 10 , 16 , 1 , 0 , 0 ] , [ 21 , 11 , 13 , 2 , 0 , 0 ] , [ 18 , 14 , 12 , 3 , 0 , 0 ] , [ 16 , 14 , 19 , 0 , 0 , 0 ] , [ 17 , 18 , 20 , 5 , 0 , 0 ] , [ 28 , 10 , 5 , 1 , 0 , 0 ] , [ 28 , 8 , 8 , 1 , 0 , 0 ] , [ 26 , 19 , 2 , 1 , 0 , 0 ] , [ 26 , 30 , 2 , 1 , 0 , 0 ] , [ 5 , 59 , 20 , 4 , 0 , 0 ] , [ 32 , 60 , 24 , 4 , 0 , 0 ] , [ 32 , 61 , 45 , 5 , 0 , 0 ] , [ 32 , 52 , 51 , 5 , 0 , 0 ] , [ 33 , 56 , 51 , 5 , 0 , 0 ] , [ 33 , 62 , 49 , 5 , 0 , 0 ] , [ 33 , 41 , 47 , 5 , 0 , 0 ] , [ 33 , 33 , 52 , 5 , 0 , 0 ] , [ 5 , 31 , 40 , 0 , 0 , 0 ] , [ 33 , 65 , 37 , 5 , 0 , 0 ] , [ 33 , 63 , 29 , 4 , 0 , 0 ] , [ 33 , 54 , 11 , 4 , 0 , 0 ] , [ 33 , 56 , 15 , 4 , 0 , 0 ] , [ 33 , 51 , 6 , 4 , 0 , 0 ] , [ 26 , 39 , 25 , 0 , 0 , 0 ] , [ 26 , 37 , 21 , 0 , 0 , 0 ] , [ 32 , 35 , 17 , 4 , 0 , 0 ] , [ 33 , 35 , 28 , 4 , 0 , 0 ] , [ 33 , 28 , 46 , 5 , 0 , 0 ] , [ 33 , 31 , 6 , 4 , 0 , 0 ] , [ 26 , 54 , 38 , 4 , 0 , 0 ] , [ 33 , 207 , 167 , 3 , 0 , 0 ] , [ 30 , 43 , 2 , 4 , 0 , 0 ] ] ;
2598: LD_ADDR_VAR 0 4
2602: PUSH
2603: LD_INT 0
2605: PUSH
2606: LD_INT 208
2608: PUSH
2609: LD_INT 163
2611: PUSH
2612: LD_INT 4
2614: PUSH
2615: LD_INT 0
2617: PUSH
2618: LD_INT 0
2620: PUSH
2621: EMPTY
2622: LIST
2623: LIST
2624: LIST
2625: LIST
2626: LIST
2627: LIST
2628: PUSH
2629: LD_INT 3
2631: PUSH
2632: LD_INT 194
2634: PUSH
2635: LD_INT 161
2637: PUSH
2638: LD_INT 1
2640: PUSH
2641: LD_INT 0
2643: PUSH
2644: LD_INT 0
2646: PUSH
2647: EMPTY
2648: LIST
2649: LIST
2650: LIST
2651: LIST
2652: LIST
2653: LIST
2654: PUSH
2655: LD_INT 17
2657: PUSH
2658: LD_INT 190
2660: PUSH
2661: LD_INT 161
2663: PUSH
2664: LD_INT 1
2666: PUSH
2667: LD_INT 0
2669: PUSH
2670: LD_INT 0
2672: PUSH
2673: EMPTY
2674: LIST
2675: LIST
2676: LIST
2677: LIST
2678: LIST
2679: LIST
2680: PUSH
2681: LD_INT 5
2683: PUSH
2684: LD_INT 200
2686: PUSH
2687: LD_INT 145
2689: PUSH
2690: LD_INT 3
2692: PUSH
2693: LD_INT 0
2695: PUSH
2696: LD_INT 0
2698: PUSH
2699: EMPTY
2700: LIST
2701: LIST
2702: LIST
2703: LIST
2704: LIST
2705: LIST
2706: PUSH
2707: LD_INT 32
2709: PUSH
2710: LD_INT 192
2712: PUSH
2713: LD_INT 144
2715: PUSH
2716: LD_INT 3
2718: PUSH
2719: LD_INT 0
2721: PUSH
2722: LD_INT 0
2724: PUSH
2725: EMPTY
2726: LIST
2727: LIST
2728: LIST
2729: LIST
2730: LIST
2731: LIST
2732: PUSH
2733: LD_INT 26
2735: PUSH
2736: LD_INT 216
2738: PUSH
2739: LD_INT 172
2741: PUSH
2742: LD_INT 3
2744: PUSH
2745: LD_INT 0
2747: PUSH
2748: LD_INT 0
2750: PUSH
2751: EMPTY
2752: LIST
2753: LIST
2754: LIST
2755: LIST
2756: LIST
2757: LIST
2758: PUSH
2759: LD_INT 26
2761: PUSH
2762: LD_INT 218
2764: PUSH
2765: LD_INT 176
2767: PUSH
2768: LD_INT 3
2770: PUSH
2771: LD_INT 0
2773: PUSH
2774: LD_INT 0
2776: PUSH
2777: EMPTY
2778: LIST
2779: LIST
2780: LIST
2781: LIST
2782: LIST
2783: LIST
2784: PUSH
2785: LD_INT 29
2787: PUSH
2788: LD_INT 182
2790: PUSH
2791: LD_INT 149
2793: PUSH
2794: LD_INT 3
2796: PUSH
2797: LD_INT 0
2799: PUSH
2800: LD_INT 0
2802: PUSH
2803: EMPTY
2804: LIST
2805: LIST
2806: LIST
2807: LIST
2808: LIST
2809: LIST
2810: PUSH
2811: LD_INT 8
2813: PUSH
2814: LD_INT 201
2816: PUSH
2817: LD_INT 171
2819: PUSH
2820: LD_INT 0
2822: PUSH
2823: LD_INT 10
2825: PUSH
2826: LD_INT 11
2828: PUSH
2829: EMPTY
2830: LIST
2831: LIST
2832: LIST
2833: LIST
2834: LIST
2835: LIST
2836: PUSH
2837: LD_INT 32
2839: PUSH
2840: LD_INT 188
2842: PUSH
2843: LD_INT 167
2845: PUSH
2846: LD_INT 0
2848: PUSH
2849: LD_INT 0
2851: PUSH
2852: LD_INT 0
2854: PUSH
2855: EMPTY
2856: LIST
2857: LIST
2858: LIST
2859: LIST
2860: LIST
2861: LIST
2862: PUSH
2863: LD_INT 32
2865: PUSH
2866: LD_INT 202
2868: PUSH
2869: LD_INT 179
2871: PUSH
2872: LD_INT 0
2874: PUSH
2875: LD_INT 0
2877: PUSH
2878: LD_INT 0
2880: PUSH
2881: EMPTY
2882: LIST
2883: LIST
2884: LIST
2885: LIST
2886: LIST
2887: LIST
2888: PUSH
2889: LD_INT 32
2891: PUSH
2892: LD_INT 209
2894: PUSH
2895: LD_INT 182
2897: PUSH
2898: LD_INT 0
2900: PUSH
2901: LD_INT 0
2903: PUSH
2904: LD_INT 0
2906: PUSH
2907: EMPTY
2908: LIST
2909: LIST
2910: LIST
2911: LIST
2912: LIST
2913: LIST
2914: PUSH
2915: LD_INT 32
2917: PUSH
2918: LD_INT 220
2920: PUSH
2921: LD_INT 183
2923: PUSH
2924: LD_INT 5
2926: PUSH
2927: LD_INT 0
2929: PUSH
2930: LD_INT 0
2932: PUSH
2933: EMPTY
2934: LIST
2935: LIST
2936: LIST
2937: LIST
2938: LIST
2939: LIST
2940: PUSH
2941: LD_INT 32
2943: PUSH
2944: LD_INT 225
2946: PUSH
2947: LD_INT 181
2949: PUSH
2950: LD_INT 5
2952: PUSH
2953: LD_INT 0
2955: PUSH
2956: LD_INT 0
2958: PUSH
2959: EMPTY
2960: LIST
2961: LIST
2962: LIST
2963: LIST
2964: LIST
2965: LIST
2966: PUSH
2967: LD_INT 26
2969: PUSH
2970: LD_INT 220
2972: PUSH
2973: LD_INT 174
2975: PUSH
2976: LD_INT 5
2978: PUSH
2979: LD_INT 0
2981: PUSH
2982: LD_INT 0
2984: PUSH
2985: EMPTY
2986: LIST
2987: LIST
2988: LIST
2989: LIST
2990: LIST
2991: LIST
2992: PUSH
2993: LD_INT 1
2995: PUSH
2996: LD_INT 84
2998: PUSH
2999: LD_INT 128
3001: PUSH
3002: LD_INT 4
3004: PUSH
3005: LD_INT 0
3007: PUSH
3008: LD_INT 0
3010: PUSH
3011: EMPTY
3012: LIST
3013: LIST
3014: LIST
3015: LIST
3016: LIST
3017: LIST
3018: PUSH
3019: LD_INT 3
3021: PUSH
3022: LD_INT 68
3024: PUSH
3025: LD_INT 121
3027: PUSH
3028: LD_INT 1
3030: PUSH
3031: LD_INT 0
3033: PUSH
3034: LD_INT 0
3036: PUSH
3037: EMPTY
3038: LIST
3039: LIST
3040: LIST
3041: LIST
3042: LIST
3043: LIST
3044: PUSH
3045: LD_INT 19
3047: PUSH
3048: LD_INT 72
3050: PUSH
3051: LD_INT 125
3053: PUSH
3054: LD_INT 5
3056: PUSH
3057: LD_INT 0
3059: PUSH
3060: LD_INT 0
3062: PUSH
3063: EMPTY
3064: LIST
3065: LIST
3066: LIST
3067: LIST
3068: LIST
3069: LIST
3070: PUSH
3071: LD_INT 18
3073: PUSH
3074: LD_INT 68
3076: PUSH
3077: LD_INT 124
3079: PUSH
3080: LD_INT 0
3082: PUSH
3083: LD_INT 0
3085: PUSH
3086: LD_INT 0
3088: PUSH
3089: EMPTY
3090: LIST
3091: LIST
3092: LIST
3093: LIST
3094: LIST
3095: LIST
3096: PUSH
3097: LD_INT 24
3099: PUSH
3100: LD_INT 64
3102: PUSH
3103: LD_INT 121
3105: PUSH
3106: LD_INT 1
3108: PUSH
3109: LD_INT 0
3111: PUSH
3112: LD_INT 0
3114: PUSH
3115: EMPTY
3116: LIST
3117: LIST
3118: LIST
3119: LIST
3120: LIST
3121: LIST
3122: PUSH
3123: LD_INT 17
3125: PUSH
3126: LD_INT 65
3128: PUSH
3129: LD_INT 118
3131: PUSH
3132: LD_INT 2
3134: PUSH
3135: LD_INT 0
3137: PUSH
3138: LD_INT 0
3140: PUSH
3141: EMPTY
3142: LIST
3143: LIST
3144: LIST
3145: LIST
3146: LIST
3147: LIST
3148: PUSH
3149: LD_INT 21
3151: PUSH
3152: LD_INT 68
3154: PUSH
3155: LD_INT 117
3157: PUSH
3158: LD_INT 3
3160: PUSH
3161: LD_INT 0
3163: PUSH
3164: LD_INT 0
3166: PUSH
3167: EMPTY
3168: LIST
3169: LIST
3170: LIST
3171: LIST
3172: LIST
3173: LIST
3174: PUSH
3175: LD_INT 8
3177: PUSH
3178: LD_INT 68
3180: PUSH
3181: LD_INT 130
3183: PUSH
3184: LD_INT 1
3186: PUSH
3187: LD_INT 14
3189: PUSH
3190: LD_INT 10
3192: PUSH
3193: EMPTY
3194: LIST
3195: LIST
3196: LIST
3197: LIST
3198: LIST
3199: LIST
3200: PUSH
3201: LD_INT 8
3203: PUSH
3204: LD_INT 67
3206: PUSH
3207: LD_INT 110
3209: PUSH
3210: LD_INT 2
3212: PUSH
3213: LD_INT 11
3215: PUSH
3216: LD_INT 12
3218: PUSH
3219: EMPTY
3220: LIST
3221: LIST
3222: LIST
3223: LIST
3224: LIST
3225: LIST
3226: PUSH
3227: LD_INT 28
3229: PUSH
3230: LD_INT 85
3232: PUSH
3233: LD_INT 108
3235: PUSH
3236: LD_INT 2
3238: PUSH
3239: LD_INT 0
3241: PUSH
3242: LD_INT 0
3244: PUSH
3245: EMPTY
3246: LIST
3247: LIST
3248: LIST
3249: LIST
3250: LIST
3251: LIST
3252: PUSH
3253: LD_INT 28
3255: PUSH
3256: LD_INT 85
3258: PUSH
3259: LD_INT 124
3261: PUSH
3262: LD_INT 2
3264: PUSH
3265: LD_INT 0
3267: PUSH
3268: LD_INT 0
3270: PUSH
3271: EMPTY
3272: LIST
3273: LIST
3274: LIST
3275: LIST
3276: LIST
3277: LIST
3278: PUSH
3279: LD_INT 30
3281: PUSH
3282: LD_INT 97
3284: PUSH
3285: LD_INT 119
3287: PUSH
3288: LD_INT 2
3290: PUSH
3291: LD_INT 0
3293: PUSH
3294: LD_INT 0
3296: PUSH
3297: EMPTY
3298: LIST
3299: LIST
3300: LIST
3301: LIST
3302: LIST
3303: LIST
3304: PUSH
3305: LD_INT 5
3307: PUSH
3308: LD_INT 111
3310: PUSH
3311: LD_INT 138
3313: PUSH
3314: LD_INT 4
3316: PUSH
3317: LD_INT 0
3319: PUSH
3320: LD_INT 0
3322: PUSH
3323: EMPTY
3324: LIST
3325: LIST
3326: LIST
3327: LIST
3328: LIST
3329: LIST
3330: PUSH
3331: LD_INT 33
3333: PUSH
3334: LD_INT 104
3336: PUSH
3337: LD_INT 130
3339: PUSH
3340: LD_INT 3
3342: PUSH
3343: LD_INT 0
3345: PUSH
3346: LD_INT 0
3348: PUSH
3349: EMPTY
3350: LIST
3351: LIST
3352: LIST
3353: LIST
3354: LIST
3355: LIST
3356: PUSH
3357: LD_INT 33
3359: PUSH
3360: LD_INT 110
3362: PUSH
3363: LD_INT 142
3365: PUSH
3366: LD_INT 5
3368: PUSH
3369: LD_INT 0
3371: PUSH
3372: LD_INT 0
3374: PUSH
3375: EMPTY
3376: LIST
3377: LIST
3378: LIST
3379: LIST
3380: LIST
3381: LIST
3382: PUSH
3383: LD_INT 33
3385: PUSH
3386: LD_INT 91
3388: PUSH
3389: LD_INT 131
3391: PUSH
3392: LD_INT 5
3394: PUSH
3395: LD_INT 0
3397: PUSH
3398: LD_INT 0
3400: PUSH
3401: EMPTY
3402: LIST
3403: LIST
3404: LIST
3405: LIST
3406: LIST
3407: LIST
3408: PUSH
3409: LD_INT 33
3411: PUSH
3412: LD_INT 107
3414: PUSH
3415: LD_INT 157
3417: PUSH
3418: LD_INT 5
3420: PUSH
3421: LD_INT 0
3423: PUSH
3424: LD_INT 0
3426: PUSH
3427: EMPTY
3428: LIST
3429: LIST
3430: LIST
3431: LIST
3432: LIST
3433: LIST
3434: PUSH
3435: LD_INT 33
3437: PUSH
3438: LD_INT 104
3440: PUSH
3441: LD_INT 160
3443: PUSH
3444: LD_INT 5
3446: PUSH
3447: LD_INT 0
3449: PUSH
3450: LD_INT 0
3452: PUSH
3453: EMPTY
3454: LIST
3455: LIST
3456: LIST
3457: LIST
3458: LIST
3459: LIST
3460: PUSH
3461: LD_INT 33
3463: PUSH
3464: LD_INT 101
3466: PUSH
3467: LD_INT 162
3469: PUSH
3470: LD_INT 5
3472: PUSH
3473: LD_INT 0
3475: PUSH
3476: LD_INT 0
3478: PUSH
3479: EMPTY
3480: LIST
3481: LIST
3482: LIST
3483: LIST
3484: LIST
3485: LIST
3486: PUSH
3487: LD_INT 32
3489: PUSH
3490: LD_INT 87
3492: PUSH
3493: LD_INT 157
3495: PUSH
3496: LD_INT 5
3498: PUSH
3499: LD_INT 0
3501: PUSH
3502: LD_INT 0
3504: PUSH
3505: EMPTY
3506: LIST
3507: LIST
3508: LIST
3509: LIST
3510: LIST
3511: LIST
3512: PUSH
3513: LD_INT 32
3515: PUSH
3516: LD_INT 105
3518: PUSH
3519: LD_INT 158
3521: PUSH
3522: LD_INT 5
3524: PUSH
3525: LD_INT 0
3527: PUSH
3528: LD_INT 0
3530: PUSH
3531: EMPTY
3532: LIST
3533: LIST
3534: LIST
3535: LIST
3536: LIST
3537: LIST
3538: PUSH
3539: LD_INT 33
3541: PUSH
3542: LD_INT 91
3544: PUSH
3545: LD_INT 118
3547: PUSH
3548: LD_INT 4
3550: PUSH
3551: LD_INT 0
3553: PUSH
3554: LD_INT 0
3556: PUSH
3557: EMPTY
3558: LIST
3559: LIST
3560: LIST
3561: LIST
3562: LIST
3563: LIST
3564: PUSH
3565: LD_INT 33
3567: PUSH
3568: LD_INT 89
3570: PUSH
3571: LD_INT 107
3573: PUSH
3574: LD_INT 4
3576: PUSH
3577: LD_INT 0
3579: PUSH
3580: LD_INT 0
3582: PUSH
3583: EMPTY
3584: LIST
3585: LIST
3586: LIST
3587: LIST
3588: LIST
3589: LIST
3590: PUSH
3591: LD_INT 5
3593: PUSH
3594: LD_INT 86
3596: PUSH
3597: LD_INT 96
3599: PUSH
3600: LD_INT 3
3602: PUSH
3603: LD_INT 0
3605: PUSH
3606: LD_INT 0
3608: PUSH
3609: EMPTY
3610: LIST
3611: LIST
3612: LIST
3613: LIST
3614: LIST
3615: LIST
3616: PUSH
3617: LD_INT 33
3619: PUSH
3620: LD_INT 91
3622: PUSH
3623: LD_INT 102
3625: PUSH
3626: LD_INT 4
3628: PUSH
3629: LD_INT 0
3631: PUSH
3632: LD_INT 0
3634: PUSH
3635: EMPTY
3636: LIST
3637: LIST
3638: LIST
3639: LIST
3640: LIST
3641: LIST
3642: PUSH
3643: LD_INT 32
3645: PUSH
3646: LD_INT 80
3648: PUSH
3649: LD_INT 95
3651: PUSH
3652: LD_INT 3
3654: PUSH
3655: LD_INT 0
3657: PUSH
3658: LD_INT 0
3660: PUSH
3661: EMPTY
3662: LIST
3663: LIST
3664: LIST
3665: LIST
3666: LIST
3667: LIST
3668: PUSH
3669: LD_INT 28
3671: PUSH
3672: LD_INT 77
3674: PUSH
3675: LD_INT 105
3677: PUSH
3678: LD_INT 3
3680: PUSH
3681: LD_INT 0
3683: PUSH
3684: LD_INT 0
3686: PUSH
3687: EMPTY
3688: LIST
3689: LIST
3690: LIST
3691: LIST
3692: LIST
3693: LIST
3694: PUSH
3695: LD_INT 28
3697: PUSH
3698: LD_INT 85
3700: PUSH
3701: LD_INT 113
3703: PUSH
3704: LD_INT 3
3706: PUSH
3707: LD_INT 0
3709: PUSH
3710: LD_INT 0
3712: PUSH
3713: EMPTY
3714: LIST
3715: LIST
3716: LIST
3717: LIST
3718: LIST
3719: LIST
3720: PUSH
3721: LD_INT 28
3723: PUSH
3724: LD_INT 55
3726: PUSH
3727: LD_INT 97
3729: PUSH
3730: LD_INT 3
3732: PUSH
3733: LD_INT 0
3735: PUSH
3736: LD_INT 0
3738: PUSH
3739: EMPTY
3740: LIST
3741: LIST
3742: LIST
3743: LIST
3744: LIST
3745: LIST
3746: PUSH
3747: LD_INT 28
3749: PUSH
3750: LD_INT 88
3752: PUSH
3753: LD_INT 128
3755: PUSH
3756: LD_INT 3
3758: PUSH
3759: LD_INT 0
3761: PUSH
3762: LD_INT 0
3764: PUSH
3765: EMPTY
3766: LIST
3767: LIST
3768: LIST
3769: LIST
3770: LIST
3771: LIST
3772: PUSH
3773: LD_INT 32
3775: PUSH
3776: LD_INT 69
3778: PUSH
3779: LD_INT 101
3781: PUSH
3782: LD_INT 2
3784: PUSH
3785: LD_INT 0
3787: PUSH
3788: LD_INT 0
3790: PUSH
3791: EMPTY
3792: LIST
3793: LIST
3794: LIST
3795: LIST
3796: LIST
3797: LIST
3798: PUSH
3799: LD_INT 1
3801: PUSH
3802: LD_INT 34
3804: PUSH
3805: LD_INT 23
3807: PUSH
3808: LD_INT 4
3810: PUSH
3811: LD_INT 0
3813: PUSH
3814: LD_INT 0
3816: PUSH
3817: EMPTY
3818: LIST
3819: LIST
3820: LIST
3821: LIST
3822: LIST
3823: LIST
3824: PUSH
3825: LD_INT 8
3827: PUSH
3828: LD_INT 25
3830: PUSH
3831: LD_INT 4
3833: PUSH
3834: LD_INT 3
3836: PUSH
3837: LD_INT 11
3839: PUSH
3840: LD_INT 10
3842: PUSH
3843: EMPTY
3844: LIST
3845: LIST
3846: LIST
3847: LIST
3848: LIST
3849: LIST
3850: PUSH
3851: LD_INT 8
3853: PUSH
3854: LD_INT 15
3856: PUSH
3857: LD_INT 4
3859: PUSH
3860: LD_INT 2
3862: PUSH
3863: LD_INT 14
3865: PUSH
3866: LD_INT 12
3868: PUSH
3869: EMPTY
3870: LIST
3871: LIST
3872: LIST
3873: LIST
3874: LIST
3875: LIST
3876: PUSH
3877: LD_INT 29
3879: PUSH
3880: LD_INT 55
3882: PUSH
3883: LD_INT 35
3885: PUSH
3886: LD_INT 2
3888: PUSH
3889: LD_INT 0
3891: PUSH
3892: LD_INT 0
3894: PUSH
3895: EMPTY
3896: LIST
3897: LIST
3898: LIST
3899: LIST
3900: LIST
3901: LIST
3902: PUSH
3903: LD_INT 29
3905: PUSH
3906: LD_INT 24
3908: PUSH
3909: LD_INT 44
3911: PUSH
3912: LD_INT 2
3914: PUSH
3915: LD_INT 0
3917: PUSH
3918: LD_INT 0
3920: PUSH
3921: EMPTY
3922: LIST
3923: LIST
3924: LIST
3925: LIST
3926: LIST
3927: LIST
3928: PUSH
3929: LD_INT 34
3931: PUSH
3932: LD_INT 34
3934: PUSH
3935: LD_INT 32
3937: PUSH
3938: LD_INT 4
3940: PUSH
3941: LD_INT 0
3943: PUSH
3944: LD_INT 0
3946: PUSH
3947: EMPTY
3948: LIST
3949: LIST
3950: LIST
3951: LIST
3952: LIST
3953: LIST
3954: PUSH
3955: LD_INT 3
3957: PUSH
3958: LD_INT 14
3960: PUSH
3961: LD_INT 16
3963: PUSH
3964: LD_INT 1
3966: PUSH
3967: LD_INT 0
3969: PUSH
3970: LD_INT 0
3972: PUSH
3973: EMPTY
3974: LIST
3975: LIST
3976: LIST
3977: LIST
3978: LIST
3979: LIST
3980: PUSH
3981: LD_INT 24
3983: PUSH
3984: LD_INT 10
3986: PUSH
3987: LD_INT 16
3989: PUSH
3990: LD_INT 1
3992: PUSH
3993: LD_INT 0
3995: PUSH
3996: LD_INT 0
3998: PUSH
3999: EMPTY
4000: LIST
4001: LIST
4002: LIST
4003: LIST
4004: LIST
4005: LIST
4006: PUSH
4007: LD_INT 21
4009: PUSH
4010: LD_INT 11
4012: PUSH
4013: LD_INT 13
4015: PUSH
4016: LD_INT 2
4018: PUSH
4019: LD_INT 0
4021: PUSH
4022: LD_INT 0
4024: PUSH
4025: EMPTY
4026: LIST
4027: LIST
4028: LIST
4029: LIST
4030: LIST
4031: LIST
4032: PUSH
4033: LD_INT 18
4035: PUSH
4036: LD_INT 14
4038: PUSH
4039: LD_INT 12
4041: PUSH
4042: LD_INT 3
4044: PUSH
4045: LD_INT 0
4047: PUSH
4048: LD_INT 0
4050: PUSH
4051: EMPTY
4052: LIST
4053: LIST
4054: LIST
4055: LIST
4056: LIST
4057: LIST
4058: PUSH
4059: LD_INT 16
4061: PUSH
4062: LD_INT 14
4064: PUSH
4065: LD_INT 19
4067: PUSH
4068: LD_INT 0
4070: PUSH
4071: LD_INT 0
4073: PUSH
4074: LD_INT 0
4076: PUSH
4077: EMPTY
4078: LIST
4079: LIST
4080: LIST
4081: LIST
4082: LIST
4083: LIST
4084: PUSH
4085: LD_INT 17
4087: PUSH
4088: LD_INT 18
4090: PUSH
4091: LD_INT 20
4093: PUSH
4094: LD_INT 5
4096: PUSH
4097: LD_INT 0
4099: PUSH
4100: LD_INT 0
4102: PUSH
4103: EMPTY
4104: LIST
4105: LIST
4106: LIST
4107: LIST
4108: LIST
4109: LIST
4110: PUSH
4111: LD_INT 28
4113: PUSH
4114: LD_INT 10
4116: PUSH
4117: LD_INT 5
4119: PUSH
4120: LD_INT 1
4122: PUSH
4123: LD_INT 0
4125: PUSH
4126: LD_INT 0
4128: PUSH
4129: EMPTY
4130: LIST
4131: LIST
4132: LIST
4133: LIST
4134: LIST
4135: LIST
4136: PUSH
4137: LD_INT 28
4139: PUSH
4140: LD_INT 8
4142: PUSH
4143: LD_INT 8
4145: PUSH
4146: LD_INT 1
4148: PUSH
4149: LD_INT 0
4151: PUSH
4152: LD_INT 0
4154: PUSH
4155: EMPTY
4156: LIST
4157: LIST
4158: LIST
4159: LIST
4160: LIST
4161: LIST
4162: PUSH
4163: LD_INT 26
4165: PUSH
4166: LD_INT 19
4168: PUSH
4169: LD_INT 2
4171: PUSH
4172: LD_INT 1
4174: PUSH
4175: LD_INT 0
4177: PUSH
4178: LD_INT 0
4180: PUSH
4181: EMPTY
4182: LIST
4183: LIST
4184: LIST
4185: LIST
4186: LIST
4187: LIST
4188: PUSH
4189: LD_INT 26
4191: PUSH
4192: LD_INT 30
4194: PUSH
4195: LD_INT 2
4197: PUSH
4198: LD_INT 1
4200: PUSH
4201: LD_INT 0
4203: PUSH
4204: LD_INT 0
4206: PUSH
4207: EMPTY
4208: LIST
4209: LIST
4210: LIST
4211: LIST
4212: LIST
4213: LIST
4214: PUSH
4215: LD_INT 5
4217: PUSH
4218: LD_INT 59
4220: PUSH
4221: LD_INT 20
4223: PUSH
4224: LD_INT 4
4226: PUSH
4227: LD_INT 0
4229: PUSH
4230: LD_INT 0
4232: PUSH
4233: EMPTY
4234: LIST
4235: LIST
4236: LIST
4237: LIST
4238: LIST
4239: LIST
4240: PUSH
4241: LD_INT 32
4243: PUSH
4244: LD_INT 60
4246: PUSH
4247: LD_INT 24
4249: PUSH
4250: LD_INT 4
4252: PUSH
4253: LD_INT 0
4255: PUSH
4256: LD_INT 0
4258: PUSH
4259: EMPTY
4260: LIST
4261: LIST
4262: LIST
4263: LIST
4264: LIST
4265: LIST
4266: PUSH
4267: LD_INT 32
4269: PUSH
4270: LD_INT 61
4272: PUSH
4273: LD_INT 45
4275: PUSH
4276: LD_INT 5
4278: PUSH
4279: LD_INT 0
4281: PUSH
4282: LD_INT 0
4284: PUSH
4285: EMPTY
4286: LIST
4287: LIST
4288: LIST
4289: LIST
4290: LIST
4291: LIST
4292: PUSH
4293: LD_INT 32
4295: PUSH
4296: LD_INT 52
4298: PUSH
4299: LD_INT 51
4301: PUSH
4302: LD_INT 5
4304: PUSH
4305: LD_INT 0
4307: PUSH
4308: LD_INT 0
4310: PUSH
4311: EMPTY
4312: LIST
4313: LIST
4314: LIST
4315: LIST
4316: LIST
4317: LIST
4318: PUSH
4319: LD_INT 33
4321: PUSH
4322: LD_INT 56
4324: PUSH
4325: LD_INT 51
4327: PUSH
4328: LD_INT 5
4330: PUSH
4331: LD_INT 0
4333: PUSH
4334: LD_INT 0
4336: PUSH
4337: EMPTY
4338: LIST
4339: LIST
4340: LIST
4341: LIST
4342: LIST
4343: LIST
4344: PUSH
4345: LD_INT 33
4347: PUSH
4348: LD_INT 62
4350: PUSH
4351: LD_INT 49
4353: PUSH
4354: LD_INT 5
4356: PUSH
4357: LD_INT 0
4359: PUSH
4360: LD_INT 0
4362: PUSH
4363: EMPTY
4364: LIST
4365: LIST
4366: LIST
4367: LIST
4368: LIST
4369: LIST
4370: PUSH
4371: LD_INT 33
4373: PUSH
4374: LD_INT 41
4376: PUSH
4377: LD_INT 47
4379: PUSH
4380: LD_INT 5
4382: PUSH
4383: LD_INT 0
4385: PUSH
4386: LD_INT 0
4388: PUSH
4389: EMPTY
4390: LIST
4391: LIST
4392: LIST
4393: LIST
4394: LIST
4395: LIST
4396: PUSH
4397: LD_INT 33
4399: PUSH
4400: LD_INT 33
4402: PUSH
4403: LD_INT 52
4405: PUSH
4406: LD_INT 5
4408: PUSH
4409: LD_INT 0
4411: PUSH
4412: LD_INT 0
4414: PUSH
4415: EMPTY
4416: LIST
4417: LIST
4418: LIST
4419: LIST
4420: LIST
4421: LIST
4422: PUSH
4423: LD_INT 5
4425: PUSH
4426: LD_INT 31
4428: PUSH
4429: LD_INT 40
4431: PUSH
4432: LD_INT 0
4434: PUSH
4435: LD_INT 0
4437: PUSH
4438: LD_INT 0
4440: PUSH
4441: EMPTY
4442: LIST
4443: LIST
4444: LIST
4445: LIST
4446: LIST
4447: LIST
4448: PUSH
4449: LD_INT 33
4451: PUSH
4452: LD_INT 65
4454: PUSH
4455: LD_INT 37
4457: PUSH
4458: LD_INT 5
4460: PUSH
4461: LD_INT 0
4463: PUSH
4464: LD_INT 0
4466: PUSH
4467: EMPTY
4468: LIST
4469: LIST
4470: LIST
4471: LIST
4472: LIST
4473: LIST
4474: PUSH
4475: LD_INT 33
4477: PUSH
4478: LD_INT 63
4480: PUSH
4481: LD_INT 29
4483: PUSH
4484: LD_INT 4
4486: PUSH
4487: LD_INT 0
4489: PUSH
4490: LD_INT 0
4492: PUSH
4493: EMPTY
4494: LIST
4495: LIST
4496: LIST
4497: LIST
4498: LIST
4499: LIST
4500: PUSH
4501: LD_INT 33
4503: PUSH
4504: LD_INT 54
4506: PUSH
4507: LD_INT 11
4509: PUSH
4510: LD_INT 4
4512: PUSH
4513: LD_INT 0
4515: PUSH
4516: LD_INT 0
4518: PUSH
4519: EMPTY
4520: LIST
4521: LIST
4522: LIST
4523: LIST
4524: LIST
4525: LIST
4526: PUSH
4527: LD_INT 33
4529: PUSH
4530: LD_INT 56
4532: PUSH
4533: LD_INT 15
4535: PUSH
4536: LD_INT 4
4538: PUSH
4539: LD_INT 0
4541: PUSH
4542: LD_INT 0
4544: PUSH
4545: EMPTY
4546: LIST
4547: LIST
4548: LIST
4549: LIST
4550: LIST
4551: LIST
4552: PUSH
4553: LD_INT 33
4555: PUSH
4556: LD_INT 51
4558: PUSH
4559: LD_INT 6
4561: PUSH
4562: LD_INT 4
4564: PUSH
4565: LD_INT 0
4567: PUSH
4568: LD_INT 0
4570: PUSH
4571: EMPTY
4572: LIST
4573: LIST
4574: LIST
4575: LIST
4576: LIST
4577: LIST
4578: PUSH
4579: LD_INT 26
4581: PUSH
4582: LD_INT 39
4584: PUSH
4585: LD_INT 25
4587: PUSH
4588: LD_INT 0
4590: PUSH
4591: LD_INT 0
4593: PUSH
4594: LD_INT 0
4596: PUSH
4597: EMPTY
4598: LIST
4599: LIST
4600: LIST
4601: LIST
4602: LIST
4603: LIST
4604: PUSH
4605: LD_INT 26
4607: PUSH
4608: LD_INT 37
4610: PUSH
4611: LD_INT 21
4613: PUSH
4614: LD_INT 0
4616: PUSH
4617: LD_INT 0
4619: PUSH
4620: LD_INT 0
4622: PUSH
4623: EMPTY
4624: LIST
4625: LIST
4626: LIST
4627: LIST
4628: LIST
4629: LIST
4630: PUSH
4631: LD_INT 32
4633: PUSH
4634: LD_INT 35
4636: PUSH
4637: LD_INT 17
4639: PUSH
4640: LD_INT 4
4642: PUSH
4643: LD_INT 0
4645: PUSH
4646: LD_INT 0
4648: PUSH
4649: EMPTY
4650: LIST
4651: LIST
4652: LIST
4653: LIST
4654: LIST
4655: LIST
4656: PUSH
4657: LD_INT 33
4659: PUSH
4660: LD_INT 35
4662: PUSH
4663: LD_INT 28
4665: PUSH
4666: LD_INT 4
4668: PUSH
4669: LD_INT 0
4671: PUSH
4672: LD_INT 0
4674: PUSH
4675: EMPTY
4676: LIST
4677: LIST
4678: LIST
4679: LIST
4680: LIST
4681: LIST
4682: PUSH
4683: LD_INT 33
4685: PUSH
4686: LD_INT 28
4688: PUSH
4689: LD_INT 46
4691: PUSH
4692: LD_INT 5
4694: PUSH
4695: LD_INT 0
4697: PUSH
4698: LD_INT 0
4700: PUSH
4701: EMPTY
4702: LIST
4703: LIST
4704: LIST
4705: LIST
4706: LIST
4707: LIST
4708: PUSH
4709: LD_INT 33
4711: PUSH
4712: LD_INT 31
4714: PUSH
4715: LD_INT 6
4717: PUSH
4718: LD_INT 4
4720: PUSH
4721: LD_INT 0
4723: PUSH
4724: LD_INT 0
4726: PUSH
4727: EMPTY
4728: LIST
4729: LIST
4730: LIST
4731: LIST
4732: LIST
4733: LIST
4734: PUSH
4735: LD_INT 26
4737: PUSH
4738: LD_INT 54
4740: PUSH
4741: LD_INT 38
4743: PUSH
4744: LD_INT 4
4746: PUSH
4747: LD_INT 0
4749: PUSH
4750: LD_INT 0
4752: PUSH
4753: EMPTY
4754: LIST
4755: LIST
4756: LIST
4757: LIST
4758: LIST
4759: LIST
4760: PUSH
4761: LD_INT 33
4763: PUSH
4764: LD_INT 207
4766: PUSH
4767: LD_INT 167
4769: PUSH
4770: LD_INT 3
4772: PUSH
4773: LD_INT 0
4775: PUSH
4776: LD_INT 0
4778: PUSH
4779: EMPTY
4780: LIST
4781: LIST
4782: LIST
4783: LIST
4784: LIST
4785: LIST
4786: PUSH
4787: LD_INT 30
4789: PUSH
4790: LD_INT 43
4792: PUSH
4793: LD_INT 2
4795: PUSH
4796: LD_INT 4
4798: PUSH
4799: LD_INT 0
4801: PUSH
4802: LD_INT 0
4804: PUSH
4805: EMPTY
4806: LIST
4807: LIST
4808: LIST
4809: LIST
4810: LIST
4811: LIST
4812: PUSH
4813: EMPTY
4814: LIST
4815: LIST
4816: LIST
4817: LIST
4818: LIST
4819: LIST
4820: LIST
4821: LIST
4822: LIST
4823: LIST
4824: LIST
4825: LIST
4826: LIST
4827: LIST
4828: LIST
4829: LIST
4830: LIST
4831: LIST
4832: LIST
4833: LIST
4834: LIST
4835: LIST
4836: LIST
4837: LIST
4838: LIST
4839: LIST
4840: LIST
4841: LIST
4842: LIST
4843: LIST
4844: LIST
4845: LIST
4846: LIST
4847: LIST
4848: LIST
4849: LIST
4850: LIST
4851: LIST
4852: LIST
4853: LIST
4854: LIST
4855: LIST
4856: LIST
4857: LIST
4858: LIST
4859: LIST
4860: LIST
4861: LIST
4862: LIST
4863: LIST
4864: LIST
4865: LIST
4866: LIST
4867: LIST
4868: LIST
4869: LIST
4870: LIST
4871: LIST
4872: LIST
4873: LIST
4874: LIST
4875: LIST
4876: LIST
4877: LIST
4878: LIST
4879: LIST
4880: LIST
4881: LIST
4882: LIST
4883: LIST
4884: LIST
4885: LIST
4886: LIST
4887: LIST
4888: LIST
4889: LIST
4890: LIST
4891: LIST
4892: LIST
4893: LIST
4894: LIST
4895: LIST
4896: LIST
4897: LIST
4898: LIST
4899: ST_TO_ADDR
// for i in tmp do
4900: LD_ADDR_VAR 0 2
4904: PUSH
4905: LD_VAR 0 4
4909: PUSH
4910: FOR_IN
4911: IFFALSE 5142
// begin uc_side := side ;
4913: LD_ADDR_OWVAR 20
4917: PUSH
4918: LD_VAR 0 5
4922: ST_TO_ADDR
// uc_nation := nation_russian ;
4923: LD_ADDR_OWVAR 21
4927: PUSH
4928: LD_INT 3
4930: ST_TO_ADDR
// bc_type := i [ 1 ] ;
4931: LD_ADDR_OWVAR 42
4935: PUSH
4936: LD_VAR 0 2
4940: PUSH
4941: LD_INT 1
4943: ARRAY
4944: ST_TO_ADDR
// bc_level := rand ( 5 , 6 ) ;
4945: LD_ADDR_OWVAR 43
4949: PUSH
4950: LD_INT 5
4952: PPUSH
4953: LD_INT 6
4955: PPUSH
4956: CALL_OW 12
4960: ST_TO_ADDR
// bc_kind1 := i [ 5 ] ;
4961: LD_ADDR_OWVAR 44
4965: PUSH
4966: LD_VAR 0 2
4970: PUSH
4971: LD_INT 5
4973: ARRAY
4974: ST_TO_ADDR
// bc_kind2 := i [ 6 ] ;
4975: LD_ADDR_OWVAR 45
4979: PUSH
4980: LD_VAR 0 2
4984: PUSH
4985: LD_INT 6
4987: ARRAY
4988: ST_TO_ADDR
// sr := 0 ;
4989: LD_ADDR_VAR 0 6
4993: PUSH
4994: LD_INT 0
4996: ST_TO_ADDR
// if i [ 1 ] = b_oil_mine then
4997: LD_VAR 0 2
5001: PUSH
5002: LD_INT 1
5004: ARRAY
5005: PUSH
5006: LD_INT 29
5008: EQUAL
5009: IFFALSE 5021
// sr := mat_oil else
5011: LD_ADDR_VAR 0 6
5015: PUSH
5016: LD_INT 2
5018: ST_TO_ADDR
5019: GO 5043
// if i [ 1 ] = b_siberite_mine then
5021: LD_VAR 0 2
5025: PUSH
5026: LD_INT 1
5028: ARRAY
5029: PUSH
5030: LD_INT 30
5032: EQUAL
5033: IFFALSE 5043
// sr := mat_siberit ;
5035: LD_ADDR_VAR 0 6
5039: PUSH
5040: LD_INT 3
5042: ST_TO_ADDR
// if sr then
5043: LD_VAR 0 6
5047: IFFALSE 5103
// begin CreateDepositXY ( i [ 2 ] , i [ 3 ] , sr ) ;
5049: LD_VAR 0 2
5053: PUSH
5054: LD_INT 2
5056: ARRAY
5057: PPUSH
5058: LD_VAR 0 2
5062: PUSH
5063: LD_INT 3
5065: ARRAY
5066: PPUSH
5067: LD_VAR 0 6
5071: PPUSH
5072: CALL_OW 62
// SetResourceVisibility ( i [ 2 ] , i [ 3 ] , side ) ;
5076: LD_VAR 0 2
5080: PUSH
5081: LD_INT 2
5083: ARRAY
5084: PPUSH
5085: LD_VAR 0 2
5089: PUSH
5090: LD_INT 3
5092: ARRAY
5093: PPUSH
5094: LD_VAR 0 5
5098: PPUSH
5099: CALL_OW 441
// end ; b := CreateAndPlaceBuildingXYD ( i [ 2 ] , i [ 3 ] , i [ 4 ] ) ;
5103: LD_ADDR_VAR 0 3
5107: PUSH
5108: LD_VAR 0 2
5112: PUSH
5113: LD_INT 2
5115: ARRAY
5116: PPUSH
5117: LD_VAR 0 2
5121: PUSH
5122: LD_INT 3
5124: ARRAY
5125: PPUSH
5126: LD_VAR 0 2
5130: PUSH
5131: LD_INT 4
5133: ARRAY
5134: PPUSH
5135: CALL_OW 47
5139: ST_TO_ADDR
// end ;
5140: GO 4910
5142: POP
5143: POP
// depot := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_warehouse ] ] ) ;
5144: LD_ADDR_VAR 0 7
5148: PUSH
5149: LD_INT 22
5151: PUSH
5152: LD_VAR 0 5
5156: PUSH
5157: EMPTY
5158: LIST
5159: LIST
5160: PUSH
5161: LD_INT 30
5163: PUSH
5164: LD_INT 1
5166: PUSH
5167: EMPTY
5168: LIST
5169: LIST
5170: PUSH
5171: EMPTY
5172: LIST
5173: LIST
5174: PPUSH
5175: CALL_OW 69
5179: ST_TO_ADDR
// if not depot then
5180: LD_VAR 0 7
5184: NOT
5185: IFFALSE 5189
// exit ;
5187: GO 5533
// base := PrepareBase ( HexInfo ( 84 , 128 ) , rus1Base , 0 , [ 6 , 7 , 8 ] [ Difficulty ] , [ 3000 , 300 , 100 ] , [ 12 , 6 , 6 , 4 ] ) ;
5189: LD_ADDR_VAR 0 8
5193: PUSH
5194: LD_INT 84
5196: PPUSH
5197: LD_INT 128
5199: PPUSH
5200: CALL_OW 428
5204: PPUSH
5205: LD_INT 15
5207: PPUSH
5208: LD_INT 0
5210: PPUSH
5211: LD_INT 6
5213: PUSH
5214: LD_INT 7
5216: PUSH
5217: LD_INT 8
5219: PUSH
5220: EMPTY
5221: LIST
5222: LIST
5223: LIST
5224: PUSH
5225: LD_OWVAR 67
5229: ARRAY
5230: PPUSH
5231: LD_INT 3000
5233: PUSH
5234: LD_INT 300
5236: PUSH
5237: LD_INT 100
5239: PUSH
5240: EMPTY
5241: LIST
5242: LIST
5243: LIST
5244: PPUSH
5245: LD_INT 12
5247: PUSH
5248: LD_INT 6
5250: PUSH
5251: LD_INT 6
5253: PUSH
5254: LD_INT 4
5256: PUSH
5257: EMPTY
5258: LIST
5259: LIST
5260: LIST
5261: LIST
5262: PPUSH
5263: CALL 28177 0 6
5267: ST_TO_ADDR
// if not base then
5268: LD_VAR 0 8
5272: NOT
5273: IFFALSE 5277
// exit ;
5275: GO 5533
// mc_bases := Replace ( mc_bases , mc_rus_1 , base ) ;
5277: LD_ADDR_EXP 31
5281: PUSH
5282: LD_EXP 31
5286: PPUSH
5287: LD_EXP 7
5291: PPUSH
5292: LD_VAR 0 8
5296: PPUSH
5297: CALL_OW 1
5301: ST_TO_ADDR
// base := PrepareBase ( HexInfo ( 34 , 23 ) , rus2Base , 0 , [ 6 , 7 , 8 ] [ Difficulty ] , [ 20000 , 3000 , 1000 ] , [ 12 , 6 , 6 , 4 ] ) ;
5302: LD_ADDR_VAR 0 8
5306: PUSH
5307: LD_INT 34
5309: PPUSH
5310: LD_INT 23
5312: PPUSH
5313: CALL_OW 428
5317: PPUSH
5318: LD_INT 11
5320: PPUSH
5321: LD_INT 0
5323: PPUSH
5324: LD_INT 6
5326: PUSH
5327: LD_INT 7
5329: PUSH
5330: LD_INT 8
5332: PUSH
5333: EMPTY
5334: LIST
5335: LIST
5336: LIST
5337: PUSH
5338: LD_OWVAR 67
5342: ARRAY
5343: PPUSH
5344: LD_INT 20000
5346: PUSH
5347: LD_INT 3000
5349: PUSH
5350: LD_INT 1000
5352: PUSH
5353: EMPTY
5354: LIST
5355: LIST
5356: LIST
5357: PPUSH
5358: LD_INT 12
5360: PUSH
5361: LD_INT 6
5363: PUSH
5364: LD_INT 6
5366: PUSH
5367: LD_INT 4
5369: PUSH
5370: EMPTY
5371: LIST
5372: LIST
5373: LIST
5374: LIST
5375: PPUSH
5376: CALL 28177 0 6
5380: ST_TO_ADDR
// if not base then
5381: LD_VAR 0 8
5385: NOT
5386: IFFALSE 5390
// exit ;
5388: GO 5533
// mc_bases := Replace ( mc_bases , mc_rus_2 , base ) ;
5390: LD_ADDR_EXP 31
5394: PUSH
5395: LD_EXP 31
5399: PPUSH
5400: LD_EXP 8
5404: PPUSH
5405: LD_VAR 0 8
5409: PPUSH
5410: CALL_OW 1
5414: ST_TO_ADDR
// ruOutpost := PrepareBase ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_depot ] ] ) [ 1 ] , ruOutpostArea , 0 , [ 6 , 7 , 8 ] [ Difficulty ] , [ 500 , 100 , 10 ] , [ [ 6 , 7 , 8 ] [ Difficulty ] , 2 , 0 , 1 ] ) ;
5415: LD_ADDR_EXP 14
5419: PUSH
5420: LD_INT 22
5422: PUSH
5423: LD_INT 3
5425: PUSH
5426: EMPTY
5427: LIST
5428: LIST
5429: PUSH
5430: LD_INT 30
5432: PUSH
5433: LD_INT 0
5435: PUSH
5436: EMPTY
5437: LIST
5438: LIST
5439: PUSH
5440: EMPTY
5441: LIST
5442: LIST
5443: PPUSH
5444: CALL_OW 69
5448: PUSH
5449: LD_INT 1
5451: ARRAY
5452: PPUSH
5453: LD_INT 25
5455: PPUSH
5456: LD_INT 0
5458: PPUSH
5459: LD_INT 6
5461: PUSH
5462: LD_INT 7
5464: PUSH
5465: LD_INT 8
5467: PUSH
5468: EMPTY
5469: LIST
5470: LIST
5471: LIST
5472: PUSH
5473: LD_OWVAR 67
5477: ARRAY
5478: PPUSH
5479: LD_INT 500
5481: PUSH
5482: LD_INT 100
5484: PUSH
5485: LD_INT 10
5487: PUSH
5488: EMPTY
5489: LIST
5490: LIST
5491: LIST
5492: PPUSH
5493: LD_INT 6
5495: PUSH
5496: LD_INT 7
5498: PUSH
5499: LD_INT 8
5501: PUSH
5502: EMPTY
5503: LIST
5504: LIST
5505: LIST
5506: PUSH
5507: LD_OWVAR 67
5511: ARRAY
5512: PUSH
5513: LD_INT 2
5515: PUSH
5516: LD_INT 0
5518: PUSH
5519: LD_INT 1
5521: PUSH
5522: EMPTY
5523: LIST
5524: LIST
5525: LIST
5526: LIST
5527: PPUSH
5528: CALL 28177 0 6
5532: ST_TO_ADDR
// end ;
5533: LD_VAR 0 1
5537: RET
// export function PrepareLegion ; var i , b , veh , tmp , tmp2 , cameras , side , sr , depot , base ; begin
5538: LD_INT 0
5540: PPUSH
5541: PPUSH
5542: PPUSH
5543: PPUSH
5544: PPUSH
5545: PPUSH
5546: PPUSH
5547: PPUSH
5548: PPUSH
5549: PPUSH
5550: PPUSH
// PrepareNature ( 0 , 0 , 6 , 0 , 0 , 0 , 0 , legApe , 0 ) ;
5551: LD_INT 0
5553: PPUSH
5554: LD_INT 0
5556: PPUSH
5557: LD_INT 6
5559: PPUSH
5560: LD_INT 0
5562: PPUSH
5563: LD_INT 0
5565: PPUSH
5566: LD_INT 0
5568: PPUSH
5569: LD_INT 0
5571: PPUSH
5572: LD_INT 8
5574: PPUSH
5575: LD_INT 0
5577: PPUSH
5578: CALL 53895 0 9
// side := 8 ;
5582: LD_ADDR_VAR 0 8
5586: PUSH
5587: LD_INT 8
5589: ST_TO_ADDR
// tmp := AreaToList ( minesArea , 0 ) ;
5590: LD_ADDR_VAR 0 5
5594: PUSH
5595: LD_INT 20
5597: PPUSH
5598: LD_INT 0
5600: PPUSH
5601: CALL_OW 517
5605: ST_TO_ADDR
// if Difficulty > 2 then
5606: LD_OWVAR 67
5610: PUSH
5611: LD_INT 2
5613: GREATER
5614: IFFALSE 5758
// begin tmp2 := AreaToList ( minesArea2 , 0 ) ;
5616: LD_ADDR_VAR 0 6
5620: PUSH
5621: LD_INT 27
5623: PPUSH
5624: LD_INT 0
5626: PPUSH
5627: CALL_OW 517
5631: ST_TO_ADDR
// for i = 1 to tmp2 [ 1 ] do
5632: LD_ADDR_VAR 0 2
5636: PUSH
5637: DOUBLE
5638: LD_INT 1
5640: DEC
5641: ST_TO_ADDR
5642: LD_VAR 0 6
5646: PUSH
5647: LD_INT 1
5649: ARRAY
5650: PUSH
5651: FOR_TO
5652: IFFALSE 5756
// begin tmp := ReplaceIn ( tmp , [ 1 , tmp [ 1 ] + 1 ] , tmp2 [ 1 ] [ i ] ) ;
5654: LD_ADDR_VAR 0 5
5658: PUSH
5659: LD_VAR 0 5
5663: PPUSH
5664: LD_INT 1
5666: PUSH
5667: LD_VAR 0 5
5671: PUSH
5672: LD_INT 1
5674: ARRAY
5675: PUSH
5676: LD_INT 1
5678: PLUS
5679: PUSH
5680: EMPTY
5681: LIST
5682: LIST
5683: PPUSH
5684: LD_VAR 0 6
5688: PUSH
5689: LD_INT 1
5691: ARRAY
5692: PUSH
5693: LD_VAR 0 2
5697: ARRAY
5698: PPUSH
5699: CALL 24846 0 3
5703: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 2 , tmp [ 2 ] + 1 ] , tmp2 [ 2 ] [ i ] ) ;
5704: LD_ADDR_VAR 0 5
5708: PUSH
5709: LD_VAR 0 5
5713: PPUSH
5714: LD_INT 2
5716: PUSH
5717: LD_VAR 0 5
5721: PUSH
5722: LD_INT 2
5724: ARRAY
5725: PUSH
5726: LD_INT 1
5728: PLUS
5729: PUSH
5730: EMPTY
5731: LIST
5732: LIST
5733: PPUSH
5734: LD_VAR 0 6
5738: PUSH
5739: LD_INT 2
5741: ARRAY
5742: PUSH
5743: LD_VAR 0 2
5747: ARRAY
5748: PPUSH
5749: CALL 24846 0 3
5753: ST_TO_ADDR
// end ;
5754: GO 5651
5756: POP
5757: POP
// end ; if tmp then
5758: LD_VAR 0 5
5762: IFFALSE 5890
// begin for i = 1 to tmp [ 1 ] do
5764: LD_ADDR_VAR 0 2
5768: PUSH
5769: DOUBLE
5770: LD_INT 1
5772: DEC
5773: ST_TO_ADDR
5774: LD_VAR 0 5
5778: PUSH
5779: LD_INT 1
5781: ARRAY
5782: PUSH
5783: FOR_TO
5784: IFFALSE 5888
// begin PlaceMine ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] , side , 0 ) ;
5786: LD_VAR 0 5
5790: PUSH
5791: LD_INT 1
5793: ARRAY
5794: PUSH
5795: LD_VAR 0 2
5799: ARRAY
5800: PPUSH
5801: LD_VAR 0 5
5805: PUSH
5806: LD_INT 2
5808: ARRAY
5809: PUSH
5810: LD_VAR 0 2
5814: ARRAY
5815: PPUSH
5816: LD_VAR 0 8
5820: PPUSH
5821: LD_INT 0
5823: PPUSH
5824: CALL_OW 454
// staticMines := Insert ( staticMines , staticMines + 1 , [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ) ;
5828: LD_ADDR_EXP 16
5832: PUSH
5833: LD_EXP 16
5837: PPUSH
5838: LD_EXP 16
5842: PUSH
5843: LD_INT 1
5845: PLUS
5846: PPUSH
5847: LD_VAR 0 5
5851: PUSH
5852: LD_INT 1
5854: ARRAY
5855: PUSH
5856: LD_VAR 0 2
5860: ARRAY
5861: PUSH
5862: LD_VAR 0 5
5866: PUSH
5867: LD_INT 2
5869: ARRAY
5870: PUSH
5871: LD_VAR 0 2
5875: ARRAY
5876: PUSH
5877: EMPTY
5878: LIST
5879: LIST
5880: PPUSH
5881: CALL_OW 2
5885: ST_TO_ADDR
// end ;
5886: GO 5783
5888: POP
5889: POP
// end ; cameras := [ [ 165 , 156 ] , [ 143 , 145 ] , [ 152 , 165 ] , [ 123 , 153 ] , [ 161 , 215 ] , [ 172 , 100 ] , [ 148 , 83 ] , [ 122 , 68 ] , [ 105 , 74 ] , [ 113 , 97 ] ] ;
5890: LD_ADDR_VAR 0 7
5894: PUSH
5895: LD_INT 165
5897: PUSH
5898: LD_INT 156
5900: PUSH
5901: EMPTY
5902: LIST
5903: LIST
5904: PUSH
5905: LD_INT 143
5907: PUSH
5908: LD_INT 145
5910: PUSH
5911: EMPTY
5912: LIST
5913: LIST
5914: PUSH
5915: LD_INT 152
5917: PUSH
5918: LD_INT 165
5920: PUSH
5921: EMPTY
5922: LIST
5923: LIST
5924: PUSH
5925: LD_INT 123
5927: PUSH
5928: LD_INT 153
5930: PUSH
5931: EMPTY
5932: LIST
5933: LIST
5934: PUSH
5935: LD_INT 161
5937: PUSH
5938: LD_INT 215
5940: PUSH
5941: EMPTY
5942: LIST
5943: LIST
5944: PUSH
5945: LD_INT 172
5947: PUSH
5948: LD_INT 100
5950: PUSH
5951: EMPTY
5952: LIST
5953: LIST
5954: PUSH
5955: LD_INT 148
5957: PUSH
5958: LD_INT 83
5960: PUSH
5961: EMPTY
5962: LIST
5963: LIST
5964: PUSH
5965: LD_INT 122
5967: PUSH
5968: LD_INT 68
5970: PUSH
5971: EMPTY
5972: LIST
5973: LIST
5974: PUSH
5975: LD_INT 105
5977: PUSH
5978: LD_INT 74
5980: PUSH
5981: EMPTY
5982: LIST
5983: LIST
5984: PUSH
5985: LD_INT 113
5987: PUSH
5988: LD_INT 97
5990: PUSH
5991: EMPTY
5992: LIST
5993: LIST
5994: PUSH
5995: EMPTY
5996: LIST
5997: LIST
5998: LIST
5999: LIST
6000: LIST
6001: LIST
6002: LIST
6003: LIST
6004: LIST
6005: LIST
6006: ST_TO_ADDR
// for i in cameras do
6007: LD_ADDR_VAR 0 2
6011: PUSH
6012: LD_VAR 0 7
6016: PUSH
6017: FOR_IN
6018: IFFALSE 6049
// HiddenCamera ( i [ 1 ] , i [ 2 ] , side ) ;
6020: LD_VAR 0 2
6024: PUSH
6025: LD_INT 1
6027: ARRAY
6028: PPUSH
6029: LD_VAR 0 2
6033: PUSH
6034: LD_INT 2
6036: ARRAY
6037: PPUSH
6038: LD_VAR 0 8
6042: PPUSH
6043: CALL_OW 244
6047: GO 6017
6049: POP
6050: POP
// tmp := [ [ 1 , 144 , 110 , 1 , 0 , 0 ] , [ 3 , 151 , 118 , 0 , 0 , 0 ] , [ 8 , 158 , 110 , 4 , 10 , 15 ] , [ 23 , 154 , 121 , 5 , 0 , 0 ] , [ 22 , 155 , 118 , 4 , 0 , 0 ] , [ 21 , 151 , 122 , 0 , 0 , 0 ] , [ 18 , 148 , 118 , 1 , 0 , 0 ] , [ 17 , 147 , 114 , 2 , 0 , 0 ] , [ 29 , 163 , 120 , 5 , 0 , 0 ] , [ 27 , 137 , 116 , 3 , 0 , 0 ] , [ 27 , 133 , 111 , 1 , 0 , 0 ] , [ 27 , 132 , 106 , 4 , 0 , 0 ] , [ 26 , 137 , 111 , 0 , 0 , 0 ] , [ 8 , 141 , 117 , 1 , 13 , 11 ] , [ 30 , 140 , 128 , 1 , 0 , 0 ] , [ 5 , 146 , 96 , 3 , 0 , 0 ] , [ 32 , 150 , 98 , 3 , 0 , 0 ] , [ 32 , 142 , 95 , 3 , 0 , 0 ] , [ 32 , 159 , 104 , 3 , 0 , 0 ] , [ 32 , 133 , 95 , 3 , 0 , 0 ] , [ 32 , 131 , 102 , 2 , 0 , 0 ] , [ 32 , 164 , 144 , 0 , 0 , 0 ] , [ 32 , 146 , 139 , 0 , 0 , 0 ] , [ 26 , 143 , 122 , 4 , 0 , 0 ] , [ 26 , 164 , 116 , 2 , 0 , 0 ] , ] ;
6051: LD_ADDR_VAR 0 5
6055: PUSH
6056: LD_INT 1
6058: PUSH
6059: LD_INT 144
6061: PUSH
6062: LD_INT 110
6064: PUSH
6065: LD_INT 1
6067: PUSH
6068: LD_INT 0
6070: PUSH
6071: LD_INT 0
6073: PUSH
6074: EMPTY
6075: LIST
6076: LIST
6077: LIST
6078: LIST
6079: LIST
6080: LIST
6081: PUSH
6082: LD_INT 3
6084: PUSH
6085: LD_INT 151
6087: PUSH
6088: LD_INT 118
6090: PUSH
6091: LD_INT 0
6093: PUSH
6094: LD_INT 0
6096: PUSH
6097: LD_INT 0
6099: PUSH
6100: EMPTY
6101: LIST
6102: LIST
6103: LIST
6104: LIST
6105: LIST
6106: LIST
6107: PUSH
6108: LD_INT 8
6110: PUSH
6111: LD_INT 158
6113: PUSH
6114: LD_INT 110
6116: PUSH
6117: LD_INT 4
6119: PUSH
6120: LD_INT 10
6122: PUSH
6123: LD_INT 15
6125: PUSH
6126: EMPTY
6127: LIST
6128: LIST
6129: LIST
6130: LIST
6131: LIST
6132: LIST
6133: PUSH
6134: LD_INT 23
6136: PUSH
6137: LD_INT 154
6139: PUSH
6140: LD_INT 121
6142: PUSH
6143: LD_INT 5
6145: PUSH
6146: LD_INT 0
6148: PUSH
6149: LD_INT 0
6151: PUSH
6152: EMPTY
6153: LIST
6154: LIST
6155: LIST
6156: LIST
6157: LIST
6158: LIST
6159: PUSH
6160: LD_INT 22
6162: PUSH
6163: LD_INT 155
6165: PUSH
6166: LD_INT 118
6168: PUSH
6169: LD_INT 4
6171: PUSH
6172: LD_INT 0
6174: PUSH
6175: LD_INT 0
6177: PUSH
6178: EMPTY
6179: LIST
6180: LIST
6181: LIST
6182: LIST
6183: LIST
6184: LIST
6185: PUSH
6186: LD_INT 21
6188: PUSH
6189: LD_INT 151
6191: PUSH
6192: LD_INT 122
6194: PUSH
6195: LD_INT 0
6197: PUSH
6198: LD_INT 0
6200: PUSH
6201: LD_INT 0
6203: PUSH
6204: EMPTY
6205: LIST
6206: LIST
6207: LIST
6208: LIST
6209: LIST
6210: LIST
6211: PUSH
6212: LD_INT 18
6214: PUSH
6215: LD_INT 148
6217: PUSH
6218: LD_INT 118
6220: PUSH
6221: LD_INT 1
6223: PUSH
6224: LD_INT 0
6226: PUSH
6227: LD_INT 0
6229: PUSH
6230: EMPTY
6231: LIST
6232: LIST
6233: LIST
6234: LIST
6235: LIST
6236: LIST
6237: PUSH
6238: LD_INT 17
6240: PUSH
6241: LD_INT 147
6243: PUSH
6244: LD_INT 114
6246: PUSH
6247: LD_INT 2
6249: PUSH
6250: LD_INT 0
6252: PUSH
6253: LD_INT 0
6255: PUSH
6256: EMPTY
6257: LIST
6258: LIST
6259: LIST
6260: LIST
6261: LIST
6262: LIST
6263: PUSH
6264: LD_INT 29
6266: PUSH
6267: LD_INT 163
6269: PUSH
6270: LD_INT 120
6272: PUSH
6273: LD_INT 5
6275: PUSH
6276: LD_INT 0
6278: PUSH
6279: LD_INT 0
6281: PUSH
6282: EMPTY
6283: LIST
6284: LIST
6285: LIST
6286: LIST
6287: LIST
6288: LIST
6289: PUSH
6290: LD_INT 27
6292: PUSH
6293: LD_INT 137
6295: PUSH
6296: LD_INT 116
6298: PUSH
6299: LD_INT 3
6301: PUSH
6302: LD_INT 0
6304: PUSH
6305: LD_INT 0
6307: PUSH
6308: EMPTY
6309: LIST
6310: LIST
6311: LIST
6312: LIST
6313: LIST
6314: LIST
6315: PUSH
6316: LD_INT 27
6318: PUSH
6319: LD_INT 133
6321: PUSH
6322: LD_INT 111
6324: PUSH
6325: LD_INT 1
6327: PUSH
6328: LD_INT 0
6330: PUSH
6331: LD_INT 0
6333: PUSH
6334: EMPTY
6335: LIST
6336: LIST
6337: LIST
6338: LIST
6339: LIST
6340: LIST
6341: PUSH
6342: LD_INT 27
6344: PUSH
6345: LD_INT 132
6347: PUSH
6348: LD_INT 106
6350: PUSH
6351: LD_INT 4
6353: PUSH
6354: LD_INT 0
6356: PUSH
6357: LD_INT 0
6359: PUSH
6360: EMPTY
6361: LIST
6362: LIST
6363: LIST
6364: LIST
6365: LIST
6366: LIST
6367: PUSH
6368: LD_INT 26
6370: PUSH
6371: LD_INT 137
6373: PUSH
6374: LD_INT 111
6376: PUSH
6377: LD_INT 0
6379: PUSH
6380: LD_INT 0
6382: PUSH
6383: LD_INT 0
6385: PUSH
6386: EMPTY
6387: LIST
6388: LIST
6389: LIST
6390: LIST
6391: LIST
6392: LIST
6393: PUSH
6394: LD_INT 8
6396: PUSH
6397: LD_INT 141
6399: PUSH
6400: LD_INT 117
6402: PUSH
6403: LD_INT 1
6405: PUSH
6406: LD_INT 13
6408: PUSH
6409: LD_INT 11
6411: PUSH
6412: EMPTY
6413: LIST
6414: LIST
6415: LIST
6416: LIST
6417: LIST
6418: LIST
6419: PUSH
6420: LD_INT 30
6422: PUSH
6423: LD_INT 140
6425: PUSH
6426: LD_INT 128
6428: PUSH
6429: LD_INT 1
6431: PUSH
6432: LD_INT 0
6434: PUSH
6435: LD_INT 0
6437: PUSH
6438: EMPTY
6439: LIST
6440: LIST
6441: LIST
6442: LIST
6443: LIST
6444: LIST
6445: PUSH
6446: LD_INT 5
6448: PUSH
6449: LD_INT 146
6451: PUSH
6452: LD_INT 96
6454: PUSH
6455: LD_INT 3
6457: PUSH
6458: LD_INT 0
6460: PUSH
6461: LD_INT 0
6463: PUSH
6464: EMPTY
6465: LIST
6466: LIST
6467: LIST
6468: LIST
6469: LIST
6470: LIST
6471: PUSH
6472: LD_INT 32
6474: PUSH
6475: LD_INT 150
6477: PUSH
6478: LD_INT 98
6480: PUSH
6481: LD_INT 3
6483: PUSH
6484: LD_INT 0
6486: PUSH
6487: LD_INT 0
6489: PUSH
6490: EMPTY
6491: LIST
6492: LIST
6493: LIST
6494: LIST
6495: LIST
6496: LIST
6497: PUSH
6498: LD_INT 32
6500: PUSH
6501: LD_INT 142
6503: PUSH
6504: LD_INT 95
6506: PUSH
6507: LD_INT 3
6509: PUSH
6510: LD_INT 0
6512: PUSH
6513: LD_INT 0
6515: PUSH
6516: EMPTY
6517: LIST
6518: LIST
6519: LIST
6520: LIST
6521: LIST
6522: LIST
6523: PUSH
6524: LD_INT 32
6526: PUSH
6527: LD_INT 159
6529: PUSH
6530: LD_INT 104
6532: PUSH
6533: LD_INT 3
6535: PUSH
6536: LD_INT 0
6538: PUSH
6539: LD_INT 0
6541: PUSH
6542: EMPTY
6543: LIST
6544: LIST
6545: LIST
6546: LIST
6547: LIST
6548: LIST
6549: PUSH
6550: LD_INT 32
6552: PUSH
6553: LD_INT 133
6555: PUSH
6556: LD_INT 95
6558: PUSH
6559: LD_INT 3
6561: PUSH
6562: LD_INT 0
6564: PUSH
6565: LD_INT 0
6567: PUSH
6568: EMPTY
6569: LIST
6570: LIST
6571: LIST
6572: LIST
6573: LIST
6574: LIST
6575: PUSH
6576: LD_INT 32
6578: PUSH
6579: LD_INT 131
6581: PUSH
6582: LD_INT 102
6584: PUSH
6585: LD_INT 2
6587: PUSH
6588: LD_INT 0
6590: PUSH
6591: LD_INT 0
6593: PUSH
6594: EMPTY
6595: LIST
6596: LIST
6597: LIST
6598: LIST
6599: LIST
6600: LIST
6601: PUSH
6602: LD_INT 32
6604: PUSH
6605: LD_INT 164
6607: PUSH
6608: LD_INT 144
6610: PUSH
6611: LD_INT 0
6613: PUSH
6614: LD_INT 0
6616: PUSH
6617: LD_INT 0
6619: PUSH
6620: EMPTY
6621: LIST
6622: LIST
6623: LIST
6624: LIST
6625: LIST
6626: LIST
6627: PUSH
6628: LD_INT 32
6630: PUSH
6631: LD_INT 146
6633: PUSH
6634: LD_INT 139
6636: PUSH
6637: LD_INT 0
6639: PUSH
6640: LD_INT 0
6642: PUSH
6643: LD_INT 0
6645: PUSH
6646: EMPTY
6647: LIST
6648: LIST
6649: LIST
6650: LIST
6651: LIST
6652: LIST
6653: PUSH
6654: LD_INT 26
6656: PUSH
6657: LD_INT 143
6659: PUSH
6660: LD_INT 122
6662: PUSH
6663: LD_INT 4
6665: PUSH
6666: LD_INT 0
6668: PUSH
6669: LD_INT 0
6671: PUSH
6672: EMPTY
6673: LIST
6674: LIST
6675: LIST
6676: LIST
6677: LIST
6678: LIST
6679: PUSH
6680: LD_INT 26
6682: PUSH
6683: LD_INT 164
6685: PUSH
6686: LD_INT 116
6688: PUSH
6689: LD_INT 2
6691: PUSH
6692: LD_INT 0
6694: PUSH
6695: LD_INT 0
6697: PUSH
6698: EMPTY
6699: LIST
6700: LIST
6701: LIST
6702: LIST
6703: LIST
6704: LIST
6705: PUSH
6706: EMPTY
6707: LIST
6708: LIST
6709: LIST
6710: LIST
6711: LIST
6712: LIST
6713: LIST
6714: LIST
6715: LIST
6716: LIST
6717: LIST
6718: LIST
6719: LIST
6720: LIST
6721: LIST
6722: LIST
6723: LIST
6724: LIST
6725: LIST
6726: LIST
6727: LIST
6728: LIST
6729: LIST
6730: LIST
6731: LIST
6732: ST_TO_ADDR
// for i in tmp do
6733: LD_ADDR_VAR 0 2
6737: PUSH
6738: LD_VAR 0 5
6742: PUSH
6743: FOR_IN
6744: IFFALSE 6975
// begin uc_side := side ;
6746: LD_ADDR_OWVAR 20
6750: PUSH
6751: LD_VAR 0 8
6755: ST_TO_ADDR
// uc_nation := nation_arabian ;
6756: LD_ADDR_OWVAR 21
6760: PUSH
6761: LD_INT 2
6763: ST_TO_ADDR
// bc_type := i [ 1 ] ;
6764: LD_ADDR_OWVAR 42
6768: PUSH
6769: LD_VAR 0 2
6773: PUSH
6774: LD_INT 1
6776: ARRAY
6777: ST_TO_ADDR
// bc_level := rand ( 5 , 6 ) ;
6778: LD_ADDR_OWVAR 43
6782: PUSH
6783: LD_INT 5
6785: PPUSH
6786: LD_INT 6
6788: PPUSH
6789: CALL_OW 12
6793: ST_TO_ADDR
// bc_kind1 := i [ 5 ] ;
6794: LD_ADDR_OWVAR 44
6798: PUSH
6799: LD_VAR 0 2
6803: PUSH
6804: LD_INT 5
6806: ARRAY
6807: ST_TO_ADDR
// bc_kind2 := i [ 6 ] ;
6808: LD_ADDR_OWVAR 45
6812: PUSH
6813: LD_VAR 0 2
6817: PUSH
6818: LD_INT 6
6820: ARRAY
6821: ST_TO_ADDR
// sr := 0 ;
6822: LD_ADDR_VAR 0 9
6826: PUSH
6827: LD_INT 0
6829: ST_TO_ADDR
// if i [ 1 ] = b_oil_mine then
6830: LD_VAR 0 2
6834: PUSH
6835: LD_INT 1
6837: ARRAY
6838: PUSH
6839: LD_INT 29
6841: EQUAL
6842: IFFALSE 6854
// sr := mat_oil else
6844: LD_ADDR_VAR 0 9
6848: PUSH
6849: LD_INT 2
6851: ST_TO_ADDR
6852: GO 6876
// if i [ 1 ] = b_siberite_mine then
6854: LD_VAR 0 2
6858: PUSH
6859: LD_INT 1
6861: ARRAY
6862: PUSH
6863: LD_INT 30
6865: EQUAL
6866: IFFALSE 6876
// sr := mat_siberit ;
6868: LD_ADDR_VAR 0 9
6872: PUSH
6873: LD_INT 3
6875: ST_TO_ADDR
// if sr then
6876: LD_VAR 0 9
6880: IFFALSE 6936
// begin CreateDepositXY ( i [ 2 ] , i [ 3 ] , sr ) ;
6882: LD_VAR 0 2
6886: PUSH
6887: LD_INT 2
6889: ARRAY
6890: PPUSH
6891: LD_VAR 0 2
6895: PUSH
6896: LD_INT 3
6898: ARRAY
6899: PPUSH
6900: LD_VAR 0 9
6904: PPUSH
6905: CALL_OW 62
// SetResourceVisibility ( i [ 2 ] , i [ 3 ] , side ) ;
6909: LD_VAR 0 2
6913: PUSH
6914: LD_INT 2
6916: ARRAY
6917: PPUSH
6918: LD_VAR 0 2
6922: PUSH
6923: LD_INT 3
6925: ARRAY
6926: PPUSH
6927: LD_VAR 0 8
6931: PPUSH
6932: CALL_OW 441
// end ; b := CreateAndPlaceBuildingXYD ( i [ 2 ] , i [ 3 ] , i [ 4 ] ) ;
6936: LD_ADDR_VAR 0 3
6940: PUSH
6941: LD_VAR 0 2
6945: PUSH
6946: LD_INT 2
6948: ARRAY
6949: PPUSH
6950: LD_VAR 0 2
6954: PUSH
6955: LD_INT 3
6957: ARRAY
6958: PPUSH
6959: LD_VAR 0 2
6963: PUSH
6964: LD_INT 4
6966: ARRAY
6967: PPUSH
6968: CALL_OW 47
6972: ST_TO_ADDR
// end ;
6973: GO 6743
6975: POP
6976: POP
// depot := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_warehouse ] ] ) ;
6977: LD_ADDR_VAR 0 10
6981: PUSH
6982: LD_INT 22
6984: PUSH
6985: LD_VAR 0 8
6989: PUSH
6990: EMPTY
6991: LIST
6992: LIST
6993: PUSH
6994: LD_INT 30
6996: PUSH
6997: LD_INT 1
6999: PUSH
7000: EMPTY
7001: LIST
7002: LIST
7003: PUSH
7004: EMPTY
7005: LIST
7006: LIST
7007: PPUSH
7008: CALL_OW 69
7012: ST_TO_ADDR
// if not depot then
7013: LD_VAR 0 10
7017: NOT
7018: IFFALSE 7022
// exit ;
7020: GO 7268
// base := PrepareBase ( depot [ 1 ] , legBase , 0 , [ 7 , 8 , 10 ] [ Difficulty ] , [ 3000 , 300 , 100 ] , [ 14 , 6 , 6 , 5 ] ) ;
7022: LD_ADDR_VAR 0 11
7026: PUSH
7027: LD_VAR 0 10
7031: PUSH
7032: LD_INT 1
7034: ARRAY
7035: PPUSH
7036: LD_INT 6
7038: PPUSH
7039: LD_INT 0
7041: PPUSH
7042: LD_INT 7
7044: PUSH
7045: LD_INT 8
7047: PUSH
7048: LD_INT 10
7050: PUSH
7051: EMPTY
7052: LIST
7053: LIST
7054: LIST
7055: PUSH
7056: LD_OWVAR 67
7060: ARRAY
7061: PPUSH
7062: LD_INT 3000
7064: PUSH
7065: LD_INT 300
7067: PUSH
7068: LD_INT 100
7070: PUSH
7071: EMPTY
7072: LIST
7073: LIST
7074: LIST
7075: PPUSH
7076: LD_INT 14
7078: PUSH
7079: LD_INT 6
7081: PUSH
7082: LD_INT 6
7084: PUSH
7085: LD_INT 5
7087: PUSH
7088: EMPTY
7089: LIST
7090: LIST
7091: LIST
7092: LIST
7093: PPUSH
7094: CALL 28177 0 6
7098: ST_TO_ADDR
// if not base then
7099: LD_VAR 0 11
7103: NOT
7104: IFFALSE 7108
// exit ;
7106: GO 7268
// if Difficulty > 1 then
7108: LD_OWVAR 67
7112: PUSH
7113: LD_INT 1
7115: GREATER
7116: IFFALSE 7189
// begin InitHc ;
7118: CALL_OW 19
// PrepareHuman ( sex_male , class_sniper , [ 5 , 8 ] [ Difficulty - 1 ] ) ;
7122: LD_INT 1
7124: PPUSH
7125: LD_INT 5
7127: PPUSH
7128: LD_INT 5
7130: PUSH
7131: LD_INT 8
7133: PUSH
7134: EMPTY
7135: LIST
7136: LIST
7137: PUSH
7138: LD_OWVAR 67
7142: PUSH
7143: LD_INT 1
7145: MINUS
7146: ARRAY
7147: PPUSH
7148: CALL_OW 380
// for i = 1 to Difficulty do
7152: LD_ADDR_VAR 0 2
7156: PUSH
7157: DOUBLE
7158: LD_INT 1
7160: DEC
7161: ST_TO_ADDR
7162: LD_OWVAR 67
7166: PUSH
7167: FOR_TO
7168: IFFALSE 7187
// PlaceUnitArea ( CreateHuman , sniperGuardArea , false ) ;
7170: CALL_OW 44
7174: PPUSH
7175: LD_INT 24
7177: PPUSH
7178: LD_INT 0
7180: PPUSH
7181: CALL_OW 49
7185: GO 7167
7187: POP
7188: POP
// end ; mc_bases := Replace ( mc_bases , mc_leg , base ) ;
7189: LD_ADDR_EXP 31
7193: PUSH
7194: LD_EXP 31
7198: PPUSH
7199: LD_EXP 6
7203: PPUSH
7204: LD_VAR 0 11
7208: PPUSH
7209: CALL_OW 1
7213: ST_TO_ADDR
// hc_gallery := ru ;
7214: LD_ADDR_OWVAR 33
7218: PUSH
7219: LD_STRING ru
7221: ST_TO_ADDR
// hc_face_number := 44 ;
7222: LD_ADDR_OWVAR 34
7226: PUSH
7227: LD_INT 44
7229: ST_TO_ADDR
// hc_name := Robert Farmer ;
7230: LD_ADDR_OWVAR 26
7234: PUSH
7235: LD_STRING Robert Farmer
7237: ST_TO_ADDR
// hc_sex := sex_male ;
7238: LD_ADDR_OWVAR 27
7242: PUSH
7243: LD_INT 1
7245: ST_TO_ADDR
// hc_class := 1 ;
7246: LD_ADDR_OWVAR 28
7250: PUSH
7251: LD_INT 1
7253: ST_TO_ADDR
// Farmer := CreateHuman ;
7254: LD_ADDR_EXP 13
7258: PUSH
7259: CALL_OW 44
7263: ST_TO_ADDR
// InitHc ;
7264: CALL_OW 19
// end ;
7268: LD_VAR 0 1
7272: RET
// export function SetAdditionalRussianForces ; var i , tmp , veh ; begin
7273: LD_INT 0
7275: PPUSH
7276: PPUSH
7277: PPUSH
7278: PPUSH
// tmp := [ ] ;
7279: LD_ADDR_VAR 0 3
7283: PUSH
7284: EMPTY
7285: ST_TO_ADDR
// for i := 1 to 3 do
7286: LD_ADDR_VAR 0 2
7290: PUSH
7291: DOUBLE
7292: LD_INT 1
7294: DEC
7295: ST_TO_ADDR
7296: LD_INT 3
7298: PUSH
7299: FOR_TO
7300: IFFALSE 7412
// begin uc_side := 3 ;
7302: LD_ADDR_OWVAR 20
7306: PUSH
7307: LD_INT 3
7309: ST_TO_ADDR
// uc_nation := 3 ;
7310: LD_ADDR_OWVAR 21
7314: PUSH
7315: LD_INT 3
7317: ST_TO_ADDR
// vc_chassis := ru_medium_tracked ;
7318: LD_ADDR_OWVAR 37
7322: PUSH
7323: LD_INT 22
7325: ST_TO_ADDR
// vc_engine := engine_siberite ;
7326: LD_ADDR_OWVAR 39
7330: PUSH
7331: LD_INT 3
7333: ST_TO_ADDR
// vc_control := control_computer ;
7334: LD_ADDR_OWVAR 38
7338: PUSH
7339: LD_INT 3
7341: ST_TO_ADDR
// vc_weapon := ru_crane ;
7342: LD_ADDR_OWVAR 40
7346: PUSH
7347: LD_INT 52
7349: ST_TO_ADDR
// veh := CreateVehicle ;
7350: LD_ADDR_VAR 0 4
7354: PUSH
7355: CALL_OW 45
7359: ST_TO_ADDR
// PlaceUnitXYR ( veh , 73 , 122 , 3 , false ) ;
7360: LD_VAR 0 4
7364: PPUSH
7365: LD_INT 73
7367: PPUSH
7368: LD_INT 122
7370: PPUSH
7371: LD_INT 3
7373: PPUSH
7374: LD_INT 0
7376: PPUSH
7377: CALL_OW 50
// tmp := Replace ( tmp , tmp + 1 , veh ) ;
7381: LD_ADDR_VAR 0 3
7385: PUSH
7386: LD_VAR 0 3
7390: PPUSH
7391: LD_VAR 0 3
7395: PUSH
7396: LD_INT 1
7398: PLUS
7399: PPUSH
7400: LD_VAR 0 4
7404: PPUSH
7405: CALL_OW 1
7409: ST_TO_ADDR
// end ;
7410: GO 7299
7412: POP
7413: POP
// mc_vehicles := Replace ( mc_vehicles , mc_rus_1 , tmp ) ;
7414: LD_ADDR_EXP 50
7418: PUSH
7419: LD_EXP 50
7423: PPUSH
7424: LD_EXP 7
7428: PPUSH
7429: LD_VAR 0 3
7433: PPUSH
7434: CALL_OW 1
7438: ST_TO_ADDR
// tmp := [ ] ;
7439: LD_ADDR_VAR 0 3
7443: PUSH
7444: EMPTY
7445: ST_TO_ADDR
// for i := 1 to 3 do
7446: LD_ADDR_VAR 0 2
7450: PUSH
7451: DOUBLE
7452: LD_INT 1
7454: DEC
7455: ST_TO_ADDR
7456: LD_INT 3
7458: PUSH
7459: FOR_TO
7460: IFFALSE 7572
// begin uc_side := 3 ;
7462: LD_ADDR_OWVAR 20
7466: PUSH
7467: LD_INT 3
7469: ST_TO_ADDR
// uc_nation := 3 ;
7470: LD_ADDR_OWVAR 21
7474: PUSH
7475: LD_INT 3
7477: ST_TO_ADDR
// vc_chassis := ru_medium_tracked ;
7478: LD_ADDR_OWVAR 37
7482: PUSH
7483: LD_INT 22
7485: ST_TO_ADDR
// vc_engine := engine_siberite ;
7486: LD_ADDR_OWVAR 39
7490: PUSH
7491: LD_INT 3
7493: ST_TO_ADDR
// vc_control := control_computer ;
7494: LD_ADDR_OWVAR 38
7498: PUSH
7499: LD_INT 3
7501: ST_TO_ADDR
// vc_weapon := ru_crane ;
7502: LD_ADDR_OWVAR 40
7506: PUSH
7507: LD_INT 52
7509: ST_TO_ADDR
// veh := CreateVehicle ;
7510: LD_ADDR_VAR 0 4
7514: PUSH
7515: CALL_OW 45
7519: ST_TO_ADDR
// PlaceUnitXYR ( veh , 22 , 28 , 3 , false ) ;
7520: LD_VAR 0 4
7524: PPUSH
7525: LD_INT 22
7527: PPUSH
7528: LD_INT 28
7530: PPUSH
7531: LD_INT 3
7533: PPUSH
7534: LD_INT 0
7536: PPUSH
7537: CALL_OW 50
// tmp := Replace ( tmp , tmp + 1 , veh ) ;
7541: LD_ADDR_VAR 0 3
7545: PUSH
7546: LD_VAR 0 3
7550: PPUSH
7551: LD_VAR 0 3
7555: PUSH
7556: LD_INT 1
7558: PLUS
7559: PPUSH
7560: LD_VAR 0 4
7564: PPUSH
7565: CALL_OW 1
7569: ST_TO_ADDR
// end ;
7570: GO 7459
7572: POP
7573: POP
// mc_vehicles := Replace ( mc_vehicles , mc_rus_2 , tmp ) ;
7574: LD_ADDR_EXP 50
7578: PUSH
7579: LD_EXP 50
7583: PPUSH
7584: LD_EXP 8
7588: PPUSH
7589: LD_VAR 0 3
7593: PPUSH
7594: CALL_OW 1
7598: ST_TO_ADDR
// end ;
7599: LD_VAR 0 1
7603: RET
// export function PrepareAmericans ; var i , b , tmp , side , sr , base , depot ; begin
7604: LD_INT 0
7606: PPUSH
7607: PPUSH
7608: PPUSH
7609: PPUSH
7610: PPUSH
7611: PPUSH
7612: PPUSH
7613: PPUSH
// PrepareNature ( 0 , 0 , 4 , 0 , 0 , 0 , 0 , amerApe , 0 ) ;
7614: LD_INT 0
7616: PPUSH
7617: LD_INT 0
7619: PPUSH
7620: LD_INT 4
7622: PPUSH
7623: LD_INT 0
7625: PPUSH
7626: LD_INT 0
7628: PPUSH
7629: LD_INT 0
7631: PPUSH
7632: LD_INT 0
7634: PPUSH
7635: LD_INT 10
7637: PPUSH
7638: LD_INT 0
7640: PPUSH
7641: CALL 53895 0 9
// side := 4 ;
7645: LD_ADDR_VAR 0 5
7649: PUSH
7650: LD_INT 4
7652: ST_TO_ADDR
// tmp := [ [ 1 , 144 , 18 , 4 , 0 , 0 ] , [ 3 , 137 , 8 , 4 , 0 , 0 ] , [ 22 , 141 , 8 , 4 , 0 , 0 ] , [ 25 , 137 , 5 , 3 , 0 , 0 ] , [ 18 , 137 , 12 , 0 , 0 , 0 ] , [ 17 , 133 , 4 , 2 , 0 , 0 ] , [ 16 , 140 , 11 , 5 , 0 , 0 ] , [ 8 , 149 , 26 , 4 , 10 , 15 ] , [ 8 , 142 , 26 , 1 , 11 , 12 ] , [ 27 , 153 , 32 , 5 , 0 , 0 ] , [ 27 , 145 , 32 , 3 , 0 , 0 ] , [ 27 , 138 , 2 , 4 , 0 , 0 ] , [ 27 , 144 , 13 , 0 , 0 , 0 ] , [ 26 , 124 , 2 , 4 , 0 , 0 ] , [ 26 , 121 , 2 , 2 , 0 , 0 ] , [ 26 , 118 , 2 , 1 , 0 , 0 ] , [ 29 , 159 , 47 , 2 , 0 , 0 ] , [ 32 , 146 , 41 , 0 , 0 , 0 ] , [ 33 , 136 , 37 , 0 , 0 , 0 ] , [ 33 , 132 , 34 , 0 , 0 , 0 ] , [ 36 , 124 , 7 , 1 , 0 , 0 ] , [ 5 , 124 , 19 , 0 , 0 , 0 ] , [ 32 , 127 , 23 , 0 , 0 , 0 ] ] ;
7653: LD_ADDR_VAR 0 4
7657: PUSH
7658: LD_INT 1
7660: PUSH
7661: LD_INT 144
7663: PUSH
7664: LD_INT 18
7666: PUSH
7667: LD_INT 4
7669: PUSH
7670: LD_INT 0
7672: PUSH
7673: LD_INT 0
7675: PUSH
7676: EMPTY
7677: LIST
7678: LIST
7679: LIST
7680: LIST
7681: LIST
7682: LIST
7683: PUSH
7684: LD_INT 3
7686: PUSH
7687: LD_INT 137
7689: PUSH
7690: LD_INT 8
7692: PUSH
7693: LD_INT 4
7695: PUSH
7696: LD_INT 0
7698: PUSH
7699: LD_INT 0
7701: PUSH
7702: EMPTY
7703: LIST
7704: LIST
7705: LIST
7706: LIST
7707: LIST
7708: LIST
7709: PUSH
7710: LD_INT 22
7712: PUSH
7713: LD_INT 141
7715: PUSH
7716: LD_INT 8
7718: PUSH
7719: LD_INT 4
7721: PUSH
7722: LD_INT 0
7724: PUSH
7725: LD_INT 0
7727: PUSH
7728: EMPTY
7729: LIST
7730: LIST
7731: LIST
7732: LIST
7733: LIST
7734: LIST
7735: PUSH
7736: LD_INT 25
7738: PUSH
7739: LD_INT 137
7741: PUSH
7742: LD_INT 5
7744: PUSH
7745: LD_INT 3
7747: PUSH
7748: LD_INT 0
7750: PUSH
7751: LD_INT 0
7753: PUSH
7754: EMPTY
7755: LIST
7756: LIST
7757: LIST
7758: LIST
7759: LIST
7760: LIST
7761: PUSH
7762: LD_INT 18
7764: PUSH
7765: LD_INT 137
7767: PUSH
7768: LD_INT 12
7770: PUSH
7771: LD_INT 0
7773: PUSH
7774: LD_INT 0
7776: PUSH
7777: LD_INT 0
7779: PUSH
7780: EMPTY
7781: LIST
7782: LIST
7783: LIST
7784: LIST
7785: LIST
7786: LIST
7787: PUSH
7788: LD_INT 17
7790: PUSH
7791: LD_INT 133
7793: PUSH
7794: LD_INT 4
7796: PUSH
7797: LD_INT 2
7799: PUSH
7800: LD_INT 0
7802: PUSH
7803: LD_INT 0
7805: PUSH
7806: EMPTY
7807: LIST
7808: LIST
7809: LIST
7810: LIST
7811: LIST
7812: LIST
7813: PUSH
7814: LD_INT 16
7816: PUSH
7817: LD_INT 140
7819: PUSH
7820: LD_INT 11
7822: PUSH
7823: LD_INT 5
7825: PUSH
7826: LD_INT 0
7828: PUSH
7829: LD_INT 0
7831: PUSH
7832: EMPTY
7833: LIST
7834: LIST
7835: LIST
7836: LIST
7837: LIST
7838: LIST
7839: PUSH
7840: LD_INT 8
7842: PUSH
7843: LD_INT 149
7845: PUSH
7846: LD_INT 26
7848: PUSH
7849: LD_INT 4
7851: PUSH
7852: LD_INT 10
7854: PUSH
7855: LD_INT 15
7857: PUSH
7858: EMPTY
7859: LIST
7860: LIST
7861: LIST
7862: LIST
7863: LIST
7864: LIST
7865: PUSH
7866: LD_INT 8
7868: PUSH
7869: LD_INT 142
7871: PUSH
7872: LD_INT 26
7874: PUSH
7875: LD_INT 1
7877: PUSH
7878: LD_INT 11
7880: PUSH
7881: LD_INT 12
7883: PUSH
7884: EMPTY
7885: LIST
7886: LIST
7887: LIST
7888: LIST
7889: LIST
7890: LIST
7891: PUSH
7892: LD_INT 27
7894: PUSH
7895: LD_INT 153
7897: PUSH
7898: LD_INT 32
7900: PUSH
7901: LD_INT 5
7903: PUSH
7904: LD_INT 0
7906: PUSH
7907: LD_INT 0
7909: PUSH
7910: EMPTY
7911: LIST
7912: LIST
7913: LIST
7914: LIST
7915: LIST
7916: LIST
7917: PUSH
7918: LD_INT 27
7920: PUSH
7921: LD_INT 145
7923: PUSH
7924: LD_INT 32
7926: PUSH
7927: LD_INT 3
7929: PUSH
7930: LD_INT 0
7932: PUSH
7933: LD_INT 0
7935: PUSH
7936: EMPTY
7937: LIST
7938: LIST
7939: LIST
7940: LIST
7941: LIST
7942: LIST
7943: PUSH
7944: LD_INT 27
7946: PUSH
7947: LD_INT 138
7949: PUSH
7950: LD_INT 2
7952: PUSH
7953: LD_INT 4
7955: PUSH
7956: LD_INT 0
7958: PUSH
7959: LD_INT 0
7961: PUSH
7962: EMPTY
7963: LIST
7964: LIST
7965: LIST
7966: LIST
7967: LIST
7968: LIST
7969: PUSH
7970: LD_INT 27
7972: PUSH
7973: LD_INT 144
7975: PUSH
7976: LD_INT 13
7978: PUSH
7979: LD_INT 0
7981: PUSH
7982: LD_INT 0
7984: PUSH
7985: LD_INT 0
7987: PUSH
7988: EMPTY
7989: LIST
7990: LIST
7991: LIST
7992: LIST
7993: LIST
7994: LIST
7995: PUSH
7996: LD_INT 26
7998: PUSH
7999: LD_INT 124
8001: PUSH
8002: LD_INT 2
8004: PUSH
8005: LD_INT 4
8007: PUSH
8008: LD_INT 0
8010: PUSH
8011: LD_INT 0
8013: PUSH
8014: EMPTY
8015: LIST
8016: LIST
8017: LIST
8018: LIST
8019: LIST
8020: LIST
8021: PUSH
8022: LD_INT 26
8024: PUSH
8025: LD_INT 121
8027: PUSH
8028: LD_INT 2
8030: PUSH
8031: LD_INT 2
8033: PUSH
8034: LD_INT 0
8036: PUSH
8037: LD_INT 0
8039: PUSH
8040: EMPTY
8041: LIST
8042: LIST
8043: LIST
8044: LIST
8045: LIST
8046: LIST
8047: PUSH
8048: LD_INT 26
8050: PUSH
8051: LD_INT 118
8053: PUSH
8054: LD_INT 2
8056: PUSH
8057: LD_INT 1
8059: PUSH
8060: LD_INT 0
8062: PUSH
8063: LD_INT 0
8065: PUSH
8066: EMPTY
8067: LIST
8068: LIST
8069: LIST
8070: LIST
8071: LIST
8072: LIST
8073: PUSH
8074: LD_INT 29
8076: PUSH
8077: LD_INT 159
8079: PUSH
8080: LD_INT 47
8082: PUSH
8083: LD_INT 2
8085: PUSH
8086: LD_INT 0
8088: PUSH
8089: LD_INT 0
8091: PUSH
8092: EMPTY
8093: LIST
8094: LIST
8095: LIST
8096: LIST
8097: LIST
8098: LIST
8099: PUSH
8100: LD_INT 32
8102: PUSH
8103: LD_INT 146
8105: PUSH
8106: LD_INT 41
8108: PUSH
8109: LD_INT 0
8111: PUSH
8112: LD_INT 0
8114: PUSH
8115: LD_INT 0
8117: PUSH
8118: EMPTY
8119: LIST
8120: LIST
8121: LIST
8122: LIST
8123: LIST
8124: LIST
8125: PUSH
8126: LD_INT 33
8128: PUSH
8129: LD_INT 136
8131: PUSH
8132: LD_INT 37
8134: PUSH
8135: LD_INT 0
8137: PUSH
8138: LD_INT 0
8140: PUSH
8141: LD_INT 0
8143: PUSH
8144: EMPTY
8145: LIST
8146: LIST
8147: LIST
8148: LIST
8149: LIST
8150: LIST
8151: PUSH
8152: LD_INT 33
8154: PUSH
8155: LD_INT 132
8157: PUSH
8158: LD_INT 34
8160: PUSH
8161: LD_INT 0
8163: PUSH
8164: LD_INT 0
8166: PUSH
8167: LD_INT 0
8169: PUSH
8170: EMPTY
8171: LIST
8172: LIST
8173: LIST
8174: LIST
8175: LIST
8176: LIST
8177: PUSH
8178: LD_INT 36
8180: PUSH
8181: LD_INT 124
8183: PUSH
8184: LD_INT 7
8186: PUSH
8187: LD_INT 1
8189: PUSH
8190: LD_INT 0
8192: PUSH
8193: LD_INT 0
8195: PUSH
8196: EMPTY
8197: LIST
8198: LIST
8199: LIST
8200: LIST
8201: LIST
8202: LIST
8203: PUSH
8204: LD_INT 5
8206: PUSH
8207: LD_INT 124
8209: PUSH
8210: LD_INT 19
8212: PUSH
8213: LD_INT 0
8215: PUSH
8216: LD_INT 0
8218: PUSH
8219: LD_INT 0
8221: PUSH
8222: EMPTY
8223: LIST
8224: LIST
8225: LIST
8226: LIST
8227: LIST
8228: LIST
8229: PUSH
8230: LD_INT 32
8232: PUSH
8233: LD_INT 127
8235: PUSH
8236: LD_INT 23
8238: PUSH
8239: LD_INT 0
8241: PUSH
8242: LD_INT 0
8244: PUSH
8245: LD_INT 0
8247: PUSH
8248: EMPTY
8249: LIST
8250: LIST
8251: LIST
8252: LIST
8253: LIST
8254: LIST
8255: PUSH
8256: EMPTY
8257: LIST
8258: LIST
8259: LIST
8260: LIST
8261: LIST
8262: LIST
8263: LIST
8264: LIST
8265: LIST
8266: LIST
8267: LIST
8268: LIST
8269: LIST
8270: LIST
8271: LIST
8272: LIST
8273: LIST
8274: LIST
8275: LIST
8276: LIST
8277: LIST
8278: LIST
8279: LIST
8280: ST_TO_ADDR
// for i in tmp do
8281: LD_ADDR_VAR 0 2
8285: PUSH
8286: LD_VAR 0 4
8290: PUSH
8291: FOR_IN
8292: IFFALSE 8523
// begin uc_side := side ;
8294: LD_ADDR_OWVAR 20
8298: PUSH
8299: LD_VAR 0 5
8303: ST_TO_ADDR
// uc_nation := nation_american ;
8304: LD_ADDR_OWVAR 21
8308: PUSH
8309: LD_INT 1
8311: ST_TO_ADDR
// bc_type := i [ 1 ] ;
8312: LD_ADDR_OWVAR 42
8316: PUSH
8317: LD_VAR 0 2
8321: PUSH
8322: LD_INT 1
8324: ARRAY
8325: ST_TO_ADDR
// bc_level := rand ( 5 , 6 ) ;
8326: LD_ADDR_OWVAR 43
8330: PUSH
8331: LD_INT 5
8333: PPUSH
8334: LD_INT 6
8336: PPUSH
8337: CALL_OW 12
8341: ST_TO_ADDR
// bc_kind1 := i [ 5 ] ;
8342: LD_ADDR_OWVAR 44
8346: PUSH
8347: LD_VAR 0 2
8351: PUSH
8352: LD_INT 5
8354: ARRAY
8355: ST_TO_ADDR
// bc_kind2 := i [ 6 ] ;
8356: LD_ADDR_OWVAR 45
8360: PUSH
8361: LD_VAR 0 2
8365: PUSH
8366: LD_INT 6
8368: ARRAY
8369: ST_TO_ADDR
// sr := 0 ;
8370: LD_ADDR_VAR 0 6
8374: PUSH
8375: LD_INT 0
8377: ST_TO_ADDR
// if i [ 1 ] = b_oil_mine then
8378: LD_VAR 0 2
8382: PUSH
8383: LD_INT 1
8385: ARRAY
8386: PUSH
8387: LD_INT 29
8389: EQUAL
8390: IFFALSE 8402
// sr := mat_oil else
8392: LD_ADDR_VAR 0 6
8396: PUSH
8397: LD_INT 2
8399: ST_TO_ADDR
8400: GO 8424
// if i [ 1 ] = b_siberite_mine then
8402: LD_VAR 0 2
8406: PUSH
8407: LD_INT 1
8409: ARRAY
8410: PUSH
8411: LD_INT 30
8413: EQUAL
8414: IFFALSE 8424
// sr := mat_siberit ;
8416: LD_ADDR_VAR 0 6
8420: PUSH
8421: LD_INT 3
8423: ST_TO_ADDR
// if sr then
8424: LD_VAR 0 6
8428: IFFALSE 8484
// begin CreateDepositXY ( i [ 2 ] , i [ 3 ] , sr ) ;
8430: LD_VAR 0 2
8434: PUSH
8435: LD_INT 2
8437: ARRAY
8438: PPUSH
8439: LD_VAR 0 2
8443: PUSH
8444: LD_INT 3
8446: ARRAY
8447: PPUSH
8448: LD_VAR 0 6
8452: PPUSH
8453: CALL_OW 62
// SetResourceVisibility ( i [ 2 ] , i [ 3 ] , side ) ;
8457: LD_VAR 0 2
8461: PUSH
8462: LD_INT 2
8464: ARRAY
8465: PPUSH
8466: LD_VAR 0 2
8470: PUSH
8471: LD_INT 3
8473: ARRAY
8474: PPUSH
8475: LD_VAR 0 5
8479: PPUSH
8480: CALL_OW 441
// end ; b := CreateAndPlaceBuildingXYD ( i [ 2 ] , i [ 3 ] , i [ 4 ] ) ;
8484: LD_ADDR_VAR 0 3
8488: PUSH
8489: LD_VAR 0 2
8493: PUSH
8494: LD_INT 2
8496: ARRAY
8497: PPUSH
8498: LD_VAR 0 2
8502: PUSH
8503: LD_INT 3
8505: ARRAY
8506: PPUSH
8507: LD_VAR 0 2
8511: PUSH
8512: LD_INT 4
8514: ARRAY
8515: PPUSH
8516: CALL_OW 47
8520: ST_TO_ADDR
// end ;
8521: GO 8291
8523: POP
8524: POP
// depot := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_warehouse ] ] ) ;
8525: LD_ADDR_VAR 0 8
8529: PUSH
8530: LD_INT 22
8532: PUSH
8533: LD_VAR 0 5
8537: PUSH
8538: EMPTY
8539: LIST
8540: LIST
8541: PUSH
8542: LD_INT 30
8544: PUSH
8545: LD_INT 1
8547: PUSH
8548: EMPTY
8549: LIST
8550: LIST
8551: PUSH
8552: EMPTY
8553: LIST
8554: LIST
8555: PPUSH
8556: CALL_OW 69
8560: ST_TO_ADDR
// if not depot then
8561: LD_VAR 0 8
8565: NOT
8566: IFFALSE 8570
// exit ;
8568: GO 8842
// base := PrepareBase ( depot [ 1 ] , amerBase , theta3 , [ 8 , 7 , 6 ] [ Difficulty ] , [ [ 2500 , 2000 , 1750 ] [ Difficulty ] , [ 300 , 250 , 200 ] [ Difficulty ] , [ 80 , 60 , 50 ] [ Difficulty ] ] , [ 7 , 6 , 5 , 5 ] ) ;
8570: LD_ADDR_VAR 0 7
8574: PUSH
8575: LD_VAR 0 8
8579: PUSH
8580: LD_INT 1
8582: ARRAY
8583: PPUSH
8584: LD_INT 3
8586: PPUSH
8587: LD_STRING theta3
8589: PPUSH
8590: LD_INT 8
8592: PUSH
8593: LD_INT 7
8595: PUSH
8596: LD_INT 6
8598: PUSH
8599: EMPTY
8600: LIST
8601: LIST
8602: LIST
8603: PUSH
8604: LD_OWVAR 67
8608: ARRAY
8609: PPUSH
8610: LD_INT 2500
8612: PUSH
8613: LD_INT 2000
8615: PUSH
8616: LD_INT 1750
8618: PUSH
8619: EMPTY
8620: LIST
8621: LIST
8622: LIST
8623: PUSH
8624: LD_OWVAR 67
8628: ARRAY
8629: PUSH
8630: LD_INT 300
8632: PUSH
8633: LD_INT 250
8635: PUSH
8636: LD_INT 200
8638: PUSH
8639: EMPTY
8640: LIST
8641: LIST
8642: LIST
8643: PUSH
8644: LD_OWVAR 67
8648: ARRAY
8649: PUSH
8650: LD_INT 80
8652: PUSH
8653: LD_INT 60
8655: PUSH
8656: LD_INT 50
8658: PUSH
8659: EMPTY
8660: LIST
8661: LIST
8662: LIST
8663: PUSH
8664: LD_OWVAR 67
8668: ARRAY
8669: PUSH
8670: EMPTY
8671: LIST
8672: LIST
8673: LIST
8674: PPUSH
8675: LD_INT 7
8677: PUSH
8678: LD_INT 6
8680: PUSH
8681: LD_INT 5
8683: PUSH
8684: LD_INT 5
8686: PUSH
8687: EMPTY
8688: LIST
8689: LIST
8690: LIST
8691: LIST
8692: PPUSH
8693: CALL 28177 0 6
8697: ST_TO_ADDR
// if not base then
8698: LD_VAR 0 7
8702: NOT
8703: IFFALSE 8707
// exit ;
8705: GO 8842
// mc_bases := Replace ( mc_bases , mc_amer , base ) ;
8707: LD_ADDR_EXP 31
8711: PUSH
8712: LD_EXP 31
8716: PPUSH
8717: LD_EXP 5
8721: PPUSH
8722: LD_VAR 0 7
8726: PPUSH
8727: CALL_OW 1
8731: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , 7 ) ;
8732: LD_INT 1
8734: PPUSH
8735: LD_INT 1
8737: PPUSH
8738: LD_INT 7
8740: PPUSH
8741: CALL_OW 380
// allyCommander := CreateHuman ;
8745: LD_ADDR_EXP 11
8749: PUSH
8750: CALL_OW 44
8754: ST_TO_ADDR
// PlaceUnitXY ( allyCommander , 139 , 15 , false ) ;
8755: LD_EXP 11
8759: PPUSH
8760: LD_INT 139
8762: PPUSH
8763: LD_INT 15
8765: PPUSH
8766: LD_INT 0
8768: PPUSH
8769: CALL_OW 48
// ComTurnXY ( allyCommander , 137 , 15 ) ;
8773: LD_EXP 11
8777: PPUSH
8778: LD_INT 137
8780: PPUSH
8781: LD_INT 15
8783: PPUSH
8784: CALL_OW 118
// hc_gallery := us ;
8788: LD_ADDR_OWVAR 33
8792: PUSH
8793: LD_STRING us
8795: ST_TO_ADDR
// hc_face_number := 7 ;
8796: LD_ADDR_OWVAR 34
8800: PUSH
8801: LD_INT 7
8803: ST_TO_ADDR
// hc_name := Arthur Powell ;
8804: LD_ADDR_OWVAR 26
8808: PUSH
8809: LD_STRING Arthur Powell
8811: ST_TO_ADDR
// hc_sex := sex_male ;
8812: LD_ADDR_OWVAR 27
8816: PUSH
8817: LD_INT 1
8819: ST_TO_ADDR
// hc_class := 1 ;
8820: LD_ADDR_OWVAR 28
8824: PUSH
8825: LD_INT 1
8827: ST_TO_ADDR
// Powell := CreateHuman ;
8828: LD_ADDR_EXP 12
8832: PUSH
8833: CALL_OW 44
8837: ST_TO_ADDR
// InitHc ;
8838: CALL_OW 19
// end ;
8842: LD_VAR 0 1
8846: RET
// export function PreparePlayer ; var i , side , techs , tanks , cl , chassis , engines , weapons ; begin
8847: LD_INT 0
8849: PPUSH
8850: PPUSH
8851: PPUSH
8852: PPUSH
8853: PPUSH
8854: PPUSH
8855: PPUSH
8856: PPUSH
8857: PPUSH
// side := 1 ;
8858: LD_ADDR_VAR 0 3
8862: PUSH
8863: LD_INT 1
8865: ST_TO_ADDR
// result := [ [ ] , [ ] ] ;
8866: LD_ADDR_VAR 0 1
8870: PUSH
8871: EMPTY
8872: PUSH
8873: EMPTY
8874: PUSH
8875: EMPTY
8876: LIST
8877: LIST
8878: ST_TO_ADDR
// uc_side := side ;
8879: LD_ADDR_OWVAR 20
8883: PUSH
8884: LD_VAR 0 3
8888: ST_TO_ADDR
// uc_nation := nation_american ;
8889: LD_ADDR_OWVAR 21
8893: PUSH
8894: LD_INT 1
8896: ST_TO_ADDR
// InitHc ;
8897: CALL_OW 19
// InitVc ;
8901: CALL_OW 20
// hc_importance := 0 ;
8905: LD_ADDR_OWVAR 32
8909: PUSH
8910: LD_INT 0
8912: ST_TO_ADDR
// chassis := [ us_medium_wheeled , us_medium_tracked , us_medium_tracked ] ;
8913: LD_ADDR_VAR 0 7
8917: PUSH
8918: LD_INT 2
8920: PUSH
8921: LD_INT 3
8923: PUSH
8924: LD_INT 3
8926: PUSH
8927: EMPTY
8928: LIST
8929: LIST
8930: LIST
8931: ST_TO_ADDR
// if commander = 2 then
8932: LD_EXP 25
8936: PUSH
8937: LD_INT 2
8939: EQUAL
8940: IFFALSE 8961
// chassis := [ us_medium_tracked , us_heavy_tracked , us_heavy_tracked ] ;
8942: LD_ADDR_VAR 0 7
8946: PUSH
8947: LD_INT 3
8949: PUSH
8950: LD_INT 4
8952: PUSH
8953: LD_INT 4
8955: PUSH
8956: EMPTY
8957: LIST
8958: LIST
8959: LIST
8960: ST_TO_ADDR
// if commander = 3 then
8961: LD_EXP 25
8965: PUSH
8966: LD_INT 3
8968: EQUAL
8969: IFFALSE 8990
// chassis := [ us_medium_wheeled , us_morphling , us_morphling ] ;
8971: LD_ADDR_VAR 0 7
8975: PUSH
8976: LD_INT 2
8978: PUSH
8979: LD_INT 5
8981: PUSH
8982: LD_INT 5
8984: PUSH
8985: EMPTY
8986: LIST
8987: LIST
8988: LIST
8989: ST_TO_ADDR
// engines := [ engine_solar , engine_solar , engine_combustion ] ;
8990: LD_ADDR_VAR 0 8
8994: PUSH
8995: LD_INT 2
8997: PUSH
8998: LD_INT 2
9000: PUSH
9001: LD_INT 1
9003: PUSH
9004: EMPTY
9005: LIST
9006: LIST
9007: LIST
9008: ST_TO_ADDR
// if commander = 2 then
9009: LD_EXP 25
9013: PUSH
9014: LD_INT 2
9016: EQUAL
9017: IFFALSE 9038
// engines := [ engine_combustion , engine_combustion , engine_siberite ] ;
9019: LD_ADDR_VAR 0 8
9023: PUSH
9024: LD_INT 1
9026: PUSH
9027: LD_INT 1
9029: PUSH
9030: LD_INT 3
9032: PUSH
9033: EMPTY
9034: LIST
9035: LIST
9036: LIST
9037: ST_TO_ADDR
// if commander = 3 then
9038: LD_EXP 25
9042: PUSH
9043: LD_INT 3
9045: EQUAL
9046: IFFALSE 9067
// engines := [ engine_siberite , engine_siberite , engine_combustion ] ;
9048: LD_ADDR_VAR 0 8
9052: PUSH
9053: LD_INT 3
9055: PUSH
9056: LD_INT 3
9058: PUSH
9059: LD_INT 1
9061: PUSH
9062: EMPTY
9063: LIST
9064: LIST
9065: LIST
9066: ST_TO_ADDR
// weapons := [ us_double_gun , us_light_gun , us_gatling_gun ] ;
9067: LD_ADDR_VAR 0 9
9071: PUSH
9072: LD_INT 5
9074: PUSH
9075: LD_INT 3
9077: PUSH
9078: LD_INT 4
9080: PUSH
9081: EMPTY
9082: LIST
9083: LIST
9084: LIST
9085: ST_TO_ADDR
// if commander = 2 then
9086: LD_EXP 25
9090: PUSH
9091: LD_INT 2
9093: EQUAL
9094: IFFALSE 9115
// weapons := [ us_rocket_launcher , us_double_gun , us_heavy_gun ] ;
9096: LD_ADDR_VAR 0 9
9100: PUSH
9101: LD_INT 7
9103: PUSH
9104: LD_INT 5
9106: PUSH
9107: LD_INT 6
9109: PUSH
9110: EMPTY
9111: LIST
9112: LIST
9113: LIST
9114: ST_TO_ADDR
// if commander = 3 then
9115: LD_EXP 25
9119: PUSH
9120: LD_INT 3
9122: EQUAL
9123: IFFALSE 9144
// weapons := [ us_laser , us_double_laser , us_rocket_launcher ] ;
9125: LD_ADDR_VAR 0 9
9129: PUSH
9130: LD_INT 9
9132: PUSH
9133: LD_INT 10
9135: PUSH
9136: LD_INT 7
9138: PUSH
9139: EMPTY
9140: LIST
9141: LIST
9142: LIST
9143: ST_TO_ADDR
// tanks := [ 5 , 5 , 4 ] [ Difficulty ] ;
9144: LD_ADDR_VAR 0 5
9148: PUSH
9149: LD_INT 5
9151: PUSH
9152: LD_INT 5
9154: PUSH
9155: LD_INT 4
9157: PUSH
9158: EMPTY
9159: LIST
9160: LIST
9161: LIST
9162: PUSH
9163: LD_OWVAR 67
9167: ARRAY
9168: ST_TO_ADDR
// if commander = 2 then
9169: LD_EXP 25
9173: PUSH
9174: LD_INT 2
9176: EQUAL
9177: IFFALSE 9193
// tanks := tanks + 3 ;
9179: LD_ADDR_VAR 0 5
9183: PUSH
9184: LD_VAR 0 5
9188: PUSH
9189: LD_INT 3
9191: PLUS
9192: ST_TO_ADDR
// for i = 1 to tanks do
9193: LD_ADDR_VAR 0 2
9197: PUSH
9198: DOUBLE
9199: LD_INT 1
9201: DEC
9202: ST_TO_ADDR
9203: LD_VAR 0 5
9207: PUSH
9208: FOR_TO
9209: IFFALSE 9319
// begin PrepareVehicle ( chassis [ i mod 3 + 1 ] , engines [ rand ( 1 , 3 ) ] , control_manual , weapons [ i mod 3 + 1 ] , rand ( 60 , 70 ) ) ;
9211: LD_VAR 0 7
9215: PUSH
9216: LD_VAR 0 2
9220: PUSH
9221: LD_INT 3
9223: MOD
9224: PUSH
9225: LD_INT 1
9227: PLUS
9228: ARRAY
9229: PPUSH
9230: LD_VAR 0 8
9234: PUSH
9235: LD_INT 1
9237: PPUSH
9238: LD_INT 3
9240: PPUSH
9241: CALL_OW 12
9245: ARRAY
9246: PPUSH
9247: LD_INT 1
9249: PPUSH
9250: LD_VAR 0 9
9254: PUSH
9255: LD_VAR 0 2
9259: PUSH
9260: LD_INT 3
9262: MOD
9263: PUSH
9264: LD_INT 1
9266: PLUS
9267: ARRAY
9268: PPUSH
9269: LD_INT 60
9271: PPUSH
9272: LD_INT 70
9274: PPUSH
9275: CALL_OW 12
9279: PPUSH
9280: CALL 24724 0 5
// result := Replace ( result , 1 , result [ 1 ] ^ CreateVehicle ) ;
9284: LD_ADDR_VAR 0 1
9288: PUSH
9289: LD_VAR 0 1
9293: PPUSH
9294: LD_INT 1
9296: PPUSH
9297: LD_VAR 0 1
9301: PUSH
9302: LD_INT 1
9304: ARRAY
9305: PUSH
9306: CALL_OW 45
9310: ADD
9311: PPUSH
9312: CALL_OW 1
9316: ST_TO_ADDR
// end ;
9317: GO 9208
9319: POP
9320: POP
// cl := 1 ;
9321: LD_ADDR_VAR 0 6
9325: PUSH
9326: LD_INT 1
9328: ST_TO_ADDR
// for i = 1 to 10 do
9329: LD_ADDR_VAR 0 2
9333: PUSH
9334: DOUBLE
9335: LD_INT 1
9337: DEC
9338: ST_TO_ADDR
9339: LD_INT 10
9341: PUSH
9342: FOR_TO
9343: IFFALSE 9458
// begin if i mod 4 = 0 then
9345: LD_VAR 0 2
9349: PUSH
9350: LD_INT 4
9352: MOD
9353: PUSH
9354: LD_INT 0
9356: EQUAL
9357: IFFALSE 9373
// cl := cl + 1 ;
9359: LD_ADDR_VAR 0 6
9363: PUSH
9364: LD_VAR 0 6
9368: PUSH
9369: LD_INT 1
9371: PLUS
9372: ST_TO_ADDR
// if cl = 2 then
9373: LD_VAR 0 6
9377: PUSH
9378: LD_INT 2
9380: EQUAL
9381: IFFALSE 9391
// cl := 3 ;
9383: LD_ADDR_VAR 0 6
9387: PUSH
9388: LD_INT 3
9390: ST_TO_ADDR
// PrepareHuman ( false , cl , [ 6 , 6 , 5 ] [ Difficulty ] ) ;
9391: LD_INT 0
9393: PPUSH
9394: LD_VAR 0 6
9398: PPUSH
9399: LD_INT 6
9401: PUSH
9402: LD_INT 6
9404: PUSH
9405: LD_INT 5
9407: PUSH
9408: EMPTY
9409: LIST
9410: LIST
9411: LIST
9412: PUSH
9413: LD_OWVAR 67
9417: ARRAY
9418: PPUSH
9419: CALL_OW 380
// result := Replace ( result , 2 , result [ 2 ] ^ CreateHuman ) ;
9423: LD_ADDR_VAR 0 1
9427: PUSH
9428: LD_VAR 0 1
9432: PPUSH
9433: LD_INT 2
9435: PPUSH
9436: LD_VAR 0 1
9440: PUSH
9441: LD_INT 2
9443: ARRAY
9444: PUSH
9445: CALL_OW 44
9449: ADD
9450: PPUSH
9451: CALL_OW 1
9455: ST_TO_ADDR
// end ;
9456: GO 9342
9458: POP
9459: POP
// if commander = 1 then
9460: LD_EXP 25
9464: PUSH
9465: LD_INT 1
9467: EQUAL
9468: IFFALSE 9536
// for i = 1 to 4 do
9470: LD_ADDR_VAR 0 2
9474: PUSH
9475: DOUBLE
9476: LD_INT 1
9478: DEC
9479: ST_TO_ADDR
9480: LD_INT 4
9482: PUSH
9483: FOR_TO
9484: IFFALSE 9534
// begin PrepareHuman ( false , class_soldier , 8 ) ;
9486: LD_INT 0
9488: PPUSH
9489: LD_INT 1
9491: PPUSH
9492: LD_INT 8
9494: PPUSH
9495: CALL_OW 380
// result := Replace ( result , 2 , result [ 2 ] ^ CreateHuman ) ;
9499: LD_ADDR_VAR 0 1
9503: PUSH
9504: LD_VAR 0 1
9508: PPUSH
9509: LD_INT 2
9511: PPUSH
9512: LD_VAR 0 1
9516: PUSH
9517: LD_INT 2
9519: ARRAY
9520: PUSH
9521: CALL_OW 44
9525: ADD
9526: PPUSH
9527: CALL_OW 1
9531: ST_TO_ADDR
// end ;
9532: GO 9483
9534: POP
9535: POP
// techs := [ ] ;
9536: LD_ADDR_VAR 0 4
9540: PUSH
9541: EMPTY
9542: ST_TO_ADDR
// if commander = 1 then
9543: LD_EXP 25
9547: PUSH
9548: LD_INT 1
9550: EQUAL
9551: IFFALSE 9576
// techs := [ tech_weap1 , tech_weap2 , tech_weap3 , tech_lasSight ] ;
9553: LD_ADDR_VAR 0 4
9557: PUSH
9558: LD_INT 51
9560: PUSH
9561: LD_INT 52
9563: PUSH
9564: LD_INT 53
9566: PUSH
9567: LD_INT 12
9569: PUSH
9570: EMPTY
9571: LIST
9572: LIST
9573: LIST
9574: LIST
9575: ST_TO_ADDR
// if commander = 2 then
9576: LD_EXP 25
9580: PUSH
9581: LD_INT 2
9583: EQUAL
9584: IFFALSE 9621
// techs := [ tech_tech1 , tech_oilEng , tech_oilPow , tech_solEng , tech_solPow , tech_opto1 , tech_radar ] ;
9586: LD_ADDR_VAR 0 4
9590: PUSH
9591: LD_INT 48
9593: PUSH
9594: LD_INT 47
9596: PUSH
9597: LD_INT 46
9599: PUSH
9600: LD_INT 45
9602: PUSH
9603: LD_INT 35
9605: PUSH
9606: LD_INT 60
9608: PUSH
9609: LD_INT 6
9611: PUSH
9612: EMPTY
9613: LIST
9614: LIST
9615: LIST
9616: LIST
9617: LIST
9618: LIST
9619: LIST
9620: ST_TO_ADDR
// if commander = 3 then
9621: LD_EXP 25
9625: PUSH
9626: LD_INT 3
9628: EQUAL
9629: IFFALSE 9678
// techs := [ tech_advAI , tech_advchassis , tech_ai , tech_comp1 , tech_comp2 , tech_oilEng , tech_oilPow , tech_weap1 , tech_gatling , tech_gun ] ;
9631: LD_ADDR_VAR 0 4
9635: PUSH
9636: LD_INT 27
9638: PUSH
9639: LD_INT 36
9641: PUSH
9642: LD_INT 32
9644: PUSH
9645: LD_INT 57
9647: PUSH
9648: LD_INT 58
9650: PUSH
9651: LD_INT 47
9653: PUSH
9654: LD_INT 46
9656: PUSH
9657: LD_INT 51
9659: PUSH
9660: LD_INT 69
9662: PUSH
9663: LD_INT 39
9665: PUSH
9666: EMPTY
9667: LIST
9668: LIST
9669: LIST
9670: LIST
9671: LIST
9672: LIST
9673: LIST
9674: LIST
9675: LIST
9676: LIST
9677: ST_TO_ADDR
// if techs then
9678: LD_VAR 0 4
9682: IFFALSE 9716
// for i in techs do
9684: LD_ADDR_VAR 0 2
9688: PUSH
9689: LD_VAR 0 4
9693: PUSH
9694: FOR_IN
9695: IFFALSE 9714
// SetTech ( i , 1 , state_researched ) ;
9697: LD_VAR 0 2
9701: PPUSH
9702: LD_INT 1
9704: PPUSH
9705: LD_INT 2
9707: PPUSH
9708: CALL_OW 322
9712: GO 9694
9714: POP
9715: POP
// hc_gallery := skirmish ;
9716: LD_ADDR_OWVAR 33
9720: PUSH
9721: LD_STRING skirmish
9723: ST_TO_ADDR
// hc_face_number := commander ;
9724: LD_ADDR_OWVAR 34
9728: PUSH
9729: LD_EXP 25
9733: ST_TO_ADDR
// hc_importance := 100 ;
9734: LD_ADDR_OWVAR 32
9738: PUSH
9739: LD_INT 100
9741: ST_TO_ADDR
// case commander of 1 :
9742: LD_EXP 25
9746: PUSH
9747: LD_INT 1
9749: DOUBLE
9750: EQUAL
9751: IFTRUE 9755
9753: GO 9779
9755: POP
// begin hc_name := Jeff Ironside ;
9756: LD_ADDR_OWVAR 26
9760: PUSH
9761: LD_STRING Jeff Ironside
9763: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , 7 ) ;
9764: LD_INT 1
9766: PPUSH
9767: LD_INT 1
9769: PPUSH
9770: LD_INT 7
9772: PPUSH
9773: CALL_OW 380
// end ; 2 :
9777: GO 9844
9779: LD_INT 2
9781: DOUBLE
9782: EQUAL
9783: IFTRUE 9787
9785: GO 9811
9787: POP
// begin hc_name := Paul Johnson ;
9788: LD_ADDR_OWVAR 26
9792: PUSH
9793: LD_STRING Paul Johnson
9795: ST_TO_ADDR
// PrepareHuman ( sex_male , 3 , 7 ) ;
9796: LD_INT 1
9798: PPUSH
9799: LD_INT 3
9801: PPUSH
9802: LD_INT 7
9804: PPUSH
9805: CALL_OW 380
// end ; 3 :
9809: GO 9844
9811: LD_INT 3
9813: DOUBLE
9814: EQUAL
9815: IFTRUE 9819
9817: GO 9843
9819: POP
// begin hc_name := Lisa Stuart ;
9820: LD_ADDR_OWVAR 26
9824: PUSH
9825: LD_STRING Lisa Stuart
9827: ST_TO_ADDR
// PrepareHuman ( sex_female , 4 , 7 ) ;
9828: LD_INT 2
9830: PPUSH
9831: LD_INT 4
9833: PPUSH
9834: LD_INT 7
9836: PPUSH
9837: CALL_OW 380
// end ; end ;
9841: GO 9844
9843: POP
// playerCommander := CreateHuman ;
9844: LD_ADDR_EXP 9
9848: PUSH
9849: CALL_OW 44
9853: ST_TO_ADDR
// hc_importance := 0 ;
9854: LD_ADDR_OWVAR 32
9858: PUSH
9859: LD_INT 0
9861: ST_TO_ADDR
// hc_gallery :=  ;
9862: LD_ADDR_OWVAR 33
9866: PUSH
9867: LD_STRING 
9869: ST_TO_ADDR
// result := Replace ( result , 2 , result [ 2 ] ^ playerCommander ) ;
9870: LD_ADDR_VAR 0 1
9874: PUSH
9875: LD_VAR 0 1
9879: PPUSH
9880: LD_INT 2
9882: PPUSH
9883: LD_VAR 0 1
9887: PUSH
9888: LD_INT 2
9890: ARRAY
9891: PUSH
9892: LD_EXP 9
9896: ADD
9897: PPUSH
9898: CALL_OW 1
9902: ST_TO_ADDR
// end ;
9903: LD_VAR 0 1
9907: RET
// export function PrepareReinforcements ; var i , peopleAmount , tmp , un , veh ; begin
9908: LD_INT 0
9910: PPUSH
9911: PPUSH
9912: PPUSH
9913: PPUSH
9914: PPUSH
9915: PPUSH
// uc_side := 1 ;
9916: LD_ADDR_OWVAR 20
9920: PUSH
9921: LD_INT 1
9923: ST_TO_ADDR
// uc_nation := 1 ;
9924: LD_ADDR_OWVAR 21
9928: PUSH
9929: LD_INT 1
9931: ST_TO_ADDR
// InitHc ;
9932: CALL_OW 19
// peopleAmount := [ 3 , 3 , 2 ] [ Difficulty ] ;
9936: LD_ADDR_VAR 0 3
9940: PUSH
9941: LD_INT 3
9943: PUSH
9944: LD_INT 3
9946: PUSH
9947: LD_INT 2
9949: PUSH
9950: EMPTY
9951: LIST
9952: LIST
9953: LIST
9954: PUSH
9955: LD_OWVAR 67
9959: ARRAY
9960: ST_TO_ADDR
// for i = 1 to peopleAmount do
9961: LD_ADDR_VAR 0 2
9965: PUSH
9966: DOUBLE
9967: LD_INT 1
9969: DEC
9970: ST_TO_ADDR
9971: LD_VAR 0 3
9975: PUSH
9976: FOR_TO
9977: IFFALSE 10026
// begin PrepareHuman ( false , 2 , [ 7 , 6 , 5 ] [ Difficulty ] ) ;
9979: LD_INT 0
9981: PPUSH
9982: LD_INT 2
9984: PPUSH
9985: LD_INT 7
9987: PUSH
9988: LD_INT 6
9990: PUSH
9991: LD_INT 5
9993: PUSH
9994: EMPTY
9995: LIST
9996: LIST
9997: LIST
9998: PUSH
9999: LD_OWVAR 67
10003: ARRAY
10004: PPUSH
10005: CALL_OW 380
// PlaceUnitInArea ( CreateHuman , startArea , false ) ;
10009: CALL_OW 44
10013: PPUSH
10014: LD_INT 19
10016: PPUSH
10017: LD_INT 0
10019: PPUSH
10020: CALL 56123 0 3
// end ;
10024: GO 9976
10026: POP
10027: POP
// PrepareVehicle ( us_medium_wheeled , engine_combustion , control_computer , us_crane , 58 ) ;
10028: LD_INT 2
10030: PPUSH
10031: LD_INT 1
10033: PPUSH
10034: LD_INT 3
10036: PPUSH
10037: LD_INT 13
10039: PPUSH
10040: LD_INT 58
10042: PPUSH
10043: CALL 24724 0 5
// PlaceUnitInArea ( CreateVehicle , startArea , false ) ;
10047: CALL_OW 45
10051: PPUSH
10052: LD_INT 19
10054: PPUSH
10055: LD_INT 0
10057: PPUSH
10058: CALL 56123 0 3
// if commander = 1 then
10062: LD_EXP 25
10066: PUSH
10067: LD_INT 1
10069: EQUAL
10070: IFFALSE 10081
// wait ( 6 6$00 ) else
10072: LD_INT 12600
10074: PPUSH
10075: CALL_OW 67
10079: GO 10088
// wait ( 8 8$00 ) ;
10081: LD_INT 16800
10083: PPUSH
10084: CALL_OW 67
// uc_side := 1 ;
10088: LD_ADDR_OWVAR 20
10092: PUSH
10093: LD_INT 1
10095: ST_TO_ADDR
// uc_nation := 1 ;
10096: LD_ADDR_OWVAR 21
10100: PUSH
10101: LD_INT 1
10103: ST_TO_ADDR
// InitVc ;
10104: CALL_OW 20
// InitHc ;
10108: CALL_OW 19
// for i = 1 to 5 do
10112: LD_ADDR_VAR 0 2
10116: PUSH
10117: DOUBLE
10118: LD_INT 1
10120: DEC
10121: ST_TO_ADDR
10122: LD_INT 5
10124: PUSH
10125: FOR_TO
10126: IFFALSE 10370
// begin PrepareVehicle ( [ us_heavy_tracked , us_medium_tracked , us_light_wheeled ] [ i mod 3 + 1 ] , engine_combustion , [ control_manual , control_computer , control_computer ] [ i mod 3 + 1 ] , [ us_heavy_gun , us_cargo_bay , us_radar ] [ i mod 3 + 1 ] , rand ( 40 , 55 ) ) ;
10128: LD_INT 4
10130: PUSH
10131: LD_INT 3
10133: PUSH
10134: LD_INT 1
10136: PUSH
10137: EMPTY
10138: LIST
10139: LIST
10140: LIST
10141: PUSH
10142: LD_VAR 0 2
10146: PUSH
10147: LD_INT 3
10149: MOD
10150: PUSH
10151: LD_INT 1
10153: PLUS
10154: ARRAY
10155: PPUSH
10156: LD_INT 1
10158: PPUSH
10159: LD_INT 1
10161: PUSH
10162: LD_INT 3
10164: PUSH
10165: LD_INT 3
10167: PUSH
10168: EMPTY
10169: LIST
10170: LIST
10171: LIST
10172: PUSH
10173: LD_VAR 0 2
10177: PUSH
10178: LD_INT 3
10180: MOD
10181: PUSH
10182: LD_INT 1
10184: PLUS
10185: ARRAY
10186: PPUSH
10187: LD_INT 6
10189: PUSH
10190: LD_INT 12
10192: PUSH
10193: LD_INT 11
10195: PUSH
10196: EMPTY
10197: LIST
10198: LIST
10199: LIST
10200: PUSH
10201: LD_VAR 0 2
10205: PUSH
10206: LD_INT 3
10208: MOD
10209: PUSH
10210: LD_INT 1
10212: PLUS
10213: ARRAY
10214: PPUSH
10215: LD_INT 40
10217: PPUSH
10218: LD_INT 55
10220: PPUSH
10221: CALL_OW 12
10225: PPUSH
10226: CALL 24724 0 5
// veh := CreateVehicle ;
10230: LD_ADDR_VAR 0 6
10234: PUSH
10235: CALL_OW 45
10239: ST_TO_ADDR
// PlaceUnitInArea ( veh , startArea , false ) ;
10240: LD_VAR 0 6
10244: PPUSH
10245: LD_INT 19
10247: PPUSH
10248: LD_INT 0
10250: PPUSH
10251: CALL 56123 0 3
// if GetWeapon ( veh ) = us_cargo_bay then
10255: LD_VAR 0 6
10259: PPUSH
10260: CALL_OW 264
10264: PUSH
10265: LD_INT 12
10267: EQUAL
10268: IFFALSE 10300
// begin AddCargo ( veh , mat_cans , 70 ) ;
10270: LD_VAR 0 6
10274: PPUSH
10275: LD_INT 1
10277: PPUSH
10278: LD_INT 70
10280: PPUSH
10281: CALL_OW 291
// AddCargo ( veh , mat_siberit , 30 ) ;
10285: LD_VAR 0 6
10289: PPUSH
10290: LD_INT 3
10292: PPUSH
10293: LD_INT 30
10295: PPUSH
10296: CALL_OW 291
// end ; if GetControl ( veh ) = control_manual then
10300: LD_VAR 0 6
10304: PPUSH
10305: CALL_OW 263
10309: PUSH
10310: LD_INT 1
10312: EQUAL
10313: IFFALSE 10368
// begin PrepareHuman ( sex_male , 3 , 6 ) ;
10315: LD_INT 1
10317: PPUSH
10318: LD_INT 3
10320: PPUSH
10321: LD_INT 6
10323: PPUSH
10324: CALL_OW 380
// un := CreateHuman ;
10328: LD_ADDR_VAR 0 5
10332: PUSH
10333: CALL_OW 44
10337: ST_TO_ADDR
// tmp := tmp ^ un ;
10338: LD_ADDR_VAR 0 4
10342: PUSH
10343: LD_VAR 0 4
10347: PUSH
10348: LD_VAR 0 5
10352: ADD
10353: ST_TO_ADDR
// PlaceHumanInUnit ( un , veh ) ;
10354: LD_VAR 0 5
10358: PPUSH
10359: LD_VAR 0 6
10363: PPUSH
10364: CALL_OW 52
// end ; end ;
10368: GO 10125
10370: POP
10371: POP
// if tmp then
10372: LD_VAR 0 4
10376: IFFALSE 10440
// begin CenterNowOnUnits ( tmp ) ;
10378: LD_VAR 0 4
10382: PPUSH
10383: CALL_OW 87
// Say ( tmp [ 1 ] , DAR-1 ) ;
10387: LD_VAR 0 4
10391: PUSH
10392: LD_INT 1
10394: ARRAY
10395: PPUSH
10396: LD_STRING DAR-1
10398: PPUSH
10399: CALL_OW 88
// Say ( playerCommander , D & [ I , J , S ] [ commander ] & -1-DAR ) ;
10403: LD_EXP 9
10407: PPUSH
10408: LD_STRING D
10410: PUSH
10411: LD_STRING I
10413: PUSH
10414: LD_STRING J
10416: PUSH
10417: LD_STRING S
10419: PUSH
10420: EMPTY
10421: LIST
10422: LIST
10423: LIST
10424: PUSH
10425: LD_EXP 25
10429: ARRAY
10430: STR
10431: PUSH
10432: LD_STRING -1-DAR
10434: STR
10435: PPUSH
10436: CALL_OW 88
// end ; if not reinforceAllowed then
10440: LD_EXP 24
10444: NOT
10445: IFFALSE 10449
// exit ;
10447: GO 10603
// wait ( 25 25$00 ) ;
10449: LD_INT 52500
10451: PPUSH
10452: CALL_OW 67
// uc_side := 1 ;
10456: LD_ADDR_OWVAR 20
10460: PUSH
10461: LD_INT 1
10463: ST_TO_ADDR
// uc_nation := 1 ;
10464: LD_ADDR_OWVAR 21
10468: PUSH
10469: LD_INT 1
10471: ST_TO_ADDR
// InitVc ;
10472: CALL_OW 20
// InitHc ;
10476: CALL_OW 19
// for i = 1 to 4 do
10480: LD_ADDR_VAR 0 2
10484: PUSH
10485: DOUBLE
10486: LD_INT 1
10488: DEC
10489: ST_TO_ADDR
10490: LD_INT 4
10492: PUSH
10493: FOR_TO
10494: IFFALSE 10601
// begin PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 1 ) ;
10496: LD_INT 5
10498: PPUSH
10499: LD_INT 3
10501: PPUSH
10502: LD_INT 1
10504: PPUSH
10505: LD_INT 6
10507: PPUSH
10508: LD_INT 1
10510: PPUSH
10511: CALL 24724 0 5
// veh := CreateVehicle ;
10515: LD_ADDR_VAR 0 6
10519: PUSH
10520: CALL_OW 45
10524: ST_TO_ADDR
// PlaceUnitInArea ( veh , startArea , false ) ;
10525: LD_VAR 0 6
10529: PPUSH
10530: LD_INT 19
10532: PPUSH
10533: LD_INT 0
10535: PPUSH
10536: CALL 56123 0 3
// if GetControl ( veh ) = control_manual then
10540: LD_VAR 0 6
10544: PPUSH
10545: CALL_OW 263
10549: PUSH
10550: LD_INT 1
10552: EQUAL
10553: IFFALSE 10599
// begin PrepareHuman ( false , 3 , [ 7 , 6 , 5 ] [ Difficulty ] ) ;
10555: LD_INT 0
10557: PPUSH
10558: LD_INT 3
10560: PPUSH
10561: LD_INT 7
10563: PUSH
10564: LD_INT 6
10566: PUSH
10567: LD_INT 5
10569: PUSH
10570: EMPTY
10571: LIST
10572: LIST
10573: LIST
10574: PUSH
10575: LD_OWVAR 67
10579: ARRAY
10580: PPUSH
10581: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , veh ) ;
10585: CALL_OW 44
10589: PPUSH
10590: LD_VAR 0 6
10594: PPUSH
10595: CALL_OW 52
// end ; end ;
10599: GO 10493
10601: POP
10602: POP
// end ;
10603: LD_VAR 0 1
10607: RET
// export function PrepareLegionReinforcements ; var i , un , j , tmp ; begin
10608: LD_INT 0
10610: PPUSH
10611: PPUSH
10612: PPUSH
10613: PPUSH
10614: PPUSH
// uc_side := 8 ;
10615: LD_ADDR_OWVAR 20
10619: PUSH
10620: LD_INT 8
10622: ST_TO_ADDR
// uc_nation := nation_arabian ;
10623: LD_ADDR_OWVAR 21
10627: PUSH
10628: LD_INT 2
10630: ST_TO_ADDR
// for i = 1 to 2 do
10631: LD_ADDR_VAR 0 2
10635: PUSH
10636: DOUBLE
10637: LD_INT 1
10639: DEC
10640: ST_TO_ADDR
10641: LD_INT 2
10643: PUSH
10644: FOR_TO
10645: IFFALSE 10725
// for j = 1 to 4 do
10647: LD_ADDR_VAR 0 4
10651: PUSH
10652: DOUBLE
10653: LD_INT 1
10655: DEC
10656: ST_TO_ADDR
10657: LD_INT 4
10659: PUSH
10660: FOR_TO
10661: IFFALSE 10721
// begin PrepareHuman ( false , j , 8 ) ;
10663: LD_INT 0
10665: PPUSH
10666: LD_VAR 0 4
10670: PPUSH
10671: LD_INT 8
10673: PPUSH
10674: CALL_OW 380
// un := CreateHuman ;
10678: LD_ADDR_VAR 0 3
10682: PUSH
10683: CALL_OW 44
10687: ST_TO_ADDR
// PlaceUnitArea ( un , legionSpawn , false ) ;
10688: LD_VAR 0 3
10692: PPUSH
10693: LD_INT 23
10695: PPUSH
10696: LD_INT 0
10698: PPUSH
10699: CALL_OW 49
// tmp := tmp union un ;
10703: LD_ADDR_VAR 0 5
10707: PUSH
10708: LD_VAR 0 5
10712: PUSH
10713: LD_VAR 0 3
10717: UNION
10718: ST_TO_ADDR
// end ;
10719: GO 10660
10721: POP
10722: POP
10723: GO 10644
10725: POP
10726: POP
// for i in tmp do
10727: LD_ADDR_VAR 0 2
10731: PUSH
10732: LD_VAR 0 5
10736: PUSH
10737: FOR_IN
10738: IFFALSE 10757
// ComMoveXY ( i , 150 , 136 ) ;
10740: LD_VAR 0 2
10744: PPUSH
10745: LD_INT 150
10747: PPUSH
10748: LD_INT 136
10750: PPUSH
10751: CALL_OW 111
10755: GO 10737
10757: POP
10758: POP
// mc_bases := Replace ( mc_bases , mc_leg , mc_bases [ mc_leg ] union tmp ) ;
10759: LD_ADDR_EXP 31
10763: PUSH
10764: LD_EXP 31
10768: PPUSH
10769: LD_EXP 6
10773: PPUSH
10774: LD_EXP 31
10778: PUSH
10779: LD_EXP 6
10783: ARRAY
10784: PUSH
10785: LD_VAR 0 5
10789: UNION
10790: PPUSH
10791: CALL_OW 1
10795: ST_TO_ADDR
// end ;
10796: LD_VAR 0 1
10800: RET
// every 0 0$10 trigger Difficulty > 1 and GetTech ( tech_lapser , 3 ) = state_researched do
10801: LD_OWVAR 67
10805: PUSH
10806: LD_INT 1
10808: GREATER
10809: PUSH
10810: LD_INT 31
10812: PPUSH
10813: LD_INT 3
10815: PPUSH
10816: CALL_OW 321
10820: PUSH
10821: LD_INT 2
10823: EQUAL
10824: AND
10825: IFFALSE 11042
10827: GO 10829
10829: DISABLE
// begin MC_InsertBuildingList ( mc_rus_1 , [ [ b_turret , 101 , 159 , 5 ] , [ b_turret , 105 , 158 , 5 ] , [ b_turret , 96 , 136 , 5 ] , [ b_turret , 94 , 133 , 4 ] , [ b_turret , 84 , 102 , 4 ] ] ) ;
10830: LD_EXP 7
10834: PPUSH
10835: LD_INT 33
10837: PUSH
10838: LD_INT 101
10840: PUSH
10841: LD_INT 159
10843: PUSH
10844: LD_INT 5
10846: PUSH
10847: EMPTY
10848: LIST
10849: LIST
10850: LIST
10851: LIST
10852: PUSH
10853: LD_INT 33
10855: PUSH
10856: LD_INT 105
10858: PUSH
10859: LD_INT 158
10861: PUSH
10862: LD_INT 5
10864: PUSH
10865: EMPTY
10866: LIST
10867: LIST
10868: LIST
10869: LIST
10870: PUSH
10871: LD_INT 33
10873: PUSH
10874: LD_INT 96
10876: PUSH
10877: LD_INT 136
10879: PUSH
10880: LD_INT 5
10882: PUSH
10883: EMPTY
10884: LIST
10885: LIST
10886: LIST
10887: LIST
10888: PUSH
10889: LD_INT 33
10891: PUSH
10892: LD_INT 94
10894: PUSH
10895: LD_INT 133
10897: PUSH
10898: LD_INT 4
10900: PUSH
10901: EMPTY
10902: LIST
10903: LIST
10904: LIST
10905: LIST
10906: PUSH
10907: LD_INT 33
10909: PUSH
10910: LD_INT 84
10912: PUSH
10913: LD_INT 102
10915: PUSH
10916: LD_INT 4
10918: PUSH
10919: EMPTY
10920: LIST
10921: LIST
10922: LIST
10923: LIST
10924: PUSH
10925: EMPTY
10926: LIST
10927: LIST
10928: LIST
10929: LIST
10930: LIST
10931: PPUSH
10932: CALL 85601 0 2
// MC_InsertBuildingList ( mc_rus_2 , [ [ b_turret , 50 , 17 , 4 ] , [ b_turret , 52 , 20 , 4 ] , [ b_turret , 53 , 23 , 4 ] , [ b_turret , 45 , 32 , 4 ] , [ b_turret , 45 , 39 , 4 ] ] ) ;
10936: LD_EXP 8
10940: PPUSH
10941: LD_INT 33
10943: PUSH
10944: LD_INT 50
10946: PUSH
10947: LD_INT 17
10949: PUSH
10950: LD_INT 4
10952: PUSH
10953: EMPTY
10954: LIST
10955: LIST
10956: LIST
10957: LIST
10958: PUSH
10959: LD_INT 33
10961: PUSH
10962: LD_INT 52
10964: PUSH
10965: LD_INT 20
10967: PUSH
10968: LD_INT 4
10970: PUSH
10971: EMPTY
10972: LIST
10973: LIST
10974: LIST
10975: LIST
10976: PUSH
10977: LD_INT 33
10979: PUSH
10980: LD_INT 53
10982: PUSH
10983: LD_INT 23
10985: PUSH
10986: LD_INT 4
10988: PUSH
10989: EMPTY
10990: LIST
10991: LIST
10992: LIST
10993: LIST
10994: PUSH
10995: LD_INT 33
10997: PUSH
10998: LD_INT 45
11000: PUSH
11001: LD_INT 32
11003: PUSH
11004: LD_INT 4
11006: PUSH
11007: EMPTY
11008: LIST
11009: LIST
11010: LIST
11011: LIST
11012: PUSH
11013: LD_INT 33
11015: PUSH
11016: LD_INT 45
11018: PUSH
11019: LD_INT 39
11021: PUSH
11022: LD_INT 4
11024: PUSH
11025: EMPTY
11026: LIST
11027: LIST
11028: LIST
11029: LIST
11030: PUSH
11031: EMPTY
11032: LIST
11033: LIST
11034: LIST
11035: LIST
11036: LIST
11037: PPUSH
11038: CALL 85601 0 2
// end ;
11042: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_not , [ f_side , your_side ] ] , [ f_control , control_remote ] , [ f_ok ] , [ f_not , [ f_linked ] ] ] ) do var i , tmp ;
11043: LD_INT 3
11045: PUSH
11046: LD_INT 22
11048: PUSH
11049: LD_OWVAR 2
11053: PUSH
11054: EMPTY
11055: LIST
11056: LIST
11057: PUSH
11058: EMPTY
11059: LIST
11060: LIST
11061: PUSH
11062: LD_INT 33
11064: PUSH
11065: LD_INT 2
11067: PUSH
11068: EMPTY
11069: LIST
11070: LIST
11071: PUSH
11072: LD_INT 50
11074: PUSH
11075: EMPTY
11076: LIST
11077: PUSH
11078: LD_INT 3
11080: PUSH
11081: LD_INT 61
11083: PUSH
11084: EMPTY
11085: LIST
11086: PUSH
11087: EMPTY
11088: LIST
11089: LIST
11090: PUSH
11091: EMPTY
11092: LIST
11093: LIST
11094: LIST
11095: LIST
11096: PPUSH
11097: CALL_OW 69
11101: IFFALSE 11201
11103: GO 11105
11105: DISABLE
11106: LD_INT 0
11108: PPUSH
11109: PPUSH
// begin enable ;
11110: ENABLE
// tmp := FilterAllUnits ( [ [ f_not , [ f_side , your_side ] ] , [ f_control , control_remote ] , [ f_ok ] , [ f_not , [ f_linked ] ] ] ) ;
11111: LD_ADDR_VAR 0 2
11115: PUSH
11116: LD_INT 3
11118: PUSH
11119: LD_INT 22
11121: PUSH
11122: LD_OWVAR 2
11126: PUSH
11127: EMPTY
11128: LIST
11129: LIST
11130: PUSH
11131: EMPTY
11132: LIST
11133: LIST
11134: PUSH
11135: LD_INT 33
11137: PUSH
11138: LD_INT 2
11140: PUSH
11141: EMPTY
11142: LIST
11143: LIST
11144: PUSH
11145: LD_INT 50
11147: PUSH
11148: EMPTY
11149: LIST
11150: PUSH
11151: LD_INT 3
11153: PUSH
11154: LD_INT 61
11156: PUSH
11157: EMPTY
11158: LIST
11159: PUSH
11160: EMPTY
11161: LIST
11162: LIST
11163: PUSH
11164: EMPTY
11165: LIST
11166: LIST
11167: LIST
11168: LIST
11169: PPUSH
11170: CALL_OW 69
11174: ST_TO_ADDR
// for i in tmp do
11175: LD_ADDR_VAR 0 1
11179: PUSH
11180: LD_VAR 0 2
11184: PUSH
11185: FOR_IN
11186: IFFALSE 11199
// Connect ( i ) ;
11188: LD_VAR 0 1
11192: PPUSH
11193: CALL 27824 0 1
11197: GO 11185
11199: POP
11200: POP
// end ; end_of_file
11201: PPOPN 2
11203: END
// export function Action ; var i , tmp ; begin
11204: LD_INT 0
11206: PPUSH
11207: PPUSH
11208: PPUSH
// InGameOn ;
11209: CALL_OW 8
// CenterNowOnXY ( 225 , 217 ) ;
11213: LD_INT 225
11215: PPUSH
11216: LD_INT 217
11218: PPUSH
11219: CALL_OW 86
// for i in playerForces [ 2 ] do
11223: LD_ADDR_VAR 0 2
11227: PUSH
11228: LD_EXP 10
11232: PUSH
11233: LD_INT 2
11235: ARRAY
11236: PUSH
11237: FOR_IN
11238: IFFALSE 11371
// begin if playerForces [ 1 ] and GetClass ( i ) in [ 3 , 4 ] then
11240: LD_EXP 10
11244: PUSH
11245: LD_INT 1
11247: ARRAY
11248: PUSH
11249: LD_VAR 0 2
11253: PPUSH
11254: CALL_OW 257
11258: PUSH
11259: LD_INT 3
11261: PUSH
11262: LD_INT 4
11264: PUSH
11265: EMPTY
11266: LIST
11267: LIST
11268: IN
11269: AND
11270: IFFALSE 11354
// begin PlaceUnitInArea ( playerForces [ 1 ] [ 1 ] , startArea , false ) ;
11272: LD_EXP 10
11276: PUSH
11277: LD_INT 1
11279: ARRAY
11280: PUSH
11281: LD_INT 1
11283: ARRAY
11284: PPUSH
11285: LD_INT 19
11287: PPUSH
11288: LD_INT 0
11290: PPUSH
11291: CALL 56123 0 3
// PlaceHumanInUnit ( i , playerForces [ 1 ] [ 1 ] ) ;
11295: LD_VAR 0 2
11299: PPUSH
11300: LD_EXP 10
11304: PUSH
11305: LD_INT 1
11307: ARRAY
11308: PUSH
11309: LD_INT 1
11311: ARRAY
11312: PPUSH
11313: CALL_OW 52
// playerForces := Replace ( playerForces , 1 , Delete ( playerForces [ 1 ] , 1 ) ) ;
11317: LD_ADDR_EXP 10
11321: PUSH
11322: LD_EXP 10
11326: PPUSH
11327: LD_INT 1
11329: PPUSH
11330: LD_EXP 10
11334: PUSH
11335: LD_INT 1
11337: ARRAY
11338: PPUSH
11339: LD_INT 1
11341: PPUSH
11342: CALL_OW 3
11346: PPUSH
11347: CALL_OW 1
11351: ST_TO_ADDR
// end else
11352: GO 11369
// PlaceUnitInArea ( i , startArea , false ) ;
11354: LD_VAR 0 2
11358: PPUSH
11359: LD_INT 19
11361: PPUSH
11362: LD_INT 0
11364: PPUSH
11365: CALL 56123 0 3
// end ;
11369: GO 11237
11371: POP
11372: POP
// wait ( 0 0$2 ) ;
11373: LD_INT 70
11375: PPUSH
11376: CALL_OW 67
// Say ( playerCommander , D & [ I , J , S ] [ commander ] & -1 ) ;
11380: LD_EXP 9
11384: PPUSH
11385: LD_STRING D
11387: PUSH
11388: LD_STRING I
11390: PUSH
11391: LD_STRING J
11393: PUSH
11394: LD_STRING S
11396: PUSH
11397: EMPTY
11398: LIST
11399: LIST
11400: LIST
11401: PUSH
11402: LD_EXP 25
11406: ARRAY
11407: STR
11408: PUSH
11409: LD_STRING -1
11411: STR
11412: PPUSH
11413: CALL_OW 88
// SayRadio ( Powell , DP-1 ) ;
11417: LD_EXP 12
11421: PPUSH
11422: LD_STRING DP-1
11424: PPUSH
11425: CALL_OW 94
// SayRadio ( Powell , DP-2 ) ;
11429: LD_EXP 12
11433: PPUSH
11434: LD_STRING DP-2
11436: PPUSH
11437: CALL_OW 94
// Say ( playerCommander , D & [ I , J , S ] [ commander ] & -2 ) ;
11441: LD_EXP 9
11445: PPUSH
11446: LD_STRING D
11448: PUSH
11449: LD_STRING I
11451: PUSH
11452: LD_STRING J
11454: PUSH
11455: LD_STRING S
11457: PUSH
11458: EMPTY
11459: LIST
11460: LIST
11461: LIST
11462: PUSH
11463: LD_EXP 25
11467: ARRAY
11468: STR
11469: PUSH
11470: LD_STRING -2
11472: STR
11473: PPUSH
11474: CALL_OW 88
// InGameOff ;
11478: CALL_OW 9
// ChangeMissionObjectives ( O1 ) ;
11482: LD_STRING O1
11484: PPUSH
11485: CALL_OW 337
// game := true ;
11489: LD_ADDR_EXP 3
11493: PUSH
11494: LD_INT 1
11496: ST_TO_ADDR
// SaveForQuickRestart ;
11497: CALL_OW 22
// wait ( 0 0$5 ) ;
11501: LD_INT 175
11503: PPUSH
11504: CALL_OW 67
// Say ( playerCommander , D & [ I , J , S ] [ commander ] & -3 ) ;
11508: LD_EXP 9
11512: PPUSH
11513: LD_STRING D
11515: PUSH
11516: LD_STRING I
11518: PUSH
11519: LD_STRING J
11521: PUSH
11522: LD_STRING S
11524: PUSH
11525: EMPTY
11526: LIST
11527: LIST
11528: LIST
11529: PUSH
11530: LD_EXP 25
11534: ARRAY
11535: STR
11536: PUSH
11537: LD_STRING -3
11539: STR
11540: PPUSH
11541: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
11545: LD_INT 35
11547: PPUSH
11548: CALL_OW 67
// until ruEscape [ 1 ] >= ruEscape [ 2 ] ;
11552: LD_EXP 15
11556: PUSH
11557: LD_INT 1
11559: ARRAY
11560: PUSH
11561: LD_EXP 15
11565: PUSH
11566: LD_INT 2
11568: ARRAY
11569: GREATEREQUAL
11570: IFFALSE 11545
// outpostEscape := true ;
11572: LD_ADDR_EXP 27
11576: PUSH
11577: LD_INT 1
11579: ST_TO_ADDR
// tmp := UnitFilter ( ruOutpost , [ f_sex , sex_male ] ) ;
11580: LD_ADDR_VAR 0 3
11584: PUSH
11585: LD_EXP 14
11589: PPUSH
11590: LD_INT 26
11592: PUSH
11593: LD_INT 1
11595: PUSH
11596: EMPTY
11597: LIST
11598: LIST
11599: PPUSH
11600: CALL_OW 72
11604: ST_TO_ADDR
// if tmp then
11605: LD_VAR 0 3
11609: IFFALSE 11627
// Say ( tmp [ 1 ] , DR-1-Escape ) ;
11611: LD_VAR 0 3
11615: PUSH
11616: LD_INT 1
11618: ARRAY
11619: PPUSH
11620: LD_STRING DR-1-Escape
11622: PPUSH
11623: CALL_OW 88
// wait ( 0 0$1 ) ;
11627: LD_INT 35
11629: PPUSH
11630: CALL_OW 67
// Say ( playerCommander , D & [ I , J , S ] [ commander ] & -1-Escape ) ;
11634: LD_EXP 9
11638: PPUSH
11639: LD_STRING D
11641: PUSH
11642: LD_STRING I
11644: PUSH
11645: LD_STRING J
11647: PUSH
11648: LD_STRING S
11650: PUSH
11651: EMPTY
11652: LIST
11653: LIST
11654: LIST
11655: PUSH
11656: LD_EXP 25
11660: ARRAY
11661: STR
11662: PUSH
11663: LD_STRING -1-Escape
11665: STR
11666: PPUSH
11667: CALL_OW 88
// for i in ruOutpost do
11671: LD_ADDR_VAR 0 2
11675: PUSH
11676: LD_EXP 14
11680: PUSH
11681: FOR_IN
11682: IFFALSE 11736
// begin if IsInUnit ( i ) then
11684: LD_VAR 0 2
11688: PPUSH
11689: CALL_OW 310
11693: IFFALSE 11704
// ComExitBuilding ( i ) ;
11695: LD_VAR 0 2
11699: PPUSH
11700: CALL_OW 122
// AddComMoveXY ( i , 179 , 102 ) ;
11704: LD_VAR 0 2
11708: PPUSH
11709: LD_INT 179
11711: PPUSH
11712: LD_INT 102
11714: PPUSH
11715: CALL_OW 171
// AddComMoveXY ( i , 28 , 20 ) ;
11719: LD_VAR 0 2
11723: PPUSH
11724: LD_INT 28
11726: PPUSH
11727: LD_INT 20
11729: PPUSH
11730: CALL_OW 171
// end ;
11734: GO 11681
11736: POP
11737: POP
// tmp := [ ] ;
11738: LD_ADDR_VAR 0 3
11742: PUSH
11743: EMPTY
11744: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
11745: LD_INT 35
11747: PPUSH
11748: CALL_OW 67
// tmp := UnitFilter ( ruOutpost , [ f_inarea , rus2Base ] ) ;
11752: LD_ADDR_VAR 0 3
11756: PUSH
11757: LD_EXP 14
11761: PPUSH
11762: LD_INT 95
11764: PUSH
11765: LD_INT 11
11767: PUSH
11768: EMPTY
11769: LIST
11770: LIST
11771: PPUSH
11772: CALL_OW 72
11776: ST_TO_ADDR
// if tmp then
11777: LD_VAR 0 3
11781: IFFALSE 11860
// for i in tmp do
11783: LD_ADDR_VAR 0 2
11787: PUSH
11788: LD_VAR 0 3
11792: PUSH
11793: FOR_IN
11794: IFFALSE 11858
// begin ruOutpost := ruOutpost diff i ;
11796: LD_ADDR_EXP 14
11800: PUSH
11801: LD_EXP 14
11805: PUSH
11806: LD_VAR 0 2
11810: DIFF
11811: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ mc_rus_2 , mc_bases [ mc_rus_2 ] + 1 ] , i ) ;
11812: LD_ADDR_EXP 31
11816: PUSH
11817: LD_EXP 31
11821: PPUSH
11822: LD_EXP 8
11826: PUSH
11827: LD_EXP 31
11831: PUSH
11832: LD_EXP 8
11836: ARRAY
11837: PUSH
11838: LD_INT 1
11840: PLUS
11841: PUSH
11842: EMPTY
11843: LIST
11844: LIST
11845: PPUSH
11846: LD_VAR 0 2
11850: PPUSH
11851: CALL 24846 0 3
11855: ST_TO_ADDR
// end ;
11856: GO 11793
11858: POP
11859: POP
// until not UnitFilter ( ruOutpost , [ f_type , unit_human ] ) ;
11860: LD_EXP 14
11864: PPUSH
11865: LD_INT 21
11867: PUSH
11868: LD_INT 1
11870: PUSH
11871: EMPTY
11872: LIST
11873: LIST
11874: PPUSH
11875: CALL_OW 72
11879: NOT
11880: IFFALSE 11745
// ruOutpost := [ ] ;
11882: LD_ADDR_EXP 14
11886: PUSH
11887: EMPTY
11888: ST_TO_ADDR
// end ;
11889: LD_VAR 0 1
11893: RET
// every 0 0$1 trigger outpostEscape do var i , tmp ;
11894: LD_EXP 27
11898: IFFALSE 12087
11900: GO 11902
11902: DISABLE
11903: LD_INT 0
11905: PPUSH
11906: PPUSH
// begin wait ( rand ( 0 0$25 , 0 0$35 ) ) ;
11907: LD_INT 875
11909: PPUSH
11910: LD_INT 1225
11912: PPUSH
11913: CALL_OW 12
11917: PPUSH
11918: CALL_OW 67
// tmp := [ [ 208 , 166 ] , [ 218 , 174 ] , [ 201 , 173 ] , [ 189 , 167 ] , [ 191 , 160 ] , [ 209 , 181 ] , [ 192 , 162 ] , [ 197 , 166 ] ] ;
11922: LD_ADDR_VAR 0 2
11926: PUSH
11927: LD_INT 208
11929: PUSH
11930: LD_INT 166
11932: PUSH
11933: EMPTY
11934: LIST
11935: LIST
11936: PUSH
11937: LD_INT 218
11939: PUSH
11940: LD_INT 174
11942: PUSH
11943: EMPTY
11944: LIST
11945: LIST
11946: PUSH
11947: LD_INT 201
11949: PUSH
11950: LD_INT 173
11952: PUSH
11953: EMPTY
11954: LIST
11955: LIST
11956: PUSH
11957: LD_INT 189
11959: PUSH
11960: LD_INT 167
11962: PUSH
11963: EMPTY
11964: LIST
11965: LIST
11966: PUSH
11967: LD_INT 191
11969: PUSH
11970: LD_INT 160
11972: PUSH
11973: EMPTY
11974: LIST
11975: LIST
11976: PUSH
11977: LD_INT 209
11979: PUSH
11980: LD_INT 181
11982: PUSH
11983: EMPTY
11984: LIST
11985: LIST
11986: PUSH
11987: LD_INT 192
11989: PUSH
11990: LD_INT 162
11992: PUSH
11993: EMPTY
11994: LIST
11995: LIST
11996: PUSH
11997: LD_INT 197
11999: PUSH
12000: LD_INT 166
12002: PUSH
12003: EMPTY
12004: LIST
12005: LIST
12006: PUSH
12007: EMPTY
12008: LIST
12009: LIST
12010: LIST
12011: LIST
12012: LIST
12013: LIST
12014: LIST
12015: LIST
12016: ST_TO_ADDR
// for i = 1 to 5 + Difficulty do
12017: LD_ADDR_VAR 0 1
12021: PUSH
12022: DOUBLE
12023: LD_INT 1
12025: DEC
12026: ST_TO_ADDR
12027: LD_INT 5
12029: PUSH
12030: LD_OWVAR 67
12034: PLUS
12035: PUSH
12036: FOR_TO
12037: IFFALSE 12085
// begin MineExplosion ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] , 1 ) ;
12039: LD_VAR 0 2
12043: PUSH
12044: LD_VAR 0 1
12048: ARRAY
12049: PUSH
12050: LD_INT 1
12052: ARRAY
12053: PPUSH
12054: LD_VAR 0 2
12058: PUSH
12059: LD_VAR 0 1
12063: ARRAY
12064: PUSH
12065: LD_INT 2
12067: ARRAY
12068: PPUSH
12069: LD_INT 1
12071: PPUSH
12072: CALL_OW 453
// wait ( 0 0$0.8 ) ;
12076: LD_INT 28
12078: PPUSH
12079: CALL_OW 67
// end ;
12083: GO 12036
12085: POP
12086: POP
// end ;
12087: PPOPN 2
12089: END
// every 0 0$3 trigger not outpostEscape do var tmp , engs , buildings , empty , i , j , k ;
12090: LD_EXP 27
12094: NOT
12095: IFFALSE 12749
12097: GO 12099
12099: DISABLE
12100: LD_INT 0
12102: PPUSH
12103: PPUSH
12104: PPUSH
12105: PPUSH
12106: PPUSH
12107: PPUSH
12108: PPUSH
// begin enable ;
12109: ENABLE
// tmp := UnitFilter ( ruOutpost , [ [ f_side , 3 ] , [ f_class , 1 ] ] ) ;
12110: LD_ADDR_VAR 0 1
12114: PUSH
12115: LD_EXP 14
12119: PPUSH
12120: LD_INT 22
12122: PUSH
12123: LD_INT 3
12125: PUSH
12126: EMPTY
12127: LIST
12128: LIST
12129: PUSH
12130: LD_INT 25
12132: PUSH
12133: LD_INT 1
12135: PUSH
12136: EMPTY
12137: LIST
12138: LIST
12139: PUSH
12140: EMPTY
12141: LIST
12142: LIST
12143: PPUSH
12144: CALL_OW 72
12148: ST_TO_ADDR
// engs := UnitFilter ( ruOutpost , [ [ f_side , 3 ] , [ f_class , 2 ] ] ) ;
12149: LD_ADDR_VAR 0 2
12153: PUSH
12154: LD_EXP 14
12158: PPUSH
12159: LD_INT 22
12161: PUSH
12162: LD_INT 3
12164: PUSH
12165: EMPTY
12166: LIST
12167: LIST
12168: PUSH
12169: LD_INT 25
12171: PUSH
12172: LD_INT 2
12174: PUSH
12175: EMPTY
12176: LIST
12177: LIST
12178: PUSH
12179: EMPTY
12180: LIST
12181: LIST
12182: PPUSH
12183: CALL_OW 72
12187: ST_TO_ADDR
// buildings := UnitFilter ( ruOutpost , [ [ f_side , 3 ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
12188: LD_ADDR_VAR 0 3
12192: PUSH
12193: LD_EXP 14
12197: PPUSH
12198: LD_INT 22
12200: PUSH
12201: LD_INT 3
12203: PUSH
12204: EMPTY
12205: LIST
12206: LIST
12207: PUSH
12208: LD_INT 21
12210: PUSH
12211: LD_INT 3
12213: PUSH
12214: EMPTY
12215: LIST
12216: LIST
12217: PUSH
12218: LD_INT 3
12220: PUSH
12221: LD_INT 24
12223: PUSH
12224: LD_INT 1000
12226: PUSH
12227: EMPTY
12228: LIST
12229: LIST
12230: PUSH
12231: EMPTY
12232: LIST
12233: LIST
12234: PUSH
12235: EMPTY
12236: LIST
12237: LIST
12238: LIST
12239: PPUSH
12240: CALL_OW 72
12244: ST_TO_ADDR
// if engs and buildings then
12245: LD_VAR 0 2
12249: PUSH
12250: LD_VAR 0 3
12254: AND
12255: IFFALSE 12328
// begin for i in engs do
12257: LD_ADDR_VAR 0 5
12261: PUSH
12262: LD_VAR 0 2
12266: PUSH
12267: FOR_IN
12268: IFFALSE 12324
// if IsInUnit ( i ) then
12270: LD_VAR 0 5
12274: PPUSH
12275: CALL_OW 310
12279: IFFALSE 12292
// ComExitBuilding ( i ) else
12281: LD_VAR 0 5
12285: PPUSH
12286: CALL_OW 122
12290: GO 12322
// if not HasTask ( i ) then
12292: LD_VAR 0 5
12296: PPUSH
12297: CALL_OW 314
12301: NOT
12302: IFFALSE 12322
// ComRepairBuilding ( i , buildings [ 1 ] ) ;
12304: LD_VAR 0 5
12308: PPUSH
12309: LD_VAR 0 3
12313: PUSH
12314: LD_INT 1
12316: ARRAY
12317: PPUSH
12318: CALL_OW 130
12322: GO 12267
12324: POP
12325: POP
// end else
12326: GO 12431
// if not buildings and UnitFilter ( ruOutpost , [ f_btype , b_depot ] ) and UnitFilter ( engs , [ f_not , [ f_inside ] ] ) then
12328: LD_VAR 0 3
12332: NOT
12333: PUSH
12334: LD_EXP 14
12338: PPUSH
12339: LD_INT 30
12341: PUSH
12342: LD_INT 0
12344: PUSH
12345: EMPTY
12346: LIST
12347: LIST
12348: PPUSH
12349: CALL_OW 72
12353: AND
12354: PUSH
12355: LD_VAR 0 2
12359: PPUSH
12360: LD_INT 3
12362: PUSH
12363: LD_INT 54
12365: PUSH
12366: EMPTY
12367: LIST
12368: PUSH
12369: EMPTY
12370: LIST
12371: LIST
12372: PPUSH
12373: CALL_OW 72
12377: AND
12378: IFFALSE 12431
// ComEnterUnit ( UnitFilter ( engs , [ f_not , [ f_inside ] ] ) , UnitFilter ( ruOutpost , [ f_btype , b_depot ] ) [ 1 ] ) ;
12380: LD_VAR 0 2
12384: PPUSH
12385: LD_INT 3
12387: PUSH
12388: LD_INT 54
12390: PUSH
12391: EMPTY
12392: LIST
12393: PUSH
12394: EMPTY
12395: LIST
12396: LIST
12397: PPUSH
12398: CALL_OW 72
12402: PPUSH
12403: LD_EXP 14
12407: PPUSH
12408: LD_INT 30
12410: PUSH
12411: LD_INT 0
12413: PUSH
12414: EMPTY
12415: LIST
12416: LIST
12417: PPUSH
12418: CALL_OW 72
12422: PUSH
12423: LD_INT 1
12425: ARRAY
12426: PPUSH
12427: CALL_OW 120
// if not tmp then
12431: LD_VAR 0 1
12435: NOT
12436: IFFALSE 12440
// exit ;
12438: GO 12749
// if FilterUnitsInArea ( ruOutpostCenterArea , [ f_enemy , 3 ] ) > 1 then
12440: LD_INT 26
12442: PPUSH
12443: LD_INT 81
12445: PUSH
12446: LD_INT 3
12448: PUSH
12449: EMPTY
12450: LIST
12451: LIST
12452: PPUSH
12453: CALL_OW 70
12457: PUSH
12458: LD_INT 1
12460: GREATER
12461: IFFALSE 12517
// begin for i in tmp do
12463: LD_ADDR_VAR 0 5
12467: PUSH
12468: LD_VAR 0 1
12472: PUSH
12473: FOR_IN
12474: IFFALSE 12513
// begin if IsInUnit ( i ) then
12476: LD_VAR 0 5
12480: PPUSH
12481: CALL_OW 310
12485: IFFALSE 12496
// ComExitBuilding ( i ) ;
12487: LD_VAR 0 5
12491: PPUSH
12492: CALL_OW 122
// AddComAgressiveMove ( i , 204 , 164 ) ;
12496: LD_VAR 0 5
12500: PPUSH
12501: LD_INT 204
12503: PPUSH
12504: LD_INT 164
12506: PPUSH
12507: CALL_OW 174
// end ;
12511: GO 12473
12513: POP
12514: POP
// end else
12515: GO 12749
// if UnitFilter ( tmp , [ f_not , [ f_inside ] ] ) then
12517: LD_VAR 0 1
12521: PPUSH
12522: LD_INT 3
12524: PUSH
12525: LD_INT 54
12527: PUSH
12528: EMPTY
12529: LIST
12530: PUSH
12531: EMPTY
12532: LIST
12533: LIST
12534: PPUSH
12535: CALL_OW 72
12539: IFFALSE 12749
// begin empty := UnitFilter ( ruOutpost , [ [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
12541: LD_ADDR_VAR 0 4
12545: PUSH
12546: LD_EXP 14
12550: PPUSH
12551: LD_INT 30
12553: PUSH
12554: LD_INT 32
12556: PUSH
12557: EMPTY
12558: LIST
12559: LIST
12560: PUSH
12561: LD_INT 58
12563: PUSH
12564: EMPTY
12565: LIST
12566: PUSH
12567: EMPTY
12568: LIST
12569: LIST
12570: PPUSH
12571: CALL_OW 72
12575: ST_TO_ADDR
// if not empty and UnitFilter ( ruOutpost , [ f_btype , b_barracks ] ) then
12576: LD_VAR 0 4
12580: NOT
12581: PUSH
12582: LD_EXP 14
12586: PPUSH
12587: LD_INT 30
12589: PUSH
12590: LD_INT 5
12592: PUSH
12593: EMPTY
12594: LIST
12595: LIST
12596: PPUSH
12597: CALL_OW 72
12601: AND
12602: IFFALSE 12639
// begin ComEnterUnit ( tmp , UnitFilter ( ruOutpost , [ f_btype , b_barracks ] ) [ 1 ] ) ;
12604: LD_VAR 0 1
12608: PPUSH
12609: LD_EXP 14
12613: PPUSH
12614: LD_INT 30
12616: PUSH
12617: LD_INT 5
12619: PUSH
12620: EMPTY
12621: LIST
12622: LIST
12623: PPUSH
12624: CALL_OW 72
12628: PUSH
12629: LD_INT 1
12631: ARRAY
12632: PPUSH
12633: CALL_OW 120
// exit ;
12637: GO 12749
// end ; j := UnitFilter ( tmp , [ f_not , [ f_inside ] ] ) ;
12639: LD_ADDR_VAR 0 6
12643: PUSH
12644: LD_VAR 0 1
12648: PPUSH
12649: LD_INT 3
12651: PUSH
12652: LD_INT 54
12654: PUSH
12655: EMPTY
12656: LIST
12657: PUSH
12658: EMPTY
12659: LIST
12660: LIST
12661: PPUSH
12662: CALL_OW 72
12666: ST_TO_ADDR
// if j < empty then
12667: LD_VAR 0 6
12671: PUSH
12672: LD_VAR 0 4
12676: LESS
12677: IFFALSE 12691
// k := j else
12679: LD_ADDR_VAR 0 7
12683: PUSH
12684: LD_VAR 0 6
12688: ST_TO_ADDR
12689: GO 12701
// k := empty ;
12691: LD_ADDR_VAR 0 7
12695: PUSH
12696: LD_VAR 0 4
12700: ST_TO_ADDR
// for i = 1 to k do
12701: LD_ADDR_VAR 0 5
12705: PUSH
12706: DOUBLE
12707: LD_INT 1
12709: DEC
12710: ST_TO_ADDR
12711: LD_VAR 0 7
12715: PUSH
12716: FOR_TO
12717: IFFALSE 12747
// ComEnterUnit ( j [ i ] , empty [ i ] ) ;
12719: LD_VAR 0 6
12723: PUSH
12724: LD_VAR 0 5
12728: ARRAY
12729: PPUSH
12730: LD_VAR 0 4
12734: PUSH
12735: LD_VAR 0 5
12739: ARRAY
12740: PPUSH
12741: CALL_OW 120
12745: GO 12716
12747: POP
12748: POP
// end ; end ;
12749: PPOPN 7
12751: END
// every 0 0$2 trigger GameType = 1 and outpostEscape and FilterAllUnits ( [ [ f_side , 1 ] , [ f_distxy , 208 , 163 , 8 ] ] ) and not FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_distxy , 208 , 163 , 14 ] ] ) do var i ;
12752: LD_EXP 2
12756: PUSH
12757: LD_INT 1
12759: EQUAL
12760: PUSH
12761: LD_EXP 27
12765: AND
12766: PUSH
12767: LD_INT 22
12769: PUSH
12770: LD_INT 1
12772: PUSH
12773: EMPTY
12774: LIST
12775: LIST
12776: PUSH
12777: LD_INT 92
12779: PUSH
12780: LD_INT 208
12782: PUSH
12783: LD_INT 163
12785: PUSH
12786: LD_INT 8
12788: PUSH
12789: EMPTY
12790: LIST
12791: LIST
12792: LIST
12793: LIST
12794: PUSH
12795: EMPTY
12796: LIST
12797: LIST
12798: PPUSH
12799: CALL_OW 69
12803: AND
12804: PUSH
12805: LD_INT 22
12807: PUSH
12808: LD_INT 3
12810: PUSH
12811: EMPTY
12812: LIST
12813: LIST
12814: PUSH
12815: LD_INT 21
12817: PUSH
12818: LD_INT 1
12820: PUSH
12821: EMPTY
12822: LIST
12823: LIST
12824: PUSH
12825: LD_INT 92
12827: PUSH
12828: LD_INT 208
12830: PUSH
12831: LD_INT 163
12833: PUSH
12834: LD_INT 14
12836: PUSH
12837: EMPTY
12838: LIST
12839: LIST
12840: LIST
12841: LIST
12842: PUSH
12843: EMPTY
12844: LIST
12845: LIST
12846: LIST
12847: PPUSH
12848: CALL_OW 69
12852: NOT
12853: AND
12854: IFFALSE 13159
12856: GO 12858
12858: DISABLE
12859: LD_INT 0
12861: PPUSH
// begin InGameOn ;
12862: CALL_OW 8
// CenterNowOnUnits ( playerCommander ) ;
12866: LD_EXP 9
12870: PPUSH
12871: CALL_OW 87
// wait ( 0 0$1 ) ;
12875: LD_INT 35
12877: PPUSH
12878: CALL_OW 67
// DialogueOn ;
12882: CALL_OW 6
// Say ( playerCommander , D & [ I , J , S ] [ commander ] & -1-BaseCaptured ) ;
12886: LD_EXP 9
12890: PPUSH
12891: LD_STRING D
12893: PUSH
12894: LD_STRING I
12896: PUSH
12897: LD_STRING J
12899: PUSH
12900: LD_STRING S
12902: PUSH
12903: EMPTY
12904: LIST
12905: LIST
12906: LIST
12907: PUSH
12908: LD_EXP 25
12912: ARRAY
12913: STR
12914: PUSH
12915: LD_STRING -1-BaseCaptured
12917: STR
12918: PPUSH
12919: CALL_OW 88
// SayRadio ( Powell , DP-1-BaseCaptured ) ;
12923: LD_EXP 12
12927: PPUSH
12928: LD_STRING DP-1-BaseCaptured
12930: PPUSH
12931: CALL_OW 94
// if sibBombAllowed then
12935: LD_EXP 23
12939: IFFALSE 13081
// begin Say ( playerCommander , D & [ I , J , S ] [ commander ] & -2-BaseCaptured ) ;
12941: LD_EXP 9
12945: PPUSH
12946: LD_STRING D
12948: PUSH
12949: LD_STRING I
12951: PUSH
12952: LD_STRING J
12954: PUSH
12955: LD_STRING S
12957: PUSH
12958: EMPTY
12959: LIST
12960: LIST
12961: LIST
12962: PUSH
12963: LD_EXP 25
12967: ARRAY
12968: STR
12969: PUSH
12970: LD_STRING -2-BaseCaptured
12972: STR
12973: PPUSH
12974: CALL_OW 88
// if commander = 1 then
12978: LD_EXP 25
12982: PUSH
12983: LD_INT 1
12985: EQUAL
12986: IFFALSE 13000
// SayRadio ( Powell , DP-2b-BaseCaptured ) ;
12988: LD_EXP 12
12992: PPUSH
12993: LD_STRING DP-2b-BaseCaptured
12995: PPUSH
12996: CALL_OW 94
// if commander = 2 then
13000: LD_EXP 25
13004: PUSH
13005: LD_INT 2
13007: EQUAL
13008: IFFALSE 13022
// SayRadio ( Powell , DP-2-BaseCaptured ) ;
13010: LD_EXP 12
13014: PPUSH
13015: LD_STRING DP-2-BaseCaptured
13017: PPUSH
13018: CALL_OW 94
// if commander = 3 then
13022: LD_EXP 25
13026: PUSH
13027: LD_INT 3
13029: EQUAL
13030: IFFALSE 13044
// SayRadio ( Powell , DP-2a-BaseCaptured ) ;
13032: LD_EXP 12
13036: PPUSH
13037: LD_STRING DP-2a-BaseCaptured
13039: PPUSH
13040: CALL_OW 94
// Say ( playerCommander , D & [ I , J , S ] [ commander ] & -3-BaseCaptured ) ;
13044: LD_EXP 9
13048: PPUSH
13049: LD_STRING D
13051: PUSH
13052: LD_STRING I
13054: PUSH
13055: LD_STRING J
13057: PUSH
13058: LD_STRING S
13060: PUSH
13061: EMPTY
13062: LIST
13063: LIST
13064: LIST
13065: PUSH
13066: LD_EXP 25
13070: ARRAY
13071: STR
13072: PUSH
13073: LD_STRING -3-BaseCaptured
13075: STR
13076: PPUSH
13077: CALL_OW 88
// end ; DialogueOff ;
13081: CALL_OW 7
// InGameOff ;
13085: CALL_OW 9
// ChangeMissionObjectives ( O2 ) ;
13089: LD_STRING O2
13091: PPUSH
13092: CALL_OW 337
// for i in UnitFilter ( ruOutpost , [ f_type , unit_building ] ) do
13096: LD_ADDR_VAR 0 1
13100: PUSH
13101: LD_EXP 14
13105: PPUSH
13106: LD_INT 21
13108: PUSH
13109: LD_INT 3
13111: PUSH
13112: EMPTY
13113: LIST
13114: LIST
13115: PPUSH
13116: CALL_OW 72
13120: PUSH
13121: FOR_IN
13122: IFFALSE 13138
// SetSide ( i , 1 ) ;
13124: LD_VAR 0 1
13128: PPUSH
13129: LD_INT 1
13131: PPUSH
13132: CALL_OW 235
13136: GO 13121
13138: POP
13139: POP
// baseCaptured := true ;
13140: LD_ADDR_EXP 17
13144: PUSH
13145: LD_INT 1
13147: ST_TO_ADDR
// wait ( 0 0$35 ) ;
13148: LD_INT 1225
13150: PPUSH
13151: CALL_OW 67
// PrepareReinforcements ;
13155: CALL 9908 0 0
// end ;
13159: PPOPN 1
13161: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_distxy , 167 , 197 , 20 ] ] ) > 3 do
13162: LD_INT 22
13164: PUSH
13165: LD_INT 3
13167: PUSH
13168: EMPTY
13169: LIST
13170: LIST
13171: PUSH
13172: LD_INT 92
13174: PUSH
13175: LD_INT 167
13177: PUSH
13178: LD_INT 197
13180: PUSH
13181: LD_INT 20
13183: PUSH
13184: EMPTY
13185: LIST
13186: LIST
13187: LIST
13188: LIST
13189: PUSH
13190: EMPTY
13191: LIST
13192: LIST
13193: PPUSH
13194: CALL_OW 69
13198: PUSH
13199: LD_INT 3
13201: GREATER
13202: IFFALSE 13219
13204: GO 13206
13206: DISABLE
// SayRadio ( Powell , DP-RuAttack ) ;
13207: LD_EXP 12
13211: PPUSH
13212: LD_STRING DP-RuAttack
13214: PPUSH
13215: CALL_OW 94
13219: END
// every 0 0$2 trigger not debug and SeeXY ( 1 , 168 , 74 ) and GetEnvironmentType ( 168 , 72 ) do
13220: LD_EXP 1
13224: NOT
13225: PUSH
13226: LD_INT 1
13228: PPUSH
13229: LD_INT 168
13231: PPUSH
13232: LD_INT 74
13234: PPUSH
13235: CALL_OW 293
13239: AND
13240: PUSH
13241: LD_INT 168
13243: PPUSH
13244: LD_INT 72
13246: PPUSH
13247: CALL_OW 553
13251: AND
13252: IFFALSE 13304
13254: GO 13256
13256: DISABLE
// begin CenterOnXY ( 168 , 72 ) ;
13257: LD_INT 168
13259: PPUSH
13260: LD_INT 72
13262: PPUSH
13263: CALL_OW 84
// Say ( playerCommander , D & [ I , J , S ] [ commander ] & -1-Blockade ) ;
13267: LD_EXP 9
13271: PPUSH
13272: LD_STRING D
13274: PUSH
13275: LD_STRING I
13277: PUSH
13278: LD_STRING J
13280: PUSH
13281: LD_STRING S
13283: PUSH
13284: EMPTY
13285: LIST
13286: LIST
13287: LIST
13288: PUSH
13289: LD_EXP 25
13293: ARRAY
13294: STR
13295: PUSH
13296: LD_STRING -1-Blockade
13298: STR
13299: PPUSH
13300: CALL_OW 88
// end ;
13304: END
// every 0 0$2 trigger GameType = 1 and FilterAllUnits ( [ [ f_side , 1 ] , [ f_see , 4 ] ] ) do
13305: LD_EXP 2
13309: PUSH
13310: LD_INT 1
13312: EQUAL
13313: PUSH
13314: LD_INT 22
13316: PUSH
13317: LD_INT 1
13319: PUSH
13320: EMPTY
13321: LIST
13322: LIST
13323: PUSH
13324: LD_INT 101
13326: PUSH
13327: LD_INT 4
13329: PUSH
13330: EMPTY
13331: LIST
13332: LIST
13333: PUSH
13334: EMPTY
13335: LIST
13336: LIST
13337: PPUSH
13338: CALL_OW 69
13342: AND
13343: IFFALSE 13875
13345: GO 13347
13347: DISABLE
// begin ChangeSideFog ( 4 , 1 ) ;
13348: LD_INT 4
13350: PPUSH
13351: LD_INT 1
13353: PPUSH
13354: CALL_OW 343
// DialogueOn ;
13358: CALL_OW 6
// CenterNowOnUnits ( allyCommander ) ;
13362: LD_EXP 11
13366: PPUSH
13367: CALL_OW 87
// SayRadio ( allyCommander , DM-1-Contact ) ;
13371: LD_EXP 11
13375: PPUSH
13376: LD_STRING DM-1-Contact
13378: PPUSH
13379: CALL_OW 94
// Say ( playerCommander , D & [ I , J , S ] [ commander ] & -1-Contact ) ;
13383: LD_EXP 9
13387: PPUSH
13388: LD_STRING D
13390: PUSH
13391: LD_STRING I
13393: PUSH
13394: LD_STRING J
13396: PUSH
13397: LD_STRING S
13399: PUSH
13400: EMPTY
13401: LIST
13402: LIST
13403: LIST
13404: PUSH
13405: LD_EXP 25
13409: ARRAY
13410: STR
13411: PUSH
13412: LD_STRING -1-Contact
13414: STR
13415: PPUSH
13416: CALL_OW 88
// if commander = 1 then
13420: LD_EXP 25
13424: PUSH
13425: LD_INT 1
13427: EQUAL
13428: IFFALSE 13560
// begin SayRadio ( allyCommander , DM-2-Contact ) ;
13430: LD_EXP 11
13434: PPUSH
13435: LD_STRING DM-2-Contact
13437: PPUSH
13438: CALL_OW 94
// Say ( playerCommander , DI-2-Contact ) ;
13442: LD_EXP 9
13446: PPUSH
13447: LD_STRING DI-2-Contact
13449: PPUSH
13450: CALL_OW 88
// if FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) and GetAttitude ( 8 , 1 ) = att_enemy then
13454: LD_INT 22
13456: PUSH
13457: LD_INT 8
13459: PUSH
13460: EMPTY
13461: LIST
13462: LIST
13463: PUSH
13464: LD_INT 21
13466: PUSH
13467: LD_INT 1
13469: PUSH
13470: EMPTY
13471: LIST
13472: LIST
13473: PUSH
13474: EMPTY
13475: LIST
13476: LIST
13477: PPUSH
13478: CALL_OW 69
13482: PUSH
13483: LD_INT 8
13485: PPUSH
13486: LD_INT 1
13488: PPUSH
13489: CALL_OW 81
13493: PUSH
13494: LD_INT 2
13496: EQUAL
13497: AND
13498: IFFALSE 13524
// begin SayRadio ( allyCommander , DM-3-Contact ) ;
13500: LD_EXP 11
13504: PPUSH
13505: LD_STRING DM-3-Contact
13507: PPUSH
13508: CALL_OW 94
// Say ( playerCommander , DI-3-Contact ) ;
13512: LD_EXP 9
13516: PPUSH
13517: LD_STRING DI-3-Contact
13519: PPUSH
13520: CALL_OW 88
// end ; SayRadio ( allyCommander , DM-4-Contact ) ;
13524: LD_EXP 11
13528: PPUSH
13529: LD_STRING DM-4-Contact
13531: PPUSH
13532: CALL_OW 94
// Say ( playerCommander , DI-4-Contact ) ;
13536: LD_EXP 9
13540: PPUSH
13541: LD_STRING DI-4-Contact
13543: PPUSH
13544: CALL_OW 88
// SayRadio ( allyCommander , DM-5-Contact ) ;
13548: LD_EXP 11
13552: PPUSH
13553: LD_STRING DM-5-Contact
13555: PPUSH
13556: CALL_OW 94
// end ; if commander = 2 then
13560: LD_EXP 25
13564: PUSH
13565: LD_INT 2
13567: EQUAL
13568: IFFALSE 13700
// begin SayRadio ( allyCommander , DM-2c-Contact ) ;
13570: LD_EXP 11
13574: PPUSH
13575: LD_STRING DM-2c-Contact
13577: PPUSH
13578: CALL_OW 94
// Say ( playerCommander , DJ-2-Contact ) ;
13582: LD_EXP 9
13586: PPUSH
13587: LD_STRING DJ-2-Contact
13589: PPUSH
13590: CALL_OW 88
// if FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) and GetAttitude ( 8 , 1 ) = att_enemy then
13594: LD_INT 22
13596: PUSH
13597: LD_INT 8
13599: PUSH
13600: EMPTY
13601: LIST
13602: LIST
13603: PUSH
13604: LD_INT 21
13606: PUSH
13607: LD_INT 1
13609: PUSH
13610: EMPTY
13611: LIST
13612: LIST
13613: PUSH
13614: EMPTY
13615: LIST
13616: LIST
13617: PPUSH
13618: CALL_OW 69
13622: PUSH
13623: LD_INT 8
13625: PPUSH
13626: LD_INT 1
13628: PPUSH
13629: CALL_OW 81
13633: PUSH
13634: LD_INT 2
13636: EQUAL
13637: AND
13638: IFFALSE 13664
// begin SayRadio ( allyCommander , DM-3-Contact ) ;
13640: LD_EXP 11
13644: PPUSH
13645: LD_STRING DM-3-Contact
13647: PPUSH
13648: CALL_OW 94
// Say ( playerCommander , DJ-3-Contact ) ;
13652: LD_EXP 9
13656: PPUSH
13657: LD_STRING DJ-3-Contact
13659: PPUSH
13660: CALL_OW 88
// end ; SayRadio ( allyCommander , DM-4-Contact ) ;
13664: LD_EXP 11
13668: PPUSH
13669: LD_STRING DM-4-Contact
13671: PPUSH
13672: CALL_OW 94
// Say ( playerCommander , DJ-4-Contact ) ;
13676: LD_EXP 9
13680: PPUSH
13681: LD_STRING DJ-4-Contact
13683: PPUSH
13684: CALL_OW 88
// SayRadio ( allyCommander , DM-5a-Contact ) ;
13688: LD_EXP 11
13692: PPUSH
13693: LD_STRING DM-5a-Contact
13695: PPUSH
13696: CALL_OW 94
// end ; if commander = 3 then
13700: LD_EXP 25
13704: PUSH
13705: LD_INT 3
13707: EQUAL
13708: IFFALSE 13864
// begin SayRadio ( allyCommander , DM-2a-Contact ) ;
13710: LD_EXP 11
13714: PPUSH
13715: LD_STRING DM-2a-Contact
13717: PPUSH
13718: CALL_OW 94
// Say ( playerCommander , DS-2a-Contact ) ;
13722: LD_EXP 9
13726: PPUSH
13727: LD_STRING DS-2a-Contact
13729: PPUSH
13730: CALL_OW 88
// SayRadio ( allyCommander , DM-2b-Contact ) ;
13734: LD_EXP 11
13738: PPUSH
13739: LD_STRING DM-2b-Contact
13741: PPUSH
13742: CALL_OW 94
// Say ( playerCommander , DS-2b-Contact ) ;
13746: LD_EXP 9
13750: PPUSH
13751: LD_STRING DS-2b-Contact
13753: PPUSH
13754: CALL_OW 88
// if FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) and GetAttitude ( 8 , 1 ) = att_enemy then
13758: LD_INT 22
13760: PUSH
13761: LD_INT 8
13763: PUSH
13764: EMPTY
13765: LIST
13766: LIST
13767: PUSH
13768: LD_INT 21
13770: PUSH
13771: LD_INT 1
13773: PUSH
13774: EMPTY
13775: LIST
13776: LIST
13777: PUSH
13778: EMPTY
13779: LIST
13780: LIST
13781: PPUSH
13782: CALL_OW 69
13786: PUSH
13787: LD_INT 8
13789: PPUSH
13790: LD_INT 1
13792: PPUSH
13793: CALL_OW 81
13797: PUSH
13798: LD_INT 2
13800: EQUAL
13801: AND
13802: IFFALSE 13828
// begin SayRadio ( allyCommander , DM-3-Contact ) ;
13804: LD_EXP 11
13808: PPUSH
13809: LD_STRING DM-3-Contact
13811: PPUSH
13812: CALL_OW 94
// Say ( playerCommander , DS-3-Contact ) ;
13816: LD_EXP 9
13820: PPUSH
13821: LD_STRING DS-3-Contact
13823: PPUSH
13824: CALL_OW 88
// end ; SayRadio ( allyCommander , DM-4-Contact ) ;
13828: LD_EXP 11
13832: PPUSH
13833: LD_STRING DM-4-Contact
13835: PPUSH
13836: CALL_OW 94
// Say ( playerCommander , DS-4-Contact ) ;
13840: LD_EXP 9
13844: PPUSH
13845: LD_STRING DS-4-Contact
13847: PPUSH
13848: CALL_OW 88
// SayRadio ( allyCommander , DM-5-Contact ) ;
13852: LD_EXP 11
13856: PPUSH
13857: LD_STRING DM-5-Contact
13859: PPUSH
13860: CALL_OW 94
// end ; DialogueOff ;
13864: CALL_OW 7
// ChangeMissionObjectives ( O3 ) ;
13868: LD_STRING O3
13870: PPUSH
13871: CALL_OW 337
// end ;
13875: END
// every 0 0$10 trigger GameType = 1 and legDestCounter >= [ 15 , 20 , 25 ] [ Difficulty ] and FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_warehouse ] ] ) and FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] ] ) >= 5 do var time , sib , sources , i ;
13876: LD_EXP 2
13880: PUSH
13881: LD_INT 1
13883: EQUAL
13884: PUSH
13885: LD_EXP 18
13889: PUSH
13890: LD_INT 15
13892: PUSH
13893: LD_INT 20
13895: PUSH
13896: LD_INT 25
13898: PUSH
13899: EMPTY
13900: LIST
13901: LIST
13902: LIST
13903: PUSH
13904: LD_OWVAR 67
13908: ARRAY
13909: GREATEREQUAL
13910: AND
13911: PUSH
13912: LD_INT 22
13914: PUSH
13915: LD_INT 8
13917: PUSH
13918: EMPTY
13919: LIST
13920: LIST
13921: PUSH
13922: LD_INT 30
13924: PUSH
13925: LD_INT 1
13927: PUSH
13928: EMPTY
13929: LIST
13930: LIST
13931: PUSH
13932: EMPTY
13933: LIST
13934: LIST
13935: PPUSH
13936: CALL_OW 69
13940: AND
13941: PUSH
13942: LD_INT 22
13944: PUSH
13945: LD_INT 8
13947: PUSH
13948: EMPTY
13949: LIST
13950: LIST
13951: PUSH
13952: LD_INT 21
13954: PUSH
13955: LD_INT 3
13957: PUSH
13958: EMPTY
13959: LIST
13960: LIST
13961: PUSH
13962: EMPTY
13963: LIST
13964: LIST
13965: PPUSH
13966: CALL_OW 69
13970: PUSH
13971: LD_INT 5
13973: GREATEREQUAL
13974: AND
13975: IFFALSE 14498
13977: GO 13979
13979: DISABLE
13980: LD_INT 0
13982: PPUSH
13983: PPUSH
13984: PPUSH
13985: PPUSH
// begin DialogueOn ;
13986: CALL_OW 6
// SayRadio ( Farmer , DF-1-Leg ) ;
13990: LD_EXP 13
13994: PPUSH
13995: LD_STRING DF-1-Leg
13997: PPUSH
13998: CALL_OW 94
// Say ( playerCommander , D & [ I , J , S ] [ commander ] & -1-Leg ) ;
14002: LD_EXP 9
14006: PPUSH
14007: LD_STRING D
14009: PUSH
14010: LD_STRING I
14012: PUSH
14013: LD_STRING J
14015: PUSH
14016: LD_STRING S
14018: PUSH
14019: EMPTY
14020: LIST
14021: LIST
14022: LIST
14023: PUSH
14024: LD_EXP 25
14028: ARRAY
14029: STR
14030: PUSH
14031: LD_STRING -1-Leg
14033: STR
14034: PPUSH
14035: CALL_OW 88
// SayRadio ( Farmer , DF-2-Leg ) ;
14039: LD_EXP 13
14043: PPUSH
14044: LD_STRING DF-2-Leg
14046: PPUSH
14047: CALL_OW 94
// DialogueOff ;
14051: CALL_OW 7
// case Query ( QLegionOffer ) of 1 :
14055: LD_STRING QLegionOffer
14057: PPUSH
14058: CALL_OW 97
14062: PUSH
14063: LD_INT 1
14065: DOUBLE
14066: EQUAL
14067: IFTRUE 14071
14069: GO 14074
14071: POP
// ; 2 :
14072: GO 14088
14074: LD_INT 2
14076: DOUBLE
14077: EQUAL
14078: IFTRUE 14082
14080: GO 14087
14082: POP
// exit ; end ;
14083: GO 14498
14085: GO 14088
14087: POP
// Say ( playerCommander , D & [ I , J , S ] [ commander ] & -2-Leg ) ;
14088: LD_EXP 9
14092: PPUSH
14093: LD_STRING D
14095: PUSH
14096: LD_STRING I
14098: PUSH
14099: LD_STRING J
14101: PUSH
14102: LD_STRING S
14104: PUSH
14105: EMPTY
14106: LIST
14107: LIST
14108: LIST
14109: PUSH
14110: LD_EXP 25
14114: ARRAY
14115: STR
14116: PUSH
14117: LD_STRING -2-Leg
14119: STR
14120: PPUSH
14121: CALL_OW 88
// legOfferAccepted := true ;
14125: LD_ADDR_EXP 20
14129: PUSH
14130: LD_INT 1
14132: ST_TO_ADDR
// SetAreaMapShow ( legOfferArea , 1 ) ;
14133: LD_INT 21
14135: PPUSH
14136: LD_INT 1
14138: PPUSH
14139: CALL_OW 424
// CenterOnXY ( 190 , 227 ) ;
14143: LD_INT 190
14145: PPUSH
14146: LD_INT 227
14148: PPUSH
14149: CALL_OW 84
// time := [ 8 8$00 , 7 7$00 , 6 6$00 ] [ Difficulty ] ;
14153: LD_ADDR_VAR 0 1
14157: PUSH
14158: LD_INT 16800
14160: PUSH
14161: LD_INT 14700
14163: PUSH
14164: LD_INT 12600
14166: PUSH
14167: EMPTY
14168: LIST
14169: LIST
14170: LIST
14171: PUSH
14172: LD_OWVAR 67
14176: ARRAY
14177: ST_TO_ADDR
// sib := 100 ;
14178: LD_ADDR_VAR 0 2
14182: PUSH
14183: LD_INT 100
14185: ST_TO_ADDR
// disableGlobalTimer := true ;
14186: LD_ADDR_EXP 4
14190: PUSH
14191: LD_INT 1
14193: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
14194: LD_INT 35
14196: PPUSH
14197: CALL_OW 67
// time := time - 0 0$1 ;
14201: LD_ADDR_VAR 0 1
14205: PUSH
14206: LD_VAR 0 1
14210: PUSH
14211: LD_INT 35
14213: MINUS
14214: ST_TO_ADDR
// sources := GetResourceArea ( legOfferArea , mat_siberit ) ;
14215: LD_ADDR_VAR 0 3
14219: PUSH
14220: LD_INT 21
14222: PPUSH
14223: LD_INT 3
14225: PPUSH
14226: CALL_OW 287
14230: ST_TO_ADDR
// display_strings := [ #SkrTime , tick , #Skr-LegOffer , sib , time ] ;
14231: LD_ADDR_OWVAR 47
14235: PUSH
14236: LD_STRING #SkrTime
14238: PUSH
14239: LD_OWVAR 1
14243: PUSH
14244: LD_STRING #Skr-LegOffer
14246: PUSH
14247: LD_VAR 0 2
14251: PUSH
14252: LD_VAR 0 1
14256: PUSH
14257: EMPTY
14258: LIST
14259: LIST
14260: LIST
14261: LIST
14262: LIST
14263: ST_TO_ADDR
// if sources then
14264: LD_VAR 0 3
14268: IFFALSE 14300
// begin sib := sib - sources * 10 ;
14270: LD_ADDR_VAR 0 2
14274: PUSH
14275: LD_VAR 0 2
14279: PUSH
14280: LD_VAR 0 3
14284: PUSH
14285: LD_INT 10
14287: MUL
14288: MINUS
14289: ST_TO_ADDR
// EraseResourceArea ( legOfferArea , mat_siberit ) ;
14290: LD_INT 21
14292: PPUSH
14293: LD_INT 3
14295: PPUSH
14296: CALL_OW 286
// end ; until time = 0 0$00 or sib <= 0 or not FilterAllUnits ( [ f_side , 8 ] ) ;
14300: LD_VAR 0 1
14304: PUSH
14305: LD_INT 0
14307: EQUAL
14308: PUSH
14309: LD_VAR 0 2
14313: PUSH
14314: LD_INT 0
14316: LESSEQUAL
14317: OR
14318: PUSH
14319: LD_INT 22
14321: PUSH
14322: LD_INT 8
14324: PUSH
14325: EMPTY
14326: LIST
14327: LIST
14328: PPUSH
14329: CALL_OW 69
14333: NOT
14334: OR
14335: IFFALSE 14194
// SetAreaMapShow ( legOfferArea , 0 ) ;
14337: LD_INT 21
14339: PPUSH
14340: LD_INT 0
14342: PPUSH
14343: CALL_OW 424
// disableGlobalTimer := false ;
14347: LD_ADDR_EXP 4
14351: PUSH
14352: LD_INT 0
14354: ST_TO_ADDR
// if sib <= 0 then
14355: LD_VAR 0 2
14359: PUSH
14360: LD_INT 0
14362: LESSEQUAL
14363: IFFALSE 14479
// begin legChangeSide := true ;
14365: LD_ADDR_EXP 21
14369: PUSH
14370: LD_INT 1
14372: ST_TO_ADDR
// SayRadio ( Farmer , DF-4y-Leg ) ;
14373: LD_EXP 13
14377: PPUSH
14378: LD_STRING DF-4y-Leg
14380: PPUSH
14381: CALL_OW 94
// ChangeMissionObjectives ( O3a ) ;
14385: LD_STRING O3a
14387: PPUSH
14388: CALL_OW 337
// ChangeSideFog ( 8 , 1 ) ;
14392: LD_INT 8
14394: PPUSH
14395: LD_INT 1
14397: PPUSH
14398: CALL_OW 343
// SetAttitude ( 8 , 1 , att_friend , true ) ;
14402: LD_INT 8
14404: PPUSH
14405: LD_INT 1
14407: PPUSH
14408: LD_INT 1
14410: PPUSH
14411: LD_INT 1
14413: PPUSH
14414: CALL_OW 80
// SetAttitude ( 8 , 4 , att_friend , true ) ;
14418: LD_INT 8
14420: PPUSH
14421: LD_INT 4
14423: PPUSH
14424: LD_INT 1
14426: PPUSH
14427: LD_INT 1
14429: PPUSH
14430: CALL_OW 80
// SetAttitude ( 8 , 6 , att_enemy , true ) ;
14434: LD_INT 8
14436: PPUSH
14437: LD_INT 6
14439: PPUSH
14440: LD_INT 2
14442: PPUSH
14443: LD_INT 1
14445: PPUSH
14446: CALL_OW 80
// SetAttitude ( 8 , 3 , att_enemy , true ) ;
14450: LD_INT 8
14452: PPUSH
14453: LD_INT 3
14455: PPUSH
14456: LD_INT 2
14458: PPUSH
14459: LD_INT 1
14461: PPUSH
14462: CALL_OW 80
// wait ( 0 0$30 ) ;
14466: LD_INT 1050
14468: PPUSH
14469: CALL_OW 67
// PrepareLegionReinforcements ;
14473: CALL 10608 0 0
// end else
14477: GO 14498
// begin ChangeMissionObjectives ( O3a ) ;
14479: LD_STRING O3a
14481: PPUSH
14482: CALL_OW 337
// SayRadio ( Farmer , DF-4n-Leg ) ;
14486: LD_EXP 13
14490: PPUSH
14491: LD_STRING DF-4n-Leg
14493: PPUSH
14494: CALL_OW 94
// end ; end ;
14498: PPOPN 4
14500: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) = 0 and GetAttitude ( 8 , 1 ) = att_enemy do
14501: LD_INT 22
14503: PUSH
14504: LD_INT 8
14506: PUSH
14507: EMPTY
14508: LIST
14509: LIST
14510: PUSH
14511: LD_INT 21
14513: PUSH
14514: LD_INT 1
14516: PUSH
14517: EMPTY
14518: LIST
14519: LIST
14520: PUSH
14521: EMPTY
14522: LIST
14523: LIST
14524: PPUSH
14525: CALL_OW 69
14529: PUSH
14530: LD_INT 0
14532: EQUAL
14533: PUSH
14534: LD_INT 8
14536: PPUSH
14537: LD_INT 1
14539: PPUSH
14540: CALL_OW 81
14544: PUSH
14545: LD_INT 2
14547: EQUAL
14548: AND
14549: IFFALSE 14561
14551: GO 14553
14553: DISABLE
// ChangeMissionObjectives ( O3a ) ;
14554: LD_STRING O3a
14556: PPUSH
14557: CALL_OW 337
14561: END
// every 0 0$1 trigger GameType = 1 and game and FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_warehouse ] ] ) = 0 do
14562: LD_EXP 2
14566: PUSH
14567: LD_INT 1
14569: EQUAL
14570: PUSH
14571: LD_EXP 3
14575: AND
14576: PUSH
14577: LD_INT 22
14579: PUSH
14580: LD_INT 3
14582: PUSH
14583: EMPTY
14584: LIST
14585: LIST
14586: PUSH
14587: LD_INT 21
14589: PUSH
14590: LD_INT 1
14592: PUSH
14593: EMPTY
14594: LIST
14595: LIST
14596: PUSH
14597: EMPTY
14598: LIST
14599: LIST
14600: PPUSH
14601: CALL_OW 69
14605: PUSH
14606: LD_INT 0
14608: EQUAL
14609: AND
14610: PUSH
14611: LD_INT 22
14613: PUSH
14614: LD_INT 3
14616: PUSH
14617: EMPTY
14618: LIST
14619: LIST
14620: PUSH
14621: LD_INT 30
14623: PUSH
14624: LD_INT 1
14626: PUSH
14627: EMPTY
14628: LIST
14629: LIST
14630: PUSH
14631: EMPTY
14632: LIST
14633: LIST
14634: PPUSH
14635: CALL_OW 69
14639: PUSH
14640: LD_INT 0
14642: EQUAL
14643: AND
14644: IFFALSE 14882
14646: GO 14648
14648: DISABLE
// begin Say ( playerCommander , D & [ I , J , S ] [ commander ] & -1-Win ) ;
14649: LD_EXP 9
14653: PPUSH
14654: LD_STRING D
14656: PUSH
14657: LD_STRING I
14659: PUSH
14660: LD_STRING J
14662: PUSH
14663: LD_STRING S
14665: PUSH
14666: EMPTY
14667: LIST
14668: LIST
14669: LIST
14670: PUSH
14671: LD_EXP 25
14675: ARRAY
14676: STR
14677: PUSH
14678: LD_STRING -1-Win
14680: STR
14681: PPUSH
14682: CALL_OW 88
// if tick >= [ 150 150$0 , 130 130$0 , 110 110$0 ] [ Difficulty ] then
14686: LD_OWVAR 1
14690: PUSH
14691: LD_INT 315000
14693: PUSH
14694: LD_INT 273000
14696: PUSH
14697: LD_INT 231000
14699: PUSH
14700: EMPTY
14701: LIST
14702: LIST
14703: LIST
14704: PUSH
14705: LD_OWVAR 67
14709: ARRAY
14710: GREATEREQUAL
14711: IFFALSE 14726
// AddMedal ( med1 , - 1 ) else
14713: LD_STRING med1
14715: PPUSH
14716: LD_INT 1
14718: NEG
14719: PPUSH
14720: CALL_OW 101
14724: GO 14736
// AddMedal ( med1 , 1 ) ;
14726: LD_STRING med1
14728: PPUSH
14729: LD_INT 1
14731: PPUSH
14732: CALL_OW 101
// if allyDestCounter >= [ 20 , 15 , 10 ] [ Difficulty ] then
14736: LD_EXP 22
14740: PUSH
14741: LD_INT 20
14743: PUSH
14744: LD_INT 15
14746: PUSH
14747: LD_INT 10
14749: PUSH
14750: EMPTY
14751: LIST
14752: LIST
14753: LIST
14754: PUSH
14755: LD_OWVAR 67
14759: ARRAY
14760: GREATEREQUAL
14761: IFFALSE 14776
// AddMedal ( med2 , - 1 ) else
14763: LD_STRING med2
14765: PPUSH
14766: LD_INT 1
14768: NEG
14769: PPUSH
14770: CALL_OW 101
14774: GO 14786
// AddMedal ( med2 , 1 ) ;
14776: LD_STRING med2
14778: PPUSH
14779: LD_INT 1
14781: PPUSH
14782: CALL_OW 101
// if GetAttitude ( 8 , 1 ) = att_friend then
14786: LD_INT 8
14788: PPUSH
14789: LD_INT 1
14791: PPUSH
14792: CALL_OW 81
14796: PUSH
14797: LD_INT 1
14799: EQUAL
14800: IFFALSE 14814
// AddMedal ( med3 , 1 ) else
14802: LD_STRING med3
14804: PPUSH
14805: LD_INT 1
14807: PPUSH
14808: CALL_OW 101
14812: GO 14871
// if FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) = 0 then
14814: LD_INT 22
14816: PUSH
14817: LD_INT 8
14819: PUSH
14820: EMPTY
14821: LIST
14822: LIST
14823: PUSH
14824: LD_INT 21
14826: PUSH
14827: LD_INT 1
14829: PUSH
14830: EMPTY
14831: LIST
14832: LIST
14833: PUSH
14834: EMPTY
14835: LIST
14836: LIST
14837: PPUSH
14838: CALL_OW 69
14842: PUSH
14843: LD_INT 0
14845: EQUAL
14846: IFFALSE 14860
// AddMedal ( med3 , 2 ) else
14848: LD_STRING med3
14850: PPUSH
14851: LD_INT 2
14853: PPUSH
14854: CALL_OW 101
14858: GO 14871
// AddMedal ( med3 , - 1 ) ;
14860: LD_STRING med3
14862: PPUSH
14863: LD_INT 1
14865: NEG
14866: PPUSH
14867: CALL_OW 101
// GiveMedals ( MAIN ) ;
14871: LD_STRING MAIN
14873: PPUSH
14874: CALL_OW 102
// YouWin ;
14878: CALL_OW 103
// end ;
14882: END
// every 10 trigger GameType = 1 and staticMines and FilterUnitsInArea ( minesArea , [ f_enemy , 8 ] ) do var i , j , tmp , x , y ;
14883: LD_EXP 2
14887: PUSH
14888: LD_INT 1
14890: EQUAL
14891: PUSH
14892: LD_EXP 16
14896: AND
14897: PUSH
14898: LD_INT 20
14900: PPUSH
14901: LD_INT 81
14903: PUSH
14904: LD_INT 8
14906: PUSH
14907: EMPTY
14908: LIST
14909: LIST
14910: PPUSH
14911: CALL_OW 70
14915: AND
14916: IFFALSE 15195
14918: GO 14920
14920: DISABLE
14921: LD_INT 0
14923: PPUSH
14924: PPUSH
14925: PPUSH
14926: PPUSH
14927: PPUSH
// begin enable ;
14928: ENABLE
// tmp := FilterUnitsInArea ( minesArea , [ f_enemy , 8 ] ) ;
14929: LD_ADDR_VAR 0 3
14933: PUSH
14934: LD_INT 20
14936: PPUSH
14937: LD_INT 81
14939: PUSH
14940: LD_INT 8
14942: PUSH
14943: EMPTY
14944: LIST
14945: LIST
14946: PPUSH
14947: CALL_OW 70
14951: ST_TO_ADDR
// if not tmp then
14952: LD_VAR 0 3
14956: NOT
14957: IFFALSE 14961
// exit ;
14959: GO 15195
// for i in tmp do
14961: LD_ADDR_VAR 0 1
14965: PUSH
14966: LD_VAR 0 3
14970: PUSH
14971: FOR_IN
14972: IFFALSE 15193
// begin x := GetX ( i ) ;
14974: LD_ADDR_VAR 0 4
14978: PUSH
14979: LD_VAR 0 1
14983: PPUSH
14984: CALL_OW 250
14988: ST_TO_ADDR
// y := GetY ( i ) ;
14989: LD_ADDR_VAR 0 5
14993: PUSH
14994: LD_VAR 0 1
14998: PPUSH
14999: CALL_OW 251
15003: ST_TO_ADDR
// if MineAtPos ( x , y ) then
15004: LD_VAR 0 4
15008: PPUSH
15009: LD_VAR 0 5
15013: PPUSH
15014: CALL_OW 458
15018: IFFALSE 15191
// begin LaunchMineAtPos ( x , y , 8 ) ;
15020: LD_VAR 0 4
15024: PPUSH
15025: LD_VAR 0 5
15029: PPUSH
15030: LD_INT 8
15032: PPUSH
15033: CALL_OW 456
// if not dialogueMineDetected then
15037: LD_EXP 28
15041: NOT
15042: IFFALSE 15103
// begin dialogueMineDetected := true ;
15044: LD_ADDR_EXP 28
15048: PUSH
15049: LD_INT 1
15051: ST_TO_ADDR
// CenterNowOnXY ( x , y ) ;
15052: LD_VAR 0 4
15056: PPUSH
15057: LD_VAR 0 5
15061: PPUSH
15062: CALL_OW 86
// Say ( playerCommander , D & [ I , J , S ] [ commander ] & -1-Mine ) ;
15066: LD_EXP 9
15070: PPUSH
15071: LD_STRING D
15073: PUSH
15074: LD_STRING I
15076: PUSH
15077: LD_STRING J
15079: PUSH
15080: LD_STRING S
15082: PUSH
15083: EMPTY
15084: LIST
15085: LIST
15086: LIST
15087: PUSH
15088: LD_EXP 25
15092: ARRAY
15093: STR
15094: PUSH
15095: LD_STRING -1-Mine
15097: STR
15098: PPUSH
15099: CALL_OW 88
// end ; for j = 1 to staticMines do
15103: LD_ADDR_VAR 0 2
15107: PUSH
15108: DOUBLE
15109: LD_INT 1
15111: DEC
15112: ST_TO_ADDR
15113: LD_EXP 16
15117: PUSH
15118: FOR_TO
15119: IFFALSE 15189
// if staticMines [ j ] [ 1 ] = x and staticMines [ j ] [ 2 ] = y then
15121: LD_EXP 16
15125: PUSH
15126: LD_VAR 0 2
15130: ARRAY
15131: PUSH
15132: LD_INT 1
15134: ARRAY
15135: PUSH
15136: LD_VAR 0 4
15140: EQUAL
15141: PUSH
15142: LD_EXP 16
15146: PUSH
15147: LD_VAR 0 2
15151: ARRAY
15152: PUSH
15153: LD_INT 2
15155: ARRAY
15156: PUSH
15157: LD_VAR 0 5
15161: EQUAL
15162: AND
15163: IFFALSE 15187
// begin staticMines := Delete ( staticMines , j ) ;
15165: LD_ADDR_EXP 16
15169: PUSH
15170: LD_EXP 16
15174: PPUSH
15175: LD_VAR 0 2
15179: PPUSH
15180: CALL_OW 3
15184: ST_TO_ADDR
// break ;
15185: GO 15189
// end ;
15187: GO 15118
15189: POP
15190: POP
// end ; end ;
15191: GO 14971
15193: POP
15194: POP
// end ;
15195: PPOPN 5
15197: END
// every 30 30$00 + 50 50$00 trigger GameType = 1 and game and sibBombAllowed and UnitFilter ( mc_bases [ mc_rus_1 ] , [ f_btype , b_factory ] ) do var bomb , e ;
15198: LD_EXP 2
15202: PUSH
15203: LD_INT 1
15205: EQUAL
15206: PUSH
15207: LD_EXP 3
15211: AND
15212: PUSH
15213: LD_EXP 23
15217: AND
15218: PUSH
15219: LD_EXP 31
15223: PUSH
15224: LD_EXP 7
15228: ARRAY
15229: PPUSH
15230: LD_INT 30
15232: PUSH
15233: LD_INT 3
15235: PUSH
15236: EMPTY
15237: LIST
15238: LIST
15239: PPUSH
15240: CALL_OW 72
15244: AND
15245: IFFALSE 15449
15247: GO 15249
15249: DISABLE
15250: LD_INT 0
15252: PPUSH
15253: PPUSH
// begin enable ;
15254: ENABLE
// MC_InsertProduceList ( mc_rus_1 , [ [ ru_heavy_wheeled , engine_siberite , control_computer , ru_siberium_rocket ] ] ) ;
15255: LD_EXP 7
15259: PPUSH
15260: LD_INT 23
15262: PUSH
15263: LD_INT 3
15265: PUSH
15266: LD_INT 3
15268: PUSH
15269: LD_INT 48
15271: PUSH
15272: EMPTY
15273: LIST
15274: LIST
15275: LIST
15276: LIST
15277: PUSH
15278: EMPTY
15279: LIST
15280: PPUSH
15281: CALL 85709 0 2
// repeat wait ( 0 0$1 ) ;
15285: LD_INT 35
15287: PPUSH
15288: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) ;
15292: LD_INT 22
15294: PUSH
15295: LD_INT 3
15297: PUSH
15298: EMPTY
15299: LIST
15300: LIST
15301: PUSH
15302: LD_INT 34
15304: PUSH
15305: LD_INT 48
15307: PUSH
15308: EMPTY
15309: LIST
15310: LIST
15311: PUSH
15312: EMPTY
15313: LIST
15314: LIST
15315: PPUSH
15316: CALL_OW 69
15320: IFFALSE 15285
// bomb := FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) ;
15322: LD_ADDR_VAR 0 1
15326: PUSH
15327: LD_INT 22
15329: PUSH
15330: LD_INT 3
15332: PUSH
15333: EMPTY
15334: LIST
15335: LIST
15336: PUSH
15337: LD_INT 34
15339: PUSH
15340: LD_INT 48
15342: PUSH
15343: EMPTY
15344: LIST
15345: LIST
15346: PUSH
15347: EMPTY
15348: LIST
15349: LIST
15350: PPUSH
15351: CALL_OW 69
15355: ST_TO_ADDR
// e := FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_type , unit_building ] ] ) ;
15356: LD_ADDR_VAR 0 2
15360: PUSH
15361: LD_INT 81
15363: PUSH
15364: LD_INT 3
15366: PUSH
15367: EMPTY
15368: LIST
15369: LIST
15370: PUSH
15371: LD_INT 21
15373: PUSH
15374: LD_INT 3
15376: PUSH
15377: EMPTY
15378: LIST
15379: LIST
15380: PUSH
15381: EMPTY
15382: LIST
15383: LIST
15384: PPUSH
15385: CALL_OW 69
15389: ST_TO_ADDR
// if e then
15390: LD_VAR 0 2
15394: IFFALSE 15420
// e := NearestUnitToUnit ( e , bomb [ 1 ] ) ;
15396: LD_ADDR_VAR 0 2
15400: PUSH
15401: LD_VAR 0 2
15405: PPUSH
15406: LD_VAR 0 1
15410: PUSH
15411: LD_INT 1
15413: ARRAY
15414: PPUSH
15415: CALL_OW 74
15419: ST_TO_ADDR
// ComAttackPlace ( bomb , GetX ( e ) , GetY ( e ) ) ;
15420: LD_VAR 0 1
15424: PPUSH
15425: LD_VAR 0 2
15429: PPUSH
15430: CALL_OW 250
15434: PPUSH
15435: LD_VAR 0 2
15439: PPUSH
15440: CALL_OW 251
15444: PPUSH
15445: CALL_OW 116
// end ;
15449: PPOPN 2
15451: END
// every 0 0$2 trigger Difficulty > 1 and UnitFilter ( mc_bases [ mc_rus_1 ] , [ f_class , 3 ] ) and GameType = 1 and game and GetTech ( tech_Behemoth , 3 ) = state_researched do var tmp , i ;
15452: LD_OWVAR 67
15456: PUSH
15457: LD_INT 1
15459: GREATER
15460: PUSH
15461: LD_EXP 31
15465: PUSH
15466: LD_EXP 7
15470: ARRAY
15471: PPUSH
15472: LD_INT 25
15474: PUSH
15475: LD_INT 3
15477: PUSH
15478: EMPTY
15479: LIST
15480: LIST
15481: PPUSH
15482: CALL_OW 72
15486: AND
15487: PUSH
15488: LD_EXP 2
15492: PUSH
15493: LD_INT 1
15495: EQUAL
15496: AND
15497: PUSH
15498: LD_EXP 3
15502: AND
15503: PUSH
15504: LD_INT 23
15506: PPUSH
15507: LD_INT 3
15509: PPUSH
15510: CALL_OW 321
15514: PUSH
15515: LD_INT 2
15517: EQUAL
15518: AND
15519: IFFALSE 15646
15521: GO 15523
15523: DISABLE
15524: LD_INT 0
15526: PPUSH
15527: PPUSH
// begin tmp := UnitFilter ( mc_bases [ mc_rus_1 ] , [ f_class , 3 ] ) ;
15528: LD_ADDR_VAR 0 1
15532: PUSH
15533: LD_EXP 31
15537: PUSH
15538: LD_EXP 7
15542: ARRAY
15543: PPUSH
15544: LD_INT 25
15546: PUSH
15547: LD_INT 3
15549: PUSH
15550: EMPTY
15551: LIST
15552: LIST
15553: PPUSH
15554: CALL_OW 72
15558: ST_TO_ADDR
// if not tmp then
15559: LD_VAR 0 1
15563: NOT
15564: IFFALSE 15568
// exit ;
15566: GO 15646
// for i in tmp do
15568: LD_ADDR_VAR 0 2
15572: PUSH
15573: LD_VAR 0 1
15577: PUSH
15578: FOR_IN
15579: IFFALSE 15625
// begin SetTag ( i , 29 ) ;
15581: LD_VAR 0 2
15585: PPUSH
15586: LD_INT 29
15588: PPUSH
15589: CALL_OW 109
// ComExitBuilding ( i ) ;
15593: LD_VAR 0 2
15597: PPUSH
15598: CALL_OW 122
// AddComBuildBehemoth ( i , b_behemoth , 97 , 133 , 0 ) ;
15602: LD_VAR 0 2
15606: PPUSH
15607: LD_INT 37
15609: PPUSH
15610: LD_INT 97
15612: PPUSH
15613: LD_INT 133
15615: PPUSH
15616: LD_INT 0
15618: PPUSH
15619: CALL_OW 230
// end ;
15623: GO 15578
15625: POP
15626: POP
// wait ( 1 1$00 ) ;
15627: LD_INT 2100
15629: PPUSH
15630: CALL_OW 67
// MC_Reset ( mc_rus_1 , 29 ) ;
15634: LD_EXP 7
15638: PPUSH
15639: LD_INT 29
15641: PPUSH
15642: CALL 65596 0 2
// end ;
15646: PPOPN 2
15648: END
// every 7 7$00 trigger GameType = 1 and GetBType ( HexInfo ( 84 , 128 ) ) = b_warehouse and GetSide ( HexInfo ( 84 , 128 ) ) = 3 do var veh , depot ;
15649: LD_EXP 2
15653: PUSH
15654: LD_INT 1
15656: EQUAL
15657: PUSH
15658: LD_INT 84
15660: PPUSH
15661: LD_INT 128
15663: PPUSH
15664: CALL_OW 428
15668: PPUSH
15669: CALL_OW 266
15673: PUSH
15674: LD_INT 1
15676: EQUAL
15677: AND
15678: PUSH
15679: LD_INT 84
15681: PPUSH
15682: LD_INT 128
15684: PPUSH
15685: CALL_OW 428
15689: PPUSH
15690: CALL_OW 255
15694: PUSH
15695: LD_INT 3
15697: EQUAL
15698: AND
15699: IFFALSE 15872
15701: GO 15703
15703: DISABLE
15704: LD_INT 0
15706: PPUSH
15707: PPUSH
// begin enable ;
15708: ENABLE
// depot := HexInfo ( 84 , 128 ) ;
15709: LD_ADDR_VAR 0 2
15713: PUSH
15714: LD_INT 84
15716: PPUSH
15717: LD_INT 128
15719: PPUSH
15720: CALL_OW 428
15724: ST_TO_ADDR
// uc_side := 3 ;
15725: LD_ADDR_OWVAR 20
15729: PUSH
15730: LD_INT 3
15732: ST_TO_ADDR
// uc_nation := 3 ;
15733: LD_ADDR_OWVAR 21
15737: PUSH
15738: LD_INT 3
15740: ST_TO_ADDR
// PrepareVehicle ( ru_medium_wheeled , engine_siberite , control_computer , ru_cargo_bay , 0 ) ;
15741: LD_INT 21
15743: PPUSH
15744: LD_INT 3
15746: PPUSH
15747: LD_INT 3
15749: PPUSH
15750: LD_INT 51
15752: PPUSH
15753: LD_INT 0
15755: PPUSH
15756: CALL 24724 0 5
// veh := CreateVehicle ;
15760: LD_ADDR_VAR 0 1
15764: PUSH
15765: CALL_OW 45
15769: ST_TO_ADDR
// PlaceUnitXY ( veh , 126 , 227 , false ) ;
15770: LD_VAR 0 1
15774: PPUSH
15775: LD_INT 126
15777: PPUSH
15778: LD_INT 227
15780: PPUSH
15781: LD_INT 0
15783: PPUSH
15784: CALL_OW 48
// SetCargo ( veh , mat_oil , 100 ) ;
15788: LD_VAR 0 1
15792: PPUSH
15793: LD_INT 2
15795: PPUSH
15796: LD_INT 100
15798: PPUSH
15799: CALL_OW 290
// ComGive ( veh , depot ) ;
15803: LD_VAR 0 1
15807: PPUSH
15808: LD_VAR 0 2
15812: PPUSH
15813: CALL_OW 161
// AddComMoveXY ( veh , 126 , 227 ) ;
15817: LD_VAR 0 1
15821: PPUSH
15822: LD_INT 126
15824: PPUSH
15825: LD_INT 227
15827: PPUSH
15828: CALL_OW 171
// wait ( 0 0$10 ) ;
15832: LD_INT 350
15834: PPUSH
15835: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
15839: LD_INT 35
15841: PPUSH
15842: CALL_OW 67
// until IsAt ( veh , 126 , 227 ) ;
15846: LD_VAR 0 1
15850: PPUSH
15851: LD_INT 126
15853: PPUSH
15854: LD_INT 227
15856: PPUSH
15857: CALL_OW 307
15861: IFFALSE 15839
// RemoveUnit ( veh ) ;
15863: LD_VAR 0 1
15867: PPUSH
15868: CALL_OW 64
// end ;
15872: PPOPN 2
15874: END
// every 9 9$00 trigger GameType = 1 and outpostEscape and commander = 2 do var veh , depot ;
15875: LD_EXP 2
15879: PUSH
15880: LD_INT 1
15882: EQUAL
15883: PUSH
15884: LD_EXP 27
15888: AND
15889: PUSH
15890: LD_EXP 25
15894: PUSH
15895: LD_INT 2
15897: EQUAL
15898: AND
15899: IFFALSE 16091
15901: GO 15903
15903: DISABLE
15904: LD_INT 0
15906: PPUSH
15907: PPUSH
// begin enable ;
15908: ENABLE
// if tick >= [ 50 50$00 , 40 40$00 , 30 30$00 ] [ Difficulty ] then
15909: LD_OWVAR 1
15913: PUSH
15914: LD_INT 105000
15916: PUSH
15917: LD_INT 84000
15919: PUSH
15920: LD_INT 63000
15922: PUSH
15923: EMPTY
15924: LIST
15925: LIST
15926: LIST
15927: PUSH
15928: LD_OWVAR 67
15932: ARRAY
15933: GREATEREQUAL
15934: IFFALSE 15937
// disable ;
15936: DISABLE
// uc_side := 4 ;
15937: LD_ADDR_OWVAR 20
15941: PUSH
15942: LD_INT 4
15944: ST_TO_ADDR
// uc_nation := 1 ;
15945: LD_ADDR_OWVAR 21
15949: PUSH
15950: LD_INT 1
15952: ST_TO_ADDR
// PrepareVehicle ( us_medium_wheeled , engine_siberite , control_computer , us_cargo_bay , 0 ) ;
15953: LD_INT 2
15955: PPUSH
15956: LD_INT 3
15958: PPUSH
15959: LD_INT 3
15961: PPUSH
15962: LD_INT 12
15964: PPUSH
15965: LD_INT 0
15967: PPUSH
15968: CALL 24724 0 5
// veh := CreateVehicle ;
15972: LD_ADDR_VAR 0 1
15976: PUSH
15977: CALL_OW 45
15981: ST_TO_ADDR
// PlaceUnitXY ( veh , 229 , 226 , false ) ;
15982: LD_VAR 0 1
15986: PPUSH
15987: LD_INT 229
15989: PPUSH
15990: LD_INT 226
15992: PPUSH
15993: LD_INT 0
15995: PPUSH
15996: CALL_OW 48
// SetCargo ( veh , mat_cans , 100 ) ;
16000: LD_VAR 0 1
16004: PPUSH
16005: LD_INT 1
16007: PPUSH
16008: LD_INT 100
16010: PPUSH
16011: CALL_OW 290
// AddComMoveToArea ( veh , ruOutpostArea ) ;
16015: LD_VAR 0 1
16019: PPUSH
16020: LD_INT 25
16022: PPUSH
16023: CALL_OW 173
// AddComUnload ( veh ) ;
16027: LD_VAR 0 1
16031: PPUSH
16032: CALL_OW 219
// AddComMoveXY ( veh , 229 , 226 ) ;
16036: LD_VAR 0 1
16040: PPUSH
16041: LD_INT 229
16043: PPUSH
16044: LD_INT 226
16046: PPUSH
16047: CALL_OW 171
// wait ( 0 0$10 ) ;
16051: LD_INT 350
16053: PPUSH
16054: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
16058: LD_INT 35
16060: PPUSH
16061: CALL_OW 67
// until IsAt ( veh , 229 , 226 ) ;
16065: LD_VAR 0 1
16069: PPUSH
16070: LD_INT 229
16072: PPUSH
16073: LD_INT 226
16075: PPUSH
16076: CALL_OW 307
16080: IFFALSE 16058
// RemoveUnit ( veh ) ;
16082: LD_VAR 0 1
16086: PPUSH
16087: CALL_OW 64
// end ;
16091: PPOPN 2
16093: END
// every 15 15$00 trigger GameType = 1 and game and reinforceAllowed do var i , j , veh , tmp , amount ;
16094: LD_EXP 2
16098: PUSH
16099: LD_INT 1
16101: EQUAL
16102: PUSH
16103: LD_EXP 3
16107: AND
16108: PUSH
16109: LD_EXP 24
16113: AND
16114: IFFALSE 16447
16116: GO 16118
16118: DISABLE
16119: LD_INT 0
16121: PPUSH
16122: PPUSH
16123: PPUSH
16124: PPUSH
16125: PPUSH
// begin enable ;
16126: ENABLE
// tmp := [ ] ;
16127: LD_ADDR_VAR 0 4
16131: PUSH
16132: EMPTY
16133: ST_TO_ADDR
// if commander = 1 then
16134: LD_EXP 25
16138: PUSH
16139: LD_INT 1
16141: EQUAL
16142: IFFALSE 16154
// amount := 3 else
16144: LD_ADDR_VAR 0 5
16148: PUSH
16149: LD_INT 3
16151: ST_TO_ADDR
16152: GO 16162
// amount := 2 ;
16154: LD_ADDR_VAR 0 5
16158: PUSH
16159: LD_INT 2
16161: ST_TO_ADDR
// for i = 1 to amount do
16162: LD_ADDR_VAR 0 1
16166: PUSH
16167: DOUBLE
16168: LD_INT 1
16170: DEC
16171: ST_TO_ADDR
16172: LD_VAR 0 5
16176: PUSH
16177: FOR_TO
16178: IFFALSE 16342
// begin wait ( 0 0$5 ) ;
16180: LD_INT 175
16182: PPUSH
16183: CALL_OW 67
// for j = 1 to 3 do
16187: LD_ADDR_VAR 0 2
16191: PUSH
16192: DOUBLE
16193: LD_INT 1
16195: DEC
16196: ST_TO_ADDR
16197: LD_INT 3
16199: PUSH
16200: FOR_TO
16201: IFFALSE 16338
// begin uc_side := 4 ;
16203: LD_ADDR_OWVAR 20
16207: PUSH
16208: LD_INT 4
16210: ST_TO_ADDR
// uc_nation := 1 ;
16211: LD_ADDR_OWVAR 21
16215: PUSH
16216: LD_INT 1
16218: ST_TO_ADDR
// PrepareVehicle ( [ us_medium_tracked , us_morphling ] [ rand ( 1 , 2 ) ] , engine_siberite , control_computer , [ us_laser , us_double_gun , us_rocket_launcher ] [ rand ( 1 , 3 ) ] , 100 ) ;
16219: LD_INT 3
16221: PUSH
16222: LD_INT 5
16224: PUSH
16225: EMPTY
16226: LIST
16227: LIST
16228: PUSH
16229: LD_INT 1
16231: PPUSH
16232: LD_INT 2
16234: PPUSH
16235: CALL_OW 12
16239: ARRAY
16240: PPUSH
16241: LD_INT 3
16243: PPUSH
16244: LD_INT 3
16246: PPUSH
16247: LD_INT 9
16249: PUSH
16250: LD_INT 5
16252: PUSH
16253: LD_INT 7
16255: PUSH
16256: EMPTY
16257: LIST
16258: LIST
16259: LIST
16260: PUSH
16261: LD_INT 1
16263: PPUSH
16264: LD_INT 3
16266: PPUSH
16267: CALL_OW 12
16271: ARRAY
16272: PPUSH
16273: LD_INT 100
16275: PPUSH
16276: CALL 24724 0 5
// veh := CreateVehicle ;
16280: LD_ADDR_VAR 0 3
16284: PUSH
16285: CALL_OW 45
16289: ST_TO_ADDR
// tmp := tmp ^ veh ;
16290: LD_ADDR_VAR 0 4
16294: PUSH
16295: LD_VAR 0 4
16299: PUSH
16300: LD_VAR 0 3
16304: ADD
16305: ST_TO_ADDR
// PlaceUnitArea ( veh , westSpawn , false ) ;
16306: LD_VAR 0 3
16310: PPUSH
16311: LD_INT 22
16313: PPUSH
16314: LD_INT 0
16316: PPUSH
16317: CALL_OW 49
// ComMoveXY ( veh , 119 , 215 ) ;
16321: LD_VAR 0 3
16325: PPUSH
16326: LD_INT 119
16328: PPUSH
16329: LD_INT 215
16331: PPUSH
16332: CALL_OW 111
// end ;
16336: GO 16200
16338: POP
16339: POP
// end ;
16340: GO 16177
16342: POP
16343: POP
// wait ( 0 0$3 ) ;
16344: LD_INT 105
16346: PPUSH
16347: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
16351: LD_INT 35
16353: PPUSH
16354: CALL_OW 67
// for i in tmp do
16358: LD_ADDR_VAR 0 1
16362: PUSH
16363: LD_VAR 0 4
16367: PUSH
16368: FOR_IN
16369: IFFALSE 16436
// if IsDead ( i ) then
16371: LD_VAR 0 1
16375: PPUSH
16376: CALL_OW 301
16380: IFFALSE 16400
// tmp := tmp diff i else
16382: LD_ADDR_VAR 0 4
16386: PUSH
16387: LD_VAR 0 4
16391: PUSH
16392: LD_VAR 0 1
16396: DIFF
16397: ST_TO_ADDR
16398: GO 16434
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 4 ] ) , i ) ) ;
16400: LD_VAR 0 1
16404: PPUSH
16405: LD_INT 81
16407: PUSH
16408: LD_INT 4
16410: PUSH
16411: EMPTY
16412: LIST
16413: LIST
16414: PPUSH
16415: CALL_OW 69
16419: PPUSH
16420: LD_VAR 0 1
16424: PPUSH
16425: CALL_OW 74
16429: PPUSH
16430: CALL_OW 115
16434: GO 16368
16436: POP
16437: POP
// until tmp = [ ] ;
16438: LD_VAR 0 4
16442: PUSH
16443: EMPTY
16444: EQUAL
16445: IFFALSE 16351
// end ;
16447: PPOPN 5
16449: END
// every 0 0$1 trigger GameType = 1 and game do var i , tmp ;
16450: LD_EXP 2
16454: PUSH
16455: LD_INT 1
16457: EQUAL
16458: PUSH
16459: LD_EXP 3
16463: AND
16464: IFFALSE 16565
16466: GO 16468
16468: DISABLE
16469: LD_INT 0
16471: PPUSH
16472: PPUSH
// begin enable ;
16473: ENABLE
// tmp := FilterAllUnits ( [ [ f_not , [ f_side , 1 ] ] , [ f_engine , engine_combustion ] ] ) ;
16474: LD_ADDR_VAR 0 2
16478: PUSH
16479: LD_INT 3
16481: PUSH
16482: LD_INT 22
16484: PUSH
16485: LD_INT 1
16487: PUSH
16488: EMPTY
16489: LIST
16490: LIST
16491: PUSH
16492: EMPTY
16493: LIST
16494: LIST
16495: PUSH
16496: LD_INT 32
16498: PUSH
16499: LD_INT 1
16501: PUSH
16502: EMPTY
16503: LIST
16504: LIST
16505: PUSH
16506: EMPTY
16507: LIST
16508: LIST
16509: PPUSH
16510: CALL_OW 69
16514: ST_TO_ADDR
// if tmp then
16515: LD_VAR 0 2
16519: IFFALSE 16565
// for i in tmp do
16521: LD_ADDR_VAR 0 1
16525: PUSH
16526: LD_VAR 0 2
16530: PUSH
16531: FOR_IN
16532: IFFALSE 16563
// if GetFuel ( i ) < 3 then
16534: LD_VAR 0 1
16538: PPUSH
16539: CALL_OW 261
16543: PUSH
16544: LD_INT 3
16546: LESS
16547: IFFALSE 16561
// SetFuel ( i , 3 ) ;
16549: LD_VAR 0 1
16553: PPUSH
16554: LD_INT 3
16556: PPUSH
16557: CALL_OW 240
16561: GO 16531
16563: POP
16564: POP
// end ;
16565: PPOPN 2
16567: END
// every 15 15$00 trigger game and GetAttitude ( 8 , 4 ) = att_enemy do var i , un , tmp ;
16568: LD_EXP 3
16572: PUSH
16573: LD_INT 8
16575: PPUSH
16576: LD_INT 4
16578: PPUSH
16579: CALL_OW 81
16583: PUSH
16584: LD_INT 2
16586: EQUAL
16587: AND
16588: IFFALSE 16798
16590: GO 16592
16592: DISABLE
16593: LD_INT 0
16595: PPUSH
16596: PPUSH
16597: PPUSH
// begin enable ;
16598: ENABLE
// tmp := [ ] ;
16599: LD_ADDR_VAR 0 3
16603: PUSH
16604: EMPTY
16605: ST_TO_ADDR
// for i = 1 to 4 do
16606: LD_ADDR_VAR 0 1
16610: PUSH
16611: DOUBLE
16612: LD_INT 1
16614: DEC
16615: ST_TO_ADDR
16616: LD_INT 4
16618: PUSH
16619: FOR_TO
16620: IFFALSE 16764
// begin uc_side := 8 ;
16622: LD_ADDR_OWVAR 20
16626: PUSH
16627: LD_INT 8
16629: ST_TO_ADDR
// uc_nation := nation_arabian ;
16630: LD_ADDR_OWVAR 21
16634: PUSH
16635: LD_INT 2
16637: ST_TO_ADDR
// PrepareVehicle ( ar_hovercraft , engine_combustion , control_apeman , [ ar_double_machine_gun , ar_light_gun ] [ rand ( 1 , 2 ) ] , rand ( 60 , 80 ) ) ;
16638: LD_INT 11
16640: PPUSH
16641: LD_INT 1
16643: PPUSH
16644: LD_INT 5
16646: PPUSH
16647: LD_INT 24
16649: PUSH
16650: LD_INT 23
16652: PUSH
16653: EMPTY
16654: LIST
16655: LIST
16656: PUSH
16657: LD_INT 1
16659: PPUSH
16660: LD_INT 2
16662: PPUSH
16663: CALL_OW 12
16667: ARRAY
16668: PPUSH
16669: LD_INT 60
16671: PPUSH
16672: LD_INT 80
16674: PPUSH
16675: CALL_OW 12
16679: PPUSH
16680: CALL 24724 0 5
// un := CreateVehicle ;
16684: LD_ADDR_VAR 0 2
16688: PUSH
16689: CALL_OW 45
16693: ST_TO_ADDR
// SetDir ( un , 2 ) ;
16694: LD_VAR 0 2
16698: PPUSH
16699: LD_INT 2
16701: PPUSH
16702: CALL_OW 233
// tmp := tmp ^ un ;
16706: LD_ADDR_VAR 0 3
16710: PUSH
16711: LD_VAR 0 3
16715: PUSH
16716: LD_VAR 0 2
16720: ADD
16721: ST_TO_ADDR
// PlaceUnitXY ( un , 88 , 2 , false ) ;
16722: LD_VAR 0 2
16726: PPUSH
16727: LD_INT 88
16729: PPUSH
16730: LD_INT 2
16732: PPUSH
16733: LD_INT 0
16735: PPUSH
16736: CALL_OW 48
// ComMoveXY ( un , 93 , 13 ) ;
16740: LD_VAR 0 2
16744: PPUSH
16745: LD_INT 93
16747: PPUSH
16748: LD_INT 13
16750: PPUSH
16751: CALL_OW 111
// wait ( 0 0$2 ) ;
16755: LD_INT 70
16757: PPUSH
16758: CALL_OW 67
// end ;
16762: GO 16619
16764: POP
16765: POP
// for i in tmp do
16766: LD_ADDR_VAR 0 1
16770: PUSH
16771: LD_VAR 0 3
16775: PUSH
16776: FOR_IN
16777: IFFALSE 16796
// AddComMoveXY ( i , 136 , 19 ) ;
16779: LD_VAR 0 1
16783: PPUSH
16784: LD_INT 136
16786: PPUSH
16787: LD_INT 19
16789: PPUSH
16790: CALL_OW 171
16794: GO 16776
16796: POP
16797: POP
// end ;
16798: PPOPN 3
16800: END
// every 7 7$30 + 7 7$30 trigger game do var i , base , tmp , target ;
16801: LD_EXP 3
16805: IFFALSE 17724
16807: GO 16809
16809: DISABLE
16810: LD_INT 0
16812: PPUSH
16813: PPUSH
16814: PPUSH
16815: PPUSH
// begin enable ;
16816: ENABLE
// base := mc_leg ;
16817: LD_ADDR_VAR 0 2
16821: PUSH
16822: LD_EXP 6
16826: ST_TO_ADDR
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) then
16827: LD_INT 22
16829: PUSH
16830: LD_INT 8
16832: PUSH
16833: EMPTY
16834: LIST
16835: LIST
16836: PUSH
16837: LD_INT 23
16839: PUSH
16840: LD_INT 2
16842: PUSH
16843: EMPTY
16844: LIST
16845: LIST
16846: PUSH
16847: LD_INT 30
16849: PUSH
16850: LD_INT 3
16852: PUSH
16853: EMPTY
16854: LIST
16855: LIST
16856: PUSH
16857: EMPTY
16858: LIST
16859: LIST
16860: LIST
16861: PPUSH
16862: CALL_OW 69
16866: NOT
16867: IFFALSE 16871
// exit ;
16869: GO 17724
// if Prob ( 40 ) then
16871: LD_INT 40
16873: PPUSH
16874: CALL_OW 13
16878: IFFALSE 17007
// begin MC_InsertProduceList ( base , [ [ ar_medium_trike , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
16880: LD_VAR 0 2
16884: PPUSH
16885: LD_INT 13
16887: PUSH
16888: LD_INT 1
16890: PUSH
16891: LD_INT 2
16893: PUSH
16894: LD_INT 28
16896: PUSH
16897: EMPTY
16898: LIST
16899: LIST
16900: LIST
16901: LIST
16902: PUSH
16903: LD_INT 13
16905: PUSH
16906: LD_INT 1
16908: PUSH
16909: LD_INT 2
16911: PUSH
16912: LD_INT 28
16914: PUSH
16915: EMPTY
16916: LIST
16917: LIST
16918: LIST
16919: LIST
16920: PUSH
16921: LD_INT 13
16923: PUSH
16924: LD_INT 1
16926: PUSH
16927: LD_INT 2
16929: PUSH
16930: LD_INT 28
16932: PUSH
16933: EMPTY
16934: LIST
16935: LIST
16936: LIST
16937: LIST
16938: PUSH
16939: LD_INT 13
16941: PUSH
16942: LD_INT 1
16944: PUSH
16945: LD_INT 2
16947: PUSH
16948: LD_INT 28
16950: PUSH
16951: EMPTY
16952: LIST
16953: LIST
16954: LIST
16955: LIST
16956: PUSH
16957: LD_INT 13
16959: PUSH
16960: LD_INT 1
16962: PUSH
16963: LD_INT 2
16965: PUSH
16966: LD_INT 28
16968: PUSH
16969: EMPTY
16970: LIST
16971: LIST
16972: LIST
16973: LIST
16974: PUSH
16975: LD_INT 13
16977: PUSH
16978: LD_INT 1
16980: PUSH
16981: LD_INT 2
16983: PUSH
16984: LD_INT 26
16986: PUSH
16987: EMPTY
16988: LIST
16989: LIST
16990: LIST
16991: LIST
16992: PUSH
16993: EMPTY
16994: LIST
16995: LIST
16996: LIST
16997: LIST
16998: LIST
16999: LIST
17000: PPUSH
17001: CALL 85709 0 2
// end else
17005: GO 17224
// begin MC_InsertProduceList ( base , [ [ ar_medium_trike , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower ] [ rand ( 1 , 3 ) ] ] , [ ar_medium_trike , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower ] [ rand ( 1 , 3 ) ] ] , [ ar_medium_trike , engine_combustion , control_remote , [ ar_flame_thrower , ar_flame_thrower , ar_selfpropelled_bomb ] [ rand ( 1 , 3 ) ] ] , [ ar_medium_trike , engine_combustion , control_remote , [ ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ rand ( 1 , 3 ) ] ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_medium_trike , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
17007: LD_VAR 0 2
17011: PPUSH
17012: LD_INT 13
17014: PUSH
17015: LD_INT 1
17017: PUSH
17018: LD_INT 2
17020: PUSH
17021: LD_INT 27
17023: PUSH
17024: LD_INT 26
17026: PUSH
17027: LD_INT 26
17029: PUSH
17030: EMPTY
17031: LIST
17032: LIST
17033: LIST
17034: PUSH
17035: LD_INT 1
17037: PPUSH
17038: LD_INT 3
17040: PPUSH
17041: CALL_OW 12
17045: ARRAY
17046: PUSH
17047: EMPTY
17048: LIST
17049: LIST
17050: LIST
17051: LIST
17052: PUSH
17053: LD_INT 13
17055: PUSH
17056: LD_INT 1
17058: PUSH
17059: LD_INT 2
17061: PUSH
17062: LD_INT 27
17064: PUSH
17065: LD_INT 26
17067: PUSH
17068: LD_INT 26
17070: PUSH
17071: EMPTY
17072: LIST
17073: LIST
17074: LIST
17075: PUSH
17076: LD_INT 1
17078: PPUSH
17079: LD_INT 3
17081: PPUSH
17082: CALL_OW 12
17086: ARRAY
17087: PUSH
17088: EMPTY
17089: LIST
17090: LIST
17091: LIST
17092: LIST
17093: PUSH
17094: LD_INT 13
17096: PUSH
17097: LD_INT 1
17099: PUSH
17100: LD_INT 2
17102: PUSH
17103: LD_INT 26
17105: PUSH
17106: LD_INT 26
17108: PUSH
17109: LD_INT 29
17111: PUSH
17112: EMPTY
17113: LIST
17114: LIST
17115: LIST
17116: PUSH
17117: LD_INT 1
17119: PPUSH
17120: LD_INT 3
17122: PPUSH
17123: CALL_OW 12
17127: ARRAY
17128: PUSH
17129: EMPTY
17130: LIST
17131: LIST
17132: LIST
17133: LIST
17134: PUSH
17135: LD_INT 13
17137: PUSH
17138: LD_INT 1
17140: PUSH
17141: LD_INT 2
17143: PUSH
17144: LD_INT 26
17146: PUSH
17147: LD_INT 29
17149: PUSH
17150: LD_INT 29
17152: PUSH
17153: EMPTY
17154: LIST
17155: LIST
17156: LIST
17157: PUSH
17158: LD_INT 1
17160: PPUSH
17161: LD_INT 3
17163: PPUSH
17164: CALL_OW 12
17168: ARRAY
17169: PUSH
17170: EMPTY
17171: LIST
17172: LIST
17173: LIST
17174: LIST
17175: PUSH
17176: LD_INT 13
17178: PUSH
17179: LD_INT 1
17181: PUSH
17182: LD_INT 2
17184: PUSH
17185: LD_INT 29
17187: PUSH
17188: EMPTY
17189: LIST
17190: LIST
17191: LIST
17192: LIST
17193: PUSH
17194: LD_INT 13
17196: PUSH
17197: LD_INT 1
17199: PUSH
17200: LD_INT 2
17202: PUSH
17203: LD_INT 26
17205: PUSH
17206: EMPTY
17207: LIST
17208: LIST
17209: LIST
17210: LIST
17211: PUSH
17212: EMPTY
17213: LIST
17214: LIST
17215: LIST
17216: LIST
17217: LIST
17218: LIST
17219: PPUSH
17220: CALL 85709 0 2
// end ; repeat wait ( 0 0$1 ) ;
17224: LD_INT 35
17226: PPUSH
17227: CALL_OW 67
// until MC_GetVehicles ( base , true ) >= 6 or tick mod 10 10$00 = 0 ;
17231: LD_VAR 0 2
17235: PPUSH
17236: LD_INT 1
17238: PPUSH
17239: CALL 87127 0 2
17243: PUSH
17244: LD_INT 6
17246: GREATEREQUAL
17247: PUSH
17248: LD_OWVAR 1
17252: PUSH
17253: LD_INT 21000
17255: MOD
17256: PUSH
17257: LD_INT 0
17259: EQUAL
17260: OR
17261: IFFALSE 17224
// wait ( 0 0$30 ) ;
17263: LD_INT 1050
17265: PPUSH
17266: CALL_OW 67
// tmp := MC_GetVehicles ( base , true ) ;
17270: LD_ADDR_VAR 0 3
17274: PUSH
17275: LD_VAR 0 2
17279: PPUSH
17280: LD_INT 1
17282: PPUSH
17283: CALL 87127 0 2
17287: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , mc_vehicles [ base ] diff tmp ) ;
17288: LD_ADDR_EXP 50
17292: PUSH
17293: LD_EXP 50
17297: PPUSH
17298: LD_VAR 0 2
17302: PPUSH
17303: LD_EXP 50
17307: PUSH
17308: LD_VAR 0 2
17312: ARRAY
17313: PUSH
17314: LD_VAR 0 3
17318: DIFF
17319: PPUSH
17320: CALL_OW 1
17324: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
17325: LD_ADDR_VAR 0 4
17329: PUSH
17330: LD_INT 0
17332: PPUSH
17333: LD_INT 2
17335: PPUSH
17336: CALL_OW 12
17340: ST_TO_ADDR
// if legChangeSide then
17341: LD_EXP 21
17345: IFFALSE 17355
// target := 2 ;
17347: LD_ADDR_VAR 0 4
17351: PUSH
17352: LD_INT 2
17354: ST_TO_ADDR
// if target = 2 then
17355: LD_VAR 0 4
17359: PUSH
17360: LD_INT 2
17362: EQUAL
17363: IFFALSE 17491
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
17365: LD_ADDR_VAR 0 3
17369: PUSH
17370: LD_VAR 0 3
17374: PPUSH
17375: LD_INT 24
17377: PUSH
17378: LD_INT 250
17380: PUSH
17381: EMPTY
17382: LIST
17383: LIST
17384: PPUSH
17385: CALL_OW 72
17389: ST_TO_ADDR
// for i in tmp do
17390: LD_ADDR_VAR 0 1
17394: PUSH
17395: LD_VAR 0 3
17399: PUSH
17400: FOR_IN
17401: IFFALSE 17441
// if GetDistUnitXY ( i , 112 , 64 ) > 9 then
17403: LD_VAR 0 1
17407: PPUSH
17408: LD_INT 112
17410: PPUSH
17411: LD_INT 64
17413: PPUSH
17414: CALL_OW 297
17418: PUSH
17419: LD_INT 9
17421: GREATER
17422: IFFALSE 17439
// ComMoveXY ( i , 112 , 64 ) ;
17424: LD_VAR 0 1
17428: PPUSH
17429: LD_INT 112
17431: PPUSH
17432: LD_INT 64
17434: PPUSH
17435: CALL_OW 111
17439: GO 17400
17441: POP
17442: POP
// wait ( 0 0$1 ) ;
17443: LD_INT 35
17445: PPUSH
17446: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 112 , 64 , 9 ] ) >= ( tmp - 1 ) ;
17450: LD_VAR 0 3
17454: PPUSH
17455: LD_INT 92
17457: PUSH
17458: LD_INT 112
17460: PUSH
17461: LD_INT 64
17463: PUSH
17464: LD_INT 9
17466: PUSH
17467: EMPTY
17468: LIST
17469: LIST
17470: LIST
17471: LIST
17472: PPUSH
17473: CALL_OW 72
17477: PUSH
17478: LD_VAR 0 3
17482: PUSH
17483: LD_INT 1
17485: MINUS
17486: GREATEREQUAL
17487: IFFALSE 17365
// end else
17489: GO 17615
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
17491: LD_ADDR_VAR 0 3
17495: PUSH
17496: LD_VAR 0 3
17500: PPUSH
17501: LD_INT 24
17503: PUSH
17504: LD_INT 250
17506: PUSH
17507: EMPTY
17508: LIST
17509: LIST
17510: PPUSH
17511: CALL_OW 72
17515: ST_TO_ADDR
// for i in tmp do
17516: LD_ADDR_VAR 0 1
17520: PUSH
17521: LD_VAR 0 3
17525: PUSH
17526: FOR_IN
17527: IFFALSE 17567
// if GetDistUnitXY ( i , 174 , 94 ) > 9 then
17529: LD_VAR 0 1
17533: PPUSH
17534: LD_INT 174
17536: PPUSH
17537: LD_INT 94
17539: PPUSH
17540: CALL_OW 297
17544: PUSH
17545: LD_INT 9
17547: GREATER
17548: IFFALSE 17565
// ComMoveXY ( i , 174 , 94 ) ;
17550: LD_VAR 0 1
17554: PPUSH
17555: LD_INT 174
17557: PPUSH
17558: LD_INT 94
17560: PPUSH
17561: CALL_OW 111
17565: GO 17526
17567: POP
17568: POP
// wait ( 0 0$1 ) ;
17569: LD_INT 35
17571: PPUSH
17572: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 174 , 94 , 9 ] ) >= ( tmp - 1 ) ;
17576: LD_VAR 0 3
17580: PPUSH
17581: LD_INT 92
17583: PUSH
17584: LD_INT 174
17586: PUSH
17587: LD_INT 94
17589: PUSH
17590: LD_INT 9
17592: PUSH
17593: EMPTY
17594: LIST
17595: LIST
17596: LIST
17597: LIST
17598: PPUSH
17599: CALL_OW 72
17603: PUSH
17604: LD_VAR 0 3
17608: PUSH
17609: LD_INT 1
17611: MINUS
17612: GREATEREQUAL
17613: IFFALSE 17491
// end ; repeat wait ( 0 0$1 ) ;
17615: LD_INT 35
17617: PPUSH
17618: CALL_OW 67
// for i in tmp do
17622: LD_ADDR_VAR 0 1
17626: PUSH
17627: LD_VAR 0 3
17631: PUSH
17632: FOR_IN
17633: IFFALSE 17715
// begin if GetLives ( i ) > 251 then
17635: LD_VAR 0 1
17639: PPUSH
17640: CALL_OW 256
17644: PUSH
17645: LD_INT 251
17647: GREATER
17648: IFFALSE 17686
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) else
17650: LD_VAR 0 1
17654: PPUSH
17655: LD_INT 81
17657: PUSH
17658: LD_INT 8
17660: PUSH
17661: EMPTY
17662: LIST
17663: LIST
17664: PPUSH
17665: CALL_OW 69
17669: PPUSH
17670: LD_VAR 0 1
17674: PPUSH
17675: CALL_OW 74
17679: PPUSH
17680: CALL_OW 115
17684: GO 17713
// if IsDead ( i ) then
17686: LD_VAR 0 1
17690: PPUSH
17691: CALL_OW 301
17695: IFFALSE 17713
// tmp := tmp diff i ;
17697: LD_ADDR_VAR 0 3
17701: PUSH
17702: LD_VAR 0 3
17706: PUSH
17707: LD_VAR 0 1
17711: DIFF
17712: ST_TO_ADDR
// end ;
17713: GO 17632
17715: POP
17716: POP
// until not tmp ;
17717: LD_VAR 0 3
17721: NOT
17722: IFFALSE 17615
// end ;
17724: PPOPN 4
17726: END
// every 7 7$30 trigger game do var i , base , tmp , target , teleport ;
17727: LD_EXP 3
17731: IFFALSE 18719
17733: GO 17735
17735: DISABLE
17736: LD_INT 0
17738: PPUSH
17739: PPUSH
17740: PPUSH
17741: PPUSH
17742: PPUSH
// begin enable ;
17743: ENABLE
// if not UnitFilter ( mc_bases [ mc_rus_2 ] , [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) then
17744: LD_EXP 31
17748: PUSH
17749: LD_EXP 8
17753: ARRAY
17754: PPUSH
17755: LD_INT 22
17757: PUSH
17758: LD_INT 3
17760: PUSH
17761: EMPTY
17762: LIST
17763: LIST
17764: PUSH
17765: LD_INT 30
17767: PUSH
17768: LD_INT 3
17770: PUSH
17771: EMPTY
17772: LIST
17773: LIST
17774: PUSH
17775: EMPTY
17776: LIST
17777: LIST
17778: PPUSH
17779: CALL_OW 72
17783: NOT
17784: IFFALSE 17788
// exit ;
17786: GO 18719
// base := mc_rus_2 ;
17788: LD_ADDR_VAR 0 2
17792: PUSH
17793: LD_EXP 8
17797: ST_TO_ADDR
// teleport := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) ;
17798: LD_ADDR_VAR 0 5
17802: PUSH
17803: LD_INT 22
17805: PUSH
17806: LD_INT 3
17808: PUSH
17809: EMPTY
17810: LIST
17811: LIST
17812: PUSH
17813: LD_INT 30
17815: PUSH
17816: LD_INT 34
17818: PUSH
17819: EMPTY
17820: LIST
17821: LIST
17822: PUSH
17823: EMPTY
17824: LIST
17825: LIST
17826: PPUSH
17827: CALL_OW 69
17831: ST_TO_ADDR
// if Prob ( 40 ) then
17832: LD_INT 40
17834: PPUSH
17835: CALL_OW 13
17839: IFFALSE 17968
// begin MC_InsertProduceList ( base , [ [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
17841: LD_VAR 0 2
17845: PPUSH
17846: LD_INT 22
17848: PUSH
17849: LD_INT 3
17851: PUSH
17852: LD_INT 3
17854: PUSH
17855: LD_INT 49
17857: PUSH
17858: EMPTY
17859: LIST
17860: LIST
17861: LIST
17862: LIST
17863: PUSH
17864: LD_INT 22
17866: PUSH
17867: LD_INT 3
17869: PUSH
17870: LD_INT 3
17872: PUSH
17873: LD_INT 49
17875: PUSH
17876: EMPTY
17877: LIST
17878: LIST
17879: LIST
17880: LIST
17881: PUSH
17882: LD_INT 22
17884: PUSH
17885: LD_INT 3
17887: PUSH
17888: LD_INT 3
17890: PUSH
17891: LD_INT 49
17893: PUSH
17894: EMPTY
17895: LIST
17896: LIST
17897: LIST
17898: LIST
17899: PUSH
17900: LD_INT 24
17902: PUSH
17903: LD_INT 3
17905: PUSH
17906: LD_INT 3
17908: PUSH
17909: LD_INT 46
17911: PUSH
17912: EMPTY
17913: LIST
17914: LIST
17915: LIST
17916: LIST
17917: PUSH
17918: LD_INT 24
17920: PUSH
17921: LD_INT 3
17923: PUSH
17924: LD_INT 3
17926: PUSH
17927: LD_INT 46
17929: PUSH
17930: EMPTY
17931: LIST
17932: LIST
17933: LIST
17934: LIST
17935: PUSH
17936: LD_INT 24
17938: PUSH
17939: LD_INT 3
17941: PUSH
17942: LD_INT 3
17944: PUSH
17945: LD_INT 46
17947: PUSH
17948: EMPTY
17949: LIST
17950: LIST
17951: LIST
17952: LIST
17953: PUSH
17954: EMPTY
17955: LIST
17956: LIST
17957: LIST
17958: LIST
17959: LIST
17960: LIST
17961: PPUSH
17962: CALL 85709 0 2
// end else
17966: GO 18093
// begin MC_InsertProduceList ( base , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
17968: LD_VAR 0 2
17972: PPUSH
17973: LD_INT 24
17975: PUSH
17976: LD_INT 3
17978: PUSH
17979: LD_INT 3
17981: PUSH
17982: LD_INT 47
17984: PUSH
17985: EMPTY
17986: LIST
17987: LIST
17988: LIST
17989: LIST
17990: PUSH
17991: LD_INT 24
17993: PUSH
17994: LD_INT 3
17996: PUSH
17997: LD_INT 3
17999: PUSH
18000: LD_INT 47
18002: PUSH
18003: EMPTY
18004: LIST
18005: LIST
18006: LIST
18007: LIST
18008: PUSH
18009: LD_INT 24
18011: PUSH
18012: LD_INT 3
18014: PUSH
18015: LD_INT 3
18017: PUSH
18018: LD_INT 47
18020: PUSH
18021: EMPTY
18022: LIST
18023: LIST
18024: LIST
18025: LIST
18026: PUSH
18027: LD_INT 24
18029: PUSH
18030: LD_INT 3
18032: PUSH
18033: LD_INT 3
18035: PUSH
18036: LD_INT 46
18038: PUSH
18039: EMPTY
18040: LIST
18041: LIST
18042: LIST
18043: LIST
18044: PUSH
18045: LD_INT 24
18047: PUSH
18048: LD_INT 3
18050: PUSH
18051: LD_INT 3
18053: PUSH
18054: LD_INT 46
18056: PUSH
18057: EMPTY
18058: LIST
18059: LIST
18060: LIST
18061: LIST
18062: PUSH
18063: LD_INT 24
18065: PUSH
18066: LD_INT 3
18068: PUSH
18069: LD_INT 3
18071: PUSH
18072: LD_INT 46
18074: PUSH
18075: EMPTY
18076: LIST
18077: LIST
18078: LIST
18079: LIST
18080: PUSH
18081: EMPTY
18082: LIST
18083: LIST
18084: LIST
18085: LIST
18086: LIST
18087: LIST
18088: PPUSH
18089: CALL 85709 0 2
// end ; if Difficulty > 1 then
18093: LD_OWVAR 67
18097: PUSH
18098: LD_INT 1
18100: GREATER
18101: IFFALSE 18133
// MC_InsertProduceList ( base , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
18103: LD_VAR 0 2
18107: PPUSH
18108: LD_INT 24
18110: PUSH
18111: LD_INT 3
18113: PUSH
18114: LD_INT 3
18116: PUSH
18117: LD_INT 47
18119: PUSH
18120: EMPTY
18121: LIST
18122: LIST
18123: LIST
18124: LIST
18125: PUSH
18126: EMPTY
18127: LIST
18128: PPUSH
18129: CALL 85709 0 2
// repeat wait ( 0 0$1 ) ;
18133: LD_INT 35
18135: PPUSH
18136: CALL_OW 67
// until MC_GetVehicles ( base , true ) >= [ 6 , 7 , 7 ] [ Difficulty ] or tick mod 10 10$00 = 0 ;
18140: LD_VAR 0 2
18144: PPUSH
18145: LD_INT 1
18147: PPUSH
18148: CALL 87127 0 2
18152: PUSH
18153: LD_INT 6
18155: PUSH
18156: LD_INT 7
18158: PUSH
18159: LD_INT 7
18161: PUSH
18162: EMPTY
18163: LIST
18164: LIST
18165: LIST
18166: PUSH
18167: LD_OWVAR 67
18171: ARRAY
18172: GREATEREQUAL
18173: PUSH
18174: LD_OWVAR 1
18178: PUSH
18179: LD_INT 21000
18181: MOD
18182: PUSH
18183: LD_INT 0
18185: EQUAL
18186: OR
18187: IFFALSE 18133
// wait ( 0 0$45 ) ;
18189: LD_INT 1575
18191: PPUSH
18192: CALL_OW 67
// tmp := MC_GetVehicles ( base , true ) ;
18196: LD_ADDR_VAR 0 3
18200: PUSH
18201: LD_VAR 0 2
18205: PPUSH
18206: LD_INT 1
18208: PPUSH
18209: CALL 87127 0 2
18213: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , mc_vehicles [ base ] diff tmp ) ;
18214: LD_ADDR_EXP 50
18218: PUSH
18219: LD_EXP 50
18223: PPUSH
18224: LD_VAR 0 2
18228: PPUSH
18229: LD_EXP 50
18233: PUSH
18234: LD_VAR 0 2
18238: ARRAY
18239: PUSH
18240: LD_VAR 0 3
18244: DIFF
18245: PPUSH
18246: CALL_OW 1
18250: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
18251: LD_ADDR_VAR 0 4
18255: PUSH
18256: LD_INT 0
18258: PPUSH
18259: LD_INT 1
18261: PPUSH
18262: CALL_OW 12
18266: ST_TO_ADDR
// if target then
18267: LD_VAR 0 4
18271: IFFALSE 18399
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
18273: LD_ADDR_VAR 0 3
18277: PUSH
18278: LD_VAR 0 3
18282: PPUSH
18283: LD_INT 24
18285: PUSH
18286: LD_INT 250
18288: PUSH
18289: EMPTY
18290: LIST
18291: LIST
18292: PPUSH
18293: CALL_OW 72
18297: ST_TO_ADDR
// for i in tmp do
18298: LD_ADDR_VAR 0 1
18302: PUSH
18303: LD_VAR 0 3
18307: PUSH
18308: FOR_IN
18309: IFFALSE 18349
// if GetDistUnitXY ( i , 84 , 32 ) > 9 then
18311: LD_VAR 0 1
18315: PPUSH
18316: LD_INT 84
18318: PPUSH
18319: LD_INT 32
18321: PPUSH
18322: CALL_OW 297
18326: PUSH
18327: LD_INT 9
18329: GREATER
18330: IFFALSE 18347
// ComMoveXY ( i , 84 , 32 ) ;
18332: LD_VAR 0 1
18336: PPUSH
18337: LD_INT 84
18339: PPUSH
18340: LD_INT 32
18342: PPUSH
18343: CALL_OW 111
18347: GO 18308
18349: POP
18350: POP
// wait ( 0 0$1 ) ;
18351: LD_INT 35
18353: PPUSH
18354: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 84 , 32 , 9 ] ) >= ( tmp - 1 ) ;
18358: LD_VAR 0 3
18362: PPUSH
18363: LD_INT 92
18365: PUSH
18366: LD_INT 84
18368: PUSH
18369: LD_INT 32
18371: PUSH
18372: LD_INT 9
18374: PUSH
18375: EMPTY
18376: LIST
18377: LIST
18378: LIST
18379: LIST
18380: PPUSH
18381: CALL_OW 72
18385: PUSH
18386: LD_VAR 0 3
18390: PUSH
18391: LD_INT 1
18393: MINUS
18394: GREATEREQUAL
18395: IFFALSE 18273
// end else
18397: GO 18559
// begin if teleport then
18399: LD_VAR 0 5
18403: IFFALSE 18423
// ComEnterUnit ( tmp , teleport [ 1 ] ) ;
18405: LD_VAR 0 3
18409: PPUSH
18410: LD_VAR 0 5
18414: PUSH
18415: LD_INT 1
18417: ARRAY
18418: PPUSH
18419: CALL_OW 120
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
18423: LD_ADDR_VAR 0 3
18427: PUSH
18428: LD_VAR 0 3
18432: PPUSH
18433: LD_INT 24
18435: PUSH
18436: LD_INT 250
18438: PUSH
18439: EMPTY
18440: LIST
18441: LIST
18442: PPUSH
18443: CALL_OW 72
18447: ST_TO_ADDR
// for i in tmp do
18448: LD_ADDR_VAR 0 1
18452: PUSH
18453: LD_VAR 0 3
18457: PUSH
18458: FOR_IN
18459: IFFALSE 18511
// if GetDistUnitXY ( i , 140 , 219 ) > 9 and not HasTask ( i ) then
18461: LD_VAR 0 1
18465: PPUSH
18466: LD_INT 140
18468: PPUSH
18469: LD_INT 219
18471: PPUSH
18472: CALL_OW 297
18476: PUSH
18477: LD_INT 9
18479: GREATER
18480: PUSH
18481: LD_VAR 0 1
18485: PPUSH
18486: CALL_OW 314
18490: NOT
18491: AND
18492: IFFALSE 18509
// AddComMoveXY ( i , 140 , 219 ) ;
18494: LD_VAR 0 1
18498: PPUSH
18499: LD_INT 140
18501: PPUSH
18502: LD_INT 219
18504: PPUSH
18505: CALL_OW 171
18509: GO 18458
18511: POP
18512: POP
// wait ( 0 0$1 ) ;
18513: LD_INT 35
18515: PPUSH
18516: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 140 , 219 , 9 ] ) >= ( tmp - 1 ) ;
18520: LD_VAR 0 3
18524: PPUSH
18525: LD_INT 92
18527: PUSH
18528: LD_INT 140
18530: PUSH
18531: LD_INT 219
18533: PUSH
18534: LD_INT 9
18536: PUSH
18537: EMPTY
18538: LIST
18539: LIST
18540: LIST
18541: LIST
18542: PPUSH
18543: CALL_OW 72
18547: PUSH
18548: LD_VAR 0 3
18552: PUSH
18553: LD_INT 1
18555: MINUS
18556: GREATEREQUAL
18557: IFFALSE 18423
// end ; repeat wait ( 0 0$1 ) ;
18559: LD_INT 35
18561: PPUSH
18562: CALL_OW 67
// for i in tmp do
18566: LD_ADDR_VAR 0 1
18570: PUSH
18571: LD_VAR 0 3
18575: PUSH
18576: FOR_IN
18577: IFFALSE 18710
// begin if GetLives ( i ) > 251 then
18579: LD_VAR 0 1
18583: PPUSH
18584: CALL_OW 256
18588: PUSH
18589: LD_INT 251
18591: GREATER
18592: IFFALSE 18681
// begin if GetWeapon ( i ) = ru_time_lapser then
18594: LD_VAR 0 1
18598: PPUSH
18599: CALL_OW 264
18603: PUSH
18604: LD_INT 49
18606: EQUAL
18607: IFFALSE 18645
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) else
18609: LD_VAR 0 1
18613: PPUSH
18614: LD_INT 81
18616: PUSH
18617: LD_INT 3
18619: PUSH
18620: EMPTY
18621: LIST
18622: LIST
18623: PPUSH
18624: CALL_OW 69
18628: PPUSH
18629: LD_VAR 0 1
18633: PPUSH
18634: CALL_OW 74
18638: PPUSH
18639: CALL_OW 112
18643: GO 18679
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
18645: LD_VAR 0 1
18649: PPUSH
18650: LD_INT 81
18652: PUSH
18653: LD_INT 3
18655: PUSH
18656: EMPTY
18657: LIST
18658: LIST
18659: PPUSH
18660: CALL_OW 69
18664: PPUSH
18665: LD_VAR 0 1
18669: PPUSH
18670: CALL_OW 74
18674: PPUSH
18675: CALL_OW 115
// end else
18679: GO 18708
// if IsDead ( i ) then
18681: LD_VAR 0 1
18685: PPUSH
18686: CALL_OW 301
18690: IFFALSE 18708
// tmp := tmp diff i ;
18692: LD_ADDR_VAR 0 3
18696: PUSH
18697: LD_VAR 0 3
18701: PUSH
18702: LD_VAR 0 1
18706: DIFF
18707: ST_TO_ADDR
// end ;
18708: GO 18576
18710: POP
18711: POP
// until not tmp ;
18712: LD_VAR 0 3
18716: NOT
18717: IFFALSE 18559
// end ;
18719: PPOPN 5
18721: END
// every 12 12$30 + 11 11$30 trigger game do var i , base , tmp , target ;
18722: LD_EXP 3
18726: IFFALSE 19108
18728: GO 18730
18730: DISABLE
18731: LD_INT 0
18733: PPUSH
18734: PPUSH
18735: PPUSH
18736: PPUSH
// begin enable ;
18737: ENABLE
// base := mc_amer ;
18738: LD_ADDR_VAR 0 2
18742: PUSH
18743: LD_EXP 5
18747: ST_TO_ADDR
// if not FilterAllUnits ( [ [ f_side , 4 ] , [ f_nation , 1 ] , [ f_btype , b_factory ] ] ) then
18748: LD_INT 22
18750: PUSH
18751: LD_INT 4
18753: PUSH
18754: EMPTY
18755: LIST
18756: LIST
18757: PUSH
18758: LD_INT 23
18760: PUSH
18761: LD_INT 1
18763: PUSH
18764: EMPTY
18765: LIST
18766: LIST
18767: PUSH
18768: LD_INT 30
18770: PUSH
18771: LD_INT 3
18773: PUSH
18774: EMPTY
18775: LIST
18776: LIST
18777: PUSH
18778: EMPTY
18779: LIST
18780: LIST
18781: LIST
18782: PPUSH
18783: CALL_OW 69
18787: NOT
18788: IFFALSE 18792
// exit ;
18790: GO 19108
// MC_InsertProduceList ( base , [ [ us_medium_tracked , engine_combustion , control_remote , us_double_gun ] , [ us_medium_tracked , engine_combustion , control_remote , us_laser ] , [ us_medium_tracked , engine_combustion , control_remote , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_remote , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_remote , us_rocket_launcher ] ] ) ;
18792: LD_VAR 0 2
18796: PPUSH
18797: LD_INT 3
18799: PUSH
18800: LD_INT 1
18802: PUSH
18803: LD_INT 2
18805: PUSH
18806: LD_INT 5
18808: PUSH
18809: EMPTY
18810: LIST
18811: LIST
18812: LIST
18813: LIST
18814: PUSH
18815: LD_INT 3
18817: PUSH
18818: LD_INT 1
18820: PUSH
18821: LD_INT 2
18823: PUSH
18824: LD_INT 9
18826: PUSH
18827: EMPTY
18828: LIST
18829: LIST
18830: LIST
18831: LIST
18832: PUSH
18833: LD_INT 3
18835: PUSH
18836: LD_INT 1
18838: PUSH
18839: LD_INT 2
18841: PUSH
18842: LD_INT 7
18844: PUSH
18845: EMPTY
18846: LIST
18847: LIST
18848: LIST
18849: LIST
18850: PUSH
18851: LD_INT 3
18853: PUSH
18854: LD_INT 1
18856: PUSH
18857: LD_INT 2
18859: PUSH
18860: LD_INT 7
18862: PUSH
18863: EMPTY
18864: LIST
18865: LIST
18866: LIST
18867: LIST
18868: PUSH
18869: LD_INT 3
18871: PUSH
18872: LD_INT 1
18874: PUSH
18875: LD_INT 2
18877: PUSH
18878: LD_INT 7
18880: PUSH
18881: EMPTY
18882: LIST
18883: LIST
18884: LIST
18885: LIST
18886: PUSH
18887: EMPTY
18888: LIST
18889: LIST
18890: LIST
18891: LIST
18892: LIST
18893: PPUSH
18894: CALL 85709 0 2
// repeat wait ( 0 0$1 ) ;
18898: LD_INT 35
18900: PPUSH
18901: CALL_OW 67
// until MC_GetVehicles ( base , true ) >= 5 or tick mod 10 10$00 = 0 ;
18905: LD_VAR 0 2
18909: PPUSH
18910: LD_INT 1
18912: PPUSH
18913: CALL 87127 0 2
18917: PUSH
18918: LD_INT 5
18920: GREATEREQUAL
18921: PUSH
18922: LD_OWVAR 1
18926: PUSH
18927: LD_INT 21000
18929: MOD
18930: PUSH
18931: LD_INT 0
18933: EQUAL
18934: OR
18935: IFFALSE 18898
// wait ( 0 0$30 ) ;
18937: LD_INT 1050
18939: PPUSH
18940: CALL_OW 67
// tmp := MC_GetVehicles ( base , true ) ;
18944: LD_ADDR_VAR 0 3
18948: PUSH
18949: LD_VAR 0 2
18953: PPUSH
18954: LD_INT 1
18956: PPUSH
18957: CALL 87127 0 2
18961: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , mc_vehicles [ base ] diff tmp ) ;
18962: LD_ADDR_EXP 50
18966: PUSH
18967: LD_EXP 50
18971: PPUSH
18972: LD_VAR 0 2
18976: PPUSH
18977: LD_EXP 50
18981: PUSH
18982: LD_VAR 0 2
18986: ARRAY
18987: PUSH
18988: LD_VAR 0 3
18992: DIFF
18993: PPUSH
18994: CALL_OW 1
18998: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
18999: LD_INT 35
19001: PPUSH
19002: CALL_OW 67
// for i in tmp do
19006: LD_ADDR_VAR 0 1
19010: PUSH
19011: LD_VAR 0 3
19015: PUSH
19016: FOR_IN
19017: IFFALSE 19099
// begin if GetLives ( i ) > 251 then
19019: LD_VAR 0 1
19023: PPUSH
19024: CALL_OW 256
19028: PUSH
19029: LD_INT 251
19031: GREATER
19032: IFFALSE 19070
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 4 ] ) , i ) ) else
19034: LD_VAR 0 1
19038: PPUSH
19039: LD_INT 81
19041: PUSH
19042: LD_INT 4
19044: PUSH
19045: EMPTY
19046: LIST
19047: LIST
19048: PPUSH
19049: CALL_OW 69
19053: PPUSH
19054: LD_VAR 0 1
19058: PPUSH
19059: CALL_OW 74
19063: PPUSH
19064: CALL_OW 115
19068: GO 19097
// if IsDead ( i ) then
19070: LD_VAR 0 1
19074: PPUSH
19075: CALL_OW 301
19079: IFFALSE 19097
// tmp := tmp diff i ;
19081: LD_ADDR_VAR 0 3
19085: PUSH
19086: LD_VAR 0 3
19090: PUSH
19091: LD_VAR 0 1
19095: DIFF
19096: ST_TO_ADDR
// end ;
19097: GO 19016
19099: POP
19100: POP
// until not tmp ;
19101: LD_VAR 0 3
19105: NOT
19106: IFFALSE 18999
// end ; end_of_file
19108: PPOPN 4
19110: END
// export function CustomEvent ( event ) ; begin
19111: LD_INT 0
19113: PPUSH
// end ;
19114: LD_VAR 0 2
19118: RET
// on Contact ( s1 , s2 ) do begin if s1 = 1 and s2 = 4 then
19119: LD_VAR 0 1
19123: PUSH
19124: LD_INT 1
19126: EQUAL
19127: PUSH
19128: LD_VAR 0 2
19132: PUSH
19133: LD_INT 4
19135: EQUAL
19136: AND
19137: IFFALSE 19165
// begin SayRadio ( Powell , DP-Lost ) ;
19139: LD_EXP 12
19143: PPUSH
19144: LD_STRING DP-Lost
19146: PPUSH
19147: CALL_OW 94
// wait ( 0 0$2 ) ;
19151: LD_INT 70
19153: PPUSH
19154: CALL_OW 67
// YouLost ( FriendlyFire ) ;
19158: LD_STRING FriendlyFire
19160: PPUSH
19161: CALL_OW 104
// end ; end ;
19165: PPOPN 2
19167: END
// on UnitDestroyed ( un ) do begin SOS_UnitDestroyed ( un ) ;
19168: LD_VAR 0 1
19172: PPUSH
19173: CALL 107937 0 1
// if GameType = 1 then
19177: LD_EXP 2
19181: PUSH
19182: LD_INT 1
19184: EQUAL
19185: IFFALSE 19420
// begin if un = playerCommander then
19187: LD_VAR 0 1
19191: PUSH
19192: LD_EXP 9
19196: EQUAL
19197: IFFALSE 19206
// YouLost ( commanderDied ) ;
19199: LD_STRING commanderDied
19201: PPUSH
19202: CALL_OW 104
// if un = allyCommander then
19206: LD_VAR 0 1
19210: PUSH
19211: LD_EXP 11
19215: EQUAL
19216: IFFALSE 19225
// YouLost ( Theta ) ;
19218: LD_STRING Theta
19220: PPUSH
19221: CALL_OW 104
// if un in FilterAllUnits ( [ [ f_side , 8 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_building ] ] ] ) then
19225: LD_VAR 0 1
19229: PUSH
19230: LD_INT 22
19232: PUSH
19233: LD_INT 8
19235: PUSH
19236: EMPTY
19237: LIST
19238: LIST
19239: PUSH
19240: LD_INT 2
19242: PUSH
19243: LD_INT 21
19245: PUSH
19246: LD_INT 1
19248: PUSH
19249: EMPTY
19250: LIST
19251: LIST
19252: PUSH
19253: LD_INT 21
19255: PUSH
19256: LD_INT 3
19258: PUSH
19259: EMPTY
19260: LIST
19261: LIST
19262: PUSH
19263: EMPTY
19264: LIST
19265: LIST
19266: LIST
19267: PUSH
19268: EMPTY
19269: LIST
19270: LIST
19271: PPUSH
19272: CALL_OW 69
19276: IN
19277: IFFALSE 19293
// legDestCounter := legDestCounter + 1 ;
19279: LD_ADDR_EXP 18
19283: PUSH
19284: LD_EXP 18
19288: PUSH
19289: LD_INT 1
19291: PLUS
19292: ST_TO_ADDR
// if un in FilterAllUnits ( [ [ f_side , 4 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_building ] ] ] ) then
19293: LD_VAR 0 1
19297: PUSH
19298: LD_INT 22
19300: PUSH
19301: LD_INT 4
19303: PUSH
19304: EMPTY
19305: LIST
19306: LIST
19307: PUSH
19308: LD_INT 2
19310: PUSH
19311: LD_INT 21
19313: PUSH
19314: LD_INT 1
19316: PUSH
19317: EMPTY
19318: LIST
19319: LIST
19320: PUSH
19321: LD_INT 21
19323: PUSH
19324: LD_INT 3
19326: PUSH
19327: EMPTY
19328: LIST
19329: LIST
19330: PUSH
19331: EMPTY
19332: LIST
19333: LIST
19334: LIST
19335: PUSH
19336: EMPTY
19337: LIST
19338: LIST
19339: PPUSH
19340: CALL_OW 69
19344: IN
19345: IFFALSE 19361
// allyDestCounter := allyDestCounter + 1 ;
19347: LD_ADDR_EXP 22
19351: PUSH
19352: LD_EXP 22
19356: PUSH
19357: LD_INT 1
19359: PLUS
19360: ST_TO_ADDR
// if un in ruOutpost then
19361: LD_VAR 0 1
19365: PUSH
19366: LD_EXP 14
19370: IN
19371: IFFALSE 19420
// begin ruOutpost := ruOutpost diff un ;
19373: LD_ADDR_EXP 14
19377: PUSH
19378: LD_EXP 14
19382: PUSH
19383: LD_VAR 0 1
19387: DIFF
19388: ST_TO_ADDR
// ruEscape := Replace ( ruEscape , 1 , ruEscape [ 1 ] + 1 ) ;
19389: LD_ADDR_EXP 15
19393: PUSH
19394: LD_EXP 15
19398: PPUSH
19399: LD_INT 1
19401: PPUSH
19402: LD_EXP 15
19406: PUSH
19407: LD_INT 1
19409: ARRAY
19410: PUSH
19411: LD_INT 1
19413: PLUS
19414: PPUSH
19415: CALL_OW 1
19419: ST_TO_ADDR
// end ; end ; MCE_UnitDestroyed ( un ) ;
19420: LD_VAR 0 1
19424: PPUSH
19425: CALL 89151 0 1
// end ;
19429: PPOPN 1
19431: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
19432: LD_VAR 0 1
19436: PPUSH
19437: LD_VAR 0 2
19441: PPUSH
19442: CALL 91483 0 2
// end ;
19446: PPOPN 2
19448: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
19449: LD_VAR 0 1
19453: PPUSH
19454: CALL 90551 0 1
// end ;
19458: PPOPN 1
19460: END
// on BuildingComplete ( building ) do begin MCE_BuildingComplete ( building ) ;
19461: LD_VAR 0 1
19465: PPUSH
19466: CALL 90792 0 1
// end ;
19470: PPOPN 1
19472: END
// on ResearchComplete ( tech , lab ) do begin if tech = tech_LasDouble and GetSide ( lab ) = 1 then
19473: LD_VAR 0 1
19477: PUSH
19478: LD_INT 14
19480: EQUAL
19481: PUSH
19482: LD_VAR 0 2
19486: PPUSH
19487: CALL_OW 255
19491: PUSH
19492: LD_INT 1
19494: EQUAL
19495: AND
19496: IFFALSE 19537
// begin Say ( playerCommander , D & [ I , J , S ] [ commander ] & -1-Laser ) ;
19498: LD_EXP 9
19502: PPUSH
19503: LD_STRING D
19505: PUSH
19506: LD_STRING I
19508: PUSH
19509: LD_STRING J
19511: PUSH
19512: LD_STRING S
19514: PUSH
19515: EMPTY
19516: LIST
19517: LIST
19518: LIST
19519: PUSH
19520: LD_EXP 25
19524: ARRAY
19525: STR
19526: PUSH
19527: LD_STRING -1-Laser
19529: STR
19530: PPUSH
19531: CALL_OW 88
// exit ;
19535: GO 19679
// end ; if tech = tech_MatDet and GetSide ( lab ) = 1 then
19537: LD_VAR 0 1
19541: PUSH
19542: LD_INT 7
19544: EQUAL
19545: PUSH
19546: LD_VAR 0 2
19550: PPUSH
19551: CALL_OW 255
19555: PUSH
19556: LD_INT 1
19558: EQUAL
19559: AND
19560: IFFALSE 19601
// begin Say ( playerCommander , D & [ I , J , S ] [ commander ] & -1-Materialization ) ;
19562: LD_EXP 9
19566: PPUSH
19567: LD_STRING D
19569: PUSH
19570: LD_STRING I
19572: PUSH
19573: LD_STRING J
19575: PUSH
19576: LD_STRING S
19578: PUSH
19579: EMPTY
19580: LIST
19581: LIST
19582: LIST
19583: PUSH
19584: LD_EXP 25
19588: ARRAY
19589: STR
19590: PUSH
19591: LD_STRING -1-Materialization
19593: STR
19594: PPUSH
19595: CALL_OW 88
// exit ;
19599: GO 19679
// end ; if tech = tech_SibFiss and GetSide ( lab ) = 1 then
19601: LD_VAR 0 1
19605: PUSH
19606: LD_INT 25
19608: EQUAL
19609: PUSH
19610: LD_VAR 0 2
19614: PPUSH
19615: CALL_OW 255
19619: PUSH
19620: LD_INT 1
19622: EQUAL
19623: AND
19624: IFFALSE 19665
// begin Say ( playerCommander , D & [ I , J , S ] [ commander ] & -1-Rocket ) ;
19626: LD_EXP 9
19630: PPUSH
19631: LD_STRING D
19633: PUSH
19634: LD_STRING I
19636: PUSH
19637: LD_STRING J
19639: PUSH
19640: LD_STRING S
19642: PUSH
19643: EMPTY
19644: LIST
19645: LIST
19646: LIST
19647: PUSH
19648: LD_EXP 25
19652: ARRAY
19653: STR
19654: PUSH
19655: LD_STRING -1-Rocket
19657: STR
19658: PPUSH
19659: CALL_OW 88
// exit ;
19663: GO 19679
// end ; MCE_ResearchComplete ( tech , lab ) ;
19665: LD_VAR 0 1
19669: PPUSH
19670: LD_VAR 0 2
19674: PPUSH
19675: CALL 88847 0 2
// end ;
19679: PPOPN 2
19681: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
19682: LD_VAR 0 1
19686: PPUSH
19687: LD_VAR 0 2
19691: PPUSH
19692: LD_VAR 0 3
19696: PPUSH
19697: LD_VAR 0 4
19701: PPUSH
19702: LD_VAR 0 5
19706: PPUSH
19707: CALL 88467 0 5
// end ;
19711: PPOPN 5
19713: END
// on VehicleConstructed ( vehicle , factory ) do begin SOS_VehicleConstructed ( vehicle , factory ) ;
19714: LD_VAR 0 1
19718: PPUSH
19719: LD_VAR 0 2
19723: PPUSH
19724: CALL 108057 0 2
// MCE_VehicleConstructed ( vehicle , factory ) ;
19728: LD_VAR 0 1
19732: PPUSH
19733: LD_VAR 0 2
19737: PPUSH
19738: CALL 88020 0 2
// end ;
19742: PPOPN 2
19744: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
19745: LD_VAR 0 1
19749: PPUSH
19750: LD_VAR 0 2
19754: PPUSH
19755: LD_VAR 0 3
19759: PPUSH
19760: LD_VAR 0 4
19764: PPUSH
19765: CALL 87858 0 4
// end ;
19769: PPOPN 4
19771: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
19772: LD_VAR 0 1
19776: PPUSH
19777: LD_VAR 0 2
19781: PPUSH
19782: LD_VAR 0 3
19786: PPUSH
19787: CALL 87633 0 3
// end ;
19791: PPOPN 3
19793: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
19794: LD_VAR 0 1
19798: PPUSH
19799: LD_VAR 0 2
19803: PPUSH
19804: CALL 87518 0 2
// end ;
19808: PPOPN 2
19810: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
19811: LD_VAR 0 1
19815: PPUSH
19816: LD_VAR 0 2
19820: PPUSH
19821: CALL 91778 0 2
// end ;
19825: PPOPN 2
19827: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
19828: LD_VAR 0 1
19832: PPUSH
19833: LD_VAR 0 2
19837: PPUSH
19838: LD_VAR 0 3
19842: PPUSH
19843: LD_VAR 0 4
19847: PPUSH
19848: CALL 91994 0 4
// end ;
19852: PPOPN 4
19854: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
19855: LD_VAR 0 1
19859: PPUSH
19860: LD_VAR 0 2
19864: PPUSH
19865: CALL 87327 0 2
// end ;
19869: PPOPN 2
19871: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
19872: LD_VAR 0 1
19876: PPUSH
19877: CALL 108041 0 1
// end ; end_of_file
19881: PPOPN 1
19883: END
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
19884: LD_INT 0
19886: PPUSH
19887: PPUSH
// if exist_mode then
19888: LD_VAR 0 2
19892: IFFALSE 19917
// unit := CreateCharacter ( prefix & ident ) else
19894: LD_ADDR_VAR 0 5
19898: PUSH
19899: LD_VAR 0 3
19903: PUSH
19904: LD_VAR 0 1
19908: STR
19909: PPUSH
19910: CALL_OW 34
19914: ST_TO_ADDR
19915: GO 19932
// unit := NewCharacter ( ident ) ;
19917: LD_ADDR_VAR 0 5
19921: PUSH
19922: LD_VAR 0 1
19926: PPUSH
19927: CALL_OW 25
19931: ST_TO_ADDR
// result := unit ;
19932: LD_ADDR_VAR 0 4
19936: PUSH
19937: LD_VAR 0 5
19941: ST_TO_ADDR
// end ;
19942: LD_VAR 0 4
19946: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
19947: LD_INT 0
19949: PPUSH
19950: PPUSH
// if not side or not nation then
19951: LD_VAR 0 1
19955: NOT
19956: PUSH
19957: LD_VAR 0 2
19961: NOT
19962: OR
19963: IFFALSE 19967
// exit ;
19965: GO 20735
// case nation of nation_american :
19967: LD_VAR 0 2
19971: PUSH
19972: LD_INT 1
19974: DOUBLE
19975: EQUAL
19976: IFTRUE 19980
19978: GO 20194
19980: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
19981: LD_ADDR_VAR 0 4
19985: PUSH
19986: LD_INT 35
19988: PUSH
19989: LD_INT 45
19991: PUSH
19992: LD_INT 46
19994: PUSH
19995: LD_INT 47
19997: PUSH
19998: LD_INT 82
20000: PUSH
20001: LD_INT 83
20003: PUSH
20004: LD_INT 84
20006: PUSH
20007: LD_INT 85
20009: PUSH
20010: LD_INT 86
20012: PUSH
20013: LD_INT 1
20015: PUSH
20016: LD_INT 2
20018: PUSH
20019: LD_INT 6
20021: PUSH
20022: LD_INT 15
20024: PUSH
20025: LD_INT 16
20027: PUSH
20028: LD_INT 7
20030: PUSH
20031: LD_INT 12
20033: PUSH
20034: LD_INT 13
20036: PUSH
20037: LD_INT 10
20039: PUSH
20040: LD_INT 14
20042: PUSH
20043: LD_INT 20
20045: PUSH
20046: LD_INT 21
20048: PUSH
20049: LD_INT 22
20051: PUSH
20052: LD_INT 25
20054: PUSH
20055: LD_INT 32
20057: PUSH
20058: LD_INT 27
20060: PUSH
20061: LD_INT 36
20063: PUSH
20064: LD_INT 69
20066: PUSH
20067: LD_INT 39
20069: PUSH
20070: LD_INT 34
20072: PUSH
20073: LD_INT 40
20075: PUSH
20076: LD_INT 48
20078: PUSH
20079: LD_INT 49
20081: PUSH
20082: LD_INT 50
20084: PUSH
20085: LD_INT 51
20087: PUSH
20088: LD_INT 52
20090: PUSH
20091: LD_INT 53
20093: PUSH
20094: LD_INT 54
20096: PUSH
20097: LD_INT 55
20099: PUSH
20100: LD_INT 56
20102: PUSH
20103: LD_INT 57
20105: PUSH
20106: LD_INT 58
20108: PUSH
20109: LD_INT 59
20111: PUSH
20112: LD_INT 60
20114: PUSH
20115: LD_INT 61
20117: PUSH
20118: LD_INT 62
20120: PUSH
20121: LD_INT 80
20123: PUSH
20124: LD_INT 82
20126: PUSH
20127: LD_INT 83
20129: PUSH
20130: LD_INT 84
20132: PUSH
20133: LD_INT 85
20135: PUSH
20136: LD_INT 86
20138: PUSH
20139: EMPTY
20140: LIST
20141: LIST
20142: LIST
20143: LIST
20144: LIST
20145: LIST
20146: LIST
20147: LIST
20148: LIST
20149: LIST
20150: LIST
20151: LIST
20152: LIST
20153: LIST
20154: LIST
20155: LIST
20156: LIST
20157: LIST
20158: LIST
20159: LIST
20160: LIST
20161: LIST
20162: LIST
20163: LIST
20164: LIST
20165: LIST
20166: LIST
20167: LIST
20168: LIST
20169: LIST
20170: LIST
20171: LIST
20172: LIST
20173: LIST
20174: LIST
20175: LIST
20176: LIST
20177: LIST
20178: LIST
20179: LIST
20180: LIST
20181: LIST
20182: LIST
20183: LIST
20184: LIST
20185: LIST
20186: LIST
20187: LIST
20188: LIST
20189: LIST
20190: LIST
20191: ST_TO_ADDR
20192: GO 20659
20194: LD_INT 2
20196: DOUBLE
20197: EQUAL
20198: IFTRUE 20202
20200: GO 20428
20202: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 ] ; nation_russian :
20203: LD_ADDR_VAR 0 4
20207: PUSH
20208: LD_INT 35
20210: PUSH
20211: LD_INT 45
20213: PUSH
20214: LD_INT 46
20216: PUSH
20217: LD_INT 47
20219: PUSH
20220: LD_INT 82
20222: PUSH
20223: LD_INT 83
20225: PUSH
20226: LD_INT 84
20228: PUSH
20229: LD_INT 85
20231: PUSH
20232: LD_INT 87
20234: PUSH
20235: LD_INT 70
20237: PUSH
20238: LD_INT 1
20240: PUSH
20241: LD_INT 11
20243: PUSH
20244: LD_INT 3
20246: PUSH
20247: LD_INT 4
20249: PUSH
20250: LD_INT 5
20252: PUSH
20253: LD_INT 6
20255: PUSH
20256: LD_INT 15
20258: PUSH
20259: LD_INT 18
20261: PUSH
20262: LD_INT 7
20264: PUSH
20265: LD_INT 17
20267: PUSH
20268: LD_INT 8
20270: PUSH
20271: LD_INT 20
20273: PUSH
20274: LD_INT 21
20276: PUSH
20277: LD_INT 22
20279: PUSH
20280: LD_INT 72
20282: PUSH
20283: LD_INT 26
20285: PUSH
20286: LD_INT 69
20288: PUSH
20289: LD_INT 39
20291: PUSH
20292: LD_INT 40
20294: PUSH
20295: LD_INT 41
20297: PUSH
20298: LD_INT 42
20300: PUSH
20301: LD_INT 43
20303: PUSH
20304: LD_INT 48
20306: PUSH
20307: LD_INT 49
20309: PUSH
20310: LD_INT 50
20312: PUSH
20313: LD_INT 51
20315: PUSH
20316: LD_INT 52
20318: PUSH
20319: LD_INT 53
20321: PUSH
20322: LD_INT 54
20324: PUSH
20325: LD_INT 55
20327: PUSH
20328: LD_INT 56
20330: PUSH
20331: LD_INT 60
20333: PUSH
20334: LD_INT 61
20336: PUSH
20337: LD_INT 62
20339: PUSH
20340: LD_INT 66
20342: PUSH
20343: LD_INT 67
20345: PUSH
20346: LD_INT 68
20348: PUSH
20349: LD_INT 81
20351: PUSH
20352: LD_INT 82
20354: PUSH
20355: LD_INT 83
20357: PUSH
20358: LD_INT 84
20360: PUSH
20361: LD_INT 85
20363: PUSH
20364: LD_INT 87
20366: PUSH
20367: LD_INT 88
20369: PUSH
20370: EMPTY
20371: LIST
20372: LIST
20373: LIST
20374: LIST
20375: LIST
20376: LIST
20377: LIST
20378: LIST
20379: LIST
20380: LIST
20381: LIST
20382: LIST
20383: LIST
20384: LIST
20385: LIST
20386: LIST
20387: LIST
20388: LIST
20389: LIST
20390: LIST
20391: LIST
20392: LIST
20393: LIST
20394: LIST
20395: LIST
20396: LIST
20397: LIST
20398: LIST
20399: LIST
20400: LIST
20401: LIST
20402: LIST
20403: LIST
20404: LIST
20405: LIST
20406: LIST
20407: LIST
20408: LIST
20409: LIST
20410: LIST
20411: LIST
20412: LIST
20413: LIST
20414: LIST
20415: LIST
20416: LIST
20417: LIST
20418: LIST
20419: LIST
20420: LIST
20421: LIST
20422: LIST
20423: LIST
20424: LIST
20425: ST_TO_ADDR
20426: GO 20659
20428: LD_INT 3
20430: DOUBLE
20431: EQUAL
20432: IFTRUE 20436
20434: GO 20658
20436: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
20437: LD_ADDR_VAR 0 4
20441: PUSH
20442: LD_INT 46
20444: PUSH
20445: LD_INT 47
20447: PUSH
20448: LD_INT 1
20450: PUSH
20451: LD_INT 2
20453: PUSH
20454: LD_INT 82
20456: PUSH
20457: LD_INT 83
20459: PUSH
20460: LD_INT 84
20462: PUSH
20463: LD_INT 85
20465: PUSH
20466: LD_INT 86
20468: PUSH
20469: LD_INT 11
20471: PUSH
20472: LD_INT 9
20474: PUSH
20475: LD_INT 20
20477: PUSH
20478: LD_INT 19
20480: PUSH
20481: LD_INT 21
20483: PUSH
20484: LD_INT 24
20486: PUSH
20487: LD_INT 22
20489: PUSH
20490: LD_INT 25
20492: PUSH
20493: LD_INT 28
20495: PUSH
20496: LD_INT 29
20498: PUSH
20499: LD_INT 30
20501: PUSH
20502: LD_INT 31
20504: PUSH
20505: LD_INT 37
20507: PUSH
20508: LD_INT 38
20510: PUSH
20511: LD_INT 32
20513: PUSH
20514: LD_INT 27
20516: PUSH
20517: LD_INT 33
20519: PUSH
20520: LD_INT 69
20522: PUSH
20523: LD_INT 39
20525: PUSH
20526: LD_INT 34
20528: PUSH
20529: LD_INT 40
20531: PUSH
20532: LD_INT 71
20534: PUSH
20535: LD_INT 23
20537: PUSH
20538: LD_INT 44
20540: PUSH
20541: LD_INT 48
20543: PUSH
20544: LD_INT 49
20546: PUSH
20547: LD_INT 50
20549: PUSH
20550: LD_INT 51
20552: PUSH
20553: LD_INT 52
20555: PUSH
20556: LD_INT 53
20558: PUSH
20559: LD_INT 54
20561: PUSH
20562: LD_INT 55
20564: PUSH
20565: LD_INT 56
20567: PUSH
20568: LD_INT 57
20570: PUSH
20571: LD_INT 58
20573: PUSH
20574: LD_INT 59
20576: PUSH
20577: LD_INT 63
20579: PUSH
20580: LD_INT 64
20582: PUSH
20583: LD_INT 65
20585: PUSH
20586: LD_INT 82
20588: PUSH
20589: LD_INT 83
20591: PUSH
20592: LD_INT 84
20594: PUSH
20595: LD_INT 85
20597: PUSH
20598: LD_INT 86
20600: PUSH
20601: EMPTY
20602: LIST
20603: LIST
20604: LIST
20605: LIST
20606: LIST
20607: LIST
20608: LIST
20609: LIST
20610: LIST
20611: LIST
20612: LIST
20613: LIST
20614: LIST
20615: LIST
20616: LIST
20617: LIST
20618: LIST
20619: LIST
20620: LIST
20621: LIST
20622: LIST
20623: LIST
20624: LIST
20625: LIST
20626: LIST
20627: LIST
20628: LIST
20629: LIST
20630: LIST
20631: LIST
20632: LIST
20633: LIST
20634: LIST
20635: LIST
20636: LIST
20637: LIST
20638: LIST
20639: LIST
20640: LIST
20641: LIST
20642: LIST
20643: LIST
20644: LIST
20645: LIST
20646: LIST
20647: LIST
20648: LIST
20649: LIST
20650: LIST
20651: LIST
20652: LIST
20653: LIST
20654: LIST
20655: ST_TO_ADDR
20656: GO 20659
20658: POP
// if state > - 1 and state < 3 then
20659: LD_VAR 0 3
20663: PUSH
20664: LD_INT 1
20666: NEG
20667: GREATER
20668: PUSH
20669: LD_VAR 0 3
20673: PUSH
20674: LD_INT 3
20676: LESS
20677: AND
20678: IFFALSE 20735
// for i in result do
20680: LD_ADDR_VAR 0 5
20684: PUSH
20685: LD_VAR 0 4
20689: PUSH
20690: FOR_IN
20691: IFFALSE 20733
// if GetTech ( i , side ) <> state then
20693: LD_VAR 0 5
20697: PPUSH
20698: LD_VAR 0 1
20702: PPUSH
20703: CALL_OW 321
20707: PUSH
20708: LD_VAR 0 3
20712: NONEQUAL
20713: IFFALSE 20731
// result := result diff i ;
20715: LD_ADDR_VAR 0 4
20719: PUSH
20720: LD_VAR 0 4
20724: PUSH
20725: LD_VAR 0 5
20729: DIFF
20730: ST_TO_ADDR
20731: GO 20690
20733: POP
20734: POP
// end ;
20735: LD_VAR 0 4
20739: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
20740: LD_INT 0
20742: PPUSH
20743: PPUSH
20744: PPUSH
// result := true ;
20745: LD_ADDR_VAR 0 3
20749: PUSH
20750: LD_INT 1
20752: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
20753: LD_ADDR_VAR 0 5
20757: PUSH
20758: LD_VAR 0 2
20762: PPUSH
20763: CALL_OW 480
20767: ST_TO_ADDR
// if not tmp then
20768: LD_VAR 0 5
20772: NOT
20773: IFFALSE 20777
// exit ;
20775: GO 20826
// for i in tmp do
20777: LD_ADDR_VAR 0 4
20781: PUSH
20782: LD_VAR 0 5
20786: PUSH
20787: FOR_IN
20788: IFFALSE 20824
// if GetTech ( i , side ) <> state_researched then
20790: LD_VAR 0 4
20794: PPUSH
20795: LD_VAR 0 1
20799: PPUSH
20800: CALL_OW 321
20804: PUSH
20805: LD_INT 2
20807: NONEQUAL
20808: IFFALSE 20822
// begin result := false ;
20810: LD_ADDR_VAR 0 3
20814: PUSH
20815: LD_INT 0
20817: ST_TO_ADDR
// exit ;
20818: POP
20819: POP
20820: GO 20826
// end ;
20822: GO 20787
20824: POP
20825: POP
// end ;
20826: LD_VAR 0 3
20830: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
20831: LD_INT 0
20833: PPUSH
20834: PPUSH
20835: PPUSH
20836: PPUSH
20837: PPUSH
20838: PPUSH
20839: PPUSH
20840: PPUSH
20841: PPUSH
20842: PPUSH
20843: PPUSH
20844: PPUSH
20845: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
20846: LD_VAR 0 1
20850: NOT
20851: PUSH
20852: LD_VAR 0 1
20856: PPUSH
20857: CALL_OW 257
20861: PUSH
20862: LD_INT 9
20864: NONEQUAL
20865: OR
20866: IFFALSE 20870
// exit ;
20868: GO 21443
// side := GetSide ( unit ) ;
20870: LD_ADDR_VAR 0 9
20874: PUSH
20875: LD_VAR 0 1
20879: PPUSH
20880: CALL_OW 255
20884: ST_TO_ADDR
// tech_space := tech_spacanom ;
20885: LD_ADDR_VAR 0 12
20889: PUSH
20890: LD_INT 29
20892: ST_TO_ADDR
// tech_time := tech_taurad ;
20893: LD_ADDR_VAR 0 13
20897: PUSH
20898: LD_INT 28
20900: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
20901: LD_ADDR_VAR 0 11
20905: PUSH
20906: LD_VAR 0 1
20910: PPUSH
20911: CALL_OW 310
20915: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
20916: LD_VAR 0 11
20920: PPUSH
20921: CALL_OW 247
20925: PUSH
20926: LD_INT 2
20928: EQUAL
20929: IFFALSE 20933
// exit ;
20931: GO 21443
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
20933: LD_ADDR_VAR 0 8
20937: PUSH
20938: LD_INT 81
20940: PUSH
20941: LD_VAR 0 9
20945: PUSH
20946: EMPTY
20947: LIST
20948: LIST
20949: PUSH
20950: LD_INT 3
20952: PUSH
20953: LD_INT 21
20955: PUSH
20956: LD_INT 3
20958: PUSH
20959: EMPTY
20960: LIST
20961: LIST
20962: PUSH
20963: EMPTY
20964: LIST
20965: LIST
20966: PUSH
20967: EMPTY
20968: LIST
20969: LIST
20970: PPUSH
20971: CALL_OW 69
20975: ST_TO_ADDR
// if not tmp then
20976: LD_VAR 0 8
20980: NOT
20981: IFFALSE 20985
// exit ;
20983: GO 21443
// if in_unit then
20985: LD_VAR 0 11
20989: IFFALSE 21013
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
20991: LD_ADDR_VAR 0 10
20995: PUSH
20996: LD_VAR 0 8
21000: PPUSH
21001: LD_VAR 0 11
21005: PPUSH
21006: CALL_OW 74
21010: ST_TO_ADDR
21011: GO 21033
// enemy := NearestUnitToUnit ( tmp , unit ) ;
21013: LD_ADDR_VAR 0 10
21017: PUSH
21018: LD_VAR 0 8
21022: PPUSH
21023: LD_VAR 0 1
21027: PPUSH
21028: CALL_OW 74
21032: ST_TO_ADDR
// if not enemy then
21033: LD_VAR 0 10
21037: NOT
21038: IFFALSE 21042
// exit ;
21040: GO 21443
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
21042: LD_VAR 0 11
21046: PUSH
21047: LD_VAR 0 11
21051: PPUSH
21052: LD_VAR 0 10
21056: PPUSH
21057: CALL_OW 296
21061: PUSH
21062: LD_INT 13
21064: GREATER
21065: AND
21066: PUSH
21067: LD_VAR 0 1
21071: PPUSH
21072: LD_VAR 0 10
21076: PPUSH
21077: CALL_OW 296
21081: PUSH
21082: LD_INT 12
21084: GREATER
21085: OR
21086: IFFALSE 21090
// exit ;
21088: GO 21443
// missile := [ 1 ] ;
21090: LD_ADDR_VAR 0 14
21094: PUSH
21095: LD_INT 1
21097: PUSH
21098: EMPTY
21099: LIST
21100: ST_TO_ADDR
// if Researched ( side , tech_space ) then
21101: LD_VAR 0 9
21105: PPUSH
21106: LD_VAR 0 12
21110: PPUSH
21111: CALL_OW 325
21115: IFFALSE 21144
// missile := Replace ( missile , missile + 1 , 2 ) ;
21117: LD_ADDR_VAR 0 14
21121: PUSH
21122: LD_VAR 0 14
21126: PPUSH
21127: LD_VAR 0 14
21131: PUSH
21132: LD_INT 1
21134: PLUS
21135: PPUSH
21136: LD_INT 2
21138: PPUSH
21139: CALL_OW 1
21143: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
21144: LD_VAR 0 9
21148: PPUSH
21149: LD_VAR 0 13
21153: PPUSH
21154: CALL_OW 325
21158: PUSH
21159: LD_VAR 0 10
21163: PPUSH
21164: CALL_OW 255
21168: PPUSH
21169: LD_VAR 0 13
21173: PPUSH
21174: CALL_OW 325
21178: NOT
21179: AND
21180: IFFALSE 21209
// missile := Replace ( missile , missile + 1 , 3 ) ;
21182: LD_ADDR_VAR 0 14
21186: PUSH
21187: LD_VAR 0 14
21191: PPUSH
21192: LD_VAR 0 14
21196: PUSH
21197: LD_INT 1
21199: PLUS
21200: PPUSH
21201: LD_INT 3
21203: PPUSH
21204: CALL_OW 1
21208: ST_TO_ADDR
// if missile < 2 then
21209: LD_VAR 0 14
21213: PUSH
21214: LD_INT 2
21216: LESS
21217: IFFALSE 21221
// exit ;
21219: GO 21443
// x := GetX ( enemy ) ;
21221: LD_ADDR_VAR 0 4
21225: PUSH
21226: LD_VAR 0 10
21230: PPUSH
21231: CALL_OW 250
21235: ST_TO_ADDR
// y := GetY ( enemy ) ;
21236: LD_ADDR_VAR 0 5
21240: PUSH
21241: LD_VAR 0 10
21245: PPUSH
21246: CALL_OW 251
21250: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
21251: LD_ADDR_VAR 0 6
21255: PUSH
21256: LD_VAR 0 4
21260: PUSH
21261: LD_INT 1
21263: NEG
21264: PPUSH
21265: LD_INT 1
21267: PPUSH
21268: CALL_OW 12
21272: PLUS
21273: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
21274: LD_ADDR_VAR 0 7
21278: PUSH
21279: LD_VAR 0 5
21283: PUSH
21284: LD_INT 1
21286: NEG
21287: PPUSH
21288: LD_INT 1
21290: PPUSH
21291: CALL_OW 12
21295: PLUS
21296: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
21297: LD_VAR 0 6
21301: PPUSH
21302: LD_VAR 0 7
21306: PPUSH
21307: CALL_OW 488
21311: NOT
21312: IFFALSE 21334
// begin _x := x ;
21314: LD_ADDR_VAR 0 6
21318: PUSH
21319: LD_VAR 0 4
21323: ST_TO_ADDR
// _y := y ;
21324: LD_ADDR_VAR 0 7
21328: PUSH
21329: LD_VAR 0 5
21333: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
21334: LD_ADDR_VAR 0 3
21338: PUSH
21339: LD_INT 1
21341: PPUSH
21342: LD_VAR 0 14
21346: PPUSH
21347: CALL_OW 12
21351: ST_TO_ADDR
// case i of 1 :
21352: LD_VAR 0 3
21356: PUSH
21357: LD_INT 1
21359: DOUBLE
21360: EQUAL
21361: IFTRUE 21365
21363: GO 21382
21365: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
21366: LD_VAR 0 1
21370: PPUSH
21371: LD_VAR 0 10
21375: PPUSH
21376: CALL_OW 115
21380: GO 21443
21382: LD_INT 2
21384: DOUBLE
21385: EQUAL
21386: IFTRUE 21390
21388: GO 21412
21390: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
21391: LD_VAR 0 1
21395: PPUSH
21396: LD_VAR 0 6
21400: PPUSH
21401: LD_VAR 0 7
21405: PPUSH
21406: CALL_OW 153
21410: GO 21443
21412: LD_INT 3
21414: DOUBLE
21415: EQUAL
21416: IFTRUE 21420
21418: GO 21442
21420: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
21421: LD_VAR 0 1
21425: PPUSH
21426: LD_VAR 0 6
21430: PPUSH
21431: LD_VAR 0 7
21435: PPUSH
21436: CALL_OW 154
21440: GO 21443
21442: POP
// end ;
21443: LD_VAR 0 2
21447: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
21448: LD_INT 0
21450: PPUSH
21451: PPUSH
21452: PPUSH
21453: PPUSH
21454: PPUSH
21455: PPUSH
// if not unit or not building then
21456: LD_VAR 0 1
21460: NOT
21461: PUSH
21462: LD_VAR 0 2
21466: NOT
21467: OR
21468: IFFALSE 21472
// exit ;
21470: GO 21630
// x := GetX ( building ) ;
21472: LD_ADDR_VAR 0 5
21476: PUSH
21477: LD_VAR 0 2
21481: PPUSH
21482: CALL_OW 250
21486: ST_TO_ADDR
// y := GetY ( building ) ;
21487: LD_ADDR_VAR 0 6
21491: PUSH
21492: LD_VAR 0 2
21496: PPUSH
21497: CALL_OW 251
21501: ST_TO_ADDR
// for i = 0 to 5 do
21502: LD_ADDR_VAR 0 4
21506: PUSH
21507: DOUBLE
21508: LD_INT 0
21510: DEC
21511: ST_TO_ADDR
21512: LD_INT 5
21514: PUSH
21515: FOR_TO
21516: IFFALSE 21628
// begin _x := ShiftX ( x , i , 3 ) ;
21518: LD_ADDR_VAR 0 7
21522: PUSH
21523: LD_VAR 0 5
21527: PPUSH
21528: LD_VAR 0 4
21532: PPUSH
21533: LD_INT 3
21535: PPUSH
21536: CALL_OW 272
21540: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
21541: LD_ADDR_VAR 0 8
21545: PUSH
21546: LD_VAR 0 6
21550: PPUSH
21551: LD_VAR 0 4
21555: PPUSH
21556: LD_INT 3
21558: PPUSH
21559: CALL_OW 273
21563: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
21564: LD_VAR 0 7
21568: PPUSH
21569: LD_VAR 0 8
21573: PPUSH
21574: CALL_OW 488
21578: NOT
21579: IFFALSE 21583
// continue ;
21581: GO 21515
// if HexInfo ( _x , _y ) = 0 then
21583: LD_VAR 0 7
21587: PPUSH
21588: LD_VAR 0 8
21592: PPUSH
21593: CALL_OW 428
21597: PUSH
21598: LD_INT 0
21600: EQUAL
21601: IFFALSE 21626
// begin ComMoveXY ( unit , _x , _y ) ;
21603: LD_VAR 0 1
21607: PPUSH
21608: LD_VAR 0 7
21612: PPUSH
21613: LD_VAR 0 8
21617: PPUSH
21618: CALL_OW 111
// exit ;
21622: POP
21623: POP
21624: GO 21630
// end ; end ;
21626: GO 21515
21628: POP
21629: POP
// end ;
21630: LD_VAR 0 3
21634: RET
// export function ScanBase ( side , base_area ) ; begin
21635: LD_INT 0
21637: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
21638: LD_ADDR_VAR 0 3
21642: PUSH
21643: LD_VAR 0 2
21647: PPUSH
21648: LD_INT 81
21650: PUSH
21651: LD_VAR 0 1
21655: PUSH
21656: EMPTY
21657: LIST
21658: LIST
21659: PPUSH
21660: CALL_OW 70
21664: ST_TO_ADDR
// end ;
21665: LD_VAR 0 3
21669: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
21670: LD_INT 0
21672: PPUSH
21673: PPUSH
21674: PPUSH
21675: PPUSH
// result := false ;
21676: LD_ADDR_VAR 0 2
21680: PUSH
21681: LD_INT 0
21683: ST_TO_ADDR
// side := GetSide ( unit ) ;
21684: LD_ADDR_VAR 0 3
21688: PUSH
21689: LD_VAR 0 1
21693: PPUSH
21694: CALL_OW 255
21698: ST_TO_ADDR
// nat := GetNation ( unit ) ;
21699: LD_ADDR_VAR 0 4
21703: PUSH
21704: LD_VAR 0 1
21708: PPUSH
21709: CALL_OW 248
21713: ST_TO_ADDR
// case nat of 1 :
21714: LD_VAR 0 4
21718: PUSH
21719: LD_INT 1
21721: DOUBLE
21722: EQUAL
21723: IFTRUE 21727
21725: GO 21738
21727: POP
// tech := tech_lassight ; 2 :
21728: LD_ADDR_VAR 0 5
21732: PUSH
21733: LD_INT 12
21735: ST_TO_ADDR
21736: GO 21777
21738: LD_INT 2
21740: DOUBLE
21741: EQUAL
21742: IFTRUE 21746
21744: GO 21757
21746: POP
// tech := tech_mortar ; 3 :
21747: LD_ADDR_VAR 0 5
21751: PUSH
21752: LD_INT 41
21754: ST_TO_ADDR
21755: GO 21777
21757: LD_INT 3
21759: DOUBLE
21760: EQUAL
21761: IFTRUE 21765
21763: GO 21776
21765: POP
// tech := tech_bazooka ; end ;
21766: LD_ADDR_VAR 0 5
21770: PUSH
21771: LD_INT 44
21773: ST_TO_ADDR
21774: GO 21777
21776: POP
// if Researched ( side , tech ) then
21777: LD_VAR 0 3
21781: PPUSH
21782: LD_VAR 0 5
21786: PPUSH
21787: CALL_OW 325
21791: IFFALSE 21818
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
21793: LD_ADDR_VAR 0 2
21797: PUSH
21798: LD_INT 5
21800: PUSH
21801: LD_INT 8
21803: PUSH
21804: LD_INT 9
21806: PUSH
21807: EMPTY
21808: LIST
21809: LIST
21810: LIST
21811: PUSH
21812: LD_VAR 0 4
21816: ARRAY
21817: ST_TO_ADDR
// end ;
21818: LD_VAR 0 2
21822: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
21823: LD_INT 0
21825: PPUSH
21826: PPUSH
21827: PPUSH
// if not mines then
21828: LD_VAR 0 2
21832: NOT
21833: IFFALSE 21837
// exit ;
21835: GO 21981
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
21837: LD_ADDR_VAR 0 5
21841: PUSH
21842: LD_INT 81
21844: PUSH
21845: LD_VAR 0 1
21849: PUSH
21850: EMPTY
21851: LIST
21852: LIST
21853: PUSH
21854: LD_INT 3
21856: PUSH
21857: LD_INT 21
21859: PUSH
21860: LD_INT 3
21862: PUSH
21863: EMPTY
21864: LIST
21865: LIST
21866: PUSH
21867: EMPTY
21868: LIST
21869: LIST
21870: PUSH
21871: EMPTY
21872: LIST
21873: LIST
21874: PPUSH
21875: CALL_OW 69
21879: ST_TO_ADDR
// for i in mines do
21880: LD_ADDR_VAR 0 4
21884: PUSH
21885: LD_VAR 0 2
21889: PUSH
21890: FOR_IN
21891: IFFALSE 21979
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
21893: LD_VAR 0 4
21897: PUSH
21898: LD_INT 1
21900: ARRAY
21901: PPUSH
21902: LD_VAR 0 4
21906: PUSH
21907: LD_INT 2
21909: ARRAY
21910: PPUSH
21911: CALL_OW 458
21915: NOT
21916: IFFALSE 21920
// continue ;
21918: GO 21890
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
21920: LD_VAR 0 4
21924: PUSH
21925: LD_INT 1
21927: ARRAY
21928: PPUSH
21929: LD_VAR 0 4
21933: PUSH
21934: LD_INT 2
21936: ARRAY
21937: PPUSH
21938: CALL_OW 428
21942: PUSH
21943: LD_VAR 0 5
21947: IN
21948: IFFALSE 21977
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
21950: LD_VAR 0 4
21954: PUSH
21955: LD_INT 1
21957: ARRAY
21958: PPUSH
21959: LD_VAR 0 4
21963: PUSH
21964: LD_INT 2
21966: ARRAY
21967: PPUSH
21968: LD_VAR 0 1
21972: PPUSH
21973: CALL_OW 456
// end ;
21977: GO 21890
21979: POP
21980: POP
// end ;
21981: LD_VAR 0 3
21985: RET
// export function Count ( array ) ; begin
21986: LD_INT 0
21988: PPUSH
// result := array + 0 ;
21989: LD_ADDR_VAR 0 2
21993: PUSH
21994: LD_VAR 0 1
21998: PUSH
21999: LD_INT 0
22001: PLUS
22002: ST_TO_ADDR
// end ;
22003: LD_VAR 0 2
22007: RET
// export function IsEmpty ( building ) ; begin
22008: LD_INT 0
22010: PPUSH
// if not building then
22011: LD_VAR 0 1
22015: NOT
22016: IFFALSE 22020
// exit ;
22018: GO 22063
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
22020: LD_ADDR_VAR 0 2
22024: PUSH
22025: LD_VAR 0 1
22029: PUSH
22030: LD_INT 22
22032: PUSH
22033: LD_VAR 0 1
22037: PPUSH
22038: CALL_OW 255
22042: PUSH
22043: EMPTY
22044: LIST
22045: LIST
22046: PUSH
22047: LD_INT 58
22049: PUSH
22050: EMPTY
22051: LIST
22052: PUSH
22053: EMPTY
22054: LIST
22055: LIST
22056: PPUSH
22057: CALL_OW 69
22061: IN
22062: ST_TO_ADDR
// end ;
22063: LD_VAR 0 2
22067: RET
// export function IsNotFull ( building ) ; var places ; begin
22068: LD_INT 0
22070: PPUSH
22071: PPUSH
// if not building then
22072: LD_VAR 0 1
22076: NOT
22077: IFFALSE 22081
// exit ;
22079: GO 22109
// result := UnitFilter ( building , [ f_not , [ f_full ] ] ) ;
22081: LD_ADDR_VAR 0 2
22085: PUSH
22086: LD_VAR 0 1
22090: PPUSH
22091: LD_INT 3
22093: PUSH
22094: LD_INT 62
22096: PUSH
22097: EMPTY
22098: LIST
22099: PUSH
22100: EMPTY
22101: LIST
22102: LIST
22103: PPUSH
22104: CALL_OW 72
22108: ST_TO_ADDR
// end ;
22109: LD_VAR 0 2
22113: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
22114: LD_INT 0
22116: PPUSH
22117: PPUSH
22118: PPUSH
22119: PPUSH
// tmp := [ ] ;
22120: LD_ADDR_VAR 0 3
22124: PUSH
22125: EMPTY
22126: ST_TO_ADDR
// list := [ ] ;
22127: LD_ADDR_VAR 0 5
22131: PUSH
22132: EMPTY
22133: ST_TO_ADDR
// for i = 16 to 25 do
22134: LD_ADDR_VAR 0 4
22138: PUSH
22139: DOUBLE
22140: LD_INT 16
22142: DEC
22143: ST_TO_ADDR
22144: LD_INT 25
22146: PUSH
22147: FOR_TO
22148: IFFALSE 22221
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
22150: LD_ADDR_VAR 0 3
22154: PUSH
22155: LD_VAR 0 3
22159: PUSH
22160: LD_INT 22
22162: PUSH
22163: LD_VAR 0 1
22167: PPUSH
22168: CALL_OW 255
22172: PUSH
22173: EMPTY
22174: LIST
22175: LIST
22176: PUSH
22177: LD_INT 91
22179: PUSH
22180: LD_VAR 0 1
22184: PUSH
22185: LD_INT 6
22187: PUSH
22188: EMPTY
22189: LIST
22190: LIST
22191: LIST
22192: PUSH
22193: LD_INT 30
22195: PUSH
22196: LD_VAR 0 4
22200: PUSH
22201: EMPTY
22202: LIST
22203: LIST
22204: PUSH
22205: EMPTY
22206: LIST
22207: LIST
22208: LIST
22209: PUSH
22210: EMPTY
22211: LIST
22212: PPUSH
22213: CALL_OW 69
22217: ADD
22218: ST_TO_ADDR
22219: GO 22147
22221: POP
22222: POP
// for i = 1 to tmp do
22223: LD_ADDR_VAR 0 4
22227: PUSH
22228: DOUBLE
22229: LD_INT 1
22231: DEC
22232: ST_TO_ADDR
22233: LD_VAR 0 3
22237: PUSH
22238: FOR_TO
22239: IFFALSE 22327
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
22241: LD_ADDR_VAR 0 5
22245: PUSH
22246: LD_VAR 0 5
22250: PUSH
22251: LD_VAR 0 3
22255: PUSH
22256: LD_VAR 0 4
22260: ARRAY
22261: PPUSH
22262: CALL_OW 266
22266: PUSH
22267: LD_VAR 0 3
22271: PUSH
22272: LD_VAR 0 4
22276: ARRAY
22277: PPUSH
22278: CALL_OW 250
22282: PUSH
22283: LD_VAR 0 3
22287: PUSH
22288: LD_VAR 0 4
22292: ARRAY
22293: PPUSH
22294: CALL_OW 251
22298: PUSH
22299: LD_VAR 0 3
22303: PUSH
22304: LD_VAR 0 4
22308: ARRAY
22309: PPUSH
22310: CALL_OW 254
22314: PUSH
22315: EMPTY
22316: LIST
22317: LIST
22318: LIST
22319: LIST
22320: PUSH
22321: EMPTY
22322: LIST
22323: ADD
22324: ST_TO_ADDR
22325: GO 22238
22327: POP
22328: POP
// result := list ;
22329: LD_ADDR_VAR 0 2
22333: PUSH
22334: LD_VAR 0 5
22338: ST_TO_ADDR
// end ;
22339: LD_VAR 0 2
22343: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
22344: LD_INT 0
22346: PPUSH
22347: PPUSH
22348: PPUSH
22349: PPUSH
22350: PPUSH
22351: PPUSH
22352: PPUSH
// if not factory then
22353: LD_VAR 0 1
22357: NOT
22358: IFFALSE 22362
// exit ;
22360: GO 22955
// if control = control_apeman then
22362: LD_VAR 0 4
22366: PUSH
22367: LD_INT 5
22369: EQUAL
22370: IFFALSE 22479
// begin tmp := UnitsInside ( factory ) ;
22372: LD_ADDR_VAR 0 8
22376: PUSH
22377: LD_VAR 0 1
22381: PPUSH
22382: CALL_OW 313
22386: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
22387: LD_VAR 0 8
22391: PPUSH
22392: LD_INT 25
22394: PUSH
22395: LD_INT 12
22397: PUSH
22398: EMPTY
22399: LIST
22400: LIST
22401: PPUSH
22402: CALL_OW 72
22406: NOT
22407: IFFALSE 22417
// control := control_manual ;
22409: LD_ADDR_VAR 0 4
22413: PUSH
22414: LD_INT 1
22416: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
22417: LD_ADDR_VAR 0 8
22421: PUSH
22422: LD_VAR 0 1
22426: PPUSH
22427: CALL 22114 0 1
22431: ST_TO_ADDR
// if tmp then
22432: LD_VAR 0 8
22436: IFFALSE 22479
// begin for i in tmp do
22438: LD_ADDR_VAR 0 7
22442: PUSH
22443: LD_VAR 0 8
22447: PUSH
22448: FOR_IN
22449: IFFALSE 22477
// if i [ 1 ] = b_ext_radio then
22451: LD_VAR 0 7
22455: PUSH
22456: LD_INT 1
22458: ARRAY
22459: PUSH
22460: LD_INT 22
22462: EQUAL
22463: IFFALSE 22475
// begin control := control_remote ;
22465: LD_ADDR_VAR 0 4
22469: PUSH
22470: LD_INT 2
22472: ST_TO_ADDR
// break ;
22473: GO 22477
// end ;
22475: GO 22448
22477: POP
22478: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
22479: LD_VAR 0 1
22483: PPUSH
22484: LD_VAR 0 2
22488: PPUSH
22489: LD_VAR 0 3
22493: PPUSH
22494: LD_VAR 0 4
22498: PPUSH
22499: LD_VAR 0 5
22503: PPUSH
22504: CALL_OW 448
22508: IFFALSE 22543
// begin result := [ chassis , engine , control , weapon ] ;
22510: LD_ADDR_VAR 0 6
22514: PUSH
22515: LD_VAR 0 2
22519: PUSH
22520: LD_VAR 0 3
22524: PUSH
22525: LD_VAR 0 4
22529: PUSH
22530: LD_VAR 0 5
22534: PUSH
22535: EMPTY
22536: LIST
22537: LIST
22538: LIST
22539: LIST
22540: ST_TO_ADDR
// exit ;
22541: GO 22955
// end ; _chassis := AvailableChassisList ( factory ) ;
22543: LD_ADDR_VAR 0 9
22547: PUSH
22548: LD_VAR 0 1
22552: PPUSH
22553: CALL_OW 475
22557: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
22558: LD_ADDR_VAR 0 11
22562: PUSH
22563: LD_VAR 0 1
22567: PPUSH
22568: CALL_OW 476
22572: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
22573: LD_ADDR_VAR 0 12
22577: PUSH
22578: LD_VAR 0 1
22582: PPUSH
22583: CALL_OW 477
22587: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
22588: LD_ADDR_VAR 0 10
22592: PUSH
22593: LD_VAR 0 1
22597: PPUSH
22598: CALL_OW 478
22602: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
22603: LD_VAR 0 9
22607: NOT
22608: PUSH
22609: LD_VAR 0 11
22613: NOT
22614: OR
22615: PUSH
22616: LD_VAR 0 12
22620: NOT
22621: OR
22622: PUSH
22623: LD_VAR 0 10
22627: NOT
22628: OR
22629: IFFALSE 22664
// begin result := [ chassis , engine , control , weapon ] ;
22631: LD_ADDR_VAR 0 6
22635: PUSH
22636: LD_VAR 0 2
22640: PUSH
22641: LD_VAR 0 3
22645: PUSH
22646: LD_VAR 0 4
22650: PUSH
22651: LD_VAR 0 5
22655: PUSH
22656: EMPTY
22657: LIST
22658: LIST
22659: LIST
22660: LIST
22661: ST_TO_ADDR
// exit ;
22662: GO 22955
// end ; if not chassis in _chassis then
22664: LD_VAR 0 2
22668: PUSH
22669: LD_VAR 0 9
22673: IN
22674: NOT
22675: IFFALSE 22701
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
22677: LD_ADDR_VAR 0 2
22681: PUSH
22682: LD_VAR 0 9
22686: PUSH
22687: LD_INT 1
22689: PPUSH
22690: LD_VAR 0 9
22694: PPUSH
22695: CALL_OW 12
22699: ARRAY
22700: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
22701: LD_VAR 0 2
22705: PPUSH
22706: LD_VAR 0 3
22710: PPUSH
22711: CALL 22960 0 2
22715: NOT
22716: IFFALSE 22775
// repeat engine := _engine [ 1 ] ;
22718: LD_ADDR_VAR 0 3
22722: PUSH
22723: LD_VAR 0 11
22727: PUSH
22728: LD_INT 1
22730: ARRAY
22731: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
22732: LD_ADDR_VAR 0 11
22736: PUSH
22737: LD_VAR 0 11
22741: PPUSH
22742: LD_INT 1
22744: PPUSH
22745: CALL_OW 3
22749: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
22750: LD_VAR 0 2
22754: PPUSH
22755: LD_VAR 0 3
22759: PPUSH
22760: CALL 22960 0 2
22764: PUSH
22765: LD_VAR 0 11
22769: PUSH
22770: EMPTY
22771: EQUAL
22772: OR
22773: IFFALSE 22718
// if not control in _control then
22775: LD_VAR 0 4
22779: PUSH
22780: LD_VAR 0 12
22784: IN
22785: NOT
22786: IFFALSE 22812
// control := _control [ rand ( 1 , _control ) ] ;
22788: LD_ADDR_VAR 0 4
22792: PUSH
22793: LD_VAR 0 12
22797: PUSH
22798: LD_INT 1
22800: PPUSH
22801: LD_VAR 0 12
22805: PPUSH
22806: CALL_OW 12
22810: ARRAY
22811: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
22812: LD_VAR 0 2
22816: PPUSH
22817: LD_VAR 0 5
22821: PPUSH
22822: CALL 23180 0 2
22826: NOT
22827: IFFALSE 22886
// repeat weapon := _weapon [ 1 ] ;
22829: LD_ADDR_VAR 0 5
22833: PUSH
22834: LD_VAR 0 10
22838: PUSH
22839: LD_INT 1
22841: ARRAY
22842: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
22843: LD_ADDR_VAR 0 10
22847: PUSH
22848: LD_VAR 0 10
22852: PPUSH
22853: LD_INT 1
22855: PPUSH
22856: CALL_OW 3
22860: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
22861: LD_VAR 0 2
22865: PPUSH
22866: LD_VAR 0 5
22870: PPUSH
22871: CALL 23180 0 2
22875: PUSH
22876: LD_VAR 0 10
22880: PUSH
22881: EMPTY
22882: EQUAL
22883: OR
22884: IFFALSE 22829
// result := [ ] ;
22886: LD_ADDR_VAR 0 6
22890: PUSH
22891: EMPTY
22892: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
22893: LD_VAR 0 1
22897: PPUSH
22898: LD_VAR 0 2
22902: PPUSH
22903: LD_VAR 0 3
22907: PPUSH
22908: LD_VAR 0 4
22912: PPUSH
22913: LD_VAR 0 5
22917: PPUSH
22918: CALL_OW 448
22922: IFFALSE 22955
// result := [ chassis , engine , control , weapon ] ;
22924: LD_ADDR_VAR 0 6
22928: PUSH
22929: LD_VAR 0 2
22933: PUSH
22934: LD_VAR 0 3
22938: PUSH
22939: LD_VAR 0 4
22943: PUSH
22944: LD_VAR 0 5
22948: PUSH
22949: EMPTY
22950: LIST
22951: LIST
22952: LIST
22953: LIST
22954: ST_TO_ADDR
// end ;
22955: LD_VAR 0 6
22959: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
22960: LD_INT 0
22962: PPUSH
// if not chassis or not engine then
22963: LD_VAR 0 1
22967: NOT
22968: PUSH
22969: LD_VAR 0 2
22973: NOT
22974: OR
22975: IFFALSE 22979
// exit ;
22977: GO 23175
// case engine of engine_solar :
22979: LD_VAR 0 2
22983: PUSH
22984: LD_INT 2
22986: DOUBLE
22987: EQUAL
22988: IFTRUE 22992
22990: GO 23030
22992: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
22993: LD_ADDR_VAR 0 3
22997: PUSH
22998: LD_INT 11
23000: PUSH
23001: LD_INT 12
23003: PUSH
23004: LD_INT 13
23006: PUSH
23007: LD_INT 14
23009: PUSH
23010: LD_INT 1
23012: PUSH
23013: LD_INT 2
23015: PUSH
23016: LD_INT 3
23018: PUSH
23019: EMPTY
23020: LIST
23021: LIST
23022: LIST
23023: LIST
23024: LIST
23025: LIST
23026: LIST
23027: ST_TO_ADDR
23028: GO 23159
23030: LD_INT 1
23032: DOUBLE
23033: EQUAL
23034: IFTRUE 23038
23036: GO 23100
23038: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
23039: LD_ADDR_VAR 0 3
23043: PUSH
23044: LD_INT 11
23046: PUSH
23047: LD_INT 12
23049: PUSH
23050: LD_INT 13
23052: PUSH
23053: LD_INT 14
23055: PUSH
23056: LD_INT 1
23058: PUSH
23059: LD_INT 2
23061: PUSH
23062: LD_INT 3
23064: PUSH
23065: LD_INT 4
23067: PUSH
23068: LD_INT 5
23070: PUSH
23071: LD_INT 21
23073: PUSH
23074: LD_INT 23
23076: PUSH
23077: LD_INT 22
23079: PUSH
23080: LD_INT 24
23082: PUSH
23083: EMPTY
23084: LIST
23085: LIST
23086: LIST
23087: LIST
23088: LIST
23089: LIST
23090: LIST
23091: LIST
23092: LIST
23093: LIST
23094: LIST
23095: LIST
23096: LIST
23097: ST_TO_ADDR
23098: GO 23159
23100: LD_INT 3
23102: DOUBLE
23103: EQUAL
23104: IFTRUE 23108
23106: GO 23158
23108: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
23109: LD_ADDR_VAR 0 3
23113: PUSH
23114: LD_INT 13
23116: PUSH
23117: LD_INT 14
23119: PUSH
23120: LD_INT 2
23122: PUSH
23123: LD_INT 3
23125: PUSH
23126: LD_INT 4
23128: PUSH
23129: LD_INT 5
23131: PUSH
23132: LD_INT 21
23134: PUSH
23135: LD_INT 22
23137: PUSH
23138: LD_INT 23
23140: PUSH
23141: LD_INT 24
23143: PUSH
23144: EMPTY
23145: LIST
23146: LIST
23147: LIST
23148: LIST
23149: LIST
23150: LIST
23151: LIST
23152: LIST
23153: LIST
23154: LIST
23155: ST_TO_ADDR
23156: GO 23159
23158: POP
// result := ( chassis in result ) ;
23159: LD_ADDR_VAR 0 3
23163: PUSH
23164: LD_VAR 0 1
23168: PUSH
23169: LD_VAR 0 3
23173: IN
23174: ST_TO_ADDR
// end ;
23175: LD_VAR 0 3
23179: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
23180: LD_INT 0
23182: PPUSH
// if not chassis or not weapon then
23183: LD_VAR 0 1
23187: NOT
23188: PUSH
23189: LD_VAR 0 2
23193: NOT
23194: OR
23195: IFFALSE 23199
// exit ;
23197: GO 24259
// case weapon of us_machine_gun :
23199: LD_VAR 0 2
23203: PUSH
23204: LD_INT 2
23206: DOUBLE
23207: EQUAL
23208: IFTRUE 23212
23210: GO 23242
23212: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
23213: LD_ADDR_VAR 0 3
23217: PUSH
23218: LD_INT 1
23220: PUSH
23221: LD_INT 2
23223: PUSH
23224: LD_INT 3
23226: PUSH
23227: LD_INT 4
23229: PUSH
23230: LD_INT 5
23232: PUSH
23233: EMPTY
23234: LIST
23235: LIST
23236: LIST
23237: LIST
23238: LIST
23239: ST_TO_ADDR
23240: GO 24243
23242: LD_INT 3
23244: DOUBLE
23245: EQUAL
23246: IFTRUE 23250
23248: GO 23280
23250: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
23251: LD_ADDR_VAR 0 3
23255: PUSH
23256: LD_INT 1
23258: PUSH
23259: LD_INT 2
23261: PUSH
23262: LD_INT 3
23264: PUSH
23265: LD_INT 4
23267: PUSH
23268: LD_INT 5
23270: PUSH
23271: EMPTY
23272: LIST
23273: LIST
23274: LIST
23275: LIST
23276: LIST
23277: ST_TO_ADDR
23278: GO 24243
23280: LD_INT 11
23282: DOUBLE
23283: EQUAL
23284: IFTRUE 23288
23286: GO 23318
23288: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
23289: LD_ADDR_VAR 0 3
23293: PUSH
23294: LD_INT 1
23296: PUSH
23297: LD_INT 2
23299: PUSH
23300: LD_INT 3
23302: PUSH
23303: LD_INT 4
23305: PUSH
23306: LD_INT 5
23308: PUSH
23309: EMPTY
23310: LIST
23311: LIST
23312: LIST
23313: LIST
23314: LIST
23315: ST_TO_ADDR
23316: GO 24243
23318: LD_INT 4
23320: DOUBLE
23321: EQUAL
23322: IFTRUE 23326
23324: GO 23352
23326: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
23327: LD_ADDR_VAR 0 3
23331: PUSH
23332: LD_INT 2
23334: PUSH
23335: LD_INT 3
23337: PUSH
23338: LD_INT 4
23340: PUSH
23341: LD_INT 5
23343: PUSH
23344: EMPTY
23345: LIST
23346: LIST
23347: LIST
23348: LIST
23349: ST_TO_ADDR
23350: GO 24243
23352: LD_INT 5
23354: DOUBLE
23355: EQUAL
23356: IFTRUE 23360
23358: GO 23386
23360: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
23361: LD_ADDR_VAR 0 3
23365: PUSH
23366: LD_INT 2
23368: PUSH
23369: LD_INT 3
23371: PUSH
23372: LD_INT 4
23374: PUSH
23375: LD_INT 5
23377: PUSH
23378: EMPTY
23379: LIST
23380: LIST
23381: LIST
23382: LIST
23383: ST_TO_ADDR
23384: GO 24243
23386: LD_INT 9
23388: DOUBLE
23389: EQUAL
23390: IFTRUE 23394
23392: GO 23420
23394: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
23395: LD_ADDR_VAR 0 3
23399: PUSH
23400: LD_INT 2
23402: PUSH
23403: LD_INT 3
23405: PUSH
23406: LD_INT 4
23408: PUSH
23409: LD_INT 5
23411: PUSH
23412: EMPTY
23413: LIST
23414: LIST
23415: LIST
23416: LIST
23417: ST_TO_ADDR
23418: GO 24243
23420: LD_INT 7
23422: DOUBLE
23423: EQUAL
23424: IFTRUE 23428
23426: GO 23454
23428: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
23429: LD_ADDR_VAR 0 3
23433: PUSH
23434: LD_INT 2
23436: PUSH
23437: LD_INT 3
23439: PUSH
23440: LD_INT 4
23442: PUSH
23443: LD_INT 5
23445: PUSH
23446: EMPTY
23447: LIST
23448: LIST
23449: LIST
23450: LIST
23451: ST_TO_ADDR
23452: GO 24243
23454: LD_INT 12
23456: DOUBLE
23457: EQUAL
23458: IFTRUE 23462
23460: GO 23488
23462: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
23463: LD_ADDR_VAR 0 3
23467: PUSH
23468: LD_INT 2
23470: PUSH
23471: LD_INT 3
23473: PUSH
23474: LD_INT 4
23476: PUSH
23477: LD_INT 5
23479: PUSH
23480: EMPTY
23481: LIST
23482: LIST
23483: LIST
23484: LIST
23485: ST_TO_ADDR
23486: GO 24243
23488: LD_INT 13
23490: DOUBLE
23491: EQUAL
23492: IFTRUE 23496
23494: GO 23522
23496: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
23497: LD_ADDR_VAR 0 3
23501: PUSH
23502: LD_INT 2
23504: PUSH
23505: LD_INT 3
23507: PUSH
23508: LD_INT 4
23510: PUSH
23511: LD_INT 5
23513: PUSH
23514: EMPTY
23515: LIST
23516: LIST
23517: LIST
23518: LIST
23519: ST_TO_ADDR
23520: GO 24243
23522: LD_INT 14
23524: DOUBLE
23525: EQUAL
23526: IFTRUE 23530
23528: GO 23548
23530: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
23531: LD_ADDR_VAR 0 3
23535: PUSH
23536: LD_INT 4
23538: PUSH
23539: LD_INT 5
23541: PUSH
23542: EMPTY
23543: LIST
23544: LIST
23545: ST_TO_ADDR
23546: GO 24243
23548: LD_INT 6
23550: DOUBLE
23551: EQUAL
23552: IFTRUE 23556
23554: GO 23574
23556: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
23557: LD_ADDR_VAR 0 3
23561: PUSH
23562: LD_INT 4
23564: PUSH
23565: LD_INT 5
23567: PUSH
23568: EMPTY
23569: LIST
23570: LIST
23571: ST_TO_ADDR
23572: GO 24243
23574: LD_INT 10
23576: DOUBLE
23577: EQUAL
23578: IFTRUE 23582
23580: GO 23600
23582: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
23583: LD_ADDR_VAR 0 3
23587: PUSH
23588: LD_INT 4
23590: PUSH
23591: LD_INT 5
23593: PUSH
23594: EMPTY
23595: LIST
23596: LIST
23597: ST_TO_ADDR
23598: GO 24243
23600: LD_INT 22
23602: DOUBLE
23603: EQUAL
23604: IFTRUE 23608
23606: GO 23634
23608: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
23609: LD_ADDR_VAR 0 3
23613: PUSH
23614: LD_INT 11
23616: PUSH
23617: LD_INT 12
23619: PUSH
23620: LD_INT 13
23622: PUSH
23623: LD_INT 14
23625: PUSH
23626: EMPTY
23627: LIST
23628: LIST
23629: LIST
23630: LIST
23631: ST_TO_ADDR
23632: GO 24243
23634: LD_INT 23
23636: DOUBLE
23637: EQUAL
23638: IFTRUE 23642
23640: GO 23668
23642: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
23643: LD_ADDR_VAR 0 3
23647: PUSH
23648: LD_INT 11
23650: PUSH
23651: LD_INT 12
23653: PUSH
23654: LD_INT 13
23656: PUSH
23657: LD_INT 14
23659: PUSH
23660: EMPTY
23661: LIST
23662: LIST
23663: LIST
23664: LIST
23665: ST_TO_ADDR
23666: GO 24243
23668: LD_INT 24
23670: DOUBLE
23671: EQUAL
23672: IFTRUE 23676
23674: GO 23702
23676: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
23677: LD_ADDR_VAR 0 3
23681: PUSH
23682: LD_INT 11
23684: PUSH
23685: LD_INT 12
23687: PUSH
23688: LD_INT 13
23690: PUSH
23691: LD_INT 14
23693: PUSH
23694: EMPTY
23695: LIST
23696: LIST
23697: LIST
23698: LIST
23699: ST_TO_ADDR
23700: GO 24243
23702: LD_INT 30
23704: DOUBLE
23705: EQUAL
23706: IFTRUE 23710
23708: GO 23736
23710: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
23711: LD_ADDR_VAR 0 3
23715: PUSH
23716: LD_INT 11
23718: PUSH
23719: LD_INT 12
23721: PUSH
23722: LD_INT 13
23724: PUSH
23725: LD_INT 14
23727: PUSH
23728: EMPTY
23729: LIST
23730: LIST
23731: LIST
23732: LIST
23733: ST_TO_ADDR
23734: GO 24243
23736: LD_INT 25
23738: DOUBLE
23739: EQUAL
23740: IFTRUE 23744
23742: GO 23762
23744: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
23745: LD_ADDR_VAR 0 3
23749: PUSH
23750: LD_INT 13
23752: PUSH
23753: LD_INT 14
23755: PUSH
23756: EMPTY
23757: LIST
23758: LIST
23759: ST_TO_ADDR
23760: GO 24243
23762: LD_INT 27
23764: DOUBLE
23765: EQUAL
23766: IFTRUE 23770
23768: GO 23788
23770: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
23771: LD_ADDR_VAR 0 3
23775: PUSH
23776: LD_INT 13
23778: PUSH
23779: LD_INT 14
23781: PUSH
23782: EMPTY
23783: LIST
23784: LIST
23785: ST_TO_ADDR
23786: GO 24243
23788: LD_INT 92
23790: DOUBLE
23791: EQUAL
23792: IFTRUE 23796
23794: GO 23822
23796: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
23797: LD_ADDR_VAR 0 3
23801: PUSH
23802: LD_INT 11
23804: PUSH
23805: LD_INT 12
23807: PUSH
23808: LD_INT 13
23810: PUSH
23811: LD_INT 14
23813: PUSH
23814: EMPTY
23815: LIST
23816: LIST
23817: LIST
23818: LIST
23819: ST_TO_ADDR
23820: GO 24243
23822: LD_INT 28
23824: DOUBLE
23825: EQUAL
23826: IFTRUE 23830
23828: GO 23848
23830: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
23831: LD_ADDR_VAR 0 3
23835: PUSH
23836: LD_INT 13
23838: PUSH
23839: LD_INT 14
23841: PUSH
23842: EMPTY
23843: LIST
23844: LIST
23845: ST_TO_ADDR
23846: GO 24243
23848: LD_INT 29
23850: DOUBLE
23851: EQUAL
23852: IFTRUE 23856
23854: GO 23874
23856: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
23857: LD_ADDR_VAR 0 3
23861: PUSH
23862: LD_INT 13
23864: PUSH
23865: LD_INT 14
23867: PUSH
23868: EMPTY
23869: LIST
23870: LIST
23871: ST_TO_ADDR
23872: GO 24243
23874: LD_INT 31
23876: DOUBLE
23877: EQUAL
23878: IFTRUE 23882
23880: GO 23900
23882: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
23883: LD_ADDR_VAR 0 3
23887: PUSH
23888: LD_INT 13
23890: PUSH
23891: LD_INT 14
23893: PUSH
23894: EMPTY
23895: LIST
23896: LIST
23897: ST_TO_ADDR
23898: GO 24243
23900: LD_INT 26
23902: DOUBLE
23903: EQUAL
23904: IFTRUE 23908
23906: GO 23926
23908: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
23909: LD_ADDR_VAR 0 3
23913: PUSH
23914: LD_INT 13
23916: PUSH
23917: LD_INT 14
23919: PUSH
23920: EMPTY
23921: LIST
23922: LIST
23923: ST_TO_ADDR
23924: GO 24243
23926: LD_INT 42
23928: DOUBLE
23929: EQUAL
23930: IFTRUE 23934
23932: GO 23960
23934: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
23935: LD_ADDR_VAR 0 3
23939: PUSH
23940: LD_INT 21
23942: PUSH
23943: LD_INT 22
23945: PUSH
23946: LD_INT 23
23948: PUSH
23949: LD_INT 24
23951: PUSH
23952: EMPTY
23953: LIST
23954: LIST
23955: LIST
23956: LIST
23957: ST_TO_ADDR
23958: GO 24243
23960: LD_INT 43
23962: DOUBLE
23963: EQUAL
23964: IFTRUE 23968
23966: GO 23994
23968: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
23969: LD_ADDR_VAR 0 3
23973: PUSH
23974: LD_INT 21
23976: PUSH
23977: LD_INT 22
23979: PUSH
23980: LD_INT 23
23982: PUSH
23983: LD_INT 24
23985: PUSH
23986: EMPTY
23987: LIST
23988: LIST
23989: LIST
23990: LIST
23991: ST_TO_ADDR
23992: GO 24243
23994: LD_INT 44
23996: DOUBLE
23997: EQUAL
23998: IFTRUE 24002
24000: GO 24028
24002: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
24003: LD_ADDR_VAR 0 3
24007: PUSH
24008: LD_INT 21
24010: PUSH
24011: LD_INT 22
24013: PUSH
24014: LD_INT 23
24016: PUSH
24017: LD_INT 24
24019: PUSH
24020: EMPTY
24021: LIST
24022: LIST
24023: LIST
24024: LIST
24025: ST_TO_ADDR
24026: GO 24243
24028: LD_INT 45
24030: DOUBLE
24031: EQUAL
24032: IFTRUE 24036
24034: GO 24062
24036: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
24037: LD_ADDR_VAR 0 3
24041: PUSH
24042: LD_INT 21
24044: PUSH
24045: LD_INT 22
24047: PUSH
24048: LD_INT 23
24050: PUSH
24051: LD_INT 24
24053: PUSH
24054: EMPTY
24055: LIST
24056: LIST
24057: LIST
24058: LIST
24059: ST_TO_ADDR
24060: GO 24243
24062: LD_INT 49
24064: DOUBLE
24065: EQUAL
24066: IFTRUE 24070
24068: GO 24096
24070: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
24071: LD_ADDR_VAR 0 3
24075: PUSH
24076: LD_INT 21
24078: PUSH
24079: LD_INT 22
24081: PUSH
24082: LD_INT 23
24084: PUSH
24085: LD_INT 24
24087: PUSH
24088: EMPTY
24089: LIST
24090: LIST
24091: LIST
24092: LIST
24093: ST_TO_ADDR
24094: GO 24243
24096: LD_INT 51
24098: DOUBLE
24099: EQUAL
24100: IFTRUE 24104
24102: GO 24130
24104: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
24105: LD_ADDR_VAR 0 3
24109: PUSH
24110: LD_INT 21
24112: PUSH
24113: LD_INT 22
24115: PUSH
24116: LD_INT 23
24118: PUSH
24119: LD_INT 24
24121: PUSH
24122: EMPTY
24123: LIST
24124: LIST
24125: LIST
24126: LIST
24127: ST_TO_ADDR
24128: GO 24243
24130: LD_INT 52
24132: DOUBLE
24133: EQUAL
24134: IFTRUE 24138
24136: GO 24164
24138: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
24139: LD_ADDR_VAR 0 3
24143: PUSH
24144: LD_INT 21
24146: PUSH
24147: LD_INT 22
24149: PUSH
24150: LD_INT 23
24152: PUSH
24153: LD_INT 24
24155: PUSH
24156: EMPTY
24157: LIST
24158: LIST
24159: LIST
24160: LIST
24161: ST_TO_ADDR
24162: GO 24243
24164: LD_INT 53
24166: DOUBLE
24167: EQUAL
24168: IFTRUE 24172
24170: GO 24190
24172: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
24173: LD_ADDR_VAR 0 3
24177: PUSH
24178: LD_INT 23
24180: PUSH
24181: LD_INT 24
24183: PUSH
24184: EMPTY
24185: LIST
24186: LIST
24187: ST_TO_ADDR
24188: GO 24243
24190: LD_INT 46
24192: DOUBLE
24193: EQUAL
24194: IFTRUE 24198
24196: GO 24216
24198: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
24199: LD_ADDR_VAR 0 3
24203: PUSH
24204: LD_INT 23
24206: PUSH
24207: LD_INT 24
24209: PUSH
24210: EMPTY
24211: LIST
24212: LIST
24213: ST_TO_ADDR
24214: GO 24243
24216: LD_INT 47
24218: DOUBLE
24219: EQUAL
24220: IFTRUE 24224
24222: GO 24242
24224: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
24225: LD_ADDR_VAR 0 3
24229: PUSH
24230: LD_INT 23
24232: PUSH
24233: LD_INT 24
24235: PUSH
24236: EMPTY
24237: LIST
24238: LIST
24239: ST_TO_ADDR
24240: GO 24243
24242: POP
// result := ( chassis in result ) ;
24243: LD_ADDR_VAR 0 3
24247: PUSH
24248: LD_VAR 0 1
24252: PUSH
24253: LD_VAR 0 3
24257: IN
24258: ST_TO_ADDR
// end ;
24259: LD_VAR 0 3
24263: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
24264: LD_INT 0
24266: PPUSH
24267: PPUSH
24268: PPUSH
24269: PPUSH
24270: PPUSH
24271: PPUSH
24272: PPUSH
// result := array ;
24273: LD_ADDR_VAR 0 5
24277: PUSH
24278: LD_VAR 0 1
24282: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
24283: LD_VAR 0 1
24287: NOT
24288: PUSH
24289: LD_VAR 0 2
24293: NOT
24294: OR
24295: PUSH
24296: LD_VAR 0 3
24300: NOT
24301: OR
24302: PUSH
24303: LD_VAR 0 2
24307: PUSH
24308: LD_VAR 0 1
24312: GREATER
24313: OR
24314: PUSH
24315: LD_VAR 0 3
24319: PUSH
24320: LD_VAR 0 1
24324: GREATER
24325: OR
24326: IFFALSE 24330
// exit ;
24328: GO 24626
// if direction then
24330: LD_VAR 0 4
24334: IFFALSE 24398
// begin d := 1 ;
24336: LD_ADDR_VAR 0 9
24340: PUSH
24341: LD_INT 1
24343: ST_TO_ADDR
// if i_from > i_to then
24344: LD_VAR 0 2
24348: PUSH
24349: LD_VAR 0 3
24353: GREATER
24354: IFFALSE 24380
// length := ( array - i_from ) + i_to else
24356: LD_ADDR_VAR 0 11
24360: PUSH
24361: LD_VAR 0 1
24365: PUSH
24366: LD_VAR 0 2
24370: MINUS
24371: PUSH
24372: LD_VAR 0 3
24376: PLUS
24377: ST_TO_ADDR
24378: GO 24396
// length := i_to - i_from ;
24380: LD_ADDR_VAR 0 11
24384: PUSH
24385: LD_VAR 0 3
24389: PUSH
24390: LD_VAR 0 2
24394: MINUS
24395: ST_TO_ADDR
// end else
24396: GO 24459
// begin d := - 1 ;
24398: LD_ADDR_VAR 0 9
24402: PUSH
24403: LD_INT 1
24405: NEG
24406: ST_TO_ADDR
// if i_from > i_to then
24407: LD_VAR 0 2
24411: PUSH
24412: LD_VAR 0 3
24416: GREATER
24417: IFFALSE 24437
// length := i_from - i_to else
24419: LD_ADDR_VAR 0 11
24423: PUSH
24424: LD_VAR 0 2
24428: PUSH
24429: LD_VAR 0 3
24433: MINUS
24434: ST_TO_ADDR
24435: GO 24459
// length := ( array - i_to ) + i_from ;
24437: LD_ADDR_VAR 0 11
24441: PUSH
24442: LD_VAR 0 1
24446: PUSH
24447: LD_VAR 0 3
24451: MINUS
24452: PUSH
24453: LD_VAR 0 2
24457: PLUS
24458: ST_TO_ADDR
// end ; if not length then
24459: LD_VAR 0 11
24463: NOT
24464: IFFALSE 24468
// exit ;
24466: GO 24626
// tmp := array ;
24468: LD_ADDR_VAR 0 10
24472: PUSH
24473: LD_VAR 0 1
24477: ST_TO_ADDR
// for i = 1 to length do
24478: LD_ADDR_VAR 0 6
24482: PUSH
24483: DOUBLE
24484: LD_INT 1
24486: DEC
24487: ST_TO_ADDR
24488: LD_VAR 0 11
24492: PUSH
24493: FOR_TO
24494: IFFALSE 24614
// begin for j = 1 to array do
24496: LD_ADDR_VAR 0 7
24500: PUSH
24501: DOUBLE
24502: LD_INT 1
24504: DEC
24505: ST_TO_ADDR
24506: LD_VAR 0 1
24510: PUSH
24511: FOR_TO
24512: IFFALSE 24600
// begin k := j + d ;
24514: LD_ADDR_VAR 0 8
24518: PUSH
24519: LD_VAR 0 7
24523: PUSH
24524: LD_VAR 0 9
24528: PLUS
24529: ST_TO_ADDR
// if k > array then
24530: LD_VAR 0 8
24534: PUSH
24535: LD_VAR 0 1
24539: GREATER
24540: IFFALSE 24550
// k := 1 ;
24542: LD_ADDR_VAR 0 8
24546: PUSH
24547: LD_INT 1
24549: ST_TO_ADDR
// if not k then
24550: LD_VAR 0 8
24554: NOT
24555: IFFALSE 24567
// k := array ;
24557: LD_ADDR_VAR 0 8
24561: PUSH
24562: LD_VAR 0 1
24566: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
24567: LD_ADDR_VAR 0 10
24571: PUSH
24572: LD_VAR 0 10
24576: PPUSH
24577: LD_VAR 0 8
24581: PPUSH
24582: LD_VAR 0 1
24586: PUSH
24587: LD_VAR 0 7
24591: ARRAY
24592: PPUSH
24593: CALL_OW 1
24597: ST_TO_ADDR
// end ;
24598: GO 24511
24600: POP
24601: POP
// array := tmp ;
24602: LD_ADDR_VAR 0 1
24606: PUSH
24607: LD_VAR 0 10
24611: ST_TO_ADDR
// end ;
24612: GO 24493
24614: POP
24615: POP
// result := array ;
24616: LD_ADDR_VAR 0 5
24620: PUSH
24621: LD_VAR 0 1
24625: ST_TO_ADDR
// end ;
24626: LD_VAR 0 5
24630: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
24631: LD_INT 0
24633: PPUSH
24634: PPUSH
// result := 0 ;
24635: LD_ADDR_VAR 0 3
24639: PUSH
24640: LD_INT 0
24642: ST_TO_ADDR
// if not array or not value in array then
24643: LD_VAR 0 1
24647: NOT
24648: PUSH
24649: LD_VAR 0 2
24653: PUSH
24654: LD_VAR 0 1
24658: IN
24659: NOT
24660: OR
24661: IFFALSE 24665
// exit ;
24663: GO 24719
// for i = 1 to array do
24665: LD_ADDR_VAR 0 4
24669: PUSH
24670: DOUBLE
24671: LD_INT 1
24673: DEC
24674: ST_TO_ADDR
24675: LD_VAR 0 1
24679: PUSH
24680: FOR_TO
24681: IFFALSE 24717
// if value = array [ i ] then
24683: LD_VAR 0 2
24687: PUSH
24688: LD_VAR 0 1
24692: PUSH
24693: LD_VAR 0 4
24697: ARRAY
24698: EQUAL
24699: IFFALSE 24715
// begin result := i ;
24701: LD_ADDR_VAR 0 3
24705: PUSH
24706: LD_VAR 0 4
24710: ST_TO_ADDR
// exit ;
24711: POP
24712: POP
24713: GO 24719
// end ;
24715: GO 24680
24717: POP
24718: POP
// end ;
24719: LD_VAR 0 3
24723: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
24724: LD_INT 0
24726: PPUSH
// vc_chassis := chassis ;
24727: LD_ADDR_OWVAR 37
24731: PUSH
24732: LD_VAR 0 1
24736: ST_TO_ADDR
// vc_engine := engine ;
24737: LD_ADDR_OWVAR 39
24741: PUSH
24742: LD_VAR 0 2
24746: ST_TO_ADDR
// vc_control := control ;
24747: LD_ADDR_OWVAR 38
24751: PUSH
24752: LD_VAR 0 3
24756: ST_TO_ADDR
// vc_weapon := weapon ;
24757: LD_ADDR_OWVAR 40
24761: PUSH
24762: LD_VAR 0 4
24766: ST_TO_ADDR
// vc_fuel_battery := fuel ;
24767: LD_ADDR_OWVAR 41
24771: PUSH
24772: LD_VAR 0 5
24776: ST_TO_ADDR
// end ;
24777: LD_VAR 0 6
24781: RET
// export function WantPlant ( unit ) ; var task ; begin
24782: LD_INT 0
24784: PPUSH
24785: PPUSH
// result := false ;
24786: LD_ADDR_VAR 0 2
24790: PUSH
24791: LD_INT 0
24793: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
24794: LD_ADDR_VAR 0 3
24798: PUSH
24799: LD_VAR 0 1
24803: PPUSH
24804: CALL_OW 437
24808: ST_TO_ADDR
// if task then
24809: LD_VAR 0 3
24813: IFFALSE 24841
// if task [ 1 ] [ 1 ] = p then
24815: LD_VAR 0 3
24819: PUSH
24820: LD_INT 1
24822: ARRAY
24823: PUSH
24824: LD_INT 1
24826: ARRAY
24827: PUSH
24828: LD_STRING p
24830: EQUAL
24831: IFFALSE 24841
// result := true ;
24833: LD_ADDR_VAR 0 2
24837: PUSH
24838: LD_INT 1
24840: ST_TO_ADDR
// end ;
24841: LD_VAR 0 2
24845: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
24846: LD_INT 0
24848: PPUSH
24849: PPUSH
24850: PPUSH
24851: PPUSH
// if pos < 1 then
24852: LD_VAR 0 2
24856: PUSH
24857: LD_INT 1
24859: LESS
24860: IFFALSE 24864
// exit ;
24862: GO 25167
// if pos = 1 then
24864: LD_VAR 0 2
24868: PUSH
24869: LD_INT 1
24871: EQUAL
24872: IFFALSE 24905
// result := Replace ( arr , pos [ 1 ] , value ) else
24874: LD_ADDR_VAR 0 4
24878: PUSH
24879: LD_VAR 0 1
24883: PPUSH
24884: LD_VAR 0 2
24888: PUSH
24889: LD_INT 1
24891: ARRAY
24892: PPUSH
24893: LD_VAR 0 3
24897: PPUSH
24898: CALL_OW 1
24902: ST_TO_ADDR
24903: GO 25167
// begin tmp := arr ;
24905: LD_ADDR_VAR 0 6
24909: PUSH
24910: LD_VAR 0 1
24914: ST_TO_ADDR
// s_arr := [ tmp ] ;
24915: LD_ADDR_VAR 0 7
24919: PUSH
24920: LD_VAR 0 6
24924: PUSH
24925: EMPTY
24926: LIST
24927: ST_TO_ADDR
// for i = 1 to pos - 1 do
24928: LD_ADDR_VAR 0 5
24932: PUSH
24933: DOUBLE
24934: LD_INT 1
24936: DEC
24937: ST_TO_ADDR
24938: LD_VAR 0 2
24942: PUSH
24943: LD_INT 1
24945: MINUS
24946: PUSH
24947: FOR_TO
24948: IFFALSE 24993
// begin tmp := tmp [ pos [ i ] ] ;
24950: LD_ADDR_VAR 0 6
24954: PUSH
24955: LD_VAR 0 6
24959: PUSH
24960: LD_VAR 0 2
24964: PUSH
24965: LD_VAR 0 5
24969: ARRAY
24970: ARRAY
24971: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
24972: LD_ADDR_VAR 0 7
24976: PUSH
24977: LD_VAR 0 7
24981: PUSH
24982: LD_VAR 0 6
24986: PUSH
24987: EMPTY
24988: LIST
24989: ADD
24990: ST_TO_ADDR
// end ;
24991: GO 24947
24993: POP
24994: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
24995: LD_ADDR_VAR 0 6
24999: PUSH
25000: LD_VAR 0 6
25004: PPUSH
25005: LD_VAR 0 2
25009: PUSH
25010: LD_VAR 0 2
25014: ARRAY
25015: PPUSH
25016: LD_VAR 0 3
25020: PPUSH
25021: CALL_OW 1
25025: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
25026: LD_ADDR_VAR 0 7
25030: PUSH
25031: LD_VAR 0 7
25035: PPUSH
25036: LD_VAR 0 7
25040: PPUSH
25041: LD_VAR 0 6
25045: PPUSH
25046: CALL_OW 1
25050: ST_TO_ADDR
// for i = s_arr downto 2 do
25051: LD_ADDR_VAR 0 5
25055: PUSH
25056: DOUBLE
25057: LD_VAR 0 7
25061: INC
25062: ST_TO_ADDR
25063: LD_INT 2
25065: PUSH
25066: FOR_DOWNTO
25067: IFFALSE 25151
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
25069: LD_ADDR_VAR 0 6
25073: PUSH
25074: LD_VAR 0 7
25078: PUSH
25079: LD_VAR 0 5
25083: PUSH
25084: LD_INT 1
25086: MINUS
25087: ARRAY
25088: PPUSH
25089: LD_VAR 0 2
25093: PUSH
25094: LD_VAR 0 5
25098: PUSH
25099: LD_INT 1
25101: MINUS
25102: ARRAY
25103: PPUSH
25104: LD_VAR 0 7
25108: PUSH
25109: LD_VAR 0 5
25113: ARRAY
25114: PPUSH
25115: CALL_OW 1
25119: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
25120: LD_ADDR_VAR 0 7
25124: PUSH
25125: LD_VAR 0 7
25129: PPUSH
25130: LD_VAR 0 5
25134: PUSH
25135: LD_INT 1
25137: MINUS
25138: PPUSH
25139: LD_VAR 0 6
25143: PPUSH
25144: CALL_OW 1
25148: ST_TO_ADDR
// end ;
25149: GO 25066
25151: POP
25152: POP
// result := s_arr [ 1 ] ;
25153: LD_ADDR_VAR 0 4
25157: PUSH
25158: LD_VAR 0 7
25162: PUSH
25163: LD_INT 1
25165: ARRAY
25166: ST_TO_ADDR
// end ; end ;
25167: LD_VAR 0 4
25171: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
25172: LD_INT 0
25174: PPUSH
25175: PPUSH
// if not list then
25176: LD_VAR 0 1
25180: NOT
25181: IFFALSE 25185
// exit ;
25183: GO 25276
// i := list [ pos1 ] ;
25185: LD_ADDR_VAR 0 5
25189: PUSH
25190: LD_VAR 0 1
25194: PUSH
25195: LD_VAR 0 2
25199: ARRAY
25200: ST_TO_ADDR
// if not i then
25201: LD_VAR 0 5
25205: NOT
25206: IFFALSE 25210
// exit ;
25208: GO 25276
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
25210: LD_ADDR_VAR 0 1
25214: PUSH
25215: LD_VAR 0 1
25219: PPUSH
25220: LD_VAR 0 2
25224: PPUSH
25225: LD_VAR 0 1
25229: PUSH
25230: LD_VAR 0 3
25234: ARRAY
25235: PPUSH
25236: CALL_OW 1
25240: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
25241: LD_ADDR_VAR 0 1
25245: PUSH
25246: LD_VAR 0 1
25250: PPUSH
25251: LD_VAR 0 3
25255: PPUSH
25256: LD_VAR 0 5
25260: PPUSH
25261: CALL_OW 1
25265: ST_TO_ADDR
// result := list ;
25266: LD_ADDR_VAR 0 4
25270: PUSH
25271: LD_VAR 0 1
25275: ST_TO_ADDR
// end ;
25276: LD_VAR 0 4
25280: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
25281: LD_INT 0
25283: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
25284: LD_ADDR_VAR 0 5
25288: PUSH
25289: LD_VAR 0 1
25293: PPUSH
25294: CALL_OW 250
25298: PPUSH
25299: LD_VAR 0 1
25303: PPUSH
25304: CALL_OW 251
25308: PPUSH
25309: LD_VAR 0 2
25313: PPUSH
25314: LD_VAR 0 3
25318: PPUSH
25319: LD_VAR 0 4
25323: PPUSH
25324: CALL 25334 0 5
25328: ST_TO_ADDR
// end ;
25329: LD_VAR 0 5
25333: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
25334: LD_INT 0
25336: PPUSH
25337: PPUSH
25338: PPUSH
25339: PPUSH
// if not list then
25340: LD_VAR 0 3
25344: NOT
25345: IFFALSE 25349
// exit ;
25347: GO 25737
// result := [ ] ;
25349: LD_ADDR_VAR 0 6
25353: PUSH
25354: EMPTY
25355: ST_TO_ADDR
// for i in list do
25356: LD_ADDR_VAR 0 7
25360: PUSH
25361: LD_VAR 0 3
25365: PUSH
25366: FOR_IN
25367: IFFALSE 25569
// begin tmp := GetDistUnitXY ( i , x , y ) ;
25369: LD_ADDR_VAR 0 9
25373: PUSH
25374: LD_VAR 0 7
25378: PPUSH
25379: LD_VAR 0 1
25383: PPUSH
25384: LD_VAR 0 2
25388: PPUSH
25389: CALL_OW 297
25393: ST_TO_ADDR
// if not result then
25394: LD_VAR 0 6
25398: NOT
25399: IFFALSE 25425
// result := [ [ i , tmp ] ] else
25401: LD_ADDR_VAR 0 6
25405: PUSH
25406: LD_VAR 0 7
25410: PUSH
25411: LD_VAR 0 9
25415: PUSH
25416: EMPTY
25417: LIST
25418: LIST
25419: PUSH
25420: EMPTY
25421: LIST
25422: ST_TO_ADDR
25423: GO 25567
// begin if result [ result ] [ 2 ] < tmp then
25425: LD_VAR 0 6
25429: PUSH
25430: LD_VAR 0 6
25434: ARRAY
25435: PUSH
25436: LD_INT 2
25438: ARRAY
25439: PUSH
25440: LD_VAR 0 9
25444: LESS
25445: IFFALSE 25487
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
25447: LD_ADDR_VAR 0 6
25451: PUSH
25452: LD_VAR 0 6
25456: PPUSH
25457: LD_VAR 0 6
25461: PUSH
25462: LD_INT 1
25464: PLUS
25465: PPUSH
25466: LD_VAR 0 7
25470: PUSH
25471: LD_VAR 0 9
25475: PUSH
25476: EMPTY
25477: LIST
25478: LIST
25479: PPUSH
25480: CALL_OW 2
25484: ST_TO_ADDR
25485: GO 25567
// for j = 1 to result do
25487: LD_ADDR_VAR 0 8
25491: PUSH
25492: DOUBLE
25493: LD_INT 1
25495: DEC
25496: ST_TO_ADDR
25497: LD_VAR 0 6
25501: PUSH
25502: FOR_TO
25503: IFFALSE 25565
// begin if tmp < result [ j ] [ 2 ] then
25505: LD_VAR 0 9
25509: PUSH
25510: LD_VAR 0 6
25514: PUSH
25515: LD_VAR 0 8
25519: ARRAY
25520: PUSH
25521: LD_INT 2
25523: ARRAY
25524: LESS
25525: IFFALSE 25563
// begin result := Insert ( result , j , [ i , tmp ] ) ;
25527: LD_ADDR_VAR 0 6
25531: PUSH
25532: LD_VAR 0 6
25536: PPUSH
25537: LD_VAR 0 8
25541: PPUSH
25542: LD_VAR 0 7
25546: PUSH
25547: LD_VAR 0 9
25551: PUSH
25552: EMPTY
25553: LIST
25554: LIST
25555: PPUSH
25556: CALL_OW 2
25560: ST_TO_ADDR
// break ;
25561: GO 25565
// end ; end ;
25563: GO 25502
25565: POP
25566: POP
// end ; end ;
25567: GO 25366
25569: POP
25570: POP
// if result and not asc then
25571: LD_VAR 0 6
25575: PUSH
25576: LD_VAR 0 4
25580: NOT
25581: AND
25582: IFFALSE 25657
// begin tmp := result ;
25584: LD_ADDR_VAR 0 9
25588: PUSH
25589: LD_VAR 0 6
25593: ST_TO_ADDR
// for i = tmp downto 1 do
25594: LD_ADDR_VAR 0 7
25598: PUSH
25599: DOUBLE
25600: LD_VAR 0 9
25604: INC
25605: ST_TO_ADDR
25606: LD_INT 1
25608: PUSH
25609: FOR_DOWNTO
25610: IFFALSE 25655
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
25612: LD_ADDR_VAR 0 6
25616: PUSH
25617: LD_VAR 0 6
25621: PPUSH
25622: LD_VAR 0 9
25626: PUSH
25627: LD_VAR 0 7
25631: MINUS
25632: PUSH
25633: LD_INT 1
25635: PLUS
25636: PPUSH
25637: LD_VAR 0 9
25641: PUSH
25642: LD_VAR 0 7
25646: ARRAY
25647: PPUSH
25648: CALL_OW 1
25652: ST_TO_ADDR
25653: GO 25609
25655: POP
25656: POP
// end ; tmp := [ ] ;
25657: LD_ADDR_VAR 0 9
25661: PUSH
25662: EMPTY
25663: ST_TO_ADDR
// if mode then
25664: LD_VAR 0 5
25668: IFFALSE 25737
// begin for i = 1 to result do
25670: LD_ADDR_VAR 0 7
25674: PUSH
25675: DOUBLE
25676: LD_INT 1
25678: DEC
25679: ST_TO_ADDR
25680: LD_VAR 0 6
25684: PUSH
25685: FOR_TO
25686: IFFALSE 25725
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
25688: LD_ADDR_VAR 0 9
25692: PUSH
25693: LD_VAR 0 9
25697: PPUSH
25698: LD_VAR 0 7
25702: PPUSH
25703: LD_VAR 0 6
25707: PUSH
25708: LD_VAR 0 7
25712: ARRAY
25713: PUSH
25714: LD_INT 1
25716: ARRAY
25717: PPUSH
25718: CALL_OW 1
25722: ST_TO_ADDR
25723: GO 25685
25725: POP
25726: POP
// result := tmp ;
25727: LD_ADDR_VAR 0 6
25731: PUSH
25732: LD_VAR 0 9
25736: ST_TO_ADDR
// end ; end ;
25737: LD_VAR 0 6
25741: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
25742: LD_INT 0
25744: PPUSH
25745: PPUSH
25746: PPUSH
25747: PPUSH
25748: PPUSH
25749: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
25750: LD_ADDR_VAR 0 5
25754: PUSH
25755: LD_INT 0
25757: PUSH
25758: LD_INT 0
25760: PUSH
25761: LD_INT 0
25763: PUSH
25764: EMPTY
25765: PUSH
25766: EMPTY
25767: LIST
25768: LIST
25769: LIST
25770: LIST
25771: ST_TO_ADDR
// if not x or not y then
25772: LD_VAR 0 2
25776: NOT
25777: PUSH
25778: LD_VAR 0 3
25782: NOT
25783: OR
25784: IFFALSE 25788
// exit ;
25786: GO 27438
// if not range then
25788: LD_VAR 0 4
25792: NOT
25793: IFFALSE 25803
// range := 10 ;
25795: LD_ADDR_VAR 0 4
25799: PUSH
25800: LD_INT 10
25802: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
25803: LD_ADDR_VAR 0 8
25807: PUSH
25808: LD_INT 81
25810: PUSH
25811: LD_VAR 0 1
25815: PUSH
25816: EMPTY
25817: LIST
25818: LIST
25819: PUSH
25820: LD_INT 92
25822: PUSH
25823: LD_VAR 0 2
25827: PUSH
25828: LD_VAR 0 3
25832: PUSH
25833: LD_VAR 0 4
25837: PUSH
25838: EMPTY
25839: LIST
25840: LIST
25841: LIST
25842: LIST
25843: PUSH
25844: LD_INT 3
25846: PUSH
25847: LD_INT 21
25849: PUSH
25850: LD_INT 3
25852: PUSH
25853: EMPTY
25854: LIST
25855: LIST
25856: PUSH
25857: EMPTY
25858: LIST
25859: LIST
25860: PUSH
25861: EMPTY
25862: LIST
25863: LIST
25864: LIST
25865: PPUSH
25866: CALL_OW 69
25870: ST_TO_ADDR
// if not tmp then
25871: LD_VAR 0 8
25875: NOT
25876: IFFALSE 25880
// exit ;
25878: GO 27438
// for i in tmp do
25880: LD_ADDR_VAR 0 6
25884: PUSH
25885: LD_VAR 0 8
25889: PUSH
25890: FOR_IN
25891: IFFALSE 27413
// begin points := [ 0 , 0 , 0 ] ;
25893: LD_ADDR_VAR 0 9
25897: PUSH
25898: LD_INT 0
25900: PUSH
25901: LD_INT 0
25903: PUSH
25904: LD_INT 0
25906: PUSH
25907: EMPTY
25908: LIST
25909: LIST
25910: LIST
25911: ST_TO_ADDR
// bpoints := 1 ;
25912: LD_ADDR_VAR 0 10
25916: PUSH
25917: LD_INT 1
25919: ST_TO_ADDR
// case GetType ( i ) of unit_human :
25920: LD_VAR 0 6
25924: PPUSH
25925: CALL_OW 247
25929: PUSH
25930: LD_INT 1
25932: DOUBLE
25933: EQUAL
25934: IFTRUE 25938
25936: GO 26516
25938: POP
// begin if GetClass ( i ) = 1 then
25939: LD_VAR 0 6
25943: PPUSH
25944: CALL_OW 257
25948: PUSH
25949: LD_INT 1
25951: EQUAL
25952: IFFALSE 25973
// points := [ 10 , 5 , 3 ] ;
25954: LD_ADDR_VAR 0 9
25958: PUSH
25959: LD_INT 10
25961: PUSH
25962: LD_INT 5
25964: PUSH
25965: LD_INT 3
25967: PUSH
25968: EMPTY
25969: LIST
25970: LIST
25971: LIST
25972: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
25973: LD_VAR 0 6
25977: PPUSH
25978: CALL_OW 257
25982: PUSH
25983: LD_INT 2
25985: PUSH
25986: LD_INT 3
25988: PUSH
25989: LD_INT 4
25991: PUSH
25992: EMPTY
25993: LIST
25994: LIST
25995: LIST
25996: IN
25997: IFFALSE 26018
// points := [ 3 , 2 , 1 ] ;
25999: LD_ADDR_VAR 0 9
26003: PUSH
26004: LD_INT 3
26006: PUSH
26007: LD_INT 2
26009: PUSH
26010: LD_INT 1
26012: PUSH
26013: EMPTY
26014: LIST
26015: LIST
26016: LIST
26017: ST_TO_ADDR
// if GetClass ( i ) = 5 then
26018: LD_VAR 0 6
26022: PPUSH
26023: CALL_OW 257
26027: PUSH
26028: LD_INT 5
26030: EQUAL
26031: IFFALSE 26052
// points := [ 130 , 5 , 2 ] ;
26033: LD_ADDR_VAR 0 9
26037: PUSH
26038: LD_INT 130
26040: PUSH
26041: LD_INT 5
26043: PUSH
26044: LD_INT 2
26046: PUSH
26047: EMPTY
26048: LIST
26049: LIST
26050: LIST
26051: ST_TO_ADDR
// if GetClass ( i ) = 8 then
26052: LD_VAR 0 6
26056: PPUSH
26057: CALL_OW 257
26061: PUSH
26062: LD_INT 8
26064: EQUAL
26065: IFFALSE 26086
// points := [ 35 , 35 , 30 ] ;
26067: LD_ADDR_VAR 0 9
26071: PUSH
26072: LD_INT 35
26074: PUSH
26075: LD_INT 35
26077: PUSH
26078: LD_INT 30
26080: PUSH
26081: EMPTY
26082: LIST
26083: LIST
26084: LIST
26085: ST_TO_ADDR
// if GetClass ( i ) = 9 then
26086: LD_VAR 0 6
26090: PPUSH
26091: CALL_OW 257
26095: PUSH
26096: LD_INT 9
26098: EQUAL
26099: IFFALSE 26120
// points := [ 20 , 55 , 40 ] ;
26101: LD_ADDR_VAR 0 9
26105: PUSH
26106: LD_INT 20
26108: PUSH
26109: LD_INT 55
26111: PUSH
26112: LD_INT 40
26114: PUSH
26115: EMPTY
26116: LIST
26117: LIST
26118: LIST
26119: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
26120: LD_VAR 0 6
26124: PPUSH
26125: CALL_OW 257
26129: PUSH
26130: LD_INT 12
26132: PUSH
26133: LD_INT 16
26135: PUSH
26136: EMPTY
26137: LIST
26138: LIST
26139: IN
26140: IFFALSE 26161
// points := [ 5 , 3 , 2 ] ;
26142: LD_ADDR_VAR 0 9
26146: PUSH
26147: LD_INT 5
26149: PUSH
26150: LD_INT 3
26152: PUSH
26153: LD_INT 2
26155: PUSH
26156: EMPTY
26157: LIST
26158: LIST
26159: LIST
26160: ST_TO_ADDR
// if GetClass ( i ) = 17 then
26161: LD_VAR 0 6
26165: PPUSH
26166: CALL_OW 257
26170: PUSH
26171: LD_INT 17
26173: EQUAL
26174: IFFALSE 26195
// points := [ 100 , 50 , 75 ] ;
26176: LD_ADDR_VAR 0 9
26180: PUSH
26181: LD_INT 100
26183: PUSH
26184: LD_INT 50
26186: PUSH
26187: LD_INT 75
26189: PUSH
26190: EMPTY
26191: LIST
26192: LIST
26193: LIST
26194: ST_TO_ADDR
// if GetClass ( i ) = 15 then
26195: LD_VAR 0 6
26199: PPUSH
26200: CALL_OW 257
26204: PUSH
26205: LD_INT 15
26207: EQUAL
26208: IFFALSE 26229
// points := [ 10 , 5 , 3 ] ;
26210: LD_ADDR_VAR 0 9
26214: PUSH
26215: LD_INT 10
26217: PUSH
26218: LD_INT 5
26220: PUSH
26221: LD_INT 3
26223: PUSH
26224: EMPTY
26225: LIST
26226: LIST
26227: LIST
26228: ST_TO_ADDR
// if GetClass ( i ) = 14 then
26229: LD_VAR 0 6
26233: PPUSH
26234: CALL_OW 257
26238: PUSH
26239: LD_INT 14
26241: EQUAL
26242: IFFALSE 26263
// points := [ 10 , 0 , 0 ] ;
26244: LD_ADDR_VAR 0 9
26248: PUSH
26249: LD_INT 10
26251: PUSH
26252: LD_INT 0
26254: PUSH
26255: LD_INT 0
26257: PUSH
26258: EMPTY
26259: LIST
26260: LIST
26261: LIST
26262: ST_TO_ADDR
// if GetClass ( i ) = 11 then
26263: LD_VAR 0 6
26267: PPUSH
26268: CALL_OW 257
26272: PUSH
26273: LD_INT 11
26275: EQUAL
26276: IFFALSE 26297
// points := [ 30 , 10 , 5 ] ;
26278: LD_ADDR_VAR 0 9
26282: PUSH
26283: LD_INT 30
26285: PUSH
26286: LD_INT 10
26288: PUSH
26289: LD_INT 5
26291: PUSH
26292: EMPTY
26293: LIST
26294: LIST
26295: LIST
26296: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
26297: LD_VAR 0 1
26301: PPUSH
26302: LD_INT 5
26304: PPUSH
26305: CALL_OW 321
26309: PUSH
26310: LD_INT 2
26312: EQUAL
26313: IFFALSE 26330
// bpoints := bpoints * 1.8 ;
26315: LD_ADDR_VAR 0 10
26319: PUSH
26320: LD_VAR 0 10
26324: PUSH
26325: LD_REAL  1.80000000000000E+0000
26328: MUL
26329: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
26330: LD_VAR 0 6
26334: PPUSH
26335: CALL_OW 257
26339: PUSH
26340: LD_INT 1
26342: PUSH
26343: LD_INT 2
26345: PUSH
26346: LD_INT 3
26348: PUSH
26349: LD_INT 4
26351: PUSH
26352: EMPTY
26353: LIST
26354: LIST
26355: LIST
26356: LIST
26357: IN
26358: PUSH
26359: LD_VAR 0 1
26363: PPUSH
26364: LD_INT 51
26366: PPUSH
26367: CALL_OW 321
26371: PUSH
26372: LD_INT 2
26374: EQUAL
26375: AND
26376: IFFALSE 26393
// bpoints := bpoints * 1.2 ;
26378: LD_ADDR_VAR 0 10
26382: PUSH
26383: LD_VAR 0 10
26387: PUSH
26388: LD_REAL  1.20000000000000E+0000
26391: MUL
26392: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
26393: LD_VAR 0 6
26397: PPUSH
26398: CALL_OW 257
26402: PUSH
26403: LD_INT 5
26405: PUSH
26406: LD_INT 7
26408: PUSH
26409: LD_INT 9
26411: PUSH
26412: EMPTY
26413: LIST
26414: LIST
26415: LIST
26416: IN
26417: PUSH
26418: LD_VAR 0 1
26422: PPUSH
26423: LD_INT 52
26425: PPUSH
26426: CALL_OW 321
26430: PUSH
26431: LD_INT 2
26433: EQUAL
26434: AND
26435: IFFALSE 26452
// bpoints := bpoints * 1.5 ;
26437: LD_ADDR_VAR 0 10
26441: PUSH
26442: LD_VAR 0 10
26446: PUSH
26447: LD_REAL  1.50000000000000E+0000
26450: MUL
26451: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
26452: LD_VAR 0 1
26456: PPUSH
26457: LD_INT 66
26459: PPUSH
26460: CALL_OW 321
26464: PUSH
26465: LD_INT 2
26467: EQUAL
26468: IFFALSE 26485
// bpoints := bpoints * 1.1 ;
26470: LD_ADDR_VAR 0 10
26474: PUSH
26475: LD_VAR 0 10
26479: PUSH
26480: LD_REAL  1.10000000000000E+0000
26483: MUL
26484: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
26485: LD_ADDR_VAR 0 10
26489: PUSH
26490: LD_VAR 0 10
26494: PUSH
26495: LD_VAR 0 6
26499: PPUSH
26500: LD_INT 1
26502: PPUSH
26503: CALL_OW 259
26507: PUSH
26508: LD_REAL  1.15000000000000E+0000
26511: MUL
26512: MUL
26513: ST_TO_ADDR
// end ; unit_vehicle :
26514: GO 27342
26516: LD_INT 2
26518: DOUBLE
26519: EQUAL
26520: IFTRUE 26524
26522: GO 27330
26524: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
26525: LD_VAR 0 6
26529: PPUSH
26530: CALL_OW 264
26534: PUSH
26535: LD_INT 2
26537: PUSH
26538: LD_INT 42
26540: PUSH
26541: LD_INT 24
26543: PUSH
26544: EMPTY
26545: LIST
26546: LIST
26547: LIST
26548: IN
26549: IFFALSE 26570
// points := [ 25 , 5 , 3 ] ;
26551: LD_ADDR_VAR 0 9
26555: PUSH
26556: LD_INT 25
26558: PUSH
26559: LD_INT 5
26561: PUSH
26562: LD_INT 3
26564: PUSH
26565: EMPTY
26566: LIST
26567: LIST
26568: LIST
26569: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
26570: LD_VAR 0 6
26574: PPUSH
26575: CALL_OW 264
26579: PUSH
26580: LD_INT 4
26582: PUSH
26583: LD_INT 43
26585: PUSH
26586: LD_INT 25
26588: PUSH
26589: EMPTY
26590: LIST
26591: LIST
26592: LIST
26593: IN
26594: IFFALSE 26615
// points := [ 40 , 15 , 5 ] ;
26596: LD_ADDR_VAR 0 9
26600: PUSH
26601: LD_INT 40
26603: PUSH
26604: LD_INT 15
26606: PUSH
26607: LD_INT 5
26609: PUSH
26610: EMPTY
26611: LIST
26612: LIST
26613: LIST
26614: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
26615: LD_VAR 0 6
26619: PPUSH
26620: CALL_OW 264
26624: PUSH
26625: LD_INT 3
26627: PUSH
26628: LD_INT 23
26630: PUSH
26631: EMPTY
26632: LIST
26633: LIST
26634: IN
26635: IFFALSE 26656
// points := [ 7 , 25 , 8 ] ;
26637: LD_ADDR_VAR 0 9
26641: PUSH
26642: LD_INT 7
26644: PUSH
26645: LD_INT 25
26647: PUSH
26648: LD_INT 8
26650: PUSH
26651: EMPTY
26652: LIST
26653: LIST
26654: LIST
26655: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
26656: LD_VAR 0 6
26660: PPUSH
26661: CALL_OW 264
26665: PUSH
26666: LD_INT 5
26668: PUSH
26669: LD_INT 27
26671: PUSH
26672: LD_INT 44
26674: PUSH
26675: EMPTY
26676: LIST
26677: LIST
26678: LIST
26679: IN
26680: IFFALSE 26701
// points := [ 14 , 50 , 16 ] ;
26682: LD_ADDR_VAR 0 9
26686: PUSH
26687: LD_INT 14
26689: PUSH
26690: LD_INT 50
26692: PUSH
26693: LD_INT 16
26695: PUSH
26696: EMPTY
26697: LIST
26698: LIST
26699: LIST
26700: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
26701: LD_VAR 0 6
26705: PPUSH
26706: CALL_OW 264
26710: PUSH
26711: LD_INT 6
26713: PUSH
26714: LD_INT 46
26716: PUSH
26717: EMPTY
26718: LIST
26719: LIST
26720: IN
26721: IFFALSE 26742
// points := [ 32 , 120 , 70 ] ;
26723: LD_ADDR_VAR 0 9
26727: PUSH
26728: LD_INT 32
26730: PUSH
26731: LD_INT 120
26733: PUSH
26734: LD_INT 70
26736: PUSH
26737: EMPTY
26738: LIST
26739: LIST
26740: LIST
26741: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
26742: LD_VAR 0 6
26746: PPUSH
26747: CALL_OW 264
26751: PUSH
26752: LD_INT 7
26754: PUSH
26755: LD_INT 28
26757: PUSH
26758: LD_INT 45
26760: PUSH
26761: LD_INT 92
26763: PUSH
26764: EMPTY
26765: LIST
26766: LIST
26767: LIST
26768: LIST
26769: IN
26770: IFFALSE 26791
// points := [ 35 , 20 , 45 ] ;
26772: LD_ADDR_VAR 0 9
26776: PUSH
26777: LD_INT 35
26779: PUSH
26780: LD_INT 20
26782: PUSH
26783: LD_INT 45
26785: PUSH
26786: EMPTY
26787: LIST
26788: LIST
26789: LIST
26790: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
26791: LD_VAR 0 6
26795: PPUSH
26796: CALL_OW 264
26800: PUSH
26801: LD_INT 47
26803: PUSH
26804: EMPTY
26805: LIST
26806: IN
26807: IFFALSE 26828
// points := [ 67 , 45 , 75 ] ;
26809: LD_ADDR_VAR 0 9
26813: PUSH
26814: LD_INT 67
26816: PUSH
26817: LD_INT 45
26819: PUSH
26820: LD_INT 75
26822: PUSH
26823: EMPTY
26824: LIST
26825: LIST
26826: LIST
26827: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
26828: LD_VAR 0 6
26832: PPUSH
26833: CALL_OW 264
26837: PUSH
26838: LD_INT 26
26840: PUSH
26841: EMPTY
26842: LIST
26843: IN
26844: IFFALSE 26865
// points := [ 120 , 30 , 80 ] ;
26846: LD_ADDR_VAR 0 9
26850: PUSH
26851: LD_INT 120
26853: PUSH
26854: LD_INT 30
26856: PUSH
26857: LD_INT 80
26859: PUSH
26860: EMPTY
26861: LIST
26862: LIST
26863: LIST
26864: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
26865: LD_VAR 0 6
26869: PPUSH
26870: CALL_OW 264
26874: PUSH
26875: LD_INT 22
26877: PUSH
26878: EMPTY
26879: LIST
26880: IN
26881: IFFALSE 26902
// points := [ 40 , 1 , 1 ] ;
26883: LD_ADDR_VAR 0 9
26887: PUSH
26888: LD_INT 40
26890: PUSH
26891: LD_INT 1
26893: PUSH
26894: LD_INT 1
26896: PUSH
26897: EMPTY
26898: LIST
26899: LIST
26900: LIST
26901: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
26902: LD_VAR 0 6
26906: PPUSH
26907: CALL_OW 264
26911: PUSH
26912: LD_INT 29
26914: PUSH
26915: EMPTY
26916: LIST
26917: IN
26918: IFFALSE 26939
// points := [ 70 , 200 , 400 ] ;
26920: LD_ADDR_VAR 0 9
26924: PUSH
26925: LD_INT 70
26927: PUSH
26928: LD_INT 200
26930: PUSH
26931: LD_INT 400
26933: PUSH
26934: EMPTY
26935: LIST
26936: LIST
26937: LIST
26938: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
26939: LD_VAR 0 6
26943: PPUSH
26944: CALL_OW 264
26948: PUSH
26949: LD_INT 14
26951: PUSH
26952: LD_INT 53
26954: PUSH
26955: EMPTY
26956: LIST
26957: LIST
26958: IN
26959: IFFALSE 26980
// points := [ 40 , 10 , 20 ] ;
26961: LD_ADDR_VAR 0 9
26965: PUSH
26966: LD_INT 40
26968: PUSH
26969: LD_INT 10
26971: PUSH
26972: LD_INT 20
26974: PUSH
26975: EMPTY
26976: LIST
26977: LIST
26978: LIST
26979: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
26980: LD_VAR 0 6
26984: PPUSH
26985: CALL_OW 264
26989: PUSH
26990: LD_INT 9
26992: PUSH
26993: EMPTY
26994: LIST
26995: IN
26996: IFFALSE 27017
// points := [ 5 , 70 , 20 ] ;
26998: LD_ADDR_VAR 0 9
27002: PUSH
27003: LD_INT 5
27005: PUSH
27006: LD_INT 70
27008: PUSH
27009: LD_INT 20
27011: PUSH
27012: EMPTY
27013: LIST
27014: LIST
27015: LIST
27016: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
27017: LD_VAR 0 6
27021: PPUSH
27022: CALL_OW 264
27026: PUSH
27027: LD_INT 10
27029: PUSH
27030: EMPTY
27031: LIST
27032: IN
27033: IFFALSE 27054
// points := [ 35 , 110 , 70 ] ;
27035: LD_ADDR_VAR 0 9
27039: PUSH
27040: LD_INT 35
27042: PUSH
27043: LD_INT 110
27045: PUSH
27046: LD_INT 70
27048: PUSH
27049: EMPTY
27050: LIST
27051: LIST
27052: LIST
27053: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
27054: LD_VAR 0 6
27058: PPUSH
27059: CALL_OW 265
27063: PUSH
27064: LD_INT 25
27066: EQUAL
27067: IFFALSE 27088
// points := [ 80 , 65 , 100 ] ;
27069: LD_ADDR_VAR 0 9
27073: PUSH
27074: LD_INT 80
27076: PUSH
27077: LD_INT 65
27079: PUSH
27080: LD_INT 100
27082: PUSH
27083: EMPTY
27084: LIST
27085: LIST
27086: LIST
27087: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
27088: LD_VAR 0 6
27092: PPUSH
27093: CALL_OW 263
27097: PUSH
27098: LD_INT 1
27100: EQUAL
27101: IFFALSE 27136
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
27103: LD_ADDR_VAR 0 10
27107: PUSH
27108: LD_VAR 0 10
27112: PUSH
27113: LD_VAR 0 6
27117: PPUSH
27118: CALL_OW 311
27122: PPUSH
27123: LD_INT 3
27125: PPUSH
27126: CALL_OW 259
27130: PUSH
27131: LD_INT 4
27133: MUL
27134: MUL
27135: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
27136: LD_VAR 0 6
27140: PPUSH
27141: CALL_OW 263
27145: PUSH
27146: LD_INT 2
27148: EQUAL
27149: IFFALSE 27200
// begin j := IsControledBy ( i ) ;
27151: LD_ADDR_VAR 0 7
27155: PUSH
27156: LD_VAR 0 6
27160: PPUSH
27161: CALL_OW 312
27165: ST_TO_ADDR
// if j then
27166: LD_VAR 0 7
27170: IFFALSE 27200
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
27172: LD_ADDR_VAR 0 10
27176: PUSH
27177: LD_VAR 0 10
27181: PUSH
27182: LD_VAR 0 7
27186: PPUSH
27187: LD_INT 3
27189: PPUSH
27190: CALL_OW 259
27194: PUSH
27195: LD_INT 3
27197: MUL
27198: MUL
27199: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
27200: LD_VAR 0 6
27204: PPUSH
27205: CALL_OW 264
27209: PUSH
27210: LD_INT 5
27212: PUSH
27213: LD_INT 6
27215: PUSH
27216: LD_INT 46
27218: PUSH
27219: LD_INT 44
27221: PUSH
27222: LD_INT 47
27224: PUSH
27225: LD_INT 45
27227: PUSH
27228: LD_INT 28
27230: PUSH
27231: LD_INT 7
27233: PUSH
27234: LD_INT 27
27236: PUSH
27237: LD_INT 29
27239: PUSH
27240: EMPTY
27241: LIST
27242: LIST
27243: LIST
27244: LIST
27245: LIST
27246: LIST
27247: LIST
27248: LIST
27249: LIST
27250: LIST
27251: IN
27252: PUSH
27253: LD_VAR 0 1
27257: PPUSH
27258: LD_INT 52
27260: PPUSH
27261: CALL_OW 321
27265: PUSH
27266: LD_INT 2
27268: EQUAL
27269: AND
27270: IFFALSE 27287
// bpoints := bpoints * 1.2 ;
27272: LD_ADDR_VAR 0 10
27276: PUSH
27277: LD_VAR 0 10
27281: PUSH
27282: LD_REAL  1.20000000000000E+0000
27285: MUL
27286: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
27287: LD_VAR 0 6
27291: PPUSH
27292: CALL_OW 264
27296: PUSH
27297: LD_INT 6
27299: PUSH
27300: LD_INT 46
27302: PUSH
27303: LD_INT 47
27305: PUSH
27306: EMPTY
27307: LIST
27308: LIST
27309: LIST
27310: IN
27311: IFFALSE 27328
// bpoints := bpoints * 1.2 ;
27313: LD_ADDR_VAR 0 10
27317: PUSH
27318: LD_VAR 0 10
27322: PUSH
27323: LD_REAL  1.20000000000000E+0000
27326: MUL
27327: ST_TO_ADDR
// end ; unit_building :
27328: GO 27342
27330: LD_INT 3
27332: DOUBLE
27333: EQUAL
27334: IFTRUE 27338
27336: GO 27341
27338: POP
// ; end ;
27339: GO 27342
27341: POP
// for j = 1 to 3 do
27342: LD_ADDR_VAR 0 7
27346: PUSH
27347: DOUBLE
27348: LD_INT 1
27350: DEC
27351: ST_TO_ADDR
27352: LD_INT 3
27354: PUSH
27355: FOR_TO
27356: IFFALSE 27409
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
27358: LD_ADDR_VAR 0 5
27362: PUSH
27363: LD_VAR 0 5
27367: PPUSH
27368: LD_VAR 0 7
27372: PPUSH
27373: LD_VAR 0 5
27377: PUSH
27378: LD_VAR 0 7
27382: ARRAY
27383: PUSH
27384: LD_VAR 0 9
27388: PUSH
27389: LD_VAR 0 7
27393: ARRAY
27394: PUSH
27395: LD_VAR 0 10
27399: MUL
27400: PLUS
27401: PPUSH
27402: CALL_OW 1
27406: ST_TO_ADDR
27407: GO 27355
27409: POP
27410: POP
// end ;
27411: GO 25890
27413: POP
27414: POP
// result := Replace ( result , 4 , tmp ) ;
27415: LD_ADDR_VAR 0 5
27419: PUSH
27420: LD_VAR 0 5
27424: PPUSH
27425: LD_INT 4
27427: PPUSH
27428: LD_VAR 0 8
27432: PPUSH
27433: CALL_OW 1
27437: ST_TO_ADDR
// end ;
27438: LD_VAR 0 5
27442: RET
// export function DangerAtRange ( unit , range ) ; begin
27443: LD_INT 0
27445: PPUSH
// if not unit then
27446: LD_VAR 0 1
27450: NOT
27451: IFFALSE 27455
// exit ;
27453: GO 27500
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
27455: LD_ADDR_VAR 0 3
27459: PUSH
27460: LD_VAR 0 1
27464: PPUSH
27465: CALL_OW 255
27469: PPUSH
27470: LD_VAR 0 1
27474: PPUSH
27475: CALL_OW 250
27479: PPUSH
27480: LD_VAR 0 1
27484: PPUSH
27485: CALL_OW 251
27489: PPUSH
27490: LD_VAR 0 2
27494: PPUSH
27495: CALL 25742 0 4
27499: ST_TO_ADDR
// end ;
27500: LD_VAR 0 3
27504: RET
// export function DangerInArea ( side , area ) ; begin
27505: LD_INT 0
27507: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
27508: LD_ADDR_VAR 0 3
27512: PUSH
27513: LD_VAR 0 2
27517: PPUSH
27518: LD_INT 81
27520: PUSH
27521: LD_VAR 0 1
27525: PUSH
27526: EMPTY
27527: LIST
27528: LIST
27529: PPUSH
27530: CALL_OW 70
27534: ST_TO_ADDR
// end ;
27535: LD_VAR 0 3
27539: RET
// export function IsExtension ( b ) ; begin
27540: LD_INT 0
27542: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
27543: LD_ADDR_VAR 0 2
27547: PUSH
27548: LD_VAR 0 1
27552: PUSH
27553: LD_INT 23
27555: PUSH
27556: LD_INT 20
27558: PUSH
27559: LD_INT 22
27561: PUSH
27562: LD_INT 17
27564: PUSH
27565: LD_INT 24
27567: PUSH
27568: LD_INT 21
27570: PUSH
27571: LD_INT 19
27573: PUSH
27574: LD_INT 16
27576: PUSH
27577: LD_INT 25
27579: PUSH
27580: LD_INT 18
27582: PUSH
27583: EMPTY
27584: LIST
27585: LIST
27586: LIST
27587: LIST
27588: LIST
27589: LIST
27590: LIST
27591: LIST
27592: LIST
27593: LIST
27594: IN
27595: ST_TO_ADDR
// end ;
27596: LD_VAR 0 2
27600: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
27601: LD_INT 0
27603: PPUSH
27604: PPUSH
27605: PPUSH
// result := [ ] ;
27606: LD_ADDR_VAR 0 4
27610: PUSH
27611: EMPTY
27612: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
27613: LD_ADDR_VAR 0 5
27617: PUSH
27618: LD_VAR 0 2
27622: PPUSH
27623: LD_INT 21
27625: PUSH
27626: LD_INT 3
27628: PUSH
27629: EMPTY
27630: LIST
27631: LIST
27632: PPUSH
27633: CALL_OW 70
27637: ST_TO_ADDR
// if not tmp then
27638: LD_VAR 0 5
27642: NOT
27643: IFFALSE 27647
// exit ;
27645: GO 27711
// if checkLink then
27647: LD_VAR 0 3
27651: IFFALSE 27701
// begin for i in tmp do
27653: LD_ADDR_VAR 0 6
27657: PUSH
27658: LD_VAR 0 5
27662: PUSH
27663: FOR_IN
27664: IFFALSE 27699
// if GetBase ( i ) <> base then
27666: LD_VAR 0 6
27670: PPUSH
27671: CALL_OW 274
27675: PUSH
27676: LD_VAR 0 1
27680: NONEQUAL
27681: IFFALSE 27697
// ComLinkToBase ( base , i ) ;
27683: LD_VAR 0 1
27687: PPUSH
27688: LD_VAR 0 6
27692: PPUSH
27693: CALL_OW 169
27697: GO 27663
27699: POP
27700: POP
// end ; result := tmp ;
27701: LD_ADDR_VAR 0 4
27705: PUSH
27706: LD_VAR 0 5
27710: ST_TO_ADDR
// end ;
27711: LD_VAR 0 4
27715: RET
// export function ComComplete ( units , b ) ; var i ; begin
27716: LD_INT 0
27718: PPUSH
27719: PPUSH
// if not units then
27720: LD_VAR 0 1
27724: NOT
27725: IFFALSE 27729
// exit ;
27727: GO 27819
// for i in units do
27729: LD_ADDR_VAR 0 4
27733: PUSH
27734: LD_VAR 0 1
27738: PUSH
27739: FOR_IN
27740: IFFALSE 27817
// if BuildingStatus ( b ) = bs_build then
27742: LD_VAR 0 2
27746: PPUSH
27747: CALL_OW 461
27751: PUSH
27752: LD_INT 1
27754: EQUAL
27755: IFFALSE 27815
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
27757: LD_VAR 0 4
27761: PPUSH
27762: LD_STRING h
27764: PUSH
27765: LD_VAR 0 2
27769: PPUSH
27770: CALL_OW 250
27774: PUSH
27775: LD_VAR 0 2
27779: PPUSH
27780: CALL_OW 251
27784: PUSH
27785: LD_VAR 0 2
27789: PUSH
27790: LD_INT 0
27792: PUSH
27793: LD_INT 0
27795: PUSH
27796: LD_INT 0
27798: PUSH
27799: EMPTY
27800: LIST
27801: LIST
27802: LIST
27803: LIST
27804: LIST
27805: LIST
27806: LIST
27807: PUSH
27808: EMPTY
27809: LIST
27810: PPUSH
27811: CALL_OW 446
27815: GO 27739
27817: POP
27818: POP
// end ;
27819: LD_VAR 0 3
27823: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
27824: LD_INT 0
27826: PPUSH
27827: PPUSH
27828: PPUSH
27829: PPUSH
27830: PPUSH
27831: PPUSH
// if not vehicle or GetControl ( vehicle ) <> control_remote then
27832: LD_VAR 0 1
27836: NOT
27837: PUSH
27838: LD_VAR 0 1
27842: PPUSH
27843: CALL_OW 263
27847: PUSH
27848: LD_INT 2
27850: NONEQUAL
27851: OR
27852: IFFALSE 27856
// exit ;
27854: GO 28172
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
27856: LD_ADDR_VAR 0 6
27860: PUSH
27861: LD_INT 22
27863: PUSH
27864: LD_VAR 0 1
27868: PPUSH
27869: CALL_OW 255
27873: PUSH
27874: EMPTY
27875: LIST
27876: LIST
27877: PUSH
27878: LD_INT 2
27880: PUSH
27881: LD_INT 30
27883: PUSH
27884: LD_INT 36
27886: PUSH
27887: EMPTY
27888: LIST
27889: LIST
27890: PUSH
27891: LD_INT 34
27893: PUSH
27894: LD_INT 31
27896: PUSH
27897: EMPTY
27898: LIST
27899: LIST
27900: PUSH
27901: EMPTY
27902: LIST
27903: LIST
27904: LIST
27905: PUSH
27906: EMPTY
27907: LIST
27908: LIST
27909: PPUSH
27910: CALL_OW 69
27914: ST_TO_ADDR
// if not tmp then
27915: LD_VAR 0 6
27919: NOT
27920: IFFALSE 27924
// exit ;
27922: GO 28172
// result := [ ] ;
27924: LD_ADDR_VAR 0 2
27928: PUSH
27929: EMPTY
27930: ST_TO_ADDR
// for i in tmp do
27931: LD_ADDR_VAR 0 3
27935: PUSH
27936: LD_VAR 0 6
27940: PUSH
27941: FOR_IN
27942: IFFALSE 28013
// begin t := UnitsInside ( i ) ;
27944: LD_ADDR_VAR 0 4
27948: PUSH
27949: LD_VAR 0 3
27953: PPUSH
27954: CALL_OW 313
27958: ST_TO_ADDR
// if t then
27959: LD_VAR 0 4
27963: IFFALSE 28011
// for j in t do
27965: LD_ADDR_VAR 0 7
27969: PUSH
27970: LD_VAR 0 4
27974: PUSH
27975: FOR_IN
27976: IFFALSE 28009
// result := Replace ( result , result + 1 , j ) ;
27978: LD_ADDR_VAR 0 2
27982: PUSH
27983: LD_VAR 0 2
27987: PPUSH
27988: LD_VAR 0 2
27992: PUSH
27993: LD_INT 1
27995: PLUS
27996: PPUSH
27997: LD_VAR 0 7
28001: PPUSH
28002: CALL_OW 1
28006: ST_TO_ADDR
28007: GO 27975
28009: POP
28010: POP
// end ;
28011: GO 27941
28013: POP
28014: POP
// if not result then
28015: LD_VAR 0 2
28019: NOT
28020: IFFALSE 28024
// exit ;
28022: GO 28172
// mech := result [ 1 ] ;
28024: LD_ADDR_VAR 0 5
28028: PUSH
28029: LD_VAR 0 2
28033: PUSH
28034: LD_INT 1
28036: ARRAY
28037: ST_TO_ADDR
// if result > 1 then
28038: LD_VAR 0 2
28042: PUSH
28043: LD_INT 1
28045: GREATER
28046: IFFALSE 28158
// begin for i = 2 to result do
28048: LD_ADDR_VAR 0 3
28052: PUSH
28053: DOUBLE
28054: LD_INT 2
28056: DEC
28057: ST_TO_ADDR
28058: LD_VAR 0 2
28062: PUSH
28063: FOR_TO
28064: IFFALSE 28156
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
28066: LD_ADDR_VAR 0 4
28070: PUSH
28071: LD_VAR 0 2
28075: PUSH
28076: LD_VAR 0 3
28080: ARRAY
28081: PPUSH
28082: LD_INT 3
28084: PPUSH
28085: CALL_OW 259
28089: PUSH
28090: LD_VAR 0 2
28094: PUSH
28095: LD_VAR 0 3
28099: ARRAY
28100: PPUSH
28101: CALL_OW 432
28105: MINUS
28106: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
28107: LD_VAR 0 4
28111: PUSH
28112: LD_VAR 0 5
28116: PPUSH
28117: LD_INT 3
28119: PPUSH
28120: CALL_OW 259
28124: PUSH
28125: LD_VAR 0 5
28129: PPUSH
28130: CALL_OW 432
28134: MINUS
28135: GREATEREQUAL
28136: IFFALSE 28154
// mech := result [ i ] ;
28138: LD_ADDR_VAR 0 5
28142: PUSH
28143: LD_VAR 0 2
28147: PUSH
28148: LD_VAR 0 3
28152: ARRAY
28153: ST_TO_ADDR
// end ;
28154: GO 28063
28156: POP
28157: POP
// end ; ComLinkTo ( vehicle , mech ) ;
28158: LD_VAR 0 1
28162: PPUSH
28163: LD_VAR 0 5
28167: PPUSH
28168: CALL_OW 135
// end ;
28172: LD_VAR 0 2
28176: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
28177: LD_INT 0
28179: PPUSH
28180: PPUSH
28181: PPUSH
28182: PPUSH
28183: PPUSH
28184: PPUSH
28185: PPUSH
28186: PPUSH
28187: PPUSH
28188: PPUSH
28189: PPUSH
28190: PPUSH
28191: PPUSH
// result := [ ] ;
28192: LD_ADDR_VAR 0 7
28196: PUSH
28197: EMPTY
28198: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
28199: LD_VAR 0 1
28203: PPUSH
28204: CALL_OW 266
28208: PUSH
28209: LD_INT 0
28211: PUSH
28212: LD_INT 1
28214: PUSH
28215: EMPTY
28216: LIST
28217: LIST
28218: IN
28219: NOT
28220: IFFALSE 28224
// exit ;
28222: GO 29858
// if name then
28224: LD_VAR 0 3
28228: IFFALSE 28244
// SetBName ( base_dep , name ) ;
28230: LD_VAR 0 1
28234: PPUSH
28235: LD_VAR 0 3
28239: PPUSH
28240: CALL_OW 500
// base := GetBase ( base_dep ) ;
28244: LD_ADDR_VAR 0 15
28248: PUSH
28249: LD_VAR 0 1
28253: PPUSH
28254: CALL_OW 274
28258: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
28259: LD_ADDR_VAR 0 16
28263: PUSH
28264: LD_VAR 0 1
28268: PPUSH
28269: CALL_OW 255
28273: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
28274: LD_ADDR_VAR 0 17
28278: PUSH
28279: LD_VAR 0 1
28283: PPUSH
28284: CALL_OW 248
28288: ST_TO_ADDR
// if sources then
28289: LD_VAR 0 5
28293: IFFALSE 28340
// for i = 1 to 3 do
28295: LD_ADDR_VAR 0 8
28299: PUSH
28300: DOUBLE
28301: LD_INT 1
28303: DEC
28304: ST_TO_ADDR
28305: LD_INT 3
28307: PUSH
28308: FOR_TO
28309: IFFALSE 28338
// AddResourceType ( base , i , sources [ i ] ) ;
28311: LD_VAR 0 15
28315: PPUSH
28316: LD_VAR 0 8
28320: PPUSH
28321: LD_VAR 0 5
28325: PUSH
28326: LD_VAR 0 8
28330: ARRAY
28331: PPUSH
28332: CALL_OW 276
28336: GO 28308
28338: POP
28339: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
28340: LD_ADDR_VAR 0 18
28344: PUSH
28345: LD_VAR 0 15
28349: PPUSH
28350: LD_VAR 0 2
28354: PPUSH
28355: LD_INT 1
28357: PPUSH
28358: CALL 27601 0 3
28362: ST_TO_ADDR
// InitHc ;
28363: CALL_OW 19
// InitUc ;
28367: CALL_OW 18
// uc_side := side ;
28371: LD_ADDR_OWVAR 20
28375: PUSH
28376: LD_VAR 0 16
28380: ST_TO_ADDR
// uc_nation := nation ;
28381: LD_ADDR_OWVAR 21
28385: PUSH
28386: LD_VAR 0 17
28390: ST_TO_ADDR
// if buildings then
28391: LD_VAR 0 18
28395: IFFALSE 29717
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
28397: LD_ADDR_VAR 0 19
28401: PUSH
28402: LD_VAR 0 18
28406: PPUSH
28407: LD_INT 2
28409: PUSH
28410: LD_INT 30
28412: PUSH
28413: LD_INT 29
28415: PUSH
28416: EMPTY
28417: LIST
28418: LIST
28419: PUSH
28420: LD_INT 30
28422: PUSH
28423: LD_INT 30
28425: PUSH
28426: EMPTY
28427: LIST
28428: LIST
28429: PUSH
28430: EMPTY
28431: LIST
28432: LIST
28433: LIST
28434: PPUSH
28435: CALL_OW 72
28439: ST_TO_ADDR
// if tmp then
28440: LD_VAR 0 19
28444: IFFALSE 28492
// for i in tmp do
28446: LD_ADDR_VAR 0 8
28450: PUSH
28451: LD_VAR 0 19
28455: PUSH
28456: FOR_IN
28457: IFFALSE 28490
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
28459: LD_VAR 0 8
28463: PPUSH
28464: CALL_OW 250
28468: PPUSH
28469: LD_VAR 0 8
28473: PPUSH
28474: CALL_OW 251
28478: PPUSH
28479: LD_VAR 0 16
28483: PPUSH
28484: CALL_OW 441
28488: GO 28456
28490: POP
28491: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
28492: LD_VAR 0 18
28496: PPUSH
28497: LD_INT 2
28499: PUSH
28500: LD_INT 30
28502: PUSH
28503: LD_INT 32
28505: PUSH
28506: EMPTY
28507: LIST
28508: LIST
28509: PUSH
28510: LD_INT 30
28512: PUSH
28513: LD_INT 33
28515: PUSH
28516: EMPTY
28517: LIST
28518: LIST
28519: PUSH
28520: EMPTY
28521: LIST
28522: LIST
28523: LIST
28524: PPUSH
28525: CALL_OW 72
28529: IFFALSE 28617
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
28531: LD_ADDR_VAR 0 8
28535: PUSH
28536: LD_VAR 0 18
28540: PPUSH
28541: LD_INT 2
28543: PUSH
28544: LD_INT 30
28546: PUSH
28547: LD_INT 32
28549: PUSH
28550: EMPTY
28551: LIST
28552: LIST
28553: PUSH
28554: LD_INT 30
28556: PUSH
28557: LD_INT 33
28559: PUSH
28560: EMPTY
28561: LIST
28562: LIST
28563: PUSH
28564: EMPTY
28565: LIST
28566: LIST
28567: LIST
28568: PPUSH
28569: CALL_OW 72
28573: PUSH
28574: FOR_IN
28575: IFFALSE 28615
// begin if not GetBWeapon ( i ) then
28577: LD_VAR 0 8
28581: PPUSH
28582: CALL_OW 269
28586: NOT
28587: IFFALSE 28613
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
28589: LD_VAR 0 8
28593: PPUSH
28594: LD_VAR 0 8
28598: PPUSH
28599: LD_VAR 0 2
28603: PPUSH
28604: CALL 29863 0 2
28608: PPUSH
28609: CALL_OW 431
// end ;
28613: GO 28574
28615: POP
28616: POP
// end ; for i = 1 to personel do
28617: LD_ADDR_VAR 0 8
28621: PUSH
28622: DOUBLE
28623: LD_INT 1
28625: DEC
28626: ST_TO_ADDR
28627: LD_VAR 0 6
28631: PUSH
28632: FOR_TO
28633: IFFALSE 29697
// begin if i > 4 then
28635: LD_VAR 0 8
28639: PUSH
28640: LD_INT 4
28642: GREATER
28643: IFFALSE 28647
// break ;
28645: GO 29697
// case i of 1 :
28647: LD_VAR 0 8
28651: PUSH
28652: LD_INT 1
28654: DOUBLE
28655: EQUAL
28656: IFTRUE 28660
28658: GO 28740
28660: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
28661: LD_ADDR_VAR 0 12
28665: PUSH
28666: LD_VAR 0 18
28670: PPUSH
28671: LD_INT 22
28673: PUSH
28674: LD_VAR 0 16
28678: PUSH
28679: EMPTY
28680: LIST
28681: LIST
28682: PUSH
28683: LD_INT 58
28685: PUSH
28686: EMPTY
28687: LIST
28688: PUSH
28689: LD_INT 2
28691: PUSH
28692: LD_INT 30
28694: PUSH
28695: LD_INT 32
28697: PUSH
28698: EMPTY
28699: LIST
28700: LIST
28701: PUSH
28702: LD_INT 30
28704: PUSH
28705: LD_INT 4
28707: PUSH
28708: EMPTY
28709: LIST
28710: LIST
28711: PUSH
28712: LD_INT 30
28714: PUSH
28715: LD_INT 5
28717: PUSH
28718: EMPTY
28719: LIST
28720: LIST
28721: PUSH
28722: EMPTY
28723: LIST
28724: LIST
28725: LIST
28726: LIST
28727: PUSH
28728: EMPTY
28729: LIST
28730: LIST
28731: LIST
28732: PPUSH
28733: CALL_OW 72
28737: ST_TO_ADDR
28738: GO 28962
28740: LD_INT 2
28742: DOUBLE
28743: EQUAL
28744: IFTRUE 28748
28746: GO 28810
28748: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
28749: LD_ADDR_VAR 0 12
28753: PUSH
28754: LD_VAR 0 18
28758: PPUSH
28759: LD_INT 22
28761: PUSH
28762: LD_VAR 0 16
28766: PUSH
28767: EMPTY
28768: LIST
28769: LIST
28770: PUSH
28771: LD_INT 2
28773: PUSH
28774: LD_INT 30
28776: PUSH
28777: LD_INT 0
28779: PUSH
28780: EMPTY
28781: LIST
28782: LIST
28783: PUSH
28784: LD_INT 30
28786: PUSH
28787: LD_INT 1
28789: PUSH
28790: EMPTY
28791: LIST
28792: LIST
28793: PUSH
28794: EMPTY
28795: LIST
28796: LIST
28797: LIST
28798: PUSH
28799: EMPTY
28800: LIST
28801: LIST
28802: PPUSH
28803: CALL_OW 72
28807: ST_TO_ADDR
28808: GO 28962
28810: LD_INT 3
28812: DOUBLE
28813: EQUAL
28814: IFTRUE 28818
28816: GO 28880
28818: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
28819: LD_ADDR_VAR 0 12
28823: PUSH
28824: LD_VAR 0 18
28828: PPUSH
28829: LD_INT 22
28831: PUSH
28832: LD_VAR 0 16
28836: PUSH
28837: EMPTY
28838: LIST
28839: LIST
28840: PUSH
28841: LD_INT 2
28843: PUSH
28844: LD_INT 30
28846: PUSH
28847: LD_INT 2
28849: PUSH
28850: EMPTY
28851: LIST
28852: LIST
28853: PUSH
28854: LD_INT 30
28856: PUSH
28857: LD_INT 3
28859: PUSH
28860: EMPTY
28861: LIST
28862: LIST
28863: PUSH
28864: EMPTY
28865: LIST
28866: LIST
28867: LIST
28868: PUSH
28869: EMPTY
28870: LIST
28871: LIST
28872: PPUSH
28873: CALL_OW 72
28877: ST_TO_ADDR
28878: GO 28962
28880: LD_INT 4
28882: DOUBLE
28883: EQUAL
28884: IFTRUE 28888
28886: GO 28961
28888: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
28889: LD_ADDR_VAR 0 12
28893: PUSH
28894: LD_VAR 0 18
28898: PPUSH
28899: LD_INT 22
28901: PUSH
28902: LD_VAR 0 16
28906: PUSH
28907: EMPTY
28908: LIST
28909: LIST
28910: PUSH
28911: LD_INT 2
28913: PUSH
28914: LD_INT 30
28916: PUSH
28917: LD_INT 6
28919: PUSH
28920: EMPTY
28921: LIST
28922: LIST
28923: PUSH
28924: LD_INT 30
28926: PUSH
28927: LD_INT 7
28929: PUSH
28930: EMPTY
28931: LIST
28932: LIST
28933: PUSH
28934: LD_INT 30
28936: PUSH
28937: LD_INT 8
28939: PUSH
28940: EMPTY
28941: LIST
28942: LIST
28943: PUSH
28944: EMPTY
28945: LIST
28946: LIST
28947: LIST
28948: LIST
28949: PUSH
28950: EMPTY
28951: LIST
28952: LIST
28953: PPUSH
28954: CALL_OW 72
28958: ST_TO_ADDR
28959: GO 28962
28961: POP
// if i = 1 then
28962: LD_VAR 0 8
28966: PUSH
28967: LD_INT 1
28969: EQUAL
28970: IFFALSE 29081
// begin tmp := [ ] ;
28972: LD_ADDR_VAR 0 19
28976: PUSH
28977: EMPTY
28978: ST_TO_ADDR
// for j in f do
28979: LD_ADDR_VAR 0 9
28983: PUSH
28984: LD_VAR 0 12
28988: PUSH
28989: FOR_IN
28990: IFFALSE 29063
// if GetBType ( j ) = b_bunker then
28992: LD_VAR 0 9
28996: PPUSH
28997: CALL_OW 266
29001: PUSH
29002: LD_INT 32
29004: EQUAL
29005: IFFALSE 29032
// tmp := Insert ( tmp , 1 , j ) else
29007: LD_ADDR_VAR 0 19
29011: PUSH
29012: LD_VAR 0 19
29016: PPUSH
29017: LD_INT 1
29019: PPUSH
29020: LD_VAR 0 9
29024: PPUSH
29025: CALL_OW 2
29029: ST_TO_ADDR
29030: GO 29061
// tmp := Insert ( tmp , tmp + 1 , j ) ;
29032: LD_ADDR_VAR 0 19
29036: PUSH
29037: LD_VAR 0 19
29041: PPUSH
29042: LD_VAR 0 19
29046: PUSH
29047: LD_INT 1
29049: PLUS
29050: PPUSH
29051: LD_VAR 0 9
29055: PPUSH
29056: CALL_OW 2
29060: ST_TO_ADDR
29061: GO 28989
29063: POP
29064: POP
// if tmp then
29065: LD_VAR 0 19
29069: IFFALSE 29081
// f := tmp ;
29071: LD_ADDR_VAR 0 12
29075: PUSH
29076: LD_VAR 0 19
29080: ST_TO_ADDR
// end ; x := personel [ i ] ;
29081: LD_ADDR_VAR 0 13
29085: PUSH
29086: LD_VAR 0 6
29090: PUSH
29091: LD_VAR 0 8
29095: ARRAY
29096: ST_TO_ADDR
// if x = - 1 then
29097: LD_VAR 0 13
29101: PUSH
29102: LD_INT 1
29104: NEG
29105: EQUAL
29106: IFFALSE 29315
// begin for j in f do
29108: LD_ADDR_VAR 0 9
29112: PUSH
29113: LD_VAR 0 12
29117: PUSH
29118: FOR_IN
29119: IFFALSE 29311
// repeat InitHc ;
29121: CALL_OW 19
// if GetBType ( j ) = b_barracks then
29125: LD_VAR 0 9
29129: PPUSH
29130: CALL_OW 266
29134: PUSH
29135: LD_INT 5
29137: EQUAL
29138: IFFALSE 29208
// begin if UnitsInside ( j ) < 3 then
29140: LD_VAR 0 9
29144: PPUSH
29145: CALL_OW 313
29149: PUSH
29150: LD_INT 3
29152: LESS
29153: IFFALSE 29189
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
29155: LD_INT 0
29157: PPUSH
29158: LD_INT 5
29160: PUSH
29161: LD_INT 8
29163: PUSH
29164: LD_INT 9
29166: PUSH
29167: EMPTY
29168: LIST
29169: LIST
29170: LIST
29171: PUSH
29172: LD_VAR 0 17
29176: ARRAY
29177: PPUSH
29178: LD_VAR 0 4
29182: PPUSH
29183: CALL_OW 380
29187: GO 29206
// PrepareHuman ( false , i , skill ) ;
29189: LD_INT 0
29191: PPUSH
29192: LD_VAR 0 8
29196: PPUSH
29197: LD_VAR 0 4
29201: PPUSH
29202: CALL_OW 380
// end else
29206: GO 29225
// PrepareHuman ( false , i , skill ) ;
29208: LD_INT 0
29210: PPUSH
29211: LD_VAR 0 8
29215: PPUSH
29216: LD_VAR 0 4
29220: PPUSH
29221: CALL_OW 380
// un := CreateHuman ;
29225: LD_ADDR_VAR 0 14
29229: PUSH
29230: CALL_OW 44
29234: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
29235: LD_ADDR_VAR 0 7
29239: PUSH
29240: LD_VAR 0 7
29244: PPUSH
29245: LD_INT 1
29247: PPUSH
29248: LD_VAR 0 14
29252: PPUSH
29253: CALL_OW 2
29257: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
29258: LD_VAR 0 14
29262: PPUSH
29263: LD_VAR 0 9
29267: PPUSH
29268: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
29272: LD_VAR 0 9
29276: PPUSH
29277: CALL_OW 313
29281: PUSH
29282: LD_INT 6
29284: EQUAL
29285: PUSH
29286: LD_VAR 0 9
29290: PPUSH
29291: CALL_OW 266
29295: PUSH
29296: LD_INT 32
29298: PUSH
29299: LD_INT 31
29301: PUSH
29302: EMPTY
29303: LIST
29304: LIST
29305: IN
29306: OR
29307: IFFALSE 29121
29309: GO 29118
29311: POP
29312: POP
// end else
29313: GO 29695
// for j = 1 to x do
29315: LD_ADDR_VAR 0 9
29319: PUSH
29320: DOUBLE
29321: LD_INT 1
29323: DEC
29324: ST_TO_ADDR
29325: LD_VAR 0 13
29329: PUSH
29330: FOR_TO
29331: IFFALSE 29693
// begin InitHc ;
29333: CALL_OW 19
// if not f then
29337: LD_VAR 0 12
29341: NOT
29342: IFFALSE 29431
// begin PrepareHuman ( false , i , skill ) ;
29344: LD_INT 0
29346: PPUSH
29347: LD_VAR 0 8
29351: PPUSH
29352: LD_VAR 0 4
29356: PPUSH
29357: CALL_OW 380
// un := CreateHuman ;
29361: LD_ADDR_VAR 0 14
29365: PUSH
29366: CALL_OW 44
29370: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
29371: LD_ADDR_VAR 0 7
29375: PUSH
29376: LD_VAR 0 7
29380: PPUSH
29381: LD_INT 1
29383: PPUSH
29384: LD_VAR 0 14
29388: PPUSH
29389: CALL_OW 2
29393: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
29394: LD_VAR 0 14
29398: PPUSH
29399: LD_VAR 0 1
29403: PPUSH
29404: CALL_OW 250
29408: PPUSH
29409: LD_VAR 0 1
29413: PPUSH
29414: CALL_OW 251
29418: PPUSH
29419: LD_INT 10
29421: PPUSH
29422: LD_INT 0
29424: PPUSH
29425: CALL_OW 50
// continue ;
29429: GO 29330
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
29431: LD_VAR 0 12
29435: PUSH
29436: LD_INT 1
29438: ARRAY
29439: PPUSH
29440: CALL_OW 313
29444: PUSH
29445: LD_VAR 0 12
29449: PUSH
29450: LD_INT 1
29452: ARRAY
29453: PPUSH
29454: CALL_OW 266
29458: PUSH
29459: LD_INT 32
29461: PUSH
29462: LD_INT 31
29464: PUSH
29465: EMPTY
29466: LIST
29467: LIST
29468: IN
29469: AND
29470: PUSH
29471: LD_VAR 0 12
29475: PUSH
29476: LD_INT 1
29478: ARRAY
29479: PPUSH
29480: CALL_OW 313
29484: PUSH
29485: LD_INT 6
29487: EQUAL
29488: OR
29489: IFFALSE 29509
// f := Delete ( f , 1 ) ;
29491: LD_ADDR_VAR 0 12
29495: PUSH
29496: LD_VAR 0 12
29500: PPUSH
29501: LD_INT 1
29503: PPUSH
29504: CALL_OW 3
29508: ST_TO_ADDR
// if not f then
29509: LD_VAR 0 12
29513: NOT
29514: IFFALSE 29532
// begin x := x + 2 ;
29516: LD_ADDR_VAR 0 13
29520: PUSH
29521: LD_VAR 0 13
29525: PUSH
29526: LD_INT 2
29528: PLUS
29529: ST_TO_ADDR
// continue ;
29530: GO 29330
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
29532: LD_VAR 0 12
29536: PUSH
29537: LD_INT 1
29539: ARRAY
29540: PPUSH
29541: CALL_OW 266
29545: PUSH
29546: LD_INT 5
29548: EQUAL
29549: IFFALSE 29623
// begin if UnitsInside ( f [ 1 ] ) < 3 then
29551: LD_VAR 0 12
29555: PUSH
29556: LD_INT 1
29558: ARRAY
29559: PPUSH
29560: CALL_OW 313
29564: PUSH
29565: LD_INT 3
29567: LESS
29568: IFFALSE 29604
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
29570: LD_INT 0
29572: PPUSH
29573: LD_INT 5
29575: PUSH
29576: LD_INT 8
29578: PUSH
29579: LD_INT 9
29581: PUSH
29582: EMPTY
29583: LIST
29584: LIST
29585: LIST
29586: PUSH
29587: LD_VAR 0 17
29591: ARRAY
29592: PPUSH
29593: LD_VAR 0 4
29597: PPUSH
29598: CALL_OW 380
29602: GO 29621
// PrepareHuman ( false , i , skill ) ;
29604: LD_INT 0
29606: PPUSH
29607: LD_VAR 0 8
29611: PPUSH
29612: LD_VAR 0 4
29616: PPUSH
29617: CALL_OW 380
// end else
29621: GO 29640
// PrepareHuman ( false , i , skill ) ;
29623: LD_INT 0
29625: PPUSH
29626: LD_VAR 0 8
29630: PPUSH
29631: LD_VAR 0 4
29635: PPUSH
29636: CALL_OW 380
// un := CreateHuman ;
29640: LD_ADDR_VAR 0 14
29644: PUSH
29645: CALL_OW 44
29649: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
29650: LD_ADDR_VAR 0 7
29654: PUSH
29655: LD_VAR 0 7
29659: PPUSH
29660: LD_INT 1
29662: PPUSH
29663: LD_VAR 0 14
29667: PPUSH
29668: CALL_OW 2
29672: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
29673: LD_VAR 0 14
29677: PPUSH
29678: LD_VAR 0 12
29682: PUSH
29683: LD_INT 1
29685: ARRAY
29686: PPUSH
29687: CALL_OW 52
// end ;
29691: GO 29330
29693: POP
29694: POP
// end ;
29695: GO 28632
29697: POP
29698: POP
// result := result ^ buildings ;
29699: LD_ADDR_VAR 0 7
29703: PUSH
29704: LD_VAR 0 7
29708: PUSH
29709: LD_VAR 0 18
29713: ADD
29714: ST_TO_ADDR
// end else
29715: GO 29858
// begin for i = 1 to personel do
29717: LD_ADDR_VAR 0 8
29721: PUSH
29722: DOUBLE
29723: LD_INT 1
29725: DEC
29726: ST_TO_ADDR
29727: LD_VAR 0 6
29731: PUSH
29732: FOR_TO
29733: IFFALSE 29856
// begin if i > 4 then
29735: LD_VAR 0 8
29739: PUSH
29740: LD_INT 4
29742: GREATER
29743: IFFALSE 29747
// break ;
29745: GO 29856
// x := personel [ i ] ;
29747: LD_ADDR_VAR 0 13
29751: PUSH
29752: LD_VAR 0 6
29756: PUSH
29757: LD_VAR 0 8
29761: ARRAY
29762: ST_TO_ADDR
// if x = - 1 then
29763: LD_VAR 0 13
29767: PUSH
29768: LD_INT 1
29770: NEG
29771: EQUAL
29772: IFFALSE 29776
// continue ;
29774: GO 29732
// PrepareHuman ( false , i , skill ) ;
29776: LD_INT 0
29778: PPUSH
29779: LD_VAR 0 8
29783: PPUSH
29784: LD_VAR 0 4
29788: PPUSH
29789: CALL_OW 380
// un := CreateHuman ;
29793: LD_ADDR_VAR 0 14
29797: PUSH
29798: CALL_OW 44
29802: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
29803: LD_VAR 0 14
29807: PPUSH
29808: LD_VAR 0 1
29812: PPUSH
29813: CALL_OW 250
29817: PPUSH
29818: LD_VAR 0 1
29822: PPUSH
29823: CALL_OW 251
29827: PPUSH
29828: LD_INT 10
29830: PPUSH
29831: LD_INT 0
29833: PPUSH
29834: CALL_OW 50
// result := result ^ un ;
29838: LD_ADDR_VAR 0 7
29842: PUSH
29843: LD_VAR 0 7
29847: PUSH
29848: LD_VAR 0 14
29852: ADD
29853: ST_TO_ADDR
// end ;
29854: GO 29732
29856: POP
29857: POP
// end ; end ;
29858: LD_VAR 0 7
29862: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
29863: LD_INT 0
29865: PPUSH
29866: PPUSH
29867: PPUSH
29868: PPUSH
29869: PPUSH
29870: PPUSH
29871: PPUSH
29872: PPUSH
29873: PPUSH
29874: PPUSH
29875: PPUSH
29876: PPUSH
29877: PPUSH
29878: PPUSH
29879: PPUSH
29880: PPUSH
// result := false ;
29881: LD_ADDR_VAR 0 3
29885: PUSH
29886: LD_INT 0
29888: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
29889: LD_VAR 0 1
29893: NOT
29894: PUSH
29895: LD_VAR 0 1
29899: PPUSH
29900: CALL_OW 266
29904: PUSH
29905: LD_INT 32
29907: PUSH
29908: LD_INT 33
29910: PUSH
29911: EMPTY
29912: LIST
29913: LIST
29914: IN
29915: NOT
29916: OR
29917: IFFALSE 29921
// exit ;
29919: GO 31030
// nat := GetNation ( tower ) ;
29921: LD_ADDR_VAR 0 12
29925: PUSH
29926: LD_VAR 0 1
29930: PPUSH
29931: CALL_OW 248
29935: ST_TO_ADDR
// side := GetSide ( tower ) ;
29936: LD_ADDR_VAR 0 16
29940: PUSH
29941: LD_VAR 0 1
29945: PPUSH
29946: CALL_OW 255
29950: ST_TO_ADDR
// x := GetX ( tower ) ;
29951: LD_ADDR_VAR 0 10
29955: PUSH
29956: LD_VAR 0 1
29960: PPUSH
29961: CALL_OW 250
29965: ST_TO_ADDR
// y := GetY ( tower ) ;
29966: LD_ADDR_VAR 0 11
29970: PUSH
29971: LD_VAR 0 1
29975: PPUSH
29976: CALL_OW 251
29980: ST_TO_ADDR
// if not x or not y then
29981: LD_VAR 0 10
29985: NOT
29986: PUSH
29987: LD_VAR 0 11
29991: NOT
29992: OR
29993: IFFALSE 29997
// exit ;
29995: GO 31030
// weapon := 0 ;
29997: LD_ADDR_VAR 0 18
30001: PUSH
30002: LD_INT 0
30004: ST_TO_ADDR
// fac_list := [ ] ;
30005: LD_ADDR_VAR 0 17
30009: PUSH
30010: EMPTY
30011: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
30012: LD_ADDR_VAR 0 6
30016: PUSH
30017: LD_VAR 0 1
30021: PPUSH
30022: CALL_OW 274
30026: PPUSH
30027: LD_VAR 0 2
30031: PPUSH
30032: LD_INT 0
30034: PPUSH
30035: CALL 27601 0 3
30039: PPUSH
30040: LD_INT 30
30042: PUSH
30043: LD_INT 3
30045: PUSH
30046: EMPTY
30047: LIST
30048: LIST
30049: PPUSH
30050: CALL_OW 72
30054: ST_TO_ADDR
// if not factories then
30055: LD_VAR 0 6
30059: NOT
30060: IFFALSE 30064
// exit ;
30062: GO 31030
// for i in factories do
30064: LD_ADDR_VAR 0 8
30068: PUSH
30069: LD_VAR 0 6
30073: PUSH
30074: FOR_IN
30075: IFFALSE 30100
// fac_list := fac_list union AvailableWeaponList ( i ) ;
30077: LD_ADDR_VAR 0 17
30081: PUSH
30082: LD_VAR 0 17
30086: PUSH
30087: LD_VAR 0 8
30091: PPUSH
30092: CALL_OW 478
30096: UNION
30097: ST_TO_ADDR
30098: GO 30074
30100: POP
30101: POP
// if not fac_list then
30102: LD_VAR 0 17
30106: NOT
30107: IFFALSE 30111
// exit ;
30109: GO 31030
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
30111: LD_ADDR_VAR 0 5
30115: PUSH
30116: LD_INT 4
30118: PUSH
30119: LD_INT 5
30121: PUSH
30122: LD_INT 9
30124: PUSH
30125: LD_INT 10
30127: PUSH
30128: LD_INT 6
30130: PUSH
30131: LD_INT 7
30133: PUSH
30134: LD_INT 11
30136: PUSH
30137: EMPTY
30138: LIST
30139: LIST
30140: LIST
30141: LIST
30142: LIST
30143: LIST
30144: LIST
30145: PUSH
30146: LD_INT 27
30148: PUSH
30149: LD_INT 28
30151: PUSH
30152: LD_INT 26
30154: PUSH
30155: LD_INT 30
30157: PUSH
30158: EMPTY
30159: LIST
30160: LIST
30161: LIST
30162: LIST
30163: PUSH
30164: LD_INT 43
30166: PUSH
30167: LD_INT 44
30169: PUSH
30170: LD_INT 46
30172: PUSH
30173: LD_INT 45
30175: PUSH
30176: LD_INT 47
30178: PUSH
30179: LD_INT 49
30181: PUSH
30182: EMPTY
30183: LIST
30184: LIST
30185: LIST
30186: LIST
30187: LIST
30188: LIST
30189: PUSH
30190: EMPTY
30191: LIST
30192: LIST
30193: LIST
30194: PUSH
30195: LD_VAR 0 12
30199: ARRAY
30200: ST_TO_ADDR
// list := list isect fac_list ;
30201: LD_ADDR_VAR 0 5
30205: PUSH
30206: LD_VAR 0 5
30210: PUSH
30211: LD_VAR 0 17
30215: ISECT
30216: ST_TO_ADDR
// if not list then
30217: LD_VAR 0 5
30221: NOT
30222: IFFALSE 30226
// exit ;
30224: GO 31030
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
30226: LD_VAR 0 12
30230: PUSH
30231: LD_INT 3
30233: EQUAL
30234: PUSH
30235: LD_INT 49
30237: PUSH
30238: LD_VAR 0 5
30242: IN
30243: AND
30244: PUSH
30245: LD_INT 31
30247: PPUSH
30248: LD_VAR 0 16
30252: PPUSH
30253: CALL_OW 321
30257: PUSH
30258: LD_INT 2
30260: EQUAL
30261: AND
30262: IFFALSE 30322
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
30264: LD_INT 22
30266: PUSH
30267: LD_VAR 0 16
30271: PUSH
30272: EMPTY
30273: LIST
30274: LIST
30275: PUSH
30276: LD_INT 35
30278: PUSH
30279: LD_INT 49
30281: PUSH
30282: EMPTY
30283: LIST
30284: LIST
30285: PUSH
30286: LD_INT 91
30288: PUSH
30289: LD_VAR 0 1
30293: PUSH
30294: LD_INT 10
30296: PUSH
30297: EMPTY
30298: LIST
30299: LIST
30300: LIST
30301: PUSH
30302: EMPTY
30303: LIST
30304: LIST
30305: LIST
30306: PPUSH
30307: CALL_OW 69
30311: NOT
30312: IFFALSE 30322
// weapon := ru_time_lapser ;
30314: LD_ADDR_VAR 0 18
30318: PUSH
30319: LD_INT 49
30321: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
30322: LD_VAR 0 12
30326: PUSH
30327: LD_INT 1
30329: PUSH
30330: LD_INT 2
30332: PUSH
30333: EMPTY
30334: LIST
30335: LIST
30336: IN
30337: PUSH
30338: LD_INT 11
30340: PUSH
30341: LD_VAR 0 5
30345: IN
30346: PUSH
30347: LD_INT 30
30349: PUSH
30350: LD_VAR 0 5
30354: IN
30355: OR
30356: AND
30357: PUSH
30358: LD_INT 6
30360: PPUSH
30361: LD_VAR 0 16
30365: PPUSH
30366: CALL_OW 321
30370: PUSH
30371: LD_INT 2
30373: EQUAL
30374: AND
30375: IFFALSE 30540
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
30377: LD_INT 22
30379: PUSH
30380: LD_VAR 0 16
30384: PUSH
30385: EMPTY
30386: LIST
30387: LIST
30388: PUSH
30389: LD_INT 2
30391: PUSH
30392: LD_INT 35
30394: PUSH
30395: LD_INT 11
30397: PUSH
30398: EMPTY
30399: LIST
30400: LIST
30401: PUSH
30402: LD_INT 35
30404: PUSH
30405: LD_INT 30
30407: PUSH
30408: EMPTY
30409: LIST
30410: LIST
30411: PUSH
30412: EMPTY
30413: LIST
30414: LIST
30415: LIST
30416: PUSH
30417: LD_INT 91
30419: PUSH
30420: LD_VAR 0 1
30424: PUSH
30425: LD_INT 18
30427: PUSH
30428: EMPTY
30429: LIST
30430: LIST
30431: LIST
30432: PUSH
30433: EMPTY
30434: LIST
30435: LIST
30436: LIST
30437: PPUSH
30438: CALL_OW 69
30442: NOT
30443: PUSH
30444: LD_INT 22
30446: PUSH
30447: LD_VAR 0 16
30451: PUSH
30452: EMPTY
30453: LIST
30454: LIST
30455: PUSH
30456: LD_INT 2
30458: PUSH
30459: LD_INT 30
30461: PUSH
30462: LD_INT 32
30464: PUSH
30465: EMPTY
30466: LIST
30467: LIST
30468: PUSH
30469: LD_INT 30
30471: PUSH
30472: LD_INT 33
30474: PUSH
30475: EMPTY
30476: LIST
30477: LIST
30478: PUSH
30479: EMPTY
30480: LIST
30481: LIST
30482: LIST
30483: PUSH
30484: LD_INT 91
30486: PUSH
30487: LD_VAR 0 1
30491: PUSH
30492: LD_INT 12
30494: PUSH
30495: EMPTY
30496: LIST
30497: LIST
30498: LIST
30499: PUSH
30500: EMPTY
30501: LIST
30502: LIST
30503: LIST
30504: PUSH
30505: EMPTY
30506: LIST
30507: PPUSH
30508: CALL_OW 69
30512: PUSH
30513: LD_INT 2
30515: GREATER
30516: AND
30517: IFFALSE 30540
// weapon := [ us_radar , ar_radar ] [ nat ] ;
30519: LD_ADDR_VAR 0 18
30523: PUSH
30524: LD_INT 11
30526: PUSH
30527: LD_INT 30
30529: PUSH
30530: EMPTY
30531: LIST
30532: LIST
30533: PUSH
30534: LD_VAR 0 12
30538: ARRAY
30539: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
30540: LD_VAR 0 18
30544: NOT
30545: PUSH
30546: LD_INT 40
30548: PPUSH
30549: LD_VAR 0 16
30553: PPUSH
30554: CALL_OW 321
30558: PUSH
30559: LD_INT 2
30561: EQUAL
30562: AND
30563: PUSH
30564: LD_INT 7
30566: PUSH
30567: LD_VAR 0 5
30571: IN
30572: PUSH
30573: LD_INT 28
30575: PUSH
30576: LD_VAR 0 5
30580: IN
30581: OR
30582: PUSH
30583: LD_INT 45
30585: PUSH
30586: LD_VAR 0 5
30590: IN
30591: OR
30592: AND
30593: IFFALSE 30847
// begin hex := GetHexInfo ( x , y ) ;
30595: LD_ADDR_VAR 0 4
30599: PUSH
30600: LD_VAR 0 10
30604: PPUSH
30605: LD_VAR 0 11
30609: PPUSH
30610: CALL_OW 546
30614: ST_TO_ADDR
// if hex [ 1 ] then
30615: LD_VAR 0 4
30619: PUSH
30620: LD_INT 1
30622: ARRAY
30623: IFFALSE 30627
// exit ;
30625: GO 31030
// height := hex [ 2 ] ;
30627: LD_ADDR_VAR 0 15
30631: PUSH
30632: LD_VAR 0 4
30636: PUSH
30637: LD_INT 2
30639: ARRAY
30640: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
30641: LD_ADDR_VAR 0 14
30645: PUSH
30646: LD_INT 0
30648: PUSH
30649: LD_INT 2
30651: PUSH
30652: LD_INT 3
30654: PUSH
30655: LD_INT 5
30657: PUSH
30658: EMPTY
30659: LIST
30660: LIST
30661: LIST
30662: LIST
30663: ST_TO_ADDR
// for i in tmp do
30664: LD_ADDR_VAR 0 8
30668: PUSH
30669: LD_VAR 0 14
30673: PUSH
30674: FOR_IN
30675: IFFALSE 30845
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
30677: LD_ADDR_VAR 0 9
30681: PUSH
30682: LD_VAR 0 10
30686: PPUSH
30687: LD_VAR 0 8
30691: PPUSH
30692: LD_INT 5
30694: PPUSH
30695: CALL_OW 272
30699: PUSH
30700: LD_VAR 0 11
30704: PPUSH
30705: LD_VAR 0 8
30709: PPUSH
30710: LD_INT 5
30712: PPUSH
30713: CALL_OW 273
30717: PUSH
30718: EMPTY
30719: LIST
30720: LIST
30721: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
30722: LD_VAR 0 9
30726: PUSH
30727: LD_INT 1
30729: ARRAY
30730: PPUSH
30731: LD_VAR 0 9
30735: PUSH
30736: LD_INT 2
30738: ARRAY
30739: PPUSH
30740: CALL_OW 488
30744: IFFALSE 30843
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
30746: LD_ADDR_VAR 0 4
30750: PUSH
30751: LD_VAR 0 9
30755: PUSH
30756: LD_INT 1
30758: ARRAY
30759: PPUSH
30760: LD_VAR 0 9
30764: PUSH
30765: LD_INT 2
30767: ARRAY
30768: PPUSH
30769: CALL_OW 546
30773: ST_TO_ADDR
// if hex [ 1 ] then
30774: LD_VAR 0 4
30778: PUSH
30779: LD_INT 1
30781: ARRAY
30782: IFFALSE 30786
// continue ;
30784: GO 30674
// h := hex [ 2 ] ;
30786: LD_ADDR_VAR 0 13
30790: PUSH
30791: LD_VAR 0 4
30795: PUSH
30796: LD_INT 2
30798: ARRAY
30799: ST_TO_ADDR
// if h + 7 < height then
30800: LD_VAR 0 13
30804: PUSH
30805: LD_INT 7
30807: PLUS
30808: PUSH
30809: LD_VAR 0 15
30813: LESS
30814: IFFALSE 30843
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
30816: LD_ADDR_VAR 0 18
30820: PUSH
30821: LD_INT 7
30823: PUSH
30824: LD_INT 28
30826: PUSH
30827: LD_INT 45
30829: PUSH
30830: EMPTY
30831: LIST
30832: LIST
30833: LIST
30834: PUSH
30835: LD_VAR 0 12
30839: ARRAY
30840: ST_TO_ADDR
// break ;
30841: GO 30845
// end ; end ; end ;
30843: GO 30674
30845: POP
30846: POP
// end ; if not weapon then
30847: LD_VAR 0 18
30851: NOT
30852: IFFALSE 30912
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
30854: LD_ADDR_VAR 0 5
30858: PUSH
30859: LD_VAR 0 5
30863: PUSH
30864: LD_INT 11
30866: PUSH
30867: LD_INT 30
30869: PUSH
30870: LD_INT 49
30872: PUSH
30873: EMPTY
30874: LIST
30875: LIST
30876: LIST
30877: DIFF
30878: ST_TO_ADDR
// if not list then
30879: LD_VAR 0 5
30883: NOT
30884: IFFALSE 30888
// exit ;
30886: GO 31030
// weapon := list [ rand ( 1 , list ) ] ;
30888: LD_ADDR_VAR 0 18
30892: PUSH
30893: LD_VAR 0 5
30897: PUSH
30898: LD_INT 1
30900: PPUSH
30901: LD_VAR 0 5
30905: PPUSH
30906: CALL_OW 12
30910: ARRAY
30911: ST_TO_ADDR
// end ; if weapon then
30912: LD_VAR 0 18
30916: IFFALSE 31030
// begin tmp := CostOfWeapon ( weapon ) ;
30918: LD_ADDR_VAR 0 14
30922: PUSH
30923: LD_VAR 0 18
30927: PPUSH
30928: CALL_OW 451
30932: ST_TO_ADDR
// j := GetBase ( tower ) ;
30933: LD_ADDR_VAR 0 9
30937: PUSH
30938: LD_VAR 0 1
30942: PPUSH
30943: CALL_OW 274
30947: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
30948: LD_VAR 0 9
30952: PPUSH
30953: LD_INT 1
30955: PPUSH
30956: CALL_OW 275
30960: PUSH
30961: LD_VAR 0 14
30965: PUSH
30966: LD_INT 1
30968: ARRAY
30969: GREATEREQUAL
30970: PUSH
30971: LD_VAR 0 9
30975: PPUSH
30976: LD_INT 2
30978: PPUSH
30979: CALL_OW 275
30983: PUSH
30984: LD_VAR 0 14
30988: PUSH
30989: LD_INT 2
30991: ARRAY
30992: GREATEREQUAL
30993: AND
30994: PUSH
30995: LD_VAR 0 9
30999: PPUSH
31000: LD_INT 3
31002: PPUSH
31003: CALL_OW 275
31007: PUSH
31008: LD_VAR 0 14
31012: PUSH
31013: LD_INT 3
31015: ARRAY
31016: GREATEREQUAL
31017: AND
31018: IFFALSE 31030
// result := weapon ;
31020: LD_ADDR_VAR 0 3
31024: PUSH
31025: LD_VAR 0 18
31029: ST_TO_ADDR
// end ; end ;
31030: LD_VAR 0 3
31034: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
31035: LD_INT 0
31037: PPUSH
31038: PPUSH
// result := true ;
31039: LD_ADDR_VAR 0 3
31043: PUSH
31044: LD_INT 1
31046: ST_TO_ADDR
// if array1 = array2 then
31047: LD_VAR 0 1
31051: PUSH
31052: LD_VAR 0 2
31056: EQUAL
31057: IFFALSE 31117
// begin for i = 1 to array1 do
31059: LD_ADDR_VAR 0 4
31063: PUSH
31064: DOUBLE
31065: LD_INT 1
31067: DEC
31068: ST_TO_ADDR
31069: LD_VAR 0 1
31073: PUSH
31074: FOR_TO
31075: IFFALSE 31113
// if array1 [ i ] <> array2 [ i ] then
31077: LD_VAR 0 1
31081: PUSH
31082: LD_VAR 0 4
31086: ARRAY
31087: PUSH
31088: LD_VAR 0 2
31092: PUSH
31093: LD_VAR 0 4
31097: ARRAY
31098: NONEQUAL
31099: IFFALSE 31111
// begin result := false ;
31101: LD_ADDR_VAR 0 3
31105: PUSH
31106: LD_INT 0
31108: ST_TO_ADDR
// break ;
31109: GO 31113
// end ;
31111: GO 31074
31113: POP
31114: POP
// end else
31115: GO 31125
// result := false ;
31117: LD_ADDR_VAR 0 3
31121: PUSH
31122: LD_INT 0
31124: ST_TO_ADDR
// end ;
31125: LD_VAR 0 3
31129: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
31130: LD_INT 0
31132: PPUSH
31133: PPUSH
// if not array1 or not array2 then
31134: LD_VAR 0 1
31138: NOT
31139: PUSH
31140: LD_VAR 0 2
31144: NOT
31145: OR
31146: IFFALSE 31150
// exit ;
31148: GO 31214
// result := true ;
31150: LD_ADDR_VAR 0 3
31154: PUSH
31155: LD_INT 1
31157: ST_TO_ADDR
// for i = 1 to array1 do
31158: LD_ADDR_VAR 0 4
31162: PUSH
31163: DOUBLE
31164: LD_INT 1
31166: DEC
31167: ST_TO_ADDR
31168: LD_VAR 0 1
31172: PUSH
31173: FOR_TO
31174: IFFALSE 31212
// if array1 [ i ] <> array2 [ i ] then
31176: LD_VAR 0 1
31180: PUSH
31181: LD_VAR 0 4
31185: ARRAY
31186: PUSH
31187: LD_VAR 0 2
31191: PUSH
31192: LD_VAR 0 4
31196: ARRAY
31197: NONEQUAL
31198: IFFALSE 31210
// begin result := false ;
31200: LD_ADDR_VAR 0 3
31204: PUSH
31205: LD_INT 0
31207: ST_TO_ADDR
// break ;
31208: GO 31212
// end ;
31210: GO 31173
31212: POP
31213: POP
// end ;
31214: LD_VAR 0 3
31218: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
31219: LD_INT 0
31221: PPUSH
31222: PPUSH
31223: PPUSH
// pom := GetBase ( fac ) ;
31224: LD_ADDR_VAR 0 5
31228: PUSH
31229: LD_VAR 0 1
31233: PPUSH
31234: CALL_OW 274
31238: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
31239: LD_ADDR_VAR 0 4
31243: PUSH
31244: LD_VAR 0 2
31248: PUSH
31249: LD_INT 1
31251: ARRAY
31252: PPUSH
31253: LD_VAR 0 2
31257: PUSH
31258: LD_INT 2
31260: ARRAY
31261: PPUSH
31262: LD_VAR 0 2
31266: PUSH
31267: LD_INT 3
31269: ARRAY
31270: PPUSH
31271: LD_VAR 0 2
31275: PUSH
31276: LD_INT 4
31278: ARRAY
31279: PPUSH
31280: CALL_OW 449
31284: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
31285: LD_ADDR_VAR 0 3
31289: PUSH
31290: LD_VAR 0 5
31294: PPUSH
31295: LD_INT 1
31297: PPUSH
31298: CALL_OW 275
31302: PUSH
31303: LD_VAR 0 4
31307: PUSH
31308: LD_INT 1
31310: ARRAY
31311: GREATEREQUAL
31312: PUSH
31313: LD_VAR 0 5
31317: PPUSH
31318: LD_INT 2
31320: PPUSH
31321: CALL_OW 275
31325: PUSH
31326: LD_VAR 0 4
31330: PUSH
31331: LD_INT 2
31333: ARRAY
31334: GREATEREQUAL
31335: AND
31336: PUSH
31337: LD_VAR 0 5
31341: PPUSH
31342: LD_INT 3
31344: PPUSH
31345: CALL_OW 275
31349: PUSH
31350: LD_VAR 0 4
31354: PUSH
31355: LD_INT 3
31357: ARRAY
31358: GREATEREQUAL
31359: AND
31360: ST_TO_ADDR
// end ;
31361: LD_VAR 0 3
31365: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
31366: LD_INT 0
31368: PPUSH
31369: PPUSH
31370: PPUSH
31371: PPUSH
// pom := GetBase ( building ) ;
31372: LD_ADDR_VAR 0 3
31376: PUSH
31377: LD_VAR 0 1
31381: PPUSH
31382: CALL_OW 274
31386: ST_TO_ADDR
// if not pom then
31387: LD_VAR 0 3
31391: NOT
31392: IFFALSE 31396
// exit ;
31394: GO 31566
// btype := GetBType ( building ) ;
31396: LD_ADDR_VAR 0 5
31400: PUSH
31401: LD_VAR 0 1
31405: PPUSH
31406: CALL_OW 266
31410: ST_TO_ADDR
// if btype = b_armoury then
31411: LD_VAR 0 5
31415: PUSH
31416: LD_INT 4
31418: EQUAL
31419: IFFALSE 31429
// btype := b_barracks ;
31421: LD_ADDR_VAR 0 5
31425: PUSH
31426: LD_INT 5
31428: ST_TO_ADDR
// if btype = b_depot then
31429: LD_VAR 0 5
31433: PUSH
31434: LD_INT 0
31436: EQUAL
31437: IFFALSE 31447
// btype := b_warehouse ;
31439: LD_ADDR_VAR 0 5
31443: PUSH
31444: LD_INT 1
31446: ST_TO_ADDR
// if btype = b_workshop then
31447: LD_VAR 0 5
31451: PUSH
31452: LD_INT 2
31454: EQUAL
31455: IFFALSE 31465
// btype := b_factory ;
31457: LD_ADDR_VAR 0 5
31461: PUSH
31462: LD_INT 3
31464: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
31465: LD_ADDR_VAR 0 4
31469: PUSH
31470: LD_VAR 0 5
31474: PPUSH
31475: LD_VAR 0 1
31479: PPUSH
31480: CALL_OW 248
31484: PPUSH
31485: CALL_OW 450
31489: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
31490: LD_ADDR_VAR 0 2
31494: PUSH
31495: LD_VAR 0 3
31499: PPUSH
31500: LD_INT 1
31502: PPUSH
31503: CALL_OW 275
31507: PUSH
31508: LD_VAR 0 4
31512: PUSH
31513: LD_INT 1
31515: ARRAY
31516: GREATEREQUAL
31517: PUSH
31518: LD_VAR 0 3
31522: PPUSH
31523: LD_INT 2
31525: PPUSH
31526: CALL_OW 275
31530: PUSH
31531: LD_VAR 0 4
31535: PUSH
31536: LD_INT 2
31538: ARRAY
31539: GREATEREQUAL
31540: AND
31541: PUSH
31542: LD_VAR 0 3
31546: PPUSH
31547: LD_INT 3
31549: PPUSH
31550: CALL_OW 275
31554: PUSH
31555: LD_VAR 0 4
31559: PUSH
31560: LD_INT 3
31562: ARRAY
31563: GREATEREQUAL
31564: AND
31565: ST_TO_ADDR
// end ;
31566: LD_VAR 0 2
31570: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
31571: LD_INT 0
31573: PPUSH
31574: PPUSH
31575: PPUSH
// pom := GetBase ( building ) ;
31576: LD_ADDR_VAR 0 4
31580: PUSH
31581: LD_VAR 0 1
31585: PPUSH
31586: CALL_OW 274
31590: ST_TO_ADDR
// if not pom then
31591: LD_VAR 0 4
31595: NOT
31596: IFFALSE 31600
// exit ;
31598: GO 31701
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
31600: LD_ADDR_VAR 0 5
31604: PUSH
31605: LD_VAR 0 2
31609: PPUSH
31610: LD_VAR 0 1
31614: PPUSH
31615: CALL_OW 248
31619: PPUSH
31620: CALL_OW 450
31624: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
31625: LD_ADDR_VAR 0 3
31629: PUSH
31630: LD_VAR 0 4
31634: PPUSH
31635: LD_INT 1
31637: PPUSH
31638: CALL_OW 275
31642: PUSH
31643: LD_VAR 0 5
31647: PUSH
31648: LD_INT 1
31650: ARRAY
31651: GREATEREQUAL
31652: PUSH
31653: LD_VAR 0 4
31657: PPUSH
31658: LD_INT 2
31660: PPUSH
31661: CALL_OW 275
31665: PUSH
31666: LD_VAR 0 5
31670: PUSH
31671: LD_INT 2
31673: ARRAY
31674: GREATEREQUAL
31675: AND
31676: PUSH
31677: LD_VAR 0 4
31681: PPUSH
31682: LD_INT 3
31684: PPUSH
31685: CALL_OW 275
31689: PUSH
31690: LD_VAR 0 5
31694: PUSH
31695: LD_INT 3
31697: ARRAY
31698: GREATEREQUAL
31699: AND
31700: ST_TO_ADDR
// end ;
31701: LD_VAR 0 3
31705: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
31706: LD_INT 0
31708: PPUSH
31709: PPUSH
31710: PPUSH
31711: PPUSH
31712: PPUSH
31713: PPUSH
31714: PPUSH
31715: PPUSH
31716: PPUSH
31717: PPUSH
31718: PPUSH
// result := false ;
31719: LD_ADDR_VAR 0 8
31723: PUSH
31724: LD_INT 0
31726: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
31727: LD_VAR 0 5
31731: NOT
31732: PUSH
31733: LD_VAR 0 1
31737: NOT
31738: OR
31739: PUSH
31740: LD_VAR 0 2
31744: NOT
31745: OR
31746: PUSH
31747: LD_VAR 0 3
31751: NOT
31752: OR
31753: IFFALSE 31757
// exit ;
31755: GO 32571
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
31757: LD_ADDR_VAR 0 14
31761: PUSH
31762: LD_VAR 0 1
31766: PPUSH
31767: LD_VAR 0 2
31771: PPUSH
31772: LD_VAR 0 3
31776: PPUSH
31777: LD_VAR 0 4
31781: PPUSH
31782: LD_VAR 0 5
31786: PUSH
31787: LD_INT 1
31789: ARRAY
31790: PPUSH
31791: CALL_OW 248
31795: PPUSH
31796: LD_INT 0
31798: PPUSH
31799: CALL 33824 0 6
31803: ST_TO_ADDR
// if not hexes then
31804: LD_VAR 0 14
31808: NOT
31809: IFFALSE 31813
// exit ;
31811: GO 32571
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
31813: LD_ADDR_VAR 0 17
31817: PUSH
31818: LD_VAR 0 5
31822: PPUSH
31823: LD_INT 22
31825: PUSH
31826: LD_VAR 0 13
31830: PPUSH
31831: CALL_OW 255
31835: PUSH
31836: EMPTY
31837: LIST
31838: LIST
31839: PUSH
31840: LD_INT 2
31842: PUSH
31843: LD_INT 30
31845: PUSH
31846: LD_INT 0
31848: PUSH
31849: EMPTY
31850: LIST
31851: LIST
31852: PUSH
31853: LD_INT 30
31855: PUSH
31856: LD_INT 1
31858: PUSH
31859: EMPTY
31860: LIST
31861: LIST
31862: PUSH
31863: EMPTY
31864: LIST
31865: LIST
31866: LIST
31867: PUSH
31868: EMPTY
31869: LIST
31870: LIST
31871: PPUSH
31872: CALL_OW 72
31876: ST_TO_ADDR
// for i = 1 to hexes do
31877: LD_ADDR_VAR 0 9
31881: PUSH
31882: DOUBLE
31883: LD_INT 1
31885: DEC
31886: ST_TO_ADDR
31887: LD_VAR 0 14
31891: PUSH
31892: FOR_TO
31893: IFFALSE 32569
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
31895: LD_ADDR_VAR 0 13
31899: PUSH
31900: LD_VAR 0 14
31904: PUSH
31905: LD_VAR 0 9
31909: ARRAY
31910: PUSH
31911: LD_INT 1
31913: ARRAY
31914: PPUSH
31915: LD_VAR 0 14
31919: PUSH
31920: LD_VAR 0 9
31924: ARRAY
31925: PUSH
31926: LD_INT 2
31928: ARRAY
31929: PPUSH
31930: CALL_OW 428
31934: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
31935: LD_VAR 0 14
31939: PUSH
31940: LD_VAR 0 9
31944: ARRAY
31945: PUSH
31946: LD_INT 1
31948: ARRAY
31949: PPUSH
31950: LD_VAR 0 14
31954: PUSH
31955: LD_VAR 0 9
31959: ARRAY
31960: PUSH
31961: LD_INT 2
31963: ARRAY
31964: PPUSH
31965: CALL_OW 351
31969: PUSH
31970: LD_VAR 0 14
31974: PUSH
31975: LD_VAR 0 9
31979: ARRAY
31980: PUSH
31981: LD_INT 1
31983: ARRAY
31984: PPUSH
31985: LD_VAR 0 14
31989: PUSH
31990: LD_VAR 0 9
31994: ARRAY
31995: PUSH
31996: LD_INT 2
31998: ARRAY
31999: PPUSH
32000: CALL_OW 488
32004: NOT
32005: OR
32006: PUSH
32007: LD_VAR 0 13
32011: PPUSH
32012: CALL_OW 247
32016: PUSH
32017: LD_INT 3
32019: EQUAL
32020: OR
32021: IFFALSE 32027
// exit ;
32023: POP
32024: POP
32025: GO 32571
// if not tmp then
32027: LD_VAR 0 13
32031: NOT
32032: IFFALSE 32036
// continue ;
32034: GO 31892
// result := true ;
32036: LD_ADDR_VAR 0 8
32040: PUSH
32041: LD_INT 1
32043: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
32044: LD_VAR 0 6
32048: PUSH
32049: LD_VAR 0 13
32053: PPUSH
32054: CALL_OW 247
32058: PUSH
32059: LD_INT 2
32061: EQUAL
32062: AND
32063: PUSH
32064: LD_VAR 0 13
32068: PPUSH
32069: CALL_OW 263
32073: PUSH
32074: LD_INT 1
32076: EQUAL
32077: AND
32078: IFFALSE 32242
// begin if IsDrivenBy ( tmp ) then
32080: LD_VAR 0 13
32084: PPUSH
32085: CALL_OW 311
32089: IFFALSE 32093
// continue ;
32091: GO 31892
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
32093: LD_VAR 0 6
32097: PPUSH
32098: LD_INT 3
32100: PUSH
32101: LD_INT 60
32103: PUSH
32104: EMPTY
32105: LIST
32106: PUSH
32107: EMPTY
32108: LIST
32109: LIST
32110: PUSH
32111: LD_INT 3
32113: PUSH
32114: LD_INT 55
32116: PUSH
32117: EMPTY
32118: LIST
32119: PUSH
32120: EMPTY
32121: LIST
32122: LIST
32123: PUSH
32124: EMPTY
32125: LIST
32126: LIST
32127: PPUSH
32128: CALL_OW 72
32132: IFFALSE 32240
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
32134: LD_ADDR_VAR 0 18
32138: PUSH
32139: LD_VAR 0 6
32143: PPUSH
32144: LD_INT 3
32146: PUSH
32147: LD_INT 60
32149: PUSH
32150: EMPTY
32151: LIST
32152: PUSH
32153: EMPTY
32154: LIST
32155: LIST
32156: PUSH
32157: LD_INT 3
32159: PUSH
32160: LD_INT 55
32162: PUSH
32163: EMPTY
32164: LIST
32165: PUSH
32166: EMPTY
32167: LIST
32168: LIST
32169: PUSH
32170: EMPTY
32171: LIST
32172: LIST
32173: PPUSH
32174: CALL_OW 72
32178: PUSH
32179: LD_INT 1
32181: ARRAY
32182: ST_TO_ADDR
// if IsInUnit ( driver ) then
32183: LD_VAR 0 18
32187: PPUSH
32188: CALL_OW 310
32192: IFFALSE 32203
// ComExit ( driver ) ;
32194: LD_VAR 0 18
32198: PPUSH
32199: CALL 57603 0 1
// AddComEnterUnit ( driver , tmp ) ;
32203: LD_VAR 0 18
32207: PPUSH
32208: LD_VAR 0 13
32212: PPUSH
32213: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
32217: LD_VAR 0 18
32221: PPUSH
32222: LD_VAR 0 7
32226: PPUSH
32227: CALL_OW 173
// AddComExitVehicle ( driver ) ;
32231: LD_VAR 0 18
32235: PPUSH
32236: CALL_OW 181
// end ; continue ;
32240: GO 31892
// end ; if not cleaners or not tmp in cleaners then
32242: LD_VAR 0 6
32246: NOT
32247: PUSH
32248: LD_VAR 0 13
32252: PUSH
32253: LD_VAR 0 6
32257: IN
32258: NOT
32259: OR
32260: IFFALSE 32567
// begin if dep then
32262: LD_VAR 0 17
32266: IFFALSE 32402
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
32268: LD_ADDR_VAR 0 16
32272: PUSH
32273: LD_VAR 0 17
32277: PUSH
32278: LD_INT 1
32280: ARRAY
32281: PPUSH
32282: CALL_OW 250
32286: PPUSH
32287: LD_VAR 0 17
32291: PUSH
32292: LD_INT 1
32294: ARRAY
32295: PPUSH
32296: CALL_OW 254
32300: PPUSH
32301: LD_INT 5
32303: PPUSH
32304: CALL_OW 272
32308: PUSH
32309: LD_VAR 0 17
32313: PUSH
32314: LD_INT 1
32316: ARRAY
32317: PPUSH
32318: CALL_OW 251
32322: PPUSH
32323: LD_VAR 0 17
32327: PUSH
32328: LD_INT 1
32330: ARRAY
32331: PPUSH
32332: CALL_OW 254
32336: PPUSH
32337: LD_INT 5
32339: PPUSH
32340: CALL_OW 273
32344: PUSH
32345: EMPTY
32346: LIST
32347: LIST
32348: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
32349: LD_VAR 0 16
32353: PUSH
32354: LD_INT 1
32356: ARRAY
32357: PPUSH
32358: LD_VAR 0 16
32362: PUSH
32363: LD_INT 2
32365: ARRAY
32366: PPUSH
32367: CALL_OW 488
32371: IFFALSE 32402
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
32373: LD_VAR 0 13
32377: PPUSH
32378: LD_VAR 0 16
32382: PUSH
32383: LD_INT 1
32385: ARRAY
32386: PPUSH
32387: LD_VAR 0 16
32391: PUSH
32392: LD_INT 2
32394: ARRAY
32395: PPUSH
32396: CALL_OW 111
// continue ;
32400: GO 31892
// end ; end ; r := GetDir ( tmp ) ;
32402: LD_ADDR_VAR 0 15
32406: PUSH
32407: LD_VAR 0 13
32411: PPUSH
32412: CALL_OW 254
32416: ST_TO_ADDR
// if r = 5 then
32417: LD_VAR 0 15
32421: PUSH
32422: LD_INT 5
32424: EQUAL
32425: IFFALSE 32435
// r := 0 ;
32427: LD_ADDR_VAR 0 15
32431: PUSH
32432: LD_INT 0
32434: ST_TO_ADDR
// for j = r to 5 do
32435: LD_ADDR_VAR 0 10
32439: PUSH
32440: DOUBLE
32441: LD_VAR 0 15
32445: DEC
32446: ST_TO_ADDR
32447: LD_INT 5
32449: PUSH
32450: FOR_TO
32451: IFFALSE 32565
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
32453: LD_ADDR_VAR 0 11
32457: PUSH
32458: LD_VAR 0 13
32462: PPUSH
32463: CALL_OW 250
32467: PPUSH
32468: LD_VAR 0 10
32472: PPUSH
32473: LD_INT 2
32475: PPUSH
32476: CALL_OW 272
32480: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
32481: LD_ADDR_VAR 0 12
32485: PUSH
32486: LD_VAR 0 13
32490: PPUSH
32491: CALL_OW 251
32495: PPUSH
32496: LD_VAR 0 10
32500: PPUSH
32501: LD_INT 2
32503: PPUSH
32504: CALL_OW 273
32508: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
32509: LD_VAR 0 11
32513: PPUSH
32514: LD_VAR 0 12
32518: PPUSH
32519: CALL_OW 488
32523: PUSH
32524: LD_VAR 0 11
32528: PPUSH
32529: LD_VAR 0 12
32533: PPUSH
32534: CALL_OW 428
32538: NOT
32539: AND
32540: IFFALSE 32563
// begin ComMoveXY ( tmp , _x , _y ) ;
32542: LD_VAR 0 13
32546: PPUSH
32547: LD_VAR 0 11
32551: PPUSH
32552: LD_VAR 0 12
32556: PPUSH
32557: CALL_OW 111
// break ;
32561: GO 32565
// end ; end ;
32563: GO 32450
32565: POP
32566: POP
// end ; end ;
32567: GO 31892
32569: POP
32570: POP
// end ;
32571: LD_VAR 0 8
32575: RET
// export function BuildingTechInvented ( side , btype ) ; begin
32576: LD_INT 0
32578: PPUSH
// result := true ;
32579: LD_ADDR_VAR 0 3
32583: PUSH
32584: LD_INT 1
32586: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
32587: LD_VAR 0 2
32591: PUSH
32592: LD_INT 24
32594: DOUBLE
32595: EQUAL
32596: IFTRUE 32606
32598: LD_INT 33
32600: DOUBLE
32601: EQUAL
32602: IFTRUE 32606
32604: GO 32631
32606: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
32607: LD_ADDR_VAR 0 3
32611: PUSH
32612: LD_INT 32
32614: PPUSH
32615: LD_VAR 0 1
32619: PPUSH
32620: CALL_OW 321
32624: PUSH
32625: LD_INT 2
32627: EQUAL
32628: ST_TO_ADDR
32629: GO 32947
32631: LD_INT 20
32633: DOUBLE
32634: EQUAL
32635: IFTRUE 32639
32637: GO 32664
32639: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
32640: LD_ADDR_VAR 0 3
32644: PUSH
32645: LD_INT 6
32647: PPUSH
32648: LD_VAR 0 1
32652: PPUSH
32653: CALL_OW 321
32657: PUSH
32658: LD_INT 2
32660: EQUAL
32661: ST_TO_ADDR
32662: GO 32947
32664: LD_INT 22
32666: DOUBLE
32667: EQUAL
32668: IFTRUE 32678
32670: LD_INT 36
32672: DOUBLE
32673: EQUAL
32674: IFTRUE 32678
32676: GO 32703
32678: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
32679: LD_ADDR_VAR 0 3
32683: PUSH
32684: LD_INT 15
32686: PPUSH
32687: LD_VAR 0 1
32691: PPUSH
32692: CALL_OW 321
32696: PUSH
32697: LD_INT 2
32699: EQUAL
32700: ST_TO_ADDR
32701: GO 32947
32703: LD_INT 30
32705: DOUBLE
32706: EQUAL
32707: IFTRUE 32711
32709: GO 32736
32711: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
32712: LD_ADDR_VAR 0 3
32716: PUSH
32717: LD_INT 20
32719: PPUSH
32720: LD_VAR 0 1
32724: PPUSH
32725: CALL_OW 321
32729: PUSH
32730: LD_INT 2
32732: EQUAL
32733: ST_TO_ADDR
32734: GO 32947
32736: LD_INT 28
32738: DOUBLE
32739: EQUAL
32740: IFTRUE 32750
32742: LD_INT 21
32744: DOUBLE
32745: EQUAL
32746: IFTRUE 32750
32748: GO 32775
32750: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
32751: LD_ADDR_VAR 0 3
32755: PUSH
32756: LD_INT 21
32758: PPUSH
32759: LD_VAR 0 1
32763: PPUSH
32764: CALL_OW 321
32768: PUSH
32769: LD_INT 2
32771: EQUAL
32772: ST_TO_ADDR
32773: GO 32947
32775: LD_INT 16
32777: DOUBLE
32778: EQUAL
32779: IFTRUE 32783
32781: GO 32808
32783: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
32784: LD_ADDR_VAR 0 3
32788: PUSH
32789: LD_INT 84
32791: PPUSH
32792: LD_VAR 0 1
32796: PPUSH
32797: CALL_OW 321
32801: PUSH
32802: LD_INT 2
32804: EQUAL
32805: ST_TO_ADDR
32806: GO 32947
32808: LD_INT 19
32810: DOUBLE
32811: EQUAL
32812: IFTRUE 32822
32814: LD_INT 23
32816: DOUBLE
32817: EQUAL
32818: IFTRUE 32822
32820: GO 32847
32822: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
32823: LD_ADDR_VAR 0 3
32827: PUSH
32828: LD_INT 83
32830: PPUSH
32831: LD_VAR 0 1
32835: PPUSH
32836: CALL_OW 321
32840: PUSH
32841: LD_INT 2
32843: EQUAL
32844: ST_TO_ADDR
32845: GO 32947
32847: LD_INT 17
32849: DOUBLE
32850: EQUAL
32851: IFTRUE 32855
32853: GO 32880
32855: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
32856: LD_ADDR_VAR 0 3
32860: PUSH
32861: LD_INT 39
32863: PPUSH
32864: LD_VAR 0 1
32868: PPUSH
32869: CALL_OW 321
32873: PUSH
32874: LD_INT 2
32876: EQUAL
32877: ST_TO_ADDR
32878: GO 32947
32880: LD_INT 18
32882: DOUBLE
32883: EQUAL
32884: IFTRUE 32888
32886: GO 32913
32888: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
32889: LD_ADDR_VAR 0 3
32893: PUSH
32894: LD_INT 40
32896: PPUSH
32897: LD_VAR 0 1
32901: PPUSH
32902: CALL_OW 321
32906: PUSH
32907: LD_INT 2
32909: EQUAL
32910: ST_TO_ADDR
32911: GO 32947
32913: LD_INT 27
32915: DOUBLE
32916: EQUAL
32917: IFTRUE 32921
32919: GO 32946
32921: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
32922: LD_ADDR_VAR 0 3
32926: PUSH
32927: LD_INT 35
32929: PPUSH
32930: LD_VAR 0 1
32934: PPUSH
32935: CALL_OW 321
32939: PUSH
32940: LD_INT 2
32942: EQUAL
32943: ST_TO_ADDR
32944: GO 32947
32946: POP
// end ;
32947: LD_VAR 0 3
32951: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
32952: LD_INT 0
32954: PPUSH
32955: PPUSH
32956: PPUSH
32957: PPUSH
32958: PPUSH
32959: PPUSH
32960: PPUSH
32961: PPUSH
32962: PPUSH
32963: PPUSH
32964: PPUSH
// result := false ;
32965: LD_ADDR_VAR 0 6
32969: PUSH
32970: LD_INT 0
32972: ST_TO_ADDR
// if btype = b_depot then
32973: LD_VAR 0 2
32977: PUSH
32978: LD_INT 0
32980: EQUAL
32981: IFFALSE 32993
// begin result := true ;
32983: LD_ADDR_VAR 0 6
32987: PUSH
32988: LD_INT 1
32990: ST_TO_ADDR
// exit ;
32991: GO 33819
// end ; if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
32993: LD_VAR 0 1
32997: NOT
32998: PUSH
32999: LD_VAR 0 1
33003: PPUSH
33004: CALL_OW 266
33008: PUSH
33009: LD_INT 0
33011: PUSH
33012: LD_INT 1
33014: PUSH
33015: EMPTY
33016: LIST
33017: LIST
33018: IN
33019: NOT
33020: OR
33021: PUSH
33022: LD_VAR 0 2
33026: NOT
33027: OR
33028: PUSH
33029: LD_VAR 0 5
33033: PUSH
33034: LD_INT 0
33036: PUSH
33037: LD_INT 1
33039: PUSH
33040: LD_INT 2
33042: PUSH
33043: LD_INT 3
33045: PUSH
33046: LD_INT 4
33048: PUSH
33049: LD_INT 5
33051: PUSH
33052: EMPTY
33053: LIST
33054: LIST
33055: LIST
33056: LIST
33057: LIST
33058: LIST
33059: IN
33060: NOT
33061: OR
33062: PUSH
33063: LD_VAR 0 3
33067: PPUSH
33068: LD_VAR 0 4
33072: PPUSH
33073: CALL_OW 488
33077: NOT
33078: OR
33079: IFFALSE 33083
// exit ;
33081: GO 33819
// side := GetSide ( depot ) ;
33083: LD_ADDR_VAR 0 9
33087: PUSH
33088: LD_VAR 0 1
33092: PPUSH
33093: CALL_OW 255
33097: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
33098: LD_VAR 0 9
33102: PPUSH
33103: LD_VAR 0 2
33107: PPUSH
33108: CALL 32576 0 2
33112: NOT
33113: IFFALSE 33117
// exit ;
33115: GO 33819
// pom := GetBase ( depot ) ;
33117: LD_ADDR_VAR 0 10
33121: PUSH
33122: LD_VAR 0 1
33126: PPUSH
33127: CALL_OW 274
33131: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
33132: LD_ADDR_VAR 0 11
33136: PUSH
33137: LD_VAR 0 2
33141: PPUSH
33142: LD_VAR 0 1
33146: PPUSH
33147: CALL_OW 248
33151: PPUSH
33152: CALL_OW 450
33156: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
33157: LD_VAR 0 10
33161: PPUSH
33162: LD_INT 1
33164: PPUSH
33165: CALL_OW 275
33169: PUSH
33170: LD_VAR 0 11
33174: PUSH
33175: LD_INT 1
33177: ARRAY
33178: GREATEREQUAL
33179: PUSH
33180: LD_VAR 0 10
33184: PPUSH
33185: LD_INT 2
33187: PPUSH
33188: CALL_OW 275
33192: PUSH
33193: LD_VAR 0 11
33197: PUSH
33198: LD_INT 2
33200: ARRAY
33201: GREATEREQUAL
33202: AND
33203: PUSH
33204: LD_VAR 0 10
33208: PPUSH
33209: LD_INT 3
33211: PPUSH
33212: CALL_OW 275
33216: PUSH
33217: LD_VAR 0 11
33221: PUSH
33222: LD_INT 3
33224: ARRAY
33225: GREATEREQUAL
33226: AND
33227: NOT
33228: IFFALSE 33232
// exit ;
33230: GO 33819
// if GetBType ( depot ) = b_depot then
33232: LD_VAR 0 1
33236: PPUSH
33237: CALL_OW 266
33241: PUSH
33242: LD_INT 0
33244: EQUAL
33245: IFFALSE 33257
// dist := 28 else
33247: LD_ADDR_VAR 0 14
33251: PUSH
33252: LD_INT 28
33254: ST_TO_ADDR
33255: GO 33265
// dist := 36 ;
33257: LD_ADDR_VAR 0 14
33261: PUSH
33262: LD_INT 36
33264: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
33265: LD_VAR 0 1
33269: PPUSH
33270: LD_VAR 0 3
33274: PPUSH
33275: LD_VAR 0 4
33279: PPUSH
33280: CALL_OW 297
33284: PUSH
33285: LD_VAR 0 14
33289: GREATER
33290: IFFALSE 33294
// exit ;
33292: GO 33819
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
33294: LD_ADDR_VAR 0 12
33298: PUSH
33299: LD_VAR 0 2
33303: PPUSH
33304: LD_VAR 0 3
33308: PPUSH
33309: LD_VAR 0 4
33313: PPUSH
33314: LD_VAR 0 5
33318: PPUSH
33319: LD_VAR 0 1
33323: PPUSH
33324: CALL_OW 248
33328: PPUSH
33329: LD_INT 0
33331: PPUSH
33332: CALL 33824 0 6
33336: ST_TO_ADDR
// if not hexes then
33337: LD_VAR 0 12
33341: NOT
33342: IFFALSE 33346
// exit ;
33344: GO 33819
// hex := GetHexInfo ( x , y ) ;
33346: LD_ADDR_VAR 0 15
33350: PUSH
33351: LD_VAR 0 3
33355: PPUSH
33356: LD_VAR 0 4
33360: PPUSH
33361: CALL_OW 546
33365: ST_TO_ADDR
// if hex [ 1 ] then
33366: LD_VAR 0 15
33370: PUSH
33371: LD_INT 1
33373: ARRAY
33374: IFFALSE 33378
// exit ;
33376: GO 33819
// height := hex [ 2 ] ;
33378: LD_ADDR_VAR 0 13
33382: PUSH
33383: LD_VAR 0 15
33387: PUSH
33388: LD_INT 2
33390: ARRAY
33391: ST_TO_ADDR
// for i = 1 to hexes do
33392: LD_ADDR_VAR 0 7
33396: PUSH
33397: DOUBLE
33398: LD_INT 1
33400: DEC
33401: ST_TO_ADDR
33402: LD_VAR 0 12
33406: PUSH
33407: FOR_TO
33408: IFFALSE 33738
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
33410: LD_VAR 0 12
33414: PUSH
33415: LD_VAR 0 7
33419: ARRAY
33420: PUSH
33421: LD_INT 1
33423: ARRAY
33424: PPUSH
33425: LD_VAR 0 12
33429: PUSH
33430: LD_VAR 0 7
33434: ARRAY
33435: PUSH
33436: LD_INT 2
33438: ARRAY
33439: PPUSH
33440: CALL_OW 488
33444: NOT
33445: PUSH
33446: LD_VAR 0 12
33450: PUSH
33451: LD_VAR 0 7
33455: ARRAY
33456: PUSH
33457: LD_INT 1
33459: ARRAY
33460: PPUSH
33461: LD_VAR 0 12
33465: PUSH
33466: LD_VAR 0 7
33470: ARRAY
33471: PUSH
33472: LD_INT 2
33474: ARRAY
33475: PPUSH
33476: CALL_OW 428
33480: PUSH
33481: LD_INT 0
33483: GREATER
33484: OR
33485: PUSH
33486: LD_VAR 0 12
33490: PUSH
33491: LD_VAR 0 7
33495: ARRAY
33496: PUSH
33497: LD_INT 1
33499: ARRAY
33500: PPUSH
33501: LD_VAR 0 12
33505: PUSH
33506: LD_VAR 0 7
33510: ARRAY
33511: PUSH
33512: LD_INT 2
33514: ARRAY
33515: PPUSH
33516: CALL_OW 351
33520: OR
33521: IFFALSE 33527
// exit ;
33523: POP
33524: POP
33525: GO 33819
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
33527: LD_ADDR_VAR 0 8
33531: PUSH
33532: LD_VAR 0 12
33536: PUSH
33537: LD_VAR 0 7
33541: ARRAY
33542: PUSH
33543: LD_INT 1
33545: ARRAY
33546: PPUSH
33547: LD_VAR 0 12
33551: PUSH
33552: LD_VAR 0 7
33556: ARRAY
33557: PUSH
33558: LD_INT 2
33560: ARRAY
33561: PPUSH
33562: CALL_OW 546
33566: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
33567: LD_VAR 0 8
33571: PUSH
33572: LD_INT 1
33574: ARRAY
33575: PUSH
33576: LD_VAR 0 8
33580: PUSH
33581: LD_INT 2
33583: ARRAY
33584: PUSH
33585: LD_VAR 0 13
33589: PUSH
33590: LD_INT 2
33592: PLUS
33593: GREATER
33594: OR
33595: PUSH
33596: LD_VAR 0 8
33600: PUSH
33601: LD_INT 2
33603: ARRAY
33604: PUSH
33605: LD_VAR 0 13
33609: PUSH
33610: LD_INT 2
33612: MINUS
33613: LESS
33614: OR
33615: PUSH
33616: LD_VAR 0 8
33620: PUSH
33621: LD_INT 3
33623: ARRAY
33624: PUSH
33625: LD_INT 0
33627: PUSH
33628: LD_INT 8
33630: PUSH
33631: LD_INT 9
33633: PUSH
33634: LD_INT 10
33636: PUSH
33637: LD_INT 11
33639: PUSH
33640: LD_INT 12
33642: PUSH
33643: LD_INT 13
33645: PUSH
33646: LD_INT 16
33648: PUSH
33649: LD_INT 17
33651: PUSH
33652: LD_INT 18
33654: PUSH
33655: LD_INT 19
33657: PUSH
33658: LD_INT 20
33660: PUSH
33661: LD_INT 21
33663: PUSH
33664: EMPTY
33665: LIST
33666: LIST
33667: LIST
33668: LIST
33669: LIST
33670: LIST
33671: LIST
33672: LIST
33673: LIST
33674: LIST
33675: LIST
33676: LIST
33677: LIST
33678: IN
33679: NOT
33680: OR
33681: PUSH
33682: LD_VAR 0 8
33686: PUSH
33687: LD_INT 5
33689: ARRAY
33690: NOT
33691: OR
33692: PUSH
33693: LD_VAR 0 8
33697: PUSH
33698: LD_INT 6
33700: ARRAY
33701: PUSH
33702: LD_INT 1
33704: PUSH
33705: LD_INT 2
33707: PUSH
33708: LD_INT 7
33710: PUSH
33711: LD_INT 9
33713: PUSH
33714: LD_INT 10
33716: PUSH
33717: LD_INT 11
33719: PUSH
33720: EMPTY
33721: LIST
33722: LIST
33723: LIST
33724: LIST
33725: LIST
33726: LIST
33727: IN
33728: NOT
33729: OR
33730: IFFALSE 33736
// exit ;
33732: POP
33733: POP
33734: GO 33819
// end ;
33736: GO 33407
33738: POP
33739: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
33740: LD_VAR 0 9
33744: PPUSH
33745: LD_VAR 0 3
33749: PPUSH
33750: LD_VAR 0 4
33754: PPUSH
33755: LD_INT 20
33757: PPUSH
33758: CALL 25742 0 4
33762: PUSH
33763: LD_INT 4
33765: ARRAY
33766: IFFALSE 33770
// exit ;
33768: GO 33819
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
33770: LD_VAR 0 2
33774: PUSH
33775: LD_INT 29
33777: PUSH
33778: LD_INT 30
33780: PUSH
33781: EMPTY
33782: LIST
33783: LIST
33784: IN
33785: PUSH
33786: LD_VAR 0 3
33790: PPUSH
33791: LD_VAR 0 4
33795: PPUSH
33796: LD_VAR 0 9
33800: PPUSH
33801: CALL_OW 440
33805: NOT
33806: AND
33807: IFFALSE 33811
// exit ;
33809: GO 33819
// result := true ;
33811: LD_ADDR_VAR 0 6
33815: PUSH
33816: LD_INT 1
33818: ST_TO_ADDR
// end ;
33819: LD_VAR 0 6
33823: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
33824: LD_INT 0
33826: PPUSH
33827: PPUSH
33828: PPUSH
33829: PPUSH
33830: PPUSH
33831: PPUSH
33832: PPUSH
33833: PPUSH
33834: PPUSH
33835: PPUSH
33836: PPUSH
33837: PPUSH
33838: PPUSH
33839: PPUSH
33840: PPUSH
33841: PPUSH
33842: PPUSH
33843: PPUSH
33844: PPUSH
33845: PPUSH
33846: PPUSH
33847: PPUSH
33848: PPUSH
33849: PPUSH
33850: PPUSH
33851: PPUSH
33852: PPUSH
33853: PPUSH
33854: PPUSH
33855: PPUSH
33856: PPUSH
33857: PPUSH
33858: PPUSH
33859: PPUSH
33860: PPUSH
33861: PPUSH
33862: PPUSH
33863: PPUSH
33864: PPUSH
33865: PPUSH
33866: PPUSH
33867: PPUSH
33868: PPUSH
33869: PPUSH
33870: PPUSH
33871: PPUSH
33872: PPUSH
33873: PPUSH
33874: PPUSH
33875: PPUSH
33876: PPUSH
33877: PPUSH
33878: PPUSH
33879: PPUSH
33880: PPUSH
33881: PPUSH
33882: PPUSH
33883: PPUSH
// result = [ ] ;
33884: LD_ADDR_VAR 0 7
33888: PUSH
33889: EMPTY
33890: ST_TO_ADDR
// temp_list = [ ] ;
33891: LD_ADDR_VAR 0 9
33895: PUSH
33896: EMPTY
33897: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
33898: LD_VAR 0 4
33902: PUSH
33903: LD_INT 0
33905: PUSH
33906: LD_INT 1
33908: PUSH
33909: LD_INT 2
33911: PUSH
33912: LD_INT 3
33914: PUSH
33915: LD_INT 4
33917: PUSH
33918: LD_INT 5
33920: PUSH
33921: EMPTY
33922: LIST
33923: LIST
33924: LIST
33925: LIST
33926: LIST
33927: LIST
33928: IN
33929: NOT
33930: PUSH
33931: LD_VAR 0 1
33935: PUSH
33936: LD_INT 0
33938: PUSH
33939: LD_INT 1
33941: PUSH
33942: EMPTY
33943: LIST
33944: LIST
33945: IN
33946: PUSH
33947: LD_VAR 0 5
33951: PUSH
33952: LD_INT 1
33954: PUSH
33955: LD_INT 2
33957: PUSH
33958: LD_INT 3
33960: PUSH
33961: EMPTY
33962: LIST
33963: LIST
33964: LIST
33965: IN
33966: NOT
33967: AND
33968: OR
33969: IFFALSE 33973
// exit ;
33971: GO 52364
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
33973: LD_VAR 0 1
33977: PUSH
33978: LD_INT 6
33980: PUSH
33981: LD_INT 7
33983: PUSH
33984: LD_INT 8
33986: PUSH
33987: LD_INT 13
33989: PUSH
33990: LD_INT 12
33992: PUSH
33993: LD_INT 15
33995: PUSH
33996: LD_INT 11
33998: PUSH
33999: LD_INT 14
34001: PUSH
34002: LD_INT 10
34004: PUSH
34005: EMPTY
34006: LIST
34007: LIST
34008: LIST
34009: LIST
34010: LIST
34011: LIST
34012: LIST
34013: LIST
34014: LIST
34015: IN
34016: IFFALSE 34026
// btype = b_lab ;
34018: LD_ADDR_VAR 0 1
34022: PUSH
34023: LD_INT 6
34025: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
34026: LD_VAR 0 6
34030: PUSH
34031: LD_INT 0
34033: PUSH
34034: LD_INT 1
34036: PUSH
34037: LD_INT 2
34039: PUSH
34040: EMPTY
34041: LIST
34042: LIST
34043: LIST
34044: IN
34045: NOT
34046: PUSH
34047: LD_VAR 0 1
34051: PUSH
34052: LD_INT 0
34054: PUSH
34055: LD_INT 1
34057: PUSH
34058: LD_INT 2
34060: PUSH
34061: LD_INT 3
34063: PUSH
34064: LD_INT 6
34066: PUSH
34067: LD_INT 36
34069: PUSH
34070: LD_INT 4
34072: PUSH
34073: LD_INT 5
34075: PUSH
34076: LD_INT 31
34078: PUSH
34079: LD_INT 32
34081: PUSH
34082: LD_INT 33
34084: PUSH
34085: EMPTY
34086: LIST
34087: LIST
34088: LIST
34089: LIST
34090: LIST
34091: LIST
34092: LIST
34093: LIST
34094: LIST
34095: LIST
34096: LIST
34097: IN
34098: NOT
34099: PUSH
34100: LD_VAR 0 6
34104: PUSH
34105: LD_INT 1
34107: EQUAL
34108: AND
34109: OR
34110: PUSH
34111: LD_VAR 0 1
34115: PUSH
34116: LD_INT 2
34118: PUSH
34119: LD_INT 3
34121: PUSH
34122: EMPTY
34123: LIST
34124: LIST
34125: IN
34126: NOT
34127: PUSH
34128: LD_VAR 0 6
34132: PUSH
34133: LD_INT 2
34135: EQUAL
34136: AND
34137: OR
34138: IFFALSE 34148
// mode = 0 ;
34140: LD_ADDR_VAR 0 6
34144: PUSH
34145: LD_INT 0
34147: ST_TO_ADDR
// case mode of 0 :
34148: LD_VAR 0 6
34152: PUSH
34153: LD_INT 0
34155: DOUBLE
34156: EQUAL
34157: IFTRUE 34161
34159: GO 45614
34161: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
34162: LD_ADDR_VAR 0 11
34166: PUSH
34167: LD_INT 0
34169: PUSH
34170: LD_INT 0
34172: PUSH
34173: EMPTY
34174: LIST
34175: LIST
34176: PUSH
34177: LD_INT 0
34179: PUSH
34180: LD_INT 1
34182: NEG
34183: PUSH
34184: EMPTY
34185: LIST
34186: LIST
34187: PUSH
34188: LD_INT 1
34190: PUSH
34191: LD_INT 0
34193: PUSH
34194: EMPTY
34195: LIST
34196: LIST
34197: PUSH
34198: LD_INT 1
34200: PUSH
34201: LD_INT 1
34203: PUSH
34204: EMPTY
34205: LIST
34206: LIST
34207: PUSH
34208: LD_INT 0
34210: PUSH
34211: LD_INT 1
34213: PUSH
34214: EMPTY
34215: LIST
34216: LIST
34217: PUSH
34218: LD_INT 1
34220: NEG
34221: PUSH
34222: LD_INT 0
34224: PUSH
34225: EMPTY
34226: LIST
34227: LIST
34228: PUSH
34229: LD_INT 1
34231: NEG
34232: PUSH
34233: LD_INT 1
34235: NEG
34236: PUSH
34237: EMPTY
34238: LIST
34239: LIST
34240: PUSH
34241: LD_INT 1
34243: NEG
34244: PUSH
34245: LD_INT 2
34247: NEG
34248: PUSH
34249: EMPTY
34250: LIST
34251: LIST
34252: PUSH
34253: LD_INT 0
34255: PUSH
34256: LD_INT 2
34258: NEG
34259: PUSH
34260: EMPTY
34261: LIST
34262: LIST
34263: PUSH
34264: LD_INT 1
34266: PUSH
34267: LD_INT 1
34269: NEG
34270: PUSH
34271: EMPTY
34272: LIST
34273: LIST
34274: PUSH
34275: LD_INT 1
34277: PUSH
34278: LD_INT 2
34280: PUSH
34281: EMPTY
34282: LIST
34283: LIST
34284: PUSH
34285: LD_INT 0
34287: PUSH
34288: LD_INT 2
34290: PUSH
34291: EMPTY
34292: LIST
34293: LIST
34294: PUSH
34295: LD_INT 1
34297: NEG
34298: PUSH
34299: LD_INT 1
34301: PUSH
34302: EMPTY
34303: LIST
34304: LIST
34305: PUSH
34306: LD_INT 1
34308: PUSH
34309: LD_INT 3
34311: PUSH
34312: EMPTY
34313: LIST
34314: LIST
34315: PUSH
34316: LD_INT 0
34318: PUSH
34319: LD_INT 3
34321: PUSH
34322: EMPTY
34323: LIST
34324: LIST
34325: PUSH
34326: LD_INT 1
34328: NEG
34329: PUSH
34330: LD_INT 2
34332: PUSH
34333: EMPTY
34334: LIST
34335: LIST
34336: PUSH
34337: EMPTY
34338: LIST
34339: LIST
34340: LIST
34341: LIST
34342: LIST
34343: LIST
34344: LIST
34345: LIST
34346: LIST
34347: LIST
34348: LIST
34349: LIST
34350: LIST
34351: LIST
34352: LIST
34353: LIST
34354: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
34355: LD_ADDR_VAR 0 12
34359: PUSH
34360: LD_INT 0
34362: PUSH
34363: LD_INT 0
34365: PUSH
34366: EMPTY
34367: LIST
34368: LIST
34369: PUSH
34370: LD_INT 0
34372: PUSH
34373: LD_INT 1
34375: NEG
34376: PUSH
34377: EMPTY
34378: LIST
34379: LIST
34380: PUSH
34381: LD_INT 1
34383: PUSH
34384: LD_INT 0
34386: PUSH
34387: EMPTY
34388: LIST
34389: LIST
34390: PUSH
34391: LD_INT 1
34393: PUSH
34394: LD_INT 1
34396: PUSH
34397: EMPTY
34398: LIST
34399: LIST
34400: PUSH
34401: LD_INT 0
34403: PUSH
34404: LD_INT 1
34406: PUSH
34407: EMPTY
34408: LIST
34409: LIST
34410: PUSH
34411: LD_INT 1
34413: NEG
34414: PUSH
34415: LD_INT 0
34417: PUSH
34418: EMPTY
34419: LIST
34420: LIST
34421: PUSH
34422: LD_INT 1
34424: NEG
34425: PUSH
34426: LD_INT 1
34428: NEG
34429: PUSH
34430: EMPTY
34431: LIST
34432: LIST
34433: PUSH
34434: LD_INT 1
34436: PUSH
34437: LD_INT 1
34439: NEG
34440: PUSH
34441: EMPTY
34442: LIST
34443: LIST
34444: PUSH
34445: LD_INT 2
34447: PUSH
34448: LD_INT 0
34450: PUSH
34451: EMPTY
34452: LIST
34453: LIST
34454: PUSH
34455: LD_INT 2
34457: PUSH
34458: LD_INT 1
34460: PUSH
34461: EMPTY
34462: LIST
34463: LIST
34464: PUSH
34465: LD_INT 1
34467: NEG
34468: PUSH
34469: LD_INT 1
34471: PUSH
34472: EMPTY
34473: LIST
34474: LIST
34475: PUSH
34476: LD_INT 2
34478: NEG
34479: PUSH
34480: LD_INT 0
34482: PUSH
34483: EMPTY
34484: LIST
34485: LIST
34486: PUSH
34487: LD_INT 2
34489: NEG
34490: PUSH
34491: LD_INT 1
34493: NEG
34494: PUSH
34495: EMPTY
34496: LIST
34497: LIST
34498: PUSH
34499: LD_INT 2
34501: NEG
34502: PUSH
34503: LD_INT 1
34505: PUSH
34506: EMPTY
34507: LIST
34508: LIST
34509: PUSH
34510: LD_INT 3
34512: NEG
34513: PUSH
34514: LD_INT 0
34516: PUSH
34517: EMPTY
34518: LIST
34519: LIST
34520: PUSH
34521: LD_INT 3
34523: NEG
34524: PUSH
34525: LD_INT 1
34527: NEG
34528: PUSH
34529: EMPTY
34530: LIST
34531: LIST
34532: PUSH
34533: EMPTY
34534: LIST
34535: LIST
34536: LIST
34537: LIST
34538: LIST
34539: LIST
34540: LIST
34541: LIST
34542: LIST
34543: LIST
34544: LIST
34545: LIST
34546: LIST
34547: LIST
34548: LIST
34549: LIST
34550: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
34551: LD_ADDR_VAR 0 13
34555: PUSH
34556: LD_INT 0
34558: PUSH
34559: LD_INT 0
34561: PUSH
34562: EMPTY
34563: LIST
34564: LIST
34565: PUSH
34566: LD_INT 0
34568: PUSH
34569: LD_INT 1
34571: NEG
34572: PUSH
34573: EMPTY
34574: LIST
34575: LIST
34576: PUSH
34577: LD_INT 1
34579: PUSH
34580: LD_INT 0
34582: PUSH
34583: EMPTY
34584: LIST
34585: LIST
34586: PUSH
34587: LD_INT 1
34589: PUSH
34590: LD_INT 1
34592: PUSH
34593: EMPTY
34594: LIST
34595: LIST
34596: PUSH
34597: LD_INT 0
34599: PUSH
34600: LD_INT 1
34602: PUSH
34603: EMPTY
34604: LIST
34605: LIST
34606: PUSH
34607: LD_INT 1
34609: NEG
34610: PUSH
34611: LD_INT 0
34613: PUSH
34614: EMPTY
34615: LIST
34616: LIST
34617: PUSH
34618: LD_INT 1
34620: NEG
34621: PUSH
34622: LD_INT 1
34624: NEG
34625: PUSH
34626: EMPTY
34627: LIST
34628: LIST
34629: PUSH
34630: LD_INT 1
34632: NEG
34633: PUSH
34634: LD_INT 2
34636: NEG
34637: PUSH
34638: EMPTY
34639: LIST
34640: LIST
34641: PUSH
34642: LD_INT 2
34644: PUSH
34645: LD_INT 1
34647: PUSH
34648: EMPTY
34649: LIST
34650: LIST
34651: PUSH
34652: LD_INT 2
34654: PUSH
34655: LD_INT 2
34657: PUSH
34658: EMPTY
34659: LIST
34660: LIST
34661: PUSH
34662: LD_INT 1
34664: PUSH
34665: LD_INT 2
34667: PUSH
34668: EMPTY
34669: LIST
34670: LIST
34671: PUSH
34672: LD_INT 2
34674: NEG
34675: PUSH
34676: LD_INT 1
34678: NEG
34679: PUSH
34680: EMPTY
34681: LIST
34682: LIST
34683: PUSH
34684: LD_INT 2
34686: NEG
34687: PUSH
34688: LD_INT 2
34690: NEG
34691: PUSH
34692: EMPTY
34693: LIST
34694: LIST
34695: PUSH
34696: LD_INT 2
34698: NEG
34699: PUSH
34700: LD_INT 3
34702: NEG
34703: PUSH
34704: EMPTY
34705: LIST
34706: LIST
34707: PUSH
34708: LD_INT 3
34710: NEG
34711: PUSH
34712: LD_INT 2
34714: NEG
34715: PUSH
34716: EMPTY
34717: LIST
34718: LIST
34719: PUSH
34720: LD_INT 3
34722: NEG
34723: PUSH
34724: LD_INT 3
34726: NEG
34727: PUSH
34728: EMPTY
34729: LIST
34730: LIST
34731: PUSH
34732: EMPTY
34733: LIST
34734: LIST
34735: LIST
34736: LIST
34737: LIST
34738: LIST
34739: LIST
34740: LIST
34741: LIST
34742: LIST
34743: LIST
34744: LIST
34745: LIST
34746: LIST
34747: LIST
34748: LIST
34749: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
34750: LD_ADDR_VAR 0 14
34754: PUSH
34755: LD_INT 0
34757: PUSH
34758: LD_INT 0
34760: PUSH
34761: EMPTY
34762: LIST
34763: LIST
34764: PUSH
34765: LD_INT 0
34767: PUSH
34768: LD_INT 1
34770: NEG
34771: PUSH
34772: EMPTY
34773: LIST
34774: LIST
34775: PUSH
34776: LD_INT 1
34778: PUSH
34779: LD_INT 0
34781: PUSH
34782: EMPTY
34783: LIST
34784: LIST
34785: PUSH
34786: LD_INT 1
34788: PUSH
34789: LD_INT 1
34791: PUSH
34792: EMPTY
34793: LIST
34794: LIST
34795: PUSH
34796: LD_INT 0
34798: PUSH
34799: LD_INT 1
34801: PUSH
34802: EMPTY
34803: LIST
34804: LIST
34805: PUSH
34806: LD_INT 1
34808: NEG
34809: PUSH
34810: LD_INT 0
34812: PUSH
34813: EMPTY
34814: LIST
34815: LIST
34816: PUSH
34817: LD_INT 1
34819: NEG
34820: PUSH
34821: LD_INT 1
34823: NEG
34824: PUSH
34825: EMPTY
34826: LIST
34827: LIST
34828: PUSH
34829: LD_INT 1
34831: NEG
34832: PUSH
34833: LD_INT 2
34835: NEG
34836: PUSH
34837: EMPTY
34838: LIST
34839: LIST
34840: PUSH
34841: LD_INT 0
34843: PUSH
34844: LD_INT 2
34846: NEG
34847: PUSH
34848: EMPTY
34849: LIST
34850: LIST
34851: PUSH
34852: LD_INT 1
34854: PUSH
34855: LD_INT 1
34857: NEG
34858: PUSH
34859: EMPTY
34860: LIST
34861: LIST
34862: PUSH
34863: LD_INT 1
34865: PUSH
34866: LD_INT 2
34868: PUSH
34869: EMPTY
34870: LIST
34871: LIST
34872: PUSH
34873: LD_INT 0
34875: PUSH
34876: LD_INT 2
34878: PUSH
34879: EMPTY
34880: LIST
34881: LIST
34882: PUSH
34883: LD_INT 1
34885: NEG
34886: PUSH
34887: LD_INT 1
34889: PUSH
34890: EMPTY
34891: LIST
34892: LIST
34893: PUSH
34894: LD_INT 1
34896: NEG
34897: PUSH
34898: LD_INT 3
34900: NEG
34901: PUSH
34902: EMPTY
34903: LIST
34904: LIST
34905: PUSH
34906: LD_INT 0
34908: PUSH
34909: LD_INT 3
34911: NEG
34912: PUSH
34913: EMPTY
34914: LIST
34915: LIST
34916: PUSH
34917: LD_INT 1
34919: PUSH
34920: LD_INT 2
34922: NEG
34923: PUSH
34924: EMPTY
34925: LIST
34926: LIST
34927: PUSH
34928: EMPTY
34929: LIST
34930: LIST
34931: LIST
34932: LIST
34933: LIST
34934: LIST
34935: LIST
34936: LIST
34937: LIST
34938: LIST
34939: LIST
34940: LIST
34941: LIST
34942: LIST
34943: LIST
34944: LIST
34945: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
34946: LD_ADDR_VAR 0 15
34950: PUSH
34951: LD_INT 0
34953: PUSH
34954: LD_INT 0
34956: PUSH
34957: EMPTY
34958: LIST
34959: LIST
34960: PUSH
34961: LD_INT 0
34963: PUSH
34964: LD_INT 1
34966: NEG
34967: PUSH
34968: EMPTY
34969: LIST
34970: LIST
34971: PUSH
34972: LD_INT 1
34974: PUSH
34975: LD_INT 0
34977: PUSH
34978: EMPTY
34979: LIST
34980: LIST
34981: PUSH
34982: LD_INT 1
34984: PUSH
34985: LD_INT 1
34987: PUSH
34988: EMPTY
34989: LIST
34990: LIST
34991: PUSH
34992: LD_INT 0
34994: PUSH
34995: LD_INT 1
34997: PUSH
34998: EMPTY
34999: LIST
35000: LIST
35001: PUSH
35002: LD_INT 1
35004: NEG
35005: PUSH
35006: LD_INT 0
35008: PUSH
35009: EMPTY
35010: LIST
35011: LIST
35012: PUSH
35013: LD_INT 1
35015: NEG
35016: PUSH
35017: LD_INT 1
35019: NEG
35020: PUSH
35021: EMPTY
35022: LIST
35023: LIST
35024: PUSH
35025: LD_INT 1
35027: PUSH
35028: LD_INT 1
35030: NEG
35031: PUSH
35032: EMPTY
35033: LIST
35034: LIST
35035: PUSH
35036: LD_INT 2
35038: PUSH
35039: LD_INT 0
35041: PUSH
35042: EMPTY
35043: LIST
35044: LIST
35045: PUSH
35046: LD_INT 2
35048: PUSH
35049: LD_INT 1
35051: PUSH
35052: EMPTY
35053: LIST
35054: LIST
35055: PUSH
35056: LD_INT 1
35058: NEG
35059: PUSH
35060: LD_INT 1
35062: PUSH
35063: EMPTY
35064: LIST
35065: LIST
35066: PUSH
35067: LD_INT 2
35069: NEG
35070: PUSH
35071: LD_INT 0
35073: PUSH
35074: EMPTY
35075: LIST
35076: LIST
35077: PUSH
35078: LD_INT 2
35080: NEG
35081: PUSH
35082: LD_INT 1
35084: NEG
35085: PUSH
35086: EMPTY
35087: LIST
35088: LIST
35089: PUSH
35090: LD_INT 2
35092: PUSH
35093: LD_INT 1
35095: NEG
35096: PUSH
35097: EMPTY
35098: LIST
35099: LIST
35100: PUSH
35101: LD_INT 3
35103: PUSH
35104: LD_INT 0
35106: PUSH
35107: EMPTY
35108: LIST
35109: LIST
35110: PUSH
35111: LD_INT 3
35113: PUSH
35114: LD_INT 1
35116: PUSH
35117: EMPTY
35118: LIST
35119: LIST
35120: PUSH
35121: EMPTY
35122: LIST
35123: LIST
35124: LIST
35125: LIST
35126: LIST
35127: LIST
35128: LIST
35129: LIST
35130: LIST
35131: LIST
35132: LIST
35133: LIST
35134: LIST
35135: LIST
35136: LIST
35137: LIST
35138: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
35139: LD_ADDR_VAR 0 16
35143: PUSH
35144: LD_INT 0
35146: PUSH
35147: LD_INT 0
35149: PUSH
35150: EMPTY
35151: LIST
35152: LIST
35153: PUSH
35154: LD_INT 0
35156: PUSH
35157: LD_INT 1
35159: NEG
35160: PUSH
35161: EMPTY
35162: LIST
35163: LIST
35164: PUSH
35165: LD_INT 1
35167: PUSH
35168: LD_INT 0
35170: PUSH
35171: EMPTY
35172: LIST
35173: LIST
35174: PUSH
35175: LD_INT 1
35177: PUSH
35178: LD_INT 1
35180: PUSH
35181: EMPTY
35182: LIST
35183: LIST
35184: PUSH
35185: LD_INT 0
35187: PUSH
35188: LD_INT 1
35190: PUSH
35191: EMPTY
35192: LIST
35193: LIST
35194: PUSH
35195: LD_INT 1
35197: NEG
35198: PUSH
35199: LD_INT 0
35201: PUSH
35202: EMPTY
35203: LIST
35204: LIST
35205: PUSH
35206: LD_INT 1
35208: NEG
35209: PUSH
35210: LD_INT 1
35212: NEG
35213: PUSH
35214: EMPTY
35215: LIST
35216: LIST
35217: PUSH
35218: LD_INT 1
35220: NEG
35221: PUSH
35222: LD_INT 2
35224: NEG
35225: PUSH
35226: EMPTY
35227: LIST
35228: LIST
35229: PUSH
35230: LD_INT 2
35232: PUSH
35233: LD_INT 1
35235: PUSH
35236: EMPTY
35237: LIST
35238: LIST
35239: PUSH
35240: LD_INT 2
35242: PUSH
35243: LD_INT 2
35245: PUSH
35246: EMPTY
35247: LIST
35248: LIST
35249: PUSH
35250: LD_INT 1
35252: PUSH
35253: LD_INT 2
35255: PUSH
35256: EMPTY
35257: LIST
35258: LIST
35259: PUSH
35260: LD_INT 2
35262: NEG
35263: PUSH
35264: LD_INT 1
35266: NEG
35267: PUSH
35268: EMPTY
35269: LIST
35270: LIST
35271: PUSH
35272: LD_INT 2
35274: NEG
35275: PUSH
35276: LD_INT 2
35278: NEG
35279: PUSH
35280: EMPTY
35281: LIST
35282: LIST
35283: PUSH
35284: LD_INT 3
35286: PUSH
35287: LD_INT 2
35289: PUSH
35290: EMPTY
35291: LIST
35292: LIST
35293: PUSH
35294: LD_INT 3
35296: PUSH
35297: LD_INT 3
35299: PUSH
35300: EMPTY
35301: LIST
35302: LIST
35303: PUSH
35304: LD_INT 2
35306: PUSH
35307: LD_INT 3
35309: PUSH
35310: EMPTY
35311: LIST
35312: LIST
35313: PUSH
35314: EMPTY
35315: LIST
35316: LIST
35317: LIST
35318: LIST
35319: LIST
35320: LIST
35321: LIST
35322: LIST
35323: LIST
35324: LIST
35325: LIST
35326: LIST
35327: LIST
35328: LIST
35329: LIST
35330: LIST
35331: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
35332: LD_ADDR_VAR 0 17
35336: PUSH
35337: LD_INT 0
35339: PUSH
35340: LD_INT 0
35342: PUSH
35343: EMPTY
35344: LIST
35345: LIST
35346: PUSH
35347: LD_INT 0
35349: PUSH
35350: LD_INT 1
35352: NEG
35353: PUSH
35354: EMPTY
35355: LIST
35356: LIST
35357: PUSH
35358: LD_INT 1
35360: PUSH
35361: LD_INT 0
35363: PUSH
35364: EMPTY
35365: LIST
35366: LIST
35367: PUSH
35368: LD_INT 1
35370: PUSH
35371: LD_INT 1
35373: PUSH
35374: EMPTY
35375: LIST
35376: LIST
35377: PUSH
35378: LD_INT 0
35380: PUSH
35381: LD_INT 1
35383: PUSH
35384: EMPTY
35385: LIST
35386: LIST
35387: PUSH
35388: LD_INT 1
35390: NEG
35391: PUSH
35392: LD_INT 0
35394: PUSH
35395: EMPTY
35396: LIST
35397: LIST
35398: PUSH
35399: LD_INT 1
35401: NEG
35402: PUSH
35403: LD_INT 1
35405: NEG
35406: PUSH
35407: EMPTY
35408: LIST
35409: LIST
35410: PUSH
35411: LD_INT 1
35413: NEG
35414: PUSH
35415: LD_INT 2
35417: NEG
35418: PUSH
35419: EMPTY
35420: LIST
35421: LIST
35422: PUSH
35423: LD_INT 0
35425: PUSH
35426: LD_INT 2
35428: NEG
35429: PUSH
35430: EMPTY
35431: LIST
35432: LIST
35433: PUSH
35434: LD_INT 1
35436: PUSH
35437: LD_INT 1
35439: NEG
35440: PUSH
35441: EMPTY
35442: LIST
35443: LIST
35444: PUSH
35445: LD_INT 2
35447: PUSH
35448: LD_INT 0
35450: PUSH
35451: EMPTY
35452: LIST
35453: LIST
35454: PUSH
35455: LD_INT 2
35457: PUSH
35458: LD_INT 1
35460: PUSH
35461: EMPTY
35462: LIST
35463: LIST
35464: PUSH
35465: LD_INT 2
35467: PUSH
35468: LD_INT 2
35470: PUSH
35471: EMPTY
35472: LIST
35473: LIST
35474: PUSH
35475: LD_INT 1
35477: PUSH
35478: LD_INT 2
35480: PUSH
35481: EMPTY
35482: LIST
35483: LIST
35484: PUSH
35485: LD_INT 0
35487: PUSH
35488: LD_INT 2
35490: PUSH
35491: EMPTY
35492: LIST
35493: LIST
35494: PUSH
35495: LD_INT 1
35497: NEG
35498: PUSH
35499: LD_INT 1
35501: PUSH
35502: EMPTY
35503: LIST
35504: LIST
35505: PUSH
35506: LD_INT 2
35508: NEG
35509: PUSH
35510: LD_INT 0
35512: PUSH
35513: EMPTY
35514: LIST
35515: LIST
35516: PUSH
35517: LD_INT 2
35519: NEG
35520: PUSH
35521: LD_INT 1
35523: NEG
35524: PUSH
35525: EMPTY
35526: LIST
35527: LIST
35528: PUSH
35529: LD_INT 2
35531: NEG
35532: PUSH
35533: LD_INT 2
35535: NEG
35536: PUSH
35537: EMPTY
35538: LIST
35539: LIST
35540: PUSH
35541: EMPTY
35542: LIST
35543: LIST
35544: LIST
35545: LIST
35546: LIST
35547: LIST
35548: LIST
35549: LIST
35550: LIST
35551: LIST
35552: LIST
35553: LIST
35554: LIST
35555: LIST
35556: LIST
35557: LIST
35558: LIST
35559: LIST
35560: LIST
35561: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
35562: LD_ADDR_VAR 0 18
35566: PUSH
35567: LD_INT 0
35569: PUSH
35570: LD_INT 0
35572: PUSH
35573: EMPTY
35574: LIST
35575: LIST
35576: PUSH
35577: LD_INT 0
35579: PUSH
35580: LD_INT 1
35582: NEG
35583: PUSH
35584: EMPTY
35585: LIST
35586: LIST
35587: PUSH
35588: LD_INT 1
35590: PUSH
35591: LD_INT 0
35593: PUSH
35594: EMPTY
35595: LIST
35596: LIST
35597: PUSH
35598: LD_INT 1
35600: PUSH
35601: LD_INT 1
35603: PUSH
35604: EMPTY
35605: LIST
35606: LIST
35607: PUSH
35608: LD_INT 0
35610: PUSH
35611: LD_INT 1
35613: PUSH
35614: EMPTY
35615: LIST
35616: LIST
35617: PUSH
35618: LD_INT 1
35620: NEG
35621: PUSH
35622: LD_INT 0
35624: PUSH
35625: EMPTY
35626: LIST
35627: LIST
35628: PUSH
35629: LD_INT 1
35631: NEG
35632: PUSH
35633: LD_INT 1
35635: NEG
35636: PUSH
35637: EMPTY
35638: LIST
35639: LIST
35640: PUSH
35641: LD_INT 1
35643: NEG
35644: PUSH
35645: LD_INT 2
35647: NEG
35648: PUSH
35649: EMPTY
35650: LIST
35651: LIST
35652: PUSH
35653: LD_INT 0
35655: PUSH
35656: LD_INT 2
35658: NEG
35659: PUSH
35660: EMPTY
35661: LIST
35662: LIST
35663: PUSH
35664: LD_INT 1
35666: PUSH
35667: LD_INT 1
35669: NEG
35670: PUSH
35671: EMPTY
35672: LIST
35673: LIST
35674: PUSH
35675: LD_INT 2
35677: PUSH
35678: LD_INT 0
35680: PUSH
35681: EMPTY
35682: LIST
35683: LIST
35684: PUSH
35685: LD_INT 2
35687: PUSH
35688: LD_INT 1
35690: PUSH
35691: EMPTY
35692: LIST
35693: LIST
35694: PUSH
35695: LD_INT 2
35697: PUSH
35698: LD_INT 2
35700: PUSH
35701: EMPTY
35702: LIST
35703: LIST
35704: PUSH
35705: LD_INT 1
35707: PUSH
35708: LD_INT 2
35710: PUSH
35711: EMPTY
35712: LIST
35713: LIST
35714: PUSH
35715: LD_INT 0
35717: PUSH
35718: LD_INT 2
35720: PUSH
35721: EMPTY
35722: LIST
35723: LIST
35724: PUSH
35725: LD_INT 1
35727: NEG
35728: PUSH
35729: LD_INT 1
35731: PUSH
35732: EMPTY
35733: LIST
35734: LIST
35735: PUSH
35736: LD_INT 2
35738: NEG
35739: PUSH
35740: LD_INT 0
35742: PUSH
35743: EMPTY
35744: LIST
35745: LIST
35746: PUSH
35747: LD_INT 2
35749: NEG
35750: PUSH
35751: LD_INT 1
35753: NEG
35754: PUSH
35755: EMPTY
35756: LIST
35757: LIST
35758: PUSH
35759: LD_INT 2
35761: NEG
35762: PUSH
35763: LD_INT 2
35765: NEG
35766: PUSH
35767: EMPTY
35768: LIST
35769: LIST
35770: PUSH
35771: EMPTY
35772: LIST
35773: LIST
35774: LIST
35775: LIST
35776: LIST
35777: LIST
35778: LIST
35779: LIST
35780: LIST
35781: LIST
35782: LIST
35783: LIST
35784: LIST
35785: LIST
35786: LIST
35787: LIST
35788: LIST
35789: LIST
35790: LIST
35791: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
35792: LD_ADDR_VAR 0 19
35796: PUSH
35797: LD_INT 0
35799: PUSH
35800: LD_INT 0
35802: PUSH
35803: EMPTY
35804: LIST
35805: LIST
35806: PUSH
35807: LD_INT 0
35809: PUSH
35810: LD_INT 1
35812: NEG
35813: PUSH
35814: EMPTY
35815: LIST
35816: LIST
35817: PUSH
35818: LD_INT 1
35820: PUSH
35821: LD_INT 0
35823: PUSH
35824: EMPTY
35825: LIST
35826: LIST
35827: PUSH
35828: LD_INT 1
35830: PUSH
35831: LD_INT 1
35833: PUSH
35834: EMPTY
35835: LIST
35836: LIST
35837: PUSH
35838: LD_INT 0
35840: PUSH
35841: LD_INT 1
35843: PUSH
35844: EMPTY
35845: LIST
35846: LIST
35847: PUSH
35848: LD_INT 1
35850: NEG
35851: PUSH
35852: LD_INT 0
35854: PUSH
35855: EMPTY
35856: LIST
35857: LIST
35858: PUSH
35859: LD_INT 1
35861: NEG
35862: PUSH
35863: LD_INT 1
35865: NEG
35866: PUSH
35867: EMPTY
35868: LIST
35869: LIST
35870: PUSH
35871: LD_INT 1
35873: NEG
35874: PUSH
35875: LD_INT 2
35877: NEG
35878: PUSH
35879: EMPTY
35880: LIST
35881: LIST
35882: PUSH
35883: LD_INT 0
35885: PUSH
35886: LD_INT 2
35888: NEG
35889: PUSH
35890: EMPTY
35891: LIST
35892: LIST
35893: PUSH
35894: LD_INT 1
35896: PUSH
35897: LD_INT 1
35899: NEG
35900: PUSH
35901: EMPTY
35902: LIST
35903: LIST
35904: PUSH
35905: LD_INT 2
35907: PUSH
35908: LD_INT 0
35910: PUSH
35911: EMPTY
35912: LIST
35913: LIST
35914: PUSH
35915: LD_INT 2
35917: PUSH
35918: LD_INT 1
35920: PUSH
35921: EMPTY
35922: LIST
35923: LIST
35924: PUSH
35925: LD_INT 2
35927: PUSH
35928: LD_INT 2
35930: PUSH
35931: EMPTY
35932: LIST
35933: LIST
35934: PUSH
35935: LD_INT 1
35937: PUSH
35938: LD_INT 2
35940: PUSH
35941: EMPTY
35942: LIST
35943: LIST
35944: PUSH
35945: LD_INT 0
35947: PUSH
35948: LD_INT 2
35950: PUSH
35951: EMPTY
35952: LIST
35953: LIST
35954: PUSH
35955: LD_INT 1
35957: NEG
35958: PUSH
35959: LD_INT 1
35961: PUSH
35962: EMPTY
35963: LIST
35964: LIST
35965: PUSH
35966: LD_INT 2
35968: NEG
35969: PUSH
35970: LD_INT 0
35972: PUSH
35973: EMPTY
35974: LIST
35975: LIST
35976: PUSH
35977: LD_INT 2
35979: NEG
35980: PUSH
35981: LD_INT 1
35983: NEG
35984: PUSH
35985: EMPTY
35986: LIST
35987: LIST
35988: PUSH
35989: LD_INT 2
35991: NEG
35992: PUSH
35993: LD_INT 2
35995: NEG
35996: PUSH
35997: EMPTY
35998: LIST
35999: LIST
36000: PUSH
36001: EMPTY
36002: LIST
36003: LIST
36004: LIST
36005: LIST
36006: LIST
36007: LIST
36008: LIST
36009: LIST
36010: LIST
36011: LIST
36012: LIST
36013: LIST
36014: LIST
36015: LIST
36016: LIST
36017: LIST
36018: LIST
36019: LIST
36020: LIST
36021: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
36022: LD_ADDR_VAR 0 20
36026: PUSH
36027: LD_INT 0
36029: PUSH
36030: LD_INT 0
36032: PUSH
36033: EMPTY
36034: LIST
36035: LIST
36036: PUSH
36037: LD_INT 0
36039: PUSH
36040: LD_INT 1
36042: NEG
36043: PUSH
36044: EMPTY
36045: LIST
36046: LIST
36047: PUSH
36048: LD_INT 1
36050: PUSH
36051: LD_INT 0
36053: PUSH
36054: EMPTY
36055: LIST
36056: LIST
36057: PUSH
36058: LD_INT 1
36060: PUSH
36061: LD_INT 1
36063: PUSH
36064: EMPTY
36065: LIST
36066: LIST
36067: PUSH
36068: LD_INT 0
36070: PUSH
36071: LD_INT 1
36073: PUSH
36074: EMPTY
36075: LIST
36076: LIST
36077: PUSH
36078: LD_INT 1
36080: NEG
36081: PUSH
36082: LD_INT 0
36084: PUSH
36085: EMPTY
36086: LIST
36087: LIST
36088: PUSH
36089: LD_INT 1
36091: NEG
36092: PUSH
36093: LD_INT 1
36095: NEG
36096: PUSH
36097: EMPTY
36098: LIST
36099: LIST
36100: PUSH
36101: LD_INT 1
36103: NEG
36104: PUSH
36105: LD_INT 2
36107: NEG
36108: PUSH
36109: EMPTY
36110: LIST
36111: LIST
36112: PUSH
36113: LD_INT 0
36115: PUSH
36116: LD_INT 2
36118: NEG
36119: PUSH
36120: EMPTY
36121: LIST
36122: LIST
36123: PUSH
36124: LD_INT 1
36126: PUSH
36127: LD_INT 1
36129: NEG
36130: PUSH
36131: EMPTY
36132: LIST
36133: LIST
36134: PUSH
36135: LD_INT 2
36137: PUSH
36138: LD_INT 0
36140: PUSH
36141: EMPTY
36142: LIST
36143: LIST
36144: PUSH
36145: LD_INT 2
36147: PUSH
36148: LD_INT 1
36150: PUSH
36151: EMPTY
36152: LIST
36153: LIST
36154: PUSH
36155: LD_INT 2
36157: PUSH
36158: LD_INT 2
36160: PUSH
36161: EMPTY
36162: LIST
36163: LIST
36164: PUSH
36165: LD_INT 1
36167: PUSH
36168: LD_INT 2
36170: PUSH
36171: EMPTY
36172: LIST
36173: LIST
36174: PUSH
36175: LD_INT 0
36177: PUSH
36178: LD_INT 2
36180: PUSH
36181: EMPTY
36182: LIST
36183: LIST
36184: PUSH
36185: LD_INT 1
36187: NEG
36188: PUSH
36189: LD_INT 1
36191: PUSH
36192: EMPTY
36193: LIST
36194: LIST
36195: PUSH
36196: LD_INT 2
36198: NEG
36199: PUSH
36200: LD_INT 0
36202: PUSH
36203: EMPTY
36204: LIST
36205: LIST
36206: PUSH
36207: LD_INT 2
36209: NEG
36210: PUSH
36211: LD_INT 1
36213: NEG
36214: PUSH
36215: EMPTY
36216: LIST
36217: LIST
36218: PUSH
36219: LD_INT 2
36221: NEG
36222: PUSH
36223: LD_INT 2
36225: NEG
36226: PUSH
36227: EMPTY
36228: LIST
36229: LIST
36230: PUSH
36231: EMPTY
36232: LIST
36233: LIST
36234: LIST
36235: LIST
36236: LIST
36237: LIST
36238: LIST
36239: LIST
36240: LIST
36241: LIST
36242: LIST
36243: LIST
36244: LIST
36245: LIST
36246: LIST
36247: LIST
36248: LIST
36249: LIST
36250: LIST
36251: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
36252: LD_ADDR_VAR 0 21
36256: PUSH
36257: LD_INT 0
36259: PUSH
36260: LD_INT 0
36262: PUSH
36263: EMPTY
36264: LIST
36265: LIST
36266: PUSH
36267: LD_INT 0
36269: PUSH
36270: LD_INT 1
36272: NEG
36273: PUSH
36274: EMPTY
36275: LIST
36276: LIST
36277: PUSH
36278: LD_INT 1
36280: PUSH
36281: LD_INT 0
36283: PUSH
36284: EMPTY
36285: LIST
36286: LIST
36287: PUSH
36288: LD_INT 1
36290: PUSH
36291: LD_INT 1
36293: PUSH
36294: EMPTY
36295: LIST
36296: LIST
36297: PUSH
36298: LD_INT 0
36300: PUSH
36301: LD_INT 1
36303: PUSH
36304: EMPTY
36305: LIST
36306: LIST
36307: PUSH
36308: LD_INT 1
36310: NEG
36311: PUSH
36312: LD_INT 0
36314: PUSH
36315: EMPTY
36316: LIST
36317: LIST
36318: PUSH
36319: LD_INT 1
36321: NEG
36322: PUSH
36323: LD_INT 1
36325: NEG
36326: PUSH
36327: EMPTY
36328: LIST
36329: LIST
36330: PUSH
36331: LD_INT 1
36333: NEG
36334: PUSH
36335: LD_INT 2
36337: NEG
36338: PUSH
36339: EMPTY
36340: LIST
36341: LIST
36342: PUSH
36343: LD_INT 0
36345: PUSH
36346: LD_INT 2
36348: NEG
36349: PUSH
36350: EMPTY
36351: LIST
36352: LIST
36353: PUSH
36354: LD_INT 1
36356: PUSH
36357: LD_INT 1
36359: NEG
36360: PUSH
36361: EMPTY
36362: LIST
36363: LIST
36364: PUSH
36365: LD_INT 2
36367: PUSH
36368: LD_INT 0
36370: PUSH
36371: EMPTY
36372: LIST
36373: LIST
36374: PUSH
36375: LD_INT 2
36377: PUSH
36378: LD_INT 1
36380: PUSH
36381: EMPTY
36382: LIST
36383: LIST
36384: PUSH
36385: LD_INT 2
36387: PUSH
36388: LD_INT 2
36390: PUSH
36391: EMPTY
36392: LIST
36393: LIST
36394: PUSH
36395: LD_INT 1
36397: PUSH
36398: LD_INT 2
36400: PUSH
36401: EMPTY
36402: LIST
36403: LIST
36404: PUSH
36405: LD_INT 0
36407: PUSH
36408: LD_INT 2
36410: PUSH
36411: EMPTY
36412: LIST
36413: LIST
36414: PUSH
36415: LD_INT 1
36417: NEG
36418: PUSH
36419: LD_INT 1
36421: PUSH
36422: EMPTY
36423: LIST
36424: LIST
36425: PUSH
36426: LD_INT 2
36428: NEG
36429: PUSH
36430: LD_INT 0
36432: PUSH
36433: EMPTY
36434: LIST
36435: LIST
36436: PUSH
36437: LD_INT 2
36439: NEG
36440: PUSH
36441: LD_INT 1
36443: NEG
36444: PUSH
36445: EMPTY
36446: LIST
36447: LIST
36448: PUSH
36449: LD_INT 2
36451: NEG
36452: PUSH
36453: LD_INT 2
36455: NEG
36456: PUSH
36457: EMPTY
36458: LIST
36459: LIST
36460: PUSH
36461: EMPTY
36462: LIST
36463: LIST
36464: LIST
36465: LIST
36466: LIST
36467: LIST
36468: LIST
36469: LIST
36470: LIST
36471: LIST
36472: LIST
36473: LIST
36474: LIST
36475: LIST
36476: LIST
36477: LIST
36478: LIST
36479: LIST
36480: LIST
36481: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
36482: LD_ADDR_VAR 0 22
36486: PUSH
36487: LD_INT 0
36489: PUSH
36490: LD_INT 0
36492: PUSH
36493: EMPTY
36494: LIST
36495: LIST
36496: PUSH
36497: LD_INT 0
36499: PUSH
36500: LD_INT 1
36502: NEG
36503: PUSH
36504: EMPTY
36505: LIST
36506: LIST
36507: PUSH
36508: LD_INT 1
36510: PUSH
36511: LD_INT 0
36513: PUSH
36514: EMPTY
36515: LIST
36516: LIST
36517: PUSH
36518: LD_INT 1
36520: PUSH
36521: LD_INT 1
36523: PUSH
36524: EMPTY
36525: LIST
36526: LIST
36527: PUSH
36528: LD_INT 0
36530: PUSH
36531: LD_INT 1
36533: PUSH
36534: EMPTY
36535: LIST
36536: LIST
36537: PUSH
36538: LD_INT 1
36540: NEG
36541: PUSH
36542: LD_INT 0
36544: PUSH
36545: EMPTY
36546: LIST
36547: LIST
36548: PUSH
36549: LD_INT 1
36551: NEG
36552: PUSH
36553: LD_INT 1
36555: NEG
36556: PUSH
36557: EMPTY
36558: LIST
36559: LIST
36560: PUSH
36561: LD_INT 1
36563: NEG
36564: PUSH
36565: LD_INT 2
36567: NEG
36568: PUSH
36569: EMPTY
36570: LIST
36571: LIST
36572: PUSH
36573: LD_INT 0
36575: PUSH
36576: LD_INT 2
36578: NEG
36579: PUSH
36580: EMPTY
36581: LIST
36582: LIST
36583: PUSH
36584: LD_INT 1
36586: PUSH
36587: LD_INT 1
36589: NEG
36590: PUSH
36591: EMPTY
36592: LIST
36593: LIST
36594: PUSH
36595: LD_INT 2
36597: PUSH
36598: LD_INT 0
36600: PUSH
36601: EMPTY
36602: LIST
36603: LIST
36604: PUSH
36605: LD_INT 2
36607: PUSH
36608: LD_INT 1
36610: PUSH
36611: EMPTY
36612: LIST
36613: LIST
36614: PUSH
36615: LD_INT 2
36617: PUSH
36618: LD_INT 2
36620: PUSH
36621: EMPTY
36622: LIST
36623: LIST
36624: PUSH
36625: LD_INT 1
36627: PUSH
36628: LD_INT 2
36630: PUSH
36631: EMPTY
36632: LIST
36633: LIST
36634: PUSH
36635: LD_INT 0
36637: PUSH
36638: LD_INT 2
36640: PUSH
36641: EMPTY
36642: LIST
36643: LIST
36644: PUSH
36645: LD_INT 1
36647: NEG
36648: PUSH
36649: LD_INT 1
36651: PUSH
36652: EMPTY
36653: LIST
36654: LIST
36655: PUSH
36656: LD_INT 2
36658: NEG
36659: PUSH
36660: LD_INT 0
36662: PUSH
36663: EMPTY
36664: LIST
36665: LIST
36666: PUSH
36667: LD_INT 2
36669: NEG
36670: PUSH
36671: LD_INT 1
36673: NEG
36674: PUSH
36675: EMPTY
36676: LIST
36677: LIST
36678: PUSH
36679: LD_INT 2
36681: NEG
36682: PUSH
36683: LD_INT 2
36685: NEG
36686: PUSH
36687: EMPTY
36688: LIST
36689: LIST
36690: PUSH
36691: EMPTY
36692: LIST
36693: LIST
36694: LIST
36695: LIST
36696: LIST
36697: LIST
36698: LIST
36699: LIST
36700: LIST
36701: LIST
36702: LIST
36703: LIST
36704: LIST
36705: LIST
36706: LIST
36707: LIST
36708: LIST
36709: LIST
36710: LIST
36711: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
36712: LD_ADDR_VAR 0 23
36716: PUSH
36717: LD_INT 0
36719: PUSH
36720: LD_INT 0
36722: PUSH
36723: EMPTY
36724: LIST
36725: LIST
36726: PUSH
36727: LD_INT 0
36729: PUSH
36730: LD_INT 1
36732: NEG
36733: PUSH
36734: EMPTY
36735: LIST
36736: LIST
36737: PUSH
36738: LD_INT 1
36740: PUSH
36741: LD_INT 0
36743: PUSH
36744: EMPTY
36745: LIST
36746: LIST
36747: PUSH
36748: LD_INT 1
36750: PUSH
36751: LD_INT 1
36753: PUSH
36754: EMPTY
36755: LIST
36756: LIST
36757: PUSH
36758: LD_INT 0
36760: PUSH
36761: LD_INT 1
36763: PUSH
36764: EMPTY
36765: LIST
36766: LIST
36767: PUSH
36768: LD_INT 1
36770: NEG
36771: PUSH
36772: LD_INT 0
36774: PUSH
36775: EMPTY
36776: LIST
36777: LIST
36778: PUSH
36779: LD_INT 1
36781: NEG
36782: PUSH
36783: LD_INT 1
36785: NEG
36786: PUSH
36787: EMPTY
36788: LIST
36789: LIST
36790: PUSH
36791: LD_INT 1
36793: NEG
36794: PUSH
36795: LD_INT 2
36797: NEG
36798: PUSH
36799: EMPTY
36800: LIST
36801: LIST
36802: PUSH
36803: LD_INT 0
36805: PUSH
36806: LD_INT 2
36808: NEG
36809: PUSH
36810: EMPTY
36811: LIST
36812: LIST
36813: PUSH
36814: LD_INT 1
36816: PUSH
36817: LD_INT 1
36819: NEG
36820: PUSH
36821: EMPTY
36822: LIST
36823: LIST
36824: PUSH
36825: LD_INT 2
36827: PUSH
36828: LD_INT 0
36830: PUSH
36831: EMPTY
36832: LIST
36833: LIST
36834: PUSH
36835: LD_INT 2
36837: PUSH
36838: LD_INT 1
36840: PUSH
36841: EMPTY
36842: LIST
36843: LIST
36844: PUSH
36845: LD_INT 2
36847: PUSH
36848: LD_INT 2
36850: PUSH
36851: EMPTY
36852: LIST
36853: LIST
36854: PUSH
36855: LD_INT 1
36857: PUSH
36858: LD_INT 2
36860: PUSH
36861: EMPTY
36862: LIST
36863: LIST
36864: PUSH
36865: LD_INT 0
36867: PUSH
36868: LD_INT 2
36870: PUSH
36871: EMPTY
36872: LIST
36873: LIST
36874: PUSH
36875: LD_INT 1
36877: NEG
36878: PUSH
36879: LD_INT 1
36881: PUSH
36882: EMPTY
36883: LIST
36884: LIST
36885: PUSH
36886: LD_INT 2
36888: NEG
36889: PUSH
36890: LD_INT 0
36892: PUSH
36893: EMPTY
36894: LIST
36895: LIST
36896: PUSH
36897: LD_INT 2
36899: NEG
36900: PUSH
36901: LD_INT 1
36903: NEG
36904: PUSH
36905: EMPTY
36906: LIST
36907: LIST
36908: PUSH
36909: LD_INT 2
36911: NEG
36912: PUSH
36913: LD_INT 2
36915: NEG
36916: PUSH
36917: EMPTY
36918: LIST
36919: LIST
36920: PUSH
36921: LD_INT 2
36923: NEG
36924: PUSH
36925: LD_INT 3
36927: NEG
36928: PUSH
36929: EMPTY
36930: LIST
36931: LIST
36932: PUSH
36933: LD_INT 1
36935: NEG
36936: PUSH
36937: LD_INT 3
36939: NEG
36940: PUSH
36941: EMPTY
36942: LIST
36943: LIST
36944: PUSH
36945: LD_INT 1
36947: PUSH
36948: LD_INT 2
36950: NEG
36951: PUSH
36952: EMPTY
36953: LIST
36954: LIST
36955: PUSH
36956: LD_INT 2
36958: PUSH
36959: LD_INT 1
36961: NEG
36962: PUSH
36963: EMPTY
36964: LIST
36965: LIST
36966: PUSH
36967: EMPTY
36968: LIST
36969: LIST
36970: LIST
36971: LIST
36972: LIST
36973: LIST
36974: LIST
36975: LIST
36976: LIST
36977: LIST
36978: LIST
36979: LIST
36980: LIST
36981: LIST
36982: LIST
36983: LIST
36984: LIST
36985: LIST
36986: LIST
36987: LIST
36988: LIST
36989: LIST
36990: LIST
36991: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
36992: LD_ADDR_VAR 0 24
36996: PUSH
36997: LD_INT 0
36999: PUSH
37000: LD_INT 0
37002: PUSH
37003: EMPTY
37004: LIST
37005: LIST
37006: PUSH
37007: LD_INT 0
37009: PUSH
37010: LD_INT 1
37012: NEG
37013: PUSH
37014: EMPTY
37015: LIST
37016: LIST
37017: PUSH
37018: LD_INT 1
37020: PUSH
37021: LD_INT 0
37023: PUSH
37024: EMPTY
37025: LIST
37026: LIST
37027: PUSH
37028: LD_INT 1
37030: PUSH
37031: LD_INT 1
37033: PUSH
37034: EMPTY
37035: LIST
37036: LIST
37037: PUSH
37038: LD_INT 0
37040: PUSH
37041: LD_INT 1
37043: PUSH
37044: EMPTY
37045: LIST
37046: LIST
37047: PUSH
37048: LD_INT 1
37050: NEG
37051: PUSH
37052: LD_INT 0
37054: PUSH
37055: EMPTY
37056: LIST
37057: LIST
37058: PUSH
37059: LD_INT 1
37061: NEG
37062: PUSH
37063: LD_INT 1
37065: NEG
37066: PUSH
37067: EMPTY
37068: LIST
37069: LIST
37070: PUSH
37071: LD_INT 1
37073: NEG
37074: PUSH
37075: LD_INT 2
37077: NEG
37078: PUSH
37079: EMPTY
37080: LIST
37081: LIST
37082: PUSH
37083: LD_INT 0
37085: PUSH
37086: LD_INT 2
37088: NEG
37089: PUSH
37090: EMPTY
37091: LIST
37092: LIST
37093: PUSH
37094: LD_INT 1
37096: PUSH
37097: LD_INT 1
37099: NEG
37100: PUSH
37101: EMPTY
37102: LIST
37103: LIST
37104: PUSH
37105: LD_INT 2
37107: PUSH
37108: LD_INT 0
37110: PUSH
37111: EMPTY
37112: LIST
37113: LIST
37114: PUSH
37115: LD_INT 2
37117: PUSH
37118: LD_INT 1
37120: PUSH
37121: EMPTY
37122: LIST
37123: LIST
37124: PUSH
37125: LD_INT 2
37127: PUSH
37128: LD_INT 2
37130: PUSH
37131: EMPTY
37132: LIST
37133: LIST
37134: PUSH
37135: LD_INT 1
37137: PUSH
37138: LD_INT 2
37140: PUSH
37141: EMPTY
37142: LIST
37143: LIST
37144: PUSH
37145: LD_INT 0
37147: PUSH
37148: LD_INT 2
37150: PUSH
37151: EMPTY
37152: LIST
37153: LIST
37154: PUSH
37155: LD_INT 1
37157: NEG
37158: PUSH
37159: LD_INT 1
37161: PUSH
37162: EMPTY
37163: LIST
37164: LIST
37165: PUSH
37166: LD_INT 2
37168: NEG
37169: PUSH
37170: LD_INT 0
37172: PUSH
37173: EMPTY
37174: LIST
37175: LIST
37176: PUSH
37177: LD_INT 2
37179: NEG
37180: PUSH
37181: LD_INT 1
37183: NEG
37184: PUSH
37185: EMPTY
37186: LIST
37187: LIST
37188: PUSH
37189: LD_INT 2
37191: NEG
37192: PUSH
37193: LD_INT 2
37195: NEG
37196: PUSH
37197: EMPTY
37198: LIST
37199: LIST
37200: PUSH
37201: LD_INT 1
37203: PUSH
37204: LD_INT 2
37206: NEG
37207: PUSH
37208: EMPTY
37209: LIST
37210: LIST
37211: PUSH
37212: LD_INT 2
37214: PUSH
37215: LD_INT 1
37217: NEG
37218: PUSH
37219: EMPTY
37220: LIST
37221: LIST
37222: PUSH
37223: LD_INT 3
37225: PUSH
37226: LD_INT 1
37228: PUSH
37229: EMPTY
37230: LIST
37231: LIST
37232: PUSH
37233: LD_INT 3
37235: PUSH
37236: LD_INT 2
37238: PUSH
37239: EMPTY
37240: LIST
37241: LIST
37242: PUSH
37243: EMPTY
37244: LIST
37245: LIST
37246: LIST
37247: LIST
37248: LIST
37249: LIST
37250: LIST
37251: LIST
37252: LIST
37253: LIST
37254: LIST
37255: LIST
37256: LIST
37257: LIST
37258: LIST
37259: LIST
37260: LIST
37261: LIST
37262: LIST
37263: LIST
37264: LIST
37265: LIST
37266: LIST
37267: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
37268: LD_ADDR_VAR 0 25
37272: PUSH
37273: LD_INT 0
37275: PUSH
37276: LD_INT 0
37278: PUSH
37279: EMPTY
37280: LIST
37281: LIST
37282: PUSH
37283: LD_INT 0
37285: PUSH
37286: LD_INT 1
37288: NEG
37289: PUSH
37290: EMPTY
37291: LIST
37292: LIST
37293: PUSH
37294: LD_INT 1
37296: PUSH
37297: LD_INT 0
37299: PUSH
37300: EMPTY
37301: LIST
37302: LIST
37303: PUSH
37304: LD_INT 1
37306: PUSH
37307: LD_INT 1
37309: PUSH
37310: EMPTY
37311: LIST
37312: LIST
37313: PUSH
37314: LD_INT 0
37316: PUSH
37317: LD_INT 1
37319: PUSH
37320: EMPTY
37321: LIST
37322: LIST
37323: PUSH
37324: LD_INT 1
37326: NEG
37327: PUSH
37328: LD_INT 0
37330: PUSH
37331: EMPTY
37332: LIST
37333: LIST
37334: PUSH
37335: LD_INT 1
37337: NEG
37338: PUSH
37339: LD_INT 1
37341: NEG
37342: PUSH
37343: EMPTY
37344: LIST
37345: LIST
37346: PUSH
37347: LD_INT 1
37349: NEG
37350: PUSH
37351: LD_INT 2
37353: NEG
37354: PUSH
37355: EMPTY
37356: LIST
37357: LIST
37358: PUSH
37359: LD_INT 0
37361: PUSH
37362: LD_INT 2
37364: NEG
37365: PUSH
37366: EMPTY
37367: LIST
37368: LIST
37369: PUSH
37370: LD_INT 1
37372: PUSH
37373: LD_INT 1
37375: NEG
37376: PUSH
37377: EMPTY
37378: LIST
37379: LIST
37380: PUSH
37381: LD_INT 2
37383: PUSH
37384: LD_INT 0
37386: PUSH
37387: EMPTY
37388: LIST
37389: LIST
37390: PUSH
37391: LD_INT 2
37393: PUSH
37394: LD_INT 1
37396: PUSH
37397: EMPTY
37398: LIST
37399: LIST
37400: PUSH
37401: LD_INT 2
37403: PUSH
37404: LD_INT 2
37406: PUSH
37407: EMPTY
37408: LIST
37409: LIST
37410: PUSH
37411: LD_INT 1
37413: PUSH
37414: LD_INT 2
37416: PUSH
37417: EMPTY
37418: LIST
37419: LIST
37420: PUSH
37421: LD_INT 0
37423: PUSH
37424: LD_INT 2
37426: PUSH
37427: EMPTY
37428: LIST
37429: LIST
37430: PUSH
37431: LD_INT 1
37433: NEG
37434: PUSH
37435: LD_INT 1
37437: PUSH
37438: EMPTY
37439: LIST
37440: LIST
37441: PUSH
37442: LD_INT 2
37444: NEG
37445: PUSH
37446: LD_INT 0
37448: PUSH
37449: EMPTY
37450: LIST
37451: LIST
37452: PUSH
37453: LD_INT 2
37455: NEG
37456: PUSH
37457: LD_INT 1
37459: NEG
37460: PUSH
37461: EMPTY
37462: LIST
37463: LIST
37464: PUSH
37465: LD_INT 2
37467: NEG
37468: PUSH
37469: LD_INT 2
37471: NEG
37472: PUSH
37473: EMPTY
37474: LIST
37475: LIST
37476: PUSH
37477: LD_INT 3
37479: PUSH
37480: LD_INT 1
37482: PUSH
37483: EMPTY
37484: LIST
37485: LIST
37486: PUSH
37487: LD_INT 3
37489: PUSH
37490: LD_INT 2
37492: PUSH
37493: EMPTY
37494: LIST
37495: LIST
37496: PUSH
37497: LD_INT 2
37499: PUSH
37500: LD_INT 3
37502: PUSH
37503: EMPTY
37504: LIST
37505: LIST
37506: PUSH
37507: LD_INT 1
37509: PUSH
37510: LD_INT 3
37512: PUSH
37513: EMPTY
37514: LIST
37515: LIST
37516: PUSH
37517: EMPTY
37518: LIST
37519: LIST
37520: LIST
37521: LIST
37522: LIST
37523: LIST
37524: LIST
37525: LIST
37526: LIST
37527: LIST
37528: LIST
37529: LIST
37530: LIST
37531: LIST
37532: LIST
37533: LIST
37534: LIST
37535: LIST
37536: LIST
37537: LIST
37538: LIST
37539: LIST
37540: LIST
37541: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
37542: LD_ADDR_VAR 0 26
37546: PUSH
37547: LD_INT 0
37549: PUSH
37550: LD_INT 0
37552: PUSH
37553: EMPTY
37554: LIST
37555: LIST
37556: PUSH
37557: LD_INT 0
37559: PUSH
37560: LD_INT 1
37562: NEG
37563: PUSH
37564: EMPTY
37565: LIST
37566: LIST
37567: PUSH
37568: LD_INT 1
37570: PUSH
37571: LD_INT 0
37573: PUSH
37574: EMPTY
37575: LIST
37576: LIST
37577: PUSH
37578: LD_INT 1
37580: PUSH
37581: LD_INT 1
37583: PUSH
37584: EMPTY
37585: LIST
37586: LIST
37587: PUSH
37588: LD_INT 0
37590: PUSH
37591: LD_INT 1
37593: PUSH
37594: EMPTY
37595: LIST
37596: LIST
37597: PUSH
37598: LD_INT 1
37600: NEG
37601: PUSH
37602: LD_INT 0
37604: PUSH
37605: EMPTY
37606: LIST
37607: LIST
37608: PUSH
37609: LD_INT 1
37611: NEG
37612: PUSH
37613: LD_INT 1
37615: NEG
37616: PUSH
37617: EMPTY
37618: LIST
37619: LIST
37620: PUSH
37621: LD_INT 1
37623: NEG
37624: PUSH
37625: LD_INT 2
37627: NEG
37628: PUSH
37629: EMPTY
37630: LIST
37631: LIST
37632: PUSH
37633: LD_INT 0
37635: PUSH
37636: LD_INT 2
37638: NEG
37639: PUSH
37640: EMPTY
37641: LIST
37642: LIST
37643: PUSH
37644: LD_INT 1
37646: PUSH
37647: LD_INT 1
37649: NEG
37650: PUSH
37651: EMPTY
37652: LIST
37653: LIST
37654: PUSH
37655: LD_INT 2
37657: PUSH
37658: LD_INT 0
37660: PUSH
37661: EMPTY
37662: LIST
37663: LIST
37664: PUSH
37665: LD_INT 2
37667: PUSH
37668: LD_INT 1
37670: PUSH
37671: EMPTY
37672: LIST
37673: LIST
37674: PUSH
37675: LD_INT 2
37677: PUSH
37678: LD_INT 2
37680: PUSH
37681: EMPTY
37682: LIST
37683: LIST
37684: PUSH
37685: LD_INT 1
37687: PUSH
37688: LD_INT 2
37690: PUSH
37691: EMPTY
37692: LIST
37693: LIST
37694: PUSH
37695: LD_INT 0
37697: PUSH
37698: LD_INT 2
37700: PUSH
37701: EMPTY
37702: LIST
37703: LIST
37704: PUSH
37705: LD_INT 1
37707: NEG
37708: PUSH
37709: LD_INT 1
37711: PUSH
37712: EMPTY
37713: LIST
37714: LIST
37715: PUSH
37716: LD_INT 2
37718: NEG
37719: PUSH
37720: LD_INT 0
37722: PUSH
37723: EMPTY
37724: LIST
37725: LIST
37726: PUSH
37727: LD_INT 2
37729: NEG
37730: PUSH
37731: LD_INT 1
37733: NEG
37734: PUSH
37735: EMPTY
37736: LIST
37737: LIST
37738: PUSH
37739: LD_INT 2
37741: NEG
37742: PUSH
37743: LD_INT 2
37745: NEG
37746: PUSH
37747: EMPTY
37748: LIST
37749: LIST
37750: PUSH
37751: LD_INT 2
37753: PUSH
37754: LD_INT 3
37756: PUSH
37757: EMPTY
37758: LIST
37759: LIST
37760: PUSH
37761: LD_INT 1
37763: PUSH
37764: LD_INT 3
37766: PUSH
37767: EMPTY
37768: LIST
37769: LIST
37770: PUSH
37771: LD_INT 1
37773: NEG
37774: PUSH
37775: LD_INT 2
37777: PUSH
37778: EMPTY
37779: LIST
37780: LIST
37781: PUSH
37782: LD_INT 2
37784: NEG
37785: PUSH
37786: LD_INT 1
37788: PUSH
37789: EMPTY
37790: LIST
37791: LIST
37792: PUSH
37793: EMPTY
37794: LIST
37795: LIST
37796: LIST
37797: LIST
37798: LIST
37799: LIST
37800: LIST
37801: LIST
37802: LIST
37803: LIST
37804: LIST
37805: LIST
37806: LIST
37807: LIST
37808: LIST
37809: LIST
37810: LIST
37811: LIST
37812: LIST
37813: LIST
37814: LIST
37815: LIST
37816: LIST
37817: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
37818: LD_ADDR_VAR 0 27
37822: PUSH
37823: LD_INT 0
37825: PUSH
37826: LD_INT 0
37828: PUSH
37829: EMPTY
37830: LIST
37831: LIST
37832: PUSH
37833: LD_INT 0
37835: PUSH
37836: LD_INT 1
37838: NEG
37839: PUSH
37840: EMPTY
37841: LIST
37842: LIST
37843: PUSH
37844: LD_INT 1
37846: PUSH
37847: LD_INT 0
37849: PUSH
37850: EMPTY
37851: LIST
37852: LIST
37853: PUSH
37854: LD_INT 1
37856: PUSH
37857: LD_INT 1
37859: PUSH
37860: EMPTY
37861: LIST
37862: LIST
37863: PUSH
37864: LD_INT 0
37866: PUSH
37867: LD_INT 1
37869: PUSH
37870: EMPTY
37871: LIST
37872: LIST
37873: PUSH
37874: LD_INT 1
37876: NEG
37877: PUSH
37878: LD_INT 0
37880: PUSH
37881: EMPTY
37882: LIST
37883: LIST
37884: PUSH
37885: LD_INT 1
37887: NEG
37888: PUSH
37889: LD_INT 1
37891: NEG
37892: PUSH
37893: EMPTY
37894: LIST
37895: LIST
37896: PUSH
37897: LD_INT 1
37899: NEG
37900: PUSH
37901: LD_INT 2
37903: NEG
37904: PUSH
37905: EMPTY
37906: LIST
37907: LIST
37908: PUSH
37909: LD_INT 0
37911: PUSH
37912: LD_INT 2
37914: NEG
37915: PUSH
37916: EMPTY
37917: LIST
37918: LIST
37919: PUSH
37920: LD_INT 1
37922: PUSH
37923: LD_INT 1
37925: NEG
37926: PUSH
37927: EMPTY
37928: LIST
37929: LIST
37930: PUSH
37931: LD_INT 2
37933: PUSH
37934: LD_INT 0
37936: PUSH
37937: EMPTY
37938: LIST
37939: LIST
37940: PUSH
37941: LD_INT 2
37943: PUSH
37944: LD_INT 1
37946: PUSH
37947: EMPTY
37948: LIST
37949: LIST
37950: PUSH
37951: LD_INT 2
37953: PUSH
37954: LD_INT 2
37956: PUSH
37957: EMPTY
37958: LIST
37959: LIST
37960: PUSH
37961: LD_INT 1
37963: PUSH
37964: LD_INT 2
37966: PUSH
37967: EMPTY
37968: LIST
37969: LIST
37970: PUSH
37971: LD_INT 0
37973: PUSH
37974: LD_INT 2
37976: PUSH
37977: EMPTY
37978: LIST
37979: LIST
37980: PUSH
37981: LD_INT 1
37983: NEG
37984: PUSH
37985: LD_INT 1
37987: PUSH
37988: EMPTY
37989: LIST
37990: LIST
37991: PUSH
37992: LD_INT 2
37994: NEG
37995: PUSH
37996: LD_INT 0
37998: PUSH
37999: EMPTY
38000: LIST
38001: LIST
38002: PUSH
38003: LD_INT 2
38005: NEG
38006: PUSH
38007: LD_INT 1
38009: NEG
38010: PUSH
38011: EMPTY
38012: LIST
38013: LIST
38014: PUSH
38015: LD_INT 2
38017: NEG
38018: PUSH
38019: LD_INT 2
38021: NEG
38022: PUSH
38023: EMPTY
38024: LIST
38025: LIST
38026: PUSH
38027: LD_INT 1
38029: NEG
38030: PUSH
38031: LD_INT 2
38033: PUSH
38034: EMPTY
38035: LIST
38036: LIST
38037: PUSH
38038: LD_INT 2
38040: NEG
38041: PUSH
38042: LD_INT 1
38044: PUSH
38045: EMPTY
38046: LIST
38047: LIST
38048: PUSH
38049: LD_INT 3
38051: NEG
38052: PUSH
38053: LD_INT 1
38055: NEG
38056: PUSH
38057: EMPTY
38058: LIST
38059: LIST
38060: PUSH
38061: LD_INT 3
38063: NEG
38064: PUSH
38065: LD_INT 2
38067: NEG
38068: PUSH
38069: EMPTY
38070: LIST
38071: LIST
38072: PUSH
38073: EMPTY
38074: LIST
38075: LIST
38076: LIST
38077: LIST
38078: LIST
38079: LIST
38080: LIST
38081: LIST
38082: LIST
38083: LIST
38084: LIST
38085: LIST
38086: LIST
38087: LIST
38088: LIST
38089: LIST
38090: LIST
38091: LIST
38092: LIST
38093: LIST
38094: LIST
38095: LIST
38096: LIST
38097: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
38098: LD_ADDR_VAR 0 28
38102: PUSH
38103: LD_INT 0
38105: PUSH
38106: LD_INT 0
38108: PUSH
38109: EMPTY
38110: LIST
38111: LIST
38112: PUSH
38113: LD_INT 0
38115: PUSH
38116: LD_INT 1
38118: NEG
38119: PUSH
38120: EMPTY
38121: LIST
38122: LIST
38123: PUSH
38124: LD_INT 1
38126: PUSH
38127: LD_INT 0
38129: PUSH
38130: EMPTY
38131: LIST
38132: LIST
38133: PUSH
38134: LD_INT 1
38136: PUSH
38137: LD_INT 1
38139: PUSH
38140: EMPTY
38141: LIST
38142: LIST
38143: PUSH
38144: LD_INT 0
38146: PUSH
38147: LD_INT 1
38149: PUSH
38150: EMPTY
38151: LIST
38152: LIST
38153: PUSH
38154: LD_INT 1
38156: NEG
38157: PUSH
38158: LD_INT 0
38160: PUSH
38161: EMPTY
38162: LIST
38163: LIST
38164: PUSH
38165: LD_INT 1
38167: NEG
38168: PUSH
38169: LD_INT 1
38171: NEG
38172: PUSH
38173: EMPTY
38174: LIST
38175: LIST
38176: PUSH
38177: LD_INT 1
38179: NEG
38180: PUSH
38181: LD_INT 2
38183: NEG
38184: PUSH
38185: EMPTY
38186: LIST
38187: LIST
38188: PUSH
38189: LD_INT 0
38191: PUSH
38192: LD_INT 2
38194: NEG
38195: PUSH
38196: EMPTY
38197: LIST
38198: LIST
38199: PUSH
38200: LD_INT 1
38202: PUSH
38203: LD_INT 1
38205: NEG
38206: PUSH
38207: EMPTY
38208: LIST
38209: LIST
38210: PUSH
38211: LD_INT 2
38213: PUSH
38214: LD_INT 0
38216: PUSH
38217: EMPTY
38218: LIST
38219: LIST
38220: PUSH
38221: LD_INT 2
38223: PUSH
38224: LD_INT 1
38226: PUSH
38227: EMPTY
38228: LIST
38229: LIST
38230: PUSH
38231: LD_INT 2
38233: PUSH
38234: LD_INT 2
38236: PUSH
38237: EMPTY
38238: LIST
38239: LIST
38240: PUSH
38241: LD_INT 1
38243: PUSH
38244: LD_INT 2
38246: PUSH
38247: EMPTY
38248: LIST
38249: LIST
38250: PUSH
38251: LD_INT 0
38253: PUSH
38254: LD_INT 2
38256: PUSH
38257: EMPTY
38258: LIST
38259: LIST
38260: PUSH
38261: LD_INT 1
38263: NEG
38264: PUSH
38265: LD_INT 1
38267: PUSH
38268: EMPTY
38269: LIST
38270: LIST
38271: PUSH
38272: LD_INT 2
38274: NEG
38275: PUSH
38276: LD_INT 0
38278: PUSH
38279: EMPTY
38280: LIST
38281: LIST
38282: PUSH
38283: LD_INT 2
38285: NEG
38286: PUSH
38287: LD_INT 1
38289: NEG
38290: PUSH
38291: EMPTY
38292: LIST
38293: LIST
38294: PUSH
38295: LD_INT 2
38297: NEG
38298: PUSH
38299: LD_INT 2
38301: NEG
38302: PUSH
38303: EMPTY
38304: LIST
38305: LIST
38306: PUSH
38307: LD_INT 2
38309: NEG
38310: PUSH
38311: LD_INT 3
38313: NEG
38314: PUSH
38315: EMPTY
38316: LIST
38317: LIST
38318: PUSH
38319: LD_INT 1
38321: NEG
38322: PUSH
38323: LD_INT 3
38325: NEG
38326: PUSH
38327: EMPTY
38328: LIST
38329: LIST
38330: PUSH
38331: LD_INT 3
38333: NEG
38334: PUSH
38335: LD_INT 1
38337: NEG
38338: PUSH
38339: EMPTY
38340: LIST
38341: LIST
38342: PUSH
38343: LD_INT 3
38345: NEG
38346: PUSH
38347: LD_INT 2
38349: NEG
38350: PUSH
38351: EMPTY
38352: LIST
38353: LIST
38354: PUSH
38355: EMPTY
38356: LIST
38357: LIST
38358: LIST
38359: LIST
38360: LIST
38361: LIST
38362: LIST
38363: LIST
38364: LIST
38365: LIST
38366: LIST
38367: LIST
38368: LIST
38369: LIST
38370: LIST
38371: LIST
38372: LIST
38373: LIST
38374: LIST
38375: LIST
38376: LIST
38377: LIST
38378: LIST
38379: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
38380: LD_ADDR_VAR 0 29
38384: PUSH
38385: LD_INT 0
38387: PUSH
38388: LD_INT 0
38390: PUSH
38391: EMPTY
38392: LIST
38393: LIST
38394: PUSH
38395: LD_INT 0
38397: PUSH
38398: LD_INT 1
38400: NEG
38401: PUSH
38402: EMPTY
38403: LIST
38404: LIST
38405: PUSH
38406: LD_INT 1
38408: PUSH
38409: LD_INT 0
38411: PUSH
38412: EMPTY
38413: LIST
38414: LIST
38415: PUSH
38416: LD_INT 1
38418: PUSH
38419: LD_INT 1
38421: PUSH
38422: EMPTY
38423: LIST
38424: LIST
38425: PUSH
38426: LD_INT 0
38428: PUSH
38429: LD_INT 1
38431: PUSH
38432: EMPTY
38433: LIST
38434: LIST
38435: PUSH
38436: LD_INT 1
38438: NEG
38439: PUSH
38440: LD_INT 0
38442: PUSH
38443: EMPTY
38444: LIST
38445: LIST
38446: PUSH
38447: LD_INT 1
38449: NEG
38450: PUSH
38451: LD_INT 1
38453: NEG
38454: PUSH
38455: EMPTY
38456: LIST
38457: LIST
38458: PUSH
38459: LD_INT 1
38461: NEG
38462: PUSH
38463: LD_INT 2
38465: NEG
38466: PUSH
38467: EMPTY
38468: LIST
38469: LIST
38470: PUSH
38471: LD_INT 0
38473: PUSH
38474: LD_INT 2
38476: NEG
38477: PUSH
38478: EMPTY
38479: LIST
38480: LIST
38481: PUSH
38482: LD_INT 1
38484: PUSH
38485: LD_INT 1
38487: NEG
38488: PUSH
38489: EMPTY
38490: LIST
38491: LIST
38492: PUSH
38493: LD_INT 2
38495: PUSH
38496: LD_INT 0
38498: PUSH
38499: EMPTY
38500: LIST
38501: LIST
38502: PUSH
38503: LD_INT 2
38505: PUSH
38506: LD_INT 1
38508: PUSH
38509: EMPTY
38510: LIST
38511: LIST
38512: PUSH
38513: LD_INT 1
38515: PUSH
38516: LD_INT 2
38518: PUSH
38519: EMPTY
38520: LIST
38521: LIST
38522: PUSH
38523: LD_INT 0
38525: PUSH
38526: LD_INT 2
38528: PUSH
38529: EMPTY
38530: LIST
38531: LIST
38532: PUSH
38533: LD_INT 1
38535: NEG
38536: PUSH
38537: LD_INT 1
38539: PUSH
38540: EMPTY
38541: LIST
38542: LIST
38543: PUSH
38544: LD_INT 2
38546: NEG
38547: PUSH
38548: LD_INT 1
38550: NEG
38551: PUSH
38552: EMPTY
38553: LIST
38554: LIST
38555: PUSH
38556: LD_INT 2
38558: NEG
38559: PUSH
38560: LD_INT 2
38562: NEG
38563: PUSH
38564: EMPTY
38565: LIST
38566: LIST
38567: PUSH
38568: LD_INT 2
38570: NEG
38571: PUSH
38572: LD_INT 3
38574: NEG
38575: PUSH
38576: EMPTY
38577: LIST
38578: LIST
38579: PUSH
38580: LD_INT 2
38582: PUSH
38583: LD_INT 1
38585: NEG
38586: PUSH
38587: EMPTY
38588: LIST
38589: LIST
38590: PUSH
38591: LD_INT 3
38593: PUSH
38594: LD_INT 1
38596: PUSH
38597: EMPTY
38598: LIST
38599: LIST
38600: PUSH
38601: LD_INT 1
38603: PUSH
38604: LD_INT 3
38606: PUSH
38607: EMPTY
38608: LIST
38609: LIST
38610: PUSH
38611: LD_INT 1
38613: NEG
38614: PUSH
38615: LD_INT 2
38617: PUSH
38618: EMPTY
38619: LIST
38620: LIST
38621: PUSH
38622: LD_INT 3
38624: NEG
38625: PUSH
38626: LD_INT 2
38628: NEG
38629: PUSH
38630: EMPTY
38631: LIST
38632: LIST
38633: PUSH
38634: EMPTY
38635: LIST
38636: LIST
38637: LIST
38638: LIST
38639: LIST
38640: LIST
38641: LIST
38642: LIST
38643: LIST
38644: LIST
38645: LIST
38646: LIST
38647: LIST
38648: LIST
38649: LIST
38650: LIST
38651: LIST
38652: LIST
38653: LIST
38654: LIST
38655: LIST
38656: LIST
38657: LIST
38658: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
38659: LD_ADDR_VAR 0 30
38663: PUSH
38664: LD_INT 0
38666: PUSH
38667: LD_INT 0
38669: PUSH
38670: EMPTY
38671: LIST
38672: LIST
38673: PUSH
38674: LD_INT 0
38676: PUSH
38677: LD_INT 1
38679: NEG
38680: PUSH
38681: EMPTY
38682: LIST
38683: LIST
38684: PUSH
38685: LD_INT 1
38687: PUSH
38688: LD_INT 0
38690: PUSH
38691: EMPTY
38692: LIST
38693: LIST
38694: PUSH
38695: LD_INT 1
38697: PUSH
38698: LD_INT 1
38700: PUSH
38701: EMPTY
38702: LIST
38703: LIST
38704: PUSH
38705: LD_INT 0
38707: PUSH
38708: LD_INT 1
38710: PUSH
38711: EMPTY
38712: LIST
38713: LIST
38714: PUSH
38715: LD_INT 1
38717: NEG
38718: PUSH
38719: LD_INT 0
38721: PUSH
38722: EMPTY
38723: LIST
38724: LIST
38725: PUSH
38726: LD_INT 1
38728: NEG
38729: PUSH
38730: LD_INT 1
38732: NEG
38733: PUSH
38734: EMPTY
38735: LIST
38736: LIST
38737: PUSH
38738: LD_INT 1
38740: NEG
38741: PUSH
38742: LD_INT 2
38744: NEG
38745: PUSH
38746: EMPTY
38747: LIST
38748: LIST
38749: PUSH
38750: LD_INT 0
38752: PUSH
38753: LD_INT 2
38755: NEG
38756: PUSH
38757: EMPTY
38758: LIST
38759: LIST
38760: PUSH
38761: LD_INT 1
38763: PUSH
38764: LD_INT 1
38766: NEG
38767: PUSH
38768: EMPTY
38769: LIST
38770: LIST
38771: PUSH
38772: LD_INT 2
38774: PUSH
38775: LD_INT 0
38777: PUSH
38778: EMPTY
38779: LIST
38780: LIST
38781: PUSH
38782: LD_INT 2
38784: PUSH
38785: LD_INT 1
38787: PUSH
38788: EMPTY
38789: LIST
38790: LIST
38791: PUSH
38792: LD_INT 2
38794: PUSH
38795: LD_INT 2
38797: PUSH
38798: EMPTY
38799: LIST
38800: LIST
38801: PUSH
38802: LD_INT 1
38804: PUSH
38805: LD_INT 2
38807: PUSH
38808: EMPTY
38809: LIST
38810: LIST
38811: PUSH
38812: LD_INT 1
38814: NEG
38815: PUSH
38816: LD_INT 1
38818: PUSH
38819: EMPTY
38820: LIST
38821: LIST
38822: PUSH
38823: LD_INT 2
38825: NEG
38826: PUSH
38827: LD_INT 0
38829: PUSH
38830: EMPTY
38831: LIST
38832: LIST
38833: PUSH
38834: LD_INT 2
38836: NEG
38837: PUSH
38838: LD_INT 1
38840: NEG
38841: PUSH
38842: EMPTY
38843: LIST
38844: LIST
38845: PUSH
38846: LD_INT 1
38848: NEG
38849: PUSH
38850: LD_INT 3
38852: NEG
38853: PUSH
38854: EMPTY
38855: LIST
38856: LIST
38857: PUSH
38858: LD_INT 1
38860: PUSH
38861: LD_INT 2
38863: NEG
38864: PUSH
38865: EMPTY
38866: LIST
38867: LIST
38868: PUSH
38869: LD_INT 3
38871: PUSH
38872: LD_INT 2
38874: PUSH
38875: EMPTY
38876: LIST
38877: LIST
38878: PUSH
38879: LD_INT 2
38881: PUSH
38882: LD_INT 3
38884: PUSH
38885: EMPTY
38886: LIST
38887: LIST
38888: PUSH
38889: LD_INT 2
38891: NEG
38892: PUSH
38893: LD_INT 1
38895: PUSH
38896: EMPTY
38897: LIST
38898: LIST
38899: PUSH
38900: LD_INT 3
38902: NEG
38903: PUSH
38904: LD_INT 1
38906: NEG
38907: PUSH
38908: EMPTY
38909: LIST
38910: LIST
38911: PUSH
38912: EMPTY
38913: LIST
38914: LIST
38915: LIST
38916: LIST
38917: LIST
38918: LIST
38919: LIST
38920: LIST
38921: LIST
38922: LIST
38923: LIST
38924: LIST
38925: LIST
38926: LIST
38927: LIST
38928: LIST
38929: LIST
38930: LIST
38931: LIST
38932: LIST
38933: LIST
38934: LIST
38935: LIST
38936: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
38937: LD_ADDR_VAR 0 31
38941: PUSH
38942: LD_INT 0
38944: PUSH
38945: LD_INT 0
38947: PUSH
38948: EMPTY
38949: LIST
38950: LIST
38951: PUSH
38952: LD_INT 0
38954: PUSH
38955: LD_INT 1
38957: NEG
38958: PUSH
38959: EMPTY
38960: LIST
38961: LIST
38962: PUSH
38963: LD_INT 1
38965: PUSH
38966: LD_INT 0
38968: PUSH
38969: EMPTY
38970: LIST
38971: LIST
38972: PUSH
38973: LD_INT 1
38975: PUSH
38976: LD_INT 1
38978: PUSH
38979: EMPTY
38980: LIST
38981: LIST
38982: PUSH
38983: LD_INT 0
38985: PUSH
38986: LD_INT 1
38988: PUSH
38989: EMPTY
38990: LIST
38991: LIST
38992: PUSH
38993: LD_INT 1
38995: NEG
38996: PUSH
38997: LD_INT 0
38999: PUSH
39000: EMPTY
39001: LIST
39002: LIST
39003: PUSH
39004: LD_INT 1
39006: NEG
39007: PUSH
39008: LD_INT 1
39010: NEG
39011: PUSH
39012: EMPTY
39013: LIST
39014: LIST
39015: PUSH
39016: LD_INT 1
39018: NEG
39019: PUSH
39020: LD_INT 2
39022: NEG
39023: PUSH
39024: EMPTY
39025: LIST
39026: LIST
39027: PUSH
39028: LD_INT 1
39030: PUSH
39031: LD_INT 1
39033: NEG
39034: PUSH
39035: EMPTY
39036: LIST
39037: LIST
39038: PUSH
39039: LD_INT 2
39041: PUSH
39042: LD_INT 0
39044: PUSH
39045: EMPTY
39046: LIST
39047: LIST
39048: PUSH
39049: LD_INT 2
39051: PUSH
39052: LD_INT 1
39054: PUSH
39055: EMPTY
39056: LIST
39057: LIST
39058: PUSH
39059: LD_INT 2
39061: PUSH
39062: LD_INT 2
39064: PUSH
39065: EMPTY
39066: LIST
39067: LIST
39068: PUSH
39069: LD_INT 1
39071: PUSH
39072: LD_INT 2
39074: PUSH
39075: EMPTY
39076: LIST
39077: LIST
39078: PUSH
39079: LD_INT 0
39081: PUSH
39082: LD_INT 2
39084: PUSH
39085: EMPTY
39086: LIST
39087: LIST
39088: PUSH
39089: LD_INT 1
39091: NEG
39092: PUSH
39093: LD_INT 1
39095: PUSH
39096: EMPTY
39097: LIST
39098: LIST
39099: PUSH
39100: LD_INT 2
39102: NEG
39103: PUSH
39104: LD_INT 1
39106: NEG
39107: PUSH
39108: EMPTY
39109: LIST
39110: LIST
39111: PUSH
39112: LD_INT 2
39114: NEG
39115: PUSH
39116: LD_INT 2
39118: NEG
39119: PUSH
39120: EMPTY
39121: LIST
39122: LIST
39123: PUSH
39124: LD_INT 2
39126: NEG
39127: PUSH
39128: LD_INT 3
39130: NEG
39131: PUSH
39132: EMPTY
39133: LIST
39134: LIST
39135: PUSH
39136: LD_INT 2
39138: PUSH
39139: LD_INT 1
39141: NEG
39142: PUSH
39143: EMPTY
39144: LIST
39145: LIST
39146: PUSH
39147: LD_INT 3
39149: PUSH
39150: LD_INT 1
39152: PUSH
39153: EMPTY
39154: LIST
39155: LIST
39156: PUSH
39157: LD_INT 1
39159: PUSH
39160: LD_INT 3
39162: PUSH
39163: EMPTY
39164: LIST
39165: LIST
39166: PUSH
39167: LD_INT 1
39169: NEG
39170: PUSH
39171: LD_INT 2
39173: PUSH
39174: EMPTY
39175: LIST
39176: LIST
39177: PUSH
39178: LD_INT 3
39180: NEG
39181: PUSH
39182: LD_INT 2
39184: NEG
39185: PUSH
39186: EMPTY
39187: LIST
39188: LIST
39189: PUSH
39190: EMPTY
39191: LIST
39192: LIST
39193: LIST
39194: LIST
39195: LIST
39196: LIST
39197: LIST
39198: LIST
39199: LIST
39200: LIST
39201: LIST
39202: LIST
39203: LIST
39204: LIST
39205: LIST
39206: LIST
39207: LIST
39208: LIST
39209: LIST
39210: LIST
39211: LIST
39212: LIST
39213: LIST
39214: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
39215: LD_ADDR_VAR 0 32
39219: PUSH
39220: LD_INT 0
39222: PUSH
39223: LD_INT 0
39225: PUSH
39226: EMPTY
39227: LIST
39228: LIST
39229: PUSH
39230: LD_INT 0
39232: PUSH
39233: LD_INT 1
39235: NEG
39236: PUSH
39237: EMPTY
39238: LIST
39239: LIST
39240: PUSH
39241: LD_INT 1
39243: PUSH
39244: LD_INT 0
39246: PUSH
39247: EMPTY
39248: LIST
39249: LIST
39250: PUSH
39251: LD_INT 1
39253: PUSH
39254: LD_INT 1
39256: PUSH
39257: EMPTY
39258: LIST
39259: LIST
39260: PUSH
39261: LD_INT 0
39263: PUSH
39264: LD_INT 1
39266: PUSH
39267: EMPTY
39268: LIST
39269: LIST
39270: PUSH
39271: LD_INT 1
39273: NEG
39274: PUSH
39275: LD_INT 0
39277: PUSH
39278: EMPTY
39279: LIST
39280: LIST
39281: PUSH
39282: LD_INT 1
39284: NEG
39285: PUSH
39286: LD_INT 1
39288: NEG
39289: PUSH
39290: EMPTY
39291: LIST
39292: LIST
39293: PUSH
39294: LD_INT 1
39296: NEG
39297: PUSH
39298: LD_INT 2
39300: NEG
39301: PUSH
39302: EMPTY
39303: LIST
39304: LIST
39305: PUSH
39306: LD_INT 0
39308: PUSH
39309: LD_INT 2
39311: NEG
39312: PUSH
39313: EMPTY
39314: LIST
39315: LIST
39316: PUSH
39317: LD_INT 1
39319: PUSH
39320: LD_INT 1
39322: NEG
39323: PUSH
39324: EMPTY
39325: LIST
39326: LIST
39327: PUSH
39328: LD_INT 2
39330: PUSH
39331: LD_INT 1
39333: PUSH
39334: EMPTY
39335: LIST
39336: LIST
39337: PUSH
39338: LD_INT 2
39340: PUSH
39341: LD_INT 2
39343: PUSH
39344: EMPTY
39345: LIST
39346: LIST
39347: PUSH
39348: LD_INT 1
39350: PUSH
39351: LD_INT 2
39353: PUSH
39354: EMPTY
39355: LIST
39356: LIST
39357: PUSH
39358: LD_INT 0
39360: PUSH
39361: LD_INT 2
39363: PUSH
39364: EMPTY
39365: LIST
39366: LIST
39367: PUSH
39368: LD_INT 1
39370: NEG
39371: PUSH
39372: LD_INT 1
39374: PUSH
39375: EMPTY
39376: LIST
39377: LIST
39378: PUSH
39379: LD_INT 2
39381: NEG
39382: PUSH
39383: LD_INT 0
39385: PUSH
39386: EMPTY
39387: LIST
39388: LIST
39389: PUSH
39390: LD_INT 2
39392: NEG
39393: PUSH
39394: LD_INT 1
39396: NEG
39397: PUSH
39398: EMPTY
39399: LIST
39400: LIST
39401: PUSH
39402: LD_INT 1
39404: NEG
39405: PUSH
39406: LD_INT 3
39408: NEG
39409: PUSH
39410: EMPTY
39411: LIST
39412: LIST
39413: PUSH
39414: LD_INT 1
39416: PUSH
39417: LD_INT 2
39419: NEG
39420: PUSH
39421: EMPTY
39422: LIST
39423: LIST
39424: PUSH
39425: LD_INT 3
39427: PUSH
39428: LD_INT 2
39430: PUSH
39431: EMPTY
39432: LIST
39433: LIST
39434: PUSH
39435: LD_INT 2
39437: PUSH
39438: LD_INT 3
39440: PUSH
39441: EMPTY
39442: LIST
39443: LIST
39444: PUSH
39445: LD_INT 2
39447: NEG
39448: PUSH
39449: LD_INT 1
39451: PUSH
39452: EMPTY
39453: LIST
39454: LIST
39455: PUSH
39456: LD_INT 3
39458: NEG
39459: PUSH
39460: LD_INT 1
39462: NEG
39463: PUSH
39464: EMPTY
39465: LIST
39466: LIST
39467: PUSH
39468: EMPTY
39469: LIST
39470: LIST
39471: LIST
39472: LIST
39473: LIST
39474: LIST
39475: LIST
39476: LIST
39477: LIST
39478: LIST
39479: LIST
39480: LIST
39481: LIST
39482: LIST
39483: LIST
39484: LIST
39485: LIST
39486: LIST
39487: LIST
39488: LIST
39489: LIST
39490: LIST
39491: LIST
39492: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
39493: LD_ADDR_VAR 0 33
39497: PUSH
39498: LD_INT 0
39500: PUSH
39501: LD_INT 0
39503: PUSH
39504: EMPTY
39505: LIST
39506: LIST
39507: PUSH
39508: LD_INT 0
39510: PUSH
39511: LD_INT 1
39513: NEG
39514: PUSH
39515: EMPTY
39516: LIST
39517: LIST
39518: PUSH
39519: LD_INT 1
39521: PUSH
39522: LD_INT 0
39524: PUSH
39525: EMPTY
39526: LIST
39527: LIST
39528: PUSH
39529: LD_INT 1
39531: PUSH
39532: LD_INT 1
39534: PUSH
39535: EMPTY
39536: LIST
39537: LIST
39538: PUSH
39539: LD_INT 0
39541: PUSH
39542: LD_INT 1
39544: PUSH
39545: EMPTY
39546: LIST
39547: LIST
39548: PUSH
39549: LD_INT 1
39551: NEG
39552: PUSH
39553: LD_INT 0
39555: PUSH
39556: EMPTY
39557: LIST
39558: LIST
39559: PUSH
39560: LD_INT 1
39562: NEG
39563: PUSH
39564: LD_INT 1
39566: NEG
39567: PUSH
39568: EMPTY
39569: LIST
39570: LIST
39571: PUSH
39572: LD_INT 1
39574: NEG
39575: PUSH
39576: LD_INT 2
39578: NEG
39579: PUSH
39580: EMPTY
39581: LIST
39582: LIST
39583: PUSH
39584: LD_INT 1
39586: PUSH
39587: LD_INT 1
39589: NEG
39590: PUSH
39591: EMPTY
39592: LIST
39593: LIST
39594: PUSH
39595: LD_INT 2
39597: PUSH
39598: LD_INT 0
39600: PUSH
39601: EMPTY
39602: LIST
39603: LIST
39604: PUSH
39605: LD_INT 2
39607: PUSH
39608: LD_INT 1
39610: PUSH
39611: EMPTY
39612: LIST
39613: LIST
39614: PUSH
39615: LD_INT 1
39617: PUSH
39618: LD_INT 2
39620: PUSH
39621: EMPTY
39622: LIST
39623: LIST
39624: PUSH
39625: LD_INT 0
39627: PUSH
39628: LD_INT 2
39630: PUSH
39631: EMPTY
39632: LIST
39633: LIST
39634: PUSH
39635: LD_INT 1
39637: NEG
39638: PUSH
39639: LD_INT 1
39641: PUSH
39642: EMPTY
39643: LIST
39644: LIST
39645: PUSH
39646: LD_INT 2
39648: NEG
39649: PUSH
39650: LD_INT 0
39652: PUSH
39653: EMPTY
39654: LIST
39655: LIST
39656: PUSH
39657: LD_INT 2
39659: NEG
39660: PUSH
39661: LD_INT 1
39663: NEG
39664: PUSH
39665: EMPTY
39666: LIST
39667: LIST
39668: PUSH
39669: LD_INT 2
39671: NEG
39672: PUSH
39673: LD_INT 2
39675: NEG
39676: PUSH
39677: EMPTY
39678: LIST
39679: LIST
39680: PUSH
39681: LD_INT 2
39683: NEG
39684: PUSH
39685: LD_INT 3
39687: NEG
39688: PUSH
39689: EMPTY
39690: LIST
39691: LIST
39692: PUSH
39693: LD_INT 2
39695: PUSH
39696: LD_INT 1
39698: NEG
39699: PUSH
39700: EMPTY
39701: LIST
39702: LIST
39703: PUSH
39704: LD_INT 3
39706: PUSH
39707: LD_INT 1
39709: PUSH
39710: EMPTY
39711: LIST
39712: LIST
39713: PUSH
39714: LD_INT 1
39716: PUSH
39717: LD_INT 3
39719: PUSH
39720: EMPTY
39721: LIST
39722: LIST
39723: PUSH
39724: LD_INT 1
39726: NEG
39727: PUSH
39728: LD_INT 2
39730: PUSH
39731: EMPTY
39732: LIST
39733: LIST
39734: PUSH
39735: LD_INT 3
39737: NEG
39738: PUSH
39739: LD_INT 2
39741: NEG
39742: PUSH
39743: EMPTY
39744: LIST
39745: LIST
39746: PUSH
39747: EMPTY
39748: LIST
39749: LIST
39750: LIST
39751: LIST
39752: LIST
39753: LIST
39754: LIST
39755: LIST
39756: LIST
39757: LIST
39758: LIST
39759: LIST
39760: LIST
39761: LIST
39762: LIST
39763: LIST
39764: LIST
39765: LIST
39766: LIST
39767: LIST
39768: LIST
39769: LIST
39770: LIST
39771: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
39772: LD_ADDR_VAR 0 34
39776: PUSH
39777: LD_INT 0
39779: PUSH
39780: LD_INT 0
39782: PUSH
39783: EMPTY
39784: LIST
39785: LIST
39786: PUSH
39787: LD_INT 0
39789: PUSH
39790: LD_INT 1
39792: NEG
39793: PUSH
39794: EMPTY
39795: LIST
39796: LIST
39797: PUSH
39798: LD_INT 1
39800: PUSH
39801: LD_INT 0
39803: PUSH
39804: EMPTY
39805: LIST
39806: LIST
39807: PUSH
39808: LD_INT 1
39810: PUSH
39811: LD_INT 1
39813: PUSH
39814: EMPTY
39815: LIST
39816: LIST
39817: PUSH
39818: LD_INT 0
39820: PUSH
39821: LD_INT 1
39823: PUSH
39824: EMPTY
39825: LIST
39826: LIST
39827: PUSH
39828: LD_INT 1
39830: NEG
39831: PUSH
39832: LD_INT 0
39834: PUSH
39835: EMPTY
39836: LIST
39837: LIST
39838: PUSH
39839: LD_INT 1
39841: NEG
39842: PUSH
39843: LD_INT 1
39845: NEG
39846: PUSH
39847: EMPTY
39848: LIST
39849: LIST
39850: PUSH
39851: LD_INT 1
39853: NEG
39854: PUSH
39855: LD_INT 2
39857: NEG
39858: PUSH
39859: EMPTY
39860: LIST
39861: LIST
39862: PUSH
39863: LD_INT 0
39865: PUSH
39866: LD_INT 2
39868: NEG
39869: PUSH
39870: EMPTY
39871: LIST
39872: LIST
39873: PUSH
39874: LD_INT 1
39876: PUSH
39877: LD_INT 1
39879: NEG
39880: PUSH
39881: EMPTY
39882: LIST
39883: LIST
39884: PUSH
39885: LD_INT 2
39887: PUSH
39888: LD_INT 1
39890: PUSH
39891: EMPTY
39892: LIST
39893: LIST
39894: PUSH
39895: LD_INT 2
39897: PUSH
39898: LD_INT 2
39900: PUSH
39901: EMPTY
39902: LIST
39903: LIST
39904: PUSH
39905: LD_INT 1
39907: PUSH
39908: LD_INT 2
39910: PUSH
39911: EMPTY
39912: LIST
39913: LIST
39914: PUSH
39915: LD_INT 1
39917: NEG
39918: PUSH
39919: LD_INT 1
39921: PUSH
39922: EMPTY
39923: LIST
39924: LIST
39925: PUSH
39926: LD_INT 2
39928: NEG
39929: PUSH
39930: LD_INT 0
39932: PUSH
39933: EMPTY
39934: LIST
39935: LIST
39936: PUSH
39937: LD_INT 2
39939: NEG
39940: PUSH
39941: LD_INT 1
39943: NEG
39944: PUSH
39945: EMPTY
39946: LIST
39947: LIST
39948: PUSH
39949: LD_INT 2
39951: NEG
39952: PUSH
39953: LD_INT 2
39955: NEG
39956: PUSH
39957: EMPTY
39958: LIST
39959: LIST
39960: PUSH
39961: LD_INT 1
39963: NEG
39964: PUSH
39965: LD_INT 3
39967: NEG
39968: PUSH
39969: EMPTY
39970: LIST
39971: LIST
39972: PUSH
39973: LD_INT 1
39975: PUSH
39976: LD_INT 2
39978: NEG
39979: PUSH
39980: EMPTY
39981: LIST
39982: LIST
39983: PUSH
39984: LD_INT 3
39986: PUSH
39987: LD_INT 2
39989: PUSH
39990: EMPTY
39991: LIST
39992: LIST
39993: PUSH
39994: LD_INT 2
39996: PUSH
39997: LD_INT 3
39999: PUSH
40000: EMPTY
40001: LIST
40002: LIST
40003: PUSH
40004: LD_INT 2
40006: NEG
40007: PUSH
40008: LD_INT 1
40010: PUSH
40011: EMPTY
40012: LIST
40013: LIST
40014: PUSH
40015: LD_INT 3
40017: NEG
40018: PUSH
40019: LD_INT 1
40021: NEG
40022: PUSH
40023: EMPTY
40024: LIST
40025: LIST
40026: PUSH
40027: EMPTY
40028: LIST
40029: LIST
40030: LIST
40031: LIST
40032: LIST
40033: LIST
40034: LIST
40035: LIST
40036: LIST
40037: LIST
40038: LIST
40039: LIST
40040: LIST
40041: LIST
40042: LIST
40043: LIST
40044: LIST
40045: LIST
40046: LIST
40047: LIST
40048: LIST
40049: LIST
40050: LIST
40051: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
40052: LD_ADDR_VAR 0 35
40056: PUSH
40057: LD_INT 0
40059: PUSH
40060: LD_INT 0
40062: PUSH
40063: EMPTY
40064: LIST
40065: LIST
40066: PUSH
40067: LD_INT 0
40069: PUSH
40070: LD_INT 1
40072: NEG
40073: PUSH
40074: EMPTY
40075: LIST
40076: LIST
40077: PUSH
40078: LD_INT 1
40080: PUSH
40081: LD_INT 0
40083: PUSH
40084: EMPTY
40085: LIST
40086: LIST
40087: PUSH
40088: LD_INT 1
40090: PUSH
40091: LD_INT 1
40093: PUSH
40094: EMPTY
40095: LIST
40096: LIST
40097: PUSH
40098: LD_INT 0
40100: PUSH
40101: LD_INT 1
40103: PUSH
40104: EMPTY
40105: LIST
40106: LIST
40107: PUSH
40108: LD_INT 1
40110: NEG
40111: PUSH
40112: LD_INT 0
40114: PUSH
40115: EMPTY
40116: LIST
40117: LIST
40118: PUSH
40119: LD_INT 1
40121: NEG
40122: PUSH
40123: LD_INT 1
40125: NEG
40126: PUSH
40127: EMPTY
40128: LIST
40129: LIST
40130: PUSH
40131: LD_INT 2
40133: PUSH
40134: LD_INT 1
40136: PUSH
40137: EMPTY
40138: LIST
40139: LIST
40140: PUSH
40141: LD_INT 2
40143: NEG
40144: PUSH
40145: LD_INT 1
40147: NEG
40148: PUSH
40149: EMPTY
40150: LIST
40151: LIST
40152: PUSH
40153: EMPTY
40154: LIST
40155: LIST
40156: LIST
40157: LIST
40158: LIST
40159: LIST
40160: LIST
40161: LIST
40162: LIST
40163: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
40164: LD_ADDR_VAR 0 36
40168: PUSH
40169: LD_INT 0
40171: PUSH
40172: LD_INT 0
40174: PUSH
40175: EMPTY
40176: LIST
40177: LIST
40178: PUSH
40179: LD_INT 0
40181: PUSH
40182: LD_INT 1
40184: NEG
40185: PUSH
40186: EMPTY
40187: LIST
40188: LIST
40189: PUSH
40190: LD_INT 1
40192: PUSH
40193: LD_INT 0
40195: PUSH
40196: EMPTY
40197: LIST
40198: LIST
40199: PUSH
40200: LD_INT 1
40202: PUSH
40203: LD_INT 1
40205: PUSH
40206: EMPTY
40207: LIST
40208: LIST
40209: PUSH
40210: LD_INT 0
40212: PUSH
40213: LD_INT 1
40215: PUSH
40216: EMPTY
40217: LIST
40218: LIST
40219: PUSH
40220: LD_INT 1
40222: NEG
40223: PUSH
40224: LD_INT 0
40226: PUSH
40227: EMPTY
40228: LIST
40229: LIST
40230: PUSH
40231: LD_INT 1
40233: NEG
40234: PUSH
40235: LD_INT 1
40237: NEG
40238: PUSH
40239: EMPTY
40240: LIST
40241: LIST
40242: PUSH
40243: LD_INT 1
40245: NEG
40246: PUSH
40247: LD_INT 2
40249: NEG
40250: PUSH
40251: EMPTY
40252: LIST
40253: LIST
40254: PUSH
40255: LD_INT 1
40257: PUSH
40258: LD_INT 2
40260: PUSH
40261: EMPTY
40262: LIST
40263: LIST
40264: PUSH
40265: EMPTY
40266: LIST
40267: LIST
40268: LIST
40269: LIST
40270: LIST
40271: LIST
40272: LIST
40273: LIST
40274: LIST
40275: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
40276: LD_ADDR_VAR 0 37
40280: PUSH
40281: LD_INT 0
40283: PUSH
40284: LD_INT 0
40286: PUSH
40287: EMPTY
40288: LIST
40289: LIST
40290: PUSH
40291: LD_INT 0
40293: PUSH
40294: LD_INT 1
40296: NEG
40297: PUSH
40298: EMPTY
40299: LIST
40300: LIST
40301: PUSH
40302: LD_INT 1
40304: PUSH
40305: LD_INT 0
40307: PUSH
40308: EMPTY
40309: LIST
40310: LIST
40311: PUSH
40312: LD_INT 1
40314: PUSH
40315: LD_INT 1
40317: PUSH
40318: EMPTY
40319: LIST
40320: LIST
40321: PUSH
40322: LD_INT 0
40324: PUSH
40325: LD_INT 1
40327: PUSH
40328: EMPTY
40329: LIST
40330: LIST
40331: PUSH
40332: LD_INT 1
40334: NEG
40335: PUSH
40336: LD_INT 0
40338: PUSH
40339: EMPTY
40340: LIST
40341: LIST
40342: PUSH
40343: LD_INT 1
40345: NEG
40346: PUSH
40347: LD_INT 1
40349: NEG
40350: PUSH
40351: EMPTY
40352: LIST
40353: LIST
40354: PUSH
40355: LD_INT 1
40357: PUSH
40358: LD_INT 1
40360: NEG
40361: PUSH
40362: EMPTY
40363: LIST
40364: LIST
40365: PUSH
40366: LD_INT 1
40368: NEG
40369: PUSH
40370: LD_INT 1
40372: PUSH
40373: EMPTY
40374: LIST
40375: LIST
40376: PUSH
40377: EMPTY
40378: LIST
40379: LIST
40380: LIST
40381: LIST
40382: LIST
40383: LIST
40384: LIST
40385: LIST
40386: LIST
40387: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
40388: LD_ADDR_VAR 0 38
40392: PUSH
40393: LD_INT 0
40395: PUSH
40396: LD_INT 0
40398: PUSH
40399: EMPTY
40400: LIST
40401: LIST
40402: PUSH
40403: LD_INT 0
40405: PUSH
40406: LD_INT 1
40408: NEG
40409: PUSH
40410: EMPTY
40411: LIST
40412: LIST
40413: PUSH
40414: LD_INT 1
40416: PUSH
40417: LD_INT 0
40419: PUSH
40420: EMPTY
40421: LIST
40422: LIST
40423: PUSH
40424: LD_INT 1
40426: PUSH
40427: LD_INT 1
40429: PUSH
40430: EMPTY
40431: LIST
40432: LIST
40433: PUSH
40434: LD_INT 0
40436: PUSH
40437: LD_INT 1
40439: PUSH
40440: EMPTY
40441: LIST
40442: LIST
40443: PUSH
40444: LD_INT 1
40446: NEG
40447: PUSH
40448: LD_INT 0
40450: PUSH
40451: EMPTY
40452: LIST
40453: LIST
40454: PUSH
40455: LD_INT 1
40457: NEG
40458: PUSH
40459: LD_INT 1
40461: NEG
40462: PUSH
40463: EMPTY
40464: LIST
40465: LIST
40466: PUSH
40467: LD_INT 2
40469: PUSH
40470: LD_INT 1
40472: PUSH
40473: EMPTY
40474: LIST
40475: LIST
40476: PUSH
40477: LD_INT 2
40479: NEG
40480: PUSH
40481: LD_INT 1
40483: NEG
40484: PUSH
40485: EMPTY
40486: LIST
40487: LIST
40488: PUSH
40489: EMPTY
40490: LIST
40491: LIST
40492: LIST
40493: LIST
40494: LIST
40495: LIST
40496: LIST
40497: LIST
40498: LIST
40499: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
40500: LD_ADDR_VAR 0 39
40504: PUSH
40505: LD_INT 0
40507: PUSH
40508: LD_INT 0
40510: PUSH
40511: EMPTY
40512: LIST
40513: LIST
40514: PUSH
40515: LD_INT 0
40517: PUSH
40518: LD_INT 1
40520: NEG
40521: PUSH
40522: EMPTY
40523: LIST
40524: LIST
40525: PUSH
40526: LD_INT 1
40528: PUSH
40529: LD_INT 0
40531: PUSH
40532: EMPTY
40533: LIST
40534: LIST
40535: PUSH
40536: LD_INT 1
40538: PUSH
40539: LD_INT 1
40541: PUSH
40542: EMPTY
40543: LIST
40544: LIST
40545: PUSH
40546: LD_INT 0
40548: PUSH
40549: LD_INT 1
40551: PUSH
40552: EMPTY
40553: LIST
40554: LIST
40555: PUSH
40556: LD_INT 1
40558: NEG
40559: PUSH
40560: LD_INT 0
40562: PUSH
40563: EMPTY
40564: LIST
40565: LIST
40566: PUSH
40567: LD_INT 1
40569: NEG
40570: PUSH
40571: LD_INT 1
40573: NEG
40574: PUSH
40575: EMPTY
40576: LIST
40577: LIST
40578: PUSH
40579: LD_INT 1
40581: NEG
40582: PUSH
40583: LD_INT 2
40585: NEG
40586: PUSH
40587: EMPTY
40588: LIST
40589: LIST
40590: PUSH
40591: LD_INT 1
40593: PUSH
40594: LD_INT 2
40596: PUSH
40597: EMPTY
40598: LIST
40599: LIST
40600: PUSH
40601: EMPTY
40602: LIST
40603: LIST
40604: LIST
40605: LIST
40606: LIST
40607: LIST
40608: LIST
40609: LIST
40610: LIST
40611: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
40612: LD_ADDR_VAR 0 40
40616: PUSH
40617: LD_INT 0
40619: PUSH
40620: LD_INT 0
40622: PUSH
40623: EMPTY
40624: LIST
40625: LIST
40626: PUSH
40627: LD_INT 0
40629: PUSH
40630: LD_INT 1
40632: NEG
40633: PUSH
40634: EMPTY
40635: LIST
40636: LIST
40637: PUSH
40638: LD_INT 1
40640: PUSH
40641: LD_INT 0
40643: PUSH
40644: EMPTY
40645: LIST
40646: LIST
40647: PUSH
40648: LD_INT 1
40650: PUSH
40651: LD_INT 1
40653: PUSH
40654: EMPTY
40655: LIST
40656: LIST
40657: PUSH
40658: LD_INT 0
40660: PUSH
40661: LD_INT 1
40663: PUSH
40664: EMPTY
40665: LIST
40666: LIST
40667: PUSH
40668: LD_INT 1
40670: NEG
40671: PUSH
40672: LD_INT 0
40674: PUSH
40675: EMPTY
40676: LIST
40677: LIST
40678: PUSH
40679: LD_INT 1
40681: NEG
40682: PUSH
40683: LD_INT 1
40685: NEG
40686: PUSH
40687: EMPTY
40688: LIST
40689: LIST
40690: PUSH
40691: LD_INT 1
40693: PUSH
40694: LD_INT 1
40696: NEG
40697: PUSH
40698: EMPTY
40699: LIST
40700: LIST
40701: PUSH
40702: LD_INT 1
40704: NEG
40705: PUSH
40706: LD_INT 1
40708: PUSH
40709: EMPTY
40710: LIST
40711: LIST
40712: PUSH
40713: EMPTY
40714: LIST
40715: LIST
40716: LIST
40717: LIST
40718: LIST
40719: LIST
40720: LIST
40721: LIST
40722: LIST
40723: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
40724: LD_ADDR_VAR 0 41
40728: PUSH
40729: LD_INT 0
40731: PUSH
40732: LD_INT 0
40734: PUSH
40735: EMPTY
40736: LIST
40737: LIST
40738: PUSH
40739: LD_INT 0
40741: PUSH
40742: LD_INT 1
40744: NEG
40745: PUSH
40746: EMPTY
40747: LIST
40748: LIST
40749: PUSH
40750: LD_INT 1
40752: PUSH
40753: LD_INT 0
40755: PUSH
40756: EMPTY
40757: LIST
40758: LIST
40759: PUSH
40760: LD_INT 1
40762: PUSH
40763: LD_INT 1
40765: PUSH
40766: EMPTY
40767: LIST
40768: LIST
40769: PUSH
40770: LD_INT 0
40772: PUSH
40773: LD_INT 1
40775: PUSH
40776: EMPTY
40777: LIST
40778: LIST
40779: PUSH
40780: LD_INT 1
40782: NEG
40783: PUSH
40784: LD_INT 0
40786: PUSH
40787: EMPTY
40788: LIST
40789: LIST
40790: PUSH
40791: LD_INT 1
40793: NEG
40794: PUSH
40795: LD_INT 1
40797: NEG
40798: PUSH
40799: EMPTY
40800: LIST
40801: LIST
40802: PUSH
40803: LD_INT 1
40805: NEG
40806: PUSH
40807: LD_INT 2
40809: NEG
40810: PUSH
40811: EMPTY
40812: LIST
40813: LIST
40814: PUSH
40815: LD_INT 1
40817: PUSH
40818: LD_INT 1
40820: NEG
40821: PUSH
40822: EMPTY
40823: LIST
40824: LIST
40825: PUSH
40826: LD_INT 2
40828: PUSH
40829: LD_INT 0
40831: PUSH
40832: EMPTY
40833: LIST
40834: LIST
40835: PUSH
40836: LD_INT 2
40838: PUSH
40839: LD_INT 1
40841: PUSH
40842: EMPTY
40843: LIST
40844: LIST
40845: PUSH
40846: LD_INT 2
40848: PUSH
40849: LD_INT 2
40851: PUSH
40852: EMPTY
40853: LIST
40854: LIST
40855: PUSH
40856: LD_INT 1
40858: PUSH
40859: LD_INT 2
40861: PUSH
40862: EMPTY
40863: LIST
40864: LIST
40865: PUSH
40866: LD_INT 1
40868: NEG
40869: PUSH
40870: LD_INT 1
40872: PUSH
40873: EMPTY
40874: LIST
40875: LIST
40876: PUSH
40877: LD_INT 2
40879: NEG
40880: PUSH
40881: LD_INT 0
40883: PUSH
40884: EMPTY
40885: LIST
40886: LIST
40887: PUSH
40888: LD_INT 2
40890: NEG
40891: PUSH
40892: LD_INT 1
40894: NEG
40895: PUSH
40896: EMPTY
40897: LIST
40898: LIST
40899: PUSH
40900: LD_INT 2
40902: NEG
40903: PUSH
40904: LD_INT 2
40906: NEG
40907: PUSH
40908: EMPTY
40909: LIST
40910: LIST
40911: PUSH
40912: LD_INT 2
40914: NEG
40915: PUSH
40916: LD_INT 3
40918: NEG
40919: PUSH
40920: EMPTY
40921: LIST
40922: LIST
40923: PUSH
40924: LD_INT 2
40926: PUSH
40927: LD_INT 1
40929: NEG
40930: PUSH
40931: EMPTY
40932: LIST
40933: LIST
40934: PUSH
40935: LD_INT 3
40937: PUSH
40938: LD_INT 0
40940: PUSH
40941: EMPTY
40942: LIST
40943: LIST
40944: PUSH
40945: LD_INT 3
40947: PUSH
40948: LD_INT 1
40950: PUSH
40951: EMPTY
40952: LIST
40953: LIST
40954: PUSH
40955: LD_INT 3
40957: PUSH
40958: LD_INT 2
40960: PUSH
40961: EMPTY
40962: LIST
40963: LIST
40964: PUSH
40965: LD_INT 3
40967: PUSH
40968: LD_INT 3
40970: PUSH
40971: EMPTY
40972: LIST
40973: LIST
40974: PUSH
40975: LD_INT 2
40977: PUSH
40978: LD_INT 3
40980: PUSH
40981: EMPTY
40982: LIST
40983: LIST
40984: PUSH
40985: LD_INT 2
40987: NEG
40988: PUSH
40989: LD_INT 1
40991: PUSH
40992: EMPTY
40993: LIST
40994: LIST
40995: PUSH
40996: LD_INT 3
40998: NEG
40999: PUSH
41000: LD_INT 0
41002: PUSH
41003: EMPTY
41004: LIST
41005: LIST
41006: PUSH
41007: LD_INT 3
41009: NEG
41010: PUSH
41011: LD_INT 1
41013: NEG
41014: PUSH
41015: EMPTY
41016: LIST
41017: LIST
41018: PUSH
41019: LD_INT 3
41021: NEG
41022: PUSH
41023: LD_INT 2
41025: NEG
41026: PUSH
41027: EMPTY
41028: LIST
41029: LIST
41030: PUSH
41031: LD_INT 3
41033: NEG
41034: PUSH
41035: LD_INT 3
41037: NEG
41038: PUSH
41039: EMPTY
41040: LIST
41041: LIST
41042: PUSH
41043: EMPTY
41044: LIST
41045: LIST
41046: LIST
41047: LIST
41048: LIST
41049: LIST
41050: LIST
41051: LIST
41052: LIST
41053: LIST
41054: LIST
41055: LIST
41056: LIST
41057: LIST
41058: LIST
41059: LIST
41060: LIST
41061: LIST
41062: LIST
41063: LIST
41064: LIST
41065: LIST
41066: LIST
41067: LIST
41068: LIST
41069: LIST
41070: LIST
41071: LIST
41072: LIST
41073: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
41074: LD_ADDR_VAR 0 42
41078: PUSH
41079: LD_INT 0
41081: PUSH
41082: LD_INT 0
41084: PUSH
41085: EMPTY
41086: LIST
41087: LIST
41088: PUSH
41089: LD_INT 0
41091: PUSH
41092: LD_INT 1
41094: NEG
41095: PUSH
41096: EMPTY
41097: LIST
41098: LIST
41099: PUSH
41100: LD_INT 1
41102: PUSH
41103: LD_INT 0
41105: PUSH
41106: EMPTY
41107: LIST
41108: LIST
41109: PUSH
41110: LD_INT 1
41112: PUSH
41113: LD_INT 1
41115: PUSH
41116: EMPTY
41117: LIST
41118: LIST
41119: PUSH
41120: LD_INT 0
41122: PUSH
41123: LD_INT 1
41125: PUSH
41126: EMPTY
41127: LIST
41128: LIST
41129: PUSH
41130: LD_INT 1
41132: NEG
41133: PUSH
41134: LD_INT 0
41136: PUSH
41137: EMPTY
41138: LIST
41139: LIST
41140: PUSH
41141: LD_INT 1
41143: NEG
41144: PUSH
41145: LD_INT 1
41147: NEG
41148: PUSH
41149: EMPTY
41150: LIST
41151: LIST
41152: PUSH
41153: LD_INT 1
41155: NEG
41156: PUSH
41157: LD_INT 2
41159: NEG
41160: PUSH
41161: EMPTY
41162: LIST
41163: LIST
41164: PUSH
41165: LD_INT 0
41167: PUSH
41168: LD_INT 2
41170: NEG
41171: PUSH
41172: EMPTY
41173: LIST
41174: LIST
41175: PUSH
41176: LD_INT 1
41178: PUSH
41179: LD_INT 1
41181: NEG
41182: PUSH
41183: EMPTY
41184: LIST
41185: LIST
41186: PUSH
41187: LD_INT 2
41189: PUSH
41190: LD_INT 1
41192: PUSH
41193: EMPTY
41194: LIST
41195: LIST
41196: PUSH
41197: LD_INT 2
41199: PUSH
41200: LD_INT 2
41202: PUSH
41203: EMPTY
41204: LIST
41205: LIST
41206: PUSH
41207: LD_INT 1
41209: PUSH
41210: LD_INT 2
41212: PUSH
41213: EMPTY
41214: LIST
41215: LIST
41216: PUSH
41217: LD_INT 0
41219: PUSH
41220: LD_INT 2
41222: PUSH
41223: EMPTY
41224: LIST
41225: LIST
41226: PUSH
41227: LD_INT 1
41229: NEG
41230: PUSH
41231: LD_INT 1
41233: PUSH
41234: EMPTY
41235: LIST
41236: LIST
41237: PUSH
41238: LD_INT 2
41240: NEG
41241: PUSH
41242: LD_INT 1
41244: NEG
41245: PUSH
41246: EMPTY
41247: LIST
41248: LIST
41249: PUSH
41250: LD_INT 2
41252: NEG
41253: PUSH
41254: LD_INT 2
41256: NEG
41257: PUSH
41258: EMPTY
41259: LIST
41260: LIST
41261: PUSH
41262: LD_INT 2
41264: NEG
41265: PUSH
41266: LD_INT 3
41268: NEG
41269: PUSH
41270: EMPTY
41271: LIST
41272: LIST
41273: PUSH
41274: LD_INT 1
41276: NEG
41277: PUSH
41278: LD_INT 3
41280: NEG
41281: PUSH
41282: EMPTY
41283: LIST
41284: LIST
41285: PUSH
41286: LD_INT 0
41288: PUSH
41289: LD_INT 3
41291: NEG
41292: PUSH
41293: EMPTY
41294: LIST
41295: LIST
41296: PUSH
41297: LD_INT 1
41299: PUSH
41300: LD_INT 2
41302: NEG
41303: PUSH
41304: EMPTY
41305: LIST
41306: LIST
41307: PUSH
41308: LD_INT 3
41310: PUSH
41311: LD_INT 2
41313: PUSH
41314: EMPTY
41315: LIST
41316: LIST
41317: PUSH
41318: LD_INT 3
41320: PUSH
41321: LD_INT 3
41323: PUSH
41324: EMPTY
41325: LIST
41326: LIST
41327: PUSH
41328: LD_INT 2
41330: PUSH
41331: LD_INT 3
41333: PUSH
41334: EMPTY
41335: LIST
41336: LIST
41337: PUSH
41338: LD_INT 1
41340: PUSH
41341: LD_INT 3
41343: PUSH
41344: EMPTY
41345: LIST
41346: LIST
41347: PUSH
41348: LD_INT 0
41350: PUSH
41351: LD_INT 3
41353: PUSH
41354: EMPTY
41355: LIST
41356: LIST
41357: PUSH
41358: LD_INT 1
41360: NEG
41361: PUSH
41362: LD_INT 2
41364: PUSH
41365: EMPTY
41366: LIST
41367: LIST
41368: PUSH
41369: LD_INT 3
41371: NEG
41372: PUSH
41373: LD_INT 2
41375: NEG
41376: PUSH
41377: EMPTY
41378: LIST
41379: LIST
41380: PUSH
41381: LD_INT 3
41383: NEG
41384: PUSH
41385: LD_INT 3
41387: NEG
41388: PUSH
41389: EMPTY
41390: LIST
41391: LIST
41392: PUSH
41393: EMPTY
41394: LIST
41395: LIST
41396: LIST
41397: LIST
41398: LIST
41399: LIST
41400: LIST
41401: LIST
41402: LIST
41403: LIST
41404: LIST
41405: LIST
41406: LIST
41407: LIST
41408: LIST
41409: LIST
41410: LIST
41411: LIST
41412: LIST
41413: LIST
41414: LIST
41415: LIST
41416: LIST
41417: LIST
41418: LIST
41419: LIST
41420: LIST
41421: LIST
41422: LIST
41423: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
41424: LD_ADDR_VAR 0 43
41428: PUSH
41429: LD_INT 0
41431: PUSH
41432: LD_INT 0
41434: PUSH
41435: EMPTY
41436: LIST
41437: LIST
41438: PUSH
41439: LD_INT 0
41441: PUSH
41442: LD_INT 1
41444: NEG
41445: PUSH
41446: EMPTY
41447: LIST
41448: LIST
41449: PUSH
41450: LD_INT 1
41452: PUSH
41453: LD_INT 0
41455: PUSH
41456: EMPTY
41457: LIST
41458: LIST
41459: PUSH
41460: LD_INT 1
41462: PUSH
41463: LD_INT 1
41465: PUSH
41466: EMPTY
41467: LIST
41468: LIST
41469: PUSH
41470: LD_INT 0
41472: PUSH
41473: LD_INT 1
41475: PUSH
41476: EMPTY
41477: LIST
41478: LIST
41479: PUSH
41480: LD_INT 1
41482: NEG
41483: PUSH
41484: LD_INT 0
41486: PUSH
41487: EMPTY
41488: LIST
41489: LIST
41490: PUSH
41491: LD_INT 1
41493: NEG
41494: PUSH
41495: LD_INT 1
41497: NEG
41498: PUSH
41499: EMPTY
41500: LIST
41501: LIST
41502: PUSH
41503: LD_INT 1
41505: NEG
41506: PUSH
41507: LD_INT 2
41509: NEG
41510: PUSH
41511: EMPTY
41512: LIST
41513: LIST
41514: PUSH
41515: LD_INT 0
41517: PUSH
41518: LD_INT 2
41520: NEG
41521: PUSH
41522: EMPTY
41523: LIST
41524: LIST
41525: PUSH
41526: LD_INT 1
41528: PUSH
41529: LD_INT 1
41531: NEG
41532: PUSH
41533: EMPTY
41534: LIST
41535: LIST
41536: PUSH
41537: LD_INT 2
41539: PUSH
41540: LD_INT 0
41542: PUSH
41543: EMPTY
41544: LIST
41545: LIST
41546: PUSH
41547: LD_INT 2
41549: PUSH
41550: LD_INT 1
41552: PUSH
41553: EMPTY
41554: LIST
41555: LIST
41556: PUSH
41557: LD_INT 1
41559: PUSH
41560: LD_INT 2
41562: PUSH
41563: EMPTY
41564: LIST
41565: LIST
41566: PUSH
41567: LD_INT 0
41569: PUSH
41570: LD_INT 2
41572: PUSH
41573: EMPTY
41574: LIST
41575: LIST
41576: PUSH
41577: LD_INT 1
41579: NEG
41580: PUSH
41581: LD_INT 1
41583: PUSH
41584: EMPTY
41585: LIST
41586: LIST
41587: PUSH
41588: LD_INT 2
41590: NEG
41591: PUSH
41592: LD_INT 0
41594: PUSH
41595: EMPTY
41596: LIST
41597: LIST
41598: PUSH
41599: LD_INT 2
41601: NEG
41602: PUSH
41603: LD_INT 1
41605: NEG
41606: PUSH
41607: EMPTY
41608: LIST
41609: LIST
41610: PUSH
41611: LD_INT 1
41613: NEG
41614: PUSH
41615: LD_INT 3
41617: NEG
41618: PUSH
41619: EMPTY
41620: LIST
41621: LIST
41622: PUSH
41623: LD_INT 0
41625: PUSH
41626: LD_INT 3
41628: NEG
41629: PUSH
41630: EMPTY
41631: LIST
41632: LIST
41633: PUSH
41634: LD_INT 1
41636: PUSH
41637: LD_INT 2
41639: NEG
41640: PUSH
41641: EMPTY
41642: LIST
41643: LIST
41644: PUSH
41645: LD_INT 2
41647: PUSH
41648: LD_INT 1
41650: NEG
41651: PUSH
41652: EMPTY
41653: LIST
41654: LIST
41655: PUSH
41656: LD_INT 3
41658: PUSH
41659: LD_INT 0
41661: PUSH
41662: EMPTY
41663: LIST
41664: LIST
41665: PUSH
41666: LD_INT 3
41668: PUSH
41669: LD_INT 1
41671: PUSH
41672: EMPTY
41673: LIST
41674: LIST
41675: PUSH
41676: LD_INT 1
41678: PUSH
41679: LD_INT 3
41681: PUSH
41682: EMPTY
41683: LIST
41684: LIST
41685: PUSH
41686: LD_INT 0
41688: PUSH
41689: LD_INT 3
41691: PUSH
41692: EMPTY
41693: LIST
41694: LIST
41695: PUSH
41696: LD_INT 1
41698: NEG
41699: PUSH
41700: LD_INT 2
41702: PUSH
41703: EMPTY
41704: LIST
41705: LIST
41706: PUSH
41707: LD_INT 2
41709: NEG
41710: PUSH
41711: LD_INT 1
41713: PUSH
41714: EMPTY
41715: LIST
41716: LIST
41717: PUSH
41718: LD_INT 3
41720: NEG
41721: PUSH
41722: LD_INT 0
41724: PUSH
41725: EMPTY
41726: LIST
41727: LIST
41728: PUSH
41729: LD_INT 3
41731: NEG
41732: PUSH
41733: LD_INT 1
41735: NEG
41736: PUSH
41737: EMPTY
41738: LIST
41739: LIST
41740: PUSH
41741: EMPTY
41742: LIST
41743: LIST
41744: LIST
41745: LIST
41746: LIST
41747: LIST
41748: LIST
41749: LIST
41750: LIST
41751: LIST
41752: LIST
41753: LIST
41754: LIST
41755: LIST
41756: LIST
41757: LIST
41758: LIST
41759: LIST
41760: LIST
41761: LIST
41762: LIST
41763: LIST
41764: LIST
41765: LIST
41766: LIST
41767: LIST
41768: LIST
41769: LIST
41770: LIST
41771: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
41772: LD_ADDR_VAR 0 44
41776: PUSH
41777: LD_INT 0
41779: PUSH
41780: LD_INT 0
41782: PUSH
41783: EMPTY
41784: LIST
41785: LIST
41786: PUSH
41787: LD_INT 0
41789: PUSH
41790: LD_INT 1
41792: NEG
41793: PUSH
41794: EMPTY
41795: LIST
41796: LIST
41797: PUSH
41798: LD_INT 1
41800: PUSH
41801: LD_INT 0
41803: PUSH
41804: EMPTY
41805: LIST
41806: LIST
41807: PUSH
41808: LD_INT 1
41810: PUSH
41811: LD_INT 1
41813: PUSH
41814: EMPTY
41815: LIST
41816: LIST
41817: PUSH
41818: LD_INT 0
41820: PUSH
41821: LD_INT 1
41823: PUSH
41824: EMPTY
41825: LIST
41826: LIST
41827: PUSH
41828: LD_INT 1
41830: NEG
41831: PUSH
41832: LD_INT 0
41834: PUSH
41835: EMPTY
41836: LIST
41837: LIST
41838: PUSH
41839: LD_INT 1
41841: NEG
41842: PUSH
41843: LD_INT 1
41845: NEG
41846: PUSH
41847: EMPTY
41848: LIST
41849: LIST
41850: PUSH
41851: LD_INT 1
41853: NEG
41854: PUSH
41855: LD_INT 2
41857: NEG
41858: PUSH
41859: EMPTY
41860: LIST
41861: LIST
41862: PUSH
41863: LD_INT 1
41865: PUSH
41866: LD_INT 1
41868: NEG
41869: PUSH
41870: EMPTY
41871: LIST
41872: LIST
41873: PUSH
41874: LD_INT 2
41876: PUSH
41877: LD_INT 0
41879: PUSH
41880: EMPTY
41881: LIST
41882: LIST
41883: PUSH
41884: LD_INT 2
41886: PUSH
41887: LD_INT 1
41889: PUSH
41890: EMPTY
41891: LIST
41892: LIST
41893: PUSH
41894: LD_INT 2
41896: PUSH
41897: LD_INT 2
41899: PUSH
41900: EMPTY
41901: LIST
41902: LIST
41903: PUSH
41904: LD_INT 1
41906: PUSH
41907: LD_INT 2
41909: PUSH
41910: EMPTY
41911: LIST
41912: LIST
41913: PUSH
41914: LD_INT 1
41916: NEG
41917: PUSH
41918: LD_INT 1
41920: PUSH
41921: EMPTY
41922: LIST
41923: LIST
41924: PUSH
41925: LD_INT 2
41927: NEG
41928: PUSH
41929: LD_INT 0
41931: PUSH
41932: EMPTY
41933: LIST
41934: LIST
41935: PUSH
41936: LD_INT 2
41938: NEG
41939: PUSH
41940: LD_INT 1
41942: NEG
41943: PUSH
41944: EMPTY
41945: LIST
41946: LIST
41947: PUSH
41948: LD_INT 2
41950: NEG
41951: PUSH
41952: LD_INT 2
41954: NEG
41955: PUSH
41956: EMPTY
41957: LIST
41958: LIST
41959: PUSH
41960: LD_INT 2
41962: NEG
41963: PUSH
41964: LD_INT 3
41966: NEG
41967: PUSH
41968: EMPTY
41969: LIST
41970: LIST
41971: PUSH
41972: LD_INT 2
41974: PUSH
41975: LD_INT 1
41977: NEG
41978: PUSH
41979: EMPTY
41980: LIST
41981: LIST
41982: PUSH
41983: LD_INT 3
41985: PUSH
41986: LD_INT 0
41988: PUSH
41989: EMPTY
41990: LIST
41991: LIST
41992: PUSH
41993: LD_INT 3
41995: PUSH
41996: LD_INT 1
41998: PUSH
41999: EMPTY
42000: LIST
42001: LIST
42002: PUSH
42003: LD_INT 3
42005: PUSH
42006: LD_INT 2
42008: PUSH
42009: EMPTY
42010: LIST
42011: LIST
42012: PUSH
42013: LD_INT 3
42015: PUSH
42016: LD_INT 3
42018: PUSH
42019: EMPTY
42020: LIST
42021: LIST
42022: PUSH
42023: LD_INT 2
42025: PUSH
42026: LD_INT 3
42028: PUSH
42029: EMPTY
42030: LIST
42031: LIST
42032: PUSH
42033: LD_INT 2
42035: NEG
42036: PUSH
42037: LD_INT 1
42039: PUSH
42040: EMPTY
42041: LIST
42042: LIST
42043: PUSH
42044: LD_INT 3
42046: NEG
42047: PUSH
42048: LD_INT 0
42050: PUSH
42051: EMPTY
42052: LIST
42053: LIST
42054: PUSH
42055: LD_INT 3
42057: NEG
42058: PUSH
42059: LD_INT 1
42061: NEG
42062: PUSH
42063: EMPTY
42064: LIST
42065: LIST
42066: PUSH
42067: LD_INT 3
42069: NEG
42070: PUSH
42071: LD_INT 2
42073: NEG
42074: PUSH
42075: EMPTY
42076: LIST
42077: LIST
42078: PUSH
42079: LD_INT 3
42081: NEG
42082: PUSH
42083: LD_INT 3
42085: NEG
42086: PUSH
42087: EMPTY
42088: LIST
42089: LIST
42090: PUSH
42091: EMPTY
42092: LIST
42093: LIST
42094: LIST
42095: LIST
42096: LIST
42097: LIST
42098: LIST
42099: LIST
42100: LIST
42101: LIST
42102: LIST
42103: LIST
42104: LIST
42105: LIST
42106: LIST
42107: LIST
42108: LIST
42109: LIST
42110: LIST
42111: LIST
42112: LIST
42113: LIST
42114: LIST
42115: LIST
42116: LIST
42117: LIST
42118: LIST
42119: LIST
42120: LIST
42121: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
42122: LD_ADDR_VAR 0 45
42126: PUSH
42127: LD_INT 0
42129: PUSH
42130: LD_INT 0
42132: PUSH
42133: EMPTY
42134: LIST
42135: LIST
42136: PUSH
42137: LD_INT 0
42139: PUSH
42140: LD_INT 1
42142: NEG
42143: PUSH
42144: EMPTY
42145: LIST
42146: LIST
42147: PUSH
42148: LD_INT 1
42150: PUSH
42151: LD_INT 0
42153: PUSH
42154: EMPTY
42155: LIST
42156: LIST
42157: PUSH
42158: LD_INT 1
42160: PUSH
42161: LD_INT 1
42163: PUSH
42164: EMPTY
42165: LIST
42166: LIST
42167: PUSH
42168: LD_INT 0
42170: PUSH
42171: LD_INT 1
42173: PUSH
42174: EMPTY
42175: LIST
42176: LIST
42177: PUSH
42178: LD_INT 1
42180: NEG
42181: PUSH
42182: LD_INT 0
42184: PUSH
42185: EMPTY
42186: LIST
42187: LIST
42188: PUSH
42189: LD_INT 1
42191: NEG
42192: PUSH
42193: LD_INT 1
42195: NEG
42196: PUSH
42197: EMPTY
42198: LIST
42199: LIST
42200: PUSH
42201: LD_INT 1
42203: NEG
42204: PUSH
42205: LD_INT 2
42207: NEG
42208: PUSH
42209: EMPTY
42210: LIST
42211: LIST
42212: PUSH
42213: LD_INT 0
42215: PUSH
42216: LD_INT 2
42218: NEG
42219: PUSH
42220: EMPTY
42221: LIST
42222: LIST
42223: PUSH
42224: LD_INT 1
42226: PUSH
42227: LD_INT 1
42229: NEG
42230: PUSH
42231: EMPTY
42232: LIST
42233: LIST
42234: PUSH
42235: LD_INT 2
42237: PUSH
42238: LD_INT 1
42240: PUSH
42241: EMPTY
42242: LIST
42243: LIST
42244: PUSH
42245: LD_INT 2
42247: PUSH
42248: LD_INT 2
42250: PUSH
42251: EMPTY
42252: LIST
42253: LIST
42254: PUSH
42255: LD_INT 1
42257: PUSH
42258: LD_INT 2
42260: PUSH
42261: EMPTY
42262: LIST
42263: LIST
42264: PUSH
42265: LD_INT 0
42267: PUSH
42268: LD_INT 2
42270: PUSH
42271: EMPTY
42272: LIST
42273: LIST
42274: PUSH
42275: LD_INT 1
42277: NEG
42278: PUSH
42279: LD_INT 1
42281: PUSH
42282: EMPTY
42283: LIST
42284: LIST
42285: PUSH
42286: LD_INT 2
42288: NEG
42289: PUSH
42290: LD_INT 1
42292: NEG
42293: PUSH
42294: EMPTY
42295: LIST
42296: LIST
42297: PUSH
42298: LD_INT 2
42300: NEG
42301: PUSH
42302: LD_INT 2
42304: NEG
42305: PUSH
42306: EMPTY
42307: LIST
42308: LIST
42309: PUSH
42310: LD_INT 2
42312: NEG
42313: PUSH
42314: LD_INT 3
42316: NEG
42317: PUSH
42318: EMPTY
42319: LIST
42320: LIST
42321: PUSH
42322: LD_INT 1
42324: NEG
42325: PUSH
42326: LD_INT 3
42328: NEG
42329: PUSH
42330: EMPTY
42331: LIST
42332: LIST
42333: PUSH
42334: LD_INT 0
42336: PUSH
42337: LD_INT 3
42339: NEG
42340: PUSH
42341: EMPTY
42342: LIST
42343: LIST
42344: PUSH
42345: LD_INT 1
42347: PUSH
42348: LD_INT 2
42350: NEG
42351: PUSH
42352: EMPTY
42353: LIST
42354: LIST
42355: PUSH
42356: LD_INT 3
42358: PUSH
42359: LD_INT 2
42361: PUSH
42362: EMPTY
42363: LIST
42364: LIST
42365: PUSH
42366: LD_INT 3
42368: PUSH
42369: LD_INT 3
42371: PUSH
42372: EMPTY
42373: LIST
42374: LIST
42375: PUSH
42376: LD_INT 2
42378: PUSH
42379: LD_INT 3
42381: PUSH
42382: EMPTY
42383: LIST
42384: LIST
42385: PUSH
42386: LD_INT 1
42388: PUSH
42389: LD_INT 3
42391: PUSH
42392: EMPTY
42393: LIST
42394: LIST
42395: PUSH
42396: LD_INT 0
42398: PUSH
42399: LD_INT 3
42401: PUSH
42402: EMPTY
42403: LIST
42404: LIST
42405: PUSH
42406: LD_INT 1
42408: NEG
42409: PUSH
42410: LD_INT 2
42412: PUSH
42413: EMPTY
42414: LIST
42415: LIST
42416: PUSH
42417: LD_INT 3
42419: NEG
42420: PUSH
42421: LD_INT 2
42423: NEG
42424: PUSH
42425: EMPTY
42426: LIST
42427: LIST
42428: PUSH
42429: LD_INT 3
42431: NEG
42432: PUSH
42433: LD_INT 3
42435: NEG
42436: PUSH
42437: EMPTY
42438: LIST
42439: LIST
42440: PUSH
42441: EMPTY
42442: LIST
42443: LIST
42444: LIST
42445: LIST
42446: LIST
42447: LIST
42448: LIST
42449: LIST
42450: LIST
42451: LIST
42452: LIST
42453: LIST
42454: LIST
42455: LIST
42456: LIST
42457: LIST
42458: LIST
42459: LIST
42460: LIST
42461: LIST
42462: LIST
42463: LIST
42464: LIST
42465: LIST
42466: LIST
42467: LIST
42468: LIST
42469: LIST
42470: LIST
42471: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
42472: LD_ADDR_VAR 0 46
42476: PUSH
42477: LD_INT 0
42479: PUSH
42480: LD_INT 0
42482: PUSH
42483: EMPTY
42484: LIST
42485: LIST
42486: PUSH
42487: LD_INT 0
42489: PUSH
42490: LD_INT 1
42492: NEG
42493: PUSH
42494: EMPTY
42495: LIST
42496: LIST
42497: PUSH
42498: LD_INT 1
42500: PUSH
42501: LD_INT 0
42503: PUSH
42504: EMPTY
42505: LIST
42506: LIST
42507: PUSH
42508: LD_INT 1
42510: PUSH
42511: LD_INT 1
42513: PUSH
42514: EMPTY
42515: LIST
42516: LIST
42517: PUSH
42518: LD_INT 0
42520: PUSH
42521: LD_INT 1
42523: PUSH
42524: EMPTY
42525: LIST
42526: LIST
42527: PUSH
42528: LD_INT 1
42530: NEG
42531: PUSH
42532: LD_INT 0
42534: PUSH
42535: EMPTY
42536: LIST
42537: LIST
42538: PUSH
42539: LD_INT 1
42541: NEG
42542: PUSH
42543: LD_INT 1
42545: NEG
42546: PUSH
42547: EMPTY
42548: LIST
42549: LIST
42550: PUSH
42551: LD_INT 1
42553: NEG
42554: PUSH
42555: LD_INT 2
42557: NEG
42558: PUSH
42559: EMPTY
42560: LIST
42561: LIST
42562: PUSH
42563: LD_INT 0
42565: PUSH
42566: LD_INT 2
42568: NEG
42569: PUSH
42570: EMPTY
42571: LIST
42572: LIST
42573: PUSH
42574: LD_INT 1
42576: PUSH
42577: LD_INT 1
42579: NEG
42580: PUSH
42581: EMPTY
42582: LIST
42583: LIST
42584: PUSH
42585: LD_INT 2
42587: PUSH
42588: LD_INT 0
42590: PUSH
42591: EMPTY
42592: LIST
42593: LIST
42594: PUSH
42595: LD_INT 2
42597: PUSH
42598: LD_INT 1
42600: PUSH
42601: EMPTY
42602: LIST
42603: LIST
42604: PUSH
42605: LD_INT 1
42607: PUSH
42608: LD_INT 2
42610: PUSH
42611: EMPTY
42612: LIST
42613: LIST
42614: PUSH
42615: LD_INT 0
42617: PUSH
42618: LD_INT 2
42620: PUSH
42621: EMPTY
42622: LIST
42623: LIST
42624: PUSH
42625: LD_INT 1
42627: NEG
42628: PUSH
42629: LD_INT 1
42631: PUSH
42632: EMPTY
42633: LIST
42634: LIST
42635: PUSH
42636: LD_INT 2
42638: NEG
42639: PUSH
42640: LD_INT 0
42642: PUSH
42643: EMPTY
42644: LIST
42645: LIST
42646: PUSH
42647: LD_INT 2
42649: NEG
42650: PUSH
42651: LD_INT 1
42653: NEG
42654: PUSH
42655: EMPTY
42656: LIST
42657: LIST
42658: PUSH
42659: LD_INT 1
42661: NEG
42662: PUSH
42663: LD_INT 3
42665: NEG
42666: PUSH
42667: EMPTY
42668: LIST
42669: LIST
42670: PUSH
42671: LD_INT 0
42673: PUSH
42674: LD_INT 3
42676: NEG
42677: PUSH
42678: EMPTY
42679: LIST
42680: LIST
42681: PUSH
42682: LD_INT 1
42684: PUSH
42685: LD_INT 2
42687: NEG
42688: PUSH
42689: EMPTY
42690: LIST
42691: LIST
42692: PUSH
42693: LD_INT 2
42695: PUSH
42696: LD_INT 1
42698: NEG
42699: PUSH
42700: EMPTY
42701: LIST
42702: LIST
42703: PUSH
42704: LD_INT 3
42706: PUSH
42707: LD_INT 0
42709: PUSH
42710: EMPTY
42711: LIST
42712: LIST
42713: PUSH
42714: LD_INT 3
42716: PUSH
42717: LD_INT 1
42719: PUSH
42720: EMPTY
42721: LIST
42722: LIST
42723: PUSH
42724: LD_INT 1
42726: PUSH
42727: LD_INT 3
42729: PUSH
42730: EMPTY
42731: LIST
42732: LIST
42733: PUSH
42734: LD_INT 0
42736: PUSH
42737: LD_INT 3
42739: PUSH
42740: EMPTY
42741: LIST
42742: LIST
42743: PUSH
42744: LD_INT 1
42746: NEG
42747: PUSH
42748: LD_INT 2
42750: PUSH
42751: EMPTY
42752: LIST
42753: LIST
42754: PUSH
42755: LD_INT 2
42757: NEG
42758: PUSH
42759: LD_INT 1
42761: PUSH
42762: EMPTY
42763: LIST
42764: LIST
42765: PUSH
42766: LD_INT 3
42768: NEG
42769: PUSH
42770: LD_INT 0
42772: PUSH
42773: EMPTY
42774: LIST
42775: LIST
42776: PUSH
42777: LD_INT 3
42779: NEG
42780: PUSH
42781: LD_INT 1
42783: NEG
42784: PUSH
42785: EMPTY
42786: LIST
42787: LIST
42788: PUSH
42789: EMPTY
42790: LIST
42791: LIST
42792: LIST
42793: LIST
42794: LIST
42795: LIST
42796: LIST
42797: LIST
42798: LIST
42799: LIST
42800: LIST
42801: LIST
42802: LIST
42803: LIST
42804: LIST
42805: LIST
42806: LIST
42807: LIST
42808: LIST
42809: LIST
42810: LIST
42811: LIST
42812: LIST
42813: LIST
42814: LIST
42815: LIST
42816: LIST
42817: LIST
42818: LIST
42819: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
42820: LD_ADDR_VAR 0 47
42824: PUSH
42825: LD_INT 0
42827: PUSH
42828: LD_INT 0
42830: PUSH
42831: EMPTY
42832: LIST
42833: LIST
42834: PUSH
42835: LD_INT 0
42837: PUSH
42838: LD_INT 1
42840: NEG
42841: PUSH
42842: EMPTY
42843: LIST
42844: LIST
42845: PUSH
42846: LD_INT 1
42848: PUSH
42849: LD_INT 0
42851: PUSH
42852: EMPTY
42853: LIST
42854: LIST
42855: PUSH
42856: LD_INT 1
42858: PUSH
42859: LD_INT 1
42861: PUSH
42862: EMPTY
42863: LIST
42864: LIST
42865: PUSH
42866: LD_INT 0
42868: PUSH
42869: LD_INT 1
42871: PUSH
42872: EMPTY
42873: LIST
42874: LIST
42875: PUSH
42876: LD_INT 1
42878: NEG
42879: PUSH
42880: LD_INT 0
42882: PUSH
42883: EMPTY
42884: LIST
42885: LIST
42886: PUSH
42887: LD_INT 1
42889: NEG
42890: PUSH
42891: LD_INT 1
42893: NEG
42894: PUSH
42895: EMPTY
42896: LIST
42897: LIST
42898: PUSH
42899: LD_INT 1
42901: NEG
42902: PUSH
42903: LD_INT 2
42905: NEG
42906: PUSH
42907: EMPTY
42908: LIST
42909: LIST
42910: PUSH
42911: LD_INT 0
42913: PUSH
42914: LD_INT 2
42916: NEG
42917: PUSH
42918: EMPTY
42919: LIST
42920: LIST
42921: PUSH
42922: LD_INT 1
42924: PUSH
42925: LD_INT 1
42927: NEG
42928: PUSH
42929: EMPTY
42930: LIST
42931: LIST
42932: PUSH
42933: LD_INT 2
42935: NEG
42936: PUSH
42937: LD_INT 1
42939: NEG
42940: PUSH
42941: EMPTY
42942: LIST
42943: LIST
42944: PUSH
42945: LD_INT 2
42947: NEG
42948: PUSH
42949: LD_INT 2
42951: NEG
42952: PUSH
42953: EMPTY
42954: LIST
42955: LIST
42956: PUSH
42957: EMPTY
42958: LIST
42959: LIST
42960: LIST
42961: LIST
42962: LIST
42963: LIST
42964: LIST
42965: LIST
42966: LIST
42967: LIST
42968: LIST
42969: LIST
42970: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
42971: LD_ADDR_VAR 0 48
42975: PUSH
42976: LD_INT 0
42978: PUSH
42979: LD_INT 0
42981: PUSH
42982: EMPTY
42983: LIST
42984: LIST
42985: PUSH
42986: LD_INT 0
42988: PUSH
42989: LD_INT 1
42991: NEG
42992: PUSH
42993: EMPTY
42994: LIST
42995: LIST
42996: PUSH
42997: LD_INT 1
42999: PUSH
43000: LD_INT 0
43002: PUSH
43003: EMPTY
43004: LIST
43005: LIST
43006: PUSH
43007: LD_INT 1
43009: PUSH
43010: LD_INT 1
43012: PUSH
43013: EMPTY
43014: LIST
43015: LIST
43016: PUSH
43017: LD_INT 0
43019: PUSH
43020: LD_INT 1
43022: PUSH
43023: EMPTY
43024: LIST
43025: LIST
43026: PUSH
43027: LD_INT 1
43029: NEG
43030: PUSH
43031: LD_INT 0
43033: PUSH
43034: EMPTY
43035: LIST
43036: LIST
43037: PUSH
43038: LD_INT 1
43040: NEG
43041: PUSH
43042: LD_INT 1
43044: NEG
43045: PUSH
43046: EMPTY
43047: LIST
43048: LIST
43049: PUSH
43050: LD_INT 1
43052: NEG
43053: PUSH
43054: LD_INT 2
43056: NEG
43057: PUSH
43058: EMPTY
43059: LIST
43060: LIST
43061: PUSH
43062: LD_INT 0
43064: PUSH
43065: LD_INT 2
43067: NEG
43068: PUSH
43069: EMPTY
43070: LIST
43071: LIST
43072: PUSH
43073: LD_INT 1
43075: PUSH
43076: LD_INT 1
43078: NEG
43079: PUSH
43080: EMPTY
43081: LIST
43082: LIST
43083: PUSH
43084: LD_INT 2
43086: PUSH
43087: LD_INT 0
43089: PUSH
43090: EMPTY
43091: LIST
43092: LIST
43093: PUSH
43094: LD_INT 2
43096: PUSH
43097: LD_INT 1
43099: PUSH
43100: EMPTY
43101: LIST
43102: LIST
43103: PUSH
43104: EMPTY
43105: LIST
43106: LIST
43107: LIST
43108: LIST
43109: LIST
43110: LIST
43111: LIST
43112: LIST
43113: LIST
43114: LIST
43115: LIST
43116: LIST
43117: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
43118: LD_ADDR_VAR 0 49
43122: PUSH
43123: LD_INT 0
43125: PUSH
43126: LD_INT 0
43128: PUSH
43129: EMPTY
43130: LIST
43131: LIST
43132: PUSH
43133: LD_INT 0
43135: PUSH
43136: LD_INT 1
43138: NEG
43139: PUSH
43140: EMPTY
43141: LIST
43142: LIST
43143: PUSH
43144: LD_INT 1
43146: PUSH
43147: LD_INT 0
43149: PUSH
43150: EMPTY
43151: LIST
43152: LIST
43153: PUSH
43154: LD_INT 1
43156: PUSH
43157: LD_INT 1
43159: PUSH
43160: EMPTY
43161: LIST
43162: LIST
43163: PUSH
43164: LD_INT 0
43166: PUSH
43167: LD_INT 1
43169: PUSH
43170: EMPTY
43171: LIST
43172: LIST
43173: PUSH
43174: LD_INT 1
43176: NEG
43177: PUSH
43178: LD_INT 0
43180: PUSH
43181: EMPTY
43182: LIST
43183: LIST
43184: PUSH
43185: LD_INT 1
43187: NEG
43188: PUSH
43189: LD_INT 1
43191: NEG
43192: PUSH
43193: EMPTY
43194: LIST
43195: LIST
43196: PUSH
43197: LD_INT 1
43199: PUSH
43200: LD_INT 1
43202: NEG
43203: PUSH
43204: EMPTY
43205: LIST
43206: LIST
43207: PUSH
43208: LD_INT 2
43210: PUSH
43211: LD_INT 0
43213: PUSH
43214: EMPTY
43215: LIST
43216: LIST
43217: PUSH
43218: LD_INT 2
43220: PUSH
43221: LD_INT 1
43223: PUSH
43224: EMPTY
43225: LIST
43226: LIST
43227: PUSH
43228: LD_INT 2
43230: PUSH
43231: LD_INT 2
43233: PUSH
43234: EMPTY
43235: LIST
43236: LIST
43237: PUSH
43238: LD_INT 1
43240: PUSH
43241: LD_INT 2
43243: PUSH
43244: EMPTY
43245: LIST
43246: LIST
43247: PUSH
43248: EMPTY
43249: LIST
43250: LIST
43251: LIST
43252: LIST
43253: LIST
43254: LIST
43255: LIST
43256: LIST
43257: LIST
43258: LIST
43259: LIST
43260: LIST
43261: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
43262: LD_ADDR_VAR 0 50
43266: PUSH
43267: LD_INT 0
43269: PUSH
43270: LD_INT 0
43272: PUSH
43273: EMPTY
43274: LIST
43275: LIST
43276: PUSH
43277: LD_INT 0
43279: PUSH
43280: LD_INT 1
43282: NEG
43283: PUSH
43284: EMPTY
43285: LIST
43286: LIST
43287: PUSH
43288: LD_INT 1
43290: PUSH
43291: LD_INT 0
43293: PUSH
43294: EMPTY
43295: LIST
43296: LIST
43297: PUSH
43298: LD_INT 1
43300: PUSH
43301: LD_INT 1
43303: PUSH
43304: EMPTY
43305: LIST
43306: LIST
43307: PUSH
43308: LD_INT 0
43310: PUSH
43311: LD_INT 1
43313: PUSH
43314: EMPTY
43315: LIST
43316: LIST
43317: PUSH
43318: LD_INT 1
43320: NEG
43321: PUSH
43322: LD_INT 0
43324: PUSH
43325: EMPTY
43326: LIST
43327: LIST
43328: PUSH
43329: LD_INT 1
43331: NEG
43332: PUSH
43333: LD_INT 1
43335: NEG
43336: PUSH
43337: EMPTY
43338: LIST
43339: LIST
43340: PUSH
43341: LD_INT 2
43343: PUSH
43344: LD_INT 1
43346: PUSH
43347: EMPTY
43348: LIST
43349: LIST
43350: PUSH
43351: LD_INT 2
43353: PUSH
43354: LD_INT 2
43356: PUSH
43357: EMPTY
43358: LIST
43359: LIST
43360: PUSH
43361: LD_INT 1
43363: PUSH
43364: LD_INT 2
43366: PUSH
43367: EMPTY
43368: LIST
43369: LIST
43370: PUSH
43371: LD_INT 0
43373: PUSH
43374: LD_INT 2
43376: PUSH
43377: EMPTY
43378: LIST
43379: LIST
43380: PUSH
43381: LD_INT 1
43383: NEG
43384: PUSH
43385: LD_INT 1
43387: PUSH
43388: EMPTY
43389: LIST
43390: LIST
43391: PUSH
43392: EMPTY
43393: LIST
43394: LIST
43395: LIST
43396: LIST
43397: LIST
43398: LIST
43399: LIST
43400: LIST
43401: LIST
43402: LIST
43403: LIST
43404: LIST
43405: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
43406: LD_ADDR_VAR 0 51
43410: PUSH
43411: LD_INT 0
43413: PUSH
43414: LD_INT 0
43416: PUSH
43417: EMPTY
43418: LIST
43419: LIST
43420: PUSH
43421: LD_INT 0
43423: PUSH
43424: LD_INT 1
43426: NEG
43427: PUSH
43428: EMPTY
43429: LIST
43430: LIST
43431: PUSH
43432: LD_INT 1
43434: PUSH
43435: LD_INT 0
43437: PUSH
43438: EMPTY
43439: LIST
43440: LIST
43441: PUSH
43442: LD_INT 1
43444: PUSH
43445: LD_INT 1
43447: PUSH
43448: EMPTY
43449: LIST
43450: LIST
43451: PUSH
43452: LD_INT 0
43454: PUSH
43455: LD_INT 1
43457: PUSH
43458: EMPTY
43459: LIST
43460: LIST
43461: PUSH
43462: LD_INT 1
43464: NEG
43465: PUSH
43466: LD_INT 0
43468: PUSH
43469: EMPTY
43470: LIST
43471: LIST
43472: PUSH
43473: LD_INT 1
43475: NEG
43476: PUSH
43477: LD_INT 1
43479: NEG
43480: PUSH
43481: EMPTY
43482: LIST
43483: LIST
43484: PUSH
43485: LD_INT 1
43487: PUSH
43488: LD_INT 2
43490: PUSH
43491: EMPTY
43492: LIST
43493: LIST
43494: PUSH
43495: LD_INT 0
43497: PUSH
43498: LD_INT 2
43500: PUSH
43501: EMPTY
43502: LIST
43503: LIST
43504: PUSH
43505: LD_INT 1
43507: NEG
43508: PUSH
43509: LD_INT 1
43511: PUSH
43512: EMPTY
43513: LIST
43514: LIST
43515: PUSH
43516: LD_INT 2
43518: NEG
43519: PUSH
43520: LD_INT 0
43522: PUSH
43523: EMPTY
43524: LIST
43525: LIST
43526: PUSH
43527: LD_INT 2
43529: NEG
43530: PUSH
43531: LD_INT 1
43533: NEG
43534: PUSH
43535: EMPTY
43536: LIST
43537: LIST
43538: PUSH
43539: EMPTY
43540: LIST
43541: LIST
43542: LIST
43543: LIST
43544: LIST
43545: LIST
43546: LIST
43547: LIST
43548: LIST
43549: LIST
43550: LIST
43551: LIST
43552: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
43553: LD_ADDR_VAR 0 52
43557: PUSH
43558: LD_INT 0
43560: PUSH
43561: LD_INT 0
43563: PUSH
43564: EMPTY
43565: LIST
43566: LIST
43567: PUSH
43568: LD_INT 0
43570: PUSH
43571: LD_INT 1
43573: NEG
43574: PUSH
43575: EMPTY
43576: LIST
43577: LIST
43578: PUSH
43579: LD_INT 1
43581: PUSH
43582: LD_INT 0
43584: PUSH
43585: EMPTY
43586: LIST
43587: LIST
43588: PUSH
43589: LD_INT 1
43591: PUSH
43592: LD_INT 1
43594: PUSH
43595: EMPTY
43596: LIST
43597: LIST
43598: PUSH
43599: LD_INT 0
43601: PUSH
43602: LD_INT 1
43604: PUSH
43605: EMPTY
43606: LIST
43607: LIST
43608: PUSH
43609: LD_INT 1
43611: NEG
43612: PUSH
43613: LD_INT 0
43615: PUSH
43616: EMPTY
43617: LIST
43618: LIST
43619: PUSH
43620: LD_INT 1
43622: NEG
43623: PUSH
43624: LD_INT 1
43626: NEG
43627: PUSH
43628: EMPTY
43629: LIST
43630: LIST
43631: PUSH
43632: LD_INT 1
43634: NEG
43635: PUSH
43636: LD_INT 2
43638: NEG
43639: PUSH
43640: EMPTY
43641: LIST
43642: LIST
43643: PUSH
43644: LD_INT 1
43646: NEG
43647: PUSH
43648: LD_INT 1
43650: PUSH
43651: EMPTY
43652: LIST
43653: LIST
43654: PUSH
43655: LD_INT 2
43657: NEG
43658: PUSH
43659: LD_INT 0
43661: PUSH
43662: EMPTY
43663: LIST
43664: LIST
43665: PUSH
43666: LD_INT 2
43668: NEG
43669: PUSH
43670: LD_INT 1
43672: NEG
43673: PUSH
43674: EMPTY
43675: LIST
43676: LIST
43677: PUSH
43678: LD_INT 2
43680: NEG
43681: PUSH
43682: LD_INT 2
43684: NEG
43685: PUSH
43686: EMPTY
43687: LIST
43688: LIST
43689: PUSH
43690: EMPTY
43691: LIST
43692: LIST
43693: LIST
43694: LIST
43695: LIST
43696: LIST
43697: LIST
43698: LIST
43699: LIST
43700: LIST
43701: LIST
43702: LIST
43703: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
43704: LD_ADDR_VAR 0 53
43708: PUSH
43709: LD_INT 0
43711: PUSH
43712: LD_INT 0
43714: PUSH
43715: EMPTY
43716: LIST
43717: LIST
43718: PUSH
43719: LD_INT 0
43721: PUSH
43722: LD_INT 1
43724: NEG
43725: PUSH
43726: EMPTY
43727: LIST
43728: LIST
43729: PUSH
43730: LD_INT 1
43732: PUSH
43733: LD_INT 0
43735: PUSH
43736: EMPTY
43737: LIST
43738: LIST
43739: PUSH
43740: LD_INT 1
43742: PUSH
43743: LD_INT 1
43745: PUSH
43746: EMPTY
43747: LIST
43748: LIST
43749: PUSH
43750: LD_INT 0
43752: PUSH
43753: LD_INT 1
43755: PUSH
43756: EMPTY
43757: LIST
43758: LIST
43759: PUSH
43760: LD_INT 1
43762: NEG
43763: PUSH
43764: LD_INT 0
43766: PUSH
43767: EMPTY
43768: LIST
43769: LIST
43770: PUSH
43771: LD_INT 1
43773: NEG
43774: PUSH
43775: LD_INT 1
43777: NEG
43778: PUSH
43779: EMPTY
43780: LIST
43781: LIST
43782: PUSH
43783: LD_INT 1
43785: NEG
43786: PUSH
43787: LD_INT 2
43789: NEG
43790: PUSH
43791: EMPTY
43792: LIST
43793: LIST
43794: PUSH
43795: LD_INT 0
43797: PUSH
43798: LD_INT 2
43800: NEG
43801: PUSH
43802: EMPTY
43803: LIST
43804: LIST
43805: PUSH
43806: LD_INT 1
43808: PUSH
43809: LD_INT 1
43811: NEG
43812: PUSH
43813: EMPTY
43814: LIST
43815: LIST
43816: PUSH
43817: LD_INT 2
43819: PUSH
43820: LD_INT 0
43822: PUSH
43823: EMPTY
43824: LIST
43825: LIST
43826: PUSH
43827: LD_INT 2
43829: PUSH
43830: LD_INT 1
43832: PUSH
43833: EMPTY
43834: LIST
43835: LIST
43836: PUSH
43837: LD_INT 2
43839: PUSH
43840: LD_INT 2
43842: PUSH
43843: EMPTY
43844: LIST
43845: LIST
43846: PUSH
43847: LD_INT 1
43849: PUSH
43850: LD_INT 2
43852: PUSH
43853: EMPTY
43854: LIST
43855: LIST
43856: PUSH
43857: LD_INT 0
43859: PUSH
43860: LD_INT 2
43862: PUSH
43863: EMPTY
43864: LIST
43865: LIST
43866: PUSH
43867: LD_INT 1
43869: NEG
43870: PUSH
43871: LD_INT 1
43873: PUSH
43874: EMPTY
43875: LIST
43876: LIST
43877: PUSH
43878: LD_INT 2
43880: NEG
43881: PUSH
43882: LD_INT 0
43884: PUSH
43885: EMPTY
43886: LIST
43887: LIST
43888: PUSH
43889: LD_INT 2
43891: NEG
43892: PUSH
43893: LD_INT 1
43895: NEG
43896: PUSH
43897: EMPTY
43898: LIST
43899: LIST
43900: PUSH
43901: LD_INT 2
43903: NEG
43904: PUSH
43905: LD_INT 2
43907: NEG
43908: PUSH
43909: EMPTY
43910: LIST
43911: LIST
43912: PUSH
43913: EMPTY
43914: LIST
43915: LIST
43916: LIST
43917: LIST
43918: LIST
43919: LIST
43920: LIST
43921: LIST
43922: LIST
43923: LIST
43924: LIST
43925: LIST
43926: LIST
43927: LIST
43928: LIST
43929: LIST
43930: LIST
43931: LIST
43932: LIST
43933: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
43934: LD_ADDR_VAR 0 54
43938: PUSH
43939: LD_INT 0
43941: PUSH
43942: LD_INT 0
43944: PUSH
43945: EMPTY
43946: LIST
43947: LIST
43948: PUSH
43949: LD_INT 0
43951: PUSH
43952: LD_INT 1
43954: NEG
43955: PUSH
43956: EMPTY
43957: LIST
43958: LIST
43959: PUSH
43960: LD_INT 1
43962: PUSH
43963: LD_INT 0
43965: PUSH
43966: EMPTY
43967: LIST
43968: LIST
43969: PUSH
43970: LD_INT 1
43972: PUSH
43973: LD_INT 1
43975: PUSH
43976: EMPTY
43977: LIST
43978: LIST
43979: PUSH
43980: LD_INT 0
43982: PUSH
43983: LD_INT 1
43985: PUSH
43986: EMPTY
43987: LIST
43988: LIST
43989: PUSH
43990: LD_INT 1
43992: NEG
43993: PUSH
43994: LD_INT 0
43996: PUSH
43997: EMPTY
43998: LIST
43999: LIST
44000: PUSH
44001: LD_INT 1
44003: NEG
44004: PUSH
44005: LD_INT 1
44007: NEG
44008: PUSH
44009: EMPTY
44010: LIST
44011: LIST
44012: PUSH
44013: LD_INT 1
44015: NEG
44016: PUSH
44017: LD_INT 2
44019: NEG
44020: PUSH
44021: EMPTY
44022: LIST
44023: LIST
44024: PUSH
44025: LD_INT 0
44027: PUSH
44028: LD_INT 2
44030: NEG
44031: PUSH
44032: EMPTY
44033: LIST
44034: LIST
44035: PUSH
44036: LD_INT 1
44038: PUSH
44039: LD_INT 1
44041: NEG
44042: PUSH
44043: EMPTY
44044: LIST
44045: LIST
44046: PUSH
44047: LD_INT 2
44049: PUSH
44050: LD_INT 0
44052: PUSH
44053: EMPTY
44054: LIST
44055: LIST
44056: PUSH
44057: LD_INT 2
44059: PUSH
44060: LD_INT 1
44062: PUSH
44063: EMPTY
44064: LIST
44065: LIST
44066: PUSH
44067: LD_INT 2
44069: PUSH
44070: LD_INT 2
44072: PUSH
44073: EMPTY
44074: LIST
44075: LIST
44076: PUSH
44077: LD_INT 1
44079: PUSH
44080: LD_INT 2
44082: PUSH
44083: EMPTY
44084: LIST
44085: LIST
44086: PUSH
44087: LD_INT 0
44089: PUSH
44090: LD_INT 2
44092: PUSH
44093: EMPTY
44094: LIST
44095: LIST
44096: PUSH
44097: LD_INT 1
44099: NEG
44100: PUSH
44101: LD_INT 1
44103: PUSH
44104: EMPTY
44105: LIST
44106: LIST
44107: PUSH
44108: LD_INT 2
44110: NEG
44111: PUSH
44112: LD_INT 0
44114: PUSH
44115: EMPTY
44116: LIST
44117: LIST
44118: PUSH
44119: LD_INT 2
44121: NEG
44122: PUSH
44123: LD_INT 1
44125: NEG
44126: PUSH
44127: EMPTY
44128: LIST
44129: LIST
44130: PUSH
44131: LD_INT 2
44133: NEG
44134: PUSH
44135: LD_INT 2
44137: NEG
44138: PUSH
44139: EMPTY
44140: LIST
44141: LIST
44142: PUSH
44143: EMPTY
44144: LIST
44145: LIST
44146: LIST
44147: LIST
44148: LIST
44149: LIST
44150: LIST
44151: LIST
44152: LIST
44153: LIST
44154: LIST
44155: LIST
44156: LIST
44157: LIST
44158: LIST
44159: LIST
44160: LIST
44161: LIST
44162: LIST
44163: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
44164: LD_ADDR_VAR 0 55
44168: PUSH
44169: LD_INT 0
44171: PUSH
44172: LD_INT 0
44174: PUSH
44175: EMPTY
44176: LIST
44177: LIST
44178: PUSH
44179: LD_INT 0
44181: PUSH
44182: LD_INT 1
44184: NEG
44185: PUSH
44186: EMPTY
44187: LIST
44188: LIST
44189: PUSH
44190: LD_INT 1
44192: PUSH
44193: LD_INT 0
44195: PUSH
44196: EMPTY
44197: LIST
44198: LIST
44199: PUSH
44200: LD_INT 1
44202: PUSH
44203: LD_INT 1
44205: PUSH
44206: EMPTY
44207: LIST
44208: LIST
44209: PUSH
44210: LD_INT 0
44212: PUSH
44213: LD_INT 1
44215: PUSH
44216: EMPTY
44217: LIST
44218: LIST
44219: PUSH
44220: LD_INT 1
44222: NEG
44223: PUSH
44224: LD_INT 0
44226: PUSH
44227: EMPTY
44228: LIST
44229: LIST
44230: PUSH
44231: LD_INT 1
44233: NEG
44234: PUSH
44235: LD_INT 1
44237: NEG
44238: PUSH
44239: EMPTY
44240: LIST
44241: LIST
44242: PUSH
44243: LD_INT 1
44245: NEG
44246: PUSH
44247: LD_INT 2
44249: NEG
44250: PUSH
44251: EMPTY
44252: LIST
44253: LIST
44254: PUSH
44255: LD_INT 0
44257: PUSH
44258: LD_INT 2
44260: NEG
44261: PUSH
44262: EMPTY
44263: LIST
44264: LIST
44265: PUSH
44266: LD_INT 1
44268: PUSH
44269: LD_INT 1
44271: NEG
44272: PUSH
44273: EMPTY
44274: LIST
44275: LIST
44276: PUSH
44277: LD_INT 2
44279: PUSH
44280: LD_INT 0
44282: PUSH
44283: EMPTY
44284: LIST
44285: LIST
44286: PUSH
44287: LD_INT 2
44289: PUSH
44290: LD_INT 1
44292: PUSH
44293: EMPTY
44294: LIST
44295: LIST
44296: PUSH
44297: LD_INT 2
44299: PUSH
44300: LD_INT 2
44302: PUSH
44303: EMPTY
44304: LIST
44305: LIST
44306: PUSH
44307: LD_INT 1
44309: PUSH
44310: LD_INT 2
44312: PUSH
44313: EMPTY
44314: LIST
44315: LIST
44316: PUSH
44317: LD_INT 0
44319: PUSH
44320: LD_INT 2
44322: PUSH
44323: EMPTY
44324: LIST
44325: LIST
44326: PUSH
44327: LD_INT 1
44329: NEG
44330: PUSH
44331: LD_INT 1
44333: PUSH
44334: EMPTY
44335: LIST
44336: LIST
44337: PUSH
44338: LD_INT 2
44340: NEG
44341: PUSH
44342: LD_INT 0
44344: PUSH
44345: EMPTY
44346: LIST
44347: LIST
44348: PUSH
44349: LD_INT 2
44351: NEG
44352: PUSH
44353: LD_INT 1
44355: NEG
44356: PUSH
44357: EMPTY
44358: LIST
44359: LIST
44360: PUSH
44361: LD_INT 2
44363: NEG
44364: PUSH
44365: LD_INT 2
44367: NEG
44368: PUSH
44369: EMPTY
44370: LIST
44371: LIST
44372: PUSH
44373: EMPTY
44374: LIST
44375: LIST
44376: LIST
44377: LIST
44378: LIST
44379: LIST
44380: LIST
44381: LIST
44382: LIST
44383: LIST
44384: LIST
44385: LIST
44386: LIST
44387: LIST
44388: LIST
44389: LIST
44390: LIST
44391: LIST
44392: LIST
44393: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
44394: LD_ADDR_VAR 0 56
44398: PUSH
44399: LD_INT 0
44401: PUSH
44402: LD_INT 0
44404: PUSH
44405: EMPTY
44406: LIST
44407: LIST
44408: PUSH
44409: LD_INT 0
44411: PUSH
44412: LD_INT 1
44414: NEG
44415: PUSH
44416: EMPTY
44417: LIST
44418: LIST
44419: PUSH
44420: LD_INT 1
44422: PUSH
44423: LD_INT 0
44425: PUSH
44426: EMPTY
44427: LIST
44428: LIST
44429: PUSH
44430: LD_INT 1
44432: PUSH
44433: LD_INT 1
44435: PUSH
44436: EMPTY
44437: LIST
44438: LIST
44439: PUSH
44440: LD_INT 0
44442: PUSH
44443: LD_INT 1
44445: PUSH
44446: EMPTY
44447: LIST
44448: LIST
44449: PUSH
44450: LD_INT 1
44452: NEG
44453: PUSH
44454: LD_INT 0
44456: PUSH
44457: EMPTY
44458: LIST
44459: LIST
44460: PUSH
44461: LD_INT 1
44463: NEG
44464: PUSH
44465: LD_INT 1
44467: NEG
44468: PUSH
44469: EMPTY
44470: LIST
44471: LIST
44472: PUSH
44473: LD_INT 1
44475: NEG
44476: PUSH
44477: LD_INT 2
44479: NEG
44480: PUSH
44481: EMPTY
44482: LIST
44483: LIST
44484: PUSH
44485: LD_INT 0
44487: PUSH
44488: LD_INT 2
44490: NEG
44491: PUSH
44492: EMPTY
44493: LIST
44494: LIST
44495: PUSH
44496: LD_INT 1
44498: PUSH
44499: LD_INT 1
44501: NEG
44502: PUSH
44503: EMPTY
44504: LIST
44505: LIST
44506: PUSH
44507: LD_INT 2
44509: PUSH
44510: LD_INT 0
44512: PUSH
44513: EMPTY
44514: LIST
44515: LIST
44516: PUSH
44517: LD_INT 2
44519: PUSH
44520: LD_INT 1
44522: PUSH
44523: EMPTY
44524: LIST
44525: LIST
44526: PUSH
44527: LD_INT 2
44529: PUSH
44530: LD_INT 2
44532: PUSH
44533: EMPTY
44534: LIST
44535: LIST
44536: PUSH
44537: LD_INT 1
44539: PUSH
44540: LD_INT 2
44542: PUSH
44543: EMPTY
44544: LIST
44545: LIST
44546: PUSH
44547: LD_INT 0
44549: PUSH
44550: LD_INT 2
44552: PUSH
44553: EMPTY
44554: LIST
44555: LIST
44556: PUSH
44557: LD_INT 1
44559: NEG
44560: PUSH
44561: LD_INT 1
44563: PUSH
44564: EMPTY
44565: LIST
44566: LIST
44567: PUSH
44568: LD_INT 2
44570: NEG
44571: PUSH
44572: LD_INT 0
44574: PUSH
44575: EMPTY
44576: LIST
44577: LIST
44578: PUSH
44579: LD_INT 2
44581: NEG
44582: PUSH
44583: LD_INT 1
44585: NEG
44586: PUSH
44587: EMPTY
44588: LIST
44589: LIST
44590: PUSH
44591: LD_INT 2
44593: NEG
44594: PUSH
44595: LD_INT 2
44597: NEG
44598: PUSH
44599: EMPTY
44600: LIST
44601: LIST
44602: PUSH
44603: EMPTY
44604: LIST
44605: LIST
44606: LIST
44607: LIST
44608: LIST
44609: LIST
44610: LIST
44611: LIST
44612: LIST
44613: LIST
44614: LIST
44615: LIST
44616: LIST
44617: LIST
44618: LIST
44619: LIST
44620: LIST
44621: LIST
44622: LIST
44623: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
44624: LD_ADDR_VAR 0 57
44628: PUSH
44629: LD_INT 0
44631: PUSH
44632: LD_INT 0
44634: PUSH
44635: EMPTY
44636: LIST
44637: LIST
44638: PUSH
44639: LD_INT 0
44641: PUSH
44642: LD_INT 1
44644: NEG
44645: PUSH
44646: EMPTY
44647: LIST
44648: LIST
44649: PUSH
44650: LD_INT 1
44652: PUSH
44653: LD_INT 0
44655: PUSH
44656: EMPTY
44657: LIST
44658: LIST
44659: PUSH
44660: LD_INT 1
44662: PUSH
44663: LD_INT 1
44665: PUSH
44666: EMPTY
44667: LIST
44668: LIST
44669: PUSH
44670: LD_INT 0
44672: PUSH
44673: LD_INT 1
44675: PUSH
44676: EMPTY
44677: LIST
44678: LIST
44679: PUSH
44680: LD_INT 1
44682: NEG
44683: PUSH
44684: LD_INT 0
44686: PUSH
44687: EMPTY
44688: LIST
44689: LIST
44690: PUSH
44691: LD_INT 1
44693: NEG
44694: PUSH
44695: LD_INT 1
44697: NEG
44698: PUSH
44699: EMPTY
44700: LIST
44701: LIST
44702: PUSH
44703: LD_INT 1
44705: NEG
44706: PUSH
44707: LD_INT 2
44709: NEG
44710: PUSH
44711: EMPTY
44712: LIST
44713: LIST
44714: PUSH
44715: LD_INT 0
44717: PUSH
44718: LD_INT 2
44720: NEG
44721: PUSH
44722: EMPTY
44723: LIST
44724: LIST
44725: PUSH
44726: LD_INT 1
44728: PUSH
44729: LD_INT 1
44731: NEG
44732: PUSH
44733: EMPTY
44734: LIST
44735: LIST
44736: PUSH
44737: LD_INT 2
44739: PUSH
44740: LD_INT 0
44742: PUSH
44743: EMPTY
44744: LIST
44745: LIST
44746: PUSH
44747: LD_INT 2
44749: PUSH
44750: LD_INT 1
44752: PUSH
44753: EMPTY
44754: LIST
44755: LIST
44756: PUSH
44757: LD_INT 2
44759: PUSH
44760: LD_INT 2
44762: PUSH
44763: EMPTY
44764: LIST
44765: LIST
44766: PUSH
44767: LD_INT 1
44769: PUSH
44770: LD_INT 2
44772: PUSH
44773: EMPTY
44774: LIST
44775: LIST
44776: PUSH
44777: LD_INT 0
44779: PUSH
44780: LD_INT 2
44782: PUSH
44783: EMPTY
44784: LIST
44785: LIST
44786: PUSH
44787: LD_INT 1
44789: NEG
44790: PUSH
44791: LD_INT 1
44793: PUSH
44794: EMPTY
44795: LIST
44796: LIST
44797: PUSH
44798: LD_INT 2
44800: NEG
44801: PUSH
44802: LD_INT 0
44804: PUSH
44805: EMPTY
44806: LIST
44807: LIST
44808: PUSH
44809: LD_INT 2
44811: NEG
44812: PUSH
44813: LD_INT 1
44815: NEG
44816: PUSH
44817: EMPTY
44818: LIST
44819: LIST
44820: PUSH
44821: LD_INT 2
44823: NEG
44824: PUSH
44825: LD_INT 2
44827: NEG
44828: PUSH
44829: EMPTY
44830: LIST
44831: LIST
44832: PUSH
44833: EMPTY
44834: LIST
44835: LIST
44836: LIST
44837: LIST
44838: LIST
44839: LIST
44840: LIST
44841: LIST
44842: LIST
44843: LIST
44844: LIST
44845: LIST
44846: LIST
44847: LIST
44848: LIST
44849: LIST
44850: LIST
44851: LIST
44852: LIST
44853: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
44854: LD_ADDR_VAR 0 58
44858: PUSH
44859: LD_INT 0
44861: PUSH
44862: LD_INT 0
44864: PUSH
44865: EMPTY
44866: LIST
44867: LIST
44868: PUSH
44869: LD_INT 0
44871: PUSH
44872: LD_INT 1
44874: NEG
44875: PUSH
44876: EMPTY
44877: LIST
44878: LIST
44879: PUSH
44880: LD_INT 1
44882: PUSH
44883: LD_INT 0
44885: PUSH
44886: EMPTY
44887: LIST
44888: LIST
44889: PUSH
44890: LD_INT 1
44892: PUSH
44893: LD_INT 1
44895: PUSH
44896: EMPTY
44897: LIST
44898: LIST
44899: PUSH
44900: LD_INT 0
44902: PUSH
44903: LD_INT 1
44905: PUSH
44906: EMPTY
44907: LIST
44908: LIST
44909: PUSH
44910: LD_INT 1
44912: NEG
44913: PUSH
44914: LD_INT 0
44916: PUSH
44917: EMPTY
44918: LIST
44919: LIST
44920: PUSH
44921: LD_INT 1
44923: NEG
44924: PUSH
44925: LD_INT 1
44927: NEG
44928: PUSH
44929: EMPTY
44930: LIST
44931: LIST
44932: PUSH
44933: LD_INT 1
44935: NEG
44936: PUSH
44937: LD_INT 2
44939: NEG
44940: PUSH
44941: EMPTY
44942: LIST
44943: LIST
44944: PUSH
44945: LD_INT 0
44947: PUSH
44948: LD_INT 2
44950: NEG
44951: PUSH
44952: EMPTY
44953: LIST
44954: LIST
44955: PUSH
44956: LD_INT 1
44958: PUSH
44959: LD_INT 1
44961: NEG
44962: PUSH
44963: EMPTY
44964: LIST
44965: LIST
44966: PUSH
44967: LD_INT 2
44969: PUSH
44970: LD_INT 0
44972: PUSH
44973: EMPTY
44974: LIST
44975: LIST
44976: PUSH
44977: LD_INT 2
44979: PUSH
44980: LD_INT 1
44982: PUSH
44983: EMPTY
44984: LIST
44985: LIST
44986: PUSH
44987: LD_INT 2
44989: PUSH
44990: LD_INT 2
44992: PUSH
44993: EMPTY
44994: LIST
44995: LIST
44996: PUSH
44997: LD_INT 1
44999: PUSH
45000: LD_INT 2
45002: PUSH
45003: EMPTY
45004: LIST
45005: LIST
45006: PUSH
45007: LD_INT 0
45009: PUSH
45010: LD_INT 2
45012: PUSH
45013: EMPTY
45014: LIST
45015: LIST
45016: PUSH
45017: LD_INT 1
45019: NEG
45020: PUSH
45021: LD_INT 1
45023: PUSH
45024: EMPTY
45025: LIST
45026: LIST
45027: PUSH
45028: LD_INT 2
45030: NEG
45031: PUSH
45032: LD_INT 0
45034: PUSH
45035: EMPTY
45036: LIST
45037: LIST
45038: PUSH
45039: LD_INT 2
45041: NEG
45042: PUSH
45043: LD_INT 1
45045: NEG
45046: PUSH
45047: EMPTY
45048: LIST
45049: LIST
45050: PUSH
45051: LD_INT 2
45053: NEG
45054: PUSH
45055: LD_INT 2
45057: NEG
45058: PUSH
45059: EMPTY
45060: LIST
45061: LIST
45062: PUSH
45063: EMPTY
45064: LIST
45065: LIST
45066: LIST
45067: LIST
45068: LIST
45069: LIST
45070: LIST
45071: LIST
45072: LIST
45073: LIST
45074: LIST
45075: LIST
45076: LIST
45077: LIST
45078: LIST
45079: LIST
45080: LIST
45081: LIST
45082: LIST
45083: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
45084: LD_ADDR_VAR 0 59
45088: PUSH
45089: LD_INT 0
45091: PUSH
45092: LD_INT 0
45094: PUSH
45095: EMPTY
45096: LIST
45097: LIST
45098: PUSH
45099: LD_INT 0
45101: PUSH
45102: LD_INT 1
45104: NEG
45105: PUSH
45106: EMPTY
45107: LIST
45108: LIST
45109: PUSH
45110: LD_INT 1
45112: PUSH
45113: LD_INT 0
45115: PUSH
45116: EMPTY
45117: LIST
45118: LIST
45119: PUSH
45120: LD_INT 1
45122: PUSH
45123: LD_INT 1
45125: PUSH
45126: EMPTY
45127: LIST
45128: LIST
45129: PUSH
45130: LD_INT 0
45132: PUSH
45133: LD_INT 1
45135: PUSH
45136: EMPTY
45137: LIST
45138: LIST
45139: PUSH
45140: LD_INT 1
45142: NEG
45143: PUSH
45144: LD_INT 0
45146: PUSH
45147: EMPTY
45148: LIST
45149: LIST
45150: PUSH
45151: LD_INT 1
45153: NEG
45154: PUSH
45155: LD_INT 1
45157: NEG
45158: PUSH
45159: EMPTY
45160: LIST
45161: LIST
45162: PUSH
45163: EMPTY
45164: LIST
45165: LIST
45166: LIST
45167: LIST
45168: LIST
45169: LIST
45170: LIST
45171: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
45172: LD_ADDR_VAR 0 60
45176: PUSH
45177: LD_INT 0
45179: PUSH
45180: LD_INT 0
45182: PUSH
45183: EMPTY
45184: LIST
45185: LIST
45186: PUSH
45187: LD_INT 0
45189: PUSH
45190: LD_INT 1
45192: NEG
45193: PUSH
45194: EMPTY
45195: LIST
45196: LIST
45197: PUSH
45198: LD_INT 1
45200: PUSH
45201: LD_INT 0
45203: PUSH
45204: EMPTY
45205: LIST
45206: LIST
45207: PUSH
45208: LD_INT 1
45210: PUSH
45211: LD_INT 1
45213: PUSH
45214: EMPTY
45215: LIST
45216: LIST
45217: PUSH
45218: LD_INT 0
45220: PUSH
45221: LD_INT 1
45223: PUSH
45224: EMPTY
45225: LIST
45226: LIST
45227: PUSH
45228: LD_INT 1
45230: NEG
45231: PUSH
45232: LD_INT 0
45234: PUSH
45235: EMPTY
45236: LIST
45237: LIST
45238: PUSH
45239: LD_INT 1
45241: NEG
45242: PUSH
45243: LD_INT 1
45245: NEG
45246: PUSH
45247: EMPTY
45248: LIST
45249: LIST
45250: PUSH
45251: EMPTY
45252: LIST
45253: LIST
45254: LIST
45255: LIST
45256: LIST
45257: LIST
45258: LIST
45259: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
45260: LD_ADDR_VAR 0 61
45264: PUSH
45265: LD_INT 0
45267: PUSH
45268: LD_INT 0
45270: PUSH
45271: EMPTY
45272: LIST
45273: LIST
45274: PUSH
45275: LD_INT 0
45277: PUSH
45278: LD_INT 1
45280: NEG
45281: PUSH
45282: EMPTY
45283: LIST
45284: LIST
45285: PUSH
45286: LD_INT 1
45288: PUSH
45289: LD_INT 0
45291: PUSH
45292: EMPTY
45293: LIST
45294: LIST
45295: PUSH
45296: LD_INT 1
45298: PUSH
45299: LD_INT 1
45301: PUSH
45302: EMPTY
45303: LIST
45304: LIST
45305: PUSH
45306: LD_INT 0
45308: PUSH
45309: LD_INT 1
45311: PUSH
45312: EMPTY
45313: LIST
45314: LIST
45315: PUSH
45316: LD_INT 1
45318: NEG
45319: PUSH
45320: LD_INT 0
45322: PUSH
45323: EMPTY
45324: LIST
45325: LIST
45326: PUSH
45327: LD_INT 1
45329: NEG
45330: PUSH
45331: LD_INT 1
45333: NEG
45334: PUSH
45335: EMPTY
45336: LIST
45337: LIST
45338: PUSH
45339: EMPTY
45340: LIST
45341: LIST
45342: LIST
45343: LIST
45344: LIST
45345: LIST
45346: LIST
45347: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
45348: LD_ADDR_VAR 0 62
45352: PUSH
45353: LD_INT 0
45355: PUSH
45356: LD_INT 0
45358: PUSH
45359: EMPTY
45360: LIST
45361: LIST
45362: PUSH
45363: LD_INT 0
45365: PUSH
45366: LD_INT 1
45368: NEG
45369: PUSH
45370: EMPTY
45371: LIST
45372: LIST
45373: PUSH
45374: LD_INT 1
45376: PUSH
45377: LD_INT 0
45379: PUSH
45380: EMPTY
45381: LIST
45382: LIST
45383: PUSH
45384: LD_INT 1
45386: PUSH
45387: LD_INT 1
45389: PUSH
45390: EMPTY
45391: LIST
45392: LIST
45393: PUSH
45394: LD_INT 0
45396: PUSH
45397: LD_INT 1
45399: PUSH
45400: EMPTY
45401: LIST
45402: LIST
45403: PUSH
45404: LD_INT 1
45406: NEG
45407: PUSH
45408: LD_INT 0
45410: PUSH
45411: EMPTY
45412: LIST
45413: LIST
45414: PUSH
45415: LD_INT 1
45417: NEG
45418: PUSH
45419: LD_INT 1
45421: NEG
45422: PUSH
45423: EMPTY
45424: LIST
45425: LIST
45426: PUSH
45427: EMPTY
45428: LIST
45429: LIST
45430: LIST
45431: LIST
45432: LIST
45433: LIST
45434: LIST
45435: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
45436: LD_ADDR_VAR 0 63
45440: PUSH
45441: LD_INT 0
45443: PUSH
45444: LD_INT 0
45446: PUSH
45447: EMPTY
45448: LIST
45449: LIST
45450: PUSH
45451: LD_INT 0
45453: PUSH
45454: LD_INT 1
45456: NEG
45457: PUSH
45458: EMPTY
45459: LIST
45460: LIST
45461: PUSH
45462: LD_INT 1
45464: PUSH
45465: LD_INT 0
45467: PUSH
45468: EMPTY
45469: LIST
45470: LIST
45471: PUSH
45472: LD_INT 1
45474: PUSH
45475: LD_INT 1
45477: PUSH
45478: EMPTY
45479: LIST
45480: LIST
45481: PUSH
45482: LD_INT 0
45484: PUSH
45485: LD_INT 1
45487: PUSH
45488: EMPTY
45489: LIST
45490: LIST
45491: PUSH
45492: LD_INT 1
45494: NEG
45495: PUSH
45496: LD_INT 0
45498: PUSH
45499: EMPTY
45500: LIST
45501: LIST
45502: PUSH
45503: LD_INT 1
45505: NEG
45506: PUSH
45507: LD_INT 1
45509: NEG
45510: PUSH
45511: EMPTY
45512: LIST
45513: LIST
45514: PUSH
45515: EMPTY
45516: LIST
45517: LIST
45518: LIST
45519: LIST
45520: LIST
45521: LIST
45522: LIST
45523: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
45524: LD_ADDR_VAR 0 64
45528: PUSH
45529: LD_INT 0
45531: PUSH
45532: LD_INT 0
45534: PUSH
45535: EMPTY
45536: LIST
45537: LIST
45538: PUSH
45539: LD_INT 0
45541: PUSH
45542: LD_INT 1
45544: NEG
45545: PUSH
45546: EMPTY
45547: LIST
45548: LIST
45549: PUSH
45550: LD_INT 1
45552: PUSH
45553: LD_INT 0
45555: PUSH
45556: EMPTY
45557: LIST
45558: LIST
45559: PUSH
45560: LD_INT 1
45562: PUSH
45563: LD_INT 1
45565: PUSH
45566: EMPTY
45567: LIST
45568: LIST
45569: PUSH
45570: LD_INT 0
45572: PUSH
45573: LD_INT 1
45575: PUSH
45576: EMPTY
45577: LIST
45578: LIST
45579: PUSH
45580: LD_INT 1
45582: NEG
45583: PUSH
45584: LD_INT 0
45586: PUSH
45587: EMPTY
45588: LIST
45589: LIST
45590: PUSH
45591: LD_INT 1
45593: NEG
45594: PUSH
45595: LD_INT 1
45597: NEG
45598: PUSH
45599: EMPTY
45600: LIST
45601: LIST
45602: PUSH
45603: EMPTY
45604: LIST
45605: LIST
45606: LIST
45607: LIST
45608: LIST
45609: LIST
45610: LIST
45611: ST_TO_ADDR
// end ; 1 :
45612: GO 51509
45614: LD_INT 1
45616: DOUBLE
45617: EQUAL
45618: IFTRUE 45622
45620: GO 48245
45622: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
45623: LD_ADDR_VAR 0 11
45627: PUSH
45628: LD_INT 1
45630: NEG
45631: PUSH
45632: LD_INT 3
45634: NEG
45635: PUSH
45636: EMPTY
45637: LIST
45638: LIST
45639: PUSH
45640: LD_INT 0
45642: PUSH
45643: LD_INT 3
45645: NEG
45646: PUSH
45647: EMPTY
45648: LIST
45649: LIST
45650: PUSH
45651: LD_INT 1
45653: PUSH
45654: LD_INT 2
45656: NEG
45657: PUSH
45658: EMPTY
45659: LIST
45660: LIST
45661: PUSH
45662: EMPTY
45663: LIST
45664: LIST
45665: LIST
45666: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
45667: LD_ADDR_VAR 0 12
45671: PUSH
45672: LD_INT 2
45674: PUSH
45675: LD_INT 1
45677: NEG
45678: PUSH
45679: EMPTY
45680: LIST
45681: LIST
45682: PUSH
45683: LD_INT 3
45685: PUSH
45686: LD_INT 0
45688: PUSH
45689: EMPTY
45690: LIST
45691: LIST
45692: PUSH
45693: LD_INT 3
45695: PUSH
45696: LD_INT 1
45698: PUSH
45699: EMPTY
45700: LIST
45701: LIST
45702: PUSH
45703: EMPTY
45704: LIST
45705: LIST
45706: LIST
45707: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
45708: LD_ADDR_VAR 0 13
45712: PUSH
45713: LD_INT 3
45715: PUSH
45716: LD_INT 2
45718: PUSH
45719: EMPTY
45720: LIST
45721: LIST
45722: PUSH
45723: LD_INT 3
45725: PUSH
45726: LD_INT 3
45728: PUSH
45729: EMPTY
45730: LIST
45731: LIST
45732: PUSH
45733: LD_INT 2
45735: PUSH
45736: LD_INT 3
45738: PUSH
45739: EMPTY
45740: LIST
45741: LIST
45742: PUSH
45743: EMPTY
45744: LIST
45745: LIST
45746: LIST
45747: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
45748: LD_ADDR_VAR 0 14
45752: PUSH
45753: LD_INT 1
45755: PUSH
45756: LD_INT 3
45758: PUSH
45759: EMPTY
45760: LIST
45761: LIST
45762: PUSH
45763: LD_INT 0
45765: PUSH
45766: LD_INT 3
45768: PUSH
45769: EMPTY
45770: LIST
45771: LIST
45772: PUSH
45773: LD_INT 1
45775: NEG
45776: PUSH
45777: LD_INT 2
45779: PUSH
45780: EMPTY
45781: LIST
45782: LIST
45783: PUSH
45784: EMPTY
45785: LIST
45786: LIST
45787: LIST
45788: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
45789: LD_ADDR_VAR 0 15
45793: PUSH
45794: LD_INT 2
45796: NEG
45797: PUSH
45798: LD_INT 1
45800: PUSH
45801: EMPTY
45802: LIST
45803: LIST
45804: PUSH
45805: LD_INT 3
45807: NEG
45808: PUSH
45809: LD_INT 0
45811: PUSH
45812: EMPTY
45813: LIST
45814: LIST
45815: PUSH
45816: LD_INT 3
45818: NEG
45819: PUSH
45820: LD_INT 1
45822: NEG
45823: PUSH
45824: EMPTY
45825: LIST
45826: LIST
45827: PUSH
45828: EMPTY
45829: LIST
45830: LIST
45831: LIST
45832: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
45833: LD_ADDR_VAR 0 16
45837: PUSH
45838: LD_INT 2
45840: NEG
45841: PUSH
45842: LD_INT 3
45844: NEG
45845: PUSH
45846: EMPTY
45847: LIST
45848: LIST
45849: PUSH
45850: LD_INT 3
45852: NEG
45853: PUSH
45854: LD_INT 2
45856: NEG
45857: PUSH
45858: EMPTY
45859: LIST
45860: LIST
45861: PUSH
45862: LD_INT 3
45864: NEG
45865: PUSH
45866: LD_INT 3
45868: NEG
45869: PUSH
45870: EMPTY
45871: LIST
45872: LIST
45873: PUSH
45874: EMPTY
45875: LIST
45876: LIST
45877: LIST
45878: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
45879: LD_ADDR_VAR 0 17
45883: PUSH
45884: LD_INT 1
45886: NEG
45887: PUSH
45888: LD_INT 3
45890: NEG
45891: PUSH
45892: EMPTY
45893: LIST
45894: LIST
45895: PUSH
45896: LD_INT 0
45898: PUSH
45899: LD_INT 3
45901: NEG
45902: PUSH
45903: EMPTY
45904: LIST
45905: LIST
45906: PUSH
45907: LD_INT 1
45909: PUSH
45910: LD_INT 2
45912: NEG
45913: PUSH
45914: EMPTY
45915: LIST
45916: LIST
45917: PUSH
45918: EMPTY
45919: LIST
45920: LIST
45921: LIST
45922: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
45923: LD_ADDR_VAR 0 18
45927: PUSH
45928: LD_INT 2
45930: PUSH
45931: LD_INT 1
45933: NEG
45934: PUSH
45935: EMPTY
45936: LIST
45937: LIST
45938: PUSH
45939: LD_INT 3
45941: PUSH
45942: LD_INT 0
45944: PUSH
45945: EMPTY
45946: LIST
45947: LIST
45948: PUSH
45949: LD_INT 3
45951: PUSH
45952: LD_INT 1
45954: PUSH
45955: EMPTY
45956: LIST
45957: LIST
45958: PUSH
45959: EMPTY
45960: LIST
45961: LIST
45962: LIST
45963: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
45964: LD_ADDR_VAR 0 19
45968: PUSH
45969: LD_INT 3
45971: PUSH
45972: LD_INT 2
45974: PUSH
45975: EMPTY
45976: LIST
45977: LIST
45978: PUSH
45979: LD_INT 3
45981: PUSH
45982: LD_INT 3
45984: PUSH
45985: EMPTY
45986: LIST
45987: LIST
45988: PUSH
45989: LD_INT 2
45991: PUSH
45992: LD_INT 3
45994: PUSH
45995: EMPTY
45996: LIST
45997: LIST
45998: PUSH
45999: EMPTY
46000: LIST
46001: LIST
46002: LIST
46003: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
46004: LD_ADDR_VAR 0 20
46008: PUSH
46009: LD_INT 1
46011: PUSH
46012: LD_INT 3
46014: PUSH
46015: EMPTY
46016: LIST
46017: LIST
46018: PUSH
46019: LD_INT 0
46021: PUSH
46022: LD_INT 3
46024: PUSH
46025: EMPTY
46026: LIST
46027: LIST
46028: PUSH
46029: LD_INT 1
46031: NEG
46032: PUSH
46033: LD_INT 2
46035: PUSH
46036: EMPTY
46037: LIST
46038: LIST
46039: PUSH
46040: EMPTY
46041: LIST
46042: LIST
46043: LIST
46044: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
46045: LD_ADDR_VAR 0 21
46049: PUSH
46050: LD_INT 2
46052: NEG
46053: PUSH
46054: LD_INT 1
46056: PUSH
46057: EMPTY
46058: LIST
46059: LIST
46060: PUSH
46061: LD_INT 3
46063: NEG
46064: PUSH
46065: LD_INT 0
46067: PUSH
46068: EMPTY
46069: LIST
46070: LIST
46071: PUSH
46072: LD_INT 3
46074: NEG
46075: PUSH
46076: LD_INT 1
46078: NEG
46079: PUSH
46080: EMPTY
46081: LIST
46082: LIST
46083: PUSH
46084: EMPTY
46085: LIST
46086: LIST
46087: LIST
46088: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
46089: LD_ADDR_VAR 0 22
46093: PUSH
46094: LD_INT 2
46096: NEG
46097: PUSH
46098: LD_INT 3
46100: NEG
46101: PUSH
46102: EMPTY
46103: LIST
46104: LIST
46105: PUSH
46106: LD_INT 3
46108: NEG
46109: PUSH
46110: LD_INT 2
46112: NEG
46113: PUSH
46114: EMPTY
46115: LIST
46116: LIST
46117: PUSH
46118: LD_INT 3
46120: NEG
46121: PUSH
46122: LD_INT 3
46124: NEG
46125: PUSH
46126: EMPTY
46127: LIST
46128: LIST
46129: PUSH
46130: EMPTY
46131: LIST
46132: LIST
46133: LIST
46134: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
46135: LD_ADDR_VAR 0 23
46139: PUSH
46140: LD_INT 0
46142: PUSH
46143: LD_INT 3
46145: NEG
46146: PUSH
46147: EMPTY
46148: LIST
46149: LIST
46150: PUSH
46151: LD_INT 1
46153: NEG
46154: PUSH
46155: LD_INT 4
46157: NEG
46158: PUSH
46159: EMPTY
46160: LIST
46161: LIST
46162: PUSH
46163: LD_INT 1
46165: PUSH
46166: LD_INT 3
46168: NEG
46169: PUSH
46170: EMPTY
46171: LIST
46172: LIST
46173: PUSH
46174: EMPTY
46175: LIST
46176: LIST
46177: LIST
46178: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
46179: LD_ADDR_VAR 0 24
46183: PUSH
46184: LD_INT 3
46186: PUSH
46187: LD_INT 0
46189: PUSH
46190: EMPTY
46191: LIST
46192: LIST
46193: PUSH
46194: LD_INT 3
46196: PUSH
46197: LD_INT 1
46199: NEG
46200: PUSH
46201: EMPTY
46202: LIST
46203: LIST
46204: PUSH
46205: LD_INT 4
46207: PUSH
46208: LD_INT 1
46210: PUSH
46211: EMPTY
46212: LIST
46213: LIST
46214: PUSH
46215: EMPTY
46216: LIST
46217: LIST
46218: LIST
46219: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
46220: LD_ADDR_VAR 0 25
46224: PUSH
46225: LD_INT 3
46227: PUSH
46228: LD_INT 3
46230: PUSH
46231: EMPTY
46232: LIST
46233: LIST
46234: PUSH
46235: LD_INT 4
46237: PUSH
46238: LD_INT 3
46240: PUSH
46241: EMPTY
46242: LIST
46243: LIST
46244: PUSH
46245: LD_INT 3
46247: PUSH
46248: LD_INT 4
46250: PUSH
46251: EMPTY
46252: LIST
46253: LIST
46254: PUSH
46255: EMPTY
46256: LIST
46257: LIST
46258: LIST
46259: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
46260: LD_ADDR_VAR 0 26
46264: PUSH
46265: LD_INT 0
46267: PUSH
46268: LD_INT 3
46270: PUSH
46271: EMPTY
46272: LIST
46273: LIST
46274: PUSH
46275: LD_INT 1
46277: PUSH
46278: LD_INT 4
46280: PUSH
46281: EMPTY
46282: LIST
46283: LIST
46284: PUSH
46285: LD_INT 1
46287: NEG
46288: PUSH
46289: LD_INT 3
46291: PUSH
46292: EMPTY
46293: LIST
46294: LIST
46295: PUSH
46296: EMPTY
46297: LIST
46298: LIST
46299: LIST
46300: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
46301: LD_ADDR_VAR 0 27
46305: PUSH
46306: LD_INT 3
46308: NEG
46309: PUSH
46310: LD_INT 0
46312: PUSH
46313: EMPTY
46314: LIST
46315: LIST
46316: PUSH
46317: LD_INT 3
46319: NEG
46320: PUSH
46321: LD_INT 1
46323: PUSH
46324: EMPTY
46325: LIST
46326: LIST
46327: PUSH
46328: LD_INT 4
46330: NEG
46331: PUSH
46332: LD_INT 1
46334: NEG
46335: PUSH
46336: EMPTY
46337: LIST
46338: LIST
46339: PUSH
46340: EMPTY
46341: LIST
46342: LIST
46343: LIST
46344: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
46345: LD_ADDR_VAR 0 28
46349: PUSH
46350: LD_INT 3
46352: NEG
46353: PUSH
46354: LD_INT 3
46356: NEG
46357: PUSH
46358: EMPTY
46359: LIST
46360: LIST
46361: PUSH
46362: LD_INT 3
46364: NEG
46365: PUSH
46366: LD_INT 4
46368: NEG
46369: PUSH
46370: EMPTY
46371: LIST
46372: LIST
46373: PUSH
46374: LD_INT 4
46376: NEG
46377: PUSH
46378: LD_INT 3
46380: NEG
46381: PUSH
46382: EMPTY
46383: LIST
46384: LIST
46385: PUSH
46386: EMPTY
46387: LIST
46388: LIST
46389: LIST
46390: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
46391: LD_ADDR_VAR 0 29
46395: PUSH
46396: LD_INT 1
46398: NEG
46399: PUSH
46400: LD_INT 3
46402: NEG
46403: PUSH
46404: EMPTY
46405: LIST
46406: LIST
46407: PUSH
46408: LD_INT 0
46410: PUSH
46411: LD_INT 3
46413: NEG
46414: PUSH
46415: EMPTY
46416: LIST
46417: LIST
46418: PUSH
46419: LD_INT 1
46421: PUSH
46422: LD_INT 2
46424: NEG
46425: PUSH
46426: EMPTY
46427: LIST
46428: LIST
46429: PUSH
46430: LD_INT 1
46432: NEG
46433: PUSH
46434: LD_INT 4
46436: NEG
46437: PUSH
46438: EMPTY
46439: LIST
46440: LIST
46441: PUSH
46442: LD_INT 0
46444: PUSH
46445: LD_INT 4
46447: NEG
46448: PUSH
46449: EMPTY
46450: LIST
46451: LIST
46452: PUSH
46453: LD_INT 1
46455: PUSH
46456: LD_INT 3
46458: NEG
46459: PUSH
46460: EMPTY
46461: LIST
46462: LIST
46463: PUSH
46464: LD_INT 1
46466: NEG
46467: PUSH
46468: LD_INT 5
46470: NEG
46471: PUSH
46472: EMPTY
46473: LIST
46474: LIST
46475: PUSH
46476: LD_INT 0
46478: PUSH
46479: LD_INT 5
46481: NEG
46482: PUSH
46483: EMPTY
46484: LIST
46485: LIST
46486: PUSH
46487: LD_INT 1
46489: PUSH
46490: LD_INT 4
46492: NEG
46493: PUSH
46494: EMPTY
46495: LIST
46496: LIST
46497: PUSH
46498: LD_INT 1
46500: NEG
46501: PUSH
46502: LD_INT 6
46504: NEG
46505: PUSH
46506: EMPTY
46507: LIST
46508: LIST
46509: PUSH
46510: LD_INT 0
46512: PUSH
46513: LD_INT 6
46515: NEG
46516: PUSH
46517: EMPTY
46518: LIST
46519: LIST
46520: PUSH
46521: LD_INT 1
46523: PUSH
46524: LD_INT 5
46526: NEG
46527: PUSH
46528: EMPTY
46529: LIST
46530: LIST
46531: PUSH
46532: EMPTY
46533: LIST
46534: LIST
46535: LIST
46536: LIST
46537: LIST
46538: LIST
46539: LIST
46540: LIST
46541: LIST
46542: LIST
46543: LIST
46544: LIST
46545: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
46546: LD_ADDR_VAR 0 30
46550: PUSH
46551: LD_INT 2
46553: PUSH
46554: LD_INT 1
46556: NEG
46557: PUSH
46558: EMPTY
46559: LIST
46560: LIST
46561: PUSH
46562: LD_INT 3
46564: PUSH
46565: LD_INT 0
46567: PUSH
46568: EMPTY
46569: LIST
46570: LIST
46571: PUSH
46572: LD_INT 3
46574: PUSH
46575: LD_INT 1
46577: PUSH
46578: EMPTY
46579: LIST
46580: LIST
46581: PUSH
46582: LD_INT 3
46584: PUSH
46585: LD_INT 1
46587: NEG
46588: PUSH
46589: EMPTY
46590: LIST
46591: LIST
46592: PUSH
46593: LD_INT 4
46595: PUSH
46596: LD_INT 0
46598: PUSH
46599: EMPTY
46600: LIST
46601: LIST
46602: PUSH
46603: LD_INT 4
46605: PUSH
46606: LD_INT 1
46608: PUSH
46609: EMPTY
46610: LIST
46611: LIST
46612: PUSH
46613: LD_INT 4
46615: PUSH
46616: LD_INT 1
46618: NEG
46619: PUSH
46620: EMPTY
46621: LIST
46622: LIST
46623: PUSH
46624: LD_INT 5
46626: PUSH
46627: LD_INT 0
46629: PUSH
46630: EMPTY
46631: LIST
46632: LIST
46633: PUSH
46634: LD_INT 5
46636: PUSH
46637: LD_INT 1
46639: PUSH
46640: EMPTY
46641: LIST
46642: LIST
46643: PUSH
46644: LD_INT 5
46646: PUSH
46647: LD_INT 1
46649: NEG
46650: PUSH
46651: EMPTY
46652: LIST
46653: LIST
46654: PUSH
46655: LD_INT 6
46657: PUSH
46658: LD_INT 0
46660: PUSH
46661: EMPTY
46662: LIST
46663: LIST
46664: PUSH
46665: LD_INT 6
46667: PUSH
46668: LD_INT 1
46670: PUSH
46671: EMPTY
46672: LIST
46673: LIST
46674: PUSH
46675: EMPTY
46676: LIST
46677: LIST
46678: LIST
46679: LIST
46680: LIST
46681: LIST
46682: LIST
46683: LIST
46684: LIST
46685: LIST
46686: LIST
46687: LIST
46688: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
46689: LD_ADDR_VAR 0 31
46693: PUSH
46694: LD_INT 3
46696: PUSH
46697: LD_INT 2
46699: PUSH
46700: EMPTY
46701: LIST
46702: LIST
46703: PUSH
46704: LD_INT 3
46706: PUSH
46707: LD_INT 3
46709: PUSH
46710: EMPTY
46711: LIST
46712: LIST
46713: PUSH
46714: LD_INT 2
46716: PUSH
46717: LD_INT 3
46719: PUSH
46720: EMPTY
46721: LIST
46722: LIST
46723: PUSH
46724: LD_INT 4
46726: PUSH
46727: LD_INT 3
46729: PUSH
46730: EMPTY
46731: LIST
46732: LIST
46733: PUSH
46734: LD_INT 4
46736: PUSH
46737: LD_INT 4
46739: PUSH
46740: EMPTY
46741: LIST
46742: LIST
46743: PUSH
46744: LD_INT 3
46746: PUSH
46747: LD_INT 4
46749: PUSH
46750: EMPTY
46751: LIST
46752: LIST
46753: PUSH
46754: LD_INT 5
46756: PUSH
46757: LD_INT 4
46759: PUSH
46760: EMPTY
46761: LIST
46762: LIST
46763: PUSH
46764: LD_INT 5
46766: PUSH
46767: LD_INT 5
46769: PUSH
46770: EMPTY
46771: LIST
46772: LIST
46773: PUSH
46774: LD_INT 4
46776: PUSH
46777: LD_INT 5
46779: PUSH
46780: EMPTY
46781: LIST
46782: LIST
46783: PUSH
46784: LD_INT 6
46786: PUSH
46787: LD_INT 5
46789: PUSH
46790: EMPTY
46791: LIST
46792: LIST
46793: PUSH
46794: LD_INT 6
46796: PUSH
46797: LD_INT 6
46799: PUSH
46800: EMPTY
46801: LIST
46802: LIST
46803: PUSH
46804: LD_INT 5
46806: PUSH
46807: LD_INT 6
46809: PUSH
46810: EMPTY
46811: LIST
46812: LIST
46813: PUSH
46814: EMPTY
46815: LIST
46816: LIST
46817: LIST
46818: LIST
46819: LIST
46820: LIST
46821: LIST
46822: LIST
46823: LIST
46824: LIST
46825: LIST
46826: LIST
46827: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
46828: LD_ADDR_VAR 0 32
46832: PUSH
46833: LD_INT 1
46835: PUSH
46836: LD_INT 3
46838: PUSH
46839: EMPTY
46840: LIST
46841: LIST
46842: PUSH
46843: LD_INT 0
46845: PUSH
46846: LD_INT 3
46848: PUSH
46849: EMPTY
46850: LIST
46851: LIST
46852: PUSH
46853: LD_INT 1
46855: NEG
46856: PUSH
46857: LD_INT 2
46859: PUSH
46860: EMPTY
46861: LIST
46862: LIST
46863: PUSH
46864: LD_INT 1
46866: PUSH
46867: LD_INT 4
46869: PUSH
46870: EMPTY
46871: LIST
46872: LIST
46873: PUSH
46874: LD_INT 0
46876: PUSH
46877: LD_INT 4
46879: PUSH
46880: EMPTY
46881: LIST
46882: LIST
46883: PUSH
46884: LD_INT 1
46886: NEG
46887: PUSH
46888: LD_INT 3
46890: PUSH
46891: EMPTY
46892: LIST
46893: LIST
46894: PUSH
46895: LD_INT 1
46897: PUSH
46898: LD_INT 5
46900: PUSH
46901: EMPTY
46902: LIST
46903: LIST
46904: PUSH
46905: LD_INT 0
46907: PUSH
46908: LD_INT 5
46910: PUSH
46911: EMPTY
46912: LIST
46913: LIST
46914: PUSH
46915: LD_INT 1
46917: NEG
46918: PUSH
46919: LD_INT 4
46921: PUSH
46922: EMPTY
46923: LIST
46924: LIST
46925: PUSH
46926: LD_INT 1
46928: PUSH
46929: LD_INT 6
46931: PUSH
46932: EMPTY
46933: LIST
46934: LIST
46935: PUSH
46936: LD_INT 0
46938: PUSH
46939: LD_INT 6
46941: PUSH
46942: EMPTY
46943: LIST
46944: LIST
46945: PUSH
46946: LD_INT 1
46948: NEG
46949: PUSH
46950: LD_INT 5
46952: PUSH
46953: EMPTY
46954: LIST
46955: LIST
46956: PUSH
46957: EMPTY
46958: LIST
46959: LIST
46960: LIST
46961: LIST
46962: LIST
46963: LIST
46964: LIST
46965: LIST
46966: LIST
46967: LIST
46968: LIST
46969: LIST
46970: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
46971: LD_ADDR_VAR 0 33
46975: PUSH
46976: LD_INT 2
46978: NEG
46979: PUSH
46980: LD_INT 1
46982: PUSH
46983: EMPTY
46984: LIST
46985: LIST
46986: PUSH
46987: LD_INT 3
46989: NEG
46990: PUSH
46991: LD_INT 0
46993: PUSH
46994: EMPTY
46995: LIST
46996: LIST
46997: PUSH
46998: LD_INT 3
47000: NEG
47001: PUSH
47002: LD_INT 1
47004: NEG
47005: PUSH
47006: EMPTY
47007: LIST
47008: LIST
47009: PUSH
47010: LD_INT 3
47012: NEG
47013: PUSH
47014: LD_INT 1
47016: PUSH
47017: EMPTY
47018: LIST
47019: LIST
47020: PUSH
47021: LD_INT 4
47023: NEG
47024: PUSH
47025: LD_INT 0
47027: PUSH
47028: EMPTY
47029: LIST
47030: LIST
47031: PUSH
47032: LD_INT 4
47034: NEG
47035: PUSH
47036: LD_INT 1
47038: NEG
47039: PUSH
47040: EMPTY
47041: LIST
47042: LIST
47043: PUSH
47044: LD_INT 4
47046: NEG
47047: PUSH
47048: LD_INT 1
47050: PUSH
47051: EMPTY
47052: LIST
47053: LIST
47054: PUSH
47055: LD_INT 5
47057: NEG
47058: PUSH
47059: LD_INT 0
47061: PUSH
47062: EMPTY
47063: LIST
47064: LIST
47065: PUSH
47066: LD_INT 5
47068: NEG
47069: PUSH
47070: LD_INT 1
47072: NEG
47073: PUSH
47074: EMPTY
47075: LIST
47076: LIST
47077: PUSH
47078: LD_INT 5
47080: NEG
47081: PUSH
47082: LD_INT 1
47084: PUSH
47085: EMPTY
47086: LIST
47087: LIST
47088: PUSH
47089: LD_INT 6
47091: NEG
47092: PUSH
47093: LD_INT 0
47095: PUSH
47096: EMPTY
47097: LIST
47098: LIST
47099: PUSH
47100: LD_INT 6
47102: NEG
47103: PUSH
47104: LD_INT 1
47106: NEG
47107: PUSH
47108: EMPTY
47109: LIST
47110: LIST
47111: PUSH
47112: EMPTY
47113: LIST
47114: LIST
47115: LIST
47116: LIST
47117: LIST
47118: LIST
47119: LIST
47120: LIST
47121: LIST
47122: LIST
47123: LIST
47124: LIST
47125: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
47126: LD_ADDR_VAR 0 34
47130: PUSH
47131: LD_INT 2
47133: NEG
47134: PUSH
47135: LD_INT 3
47137: NEG
47138: PUSH
47139: EMPTY
47140: LIST
47141: LIST
47142: PUSH
47143: LD_INT 3
47145: NEG
47146: PUSH
47147: LD_INT 2
47149: NEG
47150: PUSH
47151: EMPTY
47152: LIST
47153: LIST
47154: PUSH
47155: LD_INT 3
47157: NEG
47158: PUSH
47159: LD_INT 3
47161: NEG
47162: PUSH
47163: EMPTY
47164: LIST
47165: LIST
47166: PUSH
47167: LD_INT 3
47169: NEG
47170: PUSH
47171: LD_INT 4
47173: NEG
47174: PUSH
47175: EMPTY
47176: LIST
47177: LIST
47178: PUSH
47179: LD_INT 4
47181: NEG
47182: PUSH
47183: LD_INT 3
47185: NEG
47186: PUSH
47187: EMPTY
47188: LIST
47189: LIST
47190: PUSH
47191: LD_INT 4
47193: NEG
47194: PUSH
47195: LD_INT 4
47197: NEG
47198: PUSH
47199: EMPTY
47200: LIST
47201: LIST
47202: PUSH
47203: LD_INT 4
47205: NEG
47206: PUSH
47207: LD_INT 5
47209: NEG
47210: PUSH
47211: EMPTY
47212: LIST
47213: LIST
47214: PUSH
47215: LD_INT 5
47217: NEG
47218: PUSH
47219: LD_INT 4
47221: NEG
47222: PUSH
47223: EMPTY
47224: LIST
47225: LIST
47226: PUSH
47227: LD_INT 5
47229: NEG
47230: PUSH
47231: LD_INT 5
47233: NEG
47234: PUSH
47235: EMPTY
47236: LIST
47237: LIST
47238: PUSH
47239: LD_INT 5
47241: NEG
47242: PUSH
47243: LD_INT 6
47245: NEG
47246: PUSH
47247: EMPTY
47248: LIST
47249: LIST
47250: PUSH
47251: LD_INT 6
47253: NEG
47254: PUSH
47255: LD_INT 5
47257: NEG
47258: PUSH
47259: EMPTY
47260: LIST
47261: LIST
47262: PUSH
47263: LD_INT 6
47265: NEG
47266: PUSH
47267: LD_INT 6
47269: NEG
47270: PUSH
47271: EMPTY
47272: LIST
47273: LIST
47274: PUSH
47275: EMPTY
47276: LIST
47277: LIST
47278: LIST
47279: LIST
47280: LIST
47281: LIST
47282: LIST
47283: LIST
47284: LIST
47285: LIST
47286: LIST
47287: LIST
47288: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
47289: LD_ADDR_VAR 0 41
47293: PUSH
47294: LD_INT 0
47296: PUSH
47297: LD_INT 2
47299: NEG
47300: PUSH
47301: EMPTY
47302: LIST
47303: LIST
47304: PUSH
47305: LD_INT 1
47307: NEG
47308: PUSH
47309: LD_INT 3
47311: NEG
47312: PUSH
47313: EMPTY
47314: LIST
47315: LIST
47316: PUSH
47317: LD_INT 1
47319: PUSH
47320: LD_INT 2
47322: NEG
47323: PUSH
47324: EMPTY
47325: LIST
47326: LIST
47327: PUSH
47328: EMPTY
47329: LIST
47330: LIST
47331: LIST
47332: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
47333: LD_ADDR_VAR 0 42
47337: PUSH
47338: LD_INT 2
47340: PUSH
47341: LD_INT 0
47343: PUSH
47344: EMPTY
47345: LIST
47346: LIST
47347: PUSH
47348: LD_INT 2
47350: PUSH
47351: LD_INT 1
47353: NEG
47354: PUSH
47355: EMPTY
47356: LIST
47357: LIST
47358: PUSH
47359: LD_INT 3
47361: PUSH
47362: LD_INT 1
47364: PUSH
47365: EMPTY
47366: LIST
47367: LIST
47368: PUSH
47369: EMPTY
47370: LIST
47371: LIST
47372: LIST
47373: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
47374: LD_ADDR_VAR 0 43
47378: PUSH
47379: LD_INT 2
47381: PUSH
47382: LD_INT 2
47384: PUSH
47385: EMPTY
47386: LIST
47387: LIST
47388: PUSH
47389: LD_INT 3
47391: PUSH
47392: LD_INT 2
47394: PUSH
47395: EMPTY
47396: LIST
47397: LIST
47398: PUSH
47399: LD_INT 2
47401: PUSH
47402: LD_INT 3
47404: PUSH
47405: EMPTY
47406: LIST
47407: LIST
47408: PUSH
47409: EMPTY
47410: LIST
47411: LIST
47412: LIST
47413: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
47414: LD_ADDR_VAR 0 44
47418: PUSH
47419: LD_INT 0
47421: PUSH
47422: LD_INT 2
47424: PUSH
47425: EMPTY
47426: LIST
47427: LIST
47428: PUSH
47429: LD_INT 1
47431: PUSH
47432: LD_INT 3
47434: PUSH
47435: EMPTY
47436: LIST
47437: LIST
47438: PUSH
47439: LD_INT 1
47441: NEG
47442: PUSH
47443: LD_INT 2
47445: PUSH
47446: EMPTY
47447: LIST
47448: LIST
47449: PUSH
47450: EMPTY
47451: LIST
47452: LIST
47453: LIST
47454: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
47455: LD_ADDR_VAR 0 45
47459: PUSH
47460: LD_INT 2
47462: NEG
47463: PUSH
47464: LD_INT 0
47466: PUSH
47467: EMPTY
47468: LIST
47469: LIST
47470: PUSH
47471: LD_INT 2
47473: NEG
47474: PUSH
47475: LD_INT 1
47477: PUSH
47478: EMPTY
47479: LIST
47480: LIST
47481: PUSH
47482: LD_INT 3
47484: NEG
47485: PUSH
47486: LD_INT 1
47488: NEG
47489: PUSH
47490: EMPTY
47491: LIST
47492: LIST
47493: PUSH
47494: EMPTY
47495: LIST
47496: LIST
47497: LIST
47498: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
47499: LD_ADDR_VAR 0 46
47503: PUSH
47504: LD_INT 2
47506: NEG
47507: PUSH
47508: LD_INT 2
47510: NEG
47511: PUSH
47512: EMPTY
47513: LIST
47514: LIST
47515: PUSH
47516: LD_INT 2
47518: NEG
47519: PUSH
47520: LD_INT 3
47522: NEG
47523: PUSH
47524: EMPTY
47525: LIST
47526: LIST
47527: PUSH
47528: LD_INT 3
47530: NEG
47531: PUSH
47532: LD_INT 2
47534: NEG
47535: PUSH
47536: EMPTY
47537: LIST
47538: LIST
47539: PUSH
47540: EMPTY
47541: LIST
47542: LIST
47543: LIST
47544: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
47545: LD_ADDR_VAR 0 47
47549: PUSH
47550: LD_INT 2
47552: NEG
47553: PUSH
47554: LD_INT 3
47556: NEG
47557: PUSH
47558: EMPTY
47559: LIST
47560: LIST
47561: PUSH
47562: LD_INT 1
47564: NEG
47565: PUSH
47566: LD_INT 3
47568: NEG
47569: PUSH
47570: EMPTY
47571: LIST
47572: LIST
47573: PUSH
47574: EMPTY
47575: LIST
47576: LIST
47577: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
47578: LD_ADDR_VAR 0 48
47582: PUSH
47583: LD_INT 1
47585: PUSH
47586: LD_INT 2
47588: NEG
47589: PUSH
47590: EMPTY
47591: LIST
47592: LIST
47593: PUSH
47594: LD_INT 2
47596: PUSH
47597: LD_INT 1
47599: NEG
47600: PUSH
47601: EMPTY
47602: LIST
47603: LIST
47604: PUSH
47605: EMPTY
47606: LIST
47607: LIST
47608: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
47609: LD_ADDR_VAR 0 49
47613: PUSH
47614: LD_INT 3
47616: PUSH
47617: LD_INT 1
47619: PUSH
47620: EMPTY
47621: LIST
47622: LIST
47623: PUSH
47624: LD_INT 3
47626: PUSH
47627: LD_INT 2
47629: PUSH
47630: EMPTY
47631: LIST
47632: LIST
47633: PUSH
47634: EMPTY
47635: LIST
47636: LIST
47637: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
47638: LD_ADDR_VAR 0 50
47642: PUSH
47643: LD_INT 2
47645: PUSH
47646: LD_INT 3
47648: PUSH
47649: EMPTY
47650: LIST
47651: LIST
47652: PUSH
47653: LD_INT 1
47655: PUSH
47656: LD_INT 3
47658: PUSH
47659: EMPTY
47660: LIST
47661: LIST
47662: PUSH
47663: EMPTY
47664: LIST
47665: LIST
47666: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
47667: LD_ADDR_VAR 0 51
47671: PUSH
47672: LD_INT 1
47674: NEG
47675: PUSH
47676: LD_INT 2
47678: PUSH
47679: EMPTY
47680: LIST
47681: LIST
47682: PUSH
47683: LD_INT 2
47685: NEG
47686: PUSH
47687: LD_INT 1
47689: PUSH
47690: EMPTY
47691: LIST
47692: LIST
47693: PUSH
47694: EMPTY
47695: LIST
47696: LIST
47697: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
47698: LD_ADDR_VAR 0 52
47702: PUSH
47703: LD_INT 3
47705: NEG
47706: PUSH
47707: LD_INT 1
47709: NEG
47710: PUSH
47711: EMPTY
47712: LIST
47713: LIST
47714: PUSH
47715: LD_INT 3
47717: NEG
47718: PUSH
47719: LD_INT 2
47721: NEG
47722: PUSH
47723: EMPTY
47724: LIST
47725: LIST
47726: PUSH
47727: EMPTY
47728: LIST
47729: LIST
47730: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
47731: LD_ADDR_VAR 0 53
47735: PUSH
47736: LD_INT 1
47738: NEG
47739: PUSH
47740: LD_INT 3
47742: NEG
47743: PUSH
47744: EMPTY
47745: LIST
47746: LIST
47747: PUSH
47748: LD_INT 0
47750: PUSH
47751: LD_INT 3
47753: NEG
47754: PUSH
47755: EMPTY
47756: LIST
47757: LIST
47758: PUSH
47759: LD_INT 1
47761: PUSH
47762: LD_INT 2
47764: NEG
47765: PUSH
47766: EMPTY
47767: LIST
47768: LIST
47769: PUSH
47770: EMPTY
47771: LIST
47772: LIST
47773: LIST
47774: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
47775: LD_ADDR_VAR 0 54
47779: PUSH
47780: LD_INT 2
47782: PUSH
47783: LD_INT 1
47785: NEG
47786: PUSH
47787: EMPTY
47788: LIST
47789: LIST
47790: PUSH
47791: LD_INT 3
47793: PUSH
47794: LD_INT 0
47796: PUSH
47797: EMPTY
47798: LIST
47799: LIST
47800: PUSH
47801: LD_INT 3
47803: PUSH
47804: LD_INT 1
47806: PUSH
47807: EMPTY
47808: LIST
47809: LIST
47810: PUSH
47811: EMPTY
47812: LIST
47813: LIST
47814: LIST
47815: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
47816: LD_ADDR_VAR 0 55
47820: PUSH
47821: LD_INT 3
47823: PUSH
47824: LD_INT 2
47826: PUSH
47827: EMPTY
47828: LIST
47829: LIST
47830: PUSH
47831: LD_INT 3
47833: PUSH
47834: LD_INT 3
47836: PUSH
47837: EMPTY
47838: LIST
47839: LIST
47840: PUSH
47841: LD_INT 2
47843: PUSH
47844: LD_INT 3
47846: PUSH
47847: EMPTY
47848: LIST
47849: LIST
47850: PUSH
47851: EMPTY
47852: LIST
47853: LIST
47854: LIST
47855: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
47856: LD_ADDR_VAR 0 56
47860: PUSH
47861: LD_INT 1
47863: PUSH
47864: LD_INT 3
47866: PUSH
47867: EMPTY
47868: LIST
47869: LIST
47870: PUSH
47871: LD_INT 0
47873: PUSH
47874: LD_INT 3
47876: PUSH
47877: EMPTY
47878: LIST
47879: LIST
47880: PUSH
47881: LD_INT 1
47883: NEG
47884: PUSH
47885: LD_INT 2
47887: PUSH
47888: EMPTY
47889: LIST
47890: LIST
47891: PUSH
47892: EMPTY
47893: LIST
47894: LIST
47895: LIST
47896: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
47897: LD_ADDR_VAR 0 57
47901: PUSH
47902: LD_INT 2
47904: NEG
47905: PUSH
47906: LD_INT 1
47908: PUSH
47909: EMPTY
47910: LIST
47911: LIST
47912: PUSH
47913: LD_INT 3
47915: NEG
47916: PUSH
47917: LD_INT 0
47919: PUSH
47920: EMPTY
47921: LIST
47922: LIST
47923: PUSH
47924: LD_INT 3
47926: NEG
47927: PUSH
47928: LD_INT 1
47930: NEG
47931: PUSH
47932: EMPTY
47933: LIST
47934: LIST
47935: PUSH
47936: EMPTY
47937: LIST
47938: LIST
47939: LIST
47940: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
47941: LD_ADDR_VAR 0 58
47945: PUSH
47946: LD_INT 2
47948: NEG
47949: PUSH
47950: LD_INT 3
47952: NEG
47953: PUSH
47954: EMPTY
47955: LIST
47956: LIST
47957: PUSH
47958: LD_INT 3
47960: NEG
47961: PUSH
47962: LD_INT 2
47964: NEG
47965: PUSH
47966: EMPTY
47967: LIST
47968: LIST
47969: PUSH
47970: LD_INT 3
47972: NEG
47973: PUSH
47974: LD_INT 3
47976: NEG
47977: PUSH
47978: EMPTY
47979: LIST
47980: LIST
47981: PUSH
47982: EMPTY
47983: LIST
47984: LIST
47985: LIST
47986: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
47987: LD_ADDR_VAR 0 59
47991: PUSH
47992: LD_INT 1
47994: NEG
47995: PUSH
47996: LD_INT 2
47998: NEG
47999: PUSH
48000: EMPTY
48001: LIST
48002: LIST
48003: PUSH
48004: LD_INT 0
48006: PUSH
48007: LD_INT 2
48009: NEG
48010: PUSH
48011: EMPTY
48012: LIST
48013: LIST
48014: PUSH
48015: LD_INT 1
48017: PUSH
48018: LD_INT 1
48020: NEG
48021: PUSH
48022: EMPTY
48023: LIST
48024: LIST
48025: PUSH
48026: EMPTY
48027: LIST
48028: LIST
48029: LIST
48030: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
48031: LD_ADDR_VAR 0 60
48035: PUSH
48036: LD_INT 1
48038: PUSH
48039: LD_INT 1
48041: NEG
48042: PUSH
48043: EMPTY
48044: LIST
48045: LIST
48046: PUSH
48047: LD_INT 2
48049: PUSH
48050: LD_INT 0
48052: PUSH
48053: EMPTY
48054: LIST
48055: LIST
48056: PUSH
48057: LD_INT 2
48059: PUSH
48060: LD_INT 1
48062: PUSH
48063: EMPTY
48064: LIST
48065: LIST
48066: PUSH
48067: EMPTY
48068: LIST
48069: LIST
48070: LIST
48071: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
48072: LD_ADDR_VAR 0 61
48076: PUSH
48077: LD_INT 2
48079: PUSH
48080: LD_INT 1
48082: PUSH
48083: EMPTY
48084: LIST
48085: LIST
48086: PUSH
48087: LD_INT 2
48089: PUSH
48090: LD_INT 2
48092: PUSH
48093: EMPTY
48094: LIST
48095: LIST
48096: PUSH
48097: LD_INT 1
48099: PUSH
48100: LD_INT 2
48102: PUSH
48103: EMPTY
48104: LIST
48105: LIST
48106: PUSH
48107: EMPTY
48108: LIST
48109: LIST
48110: LIST
48111: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
48112: LD_ADDR_VAR 0 62
48116: PUSH
48117: LD_INT 1
48119: PUSH
48120: LD_INT 2
48122: PUSH
48123: EMPTY
48124: LIST
48125: LIST
48126: PUSH
48127: LD_INT 0
48129: PUSH
48130: LD_INT 2
48132: PUSH
48133: EMPTY
48134: LIST
48135: LIST
48136: PUSH
48137: LD_INT 1
48139: NEG
48140: PUSH
48141: LD_INT 1
48143: PUSH
48144: EMPTY
48145: LIST
48146: LIST
48147: PUSH
48148: EMPTY
48149: LIST
48150: LIST
48151: LIST
48152: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
48153: LD_ADDR_VAR 0 63
48157: PUSH
48158: LD_INT 1
48160: NEG
48161: PUSH
48162: LD_INT 1
48164: PUSH
48165: EMPTY
48166: LIST
48167: LIST
48168: PUSH
48169: LD_INT 2
48171: NEG
48172: PUSH
48173: LD_INT 0
48175: PUSH
48176: EMPTY
48177: LIST
48178: LIST
48179: PUSH
48180: LD_INT 2
48182: NEG
48183: PUSH
48184: LD_INT 1
48186: NEG
48187: PUSH
48188: EMPTY
48189: LIST
48190: LIST
48191: PUSH
48192: EMPTY
48193: LIST
48194: LIST
48195: LIST
48196: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
48197: LD_ADDR_VAR 0 64
48201: PUSH
48202: LD_INT 1
48204: NEG
48205: PUSH
48206: LD_INT 2
48208: NEG
48209: PUSH
48210: EMPTY
48211: LIST
48212: LIST
48213: PUSH
48214: LD_INT 2
48216: NEG
48217: PUSH
48218: LD_INT 1
48220: NEG
48221: PUSH
48222: EMPTY
48223: LIST
48224: LIST
48225: PUSH
48226: LD_INT 2
48228: NEG
48229: PUSH
48230: LD_INT 2
48232: NEG
48233: PUSH
48234: EMPTY
48235: LIST
48236: LIST
48237: PUSH
48238: EMPTY
48239: LIST
48240: LIST
48241: LIST
48242: ST_TO_ADDR
// end ; 2 :
48243: GO 51509
48245: LD_INT 2
48247: DOUBLE
48248: EQUAL
48249: IFTRUE 48253
48251: GO 51508
48253: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
48254: LD_ADDR_VAR 0 29
48258: PUSH
48259: LD_INT 4
48261: PUSH
48262: LD_INT 0
48264: PUSH
48265: EMPTY
48266: LIST
48267: LIST
48268: PUSH
48269: LD_INT 4
48271: PUSH
48272: LD_INT 1
48274: NEG
48275: PUSH
48276: EMPTY
48277: LIST
48278: LIST
48279: PUSH
48280: LD_INT 5
48282: PUSH
48283: LD_INT 0
48285: PUSH
48286: EMPTY
48287: LIST
48288: LIST
48289: PUSH
48290: LD_INT 5
48292: PUSH
48293: LD_INT 1
48295: PUSH
48296: EMPTY
48297: LIST
48298: LIST
48299: PUSH
48300: LD_INT 4
48302: PUSH
48303: LD_INT 1
48305: PUSH
48306: EMPTY
48307: LIST
48308: LIST
48309: PUSH
48310: LD_INT 3
48312: PUSH
48313: LD_INT 0
48315: PUSH
48316: EMPTY
48317: LIST
48318: LIST
48319: PUSH
48320: LD_INT 3
48322: PUSH
48323: LD_INT 1
48325: NEG
48326: PUSH
48327: EMPTY
48328: LIST
48329: LIST
48330: PUSH
48331: LD_INT 3
48333: PUSH
48334: LD_INT 2
48336: NEG
48337: PUSH
48338: EMPTY
48339: LIST
48340: LIST
48341: PUSH
48342: LD_INT 5
48344: PUSH
48345: LD_INT 2
48347: PUSH
48348: EMPTY
48349: LIST
48350: LIST
48351: PUSH
48352: LD_INT 3
48354: PUSH
48355: LD_INT 3
48357: PUSH
48358: EMPTY
48359: LIST
48360: LIST
48361: PUSH
48362: LD_INT 3
48364: PUSH
48365: LD_INT 2
48367: PUSH
48368: EMPTY
48369: LIST
48370: LIST
48371: PUSH
48372: LD_INT 4
48374: PUSH
48375: LD_INT 3
48377: PUSH
48378: EMPTY
48379: LIST
48380: LIST
48381: PUSH
48382: LD_INT 4
48384: PUSH
48385: LD_INT 4
48387: PUSH
48388: EMPTY
48389: LIST
48390: LIST
48391: PUSH
48392: LD_INT 3
48394: PUSH
48395: LD_INT 4
48397: PUSH
48398: EMPTY
48399: LIST
48400: LIST
48401: PUSH
48402: LD_INT 2
48404: PUSH
48405: LD_INT 3
48407: PUSH
48408: EMPTY
48409: LIST
48410: LIST
48411: PUSH
48412: LD_INT 2
48414: PUSH
48415: LD_INT 2
48417: PUSH
48418: EMPTY
48419: LIST
48420: LIST
48421: PUSH
48422: LD_INT 4
48424: PUSH
48425: LD_INT 2
48427: PUSH
48428: EMPTY
48429: LIST
48430: LIST
48431: PUSH
48432: LD_INT 2
48434: PUSH
48435: LD_INT 4
48437: PUSH
48438: EMPTY
48439: LIST
48440: LIST
48441: PUSH
48442: LD_INT 0
48444: PUSH
48445: LD_INT 4
48447: PUSH
48448: EMPTY
48449: LIST
48450: LIST
48451: PUSH
48452: LD_INT 0
48454: PUSH
48455: LD_INT 3
48457: PUSH
48458: EMPTY
48459: LIST
48460: LIST
48461: PUSH
48462: LD_INT 1
48464: PUSH
48465: LD_INT 4
48467: PUSH
48468: EMPTY
48469: LIST
48470: LIST
48471: PUSH
48472: LD_INT 1
48474: PUSH
48475: LD_INT 5
48477: PUSH
48478: EMPTY
48479: LIST
48480: LIST
48481: PUSH
48482: LD_INT 0
48484: PUSH
48485: LD_INT 5
48487: PUSH
48488: EMPTY
48489: LIST
48490: LIST
48491: PUSH
48492: LD_INT 1
48494: NEG
48495: PUSH
48496: LD_INT 4
48498: PUSH
48499: EMPTY
48500: LIST
48501: LIST
48502: PUSH
48503: LD_INT 1
48505: NEG
48506: PUSH
48507: LD_INT 3
48509: PUSH
48510: EMPTY
48511: LIST
48512: LIST
48513: PUSH
48514: LD_INT 2
48516: PUSH
48517: LD_INT 5
48519: PUSH
48520: EMPTY
48521: LIST
48522: LIST
48523: PUSH
48524: LD_INT 2
48526: NEG
48527: PUSH
48528: LD_INT 3
48530: PUSH
48531: EMPTY
48532: LIST
48533: LIST
48534: PUSH
48535: LD_INT 3
48537: NEG
48538: PUSH
48539: LD_INT 0
48541: PUSH
48542: EMPTY
48543: LIST
48544: LIST
48545: PUSH
48546: LD_INT 3
48548: NEG
48549: PUSH
48550: LD_INT 1
48552: NEG
48553: PUSH
48554: EMPTY
48555: LIST
48556: LIST
48557: PUSH
48558: LD_INT 2
48560: NEG
48561: PUSH
48562: LD_INT 0
48564: PUSH
48565: EMPTY
48566: LIST
48567: LIST
48568: PUSH
48569: LD_INT 2
48571: NEG
48572: PUSH
48573: LD_INT 1
48575: PUSH
48576: EMPTY
48577: LIST
48578: LIST
48579: PUSH
48580: LD_INT 3
48582: NEG
48583: PUSH
48584: LD_INT 1
48586: PUSH
48587: EMPTY
48588: LIST
48589: LIST
48590: PUSH
48591: LD_INT 4
48593: NEG
48594: PUSH
48595: LD_INT 0
48597: PUSH
48598: EMPTY
48599: LIST
48600: LIST
48601: PUSH
48602: LD_INT 4
48604: NEG
48605: PUSH
48606: LD_INT 1
48608: NEG
48609: PUSH
48610: EMPTY
48611: LIST
48612: LIST
48613: PUSH
48614: LD_INT 4
48616: NEG
48617: PUSH
48618: LD_INT 2
48620: NEG
48621: PUSH
48622: EMPTY
48623: LIST
48624: LIST
48625: PUSH
48626: LD_INT 2
48628: NEG
48629: PUSH
48630: LD_INT 2
48632: PUSH
48633: EMPTY
48634: LIST
48635: LIST
48636: PUSH
48637: LD_INT 4
48639: NEG
48640: PUSH
48641: LD_INT 4
48643: NEG
48644: PUSH
48645: EMPTY
48646: LIST
48647: LIST
48648: PUSH
48649: LD_INT 4
48651: NEG
48652: PUSH
48653: LD_INT 5
48655: NEG
48656: PUSH
48657: EMPTY
48658: LIST
48659: LIST
48660: PUSH
48661: LD_INT 3
48663: NEG
48664: PUSH
48665: LD_INT 4
48667: NEG
48668: PUSH
48669: EMPTY
48670: LIST
48671: LIST
48672: PUSH
48673: LD_INT 3
48675: NEG
48676: PUSH
48677: LD_INT 3
48679: NEG
48680: PUSH
48681: EMPTY
48682: LIST
48683: LIST
48684: PUSH
48685: LD_INT 4
48687: NEG
48688: PUSH
48689: LD_INT 3
48691: NEG
48692: PUSH
48693: EMPTY
48694: LIST
48695: LIST
48696: PUSH
48697: LD_INT 5
48699: NEG
48700: PUSH
48701: LD_INT 4
48703: NEG
48704: PUSH
48705: EMPTY
48706: LIST
48707: LIST
48708: PUSH
48709: LD_INT 5
48711: NEG
48712: PUSH
48713: LD_INT 5
48715: NEG
48716: PUSH
48717: EMPTY
48718: LIST
48719: LIST
48720: PUSH
48721: LD_INT 3
48723: NEG
48724: PUSH
48725: LD_INT 5
48727: NEG
48728: PUSH
48729: EMPTY
48730: LIST
48731: LIST
48732: PUSH
48733: LD_INT 5
48735: NEG
48736: PUSH
48737: LD_INT 3
48739: NEG
48740: PUSH
48741: EMPTY
48742: LIST
48743: LIST
48744: PUSH
48745: EMPTY
48746: LIST
48747: LIST
48748: LIST
48749: LIST
48750: LIST
48751: LIST
48752: LIST
48753: LIST
48754: LIST
48755: LIST
48756: LIST
48757: LIST
48758: LIST
48759: LIST
48760: LIST
48761: LIST
48762: LIST
48763: LIST
48764: LIST
48765: LIST
48766: LIST
48767: LIST
48768: LIST
48769: LIST
48770: LIST
48771: LIST
48772: LIST
48773: LIST
48774: LIST
48775: LIST
48776: LIST
48777: LIST
48778: LIST
48779: LIST
48780: LIST
48781: LIST
48782: LIST
48783: LIST
48784: LIST
48785: LIST
48786: LIST
48787: LIST
48788: LIST
48789: LIST
48790: LIST
48791: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
48792: LD_ADDR_VAR 0 30
48796: PUSH
48797: LD_INT 4
48799: PUSH
48800: LD_INT 4
48802: PUSH
48803: EMPTY
48804: LIST
48805: LIST
48806: PUSH
48807: LD_INT 4
48809: PUSH
48810: LD_INT 3
48812: PUSH
48813: EMPTY
48814: LIST
48815: LIST
48816: PUSH
48817: LD_INT 5
48819: PUSH
48820: LD_INT 4
48822: PUSH
48823: EMPTY
48824: LIST
48825: LIST
48826: PUSH
48827: LD_INT 5
48829: PUSH
48830: LD_INT 5
48832: PUSH
48833: EMPTY
48834: LIST
48835: LIST
48836: PUSH
48837: LD_INT 4
48839: PUSH
48840: LD_INT 5
48842: PUSH
48843: EMPTY
48844: LIST
48845: LIST
48846: PUSH
48847: LD_INT 3
48849: PUSH
48850: LD_INT 4
48852: PUSH
48853: EMPTY
48854: LIST
48855: LIST
48856: PUSH
48857: LD_INT 3
48859: PUSH
48860: LD_INT 3
48862: PUSH
48863: EMPTY
48864: LIST
48865: LIST
48866: PUSH
48867: LD_INT 5
48869: PUSH
48870: LD_INT 3
48872: PUSH
48873: EMPTY
48874: LIST
48875: LIST
48876: PUSH
48877: LD_INT 3
48879: PUSH
48880: LD_INT 5
48882: PUSH
48883: EMPTY
48884: LIST
48885: LIST
48886: PUSH
48887: LD_INT 0
48889: PUSH
48890: LD_INT 3
48892: PUSH
48893: EMPTY
48894: LIST
48895: LIST
48896: PUSH
48897: LD_INT 0
48899: PUSH
48900: LD_INT 2
48902: PUSH
48903: EMPTY
48904: LIST
48905: LIST
48906: PUSH
48907: LD_INT 1
48909: PUSH
48910: LD_INT 3
48912: PUSH
48913: EMPTY
48914: LIST
48915: LIST
48916: PUSH
48917: LD_INT 1
48919: PUSH
48920: LD_INT 4
48922: PUSH
48923: EMPTY
48924: LIST
48925: LIST
48926: PUSH
48927: LD_INT 0
48929: PUSH
48930: LD_INT 4
48932: PUSH
48933: EMPTY
48934: LIST
48935: LIST
48936: PUSH
48937: LD_INT 1
48939: NEG
48940: PUSH
48941: LD_INT 3
48943: PUSH
48944: EMPTY
48945: LIST
48946: LIST
48947: PUSH
48948: LD_INT 1
48950: NEG
48951: PUSH
48952: LD_INT 2
48954: PUSH
48955: EMPTY
48956: LIST
48957: LIST
48958: PUSH
48959: LD_INT 2
48961: PUSH
48962: LD_INT 4
48964: PUSH
48965: EMPTY
48966: LIST
48967: LIST
48968: PUSH
48969: LD_INT 2
48971: NEG
48972: PUSH
48973: LD_INT 2
48975: PUSH
48976: EMPTY
48977: LIST
48978: LIST
48979: PUSH
48980: LD_INT 4
48982: NEG
48983: PUSH
48984: LD_INT 0
48986: PUSH
48987: EMPTY
48988: LIST
48989: LIST
48990: PUSH
48991: LD_INT 4
48993: NEG
48994: PUSH
48995: LD_INT 1
48997: NEG
48998: PUSH
48999: EMPTY
49000: LIST
49001: LIST
49002: PUSH
49003: LD_INT 3
49005: NEG
49006: PUSH
49007: LD_INT 0
49009: PUSH
49010: EMPTY
49011: LIST
49012: LIST
49013: PUSH
49014: LD_INT 3
49016: NEG
49017: PUSH
49018: LD_INT 1
49020: PUSH
49021: EMPTY
49022: LIST
49023: LIST
49024: PUSH
49025: LD_INT 4
49027: NEG
49028: PUSH
49029: LD_INT 1
49031: PUSH
49032: EMPTY
49033: LIST
49034: LIST
49035: PUSH
49036: LD_INT 5
49038: NEG
49039: PUSH
49040: LD_INT 0
49042: PUSH
49043: EMPTY
49044: LIST
49045: LIST
49046: PUSH
49047: LD_INT 5
49049: NEG
49050: PUSH
49051: LD_INT 1
49053: NEG
49054: PUSH
49055: EMPTY
49056: LIST
49057: LIST
49058: PUSH
49059: LD_INT 5
49061: NEG
49062: PUSH
49063: LD_INT 2
49065: NEG
49066: PUSH
49067: EMPTY
49068: LIST
49069: LIST
49070: PUSH
49071: LD_INT 3
49073: NEG
49074: PUSH
49075: LD_INT 2
49077: PUSH
49078: EMPTY
49079: LIST
49080: LIST
49081: PUSH
49082: LD_INT 3
49084: NEG
49085: PUSH
49086: LD_INT 3
49088: NEG
49089: PUSH
49090: EMPTY
49091: LIST
49092: LIST
49093: PUSH
49094: LD_INT 3
49096: NEG
49097: PUSH
49098: LD_INT 4
49100: NEG
49101: PUSH
49102: EMPTY
49103: LIST
49104: LIST
49105: PUSH
49106: LD_INT 2
49108: NEG
49109: PUSH
49110: LD_INT 3
49112: NEG
49113: PUSH
49114: EMPTY
49115: LIST
49116: LIST
49117: PUSH
49118: LD_INT 2
49120: NEG
49121: PUSH
49122: LD_INT 2
49124: NEG
49125: PUSH
49126: EMPTY
49127: LIST
49128: LIST
49129: PUSH
49130: LD_INT 3
49132: NEG
49133: PUSH
49134: LD_INT 2
49136: NEG
49137: PUSH
49138: EMPTY
49139: LIST
49140: LIST
49141: PUSH
49142: LD_INT 4
49144: NEG
49145: PUSH
49146: LD_INT 3
49148: NEG
49149: PUSH
49150: EMPTY
49151: LIST
49152: LIST
49153: PUSH
49154: LD_INT 4
49156: NEG
49157: PUSH
49158: LD_INT 4
49160: NEG
49161: PUSH
49162: EMPTY
49163: LIST
49164: LIST
49165: PUSH
49166: LD_INT 2
49168: NEG
49169: PUSH
49170: LD_INT 4
49172: NEG
49173: PUSH
49174: EMPTY
49175: LIST
49176: LIST
49177: PUSH
49178: LD_INT 4
49180: NEG
49181: PUSH
49182: LD_INT 2
49184: NEG
49185: PUSH
49186: EMPTY
49187: LIST
49188: LIST
49189: PUSH
49190: LD_INT 0
49192: PUSH
49193: LD_INT 4
49195: NEG
49196: PUSH
49197: EMPTY
49198: LIST
49199: LIST
49200: PUSH
49201: LD_INT 0
49203: PUSH
49204: LD_INT 5
49206: NEG
49207: PUSH
49208: EMPTY
49209: LIST
49210: LIST
49211: PUSH
49212: LD_INT 1
49214: PUSH
49215: LD_INT 4
49217: NEG
49218: PUSH
49219: EMPTY
49220: LIST
49221: LIST
49222: PUSH
49223: LD_INT 1
49225: PUSH
49226: LD_INT 3
49228: NEG
49229: PUSH
49230: EMPTY
49231: LIST
49232: LIST
49233: PUSH
49234: LD_INT 0
49236: PUSH
49237: LD_INT 3
49239: NEG
49240: PUSH
49241: EMPTY
49242: LIST
49243: LIST
49244: PUSH
49245: LD_INT 1
49247: NEG
49248: PUSH
49249: LD_INT 4
49251: NEG
49252: PUSH
49253: EMPTY
49254: LIST
49255: LIST
49256: PUSH
49257: LD_INT 1
49259: NEG
49260: PUSH
49261: LD_INT 5
49263: NEG
49264: PUSH
49265: EMPTY
49266: LIST
49267: LIST
49268: PUSH
49269: LD_INT 2
49271: PUSH
49272: LD_INT 3
49274: NEG
49275: PUSH
49276: EMPTY
49277: LIST
49278: LIST
49279: PUSH
49280: LD_INT 2
49282: NEG
49283: PUSH
49284: LD_INT 5
49286: NEG
49287: PUSH
49288: EMPTY
49289: LIST
49290: LIST
49291: PUSH
49292: EMPTY
49293: LIST
49294: LIST
49295: LIST
49296: LIST
49297: LIST
49298: LIST
49299: LIST
49300: LIST
49301: LIST
49302: LIST
49303: LIST
49304: LIST
49305: LIST
49306: LIST
49307: LIST
49308: LIST
49309: LIST
49310: LIST
49311: LIST
49312: LIST
49313: LIST
49314: LIST
49315: LIST
49316: LIST
49317: LIST
49318: LIST
49319: LIST
49320: LIST
49321: LIST
49322: LIST
49323: LIST
49324: LIST
49325: LIST
49326: LIST
49327: LIST
49328: LIST
49329: LIST
49330: LIST
49331: LIST
49332: LIST
49333: LIST
49334: LIST
49335: LIST
49336: LIST
49337: LIST
49338: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
49339: LD_ADDR_VAR 0 31
49343: PUSH
49344: LD_INT 0
49346: PUSH
49347: LD_INT 4
49349: PUSH
49350: EMPTY
49351: LIST
49352: LIST
49353: PUSH
49354: LD_INT 0
49356: PUSH
49357: LD_INT 3
49359: PUSH
49360: EMPTY
49361: LIST
49362: LIST
49363: PUSH
49364: LD_INT 1
49366: PUSH
49367: LD_INT 4
49369: PUSH
49370: EMPTY
49371: LIST
49372: LIST
49373: PUSH
49374: LD_INT 1
49376: PUSH
49377: LD_INT 5
49379: PUSH
49380: EMPTY
49381: LIST
49382: LIST
49383: PUSH
49384: LD_INT 0
49386: PUSH
49387: LD_INT 5
49389: PUSH
49390: EMPTY
49391: LIST
49392: LIST
49393: PUSH
49394: LD_INT 1
49396: NEG
49397: PUSH
49398: LD_INT 4
49400: PUSH
49401: EMPTY
49402: LIST
49403: LIST
49404: PUSH
49405: LD_INT 1
49407: NEG
49408: PUSH
49409: LD_INT 3
49411: PUSH
49412: EMPTY
49413: LIST
49414: LIST
49415: PUSH
49416: LD_INT 2
49418: PUSH
49419: LD_INT 5
49421: PUSH
49422: EMPTY
49423: LIST
49424: LIST
49425: PUSH
49426: LD_INT 2
49428: NEG
49429: PUSH
49430: LD_INT 3
49432: PUSH
49433: EMPTY
49434: LIST
49435: LIST
49436: PUSH
49437: LD_INT 3
49439: NEG
49440: PUSH
49441: LD_INT 0
49443: PUSH
49444: EMPTY
49445: LIST
49446: LIST
49447: PUSH
49448: LD_INT 3
49450: NEG
49451: PUSH
49452: LD_INT 1
49454: NEG
49455: PUSH
49456: EMPTY
49457: LIST
49458: LIST
49459: PUSH
49460: LD_INT 2
49462: NEG
49463: PUSH
49464: LD_INT 0
49466: PUSH
49467: EMPTY
49468: LIST
49469: LIST
49470: PUSH
49471: LD_INT 2
49473: NEG
49474: PUSH
49475: LD_INT 1
49477: PUSH
49478: EMPTY
49479: LIST
49480: LIST
49481: PUSH
49482: LD_INT 3
49484: NEG
49485: PUSH
49486: LD_INT 1
49488: PUSH
49489: EMPTY
49490: LIST
49491: LIST
49492: PUSH
49493: LD_INT 4
49495: NEG
49496: PUSH
49497: LD_INT 0
49499: PUSH
49500: EMPTY
49501: LIST
49502: LIST
49503: PUSH
49504: LD_INT 4
49506: NEG
49507: PUSH
49508: LD_INT 1
49510: NEG
49511: PUSH
49512: EMPTY
49513: LIST
49514: LIST
49515: PUSH
49516: LD_INT 4
49518: NEG
49519: PUSH
49520: LD_INT 2
49522: NEG
49523: PUSH
49524: EMPTY
49525: LIST
49526: LIST
49527: PUSH
49528: LD_INT 2
49530: NEG
49531: PUSH
49532: LD_INT 2
49534: PUSH
49535: EMPTY
49536: LIST
49537: LIST
49538: PUSH
49539: LD_INT 4
49541: NEG
49542: PUSH
49543: LD_INT 4
49545: NEG
49546: PUSH
49547: EMPTY
49548: LIST
49549: LIST
49550: PUSH
49551: LD_INT 4
49553: NEG
49554: PUSH
49555: LD_INT 5
49557: NEG
49558: PUSH
49559: EMPTY
49560: LIST
49561: LIST
49562: PUSH
49563: LD_INT 3
49565: NEG
49566: PUSH
49567: LD_INT 4
49569: NEG
49570: PUSH
49571: EMPTY
49572: LIST
49573: LIST
49574: PUSH
49575: LD_INT 3
49577: NEG
49578: PUSH
49579: LD_INT 3
49581: NEG
49582: PUSH
49583: EMPTY
49584: LIST
49585: LIST
49586: PUSH
49587: LD_INT 4
49589: NEG
49590: PUSH
49591: LD_INT 3
49593: NEG
49594: PUSH
49595: EMPTY
49596: LIST
49597: LIST
49598: PUSH
49599: LD_INT 5
49601: NEG
49602: PUSH
49603: LD_INT 4
49605: NEG
49606: PUSH
49607: EMPTY
49608: LIST
49609: LIST
49610: PUSH
49611: LD_INT 5
49613: NEG
49614: PUSH
49615: LD_INT 5
49617: NEG
49618: PUSH
49619: EMPTY
49620: LIST
49621: LIST
49622: PUSH
49623: LD_INT 3
49625: NEG
49626: PUSH
49627: LD_INT 5
49629: NEG
49630: PUSH
49631: EMPTY
49632: LIST
49633: LIST
49634: PUSH
49635: LD_INT 5
49637: NEG
49638: PUSH
49639: LD_INT 3
49641: NEG
49642: PUSH
49643: EMPTY
49644: LIST
49645: LIST
49646: PUSH
49647: LD_INT 0
49649: PUSH
49650: LD_INT 3
49652: NEG
49653: PUSH
49654: EMPTY
49655: LIST
49656: LIST
49657: PUSH
49658: LD_INT 0
49660: PUSH
49661: LD_INT 4
49663: NEG
49664: PUSH
49665: EMPTY
49666: LIST
49667: LIST
49668: PUSH
49669: LD_INT 1
49671: PUSH
49672: LD_INT 3
49674: NEG
49675: PUSH
49676: EMPTY
49677: LIST
49678: LIST
49679: PUSH
49680: LD_INT 1
49682: PUSH
49683: LD_INT 2
49685: NEG
49686: PUSH
49687: EMPTY
49688: LIST
49689: LIST
49690: PUSH
49691: LD_INT 0
49693: PUSH
49694: LD_INT 2
49696: NEG
49697: PUSH
49698: EMPTY
49699: LIST
49700: LIST
49701: PUSH
49702: LD_INT 1
49704: NEG
49705: PUSH
49706: LD_INT 3
49708: NEG
49709: PUSH
49710: EMPTY
49711: LIST
49712: LIST
49713: PUSH
49714: LD_INT 1
49716: NEG
49717: PUSH
49718: LD_INT 4
49720: NEG
49721: PUSH
49722: EMPTY
49723: LIST
49724: LIST
49725: PUSH
49726: LD_INT 2
49728: PUSH
49729: LD_INT 2
49731: NEG
49732: PUSH
49733: EMPTY
49734: LIST
49735: LIST
49736: PUSH
49737: LD_INT 2
49739: NEG
49740: PUSH
49741: LD_INT 4
49743: NEG
49744: PUSH
49745: EMPTY
49746: LIST
49747: LIST
49748: PUSH
49749: LD_INT 4
49751: PUSH
49752: LD_INT 0
49754: PUSH
49755: EMPTY
49756: LIST
49757: LIST
49758: PUSH
49759: LD_INT 4
49761: PUSH
49762: LD_INT 1
49764: NEG
49765: PUSH
49766: EMPTY
49767: LIST
49768: LIST
49769: PUSH
49770: LD_INT 5
49772: PUSH
49773: LD_INT 0
49775: PUSH
49776: EMPTY
49777: LIST
49778: LIST
49779: PUSH
49780: LD_INT 5
49782: PUSH
49783: LD_INT 1
49785: PUSH
49786: EMPTY
49787: LIST
49788: LIST
49789: PUSH
49790: LD_INT 4
49792: PUSH
49793: LD_INT 1
49795: PUSH
49796: EMPTY
49797: LIST
49798: LIST
49799: PUSH
49800: LD_INT 3
49802: PUSH
49803: LD_INT 0
49805: PUSH
49806: EMPTY
49807: LIST
49808: LIST
49809: PUSH
49810: LD_INT 3
49812: PUSH
49813: LD_INT 1
49815: NEG
49816: PUSH
49817: EMPTY
49818: LIST
49819: LIST
49820: PUSH
49821: LD_INT 3
49823: PUSH
49824: LD_INT 2
49826: NEG
49827: PUSH
49828: EMPTY
49829: LIST
49830: LIST
49831: PUSH
49832: LD_INT 5
49834: PUSH
49835: LD_INT 2
49837: PUSH
49838: EMPTY
49839: LIST
49840: LIST
49841: PUSH
49842: EMPTY
49843: LIST
49844: LIST
49845: LIST
49846: LIST
49847: LIST
49848: LIST
49849: LIST
49850: LIST
49851: LIST
49852: LIST
49853: LIST
49854: LIST
49855: LIST
49856: LIST
49857: LIST
49858: LIST
49859: LIST
49860: LIST
49861: LIST
49862: LIST
49863: LIST
49864: LIST
49865: LIST
49866: LIST
49867: LIST
49868: LIST
49869: LIST
49870: LIST
49871: LIST
49872: LIST
49873: LIST
49874: LIST
49875: LIST
49876: LIST
49877: LIST
49878: LIST
49879: LIST
49880: LIST
49881: LIST
49882: LIST
49883: LIST
49884: LIST
49885: LIST
49886: LIST
49887: LIST
49888: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
49889: LD_ADDR_VAR 0 32
49893: PUSH
49894: LD_INT 4
49896: NEG
49897: PUSH
49898: LD_INT 0
49900: PUSH
49901: EMPTY
49902: LIST
49903: LIST
49904: PUSH
49905: LD_INT 4
49907: NEG
49908: PUSH
49909: LD_INT 1
49911: NEG
49912: PUSH
49913: EMPTY
49914: LIST
49915: LIST
49916: PUSH
49917: LD_INT 3
49919: NEG
49920: PUSH
49921: LD_INT 0
49923: PUSH
49924: EMPTY
49925: LIST
49926: LIST
49927: PUSH
49928: LD_INT 3
49930: NEG
49931: PUSH
49932: LD_INT 1
49934: PUSH
49935: EMPTY
49936: LIST
49937: LIST
49938: PUSH
49939: LD_INT 4
49941: NEG
49942: PUSH
49943: LD_INT 1
49945: PUSH
49946: EMPTY
49947: LIST
49948: LIST
49949: PUSH
49950: LD_INT 5
49952: NEG
49953: PUSH
49954: LD_INT 0
49956: PUSH
49957: EMPTY
49958: LIST
49959: LIST
49960: PUSH
49961: LD_INT 5
49963: NEG
49964: PUSH
49965: LD_INT 1
49967: NEG
49968: PUSH
49969: EMPTY
49970: LIST
49971: LIST
49972: PUSH
49973: LD_INT 5
49975: NEG
49976: PUSH
49977: LD_INT 2
49979: NEG
49980: PUSH
49981: EMPTY
49982: LIST
49983: LIST
49984: PUSH
49985: LD_INT 3
49987: NEG
49988: PUSH
49989: LD_INT 2
49991: PUSH
49992: EMPTY
49993: LIST
49994: LIST
49995: PUSH
49996: LD_INT 3
49998: NEG
49999: PUSH
50000: LD_INT 3
50002: NEG
50003: PUSH
50004: EMPTY
50005: LIST
50006: LIST
50007: PUSH
50008: LD_INT 3
50010: NEG
50011: PUSH
50012: LD_INT 4
50014: NEG
50015: PUSH
50016: EMPTY
50017: LIST
50018: LIST
50019: PUSH
50020: LD_INT 2
50022: NEG
50023: PUSH
50024: LD_INT 3
50026: NEG
50027: PUSH
50028: EMPTY
50029: LIST
50030: LIST
50031: PUSH
50032: LD_INT 2
50034: NEG
50035: PUSH
50036: LD_INT 2
50038: NEG
50039: PUSH
50040: EMPTY
50041: LIST
50042: LIST
50043: PUSH
50044: LD_INT 3
50046: NEG
50047: PUSH
50048: LD_INT 2
50050: NEG
50051: PUSH
50052: EMPTY
50053: LIST
50054: LIST
50055: PUSH
50056: LD_INT 4
50058: NEG
50059: PUSH
50060: LD_INT 3
50062: NEG
50063: PUSH
50064: EMPTY
50065: LIST
50066: LIST
50067: PUSH
50068: LD_INT 4
50070: NEG
50071: PUSH
50072: LD_INT 4
50074: NEG
50075: PUSH
50076: EMPTY
50077: LIST
50078: LIST
50079: PUSH
50080: LD_INT 2
50082: NEG
50083: PUSH
50084: LD_INT 4
50086: NEG
50087: PUSH
50088: EMPTY
50089: LIST
50090: LIST
50091: PUSH
50092: LD_INT 4
50094: NEG
50095: PUSH
50096: LD_INT 2
50098: NEG
50099: PUSH
50100: EMPTY
50101: LIST
50102: LIST
50103: PUSH
50104: LD_INT 0
50106: PUSH
50107: LD_INT 4
50109: NEG
50110: PUSH
50111: EMPTY
50112: LIST
50113: LIST
50114: PUSH
50115: LD_INT 0
50117: PUSH
50118: LD_INT 5
50120: NEG
50121: PUSH
50122: EMPTY
50123: LIST
50124: LIST
50125: PUSH
50126: LD_INT 1
50128: PUSH
50129: LD_INT 4
50131: NEG
50132: PUSH
50133: EMPTY
50134: LIST
50135: LIST
50136: PUSH
50137: LD_INT 1
50139: PUSH
50140: LD_INT 3
50142: NEG
50143: PUSH
50144: EMPTY
50145: LIST
50146: LIST
50147: PUSH
50148: LD_INT 0
50150: PUSH
50151: LD_INT 3
50153: NEG
50154: PUSH
50155: EMPTY
50156: LIST
50157: LIST
50158: PUSH
50159: LD_INT 1
50161: NEG
50162: PUSH
50163: LD_INT 4
50165: NEG
50166: PUSH
50167: EMPTY
50168: LIST
50169: LIST
50170: PUSH
50171: LD_INT 1
50173: NEG
50174: PUSH
50175: LD_INT 5
50177: NEG
50178: PUSH
50179: EMPTY
50180: LIST
50181: LIST
50182: PUSH
50183: LD_INT 2
50185: PUSH
50186: LD_INT 3
50188: NEG
50189: PUSH
50190: EMPTY
50191: LIST
50192: LIST
50193: PUSH
50194: LD_INT 2
50196: NEG
50197: PUSH
50198: LD_INT 5
50200: NEG
50201: PUSH
50202: EMPTY
50203: LIST
50204: LIST
50205: PUSH
50206: LD_INT 3
50208: PUSH
50209: LD_INT 0
50211: PUSH
50212: EMPTY
50213: LIST
50214: LIST
50215: PUSH
50216: LD_INT 3
50218: PUSH
50219: LD_INT 1
50221: NEG
50222: PUSH
50223: EMPTY
50224: LIST
50225: LIST
50226: PUSH
50227: LD_INT 4
50229: PUSH
50230: LD_INT 0
50232: PUSH
50233: EMPTY
50234: LIST
50235: LIST
50236: PUSH
50237: LD_INT 4
50239: PUSH
50240: LD_INT 1
50242: PUSH
50243: EMPTY
50244: LIST
50245: LIST
50246: PUSH
50247: LD_INT 3
50249: PUSH
50250: LD_INT 1
50252: PUSH
50253: EMPTY
50254: LIST
50255: LIST
50256: PUSH
50257: LD_INT 2
50259: PUSH
50260: LD_INT 0
50262: PUSH
50263: EMPTY
50264: LIST
50265: LIST
50266: PUSH
50267: LD_INT 2
50269: PUSH
50270: LD_INT 1
50272: NEG
50273: PUSH
50274: EMPTY
50275: LIST
50276: LIST
50277: PUSH
50278: LD_INT 2
50280: PUSH
50281: LD_INT 2
50283: NEG
50284: PUSH
50285: EMPTY
50286: LIST
50287: LIST
50288: PUSH
50289: LD_INT 4
50291: PUSH
50292: LD_INT 2
50294: PUSH
50295: EMPTY
50296: LIST
50297: LIST
50298: PUSH
50299: LD_INT 4
50301: PUSH
50302: LD_INT 4
50304: PUSH
50305: EMPTY
50306: LIST
50307: LIST
50308: PUSH
50309: LD_INT 4
50311: PUSH
50312: LD_INT 3
50314: PUSH
50315: EMPTY
50316: LIST
50317: LIST
50318: PUSH
50319: LD_INT 5
50321: PUSH
50322: LD_INT 4
50324: PUSH
50325: EMPTY
50326: LIST
50327: LIST
50328: PUSH
50329: LD_INT 5
50331: PUSH
50332: LD_INT 5
50334: PUSH
50335: EMPTY
50336: LIST
50337: LIST
50338: PUSH
50339: LD_INT 4
50341: PUSH
50342: LD_INT 5
50344: PUSH
50345: EMPTY
50346: LIST
50347: LIST
50348: PUSH
50349: LD_INT 3
50351: PUSH
50352: LD_INT 4
50354: PUSH
50355: EMPTY
50356: LIST
50357: LIST
50358: PUSH
50359: LD_INT 3
50361: PUSH
50362: LD_INT 3
50364: PUSH
50365: EMPTY
50366: LIST
50367: LIST
50368: PUSH
50369: LD_INT 5
50371: PUSH
50372: LD_INT 3
50374: PUSH
50375: EMPTY
50376: LIST
50377: LIST
50378: PUSH
50379: LD_INT 3
50381: PUSH
50382: LD_INT 5
50384: PUSH
50385: EMPTY
50386: LIST
50387: LIST
50388: PUSH
50389: EMPTY
50390: LIST
50391: LIST
50392: LIST
50393: LIST
50394: LIST
50395: LIST
50396: LIST
50397: LIST
50398: LIST
50399: LIST
50400: LIST
50401: LIST
50402: LIST
50403: LIST
50404: LIST
50405: LIST
50406: LIST
50407: LIST
50408: LIST
50409: LIST
50410: LIST
50411: LIST
50412: LIST
50413: LIST
50414: LIST
50415: LIST
50416: LIST
50417: LIST
50418: LIST
50419: LIST
50420: LIST
50421: LIST
50422: LIST
50423: LIST
50424: LIST
50425: LIST
50426: LIST
50427: LIST
50428: LIST
50429: LIST
50430: LIST
50431: LIST
50432: LIST
50433: LIST
50434: LIST
50435: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
50436: LD_ADDR_VAR 0 33
50440: PUSH
50441: LD_INT 4
50443: NEG
50444: PUSH
50445: LD_INT 4
50447: NEG
50448: PUSH
50449: EMPTY
50450: LIST
50451: LIST
50452: PUSH
50453: LD_INT 4
50455: NEG
50456: PUSH
50457: LD_INT 5
50459: NEG
50460: PUSH
50461: EMPTY
50462: LIST
50463: LIST
50464: PUSH
50465: LD_INT 3
50467: NEG
50468: PUSH
50469: LD_INT 4
50471: NEG
50472: PUSH
50473: EMPTY
50474: LIST
50475: LIST
50476: PUSH
50477: LD_INT 3
50479: NEG
50480: PUSH
50481: LD_INT 3
50483: NEG
50484: PUSH
50485: EMPTY
50486: LIST
50487: LIST
50488: PUSH
50489: LD_INT 4
50491: NEG
50492: PUSH
50493: LD_INT 3
50495: NEG
50496: PUSH
50497: EMPTY
50498: LIST
50499: LIST
50500: PUSH
50501: LD_INT 5
50503: NEG
50504: PUSH
50505: LD_INT 4
50507: NEG
50508: PUSH
50509: EMPTY
50510: LIST
50511: LIST
50512: PUSH
50513: LD_INT 5
50515: NEG
50516: PUSH
50517: LD_INT 5
50519: NEG
50520: PUSH
50521: EMPTY
50522: LIST
50523: LIST
50524: PUSH
50525: LD_INT 3
50527: NEG
50528: PUSH
50529: LD_INT 5
50531: NEG
50532: PUSH
50533: EMPTY
50534: LIST
50535: LIST
50536: PUSH
50537: LD_INT 5
50539: NEG
50540: PUSH
50541: LD_INT 3
50543: NEG
50544: PUSH
50545: EMPTY
50546: LIST
50547: LIST
50548: PUSH
50549: LD_INT 0
50551: PUSH
50552: LD_INT 3
50554: NEG
50555: PUSH
50556: EMPTY
50557: LIST
50558: LIST
50559: PUSH
50560: LD_INT 0
50562: PUSH
50563: LD_INT 4
50565: NEG
50566: PUSH
50567: EMPTY
50568: LIST
50569: LIST
50570: PUSH
50571: LD_INT 1
50573: PUSH
50574: LD_INT 3
50576: NEG
50577: PUSH
50578: EMPTY
50579: LIST
50580: LIST
50581: PUSH
50582: LD_INT 1
50584: PUSH
50585: LD_INT 2
50587: NEG
50588: PUSH
50589: EMPTY
50590: LIST
50591: LIST
50592: PUSH
50593: LD_INT 0
50595: PUSH
50596: LD_INT 2
50598: NEG
50599: PUSH
50600: EMPTY
50601: LIST
50602: LIST
50603: PUSH
50604: LD_INT 1
50606: NEG
50607: PUSH
50608: LD_INT 3
50610: NEG
50611: PUSH
50612: EMPTY
50613: LIST
50614: LIST
50615: PUSH
50616: LD_INT 1
50618: NEG
50619: PUSH
50620: LD_INT 4
50622: NEG
50623: PUSH
50624: EMPTY
50625: LIST
50626: LIST
50627: PUSH
50628: LD_INT 2
50630: PUSH
50631: LD_INT 2
50633: NEG
50634: PUSH
50635: EMPTY
50636: LIST
50637: LIST
50638: PUSH
50639: LD_INT 2
50641: NEG
50642: PUSH
50643: LD_INT 4
50645: NEG
50646: PUSH
50647: EMPTY
50648: LIST
50649: LIST
50650: PUSH
50651: LD_INT 4
50653: PUSH
50654: LD_INT 0
50656: PUSH
50657: EMPTY
50658: LIST
50659: LIST
50660: PUSH
50661: LD_INT 4
50663: PUSH
50664: LD_INT 1
50666: NEG
50667: PUSH
50668: EMPTY
50669: LIST
50670: LIST
50671: PUSH
50672: LD_INT 5
50674: PUSH
50675: LD_INT 0
50677: PUSH
50678: EMPTY
50679: LIST
50680: LIST
50681: PUSH
50682: LD_INT 5
50684: PUSH
50685: LD_INT 1
50687: PUSH
50688: EMPTY
50689: LIST
50690: LIST
50691: PUSH
50692: LD_INT 4
50694: PUSH
50695: LD_INT 1
50697: PUSH
50698: EMPTY
50699: LIST
50700: LIST
50701: PUSH
50702: LD_INT 3
50704: PUSH
50705: LD_INT 0
50707: PUSH
50708: EMPTY
50709: LIST
50710: LIST
50711: PUSH
50712: LD_INT 3
50714: PUSH
50715: LD_INT 1
50717: NEG
50718: PUSH
50719: EMPTY
50720: LIST
50721: LIST
50722: PUSH
50723: LD_INT 3
50725: PUSH
50726: LD_INT 2
50728: NEG
50729: PUSH
50730: EMPTY
50731: LIST
50732: LIST
50733: PUSH
50734: LD_INT 5
50736: PUSH
50737: LD_INT 2
50739: PUSH
50740: EMPTY
50741: LIST
50742: LIST
50743: PUSH
50744: LD_INT 3
50746: PUSH
50747: LD_INT 3
50749: PUSH
50750: EMPTY
50751: LIST
50752: LIST
50753: PUSH
50754: LD_INT 3
50756: PUSH
50757: LD_INT 2
50759: PUSH
50760: EMPTY
50761: LIST
50762: LIST
50763: PUSH
50764: LD_INT 4
50766: PUSH
50767: LD_INT 3
50769: PUSH
50770: EMPTY
50771: LIST
50772: LIST
50773: PUSH
50774: LD_INT 4
50776: PUSH
50777: LD_INT 4
50779: PUSH
50780: EMPTY
50781: LIST
50782: LIST
50783: PUSH
50784: LD_INT 3
50786: PUSH
50787: LD_INT 4
50789: PUSH
50790: EMPTY
50791: LIST
50792: LIST
50793: PUSH
50794: LD_INT 2
50796: PUSH
50797: LD_INT 3
50799: PUSH
50800: EMPTY
50801: LIST
50802: LIST
50803: PUSH
50804: LD_INT 2
50806: PUSH
50807: LD_INT 2
50809: PUSH
50810: EMPTY
50811: LIST
50812: LIST
50813: PUSH
50814: LD_INT 4
50816: PUSH
50817: LD_INT 2
50819: PUSH
50820: EMPTY
50821: LIST
50822: LIST
50823: PUSH
50824: LD_INT 2
50826: PUSH
50827: LD_INT 4
50829: PUSH
50830: EMPTY
50831: LIST
50832: LIST
50833: PUSH
50834: LD_INT 0
50836: PUSH
50837: LD_INT 4
50839: PUSH
50840: EMPTY
50841: LIST
50842: LIST
50843: PUSH
50844: LD_INT 0
50846: PUSH
50847: LD_INT 3
50849: PUSH
50850: EMPTY
50851: LIST
50852: LIST
50853: PUSH
50854: LD_INT 1
50856: PUSH
50857: LD_INT 4
50859: PUSH
50860: EMPTY
50861: LIST
50862: LIST
50863: PUSH
50864: LD_INT 1
50866: PUSH
50867: LD_INT 5
50869: PUSH
50870: EMPTY
50871: LIST
50872: LIST
50873: PUSH
50874: LD_INT 0
50876: PUSH
50877: LD_INT 5
50879: PUSH
50880: EMPTY
50881: LIST
50882: LIST
50883: PUSH
50884: LD_INT 1
50886: NEG
50887: PUSH
50888: LD_INT 4
50890: PUSH
50891: EMPTY
50892: LIST
50893: LIST
50894: PUSH
50895: LD_INT 1
50897: NEG
50898: PUSH
50899: LD_INT 3
50901: PUSH
50902: EMPTY
50903: LIST
50904: LIST
50905: PUSH
50906: LD_INT 2
50908: PUSH
50909: LD_INT 5
50911: PUSH
50912: EMPTY
50913: LIST
50914: LIST
50915: PUSH
50916: LD_INT 2
50918: NEG
50919: PUSH
50920: LD_INT 3
50922: PUSH
50923: EMPTY
50924: LIST
50925: LIST
50926: PUSH
50927: EMPTY
50928: LIST
50929: LIST
50930: LIST
50931: LIST
50932: LIST
50933: LIST
50934: LIST
50935: LIST
50936: LIST
50937: LIST
50938: LIST
50939: LIST
50940: LIST
50941: LIST
50942: LIST
50943: LIST
50944: LIST
50945: LIST
50946: LIST
50947: LIST
50948: LIST
50949: LIST
50950: LIST
50951: LIST
50952: LIST
50953: LIST
50954: LIST
50955: LIST
50956: LIST
50957: LIST
50958: LIST
50959: LIST
50960: LIST
50961: LIST
50962: LIST
50963: LIST
50964: LIST
50965: LIST
50966: LIST
50967: LIST
50968: LIST
50969: LIST
50970: LIST
50971: LIST
50972: LIST
50973: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
50974: LD_ADDR_VAR 0 34
50978: PUSH
50979: LD_INT 0
50981: PUSH
50982: LD_INT 4
50984: NEG
50985: PUSH
50986: EMPTY
50987: LIST
50988: LIST
50989: PUSH
50990: LD_INT 0
50992: PUSH
50993: LD_INT 5
50995: NEG
50996: PUSH
50997: EMPTY
50998: LIST
50999: LIST
51000: PUSH
51001: LD_INT 1
51003: PUSH
51004: LD_INT 4
51006: NEG
51007: PUSH
51008: EMPTY
51009: LIST
51010: LIST
51011: PUSH
51012: LD_INT 1
51014: PUSH
51015: LD_INT 3
51017: NEG
51018: PUSH
51019: EMPTY
51020: LIST
51021: LIST
51022: PUSH
51023: LD_INT 0
51025: PUSH
51026: LD_INT 3
51028: NEG
51029: PUSH
51030: EMPTY
51031: LIST
51032: LIST
51033: PUSH
51034: LD_INT 1
51036: NEG
51037: PUSH
51038: LD_INT 4
51040: NEG
51041: PUSH
51042: EMPTY
51043: LIST
51044: LIST
51045: PUSH
51046: LD_INT 1
51048: NEG
51049: PUSH
51050: LD_INT 5
51052: NEG
51053: PUSH
51054: EMPTY
51055: LIST
51056: LIST
51057: PUSH
51058: LD_INT 2
51060: PUSH
51061: LD_INT 3
51063: NEG
51064: PUSH
51065: EMPTY
51066: LIST
51067: LIST
51068: PUSH
51069: LD_INT 2
51071: NEG
51072: PUSH
51073: LD_INT 5
51075: NEG
51076: PUSH
51077: EMPTY
51078: LIST
51079: LIST
51080: PUSH
51081: LD_INT 3
51083: PUSH
51084: LD_INT 0
51086: PUSH
51087: EMPTY
51088: LIST
51089: LIST
51090: PUSH
51091: LD_INT 3
51093: PUSH
51094: LD_INT 1
51096: NEG
51097: PUSH
51098: EMPTY
51099: LIST
51100: LIST
51101: PUSH
51102: LD_INT 4
51104: PUSH
51105: LD_INT 0
51107: PUSH
51108: EMPTY
51109: LIST
51110: LIST
51111: PUSH
51112: LD_INT 4
51114: PUSH
51115: LD_INT 1
51117: PUSH
51118: EMPTY
51119: LIST
51120: LIST
51121: PUSH
51122: LD_INT 3
51124: PUSH
51125: LD_INT 1
51127: PUSH
51128: EMPTY
51129: LIST
51130: LIST
51131: PUSH
51132: LD_INT 2
51134: PUSH
51135: LD_INT 0
51137: PUSH
51138: EMPTY
51139: LIST
51140: LIST
51141: PUSH
51142: LD_INT 2
51144: PUSH
51145: LD_INT 1
51147: NEG
51148: PUSH
51149: EMPTY
51150: LIST
51151: LIST
51152: PUSH
51153: LD_INT 2
51155: PUSH
51156: LD_INT 2
51158: NEG
51159: PUSH
51160: EMPTY
51161: LIST
51162: LIST
51163: PUSH
51164: LD_INT 4
51166: PUSH
51167: LD_INT 2
51169: PUSH
51170: EMPTY
51171: LIST
51172: LIST
51173: PUSH
51174: LD_INT 4
51176: PUSH
51177: LD_INT 4
51179: PUSH
51180: EMPTY
51181: LIST
51182: LIST
51183: PUSH
51184: LD_INT 4
51186: PUSH
51187: LD_INT 3
51189: PUSH
51190: EMPTY
51191: LIST
51192: LIST
51193: PUSH
51194: LD_INT 5
51196: PUSH
51197: LD_INT 4
51199: PUSH
51200: EMPTY
51201: LIST
51202: LIST
51203: PUSH
51204: LD_INT 5
51206: PUSH
51207: LD_INT 5
51209: PUSH
51210: EMPTY
51211: LIST
51212: LIST
51213: PUSH
51214: LD_INT 4
51216: PUSH
51217: LD_INT 5
51219: PUSH
51220: EMPTY
51221: LIST
51222: LIST
51223: PUSH
51224: LD_INT 3
51226: PUSH
51227: LD_INT 4
51229: PUSH
51230: EMPTY
51231: LIST
51232: LIST
51233: PUSH
51234: LD_INT 3
51236: PUSH
51237: LD_INT 3
51239: PUSH
51240: EMPTY
51241: LIST
51242: LIST
51243: PUSH
51244: LD_INT 5
51246: PUSH
51247: LD_INT 3
51249: PUSH
51250: EMPTY
51251: LIST
51252: LIST
51253: PUSH
51254: LD_INT 3
51256: PUSH
51257: LD_INT 5
51259: PUSH
51260: EMPTY
51261: LIST
51262: LIST
51263: PUSH
51264: LD_INT 0
51266: PUSH
51267: LD_INT 3
51269: PUSH
51270: EMPTY
51271: LIST
51272: LIST
51273: PUSH
51274: LD_INT 0
51276: PUSH
51277: LD_INT 2
51279: PUSH
51280: EMPTY
51281: LIST
51282: LIST
51283: PUSH
51284: LD_INT 1
51286: PUSH
51287: LD_INT 3
51289: PUSH
51290: EMPTY
51291: LIST
51292: LIST
51293: PUSH
51294: LD_INT 1
51296: PUSH
51297: LD_INT 4
51299: PUSH
51300: EMPTY
51301: LIST
51302: LIST
51303: PUSH
51304: LD_INT 0
51306: PUSH
51307: LD_INT 4
51309: PUSH
51310: EMPTY
51311: LIST
51312: LIST
51313: PUSH
51314: LD_INT 1
51316: NEG
51317: PUSH
51318: LD_INT 3
51320: PUSH
51321: EMPTY
51322: LIST
51323: LIST
51324: PUSH
51325: LD_INT 1
51327: NEG
51328: PUSH
51329: LD_INT 2
51331: PUSH
51332: EMPTY
51333: LIST
51334: LIST
51335: PUSH
51336: LD_INT 2
51338: PUSH
51339: LD_INT 4
51341: PUSH
51342: EMPTY
51343: LIST
51344: LIST
51345: PUSH
51346: LD_INT 2
51348: NEG
51349: PUSH
51350: LD_INT 2
51352: PUSH
51353: EMPTY
51354: LIST
51355: LIST
51356: PUSH
51357: LD_INT 4
51359: NEG
51360: PUSH
51361: LD_INT 0
51363: PUSH
51364: EMPTY
51365: LIST
51366: LIST
51367: PUSH
51368: LD_INT 4
51370: NEG
51371: PUSH
51372: LD_INT 1
51374: NEG
51375: PUSH
51376: EMPTY
51377: LIST
51378: LIST
51379: PUSH
51380: LD_INT 3
51382: NEG
51383: PUSH
51384: LD_INT 0
51386: PUSH
51387: EMPTY
51388: LIST
51389: LIST
51390: PUSH
51391: LD_INT 3
51393: NEG
51394: PUSH
51395: LD_INT 1
51397: PUSH
51398: EMPTY
51399: LIST
51400: LIST
51401: PUSH
51402: LD_INT 4
51404: NEG
51405: PUSH
51406: LD_INT 1
51408: PUSH
51409: EMPTY
51410: LIST
51411: LIST
51412: PUSH
51413: LD_INT 5
51415: NEG
51416: PUSH
51417: LD_INT 0
51419: PUSH
51420: EMPTY
51421: LIST
51422: LIST
51423: PUSH
51424: LD_INT 5
51426: NEG
51427: PUSH
51428: LD_INT 1
51430: NEG
51431: PUSH
51432: EMPTY
51433: LIST
51434: LIST
51435: PUSH
51436: LD_INT 5
51438: NEG
51439: PUSH
51440: LD_INT 2
51442: NEG
51443: PUSH
51444: EMPTY
51445: LIST
51446: LIST
51447: PUSH
51448: LD_INT 3
51450: NEG
51451: PUSH
51452: LD_INT 2
51454: PUSH
51455: EMPTY
51456: LIST
51457: LIST
51458: PUSH
51459: EMPTY
51460: LIST
51461: LIST
51462: LIST
51463: LIST
51464: LIST
51465: LIST
51466: LIST
51467: LIST
51468: LIST
51469: LIST
51470: LIST
51471: LIST
51472: LIST
51473: LIST
51474: LIST
51475: LIST
51476: LIST
51477: LIST
51478: LIST
51479: LIST
51480: LIST
51481: LIST
51482: LIST
51483: LIST
51484: LIST
51485: LIST
51486: LIST
51487: LIST
51488: LIST
51489: LIST
51490: LIST
51491: LIST
51492: LIST
51493: LIST
51494: LIST
51495: LIST
51496: LIST
51497: LIST
51498: LIST
51499: LIST
51500: LIST
51501: LIST
51502: LIST
51503: LIST
51504: LIST
51505: ST_TO_ADDR
// end ; end ;
51506: GO 51509
51508: POP
// case btype of b_depot , b_warehouse :
51509: LD_VAR 0 1
51513: PUSH
51514: LD_INT 0
51516: DOUBLE
51517: EQUAL
51518: IFTRUE 51528
51520: LD_INT 1
51522: DOUBLE
51523: EQUAL
51524: IFTRUE 51528
51526: GO 51729
51528: POP
// case nation of nation_american :
51529: LD_VAR 0 5
51533: PUSH
51534: LD_INT 1
51536: DOUBLE
51537: EQUAL
51538: IFTRUE 51542
51540: GO 51598
51542: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
51543: LD_ADDR_VAR 0 9
51547: PUSH
51548: LD_VAR 0 11
51552: PUSH
51553: LD_VAR 0 12
51557: PUSH
51558: LD_VAR 0 13
51562: PUSH
51563: LD_VAR 0 14
51567: PUSH
51568: LD_VAR 0 15
51572: PUSH
51573: LD_VAR 0 16
51577: PUSH
51578: EMPTY
51579: LIST
51580: LIST
51581: LIST
51582: LIST
51583: LIST
51584: LIST
51585: PUSH
51586: LD_VAR 0 4
51590: PUSH
51591: LD_INT 1
51593: PLUS
51594: ARRAY
51595: ST_TO_ADDR
51596: GO 51727
51598: LD_INT 2
51600: DOUBLE
51601: EQUAL
51602: IFTRUE 51606
51604: GO 51662
51606: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
51607: LD_ADDR_VAR 0 9
51611: PUSH
51612: LD_VAR 0 17
51616: PUSH
51617: LD_VAR 0 18
51621: PUSH
51622: LD_VAR 0 19
51626: PUSH
51627: LD_VAR 0 20
51631: PUSH
51632: LD_VAR 0 21
51636: PUSH
51637: LD_VAR 0 22
51641: PUSH
51642: EMPTY
51643: LIST
51644: LIST
51645: LIST
51646: LIST
51647: LIST
51648: LIST
51649: PUSH
51650: LD_VAR 0 4
51654: PUSH
51655: LD_INT 1
51657: PLUS
51658: ARRAY
51659: ST_TO_ADDR
51660: GO 51727
51662: LD_INT 3
51664: DOUBLE
51665: EQUAL
51666: IFTRUE 51670
51668: GO 51726
51670: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
51671: LD_ADDR_VAR 0 9
51675: PUSH
51676: LD_VAR 0 23
51680: PUSH
51681: LD_VAR 0 24
51685: PUSH
51686: LD_VAR 0 25
51690: PUSH
51691: LD_VAR 0 26
51695: PUSH
51696: LD_VAR 0 27
51700: PUSH
51701: LD_VAR 0 28
51705: PUSH
51706: EMPTY
51707: LIST
51708: LIST
51709: LIST
51710: LIST
51711: LIST
51712: LIST
51713: PUSH
51714: LD_VAR 0 4
51718: PUSH
51719: LD_INT 1
51721: PLUS
51722: ARRAY
51723: ST_TO_ADDR
51724: GO 51727
51726: POP
51727: GO 52282
51729: LD_INT 2
51731: DOUBLE
51732: EQUAL
51733: IFTRUE 51743
51735: LD_INT 3
51737: DOUBLE
51738: EQUAL
51739: IFTRUE 51743
51741: GO 51799
51743: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
51744: LD_ADDR_VAR 0 9
51748: PUSH
51749: LD_VAR 0 29
51753: PUSH
51754: LD_VAR 0 30
51758: PUSH
51759: LD_VAR 0 31
51763: PUSH
51764: LD_VAR 0 32
51768: PUSH
51769: LD_VAR 0 33
51773: PUSH
51774: LD_VAR 0 34
51778: PUSH
51779: EMPTY
51780: LIST
51781: LIST
51782: LIST
51783: LIST
51784: LIST
51785: LIST
51786: PUSH
51787: LD_VAR 0 4
51791: PUSH
51792: LD_INT 1
51794: PLUS
51795: ARRAY
51796: ST_TO_ADDR
51797: GO 52282
51799: LD_INT 16
51801: DOUBLE
51802: EQUAL
51803: IFTRUE 51861
51805: LD_INT 17
51807: DOUBLE
51808: EQUAL
51809: IFTRUE 51861
51811: LD_INT 18
51813: DOUBLE
51814: EQUAL
51815: IFTRUE 51861
51817: LD_INT 19
51819: DOUBLE
51820: EQUAL
51821: IFTRUE 51861
51823: LD_INT 22
51825: DOUBLE
51826: EQUAL
51827: IFTRUE 51861
51829: LD_INT 20
51831: DOUBLE
51832: EQUAL
51833: IFTRUE 51861
51835: LD_INT 21
51837: DOUBLE
51838: EQUAL
51839: IFTRUE 51861
51841: LD_INT 23
51843: DOUBLE
51844: EQUAL
51845: IFTRUE 51861
51847: LD_INT 24
51849: DOUBLE
51850: EQUAL
51851: IFTRUE 51861
51853: LD_INT 25
51855: DOUBLE
51856: EQUAL
51857: IFTRUE 51861
51859: GO 51917
51861: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
51862: LD_ADDR_VAR 0 9
51866: PUSH
51867: LD_VAR 0 35
51871: PUSH
51872: LD_VAR 0 36
51876: PUSH
51877: LD_VAR 0 37
51881: PUSH
51882: LD_VAR 0 38
51886: PUSH
51887: LD_VAR 0 39
51891: PUSH
51892: LD_VAR 0 40
51896: PUSH
51897: EMPTY
51898: LIST
51899: LIST
51900: LIST
51901: LIST
51902: LIST
51903: LIST
51904: PUSH
51905: LD_VAR 0 4
51909: PUSH
51910: LD_INT 1
51912: PLUS
51913: ARRAY
51914: ST_TO_ADDR
51915: GO 52282
51917: LD_INT 6
51919: DOUBLE
51920: EQUAL
51921: IFTRUE 51973
51923: LD_INT 7
51925: DOUBLE
51926: EQUAL
51927: IFTRUE 51973
51929: LD_INT 8
51931: DOUBLE
51932: EQUAL
51933: IFTRUE 51973
51935: LD_INT 13
51937: DOUBLE
51938: EQUAL
51939: IFTRUE 51973
51941: LD_INT 12
51943: DOUBLE
51944: EQUAL
51945: IFTRUE 51973
51947: LD_INT 15
51949: DOUBLE
51950: EQUAL
51951: IFTRUE 51973
51953: LD_INT 11
51955: DOUBLE
51956: EQUAL
51957: IFTRUE 51973
51959: LD_INT 14
51961: DOUBLE
51962: EQUAL
51963: IFTRUE 51973
51965: LD_INT 10
51967: DOUBLE
51968: EQUAL
51969: IFTRUE 51973
51971: GO 52029
51973: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
51974: LD_ADDR_VAR 0 9
51978: PUSH
51979: LD_VAR 0 41
51983: PUSH
51984: LD_VAR 0 42
51988: PUSH
51989: LD_VAR 0 43
51993: PUSH
51994: LD_VAR 0 44
51998: PUSH
51999: LD_VAR 0 45
52003: PUSH
52004: LD_VAR 0 46
52008: PUSH
52009: EMPTY
52010: LIST
52011: LIST
52012: LIST
52013: LIST
52014: LIST
52015: LIST
52016: PUSH
52017: LD_VAR 0 4
52021: PUSH
52022: LD_INT 1
52024: PLUS
52025: ARRAY
52026: ST_TO_ADDR
52027: GO 52282
52029: LD_INT 36
52031: DOUBLE
52032: EQUAL
52033: IFTRUE 52037
52035: GO 52093
52037: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
52038: LD_ADDR_VAR 0 9
52042: PUSH
52043: LD_VAR 0 47
52047: PUSH
52048: LD_VAR 0 48
52052: PUSH
52053: LD_VAR 0 49
52057: PUSH
52058: LD_VAR 0 50
52062: PUSH
52063: LD_VAR 0 51
52067: PUSH
52068: LD_VAR 0 52
52072: PUSH
52073: EMPTY
52074: LIST
52075: LIST
52076: LIST
52077: LIST
52078: LIST
52079: LIST
52080: PUSH
52081: LD_VAR 0 4
52085: PUSH
52086: LD_INT 1
52088: PLUS
52089: ARRAY
52090: ST_TO_ADDR
52091: GO 52282
52093: LD_INT 4
52095: DOUBLE
52096: EQUAL
52097: IFTRUE 52119
52099: LD_INT 5
52101: DOUBLE
52102: EQUAL
52103: IFTRUE 52119
52105: LD_INT 34
52107: DOUBLE
52108: EQUAL
52109: IFTRUE 52119
52111: LD_INT 37
52113: DOUBLE
52114: EQUAL
52115: IFTRUE 52119
52117: GO 52175
52119: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
52120: LD_ADDR_VAR 0 9
52124: PUSH
52125: LD_VAR 0 53
52129: PUSH
52130: LD_VAR 0 54
52134: PUSH
52135: LD_VAR 0 55
52139: PUSH
52140: LD_VAR 0 56
52144: PUSH
52145: LD_VAR 0 57
52149: PUSH
52150: LD_VAR 0 58
52154: PUSH
52155: EMPTY
52156: LIST
52157: LIST
52158: LIST
52159: LIST
52160: LIST
52161: LIST
52162: PUSH
52163: LD_VAR 0 4
52167: PUSH
52168: LD_INT 1
52170: PLUS
52171: ARRAY
52172: ST_TO_ADDR
52173: GO 52282
52175: LD_INT 31
52177: DOUBLE
52178: EQUAL
52179: IFTRUE 52225
52181: LD_INT 32
52183: DOUBLE
52184: EQUAL
52185: IFTRUE 52225
52187: LD_INT 33
52189: DOUBLE
52190: EQUAL
52191: IFTRUE 52225
52193: LD_INT 27
52195: DOUBLE
52196: EQUAL
52197: IFTRUE 52225
52199: LD_INT 26
52201: DOUBLE
52202: EQUAL
52203: IFTRUE 52225
52205: LD_INT 28
52207: DOUBLE
52208: EQUAL
52209: IFTRUE 52225
52211: LD_INT 29
52213: DOUBLE
52214: EQUAL
52215: IFTRUE 52225
52217: LD_INT 30
52219: DOUBLE
52220: EQUAL
52221: IFTRUE 52225
52223: GO 52281
52225: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
52226: LD_ADDR_VAR 0 9
52230: PUSH
52231: LD_VAR 0 59
52235: PUSH
52236: LD_VAR 0 60
52240: PUSH
52241: LD_VAR 0 61
52245: PUSH
52246: LD_VAR 0 62
52250: PUSH
52251: LD_VAR 0 63
52255: PUSH
52256: LD_VAR 0 64
52260: PUSH
52261: EMPTY
52262: LIST
52263: LIST
52264: LIST
52265: LIST
52266: LIST
52267: LIST
52268: PUSH
52269: LD_VAR 0 4
52273: PUSH
52274: LD_INT 1
52276: PLUS
52277: ARRAY
52278: ST_TO_ADDR
52279: GO 52282
52281: POP
// temp_list2 = [ ] ;
52282: LD_ADDR_VAR 0 10
52286: PUSH
52287: EMPTY
52288: ST_TO_ADDR
// for i in temp_list do
52289: LD_ADDR_VAR 0 8
52293: PUSH
52294: LD_VAR 0 9
52298: PUSH
52299: FOR_IN
52300: IFFALSE 52352
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
52302: LD_ADDR_VAR 0 10
52306: PUSH
52307: LD_VAR 0 10
52311: PUSH
52312: LD_VAR 0 8
52316: PUSH
52317: LD_INT 1
52319: ARRAY
52320: PUSH
52321: LD_VAR 0 2
52325: PLUS
52326: PUSH
52327: LD_VAR 0 8
52331: PUSH
52332: LD_INT 2
52334: ARRAY
52335: PUSH
52336: LD_VAR 0 3
52340: PLUS
52341: PUSH
52342: EMPTY
52343: LIST
52344: LIST
52345: PUSH
52346: EMPTY
52347: LIST
52348: ADD
52349: ST_TO_ADDR
52350: GO 52299
52352: POP
52353: POP
// result = temp_list2 ;
52354: LD_ADDR_VAR 0 7
52358: PUSH
52359: LD_VAR 0 10
52363: ST_TO_ADDR
// end ;
52364: LD_VAR 0 7
52368: RET
// export function EnemyInRange ( unit , dist ) ; begin
52369: LD_INT 0
52371: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
52372: LD_ADDR_VAR 0 3
52376: PUSH
52377: LD_VAR 0 1
52381: PPUSH
52382: CALL_OW 255
52386: PPUSH
52387: LD_VAR 0 1
52391: PPUSH
52392: CALL_OW 250
52396: PPUSH
52397: LD_VAR 0 1
52401: PPUSH
52402: CALL_OW 251
52406: PPUSH
52407: LD_VAR 0 2
52411: PPUSH
52412: CALL 25742 0 4
52416: PUSH
52417: LD_INT 4
52419: ARRAY
52420: ST_TO_ADDR
// end ;
52421: LD_VAR 0 3
52425: RET
// export function PlayerSeeMe ( unit ) ; begin
52426: LD_INT 0
52428: PPUSH
// result := See ( your_side , unit ) ;
52429: LD_ADDR_VAR 0 2
52433: PUSH
52434: LD_OWVAR 2
52438: PPUSH
52439: LD_VAR 0 1
52443: PPUSH
52444: CALL_OW 292
52448: ST_TO_ADDR
// end ;
52449: LD_VAR 0 2
52453: RET
// export function ReverseDir ( unit ) ; begin
52454: LD_INT 0
52456: PPUSH
// if not unit then
52457: LD_VAR 0 1
52461: NOT
52462: IFFALSE 52466
// exit ;
52464: GO 52489
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
52466: LD_ADDR_VAR 0 2
52470: PUSH
52471: LD_VAR 0 1
52475: PPUSH
52476: CALL_OW 254
52480: PUSH
52481: LD_INT 3
52483: PLUS
52484: PUSH
52485: LD_INT 6
52487: MOD
52488: ST_TO_ADDR
// end ;
52489: LD_VAR 0 2
52493: RET
// export function ReverseArray ( array ) ; var i ; begin
52494: LD_INT 0
52496: PPUSH
52497: PPUSH
// if not array then
52498: LD_VAR 0 1
52502: NOT
52503: IFFALSE 52507
// exit ;
52505: GO 52562
// result := [ ] ;
52507: LD_ADDR_VAR 0 2
52511: PUSH
52512: EMPTY
52513: ST_TO_ADDR
// for i := array downto 1 do
52514: LD_ADDR_VAR 0 3
52518: PUSH
52519: DOUBLE
52520: LD_VAR 0 1
52524: INC
52525: ST_TO_ADDR
52526: LD_INT 1
52528: PUSH
52529: FOR_DOWNTO
52530: IFFALSE 52560
// result := Join ( result , array [ i ] ) ;
52532: LD_ADDR_VAR 0 2
52536: PUSH
52537: LD_VAR 0 2
52541: PPUSH
52542: LD_VAR 0 1
52546: PUSH
52547: LD_VAR 0 3
52551: ARRAY
52552: PPUSH
52553: CALL 57205 0 2
52557: ST_TO_ADDR
52558: GO 52529
52560: POP
52561: POP
// end ;
52562: LD_VAR 0 2
52566: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tdist , tmp , hex ; begin
52567: LD_INT 0
52569: PPUSH
52570: PPUSH
52571: PPUSH
52572: PPUSH
52573: PPUSH
52574: PPUSH
// if not unit or not hexes then
52575: LD_VAR 0 1
52579: NOT
52580: PUSH
52581: LD_VAR 0 2
52585: NOT
52586: OR
52587: IFFALSE 52591
// exit ;
52589: GO 52714
// dist := 9999 ;
52591: LD_ADDR_VAR 0 5
52595: PUSH
52596: LD_INT 9999
52598: ST_TO_ADDR
// for i = 1 to hexes do
52599: LD_ADDR_VAR 0 4
52603: PUSH
52604: DOUBLE
52605: LD_INT 1
52607: DEC
52608: ST_TO_ADDR
52609: LD_VAR 0 2
52613: PUSH
52614: FOR_TO
52615: IFFALSE 52702
// begin tdist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
52617: LD_ADDR_VAR 0 6
52621: PUSH
52622: LD_VAR 0 1
52626: PPUSH
52627: LD_VAR 0 2
52631: PUSH
52632: LD_VAR 0 4
52636: ARRAY
52637: PUSH
52638: LD_INT 1
52640: ARRAY
52641: PPUSH
52642: LD_VAR 0 2
52646: PUSH
52647: LD_VAR 0 4
52651: ARRAY
52652: PUSH
52653: LD_INT 2
52655: ARRAY
52656: PPUSH
52657: CALL_OW 297
52661: ST_TO_ADDR
// if tdist < dist then
52662: LD_VAR 0 6
52666: PUSH
52667: LD_VAR 0 5
52671: LESS
52672: IFFALSE 52700
// begin hex := hexes [ i ] ;
52674: LD_ADDR_VAR 0 8
52678: PUSH
52679: LD_VAR 0 2
52683: PUSH
52684: LD_VAR 0 4
52688: ARRAY
52689: ST_TO_ADDR
// dist := tdist ;
52690: LD_ADDR_VAR 0 5
52694: PUSH
52695: LD_VAR 0 6
52699: ST_TO_ADDR
// end ; end ;
52700: GO 52614
52702: POP
52703: POP
// result := hex ;
52704: LD_ADDR_VAR 0 3
52708: PUSH
52709: LD_VAR 0 8
52713: ST_TO_ADDR
// end ;
52714: LD_VAR 0 3
52718: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
52719: LD_INT 0
52721: PPUSH
52722: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
52723: LD_VAR 0 1
52727: NOT
52728: PUSH
52729: LD_VAR 0 1
52733: PUSH
52734: LD_INT 21
52736: PUSH
52737: LD_INT 2
52739: PUSH
52740: EMPTY
52741: LIST
52742: LIST
52743: PUSH
52744: LD_INT 23
52746: PUSH
52747: LD_INT 2
52749: PUSH
52750: EMPTY
52751: LIST
52752: LIST
52753: PUSH
52754: EMPTY
52755: LIST
52756: LIST
52757: PPUSH
52758: CALL_OW 69
52762: IN
52763: NOT
52764: OR
52765: IFFALSE 52769
// exit ;
52767: GO 52816
// for i = 1 to 3 do
52769: LD_ADDR_VAR 0 3
52773: PUSH
52774: DOUBLE
52775: LD_INT 1
52777: DEC
52778: ST_TO_ADDR
52779: LD_INT 3
52781: PUSH
52782: FOR_TO
52783: IFFALSE 52814
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
52785: LD_VAR 0 1
52789: PPUSH
52790: CALL_OW 250
52794: PPUSH
52795: LD_VAR 0 1
52799: PPUSH
52800: CALL_OW 251
52804: PPUSH
52805: LD_INT 1
52807: PPUSH
52808: CALL_OW 453
52812: GO 52782
52814: POP
52815: POP
// end ;
52816: LD_VAR 0 2
52820: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
52821: LD_INT 0
52823: PPUSH
52824: PPUSH
52825: PPUSH
52826: PPUSH
52827: PPUSH
52828: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
52829: LD_VAR 0 1
52833: NOT
52834: PUSH
52835: LD_VAR 0 2
52839: NOT
52840: OR
52841: PUSH
52842: LD_VAR 0 1
52846: PPUSH
52847: CALL_OW 314
52851: OR
52852: IFFALSE 52856
// exit ;
52854: GO 53323
// if GetLives ( i ) < 250 then
52856: LD_VAR 0 4
52860: PPUSH
52861: CALL_OW 256
52865: PUSH
52866: LD_INT 250
52868: LESS
52869: IFFALSE 52882
// begin ComAutodestruct ( i ) ;
52871: LD_VAR 0 4
52875: PPUSH
52876: CALL 52719 0 1
// exit ;
52880: GO 53323
// end ; x := GetX ( enemy_unit ) ;
52882: LD_ADDR_VAR 0 7
52886: PUSH
52887: LD_VAR 0 2
52891: PPUSH
52892: CALL_OW 250
52896: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
52897: LD_ADDR_VAR 0 8
52901: PUSH
52902: LD_VAR 0 2
52906: PPUSH
52907: CALL_OW 251
52911: ST_TO_ADDR
// if not x or not y then
52912: LD_VAR 0 7
52916: NOT
52917: PUSH
52918: LD_VAR 0 8
52922: NOT
52923: OR
52924: IFFALSE 52928
// exit ;
52926: GO 53323
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
52928: LD_ADDR_VAR 0 6
52932: PUSH
52933: LD_VAR 0 7
52937: PPUSH
52938: LD_INT 0
52940: PPUSH
52941: LD_INT 4
52943: PPUSH
52944: CALL_OW 272
52948: PUSH
52949: LD_VAR 0 8
52953: PPUSH
52954: LD_INT 0
52956: PPUSH
52957: LD_INT 4
52959: PPUSH
52960: CALL_OW 273
52964: PUSH
52965: EMPTY
52966: LIST
52967: LIST
52968: PUSH
52969: LD_VAR 0 7
52973: PPUSH
52974: LD_INT 1
52976: PPUSH
52977: LD_INT 4
52979: PPUSH
52980: CALL_OW 272
52984: PUSH
52985: LD_VAR 0 8
52989: PPUSH
52990: LD_INT 1
52992: PPUSH
52993: LD_INT 4
52995: PPUSH
52996: CALL_OW 273
53000: PUSH
53001: EMPTY
53002: LIST
53003: LIST
53004: PUSH
53005: LD_VAR 0 7
53009: PPUSH
53010: LD_INT 2
53012: PPUSH
53013: LD_INT 4
53015: PPUSH
53016: CALL_OW 272
53020: PUSH
53021: LD_VAR 0 8
53025: PPUSH
53026: LD_INT 2
53028: PPUSH
53029: LD_INT 4
53031: PPUSH
53032: CALL_OW 273
53036: PUSH
53037: EMPTY
53038: LIST
53039: LIST
53040: PUSH
53041: LD_VAR 0 7
53045: PPUSH
53046: LD_INT 3
53048: PPUSH
53049: LD_INT 4
53051: PPUSH
53052: CALL_OW 272
53056: PUSH
53057: LD_VAR 0 8
53061: PPUSH
53062: LD_INT 3
53064: PPUSH
53065: LD_INT 4
53067: PPUSH
53068: CALL_OW 273
53072: PUSH
53073: EMPTY
53074: LIST
53075: LIST
53076: PUSH
53077: LD_VAR 0 7
53081: PPUSH
53082: LD_INT 4
53084: PPUSH
53085: LD_INT 4
53087: PPUSH
53088: CALL_OW 272
53092: PUSH
53093: LD_VAR 0 8
53097: PPUSH
53098: LD_INT 4
53100: PPUSH
53101: LD_INT 4
53103: PPUSH
53104: CALL_OW 273
53108: PUSH
53109: EMPTY
53110: LIST
53111: LIST
53112: PUSH
53113: LD_VAR 0 7
53117: PPUSH
53118: LD_INT 5
53120: PPUSH
53121: LD_INT 4
53123: PPUSH
53124: CALL_OW 272
53128: PUSH
53129: LD_VAR 0 8
53133: PPUSH
53134: LD_INT 5
53136: PPUSH
53137: LD_INT 4
53139: PPUSH
53140: CALL_OW 273
53144: PUSH
53145: EMPTY
53146: LIST
53147: LIST
53148: PUSH
53149: EMPTY
53150: LIST
53151: LIST
53152: LIST
53153: LIST
53154: LIST
53155: LIST
53156: ST_TO_ADDR
// for i = tmp downto 1 do
53157: LD_ADDR_VAR 0 4
53161: PUSH
53162: DOUBLE
53163: LD_VAR 0 6
53167: INC
53168: ST_TO_ADDR
53169: LD_INT 1
53171: PUSH
53172: FOR_DOWNTO
53173: IFFALSE 53274
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
53175: LD_VAR 0 6
53179: PUSH
53180: LD_VAR 0 4
53184: ARRAY
53185: PUSH
53186: LD_INT 1
53188: ARRAY
53189: PPUSH
53190: LD_VAR 0 6
53194: PUSH
53195: LD_VAR 0 4
53199: ARRAY
53200: PUSH
53201: LD_INT 2
53203: ARRAY
53204: PPUSH
53205: CALL_OW 488
53209: NOT
53210: PUSH
53211: LD_VAR 0 6
53215: PUSH
53216: LD_VAR 0 4
53220: ARRAY
53221: PUSH
53222: LD_INT 1
53224: ARRAY
53225: PPUSH
53226: LD_VAR 0 6
53230: PUSH
53231: LD_VAR 0 4
53235: ARRAY
53236: PUSH
53237: LD_INT 2
53239: ARRAY
53240: PPUSH
53241: CALL_OW 428
53245: PUSH
53246: LD_INT 0
53248: NONEQUAL
53249: OR
53250: IFFALSE 53272
// tmp := Delete ( tmp , i ) ;
53252: LD_ADDR_VAR 0 6
53256: PUSH
53257: LD_VAR 0 6
53261: PPUSH
53262: LD_VAR 0 4
53266: PPUSH
53267: CALL_OW 3
53271: ST_TO_ADDR
53272: GO 53172
53274: POP
53275: POP
// j := GetClosestHex ( unit , tmp ) ;
53276: LD_ADDR_VAR 0 5
53280: PUSH
53281: LD_VAR 0 1
53285: PPUSH
53286: LD_VAR 0 6
53290: PPUSH
53291: CALL 52567 0 2
53295: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
53296: LD_VAR 0 1
53300: PPUSH
53301: LD_VAR 0 5
53305: PUSH
53306: LD_INT 1
53308: ARRAY
53309: PPUSH
53310: LD_VAR 0 5
53314: PUSH
53315: LD_INT 2
53317: ARRAY
53318: PPUSH
53319: CALL_OW 111
// end ;
53323: LD_VAR 0 3
53327: RET
// export function PrepareApemanSoldier ( ) ; begin
53328: LD_INT 0
53330: PPUSH
// uc_nation := 0 ;
53331: LD_ADDR_OWVAR 21
53335: PUSH
53336: LD_INT 0
53338: ST_TO_ADDR
// hc_sex := sex_male ;
53339: LD_ADDR_OWVAR 27
53343: PUSH
53344: LD_INT 1
53346: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
53347: LD_ADDR_OWVAR 28
53351: PUSH
53352: LD_INT 15
53354: ST_TO_ADDR
// hc_gallery :=  ;
53355: LD_ADDR_OWVAR 33
53359: PUSH
53360: LD_STRING 
53362: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
53363: LD_ADDR_OWVAR 31
53367: PUSH
53368: LD_INT 0
53370: PPUSH
53371: LD_INT 3
53373: PPUSH
53374: CALL_OW 12
53378: PUSH
53379: LD_INT 0
53381: PPUSH
53382: LD_INT 3
53384: PPUSH
53385: CALL_OW 12
53389: PUSH
53390: LD_INT 0
53392: PUSH
53393: LD_INT 0
53395: PUSH
53396: EMPTY
53397: LIST
53398: LIST
53399: LIST
53400: LIST
53401: ST_TO_ADDR
// end ;
53402: LD_VAR 0 1
53406: RET
// export function PrepareApemanEngineer ( ) ; begin
53407: LD_INT 0
53409: PPUSH
// uc_nation := 0 ;
53410: LD_ADDR_OWVAR 21
53414: PUSH
53415: LD_INT 0
53417: ST_TO_ADDR
// hc_sex := sex_male ;
53418: LD_ADDR_OWVAR 27
53422: PUSH
53423: LD_INT 1
53425: ST_TO_ADDR
// hc_class := class_apeman_engineer ;
53426: LD_ADDR_OWVAR 28
53430: PUSH
53431: LD_INT 16
53433: ST_TO_ADDR
// hc_gallery :=  ;
53434: LD_ADDR_OWVAR 33
53438: PUSH
53439: LD_STRING 
53441: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
53442: LD_ADDR_OWVAR 31
53446: PUSH
53447: LD_INT 0
53449: PPUSH
53450: LD_INT 3
53452: PPUSH
53453: CALL_OW 12
53457: PUSH
53458: LD_INT 0
53460: PPUSH
53461: LD_INT 3
53463: PPUSH
53464: CALL_OW 12
53468: PUSH
53469: LD_INT 0
53471: PUSH
53472: LD_INT 0
53474: PUSH
53475: EMPTY
53476: LIST
53477: LIST
53478: LIST
53479: LIST
53480: ST_TO_ADDR
// end ;
53481: LD_VAR 0 1
53485: RET
// export function PrepareApeman ( agressivity ) ; begin
53486: LD_INT 0
53488: PPUSH
// uc_side := 0 ;
53489: LD_ADDR_OWVAR 20
53493: PUSH
53494: LD_INT 0
53496: ST_TO_ADDR
// uc_nation := 0 ;
53497: LD_ADDR_OWVAR 21
53501: PUSH
53502: LD_INT 0
53504: ST_TO_ADDR
// hc_sex := sex_male ;
53505: LD_ADDR_OWVAR 27
53509: PUSH
53510: LD_INT 1
53512: ST_TO_ADDR
// hc_class := class_apeman ;
53513: LD_ADDR_OWVAR 28
53517: PUSH
53518: LD_INT 12
53520: ST_TO_ADDR
// hc_gallery :=  ;
53521: LD_ADDR_OWVAR 33
53525: PUSH
53526: LD_STRING 
53528: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
53529: LD_ADDR_OWVAR 35
53533: PUSH
53534: LD_VAR 0 1
53538: NEG
53539: PPUSH
53540: LD_VAR 0 1
53544: PPUSH
53545: CALL_OW 12
53549: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
53550: LD_ADDR_OWVAR 31
53554: PUSH
53555: LD_INT 0
53557: PPUSH
53558: LD_INT 3
53560: PPUSH
53561: CALL_OW 12
53565: PUSH
53566: LD_INT 0
53568: PPUSH
53569: LD_INT 3
53571: PPUSH
53572: CALL_OW 12
53576: PUSH
53577: LD_INT 0
53579: PUSH
53580: LD_INT 0
53582: PUSH
53583: EMPTY
53584: LIST
53585: LIST
53586: LIST
53587: LIST
53588: ST_TO_ADDR
// end ;
53589: LD_VAR 0 2
53593: RET
// export function PrepareTiger ( agressivity ) ; begin
53594: LD_INT 0
53596: PPUSH
// uc_side := 0 ;
53597: LD_ADDR_OWVAR 20
53601: PUSH
53602: LD_INT 0
53604: ST_TO_ADDR
// uc_nation := 0 ;
53605: LD_ADDR_OWVAR 21
53609: PUSH
53610: LD_INT 0
53612: ST_TO_ADDR
// hc_class := class_tiger ;
53613: LD_ADDR_OWVAR 28
53617: PUSH
53618: LD_INT 14
53620: ST_TO_ADDR
// hc_gallery :=  ;
53621: LD_ADDR_OWVAR 33
53625: PUSH
53626: LD_STRING 
53628: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
53629: LD_ADDR_OWVAR 35
53633: PUSH
53634: LD_VAR 0 1
53638: NEG
53639: PPUSH
53640: LD_VAR 0 1
53644: PPUSH
53645: CALL_OW 12
53649: ST_TO_ADDR
// end ;
53650: LD_VAR 0 2
53654: RET
// export function PrepareEnchidna ( ) ; begin
53655: LD_INT 0
53657: PPUSH
// uc_side := 0 ;
53658: LD_ADDR_OWVAR 20
53662: PUSH
53663: LD_INT 0
53665: ST_TO_ADDR
// uc_nation := 0 ;
53666: LD_ADDR_OWVAR 21
53670: PUSH
53671: LD_INT 0
53673: ST_TO_ADDR
// hc_class := class_baggie ;
53674: LD_ADDR_OWVAR 28
53678: PUSH
53679: LD_INT 13
53681: ST_TO_ADDR
// hc_gallery :=  ;
53682: LD_ADDR_OWVAR 33
53686: PUSH
53687: LD_STRING 
53689: ST_TO_ADDR
// end ;
53690: LD_VAR 0 1
53694: RET
// export function PrepareFrog ( ) ; begin
53695: LD_INT 0
53697: PPUSH
// uc_side := 0 ;
53698: LD_ADDR_OWVAR 20
53702: PUSH
53703: LD_INT 0
53705: ST_TO_ADDR
// uc_nation := 0 ;
53706: LD_ADDR_OWVAR 21
53710: PUSH
53711: LD_INT 0
53713: ST_TO_ADDR
// hc_class := class_frog ;
53714: LD_ADDR_OWVAR 28
53718: PUSH
53719: LD_INT 19
53721: ST_TO_ADDR
// hc_gallery :=  ;
53722: LD_ADDR_OWVAR 33
53726: PUSH
53727: LD_STRING 
53729: ST_TO_ADDR
// end ;
53730: LD_VAR 0 1
53734: RET
// export function PrepareFish ( ) ; begin
53735: LD_INT 0
53737: PPUSH
// uc_side := 0 ;
53738: LD_ADDR_OWVAR 20
53742: PUSH
53743: LD_INT 0
53745: ST_TO_ADDR
// uc_nation := 0 ;
53746: LD_ADDR_OWVAR 21
53750: PUSH
53751: LD_INT 0
53753: ST_TO_ADDR
// hc_class := class_fish ;
53754: LD_ADDR_OWVAR 28
53758: PUSH
53759: LD_INT 20
53761: ST_TO_ADDR
// hc_gallery :=  ;
53762: LD_ADDR_OWVAR 33
53766: PUSH
53767: LD_STRING 
53769: ST_TO_ADDR
// end ;
53770: LD_VAR 0 1
53774: RET
// export function PrepareBird ( ) ; begin
53775: LD_INT 0
53777: PPUSH
// uc_side := 0 ;
53778: LD_ADDR_OWVAR 20
53782: PUSH
53783: LD_INT 0
53785: ST_TO_ADDR
// uc_nation := 0 ;
53786: LD_ADDR_OWVAR 21
53790: PUSH
53791: LD_INT 0
53793: ST_TO_ADDR
// hc_class := class_phororhacos ;
53794: LD_ADDR_OWVAR 28
53798: PUSH
53799: LD_INT 18
53801: ST_TO_ADDR
// hc_gallery :=  ;
53802: LD_ADDR_OWVAR 33
53806: PUSH
53807: LD_STRING 
53809: ST_TO_ADDR
// end ;
53810: LD_VAR 0 1
53814: RET
// export function PrepareHorse ( ) ; begin
53815: LD_INT 0
53817: PPUSH
// uc_side := 0 ;
53818: LD_ADDR_OWVAR 20
53822: PUSH
53823: LD_INT 0
53825: ST_TO_ADDR
// uc_nation := 0 ;
53826: LD_ADDR_OWVAR 21
53830: PUSH
53831: LD_INT 0
53833: ST_TO_ADDR
// hc_class := class_horse ;
53834: LD_ADDR_OWVAR 28
53838: PUSH
53839: LD_INT 21
53841: ST_TO_ADDR
// hc_gallery :=  ;
53842: LD_ADDR_OWVAR 33
53846: PUSH
53847: LD_STRING 
53849: ST_TO_ADDR
// end ;
53850: LD_VAR 0 1
53854: RET
// export function PrepareMastodont ( ) ; begin
53855: LD_INT 0
53857: PPUSH
// uc_side := 0 ;
53858: LD_ADDR_OWVAR 20
53862: PUSH
53863: LD_INT 0
53865: ST_TO_ADDR
// uc_nation := 0 ;
53866: LD_ADDR_OWVAR 21
53870: PUSH
53871: LD_INT 0
53873: ST_TO_ADDR
// vc_chassis := class_mastodont ;
53874: LD_ADDR_OWVAR 37
53878: PUSH
53879: LD_INT 31
53881: ST_TO_ADDR
// vc_control := control_rider ;
53882: LD_ADDR_OWVAR 38
53886: PUSH
53887: LD_INT 4
53889: ST_TO_ADDR
// end ;
53890: LD_VAR 0 1
53894: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
53895: LD_INT 0
53897: PPUSH
53898: PPUSH
53899: PPUSH
// uc_side = 0 ;
53900: LD_ADDR_OWVAR 20
53904: PUSH
53905: LD_INT 0
53907: ST_TO_ADDR
// uc_nation = 0 ;
53908: LD_ADDR_OWVAR 21
53912: PUSH
53913: LD_INT 0
53915: ST_TO_ADDR
// InitHc_All ( ) ;
53916: CALL_OW 584
// InitVc ;
53920: CALL_OW 20
// if mastodonts then
53924: LD_VAR 0 6
53928: IFFALSE 53995
// for i = 1 to mastodonts do
53930: LD_ADDR_VAR 0 11
53934: PUSH
53935: DOUBLE
53936: LD_INT 1
53938: DEC
53939: ST_TO_ADDR
53940: LD_VAR 0 6
53944: PUSH
53945: FOR_TO
53946: IFFALSE 53993
// begin vc_chassis := 31 ;
53948: LD_ADDR_OWVAR 37
53952: PUSH
53953: LD_INT 31
53955: ST_TO_ADDR
// vc_control := control_rider ;
53956: LD_ADDR_OWVAR 38
53960: PUSH
53961: LD_INT 4
53963: ST_TO_ADDR
// animal := CreateVehicle ;
53964: LD_ADDR_VAR 0 12
53968: PUSH
53969: CALL_OW 45
53973: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
53974: LD_VAR 0 12
53978: PPUSH
53979: LD_VAR 0 8
53983: PPUSH
53984: LD_INT 0
53986: PPUSH
53987: CALL 56123 0 3
// end ;
53991: GO 53945
53993: POP
53994: POP
// if horses then
53995: LD_VAR 0 5
53999: IFFALSE 54066
// for i = 1 to horses do
54001: LD_ADDR_VAR 0 11
54005: PUSH
54006: DOUBLE
54007: LD_INT 1
54009: DEC
54010: ST_TO_ADDR
54011: LD_VAR 0 5
54015: PUSH
54016: FOR_TO
54017: IFFALSE 54064
// begin hc_class := 21 ;
54019: LD_ADDR_OWVAR 28
54023: PUSH
54024: LD_INT 21
54026: ST_TO_ADDR
// hc_gallery :=  ;
54027: LD_ADDR_OWVAR 33
54031: PUSH
54032: LD_STRING 
54034: ST_TO_ADDR
// animal := CreateHuman ;
54035: LD_ADDR_VAR 0 12
54039: PUSH
54040: CALL_OW 44
54044: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
54045: LD_VAR 0 12
54049: PPUSH
54050: LD_VAR 0 8
54054: PPUSH
54055: LD_INT 0
54057: PPUSH
54058: CALL 56123 0 3
// end ;
54062: GO 54016
54064: POP
54065: POP
// if birds then
54066: LD_VAR 0 1
54070: IFFALSE 54137
// for i = 1 to birds do
54072: LD_ADDR_VAR 0 11
54076: PUSH
54077: DOUBLE
54078: LD_INT 1
54080: DEC
54081: ST_TO_ADDR
54082: LD_VAR 0 1
54086: PUSH
54087: FOR_TO
54088: IFFALSE 54135
// begin hc_class := 18 ;
54090: LD_ADDR_OWVAR 28
54094: PUSH
54095: LD_INT 18
54097: ST_TO_ADDR
// hc_gallery =  ;
54098: LD_ADDR_OWVAR 33
54102: PUSH
54103: LD_STRING 
54105: ST_TO_ADDR
// animal := CreateHuman ;
54106: LD_ADDR_VAR 0 12
54110: PUSH
54111: CALL_OW 44
54115: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
54116: LD_VAR 0 12
54120: PPUSH
54121: LD_VAR 0 8
54125: PPUSH
54126: LD_INT 0
54128: PPUSH
54129: CALL 56123 0 3
// end ;
54133: GO 54087
54135: POP
54136: POP
// if tigers then
54137: LD_VAR 0 2
54141: IFFALSE 54225
// for i = 1 to tigers do
54143: LD_ADDR_VAR 0 11
54147: PUSH
54148: DOUBLE
54149: LD_INT 1
54151: DEC
54152: ST_TO_ADDR
54153: LD_VAR 0 2
54157: PUSH
54158: FOR_TO
54159: IFFALSE 54223
// begin hc_class = class_tiger ;
54161: LD_ADDR_OWVAR 28
54165: PUSH
54166: LD_INT 14
54168: ST_TO_ADDR
// hc_gallery =  ;
54169: LD_ADDR_OWVAR 33
54173: PUSH
54174: LD_STRING 
54176: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
54177: LD_ADDR_OWVAR 35
54181: PUSH
54182: LD_INT 7
54184: NEG
54185: PPUSH
54186: LD_INT 7
54188: PPUSH
54189: CALL_OW 12
54193: ST_TO_ADDR
// animal := CreateHuman ;
54194: LD_ADDR_VAR 0 12
54198: PUSH
54199: CALL_OW 44
54203: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
54204: LD_VAR 0 12
54208: PPUSH
54209: LD_VAR 0 8
54213: PPUSH
54214: LD_INT 0
54216: PPUSH
54217: CALL 56123 0 3
// end ;
54221: GO 54158
54223: POP
54224: POP
// if apemans then
54225: LD_VAR 0 3
54229: IFFALSE 54352
// for i = 1 to apemans do
54231: LD_ADDR_VAR 0 11
54235: PUSH
54236: DOUBLE
54237: LD_INT 1
54239: DEC
54240: ST_TO_ADDR
54241: LD_VAR 0 3
54245: PUSH
54246: FOR_TO
54247: IFFALSE 54350
// begin hc_class = class_apeman ;
54249: LD_ADDR_OWVAR 28
54253: PUSH
54254: LD_INT 12
54256: ST_TO_ADDR
// hc_gallery =  ;
54257: LD_ADDR_OWVAR 33
54261: PUSH
54262: LD_STRING 
54264: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
54265: LD_ADDR_OWVAR 35
54269: PUSH
54270: LD_INT 2
54272: NEG
54273: PPUSH
54274: LD_INT 2
54276: PPUSH
54277: CALL_OW 12
54281: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
54282: LD_ADDR_OWVAR 31
54286: PUSH
54287: LD_INT 1
54289: PPUSH
54290: LD_INT 3
54292: PPUSH
54293: CALL_OW 12
54297: PUSH
54298: LD_INT 1
54300: PPUSH
54301: LD_INT 3
54303: PPUSH
54304: CALL_OW 12
54308: PUSH
54309: LD_INT 0
54311: PUSH
54312: LD_INT 0
54314: PUSH
54315: EMPTY
54316: LIST
54317: LIST
54318: LIST
54319: LIST
54320: ST_TO_ADDR
// animal := CreateHuman ;
54321: LD_ADDR_VAR 0 12
54325: PUSH
54326: CALL_OW 44
54330: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
54331: LD_VAR 0 12
54335: PPUSH
54336: LD_VAR 0 8
54340: PPUSH
54341: LD_INT 0
54343: PPUSH
54344: CALL 56123 0 3
// end ;
54348: GO 54246
54350: POP
54351: POP
// if enchidnas then
54352: LD_VAR 0 4
54356: IFFALSE 54423
// for i = 1 to enchidnas do
54358: LD_ADDR_VAR 0 11
54362: PUSH
54363: DOUBLE
54364: LD_INT 1
54366: DEC
54367: ST_TO_ADDR
54368: LD_VAR 0 4
54372: PUSH
54373: FOR_TO
54374: IFFALSE 54421
// begin hc_class = 13 ;
54376: LD_ADDR_OWVAR 28
54380: PUSH
54381: LD_INT 13
54383: ST_TO_ADDR
// hc_gallery =  ;
54384: LD_ADDR_OWVAR 33
54388: PUSH
54389: LD_STRING 
54391: ST_TO_ADDR
// animal := CreateHuman ;
54392: LD_ADDR_VAR 0 12
54396: PUSH
54397: CALL_OW 44
54401: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
54402: LD_VAR 0 12
54406: PPUSH
54407: LD_VAR 0 8
54411: PPUSH
54412: LD_INT 0
54414: PPUSH
54415: CALL 56123 0 3
// end ;
54419: GO 54373
54421: POP
54422: POP
// if fishes then
54423: LD_VAR 0 7
54427: IFFALSE 54494
// for i = 1 to fishes do
54429: LD_ADDR_VAR 0 11
54433: PUSH
54434: DOUBLE
54435: LD_INT 1
54437: DEC
54438: ST_TO_ADDR
54439: LD_VAR 0 7
54443: PUSH
54444: FOR_TO
54445: IFFALSE 54492
// begin hc_class = 20 ;
54447: LD_ADDR_OWVAR 28
54451: PUSH
54452: LD_INT 20
54454: ST_TO_ADDR
// hc_gallery =  ;
54455: LD_ADDR_OWVAR 33
54459: PUSH
54460: LD_STRING 
54462: ST_TO_ADDR
// animal := CreateHuman ;
54463: LD_ADDR_VAR 0 12
54467: PUSH
54468: CALL_OW 44
54472: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
54473: LD_VAR 0 12
54477: PPUSH
54478: LD_VAR 0 9
54482: PPUSH
54483: LD_INT 0
54485: PPUSH
54486: CALL 56123 0 3
// end ;
54490: GO 54444
54492: POP
54493: POP
// end ;
54494: LD_VAR 0 10
54498: RET
// export function WantHeal ( sci , unit ) ; begin
54499: LD_INT 0
54501: PPUSH
// if GetTaskList ( sci ) > 0 then
54502: LD_VAR 0 1
54506: PPUSH
54507: CALL_OW 437
54511: PUSH
54512: LD_INT 0
54514: GREATER
54515: IFFALSE 54585
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
54517: LD_VAR 0 1
54521: PPUSH
54522: CALL_OW 437
54526: PUSH
54527: LD_INT 1
54529: ARRAY
54530: PUSH
54531: LD_INT 1
54533: ARRAY
54534: PUSH
54535: LD_STRING l
54537: EQUAL
54538: PUSH
54539: LD_VAR 0 1
54543: PPUSH
54544: CALL_OW 437
54548: PUSH
54549: LD_INT 1
54551: ARRAY
54552: PUSH
54553: LD_INT 4
54555: ARRAY
54556: PUSH
54557: LD_VAR 0 2
54561: EQUAL
54562: AND
54563: IFFALSE 54575
// result := true else
54565: LD_ADDR_VAR 0 3
54569: PUSH
54570: LD_INT 1
54572: ST_TO_ADDR
54573: GO 54583
// result := false ;
54575: LD_ADDR_VAR 0 3
54579: PUSH
54580: LD_INT 0
54582: ST_TO_ADDR
// end else
54583: GO 54593
// result := false ;
54585: LD_ADDR_VAR 0 3
54589: PUSH
54590: LD_INT 0
54592: ST_TO_ADDR
// end ;
54593: LD_VAR 0 3
54597: RET
// export function HealTarget ( sci ) ; begin
54598: LD_INT 0
54600: PPUSH
// if not sci then
54601: LD_VAR 0 1
54605: NOT
54606: IFFALSE 54610
// exit ;
54608: GO 54675
// result := 0 ;
54610: LD_ADDR_VAR 0 2
54614: PUSH
54615: LD_INT 0
54617: ST_TO_ADDR
// if GetTaskList ( sci ) then
54618: LD_VAR 0 1
54622: PPUSH
54623: CALL_OW 437
54627: IFFALSE 54675
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
54629: LD_VAR 0 1
54633: PPUSH
54634: CALL_OW 437
54638: PUSH
54639: LD_INT 1
54641: ARRAY
54642: PUSH
54643: LD_INT 1
54645: ARRAY
54646: PUSH
54647: LD_STRING l
54649: EQUAL
54650: IFFALSE 54675
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
54652: LD_ADDR_VAR 0 2
54656: PUSH
54657: LD_VAR 0 1
54661: PPUSH
54662: CALL_OW 437
54666: PUSH
54667: LD_INT 1
54669: ARRAY
54670: PUSH
54671: LD_INT 4
54673: ARRAY
54674: ST_TO_ADDR
// end ;
54675: LD_VAR 0 2
54679: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
54680: LD_INT 0
54682: PPUSH
54683: PPUSH
54684: PPUSH
54685: PPUSH
// if not base_units then
54686: LD_VAR 0 1
54690: NOT
54691: IFFALSE 54695
// exit ;
54693: GO 54782
// result := false ;
54695: LD_ADDR_VAR 0 2
54699: PUSH
54700: LD_INT 0
54702: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
54703: LD_ADDR_VAR 0 5
54707: PUSH
54708: LD_VAR 0 1
54712: PPUSH
54713: LD_INT 21
54715: PUSH
54716: LD_INT 3
54718: PUSH
54719: EMPTY
54720: LIST
54721: LIST
54722: PPUSH
54723: CALL_OW 72
54727: ST_TO_ADDR
// if not tmp then
54728: LD_VAR 0 5
54732: NOT
54733: IFFALSE 54737
// exit ;
54735: GO 54782
// for i in tmp do
54737: LD_ADDR_VAR 0 3
54741: PUSH
54742: LD_VAR 0 5
54746: PUSH
54747: FOR_IN
54748: IFFALSE 54780
// begin result := EnemyInRange ( i , 22 ) ;
54750: LD_ADDR_VAR 0 2
54754: PUSH
54755: LD_VAR 0 3
54759: PPUSH
54760: LD_INT 22
54762: PPUSH
54763: CALL 52369 0 2
54767: ST_TO_ADDR
// if result then
54768: LD_VAR 0 2
54772: IFFALSE 54778
// exit ;
54774: POP
54775: POP
54776: GO 54782
// end ;
54778: GO 54747
54780: POP
54781: POP
// end ;
54782: LD_VAR 0 2
54786: RET
// export function FilterByTag ( units , tag ) ; begin
54787: LD_INT 0
54789: PPUSH
// result := UnitFilter ( units , [ f_tag , tag ] ) ;
54790: LD_ADDR_VAR 0 3
54794: PUSH
54795: LD_VAR 0 1
54799: PPUSH
54800: LD_INT 120
54802: PUSH
54803: LD_VAR 0 2
54807: PUSH
54808: EMPTY
54809: LIST
54810: LIST
54811: PPUSH
54812: CALL_OW 72
54816: ST_TO_ADDR
// end ;
54817: LD_VAR 0 3
54821: RET
// export function IsDriver ( un ) ; begin
54822: LD_INT 0
54824: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
54825: LD_ADDR_VAR 0 2
54829: PUSH
54830: LD_VAR 0 1
54834: PUSH
54835: LD_INT 55
54837: PUSH
54838: EMPTY
54839: LIST
54840: PPUSH
54841: CALL_OW 69
54845: IN
54846: ST_TO_ADDR
// end ;
54847: LD_VAR 0 2
54851: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
54852: LD_INT 0
54854: PPUSH
54855: PPUSH
// list := [ ] ;
54856: LD_ADDR_VAR 0 5
54860: PUSH
54861: EMPTY
54862: ST_TO_ADDR
// case d of 0 :
54863: LD_VAR 0 3
54867: PUSH
54868: LD_INT 0
54870: DOUBLE
54871: EQUAL
54872: IFTRUE 54876
54874: GO 55009
54876: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
54877: LD_ADDR_VAR 0 5
54881: PUSH
54882: LD_VAR 0 1
54886: PUSH
54887: LD_INT 4
54889: MINUS
54890: PUSH
54891: LD_VAR 0 2
54895: PUSH
54896: LD_INT 4
54898: MINUS
54899: PUSH
54900: LD_INT 2
54902: PUSH
54903: EMPTY
54904: LIST
54905: LIST
54906: LIST
54907: PUSH
54908: LD_VAR 0 1
54912: PUSH
54913: LD_INT 3
54915: MINUS
54916: PUSH
54917: LD_VAR 0 2
54921: PUSH
54922: LD_INT 1
54924: PUSH
54925: EMPTY
54926: LIST
54927: LIST
54928: LIST
54929: PUSH
54930: LD_VAR 0 1
54934: PUSH
54935: LD_INT 4
54937: PLUS
54938: PUSH
54939: LD_VAR 0 2
54943: PUSH
54944: LD_INT 4
54946: PUSH
54947: EMPTY
54948: LIST
54949: LIST
54950: LIST
54951: PUSH
54952: LD_VAR 0 1
54956: PUSH
54957: LD_INT 3
54959: PLUS
54960: PUSH
54961: LD_VAR 0 2
54965: PUSH
54966: LD_INT 3
54968: PLUS
54969: PUSH
54970: LD_INT 5
54972: PUSH
54973: EMPTY
54974: LIST
54975: LIST
54976: LIST
54977: PUSH
54978: LD_VAR 0 1
54982: PUSH
54983: LD_VAR 0 2
54987: PUSH
54988: LD_INT 4
54990: PLUS
54991: PUSH
54992: LD_INT 0
54994: PUSH
54995: EMPTY
54996: LIST
54997: LIST
54998: LIST
54999: PUSH
55000: EMPTY
55001: LIST
55002: LIST
55003: LIST
55004: LIST
55005: LIST
55006: ST_TO_ADDR
// end ; 1 :
55007: GO 55707
55009: LD_INT 1
55011: DOUBLE
55012: EQUAL
55013: IFTRUE 55017
55015: GO 55150
55017: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
55018: LD_ADDR_VAR 0 5
55022: PUSH
55023: LD_VAR 0 1
55027: PUSH
55028: LD_VAR 0 2
55032: PUSH
55033: LD_INT 4
55035: MINUS
55036: PUSH
55037: LD_INT 3
55039: PUSH
55040: EMPTY
55041: LIST
55042: LIST
55043: LIST
55044: PUSH
55045: LD_VAR 0 1
55049: PUSH
55050: LD_INT 3
55052: MINUS
55053: PUSH
55054: LD_VAR 0 2
55058: PUSH
55059: LD_INT 3
55061: MINUS
55062: PUSH
55063: LD_INT 2
55065: PUSH
55066: EMPTY
55067: LIST
55068: LIST
55069: LIST
55070: PUSH
55071: LD_VAR 0 1
55075: PUSH
55076: LD_INT 4
55078: MINUS
55079: PUSH
55080: LD_VAR 0 2
55084: PUSH
55085: LD_INT 1
55087: PUSH
55088: EMPTY
55089: LIST
55090: LIST
55091: LIST
55092: PUSH
55093: LD_VAR 0 1
55097: PUSH
55098: LD_VAR 0 2
55102: PUSH
55103: LD_INT 3
55105: PLUS
55106: PUSH
55107: LD_INT 0
55109: PUSH
55110: EMPTY
55111: LIST
55112: LIST
55113: LIST
55114: PUSH
55115: LD_VAR 0 1
55119: PUSH
55120: LD_INT 4
55122: PLUS
55123: PUSH
55124: LD_VAR 0 2
55128: PUSH
55129: LD_INT 4
55131: PLUS
55132: PUSH
55133: LD_INT 5
55135: PUSH
55136: EMPTY
55137: LIST
55138: LIST
55139: LIST
55140: PUSH
55141: EMPTY
55142: LIST
55143: LIST
55144: LIST
55145: LIST
55146: LIST
55147: ST_TO_ADDR
// end ; 2 :
55148: GO 55707
55150: LD_INT 2
55152: DOUBLE
55153: EQUAL
55154: IFTRUE 55158
55156: GO 55287
55158: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
55159: LD_ADDR_VAR 0 5
55163: PUSH
55164: LD_VAR 0 1
55168: PUSH
55169: LD_VAR 0 2
55173: PUSH
55174: LD_INT 3
55176: MINUS
55177: PUSH
55178: LD_INT 3
55180: PUSH
55181: EMPTY
55182: LIST
55183: LIST
55184: LIST
55185: PUSH
55186: LD_VAR 0 1
55190: PUSH
55191: LD_INT 4
55193: PLUS
55194: PUSH
55195: LD_VAR 0 2
55199: PUSH
55200: LD_INT 4
55202: PUSH
55203: EMPTY
55204: LIST
55205: LIST
55206: LIST
55207: PUSH
55208: LD_VAR 0 1
55212: PUSH
55213: LD_VAR 0 2
55217: PUSH
55218: LD_INT 4
55220: PLUS
55221: PUSH
55222: LD_INT 0
55224: PUSH
55225: EMPTY
55226: LIST
55227: LIST
55228: LIST
55229: PUSH
55230: LD_VAR 0 1
55234: PUSH
55235: LD_INT 3
55237: MINUS
55238: PUSH
55239: LD_VAR 0 2
55243: PUSH
55244: LD_INT 1
55246: PUSH
55247: EMPTY
55248: LIST
55249: LIST
55250: LIST
55251: PUSH
55252: LD_VAR 0 1
55256: PUSH
55257: LD_INT 4
55259: MINUS
55260: PUSH
55261: LD_VAR 0 2
55265: PUSH
55266: LD_INT 4
55268: MINUS
55269: PUSH
55270: LD_INT 2
55272: PUSH
55273: EMPTY
55274: LIST
55275: LIST
55276: LIST
55277: PUSH
55278: EMPTY
55279: LIST
55280: LIST
55281: LIST
55282: LIST
55283: LIST
55284: ST_TO_ADDR
// end ; 3 :
55285: GO 55707
55287: LD_INT 3
55289: DOUBLE
55290: EQUAL
55291: IFTRUE 55295
55293: GO 55428
55295: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
55296: LD_ADDR_VAR 0 5
55300: PUSH
55301: LD_VAR 0 1
55305: PUSH
55306: LD_INT 3
55308: PLUS
55309: PUSH
55310: LD_VAR 0 2
55314: PUSH
55315: LD_INT 4
55317: PUSH
55318: EMPTY
55319: LIST
55320: LIST
55321: LIST
55322: PUSH
55323: LD_VAR 0 1
55327: PUSH
55328: LD_INT 4
55330: PLUS
55331: PUSH
55332: LD_VAR 0 2
55336: PUSH
55337: LD_INT 4
55339: PLUS
55340: PUSH
55341: LD_INT 5
55343: PUSH
55344: EMPTY
55345: LIST
55346: LIST
55347: LIST
55348: PUSH
55349: LD_VAR 0 1
55353: PUSH
55354: LD_INT 4
55356: MINUS
55357: PUSH
55358: LD_VAR 0 2
55362: PUSH
55363: LD_INT 1
55365: PUSH
55366: EMPTY
55367: LIST
55368: LIST
55369: LIST
55370: PUSH
55371: LD_VAR 0 1
55375: PUSH
55376: LD_VAR 0 2
55380: PUSH
55381: LD_INT 4
55383: MINUS
55384: PUSH
55385: LD_INT 3
55387: PUSH
55388: EMPTY
55389: LIST
55390: LIST
55391: LIST
55392: PUSH
55393: LD_VAR 0 1
55397: PUSH
55398: LD_INT 3
55400: MINUS
55401: PUSH
55402: LD_VAR 0 2
55406: PUSH
55407: LD_INT 3
55409: MINUS
55410: PUSH
55411: LD_INT 2
55413: PUSH
55414: EMPTY
55415: LIST
55416: LIST
55417: LIST
55418: PUSH
55419: EMPTY
55420: LIST
55421: LIST
55422: LIST
55423: LIST
55424: LIST
55425: ST_TO_ADDR
// end ; 4 :
55426: GO 55707
55428: LD_INT 4
55430: DOUBLE
55431: EQUAL
55432: IFTRUE 55436
55434: GO 55569
55436: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
55437: LD_ADDR_VAR 0 5
55441: PUSH
55442: LD_VAR 0 1
55446: PUSH
55447: LD_VAR 0 2
55451: PUSH
55452: LD_INT 4
55454: PLUS
55455: PUSH
55456: LD_INT 0
55458: PUSH
55459: EMPTY
55460: LIST
55461: LIST
55462: LIST
55463: PUSH
55464: LD_VAR 0 1
55468: PUSH
55469: LD_INT 3
55471: PLUS
55472: PUSH
55473: LD_VAR 0 2
55477: PUSH
55478: LD_INT 3
55480: PLUS
55481: PUSH
55482: LD_INT 5
55484: PUSH
55485: EMPTY
55486: LIST
55487: LIST
55488: LIST
55489: PUSH
55490: LD_VAR 0 1
55494: PUSH
55495: LD_INT 4
55497: PLUS
55498: PUSH
55499: LD_VAR 0 2
55503: PUSH
55504: LD_INT 4
55506: PUSH
55507: EMPTY
55508: LIST
55509: LIST
55510: LIST
55511: PUSH
55512: LD_VAR 0 1
55516: PUSH
55517: LD_VAR 0 2
55521: PUSH
55522: LD_INT 3
55524: MINUS
55525: PUSH
55526: LD_INT 3
55528: PUSH
55529: EMPTY
55530: LIST
55531: LIST
55532: LIST
55533: PUSH
55534: LD_VAR 0 1
55538: PUSH
55539: LD_INT 4
55541: MINUS
55542: PUSH
55543: LD_VAR 0 2
55547: PUSH
55548: LD_INT 4
55550: MINUS
55551: PUSH
55552: LD_INT 2
55554: PUSH
55555: EMPTY
55556: LIST
55557: LIST
55558: LIST
55559: PUSH
55560: EMPTY
55561: LIST
55562: LIST
55563: LIST
55564: LIST
55565: LIST
55566: ST_TO_ADDR
// end ; 5 :
55567: GO 55707
55569: LD_INT 5
55571: DOUBLE
55572: EQUAL
55573: IFTRUE 55577
55575: GO 55706
55577: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
55578: LD_ADDR_VAR 0 5
55582: PUSH
55583: LD_VAR 0 1
55587: PUSH
55588: LD_INT 4
55590: MINUS
55591: PUSH
55592: LD_VAR 0 2
55596: PUSH
55597: LD_INT 1
55599: PUSH
55600: EMPTY
55601: LIST
55602: LIST
55603: LIST
55604: PUSH
55605: LD_VAR 0 1
55609: PUSH
55610: LD_VAR 0 2
55614: PUSH
55615: LD_INT 4
55617: MINUS
55618: PUSH
55619: LD_INT 3
55621: PUSH
55622: EMPTY
55623: LIST
55624: LIST
55625: LIST
55626: PUSH
55627: LD_VAR 0 1
55631: PUSH
55632: LD_INT 4
55634: PLUS
55635: PUSH
55636: LD_VAR 0 2
55640: PUSH
55641: LD_INT 4
55643: PLUS
55644: PUSH
55645: LD_INT 5
55647: PUSH
55648: EMPTY
55649: LIST
55650: LIST
55651: LIST
55652: PUSH
55653: LD_VAR 0 1
55657: PUSH
55658: LD_INT 3
55660: PLUS
55661: PUSH
55662: LD_VAR 0 2
55666: PUSH
55667: LD_INT 4
55669: PUSH
55670: EMPTY
55671: LIST
55672: LIST
55673: LIST
55674: PUSH
55675: LD_VAR 0 1
55679: PUSH
55680: LD_VAR 0 2
55684: PUSH
55685: LD_INT 3
55687: PLUS
55688: PUSH
55689: LD_INT 0
55691: PUSH
55692: EMPTY
55693: LIST
55694: LIST
55695: LIST
55696: PUSH
55697: EMPTY
55698: LIST
55699: LIST
55700: LIST
55701: LIST
55702: LIST
55703: ST_TO_ADDR
// end ; end ;
55704: GO 55707
55706: POP
// result := list ;
55707: LD_ADDR_VAR 0 4
55711: PUSH
55712: LD_VAR 0 5
55716: ST_TO_ADDR
// end ;
55717: LD_VAR 0 4
55721: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
55722: LD_INT 0
55724: PPUSH
55725: PPUSH
55726: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
55727: LD_VAR 0 1
55731: NOT
55732: PUSH
55733: LD_VAR 0 2
55737: PUSH
55738: LD_INT 1
55740: PUSH
55741: LD_INT 2
55743: PUSH
55744: LD_INT 3
55746: PUSH
55747: LD_INT 4
55749: PUSH
55750: EMPTY
55751: LIST
55752: LIST
55753: LIST
55754: LIST
55755: IN
55756: NOT
55757: OR
55758: IFFALSE 55762
// exit ;
55760: GO 55845
// tmp := [ ] ;
55762: LD_ADDR_VAR 0 5
55766: PUSH
55767: EMPTY
55768: ST_TO_ADDR
// for i in units do
55769: LD_ADDR_VAR 0 4
55773: PUSH
55774: LD_VAR 0 1
55778: PUSH
55779: FOR_IN
55780: IFFALSE 55814
// tmp := Join ( tmp , GetSkill ( i , class ) ) ;
55782: LD_ADDR_VAR 0 5
55786: PUSH
55787: LD_VAR 0 5
55791: PPUSH
55792: LD_VAR 0 4
55796: PPUSH
55797: LD_VAR 0 2
55801: PPUSH
55802: CALL_OW 259
55806: PPUSH
55807: CALL 57205 0 2
55811: ST_TO_ADDR
55812: GO 55779
55814: POP
55815: POP
// if not tmp then
55816: LD_VAR 0 5
55820: NOT
55821: IFFALSE 55825
// exit ;
55823: GO 55845
// result := SortListByListDesc ( units , tmp ) ;
55825: LD_ADDR_VAR 0 3
55829: PUSH
55830: LD_VAR 0 1
55834: PPUSH
55835: LD_VAR 0 5
55839: PPUSH
55840: CALL_OW 77
55844: ST_TO_ADDR
// end ;
55845: LD_VAR 0 3
55849: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
55850: LD_INT 0
55852: PPUSH
55853: PPUSH
55854: PPUSH
// result := false ;
55855: LD_ADDR_VAR 0 3
55859: PUSH
55860: LD_INT 0
55862: ST_TO_ADDR
// if not building then
55863: LD_VAR 0 2
55867: NOT
55868: IFFALSE 55872
// exit ;
55870: GO 56010
// x := GetX ( building ) ;
55872: LD_ADDR_VAR 0 4
55876: PUSH
55877: LD_VAR 0 2
55881: PPUSH
55882: CALL_OW 250
55886: ST_TO_ADDR
// y := GetY ( building ) ;
55887: LD_ADDR_VAR 0 5
55891: PUSH
55892: LD_VAR 0 2
55896: PPUSH
55897: CALL_OW 251
55901: ST_TO_ADDR
// if not x or not y then
55902: LD_VAR 0 4
55906: NOT
55907: PUSH
55908: LD_VAR 0 5
55912: NOT
55913: OR
55914: IFFALSE 55918
// exit ;
55916: GO 56010
// if GetTaskList ( unit ) then
55918: LD_VAR 0 1
55922: PPUSH
55923: CALL_OW 437
55927: IFFALSE 56010
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
55929: LD_STRING e
55931: PUSH
55932: LD_VAR 0 1
55936: PPUSH
55937: CALL_OW 437
55941: PUSH
55942: LD_INT 1
55944: ARRAY
55945: PUSH
55946: LD_INT 1
55948: ARRAY
55949: EQUAL
55950: PUSH
55951: LD_VAR 0 4
55955: PUSH
55956: LD_VAR 0 1
55960: PPUSH
55961: CALL_OW 437
55965: PUSH
55966: LD_INT 1
55968: ARRAY
55969: PUSH
55970: LD_INT 2
55972: ARRAY
55973: EQUAL
55974: AND
55975: PUSH
55976: LD_VAR 0 5
55980: PUSH
55981: LD_VAR 0 1
55985: PPUSH
55986: CALL_OW 437
55990: PUSH
55991: LD_INT 1
55993: ARRAY
55994: PUSH
55995: LD_INT 3
55997: ARRAY
55998: EQUAL
55999: AND
56000: IFFALSE 56010
// result := true end ;
56002: LD_ADDR_VAR 0 3
56006: PUSH
56007: LD_INT 1
56009: ST_TO_ADDR
// end ;
56010: LD_VAR 0 3
56014: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
56015: LD_INT 0
56017: PPUSH
// result := false ;
56018: LD_ADDR_VAR 0 4
56022: PUSH
56023: LD_INT 0
56025: ST_TO_ADDR
// if GetTaskList ( unit ) then
56026: LD_VAR 0 1
56030: PPUSH
56031: CALL_OW 437
56035: IFFALSE 56118
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
56037: LD_STRING M
56039: PUSH
56040: LD_VAR 0 1
56044: PPUSH
56045: CALL_OW 437
56049: PUSH
56050: LD_INT 1
56052: ARRAY
56053: PUSH
56054: LD_INT 1
56056: ARRAY
56057: EQUAL
56058: PUSH
56059: LD_VAR 0 2
56063: PUSH
56064: LD_VAR 0 1
56068: PPUSH
56069: CALL_OW 437
56073: PUSH
56074: LD_INT 1
56076: ARRAY
56077: PUSH
56078: LD_INT 2
56080: ARRAY
56081: EQUAL
56082: AND
56083: PUSH
56084: LD_VAR 0 3
56088: PUSH
56089: LD_VAR 0 1
56093: PPUSH
56094: CALL_OW 437
56098: PUSH
56099: LD_INT 1
56101: ARRAY
56102: PUSH
56103: LD_INT 3
56105: ARRAY
56106: EQUAL
56107: AND
56108: IFFALSE 56118
// result := true ;
56110: LD_ADDR_VAR 0 4
56114: PUSH
56115: LD_INT 1
56117: ST_TO_ADDR
// end ; end ;
56118: LD_VAR 0 4
56122: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
56123: LD_INT 0
56125: PPUSH
56126: PPUSH
56127: PPUSH
56128: PPUSH
// if not unit or not area then
56129: LD_VAR 0 1
56133: NOT
56134: PUSH
56135: LD_VAR 0 2
56139: NOT
56140: OR
56141: IFFALSE 56145
// exit ;
56143: GO 56308
// tmp := AreaToList ( area , i ) ;
56145: LD_ADDR_VAR 0 6
56149: PUSH
56150: LD_VAR 0 2
56154: PPUSH
56155: LD_VAR 0 5
56159: PPUSH
56160: CALL_OW 517
56164: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
56165: LD_ADDR_VAR 0 5
56169: PUSH
56170: DOUBLE
56171: LD_INT 1
56173: DEC
56174: ST_TO_ADDR
56175: LD_VAR 0 6
56179: PUSH
56180: LD_INT 1
56182: ARRAY
56183: PUSH
56184: FOR_TO
56185: IFFALSE 56306
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
56187: LD_ADDR_VAR 0 7
56191: PUSH
56192: LD_VAR 0 6
56196: PUSH
56197: LD_INT 1
56199: ARRAY
56200: PUSH
56201: LD_VAR 0 5
56205: ARRAY
56206: PUSH
56207: LD_VAR 0 6
56211: PUSH
56212: LD_INT 2
56214: ARRAY
56215: PUSH
56216: LD_VAR 0 5
56220: ARRAY
56221: PUSH
56222: EMPTY
56223: LIST
56224: LIST
56225: ST_TO_ADDR
// if FilterAllUnits ( [ f_distxy , hex [ 1 ] , hex [ 2 ] , 3 ] ) = 0 then
56226: LD_INT 92
56228: PUSH
56229: LD_VAR 0 7
56233: PUSH
56234: LD_INT 1
56236: ARRAY
56237: PUSH
56238: LD_VAR 0 7
56242: PUSH
56243: LD_INT 2
56245: ARRAY
56246: PUSH
56247: LD_INT 3
56249: PUSH
56250: EMPTY
56251: LIST
56252: LIST
56253: LIST
56254: LIST
56255: PPUSH
56256: CALL_OW 69
56260: PUSH
56261: LD_INT 0
56263: EQUAL
56264: IFFALSE 56304
// begin PlaceUnitArea ( unit , area , mode ) ;
56266: LD_VAR 0 1
56270: PPUSH
56271: LD_VAR 0 2
56275: PPUSH
56276: LD_VAR 0 3
56280: PPUSH
56281: CALL_OW 49
// result := IsPlaced ( unit ) ;
56285: LD_ADDR_VAR 0 4
56289: PUSH
56290: LD_VAR 0 1
56294: PPUSH
56295: CALL_OW 305
56299: ST_TO_ADDR
// exit ;
56300: POP
56301: POP
56302: GO 56308
// end ; end ;
56304: GO 56184
56306: POP
56307: POP
// end ;
56308: LD_VAR 0 4
56312: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
56313: LD_INT 0
56315: PPUSH
56316: PPUSH
56317: PPUSH
// if not side or side > 8 then
56318: LD_VAR 0 1
56322: NOT
56323: PUSH
56324: LD_VAR 0 1
56328: PUSH
56329: LD_INT 8
56331: GREATER
56332: OR
56333: IFFALSE 56337
// exit ;
56335: GO 56524
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
56337: LD_ADDR_VAR 0 4
56341: PUSH
56342: LD_INT 22
56344: PUSH
56345: LD_VAR 0 1
56349: PUSH
56350: EMPTY
56351: LIST
56352: LIST
56353: PUSH
56354: LD_INT 21
56356: PUSH
56357: LD_INT 3
56359: PUSH
56360: EMPTY
56361: LIST
56362: LIST
56363: PUSH
56364: EMPTY
56365: LIST
56366: LIST
56367: PPUSH
56368: CALL_OW 69
56372: ST_TO_ADDR
// if not tmp then
56373: LD_VAR 0 4
56377: NOT
56378: IFFALSE 56382
// exit ;
56380: GO 56524
// enable_addtolog := true ;
56382: LD_ADDR_OWVAR 81
56386: PUSH
56387: LD_INT 1
56389: ST_TO_ADDR
// AddToLog ( [ ) ;
56390: LD_STRING [
56392: PPUSH
56393: CALL_OW 561
// for i in tmp do
56397: LD_ADDR_VAR 0 3
56401: PUSH
56402: LD_VAR 0 4
56406: PUSH
56407: FOR_IN
56408: IFFALSE 56515
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
56410: LD_STRING [
56412: PUSH
56413: LD_VAR 0 3
56417: PPUSH
56418: CALL_OW 266
56422: STR
56423: PUSH
56424: LD_STRING , 
56426: STR
56427: PUSH
56428: LD_VAR 0 3
56432: PPUSH
56433: CALL_OW 250
56437: STR
56438: PUSH
56439: LD_STRING , 
56441: STR
56442: PUSH
56443: LD_VAR 0 3
56447: PPUSH
56448: CALL_OW 251
56452: STR
56453: PUSH
56454: LD_STRING , 
56456: STR
56457: PUSH
56458: LD_VAR 0 3
56462: PPUSH
56463: CALL_OW 254
56467: STR
56468: PUSH
56469: LD_STRING , 
56471: STR
56472: PUSH
56473: LD_VAR 0 3
56477: PPUSH
56478: LD_INT 1
56480: PPUSH
56481: CALL_OW 268
56485: STR
56486: PUSH
56487: LD_STRING , 
56489: STR
56490: PUSH
56491: LD_VAR 0 3
56495: PPUSH
56496: LD_INT 2
56498: PPUSH
56499: CALL_OW 268
56503: STR
56504: PUSH
56505: LD_STRING ],
56507: STR
56508: PPUSH
56509: CALL_OW 561
// end ;
56513: GO 56407
56515: POP
56516: POP
// AddToLog ( ]; ) ;
56517: LD_STRING ];
56519: PPUSH
56520: CALL_OW 561
// end ;
56524: LD_VAR 0 2
56528: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
56529: LD_INT 0
56531: PPUSH
56532: PPUSH
56533: PPUSH
56534: PPUSH
56535: PPUSH
// if not area or not rate or not max then
56536: LD_VAR 0 1
56540: NOT
56541: PUSH
56542: LD_VAR 0 2
56546: NOT
56547: OR
56548: PUSH
56549: LD_VAR 0 4
56553: NOT
56554: OR
56555: IFFALSE 56559
// exit ;
56557: GO 56748
// while 1 do
56559: LD_INT 1
56561: IFFALSE 56748
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
56563: LD_ADDR_VAR 0 9
56567: PUSH
56568: LD_VAR 0 1
56572: PPUSH
56573: LD_INT 1
56575: PPUSH
56576: CALL_OW 287
56580: PUSH
56581: LD_INT 10
56583: MUL
56584: ST_TO_ADDR
// r := rate / 10 ;
56585: LD_ADDR_VAR 0 7
56589: PUSH
56590: LD_VAR 0 2
56594: PUSH
56595: LD_INT 10
56597: DIVREAL
56598: ST_TO_ADDR
// time := 1 1$00 ;
56599: LD_ADDR_VAR 0 8
56603: PUSH
56604: LD_INT 2100
56606: ST_TO_ADDR
// if amount < min then
56607: LD_VAR 0 9
56611: PUSH
56612: LD_VAR 0 3
56616: LESS
56617: IFFALSE 56635
// r := r * 2 else
56619: LD_ADDR_VAR 0 7
56623: PUSH
56624: LD_VAR 0 7
56628: PUSH
56629: LD_INT 2
56631: MUL
56632: ST_TO_ADDR
56633: GO 56661
// if amount > max then
56635: LD_VAR 0 9
56639: PUSH
56640: LD_VAR 0 4
56644: GREATER
56645: IFFALSE 56661
// r := r / 2 ;
56647: LD_ADDR_VAR 0 7
56651: PUSH
56652: LD_VAR 0 7
56656: PUSH
56657: LD_INT 2
56659: DIVREAL
56660: ST_TO_ADDR
// time := time / r ;
56661: LD_ADDR_VAR 0 8
56665: PUSH
56666: LD_VAR 0 8
56670: PUSH
56671: LD_VAR 0 7
56675: DIVREAL
56676: ST_TO_ADDR
// if time < 0 then
56677: LD_VAR 0 8
56681: PUSH
56682: LD_INT 0
56684: LESS
56685: IFFALSE 56702
// time := time * - 1 ;
56687: LD_ADDR_VAR 0 8
56691: PUSH
56692: LD_VAR 0 8
56696: PUSH
56697: LD_INT 1
56699: NEG
56700: MUL
56701: ST_TO_ADDR
// wait ( time + rand ( 0 0$01 , 0 0$25 ) ) ;
56702: LD_VAR 0 8
56706: PUSH
56707: LD_INT 35
56709: PPUSH
56710: LD_INT 875
56712: PPUSH
56713: CALL_OW 12
56717: PLUS
56718: PPUSH
56719: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
56723: LD_INT 1
56725: PPUSH
56726: LD_INT 5
56728: PPUSH
56729: CALL_OW 12
56733: PPUSH
56734: LD_VAR 0 1
56738: PPUSH
56739: LD_INT 1
56741: PPUSH
56742: CALL_OW 55
// end ;
56746: GO 56559
// end ;
56748: LD_VAR 0 5
56752: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
56753: LD_INT 0
56755: PPUSH
56756: PPUSH
56757: PPUSH
56758: PPUSH
56759: PPUSH
56760: PPUSH
56761: PPUSH
56762: PPUSH
// if not turrets or not factories then
56763: LD_VAR 0 1
56767: NOT
56768: PUSH
56769: LD_VAR 0 2
56773: NOT
56774: OR
56775: IFFALSE 56779
// exit ;
56777: GO 57086
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
56779: LD_ADDR_VAR 0 10
56783: PUSH
56784: LD_INT 5
56786: PUSH
56787: LD_INT 6
56789: PUSH
56790: EMPTY
56791: LIST
56792: LIST
56793: PUSH
56794: LD_INT 2
56796: PUSH
56797: LD_INT 4
56799: PUSH
56800: EMPTY
56801: LIST
56802: LIST
56803: PUSH
56804: LD_INT 3
56806: PUSH
56807: LD_INT 5
56809: PUSH
56810: EMPTY
56811: LIST
56812: LIST
56813: PUSH
56814: EMPTY
56815: LIST
56816: LIST
56817: LIST
56818: PUSH
56819: LD_INT 24
56821: PUSH
56822: LD_INT 25
56824: PUSH
56825: EMPTY
56826: LIST
56827: LIST
56828: PUSH
56829: LD_INT 23
56831: PUSH
56832: LD_INT 27
56834: PUSH
56835: EMPTY
56836: LIST
56837: LIST
56838: PUSH
56839: EMPTY
56840: LIST
56841: LIST
56842: PUSH
56843: LD_INT 42
56845: PUSH
56846: LD_INT 43
56848: PUSH
56849: EMPTY
56850: LIST
56851: LIST
56852: PUSH
56853: LD_INT 44
56855: PUSH
56856: LD_INT 46
56858: PUSH
56859: EMPTY
56860: LIST
56861: LIST
56862: PUSH
56863: LD_INT 45
56865: PUSH
56866: LD_INT 47
56868: PUSH
56869: EMPTY
56870: LIST
56871: LIST
56872: PUSH
56873: EMPTY
56874: LIST
56875: LIST
56876: LIST
56877: PUSH
56878: EMPTY
56879: LIST
56880: LIST
56881: LIST
56882: ST_TO_ADDR
// result := [ ] ;
56883: LD_ADDR_VAR 0 3
56887: PUSH
56888: EMPTY
56889: ST_TO_ADDR
// for i in turrets do
56890: LD_ADDR_VAR 0 4
56894: PUSH
56895: LD_VAR 0 1
56899: PUSH
56900: FOR_IN
56901: IFFALSE 57084
// begin nat := GetNation ( i ) ;
56903: LD_ADDR_VAR 0 7
56907: PUSH
56908: LD_VAR 0 4
56912: PPUSH
56913: CALL_OW 248
56917: ST_TO_ADDR
// weapon := 0 ;
56918: LD_ADDR_VAR 0 8
56922: PUSH
56923: LD_INT 0
56925: ST_TO_ADDR
// if not nat then
56926: LD_VAR 0 7
56930: NOT
56931: IFFALSE 56935
// continue ;
56933: GO 56900
// for j in list [ nat ] do
56935: LD_ADDR_VAR 0 5
56939: PUSH
56940: LD_VAR 0 10
56944: PUSH
56945: LD_VAR 0 7
56949: ARRAY
56950: PUSH
56951: FOR_IN
56952: IFFALSE 56993
// if GetBWeapon ( i ) = j [ 1 ] then
56954: LD_VAR 0 4
56958: PPUSH
56959: CALL_OW 269
56963: PUSH
56964: LD_VAR 0 5
56968: PUSH
56969: LD_INT 1
56971: ARRAY
56972: EQUAL
56973: IFFALSE 56991
// begin weapon := j [ 2 ] ;
56975: LD_ADDR_VAR 0 8
56979: PUSH
56980: LD_VAR 0 5
56984: PUSH
56985: LD_INT 2
56987: ARRAY
56988: ST_TO_ADDR
// break ;
56989: GO 56993
// end ;
56991: GO 56951
56993: POP
56994: POP
// if not weapon then
56995: LD_VAR 0 8
56999: NOT
57000: IFFALSE 57004
// continue ;
57002: GO 56900
// for k in factories do
57004: LD_ADDR_VAR 0 6
57008: PUSH
57009: LD_VAR 0 2
57013: PUSH
57014: FOR_IN
57015: IFFALSE 57080
// begin weapons := AvailableWeaponList ( k ) ;
57017: LD_ADDR_VAR 0 9
57021: PUSH
57022: LD_VAR 0 6
57026: PPUSH
57027: CALL_OW 478
57031: ST_TO_ADDR
// if not weapons then
57032: LD_VAR 0 9
57036: NOT
57037: IFFALSE 57041
// continue ;
57039: GO 57014
// if weapon in weapons then
57041: LD_VAR 0 8
57045: PUSH
57046: LD_VAR 0 9
57050: IN
57051: IFFALSE 57078
// begin result := [ i , weapon ] ;
57053: LD_ADDR_VAR 0 3
57057: PUSH
57058: LD_VAR 0 4
57062: PUSH
57063: LD_VAR 0 8
57067: PUSH
57068: EMPTY
57069: LIST
57070: LIST
57071: ST_TO_ADDR
// exit ;
57072: POP
57073: POP
57074: POP
57075: POP
57076: GO 57086
// end ; end ;
57078: GO 57014
57080: POP
57081: POP
// end ;
57082: GO 56900
57084: POP
57085: POP
// end ;
57086: LD_VAR 0 3
57090: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
57091: LD_INT 0
57093: PPUSH
// if not side or side > 8 then
57094: LD_VAR 0 3
57098: NOT
57099: PUSH
57100: LD_VAR 0 3
57104: PUSH
57105: LD_INT 8
57107: GREATER
57108: OR
57109: IFFALSE 57113
// exit ;
57111: GO 57172
// if not range then
57113: LD_VAR 0 4
57117: NOT
57118: IFFALSE 57129
// range := - 12 ;
57120: LD_ADDR_VAR 0 4
57124: PUSH
57125: LD_INT 12
57127: NEG
57128: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
57129: LD_VAR 0 1
57133: PPUSH
57134: LD_VAR 0 2
57138: PPUSH
57139: LD_VAR 0 3
57143: PPUSH
57144: LD_VAR 0 4
57148: PPUSH
57149: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
57153: LD_VAR 0 1
57157: PPUSH
57158: LD_VAR 0 2
57162: PPUSH
57163: LD_VAR 0 3
57167: PPUSH
57168: CALL_OW 331
// end ;
57172: LD_VAR 0 5
57176: RET
// export function Video ( mode ) ; begin
57177: LD_INT 0
57179: PPUSH
// ingame_video = mode ;
57180: LD_ADDR_OWVAR 52
57184: PUSH
57185: LD_VAR 0 1
57189: ST_TO_ADDR
// interface_hidden = mode ;
57190: LD_ADDR_OWVAR 54
57194: PUSH
57195: LD_VAR 0 1
57199: ST_TO_ADDR
// end ;
57200: LD_VAR 0 2
57204: RET
// export function Join ( array , element ) ; begin
57205: LD_INT 0
57207: PPUSH
// result := Replace ( array , array + 1 , element ) ;
57208: LD_ADDR_VAR 0 3
57212: PUSH
57213: LD_VAR 0 1
57217: PPUSH
57218: LD_VAR 0 1
57222: PUSH
57223: LD_INT 1
57225: PLUS
57226: PPUSH
57227: LD_VAR 0 2
57231: PPUSH
57232: CALL_OW 1
57236: ST_TO_ADDR
// end ;
57237: LD_VAR 0 3
57241: RET
// export function JoinUnion ( array , element ) ; begin
57242: LD_INT 0
57244: PPUSH
// result := array union element ;
57245: LD_ADDR_VAR 0 3
57249: PUSH
57250: LD_VAR 0 1
57254: PUSH
57255: LD_VAR 0 2
57259: UNION
57260: ST_TO_ADDR
// end ;
57261: LD_VAR 0 3
57265: RET
// export function GetBehemoths ( side ) ; begin
57266: LD_INT 0
57268: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , ru_behemoth ] ] ) ;
57269: LD_ADDR_VAR 0 2
57273: PUSH
57274: LD_INT 22
57276: PUSH
57277: LD_VAR 0 1
57281: PUSH
57282: EMPTY
57283: LIST
57284: LIST
57285: PUSH
57286: LD_INT 31
57288: PUSH
57289: LD_INT 25
57291: PUSH
57292: EMPTY
57293: LIST
57294: LIST
57295: PUSH
57296: EMPTY
57297: LIST
57298: LIST
57299: PPUSH
57300: CALL_OW 69
57304: ST_TO_ADDR
// end ;
57305: LD_VAR 0 2
57309: RET
// export function Shuffle ( array ) ; var i , index ; begin
57310: LD_INT 0
57312: PPUSH
57313: PPUSH
57314: PPUSH
// result := [ ] ;
57315: LD_ADDR_VAR 0 2
57319: PUSH
57320: EMPTY
57321: ST_TO_ADDR
// if not array then
57322: LD_VAR 0 1
57326: NOT
57327: IFFALSE 57331
// exit ;
57329: GO 57430
// Randomize ;
57331: CALL_OW 10
// for i = array downto 1 do
57335: LD_ADDR_VAR 0 3
57339: PUSH
57340: DOUBLE
57341: LD_VAR 0 1
57345: INC
57346: ST_TO_ADDR
57347: LD_INT 1
57349: PUSH
57350: FOR_DOWNTO
57351: IFFALSE 57428
// begin index := rand ( 1 , array ) ;
57353: LD_ADDR_VAR 0 4
57357: PUSH
57358: LD_INT 1
57360: PPUSH
57361: LD_VAR 0 1
57365: PPUSH
57366: CALL_OW 12
57370: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
57371: LD_ADDR_VAR 0 2
57375: PUSH
57376: LD_VAR 0 2
57380: PPUSH
57381: LD_VAR 0 2
57385: PUSH
57386: LD_INT 1
57388: PLUS
57389: PPUSH
57390: LD_VAR 0 1
57394: PUSH
57395: LD_VAR 0 4
57399: ARRAY
57400: PPUSH
57401: CALL_OW 2
57405: ST_TO_ADDR
// array := Delete ( array , index ) ;
57406: LD_ADDR_VAR 0 1
57410: PUSH
57411: LD_VAR 0 1
57415: PPUSH
57416: LD_VAR 0 4
57420: PPUSH
57421: CALL_OW 3
57425: ST_TO_ADDR
// end ;
57426: GO 57350
57428: POP
57429: POP
// end ;
57430: LD_VAR 0 2
57434: RET
// export function GetBaseMaterials ( base ) ; begin
57435: LD_INT 0
57437: PPUSH
// result := [ 0 , 0 , 0 ] ;
57438: LD_ADDR_VAR 0 2
57442: PUSH
57443: LD_INT 0
57445: PUSH
57446: LD_INT 0
57448: PUSH
57449: LD_INT 0
57451: PUSH
57452: EMPTY
57453: LIST
57454: LIST
57455: LIST
57456: ST_TO_ADDR
// if not base then
57457: LD_VAR 0 1
57461: NOT
57462: IFFALSE 57466
// exit ;
57464: GO 57515
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
57466: LD_ADDR_VAR 0 2
57470: PUSH
57471: LD_VAR 0 1
57475: PPUSH
57476: LD_INT 1
57478: PPUSH
57479: CALL_OW 275
57483: PUSH
57484: LD_VAR 0 1
57488: PPUSH
57489: LD_INT 2
57491: PPUSH
57492: CALL_OW 275
57496: PUSH
57497: LD_VAR 0 1
57501: PPUSH
57502: LD_INT 3
57504: PPUSH
57505: CALL_OW 275
57509: PUSH
57510: EMPTY
57511: LIST
57512: LIST
57513: LIST
57514: ST_TO_ADDR
// end ;
57515: LD_VAR 0 2
57519: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
57520: LD_INT 0
57522: PPUSH
57523: PPUSH
// result := array ;
57524: LD_ADDR_VAR 0 3
57528: PUSH
57529: LD_VAR 0 1
57533: ST_TO_ADDR
// if size >= result then
57534: LD_VAR 0 2
57538: PUSH
57539: LD_VAR 0 3
57543: GREATEREQUAL
57544: IFFALSE 57548
// exit ;
57546: GO 57598
// if size then
57548: LD_VAR 0 2
57552: IFFALSE 57598
// for i := array downto size do
57554: LD_ADDR_VAR 0 4
57558: PUSH
57559: DOUBLE
57560: LD_VAR 0 1
57564: INC
57565: ST_TO_ADDR
57566: LD_VAR 0 2
57570: PUSH
57571: FOR_DOWNTO
57572: IFFALSE 57596
// result := Delete ( result , result ) ;
57574: LD_ADDR_VAR 0 3
57578: PUSH
57579: LD_VAR 0 3
57583: PPUSH
57584: LD_VAR 0 3
57588: PPUSH
57589: CALL_OW 3
57593: ST_TO_ADDR
57594: GO 57571
57596: POP
57597: POP
// end ;
57598: LD_VAR 0 3
57602: RET
// export function ComExit ( unit ) ; var tmp ; begin
57603: LD_INT 0
57605: PPUSH
57606: PPUSH
// if not IsInUnit ( unit ) then
57607: LD_VAR 0 1
57611: PPUSH
57612: CALL_OW 310
57616: NOT
57617: IFFALSE 57621
// exit ;
57619: GO 57681
// tmp := IsInUnit ( unit ) ;
57621: LD_ADDR_VAR 0 3
57625: PUSH
57626: LD_VAR 0 1
57630: PPUSH
57631: CALL_OW 310
57635: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
57636: LD_VAR 0 3
57640: PPUSH
57641: CALL_OW 247
57645: PUSH
57646: LD_INT 2
57648: EQUAL
57649: IFFALSE 57662
// ComExitVehicle ( unit ) else
57651: LD_VAR 0 1
57655: PPUSH
57656: CALL_OW 121
57660: GO 57671
// ComExitBuilding ( unit ) ;
57662: LD_VAR 0 1
57666: PPUSH
57667: CALL_OW 122
// result := tmp ;
57671: LD_ADDR_VAR 0 2
57675: PUSH
57676: LD_VAR 0 3
57680: ST_TO_ADDR
// end ;
57681: LD_VAR 0 2
57685: RET
// export function ComExitAll ( units ) ; var i ; begin
57686: LD_INT 0
57688: PPUSH
57689: PPUSH
// if not units then
57690: LD_VAR 0 1
57694: NOT
57695: IFFALSE 57699
// exit ;
57697: GO 57725
// for i in units do
57699: LD_ADDR_VAR 0 3
57703: PUSH
57704: LD_VAR 0 1
57708: PUSH
57709: FOR_IN
57710: IFFALSE 57723
// ComExit ( i ) ;
57712: LD_VAR 0 3
57716: PPUSH
57717: CALL 57603 0 1
57721: GO 57709
57723: POP
57724: POP
// end ;
57725: LD_VAR 0 2
57729: RET
// export function ResetHc ; begin
57730: LD_INT 0
57732: PPUSH
// InitHc ;
57733: CALL_OW 19
// hc_importance := 0 ;
57737: LD_ADDR_OWVAR 32
57741: PUSH
57742: LD_INT 0
57744: ST_TO_ADDR
// end ;
57745: LD_VAR 0 1
57749: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
57750: LD_INT 0
57752: PPUSH
57753: PPUSH
57754: PPUSH
// _x := ( x1 + x2 ) div 2 ;
57755: LD_ADDR_VAR 0 6
57759: PUSH
57760: LD_VAR 0 1
57764: PUSH
57765: LD_VAR 0 3
57769: PLUS
57770: PUSH
57771: LD_INT 2
57773: DIV
57774: ST_TO_ADDR
// if _x < 0 then
57775: LD_VAR 0 6
57779: PUSH
57780: LD_INT 0
57782: LESS
57783: IFFALSE 57800
// _x := _x * - 1 ;
57785: LD_ADDR_VAR 0 6
57789: PUSH
57790: LD_VAR 0 6
57794: PUSH
57795: LD_INT 1
57797: NEG
57798: MUL
57799: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
57800: LD_ADDR_VAR 0 7
57804: PUSH
57805: LD_VAR 0 2
57809: PUSH
57810: LD_VAR 0 4
57814: PLUS
57815: PUSH
57816: LD_INT 2
57818: DIV
57819: ST_TO_ADDR
// if _y < 0 then
57820: LD_VAR 0 7
57824: PUSH
57825: LD_INT 0
57827: LESS
57828: IFFALSE 57845
// _y := _y * - 1 ;
57830: LD_ADDR_VAR 0 7
57834: PUSH
57835: LD_VAR 0 7
57839: PUSH
57840: LD_INT 1
57842: NEG
57843: MUL
57844: ST_TO_ADDR
// result := [ _x , _y ] ;
57845: LD_ADDR_VAR 0 5
57849: PUSH
57850: LD_VAR 0 6
57854: PUSH
57855: LD_VAR 0 7
57859: PUSH
57860: EMPTY
57861: LIST
57862: LIST
57863: ST_TO_ADDR
// end ;
57864: LD_VAR 0 5
57868: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
57869: LD_INT 0
57871: PPUSH
57872: PPUSH
57873: PPUSH
57874: PPUSH
// task := GetTaskList ( unit ) ;
57875: LD_ADDR_VAR 0 7
57879: PUSH
57880: LD_VAR 0 1
57884: PPUSH
57885: CALL_OW 437
57889: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
57890: LD_VAR 0 7
57894: NOT
57895: PUSH
57896: LD_VAR 0 1
57900: PPUSH
57901: LD_VAR 0 2
57905: PPUSH
57906: CALL_OW 308
57910: NOT
57911: AND
57912: IFFALSE 57916
// exit ;
57914: GO 58034
// if IsInArea ( unit , area ) then
57916: LD_VAR 0 1
57920: PPUSH
57921: LD_VAR 0 2
57925: PPUSH
57926: CALL_OW 308
57930: IFFALSE 57948
// begin ComMoveToArea ( unit , goAway ) ;
57932: LD_VAR 0 1
57936: PPUSH
57937: LD_VAR 0 3
57941: PPUSH
57942: CALL_OW 113
// exit ;
57946: GO 58034
// end ; if task [ 1 ] [ 1 ] <> M then
57948: LD_VAR 0 7
57952: PUSH
57953: LD_INT 1
57955: ARRAY
57956: PUSH
57957: LD_INT 1
57959: ARRAY
57960: PUSH
57961: LD_STRING M
57963: NONEQUAL
57964: IFFALSE 57968
// exit ;
57966: GO 58034
// x := task [ 1 ] [ 2 ] ;
57968: LD_ADDR_VAR 0 5
57972: PUSH
57973: LD_VAR 0 7
57977: PUSH
57978: LD_INT 1
57980: ARRAY
57981: PUSH
57982: LD_INT 2
57984: ARRAY
57985: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
57986: LD_ADDR_VAR 0 6
57990: PUSH
57991: LD_VAR 0 7
57995: PUSH
57996: LD_INT 1
57998: ARRAY
57999: PUSH
58000: LD_INT 3
58002: ARRAY
58003: ST_TO_ADDR
// if InArea ( x , y , area ) then
58004: LD_VAR 0 5
58008: PPUSH
58009: LD_VAR 0 6
58013: PPUSH
58014: LD_VAR 0 2
58018: PPUSH
58019: CALL_OW 309
58023: IFFALSE 58034
// ComStop ( unit ) ;
58025: LD_VAR 0 1
58029: PPUSH
58030: CALL_OW 141
// end ;
58034: LD_VAR 0 4
58038: RET
// export function Abs ( value ) ; begin
58039: LD_INT 0
58041: PPUSH
// result := value ;
58042: LD_ADDR_VAR 0 2
58046: PUSH
58047: LD_VAR 0 1
58051: ST_TO_ADDR
// if value < 0 then
58052: LD_VAR 0 1
58056: PUSH
58057: LD_INT 0
58059: LESS
58060: IFFALSE 58077
// result := value * - 1 ;
58062: LD_ADDR_VAR 0 2
58066: PUSH
58067: LD_VAR 0 1
58071: PUSH
58072: LD_INT 1
58074: NEG
58075: MUL
58076: ST_TO_ADDR
// end ;
58077: LD_VAR 0 2
58081: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
58082: LD_INT 0
58084: PPUSH
58085: PPUSH
58086: PPUSH
58087: PPUSH
58088: PPUSH
58089: PPUSH
58090: PPUSH
58091: PPUSH
// if not unit or not building then
58092: LD_VAR 0 1
58096: NOT
58097: PUSH
58098: LD_VAR 0 2
58102: NOT
58103: OR
58104: IFFALSE 58108
// exit ;
58106: GO 58334
// x := GetX ( building ) ;
58108: LD_ADDR_VAR 0 4
58112: PUSH
58113: LD_VAR 0 2
58117: PPUSH
58118: CALL_OW 250
58122: ST_TO_ADDR
// y := GetY ( building ) ;
58123: LD_ADDR_VAR 0 6
58127: PUSH
58128: LD_VAR 0 2
58132: PPUSH
58133: CALL_OW 251
58137: ST_TO_ADDR
// d := GetDir ( building ) ;
58138: LD_ADDR_VAR 0 8
58142: PUSH
58143: LD_VAR 0 2
58147: PPUSH
58148: CALL_OW 254
58152: ST_TO_ADDR
// r := 4 ;
58153: LD_ADDR_VAR 0 9
58157: PUSH
58158: LD_INT 4
58160: ST_TO_ADDR
// for i := 1 to 5 do
58161: LD_ADDR_VAR 0 10
58165: PUSH
58166: DOUBLE
58167: LD_INT 1
58169: DEC
58170: ST_TO_ADDR
58171: LD_INT 5
58173: PUSH
58174: FOR_TO
58175: IFFALSE 58332
// begin _x := ShiftX ( x , d , r + i ) ;
58177: LD_ADDR_VAR 0 5
58181: PUSH
58182: LD_VAR 0 4
58186: PPUSH
58187: LD_VAR 0 8
58191: PPUSH
58192: LD_VAR 0 9
58196: PUSH
58197: LD_VAR 0 10
58201: PLUS
58202: PPUSH
58203: CALL_OW 272
58207: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
58208: LD_ADDR_VAR 0 7
58212: PUSH
58213: LD_VAR 0 6
58217: PPUSH
58218: LD_VAR 0 8
58222: PPUSH
58223: LD_VAR 0 9
58227: PUSH
58228: LD_VAR 0 10
58232: PLUS
58233: PPUSH
58234: CALL_OW 273
58238: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
58239: LD_VAR 0 5
58243: PPUSH
58244: LD_VAR 0 7
58248: PPUSH
58249: CALL_OW 488
58253: PUSH
58254: LD_VAR 0 5
58258: PPUSH
58259: LD_VAR 0 7
58263: PPUSH
58264: CALL_OW 428
58268: PPUSH
58269: CALL_OW 247
58273: PUSH
58274: LD_INT 3
58276: PUSH
58277: LD_INT 2
58279: PUSH
58280: EMPTY
58281: LIST
58282: LIST
58283: IN
58284: NOT
58285: AND
58286: IFFALSE 58330
// begin ComMoveXY ( unit , _x , _y ) ;
58288: LD_VAR 0 1
58292: PPUSH
58293: LD_VAR 0 5
58297: PPUSH
58298: LD_VAR 0 7
58302: PPUSH
58303: CALL_OW 111
// result := [ _x , _y ] ;
58307: LD_ADDR_VAR 0 3
58311: PUSH
58312: LD_VAR 0 5
58316: PUSH
58317: LD_VAR 0 7
58321: PUSH
58322: EMPTY
58323: LIST
58324: LIST
58325: ST_TO_ADDR
// exit ;
58326: POP
58327: POP
58328: GO 58334
// end ; end ;
58330: GO 58174
58332: POP
58333: POP
// end ;
58334: LD_VAR 0 3
58338: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
58339: LD_INT 0
58341: PPUSH
58342: PPUSH
58343: PPUSH
// result := 0 ;
58344: LD_ADDR_VAR 0 3
58348: PUSH
58349: LD_INT 0
58351: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
58352: LD_VAR 0 1
58356: PUSH
58357: LD_INT 0
58359: LESS
58360: PUSH
58361: LD_VAR 0 1
58365: PUSH
58366: LD_INT 8
58368: GREATER
58369: OR
58370: PUSH
58371: LD_VAR 0 2
58375: PUSH
58376: LD_INT 0
58378: LESS
58379: OR
58380: PUSH
58381: LD_VAR 0 2
58385: PUSH
58386: LD_INT 8
58388: GREATER
58389: OR
58390: IFFALSE 58394
// exit ;
58392: GO 58469
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
58394: LD_ADDR_VAR 0 4
58398: PUSH
58399: LD_INT 22
58401: PUSH
58402: LD_VAR 0 2
58406: PUSH
58407: EMPTY
58408: LIST
58409: LIST
58410: PPUSH
58411: CALL_OW 69
58415: PUSH
58416: FOR_IN
58417: IFFALSE 58467
// begin un := UnitShoot ( i ) ;
58419: LD_ADDR_VAR 0 5
58423: PUSH
58424: LD_VAR 0 4
58428: PPUSH
58429: CALL_OW 504
58433: ST_TO_ADDR
// if GetSide ( un ) = side1 then
58434: LD_VAR 0 5
58438: PPUSH
58439: CALL_OW 255
58443: PUSH
58444: LD_VAR 0 1
58448: EQUAL
58449: IFFALSE 58465
// begin result := un ;
58451: LD_ADDR_VAR 0 3
58455: PUSH
58456: LD_VAR 0 5
58460: ST_TO_ADDR
// exit ;
58461: POP
58462: POP
58463: GO 58469
// end ; end ;
58465: GO 58416
58467: POP
58468: POP
// end ;
58469: LD_VAR 0 3
58473: RET
// export function GetCargoBay ( units ) ; begin
58474: LD_INT 0
58476: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
58477: LD_ADDR_VAR 0 2
58481: PUSH
58482: LD_VAR 0 1
58486: PPUSH
58487: LD_INT 2
58489: PUSH
58490: LD_INT 34
58492: PUSH
58493: LD_INT 12
58495: PUSH
58496: EMPTY
58497: LIST
58498: LIST
58499: PUSH
58500: LD_INT 34
58502: PUSH
58503: LD_INT 51
58505: PUSH
58506: EMPTY
58507: LIST
58508: LIST
58509: PUSH
58510: LD_INT 34
58512: PUSH
58513: LD_INT 32
58515: PUSH
58516: EMPTY
58517: LIST
58518: LIST
58519: PUSH
58520: LD_INT 34
58522: PUSH
58523: LD_INT 89
58525: PUSH
58526: EMPTY
58527: LIST
58528: LIST
58529: PUSH
58530: EMPTY
58531: LIST
58532: LIST
58533: LIST
58534: LIST
58535: LIST
58536: PPUSH
58537: CALL_OW 72
58541: ST_TO_ADDR
// end ;
58542: LD_VAR 0 2
58546: RET
// export function Negate ( value ) ; begin
58547: LD_INT 0
58549: PPUSH
// result := not value ;
58550: LD_ADDR_VAR 0 2
58554: PUSH
58555: LD_VAR 0 1
58559: NOT
58560: ST_TO_ADDR
// end ;
58561: LD_VAR 0 2
58565: RET
// export function Inc ( value ) ; begin
58566: LD_INT 0
58568: PPUSH
// result := value + 1 ;
58569: LD_ADDR_VAR 0 2
58573: PUSH
58574: LD_VAR 0 1
58578: PUSH
58579: LD_INT 1
58581: PLUS
58582: ST_TO_ADDR
// end ;
58583: LD_VAR 0 2
58587: RET
// export function Dec ( value ) ; begin
58588: LD_INT 0
58590: PPUSH
// result := value - 1 ;
58591: LD_ADDR_VAR 0 2
58595: PUSH
58596: LD_VAR 0 1
58600: PUSH
58601: LD_INT 1
58603: MINUS
58604: ST_TO_ADDR
// end ;
58605: LD_VAR 0 2
58609: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; var i , _x , _y , tmp , distance , centerDist , centerPoint ; begin
58610: LD_INT 0
58612: PPUSH
58613: PPUSH
58614: PPUSH
58615: PPUSH
58616: PPUSH
58617: PPUSH
58618: PPUSH
58619: PPUSH
// if not ValidHex ( x1 , y1 ) or not ValidHex ( x2 , y2 ) then
58620: LD_VAR 0 1
58624: PPUSH
58625: LD_VAR 0 2
58629: PPUSH
58630: CALL_OW 488
58634: NOT
58635: PUSH
58636: LD_VAR 0 3
58640: PPUSH
58641: LD_VAR 0 4
58645: PPUSH
58646: CALL_OW 488
58650: NOT
58651: OR
58652: IFFALSE 58665
// begin result := - 1 ;
58654: LD_ADDR_VAR 0 5
58658: PUSH
58659: LD_INT 1
58661: NEG
58662: ST_TO_ADDR
// exit ;
58663: GO 58900
// end ; centerPoint := PointBetweenXY ( x1 , y1 , x2 , y2 ) ;
58665: LD_ADDR_VAR 0 12
58669: PUSH
58670: LD_VAR 0 1
58674: PPUSH
58675: LD_VAR 0 2
58679: PPUSH
58680: LD_VAR 0 3
58684: PPUSH
58685: LD_VAR 0 4
58689: PPUSH
58690: CALL 57750 0 4
58694: ST_TO_ADDR
// centerDist := GetDistXY ( x1 , y1 , centerPoint [ 1 ] , centerPoint [ 2 ] ) ;
58695: LD_ADDR_VAR 0 11
58699: PUSH
58700: LD_VAR 0 1
58704: PPUSH
58705: LD_VAR 0 2
58709: PPUSH
58710: LD_VAR 0 12
58714: PUSH
58715: LD_INT 1
58717: ARRAY
58718: PPUSH
58719: LD_VAR 0 12
58723: PUSH
58724: LD_INT 2
58726: ARRAY
58727: PPUSH
58728: CALL_OW 298
58732: ST_TO_ADDR
// distance := 9999 ;
58733: LD_ADDR_VAR 0 10
58737: PUSH
58738: LD_INT 9999
58740: ST_TO_ADDR
// for i := 0 to 5 do
58741: LD_ADDR_VAR 0 6
58745: PUSH
58746: DOUBLE
58747: LD_INT 0
58749: DEC
58750: ST_TO_ADDR
58751: LD_INT 5
58753: PUSH
58754: FOR_TO
58755: IFFALSE 58898
// begin _x := ShiftX ( x1 , i , centerDist ) ;
58757: LD_ADDR_VAR 0 7
58761: PUSH
58762: LD_VAR 0 1
58766: PPUSH
58767: LD_VAR 0 6
58771: PPUSH
58772: LD_VAR 0 11
58776: PPUSH
58777: CALL_OW 272
58781: ST_TO_ADDR
// _y := ShiftY ( y1 , i , centerDist ) ;
58782: LD_ADDR_VAR 0 8
58786: PUSH
58787: LD_VAR 0 2
58791: PPUSH
58792: LD_VAR 0 6
58796: PPUSH
58797: LD_VAR 0 11
58801: PPUSH
58802: CALL_OW 273
58806: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
58807: LD_VAR 0 7
58811: PPUSH
58812: LD_VAR 0 8
58816: PPUSH
58817: CALL_OW 488
58821: NOT
58822: IFFALSE 58826
// continue ;
58824: GO 58754
// tmp := GetDistXY ( centerPoint [ 1 ] , centerPoint [ 2 ] , _x , _y ) ;
58826: LD_ADDR_VAR 0 9
58830: PUSH
58831: LD_VAR 0 12
58835: PUSH
58836: LD_INT 1
58838: ARRAY
58839: PPUSH
58840: LD_VAR 0 12
58844: PUSH
58845: LD_INT 2
58847: ARRAY
58848: PPUSH
58849: LD_VAR 0 7
58853: PPUSH
58854: LD_VAR 0 8
58858: PPUSH
58859: CALL_OW 298
58863: ST_TO_ADDR
// if tmp < distance then
58864: LD_VAR 0 9
58868: PUSH
58869: LD_VAR 0 10
58873: LESS
58874: IFFALSE 58896
// begin result := i ;
58876: LD_ADDR_VAR 0 5
58880: PUSH
58881: LD_VAR 0 6
58885: ST_TO_ADDR
// distance := tmp ;
58886: LD_ADDR_VAR 0 10
58890: PUSH
58891: LD_VAR 0 9
58895: ST_TO_ADDR
// end ; end ;
58896: GO 58754
58898: POP
58899: POP
// end ;
58900: LD_VAR 0 5
58904: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
58905: LD_INT 0
58907: PPUSH
58908: PPUSH
// if not driver or not IsInUnit ( driver ) then
58909: LD_VAR 0 1
58913: NOT
58914: PUSH
58915: LD_VAR 0 1
58919: PPUSH
58920: CALL_OW 310
58924: NOT
58925: OR
58926: IFFALSE 58930
// exit ;
58928: GO 59020
// vehicle := IsInUnit ( driver ) ;
58930: LD_ADDR_VAR 0 3
58934: PUSH
58935: LD_VAR 0 1
58939: PPUSH
58940: CALL_OW 310
58944: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
58945: LD_VAR 0 1
58949: PPUSH
58950: LD_STRING \
58952: PUSH
58953: LD_INT 0
58955: PUSH
58956: LD_INT 0
58958: PUSH
58959: LD_INT 0
58961: PUSH
58962: LD_INT 0
58964: PUSH
58965: LD_INT 0
58967: PUSH
58968: LD_INT 0
58970: PUSH
58971: EMPTY
58972: LIST
58973: LIST
58974: LIST
58975: LIST
58976: LIST
58977: LIST
58978: LIST
58979: PUSH
58980: LD_STRING E
58982: PUSH
58983: LD_INT 0
58985: PUSH
58986: LD_INT 0
58988: PUSH
58989: LD_VAR 0 3
58993: PUSH
58994: LD_INT 0
58996: PUSH
58997: LD_INT 0
58999: PUSH
59000: LD_INT 0
59002: PUSH
59003: EMPTY
59004: LIST
59005: LIST
59006: LIST
59007: LIST
59008: LIST
59009: LIST
59010: LIST
59011: PUSH
59012: EMPTY
59013: LIST
59014: LIST
59015: PPUSH
59016: CALL_OW 446
// end ;
59020: LD_VAR 0 2
59024: RET
// export function AddComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
59025: LD_INT 0
59027: PPUSH
59028: PPUSH
// if not driver or not IsInUnit ( driver ) then
59029: LD_VAR 0 1
59033: NOT
59034: PUSH
59035: LD_VAR 0 1
59039: PPUSH
59040: CALL_OW 310
59044: NOT
59045: OR
59046: IFFALSE 59050
// exit ;
59048: GO 59140
// vehicle := IsInUnit ( driver ) ;
59050: LD_ADDR_VAR 0 3
59054: PUSH
59055: LD_VAR 0 1
59059: PPUSH
59060: CALL_OW 310
59064: ST_TO_ADDR
// AddTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
59065: LD_VAR 0 1
59069: PPUSH
59070: LD_STRING \
59072: PUSH
59073: LD_INT 0
59075: PUSH
59076: LD_INT 0
59078: PUSH
59079: LD_INT 0
59081: PUSH
59082: LD_INT 0
59084: PUSH
59085: LD_INT 0
59087: PUSH
59088: LD_INT 0
59090: PUSH
59091: EMPTY
59092: LIST
59093: LIST
59094: LIST
59095: LIST
59096: LIST
59097: LIST
59098: LIST
59099: PUSH
59100: LD_STRING E
59102: PUSH
59103: LD_INT 0
59105: PUSH
59106: LD_INT 0
59108: PUSH
59109: LD_VAR 0 3
59113: PUSH
59114: LD_INT 0
59116: PUSH
59117: LD_INT 0
59119: PUSH
59120: LD_INT 0
59122: PUSH
59123: EMPTY
59124: LIST
59125: LIST
59126: LIST
59127: LIST
59128: LIST
59129: LIST
59130: LIST
59131: PUSH
59132: EMPTY
59133: LIST
59134: LIST
59135: PPUSH
59136: CALL_OW 447
// end ;
59140: LD_VAR 0 2
59144: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
59145: LD_INT 0
59147: PPUSH
59148: PPUSH
59149: PPUSH
// tmp := [ ] ;
59150: LD_ADDR_VAR 0 5
59154: PUSH
59155: EMPTY
59156: ST_TO_ADDR
// for i in units do
59157: LD_ADDR_VAR 0 4
59161: PUSH
59162: LD_VAR 0 1
59166: PUSH
59167: FOR_IN
59168: IFFALSE 59206
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
59170: LD_ADDR_VAR 0 5
59174: PUSH
59175: LD_VAR 0 5
59179: PPUSH
59180: LD_VAR 0 5
59184: PUSH
59185: LD_INT 1
59187: PLUS
59188: PPUSH
59189: LD_VAR 0 4
59193: PPUSH
59194: CALL_OW 256
59198: PPUSH
59199: CALL_OW 2
59203: ST_TO_ADDR
59204: GO 59167
59206: POP
59207: POP
// if not tmp then
59208: LD_VAR 0 5
59212: NOT
59213: IFFALSE 59217
// exit ;
59215: GO 59265
// if asc then
59217: LD_VAR 0 2
59221: IFFALSE 59245
// result := SortListByListAsc ( units , tmp ) else
59223: LD_ADDR_VAR 0 3
59227: PUSH
59228: LD_VAR 0 1
59232: PPUSH
59233: LD_VAR 0 5
59237: PPUSH
59238: CALL_OW 76
59242: ST_TO_ADDR
59243: GO 59265
// result := SortListByListDesc ( units , tmp ) ;
59245: LD_ADDR_VAR 0 3
59249: PUSH
59250: LD_VAR 0 1
59254: PPUSH
59255: LD_VAR 0 5
59259: PPUSH
59260: CALL_OW 77
59264: ST_TO_ADDR
// end ;
59265: LD_VAR 0 3
59269: RET
// export function WantToRepairVehicle ( mech , vehicle ) ; var task ; begin
59270: LD_INT 0
59272: PPUSH
59273: PPUSH
// task := GetTaskList ( mech ) ;
59274: LD_ADDR_VAR 0 4
59278: PUSH
59279: LD_VAR 0 1
59283: PPUSH
59284: CALL_OW 437
59288: ST_TO_ADDR
// if not task then
59289: LD_VAR 0 4
59293: NOT
59294: IFFALSE 59298
// exit ;
59296: GO 59340
// result := task [ 1 ] [ 1 ] = r and task [ 1 ] [ 4 ] = vehicle ;
59298: LD_ADDR_VAR 0 3
59302: PUSH
59303: LD_VAR 0 4
59307: PUSH
59308: LD_INT 1
59310: ARRAY
59311: PUSH
59312: LD_INT 1
59314: ARRAY
59315: PUSH
59316: LD_STRING r
59318: EQUAL
59319: PUSH
59320: LD_VAR 0 4
59324: PUSH
59325: LD_INT 1
59327: ARRAY
59328: PUSH
59329: LD_INT 4
59331: ARRAY
59332: PUSH
59333: LD_VAR 0 2
59337: EQUAL
59338: AND
59339: ST_TO_ADDR
// end ;
59340: LD_VAR 0 3
59344: RET
// export function PlaceUnitXYD ( unit , x , y , d , mode ) ; begin
59345: LD_INT 0
59347: PPUSH
// SetDir ( unit , d ) ;
59348: LD_VAR 0 1
59352: PPUSH
59353: LD_VAR 0 4
59357: PPUSH
59358: CALL_OW 233
// PlaceUnitXY ( unit , x , y , mode ) ;
59362: LD_VAR 0 1
59366: PPUSH
59367: LD_VAR 0 2
59371: PPUSH
59372: LD_VAR 0 3
59376: PPUSH
59377: LD_VAR 0 5
59381: PPUSH
59382: CALL_OW 48
// end ;
59386: LD_VAR 0 6
59390: RET
// export function ToNaturalNumber ( number ) ; begin
59391: LD_INT 0
59393: PPUSH
// result := number div 1 ;
59394: LD_ADDR_VAR 0 2
59398: PUSH
59399: LD_VAR 0 1
59403: PUSH
59404: LD_INT 1
59406: DIV
59407: ST_TO_ADDR
// if number < 0 then
59408: LD_VAR 0 1
59412: PUSH
59413: LD_INT 0
59415: LESS
59416: IFFALSE 59426
// result := 0 ;
59418: LD_ADDR_VAR 0 2
59422: PUSH
59423: LD_INT 0
59425: ST_TO_ADDR
// end ;
59426: LD_VAR 0 2
59430: RET
// export function SortByClass ( units , class ) ; var un ; begin
59431: LD_INT 0
59433: PPUSH
59434: PPUSH
// if not units or not class then
59435: LD_VAR 0 1
59439: NOT
59440: PUSH
59441: LD_VAR 0 2
59445: NOT
59446: OR
59447: IFFALSE 59451
// exit ;
59449: GO 59546
// result := [ ] ;
59451: LD_ADDR_VAR 0 3
59455: PUSH
59456: EMPTY
59457: ST_TO_ADDR
// for un in units do
59458: LD_ADDR_VAR 0 4
59462: PUSH
59463: LD_VAR 0 1
59467: PUSH
59468: FOR_IN
59469: IFFALSE 59544
// if GetClass ( un ) = class then
59471: LD_VAR 0 4
59475: PPUSH
59476: CALL_OW 257
59480: PUSH
59481: LD_VAR 0 2
59485: EQUAL
59486: IFFALSE 59513
// result := Insert ( result , 1 , un ) else
59488: LD_ADDR_VAR 0 3
59492: PUSH
59493: LD_VAR 0 3
59497: PPUSH
59498: LD_INT 1
59500: PPUSH
59501: LD_VAR 0 4
59505: PPUSH
59506: CALL_OW 2
59510: ST_TO_ADDR
59511: GO 59542
// result := Replace ( result , result + 1 , un ) ;
59513: LD_ADDR_VAR 0 3
59517: PUSH
59518: LD_VAR 0 3
59522: PPUSH
59523: LD_VAR 0 3
59527: PUSH
59528: LD_INT 1
59530: PLUS
59531: PPUSH
59532: LD_VAR 0 4
59536: PPUSH
59537: CALL_OW 1
59541: ST_TO_ADDR
59542: GO 59468
59544: POP
59545: POP
// end ;
59546: LD_VAR 0 3
59550: RET
// export function GetCratesNearbyXY ( x , y , r ) ; var _x , _y , min_y , min_x , max_x , max_y ; begin
59551: LD_INT 0
59553: PPUSH
59554: PPUSH
59555: PPUSH
59556: PPUSH
59557: PPUSH
59558: PPUSH
59559: PPUSH
// result := [ ] ;
59560: LD_ADDR_VAR 0 4
59564: PUSH
59565: EMPTY
59566: ST_TO_ADDR
// if x - r < 0 then
59567: LD_VAR 0 1
59571: PUSH
59572: LD_VAR 0 3
59576: MINUS
59577: PUSH
59578: LD_INT 0
59580: LESS
59581: IFFALSE 59593
// min_x := 0 else
59583: LD_ADDR_VAR 0 8
59587: PUSH
59588: LD_INT 0
59590: ST_TO_ADDR
59591: GO 59609
// min_x := x - r ;
59593: LD_ADDR_VAR 0 8
59597: PUSH
59598: LD_VAR 0 1
59602: PUSH
59603: LD_VAR 0 3
59607: MINUS
59608: ST_TO_ADDR
// if y - r < 0 then
59609: LD_VAR 0 2
59613: PUSH
59614: LD_VAR 0 3
59618: MINUS
59619: PUSH
59620: LD_INT 0
59622: LESS
59623: IFFALSE 59635
// min_y := 0 else
59625: LD_ADDR_VAR 0 7
59629: PUSH
59630: LD_INT 0
59632: ST_TO_ADDR
59633: GO 59651
// min_y := y - r ;
59635: LD_ADDR_VAR 0 7
59639: PUSH
59640: LD_VAR 0 2
59644: PUSH
59645: LD_VAR 0 3
59649: MINUS
59650: ST_TO_ADDR
// max_x := x + r ;
59651: LD_ADDR_VAR 0 9
59655: PUSH
59656: LD_VAR 0 1
59660: PUSH
59661: LD_VAR 0 3
59665: PLUS
59666: ST_TO_ADDR
// max_y := y + r ;
59667: LD_ADDR_VAR 0 10
59671: PUSH
59672: LD_VAR 0 2
59676: PUSH
59677: LD_VAR 0 3
59681: PLUS
59682: ST_TO_ADDR
// for _x = min_x to max_x do
59683: LD_ADDR_VAR 0 5
59687: PUSH
59688: DOUBLE
59689: LD_VAR 0 8
59693: DEC
59694: ST_TO_ADDR
59695: LD_VAR 0 9
59699: PUSH
59700: FOR_TO
59701: IFFALSE 59802
// for _y = min_y to max_y do
59703: LD_ADDR_VAR 0 6
59707: PUSH
59708: DOUBLE
59709: LD_VAR 0 7
59713: DEC
59714: ST_TO_ADDR
59715: LD_VAR 0 10
59719: PUSH
59720: FOR_TO
59721: IFFALSE 59798
// begin if not ValidHex ( _x , _y ) then
59723: LD_VAR 0 5
59727: PPUSH
59728: LD_VAR 0 6
59732: PPUSH
59733: CALL_OW 488
59737: NOT
59738: IFFALSE 59742
// continue ;
59740: GO 59720
// if GetResourceTypeXY ( _x , _y ) then
59742: LD_VAR 0 5
59746: PPUSH
59747: LD_VAR 0 6
59751: PPUSH
59752: CALL_OW 283
59756: IFFALSE 59796
// result := Replace ( result , result + 1 , [ _x , _y ] ) ;
59758: LD_ADDR_VAR 0 4
59762: PUSH
59763: LD_VAR 0 4
59767: PPUSH
59768: LD_VAR 0 4
59772: PUSH
59773: LD_INT 1
59775: PLUS
59776: PPUSH
59777: LD_VAR 0 5
59781: PUSH
59782: LD_VAR 0 6
59786: PUSH
59787: EMPTY
59788: LIST
59789: LIST
59790: PPUSH
59791: CALL_OW 1
59795: ST_TO_ADDR
// end ;
59796: GO 59720
59798: POP
59799: POP
59800: GO 59700
59802: POP
59803: POP
// end ;
59804: LD_VAR 0 4
59808: RET
// export function AgressiveMove ( units , path ) ; var i , enemy , nearEnemy , cr , side , tag , ignoreCratesWeapon ; begin
59809: LD_INT 0
59811: PPUSH
59812: PPUSH
59813: PPUSH
59814: PPUSH
59815: PPUSH
59816: PPUSH
59817: PPUSH
59818: PPUSH
// if not units then
59819: LD_VAR 0 1
59823: NOT
59824: IFFALSE 59828
// exit ;
59826: GO 60352
// result := UnitFilter ( units , [ f_ok ] ) ;
59828: LD_ADDR_VAR 0 3
59832: PUSH
59833: LD_VAR 0 1
59837: PPUSH
59838: LD_INT 50
59840: PUSH
59841: EMPTY
59842: LIST
59843: PPUSH
59844: CALL_OW 72
59848: ST_TO_ADDR
// side := GetSide ( units [ 1 ] ) ;
59849: LD_ADDR_VAR 0 8
59853: PUSH
59854: LD_VAR 0 1
59858: PUSH
59859: LD_INT 1
59861: ARRAY
59862: PPUSH
59863: CALL_OW 255
59867: ST_TO_ADDR
// ignoreCratesWeapon := [ ar_selfpropelled_bomb , ar_bio_bomb , ru_time_lapser ] ;
59868: LD_ADDR_VAR 0 10
59872: PUSH
59873: LD_INT 29
59875: PUSH
59876: LD_INT 91
59878: PUSH
59879: LD_INT 49
59881: PUSH
59882: EMPTY
59883: LIST
59884: LIST
59885: LIST
59886: ST_TO_ADDR
// if not result then
59887: LD_VAR 0 3
59891: NOT
59892: IFFALSE 59896
// exit ;
59894: GO 60352
// enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
59896: LD_ADDR_VAR 0 5
59900: PUSH
59901: LD_INT 81
59903: PUSH
59904: LD_VAR 0 8
59908: PUSH
59909: EMPTY
59910: LIST
59911: LIST
59912: PPUSH
59913: CALL_OW 69
59917: ST_TO_ADDR
// for i in result do
59918: LD_ADDR_VAR 0 4
59922: PUSH
59923: LD_VAR 0 3
59927: PUSH
59928: FOR_IN
59929: IFFALSE 60350
// begin tag := GetTag ( i ) + 1 ;
59931: LD_ADDR_VAR 0 9
59935: PUSH
59936: LD_VAR 0 4
59940: PPUSH
59941: CALL_OW 110
59945: PUSH
59946: LD_INT 1
59948: PLUS
59949: ST_TO_ADDR
// cr := GetCratesNearbyXY ( GetX ( i ) , GetY ( i ) , 6 ) ;
59950: LD_ADDR_VAR 0 7
59954: PUSH
59955: LD_VAR 0 4
59959: PPUSH
59960: CALL_OW 250
59964: PPUSH
59965: LD_VAR 0 4
59969: PPUSH
59970: CALL_OW 251
59974: PPUSH
59975: LD_INT 6
59977: PPUSH
59978: CALL 59551 0 3
59982: ST_TO_ADDR
// if GetType ( i ) = unit_vehicle and cr and not GetWeapon ( i ) in ignoreCratesWeapon then
59983: LD_VAR 0 4
59987: PPUSH
59988: CALL_OW 247
59992: PUSH
59993: LD_INT 2
59995: EQUAL
59996: PUSH
59997: LD_VAR 0 7
60001: AND
60002: PUSH
60003: LD_VAR 0 4
60007: PPUSH
60008: CALL_OW 264
60012: PUSH
60013: LD_VAR 0 10
60017: IN
60018: NOT
60019: AND
60020: IFFALSE 60059
// ComAttackPlace ( i , cr [ 1 ] [ 1 ] , cr [ 1 ] [ 2 ] ) else
60022: LD_VAR 0 4
60026: PPUSH
60027: LD_VAR 0 7
60031: PUSH
60032: LD_INT 1
60034: ARRAY
60035: PUSH
60036: LD_INT 1
60038: ARRAY
60039: PPUSH
60040: LD_VAR 0 7
60044: PUSH
60045: LD_INT 1
60047: ARRAY
60048: PUSH
60049: LD_INT 2
60051: ARRAY
60052: PPUSH
60053: CALL_OW 116
60057: GO 60348
// if path > tag then
60059: LD_VAR 0 2
60063: PUSH
60064: LD_VAR 0 9
60068: GREATER
60069: IFFALSE 60277
// begin nearEnemy := UnitFilter ( enemy , [ f_dist , i , 8 ] ) ;
60071: LD_ADDR_VAR 0 6
60075: PUSH
60076: LD_VAR 0 5
60080: PPUSH
60081: LD_INT 91
60083: PUSH
60084: LD_VAR 0 4
60088: PUSH
60089: LD_INT 8
60091: PUSH
60092: EMPTY
60093: LIST
60094: LIST
60095: LIST
60096: PPUSH
60097: CALL_OW 72
60101: ST_TO_ADDR
// if nearEnemy then
60102: LD_VAR 0 6
60106: IFFALSE 60175
// begin if GetWeapon ( i ) = ru_time_lapser then
60108: LD_VAR 0 4
60112: PPUSH
60113: CALL_OW 264
60117: PUSH
60118: LD_INT 49
60120: EQUAL
60121: IFFALSE 60149
// ComMoveUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) else
60123: LD_VAR 0 4
60127: PPUSH
60128: LD_VAR 0 6
60132: PPUSH
60133: LD_VAR 0 4
60137: PPUSH
60138: CALL_OW 74
60142: PPUSH
60143: CALL_OW 112
60147: GO 60173
// ComAgressiveMoveToUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) ;
60149: LD_VAR 0 4
60153: PPUSH
60154: LD_VAR 0 6
60158: PPUSH
60159: LD_VAR 0 4
60163: PPUSH
60164: CALL_OW 74
60168: PPUSH
60169: CALL 61277 0 2
// end else
60173: GO 60275
// if GetDistUnitXY ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) > 6 then
60175: LD_VAR 0 4
60179: PPUSH
60180: LD_VAR 0 2
60184: PUSH
60185: LD_VAR 0 9
60189: ARRAY
60190: PUSH
60191: LD_INT 1
60193: ARRAY
60194: PPUSH
60195: LD_VAR 0 2
60199: PUSH
60200: LD_VAR 0 9
60204: ARRAY
60205: PUSH
60206: LD_INT 2
60208: ARRAY
60209: PPUSH
60210: CALL_OW 297
60214: PUSH
60215: LD_INT 6
60217: GREATER
60218: IFFALSE 60261
// ComAgressiveMove ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) else
60220: LD_VAR 0 4
60224: PPUSH
60225: LD_VAR 0 2
60229: PUSH
60230: LD_VAR 0 9
60234: ARRAY
60235: PUSH
60236: LD_INT 1
60238: ARRAY
60239: PPUSH
60240: LD_VAR 0 2
60244: PUSH
60245: LD_VAR 0 9
60249: ARRAY
60250: PUSH
60251: LD_INT 2
60253: ARRAY
60254: PPUSH
60255: CALL_OW 114
60259: GO 60275
// SetTag ( i , tag ) ;
60261: LD_VAR 0 4
60265: PPUSH
60266: LD_VAR 0 9
60270: PPUSH
60271: CALL_OW 109
// end else
60275: GO 60348
// if enemy then
60277: LD_VAR 0 5
60281: IFFALSE 60348
// begin if GetWeapon ( i ) = ru_time_lapser then
60283: LD_VAR 0 4
60287: PPUSH
60288: CALL_OW 264
60292: PUSH
60293: LD_INT 49
60295: EQUAL
60296: IFFALSE 60324
// ComMoveUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
60298: LD_VAR 0 4
60302: PPUSH
60303: LD_VAR 0 5
60307: PPUSH
60308: LD_VAR 0 4
60312: PPUSH
60313: CALL_OW 74
60317: PPUSH
60318: CALL_OW 112
60322: GO 60348
// ComAgressiveMoveToUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
60324: LD_VAR 0 4
60328: PPUSH
60329: LD_VAR 0 5
60333: PPUSH
60334: LD_VAR 0 4
60338: PPUSH
60339: CALL_OW 74
60343: PPUSH
60344: CALL 61277 0 2
// end ; end ;
60348: GO 59928
60350: POP
60351: POP
// end ;
60352: LD_VAR 0 3
60356: RET
// export function ComLookAtDir ( unit , direction ) ; var x , y ; begin
60357: LD_INT 0
60359: PPUSH
60360: PPUSH
60361: PPUSH
// if not unit or IsInUnit ( unit ) then
60362: LD_VAR 0 1
60366: NOT
60367: PUSH
60368: LD_VAR 0 1
60372: PPUSH
60373: CALL_OW 310
60377: OR
60378: IFFALSE 60382
// exit ;
60380: GO 60473
// x := ShiftX ( GetX ( unit ) , direction , 1 ) ;
60382: LD_ADDR_VAR 0 4
60386: PUSH
60387: LD_VAR 0 1
60391: PPUSH
60392: CALL_OW 250
60396: PPUSH
60397: LD_VAR 0 2
60401: PPUSH
60402: LD_INT 1
60404: PPUSH
60405: CALL_OW 272
60409: ST_TO_ADDR
// y := ShiftY ( GetY ( unit ) , direction , 1 ) ;
60410: LD_ADDR_VAR 0 5
60414: PUSH
60415: LD_VAR 0 1
60419: PPUSH
60420: CALL_OW 251
60424: PPUSH
60425: LD_VAR 0 2
60429: PPUSH
60430: LD_INT 1
60432: PPUSH
60433: CALL_OW 273
60437: ST_TO_ADDR
// if ValidHex ( x , y ) then
60438: LD_VAR 0 4
60442: PPUSH
60443: LD_VAR 0 5
60447: PPUSH
60448: CALL_OW 488
60452: IFFALSE 60473
// ComTurnXY ( unit , x , y ) ;
60454: LD_VAR 0 1
60458: PPUSH
60459: LD_VAR 0 4
60463: PPUSH
60464: LD_VAR 0 5
60468: PPUSH
60469: CALL_OW 118
// end ;
60473: LD_VAR 0 3
60477: RET
// export function SeeUnits ( side , units ) ; var i ; begin
60478: LD_INT 0
60480: PPUSH
60481: PPUSH
// result := false ;
60482: LD_ADDR_VAR 0 3
60486: PUSH
60487: LD_INT 0
60489: ST_TO_ADDR
// if not units then
60490: LD_VAR 0 2
60494: NOT
60495: IFFALSE 60499
// exit ;
60497: GO 60544
// for i in units do
60499: LD_ADDR_VAR 0 4
60503: PUSH
60504: LD_VAR 0 2
60508: PUSH
60509: FOR_IN
60510: IFFALSE 60542
// if See ( side , i ) then
60512: LD_VAR 0 1
60516: PPUSH
60517: LD_VAR 0 4
60521: PPUSH
60522: CALL_OW 292
60526: IFFALSE 60540
// begin result := true ;
60528: LD_ADDR_VAR 0 3
60532: PUSH
60533: LD_INT 1
60535: ST_TO_ADDR
// exit ;
60536: POP
60537: POP
60538: GO 60544
// end ;
60540: GO 60509
60542: POP
60543: POP
// end ;
60544: LD_VAR 0 3
60548: RET
// export function GetNearestPoint ( unit , points ) ; var i , dist , tmpDist ; begin
60549: LD_INT 0
60551: PPUSH
60552: PPUSH
60553: PPUSH
60554: PPUSH
// if not unit or not points then
60555: LD_VAR 0 1
60559: NOT
60560: PUSH
60561: LD_VAR 0 2
60565: NOT
60566: OR
60567: IFFALSE 60571
// exit ;
60569: GO 60661
// dist := 99999 ;
60571: LD_ADDR_VAR 0 5
60575: PUSH
60576: LD_INT 99999
60578: ST_TO_ADDR
// for i in points do
60579: LD_ADDR_VAR 0 4
60583: PUSH
60584: LD_VAR 0 2
60588: PUSH
60589: FOR_IN
60590: IFFALSE 60659
// begin tmpDist := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
60592: LD_ADDR_VAR 0 6
60596: PUSH
60597: LD_VAR 0 1
60601: PPUSH
60602: LD_VAR 0 4
60606: PUSH
60607: LD_INT 1
60609: ARRAY
60610: PPUSH
60611: LD_VAR 0 4
60615: PUSH
60616: LD_INT 2
60618: ARRAY
60619: PPUSH
60620: CALL_OW 297
60624: ST_TO_ADDR
// if tmpDist < dist then
60625: LD_VAR 0 6
60629: PUSH
60630: LD_VAR 0 5
60634: LESS
60635: IFFALSE 60657
// begin result := i ;
60637: LD_ADDR_VAR 0 3
60641: PUSH
60642: LD_VAR 0 4
60646: ST_TO_ADDR
// dist := tmpDist ;
60647: LD_ADDR_VAR 0 5
60651: PUSH
60652: LD_VAR 0 6
60656: ST_TO_ADDR
// end ; end ;
60657: GO 60589
60659: POP
60660: POP
// end ;
60661: LD_VAR 0 3
60665: RET
// export function CreateBehemoth ( side , x , y , d ) ; begin
60666: LD_INT 0
60668: PPUSH
// uc_side := side ;
60669: LD_ADDR_OWVAR 20
60673: PUSH
60674: LD_VAR 0 1
60678: ST_TO_ADDR
// uc_nation := 3 ;
60679: LD_ADDR_OWVAR 21
60683: PUSH
60684: LD_INT 3
60686: ST_TO_ADDR
// vc_chassis := 25 ;
60687: LD_ADDR_OWVAR 37
60691: PUSH
60692: LD_INT 25
60694: ST_TO_ADDR
// vc_engine := engine_siberite ;
60695: LD_ADDR_OWVAR 39
60699: PUSH
60700: LD_INT 3
60702: ST_TO_ADDR
// vc_control := control_computer ;
60703: LD_ADDR_OWVAR 38
60707: PUSH
60708: LD_INT 3
60710: ST_TO_ADDR
// vc_weapon := 59 ;
60711: LD_ADDR_OWVAR 40
60715: PUSH
60716: LD_INT 59
60718: ST_TO_ADDR
// result := CreateVehicle ;
60719: LD_ADDR_VAR 0 5
60723: PUSH
60724: CALL_OW 45
60728: ST_TO_ADDR
// SetDir ( result , d ) ;
60729: LD_VAR 0 5
60733: PPUSH
60734: LD_VAR 0 4
60738: PPUSH
60739: CALL_OW 233
// PlaceUnitXY ( result , x , y , false ) ;
60743: LD_VAR 0 5
60747: PPUSH
60748: LD_VAR 0 2
60752: PPUSH
60753: LD_VAR 0 3
60757: PPUSH
60758: LD_INT 0
60760: PPUSH
60761: CALL_OW 48
// end ;
60765: LD_VAR 0 5
60769: RET
// export function GetMultiCargo ( cargo ) ; var i , tmp ; begin
60770: LD_INT 0
60772: PPUSH
60773: PPUSH
60774: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
60775: LD_ADDR_VAR 0 2
60779: PUSH
60780: LD_INT 0
60782: PUSH
60783: LD_INT 0
60785: PUSH
60786: LD_INT 0
60788: PUSH
60789: LD_INT 0
60791: PUSH
60792: EMPTY
60793: LIST
60794: LIST
60795: LIST
60796: LIST
60797: ST_TO_ADDR
// if not cargo or not GetWeapon ( cargo ) in [ us_cargo_bay , ru_cargo_bay , ar_cargo_bay , ru_big_cargo_bay ] then
60798: LD_VAR 0 1
60802: NOT
60803: PUSH
60804: LD_VAR 0 1
60808: PPUSH
60809: CALL_OW 264
60813: PUSH
60814: LD_INT 12
60816: PUSH
60817: LD_INT 51
60819: PUSH
60820: LD_INT 32
60822: PUSH
60823: LD_INT 89
60825: PUSH
60826: EMPTY
60827: LIST
60828: LIST
60829: LIST
60830: LIST
60831: IN
60832: NOT
60833: OR
60834: IFFALSE 60838
// exit ;
60836: GO 60936
// for i := 1 to 3 do
60838: LD_ADDR_VAR 0 3
60842: PUSH
60843: DOUBLE
60844: LD_INT 1
60846: DEC
60847: ST_TO_ADDR
60848: LD_INT 3
60850: PUSH
60851: FOR_TO
60852: IFFALSE 60934
// begin tmp := GetCargo ( cargo , i ) ;
60854: LD_ADDR_VAR 0 4
60858: PUSH
60859: LD_VAR 0 1
60863: PPUSH
60864: LD_VAR 0 3
60868: PPUSH
60869: CALL_OW 289
60873: ST_TO_ADDR
// result := Replace ( result , i , tmp ) ;
60874: LD_ADDR_VAR 0 2
60878: PUSH
60879: LD_VAR 0 2
60883: PPUSH
60884: LD_VAR 0 3
60888: PPUSH
60889: LD_VAR 0 4
60893: PPUSH
60894: CALL_OW 1
60898: ST_TO_ADDR
// result := Replace ( result , 4 , result [ 4 ] + tmp ) ;
60899: LD_ADDR_VAR 0 2
60903: PUSH
60904: LD_VAR 0 2
60908: PPUSH
60909: LD_INT 4
60911: PPUSH
60912: LD_VAR 0 2
60916: PUSH
60917: LD_INT 4
60919: ARRAY
60920: PUSH
60921: LD_VAR 0 4
60925: PLUS
60926: PPUSH
60927: CALL_OW 1
60931: ST_TO_ADDR
// end ;
60932: GO 60851
60934: POP
60935: POP
// end ;
60936: LD_VAR 0 2
60940: RET
// export function Length ( array ) ; begin
60941: LD_INT 0
60943: PPUSH
// result := array + 0 ;
60944: LD_ADDR_VAR 0 2
60948: PUSH
60949: LD_VAR 0 1
60953: PUSH
60954: LD_INT 0
60956: PLUS
60957: ST_TO_ADDR
// end ;
60958: LD_VAR 0 2
60962: RET
// export function PrepareArray ( array ) ; begin
60963: LD_INT 0
60965: PPUSH
// result := array diff 0 ;
60966: LD_ADDR_VAR 0 2
60970: PUSH
60971: LD_VAR 0 1
60975: PUSH
60976: LD_INT 0
60978: DIFF
60979: ST_TO_ADDR
// if not result [ 1 ] then
60980: LD_VAR 0 2
60984: PUSH
60985: LD_INT 1
60987: ARRAY
60988: NOT
60989: IFFALSE 61009
// result := Delete ( result , 1 ) ;
60991: LD_ADDR_VAR 0 2
60995: PUSH
60996: LD_VAR 0 2
61000: PPUSH
61001: LD_INT 1
61003: PPUSH
61004: CALL_OW 3
61008: ST_TO_ADDR
// end ;
61009: LD_VAR 0 2
61013: RET
// export function IsInSibRocketRange ( x , y , area ) ; var i , sibRocketRange , tmp ; begin
61014: LD_INT 0
61016: PPUSH
61017: PPUSH
61018: PPUSH
61019: PPUSH
// sibRocketRange := 25 ;
61020: LD_ADDR_VAR 0 6
61024: PUSH
61025: LD_INT 25
61027: ST_TO_ADDR
// result := false ;
61028: LD_ADDR_VAR 0 4
61032: PUSH
61033: LD_INT 0
61035: ST_TO_ADDR
// for i := 0 to 5 do
61036: LD_ADDR_VAR 0 5
61040: PUSH
61041: DOUBLE
61042: LD_INT 0
61044: DEC
61045: ST_TO_ADDR
61046: LD_INT 5
61048: PUSH
61049: FOR_TO
61050: IFFALSE 61117
// if InArea ( ShiftX ( x , i , sibRocketRange ) , ShiftY ( y , i , sibRocketRange ) , area ) then
61052: LD_VAR 0 1
61056: PPUSH
61057: LD_VAR 0 5
61061: PPUSH
61062: LD_VAR 0 6
61066: PPUSH
61067: CALL_OW 272
61071: PPUSH
61072: LD_VAR 0 2
61076: PPUSH
61077: LD_VAR 0 5
61081: PPUSH
61082: LD_VAR 0 6
61086: PPUSH
61087: CALL_OW 273
61091: PPUSH
61092: LD_VAR 0 3
61096: PPUSH
61097: CALL_OW 309
61101: IFFALSE 61115
// begin result := true ;
61103: LD_ADDR_VAR 0 4
61107: PUSH
61108: LD_INT 1
61110: ST_TO_ADDR
// exit ;
61111: POP
61112: POP
61113: GO 61119
// end ;
61115: GO 61049
61117: POP
61118: POP
// end ;
61119: LD_VAR 0 4
61123: RET
// export function SayRadioNoFaceNoName ( unit , dialog ) ; begin
61124: LD_INT 0
61126: PPUSH
// SayEX ( unit , dialog , false , false , true , false ) ;
61127: LD_VAR 0 1
61131: PPUSH
61132: LD_VAR 0 2
61136: PPUSH
61137: LD_INT 0
61139: PPUSH
61140: LD_INT 0
61142: PPUSH
61143: LD_INT 1
61145: PPUSH
61146: LD_INT 0
61148: PPUSH
61149: CALL_OW 587
// end ;
61153: LD_VAR 0 3
61157: RET
// export function CenterOnNow ( unit ) ; begin
61158: LD_INT 0
61160: PPUSH
// result := IsInUnit ( unit ) ;
61161: LD_ADDR_VAR 0 2
61165: PUSH
61166: LD_VAR 0 1
61170: PPUSH
61171: CALL_OW 310
61175: ST_TO_ADDR
// if not result then
61176: LD_VAR 0 2
61180: NOT
61181: IFFALSE 61193
// result := unit ;
61183: LD_ADDR_VAR 0 2
61187: PUSH
61188: LD_VAR 0 1
61192: ST_TO_ADDR
// CenterNowOnUnits ( unit ) ;
61193: LD_VAR 0 1
61197: PPUSH
61198: CALL_OW 87
// end ;
61202: LD_VAR 0 2
61206: RET
// export function ComMoveHex ( unit , hex ) ; begin
61207: LD_INT 0
61209: PPUSH
// if not hex then
61210: LD_VAR 0 2
61214: NOT
61215: IFFALSE 61219
// exit ;
61217: GO 61272
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) then
61219: LD_VAR 0 2
61223: PUSH
61224: LD_INT 1
61226: ARRAY
61227: PPUSH
61228: LD_VAR 0 2
61232: PUSH
61233: LD_INT 2
61235: ARRAY
61236: PPUSH
61237: CALL_OW 428
61241: IFFALSE 61245
// exit ;
61243: GO 61272
// ComMoveXY ( unit , hex [ 1 ] , hex [ 2 ] ) ;
61245: LD_VAR 0 1
61249: PPUSH
61250: LD_VAR 0 2
61254: PUSH
61255: LD_INT 1
61257: ARRAY
61258: PPUSH
61259: LD_VAR 0 2
61263: PUSH
61264: LD_INT 2
61266: ARRAY
61267: PPUSH
61268: CALL_OW 111
// end ;
61272: LD_VAR 0 3
61276: RET
// export function ComAgressiveMoveToUnit ( unit , enemy ) ; var x , y ; begin
61277: LD_INT 0
61279: PPUSH
61280: PPUSH
61281: PPUSH
// if not unit or not enemy then
61282: LD_VAR 0 1
61286: NOT
61287: PUSH
61288: LD_VAR 0 2
61292: NOT
61293: OR
61294: IFFALSE 61298
// exit ;
61296: GO 61422
// x := GetX ( enemy ) ;
61298: LD_ADDR_VAR 0 4
61302: PUSH
61303: LD_VAR 0 2
61307: PPUSH
61308: CALL_OW 250
61312: ST_TO_ADDR
// y := GetY ( enemy ) ;
61313: LD_ADDR_VAR 0 5
61317: PUSH
61318: LD_VAR 0 2
61322: PPUSH
61323: CALL_OW 251
61327: ST_TO_ADDR
// if ValidHex ( x , y ) then
61328: LD_VAR 0 4
61332: PPUSH
61333: LD_VAR 0 5
61337: PPUSH
61338: CALL_OW 488
61342: IFFALSE 61422
// if GetType ( enemy ) in [ unit_building , unit_vehicle ] and See ( GetSide ( unit ) , enemy ) then
61344: LD_VAR 0 2
61348: PPUSH
61349: CALL_OW 247
61353: PUSH
61354: LD_INT 3
61356: PUSH
61357: LD_INT 2
61359: PUSH
61360: EMPTY
61361: LIST
61362: LIST
61363: IN
61364: PUSH
61365: LD_VAR 0 1
61369: PPUSH
61370: CALL_OW 255
61374: PPUSH
61375: LD_VAR 0 2
61379: PPUSH
61380: CALL_OW 292
61384: AND
61385: IFFALSE 61403
// ComAttackUnit ( unit , enemy ) else
61387: LD_VAR 0 1
61391: PPUSH
61392: LD_VAR 0 2
61396: PPUSH
61397: CALL_OW 115
61401: GO 61422
// ComAgressiveMove ( unit , x , y ) ;
61403: LD_VAR 0 1
61407: PPUSH
61408: LD_VAR 0 4
61412: PPUSH
61413: LD_VAR 0 5
61417: PPUSH
61418: CALL_OW 114
// end ; end_of_file
61422: LD_VAR 0 3
61426: RET
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use , mc_is_defending ; export mc_block_vehicle_constructed_thread ; export function InitMacro ; var i ; begin
61427: LD_INT 0
61429: PPUSH
61430: PPUSH
// skirmish := false ;
61431: LD_ADDR_EXP 29
61435: PUSH
61436: LD_INT 0
61438: ST_TO_ADDR
// debug_mc := false ;
61439: LD_ADDR_EXP 30
61443: PUSH
61444: LD_INT 0
61446: ST_TO_ADDR
// mc_bases := [ ] ;
61447: LD_ADDR_EXP 31
61451: PUSH
61452: EMPTY
61453: ST_TO_ADDR
// mc_sides := [ ] ;
61454: LD_ADDR_EXP 57
61458: PUSH
61459: EMPTY
61460: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
61461: LD_ADDR_EXP 32
61465: PUSH
61466: EMPTY
61467: ST_TO_ADDR
// mc_building_repairs := [ ] ;
61468: LD_ADDR_EXP 33
61472: PUSH
61473: EMPTY
61474: ST_TO_ADDR
// mc_need_heal := [ ] ;
61475: LD_ADDR_EXP 34
61479: PUSH
61480: EMPTY
61481: ST_TO_ADDR
// mc_healers := [ ] ;
61482: LD_ADDR_EXP 35
61486: PUSH
61487: EMPTY
61488: ST_TO_ADDR
// mc_build_list := [ ] ;
61489: LD_ADDR_EXP 36
61493: PUSH
61494: EMPTY
61495: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
61496: LD_ADDR_EXP 63
61500: PUSH
61501: EMPTY
61502: ST_TO_ADDR
// mc_builders := [ ] ;
61503: LD_ADDR_EXP 37
61507: PUSH
61508: EMPTY
61509: ST_TO_ADDR
// mc_construct_list := [ ] ;
61510: LD_ADDR_EXP 38
61514: PUSH
61515: EMPTY
61516: ST_TO_ADDR
// mc_turret_list := [ ] ;
61517: LD_ADDR_EXP 39
61521: PUSH
61522: EMPTY
61523: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
61524: LD_ADDR_EXP 40
61528: PUSH
61529: EMPTY
61530: ST_TO_ADDR
// mc_miners := [ ] ;
61531: LD_ADDR_EXP 45
61535: PUSH
61536: EMPTY
61537: ST_TO_ADDR
// mc_mines := [ ] ;
61538: LD_ADDR_EXP 44
61542: PUSH
61543: EMPTY
61544: ST_TO_ADDR
// mc_minefields := [ ] ;
61545: LD_ADDR_EXP 46
61549: PUSH
61550: EMPTY
61551: ST_TO_ADDR
// mc_crates := [ ] ;
61552: LD_ADDR_EXP 47
61556: PUSH
61557: EMPTY
61558: ST_TO_ADDR
// mc_crates_collector := [ ] ;
61559: LD_ADDR_EXP 48
61563: PUSH
61564: EMPTY
61565: ST_TO_ADDR
// mc_crates_area := [ ] ;
61566: LD_ADDR_EXP 49
61570: PUSH
61571: EMPTY
61572: ST_TO_ADDR
// mc_vehicles := [ ] ;
61573: LD_ADDR_EXP 50
61577: PUSH
61578: EMPTY
61579: ST_TO_ADDR
// mc_attack := [ ] ;
61580: LD_ADDR_EXP 51
61584: PUSH
61585: EMPTY
61586: ST_TO_ADDR
// mc_produce := [ ] ;
61587: LD_ADDR_EXP 52
61591: PUSH
61592: EMPTY
61593: ST_TO_ADDR
// mc_defender := [ ] ;
61594: LD_ADDR_EXP 53
61598: PUSH
61599: EMPTY
61600: ST_TO_ADDR
// mc_parking := [ ] ;
61601: LD_ADDR_EXP 55
61605: PUSH
61606: EMPTY
61607: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
61608: LD_ADDR_EXP 41
61612: PUSH
61613: EMPTY
61614: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
61615: LD_ADDR_EXP 43
61619: PUSH
61620: EMPTY
61621: ST_TO_ADDR
// mc_scan := [ ] ;
61622: LD_ADDR_EXP 54
61626: PUSH
61627: EMPTY
61628: ST_TO_ADDR
// mc_scan_area := [ ] ;
61629: LD_ADDR_EXP 56
61633: PUSH
61634: EMPTY
61635: ST_TO_ADDR
// mc_tech := [ ] ;
61636: LD_ADDR_EXP 58
61640: PUSH
61641: EMPTY
61642: ST_TO_ADDR
// mc_class := [ ] ;
61643: LD_ADDR_EXP 72
61647: PUSH
61648: EMPTY
61649: ST_TO_ADDR
// mc_class_case_use := [ ] ;
61650: LD_ADDR_EXP 73
61654: PUSH
61655: EMPTY
61656: ST_TO_ADDR
// mc_is_defending := [ ] ;
61657: LD_ADDR_EXP 74
61661: PUSH
61662: EMPTY
61663: ST_TO_ADDR
// mc_lab_upgrade := [ ] ;
61664: LD_ADDR_EXP 65
61668: PUSH
61669: EMPTY
61670: ST_TO_ADDR
// mc_block_vehicle_constructed_thread := false ;
61671: LD_ADDR_EXP 75
61675: PUSH
61676: LD_INT 0
61678: ST_TO_ADDR
// end ;
61679: LD_VAR 0 1
61683: RET
// export function MC_Kill ( base ) ; begin
61684: LD_INT 0
61686: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
61687: LD_ADDR_EXP 31
61691: PUSH
61692: LD_EXP 31
61696: PPUSH
61697: LD_VAR 0 1
61701: PPUSH
61702: EMPTY
61703: PPUSH
61704: CALL_OW 1
61708: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
61709: LD_ADDR_EXP 32
61713: PUSH
61714: LD_EXP 32
61718: PPUSH
61719: LD_VAR 0 1
61723: PPUSH
61724: EMPTY
61725: PPUSH
61726: CALL_OW 1
61730: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
61731: LD_ADDR_EXP 33
61735: PUSH
61736: LD_EXP 33
61740: PPUSH
61741: LD_VAR 0 1
61745: PPUSH
61746: EMPTY
61747: PPUSH
61748: CALL_OW 1
61752: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
61753: LD_ADDR_EXP 34
61757: PUSH
61758: LD_EXP 34
61762: PPUSH
61763: LD_VAR 0 1
61767: PPUSH
61768: EMPTY
61769: PPUSH
61770: CALL_OW 1
61774: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
61775: LD_ADDR_EXP 35
61779: PUSH
61780: LD_EXP 35
61784: PPUSH
61785: LD_VAR 0 1
61789: PPUSH
61790: EMPTY
61791: PPUSH
61792: CALL_OW 1
61796: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
61797: LD_ADDR_EXP 36
61801: PUSH
61802: LD_EXP 36
61806: PPUSH
61807: LD_VAR 0 1
61811: PPUSH
61812: EMPTY
61813: PPUSH
61814: CALL_OW 1
61818: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
61819: LD_ADDR_EXP 37
61823: PUSH
61824: LD_EXP 37
61828: PPUSH
61829: LD_VAR 0 1
61833: PPUSH
61834: EMPTY
61835: PPUSH
61836: CALL_OW 1
61840: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
61841: LD_ADDR_EXP 38
61845: PUSH
61846: LD_EXP 38
61850: PPUSH
61851: LD_VAR 0 1
61855: PPUSH
61856: EMPTY
61857: PPUSH
61858: CALL_OW 1
61862: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
61863: LD_ADDR_EXP 39
61867: PUSH
61868: LD_EXP 39
61872: PPUSH
61873: LD_VAR 0 1
61877: PPUSH
61878: EMPTY
61879: PPUSH
61880: CALL_OW 1
61884: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
61885: LD_ADDR_EXP 40
61889: PUSH
61890: LD_EXP 40
61894: PPUSH
61895: LD_VAR 0 1
61899: PPUSH
61900: EMPTY
61901: PPUSH
61902: CALL_OW 1
61906: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
61907: LD_ADDR_EXP 41
61911: PUSH
61912: LD_EXP 41
61916: PPUSH
61917: LD_VAR 0 1
61921: PPUSH
61922: EMPTY
61923: PPUSH
61924: CALL_OW 1
61928: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
61929: LD_ADDR_EXP 42
61933: PUSH
61934: LD_EXP 42
61938: PPUSH
61939: LD_VAR 0 1
61943: PPUSH
61944: LD_INT 0
61946: PPUSH
61947: CALL_OW 1
61951: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
61952: LD_ADDR_EXP 43
61956: PUSH
61957: LD_EXP 43
61961: PPUSH
61962: LD_VAR 0 1
61966: PPUSH
61967: EMPTY
61968: PPUSH
61969: CALL_OW 1
61973: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
61974: LD_ADDR_EXP 44
61978: PUSH
61979: LD_EXP 44
61983: PPUSH
61984: LD_VAR 0 1
61988: PPUSH
61989: EMPTY
61990: PPUSH
61991: CALL_OW 1
61995: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
61996: LD_ADDR_EXP 45
62000: PUSH
62001: LD_EXP 45
62005: PPUSH
62006: LD_VAR 0 1
62010: PPUSH
62011: EMPTY
62012: PPUSH
62013: CALL_OW 1
62017: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
62018: LD_ADDR_EXP 46
62022: PUSH
62023: LD_EXP 46
62027: PPUSH
62028: LD_VAR 0 1
62032: PPUSH
62033: EMPTY
62034: PPUSH
62035: CALL_OW 1
62039: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
62040: LD_ADDR_EXP 47
62044: PUSH
62045: LD_EXP 47
62049: PPUSH
62050: LD_VAR 0 1
62054: PPUSH
62055: EMPTY
62056: PPUSH
62057: CALL_OW 1
62061: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
62062: LD_ADDR_EXP 48
62066: PUSH
62067: LD_EXP 48
62071: PPUSH
62072: LD_VAR 0 1
62076: PPUSH
62077: EMPTY
62078: PPUSH
62079: CALL_OW 1
62083: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
62084: LD_ADDR_EXP 49
62088: PUSH
62089: LD_EXP 49
62093: PPUSH
62094: LD_VAR 0 1
62098: PPUSH
62099: EMPTY
62100: PPUSH
62101: CALL_OW 1
62105: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
62106: LD_ADDR_EXP 50
62110: PUSH
62111: LD_EXP 50
62115: PPUSH
62116: LD_VAR 0 1
62120: PPUSH
62121: EMPTY
62122: PPUSH
62123: CALL_OW 1
62127: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
62128: LD_ADDR_EXP 51
62132: PUSH
62133: LD_EXP 51
62137: PPUSH
62138: LD_VAR 0 1
62142: PPUSH
62143: EMPTY
62144: PPUSH
62145: CALL_OW 1
62149: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
62150: LD_ADDR_EXP 52
62154: PUSH
62155: LD_EXP 52
62159: PPUSH
62160: LD_VAR 0 1
62164: PPUSH
62165: EMPTY
62166: PPUSH
62167: CALL_OW 1
62171: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
62172: LD_ADDR_EXP 53
62176: PUSH
62177: LD_EXP 53
62181: PPUSH
62182: LD_VAR 0 1
62186: PPUSH
62187: EMPTY
62188: PPUSH
62189: CALL_OW 1
62193: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
62194: LD_ADDR_EXP 54
62198: PUSH
62199: LD_EXP 54
62203: PPUSH
62204: LD_VAR 0 1
62208: PPUSH
62209: EMPTY
62210: PPUSH
62211: CALL_OW 1
62215: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
62216: LD_ADDR_EXP 55
62220: PUSH
62221: LD_EXP 55
62225: PPUSH
62226: LD_VAR 0 1
62230: PPUSH
62231: EMPTY
62232: PPUSH
62233: CALL_OW 1
62237: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
62238: LD_ADDR_EXP 56
62242: PUSH
62243: LD_EXP 56
62247: PPUSH
62248: LD_VAR 0 1
62252: PPUSH
62253: EMPTY
62254: PPUSH
62255: CALL_OW 1
62259: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
62260: LD_ADDR_EXP 58
62264: PUSH
62265: LD_EXP 58
62269: PPUSH
62270: LD_VAR 0 1
62274: PPUSH
62275: EMPTY
62276: PPUSH
62277: CALL_OW 1
62281: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
62282: LD_ADDR_EXP 60
62286: PUSH
62287: LD_EXP 60
62291: PPUSH
62292: LD_VAR 0 1
62296: PPUSH
62297: EMPTY
62298: PPUSH
62299: CALL_OW 1
62303: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
62304: LD_ADDR_EXP 61
62308: PUSH
62309: LD_EXP 61
62313: PPUSH
62314: LD_VAR 0 1
62318: PPUSH
62319: EMPTY
62320: PPUSH
62321: CALL_OW 1
62325: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
62326: LD_ADDR_EXP 62
62330: PUSH
62331: LD_EXP 62
62335: PPUSH
62336: LD_VAR 0 1
62340: PPUSH
62341: EMPTY
62342: PPUSH
62343: CALL_OW 1
62347: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
62348: LD_ADDR_EXP 63
62352: PUSH
62353: LD_EXP 63
62357: PPUSH
62358: LD_VAR 0 1
62362: PPUSH
62363: EMPTY
62364: PPUSH
62365: CALL_OW 1
62369: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
62370: LD_ADDR_EXP 64
62374: PUSH
62375: LD_EXP 64
62379: PPUSH
62380: LD_VAR 0 1
62384: PPUSH
62385: EMPTY
62386: PPUSH
62387: CALL_OW 1
62391: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
62392: LD_ADDR_EXP 65
62396: PUSH
62397: LD_EXP 65
62401: PPUSH
62402: LD_VAR 0 1
62406: PPUSH
62407: EMPTY
62408: PPUSH
62409: CALL_OW 1
62413: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
62414: LD_ADDR_EXP 66
62418: PUSH
62419: LD_EXP 66
62423: PPUSH
62424: LD_VAR 0 1
62428: PPUSH
62429: EMPTY
62430: PPUSH
62431: CALL_OW 1
62435: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
62436: LD_ADDR_EXP 67
62440: PUSH
62441: LD_EXP 67
62445: PPUSH
62446: LD_VAR 0 1
62450: PPUSH
62451: EMPTY
62452: PPUSH
62453: CALL_OW 1
62457: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
62458: LD_ADDR_EXP 68
62462: PUSH
62463: LD_EXP 68
62467: PPUSH
62468: LD_VAR 0 1
62472: PPUSH
62473: EMPTY
62474: PPUSH
62475: CALL_OW 1
62479: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
62480: LD_ADDR_EXP 69
62484: PUSH
62485: LD_EXP 69
62489: PPUSH
62490: LD_VAR 0 1
62494: PPUSH
62495: EMPTY
62496: PPUSH
62497: CALL_OW 1
62501: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
62502: LD_ADDR_EXP 70
62506: PUSH
62507: LD_EXP 70
62511: PPUSH
62512: LD_VAR 0 1
62516: PPUSH
62517: EMPTY
62518: PPUSH
62519: CALL_OW 1
62523: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
62524: LD_ADDR_EXP 71
62528: PUSH
62529: LD_EXP 71
62533: PPUSH
62534: LD_VAR 0 1
62538: PPUSH
62539: EMPTY
62540: PPUSH
62541: CALL_OW 1
62545: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
62546: LD_ADDR_EXP 72
62550: PUSH
62551: LD_EXP 72
62555: PPUSH
62556: LD_VAR 0 1
62560: PPUSH
62561: EMPTY
62562: PPUSH
62563: CALL_OW 1
62567: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
62568: LD_ADDR_EXP 73
62572: PUSH
62573: LD_EXP 73
62577: PPUSH
62578: LD_VAR 0 1
62582: PPUSH
62583: LD_INT 0
62585: PPUSH
62586: CALL_OW 1
62590: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
62591: LD_ADDR_EXP 74
62595: PUSH
62596: LD_EXP 74
62600: PPUSH
62601: LD_VAR 0 1
62605: PPUSH
62606: LD_INT 0
62608: PPUSH
62609: CALL_OW 1
62613: ST_TO_ADDR
// end ;
62614: LD_VAR 0 2
62618: RET
// export function MC_Add ( side , units ) ; var base ; begin
62619: LD_INT 0
62621: PPUSH
62622: PPUSH
// base := mc_bases + 1 ;
62623: LD_ADDR_VAR 0 4
62627: PUSH
62628: LD_EXP 31
62632: PUSH
62633: LD_INT 1
62635: PLUS
62636: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
62637: LD_ADDR_EXP 57
62641: PUSH
62642: LD_EXP 57
62646: PPUSH
62647: LD_VAR 0 4
62651: PPUSH
62652: LD_VAR 0 1
62656: PPUSH
62657: CALL_OW 1
62661: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
62662: LD_ADDR_EXP 31
62666: PUSH
62667: LD_EXP 31
62671: PPUSH
62672: LD_VAR 0 4
62676: PPUSH
62677: LD_VAR 0 2
62681: PPUSH
62682: CALL_OW 1
62686: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
62687: LD_ADDR_EXP 32
62691: PUSH
62692: LD_EXP 32
62696: PPUSH
62697: LD_VAR 0 4
62701: PPUSH
62702: EMPTY
62703: PPUSH
62704: CALL_OW 1
62708: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
62709: LD_ADDR_EXP 33
62713: PUSH
62714: LD_EXP 33
62718: PPUSH
62719: LD_VAR 0 4
62723: PPUSH
62724: EMPTY
62725: PPUSH
62726: CALL_OW 1
62730: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
62731: LD_ADDR_EXP 34
62735: PUSH
62736: LD_EXP 34
62740: PPUSH
62741: LD_VAR 0 4
62745: PPUSH
62746: EMPTY
62747: PPUSH
62748: CALL_OW 1
62752: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
62753: LD_ADDR_EXP 35
62757: PUSH
62758: LD_EXP 35
62762: PPUSH
62763: LD_VAR 0 4
62767: PPUSH
62768: EMPTY
62769: PPUSH
62770: CALL_OW 1
62774: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
62775: LD_ADDR_EXP 36
62779: PUSH
62780: LD_EXP 36
62784: PPUSH
62785: LD_VAR 0 4
62789: PPUSH
62790: EMPTY
62791: PPUSH
62792: CALL_OW 1
62796: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
62797: LD_ADDR_EXP 37
62801: PUSH
62802: LD_EXP 37
62806: PPUSH
62807: LD_VAR 0 4
62811: PPUSH
62812: EMPTY
62813: PPUSH
62814: CALL_OW 1
62818: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
62819: LD_ADDR_EXP 38
62823: PUSH
62824: LD_EXP 38
62828: PPUSH
62829: LD_VAR 0 4
62833: PPUSH
62834: EMPTY
62835: PPUSH
62836: CALL_OW 1
62840: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
62841: LD_ADDR_EXP 39
62845: PUSH
62846: LD_EXP 39
62850: PPUSH
62851: LD_VAR 0 4
62855: PPUSH
62856: EMPTY
62857: PPUSH
62858: CALL_OW 1
62862: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
62863: LD_ADDR_EXP 40
62867: PUSH
62868: LD_EXP 40
62872: PPUSH
62873: LD_VAR 0 4
62877: PPUSH
62878: EMPTY
62879: PPUSH
62880: CALL_OW 1
62884: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
62885: LD_ADDR_EXP 41
62889: PUSH
62890: LD_EXP 41
62894: PPUSH
62895: LD_VAR 0 4
62899: PPUSH
62900: EMPTY
62901: PPUSH
62902: CALL_OW 1
62906: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
62907: LD_ADDR_EXP 42
62911: PUSH
62912: LD_EXP 42
62916: PPUSH
62917: LD_VAR 0 4
62921: PPUSH
62922: LD_INT 0
62924: PPUSH
62925: CALL_OW 1
62929: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
62930: LD_ADDR_EXP 43
62934: PUSH
62935: LD_EXP 43
62939: PPUSH
62940: LD_VAR 0 4
62944: PPUSH
62945: EMPTY
62946: PPUSH
62947: CALL_OW 1
62951: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
62952: LD_ADDR_EXP 44
62956: PUSH
62957: LD_EXP 44
62961: PPUSH
62962: LD_VAR 0 4
62966: PPUSH
62967: EMPTY
62968: PPUSH
62969: CALL_OW 1
62973: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
62974: LD_ADDR_EXP 45
62978: PUSH
62979: LD_EXP 45
62983: PPUSH
62984: LD_VAR 0 4
62988: PPUSH
62989: EMPTY
62990: PPUSH
62991: CALL_OW 1
62995: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
62996: LD_ADDR_EXP 46
63000: PUSH
63001: LD_EXP 46
63005: PPUSH
63006: LD_VAR 0 4
63010: PPUSH
63011: EMPTY
63012: PPUSH
63013: CALL_OW 1
63017: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
63018: LD_ADDR_EXP 47
63022: PUSH
63023: LD_EXP 47
63027: PPUSH
63028: LD_VAR 0 4
63032: PPUSH
63033: EMPTY
63034: PPUSH
63035: CALL_OW 1
63039: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
63040: LD_ADDR_EXP 48
63044: PUSH
63045: LD_EXP 48
63049: PPUSH
63050: LD_VAR 0 4
63054: PPUSH
63055: EMPTY
63056: PPUSH
63057: CALL_OW 1
63061: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
63062: LD_ADDR_EXP 49
63066: PUSH
63067: LD_EXP 49
63071: PPUSH
63072: LD_VAR 0 4
63076: PPUSH
63077: EMPTY
63078: PPUSH
63079: CALL_OW 1
63083: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
63084: LD_ADDR_EXP 50
63088: PUSH
63089: LD_EXP 50
63093: PPUSH
63094: LD_VAR 0 4
63098: PPUSH
63099: EMPTY
63100: PPUSH
63101: CALL_OW 1
63105: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
63106: LD_ADDR_EXP 51
63110: PUSH
63111: LD_EXP 51
63115: PPUSH
63116: LD_VAR 0 4
63120: PPUSH
63121: EMPTY
63122: PPUSH
63123: CALL_OW 1
63127: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
63128: LD_ADDR_EXP 52
63132: PUSH
63133: LD_EXP 52
63137: PPUSH
63138: LD_VAR 0 4
63142: PPUSH
63143: EMPTY
63144: PPUSH
63145: CALL_OW 1
63149: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
63150: LD_ADDR_EXP 53
63154: PUSH
63155: LD_EXP 53
63159: PPUSH
63160: LD_VAR 0 4
63164: PPUSH
63165: EMPTY
63166: PPUSH
63167: CALL_OW 1
63171: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
63172: LD_ADDR_EXP 54
63176: PUSH
63177: LD_EXP 54
63181: PPUSH
63182: LD_VAR 0 4
63186: PPUSH
63187: EMPTY
63188: PPUSH
63189: CALL_OW 1
63193: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
63194: LD_ADDR_EXP 55
63198: PUSH
63199: LD_EXP 55
63203: PPUSH
63204: LD_VAR 0 4
63208: PPUSH
63209: EMPTY
63210: PPUSH
63211: CALL_OW 1
63215: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
63216: LD_ADDR_EXP 56
63220: PUSH
63221: LD_EXP 56
63225: PPUSH
63226: LD_VAR 0 4
63230: PPUSH
63231: EMPTY
63232: PPUSH
63233: CALL_OW 1
63237: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
63238: LD_ADDR_EXP 58
63242: PUSH
63243: LD_EXP 58
63247: PPUSH
63248: LD_VAR 0 4
63252: PPUSH
63253: EMPTY
63254: PPUSH
63255: CALL_OW 1
63259: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
63260: LD_ADDR_EXP 60
63264: PUSH
63265: LD_EXP 60
63269: PPUSH
63270: LD_VAR 0 4
63274: PPUSH
63275: EMPTY
63276: PPUSH
63277: CALL_OW 1
63281: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
63282: LD_ADDR_EXP 61
63286: PUSH
63287: LD_EXP 61
63291: PPUSH
63292: LD_VAR 0 4
63296: PPUSH
63297: EMPTY
63298: PPUSH
63299: CALL_OW 1
63303: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
63304: LD_ADDR_EXP 62
63308: PUSH
63309: LD_EXP 62
63313: PPUSH
63314: LD_VAR 0 4
63318: PPUSH
63319: EMPTY
63320: PPUSH
63321: CALL_OW 1
63325: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
63326: LD_ADDR_EXP 63
63330: PUSH
63331: LD_EXP 63
63335: PPUSH
63336: LD_VAR 0 4
63340: PPUSH
63341: EMPTY
63342: PPUSH
63343: CALL_OW 1
63347: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
63348: LD_ADDR_EXP 64
63352: PUSH
63353: LD_EXP 64
63357: PPUSH
63358: LD_VAR 0 4
63362: PPUSH
63363: EMPTY
63364: PPUSH
63365: CALL_OW 1
63369: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
63370: LD_ADDR_EXP 65
63374: PUSH
63375: LD_EXP 65
63379: PPUSH
63380: LD_VAR 0 4
63384: PPUSH
63385: EMPTY
63386: PPUSH
63387: CALL_OW 1
63391: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
63392: LD_ADDR_EXP 66
63396: PUSH
63397: LD_EXP 66
63401: PPUSH
63402: LD_VAR 0 4
63406: PPUSH
63407: EMPTY
63408: PPUSH
63409: CALL_OW 1
63413: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
63414: LD_ADDR_EXP 67
63418: PUSH
63419: LD_EXP 67
63423: PPUSH
63424: LD_VAR 0 4
63428: PPUSH
63429: EMPTY
63430: PPUSH
63431: CALL_OW 1
63435: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
63436: LD_ADDR_EXP 68
63440: PUSH
63441: LD_EXP 68
63445: PPUSH
63446: LD_VAR 0 4
63450: PPUSH
63451: EMPTY
63452: PPUSH
63453: CALL_OW 1
63457: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
63458: LD_ADDR_EXP 69
63462: PUSH
63463: LD_EXP 69
63467: PPUSH
63468: LD_VAR 0 4
63472: PPUSH
63473: EMPTY
63474: PPUSH
63475: CALL_OW 1
63479: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
63480: LD_ADDR_EXP 70
63484: PUSH
63485: LD_EXP 70
63489: PPUSH
63490: LD_VAR 0 4
63494: PPUSH
63495: EMPTY
63496: PPUSH
63497: CALL_OW 1
63501: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
63502: LD_ADDR_EXP 71
63506: PUSH
63507: LD_EXP 71
63511: PPUSH
63512: LD_VAR 0 4
63516: PPUSH
63517: EMPTY
63518: PPUSH
63519: CALL_OW 1
63523: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
63524: LD_ADDR_EXP 72
63528: PUSH
63529: LD_EXP 72
63533: PPUSH
63534: LD_VAR 0 4
63538: PPUSH
63539: EMPTY
63540: PPUSH
63541: CALL_OW 1
63545: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
63546: LD_ADDR_EXP 73
63550: PUSH
63551: LD_EXP 73
63555: PPUSH
63556: LD_VAR 0 4
63560: PPUSH
63561: LD_INT 0
63563: PPUSH
63564: CALL_OW 1
63568: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
63569: LD_ADDR_EXP 74
63573: PUSH
63574: LD_EXP 74
63578: PPUSH
63579: LD_VAR 0 4
63583: PPUSH
63584: LD_INT 0
63586: PPUSH
63587: CALL_OW 1
63591: ST_TO_ADDR
// result := base ;
63592: LD_ADDR_VAR 0 3
63596: PUSH
63597: LD_VAR 0 4
63601: ST_TO_ADDR
// end ;
63602: LD_VAR 0 3
63606: RET
// export function MC_Start ( ) ; var i ; begin
63607: LD_INT 0
63609: PPUSH
63610: PPUSH
// for i = 1 to mc_bases do
63611: LD_ADDR_VAR 0 2
63615: PUSH
63616: DOUBLE
63617: LD_INT 1
63619: DEC
63620: ST_TO_ADDR
63621: LD_EXP 31
63625: PUSH
63626: FOR_TO
63627: IFFALSE 64727
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
63629: LD_ADDR_EXP 31
63633: PUSH
63634: LD_EXP 31
63638: PPUSH
63639: LD_VAR 0 2
63643: PPUSH
63644: LD_EXP 31
63648: PUSH
63649: LD_VAR 0 2
63653: ARRAY
63654: PUSH
63655: LD_INT 0
63657: DIFF
63658: PPUSH
63659: CALL_OW 1
63663: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
63664: LD_ADDR_EXP 32
63668: PUSH
63669: LD_EXP 32
63673: PPUSH
63674: LD_VAR 0 2
63678: PPUSH
63679: EMPTY
63680: PPUSH
63681: CALL_OW 1
63685: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
63686: LD_ADDR_EXP 33
63690: PUSH
63691: LD_EXP 33
63695: PPUSH
63696: LD_VAR 0 2
63700: PPUSH
63701: EMPTY
63702: PPUSH
63703: CALL_OW 1
63707: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
63708: LD_ADDR_EXP 34
63712: PUSH
63713: LD_EXP 34
63717: PPUSH
63718: LD_VAR 0 2
63722: PPUSH
63723: EMPTY
63724: PPUSH
63725: CALL_OW 1
63729: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
63730: LD_ADDR_EXP 35
63734: PUSH
63735: LD_EXP 35
63739: PPUSH
63740: LD_VAR 0 2
63744: PPUSH
63745: EMPTY
63746: PUSH
63747: EMPTY
63748: PUSH
63749: EMPTY
63750: LIST
63751: LIST
63752: PPUSH
63753: CALL_OW 1
63757: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
63758: LD_ADDR_EXP 36
63762: PUSH
63763: LD_EXP 36
63767: PPUSH
63768: LD_VAR 0 2
63772: PPUSH
63773: EMPTY
63774: PPUSH
63775: CALL_OW 1
63779: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
63780: LD_ADDR_EXP 63
63784: PUSH
63785: LD_EXP 63
63789: PPUSH
63790: LD_VAR 0 2
63794: PPUSH
63795: EMPTY
63796: PPUSH
63797: CALL_OW 1
63801: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
63802: LD_ADDR_EXP 37
63806: PUSH
63807: LD_EXP 37
63811: PPUSH
63812: LD_VAR 0 2
63816: PPUSH
63817: EMPTY
63818: PPUSH
63819: CALL_OW 1
63823: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
63824: LD_ADDR_EXP 38
63828: PUSH
63829: LD_EXP 38
63833: PPUSH
63834: LD_VAR 0 2
63838: PPUSH
63839: EMPTY
63840: PPUSH
63841: CALL_OW 1
63845: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
63846: LD_ADDR_EXP 39
63850: PUSH
63851: LD_EXP 39
63855: PPUSH
63856: LD_VAR 0 2
63860: PPUSH
63861: LD_EXP 31
63865: PUSH
63866: LD_VAR 0 2
63870: ARRAY
63871: PPUSH
63872: LD_INT 2
63874: PUSH
63875: LD_INT 30
63877: PUSH
63878: LD_INT 32
63880: PUSH
63881: EMPTY
63882: LIST
63883: LIST
63884: PUSH
63885: LD_INT 30
63887: PUSH
63888: LD_INT 33
63890: PUSH
63891: EMPTY
63892: LIST
63893: LIST
63894: PUSH
63895: EMPTY
63896: LIST
63897: LIST
63898: LIST
63899: PPUSH
63900: CALL_OW 72
63904: PPUSH
63905: CALL_OW 1
63909: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
63910: LD_ADDR_EXP 40
63914: PUSH
63915: LD_EXP 40
63919: PPUSH
63920: LD_VAR 0 2
63924: PPUSH
63925: LD_EXP 31
63929: PUSH
63930: LD_VAR 0 2
63934: ARRAY
63935: PPUSH
63936: LD_INT 2
63938: PUSH
63939: LD_INT 30
63941: PUSH
63942: LD_INT 32
63944: PUSH
63945: EMPTY
63946: LIST
63947: LIST
63948: PUSH
63949: LD_INT 30
63951: PUSH
63952: LD_INT 31
63954: PUSH
63955: EMPTY
63956: LIST
63957: LIST
63958: PUSH
63959: EMPTY
63960: LIST
63961: LIST
63962: LIST
63963: PUSH
63964: LD_INT 58
63966: PUSH
63967: EMPTY
63968: LIST
63969: PUSH
63970: EMPTY
63971: LIST
63972: LIST
63973: PPUSH
63974: CALL_OW 72
63978: PPUSH
63979: CALL_OW 1
63983: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
63984: LD_ADDR_EXP 41
63988: PUSH
63989: LD_EXP 41
63993: PPUSH
63994: LD_VAR 0 2
63998: PPUSH
63999: EMPTY
64000: PPUSH
64001: CALL_OW 1
64005: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
64006: LD_ADDR_EXP 45
64010: PUSH
64011: LD_EXP 45
64015: PPUSH
64016: LD_VAR 0 2
64020: PPUSH
64021: EMPTY
64022: PPUSH
64023: CALL_OW 1
64027: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
64028: LD_ADDR_EXP 44
64032: PUSH
64033: LD_EXP 44
64037: PPUSH
64038: LD_VAR 0 2
64042: PPUSH
64043: EMPTY
64044: PPUSH
64045: CALL_OW 1
64049: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
64050: LD_ADDR_EXP 46
64054: PUSH
64055: LD_EXP 46
64059: PPUSH
64060: LD_VAR 0 2
64064: PPUSH
64065: EMPTY
64066: PPUSH
64067: CALL_OW 1
64071: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
64072: LD_ADDR_EXP 47
64076: PUSH
64077: LD_EXP 47
64081: PPUSH
64082: LD_VAR 0 2
64086: PPUSH
64087: EMPTY
64088: PPUSH
64089: CALL_OW 1
64093: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
64094: LD_ADDR_EXP 48
64098: PUSH
64099: LD_EXP 48
64103: PPUSH
64104: LD_VAR 0 2
64108: PPUSH
64109: EMPTY
64110: PPUSH
64111: CALL_OW 1
64115: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
64116: LD_ADDR_EXP 49
64120: PUSH
64121: LD_EXP 49
64125: PPUSH
64126: LD_VAR 0 2
64130: PPUSH
64131: EMPTY
64132: PPUSH
64133: CALL_OW 1
64137: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
64138: LD_ADDR_EXP 50
64142: PUSH
64143: LD_EXP 50
64147: PPUSH
64148: LD_VAR 0 2
64152: PPUSH
64153: EMPTY
64154: PPUSH
64155: CALL_OW 1
64159: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
64160: LD_ADDR_EXP 51
64164: PUSH
64165: LD_EXP 51
64169: PPUSH
64170: LD_VAR 0 2
64174: PPUSH
64175: EMPTY
64176: PPUSH
64177: CALL_OW 1
64181: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
64182: LD_ADDR_EXP 52
64186: PUSH
64187: LD_EXP 52
64191: PPUSH
64192: LD_VAR 0 2
64196: PPUSH
64197: EMPTY
64198: PPUSH
64199: CALL_OW 1
64203: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
64204: LD_ADDR_EXP 53
64208: PUSH
64209: LD_EXP 53
64213: PPUSH
64214: LD_VAR 0 2
64218: PPUSH
64219: EMPTY
64220: PPUSH
64221: CALL_OW 1
64225: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
64226: LD_ADDR_EXP 42
64230: PUSH
64231: LD_EXP 42
64235: PPUSH
64236: LD_VAR 0 2
64240: PPUSH
64241: LD_INT 0
64243: PPUSH
64244: CALL_OW 1
64248: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
64249: LD_ADDR_EXP 55
64253: PUSH
64254: LD_EXP 55
64258: PPUSH
64259: LD_VAR 0 2
64263: PPUSH
64264: LD_INT 0
64266: PPUSH
64267: CALL_OW 1
64271: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
64272: LD_ADDR_EXP 43
64276: PUSH
64277: LD_EXP 43
64281: PPUSH
64282: LD_VAR 0 2
64286: PPUSH
64287: EMPTY
64288: PPUSH
64289: CALL_OW 1
64293: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
64294: LD_ADDR_EXP 54
64298: PUSH
64299: LD_EXP 54
64303: PPUSH
64304: LD_VAR 0 2
64308: PPUSH
64309: LD_INT 0
64311: PPUSH
64312: CALL_OW 1
64316: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
64317: LD_ADDR_EXP 56
64321: PUSH
64322: LD_EXP 56
64326: PPUSH
64327: LD_VAR 0 2
64331: PPUSH
64332: EMPTY
64333: PPUSH
64334: CALL_OW 1
64338: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
64339: LD_ADDR_EXP 59
64343: PUSH
64344: LD_EXP 59
64348: PPUSH
64349: LD_VAR 0 2
64353: PPUSH
64354: LD_INT 0
64356: PPUSH
64357: CALL_OW 1
64361: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
64362: LD_ADDR_EXP 60
64366: PUSH
64367: LD_EXP 60
64371: PPUSH
64372: LD_VAR 0 2
64376: PPUSH
64377: EMPTY
64378: PPUSH
64379: CALL_OW 1
64383: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
64384: LD_ADDR_EXP 61
64388: PUSH
64389: LD_EXP 61
64393: PPUSH
64394: LD_VAR 0 2
64398: PPUSH
64399: EMPTY
64400: PPUSH
64401: CALL_OW 1
64405: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
64406: LD_ADDR_EXP 62
64410: PUSH
64411: LD_EXP 62
64415: PPUSH
64416: LD_VAR 0 2
64420: PPUSH
64421: EMPTY
64422: PPUSH
64423: CALL_OW 1
64427: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
64428: LD_ADDR_EXP 64
64432: PUSH
64433: LD_EXP 64
64437: PPUSH
64438: LD_VAR 0 2
64442: PPUSH
64443: LD_EXP 31
64447: PUSH
64448: LD_VAR 0 2
64452: ARRAY
64453: PPUSH
64454: LD_INT 2
64456: PUSH
64457: LD_INT 30
64459: PUSH
64460: LD_INT 6
64462: PUSH
64463: EMPTY
64464: LIST
64465: LIST
64466: PUSH
64467: LD_INT 30
64469: PUSH
64470: LD_INT 7
64472: PUSH
64473: EMPTY
64474: LIST
64475: LIST
64476: PUSH
64477: LD_INT 30
64479: PUSH
64480: LD_INT 8
64482: PUSH
64483: EMPTY
64484: LIST
64485: LIST
64486: PUSH
64487: EMPTY
64488: LIST
64489: LIST
64490: LIST
64491: LIST
64492: PPUSH
64493: CALL_OW 72
64497: PPUSH
64498: CALL_OW 1
64502: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
64503: LD_ADDR_EXP 65
64507: PUSH
64508: LD_EXP 65
64512: PPUSH
64513: LD_VAR 0 2
64517: PPUSH
64518: EMPTY
64519: PPUSH
64520: CALL_OW 1
64524: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
64525: LD_ADDR_EXP 66
64529: PUSH
64530: LD_EXP 66
64534: PPUSH
64535: LD_VAR 0 2
64539: PPUSH
64540: EMPTY
64541: PPUSH
64542: CALL_OW 1
64546: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
64547: LD_ADDR_EXP 67
64551: PUSH
64552: LD_EXP 67
64556: PPUSH
64557: LD_VAR 0 2
64561: PPUSH
64562: EMPTY
64563: PPUSH
64564: CALL_OW 1
64568: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
64569: LD_ADDR_EXP 68
64573: PUSH
64574: LD_EXP 68
64578: PPUSH
64579: LD_VAR 0 2
64583: PPUSH
64584: EMPTY
64585: PPUSH
64586: CALL_OW 1
64590: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
64591: LD_ADDR_EXP 69
64595: PUSH
64596: LD_EXP 69
64600: PPUSH
64601: LD_VAR 0 2
64605: PPUSH
64606: EMPTY
64607: PPUSH
64608: CALL_OW 1
64612: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
64613: LD_ADDR_EXP 70
64617: PUSH
64618: LD_EXP 70
64622: PPUSH
64623: LD_VAR 0 2
64627: PPUSH
64628: EMPTY
64629: PPUSH
64630: CALL_OW 1
64634: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
64635: LD_ADDR_EXP 71
64639: PUSH
64640: LD_EXP 71
64644: PPUSH
64645: LD_VAR 0 2
64649: PPUSH
64650: EMPTY
64651: PPUSH
64652: CALL_OW 1
64656: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
64657: LD_ADDR_EXP 72
64661: PUSH
64662: LD_EXP 72
64666: PPUSH
64667: LD_VAR 0 2
64671: PPUSH
64672: EMPTY
64673: PPUSH
64674: CALL_OW 1
64678: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
64679: LD_ADDR_EXP 73
64683: PUSH
64684: LD_EXP 73
64688: PPUSH
64689: LD_VAR 0 2
64693: PPUSH
64694: LD_INT 0
64696: PPUSH
64697: CALL_OW 1
64701: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
64702: LD_ADDR_EXP 74
64706: PUSH
64707: LD_EXP 74
64711: PPUSH
64712: LD_VAR 0 2
64716: PPUSH
64717: LD_INT 0
64719: PPUSH
64720: CALL_OW 1
64724: ST_TO_ADDR
// end ;
64725: GO 63626
64727: POP
64728: POP
// MC_InitSides ( ) ;
64729: CALL 65015 0 0
// MC_InitResearch ( ) ;
64733: CALL 64754 0 0
// CustomInitMacro ( ) ;
64737: CALL 1411 0 0
// skirmish := true ;
64741: LD_ADDR_EXP 29
64745: PUSH
64746: LD_INT 1
64748: ST_TO_ADDR
// end ;
64749: LD_VAR 0 1
64753: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
64754: LD_INT 0
64756: PPUSH
64757: PPUSH
64758: PPUSH
64759: PPUSH
64760: PPUSH
64761: PPUSH
// if not mc_bases then
64762: LD_EXP 31
64766: NOT
64767: IFFALSE 64771
// exit ;
64769: GO 65010
// for i = 1 to 8 do
64771: LD_ADDR_VAR 0 2
64775: PUSH
64776: DOUBLE
64777: LD_INT 1
64779: DEC
64780: ST_TO_ADDR
64781: LD_INT 8
64783: PUSH
64784: FOR_TO
64785: IFFALSE 64811
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
64787: LD_ADDR_EXP 58
64791: PUSH
64792: LD_EXP 58
64796: PPUSH
64797: LD_VAR 0 2
64801: PPUSH
64802: EMPTY
64803: PPUSH
64804: CALL_OW 1
64808: ST_TO_ADDR
64809: GO 64784
64811: POP
64812: POP
// tmp := [ ] ;
64813: LD_ADDR_VAR 0 5
64817: PUSH
64818: EMPTY
64819: ST_TO_ADDR
// for i = 1 to mc_sides do
64820: LD_ADDR_VAR 0 2
64824: PUSH
64825: DOUBLE
64826: LD_INT 1
64828: DEC
64829: ST_TO_ADDR
64830: LD_EXP 57
64834: PUSH
64835: FOR_TO
64836: IFFALSE 64894
// if not mc_sides [ i ] in tmp then
64838: LD_EXP 57
64842: PUSH
64843: LD_VAR 0 2
64847: ARRAY
64848: PUSH
64849: LD_VAR 0 5
64853: IN
64854: NOT
64855: IFFALSE 64892
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
64857: LD_ADDR_VAR 0 5
64861: PUSH
64862: LD_VAR 0 5
64866: PPUSH
64867: LD_VAR 0 5
64871: PUSH
64872: LD_INT 1
64874: PLUS
64875: PPUSH
64876: LD_EXP 57
64880: PUSH
64881: LD_VAR 0 2
64885: ARRAY
64886: PPUSH
64887: CALL_OW 2
64891: ST_TO_ADDR
64892: GO 64835
64894: POP
64895: POP
// if not tmp then
64896: LD_VAR 0 5
64900: NOT
64901: IFFALSE 64905
// exit ;
64903: GO 65010
// for j in tmp do
64905: LD_ADDR_VAR 0 3
64909: PUSH
64910: LD_VAR 0 5
64914: PUSH
64915: FOR_IN
64916: IFFALSE 65008
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
64918: LD_ADDR_VAR 0 6
64922: PUSH
64923: LD_INT 22
64925: PUSH
64926: LD_VAR 0 3
64930: PUSH
64931: EMPTY
64932: LIST
64933: LIST
64934: PPUSH
64935: CALL_OW 69
64939: ST_TO_ADDR
// if not un then
64940: LD_VAR 0 6
64944: NOT
64945: IFFALSE 64949
// continue ;
64947: GO 64915
// nation := GetNation ( un [ 1 ] ) ;
64949: LD_ADDR_VAR 0 4
64953: PUSH
64954: LD_VAR 0 6
64958: PUSH
64959: LD_INT 1
64961: ARRAY
64962: PPUSH
64963: CALL_OW 248
64967: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
64968: LD_ADDR_EXP 58
64972: PUSH
64973: LD_EXP 58
64977: PPUSH
64978: LD_VAR 0 3
64982: PPUSH
64983: LD_VAR 0 3
64987: PPUSH
64988: LD_VAR 0 4
64992: PPUSH
64993: LD_INT 1
64995: PPUSH
64996: CALL 19947 0 3
65000: PPUSH
65001: CALL_OW 1
65005: ST_TO_ADDR
// end ;
65006: GO 64915
65008: POP
65009: POP
// end ;
65010: LD_VAR 0 1
65014: RET
// export function MC_InitSides ( ) ; var i ; begin
65015: LD_INT 0
65017: PPUSH
65018: PPUSH
// if not mc_bases then
65019: LD_EXP 31
65023: NOT
65024: IFFALSE 65028
// exit ;
65026: GO 65102
// for i = 1 to mc_bases do
65028: LD_ADDR_VAR 0 2
65032: PUSH
65033: DOUBLE
65034: LD_INT 1
65036: DEC
65037: ST_TO_ADDR
65038: LD_EXP 31
65042: PUSH
65043: FOR_TO
65044: IFFALSE 65100
// if mc_bases [ i ] then
65046: LD_EXP 31
65050: PUSH
65051: LD_VAR 0 2
65055: ARRAY
65056: IFFALSE 65098
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
65058: LD_ADDR_EXP 57
65062: PUSH
65063: LD_EXP 57
65067: PPUSH
65068: LD_VAR 0 2
65072: PPUSH
65073: LD_EXP 31
65077: PUSH
65078: LD_VAR 0 2
65082: ARRAY
65083: PUSH
65084: LD_INT 1
65086: ARRAY
65087: PPUSH
65088: CALL_OW 255
65092: PPUSH
65093: CALL_OW 1
65097: ST_TO_ADDR
65098: GO 65043
65100: POP
65101: POP
// end ;
65102: LD_VAR 0 1
65106: RET
// every 0 0$03 trigger skirmish do
65107: LD_EXP 29
65111: IFFALSE 65265
65113: GO 65115
65115: DISABLE
// begin enable ;
65116: ENABLE
// MC_CheckBuildings ( ) ;
65117: CALL 69777 0 0
// MC_CheckPeopleLife ( ) ;
65121: CALL 69938 0 0
// RaiseSailEvent ( 100 ) ;
65125: LD_INT 100
65127: PPUSH
65128: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
65132: LD_INT 103
65134: PPUSH
65135: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
65139: LD_INT 104
65141: PPUSH
65142: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
65146: LD_INT 105
65148: PPUSH
65149: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
65153: LD_INT 106
65155: PPUSH
65156: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
65160: LD_INT 107
65162: PPUSH
65163: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
65167: LD_INT 108
65169: PPUSH
65170: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
65174: LD_INT 109
65176: PPUSH
65177: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
65181: LD_INT 110
65183: PPUSH
65184: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
65188: LD_INT 111
65190: PPUSH
65191: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
65195: LD_INT 112
65197: PPUSH
65198: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
65202: LD_INT 113
65204: PPUSH
65205: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
65209: LD_INT 120
65211: PPUSH
65212: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
65216: LD_INT 121
65218: PPUSH
65219: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
65223: LD_INT 122
65225: PPUSH
65226: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
65230: LD_INT 123
65232: PPUSH
65233: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
65237: LD_INT 124
65239: PPUSH
65240: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
65244: LD_INT 125
65246: PPUSH
65247: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
65251: LD_INT 126
65253: PPUSH
65254: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
65258: LD_INT 200
65260: PPUSH
65261: CALL_OW 427
// end ;
65265: END
// on SailEvent ( event ) do begin if event < 100 then
65266: LD_VAR 0 1
65270: PUSH
65271: LD_INT 100
65273: LESS
65274: IFFALSE 65285
// CustomEvent ( event ) ;
65276: LD_VAR 0 1
65280: PPUSH
65281: CALL 19111 0 1
// if event = 100 then
65285: LD_VAR 0 1
65289: PUSH
65290: LD_INT 100
65292: EQUAL
65293: IFFALSE 65299
// MC_ClassManager ( ) ;
65295: CALL 65691 0 0
// if event = 101 then
65299: LD_VAR 0 1
65303: PUSH
65304: LD_INT 101
65306: EQUAL
65307: IFFALSE 65313
// MC_RepairBuildings ( ) ;
65309: CALL 70523 0 0
// if event = 102 then
65313: LD_VAR 0 1
65317: PUSH
65318: LD_INT 102
65320: EQUAL
65321: IFFALSE 65327
// MC_Heal ( ) ;
65323: CALL 71458 0 0
// if event = 103 then
65327: LD_VAR 0 1
65331: PUSH
65332: LD_INT 103
65334: EQUAL
65335: IFFALSE 65341
// MC_Build ( ) ;
65337: CALL 71880 0 0
// if event = 104 then
65341: LD_VAR 0 1
65345: PUSH
65346: LD_INT 104
65348: EQUAL
65349: IFFALSE 65355
// MC_TurretWeapon ( ) ;
65351: CALL 73514 0 0
// if event = 105 then
65355: LD_VAR 0 1
65359: PUSH
65360: LD_INT 105
65362: EQUAL
65363: IFFALSE 65369
// MC_BuildUpgrade ( ) ;
65365: CALL 73065 0 0
// if event = 106 then
65369: LD_VAR 0 1
65373: PUSH
65374: LD_INT 106
65376: EQUAL
65377: IFFALSE 65383
// MC_PlantMines ( ) ;
65379: CALL 73944 0 0
// if event = 107 then
65383: LD_VAR 0 1
65387: PUSH
65388: LD_INT 107
65390: EQUAL
65391: IFFALSE 65397
// MC_CollectCrates ( ) ;
65393: CALL 74742 0 0
// if event = 108 then
65397: LD_VAR 0 1
65401: PUSH
65402: LD_INT 108
65404: EQUAL
65405: IFFALSE 65411
// MC_LinkRemoteControl ( ) ;
65407: CALL 76592 0 0
// if event = 109 then
65411: LD_VAR 0 1
65415: PUSH
65416: LD_INT 109
65418: EQUAL
65419: IFFALSE 65425
// MC_ProduceVehicle ( ) ;
65421: CALL 76773 0 0
// if event = 110 then
65425: LD_VAR 0 1
65429: PUSH
65430: LD_INT 110
65432: EQUAL
65433: IFFALSE 65439
// MC_SendAttack ( ) ;
65435: CALL 77239 0 0
// if event = 111 then
65439: LD_VAR 0 1
65443: PUSH
65444: LD_INT 111
65446: EQUAL
65447: IFFALSE 65453
// MC_Defend ( ) ;
65449: CALL 77347 0 0
// if event = 112 then
65453: LD_VAR 0 1
65457: PUSH
65458: LD_INT 112
65460: EQUAL
65461: IFFALSE 65467
// MC_Research ( ) ;
65463: CALL 78227 0 0
// if event = 113 then
65467: LD_VAR 0 1
65471: PUSH
65472: LD_INT 113
65474: EQUAL
65475: IFFALSE 65481
// MC_MinesTrigger ( ) ;
65477: CALL 79341 0 0
// if event = 120 then
65481: LD_VAR 0 1
65485: PUSH
65486: LD_INT 120
65488: EQUAL
65489: IFFALSE 65495
// MC_RepairVehicle ( ) ;
65491: CALL 79440 0 0
// if event = 121 then
65495: LD_VAR 0 1
65499: PUSH
65500: LD_INT 121
65502: EQUAL
65503: IFFALSE 65509
// MC_TameApe ( ) ;
65505: CALL 80209 0 0
// if event = 122 then
65509: LD_VAR 0 1
65513: PUSH
65514: LD_INT 122
65516: EQUAL
65517: IFFALSE 65523
// MC_ChangeApeClass ( ) ;
65519: CALL 81038 0 0
// if event = 123 then
65523: LD_VAR 0 1
65527: PUSH
65528: LD_INT 123
65530: EQUAL
65531: IFFALSE 65537
// MC_Bazooka ( ) ;
65533: CALL 81688 0 0
// if event = 124 then
65537: LD_VAR 0 1
65541: PUSH
65542: LD_INT 124
65544: EQUAL
65545: IFFALSE 65551
// MC_TeleportExit ( ) ;
65547: CALL 81886 0 0
// if event = 125 then
65551: LD_VAR 0 1
65555: PUSH
65556: LD_INT 125
65558: EQUAL
65559: IFFALSE 65565
// MC_Deposits ( ) ;
65561: CALL 82533 0 0
// if event = 126 then
65565: LD_VAR 0 1
65569: PUSH
65570: LD_INT 126
65572: EQUAL
65573: IFFALSE 65579
// MC_RemoteDriver ( ) ;
65575: CALL 83158 0 0
// if event = 200 then
65579: LD_VAR 0 1
65583: PUSH
65584: LD_INT 200
65586: EQUAL
65587: IFFALSE 65593
// MC_Idle ( ) ;
65589: CALL 85065 0 0
// end ;
65593: PPOPN 1
65595: END
// export function MC_Reset ( base , tag ) ; var i ; begin
65596: LD_INT 0
65598: PPUSH
65599: PPUSH
// if not mc_bases [ base ] or not tag then
65600: LD_EXP 31
65604: PUSH
65605: LD_VAR 0 1
65609: ARRAY
65610: NOT
65611: PUSH
65612: LD_VAR 0 2
65616: NOT
65617: OR
65618: IFFALSE 65622
// exit ;
65620: GO 65686
// for i in mc_bases [ base ] union mc_ape [ base ] do
65622: LD_ADDR_VAR 0 4
65626: PUSH
65627: LD_EXP 31
65631: PUSH
65632: LD_VAR 0 1
65636: ARRAY
65637: PUSH
65638: LD_EXP 60
65642: PUSH
65643: LD_VAR 0 1
65647: ARRAY
65648: UNION
65649: PUSH
65650: FOR_IN
65651: IFFALSE 65684
// if GetTag ( i ) = tag then
65653: LD_VAR 0 4
65657: PPUSH
65658: CALL_OW 110
65662: PUSH
65663: LD_VAR 0 2
65667: EQUAL
65668: IFFALSE 65682
// SetTag ( i , 0 ) ;
65670: LD_VAR 0 4
65674: PPUSH
65675: LD_INT 0
65677: PPUSH
65678: CALL_OW 109
65682: GO 65650
65684: POP
65685: POP
// end ;
65686: LD_VAR 0 3
65690: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
65691: LD_INT 0
65693: PPUSH
65694: PPUSH
65695: PPUSH
65696: PPUSH
65697: PPUSH
65698: PPUSH
65699: PPUSH
65700: PPUSH
// if not mc_bases then
65701: LD_EXP 31
65705: NOT
65706: IFFALSE 65710
// exit ;
65708: GO 66159
// for i = 1 to mc_bases do
65710: LD_ADDR_VAR 0 2
65714: PUSH
65715: DOUBLE
65716: LD_INT 1
65718: DEC
65719: ST_TO_ADDR
65720: LD_EXP 31
65724: PUSH
65725: FOR_TO
65726: IFFALSE 66157
// begin tmp := MC_ClassCheckReq ( i ) ;
65728: LD_ADDR_VAR 0 4
65732: PUSH
65733: LD_VAR 0 2
65737: PPUSH
65738: CALL 66164 0 1
65742: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
65743: LD_ADDR_EXP 72
65747: PUSH
65748: LD_EXP 72
65752: PPUSH
65753: LD_VAR 0 2
65757: PPUSH
65758: LD_VAR 0 4
65762: PPUSH
65763: CALL_OW 1
65767: ST_TO_ADDR
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
65768: LD_ADDR_VAR 0 6
65772: PUSH
65773: LD_EXP 31
65777: PUSH
65778: LD_VAR 0 2
65782: ARRAY
65783: PPUSH
65784: LD_INT 2
65786: PUSH
65787: LD_INT 30
65789: PUSH
65790: LD_INT 4
65792: PUSH
65793: EMPTY
65794: LIST
65795: LIST
65796: PUSH
65797: LD_INT 30
65799: PUSH
65800: LD_INT 5
65802: PUSH
65803: EMPTY
65804: LIST
65805: LIST
65806: PUSH
65807: EMPTY
65808: LIST
65809: LIST
65810: LIST
65811: PPUSH
65812: CALL_OW 72
65816: PUSH
65817: LD_EXP 31
65821: PUSH
65822: LD_VAR 0 2
65826: ARRAY
65827: PPUSH
65828: LD_INT 2
65830: PUSH
65831: LD_INT 30
65833: PUSH
65834: LD_INT 0
65836: PUSH
65837: EMPTY
65838: LIST
65839: LIST
65840: PUSH
65841: LD_INT 30
65843: PUSH
65844: LD_INT 1
65846: PUSH
65847: EMPTY
65848: LIST
65849: LIST
65850: PUSH
65851: EMPTY
65852: LIST
65853: LIST
65854: LIST
65855: PPUSH
65856: CALL_OW 72
65860: PUSH
65861: LD_EXP 31
65865: PUSH
65866: LD_VAR 0 2
65870: ARRAY
65871: PPUSH
65872: LD_INT 30
65874: PUSH
65875: LD_INT 3
65877: PUSH
65878: EMPTY
65879: LIST
65880: LIST
65881: PPUSH
65882: CALL_OW 72
65886: PUSH
65887: LD_EXP 31
65891: PUSH
65892: LD_VAR 0 2
65896: ARRAY
65897: PPUSH
65898: LD_INT 2
65900: PUSH
65901: LD_INT 30
65903: PUSH
65904: LD_INT 6
65906: PUSH
65907: EMPTY
65908: LIST
65909: LIST
65910: PUSH
65911: LD_INT 30
65913: PUSH
65914: LD_INT 7
65916: PUSH
65917: EMPTY
65918: LIST
65919: LIST
65920: PUSH
65921: LD_INT 30
65923: PUSH
65924: LD_INT 8
65926: PUSH
65927: EMPTY
65928: LIST
65929: LIST
65930: PUSH
65931: EMPTY
65932: LIST
65933: LIST
65934: LIST
65935: LIST
65936: PPUSH
65937: CALL_OW 72
65941: PUSH
65942: EMPTY
65943: LIST
65944: LIST
65945: LIST
65946: LIST
65947: ST_TO_ADDR
// for j := 1 to 4 do
65948: LD_ADDR_VAR 0 3
65952: PUSH
65953: DOUBLE
65954: LD_INT 1
65956: DEC
65957: ST_TO_ADDR
65958: LD_INT 4
65960: PUSH
65961: FOR_TO
65962: IFFALSE 66153
// begin if not tmp [ j ] then
65964: LD_VAR 0 4
65968: PUSH
65969: LD_VAR 0 3
65973: ARRAY
65974: NOT
65975: IFFALSE 65979
// continue ;
65977: GO 65961
// for p in tmp [ j ] do
65979: LD_ADDR_VAR 0 5
65983: PUSH
65984: LD_VAR 0 4
65988: PUSH
65989: LD_VAR 0 3
65993: ARRAY
65994: PUSH
65995: FOR_IN
65996: IFFALSE 66149
// begin if not b [ j ] then
65998: LD_VAR 0 6
66002: PUSH
66003: LD_VAR 0 3
66007: ARRAY
66008: NOT
66009: IFFALSE 66013
// break ;
66011: GO 66149
// e := 0 ;
66013: LD_ADDR_VAR 0 7
66017: PUSH
66018: LD_INT 0
66020: ST_TO_ADDR
// for k in b [ j ] do
66021: LD_ADDR_VAR 0 8
66025: PUSH
66026: LD_VAR 0 6
66030: PUSH
66031: LD_VAR 0 3
66035: ARRAY
66036: PUSH
66037: FOR_IN
66038: IFFALSE 66065
// if IsNotFull ( k ) then
66040: LD_VAR 0 8
66044: PPUSH
66045: CALL 22068 0 1
66049: IFFALSE 66063
// begin e := k ;
66051: LD_ADDR_VAR 0 7
66055: PUSH
66056: LD_VAR 0 8
66060: ST_TO_ADDR
// break ;
66061: GO 66065
// end ;
66063: GO 66037
66065: POP
66066: POP
// if e and not UnitGoingToBuilding ( p , e ) then
66067: LD_VAR 0 7
66071: PUSH
66072: LD_VAR 0 5
66076: PPUSH
66077: LD_VAR 0 7
66081: PPUSH
66082: CALL 55850 0 2
66086: NOT
66087: AND
66088: IFFALSE 66147
// begin if IsInUnit ( p ) then
66090: LD_VAR 0 5
66094: PPUSH
66095: CALL_OW 310
66099: IFFALSE 66110
// ComExitBuilding ( p ) ;
66101: LD_VAR 0 5
66105: PPUSH
66106: CALL_OW 122
// ComEnterUnit ( p , e ) ;
66110: LD_VAR 0 5
66114: PPUSH
66115: LD_VAR 0 7
66119: PPUSH
66120: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
66124: LD_VAR 0 5
66128: PPUSH
66129: LD_VAR 0 3
66133: PPUSH
66134: CALL_OW 183
// AddComExitBuilding ( p ) ;
66138: LD_VAR 0 5
66142: PPUSH
66143: CALL_OW 182
// end ; end ;
66147: GO 65995
66149: POP
66150: POP
// end ;
66151: GO 65961
66153: POP
66154: POP
// end ;
66155: GO 65725
66157: POP
66158: POP
// end ;
66159: LD_VAR 0 1
66163: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
66164: LD_INT 0
66166: PPUSH
66167: PPUSH
66168: PPUSH
66169: PPUSH
66170: PPUSH
66171: PPUSH
66172: PPUSH
66173: PPUSH
66174: PPUSH
66175: PPUSH
66176: PPUSH
66177: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
66178: LD_ADDR_VAR 0 2
66182: PUSH
66183: LD_INT 0
66185: PUSH
66186: LD_INT 0
66188: PUSH
66189: LD_INT 0
66191: PUSH
66192: LD_INT 0
66194: PUSH
66195: EMPTY
66196: LIST
66197: LIST
66198: LIST
66199: LIST
66200: ST_TO_ADDR
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
66201: LD_VAR 0 1
66205: NOT
66206: PUSH
66207: LD_EXP 31
66211: PUSH
66212: LD_VAR 0 1
66216: ARRAY
66217: NOT
66218: OR
66219: PUSH
66220: LD_EXP 31
66224: PUSH
66225: LD_VAR 0 1
66229: ARRAY
66230: PPUSH
66231: LD_INT 2
66233: PUSH
66234: LD_INT 30
66236: PUSH
66237: LD_INT 0
66239: PUSH
66240: EMPTY
66241: LIST
66242: LIST
66243: PUSH
66244: LD_INT 30
66246: PUSH
66247: LD_INT 1
66249: PUSH
66250: EMPTY
66251: LIST
66252: LIST
66253: PUSH
66254: EMPTY
66255: LIST
66256: LIST
66257: LIST
66258: PPUSH
66259: CALL_OW 72
66263: NOT
66264: OR
66265: IFFALSE 66269
// exit ;
66267: GO 69772
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
66269: LD_ADDR_VAR 0 4
66273: PUSH
66274: LD_EXP 31
66278: PUSH
66279: LD_VAR 0 1
66283: ARRAY
66284: PPUSH
66285: LD_INT 2
66287: PUSH
66288: LD_INT 25
66290: PUSH
66291: LD_INT 1
66293: PUSH
66294: EMPTY
66295: LIST
66296: LIST
66297: PUSH
66298: LD_INT 25
66300: PUSH
66301: LD_INT 2
66303: PUSH
66304: EMPTY
66305: LIST
66306: LIST
66307: PUSH
66308: LD_INT 25
66310: PUSH
66311: LD_INT 3
66313: PUSH
66314: EMPTY
66315: LIST
66316: LIST
66317: PUSH
66318: LD_INT 25
66320: PUSH
66321: LD_INT 4
66323: PUSH
66324: EMPTY
66325: LIST
66326: LIST
66327: PUSH
66328: LD_INT 25
66330: PUSH
66331: LD_INT 5
66333: PUSH
66334: EMPTY
66335: LIST
66336: LIST
66337: PUSH
66338: LD_INT 25
66340: PUSH
66341: LD_INT 8
66343: PUSH
66344: EMPTY
66345: LIST
66346: LIST
66347: PUSH
66348: LD_INT 25
66350: PUSH
66351: LD_INT 9
66353: PUSH
66354: EMPTY
66355: LIST
66356: LIST
66357: PUSH
66358: EMPTY
66359: LIST
66360: LIST
66361: LIST
66362: LIST
66363: LIST
66364: LIST
66365: LIST
66366: LIST
66367: PPUSH
66368: CALL_OW 72
66372: ST_TO_ADDR
// if not tmp then
66373: LD_VAR 0 4
66377: NOT
66378: IFFALSE 66382
// exit ;
66380: GO 69772
// for i in tmp do
66382: LD_ADDR_VAR 0 3
66386: PUSH
66387: LD_VAR 0 4
66391: PUSH
66392: FOR_IN
66393: IFFALSE 66424
// if GetTag ( i ) then
66395: LD_VAR 0 3
66399: PPUSH
66400: CALL_OW 110
66404: IFFALSE 66422
// tmp := tmp diff i ;
66406: LD_ADDR_VAR 0 4
66410: PUSH
66411: LD_VAR 0 4
66415: PUSH
66416: LD_VAR 0 3
66420: DIFF
66421: ST_TO_ADDR
66422: GO 66392
66424: POP
66425: POP
// if not tmp then
66426: LD_VAR 0 4
66430: NOT
66431: IFFALSE 66435
// exit ;
66433: GO 69772
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
66435: LD_ADDR_VAR 0 5
66439: PUSH
66440: LD_EXP 31
66444: PUSH
66445: LD_VAR 0 1
66449: ARRAY
66450: PPUSH
66451: LD_INT 2
66453: PUSH
66454: LD_INT 25
66456: PUSH
66457: LD_INT 1
66459: PUSH
66460: EMPTY
66461: LIST
66462: LIST
66463: PUSH
66464: LD_INT 25
66466: PUSH
66467: LD_INT 5
66469: PUSH
66470: EMPTY
66471: LIST
66472: LIST
66473: PUSH
66474: LD_INT 25
66476: PUSH
66477: LD_INT 8
66479: PUSH
66480: EMPTY
66481: LIST
66482: LIST
66483: PUSH
66484: LD_INT 25
66486: PUSH
66487: LD_INT 9
66489: PUSH
66490: EMPTY
66491: LIST
66492: LIST
66493: PUSH
66494: EMPTY
66495: LIST
66496: LIST
66497: LIST
66498: LIST
66499: LIST
66500: PPUSH
66501: CALL_OW 72
66505: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
66506: LD_ADDR_VAR 0 6
66510: PUSH
66511: LD_EXP 31
66515: PUSH
66516: LD_VAR 0 1
66520: ARRAY
66521: PPUSH
66522: LD_INT 25
66524: PUSH
66525: LD_INT 2
66527: PUSH
66528: EMPTY
66529: LIST
66530: LIST
66531: PPUSH
66532: CALL_OW 72
66536: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
66537: LD_ADDR_VAR 0 7
66541: PUSH
66542: LD_EXP 31
66546: PUSH
66547: LD_VAR 0 1
66551: ARRAY
66552: PPUSH
66553: LD_INT 25
66555: PUSH
66556: LD_INT 3
66558: PUSH
66559: EMPTY
66560: LIST
66561: LIST
66562: PPUSH
66563: CALL_OW 72
66567: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
66568: LD_ADDR_VAR 0 8
66572: PUSH
66573: LD_EXP 31
66577: PUSH
66578: LD_VAR 0 1
66582: ARRAY
66583: PPUSH
66584: LD_INT 25
66586: PUSH
66587: LD_INT 4
66589: PUSH
66590: EMPTY
66591: LIST
66592: LIST
66593: PUSH
66594: LD_INT 24
66596: PUSH
66597: LD_INT 251
66599: PUSH
66600: EMPTY
66601: LIST
66602: LIST
66603: PUSH
66604: EMPTY
66605: LIST
66606: LIST
66607: PPUSH
66608: CALL_OW 72
66612: ST_TO_ADDR
// if mc_is_defending [ base ] then
66613: LD_EXP 74
66617: PUSH
66618: LD_VAR 0 1
66622: ARRAY
66623: IFFALSE 67084
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
66625: LD_ADDR_EXP 73
66629: PUSH
66630: LD_EXP 73
66634: PPUSH
66635: LD_VAR 0 1
66639: PPUSH
66640: LD_INT 4
66642: PPUSH
66643: CALL_OW 1
66647: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
66648: LD_ADDR_VAR 0 12
66652: PUSH
66653: LD_EXP 31
66657: PUSH
66658: LD_VAR 0 1
66662: ARRAY
66663: PPUSH
66664: LD_INT 2
66666: PUSH
66667: LD_INT 30
66669: PUSH
66670: LD_INT 4
66672: PUSH
66673: EMPTY
66674: LIST
66675: LIST
66676: PUSH
66677: LD_INT 30
66679: PUSH
66680: LD_INT 5
66682: PUSH
66683: EMPTY
66684: LIST
66685: LIST
66686: PUSH
66687: EMPTY
66688: LIST
66689: LIST
66690: LIST
66691: PPUSH
66692: CALL_OW 72
66696: ST_TO_ADDR
// if not b then
66697: LD_VAR 0 12
66701: NOT
66702: IFFALSE 66706
// exit ;
66704: GO 69772
// p := [ ] ;
66706: LD_ADDR_VAR 0 11
66710: PUSH
66711: EMPTY
66712: ST_TO_ADDR
// if sci >= 2 then
66713: LD_VAR 0 8
66717: PUSH
66718: LD_INT 2
66720: GREATEREQUAL
66721: IFFALSE 66752
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
66723: LD_ADDR_VAR 0 8
66727: PUSH
66728: LD_VAR 0 8
66732: PUSH
66733: LD_INT 1
66735: ARRAY
66736: PUSH
66737: LD_VAR 0 8
66741: PUSH
66742: LD_INT 2
66744: ARRAY
66745: PUSH
66746: EMPTY
66747: LIST
66748: LIST
66749: ST_TO_ADDR
66750: GO 66813
// if sci = 1 then
66752: LD_VAR 0 8
66756: PUSH
66757: LD_INT 1
66759: EQUAL
66760: IFFALSE 66781
// sci := [ sci [ 1 ] ] else
66762: LD_ADDR_VAR 0 8
66766: PUSH
66767: LD_VAR 0 8
66771: PUSH
66772: LD_INT 1
66774: ARRAY
66775: PUSH
66776: EMPTY
66777: LIST
66778: ST_TO_ADDR
66779: GO 66813
// if sci = 0 then
66781: LD_VAR 0 8
66785: PUSH
66786: LD_INT 0
66788: EQUAL
66789: IFFALSE 66813
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
66791: LD_ADDR_VAR 0 11
66795: PUSH
66796: LD_VAR 0 4
66800: PPUSH
66801: LD_INT 4
66803: PPUSH
66804: CALL 55722 0 2
66808: PUSH
66809: LD_INT 1
66811: ARRAY
66812: ST_TO_ADDR
// if eng > 4 then
66813: LD_VAR 0 6
66817: PUSH
66818: LD_INT 4
66820: GREATER
66821: IFFALSE 66867
// for i = eng downto 4 do
66823: LD_ADDR_VAR 0 3
66827: PUSH
66828: DOUBLE
66829: LD_VAR 0 6
66833: INC
66834: ST_TO_ADDR
66835: LD_INT 4
66837: PUSH
66838: FOR_DOWNTO
66839: IFFALSE 66865
// eng := eng diff eng [ i ] ;
66841: LD_ADDR_VAR 0 6
66845: PUSH
66846: LD_VAR 0 6
66850: PUSH
66851: LD_VAR 0 6
66855: PUSH
66856: LD_VAR 0 3
66860: ARRAY
66861: DIFF
66862: ST_TO_ADDR
66863: GO 66838
66865: POP
66866: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
66867: LD_ADDR_VAR 0 4
66871: PUSH
66872: LD_VAR 0 4
66876: PUSH
66877: LD_VAR 0 5
66881: PUSH
66882: LD_VAR 0 6
66886: UNION
66887: PUSH
66888: LD_VAR 0 7
66892: UNION
66893: PUSH
66894: LD_VAR 0 8
66898: UNION
66899: DIFF
66900: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
66901: LD_ADDR_VAR 0 13
66905: PUSH
66906: LD_EXP 31
66910: PUSH
66911: LD_VAR 0 1
66915: ARRAY
66916: PPUSH
66917: LD_INT 2
66919: PUSH
66920: LD_INT 30
66922: PUSH
66923: LD_INT 32
66925: PUSH
66926: EMPTY
66927: LIST
66928: LIST
66929: PUSH
66930: LD_INT 30
66932: PUSH
66933: LD_INT 31
66935: PUSH
66936: EMPTY
66937: LIST
66938: LIST
66939: PUSH
66940: EMPTY
66941: LIST
66942: LIST
66943: LIST
66944: PPUSH
66945: CALL_OW 72
66949: PUSH
66950: LD_EXP 31
66954: PUSH
66955: LD_VAR 0 1
66959: ARRAY
66960: PPUSH
66961: LD_INT 2
66963: PUSH
66964: LD_INT 30
66966: PUSH
66967: LD_INT 4
66969: PUSH
66970: EMPTY
66971: LIST
66972: LIST
66973: PUSH
66974: LD_INT 30
66976: PUSH
66977: LD_INT 5
66979: PUSH
66980: EMPTY
66981: LIST
66982: LIST
66983: PUSH
66984: EMPTY
66985: LIST
66986: LIST
66987: LIST
66988: PPUSH
66989: CALL_OW 72
66993: PUSH
66994: LD_INT 6
66996: MUL
66997: PLUS
66998: ST_TO_ADDR
// if bcount < tmp then
66999: LD_VAR 0 13
67003: PUSH
67004: LD_VAR 0 4
67008: LESS
67009: IFFALSE 67055
// for i = tmp downto bcount do
67011: LD_ADDR_VAR 0 3
67015: PUSH
67016: DOUBLE
67017: LD_VAR 0 4
67021: INC
67022: ST_TO_ADDR
67023: LD_VAR 0 13
67027: PUSH
67028: FOR_DOWNTO
67029: IFFALSE 67053
// tmp := Delete ( tmp , tmp ) ;
67031: LD_ADDR_VAR 0 4
67035: PUSH
67036: LD_VAR 0 4
67040: PPUSH
67041: LD_VAR 0 4
67045: PPUSH
67046: CALL_OW 3
67050: ST_TO_ADDR
67051: GO 67028
67053: POP
67054: POP
// result := [ tmp , 0 , 0 , p ] ;
67055: LD_ADDR_VAR 0 2
67059: PUSH
67060: LD_VAR 0 4
67064: PUSH
67065: LD_INT 0
67067: PUSH
67068: LD_INT 0
67070: PUSH
67071: LD_VAR 0 11
67075: PUSH
67076: EMPTY
67077: LIST
67078: LIST
67079: LIST
67080: LIST
67081: ST_TO_ADDR
// exit ;
67082: GO 69772
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
67084: LD_EXP 31
67088: PUSH
67089: LD_VAR 0 1
67093: ARRAY
67094: PPUSH
67095: LD_INT 2
67097: PUSH
67098: LD_INT 30
67100: PUSH
67101: LD_INT 6
67103: PUSH
67104: EMPTY
67105: LIST
67106: LIST
67107: PUSH
67108: LD_INT 30
67110: PUSH
67111: LD_INT 7
67113: PUSH
67114: EMPTY
67115: LIST
67116: LIST
67117: PUSH
67118: LD_INT 30
67120: PUSH
67121: LD_INT 8
67123: PUSH
67124: EMPTY
67125: LIST
67126: LIST
67127: PUSH
67128: EMPTY
67129: LIST
67130: LIST
67131: LIST
67132: LIST
67133: PPUSH
67134: CALL_OW 72
67138: NOT
67139: PUSH
67140: LD_EXP 31
67144: PUSH
67145: LD_VAR 0 1
67149: ARRAY
67150: PPUSH
67151: LD_INT 30
67153: PUSH
67154: LD_INT 3
67156: PUSH
67157: EMPTY
67158: LIST
67159: LIST
67160: PPUSH
67161: CALL_OW 72
67165: NOT
67166: AND
67167: IFFALSE 67239
// begin if eng = tmp then
67169: LD_VAR 0 6
67173: PUSH
67174: LD_VAR 0 4
67178: EQUAL
67179: IFFALSE 67183
// exit ;
67181: GO 69772
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
67183: LD_ADDR_EXP 73
67187: PUSH
67188: LD_EXP 73
67192: PPUSH
67193: LD_VAR 0 1
67197: PPUSH
67198: LD_INT 1
67200: PPUSH
67201: CALL_OW 1
67205: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
67206: LD_ADDR_VAR 0 2
67210: PUSH
67211: LD_INT 0
67213: PUSH
67214: LD_VAR 0 4
67218: PUSH
67219: LD_VAR 0 6
67223: DIFF
67224: PUSH
67225: LD_INT 0
67227: PUSH
67228: LD_INT 0
67230: PUSH
67231: EMPTY
67232: LIST
67233: LIST
67234: LIST
67235: LIST
67236: ST_TO_ADDR
// exit ;
67237: GO 69772
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
67239: LD_EXP 58
67243: PUSH
67244: LD_EXP 57
67248: PUSH
67249: LD_VAR 0 1
67253: ARRAY
67254: ARRAY
67255: PUSH
67256: LD_EXP 31
67260: PUSH
67261: LD_VAR 0 1
67265: ARRAY
67266: PPUSH
67267: LD_INT 2
67269: PUSH
67270: LD_INT 30
67272: PUSH
67273: LD_INT 6
67275: PUSH
67276: EMPTY
67277: LIST
67278: LIST
67279: PUSH
67280: LD_INT 30
67282: PUSH
67283: LD_INT 7
67285: PUSH
67286: EMPTY
67287: LIST
67288: LIST
67289: PUSH
67290: LD_INT 30
67292: PUSH
67293: LD_INT 8
67295: PUSH
67296: EMPTY
67297: LIST
67298: LIST
67299: PUSH
67300: EMPTY
67301: LIST
67302: LIST
67303: LIST
67304: LIST
67305: PPUSH
67306: CALL_OW 72
67310: AND
67311: PUSH
67312: LD_EXP 31
67316: PUSH
67317: LD_VAR 0 1
67321: ARRAY
67322: PPUSH
67323: LD_INT 30
67325: PUSH
67326: LD_INT 3
67328: PUSH
67329: EMPTY
67330: LIST
67331: LIST
67332: PPUSH
67333: CALL_OW 72
67337: NOT
67338: AND
67339: IFFALSE 67553
// begin if sci >= 6 then
67341: LD_VAR 0 8
67345: PUSH
67346: LD_INT 6
67348: GREATEREQUAL
67349: IFFALSE 67353
// exit ;
67351: GO 69772
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
67353: LD_ADDR_EXP 73
67357: PUSH
67358: LD_EXP 73
67362: PPUSH
67363: LD_VAR 0 1
67367: PPUSH
67368: LD_INT 2
67370: PPUSH
67371: CALL_OW 1
67375: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
67376: LD_ADDR_VAR 0 9
67380: PUSH
67381: LD_VAR 0 4
67385: PUSH
67386: LD_VAR 0 8
67390: DIFF
67391: PPUSH
67392: LD_INT 4
67394: PPUSH
67395: CALL 55722 0 2
67399: ST_TO_ADDR
// p := [ ] ;
67400: LD_ADDR_VAR 0 11
67404: PUSH
67405: EMPTY
67406: ST_TO_ADDR
// if sci < 6 and sort > 6 then
67407: LD_VAR 0 8
67411: PUSH
67412: LD_INT 6
67414: LESS
67415: PUSH
67416: LD_VAR 0 9
67420: PUSH
67421: LD_INT 6
67423: GREATER
67424: AND
67425: IFFALSE 67506
// begin for i = 1 to 6 - sci do
67427: LD_ADDR_VAR 0 3
67431: PUSH
67432: DOUBLE
67433: LD_INT 1
67435: DEC
67436: ST_TO_ADDR
67437: LD_INT 6
67439: PUSH
67440: LD_VAR 0 8
67444: MINUS
67445: PUSH
67446: FOR_TO
67447: IFFALSE 67502
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
67449: LD_ADDR_VAR 0 11
67453: PUSH
67454: LD_VAR 0 11
67458: PPUSH
67459: LD_VAR 0 11
67463: PUSH
67464: LD_INT 1
67466: PLUS
67467: PPUSH
67468: LD_VAR 0 9
67472: PUSH
67473: LD_INT 1
67475: ARRAY
67476: PPUSH
67477: CALL_OW 2
67481: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
67482: LD_ADDR_VAR 0 9
67486: PUSH
67487: LD_VAR 0 9
67491: PPUSH
67492: LD_INT 1
67494: PPUSH
67495: CALL_OW 3
67499: ST_TO_ADDR
// end ;
67500: GO 67446
67502: POP
67503: POP
// end else
67504: GO 67526
// if sort then
67506: LD_VAR 0 9
67510: IFFALSE 67526
// p := sort [ 1 ] ;
67512: LD_ADDR_VAR 0 11
67516: PUSH
67517: LD_VAR 0 9
67521: PUSH
67522: LD_INT 1
67524: ARRAY
67525: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
67526: LD_ADDR_VAR 0 2
67530: PUSH
67531: LD_INT 0
67533: PUSH
67534: LD_INT 0
67536: PUSH
67537: LD_INT 0
67539: PUSH
67540: LD_VAR 0 11
67544: PUSH
67545: EMPTY
67546: LIST
67547: LIST
67548: LIST
67549: LIST
67550: ST_TO_ADDR
// exit ;
67551: GO 69772
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
67553: LD_EXP 58
67557: PUSH
67558: LD_EXP 57
67562: PUSH
67563: LD_VAR 0 1
67567: ARRAY
67568: ARRAY
67569: PUSH
67570: LD_EXP 31
67574: PUSH
67575: LD_VAR 0 1
67579: ARRAY
67580: PPUSH
67581: LD_INT 2
67583: PUSH
67584: LD_INT 30
67586: PUSH
67587: LD_INT 6
67589: PUSH
67590: EMPTY
67591: LIST
67592: LIST
67593: PUSH
67594: LD_INT 30
67596: PUSH
67597: LD_INT 7
67599: PUSH
67600: EMPTY
67601: LIST
67602: LIST
67603: PUSH
67604: LD_INT 30
67606: PUSH
67607: LD_INT 8
67609: PUSH
67610: EMPTY
67611: LIST
67612: LIST
67613: PUSH
67614: EMPTY
67615: LIST
67616: LIST
67617: LIST
67618: LIST
67619: PPUSH
67620: CALL_OW 72
67624: AND
67625: PUSH
67626: LD_EXP 31
67630: PUSH
67631: LD_VAR 0 1
67635: ARRAY
67636: PPUSH
67637: LD_INT 30
67639: PUSH
67640: LD_INT 3
67642: PUSH
67643: EMPTY
67644: LIST
67645: LIST
67646: PPUSH
67647: CALL_OW 72
67651: AND
67652: IFFALSE 68386
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
67654: LD_ADDR_EXP 73
67658: PUSH
67659: LD_EXP 73
67663: PPUSH
67664: LD_VAR 0 1
67668: PPUSH
67669: LD_INT 3
67671: PPUSH
67672: CALL_OW 1
67676: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
67677: LD_ADDR_VAR 0 2
67681: PUSH
67682: LD_INT 0
67684: PUSH
67685: LD_INT 0
67687: PUSH
67688: LD_INT 0
67690: PUSH
67691: LD_INT 0
67693: PUSH
67694: EMPTY
67695: LIST
67696: LIST
67697: LIST
67698: LIST
67699: ST_TO_ADDR
// if not eng then
67700: LD_VAR 0 6
67704: NOT
67705: IFFALSE 67768
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
67707: LD_ADDR_VAR 0 11
67711: PUSH
67712: LD_VAR 0 4
67716: PPUSH
67717: LD_INT 2
67719: PPUSH
67720: CALL 55722 0 2
67724: PUSH
67725: LD_INT 1
67727: ARRAY
67728: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
67729: LD_ADDR_VAR 0 2
67733: PUSH
67734: LD_VAR 0 2
67738: PPUSH
67739: LD_INT 2
67741: PPUSH
67742: LD_VAR 0 11
67746: PPUSH
67747: CALL_OW 1
67751: ST_TO_ADDR
// tmp := tmp diff p ;
67752: LD_ADDR_VAR 0 4
67756: PUSH
67757: LD_VAR 0 4
67761: PUSH
67762: LD_VAR 0 11
67766: DIFF
67767: ST_TO_ADDR
// end ; if tmp and sci < 6 then
67768: LD_VAR 0 4
67772: PUSH
67773: LD_VAR 0 8
67777: PUSH
67778: LD_INT 6
67780: LESS
67781: AND
67782: IFFALSE 67970
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
67784: LD_ADDR_VAR 0 9
67788: PUSH
67789: LD_VAR 0 4
67793: PUSH
67794: LD_VAR 0 8
67798: PUSH
67799: LD_VAR 0 7
67803: UNION
67804: DIFF
67805: PPUSH
67806: LD_INT 4
67808: PPUSH
67809: CALL 55722 0 2
67813: ST_TO_ADDR
// p := [ ] ;
67814: LD_ADDR_VAR 0 11
67818: PUSH
67819: EMPTY
67820: ST_TO_ADDR
// if sort then
67821: LD_VAR 0 9
67825: IFFALSE 67941
// for i = 1 to 6 - sci do
67827: LD_ADDR_VAR 0 3
67831: PUSH
67832: DOUBLE
67833: LD_INT 1
67835: DEC
67836: ST_TO_ADDR
67837: LD_INT 6
67839: PUSH
67840: LD_VAR 0 8
67844: MINUS
67845: PUSH
67846: FOR_TO
67847: IFFALSE 67939
// begin if i = sort then
67849: LD_VAR 0 3
67853: PUSH
67854: LD_VAR 0 9
67858: EQUAL
67859: IFFALSE 67863
// break ;
67861: GO 67939
// if GetClass ( i ) = 4 then
67863: LD_VAR 0 3
67867: PPUSH
67868: CALL_OW 257
67872: PUSH
67873: LD_INT 4
67875: EQUAL
67876: IFFALSE 67880
// continue ;
67878: GO 67846
// p := Insert ( p , p + 1 , sort [ i ] ) ;
67880: LD_ADDR_VAR 0 11
67884: PUSH
67885: LD_VAR 0 11
67889: PPUSH
67890: LD_VAR 0 11
67894: PUSH
67895: LD_INT 1
67897: PLUS
67898: PPUSH
67899: LD_VAR 0 9
67903: PUSH
67904: LD_VAR 0 3
67908: ARRAY
67909: PPUSH
67910: CALL_OW 2
67914: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
67915: LD_ADDR_VAR 0 4
67919: PUSH
67920: LD_VAR 0 4
67924: PUSH
67925: LD_VAR 0 9
67929: PUSH
67930: LD_VAR 0 3
67934: ARRAY
67935: DIFF
67936: ST_TO_ADDR
// end ;
67937: GO 67846
67939: POP
67940: POP
// if p then
67941: LD_VAR 0 11
67945: IFFALSE 67970
// result := Replace ( result , 4 , p ) ;
67947: LD_ADDR_VAR 0 2
67951: PUSH
67952: LD_VAR 0 2
67956: PPUSH
67957: LD_INT 4
67959: PPUSH
67960: LD_VAR 0 11
67964: PPUSH
67965: CALL_OW 1
67969: ST_TO_ADDR
// end ; if tmp and mech < 6 then
67970: LD_VAR 0 4
67974: PUSH
67975: LD_VAR 0 7
67979: PUSH
67980: LD_INT 6
67982: LESS
67983: AND
67984: IFFALSE 68172
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
67986: LD_ADDR_VAR 0 9
67990: PUSH
67991: LD_VAR 0 4
67995: PUSH
67996: LD_VAR 0 8
68000: PUSH
68001: LD_VAR 0 7
68005: UNION
68006: DIFF
68007: PPUSH
68008: LD_INT 3
68010: PPUSH
68011: CALL 55722 0 2
68015: ST_TO_ADDR
// p := [ ] ;
68016: LD_ADDR_VAR 0 11
68020: PUSH
68021: EMPTY
68022: ST_TO_ADDR
// if sort then
68023: LD_VAR 0 9
68027: IFFALSE 68143
// for i = 1 to 6 - mech do
68029: LD_ADDR_VAR 0 3
68033: PUSH
68034: DOUBLE
68035: LD_INT 1
68037: DEC
68038: ST_TO_ADDR
68039: LD_INT 6
68041: PUSH
68042: LD_VAR 0 7
68046: MINUS
68047: PUSH
68048: FOR_TO
68049: IFFALSE 68141
// begin if i = sort then
68051: LD_VAR 0 3
68055: PUSH
68056: LD_VAR 0 9
68060: EQUAL
68061: IFFALSE 68065
// break ;
68063: GO 68141
// if GetClass ( i ) = 3 then
68065: LD_VAR 0 3
68069: PPUSH
68070: CALL_OW 257
68074: PUSH
68075: LD_INT 3
68077: EQUAL
68078: IFFALSE 68082
// continue ;
68080: GO 68048
// p := Insert ( p , p + 1 , sort [ i ] ) ;
68082: LD_ADDR_VAR 0 11
68086: PUSH
68087: LD_VAR 0 11
68091: PPUSH
68092: LD_VAR 0 11
68096: PUSH
68097: LD_INT 1
68099: PLUS
68100: PPUSH
68101: LD_VAR 0 9
68105: PUSH
68106: LD_VAR 0 3
68110: ARRAY
68111: PPUSH
68112: CALL_OW 2
68116: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
68117: LD_ADDR_VAR 0 4
68121: PUSH
68122: LD_VAR 0 4
68126: PUSH
68127: LD_VAR 0 9
68131: PUSH
68132: LD_VAR 0 3
68136: ARRAY
68137: DIFF
68138: ST_TO_ADDR
// end ;
68139: GO 68048
68141: POP
68142: POP
// if p then
68143: LD_VAR 0 11
68147: IFFALSE 68172
// result := Replace ( result , 3 , p ) ;
68149: LD_ADDR_VAR 0 2
68153: PUSH
68154: LD_VAR 0 2
68158: PPUSH
68159: LD_INT 3
68161: PPUSH
68162: LD_VAR 0 11
68166: PPUSH
68167: CALL_OW 1
68171: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
68172: LD_VAR 0 4
68176: PUSH
68177: LD_INT 6
68179: GREATER
68180: PUSH
68181: LD_VAR 0 6
68185: PUSH
68186: LD_INT 6
68188: LESS
68189: AND
68190: IFFALSE 68384
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
68192: LD_ADDR_VAR 0 9
68196: PUSH
68197: LD_VAR 0 4
68201: PUSH
68202: LD_VAR 0 8
68206: PUSH
68207: LD_VAR 0 7
68211: UNION
68212: PUSH
68213: LD_VAR 0 6
68217: UNION
68218: DIFF
68219: PPUSH
68220: LD_INT 2
68222: PPUSH
68223: CALL 55722 0 2
68227: ST_TO_ADDR
// p := [ ] ;
68228: LD_ADDR_VAR 0 11
68232: PUSH
68233: EMPTY
68234: ST_TO_ADDR
// if sort then
68235: LD_VAR 0 9
68239: IFFALSE 68355
// for i = 1 to 6 - eng do
68241: LD_ADDR_VAR 0 3
68245: PUSH
68246: DOUBLE
68247: LD_INT 1
68249: DEC
68250: ST_TO_ADDR
68251: LD_INT 6
68253: PUSH
68254: LD_VAR 0 6
68258: MINUS
68259: PUSH
68260: FOR_TO
68261: IFFALSE 68353
// begin if i = sort then
68263: LD_VAR 0 3
68267: PUSH
68268: LD_VAR 0 9
68272: EQUAL
68273: IFFALSE 68277
// break ;
68275: GO 68353
// if GetClass ( i ) = 2 then
68277: LD_VAR 0 3
68281: PPUSH
68282: CALL_OW 257
68286: PUSH
68287: LD_INT 2
68289: EQUAL
68290: IFFALSE 68294
// continue ;
68292: GO 68260
// p := Insert ( p , p + 1 , sort [ i ] ) ;
68294: LD_ADDR_VAR 0 11
68298: PUSH
68299: LD_VAR 0 11
68303: PPUSH
68304: LD_VAR 0 11
68308: PUSH
68309: LD_INT 1
68311: PLUS
68312: PPUSH
68313: LD_VAR 0 9
68317: PUSH
68318: LD_VAR 0 3
68322: ARRAY
68323: PPUSH
68324: CALL_OW 2
68328: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
68329: LD_ADDR_VAR 0 4
68333: PUSH
68334: LD_VAR 0 4
68338: PUSH
68339: LD_VAR 0 9
68343: PUSH
68344: LD_VAR 0 3
68348: ARRAY
68349: DIFF
68350: ST_TO_ADDR
// end ;
68351: GO 68260
68353: POP
68354: POP
// if p then
68355: LD_VAR 0 11
68359: IFFALSE 68384
// result := Replace ( result , 2 , p ) ;
68361: LD_ADDR_VAR 0 2
68365: PUSH
68366: LD_VAR 0 2
68370: PPUSH
68371: LD_INT 2
68373: PPUSH
68374: LD_VAR 0 11
68378: PPUSH
68379: CALL_OW 1
68383: ST_TO_ADDR
// end ; exit ;
68384: GO 69772
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
68386: LD_EXP 58
68390: PUSH
68391: LD_EXP 57
68395: PUSH
68396: LD_VAR 0 1
68400: ARRAY
68401: ARRAY
68402: NOT
68403: PUSH
68404: LD_EXP 31
68408: PUSH
68409: LD_VAR 0 1
68413: ARRAY
68414: PPUSH
68415: LD_INT 30
68417: PUSH
68418: LD_INT 3
68420: PUSH
68421: EMPTY
68422: LIST
68423: LIST
68424: PPUSH
68425: CALL_OW 72
68429: AND
68430: PUSH
68431: LD_EXP 36
68435: PUSH
68436: LD_VAR 0 1
68440: ARRAY
68441: AND
68442: IFFALSE 69050
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
68444: LD_ADDR_EXP 73
68448: PUSH
68449: LD_EXP 73
68453: PPUSH
68454: LD_VAR 0 1
68458: PPUSH
68459: LD_INT 5
68461: PPUSH
68462: CALL_OW 1
68466: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
68467: LD_ADDR_VAR 0 2
68471: PUSH
68472: LD_INT 0
68474: PUSH
68475: LD_INT 0
68477: PUSH
68478: LD_INT 0
68480: PUSH
68481: LD_INT 0
68483: PUSH
68484: EMPTY
68485: LIST
68486: LIST
68487: LIST
68488: LIST
68489: ST_TO_ADDR
// if sci > 1 then
68490: LD_VAR 0 8
68494: PUSH
68495: LD_INT 1
68497: GREATER
68498: IFFALSE 68526
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
68500: LD_ADDR_VAR 0 4
68504: PUSH
68505: LD_VAR 0 4
68509: PUSH
68510: LD_VAR 0 8
68514: PUSH
68515: LD_VAR 0 8
68519: PUSH
68520: LD_INT 1
68522: ARRAY
68523: DIFF
68524: DIFF
68525: ST_TO_ADDR
// if tmp and not sci then
68526: LD_VAR 0 4
68530: PUSH
68531: LD_VAR 0 8
68535: NOT
68536: AND
68537: IFFALSE 68606
// begin sort := SortBySkill ( tmp , 4 ) ;
68539: LD_ADDR_VAR 0 9
68543: PUSH
68544: LD_VAR 0 4
68548: PPUSH
68549: LD_INT 4
68551: PPUSH
68552: CALL 55722 0 2
68556: ST_TO_ADDR
// if sort then
68557: LD_VAR 0 9
68561: IFFALSE 68577
// p := sort [ 1 ] ;
68563: LD_ADDR_VAR 0 11
68567: PUSH
68568: LD_VAR 0 9
68572: PUSH
68573: LD_INT 1
68575: ARRAY
68576: ST_TO_ADDR
// if p then
68577: LD_VAR 0 11
68581: IFFALSE 68606
// result := Replace ( result , 4 , p ) ;
68583: LD_ADDR_VAR 0 2
68587: PUSH
68588: LD_VAR 0 2
68592: PPUSH
68593: LD_INT 4
68595: PPUSH
68596: LD_VAR 0 11
68600: PPUSH
68601: CALL_OW 1
68605: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
68606: LD_ADDR_VAR 0 4
68610: PUSH
68611: LD_VAR 0 4
68615: PUSH
68616: LD_VAR 0 7
68620: DIFF
68621: ST_TO_ADDR
// if tmp and mech < 6 then
68622: LD_VAR 0 4
68626: PUSH
68627: LD_VAR 0 7
68631: PUSH
68632: LD_INT 6
68634: LESS
68635: AND
68636: IFFALSE 68824
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
68638: LD_ADDR_VAR 0 9
68642: PUSH
68643: LD_VAR 0 4
68647: PUSH
68648: LD_VAR 0 8
68652: PUSH
68653: LD_VAR 0 7
68657: UNION
68658: DIFF
68659: PPUSH
68660: LD_INT 3
68662: PPUSH
68663: CALL 55722 0 2
68667: ST_TO_ADDR
// p := [ ] ;
68668: LD_ADDR_VAR 0 11
68672: PUSH
68673: EMPTY
68674: ST_TO_ADDR
// if sort then
68675: LD_VAR 0 9
68679: IFFALSE 68795
// for i = 1 to 6 - mech do
68681: LD_ADDR_VAR 0 3
68685: PUSH
68686: DOUBLE
68687: LD_INT 1
68689: DEC
68690: ST_TO_ADDR
68691: LD_INT 6
68693: PUSH
68694: LD_VAR 0 7
68698: MINUS
68699: PUSH
68700: FOR_TO
68701: IFFALSE 68793
// begin if i = sort then
68703: LD_VAR 0 3
68707: PUSH
68708: LD_VAR 0 9
68712: EQUAL
68713: IFFALSE 68717
// break ;
68715: GO 68793
// if GetClass ( i ) = 3 then
68717: LD_VAR 0 3
68721: PPUSH
68722: CALL_OW 257
68726: PUSH
68727: LD_INT 3
68729: EQUAL
68730: IFFALSE 68734
// continue ;
68732: GO 68700
// p := Insert ( p , p + 1 , sort [ i ] ) ;
68734: LD_ADDR_VAR 0 11
68738: PUSH
68739: LD_VAR 0 11
68743: PPUSH
68744: LD_VAR 0 11
68748: PUSH
68749: LD_INT 1
68751: PLUS
68752: PPUSH
68753: LD_VAR 0 9
68757: PUSH
68758: LD_VAR 0 3
68762: ARRAY
68763: PPUSH
68764: CALL_OW 2
68768: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
68769: LD_ADDR_VAR 0 4
68773: PUSH
68774: LD_VAR 0 4
68778: PUSH
68779: LD_VAR 0 9
68783: PUSH
68784: LD_VAR 0 3
68788: ARRAY
68789: DIFF
68790: ST_TO_ADDR
// end ;
68791: GO 68700
68793: POP
68794: POP
// if p then
68795: LD_VAR 0 11
68799: IFFALSE 68824
// result := Replace ( result , 3 , p ) ;
68801: LD_ADDR_VAR 0 2
68805: PUSH
68806: LD_VAR 0 2
68810: PPUSH
68811: LD_INT 3
68813: PPUSH
68814: LD_VAR 0 11
68818: PPUSH
68819: CALL_OW 1
68823: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
68824: LD_ADDR_VAR 0 4
68828: PUSH
68829: LD_VAR 0 4
68833: PUSH
68834: LD_VAR 0 6
68838: DIFF
68839: ST_TO_ADDR
// if tmp and eng < 6 then
68840: LD_VAR 0 4
68844: PUSH
68845: LD_VAR 0 6
68849: PUSH
68850: LD_INT 6
68852: LESS
68853: AND
68854: IFFALSE 69048
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
68856: LD_ADDR_VAR 0 9
68860: PUSH
68861: LD_VAR 0 4
68865: PUSH
68866: LD_VAR 0 8
68870: PUSH
68871: LD_VAR 0 7
68875: UNION
68876: PUSH
68877: LD_VAR 0 6
68881: UNION
68882: DIFF
68883: PPUSH
68884: LD_INT 2
68886: PPUSH
68887: CALL 55722 0 2
68891: ST_TO_ADDR
// p := [ ] ;
68892: LD_ADDR_VAR 0 11
68896: PUSH
68897: EMPTY
68898: ST_TO_ADDR
// if sort then
68899: LD_VAR 0 9
68903: IFFALSE 69019
// for i = 1 to 6 - eng do
68905: LD_ADDR_VAR 0 3
68909: PUSH
68910: DOUBLE
68911: LD_INT 1
68913: DEC
68914: ST_TO_ADDR
68915: LD_INT 6
68917: PUSH
68918: LD_VAR 0 6
68922: MINUS
68923: PUSH
68924: FOR_TO
68925: IFFALSE 69017
// begin if i = sort then
68927: LD_VAR 0 3
68931: PUSH
68932: LD_VAR 0 9
68936: EQUAL
68937: IFFALSE 68941
// break ;
68939: GO 69017
// if GetClass ( i ) = 2 then
68941: LD_VAR 0 3
68945: PPUSH
68946: CALL_OW 257
68950: PUSH
68951: LD_INT 2
68953: EQUAL
68954: IFFALSE 68958
// continue ;
68956: GO 68924
// p := Insert ( p , p + 1 , sort [ i ] ) ;
68958: LD_ADDR_VAR 0 11
68962: PUSH
68963: LD_VAR 0 11
68967: PPUSH
68968: LD_VAR 0 11
68972: PUSH
68973: LD_INT 1
68975: PLUS
68976: PPUSH
68977: LD_VAR 0 9
68981: PUSH
68982: LD_VAR 0 3
68986: ARRAY
68987: PPUSH
68988: CALL_OW 2
68992: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
68993: LD_ADDR_VAR 0 4
68997: PUSH
68998: LD_VAR 0 4
69002: PUSH
69003: LD_VAR 0 9
69007: PUSH
69008: LD_VAR 0 3
69012: ARRAY
69013: DIFF
69014: ST_TO_ADDR
// end ;
69015: GO 68924
69017: POP
69018: POP
// if p then
69019: LD_VAR 0 11
69023: IFFALSE 69048
// result := Replace ( result , 2 , p ) ;
69025: LD_ADDR_VAR 0 2
69029: PUSH
69030: LD_VAR 0 2
69034: PPUSH
69035: LD_INT 2
69037: PPUSH
69038: LD_VAR 0 11
69042: PPUSH
69043: CALL_OW 1
69047: ST_TO_ADDR
// end ; exit ;
69048: GO 69772
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
69050: LD_EXP 58
69054: PUSH
69055: LD_EXP 57
69059: PUSH
69060: LD_VAR 0 1
69064: ARRAY
69065: ARRAY
69066: NOT
69067: PUSH
69068: LD_EXP 31
69072: PUSH
69073: LD_VAR 0 1
69077: ARRAY
69078: PPUSH
69079: LD_INT 30
69081: PUSH
69082: LD_INT 3
69084: PUSH
69085: EMPTY
69086: LIST
69087: LIST
69088: PPUSH
69089: CALL_OW 72
69093: AND
69094: PUSH
69095: LD_EXP 36
69099: PUSH
69100: LD_VAR 0 1
69104: ARRAY
69105: NOT
69106: AND
69107: IFFALSE 69772
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
69109: LD_ADDR_EXP 73
69113: PUSH
69114: LD_EXP 73
69118: PPUSH
69119: LD_VAR 0 1
69123: PPUSH
69124: LD_INT 6
69126: PPUSH
69127: CALL_OW 1
69131: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
69132: LD_ADDR_VAR 0 2
69136: PUSH
69137: LD_INT 0
69139: PUSH
69140: LD_INT 0
69142: PUSH
69143: LD_INT 0
69145: PUSH
69146: LD_INT 0
69148: PUSH
69149: EMPTY
69150: LIST
69151: LIST
69152: LIST
69153: LIST
69154: ST_TO_ADDR
// if sci >= 1 then
69155: LD_VAR 0 8
69159: PUSH
69160: LD_INT 1
69162: GREATEREQUAL
69163: IFFALSE 69185
// tmp := tmp diff sci [ 1 ] ;
69165: LD_ADDR_VAR 0 4
69169: PUSH
69170: LD_VAR 0 4
69174: PUSH
69175: LD_VAR 0 8
69179: PUSH
69180: LD_INT 1
69182: ARRAY
69183: DIFF
69184: ST_TO_ADDR
// if tmp and not sci then
69185: LD_VAR 0 4
69189: PUSH
69190: LD_VAR 0 8
69194: NOT
69195: AND
69196: IFFALSE 69265
// begin sort := SortBySkill ( tmp , 4 ) ;
69198: LD_ADDR_VAR 0 9
69202: PUSH
69203: LD_VAR 0 4
69207: PPUSH
69208: LD_INT 4
69210: PPUSH
69211: CALL 55722 0 2
69215: ST_TO_ADDR
// if sort then
69216: LD_VAR 0 9
69220: IFFALSE 69236
// p := sort [ 1 ] ;
69222: LD_ADDR_VAR 0 11
69226: PUSH
69227: LD_VAR 0 9
69231: PUSH
69232: LD_INT 1
69234: ARRAY
69235: ST_TO_ADDR
// if p then
69236: LD_VAR 0 11
69240: IFFALSE 69265
// result := Replace ( result , 4 , p ) ;
69242: LD_ADDR_VAR 0 2
69246: PUSH
69247: LD_VAR 0 2
69251: PPUSH
69252: LD_INT 4
69254: PPUSH
69255: LD_VAR 0 11
69259: PPUSH
69260: CALL_OW 1
69264: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
69265: LD_ADDR_VAR 0 4
69269: PUSH
69270: LD_VAR 0 4
69274: PUSH
69275: LD_VAR 0 7
69279: DIFF
69280: ST_TO_ADDR
// if tmp and mech < 6 then
69281: LD_VAR 0 4
69285: PUSH
69286: LD_VAR 0 7
69290: PUSH
69291: LD_INT 6
69293: LESS
69294: AND
69295: IFFALSE 69477
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
69297: LD_ADDR_VAR 0 9
69301: PUSH
69302: LD_VAR 0 4
69306: PUSH
69307: LD_VAR 0 7
69311: DIFF
69312: PPUSH
69313: LD_INT 3
69315: PPUSH
69316: CALL 55722 0 2
69320: ST_TO_ADDR
// p := [ ] ;
69321: LD_ADDR_VAR 0 11
69325: PUSH
69326: EMPTY
69327: ST_TO_ADDR
// if sort then
69328: LD_VAR 0 9
69332: IFFALSE 69448
// for i = 1 to 6 - mech do
69334: LD_ADDR_VAR 0 3
69338: PUSH
69339: DOUBLE
69340: LD_INT 1
69342: DEC
69343: ST_TO_ADDR
69344: LD_INT 6
69346: PUSH
69347: LD_VAR 0 7
69351: MINUS
69352: PUSH
69353: FOR_TO
69354: IFFALSE 69446
// begin if i = sort then
69356: LD_VAR 0 3
69360: PUSH
69361: LD_VAR 0 9
69365: EQUAL
69366: IFFALSE 69370
// break ;
69368: GO 69446
// if GetClass ( i ) = 3 then
69370: LD_VAR 0 3
69374: PPUSH
69375: CALL_OW 257
69379: PUSH
69380: LD_INT 3
69382: EQUAL
69383: IFFALSE 69387
// continue ;
69385: GO 69353
// p := Insert ( p , p + 1 , sort [ i ] ) ;
69387: LD_ADDR_VAR 0 11
69391: PUSH
69392: LD_VAR 0 11
69396: PPUSH
69397: LD_VAR 0 11
69401: PUSH
69402: LD_INT 1
69404: PLUS
69405: PPUSH
69406: LD_VAR 0 9
69410: PUSH
69411: LD_VAR 0 3
69415: ARRAY
69416: PPUSH
69417: CALL_OW 2
69421: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
69422: LD_ADDR_VAR 0 4
69426: PUSH
69427: LD_VAR 0 4
69431: PUSH
69432: LD_VAR 0 9
69436: PUSH
69437: LD_VAR 0 3
69441: ARRAY
69442: DIFF
69443: ST_TO_ADDR
// end ;
69444: GO 69353
69446: POP
69447: POP
// if p then
69448: LD_VAR 0 11
69452: IFFALSE 69477
// result := Replace ( result , 3 , p ) ;
69454: LD_ADDR_VAR 0 2
69458: PUSH
69459: LD_VAR 0 2
69463: PPUSH
69464: LD_INT 3
69466: PPUSH
69467: LD_VAR 0 11
69471: PPUSH
69472: CALL_OW 1
69476: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
69477: LD_ADDR_VAR 0 4
69481: PUSH
69482: LD_VAR 0 4
69486: PUSH
69487: LD_VAR 0 6
69491: DIFF
69492: ST_TO_ADDR
// if tmp and eng < 4 then
69493: LD_VAR 0 4
69497: PUSH
69498: LD_VAR 0 6
69502: PUSH
69503: LD_INT 4
69505: LESS
69506: AND
69507: IFFALSE 69697
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
69509: LD_ADDR_VAR 0 9
69513: PUSH
69514: LD_VAR 0 4
69518: PUSH
69519: LD_VAR 0 7
69523: PUSH
69524: LD_VAR 0 6
69528: UNION
69529: DIFF
69530: PPUSH
69531: LD_INT 2
69533: PPUSH
69534: CALL 55722 0 2
69538: ST_TO_ADDR
// p := [ ] ;
69539: LD_ADDR_VAR 0 11
69543: PUSH
69544: EMPTY
69545: ST_TO_ADDR
// if sort then
69546: LD_VAR 0 9
69550: IFFALSE 69666
// for i = 1 to 4 - eng do
69552: LD_ADDR_VAR 0 3
69556: PUSH
69557: DOUBLE
69558: LD_INT 1
69560: DEC
69561: ST_TO_ADDR
69562: LD_INT 4
69564: PUSH
69565: LD_VAR 0 6
69569: MINUS
69570: PUSH
69571: FOR_TO
69572: IFFALSE 69664
// begin if i = sort then
69574: LD_VAR 0 3
69578: PUSH
69579: LD_VAR 0 9
69583: EQUAL
69584: IFFALSE 69588
// break ;
69586: GO 69664
// if GetClass ( i ) = 2 then
69588: LD_VAR 0 3
69592: PPUSH
69593: CALL_OW 257
69597: PUSH
69598: LD_INT 2
69600: EQUAL
69601: IFFALSE 69605
// continue ;
69603: GO 69571
// p := Insert ( p , p + 1 , sort [ i ] ) ;
69605: LD_ADDR_VAR 0 11
69609: PUSH
69610: LD_VAR 0 11
69614: PPUSH
69615: LD_VAR 0 11
69619: PUSH
69620: LD_INT 1
69622: PLUS
69623: PPUSH
69624: LD_VAR 0 9
69628: PUSH
69629: LD_VAR 0 3
69633: ARRAY
69634: PPUSH
69635: CALL_OW 2
69639: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
69640: LD_ADDR_VAR 0 4
69644: PUSH
69645: LD_VAR 0 4
69649: PUSH
69650: LD_VAR 0 9
69654: PUSH
69655: LD_VAR 0 3
69659: ARRAY
69660: DIFF
69661: ST_TO_ADDR
// end ;
69662: GO 69571
69664: POP
69665: POP
// if p then
69666: LD_VAR 0 11
69670: IFFALSE 69695
// result := Replace ( result , 2 , p ) ;
69672: LD_ADDR_VAR 0 2
69676: PUSH
69677: LD_VAR 0 2
69681: PPUSH
69682: LD_INT 2
69684: PPUSH
69685: LD_VAR 0 11
69689: PPUSH
69690: CALL_OW 1
69694: ST_TO_ADDR
// end else
69695: GO 69741
// for i = eng downto 5 do
69697: LD_ADDR_VAR 0 3
69701: PUSH
69702: DOUBLE
69703: LD_VAR 0 6
69707: INC
69708: ST_TO_ADDR
69709: LD_INT 5
69711: PUSH
69712: FOR_DOWNTO
69713: IFFALSE 69739
// tmp := tmp union eng [ i ] ;
69715: LD_ADDR_VAR 0 4
69719: PUSH
69720: LD_VAR 0 4
69724: PUSH
69725: LD_VAR 0 6
69729: PUSH
69730: LD_VAR 0 3
69734: ARRAY
69735: UNION
69736: ST_TO_ADDR
69737: GO 69712
69739: POP
69740: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
69741: LD_ADDR_VAR 0 2
69745: PUSH
69746: LD_VAR 0 2
69750: PPUSH
69751: LD_INT 1
69753: PPUSH
69754: LD_VAR 0 4
69758: PUSH
69759: LD_VAR 0 5
69763: DIFF
69764: PPUSH
69765: CALL_OW 1
69769: ST_TO_ADDR
// exit ;
69770: GO 69772
// end ; end ;
69772: LD_VAR 0 2
69776: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
69777: LD_INT 0
69779: PPUSH
69780: PPUSH
69781: PPUSH
// if not mc_bases then
69782: LD_EXP 31
69786: NOT
69787: IFFALSE 69791
// exit ;
69789: GO 69933
// for i = 1 to mc_bases do
69791: LD_ADDR_VAR 0 2
69795: PUSH
69796: DOUBLE
69797: LD_INT 1
69799: DEC
69800: ST_TO_ADDR
69801: LD_EXP 31
69805: PUSH
69806: FOR_TO
69807: IFFALSE 69924
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
69809: LD_ADDR_VAR 0 3
69813: PUSH
69814: LD_EXP 31
69818: PUSH
69819: LD_VAR 0 2
69823: ARRAY
69824: PPUSH
69825: LD_INT 21
69827: PUSH
69828: LD_INT 3
69830: PUSH
69831: EMPTY
69832: LIST
69833: LIST
69834: PUSH
69835: LD_INT 3
69837: PUSH
69838: LD_INT 2
69840: PUSH
69841: LD_INT 30
69843: PUSH
69844: LD_INT 29
69846: PUSH
69847: EMPTY
69848: LIST
69849: LIST
69850: PUSH
69851: LD_INT 30
69853: PUSH
69854: LD_INT 30
69856: PUSH
69857: EMPTY
69858: LIST
69859: LIST
69860: PUSH
69861: EMPTY
69862: LIST
69863: LIST
69864: LIST
69865: PUSH
69866: EMPTY
69867: LIST
69868: LIST
69869: PUSH
69870: LD_INT 3
69872: PUSH
69873: LD_INT 24
69875: PUSH
69876: LD_INT 1000
69878: PUSH
69879: EMPTY
69880: LIST
69881: LIST
69882: PUSH
69883: EMPTY
69884: LIST
69885: LIST
69886: PUSH
69887: EMPTY
69888: LIST
69889: LIST
69890: LIST
69891: PPUSH
69892: CALL_OW 72
69896: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
69897: LD_ADDR_EXP 32
69901: PUSH
69902: LD_EXP 32
69906: PPUSH
69907: LD_VAR 0 2
69911: PPUSH
69912: LD_VAR 0 3
69916: PPUSH
69917: CALL_OW 1
69921: ST_TO_ADDR
// end ;
69922: GO 69806
69924: POP
69925: POP
// RaiseSailEvent ( 101 ) ;
69926: LD_INT 101
69928: PPUSH
69929: CALL_OW 427
// end ;
69933: LD_VAR 0 1
69937: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
69938: LD_INT 0
69940: PPUSH
69941: PPUSH
69942: PPUSH
69943: PPUSH
69944: PPUSH
69945: PPUSH
69946: PPUSH
// if not mc_bases then
69947: LD_EXP 31
69951: NOT
69952: IFFALSE 69956
// exit ;
69954: GO 70518
// for i = 1 to mc_bases do
69956: LD_ADDR_VAR 0 2
69960: PUSH
69961: DOUBLE
69962: LD_INT 1
69964: DEC
69965: ST_TO_ADDR
69966: LD_EXP 31
69970: PUSH
69971: FOR_TO
69972: IFFALSE 70509
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
69974: LD_ADDR_VAR 0 5
69978: PUSH
69979: LD_EXP 31
69983: PUSH
69984: LD_VAR 0 2
69988: ARRAY
69989: PUSH
69990: LD_EXP 60
69994: PUSH
69995: LD_VAR 0 2
69999: ARRAY
70000: UNION
70001: PPUSH
70002: LD_INT 21
70004: PUSH
70005: LD_INT 1
70007: PUSH
70008: EMPTY
70009: LIST
70010: LIST
70011: PUSH
70012: LD_INT 1
70014: PUSH
70015: LD_INT 3
70017: PUSH
70018: LD_INT 54
70020: PUSH
70021: EMPTY
70022: LIST
70023: PUSH
70024: EMPTY
70025: LIST
70026: LIST
70027: PUSH
70028: LD_INT 3
70030: PUSH
70031: LD_INT 24
70033: PUSH
70034: LD_INT 1000
70036: PUSH
70037: EMPTY
70038: LIST
70039: LIST
70040: PUSH
70041: EMPTY
70042: LIST
70043: LIST
70044: PUSH
70045: EMPTY
70046: LIST
70047: LIST
70048: LIST
70049: PUSH
70050: EMPTY
70051: LIST
70052: LIST
70053: PPUSH
70054: CALL_OW 72
70058: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
70059: LD_ADDR_VAR 0 6
70063: PUSH
70064: LD_EXP 31
70068: PUSH
70069: LD_VAR 0 2
70073: ARRAY
70074: PPUSH
70075: LD_INT 21
70077: PUSH
70078: LD_INT 1
70080: PUSH
70081: EMPTY
70082: LIST
70083: LIST
70084: PUSH
70085: LD_INT 1
70087: PUSH
70088: LD_INT 3
70090: PUSH
70091: LD_INT 54
70093: PUSH
70094: EMPTY
70095: LIST
70096: PUSH
70097: EMPTY
70098: LIST
70099: LIST
70100: PUSH
70101: LD_INT 3
70103: PUSH
70104: LD_INT 24
70106: PUSH
70107: LD_INT 250
70109: PUSH
70110: EMPTY
70111: LIST
70112: LIST
70113: PUSH
70114: EMPTY
70115: LIST
70116: LIST
70117: PUSH
70118: EMPTY
70119: LIST
70120: LIST
70121: LIST
70122: PUSH
70123: EMPTY
70124: LIST
70125: LIST
70126: PPUSH
70127: CALL_OW 72
70131: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
70132: LD_ADDR_VAR 0 7
70136: PUSH
70137: LD_VAR 0 5
70141: PUSH
70142: LD_VAR 0 6
70146: DIFF
70147: ST_TO_ADDR
// if not need_heal_1 then
70148: LD_VAR 0 6
70152: NOT
70153: IFFALSE 70186
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
70155: LD_ADDR_EXP 34
70159: PUSH
70160: LD_EXP 34
70164: PPUSH
70165: LD_VAR 0 2
70169: PUSH
70170: LD_INT 1
70172: PUSH
70173: EMPTY
70174: LIST
70175: LIST
70176: PPUSH
70177: EMPTY
70178: PPUSH
70179: CALL 24846 0 3
70183: ST_TO_ADDR
70184: GO 70256
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
70186: LD_ADDR_EXP 34
70190: PUSH
70191: LD_EXP 34
70195: PPUSH
70196: LD_VAR 0 2
70200: PUSH
70201: LD_INT 1
70203: PUSH
70204: EMPTY
70205: LIST
70206: LIST
70207: PPUSH
70208: LD_EXP 34
70212: PUSH
70213: LD_VAR 0 2
70217: ARRAY
70218: PUSH
70219: LD_INT 1
70221: ARRAY
70222: PPUSH
70223: LD_INT 3
70225: PUSH
70226: LD_INT 24
70228: PUSH
70229: LD_INT 1000
70231: PUSH
70232: EMPTY
70233: LIST
70234: LIST
70235: PUSH
70236: EMPTY
70237: LIST
70238: LIST
70239: PPUSH
70240: CALL_OW 72
70244: PUSH
70245: LD_VAR 0 6
70249: UNION
70250: PPUSH
70251: CALL 24846 0 3
70255: ST_TO_ADDR
// if not need_heal_2 then
70256: LD_VAR 0 7
70260: NOT
70261: IFFALSE 70294
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
70263: LD_ADDR_EXP 34
70267: PUSH
70268: LD_EXP 34
70272: PPUSH
70273: LD_VAR 0 2
70277: PUSH
70278: LD_INT 2
70280: PUSH
70281: EMPTY
70282: LIST
70283: LIST
70284: PPUSH
70285: EMPTY
70286: PPUSH
70287: CALL 24846 0 3
70291: ST_TO_ADDR
70292: GO 70326
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
70294: LD_ADDR_EXP 34
70298: PUSH
70299: LD_EXP 34
70303: PPUSH
70304: LD_VAR 0 2
70308: PUSH
70309: LD_INT 2
70311: PUSH
70312: EMPTY
70313: LIST
70314: LIST
70315: PPUSH
70316: LD_VAR 0 7
70320: PPUSH
70321: CALL 24846 0 3
70325: ST_TO_ADDR
// if need_heal_2 then
70326: LD_VAR 0 7
70330: IFFALSE 70491
// for j in need_heal_2 do
70332: LD_ADDR_VAR 0 3
70336: PUSH
70337: LD_VAR 0 7
70341: PUSH
70342: FOR_IN
70343: IFFALSE 70489
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
70345: LD_ADDR_VAR 0 5
70349: PUSH
70350: LD_EXP 31
70354: PUSH
70355: LD_VAR 0 2
70359: ARRAY
70360: PPUSH
70361: LD_INT 2
70363: PUSH
70364: LD_INT 30
70366: PUSH
70367: LD_INT 6
70369: PUSH
70370: EMPTY
70371: LIST
70372: LIST
70373: PUSH
70374: LD_INT 30
70376: PUSH
70377: LD_INT 7
70379: PUSH
70380: EMPTY
70381: LIST
70382: LIST
70383: PUSH
70384: LD_INT 30
70386: PUSH
70387: LD_INT 8
70389: PUSH
70390: EMPTY
70391: LIST
70392: LIST
70393: PUSH
70394: LD_INT 30
70396: PUSH
70397: LD_INT 0
70399: PUSH
70400: EMPTY
70401: LIST
70402: LIST
70403: PUSH
70404: LD_INT 30
70406: PUSH
70407: LD_INT 1
70409: PUSH
70410: EMPTY
70411: LIST
70412: LIST
70413: PUSH
70414: EMPTY
70415: LIST
70416: LIST
70417: LIST
70418: LIST
70419: LIST
70420: LIST
70421: PPUSH
70422: CALL_OW 72
70426: ST_TO_ADDR
// if tmp then
70427: LD_VAR 0 5
70431: IFFALSE 70487
// begin k := NearestUnitToUnit ( tmp , j ) ;
70433: LD_ADDR_VAR 0 4
70437: PUSH
70438: LD_VAR 0 5
70442: PPUSH
70443: LD_VAR 0 3
70447: PPUSH
70448: CALL_OW 74
70452: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
70453: LD_VAR 0 3
70457: PPUSH
70458: LD_VAR 0 4
70462: PPUSH
70463: CALL_OW 296
70467: PUSH
70468: LD_INT 5
70470: GREATER
70471: IFFALSE 70487
// ComMoveToNearbyEntrance ( j , k ) ;
70473: LD_VAR 0 3
70477: PPUSH
70478: LD_VAR 0 4
70482: PPUSH
70483: CALL 58082 0 2
// end ; end ;
70487: GO 70342
70489: POP
70490: POP
// if not need_heal_1 and not need_heal_2 then
70491: LD_VAR 0 6
70495: NOT
70496: PUSH
70497: LD_VAR 0 7
70501: NOT
70502: AND
70503: IFFALSE 70507
// continue ;
70505: GO 69971
// end ;
70507: GO 69971
70509: POP
70510: POP
// RaiseSailEvent ( 102 ) ;
70511: LD_INT 102
70513: PPUSH
70514: CALL_OW 427
// end ;
70518: LD_VAR 0 1
70522: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
70523: LD_INT 0
70525: PPUSH
70526: PPUSH
70527: PPUSH
70528: PPUSH
70529: PPUSH
70530: PPUSH
70531: PPUSH
70532: PPUSH
// if not mc_bases then
70533: LD_EXP 31
70537: NOT
70538: IFFALSE 70542
// exit ;
70540: GO 71453
// for i = 1 to mc_bases do
70542: LD_ADDR_VAR 0 2
70546: PUSH
70547: DOUBLE
70548: LD_INT 1
70550: DEC
70551: ST_TO_ADDR
70552: LD_EXP 31
70556: PUSH
70557: FOR_TO
70558: IFFALSE 71451
// begin if not mc_building_need_repair [ i ] then
70560: LD_EXP 32
70564: PUSH
70565: LD_VAR 0 2
70569: ARRAY
70570: NOT
70571: IFFALSE 70756
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
70573: LD_ADDR_VAR 0 6
70577: PUSH
70578: LD_EXP 50
70582: PUSH
70583: LD_VAR 0 2
70587: ARRAY
70588: PPUSH
70589: LD_INT 3
70591: PUSH
70592: LD_INT 24
70594: PUSH
70595: LD_INT 1000
70597: PUSH
70598: EMPTY
70599: LIST
70600: LIST
70601: PUSH
70602: EMPTY
70603: LIST
70604: LIST
70605: PUSH
70606: LD_INT 2
70608: PUSH
70609: LD_INT 34
70611: PUSH
70612: LD_INT 13
70614: PUSH
70615: EMPTY
70616: LIST
70617: LIST
70618: PUSH
70619: LD_INT 34
70621: PUSH
70622: LD_INT 52
70624: PUSH
70625: EMPTY
70626: LIST
70627: LIST
70628: PUSH
70629: LD_INT 34
70631: PUSH
70632: LD_INT 88
70634: PUSH
70635: EMPTY
70636: LIST
70637: LIST
70638: PUSH
70639: EMPTY
70640: LIST
70641: LIST
70642: LIST
70643: LIST
70644: PUSH
70645: EMPTY
70646: LIST
70647: LIST
70648: PPUSH
70649: CALL_OW 72
70653: ST_TO_ADDR
// if cranes then
70654: LD_VAR 0 6
70658: IFFALSE 70720
// for j in cranes do
70660: LD_ADDR_VAR 0 3
70664: PUSH
70665: LD_VAR 0 6
70669: PUSH
70670: FOR_IN
70671: IFFALSE 70718
// if not IsInArea ( j , mc_parking [ i ] ) then
70673: LD_VAR 0 3
70677: PPUSH
70678: LD_EXP 55
70682: PUSH
70683: LD_VAR 0 2
70687: ARRAY
70688: PPUSH
70689: CALL_OW 308
70693: NOT
70694: IFFALSE 70716
// ComMoveToArea ( j , mc_parking [ i ] ) ;
70696: LD_VAR 0 3
70700: PPUSH
70701: LD_EXP 55
70705: PUSH
70706: LD_VAR 0 2
70710: ARRAY
70711: PPUSH
70712: CALL_OW 113
70716: GO 70670
70718: POP
70719: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
70720: LD_ADDR_EXP 33
70724: PUSH
70725: LD_EXP 33
70729: PPUSH
70730: LD_VAR 0 2
70734: PPUSH
70735: EMPTY
70736: PPUSH
70737: CALL_OW 1
70741: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
70742: LD_VAR 0 2
70746: PPUSH
70747: LD_INT 101
70749: PPUSH
70750: CALL 65596 0 2
// continue ;
70754: GO 70557
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
70756: LD_ADDR_EXP 37
70760: PUSH
70761: LD_EXP 37
70765: PPUSH
70766: LD_VAR 0 2
70770: PPUSH
70771: EMPTY
70772: PPUSH
70773: CALL_OW 1
70777: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
70778: LD_VAR 0 2
70782: PPUSH
70783: LD_INT 103
70785: PPUSH
70786: CALL 65596 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
70790: LD_ADDR_VAR 0 5
70794: PUSH
70795: LD_EXP 31
70799: PUSH
70800: LD_VAR 0 2
70804: ARRAY
70805: PUSH
70806: LD_EXP 60
70810: PUSH
70811: LD_VAR 0 2
70815: ARRAY
70816: UNION
70817: PPUSH
70818: LD_INT 2
70820: PUSH
70821: LD_INT 25
70823: PUSH
70824: LD_INT 2
70826: PUSH
70827: EMPTY
70828: LIST
70829: LIST
70830: PUSH
70831: LD_INT 25
70833: PUSH
70834: LD_INT 16
70836: PUSH
70837: EMPTY
70838: LIST
70839: LIST
70840: PUSH
70841: EMPTY
70842: LIST
70843: LIST
70844: LIST
70845: PUSH
70846: EMPTY
70847: LIST
70848: PPUSH
70849: CALL_OW 72
70853: ST_TO_ADDR
// if mc_need_heal [ i ] then
70854: LD_EXP 34
70858: PUSH
70859: LD_VAR 0 2
70863: ARRAY
70864: IFFALSE 70908
// tmp := tmp diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
70866: LD_ADDR_VAR 0 5
70870: PUSH
70871: LD_VAR 0 5
70875: PUSH
70876: LD_EXP 34
70880: PUSH
70881: LD_VAR 0 2
70885: ARRAY
70886: PUSH
70887: LD_INT 1
70889: ARRAY
70890: PUSH
70891: LD_EXP 34
70895: PUSH
70896: LD_VAR 0 2
70900: ARRAY
70901: PUSH
70902: LD_INT 2
70904: ARRAY
70905: UNION
70906: DIFF
70907: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
70908: LD_ADDR_VAR 0 6
70912: PUSH
70913: LD_EXP 50
70917: PUSH
70918: LD_VAR 0 2
70922: ARRAY
70923: PPUSH
70924: LD_INT 2
70926: PUSH
70927: LD_INT 34
70929: PUSH
70930: LD_INT 13
70932: PUSH
70933: EMPTY
70934: LIST
70935: LIST
70936: PUSH
70937: LD_INT 34
70939: PUSH
70940: LD_INT 52
70942: PUSH
70943: EMPTY
70944: LIST
70945: LIST
70946: PUSH
70947: LD_INT 34
70949: PUSH
70950: LD_INT 88
70952: PUSH
70953: EMPTY
70954: LIST
70955: LIST
70956: PUSH
70957: EMPTY
70958: LIST
70959: LIST
70960: LIST
70961: LIST
70962: PPUSH
70963: CALL_OW 72
70967: ST_TO_ADDR
// if cranes then
70968: LD_VAR 0 6
70972: IFFALSE 71140
// begin for j in cranes do
70974: LD_ADDR_VAR 0 3
70978: PUSH
70979: LD_VAR 0 6
70983: PUSH
70984: FOR_IN
70985: IFFALSE 71138
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
70987: LD_VAR 0 3
70991: PPUSH
70992: CALL_OW 256
70996: PUSH
70997: LD_INT 1000
70999: EQUAL
71000: PUSH
71001: LD_VAR 0 3
71005: PPUSH
71006: CALL_OW 314
71010: NOT
71011: AND
71012: IFFALSE 71078
// begin to_repair := NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ;
71014: LD_ADDR_VAR 0 8
71018: PUSH
71019: LD_EXP 32
71023: PUSH
71024: LD_VAR 0 2
71028: ARRAY
71029: PPUSH
71030: LD_VAR 0 3
71034: PPUSH
71035: CALL_OW 74
71039: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
71040: LD_VAR 0 8
71044: PPUSH
71045: LD_INT 16
71047: PPUSH
71048: CALL 27443 0 2
71052: PUSH
71053: LD_INT 4
71055: ARRAY
71056: PUSH
71057: LD_INT 10
71059: LESS
71060: IFFALSE 71076
// ComRepairBuilding ( j , to_repair ) ;
71062: LD_VAR 0 3
71066: PPUSH
71067: LD_VAR 0 8
71071: PPUSH
71072: CALL_OW 130
// end else
71076: GO 71136
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
71078: LD_VAR 0 3
71082: PPUSH
71083: CALL_OW 256
71087: PUSH
71088: LD_INT 500
71090: LESS
71091: PUSH
71092: LD_VAR 0 3
71096: PPUSH
71097: LD_EXP 55
71101: PUSH
71102: LD_VAR 0 2
71106: ARRAY
71107: PPUSH
71108: CALL_OW 308
71112: NOT
71113: AND
71114: IFFALSE 71136
// ComMoveToArea ( j , mc_parking [ i ] ) ;
71116: LD_VAR 0 3
71120: PPUSH
71121: LD_EXP 55
71125: PUSH
71126: LD_VAR 0 2
71130: ARRAY
71131: PPUSH
71132: CALL_OW 113
// end ;
71136: GO 70984
71138: POP
71139: POP
// end ; if tmp > 3 then
71140: LD_VAR 0 5
71144: PUSH
71145: LD_INT 3
71147: GREATER
71148: IFFALSE 71168
// tmp := ShrinkArray ( tmp , 4 ) ;
71150: LD_ADDR_VAR 0 5
71154: PUSH
71155: LD_VAR 0 5
71159: PPUSH
71160: LD_INT 4
71162: PPUSH
71163: CALL 57520 0 2
71167: ST_TO_ADDR
// if not tmp then
71168: LD_VAR 0 5
71172: NOT
71173: IFFALSE 71177
// continue ;
71175: GO 70557
// for j in tmp do
71177: LD_ADDR_VAR 0 3
71181: PUSH
71182: LD_VAR 0 5
71186: PUSH
71187: FOR_IN
71188: IFFALSE 71447
// begin if IsInUnit ( j ) then
71190: LD_VAR 0 3
71194: PPUSH
71195: CALL_OW 310
71199: IFFALSE 71210
// ComExitBuilding ( j ) ;
71201: LD_VAR 0 3
71205: PPUSH
71206: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
71210: LD_VAR 0 3
71214: PUSH
71215: LD_EXP 33
71219: PUSH
71220: LD_VAR 0 2
71224: ARRAY
71225: IN
71226: NOT
71227: IFFALSE 71285
// begin SetTag ( j , 101 ) ;
71229: LD_VAR 0 3
71233: PPUSH
71234: LD_INT 101
71236: PPUSH
71237: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
71241: LD_ADDR_EXP 33
71245: PUSH
71246: LD_EXP 33
71250: PPUSH
71251: LD_VAR 0 2
71255: PUSH
71256: LD_EXP 33
71260: PUSH
71261: LD_VAR 0 2
71265: ARRAY
71266: PUSH
71267: LD_INT 1
71269: PLUS
71270: PUSH
71271: EMPTY
71272: LIST
71273: LIST
71274: PPUSH
71275: LD_VAR 0 3
71279: PPUSH
71280: CALL 24846 0 3
71284: ST_TO_ADDR
// end ; wait ( 1 ) ;
71285: LD_INT 1
71287: PPUSH
71288: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
71292: LD_ADDR_VAR 0 7
71296: PUSH
71297: LD_EXP 32
71301: PUSH
71302: LD_VAR 0 2
71306: ARRAY
71307: ST_TO_ADDR
// if mc_scan [ i ] then
71308: LD_EXP 54
71312: PUSH
71313: LD_VAR 0 2
71317: ARRAY
71318: IFFALSE 71380
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
71320: LD_ADDR_VAR 0 7
71324: PUSH
71325: LD_EXP 32
71329: PUSH
71330: LD_VAR 0 2
71334: ARRAY
71335: PPUSH
71336: LD_INT 3
71338: PUSH
71339: LD_INT 30
71341: PUSH
71342: LD_INT 32
71344: PUSH
71345: EMPTY
71346: LIST
71347: LIST
71348: PUSH
71349: LD_INT 30
71351: PUSH
71352: LD_INT 33
71354: PUSH
71355: EMPTY
71356: LIST
71357: LIST
71358: PUSH
71359: LD_INT 30
71361: PUSH
71362: LD_INT 31
71364: PUSH
71365: EMPTY
71366: LIST
71367: LIST
71368: PUSH
71369: EMPTY
71370: LIST
71371: LIST
71372: LIST
71373: LIST
71374: PPUSH
71375: CALL_OW 72
71379: ST_TO_ADDR
// if not to_repair_tmp then
71380: LD_VAR 0 7
71384: NOT
71385: IFFALSE 71389
// continue ;
71387: GO 71187
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
71389: LD_ADDR_VAR 0 8
71393: PUSH
71394: LD_VAR 0 7
71398: PPUSH
71399: LD_VAR 0 3
71403: PPUSH
71404: CALL_OW 74
71408: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 14 then
71409: LD_VAR 0 8
71413: PPUSH
71414: LD_INT 16
71416: PPUSH
71417: CALL 27443 0 2
71421: PUSH
71422: LD_INT 4
71424: ARRAY
71425: PUSH
71426: LD_INT 14
71428: LESS
71429: IFFALSE 71445
// ComRepairBuilding ( j , to_repair ) ;
71431: LD_VAR 0 3
71435: PPUSH
71436: LD_VAR 0 8
71440: PPUSH
71441: CALL_OW 130
// end ;
71445: GO 71187
71447: POP
71448: POP
// end ;
71449: GO 70557
71451: POP
71452: POP
// end ;
71453: LD_VAR 0 1
71457: RET
// export function MC_Heal ; var i , j , tmp ; begin
71458: LD_INT 0
71460: PPUSH
71461: PPUSH
71462: PPUSH
71463: PPUSH
// if not mc_bases then
71464: LD_EXP 31
71468: NOT
71469: IFFALSE 71473
// exit ;
71471: GO 71875
// for i = 1 to mc_bases do
71473: LD_ADDR_VAR 0 2
71477: PUSH
71478: DOUBLE
71479: LD_INT 1
71481: DEC
71482: ST_TO_ADDR
71483: LD_EXP 31
71487: PUSH
71488: FOR_TO
71489: IFFALSE 71873
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
71491: LD_EXP 34
71495: PUSH
71496: LD_VAR 0 2
71500: ARRAY
71501: PUSH
71502: LD_INT 1
71504: ARRAY
71505: NOT
71506: PUSH
71507: LD_EXP 34
71511: PUSH
71512: LD_VAR 0 2
71516: ARRAY
71517: PUSH
71518: LD_INT 2
71520: ARRAY
71521: NOT
71522: AND
71523: IFFALSE 71561
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
71525: LD_ADDR_EXP 35
71529: PUSH
71530: LD_EXP 35
71534: PPUSH
71535: LD_VAR 0 2
71539: PPUSH
71540: EMPTY
71541: PPUSH
71542: CALL_OW 1
71546: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
71547: LD_VAR 0 2
71551: PPUSH
71552: LD_INT 102
71554: PPUSH
71555: CALL 65596 0 2
// continue ;
71559: GO 71488
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
71561: LD_ADDR_VAR 0 4
71565: PUSH
71566: LD_EXP 31
71570: PUSH
71571: LD_VAR 0 2
71575: ARRAY
71576: PPUSH
71577: LD_INT 25
71579: PUSH
71580: LD_INT 4
71582: PUSH
71583: EMPTY
71584: LIST
71585: LIST
71586: PPUSH
71587: CALL_OW 72
71591: ST_TO_ADDR
// if not tmp then
71592: LD_VAR 0 4
71596: NOT
71597: IFFALSE 71601
// continue ;
71599: GO 71488
// if mc_taming [ i ] then
71601: LD_EXP 62
71605: PUSH
71606: LD_VAR 0 2
71610: ARRAY
71611: IFFALSE 71635
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
71613: LD_ADDR_EXP 62
71617: PUSH
71618: LD_EXP 62
71622: PPUSH
71623: LD_VAR 0 2
71627: PPUSH
71628: EMPTY
71629: PPUSH
71630: CALL_OW 1
71634: ST_TO_ADDR
// for j in tmp do
71635: LD_ADDR_VAR 0 3
71639: PUSH
71640: LD_VAR 0 4
71644: PUSH
71645: FOR_IN
71646: IFFALSE 71869
// begin if IsInUnit ( j ) then
71648: LD_VAR 0 3
71652: PPUSH
71653: CALL_OW 310
71657: IFFALSE 71668
// ComExitBuilding ( j ) ;
71659: LD_VAR 0 3
71663: PPUSH
71664: CALL_OW 122
// if not j in mc_healers [ i ] then
71668: LD_VAR 0 3
71672: PUSH
71673: LD_EXP 35
71677: PUSH
71678: LD_VAR 0 2
71682: ARRAY
71683: IN
71684: NOT
71685: IFFALSE 71731
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
71687: LD_ADDR_EXP 35
71691: PUSH
71692: LD_EXP 35
71696: PPUSH
71697: LD_VAR 0 2
71701: PUSH
71702: LD_EXP 35
71706: PUSH
71707: LD_VAR 0 2
71711: ARRAY
71712: PUSH
71713: LD_INT 1
71715: PLUS
71716: PUSH
71717: EMPTY
71718: LIST
71719: LIST
71720: PPUSH
71721: LD_VAR 0 3
71725: PPUSH
71726: CALL 24846 0 3
71730: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
71731: LD_VAR 0 3
71735: PPUSH
71736: CALL_OW 110
71740: PUSH
71741: LD_INT 102
71743: NONEQUAL
71744: IFFALSE 71758
// SetTag ( j , 102 ) ;
71746: LD_VAR 0 3
71750: PPUSH
71751: LD_INT 102
71753: PPUSH
71754: CALL_OW 109
// Wait ( 3 ) ;
71758: LD_INT 3
71760: PPUSH
71761: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
71765: LD_EXP 34
71769: PUSH
71770: LD_VAR 0 2
71774: ARRAY
71775: PUSH
71776: LD_INT 1
71778: ARRAY
71779: IFFALSE 71811
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
71781: LD_VAR 0 3
71785: PPUSH
71786: LD_EXP 34
71790: PUSH
71791: LD_VAR 0 2
71795: ARRAY
71796: PUSH
71797: LD_INT 1
71799: ARRAY
71800: PUSH
71801: LD_INT 1
71803: ARRAY
71804: PPUSH
71805: CALL_OW 128
71809: GO 71867
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
71811: LD_VAR 0 3
71815: PPUSH
71816: CALL_OW 314
71820: NOT
71821: PUSH
71822: LD_EXP 34
71826: PUSH
71827: LD_VAR 0 2
71831: ARRAY
71832: PUSH
71833: LD_INT 2
71835: ARRAY
71836: AND
71837: IFFALSE 71867
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
71839: LD_VAR 0 3
71843: PPUSH
71844: LD_EXP 34
71848: PUSH
71849: LD_VAR 0 2
71853: ARRAY
71854: PUSH
71855: LD_INT 2
71857: ARRAY
71858: PUSH
71859: LD_INT 1
71861: ARRAY
71862: PPUSH
71863: CALL_OW 128
// end ;
71867: GO 71645
71869: POP
71870: POP
// end ;
71871: GO 71488
71873: POP
71874: POP
// end ;
71875: LD_VAR 0 1
71879: RET
// export function MC_Build ( ) ; var i , j , k , tmp , depot ; begin
71880: LD_INT 0
71882: PPUSH
71883: PPUSH
71884: PPUSH
71885: PPUSH
71886: PPUSH
71887: PPUSH
// if not mc_bases then
71888: LD_EXP 31
71892: NOT
71893: IFFALSE 71897
// exit ;
71895: GO 73060
// for i = 1 to mc_bases do
71897: LD_ADDR_VAR 0 2
71901: PUSH
71902: DOUBLE
71903: LD_INT 1
71905: DEC
71906: ST_TO_ADDR
71907: LD_EXP 31
71911: PUSH
71912: FOR_TO
71913: IFFALSE 73058
// begin if mc_scan [ i ] then
71915: LD_EXP 54
71919: PUSH
71920: LD_VAR 0 2
71924: ARRAY
71925: IFFALSE 71929
// continue ;
71927: GO 71912
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
71929: LD_EXP 36
71933: PUSH
71934: LD_VAR 0 2
71938: ARRAY
71939: NOT
71940: PUSH
71941: LD_EXP 38
71945: PUSH
71946: LD_VAR 0 2
71950: ARRAY
71951: NOT
71952: AND
71953: PUSH
71954: LD_EXP 37
71958: PUSH
71959: LD_VAR 0 2
71963: ARRAY
71964: AND
71965: IFFALSE 72003
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
71967: LD_ADDR_EXP 37
71971: PUSH
71972: LD_EXP 37
71976: PPUSH
71977: LD_VAR 0 2
71981: PPUSH
71982: EMPTY
71983: PPUSH
71984: CALL_OW 1
71988: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
71989: LD_VAR 0 2
71993: PPUSH
71994: LD_INT 103
71996: PPUSH
71997: CALL 65596 0 2
// continue ;
72001: GO 71912
// end ; if mc_construct_list [ i ] then
72003: LD_EXP 38
72007: PUSH
72008: LD_VAR 0 2
72012: ARRAY
72013: IFFALSE 72233
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
72015: LD_ADDR_VAR 0 5
72019: PUSH
72020: LD_EXP 31
72024: PUSH
72025: LD_VAR 0 2
72029: ARRAY
72030: PPUSH
72031: LD_INT 25
72033: PUSH
72034: LD_INT 2
72036: PUSH
72037: EMPTY
72038: LIST
72039: LIST
72040: PPUSH
72041: CALL_OW 72
72045: PUSH
72046: LD_EXP 33
72050: PUSH
72051: LD_VAR 0 2
72055: ARRAY
72056: DIFF
72057: ST_TO_ADDR
// if not tmp then
72058: LD_VAR 0 5
72062: NOT
72063: IFFALSE 72067
// continue ;
72065: GO 71912
// for j in tmp do
72067: LD_ADDR_VAR 0 3
72071: PUSH
72072: LD_VAR 0 5
72076: PUSH
72077: FOR_IN
72078: IFFALSE 72229
// begin if not mc_builders [ i ] then
72080: LD_EXP 37
72084: PUSH
72085: LD_VAR 0 2
72089: ARRAY
72090: NOT
72091: IFFALSE 72149
// begin SetTag ( j , 103 ) ;
72093: LD_VAR 0 3
72097: PPUSH
72098: LD_INT 103
72100: PPUSH
72101: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
72105: LD_ADDR_EXP 37
72109: PUSH
72110: LD_EXP 37
72114: PPUSH
72115: LD_VAR 0 2
72119: PUSH
72120: LD_EXP 37
72124: PUSH
72125: LD_VAR 0 2
72129: ARRAY
72130: PUSH
72131: LD_INT 1
72133: PLUS
72134: PUSH
72135: EMPTY
72136: LIST
72137: LIST
72138: PPUSH
72139: LD_VAR 0 3
72143: PPUSH
72144: CALL 24846 0 3
72148: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
72149: LD_VAR 0 3
72153: PPUSH
72154: CALL_OW 310
72158: IFFALSE 72169
// ComExitBuilding ( j ) ;
72160: LD_VAR 0 3
72164: PPUSH
72165: CALL_OW 122
// wait ( 3 ) ;
72169: LD_INT 3
72171: PPUSH
72172: CALL_OW 67
// if not mc_construct_list [ i ] then
72176: LD_EXP 38
72180: PUSH
72181: LD_VAR 0 2
72185: ARRAY
72186: NOT
72187: IFFALSE 72191
// break ;
72189: GO 72229
// if not HasTask ( j ) then
72191: LD_VAR 0 3
72195: PPUSH
72196: CALL_OW 314
72200: NOT
72201: IFFALSE 72227
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
72203: LD_VAR 0 3
72207: PPUSH
72208: LD_EXP 38
72212: PUSH
72213: LD_VAR 0 2
72217: ARRAY
72218: PUSH
72219: LD_INT 1
72221: ARRAY
72222: PPUSH
72223: CALL 27716 0 2
// end ;
72227: GO 72077
72229: POP
72230: POP
// end else
72231: GO 73056
// if mc_build_list [ i ] then
72233: LD_EXP 36
72237: PUSH
72238: LD_VAR 0 2
72242: ARRAY
72243: IFFALSE 73056
// begin if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
72245: LD_EXP 36
72249: PUSH
72250: LD_VAR 0 2
72254: ARRAY
72255: PUSH
72256: LD_INT 1
72258: ARRAY
72259: PUSH
72260: LD_INT 1
72262: ARRAY
72263: PPUSH
72264: CALL 27540 0 1
72268: PUSH
72269: LD_EXP 31
72273: PUSH
72274: LD_VAR 0 2
72278: ARRAY
72279: PPUSH
72280: LD_INT 2
72282: PUSH
72283: LD_INT 30
72285: PUSH
72286: LD_INT 2
72288: PUSH
72289: EMPTY
72290: LIST
72291: LIST
72292: PUSH
72293: LD_INT 30
72295: PUSH
72296: LD_INT 3
72298: PUSH
72299: EMPTY
72300: LIST
72301: LIST
72302: PUSH
72303: EMPTY
72304: LIST
72305: LIST
72306: LIST
72307: PPUSH
72308: CALL_OW 72
72312: NOT
72313: AND
72314: IFFALSE 72419
// begin for j = 1 to mc_build_list [ i ] do
72316: LD_ADDR_VAR 0 3
72320: PUSH
72321: DOUBLE
72322: LD_INT 1
72324: DEC
72325: ST_TO_ADDR
72326: LD_EXP 36
72330: PUSH
72331: LD_VAR 0 2
72335: ARRAY
72336: PUSH
72337: FOR_TO
72338: IFFALSE 72417
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
72340: LD_EXP 36
72344: PUSH
72345: LD_VAR 0 2
72349: ARRAY
72350: PUSH
72351: LD_VAR 0 3
72355: ARRAY
72356: PUSH
72357: LD_INT 1
72359: ARRAY
72360: PUSH
72361: LD_INT 2
72363: EQUAL
72364: IFFALSE 72415
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
72366: LD_ADDR_EXP 36
72370: PUSH
72371: LD_EXP 36
72375: PPUSH
72376: LD_VAR 0 2
72380: PPUSH
72381: LD_EXP 36
72385: PUSH
72386: LD_VAR 0 2
72390: ARRAY
72391: PPUSH
72392: LD_VAR 0 3
72396: PPUSH
72397: LD_INT 1
72399: PPUSH
72400: LD_INT 0
72402: PPUSH
72403: CALL 24264 0 4
72407: PPUSH
72408: CALL_OW 1
72412: ST_TO_ADDR
// break ;
72413: GO 72417
// end ;
72415: GO 72337
72417: POP
72418: POP
// end ; depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
72419: LD_ADDR_VAR 0 6
72423: PUSH
72424: LD_EXP 31
72428: PUSH
72429: LD_VAR 0 2
72433: ARRAY
72434: PPUSH
72435: LD_INT 2
72437: PUSH
72438: LD_INT 30
72440: PUSH
72441: LD_INT 0
72443: PUSH
72444: EMPTY
72445: LIST
72446: LIST
72447: PUSH
72448: LD_INT 30
72450: PUSH
72451: LD_INT 1
72453: PUSH
72454: EMPTY
72455: LIST
72456: LIST
72457: PUSH
72458: EMPTY
72459: LIST
72460: LIST
72461: LIST
72462: PPUSH
72463: CALL_OW 72
72467: ST_TO_ADDR
// for k := 1 to depot do
72468: LD_ADDR_VAR 0 4
72472: PUSH
72473: DOUBLE
72474: LD_INT 1
72476: DEC
72477: ST_TO_ADDR
72478: LD_VAR 0 6
72482: PUSH
72483: FOR_TO
72484: IFFALSE 73054
// begin if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or CanBeBuilt ( depot [ k ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
72486: LD_EXP 36
72490: PUSH
72491: LD_VAR 0 2
72495: ARRAY
72496: PUSH
72497: LD_INT 1
72499: ARRAY
72500: PUSH
72501: LD_INT 1
72503: ARRAY
72504: PUSH
72505: LD_INT 0
72507: EQUAL
72508: PUSH
72509: LD_VAR 0 6
72513: PUSH
72514: LD_VAR 0 4
72518: ARRAY
72519: PPUSH
72520: LD_EXP 36
72524: PUSH
72525: LD_VAR 0 2
72529: ARRAY
72530: PUSH
72531: LD_INT 1
72533: ARRAY
72534: PUSH
72535: LD_INT 1
72537: ARRAY
72538: PPUSH
72539: LD_EXP 36
72543: PUSH
72544: LD_VAR 0 2
72548: ARRAY
72549: PUSH
72550: LD_INT 1
72552: ARRAY
72553: PUSH
72554: LD_INT 2
72556: ARRAY
72557: PPUSH
72558: LD_EXP 36
72562: PUSH
72563: LD_VAR 0 2
72567: ARRAY
72568: PUSH
72569: LD_INT 1
72571: ARRAY
72572: PUSH
72573: LD_INT 3
72575: ARRAY
72576: PPUSH
72577: LD_EXP 36
72581: PUSH
72582: LD_VAR 0 2
72586: ARRAY
72587: PUSH
72588: LD_INT 1
72590: ARRAY
72591: PUSH
72592: LD_INT 4
72594: ARRAY
72595: PPUSH
72596: CALL 32952 0 5
72600: OR
72601: IFFALSE 72882
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
72603: LD_ADDR_VAR 0 5
72607: PUSH
72608: LD_EXP 31
72612: PUSH
72613: LD_VAR 0 2
72617: ARRAY
72618: PPUSH
72619: LD_INT 25
72621: PUSH
72622: LD_INT 2
72624: PUSH
72625: EMPTY
72626: LIST
72627: LIST
72628: PPUSH
72629: CALL_OW 72
72633: PUSH
72634: LD_EXP 33
72638: PUSH
72639: LD_VAR 0 2
72643: ARRAY
72644: DIFF
72645: ST_TO_ADDR
// if not tmp then
72646: LD_VAR 0 5
72650: NOT
72651: IFFALSE 72655
// continue ;
72653: GO 72483
// for j in tmp do
72655: LD_ADDR_VAR 0 3
72659: PUSH
72660: LD_VAR 0 5
72664: PUSH
72665: FOR_IN
72666: IFFALSE 72878
// begin if not mc_builders [ i ] then
72668: LD_EXP 37
72672: PUSH
72673: LD_VAR 0 2
72677: ARRAY
72678: NOT
72679: IFFALSE 72737
// begin SetTag ( j , 103 ) ;
72681: LD_VAR 0 3
72685: PPUSH
72686: LD_INT 103
72688: PPUSH
72689: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
72693: LD_ADDR_EXP 37
72697: PUSH
72698: LD_EXP 37
72702: PPUSH
72703: LD_VAR 0 2
72707: PUSH
72708: LD_EXP 37
72712: PUSH
72713: LD_VAR 0 2
72717: ARRAY
72718: PUSH
72719: LD_INT 1
72721: PLUS
72722: PUSH
72723: EMPTY
72724: LIST
72725: LIST
72726: PPUSH
72727: LD_VAR 0 3
72731: PPUSH
72732: CALL 24846 0 3
72736: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
72737: LD_VAR 0 3
72741: PPUSH
72742: CALL_OW 310
72746: IFFALSE 72757
// ComExitBuilding ( j ) ;
72748: LD_VAR 0 3
72752: PPUSH
72753: CALL_OW 122
// wait ( 3 ) ;
72757: LD_INT 3
72759: PPUSH
72760: CALL_OW 67
// if not mc_build_list [ i ] then
72764: LD_EXP 36
72768: PUSH
72769: LD_VAR 0 2
72773: ARRAY
72774: NOT
72775: IFFALSE 72779
// break ;
72777: GO 72878
// if not HasTask ( j ) then
72779: LD_VAR 0 3
72783: PPUSH
72784: CALL_OW 314
72788: NOT
72789: IFFALSE 72876
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
72791: LD_VAR 0 3
72795: PPUSH
72796: LD_EXP 36
72800: PUSH
72801: LD_VAR 0 2
72805: ARRAY
72806: PUSH
72807: LD_INT 1
72809: ARRAY
72810: PUSH
72811: LD_INT 1
72813: ARRAY
72814: PPUSH
72815: LD_EXP 36
72819: PUSH
72820: LD_VAR 0 2
72824: ARRAY
72825: PUSH
72826: LD_INT 1
72828: ARRAY
72829: PUSH
72830: LD_INT 2
72832: ARRAY
72833: PPUSH
72834: LD_EXP 36
72838: PUSH
72839: LD_VAR 0 2
72843: ARRAY
72844: PUSH
72845: LD_INT 1
72847: ARRAY
72848: PUSH
72849: LD_INT 3
72851: ARRAY
72852: PPUSH
72853: LD_EXP 36
72857: PUSH
72858: LD_VAR 0 2
72862: ARRAY
72863: PUSH
72864: LD_INT 1
72866: ARRAY
72867: PUSH
72868: LD_INT 4
72870: ARRAY
72871: PPUSH
72872: CALL_OW 145
// end ;
72876: GO 72665
72878: POP
72879: POP
// end else
72880: GO 73052
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
72882: LD_EXP 31
72886: PUSH
72887: LD_VAR 0 2
72891: ARRAY
72892: PPUSH
72893: LD_EXP 36
72897: PUSH
72898: LD_VAR 0 2
72902: ARRAY
72903: PUSH
72904: LD_INT 1
72906: ARRAY
72907: PUSH
72908: LD_INT 1
72910: ARRAY
72911: PPUSH
72912: LD_EXP 36
72916: PUSH
72917: LD_VAR 0 2
72921: ARRAY
72922: PUSH
72923: LD_INT 1
72925: ARRAY
72926: PUSH
72927: LD_INT 2
72929: ARRAY
72930: PPUSH
72931: LD_EXP 36
72935: PUSH
72936: LD_VAR 0 2
72940: ARRAY
72941: PUSH
72942: LD_INT 1
72944: ARRAY
72945: PUSH
72946: LD_INT 3
72948: ARRAY
72949: PPUSH
72950: LD_EXP 36
72954: PUSH
72955: LD_VAR 0 2
72959: ARRAY
72960: PUSH
72961: LD_INT 1
72963: ARRAY
72964: PUSH
72965: LD_INT 4
72967: ARRAY
72968: PPUSH
72969: LD_EXP 31
72973: PUSH
72974: LD_VAR 0 2
72978: ARRAY
72979: PPUSH
72980: LD_INT 21
72982: PUSH
72983: LD_INT 3
72985: PUSH
72986: EMPTY
72987: LIST
72988: LIST
72989: PPUSH
72990: CALL_OW 72
72994: PPUSH
72995: EMPTY
72996: PPUSH
72997: CALL 31706 0 7
73001: NOT
73002: IFFALSE 73052
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
73004: LD_ADDR_EXP 36
73008: PUSH
73009: LD_EXP 36
73013: PPUSH
73014: LD_VAR 0 2
73018: PPUSH
73019: LD_EXP 36
73023: PUSH
73024: LD_VAR 0 2
73028: ARRAY
73029: PPUSH
73030: LD_INT 1
73032: PPUSH
73033: LD_INT 1
73035: NEG
73036: PPUSH
73037: LD_INT 0
73039: PPUSH
73040: CALL 24264 0 4
73044: PPUSH
73045: CALL_OW 1
73049: ST_TO_ADDR
// continue ;
73050: GO 72483
// end ; end ;
73052: GO 72483
73054: POP
73055: POP
// end ; end ;
73056: GO 71912
73058: POP
73059: POP
// end ;
73060: LD_VAR 0 1
73064: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
73065: LD_INT 0
73067: PPUSH
73068: PPUSH
73069: PPUSH
73070: PPUSH
73071: PPUSH
73072: PPUSH
// if not mc_bases then
73073: LD_EXP 31
73077: NOT
73078: IFFALSE 73082
// exit ;
73080: GO 73509
// for i = 1 to mc_bases do
73082: LD_ADDR_VAR 0 2
73086: PUSH
73087: DOUBLE
73088: LD_INT 1
73090: DEC
73091: ST_TO_ADDR
73092: LD_EXP 31
73096: PUSH
73097: FOR_TO
73098: IFFALSE 73507
// begin tmp := mc_build_upgrade [ i ] ;
73100: LD_ADDR_VAR 0 4
73104: PUSH
73105: LD_EXP 63
73109: PUSH
73110: LD_VAR 0 2
73114: ARRAY
73115: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
73116: LD_ADDR_VAR 0 6
73120: PUSH
73121: LD_EXP 64
73125: PUSH
73126: LD_VAR 0 2
73130: ARRAY
73131: PPUSH
73132: LD_INT 2
73134: PUSH
73135: LD_INT 30
73137: PUSH
73138: LD_INT 6
73140: PUSH
73141: EMPTY
73142: LIST
73143: LIST
73144: PUSH
73145: LD_INT 30
73147: PUSH
73148: LD_INT 7
73150: PUSH
73151: EMPTY
73152: LIST
73153: LIST
73154: PUSH
73155: EMPTY
73156: LIST
73157: LIST
73158: LIST
73159: PPUSH
73160: CALL_OW 72
73164: ST_TO_ADDR
// if not tmp and not lab then
73165: LD_VAR 0 4
73169: NOT
73170: PUSH
73171: LD_VAR 0 6
73175: NOT
73176: AND
73177: IFFALSE 73181
// continue ;
73179: GO 73097
// if tmp then
73181: LD_VAR 0 4
73185: IFFALSE 73305
// for j in tmp do
73187: LD_ADDR_VAR 0 3
73191: PUSH
73192: LD_VAR 0 4
73196: PUSH
73197: FOR_IN
73198: IFFALSE 73303
// begin if UpgradeCost ( j ) then
73200: LD_VAR 0 3
73204: PPUSH
73205: CALL 31366 0 1
73209: IFFALSE 73301
// begin ComUpgrade ( j ) ;
73211: LD_VAR 0 3
73215: PPUSH
73216: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
73220: LD_ADDR_EXP 63
73224: PUSH
73225: LD_EXP 63
73229: PPUSH
73230: LD_VAR 0 2
73234: PPUSH
73235: LD_EXP 63
73239: PUSH
73240: LD_VAR 0 2
73244: ARRAY
73245: PUSH
73246: LD_VAR 0 3
73250: DIFF
73251: PPUSH
73252: CALL_OW 1
73256: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
73257: LD_ADDR_EXP 38
73261: PUSH
73262: LD_EXP 38
73266: PPUSH
73267: LD_VAR 0 2
73271: PUSH
73272: LD_EXP 38
73276: PUSH
73277: LD_VAR 0 2
73281: ARRAY
73282: PUSH
73283: LD_INT 1
73285: PLUS
73286: PUSH
73287: EMPTY
73288: LIST
73289: LIST
73290: PPUSH
73291: LD_VAR 0 3
73295: PPUSH
73296: CALL 24846 0 3
73300: ST_TO_ADDR
// end ; end ;
73301: GO 73197
73303: POP
73304: POP
// if not lab or not mc_lab_upgrade [ i ] then
73305: LD_VAR 0 6
73309: NOT
73310: PUSH
73311: LD_EXP 65
73315: PUSH
73316: LD_VAR 0 2
73320: ARRAY
73321: NOT
73322: OR
73323: IFFALSE 73327
// continue ;
73325: GO 73097
// for j in lab do
73327: LD_ADDR_VAR 0 3
73331: PUSH
73332: LD_VAR 0 6
73336: PUSH
73337: FOR_IN
73338: IFFALSE 73503
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
73340: LD_VAR 0 3
73344: PPUSH
73345: CALL_OW 266
73349: PUSH
73350: LD_INT 6
73352: PUSH
73353: LD_INT 7
73355: PUSH
73356: EMPTY
73357: LIST
73358: LIST
73359: IN
73360: PUSH
73361: LD_VAR 0 3
73365: PPUSH
73366: CALL_OW 461
73370: PUSH
73371: LD_INT 1
73373: NONEQUAL
73374: AND
73375: IFFALSE 73501
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
73377: LD_VAR 0 3
73381: PPUSH
73382: LD_EXP 65
73386: PUSH
73387: LD_VAR 0 2
73391: ARRAY
73392: PUSH
73393: LD_INT 1
73395: ARRAY
73396: PPUSH
73397: CALL 31571 0 2
73401: IFFALSE 73501
// begin ComCancel ( j ) ;
73403: LD_VAR 0 3
73407: PPUSH
73408: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
73412: LD_VAR 0 3
73416: PPUSH
73417: LD_EXP 65
73421: PUSH
73422: LD_VAR 0 2
73426: ARRAY
73427: PUSH
73428: LD_INT 1
73430: ARRAY
73431: PPUSH
73432: CALL_OW 207
// if not j in mc_construct_list [ i ] then
73436: LD_VAR 0 3
73440: PUSH
73441: LD_EXP 38
73445: PUSH
73446: LD_VAR 0 2
73450: ARRAY
73451: IN
73452: NOT
73453: IFFALSE 73499
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
73455: LD_ADDR_EXP 38
73459: PUSH
73460: LD_EXP 38
73464: PPUSH
73465: LD_VAR 0 2
73469: PUSH
73470: LD_EXP 38
73474: PUSH
73475: LD_VAR 0 2
73479: ARRAY
73480: PUSH
73481: LD_INT 1
73483: PLUS
73484: PUSH
73485: EMPTY
73486: LIST
73487: LIST
73488: PPUSH
73489: LD_VAR 0 3
73493: PPUSH
73494: CALL 24846 0 3
73498: ST_TO_ADDR
// break ;
73499: GO 73503
// end ; end ; end ;
73501: GO 73337
73503: POP
73504: POP
// end ;
73505: GO 73097
73507: POP
73508: POP
// end ;
73509: LD_VAR 0 1
73513: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
73514: LD_INT 0
73516: PPUSH
73517: PPUSH
73518: PPUSH
73519: PPUSH
73520: PPUSH
73521: PPUSH
73522: PPUSH
73523: PPUSH
73524: PPUSH
// if not mc_bases then
73525: LD_EXP 31
73529: NOT
73530: IFFALSE 73534
// exit ;
73532: GO 73939
// for i = 1 to mc_bases do
73534: LD_ADDR_VAR 0 2
73538: PUSH
73539: DOUBLE
73540: LD_INT 1
73542: DEC
73543: ST_TO_ADDR
73544: LD_EXP 31
73548: PUSH
73549: FOR_TO
73550: IFFALSE 73937
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
73552: LD_EXP 39
73556: PUSH
73557: LD_VAR 0 2
73561: ARRAY
73562: NOT
73563: PUSH
73564: LD_EXP 31
73568: PUSH
73569: LD_VAR 0 2
73573: ARRAY
73574: PPUSH
73575: LD_INT 30
73577: PUSH
73578: LD_INT 3
73580: PUSH
73581: EMPTY
73582: LIST
73583: LIST
73584: PPUSH
73585: CALL_OW 72
73589: NOT
73590: OR
73591: IFFALSE 73595
// continue ;
73593: GO 73549
// busy := false ;
73595: LD_ADDR_VAR 0 8
73599: PUSH
73600: LD_INT 0
73602: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
73603: LD_ADDR_VAR 0 4
73607: PUSH
73608: LD_EXP 31
73612: PUSH
73613: LD_VAR 0 2
73617: ARRAY
73618: PPUSH
73619: LD_INT 30
73621: PUSH
73622: LD_INT 3
73624: PUSH
73625: EMPTY
73626: LIST
73627: LIST
73628: PPUSH
73629: CALL_OW 72
73633: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
73634: LD_ADDR_VAR 0 6
73638: PUSH
73639: LD_EXP 39
73643: PUSH
73644: LD_VAR 0 2
73648: ARRAY
73649: PPUSH
73650: LD_INT 2
73652: PUSH
73653: LD_INT 30
73655: PUSH
73656: LD_INT 32
73658: PUSH
73659: EMPTY
73660: LIST
73661: LIST
73662: PUSH
73663: LD_INT 30
73665: PUSH
73666: LD_INT 33
73668: PUSH
73669: EMPTY
73670: LIST
73671: LIST
73672: PUSH
73673: EMPTY
73674: LIST
73675: LIST
73676: LIST
73677: PPUSH
73678: CALL_OW 72
73682: ST_TO_ADDR
// if not t then
73683: LD_VAR 0 6
73687: NOT
73688: IFFALSE 73692
// continue ;
73690: GO 73549
// for j in tmp do
73692: LD_ADDR_VAR 0 3
73696: PUSH
73697: LD_VAR 0 4
73701: PUSH
73702: FOR_IN
73703: IFFALSE 73733
// if not BuildingStatus ( j ) = bs_idle then
73705: LD_VAR 0 3
73709: PPUSH
73710: CALL_OW 461
73714: PUSH
73715: LD_INT 2
73717: EQUAL
73718: NOT
73719: IFFALSE 73731
// begin busy := true ;
73721: LD_ADDR_VAR 0 8
73725: PUSH
73726: LD_INT 1
73728: ST_TO_ADDR
// break ;
73729: GO 73733
// end ;
73731: GO 73702
73733: POP
73734: POP
// if busy then
73735: LD_VAR 0 8
73739: IFFALSE 73743
// continue ;
73741: GO 73549
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
73743: LD_ADDR_VAR 0 7
73747: PUSH
73748: LD_VAR 0 6
73752: PPUSH
73753: LD_INT 35
73755: PUSH
73756: LD_INT 0
73758: PUSH
73759: EMPTY
73760: LIST
73761: LIST
73762: PPUSH
73763: CALL_OW 72
73767: ST_TO_ADDR
// if tw then
73768: LD_VAR 0 7
73772: IFFALSE 73849
// begin tw := tw [ 1 ] ;
73774: LD_ADDR_VAR 0 7
73778: PUSH
73779: LD_VAR 0 7
73783: PUSH
73784: LD_INT 1
73786: ARRAY
73787: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
73788: LD_ADDR_VAR 0 9
73792: PUSH
73793: LD_VAR 0 7
73797: PPUSH
73798: LD_EXP 56
73802: PUSH
73803: LD_VAR 0 2
73807: ARRAY
73808: PPUSH
73809: CALL 29863 0 2
73813: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
73814: LD_EXP 70
73818: PUSH
73819: LD_VAR 0 2
73823: ARRAY
73824: IFFALSE 73847
// if not weapon in mc_allowed_tower_weapons [ i ] then
73826: LD_VAR 0 9
73830: PUSH
73831: LD_EXP 70
73835: PUSH
73836: LD_VAR 0 2
73840: ARRAY
73841: IN
73842: NOT
73843: IFFALSE 73847
// continue ;
73845: GO 73549
// end else
73847: GO 73912
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
73849: LD_ADDR_VAR 0 5
73853: PUSH
73854: LD_EXP 39
73858: PUSH
73859: LD_VAR 0 2
73863: ARRAY
73864: PPUSH
73865: LD_VAR 0 4
73869: PPUSH
73870: CALL 56753 0 2
73874: ST_TO_ADDR
// if not tmp2 then
73875: LD_VAR 0 5
73879: NOT
73880: IFFALSE 73884
// continue ;
73882: GO 73549
// tw := tmp2 [ 1 ] ;
73884: LD_ADDR_VAR 0 7
73888: PUSH
73889: LD_VAR 0 5
73893: PUSH
73894: LD_INT 1
73896: ARRAY
73897: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
73898: LD_ADDR_VAR 0 9
73902: PUSH
73903: LD_VAR 0 5
73907: PUSH
73908: LD_INT 2
73910: ARRAY
73911: ST_TO_ADDR
// end ; if not weapon then
73912: LD_VAR 0 9
73916: NOT
73917: IFFALSE 73921
// continue ;
73919: GO 73549
// ComPlaceWeapon ( tw , weapon ) ;
73921: LD_VAR 0 7
73925: PPUSH
73926: LD_VAR 0 9
73930: PPUSH
73931: CALL_OW 148
// end ;
73935: GO 73549
73937: POP
73938: POP
// end ;
73939: LD_VAR 0 1
73943: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
73944: LD_INT 0
73946: PPUSH
73947: PPUSH
73948: PPUSH
73949: PPUSH
73950: PPUSH
73951: PPUSH
73952: PPUSH
// if not mc_bases then
73953: LD_EXP 31
73957: NOT
73958: IFFALSE 73962
// exit ;
73960: GO 74737
// for i = 1 to mc_bases do
73962: LD_ADDR_VAR 0 2
73966: PUSH
73967: DOUBLE
73968: LD_INT 1
73970: DEC
73971: ST_TO_ADDR
73972: LD_EXP 31
73976: PUSH
73977: FOR_TO
73978: IFFALSE 74735
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
73980: LD_EXP 44
73984: PUSH
73985: LD_VAR 0 2
73989: ARRAY
73990: NOT
73991: PUSH
73992: LD_EXP 44
73996: PUSH
73997: LD_VAR 0 2
74001: ARRAY
74002: PUSH
74003: LD_EXP 45
74007: PUSH
74008: LD_VAR 0 2
74012: ARRAY
74013: EQUAL
74014: OR
74015: PUSH
74016: LD_EXP 54
74020: PUSH
74021: LD_VAR 0 2
74025: ARRAY
74026: OR
74027: IFFALSE 74031
// continue ;
74029: GO 73977
// if mc_miners [ i ] then
74031: LD_EXP 45
74035: PUSH
74036: LD_VAR 0 2
74040: ARRAY
74041: IFFALSE 74422
// begin for j = mc_miners [ i ] downto 1 do
74043: LD_ADDR_VAR 0 3
74047: PUSH
74048: DOUBLE
74049: LD_EXP 45
74053: PUSH
74054: LD_VAR 0 2
74058: ARRAY
74059: INC
74060: ST_TO_ADDR
74061: LD_INT 1
74063: PUSH
74064: FOR_DOWNTO
74065: IFFALSE 74420
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
74067: LD_EXP 45
74071: PUSH
74072: LD_VAR 0 2
74076: ARRAY
74077: PUSH
74078: LD_VAR 0 3
74082: ARRAY
74083: PPUSH
74084: CALL_OW 301
74088: PUSH
74089: LD_EXP 45
74093: PUSH
74094: LD_VAR 0 2
74098: ARRAY
74099: PUSH
74100: LD_VAR 0 3
74104: ARRAY
74105: PPUSH
74106: CALL_OW 257
74110: PUSH
74111: LD_INT 1
74113: NONEQUAL
74114: OR
74115: IFFALSE 74178
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
74117: LD_ADDR_VAR 0 5
74121: PUSH
74122: LD_EXP 45
74126: PUSH
74127: LD_VAR 0 2
74131: ARRAY
74132: PUSH
74133: LD_EXP 45
74137: PUSH
74138: LD_VAR 0 2
74142: ARRAY
74143: PUSH
74144: LD_VAR 0 3
74148: ARRAY
74149: DIFF
74150: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
74151: LD_ADDR_EXP 45
74155: PUSH
74156: LD_EXP 45
74160: PPUSH
74161: LD_VAR 0 2
74165: PPUSH
74166: LD_VAR 0 5
74170: PPUSH
74171: CALL_OW 1
74175: ST_TO_ADDR
// continue ;
74176: GO 74064
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
74178: LD_EXP 45
74182: PUSH
74183: LD_VAR 0 2
74187: ARRAY
74188: PUSH
74189: LD_VAR 0 3
74193: ARRAY
74194: PPUSH
74195: CALL_OW 257
74199: PUSH
74200: LD_INT 1
74202: EQUAL
74203: PUSH
74204: LD_EXP 45
74208: PUSH
74209: LD_VAR 0 2
74213: ARRAY
74214: PUSH
74215: LD_VAR 0 3
74219: ARRAY
74220: PPUSH
74221: CALL_OW 459
74225: NOT
74226: AND
74227: PUSH
74228: LD_EXP 45
74232: PUSH
74233: LD_VAR 0 2
74237: ARRAY
74238: PUSH
74239: LD_VAR 0 3
74243: ARRAY
74244: PPUSH
74245: CALL_OW 314
74249: NOT
74250: AND
74251: IFFALSE 74418
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
74253: LD_EXP 45
74257: PUSH
74258: LD_VAR 0 2
74262: ARRAY
74263: PUSH
74264: LD_VAR 0 3
74268: ARRAY
74269: PPUSH
74270: CALL_OW 310
74274: IFFALSE 74297
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
74276: LD_EXP 45
74280: PUSH
74281: LD_VAR 0 2
74285: ARRAY
74286: PUSH
74287: LD_VAR 0 3
74291: ARRAY
74292: PPUSH
74293: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
74297: LD_EXP 45
74301: PUSH
74302: LD_VAR 0 2
74306: ARRAY
74307: PUSH
74308: LD_VAR 0 3
74312: ARRAY
74313: PPUSH
74314: CALL_OW 314
74318: NOT
74319: IFFALSE 74418
// begin r := ( j mod Count ( mc_mines [ i ] ) ) + 1 ;
74321: LD_ADDR_VAR 0 7
74325: PUSH
74326: LD_VAR 0 3
74330: PUSH
74331: LD_EXP 44
74335: PUSH
74336: LD_VAR 0 2
74340: ARRAY
74341: PPUSH
74342: CALL 21986 0 1
74346: MOD
74347: PUSH
74348: LD_INT 1
74350: PLUS
74351: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
74352: LD_EXP 45
74356: PUSH
74357: LD_VAR 0 2
74361: ARRAY
74362: PUSH
74363: LD_VAR 0 3
74367: ARRAY
74368: PPUSH
74369: LD_EXP 44
74373: PUSH
74374: LD_VAR 0 2
74378: ARRAY
74379: PUSH
74380: LD_VAR 0 7
74384: ARRAY
74385: PUSH
74386: LD_INT 1
74388: ARRAY
74389: PPUSH
74390: LD_EXP 44
74394: PUSH
74395: LD_VAR 0 2
74399: ARRAY
74400: PUSH
74401: LD_VAR 0 7
74405: ARRAY
74406: PUSH
74407: LD_INT 2
74409: ARRAY
74410: PPUSH
74411: LD_INT 0
74413: PPUSH
74414: CALL_OW 193
// end ; end ; end ;
74418: GO 74064
74420: POP
74421: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
74422: LD_ADDR_VAR 0 5
74426: PUSH
74427: LD_EXP 31
74431: PUSH
74432: LD_VAR 0 2
74436: ARRAY
74437: PPUSH
74438: LD_INT 2
74440: PUSH
74441: LD_INT 30
74443: PUSH
74444: LD_INT 4
74446: PUSH
74447: EMPTY
74448: LIST
74449: LIST
74450: PUSH
74451: LD_INT 30
74453: PUSH
74454: LD_INT 5
74456: PUSH
74457: EMPTY
74458: LIST
74459: LIST
74460: PUSH
74461: LD_INT 30
74463: PUSH
74464: LD_INT 32
74466: PUSH
74467: EMPTY
74468: LIST
74469: LIST
74470: PUSH
74471: EMPTY
74472: LIST
74473: LIST
74474: LIST
74475: LIST
74476: PPUSH
74477: CALL_OW 72
74481: ST_TO_ADDR
// if not tmp then
74482: LD_VAR 0 5
74486: NOT
74487: IFFALSE 74491
// continue ;
74489: GO 73977
// list := [ ] ;
74491: LD_ADDR_VAR 0 6
74495: PUSH
74496: EMPTY
74497: ST_TO_ADDR
// for j in tmp do
74498: LD_ADDR_VAR 0 3
74502: PUSH
74503: LD_VAR 0 5
74507: PUSH
74508: FOR_IN
74509: IFFALSE 74578
// begin for k in UnitsInside ( j ) do
74511: LD_ADDR_VAR 0 4
74515: PUSH
74516: LD_VAR 0 3
74520: PPUSH
74521: CALL_OW 313
74525: PUSH
74526: FOR_IN
74527: IFFALSE 74574
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
74529: LD_VAR 0 4
74533: PPUSH
74534: CALL_OW 257
74538: PUSH
74539: LD_INT 1
74541: EQUAL
74542: PUSH
74543: LD_VAR 0 4
74547: PPUSH
74548: CALL_OW 459
74552: NOT
74553: AND
74554: IFFALSE 74572
// list := list ^ k ;
74556: LD_ADDR_VAR 0 6
74560: PUSH
74561: LD_VAR 0 6
74565: PUSH
74566: LD_VAR 0 4
74570: ADD
74571: ST_TO_ADDR
74572: GO 74526
74574: POP
74575: POP
// end ;
74576: GO 74508
74578: POP
74579: POP
// list := list diff mc_miners [ i ] ;
74580: LD_ADDR_VAR 0 6
74584: PUSH
74585: LD_VAR 0 6
74589: PUSH
74590: LD_EXP 45
74594: PUSH
74595: LD_VAR 0 2
74599: ARRAY
74600: DIFF
74601: ST_TO_ADDR
// if not list then
74602: LD_VAR 0 6
74606: NOT
74607: IFFALSE 74611
// continue ;
74609: GO 73977
// k := mc_mines [ i ] - mc_miners [ i ] ;
74611: LD_ADDR_VAR 0 4
74615: PUSH
74616: LD_EXP 44
74620: PUSH
74621: LD_VAR 0 2
74625: ARRAY
74626: PUSH
74627: LD_EXP 45
74631: PUSH
74632: LD_VAR 0 2
74636: ARRAY
74637: MINUS
74638: ST_TO_ADDR
// if k > list then
74639: LD_VAR 0 4
74643: PUSH
74644: LD_VAR 0 6
74648: GREATER
74649: IFFALSE 74661
// k := list ;
74651: LD_ADDR_VAR 0 4
74655: PUSH
74656: LD_VAR 0 6
74660: ST_TO_ADDR
// for j = 1 to k do
74661: LD_ADDR_VAR 0 3
74665: PUSH
74666: DOUBLE
74667: LD_INT 1
74669: DEC
74670: ST_TO_ADDR
74671: LD_VAR 0 4
74675: PUSH
74676: FOR_TO
74677: IFFALSE 74731
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
74679: LD_ADDR_EXP 45
74683: PUSH
74684: LD_EXP 45
74688: PPUSH
74689: LD_VAR 0 2
74693: PUSH
74694: LD_EXP 45
74698: PUSH
74699: LD_VAR 0 2
74703: ARRAY
74704: PUSH
74705: LD_INT 1
74707: PLUS
74708: PUSH
74709: EMPTY
74710: LIST
74711: LIST
74712: PPUSH
74713: LD_VAR 0 6
74717: PUSH
74718: LD_VAR 0 3
74722: ARRAY
74723: PPUSH
74724: CALL 24846 0 3
74728: ST_TO_ADDR
74729: GO 74676
74731: POP
74732: POP
// end ;
74733: GO 73977
74735: POP
74736: POP
// end ;
74737: LD_VAR 0 1
74741: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , side , target , cargo , depot , fac , components ; begin
74742: LD_INT 0
74744: PPUSH
74745: PPUSH
74746: PPUSH
74747: PPUSH
74748: PPUSH
74749: PPUSH
74750: PPUSH
74751: PPUSH
74752: PPUSH
74753: PPUSH
74754: PPUSH
// if not mc_bases then
74755: LD_EXP 31
74759: NOT
74760: IFFALSE 74764
// exit ;
74762: GO 76587
// for i = 1 to mc_bases do
74764: LD_ADDR_VAR 0 2
74768: PUSH
74769: DOUBLE
74770: LD_INT 1
74772: DEC
74773: ST_TO_ADDR
74774: LD_EXP 31
74778: PUSH
74779: FOR_TO
74780: IFFALSE 76585
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
74782: LD_EXP 31
74786: PUSH
74787: LD_VAR 0 2
74791: ARRAY
74792: NOT
74793: PUSH
74794: LD_EXP 38
74798: PUSH
74799: LD_VAR 0 2
74803: ARRAY
74804: OR
74805: IFFALSE 74809
// continue ;
74807: GO 74779
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
74809: LD_EXP 47
74813: PUSH
74814: LD_VAR 0 2
74818: ARRAY
74819: NOT
74820: PUSH
74821: LD_EXP 48
74825: PUSH
74826: LD_VAR 0 2
74830: ARRAY
74831: AND
74832: IFFALSE 74870
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
74834: LD_ADDR_EXP 48
74838: PUSH
74839: LD_EXP 48
74843: PPUSH
74844: LD_VAR 0 2
74848: PPUSH
74849: EMPTY
74850: PPUSH
74851: CALL_OW 1
74855: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
74856: LD_VAR 0 2
74860: PPUSH
74861: LD_INT 107
74863: PPUSH
74864: CALL 65596 0 2
// continue ;
74868: GO 74779
// end ; target := [ ] ;
74870: LD_ADDR_VAR 0 7
74874: PUSH
74875: EMPTY
74876: ST_TO_ADDR
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
74877: LD_ADDR_VAR 0 6
74881: PUSH
74882: LD_EXP 31
74886: PUSH
74887: LD_VAR 0 2
74891: ARRAY
74892: PUSH
74893: LD_INT 1
74895: ARRAY
74896: PPUSH
74897: CALL_OW 255
74901: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
74902: LD_ADDR_VAR 0 9
74906: PUSH
74907: LD_EXP 31
74911: PUSH
74912: LD_VAR 0 2
74916: ARRAY
74917: PPUSH
74918: LD_INT 2
74920: PUSH
74921: LD_INT 30
74923: PUSH
74924: LD_INT 0
74926: PUSH
74927: EMPTY
74928: LIST
74929: LIST
74930: PUSH
74931: LD_INT 30
74933: PUSH
74934: LD_INT 1
74936: PUSH
74937: EMPTY
74938: LIST
74939: LIST
74940: PUSH
74941: EMPTY
74942: LIST
74943: LIST
74944: LIST
74945: PPUSH
74946: CALL_OW 72
74950: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
74951: LD_ADDR_VAR 0 3
74955: PUSH
74956: DOUBLE
74957: LD_EXP 47
74961: PUSH
74962: LD_VAR 0 2
74966: ARRAY
74967: INC
74968: ST_TO_ADDR
74969: LD_INT 1
74971: PUSH
74972: FOR_DOWNTO
74973: IFFALSE 75218
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
74975: LD_EXP 47
74979: PUSH
74980: LD_VAR 0 2
74984: ARRAY
74985: PUSH
74986: LD_VAR 0 3
74990: ARRAY
74991: PUSH
74992: LD_INT 2
74994: ARRAY
74995: PPUSH
74996: LD_EXP 47
75000: PUSH
75001: LD_VAR 0 2
75005: ARRAY
75006: PUSH
75007: LD_VAR 0 3
75011: ARRAY
75012: PUSH
75013: LD_INT 3
75015: ARRAY
75016: PPUSH
75017: CALL_OW 488
75021: PUSH
75022: LD_EXP 47
75026: PUSH
75027: LD_VAR 0 2
75031: ARRAY
75032: PUSH
75033: LD_VAR 0 3
75037: ARRAY
75038: PUSH
75039: LD_INT 2
75041: ARRAY
75042: PPUSH
75043: LD_EXP 47
75047: PUSH
75048: LD_VAR 0 2
75052: ARRAY
75053: PUSH
75054: LD_VAR 0 3
75058: ARRAY
75059: PUSH
75060: LD_INT 3
75062: ARRAY
75063: PPUSH
75064: CALL_OW 284
75068: PUSH
75069: LD_INT 0
75071: EQUAL
75072: AND
75073: IFFALSE 75128
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
75075: LD_ADDR_VAR 0 5
75079: PUSH
75080: LD_EXP 47
75084: PUSH
75085: LD_VAR 0 2
75089: ARRAY
75090: PPUSH
75091: LD_VAR 0 3
75095: PPUSH
75096: CALL_OW 3
75100: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
75101: LD_ADDR_EXP 47
75105: PUSH
75106: LD_EXP 47
75110: PPUSH
75111: LD_VAR 0 2
75115: PPUSH
75116: LD_VAR 0 5
75120: PPUSH
75121: CALL_OW 1
75125: ST_TO_ADDR
// continue ;
75126: GO 74972
// end ; if DangerAtRangeXY ( side , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
75128: LD_VAR 0 6
75132: PPUSH
75133: LD_EXP 47
75137: PUSH
75138: LD_VAR 0 2
75142: ARRAY
75143: PUSH
75144: LD_VAR 0 3
75148: ARRAY
75149: PUSH
75150: LD_INT 2
75152: ARRAY
75153: PPUSH
75154: LD_EXP 47
75158: PUSH
75159: LD_VAR 0 2
75163: ARRAY
75164: PUSH
75165: LD_VAR 0 3
75169: ARRAY
75170: PUSH
75171: LD_INT 3
75173: ARRAY
75174: PPUSH
75175: LD_INT 30
75177: PPUSH
75178: CALL 25742 0 4
75182: PUSH
75183: LD_INT 4
75185: ARRAY
75186: PUSH
75187: LD_INT 0
75189: EQUAL
75190: IFFALSE 75216
// begin target := mc_crates [ i ] [ j ] ;
75192: LD_ADDR_VAR 0 7
75196: PUSH
75197: LD_EXP 47
75201: PUSH
75202: LD_VAR 0 2
75206: ARRAY
75207: PUSH
75208: LD_VAR 0 3
75212: ARRAY
75213: ST_TO_ADDR
// break ;
75214: GO 75218
// end ; end ;
75216: GO 74972
75218: POP
75219: POP
// if not target then
75220: LD_VAR 0 7
75224: NOT
75225: IFFALSE 75229
// continue ;
75227: GO 74779
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
75229: LD_ADDR_VAR 0 8
75233: PUSH
75234: LD_EXP 50
75238: PUSH
75239: LD_VAR 0 2
75243: ARRAY
75244: PPUSH
75245: LD_INT 2
75247: PUSH
75248: LD_INT 3
75250: PUSH
75251: LD_INT 58
75253: PUSH
75254: EMPTY
75255: LIST
75256: PUSH
75257: EMPTY
75258: LIST
75259: LIST
75260: PUSH
75261: LD_INT 61
75263: PUSH
75264: EMPTY
75265: LIST
75266: PUSH
75267: LD_INT 33
75269: PUSH
75270: LD_INT 5
75272: PUSH
75273: EMPTY
75274: LIST
75275: LIST
75276: PUSH
75277: LD_INT 33
75279: PUSH
75280: LD_INT 3
75282: PUSH
75283: EMPTY
75284: LIST
75285: LIST
75286: PUSH
75287: EMPTY
75288: LIST
75289: LIST
75290: LIST
75291: LIST
75292: LIST
75293: PUSH
75294: LD_INT 2
75296: PUSH
75297: LD_INT 34
75299: PUSH
75300: LD_INT 32
75302: PUSH
75303: EMPTY
75304: LIST
75305: LIST
75306: PUSH
75307: LD_INT 34
75309: PUSH
75310: LD_INT 51
75312: PUSH
75313: EMPTY
75314: LIST
75315: LIST
75316: PUSH
75317: LD_INT 34
75319: PUSH
75320: LD_INT 12
75322: PUSH
75323: EMPTY
75324: LIST
75325: LIST
75326: PUSH
75327: EMPTY
75328: LIST
75329: LIST
75330: LIST
75331: LIST
75332: PUSH
75333: EMPTY
75334: LIST
75335: LIST
75336: PPUSH
75337: CALL_OW 72
75341: ST_TO_ADDR
// if not cargo then
75342: LD_VAR 0 8
75346: NOT
75347: IFFALSE 76053
// begin if mc_crates_collector [ i ] < 5 then
75349: LD_EXP 48
75353: PUSH
75354: LD_VAR 0 2
75358: ARRAY
75359: PUSH
75360: LD_INT 5
75362: LESS
75363: IFFALSE 75729
// begin if mc_ape [ i ] then
75365: LD_EXP 60
75369: PUSH
75370: LD_VAR 0 2
75374: ARRAY
75375: IFFALSE 75422
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
75377: LD_ADDR_VAR 0 5
75381: PUSH
75382: LD_EXP 60
75386: PUSH
75387: LD_VAR 0 2
75391: ARRAY
75392: PPUSH
75393: LD_INT 25
75395: PUSH
75396: LD_INT 16
75398: PUSH
75399: EMPTY
75400: LIST
75401: LIST
75402: PUSH
75403: LD_INT 24
75405: PUSH
75406: LD_INT 750
75408: PUSH
75409: EMPTY
75410: LIST
75411: LIST
75412: PUSH
75413: EMPTY
75414: LIST
75415: LIST
75416: PPUSH
75417: CALL_OW 72
75421: ST_TO_ADDR
// if not tmp then
75422: LD_VAR 0 5
75426: NOT
75427: IFFALSE 75474
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
75429: LD_ADDR_VAR 0 5
75433: PUSH
75434: LD_EXP 31
75438: PUSH
75439: LD_VAR 0 2
75443: ARRAY
75444: PPUSH
75445: LD_INT 25
75447: PUSH
75448: LD_INT 2
75450: PUSH
75451: EMPTY
75452: LIST
75453: LIST
75454: PUSH
75455: LD_INT 24
75457: PUSH
75458: LD_INT 750
75460: PUSH
75461: EMPTY
75462: LIST
75463: LIST
75464: PUSH
75465: EMPTY
75466: LIST
75467: LIST
75468: PPUSH
75469: CALL_OW 72
75473: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
75474: LD_EXP 60
75478: PUSH
75479: LD_VAR 0 2
75483: ARRAY
75484: PUSH
75485: LD_EXP 31
75489: PUSH
75490: LD_VAR 0 2
75494: ARRAY
75495: PPUSH
75496: LD_INT 25
75498: PUSH
75499: LD_INT 2
75501: PUSH
75502: EMPTY
75503: LIST
75504: LIST
75505: PUSH
75506: LD_INT 24
75508: PUSH
75509: LD_INT 750
75511: PUSH
75512: EMPTY
75513: LIST
75514: LIST
75515: PUSH
75516: EMPTY
75517: LIST
75518: LIST
75519: PPUSH
75520: CALL_OW 72
75524: AND
75525: PUSH
75526: LD_VAR 0 5
75530: PUSH
75531: LD_INT 5
75533: LESS
75534: AND
75535: IFFALSE 75617
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
75537: LD_ADDR_VAR 0 3
75541: PUSH
75542: LD_EXP 31
75546: PUSH
75547: LD_VAR 0 2
75551: ARRAY
75552: PPUSH
75553: LD_INT 25
75555: PUSH
75556: LD_INT 2
75558: PUSH
75559: EMPTY
75560: LIST
75561: LIST
75562: PUSH
75563: LD_INT 24
75565: PUSH
75566: LD_INT 750
75568: PUSH
75569: EMPTY
75570: LIST
75571: LIST
75572: PUSH
75573: EMPTY
75574: LIST
75575: LIST
75576: PPUSH
75577: CALL_OW 72
75581: PUSH
75582: FOR_IN
75583: IFFALSE 75615
// begin tmp := tmp union j ;
75585: LD_ADDR_VAR 0 5
75589: PUSH
75590: LD_VAR 0 5
75594: PUSH
75595: LD_VAR 0 3
75599: UNION
75600: ST_TO_ADDR
// if tmp >= 5 then
75601: LD_VAR 0 5
75605: PUSH
75606: LD_INT 5
75608: GREATEREQUAL
75609: IFFALSE 75613
// break ;
75611: GO 75615
// end ;
75613: GO 75582
75615: POP
75616: POP
// end ; if not tmp then
75617: LD_VAR 0 5
75621: NOT
75622: IFFALSE 75626
// continue ;
75624: GO 74779
// for j in tmp do
75626: LD_ADDR_VAR 0 3
75630: PUSH
75631: LD_VAR 0 5
75635: PUSH
75636: FOR_IN
75637: IFFALSE 75727
// if not GetTag ( j ) then
75639: LD_VAR 0 3
75643: PPUSH
75644: CALL_OW 110
75648: NOT
75649: IFFALSE 75725
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
75651: LD_ADDR_EXP 48
75655: PUSH
75656: LD_EXP 48
75660: PPUSH
75661: LD_VAR 0 2
75665: PUSH
75666: LD_EXP 48
75670: PUSH
75671: LD_VAR 0 2
75675: ARRAY
75676: PUSH
75677: LD_INT 1
75679: PLUS
75680: PUSH
75681: EMPTY
75682: LIST
75683: LIST
75684: PPUSH
75685: LD_VAR 0 3
75689: PPUSH
75690: CALL 24846 0 3
75694: ST_TO_ADDR
// SetTag ( j , 107 ) ;
75695: LD_VAR 0 3
75699: PPUSH
75700: LD_INT 107
75702: PPUSH
75703: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
75707: LD_EXP 48
75711: PUSH
75712: LD_VAR 0 2
75716: ARRAY
75717: PUSH
75718: LD_INT 5
75720: GREATEREQUAL
75721: IFFALSE 75725
// break ;
75723: GO 75727
// end ;
75725: GO 75636
75727: POP
75728: POP
// end ; if mc_crates_collector [ i ] and target then
75729: LD_EXP 48
75733: PUSH
75734: LD_VAR 0 2
75738: ARRAY
75739: PUSH
75740: LD_VAR 0 7
75744: AND
75745: IFFALSE 76051
// begin if mc_crates_collector [ i ] < target [ 1 ] then
75747: LD_EXP 48
75751: PUSH
75752: LD_VAR 0 2
75756: ARRAY
75757: PUSH
75758: LD_VAR 0 7
75762: PUSH
75763: LD_INT 1
75765: ARRAY
75766: LESS
75767: IFFALSE 75787
// tmp := mc_crates_collector [ i ] else
75769: LD_ADDR_VAR 0 5
75773: PUSH
75774: LD_EXP 48
75778: PUSH
75779: LD_VAR 0 2
75783: ARRAY
75784: ST_TO_ADDR
75785: GO 75801
// tmp := target [ 1 ] ;
75787: LD_ADDR_VAR 0 5
75791: PUSH
75792: LD_VAR 0 7
75796: PUSH
75797: LD_INT 1
75799: ARRAY
75800: ST_TO_ADDR
// k := 0 ;
75801: LD_ADDR_VAR 0 4
75805: PUSH
75806: LD_INT 0
75808: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
75809: LD_ADDR_VAR 0 3
75813: PUSH
75814: LD_EXP 48
75818: PUSH
75819: LD_VAR 0 2
75823: ARRAY
75824: PUSH
75825: FOR_IN
75826: IFFALSE 76049
// begin k := k + 1 ;
75828: LD_ADDR_VAR 0 4
75832: PUSH
75833: LD_VAR 0 4
75837: PUSH
75838: LD_INT 1
75840: PLUS
75841: ST_TO_ADDR
// if k > tmp then
75842: LD_VAR 0 4
75846: PUSH
75847: LD_VAR 0 5
75851: GREATER
75852: IFFALSE 75856
// break ;
75854: GO 76049
// if not GetClass ( j ) in [ 2 , 16 ] then
75856: LD_VAR 0 3
75860: PPUSH
75861: CALL_OW 257
75865: PUSH
75866: LD_INT 2
75868: PUSH
75869: LD_INT 16
75871: PUSH
75872: EMPTY
75873: LIST
75874: LIST
75875: IN
75876: NOT
75877: IFFALSE 75930
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
75879: LD_ADDR_EXP 48
75883: PUSH
75884: LD_EXP 48
75888: PPUSH
75889: LD_VAR 0 2
75893: PPUSH
75894: LD_EXP 48
75898: PUSH
75899: LD_VAR 0 2
75903: ARRAY
75904: PUSH
75905: LD_VAR 0 3
75909: DIFF
75910: PPUSH
75911: CALL_OW 1
75915: ST_TO_ADDR
// SetTag ( j , 0 ) ;
75916: LD_VAR 0 3
75920: PPUSH
75921: LD_INT 0
75923: PPUSH
75924: CALL_OW 109
// continue ;
75928: GO 75825
// end ; if IsInUnit ( j ) then
75930: LD_VAR 0 3
75934: PPUSH
75935: CALL_OW 310
75939: IFFALSE 75950
// ComExitBuilding ( j ) ;
75941: LD_VAR 0 3
75945: PPUSH
75946: CALL_OW 122
// wait ( 3 ) ;
75950: LD_INT 3
75952: PPUSH
75953: CALL_OW 67
// if HasTask ( j ) and DangerAtRangeXY ( side , target [ 2 ] , target [ 3 ] , 30 ) [ 4 ] then
75957: LD_VAR 0 3
75961: PPUSH
75962: CALL_OW 314
75966: PUSH
75967: LD_VAR 0 6
75971: PPUSH
75972: LD_VAR 0 7
75976: PUSH
75977: LD_INT 2
75979: ARRAY
75980: PPUSH
75981: LD_VAR 0 7
75985: PUSH
75986: LD_INT 3
75988: ARRAY
75989: PPUSH
75990: LD_INT 30
75992: PPUSH
75993: CALL 25742 0 4
75997: PUSH
75998: LD_INT 4
76000: ARRAY
76001: AND
76002: IFFALSE 76020
// ComStandNearbyBuilding ( j , depot ) else
76004: LD_VAR 0 3
76008: PPUSH
76009: LD_VAR 0 9
76013: PPUSH
76014: CALL 21448 0 2
76018: GO 76047
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
76020: LD_VAR 0 3
76024: PPUSH
76025: LD_VAR 0 7
76029: PUSH
76030: LD_INT 2
76032: ARRAY
76033: PPUSH
76034: LD_VAR 0 7
76038: PUSH
76039: LD_INT 3
76041: ARRAY
76042: PPUSH
76043: CALL_OW 117
// end ;
76047: GO 75825
76049: POP
76050: POP
// end ; end else
76051: GO 76583
// begin for j in cargo do
76053: LD_ADDR_VAR 0 3
76057: PUSH
76058: LD_VAR 0 8
76062: PUSH
76063: FOR_IN
76064: IFFALSE 76581
// begin if GetTag ( j ) <> 0 then
76066: LD_VAR 0 3
76070: PPUSH
76071: CALL_OW 110
76075: PUSH
76076: LD_INT 0
76078: NONEQUAL
76079: IFFALSE 76083
// continue ;
76081: GO 76063
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
76083: LD_VAR 0 3
76087: PPUSH
76088: CALL_OW 256
76092: PUSH
76093: LD_INT 1000
76095: LESS
76096: PUSH
76097: LD_VAR 0 3
76101: PPUSH
76102: LD_EXP 55
76106: PUSH
76107: LD_VAR 0 2
76111: ARRAY
76112: PPUSH
76113: CALL_OW 308
76117: NOT
76118: AND
76119: IFFALSE 76141
// ComMoveToArea ( j , mc_parking [ i ] ) ;
76121: LD_VAR 0 3
76125: PPUSH
76126: LD_EXP 55
76130: PUSH
76131: LD_VAR 0 2
76135: ARRAY
76136: PPUSH
76137: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
76141: LD_VAR 0 3
76145: PPUSH
76146: CALL_OW 256
76150: PUSH
76151: LD_INT 1000
76153: LESS
76154: PUSH
76155: LD_VAR 0 3
76159: PPUSH
76160: LD_EXP 55
76164: PUSH
76165: LD_VAR 0 2
76169: ARRAY
76170: PPUSH
76171: CALL_OW 308
76175: AND
76176: IFFALSE 76180
// continue ;
76178: GO 76063
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
76180: LD_VAR 0 3
76184: PPUSH
76185: CALL_OW 262
76189: PUSH
76190: LD_INT 2
76192: EQUAL
76193: PUSH
76194: LD_VAR 0 3
76198: PPUSH
76199: CALL_OW 261
76203: PUSH
76204: LD_INT 15
76206: LESS
76207: AND
76208: IFFALSE 76212
// continue ;
76210: GO 76063
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
76212: LD_VAR 0 3
76216: PPUSH
76217: CALL_OW 262
76221: PUSH
76222: LD_INT 1
76224: EQUAL
76225: PUSH
76226: LD_VAR 0 3
76230: PPUSH
76231: CALL_OW 261
76235: PUSH
76236: LD_INT 10
76238: LESS
76239: AND
76240: IFFALSE 76520
// begin if not depot then
76242: LD_VAR 0 9
76246: NOT
76247: IFFALSE 76251
// continue ;
76249: GO 76063
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
76251: LD_VAR 0 3
76255: PPUSH
76256: LD_VAR 0 9
76260: PPUSH
76261: LD_VAR 0 3
76265: PPUSH
76266: CALL_OW 74
76270: PPUSH
76271: CALL_OW 296
76275: PUSH
76276: LD_INT 6
76278: LESS
76279: IFFALSE 76295
// SetFuel ( j , 100 ) else
76281: LD_VAR 0 3
76285: PPUSH
76286: LD_INT 100
76288: PPUSH
76289: CALL_OW 240
76293: GO 76520
// if GetFuel ( j ) = 0 then
76295: LD_VAR 0 3
76299: PPUSH
76300: CALL_OW 261
76304: PUSH
76305: LD_INT 0
76307: EQUAL
76308: IFFALSE 76520
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
76310: LD_ADDR_EXP 50
76314: PUSH
76315: LD_EXP 50
76319: PPUSH
76320: LD_VAR 0 2
76324: PPUSH
76325: LD_EXP 50
76329: PUSH
76330: LD_VAR 0 2
76334: ARRAY
76335: PUSH
76336: LD_VAR 0 3
76340: DIFF
76341: PPUSH
76342: CALL_OW 1
76346: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
76347: LD_VAR 0 3
76351: PPUSH
76352: CALL_OW 263
76356: PUSH
76357: LD_INT 1
76359: EQUAL
76360: IFFALSE 76376
// ComExitVehicle ( IsInUnit ( j ) ) ;
76362: LD_VAR 0 3
76366: PPUSH
76367: CALL_OW 310
76371: PPUSH
76372: CALL_OW 121
// if GetControl ( j ) = control_remote then
76376: LD_VAR 0 3
76380: PPUSH
76381: CALL_OW 263
76385: PUSH
76386: LD_INT 2
76388: EQUAL
76389: IFFALSE 76400
// ComUnlink ( j ) ;
76391: LD_VAR 0 3
76395: PPUSH
76396: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
76400: LD_ADDR_VAR 0 10
76404: PUSH
76405: LD_VAR 0 2
76409: PPUSH
76410: LD_INT 3
76412: PPUSH
76413: CALL 86164 0 2
76417: ST_TO_ADDR
// if fac then
76418: LD_VAR 0 10
76422: IFFALSE 76518
// begin for k in fac do
76424: LD_ADDR_VAR 0 4
76428: PUSH
76429: LD_VAR 0 10
76433: PUSH
76434: FOR_IN
76435: IFFALSE 76516
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
76437: LD_ADDR_VAR 0 11
76441: PUSH
76442: LD_VAR 0 10
76446: PPUSH
76447: LD_VAR 0 3
76451: PPUSH
76452: CALL_OW 265
76456: PPUSH
76457: LD_VAR 0 3
76461: PPUSH
76462: CALL_OW 262
76466: PPUSH
76467: LD_VAR 0 3
76471: PPUSH
76472: CALL_OW 263
76476: PPUSH
76477: LD_VAR 0 3
76481: PPUSH
76482: CALL_OW 264
76486: PPUSH
76487: CALL 22344 0 5
76491: ST_TO_ADDR
// if components then
76492: LD_VAR 0 11
76496: IFFALSE 76514
// begin MC_InsertProduceList ( i , components ) ;
76498: LD_VAR 0 2
76502: PPUSH
76503: LD_VAR 0 11
76507: PPUSH
76508: CALL 85709 0 2
// break ;
76512: GO 76516
// end ; end ;
76514: GO 76434
76516: POP
76517: POP
// end ; continue ;
76518: GO 76063
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
76520: LD_VAR 0 3
76524: PPUSH
76525: LD_INT 1
76527: PPUSH
76528: CALL_OW 289
76532: PUSH
76533: LD_INT 100
76535: LESS
76536: PUSH
76537: LD_VAR 0 3
76541: PPUSH
76542: CALL_OW 314
76546: NOT
76547: AND
76548: IFFALSE 76577
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
76550: LD_VAR 0 3
76554: PPUSH
76555: LD_VAR 0 7
76559: PUSH
76560: LD_INT 2
76562: ARRAY
76563: PPUSH
76564: LD_VAR 0 7
76568: PUSH
76569: LD_INT 3
76571: ARRAY
76572: PPUSH
76573: CALL_OW 117
// break ;
76577: GO 76581
// end ;
76579: GO 76063
76581: POP
76582: POP
// end ; end ;
76583: GO 74779
76585: POP
76586: POP
// end ;
76587: LD_VAR 0 1
76591: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
76592: LD_INT 0
76594: PPUSH
76595: PPUSH
76596: PPUSH
76597: PPUSH
// if not mc_bases then
76598: LD_EXP 31
76602: NOT
76603: IFFALSE 76607
// exit ;
76605: GO 76768
// for i = 1 to mc_bases do
76607: LD_ADDR_VAR 0 2
76611: PUSH
76612: DOUBLE
76613: LD_INT 1
76615: DEC
76616: ST_TO_ADDR
76617: LD_EXP 31
76621: PUSH
76622: FOR_TO
76623: IFFALSE 76766
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
76625: LD_ADDR_VAR 0 4
76629: PUSH
76630: LD_EXP 50
76634: PUSH
76635: LD_VAR 0 2
76639: ARRAY
76640: PUSH
76641: LD_EXP 53
76645: PUSH
76646: LD_VAR 0 2
76650: ARRAY
76651: UNION
76652: PPUSH
76653: LD_INT 33
76655: PUSH
76656: LD_INT 2
76658: PUSH
76659: EMPTY
76660: LIST
76661: LIST
76662: PPUSH
76663: CALL_OW 72
76667: ST_TO_ADDR
// if tmp then
76668: LD_VAR 0 4
76672: IFFALSE 76764
// for j in tmp do
76674: LD_ADDR_VAR 0 3
76678: PUSH
76679: LD_VAR 0 4
76683: PUSH
76684: FOR_IN
76685: IFFALSE 76762
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
76687: LD_VAR 0 3
76691: PPUSH
76692: CALL_OW 312
76696: NOT
76697: PUSH
76698: LD_VAR 0 3
76702: PPUSH
76703: CALL_OW 256
76707: PUSH
76708: LD_INT 250
76710: GREATEREQUAL
76711: AND
76712: IFFALSE 76725
// Connect ( j ) else
76714: LD_VAR 0 3
76718: PPUSH
76719: CALL 27824 0 1
76723: GO 76760
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
76725: LD_VAR 0 3
76729: PPUSH
76730: CALL_OW 256
76734: PUSH
76735: LD_INT 250
76737: LESS
76738: PUSH
76739: LD_VAR 0 3
76743: PPUSH
76744: CALL_OW 312
76748: AND
76749: IFFALSE 76760
// ComUnlink ( j ) ;
76751: LD_VAR 0 3
76755: PPUSH
76756: CALL_OW 136
76760: GO 76684
76762: POP
76763: POP
// end ;
76764: GO 76622
76766: POP
76767: POP
// end ;
76768: LD_VAR 0 1
76772: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
76773: LD_INT 0
76775: PPUSH
76776: PPUSH
76777: PPUSH
76778: PPUSH
76779: PPUSH
// if not mc_bases then
76780: LD_EXP 31
76784: NOT
76785: IFFALSE 76789
// exit ;
76787: GO 77234
// for i = 1 to mc_bases do
76789: LD_ADDR_VAR 0 2
76793: PUSH
76794: DOUBLE
76795: LD_INT 1
76797: DEC
76798: ST_TO_ADDR
76799: LD_EXP 31
76803: PUSH
76804: FOR_TO
76805: IFFALSE 77232
// begin if not mc_produce [ i ] then
76807: LD_EXP 52
76811: PUSH
76812: LD_VAR 0 2
76816: ARRAY
76817: NOT
76818: IFFALSE 76822
// continue ;
76820: GO 76804
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
76822: LD_ADDR_VAR 0 5
76826: PUSH
76827: LD_EXP 31
76831: PUSH
76832: LD_VAR 0 2
76836: ARRAY
76837: PPUSH
76838: LD_INT 30
76840: PUSH
76841: LD_INT 3
76843: PUSH
76844: EMPTY
76845: LIST
76846: LIST
76847: PPUSH
76848: CALL_OW 72
76852: ST_TO_ADDR
// if not fac then
76853: LD_VAR 0 5
76857: NOT
76858: IFFALSE 76862
// continue ;
76860: GO 76804
// for j in fac do
76862: LD_ADDR_VAR 0 3
76866: PUSH
76867: LD_VAR 0 5
76871: PUSH
76872: FOR_IN
76873: IFFALSE 77228
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
76875: LD_VAR 0 3
76879: PPUSH
76880: CALL_OW 461
76884: PUSH
76885: LD_INT 2
76887: NONEQUAL
76888: PUSH
76889: LD_VAR 0 3
76893: PPUSH
76894: LD_INT 15
76896: PPUSH
76897: CALL 27443 0 2
76901: PUSH
76902: LD_INT 4
76904: ARRAY
76905: OR
76906: IFFALSE 76910
// continue ;
76908: GO 76872
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
76910: LD_VAR 0 3
76914: PPUSH
76915: LD_EXP 52
76919: PUSH
76920: LD_VAR 0 2
76924: ARRAY
76925: PUSH
76926: LD_INT 1
76928: ARRAY
76929: PUSH
76930: LD_INT 1
76932: ARRAY
76933: PPUSH
76934: LD_EXP 52
76938: PUSH
76939: LD_VAR 0 2
76943: ARRAY
76944: PUSH
76945: LD_INT 1
76947: ARRAY
76948: PUSH
76949: LD_INT 2
76951: ARRAY
76952: PPUSH
76953: LD_EXP 52
76957: PUSH
76958: LD_VAR 0 2
76962: ARRAY
76963: PUSH
76964: LD_INT 1
76966: ARRAY
76967: PUSH
76968: LD_INT 3
76970: ARRAY
76971: PPUSH
76972: LD_EXP 52
76976: PUSH
76977: LD_VAR 0 2
76981: ARRAY
76982: PUSH
76983: LD_INT 1
76985: ARRAY
76986: PUSH
76987: LD_INT 4
76989: ARRAY
76990: PPUSH
76991: CALL_OW 448
76995: PUSH
76996: LD_VAR 0 3
77000: PPUSH
77001: LD_EXP 52
77005: PUSH
77006: LD_VAR 0 2
77010: ARRAY
77011: PUSH
77012: LD_INT 1
77014: ARRAY
77015: PUSH
77016: LD_INT 1
77018: ARRAY
77019: PUSH
77020: LD_EXP 52
77024: PUSH
77025: LD_VAR 0 2
77029: ARRAY
77030: PUSH
77031: LD_INT 1
77033: ARRAY
77034: PUSH
77035: LD_INT 2
77037: ARRAY
77038: PUSH
77039: LD_EXP 52
77043: PUSH
77044: LD_VAR 0 2
77048: ARRAY
77049: PUSH
77050: LD_INT 1
77052: ARRAY
77053: PUSH
77054: LD_INT 3
77056: ARRAY
77057: PUSH
77058: LD_EXP 52
77062: PUSH
77063: LD_VAR 0 2
77067: ARRAY
77068: PUSH
77069: LD_INT 1
77071: ARRAY
77072: PUSH
77073: LD_INT 4
77075: ARRAY
77076: PUSH
77077: EMPTY
77078: LIST
77079: LIST
77080: LIST
77081: LIST
77082: PPUSH
77083: CALL 31219 0 2
77087: AND
77088: IFFALSE 77226
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
77090: LD_VAR 0 3
77094: PPUSH
77095: LD_EXP 52
77099: PUSH
77100: LD_VAR 0 2
77104: ARRAY
77105: PUSH
77106: LD_INT 1
77108: ARRAY
77109: PUSH
77110: LD_INT 1
77112: ARRAY
77113: PPUSH
77114: LD_EXP 52
77118: PUSH
77119: LD_VAR 0 2
77123: ARRAY
77124: PUSH
77125: LD_INT 1
77127: ARRAY
77128: PUSH
77129: LD_INT 2
77131: ARRAY
77132: PPUSH
77133: LD_EXP 52
77137: PUSH
77138: LD_VAR 0 2
77142: ARRAY
77143: PUSH
77144: LD_INT 1
77146: ARRAY
77147: PUSH
77148: LD_INT 3
77150: ARRAY
77151: PPUSH
77152: LD_EXP 52
77156: PUSH
77157: LD_VAR 0 2
77161: ARRAY
77162: PUSH
77163: LD_INT 1
77165: ARRAY
77166: PUSH
77167: LD_INT 4
77169: ARRAY
77170: PPUSH
77171: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
77175: LD_ADDR_VAR 0 4
77179: PUSH
77180: LD_EXP 52
77184: PUSH
77185: LD_VAR 0 2
77189: ARRAY
77190: PPUSH
77191: LD_INT 1
77193: PPUSH
77194: CALL_OW 3
77198: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
77199: LD_ADDR_EXP 52
77203: PUSH
77204: LD_EXP 52
77208: PPUSH
77209: LD_VAR 0 2
77213: PPUSH
77214: LD_VAR 0 4
77218: PPUSH
77219: CALL_OW 1
77223: ST_TO_ADDR
// break ;
77224: GO 77228
// end ; end ;
77226: GO 76872
77228: POP
77229: POP
// end ;
77230: GO 76804
77232: POP
77233: POP
// end ;
77234: LD_VAR 0 1
77238: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
77239: LD_INT 0
77241: PPUSH
77242: PPUSH
77243: PPUSH
// if not mc_bases then
77244: LD_EXP 31
77248: NOT
77249: IFFALSE 77253
// exit ;
77251: GO 77342
// for i = 1 to mc_bases do
77253: LD_ADDR_VAR 0 2
77257: PUSH
77258: DOUBLE
77259: LD_INT 1
77261: DEC
77262: ST_TO_ADDR
77263: LD_EXP 31
77267: PUSH
77268: FOR_TO
77269: IFFALSE 77340
// begin if mc_attack [ i ] then
77271: LD_EXP 51
77275: PUSH
77276: LD_VAR 0 2
77280: ARRAY
77281: IFFALSE 77338
// begin tmp := mc_attack [ i ] [ 1 ] ;
77283: LD_ADDR_VAR 0 3
77287: PUSH
77288: LD_EXP 51
77292: PUSH
77293: LD_VAR 0 2
77297: ARRAY
77298: PUSH
77299: LD_INT 1
77301: ARRAY
77302: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
77303: LD_ADDR_EXP 51
77307: PUSH
77308: LD_EXP 51
77312: PPUSH
77313: LD_VAR 0 2
77317: PPUSH
77318: EMPTY
77319: PPUSH
77320: CALL_OW 1
77324: ST_TO_ADDR
// Attack ( tmp ) ;
77325: LD_VAR 0 3
77329: PPUSH
77330: CALL 112226 0 1
// exit ;
77334: POP
77335: POP
77336: GO 77342
// end ; end ;
77338: GO 77268
77340: POP
77341: POP
// end ;
77342: LD_VAR 0 1
77346: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
77347: LD_INT 0
77349: PPUSH
77350: PPUSH
77351: PPUSH
77352: PPUSH
77353: PPUSH
77354: PPUSH
77355: PPUSH
// if not mc_bases then
77356: LD_EXP 31
77360: NOT
77361: IFFALSE 77365
// exit ;
77363: GO 78222
// for i = 1 to mc_bases do
77365: LD_ADDR_VAR 0 2
77369: PUSH
77370: DOUBLE
77371: LD_INT 1
77373: DEC
77374: ST_TO_ADDR
77375: LD_EXP 31
77379: PUSH
77380: FOR_TO
77381: IFFALSE 78220
// begin if not mc_bases [ i ] then
77383: LD_EXP 31
77387: PUSH
77388: LD_VAR 0 2
77392: ARRAY
77393: NOT
77394: IFFALSE 77398
// continue ;
77396: GO 77380
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
77398: LD_ADDR_VAR 0 7
77402: PUSH
77403: LD_EXP 31
77407: PUSH
77408: LD_VAR 0 2
77412: ARRAY
77413: PUSH
77414: LD_INT 1
77416: ARRAY
77417: PPUSH
77418: CALL 21670 0 1
77422: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
77423: LD_ADDR_EXP 54
77427: PUSH
77428: LD_EXP 54
77432: PPUSH
77433: LD_VAR 0 2
77437: PPUSH
77438: LD_EXP 31
77442: PUSH
77443: LD_VAR 0 2
77447: ARRAY
77448: PUSH
77449: LD_INT 1
77451: ARRAY
77452: PPUSH
77453: CALL_OW 255
77457: PPUSH
77458: LD_EXP 56
77462: PUSH
77463: LD_VAR 0 2
77467: ARRAY
77468: PPUSH
77469: CALL 21635 0 2
77473: PPUSH
77474: CALL_OW 1
77478: ST_TO_ADDR
// if not mc_scan [ i ] then
77479: LD_EXP 54
77483: PUSH
77484: LD_VAR 0 2
77488: ARRAY
77489: NOT
77490: IFFALSE 77668
// begin mc_is_defending := Replace ( mc_is_defending , i , false ) ;
77492: LD_ADDR_EXP 74
77496: PUSH
77497: LD_EXP 74
77501: PPUSH
77502: LD_VAR 0 2
77506: PPUSH
77507: LD_INT 0
77509: PPUSH
77510: CALL_OW 1
77514: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
77515: LD_ADDR_VAR 0 4
77519: PUSH
77520: LD_EXP 31
77524: PUSH
77525: LD_VAR 0 2
77529: ARRAY
77530: PPUSH
77531: LD_INT 2
77533: PUSH
77534: LD_INT 25
77536: PUSH
77537: LD_INT 5
77539: PUSH
77540: EMPTY
77541: LIST
77542: LIST
77543: PUSH
77544: LD_INT 25
77546: PUSH
77547: LD_INT 8
77549: PUSH
77550: EMPTY
77551: LIST
77552: LIST
77553: PUSH
77554: LD_INT 25
77556: PUSH
77557: LD_INT 9
77559: PUSH
77560: EMPTY
77561: LIST
77562: LIST
77563: PUSH
77564: EMPTY
77565: LIST
77566: LIST
77567: LIST
77568: LIST
77569: PPUSH
77570: CALL_OW 72
77574: ST_TO_ADDR
// if not tmp then
77575: LD_VAR 0 4
77579: NOT
77580: IFFALSE 77584
// continue ;
77582: GO 77380
// for j in tmp do
77584: LD_ADDR_VAR 0 3
77588: PUSH
77589: LD_VAR 0 4
77593: PUSH
77594: FOR_IN
77595: IFFALSE 77666
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
77597: LD_VAR 0 3
77601: PPUSH
77602: CALL_OW 310
77606: PPUSH
77607: CALL_OW 266
77611: PUSH
77612: LD_INT 5
77614: EQUAL
77615: PUSH
77616: LD_VAR 0 3
77620: PPUSH
77621: CALL_OW 257
77625: PUSH
77626: LD_INT 1
77628: EQUAL
77629: AND
77630: PUSH
77631: LD_VAR 0 3
77635: PPUSH
77636: CALL_OW 459
77640: NOT
77641: AND
77642: PUSH
77643: LD_VAR 0 7
77647: AND
77648: IFFALSE 77664
// ComChangeProfession ( j , class ) ;
77650: LD_VAR 0 3
77654: PPUSH
77655: LD_VAR 0 7
77659: PPUSH
77660: CALL_OW 123
77664: GO 77594
77666: POP
77667: POP
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and not mc_defender [ i ] and ( UnitFilter ( mc_bases [ i ] , [ [ f_ok ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) < 4 or UnitFilter ( mc_bases [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ) then
77668: LD_EXP 54
77672: PUSH
77673: LD_VAR 0 2
77677: ARRAY
77678: PUSH
77679: LD_EXP 74
77683: PUSH
77684: LD_VAR 0 2
77688: ARRAY
77689: NOT
77690: AND
77691: PUSH
77692: LD_EXP 53
77696: PUSH
77697: LD_VAR 0 2
77701: ARRAY
77702: NOT
77703: AND
77704: PUSH
77705: LD_EXP 31
77709: PUSH
77710: LD_VAR 0 2
77714: ARRAY
77715: PPUSH
77716: LD_INT 50
77718: PUSH
77719: EMPTY
77720: LIST
77721: PUSH
77722: LD_INT 2
77724: PUSH
77725: LD_INT 30
77727: PUSH
77728: LD_INT 32
77730: PUSH
77731: EMPTY
77732: LIST
77733: LIST
77734: PUSH
77735: LD_INT 30
77737: PUSH
77738: LD_INT 33
77740: PUSH
77741: EMPTY
77742: LIST
77743: LIST
77744: PUSH
77745: LD_INT 30
77747: PUSH
77748: LD_INT 4
77750: PUSH
77751: EMPTY
77752: LIST
77753: LIST
77754: PUSH
77755: LD_INT 30
77757: PUSH
77758: LD_INT 5
77760: PUSH
77761: EMPTY
77762: LIST
77763: LIST
77764: PUSH
77765: EMPTY
77766: LIST
77767: LIST
77768: LIST
77769: LIST
77770: LIST
77771: PUSH
77772: EMPTY
77773: LIST
77774: LIST
77775: PPUSH
77776: CALL_OW 72
77780: PUSH
77781: LD_INT 4
77783: LESS
77784: PUSH
77785: LD_EXP 31
77789: PUSH
77790: LD_VAR 0 2
77794: ARRAY
77795: PPUSH
77796: LD_INT 3
77798: PUSH
77799: LD_INT 24
77801: PUSH
77802: LD_INT 1000
77804: PUSH
77805: EMPTY
77806: LIST
77807: LIST
77808: PUSH
77809: EMPTY
77810: LIST
77811: LIST
77812: PUSH
77813: LD_INT 2
77815: PUSH
77816: LD_INT 30
77818: PUSH
77819: LD_INT 0
77821: PUSH
77822: EMPTY
77823: LIST
77824: LIST
77825: PUSH
77826: LD_INT 30
77828: PUSH
77829: LD_INT 1
77831: PUSH
77832: EMPTY
77833: LIST
77834: LIST
77835: PUSH
77836: EMPTY
77837: LIST
77838: LIST
77839: LIST
77840: PUSH
77841: EMPTY
77842: LIST
77843: LIST
77844: PPUSH
77845: CALL_OW 72
77849: OR
77850: AND
77851: IFFALSE 78102
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
77853: LD_ADDR_EXP 74
77857: PUSH
77858: LD_EXP 74
77862: PPUSH
77863: LD_VAR 0 2
77867: PPUSH
77868: LD_INT 1
77870: PPUSH
77871: CALL_OW 1
77875: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
77876: LD_ADDR_VAR 0 4
77880: PUSH
77881: LD_EXP 31
77885: PUSH
77886: LD_VAR 0 2
77890: ARRAY
77891: PPUSH
77892: LD_INT 2
77894: PUSH
77895: LD_INT 25
77897: PUSH
77898: LD_INT 1
77900: PUSH
77901: EMPTY
77902: LIST
77903: LIST
77904: PUSH
77905: LD_INT 25
77907: PUSH
77908: LD_INT 5
77910: PUSH
77911: EMPTY
77912: LIST
77913: LIST
77914: PUSH
77915: LD_INT 25
77917: PUSH
77918: LD_INT 8
77920: PUSH
77921: EMPTY
77922: LIST
77923: LIST
77924: PUSH
77925: LD_INT 25
77927: PUSH
77928: LD_INT 9
77930: PUSH
77931: EMPTY
77932: LIST
77933: LIST
77934: PUSH
77935: EMPTY
77936: LIST
77937: LIST
77938: LIST
77939: LIST
77940: LIST
77941: PPUSH
77942: CALL_OW 72
77946: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
77947: LD_ADDR_VAR 0 4
77951: PUSH
77952: LD_VAR 0 4
77956: PUSH
77957: LD_VAR 0 4
77961: PPUSH
77962: LD_INT 18
77964: PPUSH
77965: CALL 54787 0 2
77969: DIFF
77970: ST_TO_ADDR
// if not tmp and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
77971: LD_VAR 0 4
77975: NOT
77976: PUSH
77977: LD_EXP 31
77981: PUSH
77982: LD_VAR 0 2
77986: ARRAY
77987: PPUSH
77988: LD_INT 2
77990: PUSH
77991: LD_INT 30
77993: PUSH
77994: LD_INT 4
77996: PUSH
77997: EMPTY
77998: LIST
77999: LIST
78000: PUSH
78001: LD_INT 30
78003: PUSH
78004: LD_INT 5
78006: PUSH
78007: EMPTY
78008: LIST
78009: LIST
78010: PUSH
78011: EMPTY
78012: LIST
78013: LIST
78014: LIST
78015: PPUSH
78016: CALL_OW 72
78020: NOT
78021: AND
78022: IFFALSE 78084
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
78024: LD_ADDR_VAR 0 4
78028: PUSH
78029: LD_EXP 31
78033: PUSH
78034: LD_VAR 0 2
78038: ARRAY
78039: PPUSH
78040: LD_INT 2
78042: PUSH
78043: LD_INT 25
78045: PUSH
78046: LD_INT 2
78048: PUSH
78049: EMPTY
78050: LIST
78051: LIST
78052: PUSH
78053: LD_INT 25
78055: PUSH
78056: LD_INT 3
78058: PUSH
78059: EMPTY
78060: LIST
78061: LIST
78062: PUSH
78063: LD_INT 25
78065: PUSH
78066: LD_INT 4
78068: PUSH
78069: EMPTY
78070: LIST
78071: LIST
78072: PUSH
78073: EMPTY
78074: LIST
78075: LIST
78076: LIST
78077: LIST
78078: PPUSH
78079: CALL_OW 72
78083: ST_TO_ADDR
// BasicDefend ( i , tmp ) ;
78084: LD_VAR 0 2
78088: PPUSH
78089: LD_VAR 0 4
78093: PPUSH
78094: CALL 116935 0 2
// exit ;
78098: POP
78099: POP
78100: GO 78222
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and mc_defender [ i ] then
78102: LD_EXP 54
78106: PUSH
78107: LD_VAR 0 2
78111: ARRAY
78112: PUSH
78113: LD_EXP 74
78117: PUSH
78118: LD_VAR 0 2
78122: ARRAY
78123: NOT
78124: AND
78125: PUSH
78126: LD_EXP 53
78130: PUSH
78131: LD_VAR 0 2
78135: ARRAY
78136: AND
78137: IFFALSE 78218
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
78139: LD_ADDR_EXP 74
78143: PUSH
78144: LD_EXP 74
78148: PPUSH
78149: LD_VAR 0 2
78153: PPUSH
78154: LD_INT 1
78156: PPUSH
78157: CALL_OW 1
78161: ST_TO_ADDR
// tmp := mc_defender [ i ] ;
78162: LD_ADDR_VAR 0 4
78166: PUSH
78167: LD_EXP 53
78171: PUSH
78172: LD_VAR 0 2
78176: ARRAY
78177: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
78178: LD_ADDR_EXP 53
78182: PUSH
78183: LD_EXP 53
78187: PPUSH
78188: LD_VAR 0 2
78192: PPUSH
78193: EMPTY
78194: PPUSH
78195: CALL_OW 1
78199: ST_TO_ADDR
// Defend ( i , tmp ) ;
78200: LD_VAR 0 2
78204: PPUSH
78205: LD_VAR 0 4
78209: PPUSH
78210: CALL 117531 0 2
// exit ;
78214: POP
78215: POP
78216: GO 78222
// end ; end ;
78218: GO 77380
78220: POP
78221: POP
// end ;
78222: LD_VAR 0 1
78226: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
78227: LD_INT 0
78229: PPUSH
78230: PPUSH
78231: PPUSH
78232: PPUSH
78233: PPUSH
78234: PPUSH
78235: PPUSH
78236: PPUSH
78237: PPUSH
78238: PPUSH
78239: PPUSH
// if not mc_bases then
78240: LD_EXP 31
78244: NOT
78245: IFFALSE 78249
// exit ;
78247: GO 79336
// for i = 1 to mc_bases do
78249: LD_ADDR_VAR 0 2
78253: PUSH
78254: DOUBLE
78255: LD_INT 1
78257: DEC
78258: ST_TO_ADDR
78259: LD_EXP 31
78263: PUSH
78264: FOR_TO
78265: IFFALSE 79334
// begin tmp := mc_lab [ i ] ;
78267: LD_ADDR_VAR 0 6
78271: PUSH
78272: LD_EXP 64
78276: PUSH
78277: LD_VAR 0 2
78281: ARRAY
78282: ST_TO_ADDR
// if not tmp then
78283: LD_VAR 0 6
78287: NOT
78288: IFFALSE 78292
// continue ;
78290: GO 78264
// idle_lab := 0 ;
78292: LD_ADDR_VAR 0 11
78296: PUSH
78297: LD_INT 0
78299: ST_TO_ADDR
// for j in tmp do
78300: LD_ADDR_VAR 0 3
78304: PUSH
78305: LD_VAR 0 6
78309: PUSH
78310: FOR_IN
78311: IFFALSE 79330
// begin researching := false ;
78313: LD_ADDR_VAR 0 10
78317: PUSH
78318: LD_INT 0
78320: ST_TO_ADDR
// side := GetSide ( j ) ;
78321: LD_ADDR_VAR 0 4
78325: PUSH
78326: LD_VAR 0 3
78330: PPUSH
78331: CALL_OW 255
78335: ST_TO_ADDR
// if not mc_tech [ side ] then
78336: LD_EXP 58
78340: PUSH
78341: LD_VAR 0 4
78345: ARRAY
78346: NOT
78347: IFFALSE 78351
// continue ;
78349: GO 78310
// if BuildingStatus ( j ) = bs_idle then
78351: LD_VAR 0 3
78355: PPUSH
78356: CALL_OW 461
78360: PUSH
78361: LD_INT 2
78363: EQUAL
78364: IFFALSE 78552
// begin if idle_lab and UnitsInside ( j ) < 6 then
78366: LD_VAR 0 11
78370: PUSH
78371: LD_VAR 0 3
78375: PPUSH
78376: CALL_OW 313
78380: PUSH
78381: LD_INT 6
78383: LESS
78384: AND
78385: IFFALSE 78456
// begin tmp2 := UnitsInside ( idle_lab ) ;
78387: LD_ADDR_VAR 0 9
78391: PUSH
78392: LD_VAR 0 11
78396: PPUSH
78397: CALL_OW 313
78401: ST_TO_ADDR
// if tmp2 then
78402: LD_VAR 0 9
78406: IFFALSE 78448
// for x in tmp2 do
78408: LD_ADDR_VAR 0 7
78412: PUSH
78413: LD_VAR 0 9
78417: PUSH
78418: FOR_IN
78419: IFFALSE 78446
// begin ComExitBuilding ( x ) ;
78421: LD_VAR 0 7
78425: PPUSH
78426: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
78430: LD_VAR 0 7
78434: PPUSH
78435: LD_VAR 0 3
78439: PPUSH
78440: CALL_OW 180
// end ;
78444: GO 78418
78446: POP
78447: POP
// idle_lab := 0 ;
78448: LD_ADDR_VAR 0 11
78452: PUSH
78453: LD_INT 0
78455: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
78456: LD_ADDR_VAR 0 5
78460: PUSH
78461: LD_EXP 58
78465: PUSH
78466: LD_VAR 0 4
78470: ARRAY
78471: PUSH
78472: FOR_IN
78473: IFFALSE 78533
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
78475: LD_VAR 0 3
78479: PPUSH
78480: LD_VAR 0 5
78484: PPUSH
78485: CALL_OW 430
78489: PUSH
78490: LD_VAR 0 4
78494: PPUSH
78495: LD_VAR 0 5
78499: PPUSH
78500: CALL 20740 0 2
78504: AND
78505: IFFALSE 78531
// begin researching := true ;
78507: LD_ADDR_VAR 0 10
78511: PUSH
78512: LD_INT 1
78514: ST_TO_ADDR
// ComResearch ( j , t ) ;
78515: LD_VAR 0 3
78519: PPUSH
78520: LD_VAR 0 5
78524: PPUSH
78525: CALL_OW 124
// break ;
78529: GO 78533
// end ;
78531: GO 78472
78533: POP
78534: POP
// if not researching then
78535: LD_VAR 0 10
78539: NOT
78540: IFFALSE 78552
// idle_lab := j ;
78542: LD_ADDR_VAR 0 11
78546: PUSH
78547: LD_VAR 0 3
78551: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
78552: LD_VAR 0 3
78556: PPUSH
78557: CALL_OW 461
78561: PUSH
78562: LD_INT 10
78564: EQUAL
78565: IFFALSE 79153
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
78567: LD_EXP 60
78571: PUSH
78572: LD_VAR 0 2
78576: ARRAY
78577: NOT
78578: PUSH
78579: LD_EXP 61
78583: PUSH
78584: LD_VAR 0 2
78588: ARRAY
78589: NOT
78590: AND
78591: PUSH
78592: LD_EXP 58
78596: PUSH
78597: LD_VAR 0 4
78601: ARRAY
78602: PUSH
78603: LD_INT 1
78605: GREATER
78606: AND
78607: IFFALSE 78738
// begin ComCancel ( j ) ;
78609: LD_VAR 0 3
78613: PPUSH
78614: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
78618: LD_ADDR_EXP 58
78622: PUSH
78623: LD_EXP 58
78627: PPUSH
78628: LD_VAR 0 4
78632: PPUSH
78633: LD_EXP 58
78637: PUSH
78638: LD_VAR 0 4
78642: ARRAY
78643: PPUSH
78644: LD_EXP 58
78648: PUSH
78649: LD_VAR 0 4
78653: ARRAY
78654: PUSH
78655: LD_INT 1
78657: MINUS
78658: PPUSH
78659: LD_EXP 58
78663: PUSH
78664: LD_VAR 0 4
78668: ARRAY
78669: PPUSH
78670: LD_INT 0
78672: PPUSH
78673: CALL 24264 0 4
78677: PPUSH
78678: CALL_OW 1
78682: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
78683: LD_ADDR_EXP 58
78687: PUSH
78688: LD_EXP 58
78692: PPUSH
78693: LD_VAR 0 4
78697: PPUSH
78698: LD_EXP 58
78702: PUSH
78703: LD_VAR 0 4
78707: ARRAY
78708: PPUSH
78709: LD_EXP 58
78713: PUSH
78714: LD_VAR 0 4
78718: ARRAY
78719: PPUSH
78720: LD_INT 1
78722: PPUSH
78723: LD_INT 0
78725: PPUSH
78726: CALL 24264 0 4
78730: PPUSH
78731: CALL_OW 1
78735: ST_TO_ADDR
// continue ;
78736: GO 78310
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
78738: LD_EXP 60
78742: PUSH
78743: LD_VAR 0 2
78747: ARRAY
78748: PUSH
78749: LD_EXP 61
78753: PUSH
78754: LD_VAR 0 2
78758: ARRAY
78759: NOT
78760: AND
78761: IFFALSE 78888
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
78763: LD_ADDR_EXP 61
78767: PUSH
78768: LD_EXP 61
78772: PPUSH
78773: LD_VAR 0 2
78777: PUSH
78778: LD_EXP 61
78782: PUSH
78783: LD_VAR 0 2
78787: ARRAY
78788: PUSH
78789: LD_INT 1
78791: PLUS
78792: PUSH
78793: EMPTY
78794: LIST
78795: LIST
78796: PPUSH
78797: LD_EXP 60
78801: PUSH
78802: LD_VAR 0 2
78806: ARRAY
78807: PUSH
78808: LD_INT 1
78810: ARRAY
78811: PPUSH
78812: CALL 24846 0 3
78816: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
78817: LD_EXP 60
78821: PUSH
78822: LD_VAR 0 2
78826: ARRAY
78827: PUSH
78828: LD_INT 1
78830: ARRAY
78831: PPUSH
78832: LD_INT 112
78834: PPUSH
78835: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
78839: LD_ADDR_VAR 0 9
78843: PUSH
78844: LD_EXP 60
78848: PUSH
78849: LD_VAR 0 2
78853: ARRAY
78854: PPUSH
78855: LD_INT 1
78857: PPUSH
78858: CALL_OW 3
78862: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
78863: LD_ADDR_EXP 60
78867: PUSH
78868: LD_EXP 60
78872: PPUSH
78873: LD_VAR 0 2
78877: PPUSH
78878: LD_VAR 0 9
78882: PPUSH
78883: CALL_OW 1
78887: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
78888: LD_EXP 60
78892: PUSH
78893: LD_VAR 0 2
78897: ARRAY
78898: PUSH
78899: LD_EXP 61
78903: PUSH
78904: LD_VAR 0 2
78908: ARRAY
78909: AND
78910: PUSH
78911: LD_EXP 61
78915: PUSH
78916: LD_VAR 0 2
78920: ARRAY
78921: PUSH
78922: LD_INT 1
78924: ARRAY
78925: PPUSH
78926: CALL_OW 310
78930: NOT
78931: AND
78932: PUSH
78933: LD_VAR 0 3
78937: PPUSH
78938: CALL_OW 313
78942: PUSH
78943: LD_INT 6
78945: EQUAL
78946: AND
78947: IFFALSE 79003
// begin tmp2 := UnitsInside ( j ) ;
78949: LD_ADDR_VAR 0 9
78953: PUSH
78954: LD_VAR 0 3
78958: PPUSH
78959: CALL_OW 313
78963: ST_TO_ADDR
// if tmp2 = 6 then
78964: LD_VAR 0 9
78968: PUSH
78969: LD_INT 6
78971: EQUAL
78972: IFFALSE 79003
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
78974: LD_VAR 0 9
78978: PUSH
78979: LD_INT 1
78981: ARRAY
78982: PPUSH
78983: LD_INT 112
78985: PPUSH
78986: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
78990: LD_VAR 0 9
78994: PUSH
78995: LD_INT 1
78997: ARRAY
78998: PPUSH
78999: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
79003: LD_EXP 61
79007: PUSH
79008: LD_VAR 0 2
79012: ARRAY
79013: PUSH
79014: LD_EXP 61
79018: PUSH
79019: LD_VAR 0 2
79023: ARRAY
79024: PUSH
79025: LD_INT 1
79027: ARRAY
79028: PPUSH
79029: CALL_OW 314
79033: NOT
79034: AND
79035: PUSH
79036: LD_EXP 61
79040: PUSH
79041: LD_VAR 0 2
79045: ARRAY
79046: PUSH
79047: LD_INT 1
79049: ARRAY
79050: PPUSH
79051: CALL_OW 310
79055: NOT
79056: AND
79057: IFFALSE 79083
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
79059: LD_EXP 61
79063: PUSH
79064: LD_VAR 0 2
79068: ARRAY
79069: PUSH
79070: LD_INT 1
79072: ARRAY
79073: PPUSH
79074: LD_VAR 0 3
79078: PPUSH
79079: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
79083: LD_EXP 61
79087: PUSH
79088: LD_VAR 0 2
79092: ARRAY
79093: PUSH
79094: LD_INT 1
79096: ARRAY
79097: PPUSH
79098: CALL_OW 310
79102: PUSH
79103: LD_EXP 61
79107: PUSH
79108: LD_VAR 0 2
79112: ARRAY
79113: PUSH
79114: LD_INT 1
79116: ARRAY
79117: PPUSH
79118: CALL_OW 310
79122: PPUSH
79123: CALL_OW 461
79127: PUSH
79128: LD_INT 3
79130: NONEQUAL
79131: AND
79132: IFFALSE 79153
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
79134: LD_EXP 61
79138: PUSH
79139: LD_VAR 0 2
79143: ARRAY
79144: PUSH
79145: LD_INT 1
79147: ARRAY
79148: PPUSH
79149: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
79153: LD_VAR 0 3
79157: PPUSH
79158: CALL_OW 461
79162: PUSH
79163: LD_INT 6
79165: EQUAL
79166: PUSH
79167: LD_VAR 0 6
79171: PUSH
79172: LD_INT 1
79174: GREATER
79175: AND
79176: IFFALSE 79328
// begin sci := [ ] ;
79178: LD_ADDR_VAR 0 8
79182: PUSH
79183: EMPTY
79184: ST_TO_ADDR
// for x in ( tmp diff j ) do
79185: LD_ADDR_VAR 0 7
79189: PUSH
79190: LD_VAR 0 6
79194: PUSH
79195: LD_VAR 0 3
79199: DIFF
79200: PUSH
79201: FOR_IN
79202: IFFALSE 79254
// begin if sci = 6 then
79204: LD_VAR 0 8
79208: PUSH
79209: LD_INT 6
79211: EQUAL
79212: IFFALSE 79216
// break ;
79214: GO 79254
// if BuildingStatus ( x ) = bs_idle then
79216: LD_VAR 0 7
79220: PPUSH
79221: CALL_OW 461
79225: PUSH
79226: LD_INT 2
79228: EQUAL
79229: IFFALSE 79252
// sci := sci ^ UnitsInside ( x ) ;
79231: LD_ADDR_VAR 0 8
79235: PUSH
79236: LD_VAR 0 8
79240: PUSH
79241: LD_VAR 0 7
79245: PPUSH
79246: CALL_OW 313
79250: ADD
79251: ST_TO_ADDR
// end ;
79252: GO 79201
79254: POP
79255: POP
// if not sci then
79256: LD_VAR 0 8
79260: NOT
79261: IFFALSE 79265
// continue ;
79263: GO 78310
// for x in sci do
79265: LD_ADDR_VAR 0 7
79269: PUSH
79270: LD_VAR 0 8
79274: PUSH
79275: FOR_IN
79276: IFFALSE 79326
// if IsInUnit ( x ) and not HasTask ( x ) then
79278: LD_VAR 0 7
79282: PPUSH
79283: CALL_OW 310
79287: PUSH
79288: LD_VAR 0 7
79292: PPUSH
79293: CALL_OW 314
79297: NOT
79298: AND
79299: IFFALSE 79324
// begin ComExitBuilding ( x ) ;
79301: LD_VAR 0 7
79305: PPUSH
79306: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
79310: LD_VAR 0 7
79314: PPUSH
79315: LD_VAR 0 3
79319: PPUSH
79320: CALL_OW 180
// end ;
79324: GO 79275
79326: POP
79327: POP
// end ; end ;
79328: GO 78310
79330: POP
79331: POP
// end ;
79332: GO 78264
79334: POP
79335: POP
// end ;
79336: LD_VAR 0 1
79340: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
79341: LD_INT 0
79343: PPUSH
79344: PPUSH
// if not mc_bases then
79345: LD_EXP 31
79349: NOT
79350: IFFALSE 79354
// exit ;
79352: GO 79435
// for i = 1 to mc_bases do
79354: LD_ADDR_VAR 0 2
79358: PUSH
79359: DOUBLE
79360: LD_INT 1
79362: DEC
79363: ST_TO_ADDR
79364: LD_EXP 31
79368: PUSH
79369: FOR_TO
79370: IFFALSE 79433
// if mc_mines [ i ] and mc_miners [ i ] then
79372: LD_EXP 44
79376: PUSH
79377: LD_VAR 0 2
79381: ARRAY
79382: PUSH
79383: LD_EXP 45
79387: PUSH
79388: LD_VAR 0 2
79392: ARRAY
79393: AND
79394: IFFALSE 79431
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
79396: LD_EXP 45
79400: PUSH
79401: LD_VAR 0 2
79405: ARRAY
79406: PUSH
79407: LD_INT 1
79409: ARRAY
79410: PPUSH
79411: CALL_OW 255
79415: PPUSH
79416: LD_EXP 44
79420: PUSH
79421: LD_VAR 0 2
79425: ARRAY
79426: PPUSH
79427: CALL 21823 0 2
79431: GO 79369
79433: POP
79434: POP
// end ;
79435: LD_VAR 0 1
79439: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
79440: LD_INT 0
79442: PPUSH
79443: PPUSH
79444: PPUSH
79445: PPUSH
79446: PPUSH
79447: PPUSH
79448: PPUSH
79449: PPUSH
// if not mc_bases or not mc_parking then
79450: LD_EXP 31
79454: NOT
79455: PUSH
79456: LD_EXP 55
79460: NOT
79461: OR
79462: IFFALSE 79466
// exit ;
79464: GO 80204
// for i = 1 to mc_bases do
79466: LD_ADDR_VAR 0 2
79470: PUSH
79471: DOUBLE
79472: LD_INT 1
79474: DEC
79475: ST_TO_ADDR
79476: LD_EXP 31
79480: PUSH
79481: FOR_TO
79482: IFFALSE 80202
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
79484: LD_EXP 31
79488: PUSH
79489: LD_VAR 0 2
79493: ARRAY
79494: NOT
79495: PUSH
79496: LD_EXP 55
79500: PUSH
79501: LD_VAR 0 2
79505: ARRAY
79506: NOT
79507: OR
79508: IFFALSE 79512
// continue ;
79510: GO 79481
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
79512: LD_ADDR_VAR 0 5
79516: PUSH
79517: LD_EXP 31
79521: PUSH
79522: LD_VAR 0 2
79526: ARRAY
79527: PUSH
79528: LD_INT 1
79530: ARRAY
79531: PPUSH
79532: CALL_OW 255
79536: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
79537: LD_ADDR_VAR 0 6
79541: PUSH
79542: LD_EXP 31
79546: PUSH
79547: LD_VAR 0 2
79551: ARRAY
79552: PPUSH
79553: LD_INT 30
79555: PUSH
79556: LD_INT 3
79558: PUSH
79559: EMPTY
79560: LIST
79561: LIST
79562: PPUSH
79563: CALL_OW 72
79567: ST_TO_ADDR
// if not fac then
79568: LD_VAR 0 6
79572: NOT
79573: IFFALSE 79624
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
79575: LD_ADDR_VAR 0 6
79579: PUSH
79580: LD_EXP 31
79584: PUSH
79585: LD_VAR 0 2
79589: ARRAY
79590: PPUSH
79591: LD_INT 2
79593: PUSH
79594: LD_INT 30
79596: PUSH
79597: LD_INT 0
79599: PUSH
79600: EMPTY
79601: LIST
79602: LIST
79603: PUSH
79604: LD_INT 30
79606: PUSH
79607: LD_INT 1
79609: PUSH
79610: EMPTY
79611: LIST
79612: LIST
79613: PUSH
79614: EMPTY
79615: LIST
79616: LIST
79617: LIST
79618: PPUSH
79619: CALL_OW 72
79623: ST_TO_ADDR
// if not fac then
79624: LD_VAR 0 6
79628: NOT
79629: IFFALSE 79633
// continue ;
79631: GO 79481
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
79633: LD_ADDR_VAR 0 7
79637: PUSH
79638: LD_EXP 55
79642: PUSH
79643: LD_VAR 0 2
79647: ARRAY
79648: PPUSH
79649: LD_INT 22
79651: PUSH
79652: LD_VAR 0 5
79656: PUSH
79657: EMPTY
79658: LIST
79659: LIST
79660: PUSH
79661: LD_INT 21
79663: PUSH
79664: LD_INT 2
79666: PUSH
79667: EMPTY
79668: LIST
79669: LIST
79670: PUSH
79671: LD_INT 3
79673: PUSH
79674: LD_INT 60
79676: PUSH
79677: EMPTY
79678: LIST
79679: PUSH
79680: EMPTY
79681: LIST
79682: LIST
79683: PUSH
79684: LD_INT 3
79686: PUSH
79687: LD_INT 24
79689: PUSH
79690: LD_INT 1000
79692: PUSH
79693: EMPTY
79694: LIST
79695: LIST
79696: PUSH
79697: EMPTY
79698: LIST
79699: LIST
79700: PUSH
79701: EMPTY
79702: LIST
79703: LIST
79704: LIST
79705: LIST
79706: PPUSH
79707: CALL_OW 70
79711: ST_TO_ADDR
// for j in fac do
79712: LD_ADDR_VAR 0 3
79716: PUSH
79717: LD_VAR 0 6
79721: PUSH
79722: FOR_IN
79723: IFFALSE 79818
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
79725: LD_ADDR_VAR 0 7
79729: PUSH
79730: LD_VAR 0 7
79734: PUSH
79735: LD_INT 22
79737: PUSH
79738: LD_VAR 0 5
79742: PUSH
79743: EMPTY
79744: LIST
79745: LIST
79746: PUSH
79747: LD_INT 91
79749: PUSH
79750: LD_VAR 0 3
79754: PUSH
79755: LD_INT 15
79757: PUSH
79758: EMPTY
79759: LIST
79760: LIST
79761: LIST
79762: PUSH
79763: LD_INT 21
79765: PUSH
79766: LD_INT 2
79768: PUSH
79769: EMPTY
79770: LIST
79771: LIST
79772: PUSH
79773: LD_INT 3
79775: PUSH
79776: LD_INT 60
79778: PUSH
79779: EMPTY
79780: LIST
79781: PUSH
79782: EMPTY
79783: LIST
79784: LIST
79785: PUSH
79786: LD_INT 3
79788: PUSH
79789: LD_INT 24
79791: PUSH
79792: LD_INT 1000
79794: PUSH
79795: EMPTY
79796: LIST
79797: LIST
79798: PUSH
79799: EMPTY
79800: LIST
79801: LIST
79802: PUSH
79803: EMPTY
79804: LIST
79805: LIST
79806: LIST
79807: LIST
79808: LIST
79809: PPUSH
79810: CALL_OW 69
79814: UNION
79815: ST_TO_ADDR
79816: GO 79722
79818: POP
79819: POP
// if not vehs then
79820: LD_VAR 0 7
79824: NOT
79825: IFFALSE 79851
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
79827: LD_ADDR_EXP 43
79831: PUSH
79832: LD_EXP 43
79836: PPUSH
79837: LD_VAR 0 2
79841: PPUSH
79842: EMPTY
79843: PPUSH
79844: CALL_OW 1
79848: ST_TO_ADDR
// continue ;
79849: GO 79481
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
79851: LD_ADDR_VAR 0 8
79855: PUSH
79856: LD_EXP 31
79860: PUSH
79861: LD_VAR 0 2
79865: ARRAY
79866: PPUSH
79867: LD_INT 30
79869: PUSH
79870: LD_INT 3
79872: PUSH
79873: EMPTY
79874: LIST
79875: LIST
79876: PPUSH
79877: CALL_OW 72
79881: ST_TO_ADDR
// if tmp then
79882: LD_VAR 0 8
79886: IFFALSE 79989
// begin for j in tmp do
79888: LD_ADDR_VAR 0 3
79892: PUSH
79893: LD_VAR 0 8
79897: PUSH
79898: FOR_IN
79899: IFFALSE 79987
// for k in UnitsInside ( j ) do
79901: LD_ADDR_VAR 0 4
79905: PUSH
79906: LD_VAR 0 3
79910: PPUSH
79911: CALL_OW 313
79915: PUSH
79916: FOR_IN
79917: IFFALSE 79983
// if k then
79919: LD_VAR 0 4
79923: IFFALSE 79981
// if not k in mc_repair_vehicle [ i ] then
79925: LD_VAR 0 4
79929: PUSH
79930: LD_EXP 43
79934: PUSH
79935: LD_VAR 0 2
79939: ARRAY
79940: IN
79941: NOT
79942: IFFALSE 79981
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
79944: LD_ADDR_EXP 43
79948: PUSH
79949: LD_EXP 43
79953: PPUSH
79954: LD_VAR 0 2
79958: PPUSH
79959: LD_EXP 43
79963: PUSH
79964: LD_VAR 0 2
79968: ARRAY
79969: PUSH
79970: LD_VAR 0 4
79974: UNION
79975: PPUSH
79976: CALL_OW 1
79980: ST_TO_ADDR
79981: GO 79916
79983: POP
79984: POP
79985: GO 79898
79987: POP
79988: POP
// end ; if not mc_repair_vehicle [ i ] then
79989: LD_EXP 43
79993: PUSH
79994: LD_VAR 0 2
79998: ARRAY
79999: NOT
80000: IFFALSE 80004
// continue ;
80002: GO 79481
// for j in mc_repair_vehicle [ i ] do
80004: LD_ADDR_VAR 0 3
80008: PUSH
80009: LD_EXP 43
80013: PUSH
80014: LD_VAR 0 2
80018: ARRAY
80019: PUSH
80020: FOR_IN
80021: IFFALSE 80198
// begin if GetClass ( j ) <> 3 then
80023: LD_VAR 0 3
80027: PPUSH
80028: CALL_OW 257
80032: PUSH
80033: LD_INT 3
80035: NONEQUAL
80036: IFFALSE 80077
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
80038: LD_ADDR_EXP 43
80042: PUSH
80043: LD_EXP 43
80047: PPUSH
80048: LD_VAR 0 2
80052: PPUSH
80053: LD_EXP 43
80057: PUSH
80058: LD_VAR 0 2
80062: ARRAY
80063: PUSH
80064: LD_VAR 0 3
80068: DIFF
80069: PPUSH
80070: CALL_OW 1
80074: ST_TO_ADDR
// continue ;
80075: GO 80020
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
80077: LD_VAR 0 3
80081: PPUSH
80082: CALL_OW 311
80086: NOT
80087: PUSH
80088: LD_VAR 0 3
80092: PUSH
80093: LD_EXP 34
80097: PUSH
80098: LD_VAR 0 2
80102: ARRAY
80103: PUSH
80104: LD_INT 1
80106: ARRAY
80107: IN
80108: NOT
80109: AND
80110: PUSH
80111: LD_VAR 0 3
80115: PUSH
80116: LD_EXP 34
80120: PUSH
80121: LD_VAR 0 2
80125: ARRAY
80126: PUSH
80127: LD_INT 2
80129: ARRAY
80130: IN
80131: NOT
80132: AND
80133: IFFALSE 80196
// begin if IsInUnit ( j ) then
80135: LD_VAR 0 3
80139: PPUSH
80140: CALL_OW 310
80144: IFFALSE 80157
// ComExitBuilding ( j ) else
80146: LD_VAR 0 3
80150: PPUSH
80151: CALL_OW 122
80155: GO 80196
// if not WantToRepairVehicle ( j , vehs [ 1 ] ) then
80157: LD_VAR 0 3
80161: PPUSH
80162: LD_VAR 0 7
80166: PUSH
80167: LD_INT 1
80169: ARRAY
80170: PPUSH
80171: CALL 59270 0 2
80175: NOT
80176: IFFALSE 80196
// ComRepairVehicle ( j , vehs [ 1 ] ) ;
80178: LD_VAR 0 3
80182: PPUSH
80183: LD_VAR 0 7
80187: PUSH
80188: LD_INT 1
80190: ARRAY
80191: PPUSH
80192: CALL_OW 129
// end ; end ;
80196: GO 80020
80198: POP
80199: POP
// end ;
80200: GO 79481
80202: POP
80203: POP
// end ;
80204: LD_VAR 0 1
80208: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
80209: LD_INT 0
80211: PPUSH
80212: PPUSH
80213: PPUSH
80214: PPUSH
80215: PPUSH
80216: PPUSH
80217: PPUSH
80218: PPUSH
80219: PPUSH
80220: PPUSH
80221: PPUSH
// if not mc_bases then
80222: LD_EXP 31
80226: NOT
80227: IFFALSE 80231
// exit ;
80229: GO 81033
// for i = 1 to mc_bases do
80231: LD_ADDR_VAR 0 2
80235: PUSH
80236: DOUBLE
80237: LD_INT 1
80239: DEC
80240: ST_TO_ADDR
80241: LD_EXP 31
80245: PUSH
80246: FOR_TO
80247: IFFALSE 81031
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
80249: LD_EXP 59
80253: PUSH
80254: LD_VAR 0 2
80258: ARRAY
80259: NOT
80260: PUSH
80261: LD_EXP 34
80265: PUSH
80266: LD_VAR 0 2
80270: ARRAY
80271: PUSH
80272: LD_INT 1
80274: ARRAY
80275: OR
80276: PUSH
80277: LD_EXP 34
80281: PUSH
80282: LD_VAR 0 2
80286: ARRAY
80287: PUSH
80288: LD_INT 2
80290: ARRAY
80291: OR
80292: PUSH
80293: LD_EXP 57
80297: PUSH
80298: LD_VAR 0 2
80302: ARRAY
80303: PPUSH
80304: LD_INT 1
80306: PPUSH
80307: CALL_OW 325
80311: NOT
80312: OR
80313: PUSH
80314: LD_EXP 54
80318: PUSH
80319: LD_VAR 0 2
80323: ARRAY
80324: OR
80325: IFFALSE 80329
// continue ;
80327: GO 80246
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
80329: LD_ADDR_VAR 0 8
80333: PUSH
80334: LD_EXP 31
80338: PUSH
80339: LD_VAR 0 2
80343: ARRAY
80344: PPUSH
80345: LD_INT 25
80347: PUSH
80348: LD_INT 4
80350: PUSH
80351: EMPTY
80352: LIST
80353: LIST
80354: PUSH
80355: LD_INT 50
80357: PUSH
80358: EMPTY
80359: LIST
80360: PUSH
80361: LD_INT 3
80363: PUSH
80364: LD_INT 60
80366: PUSH
80367: EMPTY
80368: LIST
80369: PUSH
80370: EMPTY
80371: LIST
80372: LIST
80373: PUSH
80374: EMPTY
80375: LIST
80376: LIST
80377: LIST
80378: PPUSH
80379: CALL_OW 72
80383: PUSH
80384: LD_EXP 35
80388: PUSH
80389: LD_VAR 0 2
80393: ARRAY
80394: DIFF
80395: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
80396: LD_ADDR_VAR 0 9
80400: PUSH
80401: LD_EXP 31
80405: PUSH
80406: LD_VAR 0 2
80410: ARRAY
80411: PPUSH
80412: LD_INT 2
80414: PUSH
80415: LD_INT 30
80417: PUSH
80418: LD_INT 0
80420: PUSH
80421: EMPTY
80422: LIST
80423: LIST
80424: PUSH
80425: LD_INT 30
80427: PUSH
80428: LD_INT 1
80430: PUSH
80431: EMPTY
80432: LIST
80433: LIST
80434: PUSH
80435: EMPTY
80436: LIST
80437: LIST
80438: LIST
80439: PPUSH
80440: CALL_OW 72
80444: ST_TO_ADDR
// if not tmp or not dep then
80445: LD_VAR 0 8
80449: NOT
80450: PUSH
80451: LD_VAR 0 9
80455: NOT
80456: OR
80457: IFFALSE 80461
// continue ;
80459: GO 80246
// side := GetSide ( tmp [ 1 ] ) ;
80461: LD_ADDR_VAR 0 11
80465: PUSH
80466: LD_VAR 0 8
80470: PUSH
80471: LD_INT 1
80473: ARRAY
80474: PPUSH
80475: CALL_OW 255
80479: ST_TO_ADDR
// dep := dep [ 1 ] ;
80480: LD_ADDR_VAR 0 9
80484: PUSH
80485: LD_VAR 0 9
80489: PUSH
80490: LD_INT 1
80492: ARRAY
80493: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
80494: LD_ADDR_VAR 0 7
80498: PUSH
80499: LD_EXP 59
80503: PUSH
80504: LD_VAR 0 2
80508: ARRAY
80509: PPUSH
80510: LD_INT 22
80512: PUSH
80513: LD_INT 0
80515: PUSH
80516: EMPTY
80517: LIST
80518: LIST
80519: PUSH
80520: LD_INT 25
80522: PUSH
80523: LD_INT 12
80525: PUSH
80526: EMPTY
80527: LIST
80528: LIST
80529: PUSH
80530: EMPTY
80531: LIST
80532: LIST
80533: PPUSH
80534: CALL_OW 70
80538: PUSH
80539: LD_INT 22
80541: PUSH
80542: LD_INT 0
80544: PUSH
80545: EMPTY
80546: LIST
80547: LIST
80548: PUSH
80549: LD_INT 25
80551: PUSH
80552: LD_INT 12
80554: PUSH
80555: EMPTY
80556: LIST
80557: LIST
80558: PUSH
80559: LD_INT 91
80561: PUSH
80562: LD_VAR 0 9
80566: PUSH
80567: LD_INT 20
80569: PUSH
80570: EMPTY
80571: LIST
80572: LIST
80573: LIST
80574: PUSH
80575: EMPTY
80576: LIST
80577: LIST
80578: LIST
80579: PPUSH
80580: CALL_OW 69
80584: UNION
80585: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
80586: LD_ADDR_VAR 0 10
80590: PUSH
80591: LD_EXP 59
80595: PUSH
80596: LD_VAR 0 2
80600: ARRAY
80601: PPUSH
80602: LD_INT 81
80604: PUSH
80605: LD_VAR 0 11
80609: PUSH
80610: EMPTY
80611: LIST
80612: LIST
80613: PPUSH
80614: CALL_OW 70
80618: ST_TO_ADDR
// if not apes or danger_at_area then
80619: LD_VAR 0 7
80623: NOT
80624: PUSH
80625: LD_VAR 0 10
80629: OR
80630: IFFALSE 80680
// begin if mc_taming [ i ] then
80632: LD_EXP 62
80636: PUSH
80637: LD_VAR 0 2
80641: ARRAY
80642: IFFALSE 80678
// begin MC_Reset ( i , 121 ) ;
80644: LD_VAR 0 2
80648: PPUSH
80649: LD_INT 121
80651: PPUSH
80652: CALL 65596 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
80656: LD_ADDR_EXP 62
80660: PUSH
80661: LD_EXP 62
80665: PPUSH
80666: LD_VAR 0 2
80670: PPUSH
80671: EMPTY
80672: PPUSH
80673: CALL_OW 1
80677: ST_TO_ADDR
// end ; continue ;
80678: GO 80246
// end ; for j in tmp do
80680: LD_ADDR_VAR 0 3
80684: PUSH
80685: LD_VAR 0 8
80689: PUSH
80690: FOR_IN
80691: IFFALSE 81027
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
80693: LD_VAR 0 3
80697: PUSH
80698: LD_EXP 62
80702: PUSH
80703: LD_VAR 0 2
80707: ARRAY
80708: IN
80709: NOT
80710: PUSH
80711: LD_EXP 62
80715: PUSH
80716: LD_VAR 0 2
80720: ARRAY
80721: PUSH
80722: LD_INT 3
80724: LESS
80725: AND
80726: IFFALSE 80784
// begin SetTag ( j , 121 ) ;
80728: LD_VAR 0 3
80732: PPUSH
80733: LD_INT 121
80735: PPUSH
80736: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
80740: LD_ADDR_EXP 62
80744: PUSH
80745: LD_EXP 62
80749: PPUSH
80750: LD_VAR 0 2
80754: PUSH
80755: LD_EXP 62
80759: PUSH
80760: LD_VAR 0 2
80764: ARRAY
80765: PUSH
80766: LD_INT 1
80768: PLUS
80769: PUSH
80770: EMPTY
80771: LIST
80772: LIST
80773: PPUSH
80774: LD_VAR 0 3
80778: PPUSH
80779: CALL 24846 0 3
80783: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
80784: LD_VAR 0 3
80788: PUSH
80789: LD_EXP 62
80793: PUSH
80794: LD_VAR 0 2
80798: ARRAY
80799: IN
80800: IFFALSE 81025
// begin if GetClass ( j ) <> 4 then
80802: LD_VAR 0 3
80806: PPUSH
80807: CALL_OW 257
80811: PUSH
80812: LD_INT 4
80814: NONEQUAL
80815: IFFALSE 80868
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
80817: LD_ADDR_EXP 62
80821: PUSH
80822: LD_EXP 62
80826: PPUSH
80827: LD_VAR 0 2
80831: PPUSH
80832: LD_EXP 62
80836: PUSH
80837: LD_VAR 0 2
80841: ARRAY
80842: PUSH
80843: LD_VAR 0 3
80847: DIFF
80848: PPUSH
80849: CALL_OW 1
80853: ST_TO_ADDR
// SetTag ( j , 0 ) ;
80854: LD_VAR 0 3
80858: PPUSH
80859: LD_INT 0
80861: PPUSH
80862: CALL_OW 109
// continue ;
80866: GO 80690
// end ; if IsInUnit ( j ) then
80868: LD_VAR 0 3
80872: PPUSH
80873: CALL_OW 310
80877: IFFALSE 80888
// ComExitBuilding ( j ) ;
80879: LD_VAR 0 3
80883: PPUSH
80884: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
80888: LD_ADDR_VAR 0 6
80892: PUSH
80893: LD_VAR 0 7
80897: PPUSH
80898: LD_VAR 0 3
80902: PPUSH
80903: CALL_OW 74
80907: ST_TO_ADDR
// if not ape then
80908: LD_VAR 0 6
80912: NOT
80913: IFFALSE 80917
// break ;
80915: GO 81027
// x := GetX ( ape ) ;
80917: LD_ADDR_VAR 0 4
80921: PUSH
80922: LD_VAR 0 6
80926: PPUSH
80927: CALL_OW 250
80931: ST_TO_ADDR
// y := GetY ( ape ) ;
80932: LD_ADDR_VAR 0 5
80936: PUSH
80937: LD_VAR 0 6
80941: PPUSH
80942: CALL_OW 251
80946: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
80947: LD_VAR 0 4
80951: PPUSH
80952: LD_VAR 0 5
80956: PPUSH
80957: CALL_OW 488
80961: NOT
80962: PUSH
80963: LD_VAR 0 11
80967: PPUSH
80968: LD_VAR 0 4
80972: PPUSH
80973: LD_VAR 0 5
80977: PPUSH
80978: LD_INT 20
80980: PPUSH
80981: CALL 25742 0 4
80985: PUSH
80986: LD_INT 4
80988: ARRAY
80989: OR
80990: IFFALSE 80994
// break ;
80992: GO 81027
// if not HasTask ( j ) then
80994: LD_VAR 0 3
80998: PPUSH
80999: CALL_OW 314
81003: NOT
81004: IFFALSE 81025
// ComTameXY ( j , x , y ) ;
81006: LD_VAR 0 3
81010: PPUSH
81011: LD_VAR 0 4
81015: PPUSH
81016: LD_VAR 0 5
81020: PPUSH
81021: CALL_OW 131
// end ; end ;
81025: GO 80690
81027: POP
81028: POP
// end ;
81029: GO 80246
81031: POP
81032: POP
// end ;
81033: LD_VAR 0 1
81037: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
81038: LD_INT 0
81040: PPUSH
81041: PPUSH
81042: PPUSH
81043: PPUSH
81044: PPUSH
81045: PPUSH
81046: PPUSH
81047: PPUSH
// if not mc_bases then
81048: LD_EXP 31
81052: NOT
81053: IFFALSE 81057
// exit ;
81055: GO 81683
// for i = 1 to mc_bases do
81057: LD_ADDR_VAR 0 2
81061: PUSH
81062: DOUBLE
81063: LD_INT 1
81065: DEC
81066: ST_TO_ADDR
81067: LD_EXP 31
81071: PUSH
81072: FOR_TO
81073: IFFALSE 81681
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
81075: LD_EXP 60
81079: PUSH
81080: LD_VAR 0 2
81084: ARRAY
81085: NOT
81086: PUSH
81087: LD_EXP 60
81091: PUSH
81092: LD_VAR 0 2
81096: ARRAY
81097: PPUSH
81098: LD_INT 25
81100: PUSH
81101: LD_INT 12
81103: PUSH
81104: EMPTY
81105: LIST
81106: LIST
81107: PPUSH
81108: CALL_OW 72
81112: NOT
81113: OR
81114: IFFALSE 81118
// continue ;
81116: GO 81072
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
81118: LD_ADDR_VAR 0 5
81122: PUSH
81123: LD_EXP 60
81127: PUSH
81128: LD_VAR 0 2
81132: ARRAY
81133: PUSH
81134: LD_INT 1
81136: ARRAY
81137: PPUSH
81138: CALL_OW 255
81142: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
81143: LD_VAR 0 5
81147: PPUSH
81148: LD_INT 2
81150: PPUSH
81151: CALL_OW 325
81155: IFFALSE 81408
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
81157: LD_ADDR_VAR 0 4
81161: PUSH
81162: LD_EXP 60
81166: PUSH
81167: LD_VAR 0 2
81171: ARRAY
81172: PPUSH
81173: LD_INT 25
81175: PUSH
81176: LD_INT 16
81178: PUSH
81179: EMPTY
81180: LIST
81181: LIST
81182: PPUSH
81183: CALL_OW 72
81187: ST_TO_ADDR
// if tmp < 6 then
81188: LD_VAR 0 4
81192: PUSH
81193: LD_INT 6
81195: LESS
81196: IFFALSE 81408
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
81198: LD_ADDR_VAR 0 6
81202: PUSH
81203: LD_EXP 31
81207: PUSH
81208: LD_VAR 0 2
81212: ARRAY
81213: PPUSH
81214: LD_INT 2
81216: PUSH
81217: LD_INT 30
81219: PUSH
81220: LD_INT 0
81222: PUSH
81223: EMPTY
81224: LIST
81225: LIST
81226: PUSH
81227: LD_INT 30
81229: PUSH
81230: LD_INT 1
81232: PUSH
81233: EMPTY
81234: LIST
81235: LIST
81236: PUSH
81237: EMPTY
81238: LIST
81239: LIST
81240: LIST
81241: PPUSH
81242: CALL_OW 72
81246: ST_TO_ADDR
// if depot then
81247: LD_VAR 0 6
81251: IFFALSE 81408
// begin selected := 0 ;
81253: LD_ADDR_VAR 0 7
81257: PUSH
81258: LD_INT 0
81260: ST_TO_ADDR
// for j in depot do
81261: LD_ADDR_VAR 0 3
81265: PUSH
81266: LD_VAR 0 6
81270: PUSH
81271: FOR_IN
81272: IFFALSE 81303
// begin if UnitsInside ( j ) < 6 then
81274: LD_VAR 0 3
81278: PPUSH
81279: CALL_OW 313
81283: PUSH
81284: LD_INT 6
81286: LESS
81287: IFFALSE 81301
// begin selected := j ;
81289: LD_ADDR_VAR 0 7
81293: PUSH
81294: LD_VAR 0 3
81298: ST_TO_ADDR
// break ;
81299: GO 81303
// end ; end ;
81301: GO 81271
81303: POP
81304: POP
// if selected then
81305: LD_VAR 0 7
81309: IFFALSE 81408
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
81311: LD_ADDR_VAR 0 3
81315: PUSH
81316: LD_EXP 60
81320: PUSH
81321: LD_VAR 0 2
81325: ARRAY
81326: PPUSH
81327: LD_INT 25
81329: PUSH
81330: LD_INT 12
81332: PUSH
81333: EMPTY
81334: LIST
81335: LIST
81336: PPUSH
81337: CALL_OW 72
81341: PUSH
81342: FOR_IN
81343: IFFALSE 81406
// if not HasTask ( j ) then
81345: LD_VAR 0 3
81349: PPUSH
81350: CALL_OW 314
81354: NOT
81355: IFFALSE 81404
// begin if not IsInUnit ( j ) then
81357: LD_VAR 0 3
81361: PPUSH
81362: CALL_OW 310
81366: NOT
81367: IFFALSE 81383
// ComEnterUnit ( j , selected ) ;
81369: LD_VAR 0 3
81373: PPUSH
81374: LD_VAR 0 7
81378: PPUSH
81379: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
81383: LD_VAR 0 3
81387: PPUSH
81388: LD_INT 16
81390: PPUSH
81391: CALL_OW 183
// AddComExitBuilding ( j ) ;
81395: LD_VAR 0 3
81399: PPUSH
81400: CALL_OW 182
// end ;
81404: GO 81342
81406: POP
81407: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
81408: LD_VAR 0 5
81412: PPUSH
81413: LD_INT 11
81415: PPUSH
81416: CALL_OW 325
81420: IFFALSE 81679
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
81422: LD_ADDR_VAR 0 4
81426: PUSH
81427: LD_EXP 60
81431: PUSH
81432: LD_VAR 0 2
81436: ARRAY
81437: PPUSH
81438: LD_INT 25
81440: PUSH
81441: LD_INT 16
81443: PUSH
81444: EMPTY
81445: LIST
81446: LIST
81447: PPUSH
81448: CALL_OW 72
81452: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
81453: LD_VAR 0 4
81457: PUSH
81458: LD_INT 6
81460: GREATEREQUAL
81461: PUSH
81462: LD_VAR 0 5
81466: PPUSH
81467: LD_INT 2
81469: PPUSH
81470: CALL_OW 325
81474: NOT
81475: OR
81476: IFFALSE 81679
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
81478: LD_ADDR_VAR 0 8
81482: PUSH
81483: LD_EXP 31
81487: PUSH
81488: LD_VAR 0 2
81492: ARRAY
81493: PPUSH
81494: LD_INT 2
81496: PUSH
81497: LD_INT 30
81499: PUSH
81500: LD_INT 4
81502: PUSH
81503: EMPTY
81504: LIST
81505: LIST
81506: PUSH
81507: LD_INT 30
81509: PUSH
81510: LD_INT 5
81512: PUSH
81513: EMPTY
81514: LIST
81515: LIST
81516: PUSH
81517: EMPTY
81518: LIST
81519: LIST
81520: LIST
81521: PPUSH
81522: CALL_OW 72
81526: ST_TO_ADDR
// if barracks then
81527: LD_VAR 0 8
81531: IFFALSE 81679
// begin selected := 0 ;
81533: LD_ADDR_VAR 0 7
81537: PUSH
81538: LD_INT 0
81540: ST_TO_ADDR
// for j in barracks do
81541: LD_ADDR_VAR 0 3
81545: PUSH
81546: LD_VAR 0 8
81550: PUSH
81551: FOR_IN
81552: IFFALSE 81583
// begin if UnitsInside ( j ) < 6 then
81554: LD_VAR 0 3
81558: PPUSH
81559: CALL_OW 313
81563: PUSH
81564: LD_INT 6
81566: LESS
81567: IFFALSE 81581
// begin selected := j ;
81569: LD_ADDR_VAR 0 7
81573: PUSH
81574: LD_VAR 0 3
81578: ST_TO_ADDR
// break ;
81579: GO 81583
// end ; end ;
81581: GO 81551
81583: POP
81584: POP
// if selected then
81585: LD_VAR 0 7
81589: IFFALSE 81679
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
81591: LD_ADDR_VAR 0 3
81595: PUSH
81596: LD_EXP 60
81600: PUSH
81601: LD_VAR 0 2
81605: ARRAY
81606: PPUSH
81607: LD_INT 25
81609: PUSH
81610: LD_INT 12
81612: PUSH
81613: EMPTY
81614: LIST
81615: LIST
81616: PPUSH
81617: CALL_OW 72
81621: PUSH
81622: FOR_IN
81623: IFFALSE 81677
// if not IsInUnit ( j ) and not HasTask ( j ) then
81625: LD_VAR 0 3
81629: PPUSH
81630: CALL_OW 310
81634: NOT
81635: PUSH
81636: LD_VAR 0 3
81640: PPUSH
81641: CALL_OW 314
81645: NOT
81646: AND
81647: IFFALSE 81675
// begin ComEnterUnit ( j , selected ) ;
81649: LD_VAR 0 3
81653: PPUSH
81654: LD_VAR 0 7
81658: PPUSH
81659: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
81663: LD_VAR 0 3
81667: PPUSH
81668: LD_INT 15
81670: PPUSH
81671: CALL_OW 183
// end ;
81675: GO 81622
81677: POP
81678: POP
// end ; end ; end ; end ; end ;
81679: GO 81072
81681: POP
81682: POP
// end ;
81683: LD_VAR 0 1
81687: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
81688: LD_INT 0
81690: PPUSH
81691: PPUSH
81692: PPUSH
81693: PPUSH
// if not mc_bases then
81694: LD_EXP 31
81698: NOT
81699: IFFALSE 81703
// exit ;
81701: GO 81881
// for i = 1 to mc_bases do
81703: LD_ADDR_VAR 0 2
81707: PUSH
81708: DOUBLE
81709: LD_INT 1
81711: DEC
81712: ST_TO_ADDR
81713: LD_EXP 31
81717: PUSH
81718: FOR_TO
81719: IFFALSE 81879
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
81721: LD_ADDR_VAR 0 4
81725: PUSH
81726: LD_EXP 31
81730: PUSH
81731: LD_VAR 0 2
81735: ARRAY
81736: PPUSH
81737: LD_INT 25
81739: PUSH
81740: LD_INT 9
81742: PUSH
81743: EMPTY
81744: LIST
81745: LIST
81746: PPUSH
81747: CALL_OW 72
81751: ST_TO_ADDR
// if not tmp then
81752: LD_VAR 0 4
81756: NOT
81757: IFFALSE 81761
// continue ;
81759: GO 81718
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
81761: LD_EXP 57
81765: PUSH
81766: LD_VAR 0 2
81770: ARRAY
81771: PPUSH
81772: LD_INT 29
81774: PPUSH
81775: CALL_OW 325
81779: NOT
81780: PUSH
81781: LD_EXP 57
81785: PUSH
81786: LD_VAR 0 2
81790: ARRAY
81791: PPUSH
81792: LD_INT 28
81794: PPUSH
81795: CALL_OW 325
81799: NOT
81800: AND
81801: IFFALSE 81805
// continue ;
81803: GO 81718
// for j in tmp do
81805: LD_ADDR_VAR 0 3
81809: PUSH
81810: LD_VAR 0 4
81814: PUSH
81815: FOR_IN
81816: IFFALSE 81875
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
81818: LD_VAR 0 3
81822: PUSH
81823: LD_EXP 34
81827: PUSH
81828: LD_VAR 0 2
81832: ARRAY
81833: PUSH
81834: LD_INT 1
81836: ARRAY
81837: IN
81838: NOT
81839: PUSH
81840: LD_VAR 0 3
81844: PUSH
81845: LD_EXP 34
81849: PUSH
81850: LD_VAR 0 2
81854: ARRAY
81855: PUSH
81856: LD_INT 2
81858: ARRAY
81859: IN
81860: NOT
81861: AND
81862: IFFALSE 81873
// ComSpaceTimeShoot ( j ) ;
81864: LD_VAR 0 3
81868: PPUSH
81869: CALL 20831 0 1
81873: GO 81815
81875: POP
81876: POP
// end ;
81877: GO 81718
81879: POP
81880: POP
// end ;
81881: LD_VAR 0 1
81885: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
81886: LD_INT 0
81888: PPUSH
81889: PPUSH
81890: PPUSH
81891: PPUSH
81892: PPUSH
81893: PPUSH
81894: PPUSH
81895: PPUSH
81896: PPUSH
// if not mc_bases then
81897: LD_EXP 31
81901: NOT
81902: IFFALSE 81906
// exit ;
81904: GO 82528
// for i = 1 to mc_bases do
81906: LD_ADDR_VAR 0 2
81910: PUSH
81911: DOUBLE
81912: LD_INT 1
81914: DEC
81915: ST_TO_ADDR
81916: LD_EXP 31
81920: PUSH
81921: FOR_TO
81922: IFFALSE 82526
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
81924: LD_EXP 66
81928: PUSH
81929: LD_VAR 0 2
81933: ARRAY
81934: NOT
81935: PUSH
81936: LD_INT 38
81938: PPUSH
81939: LD_EXP 57
81943: PUSH
81944: LD_VAR 0 2
81948: ARRAY
81949: PPUSH
81950: CALL_OW 321
81954: PUSH
81955: LD_INT 2
81957: NONEQUAL
81958: OR
81959: IFFALSE 81963
// continue ;
81961: GO 81921
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
81963: LD_ADDR_VAR 0 8
81967: PUSH
81968: LD_EXP 31
81972: PUSH
81973: LD_VAR 0 2
81977: ARRAY
81978: PPUSH
81979: LD_INT 30
81981: PUSH
81982: LD_INT 34
81984: PUSH
81985: EMPTY
81986: LIST
81987: LIST
81988: PPUSH
81989: CALL_OW 72
81993: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
81994: LD_ADDR_VAR 0 9
81998: PUSH
81999: LD_EXP 31
82003: PUSH
82004: LD_VAR 0 2
82008: ARRAY
82009: PPUSH
82010: LD_INT 25
82012: PUSH
82013: LD_INT 4
82015: PUSH
82016: EMPTY
82017: LIST
82018: LIST
82019: PPUSH
82020: CALL_OW 72
82024: PPUSH
82025: LD_INT 0
82027: PPUSH
82028: CALL 54787 0 2
82032: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
82033: LD_VAR 0 9
82037: NOT
82038: PUSH
82039: LD_VAR 0 8
82043: NOT
82044: OR
82045: PUSH
82046: LD_EXP 31
82050: PUSH
82051: LD_VAR 0 2
82055: ARRAY
82056: PPUSH
82057: LD_INT 124
82059: PPUSH
82060: CALL 54787 0 2
82064: OR
82065: IFFALSE 82069
// continue ;
82067: GO 81921
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
82069: LD_EXP 67
82073: PUSH
82074: LD_VAR 0 2
82078: ARRAY
82079: PUSH
82080: LD_EXP 66
82084: PUSH
82085: LD_VAR 0 2
82089: ARRAY
82090: LESS
82091: PUSH
82092: LD_EXP 67
82096: PUSH
82097: LD_VAR 0 2
82101: ARRAY
82102: PUSH
82103: LD_VAR 0 8
82107: LESS
82108: AND
82109: IFFALSE 82524
// begin tmp := sci [ 1 ] ;
82111: LD_ADDR_VAR 0 7
82115: PUSH
82116: LD_VAR 0 9
82120: PUSH
82121: LD_INT 1
82123: ARRAY
82124: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
82125: LD_VAR 0 7
82129: PPUSH
82130: LD_INT 124
82132: PPUSH
82133: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
82137: LD_ADDR_VAR 0 3
82141: PUSH
82142: DOUBLE
82143: LD_EXP 66
82147: PUSH
82148: LD_VAR 0 2
82152: ARRAY
82153: INC
82154: ST_TO_ADDR
82155: LD_EXP 66
82159: PUSH
82160: LD_VAR 0 2
82164: ARRAY
82165: PUSH
82166: FOR_DOWNTO
82167: IFFALSE 82510
// begin if IsInUnit ( tmp ) then
82169: LD_VAR 0 7
82173: PPUSH
82174: CALL_OW 310
82178: IFFALSE 82189
// ComExitBuilding ( tmp ) ;
82180: LD_VAR 0 7
82184: PPUSH
82185: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
82189: LD_INT 35
82191: PPUSH
82192: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
82196: LD_VAR 0 7
82200: PPUSH
82201: CALL_OW 310
82205: NOT
82206: PUSH
82207: LD_VAR 0 7
82211: PPUSH
82212: CALL_OW 314
82216: NOT
82217: AND
82218: IFFALSE 82189
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
82220: LD_ADDR_VAR 0 6
82224: PUSH
82225: LD_VAR 0 7
82229: PPUSH
82230: CALL_OW 250
82234: PUSH
82235: LD_VAR 0 7
82239: PPUSH
82240: CALL_OW 251
82244: PUSH
82245: EMPTY
82246: LIST
82247: LIST
82248: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
82249: LD_INT 35
82251: PPUSH
82252: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
82256: LD_ADDR_VAR 0 4
82260: PUSH
82261: LD_EXP 66
82265: PUSH
82266: LD_VAR 0 2
82270: ARRAY
82271: PUSH
82272: LD_VAR 0 3
82276: ARRAY
82277: PUSH
82278: LD_INT 1
82280: ARRAY
82281: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
82282: LD_ADDR_VAR 0 5
82286: PUSH
82287: LD_EXP 66
82291: PUSH
82292: LD_VAR 0 2
82296: ARRAY
82297: PUSH
82298: LD_VAR 0 3
82302: ARRAY
82303: PUSH
82304: LD_INT 2
82306: ARRAY
82307: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
82308: LD_VAR 0 7
82312: PPUSH
82313: LD_INT 10
82315: PPUSH
82316: CALL 27443 0 2
82320: PUSH
82321: LD_INT 4
82323: ARRAY
82324: IFFALSE 82362
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
82326: LD_VAR 0 7
82330: PPUSH
82331: LD_VAR 0 6
82335: PUSH
82336: LD_INT 1
82338: ARRAY
82339: PPUSH
82340: LD_VAR 0 6
82344: PUSH
82345: LD_INT 2
82347: ARRAY
82348: PPUSH
82349: CALL_OW 111
// wait ( 0 0$10 ) ;
82353: LD_INT 350
82355: PPUSH
82356: CALL_OW 67
// end else
82360: GO 82388
// begin ComMoveXY ( tmp , x , y ) ;
82362: LD_VAR 0 7
82366: PPUSH
82367: LD_VAR 0 4
82371: PPUSH
82372: LD_VAR 0 5
82376: PPUSH
82377: CALL_OW 111
// wait ( 0 0$3 ) ;
82381: LD_INT 105
82383: PPUSH
82384: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
82388: LD_VAR 0 7
82392: PPUSH
82393: LD_VAR 0 4
82397: PPUSH
82398: LD_VAR 0 5
82402: PPUSH
82403: CALL_OW 307
82407: IFFALSE 82249
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
82409: LD_VAR 0 7
82413: PPUSH
82414: LD_VAR 0 4
82418: PPUSH
82419: LD_VAR 0 5
82423: PPUSH
82424: LD_VAR 0 8
82428: PUSH
82429: LD_VAR 0 3
82433: ARRAY
82434: PPUSH
82435: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
82439: LD_INT 35
82441: PPUSH
82442: CALL_OW 67
// until not HasTask ( tmp ) ;
82446: LD_VAR 0 7
82450: PPUSH
82451: CALL_OW 314
82455: NOT
82456: IFFALSE 82439
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
82458: LD_ADDR_EXP 67
82462: PUSH
82463: LD_EXP 67
82467: PPUSH
82468: LD_VAR 0 2
82472: PUSH
82473: LD_EXP 67
82477: PUSH
82478: LD_VAR 0 2
82482: ARRAY
82483: PUSH
82484: LD_INT 1
82486: PLUS
82487: PUSH
82488: EMPTY
82489: LIST
82490: LIST
82491: PPUSH
82492: LD_VAR 0 8
82496: PUSH
82497: LD_VAR 0 3
82501: ARRAY
82502: PPUSH
82503: CALL 24846 0 3
82507: ST_TO_ADDR
// end ;
82508: GO 82166
82510: POP
82511: POP
// MC_Reset ( i , 124 ) ;
82512: LD_VAR 0 2
82516: PPUSH
82517: LD_INT 124
82519: PPUSH
82520: CALL 65596 0 2
// end ; end ;
82524: GO 81921
82526: POP
82527: POP
// end ;
82528: LD_VAR 0 1
82532: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
82533: LD_INT 0
82535: PPUSH
82536: PPUSH
82537: PPUSH
// if not mc_bases then
82538: LD_EXP 31
82542: NOT
82543: IFFALSE 82547
// exit ;
82545: GO 83153
// for i = 1 to mc_bases do
82547: LD_ADDR_VAR 0 2
82551: PUSH
82552: DOUBLE
82553: LD_INT 1
82555: DEC
82556: ST_TO_ADDR
82557: LD_EXP 31
82561: PUSH
82562: FOR_TO
82563: IFFALSE 83151
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
82565: LD_ADDR_VAR 0 3
82569: PUSH
82570: LD_EXP 31
82574: PUSH
82575: LD_VAR 0 2
82579: ARRAY
82580: PPUSH
82581: LD_INT 25
82583: PUSH
82584: LD_INT 4
82586: PUSH
82587: EMPTY
82588: LIST
82589: LIST
82590: PPUSH
82591: CALL_OW 72
82595: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
82596: LD_VAR 0 3
82600: NOT
82601: PUSH
82602: LD_EXP 68
82606: PUSH
82607: LD_VAR 0 2
82611: ARRAY
82612: NOT
82613: OR
82614: PUSH
82615: LD_EXP 31
82619: PUSH
82620: LD_VAR 0 2
82624: ARRAY
82625: PPUSH
82626: LD_INT 2
82628: PUSH
82629: LD_INT 30
82631: PUSH
82632: LD_INT 0
82634: PUSH
82635: EMPTY
82636: LIST
82637: LIST
82638: PUSH
82639: LD_INT 30
82641: PUSH
82642: LD_INT 1
82644: PUSH
82645: EMPTY
82646: LIST
82647: LIST
82648: PUSH
82649: EMPTY
82650: LIST
82651: LIST
82652: LIST
82653: PPUSH
82654: CALL_OW 72
82658: NOT
82659: OR
82660: IFFALSE 82710
// begin if mc_deposits_finder [ i ] then
82662: LD_EXP 69
82666: PUSH
82667: LD_VAR 0 2
82671: ARRAY
82672: IFFALSE 82708
// begin MC_Reset ( i , 125 ) ;
82674: LD_VAR 0 2
82678: PPUSH
82679: LD_INT 125
82681: PPUSH
82682: CALL 65596 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
82686: LD_ADDR_EXP 69
82690: PUSH
82691: LD_EXP 69
82695: PPUSH
82696: LD_VAR 0 2
82700: PPUSH
82701: EMPTY
82702: PPUSH
82703: CALL_OW 1
82707: ST_TO_ADDR
// end ; continue ;
82708: GO 82562
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
82710: LD_EXP 68
82714: PUSH
82715: LD_VAR 0 2
82719: ARRAY
82720: PUSH
82721: LD_INT 1
82723: ARRAY
82724: PUSH
82725: LD_INT 3
82727: ARRAY
82728: PUSH
82729: LD_INT 1
82731: EQUAL
82732: PUSH
82733: LD_INT 20
82735: PPUSH
82736: LD_EXP 57
82740: PUSH
82741: LD_VAR 0 2
82745: ARRAY
82746: PPUSH
82747: CALL_OW 321
82751: PUSH
82752: LD_INT 2
82754: NONEQUAL
82755: AND
82756: IFFALSE 82806
// begin if mc_deposits_finder [ i ] then
82758: LD_EXP 69
82762: PUSH
82763: LD_VAR 0 2
82767: ARRAY
82768: IFFALSE 82804
// begin MC_Reset ( i , 125 ) ;
82770: LD_VAR 0 2
82774: PPUSH
82775: LD_INT 125
82777: PPUSH
82778: CALL 65596 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
82782: LD_ADDR_EXP 69
82786: PUSH
82787: LD_EXP 69
82791: PPUSH
82792: LD_VAR 0 2
82796: PPUSH
82797: EMPTY
82798: PPUSH
82799: CALL_OW 1
82803: ST_TO_ADDR
// end ; continue ;
82804: GO 82562
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
82806: LD_EXP 68
82810: PUSH
82811: LD_VAR 0 2
82815: ARRAY
82816: PUSH
82817: LD_INT 1
82819: ARRAY
82820: PUSH
82821: LD_INT 1
82823: ARRAY
82824: PPUSH
82825: LD_EXP 68
82829: PUSH
82830: LD_VAR 0 2
82834: ARRAY
82835: PUSH
82836: LD_INT 1
82838: ARRAY
82839: PUSH
82840: LD_INT 2
82842: ARRAY
82843: PPUSH
82844: LD_EXP 57
82848: PUSH
82849: LD_VAR 0 2
82853: ARRAY
82854: PPUSH
82855: CALL_OW 440
82859: IFFALSE 82902
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
82861: LD_ADDR_EXP 68
82865: PUSH
82866: LD_EXP 68
82870: PPUSH
82871: LD_VAR 0 2
82875: PPUSH
82876: LD_EXP 68
82880: PUSH
82881: LD_VAR 0 2
82885: ARRAY
82886: PPUSH
82887: LD_INT 1
82889: PPUSH
82890: CALL_OW 3
82894: PPUSH
82895: CALL_OW 1
82899: ST_TO_ADDR
82900: GO 83149
// begin if not mc_deposits_finder [ i ] then
82902: LD_EXP 69
82906: PUSH
82907: LD_VAR 0 2
82911: ARRAY
82912: NOT
82913: IFFALSE 82965
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
82915: LD_ADDR_EXP 69
82919: PUSH
82920: LD_EXP 69
82924: PPUSH
82925: LD_VAR 0 2
82929: PPUSH
82930: LD_VAR 0 3
82934: PUSH
82935: LD_INT 1
82937: ARRAY
82938: PUSH
82939: EMPTY
82940: LIST
82941: PPUSH
82942: CALL_OW 1
82946: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
82947: LD_VAR 0 3
82951: PUSH
82952: LD_INT 1
82954: ARRAY
82955: PPUSH
82956: LD_INT 125
82958: PPUSH
82959: CALL_OW 109
// end else
82963: GO 83149
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
82965: LD_EXP 69
82969: PUSH
82970: LD_VAR 0 2
82974: ARRAY
82975: PUSH
82976: LD_INT 1
82978: ARRAY
82979: PPUSH
82980: CALL_OW 310
82984: IFFALSE 83007
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
82986: LD_EXP 69
82990: PUSH
82991: LD_VAR 0 2
82995: ARRAY
82996: PUSH
82997: LD_INT 1
82999: ARRAY
83000: PPUSH
83001: CALL_OW 122
83005: GO 83149
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
83007: LD_EXP 69
83011: PUSH
83012: LD_VAR 0 2
83016: ARRAY
83017: PUSH
83018: LD_INT 1
83020: ARRAY
83021: PPUSH
83022: CALL_OW 314
83026: NOT
83027: PUSH
83028: LD_EXP 69
83032: PUSH
83033: LD_VAR 0 2
83037: ARRAY
83038: PUSH
83039: LD_INT 1
83041: ARRAY
83042: PPUSH
83043: LD_EXP 68
83047: PUSH
83048: LD_VAR 0 2
83052: ARRAY
83053: PUSH
83054: LD_INT 1
83056: ARRAY
83057: PUSH
83058: LD_INT 1
83060: ARRAY
83061: PPUSH
83062: LD_EXP 68
83066: PUSH
83067: LD_VAR 0 2
83071: ARRAY
83072: PUSH
83073: LD_INT 1
83075: ARRAY
83076: PUSH
83077: LD_INT 2
83079: ARRAY
83080: PPUSH
83081: CALL_OW 297
83085: PUSH
83086: LD_INT 6
83088: GREATER
83089: AND
83090: IFFALSE 83149
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
83092: LD_EXP 69
83096: PUSH
83097: LD_VAR 0 2
83101: ARRAY
83102: PUSH
83103: LD_INT 1
83105: ARRAY
83106: PPUSH
83107: LD_EXP 68
83111: PUSH
83112: LD_VAR 0 2
83116: ARRAY
83117: PUSH
83118: LD_INT 1
83120: ARRAY
83121: PUSH
83122: LD_INT 1
83124: ARRAY
83125: PPUSH
83126: LD_EXP 68
83130: PUSH
83131: LD_VAR 0 2
83135: ARRAY
83136: PUSH
83137: LD_INT 1
83139: ARRAY
83140: PUSH
83141: LD_INT 2
83143: ARRAY
83144: PPUSH
83145: CALL_OW 111
// end ; end ; end ;
83149: GO 82562
83151: POP
83152: POP
// end ;
83153: LD_VAR 0 1
83157: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
83158: LD_INT 0
83160: PPUSH
83161: PPUSH
83162: PPUSH
83163: PPUSH
83164: PPUSH
83165: PPUSH
83166: PPUSH
83167: PPUSH
83168: PPUSH
83169: PPUSH
83170: PPUSH
// if not mc_bases then
83171: LD_EXP 31
83175: NOT
83176: IFFALSE 83180
// exit ;
83178: GO 84120
// for i = 1 to mc_bases do
83180: LD_ADDR_VAR 0 2
83184: PUSH
83185: DOUBLE
83186: LD_INT 1
83188: DEC
83189: ST_TO_ADDR
83190: LD_EXP 31
83194: PUSH
83195: FOR_TO
83196: IFFALSE 84118
// begin if not mc_bases [ i ] or mc_scan [ i ] then
83198: LD_EXP 31
83202: PUSH
83203: LD_VAR 0 2
83207: ARRAY
83208: NOT
83209: PUSH
83210: LD_EXP 54
83214: PUSH
83215: LD_VAR 0 2
83219: ARRAY
83220: OR
83221: IFFALSE 83225
// continue ;
83223: GO 83195
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
83225: LD_ADDR_VAR 0 7
83229: PUSH
83230: LD_EXP 31
83234: PUSH
83235: LD_VAR 0 2
83239: ARRAY
83240: PUSH
83241: LD_INT 1
83243: ARRAY
83244: PPUSH
83245: CALL_OW 248
83249: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
83250: LD_VAR 0 7
83254: PUSH
83255: LD_INT 3
83257: EQUAL
83258: PUSH
83259: LD_EXP 50
83263: PUSH
83264: LD_VAR 0 2
83268: ARRAY
83269: PUSH
83270: LD_EXP 53
83274: PUSH
83275: LD_VAR 0 2
83279: ARRAY
83280: UNION
83281: PPUSH
83282: LD_INT 33
83284: PUSH
83285: LD_INT 2
83287: PUSH
83288: EMPTY
83289: LIST
83290: LIST
83291: PPUSH
83292: CALL_OW 72
83296: NOT
83297: OR
83298: IFFALSE 83302
// continue ;
83300: GO 83195
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
83302: LD_ADDR_VAR 0 9
83306: PUSH
83307: LD_EXP 31
83311: PUSH
83312: LD_VAR 0 2
83316: ARRAY
83317: PPUSH
83318: LD_INT 30
83320: PUSH
83321: LD_INT 36
83323: PUSH
83324: EMPTY
83325: LIST
83326: LIST
83327: PPUSH
83328: CALL_OW 72
83332: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
83333: LD_ADDR_VAR 0 10
83337: PUSH
83338: LD_EXP 50
83342: PUSH
83343: LD_VAR 0 2
83347: ARRAY
83348: PPUSH
83349: LD_INT 34
83351: PUSH
83352: LD_INT 31
83354: PUSH
83355: EMPTY
83356: LIST
83357: LIST
83358: PPUSH
83359: CALL_OW 72
83363: ST_TO_ADDR
// if not cts and not mcts then
83364: LD_VAR 0 9
83368: NOT
83369: PUSH
83370: LD_VAR 0 10
83374: NOT
83375: AND
83376: IFFALSE 83380
// continue ;
83378: GO 83195
// x := cts ;
83380: LD_ADDR_VAR 0 11
83384: PUSH
83385: LD_VAR 0 9
83389: ST_TO_ADDR
// if not x then
83390: LD_VAR 0 11
83394: NOT
83395: IFFALSE 83407
// x := mcts ;
83397: LD_ADDR_VAR 0 11
83401: PUSH
83402: LD_VAR 0 10
83406: ST_TO_ADDR
// if not x then
83407: LD_VAR 0 11
83411: NOT
83412: IFFALSE 83416
// continue ;
83414: GO 83195
// if mc_remote_driver [ i ] then
83416: LD_EXP 71
83420: PUSH
83421: LD_VAR 0 2
83425: ARRAY
83426: IFFALSE 83813
// for j in mc_remote_driver [ i ] do
83428: LD_ADDR_VAR 0 3
83432: PUSH
83433: LD_EXP 71
83437: PUSH
83438: LD_VAR 0 2
83442: ARRAY
83443: PUSH
83444: FOR_IN
83445: IFFALSE 83811
// begin if GetClass ( j ) <> 3 then
83447: LD_VAR 0 3
83451: PPUSH
83452: CALL_OW 257
83456: PUSH
83457: LD_INT 3
83459: NONEQUAL
83460: IFFALSE 83513
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
83462: LD_ADDR_EXP 71
83466: PUSH
83467: LD_EXP 71
83471: PPUSH
83472: LD_VAR 0 2
83476: PPUSH
83477: LD_EXP 71
83481: PUSH
83482: LD_VAR 0 2
83486: ARRAY
83487: PUSH
83488: LD_VAR 0 3
83492: DIFF
83493: PPUSH
83494: CALL_OW 1
83498: ST_TO_ADDR
// SetTag ( j , 0 ) ;
83499: LD_VAR 0 3
83503: PPUSH
83504: LD_INT 0
83506: PPUSH
83507: CALL_OW 109
// continue ;
83511: GO 83444
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
83513: LD_EXP 50
83517: PUSH
83518: LD_VAR 0 2
83522: ARRAY
83523: PPUSH
83524: LD_INT 34
83526: PUSH
83527: LD_INT 31
83529: PUSH
83530: EMPTY
83531: LIST
83532: LIST
83533: PUSH
83534: LD_INT 58
83536: PUSH
83537: EMPTY
83538: LIST
83539: PUSH
83540: EMPTY
83541: LIST
83542: LIST
83543: PPUSH
83544: CALL_OW 72
83548: PUSH
83549: LD_VAR 0 3
83553: PPUSH
83554: CALL 54822 0 1
83558: NOT
83559: AND
83560: IFFALSE 83631
// begin if IsInUnit ( j ) then
83562: LD_VAR 0 3
83566: PPUSH
83567: CALL_OW 310
83571: IFFALSE 83582
// ComExitBuilding ( j ) ;
83573: LD_VAR 0 3
83577: PPUSH
83578: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
83582: LD_VAR 0 3
83586: PPUSH
83587: LD_EXP 50
83591: PUSH
83592: LD_VAR 0 2
83596: ARRAY
83597: PPUSH
83598: LD_INT 34
83600: PUSH
83601: LD_INT 31
83603: PUSH
83604: EMPTY
83605: LIST
83606: LIST
83607: PUSH
83608: LD_INT 58
83610: PUSH
83611: EMPTY
83612: LIST
83613: PUSH
83614: EMPTY
83615: LIST
83616: LIST
83617: PPUSH
83618: CALL_OW 72
83622: PUSH
83623: LD_INT 1
83625: ARRAY
83626: PPUSH
83627: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
83631: LD_VAR 0 3
83635: PPUSH
83636: CALL_OW 310
83640: NOT
83641: PUSH
83642: LD_VAR 0 3
83646: PPUSH
83647: CALL_OW 310
83651: PPUSH
83652: CALL_OW 266
83656: PUSH
83657: LD_INT 36
83659: NONEQUAL
83660: PUSH
83661: LD_VAR 0 3
83665: PPUSH
83666: CALL 54822 0 1
83670: NOT
83671: AND
83672: OR
83673: IFFALSE 83809
// begin if IsInUnit ( j ) then
83675: LD_VAR 0 3
83679: PPUSH
83680: CALL_OW 310
83684: IFFALSE 83695
// ComExitBuilding ( j ) ;
83686: LD_VAR 0 3
83690: PPUSH
83691: CALL_OW 122
// ct := 0 ;
83695: LD_ADDR_VAR 0 8
83699: PUSH
83700: LD_INT 0
83702: ST_TO_ADDR
// for k in x do
83703: LD_ADDR_VAR 0 4
83707: PUSH
83708: LD_VAR 0 11
83712: PUSH
83713: FOR_IN
83714: IFFALSE 83787
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
83716: LD_VAR 0 4
83720: PPUSH
83721: CALL_OW 264
83725: PUSH
83726: LD_INT 31
83728: EQUAL
83729: PUSH
83730: LD_VAR 0 4
83734: PPUSH
83735: CALL_OW 311
83739: NOT
83740: AND
83741: PUSH
83742: LD_VAR 0 4
83746: PPUSH
83747: CALL_OW 266
83751: PUSH
83752: LD_INT 36
83754: EQUAL
83755: PUSH
83756: LD_VAR 0 4
83760: PPUSH
83761: CALL_OW 313
83765: PUSH
83766: LD_INT 3
83768: LESS
83769: AND
83770: OR
83771: IFFALSE 83785
// begin ct := k ;
83773: LD_ADDR_VAR 0 8
83777: PUSH
83778: LD_VAR 0 4
83782: ST_TO_ADDR
// break ;
83783: GO 83787
// end ;
83785: GO 83713
83787: POP
83788: POP
// if ct then
83789: LD_VAR 0 8
83793: IFFALSE 83809
// ComEnterUnit ( j , ct ) ;
83795: LD_VAR 0 3
83799: PPUSH
83800: LD_VAR 0 8
83804: PPUSH
83805: CALL_OW 120
// end ; end ;
83809: GO 83444
83811: POP
83812: POP
// places := 0 ;
83813: LD_ADDR_VAR 0 5
83817: PUSH
83818: LD_INT 0
83820: ST_TO_ADDR
// for j = 1 to x do
83821: LD_ADDR_VAR 0 3
83825: PUSH
83826: DOUBLE
83827: LD_INT 1
83829: DEC
83830: ST_TO_ADDR
83831: LD_VAR 0 11
83835: PUSH
83836: FOR_TO
83837: IFFALSE 83913
// if GetWeapon ( x [ j ] ) = ar_control_tower then
83839: LD_VAR 0 11
83843: PUSH
83844: LD_VAR 0 3
83848: ARRAY
83849: PPUSH
83850: CALL_OW 264
83854: PUSH
83855: LD_INT 31
83857: EQUAL
83858: IFFALSE 83876
// places := places + 1 else
83860: LD_ADDR_VAR 0 5
83864: PUSH
83865: LD_VAR 0 5
83869: PUSH
83870: LD_INT 1
83872: PLUS
83873: ST_TO_ADDR
83874: GO 83911
// if GetBType ( x [ j ] ) = b_control_tower then
83876: LD_VAR 0 11
83880: PUSH
83881: LD_VAR 0 3
83885: ARRAY
83886: PPUSH
83887: CALL_OW 266
83891: PUSH
83892: LD_INT 36
83894: EQUAL
83895: IFFALSE 83911
// places := places + 3 ;
83897: LD_ADDR_VAR 0 5
83901: PUSH
83902: LD_VAR 0 5
83906: PUSH
83907: LD_INT 3
83909: PLUS
83910: ST_TO_ADDR
83911: GO 83836
83913: POP
83914: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
83915: LD_VAR 0 5
83919: PUSH
83920: LD_INT 0
83922: EQUAL
83923: PUSH
83924: LD_VAR 0 5
83928: PUSH
83929: LD_EXP 71
83933: PUSH
83934: LD_VAR 0 2
83938: ARRAY
83939: LESSEQUAL
83940: OR
83941: IFFALSE 83945
// continue ;
83943: GO 83195
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
83945: LD_ADDR_VAR 0 6
83949: PUSH
83950: LD_EXP 31
83954: PUSH
83955: LD_VAR 0 2
83959: ARRAY
83960: PPUSH
83961: LD_INT 25
83963: PUSH
83964: LD_INT 3
83966: PUSH
83967: EMPTY
83968: LIST
83969: LIST
83970: PPUSH
83971: CALL_OW 72
83975: PUSH
83976: LD_EXP 71
83980: PUSH
83981: LD_VAR 0 2
83985: ARRAY
83986: DIFF
83987: PPUSH
83988: LD_INT 3
83990: PPUSH
83991: CALL 55722 0 2
83995: ST_TO_ADDR
// for j in tmp do
83996: LD_ADDR_VAR 0 3
84000: PUSH
84001: LD_VAR 0 6
84005: PUSH
84006: FOR_IN
84007: IFFALSE 84042
// if GetTag ( j ) > 0 then
84009: LD_VAR 0 3
84013: PPUSH
84014: CALL_OW 110
84018: PUSH
84019: LD_INT 0
84021: GREATER
84022: IFFALSE 84040
// tmp := tmp diff j ;
84024: LD_ADDR_VAR 0 6
84028: PUSH
84029: LD_VAR 0 6
84033: PUSH
84034: LD_VAR 0 3
84038: DIFF
84039: ST_TO_ADDR
84040: GO 84006
84042: POP
84043: POP
// if not tmp then
84044: LD_VAR 0 6
84048: NOT
84049: IFFALSE 84053
// continue ;
84051: GO 83195
// if places then
84053: LD_VAR 0 5
84057: IFFALSE 84116
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
84059: LD_ADDR_EXP 71
84063: PUSH
84064: LD_EXP 71
84068: PPUSH
84069: LD_VAR 0 2
84073: PPUSH
84074: LD_EXP 71
84078: PUSH
84079: LD_VAR 0 2
84083: ARRAY
84084: PUSH
84085: LD_VAR 0 6
84089: PUSH
84090: LD_INT 1
84092: ARRAY
84093: UNION
84094: PPUSH
84095: CALL_OW 1
84099: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
84100: LD_VAR 0 6
84104: PUSH
84105: LD_INT 1
84107: ARRAY
84108: PPUSH
84109: LD_INT 126
84111: PPUSH
84112: CALL_OW 109
// end ; end ;
84116: GO 83195
84118: POP
84119: POP
// end ;
84120: LD_VAR 0 1
84124: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
84125: LD_INT 0
84127: PPUSH
84128: PPUSH
84129: PPUSH
84130: PPUSH
84131: PPUSH
84132: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
84133: LD_VAR 0 1
84137: NOT
84138: PUSH
84139: LD_VAR 0 2
84143: NOT
84144: OR
84145: PUSH
84146: LD_VAR 0 3
84150: NOT
84151: OR
84152: PUSH
84153: LD_VAR 0 4
84157: PUSH
84158: LD_INT 1
84160: PUSH
84161: LD_INT 2
84163: PUSH
84164: LD_INT 3
84166: PUSH
84167: LD_INT 4
84169: PUSH
84170: LD_INT 5
84172: PUSH
84173: LD_INT 8
84175: PUSH
84176: LD_INT 9
84178: PUSH
84179: LD_INT 15
84181: PUSH
84182: LD_INT 16
84184: PUSH
84185: EMPTY
84186: LIST
84187: LIST
84188: LIST
84189: LIST
84190: LIST
84191: LIST
84192: LIST
84193: LIST
84194: LIST
84195: IN
84196: NOT
84197: OR
84198: IFFALSE 84202
// exit ;
84200: GO 85060
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
84202: LD_ADDR_VAR 0 2
84206: PUSH
84207: LD_VAR 0 2
84211: PPUSH
84212: LD_INT 21
84214: PUSH
84215: LD_INT 3
84217: PUSH
84218: EMPTY
84219: LIST
84220: LIST
84221: PUSH
84222: LD_INT 24
84224: PUSH
84225: LD_INT 250
84227: PUSH
84228: EMPTY
84229: LIST
84230: LIST
84231: PUSH
84232: EMPTY
84233: LIST
84234: LIST
84235: PPUSH
84236: CALL_OW 72
84240: ST_TO_ADDR
// case class of 1 , 15 :
84241: LD_VAR 0 4
84245: PUSH
84246: LD_INT 1
84248: DOUBLE
84249: EQUAL
84250: IFTRUE 84260
84252: LD_INT 15
84254: DOUBLE
84255: EQUAL
84256: IFTRUE 84260
84258: GO 84345
84260: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
84261: LD_ADDR_VAR 0 8
84265: PUSH
84266: LD_VAR 0 2
84270: PPUSH
84271: LD_INT 2
84273: PUSH
84274: LD_INT 30
84276: PUSH
84277: LD_INT 32
84279: PUSH
84280: EMPTY
84281: LIST
84282: LIST
84283: PUSH
84284: LD_INT 30
84286: PUSH
84287: LD_INT 31
84289: PUSH
84290: EMPTY
84291: LIST
84292: LIST
84293: PUSH
84294: EMPTY
84295: LIST
84296: LIST
84297: LIST
84298: PPUSH
84299: CALL_OW 72
84303: PUSH
84304: LD_VAR 0 2
84308: PPUSH
84309: LD_INT 2
84311: PUSH
84312: LD_INT 30
84314: PUSH
84315: LD_INT 4
84317: PUSH
84318: EMPTY
84319: LIST
84320: LIST
84321: PUSH
84322: LD_INT 30
84324: PUSH
84325: LD_INT 5
84327: PUSH
84328: EMPTY
84329: LIST
84330: LIST
84331: PUSH
84332: EMPTY
84333: LIST
84334: LIST
84335: LIST
84336: PPUSH
84337: CALL_OW 72
84341: ADD
84342: ST_TO_ADDR
84343: GO 84591
84345: LD_INT 2
84347: DOUBLE
84348: EQUAL
84349: IFTRUE 84359
84351: LD_INT 16
84353: DOUBLE
84354: EQUAL
84355: IFTRUE 84359
84357: GO 84405
84359: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
84360: LD_ADDR_VAR 0 8
84364: PUSH
84365: LD_VAR 0 2
84369: PPUSH
84370: LD_INT 2
84372: PUSH
84373: LD_INT 30
84375: PUSH
84376: LD_INT 0
84378: PUSH
84379: EMPTY
84380: LIST
84381: LIST
84382: PUSH
84383: LD_INT 30
84385: PUSH
84386: LD_INT 1
84388: PUSH
84389: EMPTY
84390: LIST
84391: LIST
84392: PUSH
84393: EMPTY
84394: LIST
84395: LIST
84396: LIST
84397: PPUSH
84398: CALL_OW 72
84402: ST_TO_ADDR
84403: GO 84591
84405: LD_INT 3
84407: DOUBLE
84408: EQUAL
84409: IFTRUE 84413
84411: GO 84459
84413: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
84414: LD_ADDR_VAR 0 8
84418: PUSH
84419: LD_VAR 0 2
84423: PPUSH
84424: LD_INT 2
84426: PUSH
84427: LD_INT 30
84429: PUSH
84430: LD_INT 2
84432: PUSH
84433: EMPTY
84434: LIST
84435: LIST
84436: PUSH
84437: LD_INT 30
84439: PUSH
84440: LD_INT 3
84442: PUSH
84443: EMPTY
84444: LIST
84445: LIST
84446: PUSH
84447: EMPTY
84448: LIST
84449: LIST
84450: LIST
84451: PPUSH
84452: CALL_OW 72
84456: ST_TO_ADDR
84457: GO 84591
84459: LD_INT 4
84461: DOUBLE
84462: EQUAL
84463: IFTRUE 84467
84465: GO 84524
84467: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
84468: LD_ADDR_VAR 0 8
84472: PUSH
84473: LD_VAR 0 2
84477: PPUSH
84478: LD_INT 2
84480: PUSH
84481: LD_INT 30
84483: PUSH
84484: LD_INT 6
84486: PUSH
84487: EMPTY
84488: LIST
84489: LIST
84490: PUSH
84491: LD_INT 30
84493: PUSH
84494: LD_INT 7
84496: PUSH
84497: EMPTY
84498: LIST
84499: LIST
84500: PUSH
84501: LD_INT 30
84503: PUSH
84504: LD_INT 8
84506: PUSH
84507: EMPTY
84508: LIST
84509: LIST
84510: PUSH
84511: EMPTY
84512: LIST
84513: LIST
84514: LIST
84515: LIST
84516: PPUSH
84517: CALL_OW 72
84521: ST_TO_ADDR
84522: GO 84591
84524: LD_INT 5
84526: DOUBLE
84527: EQUAL
84528: IFTRUE 84544
84530: LD_INT 8
84532: DOUBLE
84533: EQUAL
84534: IFTRUE 84544
84536: LD_INT 9
84538: DOUBLE
84539: EQUAL
84540: IFTRUE 84544
84542: GO 84590
84544: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
84545: LD_ADDR_VAR 0 8
84549: PUSH
84550: LD_VAR 0 2
84554: PPUSH
84555: LD_INT 2
84557: PUSH
84558: LD_INT 30
84560: PUSH
84561: LD_INT 4
84563: PUSH
84564: EMPTY
84565: LIST
84566: LIST
84567: PUSH
84568: LD_INT 30
84570: PUSH
84571: LD_INT 5
84573: PUSH
84574: EMPTY
84575: LIST
84576: LIST
84577: PUSH
84578: EMPTY
84579: LIST
84580: LIST
84581: LIST
84582: PPUSH
84583: CALL_OW 72
84587: ST_TO_ADDR
84588: GO 84591
84590: POP
// if not tmp then
84591: LD_VAR 0 8
84595: NOT
84596: IFFALSE 84600
// exit ;
84598: GO 85060
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
84600: LD_VAR 0 4
84604: PUSH
84605: LD_INT 1
84607: PUSH
84608: LD_INT 15
84610: PUSH
84611: EMPTY
84612: LIST
84613: LIST
84614: IN
84615: PUSH
84616: LD_EXP 40
84620: PUSH
84621: LD_VAR 0 1
84625: ARRAY
84626: AND
84627: IFFALSE 84783
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
84629: LD_ADDR_VAR 0 9
84633: PUSH
84634: LD_EXP 40
84638: PUSH
84639: LD_VAR 0 1
84643: ARRAY
84644: PUSH
84645: LD_INT 1
84647: ARRAY
84648: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
84649: LD_VAR 0 9
84653: PUSH
84654: LD_EXP 41
84658: PUSH
84659: LD_VAR 0 1
84663: ARRAY
84664: IN
84665: NOT
84666: IFFALSE 84781
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
84668: LD_ADDR_EXP 41
84672: PUSH
84673: LD_EXP 41
84677: PPUSH
84678: LD_VAR 0 1
84682: PUSH
84683: LD_EXP 41
84687: PUSH
84688: LD_VAR 0 1
84692: ARRAY
84693: PUSH
84694: LD_INT 1
84696: PLUS
84697: PUSH
84698: EMPTY
84699: LIST
84700: LIST
84701: PPUSH
84702: LD_VAR 0 9
84706: PPUSH
84707: CALL 24846 0 3
84711: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
84712: LD_ADDR_EXP 40
84716: PUSH
84717: LD_EXP 40
84721: PPUSH
84722: LD_VAR 0 1
84726: PPUSH
84727: LD_EXP 40
84731: PUSH
84732: LD_VAR 0 1
84736: ARRAY
84737: PUSH
84738: LD_VAR 0 9
84742: DIFF
84743: PPUSH
84744: CALL_OW 1
84748: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
84749: LD_VAR 0 3
84753: PPUSH
84754: LD_EXP 41
84758: PUSH
84759: LD_VAR 0 1
84763: ARRAY
84764: PUSH
84765: LD_EXP 41
84769: PUSH
84770: LD_VAR 0 1
84774: ARRAY
84775: ARRAY
84776: PPUSH
84777: CALL_OW 120
// end ; exit ;
84781: GO 85060
// end ; if tmp > 1 then
84783: LD_VAR 0 8
84787: PUSH
84788: LD_INT 1
84790: GREATER
84791: IFFALSE 84895
// for i = 2 to tmp do
84793: LD_ADDR_VAR 0 6
84797: PUSH
84798: DOUBLE
84799: LD_INT 2
84801: DEC
84802: ST_TO_ADDR
84803: LD_VAR 0 8
84807: PUSH
84808: FOR_TO
84809: IFFALSE 84893
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
84811: LD_VAR 0 8
84815: PUSH
84816: LD_VAR 0 6
84820: ARRAY
84821: PPUSH
84822: CALL_OW 461
84826: PUSH
84827: LD_INT 6
84829: EQUAL
84830: IFFALSE 84891
// begin x := tmp [ i ] ;
84832: LD_ADDR_VAR 0 9
84836: PUSH
84837: LD_VAR 0 8
84841: PUSH
84842: LD_VAR 0 6
84846: ARRAY
84847: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
84848: LD_ADDR_VAR 0 8
84852: PUSH
84853: LD_VAR 0 8
84857: PPUSH
84858: LD_VAR 0 6
84862: PPUSH
84863: CALL_OW 3
84867: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
84868: LD_ADDR_VAR 0 8
84872: PUSH
84873: LD_VAR 0 8
84877: PPUSH
84878: LD_INT 1
84880: PPUSH
84881: LD_VAR 0 9
84885: PPUSH
84886: CALL_OW 2
84890: ST_TO_ADDR
// end ;
84891: GO 84808
84893: POP
84894: POP
// for i in tmp do
84895: LD_ADDR_VAR 0 6
84899: PUSH
84900: LD_VAR 0 8
84904: PUSH
84905: FOR_IN
84906: IFFALSE 84933
// begin if IsNotFull ( i ) then
84908: LD_VAR 0 6
84912: PPUSH
84913: CALL 22068 0 1
84917: IFFALSE 84931
// begin j := i ;
84919: LD_ADDR_VAR 0 7
84923: PUSH
84924: LD_VAR 0 6
84928: ST_TO_ADDR
// break ;
84929: GO 84933
// end ; end ;
84931: GO 84905
84933: POP
84934: POP
// if j then
84935: LD_VAR 0 7
84939: IFFALSE 84957
// ComEnterUnit ( unit , j ) else
84941: LD_VAR 0 3
84945: PPUSH
84946: LD_VAR 0 7
84950: PPUSH
84951: CALL_OW 120
84955: GO 85060
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
84957: LD_ADDR_VAR 0 10
84961: PUSH
84962: LD_VAR 0 2
84966: PPUSH
84967: LD_INT 2
84969: PUSH
84970: LD_INT 30
84972: PUSH
84973: LD_INT 0
84975: PUSH
84976: EMPTY
84977: LIST
84978: LIST
84979: PUSH
84980: LD_INT 30
84982: PUSH
84983: LD_INT 1
84985: PUSH
84986: EMPTY
84987: LIST
84988: LIST
84989: PUSH
84990: EMPTY
84991: LIST
84992: LIST
84993: LIST
84994: PPUSH
84995: CALL_OW 72
84999: ST_TO_ADDR
// if depot then
85000: LD_VAR 0 10
85004: IFFALSE 85060
// begin depot := NearestUnitToUnit ( depot , unit ) ;
85006: LD_ADDR_VAR 0 10
85010: PUSH
85011: LD_VAR 0 10
85015: PPUSH
85016: LD_VAR 0 3
85020: PPUSH
85021: CALL_OW 74
85025: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
85026: LD_VAR 0 3
85030: PPUSH
85031: LD_VAR 0 10
85035: PPUSH
85036: CALL_OW 296
85040: PUSH
85041: LD_INT 10
85043: GREATER
85044: IFFALSE 85060
// ComStandNearbyBuilding ( unit , depot ) ;
85046: LD_VAR 0 3
85050: PPUSH
85051: LD_VAR 0 10
85055: PPUSH
85056: CALL 21448 0 2
// end ; end ; end ;
85060: LD_VAR 0 5
85064: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
85065: LD_INT 0
85067: PPUSH
85068: PPUSH
85069: PPUSH
85070: PPUSH
// if not mc_bases then
85071: LD_EXP 31
85075: NOT
85076: IFFALSE 85080
// exit ;
85078: GO 85319
// for i = 1 to mc_bases do
85080: LD_ADDR_VAR 0 2
85084: PUSH
85085: DOUBLE
85086: LD_INT 1
85088: DEC
85089: ST_TO_ADDR
85090: LD_EXP 31
85094: PUSH
85095: FOR_TO
85096: IFFALSE 85317
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
85098: LD_ADDR_VAR 0 4
85102: PUSH
85103: LD_EXP 31
85107: PUSH
85108: LD_VAR 0 2
85112: ARRAY
85113: PPUSH
85114: LD_INT 21
85116: PUSH
85117: LD_INT 1
85119: PUSH
85120: EMPTY
85121: LIST
85122: LIST
85123: PPUSH
85124: CALL_OW 72
85128: PUSH
85129: LD_EXP 60
85133: PUSH
85134: LD_VAR 0 2
85138: ARRAY
85139: UNION
85140: ST_TO_ADDR
// if not tmp then
85141: LD_VAR 0 4
85145: NOT
85146: IFFALSE 85150
// continue ;
85148: GO 85095
// for j in tmp do
85150: LD_ADDR_VAR 0 3
85154: PUSH
85155: LD_VAR 0 4
85159: PUSH
85160: FOR_IN
85161: IFFALSE 85313
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
85163: LD_VAR 0 3
85167: PPUSH
85168: CALL_OW 110
85172: NOT
85173: PUSH
85174: LD_VAR 0 3
85178: PPUSH
85179: CALL_OW 314
85183: NOT
85184: AND
85185: PUSH
85186: LD_VAR 0 3
85190: PPUSH
85191: CALL_OW 311
85195: NOT
85196: AND
85197: PUSH
85198: LD_VAR 0 3
85202: PPUSH
85203: CALL_OW 310
85207: NOT
85208: AND
85209: PUSH
85210: LD_VAR 0 3
85214: PUSH
85215: LD_EXP 34
85219: PUSH
85220: LD_VAR 0 2
85224: ARRAY
85225: PUSH
85226: LD_INT 1
85228: ARRAY
85229: IN
85230: NOT
85231: AND
85232: PUSH
85233: LD_VAR 0 3
85237: PUSH
85238: LD_EXP 34
85242: PUSH
85243: LD_VAR 0 2
85247: ARRAY
85248: PUSH
85249: LD_INT 2
85251: ARRAY
85252: IN
85253: NOT
85254: AND
85255: PUSH
85256: LD_VAR 0 3
85260: PUSH
85261: LD_EXP 43
85265: PUSH
85266: LD_VAR 0 2
85270: ARRAY
85271: IN
85272: NOT
85273: AND
85274: IFFALSE 85311
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
85276: LD_VAR 0 2
85280: PPUSH
85281: LD_EXP 31
85285: PUSH
85286: LD_VAR 0 2
85290: ARRAY
85291: PPUSH
85292: LD_VAR 0 3
85296: PPUSH
85297: LD_VAR 0 3
85301: PPUSH
85302: CALL_OW 257
85306: PPUSH
85307: CALL 84125 0 4
// end ;
85311: GO 85160
85313: POP
85314: POP
// end ;
85315: GO 85095
85317: POP
85318: POP
// end ;
85319: LD_VAR 0 1
85323: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , j , c ; begin
85324: LD_INT 0
85326: PPUSH
85327: PPUSH
85328: PPUSH
85329: PPUSH
85330: PPUSH
85331: PPUSH
// if not mc_bases [ base ] then
85332: LD_EXP 31
85336: PUSH
85337: LD_VAR 0 1
85341: ARRAY
85342: NOT
85343: IFFALSE 85347
// exit ;
85345: GO 85548
// tmp := [ ] ;
85347: LD_ADDR_VAR 0 6
85351: PUSH
85352: EMPTY
85353: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
85354: LD_ADDR_VAR 0 7
85358: PUSH
85359: LD_VAR 0 3
85363: PPUSH
85364: LD_INT 0
85366: PPUSH
85367: CALL_OW 517
85371: ST_TO_ADDR
// if not list then
85372: LD_VAR 0 7
85376: NOT
85377: IFFALSE 85381
// exit ;
85379: GO 85548
// c := Count ( list [ 1 ] ) ;
85381: LD_ADDR_VAR 0 9
85385: PUSH
85386: LD_VAR 0 7
85390: PUSH
85391: LD_INT 1
85393: ARRAY
85394: PPUSH
85395: CALL 21986 0 1
85399: ST_TO_ADDR
// if amount > c then
85400: LD_VAR 0 2
85404: PUSH
85405: LD_VAR 0 9
85409: GREATER
85410: IFFALSE 85422
// amount := c ;
85412: LD_ADDR_VAR 0 2
85416: PUSH
85417: LD_VAR 0 9
85421: ST_TO_ADDR
// for i := 1 to amount do
85422: LD_ADDR_VAR 0 5
85426: PUSH
85427: DOUBLE
85428: LD_INT 1
85430: DEC
85431: ST_TO_ADDR
85432: LD_VAR 0 2
85436: PUSH
85437: FOR_TO
85438: IFFALSE 85496
// tmp := Replace ( tmp , i , [ list [ 1 ] [ i ] , list [ 2 ] [ i ] ] ) ;
85440: LD_ADDR_VAR 0 6
85444: PUSH
85445: LD_VAR 0 6
85449: PPUSH
85450: LD_VAR 0 5
85454: PPUSH
85455: LD_VAR 0 7
85459: PUSH
85460: LD_INT 1
85462: ARRAY
85463: PUSH
85464: LD_VAR 0 5
85468: ARRAY
85469: PUSH
85470: LD_VAR 0 7
85474: PUSH
85475: LD_INT 2
85477: ARRAY
85478: PUSH
85479: LD_VAR 0 5
85483: ARRAY
85484: PUSH
85485: EMPTY
85486: LIST
85487: LIST
85488: PPUSH
85489: CALL_OW 1
85493: ST_TO_ADDR
85494: GO 85437
85496: POP
85497: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
85498: LD_ADDR_EXP 44
85502: PUSH
85503: LD_EXP 44
85507: PPUSH
85508: LD_VAR 0 1
85512: PPUSH
85513: LD_VAR 0 6
85517: PPUSH
85518: CALL_OW 1
85522: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
85523: LD_ADDR_EXP 46
85527: PUSH
85528: LD_EXP 46
85532: PPUSH
85533: LD_VAR 0 1
85537: PPUSH
85538: LD_VAR 0 3
85542: PPUSH
85543: CALL_OW 1
85547: ST_TO_ADDR
// end ;
85548: LD_VAR 0 4
85552: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
85553: LD_INT 0
85555: PPUSH
// if not mc_bases [ base ] then
85556: LD_EXP 31
85560: PUSH
85561: LD_VAR 0 1
85565: ARRAY
85566: NOT
85567: IFFALSE 85571
// exit ;
85569: GO 85596
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
85571: LD_ADDR_EXP 36
85575: PUSH
85576: LD_EXP 36
85580: PPUSH
85581: LD_VAR 0 1
85585: PPUSH
85586: LD_VAR 0 2
85590: PPUSH
85591: CALL_OW 1
85595: ST_TO_ADDR
// end ;
85596: LD_VAR 0 3
85600: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
85601: LD_INT 0
85603: PPUSH
// if not mc_bases [ base ] then
85604: LD_EXP 31
85608: PUSH
85609: LD_VAR 0 1
85613: ARRAY
85614: NOT
85615: IFFALSE 85619
// exit ;
85617: GO 85656
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
85619: LD_ADDR_EXP 36
85623: PUSH
85624: LD_EXP 36
85628: PPUSH
85629: LD_VAR 0 1
85633: PPUSH
85634: LD_EXP 36
85638: PUSH
85639: LD_VAR 0 1
85643: ARRAY
85644: PUSH
85645: LD_VAR 0 2
85649: UNION
85650: PPUSH
85651: CALL_OW 1
85655: ST_TO_ADDR
// end ;
85656: LD_VAR 0 3
85660: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
85661: LD_INT 0
85663: PPUSH
// if not mc_bases [ base ] then
85664: LD_EXP 31
85668: PUSH
85669: LD_VAR 0 1
85673: ARRAY
85674: NOT
85675: IFFALSE 85679
// exit ;
85677: GO 85704
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
85679: LD_ADDR_EXP 52
85683: PUSH
85684: LD_EXP 52
85688: PPUSH
85689: LD_VAR 0 1
85693: PPUSH
85694: LD_VAR 0 2
85698: PPUSH
85699: CALL_OW 1
85703: ST_TO_ADDR
// end ;
85704: LD_VAR 0 3
85708: RET
// export function MC_InsertProduceList ( base , components ) ; begin
85709: LD_INT 0
85711: PPUSH
// if not mc_bases [ base ] then
85712: LD_EXP 31
85716: PUSH
85717: LD_VAR 0 1
85721: ARRAY
85722: NOT
85723: IFFALSE 85727
// exit ;
85725: GO 85764
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
85727: LD_ADDR_EXP 52
85731: PUSH
85732: LD_EXP 52
85736: PPUSH
85737: LD_VAR 0 1
85741: PPUSH
85742: LD_EXP 52
85746: PUSH
85747: LD_VAR 0 1
85751: ARRAY
85752: PUSH
85753: LD_VAR 0 2
85757: ADD
85758: PPUSH
85759: CALL_OW 1
85763: ST_TO_ADDR
// end ;
85764: LD_VAR 0 3
85768: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
85769: LD_INT 0
85771: PPUSH
// if not mc_bases [ base ] then
85772: LD_EXP 31
85776: PUSH
85777: LD_VAR 0 1
85781: ARRAY
85782: NOT
85783: IFFALSE 85787
// exit ;
85785: GO 85841
// mc_defender := Replace ( mc_defender , base , deflist ) ;
85787: LD_ADDR_EXP 53
85791: PUSH
85792: LD_EXP 53
85796: PPUSH
85797: LD_VAR 0 1
85801: PPUSH
85802: LD_VAR 0 2
85806: PPUSH
85807: CALL_OW 1
85811: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
85812: LD_ADDR_EXP 42
85816: PUSH
85817: LD_EXP 42
85821: PPUSH
85822: LD_VAR 0 1
85826: PPUSH
85827: LD_VAR 0 2
85831: PUSH
85832: LD_INT 0
85834: PLUS
85835: PPUSH
85836: CALL_OW 1
85840: ST_TO_ADDR
// end ;
85841: LD_VAR 0 3
85845: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
85846: LD_INT 0
85848: PPUSH
// if not mc_bases [ base ] then
85849: LD_EXP 31
85853: PUSH
85854: LD_VAR 0 1
85858: ARRAY
85859: NOT
85860: IFFALSE 85864
// exit ;
85862: GO 85889
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
85864: LD_ADDR_EXP 42
85868: PUSH
85869: LD_EXP 42
85873: PPUSH
85874: LD_VAR 0 1
85878: PPUSH
85879: LD_VAR 0 2
85883: PPUSH
85884: CALL_OW 1
85888: ST_TO_ADDR
// end ;
85889: LD_VAR 0 3
85893: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
85894: LD_INT 0
85896: PPUSH
85897: PPUSH
85898: PPUSH
85899: PPUSH
// if not mc_bases [ base ] then
85900: LD_EXP 31
85904: PUSH
85905: LD_VAR 0 1
85909: ARRAY
85910: NOT
85911: IFFALSE 85915
// exit ;
85913: GO 85980
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
85915: LD_ADDR_EXP 51
85919: PUSH
85920: LD_EXP 51
85924: PPUSH
85925: LD_VAR 0 1
85929: PUSH
85930: LD_EXP 51
85934: PUSH
85935: LD_VAR 0 1
85939: ARRAY
85940: PUSH
85941: LD_INT 1
85943: PLUS
85944: PUSH
85945: EMPTY
85946: LIST
85947: LIST
85948: PPUSH
85949: LD_VAR 0 1
85953: PUSH
85954: LD_VAR 0 2
85958: PUSH
85959: LD_VAR 0 3
85963: PUSH
85964: LD_VAR 0 4
85968: PUSH
85969: EMPTY
85970: LIST
85971: LIST
85972: LIST
85973: LIST
85974: PPUSH
85975: CALL 24846 0 3
85979: ST_TO_ADDR
// end ;
85980: LD_VAR 0 5
85984: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
85985: LD_INT 0
85987: PPUSH
// if not mc_bases [ base ] then
85988: LD_EXP 31
85992: PUSH
85993: LD_VAR 0 1
85997: ARRAY
85998: NOT
85999: IFFALSE 86003
// exit ;
86001: GO 86028
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
86003: LD_ADDR_EXP 68
86007: PUSH
86008: LD_EXP 68
86012: PPUSH
86013: LD_VAR 0 1
86017: PPUSH
86018: LD_VAR 0 2
86022: PPUSH
86023: CALL_OW 1
86027: ST_TO_ADDR
// end ;
86028: LD_VAR 0 3
86032: RET
// export function MC_GetMinesField ( base ) ; begin
86033: LD_INT 0
86035: PPUSH
// result := mc_mines [ base ] ;
86036: LD_ADDR_VAR 0 2
86040: PUSH
86041: LD_EXP 44
86045: PUSH
86046: LD_VAR 0 1
86050: ARRAY
86051: ST_TO_ADDR
// end ;
86052: LD_VAR 0 2
86056: RET
// export function MC_GetProduceList ( base ) ; begin
86057: LD_INT 0
86059: PPUSH
// result := mc_produce [ base ] ;
86060: LD_ADDR_VAR 0 2
86064: PUSH
86065: LD_EXP 52
86069: PUSH
86070: LD_VAR 0 1
86074: ARRAY
86075: ST_TO_ADDR
// end ;
86076: LD_VAR 0 2
86080: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
86081: LD_INT 0
86083: PPUSH
86084: PPUSH
// if not mc_bases then
86085: LD_EXP 31
86089: NOT
86090: IFFALSE 86094
// exit ;
86092: GO 86159
// if mc_bases [ base ] then
86094: LD_EXP 31
86098: PUSH
86099: LD_VAR 0 1
86103: ARRAY
86104: IFFALSE 86159
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
86106: LD_ADDR_VAR 0 3
86110: PUSH
86111: LD_EXP 31
86115: PUSH
86116: LD_VAR 0 1
86120: ARRAY
86121: PPUSH
86122: LD_INT 30
86124: PUSH
86125: LD_VAR 0 2
86129: PUSH
86130: EMPTY
86131: LIST
86132: LIST
86133: PPUSH
86134: CALL_OW 72
86138: ST_TO_ADDR
// if result then
86139: LD_VAR 0 3
86143: IFFALSE 86159
// result := result [ 1 ] ;
86145: LD_ADDR_VAR 0 3
86149: PUSH
86150: LD_VAR 0 3
86154: PUSH
86155: LD_INT 1
86157: ARRAY
86158: ST_TO_ADDR
// end ; end ;
86159: LD_VAR 0 3
86163: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
86164: LD_INT 0
86166: PPUSH
86167: PPUSH
// if not mc_bases then
86168: LD_EXP 31
86172: NOT
86173: IFFALSE 86177
// exit ;
86175: GO 86222
// if mc_bases [ base ] then
86177: LD_EXP 31
86181: PUSH
86182: LD_VAR 0 1
86186: ARRAY
86187: IFFALSE 86222
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
86189: LD_ADDR_VAR 0 3
86193: PUSH
86194: LD_EXP 31
86198: PUSH
86199: LD_VAR 0 1
86203: ARRAY
86204: PPUSH
86205: LD_INT 30
86207: PUSH
86208: LD_VAR 0 2
86212: PUSH
86213: EMPTY
86214: LIST
86215: LIST
86216: PPUSH
86217: CALL_OW 72
86221: ST_TO_ADDR
// end ;
86222: LD_VAR 0 3
86226: RET
// export function MC_SetTame ( base , area ) ; begin
86227: LD_INT 0
86229: PPUSH
// if not mc_bases or not base then
86230: LD_EXP 31
86234: NOT
86235: PUSH
86236: LD_VAR 0 1
86240: NOT
86241: OR
86242: IFFALSE 86246
// exit ;
86244: GO 86271
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
86246: LD_ADDR_EXP 59
86250: PUSH
86251: LD_EXP 59
86255: PPUSH
86256: LD_VAR 0 1
86260: PPUSH
86261: LD_VAR 0 2
86265: PPUSH
86266: CALL_OW 1
86270: ST_TO_ADDR
// end ;
86271: LD_VAR 0 3
86275: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
86276: LD_INT 0
86278: PPUSH
86279: PPUSH
// if not mc_bases or not base then
86280: LD_EXP 31
86284: NOT
86285: PUSH
86286: LD_VAR 0 1
86290: NOT
86291: OR
86292: IFFALSE 86296
// exit ;
86294: GO 86398
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
86296: LD_ADDR_VAR 0 4
86300: PUSH
86301: LD_EXP 31
86305: PUSH
86306: LD_VAR 0 1
86310: ARRAY
86311: PPUSH
86312: LD_INT 30
86314: PUSH
86315: LD_VAR 0 2
86319: PUSH
86320: EMPTY
86321: LIST
86322: LIST
86323: PPUSH
86324: CALL_OW 72
86328: ST_TO_ADDR
// if not tmp then
86329: LD_VAR 0 4
86333: NOT
86334: IFFALSE 86338
// exit ;
86336: GO 86398
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
86338: LD_ADDR_EXP 63
86342: PUSH
86343: LD_EXP 63
86347: PPUSH
86348: LD_VAR 0 1
86352: PPUSH
86353: LD_EXP 63
86357: PUSH
86358: LD_VAR 0 1
86362: ARRAY
86363: PPUSH
86364: LD_EXP 63
86368: PUSH
86369: LD_VAR 0 1
86373: ARRAY
86374: PUSH
86375: LD_INT 1
86377: PLUS
86378: PPUSH
86379: LD_VAR 0 4
86383: PUSH
86384: LD_INT 1
86386: ARRAY
86387: PPUSH
86388: CALL_OW 2
86392: PPUSH
86393: CALL_OW 1
86397: ST_TO_ADDR
// end ;
86398: LD_VAR 0 3
86402: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
86403: LD_INT 0
86405: PPUSH
86406: PPUSH
// if not mc_bases or not base or not kinds then
86407: LD_EXP 31
86411: NOT
86412: PUSH
86413: LD_VAR 0 1
86417: NOT
86418: OR
86419: PUSH
86420: LD_VAR 0 2
86424: NOT
86425: OR
86426: IFFALSE 86430
// exit ;
86428: GO 86491
// for i in kinds do
86430: LD_ADDR_VAR 0 4
86434: PUSH
86435: LD_VAR 0 2
86439: PUSH
86440: FOR_IN
86441: IFFALSE 86489
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
86443: LD_ADDR_EXP 65
86447: PUSH
86448: LD_EXP 65
86452: PPUSH
86453: LD_VAR 0 1
86457: PUSH
86458: LD_EXP 65
86462: PUSH
86463: LD_VAR 0 1
86467: ARRAY
86468: PUSH
86469: LD_INT 1
86471: PLUS
86472: PUSH
86473: EMPTY
86474: LIST
86475: LIST
86476: PPUSH
86477: LD_VAR 0 4
86481: PPUSH
86482: CALL 24846 0 3
86486: ST_TO_ADDR
86487: GO 86440
86489: POP
86490: POP
// end ;
86491: LD_VAR 0 3
86495: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
86496: LD_INT 0
86498: PPUSH
// if not mc_bases or not base or not areas then
86499: LD_EXP 31
86503: NOT
86504: PUSH
86505: LD_VAR 0 1
86509: NOT
86510: OR
86511: PUSH
86512: LD_VAR 0 2
86516: NOT
86517: OR
86518: IFFALSE 86522
// exit ;
86520: GO 86547
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
86522: LD_ADDR_EXP 49
86526: PUSH
86527: LD_EXP 49
86531: PPUSH
86532: LD_VAR 0 1
86536: PPUSH
86537: LD_VAR 0 2
86541: PPUSH
86542: CALL_OW 1
86546: ST_TO_ADDR
// end ;
86547: LD_VAR 0 3
86551: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
86552: LD_INT 0
86554: PPUSH
// if not mc_bases or not base or not teleports_exit then
86555: LD_EXP 31
86559: NOT
86560: PUSH
86561: LD_VAR 0 1
86565: NOT
86566: OR
86567: PUSH
86568: LD_VAR 0 2
86572: NOT
86573: OR
86574: IFFALSE 86578
// exit ;
86576: GO 86603
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
86578: LD_ADDR_EXP 66
86582: PUSH
86583: LD_EXP 66
86587: PPUSH
86588: LD_VAR 0 1
86592: PPUSH
86593: LD_VAR 0 2
86597: PPUSH
86598: CALL_OW 1
86602: ST_TO_ADDR
// end ;
86603: LD_VAR 0 3
86607: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
86608: LD_INT 0
86610: PPUSH
86611: PPUSH
86612: PPUSH
// if not mc_bases or not base or not ext_list then
86613: LD_EXP 31
86617: NOT
86618: PUSH
86619: LD_VAR 0 1
86623: NOT
86624: OR
86625: PUSH
86626: LD_VAR 0 5
86630: NOT
86631: OR
86632: IFFALSE 86636
// exit ;
86634: GO 86809
// tmp := GetFacExtXYD ( x , y , d ) ;
86636: LD_ADDR_VAR 0 8
86640: PUSH
86641: LD_VAR 0 2
86645: PPUSH
86646: LD_VAR 0 3
86650: PPUSH
86651: LD_VAR 0 4
86655: PPUSH
86656: CALL 54852 0 3
86660: ST_TO_ADDR
// if not tmp then
86661: LD_VAR 0 8
86665: NOT
86666: IFFALSE 86670
// exit ;
86668: GO 86809
// for i in tmp do
86670: LD_ADDR_VAR 0 7
86674: PUSH
86675: LD_VAR 0 8
86679: PUSH
86680: FOR_IN
86681: IFFALSE 86807
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
86683: LD_ADDR_EXP 36
86687: PUSH
86688: LD_EXP 36
86692: PPUSH
86693: LD_VAR 0 1
86697: PPUSH
86698: LD_EXP 36
86702: PUSH
86703: LD_VAR 0 1
86707: ARRAY
86708: PPUSH
86709: LD_EXP 36
86713: PUSH
86714: LD_VAR 0 1
86718: ARRAY
86719: PUSH
86720: LD_INT 1
86722: PLUS
86723: PPUSH
86724: LD_VAR 0 5
86728: PUSH
86729: LD_INT 1
86731: ARRAY
86732: PUSH
86733: LD_VAR 0 7
86737: PUSH
86738: LD_INT 1
86740: ARRAY
86741: PUSH
86742: LD_VAR 0 7
86746: PUSH
86747: LD_INT 2
86749: ARRAY
86750: PUSH
86751: LD_VAR 0 7
86755: PUSH
86756: LD_INT 3
86758: ARRAY
86759: PUSH
86760: EMPTY
86761: LIST
86762: LIST
86763: LIST
86764: LIST
86765: PPUSH
86766: CALL_OW 2
86770: PPUSH
86771: CALL_OW 1
86775: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
86776: LD_ADDR_VAR 0 5
86780: PUSH
86781: LD_VAR 0 5
86785: PPUSH
86786: LD_INT 1
86788: PPUSH
86789: CALL_OW 3
86793: ST_TO_ADDR
// if not ext_list then
86794: LD_VAR 0 5
86798: NOT
86799: IFFALSE 86805
// exit ;
86801: POP
86802: POP
86803: GO 86809
// end ;
86805: GO 86680
86807: POP
86808: POP
// end ;
86809: LD_VAR 0 6
86813: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
86814: LD_INT 0
86816: PPUSH
// if not mc_bases or not base or not weapon_list then
86817: LD_EXP 31
86821: NOT
86822: PUSH
86823: LD_VAR 0 1
86827: NOT
86828: OR
86829: PUSH
86830: LD_VAR 0 2
86834: NOT
86835: OR
86836: IFFALSE 86840
// exit ;
86838: GO 86865
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
86840: LD_ADDR_EXP 70
86844: PUSH
86845: LD_EXP 70
86849: PPUSH
86850: LD_VAR 0 1
86854: PPUSH
86855: LD_VAR 0 2
86859: PPUSH
86860: CALL_OW 1
86864: ST_TO_ADDR
// end ;
86865: LD_VAR 0 3
86869: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
86870: LD_INT 0
86872: PPUSH
// if not mc_bases or not base or not tech_list then
86873: LD_EXP 31
86877: NOT
86878: PUSH
86879: LD_VAR 0 1
86883: NOT
86884: OR
86885: PUSH
86886: LD_VAR 0 2
86890: NOT
86891: OR
86892: IFFALSE 86896
// exit ;
86894: GO 86921
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
86896: LD_ADDR_EXP 58
86900: PUSH
86901: LD_EXP 58
86905: PPUSH
86906: LD_VAR 0 1
86910: PPUSH
86911: LD_VAR 0 2
86915: PPUSH
86916: CALL_OW 1
86920: ST_TO_ADDR
// end ;
86921: LD_VAR 0 3
86925: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
86926: LD_INT 0
86928: PPUSH
// if not mc_bases or not parking_area or not base then
86929: LD_EXP 31
86933: NOT
86934: PUSH
86935: LD_VAR 0 2
86939: NOT
86940: OR
86941: PUSH
86942: LD_VAR 0 1
86946: NOT
86947: OR
86948: IFFALSE 86952
// exit ;
86950: GO 86977
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
86952: LD_ADDR_EXP 55
86956: PUSH
86957: LD_EXP 55
86961: PPUSH
86962: LD_VAR 0 1
86966: PPUSH
86967: LD_VAR 0 2
86971: PPUSH
86972: CALL_OW 1
86976: ST_TO_ADDR
// end ;
86977: LD_VAR 0 3
86981: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
86982: LD_INT 0
86984: PPUSH
// if not mc_bases or not base or not scan_area then
86985: LD_EXP 31
86989: NOT
86990: PUSH
86991: LD_VAR 0 1
86995: NOT
86996: OR
86997: PUSH
86998: LD_VAR 0 2
87002: NOT
87003: OR
87004: IFFALSE 87008
// exit ;
87006: GO 87033
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
87008: LD_ADDR_EXP 56
87012: PUSH
87013: LD_EXP 56
87017: PPUSH
87018: LD_VAR 0 1
87022: PPUSH
87023: LD_VAR 0 2
87027: PPUSH
87028: CALL_OW 1
87032: ST_TO_ADDR
// end ;
87033: LD_VAR 0 3
87037: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
87038: LD_INT 0
87040: PPUSH
87041: PPUSH
// if not mc_bases or not base then
87042: LD_EXP 31
87046: NOT
87047: PUSH
87048: LD_VAR 0 1
87052: NOT
87053: OR
87054: IFFALSE 87058
// exit ;
87056: GO 87122
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
87058: LD_ADDR_VAR 0 3
87062: PUSH
87063: LD_INT 1
87065: PUSH
87066: LD_INT 2
87068: PUSH
87069: LD_INT 3
87071: PUSH
87072: LD_INT 4
87074: PUSH
87075: LD_INT 11
87077: PUSH
87078: EMPTY
87079: LIST
87080: LIST
87081: LIST
87082: LIST
87083: LIST
87084: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
87085: LD_ADDR_EXP 58
87089: PUSH
87090: LD_EXP 58
87094: PPUSH
87095: LD_VAR 0 1
87099: PPUSH
87100: LD_EXP 58
87104: PUSH
87105: LD_VAR 0 1
87109: ARRAY
87110: PUSH
87111: LD_VAR 0 3
87115: DIFF
87116: PPUSH
87117: CALL_OW 1
87121: ST_TO_ADDR
// end ;
87122: LD_VAR 0 2
87126: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
87127: LD_INT 0
87129: PPUSH
// result := mc_vehicles [ base ] ;
87130: LD_ADDR_VAR 0 3
87134: PUSH
87135: LD_EXP 50
87139: PUSH
87140: LD_VAR 0 1
87144: ARRAY
87145: ST_TO_ADDR
// if onlyCombat then
87146: LD_VAR 0 2
87150: IFFALSE 87322
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
87152: LD_ADDR_VAR 0 3
87156: PUSH
87157: LD_VAR 0 3
87161: PUSH
87162: LD_VAR 0 3
87166: PPUSH
87167: LD_INT 2
87169: PUSH
87170: LD_INT 34
87172: PUSH
87173: LD_INT 12
87175: PUSH
87176: EMPTY
87177: LIST
87178: LIST
87179: PUSH
87180: LD_INT 34
87182: PUSH
87183: LD_INT 51
87185: PUSH
87186: EMPTY
87187: LIST
87188: LIST
87189: PUSH
87190: LD_INT 34
87192: PUSH
87193: LD_INT 89
87195: PUSH
87196: EMPTY
87197: LIST
87198: LIST
87199: PUSH
87200: LD_INT 34
87202: PUSH
87203: LD_INT 32
87205: PUSH
87206: EMPTY
87207: LIST
87208: LIST
87209: PUSH
87210: LD_INT 34
87212: PUSH
87213: LD_INT 13
87215: PUSH
87216: EMPTY
87217: LIST
87218: LIST
87219: PUSH
87220: LD_INT 34
87222: PUSH
87223: LD_INT 52
87225: PUSH
87226: EMPTY
87227: LIST
87228: LIST
87229: PUSH
87230: LD_INT 34
87232: PUSH
87233: LD_INT 88
87235: PUSH
87236: EMPTY
87237: LIST
87238: LIST
87239: PUSH
87240: LD_INT 34
87242: PUSH
87243: LD_INT 14
87245: PUSH
87246: EMPTY
87247: LIST
87248: LIST
87249: PUSH
87250: LD_INT 34
87252: PUSH
87253: LD_INT 53
87255: PUSH
87256: EMPTY
87257: LIST
87258: LIST
87259: PUSH
87260: LD_INT 34
87262: PUSH
87263: LD_INT 98
87265: PUSH
87266: EMPTY
87267: LIST
87268: LIST
87269: PUSH
87270: LD_INT 34
87272: PUSH
87273: LD_INT 31
87275: PUSH
87276: EMPTY
87277: LIST
87278: LIST
87279: PUSH
87280: LD_INT 34
87282: PUSH
87283: LD_INT 48
87285: PUSH
87286: EMPTY
87287: LIST
87288: LIST
87289: PUSH
87290: LD_INT 34
87292: PUSH
87293: LD_INT 8
87295: PUSH
87296: EMPTY
87297: LIST
87298: LIST
87299: PUSH
87300: EMPTY
87301: LIST
87302: LIST
87303: LIST
87304: LIST
87305: LIST
87306: LIST
87307: LIST
87308: LIST
87309: LIST
87310: LIST
87311: LIST
87312: LIST
87313: LIST
87314: LIST
87315: PPUSH
87316: CALL_OW 72
87320: DIFF
87321: ST_TO_ADDR
// end ; end_of_file
87322: LD_VAR 0 3
87326: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
87327: LD_INT 0
87329: PPUSH
87330: PPUSH
87331: PPUSH
// if not mc_bases or not skirmish then
87332: LD_EXP 31
87336: NOT
87337: PUSH
87338: LD_EXP 29
87342: NOT
87343: OR
87344: IFFALSE 87348
// exit ;
87346: GO 87513
// for i = 1 to mc_bases do
87348: LD_ADDR_VAR 0 4
87352: PUSH
87353: DOUBLE
87354: LD_INT 1
87356: DEC
87357: ST_TO_ADDR
87358: LD_EXP 31
87362: PUSH
87363: FOR_TO
87364: IFFALSE 87511
// begin if sci in mc_bases [ i ] then
87366: LD_VAR 0 2
87370: PUSH
87371: LD_EXP 31
87375: PUSH
87376: LD_VAR 0 4
87380: ARRAY
87381: IN
87382: IFFALSE 87509
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
87384: LD_ADDR_EXP 60
87388: PUSH
87389: LD_EXP 60
87393: PPUSH
87394: LD_VAR 0 4
87398: PUSH
87399: LD_EXP 60
87403: PUSH
87404: LD_VAR 0 4
87408: ARRAY
87409: PUSH
87410: LD_INT 1
87412: PLUS
87413: PUSH
87414: EMPTY
87415: LIST
87416: LIST
87417: PPUSH
87418: LD_VAR 0 1
87422: PPUSH
87423: CALL 24846 0 3
87427: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
87428: LD_ADDR_VAR 0 5
87432: PUSH
87433: LD_EXP 31
87437: PUSH
87438: LD_VAR 0 4
87442: ARRAY
87443: PPUSH
87444: LD_INT 2
87446: PUSH
87447: LD_INT 30
87449: PUSH
87450: LD_INT 0
87452: PUSH
87453: EMPTY
87454: LIST
87455: LIST
87456: PUSH
87457: LD_INT 30
87459: PUSH
87460: LD_INT 1
87462: PUSH
87463: EMPTY
87464: LIST
87465: LIST
87466: PUSH
87467: EMPTY
87468: LIST
87469: LIST
87470: LIST
87471: PPUSH
87472: CALL_OW 72
87476: PPUSH
87477: LD_VAR 0 1
87481: PPUSH
87482: CALL_OW 74
87486: ST_TO_ADDR
// if tmp then
87487: LD_VAR 0 5
87491: IFFALSE 87507
// ComStandNearbyBuilding ( ape , tmp ) ;
87493: LD_VAR 0 1
87497: PPUSH
87498: LD_VAR 0 5
87502: PPUSH
87503: CALL 21448 0 2
// break ;
87507: GO 87511
// end ; end ;
87509: GO 87363
87511: POP
87512: POP
// end ;
87513: LD_VAR 0 3
87517: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
87518: LD_INT 0
87520: PPUSH
87521: PPUSH
87522: PPUSH
// if not mc_bases or not skirmish then
87523: LD_EXP 31
87527: NOT
87528: PUSH
87529: LD_EXP 29
87533: NOT
87534: OR
87535: IFFALSE 87539
// exit ;
87537: GO 87628
// for i = 1 to mc_bases do
87539: LD_ADDR_VAR 0 4
87543: PUSH
87544: DOUBLE
87545: LD_INT 1
87547: DEC
87548: ST_TO_ADDR
87549: LD_EXP 31
87553: PUSH
87554: FOR_TO
87555: IFFALSE 87626
// begin if building in mc_busy_turret_list [ i ] then
87557: LD_VAR 0 1
87561: PUSH
87562: LD_EXP 41
87566: PUSH
87567: LD_VAR 0 4
87571: ARRAY
87572: IN
87573: IFFALSE 87624
// begin tmp := mc_busy_turret_list [ i ] diff building ;
87575: LD_ADDR_VAR 0 5
87579: PUSH
87580: LD_EXP 41
87584: PUSH
87585: LD_VAR 0 4
87589: ARRAY
87590: PUSH
87591: LD_VAR 0 1
87595: DIFF
87596: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
87597: LD_ADDR_EXP 41
87601: PUSH
87602: LD_EXP 41
87606: PPUSH
87607: LD_VAR 0 4
87611: PPUSH
87612: LD_VAR 0 5
87616: PPUSH
87617: CALL_OW 1
87621: ST_TO_ADDR
// break ;
87622: GO 87626
// end ; end ;
87624: GO 87554
87626: POP
87627: POP
// end ;
87628: LD_VAR 0 3
87632: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
87633: LD_INT 0
87635: PPUSH
87636: PPUSH
87637: PPUSH
// if not mc_bases or not skirmish then
87638: LD_EXP 31
87642: NOT
87643: PUSH
87644: LD_EXP 29
87648: NOT
87649: OR
87650: IFFALSE 87654
// exit ;
87652: GO 87853
// for i = 1 to mc_bases do
87654: LD_ADDR_VAR 0 5
87658: PUSH
87659: DOUBLE
87660: LD_INT 1
87662: DEC
87663: ST_TO_ADDR
87664: LD_EXP 31
87668: PUSH
87669: FOR_TO
87670: IFFALSE 87851
// if building in mc_bases [ i ] then
87672: LD_VAR 0 1
87676: PUSH
87677: LD_EXP 31
87681: PUSH
87682: LD_VAR 0 5
87686: ARRAY
87687: IN
87688: IFFALSE 87849
// begin tmp := mc_bases [ i ] diff building ;
87690: LD_ADDR_VAR 0 6
87694: PUSH
87695: LD_EXP 31
87699: PUSH
87700: LD_VAR 0 5
87704: ARRAY
87705: PUSH
87706: LD_VAR 0 1
87710: DIFF
87711: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
87712: LD_ADDR_EXP 31
87716: PUSH
87717: LD_EXP 31
87721: PPUSH
87722: LD_VAR 0 5
87726: PPUSH
87727: LD_VAR 0 6
87731: PPUSH
87732: CALL_OW 1
87736: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
87737: LD_VAR 0 1
87741: PUSH
87742: LD_EXP 39
87746: PUSH
87747: LD_VAR 0 5
87751: ARRAY
87752: IN
87753: IFFALSE 87792
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
87755: LD_ADDR_EXP 39
87759: PUSH
87760: LD_EXP 39
87764: PPUSH
87765: LD_VAR 0 5
87769: PPUSH
87770: LD_EXP 39
87774: PUSH
87775: LD_VAR 0 5
87779: ARRAY
87780: PUSH
87781: LD_VAR 0 1
87785: DIFF
87786: PPUSH
87787: CALL_OW 1
87791: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
87792: LD_VAR 0 1
87796: PUSH
87797: LD_EXP 40
87801: PUSH
87802: LD_VAR 0 5
87806: ARRAY
87807: IN
87808: IFFALSE 87847
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
87810: LD_ADDR_EXP 40
87814: PUSH
87815: LD_EXP 40
87819: PPUSH
87820: LD_VAR 0 5
87824: PPUSH
87825: LD_EXP 40
87829: PUSH
87830: LD_VAR 0 5
87834: ARRAY
87835: PUSH
87836: LD_VAR 0 1
87840: DIFF
87841: PPUSH
87842: CALL_OW 1
87846: ST_TO_ADDR
// break ;
87847: GO 87851
// end ;
87849: GO 87669
87851: POP
87852: POP
// end ;
87853: LD_VAR 0 4
87857: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
87858: LD_INT 0
87860: PPUSH
87861: PPUSH
87862: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
87863: LD_EXP 31
87867: NOT
87868: PUSH
87869: LD_EXP 29
87873: NOT
87874: OR
87875: PUSH
87876: LD_VAR 0 3
87880: PUSH
87881: LD_EXP 57
87885: IN
87886: NOT
87887: OR
87888: IFFALSE 87892
// exit ;
87890: GO 88015
// for i = 1 to mc_vehicles do
87892: LD_ADDR_VAR 0 6
87896: PUSH
87897: DOUBLE
87898: LD_INT 1
87900: DEC
87901: ST_TO_ADDR
87902: LD_EXP 50
87906: PUSH
87907: FOR_TO
87908: IFFALSE 88013
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
87910: LD_VAR 0 2
87914: PUSH
87915: LD_EXP 50
87919: PUSH
87920: LD_VAR 0 6
87924: ARRAY
87925: IN
87926: PUSH
87927: LD_VAR 0 1
87931: PUSH
87932: LD_EXP 50
87936: PUSH
87937: LD_VAR 0 6
87941: ARRAY
87942: IN
87943: OR
87944: IFFALSE 88011
// begin tmp := mc_vehicles [ i ] diff old ;
87946: LD_ADDR_VAR 0 7
87950: PUSH
87951: LD_EXP 50
87955: PUSH
87956: LD_VAR 0 6
87960: ARRAY
87961: PUSH
87962: LD_VAR 0 2
87966: DIFF
87967: ST_TO_ADDR
// tmp := tmp diff new ;
87968: LD_ADDR_VAR 0 7
87972: PUSH
87973: LD_VAR 0 7
87977: PUSH
87978: LD_VAR 0 1
87982: DIFF
87983: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
87984: LD_ADDR_EXP 50
87988: PUSH
87989: LD_EXP 50
87993: PPUSH
87994: LD_VAR 0 6
87998: PPUSH
87999: LD_VAR 0 7
88003: PPUSH
88004: CALL_OW 1
88008: ST_TO_ADDR
// break ;
88009: GO 88013
// end ;
88011: GO 87907
88013: POP
88014: POP
// end ;
88015: LD_VAR 0 5
88019: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
88020: LD_INT 0
88022: PPUSH
88023: PPUSH
88024: PPUSH
88025: PPUSH
// if not mc_bases or not skirmish then
88026: LD_EXP 31
88030: NOT
88031: PUSH
88032: LD_EXP 29
88036: NOT
88037: OR
88038: IFFALSE 88042
// exit ;
88040: GO 88462
// repeat wait ( 0 0$1 ) ;
88042: LD_INT 35
88044: PPUSH
88045: CALL_OW 67
// until not mc_block_vehicle_constructed_thread ;
88049: LD_EXP 75
88053: NOT
88054: IFFALSE 88042
// mc_block_vehicle_constructed_thread := true ;
88056: LD_ADDR_EXP 75
88060: PUSH
88061: LD_INT 1
88063: ST_TO_ADDR
// side := GetSide ( vehicle ) ;
88064: LD_ADDR_VAR 0 5
88068: PUSH
88069: LD_VAR 0 1
88073: PPUSH
88074: CALL_OW 255
88078: ST_TO_ADDR
// for i = 1 to mc_bases do
88079: LD_ADDR_VAR 0 4
88083: PUSH
88084: DOUBLE
88085: LD_INT 1
88087: DEC
88088: ST_TO_ADDR
88089: LD_EXP 31
88093: PUSH
88094: FOR_TO
88095: IFFALSE 88452
// begin if factory in mc_bases [ i ] then
88097: LD_VAR 0 2
88101: PUSH
88102: LD_EXP 31
88106: PUSH
88107: LD_VAR 0 4
88111: ARRAY
88112: IN
88113: IFFALSE 88450
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
88115: LD_EXP 53
88119: PUSH
88120: LD_VAR 0 4
88124: ARRAY
88125: PUSH
88126: LD_EXP 42
88130: PUSH
88131: LD_VAR 0 4
88135: ARRAY
88136: LESS
88137: PUSH
88138: LD_VAR 0 1
88142: PPUSH
88143: CALL_OW 264
88147: PUSH
88148: LD_INT 31
88150: PUSH
88151: LD_INT 32
88153: PUSH
88154: LD_INT 51
88156: PUSH
88157: LD_INT 89
88159: PUSH
88160: LD_INT 12
88162: PUSH
88163: LD_INT 30
88165: PUSH
88166: LD_INT 98
88168: PUSH
88169: LD_INT 11
88171: PUSH
88172: LD_INT 53
88174: PUSH
88175: LD_INT 14
88177: PUSH
88178: LD_INT 91
88180: PUSH
88181: LD_INT 29
88183: PUSH
88184: LD_INT 99
88186: PUSH
88187: LD_INT 13
88189: PUSH
88190: LD_INT 52
88192: PUSH
88193: LD_INT 88
88195: PUSH
88196: LD_INT 48
88198: PUSH
88199: LD_INT 8
88201: PUSH
88202: EMPTY
88203: LIST
88204: LIST
88205: LIST
88206: LIST
88207: LIST
88208: LIST
88209: LIST
88210: LIST
88211: LIST
88212: LIST
88213: LIST
88214: LIST
88215: LIST
88216: LIST
88217: LIST
88218: LIST
88219: LIST
88220: LIST
88221: IN
88222: NOT
88223: AND
88224: IFFALSE 88272
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
88226: LD_ADDR_EXP 53
88230: PUSH
88231: LD_EXP 53
88235: PPUSH
88236: LD_VAR 0 4
88240: PUSH
88241: LD_EXP 53
88245: PUSH
88246: LD_VAR 0 4
88250: ARRAY
88251: PUSH
88252: LD_INT 1
88254: PLUS
88255: PUSH
88256: EMPTY
88257: LIST
88258: LIST
88259: PPUSH
88260: LD_VAR 0 1
88264: PPUSH
88265: CALL 24846 0 3
88269: ST_TO_ADDR
88270: GO 88316
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
88272: LD_ADDR_EXP 50
88276: PUSH
88277: LD_EXP 50
88281: PPUSH
88282: LD_VAR 0 4
88286: PUSH
88287: LD_EXP 50
88291: PUSH
88292: LD_VAR 0 4
88296: ARRAY
88297: PUSH
88298: LD_INT 1
88300: PLUS
88301: PUSH
88302: EMPTY
88303: LIST
88304: LIST
88305: PPUSH
88306: LD_VAR 0 1
88310: PPUSH
88311: CALL 24846 0 3
88315: ST_TO_ADDR
// mc_block_vehicle_constructed_thread := false ;
88316: LD_ADDR_EXP 75
88320: PUSH
88321: LD_INT 0
88323: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
88324: LD_VAR 0 1
88328: PPUSH
88329: CALL_OW 263
88333: PUSH
88334: LD_INT 2
88336: EQUAL
88337: IFFALSE 88366
// begin repeat wait ( 0 0$3 ) ;
88339: LD_INT 105
88341: PPUSH
88342: CALL_OW 67
// Connect ( vehicle ) ;
88346: LD_VAR 0 1
88350: PPUSH
88351: CALL 27824 0 1
// until IsControledBy ( vehicle ) ;
88355: LD_VAR 0 1
88359: PPUSH
88360: CALL_OW 312
88364: IFFALSE 88339
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
88366: LD_VAR 0 1
88370: PPUSH
88371: LD_EXP 55
88375: PUSH
88376: LD_VAR 0 4
88380: ARRAY
88381: PPUSH
88382: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
88386: LD_VAR 0 1
88390: PPUSH
88391: CALL_OW 263
88395: PUSH
88396: LD_INT 1
88398: NONEQUAL
88399: IFFALSE 88403
// break ;
88401: GO 88452
// repeat wait ( 0 0$1 ) ;
88403: LD_INT 35
88405: PPUSH
88406: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
88410: LD_VAR 0 1
88414: PPUSH
88415: LD_EXP 55
88419: PUSH
88420: LD_VAR 0 4
88424: ARRAY
88425: PPUSH
88426: CALL_OW 308
88430: IFFALSE 88403
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
88432: LD_VAR 0 1
88436: PPUSH
88437: CALL_OW 311
88441: PPUSH
88442: CALL_OW 121
// exit ;
88446: POP
88447: POP
88448: GO 88462
// end ; end ;
88450: GO 88094
88452: POP
88453: POP
// mc_block_vehicle_constructed_thread := false ;
88454: LD_ADDR_EXP 75
88458: PUSH
88459: LD_INT 0
88461: ST_TO_ADDR
// end ;
88462: LD_VAR 0 3
88466: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
88467: LD_INT 0
88469: PPUSH
88470: PPUSH
88471: PPUSH
88472: PPUSH
// if not mc_bases or not skirmish then
88473: LD_EXP 31
88477: NOT
88478: PUSH
88479: LD_EXP 29
88483: NOT
88484: OR
88485: IFFALSE 88489
// exit ;
88487: GO 88842
// repeat wait ( 0 0$1 ) ;
88489: LD_INT 35
88491: PPUSH
88492: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
88496: LD_VAR 0 2
88500: PPUSH
88501: LD_VAR 0 3
88505: PPUSH
88506: CALL_OW 284
88510: IFFALSE 88489
// if GetResourceTypeXY ( x , y ) = mat_artefact then
88512: LD_VAR 0 2
88516: PPUSH
88517: LD_VAR 0 3
88521: PPUSH
88522: CALL_OW 283
88526: PUSH
88527: LD_INT 4
88529: EQUAL
88530: IFFALSE 88534
// exit ;
88532: GO 88842
// for i = 1 to mc_bases do
88534: LD_ADDR_VAR 0 7
88538: PUSH
88539: DOUBLE
88540: LD_INT 1
88542: DEC
88543: ST_TO_ADDR
88544: LD_EXP 31
88548: PUSH
88549: FOR_TO
88550: IFFALSE 88840
// begin if mc_crates_area [ i ] then
88552: LD_EXP 49
88556: PUSH
88557: LD_VAR 0 7
88561: ARRAY
88562: IFFALSE 88673
// for j in mc_crates_area [ i ] do
88564: LD_ADDR_VAR 0 8
88568: PUSH
88569: LD_EXP 49
88573: PUSH
88574: LD_VAR 0 7
88578: ARRAY
88579: PUSH
88580: FOR_IN
88581: IFFALSE 88671
// if InArea ( x , y , j ) then
88583: LD_VAR 0 2
88587: PPUSH
88588: LD_VAR 0 3
88592: PPUSH
88593: LD_VAR 0 8
88597: PPUSH
88598: CALL_OW 309
88602: IFFALSE 88669
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
88604: LD_ADDR_EXP 47
88608: PUSH
88609: LD_EXP 47
88613: PPUSH
88614: LD_VAR 0 7
88618: PUSH
88619: LD_EXP 47
88623: PUSH
88624: LD_VAR 0 7
88628: ARRAY
88629: PUSH
88630: LD_INT 1
88632: PLUS
88633: PUSH
88634: EMPTY
88635: LIST
88636: LIST
88637: PPUSH
88638: LD_VAR 0 4
88642: PUSH
88643: LD_VAR 0 2
88647: PUSH
88648: LD_VAR 0 3
88652: PUSH
88653: EMPTY
88654: LIST
88655: LIST
88656: LIST
88657: PPUSH
88658: CALL 24846 0 3
88662: ST_TO_ADDR
// exit ;
88663: POP
88664: POP
88665: POP
88666: POP
88667: GO 88842
// end ;
88669: GO 88580
88671: POP
88672: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
88673: LD_ADDR_VAR 0 9
88677: PUSH
88678: LD_EXP 31
88682: PUSH
88683: LD_VAR 0 7
88687: ARRAY
88688: PPUSH
88689: LD_INT 2
88691: PUSH
88692: LD_INT 30
88694: PUSH
88695: LD_INT 0
88697: PUSH
88698: EMPTY
88699: LIST
88700: LIST
88701: PUSH
88702: LD_INT 30
88704: PUSH
88705: LD_INT 1
88707: PUSH
88708: EMPTY
88709: LIST
88710: LIST
88711: PUSH
88712: EMPTY
88713: LIST
88714: LIST
88715: LIST
88716: PPUSH
88717: CALL_OW 72
88721: ST_TO_ADDR
// if not depot then
88722: LD_VAR 0 9
88726: NOT
88727: IFFALSE 88731
// continue ;
88729: GO 88549
// for j in depot do
88731: LD_ADDR_VAR 0 8
88735: PUSH
88736: LD_VAR 0 9
88740: PUSH
88741: FOR_IN
88742: IFFALSE 88836
// if GetDistUnitXY ( j , x , y ) < 30 then
88744: LD_VAR 0 8
88748: PPUSH
88749: LD_VAR 0 2
88753: PPUSH
88754: LD_VAR 0 3
88758: PPUSH
88759: CALL_OW 297
88763: PUSH
88764: LD_INT 30
88766: LESS
88767: IFFALSE 88834
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
88769: LD_ADDR_EXP 47
88773: PUSH
88774: LD_EXP 47
88778: PPUSH
88779: LD_VAR 0 7
88783: PUSH
88784: LD_EXP 47
88788: PUSH
88789: LD_VAR 0 7
88793: ARRAY
88794: PUSH
88795: LD_INT 1
88797: PLUS
88798: PUSH
88799: EMPTY
88800: LIST
88801: LIST
88802: PPUSH
88803: LD_VAR 0 4
88807: PUSH
88808: LD_VAR 0 2
88812: PUSH
88813: LD_VAR 0 3
88817: PUSH
88818: EMPTY
88819: LIST
88820: LIST
88821: LIST
88822: PPUSH
88823: CALL 24846 0 3
88827: ST_TO_ADDR
// exit ;
88828: POP
88829: POP
88830: POP
88831: POP
88832: GO 88842
// end ;
88834: GO 88741
88836: POP
88837: POP
// end ;
88838: GO 88549
88840: POP
88841: POP
// end ;
88842: LD_VAR 0 6
88846: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
88847: LD_INT 0
88849: PPUSH
88850: PPUSH
88851: PPUSH
88852: PPUSH
// if not mc_bases or not skirmish then
88853: LD_EXP 31
88857: NOT
88858: PUSH
88859: LD_EXP 29
88863: NOT
88864: OR
88865: IFFALSE 88869
// exit ;
88867: GO 89146
// side := GetSide ( lab ) ;
88869: LD_ADDR_VAR 0 4
88873: PUSH
88874: LD_VAR 0 2
88878: PPUSH
88879: CALL_OW 255
88883: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
88884: LD_VAR 0 4
88888: PUSH
88889: LD_EXP 57
88893: IN
88894: NOT
88895: PUSH
88896: LD_EXP 58
88900: NOT
88901: OR
88902: PUSH
88903: LD_EXP 31
88907: NOT
88908: OR
88909: IFFALSE 88913
// exit ;
88911: GO 89146
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
88913: LD_ADDR_EXP 58
88917: PUSH
88918: LD_EXP 58
88922: PPUSH
88923: LD_VAR 0 4
88927: PPUSH
88928: LD_EXP 58
88932: PUSH
88933: LD_VAR 0 4
88937: ARRAY
88938: PUSH
88939: LD_VAR 0 1
88943: DIFF
88944: PPUSH
88945: CALL_OW 1
88949: ST_TO_ADDR
// for i = 1 to mc_bases do
88950: LD_ADDR_VAR 0 5
88954: PUSH
88955: DOUBLE
88956: LD_INT 1
88958: DEC
88959: ST_TO_ADDR
88960: LD_EXP 31
88964: PUSH
88965: FOR_TO
88966: IFFALSE 89144
// begin if lab in mc_bases [ i ] then
88968: LD_VAR 0 2
88972: PUSH
88973: LD_EXP 31
88977: PUSH
88978: LD_VAR 0 5
88982: ARRAY
88983: IN
88984: IFFALSE 89142
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
88986: LD_VAR 0 1
88990: PUSH
88991: LD_INT 11
88993: PUSH
88994: LD_INT 4
88996: PUSH
88997: LD_INT 3
88999: PUSH
89000: LD_INT 2
89002: PUSH
89003: EMPTY
89004: LIST
89005: LIST
89006: LIST
89007: LIST
89008: IN
89009: PUSH
89010: LD_EXP 61
89014: PUSH
89015: LD_VAR 0 5
89019: ARRAY
89020: AND
89021: IFFALSE 89142
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
89023: LD_ADDR_VAR 0 6
89027: PUSH
89028: LD_EXP 61
89032: PUSH
89033: LD_VAR 0 5
89037: ARRAY
89038: PUSH
89039: LD_INT 1
89041: ARRAY
89042: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
89043: LD_ADDR_EXP 61
89047: PUSH
89048: LD_EXP 61
89052: PPUSH
89053: LD_VAR 0 5
89057: PPUSH
89058: EMPTY
89059: PPUSH
89060: CALL_OW 1
89064: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
89065: LD_VAR 0 6
89069: PPUSH
89070: LD_INT 0
89072: PPUSH
89073: CALL_OW 109
// ComExitBuilding ( tmp ) ;
89077: LD_VAR 0 6
89081: PPUSH
89082: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
89086: LD_ADDR_EXP 60
89090: PUSH
89091: LD_EXP 60
89095: PPUSH
89096: LD_VAR 0 5
89100: PPUSH
89101: LD_EXP 60
89105: PUSH
89106: LD_VAR 0 5
89110: ARRAY
89111: PPUSH
89112: LD_INT 1
89114: PPUSH
89115: LD_VAR 0 6
89119: PPUSH
89120: CALL_OW 2
89124: PPUSH
89125: CALL_OW 1
89129: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
89130: LD_VAR 0 5
89134: PPUSH
89135: LD_INT 112
89137: PPUSH
89138: CALL 65596 0 2
// end ; end ; end ;
89142: GO 88965
89144: POP
89145: POP
// end ;
89146: LD_VAR 0 3
89150: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
89151: LD_INT 0
89153: PPUSH
89154: PPUSH
89155: PPUSH
89156: PPUSH
89157: PPUSH
89158: PPUSH
89159: PPUSH
89160: PPUSH
// if not mc_bases or not skirmish then
89161: LD_EXP 31
89165: NOT
89166: PUSH
89167: LD_EXP 29
89171: NOT
89172: OR
89173: IFFALSE 89177
// exit ;
89175: GO 90546
// for i = 1 to mc_bases do
89177: LD_ADDR_VAR 0 3
89181: PUSH
89182: DOUBLE
89183: LD_INT 1
89185: DEC
89186: ST_TO_ADDR
89187: LD_EXP 31
89191: PUSH
89192: FOR_TO
89193: IFFALSE 90544
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
89195: LD_VAR 0 1
89199: PUSH
89200: LD_EXP 31
89204: PUSH
89205: LD_VAR 0 3
89209: ARRAY
89210: IN
89211: PUSH
89212: LD_VAR 0 1
89216: PUSH
89217: LD_EXP 38
89221: PUSH
89222: LD_VAR 0 3
89226: ARRAY
89227: IN
89228: OR
89229: PUSH
89230: LD_VAR 0 1
89234: PUSH
89235: LD_EXP 53
89239: PUSH
89240: LD_VAR 0 3
89244: ARRAY
89245: IN
89246: OR
89247: PUSH
89248: LD_VAR 0 1
89252: PUSH
89253: LD_EXP 50
89257: PUSH
89258: LD_VAR 0 3
89262: ARRAY
89263: IN
89264: OR
89265: PUSH
89266: LD_VAR 0 1
89270: PUSH
89271: LD_EXP 60
89275: PUSH
89276: LD_VAR 0 3
89280: ARRAY
89281: IN
89282: OR
89283: PUSH
89284: LD_VAR 0 1
89288: PUSH
89289: LD_EXP 61
89293: PUSH
89294: LD_VAR 0 3
89298: ARRAY
89299: IN
89300: OR
89301: IFFALSE 90542
// begin if un in mc_ape [ i ] then
89303: LD_VAR 0 1
89307: PUSH
89308: LD_EXP 60
89312: PUSH
89313: LD_VAR 0 3
89317: ARRAY
89318: IN
89319: IFFALSE 89358
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
89321: LD_ADDR_EXP 60
89325: PUSH
89326: LD_EXP 60
89330: PPUSH
89331: LD_VAR 0 3
89335: PPUSH
89336: LD_EXP 60
89340: PUSH
89341: LD_VAR 0 3
89345: ARRAY
89346: PUSH
89347: LD_VAR 0 1
89351: DIFF
89352: PPUSH
89353: CALL_OW 1
89357: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
89358: LD_VAR 0 1
89362: PUSH
89363: LD_EXP 61
89367: PUSH
89368: LD_VAR 0 3
89372: ARRAY
89373: IN
89374: IFFALSE 89398
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
89376: LD_ADDR_EXP 61
89380: PUSH
89381: LD_EXP 61
89385: PPUSH
89386: LD_VAR 0 3
89390: PPUSH
89391: EMPTY
89392: PPUSH
89393: CALL_OW 1
89397: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
89398: LD_VAR 0 1
89402: PPUSH
89403: CALL_OW 247
89407: PUSH
89408: LD_INT 2
89410: EQUAL
89411: PUSH
89412: LD_VAR 0 1
89416: PPUSH
89417: CALL_OW 110
89421: PUSH
89422: LD_INT 20
89424: EQUAL
89425: PUSH
89426: LD_VAR 0 1
89430: PUSH
89431: LD_EXP 53
89435: PUSH
89436: LD_VAR 0 3
89440: ARRAY
89441: IN
89442: OR
89443: PUSH
89444: LD_VAR 0 1
89448: PPUSH
89449: CALL_OW 264
89453: PUSH
89454: LD_INT 12
89456: PUSH
89457: LD_INT 51
89459: PUSH
89460: LD_INT 89
89462: PUSH
89463: LD_INT 32
89465: PUSH
89466: LD_INT 13
89468: PUSH
89469: LD_INT 52
89471: PUSH
89472: LD_INT 31
89474: PUSH
89475: EMPTY
89476: LIST
89477: LIST
89478: LIST
89479: LIST
89480: LIST
89481: LIST
89482: LIST
89483: IN
89484: OR
89485: AND
89486: IFFALSE 89794
// begin if un in mc_defender [ i ] then
89488: LD_VAR 0 1
89492: PUSH
89493: LD_EXP 53
89497: PUSH
89498: LD_VAR 0 3
89502: ARRAY
89503: IN
89504: IFFALSE 89543
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
89506: LD_ADDR_EXP 53
89510: PUSH
89511: LD_EXP 53
89515: PPUSH
89516: LD_VAR 0 3
89520: PPUSH
89521: LD_EXP 53
89525: PUSH
89526: LD_VAR 0 3
89530: ARRAY
89531: PUSH
89532: LD_VAR 0 1
89536: DIFF
89537: PPUSH
89538: CALL_OW 1
89542: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
89543: LD_ADDR_VAR 0 8
89547: PUSH
89548: LD_VAR 0 3
89552: PPUSH
89553: LD_INT 3
89555: PPUSH
89556: CALL 86164 0 2
89560: ST_TO_ADDR
// if fac then
89561: LD_VAR 0 8
89565: IFFALSE 89794
// begin for j in fac do
89567: LD_ADDR_VAR 0 4
89571: PUSH
89572: LD_VAR 0 8
89576: PUSH
89577: FOR_IN
89578: IFFALSE 89792
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
89580: LD_ADDR_VAR 0 9
89584: PUSH
89585: LD_VAR 0 8
89589: PPUSH
89590: LD_VAR 0 1
89594: PPUSH
89595: CALL_OW 265
89599: PPUSH
89600: LD_VAR 0 1
89604: PPUSH
89605: CALL_OW 262
89609: PPUSH
89610: LD_VAR 0 1
89614: PPUSH
89615: CALL_OW 263
89619: PPUSH
89620: LD_VAR 0 1
89624: PPUSH
89625: CALL_OW 264
89629: PPUSH
89630: CALL 22344 0 5
89634: ST_TO_ADDR
// if components then
89635: LD_VAR 0 9
89639: IFFALSE 89790
// begin if GetWeapon ( un ) = ar_control_tower then
89641: LD_VAR 0 1
89645: PPUSH
89646: CALL_OW 264
89650: PUSH
89651: LD_INT 31
89653: EQUAL
89654: IFFALSE 89771
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
89656: LD_VAR 0 1
89660: PPUSH
89661: CALL_OW 311
89665: PPUSH
89666: LD_INT 0
89668: PPUSH
89669: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
89673: LD_ADDR_EXP 71
89677: PUSH
89678: LD_EXP 71
89682: PPUSH
89683: LD_VAR 0 3
89687: PPUSH
89688: LD_EXP 71
89692: PUSH
89693: LD_VAR 0 3
89697: ARRAY
89698: PUSH
89699: LD_VAR 0 1
89703: PPUSH
89704: CALL_OW 311
89708: DIFF
89709: PPUSH
89710: CALL_OW 1
89714: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
89715: LD_ADDR_VAR 0 7
89719: PUSH
89720: LD_EXP 52
89724: PUSH
89725: LD_VAR 0 3
89729: ARRAY
89730: PPUSH
89731: LD_INT 1
89733: PPUSH
89734: LD_VAR 0 9
89738: PPUSH
89739: CALL_OW 2
89743: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
89744: LD_ADDR_EXP 52
89748: PUSH
89749: LD_EXP 52
89753: PPUSH
89754: LD_VAR 0 3
89758: PPUSH
89759: LD_VAR 0 7
89763: PPUSH
89764: CALL_OW 1
89768: ST_TO_ADDR
// end else
89769: GO 89788
// MC_InsertProduceList ( i , [ components ] ) ;
89771: LD_VAR 0 3
89775: PPUSH
89776: LD_VAR 0 9
89780: PUSH
89781: EMPTY
89782: LIST
89783: PPUSH
89784: CALL 85709 0 2
// break ;
89788: GO 89792
// end ; end ;
89790: GO 89577
89792: POP
89793: POP
// end ; end ; if GetType ( un ) = unit_building then
89794: LD_VAR 0 1
89798: PPUSH
89799: CALL_OW 247
89803: PUSH
89804: LD_INT 3
89806: EQUAL
89807: IFFALSE 90210
// begin btype := GetBType ( un ) ;
89809: LD_ADDR_VAR 0 5
89813: PUSH
89814: LD_VAR 0 1
89818: PPUSH
89819: CALL_OW 266
89823: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
89824: LD_VAR 0 5
89828: PUSH
89829: LD_INT 29
89831: PUSH
89832: LD_INT 30
89834: PUSH
89835: EMPTY
89836: LIST
89837: LIST
89838: IN
89839: IFFALSE 89912
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
89841: LD_VAR 0 1
89845: PPUSH
89846: CALL_OW 250
89850: PPUSH
89851: LD_VAR 0 1
89855: PPUSH
89856: CALL_OW 251
89860: PPUSH
89861: LD_VAR 0 1
89865: PPUSH
89866: CALL_OW 255
89870: PPUSH
89871: CALL_OW 440
89875: NOT
89876: IFFALSE 89912
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
89878: LD_VAR 0 1
89882: PPUSH
89883: CALL_OW 250
89887: PPUSH
89888: LD_VAR 0 1
89892: PPUSH
89893: CALL_OW 251
89897: PPUSH
89898: LD_VAR 0 1
89902: PPUSH
89903: CALL_OW 255
89907: PPUSH
89908: CALL_OW 441
// end ; if btype = b_warehouse then
89912: LD_VAR 0 5
89916: PUSH
89917: LD_INT 1
89919: EQUAL
89920: IFFALSE 89938
// begin btype := b_depot ;
89922: LD_ADDR_VAR 0 5
89926: PUSH
89927: LD_INT 0
89929: ST_TO_ADDR
// pos := 1 ;
89930: LD_ADDR_VAR 0 6
89934: PUSH
89935: LD_INT 1
89937: ST_TO_ADDR
// end ; if btype = b_factory then
89938: LD_VAR 0 5
89942: PUSH
89943: LD_INT 3
89945: EQUAL
89946: IFFALSE 89964
// begin btype := b_workshop ;
89948: LD_ADDR_VAR 0 5
89952: PUSH
89953: LD_INT 2
89955: ST_TO_ADDR
// pos := 1 ;
89956: LD_ADDR_VAR 0 6
89960: PUSH
89961: LD_INT 1
89963: ST_TO_ADDR
// end ; if btype = b_barracks then
89964: LD_VAR 0 5
89968: PUSH
89969: LD_INT 5
89971: EQUAL
89972: IFFALSE 89982
// btype := b_armoury ;
89974: LD_ADDR_VAR 0 5
89978: PUSH
89979: LD_INT 4
89981: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
89982: LD_VAR 0 5
89986: PUSH
89987: LD_INT 7
89989: PUSH
89990: LD_INT 8
89992: PUSH
89993: EMPTY
89994: LIST
89995: LIST
89996: IN
89997: IFFALSE 90007
// btype := b_lab ;
89999: LD_ADDR_VAR 0 5
90003: PUSH
90004: LD_INT 6
90006: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
90007: LD_ADDR_EXP 36
90011: PUSH
90012: LD_EXP 36
90016: PPUSH
90017: LD_VAR 0 3
90021: PUSH
90022: LD_EXP 36
90026: PUSH
90027: LD_VAR 0 3
90031: ARRAY
90032: PUSH
90033: LD_INT 1
90035: PLUS
90036: PUSH
90037: EMPTY
90038: LIST
90039: LIST
90040: PPUSH
90041: LD_VAR 0 5
90045: PUSH
90046: LD_VAR 0 1
90050: PPUSH
90051: CALL_OW 250
90055: PUSH
90056: LD_VAR 0 1
90060: PPUSH
90061: CALL_OW 251
90065: PUSH
90066: LD_VAR 0 1
90070: PPUSH
90071: CALL_OW 254
90075: PUSH
90076: EMPTY
90077: LIST
90078: LIST
90079: LIST
90080: LIST
90081: PPUSH
90082: CALL 24846 0 3
90086: ST_TO_ADDR
// if pos = 1 then
90087: LD_VAR 0 6
90091: PUSH
90092: LD_INT 1
90094: EQUAL
90095: IFFALSE 90210
// begin tmp := mc_build_list [ i ] ;
90097: LD_ADDR_VAR 0 7
90101: PUSH
90102: LD_EXP 36
90106: PUSH
90107: LD_VAR 0 3
90111: ARRAY
90112: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
90113: LD_VAR 0 7
90117: PPUSH
90118: LD_INT 2
90120: PUSH
90121: LD_INT 30
90123: PUSH
90124: LD_INT 0
90126: PUSH
90127: EMPTY
90128: LIST
90129: LIST
90130: PUSH
90131: LD_INT 30
90133: PUSH
90134: LD_INT 1
90136: PUSH
90137: EMPTY
90138: LIST
90139: LIST
90140: PUSH
90141: EMPTY
90142: LIST
90143: LIST
90144: LIST
90145: PPUSH
90146: CALL_OW 72
90150: IFFALSE 90160
// pos := 2 ;
90152: LD_ADDR_VAR 0 6
90156: PUSH
90157: LD_INT 2
90159: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
90160: LD_ADDR_VAR 0 7
90164: PUSH
90165: LD_VAR 0 7
90169: PPUSH
90170: LD_VAR 0 6
90174: PPUSH
90175: LD_VAR 0 7
90179: PPUSH
90180: CALL 25172 0 3
90184: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
90185: LD_ADDR_EXP 36
90189: PUSH
90190: LD_EXP 36
90194: PPUSH
90195: LD_VAR 0 3
90199: PPUSH
90200: LD_VAR 0 7
90204: PPUSH
90205: CALL_OW 1
90209: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
90210: LD_VAR 0 1
90214: PUSH
90215: LD_EXP 31
90219: PUSH
90220: LD_VAR 0 3
90224: ARRAY
90225: IN
90226: IFFALSE 90265
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
90228: LD_ADDR_EXP 31
90232: PUSH
90233: LD_EXP 31
90237: PPUSH
90238: LD_VAR 0 3
90242: PPUSH
90243: LD_EXP 31
90247: PUSH
90248: LD_VAR 0 3
90252: ARRAY
90253: PUSH
90254: LD_VAR 0 1
90258: DIFF
90259: PPUSH
90260: CALL_OW 1
90264: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
90265: LD_VAR 0 1
90269: PUSH
90270: LD_EXP 38
90274: PUSH
90275: LD_VAR 0 3
90279: ARRAY
90280: IN
90281: IFFALSE 90320
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
90283: LD_ADDR_EXP 38
90287: PUSH
90288: LD_EXP 38
90292: PPUSH
90293: LD_VAR 0 3
90297: PPUSH
90298: LD_EXP 38
90302: PUSH
90303: LD_VAR 0 3
90307: ARRAY
90308: PUSH
90309: LD_VAR 0 1
90313: DIFF
90314: PPUSH
90315: CALL_OW 1
90319: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
90320: LD_VAR 0 1
90324: PUSH
90325: LD_EXP 50
90329: PUSH
90330: LD_VAR 0 3
90334: ARRAY
90335: IN
90336: IFFALSE 90375
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
90338: LD_ADDR_EXP 50
90342: PUSH
90343: LD_EXP 50
90347: PPUSH
90348: LD_VAR 0 3
90352: PPUSH
90353: LD_EXP 50
90357: PUSH
90358: LD_VAR 0 3
90362: ARRAY
90363: PUSH
90364: LD_VAR 0 1
90368: DIFF
90369: PPUSH
90370: CALL_OW 1
90374: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
90375: LD_VAR 0 1
90379: PUSH
90380: LD_EXP 53
90384: PUSH
90385: LD_VAR 0 3
90389: ARRAY
90390: IN
90391: IFFALSE 90430
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
90393: LD_ADDR_EXP 53
90397: PUSH
90398: LD_EXP 53
90402: PPUSH
90403: LD_VAR 0 3
90407: PPUSH
90408: LD_EXP 53
90412: PUSH
90413: LD_VAR 0 3
90417: ARRAY
90418: PUSH
90419: LD_VAR 0 1
90423: DIFF
90424: PPUSH
90425: CALL_OW 1
90429: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
90430: LD_VAR 0 1
90434: PUSH
90435: LD_EXP 40
90439: PUSH
90440: LD_VAR 0 3
90444: ARRAY
90445: IN
90446: IFFALSE 90485
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
90448: LD_ADDR_EXP 40
90452: PUSH
90453: LD_EXP 40
90457: PPUSH
90458: LD_VAR 0 3
90462: PPUSH
90463: LD_EXP 40
90467: PUSH
90468: LD_VAR 0 3
90472: ARRAY
90473: PUSH
90474: LD_VAR 0 1
90478: DIFF
90479: PPUSH
90480: CALL_OW 1
90484: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
90485: LD_VAR 0 1
90489: PUSH
90490: LD_EXP 39
90494: PUSH
90495: LD_VAR 0 3
90499: ARRAY
90500: IN
90501: IFFALSE 90540
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
90503: LD_ADDR_EXP 39
90507: PUSH
90508: LD_EXP 39
90512: PPUSH
90513: LD_VAR 0 3
90517: PPUSH
90518: LD_EXP 39
90522: PUSH
90523: LD_VAR 0 3
90527: ARRAY
90528: PUSH
90529: LD_VAR 0 1
90533: DIFF
90534: PPUSH
90535: CALL_OW 1
90539: ST_TO_ADDR
// end ; break ;
90540: GO 90544
// end ;
90542: GO 89192
90544: POP
90545: POP
// end ;
90546: LD_VAR 0 2
90550: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
90551: LD_INT 0
90553: PPUSH
90554: PPUSH
90555: PPUSH
// if not mc_bases or not skirmish then
90556: LD_EXP 31
90560: NOT
90561: PUSH
90562: LD_EXP 29
90566: NOT
90567: OR
90568: IFFALSE 90572
// exit ;
90570: GO 90787
// for i = 1 to mc_bases do
90572: LD_ADDR_VAR 0 3
90576: PUSH
90577: DOUBLE
90578: LD_INT 1
90580: DEC
90581: ST_TO_ADDR
90582: LD_EXP 31
90586: PUSH
90587: FOR_TO
90588: IFFALSE 90785
// begin if building in mc_construct_list [ i ] then
90590: LD_VAR 0 1
90594: PUSH
90595: LD_EXP 38
90599: PUSH
90600: LD_VAR 0 3
90604: ARRAY
90605: IN
90606: IFFALSE 90783
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
90608: LD_ADDR_EXP 38
90612: PUSH
90613: LD_EXP 38
90617: PPUSH
90618: LD_VAR 0 3
90622: PPUSH
90623: LD_EXP 38
90627: PUSH
90628: LD_VAR 0 3
90632: ARRAY
90633: PUSH
90634: LD_VAR 0 1
90638: DIFF
90639: PPUSH
90640: CALL_OW 1
90644: ST_TO_ADDR
// if building in mc_lab [ i ] then
90645: LD_VAR 0 1
90649: PUSH
90650: LD_EXP 64
90654: PUSH
90655: LD_VAR 0 3
90659: ARRAY
90660: IN
90661: IFFALSE 90716
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
90663: LD_ADDR_EXP 65
90667: PUSH
90668: LD_EXP 65
90672: PPUSH
90673: LD_VAR 0 3
90677: PPUSH
90678: LD_EXP 65
90682: PUSH
90683: LD_VAR 0 3
90687: ARRAY
90688: PPUSH
90689: LD_INT 1
90691: PPUSH
90692: LD_EXP 65
90696: PUSH
90697: LD_VAR 0 3
90701: ARRAY
90702: PPUSH
90703: LD_INT 0
90705: PPUSH
90706: CALL 24264 0 4
90710: PPUSH
90711: CALL_OW 1
90715: ST_TO_ADDR
// if not building in mc_bases [ i ] then
90716: LD_VAR 0 1
90720: PUSH
90721: LD_EXP 31
90725: PUSH
90726: LD_VAR 0 3
90730: ARRAY
90731: IN
90732: NOT
90733: IFFALSE 90779
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
90735: LD_ADDR_EXP 31
90739: PUSH
90740: LD_EXP 31
90744: PPUSH
90745: LD_VAR 0 3
90749: PUSH
90750: LD_EXP 31
90754: PUSH
90755: LD_VAR 0 3
90759: ARRAY
90760: PUSH
90761: LD_INT 1
90763: PLUS
90764: PUSH
90765: EMPTY
90766: LIST
90767: LIST
90768: PPUSH
90769: LD_VAR 0 1
90773: PPUSH
90774: CALL 24846 0 3
90778: ST_TO_ADDR
// exit ;
90779: POP
90780: POP
90781: GO 90787
// end ; end ;
90783: GO 90587
90785: POP
90786: POP
// end ;
90787: LD_VAR 0 2
90791: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
90792: LD_INT 0
90794: PPUSH
90795: PPUSH
90796: PPUSH
90797: PPUSH
90798: PPUSH
90799: PPUSH
90800: PPUSH
// if not mc_bases or not skirmish then
90801: LD_EXP 31
90805: NOT
90806: PUSH
90807: LD_EXP 29
90811: NOT
90812: OR
90813: IFFALSE 90817
// exit ;
90815: GO 91478
// for i = 1 to mc_bases do
90817: LD_ADDR_VAR 0 3
90821: PUSH
90822: DOUBLE
90823: LD_INT 1
90825: DEC
90826: ST_TO_ADDR
90827: LD_EXP 31
90831: PUSH
90832: FOR_TO
90833: IFFALSE 91476
// begin if building in mc_construct_list [ i ] then
90835: LD_VAR 0 1
90839: PUSH
90840: LD_EXP 38
90844: PUSH
90845: LD_VAR 0 3
90849: ARRAY
90850: IN
90851: IFFALSE 91474
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
90853: LD_ADDR_EXP 38
90857: PUSH
90858: LD_EXP 38
90862: PPUSH
90863: LD_VAR 0 3
90867: PPUSH
90868: LD_EXP 38
90872: PUSH
90873: LD_VAR 0 3
90877: ARRAY
90878: PUSH
90879: LD_VAR 0 1
90883: DIFF
90884: PPUSH
90885: CALL_OW 1
90889: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
90890: LD_ADDR_EXP 31
90894: PUSH
90895: LD_EXP 31
90899: PPUSH
90900: LD_VAR 0 3
90904: PUSH
90905: LD_EXP 31
90909: PUSH
90910: LD_VAR 0 3
90914: ARRAY
90915: PUSH
90916: LD_INT 1
90918: PLUS
90919: PUSH
90920: EMPTY
90921: LIST
90922: LIST
90923: PPUSH
90924: LD_VAR 0 1
90928: PPUSH
90929: CALL 24846 0 3
90933: ST_TO_ADDR
// btype := GetBType ( building ) ;
90934: LD_ADDR_VAR 0 5
90938: PUSH
90939: LD_VAR 0 1
90943: PPUSH
90944: CALL_OW 266
90948: ST_TO_ADDR
// side := GetSide ( building ) ;
90949: LD_ADDR_VAR 0 8
90953: PUSH
90954: LD_VAR 0 1
90958: PPUSH
90959: CALL_OW 255
90963: ST_TO_ADDR
// if btype = b_lab then
90964: LD_VAR 0 5
90968: PUSH
90969: LD_INT 6
90971: EQUAL
90972: IFFALSE 91022
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
90974: LD_ADDR_EXP 64
90978: PUSH
90979: LD_EXP 64
90983: PPUSH
90984: LD_VAR 0 3
90988: PUSH
90989: LD_EXP 64
90993: PUSH
90994: LD_VAR 0 3
90998: ARRAY
90999: PUSH
91000: LD_INT 1
91002: PLUS
91003: PUSH
91004: EMPTY
91005: LIST
91006: LIST
91007: PPUSH
91008: LD_VAR 0 1
91012: PPUSH
91013: CALL 24846 0 3
91017: ST_TO_ADDR
// exit ;
91018: POP
91019: POP
91020: GO 91478
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
91022: LD_VAR 0 5
91026: PUSH
91027: LD_INT 0
91029: PUSH
91030: LD_INT 2
91032: PUSH
91033: LD_INT 4
91035: PUSH
91036: EMPTY
91037: LIST
91038: LIST
91039: LIST
91040: IN
91041: IFFALSE 91165
// begin if btype = b_armoury then
91043: LD_VAR 0 5
91047: PUSH
91048: LD_INT 4
91050: EQUAL
91051: IFFALSE 91061
// btype := b_barracks ;
91053: LD_ADDR_VAR 0 5
91057: PUSH
91058: LD_INT 5
91060: ST_TO_ADDR
// if btype = b_depot then
91061: LD_VAR 0 5
91065: PUSH
91066: LD_INT 0
91068: EQUAL
91069: IFFALSE 91079
// btype := b_warehouse ;
91071: LD_ADDR_VAR 0 5
91075: PUSH
91076: LD_INT 1
91078: ST_TO_ADDR
// if btype = b_workshop then
91079: LD_VAR 0 5
91083: PUSH
91084: LD_INT 2
91086: EQUAL
91087: IFFALSE 91097
// btype := b_factory ;
91089: LD_ADDR_VAR 0 5
91093: PUSH
91094: LD_INT 3
91096: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
91097: LD_VAR 0 5
91101: PPUSH
91102: LD_VAR 0 8
91106: PPUSH
91107: CALL_OW 323
91111: PUSH
91112: LD_INT 1
91114: EQUAL
91115: IFFALSE 91161
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
91117: LD_ADDR_EXP 63
91121: PUSH
91122: LD_EXP 63
91126: PPUSH
91127: LD_VAR 0 3
91131: PUSH
91132: LD_EXP 63
91136: PUSH
91137: LD_VAR 0 3
91141: ARRAY
91142: PUSH
91143: LD_INT 1
91145: PLUS
91146: PUSH
91147: EMPTY
91148: LIST
91149: LIST
91150: PPUSH
91151: LD_VAR 0 1
91155: PPUSH
91156: CALL 24846 0 3
91160: ST_TO_ADDR
// exit ;
91161: POP
91162: POP
91163: GO 91478
// end ; if btype in [ b_bunker , b_turret ] then
91165: LD_VAR 0 5
91169: PUSH
91170: LD_INT 32
91172: PUSH
91173: LD_INT 33
91175: PUSH
91176: EMPTY
91177: LIST
91178: LIST
91179: IN
91180: IFFALSE 91470
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
91182: LD_ADDR_EXP 39
91186: PUSH
91187: LD_EXP 39
91191: PPUSH
91192: LD_VAR 0 3
91196: PUSH
91197: LD_EXP 39
91201: PUSH
91202: LD_VAR 0 3
91206: ARRAY
91207: PUSH
91208: LD_INT 1
91210: PLUS
91211: PUSH
91212: EMPTY
91213: LIST
91214: LIST
91215: PPUSH
91216: LD_VAR 0 1
91220: PPUSH
91221: CALL 24846 0 3
91225: ST_TO_ADDR
// if btype = b_bunker then
91226: LD_VAR 0 5
91230: PUSH
91231: LD_INT 32
91233: EQUAL
91234: IFFALSE 91470
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
91236: LD_ADDR_EXP 40
91240: PUSH
91241: LD_EXP 40
91245: PPUSH
91246: LD_VAR 0 3
91250: PUSH
91251: LD_EXP 40
91255: PUSH
91256: LD_VAR 0 3
91260: ARRAY
91261: PUSH
91262: LD_INT 1
91264: PLUS
91265: PUSH
91266: EMPTY
91267: LIST
91268: LIST
91269: PPUSH
91270: LD_VAR 0 1
91274: PPUSH
91275: CALL 24846 0 3
91279: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
91280: LD_ADDR_VAR 0 6
91284: PUSH
91285: LD_EXP 31
91289: PUSH
91290: LD_VAR 0 3
91294: ARRAY
91295: PPUSH
91296: LD_INT 25
91298: PUSH
91299: LD_INT 1
91301: PUSH
91302: EMPTY
91303: LIST
91304: LIST
91305: PUSH
91306: LD_INT 3
91308: PUSH
91309: LD_INT 54
91311: PUSH
91312: EMPTY
91313: LIST
91314: PUSH
91315: EMPTY
91316: LIST
91317: LIST
91318: PUSH
91319: EMPTY
91320: LIST
91321: LIST
91322: PPUSH
91323: CALL_OW 72
91327: ST_TO_ADDR
// if tmp then
91328: LD_VAR 0 6
91332: IFFALSE 91338
// exit ;
91334: POP
91335: POP
91336: GO 91478
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
91338: LD_ADDR_VAR 0 6
91342: PUSH
91343: LD_EXP 31
91347: PUSH
91348: LD_VAR 0 3
91352: ARRAY
91353: PPUSH
91354: LD_INT 2
91356: PUSH
91357: LD_INT 30
91359: PUSH
91360: LD_INT 4
91362: PUSH
91363: EMPTY
91364: LIST
91365: LIST
91366: PUSH
91367: LD_INT 30
91369: PUSH
91370: LD_INT 5
91372: PUSH
91373: EMPTY
91374: LIST
91375: LIST
91376: PUSH
91377: EMPTY
91378: LIST
91379: LIST
91380: LIST
91381: PPUSH
91382: CALL_OW 72
91386: ST_TO_ADDR
// if not tmp then
91387: LD_VAR 0 6
91391: NOT
91392: IFFALSE 91398
// exit ;
91394: POP
91395: POP
91396: GO 91478
// for j in tmp do
91398: LD_ADDR_VAR 0 4
91402: PUSH
91403: LD_VAR 0 6
91407: PUSH
91408: FOR_IN
91409: IFFALSE 91468
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
91411: LD_ADDR_VAR 0 7
91415: PUSH
91416: LD_VAR 0 4
91420: PPUSH
91421: CALL_OW 313
91425: PPUSH
91426: LD_INT 25
91428: PUSH
91429: LD_INT 1
91431: PUSH
91432: EMPTY
91433: LIST
91434: LIST
91435: PPUSH
91436: CALL_OW 72
91440: ST_TO_ADDR
// if units then
91441: LD_VAR 0 7
91445: IFFALSE 91466
// begin ComExitBuilding ( units [ 1 ] ) ;
91447: LD_VAR 0 7
91451: PUSH
91452: LD_INT 1
91454: ARRAY
91455: PPUSH
91456: CALL_OW 122
// exit ;
91460: POP
91461: POP
91462: POP
91463: POP
91464: GO 91478
// end ; end ;
91466: GO 91408
91468: POP
91469: POP
// end ; end ; exit ;
91470: POP
91471: POP
91472: GO 91478
// end ; end ;
91474: GO 90832
91476: POP
91477: POP
// end ;
91478: LD_VAR 0 2
91482: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
91483: LD_INT 0
91485: PPUSH
91486: PPUSH
91487: PPUSH
91488: PPUSH
91489: PPUSH
91490: PPUSH
91491: PPUSH
// if not mc_bases or not skirmish then
91492: LD_EXP 31
91496: NOT
91497: PUSH
91498: LD_EXP 29
91502: NOT
91503: OR
91504: IFFALSE 91508
// exit ;
91506: GO 91773
// btype := GetBType ( building ) ;
91508: LD_ADDR_VAR 0 6
91512: PUSH
91513: LD_VAR 0 1
91517: PPUSH
91518: CALL_OW 266
91522: ST_TO_ADDR
// x := GetX ( building ) ;
91523: LD_ADDR_VAR 0 7
91527: PUSH
91528: LD_VAR 0 1
91532: PPUSH
91533: CALL_OW 250
91537: ST_TO_ADDR
// y := GetY ( building ) ;
91538: LD_ADDR_VAR 0 8
91542: PUSH
91543: LD_VAR 0 1
91547: PPUSH
91548: CALL_OW 251
91552: ST_TO_ADDR
// d := GetDir ( building ) ;
91553: LD_ADDR_VAR 0 9
91557: PUSH
91558: LD_VAR 0 1
91562: PPUSH
91563: CALL_OW 254
91567: ST_TO_ADDR
// for i = 1 to mc_bases do
91568: LD_ADDR_VAR 0 4
91572: PUSH
91573: DOUBLE
91574: LD_INT 1
91576: DEC
91577: ST_TO_ADDR
91578: LD_EXP 31
91582: PUSH
91583: FOR_TO
91584: IFFALSE 91771
// begin if not mc_build_list [ i ] then
91586: LD_EXP 36
91590: PUSH
91591: LD_VAR 0 4
91595: ARRAY
91596: NOT
91597: IFFALSE 91601
// continue ;
91599: GO 91583
// for j := 1 to mc_build_list [ i ] do
91601: LD_ADDR_VAR 0 5
91605: PUSH
91606: DOUBLE
91607: LD_INT 1
91609: DEC
91610: ST_TO_ADDR
91611: LD_EXP 36
91615: PUSH
91616: LD_VAR 0 4
91620: ARRAY
91621: PUSH
91622: FOR_TO
91623: IFFALSE 91767
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ j ] ) then
91625: LD_VAR 0 6
91629: PUSH
91630: LD_VAR 0 7
91634: PUSH
91635: LD_VAR 0 8
91639: PUSH
91640: LD_VAR 0 9
91644: PUSH
91645: EMPTY
91646: LIST
91647: LIST
91648: LIST
91649: LIST
91650: PPUSH
91651: LD_EXP 36
91655: PUSH
91656: LD_VAR 0 4
91660: ARRAY
91661: PUSH
91662: LD_VAR 0 5
91666: ARRAY
91667: PPUSH
91668: CALL 31035 0 2
91672: IFFALSE 91765
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , j ) ) ;
91674: LD_ADDR_EXP 36
91678: PUSH
91679: LD_EXP 36
91683: PPUSH
91684: LD_VAR 0 4
91688: PPUSH
91689: LD_EXP 36
91693: PUSH
91694: LD_VAR 0 4
91698: ARRAY
91699: PPUSH
91700: LD_VAR 0 5
91704: PPUSH
91705: CALL_OW 3
91709: PPUSH
91710: CALL_OW 1
91714: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
91715: LD_ADDR_EXP 38
91719: PUSH
91720: LD_EXP 38
91724: PPUSH
91725: LD_VAR 0 4
91729: PUSH
91730: LD_EXP 38
91734: PUSH
91735: LD_VAR 0 4
91739: ARRAY
91740: PUSH
91741: LD_INT 1
91743: PLUS
91744: PUSH
91745: EMPTY
91746: LIST
91747: LIST
91748: PPUSH
91749: LD_VAR 0 1
91753: PPUSH
91754: CALL 24846 0 3
91758: ST_TO_ADDR
// exit ;
91759: POP
91760: POP
91761: POP
91762: POP
91763: GO 91773
// end ;
91765: GO 91622
91767: POP
91768: POP
// end ;
91769: GO 91583
91771: POP
91772: POP
// end ;
91773: LD_VAR 0 3
91777: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
91778: LD_INT 0
91780: PPUSH
91781: PPUSH
91782: PPUSH
// if not mc_bases or not skirmish then
91783: LD_EXP 31
91787: NOT
91788: PUSH
91789: LD_EXP 29
91793: NOT
91794: OR
91795: IFFALSE 91799
// exit ;
91797: GO 91989
// for i = 1 to mc_bases do
91799: LD_ADDR_VAR 0 4
91803: PUSH
91804: DOUBLE
91805: LD_INT 1
91807: DEC
91808: ST_TO_ADDR
91809: LD_EXP 31
91813: PUSH
91814: FOR_TO
91815: IFFALSE 91902
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
91817: LD_VAR 0 1
91821: PUSH
91822: LD_EXP 39
91826: PUSH
91827: LD_VAR 0 4
91831: ARRAY
91832: IN
91833: PUSH
91834: LD_VAR 0 1
91838: PUSH
91839: LD_EXP 40
91843: PUSH
91844: LD_VAR 0 4
91848: ARRAY
91849: IN
91850: NOT
91851: AND
91852: IFFALSE 91900
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
91854: LD_ADDR_EXP 40
91858: PUSH
91859: LD_EXP 40
91863: PPUSH
91864: LD_VAR 0 4
91868: PUSH
91869: LD_EXP 40
91873: PUSH
91874: LD_VAR 0 4
91878: ARRAY
91879: PUSH
91880: LD_INT 1
91882: PLUS
91883: PUSH
91884: EMPTY
91885: LIST
91886: LIST
91887: PPUSH
91888: LD_VAR 0 1
91892: PPUSH
91893: CALL 24846 0 3
91897: ST_TO_ADDR
// break ;
91898: GO 91902
// end ; end ;
91900: GO 91814
91902: POP
91903: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
91904: LD_VAR 0 1
91908: PPUSH
91909: CALL_OW 257
91913: PUSH
91914: LD_EXP 57
91918: IN
91919: PUSH
91920: LD_VAR 0 1
91924: PPUSH
91925: CALL_OW 266
91929: PUSH
91930: LD_INT 5
91932: EQUAL
91933: AND
91934: PUSH
91935: LD_VAR 0 2
91939: PPUSH
91940: CALL_OW 110
91944: PUSH
91945: LD_INT 18
91947: NONEQUAL
91948: AND
91949: IFFALSE 91989
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
91951: LD_VAR 0 2
91955: PPUSH
91956: CALL_OW 257
91960: PUSH
91961: LD_INT 5
91963: PUSH
91964: LD_INT 8
91966: PUSH
91967: LD_INT 9
91969: PUSH
91970: EMPTY
91971: LIST
91972: LIST
91973: LIST
91974: IN
91975: IFFALSE 91989
// SetClass ( unit , 1 ) ;
91977: LD_VAR 0 2
91981: PPUSH
91982: LD_INT 1
91984: PPUSH
91985: CALL_OW 336
// end ;
91989: LD_VAR 0 3
91993: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
91994: LD_INT 0
91996: PPUSH
91997: PPUSH
// if not mc_bases or not skirmish then
91998: LD_EXP 31
92002: NOT
92003: PUSH
92004: LD_EXP 29
92008: NOT
92009: OR
92010: IFFALSE 92014
// exit ;
92012: GO 92130
// if GetLives ( abandoned_vehicle ) > 250 then
92014: LD_VAR 0 2
92018: PPUSH
92019: CALL_OW 256
92023: PUSH
92024: LD_INT 250
92026: GREATER
92027: IFFALSE 92031
// exit ;
92029: GO 92130
// for i = 1 to mc_bases do
92031: LD_ADDR_VAR 0 6
92035: PUSH
92036: DOUBLE
92037: LD_INT 1
92039: DEC
92040: ST_TO_ADDR
92041: LD_EXP 31
92045: PUSH
92046: FOR_TO
92047: IFFALSE 92128
// begin if driver in mc_bases [ i ] then
92049: LD_VAR 0 1
92053: PUSH
92054: LD_EXP 31
92058: PUSH
92059: LD_VAR 0 6
92063: ARRAY
92064: IN
92065: IFFALSE 92126
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
92067: LD_VAR 0 1
92071: PPUSH
92072: LD_EXP 31
92076: PUSH
92077: LD_VAR 0 6
92081: ARRAY
92082: PPUSH
92083: LD_INT 2
92085: PUSH
92086: LD_INT 30
92088: PUSH
92089: LD_INT 0
92091: PUSH
92092: EMPTY
92093: LIST
92094: LIST
92095: PUSH
92096: LD_INT 30
92098: PUSH
92099: LD_INT 1
92101: PUSH
92102: EMPTY
92103: LIST
92104: LIST
92105: PUSH
92106: EMPTY
92107: LIST
92108: LIST
92109: LIST
92110: PPUSH
92111: CALL_OW 72
92115: PUSH
92116: LD_INT 1
92118: ARRAY
92119: PPUSH
92120: CALL 58082 0 2
// break ;
92124: GO 92128
// end ; end ;
92126: GO 92046
92128: POP
92129: POP
// end ; end_of_file end_of_file
92130: LD_VAR 0 5
92134: RET
// export globalGameSaveCounter ; every 0 0$1 do
92135: GO 92137
92137: DISABLE
// begin enable ;
92138: ENABLE
// ToLua ( updateTimer( & tick & ); ) ;
92139: LD_STRING updateTimer(
92141: PUSH
92142: LD_OWVAR 1
92146: STR
92147: PUSH
92148: LD_STRING );
92150: STR
92151: PPUSH
92152: CALL_OW 559
// end ;
92156: END
// every 0 0$1 do
92157: GO 92159
92159: DISABLE
// begin globalGameSaveCounter := 0 ;
92160: LD_ADDR_EXP 76
92164: PUSH
92165: LD_INT 0
92167: ST_TO_ADDR
// ToLua ( setGameSaveCounter(0) ) ;
92168: LD_STRING setGameSaveCounter(0)
92170: PPUSH
92171: CALL_OW 559
// ToLua ( initStreamRollete(); ) ;
92175: LD_STRING initStreamRollete();
92177: PPUSH
92178: CALL_OW 559
// InitStreamMode ;
92182: CALL 93508 0 0
// DefineStreamItems ( false ) ;
92186: LD_INT 0
92188: PPUSH
92189: CALL 93972 0 1
// end ;
92193: END
// export function SOS_MapStart ( ) ; begin
92194: LD_INT 0
92196: PPUSH
// if streamModeActive then
92197: LD_EXP 77
92201: IFFALSE 92210
// DefineStreamItems ( true ) ;
92203: LD_INT 1
92205: PPUSH
92206: CALL 93972 0 1
// UpdateLuaVariables ( ) ;
92210: CALL 92227 0 0
// UpdateFactoryWaypoints ( ) ;
92214: CALL 106841 0 0
// UpdateWarehouseGatheringPoints ( ) ;
92218: CALL 107098 0 0
// end ;
92222: LD_VAR 0 1
92226: RET
// function UpdateLuaVariables ( ) ; begin
92227: LD_INT 0
92229: PPUSH
// if globalGameSaveCounter then
92230: LD_EXP 76
92234: IFFALSE 92268
// begin globalGameSaveCounter := Inc ( globalGameSaveCounter ) ;
92236: LD_ADDR_EXP 76
92240: PUSH
92241: LD_EXP 76
92245: PPUSH
92246: CALL 58566 0 1
92250: ST_TO_ADDR
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
92251: LD_STRING setGameSaveCounter(
92253: PUSH
92254: LD_EXP 76
92258: STR
92259: PUSH
92260: LD_STRING )
92262: STR
92263: PPUSH
92264: CALL_OW 559
// end ; ToLua ( setGameDifficulty( & Difficulty & ) ) ;
92268: LD_STRING setGameDifficulty(
92270: PUSH
92271: LD_OWVAR 67
92275: STR
92276: PUSH
92277: LD_STRING )
92279: STR
92280: PPUSH
92281: CALL_OW 559
// end ;
92285: LD_VAR 0 1
92289: RET
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
92290: LD_INT 0
92292: PPUSH
// if p2 = stream_mode then
92293: LD_VAR 0 2
92297: PUSH
92298: LD_INT 100
92300: EQUAL
92301: IFFALSE 93304
// begin if not StreamModeActive then
92303: LD_EXP 77
92307: NOT
92308: IFFALSE 92318
// StreamModeActive := true ;
92310: LD_ADDR_EXP 77
92314: PUSH
92315: LD_INT 1
92317: ST_TO_ADDR
// if p3 = 0 then
92318: LD_VAR 0 3
92322: PUSH
92323: LD_INT 0
92325: EQUAL
92326: IFFALSE 92332
// InitStreamMode ;
92328: CALL 93508 0 0
// if p3 = 1 then
92332: LD_VAR 0 3
92336: PUSH
92337: LD_INT 1
92339: EQUAL
92340: IFFALSE 92350
// sRocket := true ;
92342: LD_ADDR_EXP 82
92346: PUSH
92347: LD_INT 1
92349: ST_TO_ADDR
// if p3 = 2 then
92350: LD_VAR 0 3
92354: PUSH
92355: LD_INT 2
92357: EQUAL
92358: IFFALSE 92368
// sSpeed := true ;
92360: LD_ADDR_EXP 81
92364: PUSH
92365: LD_INT 1
92367: ST_TO_ADDR
// if p3 = 3 then
92368: LD_VAR 0 3
92372: PUSH
92373: LD_INT 3
92375: EQUAL
92376: IFFALSE 92386
// sEngine := true ;
92378: LD_ADDR_EXP 83
92382: PUSH
92383: LD_INT 1
92385: ST_TO_ADDR
// if p3 = 4 then
92386: LD_VAR 0 3
92390: PUSH
92391: LD_INT 4
92393: EQUAL
92394: IFFALSE 92404
// sSpec := true ;
92396: LD_ADDR_EXP 80
92400: PUSH
92401: LD_INT 1
92403: ST_TO_ADDR
// if p3 = 5 then
92404: LD_VAR 0 3
92408: PUSH
92409: LD_INT 5
92411: EQUAL
92412: IFFALSE 92422
// sLevel := true ;
92414: LD_ADDR_EXP 84
92418: PUSH
92419: LD_INT 1
92421: ST_TO_ADDR
// if p3 = 6 then
92422: LD_VAR 0 3
92426: PUSH
92427: LD_INT 6
92429: EQUAL
92430: IFFALSE 92440
// sArmoury := true ;
92432: LD_ADDR_EXP 85
92436: PUSH
92437: LD_INT 1
92439: ST_TO_ADDR
// if p3 = 7 then
92440: LD_VAR 0 3
92444: PUSH
92445: LD_INT 7
92447: EQUAL
92448: IFFALSE 92458
// sRadar := true ;
92450: LD_ADDR_EXP 86
92454: PUSH
92455: LD_INT 1
92457: ST_TO_ADDR
// if p3 = 8 then
92458: LD_VAR 0 3
92462: PUSH
92463: LD_INT 8
92465: EQUAL
92466: IFFALSE 92476
// sBunker := true ;
92468: LD_ADDR_EXP 87
92472: PUSH
92473: LD_INT 1
92475: ST_TO_ADDR
// if p3 = 9 then
92476: LD_VAR 0 3
92480: PUSH
92481: LD_INT 9
92483: EQUAL
92484: IFFALSE 92494
// sHack := true ;
92486: LD_ADDR_EXP 88
92490: PUSH
92491: LD_INT 1
92493: ST_TO_ADDR
// if p3 = 10 then
92494: LD_VAR 0 3
92498: PUSH
92499: LD_INT 10
92501: EQUAL
92502: IFFALSE 92512
// sFire := true ;
92504: LD_ADDR_EXP 89
92508: PUSH
92509: LD_INT 1
92511: ST_TO_ADDR
// if p3 = 11 then
92512: LD_VAR 0 3
92516: PUSH
92517: LD_INT 11
92519: EQUAL
92520: IFFALSE 92530
// sRefresh := true ;
92522: LD_ADDR_EXP 90
92526: PUSH
92527: LD_INT 1
92529: ST_TO_ADDR
// if p3 = 12 then
92530: LD_VAR 0 3
92534: PUSH
92535: LD_INT 12
92537: EQUAL
92538: IFFALSE 92548
// sExp := true ;
92540: LD_ADDR_EXP 91
92544: PUSH
92545: LD_INT 1
92547: ST_TO_ADDR
// if p3 = 13 then
92548: LD_VAR 0 3
92552: PUSH
92553: LD_INT 13
92555: EQUAL
92556: IFFALSE 92566
// sDepot := true ;
92558: LD_ADDR_EXP 92
92562: PUSH
92563: LD_INT 1
92565: ST_TO_ADDR
// if p3 = 14 then
92566: LD_VAR 0 3
92570: PUSH
92571: LD_INT 14
92573: EQUAL
92574: IFFALSE 92584
// sFlag := true ;
92576: LD_ADDR_EXP 93
92580: PUSH
92581: LD_INT 1
92583: ST_TO_ADDR
// if p3 = 15 then
92584: LD_VAR 0 3
92588: PUSH
92589: LD_INT 15
92591: EQUAL
92592: IFFALSE 92602
// sKamikadze := true ;
92594: LD_ADDR_EXP 101
92598: PUSH
92599: LD_INT 1
92601: ST_TO_ADDR
// if p3 = 16 then
92602: LD_VAR 0 3
92606: PUSH
92607: LD_INT 16
92609: EQUAL
92610: IFFALSE 92620
// sTroll := true ;
92612: LD_ADDR_EXP 102
92616: PUSH
92617: LD_INT 1
92619: ST_TO_ADDR
// if p3 = 17 then
92620: LD_VAR 0 3
92624: PUSH
92625: LD_INT 17
92627: EQUAL
92628: IFFALSE 92638
// sSlow := true ;
92630: LD_ADDR_EXP 103
92634: PUSH
92635: LD_INT 1
92637: ST_TO_ADDR
// if p3 = 18 then
92638: LD_VAR 0 3
92642: PUSH
92643: LD_INT 18
92645: EQUAL
92646: IFFALSE 92656
// sLack := true ;
92648: LD_ADDR_EXP 104
92652: PUSH
92653: LD_INT 1
92655: ST_TO_ADDR
// if p3 = 19 then
92656: LD_VAR 0 3
92660: PUSH
92661: LD_INT 19
92663: EQUAL
92664: IFFALSE 92674
// sTank := true ;
92666: LD_ADDR_EXP 106
92670: PUSH
92671: LD_INT 1
92673: ST_TO_ADDR
// if p3 = 20 then
92674: LD_VAR 0 3
92678: PUSH
92679: LD_INT 20
92681: EQUAL
92682: IFFALSE 92692
// sRemote := true ;
92684: LD_ADDR_EXP 107
92688: PUSH
92689: LD_INT 1
92691: ST_TO_ADDR
// if p3 = 21 then
92692: LD_VAR 0 3
92696: PUSH
92697: LD_INT 21
92699: EQUAL
92700: IFFALSE 92710
// sPowell := true ;
92702: LD_ADDR_EXP 108
92706: PUSH
92707: LD_INT 1
92709: ST_TO_ADDR
// if p3 = 22 then
92710: LD_VAR 0 3
92714: PUSH
92715: LD_INT 22
92717: EQUAL
92718: IFFALSE 92728
// sTeleport := true ;
92720: LD_ADDR_EXP 111
92724: PUSH
92725: LD_INT 1
92727: ST_TO_ADDR
// if p3 = 23 then
92728: LD_VAR 0 3
92732: PUSH
92733: LD_INT 23
92735: EQUAL
92736: IFFALSE 92746
// sOilTower := true ;
92738: LD_ADDR_EXP 113
92742: PUSH
92743: LD_INT 1
92745: ST_TO_ADDR
// if p3 = 24 then
92746: LD_VAR 0 3
92750: PUSH
92751: LD_INT 24
92753: EQUAL
92754: IFFALSE 92764
// sShovel := true ;
92756: LD_ADDR_EXP 114
92760: PUSH
92761: LD_INT 1
92763: ST_TO_ADDR
// if p3 = 25 then
92764: LD_VAR 0 3
92768: PUSH
92769: LD_INT 25
92771: EQUAL
92772: IFFALSE 92782
// sSheik := true ;
92774: LD_ADDR_EXP 115
92778: PUSH
92779: LD_INT 1
92781: ST_TO_ADDR
// if p3 = 26 then
92782: LD_VAR 0 3
92786: PUSH
92787: LD_INT 26
92789: EQUAL
92790: IFFALSE 92800
// sEarthquake := true ;
92792: LD_ADDR_EXP 117
92796: PUSH
92797: LD_INT 1
92799: ST_TO_ADDR
// if p3 = 27 then
92800: LD_VAR 0 3
92804: PUSH
92805: LD_INT 27
92807: EQUAL
92808: IFFALSE 92818
// sAI := true ;
92810: LD_ADDR_EXP 118
92814: PUSH
92815: LD_INT 1
92817: ST_TO_ADDR
// if p3 = 28 then
92818: LD_VAR 0 3
92822: PUSH
92823: LD_INT 28
92825: EQUAL
92826: IFFALSE 92836
// sCargo := true ;
92828: LD_ADDR_EXP 121
92832: PUSH
92833: LD_INT 1
92835: ST_TO_ADDR
// if p3 = 29 then
92836: LD_VAR 0 3
92840: PUSH
92841: LD_INT 29
92843: EQUAL
92844: IFFALSE 92854
// sDLaser := true ;
92846: LD_ADDR_EXP 122
92850: PUSH
92851: LD_INT 1
92853: ST_TO_ADDR
// if p3 = 30 then
92854: LD_VAR 0 3
92858: PUSH
92859: LD_INT 30
92861: EQUAL
92862: IFFALSE 92872
// sExchange := true ;
92864: LD_ADDR_EXP 123
92868: PUSH
92869: LD_INT 1
92871: ST_TO_ADDR
// if p3 = 31 then
92872: LD_VAR 0 3
92876: PUSH
92877: LD_INT 31
92879: EQUAL
92880: IFFALSE 92890
// sFac := true ;
92882: LD_ADDR_EXP 124
92886: PUSH
92887: LD_INT 1
92889: ST_TO_ADDR
// if p3 = 32 then
92890: LD_VAR 0 3
92894: PUSH
92895: LD_INT 32
92897: EQUAL
92898: IFFALSE 92908
// sPower := true ;
92900: LD_ADDR_EXP 125
92904: PUSH
92905: LD_INT 1
92907: ST_TO_ADDR
// if p3 = 33 then
92908: LD_VAR 0 3
92912: PUSH
92913: LD_INT 33
92915: EQUAL
92916: IFFALSE 92926
// sRandom := true ;
92918: LD_ADDR_EXP 126
92922: PUSH
92923: LD_INT 1
92925: ST_TO_ADDR
// if p3 = 34 then
92926: LD_VAR 0 3
92930: PUSH
92931: LD_INT 34
92933: EQUAL
92934: IFFALSE 92944
// sShield := true ;
92936: LD_ADDR_EXP 127
92940: PUSH
92941: LD_INT 1
92943: ST_TO_ADDR
// if p3 = 35 then
92944: LD_VAR 0 3
92948: PUSH
92949: LD_INT 35
92951: EQUAL
92952: IFFALSE 92962
// sTime := true ;
92954: LD_ADDR_EXP 128
92958: PUSH
92959: LD_INT 1
92961: ST_TO_ADDR
// if p3 = 36 then
92962: LD_VAR 0 3
92966: PUSH
92967: LD_INT 36
92969: EQUAL
92970: IFFALSE 92980
// sTools := true ;
92972: LD_ADDR_EXP 129
92976: PUSH
92977: LD_INT 1
92979: ST_TO_ADDR
// if p3 = 101 then
92980: LD_VAR 0 3
92984: PUSH
92985: LD_INT 101
92987: EQUAL
92988: IFFALSE 92998
// sSold := true ;
92990: LD_ADDR_EXP 94
92994: PUSH
92995: LD_INT 1
92997: ST_TO_ADDR
// if p3 = 102 then
92998: LD_VAR 0 3
93002: PUSH
93003: LD_INT 102
93005: EQUAL
93006: IFFALSE 93016
// sDiff := true ;
93008: LD_ADDR_EXP 95
93012: PUSH
93013: LD_INT 1
93015: ST_TO_ADDR
// if p3 = 103 then
93016: LD_VAR 0 3
93020: PUSH
93021: LD_INT 103
93023: EQUAL
93024: IFFALSE 93034
// sFog := true ;
93026: LD_ADDR_EXP 98
93030: PUSH
93031: LD_INT 1
93033: ST_TO_ADDR
// if p3 = 104 then
93034: LD_VAR 0 3
93038: PUSH
93039: LD_INT 104
93041: EQUAL
93042: IFFALSE 93052
// sReset := true ;
93044: LD_ADDR_EXP 99
93048: PUSH
93049: LD_INT 1
93051: ST_TO_ADDR
// if p3 = 105 then
93052: LD_VAR 0 3
93056: PUSH
93057: LD_INT 105
93059: EQUAL
93060: IFFALSE 93070
// sSun := true ;
93062: LD_ADDR_EXP 100
93066: PUSH
93067: LD_INT 1
93069: ST_TO_ADDR
// if p3 = 106 then
93070: LD_VAR 0 3
93074: PUSH
93075: LD_INT 106
93077: EQUAL
93078: IFFALSE 93088
// sTiger := true ;
93080: LD_ADDR_EXP 96
93084: PUSH
93085: LD_INT 1
93087: ST_TO_ADDR
// if p3 = 107 then
93088: LD_VAR 0 3
93092: PUSH
93093: LD_INT 107
93095: EQUAL
93096: IFFALSE 93106
// sBomb := true ;
93098: LD_ADDR_EXP 97
93102: PUSH
93103: LD_INT 1
93105: ST_TO_ADDR
// if p3 = 108 then
93106: LD_VAR 0 3
93110: PUSH
93111: LD_INT 108
93113: EQUAL
93114: IFFALSE 93124
// sWound := true ;
93116: LD_ADDR_EXP 105
93120: PUSH
93121: LD_INT 1
93123: ST_TO_ADDR
// if p3 = 109 then
93124: LD_VAR 0 3
93128: PUSH
93129: LD_INT 109
93131: EQUAL
93132: IFFALSE 93142
// sBetray := true ;
93134: LD_ADDR_EXP 109
93138: PUSH
93139: LD_INT 1
93141: ST_TO_ADDR
// if p3 = 110 then
93142: LD_VAR 0 3
93146: PUSH
93147: LD_INT 110
93149: EQUAL
93150: IFFALSE 93160
// sContamin := true ;
93152: LD_ADDR_EXP 110
93156: PUSH
93157: LD_INT 1
93159: ST_TO_ADDR
// if p3 = 111 then
93160: LD_VAR 0 3
93164: PUSH
93165: LD_INT 111
93167: EQUAL
93168: IFFALSE 93178
// sOil := true ;
93170: LD_ADDR_EXP 112
93174: PUSH
93175: LD_INT 1
93177: ST_TO_ADDR
// if p3 = 112 then
93178: LD_VAR 0 3
93182: PUSH
93183: LD_INT 112
93185: EQUAL
93186: IFFALSE 93196
// sStu := true ;
93188: LD_ADDR_EXP 116
93192: PUSH
93193: LD_INT 1
93195: ST_TO_ADDR
// if p3 = 113 then
93196: LD_VAR 0 3
93200: PUSH
93201: LD_INT 113
93203: EQUAL
93204: IFFALSE 93214
// sBazooka := true ;
93206: LD_ADDR_EXP 119
93210: PUSH
93211: LD_INT 1
93213: ST_TO_ADDR
// if p3 = 114 then
93214: LD_VAR 0 3
93218: PUSH
93219: LD_INT 114
93221: EQUAL
93222: IFFALSE 93232
// sMortar := true ;
93224: LD_ADDR_EXP 120
93228: PUSH
93229: LD_INT 1
93231: ST_TO_ADDR
// if p3 = 115 then
93232: LD_VAR 0 3
93236: PUSH
93237: LD_INT 115
93239: EQUAL
93240: IFFALSE 93250
// sRanger := true ;
93242: LD_ADDR_EXP 130
93246: PUSH
93247: LD_INT 1
93249: ST_TO_ADDR
// if p3 = 116 then
93250: LD_VAR 0 3
93254: PUSH
93255: LD_INT 116
93257: EQUAL
93258: IFFALSE 93268
// sComputer := true ;
93260: LD_ADDR_EXP 131
93264: PUSH
93265: LD_INT 1
93267: ST_TO_ADDR
// if p3 = 117 then
93268: LD_VAR 0 3
93272: PUSH
93273: LD_INT 117
93275: EQUAL
93276: IFFALSE 93286
// s30 := true ;
93278: LD_ADDR_EXP 132
93282: PUSH
93283: LD_INT 1
93285: ST_TO_ADDR
// if p3 = 118 then
93286: LD_VAR 0 3
93290: PUSH
93291: LD_INT 118
93293: EQUAL
93294: IFFALSE 93304
// s60 := true ;
93296: LD_ADDR_EXP 133
93300: PUSH
93301: LD_INT 1
93303: ST_TO_ADDR
// end ; if p2 = hack_mode then
93304: LD_VAR 0 2
93308: PUSH
93309: LD_INT 101
93311: EQUAL
93312: IFFALSE 93440
// begin case p3 of 1 :
93314: LD_VAR 0 3
93318: PUSH
93319: LD_INT 1
93321: DOUBLE
93322: EQUAL
93323: IFTRUE 93327
93325: GO 93334
93327: POP
// hHackUnlimitedResources ; 2 :
93328: CALL 105587 0 0
93332: GO 93440
93334: LD_INT 2
93336: DOUBLE
93337: EQUAL
93338: IFTRUE 93342
93340: GO 93349
93342: POP
// hHackSetLevel10 ; 3 :
93343: CALL 105720 0 0
93347: GO 93440
93349: LD_INT 3
93351: DOUBLE
93352: EQUAL
93353: IFTRUE 93357
93355: GO 93364
93357: POP
// hHackSetLevel10YourUnits ; 4 :
93358: CALL 105805 0 0
93362: GO 93440
93364: LD_INT 4
93366: DOUBLE
93367: EQUAL
93368: IFTRUE 93372
93370: GO 93379
93372: POP
// hHackInvincible ; 5 :
93373: CALL 106253 0 0
93377: GO 93440
93379: LD_INT 5
93381: DOUBLE
93382: EQUAL
93383: IFTRUE 93387
93385: GO 93394
93387: POP
// hHackInvisible ; 6 :
93388: CALL 106364 0 0
93392: GO 93440
93394: LD_INT 6
93396: DOUBLE
93397: EQUAL
93398: IFTRUE 93402
93400: GO 93409
93402: POP
// hHackChangeYourSide ; 7 :
93403: CALL 106421 0 0
93407: GO 93440
93409: LD_INT 7
93411: DOUBLE
93412: EQUAL
93413: IFTRUE 93417
93415: GO 93424
93417: POP
// hHackChangeUnitSide ; 8 :
93418: CALL 106463 0 0
93422: GO 93440
93424: LD_INT 8
93426: DOUBLE
93427: EQUAL
93428: IFTRUE 93432
93430: GO 93439
93432: POP
// hHackFog ; end ;
93433: CALL 106564 0 0
93437: GO 93440
93439: POP
// end ; if p2 = game_save_mode then
93440: LD_VAR 0 2
93444: PUSH
93445: LD_INT 102
93447: EQUAL
93448: IFFALSE 93503
// begin if p3 = 1 then
93450: LD_VAR 0 3
93454: PUSH
93455: LD_INT 1
93457: EQUAL
93458: IFFALSE 93470
// globalGameSaveCounter := p4 ;
93460: LD_ADDR_EXP 76
93464: PUSH
93465: LD_VAR 0 4
93469: ST_TO_ADDR
// if p3 = 2 and globalGameSaveCounter then
93470: LD_VAR 0 3
93474: PUSH
93475: LD_INT 2
93477: EQUAL
93478: PUSH
93479: LD_EXP 76
93483: AND
93484: IFFALSE 93503
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
93486: LD_STRING setGameSaveCounter(
93488: PUSH
93489: LD_EXP 76
93493: STR
93494: PUSH
93495: LD_STRING )
93497: STR
93498: PPUSH
93499: CALL_OW 559
// end ; end ;
93503: LD_VAR 0 7
93507: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger , sComputer , s30 , s60 ; function InitStreamMode ; begin
93508: LD_INT 0
93510: PPUSH
// streamModeActive := false ;
93511: LD_ADDR_EXP 77
93515: PUSH
93516: LD_INT 0
93518: ST_TO_ADDR
// normalCounter := 36 ;
93519: LD_ADDR_EXP 78
93523: PUSH
93524: LD_INT 36
93526: ST_TO_ADDR
// hardcoreCounter := 18 ;
93527: LD_ADDR_EXP 79
93531: PUSH
93532: LD_INT 18
93534: ST_TO_ADDR
// sRocket := false ;
93535: LD_ADDR_EXP 82
93539: PUSH
93540: LD_INT 0
93542: ST_TO_ADDR
// sSpeed := false ;
93543: LD_ADDR_EXP 81
93547: PUSH
93548: LD_INT 0
93550: ST_TO_ADDR
// sEngine := false ;
93551: LD_ADDR_EXP 83
93555: PUSH
93556: LD_INT 0
93558: ST_TO_ADDR
// sSpec := false ;
93559: LD_ADDR_EXP 80
93563: PUSH
93564: LD_INT 0
93566: ST_TO_ADDR
// sLevel := false ;
93567: LD_ADDR_EXP 84
93571: PUSH
93572: LD_INT 0
93574: ST_TO_ADDR
// sArmoury := false ;
93575: LD_ADDR_EXP 85
93579: PUSH
93580: LD_INT 0
93582: ST_TO_ADDR
// sRadar := false ;
93583: LD_ADDR_EXP 86
93587: PUSH
93588: LD_INT 0
93590: ST_TO_ADDR
// sBunker := false ;
93591: LD_ADDR_EXP 87
93595: PUSH
93596: LD_INT 0
93598: ST_TO_ADDR
// sHack := false ;
93599: LD_ADDR_EXP 88
93603: PUSH
93604: LD_INT 0
93606: ST_TO_ADDR
// sFire := false ;
93607: LD_ADDR_EXP 89
93611: PUSH
93612: LD_INT 0
93614: ST_TO_ADDR
// sRefresh := false ;
93615: LD_ADDR_EXP 90
93619: PUSH
93620: LD_INT 0
93622: ST_TO_ADDR
// sExp := false ;
93623: LD_ADDR_EXP 91
93627: PUSH
93628: LD_INT 0
93630: ST_TO_ADDR
// sDepot := false ;
93631: LD_ADDR_EXP 92
93635: PUSH
93636: LD_INT 0
93638: ST_TO_ADDR
// sFlag := false ;
93639: LD_ADDR_EXP 93
93643: PUSH
93644: LD_INT 0
93646: ST_TO_ADDR
// sKamikadze := false ;
93647: LD_ADDR_EXP 101
93651: PUSH
93652: LD_INT 0
93654: ST_TO_ADDR
// sTroll := false ;
93655: LD_ADDR_EXP 102
93659: PUSH
93660: LD_INT 0
93662: ST_TO_ADDR
// sSlow := false ;
93663: LD_ADDR_EXP 103
93667: PUSH
93668: LD_INT 0
93670: ST_TO_ADDR
// sLack := false ;
93671: LD_ADDR_EXP 104
93675: PUSH
93676: LD_INT 0
93678: ST_TO_ADDR
// sTank := false ;
93679: LD_ADDR_EXP 106
93683: PUSH
93684: LD_INT 0
93686: ST_TO_ADDR
// sRemote := false ;
93687: LD_ADDR_EXP 107
93691: PUSH
93692: LD_INT 0
93694: ST_TO_ADDR
// sPowell := false ;
93695: LD_ADDR_EXP 108
93699: PUSH
93700: LD_INT 0
93702: ST_TO_ADDR
// sTeleport := false ;
93703: LD_ADDR_EXP 111
93707: PUSH
93708: LD_INT 0
93710: ST_TO_ADDR
// sOilTower := false ;
93711: LD_ADDR_EXP 113
93715: PUSH
93716: LD_INT 0
93718: ST_TO_ADDR
// sShovel := false ;
93719: LD_ADDR_EXP 114
93723: PUSH
93724: LD_INT 0
93726: ST_TO_ADDR
// sSheik := false ;
93727: LD_ADDR_EXP 115
93731: PUSH
93732: LD_INT 0
93734: ST_TO_ADDR
// sEarthquake := false ;
93735: LD_ADDR_EXP 117
93739: PUSH
93740: LD_INT 0
93742: ST_TO_ADDR
// sAI := false ;
93743: LD_ADDR_EXP 118
93747: PUSH
93748: LD_INT 0
93750: ST_TO_ADDR
// sCargo := false ;
93751: LD_ADDR_EXP 121
93755: PUSH
93756: LD_INT 0
93758: ST_TO_ADDR
// sDLaser := false ;
93759: LD_ADDR_EXP 122
93763: PUSH
93764: LD_INT 0
93766: ST_TO_ADDR
// sExchange := false ;
93767: LD_ADDR_EXP 123
93771: PUSH
93772: LD_INT 0
93774: ST_TO_ADDR
// sFac := false ;
93775: LD_ADDR_EXP 124
93779: PUSH
93780: LD_INT 0
93782: ST_TO_ADDR
// sPower := false ;
93783: LD_ADDR_EXP 125
93787: PUSH
93788: LD_INT 0
93790: ST_TO_ADDR
// sRandom := false ;
93791: LD_ADDR_EXP 126
93795: PUSH
93796: LD_INT 0
93798: ST_TO_ADDR
// sShield := false ;
93799: LD_ADDR_EXP 127
93803: PUSH
93804: LD_INT 0
93806: ST_TO_ADDR
// sTime := false ;
93807: LD_ADDR_EXP 128
93811: PUSH
93812: LD_INT 0
93814: ST_TO_ADDR
// sTools := false ;
93815: LD_ADDR_EXP 129
93819: PUSH
93820: LD_INT 0
93822: ST_TO_ADDR
// sSold := false ;
93823: LD_ADDR_EXP 94
93827: PUSH
93828: LD_INT 0
93830: ST_TO_ADDR
// sDiff := false ;
93831: LD_ADDR_EXP 95
93835: PUSH
93836: LD_INT 0
93838: ST_TO_ADDR
// sFog := false ;
93839: LD_ADDR_EXP 98
93843: PUSH
93844: LD_INT 0
93846: ST_TO_ADDR
// sReset := false ;
93847: LD_ADDR_EXP 99
93851: PUSH
93852: LD_INT 0
93854: ST_TO_ADDR
// sSun := false ;
93855: LD_ADDR_EXP 100
93859: PUSH
93860: LD_INT 0
93862: ST_TO_ADDR
// sTiger := false ;
93863: LD_ADDR_EXP 96
93867: PUSH
93868: LD_INT 0
93870: ST_TO_ADDR
// sBomb := false ;
93871: LD_ADDR_EXP 97
93875: PUSH
93876: LD_INT 0
93878: ST_TO_ADDR
// sWound := false ;
93879: LD_ADDR_EXP 105
93883: PUSH
93884: LD_INT 0
93886: ST_TO_ADDR
// sBetray := false ;
93887: LD_ADDR_EXP 109
93891: PUSH
93892: LD_INT 0
93894: ST_TO_ADDR
// sContamin := false ;
93895: LD_ADDR_EXP 110
93899: PUSH
93900: LD_INT 0
93902: ST_TO_ADDR
// sOil := false ;
93903: LD_ADDR_EXP 112
93907: PUSH
93908: LD_INT 0
93910: ST_TO_ADDR
// sStu := false ;
93911: LD_ADDR_EXP 116
93915: PUSH
93916: LD_INT 0
93918: ST_TO_ADDR
// sBazooka := false ;
93919: LD_ADDR_EXP 119
93923: PUSH
93924: LD_INT 0
93926: ST_TO_ADDR
// sMortar := false ;
93927: LD_ADDR_EXP 120
93931: PUSH
93932: LD_INT 0
93934: ST_TO_ADDR
// sRanger := false ;
93935: LD_ADDR_EXP 130
93939: PUSH
93940: LD_INT 0
93942: ST_TO_ADDR
// sComputer := false ;
93943: LD_ADDR_EXP 131
93947: PUSH
93948: LD_INT 0
93950: ST_TO_ADDR
// s30 := false ;
93951: LD_ADDR_EXP 132
93955: PUSH
93956: LD_INT 0
93958: ST_TO_ADDR
// s60 := false ;
93959: LD_ADDR_EXP 133
93963: PUSH
93964: LD_INT 0
93966: ST_TO_ADDR
// end ;
93967: LD_VAR 0 1
93971: RET
// function DefineStreamItems ( isGameLoad ) ; var tmp , flags , normal , hardcore , active , i ; begin
93972: LD_INT 0
93974: PPUSH
93975: PPUSH
93976: PPUSH
93977: PPUSH
93978: PPUSH
93979: PPUSH
93980: PPUSH
// result := [ ] ;
93981: LD_ADDR_VAR 0 2
93985: PUSH
93986: EMPTY
93987: ST_TO_ADDR
// if campaign_id = 1 then
93988: LD_OWVAR 69
93992: PUSH
93993: LD_INT 1
93995: EQUAL
93996: IFFALSE 97162
// begin case mission_number of 1 :
93998: LD_OWVAR 70
94002: PUSH
94003: LD_INT 1
94005: DOUBLE
94006: EQUAL
94007: IFTRUE 94011
94009: GO 94087
94011: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 , 116 , 117 , 118 ] ] ; 2 :
94012: LD_ADDR_VAR 0 2
94016: PUSH
94017: LD_INT 2
94019: PUSH
94020: LD_INT 4
94022: PUSH
94023: LD_INT 11
94025: PUSH
94026: LD_INT 12
94028: PUSH
94029: LD_INT 15
94031: PUSH
94032: LD_INT 16
94034: PUSH
94035: LD_INT 22
94037: PUSH
94038: LD_INT 23
94040: PUSH
94041: LD_INT 26
94043: PUSH
94044: EMPTY
94045: LIST
94046: LIST
94047: LIST
94048: LIST
94049: LIST
94050: LIST
94051: LIST
94052: LIST
94053: LIST
94054: PUSH
94055: LD_INT 101
94057: PUSH
94058: LD_INT 102
94060: PUSH
94061: LD_INT 106
94063: PUSH
94064: LD_INT 116
94066: PUSH
94067: LD_INT 117
94069: PUSH
94070: LD_INT 118
94072: PUSH
94073: EMPTY
94074: LIST
94075: LIST
94076: LIST
94077: LIST
94078: LIST
94079: LIST
94080: PUSH
94081: EMPTY
94082: LIST
94083: LIST
94084: ST_TO_ADDR
94085: GO 97160
94087: LD_INT 2
94089: DOUBLE
94090: EQUAL
94091: IFTRUE 94095
94093: GO 94179
94095: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 3 :
94096: LD_ADDR_VAR 0 2
94100: PUSH
94101: LD_INT 2
94103: PUSH
94104: LD_INT 4
94106: PUSH
94107: LD_INT 11
94109: PUSH
94110: LD_INT 12
94112: PUSH
94113: LD_INT 15
94115: PUSH
94116: LD_INT 16
94118: PUSH
94119: LD_INT 22
94121: PUSH
94122: LD_INT 23
94124: PUSH
94125: LD_INT 26
94127: PUSH
94128: EMPTY
94129: LIST
94130: LIST
94131: LIST
94132: LIST
94133: LIST
94134: LIST
94135: LIST
94136: LIST
94137: LIST
94138: PUSH
94139: LD_INT 101
94141: PUSH
94142: LD_INT 102
94144: PUSH
94145: LD_INT 105
94147: PUSH
94148: LD_INT 106
94150: PUSH
94151: LD_INT 108
94153: PUSH
94154: LD_INT 116
94156: PUSH
94157: LD_INT 117
94159: PUSH
94160: LD_INT 118
94162: PUSH
94163: EMPTY
94164: LIST
94165: LIST
94166: LIST
94167: LIST
94168: LIST
94169: LIST
94170: LIST
94171: LIST
94172: PUSH
94173: EMPTY
94174: LIST
94175: LIST
94176: ST_TO_ADDR
94177: GO 97160
94179: LD_INT 3
94181: DOUBLE
94182: EQUAL
94183: IFTRUE 94187
94185: GO 94275
94187: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 4 :
94188: LD_ADDR_VAR 0 2
94192: PUSH
94193: LD_INT 2
94195: PUSH
94196: LD_INT 4
94198: PUSH
94199: LD_INT 5
94201: PUSH
94202: LD_INT 11
94204: PUSH
94205: LD_INT 12
94207: PUSH
94208: LD_INT 15
94210: PUSH
94211: LD_INT 16
94213: PUSH
94214: LD_INT 22
94216: PUSH
94217: LD_INT 26
94219: PUSH
94220: LD_INT 36
94222: PUSH
94223: EMPTY
94224: LIST
94225: LIST
94226: LIST
94227: LIST
94228: LIST
94229: LIST
94230: LIST
94231: LIST
94232: LIST
94233: LIST
94234: PUSH
94235: LD_INT 101
94237: PUSH
94238: LD_INT 102
94240: PUSH
94241: LD_INT 105
94243: PUSH
94244: LD_INT 106
94246: PUSH
94247: LD_INT 108
94249: PUSH
94250: LD_INT 116
94252: PUSH
94253: LD_INT 117
94255: PUSH
94256: LD_INT 118
94258: PUSH
94259: EMPTY
94260: LIST
94261: LIST
94262: LIST
94263: LIST
94264: LIST
94265: LIST
94266: LIST
94267: LIST
94268: PUSH
94269: EMPTY
94270: LIST
94271: LIST
94272: ST_TO_ADDR
94273: GO 97160
94275: LD_INT 4
94277: DOUBLE
94278: EQUAL
94279: IFTRUE 94283
94281: GO 94379
94283: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 5 :
94284: LD_ADDR_VAR 0 2
94288: PUSH
94289: LD_INT 2
94291: PUSH
94292: LD_INT 4
94294: PUSH
94295: LD_INT 5
94297: PUSH
94298: LD_INT 8
94300: PUSH
94301: LD_INT 11
94303: PUSH
94304: LD_INT 12
94306: PUSH
94307: LD_INT 15
94309: PUSH
94310: LD_INT 16
94312: PUSH
94313: LD_INT 22
94315: PUSH
94316: LD_INT 23
94318: PUSH
94319: LD_INT 26
94321: PUSH
94322: LD_INT 36
94324: PUSH
94325: EMPTY
94326: LIST
94327: LIST
94328: LIST
94329: LIST
94330: LIST
94331: LIST
94332: LIST
94333: LIST
94334: LIST
94335: LIST
94336: LIST
94337: LIST
94338: PUSH
94339: LD_INT 101
94341: PUSH
94342: LD_INT 102
94344: PUSH
94345: LD_INT 105
94347: PUSH
94348: LD_INT 106
94350: PUSH
94351: LD_INT 108
94353: PUSH
94354: LD_INT 116
94356: PUSH
94357: LD_INT 117
94359: PUSH
94360: LD_INT 118
94362: PUSH
94363: EMPTY
94364: LIST
94365: LIST
94366: LIST
94367: LIST
94368: LIST
94369: LIST
94370: LIST
94371: LIST
94372: PUSH
94373: EMPTY
94374: LIST
94375: LIST
94376: ST_TO_ADDR
94377: GO 97160
94379: LD_INT 5
94381: DOUBLE
94382: EQUAL
94383: IFTRUE 94387
94385: GO 94499
94387: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 6 :
94388: LD_ADDR_VAR 0 2
94392: PUSH
94393: LD_INT 2
94395: PUSH
94396: LD_INT 4
94398: PUSH
94399: LD_INT 5
94401: PUSH
94402: LD_INT 6
94404: PUSH
94405: LD_INT 8
94407: PUSH
94408: LD_INT 11
94410: PUSH
94411: LD_INT 12
94413: PUSH
94414: LD_INT 15
94416: PUSH
94417: LD_INT 16
94419: PUSH
94420: LD_INT 22
94422: PUSH
94423: LD_INT 23
94425: PUSH
94426: LD_INT 25
94428: PUSH
94429: LD_INT 26
94431: PUSH
94432: LD_INT 36
94434: PUSH
94435: EMPTY
94436: LIST
94437: LIST
94438: LIST
94439: LIST
94440: LIST
94441: LIST
94442: LIST
94443: LIST
94444: LIST
94445: LIST
94446: LIST
94447: LIST
94448: LIST
94449: LIST
94450: PUSH
94451: LD_INT 101
94453: PUSH
94454: LD_INT 102
94456: PUSH
94457: LD_INT 105
94459: PUSH
94460: LD_INT 106
94462: PUSH
94463: LD_INT 108
94465: PUSH
94466: LD_INT 109
94468: PUSH
94469: LD_INT 112
94471: PUSH
94472: LD_INT 116
94474: PUSH
94475: LD_INT 117
94477: PUSH
94478: LD_INT 118
94480: PUSH
94481: EMPTY
94482: LIST
94483: LIST
94484: LIST
94485: LIST
94486: LIST
94487: LIST
94488: LIST
94489: LIST
94490: LIST
94491: LIST
94492: PUSH
94493: EMPTY
94494: LIST
94495: LIST
94496: ST_TO_ADDR
94497: GO 97160
94499: LD_INT 6
94501: DOUBLE
94502: EQUAL
94503: IFTRUE 94507
94505: GO 94639
94507: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 7 :
94508: LD_ADDR_VAR 0 2
94512: PUSH
94513: LD_INT 2
94515: PUSH
94516: LD_INT 4
94518: PUSH
94519: LD_INT 5
94521: PUSH
94522: LD_INT 6
94524: PUSH
94525: LD_INT 8
94527: PUSH
94528: LD_INT 11
94530: PUSH
94531: LD_INT 12
94533: PUSH
94534: LD_INT 15
94536: PUSH
94537: LD_INT 16
94539: PUSH
94540: LD_INT 20
94542: PUSH
94543: LD_INT 21
94545: PUSH
94546: LD_INT 22
94548: PUSH
94549: LD_INT 23
94551: PUSH
94552: LD_INT 25
94554: PUSH
94555: LD_INT 26
94557: PUSH
94558: LD_INT 30
94560: PUSH
94561: LD_INT 31
94563: PUSH
94564: LD_INT 32
94566: PUSH
94567: LD_INT 36
94569: PUSH
94570: EMPTY
94571: LIST
94572: LIST
94573: LIST
94574: LIST
94575: LIST
94576: LIST
94577: LIST
94578: LIST
94579: LIST
94580: LIST
94581: LIST
94582: LIST
94583: LIST
94584: LIST
94585: LIST
94586: LIST
94587: LIST
94588: LIST
94589: LIST
94590: PUSH
94591: LD_INT 101
94593: PUSH
94594: LD_INT 102
94596: PUSH
94597: LD_INT 105
94599: PUSH
94600: LD_INT 106
94602: PUSH
94603: LD_INT 108
94605: PUSH
94606: LD_INT 109
94608: PUSH
94609: LD_INT 112
94611: PUSH
94612: LD_INT 116
94614: PUSH
94615: LD_INT 117
94617: PUSH
94618: LD_INT 118
94620: PUSH
94621: EMPTY
94622: LIST
94623: LIST
94624: LIST
94625: LIST
94626: LIST
94627: LIST
94628: LIST
94629: LIST
94630: LIST
94631: LIST
94632: PUSH
94633: EMPTY
94634: LIST
94635: LIST
94636: ST_TO_ADDR
94637: GO 97160
94639: LD_INT 7
94641: DOUBLE
94642: EQUAL
94643: IFTRUE 94647
94645: GO 94759
94647: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 , 116 , 117 , 118 ] ] ; 8 :
94648: LD_ADDR_VAR 0 2
94652: PUSH
94653: LD_INT 2
94655: PUSH
94656: LD_INT 4
94658: PUSH
94659: LD_INT 5
94661: PUSH
94662: LD_INT 7
94664: PUSH
94665: LD_INT 11
94667: PUSH
94668: LD_INT 12
94670: PUSH
94671: LD_INT 15
94673: PUSH
94674: LD_INT 16
94676: PUSH
94677: LD_INT 20
94679: PUSH
94680: LD_INT 21
94682: PUSH
94683: LD_INT 22
94685: PUSH
94686: LD_INT 23
94688: PUSH
94689: LD_INT 25
94691: PUSH
94692: LD_INT 26
94694: PUSH
94695: EMPTY
94696: LIST
94697: LIST
94698: LIST
94699: LIST
94700: LIST
94701: LIST
94702: LIST
94703: LIST
94704: LIST
94705: LIST
94706: LIST
94707: LIST
94708: LIST
94709: LIST
94710: PUSH
94711: LD_INT 101
94713: PUSH
94714: LD_INT 102
94716: PUSH
94717: LD_INT 103
94719: PUSH
94720: LD_INT 105
94722: PUSH
94723: LD_INT 106
94725: PUSH
94726: LD_INT 108
94728: PUSH
94729: LD_INT 112
94731: PUSH
94732: LD_INT 116
94734: PUSH
94735: LD_INT 117
94737: PUSH
94738: LD_INT 118
94740: PUSH
94741: EMPTY
94742: LIST
94743: LIST
94744: LIST
94745: LIST
94746: LIST
94747: LIST
94748: LIST
94749: LIST
94750: LIST
94751: LIST
94752: PUSH
94753: EMPTY
94754: LIST
94755: LIST
94756: ST_TO_ADDR
94757: GO 97160
94759: LD_INT 8
94761: DOUBLE
94762: EQUAL
94763: IFTRUE 94767
94765: GO 94907
94767: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 9 :
94768: LD_ADDR_VAR 0 2
94772: PUSH
94773: LD_INT 2
94775: PUSH
94776: LD_INT 4
94778: PUSH
94779: LD_INT 5
94781: PUSH
94782: LD_INT 6
94784: PUSH
94785: LD_INT 7
94787: PUSH
94788: LD_INT 8
94790: PUSH
94791: LD_INT 11
94793: PUSH
94794: LD_INT 12
94796: PUSH
94797: LD_INT 15
94799: PUSH
94800: LD_INT 16
94802: PUSH
94803: LD_INT 20
94805: PUSH
94806: LD_INT 21
94808: PUSH
94809: LD_INT 22
94811: PUSH
94812: LD_INT 23
94814: PUSH
94815: LD_INT 25
94817: PUSH
94818: LD_INT 26
94820: PUSH
94821: LD_INT 30
94823: PUSH
94824: LD_INT 31
94826: PUSH
94827: LD_INT 32
94829: PUSH
94830: LD_INT 36
94832: PUSH
94833: EMPTY
94834: LIST
94835: LIST
94836: LIST
94837: LIST
94838: LIST
94839: LIST
94840: LIST
94841: LIST
94842: LIST
94843: LIST
94844: LIST
94845: LIST
94846: LIST
94847: LIST
94848: LIST
94849: LIST
94850: LIST
94851: LIST
94852: LIST
94853: LIST
94854: PUSH
94855: LD_INT 101
94857: PUSH
94858: LD_INT 102
94860: PUSH
94861: LD_INT 103
94863: PUSH
94864: LD_INT 105
94866: PUSH
94867: LD_INT 106
94869: PUSH
94870: LD_INT 108
94872: PUSH
94873: LD_INT 109
94875: PUSH
94876: LD_INT 112
94878: PUSH
94879: LD_INT 116
94881: PUSH
94882: LD_INT 117
94884: PUSH
94885: LD_INT 118
94887: PUSH
94888: EMPTY
94889: LIST
94890: LIST
94891: LIST
94892: LIST
94893: LIST
94894: LIST
94895: LIST
94896: LIST
94897: LIST
94898: LIST
94899: LIST
94900: PUSH
94901: EMPTY
94902: LIST
94903: LIST
94904: ST_TO_ADDR
94905: GO 97160
94907: LD_INT 9
94909: DOUBLE
94910: EQUAL
94911: IFTRUE 94915
94913: GO 95063
94915: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 , 116 , 117 , 118 ] ] ; 10 :
94916: LD_ADDR_VAR 0 2
94920: PUSH
94921: LD_INT 2
94923: PUSH
94924: LD_INT 4
94926: PUSH
94927: LD_INT 5
94929: PUSH
94930: LD_INT 6
94932: PUSH
94933: LD_INT 7
94935: PUSH
94936: LD_INT 8
94938: PUSH
94939: LD_INT 11
94941: PUSH
94942: LD_INT 12
94944: PUSH
94945: LD_INT 15
94947: PUSH
94948: LD_INT 16
94950: PUSH
94951: LD_INT 20
94953: PUSH
94954: LD_INT 21
94956: PUSH
94957: LD_INT 22
94959: PUSH
94960: LD_INT 23
94962: PUSH
94963: LD_INT 25
94965: PUSH
94966: LD_INT 26
94968: PUSH
94969: LD_INT 28
94971: PUSH
94972: LD_INT 30
94974: PUSH
94975: LD_INT 31
94977: PUSH
94978: LD_INT 32
94980: PUSH
94981: LD_INT 36
94983: PUSH
94984: EMPTY
94985: LIST
94986: LIST
94987: LIST
94988: LIST
94989: LIST
94990: LIST
94991: LIST
94992: LIST
94993: LIST
94994: LIST
94995: LIST
94996: LIST
94997: LIST
94998: LIST
94999: LIST
95000: LIST
95001: LIST
95002: LIST
95003: LIST
95004: LIST
95005: LIST
95006: PUSH
95007: LD_INT 101
95009: PUSH
95010: LD_INT 102
95012: PUSH
95013: LD_INT 103
95015: PUSH
95016: LD_INT 105
95018: PUSH
95019: LD_INT 106
95021: PUSH
95022: LD_INT 108
95024: PUSH
95025: LD_INT 109
95027: PUSH
95028: LD_INT 112
95030: PUSH
95031: LD_INT 114
95033: PUSH
95034: LD_INT 116
95036: PUSH
95037: LD_INT 117
95039: PUSH
95040: LD_INT 118
95042: PUSH
95043: EMPTY
95044: LIST
95045: LIST
95046: LIST
95047: LIST
95048: LIST
95049: LIST
95050: LIST
95051: LIST
95052: LIST
95053: LIST
95054: LIST
95055: LIST
95056: PUSH
95057: EMPTY
95058: LIST
95059: LIST
95060: ST_TO_ADDR
95061: GO 97160
95063: LD_INT 10
95065: DOUBLE
95066: EQUAL
95067: IFTRUE 95071
95069: GO 95267
95071: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 11 :
95072: LD_ADDR_VAR 0 2
95076: PUSH
95077: LD_INT 2
95079: PUSH
95080: LD_INT 4
95082: PUSH
95083: LD_INT 5
95085: PUSH
95086: LD_INT 6
95088: PUSH
95089: LD_INT 7
95091: PUSH
95092: LD_INT 8
95094: PUSH
95095: LD_INT 9
95097: PUSH
95098: LD_INT 10
95100: PUSH
95101: LD_INT 11
95103: PUSH
95104: LD_INT 12
95106: PUSH
95107: LD_INT 13
95109: PUSH
95110: LD_INT 14
95112: PUSH
95113: LD_INT 15
95115: PUSH
95116: LD_INT 16
95118: PUSH
95119: LD_INT 17
95121: PUSH
95122: LD_INT 18
95124: PUSH
95125: LD_INT 19
95127: PUSH
95128: LD_INT 20
95130: PUSH
95131: LD_INT 21
95133: PUSH
95134: LD_INT 22
95136: PUSH
95137: LD_INT 23
95139: PUSH
95140: LD_INT 24
95142: PUSH
95143: LD_INT 25
95145: PUSH
95146: LD_INT 26
95148: PUSH
95149: LD_INT 28
95151: PUSH
95152: LD_INT 30
95154: PUSH
95155: LD_INT 31
95157: PUSH
95158: LD_INT 32
95160: PUSH
95161: LD_INT 36
95163: PUSH
95164: EMPTY
95165: LIST
95166: LIST
95167: LIST
95168: LIST
95169: LIST
95170: LIST
95171: LIST
95172: LIST
95173: LIST
95174: LIST
95175: LIST
95176: LIST
95177: LIST
95178: LIST
95179: LIST
95180: LIST
95181: LIST
95182: LIST
95183: LIST
95184: LIST
95185: LIST
95186: LIST
95187: LIST
95188: LIST
95189: LIST
95190: LIST
95191: LIST
95192: LIST
95193: LIST
95194: PUSH
95195: LD_INT 101
95197: PUSH
95198: LD_INT 102
95200: PUSH
95201: LD_INT 103
95203: PUSH
95204: LD_INT 104
95206: PUSH
95207: LD_INT 105
95209: PUSH
95210: LD_INT 106
95212: PUSH
95213: LD_INT 107
95215: PUSH
95216: LD_INT 108
95218: PUSH
95219: LD_INT 109
95221: PUSH
95222: LD_INT 110
95224: PUSH
95225: LD_INT 111
95227: PUSH
95228: LD_INT 112
95230: PUSH
95231: LD_INT 114
95233: PUSH
95234: LD_INT 116
95236: PUSH
95237: LD_INT 117
95239: PUSH
95240: LD_INT 118
95242: PUSH
95243: EMPTY
95244: LIST
95245: LIST
95246: LIST
95247: LIST
95248: LIST
95249: LIST
95250: LIST
95251: LIST
95252: LIST
95253: LIST
95254: LIST
95255: LIST
95256: LIST
95257: LIST
95258: LIST
95259: LIST
95260: PUSH
95261: EMPTY
95262: LIST
95263: LIST
95264: ST_TO_ADDR
95265: GO 97160
95267: LD_INT 11
95269: DOUBLE
95270: EQUAL
95271: IFTRUE 95275
95273: GO 95479
95275: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 12 :
95276: LD_ADDR_VAR 0 2
95280: PUSH
95281: LD_INT 2
95283: PUSH
95284: LD_INT 3
95286: PUSH
95287: LD_INT 4
95289: PUSH
95290: LD_INT 5
95292: PUSH
95293: LD_INT 6
95295: PUSH
95296: LD_INT 7
95298: PUSH
95299: LD_INT 8
95301: PUSH
95302: LD_INT 9
95304: PUSH
95305: LD_INT 10
95307: PUSH
95308: LD_INT 11
95310: PUSH
95311: LD_INT 12
95313: PUSH
95314: LD_INT 13
95316: PUSH
95317: LD_INT 14
95319: PUSH
95320: LD_INT 15
95322: PUSH
95323: LD_INT 16
95325: PUSH
95326: LD_INT 17
95328: PUSH
95329: LD_INT 18
95331: PUSH
95332: LD_INT 19
95334: PUSH
95335: LD_INT 20
95337: PUSH
95338: LD_INT 21
95340: PUSH
95341: LD_INT 22
95343: PUSH
95344: LD_INT 23
95346: PUSH
95347: LD_INT 24
95349: PUSH
95350: LD_INT 25
95352: PUSH
95353: LD_INT 26
95355: PUSH
95356: LD_INT 28
95358: PUSH
95359: LD_INT 30
95361: PUSH
95362: LD_INT 31
95364: PUSH
95365: LD_INT 32
95367: PUSH
95368: LD_INT 34
95370: PUSH
95371: LD_INT 36
95373: PUSH
95374: EMPTY
95375: LIST
95376: LIST
95377: LIST
95378: LIST
95379: LIST
95380: LIST
95381: LIST
95382: LIST
95383: LIST
95384: LIST
95385: LIST
95386: LIST
95387: LIST
95388: LIST
95389: LIST
95390: LIST
95391: LIST
95392: LIST
95393: LIST
95394: LIST
95395: LIST
95396: LIST
95397: LIST
95398: LIST
95399: LIST
95400: LIST
95401: LIST
95402: LIST
95403: LIST
95404: LIST
95405: LIST
95406: PUSH
95407: LD_INT 101
95409: PUSH
95410: LD_INT 102
95412: PUSH
95413: LD_INT 103
95415: PUSH
95416: LD_INT 104
95418: PUSH
95419: LD_INT 105
95421: PUSH
95422: LD_INT 106
95424: PUSH
95425: LD_INT 107
95427: PUSH
95428: LD_INT 108
95430: PUSH
95431: LD_INT 109
95433: PUSH
95434: LD_INT 110
95436: PUSH
95437: LD_INT 111
95439: PUSH
95440: LD_INT 112
95442: PUSH
95443: LD_INT 114
95445: PUSH
95446: LD_INT 116
95448: PUSH
95449: LD_INT 117
95451: PUSH
95452: LD_INT 118
95454: PUSH
95455: EMPTY
95456: LIST
95457: LIST
95458: LIST
95459: LIST
95460: LIST
95461: LIST
95462: LIST
95463: LIST
95464: LIST
95465: LIST
95466: LIST
95467: LIST
95468: LIST
95469: LIST
95470: LIST
95471: LIST
95472: PUSH
95473: EMPTY
95474: LIST
95475: LIST
95476: ST_TO_ADDR
95477: GO 97160
95479: LD_INT 12
95481: DOUBLE
95482: EQUAL
95483: IFTRUE 95487
95485: GO 95707
95487: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 13 :
95488: LD_ADDR_VAR 0 2
95492: PUSH
95493: LD_INT 1
95495: PUSH
95496: LD_INT 2
95498: PUSH
95499: LD_INT 3
95501: PUSH
95502: LD_INT 4
95504: PUSH
95505: LD_INT 5
95507: PUSH
95508: LD_INT 6
95510: PUSH
95511: LD_INT 7
95513: PUSH
95514: LD_INT 8
95516: PUSH
95517: LD_INT 9
95519: PUSH
95520: LD_INT 10
95522: PUSH
95523: LD_INT 11
95525: PUSH
95526: LD_INT 12
95528: PUSH
95529: LD_INT 13
95531: PUSH
95532: LD_INT 14
95534: PUSH
95535: LD_INT 15
95537: PUSH
95538: LD_INT 16
95540: PUSH
95541: LD_INT 17
95543: PUSH
95544: LD_INT 18
95546: PUSH
95547: LD_INT 19
95549: PUSH
95550: LD_INT 20
95552: PUSH
95553: LD_INT 21
95555: PUSH
95556: LD_INT 22
95558: PUSH
95559: LD_INT 23
95561: PUSH
95562: LD_INT 24
95564: PUSH
95565: LD_INT 25
95567: PUSH
95568: LD_INT 26
95570: PUSH
95571: LD_INT 27
95573: PUSH
95574: LD_INT 28
95576: PUSH
95577: LD_INT 30
95579: PUSH
95580: LD_INT 31
95582: PUSH
95583: LD_INT 32
95585: PUSH
95586: LD_INT 33
95588: PUSH
95589: LD_INT 34
95591: PUSH
95592: LD_INT 36
95594: PUSH
95595: EMPTY
95596: LIST
95597: LIST
95598: LIST
95599: LIST
95600: LIST
95601: LIST
95602: LIST
95603: LIST
95604: LIST
95605: LIST
95606: LIST
95607: LIST
95608: LIST
95609: LIST
95610: LIST
95611: LIST
95612: LIST
95613: LIST
95614: LIST
95615: LIST
95616: LIST
95617: LIST
95618: LIST
95619: LIST
95620: LIST
95621: LIST
95622: LIST
95623: LIST
95624: LIST
95625: LIST
95626: LIST
95627: LIST
95628: LIST
95629: LIST
95630: PUSH
95631: LD_INT 101
95633: PUSH
95634: LD_INT 102
95636: PUSH
95637: LD_INT 103
95639: PUSH
95640: LD_INT 104
95642: PUSH
95643: LD_INT 105
95645: PUSH
95646: LD_INT 106
95648: PUSH
95649: LD_INT 107
95651: PUSH
95652: LD_INT 108
95654: PUSH
95655: LD_INT 109
95657: PUSH
95658: LD_INT 110
95660: PUSH
95661: LD_INT 111
95663: PUSH
95664: LD_INT 112
95666: PUSH
95667: LD_INT 113
95669: PUSH
95670: LD_INT 114
95672: PUSH
95673: LD_INT 116
95675: PUSH
95676: LD_INT 117
95678: PUSH
95679: LD_INT 118
95681: PUSH
95682: EMPTY
95683: LIST
95684: LIST
95685: LIST
95686: LIST
95687: LIST
95688: LIST
95689: LIST
95690: LIST
95691: LIST
95692: LIST
95693: LIST
95694: LIST
95695: LIST
95696: LIST
95697: LIST
95698: LIST
95699: LIST
95700: PUSH
95701: EMPTY
95702: LIST
95703: LIST
95704: ST_TO_ADDR
95705: GO 97160
95707: LD_INT 13
95709: DOUBLE
95710: EQUAL
95711: IFTRUE 95715
95713: GO 95923
95715: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 14 :
95716: LD_ADDR_VAR 0 2
95720: PUSH
95721: LD_INT 1
95723: PUSH
95724: LD_INT 2
95726: PUSH
95727: LD_INT 3
95729: PUSH
95730: LD_INT 4
95732: PUSH
95733: LD_INT 5
95735: PUSH
95736: LD_INT 8
95738: PUSH
95739: LD_INT 9
95741: PUSH
95742: LD_INT 10
95744: PUSH
95745: LD_INT 11
95747: PUSH
95748: LD_INT 12
95750: PUSH
95751: LD_INT 14
95753: PUSH
95754: LD_INT 15
95756: PUSH
95757: LD_INT 16
95759: PUSH
95760: LD_INT 17
95762: PUSH
95763: LD_INT 18
95765: PUSH
95766: LD_INT 19
95768: PUSH
95769: LD_INT 20
95771: PUSH
95772: LD_INT 21
95774: PUSH
95775: LD_INT 22
95777: PUSH
95778: LD_INT 23
95780: PUSH
95781: LD_INT 24
95783: PUSH
95784: LD_INT 25
95786: PUSH
95787: LD_INT 26
95789: PUSH
95790: LD_INT 27
95792: PUSH
95793: LD_INT 28
95795: PUSH
95796: LD_INT 30
95798: PUSH
95799: LD_INT 31
95801: PUSH
95802: LD_INT 32
95804: PUSH
95805: LD_INT 33
95807: PUSH
95808: LD_INT 34
95810: PUSH
95811: LD_INT 36
95813: PUSH
95814: EMPTY
95815: LIST
95816: LIST
95817: LIST
95818: LIST
95819: LIST
95820: LIST
95821: LIST
95822: LIST
95823: LIST
95824: LIST
95825: LIST
95826: LIST
95827: LIST
95828: LIST
95829: LIST
95830: LIST
95831: LIST
95832: LIST
95833: LIST
95834: LIST
95835: LIST
95836: LIST
95837: LIST
95838: LIST
95839: LIST
95840: LIST
95841: LIST
95842: LIST
95843: LIST
95844: LIST
95845: LIST
95846: PUSH
95847: LD_INT 101
95849: PUSH
95850: LD_INT 102
95852: PUSH
95853: LD_INT 103
95855: PUSH
95856: LD_INT 104
95858: PUSH
95859: LD_INT 105
95861: PUSH
95862: LD_INT 106
95864: PUSH
95865: LD_INT 107
95867: PUSH
95868: LD_INT 108
95870: PUSH
95871: LD_INT 109
95873: PUSH
95874: LD_INT 110
95876: PUSH
95877: LD_INT 111
95879: PUSH
95880: LD_INT 112
95882: PUSH
95883: LD_INT 113
95885: PUSH
95886: LD_INT 114
95888: PUSH
95889: LD_INT 116
95891: PUSH
95892: LD_INT 117
95894: PUSH
95895: LD_INT 118
95897: PUSH
95898: EMPTY
95899: LIST
95900: LIST
95901: LIST
95902: LIST
95903: LIST
95904: LIST
95905: LIST
95906: LIST
95907: LIST
95908: LIST
95909: LIST
95910: LIST
95911: LIST
95912: LIST
95913: LIST
95914: LIST
95915: LIST
95916: PUSH
95917: EMPTY
95918: LIST
95919: LIST
95920: ST_TO_ADDR
95921: GO 97160
95923: LD_INT 14
95925: DOUBLE
95926: EQUAL
95927: IFTRUE 95931
95929: GO 96155
95931: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 15 :
95932: LD_ADDR_VAR 0 2
95936: PUSH
95937: LD_INT 1
95939: PUSH
95940: LD_INT 2
95942: PUSH
95943: LD_INT 3
95945: PUSH
95946: LD_INT 4
95948: PUSH
95949: LD_INT 5
95951: PUSH
95952: LD_INT 6
95954: PUSH
95955: LD_INT 7
95957: PUSH
95958: LD_INT 8
95960: PUSH
95961: LD_INT 9
95963: PUSH
95964: LD_INT 10
95966: PUSH
95967: LD_INT 11
95969: PUSH
95970: LD_INT 12
95972: PUSH
95973: LD_INT 13
95975: PUSH
95976: LD_INT 14
95978: PUSH
95979: LD_INT 15
95981: PUSH
95982: LD_INT 16
95984: PUSH
95985: LD_INT 17
95987: PUSH
95988: LD_INT 18
95990: PUSH
95991: LD_INT 19
95993: PUSH
95994: LD_INT 20
95996: PUSH
95997: LD_INT 21
95999: PUSH
96000: LD_INT 22
96002: PUSH
96003: LD_INT 23
96005: PUSH
96006: LD_INT 24
96008: PUSH
96009: LD_INT 25
96011: PUSH
96012: LD_INT 26
96014: PUSH
96015: LD_INT 27
96017: PUSH
96018: LD_INT 28
96020: PUSH
96021: LD_INT 29
96023: PUSH
96024: LD_INT 30
96026: PUSH
96027: LD_INT 31
96029: PUSH
96030: LD_INT 32
96032: PUSH
96033: LD_INT 33
96035: PUSH
96036: LD_INT 34
96038: PUSH
96039: LD_INT 36
96041: PUSH
96042: EMPTY
96043: LIST
96044: LIST
96045: LIST
96046: LIST
96047: LIST
96048: LIST
96049: LIST
96050: LIST
96051: LIST
96052: LIST
96053: LIST
96054: LIST
96055: LIST
96056: LIST
96057: LIST
96058: LIST
96059: LIST
96060: LIST
96061: LIST
96062: LIST
96063: LIST
96064: LIST
96065: LIST
96066: LIST
96067: LIST
96068: LIST
96069: LIST
96070: LIST
96071: LIST
96072: LIST
96073: LIST
96074: LIST
96075: LIST
96076: LIST
96077: LIST
96078: PUSH
96079: LD_INT 101
96081: PUSH
96082: LD_INT 102
96084: PUSH
96085: LD_INT 103
96087: PUSH
96088: LD_INT 104
96090: PUSH
96091: LD_INT 105
96093: PUSH
96094: LD_INT 106
96096: PUSH
96097: LD_INT 107
96099: PUSH
96100: LD_INT 108
96102: PUSH
96103: LD_INT 109
96105: PUSH
96106: LD_INT 110
96108: PUSH
96109: LD_INT 111
96111: PUSH
96112: LD_INT 112
96114: PUSH
96115: LD_INT 113
96117: PUSH
96118: LD_INT 114
96120: PUSH
96121: LD_INT 116
96123: PUSH
96124: LD_INT 117
96126: PUSH
96127: LD_INT 118
96129: PUSH
96130: EMPTY
96131: LIST
96132: LIST
96133: LIST
96134: LIST
96135: LIST
96136: LIST
96137: LIST
96138: LIST
96139: LIST
96140: LIST
96141: LIST
96142: LIST
96143: LIST
96144: LIST
96145: LIST
96146: LIST
96147: LIST
96148: PUSH
96149: EMPTY
96150: LIST
96151: LIST
96152: ST_TO_ADDR
96153: GO 97160
96155: LD_INT 15
96157: DOUBLE
96158: EQUAL
96159: IFTRUE 96163
96161: GO 96387
96163: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 16 :
96164: LD_ADDR_VAR 0 2
96168: PUSH
96169: LD_INT 1
96171: PUSH
96172: LD_INT 2
96174: PUSH
96175: LD_INT 3
96177: PUSH
96178: LD_INT 4
96180: PUSH
96181: LD_INT 5
96183: PUSH
96184: LD_INT 6
96186: PUSH
96187: LD_INT 7
96189: PUSH
96190: LD_INT 8
96192: PUSH
96193: LD_INT 9
96195: PUSH
96196: LD_INT 10
96198: PUSH
96199: LD_INT 11
96201: PUSH
96202: LD_INT 12
96204: PUSH
96205: LD_INT 13
96207: PUSH
96208: LD_INT 14
96210: PUSH
96211: LD_INT 15
96213: PUSH
96214: LD_INT 16
96216: PUSH
96217: LD_INT 17
96219: PUSH
96220: LD_INT 18
96222: PUSH
96223: LD_INT 19
96225: PUSH
96226: LD_INT 20
96228: PUSH
96229: LD_INT 21
96231: PUSH
96232: LD_INT 22
96234: PUSH
96235: LD_INT 23
96237: PUSH
96238: LD_INT 24
96240: PUSH
96241: LD_INT 25
96243: PUSH
96244: LD_INT 26
96246: PUSH
96247: LD_INT 27
96249: PUSH
96250: LD_INT 28
96252: PUSH
96253: LD_INT 29
96255: PUSH
96256: LD_INT 30
96258: PUSH
96259: LD_INT 31
96261: PUSH
96262: LD_INT 32
96264: PUSH
96265: LD_INT 33
96267: PUSH
96268: LD_INT 34
96270: PUSH
96271: LD_INT 36
96273: PUSH
96274: EMPTY
96275: LIST
96276: LIST
96277: LIST
96278: LIST
96279: LIST
96280: LIST
96281: LIST
96282: LIST
96283: LIST
96284: LIST
96285: LIST
96286: LIST
96287: LIST
96288: LIST
96289: LIST
96290: LIST
96291: LIST
96292: LIST
96293: LIST
96294: LIST
96295: LIST
96296: LIST
96297: LIST
96298: LIST
96299: LIST
96300: LIST
96301: LIST
96302: LIST
96303: LIST
96304: LIST
96305: LIST
96306: LIST
96307: LIST
96308: LIST
96309: LIST
96310: PUSH
96311: LD_INT 101
96313: PUSH
96314: LD_INT 102
96316: PUSH
96317: LD_INT 103
96319: PUSH
96320: LD_INT 104
96322: PUSH
96323: LD_INT 105
96325: PUSH
96326: LD_INT 106
96328: PUSH
96329: LD_INT 107
96331: PUSH
96332: LD_INT 108
96334: PUSH
96335: LD_INT 109
96337: PUSH
96338: LD_INT 110
96340: PUSH
96341: LD_INT 111
96343: PUSH
96344: LD_INT 112
96346: PUSH
96347: LD_INT 113
96349: PUSH
96350: LD_INT 114
96352: PUSH
96353: LD_INT 116
96355: PUSH
96356: LD_INT 117
96358: PUSH
96359: LD_INT 118
96361: PUSH
96362: EMPTY
96363: LIST
96364: LIST
96365: LIST
96366: LIST
96367: LIST
96368: LIST
96369: LIST
96370: LIST
96371: LIST
96372: LIST
96373: LIST
96374: LIST
96375: LIST
96376: LIST
96377: LIST
96378: LIST
96379: LIST
96380: PUSH
96381: EMPTY
96382: LIST
96383: LIST
96384: ST_TO_ADDR
96385: GO 97160
96387: LD_INT 16
96389: DOUBLE
96390: EQUAL
96391: IFTRUE 96395
96393: GO 96531
96395: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 17 :
96396: LD_ADDR_VAR 0 2
96400: PUSH
96401: LD_INT 2
96403: PUSH
96404: LD_INT 4
96406: PUSH
96407: LD_INT 5
96409: PUSH
96410: LD_INT 7
96412: PUSH
96413: LD_INT 11
96415: PUSH
96416: LD_INT 12
96418: PUSH
96419: LD_INT 15
96421: PUSH
96422: LD_INT 16
96424: PUSH
96425: LD_INT 20
96427: PUSH
96428: LD_INT 21
96430: PUSH
96431: LD_INT 22
96433: PUSH
96434: LD_INT 23
96436: PUSH
96437: LD_INT 25
96439: PUSH
96440: LD_INT 26
96442: PUSH
96443: LD_INT 30
96445: PUSH
96446: LD_INT 31
96448: PUSH
96449: LD_INT 32
96451: PUSH
96452: LD_INT 33
96454: PUSH
96455: LD_INT 34
96457: PUSH
96458: EMPTY
96459: LIST
96460: LIST
96461: LIST
96462: LIST
96463: LIST
96464: LIST
96465: LIST
96466: LIST
96467: LIST
96468: LIST
96469: LIST
96470: LIST
96471: LIST
96472: LIST
96473: LIST
96474: LIST
96475: LIST
96476: LIST
96477: LIST
96478: PUSH
96479: LD_INT 101
96481: PUSH
96482: LD_INT 102
96484: PUSH
96485: LD_INT 103
96487: PUSH
96488: LD_INT 106
96490: PUSH
96491: LD_INT 108
96493: PUSH
96494: LD_INT 112
96496: PUSH
96497: LD_INT 113
96499: PUSH
96500: LD_INT 114
96502: PUSH
96503: LD_INT 116
96505: PUSH
96506: LD_INT 117
96508: PUSH
96509: LD_INT 118
96511: PUSH
96512: EMPTY
96513: LIST
96514: LIST
96515: LIST
96516: LIST
96517: LIST
96518: LIST
96519: LIST
96520: LIST
96521: LIST
96522: LIST
96523: LIST
96524: PUSH
96525: EMPTY
96526: LIST
96527: LIST
96528: ST_TO_ADDR
96529: GO 97160
96531: LD_INT 17
96533: DOUBLE
96534: EQUAL
96535: IFTRUE 96539
96537: GO 96763
96539: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 18 :
96540: LD_ADDR_VAR 0 2
96544: PUSH
96545: LD_INT 1
96547: PUSH
96548: LD_INT 2
96550: PUSH
96551: LD_INT 3
96553: PUSH
96554: LD_INT 4
96556: PUSH
96557: LD_INT 5
96559: PUSH
96560: LD_INT 6
96562: PUSH
96563: LD_INT 7
96565: PUSH
96566: LD_INT 8
96568: PUSH
96569: LD_INT 9
96571: PUSH
96572: LD_INT 10
96574: PUSH
96575: LD_INT 11
96577: PUSH
96578: LD_INT 12
96580: PUSH
96581: LD_INT 13
96583: PUSH
96584: LD_INT 14
96586: PUSH
96587: LD_INT 15
96589: PUSH
96590: LD_INT 16
96592: PUSH
96593: LD_INT 17
96595: PUSH
96596: LD_INT 18
96598: PUSH
96599: LD_INT 19
96601: PUSH
96602: LD_INT 20
96604: PUSH
96605: LD_INT 21
96607: PUSH
96608: LD_INT 22
96610: PUSH
96611: LD_INT 23
96613: PUSH
96614: LD_INT 24
96616: PUSH
96617: LD_INT 25
96619: PUSH
96620: LD_INT 26
96622: PUSH
96623: LD_INT 27
96625: PUSH
96626: LD_INT 28
96628: PUSH
96629: LD_INT 29
96631: PUSH
96632: LD_INT 30
96634: PUSH
96635: LD_INT 31
96637: PUSH
96638: LD_INT 32
96640: PUSH
96641: LD_INT 33
96643: PUSH
96644: LD_INT 34
96646: PUSH
96647: LD_INT 36
96649: PUSH
96650: EMPTY
96651: LIST
96652: LIST
96653: LIST
96654: LIST
96655: LIST
96656: LIST
96657: LIST
96658: LIST
96659: LIST
96660: LIST
96661: LIST
96662: LIST
96663: LIST
96664: LIST
96665: LIST
96666: LIST
96667: LIST
96668: LIST
96669: LIST
96670: LIST
96671: LIST
96672: LIST
96673: LIST
96674: LIST
96675: LIST
96676: LIST
96677: LIST
96678: LIST
96679: LIST
96680: LIST
96681: LIST
96682: LIST
96683: LIST
96684: LIST
96685: LIST
96686: PUSH
96687: LD_INT 101
96689: PUSH
96690: LD_INT 102
96692: PUSH
96693: LD_INT 103
96695: PUSH
96696: LD_INT 104
96698: PUSH
96699: LD_INT 105
96701: PUSH
96702: LD_INT 106
96704: PUSH
96705: LD_INT 107
96707: PUSH
96708: LD_INT 108
96710: PUSH
96711: LD_INT 109
96713: PUSH
96714: LD_INT 110
96716: PUSH
96717: LD_INT 111
96719: PUSH
96720: LD_INT 112
96722: PUSH
96723: LD_INT 113
96725: PUSH
96726: LD_INT 114
96728: PUSH
96729: LD_INT 116
96731: PUSH
96732: LD_INT 117
96734: PUSH
96735: LD_INT 118
96737: PUSH
96738: EMPTY
96739: LIST
96740: LIST
96741: LIST
96742: LIST
96743: LIST
96744: LIST
96745: LIST
96746: LIST
96747: LIST
96748: LIST
96749: LIST
96750: LIST
96751: LIST
96752: LIST
96753: LIST
96754: LIST
96755: LIST
96756: PUSH
96757: EMPTY
96758: LIST
96759: LIST
96760: ST_TO_ADDR
96761: GO 97160
96763: LD_INT 18
96765: DOUBLE
96766: EQUAL
96767: IFTRUE 96771
96769: GO 96919
96771: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; 19 :
96772: LD_ADDR_VAR 0 2
96776: PUSH
96777: LD_INT 2
96779: PUSH
96780: LD_INT 4
96782: PUSH
96783: LD_INT 5
96785: PUSH
96786: LD_INT 7
96788: PUSH
96789: LD_INT 11
96791: PUSH
96792: LD_INT 12
96794: PUSH
96795: LD_INT 15
96797: PUSH
96798: LD_INT 16
96800: PUSH
96801: LD_INT 20
96803: PUSH
96804: LD_INT 21
96806: PUSH
96807: LD_INT 22
96809: PUSH
96810: LD_INT 23
96812: PUSH
96813: LD_INT 25
96815: PUSH
96816: LD_INT 26
96818: PUSH
96819: LD_INT 30
96821: PUSH
96822: LD_INT 31
96824: PUSH
96825: LD_INT 32
96827: PUSH
96828: LD_INT 33
96830: PUSH
96831: LD_INT 34
96833: PUSH
96834: LD_INT 35
96836: PUSH
96837: LD_INT 36
96839: PUSH
96840: EMPTY
96841: LIST
96842: LIST
96843: LIST
96844: LIST
96845: LIST
96846: LIST
96847: LIST
96848: LIST
96849: LIST
96850: LIST
96851: LIST
96852: LIST
96853: LIST
96854: LIST
96855: LIST
96856: LIST
96857: LIST
96858: LIST
96859: LIST
96860: LIST
96861: LIST
96862: PUSH
96863: LD_INT 101
96865: PUSH
96866: LD_INT 102
96868: PUSH
96869: LD_INT 103
96871: PUSH
96872: LD_INT 106
96874: PUSH
96875: LD_INT 108
96877: PUSH
96878: LD_INT 112
96880: PUSH
96881: LD_INT 113
96883: PUSH
96884: LD_INT 114
96886: PUSH
96887: LD_INT 115
96889: PUSH
96890: LD_INT 116
96892: PUSH
96893: LD_INT 117
96895: PUSH
96896: LD_INT 118
96898: PUSH
96899: EMPTY
96900: LIST
96901: LIST
96902: LIST
96903: LIST
96904: LIST
96905: LIST
96906: LIST
96907: LIST
96908: LIST
96909: LIST
96910: LIST
96911: LIST
96912: PUSH
96913: EMPTY
96914: LIST
96915: LIST
96916: ST_TO_ADDR
96917: GO 97160
96919: LD_INT 19
96921: DOUBLE
96922: EQUAL
96923: IFTRUE 96927
96925: GO 97159
96927: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; end ;
96928: LD_ADDR_VAR 0 2
96932: PUSH
96933: LD_INT 1
96935: PUSH
96936: LD_INT 2
96938: PUSH
96939: LD_INT 3
96941: PUSH
96942: LD_INT 4
96944: PUSH
96945: LD_INT 5
96947: PUSH
96948: LD_INT 6
96950: PUSH
96951: LD_INT 7
96953: PUSH
96954: LD_INT 8
96956: PUSH
96957: LD_INT 9
96959: PUSH
96960: LD_INT 10
96962: PUSH
96963: LD_INT 11
96965: PUSH
96966: LD_INT 12
96968: PUSH
96969: LD_INT 13
96971: PUSH
96972: LD_INT 14
96974: PUSH
96975: LD_INT 15
96977: PUSH
96978: LD_INT 16
96980: PUSH
96981: LD_INT 17
96983: PUSH
96984: LD_INT 18
96986: PUSH
96987: LD_INT 19
96989: PUSH
96990: LD_INT 20
96992: PUSH
96993: LD_INT 21
96995: PUSH
96996: LD_INT 22
96998: PUSH
96999: LD_INT 23
97001: PUSH
97002: LD_INT 24
97004: PUSH
97005: LD_INT 25
97007: PUSH
97008: LD_INT 26
97010: PUSH
97011: LD_INT 27
97013: PUSH
97014: LD_INT 28
97016: PUSH
97017: LD_INT 29
97019: PUSH
97020: LD_INT 30
97022: PUSH
97023: LD_INT 31
97025: PUSH
97026: LD_INT 32
97028: PUSH
97029: LD_INT 33
97031: PUSH
97032: LD_INT 34
97034: PUSH
97035: LD_INT 35
97037: PUSH
97038: LD_INT 36
97040: PUSH
97041: EMPTY
97042: LIST
97043: LIST
97044: LIST
97045: LIST
97046: LIST
97047: LIST
97048: LIST
97049: LIST
97050: LIST
97051: LIST
97052: LIST
97053: LIST
97054: LIST
97055: LIST
97056: LIST
97057: LIST
97058: LIST
97059: LIST
97060: LIST
97061: LIST
97062: LIST
97063: LIST
97064: LIST
97065: LIST
97066: LIST
97067: LIST
97068: LIST
97069: LIST
97070: LIST
97071: LIST
97072: LIST
97073: LIST
97074: LIST
97075: LIST
97076: LIST
97077: LIST
97078: PUSH
97079: LD_INT 101
97081: PUSH
97082: LD_INT 102
97084: PUSH
97085: LD_INT 103
97087: PUSH
97088: LD_INT 104
97090: PUSH
97091: LD_INT 105
97093: PUSH
97094: LD_INT 106
97096: PUSH
97097: LD_INT 107
97099: PUSH
97100: LD_INT 108
97102: PUSH
97103: LD_INT 109
97105: PUSH
97106: LD_INT 110
97108: PUSH
97109: LD_INT 111
97111: PUSH
97112: LD_INT 112
97114: PUSH
97115: LD_INT 113
97117: PUSH
97118: LD_INT 114
97120: PUSH
97121: LD_INT 115
97123: PUSH
97124: LD_INT 116
97126: PUSH
97127: LD_INT 117
97129: PUSH
97130: LD_INT 118
97132: PUSH
97133: EMPTY
97134: LIST
97135: LIST
97136: LIST
97137: LIST
97138: LIST
97139: LIST
97140: LIST
97141: LIST
97142: LIST
97143: LIST
97144: LIST
97145: LIST
97146: LIST
97147: LIST
97148: LIST
97149: LIST
97150: LIST
97151: LIST
97152: PUSH
97153: EMPTY
97154: LIST
97155: LIST
97156: ST_TO_ADDR
97157: GO 97160
97159: POP
// end else
97160: GO 97391
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ;
97162: LD_ADDR_VAR 0 2
97166: PUSH
97167: LD_INT 1
97169: PUSH
97170: LD_INT 2
97172: PUSH
97173: LD_INT 3
97175: PUSH
97176: LD_INT 4
97178: PUSH
97179: LD_INT 5
97181: PUSH
97182: LD_INT 6
97184: PUSH
97185: LD_INT 7
97187: PUSH
97188: LD_INT 8
97190: PUSH
97191: LD_INT 9
97193: PUSH
97194: LD_INT 10
97196: PUSH
97197: LD_INT 11
97199: PUSH
97200: LD_INT 12
97202: PUSH
97203: LD_INT 13
97205: PUSH
97206: LD_INT 14
97208: PUSH
97209: LD_INT 15
97211: PUSH
97212: LD_INT 16
97214: PUSH
97215: LD_INT 17
97217: PUSH
97218: LD_INT 18
97220: PUSH
97221: LD_INT 19
97223: PUSH
97224: LD_INT 20
97226: PUSH
97227: LD_INT 21
97229: PUSH
97230: LD_INT 22
97232: PUSH
97233: LD_INT 23
97235: PUSH
97236: LD_INT 24
97238: PUSH
97239: LD_INT 25
97241: PUSH
97242: LD_INT 26
97244: PUSH
97245: LD_INT 27
97247: PUSH
97248: LD_INT 28
97250: PUSH
97251: LD_INT 29
97253: PUSH
97254: LD_INT 30
97256: PUSH
97257: LD_INT 31
97259: PUSH
97260: LD_INT 32
97262: PUSH
97263: LD_INT 33
97265: PUSH
97266: LD_INT 34
97268: PUSH
97269: LD_INT 35
97271: PUSH
97272: LD_INT 36
97274: PUSH
97275: EMPTY
97276: LIST
97277: LIST
97278: LIST
97279: LIST
97280: LIST
97281: LIST
97282: LIST
97283: LIST
97284: LIST
97285: LIST
97286: LIST
97287: LIST
97288: LIST
97289: LIST
97290: LIST
97291: LIST
97292: LIST
97293: LIST
97294: LIST
97295: LIST
97296: LIST
97297: LIST
97298: LIST
97299: LIST
97300: LIST
97301: LIST
97302: LIST
97303: LIST
97304: LIST
97305: LIST
97306: LIST
97307: LIST
97308: LIST
97309: LIST
97310: LIST
97311: LIST
97312: PUSH
97313: LD_INT 101
97315: PUSH
97316: LD_INT 102
97318: PUSH
97319: LD_INT 103
97321: PUSH
97322: LD_INT 104
97324: PUSH
97325: LD_INT 105
97327: PUSH
97328: LD_INT 106
97330: PUSH
97331: LD_INT 107
97333: PUSH
97334: LD_INT 108
97336: PUSH
97337: LD_INT 109
97339: PUSH
97340: LD_INT 110
97342: PUSH
97343: LD_INT 111
97345: PUSH
97346: LD_INT 112
97348: PUSH
97349: LD_INT 113
97351: PUSH
97352: LD_INT 114
97354: PUSH
97355: LD_INT 115
97357: PUSH
97358: LD_INT 116
97360: PUSH
97361: LD_INT 117
97363: PUSH
97364: LD_INT 118
97366: PUSH
97367: EMPTY
97368: LIST
97369: LIST
97370: LIST
97371: LIST
97372: LIST
97373: LIST
97374: LIST
97375: LIST
97376: LIST
97377: LIST
97378: LIST
97379: LIST
97380: LIST
97381: LIST
97382: LIST
97383: LIST
97384: LIST
97385: LIST
97386: PUSH
97387: EMPTY
97388: LIST
97389: LIST
97390: ST_TO_ADDR
// if result then
97391: LD_VAR 0 2
97395: IFFALSE 98181
// begin normal :=  ;
97397: LD_ADDR_VAR 0 5
97401: PUSH
97402: LD_STRING 
97404: ST_TO_ADDR
// hardcore :=  ;
97405: LD_ADDR_VAR 0 6
97409: PUSH
97410: LD_STRING 
97412: ST_TO_ADDR
// active :=  ;
97413: LD_ADDR_VAR 0 7
97417: PUSH
97418: LD_STRING 
97420: ST_TO_ADDR
// for i = 1 to normalCounter do
97421: LD_ADDR_VAR 0 8
97425: PUSH
97426: DOUBLE
97427: LD_INT 1
97429: DEC
97430: ST_TO_ADDR
97431: LD_EXP 78
97435: PUSH
97436: FOR_TO
97437: IFFALSE 97538
// begin tmp := 0 ;
97439: LD_ADDR_VAR 0 3
97443: PUSH
97444: LD_STRING 0
97446: ST_TO_ADDR
// if result [ 1 ] then
97447: LD_VAR 0 2
97451: PUSH
97452: LD_INT 1
97454: ARRAY
97455: IFFALSE 97520
// if result [ 1 ] [ 1 ] = i then
97457: LD_VAR 0 2
97461: PUSH
97462: LD_INT 1
97464: ARRAY
97465: PUSH
97466: LD_INT 1
97468: ARRAY
97469: PUSH
97470: LD_VAR 0 8
97474: EQUAL
97475: IFFALSE 97520
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
97477: LD_ADDR_VAR 0 2
97481: PUSH
97482: LD_VAR 0 2
97486: PPUSH
97487: LD_INT 1
97489: PPUSH
97490: LD_VAR 0 2
97494: PUSH
97495: LD_INT 1
97497: ARRAY
97498: PPUSH
97499: LD_INT 1
97501: PPUSH
97502: CALL_OW 3
97506: PPUSH
97507: CALL_OW 1
97511: ST_TO_ADDR
// tmp := 1 ;
97512: LD_ADDR_VAR 0 3
97516: PUSH
97517: LD_STRING 1
97519: ST_TO_ADDR
// end ; normal := normal & tmp ;
97520: LD_ADDR_VAR 0 5
97524: PUSH
97525: LD_VAR 0 5
97529: PUSH
97530: LD_VAR 0 3
97534: STR
97535: ST_TO_ADDR
// end ;
97536: GO 97436
97538: POP
97539: POP
// for i = 1 to hardcoreCounter do
97540: LD_ADDR_VAR 0 8
97544: PUSH
97545: DOUBLE
97546: LD_INT 1
97548: DEC
97549: ST_TO_ADDR
97550: LD_EXP 79
97554: PUSH
97555: FOR_TO
97556: IFFALSE 97661
// begin tmp := 0 ;
97558: LD_ADDR_VAR 0 3
97562: PUSH
97563: LD_STRING 0
97565: ST_TO_ADDR
// if result [ 2 ] then
97566: LD_VAR 0 2
97570: PUSH
97571: LD_INT 2
97573: ARRAY
97574: IFFALSE 97643
// if result [ 2 ] [ 1 ] = 100 + i then
97576: LD_VAR 0 2
97580: PUSH
97581: LD_INT 2
97583: ARRAY
97584: PUSH
97585: LD_INT 1
97587: ARRAY
97588: PUSH
97589: LD_INT 100
97591: PUSH
97592: LD_VAR 0 8
97596: PLUS
97597: EQUAL
97598: IFFALSE 97643
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
97600: LD_ADDR_VAR 0 2
97604: PUSH
97605: LD_VAR 0 2
97609: PPUSH
97610: LD_INT 2
97612: PPUSH
97613: LD_VAR 0 2
97617: PUSH
97618: LD_INT 2
97620: ARRAY
97621: PPUSH
97622: LD_INT 1
97624: PPUSH
97625: CALL_OW 3
97629: PPUSH
97630: CALL_OW 1
97634: ST_TO_ADDR
// tmp := 1 ;
97635: LD_ADDR_VAR 0 3
97639: PUSH
97640: LD_STRING 1
97642: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
97643: LD_ADDR_VAR 0 6
97647: PUSH
97648: LD_VAR 0 6
97652: PUSH
97653: LD_VAR 0 3
97657: STR
97658: ST_TO_ADDR
// end ;
97659: GO 97555
97661: POP
97662: POP
// if isGameLoad then
97663: LD_VAR 0 1
97667: IFFALSE 98142
// begin flags := [ sRocket , sSpeed , sEngine , sSpec , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sKamikadze , sTroll , sSlow , sLack , sTank , sRemote , sPowell , sTeleport , sOilTower , sShovel , sSheik , sEarthquake , sAI , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sSold , sDiff , sFog , sReset , sSun , sTiger , sBomb , sWound , sBetray , sContamin , sOil , sStu , sBazooka , sMortar , sRanger , sComputer , s30 , s60 ] ;
97669: LD_ADDR_VAR 0 4
97673: PUSH
97674: LD_EXP 82
97678: PUSH
97679: LD_EXP 81
97683: PUSH
97684: LD_EXP 83
97688: PUSH
97689: LD_EXP 80
97693: PUSH
97694: LD_EXP 84
97698: PUSH
97699: LD_EXP 85
97703: PUSH
97704: LD_EXP 86
97708: PUSH
97709: LD_EXP 87
97713: PUSH
97714: LD_EXP 88
97718: PUSH
97719: LD_EXP 89
97723: PUSH
97724: LD_EXP 90
97728: PUSH
97729: LD_EXP 91
97733: PUSH
97734: LD_EXP 92
97738: PUSH
97739: LD_EXP 93
97743: PUSH
97744: LD_EXP 101
97748: PUSH
97749: LD_EXP 102
97753: PUSH
97754: LD_EXP 103
97758: PUSH
97759: LD_EXP 104
97763: PUSH
97764: LD_EXP 106
97768: PUSH
97769: LD_EXP 107
97773: PUSH
97774: LD_EXP 108
97778: PUSH
97779: LD_EXP 111
97783: PUSH
97784: LD_EXP 113
97788: PUSH
97789: LD_EXP 114
97793: PUSH
97794: LD_EXP 115
97798: PUSH
97799: LD_EXP 117
97803: PUSH
97804: LD_EXP 118
97808: PUSH
97809: LD_EXP 121
97813: PUSH
97814: LD_EXP 122
97818: PUSH
97819: LD_EXP 123
97823: PUSH
97824: LD_EXP 124
97828: PUSH
97829: LD_EXP 125
97833: PUSH
97834: LD_EXP 126
97838: PUSH
97839: LD_EXP 127
97843: PUSH
97844: LD_EXP 128
97848: PUSH
97849: LD_EXP 129
97853: PUSH
97854: LD_EXP 94
97858: PUSH
97859: LD_EXP 95
97863: PUSH
97864: LD_EXP 98
97868: PUSH
97869: LD_EXP 99
97873: PUSH
97874: LD_EXP 100
97878: PUSH
97879: LD_EXP 96
97883: PUSH
97884: LD_EXP 97
97888: PUSH
97889: LD_EXP 105
97893: PUSH
97894: LD_EXP 109
97898: PUSH
97899: LD_EXP 110
97903: PUSH
97904: LD_EXP 112
97908: PUSH
97909: LD_EXP 116
97913: PUSH
97914: LD_EXP 119
97918: PUSH
97919: LD_EXP 120
97923: PUSH
97924: LD_EXP 130
97928: PUSH
97929: LD_EXP 131
97933: PUSH
97934: LD_EXP 132
97938: PUSH
97939: LD_EXP 133
97943: PUSH
97944: EMPTY
97945: LIST
97946: LIST
97947: LIST
97948: LIST
97949: LIST
97950: LIST
97951: LIST
97952: LIST
97953: LIST
97954: LIST
97955: LIST
97956: LIST
97957: LIST
97958: LIST
97959: LIST
97960: LIST
97961: LIST
97962: LIST
97963: LIST
97964: LIST
97965: LIST
97966: LIST
97967: LIST
97968: LIST
97969: LIST
97970: LIST
97971: LIST
97972: LIST
97973: LIST
97974: LIST
97975: LIST
97976: LIST
97977: LIST
97978: LIST
97979: LIST
97980: LIST
97981: LIST
97982: LIST
97983: LIST
97984: LIST
97985: LIST
97986: LIST
97987: LIST
97988: LIST
97989: LIST
97990: LIST
97991: LIST
97992: LIST
97993: LIST
97994: LIST
97995: LIST
97996: LIST
97997: LIST
97998: LIST
97999: ST_TO_ADDR
// tmp :=  ;
98000: LD_ADDR_VAR 0 3
98004: PUSH
98005: LD_STRING 
98007: ST_TO_ADDR
// for i = 1 to normalCounter do
98008: LD_ADDR_VAR 0 8
98012: PUSH
98013: DOUBLE
98014: LD_INT 1
98016: DEC
98017: ST_TO_ADDR
98018: LD_EXP 78
98022: PUSH
98023: FOR_TO
98024: IFFALSE 98060
// begin if flags [ i ] then
98026: LD_VAR 0 4
98030: PUSH
98031: LD_VAR 0 8
98035: ARRAY
98036: IFFALSE 98058
// tmp := tmp & i & ; ;
98038: LD_ADDR_VAR 0 3
98042: PUSH
98043: LD_VAR 0 3
98047: PUSH
98048: LD_VAR 0 8
98052: STR
98053: PUSH
98054: LD_STRING ;
98056: STR
98057: ST_TO_ADDR
// end ;
98058: GO 98023
98060: POP
98061: POP
// for i = 1 to hardcoreCounter do
98062: LD_ADDR_VAR 0 8
98066: PUSH
98067: DOUBLE
98068: LD_INT 1
98070: DEC
98071: ST_TO_ADDR
98072: LD_EXP 79
98076: PUSH
98077: FOR_TO
98078: IFFALSE 98124
// begin if flags [ normalCounter + i ] then
98080: LD_VAR 0 4
98084: PUSH
98085: LD_EXP 78
98089: PUSH
98090: LD_VAR 0 8
98094: PLUS
98095: ARRAY
98096: IFFALSE 98122
// tmp := tmp & ( 100 + i ) & ; ;
98098: LD_ADDR_VAR 0 3
98102: PUSH
98103: LD_VAR 0 3
98107: PUSH
98108: LD_INT 100
98110: PUSH
98111: LD_VAR 0 8
98115: PLUS
98116: STR
98117: PUSH
98118: LD_STRING ;
98120: STR
98121: ST_TO_ADDR
// end ;
98122: GO 98077
98124: POP
98125: POP
// if tmp then
98126: LD_VAR 0 3
98130: IFFALSE 98142
// active := tmp ;
98132: LD_ADDR_VAR 0 7
98136: PUSH
98137: LD_VAR 0 3
98141: ST_TO_ADDR
// end ; ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & "," & active & ") ) ;
98142: LD_STRING getStreamItemsFromMission("
98144: PUSH
98145: LD_VAR 0 5
98149: STR
98150: PUSH
98151: LD_STRING ","
98153: STR
98154: PUSH
98155: LD_VAR 0 6
98159: STR
98160: PUSH
98161: LD_STRING ","
98163: STR
98164: PUSH
98165: LD_VAR 0 7
98169: STR
98170: PUSH
98171: LD_STRING ")
98173: STR
98174: PPUSH
98175: CALL_OW 559
// end else
98179: GO 98188
// ToLua ( getStreamItemsFromMission("","","") ) ;
98181: LD_STRING getStreamItemsFromMission("","","")
98183: PPUSH
98184: CALL_OW 559
// end ;
98188: LD_VAR 0 2
98192: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
98193: LD_EXP 77
98197: PUSH
98198: LD_EXP 82
98202: AND
98203: IFFALSE 98327
98205: GO 98207
98207: DISABLE
98208: LD_INT 0
98210: PPUSH
98211: PPUSH
// begin enable ;
98212: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
98213: LD_ADDR_VAR 0 2
98217: PUSH
98218: LD_INT 22
98220: PUSH
98221: LD_OWVAR 2
98225: PUSH
98226: EMPTY
98227: LIST
98228: LIST
98229: PUSH
98230: LD_INT 2
98232: PUSH
98233: LD_INT 34
98235: PUSH
98236: LD_INT 7
98238: PUSH
98239: EMPTY
98240: LIST
98241: LIST
98242: PUSH
98243: LD_INT 34
98245: PUSH
98246: LD_INT 45
98248: PUSH
98249: EMPTY
98250: LIST
98251: LIST
98252: PUSH
98253: LD_INT 34
98255: PUSH
98256: LD_INT 28
98258: PUSH
98259: EMPTY
98260: LIST
98261: LIST
98262: PUSH
98263: LD_INT 34
98265: PUSH
98266: LD_INT 47
98268: PUSH
98269: EMPTY
98270: LIST
98271: LIST
98272: PUSH
98273: EMPTY
98274: LIST
98275: LIST
98276: LIST
98277: LIST
98278: LIST
98279: PUSH
98280: EMPTY
98281: LIST
98282: LIST
98283: PPUSH
98284: CALL_OW 69
98288: ST_TO_ADDR
// if not tmp then
98289: LD_VAR 0 2
98293: NOT
98294: IFFALSE 98298
// exit ;
98296: GO 98327
// for i in tmp do
98298: LD_ADDR_VAR 0 1
98302: PUSH
98303: LD_VAR 0 2
98307: PUSH
98308: FOR_IN
98309: IFFALSE 98325
// begin SetLives ( i , 0 ) ;
98311: LD_VAR 0 1
98315: PPUSH
98316: LD_INT 0
98318: PPUSH
98319: CALL_OW 234
// end ;
98323: GO 98308
98325: POP
98326: POP
// end ;
98327: PPOPN 2
98329: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
98330: LD_EXP 77
98334: PUSH
98335: LD_EXP 83
98339: AND
98340: IFFALSE 98424
98342: GO 98344
98344: DISABLE
98345: LD_INT 0
98347: PPUSH
98348: PPUSH
// begin enable ;
98349: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
98350: LD_ADDR_VAR 0 2
98354: PUSH
98355: LD_INT 22
98357: PUSH
98358: LD_OWVAR 2
98362: PUSH
98363: EMPTY
98364: LIST
98365: LIST
98366: PUSH
98367: LD_INT 32
98369: PUSH
98370: LD_INT 3
98372: PUSH
98373: EMPTY
98374: LIST
98375: LIST
98376: PUSH
98377: EMPTY
98378: LIST
98379: LIST
98380: PPUSH
98381: CALL_OW 69
98385: ST_TO_ADDR
// if not tmp then
98386: LD_VAR 0 2
98390: NOT
98391: IFFALSE 98395
// exit ;
98393: GO 98424
// for i in tmp do
98395: LD_ADDR_VAR 0 1
98399: PUSH
98400: LD_VAR 0 2
98404: PUSH
98405: FOR_IN
98406: IFFALSE 98422
// begin SetLives ( i , 0 ) ;
98408: LD_VAR 0 1
98412: PPUSH
98413: LD_INT 0
98415: PPUSH
98416: CALL_OW 234
// end ;
98420: GO 98405
98422: POP
98423: POP
// end ;
98424: PPOPN 2
98426: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
98427: LD_EXP 77
98431: PUSH
98432: LD_EXP 80
98436: AND
98437: IFFALSE 98530
98439: GO 98441
98441: DISABLE
98442: LD_INT 0
98444: PPUSH
// begin enable ;
98445: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
98446: LD_ADDR_VAR 0 1
98450: PUSH
98451: LD_INT 22
98453: PUSH
98454: LD_OWVAR 2
98458: PUSH
98459: EMPTY
98460: LIST
98461: LIST
98462: PUSH
98463: LD_INT 2
98465: PUSH
98466: LD_INT 25
98468: PUSH
98469: LD_INT 5
98471: PUSH
98472: EMPTY
98473: LIST
98474: LIST
98475: PUSH
98476: LD_INT 25
98478: PUSH
98479: LD_INT 9
98481: PUSH
98482: EMPTY
98483: LIST
98484: LIST
98485: PUSH
98486: LD_INT 25
98488: PUSH
98489: LD_INT 8
98491: PUSH
98492: EMPTY
98493: LIST
98494: LIST
98495: PUSH
98496: EMPTY
98497: LIST
98498: LIST
98499: LIST
98500: LIST
98501: PUSH
98502: EMPTY
98503: LIST
98504: LIST
98505: PPUSH
98506: CALL_OW 69
98510: PUSH
98511: FOR_IN
98512: IFFALSE 98528
// begin SetClass ( i , 1 ) ;
98514: LD_VAR 0 1
98518: PPUSH
98519: LD_INT 1
98521: PPUSH
98522: CALL_OW 336
// end ;
98526: GO 98511
98528: POP
98529: POP
// end ;
98530: PPOPN 1
98532: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
98533: LD_EXP 77
98537: PUSH
98538: LD_EXP 81
98542: AND
98543: PUSH
98544: LD_OWVAR 65
98548: PUSH
98549: LD_INT 7
98551: LESS
98552: AND
98553: IFFALSE 98567
98555: GO 98557
98557: DISABLE
// begin enable ;
98558: ENABLE
// game_speed := 7 ;
98559: LD_ADDR_OWVAR 65
98563: PUSH
98564: LD_INT 7
98566: ST_TO_ADDR
// end ;
98567: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
98568: LD_EXP 77
98572: PUSH
98573: LD_EXP 84
98577: AND
98578: IFFALSE 98780
98580: GO 98582
98582: DISABLE
98583: LD_INT 0
98585: PPUSH
98586: PPUSH
98587: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
98588: LD_ADDR_VAR 0 3
98592: PUSH
98593: LD_INT 81
98595: PUSH
98596: LD_OWVAR 2
98600: PUSH
98601: EMPTY
98602: LIST
98603: LIST
98604: PUSH
98605: LD_INT 21
98607: PUSH
98608: LD_INT 1
98610: PUSH
98611: EMPTY
98612: LIST
98613: LIST
98614: PUSH
98615: EMPTY
98616: LIST
98617: LIST
98618: PPUSH
98619: CALL_OW 69
98623: ST_TO_ADDR
// if not tmp then
98624: LD_VAR 0 3
98628: NOT
98629: IFFALSE 98633
// exit ;
98631: GO 98780
// if tmp > 5 then
98633: LD_VAR 0 3
98637: PUSH
98638: LD_INT 5
98640: GREATER
98641: IFFALSE 98653
// k := 5 else
98643: LD_ADDR_VAR 0 2
98647: PUSH
98648: LD_INT 5
98650: ST_TO_ADDR
98651: GO 98663
// k := tmp ;
98653: LD_ADDR_VAR 0 2
98657: PUSH
98658: LD_VAR 0 3
98662: ST_TO_ADDR
// for i := 1 to k do
98663: LD_ADDR_VAR 0 1
98667: PUSH
98668: DOUBLE
98669: LD_INT 1
98671: DEC
98672: ST_TO_ADDR
98673: LD_VAR 0 2
98677: PUSH
98678: FOR_TO
98679: IFFALSE 98778
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
98681: LD_VAR 0 3
98685: PUSH
98686: LD_VAR 0 1
98690: ARRAY
98691: PPUSH
98692: LD_VAR 0 1
98696: PUSH
98697: LD_INT 4
98699: MOD
98700: PUSH
98701: LD_INT 1
98703: PLUS
98704: PPUSH
98705: CALL_OW 259
98709: PUSH
98710: LD_INT 10
98712: LESS
98713: IFFALSE 98776
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
98715: LD_VAR 0 3
98719: PUSH
98720: LD_VAR 0 1
98724: ARRAY
98725: PPUSH
98726: LD_VAR 0 1
98730: PUSH
98731: LD_INT 4
98733: MOD
98734: PUSH
98735: LD_INT 1
98737: PLUS
98738: PPUSH
98739: LD_VAR 0 3
98743: PUSH
98744: LD_VAR 0 1
98748: ARRAY
98749: PPUSH
98750: LD_VAR 0 1
98754: PUSH
98755: LD_INT 4
98757: MOD
98758: PUSH
98759: LD_INT 1
98761: PLUS
98762: PPUSH
98763: CALL_OW 259
98767: PUSH
98768: LD_INT 1
98770: PLUS
98771: PPUSH
98772: CALL_OW 237
98776: GO 98678
98778: POP
98779: POP
// end ;
98780: PPOPN 3
98782: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
98783: LD_EXP 77
98787: PUSH
98788: LD_EXP 85
98792: AND
98793: IFFALSE 98813
98795: GO 98797
98797: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
98798: LD_INT 4
98800: PPUSH
98801: LD_OWVAR 2
98805: PPUSH
98806: LD_INT 0
98808: PPUSH
98809: CALL_OW 324
98813: END
// every 0 0$1 trigger StreamModeActive and sShovel do
98814: LD_EXP 77
98818: PUSH
98819: LD_EXP 114
98823: AND
98824: IFFALSE 98844
98826: GO 98828
98828: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
98829: LD_INT 19
98831: PPUSH
98832: LD_OWVAR 2
98836: PPUSH
98837: LD_INT 0
98839: PPUSH
98840: CALL_OW 324
98844: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
98845: LD_EXP 77
98849: PUSH
98850: LD_EXP 86
98854: AND
98855: IFFALSE 98957
98857: GO 98859
98859: DISABLE
98860: LD_INT 0
98862: PPUSH
98863: PPUSH
// begin enable ;
98864: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
98865: LD_ADDR_VAR 0 2
98869: PUSH
98870: LD_INT 22
98872: PUSH
98873: LD_OWVAR 2
98877: PUSH
98878: EMPTY
98879: LIST
98880: LIST
98881: PUSH
98882: LD_INT 2
98884: PUSH
98885: LD_INT 34
98887: PUSH
98888: LD_INT 11
98890: PUSH
98891: EMPTY
98892: LIST
98893: LIST
98894: PUSH
98895: LD_INT 34
98897: PUSH
98898: LD_INT 30
98900: PUSH
98901: EMPTY
98902: LIST
98903: LIST
98904: PUSH
98905: EMPTY
98906: LIST
98907: LIST
98908: LIST
98909: PUSH
98910: EMPTY
98911: LIST
98912: LIST
98913: PPUSH
98914: CALL_OW 69
98918: ST_TO_ADDR
// if not tmp then
98919: LD_VAR 0 2
98923: NOT
98924: IFFALSE 98928
// exit ;
98926: GO 98957
// for i in tmp do
98928: LD_ADDR_VAR 0 1
98932: PUSH
98933: LD_VAR 0 2
98937: PUSH
98938: FOR_IN
98939: IFFALSE 98955
// begin SetLives ( i , 0 ) ;
98941: LD_VAR 0 1
98945: PPUSH
98946: LD_INT 0
98948: PPUSH
98949: CALL_OW 234
// end ;
98953: GO 98938
98955: POP
98956: POP
// end ;
98957: PPOPN 2
98959: END
// every 0 0$1 trigger StreamModeActive and sBunker do
98960: LD_EXP 77
98964: PUSH
98965: LD_EXP 87
98969: AND
98970: IFFALSE 98990
98972: GO 98974
98974: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
98975: LD_INT 32
98977: PPUSH
98978: LD_OWVAR 2
98982: PPUSH
98983: LD_INT 0
98985: PPUSH
98986: CALL_OW 324
98990: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
98991: LD_EXP 77
98995: PUSH
98996: LD_EXP 88
99000: AND
99001: IFFALSE 99182
99003: GO 99005
99005: DISABLE
99006: LD_INT 0
99008: PPUSH
99009: PPUSH
99010: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
99011: LD_ADDR_VAR 0 2
99015: PUSH
99016: LD_INT 22
99018: PUSH
99019: LD_OWVAR 2
99023: PUSH
99024: EMPTY
99025: LIST
99026: LIST
99027: PUSH
99028: LD_INT 33
99030: PUSH
99031: LD_INT 3
99033: PUSH
99034: EMPTY
99035: LIST
99036: LIST
99037: PUSH
99038: EMPTY
99039: LIST
99040: LIST
99041: PPUSH
99042: CALL_OW 69
99046: ST_TO_ADDR
// if not tmp then
99047: LD_VAR 0 2
99051: NOT
99052: IFFALSE 99056
// exit ;
99054: GO 99182
// side := 0 ;
99056: LD_ADDR_VAR 0 3
99060: PUSH
99061: LD_INT 0
99063: ST_TO_ADDR
// for i := 1 to 8 do
99064: LD_ADDR_VAR 0 1
99068: PUSH
99069: DOUBLE
99070: LD_INT 1
99072: DEC
99073: ST_TO_ADDR
99074: LD_INT 8
99076: PUSH
99077: FOR_TO
99078: IFFALSE 99126
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
99080: LD_OWVAR 2
99084: PUSH
99085: LD_VAR 0 1
99089: NONEQUAL
99090: PUSH
99091: LD_OWVAR 2
99095: PPUSH
99096: LD_VAR 0 1
99100: PPUSH
99101: CALL_OW 81
99105: PUSH
99106: LD_INT 2
99108: EQUAL
99109: AND
99110: IFFALSE 99124
// begin side := i ;
99112: LD_ADDR_VAR 0 3
99116: PUSH
99117: LD_VAR 0 1
99121: ST_TO_ADDR
// break ;
99122: GO 99126
// end ;
99124: GO 99077
99126: POP
99127: POP
// if not side then
99128: LD_VAR 0 3
99132: NOT
99133: IFFALSE 99137
// exit ;
99135: GO 99182
// for i := 1 to tmp do
99137: LD_ADDR_VAR 0 1
99141: PUSH
99142: DOUBLE
99143: LD_INT 1
99145: DEC
99146: ST_TO_ADDR
99147: LD_VAR 0 2
99151: PUSH
99152: FOR_TO
99153: IFFALSE 99180
// if Prob ( 60 ) then
99155: LD_INT 60
99157: PPUSH
99158: CALL_OW 13
99162: IFFALSE 99178
// SetSide ( i , side ) ;
99164: LD_VAR 0 1
99168: PPUSH
99169: LD_VAR 0 3
99173: PPUSH
99174: CALL_OW 235
99178: GO 99152
99180: POP
99181: POP
// end ;
99182: PPOPN 3
99184: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
99185: LD_EXP 77
99189: PUSH
99190: LD_EXP 90
99194: AND
99195: IFFALSE 99314
99197: GO 99199
99199: DISABLE
99200: LD_INT 0
99202: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
99203: LD_ADDR_VAR 0 1
99207: PUSH
99208: LD_INT 22
99210: PUSH
99211: LD_OWVAR 2
99215: PUSH
99216: EMPTY
99217: LIST
99218: LIST
99219: PUSH
99220: LD_INT 21
99222: PUSH
99223: LD_INT 1
99225: PUSH
99226: EMPTY
99227: LIST
99228: LIST
99229: PUSH
99230: LD_INT 3
99232: PUSH
99233: LD_INT 23
99235: PUSH
99236: LD_INT 0
99238: PUSH
99239: EMPTY
99240: LIST
99241: LIST
99242: PUSH
99243: EMPTY
99244: LIST
99245: LIST
99246: PUSH
99247: EMPTY
99248: LIST
99249: LIST
99250: LIST
99251: PPUSH
99252: CALL_OW 69
99256: PUSH
99257: FOR_IN
99258: IFFALSE 99312
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
99260: LD_VAR 0 1
99264: PPUSH
99265: CALL_OW 257
99269: PUSH
99270: LD_INT 1
99272: PUSH
99273: LD_INT 2
99275: PUSH
99276: LD_INT 3
99278: PUSH
99279: LD_INT 4
99281: PUSH
99282: EMPTY
99283: LIST
99284: LIST
99285: LIST
99286: LIST
99287: IN
99288: IFFALSE 99310
// SetClass ( un , rand ( 1 , 4 ) ) ;
99290: LD_VAR 0 1
99294: PPUSH
99295: LD_INT 1
99297: PPUSH
99298: LD_INT 4
99300: PPUSH
99301: CALL_OW 12
99305: PPUSH
99306: CALL_OW 336
99310: GO 99257
99312: POP
99313: POP
// end ;
99314: PPOPN 1
99316: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
99317: LD_EXP 77
99321: PUSH
99322: LD_EXP 89
99326: AND
99327: IFFALSE 99406
99329: GO 99331
99331: DISABLE
99332: LD_INT 0
99334: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
99335: LD_ADDR_VAR 0 1
99339: PUSH
99340: LD_INT 22
99342: PUSH
99343: LD_OWVAR 2
99347: PUSH
99348: EMPTY
99349: LIST
99350: LIST
99351: PUSH
99352: LD_INT 21
99354: PUSH
99355: LD_INT 3
99357: PUSH
99358: EMPTY
99359: LIST
99360: LIST
99361: PUSH
99362: EMPTY
99363: LIST
99364: LIST
99365: PPUSH
99366: CALL_OW 69
99370: ST_TO_ADDR
// if not tmp then
99371: LD_VAR 0 1
99375: NOT
99376: IFFALSE 99380
// exit ;
99378: GO 99406
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
99380: LD_VAR 0 1
99384: PUSH
99385: LD_INT 1
99387: PPUSH
99388: LD_VAR 0 1
99392: PPUSH
99393: CALL_OW 12
99397: ARRAY
99398: PPUSH
99399: LD_INT 100
99401: PPUSH
99402: CALL_OW 234
// end ;
99406: PPOPN 1
99408: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
99409: LD_EXP 77
99413: PUSH
99414: LD_EXP 91
99418: AND
99419: IFFALSE 99517
99421: GO 99423
99423: DISABLE
99424: LD_INT 0
99426: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
99427: LD_ADDR_VAR 0 1
99431: PUSH
99432: LD_INT 22
99434: PUSH
99435: LD_OWVAR 2
99439: PUSH
99440: EMPTY
99441: LIST
99442: LIST
99443: PUSH
99444: LD_INT 21
99446: PUSH
99447: LD_INT 1
99449: PUSH
99450: EMPTY
99451: LIST
99452: LIST
99453: PUSH
99454: EMPTY
99455: LIST
99456: LIST
99457: PPUSH
99458: CALL_OW 69
99462: ST_TO_ADDR
// if not tmp then
99463: LD_VAR 0 1
99467: NOT
99468: IFFALSE 99472
// exit ;
99470: GO 99517
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
99472: LD_VAR 0 1
99476: PUSH
99477: LD_INT 1
99479: PPUSH
99480: LD_VAR 0 1
99484: PPUSH
99485: CALL_OW 12
99489: ARRAY
99490: PPUSH
99491: LD_INT 1
99493: PPUSH
99494: LD_INT 4
99496: PPUSH
99497: CALL_OW 12
99501: PPUSH
99502: LD_INT 3000
99504: PPUSH
99505: LD_INT 9000
99507: PPUSH
99508: CALL_OW 12
99512: PPUSH
99513: CALL_OW 492
// end ;
99517: PPOPN 1
99519: END
// every 0 0$1 trigger StreamModeActive and sDepot do
99520: LD_EXP 77
99524: PUSH
99525: LD_EXP 92
99529: AND
99530: IFFALSE 99550
99532: GO 99534
99534: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
99535: LD_INT 1
99537: PPUSH
99538: LD_OWVAR 2
99542: PPUSH
99543: LD_INT 0
99545: PPUSH
99546: CALL_OW 324
99550: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
99551: LD_EXP 77
99555: PUSH
99556: LD_EXP 93
99560: AND
99561: IFFALSE 99644
99563: GO 99565
99565: DISABLE
99566: LD_INT 0
99568: PPUSH
99569: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
99570: LD_ADDR_VAR 0 2
99574: PUSH
99575: LD_INT 22
99577: PUSH
99578: LD_OWVAR 2
99582: PUSH
99583: EMPTY
99584: LIST
99585: LIST
99586: PUSH
99587: LD_INT 21
99589: PUSH
99590: LD_INT 3
99592: PUSH
99593: EMPTY
99594: LIST
99595: LIST
99596: PUSH
99597: EMPTY
99598: LIST
99599: LIST
99600: PPUSH
99601: CALL_OW 69
99605: ST_TO_ADDR
// if not tmp then
99606: LD_VAR 0 2
99610: NOT
99611: IFFALSE 99615
// exit ;
99613: GO 99644
// for i in tmp do
99615: LD_ADDR_VAR 0 1
99619: PUSH
99620: LD_VAR 0 2
99624: PUSH
99625: FOR_IN
99626: IFFALSE 99642
// SetBLevel ( i , 10 ) ;
99628: LD_VAR 0 1
99632: PPUSH
99633: LD_INT 10
99635: PPUSH
99636: CALL_OW 241
99640: GO 99625
99642: POP
99643: POP
// end ;
99644: PPOPN 2
99646: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
99647: LD_EXP 77
99651: PUSH
99652: LD_EXP 94
99656: AND
99657: IFFALSE 99768
99659: GO 99661
99661: DISABLE
99662: LD_INT 0
99664: PPUSH
99665: PPUSH
99666: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
99667: LD_ADDR_VAR 0 3
99671: PUSH
99672: LD_INT 22
99674: PUSH
99675: LD_OWVAR 2
99679: PUSH
99680: EMPTY
99681: LIST
99682: LIST
99683: PUSH
99684: LD_INT 25
99686: PUSH
99687: LD_INT 1
99689: PUSH
99690: EMPTY
99691: LIST
99692: LIST
99693: PUSH
99694: EMPTY
99695: LIST
99696: LIST
99697: PPUSH
99698: CALL_OW 69
99702: ST_TO_ADDR
// if not tmp then
99703: LD_VAR 0 3
99707: NOT
99708: IFFALSE 99712
// exit ;
99710: GO 99768
// un := tmp [ rand ( 1 , tmp ) ] ;
99712: LD_ADDR_VAR 0 2
99716: PUSH
99717: LD_VAR 0 3
99721: PUSH
99722: LD_INT 1
99724: PPUSH
99725: LD_VAR 0 3
99729: PPUSH
99730: CALL_OW 12
99734: ARRAY
99735: ST_TO_ADDR
// if Crawls ( un ) then
99736: LD_VAR 0 2
99740: PPUSH
99741: CALL_OW 318
99745: IFFALSE 99756
// ComWalk ( un ) ;
99747: LD_VAR 0 2
99751: PPUSH
99752: CALL_OW 138
// SetClass ( un , class_sniper ) ;
99756: LD_VAR 0 2
99760: PPUSH
99761: LD_INT 5
99763: PPUSH
99764: CALL_OW 336
// end ;
99768: PPOPN 3
99770: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 4 do
99771: LD_EXP 77
99775: PUSH
99776: LD_EXP 95
99780: AND
99781: PUSH
99782: LD_OWVAR 67
99786: PUSH
99787: LD_INT 4
99789: LESS
99790: AND
99791: IFFALSE 99810
99793: GO 99795
99795: DISABLE
// begin Difficulty := Difficulty + 1 ;
99796: LD_ADDR_OWVAR 67
99800: PUSH
99801: LD_OWVAR 67
99805: PUSH
99806: LD_INT 1
99808: PLUS
99809: ST_TO_ADDR
// end ;
99810: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
99811: LD_EXP 77
99815: PUSH
99816: LD_EXP 96
99820: AND
99821: IFFALSE 99924
99823: GO 99825
99825: DISABLE
99826: LD_INT 0
99828: PPUSH
// begin for i := 1 to 5 do
99829: LD_ADDR_VAR 0 1
99833: PUSH
99834: DOUBLE
99835: LD_INT 1
99837: DEC
99838: ST_TO_ADDR
99839: LD_INT 5
99841: PUSH
99842: FOR_TO
99843: IFFALSE 99922
// begin uc_nation := nation_nature ;
99845: LD_ADDR_OWVAR 21
99849: PUSH
99850: LD_INT 0
99852: ST_TO_ADDR
// uc_side := 0 ;
99853: LD_ADDR_OWVAR 20
99857: PUSH
99858: LD_INT 0
99860: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
99861: LD_ADDR_OWVAR 29
99865: PUSH
99866: LD_INT 12
99868: PUSH
99869: LD_INT 12
99871: PUSH
99872: EMPTY
99873: LIST
99874: LIST
99875: ST_TO_ADDR
// hc_agressivity := 20 ;
99876: LD_ADDR_OWVAR 35
99880: PUSH
99881: LD_INT 20
99883: ST_TO_ADDR
// hc_class := class_tiger ;
99884: LD_ADDR_OWVAR 28
99888: PUSH
99889: LD_INT 14
99891: ST_TO_ADDR
// hc_gallery :=  ;
99892: LD_ADDR_OWVAR 33
99896: PUSH
99897: LD_STRING 
99899: ST_TO_ADDR
// hc_name :=  ;
99900: LD_ADDR_OWVAR 26
99904: PUSH
99905: LD_STRING 
99907: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
99908: CALL_OW 44
99912: PPUSH
99913: LD_INT 0
99915: PPUSH
99916: CALL_OW 51
// end ;
99920: GO 99842
99922: POP
99923: POP
// end ;
99924: PPOPN 1
99926: END
// every 0 0$1 trigger StreamModeActive and sBomb do
99927: LD_EXP 77
99931: PUSH
99932: LD_EXP 97
99936: AND
99937: IFFALSE 99946
99939: GO 99941
99941: DISABLE
// StreamSibBomb ;
99942: CALL 99947 0 0
99946: END
// export function StreamSibBomb ; var i , x , y ; begin
99947: LD_INT 0
99949: PPUSH
99950: PPUSH
99951: PPUSH
99952: PPUSH
// result := false ;
99953: LD_ADDR_VAR 0 1
99957: PUSH
99958: LD_INT 0
99960: ST_TO_ADDR
// for i := 1 to 16 do
99961: LD_ADDR_VAR 0 2
99965: PUSH
99966: DOUBLE
99967: LD_INT 1
99969: DEC
99970: ST_TO_ADDR
99971: LD_INT 16
99973: PUSH
99974: FOR_TO
99975: IFFALSE 100174
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
99977: LD_ADDR_VAR 0 3
99981: PUSH
99982: LD_INT 10
99984: PUSH
99985: LD_INT 20
99987: PUSH
99988: LD_INT 30
99990: PUSH
99991: LD_INT 40
99993: PUSH
99994: LD_INT 50
99996: PUSH
99997: LD_INT 60
99999: PUSH
100000: LD_INT 70
100002: PUSH
100003: LD_INT 80
100005: PUSH
100006: LD_INT 90
100008: PUSH
100009: LD_INT 100
100011: PUSH
100012: LD_INT 110
100014: PUSH
100015: LD_INT 120
100017: PUSH
100018: LD_INT 130
100020: PUSH
100021: LD_INT 140
100023: PUSH
100024: LD_INT 150
100026: PUSH
100027: EMPTY
100028: LIST
100029: LIST
100030: LIST
100031: LIST
100032: LIST
100033: LIST
100034: LIST
100035: LIST
100036: LIST
100037: LIST
100038: LIST
100039: LIST
100040: LIST
100041: LIST
100042: LIST
100043: PUSH
100044: LD_INT 1
100046: PPUSH
100047: LD_INT 15
100049: PPUSH
100050: CALL_OW 12
100054: ARRAY
100055: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
100056: LD_ADDR_VAR 0 4
100060: PUSH
100061: LD_INT 10
100063: PUSH
100064: LD_INT 20
100066: PUSH
100067: LD_INT 30
100069: PUSH
100070: LD_INT 40
100072: PUSH
100073: LD_INT 50
100075: PUSH
100076: LD_INT 60
100078: PUSH
100079: LD_INT 70
100081: PUSH
100082: LD_INT 80
100084: PUSH
100085: LD_INT 90
100087: PUSH
100088: LD_INT 100
100090: PUSH
100091: LD_INT 110
100093: PUSH
100094: LD_INT 120
100096: PUSH
100097: LD_INT 130
100099: PUSH
100100: LD_INT 140
100102: PUSH
100103: LD_INT 150
100105: PUSH
100106: EMPTY
100107: LIST
100108: LIST
100109: LIST
100110: LIST
100111: LIST
100112: LIST
100113: LIST
100114: LIST
100115: LIST
100116: LIST
100117: LIST
100118: LIST
100119: LIST
100120: LIST
100121: LIST
100122: PUSH
100123: LD_INT 1
100125: PPUSH
100126: LD_INT 15
100128: PPUSH
100129: CALL_OW 12
100133: ARRAY
100134: ST_TO_ADDR
// if ValidHex ( x , y ) then
100135: LD_VAR 0 3
100139: PPUSH
100140: LD_VAR 0 4
100144: PPUSH
100145: CALL_OW 488
100149: IFFALSE 100172
// begin result := [ x , y ] ;
100151: LD_ADDR_VAR 0 1
100155: PUSH
100156: LD_VAR 0 3
100160: PUSH
100161: LD_VAR 0 4
100165: PUSH
100166: EMPTY
100167: LIST
100168: LIST
100169: ST_TO_ADDR
// break ;
100170: GO 100174
// end ; end ;
100172: GO 99974
100174: POP
100175: POP
// if result then
100176: LD_VAR 0 1
100180: IFFALSE 100240
// begin ToLua ( playSibBomb() ) ;
100182: LD_STRING playSibBomb()
100184: PPUSH
100185: CALL_OW 559
// wait ( 0 0$14 ) ;
100189: LD_INT 490
100191: PPUSH
100192: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
100196: LD_VAR 0 1
100200: PUSH
100201: LD_INT 1
100203: ARRAY
100204: PPUSH
100205: LD_VAR 0 1
100209: PUSH
100210: LD_INT 2
100212: ARRAY
100213: PPUSH
100214: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
100218: LD_VAR 0 1
100222: PUSH
100223: LD_INT 1
100225: ARRAY
100226: PPUSH
100227: LD_VAR 0 1
100231: PUSH
100232: LD_INT 2
100234: ARRAY
100235: PPUSH
100236: CALL_OW 429
// end ; end ;
100240: LD_VAR 0 1
100244: RET
// every 0 0$1 trigger StreamModeActive and sReset do
100245: LD_EXP 77
100249: PUSH
100250: LD_EXP 99
100254: AND
100255: IFFALSE 100267
100257: GO 100259
100259: DISABLE
// YouLost (  ) ;
100260: LD_STRING 
100262: PPUSH
100263: CALL_OW 104
100267: END
// every 0 0$1 trigger StreamModeActive and sFog do
100268: LD_EXP 77
100272: PUSH
100273: LD_EXP 98
100277: AND
100278: IFFALSE 100292
100280: GO 100282
100282: DISABLE
// FogOff ( your_side ) ;
100283: LD_OWVAR 2
100287: PPUSH
100288: CALL_OW 344
100292: END
// every 0 0$1 trigger StreamModeActive and sSun do
100293: LD_EXP 77
100297: PUSH
100298: LD_EXP 100
100302: AND
100303: IFFALSE 100331
100305: GO 100307
100307: DISABLE
// begin solar_recharge_percent := 0 ;
100308: LD_ADDR_OWVAR 79
100312: PUSH
100313: LD_INT 0
100315: ST_TO_ADDR
// wait ( 5 5$00 ) ;
100316: LD_INT 10500
100318: PPUSH
100319: CALL_OW 67
// solar_recharge_percent := 100 ;
100323: LD_ADDR_OWVAR 79
100327: PUSH
100328: LD_INT 100
100330: ST_TO_ADDR
// end ;
100331: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
100332: LD_EXP 77
100336: PUSH
100337: LD_EXP 101
100341: AND
100342: IFFALSE 100581
100344: GO 100346
100346: DISABLE
100347: LD_INT 0
100349: PPUSH
100350: PPUSH
100351: PPUSH
// begin tmp := [ ] ;
100352: LD_ADDR_VAR 0 3
100356: PUSH
100357: EMPTY
100358: ST_TO_ADDR
// for i := 1 to 6 do
100359: LD_ADDR_VAR 0 1
100363: PUSH
100364: DOUBLE
100365: LD_INT 1
100367: DEC
100368: ST_TO_ADDR
100369: LD_INT 6
100371: PUSH
100372: FOR_TO
100373: IFFALSE 100478
// begin uc_nation := nation_nature ;
100375: LD_ADDR_OWVAR 21
100379: PUSH
100380: LD_INT 0
100382: ST_TO_ADDR
// uc_side := 0 ;
100383: LD_ADDR_OWVAR 20
100387: PUSH
100388: LD_INT 0
100390: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
100391: LD_ADDR_OWVAR 29
100395: PUSH
100396: LD_INT 12
100398: PUSH
100399: LD_INT 12
100401: PUSH
100402: EMPTY
100403: LIST
100404: LIST
100405: ST_TO_ADDR
// hc_agressivity := 20 ;
100406: LD_ADDR_OWVAR 35
100410: PUSH
100411: LD_INT 20
100413: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
100414: LD_ADDR_OWVAR 28
100418: PUSH
100419: LD_INT 17
100421: ST_TO_ADDR
// hc_gallery :=  ;
100422: LD_ADDR_OWVAR 33
100426: PUSH
100427: LD_STRING 
100429: ST_TO_ADDR
// hc_name :=  ;
100430: LD_ADDR_OWVAR 26
100434: PUSH
100435: LD_STRING 
100437: ST_TO_ADDR
// un := CreateHuman ;
100438: LD_ADDR_VAR 0 2
100442: PUSH
100443: CALL_OW 44
100447: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
100448: LD_VAR 0 2
100452: PPUSH
100453: LD_INT 1
100455: PPUSH
100456: CALL_OW 51
// tmp := tmp ^ un ;
100460: LD_ADDR_VAR 0 3
100464: PUSH
100465: LD_VAR 0 3
100469: PUSH
100470: LD_VAR 0 2
100474: ADD
100475: ST_TO_ADDR
// end ;
100476: GO 100372
100478: POP
100479: POP
// repeat wait ( 0 0$1 ) ;
100480: LD_INT 35
100482: PPUSH
100483: CALL_OW 67
// for un in tmp do
100487: LD_ADDR_VAR 0 2
100491: PUSH
100492: LD_VAR 0 3
100496: PUSH
100497: FOR_IN
100498: IFFALSE 100572
// begin if IsDead ( un ) then
100500: LD_VAR 0 2
100504: PPUSH
100505: CALL_OW 301
100509: IFFALSE 100529
// begin tmp := tmp diff un ;
100511: LD_ADDR_VAR 0 3
100515: PUSH
100516: LD_VAR 0 3
100520: PUSH
100521: LD_VAR 0 2
100525: DIFF
100526: ST_TO_ADDR
// continue ;
100527: GO 100497
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
100529: LD_VAR 0 2
100533: PPUSH
100534: LD_INT 3
100536: PUSH
100537: LD_INT 22
100539: PUSH
100540: LD_INT 0
100542: PUSH
100543: EMPTY
100544: LIST
100545: LIST
100546: PUSH
100547: EMPTY
100548: LIST
100549: LIST
100550: PPUSH
100551: CALL_OW 69
100555: PPUSH
100556: LD_VAR 0 2
100560: PPUSH
100561: CALL_OW 74
100565: PPUSH
100566: CALL_OW 115
// end ;
100570: GO 100497
100572: POP
100573: POP
// until not tmp ;
100574: LD_VAR 0 3
100578: NOT
100579: IFFALSE 100480
// end ;
100581: PPOPN 3
100583: END
// every 0 0$1 trigger StreamModeActive and sTroll do
100584: LD_EXP 77
100588: PUSH
100589: LD_EXP 102
100593: AND
100594: IFFALSE 100648
100596: GO 100598
100598: DISABLE
// begin ToLua ( displayTroll(); ) ;
100599: LD_STRING displayTroll();
100601: PPUSH
100602: CALL_OW 559
// wait ( 3 3$00 ) ;
100606: LD_INT 6300
100608: PPUSH
100609: CALL_OW 67
// ToLua ( hideTroll(); ) ;
100613: LD_STRING hideTroll();
100615: PPUSH
100616: CALL_OW 559
// wait ( 1 1$00 ) ;
100620: LD_INT 2100
100622: PPUSH
100623: CALL_OW 67
// ToLua ( displayTroll(); ) ;
100627: LD_STRING displayTroll();
100629: PPUSH
100630: CALL_OW 559
// wait ( 1 1$00 ) ;
100634: LD_INT 2100
100636: PPUSH
100637: CALL_OW 67
// ToLua ( hideTroll(); ) ;
100641: LD_STRING hideTroll();
100643: PPUSH
100644: CALL_OW 559
// end ;
100648: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
100649: LD_EXP 77
100653: PUSH
100654: LD_EXP 103
100658: AND
100659: IFFALSE 100722
100661: GO 100663
100663: DISABLE
100664: LD_INT 0
100666: PPUSH
// begin p := 0 ;
100667: LD_ADDR_VAR 0 1
100671: PUSH
100672: LD_INT 0
100674: ST_TO_ADDR
// repeat game_speed := 1 ;
100675: LD_ADDR_OWVAR 65
100679: PUSH
100680: LD_INT 1
100682: ST_TO_ADDR
// wait ( 0 0$1 ) ;
100683: LD_INT 35
100685: PPUSH
100686: CALL_OW 67
// p := p + 1 ;
100690: LD_ADDR_VAR 0 1
100694: PUSH
100695: LD_VAR 0 1
100699: PUSH
100700: LD_INT 1
100702: PLUS
100703: ST_TO_ADDR
// until p >= 60 ;
100704: LD_VAR 0 1
100708: PUSH
100709: LD_INT 60
100711: GREATEREQUAL
100712: IFFALSE 100675
// game_speed := 4 ;
100714: LD_ADDR_OWVAR 65
100718: PUSH
100719: LD_INT 4
100721: ST_TO_ADDR
// end ;
100722: PPOPN 1
100724: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
100725: LD_EXP 77
100729: PUSH
100730: LD_EXP 104
100734: AND
100735: IFFALSE 100881
100737: GO 100739
100739: DISABLE
100740: LD_INT 0
100742: PPUSH
100743: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
100744: LD_ADDR_VAR 0 1
100748: PUSH
100749: LD_INT 22
100751: PUSH
100752: LD_OWVAR 2
100756: PUSH
100757: EMPTY
100758: LIST
100759: LIST
100760: PUSH
100761: LD_INT 2
100763: PUSH
100764: LD_INT 30
100766: PUSH
100767: LD_INT 0
100769: PUSH
100770: EMPTY
100771: LIST
100772: LIST
100773: PUSH
100774: LD_INT 30
100776: PUSH
100777: LD_INT 1
100779: PUSH
100780: EMPTY
100781: LIST
100782: LIST
100783: PUSH
100784: EMPTY
100785: LIST
100786: LIST
100787: LIST
100788: PUSH
100789: EMPTY
100790: LIST
100791: LIST
100792: PPUSH
100793: CALL_OW 69
100797: ST_TO_ADDR
// if not depot then
100798: LD_VAR 0 1
100802: NOT
100803: IFFALSE 100807
// exit ;
100805: GO 100881
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
100807: LD_ADDR_VAR 0 2
100811: PUSH
100812: LD_VAR 0 1
100816: PUSH
100817: LD_INT 1
100819: PPUSH
100820: LD_VAR 0 1
100824: PPUSH
100825: CALL_OW 12
100829: ARRAY
100830: PPUSH
100831: CALL_OW 274
100835: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
100836: LD_VAR 0 2
100840: PPUSH
100841: LD_INT 1
100843: PPUSH
100844: LD_INT 0
100846: PPUSH
100847: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
100851: LD_VAR 0 2
100855: PPUSH
100856: LD_INT 2
100858: PPUSH
100859: LD_INT 0
100861: PPUSH
100862: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
100866: LD_VAR 0 2
100870: PPUSH
100871: LD_INT 3
100873: PPUSH
100874: LD_INT 0
100876: PPUSH
100877: CALL_OW 277
// end ;
100881: PPOPN 2
100883: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
100884: LD_EXP 77
100888: PUSH
100889: LD_EXP 105
100893: AND
100894: IFFALSE 100991
100896: GO 100898
100898: DISABLE
100899: LD_INT 0
100901: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
100902: LD_ADDR_VAR 0 1
100906: PUSH
100907: LD_INT 22
100909: PUSH
100910: LD_OWVAR 2
100914: PUSH
100915: EMPTY
100916: LIST
100917: LIST
100918: PUSH
100919: LD_INT 21
100921: PUSH
100922: LD_INT 1
100924: PUSH
100925: EMPTY
100926: LIST
100927: LIST
100928: PUSH
100929: LD_INT 3
100931: PUSH
100932: LD_INT 23
100934: PUSH
100935: LD_INT 0
100937: PUSH
100938: EMPTY
100939: LIST
100940: LIST
100941: PUSH
100942: EMPTY
100943: LIST
100944: LIST
100945: PUSH
100946: EMPTY
100947: LIST
100948: LIST
100949: LIST
100950: PPUSH
100951: CALL_OW 69
100955: ST_TO_ADDR
// if not tmp then
100956: LD_VAR 0 1
100960: NOT
100961: IFFALSE 100965
// exit ;
100963: GO 100991
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
100965: LD_VAR 0 1
100969: PUSH
100970: LD_INT 1
100972: PPUSH
100973: LD_VAR 0 1
100977: PPUSH
100978: CALL_OW 12
100982: ARRAY
100983: PPUSH
100984: LD_INT 200
100986: PPUSH
100987: CALL_OW 234
// end ;
100991: PPOPN 1
100993: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
100994: LD_EXP 77
100998: PUSH
100999: LD_EXP 106
101003: AND
101004: IFFALSE 101083
101006: GO 101008
101008: DISABLE
101009: LD_INT 0
101011: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
101012: LD_ADDR_VAR 0 1
101016: PUSH
101017: LD_INT 22
101019: PUSH
101020: LD_OWVAR 2
101024: PUSH
101025: EMPTY
101026: LIST
101027: LIST
101028: PUSH
101029: LD_INT 21
101031: PUSH
101032: LD_INT 2
101034: PUSH
101035: EMPTY
101036: LIST
101037: LIST
101038: PUSH
101039: EMPTY
101040: LIST
101041: LIST
101042: PPUSH
101043: CALL_OW 69
101047: ST_TO_ADDR
// if not tmp then
101048: LD_VAR 0 1
101052: NOT
101053: IFFALSE 101057
// exit ;
101055: GO 101083
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
101057: LD_VAR 0 1
101061: PUSH
101062: LD_INT 1
101064: PPUSH
101065: LD_VAR 0 1
101069: PPUSH
101070: CALL_OW 12
101074: ARRAY
101075: PPUSH
101076: LD_INT 60
101078: PPUSH
101079: CALL_OW 234
// end ;
101083: PPOPN 1
101085: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
101086: LD_EXP 77
101090: PUSH
101091: LD_EXP 107
101095: AND
101096: IFFALSE 101195
101098: GO 101100
101100: DISABLE
101101: LD_INT 0
101103: PPUSH
101104: PPUSH
// begin enable ;
101105: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
101106: LD_ADDR_VAR 0 1
101110: PUSH
101111: LD_INT 22
101113: PUSH
101114: LD_OWVAR 2
101118: PUSH
101119: EMPTY
101120: LIST
101121: LIST
101122: PUSH
101123: LD_INT 61
101125: PUSH
101126: EMPTY
101127: LIST
101128: PUSH
101129: LD_INT 33
101131: PUSH
101132: LD_INT 2
101134: PUSH
101135: EMPTY
101136: LIST
101137: LIST
101138: PUSH
101139: EMPTY
101140: LIST
101141: LIST
101142: LIST
101143: PPUSH
101144: CALL_OW 69
101148: ST_TO_ADDR
// if not tmp then
101149: LD_VAR 0 1
101153: NOT
101154: IFFALSE 101158
// exit ;
101156: GO 101195
// for i in tmp do
101158: LD_ADDR_VAR 0 2
101162: PUSH
101163: LD_VAR 0 1
101167: PUSH
101168: FOR_IN
101169: IFFALSE 101193
// if IsControledBy ( i ) then
101171: LD_VAR 0 2
101175: PPUSH
101176: CALL_OW 312
101180: IFFALSE 101191
// ComUnlink ( i ) ;
101182: LD_VAR 0 2
101186: PPUSH
101187: CALL_OW 136
101191: GO 101168
101193: POP
101194: POP
// end ;
101195: PPOPN 2
101197: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
101198: LD_EXP 77
101202: PUSH
101203: LD_EXP 108
101207: AND
101208: IFFALSE 101348
101210: GO 101212
101212: DISABLE
101213: LD_INT 0
101215: PPUSH
101216: PPUSH
// begin ToLua ( displayPowell(); ) ;
101217: LD_STRING displayPowell();
101219: PPUSH
101220: CALL_OW 559
// uc_side := 0 ;
101224: LD_ADDR_OWVAR 20
101228: PUSH
101229: LD_INT 0
101231: ST_TO_ADDR
// uc_nation := 2 ;
101232: LD_ADDR_OWVAR 21
101236: PUSH
101237: LD_INT 2
101239: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
101240: LD_ADDR_OWVAR 37
101244: PUSH
101245: LD_INT 14
101247: ST_TO_ADDR
// vc_engine := engine_siberite ;
101248: LD_ADDR_OWVAR 39
101252: PUSH
101253: LD_INT 3
101255: ST_TO_ADDR
// vc_control := control_apeman ;
101256: LD_ADDR_OWVAR 38
101260: PUSH
101261: LD_INT 5
101263: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
101264: LD_ADDR_OWVAR 40
101268: PUSH
101269: LD_INT 29
101271: ST_TO_ADDR
// un := CreateVehicle ;
101272: LD_ADDR_VAR 0 2
101276: PUSH
101277: CALL_OW 45
101281: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
101282: LD_VAR 0 2
101286: PPUSH
101287: LD_INT 1
101289: PPUSH
101290: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
101294: LD_INT 35
101296: PPUSH
101297: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
101301: LD_VAR 0 2
101305: PPUSH
101306: LD_INT 22
101308: PUSH
101309: LD_OWVAR 2
101313: PUSH
101314: EMPTY
101315: LIST
101316: LIST
101317: PPUSH
101318: CALL_OW 69
101322: PPUSH
101323: LD_VAR 0 2
101327: PPUSH
101328: CALL_OW 74
101332: PPUSH
101333: CALL_OW 115
// until IsDead ( un ) ;
101337: LD_VAR 0 2
101341: PPUSH
101342: CALL_OW 301
101346: IFFALSE 101294
// end ;
101348: PPOPN 2
101350: END
// every 0 0$1 trigger StreamModeActive and sStu do
101351: LD_EXP 77
101355: PUSH
101356: LD_EXP 116
101360: AND
101361: IFFALSE 101377
101363: GO 101365
101365: DISABLE
// begin ToLua ( displayStucuk(); ) ;
101366: LD_STRING displayStucuk();
101368: PPUSH
101369: CALL_OW 559
// ResetFog ;
101373: CALL_OW 335
// end ;
101377: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
101378: LD_EXP 77
101382: PUSH
101383: LD_EXP 109
101387: AND
101388: IFFALSE 101529
101390: GO 101392
101392: DISABLE
101393: LD_INT 0
101395: PPUSH
101396: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
101397: LD_ADDR_VAR 0 2
101401: PUSH
101402: LD_INT 22
101404: PUSH
101405: LD_OWVAR 2
101409: PUSH
101410: EMPTY
101411: LIST
101412: LIST
101413: PUSH
101414: LD_INT 21
101416: PUSH
101417: LD_INT 1
101419: PUSH
101420: EMPTY
101421: LIST
101422: LIST
101423: PUSH
101424: EMPTY
101425: LIST
101426: LIST
101427: PPUSH
101428: CALL_OW 69
101432: ST_TO_ADDR
// if not tmp then
101433: LD_VAR 0 2
101437: NOT
101438: IFFALSE 101442
// exit ;
101440: GO 101529
// un := tmp [ rand ( 1 , tmp ) ] ;
101442: LD_ADDR_VAR 0 1
101446: PUSH
101447: LD_VAR 0 2
101451: PUSH
101452: LD_INT 1
101454: PPUSH
101455: LD_VAR 0 2
101459: PPUSH
101460: CALL_OW 12
101464: ARRAY
101465: ST_TO_ADDR
// SetSide ( un , 0 ) ;
101466: LD_VAR 0 1
101470: PPUSH
101471: LD_INT 0
101473: PPUSH
101474: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
101478: LD_VAR 0 1
101482: PPUSH
101483: LD_OWVAR 3
101487: PUSH
101488: LD_VAR 0 1
101492: DIFF
101493: PPUSH
101494: LD_VAR 0 1
101498: PPUSH
101499: CALL_OW 74
101503: PPUSH
101504: CALL_OW 115
// wait ( 0 0$20 ) ;
101508: LD_INT 700
101510: PPUSH
101511: CALL_OW 67
// SetSide ( un , your_side ) ;
101515: LD_VAR 0 1
101519: PPUSH
101520: LD_OWVAR 2
101524: PPUSH
101525: CALL_OW 235
// end ;
101529: PPOPN 2
101531: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
101532: LD_EXP 77
101536: PUSH
101537: LD_EXP 110
101541: AND
101542: IFFALSE 101648
101544: GO 101546
101546: DISABLE
101547: LD_INT 0
101549: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
101550: LD_ADDR_VAR 0 1
101554: PUSH
101555: LD_INT 22
101557: PUSH
101558: LD_OWVAR 2
101562: PUSH
101563: EMPTY
101564: LIST
101565: LIST
101566: PUSH
101567: LD_INT 2
101569: PUSH
101570: LD_INT 30
101572: PUSH
101573: LD_INT 0
101575: PUSH
101576: EMPTY
101577: LIST
101578: LIST
101579: PUSH
101580: LD_INT 30
101582: PUSH
101583: LD_INT 1
101585: PUSH
101586: EMPTY
101587: LIST
101588: LIST
101589: PUSH
101590: EMPTY
101591: LIST
101592: LIST
101593: LIST
101594: PUSH
101595: EMPTY
101596: LIST
101597: LIST
101598: PPUSH
101599: CALL_OW 69
101603: ST_TO_ADDR
// if not depot then
101604: LD_VAR 0 1
101608: NOT
101609: IFFALSE 101613
// exit ;
101611: GO 101648
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
101613: LD_VAR 0 1
101617: PUSH
101618: LD_INT 1
101620: ARRAY
101621: PPUSH
101622: CALL_OW 250
101626: PPUSH
101627: LD_VAR 0 1
101631: PUSH
101632: LD_INT 1
101634: ARRAY
101635: PPUSH
101636: CALL_OW 251
101640: PPUSH
101641: LD_INT 70
101643: PPUSH
101644: CALL_OW 495
// end ;
101648: PPOPN 1
101650: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
101651: LD_EXP 77
101655: PUSH
101656: LD_EXP 111
101660: AND
101661: IFFALSE 101872
101663: GO 101665
101665: DISABLE
101666: LD_INT 0
101668: PPUSH
101669: PPUSH
101670: PPUSH
101671: PPUSH
101672: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
101673: LD_ADDR_VAR 0 5
101677: PUSH
101678: LD_INT 22
101680: PUSH
101681: LD_OWVAR 2
101685: PUSH
101686: EMPTY
101687: LIST
101688: LIST
101689: PUSH
101690: LD_INT 21
101692: PUSH
101693: LD_INT 1
101695: PUSH
101696: EMPTY
101697: LIST
101698: LIST
101699: PUSH
101700: EMPTY
101701: LIST
101702: LIST
101703: PPUSH
101704: CALL_OW 69
101708: ST_TO_ADDR
// if not tmp then
101709: LD_VAR 0 5
101713: NOT
101714: IFFALSE 101718
// exit ;
101716: GO 101872
// for i in tmp do
101718: LD_ADDR_VAR 0 1
101722: PUSH
101723: LD_VAR 0 5
101727: PUSH
101728: FOR_IN
101729: IFFALSE 101870
// begin d := rand ( 0 , 5 ) ;
101731: LD_ADDR_VAR 0 4
101735: PUSH
101736: LD_INT 0
101738: PPUSH
101739: LD_INT 5
101741: PPUSH
101742: CALL_OW 12
101746: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
101747: LD_ADDR_VAR 0 2
101751: PUSH
101752: LD_VAR 0 1
101756: PPUSH
101757: CALL_OW 250
101761: PPUSH
101762: LD_VAR 0 4
101766: PPUSH
101767: LD_INT 3
101769: PPUSH
101770: LD_INT 12
101772: PPUSH
101773: CALL_OW 12
101777: PPUSH
101778: CALL_OW 272
101782: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
101783: LD_ADDR_VAR 0 3
101787: PUSH
101788: LD_VAR 0 1
101792: PPUSH
101793: CALL_OW 251
101797: PPUSH
101798: LD_VAR 0 4
101802: PPUSH
101803: LD_INT 3
101805: PPUSH
101806: LD_INT 12
101808: PPUSH
101809: CALL_OW 12
101813: PPUSH
101814: CALL_OW 273
101818: ST_TO_ADDR
// if ValidHex ( x , y ) then
101819: LD_VAR 0 2
101823: PPUSH
101824: LD_VAR 0 3
101828: PPUSH
101829: CALL_OW 488
101833: IFFALSE 101868
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
101835: LD_VAR 0 1
101839: PPUSH
101840: LD_VAR 0 2
101844: PPUSH
101845: LD_VAR 0 3
101849: PPUSH
101850: LD_INT 3
101852: PPUSH
101853: LD_INT 6
101855: PPUSH
101856: CALL_OW 12
101860: PPUSH
101861: LD_INT 1
101863: PPUSH
101864: CALL_OW 483
// end ;
101868: GO 101728
101870: POP
101871: POP
// end ;
101872: PPOPN 5
101874: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
101875: LD_EXP 77
101879: PUSH
101880: LD_EXP 112
101884: AND
101885: IFFALSE 101979
101887: GO 101889
101889: DISABLE
101890: LD_INT 0
101892: PPUSH
101893: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
101894: LD_ADDR_VAR 0 2
101898: PUSH
101899: LD_INT 22
101901: PUSH
101902: LD_OWVAR 2
101906: PUSH
101907: EMPTY
101908: LIST
101909: LIST
101910: PUSH
101911: LD_INT 32
101913: PUSH
101914: LD_INT 1
101916: PUSH
101917: EMPTY
101918: LIST
101919: LIST
101920: PUSH
101921: LD_INT 21
101923: PUSH
101924: LD_INT 2
101926: PUSH
101927: EMPTY
101928: LIST
101929: LIST
101930: PUSH
101931: EMPTY
101932: LIST
101933: LIST
101934: LIST
101935: PPUSH
101936: CALL_OW 69
101940: ST_TO_ADDR
// if not tmp then
101941: LD_VAR 0 2
101945: NOT
101946: IFFALSE 101950
// exit ;
101948: GO 101979
// for i in tmp do
101950: LD_ADDR_VAR 0 1
101954: PUSH
101955: LD_VAR 0 2
101959: PUSH
101960: FOR_IN
101961: IFFALSE 101977
// SetFuel ( i , 0 ) ;
101963: LD_VAR 0 1
101967: PPUSH
101968: LD_INT 0
101970: PPUSH
101971: CALL_OW 240
101975: GO 101960
101977: POP
101978: POP
// end ;
101979: PPOPN 2
101981: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
101982: LD_EXP 77
101986: PUSH
101987: LD_EXP 113
101991: AND
101992: IFFALSE 102058
101994: GO 101996
101996: DISABLE
101997: LD_INT 0
101999: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
102000: LD_ADDR_VAR 0 1
102004: PUSH
102005: LD_INT 22
102007: PUSH
102008: LD_OWVAR 2
102012: PUSH
102013: EMPTY
102014: LIST
102015: LIST
102016: PUSH
102017: LD_INT 30
102019: PUSH
102020: LD_INT 29
102022: PUSH
102023: EMPTY
102024: LIST
102025: LIST
102026: PUSH
102027: EMPTY
102028: LIST
102029: LIST
102030: PPUSH
102031: CALL_OW 69
102035: ST_TO_ADDR
// if not tmp then
102036: LD_VAR 0 1
102040: NOT
102041: IFFALSE 102045
// exit ;
102043: GO 102058
// DestroyUnit ( tmp [ 1 ] ) ;
102045: LD_VAR 0 1
102049: PUSH
102050: LD_INT 1
102052: ARRAY
102053: PPUSH
102054: CALL_OW 65
// end ;
102058: PPOPN 1
102060: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
102061: LD_EXP 77
102065: PUSH
102066: LD_EXP 115
102070: AND
102071: IFFALSE 102200
102073: GO 102075
102075: DISABLE
102076: LD_INT 0
102078: PPUSH
// begin uc_side := 0 ;
102079: LD_ADDR_OWVAR 20
102083: PUSH
102084: LD_INT 0
102086: ST_TO_ADDR
// uc_nation := nation_arabian ;
102087: LD_ADDR_OWVAR 21
102091: PUSH
102092: LD_INT 2
102094: ST_TO_ADDR
// hc_gallery :=  ;
102095: LD_ADDR_OWVAR 33
102099: PUSH
102100: LD_STRING 
102102: ST_TO_ADDR
// hc_name :=  ;
102103: LD_ADDR_OWVAR 26
102107: PUSH
102108: LD_STRING 
102110: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
102111: LD_INT 1
102113: PPUSH
102114: LD_INT 11
102116: PPUSH
102117: LD_INT 10
102119: PPUSH
102120: CALL_OW 380
// un := CreateHuman ;
102124: LD_ADDR_VAR 0 1
102128: PUSH
102129: CALL_OW 44
102133: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
102134: LD_VAR 0 1
102138: PPUSH
102139: LD_INT 1
102141: PPUSH
102142: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
102146: LD_INT 35
102148: PPUSH
102149: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
102153: LD_VAR 0 1
102157: PPUSH
102158: LD_INT 22
102160: PUSH
102161: LD_OWVAR 2
102165: PUSH
102166: EMPTY
102167: LIST
102168: LIST
102169: PPUSH
102170: CALL_OW 69
102174: PPUSH
102175: LD_VAR 0 1
102179: PPUSH
102180: CALL_OW 74
102184: PPUSH
102185: CALL_OW 115
// until IsDead ( un ) ;
102189: LD_VAR 0 1
102193: PPUSH
102194: CALL_OW 301
102198: IFFALSE 102146
// end ;
102200: PPOPN 1
102202: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
102203: LD_EXP 77
102207: PUSH
102208: LD_EXP 117
102212: AND
102213: IFFALSE 102225
102215: GO 102217
102217: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
102218: LD_STRING earthquake(getX(game), 0, 32)
102220: PPUSH
102221: CALL_OW 559
102225: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
102226: LD_EXP 77
102230: PUSH
102231: LD_EXP 118
102235: AND
102236: IFFALSE 102327
102238: GO 102240
102240: DISABLE
102241: LD_INT 0
102243: PPUSH
// begin enable ;
102244: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
102245: LD_ADDR_VAR 0 1
102249: PUSH
102250: LD_INT 22
102252: PUSH
102253: LD_OWVAR 2
102257: PUSH
102258: EMPTY
102259: LIST
102260: LIST
102261: PUSH
102262: LD_INT 21
102264: PUSH
102265: LD_INT 2
102267: PUSH
102268: EMPTY
102269: LIST
102270: LIST
102271: PUSH
102272: LD_INT 33
102274: PUSH
102275: LD_INT 3
102277: PUSH
102278: EMPTY
102279: LIST
102280: LIST
102281: PUSH
102282: EMPTY
102283: LIST
102284: LIST
102285: LIST
102286: PPUSH
102287: CALL_OW 69
102291: ST_TO_ADDR
// if not tmp then
102292: LD_VAR 0 1
102296: NOT
102297: IFFALSE 102301
// exit ;
102299: GO 102327
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
102301: LD_VAR 0 1
102305: PUSH
102306: LD_INT 1
102308: PPUSH
102309: LD_VAR 0 1
102313: PPUSH
102314: CALL_OW 12
102318: ARRAY
102319: PPUSH
102320: LD_INT 1
102322: PPUSH
102323: CALL_OW 234
// end ;
102327: PPOPN 1
102329: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
102330: LD_EXP 77
102334: PUSH
102335: LD_EXP 119
102339: AND
102340: IFFALSE 102481
102342: GO 102344
102344: DISABLE
102345: LD_INT 0
102347: PPUSH
102348: PPUSH
102349: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
102350: LD_ADDR_VAR 0 3
102354: PUSH
102355: LD_INT 22
102357: PUSH
102358: LD_OWVAR 2
102362: PUSH
102363: EMPTY
102364: LIST
102365: LIST
102366: PUSH
102367: LD_INT 25
102369: PUSH
102370: LD_INT 1
102372: PUSH
102373: EMPTY
102374: LIST
102375: LIST
102376: PUSH
102377: EMPTY
102378: LIST
102379: LIST
102380: PPUSH
102381: CALL_OW 69
102385: ST_TO_ADDR
// if not tmp then
102386: LD_VAR 0 3
102390: NOT
102391: IFFALSE 102395
// exit ;
102393: GO 102481
// un := tmp [ rand ( 1 , tmp ) ] ;
102395: LD_ADDR_VAR 0 2
102399: PUSH
102400: LD_VAR 0 3
102404: PUSH
102405: LD_INT 1
102407: PPUSH
102408: LD_VAR 0 3
102412: PPUSH
102413: CALL_OW 12
102417: ARRAY
102418: ST_TO_ADDR
// if Crawls ( un ) then
102419: LD_VAR 0 2
102423: PPUSH
102424: CALL_OW 318
102428: IFFALSE 102439
// ComWalk ( un ) ;
102430: LD_VAR 0 2
102434: PPUSH
102435: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
102439: LD_VAR 0 2
102443: PPUSH
102444: LD_INT 9
102446: PPUSH
102447: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
102451: LD_INT 28
102453: PPUSH
102454: LD_OWVAR 2
102458: PPUSH
102459: LD_INT 2
102461: PPUSH
102462: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
102466: LD_INT 29
102468: PPUSH
102469: LD_OWVAR 2
102473: PPUSH
102474: LD_INT 2
102476: PPUSH
102477: CALL_OW 322
// end ;
102481: PPOPN 3
102483: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
102484: LD_EXP 77
102488: PUSH
102489: LD_EXP 120
102493: AND
102494: IFFALSE 102605
102496: GO 102498
102498: DISABLE
102499: LD_INT 0
102501: PPUSH
102502: PPUSH
102503: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
102504: LD_ADDR_VAR 0 3
102508: PUSH
102509: LD_INT 22
102511: PUSH
102512: LD_OWVAR 2
102516: PUSH
102517: EMPTY
102518: LIST
102519: LIST
102520: PUSH
102521: LD_INT 25
102523: PUSH
102524: LD_INT 1
102526: PUSH
102527: EMPTY
102528: LIST
102529: LIST
102530: PUSH
102531: EMPTY
102532: LIST
102533: LIST
102534: PPUSH
102535: CALL_OW 69
102539: ST_TO_ADDR
// if not tmp then
102540: LD_VAR 0 3
102544: NOT
102545: IFFALSE 102549
// exit ;
102547: GO 102605
// un := tmp [ rand ( 1 , tmp ) ] ;
102549: LD_ADDR_VAR 0 2
102553: PUSH
102554: LD_VAR 0 3
102558: PUSH
102559: LD_INT 1
102561: PPUSH
102562: LD_VAR 0 3
102566: PPUSH
102567: CALL_OW 12
102571: ARRAY
102572: ST_TO_ADDR
// if Crawls ( un ) then
102573: LD_VAR 0 2
102577: PPUSH
102578: CALL_OW 318
102582: IFFALSE 102593
// ComWalk ( un ) ;
102584: LD_VAR 0 2
102588: PPUSH
102589: CALL_OW 138
// SetClass ( un , class_mortar ) ;
102593: LD_VAR 0 2
102597: PPUSH
102598: LD_INT 8
102600: PPUSH
102601: CALL_OW 336
// end ;
102605: PPOPN 3
102607: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
102608: LD_EXP 77
102612: PUSH
102613: LD_EXP 121
102617: AND
102618: IFFALSE 102762
102620: GO 102622
102622: DISABLE
102623: LD_INT 0
102625: PPUSH
102626: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
102627: LD_ADDR_VAR 0 2
102631: PUSH
102632: LD_INT 22
102634: PUSH
102635: LD_OWVAR 2
102639: PUSH
102640: EMPTY
102641: LIST
102642: LIST
102643: PUSH
102644: LD_INT 21
102646: PUSH
102647: LD_INT 2
102649: PUSH
102650: EMPTY
102651: LIST
102652: LIST
102653: PUSH
102654: LD_INT 2
102656: PUSH
102657: LD_INT 34
102659: PUSH
102660: LD_INT 12
102662: PUSH
102663: EMPTY
102664: LIST
102665: LIST
102666: PUSH
102667: LD_INT 34
102669: PUSH
102670: LD_INT 51
102672: PUSH
102673: EMPTY
102674: LIST
102675: LIST
102676: PUSH
102677: LD_INT 34
102679: PUSH
102680: LD_INT 32
102682: PUSH
102683: EMPTY
102684: LIST
102685: LIST
102686: PUSH
102687: EMPTY
102688: LIST
102689: LIST
102690: LIST
102691: LIST
102692: PUSH
102693: EMPTY
102694: LIST
102695: LIST
102696: LIST
102697: PPUSH
102698: CALL_OW 69
102702: ST_TO_ADDR
// if not tmp then
102703: LD_VAR 0 2
102707: NOT
102708: IFFALSE 102712
// exit ;
102710: GO 102762
// for i in tmp do
102712: LD_ADDR_VAR 0 1
102716: PUSH
102717: LD_VAR 0 2
102721: PUSH
102722: FOR_IN
102723: IFFALSE 102760
// if GetCargo ( i , mat_artifact ) = 0 then
102725: LD_VAR 0 1
102729: PPUSH
102730: LD_INT 4
102732: PPUSH
102733: CALL_OW 289
102737: PUSH
102738: LD_INT 0
102740: EQUAL
102741: IFFALSE 102758
// SetCargo ( i , mat_siberit , 100 ) ;
102743: LD_VAR 0 1
102747: PPUSH
102748: LD_INT 3
102750: PPUSH
102751: LD_INT 100
102753: PPUSH
102754: CALL_OW 290
102758: GO 102722
102760: POP
102761: POP
// end ;
102762: PPOPN 2
102764: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
102765: LD_EXP 77
102769: PUSH
102770: LD_EXP 122
102774: AND
102775: IFFALSE 102958
102777: GO 102779
102779: DISABLE
102780: LD_INT 0
102782: PPUSH
102783: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
102784: LD_ADDR_VAR 0 2
102788: PUSH
102789: LD_INT 22
102791: PUSH
102792: LD_OWVAR 2
102796: PUSH
102797: EMPTY
102798: LIST
102799: LIST
102800: PPUSH
102801: CALL_OW 69
102805: ST_TO_ADDR
// if not tmp then
102806: LD_VAR 0 2
102810: NOT
102811: IFFALSE 102815
// exit ;
102813: GO 102958
// for i := 1 to 2 do
102815: LD_ADDR_VAR 0 1
102819: PUSH
102820: DOUBLE
102821: LD_INT 1
102823: DEC
102824: ST_TO_ADDR
102825: LD_INT 2
102827: PUSH
102828: FOR_TO
102829: IFFALSE 102956
// begin uc_side := your_side ;
102831: LD_ADDR_OWVAR 20
102835: PUSH
102836: LD_OWVAR 2
102840: ST_TO_ADDR
// uc_nation := nation_american ;
102841: LD_ADDR_OWVAR 21
102845: PUSH
102846: LD_INT 1
102848: ST_TO_ADDR
// vc_chassis := us_morphling ;
102849: LD_ADDR_OWVAR 37
102853: PUSH
102854: LD_INT 5
102856: ST_TO_ADDR
// vc_engine := engine_siberite ;
102857: LD_ADDR_OWVAR 39
102861: PUSH
102862: LD_INT 3
102864: ST_TO_ADDR
// vc_control := control_computer ;
102865: LD_ADDR_OWVAR 38
102869: PUSH
102870: LD_INT 3
102872: ST_TO_ADDR
// vc_weapon := us_double_laser ;
102873: LD_ADDR_OWVAR 40
102877: PUSH
102878: LD_INT 10
102880: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
102881: LD_VAR 0 2
102885: PUSH
102886: LD_INT 1
102888: ARRAY
102889: PPUSH
102890: CALL_OW 310
102894: NOT
102895: IFFALSE 102942
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
102897: CALL_OW 45
102901: PPUSH
102902: LD_VAR 0 2
102906: PUSH
102907: LD_INT 1
102909: ARRAY
102910: PPUSH
102911: CALL_OW 250
102915: PPUSH
102916: LD_VAR 0 2
102920: PUSH
102921: LD_INT 1
102923: ARRAY
102924: PPUSH
102925: CALL_OW 251
102929: PPUSH
102930: LD_INT 12
102932: PPUSH
102933: LD_INT 1
102935: PPUSH
102936: CALL_OW 50
102940: GO 102954
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
102942: CALL_OW 45
102946: PPUSH
102947: LD_INT 1
102949: PPUSH
102950: CALL_OW 51
// end ;
102954: GO 102828
102956: POP
102957: POP
// end ;
102958: PPOPN 2
102960: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
102961: LD_EXP 77
102965: PUSH
102966: LD_EXP 123
102970: AND
102971: IFFALSE 103193
102973: GO 102975
102975: DISABLE
102976: LD_INT 0
102978: PPUSH
102979: PPUSH
102980: PPUSH
102981: PPUSH
102982: PPUSH
102983: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
102984: LD_ADDR_VAR 0 6
102988: PUSH
102989: LD_INT 22
102991: PUSH
102992: LD_OWVAR 2
102996: PUSH
102997: EMPTY
102998: LIST
102999: LIST
103000: PUSH
103001: LD_INT 21
103003: PUSH
103004: LD_INT 1
103006: PUSH
103007: EMPTY
103008: LIST
103009: LIST
103010: PUSH
103011: LD_INT 3
103013: PUSH
103014: LD_INT 23
103016: PUSH
103017: LD_INT 0
103019: PUSH
103020: EMPTY
103021: LIST
103022: LIST
103023: PUSH
103024: EMPTY
103025: LIST
103026: LIST
103027: PUSH
103028: EMPTY
103029: LIST
103030: LIST
103031: LIST
103032: PPUSH
103033: CALL_OW 69
103037: ST_TO_ADDR
// if not tmp then
103038: LD_VAR 0 6
103042: NOT
103043: IFFALSE 103047
// exit ;
103045: GO 103193
// s1 := rand ( 1 , 4 ) ;
103047: LD_ADDR_VAR 0 2
103051: PUSH
103052: LD_INT 1
103054: PPUSH
103055: LD_INT 4
103057: PPUSH
103058: CALL_OW 12
103062: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
103063: LD_ADDR_VAR 0 4
103067: PUSH
103068: LD_VAR 0 6
103072: PUSH
103073: LD_INT 1
103075: ARRAY
103076: PPUSH
103077: LD_VAR 0 2
103081: PPUSH
103082: CALL_OW 259
103086: ST_TO_ADDR
// if s1 = 1 then
103087: LD_VAR 0 2
103091: PUSH
103092: LD_INT 1
103094: EQUAL
103095: IFFALSE 103115
// s2 := rand ( 2 , 4 ) else
103097: LD_ADDR_VAR 0 3
103101: PUSH
103102: LD_INT 2
103104: PPUSH
103105: LD_INT 4
103107: PPUSH
103108: CALL_OW 12
103112: ST_TO_ADDR
103113: GO 103123
// s2 := 1 ;
103115: LD_ADDR_VAR 0 3
103119: PUSH
103120: LD_INT 1
103122: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
103123: LD_ADDR_VAR 0 5
103127: PUSH
103128: LD_VAR 0 6
103132: PUSH
103133: LD_INT 1
103135: ARRAY
103136: PPUSH
103137: LD_VAR 0 3
103141: PPUSH
103142: CALL_OW 259
103146: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
103147: LD_VAR 0 6
103151: PUSH
103152: LD_INT 1
103154: ARRAY
103155: PPUSH
103156: LD_VAR 0 2
103160: PPUSH
103161: LD_VAR 0 5
103165: PPUSH
103166: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
103170: LD_VAR 0 6
103174: PUSH
103175: LD_INT 1
103177: ARRAY
103178: PPUSH
103179: LD_VAR 0 3
103183: PPUSH
103184: LD_VAR 0 4
103188: PPUSH
103189: CALL_OW 237
// end ;
103193: PPOPN 6
103195: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
103196: LD_EXP 77
103200: PUSH
103201: LD_EXP 124
103205: AND
103206: IFFALSE 103285
103208: GO 103210
103210: DISABLE
103211: LD_INT 0
103213: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
103214: LD_ADDR_VAR 0 1
103218: PUSH
103219: LD_INT 22
103221: PUSH
103222: LD_OWVAR 2
103226: PUSH
103227: EMPTY
103228: LIST
103229: LIST
103230: PUSH
103231: LD_INT 30
103233: PUSH
103234: LD_INT 3
103236: PUSH
103237: EMPTY
103238: LIST
103239: LIST
103240: PUSH
103241: EMPTY
103242: LIST
103243: LIST
103244: PPUSH
103245: CALL_OW 69
103249: ST_TO_ADDR
// if not tmp then
103250: LD_VAR 0 1
103254: NOT
103255: IFFALSE 103259
// exit ;
103257: GO 103285
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
103259: LD_VAR 0 1
103263: PUSH
103264: LD_INT 1
103266: PPUSH
103267: LD_VAR 0 1
103271: PPUSH
103272: CALL_OW 12
103276: ARRAY
103277: PPUSH
103278: LD_INT 1
103280: PPUSH
103281: CALL_OW 234
// end ;
103285: PPOPN 1
103287: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
103288: LD_EXP 77
103292: PUSH
103293: LD_EXP 125
103297: AND
103298: IFFALSE 103410
103300: GO 103302
103302: DISABLE
103303: LD_INT 0
103305: PPUSH
103306: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
103307: LD_ADDR_VAR 0 2
103311: PUSH
103312: LD_INT 22
103314: PUSH
103315: LD_OWVAR 2
103319: PUSH
103320: EMPTY
103321: LIST
103322: LIST
103323: PUSH
103324: LD_INT 2
103326: PUSH
103327: LD_INT 30
103329: PUSH
103330: LD_INT 27
103332: PUSH
103333: EMPTY
103334: LIST
103335: LIST
103336: PUSH
103337: LD_INT 30
103339: PUSH
103340: LD_INT 26
103342: PUSH
103343: EMPTY
103344: LIST
103345: LIST
103346: PUSH
103347: LD_INT 30
103349: PUSH
103350: LD_INT 28
103352: PUSH
103353: EMPTY
103354: LIST
103355: LIST
103356: PUSH
103357: EMPTY
103358: LIST
103359: LIST
103360: LIST
103361: LIST
103362: PUSH
103363: EMPTY
103364: LIST
103365: LIST
103366: PPUSH
103367: CALL_OW 69
103371: ST_TO_ADDR
// if not tmp then
103372: LD_VAR 0 2
103376: NOT
103377: IFFALSE 103381
// exit ;
103379: GO 103410
// for i in tmp do
103381: LD_ADDR_VAR 0 1
103385: PUSH
103386: LD_VAR 0 2
103390: PUSH
103391: FOR_IN
103392: IFFALSE 103408
// SetLives ( i , 1 ) ;
103394: LD_VAR 0 1
103398: PPUSH
103399: LD_INT 1
103401: PPUSH
103402: CALL_OW 234
103406: GO 103391
103408: POP
103409: POP
// end ;
103410: PPOPN 2
103412: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
103413: LD_EXP 77
103417: PUSH
103418: LD_EXP 126
103422: AND
103423: IFFALSE 103710
103425: GO 103427
103427: DISABLE
103428: LD_INT 0
103430: PPUSH
103431: PPUSH
103432: PPUSH
// begin i := rand ( 1 , 7 ) ;
103433: LD_ADDR_VAR 0 1
103437: PUSH
103438: LD_INT 1
103440: PPUSH
103441: LD_INT 7
103443: PPUSH
103444: CALL_OW 12
103448: ST_TO_ADDR
// case i of 1 :
103449: LD_VAR 0 1
103453: PUSH
103454: LD_INT 1
103456: DOUBLE
103457: EQUAL
103458: IFTRUE 103462
103460: GO 103472
103462: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
103463: LD_STRING earthquake(getX(game), 0, 32)
103465: PPUSH
103466: CALL_OW 559
103470: GO 103710
103472: LD_INT 2
103474: DOUBLE
103475: EQUAL
103476: IFTRUE 103480
103478: GO 103494
103480: POP
// begin ToLua ( displayStucuk(); ) ;
103481: LD_STRING displayStucuk();
103483: PPUSH
103484: CALL_OW 559
// ResetFog ;
103488: CALL_OW 335
// end ; 3 :
103492: GO 103710
103494: LD_INT 3
103496: DOUBLE
103497: EQUAL
103498: IFTRUE 103502
103500: GO 103606
103502: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
103503: LD_ADDR_VAR 0 2
103507: PUSH
103508: LD_INT 22
103510: PUSH
103511: LD_OWVAR 2
103515: PUSH
103516: EMPTY
103517: LIST
103518: LIST
103519: PUSH
103520: LD_INT 25
103522: PUSH
103523: LD_INT 1
103525: PUSH
103526: EMPTY
103527: LIST
103528: LIST
103529: PUSH
103530: EMPTY
103531: LIST
103532: LIST
103533: PPUSH
103534: CALL_OW 69
103538: ST_TO_ADDR
// if not tmp then
103539: LD_VAR 0 2
103543: NOT
103544: IFFALSE 103548
// exit ;
103546: GO 103710
// un := tmp [ rand ( 1 , tmp ) ] ;
103548: LD_ADDR_VAR 0 3
103552: PUSH
103553: LD_VAR 0 2
103557: PUSH
103558: LD_INT 1
103560: PPUSH
103561: LD_VAR 0 2
103565: PPUSH
103566: CALL_OW 12
103570: ARRAY
103571: ST_TO_ADDR
// if Crawls ( un ) then
103572: LD_VAR 0 3
103576: PPUSH
103577: CALL_OW 318
103581: IFFALSE 103592
// ComWalk ( un ) ;
103583: LD_VAR 0 3
103587: PPUSH
103588: CALL_OW 138
// SetClass ( un , class_mortar ) ;
103592: LD_VAR 0 3
103596: PPUSH
103597: LD_INT 8
103599: PPUSH
103600: CALL_OW 336
// end ; 4 :
103604: GO 103710
103606: LD_INT 4
103608: DOUBLE
103609: EQUAL
103610: IFTRUE 103614
103612: GO 103688
103614: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
103615: LD_ADDR_VAR 0 2
103619: PUSH
103620: LD_INT 22
103622: PUSH
103623: LD_OWVAR 2
103627: PUSH
103628: EMPTY
103629: LIST
103630: LIST
103631: PUSH
103632: LD_INT 30
103634: PUSH
103635: LD_INT 29
103637: PUSH
103638: EMPTY
103639: LIST
103640: LIST
103641: PUSH
103642: EMPTY
103643: LIST
103644: LIST
103645: PPUSH
103646: CALL_OW 69
103650: ST_TO_ADDR
// if not tmp then
103651: LD_VAR 0 2
103655: NOT
103656: IFFALSE 103660
// exit ;
103658: GO 103710
// CenterNowOnUnits ( tmp [ 1 ] ) ;
103660: LD_VAR 0 2
103664: PUSH
103665: LD_INT 1
103667: ARRAY
103668: PPUSH
103669: CALL_OW 87
// DestroyUnit ( tmp [ 1 ] ) ;
103673: LD_VAR 0 2
103677: PUSH
103678: LD_INT 1
103680: ARRAY
103681: PPUSH
103682: CALL_OW 65
// end ; 5 .. 7 :
103686: GO 103710
103688: LD_INT 5
103690: DOUBLE
103691: GREATEREQUAL
103692: IFFALSE 103700
103694: LD_INT 7
103696: DOUBLE
103697: LESSEQUAL
103698: IFTRUE 103702
103700: GO 103709
103702: POP
// StreamSibBomb ; end ;
103703: CALL 99947 0 0
103707: GO 103710
103709: POP
// end ;
103710: PPOPN 3
103712: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
103713: LD_EXP 77
103717: PUSH
103718: LD_EXP 127
103722: AND
103723: IFFALSE 103879
103725: GO 103727
103727: DISABLE
103728: LD_INT 0
103730: PPUSH
103731: PPUSH
103732: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
103733: LD_ADDR_VAR 0 2
103737: PUSH
103738: LD_INT 81
103740: PUSH
103741: LD_OWVAR 2
103745: PUSH
103746: EMPTY
103747: LIST
103748: LIST
103749: PUSH
103750: LD_INT 2
103752: PUSH
103753: LD_INT 21
103755: PUSH
103756: LD_INT 1
103758: PUSH
103759: EMPTY
103760: LIST
103761: LIST
103762: PUSH
103763: LD_INT 21
103765: PUSH
103766: LD_INT 2
103768: PUSH
103769: EMPTY
103770: LIST
103771: LIST
103772: PUSH
103773: EMPTY
103774: LIST
103775: LIST
103776: LIST
103777: PUSH
103778: EMPTY
103779: LIST
103780: LIST
103781: PPUSH
103782: CALL_OW 69
103786: ST_TO_ADDR
// if not tmp then
103787: LD_VAR 0 2
103791: NOT
103792: IFFALSE 103796
// exit ;
103794: GO 103879
// p := 0 ;
103796: LD_ADDR_VAR 0 3
103800: PUSH
103801: LD_INT 0
103803: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
103804: LD_INT 35
103806: PPUSH
103807: CALL_OW 67
// p := p + 1 ;
103811: LD_ADDR_VAR 0 3
103815: PUSH
103816: LD_VAR 0 3
103820: PUSH
103821: LD_INT 1
103823: PLUS
103824: ST_TO_ADDR
// for i in tmp do
103825: LD_ADDR_VAR 0 1
103829: PUSH
103830: LD_VAR 0 2
103834: PUSH
103835: FOR_IN
103836: IFFALSE 103867
// if GetLives ( i ) < 1000 then
103838: LD_VAR 0 1
103842: PPUSH
103843: CALL_OW 256
103847: PUSH
103848: LD_INT 1000
103850: LESS
103851: IFFALSE 103865
// SetLives ( i , 1000 ) ;
103853: LD_VAR 0 1
103857: PPUSH
103858: LD_INT 1000
103860: PPUSH
103861: CALL_OW 234
103865: GO 103835
103867: POP
103868: POP
// until p > 20 ;
103869: LD_VAR 0 3
103873: PUSH
103874: LD_INT 20
103876: GREATER
103877: IFFALSE 103804
// end ;
103879: PPOPN 3
103881: END
// every 0 0$1 trigger StreamModeActive and sTime do
103882: LD_EXP 77
103886: PUSH
103887: LD_EXP 128
103891: AND
103892: IFFALSE 103927
103894: GO 103896
103896: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
103897: LD_INT 28
103899: PPUSH
103900: LD_OWVAR 2
103904: PPUSH
103905: LD_INT 2
103907: PPUSH
103908: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
103912: LD_INT 30
103914: PPUSH
103915: LD_OWVAR 2
103919: PPUSH
103920: LD_INT 2
103922: PPUSH
103923: CALL_OW 322
// end ;
103927: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
103928: LD_EXP 77
103932: PUSH
103933: LD_EXP 129
103937: AND
103938: IFFALSE 104059
103940: GO 103942
103942: DISABLE
103943: LD_INT 0
103945: PPUSH
103946: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
103947: LD_ADDR_VAR 0 2
103951: PUSH
103952: LD_INT 22
103954: PUSH
103955: LD_OWVAR 2
103959: PUSH
103960: EMPTY
103961: LIST
103962: LIST
103963: PUSH
103964: LD_INT 21
103966: PUSH
103967: LD_INT 1
103969: PUSH
103970: EMPTY
103971: LIST
103972: LIST
103973: PUSH
103974: LD_INT 3
103976: PUSH
103977: LD_INT 23
103979: PUSH
103980: LD_INT 0
103982: PUSH
103983: EMPTY
103984: LIST
103985: LIST
103986: PUSH
103987: EMPTY
103988: LIST
103989: LIST
103990: PUSH
103991: EMPTY
103992: LIST
103993: LIST
103994: LIST
103995: PPUSH
103996: CALL_OW 69
104000: ST_TO_ADDR
// if not tmp then
104001: LD_VAR 0 2
104005: NOT
104006: IFFALSE 104010
// exit ;
104008: GO 104059
// for i in tmp do
104010: LD_ADDR_VAR 0 1
104014: PUSH
104015: LD_VAR 0 2
104019: PUSH
104020: FOR_IN
104021: IFFALSE 104057
// begin if Crawls ( i ) then
104023: LD_VAR 0 1
104027: PPUSH
104028: CALL_OW 318
104032: IFFALSE 104043
// ComWalk ( i ) ;
104034: LD_VAR 0 1
104038: PPUSH
104039: CALL_OW 138
// SetClass ( i , 2 ) ;
104043: LD_VAR 0 1
104047: PPUSH
104048: LD_INT 2
104050: PPUSH
104051: CALL_OW 336
// end ;
104055: GO 104020
104057: POP
104058: POP
// end ;
104059: PPOPN 2
104061: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
104062: LD_EXP 77
104066: PUSH
104067: LD_EXP 130
104071: AND
104072: IFFALSE 104360
104074: GO 104076
104076: DISABLE
104077: LD_INT 0
104079: PPUSH
104080: PPUSH
104081: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
104082: LD_OWVAR 2
104086: PPUSH
104087: LD_INT 9
104089: PPUSH
104090: LD_INT 1
104092: PPUSH
104093: LD_INT 1
104095: PPUSH
104096: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
104100: LD_INT 9
104102: PPUSH
104103: LD_OWVAR 2
104107: PPUSH
104108: CALL_OW 343
// uc_side := 9 ;
104112: LD_ADDR_OWVAR 20
104116: PUSH
104117: LD_INT 9
104119: ST_TO_ADDR
// uc_nation := 2 ;
104120: LD_ADDR_OWVAR 21
104124: PUSH
104125: LD_INT 2
104127: ST_TO_ADDR
// hc_name := Dark Warrior ;
104128: LD_ADDR_OWVAR 26
104132: PUSH
104133: LD_STRING Dark Warrior
104135: ST_TO_ADDR
// hc_gallery :=  ;
104136: LD_ADDR_OWVAR 33
104140: PUSH
104141: LD_STRING 
104143: ST_TO_ADDR
// hc_noskilllimit := true ;
104144: LD_ADDR_OWVAR 76
104148: PUSH
104149: LD_INT 1
104151: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
104152: LD_ADDR_OWVAR 31
104156: PUSH
104157: LD_INT 30
104159: PUSH
104160: LD_INT 30
104162: PUSH
104163: LD_INT 30
104165: PUSH
104166: LD_INT 30
104168: PUSH
104169: EMPTY
104170: LIST
104171: LIST
104172: LIST
104173: LIST
104174: ST_TO_ADDR
// un := CreateHuman ;
104175: LD_ADDR_VAR 0 3
104179: PUSH
104180: CALL_OW 44
104184: ST_TO_ADDR
// hc_noskilllimit := false ;
104185: LD_ADDR_OWVAR 76
104189: PUSH
104190: LD_INT 0
104192: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
104193: LD_VAR 0 3
104197: PPUSH
104198: LD_INT 1
104200: PPUSH
104201: CALL_OW 51
// ToLua ( playRanger() ) ;
104205: LD_STRING playRanger()
104207: PPUSH
104208: CALL_OW 559
// p := 0 ;
104212: LD_ADDR_VAR 0 2
104216: PUSH
104217: LD_INT 0
104219: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
104220: LD_INT 35
104222: PPUSH
104223: CALL_OW 67
// p := p + 1 ;
104227: LD_ADDR_VAR 0 2
104231: PUSH
104232: LD_VAR 0 2
104236: PUSH
104237: LD_INT 1
104239: PLUS
104240: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
104241: LD_VAR 0 3
104245: PPUSH
104246: CALL_OW 256
104250: PUSH
104251: LD_INT 1000
104253: LESS
104254: IFFALSE 104268
// SetLives ( un , 1000 ) ;
104256: LD_VAR 0 3
104260: PPUSH
104261: LD_INT 1000
104263: PPUSH
104264: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
104268: LD_VAR 0 3
104272: PPUSH
104273: LD_INT 81
104275: PUSH
104276: LD_OWVAR 2
104280: PUSH
104281: EMPTY
104282: LIST
104283: LIST
104284: PUSH
104285: LD_INT 91
104287: PUSH
104288: LD_VAR 0 3
104292: PUSH
104293: LD_INT 30
104295: PUSH
104296: EMPTY
104297: LIST
104298: LIST
104299: LIST
104300: PUSH
104301: EMPTY
104302: LIST
104303: LIST
104304: PPUSH
104305: CALL_OW 69
104309: PPUSH
104310: LD_VAR 0 3
104314: PPUSH
104315: CALL_OW 74
104319: PPUSH
104320: CALL_OW 115
// until p > 80 or IsDead ( un ) ;
104324: LD_VAR 0 2
104328: PUSH
104329: LD_INT 80
104331: GREATER
104332: PUSH
104333: LD_VAR 0 3
104337: PPUSH
104338: CALL_OW 301
104342: OR
104343: IFFALSE 104220
// if un then
104345: LD_VAR 0 3
104349: IFFALSE 104360
// RemoveUnit ( un ) ;
104351: LD_VAR 0 3
104355: PPUSH
104356: CALL_OW 64
// end ;
104360: PPOPN 3
104362: END
// every 0 0$1 trigger sComputer do var i , tmp , j ;
104363: LD_EXP 131
104367: IFFALSE 104483
104369: GO 104371
104371: DISABLE
104372: LD_INT 0
104374: PPUSH
104375: PPUSH
104376: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
104377: LD_ADDR_VAR 0 2
104381: PUSH
104382: LD_INT 81
104384: PUSH
104385: LD_OWVAR 2
104389: PUSH
104390: EMPTY
104391: LIST
104392: LIST
104393: PUSH
104394: LD_INT 21
104396: PUSH
104397: LD_INT 1
104399: PUSH
104400: EMPTY
104401: LIST
104402: LIST
104403: PUSH
104404: EMPTY
104405: LIST
104406: LIST
104407: PPUSH
104408: CALL_OW 69
104412: ST_TO_ADDR
// ToLua ( playComputer() ) ;
104413: LD_STRING playComputer()
104415: PPUSH
104416: CALL_OW 559
// if not tmp then
104420: LD_VAR 0 2
104424: NOT
104425: IFFALSE 104429
// exit ;
104427: GO 104483
// for i in tmp do
104429: LD_ADDR_VAR 0 1
104433: PUSH
104434: LD_VAR 0 2
104438: PUSH
104439: FOR_IN
104440: IFFALSE 104481
// for j := 1 to 4 do
104442: LD_ADDR_VAR 0 3
104446: PUSH
104447: DOUBLE
104448: LD_INT 1
104450: DEC
104451: ST_TO_ADDR
104452: LD_INT 4
104454: PUSH
104455: FOR_TO
104456: IFFALSE 104477
// SetSkill ( i , j , 10 ) ;
104458: LD_VAR 0 1
104462: PPUSH
104463: LD_VAR 0 3
104467: PPUSH
104468: LD_INT 10
104470: PPUSH
104471: CALL_OW 237
104475: GO 104455
104477: POP
104478: POP
104479: GO 104439
104481: POP
104482: POP
// end ;
104483: PPOPN 3
104485: END
// every 0 0$1 trigger s30 do var i , tmp ;
104486: LD_EXP 132
104490: IFFALSE 104559
104492: GO 104494
104494: DISABLE
104495: LD_INT 0
104497: PPUSH
104498: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
104499: LD_ADDR_VAR 0 2
104503: PUSH
104504: LD_INT 22
104506: PUSH
104507: LD_OWVAR 2
104511: PUSH
104512: EMPTY
104513: LIST
104514: LIST
104515: PPUSH
104516: CALL_OW 69
104520: ST_TO_ADDR
// if not tmp then
104521: LD_VAR 0 2
104525: NOT
104526: IFFALSE 104530
// exit ;
104528: GO 104559
// for i in tmp do
104530: LD_ADDR_VAR 0 1
104534: PUSH
104535: LD_VAR 0 2
104539: PUSH
104540: FOR_IN
104541: IFFALSE 104557
// SetLives ( i , 300 ) ;
104543: LD_VAR 0 1
104547: PPUSH
104548: LD_INT 300
104550: PPUSH
104551: CALL_OW 234
104555: GO 104540
104557: POP
104558: POP
// end ;
104559: PPOPN 2
104561: END
// every 0 0$1 trigger s60 do var i , tmp ;
104562: LD_EXP 133
104566: IFFALSE 104635
104568: GO 104570
104570: DISABLE
104571: LD_INT 0
104573: PPUSH
104574: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
104575: LD_ADDR_VAR 0 2
104579: PUSH
104580: LD_INT 22
104582: PUSH
104583: LD_OWVAR 2
104587: PUSH
104588: EMPTY
104589: LIST
104590: LIST
104591: PPUSH
104592: CALL_OW 69
104596: ST_TO_ADDR
// if not tmp then
104597: LD_VAR 0 2
104601: NOT
104602: IFFALSE 104606
// exit ;
104604: GO 104635
// for i in tmp do
104606: LD_ADDR_VAR 0 1
104610: PUSH
104611: LD_VAR 0 2
104615: PUSH
104616: FOR_IN
104617: IFFALSE 104633
// SetLives ( i , 600 ) ;
104619: LD_VAR 0 1
104623: PPUSH
104624: LD_INT 600
104626: PPUSH
104627: CALL_OW 234
104631: GO 104616
104633: POP
104634: POP
// end ;
104635: PPOPN 2
104637: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
104638: LD_INT 0
104640: PPUSH
// case cmd of 301 :
104641: LD_VAR 0 1
104645: PUSH
104646: LD_INT 301
104648: DOUBLE
104649: EQUAL
104650: IFTRUE 104654
104652: GO 104686
104654: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
104655: LD_VAR 0 6
104659: PPUSH
104660: LD_VAR 0 7
104664: PPUSH
104665: LD_VAR 0 8
104669: PPUSH
104670: LD_VAR 0 4
104674: PPUSH
104675: LD_VAR 0 5
104679: PPUSH
104680: CALL 105895 0 5
104684: GO 104807
104686: LD_INT 302
104688: DOUBLE
104689: EQUAL
104690: IFTRUE 104694
104692: GO 104731
104694: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
104695: LD_VAR 0 6
104699: PPUSH
104700: LD_VAR 0 7
104704: PPUSH
104705: LD_VAR 0 8
104709: PPUSH
104710: LD_VAR 0 9
104714: PPUSH
104715: LD_VAR 0 4
104719: PPUSH
104720: LD_VAR 0 5
104724: PPUSH
104725: CALL 105986 0 6
104729: GO 104807
104731: LD_INT 303
104733: DOUBLE
104734: EQUAL
104735: IFTRUE 104739
104737: GO 104776
104739: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
104740: LD_VAR 0 6
104744: PPUSH
104745: LD_VAR 0 7
104749: PPUSH
104750: LD_VAR 0 8
104754: PPUSH
104755: LD_VAR 0 9
104759: PPUSH
104760: LD_VAR 0 4
104764: PPUSH
104765: LD_VAR 0 5
104769: PPUSH
104770: CALL 104812 0 6
104774: GO 104807
104776: LD_INT 304
104778: DOUBLE
104779: EQUAL
104780: IFTRUE 104784
104782: GO 104806
104784: POP
// hHackTeleport ( unit , x , y ) ; end ;
104785: LD_VAR 0 2
104789: PPUSH
104790: LD_VAR 0 4
104794: PPUSH
104795: LD_VAR 0 5
104799: PPUSH
104800: CALL 106579 0 3
104804: GO 104807
104806: POP
// end ;
104807: LD_VAR 0 12
104811: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
104812: LD_INT 0
104814: PPUSH
104815: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
104816: LD_VAR 0 1
104820: PUSH
104821: LD_INT 1
104823: LESS
104824: PUSH
104825: LD_VAR 0 1
104829: PUSH
104830: LD_INT 3
104832: GREATER
104833: OR
104834: PUSH
104835: LD_VAR 0 5
104839: PPUSH
104840: LD_VAR 0 6
104844: PPUSH
104845: CALL_OW 428
104849: OR
104850: IFFALSE 104854
// exit ;
104852: GO 105582
// uc_side := your_side ;
104854: LD_ADDR_OWVAR 20
104858: PUSH
104859: LD_OWVAR 2
104863: ST_TO_ADDR
// uc_nation := nation ;
104864: LD_ADDR_OWVAR 21
104868: PUSH
104869: LD_VAR 0 1
104873: ST_TO_ADDR
// bc_level = 1 ;
104874: LD_ADDR_OWVAR 43
104878: PUSH
104879: LD_INT 1
104881: ST_TO_ADDR
// case btype of 1 :
104882: LD_VAR 0 2
104886: PUSH
104887: LD_INT 1
104889: DOUBLE
104890: EQUAL
104891: IFTRUE 104895
104893: GO 104906
104895: POP
// bc_type := b_depot ; 2 :
104896: LD_ADDR_OWVAR 42
104900: PUSH
104901: LD_INT 0
104903: ST_TO_ADDR
104904: GO 105526
104906: LD_INT 2
104908: DOUBLE
104909: EQUAL
104910: IFTRUE 104914
104912: GO 104925
104914: POP
// bc_type := b_warehouse ; 3 :
104915: LD_ADDR_OWVAR 42
104919: PUSH
104920: LD_INT 1
104922: ST_TO_ADDR
104923: GO 105526
104925: LD_INT 3
104927: DOUBLE
104928: EQUAL
104929: IFTRUE 104933
104931: GO 104944
104933: POP
// bc_type := b_lab ; 4 .. 9 :
104934: LD_ADDR_OWVAR 42
104938: PUSH
104939: LD_INT 6
104941: ST_TO_ADDR
104942: GO 105526
104944: LD_INT 4
104946: DOUBLE
104947: GREATEREQUAL
104948: IFFALSE 104956
104950: LD_INT 9
104952: DOUBLE
104953: LESSEQUAL
104954: IFTRUE 104958
104956: GO 105018
104958: POP
// begin bc_type := b_lab_half ;
104959: LD_ADDR_OWVAR 42
104963: PUSH
104964: LD_INT 7
104966: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
104967: LD_ADDR_OWVAR 44
104971: PUSH
104972: LD_INT 10
104974: PUSH
104975: LD_INT 11
104977: PUSH
104978: LD_INT 12
104980: PUSH
104981: LD_INT 15
104983: PUSH
104984: LD_INT 14
104986: PUSH
104987: LD_INT 13
104989: PUSH
104990: EMPTY
104991: LIST
104992: LIST
104993: LIST
104994: LIST
104995: LIST
104996: LIST
104997: PUSH
104998: LD_VAR 0 2
105002: PUSH
105003: LD_INT 3
105005: MINUS
105006: ARRAY
105007: ST_TO_ADDR
// bc_kind2 := b_lab_basic ;
105008: LD_ADDR_OWVAR 45
105012: PUSH
105013: LD_INT 9
105015: ST_TO_ADDR
// end ; 10 .. 13 :
105016: GO 105526
105018: LD_INT 10
105020: DOUBLE
105021: GREATEREQUAL
105022: IFFALSE 105030
105024: LD_INT 13
105026: DOUBLE
105027: LESSEQUAL
105028: IFTRUE 105032
105030: GO 105109
105032: POP
// begin bc_type := b_lab_full ;
105033: LD_ADDR_OWVAR 42
105037: PUSH
105038: LD_INT 8
105040: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
105041: LD_ADDR_OWVAR 44
105045: PUSH
105046: LD_INT 10
105048: PUSH
105049: LD_INT 12
105051: PUSH
105052: LD_INT 14
105054: PUSH
105055: LD_INT 13
105057: PUSH
105058: EMPTY
105059: LIST
105060: LIST
105061: LIST
105062: LIST
105063: PUSH
105064: LD_VAR 0 2
105068: PUSH
105069: LD_INT 9
105071: MINUS
105072: ARRAY
105073: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
105074: LD_ADDR_OWVAR 45
105078: PUSH
105079: LD_INT 11
105081: PUSH
105082: LD_INT 15
105084: PUSH
105085: LD_INT 12
105087: PUSH
105088: LD_INT 15
105090: PUSH
105091: EMPTY
105092: LIST
105093: LIST
105094: LIST
105095: LIST
105096: PUSH
105097: LD_VAR 0 2
105101: PUSH
105102: LD_INT 9
105104: MINUS
105105: ARRAY
105106: ST_TO_ADDR
// end ; 14 :
105107: GO 105526
105109: LD_INT 14
105111: DOUBLE
105112: EQUAL
105113: IFTRUE 105117
105115: GO 105128
105117: POP
// bc_type := b_workshop ; 15 :
105118: LD_ADDR_OWVAR 42
105122: PUSH
105123: LD_INT 2
105125: ST_TO_ADDR
105126: GO 105526
105128: LD_INT 15
105130: DOUBLE
105131: EQUAL
105132: IFTRUE 105136
105134: GO 105147
105136: POP
// bc_type := b_factory ; 16 :
105137: LD_ADDR_OWVAR 42
105141: PUSH
105142: LD_INT 3
105144: ST_TO_ADDR
105145: GO 105526
105147: LD_INT 16
105149: DOUBLE
105150: EQUAL
105151: IFTRUE 105155
105153: GO 105166
105155: POP
// bc_type := b_ext_gun ; 17 :
105156: LD_ADDR_OWVAR 42
105160: PUSH
105161: LD_INT 17
105163: ST_TO_ADDR
105164: GO 105526
105166: LD_INT 17
105168: DOUBLE
105169: EQUAL
105170: IFTRUE 105174
105172: GO 105202
105174: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
105175: LD_ADDR_OWVAR 42
105179: PUSH
105180: LD_INT 19
105182: PUSH
105183: LD_INT 23
105185: PUSH
105186: LD_INT 19
105188: PUSH
105189: EMPTY
105190: LIST
105191: LIST
105192: LIST
105193: PUSH
105194: LD_VAR 0 1
105198: ARRAY
105199: ST_TO_ADDR
105200: GO 105526
105202: LD_INT 18
105204: DOUBLE
105205: EQUAL
105206: IFTRUE 105210
105208: GO 105221
105210: POP
// bc_type := b_ext_radar ; 19 :
105211: LD_ADDR_OWVAR 42
105215: PUSH
105216: LD_INT 20
105218: ST_TO_ADDR
105219: GO 105526
105221: LD_INT 19
105223: DOUBLE
105224: EQUAL
105225: IFTRUE 105229
105227: GO 105240
105229: POP
// bc_type := b_ext_radio ; 20 :
105230: LD_ADDR_OWVAR 42
105234: PUSH
105235: LD_INT 22
105237: ST_TO_ADDR
105238: GO 105526
105240: LD_INT 20
105242: DOUBLE
105243: EQUAL
105244: IFTRUE 105248
105246: GO 105259
105248: POP
// bc_type := b_ext_siberium ; 21 :
105249: LD_ADDR_OWVAR 42
105253: PUSH
105254: LD_INT 21
105256: ST_TO_ADDR
105257: GO 105526
105259: LD_INT 21
105261: DOUBLE
105262: EQUAL
105263: IFTRUE 105267
105265: GO 105278
105267: POP
// bc_type := b_ext_computer ; 22 :
105268: LD_ADDR_OWVAR 42
105272: PUSH
105273: LD_INT 24
105275: ST_TO_ADDR
105276: GO 105526
105278: LD_INT 22
105280: DOUBLE
105281: EQUAL
105282: IFTRUE 105286
105284: GO 105297
105286: POP
// bc_type := b_ext_track ; 23 :
105287: LD_ADDR_OWVAR 42
105291: PUSH
105292: LD_INT 16
105294: ST_TO_ADDR
105295: GO 105526
105297: LD_INT 23
105299: DOUBLE
105300: EQUAL
105301: IFTRUE 105305
105303: GO 105316
105305: POP
// bc_type := b_ext_laser ; 24 :
105306: LD_ADDR_OWVAR 42
105310: PUSH
105311: LD_INT 25
105313: ST_TO_ADDR
105314: GO 105526
105316: LD_INT 24
105318: DOUBLE
105319: EQUAL
105320: IFTRUE 105324
105322: GO 105335
105324: POP
// bc_type := b_control_tower ; 25 :
105325: LD_ADDR_OWVAR 42
105329: PUSH
105330: LD_INT 36
105332: ST_TO_ADDR
105333: GO 105526
105335: LD_INT 25
105337: DOUBLE
105338: EQUAL
105339: IFTRUE 105343
105341: GO 105354
105343: POP
// bc_type := b_breastwork ; 26 :
105344: LD_ADDR_OWVAR 42
105348: PUSH
105349: LD_INT 31
105351: ST_TO_ADDR
105352: GO 105526
105354: LD_INT 26
105356: DOUBLE
105357: EQUAL
105358: IFTRUE 105362
105360: GO 105373
105362: POP
// bc_type := b_bunker ; 27 :
105363: LD_ADDR_OWVAR 42
105367: PUSH
105368: LD_INT 32
105370: ST_TO_ADDR
105371: GO 105526
105373: LD_INT 27
105375: DOUBLE
105376: EQUAL
105377: IFTRUE 105381
105379: GO 105392
105381: POP
// bc_type := b_turret ; 28 :
105382: LD_ADDR_OWVAR 42
105386: PUSH
105387: LD_INT 33
105389: ST_TO_ADDR
105390: GO 105526
105392: LD_INT 28
105394: DOUBLE
105395: EQUAL
105396: IFTRUE 105400
105398: GO 105411
105400: POP
// bc_type := b_armoury ; 29 :
105401: LD_ADDR_OWVAR 42
105405: PUSH
105406: LD_INT 4
105408: ST_TO_ADDR
105409: GO 105526
105411: LD_INT 29
105413: DOUBLE
105414: EQUAL
105415: IFTRUE 105419
105417: GO 105430
105419: POP
// bc_type := b_barracks ; 30 :
105420: LD_ADDR_OWVAR 42
105424: PUSH
105425: LD_INT 5
105427: ST_TO_ADDR
105428: GO 105526
105430: LD_INT 30
105432: DOUBLE
105433: EQUAL
105434: IFTRUE 105438
105436: GO 105449
105438: POP
// bc_type := b_solar_power ; 31 :
105439: LD_ADDR_OWVAR 42
105443: PUSH
105444: LD_INT 27
105446: ST_TO_ADDR
105447: GO 105526
105449: LD_INT 31
105451: DOUBLE
105452: EQUAL
105453: IFTRUE 105457
105455: GO 105468
105457: POP
// bc_type := b_oil_power ; 32 :
105458: LD_ADDR_OWVAR 42
105462: PUSH
105463: LD_INT 26
105465: ST_TO_ADDR
105466: GO 105526
105468: LD_INT 32
105470: DOUBLE
105471: EQUAL
105472: IFTRUE 105476
105474: GO 105487
105476: POP
// bc_type := b_siberite_power ; 33 :
105477: LD_ADDR_OWVAR 42
105481: PUSH
105482: LD_INT 28
105484: ST_TO_ADDR
105485: GO 105526
105487: LD_INT 33
105489: DOUBLE
105490: EQUAL
105491: IFTRUE 105495
105493: GO 105506
105495: POP
// bc_type := b_oil_mine ; 34 :
105496: LD_ADDR_OWVAR 42
105500: PUSH
105501: LD_INT 29
105503: ST_TO_ADDR
105504: GO 105526
105506: LD_INT 34
105508: DOUBLE
105509: EQUAL
105510: IFTRUE 105514
105512: GO 105525
105514: POP
// bc_type := b_siberite_mine ; end ;
105515: LD_ADDR_OWVAR 42
105519: PUSH
105520: LD_INT 30
105522: ST_TO_ADDR
105523: GO 105526
105525: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
105526: LD_ADDR_VAR 0 8
105530: PUSH
105531: LD_VAR 0 5
105535: PPUSH
105536: LD_VAR 0 6
105540: PPUSH
105541: LD_VAR 0 3
105545: PPUSH
105546: CALL_OW 47
105550: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
105551: LD_OWVAR 42
105555: PUSH
105556: LD_INT 32
105558: PUSH
105559: LD_INT 33
105561: PUSH
105562: EMPTY
105563: LIST
105564: LIST
105565: IN
105566: IFFALSE 105582
// PlaceWeaponTurret ( b , weapon ) ;
105568: LD_VAR 0 8
105572: PPUSH
105573: LD_VAR 0 4
105577: PPUSH
105578: CALL_OW 431
// end ;
105582: LD_VAR 0 7
105586: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
105587: LD_INT 0
105589: PPUSH
105590: PPUSH
105591: PPUSH
105592: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
105593: LD_ADDR_VAR 0 4
105597: PUSH
105598: LD_INT 22
105600: PUSH
105601: LD_OWVAR 2
105605: PUSH
105606: EMPTY
105607: LIST
105608: LIST
105609: PUSH
105610: LD_INT 2
105612: PUSH
105613: LD_INT 30
105615: PUSH
105616: LD_INT 0
105618: PUSH
105619: EMPTY
105620: LIST
105621: LIST
105622: PUSH
105623: LD_INT 30
105625: PUSH
105626: LD_INT 1
105628: PUSH
105629: EMPTY
105630: LIST
105631: LIST
105632: PUSH
105633: EMPTY
105634: LIST
105635: LIST
105636: LIST
105637: PUSH
105638: EMPTY
105639: LIST
105640: LIST
105641: PPUSH
105642: CALL_OW 69
105646: ST_TO_ADDR
// if not tmp then
105647: LD_VAR 0 4
105651: NOT
105652: IFFALSE 105656
// exit ;
105654: GO 105715
// for i in tmp do
105656: LD_ADDR_VAR 0 2
105660: PUSH
105661: LD_VAR 0 4
105665: PUSH
105666: FOR_IN
105667: IFFALSE 105713
// for j = 1 to 3 do
105669: LD_ADDR_VAR 0 3
105673: PUSH
105674: DOUBLE
105675: LD_INT 1
105677: DEC
105678: ST_TO_ADDR
105679: LD_INT 3
105681: PUSH
105682: FOR_TO
105683: IFFALSE 105709
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
105685: LD_VAR 0 2
105689: PPUSH
105690: CALL_OW 274
105694: PPUSH
105695: LD_VAR 0 3
105699: PPUSH
105700: LD_INT 99999
105702: PPUSH
105703: CALL_OW 277
105707: GO 105682
105709: POP
105710: POP
105711: GO 105666
105713: POP
105714: POP
// end ;
105715: LD_VAR 0 1
105719: RET
// export function hHackSetLevel10 ; var i , j ; begin
105720: LD_INT 0
105722: PPUSH
105723: PPUSH
105724: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
105725: LD_ADDR_VAR 0 2
105729: PUSH
105730: LD_INT 21
105732: PUSH
105733: LD_INT 1
105735: PUSH
105736: EMPTY
105737: LIST
105738: LIST
105739: PPUSH
105740: CALL_OW 69
105744: PUSH
105745: FOR_IN
105746: IFFALSE 105798
// if IsSelected ( i ) then
105748: LD_VAR 0 2
105752: PPUSH
105753: CALL_OW 306
105757: IFFALSE 105796
// begin for j := 1 to 4 do
105759: LD_ADDR_VAR 0 3
105763: PUSH
105764: DOUBLE
105765: LD_INT 1
105767: DEC
105768: ST_TO_ADDR
105769: LD_INT 4
105771: PUSH
105772: FOR_TO
105773: IFFALSE 105794
// SetSkill ( i , j , 10 ) ;
105775: LD_VAR 0 2
105779: PPUSH
105780: LD_VAR 0 3
105784: PPUSH
105785: LD_INT 10
105787: PPUSH
105788: CALL_OW 237
105792: GO 105772
105794: POP
105795: POP
// end ;
105796: GO 105745
105798: POP
105799: POP
// end ;
105800: LD_VAR 0 1
105804: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
105805: LD_INT 0
105807: PPUSH
105808: PPUSH
105809: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
105810: LD_ADDR_VAR 0 2
105814: PUSH
105815: LD_INT 22
105817: PUSH
105818: LD_OWVAR 2
105822: PUSH
105823: EMPTY
105824: LIST
105825: LIST
105826: PUSH
105827: LD_INT 21
105829: PUSH
105830: LD_INT 1
105832: PUSH
105833: EMPTY
105834: LIST
105835: LIST
105836: PUSH
105837: EMPTY
105838: LIST
105839: LIST
105840: PPUSH
105841: CALL_OW 69
105845: PUSH
105846: FOR_IN
105847: IFFALSE 105888
// begin for j := 1 to 4 do
105849: LD_ADDR_VAR 0 3
105853: PUSH
105854: DOUBLE
105855: LD_INT 1
105857: DEC
105858: ST_TO_ADDR
105859: LD_INT 4
105861: PUSH
105862: FOR_TO
105863: IFFALSE 105884
// SetSkill ( i , j , 10 ) ;
105865: LD_VAR 0 2
105869: PPUSH
105870: LD_VAR 0 3
105874: PPUSH
105875: LD_INT 10
105877: PPUSH
105878: CALL_OW 237
105882: GO 105862
105884: POP
105885: POP
// end ;
105886: GO 105846
105888: POP
105889: POP
// end ;
105890: LD_VAR 0 1
105894: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
105895: LD_INT 0
105897: PPUSH
// uc_side := your_side ;
105898: LD_ADDR_OWVAR 20
105902: PUSH
105903: LD_OWVAR 2
105907: ST_TO_ADDR
// uc_nation := nation ;
105908: LD_ADDR_OWVAR 21
105912: PUSH
105913: LD_VAR 0 1
105917: ST_TO_ADDR
// InitHc ;
105918: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
105922: LD_INT 0
105924: PPUSH
105925: LD_VAR 0 2
105929: PPUSH
105930: LD_VAR 0 3
105934: PPUSH
105935: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
105939: LD_VAR 0 4
105943: PPUSH
105944: LD_VAR 0 5
105948: PPUSH
105949: CALL_OW 428
105953: PUSH
105954: LD_INT 0
105956: EQUAL
105957: IFFALSE 105981
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
105959: CALL_OW 44
105963: PPUSH
105964: LD_VAR 0 4
105968: PPUSH
105969: LD_VAR 0 5
105973: PPUSH
105974: LD_INT 1
105976: PPUSH
105977: CALL_OW 48
// end ;
105981: LD_VAR 0 6
105985: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
105986: LD_INT 0
105988: PPUSH
105989: PPUSH
// uc_side := your_side ;
105990: LD_ADDR_OWVAR 20
105994: PUSH
105995: LD_OWVAR 2
105999: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
106000: LD_VAR 0 1
106004: PUSH
106005: LD_INT 1
106007: PUSH
106008: LD_INT 2
106010: PUSH
106011: LD_INT 3
106013: PUSH
106014: LD_INT 4
106016: PUSH
106017: LD_INT 5
106019: PUSH
106020: EMPTY
106021: LIST
106022: LIST
106023: LIST
106024: LIST
106025: LIST
106026: IN
106027: IFFALSE 106039
// uc_nation := nation_american else
106029: LD_ADDR_OWVAR 21
106033: PUSH
106034: LD_INT 1
106036: ST_TO_ADDR
106037: GO 106082
// if chassis in [ 11 , 12 , 13 , 14 ] then
106039: LD_VAR 0 1
106043: PUSH
106044: LD_INT 11
106046: PUSH
106047: LD_INT 12
106049: PUSH
106050: LD_INT 13
106052: PUSH
106053: LD_INT 14
106055: PUSH
106056: EMPTY
106057: LIST
106058: LIST
106059: LIST
106060: LIST
106061: IN
106062: IFFALSE 106074
// uc_nation := nation_arabian else
106064: LD_ADDR_OWVAR 21
106068: PUSH
106069: LD_INT 2
106071: ST_TO_ADDR
106072: GO 106082
// uc_nation := nation_russian ;
106074: LD_ADDR_OWVAR 21
106078: PUSH
106079: LD_INT 3
106081: ST_TO_ADDR
// vc_chassis := chassis ;
106082: LD_ADDR_OWVAR 37
106086: PUSH
106087: LD_VAR 0 1
106091: ST_TO_ADDR
// vc_engine := engine ;
106092: LD_ADDR_OWVAR 39
106096: PUSH
106097: LD_VAR 0 2
106101: ST_TO_ADDR
// vc_control := control ;
106102: LD_ADDR_OWVAR 38
106106: PUSH
106107: LD_VAR 0 3
106111: ST_TO_ADDR
// vc_weapon := weapon ;
106112: LD_ADDR_OWVAR 40
106116: PUSH
106117: LD_VAR 0 4
106121: ST_TO_ADDR
// un := CreateVehicle ;
106122: LD_ADDR_VAR 0 8
106126: PUSH
106127: CALL_OW 45
106131: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
106132: LD_VAR 0 8
106136: PPUSH
106137: LD_INT 0
106139: PPUSH
106140: LD_INT 5
106142: PPUSH
106143: CALL_OW 12
106147: PPUSH
106148: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
106152: LD_VAR 0 8
106156: PPUSH
106157: LD_VAR 0 5
106161: PPUSH
106162: LD_VAR 0 6
106166: PPUSH
106167: LD_INT 1
106169: PPUSH
106170: CALL_OW 48
// end ;
106174: LD_VAR 0 7
106178: RET
// export hInvincible ; every 1 do
106179: GO 106181
106181: DISABLE
// hInvincible := [ ] ;
106182: LD_ADDR_EXP 134
106186: PUSH
106187: EMPTY
106188: ST_TO_ADDR
106189: END
// every 10 do var i ;
106190: GO 106192
106192: DISABLE
106193: LD_INT 0
106195: PPUSH
// begin enable ;
106196: ENABLE
// if not hInvincible then
106197: LD_EXP 134
106201: NOT
106202: IFFALSE 106206
// exit ;
106204: GO 106250
// for i in hInvincible do
106206: LD_ADDR_VAR 0 1
106210: PUSH
106211: LD_EXP 134
106215: PUSH
106216: FOR_IN
106217: IFFALSE 106248
// if GetLives ( i ) < 1000 then
106219: LD_VAR 0 1
106223: PPUSH
106224: CALL_OW 256
106228: PUSH
106229: LD_INT 1000
106231: LESS
106232: IFFALSE 106246
// SetLives ( i , 1000 ) ;
106234: LD_VAR 0 1
106238: PPUSH
106239: LD_INT 1000
106241: PPUSH
106242: CALL_OW 234
106246: GO 106216
106248: POP
106249: POP
// end ;
106250: PPOPN 1
106252: END
// export function hHackInvincible ; var i ; begin
106253: LD_INT 0
106255: PPUSH
106256: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
106257: LD_ADDR_VAR 0 2
106261: PUSH
106262: LD_INT 2
106264: PUSH
106265: LD_INT 21
106267: PUSH
106268: LD_INT 1
106270: PUSH
106271: EMPTY
106272: LIST
106273: LIST
106274: PUSH
106275: LD_INT 21
106277: PUSH
106278: LD_INT 2
106280: PUSH
106281: EMPTY
106282: LIST
106283: LIST
106284: PUSH
106285: EMPTY
106286: LIST
106287: LIST
106288: LIST
106289: PPUSH
106290: CALL_OW 69
106294: PUSH
106295: FOR_IN
106296: IFFALSE 106357
// if IsSelected ( i ) then
106298: LD_VAR 0 2
106302: PPUSH
106303: CALL_OW 306
106307: IFFALSE 106355
// begin if i in hInvincible then
106309: LD_VAR 0 2
106313: PUSH
106314: LD_EXP 134
106318: IN
106319: IFFALSE 106339
// hInvincible := hInvincible diff i else
106321: LD_ADDR_EXP 134
106325: PUSH
106326: LD_EXP 134
106330: PUSH
106331: LD_VAR 0 2
106335: DIFF
106336: ST_TO_ADDR
106337: GO 106355
// hInvincible := hInvincible union i ;
106339: LD_ADDR_EXP 134
106343: PUSH
106344: LD_EXP 134
106348: PUSH
106349: LD_VAR 0 2
106353: UNION
106354: ST_TO_ADDR
// end ;
106355: GO 106295
106357: POP
106358: POP
// end ;
106359: LD_VAR 0 1
106363: RET
// export function hHackInvisible ; var i , j ; begin
106364: LD_INT 0
106366: PPUSH
106367: PPUSH
106368: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
106369: LD_ADDR_VAR 0 2
106373: PUSH
106374: LD_INT 21
106376: PUSH
106377: LD_INT 1
106379: PUSH
106380: EMPTY
106381: LIST
106382: LIST
106383: PPUSH
106384: CALL_OW 69
106388: PUSH
106389: FOR_IN
106390: IFFALSE 106414
// if IsSelected ( i ) then
106392: LD_VAR 0 2
106396: PPUSH
106397: CALL_OW 306
106401: IFFALSE 106412
// ComForceInvisible ( i ) ;
106403: LD_VAR 0 2
106407: PPUSH
106408: CALL_OW 496
106412: GO 106389
106414: POP
106415: POP
// end ;
106416: LD_VAR 0 1
106420: RET
// export function hHackChangeYourSide ; begin
106421: LD_INT 0
106423: PPUSH
// if your_side = 8 then
106424: LD_OWVAR 2
106428: PUSH
106429: LD_INT 8
106431: EQUAL
106432: IFFALSE 106444
// your_side := 0 else
106434: LD_ADDR_OWVAR 2
106438: PUSH
106439: LD_INT 0
106441: ST_TO_ADDR
106442: GO 106458
// your_side := your_side + 1 ;
106444: LD_ADDR_OWVAR 2
106448: PUSH
106449: LD_OWVAR 2
106453: PUSH
106454: LD_INT 1
106456: PLUS
106457: ST_TO_ADDR
// end ;
106458: LD_VAR 0 1
106462: RET
// export function hHackChangeUnitSide ; var i , j ; begin
106463: LD_INT 0
106465: PPUSH
106466: PPUSH
106467: PPUSH
// for i in all_units do
106468: LD_ADDR_VAR 0 2
106472: PUSH
106473: LD_OWVAR 3
106477: PUSH
106478: FOR_IN
106479: IFFALSE 106557
// if IsSelected ( i ) then
106481: LD_VAR 0 2
106485: PPUSH
106486: CALL_OW 306
106490: IFFALSE 106555
// begin j := GetSide ( i ) ;
106492: LD_ADDR_VAR 0 3
106496: PUSH
106497: LD_VAR 0 2
106501: PPUSH
106502: CALL_OW 255
106506: ST_TO_ADDR
// if j = 8 then
106507: LD_VAR 0 3
106511: PUSH
106512: LD_INT 8
106514: EQUAL
106515: IFFALSE 106527
// j := 0 else
106517: LD_ADDR_VAR 0 3
106521: PUSH
106522: LD_INT 0
106524: ST_TO_ADDR
106525: GO 106541
// j := j + 1 ;
106527: LD_ADDR_VAR 0 3
106531: PUSH
106532: LD_VAR 0 3
106536: PUSH
106537: LD_INT 1
106539: PLUS
106540: ST_TO_ADDR
// SetSide ( i , j ) ;
106541: LD_VAR 0 2
106545: PPUSH
106546: LD_VAR 0 3
106550: PPUSH
106551: CALL_OW 235
// end ;
106555: GO 106478
106557: POP
106558: POP
// end ;
106559: LD_VAR 0 1
106563: RET
// export function hHackFog ; begin
106564: LD_INT 0
106566: PPUSH
// FogOff ( true ) ;
106567: LD_INT 1
106569: PPUSH
106570: CALL_OW 344
// end ;
106574: LD_VAR 0 1
106578: RET
// export function hHackTeleport ( unit , x , y ) ; begin
106579: LD_INT 0
106581: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
106582: LD_VAR 0 1
106586: PPUSH
106587: LD_VAR 0 2
106591: PPUSH
106592: LD_VAR 0 3
106596: PPUSH
106597: LD_INT 1
106599: PPUSH
106600: LD_INT 1
106602: PPUSH
106603: CALL_OW 483
// CenterOnXY ( x , y ) ;
106607: LD_VAR 0 2
106611: PPUSH
106612: LD_VAR 0 3
106616: PPUSH
106617: CALL_OW 84
// end ;
106621: LD_VAR 0 4
106625: RET
// export factoryWaypoints ; export function SetFactoryWaypoint ( factory , x , y ) ; var i ; begin
106626: LD_INT 0
106628: PPUSH
106629: PPUSH
// if not factory or not ValidHex ( x , y ) or ( GetBType ( factory ) <> b_factory and not GetType ( factory ) = unit_human ) then
106630: LD_VAR 0 1
106634: NOT
106635: PUSH
106636: LD_VAR 0 2
106640: PPUSH
106641: LD_VAR 0 3
106645: PPUSH
106646: CALL_OW 488
106650: NOT
106651: OR
106652: PUSH
106653: LD_VAR 0 1
106657: PPUSH
106658: CALL_OW 266
106662: PUSH
106663: LD_INT 3
106665: NONEQUAL
106666: PUSH
106667: LD_VAR 0 1
106671: PPUSH
106672: CALL_OW 247
106676: PUSH
106677: LD_INT 1
106679: EQUAL
106680: NOT
106681: AND
106682: OR
106683: IFFALSE 106687
// exit ;
106685: GO 106836
// if GetType ( factory ) = unit_human then
106687: LD_VAR 0 1
106691: PPUSH
106692: CALL_OW 247
106696: PUSH
106697: LD_INT 1
106699: EQUAL
106700: IFFALSE 106717
// factory := IsInUnit ( factory ) ;
106702: LD_ADDR_VAR 0 1
106706: PUSH
106707: LD_VAR 0 1
106711: PPUSH
106712: CALL_OW 310
106716: ST_TO_ADDR
// if GetBType ( factory ) <> b_factory then
106717: LD_VAR 0 1
106721: PPUSH
106722: CALL_OW 266
106726: PUSH
106727: LD_INT 3
106729: NONEQUAL
106730: IFFALSE 106734
// exit ;
106732: GO 106836
// if HexInfo ( x , y ) = factory then
106734: LD_VAR 0 2
106738: PPUSH
106739: LD_VAR 0 3
106743: PPUSH
106744: CALL_OW 428
106748: PUSH
106749: LD_VAR 0 1
106753: EQUAL
106754: IFFALSE 106781
// factoryWaypoints := Replace ( factoryWaypoints , factory , 0 ) else
106756: LD_ADDR_EXP 135
106760: PUSH
106761: LD_EXP 135
106765: PPUSH
106766: LD_VAR 0 1
106770: PPUSH
106771: LD_INT 0
106773: PPUSH
106774: CALL_OW 1
106778: ST_TO_ADDR
106779: GO 106832
// factoryWaypoints := Replace ( factoryWaypoints , factory , [ GetSide ( factory ) , factory , x , y ] ) ;
106781: LD_ADDR_EXP 135
106785: PUSH
106786: LD_EXP 135
106790: PPUSH
106791: LD_VAR 0 1
106795: PPUSH
106796: LD_VAR 0 1
106800: PPUSH
106801: CALL_OW 255
106805: PUSH
106806: LD_VAR 0 1
106810: PUSH
106811: LD_VAR 0 2
106815: PUSH
106816: LD_VAR 0 3
106820: PUSH
106821: EMPTY
106822: LIST
106823: LIST
106824: LIST
106825: LIST
106826: PPUSH
106827: CALL_OW 1
106831: ST_TO_ADDR
// UpdateFactoryWaypoints ;
106832: CALL 106841 0 0
// end ;
106836: LD_VAR 0 4
106840: RET
// export function UpdateFactoryWaypoints ( ) ; var i , list ; begin
106841: LD_INT 0
106843: PPUSH
106844: PPUSH
106845: PPUSH
// ToLua ( resetFactoryWaypoint(); ) ;
106846: LD_STRING resetFactoryWaypoint();
106848: PPUSH
106849: CALL_OW 559
// if factoryWaypoints then
106853: LD_EXP 135
106857: IFFALSE 106983
// begin list := PrepareArray ( factoryWaypoints ) ;
106859: LD_ADDR_VAR 0 3
106863: PUSH
106864: LD_EXP 135
106868: PPUSH
106869: CALL 60963 0 1
106873: ST_TO_ADDR
// for i := 1 to list do
106874: LD_ADDR_VAR 0 2
106878: PUSH
106879: DOUBLE
106880: LD_INT 1
106882: DEC
106883: ST_TO_ADDR
106884: LD_VAR 0 3
106888: PUSH
106889: FOR_TO
106890: IFFALSE 106981
// ToLua ( setFactoryWaypointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
106892: LD_STRING setFactoryWaypointXY(
106894: PUSH
106895: LD_VAR 0 3
106899: PUSH
106900: LD_VAR 0 2
106904: ARRAY
106905: PUSH
106906: LD_INT 1
106908: ARRAY
106909: STR
106910: PUSH
106911: LD_STRING ,
106913: STR
106914: PUSH
106915: LD_VAR 0 3
106919: PUSH
106920: LD_VAR 0 2
106924: ARRAY
106925: PUSH
106926: LD_INT 2
106928: ARRAY
106929: STR
106930: PUSH
106931: LD_STRING ,
106933: STR
106934: PUSH
106935: LD_VAR 0 3
106939: PUSH
106940: LD_VAR 0 2
106944: ARRAY
106945: PUSH
106946: LD_INT 3
106948: ARRAY
106949: STR
106950: PUSH
106951: LD_STRING ,
106953: STR
106954: PUSH
106955: LD_VAR 0 3
106959: PUSH
106960: LD_VAR 0 2
106964: ARRAY
106965: PUSH
106966: LD_INT 4
106968: ARRAY
106969: STR
106970: PUSH
106971: LD_STRING )
106973: STR
106974: PPUSH
106975: CALL_OW 559
106979: GO 106889
106981: POP
106982: POP
// end ; end ;
106983: LD_VAR 0 1
106987: RET
// export warehouseGatheringPoints , warehouseCratesCollectors ; export function SetWarehouseGatheringPoint ( warehouse , x , y ) ; begin
106988: LD_INT 0
106990: PPUSH
// if HexInfo ( x , y ) = warehouse then
106991: LD_VAR 0 2
106995: PPUSH
106996: LD_VAR 0 3
107000: PPUSH
107001: CALL_OW 428
107005: PUSH
107006: LD_VAR 0 1
107010: EQUAL
107011: IFFALSE 107038
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , 0 ) else
107013: LD_ADDR_EXP 136
107017: PUSH
107018: LD_EXP 136
107022: PPUSH
107023: LD_VAR 0 1
107027: PPUSH
107028: LD_INT 0
107030: PPUSH
107031: CALL_OW 1
107035: ST_TO_ADDR
107036: GO 107089
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , [ GetSide ( warehouse ) , warehouse , x , y ] ) ;
107038: LD_ADDR_EXP 136
107042: PUSH
107043: LD_EXP 136
107047: PPUSH
107048: LD_VAR 0 1
107052: PPUSH
107053: LD_VAR 0 1
107057: PPUSH
107058: CALL_OW 255
107062: PUSH
107063: LD_VAR 0 1
107067: PUSH
107068: LD_VAR 0 2
107072: PUSH
107073: LD_VAR 0 3
107077: PUSH
107078: EMPTY
107079: LIST
107080: LIST
107081: LIST
107082: LIST
107083: PPUSH
107084: CALL_OW 1
107088: ST_TO_ADDR
// UpdateWarehouseGatheringPoints ;
107089: CALL 107098 0 0
// end ;
107093: LD_VAR 0 4
107097: RET
// export function UpdateWarehouseGatheringPoints ( ) ; var i , list ; begin
107098: LD_INT 0
107100: PPUSH
107101: PPUSH
107102: PPUSH
// ToLua ( resetWarehouseGatheringPoints(); ) ;
107103: LD_STRING resetWarehouseGatheringPoints();
107105: PPUSH
107106: CALL_OW 559
// if warehouseGatheringPoints then
107110: LD_EXP 136
107114: IFFALSE 107240
// begin list := PrepareArray ( warehouseGatheringPoints ) ;
107116: LD_ADDR_VAR 0 3
107120: PUSH
107121: LD_EXP 136
107125: PPUSH
107126: CALL 60963 0 1
107130: ST_TO_ADDR
// for i := 1 to list do
107131: LD_ADDR_VAR 0 2
107135: PUSH
107136: DOUBLE
107137: LD_INT 1
107139: DEC
107140: ST_TO_ADDR
107141: LD_VAR 0 3
107145: PUSH
107146: FOR_TO
107147: IFFALSE 107238
// ToLua ( setWarehouseGatheringPointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
107149: LD_STRING setWarehouseGatheringPointXY(
107151: PUSH
107152: LD_VAR 0 3
107156: PUSH
107157: LD_VAR 0 2
107161: ARRAY
107162: PUSH
107163: LD_INT 1
107165: ARRAY
107166: STR
107167: PUSH
107168: LD_STRING ,
107170: STR
107171: PUSH
107172: LD_VAR 0 3
107176: PUSH
107177: LD_VAR 0 2
107181: ARRAY
107182: PUSH
107183: LD_INT 2
107185: ARRAY
107186: STR
107187: PUSH
107188: LD_STRING ,
107190: STR
107191: PUSH
107192: LD_VAR 0 3
107196: PUSH
107197: LD_VAR 0 2
107201: ARRAY
107202: PUSH
107203: LD_INT 3
107205: ARRAY
107206: STR
107207: PUSH
107208: LD_STRING ,
107210: STR
107211: PUSH
107212: LD_VAR 0 3
107216: PUSH
107217: LD_VAR 0 2
107221: ARRAY
107222: PUSH
107223: LD_INT 4
107225: ARRAY
107226: STR
107227: PUSH
107228: LD_STRING )
107230: STR
107231: PPUSH
107232: CALL_OW 559
107236: GO 107146
107238: POP
107239: POP
// end ; end ;
107240: LD_VAR 0 1
107244: RET
// every 0 0$20 trigger warehouseGatheringPoints do var i , j , list , tmp , side , x , y , depot , cratesNearbyPoint ;
107245: LD_EXP 136
107249: IFFALSE 107934
107251: GO 107253
107253: DISABLE
107254: LD_INT 0
107256: PPUSH
107257: PPUSH
107258: PPUSH
107259: PPUSH
107260: PPUSH
107261: PPUSH
107262: PPUSH
107263: PPUSH
107264: PPUSH
// begin enable ;
107265: ENABLE
// list := PrepareArray ( warehouseGatheringPoints ) ;
107266: LD_ADDR_VAR 0 3
107270: PUSH
107271: LD_EXP 136
107275: PPUSH
107276: CALL 60963 0 1
107280: ST_TO_ADDR
// if not list then
107281: LD_VAR 0 3
107285: NOT
107286: IFFALSE 107290
// exit ;
107288: GO 107934
// for i := 1 to list do
107290: LD_ADDR_VAR 0 1
107294: PUSH
107295: DOUBLE
107296: LD_INT 1
107298: DEC
107299: ST_TO_ADDR
107300: LD_VAR 0 3
107304: PUSH
107305: FOR_TO
107306: IFFALSE 107932
// begin depot := list [ i ] [ 2 ] ;
107308: LD_ADDR_VAR 0 8
107312: PUSH
107313: LD_VAR 0 3
107317: PUSH
107318: LD_VAR 0 1
107322: ARRAY
107323: PUSH
107324: LD_INT 2
107326: ARRAY
107327: ST_TO_ADDR
// side := list [ i ] [ 1 ] ;
107328: LD_ADDR_VAR 0 5
107332: PUSH
107333: LD_VAR 0 3
107337: PUSH
107338: LD_VAR 0 1
107342: ARRAY
107343: PUSH
107344: LD_INT 1
107346: ARRAY
107347: ST_TO_ADDR
// if IsDead ( depot ) or side <> GetSide ( depot ) then
107348: LD_VAR 0 8
107352: PPUSH
107353: CALL_OW 301
107357: PUSH
107358: LD_VAR 0 5
107362: PUSH
107363: LD_VAR 0 8
107367: PPUSH
107368: CALL_OW 255
107372: NONEQUAL
107373: OR
107374: IFFALSE 107403
// begin warehouseGatheringPoints := Replace ( warehouseGatheringPoints , depot , 0 ) ;
107376: LD_ADDR_EXP 136
107380: PUSH
107381: LD_EXP 136
107385: PPUSH
107386: LD_VAR 0 8
107390: PPUSH
107391: LD_INT 0
107393: PPUSH
107394: CALL_OW 1
107398: ST_TO_ADDR
// exit ;
107399: POP
107400: POP
107401: GO 107934
// end ; x := list [ i ] [ 3 ] ;
107403: LD_ADDR_VAR 0 6
107407: PUSH
107408: LD_VAR 0 3
107412: PUSH
107413: LD_VAR 0 1
107417: ARRAY
107418: PUSH
107419: LD_INT 3
107421: ARRAY
107422: ST_TO_ADDR
// y := list [ i ] [ 4 ] ;
107423: LD_ADDR_VAR 0 7
107427: PUSH
107428: LD_VAR 0 3
107432: PUSH
107433: LD_VAR 0 1
107437: ARRAY
107438: PUSH
107439: LD_INT 4
107441: ARRAY
107442: ST_TO_ADDR
// cratesNearbyPoint := GetCratesNearbyXY ( x , y , 16 ) ;
107443: LD_ADDR_VAR 0 9
107447: PUSH
107448: LD_VAR 0 6
107452: PPUSH
107453: LD_VAR 0 7
107457: PPUSH
107458: LD_INT 16
107460: PPUSH
107461: CALL 59551 0 3
107465: ST_TO_ADDR
// if not cratesNearbyPoint then
107466: LD_VAR 0 9
107470: NOT
107471: IFFALSE 107477
// exit ;
107473: POP
107474: POP
107475: GO 107934
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_hastask ] ] , [ f_dist , depot , 6 ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) union UnitFilter ( UnitsInside ( depot ) , [ [ f_not , [ f_hastask ] ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) ;
107477: LD_ADDR_VAR 0 4
107481: PUSH
107482: LD_INT 22
107484: PUSH
107485: LD_VAR 0 5
107489: PUSH
107490: EMPTY
107491: LIST
107492: LIST
107493: PUSH
107494: LD_INT 3
107496: PUSH
107497: LD_INT 60
107499: PUSH
107500: EMPTY
107501: LIST
107502: PUSH
107503: EMPTY
107504: LIST
107505: LIST
107506: PUSH
107507: LD_INT 91
107509: PUSH
107510: LD_VAR 0 8
107514: PUSH
107515: LD_INT 6
107517: PUSH
107518: EMPTY
107519: LIST
107520: LIST
107521: LIST
107522: PUSH
107523: LD_INT 2
107525: PUSH
107526: LD_INT 25
107528: PUSH
107529: LD_INT 2
107531: PUSH
107532: EMPTY
107533: LIST
107534: LIST
107535: PUSH
107536: LD_INT 25
107538: PUSH
107539: LD_INT 16
107541: PUSH
107542: EMPTY
107543: LIST
107544: LIST
107545: PUSH
107546: EMPTY
107547: LIST
107548: LIST
107549: LIST
107550: PUSH
107551: EMPTY
107552: LIST
107553: LIST
107554: LIST
107555: LIST
107556: PPUSH
107557: CALL_OW 69
107561: PUSH
107562: LD_VAR 0 8
107566: PPUSH
107567: CALL_OW 313
107571: PPUSH
107572: LD_INT 3
107574: PUSH
107575: LD_INT 60
107577: PUSH
107578: EMPTY
107579: LIST
107580: PUSH
107581: EMPTY
107582: LIST
107583: LIST
107584: PUSH
107585: LD_INT 2
107587: PUSH
107588: LD_INT 25
107590: PUSH
107591: LD_INT 2
107593: PUSH
107594: EMPTY
107595: LIST
107596: LIST
107597: PUSH
107598: LD_INT 25
107600: PUSH
107601: LD_INT 16
107603: PUSH
107604: EMPTY
107605: LIST
107606: LIST
107607: PUSH
107608: EMPTY
107609: LIST
107610: LIST
107611: LIST
107612: PUSH
107613: EMPTY
107614: LIST
107615: LIST
107616: PPUSH
107617: CALL_OW 72
107621: UNION
107622: ST_TO_ADDR
// if tmp then
107623: LD_VAR 0 4
107627: IFFALSE 107707
// begin tmp := ShrinkArray ( tmp , 3 ) ;
107629: LD_ADDR_VAR 0 4
107633: PUSH
107634: LD_VAR 0 4
107638: PPUSH
107639: LD_INT 3
107641: PPUSH
107642: CALL 57520 0 2
107646: ST_TO_ADDR
// for j in tmp do
107647: LD_ADDR_VAR 0 2
107651: PUSH
107652: LD_VAR 0 4
107656: PUSH
107657: FOR_IN
107658: IFFALSE 107701
// begin if IsInUnit ( j ) then
107660: LD_VAR 0 2
107664: PPUSH
107665: CALL_OW 310
107669: IFFALSE 107680
// ComExit ( j ) ;
107671: LD_VAR 0 2
107675: PPUSH
107676: CALL 57603 0 1
// AddComCollect ( j , x , y ) ;
107680: LD_VAR 0 2
107684: PPUSH
107685: LD_VAR 0 6
107689: PPUSH
107690: LD_VAR 0 7
107694: PPUSH
107695: CALL_OW 177
// end ;
107699: GO 107657
107701: POP
107702: POP
// exit ;
107703: POP
107704: POP
107705: GO 107934
// end ; tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_dist , depot , 8 ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ] ) ;
107707: LD_ADDR_VAR 0 4
107711: PUSH
107712: LD_INT 22
107714: PUSH
107715: LD_VAR 0 5
107719: PUSH
107720: EMPTY
107721: LIST
107722: LIST
107723: PUSH
107724: LD_INT 91
107726: PUSH
107727: LD_VAR 0 8
107731: PUSH
107732: LD_INT 8
107734: PUSH
107735: EMPTY
107736: LIST
107737: LIST
107738: LIST
107739: PUSH
107740: LD_INT 2
107742: PUSH
107743: LD_INT 34
107745: PUSH
107746: LD_INT 12
107748: PUSH
107749: EMPTY
107750: LIST
107751: LIST
107752: PUSH
107753: LD_INT 34
107755: PUSH
107756: LD_INT 51
107758: PUSH
107759: EMPTY
107760: LIST
107761: LIST
107762: PUSH
107763: LD_INT 34
107765: PUSH
107766: LD_INT 32
107768: PUSH
107769: EMPTY
107770: LIST
107771: LIST
107772: PUSH
107773: LD_INT 34
107775: PUSH
107776: LD_INT 89
107778: PUSH
107779: EMPTY
107780: LIST
107781: LIST
107782: PUSH
107783: EMPTY
107784: LIST
107785: LIST
107786: LIST
107787: LIST
107788: LIST
107789: PUSH
107790: EMPTY
107791: LIST
107792: LIST
107793: LIST
107794: PPUSH
107795: CALL_OW 69
107799: ST_TO_ADDR
// if tmp then
107800: LD_VAR 0 4
107804: IFFALSE 107930
// begin for j in tmp do
107806: LD_ADDR_VAR 0 2
107810: PUSH
107811: LD_VAR 0 4
107815: PUSH
107816: FOR_IN
107817: IFFALSE 107928
// if ( GetEngine ( j ) = engine_siberite or GetFuel ( j ) > 20 ) and not HasTask ( j ) and ( GetControl ( j ) <> control_manual or IsDrivenBy ( j ) ) then
107819: LD_VAR 0 2
107823: PPUSH
107824: CALL_OW 262
107828: PUSH
107829: LD_INT 3
107831: EQUAL
107832: PUSH
107833: LD_VAR 0 2
107837: PPUSH
107838: CALL_OW 261
107842: PUSH
107843: LD_INT 20
107845: GREATER
107846: OR
107847: PUSH
107848: LD_VAR 0 2
107852: PPUSH
107853: CALL_OW 314
107857: NOT
107858: AND
107859: PUSH
107860: LD_VAR 0 2
107864: PPUSH
107865: CALL_OW 263
107869: PUSH
107870: LD_INT 1
107872: NONEQUAL
107873: PUSH
107874: LD_VAR 0 2
107878: PPUSH
107879: CALL_OW 311
107883: OR
107884: AND
107885: IFFALSE 107926
// begin ComCollect ( j , x , y ) ;
107887: LD_VAR 0 2
107891: PPUSH
107892: LD_VAR 0 6
107896: PPUSH
107897: LD_VAR 0 7
107901: PPUSH
107902: CALL_OW 117
// AddComMoveUnit ( j , depot ) ;
107906: LD_VAR 0 2
107910: PPUSH
107911: LD_VAR 0 8
107915: PPUSH
107916: CALL_OW 172
// exit ;
107920: POP
107921: POP
107922: POP
107923: POP
107924: GO 107934
// end ;
107926: GO 107816
107928: POP
107929: POP
// end ; end ;
107930: GO 107305
107932: POP
107933: POP
// end ; end_of_file
107934: PPOPN 9
107936: END
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
107937: LD_INT 0
107939: PPUSH
107940: PPUSH
107941: PPUSH
107942: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
107943: LD_VAR 0 1
107947: PPUSH
107948: CALL_OW 264
107952: PUSH
107953: LD_INT 91
107955: EQUAL
107956: IFFALSE 108028
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
107958: LD_INT 68
107960: PPUSH
107961: LD_VAR 0 1
107965: PPUSH
107966: CALL_OW 255
107970: PPUSH
107971: CALL_OW 321
107975: PUSH
107976: LD_INT 2
107978: EQUAL
107979: IFFALSE 107991
// eff := 70 else
107981: LD_ADDR_VAR 0 4
107985: PUSH
107986: LD_INT 70
107988: ST_TO_ADDR
107989: GO 107999
// eff := 30 ;
107991: LD_ADDR_VAR 0 4
107995: PUSH
107996: LD_INT 30
107998: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
107999: LD_VAR 0 1
108003: PPUSH
108004: CALL_OW 250
108008: PPUSH
108009: LD_VAR 0 1
108013: PPUSH
108014: CALL_OW 251
108018: PPUSH
108019: LD_VAR 0 4
108023: PPUSH
108024: CALL_OW 495
// end ; end ;
108028: LD_VAR 0 2
108032: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
108033: LD_INT 0
108035: PPUSH
// end ;
108036: LD_VAR 0 4
108040: RET
// export function SOS_Command ( cmd ) ; begin
108041: LD_INT 0
108043: PPUSH
// end ;
108044: LD_VAR 0 2
108048: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
108049: LD_INT 0
108051: PPUSH
// end ;
108052: LD_VAR 0 6
108056: RET
// export function SOS_VehicleConstructed ( vehicle , factory ) ; var driver ; begin
108057: LD_INT 0
108059: PPUSH
108060: PPUSH
// if not vehicle or not factory then
108061: LD_VAR 0 1
108065: NOT
108066: PUSH
108067: LD_VAR 0 2
108071: NOT
108072: OR
108073: IFFALSE 108077
// exit ;
108075: GO 108308
// if factoryWaypoints >= factory then
108077: LD_EXP 135
108081: PUSH
108082: LD_VAR 0 2
108086: GREATEREQUAL
108087: IFFALSE 108308
// if factoryWaypoints [ factory ] then
108089: LD_EXP 135
108093: PUSH
108094: LD_VAR 0 2
108098: ARRAY
108099: IFFALSE 108308
// begin if GetControl ( vehicle ) = control_manual then
108101: LD_VAR 0 1
108105: PPUSH
108106: CALL_OW 263
108110: PUSH
108111: LD_INT 1
108113: EQUAL
108114: IFFALSE 108195
// begin driver := IsDrivenBy ( vehicle ) ;
108116: LD_ADDR_VAR 0 4
108120: PUSH
108121: LD_VAR 0 1
108125: PPUSH
108126: CALL_OW 311
108130: ST_TO_ADDR
// AddComMoveXY ( driver , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
108131: LD_VAR 0 4
108135: PPUSH
108136: LD_EXP 135
108140: PUSH
108141: LD_VAR 0 2
108145: ARRAY
108146: PUSH
108147: LD_INT 3
108149: ARRAY
108150: PPUSH
108151: LD_EXP 135
108155: PUSH
108156: LD_VAR 0 2
108160: ARRAY
108161: PUSH
108162: LD_INT 4
108164: ARRAY
108165: PPUSH
108166: CALL_OW 171
// AddComExitVehicle ( driver ) ;
108170: LD_VAR 0 4
108174: PPUSH
108175: CALL_OW 181
// AddComEnterUnit ( driver , factory ) ;
108179: LD_VAR 0 4
108183: PPUSH
108184: LD_VAR 0 2
108188: PPUSH
108189: CALL_OW 180
// end else
108193: GO 108308
// if GetControl ( vehicle ) = control_remote then
108195: LD_VAR 0 1
108199: PPUSH
108200: CALL_OW 263
108204: PUSH
108205: LD_INT 2
108207: EQUAL
108208: IFFALSE 108269
// begin wait ( 0 0$2 ) ;
108210: LD_INT 70
108212: PPUSH
108213: CALL_OW 67
// if Connect ( vehicle ) then
108217: LD_VAR 0 1
108221: PPUSH
108222: CALL 27824 0 1
108226: IFFALSE 108267
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
108228: LD_VAR 0 1
108232: PPUSH
108233: LD_EXP 135
108237: PUSH
108238: LD_VAR 0 2
108242: ARRAY
108243: PUSH
108244: LD_INT 3
108246: ARRAY
108247: PPUSH
108248: LD_EXP 135
108252: PUSH
108253: LD_VAR 0 2
108257: ARRAY
108258: PUSH
108259: LD_INT 4
108261: ARRAY
108262: PPUSH
108263: CALL_OW 171
// end else
108267: GO 108308
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
108269: LD_VAR 0 1
108273: PPUSH
108274: LD_EXP 135
108278: PUSH
108279: LD_VAR 0 2
108283: ARRAY
108284: PUSH
108285: LD_INT 3
108287: ARRAY
108288: PPUSH
108289: LD_EXP 135
108293: PUSH
108294: LD_VAR 0 2
108298: ARRAY
108299: PUSH
108300: LD_INT 4
108302: ARRAY
108303: PPUSH
108304: CALL_OW 171
// end ; end ;
108308: LD_VAR 0 3
108312: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
108313: LD_INT 0
108315: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
108316: LD_VAR 0 1
108320: PUSH
108321: LD_INT 250
108323: EQUAL
108324: PUSH
108325: LD_VAR 0 2
108329: PPUSH
108330: CALL_OW 264
108334: PUSH
108335: LD_INT 81
108337: EQUAL
108338: AND
108339: IFFALSE 108360
// MinerPlaceMine ( unit , x , y ) ;
108341: LD_VAR 0 2
108345: PPUSH
108346: LD_VAR 0 4
108350: PPUSH
108351: LD_VAR 0 5
108355: PPUSH
108356: CALL 110745 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
108360: LD_VAR 0 1
108364: PUSH
108365: LD_INT 251
108367: EQUAL
108368: PUSH
108369: LD_VAR 0 2
108373: PPUSH
108374: CALL_OW 264
108378: PUSH
108379: LD_INT 81
108381: EQUAL
108382: AND
108383: IFFALSE 108404
// MinerDetonateMine ( unit , x , y ) ;
108385: LD_VAR 0 2
108389: PPUSH
108390: LD_VAR 0 4
108394: PPUSH
108395: LD_VAR 0 5
108399: PPUSH
108400: CALL 111020 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
108404: LD_VAR 0 1
108408: PUSH
108409: LD_INT 252
108411: EQUAL
108412: PUSH
108413: LD_VAR 0 2
108417: PPUSH
108418: CALL_OW 264
108422: PUSH
108423: LD_INT 81
108425: EQUAL
108426: AND
108427: IFFALSE 108448
// MinerCreateMinefield ( unit , x , y ) ;
108429: LD_VAR 0 2
108433: PPUSH
108434: LD_VAR 0 4
108438: PPUSH
108439: LD_VAR 0 5
108443: PPUSH
108444: CALL 111437 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
108448: LD_VAR 0 1
108452: PUSH
108453: LD_INT 253
108455: EQUAL
108456: PUSH
108457: LD_VAR 0 2
108461: PPUSH
108462: CALL_OW 257
108466: PUSH
108467: LD_INT 5
108469: EQUAL
108470: AND
108471: IFFALSE 108492
// ComBinocular ( unit , x , y ) ;
108473: LD_VAR 0 2
108477: PPUSH
108478: LD_VAR 0 4
108482: PPUSH
108483: LD_VAR 0 5
108487: PPUSH
108488: CALL 111806 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
108492: LD_VAR 0 1
108496: PUSH
108497: LD_INT 254
108499: EQUAL
108500: PUSH
108501: LD_VAR 0 2
108505: PPUSH
108506: CALL_OW 264
108510: PUSH
108511: LD_INT 99
108513: EQUAL
108514: AND
108515: PUSH
108516: LD_VAR 0 3
108520: PPUSH
108521: CALL_OW 263
108525: PUSH
108526: LD_INT 3
108528: EQUAL
108529: AND
108530: IFFALSE 108546
// HackDestroyVehicle ( unit , selectedUnit ) ;
108532: LD_VAR 0 2
108536: PPUSH
108537: LD_VAR 0 3
108541: PPUSH
108542: CALL 110109 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
108546: LD_VAR 0 1
108550: PUSH
108551: LD_INT 255
108553: EQUAL
108554: PUSH
108555: LD_VAR 0 2
108559: PPUSH
108560: CALL_OW 264
108564: PUSH
108565: LD_INT 14
108567: PUSH
108568: LD_INT 53
108570: PUSH
108571: EMPTY
108572: LIST
108573: LIST
108574: IN
108575: AND
108576: PUSH
108577: LD_VAR 0 4
108581: PPUSH
108582: LD_VAR 0 5
108586: PPUSH
108587: CALL_OW 488
108591: AND
108592: IFFALSE 108616
// CutTreeXYR ( unit , x , y , 12 ) ;
108594: LD_VAR 0 2
108598: PPUSH
108599: LD_VAR 0 4
108603: PPUSH
108604: LD_VAR 0 5
108608: PPUSH
108609: LD_INT 12
108611: PPUSH
108612: CALL 108679 0 4
// if cmd = 256 then
108616: LD_VAR 0 1
108620: PUSH
108621: LD_INT 256
108623: EQUAL
108624: IFFALSE 108645
// SetFactoryWaypoint ( unit , x , y ) ;
108626: LD_VAR 0 2
108630: PPUSH
108631: LD_VAR 0 4
108635: PPUSH
108636: LD_VAR 0 5
108640: PPUSH
108641: CALL 106626 0 3
// if cmd = 257 then
108645: LD_VAR 0 1
108649: PUSH
108650: LD_INT 257
108652: EQUAL
108653: IFFALSE 108674
// SetWarehouseGatheringPoint ( unit , x , y ) ;
108655: LD_VAR 0 2
108659: PPUSH
108660: LD_VAR 0 4
108664: PPUSH
108665: LD_VAR 0 5
108669: PPUSH
108670: CALL 106988 0 3
// end ;
108674: LD_VAR 0 6
108678: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
108679: LD_INT 0
108681: PPUSH
108682: PPUSH
108683: PPUSH
108684: PPUSH
108685: PPUSH
108686: PPUSH
108687: PPUSH
108688: PPUSH
108689: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
108690: LD_VAR 0 1
108694: NOT
108695: PUSH
108696: LD_VAR 0 2
108700: PPUSH
108701: LD_VAR 0 3
108705: PPUSH
108706: CALL_OW 488
108710: NOT
108711: OR
108712: PUSH
108713: LD_VAR 0 4
108717: NOT
108718: OR
108719: IFFALSE 108723
// exit ;
108721: GO 109063
// list := [ ] ;
108723: LD_ADDR_VAR 0 13
108727: PUSH
108728: EMPTY
108729: ST_TO_ADDR
// if x - r < 0 then
108730: LD_VAR 0 2
108734: PUSH
108735: LD_VAR 0 4
108739: MINUS
108740: PUSH
108741: LD_INT 0
108743: LESS
108744: IFFALSE 108756
// min_x := 0 else
108746: LD_ADDR_VAR 0 7
108750: PUSH
108751: LD_INT 0
108753: ST_TO_ADDR
108754: GO 108772
// min_x := x - r ;
108756: LD_ADDR_VAR 0 7
108760: PUSH
108761: LD_VAR 0 2
108765: PUSH
108766: LD_VAR 0 4
108770: MINUS
108771: ST_TO_ADDR
// if y - r < 0 then
108772: LD_VAR 0 3
108776: PUSH
108777: LD_VAR 0 4
108781: MINUS
108782: PUSH
108783: LD_INT 0
108785: LESS
108786: IFFALSE 108798
// min_y := 0 else
108788: LD_ADDR_VAR 0 8
108792: PUSH
108793: LD_INT 0
108795: ST_TO_ADDR
108796: GO 108814
// min_y := y - r ;
108798: LD_ADDR_VAR 0 8
108802: PUSH
108803: LD_VAR 0 3
108807: PUSH
108808: LD_VAR 0 4
108812: MINUS
108813: ST_TO_ADDR
// max_x := x + r ;
108814: LD_ADDR_VAR 0 9
108818: PUSH
108819: LD_VAR 0 2
108823: PUSH
108824: LD_VAR 0 4
108828: PLUS
108829: ST_TO_ADDR
// max_y := y + r ;
108830: LD_ADDR_VAR 0 10
108834: PUSH
108835: LD_VAR 0 3
108839: PUSH
108840: LD_VAR 0 4
108844: PLUS
108845: ST_TO_ADDR
// for _x = min_x to max_x do
108846: LD_ADDR_VAR 0 11
108850: PUSH
108851: DOUBLE
108852: LD_VAR 0 7
108856: DEC
108857: ST_TO_ADDR
108858: LD_VAR 0 9
108862: PUSH
108863: FOR_TO
108864: IFFALSE 108981
// for _y = min_y to max_y do
108866: LD_ADDR_VAR 0 12
108870: PUSH
108871: DOUBLE
108872: LD_VAR 0 8
108876: DEC
108877: ST_TO_ADDR
108878: LD_VAR 0 10
108882: PUSH
108883: FOR_TO
108884: IFFALSE 108977
// begin if not ValidHex ( _x , _y ) then
108886: LD_VAR 0 11
108890: PPUSH
108891: LD_VAR 0 12
108895: PPUSH
108896: CALL_OW 488
108900: NOT
108901: IFFALSE 108905
// continue ;
108903: GO 108883
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
108905: LD_VAR 0 11
108909: PPUSH
108910: LD_VAR 0 12
108914: PPUSH
108915: CALL_OW 351
108919: PUSH
108920: LD_VAR 0 11
108924: PPUSH
108925: LD_VAR 0 12
108929: PPUSH
108930: CALL_OW 554
108934: AND
108935: IFFALSE 108975
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
108937: LD_ADDR_VAR 0 13
108941: PUSH
108942: LD_VAR 0 13
108946: PPUSH
108947: LD_VAR 0 13
108951: PUSH
108952: LD_INT 1
108954: PLUS
108955: PPUSH
108956: LD_VAR 0 11
108960: PUSH
108961: LD_VAR 0 12
108965: PUSH
108966: EMPTY
108967: LIST
108968: LIST
108969: PPUSH
108970: CALL_OW 2
108974: ST_TO_ADDR
// end ;
108975: GO 108883
108977: POP
108978: POP
108979: GO 108863
108981: POP
108982: POP
// if not list then
108983: LD_VAR 0 13
108987: NOT
108988: IFFALSE 108992
// exit ;
108990: GO 109063
// for i in list do
108992: LD_ADDR_VAR 0 6
108996: PUSH
108997: LD_VAR 0 13
109001: PUSH
109002: FOR_IN
109003: IFFALSE 109061
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
109005: LD_VAR 0 1
109009: PPUSH
109010: LD_STRING M
109012: PUSH
109013: LD_VAR 0 6
109017: PUSH
109018: LD_INT 1
109020: ARRAY
109021: PUSH
109022: LD_VAR 0 6
109026: PUSH
109027: LD_INT 2
109029: ARRAY
109030: PUSH
109031: LD_INT 0
109033: PUSH
109034: LD_INT 0
109036: PUSH
109037: LD_INT 0
109039: PUSH
109040: LD_INT 0
109042: PUSH
109043: EMPTY
109044: LIST
109045: LIST
109046: LIST
109047: LIST
109048: LIST
109049: LIST
109050: LIST
109051: PUSH
109052: EMPTY
109053: LIST
109054: PPUSH
109055: CALL_OW 447
109059: GO 109002
109061: POP
109062: POP
// end ;
109063: LD_VAR 0 5
109067: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
109068: LD_EXP 138
109072: NOT
109073: IFFALSE 109123
109075: GO 109077
109077: DISABLE
// begin initHack := true ;
109078: LD_ADDR_EXP 138
109082: PUSH
109083: LD_INT 1
109085: ST_TO_ADDR
// hackTanks := [ ] ;
109086: LD_ADDR_EXP 139
109090: PUSH
109091: EMPTY
109092: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
109093: LD_ADDR_EXP 140
109097: PUSH
109098: EMPTY
109099: ST_TO_ADDR
// hackLimit := 3 ;
109100: LD_ADDR_EXP 141
109104: PUSH
109105: LD_INT 3
109107: ST_TO_ADDR
// hackDist := 12 ;
109108: LD_ADDR_EXP 142
109112: PUSH
109113: LD_INT 12
109115: ST_TO_ADDR
// hackCounter := [ ] ;
109116: LD_ADDR_EXP 143
109120: PUSH
109121: EMPTY
109122: ST_TO_ADDR
// end ;
109123: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
109124: LD_EXP 138
109128: PUSH
109129: LD_INT 34
109131: PUSH
109132: LD_INT 99
109134: PUSH
109135: EMPTY
109136: LIST
109137: LIST
109138: PPUSH
109139: CALL_OW 69
109143: AND
109144: IFFALSE 109397
109146: GO 109148
109148: DISABLE
109149: LD_INT 0
109151: PPUSH
109152: PPUSH
// begin enable ;
109153: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
109154: LD_ADDR_VAR 0 1
109158: PUSH
109159: LD_INT 34
109161: PUSH
109162: LD_INT 99
109164: PUSH
109165: EMPTY
109166: LIST
109167: LIST
109168: PPUSH
109169: CALL_OW 69
109173: PUSH
109174: FOR_IN
109175: IFFALSE 109395
// begin if not i in hackTanks then
109177: LD_VAR 0 1
109181: PUSH
109182: LD_EXP 139
109186: IN
109187: NOT
109188: IFFALSE 109271
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
109190: LD_ADDR_EXP 139
109194: PUSH
109195: LD_EXP 139
109199: PPUSH
109200: LD_EXP 139
109204: PUSH
109205: LD_INT 1
109207: PLUS
109208: PPUSH
109209: LD_VAR 0 1
109213: PPUSH
109214: CALL_OW 1
109218: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
109219: LD_ADDR_EXP 140
109223: PUSH
109224: LD_EXP 140
109228: PPUSH
109229: LD_EXP 140
109233: PUSH
109234: LD_INT 1
109236: PLUS
109237: PPUSH
109238: EMPTY
109239: PPUSH
109240: CALL_OW 1
109244: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
109245: LD_ADDR_EXP 143
109249: PUSH
109250: LD_EXP 143
109254: PPUSH
109255: LD_EXP 143
109259: PUSH
109260: LD_INT 1
109262: PLUS
109263: PPUSH
109264: EMPTY
109265: PPUSH
109266: CALL_OW 1
109270: ST_TO_ADDR
// end ; if not IsOk ( i ) then
109271: LD_VAR 0 1
109275: PPUSH
109276: CALL_OW 302
109280: NOT
109281: IFFALSE 109294
// begin HackUnlinkAll ( i ) ;
109283: LD_VAR 0 1
109287: PPUSH
109288: CALL 109400 0 1
// continue ;
109292: GO 109174
// end ; HackCheckCapturedStatus ( i ) ;
109294: LD_VAR 0 1
109298: PPUSH
109299: CALL 109843 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
109303: LD_ADDR_VAR 0 2
109307: PUSH
109308: LD_INT 81
109310: PUSH
109311: LD_VAR 0 1
109315: PPUSH
109316: CALL_OW 255
109320: PUSH
109321: EMPTY
109322: LIST
109323: LIST
109324: PUSH
109325: LD_INT 33
109327: PUSH
109328: LD_INT 3
109330: PUSH
109331: EMPTY
109332: LIST
109333: LIST
109334: PUSH
109335: LD_INT 91
109337: PUSH
109338: LD_VAR 0 1
109342: PUSH
109343: LD_EXP 142
109347: PUSH
109348: EMPTY
109349: LIST
109350: LIST
109351: LIST
109352: PUSH
109353: LD_INT 50
109355: PUSH
109356: EMPTY
109357: LIST
109358: PUSH
109359: EMPTY
109360: LIST
109361: LIST
109362: LIST
109363: LIST
109364: PPUSH
109365: CALL_OW 69
109369: ST_TO_ADDR
// if not tmp then
109370: LD_VAR 0 2
109374: NOT
109375: IFFALSE 109379
// continue ;
109377: GO 109174
// HackLink ( i , tmp ) ;
109379: LD_VAR 0 1
109383: PPUSH
109384: LD_VAR 0 2
109388: PPUSH
109389: CALL 109536 0 2
// end ;
109393: GO 109174
109395: POP
109396: POP
// end ;
109397: PPOPN 2
109399: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
109400: LD_INT 0
109402: PPUSH
109403: PPUSH
109404: PPUSH
// if not hack in hackTanks then
109405: LD_VAR 0 1
109409: PUSH
109410: LD_EXP 139
109414: IN
109415: NOT
109416: IFFALSE 109420
// exit ;
109418: GO 109531
// index := GetElementIndex ( hackTanks , hack ) ;
109420: LD_ADDR_VAR 0 4
109424: PUSH
109425: LD_EXP 139
109429: PPUSH
109430: LD_VAR 0 1
109434: PPUSH
109435: CALL 24631 0 2
109439: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
109440: LD_EXP 140
109444: PUSH
109445: LD_VAR 0 4
109449: ARRAY
109450: IFFALSE 109531
// begin for i in hackTanksCaptured [ index ] do
109452: LD_ADDR_VAR 0 3
109456: PUSH
109457: LD_EXP 140
109461: PUSH
109462: LD_VAR 0 4
109466: ARRAY
109467: PUSH
109468: FOR_IN
109469: IFFALSE 109495
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
109471: LD_VAR 0 3
109475: PUSH
109476: LD_INT 1
109478: ARRAY
109479: PPUSH
109480: LD_VAR 0 3
109484: PUSH
109485: LD_INT 2
109487: ARRAY
109488: PPUSH
109489: CALL_OW 235
109493: GO 109468
109495: POP
109496: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
109497: LD_ADDR_EXP 140
109501: PUSH
109502: LD_EXP 140
109506: PPUSH
109507: LD_VAR 0 4
109511: PPUSH
109512: EMPTY
109513: PPUSH
109514: CALL_OW 1
109518: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
109519: LD_VAR 0 1
109523: PPUSH
109524: LD_INT 0
109526: PPUSH
109527: CALL_OW 505
// end ; end ;
109531: LD_VAR 0 2
109535: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
109536: LD_INT 0
109538: PPUSH
109539: PPUSH
109540: PPUSH
// if not hack in hackTanks or not vehicles then
109541: LD_VAR 0 1
109545: PUSH
109546: LD_EXP 139
109550: IN
109551: NOT
109552: PUSH
109553: LD_VAR 0 2
109557: NOT
109558: OR
109559: IFFALSE 109563
// exit ;
109561: GO 109838
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
109563: LD_ADDR_VAR 0 2
109567: PUSH
109568: LD_VAR 0 1
109572: PPUSH
109573: LD_VAR 0 2
109577: PPUSH
109578: LD_INT 1
109580: PPUSH
109581: LD_INT 1
109583: PPUSH
109584: CALL 25281 0 4
109588: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
109589: LD_ADDR_VAR 0 5
109593: PUSH
109594: LD_EXP 139
109598: PPUSH
109599: LD_VAR 0 1
109603: PPUSH
109604: CALL 24631 0 2
109608: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
109609: LD_EXP 140
109613: PUSH
109614: LD_VAR 0 5
109618: ARRAY
109619: PUSH
109620: LD_EXP 141
109624: LESS
109625: IFFALSE 109814
// begin for i := 1 to vehicles do
109627: LD_ADDR_VAR 0 4
109631: PUSH
109632: DOUBLE
109633: LD_INT 1
109635: DEC
109636: ST_TO_ADDR
109637: LD_VAR 0 2
109641: PUSH
109642: FOR_TO
109643: IFFALSE 109812
// begin if hackTanksCaptured [ index ] = hackLimit then
109645: LD_EXP 140
109649: PUSH
109650: LD_VAR 0 5
109654: ARRAY
109655: PUSH
109656: LD_EXP 141
109660: EQUAL
109661: IFFALSE 109665
// break ;
109663: GO 109812
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
109665: LD_ADDR_EXP 143
109669: PUSH
109670: LD_EXP 143
109674: PPUSH
109675: LD_VAR 0 5
109679: PPUSH
109680: LD_EXP 143
109684: PUSH
109685: LD_VAR 0 5
109689: ARRAY
109690: PUSH
109691: LD_INT 1
109693: PLUS
109694: PPUSH
109695: CALL_OW 1
109699: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
109700: LD_ADDR_EXP 140
109704: PUSH
109705: LD_EXP 140
109709: PPUSH
109710: LD_VAR 0 5
109714: PUSH
109715: LD_EXP 140
109719: PUSH
109720: LD_VAR 0 5
109724: ARRAY
109725: PUSH
109726: LD_INT 1
109728: PLUS
109729: PUSH
109730: EMPTY
109731: LIST
109732: LIST
109733: PPUSH
109734: LD_VAR 0 2
109738: PUSH
109739: LD_VAR 0 4
109743: ARRAY
109744: PUSH
109745: LD_VAR 0 2
109749: PUSH
109750: LD_VAR 0 4
109754: ARRAY
109755: PPUSH
109756: CALL_OW 255
109760: PUSH
109761: EMPTY
109762: LIST
109763: LIST
109764: PPUSH
109765: CALL 24846 0 3
109769: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
109770: LD_VAR 0 2
109774: PUSH
109775: LD_VAR 0 4
109779: ARRAY
109780: PPUSH
109781: LD_VAR 0 1
109785: PPUSH
109786: CALL_OW 255
109790: PPUSH
109791: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
109795: LD_VAR 0 2
109799: PUSH
109800: LD_VAR 0 4
109804: ARRAY
109805: PPUSH
109806: CALL_OW 141
// end ;
109810: GO 109642
109812: POP
109813: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
109814: LD_VAR 0 1
109818: PPUSH
109819: LD_EXP 140
109823: PUSH
109824: LD_VAR 0 5
109828: ARRAY
109829: PUSH
109830: LD_INT 0
109832: PLUS
109833: PPUSH
109834: CALL_OW 505
// end ;
109838: LD_VAR 0 3
109842: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
109843: LD_INT 0
109845: PPUSH
109846: PPUSH
109847: PPUSH
109848: PPUSH
// if not hack in hackTanks then
109849: LD_VAR 0 1
109853: PUSH
109854: LD_EXP 139
109858: IN
109859: NOT
109860: IFFALSE 109864
// exit ;
109862: GO 110104
// index := GetElementIndex ( hackTanks , hack ) ;
109864: LD_ADDR_VAR 0 4
109868: PUSH
109869: LD_EXP 139
109873: PPUSH
109874: LD_VAR 0 1
109878: PPUSH
109879: CALL 24631 0 2
109883: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
109884: LD_ADDR_VAR 0 3
109888: PUSH
109889: DOUBLE
109890: LD_EXP 140
109894: PUSH
109895: LD_VAR 0 4
109899: ARRAY
109900: INC
109901: ST_TO_ADDR
109902: LD_INT 1
109904: PUSH
109905: FOR_DOWNTO
109906: IFFALSE 110078
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
109908: LD_ADDR_VAR 0 5
109912: PUSH
109913: LD_EXP 140
109917: PUSH
109918: LD_VAR 0 4
109922: ARRAY
109923: PUSH
109924: LD_VAR 0 3
109928: ARRAY
109929: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
109930: LD_VAR 0 5
109934: PUSH
109935: LD_INT 1
109937: ARRAY
109938: PPUSH
109939: CALL_OW 302
109943: NOT
109944: PUSH
109945: LD_VAR 0 5
109949: PUSH
109950: LD_INT 1
109952: ARRAY
109953: PPUSH
109954: CALL_OW 255
109958: PUSH
109959: LD_VAR 0 1
109963: PPUSH
109964: CALL_OW 255
109968: NONEQUAL
109969: OR
109970: IFFALSE 110076
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
109972: LD_VAR 0 5
109976: PUSH
109977: LD_INT 1
109979: ARRAY
109980: PPUSH
109981: CALL_OW 305
109985: PUSH
109986: LD_VAR 0 5
109990: PUSH
109991: LD_INT 1
109993: ARRAY
109994: PPUSH
109995: CALL_OW 255
109999: PUSH
110000: LD_VAR 0 1
110004: PPUSH
110005: CALL_OW 255
110009: EQUAL
110010: AND
110011: IFFALSE 110035
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
110013: LD_VAR 0 5
110017: PUSH
110018: LD_INT 1
110020: ARRAY
110021: PPUSH
110022: LD_VAR 0 5
110026: PUSH
110027: LD_INT 2
110029: ARRAY
110030: PPUSH
110031: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
110035: LD_ADDR_EXP 140
110039: PUSH
110040: LD_EXP 140
110044: PPUSH
110045: LD_VAR 0 4
110049: PPUSH
110050: LD_EXP 140
110054: PUSH
110055: LD_VAR 0 4
110059: ARRAY
110060: PPUSH
110061: LD_VAR 0 3
110065: PPUSH
110066: CALL_OW 3
110070: PPUSH
110071: CALL_OW 1
110075: ST_TO_ADDR
// end ; end ;
110076: GO 109905
110078: POP
110079: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
110080: LD_VAR 0 1
110084: PPUSH
110085: LD_EXP 140
110089: PUSH
110090: LD_VAR 0 4
110094: ARRAY
110095: PUSH
110096: LD_INT 0
110098: PLUS
110099: PPUSH
110100: CALL_OW 505
// end ;
110104: LD_VAR 0 2
110108: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
110109: LD_INT 0
110111: PPUSH
110112: PPUSH
110113: PPUSH
110114: PPUSH
// if not hack in hackTanks then
110115: LD_VAR 0 1
110119: PUSH
110120: LD_EXP 139
110124: IN
110125: NOT
110126: IFFALSE 110130
// exit ;
110128: GO 110215
// index := GetElementIndex ( hackTanks , hack ) ;
110130: LD_ADDR_VAR 0 5
110134: PUSH
110135: LD_EXP 139
110139: PPUSH
110140: LD_VAR 0 1
110144: PPUSH
110145: CALL 24631 0 2
110149: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
110150: LD_ADDR_VAR 0 4
110154: PUSH
110155: DOUBLE
110156: LD_INT 1
110158: DEC
110159: ST_TO_ADDR
110160: LD_EXP 140
110164: PUSH
110165: LD_VAR 0 5
110169: ARRAY
110170: PUSH
110171: FOR_TO
110172: IFFALSE 110213
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
110174: LD_EXP 140
110178: PUSH
110179: LD_VAR 0 5
110183: ARRAY
110184: PUSH
110185: LD_VAR 0 4
110189: ARRAY
110190: PUSH
110191: LD_INT 1
110193: ARRAY
110194: PUSH
110195: LD_VAR 0 2
110199: EQUAL
110200: IFFALSE 110211
// KillUnit ( vehicle ) ;
110202: LD_VAR 0 2
110206: PPUSH
110207: CALL_OW 66
110211: GO 110171
110213: POP
110214: POP
// end ;
110215: LD_VAR 0 3
110219: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
110220: LD_EXP 144
110224: NOT
110225: IFFALSE 110260
110227: GO 110229
110229: DISABLE
// begin initMiner := true ;
110230: LD_ADDR_EXP 144
110234: PUSH
110235: LD_INT 1
110237: ST_TO_ADDR
// minersList := [ ] ;
110238: LD_ADDR_EXP 145
110242: PUSH
110243: EMPTY
110244: ST_TO_ADDR
// minerMinesList := [ ] ;
110245: LD_ADDR_EXP 146
110249: PUSH
110250: EMPTY
110251: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
110252: LD_ADDR_EXP 147
110256: PUSH
110257: LD_INT 5
110259: ST_TO_ADDR
// end ;
110260: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
110261: LD_EXP 144
110265: PUSH
110266: LD_INT 34
110268: PUSH
110269: LD_INT 81
110271: PUSH
110272: EMPTY
110273: LIST
110274: LIST
110275: PPUSH
110276: CALL_OW 69
110280: AND
110281: IFFALSE 110742
110283: GO 110285
110285: DISABLE
110286: LD_INT 0
110288: PPUSH
110289: PPUSH
110290: PPUSH
110291: PPUSH
// begin enable ;
110292: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
110293: LD_ADDR_VAR 0 1
110297: PUSH
110298: LD_INT 34
110300: PUSH
110301: LD_INT 81
110303: PUSH
110304: EMPTY
110305: LIST
110306: LIST
110307: PPUSH
110308: CALL_OW 69
110312: PUSH
110313: FOR_IN
110314: IFFALSE 110386
// begin if not i in minersList then
110316: LD_VAR 0 1
110320: PUSH
110321: LD_EXP 145
110325: IN
110326: NOT
110327: IFFALSE 110384
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
110329: LD_ADDR_EXP 145
110333: PUSH
110334: LD_EXP 145
110338: PPUSH
110339: LD_EXP 145
110343: PUSH
110344: LD_INT 1
110346: PLUS
110347: PPUSH
110348: LD_VAR 0 1
110352: PPUSH
110353: CALL_OW 1
110357: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
110358: LD_ADDR_EXP 146
110362: PUSH
110363: LD_EXP 146
110367: PPUSH
110368: LD_EXP 146
110372: PUSH
110373: LD_INT 1
110375: PLUS
110376: PPUSH
110377: EMPTY
110378: PPUSH
110379: CALL_OW 1
110383: ST_TO_ADDR
// end end ;
110384: GO 110313
110386: POP
110387: POP
// for i := minerMinesList downto 1 do
110388: LD_ADDR_VAR 0 1
110392: PUSH
110393: DOUBLE
110394: LD_EXP 146
110398: INC
110399: ST_TO_ADDR
110400: LD_INT 1
110402: PUSH
110403: FOR_DOWNTO
110404: IFFALSE 110740
// begin if IsLive ( minersList [ i ] ) then
110406: LD_EXP 145
110410: PUSH
110411: LD_VAR 0 1
110415: ARRAY
110416: PPUSH
110417: CALL_OW 300
110421: IFFALSE 110449
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
110423: LD_EXP 145
110427: PUSH
110428: LD_VAR 0 1
110432: ARRAY
110433: PPUSH
110434: LD_EXP 146
110438: PUSH
110439: LD_VAR 0 1
110443: ARRAY
110444: PPUSH
110445: CALL_OW 505
// if not minerMinesList [ i ] then
110449: LD_EXP 146
110453: PUSH
110454: LD_VAR 0 1
110458: ARRAY
110459: NOT
110460: IFFALSE 110464
// continue ;
110462: GO 110403
// for j := minerMinesList [ i ] downto 1 do
110464: LD_ADDR_VAR 0 2
110468: PUSH
110469: DOUBLE
110470: LD_EXP 146
110474: PUSH
110475: LD_VAR 0 1
110479: ARRAY
110480: INC
110481: ST_TO_ADDR
110482: LD_INT 1
110484: PUSH
110485: FOR_DOWNTO
110486: IFFALSE 110736
// begin side := GetSide ( minersList [ i ] ) ;
110488: LD_ADDR_VAR 0 3
110492: PUSH
110493: LD_EXP 145
110497: PUSH
110498: LD_VAR 0 1
110502: ARRAY
110503: PPUSH
110504: CALL_OW 255
110508: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
110509: LD_ADDR_VAR 0 4
110513: PUSH
110514: LD_EXP 146
110518: PUSH
110519: LD_VAR 0 1
110523: ARRAY
110524: PUSH
110525: LD_VAR 0 2
110529: ARRAY
110530: PUSH
110531: LD_INT 1
110533: ARRAY
110534: PPUSH
110535: LD_EXP 146
110539: PUSH
110540: LD_VAR 0 1
110544: ARRAY
110545: PUSH
110546: LD_VAR 0 2
110550: ARRAY
110551: PUSH
110552: LD_INT 2
110554: ARRAY
110555: PPUSH
110556: CALL_OW 428
110560: ST_TO_ADDR
// if not tmp then
110561: LD_VAR 0 4
110565: NOT
110566: IFFALSE 110570
// continue ;
110568: GO 110485
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
110570: LD_VAR 0 4
110574: PUSH
110575: LD_INT 81
110577: PUSH
110578: LD_VAR 0 3
110582: PUSH
110583: EMPTY
110584: LIST
110585: LIST
110586: PPUSH
110587: CALL_OW 69
110591: IN
110592: PUSH
110593: LD_EXP 146
110597: PUSH
110598: LD_VAR 0 1
110602: ARRAY
110603: PUSH
110604: LD_VAR 0 2
110608: ARRAY
110609: PUSH
110610: LD_INT 1
110612: ARRAY
110613: PPUSH
110614: LD_EXP 146
110618: PUSH
110619: LD_VAR 0 1
110623: ARRAY
110624: PUSH
110625: LD_VAR 0 2
110629: ARRAY
110630: PUSH
110631: LD_INT 2
110633: ARRAY
110634: PPUSH
110635: CALL_OW 458
110639: AND
110640: IFFALSE 110734
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
110642: LD_EXP 146
110646: PUSH
110647: LD_VAR 0 1
110651: ARRAY
110652: PUSH
110653: LD_VAR 0 2
110657: ARRAY
110658: PUSH
110659: LD_INT 1
110661: ARRAY
110662: PPUSH
110663: LD_EXP 146
110667: PUSH
110668: LD_VAR 0 1
110672: ARRAY
110673: PUSH
110674: LD_VAR 0 2
110678: ARRAY
110679: PUSH
110680: LD_INT 2
110682: ARRAY
110683: PPUSH
110684: LD_VAR 0 3
110688: PPUSH
110689: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
110693: LD_ADDR_EXP 146
110697: PUSH
110698: LD_EXP 146
110702: PPUSH
110703: LD_VAR 0 1
110707: PPUSH
110708: LD_EXP 146
110712: PUSH
110713: LD_VAR 0 1
110717: ARRAY
110718: PPUSH
110719: LD_VAR 0 2
110723: PPUSH
110724: CALL_OW 3
110728: PPUSH
110729: CALL_OW 1
110733: ST_TO_ADDR
// end ; end ;
110734: GO 110485
110736: POP
110737: POP
// end ;
110738: GO 110403
110740: POP
110741: POP
// end ;
110742: PPOPN 4
110744: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
110745: LD_INT 0
110747: PPUSH
110748: PPUSH
// result := false ;
110749: LD_ADDR_VAR 0 4
110753: PUSH
110754: LD_INT 0
110756: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
110757: LD_VAR 0 1
110761: PPUSH
110762: CALL_OW 264
110766: PUSH
110767: LD_INT 81
110769: EQUAL
110770: NOT
110771: IFFALSE 110775
// exit ;
110773: GO 111015
// index := GetElementIndex ( minersList , unit ) ;
110775: LD_ADDR_VAR 0 5
110779: PUSH
110780: LD_EXP 145
110784: PPUSH
110785: LD_VAR 0 1
110789: PPUSH
110790: CALL 24631 0 2
110794: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
110795: LD_EXP 146
110799: PUSH
110800: LD_VAR 0 5
110804: ARRAY
110805: PUSH
110806: LD_EXP 147
110810: GREATEREQUAL
110811: IFFALSE 110815
// exit ;
110813: GO 111015
// ComMoveXY ( unit , x , y ) ;
110815: LD_VAR 0 1
110819: PPUSH
110820: LD_VAR 0 2
110824: PPUSH
110825: LD_VAR 0 3
110829: PPUSH
110830: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
110834: LD_INT 35
110836: PPUSH
110837: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
110841: LD_VAR 0 1
110845: PPUSH
110846: LD_VAR 0 2
110850: PPUSH
110851: LD_VAR 0 3
110855: PPUSH
110856: CALL 56015 0 3
110860: NOT
110861: PUSH
110862: LD_VAR 0 1
110866: PPUSH
110867: CALL_OW 314
110871: AND
110872: IFFALSE 110876
// exit ;
110874: GO 111015
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
110876: LD_VAR 0 2
110880: PPUSH
110881: LD_VAR 0 3
110885: PPUSH
110886: CALL_OW 428
110890: PUSH
110891: LD_VAR 0 1
110895: EQUAL
110896: PUSH
110897: LD_VAR 0 1
110901: PPUSH
110902: CALL_OW 314
110906: NOT
110907: AND
110908: IFFALSE 110834
// PlaySoundXY ( x , y , PlantMine ) ;
110910: LD_VAR 0 2
110914: PPUSH
110915: LD_VAR 0 3
110919: PPUSH
110920: LD_STRING PlantMine
110922: PPUSH
110923: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
110927: LD_VAR 0 2
110931: PPUSH
110932: LD_VAR 0 3
110936: PPUSH
110937: LD_VAR 0 1
110941: PPUSH
110942: CALL_OW 255
110946: PPUSH
110947: LD_INT 0
110949: PPUSH
110950: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
110954: LD_ADDR_EXP 146
110958: PUSH
110959: LD_EXP 146
110963: PPUSH
110964: LD_VAR 0 5
110968: PUSH
110969: LD_EXP 146
110973: PUSH
110974: LD_VAR 0 5
110978: ARRAY
110979: PUSH
110980: LD_INT 1
110982: PLUS
110983: PUSH
110984: EMPTY
110985: LIST
110986: LIST
110987: PPUSH
110988: LD_VAR 0 2
110992: PUSH
110993: LD_VAR 0 3
110997: PUSH
110998: EMPTY
110999: LIST
111000: LIST
111001: PPUSH
111002: CALL 24846 0 3
111006: ST_TO_ADDR
// result := true ;
111007: LD_ADDR_VAR 0 4
111011: PUSH
111012: LD_INT 1
111014: ST_TO_ADDR
// end ;
111015: LD_VAR 0 4
111019: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
111020: LD_INT 0
111022: PPUSH
111023: PPUSH
111024: PPUSH
// if not unit in minersList then
111025: LD_VAR 0 1
111029: PUSH
111030: LD_EXP 145
111034: IN
111035: NOT
111036: IFFALSE 111040
// exit ;
111038: GO 111432
// index := GetElementIndex ( minersList , unit ) ;
111040: LD_ADDR_VAR 0 6
111044: PUSH
111045: LD_EXP 145
111049: PPUSH
111050: LD_VAR 0 1
111054: PPUSH
111055: CALL 24631 0 2
111059: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
111060: LD_ADDR_VAR 0 5
111064: PUSH
111065: DOUBLE
111066: LD_EXP 146
111070: PUSH
111071: LD_VAR 0 6
111075: ARRAY
111076: INC
111077: ST_TO_ADDR
111078: LD_INT 1
111080: PUSH
111081: FOR_DOWNTO
111082: IFFALSE 111243
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
111084: LD_EXP 146
111088: PUSH
111089: LD_VAR 0 6
111093: ARRAY
111094: PUSH
111095: LD_VAR 0 5
111099: ARRAY
111100: PUSH
111101: LD_INT 1
111103: ARRAY
111104: PUSH
111105: LD_VAR 0 2
111109: EQUAL
111110: PUSH
111111: LD_EXP 146
111115: PUSH
111116: LD_VAR 0 6
111120: ARRAY
111121: PUSH
111122: LD_VAR 0 5
111126: ARRAY
111127: PUSH
111128: LD_INT 2
111130: ARRAY
111131: PUSH
111132: LD_VAR 0 3
111136: EQUAL
111137: AND
111138: IFFALSE 111241
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
111140: LD_EXP 146
111144: PUSH
111145: LD_VAR 0 6
111149: ARRAY
111150: PUSH
111151: LD_VAR 0 5
111155: ARRAY
111156: PUSH
111157: LD_INT 1
111159: ARRAY
111160: PPUSH
111161: LD_EXP 146
111165: PUSH
111166: LD_VAR 0 6
111170: ARRAY
111171: PUSH
111172: LD_VAR 0 5
111176: ARRAY
111177: PUSH
111178: LD_INT 2
111180: ARRAY
111181: PPUSH
111182: LD_VAR 0 1
111186: PPUSH
111187: CALL_OW 255
111191: PPUSH
111192: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
111196: LD_ADDR_EXP 146
111200: PUSH
111201: LD_EXP 146
111205: PPUSH
111206: LD_VAR 0 6
111210: PPUSH
111211: LD_EXP 146
111215: PUSH
111216: LD_VAR 0 6
111220: ARRAY
111221: PPUSH
111222: LD_VAR 0 5
111226: PPUSH
111227: CALL_OW 3
111231: PPUSH
111232: CALL_OW 1
111236: ST_TO_ADDR
// exit ;
111237: POP
111238: POP
111239: GO 111432
// end ; end ;
111241: GO 111081
111243: POP
111244: POP
// for i := minerMinesList [ index ] downto 1 do
111245: LD_ADDR_VAR 0 5
111249: PUSH
111250: DOUBLE
111251: LD_EXP 146
111255: PUSH
111256: LD_VAR 0 6
111260: ARRAY
111261: INC
111262: ST_TO_ADDR
111263: LD_INT 1
111265: PUSH
111266: FOR_DOWNTO
111267: IFFALSE 111430
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
111269: LD_EXP 146
111273: PUSH
111274: LD_VAR 0 6
111278: ARRAY
111279: PUSH
111280: LD_VAR 0 5
111284: ARRAY
111285: PUSH
111286: LD_INT 1
111288: ARRAY
111289: PPUSH
111290: LD_EXP 146
111294: PUSH
111295: LD_VAR 0 6
111299: ARRAY
111300: PUSH
111301: LD_VAR 0 5
111305: ARRAY
111306: PUSH
111307: LD_INT 2
111309: ARRAY
111310: PPUSH
111311: LD_VAR 0 2
111315: PPUSH
111316: LD_VAR 0 3
111320: PPUSH
111321: CALL_OW 298
111325: PUSH
111326: LD_INT 6
111328: LESS
111329: IFFALSE 111428
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
111331: LD_EXP 146
111335: PUSH
111336: LD_VAR 0 6
111340: ARRAY
111341: PUSH
111342: LD_VAR 0 5
111346: ARRAY
111347: PUSH
111348: LD_INT 1
111350: ARRAY
111351: PPUSH
111352: LD_EXP 146
111356: PUSH
111357: LD_VAR 0 6
111361: ARRAY
111362: PUSH
111363: LD_VAR 0 5
111367: ARRAY
111368: PUSH
111369: LD_INT 2
111371: ARRAY
111372: PPUSH
111373: LD_VAR 0 1
111377: PPUSH
111378: CALL_OW 255
111382: PPUSH
111383: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
111387: LD_ADDR_EXP 146
111391: PUSH
111392: LD_EXP 146
111396: PPUSH
111397: LD_VAR 0 6
111401: PPUSH
111402: LD_EXP 146
111406: PUSH
111407: LD_VAR 0 6
111411: ARRAY
111412: PPUSH
111413: LD_VAR 0 5
111417: PPUSH
111418: CALL_OW 3
111422: PPUSH
111423: CALL_OW 1
111427: ST_TO_ADDR
// end ; end ;
111428: GO 111266
111430: POP
111431: POP
// end ;
111432: LD_VAR 0 4
111436: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
111437: LD_INT 0
111439: PPUSH
111440: PPUSH
111441: PPUSH
111442: PPUSH
111443: PPUSH
111444: PPUSH
111445: PPUSH
111446: PPUSH
111447: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
111448: LD_VAR 0 1
111452: PPUSH
111453: CALL_OW 264
111457: PUSH
111458: LD_INT 81
111460: EQUAL
111461: NOT
111462: PUSH
111463: LD_VAR 0 1
111467: PUSH
111468: LD_EXP 145
111472: IN
111473: NOT
111474: OR
111475: IFFALSE 111479
// exit ;
111477: GO 111801
// index := GetElementIndex ( minersList , unit ) ;
111479: LD_ADDR_VAR 0 6
111483: PUSH
111484: LD_EXP 145
111488: PPUSH
111489: LD_VAR 0 1
111493: PPUSH
111494: CALL 24631 0 2
111498: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
111499: LD_ADDR_VAR 0 8
111503: PUSH
111504: LD_EXP 147
111508: PUSH
111509: LD_EXP 146
111513: PUSH
111514: LD_VAR 0 6
111518: ARRAY
111519: MINUS
111520: ST_TO_ADDR
// if not minesFreeAmount then
111521: LD_VAR 0 8
111525: NOT
111526: IFFALSE 111530
// exit ;
111528: GO 111801
// tmp := [ ] ;
111530: LD_ADDR_VAR 0 7
111534: PUSH
111535: EMPTY
111536: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
111537: LD_ADDR_VAR 0 5
111541: PUSH
111542: DOUBLE
111543: LD_INT 1
111545: DEC
111546: ST_TO_ADDR
111547: LD_VAR 0 8
111551: PUSH
111552: FOR_TO
111553: IFFALSE 111748
// begin _d := rand ( 0 , 5 ) ;
111555: LD_ADDR_VAR 0 11
111559: PUSH
111560: LD_INT 0
111562: PPUSH
111563: LD_INT 5
111565: PPUSH
111566: CALL_OW 12
111570: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
111571: LD_ADDR_VAR 0 12
111575: PUSH
111576: LD_INT 2
111578: PPUSH
111579: LD_INT 6
111581: PPUSH
111582: CALL_OW 12
111586: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
111587: LD_ADDR_VAR 0 9
111591: PUSH
111592: LD_VAR 0 2
111596: PPUSH
111597: LD_VAR 0 11
111601: PPUSH
111602: LD_VAR 0 12
111606: PPUSH
111607: CALL_OW 272
111611: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
111612: LD_ADDR_VAR 0 10
111616: PUSH
111617: LD_VAR 0 3
111621: PPUSH
111622: LD_VAR 0 11
111626: PPUSH
111627: LD_VAR 0 12
111631: PPUSH
111632: CALL_OW 273
111636: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
111637: LD_VAR 0 9
111641: PPUSH
111642: LD_VAR 0 10
111646: PPUSH
111647: CALL_OW 488
111651: PUSH
111652: LD_VAR 0 9
111656: PUSH
111657: LD_VAR 0 10
111661: PUSH
111662: EMPTY
111663: LIST
111664: LIST
111665: PUSH
111666: LD_VAR 0 7
111670: IN
111671: NOT
111672: AND
111673: PUSH
111674: LD_VAR 0 9
111678: PPUSH
111679: LD_VAR 0 10
111683: PPUSH
111684: CALL_OW 458
111688: NOT
111689: AND
111690: IFFALSE 111732
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
111692: LD_ADDR_VAR 0 7
111696: PUSH
111697: LD_VAR 0 7
111701: PPUSH
111702: LD_VAR 0 7
111706: PUSH
111707: LD_INT 1
111709: PLUS
111710: PPUSH
111711: LD_VAR 0 9
111715: PUSH
111716: LD_VAR 0 10
111720: PUSH
111721: EMPTY
111722: LIST
111723: LIST
111724: PPUSH
111725: CALL_OW 1
111729: ST_TO_ADDR
111730: GO 111746
// i := i - 1 ;
111732: LD_ADDR_VAR 0 5
111736: PUSH
111737: LD_VAR 0 5
111741: PUSH
111742: LD_INT 1
111744: MINUS
111745: ST_TO_ADDR
// end ;
111746: GO 111552
111748: POP
111749: POP
// for i in tmp do
111750: LD_ADDR_VAR 0 5
111754: PUSH
111755: LD_VAR 0 7
111759: PUSH
111760: FOR_IN
111761: IFFALSE 111799
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
111763: LD_VAR 0 1
111767: PPUSH
111768: LD_VAR 0 5
111772: PUSH
111773: LD_INT 1
111775: ARRAY
111776: PPUSH
111777: LD_VAR 0 5
111781: PUSH
111782: LD_INT 2
111784: ARRAY
111785: PPUSH
111786: CALL 110745 0 3
111790: NOT
111791: IFFALSE 111797
// exit ;
111793: POP
111794: POP
111795: GO 111801
111797: GO 111760
111799: POP
111800: POP
// end ;
111801: LD_VAR 0 4
111805: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
111806: LD_INT 0
111808: PPUSH
111809: PPUSH
111810: PPUSH
111811: PPUSH
111812: PPUSH
111813: PPUSH
111814: PPUSH
// if not GetClass ( unit ) = class_sniper then
111815: LD_VAR 0 1
111819: PPUSH
111820: CALL_OW 257
111824: PUSH
111825: LD_INT 5
111827: EQUAL
111828: NOT
111829: IFFALSE 111833
// exit ;
111831: GO 112221
// dist := 8 ;
111833: LD_ADDR_VAR 0 5
111837: PUSH
111838: LD_INT 8
111840: ST_TO_ADDR
// viewRange := 12 ;
111841: LD_ADDR_VAR 0 7
111845: PUSH
111846: LD_INT 12
111848: ST_TO_ADDR
// side := GetSide ( unit ) ;
111849: LD_ADDR_VAR 0 6
111853: PUSH
111854: LD_VAR 0 1
111858: PPUSH
111859: CALL_OW 255
111863: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
111864: LD_INT 61
111866: PPUSH
111867: LD_VAR 0 6
111871: PPUSH
111872: CALL_OW 321
111876: PUSH
111877: LD_INT 2
111879: EQUAL
111880: IFFALSE 111890
// viewRange := 16 ;
111882: LD_ADDR_VAR 0 7
111886: PUSH
111887: LD_INT 16
111889: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
111890: LD_VAR 0 1
111894: PPUSH
111895: LD_VAR 0 2
111899: PPUSH
111900: LD_VAR 0 3
111904: PPUSH
111905: CALL_OW 297
111909: PUSH
111910: LD_VAR 0 5
111914: GREATER
111915: IFFALSE 111994
// begin ComMoveXY ( unit , x , y ) ;
111917: LD_VAR 0 1
111921: PPUSH
111922: LD_VAR 0 2
111926: PPUSH
111927: LD_VAR 0 3
111931: PPUSH
111932: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
111936: LD_INT 35
111938: PPUSH
111939: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
111943: LD_VAR 0 1
111947: PPUSH
111948: LD_VAR 0 2
111952: PPUSH
111953: LD_VAR 0 3
111957: PPUSH
111958: CALL 56015 0 3
111962: NOT
111963: IFFALSE 111967
// exit ;
111965: GO 112221
// until GetDistUnitXY ( unit , x , y ) < dist ;
111967: LD_VAR 0 1
111971: PPUSH
111972: LD_VAR 0 2
111976: PPUSH
111977: LD_VAR 0 3
111981: PPUSH
111982: CALL_OW 297
111986: PUSH
111987: LD_VAR 0 5
111991: LESS
111992: IFFALSE 111936
// end ; ComTurnXY ( unit , x , y ) ;
111994: LD_VAR 0 1
111998: PPUSH
111999: LD_VAR 0 2
112003: PPUSH
112004: LD_VAR 0 3
112008: PPUSH
112009: CALL_OW 118
// wait ( 5 ) ;
112013: LD_INT 5
112015: PPUSH
112016: CALL_OW 67
// _d := GetDir ( unit ) ;
112020: LD_ADDR_VAR 0 10
112024: PUSH
112025: LD_VAR 0 1
112029: PPUSH
112030: CALL_OW 254
112034: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
112035: LD_ADDR_VAR 0 8
112039: PUSH
112040: LD_VAR 0 1
112044: PPUSH
112045: CALL_OW 250
112049: PPUSH
112050: LD_VAR 0 10
112054: PPUSH
112055: LD_VAR 0 5
112059: PPUSH
112060: CALL_OW 272
112064: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
112065: LD_ADDR_VAR 0 9
112069: PUSH
112070: LD_VAR 0 1
112074: PPUSH
112075: CALL_OW 251
112079: PPUSH
112080: LD_VAR 0 10
112084: PPUSH
112085: LD_VAR 0 5
112089: PPUSH
112090: CALL_OW 273
112094: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
112095: LD_VAR 0 8
112099: PPUSH
112100: LD_VAR 0 9
112104: PPUSH
112105: CALL_OW 488
112109: NOT
112110: IFFALSE 112114
// exit ;
112112: GO 112221
// ComAnimCustom ( unit , 1 ) ;
112114: LD_VAR 0 1
112118: PPUSH
112119: LD_INT 1
112121: PPUSH
112122: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
112126: LD_VAR 0 8
112130: PPUSH
112131: LD_VAR 0 9
112135: PPUSH
112136: LD_VAR 0 6
112140: PPUSH
112141: LD_VAR 0 7
112145: PPUSH
112146: CALL_OW 330
// repeat wait ( 1 ) ;
112150: LD_INT 1
112152: PPUSH
112153: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
112157: LD_VAR 0 1
112161: PPUSH
112162: CALL_OW 316
112166: PUSH
112167: LD_VAR 0 1
112171: PPUSH
112172: CALL_OW 314
112176: OR
112177: PUSH
112178: LD_VAR 0 1
112182: PPUSH
112183: CALL_OW 302
112187: NOT
112188: OR
112189: PUSH
112190: LD_VAR 0 1
112194: PPUSH
112195: CALL_OW 301
112199: OR
112200: IFFALSE 112150
// RemoveSeeing ( _x , _y , side ) ;
112202: LD_VAR 0 8
112206: PPUSH
112207: LD_VAR 0 9
112211: PPUSH
112212: LD_VAR 0 6
112216: PPUSH
112217: CALL_OW 331
// end ; end_of_file
112221: LD_VAR 0 4
112225: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
112226: LD_INT 0
112228: PPUSH
112229: PPUSH
112230: PPUSH
112231: PPUSH
112232: PPUSH
112233: PPUSH
112234: PPUSH
112235: PPUSH
112236: PPUSH
112237: PPUSH
112238: PPUSH
112239: PPUSH
112240: PPUSH
112241: PPUSH
112242: PPUSH
112243: PPUSH
112244: PPUSH
112245: PPUSH
112246: PPUSH
112247: PPUSH
112248: PPUSH
112249: PPUSH
112250: PPUSH
112251: PPUSH
112252: PPUSH
112253: PPUSH
112254: PPUSH
112255: PPUSH
112256: PPUSH
112257: PPUSH
112258: PPUSH
112259: PPUSH
112260: PPUSH
112261: PPUSH
// if not list then
112262: LD_VAR 0 1
112266: NOT
112267: IFFALSE 112271
// exit ;
112269: GO 116930
// base := list [ 1 ] ;
112271: LD_ADDR_VAR 0 3
112275: PUSH
112276: LD_VAR 0 1
112280: PUSH
112281: LD_INT 1
112283: ARRAY
112284: ST_TO_ADDR
// group := list [ 2 ] ;
112285: LD_ADDR_VAR 0 4
112289: PUSH
112290: LD_VAR 0 1
112294: PUSH
112295: LD_INT 2
112297: ARRAY
112298: ST_TO_ADDR
// path := list [ 3 ] ;
112299: LD_ADDR_VAR 0 5
112303: PUSH
112304: LD_VAR 0 1
112308: PUSH
112309: LD_INT 3
112311: ARRAY
112312: ST_TO_ADDR
// flags := list [ 4 ] ;
112313: LD_ADDR_VAR 0 6
112317: PUSH
112318: LD_VAR 0 1
112322: PUSH
112323: LD_INT 4
112325: ARRAY
112326: ST_TO_ADDR
// mined := [ ] ;
112327: LD_ADDR_VAR 0 27
112331: PUSH
112332: EMPTY
112333: ST_TO_ADDR
// bombed := [ ] ;
112334: LD_ADDR_VAR 0 28
112338: PUSH
112339: EMPTY
112340: ST_TO_ADDR
// healers := [ ] ;
112341: LD_ADDR_VAR 0 31
112345: PUSH
112346: EMPTY
112347: ST_TO_ADDR
// to_heal := [ ] ;
112348: LD_ADDR_VAR 0 30
112352: PUSH
112353: EMPTY
112354: ST_TO_ADDR
// repairs := [ ] ;
112355: LD_ADDR_VAR 0 33
112359: PUSH
112360: EMPTY
112361: ST_TO_ADDR
// to_repair := [ ] ;
112362: LD_ADDR_VAR 0 32
112366: PUSH
112367: EMPTY
112368: ST_TO_ADDR
// if not group or not path then
112369: LD_VAR 0 4
112373: NOT
112374: PUSH
112375: LD_VAR 0 5
112379: NOT
112380: OR
112381: IFFALSE 112385
// exit ;
112383: GO 116930
// side := GetSide ( group [ 1 ] ) ;
112385: LD_ADDR_VAR 0 35
112389: PUSH
112390: LD_VAR 0 4
112394: PUSH
112395: LD_INT 1
112397: ARRAY
112398: PPUSH
112399: CALL_OW 255
112403: ST_TO_ADDR
// if flags then
112404: LD_VAR 0 6
112408: IFFALSE 112552
// begin f_ignore_area := flags [ 1 ] ;
112410: LD_ADDR_VAR 0 17
112414: PUSH
112415: LD_VAR 0 6
112419: PUSH
112420: LD_INT 1
112422: ARRAY
112423: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
112424: LD_ADDR_VAR 0 18
112428: PUSH
112429: LD_VAR 0 6
112433: PUSH
112434: LD_INT 2
112436: ARRAY
112437: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
112438: LD_ADDR_VAR 0 19
112442: PUSH
112443: LD_VAR 0 6
112447: PUSH
112448: LD_INT 3
112450: ARRAY
112451: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
112452: LD_ADDR_VAR 0 20
112456: PUSH
112457: LD_VAR 0 6
112461: PUSH
112462: LD_INT 4
112464: ARRAY
112465: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
112466: LD_ADDR_VAR 0 21
112470: PUSH
112471: LD_VAR 0 6
112475: PUSH
112476: LD_INT 5
112478: ARRAY
112479: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
112480: LD_ADDR_VAR 0 22
112484: PUSH
112485: LD_VAR 0 6
112489: PUSH
112490: LD_INT 6
112492: ARRAY
112493: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
112494: LD_ADDR_VAR 0 23
112498: PUSH
112499: LD_VAR 0 6
112503: PUSH
112504: LD_INT 7
112506: ARRAY
112507: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
112508: LD_ADDR_VAR 0 24
112512: PUSH
112513: LD_VAR 0 6
112517: PUSH
112518: LD_INT 8
112520: ARRAY
112521: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
112522: LD_ADDR_VAR 0 25
112526: PUSH
112527: LD_VAR 0 6
112531: PUSH
112532: LD_INT 9
112534: ARRAY
112535: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
112536: LD_ADDR_VAR 0 26
112540: PUSH
112541: LD_VAR 0 6
112545: PUSH
112546: LD_INT 10
112548: ARRAY
112549: ST_TO_ADDR
// end else
112550: GO 112632
// begin f_ignore_area := false ;
112552: LD_ADDR_VAR 0 17
112556: PUSH
112557: LD_INT 0
112559: ST_TO_ADDR
// f_capture := false ;
112560: LD_ADDR_VAR 0 18
112564: PUSH
112565: LD_INT 0
112567: ST_TO_ADDR
// f_ignore_civ := false ;
112568: LD_ADDR_VAR 0 19
112572: PUSH
112573: LD_INT 0
112575: ST_TO_ADDR
// f_murder := false ;
112576: LD_ADDR_VAR 0 20
112580: PUSH
112581: LD_INT 0
112583: ST_TO_ADDR
// f_mines := false ;
112584: LD_ADDR_VAR 0 21
112588: PUSH
112589: LD_INT 0
112591: ST_TO_ADDR
// f_repair := false ;
112592: LD_ADDR_VAR 0 22
112596: PUSH
112597: LD_INT 0
112599: ST_TO_ADDR
// f_heal := false ;
112600: LD_ADDR_VAR 0 23
112604: PUSH
112605: LD_INT 0
112607: ST_TO_ADDR
// f_spacetime := false ;
112608: LD_ADDR_VAR 0 24
112612: PUSH
112613: LD_INT 0
112615: ST_TO_ADDR
// f_attack_depot := false ;
112616: LD_ADDR_VAR 0 25
112620: PUSH
112621: LD_INT 0
112623: ST_TO_ADDR
// f_crawl := false ;
112624: LD_ADDR_VAR 0 26
112628: PUSH
112629: LD_INT 0
112631: ST_TO_ADDR
// end ; if f_heal then
112632: LD_VAR 0 23
112636: IFFALSE 112663
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
112638: LD_ADDR_VAR 0 31
112642: PUSH
112643: LD_VAR 0 4
112647: PPUSH
112648: LD_INT 25
112650: PUSH
112651: LD_INT 4
112653: PUSH
112654: EMPTY
112655: LIST
112656: LIST
112657: PPUSH
112658: CALL_OW 72
112662: ST_TO_ADDR
// if f_repair then
112663: LD_VAR 0 22
112667: IFFALSE 112694
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
112669: LD_ADDR_VAR 0 33
112673: PUSH
112674: LD_VAR 0 4
112678: PPUSH
112679: LD_INT 25
112681: PUSH
112682: LD_INT 3
112684: PUSH
112685: EMPTY
112686: LIST
112687: LIST
112688: PPUSH
112689: CALL_OW 72
112693: ST_TO_ADDR
// units_path := [ ] ;
112694: LD_ADDR_VAR 0 16
112698: PUSH
112699: EMPTY
112700: ST_TO_ADDR
// for i = 1 to group do
112701: LD_ADDR_VAR 0 7
112705: PUSH
112706: DOUBLE
112707: LD_INT 1
112709: DEC
112710: ST_TO_ADDR
112711: LD_VAR 0 4
112715: PUSH
112716: FOR_TO
112717: IFFALSE 112746
// units_path := Replace ( units_path , i , path ) ;
112719: LD_ADDR_VAR 0 16
112723: PUSH
112724: LD_VAR 0 16
112728: PPUSH
112729: LD_VAR 0 7
112733: PPUSH
112734: LD_VAR 0 5
112738: PPUSH
112739: CALL_OW 1
112743: ST_TO_ADDR
112744: GO 112716
112746: POP
112747: POP
// repeat for i = group downto 1 do
112748: LD_ADDR_VAR 0 7
112752: PUSH
112753: DOUBLE
112754: LD_VAR 0 4
112758: INC
112759: ST_TO_ADDR
112760: LD_INT 1
112762: PUSH
112763: FOR_DOWNTO
112764: IFFALSE 116886
// begin wait ( 5 ) ;
112766: LD_INT 5
112768: PPUSH
112769: CALL_OW 67
// tmp := [ ] ;
112773: LD_ADDR_VAR 0 14
112777: PUSH
112778: EMPTY
112779: ST_TO_ADDR
// attacking := false ;
112780: LD_ADDR_VAR 0 29
112784: PUSH
112785: LD_INT 0
112787: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
112788: LD_VAR 0 4
112792: PUSH
112793: LD_VAR 0 7
112797: ARRAY
112798: PPUSH
112799: CALL_OW 301
112803: PUSH
112804: LD_VAR 0 4
112808: PUSH
112809: LD_VAR 0 7
112813: ARRAY
112814: NOT
112815: OR
112816: IFFALSE 112925
// begin if GetType ( group [ i ] ) = unit_human then
112818: LD_VAR 0 4
112822: PUSH
112823: LD_VAR 0 7
112827: ARRAY
112828: PPUSH
112829: CALL_OW 247
112833: PUSH
112834: LD_INT 1
112836: EQUAL
112837: IFFALSE 112883
// begin to_heal := to_heal diff group [ i ] ;
112839: LD_ADDR_VAR 0 30
112843: PUSH
112844: LD_VAR 0 30
112848: PUSH
112849: LD_VAR 0 4
112853: PUSH
112854: LD_VAR 0 7
112858: ARRAY
112859: DIFF
112860: ST_TO_ADDR
// healers := healers diff group [ i ] ;
112861: LD_ADDR_VAR 0 31
112865: PUSH
112866: LD_VAR 0 31
112870: PUSH
112871: LD_VAR 0 4
112875: PUSH
112876: LD_VAR 0 7
112880: ARRAY
112881: DIFF
112882: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
112883: LD_ADDR_VAR 0 4
112887: PUSH
112888: LD_VAR 0 4
112892: PPUSH
112893: LD_VAR 0 7
112897: PPUSH
112898: CALL_OW 3
112902: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
112903: LD_ADDR_VAR 0 16
112907: PUSH
112908: LD_VAR 0 16
112912: PPUSH
112913: LD_VAR 0 7
112917: PPUSH
112918: CALL_OW 3
112922: ST_TO_ADDR
// continue ;
112923: GO 112763
// end ; if f_repair then
112925: LD_VAR 0 22
112929: IFFALSE 113418
// begin if GetType ( group [ i ] ) = unit_vehicle then
112931: LD_VAR 0 4
112935: PUSH
112936: LD_VAR 0 7
112940: ARRAY
112941: PPUSH
112942: CALL_OW 247
112946: PUSH
112947: LD_INT 2
112949: EQUAL
112950: IFFALSE 113140
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
112952: LD_VAR 0 4
112956: PUSH
112957: LD_VAR 0 7
112961: ARRAY
112962: PPUSH
112963: CALL_OW 256
112967: PUSH
112968: LD_INT 700
112970: LESS
112971: PUSH
112972: LD_VAR 0 4
112976: PUSH
112977: LD_VAR 0 7
112981: ARRAY
112982: PUSH
112983: LD_VAR 0 32
112987: IN
112988: NOT
112989: AND
112990: IFFALSE 113014
// to_repair := to_repair union group [ i ] ;
112992: LD_ADDR_VAR 0 32
112996: PUSH
112997: LD_VAR 0 32
113001: PUSH
113002: LD_VAR 0 4
113006: PUSH
113007: LD_VAR 0 7
113011: ARRAY
113012: UNION
113013: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
113014: LD_VAR 0 4
113018: PUSH
113019: LD_VAR 0 7
113023: ARRAY
113024: PPUSH
113025: CALL_OW 256
113029: PUSH
113030: LD_INT 1000
113032: EQUAL
113033: PUSH
113034: LD_VAR 0 4
113038: PUSH
113039: LD_VAR 0 7
113043: ARRAY
113044: PUSH
113045: LD_VAR 0 32
113049: IN
113050: AND
113051: IFFALSE 113075
// to_repair := to_repair diff group [ i ] ;
113053: LD_ADDR_VAR 0 32
113057: PUSH
113058: LD_VAR 0 32
113062: PUSH
113063: LD_VAR 0 4
113067: PUSH
113068: LD_VAR 0 7
113072: ARRAY
113073: DIFF
113074: ST_TO_ADDR
// if group [ i ] in to_repair then
113075: LD_VAR 0 4
113079: PUSH
113080: LD_VAR 0 7
113084: ARRAY
113085: PUSH
113086: LD_VAR 0 32
113090: IN
113091: IFFALSE 113138
// begin if not IsInArea ( group [ i ] , f_repair ) then
113093: LD_VAR 0 4
113097: PUSH
113098: LD_VAR 0 7
113102: ARRAY
113103: PPUSH
113104: LD_VAR 0 22
113108: PPUSH
113109: CALL_OW 308
113113: NOT
113114: IFFALSE 113136
// ComMoveToArea ( group [ i ] , f_repair ) ;
113116: LD_VAR 0 4
113120: PUSH
113121: LD_VAR 0 7
113125: ARRAY
113126: PPUSH
113127: LD_VAR 0 22
113131: PPUSH
113132: CALL_OW 113
// continue ;
113136: GO 112763
// end ; end else
113138: GO 113418
// if group [ i ] in repairs then
113140: LD_VAR 0 4
113144: PUSH
113145: LD_VAR 0 7
113149: ARRAY
113150: PUSH
113151: LD_VAR 0 33
113155: IN
113156: IFFALSE 113418
// begin if IsInUnit ( group [ i ] ) then
113158: LD_VAR 0 4
113162: PUSH
113163: LD_VAR 0 7
113167: ARRAY
113168: PPUSH
113169: CALL_OW 310
113173: IFFALSE 113241
// begin z := IsInUnit ( group [ i ] ) ;
113175: LD_ADDR_VAR 0 13
113179: PUSH
113180: LD_VAR 0 4
113184: PUSH
113185: LD_VAR 0 7
113189: ARRAY
113190: PPUSH
113191: CALL_OW 310
113195: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
113196: LD_VAR 0 13
113200: PUSH
113201: LD_VAR 0 32
113205: IN
113206: PUSH
113207: LD_VAR 0 13
113211: PPUSH
113212: LD_VAR 0 22
113216: PPUSH
113217: CALL_OW 308
113221: AND
113222: IFFALSE 113239
// ComExitVehicle ( group [ i ] ) ;
113224: LD_VAR 0 4
113228: PUSH
113229: LD_VAR 0 7
113233: ARRAY
113234: PPUSH
113235: CALL_OW 121
// end else
113239: GO 113418
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
113241: LD_ADDR_VAR 0 13
113245: PUSH
113246: LD_VAR 0 4
113250: PPUSH
113251: LD_INT 95
113253: PUSH
113254: LD_VAR 0 22
113258: PUSH
113259: EMPTY
113260: LIST
113261: LIST
113262: PUSH
113263: LD_INT 58
113265: PUSH
113266: EMPTY
113267: LIST
113268: PUSH
113269: EMPTY
113270: LIST
113271: LIST
113272: PPUSH
113273: CALL_OW 72
113277: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
113278: LD_VAR 0 4
113282: PUSH
113283: LD_VAR 0 7
113287: ARRAY
113288: PPUSH
113289: CALL_OW 314
113293: NOT
113294: IFFALSE 113416
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
113296: LD_ADDR_VAR 0 10
113300: PUSH
113301: LD_VAR 0 13
113305: PPUSH
113306: LD_VAR 0 4
113310: PUSH
113311: LD_VAR 0 7
113315: ARRAY
113316: PPUSH
113317: CALL_OW 74
113321: ST_TO_ADDR
// if not x then
113322: LD_VAR 0 10
113326: NOT
113327: IFFALSE 113331
// continue ;
113329: GO 112763
// if GetLives ( x ) < 1000 then
113331: LD_VAR 0 10
113335: PPUSH
113336: CALL_OW 256
113340: PUSH
113341: LD_INT 1000
113343: LESS
113344: IFFALSE 113368
// ComRepairVehicle ( group [ i ] , x ) else
113346: LD_VAR 0 4
113350: PUSH
113351: LD_VAR 0 7
113355: ARRAY
113356: PPUSH
113357: LD_VAR 0 10
113361: PPUSH
113362: CALL_OW 129
113366: GO 113416
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
113368: LD_VAR 0 23
113372: PUSH
113373: LD_VAR 0 4
113377: PUSH
113378: LD_VAR 0 7
113382: ARRAY
113383: PPUSH
113384: CALL_OW 256
113388: PUSH
113389: LD_INT 1000
113391: LESS
113392: AND
113393: NOT
113394: IFFALSE 113416
// ComEnterUnit ( group [ i ] , x ) ;
113396: LD_VAR 0 4
113400: PUSH
113401: LD_VAR 0 7
113405: ARRAY
113406: PPUSH
113407: LD_VAR 0 10
113411: PPUSH
113412: CALL_OW 120
// end ; continue ;
113416: GO 112763
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
113418: LD_VAR 0 23
113422: PUSH
113423: LD_VAR 0 4
113427: PUSH
113428: LD_VAR 0 7
113432: ARRAY
113433: PPUSH
113434: CALL_OW 247
113438: PUSH
113439: LD_INT 1
113441: EQUAL
113442: AND
113443: IFFALSE 113921
// begin if group [ i ] in healers then
113445: LD_VAR 0 4
113449: PUSH
113450: LD_VAR 0 7
113454: ARRAY
113455: PUSH
113456: LD_VAR 0 31
113460: IN
113461: IFFALSE 113734
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
113463: LD_VAR 0 4
113467: PUSH
113468: LD_VAR 0 7
113472: ARRAY
113473: PPUSH
113474: LD_VAR 0 23
113478: PPUSH
113479: CALL_OW 308
113483: NOT
113484: PUSH
113485: LD_VAR 0 4
113489: PUSH
113490: LD_VAR 0 7
113494: ARRAY
113495: PPUSH
113496: CALL_OW 314
113500: NOT
113501: AND
113502: IFFALSE 113526
// ComMoveToArea ( group [ i ] , f_heal ) else
113504: LD_VAR 0 4
113508: PUSH
113509: LD_VAR 0 7
113513: ARRAY
113514: PPUSH
113515: LD_VAR 0 23
113519: PPUSH
113520: CALL_OW 113
113524: GO 113732
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
113526: LD_VAR 0 4
113530: PUSH
113531: LD_VAR 0 7
113535: ARRAY
113536: PPUSH
113537: CALL 54598 0 1
113541: PPUSH
113542: CALL_OW 256
113546: PUSH
113547: LD_INT 1000
113549: EQUAL
113550: IFFALSE 113569
// ComStop ( group [ i ] ) else
113552: LD_VAR 0 4
113556: PUSH
113557: LD_VAR 0 7
113561: ARRAY
113562: PPUSH
113563: CALL_OW 141
113567: GO 113732
// if not HasTask ( group [ i ] ) and to_heal then
113569: LD_VAR 0 4
113573: PUSH
113574: LD_VAR 0 7
113578: ARRAY
113579: PPUSH
113580: CALL_OW 314
113584: NOT
113585: PUSH
113586: LD_VAR 0 30
113590: AND
113591: IFFALSE 113732
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
113593: LD_ADDR_VAR 0 13
113597: PUSH
113598: LD_VAR 0 30
113602: PPUSH
113603: LD_INT 3
113605: PUSH
113606: LD_INT 54
113608: PUSH
113609: EMPTY
113610: LIST
113611: PUSH
113612: EMPTY
113613: LIST
113614: LIST
113615: PPUSH
113616: CALL_OW 72
113620: PPUSH
113621: LD_VAR 0 4
113625: PUSH
113626: LD_VAR 0 7
113630: ARRAY
113631: PPUSH
113632: CALL_OW 74
113636: ST_TO_ADDR
// if z then
113637: LD_VAR 0 13
113641: IFFALSE 113732
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
113643: LD_INT 91
113645: PUSH
113646: LD_VAR 0 13
113650: PUSH
113651: LD_INT 10
113653: PUSH
113654: EMPTY
113655: LIST
113656: LIST
113657: LIST
113658: PUSH
113659: LD_INT 81
113661: PUSH
113662: LD_VAR 0 13
113666: PPUSH
113667: CALL_OW 255
113671: PUSH
113672: EMPTY
113673: LIST
113674: LIST
113675: PUSH
113676: EMPTY
113677: LIST
113678: LIST
113679: PPUSH
113680: CALL_OW 69
113684: PUSH
113685: LD_INT 0
113687: EQUAL
113688: IFFALSE 113712
// ComHeal ( group [ i ] , z ) else
113690: LD_VAR 0 4
113694: PUSH
113695: LD_VAR 0 7
113699: ARRAY
113700: PPUSH
113701: LD_VAR 0 13
113705: PPUSH
113706: CALL_OW 128
113710: GO 113732
// ComMoveToArea ( group [ i ] , f_heal ) ;
113712: LD_VAR 0 4
113716: PUSH
113717: LD_VAR 0 7
113721: ARRAY
113722: PPUSH
113723: LD_VAR 0 23
113727: PPUSH
113728: CALL_OW 113
// end ; continue ;
113732: GO 112763
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
113734: LD_VAR 0 4
113738: PUSH
113739: LD_VAR 0 7
113743: ARRAY
113744: PPUSH
113745: CALL_OW 256
113749: PUSH
113750: LD_INT 700
113752: LESS
113753: PUSH
113754: LD_VAR 0 4
113758: PUSH
113759: LD_VAR 0 7
113763: ARRAY
113764: PUSH
113765: LD_VAR 0 30
113769: IN
113770: NOT
113771: AND
113772: IFFALSE 113796
// to_heal := to_heal union group [ i ] ;
113774: LD_ADDR_VAR 0 30
113778: PUSH
113779: LD_VAR 0 30
113783: PUSH
113784: LD_VAR 0 4
113788: PUSH
113789: LD_VAR 0 7
113793: ARRAY
113794: UNION
113795: ST_TO_ADDR
// if group [ i ] in to_heal then
113796: LD_VAR 0 4
113800: PUSH
113801: LD_VAR 0 7
113805: ARRAY
113806: PUSH
113807: LD_VAR 0 30
113811: IN
113812: IFFALSE 113921
// begin if GetLives ( group [ i ] ) = 1000 then
113814: LD_VAR 0 4
113818: PUSH
113819: LD_VAR 0 7
113823: ARRAY
113824: PPUSH
113825: CALL_OW 256
113829: PUSH
113830: LD_INT 1000
113832: EQUAL
113833: IFFALSE 113859
// to_heal := to_heal diff group [ i ] else
113835: LD_ADDR_VAR 0 30
113839: PUSH
113840: LD_VAR 0 30
113844: PUSH
113845: LD_VAR 0 4
113849: PUSH
113850: LD_VAR 0 7
113854: ARRAY
113855: DIFF
113856: ST_TO_ADDR
113857: GO 113921
// begin if not IsInArea ( group [ i ] , to_heal ) then
113859: LD_VAR 0 4
113863: PUSH
113864: LD_VAR 0 7
113868: ARRAY
113869: PPUSH
113870: LD_VAR 0 30
113874: PPUSH
113875: CALL_OW 308
113879: NOT
113880: IFFALSE 113904
// ComMoveToArea ( group [ i ] , f_heal ) else
113882: LD_VAR 0 4
113886: PUSH
113887: LD_VAR 0 7
113891: ARRAY
113892: PPUSH
113893: LD_VAR 0 23
113897: PPUSH
113898: CALL_OW 113
113902: GO 113919
// ComHold ( group [ i ] ) ;
113904: LD_VAR 0 4
113908: PUSH
113909: LD_VAR 0 7
113913: ARRAY
113914: PPUSH
113915: CALL_OW 140
// continue ;
113919: GO 112763
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
113921: LD_VAR 0 4
113925: PUSH
113926: LD_VAR 0 7
113930: ARRAY
113931: PPUSH
113932: LD_INT 10
113934: PPUSH
113935: CALL 52369 0 2
113939: NOT
113940: PUSH
113941: LD_VAR 0 16
113945: PUSH
113946: LD_VAR 0 7
113950: ARRAY
113951: PUSH
113952: EMPTY
113953: EQUAL
113954: NOT
113955: AND
113956: IFFALSE 114222
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
113958: LD_VAR 0 4
113962: PUSH
113963: LD_VAR 0 7
113967: ARRAY
113968: PPUSH
113969: CALL_OW 262
113973: PUSH
113974: LD_INT 1
113976: PUSH
113977: LD_INT 2
113979: PUSH
113980: EMPTY
113981: LIST
113982: LIST
113983: IN
113984: IFFALSE 114025
// if GetFuel ( group [ i ] ) < 10 then
113986: LD_VAR 0 4
113990: PUSH
113991: LD_VAR 0 7
113995: ARRAY
113996: PPUSH
113997: CALL_OW 261
114001: PUSH
114002: LD_INT 10
114004: LESS
114005: IFFALSE 114025
// SetFuel ( group [ i ] , 12 ) ;
114007: LD_VAR 0 4
114011: PUSH
114012: LD_VAR 0 7
114016: ARRAY
114017: PPUSH
114018: LD_INT 12
114020: PPUSH
114021: CALL_OW 240
// if units_path [ i ] then
114025: LD_VAR 0 16
114029: PUSH
114030: LD_VAR 0 7
114034: ARRAY
114035: IFFALSE 114220
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
114037: LD_VAR 0 4
114041: PUSH
114042: LD_VAR 0 7
114046: ARRAY
114047: PPUSH
114048: LD_VAR 0 16
114052: PUSH
114053: LD_VAR 0 7
114057: ARRAY
114058: PUSH
114059: LD_INT 1
114061: ARRAY
114062: PUSH
114063: LD_INT 1
114065: ARRAY
114066: PPUSH
114067: LD_VAR 0 16
114071: PUSH
114072: LD_VAR 0 7
114076: ARRAY
114077: PUSH
114078: LD_INT 1
114080: ARRAY
114081: PUSH
114082: LD_INT 2
114084: ARRAY
114085: PPUSH
114086: CALL_OW 297
114090: PUSH
114091: LD_INT 6
114093: GREATER
114094: IFFALSE 114169
// begin if not HasTask ( group [ i ] ) then
114096: LD_VAR 0 4
114100: PUSH
114101: LD_VAR 0 7
114105: ARRAY
114106: PPUSH
114107: CALL_OW 314
114111: NOT
114112: IFFALSE 114167
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
114114: LD_VAR 0 4
114118: PUSH
114119: LD_VAR 0 7
114123: ARRAY
114124: PPUSH
114125: LD_VAR 0 16
114129: PUSH
114130: LD_VAR 0 7
114134: ARRAY
114135: PUSH
114136: LD_INT 1
114138: ARRAY
114139: PUSH
114140: LD_INT 1
114142: ARRAY
114143: PPUSH
114144: LD_VAR 0 16
114148: PUSH
114149: LD_VAR 0 7
114153: ARRAY
114154: PUSH
114155: LD_INT 1
114157: ARRAY
114158: PUSH
114159: LD_INT 2
114161: ARRAY
114162: PPUSH
114163: CALL_OW 114
// end else
114167: GO 114220
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
114169: LD_ADDR_VAR 0 15
114173: PUSH
114174: LD_VAR 0 16
114178: PUSH
114179: LD_VAR 0 7
114183: ARRAY
114184: PPUSH
114185: LD_INT 1
114187: PPUSH
114188: CALL_OW 3
114192: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
114193: LD_ADDR_VAR 0 16
114197: PUSH
114198: LD_VAR 0 16
114202: PPUSH
114203: LD_VAR 0 7
114207: PPUSH
114208: LD_VAR 0 15
114212: PPUSH
114213: CALL_OW 1
114217: ST_TO_ADDR
// continue ;
114218: GO 112763
// end ; end ; end else
114220: GO 116884
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
114222: LD_ADDR_VAR 0 14
114226: PUSH
114227: LD_INT 81
114229: PUSH
114230: LD_VAR 0 4
114234: PUSH
114235: LD_VAR 0 7
114239: ARRAY
114240: PPUSH
114241: CALL_OW 255
114245: PUSH
114246: EMPTY
114247: LIST
114248: LIST
114249: PPUSH
114250: CALL_OW 69
114254: ST_TO_ADDR
// if not tmp then
114255: LD_VAR 0 14
114259: NOT
114260: IFFALSE 114264
// continue ;
114262: GO 112763
// if f_ignore_area then
114264: LD_VAR 0 17
114268: IFFALSE 114356
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
114270: LD_ADDR_VAR 0 15
114274: PUSH
114275: LD_VAR 0 14
114279: PPUSH
114280: LD_INT 3
114282: PUSH
114283: LD_INT 92
114285: PUSH
114286: LD_VAR 0 17
114290: PUSH
114291: LD_INT 1
114293: ARRAY
114294: PUSH
114295: LD_VAR 0 17
114299: PUSH
114300: LD_INT 2
114302: ARRAY
114303: PUSH
114304: LD_VAR 0 17
114308: PUSH
114309: LD_INT 3
114311: ARRAY
114312: PUSH
114313: EMPTY
114314: LIST
114315: LIST
114316: LIST
114317: LIST
114318: PUSH
114319: EMPTY
114320: LIST
114321: LIST
114322: PPUSH
114323: CALL_OW 72
114327: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
114328: LD_VAR 0 14
114332: PUSH
114333: LD_VAR 0 15
114337: DIFF
114338: IFFALSE 114356
// tmp := tmp diff tmp2 ;
114340: LD_ADDR_VAR 0 14
114344: PUSH
114345: LD_VAR 0 14
114349: PUSH
114350: LD_VAR 0 15
114354: DIFF
114355: ST_TO_ADDR
// end ; if not f_murder then
114356: LD_VAR 0 20
114360: NOT
114361: IFFALSE 114419
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
114363: LD_ADDR_VAR 0 15
114367: PUSH
114368: LD_VAR 0 14
114372: PPUSH
114373: LD_INT 3
114375: PUSH
114376: LD_INT 50
114378: PUSH
114379: EMPTY
114380: LIST
114381: PUSH
114382: EMPTY
114383: LIST
114384: LIST
114385: PPUSH
114386: CALL_OW 72
114390: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
114391: LD_VAR 0 14
114395: PUSH
114396: LD_VAR 0 15
114400: DIFF
114401: IFFALSE 114419
// tmp := tmp diff tmp2 ;
114403: LD_ADDR_VAR 0 14
114407: PUSH
114408: LD_VAR 0 14
114412: PUSH
114413: LD_VAR 0 15
114417: DIFF
114418: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
114419: LD_ADDR_VAR 0 14
114423: PUSH
114424: LD_VAR 0 4
114428: PUSH
114429: LD_VAR 0 7
114433: ARRAY
114434: PPUSH
114435: LD_VAR 0 14
114439: PPUSH
114440: LD_INT 1
114442: PPUSH
114443: LD_INT 1
114445: PPUSH
114446: CALL 25281 0 4
114450: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
114451: LD_VAR 0 4
114455: PUSH
114456: LD_VAR 0 7
114460: ARRAY
114461: PPUSH
114462: CALL_OW 257
114466: PUSH
114467: LD_INT 1
114469: EQUAL
114470: IFFALSE 114918
// begin if WantPlant ( group [ i ] ) then
114472: LD_VAR 0 4
114476: PUSH
114477: LD_VAR 0 7
114481: ARRAY
114482: PPUSH
114483: CALL 24782 0 1
114487: IFFALSE 114491
// continue ;
114489: GO 112763
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
114491: LD_VAR 0 18
114495: PUSH
114496: LD_VAR 0 4
114500: PUSH
114501: LD_VAR 0 7
114505: ARRAY
114506: PPUSH
114507: CALL_OW 310
114511: NOT
114512: AND
114513: PUSH
114514: LD_VAR 0 14
114518: PUSH
114519: LD_INT 1
114521: ARRAY
114522: PUSH
114523: LD_VAR 0 14
114527: PPUSH
114528: LD_INT 21
114530: PUSH
114531: LD_INT 2
114533: PUSH
114534: EMPTY
114535: LIST
114536: LIST
114537: PUSH
114538: LD_INT 58
114540: PUSH
114541: EMPTY
114542: LIST
114543: PUSH
114544: EMPTY
114545: LIST
114546: LIST
114547: PPUSH
114548: CALL_OW 72
114552: IN
114553: AND
114554: IFFALSE 114590
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
114556: LD_VAR 0 4
114560: PUSH
114561: LD_VAR 0 7
114565: ARRAY
114566: PPUSH
114567: LD_VAR 0 14
114571: PUSH
114572: LD_INT 1
114574: ARRAY
114575: PPUSH
114576: CALL_OW 120
// attacking := true ;
114580: LD_ADDR_VAR 0 29
114584: PUSH
114585: LD_INT 1
114587: ST_TO_ADDR
// continue ;
114588: GO 112763
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
114590: LD_VAR 0 26
114594: PUSH
114595: LD_VAR 0 4
114599: PUSH
114600: LD_VAR 0 7
114604: ARRAY
114605: PPUSH
114606: CALL_OW 257
114610: PUSH
114611: LD_INT 1
114613: EQUAL
114614: AND
114615: PUSH
114616: LD_VAR 0 4
114620: PUSH
114621: LD_VAR 0 7
114625: ARRAY
114626: PPUSH
114627: CALL_OW 256
114631: PUSH
114632: LD_INT 800
114634: LESS
114635: AND
114636: PUSH
114637: LD_VAR 0 4
114641: PUSH
114642: LD_VAR 0 7
114646: ARRAY
114647: PPUSH
114648: CALL_OW 318
114652: NOT
114653: AND
114654: IFFALSE 114671
// ComCrawl ( group [ i ] ) ;
114656: LD_VAR 0 4
114660: PUSH
114661: LD_VAR 0 7
114665: ARRAY
114666: PPUSH
114667: CALL_OW 137
// if f_mines then
114671: LD_VAR 0 21
114675: IFFALSE 114918
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
114677: LD_VAR 0 14
114681: PUSH
114682: LD_INT 1
114684: ARRAY
114685: PPUSH
114686: CALL_OW 247
114690: PUSH
114691: LD_INT 3
114693: EQUAL
114694: PUSH
114695: LD_VAR 0 14
114699: PUSH
114700: LD_INT 1
114702: ARRAY
114703: PUSH
114704: LD_VAR 0 27
114708: IN
114709: NOT
114710: AND
114711: IFFALSE 114918
// begin x := GetX ( tmp [ 1 ] ) ;
114713: LD_ADDR_VAR 0 10
114717: PUSH
114718: LD_VAR 0 14
114722: PUSH
114723: LD_INT 1
114725: ARRAY
114726: PPUSH
114727: CALL_OW 250
114731: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
114732: LD_ADDR_VAR 0 11
114736: PUSH
114737: LD_VAR 0 14
114741: PUSH
114742: LD_INT 1
114744: ARRAY
114745: PPUSH
114746: CALL_OW 251
114750: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
114751: LD_ADDR_VAR 0 12
114755: PUSH
114756: LD_VAR 0 4
114760: PUSH
114761: LD_VAR 0 7
114765: ARRAY
114766: PPUSH
114767: CALL 52454 0 1
114771: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
114772: LD_VAR 0 4
114776: PUSH
114777: LD_VAR 0 7
114781: ARRAY
114782: PPUSH
114783: LD_VAR 0 10
114787: PPUSH
114788: LD_VAR 0 11
114792: PPUSH
114793: LD_VAR 0 14
114797: PUSH
114798: LD_INT 1
114800: ARRAY
114801: PPUSH
114802: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
114806: LD_VAR 0 4
114810: PUSH
114811: LD_VAR 0 7
114815: ARRAY
114816: PPUSH
114817: LD_VAR 0 10
114821: PPUSH
114822: LD_VAR 0 12
114826: PPUSH
114827: LD_INT 7
114829: PPUSH
114830: CALL_OW 272
114834: PPUSH
114835: LD_VAR 0 11
114839: PPUSH
114840: LD_VAR 0 12
114844: PPUSH
114845: LD_INT 7
114847: PPUSH
114848: CALL_OW 273
114852: PPUSH
114853: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
114857: LD_VAR 0 4
114861: PUSH
114862: LD_VAR 0 7
114866: ARRAY
114867: PPUSH
114868: LD_INT 71
114870: PPUSH
114871: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
114875: LD_ADDR_VAR 0 27
114879: PUSH
114880: LD_VAR 0 27
114884: PPUSH
114885: LD_VAR 0 27
114889: PUSH
114890: LD_INT 1
114892: PLUS
114893: PPUSH
114894: LD_VAR 0 14
114898: PUSH
114899: LD_INT 1
114901: ARRAY
114902: PPUSH
114903: CALL_OW 1
114907: ST_TO_ADDR
// attacking := true ;
114908: LD_ADDR_VAR 0 29
114912: PUSH
114913: LD_INT 1
114915: ST_TO_ADDR
// continue ;
114916: GO 112763
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
114918: LD_VAR 0 4
114922: PUSH
114923: LD_VAR 0 7
114927: ARRAY
114928: PPUSH
114929: CALL_OW 257
114933: PUSH
114934: LD_INT 17
114936: EQUAL
114937: PUSH
114938: LD_VAR 0 4
114942: PUSH
114943: LD_VAR 0 7
114947: ARRAY
114948: PPUSH
114949: CALL_OW 110
114953: PUSH
114954: LD_INT 71
114956: EQUAL
114957: NOT
114958: AND
114959: IFFALSE 115105
// begin attacking := false ;
114961: LD_ADDR_VAR 0 29
114965: PUSH
114966: LD_INT 0
114968: ST_TO_ADDR
// k := 5 ;
114969: LD_ADDR_VAR 0 9
114973: PUSH
114974: LD_INT 5
114976: ST_TO_ADDR
// if tmp < k then
114977: LD_VAR 0 14
114981: PUSH
114982: LD_VAR 0 9
114986: LESS
114987: IFFALSE 114999
// k := tmp ;
114989: LD_ADDR_VAR 0 9
114993: PUSH
114994: LD_VAR 0 14
114998: ST_TO_ADDR
// for j = 1 to k do
114999: LD_ADDR_VAR 0 8
115003: PUSH
115004: DOUBLE
115005: LD_INT 1
115007: DEC
115008: ST_TO_ADDR
115009: LD_VAR 0 9
115013: PUSH
115014: FOR_TO
115015: IFFALSE 115103
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
115017: LD_VAR 0 14
115021: PUSH
115022: LD_VAR 0 8
115026: ARRAY
115027: PUSH
115028: LD_VAR 0 14
115032: PPUSH
115033: LD_INT 58
115035: PUSH
115036: EMPTY
115037: LIST
115038: PPUSH
115039: CALL_OW 72
115043: IN
115044: NOT
115045: IFFALSE 115101
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
115047: LD_VAR 0 4
115051: PUSH
115052: LD_VAR 0 7
115056: ARRAY
115057: PPUSH
115058: LD_VAR 0 14
115062: PUSH
115063: LD_VAR 0 8
115067: ARRAY
115068: PPUSH
115069: CALL_OW 115
// attacking := true ;
115073: LD_ADDR_VAR 0 29
115077: PUSH
115078: LD_INT 1
115080: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
115081: LD_VAR 0 4
115085: PUSH
115086: LD_VAR 0 7
115090: ARRAY
115091: PPUSH
115092: LD_INT 71
115094: PPUSH
115095: CALL_OW 109
// continue ;
115099: GO 115014
// end ; end ;
115101: GO 115014
115103: POP
115104: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
115105: LD_VAR 0 4
115109: PUSH
115110: LD_VAR 0 7
115114: ARRAY
115115: PPUSH
115116: CALL_OW 257
115120: PUSH
115121: LD_INT 8
115123: EQUAL
115124: PUSH
115125: LD_VAR 0 4
115129: PUSH
115130: LD_VAR 0 7
115134: ARRAY
115135: PPUSH
115136: CALL_OW 264
115140: PUSH
115141: LD_INT 28
115143: PUSH
115144: LD_INT 45
115146: PUSH
115147: LD_INT 7
115149: PUSH
115150: LD_INT 47
115152: PUSH
115153: EMPTY
115154: LIST
115155: LIST
115156: LIST
115157: LIST
115158: IN
115159: OR
115160: IFFALSE 115416
// begin attacking := false ;
115162: LD_ADDR_VAR 0 29
115166: PUSH
115167: LD_INT 0
115169: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
115170: LD_VAR 0 14
115174: PUSH
115175: LD_INT 1
115177: ARRAY
115178: PPUSH
115179: CALL_OW 266
115183: PUSH
115184: LD_INT 32
115186: PUSH
115187: LD_INT 31
115189: PUSH
115190: LD_INT 33
115192: PUSH
115193: LD_INT 4
115195: PUSH
115196: LD_INT 5
115198: PUSH
115199: EMPTY
115200: LIST
115201: LIST
115202: LIST
115203: LIST
115204: LIST
115205: IN
115206: IFFALSE 115392
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
115208: LD_ADDR_VAR 0 9
115212: PUSH
115213: LD_VAR 0 14
115217: PUSH
115218: LD_INT 1
115220: ARRAY
115221: PPUSH
115222: CALL_OW 266
115226: PPUSH
115227: LD_VAR 0 14
115231: PUSH
115232: LD_INT 1
115234: ARRAY
115235: PPUSH
115236: CALL_OW 250
115240: PPUSH
115241: LD_VAR 0 14
115245: PUSH
115246: LD_INT 1
115248: ARRAY
115249: PPUSH
115250: CALL_OW 251
115254: PPUSH
115255: LD_VAR 0 14
115259: PUSH
115260: LD_INT 1
115262: ARRAY
115263: PPUSH
115264: CALL_OW 254
115268: PPUSH
115269: LD_VAR 0 14
115273: PUSH
115274: LD_INT 1
115276: ARRAY
115277: PPUSH
115278: CALL_OW 248
115282: PPUSH
115283: LD_INT 0
115285: PPUSH
115286: CALL 33824 0 6
115290: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
115291: LD_ADDR_VAR 0 8
115295: PUSH
115296: LD_VAR 0 4
115300: PUSH
115301: LD_VAR 0 7
115305: ARRAY
115306: PPUSH
115307: LD_VAR 0 9
115311: PPUSH
115312: CALL 52567 0 2
115316: ST_TO_ADDR
// if j then
115317: LD_VAR 0 8
115321: IFFALSE 115390
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
115323: LD_VAR 0 8
115327: PUSH
115328: LD_INT 1
115330: ARRAY
115331: PPUSH
115332: LD_VAR 0 8
115336: PUSH
115337: LD_INT 2
115339: ARRAY
115340: PPUSH
115341: CALL_OW 488
115345: IFFALSE 115390
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
115347: LD_VAR 0 4
115351: PUSH
115352: LD_VAR 0 7
115356: ARRAY
115357: PPUSH
115358: LD_VAR 0 8
115362: PUSH
115363: LD_INT 1
115365: ARRAY
115366: PPUSH
115367: LD_VAR 0 8
115371: PUSH
115372: LD_INT 2
115374: ARRAY
115375: PPUSH
115376: CALL_OW 116
// attacking := true ;
115380: LD_ADDR_VAR 0 29
115384: PUSH
115385: LD_INT 1
115387: ST_TO_ADDR
// continue ;
115388: GO 112763
// end ; end else
115390: GO 115416
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
115392: LD_VAR 0 4
115396: PUSH
115397: LD_VAR 0 7
115401: ARRAY
115402: PPUSH
115403: LD_VAR 0 14
115407: PUSH
115408: LD_INT 1
115410: ARRAY
115411: PPUSH
115412: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
115416: LD_VAR 0 4
115420: PUSH
115421: LD_VAR 0 7
115425: ARRAY
115426: PPUSH
115427: CALL_OW 265
115431: PUSH
115432: LD_INT 11
115434: EQUAL
115435: IFFALSE 115713
// begin k := 10 ;
115437: LD_ADDR_VAR 0 9
115441: PUSH
115442: LD_INT 10
115444: ST_TO_ADDR
// x := 0 ;
115445: LD_ADDR_VAR 0 10
115449: PUSH
115450: LD_INT 0
115452: ST_TO_ADDR
// if tmp < k then
115453: LD_VAR 0 14
115457: PUSH
115458: LD_VAR 0 9
115462: LESS
115463: IFFALSE 115475
// k := tmp ;
115465: LD_ADDR_VAR 0 9
115469: PUSH
115470: LD_VAR 0 14
115474: ST_TO_ADDR
// for j = k downto 1 do
115475: LD_ADDR_VAR 0 8
115479: PUSH
115480: DOUBLE
115481: LD_VAR 0 9
115485: INC
115486: ST_TO_ADDR
115487: LD_INT 1
115489: PUSH
115490: FOR_DOWNTO
115491: IFFALSE 115566
// begin if GetType ( tmp [ j ] ) = unit_human then
115493: LD_VAR 0 14
115497: PUSH
115498: LD_VAR 0 8
115502: ARRAY
115503: PPUSH
115504: CALL_OW 247
115508: PUSH
115509: LD_INT 1
115511: EQUAL
115512: IFFALSE 115564
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
115514: LD_VAR 0 4
115518: PUSH
115519: LD_VAR 0 7
115523: ARRAY
115524: PPUSH
115525: LD_VAR 0 14
115529: PUSH
115530: LD_VAR 0 8
115534: ARRAY
115535: PPUSH
115536: CALL 52821 0 2
// x := tmp [ j ] ;
115540: LD_ADDR_VAR 0 10
115544: PUSH
115545: LD_VAR 0 14
115549: PUSH
115550: LD_VAR 0 8
115554: ARRAY
115555: ST_TO_ADDR
// attacking := true ;
115556: LD_ADDR_VAR 0 29
115560: PUSH
115561: LD_INT 1
115563: ST_TO_ADDR
// end ; end ;
115564: GO 115490
115566: POP
115567: POP
// if not x then
115568: LD_VAR 0 10
115572: NOT
115573: IFFALSE 115713
// begin attacking := true ;
115575: LD_ADDR_VAR 0 29
115579: PUSH
115580: LD_INT 1
115582: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
115583: LD_VAR 0 4
115587: PUSH
115588: LD_VAR 0 7
115592: ARRAY
115593: PPUSH
115594: CALL_OW 250
115598: PPUSH
115599: LD_VAR 0 4
115603: PUSH
115604: LD_VAR 0 7
115608: ARRAY
115609: PPUSH
115610: CALL_OW 251
115614: PPUSH
115615: CALL_OW 546
115619: PUSH
115620: LD_INT 2
115622: ARRAY
115623: PUSH
115624: LD_VAR 0 14
115628: PUSH
115629: LD_INT 1
115631: ARRAY
115632: PPUSH
115633: CALL_OW 250
115637: PPUSH
115638: LD_VAR 0 14
115642: PUSH
115643: LD_INT 1
115645: ARRAY
115646: PPUSH
115647: CALL_OW 251
115651: PPUSH
115652: CALL_OW 546
115656: PUSH
115657: LD_INT 2
115659: ARRAY
115660: EQUAL
115661: IFFALSE 115689
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
115663: LD_VAR 0 4
115667: PUSH
115668: LD_VAR 0 7
115672: ARRAY
115673: PPUSH
115674: LD_VAR 0 14
115678: PUSH
115679: LD_INT 1
115681: ARRAY
115682: PPUSH
115683: CALL 52821 0 2
115687: GO 115713
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
115689: LD_VAR 0 4
115693: PUSH
115694: LD_VAR 0 7
115698: ARRAY
115699: PPUSH
115700: LD_VAR 0 14
115704: PUSH
115705: LD_INT 1
115707: ARRAY
115708: PPUSH
115709: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
115713: LD_VAR 0 4
115717: PUSH
115718: LD_VAR 0 7
115722: ARRAY
115723: PPUSH
115724: CALL_OW 264
115728: PUSH
115729: LD_INT 29
115731: EQUAL
115732: IFFALSE 116098
// begin if WantsToAttack ( group [ i ] ) in bombed then
115734: LD_VAR 0 4
115738: PUSH
115739: LD_VAR 0 7
115743: ARRAY
115744: PPUSH
115745: CALL_OW 319
115749: PUSH
115750: LD_VAR 0 28
115754: IN
115755: IFFALSE 115759
// continue ;
115757: GO 112763
// k := 8 ;
115759: LD_ADDR_VAR 0 9
115763: PUSH
115764: LD_INT 8
115766: ST_TO_ADDR
// x := 0 ;
115767: LD_ADDR_VAR 0 10
115771: PUSH
115772: LD_INT 0
115774: ST_TO_ADDR
// if tmp < k then
115775: LD_VAR 0 14
115779: PUSH
115780: LD_VAR 0 9
115784: LESS
115785: IFFALSE 115797
// k := tmp ;
115787: LD_ADDR_VAR 0 9
115791: PUSH
115792: LD_VAR 0 14
115796: ST_TO_ADDR
// for j = 1 to k do
115797: LD_ADDR_VAR 0 8
115801: PUSH
115802: DOUBLE
115803: LD_INT 1
115805: DEC
115806: ST_TO_ADDR
115807: LD_VAR 0 9
115811: PUSH
115812: FOR_TO
115813: IFFALSE 115945
// begin if GetType ( tmp [ j ] ) = unit_building then
115815: LD_VAR 0 14
115819: PUSH
115820: LD_VAR 0 8
115824: ARRAY
115825: PPUSH
115826: CALL_OW 247
115830: PUSH
115831: LD_INT 3
115833: EQUAL
115834: IFFALSE 115943
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
115836: LD_VAR 0 14
115840: PUSH
115841: LD_VAR 0 8
115845: ARRAY
115846: PUSH
115847: LD_VAR 0 28
115851: IN
115852: NOT
115853: PUSH
115854: LD_VAR 0 14
115858: PUSH
115859: LD_VAR 0 8
115863: ARRAY
115864: PPUSH
115865: CALL_OW 313
115869: AND
115870: IFFALSE 115943
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
115872: LD_VAR 0 4
115876: PUSH
115877: LD_VAR 0 7
115881: ARRAY
115882: PPUSH
115883: LD_VAR 0 14
115887: PUSH
115888: LD_VAR 0 8
115892: ARRAY
115893: PPUSH
115894: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
115898: LD_ADDR_VAR 0 28
115902: PUSH
115903: LD_VAR 0 28
115907: PPUSH
115908: LD_VAR 0 28
115912: PUSH
115913: LD_INT 1
115915: PLUS
115916: PPUSH
115917: LD_VAR 0 14
115921: PUSH
115922: LD_VAR 0 8
115926: ARRAY
115927: PPUSH
115928: CALL_OW 1
115932: ST_TO_ADDR
// attacking := true ;
115933: LD_ADDR_VAR 0 29
115937: PUSH
115938: LD_INT 1
115940: ST_TO_ADDR
// break ;
115941: GO 115945
// end ; end ;
115943: GO 115812
115945: POP
115946: POP
// if not attacking and f_attack_depot then
115947: LD_VAR 0 29
115951: NOT
115952: PUSH
115953: LD_VAR 0 25
115957: AND
115958: IFFALSE 116053
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
115960: LD_ADDR_VAR 0 13
115964: PUSH
115965: LD_VAR 0 14
115969: PPUSH
115970: LD_INT 2
115972: PUSH
115973: LD_INT 30
115975: PUSH
115976: LD_INT 0
115978: PUSH
115979: EMPTY
115980: LIST
115981: LIST
115982: PUSH
115983: LD_INT 30
115985: PUSH
115986: LD_INT 1
115988: PUSH
115989: EMPTY
115990: LIST
115991: LIST
115992: PUSH
115993: EMPTY
115994: LIST
115995: LIST
115996: LIST
115997: PPUSH
115998: CALL_OW 72
116002: ST_TO_ADDR
// if z then
116003: LD_VAR 0 13
116007: IFFALSE 116053
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
116009: LD_VAR 0 4
116013: PUSH
116014: LD_VAR 0 7
116018: ARRAY
116019: PPUSH
116020: LD_VAR 0 13
116024: PPUSH
116025: LD_VAR 0 4
116029: PUSH
116030: LD_VAR 0 7
116034: ARRAY
116035: PPUSH
116036: CALL_OW 74
116040: PPUSH
116041: CALL_OW 115
// attacking := true ;
116045: LD_ADDR_VAR 0 29
116049: PUSH
116050: LD_INT 1
116052: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
116053: LD_VAR 0 4
116057: PUSH
116058: LD_VAR 0 7
116062: ARRAY
116063: PPUSH
116064: CALL_OW 256
116068: PUSH
116069: LD_INT 500
116071: LESS
116072: IFFALSE 116098
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
116074: LD_VAR 0 4
116078: PUSH
116079: LD_VAR 0 7
116083: ARRAY
116084: PPUSH
116085: LD_VAR 0 14
116089: PUSH
116090: LD_INT 1
116092: ARRAY
116093: PPUSH
116094: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
116098: LD_VAR 0 4
116102: PUSH
116103: LD_VAR 0 7
116107: ARRAY
116108: PPUSH
116109: CALL_OW 264
116113: PUSH
116114: LD_INT 49
116116: EQUAL
116117: IFFALSE 116238
// begin if not HasTask ( group [ i ] ) then
116119: LD_VAR 0 4
116123: PUSH
116124: LD_VAR 0 7
116128: ARRAY
116129: PPUSH
116130: CALL_OW 314
116134: NOT
116135: IFFALSE 116238
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
116137: LD_ADDR_VAR 0 9
116141: PUSH
116142: LD_INT 81
116144: PUSH
116145: LD_VAR 0 4
116149: PUSH
116150: LD_VAR 0 7
116154: ARRAY
116155: PPUSH
116156: CALL_OW 255
116160: PUSH
116161: EMPTY
116162: LIST
116163: LIST
116164: PPUSH
116165: CALL_OW 69
116169: PPUSH
116170: LD_VAR 0 4
116174: PUSH
116175: LD_VAR 0 7
116179: ARRAY
116180: PPUSH
116181: CALL_OW 74
116185: ST_TO_ADDR
// if k then
116186: LD_VAR 0 9
116190: IFFALSE 116238
// if GetDistUnits ( group [ i ] , k ) > 10 then
116192: LD_VAR 0 4
116196: PUSH
116197: LD_VAR 0 7
116201: ARRAY
116202: PPUSH
116203: LD_VAR 0 9
116207: PPUSH
116208: CALL_OW 296
116212: PUSH
116213: LD_INT 10
116215: GREATER
116216: IFFALSE 116238
// ComMoveUnit ( group [ i ] , k ) ;
116218: LD_VAR 0 4
116222: PUSH
116223: LD_VAR 0 7
116227: ARRAY
116228: PPUSH
116229: LD_VAR 0 9
116233: PPUSH
116234: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
116238: LD_VAR 0 4
116242: PUSH
116243: LD_VAR 0 7
116247: ARRAY
116248: PPUSH
116249: CALL_OW 256
116253: PUSH
116254: LD_INT 250
116256: LESS
116257: PUSH
116258: LD_VAR 0 4
116262: PUSH
116263: LD_VAR 0 7
116267: ARRAY
116268: PUSH
116269: LD_INT 21
116271: PUSH
116272: LD_INT 2
116274: PUSH
116275: EMPTY
116276: LIST
116277: LIST
116278: PUSH
116279: LD_INT 23
116281: PUSH
116282: LD_INT 2
116284: PUSH
116285: EMPTY
116286: LIST
116287: LIST
116288: PUSH
116289: EMPTY
116290: LIST
116291: LIST
116292: PPUSH
116293: CALL_OW 69
116297: IN
116298: AND
116299: IFFALSE 116424
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
116301: LD_ADDR_VAR 0 9
116305: PUSH
116306: LD_OWVAR 3
116310: PUSH
116311: LD_VAR 0 4
116315: PUSH
116316: LD_VAR 0 7
116320: ARRAY
116321: DIFF
116322: PPUSH
116323: LD_VAR 0 4
116327: PUSH
116328: LD_VAR 0 7
116332: ARRAY
116333: PPUSH
116334: CALL_OW 74
116338: ST_TO_ADDR
// if not k then
116339: LD_VAR 0 9
116343: NOT
116344: IFFALSE 116348
// continue ;
116346: GO 112763
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
116348: LD_VAR 0 9
116352: PUSH
116353: LD_INT 81
116355: PUSH
116356: LD_VAR 0 4
116360: PUSH
116361: LD_VAR 0 7
116365: ARRAY
116366: PPUSH
116367: CALL_OW 255
116371: PUSH
116372: EMPTY
116373: LIST
116374: LIST
116375: PPUSH
116376: CALL_OW 69
116380: IN
116381: PUSH
116382: LD_VAR 0 9
116386: PPUSH
116387: LD_VAR 0 4
116391: PUSH
116392: LD_VAR 0 7
116396: ARRAY
116397: PPUSH
116398: CALL_OW 296
116402: PUSH
116403: LD_INT 5
116405: LESS
116406: AND
116407: IFFALSE 116424
// ComAutodestruct ( group [ i ] ) ;
116409: LD_VAR 0 4
116413: PUSH
116414: LD_VAR 0 7
116418: ARRAY
116419: PPUSH
116420: CALL 52719 0 1
// end ; if f_attack_depot then
116424: LD_VAR 0 25
116428: IFFALSE 116540
// begin k := 6 ;
116430: LD_ADDR_VAR 0 9
116434: PUSH
116435: LD_INT 6
116437: ST_TO_ADDR
// if tmp < k then
116438: LD_VAR 0 14
116442: PUSH
116443: LD_VAR 0 9
116447: LESS
116448: IFFALSE 116460
// k := tmp ;
116450: LD_ADDR_VAR 0 9
116454: PUSH
116455: LD_VAR 0 14
116459: ST_TO_ADDR
// for j = 1 to k do
116460: LD_ADDR_VAR 0 8
116464: PUSH
116465: DOUBLE
116466: LD_INT 1
116468: DEC
116469: ST_TO_ADDR
116470: LD_VAR 0 9
116474: PUSH
116475: FOR_TO
116476: IFFALSE 116538
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
116478: LD_VAR 0 8
116482: PPUSH
116483: CALL_OW 266
116487: PUSH
116488: LD_INT 0
116490: PUSH
116491: LD_INT 1
116493: PUSH
116494: EMPTY
116495: LIST
116496: LIST
116497: IN
116498: IFFALSE 116536
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
116500: LD_VAR 0 4
116504: PUSH
116505: LD_VAR 0 7
116509: ARRAY
116510: PPUSH
116511: LD_VAR 0 14
116515: PUSH
116516: LD_VAR 0 8
116520: ARRAY
116521: PPUSH
116522: CALL_OW 115
// attacking := true ;
116526: LD_ADDR_VAR 0 29
116530: PUSH
116531: LD_INT 1
116533: ST_TO_ADDR
// break ;
116534: GO 116538
// end ;
116536: GO 116475
116538: POP
116539: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
116540: LD_VAR 0 4
116544: PUSH
116545: LD_VAR 0 7
116549: ARRAY
116550: PPUSH
116551: CALL_OW 302
116555: PUSH
116556: LD_VAR 0 29
116560: NOT
116561: AND
116562: IFFALSE 116884
// begin if GetTag ( group [ i ] ) = 71 then
116564: LD_VAR 0 4
116568: PUSH
116569: LD_VAR 0 7
116573: ARRAY
116574: PPUSH
116575: CALL_OW 110
116579: PUSH
116580: LD_INT 71
116582: EQUAL
116583: IFFALSE 116624
// begin if HasTask ( group [ i ] ) then
116585: LD_VAR 0 4
116589: PUSH
116590: LD_VAR 0 7
116594: ARRAY
116595: PPUSH
116596: CALL_OW 314
116600: IFFALSE 116606
// continue else
116602: GO 112763
116604: GO 116624
// SetTag ( group [ i ] , 0 ) ;
116606: LD_VAR 0 4
116610: PUSH
116611: LD_VAR 0 7
116615: ARRAY
116616: PPUSH
116617: LD_INT 0
116619: PPUSH
116620: CALL_OW 109
// end ; k := 8 ;
116624: LD_ADDR_VAR 0 9
116628: PUSH
116629: LD_INT 8
116631: ST_TO_ADDR
// x := 0 ;
116632: LD_ADDR_VAR 0 10
116636: PUSH
116637: LD_INT 0
116639: ST_TO_ADDR
// if tmp < k then
116640: LD_VAR 0 14
116644: PUSH
116645: LD_VAR 0 9
116649: LESS
116650: IFFALSE 116662
// k := tmp ;
116652: LD_ADDR_VAR 0 9
116656: PUSH
116657: LD_VAR 0 14
116661: ST_TO_ADDR
// for j = 1 to k do
116662: LD_ADDR_VAR 0 8
116666: PUSH
116667: DOUBLE
116668: LD_INT 1
116670: DEC
116671: ST_TO_ADDR
116672: LD_VAR 0 9
116676: PUSH
116677: FOR_TO
116678: IFFALSE 116776
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
116680: LD_VAR 0 14
116684: PUSH
116685: LD_VAR 0 8
116689: ARRAY
116690: PPUSH
116691: CALL_OW 247
116695: PUSH
116696: LD_INT 1
116698: EQUAL
116699: PUSH
116700: LD_VAR 0 14
116704: PUSH
116705: LD_VAR 0 8
116709: ARRAY
116710: PPUSH
116711: CALL_OW 256
116715: PUSH
116716: LD_INT 250
116718: LESS
116719: PUSH
116720: LD_VAR 0 20
116724: AND
116725: PUSH
116726: LD_VAR 0 20
116730: NOT
116731: PUSH
116732: LD_VAR 0 14
116736: PUSH
116737: LD_VAR 0 8
116741: ARRAY
116742: PPUSH
116743: CALL_OW 256
116747: PUSH
116748: LD_INT 250
116750: GREATEREQUAL
116751: AND
116752: OR
116753: AND
116754: IFFALSE 116774
// begin x := tmp [ j ] ;
116756: LD_ADDR_VAR 0 10
116760: PUSH
116761: LD_VAR 0 14
116765: PUSH
116766: LD_VAR 0 8
116770: ARRAY
116771: ST_TO_ADDR
// break ;
116772: GO 116776
// end ;
116774: GO 116677
116776: POP
116777: POP
// if x then
116778: LD_VAR 0 10
116782: IFFALSE 116806
// ComAttackUnit ( group [ i ] , x ) else
116784: LD_VAR 0 4
116788: PUSH
116789: LD_VAR 0 7
116793: ARRAY
116794: PPUSH
116795: LD_VAR 0 10
116799: PPUSH
116800: CALL_OW 115
116804: GO 116830
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
116806: LD_VAR 0 4
116810: PUSH
116811: LD_VAR 0 7
116815: ARRAY
116816: PPUSH
116817: LD_VAR 0 14
116821: PUSH
116822: LD_INT 1
116824: ARRAY
116825: PPUSH
116826: CALL_OW 115
// if not HasTask ( group [ i ] ) then
116830: LD_VAR 0 4
116834: PUSH
116835: LD_VAR 0 7
116839: ARRAY
116840: PPUSH
116841: CALL_OW 314
116845: NOT
116846: IFFALSE 116884
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
116848: LD_VAR 0 4
116852: PUSH
116853: LD_VAR 0 7
116857: ARRAY
116858: PPUSH
116859: LD_VAR 0 14
116863: PPUSH
116864: LD_VAR 0 4
116868: PUSH
116869: LD_VAR 0 7
116873: ARRAY
116874: PPUSH
116875: CALL_OW 74
116879: PPUSH
116880: CALL_OW 115
// end ; end ; end ;
116884: GO 112763
116886: POP
116887: POP
// wait ( 0 0$2 ) ;
116888: LD_INT 70
116890: PPUSH
116891: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
116895: LD_VAR 0 4
116899: NOT
116900: PUSH
116901: LD_VAR 0 4
116905: PUSH
116906: EMPTY
116907: EQUAL
116908: OR
116909: PUSH
116910: LD_INT 81
116912: PUSH
116913: LD_VAR 0 35
116917: PUSH
116918: EMPTY
116919: LIST
116920: LIST
116921: PPUSH
116922: CALL_OW 69
116926: NOT
116927: OR
116928: IFFALSE 112748
// end ;
116930: LD_VAR 0 2
116934: RET
// export function BasicDefend ( base , solds ) ; var enemy , e , side , i , hex ; begin
116935: LD_INT 0
116937: PPUSH
116938: PPUSH
116939: PPUSH
116940: PPUSH
116941: PPUSH
116942: PPUSH
// if not base or not mc_bases [ base ] or not solds then
116943: LD_VAR 0 1
116947: NOT
116948: PUSH
116949: LD_EXP 31
116953: PUSH
116954: LD_VAR 0 1
116958: ARRAY
116959: NOT
116960: OR
116961: PUSH
116962: LD_VAR 0 2
116966: NOT
116967: OR
116968: IFFALSE 116972
// exit ;
116970: GO 117526
// side := mc_sides [ base ] ;
116972: LD_ADDR_VAR 0 6
116976: PUSH
116977: LD_EXP 57
116981: PUSH
116982: LD_VAR 0 1
116986: ARRAY
116987: ST_TO_ADDR
// if not side then
116988: LD_VAR 0 6
116992: NOT
116993: IFFALSE 116997
// exit ;
116995: GO 117526
// for i in solds do
116997: LD_ADDR_VAR 0 7
117001: PUSH
117002: LD_VAR 0 2
117006: PUSH
117007: FOR_IN
117008: IFFALSE 117069
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
117010: LD_VAR 0 7
117014: PPUSH
117015: CALL_OW 310
117019: PPUSH
117020: CALL_OW 266
117024: PUSH
117025: LD_INT 32
117027: PUSH
117028: LD_INT 31
117030: PUSH
117031: EMPTY
117032: LIST
117033: LIST
117034: IN
117035: IFFALSE 117055
// solds := solds diff i else
117037: LD_ADDR_VAR 0 2
117041: PUSH
117042: LD_VAR 0 2
117046: PUSH
117047: LD_VAR 0 7
117051: DIFF
117052: ST_TO_ADDR
117053: GO 117067
// SetTag ( i , 18 ) ;
117055: LD_VAR 0 7
117059: PPUSH
117060: LD_INT 18
117062: PPUSH
117063: CALL_OW 109
117067: GO 117007
117069: POP
117070: POP
// if not solds then
117071: LD_VAR 0 2
117075: NOT
117076: IFFALSE 117080
// exit ;
117078: GO 117526
// repeat wait ( 0 0$2 ) ;
117080: LD_INT 70
117082: PPUSH
117083: CALL_OW 67
// enemy := mc_scan [ base ] ;
117087: LD_ADDR_VAR 0 4
117091: PUSH
117092: LD_EXP 54
117096: PUSH
117097: LD_VAR 0 1
117101: ARRAY
117102: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
117103: LD_EXP 31
117107: PUSH
117108: LD_VAR 0 1
117112: ARRAY
117113: NOT
117114: PUSH
117115: LD_EXP 31
117119: PUSH
117120: LD_VAR 0 1
117124: ARRAY
117125: PUSH
117126: EMPTY
117127: EQUAL
117128: OR
117129: IFFALSE 117166
// begin for i in solds do
117131: LD_ADDR_VAR 0 7
117135: PUSH
117136: LD_VAR 0 2
117140: PUSH
117141: FOR_IN
117142: IFFALSE 117155
// ComStop ( i ) ;
117144: LD_VAR 0 7
117148: PPUSH
117149: CALL_OW 141
117153: GO 117141
117155: POP
117156: POP
// solds := [ ] ;
117157: LD_ADDR_VAR 0 2
117161: PUSH
117162: EMPTY
117163: ST_TO_ADDR
// exit ;
117164: GO 117526
// end ; for i in solds do
117166: LD_ADDR_VAR 0 7
117170: PUSH
117171: LD_VAR 0 2
117175: PUSH
117176: FOR_IN
117177: IFFALSE 117498
// begin if IsInUnit ( i ) then
117179: LD_VAR 0 7
117183: PPUSH
117184: CALL_OW 310
117188: IFFALSE 117199
// ComExitBuilding ( i ) ;
117190: LD_VAR 0 7
117194: PPUSH
117195: CALL_OW 122
// if GetLives ( i ) > 500 then
117199: LD_VAR 0 7
117203: PPUSH
117204: CALL_OW 256
117208: PUSH
117209: LD_INT 500
117211: GREATER
117212: IFFALSE 117265
// begin e := NearestUnitToUnit ( enemy , i ) ;
117214: LD_ADDR_VAR 0 5
117218: PUSH
117219: LD_VAR 0 4
117223: PPUSH
117224: LD_VAR 0 7
117228: PPUSH
117229: CALL_OW 74
117233: ST_TO_ADDR
// ComAgressiveMove ( i , GetX ( e ) , GetY ( e ) ) ;
117234: LD_VAR 0 7
117238: PPUSH
117239: LD_VAR 0 5
117243: PPUSH
117244: CALL_OW 250
117248: PPUSH
117249: LD_VAR 0 5
117253: PPUSH
117254: CALL_OW 251
117258: PPUSH
117259: CALL_OW 114
// end else
117263: GO 117496
// if GetDistUnits ( i , NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ) > 10 then
117265: LD_VAR 0 7
117269: PPUSH
117270: LD_EXP 31
117274: PUSH
117275: LD_VAR 0 1
117279: ARRAY
117280: PPUSH
117281: LD_INT 2
117283: PUSH
117284: LD_INT 30
117286: PUSH
117287: LD_INT 0
117289: PUSH
117290: EMPTY
117291: LIST
117292: LIST
117293: PUSH
117294: LD_INT 30
117296: PUSH
117297: LD_INT 1
117299: PUSH
117300: EMPTY
117301: LIST
117302: LIST
117303: PUSH
117304: LD_INT 30
117306: PUSH
117307: LD_INT 6
117309: PUSH
117310: EMPTY
117311: LIST
117312: LIST
117313: PUSH
117314: EMPTY
117315: LIST
117316: LIST
117317: LIST
117318: LIST
117319: PPUSH
117320: CALL_OW 72
117324: PPUSH
117325: LD_VAR 0 7
117329: PPUSH
117330: CALL_OW 74
117334: PPUSH
117335: CALL_OW 296
117339: PUSH
117340: LD_INT 10
117342: GREATER
117343: IFFALSE 117496
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
117345: LD_ADDR_VAR 0 8
117349: PUSH
117350: LD_EXP 31
117354: PUSH
117355: LD_VAR 0 1
117359: ARRAY
117360: PPUSH
117361: LD_INT 2
117363: PUSH
117364: LD_INT 30
117366: PUSH
117367: LD_INT 0
117369: PUSH
117370: EMPTY
117371: LIST
117372: LIST
117373: PUSH
117374: LD_INT 30
117376: PUSH
117377: LD_INT 1
117379: PUSH
117380: EMPTY
117381: LIST
117382: LIST
117383: PUSH
117384: LD_INT 30
117386: PUSH
117387: LD_INT 6
117389: PUSH
117390: EMPTY
117391: LIST
117392: LIST
117393: PUSH
117394: EMPTY
117395: LIST
117396: LIST
117397: LIST
117398: LIST
117399: PPUSH
117400: CALL_OW 72
117404: PPUSH
117405: LD_VAR 0 7
117409: PPUSH
117410: CALL_OW 74
117414: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
117415: LD_VAR 0 7
117419: PPUSH
117420: LD_VAR 0 8
117424: PPUSH
117425: CALL_OW 250
117429: PPUSH
117430: LD_INT 3
117432: PPUSH
117433: LD_INT 5
117435: PPUSH
117436: CALL_OW 272
117440: PPUSH
117441: LD_VAR 0 8
117445: PPUSH
117446: CALL_OW 251
117450: PPUSH
117451: LD_INT 3
117453: PPUSH
117454: LD_INT 5
117456: PPUSH
117457: CALL_OW 273
117461: PPUSH
117462: CALL_OW 111
// SetTag ( i , 0 ) ;
117466: LD_VAR 0 7
117470: PPUSH
117471: LD_INT 0
117473: PPUSH
117474: CALL_OW 109
// solds := solds diff i ;
117478: LD_ADDR_VAR 0 2
117482: PUSH
117483: LD_VAR 0 2
117487: PUSH
117488: LD_VAR 0 7
117492: DIFF
117493: ST_TO_ADDR
// continue ;
117494: GO 117176
// end ; end ;
117496: GO 117176
117498: POP
117499: POP
// until not solds or not enemy ;
117500: LD_VAR 0 2
117504: NOT
117505: PUSH
117506: LD_VAR 0 4
117510: NOT
117511: OR
117512: IFFALSE 117080
// MC_Reset ( base , 18 ) ;
117514: LD_VAR 0 1
117518: PPUSH
117519: LD_INT 18
117521: PPUSH
117522: CALL 65596 0 2
// end ;
117526: LD_VAR 0 3
117530: RET
// export function Defend ( base , defenders ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend , class , enemy ; begin
117531: LD_INT 0
117533: PPUSH
117534: PPUSH
117535: PPUSH
117536: PPUSH
117537: PPUSH
117538: PPUSH
117539: PPUSH
117540: PPUSH
117541: PPUSH
117542: PPUSH
117543: PPUSH
117544: PPUSH
117545: PPUSH
117546: PPUSH
117547: PPUSH
117548: PPUSH
117549: PPUSH
117550: PPUSH
117551: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
117552: LD_ADDR_VAR 0 12
117556: PUSH
117557: LD_EXP 31
117561: PUSH
117562: LD_VAR 0 1
117566: ARRAY
117567: PPUSH
117568: LD_INT 25
117570: PUSH
117571: LD_INT 3
117573: PUSH
117574: EMPTY
117575: LIST
117576: LIST
117577: PPUSH
117578: CALL_OW 72
117582: ST_TO_ADDR
// if mc_remote_driver [ base ] then
117583: LD_EXP 71
117587: PUSH
117588: LD_VAR 0 1
117592: ARRAY
117593: IFFALSE 117617
// mechs := mechs diff mc_remote_driver [ base ] ;
117595: LD_ADDR_VAR 0 12
117599: PUSH
117600: LD_VAR 0 12
117604: PUSH
117605: LD_EXP 71
117609: PUSH
117610: LD_VAR 0 1
117614: ARRAY
117615: DIFF
117616: ST_TO_ADDR
// for i in mechs do
117617: LD_ADDR_VAR 0 4
117621: PUSH
117622: LD_VAR 0 12
117626: PUSH
117627: FOR_IN
117628: IFFALSE 117663
// if GetTag ( i ) > 0 then
117630: LD_VAR 0 4
117634: PPUSH
117635: CALL_OW 110
117639: PUSH
117640: LD_INT 0
117642: GREATER
117643: IFFALSE 117661
// mechs := mechs diff i ;
117645: LD_ADDR_VAR 0 12
117649: PUSH
117650: LD_VAR 0 12
117654: PUSH
117655: LD_VAR 0 4
117659: DIFF
117660: ST_TO_ADDR
117661: GO 117627
117663: POP
117664: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
117665: LD_ADDR_VAR 0 8
117669: PUSH
117670: LD_EXP 31
117674: PUSH
117675: LD_VAR 0 1
117679: ARRAY
117680: PPUSH
117681: LD_INT 2
117683: PUSH
117684: LD_INT 25
117686: PUSH
117687: LD_INT 1
117689: PUSH
117690: EMPTY
117691: LIST
117692: LIST
117693: PUSH
117694: LD_INT 25
117696: PUSH
117697: LD_INT 5
117699: PUSH
117700: EMPTY
117701: LIST
117702: LIST
117703: PUSH
117704: LD_INT 25
117706: PUSH
117707: LD_INT 8
117709: PUSH
117710: EMPTY
117711: LIST
117712: LIST
117713: PUSH
117714: LD_INT 25
117716: PUSH
117717: LD_INT 9
117719: PUSH
117720: EMPTY
117721: LIST
117722: LIST
117723: PUSH
117724: EMPTY
117725: LIST
117726: LIST
117727: LIST
117728: LIST
117729: LIST
117730: PPUSH
117731: CALL_OW 72
117735: ST_TO_ADDR
// if not defenders and not solds then
117736: LD_VAR 0 2
117740: NOT
117741: PUSH
117742: LD_VAR 0 8
117746: NOT
117747: AND
117748: IFFALSE 117752
// exit ;
117750: GO 119522
// depot_under_attack := false ;
117752: LD_ADDR_VAR 0 16
117756: PUSH
117757: LD_INT 0
117759: ST_TO_ADDR
// sold_defenders := [ ] ;
117760: LD_ADDR_VAR 0 17
117764: PUSH
117765: EMPTY
117766: ST_TO_ADDR
// if mechs then
117767: LD_VAR 0 12
117771: IFFALSE 117924
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
117773: LD_ADDR_VAR 0 4
117777: PUSH
117778: LD_VAR 0 2
117782: PPUSH
117783: LD_INT 21
117785: PUSH
117786: LD_INT 2
117788: PUSH
117789: EMPTY
117790: LIST
117791: LIST
117792: PPUSH
117793: CALL_OW 72
117797: PUSH
117798: FOR_IN
117799: IFFALSE 117922
// begin if GetTag ( i ) <> 20 then
117801: LD_VAR 0 4
117805: PPUSH
117806: CALL_OW 110
117810: PUSH
117811: LD_INT 20
117813: NONEQUAL
117814: IFFALSE 117828
// SetTag ( i , 20 ) ;
117816: LD_VAR 0 4
117820: PPUSH
117821: LD_INT 20
117823: PPUSH
117824: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
117828: LD_VAR 0 4
117832: PPUSH
117833: CALL_OW 263
117837: PUSH
117838: LD_INT 1
117840: EQUAL
117841: PUSH
117842: LD_VAR 0 4
117846: PPUSH
117847: CALL_OW 311
117851: NOT
117852: AND
117853: IFFALSE 117920
// begin un := mechs [ 1 ] ;
117855: LD_ADDR_VAR 0 10
117859: PUSH
117860: LD_VAR 0 12
117864: PUSH
117865: LD_INT 1
117867: ARRAY
117868: ST_TO_ADDR
// ComExit ( un ) ;
117869: LD_VAR 0 10
117873: PPUSH
117874: CALL 57603 0 1
// AddComEnterUnit ( un , i ) ;
117878: LD_VAR 0 10
117882: PPUSH
117883: LD_VAR 0 4
117887: PPUSH
117888: CALL_OW 180
// SetTag ( un , 19 ) ;
117892: LD_VAR 0 10
117896: PPUSH
117897: LD_INT 19
117899: PPUSH
117900: CALL_OW 109
// mechs := mechs diff un ;
117904: LD_ADDR_VAR 0 12
117908: PUSH
117909: LD_VAR 0 12
117913: PUSH
117914: LD_VAR 0 10
117918: DIFF
117919: ST_TO_ADDR
// end ; end ;
117920: GO 117798
117922: POP
117923: POP
// if solds then
117924: LD_VAR 0 8
117928: IFFALSE 117987
// for i in solds do
117930: LD_ADDR_VAR 0 4
117934: PUSH
117935: LD_VAR 0 8
117939: PUSH
117940: FOR_IN
117941: IFFALSE 117985
// if not GetTag ( i ) then
117943: LD_VAR 0 4
117947: PPUSH
117948: CALL_OW 110
117952: NOT
117953: IFFALSE 117983
// begin defenders := defenders union i ;
117955: LD_ADDR_VAR 0 2
117959: PUSH
117960: LD_VAR 0 2
117964: PUSH
117965: LD_VAR 0 4
117969: UNION
117970: ST_TO_ADDR
// SetTag ( i , 18 ) ;
117971: LD_VAR 0 4
117975: PPUSH
117976: LD_INT 18
117978: PPUSH
117979: CALL_OW 109
// end ;
117983: GO 117940
117985: POP
117986: POP
// repeat wait ( 0 0$2 ) ;
117987: LD_INT 70
117989: PPUSH
117990: CALL_OW 67
// enemy := mc_scan [ base ] ;
117994: LD_ADDR_VAR 0 21
117998: PUSH
117999: LD_EXP 54
118003: PUSH
118004: LD_VAR 0 1
118008: ARRAY
118009: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
118010: LD_EXP 31
118014: PUSH
118015: LD_VAR 0 1
118019: ARRAY
118020: NOT
118021: PUSH
118022: LD_EXP 31
118026: PUSH
118027: LD_VAR 0 1
118031: ARRAY
118032: PUSH
118033: EMPTY
118034: EQUAL
118035: OR
118036: IFFALSE 118073
// begin for i in defenders do
118038: LD_ADDR_VAR 0 4
118042: PUSH
118043: LD_VAR 0 2
118047: PUSH
118048: FOR_IN
118049: IFFALSE 118062
// ComStop ( i ) ;
118051: LD_VAR 0 4
118055: PPUSH
118056: CALL_OW 141
118060: GO 118048
118062: POP
118063: POP
// defenders := [ ] ;
118064: LD_ADDR_VAR 0 2
118068: PUSH
118069: EMPTY
118070: ST_TO_ADDR
// exit ;
118071: GO 119522
// end ; for i in defenders do
118073: LD_ADDR_VAR 0 4
118077: PUSH
118078: LD_VAR 0 2
118082: PUSH
118083: FOR_IN
118084: IFFALSE 118982
// begin e := NearestUnitToUnit ( enemy , i ) ;
118086: LD_ADDR_VAR 0 13
118090: PUSH
118091: LD_VAR 0 21
118095: PPUSH
118096: LD_VAR 0 4
118100: PPUSH
118101: CALL_OW 74
118105: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
118106: LD_ADDR_VAR 0 7
118110: PUSH
118111: LD_EXP 31
118115: PUSH
118116: LD_VAR 0 1
118120: ARRAY
118121: PPUSH
118122: LD_INT 2
118124: PUSH
118125: LD_INT 30
118127: PUSH
118128: LD_INT 0
118130: PUSH
118131: EMPTY
118132: LIST
118133: LIST
118134: PUSH
118135: LD_INT 30
118137: PUSH
118138: LD_INT 1
118140: PUSH
118141: EMPTY
118142: LIST
118143: LIST
118144: PUSH
118145: EMPTY
118146: LIST
118147: LIST
118148: LIST
118149: PPUSH
118150: CALL_OW 72
118154: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
118155: LD_ADDR_VAR 0 16
118159: PUSH
118160: LD_VAR 0 7
118164: NOT
118165: PUSH
118166: LD_VAR 0 7
118170: PPUSH
118171: LD_INT 3
118173: PUSH
118174: LD_INT 24
118176: PUSH
118177: LD_INT 600
118179: PUSH
118180: EMPTY
118181: LIST
118182: LIST
118183: PUSH
118184: EMPTY
118185: LIST
118186: LIST
118187: PPUSH
118188: CALL_OW 72
118192: OR
118193: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
118194: LD_VAR 0 4
118198: PPUSH
118199: CALL_OW 247
118203: PUSH
118204: LD_INT 2
118206: DOUBLE
118207: EQUAL
118208: IFTRUE 118212
118210: GO 118608
118212: POP
// begin if GetLives ( i ) = 1000 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
118213: LD_VAR 0 4
118217: PPUSH
118218: CALL_OW 256
118222: PUSH
118223: LD_INT 1000
118225: EQUAL
118226: PUSH
118227: LD_VAR 0 4
118231: PPUSH
118232: LD_VAR 0 13
118236: PPUSH
118237: CALL_OW 296
118241: PUSH
118242: LD_INT 40
118244: LESS
118245: PUSH
118246: LD_VAR 0 13
118250: PPUSH
118251: LD_EXP 56
118255: PUSH
118256: LD_VAR 0 1
118260: ARRAY
118261: PPUSH
118262: CALL_OW 308
118266: OR
118267: AND
118268: IFFALSE 118390
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
118270: LD_VAR 0 4
118274: PPUSH
118275: CALL_OW 262
118279: PUSH
118280: LD_INT 1
118282: EQUAL
118283: PUSH
118284: LD_VAR 0 4
118288: PPUSH
118289: CALL_OW 261
118293: PUSH
118294: LD_INT 30
118296: LESS
118297: AND
118298: PUSH
118299: LD_VAR 0 7
118303: AND
118304: IFFALSE 118374
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
118306: LD_VAR 0 4
118310: PPUSH
118311: LD_VAR 0 7
118315: PPUSH
118316: LD_VAR 0 4
118320: PPUSH
118321: CALL_OW 74
118325: PPUSH
118326: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
118330: LD_VAR 0 4
118334: PPUSH
118335: LD_VAR 0 7
118339: PPUSH
118340: LD_VAR 0 4
118344: PPUSH
118345: CALL_OW 74
118349: PPUSH
118350: CALL_OW 296
118354: PUSH
118355: LD_INT 6
118357: LESS
118358: IFFALSE 118372
// SetFuel ( i , 100 ) ;
118360: LD_VAR 0 4
118364: PPUSH
118365: LD_INT 100
118367: PPUSH
118368: CALL_OW 240
// end else
118372: GO 118388
// ComAttackUnit ( i , e ) ;
118374: LD_VAR 0 4
118378: PPUSH
118379: LD_VAR 0 13
118383: PPUSH
118384: CALL_OW 115
// end else
118388: GO 118491
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
118390: LD_VAR 0 13
118394: PPUSH
118395: LD_EXP 56
118399: PUSH
118400: LD_VAR 0 1
118404: ARRAY
118405: PPUSH
118406: CALL_OW 308
118410: NOT
118411: PUSH
118412: LD_VAR 0 4
118416: PPUSH
118417: LD_VAR 0 13
118421: PPUSH
118422: CALL_OW 296
118426: PUSH
118427: LD_INT 40
118429: GREATEREQUAL
118430: AND
118431: PUSH
118432: LD_VAR 0 4
118436: PPUSH
118437: CALL_OW 256
118441: PUSH
118442: LD_INT 650
118444: LESSEQUAL
118445: OR
118446: PUSH
118447: LD_VAR 0 4
118451: PPUSH
118452: LD_EXP 55
118456: PUSH
118457: LD_VAR 0 1
118461: ARRAY
118462: PPUSH
118463: CALL_OW 308
118467: NOT
118468: AND
118469: IFFALSE 118491
// ComMoveToArea ( i , mc_parking [ base ] ) ;
118471: LD_VAR 0 4
118475: PPUSH
118476: LD_EXP 55
118480: PUSH
118481: LD_VAR 0 1
118485: ARRAY
118486: PPUSH
118487: CALL_OW 113
// if GetLives ( i ) < 1000 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
118491: LD_VAR 0 4
118495: PPUSH
118496: CALL_OW 256
118500: PUSH
118501: LD_INT 1000
118503: LESS
118504: PUSH
118505: LD_VAR 0 4
118509: PPUSH
118510: CALL_OW 263
118514: PUSH
118515: LD_INT 1
118517: EQUAL
118518: AND
118519: PUSH
118520: LD_VAR 0 4
118524: PPUSH
118525: CALL_OW 311
118529: AND
118530: PUSH
118531: LD_VAR 0 4
118535: PPUSH
118536: LD_EXP 55
118540: PUSH
118541: LD_VAR 0 1
118545: ARRAY
118546: PPUSH
118547: CALL_OW 308
118551: AND
118552: IFFALSE 118606
// begin mech := IsDrivenBy ( i ) ;
118554: LD_ADDR_VAR 0 9
118558: PUSH
118559: LD_VAR 0 4
118563: PPUSH
118564: CALL_OW 311
118568: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
118569: LD_VAR 0 9
118573: PPUSH
118574: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
118578: LD_VAR 0 9
118582: PPUSH
118583: LD_VAR 0 4
118587: PPUSH
118588: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
118592: LD_VAR 0 9
118596: PPUSH
118597: LD_VAR 0 4
118601: PPUSH
118602: CALL_OW 180
// end ; end ; unit_human :
118606: GO 118953
118608: LD_INT 1
118610: DOUBLE
118611: EQUAL
118612: IFTRUE 118616
118614: GO 118952
118616: POP
// begin b := IsInUnit ( i ) ;
118617: LD_ADDR_VAR 0 18
118621: PUSH
118622: LD_VAR 0 4
118626: PPUSH
118627: CALL_OW 310
118631: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
118632: LD_ADDR_VAR 0 19
118636: PUSH
118637: LD_VAR 0 18
118641: NOT
118642: PUSH
118643: LD_VAR 0 18
118647: PPUSH
118648: CALL_OW 266
118652: PUSH
118653: LD_INT 32
118655: PUSH
118656: LD_INT 31
118658: PUSH
118659: EMPTY
118660: LIST
118661: LIST
118662: IN
118663: OR
118664: ST_TO_ADDR
// if GetBType ( b ) = b_barracks and GetClass ( i ) in [ 1 , 2 , 3 , 4 ] then
118665: LD_VAR 0 18
118669: PPUSH
118670: CALL_OW 266
118674: PUSH
118675: LD_INT 5
118677: EQUAL
118678: PUSH
118679: LD_VAR 0 4
118683: PPUSH
118684: CALL_OW 257
118688: PUSH
118689: LD_INT 1
118691: PUSH
118692: LD_INT 2
118694: PUSH
118695: LD_INT 3
118697: PUSH
118698: LD_INT 4
118700: PUSH
118701: EMPTY
118702: LIST
118703: LIST
118704: LIST
118705: LIST
118706: IN
118707: AND
118708: IFFALSE 118745
// begin class := AllowSpecClass ( i ) ;
118710: LD_ADDR_VAR 0 20
118714: PUSH
118715: LD_VAR 0 4
118719: PPUSH
118720: CALL 21670 0 1
118724: ST_TO_ADDR
// if class then
118725: LD_VAR 0 20
118729: IFFALSE 118745
// ComChangeProfession ( i , class ) ;
118731: LD_VAR 0 4
118735: PPUSH
118736: LD_VAR 0 20
118740: PPUSH
118741: CALL_OW 123
// end ; if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
118745: LD_VAR 0 16
118749: PUSH
118750: LD_VAR 0 2
118754: PPUSH
118755: LD_INT 21
118757: PUSH
118758: LD_INT 2
118760: PUSH
118761: EMPTY
118762: LIST
118763: LIST
118764: PPUSH
118765: CALL_OW 72
118769: PUSH
118770: LD_INT 1
118772: LESSEQUAL
118773: OR
118774: PUSH
118775: LD_VAR 0 19
118779: AND
118780: PUSH
118781: LD_VAR 0 4
118785: PUSH
118786: LD_VAR 0 17
118790: IN
118791: NOT
118792: AND
118793: IFFALSE 118886
// begin if b then
118795: LD_VAR 0 18
118799: IFFALSE 118848
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
118801: LD_VAR 0 18
118805: PPUSH
118806: LD_VAR 0 21
118810: PPUSH
118811: LD_VAR 0 18
118815: PPUSH
118816: CALL_OW 74
118820: PPUSH
118821: CALL_OW 296
118825: PUSH
118826: LD_INT 10
118828: LESS
118829: PUSH
118830: LD_VAR 0 18
118834: PPUSH
118835: CALL_OW 461
118839: PUSH
118840: LD_INT 7
118842: NONEQUAL
118843: AND
118844: IFFALSE 118848
// continue ;
118846: GO 118083
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
118848: LD_ADDR_VAR 0 17
118852: PUSH
118853: LD_VAR 0 17
118857: PPUSH
118858: LD_VAR 0 17
118862: PUSH
118863: LD_INT 1
118865: PLUS
118866: PPUSH
118867: LD_VAR 0 4
118871: PPUSH
118872: CALL_OW 1
118876: ST_TO_ADDR
// ComExitBuilding ( i ) ;
118877: LD_VAR 0 4
118881: PPUSH
118882: CALL_OW 122
// end ; if sold_defenders then
118886: LD_VAR 0 17
118890: IFFALSE 118950
// if i in sold_defenders then
118892: LD_VAR 0 4
118896: PUSH
118897: LD_VAR 0 17
118901: IN
118902: IFFALSE 118950
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
118904: LD_VAR 0 4
118908: PPUSH
118909: CALL_OW 314
118913: NOT
118914: PUSH
118915: LD_VAR 0 4
118919: PPUSH
118920: LD_VAR 0 13
118924: PPUSH
118925: CALL_OW 296
118929: PUSH
118930: LD_INT 30
118932: LESS
118933: AND
118934: IFFALSE 118950
// ComAttackUnit ( i , e ) ;
118936: LD_VAR 0 4
118940: PPUSH
118941: LD_VAR 0 13
118945: PPUSH
118946: CALL_OW 115
// end ; end ; end ;
118950: GO 118953
118952: POP
// if IsDead ( i ) then
118953: LD_VAR 0 4
118957: PPUSH
118958: CALL_OW 301
118962: IFFALSE 118980
// defenders := defenders diff i ;
118964: LD_ADDR_VAR 0 2
118968: PUSH
118969: LD_VAR 0 2
118973: PUSH
118974: LD_VAR 0 4
118978: DIFF
118979: ST_TO_ADDR
// end ;
118980: GO 118083
118982: POP
118983: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
118984: LD_VAR 0 21
118988: NOT
118989: PUSH
118990: LD_VAR 0 2
118994: NOT
118995: OR
118996: PUSH
118997: LD_EXP 31
119001: PUSH
119002: LD_VAR 0 1
119006: ARRAY
119007: NOT
119008: OR
119009: IFFALSE 117987
// MC_Reset ( base , 18 ) ;
119011: LD_VAR 0 1
119015: PPUSH
119016: LD_INT 18
119018: PPUSH
119019: CALL 65596 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
119023: LD_ADDR_VAR 0 2
119027: PUSH
119028: LD_VAR 0 2
119032: PUSH
119033: LD_VAR 0 2
119037: PPUSH
119038: LD_INT 2
119040: PUSH
119041: LD_INT 25
119043: PUSH
119044: LD_INT 1
119046: PUSH
119047: EMPTY
119048: LIST
119049: LIST
119050: PUSH
119051: LD_INT 25
119053: PUSH
119054: LD_INT 5
119056: PUSH
119057: EMPTY
119058: LIST
119059: LIST
119060: PUSH
119061: LD_INT 25
119063: PUSH
119064: LD_INT 8
119066: PUSH
119067: EMPTY
119068: LIST
119069: LIST
119070: PUSH
119071: LD_INT 25
119073: PUSH
119074: LD_INT 9
119076: PUSH
119077: EMPTY
119078: LIST
119079: LIST
119080: PUSH
119081: EMPTY
119082: LIST
119083: LIST
119084: LIST
119085: LIST
119086: LIST
119087: PPUSH
119088: CALL_OW 72
119092: DIFF
119093: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
119094: LD_VAR 0 21
119098: NOT
119099: PUSH
119100: LD_VAR 0 2
119104: PPUSH
119105: LD_INT 21
119107: PUSH
119108: LD_INT 2
119110: PUSH
119111: EMPTY
119112: LIST
119113: LIST
119114: PPUSH
119115: CALL_OW 72
119119: AND
119120: IFFALSE 119458
// begin tmp := FilterByTag ( defenders , 19 ) ;
119122: LD_ADDR_VAR 0 11
119126: PUSH
119127: LD_VAR 0 2
119131: PPUSH
119132: LD_INT 19
119134: PPUSH
119135: CALL 54787 0 2
119139: ST_TO_ADDR
// if tmp then
119140: LD_VAR 0 11
119144: IFFALSE 119214
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
119146: LD_ADDR_VAR 0 11
119150: PUSH
119151: LD_VAR 0 11
119155: PPUSH
119156: LD_INT 25
119158: PUSH
119159: LD_INT 3
119161: PUSH
119162: EMPTY
119163: LIST
119164: LIST
119165: PPUSH
119166: CALL_OW 72
119170: ST_TO_ADDR
// if tmp then
119171: LD_VAR 0 11
119175: IFFALSE 119214
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
119177: LD_ADDR_EXP 43
119181: PUSH
119182: LD_EXP 43
119186: PPUSH
119187: LD_VAR 0 1
119191: PPUSH
119192: LD_EXP 43
119196: PUSH
119197: LD_VAR 0 1
119201: ARRAY
119202: PUSH
119203: LD_VAR 0 11
119207: UNION
119208: PPUSH
119209: CALL_OW 1
119213: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
119214: LD_VAR 0 1
119218: PPUSH
119219: LD_INT 19
119221: PPUSH
119222: CALL 65596 0 2
// repeat wait ( 0 0$1 ) ;
119226: LD_INT 35
119228: PPUSH
119229: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
119233: LD_EXP 31
119237: PUSH
119238: LD_VAR 0 1
119242: ARRAY
119243: NOT
119244: PUSH
119245: LD_EXP 31
119249: PUSH
119250: LD_VAR 0 1
119254: ARRAY
119255: PUSH
119256: EMPTY
119257: EQUAL
119258: OR
119259: IFFALSE 119296
// begin for i in defenders do
119261: LD_ADDR_VAR 0 4
119265: PUSH
119266: LD_VAR 0 2
119270: PUSH
119271: FOR_IN
119272: IFFALSE 119285
// ComStop ( i ) ;
119274: LD_VAR 0 4
119278: PPUSH
119279: CALL_OW 141
119283: GO 119271
119285: POP
119286: POP
// defenders := [ ] ;
119287: LD_ADDR_VAR 0 2
119291: PUSH
119292: EMPTY
119293: ST_TO_ADDR
// exit ;
119294: GO 119522
// end ; for i in defenders do
119296: LD_ADDR_VAR 0 4
119300: PUSH
119301: LD_VAR 0 2
119305: PUSH
119306: FOR_IN
119307: IFFALSE 119396
// begin if not IsInArea ( i , mc_parking [ base ] ) then
119309: LD_VAR 0 4
119313: PPUSH
119314: LD_EXP 55
119318: PUSH
119319: LD_VAR 0 1
119323: ARRAY
119324: PPUSH
119325: CALL_OW 308
119329: NOT
119330: IFFALSE 119354
// ComMoveToArea ( i , mc_parking [ base ] ) else
119332: LD_VAR 0 4
119336: PPUSH
119337: LD_EXP 55
119341: PUSH
119342: LD_VAR 0 1
119346: ARRAY
119347: PPUSH
119348: CALL_OW 113
119352: GO 119394
// if GetControl ( i ) = control_manual then
119354: LD_VAR 0 4
119358: PPUSH
119359: CALL_OW 263
119363: PUSH
119364: LD_INT 1
119366: EQUAL
119367: IFFALSE 119394
// if IsDrivenBy ( i ) then
119369: LD_VAR 0 4
119373: PPUSH
119374: CALL_OW 311
119378: IFFALSE 119394
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
119380: LD_VAR 0 4
119384: PPUSH
119385: CALL_OW 311
119389: PPUSH
119390: CALL_OW 121
// end ;
119394: GO 119306
119396: POP
119397: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
119398: LD_VAR 0 2
119402: PPUSH
119403: LD_INT 95
119405: PUSH
119406: LD_EXP 55
119410: PUSH
119411: LD_VAR 0 1
119415: ARRAY
119416: PUSH
119417: EMPTY
119418: LIST
119419: LIST
119420: PPUSH
119421: CALL_OW 72
119425: PUSH
119426: LD_VAR 0 2
119430: EQUAL
119431: PUSH
119432: LD_EXP 54
119436: PUSH
119437: LD_VAR 0 1
119441: ARRAY
119442: OR
119443: PUSH
119444: LD_EXP 31
119448: PUSH
119449: LD_VAR 0 1
119453: ARRAY
119454: NOT
119455: OR
119456: IFFALSE 119226
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
119458: LD_ADDR_EXP 53
119462: PUSH
119463: LD_EXP 53
119467: PPUSH
119468: LD_VAR 0 1
119472: PPUSH
119473: LD_VAR 0 2
119477: PPUSH
119478: LD_INT 21
119480: PUSH
119481: LD_INT 2
119483: PUSH
119484: EMPTY
119485: LIST
119486: LIST
119487: PPUSH
119488: CALL_OW 72
119492: PPUSH
119493: CALL_OW 1
119497: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
119498: LD_VAR 0 1
119502: PPUSH
119503: LD_INT 19
119505: PPUSH
119506: CALL 65596 0 2
// MC_Reset ( base , 20 ) ;
119510: LD_VAR 0 1
119514: PPUSH
119515: LD_INT 20
119517: PPUSH
119518: CALL 65596 0 2
// end ; end_of_file
119522: LD_VAR 0 3
119526: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
119527: LD_VAR 0 1
119531: PUSH
119532: LD_INT 200
119534: DOUBLE
119535: GREATEREQUAL
119536: IFFALSE 119544
119538: LD_INT 299
119540: DOUBLE
119541: LESSEQUAL
119542: IFTRUE 119546
119544: GO 119578
119546: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
119547: LD_VAR 0 1
119551: PPUSH
119552: LD_VAR 0 2
119556: PPUSH
119557: LD_VAR 0 3
119561: PPUSH
119562: LD_VAR 0 4
119566: PPUSH
119567: LD_VAR 0 5
119571: PPUSH
119572: CALL 108313 0 5
119576: GO 119655
119578: LD_INT 300
119580: DOUBLE
119581: GREATEREQUAL
119582: IFFALSE 119590
119584: LD_INT 399
119586: DOUBLE
119587: LESSEQUAL
119588: IFTRUE 119592
119590: GO 119654
119592: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
119593: LD_VAR 0 1
119597: PPUSH
119598: LD_VAR 0 2
119602: PPUSH
119603: LD_VAR 0 3
119607: PPUSH
119608: LD_VAR 0 4
119612: PPUSH
119613: LD_VAR 0 5
119617: PPUSH
119618: LD_VAR 0 6
119622: PPUSH
119623: LD_VAR 0 7
119627: PPUSH
119628: LD_VAR 0 8
119632: PPUSH
119633: LD_VAR 0 9
119637: PPUSH
119638: LD_VAR 0 10
119642: PPUSH
119643: LD_VAR 0 11
119647: PPUSH
119648: CALL 104638 0 11
119652: GO 119655
119654: POP
// end ;
119655: PPOPN 11
119657: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
119658: LD_VAR 0 1
119662: PPUSH
119663: LD_VAR 0 2
119667: PPUSH
119668: LD_VAR 0 3
119672: PPUSH
119673: LD_VAR 0 4
119677: PPUSH
119678: LD_VAR 0 5
119682: PPUSH
119683: CALL 108049 0 5
// end ; end_of_file
119687: PPOPN 5
119689: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ;
119690: LD_VAR 0 1
119694: PPUSH
119695: LD_VAR 0 2
119699: PPUSH
119700: LD_VAR 0 3
119704: PPUSH
119705: LD_VAR 0 4
119709: PPUSH
119710: LD_VAR 0 5
119714: PPUSH
119715: LD_VAR 0 6
119719: PPUSH
119720: CALL 92290 0 6
// end ;
119724: PPOPN 6
119726: END
// on CommPanelCommand ( units , p1 , p2 , p3 , p4 , p5 ) do var i ;
119727: LD_INT 0
119729: PPUSH
// begin if not units then
119730: LD_VAR 0 1
119734: NOT
119735: IFFALSE 119739
// exit ;
119737: GO 119739
// end ;
119739: PPOPN 7
119741: END
// on MapStart ( p ) do begin SOS_MapStart ( ) ;
119742: CALL 92194 0 0
// end ;
119746: PPOPN 1
119748: END
