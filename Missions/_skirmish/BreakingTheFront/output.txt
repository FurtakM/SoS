// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// InitSettings ;
  11: CALL 51 0 0
// if debug then
  15: LD_EXP 1
  19: IFFALSE 38
// begin PlaceSeeing ( 1 , 1 , 1 , - 372963 ) ;
  21: LD_INT 1
  23: PPUSH
  24: LD_INT 1
  26: PPUSH
  27: LD_INT 1
  29: PPUSH
  30: LD_INT 372963
  32: NEG
  33: PPUSH
  34: CALL_OW 330
// end ; SetTechnologies ;
  38: CALL 602 0 0
// SetDiplomacy ;
  42: CALL 814 0 0
// PrepareGame ;
  46: CALL 896 0 0
// end ;
  50: END
// export debug , GameType , game , disableGlobalTimer ; export mc_amer , mc_leg , mc_rus_1 , mc_rus_2 ; export playerCommander , playerForces , allyCommander , Powell , Farmer , ruOutpost , ruEscape , staticMines , baseCaptured , legDestCounter , cratesSpawns , legOfferAccepted , legChangeSide , allyDestCounter , sibBombAllowed , reinforceAllowed , commander , cratesSpawn , outpostEscape , dialogueMineDetected ; end_of_file export function InitSettings ; begin
  51: LD_INT 0
  53: PPUSH
// debug := 0 ;
  54: LD_ADDR_EXP 1
  58: PUSH
  59: LD_INT 0
  61: ST_TO_ADDR
// GameType := 1 ;
  62: LD_ADDR_EXP 2
  66: PUSH
  67: LD_INT 1
  69: ST_TO_ADDR
// Difficulty := GetMultiplayerSetting ( 0 ) ;
  70: LD_ADDR_OWVAR 67
  74: PUSH
  75: LD_INT 0
  77: PPUSH
  78: CALL_OW 426
  82: ST_TO_ADDR
// sibBombAllowed := GetMultiPlayerSetting ( 1 ) - 1 ;
  83: LD_ADDR_EXP 23
  87: PUSH
  88: LD_INT 1
  90: PPUSH
  91: CALL_OW 426
  95: PUSH
  96: LD_INT 1
  98: MINUS
  99: ST_TO_ADDR
// reinforceAllowed := GetMultiPlayerSetting ( 2 ) - 1 ;
 100: LD_ADDR_EXP 24
 104: PUSH
 105: LD_INT 2
 107: PPUSH
 108: CALL_OW 426
 112: PUSH
 113: LD_INT 1
 115: MINUS
 116: ST_TO_ADDR
// cratesSpawn := GetMultiPlayerSetting ( 3 ) ;
 117: LD_ADDR_EXP 26
 121: PUSH
 122: LD_INT 3
 124: PPUSH
 125: CALL_OW 426
 129: ST_TO_ADDR
// commander := GetMultiPlayerSetting ( 4 ) ;
 130: LD_ADDR_EXP 25
 134: PUSH
 135: LD_INT 4
 137: PPUSH
 138: CALL_OW 426
 142: ST_TO_ADDR
// if not commander then
 143: LD_EXP 25
 147: NOT
 148: IFFALSE 158
// commander := 3 ;
 150: LD_ADDR_EXP 25
 154: PUSH
 155: LD_INT 3
 157: ST_TO_ADDR
// if not debug then
 158: LD_EXP 1
 162: NOT
 163: IFFALSE 167
// exit ;
 165: GO 224
// display_strings := [ Difficulty:  & Difficulty , sibBomb:  & sibBombAllowed , reinforceAllowed:  & reinforceAllowed , cratesSpawn:  & cratesSpawn , commander:  & commander ] ;
 167: LD_ADDR_OWVAR 47
 171: PUSH
 172: LD_STRING Difficulty: 
 174: PUSH
 175: LD_OWVAR 67
 179: STR
 180: PUSH
 181: LD_STRING sibBomb: 
 183: PUSH
 184: LD_EXP 23
 188: STR
 189: PUSH
 190: LD_STRING reinforceAllowed: 
 192: PUSH
 193: LD_EXP 24
 197: STR
 198: PUSH
 199: LD_STRING cratesSpawn: 
 201: PUSH
 202: LD_EXP 26
 206: STR
 207: PUSH
 208: LD_STRING commander: 
 210: PUSH
 211: LD_EXP 25
 215: STR
 216: PUSH
 217: EMPTY
 218: LIST
 219: LIST
 220: LIST
 221: LIST
 222: LIST
 223: ST_TO_ADDR
// end ;
 224: LD_VAR 0 1
 228: RET
// every 0 0$1 trigger game and GameType = 1 and not disableGlobalTimer do
 229: LD_EXP 3
 233: PUSH
 234: LD_EXP 2
 238: PUSH
 239: LD_INT 1
 241: EQUAL
 242: AND
 243: PUSH
 244: LD_EXP 4
 248: NOT
 249: AND
 250: IFFALSE 273
 252: GO 254
 254: DISABLE
// begin enable ;
 255: ENABLE
// display_strings := [ #SkrTime , tick ] ;
 256: LD_ADDR_OWVAR 47
 260: PUSH
 261: LD_STRING #SkrTime
 263: PUSH
 264: LD_OWVAR 1
 268: PUSH
 269: EMPTY
 270: LIST
 271: LIST
 272: ST_TO_ADDR
// end ;
 273: END
// every 1 trigger cratesSpawns and game and GameType = 1 do
 274: LD_EXP 19
 278: PUSH
 279: LD_EXP 3
 283: AND
 284: PUSH
 285: LD_EXP 2
 289: PUSH
 290: LD_INT 1
 292: EQUAL
 293: AND
 294: IFFALSE 355
 296: GO 298
 298: DISABLE
// Crates ( cratesSpawns [ 1 ] [ 1 ] , cratesSpawns [ 1 ] [ 2 ] , cratesSpawns [ 1 ] [ 3 ] , cratesSpawns [ 1 ] [ 4 ] ) ;
 299: LD_EXP 19
 303: PUSH
 304: LD_INT 1
 306: ARRAY
 307: PUSH
 308: LD_INT 1
 310: ARRAY
 311: PPUSH
 312: LD_EXP 19
 316: PUSH
 317: LD_INT 1
 319: ARRAY
 320: PUSH
 321: LD_INT 2
 323: ARRAY
 324: PPUSH
 325: LD_EXP 19
 329: PUSH
 330: LD_INT 1
 332: ARRAY
 333: PUSH
 334: LD_INT 3
 336: ARRAY
 337: PPUSH
 338: LD_EXP 19
 342: PUSH
 343: LD_INT 1
 345: ARRAY
 346: PUSH
 347: LD_INT 4
 349: ARRAY
 350: PPUSH
 351: CALL 56657 0 4
 355: END
// every 1 trigger cratesSpawns and game and GameType = 1 do
 356: LD_EXP 19
 360: PUSH
 361: LD_EXP 3
 365: AND
 366: PUSH
 367: LD_EXP 2
 371: PUSH
 372: LD_INT 1
 374: EQUAL
 375: AND
 376: IFFALSE 437
 378: GO 380
 380: DISABLE
// Crates ( cratesSpawns [ 2 ] [ 1 ] , cratesSpawns [ 2 ] [ 2 ] , cratesSpawns [ 2 ] [ 3 ] , cratesSpawns [ 2 ] [ 4 ] ) ;
 381: LD_EXP 19
 385: PUSH
 386: LD_INT 2
 388: ARRAY
 389: PUSH
 390: LD_INT 1
 392: ARRAY
 393: PPUSH
 394: LD_EXP 19
 398: PUSH
 399: LD_INT 2
 401: ARRAY
 402: PUSH
 403: LD_INT 2
 405: ARRAY
 406: PPUSH
 407: LD_EXP 19
 411: PUSH
 412: LD_INT 2
 414: ARRAY
 415: PUSH
 416: LD_INT 3
 418: ARRAY
 419: PPUSH
 420: LD_EXP 19
 424: PUSH
 425: LD_INT 2
 427: ARRAY
 428: PUSH
 429: LD_INT 4
 431: ARRAY
 432: PPUSH
 433: CALL 56657 0 4
 437: END
// every 1 trigger cratesSpawns and game and GameType = 1 do
 438: LD_EXP 19
 442: PUSH
 443: LD_EXP 3
 447: AND
 448: PUSH
 449: LD_EXP 2
 453: PUSH
 454: LD_INT 1
 456: EQUAL
 457: AND
 458: IFFALSE 519
 460: GO 462
 462: DISABLE
// Crates ( cratesSpawns [ 3 ] [ 1 ] , cratesSpawns [ 3 ] [ 2 ] , cratesSpawns [ 3 ] [ 3 ] , cratesSpawns [ 3 ] [ 4 ] ) ;
 463: LD_EXP 19
 467: PUSH
 468: LD_INT 3
 470: ARRAY
 471: PUSH
 472: LD_INT 1
 474: ARRAY
 475: PPUSH
 476: LD_EXP 19
 480: PUSH
 481: LD_INT 3
 483: ARRAY
 484: PUSH
 485: LD_INT 2
 487: ARRAY
 488: PPUSH
 489: LD_EXP 19
 493: PUSH
 494: LD_INT 3
 496: ARRAY
 497: PUSH
 498: LD_INT 3
 500: ARRAY
 501: PPUSH
 502: LD_EXP 19
 506: PUSH
 507: LD_INT 3
 509: ARRAY
 510: PUSH
 511: LD_INT 4
 513: ARRAY
 514: PPUSH
 515: CALL 56657 0 4
 519: END
// every 1 trigger cratesSpawns and game and GameType = 1 do
 520: LD_EXP 19
 524: PUSH
 525: LD_EXP 3
 529: AND
 530: PUSH
 531: LD_EXP 2
 535: PUSH
 536: LD_INT 1
 538: EQUAL
 539: AND
 540: IFFALSE 601
 542: GO 544
 544: DISABLE
// Crates ( cratesSpawns [ 4 ] [ 1 ] , cratesSpawns [ 4 ] [ 2 ] , cratesSpawns [ 4 ] [ 3 ] , cratesSpawns [ 4 ] [ 4 ] ) ;
 545: LD_EXP 19
 549: PUSH
 550: LD_INT 4
 552: ARRAY
 553: PUSH
 554: LD_INT 1
 556: ARRAY
 557: PPUSH
 558: LD_EXP 19
 562: PUSH
 563: LD_INT 4
 565: ARRAY
 566: PUSH
 567: LD_INT 2
 569: ARRAY
 570: PPUSH
 571: LD_EXP 19
 575: PUSH
 576: LD_INT 4
 578: ARRAY
 579: PUSH
 580: LD_INT 3
 582: ARRAY
 583: PPUSH
 584: LD_EXP 19
 588: PUSH
 589: LD_INT 4
 591: ARRAY
 592: PUSH
 593: LD_INT 4
 595: ARRAY
 596: PPUSH
 597: CALL 56657 0 4
 601: END
// export function SetTechnologies ; var i , j , ban_techs , res_techs ; begin
 602: LD_INT 0
 604: PPUSH
 605: PPUSH
 606: PPUSH
 607: PPUSH
 608: PPUSH
// if GameType = 1 then
 609: LD_EXP 2
 613: PUSH
 614: LD_INT 1
 616: EQUAL
 617: IFFALSE 686
// begin ban_techs := [ ] ;
 619: LD_ADDR_VAR 0 4
 623: PUSH
 624: EMPTY
 625: ST_TO_ADDR
// if sibBombAllowed < 2 then
 626: LD_EXP 23
 630: PUSH
 631: LD_INT 2
 633: LESS
 634: IFFALSE 647
// ban_techs := [ tech_sibFiss ] ;
 636: LD_ADDR_VAR 0 4
 640: PUSH
 641: LD_INT 25
 643: PUSH
 644: EMPTY
 645: LIST
 646: ST_TO_ADDR
// res_techs := [ tech_oilPow , tech_oilEng , tech_tech1 , tech_tech2 , tech_tech3 , tech_gun , tech_gatling , tech_rocket ] ;
 647: LD_ADDR_VAR 0 5
 651: PUSH
 652: LD_INT 46
 654: PUSH
 655: LD_INT 47
 657: PUSH
 658: LD_INT 48
 660: PUSH
 661: LD_INT 49
 663: PUSH
 664: LD_INT 50
 666: PUSH
 667: LD_INT 39
 669: PUSH
 670: LD_INT 69
 672: PUSH
 673: LD_INT 40
 675: PUSH
 676: EMPTY
 677: LIST
 678: LIST
 679: LIST
 680: LIST
 681: LIST
 682: LIST
 683: LIST
 684: LIST
 685: ST_TO_ADDR
// end ; for i = 1 to 8 do
 686: LD_ADDR_VAR 0 2
 690: PUSH
 691: DOUBLE
 692: LD_INT 1
 694: DEC
 695: ST_TO_ADDR
 696: LD_INT 8
 698: PUSH
 699: FOR_TO
 700: IFFALSE 784
// begin if res_techs then
 702: LD_VAR 0 5
 706: IFFALSE 742
// for j in res_techs do
 708: LD_ADDR_VAR 0 3
 712: PUSH
 713: LD_VAR 0 5
 717: PUSH
 718: FOR_IN
 719: IFFALSE 740
// SetTech ( j , i , state_researched ) ;
 721: LD_VAR 0 3
 725: PPUSH
 726: LD_VAR 0 2
 730: PPUSH
 731: LD_INT 2
 733: PPUSH
 734: CALL_OW 322
 738: GO 718
 740: POP
 741: POP
// if ban_techs then
 742: LD_VAR 0 4
 746: IFFALSE 782
// for j in ban_techs do
 748: LD_ADDR_VAR 0 3
 752: PUSH
 753: LD_VAR 0 4
 757: PUSH
 758: FOR_IN
 759: IFFALSE 780
// SetTech ( j , i , state_disabled ) ;
 761: LD_VAR 0 3
 765: PPUSH
 766: LD_VAR 0 2
 770: PPUSH
 771: LD_INT 0
 773: PPUSH
 774: CALL_OW 322
 778: GO 758
 780: POP
 781: POP
// end ;
 782: GO 699
 784: POP
 785: POP
// if sibBombAllowed = 1 then
 786: LD_EXP 23
 790: PUSH
 791: LD_INT 1
 793: EQUAL
 794: IFFALSE 809
// SetTech ( tech_sibFiss , 3 , state_enabled ) ;
 796: LD_INT 25
 798: PPUSH
 799: LD_INT 3
 801: PPUSH
 802: LD_INT 1
 804: PPUSH
 805: CALL_OW 322
// end ;
 809: LD_VAR 0 1
 813: RET
// export function SetDiplomacy ; begin
 814: LD_INT 0
 816: PPUSH
// if GameType = 1 then
 817: LD_EXP 2
 821: PUSH
 822: LD_INT 1
 824: EQUAL
 825: IFFALSE 891
// begin SetAttitude ( 1 , 4 , att_friend , true ) ;
 827: LD_INT 1
 829: PPUSH
 830: LD_INT 4
 832: PPUSH
 833: LD_INT 1
 835: PPUSH
 836: LD_INT 1
 838: PPUSH
 839: CALL_OW 80
// SetAttitude ( 3 , 6 , att_friend , true ) ;
 843: LD_INT 3
 845: PPUSH
 846: LD_INT 6
 848: PPUSH
 849: LD_INT 1
 851: PPUSH
 852: LD_INT 1
 854: PPUSH
 855: CALL_OW 80
// SetAttitude ( 3 , 8 , att_friend , true ) ;
 859: LD_INT 3
 861: PPUSH
 862: LD_INT 8
 864: PPUSH
 865: LD_INT 1
 867: PPUSH
 868: LD_INT 1
 870: PPUSH
 871: CALL_OW 80
// SetAttitude ( 6 , 8 , att_friend , true ) ;
 875: LD_INT 6
 877: PPUSH
 878: LD_INT 8
 880: PPUSH
 881: LD_INT 1
 883: PPUSH
 884: LD_INT 1
 886: PPUSH
 887: CALL_OW 80
// end ; end ;
 891: LD_VAR 0 1
 895: RET
// export function PrepareGame ; var i , tmp , sources ; begin
 896: LD_INT 0
 898: PPUSH
 899: PPUSH
 900: PPUSH
 901: PPUSH
// if GameType = 1 then
 902: LD_EXP 2
 906: PUSH
 907: LD_INT 1
 909: EQUAL
 910: IFFALSE 1406
// begin game := false ;
 912: LD_ADDR_EXP 3
 916: PUSH
 917: LD_INT 0
 919: ST_TO_ADDR
// your_side := 1 ;
 920: LD_ADDR_OWVAR 2
 924: PUSH
 925: LD_INT 1
 927: ST_TO_ADDR
// mc_amer := 1 ;
 928: LD_ADDR_EXP 5
 932: PUSH
 933: LD_INT 1
 935: ST_TO_ADDR
// mc_leg := 2 ;
 936: LD_ADDR_EXP 6
 940: PUSH
 941: LD_INT 2
 943: ST_TO_ADDR
// mc_rus_1 := 3 ;
 944: LD_ADDR_EXP 7
 948: PUSH
 949: LD_INT 3
 951: ST_TO_ADDR
// mc_rus_2 := 4 ;
 952: LD_ADDR_EXP 8
 956: PUSH
 957: LD_INT 4
 959: ST_TO_ADDR
// cratesSpawns := [ [ amerCrates , 1 , 0 , [ 200 , 250 , 300 ] [ cratesSpawn ] ] , [ rusCrates , 8 , 50 , 500 ] , [ legCrates , 5 , 50 , 300 ] , [ playerCrates , [ 4 , 5 , 6 ] [ cratesSpawn ] , 30 , [ 300 , 450 , 500 ] [ cratesSpawn ] ] ] ;
 960: LD_ADDR_EXP 19
 964: PUSH
 965: LD_INT 5
 967: PUSH
 968: LD_INT 1
 970: PUSH
 971: LD_INT 0
 973: PUSH
 974: LD_INT 200
 976: PUSH
 977: LD_INT 250
 979: PUSH
 980: LD_INT 300
 982: PUSH
 983: EMPTY
 984: LIST
 985: LIST
 986: LIST
 987: PUSH
 988: LD_EXP 26
 992: ARRAY
 993: PUSH
 994: EMPTY
 995: LIST
 996: LIST
 997: LIST
 998: LIST
 999: PUSH
1000: LD_INT 13
1002: PUSH
1003: LD_INT 8
1005: PUSH
1006: LD_INT 50
1008: PUSH
1009: LD_INT 500
1011: PUSH
1012: EMPTY
1013: LIST
1014: LIST
1015: LIST
1016: LIST
1017: PUSH
1018: LD_INT 17
1020: PUSH
1021: LD_INT 5
1023: PUSH
1024: LD_INT 50
1026: PUSH
1027: LD_INT 300
1029: PUSH
1030: EMPTY
1031: LIST
1032: LIST
1033: LIST
1034: LIST
1035: PUSH
1036: LD_INT 18
1038: PUSH
1039: LD_INT 4
1041: PUSH
1042: LD_INT 5
1044: PUSH
1045: LD_INT 6
1047: PUSH
1048: EMPTY
1049: LIST
1050: LIST
1051: LIST
1052: PUSH
1053: LD_EXP 26
1057: ARRAY
1058: PUSH
1059: LD_INT 30
1061: PUSH
1062: LD_INT 300
1064: PUSH
1065: LD_INT 450
1067: PUSH
1068: LD_INT 500
1070: PUSH
1071: EMPTY
1072: LIST
1073: LIST
1074: LIST
1075: PUSH
1076: LD_EXP 26
1080: ARRAY
1081: PUSH
1082: EMPTY
1083: LIST
1084: LIST
1085: LIST
1086: LIST
1087: PUSH
1088: EMPTY
1089: LIST
1090: LIST
1091: LIST
1092: LIST
1093: ST_TO_ADDR
// sources := [ [ 190 , 193 , mat_siberit ] , [ 182 , 117 , mat_siberit ] , [ 43 , 2 , mat_siberit ] , [ 114 , 152 , mat_oil ] , [ 85 , 38 , mat_oil ] ] ;
1094: LD_ADDR_VAR 0 4
1098: PUSH
1099: LD_INT 190
1101: PUSH
1102: LD_INT 193
1104: PUSH
1105: LD_INT 3
1107: PUSH
1108: EMPTY
1109: LIST
1110: LIST
1111: LIST
1112: PUSH
1113: LD_INT 182
1115: PUSH
1116: LD_INT 117
1118: PUSH
1119: LD_INT 3
1121: PUSH
1122: EMPTY
1123: LIST
1124: LIST
1125: LIST
1126: PUSH
1127: LD_INT 43
1129: PUSH
1130: LD_INT 2
1132: PUSH
1133: LD_INT 3
1135: PUSH
1136: EMPTY
1137: LIST
1138: LIST
1139: LIST
1140: PUSH
1141: LD_INT 114
1143: PUSH
1144: LD_INT 152
1146: PUSH
1147: LD_INT 2
1149: PUSH
1150: EMPTY
1151: LIST
1152: LIST
1153: LIST
1154: PUSH
1155: LD_INT 85
1157: PUSH
1158: LD_INT 38
1160: PUSH
1161: LD_INT 2
1163: PUSH
1164: EMPTY
1165: LIST
1166: LIST
1167: LIST
1168: PUSH
1169: EMPTY
1170: LIST
1171: LIST
1172: LIST
1173: LIST
1174: LIST
1175: ST_TO_ADDR
// for i in sources do
1176: LD_ADDR_VAR 0 2
1180: PUSH
1181: LD_VAR 0 4
1185: PUSH
1186: FOR_IN
1187: IFFALSE 1222
// CreateDepositXY ( i [ 1 ] , i [ 2 ] , i [ 3 ] ) ;
1189: LD_VAR 0 2
1193: PUSH
1194: LD_INT 1
1196: ARRAY
1197: PPUSH
1198: LD_VAR 0 2
1202: PUSH
1203: LD_INT 2
1205: ARRAY
1206: PPUSH
1207: LD_VAR 0 2
1211: PUSH
1212: LD_INT 3
1214: ARRAY
1215: PPUSH
1216: CALL_OW 62
1220: GO 1186
1222: POP
1223: POP
// disableGlobalTimer := false ;
1224: LD_ADDR_EXP 4
1228: PUSH
1229: LD_INT 0
1231: ST_TO_ADDR
// ruEscape := [ 0 , [ 5 , 6 , 7 ] [ Difficulty ] ] ;
1232: LD_ADDR_EXP 15
1236: PUSH
1237: LD_INT 0
1239: PUSH
1240: LD_INT 5
1242: PUSH
1243: LD_INT 6
1245: PUSH
1246: LD_INT 7
1248: PUSH
1249: EMPTY
1250: LIST
1251: LIST
1252: LIST
1253: PUSH
1254: LD_OWVAR 67
1258: ARRAY
1259: PUSH
1260: EMPTY
1261: LIST
1262: LIST
1263: ST_TO_ADDR
// ruOutpost := [ ] ;
1264: LD_ADDR_EXP 14
1268: PUSH
1269: EMPTY
1270: ST_TO_ADDR
// staticMines := [ ] ;
1271: LD_ADDR_EXP 16
1275: PUSH
1276: EMPTY
1277: ST_TO_ADDR
// baseCaptured := false ;
1278: LD_ADDR_EXP 17
1282: PUSH
1283: LD_INT 0
1285: ST_TO_ADDR
// legDestCounter := 0 ;
1286: LD_ADDR_EXP 18
1290: PUSH
1291: LD_INT 0
1293: ST_TO_ADDR
// legOfferAccepted := false ;
1294: LD_ADDR_EXP 20
1298: PUSH
1299: LD_INT 0
1301: ST_TO_ADDR
// legChangeSide := false ;
1302: LD_ADDR_EXP 21
1306: PUSH
1307: LD_INT 0
1309: ST_TO_ADDR
// allyDestCounter := 0 ;
1310: LD_ADDR_EXP 22
1314: PUSH
1315: LD_INT 0
1317: ST_TO_ADDR
// outpostEscape := false ;
1318: LD_ADDR_EXP 27
1322: PUSH
1323: LD_INT 0
1325: ST_TO_ADDR
// dialogueMineDetected := false ;
1326: LD_ADDR_EXP 28
1330: PUSH
1331: LD_INT 0
1333: ST_TO_ADDR
// PrepareAmericans ;
1334: CALL 7604 0 0
// PrepareLegion ;
1338: CALL 5538 0 0
// PrepareRussians ;
1342: CALL 2504 0 0
// playerForces := PreparePlayer ;
1346: LD_ADDR_EXP 10
1350: PUSH
1351: CALL 8847 0 0
1355: ST_TO_ADDR
// AnimateTrees ( true ) ;
1356: LD_INT 1
1358: PPUSH
1359: CALL_OW 573
// PrepareNature ( 4 , 3 , 8 , 5 , 3 , 1 , 8 , natureGroundArea , natureWaterArea ) ;
1363: LD_INT 4
1365: PPUSH
1366: LD_INT 3
1368: PPUSH
1369: LD_INT 8
1371: PPUSH
1372: LD_INT 5
1374: PPUSH
1375: LD_INT 3
1377: PPUSH
1378: LD_INT 1
1380: PPUSH
1381: LD_INT 8
1383: PPUSH
1384: LD_INT 2
1386: PPUSH
1387: LD_INT 1
1389: PPUSH
1390: CALL 54015 0 9
// MC_Start ;
1394: CALL 63424 0 0
// SetAdditionalRussianForces ;
1398: CALL 7273 0 0
// Action ;
1402: CALL 11204 0 0
// end ; end ;
1406: LD_VAR 0 1
1410: RET
// export function CustomInitMacro ; begin
1411: LD_INT 0
1413: PPUSH
// if GameType <> 1 then
1414: LD_EXP 2
1418: PUSH
1419: LD_INT 1
1421: NONEQUAL
1422: IFFALSE 1426
// exit ;
1424: GO 2499
// MC_SetScanArea ( mc_amer , amerBase ) ;
1426: LD_EXP 5
1430: PPUSH
1431: LD_INT 3
1433: PPUSH
1434: CALL 86801 0 2
// MC_SetParkingArea ( mc_amer , amerParking ) ;
1438: LD_EXP 5
1442: PPUSH
1443: LD_INT 4
1445: PPUSH
1446: CALL 86745 0 2
// MC_SetAllowedTurretWeapons ( mc_amer , [ us_radar , us_heavy_gun , us_rocket_launcher , us_laser , us_double_laser ] ) ;
1450: LD_EXP 5
1454: PPUSH
1455: LD_INT 11
1457: PUSH
1458: LD_INT 6
1460: PUSH
1461: LD_INT 7
1463: PUSH
1464: LD_INT 9
1466: PUSH
1467: LD_INT 10
1469: PUSH
1470: EMPTY
1471: LIST
1472: LIST
1473: LIST
1474: LIST
1475: LIST
1476: PPUSH
1477: CALL 86633 0 2
// MC_SetCratesArea ( mc_amer , amerCrates ) ;
1481: LD_EXP 5
1485: PPUSH
1486: LD_INT 5
1488: PPUSH
1489: CALL 86315 0 2
// MC_SetTame ( mc_amer , amerBase ) ;
1493: LD_EXP 5
1497: PPUSH
1498: LD_INT 3
1500: PPUSH
1501: CALL 86046 0 2
// MC_SetDefenderLimit ( mc_amer , 4 ) ;
1505: LD_EXP 5
1509: PPUSH
1510: LD_INT 4
1512: PPUSH
1513: CALL 85665 0 2
// MC_SetProduceList ( mc_amer , [ [ us_medium_tracked , engine_combustion , control_remote , us_double_gun ] , [ us_medium_tracked , engine_solar , control_remote , us_laser ] , [ us_heavy_tracked , engine_combustion , control_remote , us_rocket_launcher ] , [ us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun ] , ] ) ;
1517: LD_EXP 5
1521: PPUSH
1522: LD_INT 3
1524: PUSH
1525: LD_INT 1
1527: PUSH
1528: LD_INT 2
1530: PUSH
1531: LD_INT 5
1533: PUSH
1534: EMPTY
1535: LIST
1536: LIST
1537: LIST
1538: LIST
1539: PUSH
1540: LD_INT 3
1542: PUSH
1543: LD_INT 2
1545: PUSH
1546: LD_INT 2
1548: PUSH
1549: LD_INT 9
1551: PUSH
1552: EMPTY
1553: LIST
1554: LIST
1555: LIST
1556: LIST
1557: PUSH
1558: LD_INT 4
1560: PUSH
1561: LD_INT 1
1563: PUSH
1564: LD_INT 2
1566: PUSH
1567: LD_INT 7
1569: PUSH
1570: EMPTY
1571: LIST
1572: LIST
1573: LIST
1574: LIST
1575: PUSH
1576: LD_INT 4
1578: PUSH
1579: LD_INT 1
1581: PUSH
1582: LD_INT 2
1584: PUSH
1585: LD_INT 6
1587: PUSH
1588: EMPTY
1589: LIST
1590: LIST
1591: LIST
1592: LIST
1593: PUSH
1594: EMPTY
1595: LIST
1596: LIST
1597: LIST
1598: LIST
1599: PPUSH
1600: CALL 85480 0 2
// MC_SetBuildingList ( mc_amer , [ [ b_turret , 114 , 16 , 0 ] , [ b_bunker , 110 , 12 , 0 ] ] ) ;
1604: LD_EXP 5
1608: PPUSH
1609: LD_INT 33
1611: PUSH
1612: LD_INT 114
1614: PUSH
1615: LD_INT 16
1617: PUSH
1618: LD_INT 0
1620: PUSH
1621: EMPTY
1622: LIST
1623: LIST
1624: LIST
1625: LIST
1626: PUSH
1627: LD_INT 32
1629: PUSH
1630: LD_INT 110
1632: PUSH
1633: LD_INT 12
1635: PUSH
1636: LD_INT 0
1638: PUSH
1639: EMPTY
1640: LIST
1641: LIST
1642: LIST
1643: LIST
1644: PUSH
1645: EMPTY
1646: LIST
1647: LIST
1648: PPUSH
1649: CALL 85372 0 2
// MC_SetLabKind ( mc_amer , [ b_lab_weapon , b_lab_opto , b_lab_computer , b_lab_siberium ] ) ;
1653: LD_EXP 5
1657: PPUSH
1658: LD_INT 10
1660: PUSH
1661: LD_INT 15
1663: PUSH
1664: LD_INT 12
1666: PUSH
1667: LD_INT 11
1669: PUSH
1670: EMPTY
1671: LIST
1672: LIST
1673: LIST
1674: LIST
1675: PPUSH
1676: CALL 86222 0 2
// MC_SetScanArea ( mc_leg , legBase ) ;
1680: LD_EXP 6
1684: PPUSH
1685: LD_INT 6
1687: PPUSH
1688: CALL 86801 0 2
// MC_SetParkingArea ( mc_leg , legParking ) ;
1692: LD_EXP 6
1696: PPUSH
1697: LD_INT 7
1699: PPUSH
1700: CALL 86745 0 2
// MC_SetAllowedTurretWeapons ( mc_leg , [ ar_radar , ar_gun , ar_rocket_launcher , ar_gatling_gun ] ) ;
1704: LD_EXP 6
1708: PPUSH
1709: LD_INT 30
1711: PUSH
1712: LD_INT 27
1714: PUSH
1715: LD_INT 28
1717: PUSH
1718: LD_INT 25
1720: PUSH
1721: EMPTY
1722: LIST
1723: LIST
1724: LIST
1725: LIST
1726: PPUSH
1727: CALL 86633 0 2
// MC_SetCratesArea ( mc_leg , legCrates ) ;
1731: LD_EXP 6
1735: PPUSH
1736: LD_INT 17
1738: PPUSH
1739: CALL 86315 0 2
// MC_SetTame ( mc_leg , legBase ) ;
1743: LD_EXP 6
1747: PPUSH
1748: LD_INT 6
1750: PPUSH
1751: CALL 86046 0 2
// MC_SetDefenderLimit ( mc_leg , 5 ) ;
1755: LD_EXP 6
1759: PPUSH
1760: LD_INT 5
1762: PPUSH
1763: CALL 85665 0 2
// MC_SetMinesField ( mc_leg , 10 , legMines ) ;
1767: LD_EXP 6
1771: PPUSH
1772: LD_INT 10
1774: PPUSH
1775: LD_INT 9
1777: PPUSH
1778: CALL 85162 0 3
// MC_SetBuildingList ( mc_leg , [ [ b_armoury , 157 , 144 , 0 ] , [ b_bunker , 151 , 142 , 0 ] , [ b_bunker , 161 , 144 , 0 ] , [ b_bunker , 140 , 133 , 0 ] ] ) ;
1782: LD_EXP 6
1786: PPUSH
1787: LD_INT 4
1789: PUSH
1790: LD_INT 157
1792: PUSH
1793: LD_INT 144
1795: PUSH
1796: LD_INT 0
1798: PUSH
1799: EMPTY
1800: LIST
1801: LIST
1802: LIST
1803: LIST
1804: PUSH
1805: LD_INT 32
1807: PUSH
1808: LD_INT 151
1810: PUSH
1811: LD_INT 142
1813: PUSH
1814: LD_INT 0
1816: PUSH
1817: EMPTY
1818: LIST
1819: LIST
1820: LIST
1821: LIST
1822: PUSH
1823: LD_INT 32
1825: PUSH
1826: LD_INT 161
1828: PUSH
1829: LD_INT 144
1831: PUSH
1832: LD_INT 0
1834: PUSH
1835: EMPTY
1836: LIST
1837: LIST
1838: LIST
1839: LIST
1840: PUSH
1841: LD_INT 32
1843: PUSH
1844: LD_INT 140
1846: PUSH
1847: LD_INT 133
1849: PUSH
1850: LD_INT 0
1852: PUSH
1853: EMPTY
1854: LIST
1855: LIST
1856: LIST
1857: LIST
1858: PUSH
1859: EMPTY
1860: LIST
1861: LIST
1862: LIST
1863: LIST
1864: PPUSH
1865: CALL 85372 0 2
// MC_SetProduceList ( mc_leg , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_combustion , control_manual , ar_gun ] , [ ar_medium_trike , engine_combustion , control_remote , ar_gun ] , [ ar_medium_trike , engine_combustion , control_remote , ar_gun ] , [ ar_medium_trike , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_cargo_bay ] , [ ar_medium_trike , engine_combustion , control_remote , ar_crane ] ] ) ;
1869: LD_EXP 6
1873: PPUSH
1874: LD_INT 13
1876: PUSH
1877: LD_INT 2
1879: PUSH
1880: LD_INT 1
1882: PUSH
1883: LD_INT 31
1885: PUSH
1886: EMPTY
1887: LIST
1888: LIST
1889: LIST
1890: LIST
1891: PUSH
1892: LD_INT 13
1894: PUSH
1895: LD_INT 2
1897: PUSH
1898: LD_INT 1
1900: PUSH
1901: LD_INT 31
1903: PUSH
1904: EMPTY
1905: LIST
1906: LIST
1907: LIST
1908: LIST
1909: PUSH
1910: LD_INT 13
1912: PUSH
1913: LD_INT 1
1915: PUSH
1916: LD_INT 1
1918: PUSH
1919: LD_INT 27
1921: PUSH
1922: EMPTY
1923: LIST
1924: LIST
1925: LIST
1926: LIST
1927: PUSH
1928: LD_INT 13
1930: PUSH
1931: LD_INT 1
1933: PUSH
1934: LD_INT 2
1936: PUSH
1937: LD_INT 27
1939: PUSH
1940: EMPTY
1941: LIST
1942: LIST
1943: LIST
1944: LIST
1945: PUSH
1946: LD_INT 13
1948: PUSH
1949: LD_INT 1
1951: PUSH
1952: LD_INT 2
1954: PUSH
1955: LD_INT 27
1957: PUSH
1958: EMPTY
1959: LIST
1960: LIST
1961: LIST
1962: LIST
1963: PUSH
1964: LD_INT 13
1966: PUSH
1967: LD_INT 1
1969: PUSH
1970: LD_INT 2
1972: PUSH
1973: LD_INT 28
1975: PUSH
1976: EMPTY
1977: LIST
1978: LIST
1979: LIST
1980: LIST
1981: PUSH
1982: LD_INT 13
1984: PUSH
1985: LD_INT 1
1987: PUSH
1988: LD_INT 2
1990: PUSH
1991: LD_INT 28
1993: PUSH
1994: EMPTY
1995: LIST
1996: LIST
1997: LIST
1998: LIST
1999: PUSH
2000: LD_INT 13
2002: PUSH
2003: LD_INT 1
2005: PUSH
2006: LD_INT 2
2008: PUSH
2009: LD_INT 32
2011: PUSH
2012: EMPTY
2013: LIST
2014: LIST
2015: LIST
2016: LIST
2017: PUSH
2018: LD_INT 13
2020: PUSH
2021: LD_INT 1
2023: PUSH
2024: LD_INT 2
2026: PUSH
2027: LD_INT 88
2029: PUSH
2030: EMPTY
2031: LIST
2032: LIST
2033: LIST
2034: LIST
2035: PUSH
2036: EMPTY
2037: LIST
2038: LIST
2039: LIST
2040: LIST
2041: LIST
2042: LIST
2043: LIST
2044: LIST
2045: LIST
2046: PPUSH
2047: CALL 85480 0 2
// HiddenCamera ( 165 , 156 , 8 ) ;
2051: LD_INT 165
2053: PPUSH
2054: LD_INT 156
2056: PPUSH
2057: LD_INT 8
2059: PPUSH
2060: CALL_OW 244
// MC_SetScanArea ( mc_rus_1 , rus1Base ) ;
2064: LD_EXP 7
2068: PPUSH
2069: LD_INT 15
2071: PPUSH
2072: CALL 86801 0 2
// MC_SetParkingArea ( mc_rus_1 , rus1Parking ) ;
2076: LD_EXP 7
2080: PPUSH
2081: LD_INT 16
2083: PPUSH
2084: CALL 86745 0 2
// MC_SetAllowedTurretWeapons ( mc_rus_1 , [ ru_gatling_gun , ru_rocket , ru_rocket_launcher , ru_time_lapser , ru_heavy_gun ] ) ;
2088: LD_EXP 7
2092: PPUSH
2093: LD_INT 43
2095: PUSH
2096: LD_INT 47
2098: PUSH
2099: LD_INT 45
2101: PUSH
2102: LD_INT 49
2104: PUSH
2105: LD_INT 46
2107: PUSH
2108: EMPTY
2109: LIST
2110: LIST
2111: LIST
2112: LIST
2113: LIST
2114: PPUSH
2115: CALL 86633 0 2
// MC_SetCratesArea ( mc_rus_1 , rusCrates ) ;
2119: LD_EXP 7
2123: PPUSH
2124: LD_INT 13
2126: PPUSH
2127: CALL 86315 0 2
// MC_SetTame ( mc_rus_1 , rus1Base ) ;
2131: LD_EXP 7
2135: PPUSH
2136: LD_INT 15
2138: PPUSH
2139: CALL 86046 0 2
// MC_SetDefenderLimit ( mc_rus_1 , 5 ) ;
2143: LD_EXP 7
2147: PPUSH
2148: LD_INT 5
2150: PPUSH
2151: CALL 85665 0 2
// MC_SetProduceList ( mc_rus_1 , [ [ ru_heavy_wheeled , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_heavy_wheeled , engine_combustion , control_manual , ru_heavy_gun ] , [ ru_heavy_wheeled , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_heavy_wheeled , engine_combustion , control_manual , ru_rocket ] , [ ru_heavy_wheeled , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_medium_wheeled , engine_combustion , control_computer , ru_cargo_bay ] , [ ru_medium_wheeled , engine_combustion , control_computer , ru_crane ] , ] ) ;
2155: LD_EXP 7
2159: PPUSH
2160: LD_INT 23
2162: PUSH
2163: LD_INT 1
2165: PUSH
2166: LD_INT 3
2168: PUSH
2169: LD_INT 46
2171: PUSH
2172: EMPTY
2173: LIST
2174: LIST
2175: LIST
2176: LIST
2177: PUSH
2178: LD_INT 23
2180: PUSH
2181: LD_INT 1
2183: PUSH
2184: LD_INT 1
2186: PUSH
2187: LD_INT 46
2189: PUSH
2190: EMPTY
2191: LIST
2192: LIST
2193: LIST
2194: LIST
2195: PUSH
2196: LD_INT 23
2198: PUSH
2199: LD_INT 1
2201: PUSH
2202: LD_INT 3
2204: PUSH
2205: LD_INT 45
2207: PUSH
2208: EMPTY
2209: LIST
2210: LIST
2211: LIST
2212: LIST
2213: PUSH
2214: LD_INT 23
2216: PUSH
2217: LD_INT 1
2219: PUSH
2220: LD_INT 1
2222: PUSH
2223: LD_INT 47
2225: PUSH
2226: EMPTY
2227: LIST
2228: LIST
2229: LIST
2230: LIST
2231: PUSH
2232: LD_INT 23
2234: PUSH
2235: LD_INT 1
2237: PUSH
2238: LD_INT 3
2240: PUSH
2241: LD_INT 46
2243: PUSH
2244: EMPTY
2245: LIST
2246: LIST
2247: LIST
2248: LIST
2249: PUSH
2250: LD_INT 21
2252: PUSH
2253: LD_INT 1
2255: PUSH
2256: LD_INT 3
2258: PUSH
2259: LD_INT 51
2261: PUSH
2262: EMPTY
2263: LIST
2264: LIST
2265: LIST
2266: LIST
2267: PUSH
2268: LD_INT 21
2270: PUSH
2271: LD_INT 1
2273: PUSH
2274: LD_INT 3
2276: PUSH
2277: LD_INT 52
2279: PUSH
2280: EMPTY
2281: LIST
2282: LIST
2283: LIST
2284: LIST
2285: PUSH
2286: EMPTY
2287: LIST
2288: LIST
2289: LIST
2290: LIST
2291: LIST
2292: LIST
2293: LIST
2294: PPUSH
2295: CALL 85480 0 2
// MC_SetScanArea ( mc_rus_2 , rus2Base ) ;
2299: LD_EXP 8
2303: PPUSH
2304: LD_INT 11
2306: PPUSH
2307: CALL 86801 0 2
// MC_SetParkingArea ( mc_rus_2 , rus2Parking ) ;
2311: LD_EXP 8
2315: PPUSH
2316: LD_INT 12
2318: PPUSH
2319: CALL 86745 0 2
// MC_SetAllowedTurretWeapons ( mc_rus_2 , [ ru_gatling_gun , ru_rocket , ru_rocket_launcher , ru_time_lapser , ru_heavy_gun ] ) ;
2323: LD_EXP 8
2327: PPUSH
2328: LD_INT 43
2330: PUSH
2331: LD_INT 47
2333: PUSH
2334: LD_INT 45
2336: PUSH
2337: LD_INT 49
2339: PUSH
2340: LD_INT 46
2342: PUSH
2343: EMPTY
2344: LIST
2345: LIST
2346: LIST
2347: LIST
2348: LIST
2349: PPUSH
2350: CALL 86633 0 2
// MC_SetCratesArea ( mc_rus_2 , rusCrates ) ;
2354: LD_EXP 8
2358: PPUSH
2359: LD_INT 13
2361: PPUSH
2362: CALL 86315 0 2
// MC_SetTame ( mc_rus_2 , rus2Base ) ;
2366: LD_EXP 8
2370: PPUSH
2371: LD_INT 11
2373: PPUSH
2374: CALL 86046 0 2
// MC_SetDefenderLimit ( mc_rus_2 , 4 ) ;
2378: LD_EXP 8
2382: PPUSH
2383: LD_INT 4
2385: PPUSH
2386: CALL 85665 0 2
// MC_SetTeleportExit ( mc_rus_2 , [ [ 115 , 201 ] ] ) ;
2390: LD_EXP 8
2394: PPUSH
2395: LD_INT 115
2397: PUSH
2398: LD_INT 201
2400: PUSH
2401: EMPTY
2402: LIST
2403: LIST
2404: PUSH
2405: EMPTY
2406: LIST
2407: PPUSH
2408: CALL 86371 0 2
// MC_SetProduceList ( mc_rus_2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
2412: LD_EXP 8
2416: PPUSH
2417: LD_INT 24
2419: PUSH
2420: LD_INT 3
2422: PUSH
2423: LD_INT 3
2425: PUSH
2426: LD_INT 46
2428: PUSH
2429: EMPTY
2430: LIST
2431: LIST
2432: LIST
2433: LIST
2434: PUSH
2435: LD_INT 24
2437: PUSH
2438: LD_INT 3
2440: PUSH
2441: LD_INT 3
2443: PUSH
2444: LD_INT 46
2446: PUSH
2447: EMPTY
2448: LIST
2449: LIST
2450: LIST
2451: LIST
2452: PUSH
2453: LD_INT 24
2455: PUSH
2456: LD_INT 3
2458: PUSH
2459: LD_INT 3
2461: PUSH
2462: LD_INT 46
2464: PUSH
2465: EMPTY
2466: LIST
2467: LIST
2468: LIST
2469: LIST
2470: PUSH
2471: LD_INT 24
2473: PUSH
2474: LD_INT 3
2476: PUSH
2477: LD_INT 3
2479: PUSH
2480: LD_INT 46
2482: PUSH
2483: EMPTY
2484: LIST
2485: LIST
2486: LIST
2487: LIST
2488: PUSH
2489: EMPTY
2490: LIST
2491: LIST
2492: LIST
2493: LIST
2494: PPUSH
2495: CALL 85480 0 2
// end ;
2499: LD_VAR 0 1
2503: RET
// export function PrepareRussians ; var i , b , tmp , side , sr , depot , base ; begin
2504: LD_INT 0
2506: PPUSH
2507: PPUSH
2508: PPUSH
2509: PPUSH
2510: PPUSH
2511: PPUSH
2512: PPUSH
2513: PPUSH
// PrepareNature ( 0 , 0 , 3 , 0 , 0 , 0 , 0 , rusApe , 0 ) ;
2514: LD_INT 0
2516: PPUSH
2517: LD_INT 0
2519: PPUSH
2520: LD_INT 3
2522: PPUSH
2523: LD_INT 0
2525: PPUSH
2526: LD_INT 0
2528: PPUSH
2529: LD_INT 0
2531: PPUSH
2532: LD_INT 0
2534: PPUSH
2535: LD_INT 14
2537: PPUSH
2538: LD_INT 0
2540: PPUSH
2541: CALL 54015 0 9
// side := 3 ;
2545: LD_ADDR_VAR 0 5
2549: PUSH
2550: LD_INT 3
2552: ST_TO_ADDR
// SetTech ( tech_targTeleport , side , state_researched ) ;
2553: LD_INT 38
2555: PPUSH
2556: LD_VAR 0 5
2560: PPUSH
2561: LD_INT 2
2563: PPUSH
2564: CALL_OW 322
// SetTech ( tech_gun , side , state_researched ) ;
2568: LD_INT 39
2570: PPUSH
2571: LD_VAR 0 5
2575: PPUSH
2576: LD_INT 2
2578: PPUSH
2579: CALL_OW 322
// SetTech ( tech_advMet , side , state_researched ) ;
2583: LD_INT 34
2585: PPUSH
2586: LD_VAR 0 5
2590: PPUSH
2591: LD_INT 2
2593: PPUSH
2594: CALL_OW 322
// tmp := [ [ 0 , 208 , 163 , 4 , 0 , 0 ] , [ 3 , 194 , 161 , 1 , 0 , 0 ] , [ 17 , 190 , 161 , 1 , 0 , 0 ] , [ 5 , 200 , 145 , 3 , 0 , 0 ] , [ 32 , 192 , 144 , 3 , 0 , 0 ] , [ 26 , 216 , 172 , 3 , 0 , 0 ] , [ 26 , 218 , 176 , 3 , 0 , 0 ] , [ 29 , 182 , 149 , 3 , 0 , 0 ] , [ 8 , 201 , 171 , 0 , 10 , 11 ] , [ 32 , 188 , 167 , 0 , 0 , 0 ] , [ 32 , 202 , 179 , 0 , 0 , 0 ] , [ 32 , 209 , 182 , 0 , 0 , 0 ] , [ 32 , 220 , 183 , 5 , 0 , 0 ] , [ 32 , 225 , 181 , 5 , 0 , 0 ] , [ 26 , 220 , 174 , 5 , 0 , 0 ] , [ 1 , 84 , 128 , 4 , 0 , 0 ] , [ 3 , 68 , 121 , 1 , 0 , 0 ] , [ 19 , 72 , 125 , 5 , 0 , 0 ] , [ 18 , 68 , 124 , 0 , 0 , 0 ] , [ 24 , 64 , 121 , 1 , 0 , 0 ] , [ 17 , 65 , 118 , 2 , 0 , 0 ] , [ 21 , 68 , 117 , 3 , 0 , 0 ] , [ 8 , 68 , 130 , 1 , 14 , 10 ] , [ 8 , 67 , 110 , 2 , 11 , 12 ] , [ 28 , 85 , 108 , 2 , 0 , 0 ] , [ 28 , 85 , 124 , 2 , 0 , 0 ] , [ 30 , 97 , 119 , 2 , 0 , 0 ] , [ 5 , 111 , 138 , 4 , 0 , 0 ] , [ 33 , 104 , 130 , 3 , 0 , 0 ] , [ 33 , 110 , 142 , 5 , 0 , 0 ] , [ 33 , 91 , 131 , 5 , 0 , 0 ] , [ 33 , 107 , 157 , 5 , 0 , 0 ] , [ 33 , 104 , 160 , 5 , 0 , 0 ] , [ 33 , 101 , 162 , 5 , 0 , 0 ] , [ 32 , 87 , 157 , 5 , 0 , 0 ] , [ 32 , 105 , 158 , 5 , 0 , 0 ] , [ 33 , 91 , 118 , 4 , 0 , 0 ] , [ 33 , 89 , 107 , 4 , 0 , 0 ] , [ 5 , 86 , 96 , 3 , 0 , 0 ] , [ 33 , 91 , 102 , 4 , 0 , 0 ] , [ 32 , 80 , 95 , 3 , 0 , 0 ] , [ 28 , 77 , 105 , 3 , 0 , 0 ] , [ 28 , 85 , 113 , 3 , 0 , 0 ] , [ 28 , 55 , 97 , 3 , 0 , 0 ] , [ 28 , 88 , 128 , 3 , 0 , 0 ] , [ 32 , 69 , 101 , 2 , 0 , 0 ] , [ 1 , 34 , 23 , 4 , 0 , 0 ] , [ 8 , 25 , 4 , 3 , 11 , 10 ] , [ 8 , 15 , 4 , 2 , 14 , 12 ] , [ 29 , 55 , 35 , 2 , 0 , 0 ] , [ 29 , 24 , 44 , 2 , 0 , 0 ] , [ 34 , 34 , 32 , 4 , 0 , 0 ] , [ 3 , 14 , 16 , 1 , 0 , 0 ] , [ 24 , 10 , 16 , 1 , 0 , 0 ] , [ 21 , 11 , 13 , 2 , 0 , 0 ] , [ 18 , 14 , 12 , 3 , 0 , 0 ] , [ 16 , 14 , 19 , 0 , 0 , 0 ] , [ 17 , 18 , 20 , 5 , 0 , 0 ] , [ 28 , 10 , 5 , 1 , 0 , 0 ] , [ 28 , 8 , 8 , 1 , 0 , 0 ] , [ 26 , 19 , 2 , 1 , 0 , 0 ] , [ 26 , 30 , 2 , 1 , 0 , 0 ] , [ 5 , 59 , 20 , 4 , 0 , 0 ] , [ 32 , 60 , 24 , 4 , 0 , 0 ] , [ 32 , 61 , 45 , 5 , 0 , 0 ] , [ 32 , 52 , 51 , 5 , 0 , 0 ] , [ 33 , 56 , 51 , 5 , 0 , 0 ] , [ 33 , 62 , 49 , 5 , 0 , 0 ] , [ 33 , 41 , 47 , 5 , 0 , 0 ] , [ 33 , 33 , 52 , 5 , 0 , 0 ] , [ 5 , 31 , 40 , 0 , 0 , 0 ] , [ 33 , 65 , 37 , 5 , 0 , 0 ] , [ 33 , 63 , 29 , 4 , 0 , 0 ] , [ 33 , 54 , 11 , 4 , 0 , 0 ] , [ 33 , 56 , 15 , 4 , 0 , 0 ] , [ 33 , 51 , 6 , 4 , 0 , 0 ] , [ 26 , 39 , 25 , 0 , 0 , 0 ] , [ 26 , 37 , 21 , 0 , 0 , 0 ] , [ 32 , 35 , 17 , 4 , 0 , 0 ] , [ 33 , 35 , 28 , 4 , 0 , 0 ] , [ 33 , 28 , 46 , 5 , 0 , 0 ] , [ 33 , 31 , 6 , 4 , 0 , 0 ] , [ 26 , 54 , 38 , 4 , 0 , 0 ] , [ 33 , 207 , 167 , 3 , 0 , 0 ] , [ 30 , 43 , 2 , 4 , 0 , 0 ] ] ;
2598: LD_ADDR_VAR 0 4
2602: PUSH
2603: LD_INT 0
2605: PUSH
2606: LD_INT 208
2608: PUSH
2609: LD_INT 163
2611: PUSH
2612: LD_INT 4
2614: PUSH
2615: LD_INT 0
2617: PUSH
2618: LD_INT 0
2620: PUSH
2621: EMPTY
2622: LIST
2623: LIST
2624: LIST
2625: LIST
2626: LIST
2627: LIST
2628: PUSH
2629: LD_INT 3
2631: PUSH
2632: LD_INT 194
2634: PUSH
2635: LD_INT 161
2637: PUSH
2638: LD_INT 1
2640: PUSH
2641: LD_INT 0
2643: PUSH
2644: LD_INT 0
2646: PUSH
2647: EMPTY
2648: LIST
2649: LIST
2650: LIST
2651: LIST
2652: LIST
2653: LIST
2654: PUSH
2655: LD_INT 17
2657: PUSH
2658: LD_INT 190
2660: PUSH
2661: LD_INT 161
2663: PUSH
2664: LD_INT 1
2666: PUSH
2667: LD_INT 0
2669: PUSH
2670: LD_INT 0
2672: PUSH
2673: EMPTY
2674: LIST
2675: LIST
2676: LIST
2677: LIST
2678: LIST
2679: LIST
2680: PUSH
2681: LD_INT 5
2683: PUSH
2684: LD_INT 200
2686: PUSH
2687: LD_INT 145
2689: PUSH
2690: LD_INT 3
2692: PUSH
2693: LD_INT 0
2695: PUSH
2696: LD_INT 0
2698: PUSH
2699: EMPTY
2700: LIST
2701: LIST
2702: LIST
2703: LIST
2704: LIST
2705: LIST
2706: PUSH
2707: LD_INT 32
2709: PUSH
2710: LD_INT 192
2712: PUSH
2713: LD_INT 144
2715: PUSH
2716: LD_INT 3
2718: PUSH
2719: LD_INT 0
2721: PUSH
2722: LD_INT 0
2724: PUSH
2725: EMPTY
2726: LIST
2727: LIST
2728: LIST
2729: LIST
2730: LIST
2731: LIST
2732: PUSH
2733: LD_INT 26
2735: PUSH
2736: LD_INT 216
2738: PUSH
2739: LD_INT 172
2741: PUSH
2742: LD_INT 3
2744: PUSH
2745: LD_INT 0
2747: PUSH
2748: LD_INT 0
2750: PUSH
2751: EMPTY
2752: LIST
2753: LIST
2754: LIST
2755: LIST
2756: LIST
2757: LIST
2758: PUSH
2759: LD_INT 26
2761: PUSH
2762: LD_INT 218
2764: PUSH
2765: LD_INT 176
2767: PUSH
2768: LD_INT 3
2770: PUSH
2771: LD_INT 0
2773: PUSH
2774: LD_INT 0
2776: PUSH
2777: EMPTY
2778: LIST
2779: LIST
2780: LIST
2781: LIST
2782: LIST
2783: LIST
2784: PUSH
2785: LD_INT 29
2787: PUSH
2788: LD_INT 182
2790: PUSH
2791: LD_INT 149
2793: PUSH
2794: LD_INT 3
2796: PUSH
2797: LD_INT 0
2799: PUSH
2800: LD_INT 0
2802: PUSH
2803: EMPTY
2804: LIST
2805: LIST
2806: LIST
2807: LIST
2808: LIST
2809: LIST
2810: PUSH
2811: LD_INT 8
2813: PUSH
2814: LD_INT 201
2816: PUSH
2817: LD_INT 171
2819: PUSH
2820: LD_INT 0
2822: PUSH
2823: LD_INT 10
2825: PUSH
2826: LD_INT 11
2828: PUSH
2829: EMPTY
2830: LIST
2831: LIST
2832: LIST
2833: LIST
2834: LIST
2835: LIST
2836: PUSH
2837: LD_INT 32
2839: PUSH
2840: LD_INT 188
2842: PUSH
2843: LD_INT 167
2845: PUSH
2846: LD_INT 0
2848: PUSH
2849: LD_INT 0
2851: PUSH
2852: LD_INT 0
2854: PUSH
2855: EMPTY
2856: LIST
2857: LIST
2858: LIST
2859: LIST
2860: LIST
2861: LIST
2862: PUSH
2863: LD_INT 32
2865: PUSH
2866: LD_INT 202
2868: PUSH
2869: LD_INT 179
2871: PUSH
2872: LD_INT 0
2874: PUSH
2875: LD_INT 0
2877: PUSH
2878: LD_INT 0
2880: PUSH
2881: EMPTY
2882: LIST
2883: LIST
2884: LIST
2885: LIST
2886: LIST
2887: LIST
2888: PUSH
2889: LD_INT 32
2891: PUSH
2892: LD_INT 209
2894: PUSH
2895: LD_INT 182
2897: PUSH
2898: LD_INT 0
2900: PUSH
2901: LD_INT 0
2903: PUSH
2904: LD_INT 0
2906: PUSH
2907: EMPTY
2908: LIST
2909: LIST
2910: LIST
2911: LIST
2912: LIST
2913: LIST
2914: PUSH
2915: LD_INT 32
2917: PUSH
2918: LD_INT 220
2920: PUSH
2921: LD_INT 183
2923: PUSH
2924: LD_INT 5
2926: PUSH
2927: LD_INT 0
2929: PUSH
2930: LD_INT 0
2932: PUSH
2933: EMPTY
2934: LIST
2935: LIST
2936: LIST
2937: LIST
2938: LIST
2939: LIST
2940: PUSH
2941: LD_INT 32
2943: PUSH
2944: LD_INT 225
2946: PUSH
2947: LD_INT 181
2949: PUSH
2950: LD_INT 5
2952: PUSH
2953: LD_INT 0
2955: PUSH
2956: LD_INT 0
2958: PUSH
2959: EMPTY
2960: LIST
2961: LIST
2962: LIST
2963: LIST
2964: LIST
2965: LIST
2966: PUSH
2967: LD_INT 26
2969: PUSH
2970: LD_INT 220
2972: PUSH
2973: LD_INT 174
2975: PUSH
2976: LD_INT 5
2978: PUSH
2979: LD_INT 0
2981: PUSH
2982: LD_INT 0
2984: PUSH
2985: EMPTY
2986: LIST
2987: LIST
2988: LIST
2989: LIST
2990: LIST
2991: LIST
2992: PUSH
2993: LD_INT 1
2995: PUSH
2996: LD_INT 84
2998: PUSH
2999: LD_INT 128
3001: PUSH
3002: LD_INT 4
3004: PUSH
3005: LD_INT 0
3007: PUSH
3008: LD_INT 0
3010: PUSH
3011: EMPTY
3012: LIST
3013: LIST
3014: LIST
3015: LIST
3016: LIST
3017: LIST
3018: PUSH
3019: LD_INT 3
3021: PUSH
3022: LD_INT 68
3024: PUSH
3025: LD_INT 121
3027: PUSH
3028: LD_INT 1
3030: PUSH
3031: LD_INT 0
3033: PUSH
3034: LD_INT 0
3036: PUSH
3037: EMPTY
3038: LIST
3039: LIST
3040: LIST
3041: LIST
3042: LIST
3043: LIST
3044: PUSH
3045: LD_INT 19
3047: PUSH
3048: LD_INT 72
3050: PUSH
3051: LD_INT 125
3053: PUSH
3054: LD_INT 5
3056: PUSH
3057: LD_INT 0
3059: PUSH
3060: LD_INT 0
3062: PUSH
3063: EMPTY
3064: LIST
3065: LIST
3066: LIST
3067: LIST
3068: LIST
3069: LIST
3070: PUSH
3071: LD_INT 18
3073: PUSH
3074: LD_INT 68
3076: PUSH
3077: LD_INT 124
3079: PUSH
3080: LD_INT 0
3082: PUSH
3083: LD_INT 0
3085: PUSH
3086: LD_INT 0
3088: PUSH
3089: EMPTY
3090: LIST
3091: LIST
3092: LIST
3093: LIST
3094: LIST
3095: LIST
3096: PUSH
3097: LD_INT 24
3099: PUSH
3100: LD_INT 64
3102: PUSH
3103: LD_INT 121
3105: PUSH
3106: LD_INT 1
3108: PUSH
3109: LD_INT 0
3111: PUSH
3112: LD_INT 0
3114: PUSH
3115: EMPTY
3116: LIST
3117: LIST
3118: LIST
3119: LIST
3120: LIST
3121: LIST
3122: PUSH
3123: LD_INT 17
3125: PUSH
3126: LD_INT 65
3128: PUSH
3129: LD_INT 118
3131: PUSH
3132: LD_INT 2
3134: PUSH
3135: LD_INT 0
3137: PUSH
3138: LD_INT 0
3140: PUSH
3141: EMPTY
3142: LIST
3143: LIST
3144: LIST
3145: LIST
3146: LIST
3147: LIST
3148: PUSH
3149: LD_INT 21
3151: PUSH
3152: LD_INT 68
3154: PUSH
3155: LD_INT 117
3157: PUSH
3158: LD_INT 3
3160: PUSH
3161: LD_INT 0
3163: PUSH
3164: LD_INT 0
3166: PUSH
3167: EMPTY
3168: LIST
3169: LIST
3170: LIST
3171: LIST
3172: LIST
3173: LIST
3174: PUSH
3175: LD_INT 8
3177: PUSH
3178: LD_INT 68
3180: PUSH
3181: LD_INT 130
3183: PUSH
3184: LD_INT 1
3186: PUSH
3187: LD_INT 14
3189: PUSH
3190: LD_INT 10
3192: PUSH
3193: EMPTY
3194: LIST
3195: LIST
3196: LIST
3197: LIST
3198: LIST
3199: LIST
3200: PUSH
3201: LD_INT 8
3203: PUSH
3204: LD_INT 67
3206: PUSH
3207: LD_INT 110
3209: PUSH
3210: LD_INT 2
3212: PUSH
3213: LD_INT 11
3215: PUSH
3216: LD_INT 12
3218: PUSH
3219: EMPTY
3220: LIST
3221: LIST
3222: LIST
3223: LIST
3224: LIST
3225: LIST
3226: PUSH
3227: LD_INT 28
3229: PUSH
3230: LD_INT 85
3232: PUSH
3233: LD_INT 108
3235: PUSH
3236: LD_INT 2
3238: PUSH
3239: LD_INT 0
3241: PUSH
3242: LD_INT 0
3244: PUSH
3245: EMPTY
3246: LIST
3247: LIST
3248: LIST
3249: LIST
3250: LIST
3251: LIST
3252: PUSH
3253: LD_INT 28
3255: PUSH
3256: LD_INT 85
3258: PUSH
3259: LD_INT 124
3261: PUSH
3262: LD_INT 2
3264: PUSH
3265: LD_INT 0
3267: PUSH
3268: LD_INT 0
3270: PUSH
3271: EMPTY
3272: LIST
3273: LIST
3274: LIST
3275: LIST
3276: LIST
3277: LIST
3278: PUSH
3279: LD_INT 30
3281: PUSH
3282: LD_INT 97
3284: PUSH
3285: LD_INT 119
3287: PUSH
3288: LD_INT 2
3290: PUSH
3291: LD_INT 0
3293: PUSH
3294: LD_INT 0
3296: PUSH
3297: EMPTY
3298: LIST
3299: LIST
3300: LIST
3301: LIST
3302: LIST
3303: LIST
3304: PUSH
3305: LD_INT 5
3307: PUSH
3308: LD_INT 111
3310: PUSH
3311: LD_INT 138
3313: PUSH
3314: LD_INT 4
3316: PUSH
3317: LD_INT 0
3319: PUSH
3320: LD_INT 0
3322: PUSH
3323: EMPTY
3324: LIST
3325: LIST
3326: LIST
3327: LIST
3328: LIST
3329: LIST
3330: PUSH
3331: LD_INT 33
3333: PUSH
3334: LD_INT 104
3336: PUSH
3337: LD_INT 130
3339: PUSH
3340: LD_INT 3
3342: PUSH
3343: LD_INT 0
3345: PUSH
3346: LD_INT 0
3348: PUSH
3349: EMPTY
3350: LIST
3351: LIST
3352: LIST
3353: LIST
3354: LIST
3355: LIST
3356: PUSH
3357: LD_INT 33
3359: PUSH
3360: LD_INT 110
3362: PUSH
3363: LD_INT 142
3365: PUSH
3366: LD_INT 5
3368: PUSH
3369: LD_INT 0
3371: PUSH
3372: LD_INT 0
3374: PUSH
3375: EMPTY
3376: LIST
3377: LIST
3378: LIST
3379: LIST
3380: LIST
3381: LIST
3382: PUSH
3383: LD_INT 33
3385: PUSH
3386: LD_INT 91
3388: PUSH
3389: LD_INT 131
3391: PUSH
3392: LD_INT 5
3394: PUSH
3395: LD_INT 0
3397: PUSH
3398: LD_INT 0
3400: PUSH
3401: EMPTY
3402: LIST
3403: LIST
3404: LIST
3405: LIST
3406: LIST
3407: LIST
3408: PUSH
3409: LD_INT 33
3411: PUSH
3412: LD_INT 107
3414: PUSH
3415: LD_INT 157
3417: PUSH
3418: LD_INT 5
3420: PUSH
3421: LD_INT 0
3423: PUSH
3424: LD_INT 0
3426: PUSH
3427: EMPTY
3428: LIST
3429: LIST
3430: LIST
3431: LIST
3432: LIST
3433: LIST
3434: PUSH
3435: LD_INT 33
3437: PUSH
3438: LD_INT 104
3440: PUSH
3441: LD_INT 160
3443: PUSH
3444: LD_INT 5
3446: PUSH
3447: LD_INT 0
3449: PUSH
3450: LD_INT 0
3452: PUSH
3453: EMPTY
3454: LIST
3455: LIST
3456: LIST
3457: LIST
3458: LIST
3459: LIST
3460: PUSH
3461: LD_INT 33
3463: PUSH
3464: LD_INT 101
3466: PUSH
3467: LD_INT 162
3469: PUSH
3470: LD_INT 5
3472: PUSH
3473: LD_INT 0
3475: PUSH
3476: LD_INT 0
3478: PUSH
3479: EMPTY
3480: LIST
3481: LIST
3482: LIST
3483: LIST
3484: LIST
3485: LIST
3486: PUSH
3487: LD_INT 32
3489: PUSH
3490: LD_INT 87
3492: PUSH
3493: LD_INT 157
3495: PUSH
3496: LD_INT 5
3498: PUSH
3499: LD_INT 0
3501: PUSH
3502: LD_INT 0
3504: PUSH
3505: EMPTY
3506: LIST
3507: LIST
3508: LIST
3509: LIST
3510: LIST
3511: LIST
3512: PUSH
3513: LD_INT 32
3515: PUSH
3516: LD_INT 105
3518: PUSH
3519: LD_INT 158
3521: PUSH
3522: LD_INT 5
3524: PUSH
3525: LD_INT 0
3527: PUSH
3528: LD_INT 0
3530: PUSH
3531: EMPTY
3532: LIST
3533: LIST
3534: LIST
3535: LIST
3536: LIST
3537: LIST
3538: PUSH
3539: LD_INT 33
3541: PUSH
3542: LD_INT 91
3544: PUSH
3545: LD_INT 118
3547: PUSH
3548: LD_INT 4
3550: PUSH
3551: LD_INT 0
3553: PUSH
3554: LD_INT 0
3556: PUSH
3557: EMPTY
3558: LIST
3559: LIST
3560: LIST
3561: LIST
3562: LIST
3563: LIST
3564: PUSH
3565: LD_INT 33
3567: PUSH
3568: LD_INT 89
3570: PUSH
3571: LD_INT 107
3573: PUSH
3574: LD_INT 4
3576: PUSH
3577: LD_INT 0
3579: PUSH
3580: LD_INT 0
3582: PUSH
3583: EMPTY
3584: LIST
3585: LIST
3586: LIST
3587: LIST
3588: LIST
3589: LIST
3590: PUSH
3591: LD_INT 5
3593: PUSH
3594: LD_INT 86
3596: PUSH
3597: LD_INT 96
3599: PUSH
3600: LD_INT 3
3602: PUSH
3603: LD_INT 0
3605: PUSH
3606: LD_INT 0
3608: PUSH
3609: EMPTY
3610: LIST
3611: LIST
3612: LIST
3613: LIST
3614: LIST
3615: LIST
3616: PUSH
3617: LD_INT 33
3619: PUSH
3620: LD_INT 91
3622: PUSH
3623: LD_INT 102
3625: PUSH
3626: LD_INT 4
3628: PUSH
3629: LD_INT 0
3631: PUSH
3632: LD_INT 0
3634: PUSH
3635: EMPTY
3636: LIST
3637: LIST
3638: LIST
3639: LIST
3640: LIST
3641: LIST
3642: PUSH
3643: LD_INT 32
3645: PUSH
3646: LD_INT 80
3648: PUSH
3649: LD_INT 95
3651: PUSH
3652: LD_INT 3
3654: PUSH
3655: LD_INT 0
3657: PUSH
3658: LD_INT 0
3660: PUSH
3661: EMPTY
3662: LIST
3663: LIST
3664: LIST
3665: LIST
3666: LIST
3667: LIST
3668: PUSH
3669: LD_INT 28
3671: PUSH
3672: LD_INT 77
3674: PUSH
3675: LD_INT 105
3677: PUSH
3678: LD_INT 3
3680: PUSH
3681: LD_INT 0
3683: PUSH
3684: LD_INT 0
3686: PUSH
3687: EMPTY
3688: LIST
3689: LIST
3690: LIST
3691: LIST
3692: LIST
3693: LIST
3694: PUSH
3695: LD_INT 28
3697: PUSH
3698: LD_INT 85
3700: PUSH
3701: LD_INT 113
3703: PUSH
3704: LD_INT 3
3706: PUSH
3707: LD_INT 0
3709: PUSH
3710: LD_INT 0
3712: PUSH
3713: EMPTY
3714: LIST
3715: LIST
3716: LIST
3717: LIST
3718: LIST
3719: LIST
3720: PUSH
3721: LD_INT 28
3723: PUSH
3724: LD_INT 55
3726: PUSH
3727: LD_INT 97
3729: PUSH
3730: LD_INT 3
3732: PUSH
3733: LD_INT 0
3735: PUSH
3736: LD_INT 0
3738: PUSH
3739: EMPTY
3740: LIST
3741: LIST
3742: LIST
3743: LIST
3744: LIST
3745: LIST
3746: PUSH
3747: LD_INT 28
3749: PUSH
3750: LD_INT 88
3752: PUSH
3753: LD_INT 128
3755: PUSH
3756: LD_INT 3
3758: PUSH
3759: LD_INT 0
3761: PUSH
3762: LD_INT 0
3764: PUSH
3765: EMPTY
3766: LIST
3767: LIST
3768: LIST
3769: LIST
3770: LIST
3771: LIST
3772: PUSH
3773: LD_INT 32
3775: PUSH
3776: LD_INT 69
3778: PUSH
3779: LD_INT 101
3781: PUSH
3782: LD_INT 2
3784: PUSH
3785: LD_INT 0
3787: PUSH
3788: LD_INT 0
3790: PUSH
3791: EMPTY
3792: LIST
3793: LIST
3794: LIST
3795: LIST
3796: LIST
3797: LIST
3798: PUSH
3799: LD_INT 1
3801: PUSH
3802: LD_INT 34
3804: PUSH
3805: LD_INT 23
3807: PUSH
3808: LD_INT 4
3810: PUSH
3811: LD_INT 0
3813: PUSH
3814: LD_INT 0
3816: PUSH
3817: EMPTY
3818: LIST
3819: LIST
3820: LIST
3821: LIST
3822: LIST
3823: LIST
3824: PUSH
3825: LD_INT 8
3827: PUSH
3828: LD_INT 25
3830: PUSH
3831: LD_INT 4
3833: PUSH
3834: LD_INT 3
3836: PUSH
3837: LD_INT 11
3839: PUSH
3840: LD_INT 10
3842: PUSH
3843: EMPTY
3844: LIST
3845: LIST
3846: LIST
3847: LIST
3848: LIST
3849: LIST
3850: PUSH
3851: LD_INT 8
3853: PUSH
3854: LD_INT 15
3856: PUSH
3857: LD_INT 4
3859: PUSH
3860: LD_INT 2
3862: PUSH
3863: LD_INT 14
3865: PUSH
3866: LD_INT 12
3868: PUSH
3869: EMPTY
3870: LIST
3871: LIST
3872: LIST
3873: LIST
3874: LIST
3875: LIST
3876: PUSH
3877: LD_INT 29
3879: PUSH
3880: LD_INT 55
3882: PUSH
3883: LD_INT 35
3885: PUSH
3886: LD_INT 2
3888: PUSH
3889: LD_INT 0
3891: PUSH
3892: LD_INT 0
3894: PUSH
3895: EMPTY
3896: LIST
3897: LIST
3898: LIST
3899: LIST
3900: LIST
3901: LIST
3902: PUSH
3903: LD_INT 29
3905: PUSH
3906: LD_INT 24
3908: PUSH
3909: LD_INT 44
3911: PUSH
3912: LD_INT 2
3914: PUSH
3915: LD_INT 0
3917: PUSH
3918: LD_INT 0
3920: PUSH
3921: EMPTY
3922: LIST
3923: LIST
3924: LIST
3925: LIST
3926: LIST
3927: LIST
3928: PUSH
3929: LD_INT 34
3931: PUSH
3932: LD_INT 34
3934: PUSH
3935: LD_INT 32
3937: PUSH
3938: LD_INT 4
3940: PUSH
3941: LD_INT 0
3943: PUSH
3944: LD_INT 0
3946: PUSH
3947: EMPTY
3948: LIST
3949: LIST
3950: LIST
3951: LIST
3952: LIST
3953: LIST
3954: PUSH
3955: LD_INT 3
3957: PUSH
3958: LD_INT 14
3960: PUSH
3961: LD_INT 16
3963: PUSH
3964: LD_INT 1
3966: PUSH
3967: LD_INT 0
3969: PUSH
3970: LD_INT 0
3972: PUSH
3973: EMPTY
3974: LIST
3975: LIST
3976: LIST
3977: LIST
3978: LIST
3979: LIST
3980: PUSH
3981: LD_INT 24
3983: PUSH
3984: LD_INT 10
3986: PUSH
3987: LD_INT 16
3989: PUSH
3990: LD_INT 1
3992: PUSH
3993: LD_INT 0
3995: PUSH
3996: LD_INT 0
3998: PUSH
3999: EMPTY
4000: LIST
4001: LIST
4002: LIST
4003: LIST
4004: LIST
4005: LIST
4006: PUSH
4007: LD_INT 21
4009: PUSH
4010: LD_INT 11
4012: PUSH
4013: LD_INT 13
4015: PUSH
4016: LD_INT 2
4018: PUSH
4019: LD_INT 0
4021: PUSH
4022: LD_INT 0
4024: PUSH
4025: EMPTY
4026: LIST
4027: LIST
4028: LIST
4029: LIST
4030: LIST
4031: LIST
4032: PUSH
4033: LD_INT 18
4035: PUSH
4036: LD_INT 14
4038: PUSH
4039: LD_INT 12
4041: PUSH
4042: LD_INT 3
4044: PUSH
4045: LD_INT 0
4047: PUSH
4048: LD_INT 0
4050: PUSH
4051: EMPTY
4052: LIST
4053: LIST
4054: LIST
4055: LIST
4056: LIST
4057: LIST
4058: PUSH
4059: LD_INT 16
4061: PUSH
4062: LD_INT 14
4064: PUSH
4065: LD_INT 19
4067: PUSH
4068: LD_INT 0
4070: PUSH
4071: LD_INT 0
4073: PUSH
4074: LD_INT 0
4076: PUSH
4077: EMPTY
4078: LIST
4079: LIST
4080: LIST
4081: LIST
4082: LIST
4083: LIST
4084: PUSH
4085: LD_INT 17
4087: PUSH
4088: LD_INT 18
4090: PUSH
4091: LD_INT 20
4093: PUSH
4094: LD_INT 5
4096: PUSH
4097: LD_INT 0
4099: PUSH
4100: LD_INT 0
4102: PUSH
4103: EMPTY
4104: LIST
4105: LIST
4106: LIST
4107: LIST
4108: LIST
4109: LIST
4110: PUSH
4111: LD_INT 28
4113: PUSH
4114: LD_INT 10
4116: PUSH
4117: LD_INT 5
4119: PUSH
4120: LD_INT 1
4122: PUSH
4123: LD_INT 0
4125: PUSH
4126: LD_INT 0
4128: PUSH
4129: EMPTY
4130: LIST
4131: LIST
4132: LIST
4133: LIST
4134: LIST
4135: LIST
4136: PUSH
4137: LD_INT 28
4139: PUSH
4140: LD_INT 8
4142: PUSH
4143: LD_INT 8
4145: PUSH
4146: LD_INT 1
4148: PUSH
4149: LD_INT 0
4151: PUSH
4152: LD_INT 0
4154: PUSH
4155: EMPTY
4156: LIST
4157: LIST
4158: LIST
4159: LIST
4160: LIST
4161: LIST
4162: PUSH
4163: LD_INT 26
4165: PUSH
4166: LD_INT 19
4168: PUSH
4169: LD_INT 2
4171: PUSH
4172: LD_INT 1
4174: PUSH
4175: LD_INT 0
4177: PUSH
4178: LD_INT 0
4180: PUSH
4181: EMPTY
4182: LIST
4183: LIST
4184: LIST
4185: LIST
4186: LIST
4187: LIST
4188: PUSH
4189: LD_INT 26
4191: PUSH
4192: LD_INT 30
4194: PUSH
4195: LD_INT 2
4197: PUSH
4198: LD_INT 1
4200: PUSH
4201: LD_INT 0
4203: PUSH
4204: LD_INT 0
4206: PUSH
4207: EMPTY
4208: LIST
4209: LIST
4210: LIST
4211: LIST
4212: LIST
4213: LIST
4214: PUSH
4215: LD_INT 5
4217: PUSH
4218: LD_INT 59
4220: PUSH
4221: LD_INT 20
4223: PUSH
4224: LD_INT 4
4226: PUSH
4227: LD_INT 0
4229: PUSH
4230: LD_INT 0
4232: PUSH
4233: EMPTY
4234: LIST
4235: LIST
4236: LIST
4237: LIST
4238: LIST
4239: LIST
4240: PUSH
4241: LD_INT 32
4243: PUSH
4244: LD_INT 60
4246: PUSH
4247: LD_INT 24
4249: PUSH
4250: LD_INT 4
4252: PUSH
4253: LD_INT 0
4255: PUSH
4256: LD_INT 0
4258: PUSH
4259: EMPTY
4260: LIST
4261: LIST
4262: LIST
4263: LIST
4264: LIST
4265: LIST
4266: PUSH
4267: LD_INT 32
4269: PUSH
4270: LD_INT 61
4272: PUSH
4273: LD_INT 45
4275: PUSH
4276: LD_INT 5
4278: PUSH
4279: LD_INT 0
4281: PUSH
4282: LD_INT 0
4284: PUSH
4285: EMPTY
4286: LIST
4287: LIST
4288: LIST
4289: LIST
4290: LIST
4291: LIST
4292: PUSH
4293: LD_INT 32
4295: PUSH
4296: LD_INT 52
4298: PUSH
4299: LD_INT 51
4301: PUSH
4302: LD_INT 5
4304: PUSH
4305: LD_INT 0
4307: PUSH
4308: LD_INT 0
4310: PUSH
4311: EMPTY
4312: LIST
4313: LIST
4314: LIST
4315: LIST
4316: LIST
4317: LIST
4318: PUSH
4319: LD_INT 33
4321: PUSH
4322: LD_INT 56
4324: PUSH
4325: LD_INT 51
4327: PUSH
4328: LD_INT 5
4330: PUSH
4331: LD_INT 0
4333: PUSH
4334: LD_INT 0
4336: PUSH
4337: EMPTY
4338: LIST
4339: LIST
4340: LIST
4341: LIST
4342: LIST
4343: LIST
4344: PUSH
4345: LD_INT 33
4347: PUSH
4348: LD_INT 62
4350: PUSH
4351: LD_INT 49
4353: PUSH
4354: LD_INT 5
4356: PUSH
4357: LD_INT 0
4359: PUSH
4360: LD_INT 0
4362: PUSH
4363: EMPTY
4364: LIST
4365: LIST
4366: LIST
4367: LIST
4368: LIST
4369: LIST
4370: PUSH
4371: LD_INT 33
4373: PUSH
4374: LD_INT 41
4376: PUSH
4377: LD_INT 47
4379: PUSH
4380: LD_INT 5
4382: PUSH
4383: LD_INT 0
4385: PUSH
4386: LD_INT 0
4388: PUSH
4389: EMPTY
4390: LIST
4391: LIST
4392: LIST
4393: LIST
4394: LIST
4395: LIST
4396: PUSH
4397: LD_INT 33
4399: PUSH
4400: LD_INT 33
4402: PUSH
4403: LD_INT 52
4405: PUSH
4406: LD_INT 5
4408: PUSH
4409: LD_INT 0
4411: PUSH
4412: LD_INT 0
4414: PUSH
4415: EMPTY
4416: LIST
4417: LIST
4418: LIST
4419: LIST
4420: LIST
4421: LIST
4422: PUSH
4423: LD_INT 5
4425: PUSH
4426: LD_INT 31
4428: PUSH
4429: LD_INT 40
4431: PUSH
4432: LD_INT 0
4434: PUSH
4435: LD_INT 0
4437: PUSH
4438: LD_INT 0
4440: PUSH
4441: EMPTY
4442: LIST
4443: LIST
4444: LIST
4445: LIST
4446: LIST
4447: LIST
4448: PUSH
4449: LD_INT 33
4451: PUSH
4452: LD_INT 65
4454: PUSH
4455: LD_INT 37
4457: PUSH
4458: LD_INT 5
4460: PUSH
4461: LD_INT 0
4463: PUSH
4464: LD_INT 0
4466: PUSH
4467: EMPTY
4468: LIST
4469: LIST
4470: LIST
4471: LIST
4472: LIST
4473: LIST
4474: PUSH
4475: LD_INT 33
4477: PUSH
4478: LD_INT 63
4480: PUSH
4481: LD_INT 29
4483: PUSH
4484: LD_INT 4
4486: PUSH
4487: LD_INT 0
4489: PUSH
4490: LD_INT 0
4492: PUSH
4493: EMPTY
4494: LIST
4495: LIST
4496: LIST
4497: LIST
4498: LIST
4499: LIST
4500: PUSH
4501: LD_INT 33
4503: PUSH
4504: LD_INT 54
4506: PUSH
4507: LD_INT 11
4509: PUSH
4510: LD_INT 4
4512: PUSH
4513: LD_INT 0
4515: PUSH
4516: LD_INT 0
4518: PUSH
4519: EMPTY
4520: LIST
4521: LIST
4522: LIST
4523: LIST
4524: LIST
4525: LIST
4526: PUSH
4527: LD_INT 33
4529: PUSH
4530: LD_INT 56
4532: PUSH
4533: LD_INT 15
4535: PUSH
4536: LD_INT 4
4538: PUSH
4539: LD_INT 0
4541: PUSH
4542: LD_INT 0
4544: PUSH
4545: EMPTY
4546: LIST
4547: LIST
4548: LIST
4549: LIST
4550: LIST
4551: LIST
4552: PUSH
4553: LD_INT 33
4555: PUSH
4556: LD_INT 51
4558: PUSH
4559: LD_INT 6
4561: PUSH
4562: LD_INT 4
4564: PUSH
4565: LD_INT 0
4567: PUSH
4568: LD_INT 0
4570: PUSH
4571: EMPTY
4572: LIST
4573: LIST
4574: LIST
4575: LIST
4576: LIST
4577: LIST
4578: PUSH
4579: LD_INT 26
4581: PUSH
4582: LD_INT 39
4584: PUSH
4585: LD_INT 25
4587: PUSH
4588: LD_INT 0
4590: PUSH
4591: LD_INT 0
4593: PUSH
4594: LD_INT 0
4596: PUSH
4597: EMPTY
4598: LIST
4599: LIST
4600: LIST
4601: LIST
4602: LIST
4603: LIST
4604: PUSH
4605: LD_INT 26
4607: PUSH
4608: LD_INT 37
4610: PUSH
4611: LD_INT 21
4613: PUSH
4614: LD_INT 0
4616: PUSH
4617: LD_INT 0
4619: PUSH
4620: LD_INT 0
4622: PUSH
4623: EMPTY
4624: LIST
4625: LIST
4626: LIST
4627: LIST
4628: LIST
4629: LIST
4630: PUSH
4631: LD_INT 32
4633: PUSH
4634: LD_INT 35
4636: PUSH
4637: LD_INT 17
4639: PUSH
4640: LD_INT 4
4642: PUSH
4643: LD_INT 0
4645: PUSH
4646: LD_INT 0
4648: PUSH
4649: EMPTY
4650: LIST
4651: LIST
4652: LIST
4653: LIST
4654: LIST
4655: LIST
4656: PUSH
4657: LD_INT 33
4659: PUSH
4660: LD_INT 35
4662: PUSH
4663: LD_INT 28
4665: PUSH
4666: LD_INT 4
4668: PUSH
4669: LD_INT 0
4671: PUSH
4672: LD_INT 0
4674: PUSH
4675: EMPTY
4676: LIST
4677: LIST
4678: LIST
4679: LIST
4680: LIST
4681: LIST
4682: PUSH
4683: LD_INT 33
4685: PUSH
4686: LD_INT 28
4688: PUSH
4689: LD_INT 46
4691: PUSH
4692: LD_INT 5
4694: PUSH
4695: LD_INT 0
4697: PUSH
4698: LD_INT 0
4700: PUSH
4701: EMPTY
4702: LIST
4703: LIST
4704: LIST
4705: LIST
4706: LIST
4707: LIST
4708: PUSH
4709: LD_INT 33
4711: PUSH
4712: LD_INT 31
4714: PUSH
4715: LD_INT 6
4717: PUSH
4718: LD_INT 4
4720: PUSH
4721: LD_INT 0
4723: PUSH
4724: LD_INT 0
4726: PUSH
4727: EMPTY
4728: LIST
4729: LIST
4730: LIST
4731: LIST
4732: LIST
4733: LIST
4734: PUSH
4735: LD_INT 26
4737: PUSH
4738: LD_INT 54
4740: PUSH
4741: LD_INT 38
4743: PUSH
4744: LD_INT 4
4746: PUSH
4747: LD_INT 0
4749: PUSH
4750: LD_INT 0
4752: PUSH
4753: EMPTY
4754: LIST
4755: LIST
4756: LIST
4757: LIST
4758: LIST
4759: LIST
4760: PUSH
4761: LD_INT 33
4763: PUSH
4764: LD_INT 207
4766: PUSH
4767: LD_INT 167
4769: PUSH
4770: LD_INT 3
4772: PUSH
4773: LD_INT 0
4775: PUSH
4776: LD_INT 0
4778: PUSH
4779: EMPTY
4780: LIST
4781: LIST
4782: LIST
4783: LIST
4784: LIST
4785: LIST
4786: PUSH
4787: LD_INT 30
4789: PUSH
4790: LD_INT 43
4792: PUSH
4793: LD_INT 2
4795: PUSH
4796: LD_INT 4
4798: PUSH
4799: LD_INT 0
4801: PUSH
4802: LD_INT 0
4804: PUSH
4805: EMPTY
4806: LIST
4807: LIST
4808: LIST
4809: LIST
4810: LIST
4811: LIST
4812: PUSH
4813: EMPTY
4814: LIST
4815: LIST
4816: LIST
4817: LIST
4818: LIST
4819: LIST
4820: LIST
4821: LIST
4822: LIST
4823: LIST
4824: LIST
4825: LIST
4826: LIST
4827: LIST
4828: LIST
4829: LIST
4830: LIST
4831: LIST
4832: LIST
4833: LIST
4834: LIST
4835: LIST
4836: LIST
4837: LIST
4838: LIST
4839: LIST
4840: LIST
4841: LIST
4842: LIST
4843: LIST
4844: LIST
4845: LIST
4846: LIST
4847: LIST
4848: LIST
4849: LIST
4850: LIST
4851: LIST
4852: LIST
4853: LIST
4854: LIST
4855: LIST
4856: LIST
4857: LIST
4858: LIST
4859: LIST
4860: LIST
4861: LIST
4862: LIST
4863: LIST
4864: LIST
4865: LIST
4866: LIST
4867: LIST
4868: LIST
4869: LIST
4870: LIST
4871: LIST
4872: LIST
4873: LIST
4874: LIST
4875: LIST
4876: LIST
4877: LIST
4878: LIST
4879: LIST
4880: LIST
4881: LIST
4882: LIST
4883: LIST
4884: LIST
4885: LIST
4886: LIST
4887: LIST
4888: LIST
4889: LIST
4890: LIST
4891: LIST
4892: LIST
4893: LIST
4894: LIST
4895: LIST
4896: LIST
4897: LIST
4898: LIST
4899: ST_TO_ADDR
// for i in tmp do
4900: LD_ADDR_VAR 0 2
4904: PUSH
4905: LD_VAR 0 4
4909: PUSH
4910: FOR_IN
4911: IFFALSE 5142
// begin uc_side := side ;
4913: LD_ADDR_OWVAR 20
4917: PUSH
4918: LD_VAR 0 5
4922: ST_TO_ADDR
// uc_nation := nation_russian ;
4923: LD_ADDR_OWVAR 21
4927: PUSH
4928: LD_INT 3
4930: ST_TO_ADDR
// bc_type := i [ 1 ] ;
4931: LD_ADDR_OWVAR 42
4935: PUSH
4936: LD_VAR 0 2
4940: PUSH
4941: LD_INT 1
4943: ARRAY
4944: ST_TO_ADDR
// bc_level := rand ( 5 , 6 ) ;
4945: LD_ADDR_OWVAR 43
4949: PUSH
4950: LD_INT 5
4952: PPUSH
4953: LD_INT 6
4955: PPUSH
4956: CALL_OW 12
4960: ST_TO_ADDR
// bc_kind1 := i [ 5 ] ;
4961: LD_ADDR_OWVAR 44
4965: PUSH
4966: LD_VAR 0 2
4970: PUSH
4971: LD_INT 5
4973: ARRAY
4974: ST_TO_ADDR
// bc_kind2 := i [ 6 ] ;
4975: LD_ADDR_OWVAR 45
4979: PUSH
4980: LD_VAR 0 2
4984: PUSH
4985: LD_INT 6
4987: ARRAY
4988: ST_TO_ADDR
// sr := 0 ;
4989: LD_ADDR_VAR 0 6
4993: PUSH
4994: LD_INT 0
4996: ST_TO_ADDR
// if i [ 1 ] = b_oil_mine then
4997: LD_VAR 0 2
5001: PUSH
5002: LD_INT 1
5004: ARRAY
5005: PUSH
5006: LD_INT 29
5008: EQUAL
5009: IFFALSE 5021
// sr := mat_oil else
5011: LD_ADDR_VAR 0 6
5015: PUSH
5016: LD_INT 2
5018: ST_TO_ADDR
5019: GO 5043
// if i [ 1 ] = b_siberite_mine then
5021: LD_VAR 0 2
5025: PUSH
5026: LD_INT 1
5028: ARRAY
5029: PUSH
5030: LD_INT 30
5032: EQUAL
5033: IFFALSE 5043
// sr := mat_siberit ;
5035: LD_ADDR_VAR 0 6
5039: PUSH
5040: LD_INT 3
5042: ST_TO_ADDR
// if sr then
5043: LD_VAR 0 6
5047: IFFALSE 5103
// begin CreateDepositXY ( i [ 2 ] , i [ 3 ] , sr ) ;
5049: LD_VAR 0 2
5053: PUSH
5054: LD_INT 2
5056: ARRAY
5057: PPUSH
5058: LD_VAR 0 2
5062: PUSH
5063: LD_INT 3
5065: ARRAY
5066: PPUSH
5067: LD_VAR 0 6
5071: PPUSH
5072: CALL_OW 62
// SetResourceVisibility ( i [ 2 ] , i [ 3 ] , side ) ;
5076: LD_VAR 0 2
5080: PUSH
5081: LD_INT 2
5083: ARRAY
5084: PPUSH
5085: LD_VAR 0 2
5089: PUSH
5090: LD_INT 3
5092: ARRAY
5093: PPUSH
5094: LD_VAR 0 5
5098: PPUSH
5099: CALL_OW 441
// end ; b := CreateAndPlaceBuildingXYD ( i [ 2 ] , i [ 3 ] , i [ 4 ] ) ;
5103: LD_ADDR_VAR 0 3
5107: PUSH
5108: LD_VAR 0 2
5112: PUSH
5113: LD_INT 2
5115: ARRAY
5116: PPUSH
5117: LD_VAR 0 2
5121: PUSH
5122: LD_INT 3
5124: ARRAY
5125: PPUSH
5126: LD_VAR 0 2
5130: PUSH
5131: LD_INT 4
5133: ARRAY
5134: PPUSH
5135: CALL_OW 47
5139: ST_TO_ADDR
// end ;
5140: GO 4910
5142: POP
5143: POP
// depot := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_warehouse ] ] ) ;
5144: LD_ADDR_VAR 0 7
5148: PUSH
5149: LD_INT 22
5151: PUSH
5152: LD_VAR 0 5
5156: PUSH
5157: EMPTY
5158: LIST
5159: LIST
5160: PUSH
5161: LD_INT 30
5163: PUSH
5164: LD_INT 1
5166: PUSH
5167: EMPTY
5168: LIST
5169: LIST
5170: PUSH
5171: EMPTY
5172: LIST
5173: LIST
5174: PPUSH
5175: CALL_OW 69
5179: ST_TO_ADDR
// if not depot then
5180: LD_VAR 0 7
5184: NOT
5185: IFFALSE 5189
// exit ;
5187: GO 5533
// base := PrepareBase ( HexInfo ( 84 , 128 ) , rus1Base , 0 , [ 6 , 7 , 8 ] [ Difficulty ] , [ 3000 , 300 , 100 ] , [ 12 , 6 , 6 , 4 ] ) ;
5189: LD_ADDR_VAR 0 8
5193: PUSH
5194: LD_INT 84
5196: PPUSH
5197: LD_INT 128
5199: PPUSH
5200: CALL_OW 428
5204: PPUSH
5205: LD_INT 15
5207: PPUSH
5208: LD_INT 0
5210: PPUSH
5211: LD_INT 6
5213: PUSH
5214: LD_INT 7
5216: PUSH
5217: LD_INT 8
5219: PUSH
5220: EMPTY
5221: LIST
5222: LIST
5223: LIST
5224: PUSH
5225: LD_OWVAR 67
5229: ARRAY
5230: PPUSH
5231: LD_INT 3000
5233: PUSH
5234: LD_INT 300
5236: PUSH
5237: LD_INT 100
5239: PUSH
5240: EMPTY
5241: LIST
5242: LIST
5243: LIST
5244: PPUSH
5245: LD_INT 12
5247: PUSH
5248: LD_INT 6
5250: PUSH
5251: LD_INT 6
5253: PUSH
5254: LD_INT 4
5256: PUSH
5257: EMPTY
5258: LIST
5259: LIST
5260: LIST
5261: LIST
5262: PPUSH
5263: CALL 28343 0 6
5267: ST_TO_ADDR
// if not base then
5268: LD_VAR 0 8
5272: NOT
5273: IFFALSE 5277
// exit ;
5275: GO 5533
// mc_bases := Replace ( mc_bases , mc_rus_1 , base ) ;
5277: LD_ADDR_EXP 31
5281: PUSH
5282: LD_EXP 31
5286: PPUSH
5287: LD_EXP 7
5291: PPUSH
5292: LD_VAR 0 8
5296: PPUSH
5297: CALL_OW 1
5301: ST_TO_ADDR
// base := PrepareBase ( HexInfo ( 34 , 23 ) , rus2Base , 0 , [ 6 , 7 , 8 ] [ Difficulty ] , [ 20000 , 3000 , 1000 ] , [ 12 , 6 , 6 , 4 ] ) ;
5302: LD_ADDR_VAR 0 8
5306: PUSH
5307: LD_INT 34
5309: PPUSH
5310: LD_INT 23
5312: PPUSH
5313: CALL_OW 428
5317: PPUSH
5318: LD_INT 11
5320: PPUSH
5321: LD_INT 0
5323: PPUSH
5324: LD_INT 6
5326: PUSH
5327: LD_INT 7
5329: PUSH
5330: LD_INT 8
5332: PUSH
5333: EMPTY
5334: LIST
5335: LIST
5336: LIST
5337: PUSH
5338: LD_OWVAR 67
5342: ARRAY
5343: PPUSH
5344: LD_INT 20000
5346: PUSH
5347: LD_INT 3000
5349: PUSH
5350: LD_INT 1000
5352: PUSH
5353: EMPTY
5354: LIST
5355: LIST
5356: LIST
5357: PPUSH
5358: LD_INT 12
5360: PUSH
5361: LD_INT 6
5363: PUSH
5364: LD_INT 6
5366: PUSH
5367: LD_INT 4
5369: PUSH
5370: EMPTY
5371: LIST
5372: LIST
5373: LIST
5374: LIST
5375: PPUSH
5376: CALL 28343 0 6
5380: ST_TO_ADDR
// if not base then
5381: LD_VAR 0 8
5385: NOT
5386: IFFALSE 5390
// exit ;
5388: GO 5533
// mc_bases := Replace ( mc_bases , mc_rus_2 , base ) ;
5390: LD_ADDR_EXP 31
5394: PUSH
5395: LD_EXP 31
5399: PPUSH
5400: LD_EXP 8
5404: PPUSH
5405: LD_VAR 0 8
5409: PPUSH
5410: CALL_OW 1
5414: ST_TO_ADDR
// ruOutpost := PrepareBase ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_depot ] ] ) [ 1 ] , ruOutpostArea , 0 , [ 6 , 7 , 8 ] [ Difficulty ] , [ 500 , 100 , 10 ] , [ [ 6 , 7 , 8 ] [ Difficulty ] , 2 , 0 , 1 ] ) ;
5415: LD_ADDR_EXP 14
5419: PUSH
5420: LD_INT 22
5422: PUSH
5423: LD_INT 3
5425: PUSH
5426: EMPTY
5427: LIST
5428: LIST
5429: PUSH
5430: LD_INT 30
5432: PUSH
5433: LD_INT 0
5435: PUSH
5436: EMPTY
5437: LIST
5438: LIST
5439: PUSH
5440: EMPTY
5441: LIST
5442: LIST
5443: PPUSH
5444: CALL_OW 69
5448: PUSH
5449: LD_INT 1
5451: ARRAY
5452: PPUSH
5453: LD_INT 25
5455: PPUSH
5456: LD_INT 0
5458: PPUSH
5459: LD_INT 6
5461: PUSH
5462: LD_INT 7
5464: PUSH
5465: LD_INT 8
5467: PUSH
5468: EMPTY
5469: LIST
5470: LIST
5471: LIST
5472: PUSH
5473: LD_OWVAR 67
5477: ARRAY
5478: PPUSH
5479: LD_INT 500
5481: PUSH
5482: LD_INT 100
5484: PUSH
5485: LD_INT 10
5487: PUSH
5488: EMPTY
5489: LIST
5490: LIST
5491: LIST
5492: PPUSH
5493: LD_INT 6
5495: PUSH
5496: LD_INT 7
5498: PUSH
5499: LD_INT 8
5501: PUSH
5502: EMPTY
5503: LIST
5504: LIST
5505: LIST
5506: PUSH
5507: LD_OWVAR 67
5511: ARRAY
5512: PUSH
5513: LD_INT 2
5515: PUSH
5516: LD_INT 0
5518: PUSH
5519: LD_INT 1
5521: PUSH
5522: EMPTY
5523: LIST
5524: LIST
5525: LIST
5526: LIST
5527: PPUSH
5528: CALL 28343 0 6
5532: ST_TO_ADDR
// end ;
5533: LD_VAR 0 1
5537: RET
// export function PrepareLegion ; var i , b , veh , tmp , tmp2 , cameras , side , sr , depot , base ; begin
5538: LD_INT 0
5540: PPUSH
5541: PPUSH
5542: PPUSH
5543: PPUSH
5544: PPUSH
5545: PPUSH
5546: PPUSH
5547: PPUSH
5548: PPUSH
5549: PPUSH
5550: PPUSH
// PrepareNature ( 0 , 0 , 6 , 0 , 0 , 0 , 0 , legApe , 0 ) ;
5551: LD_INT 0
5553: PPUSH
5554: LD_INT 0
5556: PPUSH
5557: LD_INT 6
5559: PPUSH
5560: LD_INT 0
5562: PPUSH
5563: LD_INT 0
5565: PPUSH
5566: LD_INT 0
5568: PPUSH
5569: LD_INT 0
5571: PPUSH
5572: LD_INT 8
5574: PPUSH
5575: LD_INT 0
5577: PPUSH
5578: CALL 54015 0 9
// side := 8 ;
5582: LD_ADDR_VAR 0 8
5586: PUSH
5587: LD_INT 8
5589: ST_TO_ADDR
// tmp := AreaToList ( minesArea , 0 ) ;
5590: LD_ADDR_VAR 0 5
5594: PUSH
5595: LD_INT 20
5597: PPUSH
5598: LD_INT 0
5600: PPUSH
5601: CALL_OW 517
5605: ST_TO_ADDR
// if Difficulty > 2 then
5606: LD_OWVAR 67
5610: PUSH
5611: LD_INT 2
5613: GREATER
5614: IFFALSE 5758
// begin tmp2 := AreaToList ( minesArea2 , 0 ) ;
5616: LD_ADDR_VAR 0 6
5620: PUSH
5621: LD_INT 27
5623: PPUSH
5624: LD_INT 0
5626: PPUSH
5627: CALL_OW 517
5631: ST_TO_ADDR
// for i = 1 to tmp2 [ 1 ] do
5632: LD_ADDR_VAR 0 2
5636: PUSH
5637: DOUBLE
5638: LD_INT 1
5640: DEC
5641: ST_TO_ADDR
5642: LD_VAR 0 6
5646: PUSH
5647: LD_INT 1
5649: ARRAY
5650: PUSH
5651: FOR_TO
5652: IFFALSE 5756
// begin tmp := ReplaceIn ( tmp , [ 1 , tmp [ 1 ] + 1 ] , tmp2 [ 1 ] [ i ] ) ;
5654: LD_ADDR_VAR 0 5
5658: PUSH
5659: LD_VAR 0 5
5663: PPUSH
5664: LD_INT 1
5666: PUSH
5667: LD_VAR 0 5
5671: PUSH
5672: LD_INT 1
5674: ARRAY
5675: PUSH
5676: LD_INT 1
5678: PLUS
5679: PUSH
5680: EMPTY
5681: LIST
5682: LIST
5683: PPUSH
5684: LD_VAR 0 6
5688: PUSH
5689: LD_INT 1
5691: ARRAY
5692: PUSH
5693: LD_VAR 0 2
5697: ARRAY
5698: PPUSH
5699: CALL 25021 0 3
5703: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 2 , tmp [ 2 ] + 1 ] , tmp2 [ 2 ] [ i ] ) ;
5704: LD_ADDR_VAR 0 5
5708: PUSH
5709: LD_VAR 0 5
5713: PPUSH
5714: LD_INT 2
5716: PUSH
5717: LD_VAR 0 5
5721: PUSH
5722: LD_INT 2
5724: ARRAY
5725: PUSH
5726: LD_INT 1
5728: PLUS
5729: PUSH
5730: EMPTY
5731: LIST
5732: LIST
5733: PPUSH
5734: LD_VAR 0 6
5738: PUSH
5739: LD_INT 2
5741: ARRAY
5742: PUSH
5743: LD_VAR 0 2
5747: ARRAY
5748: PPUSH
5749: CALL 25021 0 3
5753: ST_TO_ADDR
// end ;
5754: GO 5651
5756: POP
5757: POP
// end ; if tmp then
5758: LD_VAR 0 5
5762: IFFALSE 5890
// begin for i = 1 to tmp [ 1 ] do
5764: LD_ADDR_VAR 0 2
5768: PUSH
5769: DOUBLE
5770: LD_INT 1
5772: DEC
5773: ST_TO_ADDR
5774: LD_VAR 0 5
5778: PUSH
5779: LD_INT 1
5781: ARRAY
5782: PUSH
5783: FOR_TO
5784: IFFALSE 5888
// begin PlaceMine ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] , side , 0 ) ;
5786: LD_VAR 0 5
5790: PUSH
5791: LD_INT 1
5793: ARRAY
5794: PUSH
5795: LD_VAR 0 2
5799: ARRAY
5800: PPUSH
5801: LD_VAR 0 5
5805: PUSH
5806: LD_INT 2
5808: ARRAY
5809: PUSH
5810: LD_VAR 0 2
5814: ARRAY
5815: PPUSH
5816: LD_VAR 0 8
5820: PPUSH
5821: LD_INT 0
5823: PPUSH
5824: CALL_OW 454
// staticMines := Insert ( staticMines , staticMines + 1 , [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ) ;
5828: LD_ADDR_EXP 16
5832: PUSH
5833: LD_EXP 16
5837: PPUSH
5838: LD_EXP 16
5842: PUSH
5843: LD_INT 1
5845: PLUS
5846: PPUSH
5847: LD_VAR 0 5
5851: PUSH
5852: LD_INT 1
5854: ARRAY
5855: PUSH
5856: LD_VAR 0 2
5860: ARRAY
5861: PUSH
5862: LD_VAR 0 5
5866: PUSH
5867: LD_INT 2
5869: ARRAY
5870: PUSH
5871: LD_VAR 0 2
5875: ARRAY
5876: PUSH
5877: EMPTY
5878: LIST
5879: LIST
5880: PPUSH
5881: CALL_OW 2
5885: ST_TO_ADDR
// end ;
5886: GO 5783
5888: POP
5889: POP
// end ; cameras := [ [ 165 , 156 ] , [ 143 , 145 ] , [ 152 , 165 ] , [ 123 , 153 ] , [ 161 , 215 ] , [ 172 , 100 ] , [ 148 , 83 ] , [ 122 , 68 ] , [ 105 , 74 ] , [ 113 , 97 ] ] ;
5890: LD_ADDR_VAR 0 7
5894: PUSH
5895: LD_INT 165
5897: PUSH
5898: LD_INT 156
5900: PUSH
5901: EMPTY
5902: LIST
5903: LIST
5904: PUSH
5905: LD_INT 143
5907: PUSH
5908: LD_INT 145
5910: PUSH
5911: EMPTY
5912: LIST
5913: LIST
5914: PUSH
5915: LD_INT 152
5917: PUSH
5918: LD_INT 165
5920: PUSH
5921: EMPTY
5922: LIST
5923: LIST
5924: PUSH
5925: LD_INT 123
5927: PUSH
5928: LD_INT 153
5930: PUSH
5931: EMPTY
5932: LIST
5933: LIST
5934: PUSH
5935: LD_INT 161
5937: PUSH
5938: LD_INT 215
5940: PUSH
5941: EMPTY
5942: LIST
5943: LIST
5944: PUSH
5945: LD_INT 172
5947: PUSH
5948: LD_INT 100
5950: PUSH
5951: EMPTY
5952: LIST
5953: LIST
5954: PUSH
5955: LD_INT 148
5957: PUSH
5958: LD_INT 83
5960: PUSH
5961: EMPTY
5962: LIST
5963: LIST
5964: PUSH
5965: LD_INT 122
5967: PUSH
5968: LD_INT 68
5970: PUSH
5971: EMPTY
5972: LIST
5973: LIST
5974: PUSH
5975: LD_INT 105
5977: PUSH
5978: LD_INT 74
5980: PUSH
5981: EMPTY
5982: LIST
5983: LIST
5984: PUSH
5985: LD_INT 113
5987: PUSH
5988: LD_INT 97
5990: PUSH
5991: EMPTY
5992: LIST
5993: LIST
5994: PUSH
5995: EMPTY
5996: LIST
5997: LIST
5998: LIST
5999: LIST
6000: LIST
6001: LIST
6002: LIST
6003: LIST
6004: LIST
6005: LIST
6006: ST_TO_ADDR
// for i in cameras do
6007: LD_ADDR_VAR 0 2
6011: PUSH
6012: LD_VAR 0 7
6016: PUSH
6017: FOR_IN
6018: IFFALSE 6049
// HiddenCamera ( i [ 1 ] , i [ 2 ] , side ) ;
6020: LD_VAR 0 2
6024: PUSH
6025: LD_INT 1
6027: ARRAY
6028: PPUSH
6029: LD_VAR 0 2
6033: PUSH
6034: LD_INT 2
6036: ARRAY
6037: PPUSH
6038: LD_VAR 0 8
6042: PPUSH
6043: CALL_OW 244
6047: GO 6017
6049: POP
6050: POP
// tmp := [ [ 1 , 144 , 110 , 1 , 0 , 0 ] , [ 3 , 151 , 118 , 0 , 0 , 0 ] , [ 8 , 158 , 110 , 4 , 10 , 15 ] , [ 23 , 154 , 121 , 5 , 0 , 0 ] , [ 22 , 155 , 118 , 4 , 0 , 0 ] , [ 21 , 151 , 122 , 0 , 0 , 0 ] , [ 18 , 148 , 118 , 1 , 0 , 0 ] , [ 17 , 147 , 114 , 2 , 0 , 0 ] , [ 29 , 163 , 120 , 5 , 0 , 0 ] , [ 27 , 137 , 116 , 3 , 0 , 0 ] , [ 27 , 133 , 111 , 1 , 0 , 0 ] , [ 27 , 132 , 106 , 4 , 0 , 0 ] , [ 26 , 137 , 111 , 0 , 0 , 0 ] , [ 8 , 141 , 117 , 1 , 13 , 11 ] , [ 30 , 140 , 128 , 1 , 0 , 0 ] , [ 5 , 146 , 96 , 3 , 0 , 0 ] , [ 32 , 150 , 98 , 3 , 0 , 0 ] , [ 32 , 142 , 95 , 3 , 0 , 0 ] , [ 32 , 159 , 104 , 3 , 0 , 0 ] , [ 32 , 133 , 95 , 3 , 0 , 0 ] , [ 32 , 131 , 102 , 2 , 0 , 0 ] , [ 32 , 164 , 144 , 0 , 0 , 0 ] , [ 32 , 146 , 139 , 0 , 0 , 0 ] , [ 26 , 143 , 122 , 4 , 0 , 0 ] , [ 26 , 164 , 116 , 2 , 0 , 0 ] , ] ;
6051: LD_ADDR_VAR 0 5
6055: PUSH
6056: LD_INT 1
6058: PUSH
6059: LD_INT 144
6061: PUSH
6062: LD_INT 110
6064: PUSH
6065: LD_INT 1
6067: PUSH
6068: LD_INT 0
6070: PUSH
6071: LD_INT 0
6073: PUSH
6074: EMPTY
6075: LIST
6076: LIST
6077: LIST
6078: LIST
6079: LIST
6080: LIST
6081: PUSH
6082: LD_INT 3
6084: PUSH
6085: LD_INT 151
6087: PUSH
6088: LD_INT 118
6090: PUSH
6091: LD_INT 0
6093: PUSH
6094: LD_INT 0
6096: PUSH
6097: LD_INT 0
6099: PUSH
6100: EMPTY
6101: LIST
6102: LIST
6103: LIST
6104: LIST
6105: LIST
6106: LIST
6107: PUSH
6108: LD_INT 8
6110: PUSH
6111: LD_INT 158
6113: PUSH
6114: LD_INT 110
6116: PUSH
6117: LD_INT 4
6119: PUSH
6120: LD_INT 10
6122: PUSH
6123: LD_INT 15
6125: PUSH
6126: EMPTY
6127: LIST
6128: LIST
6129: LIST
6130: LIST
6131: LIST
6132: LIST
6133: PUSH
6134: LD_INT 23
6136: PUSH
6137: LD_INT 154
6139: PUSH
6140: LD_INT 121
6142: PUSH
6143: LD_INT 5
6145: PUSH
6146: LD_INT 0
6148: PUSH
6149: LD_INT 0
6151: PUSH
6152: EMPTY
6153: LIST
6154: LIST
6155: LIST
6156: LIST
6157: LIST
6158: LIST
6159: PUSH
6160: LD_INT 22
6162: PUSH
6163: LD_INT 155
6165: PUSH
6166: LD_INT 118
6168: PUSH
6169: LD_INT 4
6171: PUSH
6172: LD_INT 0
6174: PUSH
6175: LD_INT 0
6177: PUSH
6178: EMPTY
6179: LIST
6180: LIST
6181: LIST
6182: LIST
6183: LIST
6184: LIST
6185: PUSH
6186: LD_INT 21
6188: PUSH
6189: LD_INT 151
6191: PUSH
6192: LD_INT 122
6194: PUSH
6195: LD_INT 0
6197: PUSH
6198: LD_INT 0
6200: PUSH
6201: LD_INT 0
6203: PUSH
6204: EMPTY
6205: LIST
6206: LIST
6207: LIST
6208: LIST
6209: LIST
6210: LIST
6211: PUSH
6212: LD_INT 18
6214: PUSH
6215: LD_INT 148
6217: PUSH
6218: LD_INT 118
6220: PUSH
6221: LD_INT 1
6223: PUSH
6224: LD_INT 0
6226: PUSH
6227: LD_INT 0
6229: PUSH
6230: EMPTY
6231: LIST
6232: LIST
6233: LIST
6234: LIST
6235: LIST
6236: LIST
6237: PUSH
6238: LD_INT 17
6240: PUSH
6241: LD_INT 147
6243: PUSH
6244: LD_INT 114
6246: PUSH
6247: LD_INT 2
6249: PUSH
6250: LD_INT 0
6252: PUSH
6253: LD_INT 0
6255: PUSH
6256: EMPTY
6257: LIST
6258: LIST
6259: LIST
6260: LIST
6261: LIST
6262: LIST
6263: PUSH
6264: LD_INT 29
6266: PUSH
6267: LD_INT 163
6269: PUSH
6270: LD_INT 120
6272: PUSH
6273: LD_INT 5
6275: PUSH
6276: LD_INT 0
6278: PUSH
6279: LD_INT 0
6281: PUSH
6282: EMPTY
6283: LIST
6284: LIST
6285: LIST
6286: LIST
6287: LIST
6288: LIST
6289: PUSH
6290: LD_INT 27
6292: PUSH
6293: LD_INT 137
6295: PUSH
6296: LD_INT 116
6298: PUSH
6299: LD_INT 3
6301: PUSH
6302: LD_INT 0
6304: PUSH
6305: LD_INT 0
6307: PUSH
6308: EMPTY
6309: LIST
6310: LIST
6311: LIST
6312: LIST
6313: LIST
6314: LIST
6315: PUSH
6316: LD_INT 27
6318: PUSH
6319: LD_INT 133
6321: PUSH
6322: LD_INT 111
6324: PUSH
6325: LD_INT 1
6327: PUSH
6328: LD_INT 0
6330: PUSH
6331: LD_INT 0
6333: PUSH
6334: EMPTY
6335: LIST
6336: LIST
6337: LIST
6338: LIST
6339: LIST
6340: LIST
6341: PUSH
6342: LD_INT 27
6344: PUSH
6345: LD_INT 132
6347: PUSH
6348: LD_INT 106
6350: PUSH
6351: LD_INT 4
6353: PUSH
6354: LD_INT 0
6356: PUSH
6357: LD_INT 0
6359: PUSH
6360: EMPTY
6361: LIST
6362: LIST
6363: LIST
6364: LIST
6365: LIST
6366: LIST
6367: PUSH
6368: LD_INT 26
6370: PUSH
6371: LD_INT 137
6373: PUSH
6374: LD_INT 111
6376: PUSH
6377: LD_INT 0
6379: PUSH
6380: LD_INT 0
6382: PUSH
6383: LD_INT 0
6385: PUSH
6386: EMPTY
6387: LIST
6388: LIST
6389: LIST
6390: LIST
6391: LIST
6392: LIST
6393: PUSH
6394: LD_INT 8
6396: PUSH
6397: LD_INT 141
6399: PUSH
6400: LD_INT 117
6402: PUSH
6403: LD_INT 1
6405: PUSH
6406: LD_INT 13
6408: PUSH
6409: LD_INT 11
6411: PUSH
6412: EMPTY
6413: LIST
6414: LIST
6415: LIST
6416: LIST
6417: LIST
6418: LIST
6419: PUSH
6420: LD_INT 30
6422: PUSH
6423: LD_INT 140
6425: PUSH
6426: LD_INT 128
6428: PUSH
6429: LD_INT 1
6431: PUSH
6432: LD_INT 0
6434: PUSH
6435: LD_INT 0
6437: PUSH
6438: EMPTY
6439: LIST
6440: LIST
6441: LIST
6442: LIST
6443: LIST
6444: LIST
6445: PUSH
6446: LD_INT 5
6448: PUSH
6449: LD_INT 146
6451: PUSH
6452: LD_INT 96
6454: PUSH
6455: LD_INT 3
6457: PUSH
6458: LD_INT 0
6460: PUSH
6461: LD_INT 0
6463: PUSH
6464: EMPTY
6465: LIST
6466: LIST
6467: LIST
6468: LIST
6469: LIST
6470: LIST
6471: PUSH
6472: LD_INT 32
6474: PUSH
6475: LD_INT 150
6477: PUSH
6478: LD_INT 98
6480: PUSH
6481: LD_INT 3
6483: PUSH
6484: LD_INT 0
6486: PUSH
6487: LD_INT 0
6489: PUSH
6490: EMPTY
6491: LIST
6492: LIST
6493: LIST
6494: LIST
6495: LIST
6496: LIST
6497: PUSH
6498: LD_INT 32
6500: PUSH
6501: LD_INT 142
6503: PUSH
6504: LD_INT 95
6506: PUSH
6507: LD_INT 3
6509: PUSH
6510: LD_INT 0
6512: PUSH
6513: LD_INT 0
6515: PUSH
6516: EMPTY
6517: LIST
6518: LIST
6519: LIST
6520: LIST
6521: LIST
6522: LIST
6523: PUSH
6524: LD_INT 32
6526: PUSH
6527: LD_INT 159
6529: PUSH
6530: LD_INT 104
6532: PUSH
6533: LD_INT 3
6535: PUSH
6536: LD_INT 0
6538: PUSH
6539: LD_INT 0
6541: PUSH
6542: EMPTY
6543: LIST
6544: LIST
6545: LIST
6546: LIST
6547: LIST
6548: LIST
6549: PUSH
6550: LD_INT 32
6552: PUSH
6553: LD_INT 133
6555: PUSH
6556: LD_INT 95
6558: PUSH
6559: LD_INT 3
6561: PUSH
6562: LD_INT 0
6564: PUSH
6565: LD_INT 0
6567: PUSH
6568: EMPTY
6569: LIST
6570: LIST
6571: LIST
6572: LIST
6573: LIST
6574: LIST
6575: PUSH
6576: LD_INT 32
6578: PUSH
6579: LD_INT 131
6581: PUSH
6582: LD_INT 102
6584: PUSH
6585: LD_INT 2
6587: PUSH
6588: LD_INT 0
6590: PUSH
6591: LD_INT 0
6593: PUSH
6594: EMPTY
6595: LIST
6596: LIST
6597: LIST
6598: LIST
6599: LIST
6600: LIST
6601: PUSH
6602: LD_INT 32
6604: PUSH
6605: LD_INT 164
6607: PUSH
6608: LD_INT 144
6610: PUSH
6611: LD_INT 0
6613: PUSH
6614: LD_INT 0
6616: PUSH
6617: LD_INT 0
6619: PUSH
6620: EMPTY
6621: LIST
6622: LIST
6623: LIST
6624: LIST
6625: LIST
6626: LIST
6627: PUSH
6628: LD_INT 32
6630: PUSH
6631: LD_INT 146
6633: PUSH
6634: LD_INT 139
6636: PUSH
6637: LD_INT 0
6639: PUSH
6640: LD_INT 0
6642: PUSH
6643: LD_INT 0
6645: PUSH
6646: EMPTY
6647: LIST
6648: LIST
6649: LIST
6650: LIST
6651: LIST
6652: LIST
6653: PUSH
6654: LD_INT 26
6656: PUSH
6657: LD_INT 143
6659: PUSH
6660: LD_INT 122
6662: PUSH
6663: LD_INT 4
6665: PUSH
6666: LD_INT 0
6668: PUSH
6669: LD_INT 0
6671: PUSH
6672: EMPTY
6673: LIST
6674: LIST
6675: LIST
6676: LIST
6677: LIST
6678: LIST
6679: PUSH
6680: LD_INT 26
6682: PUSH
6683: LD_INT 164
6685: PUSH
6686: LD_INT 116
6688: PUSH
6689: LD_INT 2
6691: PUSH
6692: LD_INT 0
6694: PUSH
6695: LD_INT 0
6697: PUSH
6698: EMPTY
6699: LIST
6700: LIST
6701: LIST
6702: LIST
6703: LIST
6704: LIST
6705: PUSH
6706: EMPTY
6707: LIST
6708: LIST
6709: LIST
6710: LIST
6711: LIST
6712: LIST
6713: LIST
6714: LIST
6715: LIST
6716: LIST
6717: LIST
6718: LIST
6719: LIST
6720: LIST
6721: LIST
6722: LIST
6723: LIST
6724: LIST
6725: LIST
6726: LIST
6727: LIST
6728: LIST
6729: LIST
6730: LIST
6731: LIST
6732: ST_TO_ADDR
// for i in tmp do
6733: LD_ADDR_VAR 0 2
6737: PUSH
6738: LD_VAR 0 5
6742: PUSH
6743: FOR_IN
6744: IFFALSE 6975
// begin uc_side := side ;
6746: LD_ADDR_OWVAR 20
6750: PUSH
6751: LD_VAR 0 8
6755: ST_TO_ADDR
// uc_nation := nation_arabian ;
6756: LD_ADDR_OWVAR 21
6760: PUSH
6761: LD_INT 2
6763: ST_TO_ADDR
// bc_type := i [ 1 ] ;
6764: LD_ADDR_OWVAR 42
6768: PUSH
6769: LD_VAR 0 2
6773: PUSH
6774: LD_INT 1
6776: ARRAY
6777: ST_TO_ADDR
// bc_level := rand ( 5 , 6 ) ;
6778: LD_ADDR_OWVAR 43
6782: PUSH
6783: LD_INT 5
6785: PPUSH
6786: LD_INT 6
6788: PPUSH
6789: CALL_OW 12
6793: ST_TO_ADDR
// bc_kind1 := i [ 5 ] ;
6794: LD_ADDR_OWVAR 44
6798: PUSH
6799: LD_VAR 0 2
6803: PUSH
6804: LD_INT 5
6806: ARRAY
6807: ST_TO_ADDR
// bc_kind2 := i [ 6 ] ;
6808: LD_ADDR_OWVAR 45
6812: PUSH
6813: LD_VAR 0 2
6817: PUSH
6818: LD_INT 6
6820: ARRAY
6821: ST_TO_ADDR
// sr := 0 ;
6822: LD_ADDR_VAR 0 9
6826: PUSH
6827: LD_INT 0
6829: ST_TO_ADDR
// if i [ 1 ] = b_oil_mine then
6830: LD_VAR 0 2
6834: PUSH
6835: LD_INT 1
6837: ARRAY
6838: PUSH
6839: LD_INT 29
6841: EQUAL
6842: IFFALSE 6854
// sr := mat_oil else
6844: LD_ADDR_VAR 0 9
6848: PUSH
6849: LD_INT 2
6851: ST_TO_ADDR
6852: GO 6876
// if i [ 1 ] = b_siberite_mine then
6854: LD_VAR 0 2
6858: PUSH
6859: LD_INT 1
6861: ARRAY
6862: PUSH
6863: LD_INT 30
6865: EQUAL
6866: IFFALSE 6876
// sr := mat_siberit ;
6868: LD_ADDR_VAR 0 9
6872: PUSH
6873: LD_INT 3
6875: ST_TO_ADDR
// if sr then
6876: LD_VAR 0 9
6880: IFFALSE 6936
// begin CreateDepositXY ( i [ 2 ] , i [ 3 ] , sr ) ;
6882: LD_VAR 0 2
6886: PUSH
6887: LD_INT 2
6889: ARRAY
6890: PPUSH
6891: LD_VAR 0 2
6895: PUSH
6896: LD_INT 3
6898: ARRAY
6899: PPUSH
6900: LD_VAR 0 9
6904: PPUSH
6905: CALL_OW 62
// SetResourceVisibility ( i [ 2 ] , i [ 3 ] , side ) ;
6909: LD_VAR 0 2
6913: PUSH
6914: LD_INT 2
6916: ARRAY
6917: PPUSH
6918: LD_VAR 0 2
6922: PUSH
6923: LD_INT 3
6925: ARRAY
6926: PPUSH
6927: LD_VAR 0 8
6931: PPUSH
6932: CALL_OW 441
// end ; b := CreateAndPlaceBuildingXYD ( i [ 2 ] , i [ 3 ] , i [ 4 ] ) ;
6936: LD_ADDR_VAR 0 3
6940: PUSH
6941: LD_VAR 0 2
6945: PUSH
6946: LD_INT 2
6948: ARRAY
6949: PPUSH
6950: LD_VAR 0 2
6954: PUSH
6955: LD_INT 3
6957: ARRAY
6958: PPUSH
6959: LD_VAR 0 2
6963: PUSH
6964: LD_INT 4
6966: ARRAY
6967: PPUSH
6968: CALL_OW 47
6972: ST_TO_ADDR
// end ;
6973: GO 6743
6975: POP
6976: POP
// depot := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_warehouse ] ] ) ;
6977: LD_ADDR_VAR 0 10
6981: PUSH
6982: LD_INT 22
6984: PUSH
6985: LD_VAR 0 8
6989: PUSH
6990: EMPTY
6991: LIST
6992: LIST
6993: PUSH
6994: LD_INT 30
6996: PUSH
6997: LD_INT 1
6999: PUSH
7000: EMPTY
7001: LIST
7002: LIST
7003: PUSH
7004: EMPTY
7005: LIST
7006: LIST
7007: PPUSH
7008: CALL_OW 69
7012: ST_TO_ADDR
// if not depot then
7013: LD_VAR 0 10
7017: NOT
7018: IFFALSE 7022
// exit ;
7020: GO 7268
// base := PrepareBase ( depot [ 1 ] , legBase , 0 , [ 7 , 8 , 10 ] [ Difficulty ] , [ 3000 , 300 , 100 ] , [ 14 , 6 , 6 , 5 ] ) ;
7022: LD_ADDR_VAR 0 11
7026: PUSH
7027: LD_VAR 0 10
7031: PUSH
7032: LD_INT 1
7034: ARRAY
7035: PPUSH
7036: LD_INT 6
7038: PPUSH
7039: LD_INT 0
7041: PPUSH
7042: LD_INT 7
7044: PUSH
7045: LD_INT 8
7047: PUSH
7048: LD_INT 10
7050: PUSH
7051: EMPTY
7052: LIST
7053: LIST
7054: LIST
7055: PUSH
7056: LD_OWVAR 67
7060: ARRAY
7061: PPUSH
7062: LD_INT 3000
7064: PUSH
7065: LD_INT 300
7067: PUSH
7068: LD_INT 100
7070: PUSH
7071: EMPTY
7072: LIST
7073: LIST
7074: LIST
7075: PPUSH
7076: LD_INT 14
7078: PUSH
7079: LD_INT 6
7081: PUSH
7082: LD_INT 6
7084: PUSH
7085: LD_INT 5
7087: PUSH
7088: EMPTY
7089: LIST
7090: LIST
7091: LIST
7092: LIST
7093: PPUSH
7094: CALL 28343 0 6
7098: ST_TO_ADDR
// if not base then
7099: LD_VAR 0 11
7103: NOT
7104: IFFALSE 7108
// exit ;
7106: GO 7268
// if Difficulty > 1 then
7108: LD_OWVAR 67
7112: PUSH
7113: LD_INT 1
7115: GREATER
7116: IFFALSE 7189
// begin InitHc ;
7118: CALL_OW 19
// PrepareHuman ( sex_male , class_sniper , [ 5 , 8 ] [ Difficulty - 1 ] ) ;
7122: LD_INT 1
7124: PPUSH
7125: LD_INT 5
7127: PPUSH
7128: LD_INT 5
7130: PUSH
7131: LD_INT 8
7133: PUSH
7134: EMPTY
7135: LIST
7136: LIST
7137: PUSH
7138: LD_OWVAR 67
7142: PUSH
7143: LD_INT 1
7145: MINUS
7146: ARRAY
7147: PPUSH
7148: CALL_OW 380
// for i = 1 to Difficulty do
7152: LD_ADDR_VAR 0 2
7156: PUSH
7157: DOUBLE
7158: LD_INT 1
7160: DEC
7161: ST_TO_ADDR
7162: LD_OWVAR 67
7166: PUSH
7167: FOR_TO
7168: IFFALSE 7187
// PlaceUnitArea ( CreateHuman , sniperGuardArea , false ) ;
7170: CALL_OW 44
7174: PPUSH
7175: LD_INT 24
7177: PPUSH
7178: LD_INT 0
7180: PPUSH
7181: CALL_OW 49
7185: GO 7167
7187: POP
7188: POP
// end ; mc_bases := Replace ( mc_bases , mc_leg , base ) ;
7189: LD_ADDR_EXP 31
7193: PUSH
7194: LD_EXP 31
7198: PPUSH
7199: LD_EXP 6
7203: PPUSH
7204: LD_VAR 0 11
7208: PPUSH
7209: CALL_OW 1
7213: ST_TO_ADDR
// hc_gallery := ru ;
7214: LD_ADDR_OWVAR 33
7218: PUSH
7219: LD_STRING ru
7221: ST_TO_ADDR
// hc_face_number := 44 ;
7222: LD_ADDR_OWVAR 34
7226: PUSH
7227: LD_INT 44
7229: ST_TO_ADDR
// hc_name := Robert Farmer ;
7230: LD_ADDR_OWVAR 26
7234: PUSH
7235: LD_STRING Robert Farmer
7237: ST_TO_ADDR
// hc_sex := sex_male ;
7238: LD_ADDR_OWVAR 27
7242: PUSH
7243: LD_INT 1
7245: ST_TO_ADDR
// hc_class := 1 ;
7246: LD_ADDR_OWVAR 28
7250: PUSH
7251: LD_INT 1
7253: ST_TO_ADDR
// Farmer := CreateHuman ;
7254: LD_ADDR_EXP 13
7258: PUSH
7259: CALL_OW 44
7263: ST_TO_ADDR
// InitHc ;
7264: CALL_OW 19
// end ;
7268: LD_VAR 0 1
7272: RET
// export function SetAdditionalRussianForces ; var i , tmp , veh ; begin
7273: LD_INT 0
7275: PPUSH
7276: PPUSH
7277: PPUSH
7278: PPUSH
// tmp := [ ] ;
7279: LD_ADDR_VAR 0 3
7283: PUSH
7284: EMPTY
7285: ST_TO_ADDR
// for i := 1 to 3 do
7286: LD_ADDR_VAR 0 2
7290: PUSH
7291: DOUBLE
7292: LD_INT 1
7294: DEC
7295: ST_TO_ADDR
7296: LD_INT 3
7298: PUSH
7299: FOR_TO
7300: IFFALSE 7412
// begin uc_side := 3 ;
7302: LD_ADDR_OWVAR 20
7306: PUSH
7307: LD_INT 3
7309: ST_TO_ADDR
// uc_nation := 3 ;
7310: LD_ADDR_OWVAR 21
7314: PUSH
7315: LD_INT 3
7317: ST_TO_ADDR
// vc_chassis := ru_medium_tracked ;
7318: LD_ADDR_OWVAR 37
7322: PUSH
7323: LD_INT 22
7325: ST_TO_ADDR
// vc_engine := engine_siberite ;
7326: LD_ADDR_OWVAR 39
7330: PUSH
7331: LD_INT 3
7333: ST_TO_ADDR
// vc_control := control_computer ;
7334: LD_ADDR_OWVAR 38
7338: PUSH
7339: LD_INT 3
7341: ST_TO_ADDR
// vc_weapon := ru_crane ;
7342: LD_ADDR_OWVAR 40
7346: PUSH
7347: LD_INT 52
7349: ST_TO_ADDR
// veh := CreateVehicle ;
7350: LD_ADDR_VAR 0 4
7354: PUSH
7355: CALL_OW 45
7359: ST_TO_ADDR
// PlaceUnitXYR ( veh , 73 , 122 , 3 , false ) ;
7360: LD_VAR 0 4
7364: PPUSH
7365: LD_INT 73
7367: PPUSH
7368: LD_INT 122
7370: PPUSH
7371: LD_INT 3
7373: PPUSH
7374: LD_INT 0
7376: PPUSH
7377: CALL_OW 50
// tmp := Replace ( tmp , tmp + 1 , veh ) ;
7381: LD_ADDR_VAR 0 3
7385: PUSH
7386: LD_VAR 0 3
7390: PPUSH
7391: LD_VAR 0 3
7395: PUSH
7396: LD_INT 1
7398: PLUS
7399: PPUSH
7400: LD_VAR 0 4
7404: PPUSH
7405: CALL_OW 1
7409: ST_TO_ADDR
// end ;
7410: GO 7299
7412: POP
7413: POP
// mc_vehicles := Replace ( mc_vehicles , mc_rus_1 , tmp ) ;
7414: LD_ADDR_EXP 50
7418: PUSH
7419: LD_EXP 50
7423: PPUSH
7424: LD_EXP 7
7428: PPUSH
7429: LD_VAR 0 3
7433: PPUSH
7434: CALL_OW 1
7438: ST_TO_ADDR
// tmp := [ ] ;
7439: LD_ADDR_VAR 0 3
7443: PUSH
7444: EMPTY
7445: ST_TO_ADDR
// for i := 1 to 3 do
7446: LD_ADDR_VAR 0 2
7450: PUSH
7451: DOUBLE
7452: LD_INT 1
7454: DEC
7455: ST_TO_ADDR
7456: LD_INT 3
7458: PUSH
7459: FOR_TO
7460: IFFALSE 7572
// begin uc_side := 3 ;
7462: LD_ADDR_OWVAR 20
7466: PUSH
7467: LD_INT 3
7469: ST_TO_ADDR
// uc_nation := 3 ;
7470: LD_ADDR_OWVAR 21
7474: PUSH
7475: LD_INT 3
7477: ST_TO_ADDR
// vc_chassis := ru_medium_tracked ;
7478: LD_ADDR_OWVAR 37
7482: PUSH
7483: LD_INT 22
7485: ST_TO_ADDR
// vc_engine := engine_siberite ;
7486: LD_ADDR_OWVAR 39
7490: PUSH
7491: LD_INT 3
7493: ST_TO_ADDR
// vc_control := control_computer ;
7494: LD_ADDR_OWVAR 38
7498: PUSH
7499: LD_INT 3
7501: ST_TO_ADDR
// vc_weapon := ru_crane ;
7502: LD_ADDR_OWVAR 40
7506: PUSH
7507: LD_INT 52
7509: ST_TO_ADDR
// veh := CreateVehicle ;
7510: LD_ADDR_VAR 0 4
7514: PUSH
7515: CALL_OW 45
7519: ST_TO_ADDR
// PlaceUnitXYR ( veh , 22 , 28 , 3 , false ) ;
7520: LD_VAR 0 4
7524: PPUSH
7525: LD_INT 22
7527: PPUSH
7528: LD_INT 28
7530: PPUSH
7531: LD_INT 3
7533: PPUSH
7534: LD_INT 0
7536: PPUSH
7537: CALL_OW 50
// tmp := Replace ( tmp , tmp + 1 , veh ) ;
7541: LD_ADDR_VAR 0 3
7545: PUSH
7546: LD_VAR 0 3
7550: PPUSH
7551: LD_VAR 0 3
7555: PUSH
7556: LD_INT 1
7558: PLUS
7559: PPUSH
7560: LD_VAR 0 4
7564: PPUSH
7565: CALL_OW 1
7569: ST_TO_ADDR
// end ;
7570: GO 7459
7572: POP
7573: POP
// mc_vehicles := Replace ( mc_vehicles , mc_rus_2 , tmp ) ;
7574: LD_ADDR_EXP 50
7578: PUSH
7579: LD_EXP 50
7583: PPUSH
7584: LD_EXP 8
7588: PPUSH
7589: LD_VAR 0 3
7593: PPUSH
7594: CALL_OW 1
7598: ST_TO_ADDR
// end ;
7599: LD_VAR 0 1
7603: RET
// export function PrepareAmericans ; var i , b , tmp , side , sr , base , depot ; begin
7604: LD_INT 0
7606: PPUSH
7607: PPUSH
7608: PPUSH
7609: PPUSH
7610: PPUSH
7611: PPUSH
7612: PPUSH
7613: PPUSH
// PrepareNature ( 0 , 0 , 4 , 0 , 0 , 0 , 0 , amerApe , 0 ) ;
7614: LD_INT 0
7616: PPUSH
7617: LD_INT 0
7619: PPUSH
7620: LD_INT 4
7622: PPUSH
7623: LD_INT 0
7625: PPUSH
7626: LD_INT 0
7628: PPUSH
7629: LD_INT 0
7631: PPUSH
7632: LD_INT 0
7634: PPUSH
7635: LD_INT 10
7637: PPUSH
7638: LD_INT 0
7640: PPUSH
7641: CALL 54015 0 9
// side := 4 ;
7645: LD_ADDR_VAR 0 5
7649: PUSH
7650: LD_INT 4
7652: ST_TO_ADDR
// tmp := [ [ 1 , 144 , 18 , 4 , 0 , 0 ] , [ 3 , 137 , 8 , 4 , 0 , 0 ] , [ 22 , 141 , 8 , 4 , 0 , 0 ] , [ 25 , 137 , 5 , 3 , 0 , 0 ] , [ 18 , 137 , 12 , 0 , 0 , 0 ] , [ 17 , 133 , 4 , 2 , 0 , 0 ] , [ 16 , 140 , 11 , 5 , 0 , 0 ] , [ 8 , 149 , 26 , 4 , 10 , 15 ] , [ 8 , 142 , 26 , 1 , 11 , 12 ] , [ 27 , 153 , 32 , 5 , 0 , 0 ] , [ 27 , 145 , 32 , 3 , 0 , 0 ] , [ 27 , 138 , 2 , 4 , 0 , 0 ] , [ 27 , 144 , 13 , 0 , 0 , 0 ] , [ 26 , 124 , 2 , 4 , 0 , 0 ] , [ 26 , 121 , 2 , 2 , 0 , 0 ] , [ 26 , 118 , 2 , 1 , 0 , 0 ] , [ 29 , 159 , 47 , 2 , 0 , 0 ] , [ 32 , 146 , 41 , 0 , 0 , 0 ] , [ 33 , 136 , 37 , 0 , 0 , 0 ] , [ 33 , 132 , 34 , 0 , 0 , 0 ] , [ 36 , 124 , 7 , 1 , 0 , 0 ] , [ 5 , 124 , 19 , 0 , 0 , 0 ] , [ 32 , 127 , 23 , 0 , 0 , 0 ] ] ;
7653: LD_ADDR_VAR 0 4
7657: PUSH
7658: LD_INT 1
7660: PUSH
7661: LD_INT 144
7663: PUSH
7664: LD_INT 18
7666: PUSH
7667: LD_INT 4
7669: PUSH
7670: LD_INT 0
7672: PUSH
7673: LD_INT 0
7675: PUSH
7676: EMPTY
7677: LIST
7678: LIST
7679: LIST
7680: LIST
7681: LIST
7682: LIST
7683: PUSH
7684: LD_INT 3
7686: PUSH
7687: LD_INT 137
7689: PUSH
7690: LD_INT 8
7692: PUSH
7693: LD_INT 4
7695: PUSH
7696: LD_INT 0
7698: PUSH
7699: LD_INT 0
7701: PUSH
7702: EMPTY
7703: LIST
7704: LIST
7705: LIST
7706: LIST
7707: LIST
7708: LIST
7709: PUSH
7710: LD_INT 22
7712: PUSH
7713: LD_INT 141
7715: PUSH
7716: LD_INT 8
7718: PUSH
7719: LD_INT 4
7721: PUSH
7722: LD_INT 0
7724: PUSH
7725: LD_INT 0
7727: PUSH
7728: EMPTY
7729: LIST
7730: LIST
7731: LIST
7732: LIST
7733: LIST
7734: LIST
7735: PUSH
7736: LD_INT 25
7738: PUSH
7739: LD_INT 137
7741: PUSH
7742: LD_INT 5
7744: PUSH
7745: LD_INT 3
7747: PUSH
7748: LD_INT 0
7750: PUSH
7751: LD_INT 0
7753: PUSH
7754: EMPTY
7755: LIST
7756: LIST
7757: LIST
7758: LIST
7759: LIST
7760: LIST
7761: PUSH
7762: LD_INT 18
7764: PUSH
7765: LD_INT 137
7767: PUSH
7768: LD_INT 12
7770: PUSH
7771: LD_INT 0
7773: PUSH
7774: LD_INT 0
7776: PUSH
7777: LD_INT 0
7779: PUSH
7780: EMPTY
7781: LIST
7782: LIST
7783: LIST
7784: LIST
7785: LIST
7786: LIST
7787: PUSH
7788: LD_INT 17
7790: PUSH
7791: LD_INT 133
7793: PUSH
7794: LD_INT 4
7796: PUSH
7797: LD_INT 2
7799: PUSH
7800: LD_INT 0
7802: PUSH
7803: LD_INT 0
7805: PUSH
7806: EMPTY
7807: LIST
7808: LIST
7809: LIST
7810: LIST
7811: LIST
7812: LIST
7813: PUSH
7814: LD_INT 16
7816: PUSH
7817: LD_INT 140
7819: PUSH
7820: LD_INT 11
7822: PUSH
7823: LD_INT 5
7825: PUSH
7826: LD_INT 0
7828: PUSH
7829: LD_INT 0
7831: PUSH
7832: EMPTY
7833: LIST
7834: LIST
7835: LIST
7836: LIST
7837: LIST
7838: LIST
7839: PUSH
7840: LD_INT 8
7842: PUSH
7843: LD_INT 149
7845: PUSH
7846: LD_INT 26
7848: PUSH
7849: LD_INT 4
7851: PUSH
7852: LD_INT 10
7854: PUSH
7855: LD_INT 15
7857: PUSH
7858: EMPTY
7859: LIST
7860: LIST
7861: LIST
7862: LIST
7863: LIST
7864: LIST
7865: PUSH
7866: LD_INT 8
7868: PUSH
7869: LD_INT 142
7871: PUSH
7872: LD_INT 26
7874: PUSH
7875: LD_INT 1
7877: PUSH
7878: LD_INT 11
7880: PUSH
7881: LD_INT 12
7883: PUSH
7884: EMPTY
7885: LIST
7886: LIST
7887: LIST
7888: LIST
7889: LIST
7890: LIST
7891: PUSH
7892: LD_INT 27
7894: PUSH
7895: LD_INT 153
7897: PUSH
7898: LD_INT 32
7900: PUSH
7901: LD_INT 5
7903: PUSH
7904: LD_INT 0
7906: PUSH
7907: LD_INT 0
7909: PUSH
7910: EMPTY
7911: LIST
7912: LIST
7913: LIST
7914: LIST
7915: LIST
7916: LIST
7917: PUSH
7918: LD_INT 27
7920: PUSH
7921: LD_INT 145
7923: PUSH
7924: LD_INT 32
7926: PUSH
7927: LD_INT 3
7929: PUSH
7930: LD_INT 0
7932: PUSH
7933: LD_INT 0
7935: PUSH
7936: EMPTY
7937: LIST
7938: LIST
7939: LIST
7940: LIST
7941: LIST
7942: LIST
7943: PUSH
7944: LD_INT 27
7946: PUSH
7947: LD_INT 138
7949: PUSH
7950: LD_INT 2
7952: PUSH
7953: LD_INT 4
7955: PUSH
7956: LD_INT 0
7958: PUSH
7959: LD_INT 0
7961: PUSH
7962: EMPTY
7963: LIST
7964: LIST
7965: LIST
7966: LIST
7967: LIST
7968: LIST
7969: PUSH
7970: LD_INT 27
7972: PUSH
7973: LD_INT 144
7975: PUSH
7976: LD_INT 13
7978: PUSH
7979: LD_INT 0
7981: PUSH
7982: LD_INT 0
7984: PUSH
7985: LD_INT 0
7987: PUSH
7988: EMPTY
7989: LIST
7990: LIST
7991: LIST
7992: LIST
7993: LIST
7994: LIST
7995: PUSH
7996: LD_INT 26
7998: PUSH
7999: LD_INT 124
8001: PUSH
8002: LD_INT 2
8004: PUSH
8005: LD_INT 4
8007: PUSH
8008: LD_INT 0
8010: PUSH
8011: LD_INT 0
8013: PUSH
8014: EMPTY
8015: LIST
8016: LIST
8017: LIST
8018: LIST
8019: LIST
8020: LIST
8021: PUSH
8022: LD_INT 26
8024: PUSH
8025: LD_INT 121
8027: PUSH
8028: LD_INT 2
8030: PUSH
8031: LD_INT 2
8033: PUSH
8034: LD_INT 0
8036: PUSH
8037: LD_INT 0
8039: PUSH
8040: EMPTY
8041: LIST
8042: LIST
8043: LIST
8044: LIST
8045: LIST
8046: LIST
8047: PUSH
8048: LD_INT 26
8050: PUSH
8051: LD_INT 118
8053: PUSH
8054: LD_INT 2
8056: PUSH
8057: LD_INT 1
8059: PUSH
8060: LD_INT 0
8062: PUSH
8063: LD_INT 0
8065: PUSH
8066: EMPTY
8067: LIST
8068: LIST
8069: LIST
8070: LIST
8071: LIST
8072: LIST
8073: PUSH
8074: LD_INT 29
8076: PUSH
8077: LD_INT 159
8079: PUSH
8080: LD_INT 47
8082: PUSH
8083: LD_INT 2
8085: PUSH
8086: LD_INT 0
8088: PUSH
8089: LD_INT 0
8091: PUSH
8092: EMPTY
8093: LIST
8094: LIST
8095: LIST
8096: LIST
8097: LIST
8098: LIST
8099: PUSH
8100: LD_INT 32
8102: PUSH
8103: LD_INT 146
8105: PUSH
8106: LD_INT 41
8108: PUSH
8109: LD_INT 0
8111: PUSH
8112: LD_INT 0
8114: PUSH
8115: LD_INT 0
8117: PUSH
8118: EMPTY
8119: LIST
8120: LIST
8121: LIST
8122: LIST
8123: LIST
8124: LIST
8125: PUSH
8126: LD_INT 33
8128: PUSH
8129: LD_INT 136
8131: PUSH
8132: LD_INT 37
8134: PUSH
8135: LD_INT 0
8137: PUSH
8138: LD_INT 0
8140: PUSH
8141: LD_INT 0
8143: PUSH
8144: EMPTY
8145: LIST
8146: LIST
8147: LIST
8148: LIST
8149: LIST
8150: LIST
8151: PUSH
8152: LD_INT 33
8154: PUSH
8155: LD_INT 132
8157: PUSH
8158: LD_INT 34
8160: PUSH
8161: LD_INT 0
8163: PUSH
8164: LD_INT 0
8166: PUSH
8167: LD_INT 0
8169: PUSH
8170: EMPTY
8171: LIST
8172: LIST
8173: LIST
8174: LIST
8175: LIST
8176: LIST
8177: PUSH
8178: LD_INT 36
8180: PUSH
8181: LD_INT 124
8183: PUSH
8184: LD_INT 7
8186: PUSH
8187: LD_INT 1
8189: PUSH
8190: LD_INT 0
8192: PUSH
8193: LD_INT 0
8195: PUSH
8196: EMPTY
8197: LIST
8198: LIST
8199: LIST
8200: LIST
8201: LIST
8202: LIST
8203: PUSH
8204: LD_INT 5
8206: PUSH
8207: LD_INT 124
8209: PUSH
8210: LD_INT 19
8212: PUSH
8213: LD_INT 0
8215: PUSH
8216: LD_INT 0
8218: PUSH
8219: LD_INT 0
8221: PUSH
8222: EMPTY
8223: LIST
8224: LIST
8225: LIST
8226: LIST
8227: LIST
8228: LIST
8229: PUSH
8230: LD_INT 32
8232: PUSH
8233: LD_INT 127
8235: PUSH
8236: LD_INT 23
8238: PUSH
8239: LD_INT 0
8241: PUSH
8242: LD_INT 0
8244: PUSH
8245: LD_INT 0
8247: PUSH
8248: EMPTY
8249: LIST
8250: LIST
8251: LIST
8252: LIST
8253: LIST
8254: LIST
8255: PUSH
8256: EMPTY
8257: LIST
8258: LIST
8259: LIST
8260: LIST
8261: LIST
8262: LIST
8263: LIST
8264: LIST
8265: LIST
8266: LIST
8267: LIST
8268: LIST
8269: LIST
8270: LIST
8271: LIST
8272: LIST
8273: LIST
8274: LIST
8275: LIST
8276: LIST
8277: LIST
8278: LIST
8279: LIST
8280: ST_TO_ADDR
// for i in tmp do
8281: LD_ADDR_VAR 0 2
8285: PUSH
8286: LD_VAR 0 4
8290: PUSH
8291: FOR_IN
8292: IFFALSE 8523
// begin uc_side := side ;
8294: LD_ADDR_OWVAR 20
8298: PUSH
8299: LD_VAR 0 5
8303: ST_TO_ADDR
// uc_nation := nation_american ;
8304: LD_ADDR_OWVAR 21
8308: PUSH
8309: LD_INT 1
8311: ST_TO_ADDR
// bc_type := i [ 1 ] ;
8312: LD_ADDR_OWVAR 42
8316: PUSH
8317: LD_VAR 0 2
8321: PUSH
8322: LD_INT 1
8324: ARRAY
8325: ST_TO_ADDR
// bc_level := rand ( 5 , 6 ) ;
8326: LD_ADDR_OWVAR 43
8330: PUSH
8331: LD_INT 5
8333: PPUSH
8334: LD_INT 6
8336: PPUSH
8337: CALL_OW 12
8341: ST_TO_ADDR
// bc_kind1 := i [ 5 ] ;
8342: LD_ADDR_OWVAR 44
8346: PUSH
8347: LD_VAR 0 2
8351: PUSH
8352: LD_INT 5
8354: ARRAY
8355: ST_TO_ADDR
// bc_kind2 := i [ 6 ] ;
8356: LD_ADDR_OWVAR 45
8360: PUSH
8361: LD_VAR 0 2
8365: PUSH
8366: LD_INT 6
8368: ARRAY
8369: ST_TO_ADDR
// sr := 0 ;
8370: LD_ADDR_VAR 0 6
8374: PUSH
8375: LD_INT 0
8377: ST_TO_ADDR
// if i [ 1 ] = b_oil_mine then
8378: LD_VAR 0 2
8382: PUSH
8383: LD_INT 1
8385: ARRAY
8386: PUSH
8387: LD_INT 29
8389: EQUAL
8390: IFFALSE 8402
// sr := mat_oil else
8392: LD_ADDR_VAR 0 6
8396: PUSH
8397: LD_INT 2
8399: ST_TO_ADDR
8400: GO 8424
// if i [ 1 ] = b_siberite_mine then
8402: LD_VAR 0 2
8406: PUSH
8407: LD_INT 1
8409: ARRAY
8410: PUSH
8411: LD_INT 30
8413: EQUAL
8414: IFFALSE 8424
// sr := mat_siberit ;
8416: LD_ADDR_VAR 0 6
8420: PUSH
8421: LD_INT 3
8423: ST_TO_ADDR
// if sr then
8424: LD_VAR 0 6
8428: IFFALSE 8484
// begin CreateDepositXY ( i [ 2 ] , i [ 3 ] , sr ) ;
8430: LD_VAR 0 2
8434: PUSH
8435: LD_INT 2
8437: ARRAY
8438: PPUSH
8439: LD_VAR 0 2
8443: PUSH
8444: LD_INT 3
8446: ARRAY
8447: PPUSH
8448: LD_VAR 0 6
8452: PPUSH
8453: CALL_OW 62
// SetResourceVisibility ( i [ 2 ] , i [ 3 ] , side ) ;
8457: LD_VAR 0 2
8461: PUSH
8462: LD_INT 2
8464: ARRAY
8465: PPUSH
8466: LD_VAR 0 2
8470: PUSH
8471: LD_INT 3
8473: ARRAY
8474: PPUSH
8475: LD_VAR 0 5
8479: PPUSH
8480: CALL_OW 441
// end ; b := CreateAndPlaceBuildingXYD ( i [ 2 ] , i [ 3 ] , i [ 4 ] ) ;
8484: LD_ADDR_VAR 0 3
8488: PUSH
8489: LD_VAR 0 2
8493: PUSH
8494: LD_INT 2
8496: ARRAY
8497: PPUSH
8498: LD_VAR 0 2
8502: PUSH
8503: LD_INT 3
8505: ARRAY
8506: PPUSH
8507: LD_VAR 0 2
8511: PUSH
8512: LD_INT 4
8514: ARRAY
8515: PPUSH
8516: CALL_OW 47
8520: ST_TO_ADDR
// end ;
8521: GO 8291
8523: POP
8524: POP
// depot := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_warehouse ] ] ) ;
8525: LD_ADDR_VAR 0 8
8529: PUSH
8530: LD_INT 22
8532: PUSH
8533: LD_VAR 0 5
8537: PUSH
8538: EMPTY
8539: LIST
8540: LIST
8541: PUSH
8542: LD_INT 30
8544: PUSH
8545: LD_INT 1
8547: PUSH
8548: EMPTY
8549: LIST
8550: LIST
8551: PUSH
8552: EMPTY
8553: LIST
8554: LIST
8555: PPUSH
8556: CALL_OW 69
8560: ST_TO_ADDR
// if not depot then
8561: LD_VAR 0 8
8565: NOT
8566: IFFALSE 8570
// exit ;
8568: GO 8842
// base := PrepareBase ( depot [ 1 ] , amerBase , theta3 , [ 8 , 7 , 6 ] [ Difficulty ] , [ [ 2500 , 2000 , 1750 ] [ Difficulty ] , [ 300 , 250 , 200 ] [ Difficulty ] , [ 80 , 60 , 50 ] [ Difficulty ] ] , [ 7 , 6 , 5 , 5 ] ) ;
8570: LD_ADDR_VAR 0 7
8574: PUSH
8575: LD_VAR 0 8
8579: PUSH
8580: LD_INT 1
8582: ARRAY
8583: PPUSH
8584: LD_INT 3
8586: PPUSH
8587: LD_STRING theta3
8589: PPUSH
8590: LD_INT 8
8592: PUSH
8593: LD_INT 7
8595: PUSH
8596: LD_INT 6
8598: PUSH
8599: EMPTY
8600: LIST
8601: LIST
8602: LIST
8603: PUSH
8604: LD_OWVAR 67
8608: ARRAY
8609: PPUSH
8610: LD_INT 2500
8612: PUSH
8613: LD_INT 2000
8615: PUSH
8616: LD_INT 1750
8618: PUSH
8619: EMPTY
8620: LIST
8621: LIST
8622: LIST
8623: PUSH
8624: LD_OWVAR 67
8628: ARRAY
8629: PUSH
8630: LD_INT 300
8632: PUSH
8633: LD_INT 250
8635: PUSH
8636: LD_INT 200
8638: PUSH
8639: EMPTY
8640: LIST
8641: LIST
8642: LIST
8643: PUSH
8644: LD_OWVAR 67
8648: ARRAY
8649: PUSH
8650: LD_INT 80
8652: PUSH
8653: LD_INT 60
8655: PUSH
8656: LD_INT 50
8658: PUSH
8659: EMPTY
8660: LIST
8661: LIST
8662: LIST
8663: PUSH
8664: LD_OWVAR 67
8668: ARRAY
8669: PUSH
8670: EMPTY
8671: LIST
8672: LIST
8673: LIST
8674: PPUSH
8675: LD_INT 7
8677: PUSH
8678: LD_INT 6
8680: PUSH
8681: LD_INT 5
8683: PUSH
8684: LD_INT 5
8686: PUSH
8687: EMPTY
8688: LIST
8689: LIST
8690: LIST
8691: LIST
8692: PPUSH
8693: CALL 28343 0 6
8697: ST_TO_ADDR
// if not base then
8698: LD_VAR 0 7
8702: NOT
8703: IFFALSE 8707
// exit ;
8705: GO 8842
// mc_bases := Replace ( mc_bases , mc_amer , base ) ;
8707: LD_ADDR_EXP 31
8711: PUSH
8712: LD_EXP 31
8716: PPUSH
8717: LD_EXP 5
8721: PPUSH
8722: LD_VAR 0 7
8726: PPUSH
8727: CALL_OW 1
8731: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , 7 ) ;
8732: LD_INT 1
8734: PPUSH
8735: LD_INT 1
8737: PPUSH
8738: LD_INT 7
8740: PPUSH
8741: CALL_OW 380
// allyCommander := CreateHuman ;
8745: LD_ADDR_EXP 11
8749: PUSH
8750: CALL_OW 44
8754: ST_TO_ADDR
// PlaceUnitXY ( allyCommander , 139 , 15 , false ) ;
8755: LD_EXP 11
8759: PPUSH
8760: LD_INT 139
8762: PPUSH
8763: LD_INT 15
8765: PPUSH
8766: LD_INT 0
8768: PPUSH
8769: CALL_OW 48
// ComTurnXY ( allyCommander , 137 , 15 ) ;
8773: LD_EXP 11
8777: PPUSH
8778: LD_INT 137
8780: PPUSH
8781: LD_INT 15
8783: PPUSH
8784: CALL_OW 118
// hc_gallery := us ;
8788: LD_ADDR_OWVAR 33
8792: PUSH
8793: LD_STRING us
8795: ST_TO_ADDR
// hc_face_number := 7 ;
8796: LD_ADDR_OWVAR 34
8800: PUSH
8801: LD_INT 7
8803: ST_TO_ADDR
// hc_name := Arthur Powell ;
8804: LD_ADDR_OWVAR 26
8808: PUSH
8809: LD_STRING Arthur Powell
8811: ST_TO_ADDR
// hc_sex := sex_male ;
8812: LD_ADDR_OWVAR 27
8816: PUSH
8817: LD_INT 1
8819: ST_TO_ADDR
// hc_class := 1 ;
8820: LD_ADDR_OWVAR 28
8824: PUSH
8825: LD_INT 1
8827: ST_TO_ADDR
// Powell := CreateHuman ;
8828: LD_ADDR_EXP 12
8832: PUSH
8833: CALL_OW 44
8837: ST_TO_ADDR
// InitHc ;
8838: CALL_OW 19
// end ;
8842: LD_VAR 0 1
8846: RET
// export function PreparePlayer ; var i , side , techs , tanks , cl , chassis , engines , weapons ; begin
8847: LD_INT 0
8849: PPUSH
8850: PPUSH
8851: PPUSH
8852: PPUSH
8853: PPUSH
8854: PPUSH
8855: PPUSH
8856: PPUSH
8857: PPUSH
// side := 1 ;
8858: LD_ADDR_VAR 0 3
8862: PUSH
8863: LD_INT 1
8865: ST_TO_ADDR
// result := [ [ ] , [ ] ] ;
8866: LD_ADDR_VAR 0 1
8870: PUSH
8871: EMPTY
8872: PUSH
8873: EMPTY
8874: PUSH
8875: EMPTY
8876: LIST
8877: LIST
8878: ST_TO_ADDR
// uc_side := side ;
8879: LD_ADDR_OWVAR 20
8883: PUSH
8884: LD_VAR 0 3
8888: ST_TO_ADDR
// uc_nation := nation_american ;
8889: LD_ADDR_OWVAR 21
8893: PUSH
8894: LD_INT 1
8896: ST_TO_ADDR
// InitHc ;
8897: CALL_OW 19
// InitVc ;
8901: CALL_OW 20
// hc_importance := 0 ;
8905: LD_ADDR_OWVAR 32
8909: PUSH
8910: LD_INT 0
8912: ST_TO_ADDR
// chassis := [ us_medium_wheeled , us_medium_tracked , us_medium_tracked ] ;
8913: LD_ADDR_VAR 0 7
8917: PUSH
8918: LD_INT 2
8920: PUSH
8921: LD_INT 3
8923: PUSH
8924: LD_INT 3
8926: PUSH
8927: EMPTY
8928: LIST
8929: LIST
8930: LIST
8931: ST_TO_ADDR
// if commander = 2 then
8932: LD_EXP 25
8936: PUSH
8937: LD_INT 2
8939: EQUAL
8940: IFFALSE 8961
// chassis := [ us_medium_tracked , us_heavy_tracked , us_heavy_tracked ] ;
8942: LD_ADDR_VAR 0 7
8946: PUSH
8947: LD_INT 3
8949: PUSH
8950: LD_INT 4
8952: PUSH
8953: LD_INT 4
8955: PUSH
8956: EMPTY
8957: LIST
8958: LIST
8959: LIST
8960: ST_TO_ADDR
// if commander = 3 then
8961: LD_EXP 25
8965: PUSH
8966: LD_INT 3
8968: EQUAL
8969: IFFALSE 8990
// chassis := [ us_medium_wheeled , us_morphling , us_morphling ] ;
8971: LD_ADDR_VAR 0 7
8975: PUSH
8976: LD_INT 2
8978: PUSH
8979: LD_INT 5
8981: PUSH
8982: LD_INT 5
8984: PUSH
8985: EMPTY
8986: LIST
8987: LIST
8988: LIST
8989: ST_TO_ADDR
// engines := [ engine_solar , engine_solar , engine_combustion ] ;
8990: LD_ADDR_VAR 0 8
8994: PUSH
8995: LD_INT 2
8997: PUSH
8998: LD_INT 2
9000: PUSH
9001: LD_INT 1
9003: PUSH
9004: EMPTY
9005: LIST
9006: LIST
9007: LIST
9008: ST_TO_ADDR
// if commander = 2 then
9009: LD_EXP 25
9013: PUSH
9014: LD_INT 2
9016: EQUAL
9017: IFFALSE 9038
// engines := [ engine_combustion , engine_combustion , engine_siberite ] ;
9019: LD_ADDR_VAR 0 8
9023: PUSH
9024: LD_INT 1
9026: PUSH
9027: LD_INT 1
9029: PUSH
9030: LD_INT 3
9032: PUSH
9033: EMPTY
9034: LIST
9035: LIST
9036: LIST
9037: ST_TO_ADDR
// if commander = 3 then
9038: LD_EXP 25
9042: PUSH
9043: LD_INT 3
9045: EQUAL
9046: IFFALSE 9067
// engines := [ engine_siberite , engine_siberite , engine_combustion ] ;
9048: LD_ADDR_VAR 0 8
9052: PUSH
9053: LD_INT 3
9055: PUSH
9056: LD_INT 3
9058: PUSH
9059: LD_INT 1
9061: PUSH
9062: EMPTY
9063: LIST
9064: LIST
9065: LIST
9066: ST_TO_ADDR
// weapons := [ us_double_gun , us_light_gun , us_gatling_gun ] ;
9067: LD_ADDR_VAR 0 9
9071: PUSH
9072: LD_INT 5
9074: PUSH
9075: LD_INT 3
9077: PUSH
9078: LD_INT 4
9080: PUSH
9081: EMPTY
9082: LIST
9083: LIST
9084: LIST
9085: ST_TO_ADDR
// if commander = 2 then
9086: LD_EXP 25
9090: PUSH
9091: LD_INT 2
9093: EQUAL
9094: IFFALSE 9115
// weapons := [ us_rocket_launcher , us_double_gun , us_heavy_gun ] ;
9096: LD_ADDR_VAR 0 9
9100: PUSH
9101: LD_INT 7
9103: PUSH
9104: LD_INT 5
9106: PUSH
9107: LD_INT 6
9109: PUSH
9110: EMPTY
9111: LIST
9112: LIST
9113: LIST
9114: ST_TO_ADDR
// if commander = 3 then
9115: LD_EXP 25
9119: PUSH
9120: LD_INT 3
9122: EQUAL
9123: IFFALSE 9144
// weapons := [ us_laser , us_double_laser , us_rocket_launcher ] ;
9125: LD_ADDR_VAR 0 9
9129: PUSH
9130: LD_INT 9
9132: PUSH
9133: LD_INT 10
9135: PUSH
9136: LD_INT 7
9138: PUSH
9139: EMPTY
9140: LIST
9141: LIST
9142: LIST
9143: ST_TO_ADDR
// tanks := [ 5 , 5 , 4 ] [ Difficulty ] ;
9144: LD_ADDR_VAR 0 5
9148: PUSH
9149: LD_INT 5
9151: PUSH
9152: LD_INT 5
9154: PUSH
9155: LD_INT 4
9157: PUSH
9158: EMPTY
9159: LIST
9160: LIST
9161: LIST
9162: PUSH
9163: LD_OWVAR 67
9167: ARRAY
9168: ST_TO_ADDR
// if commander = 2 then
9169: LD_EXP 25
9173: PUSH
9174: LD_INT 2
9176: EQUAL
9177: IFFALSE 9193
// tanks := tanks + 3 ;
9179: LD_ADDR_VAR 0 5
9183: PUSH
9184: LD_VAR 0 5
9188: PUSH
9189: LD_INT 3
9191: PLUS
9192: ST_TO_ADDR
// for i = 1 to tanks do
9193: LD_ADDR_VAR 0 2
9197: PUSH
9198: DOUBLE
9199: LD_INT 1
9201: DEC
9202: ST_TO_ADDR
9203: LD_VAR 0 5
9207: PUSH
9208: FOR_TO
9209: IFFALSE 9319
// begin PrepareVehicle ( chassis [ i mod 3 + 1 ] , engines [ rand ( 1 , 3 ) ] , control_manual , weapons [ i mod 3 + 1 ] , rand ( 60 , 70 ) ) ;
9211: LD_VAR 0 7
9215: PUSH
9216: LD_VAR 0 2
9220: PUSH
9221: LD_INT 3
9223: MOD
9224: PUSH
9225: LD_INT 1
9227: PLUS
9228: ARRAY
9229: PPUSH
9230: LD_VAR 0 8
9234: PUSH
9235: LD_INT 1
9237: PPUSH
9238: LD_INT 3
9240: PPUSH
9241: CALL_OW 12
9245: ARRAY
9246: PPUSH
9247: LD_INT 1
9249: PPUSH
9250: LD_VAR 0 9
9254: PUSH
9255: LD_VAR 0 2
9259: PUSH
9260: LD_INT 3
9262: MOD
9263: PUSH
9264: LD_INT 1
9266: PLUS
9267: ARRAY
9268: PPUSH
9269: LD_INT 60
9271: PPUSH
9272: LD_INT 70
9274: PPUSH
9275: CALL_OW 12
9279: PPUSH
9280: CALL 24899 0 5
// result := Replace ( result , 1 , result [ 1 ] ^ CreateVehicle ) ;
9284: LD_ADDR_VAR 0 1
9288: PUSH
9289: LD_VAR 0 1
9293: PPUSH
9294: LD_INT 1
9296: PPUSH
9297: LD_VAR 0 1
9301: PUSH
9302: LD_INT 1
9304: ARRAY
9305: PUSH
9306: CALL_OW 45
9310: ADD
9311: PPUSH
9312: CALL_OW 1
9316: ST_TO_ADDR
// end ;
9317: GO 9208
9319: POP
9320: POP
// cl := 1 ;
9321: LD_ADDR_VAR 0 6
9325: PUSH
9326: LD_INT 1
9328: ST_TO_ADDR
// for i = 1 to 10 do
9329: LD_ADDR_VAR 0 2
9333: PUSH
9334: DOUBLE
9335: LD_INT 1
9337: DEC
9338: ST_TO_ADDR
9339: LD_INT 10
9341: PUSH
9342: FOR_TO
9343: IFFALSE 9458
// begin if i mod 4 = 0 then
9345: LD_VAR 0 2
9349: PUSH
9350: LD_INT 4
9352: MOD
9353: PUSH
9354: LD_INT 0
9356: EQUAL
9357: IFFALSE 9373
// cl := cl + 1 ;
9359: LD_ADDR_VAR 0 6
9363: PUSH
9364: LD_VAR 0 6
9368: PUSH
9369: LD_INT 1
9371: PLUS
9372: ST_TO_ADDR
// if cl = 2 then
9373: LD_VAR 0 6
9377: PUSH
9378: LD_INT 2
9380: EQUAL
9381: IFFALSE 9391
// cl := 3 ;
9383: LD_ADDR_VAR 0 6
9387: PUSH
9388: LD_INT 3
9390: ST_TO_ADDR
// PrepareHuman ( false , cl , [ 6 , 6 , 5 ] [ Difficulty ] ) ;
9391: LD_INT 0
9393: PPUSH
9394: LD_VAR 0 6
9398: PPUSH
9399: LD_INT 6
9401: PUSH
9402: LD_INT 6
9404: PUSH
9405: LD_INT 5
9407: PUSH
9408: EMPTY
9409: LIST
9410: LIST
9411: LIST
9412: PUSH
9413: LD_OWVAR 67
9417: ARRAY
9418: PPUSH
9419: CALL_OW 380
// result := Replace ( result , 2 , result [ 2 ] ^ CreateHuman ) ;
9423: LD_ADDR_VAR 0 1
9427: PUSH
9428: LD_VAR 0 1
9432: PPUSH
9433: LD_INT 2
9435: PPUSH
9436: LD_VAR 0 1
9440: PUSH
9441: LD_INT 2
9443: ARRAY
9444: PUSH
9445: CALL_OW 44
9449: ADD
9450: PPUSH
9451: CALL_OW 1
9455: ST_TO_ADDR
// end ;
9456: GO 9342
9458: POP
9459: POP
// if commander = 1 then
9460: LD_EXP 25
9464: PUSH
9465: LD_INT 1
9467: EQUAL
9468: IFFALSE 9536
// for i = 1 to 4 do
9470: LD_ADDR_VAR 0 2
9474: PUSH
9475: DOUBLE
9476: LD_INT 1
9478: DEC
9479: ST_TO_ADDR
9480: LD_INT 4
9482: PUSH
9483: FOR_TO
9484: IFFALSE 9534
// begin PrepareHuman ( false , class_soldier , 8 ) ;
9486: LD_INT 0
9488: PPUSH
9489: LD_INT 1
9491: PPUSH
9492: LD_INT 8
9494: PPUSH
9495: CALL_OW 380
// result := Replace ( result , 2 , result [ 2 ] ^ CreateHuman ) ;
9499: LD_ADDR_VAR 0 1
9503: PUSH
9504: LD_VAR 0 1
9508: PPUSH
9509: LD_INT 2
9511: PPUSH
9512: LD_VAR 0 1
9516: PUSH
9517: LD_INT 2
9519: ARRAY
9520: PUSH
9521: CALL_OW 44
9525: ADD
9526: PPUSH
9527: CALL_OW 1
9531: ST_TO_ADDR
// end ;
9532: GO 9483
9534: POP
9535: POP
// techs := [ ] ;
9536: LD_ADDR_VAR 0 4
9540: PUSH
9541: EMPTY
9542: ST_TO_ADDR
// if commander = 1 then
9543: LD_EXP 25
9547: PUSH
9548: LD_INT 1
9550: EQUAL
9551: IFFALSE 9576
// techs := [ tech_weap1 , tech_weap2 , tech_weap3 , tech_lasSight ] ;
9553: LD_ADDR_VAR 0 4
9557: PUSH
9558: LD_INT 51
9560: PUSH
9561: LD_INT 52
9563: PUSH
9564: LD_INT 53
9566: PUSH
9567: LD_INT 12
9569: PUSH
9570: EMPTY
9571: LIST
9572: LIST
9573: LIST
9574: LIST
9575: ST_TO_ADDR
// if commander = 2 then
9576: LD_EXP 25
9580: PUSH
9581: LD_INT 2
9583: EQUAL
9584: IFFALSE 9621
// techs := [ tech_tech1 , tech_oilEng , tech_oilPow , tech_solEng , tech_solPow , tech_opto1 , tech_radar ] ;
9586: LD_ADDR_VAR 0 4
9590: PUSH
9591: LD_INT 48
9593: PUSH
9594: LD_INT 47
9596: PUSH
9597: LD_INT 46
9599: PUSH
9600: LD_INT 45
9602: PUSH
9603: LD_INT 35
9605: PUSH
9606: LD_INT 60
9608: PUSH
9609: LD_INT 6
9611: PUSH
9612: EMPTY
9613: LIST
9614: LIST
9615: LIST
9616: LIST
9617: LIST
9618: LIST
9619: LIST
9620: ST_TO_ADDR
// if commander = 3 then
9621: LD_EXP 25
9625: PUSH
9626: LD_INT 3
9628: EQUAL
9629: IFFALSE 9678
// techs := [ tech_advAI , tech_advchassis , tech_ai , tech_comp1 , tech_comp2 , tech_oilEng , tech_oilPow , tech_weap1 , tech_gatling , tech_gun ] ;
9631: LD_ADDR_VAR 0 4
9635: PUSH
9636: LD_INT 27
9638: PUSH
9639: LD_INT 36
9641: PUSH
9642: LD_INT 32
9644: PUSH
9645: LD_INT 57
9647: PUSH
9648: LD_INT 58
9650: PUSH
9651: LD_INT 47
9653: PUSH
9654: LD_INT 46
9656: PUSH
9657: LD_INT 51
9659: PUSH
9660: LD_INT 69
9662: PUSH
9663: LD_INT 39
9665: PUSH
9666: EMPTY
9667: LIST
9668: LIST
9669: LIST
9670: LIST
9671: LIST
9672: LIST
9673: LIST
9674: LIST
9675: LIST
9676: LIST
9677: ST_TO_ADDR
// if techs then
9678: LD_VAR 0 4
9682: IFFALSE 9716
// for i in techs do
9684: LD_ADDR_VAR 0 2
9688: PUSH
9689: LD_VAR 0 4
9693: PUSH
9694: FOR_IN
9695: IFFALSE 9714
// SetTech ( i , 1 , state_researched ) ;
9697: LD_VAR 0 2
9701: PPUSH
9702: LD_INT 1
9704: PPUSH
9705: LD_INT 2
9707: PPUSH
9708: CALL_OW 322
9712: GO 9694
9714: POP
9715: POP
// hc_gallery := skirmish ;
9716: LD_ADDR_OWVAR 33
9720: PUSH
9721: LD_STRING skirmish
9723: ST_TO_ADDR
// hc_face_number := commander ;
9724: LD_ADDR_OWVAR 34
9728: PUSH
9729: LD_EXP 25
9733: ST_TO_ADDR
// hc_importance := 100 ;
9734: LD_ADDR_OWVAR 32
9738: PUSH
9739: LD_INT 100
9741: ST_TO_ADDR
// case commander of 1 :
9742: LD_EXP 25
9746: PUSH
9747: LD_INT 1
9749: DOUBLE
9750: EQUAL
9751: IFTRUE 9755
9753: GO 9779
9755: POP
// begin hc_name := Jeff Ironside ;
9756: LD_ADDR_OWVAR 26
9760: PUSH
9761: LD_STRING Jeff Ironside
9763: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , 7 ) ;
9764: LD_INT 1
9766: PPUSH
9767: LD_INT 1
9769: PPUSH
9770: LD_INT 7
9772: PPUSH
9773: CALL_OW 380
// end ; 2 :
9777: GO 9844
9779: LD_INT 2
9781: DOUBLE
9782: EQUAL
9783: IFTRUE 9787
9785: GO 9811
9787: POP
// begin hc_name := Paul Johnson ;
9788: LD_ADDR_OWVAR 26
9792: PUSH
9793: LD_STRING Paul Johnson
9795: ST_TO_ADDR
// PrepareHuman ( sex_male , 3 , 7 ) ;
9796: LD_INT 1
9798: PPUSH
9799: LD_INT 3
9801: PPUSH
9802: LD_INT 7
9804: PPUSH
9805: CALL_OW 380
// end ; 3 :
9809: GO 9844
9811: LD_INT 3
9813: DOUBLE
9814: EQUAL
9815: IFTRUE 9819
9817: GO 9843
9819: POP
// begin hc_name := Lisa Stuart ;
9820: LD_ADDR_OWVAR 26
9824: PUSH
9825: LD_STRING Lisa Stuart
9827: ST_TO_ADDR
// PrepareHuman ( sex_female , 4 , 7 ) ;
9828: LD_INT 2
9830: PPUSH
9831: LD_INT 4
9833: PPUSH
9834: LD_INT 7
9836: PPUSH
9837: CALL_OW 380
// end ; end ;
9841: GO 9844
9843: POP
// playerCommander := CreateHuman ;
9844: LD_ADDR_EXP 9
9848: PUSH
9849: CALL_OW 44
9853: ST_TO_ADDR
// hc_importance := 0 ;
9854: LD_ADDR_OWVAR 32
9858: PUSH
9859: LD_INT 0
9861: ST_TO_ADDR
// hc_gallery :=  ;
9862: LD_ADDR_OWVAR 33
9866: PUSH
9867: LD_STRING 
9869: ST_TO_ADDR
// result := Replace ( result , 2 , result [ 2 ] ^ playerCommander ) ;
9870: LD_ADDR_VAR 0 1
9874: PUSH
9875: LD_VAR 0 1
9879: PPUSH
9880: LD_INT 2
9882: PPUSH
9883: LD_VAR 0 1
9887: PUSH
9888: LD_INT 2
9890: ARRAY
9891: PUSH
9892: LD_EXP 9
9896: ADD
9897: PPUSH
9898: CALL_OW 1
9902: ST_TO_ADDR
// end ;
9903: LD_VAR 0 1
9907: RET
// export function PrepareReinforcements ; var i , peopleAmount , tmp , un , veh ; begin
9908: LD_INT 0
9910: PPUSH
9911: PPUSH
9912: PPUSH
9913: PPUSH
9914: PPUSH
9915: PPUSH
// uc_side := 1 ;
9916: LD_ADDR_OWVAR 20
9920: PUSH
9921: LD_INT 1
9923: ST_TO_ADDR
// uc_nation := 1 ;
9924: LD_ADDR_OWVAR 21
9928: PUSH
9929: LD_INT 1
9931: ST_TO_ADDR
// InitHc ;
9932: CALL_OW 19
// peopleAmount := [ 3 , 3 , 2 ] [ Difficulty ] ;
9936: LD_ADDR_VAR 0 3
9940: PUSH
9941: LD_INT 3
9943: PUSH
9944: LD_INT 3
9946: PUSH
9947: LD_INT 2
9949: PUSH
9950: EMPTY
9951: LIST
9952: LIST
9953: LIST
9954: PUSH
9955: LD_OWVAR 67
9959: ARRAY
9960: ST_TO_ADDR
// for i = 1 to peopleAmount do
9961: LD_ADDR_VAR 0 2
9965: PUSH
9966: DOUBLE
9967: LD_INT 1
9969: DEC
9970: ST_TO_ADDR
9971: LD_VAR 0 3
9975: PUSH
9976: FOR_TO
9977: IFFALSE 10026
// begin PrepareHuman ( false , 2 , [ 7 , 6 , 5 ] [ Difficulty ] ) ;
9979: LD_INT 0
9981: PPUSH
9982: LD_INT 2
9984: PPUSH
9985: LD_INT 7
9987: PUSH
9988: LD_INT 6
9990: PUSH
9991: LD_INT 5
9993: PUSH
9994: EMPTY
9995: LIST
9996: LIST
9997: LIST
9998: PUSH
9999: LD_OWVAR 67
10003: ARRAY
10004: PPUSH
10005: CALL_OW 380
// PlaceUnitInArea ( CreateHuman , startArea , false ) ;
10009: CALL_OW 44
10013: PPUSH
10014: LD_INT 19
10016: PPUSH
10017: LD_INT 0
10019: PPUSH
10020: CALL 56250 0 3
// end ;
10024: GO 9976
10026: POP
10027: POP
// PrepareVehicle ( us_medium_wheeled , engine_combustion , control_computer , us_crane , 58 ) ;
10028: LD_INT 2
10030: PPUSH
10031: LD_INT 1
10033: PPUSH
10034: LD_INT 3
10036: PPUSH
10037: LD_INT 13
10039: PPUSH
10040: LD_INT 58
10042: PPUSH
10043: CALL 24899 0 5
// PlaceUnitInArea ( CreateVehicle , startArea , false ) ;
10047: CALL_OW 45
10051: PPUSH
10052: LD_INT 19
10054: PPUSH
10055: LD_INT 0
10057: PPUSH
10058: CALL 56250 0 3
// if commander = 1 then
10062: LD_EXP 25
10066: PUSH
10067: LD_INT 1
10069: EQUAL
10070: IFFALSE 10081
// wait ( 6 6$00 ) else
10072: LD_INT 12600
10074: PPUSH
10075: CALL_OW 67
10079: GO 10088
// wait ( 8 8$00 ) ;
10081: LD_INT 16800
10083: PPUSH
10084: CALL_OW 67
// uc_side := 1 ;
10088: LD_ADDR_OWVAR 20
10092: PUSH
10093: LD_INT 1
10095: ST_TO_ADDR
// uc_nation := 1 ;
10096: LD_ADDR_OWVAR 21
10100: PUSH
10101: LD_INT 1
10103: ST_TO_ADDR
// InitVc ;
10104: CALL_OW 20
// InitHc ;
10108: CALL_OW 19
// for i = 1 to 5 do
10112: LD_ADDR_VAR 0 2
10116: PUSH
10117: DOUBLE
10118: LD_INT 1
10120: DEC
10121: ST_TO_ADDR
10122: LD_INT 5
10124: PUSH
10125: FOR_TO
10126: IFFALSE 10370
// begin PrepareVehicle ( [ us_heavy_tracked , us_medium_tracked , us_light_wheeled ] [ i mod 3 + 1 ] , engine_combustion , [ control_manual , control_computer , control_computer ] [ i mod 3 + 1 ] , [ us_heavy_gun , us_cargo_bay , us_radar ] [ i mod 3 + 1 ] , rand ( 40 , 55 ) ) ;
10128: LD_INT 4
10130: PUSH
10131: LD_INT 3
10133: PUSH
10134: LD_INT 1
10136: PUSH
10137: EMPTY
10138: LIST
10139: LIST
10140: LIST
10141: PUSH
10142: LD_VAR 0 2
10146: PUSH
10147: LD_INT 3
10149: MOD
10150: PUSH
10151: LD_INT 1
10153: PLUS
10154: ARRAY
10155: PPUSH
10156: LD_INT 1
10158: PPUSH
10159: LD_INT 1
10161: PUSH
10162: LD_INT 3
10164: PUSH
10165: LD_INT 3
10167: PUSH
10168: EMPTY
10169: LIST
10170: LIST
10171: LIST
10172: PUSH
10173: LD_VAR 0 2
10177: PUSH
10178: LD_INT 3
10180: MOD
10181: PUSH
10182: LD_INT 1
10184: PLUS
10185: ARRAY
10186: PPUSH
10187: LD_INT 6
10189: PUSH
10190: LD_INT 12
10192: PUSH
10193: LD_INT 11
10195: PUSH
10196: EMPTY
10197: LIST
10198: LIST
10199: LIST
10200: PUSH
10201: LD_VAR 0 2
10205: PUSH
10206: LD_INT 3
10208: MOD
10209: PUSH
10210: LD_INT 1
10212: PLUS
10213: ARRAY
10214: PPUSH
10215: LD_INT 40
10217: PPUSH
10218: LD_INT 55
10220: PPUSH
10221: CALL_OW 12
10225: PPUSH
10226: CALL 24899 0 5
// veh := CreateVehicle ;
10230: LD_ADDR_VAR 0 6
10234: PUSH
10235: CALL_OW 45
10239: ST_TO_ADDR
// PlaceUnitInArea ( veh , startArea , false ) ;
10240: LD_VAR 0 6
10244: PPUSH
10245: LD_INT 19
10247: PPUSH
10248: LD_INT 0
10250: PPUSH
10251: CALL 56250 0 3
// if GetWeapon ( veh ) = us_cargo_bay then
10255: LD_VAR 0 6
10259: PPUSH
10260: CALL_OW 264
10264: PUSH
10265: LD_INT 12
10267: EQUAL
10268: IFFALSE 10300
// begin AddCargo ( veh , mat_cans , 70 ) ;
10270: LD_VAR 0 6
10274: PPUSH
10275: LD_INT 1
10277: PPUSH
10278: LD_INT 70
10280: PPUSH
10281: CALL_OW 291
// AddCargo ( veh , mat_siberit , 30 ) ;
10285: LD_VAR 0 6
10289: PPUSH
10290: LD_INT 3
10292: PPUSH
10293: LD_INT 30
10295: PPUSH
10296: CALL_OW 291
// end ; if GetControl ( veh ) = control_manual then
10300: LD_VAR 0 6
10304: PPUSH
10305: CALL_OW 263
10309: PUSH
10310: LD_INT 1
10312: EQUAL
10313: IFFALSE 10368
// begin PrepareHuman ( sex_male , 3 , 6 ) ;
10315: LD_INT 1
10317: PPUSH
10318: LD_INT 3
10320: PPUSH
10321: LD_INT 6
10323: PPUSH
10324: CALL_OW 380
// un := CreateHuman ;
10328: LD_ADDR_VAR 0 5
10332: PUSH
10333: CALL_OW 44
10337: ST_TO_ADDR
// tmp := tmp ^ un ;
10338: LD_ADDR_VAR 0 4
10342: PUSH
10343: LD_VAR 0 4
10347: PUSH
10348: LD_VAR 0 5
10352: ADD
10353: ST_TO_ADDR
// PlaceHumanInUnit ( un , veh ) ;
10354: LD_VAR 0 5
10358: PPUSH
10359: LD_VAR 0 6
10363: PPUSH
10364: CALL_OW 52
// end ; end ;
10368: GO 10125
10370: POP
10371: POP
// if tmp then
10372: LD_VAR 0 4
10376: IFFALSE 10440
// begin CenterNowOnUnits ( tmp ) ;
10378: LD_VAR 0 4
10382: PPUSH
10383: CALL_OW 87
// Say ( tmp [ 1 ] , DAR-1 ) ;
10387: LD_VAR 0 4
10391: PUSH
10392: LD_INT 1
10394: ARRAY
10395: PPUSH
10396: LD_STRING DAR-1
10398: PPUSH
10399: CALL_OW 88
// Say ( playerCommander , D & [ I , J , S ] [ commander ] & -1-DAR ) ;
10403: LD_EXP 9
10407: PPUSH
10408: LD_STRING D
10410: PUSH
10411: LD_STRING I
10413: PUSH
10414: LD_STRING J
10416: PUSH
10417: LD_STRING S
10419: PUSH
10420: EMPTY
10421: LIST
10422: LIST
10423: LIST
10424: PUSH
10425: LD_EXP 25
10429: ARRAY
10430: STR
10431: PUSH
10432: LD_STRING -1-DAR
10434: STR
10435: PPUSH
10436: CALL_OW 88
// end ; if not reinforceAllowed then
10440: LD_EXP 24
10444: NOT
10445: IFFALSE 10449
// exit ;
10447: GO 10603
// wait ( 25 25$00 ) ;
10449: LD_INT 52500
10451: PPUSH
10452: CALL_OW 67
// uc_side := 1 ;
10456: LD_ADDR_OWVAR 20
10460: PUSH
10461: LD_INT 1
10463: ST_TO_ADDR
// uc_nation := 1 ;
10464: LD_ADDR_OWVAR 21
10468: PUSH
10469: LD_INT 1
10471: ST_TO_ADDR
// InitVc ;
10472: CALL_OW 20
// InitHc ;
10476: CALL_OW 19
// for i = 1 to 4 do
10480: LD_ADDR_VAR 0 2
10484: PUSH
10485: DOUBLE
10486: LD_INT 1
10488: DEC
10489: ST_TO_ADDR
10490: LD_INT 4
10492: PUSH
10493: FOR_TO
10494: IFFALSE 10601
// begin PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 1 ) ;
10496: LD_INT 5
10498: PPUSH
10499: LD_INT 3
10501: PPUSH
10502: LD_INT 1
10504: PPUSH
10505: LD_INT 6
10507: PPUSH
10508: LD_INT 1
10510: PPUSH
10511: CALL 24899 0 5
// veh := CreateVehicle ;
10515: LD_ADDR_VAR 0 6
10519: PUSH
10520: CALL_OW 45
10524: ST_TO_ADDR
// PlaceUnitInArea ( veh , startArea , false ) ;
10525: LD_VAR 0 6
10529: PPUSH
10530: LD_INT 19
10532: PPUSH
10533: LD_INT 0
10535: PPUSH
10536: CALL 56250 0 3
// if GetControl ( veh ) = control_manual then
10540: LD_VAR 0 6
10544: PPUSH
10545: CALL_OW 263
10549: PUSH
10550: LD_INT 1
10552: EQUAL
10553: IFFALSE 10599
// begin PrepareHuman ( false , 3 , [ 7 , 6 , 5 ] [ Difficulty ] ) ;
10555: LD_INT 0
10557: PPUSH
10558: LD_INT 3
10560: PPUSH
10561: LD_INT 7
10563: PUSH
10564: LD_INT 6
10566: PUSH
10567: LD_INT 5
10569: PUSH
10570: EMPTY
10571: LIST
10572: LIST
10573: LIST
10574: PUSH
10575: LD_OWVAR 67
10579: ARRAY
10580: PPUSH
10581: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , veh ) ;
10585: CALL_OW 44
10589: PPUSH
10590: LD_VAR 0 6
10594: PPUSH
10595: CALL_OW 52
// end ; end ;
10599: GO 10493
10601: POP
10602: POP
// end ;
10603: LD_VAR 0 1
10607: RET
// export function PrepareLegionReinforcements ; var i , un , j , tmp ; begin
10608: LD_INT 0
10610: PPUSH
10611: PPUSH
10612: PPUSH
10613: PPUSH
10614: PPUSH
// uc_side := 8 ;
10615: LD_ADDR_OWVAR 20
10619: PUSH
10620: LD_INT 8
10622: ST_TO_ADDR
// uc_nation := nation_arabian ;
10623: LD_ADDR_OWVAR 21
10627: PUSH
10628: LD_INT 2
10630: ST_TO_ADDR
// for i = 1 to 2 do
10631: LD_ADDR_VAR 0 2
10635: PUSH
10636: DOUBLE
10637: LD_INT 1
10639: DEC
10640: ST_TO_ADDR
10641: LD_INT 2
10643: PUSH
10644: FOR_TO
10645: IFFALSE 10725
// for j = 1 to 4 do
10647: LD_ADDR_VAR 0 4
10651: PUSH
10652: DOUBLE
10653: LD_INT 1
10655: DEC
10656: ST_TO_ADDR
10657: LD_INT 4
10659: PUSH
10660: FOR_TO
10661: IFFALSE 10721
// begin PrepareHuman ( false , j , 8 ) ;
10663: LD_INT 0
10665: PPUSH
10666: LD_VAR 0 4
10670: PPUSH
10671: LD_INT 8
10673: PPUSH
10674: CALL_OW 380
// un := CreateHuman ;
10678: LD_ADDR_VAR 0 3
10682: PUSH
10683: CALL_OW 44
10687: ST_TO_ADDR
// PlaceUnitArea ( un , legionSpawn , false ) ;
10688: LD_VAR 0 3
10692: PPUSH
10693: LD_INT 23
10695: PPUSH
10696: LD_INT 0
10698: PPUSH
10699: CALL_OW 49
// tmp := tmp union un ;
10703: LD_ADDR_VAR 0 5
10707: PUSH
10708: LD_VAR 0 5
10712: PUSH
10713: LD_VAR 0 3
10717: UNION
10718: ST_TO_ADDR
// end ;
10719: GO 10660
10721: POP
10722: POP
10723: GO 10644
10725: POP
10726: POP
// for i in tmp do
10727: LD_ADDR_VAR 0 2
10731: PUSH
10732: LD_VAR 0 5
10736: PUSH
10737: FOR_IN
10738: IFFALSE 10757
// ComMoveXY ( i , 150 , 136 ) ;
10740: LD_VAR 0 2
10744: PPUSH
10745: LD_INT 150
10747: PPUSH
10748: LD_INT 136
10750: PPUSH
10751: CALL_OW 111
10755: GO 10737
10757: POP
10758: POP
// mc_bases := Replace ( mc_bases , mc_leg , mc_bases [ mc_leg ] union tmp ) ;
10759: LD_ADDR_EXP 31
10763: PUSH
10764: LD_EXP 31
10768: PPUSH
10769: LD_EXP 6
10773: PPUSH
10774: LD_EXP 31
10778: PUSH
10779: LD_EXP 6
10783: ARRAY
10784: PUSH
10785: LD_VAR 0 5
10789: UNION
10790: PPUSH
10791: CALL_OW 1
10795: ST_TO_ADDR
// end ;
10796: LD_VAR 0 1
10800: RET
// every 0 0$10 trigger Difficulty > 1 and GetTech ( tech_lapser , 3 ) = state_researched do
10801: LD_OWVAR 67
10805: PUSH
10806: LD_INT 1
10808: GREATER
10809: PUSH
10810: LD_INT 31
10812: PPUSH
10813: LD_INT 3
10815: PPUSH
10816: CALL_OW 321
10820: PUSH
10821: LD_INT 2
10823: EQUAL
10824: AND
10825: IFFALSE 11042
10827: GO 10829
10829: DISABLE
// begin MC_InsertBuildingList ( mc_rus_1 , [ [ b_turret , 101 , 159 , 5 ] , [ b_turret , 105 , 158 , 5 ] , [ b_turret , 96 , 136 , 5 ] , [ b_turret , 94 , 133 , 4 ] , [ b_turret , 84 , 102 , 4 ] ] ) ;
10830: LD_EXP 7
10834: PPUSH
10835: LD_INT 33
10837: PUSH
10838: LD_INT 101
10840: PUSH
10841: LD_INT 159
10843: PUSH
10844: LD_INT 5
10846: PUSH
10847: EMPTY
10848: LIST
10849: LIST
10850: LIST
10851: LIST
10852: PUSH
10853: LD_INT 33
10855: PUSH
10856: LD_INT 105
10858: PUSH
10859: LD_INT 158
10861: PUSH
10862: LD_INT 5
10864: PUSH
10865: EMPTY
10866: LIST
10867: LIST
10868: LIST
10869: LIST
10870: PUSH
10871: LD_INT 33
10873: PUSH
10874: LD_INT 96
10876: PUSH
10877: LD_INT 136
10879: PUSH
10880: LD_INT 5
10882: PUSH
10883: EMPTY
10884: LIST
10885: LIST
10886: LIST
10887: LIST
10888: PUSH
10889: LD_INT 33
10891: PUSH
10892: LD_INT 94
10894: PUSH
10895: LD_INT 133
10897: PUSH
10898: LD_INT 4
10900: PUSH
10901: EMPTY
10902: LIST
10903: LIST
10904: LIST
10905: LIST
10906: PUSH
10907: LD_INT 33
10909: PUSH
10910: LD_INT 84
10912: PUSH
10913: LD_INT 102
10915: PUSH
10916: LD_INT 4
10918: PUSH
10919: EMPTY
10920: LIST
10921: LIST
10922: LIST
10923: LIST
10924: PUSH
10925: EMPTY
10926: LIST
10927: LIST
10928: LIST
10929: LIST
10930: LIST
10931: PPUSH
10932: CALL 85420 0 2
// MC_InsertBuildingList ( mc_rus_2 , [ [ b_turret , 50 , 17 , 4 ] , [ b_turret , 52 , 20 , 4 ] , [ b_turret , 53 , 23 , 4 ] , [ b_turret , 45 , 32 , 4 ] , [ b_turret , 45 , 39 , 4 ] ] ) ;
10936: LD_EXP 8
10940: PPUSH
10941: LD_INT 33
10943: PUSH
10944: LD_INT 50
10946: PUSH
10947: LD_INT 17
10949: PUSH
10950: LD_INT 4
10952: PUSH
10953: EMPTY
10954: LIST
10955: LIST
10956: LIST
10957: LIST
10958: PUSH
10959: LD_INT 33
10961: PUSH
10962: LD_INT 52
10964: PUSH
10965: LD_INT 20
10967: PUSH
10968: LD_INT 4
10970: PUSH
10971: EMPTY
10972: LIST
10973: LIST
10974: LIST
10975: LIST
10976: PUSH
10977: LD_INT 33
10979: PUSH
10980: LD_INT 53
10982: PUSH
10983: LD_INT 23
10985: PUSH
10986: LD_INT 4
10988: PUSH
10989: EMPTY
10990: LIST
10991: LIST
10992: LIST
10993: LIST
10994: PUSH
10995: LD_INT 33
10997: PUSH
10998: LD_INT 45
11000: PUSH
11001: LD_INT 32
11003: PUSH
11004: LD_INT 4
11006: PUSH
11007: EMPTY
11008: LIST
11009: LIST
11010: LIST
11011: LIST
11012: PUSH
11013: LD_INT 33
11015: PUSH
11016: LD_INT 45
11018: PUSH
11019: LD_INT 39
11021: PUSH
11022: LD_INT 4
11024: PUSH
11025: EMPTY
11026: LIST
11027: LIST
11028: LIST
11029: LIST
11030: PUSH
11031: EMPTY
11032: LIST
11033: LIST
11034: LIST
11035: LIST
11036: LIST
11037: PPUSH
11038: CALL 85420 0 2
// end ;
11042: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_not , [ f_side , your_side ] ] , [ f_control , control_remote ] , [ f_ok ] , [ f_not , [ f_linked ] ] ] ) do var i , tmp ;
11043: LD_INT 3
11045: PUSH
11046: LD_INT 22
11048: PUSH
11049: LD_OWVAR 2
11053: PUSH
11054: EMPTY
11055: LIST
11056: LIST
11057: PUSH
11058: EMPTY
11059: LIST
11060: LIST
11061: PUSH
11062: LD_INT 33
11064: PUSH
11065: LD_INT 2
11067: PUSH
11068: EMPTY
11069: LIST
11070: LIST
11071: PUSH
11072: LD_INT 50
11074: PUSH
11075: EMPTY
11076: LIST
11077: PUSH
11078: LD_INT 3
11080: PUSH
11081: LD_INT 61
11083: PUSH
11084: EMPTY
11085: LIST
11086: PUSH
11087: EMPTY
11088: LIST
11089: LIST
11090: PUSH
11091: EMPTY
11092: LIST
11093: LIST
11094: LIST
11095: LIST
11096: PPUSH
11097: CALL_OW 69
11101: IFFALSE 11201
11103: GO 11105
11105: DISABLE
11106: LD_INT 0
11108: PPUSH
11109: PPUSH
// begin enable ;
11110: ENABLE
// tmp := FilterAllUnits ( [ [ f_not , [ f_side , your_side ] ] , [ f_control , control_remote ] , [ f_ok ] , [ f_not , [ f_linked ] ] ] ) ;
11111: LD_ADDR_VAR 0 2
11115: PUSH
11116: LD_INT 3
11118: PUSH
11119: LD_INT 22
11121: PUSH
11122: LD_OWVAR 2
11126: PUSH
11127: EMPTY
11128: LIST
11129: LIST
11130: PUSH
11131: EMPTY
11132: LIST
11133: LIST
11134: PUSH
11135: LD_INT 33
11137: PUSH
11138: LD_INT 2
11140: PUSH
11141: EMPTY
11142: LIST
11143: LIST
11144: PUSH
11145: LD_INT 50
11147: PUSH
11148: EMPTY
11149: LIST
11150: PUSH
11151: LD_INT 3
11153: PUSH
11154: LD_INT 61
11156: PUSH
11157: EMPTY
11158: LIST
11159: PUSH
11160: EMPTY
11161: LIST
11162: LIST
11163: PUSH
11164: EMPTY
11165: LIST
11166: LIST
11167: LIST
11168: LIST
11169: PPUSH
11170: CALL_OW 69
11174: ST_TO_ADDR
// for i in tmp do
11175: LD_ADDR_VAR 0 1
11179: PUSH
11180: LD_VAR 0 2
11184: PUSH
11185: FOR_IN
11186: IFFALSE 11199
// Connect ( i ) ;
11188: LD_VAR 0 1
11192: PPUSH
11193: CALL 27990 0 1
11197: GO 11185
11199: POP
11200: POP
// end ; end_of_file
11201: PPOPN 2
11203: END
// export function Action ; var i , tmp ; begin
11204: LD_INT 0
11206: PPUSH
11207: PPUSH
11208: PPUSH
// InGameOn ;
11209: CALL_OW 8
// CenterNowOnXY ( 225 , 217 ) ;
11213: LD_INT 225
11215: PPUSH
11216: LD_INT 217
11218: PPUSH
11219: CALL_OW 86
// for i in playerForces [ 2 ] do
11223: LD_ADDR_VAR 0 2
11227: PUSH
11228: LD_EXP 10
11232: PUSH
11233: LD_INT 2
11235: ARRAY
11236: PUSH
11237: FOR_IN
11238: IFFALSE 11371
// begin if playerForces [ 1 ] and GetClass ( i ) in [ 3 , 4 ] then
11240: LD_EXP 10
11244: PUSH
11245: LD_INT 1
11247: ARRAY
11248: PUSH
11249: LD_VAR 0 2
11253: PPUSH
11254: CALL_OW 257
11258: PUSH
11259: LD_INT 3
11261: PUSH
11262: LD_INT 4
11264: PUSH
11265: EMPTY
11266: LIST
11267: LIST
11268: IN
11269: AND
11270: IFFALSE 11354
// begin PlaceUnitInArea ( playerForces [ 1 ] [ 1 ] , startArea , false ) ;
11272: LD_EXP 10
11276: PUSH
11277: LD_INT 1
11279: ARRAY
11280: PUSH
11281: LD_INT 1
11283: ARRAY
11284: PPUSH
11285: LD_INT 19
11287: PPUSH
11288: LD_INT 0
11290: PPUSH
11291: CALL 56250 0 3
// PlaceHumanInUnit ( i , playerForces [ 1 ] [ 1 ] ) ;
11295: LD_VAR 0 2
11299: PPUSH
11300: LD_EXP 10
11304: PUSH
11305: LD_INT 1
11307: ARRAY
11308: PUSH
11309: LD_INT 1
11311: ARRAY
11312: PPUSH
11313: CALL_OW 52
// playerForces := Replace ( playerForces , 1 , Delete ( playerForces [ 1 ] , 1 ) ) ;
11317: LD_ADDR_EXP 10
11321: PUSH
11322: LD_EXP 10
11326: PPUSH
11327: LD_INT 1
11329: PPUSH
11330: LD_EXP 10
11334: PUSH
11335: LD_INT 1
11337: ARRAY
11338: PPUSH
11339: LD_INT 1
11341: PPUSH
11342: CALL_OW 3
11346: PPUSH
11347: CALL_OW 1
11351: ST_TO_ADDR
// end else
11352: GO 11369
// PlaceUnitInArea ( i , startArea , false ) ;
11354: LD_VAR 0 2
11358: PPUSH
11359: LD_INT 19
11361: PPUSH
11362: LD_INT 0
11364: PPUSH
11365: CALL 56250 0 3
// end ;
11369: GO 11237
11371: POP
11372: POP
// wait ( 0 0$2 ) ;
11373: LD_INT 70
11375: PPUSH
11376: CALL_OW 67
// Say ( playerCommander , D & [ I , J , S ] [ commander ] & -1 ) ;
11380: LD_EXP 9
11384: PPUSH
11385: LD_STRING D
11387: PUSH
11388: LD_STRING I
11390: PUSH
11391: LD_STRING J
11393: PUSH
11394: LD_STRING S
11396: PUSH
11397: EMPTY
11398: LIST
11399: LIST
11400: LIST
11401: PUSH
11402: LD_EXP 25
11406: ARRAY
11407: STR
11408: PUSH
11409: LD_STRING -1
11411: STR
11412: PPUSH
11413: CALL_OW 88
// SayRadio ( Powell , DP-1 ) ;
11417: LD_EXP 12
11421: PPUSH
11422: LD_STRING DP-1
11424: PPUSH
11425: CALL_OW 94
// SayRadio ( Powell , DP-2 ) ;
11429: LD_EXP 12
11433: PPUSH
11434: LD_STRING DP-2
11436: PPUSH
11437: CALL_OW 94
// Say ( playerCommander , D & [ I , J , S ] [ commander ] & -2 ) ;
11441: LD_EXP 9
11445: PPUSH
11446: LD_STRING D
11448: PUSH
11449: LD_STRING I
11451: PUSH
11452: LD_STRING J
11454: PUSH
11455: LD_STRING S
11457: PUSH
11458: EMPTY
11459: LIST
11460: LIST
11461: LIST
11462: PUSH
11463: LD_EXP 25
11467: ARRAY
11468: STR
11469: PUSH
11470: LD_STRING -2
11472: STR
11473: PPUSH
11474: CALL_OW 88
// InGameOff ;
11478: CALL_OW 9
// ChangeMissionObjectives ( O1 ) ;
11482: LD_STRING O1
11484: PPUSH
11485: CALL_OW 337
// game := true ;
11489: LD_ADDR_EXP 3
11493: PUSH
11494: LD_INT 1
11496: ST_TO_ADDR
// SaveForQuickRestart ;
11497: CALL_OW 22
// wait ( 0 0$5 ) ;
11501: LD_INT 175
11503: PPUSH
11504: CALL_OW 67
// Say ( playerCommander , D & [ I , J , S ] [ commander ] & -3 ) ;
11508: LD_EXP 9
11512: PPUSH
11513: LD_STRING D
11515: PUSH
11516: LD_STRING I
11518: PUSH
11519: LD_STRING J
11521: PUSH
11522: LD_STRING S
11524: PUSH
11525: EMPTY
11526: LIST
11527: LIST
11528: LIST
11529: PUSH
11530: LD_EXP 25
11534: ARRAY
11535: STR
11536: PUSH
11537: LD_STRING -3
11539: STR
11540: PPUSH
11541: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
11545: LD_INT 35
11547: PPUSH
11548: CALL_OW 67
// until ruEscape [ 1 ] >= ruEscape [ 2 ] ;
11552: LD_EXP 15
11556: PUSH
11557: LD_INT 1
11559: ARRAY
11560: PUSH
11561: LD_EXP 15
11565: PUSH
11566: LD_INT 2
11568: ARRAY
11569: GREATEREQUAL
11570: IFFALSE 11545
// outpostEscape := true ;
11572: LD_ADDR_EXP 27
11576: PUSH
11577: LD_INT 1
11579: ST_TO_ADDR
// tmp := UnitFilter ( ruOutpost , [ f_sex , sex_male ] ) ;
11580: LD_ADDR_VAR 0 3
11584: PUSH
11585: LD_EXP 14
11589: PPUSH
11590: LD_INT 26
11592: PUSH
11593: LD_INT 1
11595: PUSH
11596: EMPTY
11597: LIST
11598: LIST
11599: PPUSH
11600: CALL_OW 72
11604: ST_TO_ADDR
// if tmp then
11605: LD_VAR 0 3
11609: IFFALSE 11627
// Say ( tmp [ 1 ] , DR-1-Escape ) ;
11611: LD_VAR 0 3
11615: PUSH
11616: LD_INT 1
11618: ARRAY
11619: PPUSH
11620: LD_STRING DR-1-Escape
11622: PPUSH
11623: CALL_OW 88
// wait ( 0 0$1 ) ;
11627: LD_INT 35
11629: PPUSH
11630: CALL_OW 67
// Say ( playerCommander , D & [ I , J , S ] [ commander ] & -1-Escape ) ;
11634: LD_EXP 9
11638: PPUSH
11639: LD_STRING D
11641: PUSH
11642: LD_STRING I
11644: PUSH
11645: LD_STRING J
11647: PUSH
11648: LD_STRING S
11650: PUSH
11651: EMPTY
11652: LIST
11653: LIST
11654: LIST
11655: PUSH
11656: LD_EXP 25
11660: ARRAY
11661: STR
11662: PUSH
11663: LD_STRING -1-Escape
11665: STR
11666: PPUSH
11667: CALL_OW 88
// for i in ruOutpost do
11671: LD_ADDR_VAR 0 2
11675: PUSH
11676: LD_EXP 14
11680: PUSH
11681: FOR_IN
11682: IFFALSE 11736
// begin if IsInUnit ( i ) then
11684: LD_VAR 0 2
11688: PPUSH
11689: CALL_OW 310
11693: IFFALSE 11704
// ComExitBuilding ( i ) ;
11695: LD_VAR 0 2
11699: PPUSH
11700: CALL_OW 122
// AddComMoveXY ( i , 179 , 102 ) ;
11704: LD_VAR 0 2
11708: PPUSH
11709: LD_INT 179
11711: PPUSH
11712: LD_INT 102
11714: PPUSH
11715: CALL_OW 171
// AddComMoveXY ( i , 28 , 20 ) ;
11719: LD_VAR 0 2
11723: PPUSH
11724: LD_INT 28
11726: PPUSH
11727: LD_INT 20
11729: PPUSH
11730: CALL_OW 171
// end ;
11734: GO 11681
11736: POP
11737: POP
// tmp := [ ] ;
11738: LD_ADDR_VAR 0 3
11742: PUSH
11743: EMPTY
11744: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
11745: LD_INT 35
11747: PPUSH
11748: CALL_OW 67
// tmp := UnitFilter ( ruOutpost , [ f_inarea , rus2Base ] ) ;
11752: LD_ADDR_VAR 0 3
11756: PUSH
11757: LD_EXP 14
11761: PPUSH
11762: LD_INT 95
11764: PUSH
11765: LD_INT 11
11767: PUSH
11768: EMPTY
11769: LIST
11770: LIST
11771: PPUSH
11772: CALL_OW 72
11776: ST_TO_ADDR
// if tmp then
11777: LD_VAR 0 3
11781: IFFALSE 11860
// for i in tmp do
11783: LD_ADDR_VAR 0 2
11787: PUSH
11788: LD_VAR 0 3
11792: PUSH
11793: FOR_IN
11794: IFFALSE 11858
// begin ruOutpost := ruOutpost diff i ;
11796: LD_ADDR_EXP 14
11800: PUSH
11801: LD_EXP 14
11805: PUSH
11806: LD_VAR 0 2
11810: DIFF
11811: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ mc_rus_2 , mc_bases [ mc_rus_2 ] + 1 ] , i ) ;
11812: LD_ADDR_EXP 31
11816: PUSH
11817: LD_EXP 31
11821: PPUSH
11822: LD_EXP 8
11826: PUSH
11827: LD_EXP 31
11831: PUSH
11832: LD_EXP 8
11836: ARRAY
11837: PUSH
11838: LD_INT 1
11840: PLUS
11841: PUSH
11842: EMPTY
11843: LIST
11844: LIST
11845: PPUSH
11846: LD_VAR 0 2
11850: PPUSH
11851: CALL 25021 0 3
11855: ST_TO_ADDR
// end ;
11856: GO 11793
11858: POP
11859: POP
// until not UnitFilter ( ruOutpost , [ f_type , unit_human ] ) ;
11860: LD_EXP 14
11864: PPUSH
11865: LD_INT 21
11867: PUSH
11868: LD_INT 1
11870: PUSH
11871: EMPTY
11872: LIST
11873: LIST
11874: PPUSH
11875: CALL_OW 72
11879: NOT
11880: IFFALSE 11745
// ruOutpost := [ ] ;
11882: LD_ADDR_EXP 14
11886: PUSH
11887: EMPTY
11888: ST_TO_ADDR
// end ;
11889: LD_VAR 0 1
11893: RET
// every 0 0$1 trigger outpostEscape do var i , tmp ;
11894: LD_EXP 27
11898: IFFALSE 12087
11900: GO 11902
11902: DISABLE
11903: LD_INT 0
11905: PPUSH
11906: PPUSH
// begin wait ( rand ( 0 0$25 , 0 0$35 ) ) ;
11907: LD_INT 875
11909: PPUSH
11910: LD_INT 1225
11912: PPUSH
11913: CALL_OW 12
11917: PPUSH
11918: CALL_OW 67
// tmp := [ [ 208 , 166 ] , [ 218 , 174 ] , [ 201 , 173 ] , [ 189 , 167 ] , [ 191 , 160 ] , [ 209 , 181 ] , [ 192 , 162 ] , [ 197 , 166 ] ] ;
11922: LD_ADDR_VAR 0 2
11926: PUSH
11927: LD_INT 208
11929: PUSH
11930: LD_INT 166
11932: PUSH
11933: EMPTY
11934: LIST
11935: LIST
11936: PUSH
11937: LD_INT 218
11939: PUSH
11940: LD_INT 174
11942: PUSH
11943: EMPTY
11944: LIST
11945: LIST
11946: PUSH
11947: LD_INT 201
11949: PUSH
11950: LD_INT 173
11952: PUSH
11953: EMPTY
11954: LIST
11955: LIST
11956: PUSH
11957: LD_INT 189
11959: PUSH
11960: LD_INT 167
11962: PUSH
11963: EMPTY
11964: LIST
11965: LIST
11966: PUSH
11967: LD_INT 191
11969: PUSH
11970: LD_INT 160
11972: PUSH
11973: EMPTY
11974: LIST
11975: LIST
11976: PUSH
11977: LD_INT 209
11979: PUSH
11980: LD_INT 181
11982: PUSH
11983: EMPTY
11984: LIST
11985: LIST
11986: PUSH
11987: LD_INT 192
11989: PUSH
11990: LD_INT 162
11992: PUSH
11993: EMPTY
11994: LIST
11995: LIST
11996: PUSH
11997: LD_INT 197
11999: PUSH
12000: LD_INT 166
12002: PUSH
12003: EMPTY
12004: LIST
12005: LIST
12006: PUSH
12007: EMPTY
12008: LIST
12009: LIST
12010: LIST
12011: LIST
12012: LIST
12013: LIST
12014: LIST
12015: LIST
12016: ST_TO_ADDR
// for i = 1 to 5 + Difficulty do
12017: LD_ADDR_VAR 0 1
12021: PUSH
12022: DOUBLE
12023: LD_INT 1
12025: DEC
12026: ST_TO_ADDR
12027: LD_INT 5
12029: PUSH
12030: LD_OWVAR 67
12034: PLUS
12035: PUSH
12036: FOR_TO
12037: IFFALSE 12085
// begin MineExplosion ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] , 1 ) ;
12039: LD_VAR 0 2
12043: PUSH
12044: LD_VAR 0 1
12048: ARRAY
12049: PUSH
12050: LD_INT 1
12052: ARRAY
12053: PPUSH
12054: LD_VAR 0 2
12058: PUSH
12059: LD_VAR 0 1
12063: ARRAY
12064: PUSH
12065: LD_INT 2
12067: ARRAY
12068: PPUSH
12069: LD_INT 1
12071: PPUSH
12072: CALL_OW 453
// wait ( 0 0$0.8 ) ;
12076: LD_INT 28
12078: PPUSH
12079: CALL_OW 67
// end ;
12083: GO 12036
12085: POP
12086: POP
// end ;
12087: PPOPN 2
12089: END
// every 0 0$3 trigger not outpostEscape do var tmp , engs , buildings , empty , i , j , k ;
12090: LD_EXP 27
12094: NOT
12095: IFFALSE 12749
12097: GO 12099
12099: DISABLE
12100: LD_INT 0
12102: PPUSH
12103: PPUSH
12104: PPUSH
12105: PPUSH
12106: PPUSH
12107: PPUSH
12108: PPUSH
// begin enable ;
12109: ENABLE
// tmp := UnitFilter ( ruOutpost , [ [ f_side , 3 ] , [ f_class , 1 ] ] ) ;
12110: LD_ADDR_VAR 0 1
12114: PUSH
12115: LD_EXP 14
12119: PPUSH
12120: LD_INT 22
12122: PUSH
12123: LD_INT 3
12125: PUSH
12126: EMPTY
12127: LIST
12128: LIST
12129: PUSH
12130: LD_INT 25
12132: PUSH
12133: LD_INT 1
12135: PUSH
12136: EMPTY
12137: LIST
12138: LIST
12139: PUSH
12140: EMPTY
12141: LIST
12142: LIST
12143: PPUSH
12144: CALL_OW 72
12148: ST_TO_ADDR
// engs := UnitFilter ( ruOutpost , [ [ f_side , 3 ] , [ f_class , 2 ] ] ) ;
12149: LD_ADDR_VAR 0 2
12153: PUSH
12154: LD_EXP 14
12158: PPUSH
12159: LD_INT 22
12161: PUSH
12162: LD_INT 3
12164: PUSH
12165: EMPTY
12166: LIST
12167: LIST
12168: PUSH
12169: LD_INT 25
12171: PUSH
12172: LD_INT 2
12174: PUSH
12175: EMPTY
12176: LIST
12177: LIST
12178: PUSH
12179: EMPTY
12180: LIST
12181: LIST
12182: PPUSH
12183: CALL_OW 72
12187: ST_TO_ADDR
// buildings := UnitFilter ( ruOutpost , [ [ f_side , 3 ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
12188: LD_ADDR_VAR 0 3
12192: PUSH
12193: LD_EXP 14
12197: PPUSH
12198: LD_INT 22
12200: PUSH
12201: LD_INT 3
12203: PUSH
12204: EMPTY
12205: LIST
12206: LIST
12207: PUSH
12208: LD_INT 21
12210: PUSH
12211: LD_INT 3
12213: PUSH
12214: EMPTY
12215: LIST
12216: LIST
12217: PUSH
12218: LD_INT 3
12220: PUSH
12221: LD_INT 24
12223: PUSH
12224: LD_INT 1000
12226: PUSH
12227: EMPTY
12228: LIST
12229: LIST
12230: PUSH
12231: EMPTY
12232: LIST
12233: LIST
12234: PUSH
12235: EMPTY
12236: LIST
12237: LIST
12238: LIST
12239: PPUSH
12240: CALL_OW 72
12244: ST_TO_ADDR
// if engs and buildings then
12245: LD_VAR 0 2
12249: PUSH
12250: LD_VAR 0 3
12254: AND
12255: IFFALSE 12328
// begin for i in engs do
12257: LD_ADDR_VAR 0 5
12261: PUSH
12262: LD_VAR 0 2
12266: PUSH
12267: FOR_IN
12268: IFFALSE 12324
// if IsInUnit ( i ) then
12270: LD_VAR 0 5
12274: PPUSH
12275: CALL_OW 310
12279: IFFALSE 12292
// ComExitBuilding ( i ) else
12281: LD_VAR 0 5
12285: PPUSH
12286: CALL_OW 122
12290: GO 12322
// if not HasTask ( i ) then
12292: LD_VAR 0 5
12296: PPUSH
12297: CALL_OW 314
12301: NOT
12302: IFFALSE 12322
// ComRepairBuilding ( i , buildings [ 1 ] ) ;
12304: LD_VAR 0 5
12308: PPUSH
12309: LD_VAR 0 3
12313: PUSH
12314: LD_INT 1
12316: ARRAY
12317: PPUSH
12318: CALL_OW 130
12322: GO 12267
12324: POP
12325: POP
// end else
12326: GO 12431
// if not buildings and UnitFilter ( ruOutpost , [ f_btype , b_depot ] ) and UnitFilter ( engs , [ f_not , [ f_inside ] ] ) then
12328: LD_VAR 0 3
12332: NOT
12333: PUSH
12334: LD_EXP 14
12338: PPUSH
12339: LD_INT 30
12341: PUSH
12342: LD_INT 0
12344: PUSH
12345: EMPTY
12346: LIST
12347: LIST
12348: PPUSH
12349: CALL_OW 72
12353: AND
12354: PUSH
12355: LD_VAR 0 2
12359: PPUSH
12360: LD_INT 3
12362: PUSH
12363: LD_INT 54
12365: PUSH
12366: EMPTY
12367: LIST
12368: PUSH
12369: EMPTY
12370: LIST
12371: LIST
12372: PPUSH
12373: CALL_OW 72
12377: AND
12378: IFFALSE 12431
// ComEnterUnit ( UnitFilter ( engs , [ f_not , [ f_inside ] ] ) , UnitFilter ( ruOutpost , [ f_btype , b_depot ] ) [ 1 ] ) ;
12380: LD_VAR 0 2
12384: PPUSH
12385: LD_INT 3
12387: PUSH
12388: LD_INT 54
12390: PUSH
12391: EMPTY
12392: LIST
12393: PUSH
12394: EMPTY
12395: LIST
12396: LIST
12397: PPUSH
12398: CALL_OW 72
12402: PPUSH
12403: LD_EXP 14
12407: PPUSH
12408: LD_INT 30
12410: PUSH
12411: LD_INT 0
12413: PUSH
12414: EMPTY
12415: LIST
12416: LIST
12417: PPUSH
12418: CALL_OW 72
12422: PUSH
12423: LD_INT 1
12425: ARRAY
12426: PPUSH
12427: CALL_OW 120
// if not tmp then
12431: LD_VAR 0 1
12435: NOT
12436: IFFALSE 12440
// exit ;
12438: GO 12749
// if FilterUnitsInArea ( ruOutpostCenterArea , [ f_enemy , 3 ] ) > 1 then
12440: LD_INT 26
12442: PPUSH
12443: LD_INT 81
12445: PUSH
12446: LD_INT 3
12448: PUSH
12449: EMPTY
12450: LIST
12451: LIST
12452: PPUSH
12453: CALL_OW 70
12457: PUSH
12458: LD_INT 1
12460: GREATER
12461: IFFALSE 12517
// begin for i in tmp do
12463: LD_ADDR_VAR 0 5
12467: PUSH
12468: LD_VAR 0 1
12472: PUSH
12473: FOR_IN
12474: IFFALSE 12513
// begin if IsInUnit ( i ) then
12476: LD_VAR 0 5
12480: PPUSH
12481: CALL_OW 310
12485: IFFALSE 12496
// ComExitBuilding ( i ) ;
12487: LD_VAR 0 5
12491: PPUSH
12492: CALL_OW 122
// AddComAgressiveMove ( i , 204 , 164 ) ;
12496: LD_VAR 0 5
12500: PPUSH
12501: LD_INT 204
12503: PPUSH
12504: LD_INT 164
12506: PPUSH
12507: CALL_OW 174
// end ;
12511: GO 12473
12513: POP
12514: POP
// end else
12515: GO 12749
// if UnitFilter ( tmp , [ f_not , [ f_inside ] ] ) then
12517: LD_VAR 0 1
12521: PPUSH
12522: LD_INT 3
12524: PUSH
12525: LD_INT 54
12527: PUSH
12528: EMPTY
12529: LIST
12530: PUSH
12531: EMPTY
12532: LIST
12533: LIST
12534: PPUSH
12535: CALL_OW 72
12539: IFFALSE 12749
// begin empty := UnitFilter ( ruOutpost , [ [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
12541: LD_ADDR_VAR 0 4
12545: PUSH
12546: LD_EXP 14
12550: PPUSH
12551: LD_INT 30
12553: PUSH
12554: LD_INT 32
12556: PUSH
12557: EMPTY
12558: LIST
12559: LIST
12560: PUSH
12561: LD_INT 58
12563: PUSH
12564: EMPTY
12565: LIST
12566: PUSH
12567: EMPTY
12568: LIST
12569: LIST
12570: PPUSH
12571: CALL_OW 72
12575: ST_TO_ADDR
// if not empty and UnitFilter ( ruOutpost , [ f_btype , b_barracks ] ) then
12576: LD_VAR 0 4
12580: NOT
12581: PUSH
12582: LD_EXP 14
12586: PPUSH
12587: LD_INT 30
12589: PUSH
12590: LD_INT 5
12592: PUSH
12593: EMPTY
12594: LIST
12595: LIST
12596: PPUSH
12597: CALL_OW 72
12601: AND
12602: IFFALSE 12639
// begin ComEnterUnit ( tmp , UnitFilter ( ruOutpost , [ f_btype , b_barracks ] ) [ 1 ] ) ;
12604: LD_VAR 0 1
12608: PPUSH
12609: LD_EXP 14
12613: PPUSH
12614: LD_INT 30
12616: PUSH
12617: LD_INT 5
12619: PUSH
12620: EMPTY
12621: LIST
12622: LIST
12623: PPUSH
12624: CALL_OW 72
12628: PUSH
12629: LD_INT 1
12631: ARRAY
12632: PPUSH
12633: CALL_OW 120
// exit ;
12637: GO 12749
// end ; j := UnitFilter ( tmp , [ f_not , [ f_inside ] ] ) ;
12639: LD_ADDR_VAR 0 6
12643: PUSH
12644: LD_VAR 0 1
12648: PPUSH
12649: LD_INT 3
12651: PUSH
12652: LD_INT 54
12654: PUSH
12655: EMPTY
12656: LIST
12657: PUSH
12658: EMPTY
12659: LIST
12660: LIST
12661: PPUSH
12662: CALL_OW 72
12666: ST_TO_ADDR
// if j < empty then
12667: LD_VAR 0 6
12671: PUSH
12672: LD_VAR 0 4
12676: LESS
12677: IFFALSE 12691
// k := j else
12679: LD_ADDR_VAR 0 7
12683: PUSH
12684: LD_VAR 0 6
12688: ST_TO_ADDR
12689: GO 12701
// k := empty ;
12691: LD_ADDR_VAR 0 7
12695: PUSH
12696: LD_VAR 0 4
12700: ST_TO_ADDR
// for i = 1 to k do
12701: LD_ADDR_VAR 0 5
12705: PUSH
12706: DOUBLE
12707: LD_INT 1
12709: DEC
12710: ST_TO_ADDR
12711: LD_VAR 0 7
12715: PUSH
12716: FOR_TO
12717: IFFALSE 12747
// ComEnterUnit ( j [ i ] , empty [ i ] ) ;
12719: LD_VAR 0 6
12723: PUSH
12724: LD_VAR 0 5
12728: ARRAY
12729: PPUSH
12730: LD_VAR 0 4
12734: PUSH
12735: LD_VAR 0 5
12739: ARRAY
12740: PPUSH
12741: CALL_OW 120
12745: GO 12716
12747: POP
12748: POP
// end ; end ;
12749: PPOPN 7
12751: END
// every 0 0$2 trigger GameType = 1 and outpostEscape and FilterAllUnits ( [ [ f_side , 1 ] , [ f_distxy , 208 , 163 , 8 ] ] ) and not FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_distxy , 208 , 163 , 14 ] ] ) do var i ;
12752: LD_EXP 2
12756: PUSH
12757: LD_INT 1
12759: EQUAL
12760: PUSH
12761: LD_EXP 27
12765: AND
12766: PUSH
12767: LD_INT 22
12769: PUSH
12770: LD_INT 1
12772: PUSH
12773: EMPTY
12774: LIST
12775: LIST
12776: PUSH
12777: LD_INT 92
12779: PUSH
12780: LD_INT 208
12782: PUSH
12783: LD_INT 163
12785: PUSH
12786: LD_INT 8
12788: PUSH
12789: EMPTY
12790: LIST
12791: LIST
12792: LIST
12793: LIST
12794: PUSH
12795: EMPTY
12796: LIST
12797: LIST
12798: PPUSH
12799: CALL_OW 69
12803: AND
12804: PUSH
12805: LD_INT 22
12807: PUSH
12808: LD_INT 3
12810: PUSH
12811: EMPTY
12812: LIST
12813: LIST
12814: PUSH
12815: LD_INT 21
12817: PUSH
12818: LD_INT 1
12820: PUSH
12821: EMPTY
12822: LIST
12823: LIST
12824: PUSH
12825: LD_INT 92
12827: PUSH
12828: LD_INT 208
12830: PUSH
12831: LD_INT 163
12833: PUSH
12834: LD_INT 14
12836: PUSH
12837: EMPTY
12838: LIST
12839: LIST
12840: LIST
12841: LIST
12842: PUSH
12843: EMPTY
12844: LIST
12845: LIST
12846: LIST
12847: PPUSH
12848: CALL_OW 69
12852: NOT
12853: AND
12854: IFFALSE 13159
12856: GO 12858
12858: DISABLE
12859: LD_INT 0
12861: PPUSH
// begin InGameOn ;
12862: CALL_OW 8
// CenterNowOnUnits ( playerCommander ) ;
12866: LD_EXP 9
12870: PPUSH
12871: CALL_OW 87
// wait ( 0 0$1 ) ;
12875: LD_INT 35
12877: PPUSH
12878: CALL_OW 67
// DialogueOn ;
12882: CALL_OW 6
// Say ( playerCommander , D & [ I , J , S ] [ commander ] & -1-BaseCaptured ) ;
12886: LD_EXP 9
12890: PPUSH
12891: LD_STRING D
12893: PUSH
12894: LD_STRING I
12896: PUSH
12897: LD_STRING J
12899: PUSH
12900: LD_STRING S
12902: PUSH
12903: EMPTY
12904: LIST
12905: LIST
12906: LIST
12907: PUSH
12908: LD_EXP 25
12912: ARRAY
12913: STR
12914: PUSH
12915: LD_STRING -1-BaseCaptured
12917: STR
12918: PPUSH
12919: CALL_OW 88
// SayRadio ( Powell , DP-1-BaseCaptured ) ;
12923: LD_EXP 12
12927: PPUSH
12928: LD_STRING DP-1-BaseCaptured
12930: PPUSH
12931: CALL_OW 94
// if sibBombAllowed then
12935: LD_EXP 23
12939: IFFALSE 13081
// begin Say ( playerCommander , D & [ I , J , S ] [ commander ] & -2-BaseCaptured ) ;
12941: LD_EXP 9
12945: PPUSH
12946: LD_STRING D
12948: PUSH
12949: LD_STRING I
12951: PUSH
12952: LD_STRING J
12954: PUSH
12955: LD_STRING S
12957: PUSH
12958: EMPTY
12959: LIST
12960: LIST
12961: LIST
12962: PUSH
12963: LD_EXP 25
12967: ARRAY
12968: STR
12969: PUSH
12970: LD_STRING -2-BaseCaptured
12972: STR
12973: PPUSH
12974: CALL_OW 88
// if commander = 1 then
12978: LD_EXP 25
12982: PUSH
12983: LD_INT 1
12985: EQUAL
12986: IFFALSE 13000
// SayRadio ( Powell , DP-2b-BaseCaptured ) ;
12988: LD_EXP 12
12992: PPUSH
12993: LD_STRING DP-2b-BaseCaptured
12995: PPUSH
12996: CALL_OW 94
// if commander = 2 then
13000: LD_EXP 25
13004: PUSH
13005: LD_INT 2
13007: EQUAL
13008: IFFALSE 13022
// SayRadio ( Powell , DP-2-BaseCaptured ) ;
13010: LD_EXP 12
13014: PPUSH
13015: LD_STRING DP-2-BaseCaptured
13017: PPUSH
13018: CALL_OW 94
// if commander = 3 then
13022: LD_EXP 25
13026: PUSH
13027: LD_INT 3
13029: EQUAL
13030: IFFALSE 13044
// SayRadio ( Powell , DP-2a-BaseCaptured ) ;
13032: LD_EXP 12
13036: PPUSH
13037: LD_STRING DP-2a-BaseCaptured
13039: PPUSH
13040: CALL_OW 94
// Say ( playerCommander , D & [ I , J , S ] [ commander ] & -3-BaseCaptured ) ;
13044: LD_EXP 9
13048: PPUSH
13049: LD_STRING D
13051: PUSH
13052: LD_STRING I
13054: PUSH
13055: LD_STRING J
13057: PUSH
13058: LD_STRING S
13060: PUSH
13061: EMPTY
13062: LIST
13063: LIST
13064: LIST
13065: PUSH
13066: LD_EXP 25
13070: ARRAY
13071: STR
13072: PUSH
13073: LD_STRING -3-BaseCaptured
13075: STR
13076: PPUSH
13077: CALL_OW 88
// end ; DialogueOff ;
13081: CALL_OW 7
// InGameOff ;
13085: CALL_OW 9
// ChangeMissionObjectives ( O2 ) ;
13089: LD_STRING O2
13091: PPUSH
13092: CALL_OW 337
// for i in UnitFilter ( ruOutpost , [ f_type , unit_building ] ) do
13096: LD_ADDR_VAR 0 1
13100: PUSH
13101: LD_EXP 14
13105: PPUSH
13106: LD_INT 21
13108: PUSH
13109: LD_INT 3
13111: PUSH
13112: EMPTY
13113: LIST
13114: LIST
13115: PPUSH
13116: CALL_OW 72
13120: PUSH
13121: FOR_IN
13122: IFFALSE 13138
// SetSide ( i , 1 ) ;
13124: LD_VAR 0 1
13128: PPUSH
13129: LD_INT 1
13131: PPUSH
13132: CALL_OW 235
13136: GO 13121
13138: POP
13139: POP
// baseCaptured := true ;
13140: LD_ADDR_EXP 17
13144: PUSH
13145: LD_INT 1
13147: ST_TO_ADDR
// wait ( 0 0$35 ) ;
13148: LD_INT 1225
13150: PPUSH
13151: CALL_OW 67
// PrepareReinforcements ;
13155: CALL 9908 0 0
// end ;
13159: PPOPN 1
13161: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_distxy , 167 , 197 , 20 ] ] ) > 3 do
13162: LD_INT 22
13164: PUSH
13165: LD_INT 3
13167: PUSH
13168: EMPTY
13169: LIST
13170: LIST
13171: PUSH
13172: LD_INT 92
13174: PUSH
13175: LD_INT 167
13177: PUSH
13178: LD_INT 197
13180: PUSH
13181: LD_INT 20
13183: PUSH
13184: EMPTY
13185: LIST
13186: LIST
13187: LIST
13188: LIST
13189: PUSH
13190: EMPTY
13191: LIST
13192: LIST
13193: PPUSH
13194: CALL_OW 69
13198: PUSH
13199: LD_INT 3
13201: GREATER
13202: IFFALSE 13219
13204: GO 13206
13206: DISABLE
// SayRadio ( Powell , DP-RuAttack ) ;
13207: LD_EXP 12
13211: PPUSH
13212: LD_STRING DP-RuAttack
13214: PPUSH
13215: CALL_OW 94
13219: END
// every 0 0$2 trigger not debug and SeeXY ( 1 , 168 , 74 ) and GetEnvironmentType ( 168 , 72 ) do
13220: LD_EXP 1
13224: NOT
13225: PUSH
13226: LD_INT 1
13228: PPUSH
13229: LD_INT 168
13231: PPUSH
13232: LD_INT 74
13234: PPUSH
13235: CALL_OW 293
13239: AND
13240: PUSH
13241: LD_INT 168
13243: PPUSH
13244: LD_INT 72
13246: PPUSH
13247: CALL_OW 553
13251: AND
13252: IFFALSE 13304
13254: GO 13256
13256: DISABLE
// begin CenterOnXY ( 168 , 72 ) ;
13257: LD_INT 168
13259: PPUSH
13260: LD_INT 72
13262: PPUSH
13263: CALL_OW 84
// Say ( playerCommander , D & [ I , J , S ] [ commander ] & -1-Blockade ) ;
13267: LD_EXP 9
13271: PPUSH
13272: LD_STRING D
13274: PUSH
13275: LD_STRING I
13277: PUSH
13278: LD_STRING J
13280: PUSH
13281: LD_STRING S
13283: PUSH
13284: EMPTY
13285: LIST
13286: LIST
13287: LIST
13288: PUSH
13289: LD_EXP 25
13293: ARRAY
13294: STR
13295: PUSH
13296: LD_STRING -1-Blockade
13298: STR
13299: PPUSH
13300: CALL_OW 88
// end ;
13304: END
// every 0 0$2 trigger GameType = 1 and FilterAllUnits ( [ [ f_side , 1 ] , [ f_see , 4 ] ] ) do
13305: LD_EXP 2
13309: PUSH
13310: LD_INT 1
13312: EQUAL
13313: PUSH
13314: LD_INT 22
13316: PUSH
13317: LD_INT 1
13319: PUSH
13320: EMPTY
13321: LIST
13322: LIST
13323: PUSH
13324: LD_INT 101
13326: PUSH
13327: LD_INT 4
13329: PUSH
13330: EMPTY
13331: LIST
13332: LIST
13333: PUSH
13334: EMPTY
13335: LIST
13336: LIST
13337: PPUSH
13338: CALL_OW 69
13342: AND
13343: IFFALSE 13875
13345: GO 13347
13347: DISABLE
// begin ChangeSideFog ( 4 , 1 ) ;
13348: LD_INT 4
13350: PPUSH
13351: LD_INT 1
13353: PPUSH
13354: CALL_OW 343
// DialogueOn ;
13358: CALL_OW 6
// CenterNowOnUnits ( allyCommander ) ;
13362: LD_EXP 11
13366: PPUSH
13367: CALL_OW 87
// SayRadio ( allyCommander , DM-1-Contact ) ;
13371: LD_EXP 11
13375: PPUSH
13376: LD_STRING DM-1-Contact
13378: PPUSH
13379: CALL_OW 94
// Say ( playerCommander , D & [ I , J , S ] [ commander ] & -1-Contact ) ;
13383: LD_EXP 9
13387: PPUSH
13388: LD_STRING D
13390: PUSH
13391: LD_STRING I
13393: PUSH
13394: LD_STRING J
13396: PUSH
13397: LD_STRING S
13399: PUSH
13400: EMPTY
13401: LIST
13402: LIST
13403: LIST
13404: PUSH
13405: LD_EXP 25
13409: ARRAY
13410: STR
13411: PUSH
13412: LD_STRING -1-Contact
13414: STR
13415: PPUSH
13416: CALL_OW 88
// if commander = 1 then
13420: LD_EXP 25
13424: PUSH
13425: LD_INT 1
13427: EQUAL
13428: IFFALSE 13560
// begin SayRadio ( allyCommander , DM-2-Contact ) ;
13430: LD_EXP 11
13434: PPUSH
13435: LD_STRING DM-2-Contact
13437: PPUSH
13438: CALL_OW 94
// Say ( playerCommander , DI-2-Contact ) ;
13442: LD_EXP 9
13446: PPUSH
13447: LD_STRING DI-2-Contact
13449: PPUSH
13450: CALL_OW 88
// if FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) and GetAttitude ( 8 , 1 ) = att_enemy then
13454: LD_INT 22
13456: PUSH
13457: LD_INT 8
13459: PUSH
13460: EMPTY
13461: LIST
13462: LIST
13463: PUSH
13464: LD_INT 21
13466: PUSH
13467: LD_INT 1
13469: PUSH
13470: EMPTY
13471: LIST
13472: LIST
13473: PUSH
13474: EMPTY
13475: LIST
13476: LIST
13477: PPUSH
13478: CALL_OW 69
13482: PUSH
13483: LD_INT 8
13485: PPUSH
13486: LD_INT 1
13488: PPUSH
13489: CALL_OW 81
13493: PUSH
13494: LD_INT 2
13496: EQUAL
13497: AND
13498: IFFALSE 13524
// begin SayRadio ( allyCommander , DM-3-Contact ) ;
13500: LD_EXP 11
13504: PPUSH
13505: LD_STRING DM-3-Contact
13507: PPUSH
13508: CALL_OW 94
// Say ( playerCommander , DI-3-Contact ) ;
13512: LD_EXP 9
13516: PPUSH
13517: LD_STRING DI-3-Contact
13519: PPUSH
13520: CALL_OW 88
// end ; SayRadio ( allyCommander , DM-4-Contact ) ;
13524: LD_EXP 11
13528: PPUSH
13529: LD_STRING DM-4-Contact
13531: PPUSH
13532: CALL_OW 94
// Say ( playerCommander , DI-4-Contact ) ;
13536: LD_EXP 9
13540: PPUSH
13541: LD_STRING DI-4-Contact
13543: PPUSH
13544: CALL_OW 88
// SayRadio ( allyCommander , DM-5-Contact ) ;
13548: LD_EXP 11
13552: PPUSH
13553: LD_STRING DM-5-Contact
13555: PPUSH
13556: CALL_OW 94
// end ; if commander = 2 then
13560: LD_EXP 25
13564: PUSH
13565: LD_INT 2
13567: EQUAL
13568: IFFALSE 13700
// begin SayRadio ( allyCommander , DM-2c-Contact ) ;
13570: LD_EXP 11
13574: PPUSH
13575: LD_STRING DM-2c-Contact
13577: PPUSH
13578: CALL_OW 94
// Say ( playerCommander , DJ-2-Contact ) ;
13582: LD_EXP 9
13586: PPUSH
13587: LD_STRING DJ-2-Contact
13589: PPUSH
13590: CALL_OW 88
// if FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) and GetAttitude ( 8 , 1 ) = att_enemy then
13594: LD_INT 22
13596: PUSH
13597: LD_INT 8
13599: PUSH
13600: EMPTY
13601: LIST
13602: LIST
13603: PUSH
13604: LD_INT 21
13606: PUSH
13607: LD_INT 1
13609: PUSH
13610: EMPTY
13611: LIST
13612: LIST
13613: PUSH
13614: EMPTY
13615: LIST
13616: LIST
13617: PPUSH
13618: CALL_OW 69
13622: PUSH
13623: LD_INT 8
13625: PPUSH
13626: LD_INT 1
13628: PPUSH
13629: CALL_OW 81
13633: PUSH
13634: LD_INT 2
13636: EQUAL
13637: AND
13638: IFFALSE 13664
// begin SayRadio ( allyCommander , DM-3-Contact ) ;
13640: LD_EXP 11
13644: PPUSH
13645: LD_STRING DM-3-Contact
13647: PPUSH
13648: CALL_OW 94
// Say ( playerCommander , DJ-3-Contact ) ;
13652: LD_EXP 9
13656: PPUSH
13657: LD_STRING DJ-3-Contact
13659: PPUSH
13660: CALL_OW 88
// end ; SayRadio ( allyCommander , DM-4-Contact ) ;
13664: LD_EXP 11
13668: PPUSH
13669: LD_STRING DM-4-Contact
13671: PPUSH
13672: CALL_OW 94
// Say ( playerCommander , DJ-4-Contact ) ;
13676: LD_EXP 9
13680: PPUSH
13681: LD_STRING DJ-4-Contact
13683: PPUSH
13684: CALL_OW 88
// SayRadio ( allyCommander , DM-5a-Contact ) ;
13688: LD_EXP 11
13692: PPUSH
13693: LD_STRING DM-5a-Contact
13695: PPUSH
13696: CALL_OW 94
// end ; if commander = 3 then
13700: LD_EXP 25
13704: PUSH
13705: LD_INT 3
13707: EQUAL
13708: IFFALSE 13864
// begin SayRadio ( allyCommander , DM-2a-Contact ) ;
13710: LD_EXP 11
13714: PPUSH
13715: LD_STRING DM-2a-Contact
13717: PPUSH
13718: CALL_OW 94
// Say ( playerCommander , DS-2a-Contact ) ;
13722: LD_EXP 9
13726: PPUSH
13727: LD_STRING DS-2a-Contact
13729: PPUSH
13730: CALL_OW 88
// SayRadio ( allyCommander , DM-2b-Contact ) ;
13734: LD_EXP 11
13738: PPUSH
13739: LD_STRING DM-2b-Contact
13741: PPUSH
13742: CALL_OW 94
// Say ( playerCommander , DS-2b-Contact ) ;
13746: LD_EXP 9
13750: PPUSH
13751: LD_STRING DS-2b-Contact
13753: PPUSH
13754: CALL_OW 88
// if FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) and GetAttitude ( 8 , 1 ) = att_enemy then
13758: LD_INT 22
13760: PUSH
13761: LD_INT 8
13763: PUSH
13764: EMPTY
13765: LIST
13766: LIST
13767: PUSH
13768: LD_INT 21
13770: PUSH
13771: LD_INT 1
13773: PUSH
13774: EMPTY
13775: LIST
13776: LIST
13777: PUSH
13778: EMPTY
13779: LIST
13780: LIST
13781: PPUSH
13782: CALL_OW 69
13786: PUSH
13787: LD_INT 8
13789: PPUSH
13790: LD_INT 1
13792: PPUSH
13793: CALL_OW 81
13797: PUSH
13798: LD_INT 2
13800: EQUAL
13801: AND
13802: IFFALSE 13828
// begin SayRadio ( allyCommander , DM-3-Contact ) ;
13804: LD_EXP 11
13808: PPUSH
13809: LD_STRING DM-3-Contact
13811: PPUSH
13812: CALL_OW 94
// Say ( playerCommander , DS-3-Contact ) ;
13816: LD_EXP 9
13820: PPUSH
13821: LD_STRING DS-3-Contact
13823: PPUSH
13824: CALL_OW 88
// end ; SayRadio ( allyCommander , DM-4-Contact ) ;
13828: LD_EXP 11
13832: PPUSH
13833: LD_STRING DM-4-Contact
13835: PPUSH
13836: CALL_OW 94
// Say ( playerCommander , DS-4-Contact ) ;
13840: LD_EXP 9
13844: PPUSH
13845: LD_STRING DS-4-Contact
13847: PPUSH
13848: CALL_OW 88
// SayRadio ( allyCommander , DM-5-Contact ) ;
13852: LD_EXP 11
13856: PPUSH
13857: LD_STRING DM-5-Contact
13859: PPUSH
13860: CALL_OW 94
// end ; DialogueOff ;
13864: CALL_OW 7
// ChangeMissionObjectives ( O3 ) ;
13868: LD_STRING O3
13870: PPUSH
13871: CALL_OW 337
// end ;
13875: END
// every 0 0$10 trigger GameType = 1 and legDestCounter >= [ 15 , 20 , 25 ] [ Difficulty ] and FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_warehouse ] ] ) and FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] ] ) >= 5 do var time , sib , sources , i ;
13876: LD_EXP 2
13880: PUSH
13881: LD_INT 1
13883: EQUAL
13884: PUSH
13885: LD_EXP 18
13889: PUSH
13890: LD_INT 15
13892: PUSH
13893: LD_INT 20
13895: PUSH
13896: LD_INT 25
13898: PUSH
13899: EMPTY
13900: LIST
13901: LIST
13902: LIST
13903: PUSH
13904: LD_OWVAR 67
13908: ARRAY
13909: GREATEREQUAL
13910: AND
13911: PUSH
13912: LD_INT 22
13914: PUSH
13915: LD_INT 8
13917: PUSH
13918: EMPTY
13919: LIST
13920: LIST
13921: PUSH
13922: LD_INT 30
13924: PUSH
13925: LD_INT 1
13927: PUSH
13928: EMPTY
13929: LIST
13930: LIST
13931: PUSH
13932: EMPTY
13933: LIST
13934: LIST
13935: PPUSH
13936: CALL_OW 69
13940: AND
13941: PUSH
13942: LD_INT 22
13944: PUSH
13945: LD_INT 8
13947: PUSH
13948: EMPTY
13949: LIST
13950: LIST
13951: PUSH
13952: LD_INT 21
13954: PUSH
13955: LD_INT 3
13957: PUSH
13958: EMPTY
13959: LIST
13960: LIST
13961: PUSH
13962: EMPTY
13963: LIST
13964: LIST
13965: PPUSH
13966: CALL_OW 69
13970: PUSH
13971: LD_INT 5
13973: GREATEREQUAL
13974: AND
13975: IFFALSE 14498
13977: GO 13979
13979: DISABLE
13980: LD_INT 0
13982: PPUSH
13983: PPUSH
13984: PPUSH
13985: PPUSH
// begin DialogueOn ;
13986: CALL_OW 6
// SayRadio ( Farmer , DF-1-Leg ) ;
13990: LD_EXP 13
13994: PPUSH
13995: LD_STRING DF-1-Leg
13997: PPUSH
13998: CALL_OW 94
// Say ( playerCommander , D & [ I , J , S ] [ commander ] & -1-Leg ) ;
14002: LD_EXP 9
14006: PPUSH
14007: LD_STRING D
14009: PUSH
14010: LD_STRING I
14012: PUSH
14013: LD_STRING J
14015: PUSH
14016: LD_STRING S
14018: PUSH
14019: EMPTY
14020: LIST
14021: LIST
14022: LIST
14023: PUSH
14024: LD_EXP 25
14028: ARRAY
14029: STR
14030: PUSH
14031: LD_STRING -1-Leg
14033: STR
14034: PPUSH
14035: CALL_OW 88
// SayRadio ( Farmer , DF-2-Leg ) ;
14039: LD_EXP 13
14043: PPUSH
14044: LD_STRING DF-2-Leg
14046: PPUSH
14047: CALL_OW 94
// DialogueOff ;
14051: CALL_OW 7
// case Query ( QLegionOffer ) of 1 :
14055: LD_STRING QLegionOffer
14057: PPUSH
14058: CALL_OW 97
14062: PUSH
14063: LD_INT 1
14065: DOUBLE
14066: EQUAL
14067: IFTRUE 14071
14069: GO 14074
14071: POP
// ; 2 :
14072: GO 14088
14074: LD_INT 2
14076: DOUBLE
14077: EQUAL
14078: IFTRUE 14082
14080: GO 14087
14082: POP
// exit ; end ;
14083: GO 14498
14085: GO 14088
14087: POP
// Say ( playerCommander , D & [ I , J , S ] [ commander ] & -2-Leg ) ;
14088: LD_EXP 9
14092: PPUSH
14093: LD_STRING D
14095: PUSH
14096: LD_STRING I
14098: PUSH
14099: LD_STRING J
14101: PUSH
14102: LD_STRING S
14104: PUSH
14105: EMPTY
14106: LIST
14107: LIST
14108: LIST
14109: PUSH
14110: LD_EXP 25
14114: ARRAY
14115: STR
14116: PUSH
14117: LD_STRING -2-Leg
14119: STR
14120: PPUSH
14121: CALL_OW 88
// legOfferAccepted := true ;
14125: LD_ADDR_EXP 20
14129: PUSH
14130: LD_INT 1
14132: ST_TO_ADDR
// SetAreaMapShow ( legOfferArea , 1 ) ;
14133: LD_INT 21
14135: PPUSH
14136: LD_INT 1
14138: PPUSH
14139: CALL_OW 424
// CenterOnXY ( 190 , 227 ) ;
14143: LD_INT 190
14145: PPUSH
14146: LD_INT 227
14148: PPUSH
14149: CALL_OW 84
// time := [ 8 8$00 , 7 7$00 , 6 6$00 ] [ Difficulty ] ;
14153: LD_ADDR_VAR 0 1
14157: PUSH
14158: LD_INT 16800
14160: PUSH
14161: LD_INT 14700
14163: PUSH
14164: LD_INT 12600
14166: PUSH
14167: EMPTY
14168: LIST
14169: LIST
14170: LIST
14171: PUSH
14172: LD_OWVAR 67
14176: ARRAY
14177: ST_TO_ADDR
// sib := 100 ;
14178: LD_ADDR_VAR 0 2
14182: PUSH
14183: LD_INT 100
14185: ST_TO_ADDR
// disableGlobalTimer := true ;
14186: LD_ADDR_EXP 4
14190: PUSH
14191: LD_INT 1
14193: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
14194: LD_INT 35
14196: PPUSH
14197: CALL_OW 67
// time := time - 0 0$1 ;
14201: LD_ADDR_VAR 0 1
14205: PUSH
14206: LD_VAR 0 1
14210: PUSH
14211: LD_INT 35
14213: MINUS
14214: ST_TO_ADDR
// sources := GetResourceArea ( legOfferArea , mat_siberit ) ;
14215: LD_ADDR_VAR 0 3
14219: PUSH
14220: LD_INT 21
14222: PPUSH
14223: LD_INT 3
14225: PPUSH
14226: CALL_OW 287
14230: ST_TO_ADDR
// display_strings := [ #SkrTime , tick , #Skr-LegOffer , sib , time ] ;
14231: LD_ADDR_OWVAR 47
14235: PUSH
14236: LD_STRING #SkrTime
14238: PUSH
14239: LD_OWVAR 1
14243: PUSH
14244: LD_STRING #Skr-LegOffer
14246: PUSH
14247: LD_VAR 0 2
14251: PUSH
14252: LD_VAR 0 1
14256: PUSH
14257: EMPTY
14258: LIST
14259: LIST
14260: LIST
14261: LIST
14262: LIST
14263: ST_TO_ADDR
// if sources then
14264: LD_VAR 0 3
14268: IFFALSE 14300
// begin sib := sib - sources * 10 ;
14270: LD_ADDR_VAR 0 2
14274: PUSH
14275: LD_VAR 0 2
14279: PUSH
14280: LD_VAR 0 3
14284: PUSH
14285: LD_INT 10
14287: MUL
14288: MINUS
14289: ST_TO_ADDR
// EraseResourceArea ( legOfferArea , mat_siberit ) ;
14290: LD_INT 21
14292: PPUSH
14293: LD_INT 3
14295: PPUSH
14296: CALL_OW 286
// end ; until time = 0 0$00 or sib <= 0 or not FilterAllUnits ( [ f_side , 8 ] ) ;
14300: LD_VAR 0 1
14304: PUSH
14305: LD_INT 0
14307: EQUAL
14308: PUSH
14309: LD_VAR 0 2
14313: PUSH
14314: LD_INT 0
14316: LESSEQUAL
14317: OR
14318: PUSH
14319: LD_INT 22
14321: PUSH
14322: LD_INT 8
14324: PUSH
14325: EMPTY
14326: LIST
14327: LIST
14328: PPUSH
14329: CALL_OW 69
14333: NOT
14334: OR
14335: IFFALSE 14194
// SetAreaMapShow ( legOfferArea , 0 ) ;
14337: LD_INT 21
14339: PPUSH
14340: LD_INT 0
14342: PPUSH
14343: CALL_OW 424
// disableGlobalTimer := false ;
14347: LD_ADDR_EXP 4
14351: PUSH
14352: LD_INT 0
14354: ST_TO_ADDR
// if sib <= 0 then
14355: LD_VAR 0 2
14359: PUSH
14360: LD_INT 0
14362: LESSEQUAL
14363: IFFALSE 14479
// begin legChangeSide := true ;
14365: LD_ADDR_EXP 21
14369: PUSH
14370: LD_INT 1
14372: ST_TO_ADDR
// SayRadio ( Farmer , DF-4y-Leg ) ;
14373: LD_EXP 13
14377: PPUSH
14378: LD_STRING DF-4y-Leg
14380: PPUSH
14381: CALL_OW 94
// ChangeMissionObjectives ( O3a ) ;
14385: LD_STRING O3a
14387: PPUSH
14388: CALL_OW 337
// ChangeSideFog ( 8 , 1 ) ;
14392: LD_INT 8
14394: PPUSH
14395: LD_INT 1
14397: PPUSH
14398: CALL_OW 343
// SetAttitude ( 8 , 1 , att_friend , true ) ;
14402: LD_INT 8
14404: PPUSH
14405: LD_INT 1
14407: PPUSH
14408: LD_INT 1
14410: PPUSH
14411: LD_INT 1
14413: PPUSH
14414: CALL_OW 80
// SetAttitude ( 8 , 4 , att_friend , true ) ;
14418: LD_INT 8
14420: PPUSH
14421: LD_INT 4
14423: PPUSH
14424: LD_INT 1
14426: PPUSH
14427: LD_INT 1
14429: PPUSH
14430: CALL_OW 80
// SetAttitude ( 8 , 6 , att_enemy , true ) ;
14434: LD_INT 8
14436: PPUSH
14437: LD_INT 6
14439: PPUSH
14440: LD_INT 2
14442: PPUSH
14443: LD_INT 1
14445: PPUSH
14446: CALL_OW 80
// SetAttitude ( 8 , 3 , att_enemy , true ) ;
14450: LD_INT 8
14452: PPUSH
14453: LD_INT 3
14455: PPUSH
14456: LD_INT 2
14458: PPUSH
14459: LD_INT 1
14461: PPUSH
14462: CALL_OW 80
// wait ( 0 0$30 ) ;
14466: LD_INT 1050
14468: PPUSH
14469: CALL_OW 67
// PrepareLegionReinforcements ;
14473: CALL 10608 0 0
// end else
14477: GO 14498
// begin ChangeMissionObjectives ( O3a ) ;
14479: LD_STRING O3a
14481: PPUSH
14482: CALL_OW 337
// SayRadio ( Farmer , DF-4n-Leg ) ;
14486: LD_EXP 13
14490: PPUSH
14491: LD_STRING DF-4n-Leg
14493: PPUSH
14494: CALL_OW 94
// end ; end ;
14498: PPOPN 4
14500: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) = 0 and GetAttitude ( 8 , 1 ) = att_enemy do
14501: LD_INT 22
14503: PUSH
14504: LD_INT 8
14506: PUSH
14507: EMPTY
14508: LIST
14509: LIST
14510: PUSH
14511: LD_INT 21
14513: PUSH
14514: LD_INT 1
14516: PUSH
14517: EMPTY
14518: LIST
14519: LIST
14520: PUSH
14521: EMPTY
14522: LIST
14523: LIST
14524: PPUSH
14525: CALL_OW 69
14529: PUSH
14530: LD_INT 0
14532: EQUAL
14533: PUSH
14534: LD_INT 8
14536: PPUSH
14537: LD_INT 1
14539: PPUSH
14540: CALL_OW 81
14544: PUSH
14545: LD_INT 2
14547: EQUAL
14548: AND
14549: IFFALSE 14561
14551: GO 14553
14553: DISABLE
// ChangeMissionObjectives ( O3a ) ;
14554: LD_STRING O3a
14556: PPUSH
14557: CALL_OW 337
14561: END
// every 0 0$1 trigger GameType = 1 and game and FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_warehouse ] ] ) = 0 do
14562: LD_EXP 2
14566: PUSH
14567: LD_INT 1
14569: EQUAL
14570: PUSH
14571: LD_EXP 3
14575: AND
14576: PUSH
14577: LD_INT 22
14579: PUSH
14580: LD_INT 3
14582: PUSH
14583: EMPTY
14584: LIST
14585: LIST
14586: PUSH
14587: LD_INT 21
14589: PUSH
14590: LD_INT 1
14592: PUSH
14593: EMPTY
14594: LIST
14595: LIST
14596: PUSH
14597: EMPTY
14598: LIST
14599: LIST
14600: PPUSH
14601: CALL_OW 69
14605: PUSH
14606: LD_INT 0
14608: EQUAL
14609: AND
14610: PUSH
14611: LD_INT 22
14613: PUSH
14614: LD_INT 3
14616: PUSH
14617: EMPTY
14618: LIST
14619: LIST
14620: PUSH
14621: LD_INT 30
14623: PUSH
14624: LD_INT 1
14626: PUSH
14627: EMPTY
14628: LIST
14629: LIST
14630: PUSH
14631: EMPTY
14632: LIST
14633: LIST
14634: PPUSH
14635: CALL_OW 69
14639: PUSH
14640: LD_INT 0
14642: EQUAL
14643: AND
14644: IFFALSE 14882
14646: GO 14648
14648: DISABLE
// begin Say ( playerCommander , D & [ I , J , S ] [ commander ] & -1-Win ) ;
14649: LD_EXP 9
14653: PPUSH
14654: LD_STRING D
14656: PUSH
14657: LD_STRING I
14659: PUSH
14660: LD_STRING J
14662: PUSH
14663: LD_STRING S
14665: PUSH
14666: EMPTY
14667: LIST
14668: LIST
14669: LIST
14670: PUSH
14671: LD_EXP 25
14675: ARRAY
14676: STR
14677: PUSH
14678: LD_STRING -1-Win
14680: STR
14681: PPUSH
14682: CALL_OW 88
// if tick >= [ 150 150$0 , 130 130$0 , 110 110$0 ] [ Difficulty ] then
14686: LD_OWVAR 1
14690: PUSH
14691: LD_INT 315000
14693: PUSH
14694: LD_INT 273000
14696: PUSH
14697: LD_INT 231000
14699: PUSH
14700: EMPTY
14701: LIST
14702: LIST
14703: LIST
14704: PUSH
14705: LD_OWVAR 67
14709: ARRAY
14710: GREATEREQUAL
14711: IFFALSE 14726
// AddMedal ( med1 , - 1 ) else
14713: LD_STRING med1
14715: PPUSH
14716: LD_INT 1
14718: NEG
14719: PPUSH
14720: CALL_OW 101
14724: GO 14736
// AddMedal ( med1 , 1 ) ;
14726: LD_STRING med1
14728: PPUSH
14729: LD_INT 1
14731: PPUSH
14732: CALL_OW 101
// if allyDestCounter >= [ 20 , 15 , 10 ] [ Difficulty ] then
14736: LD_EXP 22
14740: PUSH
14741: LD_INT 20
14743: PUSH
14744: LD_INT 15
14746: PUSH
14747: LD_INT 10
14749: PUSH
14750: EMPTY
14751: LIST
14752: LIST
14753: LIST
14754: PUSH
14755: LD_OWVAR 67
14759: ARRAY
14760: GREATEREQUAL
14761: IFFALSE 14776
// AddMedal ( med2 , - 1 ) else
14763: LD_STRING med2
14765: PPUSH
14766: LD_INT 1
14768: NEG
14769: PPUSH
14770: CALL_OW 101
14774: GO 14786
// AddMedal ( med2 , 1 ) ;
14776: LD_STRING med2
14778: PPUSH
14779: LD_INT 1
14781: PPUSH
14782: CALL_OW 101
// if GetAttitude ( 8 , 1 ) = att_friend then
14786: LD_INT 8
14788: PPUSH
14789: LD_INT 1
14791: PPUSH
14792: CALL_OW 81
14796: PUSH
14797: LD_INT 1
14799: EQUAL
14800: IFFALSE 14814
// AddMedal ( med3 , 1 ) else
14802: LD_STRING med3
14804: PPUSH
14805: LD_INT 1
14807: PPUSH
14808: CALL_OW 101
14812: GO 14871
// if FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) = 0 then
14814: LD_INT 22
14816: PUSH
14817: LD_INT 8
14819: PUSH
14820: EMPTY
14821: LIST
14822: LIST
14823: PUSH
14824: LD_INT 21
14826: PUSH
14827: LD_INT 1
14829: PUSH
14830: EMPTY
14831: LIST
14832: LIST
14833: PUSH
14834: EMPTY
14835: LIST
14836: LIST
14837: PPUSH
14838: CALL_OW 69
14842: PUSH
14843: LD_INT 0
14845: EQUAL
14846: IFFALSE 14860
// AddMedal ( med3 , 2 ) else
14848: LD_STRING med3
14850: PPUSH
14851: LD_INT 2
14853: PPUSH
14854: CALL_OW 101
14858: GO 14871
// AddMedal ( med3 , - 1 ) ;
14860: LD_STRING med3
14862: PPUSH
14863: LD_INT 1
14865: NEG
14866: PPUSH
14867: CALL_OW 101
// GiveMedals ( MAIN ) ;
14871: LD_STRING MAIN
14873: PPUSH
14874: CALL_OW 102
// YouWin ;
14878: CALL_OW 103
// end ;
14882: END
// every 10 trigger GameType = 1 and staticMines and FilterUnitsInArea ( minesArea , [ f_enemy , 8 ] ) do var i , j , tmp , x , y ;
14883: LD_EXP 2
14887: PUSH
14888: LD_INT 1
14890: EQUAL
14891: PUSH
14892: LD_EXP 16
14896: AND
14897: PUSH
14898: LD_INT 20
14900: PPUSH
14901: LD_INT 81
14903: PUSH
14904: LD_INT 8
14906: PUSH
14907: EMPTY
14908: LIST
14909: LIST
14910: PPUSH
14911: CALL_OW 70
14915: AND
14916: IFFALSE 15195
14918: GO 14920
14920: DISABLE
14921: LD_INT 0
14923: PPUSH
14924: PPUSH
14925: PPUSH
14926: PPUSH
14927: PPUSH
// begin enable ;
14928: ENABLE
// tmp := FilterUnitsInArea ( minesArea , [ f_enemy , 8 ] ) ;
14929: LD_ADDR_VAR 0 3
14933: PUSH
14934: LD_INT 20
14936: PPUSH
14937: LD_INT 81
14939: PUSH
14940: LD_INT 8
14942: PUSH
14943: EMPTY
14944: LIST
14945: LIST
14946: PPUSH
14947: CALL_OW 70
14951: ST_TO_ADDR
// if not tmp then
14952: LD_VAR 0 3
14956: NOT
14957: IFFALSE 14961
// exit ;
14959: GO 15195
// for i in tmp do
14961: LD_ADDR_VAR 0 1
14965: PUSH
14966: LD_VAR 0 3
14970: PUSH
14971: FOR_IN
14972: IFFALSE 15193
// begin x := GetX ( i ) ;
14974: LD_ADDR_VAR 0 4
14978: PUSH
14979: LD_VAR 0 1
14983: PPUSH
14984: CALL_OW 250
14988: ST_TO_ADDR
// y := GetY ( i ) ;
14989: LD_ADDR_VAR 0 5
14993: PUSH
14994: LD_VAR 0 1
14998: PPUSH
14999: CALL_OW 251
15003: ST_TO_ADDR
// if MineAtPos ( x , y ) then
15004: LD_VAR 0 4
15008: PPUSH
15009: LD_VAR 0 5
15013: PPUSH
15014: CALL_OW 458
15018: IFFALSE 15191
// begin LaunchMineAtPos ( x , y , 8 ) ;
15020: LD_VAR 0 4
15024: PPUSH
15025: LD_VAR 0 5
15029: PPUSH
15030: LD_INT 8
15032: PPUSH
15033: CALL_OW 456
// if not dialogueMineDetected then
15037: LD_EXP 28
15041: NOT
15042: IFFALSE 15103
// begin dialogueMineDetected := true ;
15044: LD_ADDR_EXP 28
15048: PUSH
15049: LD_INT 1
15051: ST_TO_ADDR
// CenterNowOnXY ( x , y ) ;
15052: LD_VAR 0 4
15056: PPUSH
15057: LD_VAR 0 5
15061: PPUSH
15062: CALL_OW 86
// Say ( playerCommander , D & [ I , J , S ] [ commander ] & -1-Mine ) ;
15066: LD_EXP 9
15070: PPUSH
15071: LD_STRING D
15073: PUSH
15074: LD_STRING I
15076: PUSH
15077: LD_STRING J
15079: PUSH
15080: LD_STRING S
15082: PUSH
15083: EMPTY
15084: LIST
15085: LIST
15086: LIST
15087: PUSH
15088: LD_EXP 25
15092: ARRAY
15093: STR
15094: PUSH
15095: LD_STRING -1-Mine
15097: STR
15098: PPUSH
15099: CALL_OW 88
// end ; for j = 1 to staticMines do
15103: LD_ADDR_VAR 0 2
15107: PUSH
15108: DOUBLE
15109: LD_INT 1
15111: DEC
15112: ST_TO_ADDR
15113: LD_EXP 16
15117: PUSH
15118: FOR_TO
15119: IFFALSE 15189
// if staticMines [ j ] [ 1 ] = x and staticMines [ j ] [ 2 ] = y then
15121: LD_EXP 16
15125: PUSH
15126: LD_VAR 0 2
15130: ARRAY
15131: PUSH
15132: LD_INT 1
15134: ARRAY
15135: PUSH
15136: LD_VAR 0 4
15140: EQUAL
15141: PUSH
15142: LD_EXP 16
15146: PUSH
15147: LD_VAR 0 2
15151: ARRAY
15152: PUSH
15153: LD_INT 2
15155: ARRAY
15156: PUSH
15157: LD_VAR 0 5
15161: EQUAL
15162: AND
15163: IFFALSE 15187
// begin staticMines := Delete ( staticMines , j ) ;
15165: LD_ADDR_EXP 16
15169: PUSH
15170: LD_EXP 16
15174: PPUSH
15175: LD_VAR 0 2
15179: PPUSH
15180: CALL_OW 3
15184: ST_TO_ADDR
// break ;
15185: GO 15189
// end ;
15187: GO 15118
15189: POP
15190: POP
// end ; end ;
15191: GO 14971
15193: POP
15194: POP
// end ;
15195: PPOPN 5
15197: END
// every 30 30$00 + 50 50$00 trigger GameType = 1 and game and sibBombAllowed and UnitFilter ( mc_bases [ mc_rus_1 ] , [ f_btype , b_factory ] ) do var bomb , e ;
15198: LD_EXP 2
15202: PUSH
15203: LD_INT 1
15205: EQUAL
15206: PUSH
15207: LD_EXP 3
15211: AND
15212: PUSH
15213: LD_EXP 23
15217: AND
15218: PUSH
15219: LD_EXP 31
15223: PUSH
15224: LD_EXP 7
15228: ARRAY
15229: PPUSH
15230: LD_INT 30
15232: PUSH
15233: LD_INT 3
15235: PUSH
15236: EMPTY
15237: LIST
15238: LIST
15239: PPUSH
15240: CALL_OW 72
15244: AND
15245: IFFALSE 15449
15247: GO 15249
15249: DISABLE
15250: LD_INT 0
15252: PPUSH
15253: PPUSH
// begin enable ;
15254: ENABLE
// MC_InsertProduceList ( mc_rus_1 , [ [ ru_heavy_wheeled , engine_siberite , control_computer , ru_siberium_rocket ] ] ) ;
15255: LD_EXP 7
15259: PPUSH
15260: LD_INT 23
15262: PUSH
15263: LD_INT 3
15265: PUSH
15266: LD_INT 3
15268: PUSH
15269: LD_INT 48
15271: PUSH
15272: EMPTY
15273: LIST
15274: LIST
15275: LIST
15276: LIST
15277: PUSH
15278: EMPTY
15279: LIST
15280: PPUSH
15281: CALL 85528 0 2
// repeat wait ( 0 0$1 ) ;
15285: LD_INT 35
15287: PPUSH
15288: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) ;
15292: LD_INT 22
15294: PUSH
15295: LD_INT 3
15297: PUSH
15298: EMPTY
15299: LIST
15300: LIST
15301: PUSH
15302: LD_INT 34
15304: PUSH
15305: LD_INT 48
15307: PUSH
15308: EMPTY
15309: LIST
15310: LIST
15311: PUSH
15312: EMPTY
15313: LIST
15314: LIST
15315: PPUSH
15316: CALL_OW 69
15320: IFFALSE 15285
// bomb := FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) ;
15322: LD_ADDR_VAR 0 1
15326: PUSH
15327: LD_INT 22
15329: PUSH
15330: LD_INT 3
15332: PUSH
15333: EMPTY
15334: LIST
15335: LIST
15336: PUSH
15337: LD_INT 34
15339: PUSH
15340: LD_INT 48
15342: PUSH
15343: EMPTY
15344: LIST
15345: LIST
15346: PUSH
15347: EMPTY
15348: LIST
15349: LIST
15350: PPUSH
15351: CALL_OW 69
15355: ST_TO_ADDR
// e := FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_type , unit_building ] ] ) ;
15356: LD_ADDR_VAR 0 2
15360: PUSH
15361: LD_INT 81
15363: PUSH
15364: LD_INT 3
15366: PUSH
15367: EMPTY
15368: LIST
15369: LIST
15370: PUSH
15371: LD_INT 21
15373: PUSH
15374: LD_INT 3
15376: PUSH
15377: EMPTY
15378: LIST
15379: LIST
15380: PUSH
15381: EMPTY
15382: LIST
15383: LIST
15384: PPUSH
15385: CALL_OW 69
15389: ST_TO_ADDR
// if e then
15390: LD_VAR 0 2
15394: IFFALSE 15420
// e := NearestUnitToUnit ( e , bomb [ 1 ] ) ;
15396: LD_ADDR_VAR 0 2
15400: PUSH
15401: LD_VAR 0 2
15405: PPUSH
15406: LD_VAR 0 1
15410: PUSH
15411: LD_INT 1
15413: ARRAY
15414: PPUSH
15415: CALL_OW 74
15419: ST_TO_ADDR
// ComAttackPlace ( bomb , GetX ( e ) , GetY ( e ) ) ;
15420: LD_VAR 0 1
15424: PPUSH
15425: LD_VAR 0 2
15429: PPUSH
15430: CALL_OW 250
15434: PPUSH
15435: LD_VAR 0 2
15439: PPUSH
15440: CALL_OW 251
15444: PPUSH
15445: CALL_OW 116
// end ;
15449: PPOPN 2
15451: END
// every 0 0$2 trigger Difficulty > 1 and UnitFilter ( mc_bases [ mc_rus_1 ] , [ f_class , 3 ] ) and GameType = 1 and game and GetTech ( tech_Behemoth , 3 ) = state_researched do var tmp , i ;
15452: LD_OWVAR 67
15456: PUSH
15457: LD_INT 1
15459: GREATER
15460: PUSH
15461: LD_EXP 31
15465: PUSH
15466: LD_EXP 7
15470: ARRAY
15471: PPUSH
15472: LD_INT 25
15474: PUSH
15475: LD_INT 3
15477: PUSH
15478: EMPTY
15479: LIST
15480: LIST
15481: PPUSH
15482: CALL_OW 72
15486: AND
15487: PUSH
15488: LD_EXP 2
15492: PUSH
15493: LD_INT 1
15495: EQUAL
15496: AND
15497: PUSH
15498: LD_EXP 3
15502: AND
15503: PUSH
15504: LD_INT 23
15506: PPUSH
15507: LD_INT 3
15509: PPUSH
15510: CALL_OW 321
15514: PUSH
15515: LD_INT 2
15517: EQUAL
15518: AND
15519: IFFALSE 15646
15521: GO 15523
15523: DISABLE
15524: LD_INT 0
15526: PPUSH
15527: PPUSH
// begin tmp := UnitFilter ( mc_bases [ mc_rus_1 ] , [ f_class , 3 ] ) ;
15528: LD_ADDR_VAR 0 1
15532: PUSH
15533: LD_EXP 31
15537: PUSH
15538: LD_EXP 7
15542: ARRAY
15543: PPUSH
15544: LD_INT 25
15546: PUSH
15547: LD_INT 3
15549: PUSH
15550: EMPTY
15551: LIST
15552: LIST
15553: PPUSH
15554: CALL_OW 72
15558: ST_TO_ADDR
// if not tmp then
15559: LD_VAR 0 1
15563: NOT
15564: IFFALSE 15568
// exit ;
15566: GO 15646
// for i in tmp do
15568: LD_ADDR_VAR 0 2
15572: PUSH
15573: LD_VAR 0 1
15577: PUSH
15578: FOR_IN
15579: IFFALSE 15625
// begin SetTag ( i , 29 ) ;
15581: LD_VAR 0 2
15585: PPUSH
15586: LD_INT 29
15588: PPUSH
15589: CALL_OW 109
// ComExitBuilding ( i ) ;
15593: LD_VAR 0 2
15597: PPUSH
15598: CALL_OW 122
// AddComBuildBehemoth ( i , b_behemoth , 97 , 133 , 0 ) ;
15602: LD_VAR 0 2
15606: PPUSH
15607: LD_INT 37
15609: PPUSH
15610: LD_INT 97
15612: PPUSH
15613: LD_INT 133
15615: PPUSH
15616: LD_INT 0
15618: PPUSH
15619: CALL_OW 230
// end ;
15623: GO 15578
15625: POP
15626: POP
// wait ( 1 1$00 ) ;
15627: LD_INT 2100
15629: PPUSH
15630: CALL_OW 67
// MC_Reset ( mc_rus_1 , 29 ) ;
15634: LD_EXP 7
15638: PPUSH
15639: LD_INT 29
15641: PPUSH
15642: CALL 65413 0 2
// end ;
15646: PPOPN 2
15648: END
// every 7 7$00 trigger GameType = 1 and GetBType ( HexInfo ( 84 , 128 ) ) = b_warehouse and GetSide ( HexInfo ( 84 , 128 ) ) = 3 do var veh , depot ;
15649: LD_EXP 2
15653: PUSH
15654: LD_INT 1
15656: EQUAL
15657: PUSH
15658: LD_INT 84
15660: PPUSH
15661: LD_INT 128
15663: PPUSH
15664: CALL_OW 428
15668: PPUSH
15669: CALL_OW 266
15673: PUSH
15674: LD_INT 1
15676: EQUAL
15677: AND
15678: PUSH
15679: LD_INT 84
15681: PPUSH
15682: LD_INT 128
15684: PPUSH
15685: CALL_OW 428
15689: PPUSH
15690: CALL_OW 255
15694: PUSH
15695: LD_INT 3
15697: EQUAL
15698: AND
15699: IFFALSE 15872
15701: GO 15703
15703: DISABLE
15704: LD_INT 0
15706: PPUSH
15707: PPUSH
// begin enable ;
15708: ENABLE
// depot := HexInfo ( 84 , 128 ) ;
15709: LD_ADDR_VAR 0 2
15713: PUSH
15714: LD_INT 84
15716: PPUSH
15717: LD_INT 128
15719: PPUSH
15720: CALL_OW 428
15724: ST_TO_ADDR
// uc_side := 3 ;
15725: LD_ADDR_OWVAR 20
15729: PUSH
15730: LD_INT 3
15732: ST_TO_ADDR
// uc_nation := 3 ;
15733: LD_ADDR_OWVAR 21
15737: PUSH
15738: LD_INT 3
15740: ST_TO_ADDR
// PrepareVehicle ( ru_medium_wheeled , engine_siberite , control_computer , ru_cargo_bay , 0 ) ;
15741: LD_INT 21
15743: PPUSH
15744: LD_INT 3
15746: PPUSH
15747: LD_INT 3
15749: PPUSH
15750: LD_INT 51
15752: PPUSH
15753: LD_INT 0
15755: PPUSH
15756: CALL 24899 0 5
// veh := CreateVehicle ;
15760: LD_ADDR_VAR 0 1
15764: PUSH
15765: CALL_OW 45
15769: ST_TO_ADDR
// PlaceUnitXY ( veh , 126 , 227 , false ) ;
15770: LD_VAR 0 1
15774: PPUSH
15775: LD_INT 126
15777: PPUSH
15778: LD_INT 227
15780: PPUSH
15781: LD_INT 0
15783: PPUSH
15784: CALL_OW 48
// SetCargo ( veh , mat_oil , 100 ) ;
15788: LD_VAR 0 1
15792: PPUSH
15793: LD_INT 2
15795: PPUSH
15796: LD_INT 100
15798: PPUSH
15799: CALL_OW 290
// ComGive ( veh , depot ) ;
15803: LD_VAR 0 1
15807: PPUSH
15808: LD_VAR 0 2
15812: PPUSH
15813: CALL_OW 161
// AddComMoveXY ( veh , 126 , 227 ) ;
15817: LD_VAR 0 1
15821: PPUSH
15822: LD_INT 126
15824: PPUSH
15825: LD_INT 227
15827: PPUSH
15828: CALL_OW 171
// wait ( 0 0$10 ) ;
15832: LD_INT 350
15834: PPUSH
15835: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
15839: LD_INT 35
15841: PPUSH
15842: CALL_OW 67
// until IsAt ( veh , 126 , 227 ) ;
15846: LD_VAR 0 1
15850: PPUSH
15851: LD_INT 126
15853: PPUSH
15854: LD_INT 227
15856: PPUSH
15857: CALL_OW 307
15861: IFFALSE 15839
// RemoveUnit ( veh ) ;
15863: LD_VAR 0 1
15867: PPUSH
15868: CALL_OW 64
// end ;
15872: PPOPN 2
15874: END
// every 9 9$00 trigger GameType = 1 and outpostEscape and commander = 2 do var veh , depot ;
15875: LD_EXP 2
15879: PUSH
15880: LD_INT 1
15882: EQUAL
15883: PUSH
15884: LD_EXP 27
15888: AND
15889: PUSH
15890: LD_EXP 25
15894: PUSH
15895: LD_INT 2
15897: EQUAL
15898: AND
15899: IFFALSE 16091
15901: GO 15903
15903: DISABLE
15904: LD_INT 0
15906: PPUSH
15907: PPUSH
// begin enable ;
15908: ENABLE
// if tick >= [ 50 50$00 , 40 40$00 , 30 30$00 ] [ Difficulty ] then
15909: LD_OWVAR 1
15913: PUSH
15914: LD_INT 105000
15916: PUSH
15917: LD_INT 84000
15919: PUSH
15920: LD_INT 63000
15922: PUSH
15923: EMPTY
15924: LIST
15925: LIST
15926: LIST
15927: PUSH
15928: LD_OWVAR 67
15932: ARRAY
15933: GREATEREQUAL
15934: IFFALSE 15937
// disable ;
15936: DISABLE
// uc_side := 4 ;
15937: LD_ADDR_OWVAR 20
15941: PUSH
15942: LD_INT 4
15944: ST_TO_ADDR
// uc_nation := 1 ;
15945: LD_ADDR_OWVAR 21
15949: PUSH
15950: LD_INT 1
15952: ST_TO_ADDR
// PrepareVehicle ( us_medium_wheeled , engine_siberite , control_computer , us_cargo_bay , 0 ) ;
15953: LD_INT 2
15955: PPUSH
15956: LD_INT 3
15958: PPUSH
15959: LD_INT 3
15961: PPUSH
15962: LD_INT 12
15964: PPUSH
15965: LD_INT 0
15967: PPUSH
15968: CALL 24899 0 5
// veh := CreateVehicle ;
15972: LD_ADDR_VAR 0 1
15976: PUSH
15977: CALL_OW 45
15981: ST_TO_ADDR
// PlaceUnitXY ( veh , 229 , 226 , false ) ;
15982: LD_VAR 0 1
15986: PPUSH
15987: LD_INT 229
15989: PPUSH
15990: LD_INT 226
15992: PPUSH
15993: LD_INT 0
15995: PPUSH
15996: CALL_OW 48
// SetCargo ( veh , mat_cans , 100 ) ;
16000: LD_VAR 0 1
16004: PPUSH
16005: LD_INT 1
16007: PPUSH
16008: LD_INT 100
16010: PPUSH
16011: CALL_OW 290
// AddComMoveToArea ( veh , ruOutpostArea ) ;
16015: LD_VAR 0 1
16019: PPUSH
16020: LD_INT 25
16022: PPUSH
16023: CALL_OW 173
// AddComUnload ( veh ) ;
16027: LD_VAR 0 1
16031: PPUSH
16032: CALL_OW 219
// AddComMoveXY ( veh , 229 , 226 ) ;
16036: LD_VAR 0 1
16040: PPUSH
16041: LD_INT 229
16043: PPUSH
16044: LD_INT 226
16046: PPUSH
16047: CALL_OW 171
// wait ( 0 0$10 ) ;
16051: LD_INT 350
16053: PPUSH
16054: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
16058: LD_INT 35
16060: PPUSH
16061: CALL_OW 67
// until IsAt ( veh , 229 , 226 ) ;
16065: LD_VAR 0 1
16069: PPUSH
16070: LD_INT 229
16072: PPUSH
16073: LD_INT 226
16075: PPUSH
16076: CALL_OW 307
16080: IFFALSE 16058
// RemoveUnit ( veh ) ;
16082: LD_VAR 0 1
16086: PPUSH
16087: CALL_OW 64
// end ;
16091: PPOPN 2
16093: END
// every 15 15$00 trigger GameType = 1 and game and reinforceAllowed do var i , j , veh , tmp , amount ;
16094: LD_EXP 2
16098: PUSH
16099: LD_INT 1
16101: EQUAL
16102: PUSH
16103: LD_EXP 3
16107: AND
16108: PUSH
16109: LD_EXP 24
16113: AND
16114: IFFALSE 16447
16116: GO 16118
16118: DISABLE
16119: LD_INT 0
16121: PPUSH
16122: PPUSH
16123: PPUSH
16124: PPUSH
16125: PPUSH
// begin enable ;
16126: ENABLE
// tmp := [ ] ;
16127: LD_ADDR_VAR 0 4
16131: PUSH
16132: EMPTY
16133: ST_TO_ADDR
// if commander = 1 then
16134: LD_EXP 25
16138: PUSH
16139: LD_INT 1
16141: EQUAL
16142: IFFALSE 16154
// amount := 3 else
16144: LD_ADDR_VAR 0 5
16148: PUSH
16149: LD_INT 3
16151: ST_TO_ADDR
16152: GO 16162
// amount := 2 ;
16154: LD_ADDR_VAR 0 5
16158: PUSH
16159: LD_INT 2
16161: ST_TO_ADDR
// for i = 1 to amount do
16162: LD_ADDR_VAR 0 1
16166: PUSH
16167: DOUBLE
16168: LD_INT 1
16170: DEC
16171: ST_TO_ADDR
16172: LD_VAR 0 5
16176: PUSH
16177: FOR_TO
16178: IFFALSE 16342
// begin wait ( 0 0$5 ) ;
16180: LD_INT 175
16182: PPUSH
16183: CALL_OW 67
// for j = 1 to 3 do
16187: LD_ADDR_VAR 0 2
16191: PUSH
16192: DOUBLE
16193: LD_INT 1
16195: DEC
16196: ST_TO_ADDR
16197: LD_INT 3
16199: PUSH
16200: FOR_TO
16201: IFFALSE 16338
// begin uc_side := 4 ;
16203: LD_ADDR_OWVAR 20
16207: PUSH
16208: LD_INT 4
16210: ST_TO_ADDR
// uc_nation := 1 ;
16211: LD_ADDR_OWVAR 21
16215: PUSH
16216: LD_INT 1
16218: ST_TO_ADDR
// PrepareVehicle ( [ us_medium_tracked , us_morphling ] [ rand ( 1 , 2 ) ] , engine_siberite , control_computer , [ us_laser , us_double_gun , us_rocket_launcher ] [ rand ( 1 , 3 ) ] , 100 ) ;
16219: LD_INT 3
16221: PUSH
16222: LD_INT 5
16224: PUSH
16225: EMPTY
16226: LIST
16227: LIST
16228: PUSH
16229: LD_INT 1
16231: PPUSH
16232: LD_INT 2
16234: PPUSH
16235: CALL_OW 12
16239: ARRAY
16240: PPUSH
16241: LD_INT 3
16243: PPUSH
16244: LD_INT 3
16246: PPUSH
16247: LD_INT 9
16249: PUSH
16250: LD_INT 5
16252: PUSH
16253: LD_INT 7
16255: PUSH
16256: EMPTY
16257: LIST
16258: LIST
16259: LIST
16260: PUSH
16261: LD_INT 1
16263: PPUSH
16264: LD_INT 3
16266: PPUSH
16267: CALL_OW 12
16271: ARRAY
16272: PPUSH
16273: LD_INT 100
16275: PPUSH
16276: CALL 24899 0 5
// veh := CreateVehicle ;
16280: LD_ADDR_VAR 0 3
16284: PUSH
16285: CALL_OW 45
16289: ST_TO_ADDR
// tmp := tmp ^ veh ;
16290: LD_ADDR_VAR 0 4
16294: PUSH
16295: LD_VAR 0 4
16299: PUSH
16300: LD_VAR 0 3
16304: ADD
16305: ST_TO_ADDR
// PlaceUnitArea ( veh , westSpawn , false ) ;
16306: LD_VAR 0 3
16310: PPUSH
16311: LD_INT 22
16313: PPUSH
16314: LD_INT 0
16316: PPUSH
16317: CALL_OW 49
// ComMoveXY ( veh , 119 , 215 ) ;
16321: LD_VAR 0 3
16325: PPUSH
16326: LD_INT 119
16328: PPUSH
16329: LD_INT 215
16331: PPUSH
16332: CALL_OW 111
// end ;
16336: GO 16200
16338: POP
16339: POP
// end ;
16340: GO 16177
16342: POP
16343: POP
// wait ( 0 0$3 ) ;
16344: LD_INT 105
16346: PPUSH
16347: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
16351: LD_INT 35
16353: PPUSH
16354: CALL_OW 67
// for i in tmp do
16358: LD_ADDR_VAR 0 1
16362: PUSH
16363: LD_VAR 0 4
16367: PUSH
16368: FOR_IN
16369: IFFALSE 16436
// if IsDead ( i ) then
16371: LD_VAR 0 1
16375: PPUSH
16376: CALL_OW 301
16380: IFFALSE 16400
// tmp := tmp diff i else
16382: LD_ADDR_VAR 0 4
16386: PUSH
16387: LD_VAR 0 4
16391: PUSH
16392: LD_VAR 0 1
16396: DIFF
16397: ST_TO_ADDR
16398: GO 16434
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 4 ] ) , i ) ) ;
16400: LD_VAR 0 1
16404: PPUSH
16405: LD_INT 81
16407: PUSH
16408: LD_INT 4
16410: PUSH
16411: EMPTY
16412: LIST
16413: LIST
16414: PPUSH
16415: CALL_OW 69
16419: PPUSH
16420: LD_VAR 0 1
16424: PPUSH
16425: CALL_OW 74
16429: PPUSH
16430: CALL_OW 115
16434: GO 16368
16436: POP
16437: POP
// until tmp = [ ] ;
16438: LD_VAR 0 4
16442: PUSH
16443: EMPTY
16444: EQUAL
16445: IFFALSE 16351
// end ;
16447: PPOPN 5
16449: END
// every 0 0$1 trigger GameType = 1 and game do var i , tmp ;
16450: LD_EXP 2
16454: PUSH
16455: LD_INT 1
16457: EQUAL
16458: PUSH
16459: LD_EXP 3
16463: AND
16464: IFFALSE 16565
16466: GO 16468
16468: DISABLE
16469: LD_INT 0
16471: PPUSH
16472: PPUSH
// begin enable ;
16473: ENABLE
// tmp := FilterAllUnits ( [ [ f_not , [ f_side , 1 ] ] , [ f_engine , engine_combustion ] ] ) ;
16474: LD_ADDR_VAR 0 2
16478: PUSH
16479: LD_INT 3
16481: PUSH
16482: LD_INT 22
16484: PUSH
16485: LD_INT 1
16487: PUSH
16488: EMPTY
16489: LIST
16490: LIST
16491: PUSH
16492: EMPTY
16493: LIST
16494: LIST
16495: PUSH
16496: LD_INT 32
16498: PUSH
16499: LD_INT 1
16501: PUSH
16502: EMPTY
16503: LIST
16504: LIST
16505: PUSH
16506: EMPTY
16507: LIST
16508: LIST
16509: PPUSH
16510: CALL_OW 69
16514: ST_TO_ADDR
// if tmp then
16515: LD_VAR 0 2
16519: IFFALSE 16565
// for i in tmp do
16521: LD_ADDR_VAR 0 1
16525: PUSH
16526: LD_VAR 0 2
16530: PUSH
16531: FOR_IN
16532: IFFALSE 16563
// if GetFuel ( i ) < 3 then
16534: LD_VAR 0 1
16538: PPUSH
16539: CALL_OW 261
16543: PUSH
16544: LD_INT 3
16546: LESS
16547: IFFALSE 16561
// SetFuel ( i , 3 ) ;
16549: LD_VAR 0 1
16553: PPUSH
16554: LD_INT 3
16556: PPUSH
16557: CALL_OW 240
16561: GO 16531
16563: POP
16564: POP
// end ;
16565: PPOPN 2
16567: END
// every 15 15$00 trigger game and GetAttitude ( 8 , 4 ) = att_enemy do var i , un , tmp ;
16568: LD_EXP 3
16572: PUSH
16573: LD_INT 8
16575: PPUSH
16576: LD_INT 4
16578: PPUSH
16579: CALL_OW 81
16583: PUSH
16584: LD_INT 2
16586: EQUAL
16587: AND
16588: IFFALSE 16798
16590: GO 16592
16592: DISABLE
16593: LD_INT 0
16595: PPUSH
16596: PPUSH
16597: PPUSH
// begin enable ;
16598: ENABLE
// tmp := [ ] ;
16599: LD_ADDR_VAR 0 3
16603: PUSH
16604: EMPTY
16605: ST_TO_ADDR
// for i = 1 to 4 do
16606: LD_ADDR_VAR 0 1
16610: PUSH
16611: DOUBLE
16612: LD_INT 1
16614: DEC
16615: ST_TO_ADDR
16616: LD_INT 4
16618: PUSH
16619: FOR_TO
16620: IFFALSE 16764
// begin uc_side := 8 ;
16622: LD_ADDR_OWVAR 20
16626: PUSH
16627: LD_INT 8
16629: ST_TO_ADDR
// uc_nation := nation_arabian ;
16630: LD_ADDR_OWVAR 21
16634: PUSH
16635: LD_INT 2
16637: ST_TO_ADDR
// PrepareVehicle ( ar_hovercraft , engine_combustion , control_apeman , [ ar_double_machine_gun , ar_light_gun ] [ rand ( 1 , 2 ) ] , rand ( 60 , 80 ) ) ;
16638: LD_INT 11
16640: PPUSH
16641: LD_INT 1
16643: PPUSH
16644: LD_INT 5
16646: PPUSH
16647: LD_INT 24
16649: PUSH
16650: LD_INT 23
16652: PUSH
16653: EMPTY
16654: LIST
16655: LIST
16656: PUSH
16657: LD_INT 1
16659: PPUSH
16660: LD_INT 2
16662: PPUSH
16663: CALL_OW 12
16667: ARRAY
16668: PPUSH
16669: LD_INT 60
16671: PPUSH
16672: LD_INT 80
16674: PPUSH
16675: CALL_OW 12
16679: PPUSH
16680: CALL 24899 0 5
// un := CreateVehicle ;
16684: LD_ADDR_VAR 0 2
16688: PUSH
16689: CALL_OW 45
16693: ST_TO_ADDR
// SetDir ( un , 2 ) ;
16694: LD_VAR 0 2
16698: PPUSH
16699: LD_INT 2
16701: PPUSH
16702: CALL_OW 233
// tmp := tmp ^ un ;
16706: LD_ADDR_VAR 0 3
16710: PUSH
16711: LD_VAR 0 3
16715: PUSH
16716: LD_VAR 0 2
16720: ADD
16721: ST_TO_ADDR
// PlaceUnitXY ( un , 88 , 2 , false ) ;
16722: LD_VAR 0 2
16726: PPUSH
16727: LD_INT 88
16729: PPUSH
16730: LD_INT 2
16732: PPUSH
16733: LD_INT 0
16735: PPUSH
16736: CALL_OW 48
// ComMoveXY ( un , 93 , 13 ) ;
16740: LD_VAR 0 2
16744: PPUSH
16745: LD_INT 93
16747: PPUSH
16748: LD_INT 13
16750: PPUSH
16751: CALL_OW 111
// wait ( 0 0$2 ) ;
16755: LD_INT 70
16757: PPUSH
16758: CALL_OW 67
// end ;
16762: GO 16619
16764: POP
16765: POP
// for i in tmp do
16766: LD_ADDR_VAR 0 1
16770: PUSH
16771: LD_VAR 0 3
16775: PUSH
16776: FOR_IN
16777: IFFALSE 16796
// AddComMoveXY ( i , 136 , 19 ) ;
16779: LD_VAR 0 1
16783: PPUSH
16784: LD_INT 136
16786: PPUSH
16787: LD_INT 19
16789: PPUSH
16790: CALL_OW 171
16794: GO 16776
16796: POP
16797: POP
// end ;
16798: PPOPN 3
16800: END
// every 7 7$30 + 7 7$30 trigger game do var i , base , tmp , target ;
16801: LD_EXP 3
16805: IFFALSE 17724
16807: GO 16809
16809: DISABLE
16810: LD_INT 0
16812: PPUSH
16813: PPUSH
16814: PPUSH
16815: PPUSH
// begin enable ;
16816: ENABLE
// base := mc_leg ;
16817: LD_ADDR_VAR 0 2
16821: PUSH
16822: LD_EXP 6
16826: ST_TO_ADDR
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) then
16827: LD_INT 22
16829: PUSH
16830: LD_INT 8
16832: PUSH
16833: EMPTY
16834: LIST
16835: LIST
16836: PUSH
16837: LD_INT 23
16839: PUSH
16840: LD_INT 2
16842: PUSH
16843: EMPTY
16844: LIST
16845: LIST
16846: PUSH
16847: LD_INT 30
16849: PUSH
16850: LD_INT 3
16852: PUSH
16853: EMPTY
16854: LIST
16855: LIST
16856: PUSH
16857: EMPTY
16858: LIST
16859: LIST
16860: LIST
16861: PPUSH
16862: CALL_OW 69
16866: NOT
16867: IFFALSE 16871
// exit ;
16869: GO 17724
// if Prob ( 40 ) then
16871: LD_INT 40
16873: PPUSH
16874: CALL_OW 13
16878: IFFALSE 17007
// begin MC_InsertProduceList ( base , [ [ ar_medium_trike , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
16880: LD_VAR 0 2
16884: PPUSH
16885: LD_INT 13
16887: PUSH
16888: LD_INT 1
16890: PUSH
16891: LD_INT 2
16893: PUSH
16894: LD_INT 28
16896: PUSH
16897: EMPTY
16898: LIST
16899: LIST
16900: LIST
16901: LIST
16902: PUSH
16903: LD_INT 13
16905: PUSH
16906: LD_INT 1
16908: PUSH
16909: LD_INT 2
16911: PUSH
16912: LD_INT 28
16914: PUSH
16915: EMPTY
16916: LIST
16917: LIST
16918: LIST
16919: LIST
16920: PUSH
16921: LD_INT 13
16923: PUSH
16924: LD_INT 1
16926: PUSH
16927: LD_INT 2
16929: PUSH
16930: LD_INT 28
16932: PUSH
16933: EMPTY
16934: LIST
16935: LIST
16936: LIST
16937: LIST
16938: PUSH
16939: LD_INT 13
16941: PUSH
16942: LD_INT 1
16944: PUSH
16945: LD_INT 2
16947: PUSH
16948: LD_INT 28
16950: PUSH
16951: EMPTY
16952: LIST
16953: LIST
16954: LIST
16955: LIST
16956: PUSH
16957: LD_INT 13
16959: PUSH
16960: LD_INT 1
16962: PUSH
16963: LD_INT 2
16965: PUSH
16966: LD_INT 28
16968: PUSH
16969: EMPTY
16970: LIST
16971: LIST
16972: LIST
16973: LIST
16974: PUSH
16975: LD_INT 13
16977: PUSH
16978: LD_INT 1
16980: PUSH
16981: LD_INT 2
16983: PUSH
16984: LD_INT 26
16986: PUSH
16987: EMPTY
16988: LIST
16989: LIST
16990: LIST
16991: LIST
16992: PUSH
16993: EMPTY
16994: LIST
16995: LIST
16996: LIST
16997: LIST
16998: LIST
16999: LIST
17000: PPUSH
17001: CALL 85528 0 2
// end else
17005: GO 17224
// begin MC_InsertProduceList ( base , [ [ ar_medium_trike , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower ] [ rand ( 1 , 3 ) ] ] , [ ar_medium_trike , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower ] [ rand ( 1 , 3 ) ] ] , [ ar_medium_trike , engine_combustion , control_remote , [ ar_flame_thrower , ar_flame_thrower , ar_selfpropelled_bomb ] [ rand ( 1 , 3 ) ] ] , [ ar_medium_trike , engine_combustion , control_remote , [ ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ rand ( 1 , 3 ) ] ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_medium_trike , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
17007: LD_VAR 0 2
17011: PPUSH
17012: LD_INT 13
17014: PUSH
17015: LD_INT 1
17017: PUSH
17018: LD_INT 2
17020: PUSH
17021: LD_INT 27
17023: PUSH
17024: LD_INT 26
17026: PUSH
17027: LD_INT 26
17029: PUSH
17030: EMPTY
17031: LIST
17032: LIST
17033: LIST
17034: PUSH
17035: LD_INT 1
17037: PPUSH
17038: LD_INT 3
17040: PPUSH
17041: CALL_OW 12
17045: ARRAY
17046: PUSH
17047: EMPTY
17048: LIST
17049: LIST
17050: LIST
17051: LIST
17052: PUSH
17053: LD_INT 13
17055: PUSH
17056: LD_INT 1
17058: PUSH
17059: LD_INT 2
17061: PUSH
17062: LD_INT 27
17064: PUSH
17065: LD_INT 26
17067: PUSH
17068: LD_INT 26
17070: PUSH
17071: EMPTY
17072: LIST
17073: LIST
17074: LIST
17075: PUSH
17076: LD_INT 1
17078: PPUSH
17079: LD_INT 3
17081: PPUSH
17082: CALL_OW 12
17086: ARRAY
17087: PUSH
17088: EMPTY
17089: LIST
17090: LIST
17091: LIST
17092: LIST
17093: PUSH
17094: LD_INT 13
17096: PUSH
17097: LD_INT 1
17099: PUSH
17100: LD_INT 2
17102: PUSH
17103: LD_INT 26
17105: PUSH
17106: LD_INT 26
17108: PUSH
17109: LD_INT 29
17111: PUSH
17112: EMPTY
17113: LIST
17114: LIST
17115: LIST
17116: PUSH
17117: LD_INT 1
17119: PPUSH
17120: LD_INT 3
17122: PPUSH
17123: CALL_OW 12
17127: ARRAY
17128: PUSH
17129: EMPTY
17130: LIST
17131: LIST
17132: LIST
17133: LIST
17134: PUSH
17135: LD_INT 13
17137: PUSH
17138: LD_INT 1
17140: PUSH
17141: LD_INT 2
17143: PUSH
17144: LD_INT 26
17146: PUSH
17147: LD_INT 29
17149: PUSH
17150: LD_INT 29
17152: PUSH
17153: EMPTY
17154: LIST
17155: LIST
17156: LIST
17157: PUSH
17158: LD_INT 1
17160: PPUSH
17161: LD_INT 3
17163: PPUSH
17164: CALL_OW 12
17168: ARRAY
17169: PUSH
17170: EMPTY
17171: LIST
17172: LIST
17173: LIST
17174: LIST
17175: PUSH
17176: LD_INT 13
17178: PUSH
17179: LD_INT 1
17181: PUSH
17182: LD_INT 2
17184: PUSH
17185: LD_INT 29
17187: PUSH
17188: EMPTY
17189: LIST
17190: LIST
17191: LIST
17192: LIST
17193: PUSH
17194: LD_INT 13
17196: PUSH
17197: LD_INT 1
17199: PUSH
17200: LD_INT 2
17202: PUSH
17203: LD_INT 26
17205: PUSH
17206: EMPTY
17207: LIST
17208: LIST
17209: LIST
17210: LIST
17211: PUSH
17212: EMPTY
17213: LIST
17214: LIST
17215: LIST
17216: LIST
17217: LIST
17218: LIST
17219: PPUSH
17220: CALL 85528 0 2
// end ; repeat wait ( 0 0$1 ) ;
17224: LD_INT 35
17226: PPUSH
17227: CALL_OW 67
// until MC_GetVehicles ( base , true ) >= 6 or tick mod 10 10$00 = 0 ;
17231: LD_VAR 0 2
17235: PPUSH
17236: LD_INT 1
17238: PPUSH
17239: CALL 86946 0 2
17243: PUSH
17244: LD_INT 6
17246: GREATEREQUAL
17247: PUSH
17248: LD_OWVAR 1
17252: PUSH
17253: LD_INT 21000
17255: MOD
17256: PUSH
17257: LD_INT 0
17259: EQUAL
17260: OR
17261: IFFALSE 17224
// wait ( 0 0$30 ) ;
17263: LD_INT 1050
17265: PPUSH
17266: CALL_OW 67
// tmp := MC_GetVehicles ( base , true ) ;
17270: LD_ADDR_VAR 0 3
17274: PUSH
17275: LD_VAR 0 2
17279: PPUSH
17280: LD_INT 1
17282: PPUSH
17283: CALL 86946 0 2
17287: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , mc_vehicles [ base ] diff tmp ) ;
17288: LD_ADDR_EXP 50
17292: PUSH
17293: LD_EXP 50
17297: PPUSH
17298: LD_VAR 0 2
17302: PPUSH
17303: LD_EXP 50
17307: PUSH
17308: LD_VAR 0 2
17312: ARRAY
17313: PUSH
17314: LD_VAR 0 3
17318: DIFF
17319: PPUSH
17320: CALL_OW 1
17324: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
17325: LD_ADDR_VAR 0 4
17329: PUSH
17330: LD_INT 0
17332: PPUSH
17333: LD_INT 2
17335: PPUSH
17336: CALL_OW 12
17340: ST_TO_ADDR
// if legChangeSide then
17341: LD_EXP 21
17345: IFFALSE 17355
// target := 2 ;
17347: LD_ADDR_VAR 0 4
17351: PUSH
17352: LD_INT 2
17354: ST_TO_ADDR
// if target = 2 then
17355: LD_VAR 0 4
17359: PUSH
17360: LD_INT 2
17362: EQUAL
17363: IFFALSE 17491
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
17365: LD_ADDR_VAR 0 3
17369: PUSH
17370: LD_VAR 0 3
17374: PPUSH
17375: LD_INT 24
17377: PUSH
17378: LD_INT 250
17380: PUSH
17381: EMPTY
17382: LIST
17383: LIST
17384: PPUSH
17385: CALL_OW 72
17389: ST_TO_ADDR
// for i in tmp do
17390: LD_ADDR_VAR 0 1
17394: PUSH
17395: LD_VAR 0 3
17399: PUSH
17400: FOR_IN
17401: IFFALSE 17441
// if GetDistUnitXY ( i , 112 , 64 ) > 9 then
17403: LD_VAR 0 1
17407: PPUSH
17408: LD_INT 112
17410: PPUSH
17411: LD_INT 64
17413: PPUSH
17414: CALL_OW 297
17418: PUSH
17419: LD_INT 9
17421: GREATER
17422: IFFALSE 17439
// ComMoveXY ( i , 112 , 64 ) ;
17424: LD_VAR 0 1
17428: PPUSH
17429: LD_INT 112
17431: PPUSH
17432: LD_INT 64
17434: PPUSH
17435: CALL_OW 111
17439: GO 17400
17441: POP
17442: POP
// wait ( 0 0$1 ) ;
17443: LD_INT 35
17445: PPUSH
17446: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 112 , 64 , 9 ] ) >= ( tmp - 1 ) ;
17450: LD_VAR 0 3
17454: PPUSH
17455: LD_INT 92
17457: PUSH
17458: LD_INT 112
17460: PUSH
17461: LD_INT 64
17463: PUSH
17464: LD_INT 9
17466: PUSH
17467: EMPTY
17468: LIST
17469: LIST
17470: LIST
17471: LIST
17472: PPUSH
17473: CALL_OW 72
17477: PUSH
17478: LD_VAR 0 3
17482: PUSH
17483: LD_INT 1
17485: MINUS
17486: GREATEREQUAL
17487: IFFALSE 17365
// end else
17489: GO 17615
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
17491: LD_ADDR_VAR 0 3
17495: PUSH
17496: LD_VAR 0 3
17500: PPUSH
17501: LD_INT 24
17503: PUSH
17504: LD_INT 250
17506: PUSH
17507: EMPTY
17508: LIST
17509: LIST
17510: PPUSH
17511: CALL_OW 72
17515: ST_TO_ADDR
// for i in tmp do
17516: LD_ADDR_VAR 0 1
17520: PUSH
17521: LD_VAR 0 3
17525: PUSH
17526: FOR_IN
17527: IFFALSE 17567
// if GetDistUnitXY ( i , 174 , 94 ) > 9 then
17529: LD_VAR 0 1
17533: PPUSH
17534: LD_INT 174
17536: PPUSH
17537: LD_INT 94
17539: PPUSH
17540: CALL_OW 297
17544: PUSH
17545: LD_INT 9
17547: GREATER
17548: IFFALSE 17565
// ComMoveXY ( i , 174 , 94 ) ;
17550: LD_VAR 0 1
17554: PPUSH
17555: LD_INT 174
17557: PPUSH
17558: LD_INT 94
17560: PPUSH
17561: CALL_OW 111
17565: GO 17526
17567: POP
17568: POP
// wait ( 0 0$1 ) ;
17569: LD_INT 35
17571: PPUSH
17572: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 174 , 94 , 9 ] ) >= ( tmp - 1 ) ;
17576: LD_VAR 0 3
17580: PPUSH
17581: LD_INT 92
17583: PUSH
17584: LD_INT 174
17586: PUSH
17587: LD_INT 94
17589: PUSH
17590: LD_INT 9
17592: PUSH
17593: EMPTY
17594: LIST
17595: LIST
17596: LIST
17597: LIST
17598: PPUSH
17599: CALL_OW 72
17603: PUSH
17604: LD_VAR 0 3
17608: PUSH
17609: LD_INT 1
17611: MINUS
17612: GREATEREQUAL
17613: IFFALSE 17491
// end ; repeat wait ( 0 0$1 ) ;
17615: LD_INT 35
17617: PPUSH
17618: CALL_OW 67
// for i in tmp do
17622: LD_ADDR_VAR 0 1
17626: PUSH
17627: LD_VAR 0 3
17631: PUSH
17632: FOR_IN
17633: IFFALSE 17715
// begin if GetLives ( i ) > 251 then
17635: LD_VAR 0 1
17639: PPUSH
17640: CALL_OW 256
17644: PUSH
17645: LD_INT 251
17647: GREATER
17648: IFFALSE 17686
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) else
17650: LD_VAR 0 1
17654: PPUSH
17655: LD_INT 81
17657: PUSH
17658: LD_INT 8
17660: PUSH
17661: EMPTY
17662: LIST
17663: LIST
17664: PPUSH
17665: CALL_OW 69
17669: PPUSH
17670: LD_VAR 0 1
17674: PPUSH
17675: CALL_OW 74
17679: PPUSH
17680: CALL_OW 115
17684: GO 17713
// if IsDead ( i ) then
17686: LD_VAR 0 1
17690: PPUSH
17691: CALL_OW 301
17695: IFFALSE 17713
// tmp := tmp diff i ;
17697: LD_ADDR_VAR 0 3
17701: PUSH
17702: LD_VAR 0 3
17706: PUSH
17707: LD_VAR 0 1
17711: DIFF
17712: ST_TO_ADDR
// end ;
17713: GO 17632
17715: POP
17716: POP
// until not tmp ;
17717: LD_VAR 0 3
17721: NOT
17722: IFFALSE 17615
// end ;
17724: PPOPN 4
17726: END
// every 7 7$30 trigger game do var i , base , tmp , target , teleport ;
17727: LD_EXP 3
17731: IFFALSE 18719
17733: GO 17735
17735: DISABLE
17736: LD_INT 0
17738: PPUSH
17739: PPUSH
17740: PPUSH
17741: PPUSH
17742: PPUSH
// begin enable ;
17743: ENABLE
// if not UnitFilter ( mc_bases [ mc_rus_2 ] , [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) then
17744: LD_EXP 31
17748: PUSH
17749: LD_EXP 8
17753: ARRAY
17754: PPUSH
17755: LD_INT 22
17757: PUSH
17758: LD_INT 3
17760: PUSH
17761: EMPTY
17762: LIST
17763: LIST
17764: PUSH
17765: LD_INT 30
17767: PUSH
17768: LD_INT 3
17770: PUSH
17771: EMPTY
17772: LIST
17773: LIST
17774: PUSH
17775: EMPTY
17776: LIST
17777: LIST
17778: PPUSH
17779: CALL_OW 72
17783: NOT
17784: IFFALSE 17788
// exit ;
17786: GO 18719
// base := mc_rus_2 ;
17788: LD_ADDR_VAR 0 2
17792: PUSH
17793: LD_EXP 8
17797: ST_TO_ADDR
// teleport := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) ;
17798: LD_ADDR_VAR 0 5
17802: PUSH
17803: LD_INT 22
17805: PUSH
17806: LD_INT 3
17808: PUSH
17809: EMPTY
17810: LIST
17811: LIST
17812: PUSH
17813: LD_INT 30
17815: PUSH
17816: LD_INT 34
17818: PUSH
17819: EMPTY
17820: LIST
17821: LIST
17822: PUSH
17823: EMPTY
17824: LIST
17825: LIST
17826: PPUSH
17827: CALL_OW 69
17831: ST_TO_ADDR
// if Prob ( 40 ) then
17832: LD_INT 40
17834: PPUSH
17835: CALL_OW 13
17839: IFFALSE 17968
// begin MC_InsertProduceList ( base , [ [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
17841: LD_VAR 0 2
17845: PPUSH
17846: LD_INT 22
17848: PUSH
17849: LD_INT 3
17851: PUSH
17852: LD_INT 3
17854: PUSH
17855: LD_INT 49
17857: PUSH
17858: EMPTY
17859: LIST
17860: LIST
17861: LIST
17862: LIST
17863: PUSH
17864: LD_INT 22
17866: PUSH
17867: LD_INT 3
17869: PUSH
17870: LD_INT 3
17872: PUSH
17873: LD_INT 49
17875: PUSH
17876: EMPTY
17877: LIST
17878: LIST
17879: LIST
17880: LIST
17881: PUSH
17882: LD_INT 22
17884: PUSH
17885: LD_INT 3
17887: PUSH
17888: LD_INT 3
17890: PUSH
17891: LD_INT 49
17893: PUSH
17894: EMPTY
17895: LIST
17896: LIST
17897: LIST
17898: LIST
17899: PUSH
17900: LD_INT 24
17902: PUSH
17903: LD_INT 3
17905: PUSH
17906: LD_INT 3
17908: PUSH
17909: LD_INT 46
17911: PUSH
17912: EMPTY
17913: LIST
17914: LIST
17915: LIST
17916: LIST
17917: PUSH
17918: LD_INT 24
17920: PUSH
17921: LD_INT 3
17923: PUSH
17924: LD_INT 3
17926: PUSH
17927: LD_INT 46
17929: PUSH
17930: EMPTY
17931: LIST
17932: LIST
17933: LIST
17934: LIST
17935: PUSH
17936: LD_INT 24
17938: PUSH
17939: LD_INT 3
17941: PUSH
17942: LD_INT 3
17944: PUSH
17945: LD_INT 46
17947: PUSH
17948: EMPTY
17949: LIST
17950: LIST
17951: LIST
17952: LIST
17953: PUSH
17954: EMPTY
17955: LIST
17956: LIST
17957: LIST
17958: LIST
17959: LIST
17960: LIST
17961: PPUSH
17962: CALL 85528 0 2
// end else
17966: GO 18093
// begin MC_InsertProduceList ( base , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
17968: LD_VAR 0 2
17972: PPUSH
17973: LD_INT 24
17975: PUSH
17976: LD_INT 3
17978: PUSH
17979: LD_INT 3
17981: PUSH
17982: LD_INT 47
17984: PUSH
17985: EMPTY
17986: LIST
17987: LIST
17988: LIST
17989: LIST
17990: PUSH
17991: LD_INT 24
17993: PUSH
17994: LD_INT 3
17996: PUSH
17997: LD_INT 3
17999: PUSH
18000: LD_INT 47
18002: PUSH
18003: EMPTY
18004: LIST
18005: LIST
18006: LIST
18007: LIST
18008: PUSH
18009: LD_INT 24
18011: PUSH
18012: LD_INT 3
18014: PUSH
18015: LD_INT 3
18017: PUSH
18018: LD_INT 47
18020: PUSH
18021: EMPTY
18022: LIST
18023: LIST
18024: LIST
18025: LIST
18026: PUSH
18027: LD_INT 24
18029: PUSH
18030: LD_INT 3
18032: PUSH
18033: LD_INT 3
18035: PUSH
18036: LD_INT 46
18038: PUSH
18039: EMPTY
18040: LIST
18041: LIST
18042: LIST
18043: LIST
18044: PUSH
18045: LD_INT 24
18047: PUSH
18048: LD_INT 3
18050: PUSH
18051: LD_INT 3
18053: PUSH
18054: LD_INT 46
18056: PUSH
18057: EMPTY
18058: LIST
18059: LIST
18060: LIST
18061: LIST
18062: PUSH
18063: LD_INT 24
18065: PUSH
18066: LD_INT 3
18068: PUSH
18069: LD_INT 3
18071: PUSH
18072: LD_INT 46
18074: PUSH
18075: EMPTY
18076: LIST
18077: LIST
18078: LIST
18079: LIST
18080: PUSH
18081: EMPTY
18082: LIST
18083: LIST
18084: LIST
18085: LIST
18086: LIST
18087: LIST
18088: PPUSH
18089: CALL 85528 0 2
// end ; if Difficulty > 1 then
18093: LD_OWVAR 67
18097: PUSH
18098: LD_INT 1
18100: GREATER
18101: IFFALSE 18133
// MC_InsertProduceList ( base , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
18103: LD_VAR 0 2
18107: PPUSH
18108: LD_INT 24
18110: PUSH
18111: LD_INT 3
18113: PUSH
18114: LD_INT 3
18116: PUSH
18117: LD_INT 47
18119: PUSH
18120: EMPTY
18121: LIST
18122: LIST
18123: LIST
18124: LIST
18125: PUSH
18126: EMPTY
18127: LIST
18128: PPUSH
18129: CALL 85528 0 2
// repeat wait ( 0 0$1 ) ;
18133: LD_INT 35
18135: PPUSH
18136: CALL_OW 67
// until MC_GetVehicles ( base , true ) >= [ 6 , 7 , 7 ] [ Difficulty ] or tick mod 10 10$00 = 0 ;
18140: LD_VAR 0 2
18144: PPUSH
18145: LD_INT 1
18147: PPUSH
18148: CALL 86946 0 2
18152: PUSH
18153: LD_INT 6
18155: PUSH
18156: LD_INT 7
18158: PUSH
18159: LD_INT 7
18161: PUSH
18162: EMPTY
18163: LIST
18164: LIST
18165: LIST
18166: PUSH
18167: LD_OWVAR 67
18171: ARRAY
18172: GREATEREQUAL
18173: PUSH
18174: LD_OWVAR 1
18178: PUSH
18179: LD_INT 21000
18181: MOD
18182: PUSH
18183: LD_INT 0
18185: EQUAL
18186: OR
18187: IFFALSE 18133
// wait ( 0 0$45 ) ;
18189: LD_INT 1575
18191: PPUSH
18192: CALL_OW 67
// tmp := MC_GetVehicles ( base , true ) ;
18196: LD_ADDR_VAR 0 3
18200: PUSH
18201: LD_VAR 0 2
18205: PPUSH
18206: LD_INT 1
18208: PPUSH
18209: CALL 86946 0 2
18213: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , mc_vehicles [ base ] diff tmp ) ;
18214: LD_ADDR_EXP 50
18218: PUSH
18219: LD_EXP 50
18223: PPUSH
18224: LD_VAR 0 2
18228: PPUSH
18229: LD_EXP 50
18233: PUSH
18234: LD_VAR 0 2
18238: ARRAY
18239: PUSH
18240: LD_VAR 0 3
18244: DIFF
18245: PPUSH
18246: CALL_OW 1
18250: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
18251: LD_ADDR_VAR 0 4
18255: PUSH
18256: LD_INT 0
18258: PPUSH
18259: LD_INT 1
18261: PPUSH
18262: CALL_OW 12
18266: ST_TO_ADDR
// if target then
18267: LD_VAR 0 4
18271: IFFALSE 18399
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
18273: LD_ADDR_VAR 0 3
18277: PUSH
18278: LD_VAR 0 3
18282: PPUSH
18283: LD_INT 24
18285: PUSH
18286: LD_INT 250
18288: PUSH
18289: EMPTY
18290: LIST
18291: LIST
18292: PPUSH
18293: CALL_OW 72
18297: ST_TO_ADDR
// for i in tmp do
18298: LD_ADDR_VAR 0 1
18302: PUSH
18303: LD_VAR 0 3
18307: PUSH
18308: FOR_IN
18309: IFFALSE 18349
// if GetDistUnitXY ( i , 84 , 32 ) > 9 then
18311: LD_VAR 0 1
18315: PPUSH
18316: LD_INT 84
18318: PPUSH
18319: LD_INT 32
18321: PPUSH
18322: CALL_OW 297
18326: PUSH
18327: LD_INT 9
18329: GREATER
18330: IFFALSE 18347
// ComMoveXY ( i , 84 , 32 ) ;
18332: LD_VAR 0 1
18336: PPUSH
18337: LD_INT 84
18339: PPUSH
18340: LD_INT 32
18342: PPUSH
18343: CALL_OW 111
18347: GO 18308
18349: POP
18350: POP
// wait ( 0 0$1 ) ;
18351: LD_INT 35
18353: PPUSH
18354: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 84 , 32 , 9 ] ) >= ( tmp - 1 ) ;
18358: LD_VAR 0 3
18362: PPUSH
18363: LD_INT 92
18365: PUSH
18366: LD_INT 84
18368: PUSH
18369: LD_INT 32
18371: PUSH
18372: LD_INT 9
18374: PUSH
18375: EMPTY
18376: LIST
18377: LIST
18378: LIST
18379: LIST
18380: PPUSH
18381: CALL_OW 72
18385: PUSH
18386: LD_VAR 0 3
18390: PUSH
18391: LD_INT 1
18393: MINUS
18394: GREATEREQUAL
18395: IFFALSE 18273
// end else
18397: GO 18559
// begin if teleport then
18399: LD_VAR 0 5
18403: IFFALSE 18423
// ComEnterUnit ( tmp , teleport [ 1 ] ) ;
18405: LD_VAR 0 3
18409: PPUSH
18410: LD_VAR 0 5
18414: PUSH
18415: LD_INT 1
18417: ARRAY
18418: PPUSH
18419: CALL_OW 120
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
18423: LD_ADDR_VAR 0 3
18427: PUSH
18428: LD_VAR 0 3
18432: PPUSH
18433: LD_INT 24
18435: PUSH
18436: LD_INT 250
18438: PUSH
18439: EMPTY
18440: LIST
18441: LIST
18442: PPUSH
18443: CALL_OW 72
18447: ST_TO_ADDR
// for i in tmp do
18448: LD_ADDR_VAR 0 1
18452: PUSH
18453: LD_VAR 0 3
18457: PUSH
18458: FOR_IN
18459: IFFALSE 18511
// if GetDistUnitXY ( i , 140 , 219 ) > 9 and not HasTask ( i ) then
18461: LD_VAR 0 1
18465: PPUSH
18466: LD_INT 140
18468: PPUSH
18469: LD_INT 219
18471: PPUSH
18472: CALL_OW 297
18476: PUSH
18477: LD_INT 9
18479: GREATER
18480: PUSH
18481: LD_VAR 0 1
18485: PPUSH
18486: CALL_OW 314
18490: NOT
18491: AND
18492: IFFALSE 18509
// AddComMoveXY ( i , 140 , 219 ) ;
18494: LD_VAR 0 1
18498: PPUSH
18499: LD_INT 140
18501: PPUSH
18502: LD_INT 219
18504: PPUSH
18505: CALL_OW 171
18509: GO 18458
18511: POP
18512: POP
// wait ( 0 0$1 ) ;
18513: LD_INT 35
18515: PPUSH
18516: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 140 , 219 , 9 ] ) >= ( tmp - 1 ) ;
18520: LD_VAR 0 3
18524: PPUSH
18525: LD_INT 92
18527: PUSH
18528: LD_INT 140
18530: PUSH
18531: LD_INT 219
18533: PUSH
18534: LD_INT 9
18536: PUSH
18537: EMPTY
18538: LIST
18539: LIST
18540: LIST
18541: LIST
18542: PPUSH
18543: CALL_OW 72
18547: PUSH
18548: LD_VAR 0 3
18552: PUSH
18553: LD_INT 1
18555: MINUS
18556: GREATEREQUAL
18557: IFFALSE 18423
// end ; repeat wait ( 0 0$1 ) ;
18559: LD_INT 35
18561: PPUSH
18562: CALL_OW 67
// for i in tmp do
18566: LD_ADDR_VAR 0 1
18570: PUSH
18571: LD_VAR 0 3
18575: PUSH
18576: FOR_IN
18577: IFFALSE 18710
// begin if GetLives ( i ) > 251 then
18579: LD_VAR 0 1
18583: PPUSH
18584: CALL_OW 256
18588: PUSH
18589: LD_INT 251
18591: GREATER
18592: IFFALSE 18681
// begin if GetWeapon ( i ) = ru_time_lapser then
18594: LD_VAR 0 1
18598: PPUSH
18599: CALL_OW 264
18603: PUSH
18604: LD_INT 49
18606: EQUAL
18607: IFFALSE 18645
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) else
18609: LD_VAR 0 1
18613: PPUSH
18614: LD_INT 81
18616: PUSH
18617: LD_INT 3
18619: PUSH
18620: EMPTY
18621: LIST
18622: LIST
18623: PPUSH
18624: CALL_OW 69
18628: PPUSH
18629: LD_VAR 0 1
18633: PPUSH
18634: CALL_OW 74
18638: PPUSH
18639: CALL_OW 112
18643: GO 18679
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
18645: LD_VAR 0 1
18649: PPUSH
18650: LD_INT 81
18652: PUSH
18653: LD_INT 3
18655: PUSH
18656: EMPTY
18657: LIST
18658: LIST
18659: PPUSH
18660: CALL_OW 69
18664: PPUSH
18665: LD_VAR 0 1
18669: PPUSH
18670: CALL_OW 74
18674: PPUSH
18675: CALL_OW 115
// end else
18679: GO 18708
// if IsDead ( i ) then
18681: LD_VAR 0 1
18685: PPUSH
18686: CALL_OW 301
18690: IFFALSE 18708
// tmp := tmp diff i ;
18692: LD_ADDR_VAR 0 3
18696: PUSH
18697: LD_VAR 0 3
18701: PUSH
18702: LD_VAR 0 1
18706: DIFF
18707: ST_TO_ADDR
// end ;
18708: GO 18576
18710: POP
18711: POP
// until not tmp ;
18712: LD_VAR 0 3
18716: NOT
18717: IFFALSE 18559
// end ;
18719: PPOPN 5
18721: END
// every 12 12$30 + 11 11$30 trigger game do var i , base , tmp , target ;
18722: LD_EXP 3
18726: IFFALSE 19108
18728: GO 18730
18730: DISABLE
18731: LD_INT 0
18733: PPUSH
18734: PPUSH
18735: PPUSH
18736: PPUSH
// begin enable ;
18737: ENABLE
// base := mc_amer ;
18738: LD_ADDR_VAR 0 2
18742: PUSH
18743: LD_EXP 5
18747: ST_TO_ADDR
// if not FilterAllUnits ( [ [ f_side , 4 ] , [ f_nation , 1 ] , [ f_btype , b_factory ] ] ) then
18748: LD_INT 22
18750: PUSH
18751: LD_INT 4
18753: PUSH
18754: EMPTY
18755: LIST
18756: LIST
18757: PUSH
18758: LD_INT 23
18760: PUSH
18761: LD_INT 1
18763: PUSH
18764: EMPTY
18765: LIST
18766: LIST
18767: PUSH
18768: LD_INT 30
18770: PUSH
18771: LD_INT 3
18773: PUSH
18774: EMPTY
18775: LIST
18776: LIST
18777: PUSH
18778: EMPTY
18779: LIST
18780: LIST
18781: LIST
18782: PPUSH
18783: CALL_OW 69
18787: NOT
18788: IFFALSE 18792
// exit ;
18790: GO 19108
// MC_InsertProduceList ( base , [ [ us_medium_tracked , engine_combustion , control_remote , us_double_gun ] , [ us_medium_tracked , engine_combustion , control_remote , us_laser ] , [ us_medium_tracked , engine_combustion , control_remote , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_remote , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_remote , us_rocket_launcher ] ] ) ;
18792: LD_VAR 0 2
18796: PPUSH
18797: LD_INT 3
18799: PUSH
18800: LD_INT 1
18802: PUSH
18803: LD_INT 2
18805: PUSH
18806: LD_INT 5
18808: PUSH
18809: EMPTY
18810: LIST
18811: LIST
18812: LIST
18813: LIST
18814: PUSH
18815: LD_INT 3
18817: PUSH
18818: LD_INT 1
18820: PUSH
18821: LD_INT 2
18823: PUSH
18824: LD_INT 9
18826: PUSH
18827: EMPTY
18828: LIST
18829: LIST
18830: LIST
18831: LIST
18832: PUSH
18833: LD_INT 3
18835: PUSH
18836: LD_INT 1
18838: PUSH
18839: LD_INT 2
18841: PUSH
18842: LD_INT 7
18844: PUSH
18845: EMPTY
18846: LIST
18847: LIST
18848: LIST
18849: LIST
18850: PUSH
18851: LD_INT 3
18853: PUSH
18854: LD_INT 1
18856: PUSH
18857: LD_INT 2
18859: PUSH
18860: LD_INT 7
18862: PUSH
18863: EMPTY
18864: LIST
18865: LIST
18866: LIST
18867: LIST
18868: PUSH
18869: LD_INT 3
18871: PUSH
18872: LD_INT 1
18874: PUSH
18875: LD_INT 2
18877: PUSH
18878: LD_INT 7
18880: PUSH
18881: EMPTY
18882: LIST
18883: LIST
18884: LIST
18885: LIST
18886: PUSH
18887: EMPTY
18888: LIST
18889: LIST
18890: LIST
18891: LIST
18892: LIST
18893: PPUSH
18894: CALL 85528 0 2
// repeat wait ( 0 0$1 ) ;
18898: LD_INT 35
18900: PPUSH
18901: CALL_OW 67
// until MC_GetVehicles ( base , true ) >= 5 or tick mod 10 10$00 = 0 ;
18905: LD_VAR 0 2
18909: PPUSH
18910: LD_INT 1
18912: PPUSH
18913: CALL 86946 0 2
18917: PUSH
18918: LD_INT 5
18920: GREATEREQUAL
18921: PUSH
18922: LD_OWVAR 1
18926: PUSH
18927: LD_INT 21000
18929: MOD
18930: PUSH
18931: LD_INT 0
18933: EQUAL
18934: OR
18935: IFFALSE 18898
// wait ( 0 0$30 ) ;
18937: LD_INT 1050
18939: PPUSH
18940: CALL_OW 67
// tmp := MC_GetVehicles ( base , true ) ;
18944: LD_ADDR_VAR 0 3
18948: PUSH
18949: LD_VAR 0 2
18953: PPUSH
18954: LD_INT 1
18956: PPUSH
18957: CALL 86946 0 2
18961: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , mc_vehicles [ base ] diff tmp ) ;
18962: LD_ADDR_EXP 50
18966: PUSH
18967: LD_EXP 50
18971: PPUSH
18972: LD_VAR 0 2
18976: PPUSH
18977: LD_EXP 50
18981: PUSH
18982: LD_VAR 0 2
18986: ARRAY
18987: PUSH
18988: LD_VAR 0 3
18992: DIFF
18993: PPUSH
18994: CALL_OW 1
18998: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
18999: LD_INT 35
19001: PPUSH
19002: CALL_OW 67
// for i in tmp do
19006: LD_ADDR_VAR 0 1
19010: PUSH
19011: LD_VAR 0 3
19015: PUSH
19016: FOR_IN
19017: IFFALSE 19099
// begin if GetLives ( i ) > 251 then
19019: LD_VAR 0 1
19023: PPUSH
19024: CALL_OW 256
19028: PUSH
19029: LD_INT 251
19031: GREATER
19032: IFFALSE 19070
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 4 ] ) , i ) ) else
19034: LD_VAR 0 1
19038: PPUSH
19039: LD_INT 81
19041: PUSH
19042: LD_INT 4
19044: PUSH
19045: EMPTY
19046: LIST
19047: LIST
19048: PPUSH
19049: CALL_OW 69
19053: PPUSH
19054: LD_VAR 0 1
19058: PPUSH
19059: CALL_OW 74
19063: PPUSH
19064: CALL_OW 115
19068: GO 19097
// if IsDead ( i ) then
19070: LD_VAR 0 1
19074: PPUSH
19075: CALL_OW 301
19079: IFFALSE 19097
// tmp := tmp diff i ;
19081: LD_ADDR_VAR 0 3
19085: PUSH
19086: LD_VAR 0 3
19090: PUSH
19091: LD_VAR 0 1
19095: DIFF
19096: ST_TO_ADDR
// end ;
19097: GO 19016
19099: POP
19100: POP
// until not tmp ;
19101: LD_VAR 0 3
19105: NOT
19106: IFFALSE 18999
// end ; end_of_file
19108: PPOPN 4
19110: END
// export function CustomEvent ( event ) ; begin
19111: LD_INT 0
19113: PPUSH
// end ;
19114: LD_VAR 0 2
19118: RET
// on Contact ( s1 , s2 ) do begin if s1 = 1 and s2 = 4 then
19119: LD_VAR 0 1
19123: PUSH
19124: LD_INT 1
19126: EQUAL
19127: PUSH
19128: LD_VAR 0 2
19132: PUSH
19133: LD_INT 4
19135: EQUAL
19136: AND
19137: IFFALSE 19165
// begin SayRadio ( Powell , DP-Lost ) ;
19139: LD_EXP 12
19143: PPUSH
19144: LD_STRING DP-Lost
19146: PPUSH
19147: CALL_OW 94
// wait ( 0 0$2 ) ;
19151: LD_INT 70
19153: PPUSH
19154: CALL_OW 67
// YouLost ( FriendlyFire ) ;
19158: LD_STRING FriendlyFire
19160: PPUSH
19161: CALL_OW 104
// end ; end ;
19165: PPOPN 2
19167: END
// on UnitDestroyed ( un ) do begin SOS_UnitDestroyed ( un ) ;
19168: LD_VAR 0 1
19172: PPUSH
19173: CALL 107565 0 1
// if GameType = 1 then
19177: LD_EXP 2
19181: PUSH
19182: LD_INT 1
19184: EQUAL
19185: IFFALSE 19420
// begin if un = playerCommander then
19187: LD_VAR 0 1
19191: PUSH
19192: LD_EXP 9
19196: EQUAL
19197: IFFALSE 19206
// YouLost ( commanderDied ) ;
19199: LD_STRING commanderDied
19201: PPUSH
19202: CALL_OW 104
// if un = allyCommander then
19206: LD_VAR 0 1
19210: PUSH
19211: LD_EXP 11
19215: EQUAL
19216: IFFALSE 19225
// YouLost ( Theta ) ;
19218: LD_STRING Theta
19220: PPUSH
19221: CALL_OW 104
// if un in FilterAllUnits ( [ [ f_side , 8 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_building ] ] ] ) then
19225: LD_VAR 0 1
19229: PUSH
19230: LD_INT 22
19232: PUSH
19233: LD_INT 8
19235: PUSH
19236: EMPTY
19237: LIST
19238: LIST
19239: PUSH
19240: LD_INT 2
19242: PUSH
19243: LD_INT 21
19245: PUSH
19246: LD_INT 1
19248: PUSH
19249: EMPTY
19250: LIST
19251: LIST
19252: PUSH
19253: LD_INT 21
19255: PUSH
19256: LD_INT 3
19258: PUSH
19259: EMPTY
19260: LIST
19261: LIST
19262: PUSH
19263: EMPTY
19264: LIST
19265: LIST
19266: LIST
19267: PUSH
19268: EMPTY
19269: LIST
19270: LIST
19271: PPUSH
19272: CALL_OW 69
19276: IN
19277: IFFALSE 19293
// legDestCounter := legDestCounter + 1 ;
19279: LD_ADDR_EXP 18
19283: PUSH
19284: LD_EXP 18
19288: PUSH
19289: LD_INT 1
19291: PLUS
19292: ST_TO_ADDR
// if un in FilterAllUnits ( [ [ f_side , 4 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_building ] ] ] ) then
19293: LD_VAR 0 1
19297: PUSH
19298: LD_INT 22
19300: PUSH
19301: LD_INT 4
19303: PUSH
19304: EMPTY
19305: LIST
19306: LIST
19307: PUSH
19308: LD_INT 2
19310: PUSH
19311: LD_INT 21
19313: PUSH
19314: LD_INT 1
19316: PUSH
19317: EMPTY
19318: LIST
19319: LIST
19320: PUSH
19321: LD_INT 21
19323: PUSH
19324: LD_INT 3
19326: PUSH
19327: EMPTY
19328: LIST
19329: LIST
19330: PUSH
19331: EMPTY
19332: LIST
19333: LIST
19334: LIST
19335: PUSH
19336: EMPTY
19337: LIST
19338: LIST
19339: PPUSH
19340: CALL_OW 69
19344: IN
19345: IFFALSE 19361
// allyDestCounter := allyDestCounter + 1 ;
19347: LD_ADDR_EXP 22
19351: PUSH
19352: LD_EXP 22
19356: PUSH
19357: LD_INT 1
19359: PLUS
19360: ST_TO_ADDR
// if un in ruOutpost then
19361: LD_VAR 0 1
19365: PUSH
19366: LD_EXP 14
19370: IN
19371: IFFALSE 19420
// begin ruOutpost := ruOutpost diff un ;
19373: LD_ADDR_EXP 14
19377: PUSH
19378: LD_EXP 14
19382: PUSH
19383: LD_VAR 0 1
19387: DIFF
19388: ST_TO_ADDR
// ruEscape := Replace ( ruEscape , 1 , ruEscape [ 1 ] + 1 ) ;
19389: LD_ADDR_EXP 15
19393: PUSH
19394: LD_EXP 15
19398: PPUSH
19399: LD_INT 1
19401: PPUSH
19402: LD_EXP 15
19406: PUSH
19407: LD_INT 1
19409: ARRAY
19410: PUSH
19411: LD_INT 1
19413: PLUS
19414: PPUSH
19415: CALL_OW 1
19419: ST_TO_ADDR
// end ; end ; MCE_UnitDestroyed ( un ) ;
19420: LD_VAR 0 1
19424: PPUSH
19425: CALL 88932 0 1
// end ;
19429: PPOPN 1
19431: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
19432: LD_VAR 0 1
19436: PPUSH
19437: LD_VAR 0 2
19441: PPUSH
19442: CALL 91264 0 2
// end ;
19446: PPOPN 2
19448: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
19449: LD_VAR 0 1
19453: PPUSH
19454: CALL 90332 0 1
// end ;
19458: PPOPN 1
19460: END
// on BuildingComplete ( building ) do begin MCE_BuildingComplete ( building ) ;
19461: LD_VAR 0 1
19465: PPUSH
19466: CALL 90573 0 1
// end ;
19470: PPOPN 1
19472: END
// on ResearchComplete ( tech , lab ) do begin if tech = tech_LasDouble and GetSide ( lab ) = 1 then
19473: LD_VAR 0 1
19477: PUSH
19478: LD_INT 14
19480: EQUAL
19481: PUSH
19482: LD_VAR 0 2
19486: PPUSH
19487: CALL_OW 255
19491: PUSH
19492: LD_INT 1
19494: EQUAL
19495: AND
19496: IFFALSE 19537
// begin Say ( playerCommander , D & [ I , J , S ] [ commander ] & -1-Laser ) ;
19498: LD_EXP 9
19502: PPUSH
19503: LD_STRING D
19505: PUSH
19506: LD_STRING I
19508: PUSH
19509: LD_STRING J
19511: PUSH
19512: LD_STRING S
19514: PUSH
19515: EMPTY
19516: LIST
19517: LIST
19518: LIST
19519: PUSH
19520: LD_EXP 25
19524: ARRAY
19525: STR
19526: PUSH
19527: LD_STRING -1-Laser
19529: STR
19530: PPUSH
19531: CALL_OW 88
// exit ;
19535: GO 19679
// end ; if tech = tech_MatDet and GetSide ( lab ) = 1 then
19537: LD_VAR 0 1
19541: PUSH
19542: LD_INT 7
19544: EQUAL
19545: PUSH
19546: LD_VAR 0 2
19550: PPUSH
19551: CALL_OW 255
19555: PUSH
19556: LD_INT 1
19558: EQUAL
19559: AND
19560: IFFALSE 19601
// begin Say ( playerCommander , D & [ I , J , S ] [ commander ] & -1-Materialization ) ;
19562: LD_EXP 9
19566: PPUSH
19567: LD_STRING D
19569: PUSH
19570: LD_STRING I
19572: PUSH
19573: LD_STRING J
19575: PUSH
19576: LD_STRING S
19578: PUSH
19579: EMPTY
19580: LIST
19581: LIST
19582: LIST
19583: PUSH
19584: LD_EXP 25
19588: ARRAY
19589: STR
19590: PUSH
19591: LD_STRING -1-Materialization
19593: STR
19594: PPUSH
19595: CALL_OW 88
// exit ;
19599: GO 19679
// end ; if tech = tech_SibFiss and GetSide ( lab ) = 1 then
19601: LD_VAR 0 1
19605: PUSH
19606: LD_INT 25
19608: EQUAL
19609: PUSH
19610: LD_VAR 0 2
19614: PPUSH
19615: CALL_OW 255
19619: PUSH
19620: LD_INT 1
19622: EQUAL
19623: AND
19624: IFFALSE 19665
// begin Say ( playerCommander , D & [ I , J , S ] [ commander ] & -1-Rocket ) ;
19626: LD_EXP 9
19630: PPUSH
19631: LD_STRING D
19633: PUSH
19634: LD_STRING I
19636: PUSH
19637: LD_STRING J
19639: PUSH
19640: LD_STRING S
19642: PUSH
19643: EMPTY
19644: LIST
19645: LIST
19646: LIST
19647: PUSH
19648: LD_EXP 25
19652: ARRAY
19653: STR
19654: PUSH
19655: LD_STRING -1-Rocket
19657: STR
19658: PPUSH
19659: CALL_OW 88
// exit ;
19663: GO 19679
// end ; MCE_ResearchComplete ( tech , lab ) ;
19665: LD_VAR 0 1
19669: PPUSH
19670: LD_VAR 0 2
19674: PPUSH
19675: CALL 88628 0 2
// end ;
19679: PPOPN 2
19681: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
19682: LD_VAR 0 1
19686: PPUSH
19687: LD_VAR 0 2
19691: PPUSH
19692: LD_VAR 0 3
19696: PPUSH
19697: LD_VAR 0 4
19701: PPUSH
19702: LD_VAR 0 5
19706: PPUSH
19707: CALL 88248 0 5
// end ;
19711: PPOPN 5
19713: END
// on VehicleConstructed ( vehicle , factory ) do begin SOS_VehicleConstructed ( vehicle , factory ) ;
19714: LD_VAR 0 1
19718: PPUSH
19719: LD_VAR 0 2
19723: PPUSH
19724: CALL 107685 0 2
// MCE_VehicleConstructed ( vehicle , factory ) ;
19728: LD_VAR 0 1
19732: PPUSH
19733: LD_VAR 0 2
19737: PPUSH
19738: CALL 87839 0 2
// end ;
19742: PPOPN 2
19744: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
19745: LD_VAR 0 1
19749: PPUSH
19750: LD_VAR 0 2
19754: PPUSH
19755: LD_VAR 0 3
19759: PPUSH
19760: LD_VAR 0 4
19764: PPUSH
19765: CALL 87677 0 4
// end ;
19769: PPOPN 4
19771: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
19772: LD_VAR 0 1
19776: PPUSH
19777: LD_VAR 0 2
19781: PPUSH
19782: LD_VAR 0 3
19786: PPUSH
19787: CALL 87452 0 3
// end ;
19791: PPOPN 3
19793: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
19794: LD_VAR 0 1
19798: PPUSH
19799: LD_VAR 0 2
19803: PPUSH
19804: CALL 87337 0 2
// end ;
19808: PPOPN 2
19810: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
19811: LD_VAR 0 1
19815: PPUSH
19816: LD_VAR 0 2
19820: PPUSH
19821: CALL 91559 0 2
// end ;
19825: PPOPN 2
19827: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
19828: LD_VAR 0 1
19832: PPUSH
19833: LD_VAR 0 2
19837: PPUSH
19838: LD_VAR 0 3
19842: PPUSH
19843: LD_VAR 0 4
19847: PPUSH
19848: CALL 91775 0 4
// end ;
19852: PPOPN 4
19854: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
19855: LD_VAR 0 1
19859: PPUSH
19860: LD_VAR 0 2
19864: PPUSH
19865: CALL 87146 0 2
// end ;
19869: PPOPN 2
19871: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
19872: LD_VAR 0 1
19876: PPUSH
19877: CALL 107669 0 1
// end ; end_of_file
19881: PPOPN 1
19883: END
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
19884: LD_INT 0
19886: PPUSH
19887: PPUSH
// if exist_mode then
19888: LD_VAR 0 2
19892: IFFALSE 19917
// unit := CreateCharacter ( prefix & ident ) else
19894: LD_ADDR_VAR 0 5
19898: PUSH
19899: LD_VAR 0 3
19903: PUSH
19904: LD_VAR 0 1
19908: STR
19909: PPUSH
19910: CALL_OW 34
19914: ST_TO_ADDR
19915: GO 19932
// unit := NewCharacter ( ident ) ;
19917: LD_ADDR_VAR 0 5
19921: PUSH
19922: LD_VAR 0 1
19926: PPUSH
19927: CALL_OW 25
19931: ST_TO_ADDR
// result := unit ;
19932: LD_ADDR_VAR 0 4
19936: PUSH
19937: LD_VAR 0 5
19941: ST_TO_ADDR
// end ;
19942: LD_VAR 0 4
19946: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
19947: LD_INT 0
19949: PPUSH
19950: PPUSH
// if not side or not nation then
19951: LD_VAR 0 1
19955: NOT
19956: PUSH
19957: LD_VAR 0 2
19961: NOT
19962: OR
19963: IFFALSE 19967
// exit ;
19965: GO 20735
// case nation of nation_american :
19967: LD_VAR 0 2
19971: PUSH
19972: LD_INT 1
19974: DOUBLE
19975: EQUAL
19976: IFTRUE 19980
19978: GO 20194
19980: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
19981: LD_ADDR_VAR 0 4
19985: PUSH
19986: LD_INT 35
19988: PUSH
19989: LD_INT 45
19991: PUSH
19992: LD_INT 46
19994: PUSH
19995: LD_INT 47
19997: PUSH
19998: LD_INT 82
20000: PUSH
20001: LD_INT 83
20003: PUSH
20004: LD_INT 84
20006: PUSH
20007: LD_INT 85
20009: PUSH
20010: LD_INT 86
20012: PUSH
20013: LD_INT 1
20015: PUSH
20016: LD_INT 2
20018: PUSH
20019: LD_INT 6
20021: PUSH
20022: LD_INT 15
20024: PUSH
20025: LD_INT 16
20027: PUSH
20028: LD_INT 7
20030: PUSH
20031: LD_INT 12
20033: PUSH
20034: LD_INT 13
20036: PUSH
20037: LD_INT 10
20039: PUSH
20040: LD_INT 14
20042: PUSH
20043: LD_INT 20
20045: PUSH
20046: LD_INT 21
20048: PUSH
20049: LD_INT 22
20051: PUSH
20052: LD_INT 25
20054: PUSH
20055: LD_INT 32
20057: PUSH
20058: LD_INT 27
20060: PUSH
20061: LD_INT 36
20063: PUSH
20064: LD_INT 69
20066: PUSH
20067: LD_INT 39
20069: PUSH
20070: LD_INT 34
20072: PUSH
20073: LD_INT 40
20075: PUSH
20076: LD_INT 48
20078: PUSH
20079: LD_INT 49
20081: PUSH
20082: LD_INT 50
20084: PUSH
20085: LD_INT 51
20087: PUSH
20088: LD_INT 52
20090: PUSH
20091: LD_INT 53
20093: PUSH
20094: LD_INT 54
20096: PUSH
20097: LD_INT 55
20099: PUSH
20100: LD_INT 56
20102: PUSH
20103: LD_INT 57
20105: PUSH
20106: LD_INT 58
20108: PUSH
20109: LD_INT 59
20111: PUSH
20112: LD_INT 60
20114: PUSH
20115: LD_INT 61
20117: PUSH
20118: LD_INT 62
20120: PUSH
20121: LD_INT 80
20123: PUSH
20124: LD_INT 82
20126: PUSH
20127: LD_INT 83
20129: PUSH
20130: LD_INT 84
20132: PUSH
20133: LD_INT 85
20135: PUSH
20136: LD_INT 86
20138: PUSH
20139: EMPTY
20140: LIST
20141: LIST
20142: LIST
20143: LIST
20144: LIST
20145: LIST
20146: LIST
20147: LIST
20148: LIST
20149: LIST
20150: LIST
20151: LIST
20152: LIST
20153: LIST
20154: LIST
20155: LIST
20156: LIST
20157: LIST
20158: LIST
20159: LIST
20160: LIST
20161: LIST
20162: LIST
20163: LIST
20164: LIST
20165: LIST
20166: LIST
20167: LIST
20168: LIST
20169: LIST
20170: LIST
20171: LIST
20172: LIST
20173: LIST
20174: LIST
20175: LIST
20176: LIST
20177: LIST
20178: LIST
20179: LIST
20180: LIST
20181: LIST
20182: LIST
20183: LIST
20184: LIST
20185: LIST
20186: LIST
20187: LIST
20188: LIST
20189: LIST
20190: LIST
20191: ST_TO_ADDR
20192: GO 20659
20194: LD_INT 2
20196: DOUBLE
20197: EQUAL
20198: IFTRUE 20202
20200: GO 20428
20202: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 ] ; nation_russian :
20203: LD_ADDR_VAR 0 4
20207: PUSH
20208: LD_INT 35
20210: PUSH
20211: LD_INT 45
20213: PUSH
20214: LD_INT 46
20216: PUSH
20217: LD_INT 47
20219: PUSH
20220: LD_INT 82
20222: PUSH
20223: LD_INT 83
20225: PUSH
20226: LD_INT 84
20228: PUSH
20229: LD_INT 85
20231: PUSH
20232: LD_INT 87
20234: PUSH
20235: LD_INT 70
20237: PUSH
20238: LD_INT 1
20240: PUSH
20241: LD_INT 11
20243: PUSH
20244: LD_INT 3
20246: PUSH
20247: LD_INT 4
20249: PUSH
20250: LD_INT 5
20252: PUSH
20253: LD_INT 6
20255: PUSH
20256: LD_INT 15
20258: PUSH
20259: LD_INT 18
20261: PUSH
20262: LD_INT 7
20264: PUSH
20265: LD_INT 17
20267: PUSH
20268: LD_INT 8
20270: PUSH
20271: LD_INT 20
20273: PUSH
20274: LD_INT 21
20276: PUSH
20277: LD_INT 22
20279: PUSH
20280: LD_INT 72
20282: PUSH
20283: LD_INT 26
20285: PUSH
20286: LD_INT 69
20288: PUSH
20289: LD_INT 39
20291: PUSH
20292: LD_INT 40
20294: PUSH
20295: LD_INT 41
20297: PUSH
20298: LD_INT 42
20300: PUSH
20301: LD_INT 43
20303: PUSH
20304: LD_INT 48
20306: PUSH
20307: LD_INT 49
20309: PUSH
20310: LD_INT 50
20312: PUSH
20313: LD_INT 51
20315: PUSH
20316: LD_INT 52
20318: PUSH
20319: LD_INT 53
20321: PUSH
20322: LD_INT 54
20324: PUSH
20325: LD_INT 55
20327: PUSH
20328: LD_INT 56
20330: PUSH
20331: LD_INT 60
20333: PUSH
20334: LD_INT 61
20336: PUSH
20337: LD_INT 62
20339: PUSH
20340: LD_INT 66
20342: PUSH
20343: LD_INT 67
20345: PUSH
20346: LD_INT 68
20348: PUSH
20349: LD_INT 81
20351: PUSH
20352: LD_INT 82
20354: PUSH
20355: LD_INT 83
20357: PUSH
20358: LD_INT 84
20360: PUSH
20361: LD_INT 85
20363: PUSH
20364: LD_INT 87
20366: PUSH
20367: LD_INT 88
20369: PUSH
20370: EMPTY
20371: LIST
20372: LIST
20373: LIST
20374: LIST
20375: LIST
20376: LIST
20377: LIST
20378: LIST
20379: LIST
20380: LIST
20381: LIST
20382: LIST
20383: LIST
20384: LIST
20385: LIST
20386: LIST
20387: LIST
20388: LIST
20389: LIST
20390: LIST
20391: LIST
20392: LIST
20393: LIST
20394: LIST
20395: LIST
20396: LIST
20397: LIST
20398: LIST
20399: LIST
20400: LIST
20401: LIST
20402: LIST
20403: LIST
20404: LIST
20405: LIST
20406: LIST
20407: LIST
20408: LIST
20409: LIST
20410: LIST
20411: LIST
20412: LIST
20413: LIST
20414: LIST
20415: LIST
20416: LIST
20417: LIST
20418: LIST
20419: LIST
20420: LIST
20421: LIST
20422: LIST
20423: LIST
20424: LIST
20425: ST_TO_ADDR
20426: GO 20659
20428: LD_INT 3
20430: DOUBLE
20431: EQUAL
20432: IFTRUE 20436
20434: GO 20658
20436: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
20437: LD_ADDR_VAR 0 4
20441: PUSH
20442: LD_INT 46
20444: PUSH
20445: LD_INT 47
20447: PUSH
20448: LD_INT 1
20450: PUSH
20451: LD_INT 2
20453: PUSH
20454: LD_INT 82
20456: PUSH
20457: LD_INT 83
20459: PUSH
20460: LD_INT 84
20462: PUSH
20463: LD_INT 85
20465: PUSH
20466: LD_INT 86
20468: PUSH
20469: LD_INT 11
20471: PUSH
20472: LD_INT 9
20474: PUSH
20475: LD_INT 20
20477: PUSH
20478: LD_INT 19
20480: PUSH
20481: LD_INT 21
20483: PUSH
20484: LD_INT 24
20486: PUSH
20487: LD_INT 22
20489: PUSH
20490: LD_INT 25
20492: PUSH
20493: LD_INT 28
20495: PUSH
20496: LD_INT 29
20498: PUSH
20499: LD_INT 30
20501: PUSH
20502: LD_INT 31
20504: PUSH
20505: LD_INT 37
20507: PUSH
20508: LD_INT 38
20510: PUSH
20511: LD_INT 32
20513: PUSH
20514: LD_INT 27
20516: PUSH
20517: LD_INT 33
20519: PUSH
20520: LD_INT 69
20522: PUSH
20523: LD_INT 39
20525: PUSH
20526: LD_INT 34
20528: PUSH
20529: LD_INT 40
20531: PUSH
20532: LD_INT 71
20534: PUSH
20535: LD_INT 23
20537: PUSH
20538: LD_INT 44
20540: PUSH
20541: LD_INT 48
20543: PUSH
20544: LD_INT 49
20546: PUSH
20547: LD_INT 50
20549: PUSH
20550: LD_INT 51
20552: PUSH
20553: LD_INT 52
20555: PUSH
20556: LD_INT 53
20558: PUSH
20559: LD_INT 54
20561: PUSH
20562: LD_INT 55
20564: PUSH
20565: LD_INT 56
20567: PUSH
20568: LD_INT 57
20570: PUSH
20571: LD_INT 58
20573: PUSH
20574: LD_INT 59
20576: PUSH
20577: LD_INT 63
20579: PUSH
20580: LD_INT 64
20582: PUSH
20583: LD_INT 65
20585: PUSH
20586: LD_INT 82
20588: PUSH
20589: LD_INT 83
20591: PUSH
20592: LD_INT 84
20594: PUSH
20595: LD_INT 85
20597: PUSH
20598: LD_INT 86
20600: PUSH
20601: EMPTY
20602: LIST
20603: LIST
20604: LIST
20605: LIST
20606: LIST
20607: LIST
20608: LIST
20609: LIST
20610: LIST
20611: LIST
20612: LIST
20613: LIST
20614: LIST
20615: LIST
20616: LIST
20617: LIST
20618: LIST
20619: LIST
20620: LIST
20621: LIST
20622: LIST
20623: LIST
20624: LIST
20625: LIST
20626: LIST
20627: LIST
20628: LIST
20629: LIST
20630: LIST
20631: LIST
20632: LIST
20633: LIST
20634: LIST
20635: LIST
20636: LIST
20637: LIST
20638: LIST
20639: LIST
20640: LIST
20641: LIST
20642: LIST
20643: LIST
20644: LIST
20645: LIST
20646: LIST
20647: LIST
20648: LIST
20649: LIST
20650: LIST
20651: LIST
20652: LIST
20653: LIST
20654: LIST
20655: ST_TO_ADDR
20656: GO 20659
20658: POP
// if state > - 1 and state < 3 then
20659: LD_VAR 0 3
20663: PUSH
20664: LD_INT 1
20666: NEG
20667: GREATER
20668: PUSH
20669: LD_VAR 0 3
20673: PUSH
20674: LD_INT 3
20676: LESS
20677: AND
20678: IFFALSE 20735
// for i in result do
20680: LD_ADDR_VAR 0 5
20684: PUSH
20685: LD_VAR 0 4
20689: PUSH
20690: FOR_IN
20691: IFFALSE 20733
// if GetTech ( i , side ) <> state then
20693: LD_VAR 0 5
20697: PPUSH
20698: LD_VAR 0 1
20702: PPUSH
20703: CALL_OW 321
20707: PUSH
20708: LD_VAR 0 3
20712: NONEQUAL
20713: IFFALSE 20731
// result := result diff i ;
20715: LD_ADDR_VAR 0 4
20719: PUSH
20720: LD_VAR 0 4
20724: PUSH
20725: LD_VAR 0 5
20729: DIFF
20730: ST_TO_ADDR
20731: GO 20690
20733: POP
20734: POP
// end ;
20735: LD_VAR 0 4
20739: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
20740: LD_INT 0
20742: PPUSH
20743: PPUSH
20744: PPUSH
// result := true ;
20745: LD_ADDR_VAR 0 3
20749: PUSH
20750: LD_INT 1
20752: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
20753: LD_ADDR_VAR 0 5
20757: PUSH
20758: LD_VAR 0 2
20762: PPUSH
20763: CALL_OW 480
20767: ST_TO_ADDR
// if not tmp then
20768: LD_VAR 0 5
20772: NOT
20773: IFFALSE 20777
// exit ;
20775: GO 20826
// for i in tmp do
20777: LD_ADDR_VAR 0 4
20781: PUSH
20782: LD_VAR 0 5
20786: PUSH
20787: FOR_IN
20788: IFFALSE 20824
// if GetTech ( i , side ) <> state_researched then
20790: LD_VAR 0 4
20794: PPUSH
20795: LD_VAR 0 1
20799: PPUSH
20800: CALL_OW 321
20804: PUSH
20805: LD_INT 2
20807: NONEQUAL
20808: IFFALSE 20822
// begin result := false ;
20810: LD_ADDR_VAR 0 3
20814: PUSH
20815: LD_INT 0
20817: ST_TO_ADDR
// exit ;
20818: POP
20819: POP
20820: GO 20826
// end ;
20822: GO 20787
20824: POP
20825: POP
// end ;
20826: LD_VAR 0 3
20830: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
20831: LD_INT 0
20833: PPUSH
20834: PPUSH
20835: PPUSH
20836: PPUSH
20837: PPUSH
20838: PPUSH
20839: PPUSH
20840: PPUSH
20841: PPUSH
20842: PPUSH
20843: PPUSH
20844: PPUSH
20845: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
20846: LD_VAR 0 1
20850: NOT
20851: PUSH
20852: LD_VAR 0 1
20856: PPUSH
20857: CALL_OW 257
20861: PUSH
20862: LD_INT 9
20864: NONEQUAL
20865: OR
20866: IFFALSE 20870
// exit ;
20868: GO 21443
// side := GetSide ( unit ) ;
20870: LD_ADDR_VAR 0 9
20874: PUSH
20875: LD_VAR 0 1
20879: PPUSH
20880: CALL_OW 255
20884: ST_TO_ADDR
// tech_space := tech_spacanom ;
20885: LD_ADDR_VAR 0 12
20889: PUSH
20890: LD_INT 29
20892: ST_TO_ADDR
// tech_time := tech_taurad ;
20893: LD_ADDR_VAR 0 13
20897: PUSH
20898: LD_INT 28
20900: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
20901: LD_ADDR_VAR 0 11
20905: PUSH
20906: LD_VAR 0 1
20910: PPUSH
20911: CALL_OW 310
20915: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
20916: LD_VAR 0 11
20920: PPUSH
20921: CALL_OW 247
20925: PUSH
20926: LD_INT 2
20928: EQUAL
20929: IFFALSE 20933
// exit ;
20931: GO 21443
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
20933: LD_ADDR_VAR 0 8
20937: PUSH
20938: LD_INT 81
20940: PUSH
20941: LD_VAR 0 9
20945: PUSH
20946: EMPTY
20947: LIST
20948: LIST
20949: PUSH
20950: LD_INT 3
20952: PUSH
20953: LD_INT 21
20955: PUSH
20956: LD_INT 3
20958: PUSH
20959: EMPTY
20960: LIST
20961: LIST
20962: PUSH
20963: EMPTY
20964: LIST
20965: LIST
20966: PUSH
20967: EMPTY
20968: LIST
20969: LIST
20970: PPUSH
20971: CALL_OW 69
20975: ST_TO_ADDR
// if not tmp then
20976: LD_VAR 0 8
20980: NOT
20981: IFFALSE 20985
// exit ;
20983: GO 21443
// if in_unit then
20985: LD_VAR 0 11
20989: IFFALSE 21013
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
20991: LD_ADDR_VAR 0 10
20995: PUSH
20996: LD_VAR 0 8
21000: PPUSH
21001: LD_VAR 0 11
21005: PPUSH
21006: CALL_OW 74
21010: ST_TO_ADDR
21011: GO 21033
// enemy := NearestUnitToUnit ( tmp , unit ) ;
21013: LD_ADDR_VAR 0 10
21017: PUSH
21018: LD_VAR 0 8
21022: PPUSH
21023: LD_VAR 0 1
21027: PPUSH
21028: CALL_OW 74
21032: ST_TO_ADDR
// if not enemy then
21033: LD_VAR 0 10
21037: NOT
21038: IFFALSE 21042
// exit ;
21040: GO 21443
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
21042: LD_VAR 0 11
21046: PUSH
21047: LD_VAR 0 11
21051: PPUSH
21052: LD_VAR 0 10
21056: PPUSH
21057: CALL_OW 296
21061: PUSH
21062: LD_INT 13
21064: GREATER
21065: AND
21066: PUSH
21067: LD_VAR 0 1
21071: PPUSH
21072: LD_VAR 0 10
21076: PPUSH
21077: CALL_OW 296
21081: PUSH
21082: LD_INT 12
21084: GREATER
21085: OR
21086: IFFALSE 21090
// exit ;
21088: GO 21443
// missile := [ 1 ] ;
21090: LD_ADDR_VAR 0 14
21094: PUSH
21095: LD_INT 1
21097: PUSH
21098: EMPTY
21099: LIST
21100: ST_TO_ADDR
// if Researched ( side , tech_space ) then
21101: LD_VAR 0 9
21105: PPUSH
21106: LD_VAR 0 12
21110: PPUSH
21111: CALL_OW 325
21115: IFFALSE 21144
// missile := Replace ( missile , missile + 1 , 2 ) ;
21117: LD_ADDR_VAR 0 14
21121: PUSH
21122: LD_VAR 0 14
21126: PPUSH
21127: LD_VAR 0 14
21131: PUSH
21132: LD_INT 1
21134: PLUS
21135: PPUSH
21136: LD_INT 2
21138: PPUSH
21139: CALL_OW 1
21143: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
21144: LD_VAR 0 9
21148: PPUSH
21149: LD_VAR 0 13
21153: PPUSH
21154: CALL_OW 325
21158: PUSH
21159: LD_VAR 0 10
21163: PPUSH
21164: CALL_OW 255
21168: PPUSH
21169: LD_VAR 0 13
21173: PPUSH
21174: CALL_OW 325
21178: NOT
21179: AND
21180: IFFALSE 21209
// missile := Replace ( missile , missile + 1 , 3 ) ;
21182: LD_ADDR_VAR 0 14
21186: PUSH
21187: LD_VAR 0 14
21191: PPUSH
21192: LD_VAR 0 14
21196: PUSH
21197: LD_INT 1
21199: PLUS
21200: PPUSH
21201: LD_INT 3
21203: PPUSH
21204: CALL_OW 1
21208: ST_TO_ADDR
// if missile < 2 then
21209: LD_VAR 0 14
21213: PUSH
21214: LD_INT 2
21216: LESS
21217: IFFALSE 21221
// exit ;
21219: GO 21443
// x := GetX ( enemy ) ;
21221: LD_ADDR_VAR 0 4
21225: PUSH
21226: LD_VAR 0 10
21230: PPUSH
21231: CALL_OW 250
21235: ST_TO_ADDR
// y := GetY ( enemy ) ;
21236: LD_ADDR_VAR 0 5
21240: PUSH
21241: LD_VAR 0 10
21245: PPUSH
21246: CALL_OW 251
21250: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
21251: LD_ADDR_VAR 0 6
21255: PUSH
21256: LD_VAR 0 4
21260: PUSH
21261: LD_INT 1
21263: NEG
21264: PPUSH
21265: LD_INT 1
21267: PPUSH
21268: CALL_OW 12
21272: PLUS
21273: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
21274: LD_ADDR_VAR 0 7
21278: PUSH
21279: LD_VAR 0 5
21283: PUSH
21284: LD_INT 1
21286: NEG
21287: PPUSH
21288: LD_INT 1
21290: PPUSH
21291: CALL_OW 12
21295: PLUS
21296: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
21297: LD_VAR 0 6
21301: PPUSH
21302: LD_VAR 0 7
21306: PPUSH
21307: CALL_OW 488
21311: NOT
21312: IFFALSE 21334
// begin _x := x ;
21314: LD_ADDR_VAR 0 6
21318: PUSH
21319: LD_VAR 0 4
21323: ST_TO_ADDR
// _y := y ;
21324: LD_ADDR_VAR 0 7
21328: PUSH
21329: LD_VAR 0 5
21333: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
21334: LD_ADDR_VAR 0 3
21338: PUSH
21339: LD_INT 1
21341: PPUSH
21342: LD_VAR 0 14
21346: PPUSH
21347: CALL_OW 12
21351: ST_TO_ADDR
// case i of 1 :
21352: LD_VAR 0 3
21356: PUSH
21357: LD_INT 1
21359: DOUBLE
21360: EQUAL
21361: IFTRUE 21365
21363: GO 21382
21365: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
21366: LD_VAR 0 1
21370: PPUSH
21371: LD_VAR 0 10
21375: PPUSH
21376: CALL_OW 115
21380: GO 21443
21382: LD_INT 2
21384: DOUBLE
21385: EQUAL
21386: IFTRUE 21390
21388: GO 21412
21390: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
21391: LD_VAR 0 1
21395: PPUSH
21396: LD_VAR 0 6
21400: PPUSH
21401: LD_VAR 0 7
21405: PPUSH
21406: CALL_OW 153
21410: GO 21443
21412: LD_INT 3
21414: DOUBLE
21415: EQUAL
21416: IFTRUE 21420
21418: GO 21442
21420: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
21421: LD_VAR 0 1
21425: PPUSH
21426: LD_VAR 0 6
21430: PPUSH
21431: LD_VAR 0 7
21435: PPUSH
21436: CALL_OW 154
21440: GO 21443
21442: POP
// end ;
21443: LD_VAR 0 2
21447: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
21448: LD_INT 0
21450: PPUSH
21451: PPUSH
21452: PPUSH
21453: PPUSH
21454: PPUSH
21455: PPUSH
// if not unit or not building then
21456: LD_VAR 0 1
21460: NOT
21461: PUSH
21462: LD_VAR 0 2
21466: NOT
21467: OR
21468: IFFALSE 21472
// exit ;
21470: GO 21630
// x := GetX ( building ) ;
21472: LD_ADDR_VAR 0 5
21476: PUSH
21477: LD_VAR 0 2
21481: PPUSH
21482: CALL_OW 250
21486: ST_TO_ADDR
// y := GetY ( building ) ;
21487: LD_ADDR_VAR 0 6
21491: PUSH
21492: LD_VAR 0 2
21496: PPUSH
21497: CALL_OW 251
21501: ST_TO_ADDR
// for i = 0 to 5 do
21502: LD_ADDR_VAR 0 4
21506: PUSH
21507: DOUBLE
21508: LD_INT 0
21510: DEC
21511: ST_TO_ADDR
21512: LD_INT 5
21514: PUSH
21515: FOR_TO
21516: IFFALSE 21628
// begin _x := ShiftX ( x , i , 3 ) ;
21518: LD_ADDR_VAR 0 7
21522: PUSH
21523: LD_VAR 0 5
21527: PPUSH
21528: LD_VAR 0 4
21532: PPUSH
21533: LD_INT 3
21535: PPUSH
21536: CALL_OW 272
21540: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
21541: LD_ADDR_VAR 0 8
21545: PUSH
21546: LD_VAR 0 6
21550: PPUSH
21551: LD_VAR 0 4
21555: PPUSH
21556: LD_INT 3
21558: PPUSH
21559: CALL_OW 273
21563: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
21564: LD_VAR 0 7
21568: PPUSH
21569: LD_VAR 0 8
21573: PPUSH
21574: CALL_OW 488
21578: NOT
21579: IFFALSE 21583
// continue ;
21581: GO 21515
// if HexInfo ( _x , _y ) = 0 then
21583: LD_VAR 0 7
21587: PPUSH
21588: LD_VAR 0 8
21592: PPUSH
21593: CALL_OW 428
21597: PUSH
21598: LD_INT 0
21600: EQUAL
21601: IFFALSE 21626
// begin ComMoveXY ( unit , _x , _y ) ;
21603: LD_VAR 0 1
21607: PPUSH
21608: LD_VAR 0 7
21612: PPUSH
21613: LD_VAR 0 8
21617: PPUSH
21618: CALL_OW 111
// exit ;
21622: POP
21623: POP
21624: GO 21630
// end ; end ;
21626: GO 21515
21628: POP
21629: POP
// end ;
21630: LD_VAR 0 3
21634: RET
// export function ScanBase ( side , base_area ) ; begin
21635: LD_INT 0
21637: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
21638: LD_ADDR_VAR 0 3
21642: PUSH
21643: LD_VAR 0 2
21647: PPUSH
21648: LD_INT 81
21650: PUSH
21651: LD_VAR 0 1
21655: PUSH
21656: EMPTY
21657: LIST
21658: LIST
21659: PPUSH
21660: CALL_OW 70
21664: ST_TO_ADDR
// end ;
21665: LD_VAR 0 3
21669: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
21670: LD_INT 0
21672: PPUSH
21673: PPUSH
21674: PPUSH
21675: PPUSH
// result := false ;
21676: LD_ADDR_VAR 0 2
21680: PUSH
21681: LD_INT 0
21683: ST_TO_ADDR
// side := GetSide ( unit ) ;
21684: LD_ADDR_VAR 0 3
21688: PUSH
21689: LD_VAR 0 1
21693: PPUSH
21694: CALL_OW 255
21698: ST_TO_ADDR
// nat := GetNation ( unit ) ;
21699: LD_ADDR_VAR 0 4
21703: PUSH
21704: LD_VAR 0 1
21708: PPUSH
21709: CALL_OW 248
21713: ST_TO_ADDR
// case nat of 1 :
21714: LD_VAR 0 4
21718: PUSH
21719: LD_INT 1
21721: DOUBLE
21722: EQUAL
21723: IFTRUE 21727
21725: GO 21738
21727: POP
// tech := tech_lassight ; 2 :
21728: LD_ADDR_VAR 0 5
21732: PUSH
21733: LD_INT 12
21735: ST_TO_ADDR
21736: GO 21777
21738: LD_INT 2
21740: DOUBLE
21741: EQUAL
21742: IFTRUE 21746
21744: GO 21757
21746: POP
// tech := tech_mortar ; 3 :
21747: LD_ADDR_VAR 0 5
21751: PUSH
21752: LD_INT 41
21754: ST_TO_ADDR
21755: GO 21777
21757: LD_INT 3
21759: DOUBLE
21760: EQUAL
21761: IFTRUE 21765
21763: GO 21776
21765: POP
// tech := tech_bazooka ; end ;
21766: LD_ADDR_VAR 0 5
21770: PUSH
21771: LD_INT 44
21773: ST_TO_ADDR
21774: GO 21777
21776: POP
// if Researched ( side , tech ) then
21777: LD_VAR 0 3
21781: PPUSH
21782: LD_VAR 0 5
21786: PPUSH
21787: CALL_OW 325
21791: IFFALSE 21818
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
21793: LD_ADDR_VAR 0 2
21797: PUSH
21798: LD_INT 5
21800: PUSH
21801: LD_INT 8
21803: PUSH
21804: LD_INT 9
21806: PUSH
21807: EMPTY
21808: LIST
21809: LIST
21810: LIST
21811: PUSH
21812: LD_VAR 0 4
21816: ARRAY
21817: ST_TO_ADDR
// end ;
21818: LD_VAR 0 2
21822: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
21823: LD_INT 0
21825: PPUSH
21826: PPUSH
21827: PPUSH
// if not mines then
21828: LD_VAR 0 2
21832: NOT
21833: IFFALSE 21837
// exit ;
21835: GO 21981
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
21837: LD_ADDR_VAR 0 5
21841: PUSH
21842: LD_INT 81
21844: PUSH
21845: LD_VAR 0 1
21849: PUSH
21850: EMPTY
21851: LIST
21852: LIST
21853: PUSH
21854: LD_INT 3
21856: PUSH
21857: LD_INT 21
21859: PUSH
21860: LD_INT 3
21862: PUSH
21863: EMPTY
21864: LIST
21865: LIST
21866: PUSH
21867: EMPTY
21868: LIST
21869: LIST
21870: PUSH
21871: EMPTY
21872: LIST
21873: LIST
21874: PPUSH
21875: CALL_OW 69
21879: ST_TO_ADDR
// for i in mines do
21880: LD_ADDR_VAR 0 4
21884: PUSH
21885: LD_VAR 0 2
21889: PUSH
21890: FOR_IN
21891: IFFALSE 21979
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
21893: LD_VAR 0 4
21897: PUSH
21898: LD_INT 1
21900: ARRAY
21901: PPUSH
21902: LD_VAR 0 4
21906: PUSH
21907: LD_INT 2
21909: ARRAY
21910: PPUSH
21911: CALL_OW 458
21915: NOT
21916: IFFALSE 21920
// continue ;
21918: GO 21890
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
21920: LD_VAR 0 4
21924: PUSH
21925: LD_INT 1
21927: ARRAY
21928: PPUSH
21929: LD_VAR 0 4
21933: PUSH
21934: LD_INT 2
21936: ARRAY
21937: PPUSH
21938: CALL_OW 428
21942: PUSH
21943: LD_VAR 0 5
21947: IN
21948: IFFALSE 21977
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
21950: LD_VAR 0 4
21954: PUSH
21955: LD_INT 1
21957: ARRAY
21958: PPUSH
21959: LD_VAR 0 4
21963: PUSH
21964: LD_INT 2
21966: ARRAY
21967: PPUSH
21968: LD_VAR 0 1
21972: PPUSH
21973: CALL_OW 456
// end ;
21977: GO 21890
21979: POP
21980: POP
// end ;
21981: LD_VAR 0 3
21985: RET
// export function Count ( array ) ; var i ; begin
21986: LD_INT 0
21988: PPUSH
21989: PPUSH
// result := 0 ;
21990: LD_ADDR_VAR 0 2
21994: PUSH
21995: LD_INT 0
21997: ST_TO_ADDR
// for i in array do
21998: LD_ADDR_VAR 0 3
22002: PUSH
22003: LD_VAR 0 1
22007: PUSH
22008: FOR_IN
22009: IFFALSE 22033
// if i then
22011: LD_VAR 0 3
22015: IFFALSE 22031
// result := result + 1 ;
22017: LD_ADDR_VAR 0 2
22021: PUSH
22022: LD_VAR 0 2
22026: PUSH
22027: LD_INT 1
22029: PLUS
22030: ST_TO_ADDR
22031: GO 22008
22033: POP
22034: POP
// end ;
22035: LD_VAR 0 2
22039: RET
// export function IsEmpty ( building ) ; begin
22040: LD_INT 0
22042: PPUSH
// if not building then
22043: LD_VAR 0 1
22047: NOT
22048: IFFALSE 22052
// exit ;
22050: GO 22095
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
22052: LD_ADDR_VAR 0 2
22056: PUSH
22057: LD_VAR 0 1
22061: PUSH
22062: LD_INT 22
22064: PUSH
22065: LD_VAR 0 1
22069: PPUSH
22070: CALL_OW 255
22074: PUSH
22075: EMPTY
22076: LIST
22077: LIST
22078: PUSH
22079: LD_INT 58
22081: PUSH
22082: EMPTY
22083: LIST
22084: PUSH
22085: EMPTY
22086: LIST
22087: LIST
22088: PPUSH
22089: CALL_OW 69
22093: IN
22094: ST_TO_ADDR
// end ;
22095: LD_VAR 0 2
22099: RET
// export function IsNotFull ( building ) ; var places ; begin
22100: LD_INT 0
22102: PPUSH
22103: PPUSH
// if not building then
22104: LD_VAR 0 1
22108: NOT
22109: IFFALSE 22113
// exit ;
22111: GO 22284
// result := false ;
22113: LD_ADDR_VAR 0 2
22117: PUSH
22118: LD_INT 0
22120: ST_TO_ADDR
// places := 0 ;
22121: LD_ADDR_VAR 0 3
22125: PUSH
22126: LD_INT 0
22128: ST_TO_ADDR
// case GetBType ( building ) of b_depot , b_warehouse , b_lab , b_lab_half , b_lab_full , b_armoury , b_barracks , b_workshop , b_factory , b_fort :
22129: LD_VAR 0 1
22133: PPUSH
22134: CALL_OW 266
22138: PUSH
22139: LD_INT 0
22141: DOUBLE
22142: EQUAL
22143: IFTRUE 22201
22145: LD_INT 1
22147: DOUBLE
22148: EQUAL
22149: IFTRUE 22201
22151: LD_INT 6
22153: DOUBLE
22154: EQUAL
22155: IFTRUE 22201
22157: LD_INT 7
22159: DOUBLE
22160: EQUAL
22161: IFTRUE 22201
22163: LD_INT 8
22165: DOUBLE
22166: EQUAL
22167: IFTRUE 22201
22169: LD_INT 4
22171: DOUBLE
22172: EQUAL
22173: IFTRUE 22201
22175: LD_INT 5
22177: DOUBLE
22178: EQUAL
22179: IFTRUE 22201
22181: LD_INT 2
22183: DOUBLE
22184: EQUAL
22185: IFTRUE 22201
22187: LD_INT 3
22189: DOUBLE
22190: EQUAL
22191: IFTRUE 22201
22193: LD_INT 35
22195: DOUBLE
22196: EQUAL
22197: IFTRUE 22201
22199: GO 22212
22201: POP
// places := 6 ; b_bunker , b_breastwork :
22202: LD_ADDR_VAR 0 3
22206: PUSH
22207: LD_INT 6
22209: ST_TO_ADDR
22210: GO 22257
22212: LD_INT 32
22214: DOUBLE
22215: EQUAL
22216: IFTRUE 22226
22218: LD_INT 31
22220: DOUBLE
22221: EQUAL
22222: IFTRUE 22226
22224: GO 22237
22226: POP
// places := 1 ; b_control_tower :
22227: LD_ADDR_VAR 0 3
22231: PUSH
22232: LD_INT 1
22234: ST_TO_ADDR
22235: GO 22257
22237: LD_INT 36
22239: DOUBLE
22240: EQUAL
22241: IFTRUE 22245
22243: GO 22256
22245: POP
// places := 3 ; end ;
22246: LD_ADDR_VAR 0 3
22250: PUSH
22251: LD_INT 3
22253: ST_TO_ADDR
22254: GO 22257
22256: POP
// if places then
22257: LD_VAR 0 3
22261: IFFALSE 22284
// result := UnitsInside ( building ) < places ;
22263: LD_ADDR_VAR 0 2
22267: PUSH
22268: LD_VAR 0 1
22272: PPUSH
22273: CALL_OW 313
22277: PUSH
22278: LD_VAR 0 3
22282: LESS
22283: ST_TO_ADDR
// end ;
22284: LD_VAR 0 2
22288: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
22289: LD_INT 0
22291: PPUSH
22292: PPUSH
22293: PPUSH
22294: PPUSH
// tmp := [ ] ;
22295: LD_ADDR_VAR 0 3
22299: PUSH
22300: EMPTY
22301: ST_TO_ADDR
// list := [ ] ;
22302: LD_ADDR_VAR 0 5
22306: PUSH
22307: EMPTY
22308: ST_TO_ADDR
// for i = 16 to 25 do
22309: LD_ADDR_VAR 0 4
22313: PUSH
22314: DOUBLE
22315: LD_INT 16
22317: DEC
22318: ST_TO_ADDR
22319: LD_INT 25
22321: PUSH
22322: FOR_TO
22323: IFFALSE 22396
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
22325: LD_ADDR_VAR 0 3
22329: PUSH
22330: LD_VAR 0 3
22334: PUSH
22335: LD_INT 22
22337: PUSH
22338: LD_VAR 0 1
22342: PPUSH
22343: CALL_OW 255
22347: PUSH
22348: EMPTY
22349: LIST
22350: LIST
22351: PUSH
22352: LD_INT 91
22354: PUSH
22355: LD_VAR 0 1
22359: PUSH
22360: LD_INT 6
22362: PUSH
22363: EMPTY
22364: LIST
22365: LIST
22366: LIST
22367: PUSH
22368: LD_INT 30
22370: PUSH
22371: LD_VAR 0 4
22375: PUSH
22376: EMPTY
22377: LIST
22378: LIST
22379: PUSH
22380: EMPTY
22381: LIST
22382: LIST
22383: LIST
22384: PUSH
22385: EMPTY
22386: LIST
22387: PPUSH
22388: CALL_OW 69
22392: ADD
22393: ST_TO_ADDR
22394: GO 22322
22396: POP
22397: POP
// for i = 1 to tmp do
22398: LD_ADDR_VAR 0 4
22402: PUSH
22403: DOUBLE
22404: LD_INT 1
22406: DEC
22407: ST_TO_ADDR
22408: LD_VAR 0 3
22412: PUSH
22413: FOR_TO
22414: IFFALSE 22502
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
22416: LD_ADDR_VAR 0 5
22420: PUSH
22421: LD_VAR 0 5
22425: PUSH
22426: LD_VAR 0 3
22430: PUSH
22431: LD_VAR 0 4
22435: ARRAY
22436: PPUSH
22437: CALL_OW 266
22441: PUSH
22442: LD_VAR 0 3
22446: PUSH
22447: LD_VAR 0 4
22451: ARRAY
22452: PPUSH
22453: CALL_OW 250
22457: PUSH
22458: LD_VAR 0 3
22462: PUSH
22463: LD_VAR 0 4
22467: ARRAY
22468: PPUSH
22469: CALL_OW 251
22473: PUSH
22474: LD_VAR 0 3
22478: PUSH
22479: LD_VAR 0 4
22483: ARRAY
22484: PPUSH
22485: CALL_OW 254
22489: PUSH
22490: EMPTY
22491: LIST
22492: LIST
22493: LIST
22494: LIST
22495: PUSH
22496: EMPTY
22497: LIST
22498: ADD
22499: ST_TO_ADDR
22500: GO 22413
22502: POP
22503: POP
// result := list ;
22504: LD_ADDR_VAR 0 2
22508: PUSH
22509: LD_VAR 0 5
22513: ST_TO_ADDR
// end ;
22514: LD_VAR 0 2
22518: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
22519: LD_INT 0
22521: PPUSH
22522: PPUSH
22523: PPUSH
22524: PPUSH
22525: PPUSH
22526: PPUSH
22527: PPUSH
// if not factory then
22528: LD_VAR 0 1
22532: NOT
22533: IFFALSE 22537
// exit ;
22535: GO 23130
// if control = control_apeman then
22537: LD_VAR 0 4
22541: PUSH
22542: LD_INT 5
22544: EQUAL
22545: IFFALSE 22654
// begin tmp := UnitsInside ( factory ) ;
22547: LD_ADDR_VAR 0 8
22551: PUSH
22552: LD_VAR 0 1
22556: PPUSH
22557: CALL_OW 313
22561: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
22562: LD_VAR 0 8
22566: PPUSH
22567: LD_INT 25
22569: PUSH
22570: LD_INT 12
22572: PUSH
22573: EMPTY
22574: LIST
22575: LIST
22576: PPUSH
22577: CALL_OW 72
22581: NOT
22582: IFFALSE 22592
// control := control_manual ;
22584: LD_ADDR_VAR 0 4
22588: PUSH
22589: LD_INT 1
22591: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
22592: LD_ADDR_VAR 0 8
22596: PUSH
22597: LD_VAR 0 1
22601: PPUSH
22602: CALL 22289 0 1
22606: ST_TO_ADDR
// if tmp then
22607: LD_VAR 0 8
22611: IFFALSE 22654
// begin for i in tmp do
22613: LD_ADDR_VAR 0 7
22617: PUSH
22618: LD_VAR 0 8
22622: PUSH
22623: FOR_IN
22624: IFFALSE 22652
// if i [ 1 ] = b_ext_radio then
22626: LD_VAR 0 7
22630: PUSH
22631: LD_INT 1
22633: ARRAY
22634: PUSH
22635: LD_INT 22
22637: EQUAL
22638: IFFALSE 22650
// begin control := control_remote ;
22640: LD_ADDR_VAR 0 4
22644: PUSH
22645: LD_INT 2
22647: ST_TO_ADDR
// break ;
22648: GO 22652
// end ;
22650: GO 22623
22652: POP
22653: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
22654: LD_VAR 0 1
22658: PPUSH
22659: LD_VAR 0 2
22663: PPUSH
22664: LD_VAR 0 3
22668: PPUSH
22669: LD_VAR 0 4
22673: PPUSH
22674: LD_VAR 0 5
22678: PPUSH
22679: CALL_OW 448
22683: IFFALSE 22718
// begin result := [ chassis , engine , control , weapon ] ;
22685: LD_ADDR_VAR 0 6
22689: PUSH
22690: LD_VAR 0 2
22694: PUSH
22695: LD_VAR 0 3
22699: PUSH
22700: LD_VAR 0 4
22704: PUSH
22705: LD_VAR 0 5
22709: PUSH
22710: EMPTY
22711: LIST
22712: LIST
22713: LIST
22714: LIST
22715: ST_TO_ADDR
// exit ;
22716: GO 23130
// end ; _chassis := AvailableChassisList ( factory ) ;
22718: LD_ADDR_VAR 0 9
22722: PUSH
22723: LD_VAR 0 1
22727: PPUSH
22728: CALL_OW 475
22732: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
22733: LD_ADDR_VAR 0 11
22737: PUSH
22738: LD_VAR 0 1
22742: PPUSH
22743: CALL_OW 476
22747: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
22748: LD_ADDR_VAR 0 12
22752: PUSH
22753: LD_VAR 0 1
22757: PPUSH
22758: CALL_OW 477
22762: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
22763: LD_ADDR_VAR 0 10
22767: PUSH
22768: LD_VAR 0 1
22772: PPUSH
22773: CALL_OW 478
22777: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
22778: LD_VAR 0 9
22782: NOT
22783: PUSH
22784: LD_VAR 0 11
22788: NOT
22789: OR
22790: PUSH
22791: LD_VAR 0 12
22795: NOT
22796: OR
22797: PUSH
22798: LD_VAR 0 10
22802: NOT
22803: OR
22804: IFFALSE 22839
// begin result := [ chassis , engine , control , weapon ] ;
22806: LD_ADDR_VAR 0 6
22810: PUSH
22811: LD_VAR 0 2
22815: PUSH
22816: LD_VAR 0 3
22820: PUSH
22821: LD_VAR 0 4
22825: PUSH
22826: LD_VAR 0 5
22830: PUSH
22831: EMPTY
22832: LIST
22833: LIST
22834: LIST
22835: LIST
22836: ST_TO_ADDR
// exit ;
22837: GO 23130
// end ; if not chassis in _chassis then
22839: LD_VAR 0 2
22843: PUSH
22844: LD_VAR 0 9
22848: IN
22849: NOT
22850: IFFALSE 22876
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
22852: LD_ADDR_VAR 0 2
22856: PUSH
22857: LD_VAR 0 9
22861: PUSH
22862: LD_INT 1
22864: PPUSH
22865: LD_VAR 0 9
22869: PPUSH
22870: CALL_OW 12
22874: ARRAY
22875: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
22876: LD_VAR 0 2
22880: PPUSH
22881: LD_VAR 0 3
22885: PPUSH
22886: CALL 23135 0 2
22890: NOT
22891: IFFALSE 22950
// repeat engine := _engine [ 1 ] ;
22893: LD_ADDR_VAR 0 3
22897: PUSH
22898: LD_VAR 0 11
22902: PUSH
22903: LD_INT 1
22905: ARRAY
22906: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
22907: LD_ADDR_VAR 0 11
22911: PUSH
22912: LD_VAR 0 11
22916: PPUSH
22917: LD_INT 1
22919: PPUSH
22920: CALL_OW 3
22924: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
22925: LD_VAR 0 2
22929: PPUSH
22930: LD_VAR 0 3
22934: PPUSH
22935: CALL 23135 0 2
22939: PUSH
22940: LD_VAR 0 11
22944: PUSH
22945: EMPTY
22946: EQUAL
22947: OR
22948: IFFALSE 22893
// if not control in _control then
22950: LD_VAR 0 4
22954: PUSH
22955: LD_VAR 0 12
22959: IN
22960: NOT
22961: IFFALSE 22987
// control := _control [ rand ( 1 , _control ) ] ;
22963: LD_ADDR_VAR 0 4
22967: PUSH
22968: LD_VAR 0 12
22972: PUSH
22973: LD_INT 1
22975: PPUSH
22976: LD_VAR 0 12
22980: PPUSH
22981: CALL_OW 12
22985: ARRAY
22986: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
22987: LD_VAR 0 2
22991: PPUSH
22992: LD_VAR 0 5
22996: PPUSH
22997: CALL 23355 0 2
23001: NOT
23002: IFFALSE 23061
// repeat weapon := _weapon [ 1 ] ;
23004: LD_ADDR_VAR 0 5
23008: PUSH
23009: LD_VAR 0 10
23013: PUSH
23014: LD_INT 1
23016: ARRAY
23017: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
23018: LD_ADDR_VAR 0 10
23022: PUSH
23023: LD_VAR 0 10
23027: PPUSH
23028: LD_INT 1
23030: PPUSH
23031: CALL_OW 3
23035: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
23036: LD_VAR 0 2
23040: PPUSH
23041: LD_VAR 0 5
23045: PPUSH
23046: CALL 23355 0 2
23050: PUSH
23051: LD_VAR 0 10
23055: PUSH
23056: EMPTY
23057: EQUAL
23058: OR
23059: IFFALSE 23004
// result := [ ] ;
23061: LD_ADDR_VAR 0 6
23065: PUSH
23066: EMPTY
23067: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
23068: LD_VAR 0 1
23072: PPUSH
23073: LD_VAR 0 2
23077: PPUSH
23078: LD_VAR 0 3
23082: PPUSH
23083: LD_VAR 0 4
23087: PPUSH
23088: LD_VAR 0 5
23092: PPUSH
23093: CALL_OW 448
23097: IFFALSE 23130
// result := [ chassis , engine , control , weapon ] ;
23099: LD_ADDR_VAR 0 6
23103: PUSH
23104: LD_VAR 0 2
23108: PUSH
23109: LD_VAR 0 3
23113: PUSH
23114: LD_VAR 0 4
23118: PUSH
23119: LD_VAR 0 5
23123: PUSH
23124: EMPTY
23125: LIST
23126: LIST
23127: LIST
23128: LIST
23129: ST_TO_ADDR
// end ;
23130: LD_VAR 0 6
23134: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
23135: LD_INT 0
23137: PPUSH
// if not chassis or not engine then
23138: LD_VAR 0 1
23142: NOT
23143: PUSH
23144: LD_VAR 0 2
23148: NOT
23149: OR
23150: IFFALSE 23154
// exit ;
23152: GO 23350
// case engine of engine_solar :
23154: LD_VAR 0 2
23158: PUSH
23159: LD_INT 2
23161: DOUBLE
23162: EQUAL
23163: IFTRUE 23167
23165: GO 23205
23167: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
23168: LD_ADDR_VAR 0 3
23172: PUSH
23173: LD_INT 11
23175: PUSH
23176: LD_INT 12
23178: PUSH
23179: LD_INT 13
23181: PUSH
23182: LD_INT 14
23184: PUSH
23185: LD_INT 1
23187: PUSH
23188: LD_INT 2
23190: PUSH
23191: LD_INT 3
23193: PUSH
23194: EMPTY
23195: LIST
23196: LIST
23197: LIST
23198: LIST
23199: LIST
23200: LIST
23201: LIST
23202: ST_TO_ADDR
23203: GO 23334
23205: LD_INT 1
23207: DOUBLE
23208: EQUAL
23209: IFTRUE 23213
23211: GO 23275
23213: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
23214: LD_ADDR_VAR 0 3
23218: PUSH
23219: LD_INT 11
23221: PUSH
23222: LD_INT 12
23224: PUSH
23225: LD_INT 13
23227: PUSH
23228: LD_INT 14
23230: PUSH
23231: LD_INT 1
23233: PUSH
23234: LD_INT 2
23236: PUSH
23237: LD_INT 3
23239: PUSH
23240: LD_INT 4
23242: PUSH
23243: LD_INT 5
23245: PUSH
23246: LD_INT 21
23248: PUSH
23249: LD_INT 23
23251: PUSH
23252: LD_INT 22
23254: PUSH
23255: LD_INT 24
23257: PUSH
23258: EMPTY
23259: LIST
23260: LIST
23261: LIST
23262: LIST
23263: LIST
23264: LIST
23265: LIST
23266: LIST
23267: LIST
23268: LIST
23269: LIST
23270: LIST
23271: LIST
23272: ST_TO_ADDR
23273: GO 23334
23275: LD_INT 3
23277: DOUBLE
23278: EQUAL
23279: IFTRUE 23283
23281: GO 23333
23283: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
23284: LD_ADDR_VAR 0 3
23288: PUSH
23289: LD_INT 13
23291: PUSH
23292: LD_INT 14
23294: PUSH
23295: LD_INT 2
23297: PUSH
23298: LD_INT 3
23300: PUSH
23301: LD_INT 4
23303: PUSH
23304: LD_INT 5
23306: PUSH
23307: LD_INT 21
23309: PUSH
23310: LD_INT 22
23312: PUSH
23313: LD_INT 23
23315: PUSH
23316: LD_INT 24
23318: PUSH
23319: EMPTY
23320: LIST
23321: LIST
23322: LIST
23323: LIST
23324: LIST
23325: LIST
23326: LIST
23327: LIST
23328: LIST
23329: LIST
23330: ST_TO_ADDR
23331: GO 23334
23333: POP
// result := ( chassis in result ) ;
23334: LD_ADDR_VAR 0 3
23338: PUSH
23339: LD_VAR 0 1
23343: PUSH
23344: LD_VAR 0 3
23348: IN
23349: ST_TO_ADDR
// end ;
23350: LD_VAR 0 3
23354: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
23355: LD_INT 0
23357: PPUSH
// if not chassis or not weapon then
23358: LD_VAR 0 1
23362: NOT
23363: PUSH
23364: LD_VAR 0 2
23368: NOT
23369: OR
23370: IFFALSE 23374
// exit ;
23372: GO 24434
// case weapon of us_machine_gun :
23374: LD_VAR 0 2
23378: PUSH
23379: LD_INT 2
23381: DOUBLE
23382: EQUAL
23383: IFTRUE 23387
23385: GO 23417
23387: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
23388: LD_ADDR_VAR 0 3
23392: PUSH
23393: LD_INT 1
23395: PUSH
23396: LD_INT 2
23398: PUSH
23399: LD_INT 3
23401: PUSH
23402: LD_INT 4
23404: PUSH
23405: LD_INT 5
23407: PUSH
23408: EMPTY
23409: LIST
23410: LIST
23411: LIST
23412: LIST
23413: LIST
23414: ST_TO_ADDR
23415: GO 24418
23417: LD_INT 3
23419: DOUBLE
23420: EQUAL
23421: IFTRUE 23425
23423: GO 23455
23425: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
23426: LD_ADDR_VAR 0 3
23430: PUSH
23431: LD_INT 1
23433: PUSH
23434: LD_INT 2
23436: PUSH
23437: LD_INT 3
23439: PUSH
23440: LD_INT 4
23442: PUSH
23443: LD_INT 5
23445: PUSH
23446: EMPTY
23447: LIST
23448: LIST
23449: LIST
23450: LIST
23451: LIST
23452: ST_TO_ADDR
23453: GO 24418
23455: LD_INT 11
23457: DOUBLE
23458: EQUAL
23459: IFTRUE 23463
23461: GO 23493
23463: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
23464: LD_ADDR_VAR 0 3
23468: PUSH
23469: LD_INT 1
23471: PUSH
23472: LD_INT 2
23474: PUSH
23475: LD_INT 3
23477: PUSH
23478: LD_INT 4
23480: PUSH
23481: LD_INT 5
23483: PUSH
23484: EMPTY
23485: LIST
23486: LIST
23487: LIST
23488: LIST
23489: LIST
23490: ST_TO_ADDR
23491: GO 24418
23493: LD_INT 4
23495: DOUBLE
23496: EQUAL
23497: IFTRUE 23501
23499: GO 23527
23501: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
23502: LD_ADDR_VAR 0 3
23506: PUSH
23507: LD_INT 2
23509: PUSH
23510: LD_INT 3
23512: PUSH
23513: LD_INT 4
23515: PUSH
23516: LD_INT 5
23518: PUSH
23519: EMPTY
23520: LIST
23521: LIST
23522: LIST
23523: LIST
23524: ST_TO_ADDR
23525: GO 24418
23527: LD_INT 5
23529: DOUBLE
23530: EQUAL
23531: IFTRUE 23535
23533: GO 23561
23535: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
23536: LD_ADDR_VAR 0 3
23540: PUSH
23541: LD_INT 2
23543: PUSH
23544: LD_INT 3
23546: PUSH
23547: LD_INT 4
23549: PUSH
23550: LD_INT 5
23552: PUSH
23553: EMPTY
23554: LIST
23555: LIST
23556: LIST
23557: LIST
23558: ST_TO_ADDR
23559: GO 24418
23561: LD_INT 9
23563: DOUBLE
23564: EQUAL
23565: IFTRUE 23569
23567: GO 23595
23569: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
23570: LD_ADDR_VAR 0 3
23574: PUSH
23575: LD_INT 2
23577: PUSH
23578: LD_INT 3
23580: PUSH
23581: LD_INT 4
23583: PUSH
23584: LD_INT 5
23586: PUSH
23587: EMPTY
23588: LIST
23589: LIST
23590: LIST
23591: LIST
23592: ST_TO_ADDR
23593: GO 24418
23595: LD_INT 7
23597: DOUBLE
23598: EQUAL
23599: IFTRUE 23603
23601: GO 23629
23603: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
23604: LD_ADDR_VAR 0 3
23608: PUSH
23609: LD_INT 2
23611: PUSH
23612: LD_INT 3
23614: PUSH
23615: LD_INT 4
23617: PUSH
23618: LD_INT 5
23620: PUSH
23621: EMPTY
23622: LIST
23623: LIST
23624: LIST
23625: LIST
23626: ST_TO_ADDR
23627: GO 24418
23629: LD_INT 12
23631: DOUBLE
23632: EQUAL
23633: IFTRUE 23637
23635: GO 23663
23637: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
23638: LD_ADDR_VAR 0 3
23642: PUSH
23643: LD_INT 2
23645: PUSH
23646: LD_INT 3
23648: PUSH
23649: LD_INT 4
23651: PUSH
23652: LD_INT 5
23654: PUSH
23655: EMPTY
23656: LIST
23657: LIST
23658: LIST
23659: LIST
23660: ST_TO_ADDR
23661: GO 24418
23663: LD_INT 13
23665: DOUBLE
23666: EQUAL
23667: IFTRUE 23671
23669: GO 23697
23671: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
23672: LD_ADDR_VAR 0 3
23676: PUSH
23677: LD_INT 2
23679: PUSH
23680: LD_INT 3
23682: PUSH
23683: LD_INT 4
23685: PUSH
23686: LD_INT 5
23688: PUSH
23689: EMPTY
23690: LIST
23691: LIST
23692: LIST
23693: LIST
23694: ST_TO_ADDR
23695: GO 24418
23697: LD_INT 14
23699: DOUBLE
23700: EQUAL
23701: IFTRUE 23705
23703: GO 23723
23705: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
23706: LD_ADDR_VAR 0 3
23710: PUSH
23711: LD_INT 4
23713: PUSH
23714: LD_INT 5
23716: PUSH
23717: EMPTY
23718: LIST
23719: LIST
23720: ST_TO_ADDR
23721: GO 24418
23723: LD_INT 6
23725: DOUBLE
23726: EQUAL
23727: IFTRUE 23731
23729: GO 23749
23731: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
23732: LD_ADDR_VAR 0 3
23736: PUSH
23737: LD_INT 4
23739: PUSH
23740: LD_INT 5
23742: PUSH
23743: EMPTY
23744: LIST
23745: LIST
23746: ST_TO_ADDR
23747: GO 24418
23749: LD_INT 10
23751: DOUBLE
23752: EQUAL
23753: IFTRUE 23757
23755: GO 23775
23757: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
23758: LD_ADDR_VAR 0 3
23762: PUSH
23763: LD_INT 4
23765: PUSH
23766: LD_INT 5
23768: PUSH
23769: EMPTY
23770: LIST
23771: LIST
23772: ST_TO_ADDR
23773: GO 24418
23775: LD_INT 22
23777: DOUBLE
23778: EQUAL
23779: IFTRUE 23783
23781: GO 23809
23783: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
23784: LD_ADDR_VAR 0 3
23788: PUSH
23789: LD_INT 11
23791: PUSH
23792: LD_INT 12
23794: PUSH
23795: LD_INT 13
23797: PUSH
23798: LD_INT 14
23800: PUSH
23801: EMPTY
23802: LIST
23803: LIST
23804: LIST
23805: LIST
23806: ST_TO_ADDR
23807: GO 24418
23809: LD_INT 23
23811: DOUBLE
23812: EQUAL
23813: IFTRUE 23817
23815: GO 23843
23817: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
23818: LD_ADDR_VAR 0 3
23822: PUSH
23823: LD_INT 11
23825: PUSH
23826: LD_INT 12
23828: PUSH
23829: LD_INT 13
23831: PUSH
23832: LD_INT 14
23834: PUSH
23835: EMPTY
23836: LIST
23837: LIST
23838: LIST
23839: LIST
23840: ST_TO_ADDR
23841: GO 24418
23843: LD_INT 24
23845: DOUBLE
23846: EQUAL
23847: IFTRUE 23851
23849: GO 23877
23851: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
23852: LD_ADDR_VAR 0 3
23856: PUSH
23857: LD_INT 11
23859: PUSH
23860: LD_INT 12
23862: PUSH
23863: LD_INT 13
23865: PUSH
23866: LD_INT 14
23868: PUSH
23869: EMPTY
23870: LIST
23871: LIST
23872: LIST
23873: LIST
23874: ST_TO_ADDR
23875: GO 24418
23877: LD_INT 30
23879: DOUBLE
23880: EQUAL
23881: IFTRUE 23885
23883: GO 23911
23885: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
23886: LD_ADDR_VAR 0 3
23890: PUSH
23891: LD_INT 11
23893: PUSH
23894: LD_INT 12
23896: PUSH
23897: LD_INT 13
23899: PUSH
23900: LD_INT 14
23902: PUSH
23903: EMPTY
23904: LIST
23905: LIST
23906: LIST
23907: LIST
23908: ST_TO_ADDR
23909: GO 24418
23911: LD_INT 25
23913: DOUBLE
23914: EQUAL
23915: IFTRUE 23919
23917: GO 23937
23919: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
23920: LD_ADDR_VAR 0 3
23924: PUSH
23925: LD_INT 13
23927: PUSH
23928: LD_INT 14
23930: PUSH
23931: EMPTY
23932: LIST
23933: LIST
23934: ST_TO_ADDR
23935: GO 24418
23937: LD_INT 27
23939: DOUBLE
23940: EQUAL
23941: IFTRUE 23945
23943: GO 23963
23945: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
23946: LD_ADDR_VAR 0 3
23950: PUSH
23951: LD_INT 13
23953: PUSH
23954: LD_INT 14
23956: PUSH
23957: EMPTY
23958: LIST
23959: LIST
23960: ST_TO_ADDR
23961: GO 24418
23963: LD_INT 92
23965: DOUBLE
23966: EQUAL
23967: IFTRUE 23971
23969: GO 23997
23971: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
23972: LD_ADDR_VAR 0 3
23976: PUSH
23977: LD_INT 11
23979: PUSH
23980: LD_INT 12
23982: PUSH
23983: LD_INT 13
23985: PUSH
23986: LD_INT 14
23988: PUSH
23989: EMPTY
23990: LIST
23991: LIST
23992: LIST
23993: LIST
23994: ST_TO_ADDR
23995: GO 24418
23997: LD_INT 28
23999: DOUBLE
24000: EQUAL
24001: IFTRUE 24005
24003: GO 24023
24005: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
24006: LD_ADDR_VAR 0 3
24010: PUSH
24011: LD_INT 13
24013: PUSH
24014: LD_INT 14
24016: PUSH
24017: EMPTY
24018: LIST
24019: LIST
24020: ST_TO_ADDR
24021: GO 24418
24023: LD_INT 29
24025: DOUBLE
24026: EQUAL
24027: IFTRUE 24031
24029: GO 24049
24031: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
24032: LD_ADDR_VAR 0 3
24036: PUSH
24037: LD_INT 13
24039: PUSH
24040: LD_INT 14
24042: PUSH
24043: EMPTY
24044: LIST
24045: LIST
24046: ST_TO_ADDR
24047: GO 24418
24049: LD_INT 31
24051: DOUBLE
24052: EQUAL
24053: IFTRUE 24057
24055: GO 24075
24057: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
24058: LD_ADDR_VAR 0 3
24062: PUSH
24063: LD_INT 13
24065: PUSH
24066: LD_INT 14
24068: PUSH
24069: EMPTY
24070: LIST
24071: LIST
24072: ST_TO_ADDR
24073: GO 24418
24075: LD_INT 26
24077: DOUBLE
24078: EQUAL
24079: IFTRUE 24083
24081: GO 24101
24083: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
24084: LD_ADDR_VAR 0 3
24088: PUSH
24089: LD_INT 13
24091: PUSH
24092: LD_INT 14
24094: PUSH
24095: EMPTY
24096: LIST
24097: LIST
24098: ST_TO_ADDR
24099: GO 24418
24101: LD_INT 42
24103: DOUBLE
24104: EQUAL
24105: IFTRUE 24109
24107: GO 24135
24109: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
24110: LD_ADDR_VAR 0 3
24114: PUSH
24115: LD_INT 21
24117: PUSH
24118: LD_INT 22
24120: PUSH
24121: LD_INT 23
24123: PUSH
24124: LD_INT 24
24126: PUSH
24127: EMPTY
24128: LIST
24129: LIST
24130: LIST
24131: LIST
24132: ST_TO_ADDR
24133: GO 24418
24135: LD_INT 43
24137: DOUBLE
24138: EQUAL
24139: IFTRUE 24143
24141: GO 24169
24143: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
24144: LD_ADDR_VAR 0 3
24148: PUSH
24149: LD_INT 21
24151: PUSH
24152: LD_INT 22
24154: PUSH
24155: LD_INT 23
24157: PUSH
24158: LD_INT 24
24160: PUSH
24161: EMPTY
24162: LIST
24163: LIST
24164: LIST
24165: LIST
24166: ST_TO_ADDR
24167: GO 24418
24169: LD_INT 44
24171: DOUBLE
24172: EQUAL
24173: IFTRUE 24177
24175: GO 24203
24177: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
24178: LD_ADDR_VAR 0 3
24182: PUSH
24183: LD_INT 21
24185: PUSH
24186: LD_INT 22
24188: PUSH
24189: LD_INT 23
24191: PUSH
24192: LD_INT 24
24194: PUSH
24195: EMPTY
24196: LIST
24197: LIST
24198: LIST
24199: LIST
24200: ST_TO_ADDR
24201: GO 24418
24203: LD_INT 45
24205: DOUBLE
24206: EQUAL
24207: IFTRUE 24211
24209: GO 24237
24211: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
24212: LD_ADDR_VAR 0 3
24216: PUSH
24217: LD_INT 21
24219: PUSH
24220: LD_INT 22
24222: PUSH
24223: LD_INT 23
24225: PUSH
24226: LD_INT 24
24228: PUSH
24229: EMPTY
24230: LIST
24231: LIST
24232: LIST
24233: LIST
24234: ST_TO_ADDR
24235: GO 24418
24237: LD_INT 49
24239: DOUBLE
24240: EQUAL
24241: IFTRUE 24245
24243: GO 24271
24245: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
24246: LD_ADDR_VAR 0 3
24250: PUSH
24251: LD_INT 21
24253: PUSH
24254: LD_INT 22
24256: PUSH
24257: LD_INT 23
24259: PUSH
24260: LD_INT 24
24262: PUSH
24263: EMPTY
24264: LIST
24265: LIST
24266: LIST
24267: LIST
24268: ST_TO_ADDR
24269: GO 24418
24271: LD_INT 51
24273: DOUBLE
24274: EQUAL
24275: IFTRUE 24279
24277: GO 24305
24279: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
24280: LD_ADDR_VAR 0 3
24284: PUSH
24285: LD_INT 21
24287: PUSH
24288: LD_INT 22
24290: PUSH
24291: LD_INT 23
24293: PUSH
24294: LD_INT 24
24296: PUSH
24297: EMPTY
24298: LIST
24299: LIST
24300: LIST
24301: LIST
24302: ST_TO_ADDR
24303: GO 24418
24305: LD_INT 52
24307: DOUBLE
24308: EQUAL
24309: IFTRUE 24313
24311: GO 24339
24313: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
24314: LD_ADDR_VAR 0 3
24318: PUSH
24319: LD_INT 21
24321: PUSH
24322: LD_INT 22
24324: PUSH
24325: LD_INT 23
24327: PUSH
24328: LD_INT 24
24330: PUSH
24331: EMPTY
24332: LIST
24333: LIST
24334: LIST
24335: LIST
24336: ST_TO_ADDR
24337: GO 24418
24339: LD_INT 53
24341: DOUBLE
24342: EQUAL
24343: IFTRUE 24347
24345: GO 24365
24347: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
24348: LD_ADDR_VAR 0 3
24352: PUSH
24353: LD_INT 23
24355: PUSH
24356: LD_INT 24
24358: PUSH
24359: EMPTY
24360: LIST
24361: LIST
24362: ST_TO_ADDR
24363: GO 24418
24365: LD_INT 46
24367: DOUBLE
24368: EQUAL
24369: IFTRUE 24373
24371: GO 24391
24373: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
24374: LD_ADDR_VAR 0 3
24378: PUSH
24379: LD_INT 23
24381: PUSH
24382: LD_INT 24
24384: PUSH
24385: EMPTY
24386: LIST
24387: LIST
24388: ST_TO_ADDR
24389: GO 24418
24391: LD_INT 47
24393: DOUBLE
24394: EQUAL
24395: IFTRUE 24399
24397: GO 24417
24399: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
24400: LD_ADDR_VAR 0 3
24404: PUSH
24405: LD_INT 23
24407: PUSH
24408: LD_INT 24
24410: PUSH
24411: EMPTY
24412: LIST
24413: LIST
24414: ST_TO_ADDR
24415: GO 24418
24417: POP
// result := ( chassis in result ) ;
24418: LD_ADDR_VAR 0 3
24422: PUSH
24423: LD_VAR 0 1
24427: PUSH
24428: LD_VAR 0 3
24432: IN
24433: ST_TO_ADDR
// end ;
24434: LD_VAR 0 3
24438: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
24439: LD_INT 0
24441: PPUSH
24442: PPUSH
24443: PPUSH
24444: PPUSH
24445: PPUSH
24446: PPUSH
24447: PPUSH
// result := array ;
24448: LD_ADDR_VAR 0 5
24452: PUSH
24453: LD_VAR 0 1
24457: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
24458: LD_VAR 0 1
24462: NOT
24463: PUSH
24464: LD_VAR 0 2
24468: NOT
24469: OR
24470: PUSH
24471: LD_VAR 0 3
24475: NOT
24476: OR
24477: PUSH
24478: LD_VAR 0 2
24482: PUSH
24483: LD_VAR 0 1
24487: GREATER
24488: OR
24489: PUSH
24490: LD_VAR 0 3
24494: PUSH
24495: LD_VAR 0 1
24499: GREATER
24500: OR
24501: IFFALSE 24505
// exit ;
24503: GO 24801
// if direction then
24505: LD_VAR 0 4
24509: IFFALSE 24573
// begin d := 1 ;
24511: LD_ADDR_VAR 0 9
24515: PUSH
24516: LD_INT 1
24518: ST_TO_ADDR
// if i_from > i_to then
24519: LD_VAR 0 2
24523: PUSH
24524: LD_VAR 0 3
24528: GREATER
24529: IFFALSE 24555
// length := ( array - i_from ) + i_to else
24531: LD_ADDR_VAR 0 11
24535: PUSH
24536: LD_VAR 0 1
24540: PUSH
24541: LD_VAR 0 2
24545: MINUS
24546: PUSH
24547: LD_VAR 0 3
24551: PLUS
24552: ST_TO_ADDR
24553: GO 24571
// length := i_to - i_from ;
24555: LD_ADDR_VAR 0 11
24559: PUSH
24560: LD_VAR 0 3
24564: PUSH
24565: LD_VAR 0 2
24569: MINUS
24570: ST_TO_ADDR
// end else
24571: GO 24634
// begin d := - 1 ;
24573: LD_ADDR_VAR 0 9
24577: PUSH
24578: LD_INT 1
24580: NEG
24581: ST_TO_ADDR
// if i_from > i_to then
24582: LD_VAR 0 2
24586: PUSH
24587: LD_VAR 0 3
24591: GREATER
24592: IFFALSE 24612
// length := i_from - i_to else
24594: LD_ADDR_VAR 0 11
24598: PUSH
24599: LD_VAR 0 2
24603: PUSH
24604: LD_VAR 0 3
24608: MINUS
24609: ST_TO_ADDR
24610: GO 24634
// length := ( array - i_to ) + i_from ;
24612: LD_ADDR_VAR 0 11
24616: PUSH
24617: LD_VAR 0 1
24621: PUSH
24622: LD_VAR 0 3
24626: MINUS
24627: PUSH
24628: LD_VAR 0 2
24632: PLUS
24633: ST_TO_ADDR
// end ; if not length then
24634: LD_VAR 0 11
24638: NOT
24639: IFFALSE 24643
// exit ;
24641: GO 24801
// tmp := array ;
24643: LD_ADDR_VAR 0 10
24647: PUSH
24648: LD_VAR 0 1
24652: ST_TO_ADDR
// for i = 1 to length do
24653: LD_ADDR_VAR 0 6
24657: PUSH
24658: DOUBLE
24659: LD_INT 1
24661: DEC
24662: ST_TO_ADDR
24663: LD_VAR 0 11
24667: PUSH
24668: FOR_TO
24669: IFFALSE 24789
// begin for j = 1 to array do
24671: LD_ADDR_VAR 0 7
24675: PUSH
24676: DOUBLE
24677: LD_INT 1
24679: DEC
24680: ST_TO_ADDR
24681: LD_VAR 0 1
24685: PUSH
24686: FOR_TO
24687: IFFALSE 24775
// begin k := j + d ;
24689: LD_ADDR_VAR 0 8
24693: PUSH
24694: LD_VAR 0 7
24698: PUSH
24699: LD_VAR 0 9
24703: PLUS
24704: ST_TO_ADDR
// if k > array then
24705: LD_VAR 0 8
24709: PUSH
24710: LD_VAR 0 1
24714: GREATER
24715: IFFALSE 24725
// k := 1 ;
24717: LD_ADDR_VAR 0 8
24721: PUSH
24722: LD_INT 1
24724: ST_TO_ADDR
// if not k then
24725: LD_VAR 0 8
24729: NOT
24730: IFFALSE 24742
// k := array ;
24732: LD_ADDR_VAR 0 8
24736: PUSH
24737: LD_VAR 0 1
24741: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
24742: LD_ADDR_VAR 0 10
24746: PUSH
24747: LD_VAR 0 10
24751: PPUSH
24752: LD_VAR 0 8
24756: PPUSH
24757: LD_VAR 0 1
24761: PUSH
24762: LD_VAR 0 7
24766: ARRAY
24767: PPUSH
24768: CALL_OW 1
24772: ST_TO_ADDR
// end ;
24773: GO 24686
24775: POP
24776: POP
// array := tmp ;
24777: LD_ADDR_VAR 0 1
24781: PUSH
24782: LD_VAR 0 10
24786: ST_TO_ADDR
// end ;
24787: GO 24668
24789: POP
24790: POP
// result := array ;
24791: LD_ADDR_VAR 0 5
24795: PUSH
24796: LD_VAR 0 1
24800: ST_TO_ADDR
// end ;
24801: LD_VAR 0 5
24805: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
24806: LD_INT 0
24808: PPUSH
24809: PPUSH
// result := 0 ;
24810: LD_ADDR_VAR 0 3
24814: PUSH
24815: LD_INT 0
24817: ST_TO_ADDR
// if not array or not value in array then
24818: LD_VAR 0 1
24822: NOT
24823: PUSH
24824: LD_VAR 0 2
24828: PUSH
24829: LD_VAR 0 1
24833: IN
24834: NOT
24835: OR
24836: IFFALSE 24840
// exit ;
24838: GO 24894
// for i = 1 to array do
24840: LD_ADDR_VAR 0 4
24844: PUSH
24845: DOUBLE
24846: LD_INT 1
24848: DEC
24849: ST_TO_ADDR
24850: LD_VAR 0 1
24854: PUSH
24855: FOR_TO
24856: IFFALSE 24892
// if value = array [ i ] then
24858: LD_VAR 0 2
24862: PUSH
24863: LD_VAR 0 1
24867: PUSH
24868: LD_VAR 0 4
24872: ARRAY
24873: EQUAL
24874: IFFALSE 24890
// begin result := i ;
24876: LD_ADDR_VAR 0 3
24880: PUSH
24881: LD_VAR 0 4
24885: ST_TO_ADDR
// exit ;
24886: POP
24887: POP
24888: GO 24894
// end ;
24890: GO 24855
24892: POP
24893: POP
// end ;
24894: LD_VAR 0 3
24898: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
24899: LD_INT 0
24901: PPUSH
// vc_chassis := chassis ;
24902: LD_ADDR_OWVAR 37
24906: PUSH
24907: LD_VAR 0 1
24911: ST_TO_ADDR
// vc_engine := engine ;
24912: LD_ADDR_OWVAR 39
24916: PUSH
24917: LD_VAR 0 2
24921: ST_TO_ADDR
// vc_control := control ;
24922: LD_ADDR_OWVAR 38
24926: PUSH
24927: LD_VAR 0 3
24931: ST_TO_ADDR
// vc_weapon := weapon ;
24932: LD_ADDR_OWVAR 40
24936: PUSH
24937: LD_VAR 0 4
24941: ST_TO_ADDR
// vc_fuel_battery := fuel ;
24942: LD_ADDR_OWVAR 41
24946: PUSH
24947: LD_VAR 0 5
24951: ST_TO_ADDR
// end ;
24952: LD_VAR 0 6
24956: RET
// export function WantPlant ( unit ) ; var task ; begin
24957: LD_INT 0
24959: PPUSH
24960: PPUSH
// result := false ;
24961: LD_ADDR_VAR 0 2
24965: PUSH
24966: LD_INT 0
24968: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
24969: LD_ADDR_VAR 0 3
24973: PUSH
24974: LD_VAR 0 1
24978: PPUSH
24979: CALL_OW 437
24983: ST_TO_ADDR
// if task then
24984: LD_VAR 0 3
24988: IFFALSE 25016
// if task [ 1 ] [ 1 ] = p then
24990: LD_VAR 0 3
24994: PUSH
24995: LD_INT 1
24997: ARRAY
24998: PUSH
24999: LD_INT 1
25001: ARRAY
25002: PUSH
25003: LD_STRING p
25005: EQUAL
25006: IFFALSE 25016
// result := true ;
25008: LD_ADDR_VAR 0 2
25012: PUSH
25013: LD_INT 1
25015: ST_TO_ADDR
// end ;
25016: LD_VAR 0 2
25020: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
25021: LD_INT 0
25023: PPUSH
25024: PPUSH
25025: PPUSH
25026: PPUSH
// if pos < 1 then
25027: LD_VAR 0 2
25031: PUSH
25032: LD_INT 1
25034: LESS
25035: IFFALSE 25039
// exit ;
25037: GO 25342
// if pos = 1 then
25039: LD_VAR 0 2
25043: PUSH
25044: LD_INT 1
25046: EQUAL
25047: IFFALSE 25080
// result := Replace ( arr , pos [ 1 ] , value ) else
25049: LD_ADDR_VAR 0 4
25053: PUSH
25054: LD_VAR 0 1
25058: PPUSH
25059: LD_VAR 0 2
25063: PUSH
25064: LD_INT 1
25066: ARRAY
25067: PPUSH
25068: LD_VAR 0 3
25072: PPUSH
25073: CALL_OW 1
25077: ST_TO_ADDR
25078: GO 25342
// begin tmp := arr ;
25080: LD_ADDR_VAR 0 6
25084: PUSH
25085: LD_VAR 0 1
25089: ST_TO_ADDR
// s_arr := [ tmp ] ;
25090: LD_ADDR_VAR 0 7
25094: PUSH
25095: LD_VAR 0 6
25099: PUSH
25100: EMPTY
25101: LIST
25102: ST_TO_ADDR
// for i = 1 to pos - 1 do
25103: LD_ADDR_VAR 0 5
25107: PUSH
25108: DOUBLE
25109: LD_INT 1
25111: DEC
25112: ST_TO_ADDR
25113: LD_VAR 0 2
25117: PUSH
25118: LD_INT 1
25120: MINUS
25121: PUSH
25122: FOR_TO
25123: IFFALSE 25168
// begin tmp := tmp [ pos [ i ] ] ;
25125: LD_ADDR_VAR 0 6
25129: PUSH
25130: LD_VAR 0 6
25134: PUSH
25135: LD_VAR 0 2
25139: PUSH
25140: LD_VAR 0 5
25144: ARRAY
25145: ARRAY
25146: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
25147: LD_ADDR_VAR 0 7
25151: PUSH
25152: LD_VAR 0 7
25156: PUSH
25157: LD_VAR 0 6
25161: PUSH
25162: EMPTY
25163: LIST
25164: ADD
25165: ST_TO_ADDR
// end ;
25166: GO 25122
25168: POP
25169: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
25170: LD_ADDR_VAR 0 6
25174: PUSH
25175: LD_VAR 0 6
25179: PPUSH
25180: LD_VAR 0 2
25184: PUSH
25185: LD_VAR 0 2
25189: ARRAY
25190: PPUSH
25191: LD_VAR 0 3
25195: PPUSH
25196: CALL_OW 1
25200: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
25201: LD_ADDR_VAR 0 7
25205: PUSH
25206: LD_VAR 0 7
25210: PPUSH
25211: LD_VAR 0 7
25215: PPUSH
25216: LD_VAR 0 6
25220: PPUSH
25221: CALL_OW 1
25225: ST_TO_ADDR
// for i = s_arr downto 2 do
25226: LD_ADDR_VAR 0 5
25230: PUSH
25231: DOUBLE
25232: LD_VAR 0 7
25236: INC
25237: ST_TO_ADDR
25238: LD_INT 2
25240: PUSH
25241: FOR_DOWNTO
25242: IFFALSE 25326
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
25244: LD_ADDR_VAR 0 6
25248: PUSH
25249: LD_VAR 0 7
25253: PUSH
25254: LD_VAR 0 5
25258: PUSH
25259: LD_INT 1
25261: MINUS
25262: ARRAY
25263: PPUSH
25264: LD_VAR 0 2
25268: PUSH
25269: LD_VAR 0 5
25273: PUSH
25274: LD_INT 1
25276: MINUS
25277: ARRAY
25278: PPUSH
25279: LD_VAR 0 7
25283: PUSH
25284: LD_VAR 0 5
25288: ARRAY
25289: PPUSH
25290: CALL_OW 1
25294: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
25295: LD_ADDR_VAR 0 7
25299: PUSH
25300: LD_VAR 0 7
25304: PPUSH
25305: LD_VAR 0 5
25309: PUSH
25310: LD_INT 1
25312: MINUS
25313: PPUSH
25314: LD_VAR 0 6
25318: PPUSH
25319: CALL_OW 1
25323: ST_TO_ADDR
// end ;
25324: GO 25241
25326: POP
25327: POP
// result := s_arr [ 1 ] ;
25328: LD_ADDR_VAR 0 4
25332: PUSH
25333: LD_VAR 0 7
25337: PUSH
25338: LD_INT 1
25340: ARRAY
25341: ST_TO_ADDR
// end ; end ;
25342: LD_VAR 0 4
25346: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
25347: LD_INT 0
25349: PPUSH
25350: PPUSH
// if not list then
25351: LD_VAR 0 1
25355: NOT
25356: IFFALSE 25360
// exit ;
25358: GO 25451
// i := list [ pos1 ] ;
25360: LD_ADDR_VAR 0 5
25364: PUSH
25365: LD_VAR 0 1
25369: PUSH
25370: LD_VAR 0 2
25374: ARRAY
25375: ST_TO_ADDR
// if not i then
25376: LD_VAR 0 5
25380: NOT
25381: IFFALSE 25385
// exit ;
25383: GO 25451
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
25385: LD_ADDR_VAR 0 1
25389: PUSH
25390: LD_VAR 0 1
25394: PPUSH
25395: LD_VAR 0 2
25399: PPUSH
25400: LD_VAR 0 1
25404: PUSH
25405: LD_VAR 0 3
25409: ARRAY
25410: PPUSH
25411: CALL_OW 1
25415: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
25416: LD_ADDR_VAR 0 1
25420: PUSH
25421: LD_VAR 0 1
25425: PPUSH
25426: LD_VAR 0 3
25430: PPUSH
25431: LD_VAR 0 5
25435: PPUSH
25436: CALL_OW 1
25440: ST_TO_ADDR
// result := list ;
25441: LD_ADDR_VAR 0 4
25445: PUSH
25446: LD_VAR 0 1
25450: ST_TO_ADDR
// end ;
25451: LD_VAR 0 4
25455: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
25456: LD_INT 0
25458: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
25459: LD_ADDR_VAR 0 5
25463: PUSH
25464: LD_VAR 0 1
25468: PPUSH
25469: CALL_OW 250
25473: PPUSH
25474: LD_VAR 0 1
25478: PPUSH
25479: CALL_OW 251
25483: PPUSH
25484: LD_VAR 0 2
25488: PPUSH
25489: LD_VAR 0 3
25493: PPUSH
25494: LD_VAR 0 4
25498: PPUSH
25499: CALL 25509 0 5
25503: ST_TO_ADDR
// end ;
25504: LD_VAR 0 5
25508: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
25509: LD_INT 0
25511: PPUSH
25512: PPUSH
25513: PPUSH
25514: PPUSH
// if not list then
25515: LD_VAR 0 3
25519: NOT
25520: IFFALSE 25524
// exit ;
25522: GO 25912
// result := [ ] ;
25524: LD_ADDR_VAR 0 6
25528: PUSH
25529: EMPTY
25530: ST_TO_ADDR
// for i in list do
25531: LD_ADDR_VAR 0 7
25535: PUSH
25536: LD_VAR 0 3
25540: PUSH
25541: FOR_IN
25542: IFFALSE 25744
// begin tmp := GetDistUnitXY ( i , x , y ) ;
25544: LD_ADDR_VAR 0 9
25548: PUSH
25549: LD_VAR 0 7
25553: PPUSH
25554: LD_VAR 0 1
25558: PPUSH
25559: LD_VAR 0 2
25563: PPUSH
25564: CALL_OW 297
25568: ST_TO_ADDR
// if not result then
25569: LD_VAR 0 6
25573: NOT
25574: IFFALSE 25600
// result := [ [ i , tmp ] ] else
25576: LD_ADDR_VAR 0 6
25580: PUSH
25581: LD_VAR 0 7
25585: PUSH
25586: LD_VAR 0 9
25590: PUSH
25591: EMPTY
25592: LIST
25593: LIST
25594: PUSH
25595: EMPTY
25596: LIST
25597: ST_TO_ADDR
25598: GO 25742
// begin if result [ result ] [ 2 ] < tmp then
25600: LD_VAR 0 6
25604: PUSH
25605: LD_VAR 0 6
25609: ARRAY
25610: PUSH
25611: LD_INT 2
25613: ARRAY
25614: PUSH
25615: LD_VAR 0 9
25619: LESS
25620: IFFALSE 25662
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
25622: LD_ADDR_VAR 0 6
25626: PUSH
25627: LD_VAR 0 6
25631: PPUSH
25632: LD_VAR 0 6
25636: PUSH
25637: LD_INT 1
25639: PLUS
25640: PPUSH
25641: LD_VAR 0 7
25645: PUSH
25646: LD_VAR 0 9
25650: PUSH
25651: EMPTY
25652: LIST
25653: LIST
25654: PPUSH
25655: CALL_OW 2
25659: ST_TO_ADDR
25660: GO 25742
// for j = 1 to result do
25662: LD_ADDR_VAR 0 8
25666: PUSH
25667: DOUBLE
25668: LD_INT 1
25670: DEC
25671: ST_TO_ADDR
25672: LD_VAR 0 6
25676: PUSH
25677: FOR_TO
25678: IFFALSE 25740
// begin if tmp < result [ j ] [ 2 ] then
25680: LD_VAR 0 9
25684: PUSH
25685: LD_VAR 0 6
25689: PUSH
25690: LD_VAR 0 8
25694: ARRAY
25695: PUSH
25696: LD_INT 2
25698: ARRAY
25699: LESS
25700: IFFALSE 25738
// begin result := Insert ( result , j , [ i , tmp ] ) ;
25702: LD_ADDR_VAR 0 6
25706: PUSH
25707: LD_VAR 0 6
25711: PPUSH
25712: LD_VAR 0 8
25716: PPUSH
25717: LD_VAR 0 7
25721: PUSH
25722: LD_VAR 0 9
25726: PUSH
25727: EMPTY
25728: LIST
25729: LIST
25730: PPUSH
25731: CALL_OW 2
25735: ST_TO_ADDR
// break ;
25736: GO 25740
// end ; end ;
25738: GO 25677
25740: POP
25741: POP
// end ; end ;
25742: GO 25541
25744: POP
25745: POP
// if result and not asc then
25746: LD_VAR 0 6
25750: PUSH
25751: LD_VAR 0 4
25755: NOT
25756: AND
25757: IFFALSE 25832
// begin tmp := result ;
25759: LD_ADDR_VAR 0 9
25763: PUSH
25764: LD_VAR 0 6
25768: ST_TO_ADDR
// for i = tmp downto 1 do
25769: LD_ADDR_VAR 0 7
25773: PUSH
25774: DOUBLE
25775: LD_VAR 0 9
25779: INC
25780: ST_TO_ADDR
25781: LD_INT 1
25783: PUSH
25784: FOR_DOWNTO
25785: IFFALSE 25830
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
25787: LD_ADDR_VAR 0 6
25791: PUSH
25792: LD_VAR 0 6
25796: PPUSH
25797: LD_VAR 0 9
25801: PUSH
25802: LD_VAR 0 7
25806: MINUS
25807: PUSH
25808: LD_INT 1
25810: PLUS
25811: PPUSH
25812: LD_VAR 0 9
25816: PUSH
25817: LD_VAR 0 7
25821: ARRAY
25822: PPUSH
25823: CALL_OW 1
25827: ST_TO_ADDR
25828: GO 25784
25830: POP
25831: POP
// end ; tmp := [ ] ;
25832: LD_ADDR_VAR 0 9
25836: PUSH
25837: EMPTY
25838: ST_TO_ADDR
// if mode then
25839: LD_VAR 0 5
25843: IFFALSE 25912
// begin for i = 1 to result do
25845: LD_ADDR_VAR 0 7
25849: PUSH
25850: DOUBLE
25851: LD_INT 1
25853: DEC
25854: ST_TO_ADDR
25855: LD_VAR 0 6
25859: PUSH
25860: FOR_TO
25861: IFFALSE 25900
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
25863: LD_ADDR_VAR 0 9
25867: PUSH
25868: LD_VAR 0 9
25872: PPUSH
25873: LD_VAR 0 7
25877: PPUSH
25878: LD_VAR 0 6
25882: PUSH
25883: LD_VAR 0 7
25887: ARRAY
25888: PUSH
25889: LD_INT 1
25891: ARRAY
25892: PPUSH
25893: CALL_OW 1
25897: ST_TO_ADDR
25898: GO 25860
25900: POP
25901: POP
// result := tmp ;
25902: LD_ADDR_VAR 0 6
25906: PUSH
25907: LD_VAR 0 9
25911: ST_TO_ADDR
// end ; end ;
25912: LD_VAR 0 6
25916: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
25917: LD_INT 0
25919: PPUSH
25920: PPUSH
25921: PPUSH
25922: PPUSH
25923: PPUSH
25924: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
25925: LD_ADDR_VAR 0 5
25929: PUSH
25930: LD_INT 0
25932: PUSH
25933: LD_INT 0
25935: PUSH
25936: LD_INT 0
25938: PUSH
25939: EMPTY
25940: PUSH
25941: EMPTY
25942: LIST
25943: LIST
25944: LIST
25945: LIST
25946: ST_TO_ADDR
// if not x or not y then
25947: LD_VAR 0 2
25951: NOT
25952: PUSH
25953: LD_VAR 0 3
25957: NOT
25958: OR
25959: IFFALSE 25963
// exit ;
25961: GO 27613
// if not range then
25963: LD_VAR 0 4
25967: NOT
25968: IFFALSE 25978
// range := 10 ;
25970: LD_ADDR_VAR 0 4
25974: PUSH
25975: LD_INT 10
25977: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
25978: LD_ADDR_VAR 0 8
25982: PUSH
25983: LD_INT 81
25985: PUSH
25986: LD_VAR 0 1
25990: PUSH
25991: EMPTY
25992: LIST
25993: LIST
25994: PUSH
25995: LD_INT 92
25997: PUSH
25998: LD_VAR 0 2
26002: PUSH
26003: LD_VAR 0 3
26007: PUSH
26008: LD_VAR 0 4
26012: PUSH
26013: EMPTY
26014: LIST
26015: LIST
26016: LIST
26017: LIST
26018: PUSH
26019: LD_INT 3
26021: PUSH
26022: LD_INT 21
26024: PUSH
26025: LD_INT 3
26027: PUSH
26028: EMPTY
26029: LIST
26030: LIST
26031: PUSH
26032: EMPTY
26033: LIST
26034: LIST
26035: PUSH
26036: EMPTY
26037: LIST
26038: LIST
26039: LIST
26040: PPUSH
26041: CALL_OW 69
26045: ST_TO_ADDR
// if not tmp then
26046: LD_VAR 0 8
26050: NOT
26051: IFFALSE 26055
// exit ;
26053: GO 27613
// for i in tmp do
26055: LD_ADDR_VAR 0 6
26059: PUSH
26060: LD_VAR 0 8
26064: PUSH
26065: FOR_IN
26066: IFFALSE 27588
// begin points := [ 0 , 0 , 0 ] ;
26068: LD_ADDR_VAR 0 9
26072: PUSH
26073: LD_INT 0
26075: PUSH
26076: LD_INT 0
26078: PUSH
26079: LD_INT 0
26081: PUSH
26082: EMPTY
26083: LIST
26084: LIST
26085: LIST
26086: ST_TO_ADDR
// bpoints := 1 ;
26087: LD_ADDR_VAR 0 10
26091: PUSH
26092: LD_INT 1
26094: ST_TO_ADDR
// case GetType ( i ) of unit_human :
26095: LD_VAR 0 6
26099: PPUSH
26100: CALL_OW 247
26104: PUSH
26105: LD_INT 1
26107: DOUBLE
26108: EQUAL
26109: IFTRUE 26113
26111: GO 26691
26113: POP
// begin if GetClass ( i ) = 1 then
26114: LD_VAR 0 6
26118: PPUSH
26119: CALL_OW 257
26123: PUSH
26124: LD_INT 1
26126: EQUAL
26127: IFFALSE 26148
// points := [ 10 , 5 , 3 ] ;
26129: LD_ADDR_VAR 0 9
26133: PUSH
26134: LD_INT 10
26136: PUSH
26137: LD_INT 5
26139: PUSH
26140: LD_INT 3
26142: PUSH
26143: EMPTY
26144: LIST
26145: LIST
26146: LIST
26147: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
26148: LD_VAR 0 6
26152: PPUSH
26153: CALL_OW 257
26157: PUSH
26158: LD_INT 2
26160: PUSH
26161: LD_INT 3
26163: PUSH
26164: LD_INT 4
26166: PUSH
26167: EMPTY
26168: LIST
26169: LIST
26170: LIST
26171: IN
26172: IFFALSE 26193
// points := [ 3 , 2 , 1 ] ;
26174: LD_ADDR_VAR 0 9
26178: PUSH
26179: LD_INT 3
26181: PUSH
26182: LD_INT 2
26184: PUSH
26185: LD_INT 1
26187: PUSH
26188: EMPTY
26189: LIST
26190: LIST
26191: LIST
26192: ST_TO_ADDR
// if GetClass ( i ) = 5 then
26193: LD_VAR 0 6
26197: PPUSH
26198: CALL_OW 257
26202: PUSH
26203: LD_INT 5
26205: EQUAL
26206: IFFALSE 26227
// points := [ 130 , 5 , 2 ] ;
26208: LD_ADDR_VAR 0 9
26212: PUSH
26213: LD_INT 130
26215: PUSH
26216: LD_INT 5
26218: PUSH
26219: LD_INT 2
26221: PUSH
26222: EMPTY
26223: LIST
26224: LIST
26225: LIST
26226: ST_TO_ADDR
// if GetClass ( i ) = 8 then
26227: LD_VAR 0 6
26231: PPUSH
26232: CALL_OW 257
26236: PUSH
26237: LD_INT 8
26239: EQUAL
26240: IFFALSE 26261
// points := [ 35 , 35 , 30 ] ;
26242: LD_ADDR_VAR 0 9
26246: PUSH
26247: LD_INT 35
26249: PUSH
26250: LD_INT 35
26252: PUSH
26253: LD_INT 30
26255: PUSH
26256: EMPTY
26257: LIST
26258: LIST
26259: LIST
26260: ST_TO_ADDR
// if GetClass ( i ) = 9 then
26261: LD_VAR 0 6
26265: PPUSH
26266: CALL_OW 257
26270: PUSH
26271: LD_INT 9
26273: EQUAL
26274: IFFALSE 26295
// points := [ 20 , 55 , 40 ] ;
26276: LD_ADDR_VAR 0 9
26280: PUSH
26281: LD_INT 20
26283: PUSH
26284: LD_INT 55
26286: PUSH
26287: LD_INT 40
26289: PUSH
26290: EMPTY
26291: LIST
26292: LIST
26293: LIST
26294: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
26295: LD_VAR 0 6
26299: PPUSH
26300: CALL_OW 257
26304: PUSH
26305: LD_INT 12
26307: PUSH
26308: LD_INT 16
26310: PUSH
26311: EMPTY
26312: LIST
26313: LIST
26314: IN
26315: IFFALSE 26336
// points := [ 5 , 3 , 2 ] ;
26317: LD_ADDR_VAR 0 9
26321: PUSH
26322: LD_INT 5
26324: PUSH
26325: LD_INT 3
26327: PUSH
26328: LD_INT 2
26330: PUSH
26331: EMPTY
26332: LIST
26333: LIST
26334: LIST
26335: ST_TO_ADDR
// if GetClass ( i ) = 17 then
26336: LD_VAR 0 6
26340: PPUSH
26341: CALL_OW 257
26345: PUSH
26346: LD_INT 17
26348: EQUAL
26349: IFFALSE 26370
// points := [ 100 , 50 , 75 ] ;
26351: LD_ADDR_VAR 0 9
26355: PUSH
26356: LD_INT 100
26358: PUSH
26359: LD_INT 50
26361: PUSH
26362: LD_INT 75
26364: PUSH
26365: EMPTY
26366: LIST
26367: LIST
26368: LIST
26369: ST_TO_ADDR
// if GetClass ( i ) = 15 then
26370: LD_VAR 0 6
26374: PPUSH
26375: CALL_OW 257
26379: PUSH
26380: LD_INT 15
26382: EQUAL
26383: IFFALSE 26404
// points := [ 10 , 5 , 3 ] ;
26385: LD_ADDR_VAR 0 9
26389: PUSH
26390: LD_INT 10
26392: PUSH
26393: LD_INT 5
26395: PUSH
26396: LD_INT 3
26398: PUSH
26399: EMPTY
26400: LIST
26401: LIST
26402: LIST
26403: ST_TO_ADDR
// if GetClass ( i ) = 14 then
26404: LD_VAR 0 6
26408: PPUSH
26409: CALL_OW 257
26413: PUSH
26414: LD_INT 14
26416: EQUAL
26417: IFFALSE 26438
// points := [ 10 , 0 , 0 ] ;
26419: LD_ADDR_VAR 0 9
26423: PUSH
26424: LD_INT 10
26426: PUSH
26427: LD_INT 0
26429: PUSH
26430: LD_INT 0
26432: PUSH
26433: EMPTY
26434: LIST
26435: LIST
26436: LIST
26437: ST_TO_ADDR
// if GetClass ( i ) = 11 then
26438: LD_VAR 0 6
26442: PPUSH
26443: CALL_OW 257
26447: PUSH
26448: LD_INT 11
26450: EQUAL
26451: IFFALSE 26472
// points := [ 30 , 10 , 5 ] ;
26453: LD_ADDR_VAR 0 9
26457: PUSH
26458: LD_INT 30
26460: PUSH
26461: LD_INT 10
26463: PUSH
26464: LD_INT 5
26466: PUSH
26467: EMPTY
26468: LIST
26469: LIST
26470: LIST
26471: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
26472: LD_VAR 0 1
26476: PPUSH
26477: LD_INT 5
26479: PPUSH
26480: CALL_OW 321
26484: PUSH
26485: LD_INT 2
26487: EQUAL
26488: IFFALSE 26505
// bpoints := bpoints * 1.8 ;
26490: LD_ADDR_VAR 0 10
26494: PUSH
26495: LD_VAR 0 10
26499: PUSH
26500: LD_REAL  1.80000000000000E+0000
26503: MUL
26504: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
26505: LD_VAR 0 6
26509: PPUSH
26510: CALL_OW 257
26514: PUSH
26515: LD_INT 1
26517: PUSH
26518: LD_INT 2
26520: PUSH
26521: LD_INT 3
26523: PUSH
26524: LD_INT 4
26526: PUSH
26527: EMPTY
26528: LIST
26529: LIST
26530: LIST
26531: LIST
26532: IN
26533: PUSH
26534: LD_VAR 0 1
26538: PPUSH
26539: LD_INT 51
26541: PPUSH
26542: CALL_OW 321
26546: PUSH
26547: LD_INT 2
26549: EQUAL
26550: AND
26551: IFFALSE 26568
// bpoints := bpoints * 1.2 ;
26553: LD_ADDR_VAR 0 10
26557: PUSH
26558: LD_VAR 0 10
26562: PUSH
26563: LD_REAL  1.20000000000000E+0000
26566: MUL
26567: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
26568: LD_VAR 0 6
26572: PPUSH
26573: CALL_OW 257
26577: PUSH
26578: LD_INT 5
26580: PUSH
26581: LD_INT 7
26583: PUSH
26584: LD_INT 9
26586: PUSH
26587: EMPTY
26588: LIST
26589: LIST
26590: LIST
26591: IN
26592: PUSH
26593: LD_VAR 0 1
26597: PPUSH
26598: LD_INT 52
26600: PPUSH
26601: CALL_OW 321
26605: PUSH
26606: LD_INT 2
26608: EQUAL
26609: AND
26610: IFFALSE 26627
// bpoints := bpoints * 1.5 ;
26612: LD_ADDR_VAR 0 10
26616: PUSH
26617: LD_VAR 0 10
26621: PUSH
26622: LD_REAL  1.50000000000000E+0000
26625: MUL
26626: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
26627: LD_VAR 0 1
26631: PPUSH
26632: LD_INT 66
26634: PPUSH
26635: CALL_OW 321
26639: PUSH
26640: LD_INT 2
26642: EQUAL
26643: IFFALSE 26660
// bpoints := bpoints * 1.1 ;
26645: LD_ADDR_VAR 0 10
26649: PUSH
26650: LD_VAR 0 10
26654: PUSH
26655: LD_REAL  1.10000000000000E+0000
26658: MUL
26659: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
26660: LD_ADDR_VAR 0 10
26664: PUSH
26665: LD_VAR 0 10
26669: PUSH
26670: LD_VAR 0 6
26674: PPUSH
26675: LD_INT 1
26677: PPUSH
26678: CALL_OW 259
26682: PUSH
26683: LD_REAL  1.15000000000000E+0000
26686: MUL
26687: MUL
26688: ST_TO_ADDR
// end ; unit_vehicle :
26689: GO 27517
26691: LD_INT 2
26693: DOUBLE
26694: EQUAL
26695: IFTRUE 26699
26697: GO 27505
26699: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
26700: LD_VAR 0 6
26704: PPUSH
26705: CALL_OW 264
26709: PUSH
26710: LD_INT 2
26712: PUSH
26713: LD_INT 42
26715: PUSH
26716: LD_INT 24
26718: PUSH
26719: EMPTY
26720: LIST
26721: LIST
26722: LIST
26723: IN
26724: IFFALSE 26745
// points := [ 25 , 5 , 3 ] ;
26726: LD_ADDR_VAR 0 9
26730: PUSH
26731: LD_INT 25
26733: PUSH
26734: LD_INT 5
26736: PUSH
26737: LD_INT 3
26739: PUSH
26740: EMPTY
26741: LIST
26742: LIST
26743: LIST
26744: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
26745: LD_VAR 0 6
26749: PPUSH
26750: CALL_OW 264
26754: PUSH
26755: LD_INT 4
26757: PUSH
26758: LD_INT 43
26760: PUSH
26761: LD_INT 25
26763: PUSH
26764: EMPTY
26765: LIST
26766: LIST
26767: LIST
26768: IN
26769: IFFALSE 26790
// points := [ 40 , 15 , 5 ] ;
26771: LD_ADDR_VAR 0 9
26775: PUSH
26776: LD_INT 40
26778: PUSH
26779: LD_INT 15
26781: PUSH
26782: LD_INT 5
26784: PUSH
26785: EMPTY
26786: LIST
26787: LIST
26788: LIST
26789: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
26790: LD_VAR 0 6
26794: PPUSH
26795: CALL_OW 264
26799: PUSH
26800: LD_INT 3
26802: PUSH
26803: LD_INT 23
26805: PUSH
26806: EMPTY
26807: LIST
26808: LIST
26809: IN
26810: IFFALSE 26831
// points := [ 7 , 25 , 8 ] ;
26812: LD_ADDR_VAR 0 9
26816: PUSH
26817: LD_INT 7
26819: PUSH
26820: LD_INT 25
26822: PUSH
26823: LD_INT 8
26825: PUSH
26826: EMPTY
26827: LIST
26828: LIST
26829: LIST
26830: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
26831: LD_VAR 0 6
26835: PPUSH
26836: CALL_OW 264
26840: PUSH
26841: LD_INT 5
26843: PUSH
26844: LD_INT 27
26846: PUSH
26847: LD_INT 44
26849: PUSH
26850: EMPTY
26851: LIST
26852: LIST
26853: LIST
26854: IN
26855: IFFALSE 26876
// points := [ 14 , 50 , 16 ] ;
26857: LD_ADDR_VAR 0 9
26861: PUSH
26862: LD_INT 14
26864: PUSH
26865: LD_INT 50
26867: PUSH
26868: LD_INT 16
26870: PUSH
26871: EMPTY
26872: LIST
26873: LIST
26874: LIST
26875: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
26876: LD_VAR 0 6
26880: PPUSH
26881: CALL_OW 264
26885: PUSH
26886: LD_INT 6
26888: PUSH
26889: LD_INT 46
26891: PUSH
26892: EMPTY
26893: LIST
26894: LIST
26895: IN
26896: IFFALSE 26917
// points := [ 32 , 120 , 70 ] ;
26898: LD_ADDR_VAR 0 9
26902: PUSH
26903: LD_INT 32
26905: PUSH
26906: LD_INT 120
26908: PUSH
26909: LD_INT 70
26911: PUSH
26912: EMPTY
26913: LIST
26914: LIST
26915: LIST
26916: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
26917: LD_VAR 0 6
26921: PPUSH
26922: CALL_OW 264
26926: PUSH
26927: LD_INT 7
26929: PUSH
26930: LD_INT 28
26932: PUSH
26933: LD_INT 45
26935: PUSH
26936: LD_INT 92
26938: PUSH
26939: EMPTY
26940: LIST
26941: LIST
26942: LIST
26943: LIST
26944: IN
26945: IFFALSE 26966
// points := [ 35 , 20 , 45 ] ;
26947: LD_ADDR_VAR 0 9
26951: PUSH
26952: LD_INT 35
26954: PUSH
26955: LD_INT 20
26957: PUSH
26958: LD_INT 45
26960: PUSH
26961: EMPTY
26962: LIST
26963: LIST
26964: LIST
26965: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
26966: LD_VAR 0 6
26970: PPUSH
26971: CALL_OW 264
26975: PUSH
26976: LD_INT 47
26978: PUSH
26979: EMPTY
26980: LIST
26981: IN
26982: IFFALSE 27003
// points := [ 67 , 45 , 75 ] ;
26984: LD_ADDR_VAR 0 9
26988: PUSH
26989: LD_INT 67
26991: PUSH
26992: LD_INT 45
26994: PUSH
26995: LD_INT 75
26997: PUSH
26998: EMPTY
26999: LIST
27000: LIST
27001: LIST
27002: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
27003: LD_VAR 0 6
27007: PPUSH
27008: CALL_OW 264
27012: PUSH
27013: LD_INT 26
27015: PUSH
27016: EMPTY
27017: LIST
27018: IN
27019: IFFALSE 27040
// points := [ 120 , 30 , 80 ] ;
27021: LD_ADDR_VAR 0 9
27025: PUSH
27026: LD_INT 120
27028: PUSH
27029: LD_INT 30
27031: PUSH
27032: LD_INT 80
27034: PUSH
27035: EMPTY
27036: LIST
27037: LIST
27038: LIST
27039: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
27040: LD_VAR 0 6
27044: PPUSH
27045: CALL_OW 264
27049: PUSH
27050: LD_INT 22
27052: PUSH
27053: EMPTY
27054: LIST
27055: IN
27056: IFFALSE 27077
// points := [ 40 , 1 , 1 ] ;
27058: LD_ADDR_VAR 0 9
27062: PUSH
27063: LD_INT 40
27065: PUSH
27066: LD_INT 1
27068: PUSH
27069: LD_INT 1
27071: PUSH
27072: EMPTY
27073: LIST
27074: LIST
27075: LIST
27076: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
27077: LD_VAR 0 6
27081: PPUSH
27082: CALL_OW 264
27086: PUSH
27087: LD_INT 29
27089: PUSH
27090: EMPTY
27091: LIST
27092: IN
27093: IFFALSE 27114
// points := [ 70 , 200 , 400 ] ;
27095: LD_ADDR_VAR 0 9
27099: PUSH
27100: LD_INT 70
27102: PUSH
27103: LD_INT 200
27105: PUSH
27106: LD_INT 400
27108: PUSH
27109: EMPTY
27110: LIST
27111: LIST
27112: LIST
27113: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
27114: LD_VAR 0 6
27118: PPUSH
27119: CALL_OW 264
27123: PUSH
27124: LD_INT 14
27126: PUSH
27127: LD_INT 53
27129: PUSH
27130: EMPTY
27131: LIST
27132: LIST
27133: IN
27134: IFFALSE 27155
// points := [ 40 , 10 , 20 ] ;
27136: LD_ADDR_VAR 0 9
27140: PUSH
27141: LD_INT 40
27143: PUSH
27144: LD_INT 10
27146: PUSH
27147: LD_INT 20
27149: PUSH
27150: EMPTY
27151: LIST
27152: LIST
27153: LIST
27154: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
27155: LD_VAR 0 6
27159: PPUSH
27160: CALL_OW 264
27164: PUSH
27165: LD_INT 9
27167: PUSH
27168: EMPTY
27169: LIST
27170: IN
27171: IFFALSE 27192
// points := [ 5 , 70 , 20 ] ;
27173: LD_ADDR_VAR 0 9
27177: PUSH
27178: LD_INT 5
27180: PUSH
27181: LD_INT 70
27183: PUSH
27184: LD_INT 20
27186: PUSH
27187: EMPTY
27188: LIST
27189: LIST
27190: LIST
27191: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
27192: LD_VAR 0 6
27196: PPUSH
27197: CALL_OW 264
27201: PUSH
27202: LD_INT 10
27204: PUSH
27205: EMPTY
27206: LIST
27207: IN
27208: IFFALSE 27229
// points := [ 35 , 110 , 70 ] ;
27210: LD_ADDR_VAR 0 9
27214: PUSH
27215: LD_INT 35
27217: PUSH
27218: LD_INT 110
27220: PUSH
27221: LD_INT 70
27223: PUSH
27224: EMPTY
27225: LIST
27226: LIST
27227: LIST
27228: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
27229: LD_VAR 0 6
27233: PPUSH
27234: CALL_OW 265
27238: PUSH
27239: LD_INT 25
27241: EQUAL
27242: IFFALSE 27263
// points := [ 80 , 65 , 100 ] ;
27244: LD_ADDR_VAR 0 9
27248: PUSH
27249: LD_INT 80
27251: PUSH
27252: LD_INT 65
27254: PUSH
27255: LD_INT 100
27257: PUSH
27258: EMPTY
27259: LIST
27260: LIST
27261: LIST
27262: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
27263: LD_VAR 0 6
27267: PPUSH
27268: CALL_OW 263
27272: PUSH
27273: LD_INT 1
27275: EQUAL
27276: IFFALSE 27311
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
27278: LD_ADDR_VAR 0 10
27282: PUSH
27283: LD_VAR 0 10
27287: PUSH
27288: LD_VAR 0 6
27292: PPUSH
27293: CALL_OW 311
27297: PPUSH
27298: LD_INT 3
27300: PPUSH
27301: CALL_OW 259
27305: PUSH
27306: LD_INT 4
27308: MUL
27309: MUL
27310: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
27311: LD_VAR 0 6
27315: PPUSH
27316: CALL_OW 263
27320: PUSH
27321: LD_INT 2
27323: EQUAL
27324: IFFALSE 27375
// begin j := IsControledBy ( i ) ;
27326: LD_ADDR_VAR 0 7
27330: PUSH
27331: LD_VAR 0 6
27335: PPUSH
27336: CALL_OW 312
27340: ST_TO_ADDR
// if j then
27341: LD_VAR 0 7
27345: IFFALSE 27375
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
27347: LD_ADDR_VAR 0 10
27351: PUSH
27352: LD_VAR 0 10
27356: PUSH
27357: LD_VAR 0 7
27361: PPUSH
27362: LD_INT 3
27364: PPUSH
27365: CALL_OW 259
27369: PUSH
27370: LD_INT 3
27372: MUL
27373: MUL
27374: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
27375: LD_VAR 0 6
27379: PPUSH
27380: CALL_OW 264
27384: PUSH
27385: LD_INT 5
27387: PUSH
27388: LD_INT 6
27390: PUSH
27391: LD_INT 46
27393: PUSH
27394: LD_INT 44
27396: PUSH
27397: LD_INT 47
27399: PUSH
27400: LD_INT 45
27402: PUSH
27403: LD_INT 28
27405: PUSH
27406: LD_INT 7
27408: PUSH
27409: LD_INT 27
27411: PUSH
27412: LD_INT 29
27414: PUSH
27415: EMPTY
27416: LIST
27417: LIST
27418: LIST
27419: LIST
27420: LIST
27421: LIST
27422: LIST
27423: LIST
27424: LIST
27425: LIST
27426: IN
27427: PUSH
27428: LD_VAR 0 1
27432: PPUSH
27433: LD_INT 52
27435: PPUSH
27436: CALL_OW 321
27440: PUSH
27441: LD_INT 2
27443: EQUAL
27444: AND
27445: IFFALSE 27462
// bpoints := bpoints * 1.2 ;
27447: LD_ADDR_VAR 0 10
27451: PUSH
27452: LD_VAR 0 10
27456: PUSH
27457: LD_REAL  1.20000000000000E+0000
27460: MUL
27461: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
27462: LD_VAR 0 6
27466: PPUSH
27467: CALL_OW 264
27471: PUSH
27472: LD_INT 6
27474: PUSH
27475: LD_INT 46
27477: PUSH
27478: LD_INT 47
27480: PUSH
27481: EMPTY
27482: LIST
27483: LIST
27484: LIST
27485: IN
27486: IFFALSE 27503
// bpoints := bpoints * 1.2 ;
27488: LD_ADDR_VAR 0 10
27492: PUSH
27493: LD_VAR 0 10
27497: PUSH
27498: LD_REAL  1.20000000000000E+0000
27501: MUL
27502: ST_TO_ADDR
// end ; unit_building :
27503: GO 27517
27505: LD_INT 3
27507: DOUBLE
27508: EQUAL
27509: IFTRUE 27513
27511: GO 27516
27513: POP
// ; end ;
27514: GO 27517
27516: POP
// for j = 1 to 3 do
27517: LD_ADDR_VAR 0 7
27521: PUSH
27522: DOUBLE
27523: LD_INT 1
27525: DEC
27526: ST_TO_ADDR
27527: LD_INT 3
27529: PUSH
27530: FOR_TO
27531: IFFALSE 27584
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
27533: LD_ADDR_VAR 0 5
27537: PUSH
27538: LD_VAR 0 5
27542: PPUSH
27543: LD_VAR 0 7
27547: PPUSH
27548: LD_VAR 0 5
27552: PUSH
27553: LD_VAR 0 7
27557: ARRAY
27558: PUSH
27559: LD_VAR 0 9
27563: PUSH
27564: LD_VAR 0 7
27568: ARRAY
27569: PUSH
27570: LD_VAR 0 10
27574: MUL
27575: PLUS
27576: PPUSH
27577: CALL_OW 1
27581: ST_TO_ADDR
27582: GO 27530
27584: POP
27585: POP
// end ;
27586: GO 26065
27588: POP
27589: POP
// result := Replace ( result , 4 , tmp ) ;
27590: LD_ADDR_VAR 0 5
27594: PUSH
27595: LD_VAR 0 5
27599: PPUSH
27600: LD_INT 4
27602: PPUSH
27603: LD_VAR 0 8
27607: PPUSH
27608: CALL_OW 1
27612: ST_TO_ADDR
// end ;
27613: LD_VAR 0 5
27617: RET
// export function DangerAtRange ( unit , range ) ; begin
27618: LD_INT 0
27620: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
27621: LD_ADDR_VAR 0 3
27625: PUSH
27626: LD_VAR 0 1
27630: PPUSH
27631: CALL_OW 255
27635: PPUSH
27636: LD_VAR 0 1
27640: PPUSH
27641: CALL_OW 250
27645: PPUSH
27646: LD_VAR 0 1
27650: PPUSH
27651: CALL_OW 251
27655: PPUSH
27656: LD_VAR 0 2
27660: PPUSH
27661: CALL 25917 0 4
27665: ST_TO_ADDR
// end ;
27666: LD_VAR 0 3
27670: RET
// export function DangerInArea ( side , area ) ; begin
27671: LD_INT 0
27673: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
27674: LD_ADDR_VAR 0 3
27678: PUSH
27679: LD_VAR 0 2
27683: PPUSH
27684: LD_INT 81
27686: PUSH
27687: LD_VAR 0 1
27691: PUSH
27692: EMPTY
27693: LIST
27694: LIST
27695: PPUSH
27696: CALL_OW 70
27700: ST_TO_ADDR
// end ;
27701: LD_VAR 0 3
27705: RET
// export function IsExtension ( b ) ; begin
27706: LD_INT 0
27708: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
27709: LD_ADDR_VAR 0 2
27713: PUSH
27714: LD_VAR 0 1
27718: PUSH
27719: LD_INT 23
27721: PUSH
27722: LD_INT 20
27724: PUSH
27725: LD_INT 22
27727: PUSH
27728: LD_INT 17
27730: PUSH
27731: LD_INT 24
27733: PUSH
27734: LD_INT 21
27736: PUSH
27737: LD_INT 19
27739: PUSH
27740: LD_INT 16
27742: PUSH
27743: LD_INT 25
27745: PUSH
27746: LD_INT 18
27748: PUSH
27749: EMPTY
27750: LIST
27751: LIST
27752: LIST
27753: LIST
27754: LIST
27755: LIST
27756: LIST
27757: LIST
27758: LIST
27759: LIST
27760: IN
27761: ST_TO_ADDR
// end ;
27762: LD_VAR 0 2
27766: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
27767: LD_INT 0
27769: PPUSH
27770: PPUSH
27771: PPUSH
// result := [ ] ;
27772: LD_ADDR_VAR 0 4
27776: PUSH
27777: EMPTY
27778: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
27779: LD_ADDR_VAR 0 5
27783: PUSH
27784: LD_VAR 0 2
27788: PPUSH
27789: LD_INT 21
27791: PUSH
27792: LD_INT 3
27794: PUSH
27795: EMPTY
27796: LIST
27797: LIST
27798: PPUSH
27799: CALL_OW 70
27803: ST_TO_ADDR
// if not tmp then
27804: LD_VAR 0 5
27808: NOT
27809: IFFALSE 27813
// exit ;
27811: GO 27877
// if checkLink then
27813: LD_VAR 0 3
27817: IFFALSE 27867
// begin for i in tmp do
27819: LD_ADDR_VAR 0 6
27823: PUSH
27824: LD_VAR 0 5
27828: PUSH
27829: FOR_IN
27830: IFFALSE 27865
// if GetBase ( i ) <> base then
27832: LD_VAR 0 6
27836: PPUSH
27837: CALL_OW 274
27841: PUSH
27842: LD_VAR 0 1
27846: NONEQUAL
27847: IFFALSE 27863
// ComLinkToBase ( base , i ) ;
27849: LD_VAR 0 1
27853: PPUSH
27854: LD_VAR 0 6
27858: PPUSH
27859: CALL_OW 169
27863: GO 27829
27865: POP
27866: POP
// end ; result := tmp ;
27867: LD_ADDR_VAR 0 4
27871: PUSH
27872: LD_VAR 0 5
27876: ST_TO_ADDR
// end ;
27877: LD_VAR 0 4
27881: RET
// export function ComComplete ( units , b ) ; var i ; begin
27882: LD_INT 0
27884: PPUSH
27885: PPUSH
// if not units then
27886: LD_VAR 0 1
27890: NOT
27891: IFFALSE 27895
// exit ;
27893: GO 27985
// for i in units do
27895: LD_ADDR_VAR 0 4
27899: PUSH
27900: LD_VAR 0 1
27904: PUSH
27905: FOR_IN
27906: IFFALSE 27983
// if BuildingStatus ( b ) = bs_build then
27908: LD_VAR 0 2
27912: PPUSH
27913: CALL_OW 461
27917: PUSH
27918: LD_INT 1
27920: EQUAL
27921: IFFALSE 27981
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
27923: LD_VAR 0 4
27927: PPUSH
27928: LD_STRING h
27930: PUSH
27931: LD_VAR 0 2
27935: PPUSH
27936: CALL_OW 250
27940: PUSH
27941: LD_VAR 0 2
27945: PPUSH
27946: CALL_OW 251
27950: PUSH
27951: LD_VAR 0 2
27955: PUSH
27956: LD_INT 0
27958: PUSH
27959: LD_INT 0
27961: PUSH
27962: LD_INT 0
27964: PUSH
27965: EMPTY
27966: LIST
27967: LIST
27968: LIST
27969: LIST
27970: LIST
27971: LIST
27972: LIST
27973: PUSH
27974: EMPTY
27975: LIST
27976: PPUSH
27977: CALL_OW 446
27981: GO 27905
27983: POP
27984: POP
// end ;
27985: LD_VAR 0 3
27989: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
27990: LD_INT 0
27992: PPUSH
27993: PPUSH
27994: PPUSH
27995: PPUSH
27996: PPUSH
27997: PPUSH
// if not vehicle or GetControl ( vehicle ) <> control_remote then
27998: LD_VAR 0 1
28002: NOT
28003: PUSH
28004: LD_VAR 0 1
28008: PPUSH
28009: CALL_OW 263
28013: PUSH
28014: LD_INT 2
28016: NONEQUAL
28017: OR
28018: IFFALSE 28022
// exit ;
28020: GO 28338
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
28022: LD_ADDR_VAR 0 6
28026: PUSH
28027: LD_INT 22
28029: PUSH
28030: LD_VAR 0 1
28034: PPUSH
28035: CALL_OW 255
28039: PUSH
28040: EMPTY
28041: LIST
28042: LIST
28043: PUSH
28044: LD_INT 2
28046: PUSH
28047: LD_INT 30
28049: PUSH
28050: LD_INT 36
28052: PUSH
28053: EMPTY
28054: LIST
28055: LIST
28056: PUSH
28057: LD_INT 34
28059: PUSH
28060: LD_INT 31
28062: PUSH
28063: EMPTY
28064: LIST
28065: LIST
28066: PUSH
28067: EMPTY
28068: LIST
28069: LIST
28070: LIST
28071: PUSH
28072: EMPTY
28073: LIST
28074: LIST
28075: PPUSH
28076: CALL_OW 69
28080: ST_TO_ADDR
// if not tmp then
28081: LD_VAR 0 6
28085: NOT
28086: IFFALSE 28090
// exit ;
28088: GO 28338
// result := [ ] ;
28090: LD_ADDR_VAR 0 2
28094: PUSH
28095: EMPTY
28096: ST_TO_ADDR
// for i in tmp do
28097: LD_ADDR_VAR 0 3
28101: PUSH
28102: LD_VAR 0 6
28106: PUSH
28107: FOR_IN
28108: IFFALSE 28179
// begin t := UnitsInside ( i ) ;
28110: LD_ADDR_VAR 0 4
28114: PUSH
28115: LD_VAR 0 3
28119: PPUSH
28120: CALL_OW 313
28124: ST_TO_ADDR
// if t then
28125: LD_VAR 0 4
28129: IFFALSE 28177
// for j in t do
28131: LD_ADDR_VAR 0 7
28135: PUSH
28136: LD_VAR 0 4
28140: PUSH
28141: FOR_IN
28142: IFFALSE 28175
// result := Replace ( result , result + 1 , j ) ;
28144: LD_ADDR_VAR 0 2
28148: PUSH
28149: LD_VAR 0 2
28153: PPUSH
28154: LD_VAR 0 2
28158: PUSH
28159: LD_INT 1
28161: PLUS
28162: PPUSH
28163: LD_VAR 0 7
28167: PPUSH
28168: CALL_OW 1
28172: ST_TO_ADDR
28173: GO 28141
28175: POP
28176: POP
// end ;
28177: GO 28107
28179: POP
28180: POP
// if not result then
28181: LD_VAR 0 2
28185: NOT
28186: IFFALSE 28190
// exit ;
28188: GO 28338
// mech := result [ 1 ] ;
28190: LD_ADDR_VAR 0 5
28194: PUSH
28195: LD_VAR 0 2
28199: PUSH
28200: LD_INT 1
28202: ARRAY
28203: ST_TO_ADDR
// if result > 1 then
28204: LD_VAR 0 2
28208: PUSH
28209: LD_INT 1
28211: GREATER
28212: IFFALSE 28324
// begin for i = 2 to result do
28214: LD_ADDR_VAR 0 3
28218: PUSH
28219: DOUBLE
28220: LD_INT 2
28222: DEC
28223: ST_TO_ADDR
28224: LD_VAR 0 2
28228: PUSH
28229: FOR_TO
28230: IFFALSE 28322
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
28232: LD_ADDR_VAR 0 4
28236: PUSH
28237: LD_VAR 0 2
28241: PUSH
28242: LD_VAR 0 3
28246: ARRAY
28247: PPUSH
28248: LD_INT 3
28250: PPUSH
28251: CALL_OW 259
28255: PUSH
28256: LD_VAR 0 2
28260: PUSH
28261: LD_VAR 0 3
28265: ARRAY
28266: PPUSH
28267: CALL_OW 432
28271: MINUS
28272: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
28273: LD_VAR 0 4
28277: PUSH
28278: LD_VAR 0 5
28282: PPUSH
28283: LD_INT 3
28285: PPUSH
28286: CALL_OW 259
28290: PUSH
28291: LD_VAR 0 5
28295: PPUSH
28296: CALL_OW 432
28300: MINUS
28301: GREATEREQUAL
28302: IFFALSE 28320
// mech := result [ i ] ;
28304: LD_ADDR_VAR 0 5
28308: PUSH
28309: LD_VAR 0 2
28313: PUSH
28314: LD_VAR 0 3
28318: ARRAY
28319: ST_TO_ADDR
// end ;
28320: GO 28229
28322: POP
28323: POP
// end ; ComLinkTo ( vehicle , mech ) ;
28324: LD_VAR 0 1
28328: PPUSH
28329: LD_VAR 0 5
28333: PPUSH
28334: CALL_OW 135
// end ;
28338: LD_VAR 0 2
28342: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
28343: LD_INT 0
28345: PPUSH
28346: PPUSH
28347: PPUSH
28348: PPUSH
28349: PPUSH
28350: PPUSH
28351: PPUSH
28352: PPUSH
28353: PPUSH
28354: PPUSH
28355: PPUSH
28356: PPUSH
28357: PPUSH
// result := [ ] ;
28358: LD_ADDR_VAR 0 7
28362: PUSH
28363: EMPTY
28364: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
28365: LD_VAR 0 1
28369: PPUSH
28370: CALL_OW 266
28374: PUSH
28375: LD_INT 0
28377: PUSH
28378: LD_INT 1
28380: PUSH
28381: EMPTY
28382: LIST
28383: LIST
28384: IN
28385: NOT
28386: IFFALSE 28390
// exit ;
28388: GO 30024
// if name then
28390: LD_VAR 0 3
28394: IFFALSE 28410
// SetBName ( base_dep , name ) ;
28396: LD_VAR 0 1
28400: PPUSH
28401: LD_VAR 0 3
28405: PPUSH
28406: CALL_OW 500
// base := GetBase ( base_dep ) ;
28410: LD_ADDR_VAR 0 15
28414: PUSH
28415: LD_VAR 0 1
28419: PPUSH
28420: CALL_OW 274
28424: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
28425: LD_ADDR_VAR 0 16
28429: PUSH
28430: LD_VAR 0 1
28434: PPUSH
28435: CALL_OW 255
28439: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
28440: LD_ADDR_VAR 0 17
28444: PUSH
28445: LD_VAR 0 1
28449: PPUSH
28450: CALL_OW 248
28454: ST_TO_ADDR
// if sources then
28455: LD_VAR 0 5
28459: IFFALSE 28506
// for i = 1 to 3 do
28461: LD_ADDR_VAR 0 8
28465: PUSH
28466: DOUBLE
28467: LD_INT 1
28469: DEC
28470: ST_TO_ADDR
28471: LD_INT 3
28473: PUSH
28474: FOR_TO
28475: IFFALSE 28504
// AddResourceType ( base , i , sources [ i ] ) ;
28477: LD_VAR 0 15
28481: PPUSH
28482: LD_VAR 0 8
28486: PPUSH
28487: LD_VAR 0 5
28491: PUSH
28492: LD_VAR 0 8
28496: ARRAY
28497: PPUSH
28498: CALL_OW 276
28502: GO 28474
28504: POP
28505: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
28506: LD_ADDR_VAR 0 18
28510: PUSH
28511: LD_VAR 0 15
28515: PPUSH
28516: LD_VAR 0 2
28520: PPUSH
28521: LD_INT 1
28523: PPUSH
28524: CALL 27767 0 3
28528: ST_TO_ADDR
// InitHc ;
28529: CALL_OW 19
// InitUc ;
28533: CALL_OW 18
// uc_side := side ;
28537: LD_ADDR_OWVAR 20
28541: PUSH
28542: LD_VAR 0 16
28546: ST_TO_ADDR
// uc_nation := nation ;
28547: LD_ADDR_OWVAR 21
28551: PUSH
28552: LD_VAR 0 17
28556: ST_TO_ADDR
// if buildings then
28557: LD_VAR 0 18
28561: IFFALSE 29883
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
28563: LD_ADDR_VAR 0 19
28567: PUSH
28568: LD_VAR 0 18
28572: PPUSH
28573: LD_INT 2
28575: PUSH
28576: LD_INT 30
28578: PUSH
28579: LD_INT 29
28581: PUSH
28582: EMPTY
28583: LIST
28584: LIST
28585: PUSH
28586: LD_INT 30
28588: PUSH
28589: LD_INT 30
28591: PUSH
28592: EMPTY
28593: LIST
28594: LIST
28595: PUSH
28596: EMPTY
28597: LIST
28598: LIST
28599: LIST
28600: PPUSH
28601: CALL_OW 72
28605: ST_TO_ADDR
// if tmp then
28606: LD_VAR 0 19
28610: IFFALSE 28658
// for i in tmp do
28612: LD_ADDR_VAR 0 8
28616: PUSH
28617: LD_VAR 0 19
28621: PUSH
28622: FOR_IN
28623: IFFALSE 28656
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
28625: LD_VAR 0 8
28629: PPUSH
28630: CALL_OW 250
28634: PPUSH
28635: LD_VAR 0 8
28639: PPUSH
28640: CALL_OW 251
28644: PPUSH
28645: LD_VAR 0 16
28649: PPUSH
28650: CALL_OW 441
28654: GO 28622
28656: POP
28657: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
28658: LD_VAR 0 18
28662: PPUSH
28663: LD_INT 2
28665: PUSH
28666: LD_INT 30
28668: PUSH
28669: LD_INT 32
28671: PUSH
28672: EMPTY
28673: LIST
28674: LIST
28675: PUSH
28676: LD_INT 30
28678: PUSH
28679: LD_INT 33
28681: PUSH
28682: EMPTY
28683: LIST
28684: LIST
28685: PUSH
28686: EMPTY
28687: LIST
28688: LIST
28689: LIST
28690: PPUSH
28691: CALL_OW 72
28695: IFFALSE 28783
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
28697: LD_ADDR_VAR 0 8
28701: PUSH
28702: LD_VAR 0 18
28706: PPUSH
28707: LD_INT 2
28709: PUSH
28710: LD_INT 30
28712: PUSH
28713: LD_INT 32
28715: PUSH
28716: EMPTY
28717: LIST
28718: LIST
28719: PUSH
28720: LD_INT 30
28722: PUSH
28723: LD_INT 33
28725: PUSH
28726: EMPTY
28727: LIST
28728: LIST
28729: PUSH
28730: EMPTY
28731: LIST
28732: LIST
28733: LIST
28734: PPUSH
28735: CALL_OW 72
28739: PUSH
28740: FOR_IN
28741: IFFALSE 28781
// begin if not GetBWeapon ( i ) then
28743: LD_VAR 0 8
28747: PPUSH
28748: CALL_OW 269
28752: NOT
28753: IFFALSE 28779
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
28755: LD_VAR 0 8
28759: PPUSH
28760: LD_VAR 0 8
28764: PPUSH
28765: LD_VAR 0 2
28769: PPUSH
28770: CALL 30029 0 2
28774: PPUSH
28775: CALL_OW 431
// end ;
28779: GO 28740
28781: POP
28782: POP
// end ; for i = 1 to personel do
28783: LD_ADDR_VAR 0 8
28787: PUSH
28788: DOUBLE
28789: LD_INT 1
28791: DEC
28792: ST_TO_ADDR
28793: LD_VAR 0 6
28797: PUSH
28798: FOR_TO
28799: IFFALSE 29863
// begin if i > 4 then
28801: LD_VAR 0 8
28805: PUSH
28806: LD_INT 4
28808: GREATER
28809: IFFALSE 28813
// break ;
28811: GO 29863
// case i of 1 :
28813: LD_VAR 0 8
28817: PUSH
28818: LD_INT 1
28820: DOUBLE
28821: EQUAL
28822: IFTRUE 28826
28824: GO 28906
28826: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
28827: LD_ADDR_VAR 0 12
28831: PUSH
28832: LD_VAR 0 18
28836: PPUSH
28837: LD_INT 22
28839: PUSH
28840: LD_VAR 0 16
28844: PUSH
28845: EMPTY
28846: LIST
28847: LIST
28848: PUSH
28849: LD_INT 58
28851: PUSH
28852: EMPTY
28853: LIST
28854: PUSH
28855: LD_INT 2
28857: PUSH
28858: LD_INT 30
28860: PUSH
28861: LD_INT 32
28863: PUSH
28864: EMPTY
28865: LIST
28866: LIST
28867: PUSH
28868: LD_INT 30
28870: PUSH
28871: LD_INT 4
28873: PUSH
28874: EMPTY
28875: LIST
28876: LIST
28877: PUSH
28878: LD_INT 30
28880: PUSH
28881: LD_INT 5
28883: PUSH
28884: EMPTY
28885: LIST
28886: LIST
28887: PUSH
28888: EMPTY
28889: LIST
28890: LIST
28891: LIST
28892: LIST
28893: PUSH
28894: EMPTY
28895: LIST
28896: LIST
28897: LIST
28898: PPUSH
28899: CALL_OW 72
28903: ST_TO_ADDR
28904: GO 29128
28906: LD_INT 2
28908: DOUBLE
28909: EQUAL
28910: IFTRUE 28914
28912: GO 28976
28914: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
28915: LD_ADDR_VAR 0 12
28919: PUSH
28920: LD_VAR 0 18
28924: PPUSH
28925: LD_INT 22
28927: PUSH
28928: LD_VAR 0 16
28932: PUSH
28933: EMPTY
28934: LIST
28935: LIST
28936: PUSH
28937: LD_INT 2
28939: PUSH
28940: LD_INT 30
28942: PUSH
28943: LD_INT 0
28945: PUSH
28946: EMPTY
28947: LIST
28948: LIST
28949: PUSH
28950: LD_INT 30
28952: PUSH
28953: LD_INT 1
28955: PUSH
28956: EMPTY
28957: LIST
28958: LIST
28959: PUSH
28960: EMPTY
28961: LIST
28962: LIST
28963: LIST
28964: PUSH
28965: EMPTY
28966: LIST
28967: LIST
28968: PPUSH
28969: CALL_OW 72
28973: ST_TO_ADDR
28974: GO 29128
28976: LD_INT 3
28978: DOUBLE
28979: EQUAL
28980: IFTRUE 28984
28982: GO 29046
28984: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
28985: LD_ADDR_VAR 0 12
28989: PUSH
28990: LD_VAR 0 18
28994: PPUSH
28995: LD_INT 22
28997: PUSH
28998: LD_VAR 0 16
29002: PUSH
29003: EMPTY
29004: LIST
29005: LIST
29006: PUSH
29007: LD_INT 2
29009: PUSH
29010: LD_INT 30
29012: PUSH
29013: LD_INT 2
29015: PUSH
29016: EMPTY
29017: LIST
29018: LIST
29019: PUSH
29020: LD_INT 30
29022: PUSH
29023: LD_INT 3
29025: PUSH
29026: EMPTY
29027: LIST
29028: LIST
29029: PUSH
29030: EMPTY
29031: LIST
29032: LIST
29033: LIST
29034: PUSH
29035: EMPTY
29036: LIST
29037: LIST
29038: PPUSH
29039: CALL_OW 72
29043: ST_TO_ADDR
29044: GO 29128
29046: LD_INT 4
29048: DOUBLE
29049: EQUAL
29050: IFTRUE 29054
29052: GO 29127
29054: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
29055: LD_ADDR_VAR 0 12
29059: PUSH
29060: LD_VAR 0 18
29064: PPUSH
29065: LD_INT 22
29067: PUSH
29068: LD_VAR 0 16
29072: PUSH
29073: EMPTY
29074: LIST
29075: LIST
29076: PUSH
29077: LD_INT 2
29079: PUSH
29080: LD_INT 30
29082: PUSH
29083: LD_INT 6
29085: PUSH
29086: EMPTY
29087: LIST
29088: LIST
29089: PUSH
29090: LD_INT 30
29092: PUSH
29093: LD_INT 7
29095: PUSH
29096: EMPTY
29097: LIST
29098: LIST
29099: PUSH
29100: LD_INT 30
29102: PUSH
29103: LD_INT 8
29105: PUSH
29106: EMPTY
29107: LIST
29108: LIST
29109: PUSH
29110: EMPTY
29111: LIST
29112: LIST
29113: LIST
29114: LIST
29115: PUSH
29116: EMPTY
29117: LIST
29118: LIST
29119: PPUSH
29120: CALL_OW 72
29124: ST_TO_ADDR
29125: GO 29128
29127: POP
// if i = 1 then
29128: LD_VAR 0 8
29132: PUSH
29133: LD_INT 1
29135: EQUAL
29136: IFFALSE 29247
// begin tmp := [ ] ;
29138: LD_ADDR_VAR 0 19
29142: PUSH
29143: EMPTY
29144: ST_TO_ADDR
// for j in f do
29145: LD_ADDR_VAR 0 9
29149: PUSH
29150: LD_VAR 0 12
29154: PUSH
29155: FOR_IN
29156: IFFALSE 29229
// if GetBType ( j ) = b_bunker then
29158: LD_VAR 0 9
29162: PPUSH
29163: CALL_OW 266
29167: PUSH
29168: LD_INT 32
29170: EQUAL
29171: IFFALSE 29198
// tmp := Insert ( tmp , 1 , j ) else
29173: LD_ADDR_VAR 0 19
29177: PUSH
29178: LD_VAR 0 19
29182: PPUSH
29183: LD_INT 1
29185: PPUSH
29186: LD_VAR 0 9
29190: PPUSH
29191: CALL_OW 2
29195: ST_TO_ADDR
29196: GO 29227
// tmp := Insert ( tmp , tmp + 1 , j ) ;
29198: LD_ADDR_VAR 0 19
29202: PUSH
29203: LD_VAR 0 19
29207: PPUSH
29208: LD_VAR 0 19
29212: PUSH
29213: LD_INT 1
29215: PLUS
29216: PPUSH
29217: LD_VAR 0 9
29221: PPUSH
29222: CALL_OW 2
29226: ST_TO_ADDR
29227: GO 29155
29229: POP
29230: POP
// if tmp then
29231: LD_VAR 0 19
29235: IFFALSE 29247
// f := tmp ;
29237: LD_ADDR_VAR 0 12
29241: PUSH
29242: LD_VAR 0 19
29246: ST_TO_ADDR
// end ; x := personel [ i ] ;
29247: LD_ADDR_VAR 0 13
29251: PUSH
29252: LD_VAR 0 6
29256: PUSH
29257: LD_VAR 0 8
29261: ARRAY
29262: ST_TO_ADDR
// if x = - 1 then
29263: LD_VAR 0 13
29267: PUSH
29268: LD_INT 1
29270: NEG
29271: EQUAL
29272: IFFALSE 29481
// begin for j in f do
29274: LD_ADDR_VAR 0 9
29278: PUSH
29279: LD_VAR 0 12
29283: PUSH
29284: FOR_IN
29285: IFFALSE 29477
// repeat InitHc ;
29287: CALL_OW 19
// if GetBType ( j ) = b_barracks then
29291: LD_VAR 0 9
29295: PPUSH
29296: CALL_OW 266
29300: PUSH
29301: LD_INT 5
29303: EQUAL
29304: IFFALSE 29374
// begin if UnitsInside ( j ) < 3 then
29306: LD_VAR 0 9
29310: PPUSH
29311: CALL_OW 313
29315: PUSH
29316: LD_INT 3
29318: LESS
29319: IFFALSE 29355
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
29321: LD_INT 0
29323: PPUSH
29324: LD_INT 5
29326: PUSH
29327: LD_INT 8
29329: PUSH
29330: LD_INT 9
29332: PUSH
29333: EMPTY
29334: LIST
29335: LIST
29336: LIST
29337: PUSH
29338: LD_VAR 0 17
29342: ARRAY
29343: PPUSH
29344: LD_VAR 0 4
29348: PPUSH
29349: CALL_OW 380
29353: GO 29372
// PrepareHuman ( false , i , skill ) ;
29355: LD_INT 0
29357: PPUSH
29358: LD_VAR 0 8
29362: PPUSH
29363: LD_VAR 0 4
29367: PPUSH
29368: CALL_OW 380
// end else
29372: GO 29391
// PrepareHuman ( false , i , skill ) ;
29374: LD_INT 0
29376: PPUSH
29377: LD_VAR 0 8
29381: PPUSH
29382: LD_VAR 0 4
29386: PPUSH
29387: CALL_OW 380
// un := CreateHuman ;
29391: LD_ADDR_VAR 0 14
29395: PUSH
29396: CALL_OW 44
29400: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
29401: LD_ADDR_VAR 0 7
29405: PUSH
29406: LD_VAR 0 7
29410: PPUSH
29411: LD_INT 1
29413: PPUSH
29414: LD_VAR 0 14
29418: PPUSH
29419: CALL_OW 2
29423: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
29424: LD_VAR 0 14
29428: PPUSH
29429: LD_VAR 0 9
29433: PPUSH
29434: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
29438: LD_VAR 0 9
29442: PPUSH
29443: CALL_OW 313
29447: PUSH
29448: LD_INT 6
29450: EQUAL
29451: PUSH
29452: LD_VAR 0 9
29456: PPUSH
29457: CALL_OW 266
29461: PUSH
29462: LD_INT 32
29464: PUSH
29465: LD_INT 31
29467: PUSH
29468: EMPTY
29469: LIST
29470: LIST
29471: IN
29472: OR
29473: IFFALSE 29287
29475: GO 29284
29477: POP
29478: POP
// end else
29479: GO 29861
// for j = 1 to x do
29481: LD_ADDR_VAR 0 9
29485: PUSH
29486: DOUBLE
29487: LD_INT 1
29489: DEC
29490: ST_TO_ADDR
29491: LD_VAR 0 13
29495: PUSH
29496: FOR_TO
29497: IFFALSE 29859
// begin InitHc ;
29499: CALL_OW 19
// if not f then
29503: LD_VAR 0 12
29507: NOT
29508: IFFALSE 29597
// begin PrepareHuman ( false , i , skill ) ;
29510: LD_INT 0
29512: PPUSH
29513: LD_VAR 0 8
29517: PPUSH
29518: LD_VAR 0 4
29522: PPUSH
29523: CALL_OW 380
// un := CreateHuman ;
29527: LD_ADDR_VAR 0 14
29531: PUSH
29532: CALL_OW 44
29536: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
29537: LD_ADDR_VAR 0 7
29541: PUSH
29542: LD_VAR 0 7
29546: PPUSH
29547: LD_INT 1
29549: PPUSH
29550: LD_VAR 0 14
29554: PPUSH
29555: CALL_OW 2
29559: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
29560: LD_VAR 0 14
29564: PPUSH
29565: LD_VAR 0 1
29569: PPUSH
29570: CALL_OW 250
29574: PPUSH
29575: LD_VAR 0 1
29579: PPUSH
29580: CALL_OW 251
29584: PPUSH
29585: LD_INT 10
29587: PPUSH
29588: LD_INT 0
29590: PPUSH
29591: CALL_OW 50
// continue ;
29595: GO 29496
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
29597: LD_VAR 0 12
29601: PUSH
29602: LD_INT 1
29604: ARRAY
29605: PPUSH
29606: CALL_OW 313
29610: PUSH
29611: LD_VAR 0 12
29615: PUSH
29616: LD_INT 1
29618: ARRAY
29619: PPUSH
29620: CALL_OW 266
29624: PUSH
29625: LD_INT 32
29627: PUSH
29628: LD_INT 31
29630: PUSH
29631: EMPTY
29632: LIST
29633: LIST
29634: IN
29635: AND
29636: PUSH
29637: LD_VAR 0 12
29641: PUSH
29642: LD_INT 1
29644: ARRAY
29645: PPUSH
29646: CALL_OW 313
29650: PUSH
29651: LD_INT 6
29653: EQUAL
29654: OR
29655: IFFALSE 29675
// f := Delete ( f , 1 ) ;
29657: LD_ADDR_VAR 0 12
29661: PUSH
29662: LD_VAR 0 12
29666: PPUSH
29667: LD_INT 1
29669: PPUSH
29670: CALL_OW 3
29674: ST_TO_ADDR
// if not f then
29675: LD_VAR 0 12
29679: NOT
29680: IFFALSE 29698
// begin x := x + 2 ;
29682: LD_ADDR_VAR 0 13
29686: PUSH
29687: LD_VAR 0 13
29691: PUSH
29692: LD_INT 2
29694: PLUS
29695: ST_TO_ADDR
// continue ;
29696: GO 29496
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
29698: LD_VAR 0 12
29702: PUSH
29703: LD_INT 1
29705: ARRAY
29706: PPUSH
29707: CALL_OW 266
29711: PUSH
29712: LD_INT 5
29714: EQUAL
29715: IFFALSE 29789
// begin if UnitsInside ( f [ 1 ] ) < 3 then
29717: LD_VAR 0 12
29721: PUSH
29722: LD_INT 1
29724: ARRAY
29725: PPUSH
29726: CALL_OW 313
29730: PUSH
29731: LD_INT 3
29733: LESS
29734: IFFALSE 29770
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
29736: LD_INT 0
29738: PPUSH
29739: LD_INT 5
29741: PUSH
29742: LD_INT 8
29744: PUSH
29745: LD_INT 9
29747: PUSH
29748: EMPTY
29749: LIST
29750: LIST
29751: LIST
29752: PUSH
29753: LD_VAR 0 17
29757: ARRAY
29758: PPUSH
29759: LD_VAR 0 4
29763: PPUSH
29764: CALL_OW 380
29768: GO 29787
// PrepareHuman ( false , i , skill ) ;
29770: LD_INT 0
29772: PPUSH
29773: LD_VAR 0 8
29777: PPUSH
29778: LD_VAR 0 4
29782: PPUSH
29783: CALL_OW 380
// end else
29787: GO 29806
// PrepareHuman ( false , i , skill ) ;
29789: LD_INT 0
29791: PPUSH
29792: LD_VAR 0 8
29796: PPUSH
29797: LD_VAR 0 4
29801: PPUSH
29802: CALL_OW 380
// un := CreateHuman ;
29806: LD_ADDR_VAR 0 14
29810: PUSH
29811: CALL_OW 44
29815: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
29816: LD_ADDR_VAR 0 7
29820: PUSH
29821: LD_VAR 0 7
29825: PPUSH
29826: LD_INT 1
29828: PPUSH
29829: LD_VAR 0 14
29833: PPUSH
29834: CALL_OW 2
29838: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
29839: LD_VAR 0 14
29843: PPUSH
29844: LD_VAR 0 12
29848: PUSH
29849: LD_INT 1
29851: ARRAY
29852: PPUSH
29853: CALL_OW 52
// end ;
29857: GO 29496
29859: POP
29860: POP
// end ;
29861: GO 28798
29863: POP
29864: POP
// result := result ^ buildings ;
29865: LD_ADDR_VAR 0 7
29869: PUSH
29870: LD_VAR 0 7
29874: PUSH
29875: LD_VAR 0 18
29879: ADD
29880: ST_TO_ADDR
// end else
29881: GO 30024
// begin for i = 1 to personel do
29883: LD_ADDR_VAR 0 8
29887: PUSH
29888: DOUBLE
29889: LD_INT 1
29891: DEC
29892: ST_TO_ADDR
29893: LD_VAR 0 6
29897: PUSH
29898: FOR_TO
29899: IFFALSE 30022
// begin if i > 4 then
29901: LD_VAR 0 8
29905: PUSH
29906: LD_INT 4
29908: GREATER
29909: IFFALSE 29913
// break ;
29911: GO 30022
// x := personel [ i ] ;
29913: LD_ADDR_VAR 0 13
29917: PUSH
29918: LD_VAR 0 6
29922: PUSH
29923: LD_VAR 0 8
29927: ARRAY
29928: ST_TO_ADDR
// if x = - 1 then
29929: LD_VAR 0 13
29933: PUSH
29934: LD_INT 1
29936: NEG
29937: EQUAL
29938: IFFALSE 29942
// continue ;
29940: GO 29898
// PrepareHuman ( false , i , skill ) ;
29942: LD_INT 0
29944: PPUSH
29945: LD_VAR 0 8
29949: PPUSH
29950: LD_VAR 0 4
29954: PPUSH
29955: CALL_OW 380
// un := CreateHuman ;
29959: LD_ADDR_VAR 0 14
29963: PUSH
29964: CALL_OW 44
29968: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
29969: LD_VAR 0 14
29973: PPUSH
29974: LD_VAR 0 1
29978: PPUSH
29979: CALL_OW 250
29983: PPUSH
29984: LD_VAR 0 1
29988: PPUSH
29989: CALL_OW 251
29993: PPUSH
29994: LD_INT 10
29996: PPUSH
29997: LD_INT 0
29999: PPUSH
30000: CALL_OW 50
// result := result ^ un ;
30004: LD_ADDR_VAR 0 7
30008: PUSH
30009: LD_VAR 0 7
30013: PUSH
30014: LD_VAR 0 14
30018: ADD
30019: ST_TO_ADDR
// end ;
30020: GO 29898
30022: POP
30023: POP
// end ; end ;
30024: LD_VAR 0 7
30028: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
30029: LD_INT 0
30031: PPUSH
30032: PPUSH
30033: PPUSH
30034: PPUSH
30035: PPUSH
30036: PPUSH
30037: PPUSH
30038: PPUSH
30039: PPUSH
30040: PPUSH
30041: PPUSH
30042: PPUSH
30043: PPUSH
30044: PPUSH
30045: PPUSH
30046: PPUSH
// result := false ;
30047: LD_ADDR_VAR 0 3
30051: PUSH
30052: LD_INT 0
30054: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
30055: LD_VAR 0 1
30059: NOT
30060: PUSH
30061: LD_VAR 0 1
30065: PPUSH
30066: CALL_OW 266
30070: PUSH
30071: LD_INT 32
30073: PUSH
30074: LD_INT 33
30076: PUSH
30077: EMPTY
30078: LIST
30079: LIST
30080: IN
30081: NOT
30082: OR
30083: IFFALSE 30087
// exit ;
30085: GO 31196
// nat := GetNation ( tower ) ;
30087: LD_ADDR_VAR 0 12
30091: PUSH
30092: LD_VAR 0 1
30096: PPUSH
30097: CALL_OW 248
30101: ST_TO_ADDR
// side := GetSide ( tower ) ;
30102: LD_ADDR_VAR 0 16
30106: PUSH
30107: LD_VAR 0 1
30111: PPUSH
30112: CALL_OW 255
30116: ST_TO_ADDR
// x := GetX ( tower ) ;
30117: LD_ADDR_VAR 0 10
30121: PUSH
30122: LD_VAR 0 1
30126: PPUSH
30127: CALL_OW 250
30131: ST_TO_ADDR
// y := GetY ( tower ) ;
30132: LD_ADDR_VAR 0 11
30136: PUSH
30137: LD_VAR 0 1
30141: PPUSH
30142: CALL_OW 251
30146: ST_TO_ADDR
// if not x or not y then
30147: LD_VAR 0 10
30151: NOT
30152: PUSH
30153: LD_VAR 0 11
30157: NOT
30158: OR
30159: IFFALSE 30163
// exit ;
30161: GO 31196
// weapon := 0 ;
30163: LD_ADDR_VAR 0 18
30167: PUSH
30168: LD_INT 0
30170: ST_TO_ADDR
// fac_list := [ ] ;
30171: LD_ADDR_VAR 0 17
30175: PUSH
30176: EMPTY
30177: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
30178: LD_ADDR_VAR 0 6
30182: PUSH
30183: LD_VAR 0 1
30187: PPUSH
30188: CALL_OW 274
30192: PPUSH
30193: LD_VAR 0 2
30197: PPUSH
30198: LD_INT 0
30200: PPUSH
30201: CALL 27767 0 3
30205: PPUSH
30206: LD_INT 30
30208: PUSH
30209: LD_INT 3
30211: PUSH
30212: EMPTY
30213: LIST
30214: LIST
30215: PPUSH
30216: CALL_OW 72
30220: ST_TO_ADDR
// if not factories then
30221: LD_VAR 0 6
30225: NOT
30226: IFFALSE 30230
// exit ;
30228: GO 31196
// for i in factories do
30230: LD_ADDR_VAR 0 8
30234: PUSH
30235: LD_VAR 0 6
30239: PUSH
30240: FOR_IN
30241: IFFALSE 30266
// fac_list := fac_list union AvailableWeaponList ( i ) ;
30243: LD_ADDR_VAR 0 17
30247: PUSH
30248: LD_VAR 0 17
30252: PUSH
30253: LD_VAR 0 8
30257: PPUSH
30258: CALL_OW 478
30262: UNION
30263: ST_TO_ADDR
30264: GO 30240
30266: POP
30267: POP
// if not fac_list then
30268: LD_VAR 0 17
30272: NOT
30273: IFFALSE 30277
// exit ;
30275: GO 31196
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
30277: LD_ADDR_VAR 0 5
30281: PUSH
30282: LD_INT 4
30284: PUSH
30285: LD_INT 5
30287: PUSH
30288: LD_INT 9
30290: PUSH
30291: LD_INT 10
30293: PUSH
30294: LD_INT 6
30296: PUSH
30297: LD_INT 7
30299: PUSH
30300: LD_INT 11
30302: PUSH
30303: EMPTY
30304: LIST
30305: LIST
30306: LIST
30307: LIST
30308: LIST
30309: LIST
30310: LIST
30311: PUSH
30312: LD_INT 27
30314: PUSH
30315: LD_INT 28
30317: PUSH
30318: LD_INT 26
30320: PUSH
30321: LD_INT 30
30323: PUSH
30324: EMPTY
30325: LIST
30326: LIST
30327: LIST
30328: LIST
30329: PUSH
30330: LD_INT 43
30332: PUSH
30333: LD_INT 44
30335: PUSH
30336: LD_INT 46
30338: PUSH
30339: LD_INT 45
30341: PUSH
30342: LD_INT 47
30344: PUSH
30345: LD_INT 49
30347: PUSH
30348: EMPTY
30349: LIST
30350: LIST
30351: LIST
30352: LIST
30353: LIST
30354: LIST
30355: PUSH
30356: EMPTY
30357: LIST
30358: LIST
30359: LIST
30360: PUSH
30361: LD_VAR 0 12
30365: ARRAY
30366: ST_TO_ADDR
// list := list isect fac_list ;
30367: LD_ADDR_VAR 0 5
30371: PUSH
30372: LD_VAR 0 5
30376: PUSH
30377: LD_VAR 0 17
30381: ISECT
30382: ST_TO_ADDR
// if not list then
30383: LD_VAR 0 5
30387: NOT
30388: IFFALSE 30392
// exit ;
30390: GO 31196
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
30392: LD_VAR 0 12
30396: PUSH
30397: LD_INT 3
30399: EQUAL
30400: PUSH
30401: LD_INT 49
30403: PUSH
30404: LD_VAR 0 5
30408: IN
30409: AND
30410: PUSH
30411: LD_INT 31
30413: PPUSH
30414: LD_VAR 0 16
30418: PPUSH
30419: CALL_OW 321
30423: PUSH
30424: LD_INT 2
30426: EQUAL
30427: AND
30428: IFFALSE 30488
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
30430: LD_INT 22
30432: PUSH
30433: LD_VAR 0 16
30437: PUSH
30438: EMPTY
30439: LIST
30440: LIST
30441: PUSH
30442: LD_INT 35
30444: PUSH
30445: LD_INT 49
30447: PUSH
30448: EMPTY
30449: LIST
30450: LIST
30451: PUSH
30452: LD_INT 91
30454: PUSH
30455: LD_VAR 0 1
30459: PUSH
30460: LD_INT 10
30462: PUSH
30463: EMPTY
30464: LIST
30465: LIST
30466: LIST
30467: PUSH
30468: EMPTY
30469: LIST
30470: LIST
30471: LIST
30472: PPUSH
30473: CALL_OW 69
30477: NOT
30478: IFFALSE 30488
// weapon := ru_time_lapser ;
30480: LD_ADDR_VAR 0 18
30484: PUSH
30485: LD_INT 49
30487: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
30488: LD_VAR 0 12
30492: PUSH
30493: LD_INT 1
30495: PUSH
30496: LD_INT 2
30498: PUSH
30499: EMPTY
30500: LIST
30501: LIST
30502: IN
30503: PUSH
30504: LD_INT 11
30506: PUSH
30507: LD_VAR 0 5
30511: IN
30512: PUSH
30513: LD_INT 30
30515: PUSH
30516: LD_VAR 0 5
30520: IN
30521: OR
30522: AND
30523: PUSH
30524: LD_INT 6
30526: PPUSH
30527: LD_VAR 0 16
30531: PPUSH
30532: CALL_OW 321
30536: PUSH
30537: LD_INT 2
30539: EQUAL
30540: AND
30541: IFFALSE 30706
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
30543: LD_INT 22
30545: PUSH
30546: LD_VAR 0 16
30550: PUSH
30551: EMPTY
30552: LIST
30553: LIST
30554: PUSH
30555: LD_INT 2
30557: PUSH
30558: LD_INT 35
30560: PUSH
30561: LD_INT 11
30563: PUSH
30564: EMPTY
30565: LIST
30566: LIST
30567: PUSH
30568: LD_INT 35
30570: PUSH
30571: LD_INT 30
30573: PUSH
30574: EMPTY
30575: LIST
30576: LIST
30577: PUSH
30578: EMPTY
30579: LIST
30580: LIST
30581: LIST
30582: PUSH
30583: LD_INT 91
30585: PUSH
30586: LD_VAR 0 1
30590: PUSH
30591: LD_INT 18
30593: PUSH
30594: EMPTY
30595: LIST
30596: LIST
30597: LIST
30598: PUSH
30599: EMPTY
30600: LIST
30601: LIST
30602: LIST
30603: PPUSH
30604: CALL_OW 69
30608: NOT
30609: PUSH
30610: LD_INT 22
30612: PUSH
30613: LD_VAR 0 16
30617: PUSH
30618: EMPTY
30619: LIST
30620: LIST
30621: PUSH
30622: LD_INT 2
30624: PUSH
30625: LD_INT 30
30627: PUSH
30628: LD_INT 32
30630: PUSH
30631: EMPTY
30632: LIST
30633: LIST
30634: PUSH
30635: LD_INT 30
30637: PUSH
30638: LD_INT 33
30640: PUSH
30641: EMPTY
30642: LIST
30643: LIST
30644: PUSH
30645: EMPTY
30646: LIST
30647: LIST
30648: LIST
30649: PUSH
30650: LD_INT 91
30652: PUSH
30653: LD_VAR 0 1
30657: PUSH
30658: LD_INT 12
30660: PUSH
30661: EMPTY
30662: LIST
30663: LIST
30664: LIST
30665: PUSH
30666: EMPTY
30667: LIST
30668: LIST
30669: LIST
30670: PUSH
30671: EMPTY
30672: LIST
30673: PPUSH
30674: CALL_OW 69
30678: PUSH
30679: LD_INT 2
30681: GREATER
30682: AND
30683: IFFALSE 30706
// weapon := [ us_radar , ar_radar ] [ nat ] ;
30685: LD_ADDR_VAR 0 18
30689: PUSH
30690: LD_INT 11
30692: PUSH
30693: LD_INT 30
30695: PUSH
30696: EMPTY
30697: LIST
30698: LIST
30699: PUSH
30700: LD_VAR 0 12
30704: ARRAY
30705: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
30706: LD_VAR 0 18
30710: NOT
30711: PUSH
30712: LD_INT 40
30714: PPUSH
30715: LD_VAR 0 16
30719: PPUSH
30720: CALL_OW 321
30724: PUSH
30725: LD_INT 2
30727: EQUAL
30728: AND
30729: PUSH
30730: LD_INT 7
30732: PUSH
30733: LD_VAR 0 5
30737: IN
30738: PUSH
30739: LD_INT 28
30741: PUSH
30742: LD_VAR 0 5
30746: IN
30747: OR
30748: PUSH
30749: LD_INT 45
30751: PUSH
30752: LD_VAR 0 5
30756: IN
30757: OR
30758: AND
30759: IFFALSE 31013
// begin hex := GetHexInfo ( x , y ) ;
30761: LD_ADDR_VAR 0 4
30765: PUSH
30766: LD_VAR 0 10
30770: PPUSH
30771: LD_VAR 0 11
30775: PPUSH
30776: CALL_OW 546
30780: ST_TO_ADDR
// if hex [ 1 ] then
30781: LD_VAR 0 4
30785: PUSH
30786: LD_INT 1
30788: ARRAY
30789: IFFALSE 30793
// exit ;
30791: GO 31196
// height := hex [ 2 ] ;
30793: LD_ADDR_VAR 0 15
30797: PUSH
30798: LD_VAR 0 4
30802: PUSH
30803: LD_INT 2
30805: ARRAY
30806: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
30807: LD_ADDR_VAR 0 14
30811: PUSH
30812: LD_INT 0
30814: PUSH
30815: LD_INT 2
30817: PUSH
30818: LD_INT 3
30820: PUSH
30821: LD_INT 5
30823: PUSH
30824: EMPTY
30825: LIST
30826: LIST
30827: LIST
30828: LIST
30829: ST_TO_ADDR
// for i in tmp do
30830: LD_ADDR_VAR 0 8
30834: PUSH
30835: LD_VAR 0 14
30839: PUSH
30840: FOR_IN
30841: IFFALSE 31011
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
30843: LD_ADDR_VAR 0 9
30847: PUSH
30848: LD_VAR 0 10
30852: PPUSH
30853: LD_VAR 0 8
30857: PPUSH
30858: LD_INT 5
30860: PPUSH
30861: CALL_OW 272
30865: PUSH
30866: LD_VAR 0 11
30870: PPUSH
30871: LD_VAR 0 8
30875: PPUSH
30876: LD_INT 5
30878: PPUSH
30879: CALL_OW 273
30883: PUSH
30884: EMPTY
30885: LIST
30886: LIST
30887: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
30888: LD_VAR 0 9
30892: PUSH
30893: LD_INT 1
30895: ARRAY
30896: PPUSH
30897: LD_VAR 0 9
30901: PUSH
30902: LD_INT 2
30904: ARRAY
30905: PPUSH
30906: CALL_OW 488
30910: IFFALSE 31009
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
30912: LD_ADDR_VAR 0 4
30916: PUSH
30917: LD_VAR 0 9
30921: PUSH
30922: LD_INT 1
30924: ARRAY
30925: PPUSH
30926: LD_VAR 0 9
30930: PUSH
30931: LD_INT 2
30933: ARRAY
30934: PPUSH
30935: CALL_OW 546
30939: ST_TO_ADDR
// if hex [ 1 ] then
30940: LD_VAR 0 4
30944: PUSH
30945: LD_INT 1
30947: ARRAY
30948: IFFALSE 30952
// continue ;
30950: GO 30840
// h := hex [ 2 ] ;
30952: LD_ADDR_VAR 0 13
30956: PUSH
30957: LD_VAR 0 4
30961: PUSH
30962: LD_INT 2
30964: ARRAY
30965: ST_TO_ADDR
// if h + 7 < height then
30966: LD_VAR 0 13
30970: PUSH
30971: LD_INT 7
30973: PLUS
30974: PUSH
30975: LD_VAR 0 15
30979: LESS
30980: IFFALSE 31009
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
30982: LD_ADDR_VAR 0 18
30986: PUSH
30987: LD_INT 7
30989: PUSH
30990: LD_INT 28
30992: PUSH
30993: LD_INT 45
30995: PUSH
30996: EMPTY
30997: LIST
30998: LIST
30999: LIST
31000: PUSH
31001: LD_VAR 0 12
31005: ARRAY
31006: ST_TO_ADDR
// break ;
31007: GO 31011
// end ; end ; end ;
31009: GO 30840
31011: POP
31012: POP
// end ; if not weapon then
31013: LD_VAR 0 18
31017: NOT
31018: IFFALSE 31078
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
31020: LD_ADDR_VAR 0 5
31024: PUSH
31025: LD_VAR 0 5
31029: PUSH
31030: LD_INT 11
31032: PUSH
31033: LD_INT 30
31035: PUSH
31036: LD_INT 49
31038: PUSH
31039: EMPTY
31040: LIST
31041: LIST
31042: LIST
31043: DIFF
31044: ST_TO_ADDR
// if not list then
31045: LD_VAR 0 5
31049: NOT
31050: IFFALSE 31054
// exit ;
31052: GO 31196
// weapon := list [ rand ( 1 , list ) ] ;
31054: LD_ADDR_VAR 0 18
31058: PUSH
31059: LD_VAR 0 5
31063: PUSH
31064: LD_INT 1
31066: PPUSH
31067: LD_VAR 0 5
31071: PPUSH
31072: CALL_OW 12
31076: ARRAY
31077: ST_TO_ADDR
// end ; if weapon then
31078: LD_VAR 0 18
31082: IFFALSE 31196
// begin tmp := CostOfWeapon ( weapon ) ;
31084: LD_ADDR_VAR 0 14
31088: PUSH
31089: LD_VAR 0 18
31093: PPUSH
31094: CALL_OW 451
31098: ST_TO_ADDR
// j := GetBase ( tower ) ;
31099: LD_ADDR_VAR 0 9
31103: PUSH
31104: LD_VAR 0 1
31108: PPUSH
31109: CALL_OW 274
31113: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
31114: LD_VAR 0 9
31118: PPUSH
31119: LD_INT 1
31121: PPUSH
31122: CALL_OW 275
31126: PUSH
31127: LD_VAR 0 14
31131: PUSH
31132: LD_INT 1
31134: ARRAY
31135: GREATEREQUAL
31136: PUSH
31137: LD_VAR 0 9
31141: PPUSH
31142: LD_INT 2
31144: PPUSH
31145: CALL_OW 275
31149: PUSH
31150: LD_VAR 0 14
31154: PUSH
31155: LD_INT 2
31157: ARRAY
31158: GREATEREQUAL
31159: AND
31160: PUSH
31161: LD_VAR 0 9
31165: PPUSH
31166: LD_INT 3
31168: PPUSH
31169: CALL_OW 275
31173: PUSH
31174: LD_VAR 0 14
31178: PUSH
31179: LD_INT 3
31181: ARRAY
31182: GREATEREQUAL
31183: AND
31184: IFFALSE 31196
// result := weapon ;
31186: LD_ADDR_VAR 0 3
31190: PUSH
31191: LD_VAR 0 18
31195: ST_TO_ADDR
// end ; end ;
31196: LD_VAR 0 3
31200: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
31201: LD_INT 0
31203: PPUSH
31204: PPUSH
// result := true ;
31205: LD_ADDR_VAR 0 3
31209: PUSH
31210: LD_INT 1
31212: ST_TO_ADDR
// if array1 = array2 then
31213: LD_VAR 0 1
31217: PUSH
31218: LD_VAR 0 2
31222: EQUAL
31223: IFFALSE 31283
// begin for i = 1 to array1 do
31225: LD_ADDR_VAR 0 4
31229: PUSH
31230: DOUBLE
31231: LD_INT 1
31233: DEC
31234: ST_TO_ADDR
31235: LD_VAR 0 1
31239: PUSH
31240: FOR_TO
31241: IFFALSE 31279
// if array1 [ i ] <> array2 [ i ] then
31243: LD_VAR 0 1
31247: PUSH
31248: LD_VAR 0 4
31252: ARRAY
31253: PUSH
31254: LD_VAR 0 2
31258: PUSH
31259: LD_VAR 0 4
31263: ARRAY
31264: NONEQUAL
31265: IFFALSE 31277
// begin result := false ;
31267: LD_ADDR_VAR 0 3
31271: PUSH
31272: LD_INT 0
31274: ST_TO_ADDR
// break ;
31275: GO 31279
// end ;
31277: GO 31240
31279: POP
31280: POP
// end else
31281: GO 31291
// result := false ;
31283: LD_ADDR_VAR 0 3
31287: PUSH
31288: LD_INT 0
31290: ST_TO_ADDR
// end ;
31291: LD_VAR 0 3
31295: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
31296: LD_INT 0
31298: PPUSH
31299: PPUSH
// if not array1 or not array2 then
31300: LD_VAR 0 1
31304: NOT
31305: PUSH
31306: LD_VAR 0 2
31310: NOT
31311: OR
31312: IFFALSE 31316
// exit ;
31314: GO 31380
// result := true ;
31316: LD_ADDR_VAR 0 3
31320: PUSH
31321: LD_INT 1
31323: ST_TO_ADDR
// for i = 1 to array1 do
31324: LD_ADDR_VAR 0 4
31328: PUSH
31329: DOUBLE
31330: LD_INT 1
31332: DEC
31333: ST_TO_ADDR
31334: LD_VAR 0 1
31338: PUSH
31339: FOR_TO
31340: IFFALSE 31378
// if array1 [ i ] <> array2 [ i ] then
31342: LD_VAR 0 1
31346: PUSH
31347: LD_VAR 0 4
31351: ARRAY
31352: PUSH
31353: LD_VAR 0 2
31357: PUSH
31358: LD_VAR 0 4
31362: ARRAY
31363: NONEQUAL
31364: IFFALSE 31376
// begin result := false ;
31366: LD_ADDR_VAR 0 3
31370: PUSH
31371: LD_INT 0
31373: ST_TO_ADDR
// break ;
31374: GO 31378
// end ;
31376: GO 31339
31378: POP
31379: POP
// end ;
31380: LD_VAR 0 3
31384: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
31385: LD_INT 0
31387: PPUSH
31388: PPUSH
31389: PPUSH
// pom := GetBase ( fac ) ;
31390: LD_ADDR_VAR 0 5
31394: PUSH
31395: LD_VAR 0 1
31399: PPUSH
31400: CALL_OW 274
31404: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
31405: LD_ADDR_VAR 0 4
31409: PUSH
31410: LD_VAR 0 2
31414: PUSH
31415: LD_INT 1
31417: ARRAY
31418: PPUSH
31419: LD_VAR 0 2
31423: PUSH
31424: LD_INT 2
31426: ARRAY
31427: PPUSH
31428: LD_VAR 0 2
31432: PUSH
31433: LD_INT 3
31435: ARRAY
31436: PPUSH
31437: LD_VAR 0 2
31441: PUSH
31442: LD_INT 4
31444: ARRAY
31445: PPUSH
31446: CALL_OW 449
31450: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
31451: LD_ADDR_VAR 0 3
31455: PUSH
31456: LD_VAR 0 5
31460: PPUSH
31461: LD_INT 1
31463: PPUSH
31464: CALL_OW 275
31468: PUSH
31469: LD_VAR 0 4
31473: PUSH
31474: LD_INT 1
31476: ARRAY
31477: GREATEREQUAL
31478: PUSH
31479: LD_VAR 0 5
31483: PPUSH
31484: LD_INT 2
31486: PPUSH
31487: CALL_OW 275
31491: PUSH
31492: LD_VAR 0 4
31496: PUSH
31497: LD_INT 2
31499: ARRAY
31500: GREATEREQUAL
31501: AND
31502: PUSH
31503: LD_VAR 0 5
31507: PPUSH
31508: LD_INT 3
31510: PPUSH
31511: CALL_OW 275
31515: PUSH
31516: LD_VAR 0 4
31520: PUSH
31521: LD_INT 3
31523: ARRAY
31524: GREATEREQUAL
31525: AND
31526: ST_TO_ADDR
// end ;
31527: LD_VAR 0 3
31531: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
31532: LD_INT 0
31534: PPUSH
31535: PPUSH
31536: PPUSH
31537: PPUSH
// pom := GetBase ( building ) ;
31538: LD_ADDR_VAR 0 3
31542: PUSH
31543: LD_VAR 0 1
31547: PPUSH
31548: CALL_OW 274
31552: ST_TO_ADDR
// if not pom then
31553: LD_VAR 0 3
31557: NOT
31558: IFFALSE 31562
// exit ;
31560: GO 31732
// btype := GetBType ( building ) ;
31562: LD_ADDR_VAR 0 5
31566: PUSH
31567: LD_VAR 0 1
31571: PPUSH
31572: CALL_OW 266
31576: ST_TO_ADDR
// if btype = b_armoury then
31577: LD_VAR 0 5
31581: PUSH
31582: LD_INT 4
31584: EQUAL
31585: IFFALSE 31595
// btype := b_barracks ;
31587: LD_ADDR_VAR 0 5
31591: PUSH
31592: LD_INT 5
31594: ST_TO_ADDR
// if btype = b_depot then
31595: LD_VAR 0 5
31599: PUSH
31600: LD_INT 0
31602: EQUAL
31603: IFFALSE 31613
// btype := b_warehouse ;
31605: LD_ADDR_VAR 0 5
31609: PUSH
31610: LD_INT 1
31612: ST_TO_ADDR
// if btype = b_workshop then
31613: LD_VAR 0 5
31617: PUSH
31618: LD_INT 2
31620: EQUAL
31621: IFFALSE 31631
// btype := b_factory ;
31623: LD_ADDR_VAR 0 5
31627: PUSH
31628: LD_INT 3
31630: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
31631: LD_ADDR_VAR 0 4
31635: PUSH
31636: LD_VAR 0 5
31640: PPUSH
31641: LD_VAR 0 1
31645: PPUSH
31646: CALL_OW 248
31650: PPUSH
31651: CALL_OW 450
31655: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
31656: LD_ADDR_VAR 0 2
31660: PUSH
31661: LD_VAR 0 3
31665: PPUSH
31666: LD_INT 1
31668: PPUSH
31669: CALL_OW 275
31673: PUSH
31674: LD_VAR 0 4
31678: PUSH
31679: LD_INT 1
31681: ARRAY
31682: GREATEREQUAL
31683: PUSH
31684: LD_VAR 0 3
31688: PPUSH
31689: LD_INT 2
31691: PPUSH
31692: CALL_OW 275
31696: PUSH
31697: LD_VAR 0 4
31701: PUSH
31702: LD_INT 2
31704: ARRAY
31705: GREATEREQUAL
31706: AND
31707: PUSH
31708: LD_VAR 0 3
31712: PPUSH
31713: LD_INT 3
31715: PPUSH
31716: CALL_OW 275
31720: PUSH
31721: LD_VAR 0 4
31725: PUSH
31726: LD_INT 3
31728: ARRAY
31729: GREATEREQUAL
31730: AND
31731: ST_TO_ADDR
// end ;
31732: LD_VAR 0 2
31736: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
31737: LD_INT 0
31739: PPUSH
31740: PPUSH
31741: PPUSH
// pom := GetBase ( building ) ;
31742: LD_ADDR_VAR 0 4
31746: PUSH
31747: LD_VAR 0 1
31751: PPUSH
31752: CALL_OW 274
31756: ST_TO_ADDR
// if not pom then
31757: LD_VAR 0 4
31761: NOT
31762: IFFALSE 31766
// exit ;
31764: GO 31867
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
31766: LD_ADDR_VAR 0 5
31770: PUSH
31771: LD_VAR 0 2
31775: PPUSH
31776: LD_VAR 0 1
31780: PPUSH
31781: CALL_OW 248
31785: PPUSH
31786: CALL_OW 450
31790: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
31791: LD_ADDR_VAR 0 3
31795: PUSH
31796: LD_VAR 0 4
31800: PPUSH
31801: LD_INT 1
31803: PPUSH
31804: CALL_OW 275
31808: PUSH
31809: LD_VAR 0 5
31813: PUSH
31814: LD_INT 1
31816: ARRAY
31817: GREATEREQUAL
31818: PUSH
31819: LD_VAR 0 4
31823: PPUSH
31824: LD_INT 2
31826: PPUSH
31827: CALL_OW 275
31831: PUSH
31832: LD_VAR 0 5
31836: PUSH
31837: LD_INT 2
31839: ARRAY
31840: GREATEREQUAL
31841: AND
31842: PUSH
31843: LD_VAR 0 4
31847: PPUSH
31848: LD_INT 3
31850: PPUSH
31851: CALL_OW 275
31855: PUSH
31856: LD_VAR 0 5
31860: PUSH
31861: LD_INT 3
31863: ARRAY
31864: GREATEREQUAL
31865: AND
31866: ST_TO_ADDR
// end ;
31867: LD_VAR 0 3
31871: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
31872: LD_INT 0
31874: PPUSH
31875: PPUSH
31876: PPUSH
31877: PPUSH
31878: PPUSH
31879: PPUSH
31880: PPUSH
31881: PPUSH
31882: PPUSH
31883: PPUSH
31884: PPUSH
// result := false ;
31885: LD_ADDR_VAR 0 8
31889: PUSH
31890: LD_INT 0
31892: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
31893: LD_VAR 0 5
31897: NOT
31898: PUSH
31899: LD_VAR 0 1
31903: NOT
31904: OR
31905: PUSH
31906: LD_VAR 0 2
31910: NOT
31911: OR
31912: PUSH
31913: LD_VAR 0 3
31917: NOT
31918: OR
31919: IFFALSE 31923
// exit ;
31921: GO 32737
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
31923: LD_ADDR_VAR 0 14
31927: PUSH
31928: LD_VAR 0 1
31932: PPUSH
31933: LD_VAR 0 2
31937: PPUSH
31938: LD_VAR 0 3
31942: PPUSH
31943: LD_VAR 0 4
31947: PPUSH
31948: LD_VAR 0 5
31952: PUSH
31953: LD_INT 1
31955: ARRAY
31956: PPUSH
31957: CALL_OW 248
31961: PPUSH
31962: LD_INT 0
31964: PPUSH
31965: CALL 33970 0 6
31969: ST_TO_ADDR
// if not hexes then
31970: LD_VAR 0 14
31974: NOT
31975: IFFALSE 31979
// exit ;
31977: GO 32737
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
31979: LD_ADDR_VAR 0 17
31983: PUSH
31984: LD_VAR 0 5
31988: PPUSH
31989: LD_INT 22
31991: PUSH
31992: LD_VAR 0 13
31996: PPUSH
31997: CALL_OW 255
32001: PUSH
32002: EMPTY
32003: LIST
32004: LIST
32005: PUSH
32006: LD_INT 2
32008: PUSH
32009: LD_INT 30
32011: PUSH
32012: LD_INT 0
32014: PUSH
32015: EMPTY
32016: LIST
32017: LIST
32018: PUSH
32019: LD_INT 30
32021: PUSH
32022: LD_INT 1
32024: PUSH
32025: EMPTY
32026: LIST
32027: LIST
32028: PUSH
32029: EMPTY
32030: LIST
32031: LIST
32032: LIST
32033: PUSH
32034: EMPTY
32035: LIST
32036: LIST
32037: PPUSH
32038: CALL_OW 72
32042: ST_TO_ADDR
// for i = 1 to hexes do
32043: LD_ADDR_VAR 0 9
32047: PUSH
32048: DOUBLE
32049: LD_INT 1
32051: DEC
32052: ST_TO_ADDR
32053: LD_VAR 0 14
32057: PUSH
32058: FOR_TO
32059: IFFALSE 32735
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
32061: LD_ADDR_VAR 0 13
32065: PUSH
32066: LD_VAR 0 14
32070: PUSH
32071: LD_VAR 0 9
32075: ARRAY
32076: PUSH
32077: LD_INT 1
32079: ARRAY
32080: PPUSH
32081: LD_VAR 0 14
32085: PUSH
32086: LD_VAR 0 9
32090: ARRAY
32091: PUSH
32092: LD_INT 2
32094: ARRAY
32095: PPUSH
32096: CALL_OW 428
32100: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
32101: LD_VAR 0 14
32105: PUSH
32106: LD_VAR 0 9
32110: ARRAY
32111: PUSH
32112: LD_INT 1
32114: ARRAY
32115: PPUSH
32116: LD_VAR 0 14
32120: PUSH
32121: LD_VAR 0 9
32125: ARRAY
32126: PUSH
32127: LD_INT 2
32129: ARRAY
32130: PPUSH
32131: CALL_OW 351
32135: PUSH
32136: LD_VAR 0 14
32140: PUSH
32141: LD_VAR 0 9
32145: ARRAY
32146: PUSH
32147: LD_INT 1
32149: ARRAY
32150: PPUSH
32151: LD_VAR 0 14
32155: PUSH
32156: LD_VAR 0 9
32160: ARRAY
32161: PUSH
32162: LD_INT 2
32164: ARRAY
32165: PPUSH
32166: CALL_OW 488
32170: NOT
32171: OR
32172: PUSH
32173: LD_VAR 0 13
32177: PPUSH
32178: CALL_OW 247
32182: PUSH
32183: LD_INT 3
32185: EQUAL
32186: OR
32187: IFFALSE 32193
// exit ;
32189: POP
32190: POP
32191: GO 32737
// if not tmp then
32193: LD_VAR 0 13
32197: NOT
32198: IFFALSE 32202
// continue ;
32200: GO 32058
// result := true ;
32202: LD_ADDR_VAR 0 8
32206: PUSH
32207: LD_INT 1
32209: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
32210: LD_VAR 0 6
32214: PUSH
32215: LD_VAR 0 13
32219: PPUSH
32220: CALL_OW 247
32224: PUSH
32225: LD_INT 2
32227: EQUAL
32228: AND
32229: PUSH
32230: LD_VAR 0 13
32234: PPUSH
32235: CALL_OW 263
32239: PUSH
32240: LD_INT 1
32242: EQUAL
32243: AND
32244: IFFALSE 32408
// begin if IsDrivenBy ( tmp ) then
32246: LD_VAR 0 13
32250: PPUSH
32251: CALL_OW 311
32255: IFFALSE 32259
// continue ;
32257: GO 32058
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
32259: LD_VAR 0 6
32263: PPUSH
32264: LD_INT 3
32266: PUSH
32267: LD_INT 60
32269: PUSH
32270: EMPTY
32271: LIST
32272: PUSH
32273: EMPTY
32274: LIST
32275: LIST
32276: PUSH
32277: LD_INT 3
32279: PUSH
32280: LD_INT 55
32282: PUSH
32283: EMPTY
32284: LIST
32285: PUSH
32286: EMPTY
32287: LIST
32288: LIST
32289: PUSH
32290: EMPTY
32291: LIST
32292: LIST
32293: PPUSH
32294: CALL_OW 72
32298: IFFALSE 32406
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
32300: LD_ADDR_VAR 0 18
32304: PUSH
32305: LD_VAR 0 6
32309: PPUSH
32310: LD_INT 3
32312: PUSH
32313: LD_INT 60
32315: PUSH
32316: EMPTY
32317: LIST
32318: PUSH
32319: EMPTY
32320: LIST
32321: LIST
32322: PUSH
32323: LD_INT 3
32325: PUSH
32326: LD_INT 55
32328: PUSH
32329: EMPTY
32330: LIST
32331: PUSH
32332: EMPTY
32333: LIST
32334: LIST
32335: PUSH
32336: EMPTY
32337: LIST
32338: LIST
32339: PPUSH
32340: CALL_OW 72
32344: PUSH
32345: LD_INT 1
32347: ARRAY
32348: ST_TO_ADDR
// if IsInUnit ( driver ) then
32349: LD_VAR 0 18
32353: PPUSH
32354: CALL_OW 310
32358: IFFALSE 32369
// ComExit ( driver ) ;
32360: LD_VAR 0 18
32364: PPUSH
32365: CALL 57731 0 1
// AddComEnterUnit ( driver , tmp ) ;
32369: LD_VAR 0 18
32373: PPUSH
32374: LD_VAR 0 13
32378: PPUSH
32379: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
32383: LD_VAR 0 18
32387: PPUSH
32388: LD_VAR 0 7
32392: PPUSH
32393: CALL_OW 173
// AddComExitVehicle ( driver ) ;
32397: LD_VAR 0 18
32401: PPUSH
32402: CALL_OW 181
// end ; continue ;
32406: GO 32058
// end ; if not cleaners or not tmp in cleaners then
32408: LD_VAR 0 6
32412: NOT
32413: PUSH
32414: LD_VAR 0 13
32418: PUSH
32419: LD_VAR 0 6
32423: IN
32424: NOT
32425: OR
32426: IFFALSE 32733
// begin if dep then
32428: LD_VAR 0 17
32432: IFFALSE 32568
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
32434: LD_ADDR_VAR 0 16
32438: PUSH
32439: LD_VAR 0 17
32443: PUSH
32444: LD_INT 1
32446: ARRAY
32447: PPUSH
32448: CALL_OW 250
32452: PPUSH
32453: LD_VAR 0 17
32457: PUSH
32458: LD_INT 1
32460: ARRAY
32461: PPUSH
32462: CALL_OW 254
32466: PPUSH
32467: LD_INT 5
32469: PPUSH
32470: CALL_OW 272
32474: PUSH
32475: LD_VAR 0 17
32479: PUSH
32480: LD_INT 1
32482: ARRAY
32483: PPUSH
32484: CALL_OW 251
32488: PPUSH
32489: LD_VAR 0 17
32493: PUSH
32494: LD_INT 1
32496: ARRAY
32497: PPUSH
32498: CALL_OW 254
32502: PPUSH
32503: LD_INT 5
32505: PPUSH
32506: CALL_OW 273
32510: PUSH
32511: EMPTY
32512: LIST
32513: LIST
32514: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
32515: LD_VAR 0 16
32519: PUSH
32520: LD_INT 1
32522: ARRAY
32523: PPUSH
32524: LD_VAR 0 16
32528: PUSH
32529: LD_INT 2
32531: ARRAY
32532: PPUSH
32533: CALL_OW 488
32537: IFFALSE 32568
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
32539: LD_VAR 0 13
32543: PPUSH
32544: LD_VAR 0 16
32548: PUSH
32549: LD_INT 1
32551: ARRAY
32552: PPUSH
32553: LD_VAR 0 16
32557: PUSH
32558: LD_INT 2
32560: ARRAY
32561: PPUSH
32562: CALL_OW 111
// continue ;
32566: GO 32058
// end ; end ; r := GetDir ( tmp ) ;
32568: LD_ADDR_VAR 0 15
32572: PUSH
32573: LD_VAR 0 13
32577: PPUSH
32578: CALL_OW 254
32582: ST_TO_ADDR
// if r = 5 then
32583: LD_VAR 0 15
32587: PUSH
32588: LD_INT 5
32590: EQUAL
32591: IFFALSE 32601
// r := 0 ;
32593: LD_ADDR_VAR 0 15
32597: PUSH
32598: LD_INT 0
32600: ST_TO_ADDR
// for j = r to 5 do
32601: LD_ADDR_VAR 0 10
32605: PUSH
32606: DOUBLE
32607: LD_VAR 0 15
32611: DEC
32612: ST_TO_ADDR
32613: LD_INT 5
32615: PUSH
32616: FOR_TO
32617: IFFALSE 32731
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
32619: LD_ADDR_VAR 0 11
32623: PUSH
32624: LD_VAR 0 13
32628: PPUSH
32629: CALL_OW 250
32633: PPUSH
32634: LD_VAR 0 10
32638: PPUSH
32639: LD_INT 2
32641: PPUSH
32642: CALL_OW 272
32646: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
32647: LD_ADDR_VAR 0 12
32651: PUSH
32652: LD_VAR 0 13
32656: PPUSH
32657: CALL_OW 251
32661: PPUSH
32662: LD_VAR 0 10
32666: PPUSH
32667: LD_INT 2
32669: PPUSH
32670: CALL_OW 273
32674: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
32675: LD_VAR 0 11
32679: PPUSH
32680: LD_VAR 0 12
32684: PPUSH
32685: CALL_OW 488
32689: PUSH
32690: LD_VAR 0 11
32694: PPUSH
32695: LD_VAR 0 12
32699: PPUSH
32700: CALL_OW 428
32704: NOT
32705: AND
32706: IFFALSE 32729
// begin ComMoveXY ( tmp , _x , _y ) ;
32708: LD_VAR 0 13
32712: PPUSH
32713: LD_VAR 0 11
32717: PPUSH
32718: LD_VAR 0 12
32722: PPUSH
32723: CALL_OW 111
// break ;
32727: GO 32731
// end ; end ;
32729: GO 32616
32731: POP
32732: POP
// end ; end ;
32733: GO 32058
32735: POP
32736: POP
// end ;
32737: LD_VAR 0 8
32741: RET
// export function BuildingTechInvented ( side , btype ) ; begin
32742: LD_INT 0
32744: PPUSH
// result := true ;
32745: LD_ADDR_VAR 0 3
32749: PUSH
32750: LD_INT 1
32752: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
32753: LD_VAR 0 2
32757: PUSH
32758: LD_INT 24
32760: DOUBLE
32761: EQUAL
32762: IFTRUE 32772
32764: LD_INT 33
32766: DOUBLE
32767: EQUAL
32768: IFTRUE 32772
32770: GO 32797
32772: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
32773: LD_ADDR_VAR 0 3
32777: PUSH
32778: LD_INT 32
32780: PPUSH
32781: LD_VAR 0 1
32785: PPUSH
32786: CALL_OW 321
32790: PUSH
32791: LD_INT 2
32793: EQUAL
32794: ST_TO_ADDR
32795: GO 33113
32797: LD_INT 20
32799: DOUBLE
32800: EQUAL
32801: IFTRUE 32805
32803: GO 32830
32805: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
32806: LD_ADDR_VAR 0 3
32810: PUSH
32811: LD_INT 6
32813: PPUSH
32814: LD_VAR 0 1
32818: PPUSH
32819: CALL_OW 321
32823: PUSH
32824: LD_INT 2
32826: EQUAL
32827: ST_TO_ADDR
32828: GO 33113
32830: LD_INT 22
32832: DOUBLE
32833: EQUAL
32834: IFTRUE 32844
32836: LD_INT 36
32838: DOUBLE
32839: EQUAL
32840: IFTRUE 32844
32842: GO 32869
32844: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
32845: LD_ADDR_VAR 0 3
32849: PUSH
32850: LD_INT 15
32852: PPUSH
32853: LD_VAR 0 1
32857: PPUSH
32858: CALL_OW 321
32862: PUSH
32863: LD_INT 2
32865: EQUAL
32866: ST_TO_ADDR
32867: GO 33113
32869: LD_INT 30
32871: DOUBLE
32872: EQUAL
32873: IFTRUE 32877
32875: GO 32902
32877: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
32878: LD_ADDR_VAR 0 3
32882: PUSH
32883: LD_INT 20
32885: PPUSH
32886: LD_VAR 0 1
32890: PPUSH
32891: CALL_OW 321
32895: PUSH
32896: LD_INT 2
32898: EQUAL
32899: ST_TO_ADDR
32900: GO 33113
32902: LD_INT 28
32904: DOUBLE
32905: EQUAL
32906: IFTRUE 32916
32908: LD_INT 21
32910: DOUBLE
32911: EQUAL
32912: IFTRUE 32916
32914: GO 32941
32916: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
32917: LD_ADDR_VAR 0 3
32921: PUSH
32922: LD_INT 21
32924: PPUSH
32925: LD_VAR 0 1
32929: PPUSH
32930: CALL_OW 321
32934: PUSH
32935: LD_INT 2
32937: EQUAL
32938: ST_TO_ADDR
32939: GO 33113
32941: LD_INT 16
32943: DOUBLE
32944: EQUAL
32945: IFTRUE 32949
32947: GO 32974
32949: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
32950: LD_ADDR_VAR 0 3
32954: PUSH
32955: LD_INT 84
32957: PPUSH
32958: LD_VAR 0 1
32962: PPUSH
32963: CALL_OW 321
32967: PUSH
32968: LD_INT 2
32970: EQUAL
32971: ST_TO_ADDR
32972: GO 33113
32974: LD_INT 19
32976: DOUBLE
32977: EQUAL
32978: IFTRUE 32988
32980: LD_INT 23
32982: DOUBLE
32983: EQUAL
32984: IFTRUE 32988
32986: GO 33013
32988: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
32989: LD_ADDR_VAR 0 3
32993: PUSH
32994: LD_INT 83
32996: PPUSH
32997: LD_VAR 0 1
33001: PPUSH
33002: CALL_OW 321
33006: PUSH
33007: LD_INT 2
33009: EQUAL
33010: ST_TO_ADDR
33011: GO 33113
33013: LD_INT 17
33015: DOUBLE
33016: EQUAL
33017: IFTRUE 33021
33019: GO 33046
33021: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
33022: LD_ADDR_VAR 0 3
33026: PUSH
33027: LD_INT 39
33029: PPUSH
33030: LD_VAR 0 1
33034: PPUSH
33035: CALL_OW 321
33039: PUSH
33040: LD_INT 2
33042: EQUAL
33043: ST_TO_ADDR
33044: GO 33113
33046: LD_INT 18
33048: DOUBLE
33049: EQUAL
33050: IFTRUE 33054
33052: GO 33079
33054: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
33055: LD_ADDR_VAR 0 3
33059: PUSH
33060: LD_INT 40
33062: PPUSH
33063: LD_VAR 0 1
33067: PPUSH
33068: CALL_OW 321
33072: PUSH
33073: LD_INT 2
33075: EQUAL
33076: ST_TO_ADDR
33077: GO 33113
33079: LD_INT 27
33081: DOUBLE
33082: EQUAL
33083: IFTRUE 33087
33085: GO 33112
33087: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
33088: LD_ADDR_VAR 0 3
33092: PUSH
33093: LD_INT 35
33095: PPUSH
33096: LD_VAR 0 1
33100: PPUSH
33101: CALL_OW 321
33105: PUSH
33106: LD_INT 2
33108: EQUAL
33109: ST_TO_ADDR
33110: GO 33113
33112: POP
// end ;
33113: LD_VAR 0 3
33117: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
33118: LD_INT 0
33120: PPUSH
33121: PPUSH
33122: PPUSH
33123: PPUSH
33124: PPUSH
33125: PPUSH
33126: PPUSH
33127: PPUSH
33128: PPUSH
33129: PPUSH
33130: PPUSH
// result := false ;
33131: LD_ADDR_VAR 0 6
33135: PUSH
33136: LD_INT 0
33138: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
33139: LD_VAR 0 1
33143: NOT
33144: PUSH
33145: LD_VAR 0 1
33149: PPUSH
33150: CALL_OW 266
33154: PUSH
33155: LD_INT 0
33157: PUSH
33158: LD_INT 1
33160: PUSH
33161: EMPTY
33162: LIST
33163: LIST
33164: IN
33165: NOT
33166: OR
33167: PUSH
33168: LD_VAR 0 2
33172: NOT
33173: OR
33174: PUSH
33175: LD_VAR 0 5
33179: PUSH
33180: LD_INT 0
33182: PUSH
33183: LD_INT 1
33185: PUSH
33186: LD_INT 2
33188: PUSH
33189: LD_INT 3
33191: PUSH
33192: LD_INT 4
33194: PUSH
33195: LD_INT 5
33197: PUSH
33198: EMPTY
33199: LIST
33200: LIST
33201: LIST
33202: LIST
33203: LIST
33204: LIST
33205: IN
33206: NOT
33207: OR
33208: PUSH
33209: LD_VAR 0 3
33213: PPUSH
33214: LD_VAR 0 4
33218: PPUSH
33219: CALL_OW 488
33223: NOT
33224: OR
33225: IFFALSE 33229
// exit ;
33227: GO 33965
// side := GetSide ( depot ) ;
33229: LD_ADDR_VAR 0 9
33233: PUSH
33234: LD_VAR 0 1
33238: PPUSH
33239: CALL_OW 255
33243: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
33244: LD_VAR 0 9
33248: PPUSH
33249: LD_VAR 0 2
33253: PPUSH
33254: CALL 32742 0 2
33258: NOT
33259: IFFALSE 33263
// exit ;
33261: GO 33965
// pom := GetBase ( depot ) ;
33263: LD_ADDR_VAR 0 10
33267: PUSH
33268: LD_VAR 0 1
33272: PPUSH
33273: CALL_OW 274
33277: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
33278: LD_ADDR_VAR 0 11
33282: PUSH
33283: LD_VAR 0 2
33287: PPUSH
33288: LD_VAR 0 1
33292: PPUSH
33293: CALL_OW 248
33297: PPUSH
33298: CALL_OW 450
33302: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
33303: LD_VAR 0 10
33307: PPUSH
33308: LD_INT 1
33310: PPUSH
33311: CALL_OW 275
33315: PUSH
33316: LD_VAR 0 11
33320: PUSH
33321: LD_INT 1
33323: ARRAY
33324: GREATEREQUAL
33325: PUSH
33326: LD_VAR 0 10
33330: PPUSH
33331: LD_INT 2
33333: PPUSH
33334: CALL_OW 275
33338: PUSH
33339: LD_VAR 0 11
33343: PUSH
33344: LD_INT 2
33346: ARRAY
33347: GREATEREQUAL
33348: AND
33349: PUSH
33350: LD_VAR 0 10
33354: PPUSH
33355: LD_INT 3
33357: PPUSH
33358: CALL_OW 275
33362: PUSH
33363: LD_VAR 0 11
33367: PUSH
33368: LD_INT 3
33370: ARRAY
33371: GREATEREQUAL
33372: AND
33373: NOT
33374: IFFALSE 33378
// exit ;
33376: GO 33965
// if GetBType ( depot ) = b_depot then
33378: LD_VAR 0 1
33382: PPUSH
33383: CALL_OW 266
33387: PUSH
33388: LD_INT 0
33390: EQUAL
33391: IFFALSE 33403
// dist := 28 else
33393: LD_ADDR_VAR 0 14
33397: PUSH
33398: LD_INT 28
33400: ST_TO_ADDR
33401: GO 33411
// dist := 36 ;
33403: LD_ADDR_VAR 0 14
33407: PUSH
33408: LD_INT 36
33410: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
33411: LD_VAR 0 1
33415: PPUSH
33416: LD_VAR 0 3
33420: PPUSH
33421: LD_VAR 0 4
33425: PPUSH
33426: CALL_OW 297
33430: PUSH
33431: LD_VAR 0 14
33435: GREATER
33436: IFFALSE 33440
// exit ;
33438: GO 33965
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
33440: LD_ADDR_VAR 0 12
33444: PUSH
33445: LD_VAR 0 2
33449: PPUSH
33450: LD_VAR 0 3
33454: PPUSH
33455: LD_VAR 0 4
33459: PPUSH
33460: LD_VAR 0 5
33464: PPUSH
33465: LD_VAR 0 1
33469: PPUSH
33470: CALL_OW 248
33474: PPUSH
33475: LD_INT 0
33477: PPUSH
33478: CALL 33970 0 6
33482: ST_TO_ADDR
// if not hexes then
33483: LD_VAR 0 12
33487: NOT
33488: IFFALSE 33492
// exit ;
33490: GO 33965
// hex := GetHexInfo ( x , y ) ;
33492: LD_ADDR_VAR 0 15
33496: PUSH
33497: LD_VAR 0 3
33501: PPUSH
33502: LD_VAR 0 4
33506: PPUSH
33507: CALL_OW 546
33511: ST_TO_ADDR
// if hex [ 1 ] then
33512: LD_VAR 0 15
33516: PUSH
33517: LD_INT 1
33519: ARRAY
33520: IFFALSE 33524
// exit ;
33522: GO 33965
// height := hex [ 2 ] ;
33524: LD_ADDR_VAR 0 13
33528: PUSH
33529: LD_VAR 0 15
33533: PUSH
33534: LD_INT 2
33536: ARRAY
33537: ST_TO_ADDR
// for i = 1 to hexes do
33538: LD_ADDR_VAR 0 7
33542: PUSH
33543: DOUBLE
33544: LD_INT 1
33546: DEC
33547: ST_TO_ADDR
33548: LD_VAR 0 12
33552: PUSH
33553: FOR_TO
33554: IFFALSE 33884
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
33556: LD_VAR 0 12
33560: PUSH
33561: LD_VAR 0 7
33565: ARRAY
33566: PUSH
33567: LD_INT 1
33569: ARRAY
33570: PPUSH
33571: LD_VAR 0 12
33575: PUSH
33576: LD_VAR 0 7
33580: ARRAY
33581: PUSH
33582: LD_INT 2
33584: ARRAY
33585: PPUSH
33586: CALL_OW 488
33590: NOT
33591: PUSH
33592: LD_VAR 0 12
33596: PUSH
33597: LD_VAR 0 7
33601: ARRAY
33602: PUSH
33603: LD_INT 1
33605: ARRAY
33606: PPUSH
33607: LD_VAR 0 12
33611: PUSH
33612: LD_VAR 0 7
33616: ARRAY
33617: PUSH
33618: LD_INT 2
33620: ARRAY
33621: PPUSH
33622: CALL_OW 428
33626: PUSH
33627: LD_INT 0
33629: GREATER
33630: OR
33631: PUSH
33632: LD_VAR 0 12
33636: PUSH
33637: LD_VAR 0 7
33641: ARRAY
33642: PUSH
33643: LD_INT 1
33645: ARRAY
33646: PPUSH
33647: LD_VAR 0 12
33651: PUSH
33652: LD_VAR 0 7
33656: ARRAY
33657: PUSH
33658: LD_INT 2
33660: ARRAY
33661: PPUSH
33662: CALL_OW 351
33666: OR
33667: IFFALSE 33673
// exit ;
33669: POP
33670: POP
33671: GO 33965
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
33673: LD_ADDR_VAR 0 8
33677: PUSH
33678: LD_VAR 0 12
33682: PUSH
33683: LD_VAR 0 7
33687: ARRAY
33688: PUSH
33689: LD_INT 1
33691: ARRAY
33692: PPUSH
33693: LD_VAR 0 12
33697: PUSH
33698: LD_VAR 0 7
33702: ARRAY
33703: PUSH
33704: LD_INT 2
33706: ARRAY
33707: PPUSH
33708: CALL_OW 546
33712: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
33713: LD_VAR 0 8
33717: PUSH
33718: LD_INT 1
33720: ARRAY
33721: PUSH
33722: LD_VAR 0 8
33726: PUSH
33727: LD_INT 2
33729: ARRAY
33730: PUSH
33731: LD_VAR 0 13
33735: PUSH
33736: LD_INT 2
33738: PLUS
33739: GREATER
33740: OR
33741: PUSH
33742: LD_VAR 0 8
33746: PUSH
33747: LD_INT 2
33749: ARRAY
33750: PUSH
33751: LD_VAR 0 13
33755: PUSH
33756: LD_INT 2
33758: MINUS
33759: LESS
33760: OR
33761: PUSH
33762: LD_VAR 0 8
33766: PUSH
33767: LD_INT 3
33769: ARRAY
33770: PUSH
33771: LD_INT 0
33773: PUSH
33774: LD_INT 8
33776: PUSH
33777: LD_INT 9
33779: PUSH
33780: LD_INT 10
33782: PUSH
33783: LD_INT 11
33785: PUSH
33786: LD_INT 12
33788: PUSH
33789: LD_INT 13
33791: PUSH
33792: LD_INT 16
33794: PUSH
33795: LD_INT 17
33797: PUSH
33798: LD_INT 18
33800: PUSH
33801: LD_INT 19
33803: PUSH
33804: LD_INT 20
33806: PUSH
33807: LD_INT 21
33809: PUSH
33810: EMPTY
33811: LIST
33812: LIST
33813: LIST
33814: LIST
33815: LIST
33816: LIST
33817: LIST
33818: LIST
33819: LIST
33820: LIST
33821: LIST
33822: LIST
33823: LIST
33824: IN
33825: NOT
33826: OR
33827: PUSH
33828: LD_VAR 0 8
33832: PUSH
33833: LD_INT 5
33835: ARRAY
33836: NOT
33837: OR
33838: PUSH
33839: LD_VAR 0 8
33843: PUSH
33844: LD_INT 6
33846: ARRAY
33847: PUSH
33848: LD_INT 1
33850: PUSH
33851: LD_INT 2
33853: PUSH
33854: LD_INT 7
33856: PUSH
33857: LD_INT 9
33859: PUSH
33860: LD_INT 10
33862: PUSH
33863: LD_INT 11
33865: PUSH
33866: EMPTY
33867: LIST
33868: LIST
33869: LIST
33870: LIST
33871: LIST
33872: LIST
33873: IN
33874: NOT
33875: OR
33876: IFFALSE 33882
// exit ;
33878: POP
33879: POP
33880: GO 33965
// end ;
33882: GO 33553
33884: POP
33885: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
33886: LD_VAR 0 9
33890: PPUSH
33891: LD_VAR 0 3
33895: PPUSH
33896: LD_VAR 0 4
33900: PPUSH
33901: LD_INT 20
33903: PPUSH
33904: CALL 25917 0 4
33908: PUSH
33909: LD_INT 4
33911: ARRAY
33912: IFFALSE 33916
// exit ;
33914: GO 33965
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
33916: LD_VAR 0 2
33920: PUSH
33921: LD_INT 29
33923: PUSH
33924: LD_INT 30
33926: PUSH
33927: EMPTY
33928: LIST
33929: LIST
33930: IN
33931: PUSH
33932: LD_VAR 0 3
33936: PPUSH
33937: LD_VAR 0 4
33941: PPUSH
33942: LD_VAR 0 9
33946: PPUSH
33947: CALL_OW 440
33951: NOT
33952: AND
33953: IFFALSE 33957
// exit ;
33955: GO 33965
// result := true ;
33957: LD_ADDR_VAR 0 6
33961: PUSH
33962: LD_INT 1
33964: ST_TO_ADDR
// end ;
33965: LD_VAR 0 6
33969: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
33970: LD_INT 0
33972: PPUSH
33973: PPUSH
33974: PPUSH
33975: PPUSH
33976: PPUSH
33977: PPUSH
33978: PPUSH
33979: PPUSH
33980: PPUSH
33981: PPUSH
33982: PPUSH
33983: PPUSH
33984: PPUSH
33985: PPUSH
33986: PPUSH
33987: PPUSH
33988: PPUSH
33989: PPUSH
33990: PPUSH
33991: PPUSH
33992: PPUSH
33993: PPUSH
33994: PPUSH
33995: PPUSH
33996: PPUSH
33997: PPUSH
33998: PPUSH
33999: PPUSH
34000: PPUSH
34001: PPUSH
34002: PPUSH
34003: PPUSH
34004: PPUSH
34005: PPUSH
34006: PPUSH
34007: PPUSH
34008: PPUSH
34009: PPUSH
34010: PPUSH
34011: PPUSH
34012: PPUSH
34013: PPUSH
34014: PPUSH
34015: PPUSH
34016: PPUSH
34017: PPUSH
34018: PPUSH
34019: PPUSH
34020: PPUSH
34021: PPUSH
34022: PPUSH
34023: PPUSH
34024: PPUSH
34025: PPUSH
34026: PPUSH
34027: PPUSH
34028: PPUSH
34029: PPUSH
// result = [ ] ;
34030: LD_ADDR_VAR 0 7
34034: PUSH
34035: EMPTY
34036: ST_TO_ADDR
// temp_list = [ ] ;
34037: LD_ADDR_VAR 0 9
34041: PUSH
34042: EMPTY
34043: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
34044: LD_VAR 0 4
34048: PUSH
34049: LD_INT 0
34051: PUSH
34052: LD_INT 1
34054: PUSH
34055: LD_INT 2
34057: PUSH
34058: LD_INT 3
34060: PUSH
34061: LD_INT 4
34063: PUSH
34064: LD_INT 5
34066: PUSH
34067: EMPTY
34068: LIST
34069: LIST
34070: LIST
34071: LIST
34072: LIST
34073: LIST
34074: IN
34075: NOT
34076: PUSH
34077: LD_VAR 0 1
34081: PUSH
34082: LD_INT 0
34084: PUSH
34085: LD_INT 1
34087: PUSH
34088: EMPTY
34089: LIST
34090: LIST
34091: IN
34092: PUSH
34093: LD_VAR 0 5
34097: PUSH
34098: LD_INT 1
34100: PUSH
34101: LD_INT 2
34103: PUSH
34104: LD_INT 3
34106: PUSH
34107: EMPTY
34108: LIST
34109: LIST
34110: LIST
34111: IN
34112: NOT
34113: AND
34114: OR
34115: IFFALSE 34119
// exit ;
34117: GO 52510
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
34119: LD_VAR 0 1
34123: PUSH
34124: LD_INT 6
34126: PUSH
34127: LD_INT 7
34129: PUSH
34130: LD_INT 8
34132: PUSH
34133: LD_INT 13
34135: PUSH
34136: LD_INT 12
34138: PUSH
34139: LD_INT 15
34141: PUSH
34142: LD_INT 11
34144: PUSH
34145: LD_INT 14
34147: PUSH
34148: LD_INT 10
34150: PUSH
34151: EMPTY
34152: LIST
34153: LIST
34154: LIST
34155: LIST
34156: LIST
34157: LIST
34158: LIST
34159: LIST
34160: LIST
34161: IN
34162: IFFALSE 34172
// btype = b_lab ;
34164: LD_ADDR_VAR 0 1
34168: PUSH
34169: LD_INT 6
34171: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
34172: LD_VAR 0 6
34176: PUSH
34177: LD_INT 0
34179: PUSH
34180: LD_INT 1
34182: PUSH
34183: LD_INT 2
34185: PUSH
34186: EMPTY
34187: LIST
34188: LIST
34189: LIST
34190: IN
34191: NOT
34192: PUSH
34193: LD_VAR 0 1
34197: PUSH
34198: LD_INT 0
34200: PUSH
34201: LD_INT 1
34203: PUSH
34204: LD_INT 2
34206: PUSH
34207: LD_INT 3
34209: PUSH
34210: LD_INT 6
34212: PUSH
34213: LD_INT 36
34215: PUSH
34216: LD_INT 4
34218: PUSH
34219: LD_INT 5
34221: PUSH
34222: LD_INT 31
34224: PUSH
34225: LD_INT 32
34227: PUSH
34228: LD_INT 33
34230: PUSH
34231: EMPTY
34232: LIST
34233: LIST
34234: LIST
34235: LIST
34236: LIST
34237: LIST
34238: LIST
34239: LIST
34240: LIST
34241: LIST
34242: LIST
34243: IN
34244: NOT
34245: PUSH
34246: LD_VAR 0 6
34250: PUSH
34251: LD_INT 1
34253: EQUAL
34254: AND
34255: OR
34256: PUSH
34257: LD_VAR 0 1
34261: PUSH
34262: LD_INT 2
34264: PUSH
34265: LD_INT 3
34267: PUSH
34268: EMPTY
34269: LIST
34270: LIST
34271: IN
34272: NOT
34273: PUSH
34274: LD_VAR 0 6
34278: PUSH
34279: LD_INT 2
34281: EQUAL
34282: AND
34283: OR
34284: IFFALSE 34294
// mode = 0 ;
34286: LD_ADDR_VAR 0 6
34290: PUSH
34291: LD_INT 0
34293: ST_TO_ADDR
// case mode of 0 :
34294: LD_VAR 0 6
34298: PUSH
34299: LD_INT 0
34301: DOUBLE
34302: EQUAL
34303: IFTRUE 34307
34305: GO 45760
34307: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
34308: LD_ADDR_VAR 0 11
34312: PUSH
34313: LD_INT 0
34315: PUSH
34316: LD_INT 0
34318: PUSH
34319: EMPTY
34320: LIST
34321: LIST
34322: PUSH
34323: LD_INT 0
34325: PUSH
34326: LD_INT 1
34328: NEG
34329: PUSH
34330: EMPTY
34331: LIST
34332: LIST
34333: PUSH
34334: LD_INT 1
34336: PUSH
34337: LD_INT 0
34339: PUSH
34340: EMPTY
34341: LIST
34342: LIST
34343: PUSH
34344: LD_INT 1
34346: PUSH
34347: LD_INT 1
34349: PUSH
34350: EMPTY
34351: LIST
34352: LIST
34353: PUSH
34354: LD_INT 0
34356: PUSH
34357: LD_INT 1
34359: PUSH
34360: EMPTY
34361: LIST
34362: LIST
34363: PUSH
34364: LD_INT 1
34366: NEG
34367: PUSH
34368: LD_INT 0
34370: PUSH
34371: EMPTY
34372: LIST
34373: LIST
34374: PUSH
34375: LD_INT 1
34377: NEG
34378: PUSH
34379: LD_INT 1
34381: NEG
34382: PUSH
34383: EMPTY
34384: LIST
34385: LIST
34386: PUSH
34387: LD_INT 1
34389: NEG
34390: PUSH
34391: LD_INT 2
34393: NEG
34394: PUSH
34395: EMPTY
34396: LIST
34397: LIST
34398: PUSH
34399: LD_INT 0
34401: PUSH
34402: LD_INT 2
34404: NEG
34405: PUSH
34406: EMPTY
34407: LIST
34408: LIST
34409: PUSH
34410: LD_INT 1
34412: PUSH
34413: LD_INT 1
34415: NEG
34416: PUSH
34417: EMPTY
34418: LIST
34419: LIST
34420: PUSH
34421: LD_INT 1
34423: PUSH
34424: LD_INT 2
34426: PUSH
34427: EMPTY
34428: LIST
34429: LIST
34430: PUSH
34431: LD_INT 0
34433: PUSH
34434: LD_INT 2
34436: PUSH
34437: EMPTY
34438: LIST
34439: LIST
34440: PUSH
34441: LD_INT 1
34443: NEG
34444: PUSH
34445: LD_INT 1
34447: PUSH
34448: EMPTY
34449: LIST
34450: LIST
34451: PUSH
34452: LD_INT 1
34454: PUSH
34455: LD_INT 3
34457: PUSH
34458: EMPTY
34459: LIST
34460: LIST
34461: PUSH
34462: LD_INT 0
34464: PUSH
34465: LD_INT 3
34467: PUSH
34468: EMPTY
34469: LIST
34470: LIST
34471: PUSH
34472: LD_INT 1
34474: NEG
34475: PUSH
34476: LD_INT 2
34478: PUSH
34479: EMPTY
34480: LIST
34481: LIST
34482: PUSH
34483: EMPTY
34484: LIST
34485: LIST
34486: LIST
34487: LIST
34488: LIST
34489: LIST
34490: LIST
34491: LIST
34492: LIST
34493: LIST
34494: LIST
34495: LIST
34496: LIST
34497: LIST
34498: LIST
34499: LIST
34500: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
34501: LD_ADDR_VAR 0 12
34505: PUSH
34506: LD_INT 0
34508: PUSH
34509: LD_INT 0
34511: PUSH
34512: EMPTY
34513: LIST
34514: LIST
34515: PUSH
34516: LD_INT 0
34518: PUSH
34519: LD_INT 1
34521: NEG
34522: PUSH
34523: EMPTY
34524: LIST
34525: LIST
34526: PUSH
34527: LD_INT 1
34529: PUSH
34530: LD_INT 0
34532: PUSH
34533: EMPTY
34534: LIST
34535: LIST
34536: PUSH
34537: LD_INT 1
34539: PUSH
34540: LD_INT 1
34542: PUSH
34543: EMPTY
34544: LIST
34545: LIST
34546: PUSH
34547: LD_INT 0
34549: PUSH
34550: LD_INT 1
34552: PUSH
34553: EMPTY
34554: LIST
34555: LIST
34556: PUSH
34557: LD_INT 1
34559: NEG
34560: PUSH
34561: LD_INT 0
34563: PUSH
34564: EMPTY
34565: LIST
34566: LIST
34567: PUSH
34568: LD_INT 1
34570: NEG
34571: PUSH
34572: LD_INT 1
34574: NEG
34575: PUSH
34576: EMPTY
34577: LIST
34578: LIST
34579: PUSH
34580: LD_INT 1
34582: PUSH
34583: LD_INT 1
34585: NEG
34586: PUSH
34587: EMPTY
34588: LIST
34589: LIST
34590: PUSH
34591: LD_INT 2
34593: PUSH
34594: LD_INT 0
34596: PUSH
34597: EMPTY
34598: LIST
34599: LIST
34600: PUSH
34601: LD_INT 2
34603: PUSH
34604: LD_INT 1
34606: PUSH
34607: EMPTY
34608: LIST
34609: LIST
34610: PUSH
34611: LD_INT 1
34613: NEG
34614: PUSH
34615: LD_INT 1
34617: PUSH
34618: EMPTY
34619: LIST
34620: LIST
34621: PUSH
34622: LD_INT 2
34624: NEG
34625: PUSH
34626: LD_INT 0
34628: PUSH
34629: EMPTY
34630: LIST
34631: LIST
34632: PUSH
34633: LD_INT 2
34635: NEG
34636: PUSH
34637: LD_INT 1
34639: NEG
34640: PUSH
34641: EMPTY
34642: LIST
34643: LIST
34644: PUSH
34645: LD_INT 2
34647: NEG
34648: PUSH
34649: LD_INT 1
34651: PUSH
34652: EMPTY
34653: LIST
34654: LIST
34655: PUSH
34656: LD_INT 3
34658: NEG
34659: PUSH
34660: LD_INT 0
34662: PUSH
34663: EMPTY
34664: LIST
34665: LIST
34666: PUSH
34667: LD_INT 3
34669: NEG
34670: PUSH
34671: LD_INT 1
34673: NEG
34674: PUSH
34675: EMPTY
34676: LIST
34677: LIST
34678: PUSH
34679: EMPTY
34680: LIST
34681: LIST
34682: LIST
34683: LIST
34684: LIST
34685: LIST
34686: LIST
34687: LIST
34688: LIST
34689: LIST
34690: LIST
34691: LIST
34692: LIST
34693: LIST
34694: LIST
34695: LIST
34696: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
34697: LD_ADDR_VAR 0 13
34701: PUSH
34702: LD_INT 0
34704: PUSH
34705: LD_INT 0
34707: PUSH
34708: EMPTY
34709: LIST
34710: LIST
34711: PUSH
34712: LD_INT 0
34714: PUSH
34715: LD_INT 1
34717: NEG
34718: PUSH
34719: EMPTY
34720: LIST
34721: LIST
34722: PUSH
34723: LD_INT 1
34725: PUSH
34726: LD_INT 0
34728: PUSH
34729: EMPTY
34730: LIST
34731: LIST
34732: PUSH
34733: LD_INT 1
34735: PUSH
34736: LD_INT 1
34738: PUSH
34739: EMPTY
34740: LIST
34741: LIST
34742: PUSH
34743: LD_INT 0
34745: PUSH
34746: LD_INT 1
34748: PUSH
34749: EMPTY
34750: LIST
34751: LIST
34752: PUSH
34753: LD_INT 1
34755: NEG
34756: PUSH
34757: LD_INT 0
34759: PUSH
34760: EMPTY
34761: LIST
34762: LIST
34763: PUSH
34764: LD_INT 1
34766: NEG
34767: PUSH
34768: LD_INT 1
34770: NEG
34771: PUSH
34772: EMPTY
34773: LIST
34774: LIST
34775: PUSH
34776: LD_INT 1
34778: NEG
34779: PUSH
34780: LD_INT 2
34782: NEG
34783: PUSH
34784: EMPTY
34785: LIST
34786: LIST
34787: PUSH
34788: LD_INT 2
34790: PUSH
34791: LD_INT 1
34793: PUSH
34794: EMPTY
34795: LIST
34796: LIST
34797: PUSH
34798: LD_INT 2
34800: PUSH
34801: LD_INT 2
34803: PUSH
34804: EMPTY
34805: LIST
34806: LIST
34807: PUSH
34808: LD_INT 1
34810: PUSH
34811: LD_INT 2
34813: PUSH
34814: EMPTY
34815: LIST
34816: LIST
34817: PUSH
34818: LD_INT 2
34820: NEG
34821: PUSH
34822: LD_INT 1
34824: NEG
34825: PUSH
34826: EMPTY
34827: LIST
34828: LIST
34829: PUSH
34830: LD_INT 2
34832: NEG
34833: PUSH
34834: LD_INT 2
34836: NEG
34837: PUSH
34838: EMPTY
34839: LIST
34840: LIST
34841: PUSH
34842: LD_INT 2
34844: NEG
34845: PUSH
34846: LD_INT 3
34848: NEG
34849: PUSH
34850: EMPTY
34851: LIST
34852: LIST
34853: PUSH
34854: LD_INT 3
34856: NEG
34857: PUSH
34858: LD_INT 2
34860: NEG
34861: PUSH
34862: EMPTY
34863: LIST
34864: LIST
34865: PUSH
34866: LD_INT 3
34868: NEG
34869: PUSH
34870: LD_INT 3
34872: NEG
34873: PUSH
34874: EMPTY
34875: LIST
34876: LIST
34877: PUSH
34878: EMPTY
34879: LIST
34880: LIST
34881: LIST
34882: LIST
34883: LIST
34884: LIST
34885: LIST
34886: LIST
34887: LIST
34888: LIST
34889: LIST
34890: LIST
34891: LIST
34892: LIST
34893: LIST
34894: LIST
34895: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
34896: LD_ADDR_VAR 0 14
34900: PUSH
34901: LD_INT 0
34903: PUSH
34904: LD_INT 0
34906: PUSH
34907: EMPTY
34908: LIST
34909: LIST
34910: PUSH
34911: LD_INT 0
34913: PUSH
34914: LD_INT 1
34916: NEG
34917: PUSH
34918: EMPTY
34919: LIST
34920: LIST
34921: PUSH
34922: LD_INT 1
34924: PUSH
34925: LD_INT 0
34927: PUSH
34928: EMPTY
34929: LIST
34930: LIST
34931: PUSH
34932: LD_INT 1
34934: PUSH
34935: LD_INT 1
34937: PUSH
34938: EMPTY
34939: LIST
34940: LIST
34941: PUSH
34942: LD_INT 0
34944: PUSH
34945: LD_INT 1
34947: PUSH
34948: EMPTY
34949: LIST
34950: LIST
34951: PUSH
34952: LD_INT 1
34954: NEG
34955: PUSH
34956: LD_INT 0
34958: PUSH
34959: EMPTY
34960: LIST
34961: LIST
34962: PUSH
34963: LD_INT 1
34965: NEG
34966: PUSH
34967: LD_INT 1
34969: NEG
34970: PUSH
34971: EMPTY
34972: LIST
34973: LIST
34974: PUSH
34975: LD_INT 1
34977: NEG
34978: PUSH
34979: LD_INT 2
34981: NEG
34982: PUSH
34983: EMPTY
34984: LIST
34985: LIST
34986: PUSH
34987: LD_INT 0
34989: PUSH
34990: LD_INT 2
34992: NEG
34993: PUSH
34994: EMPTY
34995: LIST
34996: LIST
34997: PUSH
34998: LD_INT 1
35000: PUSH
35001: LD_INT 1
35003: NEG
35004: PUSH
35005: EMPTY
35006: LIST
35007: LIST
35008: PUSH
35009: LD_INT 1
35011: PUSH
35012: LD_INT 2
35014: PUSH
35015: EMPTY
35016: LIST
35017: LIST
35018: PUSH
35019: LD_INT 0
35021: PUSH
35022: LD_INT 2
35024: PUSH
35025: EMPTY
35026: LIST
35027: LIST
35028: PUSH
35029: LD_INT 1
35031: NEG
35032: PUSH
35033: LD_INT 1
35035: PUSH
35036: EMPTY
35037: LIST
35038: LIST
35039: PUSH
35040: LD_INT 1
35042: NEG
35043: PUSH
35044: LD_INT 3
35046: NEG
35047: PUSH
35048: EMPTY
35049: LIST
35050: LIST
35051: PUSH
35052: LD_INT 0
35054: PUSH
35055: LD_INT 3
35057: NEG
35058: PUSH
35059: EMPTY
35060: LIST
35061: LIST
35062: PUSH
35063: LD_INT 1
35065: PUSH
35066: LD_INT 2
35068: NEG
35069: PUSH
35070: EMPTY
35071: LIST
35072: LIST
35073: PUSH
35074: EMPTY
35075: LIST
35076: LIST
35077: LIST
35078: LIST
35079: LIST
35080: LIST
35081: LIST
35082: LIST
35083: LIST
35084: LIST
35085: LIST
35086: LIST
35087: LIST
35088: LIST
35089: LIST
35090: LIST
35091: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
35092: LD_ADDR_VAR 0 15
35096: PUSH
35097: LD_INT 0
35099: PUSH
35100: LD_INT 0
35102: PUSH
35103: EMPTY
35104: LIST
35105: LIST
35106: PUSH
35107: LD_INT 0
35109: PUSH
35110: LD_INT 1
35112: NEG
35113: PUSH
35114: EMPTY
35115: LIST
35116: LIST
35117: PUSH
35118: LD_INT 1
35120: PUSH
35121: LD_INT 0
35123: PUSH
35124: EMPTY
35125: LIST
35126: LIST
35127: PUSH
35128: LD_INT 1
35130: PUSH
35131: LD_INT 1
35133: PUSH
35134: EMPTY
35135: LIST
35136: LIST
35137: PUSH
35138: LD_INT 0
35140: PUSH
35141: LD_INT 1
35143: PUSH
35144: EMPTY
35145: LIST
35146: LIST
35147: PUSH
35148: LD_INT 1
35150: NEG
35151: PUSH
35152: LD_INT 0
35154: PUSH
35155: EMPTY
35156: LIST
35157: LIST
35158: PUSH
35159: LD_INT 1
35161: NEG
35162: PUSH
35163: LD_INT 1
35165: NEG
35166: PUSH
35167: EMPTY
35168: LIST
35169: LIST
35170: PUSH
35171: LD_INT 1
35173: PUSH
35174: LD_INT 1
35176: NEG
35177: PUSH
35178: EMPTY
35179: LIST
35180: LIST
35181: PUSH
35182: LD_INT 2
35184: PUSH
35185: LD_INT 0
35187: PUSH
35188: EMPTY
35189: LIST
35190: LIST
35191: PUSH
35192: LD_INT 2
35194: PUSH
35195: LD_INT 1
35197: PUSH
35198: EMPTY
35199: LIST
35200: LIST
35201: PUSH
35202: LD_INT 1
35204: NEG
35205: PUSH
35206: LD_INT 1
35208: PUSH
35209: EMPTY
35210: LIST
35211: LIST
35212: PUSH
35213: LD_INT 2
35215: NEG
35216: PUSH
35217: LD_INT 0
35219: PUSH
35220: EMPTY
35221: LIST
35222: LIST
35223: PUSH
35224: LD_INT 2
35226: NEG
35227: PUSH
35228: LD_INT 1
35230: NEG
35231: PUSH
35232: EMPTY
35233: LIST
35234: LIST
35235: PUSH
35236: LD_INT 2
35238: PUSH
35239: LD_INT 1
35241: NEG
35242: PUSH
35243: EMPTY
35244: LIST
35245: LIST
35246: PUSH
35247: LD_INT 3
35249: PUSH
35250: LD_INT 0
35252: PUSH
35253: EMPTY
35254: LIST
35255: LIST
35256: PUSH
35257: LD_INT 3
35259: PUSH
35260: LD_INT 1
35262: PUSH
35263: EMPTY
35264: LIST
35265: LIST
35266: PUSH
35267: EMPTY
35268: LIST
35269: LIST
35270: LIST
35271: LIST
35272: LIST
35273: LIST
35274: LIST
35275: LIST
35276: LIST
35277: LIST
35278: LIST
35279: LIST
35280: LIST
35281: LIST
35282: LIST
35283: LIST
35284: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
35285: LD_ADDR_VAR 0 16
35289: PUSH
35290: LD_INT 0
35292: PUSH
35293: LD_INT 0
35295: PUSH
35296: EMPTY
35297: LIST
35298: LIST
35299: PUSH
35300: LD_INT 0
35302: PUSH
35303: LD_INT 1
35305: NEG
35306: PUSH
35307: EMPTY
35308: LIST
35309: LIST
35310: PUSH
35311: LD_INT 1
35313: PUSH
35314: LD_INT 0
35316: PUSH
35317: EMPTY
35318: LIST
35319: LIST
35320: PUSH
35321: LD_INT 1
35323: PUSH
35324: LD_INT 1
35326: PUSH
35327: EMPTY
35328: LIST
35329: LIST
35330: PUSH
35331: LD_INT 0
35333: PUSH
35334: LD_INT 1
35336: PUSH
35337: EMPTY
35338: LIST
35339: LIST
35340: PUSH
35341: LD_INT 1
35343: NEG
35344: PUSH
35345: LD_INT 0
35347: PUSH
35348: EMPTY
35349: LIST
35350: LIST
35351: PUSH
35352: LD_INT 1
35354: NEG
35355: PUSH
35356: LD_INT 1
35358: NEG
35359: PUSH
35360: EMPTY
35361: LIST
35362: LIST
35363: PUSH
35364: LD_INT 1
35366: NEG
35367: PUSH
35368: LD_INT 2
35370: NEG
35371: PUSH
35372: EMPTY
35373: LIST
35374: LIST
35375: PUSH
35376: LD_INT 2
35378: PUSH
35379: LD_INT 1
35381: PUSH
35382: EMPTY
35383: LIST
35384: LIST
35385: PUSH
35386: LD_INT 2
35388: PUSH
35389: LD_INT 2
35391: PUSH
35392: EMPTY
35393: LIST
35394: LIST
35395: PUSH
35396: LD_INT 1
35398: PUSH
35399: LD_INT 2
35401: PUSH
35402: EMPTY
35403: LIST
35404: LIST
35405: PUSH
35406: LD_INT 2
35408: NEG
35409: PUSH
35410: LD_INT 1
35412: NEG
35413: PUSH
35414: EMPTY
35415: LIST
35416: LIST
35417: PUSH
35418: LD_INT 2
35420: NEG
35421: PUSH
35422: LD_INT 2
35424: NEG
35425: PUSH
35426: EMPTY
35427: LIST
35428: LIST
35429: PUSH
35430: LD_INT 3
35432: PUSH
35433: LD_INT 2
35435: PUSH
35436: EMPTY
35437: LIST
35438: LIST
35439: PUSH
35440: LD_INT 3
35442: PUSH
35443: LD_INT 3
35445: PUSH
35446: EMPTY
35447: LIST
35448: LIST
35449: PUSH
35450: LD_INT 2
35452: PUSH
35453: LD_INT 3
35455: PUSH
35456: EMPTY
35457: LIST
35458: LIST
35459: PUSH
35460: EMPTY
35461: LIST
35462: LIST
35463: LIST
35464: LIST
35465: LIST
35466: LIST
35467: LIST
35468: LIST
35469: LIST
35470: LIST
35471: LIST
35472: LIST
35473: LIST
35474: LIST
35475: LIST
35476: LIST
35477: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
35478: LD_ADDR_VAR 0 17
35482: PUSH
35483: LD_INT 0
35485: PUSH
35486: LD_INT 0
35488: PUSH
35489: EMPTY
35490: LIST
35491: LIST
35492: PUSH
35493: LD_INT 0
35495: PUSH
35496: LD_INT 1
35498: NEG
35499: PUSH
35500: EMPTY
35501: LIST
35502: LIST
35503: PUSH
35504: LD_INT 1
35506: PUSH
35507: LD_INT 0
35509: PUSH
35510: EMPTY
35511: LIST
35512: LIST
35513: PUSH
35514: LD_INT 1
35516: PUSH
35517: LD_INT 1
35519: PUSH
35520: EMPTY
35521: LIST
35522: LIST
35523: PUSH
35524: LD_INT 0
35526: PUSH
35527: LD_INT 1
35529: PUSH
35530: EMPTY
35531: LIST
35532: LIST
35533: PUSH
35534: LD_INT 1
35536: NEG
35537: PUSH
35538: LD_INT 0
35540: PUSH
35541: EMPTY
35542: LIST
35543: LIST
35544: PUSH
35545: LD_INT 1
35547: NEG
35548: PUSH
35549: LD_INT 1
35551: NEG
35552: PUSH
35553: EMPTY
35554: LIST
35555: LIST
35556: PUSH
35557: LD_INT 1
35559: NEG
35560: PUSH
35561: LD_INT 2
35563: NEG
35564: PUSH
35565: EMPTY
35566: LIST
35567: LIST
35568: PUSH
35569: LD_INT 0
35571: PUSH
35572: LD_INT 2
35574: NEG
35575: PUSH
35576: EMPTY
35577: LIST
35578: LIST
35579: PUSH
35580: LD_INT 1
35582: PUSH
35583: LD_INT 1
35585: NEG
35586: PUSH
35587: EMPTY
35588: LIST
35589: LIST
35590: PUSH
35591: LD_INT 2
35593: PUSH
35594: LD_INT 0
35596: PUSH
35597: EMPTY
35598: LIST
35599: LIST
35600: PUSH
35601: LD_INT 2
35603: PUSH
35604: LD_INT 1
35606: PUSH
35607: EMPTY
35608: LIST
35609: LIST
35610: PUSH
35611: LD_INT 2
35613: PUSH
35614: LD_INT 2
35616: PUSH
35617: EMPTY
35618: LIST
35619: LIST
35620: PUSH
35621: LD_INT 1
35623: PUSH
35624: LD_INT 2
35626: PUSH
35627: EMPTY
35628: LIST
35629: LIST
35630: PUSH
35631: LD_INT 0
35633: PUSH
35634: LD_INT 2
35636: PUSH
35637: EMPTY
35638: LIST
35639: LIST
35640: PUSH
35641: LD_INT 1
35643: NEG
35644: PUSH
35645: LD_INT 1
35647: PUSH
35648: EMPTY
35649: LIST
35650: LIST
35651: PUSH
35652: LD_INT 2
35654: NEG
35655: PUSH
35656: LD_INT 0
35658: PUSH
35659: EMPTY
35660: LIST
35661: LIST
35662: PUSH
35663: LD_INT 2
35665: NEG
35666: PUSH
35667: LD_INT 1
35669: NEG
35670: PUSH
35671: EMPTY
35672: LIST
35673: LIST
35674: PUSH
35675: LD_INT 2
35677: NEG
35678: PUSH
35679: LD_INT 2
35681: NEG
35682: PUSH
35683: EMPTY
35684: LIST
35685: LIST
35686: PUSH
35687: EMPTY
35688: LIST
35689: LIST
35690: LIST
35691: LIST
35692: LIST
35693: LIST
35694: LIST
35695: LIST
35696: LIST
35697: LIST
35698: LIST
35699: LIST
35700: LIST
35701: LIST
35702: LIST
35703: LIST
35704: LIST
35705: LIST
35706: LIST
35707: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
35708: LD_ADDR_VAR 0 18
35712: PUSH
35713: LD_INT 0
35715: PUSH
35716: LD_INT 0
35718: PUSH
35719: EMPTY
35720: LIST
35721: LIST
35722: PUSH
35723: LD_INT 0
35725: PUSH
35726: LD_INT 1
35728: NEG
35729: PUSH
35730: EMPTY
35731: LIST
35732: LIST
35733: PUSH
35734: LD_INT 1
35736: PUSH
35737: LD_INT 0
35739: PUSH
35740: EMPTY
35741: LIST
35742: LIST
35743: PUSH
35744: LD_INT 1
35746: PUSH
35747: LD_INT 1
35749: PUSH
35750: EMPTY
35751: LIST
35752: LIST
35753: PUSH
35754: LD_INT 0
35756: PUSH
35757: LD_INT 1
35759: PUSH
35760: EMPTY
35761: LIST
35762: LIST
35763: PUSH
35764: LD_INT 1
35766: NEG
35767: PUSH
35768: LD_INT 0
35770: PUSH
35771: EMPTY
35772: LIST
35773: LIST
35774: PUSH
35775: LD_INT 1
35777: NEG
35778: PUSH
35779: LD_INT 1
35781: NEG
35782: PUSH
35783: EMPTY
35784: LIST
35785: LIST
35786: PUSH
35787: LD_INT 1
35789: NEG
35790: PUSH
35791: LD_INT 2
35793: NEG
35794: PUSH
35795: EMPTY
35796: LIST
35797: LIST
35798: PUSH
35799: LD_INT 0
35801: PUSH
35802: LD_INT 2
35804: NEG
35805: PUSH
35806: EMPTY
35807: LIST
35808: LIST
35809: PUSH
35810: LD_INT 1
35812: PUSH
35813: LD_INT 1
35815: NEG
35816: PUSH
35817: EMPTY
35818: LIST
35819: LIST
35820: PUSH
35821: LD_INT 2
35823: PUSH
35824: LD_INT 0
35826: PUSH
35827: EMPTY
35828: LIST
35829: LIST
35830: PUSH
35831: LD_INT 2
35833: PUSH
35834: LD_INT 1
35836: PUSH
35837: EMPTY
35838: LIST
35839: LIST
35840: PUSH
35841: LD_INT 2
35843: PUSH
35844: LD_INT 2
35846: PUSH
35847: EMPTY
35848: LIST
35849: LIST
35850: PUSH
35851: LD_INT 1
35853: PUSH
35854: LD_INT 2
35856: PUSH
35857: EMPTY
35858: LIST
35859: LIST
35860: PUSH
35861: LD_INT 0
35863: PUSH
35864: LD_INT 2
35866: PUSH
35867: EMPTY
35868: LIST
35869: LIST
35870: PUSH
35871: LD_INT 1
35873: NEG
35874: PUSH
35875: LD_INT 1
35877: PUSH
35878: EMPTY
35879: LIST
35880: LIST
35881: PUSH
35882: LD_INT 2
35884: NEG
35885: PUSH
35886: LD_INT 0
35888: PUSH
35889: EMPTY
35890: LIST
35891: LIST
35892: PUSH
35893: LD_INT 2
35895: NEG
35896: PUSH
35897: LD_INT 1
35899: NEG
35900: PUSH
35901: EMPTY
35902: LIST
35903: LIST
35904: PUSH
35905: LD_INT 2
35907: NEG
35908: PUSH
35909: LD_INT 2
35911: NEG
35912: PUSH
35913: EMPTY
35914: LIST
35915: LIST
35916: PUSH
35917: EMPTY
35918: LIST
35919: LIST
35920: LIST
35921: LIST
35922: LIST
35923: LIST
35924: LIST
35925: LIST
35926: LIST
35927: LIST
35928: LIST
35929: LIST
35930: LIST
35931: LIST
35932: LIST
35933: LIST
35934: LIST
35935: LIST
35936: LIST
35937: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
35938: LD_ADDR_VAR 0 19
35942: PUSH
35943: LD_INT 0
35945: PUSH
35946: LD_INT 0
35948: PUSH
35949: EMPTY
35950: LIST
35951: LIST
35952: PUSH
35953: LD_INT 0
35955: PUSH
35956: LD_INT 1
35958: NEG
35959: PUSH
35960: EMPTY
35961: LIST
35962: LIST
35963: PUSH
35964: LD_INT 1
35966: PUSH
35967: LD_INT 0
35969: PUSH
35970: EMPTY
35971: LIST
35972: LIST
35973: PUSH
35974: LD_INT 1
35976: PUSH
35977: LD_INT 1
35979: PUSH
35980: EMPTY
35981: LIST
35982: LIST
35983: PUSH
35984: LD_INT 0
35986: PUSH
35987: LD_INT 1
35989: PUSH
35990: EMPTY
35991: LIST
35992: LIST
35993: PUSH
35994: LD_INT 1
35996: NEG
35997: PUSH
35998: LD_INT 0
36000: PUSH
36001: EMPTY
36002: LIST
36003: LIST
36004: PUSH
36005: LD_INT 1
36007: NEG
36008: PUSH
36009: LD_INT 1
36011: NEG
36012: PUSH
36013: EMPTY
36014: LIST
36015: LIST
36016: PUSH
36017: LD_INT 1
36019: NEG
36020: PUSH
36021: LD_INT 2
36023: NEG
36024: PUSH
36025: EMPTY
36026: LIST
36027: LIST
36028: PUSH
36029: LD_INT 0
36031: PUSH
36032: LD_INT 2
36034: NEG
36035: PUSH
36036: EMPTY
36037: LIST
36038: LIST
36039: PUSH
36040: LD_INT 1
36042: PUSH
36043: LD_INT 1
36045: NEG
36046: PUSH
36047: EMPTY
36048: LIST
36049: LIST
36050: PUSH
36051: LD_INT 2
36053: PUSH
36054: LD_INT 0
36056: PUSH
36057: EMPTY
36058: LIST
36059: LIST
36060: PUSH
36061: LD_INT 2
36063: PUSH
36064: LD_INT 1
36066: PUSH
36067: EMPTY
36068: LIST
36069: LIST
36070: PUSH
36071: LD_INT 2
36073: PUSH
36074: LD_INT 2
36076: PUSH
36077: EMPTY
36078: LIST
36079: LIST
36080: PUSH
36081: LD_INT 1
36083: PUSH
36084: LD_INT 2
36086: PUSH
36087: EMPTY
36088: LIST
36089: LIST
36090: PUSH
36091: LD_INT 0
36093: PUSH
36094: LD_INT 2
36096: PUSH
36097: EMPTY
36098: LIST
36099: LIST
36100: PUSH
36101: LD_INT 1
36103: NEG
36104: PUSH
36105: LD_INT 1
36107: PUSH
36108: EMPTY
36109: LIST
36110: LIST
36111: PUSH
36112: LD_INT 2
36114: NEG
36115: PUSH
36116: LD_INT 0
36118: PUSH
36119: EMPTY
36120: LIST
36121: LIST
36122: PUSH
36123: LD_INT 2
36125: NEG
36126: PUSH
36127: LD_INT 1
36129: NEG
36130: PUSH
36131: EMPTY
36132: LIST
36133: LIST
36134: PUSH
36135: LD_INT 2
36137: NEG
36138: PUSH
36139: LD_INT 2
36141: NEG
36142: PUSH
36143: EMPTY
36144: LIST
36145: LIST
36146: PUSH
36147: EMPTY
36148: LIST
36149: LIST
36150: LIST
36151: LIST
36152: LIST
36153: LIST
36154: LIST
36155: LIST
36156: LIST
36157: LIST
36158: LIST
36159: LIST
36160: LIST
36161: LIST
36162: LIST
36163: LIST
36164: LIST
36165: LIST
36166: LIST
36167: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
36168: LD_ADDR_VAR 0 20
36172: PUSH
36173: LD_INT 0
36175: PUSH
36176: LD_INT 0
36178: PUSH
36179: EMPTY
36180: LIST
36181: LIST
36182: PUSH
36183: LD_INT 0
36185: PUSH
36186: LD_INT 1
36188: NEG
36189: PUSH
36190: EMPTY
36191: LIST
36192: LIST
36193: PUSH
36194: LD_INT 1
36196: PUSH
36197: LD_INT 0
36199: PUSH
36200: EMPTY
36201: LIST
36202: LIST
36203: PUSH
36204: LD_INT 1
36206: PUSH
36207: LD_INT 1
36209: PUSH
36210: EMPTY
36211: LIST
36212: LIST
36213: PUSH
36214: LD_INT 0
36216: PUSH
36217: LD_INT 1
36219: PUSH
36220: EMPTY
36221: LIST
36222: LIST
36223: PUSH
36224: LD_INT 1
36226: NEG
36227: PUSH
36228: LD_INT 0
36230: PUSH
36231: EMPTY
36232: LIST
36233: LIST
36234: PUSH
36235: LD_INT 1
36237: NEG
36238: PUSH
36239: LD_INT 1
36241: NEG
36242: PUSH
36243: EMPTY
36244: LIST
36245: LIST
36246: PUSH
36247: LD_INT 1
36249: NEG
36250: PUSH
36251: LD_INT 2
36253: NEG
36254: PUSH
36255: EMPTY
36256: LIST
36257: LIST
36258: PUSH
36259: LD_INT 0
36261: PUSH
36262: LD_INT 2
36264: NEG
36265: PUSH
36266: EMPTY
36267: LIST
36268: LIST
36269: PUSH
36270: LD_INT 1
36272: PUSH
36273: LD_INT 1
36275: NEG
36276: PUSH
36277: EMPTY
36278: LIST
36279: LIST
36280: PUSH
36281: LD_INT 2
36283: PUSH
36284: LD_INT 0
36286: PUSH
36287: EMPTY
36288: LIST
36289: LIST
36290: PUSH
36291: LD_INT 2
36293: PUSH
36294: LD_INT 1
36296: PUSH
36297: EMPTY
36298: LIST
36299: LIST
36300: PUSH
36301: LD_INT 2
36303: PUSH
36304: LD_INT 2
36306: PUSH
36307: EMPTY
36308: LIST
36309: LIST
36310: PUSH
36311: LD_INT 1
36313: PUSH
36314: LD_INT 2
36316: PUSH
36317: EMPTY
36318: LIST
36319: LIST
36320: PUSH
36321: LD_INT 0
36323: PUSH
36324: LD_INT 2
36326: PUSH
36327: EMPTY
36328: LIST
36329: LIST
36330: PUSH
36331: LD_INT 1
36333: NEG
36334: PUSH
36335: LD_INT 1
36337: PUSH
36338: EMPTY
36339: LIST
36340: LIST
36341: PUSH
36342: LD_INT 2
36344: NEG
36345: PUSH
36346: LD_INT 0
36348: PUSH
36349: EMPTY
36350: LIST
36351: LIST
36352: PUSH
36353: LD_INT 2
36355: NEG
36356: PUSH
36357: LD_INT 1
36359: NEG
36360: PUSH
36361: EMPTY
36362: LIST
36363: LIST
36364: PUSH
36365: LD_INT 2
36367: NEG
36368: PUSH
36369: LD_INT 2
36371: NEG
36372: PUSH
36373: EMPTY
36374: LIST
36375: LIST
36376: PUSH
36377: EMPTY
36378: LIST
36379: LIST
36380: LIST
36381: LIST
36382: LIST
36383: LIST
36384: LIST
36385: LIST
36386: LIST
36387: LIST
36388: LIST
36389: LIST
36390: LIST
36391: LIST
36392: LIST
36393: LIST
36394: LIST
36395: LIST
36396: LIST
36397: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
36398: LD_ADDR_VAR 0 21
36402: PUSH
36403: LD_INT 0
36405: PUSH
36406: LD_INT 0
36408: PUSH
36409: EMPTY
36410: LIST
36411: LIST
36412: PUSH
36413: LD_INT 0
36415: PUSH
36416: LD_INT 1
36418: NEG
36419: PUSH
36420: EMPTY
36421: LIST
36422: LIST
36423: PUSH
36424: LD_INT 1
36426: PUSH
36427: LD_INT 0
36429: PUSH
36430: EMPTY
36431: LIST
36432: LIST
36433: PUSH
36434: LD_INT 1
36436: PUSH
36437: LD_INT 1
36439: PUSH
36440: EMPTY
36441: LIST
36442: LIST
36443: PUSH
36444: LD_INT 0
36446: PUSH
36447: LD_INT 1
36449: PUSH
36450: EMPTY
36451: LIST
36452: LIST
36453: PUSH
36454: LD_INT 1
36456: NEG
36457: PUSH
36458: LD_INT 0
36460: PUSH
36461: EMPTY
36462: LIST
36463: LIST
36464: PUSH
36465: LD_INT 1
36467: NEG
36468: PUSH
36469: LD_INT 1
36471: NEG
36472: PUSH
36473: EMPTY
36474: LIST
36475: LIST
36476: PUSH
36477: LD_INT 1
36479: NEG
36480: PUSH
36481: LD_INT 2
36483: NEG
36484: PUSH
36485: EMPTY
36486: LIST
36487: LIST
36488: PUSH
36489: LD_INT 0
36491: PUSH
36492: LD_INT 2
36494: NEG
36495: PUSH
36496: EMPTY
36497: LIST
36498: LIST
36499: PUSH
36500: LD_INT 1
36502: PUSH
36503: LD_INT 1
36505: NEG
36506: PUSH
36507: EMPTY
36508: LIST
36509: LIST
36510: PUSH
36511: LD_INT 2
36513: PUSH
36514: LD_INT 0
36516: PUSH
36517: EMPTY
36518: LIST
36519: LIST
36520: PUSH
36521: LD_INT 2
36523: PUSH
36524: LD_INT 1
36526: PUSH
36527: EMPTY
36528: LIST
36529: LIST
36530: PUSH
36531: LD_INT 2
36533: PUSH
36534: LD_INT 2
36536: PUSH
36537: EMPTY
36538: LIST
36539: LIST
36540: PUSH
36541: LD_INT 1
36543: PUSH
36544: LD_INT 2
36546: PUSH
36547: EMPTY
36548: LIST
36549: LIST
36550: PUSH
36551: LD_INT 0
36553: PUSH
36554: LD_INT 2
36556: PUSH
36557: EMPTY
36558: LIST
36559: LIST
36560: PUSH
36561: LD_INT 1
36563: NEG
36564: PUSH
36565: LD_INT 1
36567: PUSH
36568: EMPTY
36569: LIST
36570: LIST
36571: PUSH
36572: LD_INT 2
36574: NEG
36575: PUSH
36576: LD_INT 0
36578: PUSH
36579: EMPTY
36580: LIST
36581: LIST
36582: PUSH
36583: LD_INT 2
36585: NEG
36586: PUSH
36587: LD_INT 1
36589: NEG
36590: PUSH
36591: EMPTY
36592: LIST
36593: LIST
36594: PUSH
36595: LD_INT 2
36597: NEG
36598: PUSH
36599: LD_INT 2
36601: NEG
36602: PUSH
36603: EMPTY
36604: LIST
36605: LIST
36606: PUSH
36607: EMPTY
36608: LIST
36609: LIST
36610: LIST
36611: LIST
36612: LIST
36613: LIST
36614: LIST
36615: LIST
36616: LIST
36617: LIST
36618: LIST
36619: LIST
36620: LIST
36621: LIST
36622: LIST
36623: LIST
36624: LIST
36625: LIST
36626: LIST
36627: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
36628: LD_ADDR_VAR 0 22
36632: PUSH
36633: LD_INT 0
36635: PUSH
36636: LD_INT 0
36638: PUSH
36639: EMPTY
36640: LIST
36641: LIST
36642: PUSH
36643: LD_INT 0
36645: PUSH
36646: LD_INT 1
36648: NEG
36649: PUSH
36650: EMPTY
36651: LIST
36652: LIST
36653: PUSH
36654: LD_INT 1
36656: PUSH
36657: LD_INT 0
36659: PUSH
36660: EMPTY
36661: LIST
36662: LIST
36663: PUSH
36664: LD_INT 1
36666: PUSH
36667: LD_INT 1
36669: PUSH
36670: EMPTY
36671: LIST
36672: LIST
36673: PUSH
36674: LD_INT 0
36676: PUSH
36677: LD_INT 1
36679: PUSH
36680: EMPTY
36681: LIST
36682: LIST
36683: PUSH
36684: LD_INT 1
36686: NEG
36687: PUSH
36688: LD_INT 0
36690: PUSH
36691: EMPTY
36692: LIST
36693: LIST
36694: PUSH
36695: LD_INT 1
36697: NEG
36698: PUSH
36699: LD_INT 1
36701: NEG
36702: PUSH
36703: EMPTY
36704: LIST
36705: LIST
36706: PUSH
36707: LD_INT 1
36709: NEG
36710: PUSH
36711: LD_INT 2
36713: NEG
36714: PUSH
36715: EMPTY
36716: LIST
36717: LIST
36718: PUSH
36719: LD_INT 0
36721: PUSH
36722: LD_INT 2
36724: NEG
36725: PUSH
36726: EMPTY
36727: LIST
36728: LIST
36729: PUSH
36730: LD_INT 1
36732: PUSH
36733: LD_INT 1
36735: NEG
36736: PUSH
36737: EMPTY
36738: LIST
36739: LIST
36740: PUSH
36741: LD_INT 2
36743: PUSH
36744: LD_INT 0
36746: PUSH
36747: EMPTY
36748: LIST
36749: LIST
36750: PUSH
36751: LD_INT 2
36753: PUSH
36754: LD_INT 1
36756: PUSH
36757: EMPTY
36758: LIST
36759: LIST
36760: PUSH
36761: LD_INT 2
36763: PUSH
36764: LD_INT 2
36766: PUSH
36767: EMPTY
36768: LIST
36769: LIST
36770: PUSH
36771: LD_INT 1
36773: PUSH
36774: LD_INT 2
36776: PUSH
36777: EMPTY
36778: LIST
36779: LIST
36780: PUSH
36781: LD_INT 0
36783: PUSH
36784: LD_INT 2
36786: PUSH
36787: EMPTY
36788: LIST
36789: LIST
36790: PUSH
36791: LD_INT 1
36793: NEG
36794: PUSH
36795: LD_INT 1
36797: PUSH
36798: EMPTY
36799: LIST
36800: LIST
36801: PUSH
36802: LD_INT 2
36804: NEG
36805: PUSH
36806: LD_INT 0
36808: PUSH
36809: EMPTY
36810: LIST
36811: LIST
36812: PUSH
36813: LD_INT 2
36815: NEG
36816: PUSH
36817: LD_INT 1
36819: NEG
36820: PUSH
36821: EMPTY
36822: LIST
36823: LIST
36824: PUSH
36825: LD_INT 2
36827: NEG
36828: PUSH
36829: LD_INT 2
36831: NEG
36832: PUSH
36833: EMPTY
36834: LIST
36835: LIST
36836: PUSH
36837: EMPTY
36838: LIST
36839: LIST
36840: LIST
36841: LIST
36842: LIST
36843: LIST
36844: LIST
36845: LIST
36846: LIST
36847: LIST
36848: LIST
36849: LIST
36850: LIST
36851: LIST
36852: LIST
36853: LIST
36854: LIST
36855: LIST
36856: LIST
36857: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
36858: LD_ADDR_VAR 0 23
36862: PUSH
36863: LD_INT 0
36865: PUSH
36866: LD_INT 0
36868: PUSH
36869: EMPTY
36870: LIST
36871: LIST
36872: PUSH
36873: LD_INT 0
36875: PUSH
36876: LD_INT 1
36878: NEG
36879: PUSH
36880: EMPTY
36881: LIST
36882: LIST
36883: PUSH
36884: LD_INT 1
36886: PUSH
36887: LD_INT 0
36889: PUSH
36890: EMPTY
36891: LIST
36892: LIST
36893: PUSH
36894: LD_INT 1
36896: PUSH
36897: LD_INT 1
36899: PUSH
36900: EMPTY
36901: LIST
36902: LIST
36903: PUSH
36904: LD_INT 0
36906: PUSH
36907: LD_INT 1
36909: PUSH
36910: EMPTY
36911: LIST
36912: LIST
36913: PUSH
36914: LD_INT 1
36916: NEG
36917: PUSH
36918: LD_INT 0
36920: PUSH
36921: EMPTY
36922: LIST
36923: LIST
36924: PUSH
36925: LD_INT 1
36927: NEG
36928: PUSH
36929: LD_INT 1
36931: NEG
36932: PUSH
36933: EMPTY
36934: LIST
36935: LIST
36936: PUSH
36937: LD_INT 1
36939: NEG
36940: PUSH
36941: LD_INT 2
36943: NEG
36944: PUSH
36945: EMPTY
36946: LIST
36947: LIST
36948: PUSH
36949: LD_INT 0
36951: PUSH
36952: LD_INT 2
36954: NEG
36955: PUSH
36956: EMPTY
36957: LIST
36958: LIST
36959: PUSH
36960: LD_INT 1
36962: PUSH
36963: LD_INT 1
36965: NEG
36966: PUSH
36967: EMPTY
36968: LIST
36969: LIST
36970: PUSH
36971: LD_INT 2
36973: PUSH
36974: LD_INT 0
36976: PUSH
36977: EMPTY
36978: LIST
36979: LIST
36980: PUSH
36981: LD_INT 2
36983: PUSH
36984: LD_INT 1
36986: PUSH
36987: EMPTY
36988: LIST
36989: LIST
36990: PUSH
36991: LD_INT 2
36993: PUSH
36994: LD_INT 2
36996: PUSH
36997: EMPTY
36998: LIST
36999: LIST
37000: PUSH
37001: LD_INT 1
37003: PUSH
37004: LD_INT 2
37006: PUSH
37007: EMPTY
37008: LIST
37009: LIST
37010: PUSH
37011: LD_INT 0
37013: PUSH
37014: LD_INT 2
37016: PUSH
37017: EMPTY
37018: LIST
37019: LIST
37020: PUSH
37021: LD_INT 1
37023: NEG
37024: PUSH
37025: LD_INT 1
37027: PUSH
37028: EMPTY
37029: LIST
37030: LIST
37031: PUSH
37032: LD_INT 2
37034: NEG
37035: PUSH
37036: LD_INT 0
37038: PUSH
37039: EMPTY
37040: LIST
37041: LIST
37042: PUSH
37043: LD_INT 2
37045: NEG
37046: PUSH
37047: LD_INT 1
37049: NEG
37050: PUSH
37051: EMPTY
37052: LIST
37053: LIST
37054: PUSH
37055: LD_INT 2
37057: NEG
37058: PUSH
37059: LD_INT 2
37061: NEG
37062: PUSH
37063: EMPTY
37064: LIST
37065: LIST
37066: PUSH
37067: LD_INT 2
37069: NEG
37070: PUSH
37071: LD_INT 3
37073: NEG
37074: PUSH
37075: EMPTY
37076: LIST
37077: LIST
37078: PUSH
37079: LD_INT 1
37081: NEG
37082: PUSH
37083: LD_INT 3
37085: NEG
37086: PUSH
37087: EMPTY
37088: LIST
37089: LIST
37090: PUSH
37091: LD_INT 1
37093: PUSH
37094: LD_INT 2
37096: NEG
37097: PUSH
37098: EMPTY
37099: LIST
37100: LIST
37101: PUSH
37102: LD_INT 2
37104: PUSH
37105: LD_INT 1
37107: NEG
37108: PUSH
37109: EMPTY
37110: LIST
37111: LIST
37112: PUSH
37113: EMPTY
37114: LIST
37115: LIST
37116: LIST
37117: LIST
37118: LIST
37119: LIST
37120: LIST
37121: LIST
37122: LIST
37123: LIST
37124: LIST
37125: LIST
37126: LIST
37127: LIST
37128: LIST
37129: LIST
37130: LIST
37131: LIST
37132: LIST
37133: LIST
37134: LIST
37135: LIST
37136: LIST
37137: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
37138: LD_ADDR_VAR 0 24
37142: PUSH
37143: LD_INT 0
37145: PUSH
37146: LD_INT 0
37148: PUSH
37149: EMPTY
37150: LIST
37151: LIST
37152: PUSH
37153: LD_INT 0
37155: PUSH
37156: LD_INT 1
37158: NEG
37159: PUSH
37160: EMPTY
37161: LIST
37162: LIST
37163: PUSH
37164: LD_INT 1
37166: PUSH
37167: LD_INT 0
37169: PUSH
37170: EMPTY
37171: LIST
37172: LIST
37173: PUSH
37174: LD_INT 1
37176: PUSH
37177: LD_INT 1
37179: PUSH
37180: EMPTY
37181: LIST
37182: LIST
37183: PUSH
37184: LD_INT 0
37186: PUSH
37187: LD_INT 1
37189: PUSH
37190: EMPTY
37191: LIST
37192: LIST
37193: PUSH
37194: LD_INT 1
37196: NEG
37197: PUSH
37198: LD_INT 0
37200: PUSH
37201: EMPTY
37202: LIST
37203: LIST
37204: PUSH
37205: LD_INT 1
37207: NEG
37208: PUSH
37209: LD_INT 1
37211: NEG
37212: PUSH
37213: EMPTY
37214: LIST
37215: LIST
37216: PUSH
37217: LD_INT 1
37219: NEG
37220: PUSH
37221: LD_INT 2
37223: NEG
37224: PUSH
37225: EMPTY
37226: LIST
37227: LIST
37228: PUSH
37229: LD_INT 0
37231: PUSH
37232: LD_INT 2
37234: NEG
37235: PUSH
37236: EMPTY
37237: LIST
37238: LIST
37239: PUSH
37240: LD_INT 1
37242: PUSH
37243: LD_INT 1
37245: NEG
37246: PUSH
37247: EMPTY
37248: LIST
37249: LIST
37250: PUSH
37251: LD_INT 2
37253: PUSH
37254: LD_INT 0
37256: PUSH
37257: EMPTY
37258: LIST
37259: LIST
37260: PUSH
37261: LD_INT 2
37263: PUSH
37264: LD_INT 1
37266: PUSH
37267: EMPTY
37268: LIST
37269: LIST
37270: PUSH
37271: LD_INT 2
37273: PUSH
37274: LD_INT 2
37276: PUSH
37277: EMPTY
37278: LIST
37279: LIST
37280: PUSH
37281: LD_INT 1
37283: PUSH
37284: LD_INT 2
37286: PUSH
37287: EMPTY
37288: LIST
37289: LIST
37290: PUSH
37291: LD_INT 0
37293: PUSH
37294: LD_INT 2
37296: PUSH
37297: EMPTY
37298: LIST
37299: LIST
37300: PUSH
37301: LD_INT 1
37303: NEG
37304: PUSH
37305: LD_INT 1
37307: PUSH
37308: EMPTY
37309: LIST
37310: LIST
37311: PUSH
37312: LD_INT 2
37314: NEG
37315: PUSH
37316: LD_INT 0
37318: PUSH
37319: EMPTY
37320: LIST
37321: LIST
37322: PUSH
37323: LD_INT 2
37325: NEG
37326: PUSH
37327: LD_INT 1
37329: NEG
37330: PUSH
37331: EMPTY
37332: LIST
37333: LIST
37334: PUSH
37335: LD_INT 2
37337: NEG
37338: PUSH
37339: LD_INT 2
37341: NEG
37342: PUSH
37343: EMPTY
37344: LIST
37345: LIST
37346: PUSH
37347: LD_INT 1
37349: PUSH
37350: LD_INT 2
37352: NEG
37353: PUSH
37354: EMPTY
37355: LIST
37356: LIST
37357: PUSH
37358: LD_INT 2
37360: PUSH
37361: LD_INT 1
37363: NEG
37364: PUSH
37365: EMPTY
37366: LIST
37367: LIST
37368: PUSH
37369: LD_INT 3
37371: PUSH
37372: LD_INT 1
37374: PUSH
37375: EMPTY
37376: LIST
37377: LIST
37378: PUSH
37379: LD_INT 3
37381: PUSH
37382: LD_INT 2
37384: PUSH
37385: EMPTY
37386: LIST
37387: LIST
37388: PUSH
37389: EMPTY
37390: LIST
37391: LIST
37392: LIST
37393: LIST
37394: LIST
37395: LIST
37396: LIST
37397: LIST
37398: LIST
37399: LIST
37400: LIST
37401: LIST
37402: LIST
37403: LIST
37404: LIST
37405: LIST
37406: LIST
37407: LIST
37408: LIST
37409: LIST
37410: LIST
37411: LIST
37412: LIST
37413: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
37414: LD_ADDR_VAR 0 25
37418: PUSH
37419: LD_INT 0
37421: PUSH
37422: LD_INT 0
37424: PUSH
37425: EMPTY
37426: LIST
37427: LIST
37428: PUSH
37429: LD_INT 0
37431: PUSH
37432: LD_INT 1
37434: NEG
37435: PUSH
37436: EMPTY
37437: LIST
37438: LIST
37439: PUSH
37440: LD_INT 1
37442: PUSH
37443: LD_INT 0
37445: PUSH
37446: EMPTY
37447: LIST
37448: LIST
37449: PUSH
37450: LD_INT 1
37452: PUSH
37453: LD_INT 1
37455: PUSH
37456: EMPTY
37457: LIST
37458: LIST
37459: PUSH
37460: LD_INT 0
37462: PUSH
37463: LD_INT 1
37465: PUSH
37466: EMPTY
37467: LIST
37468: LIST
37469: PUSH
37470: LD_INT 1
37472: NEG
37473: PUSH
37474: LD_INT 0
37476: PUSH
37477: EMPTY
37478: LIST
37479: LIST
37480: PUSH
37481: LD_INT 1
37483: NEG
37484: PUSH
37485: LD_INT 1
37487: NEG
37488: PUSH
37489: EMPTY
37490: LIST
37491: LIST
37492: PUSH
37493: LD_INT 1
37495: NEG
37496: PUSH
37497: LD_INT 2
37499: NEG
37500: PUSH
37501: EMPTY
37502: LIST
37503: LIST
37504: PUSH
37505: LD_INT 0
37507: PUSH
37508: LD_INT 2
37510: NEG
37511: PUSH
37512: EMPTY
37513: LIST
37514: LIST
37515: PUSH
37516: LD_INT 1
37518: PUSH
37519: LD_INT 1
37521: NEG
37522: PUSH
37523: EMPTY
37524: LIST
37525: LIST
37526: PUSH
37527: LD_INT 2
37529: PUSH
37530: LD_INT 0
37532: PUSH
37533: EMPTY
37534: LIST
37535: LIST
37536: PUSH
37537: LD_INT 2
37539: PUSH
37540: LD_INT 1
37542: PUSH
37543: EMPTY
37544: LIST
37545: LIST
37546: PUSH
37547: LD_INT 2
37549: PUSH
37550: LD_INT 2
37552: PUSH
37553: EMPTY
37554: LIST
37555: LIST
37556: PUSH
37557: LD_INT 1
37559: PUSH
37560: LD_INT 2
37562: PUSH
37563: EMPTY
37564: LIST
37565: LIST
37566: PUSH
37567: LD_INT 0
37569: PUSH
37570: LD_INT 2
37572: PUSH
37573: EMPTY
37574: LIST
37575: LIST
37576: PUSH
37577: LD_INT 1
37579: NEG
37580: PUSH
37581: LD_INT 1
37583: PUSH
37584: EMPTY
37585: LIST
37586: LIST
37587: PUSH
37588: LD_INT 2
37590: NEG
37591: PUSH
37592: LD_INT 0
37594: PUSH
37595: EMPTY
37596: LIST
37597: LIST
37598: PUSH
37599: LD_INT 2
37601: NEG
37602: PUSH
37603: LD_INT 1
37605: NEG
37606: PUSH
37607: EMPTY
37608: LIST
37609: LIST
37610: PUSH
37611: LD_INT 2
37613: NEG
37614: PUSH
37615: LD_INT 2
37617: NEG
37618: PUSH
37619: EMPTY
37620: LIST
37621: LIST
37622: PUSH
37623: LD_INT 3
37625: PUSH
37626: LD_INT 1
37628: PUSH
37629: EMPTY
37630: LIST
37631: LIST
37632: PUSH
37633: LD_INT 3
37635: PUSH
37636: LD_INT 2
37638: PUSH
37639: EMPTY
37640: LIST
37641: LIST
37642: PUSH
37643: LD_INT 2
37645: PUSH
37646: LD_INT 3
37648: PUSH
37649: EMPTY
37650: LIST
37651: LIST
37652: PUSH
37653: LD_INT 1
37655: PUSH
37656: LD_INT 3
37658: PUSH
37659: EMPTY
37660: LIST
37661: LIST
37662: PUSH
37663: EMPTY
37664: LIST
37665: LIST
37666: LIST
37667: LIST
37668: LIST
37669: LIST
37670: LIST
37671: LIST
37672: LIST
37673: LIST
37674: LIST
37675: LIST
37676: LIST
37677: LIST
37678: LIST
37679: LIST
37680: LIST
37681: LIST
37682: LIST
37683: LIST
37684: LIST
37685: LIST
37686: LIST
37687: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
37688: LD_ADDR_VAR 0 26
37692: PUSH
37693: LD_INT 0
37695: PUSH
37696: LD_INT 0
37698: PUSH
37699: EMPTY
37700: LIST
37701: LIST
37702: PUSH
37703: LD_INT 0
37705: PUSH
37706: LD_INT 1
37708: NEG
37709: PUSH
37710: EMPTY
37711: LIST
37712: LIST
37713: PUSH
37714: LD_INT 1
37716: PUSH
37717: LD_INT 0
37719: PUSH
37720: EMPTY
37721: LIST
37722: LIST
37723: PUSH
37724: LD_INT 1
37726: PUSH
37727: LD_INT 1
37729: PUSH
37730: EMPTY
37731: LIST
37732: LIST
37733: PUSH
37734: LD_INT 0
37736: PUSH
37737: LD_INT 1
37739: PUSH
37740: EMPTY
37741: LIST
37742: LIST
37743: PUSH
37744: LD_INT 1
37746: NEG
37747: PUSH
37748: LD_INT 0
37750: PUSH
37751: EMPTY
37752: LIST
37753: LIST
37754: PUSH
37755: LD_INT 1
37757: NEG
37758: PUSH
37759: LD_INT 1
37761: NEG
37762: PUSH
37763: EMPTY
37764: LIST
37765: LIST
37766: PUSH
37767: LD_INT 1
37769: NEG
37770: PUSH
37771: LD_INT 2
37773: NEG
37774: PUSH
37775: EMPTY
37776: LIST
37777: LIST
37778: PUSH
37779: LD_INT 0
37781: PUSH
37782: LD_INT 2
37784: NEG
37785: PUSH
37786: EMPTY
37787: LIST
37788: LIST
37789: PUSH
37790: LD_INT 1
37792: PUSH
37793: LD_INT 1
37795: NEG
37796: PUSH
37797: EMPTY
37798: LIST
37799: LIST
37800: PUSH
37801: LD_INT 2
37803: PUSH
37804: LD_INT 0
37806: PUSH
37807: EMPTY
37808: LIST
37809: LIST
37810: PUSH
37811: LD_INT 2
37813: PUSH
37814: LD_INT 1
37816: PUSH
37817: EMPTY
37818: LIST
37819: LIST
37820: PUSH
37821: LD_INT 2
37823: PUSH
37824: LD_INT 2
37826: PUSH
37827: EMPTY
37828: LIST
37829: LIST
37830: PUSH
37831: LD_INT 1
37833: PUSH
37834: LD_INT 2
37836: PUSH
37837: EMPTY
37838: LIST
37839: LIST
37840: PUSH
37841: LD_INT 0
37843: PUSH
37844: LD_INT 2
37846: PUSH
37847: EMPTY
37848: LIST
37849: LIST
37850: PUSH
37851: LD_INT 1
37853: NEG
37854: PUSH
37855: LD_INT 1
37857: PUSH
37858: EMPTY
37859: LIST
37860: LIST
37861: PUSH
37862: LD_INT 2
37864: NEG
37865: PUSH
37866: LD_INT 0
37868: PUSH
37869: EMPTY
37870: LIST
37871: LIST
37872: PUSH
37873: LD_INT 2
37875: NEG
37876: PUSH
37877: LD_INT 1
37879: NEG
37880: PUSH
37881: EMPTY
37882: LIST
37883: LIST
37884: PUSH
37885: LD_INT 2
37887: NEG
37888: PUSH
37889: LD_INT 2
37891: NEG
37892: PUSH
37893: EMPTY
37894: LIST
37895: LIST
37896: PUSH
37897: LD_INT 2
37899: PUSH
37900: LD_INT 3
37902: PUSH
37903: EMPTY
37904: LIST
37905: LIST
37906: PUSH
37907: LD_INT 1
37909: PUSH
37910: LD_INT 3
37912: PUSH
37913: EMPTY
37914: LIST
37915: LIST
37916: PUSH
37917: LD_INT 1
37919: NEG
37920: PUSH
37921: LD_INT 2
37923: PUSH
37924: EMPTY
37925: LIST
37926: LIST
37927: PUSH
37928: LD_INT 2
37930: NEG
37931: PUSH
37932: LD_INT 1
37934: PUSH
37935: EMPTY
37936: LIST
37937: LIST
37938: PUSH
37939: EMPTY
37940: LIST
37941: LIST
37942: LIST
37943: LIST
37944: LIST
37945: LIST
37946: LIST
37947: LIST
37948: LIST
37949: LIST
37950: LIST
37951: LIST
37952: LIST
37953: LIST
37954: LIST
37955: LIST
37956: LIST
37957: LIST
37958: LIST
37959: LIST
37960: LIST
37961: LIST
37962: LIST
37963: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
37964: LD_ADDR_VAR 0 27
37968: PUSH
37969: LD_INT 0
37971: PUSH
37972: LD_INT 0
37974: PUSH
37975: EMPTY
37976: LIST
37977: LIST
37978: PUSH
37979: LD_INT 0
37981: PUSH
37982: LD_INT 1
37984: NEG
37985: PUSH
37986: EMPTY
37987: LIST
37988: LIST
37989: PUSH
37990: LD_INT 1
37992: PUSH
37993: LD_INT 0
37995: PUSH
37996: EMPTY
37997: LIST
37998: LIST
37999: PUSH
38000: LD_INT 1
38002: PUSH
38003: LD_INT 1
38005: PUSH
38006: EMPTY
38007: LIST
38008: LIST
38009: PUSH
38010: LD_INT 0
38012: PUSH
38013: LD_INT 1
38015: PUSH
38016: EMPTY
38017: LIST
38018: LIST
38019: PUSH
38020: LD_INT 1
38022: NEG
38023: PUSH
38024: LD_INT 0
38026: PUSH
38027: EMPTY
38028: LIST
38029: LIST
38030: PUSH
38031: LD_INT 1
38033: NEG
38034: PUSH
38035: LD_INT 1
38037: NEG
38038: PUSH
38039: EMPTY
38040: LIST
38041: LIST
38042: PUSH
38043: LD_INT 1
38045: NEG
38046: PUSH
38047: LD_INT 2
38049: NEG
38050: PUSH
38051: EMPTY
38052: LIST
38053: LIST
38054: PUSH
38055: LD_INT 0
38057: PUSH
38058: LD_INT 2
38060: NEG
38061: PUSH
38062: EMPTY
38063: LIST
38064: LIST
38065: PUSH
38066: LD_INT 1
38068: PUSH
38069: LD_INT 1
38071: NEG
38072: PUSH
38073: EMPTY
38074: LIST
38075: LIST
38076: PUSH
38077: LD_INT 2
38079: PUSH
38080: LD_INT 0
38082: PUSH
38083: EMPTY
38084: LIST
38085: LIST
38086: PUSH
38087: LD_INT 2
38089: PUSH
38090: LD_INT 1
38092: PUSH
38093: EMPTY
38094: LIST
38095: LIST
38096: PUSH
38097: LD_INT 2
38099: PUSH
38100: LD_INT 2
38102: PUSH
38103: EMPTY
38104: LIST
38105: LIST
38106: PUSH
38107: LD_INT 1
38109: PUSH
38110: LD_INT 2
38112: PUSH
38113: EMPTY
38114: LIST
38115: LIST
38116: PUSH
38117: LD_INT 0
38119: PUSH
38120: LD_INT 2
38122: PUSH
38123: EMPTY
38124: LIST
38125: LIST
38126: PUSH
38127: LD_INT 1
38129: NEG
38130: PUSH
38131: LD_INT 1
38133: PUSH
38134: EMPTY
38135: LIST
38136: LIST
38137: PUSH
38138: LD_INT 2
38140: NEG
38141: PUSH
38142: LD_INT 0
38144: PUSH
38145: EMPTY
38146: LIST
38147: LIST
38148: PUSH
38149: LD_INT 2
38151: NEG
38152: PUSH
38153: LD_INT 1
38155: NEG
38156: PUSH
38157: EMPTY
38158: LIST
38159: LIST
38160: PUSH
38161: LD_INT 2
38163: NEG
38164: PUSH
38165: LD_INT 2
38167: NEG
38168: PUSH
38169: EMPTY
38170: LIST
38171: LIST
38172: PUSH
38173: LD_INT 1
38175: NEG
38176: PUSH
38177: LD_INT 2
38179: PUSH
38180: EMPTY
38181: LIST
38182: LIST
38183: PUSH
38184: LD_INT 2
38186: NEG
38187: PUSH
38188: LD_INT 1
38190: PUSH
38191: EMPTY
38192: LIST
38193: LIST
38194: PUSH
38195: LD_INT 3
38197: NEG
38198: PUSH
38199: LD_INT 1
38201: NEG
38202: PUSH
38203: EMPTY
38204: LIST
38205: LIST
38206: PUSH
38207: LD_INT 3
38209: NEG
38210: PUSH
38211: LD_INT 2
38213: NEG
38214: PUSH
38215: EMPTY
38216: LIST
38217: LIST
38218: PUSH
38219: EMPTY
38220: LIST
38221: LIST
38222: LIST
38223: LIST
38224: LIST
38225: LIST
38226: LIST
38227: LIST
38228: LIST
38229: LIST
38230: LIST
38231: LIST
38232: LIST
38233: LIST
38234: LIST
38235: LIST
38236: LIST
38237: LIST
38238: LIST
38239: LIST
38240: LIST
38241: LIST
38242: LIST
38243: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
38244: LD_ADDR_VAR 0 28
38248: PUSH
38249: LD_INT 0
38251: PUSH
38252: LD_INT 0
38254: PUSH
38255: EMPTY
38256: LIST
38257: LIST
38258: PUSH
38259: LD_INT 0
38261: PUSH
38262: LD_INT 1
38264: NEG
38265: PUSH
38266: EMPTY
38267: LIST
38268: LIST
38269: PUSH
38270: LD_INT 1
38272: PUSH
38273: LD_INT 0
38275: PUSH
38276: EMPTY
38277: LIST
38278: LIST
38279: PUSH
38280: LD_INT 1
38282: PUSH
38283: LD_INT 1
38285: PUSH
38286: EMPTY
38287: LIST
38288: LIST
38289: PUSH
38290: LD_INT 0
38292: PUSH
38293: LD_INT 1
38295: PUSH
38296: EMPTY
38297: LIST
38298: LIST
38299: PUSH
38300: LD_INT 1
38302: NEG
38303: PUSH
38304: LD_INT 0
38306: PUSH
38307: EMPTY
38308: LIST
38309: LIST
38310: PUSH
38311: LD_INT 1
38313: NEG
38314: PUSH
38315: LD_INT 1
38317: NEG
38318: PUSH
38319: EMPTY
38320: LIST
38321: LIST
38322: PUSH
38323: LD_INT 1
38325: NEG
38326: PUSH
38327: LD_INT 2
38329: NEG
38330: PUSH
38331: EMPTY
38332: LIST
38333: LIST
38334: PUSH
38335: LD_INT 0
38337: PUSH
38338: LD_INT 2
38340: NEG
38341: PUSH
38342: EMPTY
38343: LIST
38344: LIST
38345: PUSH
38346: LD_INT 1
38348: PUSH
38349: LD_INT 1
38351: NEG
38352: PUSH
38353: EMPTY
38354: LIST
38355: LIST
38356: PUSH
38357: LD_INT 2
38359: PUSH
38360: LD_INT 0
38362: PUSH
38363: EMPTY
38364: LIST
38365: LIST
38366: PUSH
38367: LD_INT 2
38369: PUSH
38370: LD_INT 1
38372: PUSH
38373: EMPTY
38374: LIST
38375: LIST
38376: PUSH
38377: LD_INT 2
38379: PUSH
38380: LD_INT 2
38382: PUSH
38383: EMPTY
38384: LIST
38385: LIST
38386: PUSH
38387: LD_INT 1
38389: PUSH
38390: LD_INT 2
38392: PUSH
38393: EMPTY
38394: LIST
38395: LIST
38396: PUSH
38397: LD_INT 0
38399: PUSH
38400: LD_INT 2
38402: PUSH
38403: EMPTY
38404: LIST
38405: LIST
38406: PUSH
38407: LD_INT 1
38409: NEG
38410: PUSH
38411: LD_INT 1
38413: PUSH
38414: EMPTY
38415: LIST
38416: LIST
38417: PUSH
38418: LD_INT 2
38420: NEG
38421: PUSH
38422: LD_INT 0
38424: PUSH
38425: EMPTY
38426: LIST
38427: LIST
38428: PUSH
38429: LD_INT 2
38431: NEG
38432: PUSH
38433: LD_INT 1
38435: NEG
38436: PUSH
38437: EMPTY
38438: LIST
38439: LIST
38440: PUSH
38441: LD_INT 2
38443: NEG
38444: PUSH
38445: LD_INT 2
38447: NEG
38448: PUSH
38449: EMPTY
38450: LIST
38451: LIST
38452: PUSH
38453: LD_INT 2
38455: NEG
38456: PUSH
38457: LD_INT 3
38459: NEG
38460: PUSH
38461: EMPTY
38462: LIST
38463: LIST
38464: PUSH
38465: LD_INT 1
38467: NEG
38468: PUSH
38469: LD_INT 3
38471: NEG
38472: PUSH
38473: EMPTY
38474: LIST
38475: LIST
38476: PUSH
38477: LD_INT 3
38479: NEG
38480: PUSH
38481: LD_INT 1
38483: NEG
38484: PUSH
38485: EMPTY
38486: LIST
38487: LIST
38488: PUSH
38489: LD_INT 3
38491: NEG
38492: PUSH
38493: LD_INT 2
38495: NEG
38496: PUSH
38497: EMPTY
38498: LIST
38499: LIST
38500: PUSH
38501: EMPTY
38502: LIST
38503: LIST
38504: LIST
38505: LIST
38506: LIST
38507: LIST
38508: LIST
38509: LIST
38510: LIST
38511: LIST
38512: LIST
38513: LIST
38514: LIST
38515: LIST
38516: LIST
38517: LIST
38518: LIST
38519: LIST
38520: LIST
38521: LIST
38522: LIST
38523: LIST
38524: LIST
38525: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
38526: LD_ADDR_VAR 0 29
38530: PUSH
38531: LD_INT 0
38533: PUSH
38534: LD_INT 0
38536: PUSH
38537: EMPTY
38538: LIST
38539: LIST
38540: PUSH
38541: LD_INT 0
38543: PUSH
38544: LD_INT 1
38546: NEG
38547: PUSH
38548: EMPTY
38549: LIST
38550: LIST
38551: PUSH
38552: LD_INT 1
38554: PUSH
38555: LD_INT 0
38557: PUSH
38558: EMPTY
38559: LIST
38560: LIST
38561: PUSH
38562: LD_INT 1
38564: PUSH
38565: LD_INT 1
38567: PUSH
38568: EMPTY
38569: LIST
38570: LIST
38571: PUSH
38572: LD_INT 0
38574: PUSH
38575: LD_INT 1
38577: PUSH
38578: EMPTY
38579: LIST
38580: LIST
38581: PUSH
38582: LD_INT 1
38584: NEG
38585: PUSH
38586: LD_INT 0
38588: PUSH
38589: EMPTY
38590: LIST
38591: LIST
38592: PUSH
38593: LD_INT 1
38595: NEG
38596: PUSH
38597: LD_INT 1
38599: NEG
38600: PUSH
38601: EMPTY
38602: LIST
38603: LIST
38604: PUSH
38605: LD_INT 1
38607: NEG
38608: PUSH
38609: LD_INT 2
38611: NEG
38612: PUSH
38613: EMPTY
38614: LIST
38615: LIST
38616: PUSH
38617: LD_INT 0
38619: PUSH
38620: LD_INT 2
38622: NEG
38623: PUSH
38624: EMPTY
38625: LIST
38626: LIST
38627: PUSH
38628: LD_INT 1
38630: PUSH
38631: LD_INT 1
38633: NEG
38634: PUSH
38635: EMPTY
38636: LIST
38637: LIST
38638: PUSH
38639: LD_INT 2
38641: PUSH
38642: LD_INT 0
38644: PUSH
38645: EMPTY
38646: LIST
38647: LIST
38648: PUSH
38649: LD_INT 2
38651: PUSH
38652: LD_INT 1
38654: PUSH
38655: EMPTY
38656: LIST
38657: LIST
38658: PUSH
38659: LD_INT 1
38661: PUSH
38662: LD_INT 2
38664: PUSH
38665: EMPTY
38666: LIST
38667: LIST
38668: PUSH
38669: LD_INT 0
38671: PUSH
38672: LD_INT 2
38674: PUSH
38675: EMPTY
38676: LIST
38677: LIST
38678: PUSH
38679: LD_INT 1
38681: NEG
38682: PUSH
38683: LD_INT 1
38685: PUSH
38686: EMPTY
38687: LIST
38688: LIST
38689: PUSH
38690: LD_INT 2
38692: NEG
38693: PUSH
38694: LD_INT 1
38696: NEG
38697: PUSH
38698: EMPTY
38699: LIST
38700: LIST
38701: PUSH
38702: LD_INT 2
38704: NEG
38705: PUSH
38706: LD_INT 2
38708: NEG
38709: PUSH
38710: EMPTY
38711: LIST
38712: LIST
38713: PUSH
38714: LD_INT 2
38716: NEG
38717: PUSH
38718: LD_INT 3
38720: NEG
38721: PUSH
38722: EMPTY
38723: LIST
38724: LIST
38725: PUSH
38726: LD_INT 2
38728: PUSH
38729: LD_INT 1
38731: NEG
38732: PUSH
38733: EMPTY
38734: LIST
38735: LIST
38736: PUSH
38737: LD_INT 3
38739: PUSH
38740: LD_INT 1
38742: PUSH
38743: EMPTY
38744: LIST
38745: LIST
38746: PUSH
38747: LD_INT 1
38749: PUSH
38750: LD_INT 3
38752: PUSH
38753: EMPTY
38754: LIST
38755: LIST
38756: PUSH
38757: LD_INT 1
38759: NEG
38760: PUSH
38761: LD_INT 2
38763: PUSH
38764: EMPTY
38765: LIST
38766: LIST
38767: PUSH
38768: LD_INT 3
38770: NEG
38771: PUSH
38772: LD_INT 2
38774: NEG
38775: PUSH
38776: EMPTY
38777: LIST
38778: LIST
38779: PUSH
38780: EMPTY
38781: LIST
38782: LIST
38783: LIST
38784: LIST
38785: LIST
38786: LIST
38787: LIST
38788: LIST
38789: LIST
38790: LIST
38791: LIST
38792: LIST
38793: LIST
38794: LIST
38795: LIST
38796: LIST
38797: LIST
38798: LIST
38799: LIST
38800: LIST
38801: LIST
38802: LIST
38803: LIST
38804: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
38805: LD_ADDR_VAR 0 30
38809: PUSH
38810: LD_INT 0
38812: PUSH
38813: LD_INT 0
38815: PUSH
38816: EMPTY
38817: LIST
38818: LIST
38819: PUSH
38820: LD_INT 0
38822: PUSH
38823: LD_INT 1
38825: NEG
38826: PUSH
38827: EMPTY
38828: LIST
38829: LIST
38830: PUSH
38831: LD_INT 1
38833: PUSH
38834: LD_INT 0
38836: PUSH
38837: EMPTY
38838: LIST
38839: LIST
38840: PUSH
38841: LD_INT 1
38843: PUSH
38844: LD_INT 1
38846: PUSH
38847: EMPTY
38848: LIST
38849: LIST
38850: PUSH
38851: LD_INT 0
38853: PUSH
38854: LD_INT 1
38856: PUSH
38857: EMPTY
38858: LIST
38859: LIST
38860: PUSH
38861: LD_INT 1
38863: NEG
38864: PUSH
38865: LD_INT 0
38867: PUSH
38868: EMPTY
38869: LIST
38870: LIST
38871: PUSH
38872: LD_INT 1
38874: NEG
38875: PUSH
38876: LD_INT 1
38878: NEG
38879: PUSH
38880: EMPTY
38881: LIST
38882: LIST
38883: PUSH
38884: LD_INT 1
38886: NEG
38887: PUSH
38888: LD_INT 2
38890: NEG
38891: PUSH
38892: EMPTY
38893: LIST
38894: LIST
38895: PUSH
38896: LD_INT 0
38898: PUSH
38899: LD_INT 2
38901: NEG
38902: PUSH
38903: EMPTY
38904: LIST
38905: LIST
38906: PUSH
38907: LD_INT 1
38909: PUSH
38910: LD_INT 1
38912: NEG
38913: PUSH
38914: EMPTY
38915: LIST
38916: LIST
38917: PUSH
38918: LD_INT 2
38920: PUSH
38921: LD_INT 0
38923: PUSH
38924: EMPTY
38925: LIST
38926: LIST
38927: PUSH
38928: LD_INT 2
38930: PUSH
38931: LD_INT 1
38933: PUSH
38934: EMPTY
38935: LIST
38936: LIST
38937: PUSH
38938: LD_INT 2
38940: PUSH
38941: LD_INT 2
38943: PUSH
38944: EMPTY
38945: LIST
38946: LIST
38947: PUSH
38948: LD_INT 1
38950: PUSH
38951: LD_INT 2
38953: PUSH
38954: EMPTY
38955: LIST
38956: LIST
38957: PUSH
38958: LD_INT 1
38960: NEG
38961: PUSH
38962: LD_INT 1
38964: PUSH
38965: EMPTY
38966: LIST
38967: LIST
38968: PUSH
38969: LD_INT 2
38971: NEG
38972: PUSH
38973: LD_INT 0
38975: PUSH
38976: EMPTY
38977: LIST
38978: LIST
38979: PUSH
38980: LD_INT 2
38982: NEG
38983: PUSH
38984: LD_INT 1
38986: NEG
38987: PUSH
38988: EMPTY
38989: LIST
38990: LIST
38991: PUSH
38992: LD_INT 1
38994: NEG
38995: PUSH
38996: LD_INT 3
38998: NEG
38999: PUSH
39000: EMPTY
39001: LIST
39002: LIST
39003: PUSH
39004: LD_INT 1
39006: PUSH
39007: LD_INT 2
39009: NEG
39010: PUSH
39011: EMPTY
39012: LIST
39013: LIST
39014: PUSH
39015: LD_INT 3
39017: PUSH
39018: LD_INT 2
39020: PUSH
39021: EMPTY
39022: LIST
39023: LIST
39024: PUSH
39025: LD_INT 2
39027: PUSH
39028: LD_INT 3
39030: PUSH
39031: EMPTY
39032: LIST
39033: LIST
39034: PUSH
39035: LD_INT 2
39037: NEG
39038: PUSH
39039: LD_INT 1
39041: PUSH
39042: EMPTY
39043: LIST
39044: LIST
39045: PUSH
39046: LD_INT 3
39048: NEG
39049: PUSH
39050: LD_INT 1
39052: NEG
39053: PUSH
39054: EMPTY
39055: LIST
39056: LIST
39057: PUSH
39058: EMPTY
39059: LIST
39060: LIST
39061: LIST
39062: LIST
39063: LIST
39064: LIST
39065: LIST
39066: LIST
39067: LIST
39068: LIST
39069: LIST
39070: LIST
39071: LIST
39072: LIST
39073: LIST
39074: LIST
39075: LIST
39076: LIST
39077: LIST
39078: LIST
39079: LIST
39080: LIST
39081: LIST
39082: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
39083: LD_ADDR_VAR 0 31
39087: PUSH
39088: LD_INT 0
39090: PUSH
39091: LD_INT 0
39093: PUSH
39094: EMPTY
39095: LIST
39096: LIST
39097: PUSH
39098: LD_INT 0
39100: PUSH
39101: LD_INT 1
39103: NEG
39104: PUSH
39105: EMPTY
39106: LIST
39107: LIST
39108: PUSH
39109: LD_INT 1
39111: PUSH
39112: LD_INT 0
39114: PUSH
39115: EMPTY
39116: LIST
39117: LIST
39118: PUSH
39119: LD_INT 1
39121: PUSH
39122: LD_INT 1
39124: PUSH
39125: EMPTY
39126: LIST
39127: LIST
39128: PUSH
39129: LD_INT 0
39131: PUSH
39132: LD_INT 1
39134: PUSH
39135: EMPTY
39136: LIST
39137: LIST
39138: PUSH
39139: LD_INT 1
39141: NEG
39142: PUSH
39143: LD_INT 0
39145: PUSH
39146: EMPTY
39147: LIST
39148: LIST
39149: PUSH
39150: LD_INT 1
39152: NEG
39153: PUSH
39154: LD_INT 1
39156: NEG
39157: PUSH
39158: EMPTY
39159: LIST
39160: LIST
39161: PUSH
39162: LD_INT 1
39164: NEG
39165: PUSH
39166: LD_INT 2
39168: NEG
39169: PUSH
39170: EMPTY
39171: LIST
39172: LIST
39173: PUSH
39174: LD_INT 1
39176: PUSH
39177: LD_INT 1
39179: NEG
39180: PUSH
39181: EMPTY
39182: LIST
39183: LIST
39184: PUSH
39185: LD_INT 2
39187: PUSH
39188: LD_INT 0
39190: PUSH
39191: EMPTY
39192: LIST
39193: LIST
39194: PUSH
39195: LD_INT 2
39197: PUSH
39198: LD_INT 1
39200: PUSH
39201: EMPTY
39202: LIST
39203: LIST
39204: PUSH
39205: LD_INT 2
39207: PUSH
39208: LD_INT 2
39210: PUSH
39211: EMPTY
39212: LIST
39213: LIST
39214: PUSH
39215: LD_INT 1
39217: PUSH
39218: LD_INT 2
39220: PUSH
39221: EMPTY
39222: LIST
39223: LIST
39224: PUSH
39225: LD_INT 0
39227: PUSH
39228: LD_INT 2
39230: PUSH
39231: EMPTY
39232: LIST
39233: LIST
39234: PUSH
39235: LD_INT 1
39237: NEG
39238: PUSH
39239: LD_INT 1
39241: PUSH
39242: EMPTY
39243: LIST
39244: LIST
39245: PUSH
39246: LD_INT 2
39248: NEG
39249: PUSH
39250: LD_INT 1
39252: NEG
39253: PUSH
39254: EMPTY
39255: LIST
39256: LIST
39257: PUSH
39258: LD_INT 2
39260: NEG
39261: PUSH
39262: LD_INT 2
39264: NEG
39265: PUSH
39266: EMPTY
39267: LIST
39268: LIST
39269: PUSH
39270: LD_INT 2
39272: NEG
39273: PUSH
39274: LD_INT 3
39276: NEG
39277: PUSH
39278: EMPTY
39279: LIST
39280: LIST
39281: PUSH
39282: LD_INT 2
39284: PUSH
39285: LD_INT 1
39287: NEG
39288: PUSH
39289: EMPTY
39290: LIST
39291: LIST
39292: PUSH
39293: LD_INT 3
39295: PUSH
39296: LD_INT 1
39298: PUSH
39299: EMPTY
39300: LIST
39301: LIST
39302: PUSH
39303: LD_INT 1
39305: PUSH
39306: LD_INT 3
39308: PUSH
39309: EMPTY
39310: LIST
39311: LIST
39312: PUSH
39313: LD_INT 1
39315: NEG
39316: PUSH
39317: LD_INT 2
39319: PUSH
39320: EMPTY
39321: LIST
39322: LIST
39323: PUSH
39324: LD_INT 3
39326: NEG
39327: PUSH
39328: LD_INT 2
39330: NEG
39331: PUSH
39332: EMPTY
39333: LIST
39334: LIST
39335: PUSH
39336: EMPTY
39337: LIST
39338: LIST
39339: LIST
39340: LIST
39341: LIST
39342: LIST
39343: LIST
39344: LIST
39345: LIST
39346: LIST
39347: LIST
39348: LIST
39349: LIST
39350: LIST
39351: LIST
39352: LIST
39353: LIST
39354: LIST
39355: LIST
39356: LIST
39357: LIST
39358: LIST
39359: LIST
39360: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
39361: LD_ADDR_VAR 0 32
39365: PUSH
39366: LD_INT 0
39368: PUSH
39369: LD_INT 0
39371: PUSH
39372: EMPTY
39373: LIST
39374: LIST
39375: PUSH
39376: LD_INT 0
39378: PUSH
39379: LD_INT 1
39381: NEG
39382: PUSH
39383: EMPTY
39384: LIST
39385: LIST
39386: PUSH
39387: LD_INT 1
39389: PUSH
39390: LD_INT 0
39392: PUSH
39393: EMPTY
39394: LIST
39395: LIST
39396: PUSH
39397: LD_INT 1
39399: PUSH
39400: LD_INT 1
39402: PUSH
39403: EMPTY
39404: LIST
39405: LIST
39406: PUSH
39407: LD_INT 0
39409: PUSH
39410: LD_INT 1
39412: PUSH
39413: EMPTY
39414: LIST
39415: LIST
39416: PUSH
39417: LD_INT 1
39419: NEG
39420: PUSH
39421: LD_INT 0
39423: PUSH
39424: EMPTY
39425: LIST
39426: LIST
39427: PUSH
39428: LD_INT 1
39430: NEG
39431: PUSH
39432: LD_INT 1
39434: NEG
39435: PUSH
39436: EMPTY
39437: LIST
39438: LIST
39439: PUSH
39440: LD_INT 1
39442: NEG
39443: PUSH
39444: LD_INT 2
39446: NEG
39447: PUSH
39448: EMPTY
39449: LIST
39450: LIST
39451: PUSH
39452: LD_INT 0
39454: PUSH
39455: LD_INT 2
39457: NEG
39458: PUSH
39459: EMPTY
39460: LIST
39461: LIST
39462: PUSH
39463: LD_INT 1
39465: PUSH
39466: LD_INT 1
39468: NEG
39469: PUSH
39470: EMPTY
39471: LIST
39472: LIST
39473: PUSH
39474: LD_INT 2
39476: PUSH
39477: LD_INT 1
39479: PUSH
39480: EMPTY
39481: LIST
39482: LIST
39483: PUSH
39484: LD_INT 2
39486: PUSH
39487: LD_INT 2
39489: PUSH
39490: EMPTY
39491: LIST
39492: LIST
39493: PUSH
39494: LD_INT 1
39496: PUSH
39497: LD_INT 2
39499: PUSH
39500: EMPTY
39501: LIST
39502: LIST
39503: PUSH
39504: LD_INT 0
39506: PUSH
39507: LD_INT 2
39509: PUSH
39510: EMPTY
39511: LIST
39512: LIST
39513: PUSH
39514: LD_INT 1
39516: NEG
39517: PUSH
39518: LD_INT 1
39520: PUSH
39521: EMPTY
39522: LIST
39523: LIST
39524: PUSH
39525: LD_INT 2
39527: NEG
39528: PUSH
39529: LD_INT 0
39531: PUSH
39532: EMPTY
39533: LIST
39534: LIST
39535: PUSH
39536: LD_INT 2
39538: NEG
39539: PUSH
39540: LD_INT 1
39542: NEG
39543: PUSH
39544: EMPTY
39545: LIST
39546: LIST
39547: PUSH
39548: LD_INT 1
39550: NEG
39551: PUSH
39552: LD_INT 3
39554: NEG
39555: PUSH
39556: EMPTY
39557: LIST
39558: LIST
39559: PUSH
39560: LD_INT 1
39562: PUSH
39563: LD_INT 2
39565: NEG
39566: PUSH
39567: EMPTY
39568: LIST
39569: LIST
39570: PUSH
39571: LD_INT 3
39573: PUSH
39574: LD_INT 2
39576: PUSH
39577: EMPTY
39578: LIST
39579: LIST
39580: PUSH
39581: LD_INT 2
39583: PUSH
39584: LD_INT 3
39586: PUSH
39587: EMPTY
39588: LIST
39589: LIST
39590: PUSH
39591: LD_INT 2
39593: NEG
39594: PUSH
39595: LD_INT 1
39597: PUSH
39598: EMPTY
39599: LIST
39600: LIST
39601: PUSH
39602: LD_INT 3
39604: NEG
39605: PUSH
39606: LD_INT 1
39608: NEG
39609: PUSH
39610: EMPTY
39611: LIST
39612: LIST
39613: PUSH
39614: EMPTY
39615: LIST
39616: LIST
39617: LIST
39618: LIST
39619: LIST
39620: LIST
39621: LIST
39622: LIST
39623: LIST
39624: LIST
39625: LIST
39626: LIST
39627: LIST
39628: LIST
39629: LIST
39630: LIST
39631: LIST
39632: LIST
39633: LIST
39634: LIST
39635: LIST
39636: LIST
39637: LIST
39638: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
39639: LD_ADDR_VAR 0 33
39643: PUSH
39644: LD_INT 0
39646: PUSH
39647: LD_INT 0
39649: PUSH
39650: EMPTY
39651: LIST
39652: LIST
39653: PUSH
39654: LD_INT 0
39656: PUSH
39657: LD_INT 1
39659: NEG
39660: PUSH
39661: EMPTY
39662: LIST
39663: LIST
39664: PUSH
39665: LD_INT 1
39667: PUSH
39668: LD_INT 0
39670: PUSH
39671: EMPTY
39672: LIST
39673: LIST
39674: PUSH
39675: LD_INT 1
39677: PUSH
39678: LD_INT 1
39680: PUSH
39681: EMPTY
39682: LIST
39683: LIST
39684: PUSH
39685: LD_INT 0
39687: PUSH
39688: LD_INT 1
39690: PUSH
39691: EMPTY
39692: LIST
39693: LIST
39694: PUSH
39695: LD_INT 1
39697: NEG
39698: PUSH
39699: LD_INT 0
39701: PUSH
39702: EMPTY
39703: LIST
39704: LIST
39705: PUSH
39706: LD_INT 1
39708: NEG
39709: PUSH
39710: LD_INT 1
39712: NEG
39713: PUSH
39714: EMPTY
39715: LIST
39716: LIST
39717: PUSH
39718: LD_INT 1
39720: NEG
39721: PUSH
39722: LD_INT 2
39724: NEG
39725: PUSH
39726: EMPTY
39727: LIST
39728: LIST
39729: PUSH
39730: LD_INT 1
39732: PUSH
39733: LD_INT 1
39735: NEG
39736: PUSH
39737: EMPTY
39738: LIST
39739: LIST
39740: PUSH
39741: LD_INT 2
39743: PUSH
39744: LD_INT 0
39746: PUSH
39747: EMPTY
39748: LIST
39749: LIST
39750: PUSH
39751: LD_INT 2
39753: PUSH
39754: LD_INT 1
39756: PUSH
39757: EMPTY
39758: LIST
39759: LIST
39760: PUSH
39761: LD_INT 1
39763: PUSH
39764: LD_INT 2
39766: PUSH
39767: EMPTY
39768: LIST
39769: LIST
39770: PUSH
39771: LD_INT 0
39773: PUSH
39774: LD_INT 2
39776: PUSH
39777: EMPTY
39778: LIST
39779: LIST
39780: PUSH
39781: LD_INT 1
39783: NEG
39784: PUSH
39785: LD_INT 1
39787: PUSH
39788: EMPTY
39789: LIST
39790: LIST
39791: PUSH
39792: LD_INT 2
39794: NEG
39795: PUSH
39796: LD_INT 0
39798: PUSH
39799: EMPTY
39800: LIST
39801: LIST
39802: PUSH
39803: LD_INT 2
39805: NEG
39806: PUSH
39807: LD_INT 1
39809: NEG
39810: PUSH
39811: EMPTY
39812: LIST
39813: LIST
39814: PUSH
39815: LD_INT 2
39817: NEG
39818: PUSH
39819: LD_INT 2
39821: NEG
39822: PUSH
39823: EMPTY
39824: LIST
39825: LIST
39826: PUSH
39827: LD_INT 2
39829: NEG
39830: PUSH
39831: LD_INT 3
39833: NEG
39834: PUSH
39835: EMPTY
39836: LIST
39837: LIST
39838: PUSH
39839: LD_INT 2
39841: PUSH
39842: LD_INT 1
39844: NEG
39845: PUSH
39846: EMPTY
39847: LIST
39848: LIST
39849: PUSH
39850: LD_INT 3
39852: PUSH
39853: LD_INT 1
39855: PUSH
39856: EMPTY
39857: LIST
39858: LIST
39859: PUSH
39860: LD_INT 1
39862: PUSH
39863: LD_INT 3
39865: PUSH
39866: EMPTY
39867: LIST
39868: LIST
39869: PUSH
39870: LD_INT 1
39872: NEG
39873: PUSH
39874: LD_INT 2
39876: PUSH
39877: EMPTY
39878: LIST
39879: LIST
39880: PUSH
39881: LD_INT 3
39883: NEG
39884: PUSH
39885: LD_INT 2
39887: NEG
39888: PUSH
39889: EMPTY
39890: LIST
39891: LIST
39892: PUSH
39893: EMPTY
39894: LIST
39895: LIST
39896: LIST
39897: LIST
39898: LIST
39899: LIST
39900: LIST
39901: LIST
39902: LIST
39903: LIST
39904: LIST
39905: LIST
39906: LIST
39907: LIST
39908: LIST
39909: LIST
39910: LIST
39911: LIST
39912: LIST
39913: LIST
39914: LIST
39915: LIST
39916: LIST
39917: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
39918: LD_ADDR_VAR 0 34
39922: PUSH
39923: LD_INT 0
39925: PUSH
39926: LD_INT 0
39928: PUSH
39929: EMPTY
39930: LIST
39931: LIST
39932: PUSH
39933: LD_INT 0
39935: PUSH
39936: LD_INT 1
39938: NEG
39939: PUSH
39940: EMPTY
39941: LIST
39942: LIST
39943: PUSH
39944: LD_INT 1
39946: PUSH
39947: LD_INT 0
39949: PUSH
39950: EMPTY
39951: LIST
39952: LIST
39953: PUSH
39954: LD_INT 1
39956: PUSH
39957: LD_INT 1
39959: PUSH
39960: EMPTY
39961: LIST
39962: LIST
39963: PUSH
39964: LD_INT 0
39966: PUSH
39967: LD_INT 1
39969: PUSH
39970: EMPTY
39971: LIST
39972: LIST
39973: PUSH
39974: LD_INT 1
39976: NEG
39977: PUSH
39978: LD_INT 0
39980: PUSH
39981: EMPTY
39982: LIST
39983: LIST
39984: PUSH
39985: LD_INT 1
39987: NEG
39988: PUSH
39989: LD_INT 1
39991: NEG
39992: PUSH
39993: EMPTY
39994: LIST
39995: LIST
39996: PUSH
39997: LD_INT 1
39999: NEG
40000: PUSH
40001: LD_INT 2
40003: NEG
40004: PUSH
40005: EMPTY
40006: LIST
40007: LIST
40008: PUSH
40009: LD_INT 0
40011: PUSH
40012: LD_INT 2
40014: NEG
40015: PUSH
40016: EMPTY
40017: LIST
40018: LIST
40019: PUSH
40020: LD_INT 1
40022: PUSH
40023: LD_INT 1
40025: NEG
40026: PUSH
40027: EMPTY
40028: LIST
40029: LIST
40030: PUSH
40031: LD_INT 2
40033: PUSH
40034: LD_INT 1
40036: PUSH
40037: EMPTY
40038: LIST
40039: LIST
40040: PUSH
40041: LD_INT 2
40043: PUSH
40044: LD_INT 2
40046: PUSH
40047: EMPTY
40048: LIST
40049: LIST
40050: PUSH
40051: LD_INT 1
40053: PUSH
40054: LD_INT 2
40056: PUSH
40057: EMPTY
40058: LIST
40059: LIST
40060: PUSH
40061: LD_INT 1
40063: NEG
40064: PUSH
40065: LD_INT 1
40067: PUSH
40068: EMPTY
40069: LIST
40070: LIST
40071: PUSH
40072: LD_INT 2
40074: NEG
40075: PUSH
40076: LD_INT 0
40078: PUSH
40079: EMPTY
40080: LIST
40081: LIST
40082: PUSH
40083: LD_INT 2
40085: NEG
40086: PUSH
40087: LD_INT 1
40089: NEG
40090: PUSH
40091: EMPTY
40092: LIST
40093: LIST
40094: PUSH
40095: LD_INT 2
40097: NEG
40098: PUSH
40099: LD_INT 2
40101: NEG
40102: PUSH
40103: EMPTY
40104: LIST
40105: LIST
40106: PUSH
40107: LD_INT 1
40109: NEG
40110: PUSH
40111: LD_INT 3
40113: NEG
40114: PUSH
40115: EMPTY
40116: LIST
40117: LIST
40118: PUSH
40119: LD_INT 1
40121: PUSH
40122: LD_INT 2
40124: NEG
40125: PUSH
40126: EMPTY
40127: LIST
40128: LIST
40129: PUSH
40130: LD_INT 3
40132: PUSH
40133: LD_INT 2
40135: PUSH
40136: EMPTY
40137: LIST
40138: LIST
40139: PUSH
40140: LD_INT 2
40142: PUSH
40143: LD_INT 3
40145: PUSH
40146: EMPTY
40147: LIST
40148: LIST
40149: PUSH
40150: LD_INT 2
40152: NEG
40153: PUSH
40154: LD_INT 1
40156: PUSH
40157: EMPTY
40158: LIST
40159: LIST
40160: PUSH
40161: LD_INT 3
40163: NEG
40164: PUSH
40165: LD_INT 1
40167: NEG
40168: PUSH
40169: EMPTY
40170: LIST
40171: LIST
40172: PUSH
40173: EMPTY
40174: LIST
40175: LIST
40176: LIST
40177: LIST
40178: LIST
40179: LIST
40180: LIST
40181: LIST
40182: LIST
40183: LIST
40184: LIST
40185: LIST
40186: LIST
40187: LIST
40188: LIST
40189: LIST
40190: LIST
40191: LIST
40192: LIST
40193: LIST
40194: LIST
40195: LIST
40196: LIST
40197: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
40198: LD_ADDR_VAR 0 35
40202: PUSH
40203: LD_INT 0
40205: PUSH
40206: LD_INT 0
40208: PUSH
40209: EMPTY
40210: LIST
40211: LIST
40212: PUSH
40213: LD_INT 0
40215: PUSH
40216: LD_INT 1
40218: NEG
40219: PUSH
40220: EMPTY
40221: LIST
40222: LIST
40223: PUSH
40224: LD_INT 1
40226: PUSH
40227: LD_INT 0
40229: PUSH
40230: EMPTY
40231: LIST
40232: LIST
40233: PUSH
40234: LD_INT 1
40236: PUSH
40237: LD_INT 1
40239: PUSH
40240: EMPTY
40241: LIST
40242: LIST
40243: PUSH
40244: LD_INT 0
40246: PUSH
40247: LD_INT 1
40249: PUSH
40250: EMPTY
40251: LIST
40252: LIST
40253: PUSH
40254: LD_INT 1
40256: NEG
40257: PUSH
40258: LD_INT 0
40260: PUSH
40261: EMPTY
40262: LIST
40263: LIST
40264: PUSH
40265: LD_INT 1
40267: NEG
40268: PUSH
40269: LD_INT 1
40271: NEG
40272: PUSH
40273: EMPTY
40274: LIST
40275: LIST
40276: PUSH
40277: LD_INT 2
40279: PUSH
40280: LD_INT 1
40282: PUSH
40283: EMPTY
40284: LIST
40285: LIST
40286: PUSH
40287: LD_INT 2
40289: NEG
40290: PUSH
40291: LD_INT 1
40293: NEG
40294: PUSH
40295: EMPTY
40296: LIST
40297: LIST
40298: PUSH
40299: EMPTY
40300: LIST
40301: LIST
40302: LIST
40303: LIST
40304: LIST
40305: LIST
40306: LIST
40307: LIST
40308: LIST
40309: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
40310: LD_ADDR_VAR 0 36
40314: PUSH
40315: LD_INT 0
40317: PUSH
40318: LD_INT 0
40320: PUSH
40321: EMPTY
40322: LIST
40323: LIST
40324: PUSH
40325: LD_INT 0
40327: PUSH
40328: LD_INT 1
40330: NEG
40331: PUSH
40332: EMPTY
40333: LIST
40334: LIST
40335: PUSH
40336: LD_INT 1
40338: PUSH
40339: LD_INT 0
40341: PUSH
40342: EMPTY
40343: LIST
40344: LIST
40345: PUSH
40346: LD_INT 1
40348: PUSH
40349: LD_INT 1
40351: PUSH
40352: EMPTY
40353: LIST
40354: LIST
40355: PUSH
40356: LD_INT 0
40358: PUSH
40359: LD_INT 1
40361: PUSH
40362: EMPTY
40363: LIST
40364: LIST
40365: PUSH
40366: LD_INT 1
40368: NEG
40369: PUSH
40370: LD_INT 0
40372: PUSH
40373: EMPTY
40374: LIST
40375: LIST
40376: PUSH
40377: LD_INT 1
40379: NEG
40380: PUSH
40381: LD_INT 1
40383: NEG
40384: PUSH
40385: EMPTY
40386: LIST
40387: LIST
40388: PUSH
40389: LD_INT 1
40391: NEG
40392: PUSH
40393: LD_INT 2
40395: NEG
40396: PUSH
40397: EMPTY
40398: LIST
40399: LIST
40400: PUSH
40401: LD_INT 1
40403: PUSH
40404: LD_INT 2
40406: PUSH
40407: EMPTY
40408: LIST
40409: LIST
40410: PUSH
40411: EMPTY
40412: LIST
40413: LIST
40414: LIST
40415: LIST
40416: LIST
40417: LIST
40418: LIST
40419: LIST
40420: LIST
40421: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
40422: LD_ADDR_VAR 0 37
40426: PUSH
40427: LD_INT 0
40429: PUSH
40430: LD_INT 0
40432: PUSH
40433: EMPTY
40434: LIST
40435: LIST
40436: PUSH
40437: LD_INT 0
40439: PUSH
40440: LD_INT 1
40442: NEG
40443: PUSH
40444: EMPTY
40445: LIST
40446: LIST
40447: PUSH
40448: LD_INT 1
40450: PUSH
40451: LD_INT 0
40453: PUSH
40454: EMPTY
40455: LIST
40456: LIST
40457: PUSH
40458: LD_INT 1
40460: PUSH
40461: LD_INT 1
40463: PUSH
40464: EMPTY
40465: LIST
40466: LIST
40467: PUSH
40468: LD_INT 0
40470: PUSH
40471: LD_INT 1
40473: PUSH
40474: EMPTY
40475: LIST
40476: LIST
40477: PUSH
40478: LD_INT 1
40480: NEG
40481: PUSH
40482: LD_INT 0
40484: PUSH
40485: EMPTY
40486: LIST
40487: LIST
40488: PUSH
40489: LD_INT 1
40491: NEG
40492: PUSH
40493: LD_INT 1
40495: NEG
40496: PUSH
40497: EMPTY
40498: LIST
40499: LIST
40500: PUSH
40501: LD_INT 1
40503: PUSH
40504: LD_INT 1
40506: NEG
40507: PUSH
40508: EMPTY
40509: LIST
40510: LIST
40511: PUSH
40512: LD_INT 1
40514: NEG
40515: PUSH
40516: LD_INT 1
40518: PUSH
40519: EMPTY
40520: LIST
40521: LIST
40522: PUSH
40523: EMPTY
40524: LIST
40525: LIST
40526: LIST
40527: LIST
40528: LIST
40529: LIST
40530: LIST
40531: LIST
40532: LIST
40533: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
40534: LD_ADDR_VAR 0 38
40538: PUSH
40539: LD_INT 0
40541: PUSH
40542: LD_INT 0
40544: PUSH
40545: EMPTY
40546: LIST
40547: LIST
40548: PUSH
40549: LD_INT 0
40551: PUSH
40552: LD_INT 1
40554: NEG
40555: PUSH
40556: EMPTY
40557: LIST
40558: LIST
40559: PUSH
40560: LD_INT 1
40562: PUSH
40563: LD_INT 0
40565: PUSH
40566: EMPTY
40567: LIST
40568: LIST
40569: PUSH
40570: LD_INT 1
40572: PUSH
40573: LD_INT 1
40575: PUSH
40576: EMPTY
40577: LIST
40578: LIST
40579: PUSH
40580: LD_INT 0
40582: PUSH
40583: LD_INT 1
40585: PUSH
40586: EMPTY
40587: LIST
40588: LIST
40589: PUSH
40590: LD_INT 1
40592: NEG
40593: PUSH
40594: LD_INT 0
40596: PUSH
40597: EMPTY
40598: LIST
40599: LIST
40600: PUSH
40601: LD_INT 1
40603: NEG
40604: PUSH
40605: LD_INT 1
40607: NEG
40608: PUSH
40609: EMPTY
40610: LIST
40611: LIST
40612: PUSH
40613: LD_INT 2
40615: PUSH
40616: LD_INT 1
40618: PUSH
40619: EMPTY
40620: LIST
40621: LIST
40622: PUSH
40623: LD_INT 2
40625: NEG
40626: PUSH
40627: LD_INT 1
40629: NEG
40630: PUSH
40631: EMPTY
40632: LIST
40633: LIST
40634: PUSH
40635: EMPTY
40636: LIST
40637: LIST
40638: LIST
40639: LIST
40640: LIST
40641: LIST
40642: LIST
40643: LIST
40644: LIST
40645: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
40646: LD_ADDR_VAR 0 39
40650: PUSH
40651: LD_INT 0
40653: PUSH
40654: LD_INT 0
40656: PUSH
40657: EMPTY
40658: LIST
40659: LIST
40660: PUSH
40661: LD_INT 0
40663: PUSH
40664: LD_INT 1
40666: NEG
40667: PUSH
40668: EMPTY
40669: LIST
40670: LIST
40671: PUSH
40672: LD_INT 1
40674: PUSH
40675: LD_INT 0
40677: PUSH
40678: EMPTY
40679: LIST
40680: LIST
40681: PUSH
40682: LD_INT 1
40684: PUSH
40685: LD_INT 1
40687: PUSH
40688: EMPTY
40689: LIST
40690: LIST
40691: PUSH
40692: LD_INT 0
40694: PUSH
40695: LD_INT 1
40697: PUSH
40698: EMPTY
40699: LIST
40700: LIST
40701: PUSH
40702: LD_INT 1
40704: NEG
40705: PUSH
40706: LD_INT 0
40708: PUSH
40709: EMPTY
40710: LIST
40711: LIST
40712: PUSH
40713: LD_INT 1
40715: NEG
40716: PUSH
40717: LD_INT 1
40719: NEG
40720: PUSH
40721: EMPTY
40722: LIST
40723: LIST
40724: PUSH
40725: LD_INT 1
40727: NEG
40728: PUSH
40729: LD_INT 2
40731: NEG
40732: PUSH
40733: EMPTY
40734: LIST
40735: LIST
40736: PUSH
40737: LD_INT 1
40739: PUSH
40740: LD_INT 2
40742: PUSH
40743: EMPTY
40744: LIST
40745: LIST
40746: PUSH
40747: EMPTY
40748: LIST
40749: LIST
40750: LIST
40751: LIST
40752: LIST
40753: LIST
40754: LIST
40755: LIST
40756: LIST
40757: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
40758: LD_ADDR_VAR 0 40
40762: PUSH
40763: LD_INT 0
40765: PUSH
40766: LD_INT 0
40768: PUSH
40769: EMPTY
40770: LIST
40771: LIST
40772: PUSH
40773: LD_INT 0
40775: PUSH
40776: LD_INT 1
40778: NEG
40779: PUSH
40780: EMPTY
40781: LIST
40782: LIST
40783: PUSH
40784: LD_INT 1
40786: PUSH
40787: LD_INT 0
40789: PUSH
40790: EMPTY
40791: LIST
40792: LIST
40793: PUSH
40794: LD_INT 1
40796: PUSH
40797: LD_INT 1
40799: PUSH
40800: EMPTY
40801: LIST
40802: LIST
40803: PUSH
40804: LD_INT 0
40806: PUSH
40807: LD_INT 1
40809: PUSH
40810: EMPTY
40811: LIST
40812: LIST
40813: PUSH
40814: LD_INT 1
40816: NEG
40817: PUSH
40818: LD_INT 0
40820: PUSH
40821: EMPTY
40822: LIST
40823: LIST
40824: PUSH
40825: LD_INT 1
40827: NEG
40828: PUSH
40829: LD_INT 1
40831: NEG
40832: PUSH
40833: EMPTY
40834: LIST
40835: LIST
40836: PUSH
40837: LD_INT 1
40839: PUSH
40840: LD_INT 1
40842: NEG
40843: PUSH
40844: EMPTY
40845: LIST
40846: LIST
40847: PUSH
40848: LD_INT 1
40850: NEG
40851: PUSH
40852: LD_INT 1
40854: PUSH
40855: EMPTY
40856: LIST
40857: LIST
40858: PUSH
40859: EMPTY
40860: LIST
40861: LIST
40862: LIST
40863: LIST
40864: LIST
40865: LIST
40866: LIST
40867: LIST
40868: LIST
40869: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
40870: LD_ADDR_VAR 0 41
40874: PUSH
40875: LD_INT 0
40877: PUSH
40878: LD_INT 0
40880: PUSH
40881: EMPTY
40882: LIST
40883: LIST
40884: PUSH
40885: LD_INT 0
40887: PUSH
40888: LD_INT 1
40890: NEG
40891: PUSH
40892: EMPTY
40893: LIST
40894: LIST
40895: PUSH
40896: LD_INT 1
40898: PUSH
40899: LD_INT 0
40901: PUSH
40902: EMPTY
40903: LIST
40904: LIST
40905: PUSH
40906: LD_INT 1
40908: PUSH
40909: LD_INT 1
40911: PUSH
40912: EMPTY
40913: LIST
40914: LIST
40915: PUSH
40916: LD_INT 0
40918: PUSH
40919: LD_INT 1
40921: PUSH
40922: EMPTY
40923: LIST
40924: LIST
40925: PUSH
40926: LD_INT 1
40928: NEG
40929: PUSH
40930: LD_INT 0
40932: PUSH
40933: EMPTY
40934: LIST
40935: LIST
40936: PUSH
40937: LD_INT 1
40939: NEG
40940: PUSH
40941: LD_INT 1
40943: NEG
40944: PUSH
40945: EMPTY
40946: LIST
40947: LIST
40948: PUSH
40949: LD_INT 1
40951: NEG
40952: PUSH
40953: LD_INT 2
40955: NEG
40956: PUSH
40957: EMPTY
40958: LIST
40959: LIST
40960: PUSH
40961: LD_INT 1
40963: PUSH
40964: LD_INT 1
40966: NEG
40967: PUSH
40968: EMPTY
40969: LIST
40970: LIST
40971: PUSH
40972: LD_INT 2
40974: PUSH
40975: LD_INT 0
40977: PUSH
40978: EMPTY
40979: LIST
40980: LIST
40981: PUSH
40982: LD_INT 2
40984: PUSH
40985: LD_INT 1
40987: PUSH
40988: EMPTY
40989: LIST
40990: LIST
40991: PUSH
40992: LD_INT 2
40994: PUSH
40995: LD_INT 2
40997: PUSH
40998: EMPTY
40999: LIST
41000: LIST
41001: PUSH
41002: LD_INT 1
41004: PUSH
41005: LD_INT 2
41007: PUSH
41008: EMPTY
41009: LIST
41010: LIST
41011: PUSH
41012: LD_INT 1
41014: NEG
41015: PUSH
41016: LD_INT 1
41018: PUSH
41019: EMPTY
41020: LIST
41021: LIST
41022: PUSH
41023: LD_INT 2
41025: NEG
41026: PUSH
41027: LD_INT 0
41029: PUSH
41030: EMPTY
41031: LIST
41032: LIST
41033: PUSH
41034: LD_INT 2
41036: NEG
41037: PUSH
41038: LD_INT 1
41040: NEG
41041: PUSH
41042: EMPTY
41043: LIST
41044: LIST
41045: PUSH
41046: LD_INT 2
41048: NEG
41049: PUSH
41050: LD_INT 2
41052: NEG
41053: PUSH
41054: EMPTY
41055: LIST
41056: LIST
41057: PUSH
41058: LD_INT 2
41060: NEG
41061: PUSH
41062: LD_INT 3
41064: NEG
41065: PUSH
41066: EMPTY
41067: LIST
41068: LIST
41069: PUSH
41070: LD_INT 2
41072: PUSH
41073: LD_INT 1
41075: NEG
41076: PUSH
41077: EMPTY
41078: LIST
41079: LIST
41080: PUSH
41081: LD_INT 3
41083: PUSH
41084: LD_INT 0
41086: PUSH
41087: EMPTY
41088: LIST
41089: LIST
41090: PUSH
41091: LD_INT 3
41093: PUSH
41094: LD_INT 1
41096: PUSH
41097: EMPTY
41098: LIST
41099: LIST
41100: PUSH
41101: LD_INT 3
41103: PUSH
41104: LD_INT 2
41106: PUSH
41107: EMPTY
41108: LIST
41109: LIST
41110: PUSH
41111: LD_INT 3
41113: PUSH
41114: LD_INT 3
41116: PUSH
41117: EMPTY
41118: LIST
41119: LIST
41120: PUSH
41121: LD_INT 2
41123: PUSH
41124: LD_INT 3
41126: PUSH
41127: EMPTY
41128: LIST
41129: LIST
41130: PUSH
41131: LD_INT 2
41133: NEG
41134: PUSH
41135: LD_INT 1
41137: PUSH
41138: EMPTY
41139: LIST
41140: LIST
41141: PUSH
41142: LD_INT 3
41144: NEG
41145: PUSH
41146: LD_INT 0
41148: PUSH
41149: EMPTY
41150: LIST
41151: LIST
41152: PUSH
41153: LD_INT 3
41155: NEG
41156: PUSH
41157: LD_INT 1
41159: NEG
41160: PUSH
41161: EMPTY
41162: LIST
41163: LIST
41164: PUSH
41165: LD_INT 3
41167: NEG
41168: PUSH
41169: LD_INT 2
41171: NEG
41172: PUSH
41173: EMPTY
41174: LIST
41175: LIST
41176: PUSH
41177: LD_INT 3
41179: NEG
41180: PUSH
41181: LD_INT 3
41183: NEG
41184: PUSH
41185: EMPTY
41186: LIST
41187: LIST
41188: PUSH
41189: EMPTY
41190: LIST
41191: LIST
41192: LIST
41193: LIST
41194: LIST
41195: LIST
41196: LIST
41197: LIST
41198: LIST
41199: LIST
41200: LIST
41201: LIST
41202: LIST
41203: LIST
41204: LIST
41205: LIST
41206: LIST
41207: LIST
41208: LIST
41209: LIST
41210: LIST
41211: LIST
41212: LIST
41213: LIST
41214: LIST
41215: LIST
41216: LIST
41217: LIST
41218: LIST
41219: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
41220: LD_ADDR_VAR 0 42
41224: PUSH
41225: LD_INT 0
41227: PUSH
41228: LD_INT 0
41230: PUSH
41231: EMPTY
41232: LIST
41233: LIST
41234: PUSH
41235: LD_INT 0
41237: PUSH
41238: LD_INT 1
41240: NEG
41241: PUSH
41242: EMPTY
41243: LIST
41244: LIST
41245: PUSH
41246: LD_INT 1
41248: PUSH
41249: LD_INT 0
41251: PUSH
41252: EMPTY
41253: LIST
41254: LIST
41255: PUSH
41256: LD_INT 1
41258: PUSH
41259: LD_INT 1
41261: PUSH
41262: EMPTY
41263: LIST
41264: LIST
41265: PUSH
41266: LD_INT 0
41268: PUSH
41269: LD_INT 1
41271: PUSH
41272: EMPTY
41273: LIST
41274: LIST
41275: PUSH
41276: LD_INT 1
41278: NEG
41279: PUSH
41280: LD_INT 0
41282: PUSH
41283: EMPTY
41284: LIST
41285: LIST
41286: PUSH
41287: LD_INT 1
41289: NEG
41290: PUSH
41291: LD_INT 1
41293: NEG
41294: PUSH
41295: EMPTY
41296: LIST
41297: LIST
41298: PUSH
41299: LD_INT 1
41301: NEG
41302: PUSH
41303: LD_INT 2
41305: NEG
41306: PUSH
41307: EMPTY
41308: LIST
41309: LIST
41310: PUSH
41311: LD_INT 0
41313: PUSH
41314: LD_INT 2
41316: NEG
41317: PUSH
41318: EMPTY
41319: LIST
41320: LIST
41321: PUSH
41322: LD_INT 1
41324: PUSH
41325: LD_INT 1
41327: NEG
41328: PUSH
41329: EMPTY
41330: LIST
41331: LIST
41332: PUSH
41333: LD_INT 2
41335: PUSH
41336: LD_INT 1
41338: PUSH
41339: EMPTY
41340: LIST
41341: LIST
41342: PUSH
41343: LD_INT 2
41345: PUSH
41346: LD_INT 2
41348: PUSH
41349: EMPTY
41350: LIST
41351: LIST
41352: PUSH
41353: LD_INT 1
41355: PUSH
41356: LD_INT 2
41358: PUSH
41359: EMPTY
41360: LIST
41361: LIST
41362: PUSH
41363: LD_INT 0
41365: PUSH
41366: LD_INT 2
41368: PUSH
41369: EMPTY
41370: LIST
41371: LIST
41372: PUSH
41373: LD_INT 1
41375: NEG
41376: PUSH
41377: LD_INT 1
41379: PUSH
41380: EMPTY
41381: LIST
41382: LIST
41383: PUSH
41384: LD_INT 2
41386: NEG
41387: PUSH
41388: LD_INT 1
41390: NEG
41391: PUSH
41392: EMPTY
41393: LIST
41394: LIST
41395: PUSH
41396: LD_INT 2
41398: NEG
41399: PUSH
41400: LD_INT 2
41402: NEG
41403: PUSH
41404: EMPTY
41405: LIST
41406: LIST
41407: PUSH
41408: LD_INT 2
41410: NEG
41411: PUSH
41412: LD_INT 3
41414: NEG
41415: PUSH
41416: EMPTY
41417: LIST
41418: LIST
41419: PUSH
41420: LD_INT 1
41422: NEG
41423: PUSH
41424: LD_INT 3
41426: NEG
41427: PUSH
41428: EMPTY
41429: LIST
41430: LIST
41431: PUSH
41432: LD_INT 0
41434: PUSH
41435: LD_INT 3
41437: NEG
41438: PUSH
41439: EMPTY
41440: LIST
41441: LIST
41442: PUSH
41443: LD_INT 1
41445: PUSH
41446: LD_INT 2
41448: NEG
41449: PUSH
41450: EMPTY
41451: LIST
41452: LIST
41453: PUSH
41454: LD_INT 3
41456: PUSH
41457: LD_INT 2
41459: PUSH
41460: EMPTY
41461: LIST
41462: LIST
41463: PUSH
41464: LD_INT 3
41466: PUSH
41467: LD_INT 3
41469: PUSH
41470: EMPTY
41471: LIST
41472: LIST
41473: PUSH
41474: LD_INT 2
41476: PUSH
41477: LD_INT 3
41479: PUSH
41480: EMPTY
41481: LIST
41482: LIST
41483: PUSH
41484: LD_INT 1
41486: PUSH
41487: LD_INT 3
41489: PUSH
41490: EMPTY
41491: LIST
41492: LIST
41493: PUSH
41494: LD_INT 0
41496: PUSH
41497: LD_INT 3
41499: PUSH
41500: EMPTY
41501: LIST
41502: LIST
41503: PUSH
41504: LD_INT 1
41506: NEG
41507: PUSH
41508: LD_INT 2
41510: PUSH
41511: EMPTY
41512: LIST
41513: LIST
41514: PUSH
41515: LD_INT 3
41517: NEG
41518: PUSH
41519: LD_INT 2
41521: NEG
41522: PUSH
41523: EMPTY
41524: LIST
41525: LIST
41526: PUSH
41527: LD_INT 3
41529: NEG
41530: PUSH
41531: LD_INT 3
41533: NEG
41534: PUSH
41535: EMPTY
41536: LIST
41537: LIST
41538: PUSH
41539: EMPTY
41540: LIST
41541: LIST
41542: LIST
41543: LIST
41544: LIST
41545: LIST
41546: LIST
41547: LIST
41548: LIST
41549: LIST
41550: LIST
41551: LIST
41552: LIST
41553: LIST
41554: LIST
41555: LIST
41556: LIST
41557: LIST
41558: LIST
41559: LIST
41560: LIST
41561: LIST
41562: LIST
41563: LIST
41564: LIST
41565: LIST
41566: LIST
41567: LIST
41568: LIST
41569: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
41570: LD_ADDR_VAR 0 43
41574: PUSH
41575: LD_INT 0
41577: PUSH
41578: LD_INT 0
41580: PUSH
41581: EMPTY
41582: LIST
41583: LIST
41584: PUSH
41585: LD_INT 0
41587: PUSH
41588: LD_INT 1
41590: NEG
41591: PUSH
41592: EMPTY
41593: LIST
41594: LIST
41595: PUSH
41596: LD_INT 1
41598: PUSH
41599: LD_INT 0
41601: PUSH
41602: EMPTY
41603: LIST
41604: LIST
41605: PUSH
41606: LD_INT 1
41608: PUSH
41609: LD_INT 1
41611: PUSH
41612: EMPTY
41613: LIST
41614: LIST
41615: PUSH
41616: LD_INT 0
41618: PUSH
41619: LD_INT 1
41621: PUSH
41622: EMPTY
41623: LIST
41624: LIST
41625: PUSH
41626: LD_INT 1
41628: NEG
41629: PUSH
41630: LD_INT 0
41632: PUSH
41633: EMPTY
41634: LIST
41635: LIST
41636: PUSH
41637: LD_INT 1
41639: NEG
41640: PUSH
41641: LD_INT 1
41643: NEG
41644: PUSH
41645: EMPTY
41646: LIST
41647: LIST
41648: PUSH
41649: LD_INT 1
41651: NEG
41652: PUSH
41653: LD_INT 2
41655: NEG
41656: PUSH
41657: EMPTY
41658: LIST
41659: LIST
41660: PUSH
41661: LD_INT 0
41663: PUSH
41664: LD_INT 2
41666: NEG
41667: PUSH
41668: EMPTY
41669: LIST
41670: LIST
41671: PUSH
41672: LD_INT 1
41674: PUSH
41675: LD_INT 1
41677: NEG
41678: PUSH
41679: EMPTY
41680: LIST
41681: LIST
41682: PUSH
41683: LD_INT 2
41685: PUSH
41686: LD_INT 0
41688: PUSH
41689: EMPTY
41690: LIST
41691: LIST
41692: PUSH
41693: LD_INT 2
41695: PUSH
41696: LD_INT 1
41698: PUSH
41699: EMPTY
41700: LIST
41701: LIST
41702: PUSH
41703: LD_INT 1
41705: PUSH
41706: LD_INT 2
41708: PUSH
41709: EMPTY
41710: LIST
41711: LIST
41712: PUSH
41713: LD_INT 0
41715: PUSH
41716: LD_INT 2
41718: PUSH
41719: EMPTY
41720: LIST
41721: LIST
41722: PUSH
41723: LD_INT 1
41725: NEG
41726: PUSH
41727: LD_INT 1
41729: PUSH
41730: EMPTY
41731: LIST
41732: LIST
41733: PUSH
41734: LD_INT 2
41736: NEG
41737: PUSH
41738: LD_INT 0
41740: PUSH
41741: EMPTY
41742: LIST
41743: LIST
41744: PUSH
41745: LD_INT 2
41747: NEG
41748: PUSH
41749: LD_INT 1
41751: NEG
41752: PUSH
41753: EMPTY
41754: LIST
41755: LIST
41756: PUSH
41757: LD_INT 1
41759: NEG
41760: PUSH
41761: LD_INT 3
41763: NEG
41764: PUSH
41765: EMPTY
41766: LIST
41767: LIST
41768: PUSH
41769: LD_INT 0
41771: PUSH
41772: LD_INT 3
41774: NEG
41775: PUSH
41776: EMPTY
41777: LIST
41778: LIST
41779: PUSH
41780: LD_INT 1
41782: PUSH
41783: LD_INT 2
41785: NEG
41786: PUSH
41787: EMPTY
41788: LIST
41789: LIST
41790: PUSH
41791: LD_INT 2
41793: PUSH
41794: LD_INT 1
41796: NEG
41797: PUSH
41798: EMPTY
41799: LIST
41800: LIST
41801: PUSH
41802: LD_INT 3
41804: PUSH
41805: LD_INT 0
41807: PUSH
41808: EMPTY
41809: LIST
41810: LIST
41811: PUSH
41812: LD_INT 3
41814: PUSH
41815: LD_INT 1
41817: PUSH
41818: EMPTY
41819: LIST
41820: LIST
41821: PUSH
41822: LD_INT 1
41824: PUSH
41825: LD_INT 3
41827: PUSH
41828: EMPTY
41829: LIST
41830: LIST
41831: PUSH
41832: LD_INT 0
41834: PUSH
41835: LD_INT 3
41837: PUSH
41838: EMPTY
41839: LIST
41840: LIST
41841: PUSH
41842: LD_INT 1
41844: NEG
41845: PUSH
41846: LD_INT 2
41848: PUSH
41849: EMPTY
41850: LIST
41851: LIST
41852: PUSH
41853: LD_INT 2
41855: NEG
41856: PUSH
41857: LD_INT 1
41859: PUSH
41860: EMPTY
41861: LIST
41862: LIST
41863: PUSH
41864: LD_INT 3
41866: NEG
41867: PUSH
41868: LD_INT 0
41870: PUSH
41871: EMPTY
41872: LIST
41873: LIST
41874: PUSH
41875: LD_INT 3
41877: NEG
41878: PUSH
41879: LD_INT 1
41881: NEG
41882: PUSH
41883: EMPTY
41884: LIST
41885: LIST
41886: PUSH
41887: EMPTY
41888: LIST
41889: LIST
41890: LIST
41891: LIST
41892: LIST
41893: LIST
41894: LIST
41895: LIST
41896: LIST
41897: LIST
41898: LIST
41899: LIST
41900: LIST
41901: LIST
41902: LIST
41903: LIST
41904: LIST
41905: LIST
41906: LIST
41907: LIST
41908: LIST
41909: LIST
41910: LIST
41911: LIST
41912: LIST
41913: LIST
41914: LIST
41915: LIST
41916: LIST
41917: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
41918: LD_ADDR_VAR 0 44
41922: PUSH
41923: LD_INT 0
41925: PUSH
41926: LD_INT 0
41928: PUSH
41929: EMPTY
41930: LIST
41931: LIST
41932: PUSH
41933: LD_INT 0
41935: PUSH
41936: LD_INT 1
41938: NEG
41939: PUSH
41940: EMPTY
41941: LIST
41942: LIST
41943: PUSH
41944: LD_INT 1
41946: PUSH
41947: LD_INT 0
41949: PUSH
41950: EMPTY
41951: LIST
41952: LIST
41953: PUSH
41954: LD_INT 1
41956: PUSH
41957: LD_INT 1
41959: PUSH
41960: EMPTY
41961: LIST
41962: LIST
41963: PUSH
41964: LD_INT 0
41966: PUSH
41967: LD_INT 1
41969: PUSH
41970: EMPTY
41971: LIST
41972: LIST
41973: PUSH
41974: LD_INT 1
41976: NEG
41977: PUSH
41978: LD_INT 0
41980: PUSH
41981: EMPTY
41982: LIST
41983: LIST
41984: PUSH
41985: LD_INT 1
41987: NEG
41988: PUSH
41989: LD_INT 1
41991: NEG
41992: PUSH
41993: EMPTY
41994: LIST
41995: LIST
41996: PUSH
41997: LD_INT 1
41999: NEG
42000: PUSH
42001: LD_INT 2
42003: NEG
42004: PUSH
42005: EMPTY
42006: LIST
42007: LIST
42008: PUSH
42009: LD_INT 1
42011: PUSH
42012: LD_INT 1
42014: NEG
42015: PUSH
42016: EMPTY
42017: LIST
42018: LIST
42019: PUSH
42020: LD_INT 2
42022: PUSH
42023: LD_INT 0
42025: PUSH
42026: EMPTY
42027: LIST
42028: LIST
42029: PUSH
42030: LD_INT 2
42032: PUSH
42033: LD_INT 1
42035: PUSH
42036: EMPTY
42037: LIST
42038: LIST
42039: PUSH
42040: LD_INT 2
42042: PUSH
42043: LD_INT 2
42045: PUSH
42046: EMPTY
42047: LIST
42048: LIST
42049: PUSH
42050: LD_INT 1
42052: PUSH
42053: LD_INT 2
42055: PUSH
42056: EMPTY
42057: LIST
42058: LIST
42059: PUSH
42060: LD_INT 1
42062: NEG
42063: PUSH
42064: LD_INT 1
42066: PUSH
42067: EMPTY
42068: LIST
42069: LIST
42070: PUSH
42071: LD_INT 2
42073: NEG
42074: PUSH
42075: LD_INT 0
42077: PUSH
42078: EMPTY
42079: LIST
42080: LIST
42081: PUSH
42082: LD_INT 2
42084: NEG
42085: PUSH
42086: LD_INT 1
42088: NEG
42089: PUSH
42090: EMPTY
42091: LIST
42092: LIST
42093: PUSH
42094: LD_INT 2
42096: NEG
42097: PUSH
42098: LD_INT 2
42100: NEG
42101: PUSH
42102: EMPTY
42103: LIST
42104: LIST
42105: PUSH
42106: LD_INT 2
42108: NEG
42109: PUSH
42110: LD_INT 3
42112: NEG
42113: PUSH
42114: EMPTY
42115: LIST
42116: LIST
42117: PUSH
42118: LD_INT 2
42120: PUSH
42121: LD_INT 1
42123: NEG
42124: PUSH
42125: EMPTY
42126: LIST
42127: LIST
42128: PUSH
42129: LD_INT 3
42131: PUSH
42132: LD_INT 0
42134: PUSH
42135: EMPTY
42136: LIST
42137: LIST
42138: PUSH
42139: LD_INT 3
42141: PUSH
42142: LD_INT 1
42144: PUSH
42145: EMPTY
42146: LIST
42147: LIST
42148: PUSH
42149: LD_INT 3
42151: PUSH
42152: LD_INT 2
42154: PUSH
42155: EMPTY
42156: LIST
42157: LIST
42158: PUSH
42159: LD_INT 3
42161: PUSH
42162: LD_INT 3
42164: PUSH
42165: EMPTY
42166: LIST
42167: LIST
42168: PUSH
42169: LD_INT 2
42171: PUSH
42172: LD_INT 3
42174: PUSH
42175: EMPTY
42176: LIST
42177: LIST
42178: PUSH
42179: LD_INT 2
42181: NEG
42182: PUSH
42183: LD_INT 1
42185: PUSH
42186: EMPTY
42187: LIST
42188: LIST
42189: PUSH
42190: LD_INT 3
42192: NEG
42193: PUSH
42194: LD_INT 0
42196: PUSH
42197: EMPTY
42198: LIST
42199: LIST
42200: PUSH
42201: LD_INT 3
42203: NEG
42204: PUSH
42205: LD_INT 1
42207: NEG
42208: PUSH
42209: EMPTY
42210: LIST
42211: LIST
42212: PUSH
42213: LD_INT 3
42215: NEG
42216: PUSH
42217: LD_INT 2
42219: NEG
42220: PUSH
42221: EMPTY
42222: LIST
42223: LIST
42224: PUSH
42225: LD_INT 3
42227: NEG
42228: PUSH
42229: LD_INT 3
42231: NEG
42232: PUSH
42233: EMPTY
42234: LIST
42235: LIST
42236: PUSH
42237: EMPTY
42238: LIST
42239: LIST
42240: LIST
42241: LIST
42242: LIST
42243: LIST
42244: LIST
42245: LIST
42246: LIST
42247: LIST
42248: LIST
42249: LIST
42250: LIST
42251: LIST
42252: LIST
42253: LIST
42254: LIST
42255: LIST
42256: LIST
42257: LIST
42258: LIST
42259: LIST
42260: LIST
42261: LIST
42262: LIST
42263: LIST
42264: LIST
42265: LIST
42266: LIST
42267: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
42268: LD_ADDR_VAR 0 45
42272: PUSH
42273: LD_INT 0
42275: PUSH
42276: LD_INT 0
42278: PUSH
42279: EMPTY
42280: LIST
42281: LIST
42282: PUSH
42283: LD_INT 0
42285: PUSH
42286: LD_INT 1
42288: NEG
42289: PUSH
42290: EMPTY
42291: LIST
42292: LIST
42293: PUSH
42294: LD_INT 1
42296: PUSH
42297: LD_INT 0
42299: PUSH
42300: EMPTY
42301: LIST
42302: LIST
42303: PUSH
42304: LD_INT 1
42306: PUSH
42307: LD_INT 1
42309: PUSH
42310: EMPTY
42311: LIST
42312: LIST
42313: PUSH
42314: LD_INT 0
42316: PUSH
42317: LD_INT 1
42319: PUSH
42320: EMPTY
42321: LIST
42322: LIST
42323: PUSH
42324: LD_INT 1
42326: NEG
42327: PUSH
42328: LD_INT 0
42330: PUSH
42331: EMPTY
42332: LIST
42333: LIST
42334: PUSH
42335: LD_INT 1
42337: NEG
42338: PUSH
42339: LD_INT 1
42341: NEG
42342: PUSH
42343: EMPTY
42344: LIST
42345: LIST
42346: PUSH
42347: LD_INT 1
42349: NEG
42350: PUSH
42351: LD_INT 2
42353: NEG
42354: PUSH
42355: EMPTY
42356: LIST
42357: LIST
42358: PUSH
42359: LD_INT 0
42361: PUSH
42362: LD_INT 2
42364: NEG
42365: PUSH
42366: EMPTY
42367: LIST
42368: LIST
42369: PUSH
42370: LD_INT 1
42372: PUSH
42373: LD_INT 1
42375: NEG
42376: PUSH
42377: EMPTY
42378: LIST
42379: LIST
42380: PUSH
42381: LD_INT 2
42383: PUSH
42384: LD_INT 1
42386: PUSH
42387: EMPTY
42388: LIST
42389: LIST
42390: PUSH
42391: LD_INT 2
42393: PUSH
42394: LD_INT 2
42396: PUSH
42397: EMPTY
42398: LIST
42399: LIST
42400: PUSH
42401: LD_INT 1
42403: PUSH
42404: LD_INT 2
42406: PUSH
42407: EMPTY
42408: LIST
42409: LIST
42410: PUSH
42411: LD_INT 0
42413: PUSH
42414: LD_INT 2
42416: PUSH
42417: EMPTY
42418: LIST
42419: LIST
42420: PUSH
42421: LD_INT 1
42423: NEG
42424: PUSH
42425: LD_INT 1
42427: PUSH
42428: EMPTY
42429: LIST
42430: LIST
42431: PUSH
42432: LD_INT 2
42434: NEG
42435: PUSH
42436: LD_INT 1
42438: NEG
42439: PUSH
42440: EMPTY
42441: LIST
42442: LIST
42443: PUSH
42444: LD_INT 2
42446: NEG
42447: PUSH
42448: LD_INT 2
42450: NEG
42451: PUSH
42452: EMPTY
42453: LIST
42454: LIST
42455: PUSH
42456: LD_INT 2
42458: NEG
42459: PUSH
42460: LD_INT 3
42462: NEG
42463: PUSH
42464: EMPTY
42465: LIST
42466: LIST
42467: PUSH
42468: LD_INT 1
42470: NEG
42471: PUSH
42472: LD_INT 3
42474: NEG
42475: PUSH
42476: EMPTY
42477: LIST
42478: LIST
42479: PUSH
42480: LD_INT 0
42482: PUSH
42483: LD_INT 3
42485: NEG
42486: PUSH
42487: EMPTY
42488: LIST
42489: LIST
42490: PUSH
42491: LD_INT 1
42493: PUSH
42494: LD_INT 2
42496: NEG
42497: PUSH
42498: EMPTY
42499: LIST
42500: LIST
42501: PUSH
42502: LD_INT 3
42504: PUSH
42505: LD_INT 2
42507: PUSH
42508: EMPTY
42509: LIST
42510: LIST
42511: PUSH
42512: LD_INT 3
42514: PUSH
42515: LD_INT 3
42517: PUSH
42518: EMPTY
42519: LIST
42520: LIST
42521: PUSH
42522: LD_INT 2
42524: PUSH
42525: LD_INT 3
42527: PUSH
42528: EMPTY
42529: LIST
42530: LIST
42531: PUSH
42532: LD_INT 1
42534: PUSH
42535: LD_INT 3
42537: PUSH
42538: EMPTY
42539: LIST
42540: LIST
42541: PUSH
42542: LD_INT 0
42544: PUSH
42545: LD_INT 3
42547: PUSH
42548: EMPTY
42549: LIST
42550: LIST
42551: PUSH
42552: LD_INT 1
42554: NEG
42555: PUSH
42556: LD_INT 2
42558: PUSH
42559: EMPTY
42560: LIST
42561: LIST
42562: PUSH
42563: LD_INT 3
42565: NEG
42566: PUSH
42567: LD_INT 2
42569: NEG
42570: PUSH
42571: EMPTY
42572: LIST
42573: LIST
42574: PUSH
42575: LD_INT 3
42577: NEG
42578: PUSH
42579: LD_INT 3
42581: NEG
42582: PUSH
42583: EMPTY
42584: LIST
42585: LIST
42586: PUSH
42587: EMPTY
42588: LIST
42589: LIST
42590: LIST
42591: LIST
42592: LIST
42593: LIST
42594: LIST
42595: LIST
42596: LIST
42597: LIST
42598: LIST
42599: LIST
42600: LIST
42601: LIST
42602: LIST
42603: LIST
42604: LIST
42605: LIST
42606: LIST
42607: LIST
42608: LIST
42609: LIST
42610: LIST
42611: LIST
42612: LIST
42613: LIST
42614: LIST
42615: LIST
42616: LIST
42617: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
42618: LD_ADDR_VAR 0 46
42622: PUSH
42623: LD_INT 0
42625: PUSH
42626: LD_INT 0
42628: PUSH
42629: EMPTY
42630: LIST
42631: LIST
42632: PUSH
42633: LD_INT 0
42635: PUSH
42636: LD_INT 1
42638: NEG
42639: PUSH
42640: EMPTY
42641: LIST
42642: LIST
42643: PUSH
42644: LD_INT 1
42646: PUSH
42647: LD_INT 0
42649: PUSH
42650: EMPTY
42651: LIST
42652: LIST
42653: PUSH
42654: LD_INT 1
42656: PUSH
42657: LD_INT 1
42659: PUSH
42660: EMPTY
42661: LIST
42662: LIST
42663: PUSH
42664: LD_INT 0
42666: PUSH
42667: LD_INT 1
42669: PUSH
42670: EMPTY
42671: LIST
42672: LIST
42673: PUSH
42674: LD_INT 1
42676: NEG
42677: PUSH
42678: LD_INT 0
42680: PUSH
42681: EMPTY
42682: LIST
42683: LIST
42684: PUSH
42685: LD_INT 1
42687: NEG
42688: PUSH
42689: LD_INT 1
42691: NEG
42692: PUSH
42693: EMPTY
42694: LIST
42695: LIST
42696: PUSH
42697: LD_INT 1
42699: NEG
42700: PUSH
42701: LD_INT 2
42703: NEG
42704: PUSH
42705: EMPTY
42706: LIST
42707: LIST
42708: PUSH
42709: LD_INT 0
42711: PUSH
42712: LD_INT 2
42714: NEG
42715: PUSH
42716: EMPTY
42717: LIST
42718: LIST
42719: PUSH
42720: LD_INT 1
42722: PUSH
42723: LD_INT 1
42725: NEG
42726: PUSH
42727: EMPTY
42728: LIST
42729: LIST
42730: PUSH
42731: LD_INT 2
42733: PUSH
42734: LD_INT 0
42736: PUSH
42737: EMPTY
42738: LIST
42739: LIST
42740: PUSH
42741: LD_INT 2
42743: PUSH
42744: LD_INT 1
42746: PUSH
42747: EMPTY
42748: LIST
42749: LIST
42750: PUSH
42751: LD_INT 1
42753: PUSH
42754: LD_INT 2
42756: PUSH
42757: EMPTY
42758: LIST
42759: LIST
42760: PUSH
42761: LD_INT 0
42763: PUSH
42764: LD_INT 2
42766: PUSH
42767: EMPTY
42768: LIST
42769: LIST
42770: PUSH
42771: LD_INT 1
42773: NEG
42774: PUSH
42775: LD_INT 1
42777: PUSH
42778: EMPTY
42779: LIST
42780: LIST
42781: PUSH
42782: LD_INT 2
42784: NEG
42785: PUSH
42786: LD_INT 0
42788: PUSH
42789: EMPTY
42790: LIST
42791: LIST
42792: PUSH
42793: LD_INT 2
42795: NEG
42796: PUSH
42797: LD_INT 1
42799: NEG
42800: PUSH
42801: EMPTY
42802: LIST
42803: LIST
42804: PUSH
42805: LD_INT 1
42807: NEG
42808: PUSH
42809: LD_INT 3
42811: NEG
42812: PUSH
42813: EMPTY
42814: LIST
42815: LIST
42816: PUSH
42817: LD_INT 0
42819: PUSH
42820: LD_INT 3
42822: NEG
42823: PUSH
42824: EMPTY
42825: LIST
42826: LIST
42827: PUSH
42828: LD_INT 1
42830: PUSH
42831: LD_INT 2
42833: NEG
42834: PUSH
42835: EMPTY
42836: LIST
42837: LIST
42838: PUSH
42839: LD_INT 2
42841: PUSH
42842: LD_INT 1
42844: NEG
42845: PUSH
42846: EMPTY
42847: LIST
42848: LIST
42849: PUSH
42850: LD_INT 3
42852: PUSH
42853: LD_INT 0
42855: PUSH
42856: EMPTY
42857: LIST
42858: LIST
42859: PUSH
42860: LD_INT 3
42862: PUSH
42863: LD_INT 1
42865: PUSH
42866: EMPTY
42867: LIST
42868: LIST
42869: PUSH
42870: LD_INT 1
42872: PUSH
42873: LD_INT 3
42875: PUSH
42876: EMPTY
42877: LIST
42878: LIST
42879: PUSH
42880: LD_INT 0
42882: PUSH
42883: LD_INT 3
42885: PUSH
42886: EMPTY
42887: LIST
42888: LIST
42889: PUSH
42890: LD_INT 1
42892: NEG
42893: PUSH
42894: LD_INT 2
42896: PUSH
42897: EMPTY
42898: LIST
42899: LIST
42900: PUSH
42901: LD_INT 2
42903: NEG
42904: PUSH
42905: LD_INT 1
42907: PUSH
42908: EMPTY
42909: LIST
42910: LIST
42911: PUSH
42912: LD_INT 3
42914: NEG
42915: PUSH
42916: LD_INT 0
42918: PUSH
42919: EMPTY
42920: LIST
42921: LIST
42922: PUSH
42923: LD_INT 3
42925: NEG
42926: PUSH
42927: LD_INT 1
42929: NEG
42930: PUSH
42931: EMPTY
42932: LIST
42933: LIST
42934: PUSH
42935: EMPTY
42936: LIST
42937: LIST
42938: LIST
42939: LIST
42940: LIST
42941: LIST
42942: LIST
42943: LIST
42944: LIST
42945: LIST
42946: LIST
42947: LIST
42948: LIST
42949: LIST
42950: LIST
42951: LIST
42952: LIST
42953: LIST
42954: LIST
42955: LIST
42956: LIST
42957: LIST
42958: LIST
42959: LIST
42960: LIST
42961: LIST
42962: LIST
42963: LIST
42964: LIST
42965: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
42966: LD_ADDR_VAR 0 47
42970: PUSH
42971: LD_INT 0
42973: PUSH
42974: LD_INT 0
42976: PUSH
42977: EMPTY
42978: LIST
42979: LIST
42980: PUSH
42981: LD_INT 0
42983: PUSH
42984: LD_INT 1
42986: NEG
42987: PUSH
42988: EMPTY
42989: LIST
42990: LIST
42991: PUSH
42992: LD_INT 1
42994: PUSH
42995: LD_INT 0
42997: PUSH
42998: EMPTY
42999: LIST
43000: LIST
43001: PUSH
43002: LD_INT 1
43004: PUSH
43005: LD_INT 1
43007: PUSH
43008: EMPTY
43009: LIST
43010: LIST
43011: PUSH
43012: LD_INT 0
43014: PUSH
43015: LD_INT 1
43017: PUSH
43018: EMPTY
43019: LIST
43020: LIST
43021: PUSH
43022: LD_INT 1
43024: NEG
43025: PUSH
43026: LD_INT 0
43028: PUSH
43029: EMPTY
43030: LIST
43031: LIST
43032: PUSH
43033: LD_INT 1
43035: NEG
43036: PUSH
43037: LD_INT 1
43039: NEG
43040: PUSH
43041: EMPTY
43042: LIST
43043: LIST
43044: PUSH
43045: LD_INT 1
43047: NEG
43048: PUSH
43049: LD_INT 2
43051: NEG
43052: PUSH
43053: EMPTY
43054: LIST
43055: LIST
43056: PUSH
43057: LD_INT 0
43059: PUSH
43060: LD_INT 2
43062: NEG
43063: PUSH
43064: EMPTY
43065: LIST
43066: LIST
43067: PUSH
43068: LD_INT 1
43070: PUSH
43071: LD_INT 1
43073: NEG
43074: PUSH
43075: EMPTY
43076: LIST
43077: LIST
43078: PUSH
43079: LD_INT 2
43081: NEG
43082: PUSH
43083: LD_INT 1
43085: NEG
43086: PUSH
43087: EMPTY
43088: LIST
43089: LIST
43090: PUSH
43091: LD_INT 2
43093: NEG
43094: PUSH
43095: LD_INT 2
43097: NEG
43098: PUSH
43099: EMPTY
43100: LIST
43101: LIST
43102: PUSH
43103: EMPTY
43104: LIST
43105: LIST
43106: LIST
43107: LIST
43108: LIST
43109: LIST
43110: LIST
43111: LIST
43112: LIST
43113: LIST
43114: LIST
43115: LIST
43116: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
43117: LD_ADDR_VAR 0 48
43121: PUSH
43122: LD_INT 0
43124: PUSH
43125: LD_INT 0
43127: PUSH
43128: EMPTY
43129: LIST
43130: LIST
43131: PUSH
43132: LD_INT 0
43134: PUSH
43135: LD_INT 1
43137: NEG
43138: PUSH
43139: EMPTY
43140: LIST
43141: LIST
43142: PUSH
43143: LD_INT 1
43145: PUSH
43146: LD_INT 0
43148: PUSH
43149: EMPTY
43150: LIST
43151: LIST
43152: PUSH
43153: LD_INT 1
43155: PUSH
43156: LD_INT 1
43158: PUSH
43159: EMPTY
43160: LIST
43161: LIST
43162: PUSH
43163: LD_INT 0
43165: PUSH
43166: LD_INT 1
43168: PUSH
43169: EMPTY
43170: LIST
43171: LIST
43172: PUSH
43173: LD_INT 1
43175: NEG
43176: PUSH
43177: LD_INT 0
43179: PUSH
43180: EMPTY
43181: LIST
43182: LIST
43183: PUSH
43184: LD_INT 1
43186: NEG
43187: PUSH
43188: LD_INT 1
43190: NEG
43191: PUSH
43192: EMPTY
43193: LIST
43194: LIST
43195: PUSH
43196: LD_INT 1
43198: NEG
43199: PUSH
43200: LD_INT 2
43202: NEG
43203: PUSH
43204: EMPTY
43205: LIST
43206: LIST
43207: PUSH
43208: LD_INT 0
43210: PUSH
43211: LD_INT 2
43213: NEG
43214: PUSH
43215: EMPTY
43216: LIST
43217: LIST
43218: PUSH
43219: LD_INT 1
43221: PUSH
43222: LD_INT 1
43224: NEG
43225: PUSH
43226: EMPTY
43227: LIST
43228: LIST
43229: PUSH
43230: LD_INT 2
43232: PUSH
43233: LD_INT 0
43235: PUSH
43236: EMPTY
43237: LIST
43238: LIST
43239: PUSH
43240: LD_INT 2
43242: PUSH
43243: LD_INT 1
43245: PUSH
43246: EMPTY
43247: LIST
43248: LIST
43249: PUSH
43250: EMPTY
43251: LIST
43252: LIST
43253: LIST
43254: LIST
43255: LIST
43256: LIST
43257: LIST
43258: LIST
43259: LIST
43260: LIST
43261: LIST
43262: LIST
43263: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
43264: LD_ADDR_VAR 0 49
43268: PUSH
43269: LD_INT 0
43271: PUSH
43272: LD_INT 0
43274: PUSH
43275: EMPTY
43276: LIST
43277: LIST
43278: PUSH
43279: LD_INT 0
43281: PUSH
43282: LD_INT 1
43284: NEG
43285: PUSH
43286: EMPTY
43287: LIST
43288: LIST
43289: PUSH
43290: LD_INT 1
43292: PUSH
43293: LD_INT 0
43295: PUSH
43296: EMPTY
43297: LIST
43298: LIST
43299: PUSH
43300: LD_INT 1
43302: PUSH
43303: LD_INT 1
43305: PUSH
43306: EMPTY
43307: LIST
43308: LIST
43309: PUSH
43310: LD_INT 0
43312: PUSH
43313: LD_INT 1
43315: PUSH
43316: EMPTY
43317: LIST
43318: LIST
43319: PUSH
43320: LD_INT 1
43322: NEG
43323: PUSH
43324: LD_INT 0
43326: PUSH
43327: EMPTY
43328: LIST
43329: LIST
43330: PUSH
43331: LD_INT 1
43333: NEG
43334: PUSH
43335: LD_INT 1
43337: NEG
43338: PUSH
43339: EMPTY
43340: LIST
43341: LIST
43342: PUSH
43343: LD_INT 1
43345: PUSH
43346: LD_INT 1
43348: NEG
43349: PUSH
43350: EMPTY
43351: LIST
43352: LIST
43353: PUSH
43354: LD_INT 2
43356: PUSH
43357: LD_INT 0
43359: PUSH
43360: EMPTY
43361: LIST
43362: LIST
43363: PUSH
43364: LD_INT 2
43366: PUSH
43367: LD_INT 1
43369: PUSH
43370: EMPTY
43371: LIST
43372: LIST
43373: PUSH
43374: LD_INT 2
43376: PUSH
43377: LD_INT 2
43379: PUSH
43380: EMPTY
43381: LIST
43382: LIST
43383: PUSH
43384: LD_INT 1
43386: PUSH
43387: LD_INT 2
43389: PUSH
43390: EMPTY
43391: LIST
43392: LIST
43393: PUSH
43394: EMPTY
43395: LIST
43396: LIST
43397: LIST
43398: LIST
43399: LIST
43400: LIST
43401: LIST
43402: LIST
43403: LIST
43404: LIST
43405: LIST
43406: LIST
43407: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
43408: LD_ADDR_VAR 0 50
43412: PUSH
43413: LD_INT 0
43415: PUSH
43416: LD_INT 0
43418: PUSH
43419: EMPTY
43420: LIST
43421: LIST
43422: PUSH
43423: LD_INT 0
43425: PUSH
43426: LD_INT 1
43428: NEG
43429: PUSH
43430: EMPTY
43431: LIST
43432: LIST
43433: PUSH
43434: LD_INT 1
43436: PUSH
43437: LD_INT 0
43439: PUSH
43440: EMPTY
43441: LIST
43442: LIST
43443: PUSH
43444: LD_INT 1
43446: PUSH
43447: LD_INT 1
43449: PUSH
43450: EMPTY
43451: LIST
43452: LIST
43453: PUSH
43454: LD_INT 0
43456: PUSH
43457: LD_INT 1
43459: PUSH
43460: EMPTY
43461: LIST
43462: LIST
43463: PUSH
43464: LD_INT 1
43466: NEG
43467: PUSH
43468: LD_INT 0
43470: PUSH
43471: EMPTY
43472: LIST
43473: LIST
43474: PUSH
43475: LD_INT 1
43477: NEG
43478: PUSH
43479: LD_INT 1
43481: NEG
43482: PUSH
43483: EMPTY
43484: LIST
43485: LIST
43486: PUSH
43487: LD_INT 2
43489: PUSH
43490: LD_INT 1
43492: PUSH
43493: EMPTY
43494: LIST
43495: LIST
43496: PUSH
43497: LD_INT 2
43499: PUSH
43500: LD_INT 2
43502: PUSH
43503: EMPTY
43504: LIST
43505: LIST
43506: PUSH
43507: LD_INT 1
43509: PUSH
43510: LD_INT 2
43512: PUSH
43513: EMPTY
43514: LIST
43515: LIST
43516: PUSH
43517: LD_INT 0
43519: PUSH
43520: LD_INT 2
43522: PUSH
43523: EMPTY
43524: LIST
43525: LIST
43526: PUSH
43527: LD_INT 1
43529: NEG
43530: PUSH
43531: LD_INT 1
43533: PUSH
43534: EMPTY
43535: LIST
43536: LIST
43537: PUSH
43538: EMPTY
43539: LIST
43540: LIST
43541: LIST
43542: LIST
43543: LIST
43544: LIST
43545: LIST
43546: LIST
43547: LIST
43548: LIST
43549: LIST
43550: LIST
43551: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
43552: LD_ADDR_VAR 0 51
43556: PUSH
43557: LD_INT 0
43559: PUSH
43560: LD_INT 0
43562: PUSH
43563: EMPTY
43564: LIST
43565: LIST
43566: PUSH
43567: LD_INT 0
43569: PUSH
43570: LD_INT 1
43572: NEG
43573: PUSH
43574: EMPTY
43575: LIST
43576: LIST
43577: PUSH
43578: LD_INT 1
43580: PUSH
43581: LD_INT 0
43583: PUSH
43584: EMPTY
43585: LIST
43586: LIST
43587: PUSH
43588: LD_INT 1
43590: PUSH
43591: LD_INT 1
43593: PUSH
43594: EMPTY
43595: LIST
43596: LIST
43597: PUSH
43598: LD_INT 0
43600: PUSH
43601: LD_INT 1
43603: PUSH
43604: EMPTY
43605: LIST
43606: LIST
43607: PUSH
43608: LD_INT 1
43610: NEG
43611: PUSH
43612: LD_INT 0
43614: PUSH
43615: EMPTY
43616: LIST
43617: LIST
43618: PUSH
43619: LD_INT 1
43621: NEG
43622: PUSH
43623: LD_INT 1
43625: NEG
43626: PUSH
43627: EMPTY
43628: LIST
43629: LIST
43630: PUSH
43631: LD_INT 1
43633: PUSH
43634: LD_INT 2
43636: PUSH
43637: EMPTY
43638: LIST
43639: LIST
43640: PUSH
43641: LD_INT 0
43643: PUSH
43644: LD_INT 2
43646: PUSH
43647: EMPTY
43648: LIST
43649: LIST
43650: PUSH
43651: LD_INT 1
43653: NEG
43654: PUSH
43655: LD_INT 1
43657: PUSH
43658: EMPTY
43659: LIST
43660: LIST
43661: PUSH
43662: LD_INT 2
43664: NEG
43665: PUSH
43666: LD_INT 0
43668: PUSH
43669: EMPTY
43670: LIST
43671: LIST
43672: PUSH
43673: LD_INT 2
43675: NEG
43676: PUSH
43677: LD_INT 1
43679: NEG
43680: PUSH
43681: EMPTY
43682: LIST
43683: LIST
43684: PUSH
43685: EMPTY
43686: LIST
43687: LIST
43688: LIST
43689: LIST
43690: LIST
43691: LIST
43692: LIST
43693: LIST
43694: LIST
43695: LIST
43696: LIST
43697: LIST
43698: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
43699: LD_ADDR_VAR 0 52
43703: PUSH
43704: LD_INT 0
43706: PUSH
43707: LD_INT 0
43709: PUSH
43710: EMPTY
43711: LIST
43712: LIST
43713: PUSH
43714: LD_INT 0
43716: PUSH
43717: LD_INT 1
43719: NEG
43720: PUSH
43721: EMPTY
43722: LIST
43723: LIST
43724: PUSH
43725: LD_INT 1
43727: PUSH
43728: LD_INT 0
43730: PUSH
43731: EMPTY
43732: LIST
43733: LIST
43734: PUSH
43735: LD_INT 1
43737: PUSH
43738: LD_INT 1
43740: PUSH
43741: EMPTY
43742: LIST
43743: LIST
43744: PUSH
43745: LD_INT 0
43747: PUSH
43748: LD_INT 1
43750: PUSH
43751: EMPTY
43752: LIST
43753: LIST
43754: PUSH
43755: LD_INT 1
43757: NEG
43758: PUSH
43759: LD_INT 0
43761: PUSH
43762: EMPTY
43763: LIST
43764: LIST
43765: PUSH
43766: LD_INT 1
43768: NEG
43769: PUSH
43770: LD_INT 1
43772: NEG
43773: PUSH
43774: EMPTY
43775: LIST
43776: LIST
43777: PUSH
43778: LD_INT 1
43780: NEG
43781: PUSH
43782: LD_INT 2
43784: NEG
43785: PUSH
43786: EMPTY
43787: LIST
43788: LIST
43789: PUSH
43790: LD_INT 1
43792: NEG
43793: PUSH
43794: LD_INT 1
43796: PUSH
43797: EMPTY
43798: LIST
43799: LIST
43800: PUSH
43801: LD_INT 2
43803: NEG
43804: PUSH
43805: LD_INT 0
43807: PUSH
43808: EMPTY
43809: LIST
43810: LIST
43811: PUSH
43812: LD_INT 2
43814: NEG
43815: PUSH
43816: LD_INT 1
43818: NEG
43819: PUSH
43820: EMPTY
43821: LIST
43822: LIST
43823: PUSH
43824: LD_INT 2
43826: NEG
43827: PUSH
43828: LD_INT 2
43830: NEG
43831: PUSH
43832: EMPTY
43833: LIST
43834: LIST
43835: PUSH
43836: EMPTY
43837: LIST
43838: LIST
43839: LIST
43840: LIST
43841: LIST
43842: LIST
43843: LIST
43844: LIST
43845: LIST
43846: LIST
43847: LIST
43848: LIST
43849: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
43850: LD_ADDR_VAR 0 53
43854: PUSH
43855: LD_INT 0
43857: PUSH
43858: LD_INT 0
43860: PUSH
43861: EMPTY
43862: LIST
43863: LIST
43864: PUSH
43865: LD_INT 0
43867: PUSH
43868: LD_INT 1
43870: NEG
43871: PUSH
43872: EMPTY
43873: LIST
43874: LIST
43875: PUSH
43876: LD_INT 1
43878: PUSH
43879: LD_INT 0
43881: PUSH
43882: EMPTY
43883: LIST
43884: LIST
43885: PUSH
43886: LD_INT 1
43888: PUSH
43889: LD_INT 1
43891: PUSH
43892: EMPTY
43893: LIST
43894: LIST
43895: PUSH
43896: LD_INT 0
43898: PUSH
43899: LD_INT 1
43901: PUSH
43902: EMPTY
43903: LIST
43904: LIST
43905: PUSH
43906: LD_INT 1
43908: NEG
43909: PUSH
43910: LD_INT 0
43912: PUSH
43913: EMPTY
43914: LIST
43915: LIST
43916: PUSH
43917: LD_INT 1
43919: NEG
43920: PUSH
43921: LD_INT 1
43923: NEG
43924: PUSH
43925: EMPTY
43926: LIST
43927: LIST
43928: PUSH
43929: LD_INT 1
43931: NEG
43932: PUSH
43933: LD_INT 2
43935: NEG
43936: PUSH
43937: EMPTY
43938: LIST
43939: LIST
43940: PUSH
43941: LD_INT 0
43943: PUSH
43944: LD_INT 2
43946: NEG
43947: PUSH
43948: EMPTY
43949: LIST
43950: LIST
43951: PUSH
43952: LD_INT 1
43954: PUSH
43955: LD_INT 1
43957: NEG
43958: PUSH
43959: EMPTY
43960: LIST
43961: LIST
43962: PUSH
43963: LD_INT 2
43965: PUSH
43966: LD_INT 0
43968: PUSH
43969: EMPTY
43970: LIST
43971: LIST
43972: PUSH
43973: LD_INT 2
43975: PUSH
43976: LD_INT 1
43978: PUSH
43979: EMPTY
43980: LIST
43981: LIST
43982: PUSH
43983: LD_INT 2
43985: PUSH
43986: LD_INT 2
43988: PUSH
43989: EMPTY
43990: LIST
43991: LIST
43992: PUSH
43993: LD_INT 1
43995: PUSH
43996: LD_INT 2
43998: PUSH
43999: EMPTY
44000: LIST
44001: LIST
44002: PUSH
44003: LD_INT 0
44005: PUSH
44006: LD_INT 2
44008: PUSH
44009: EMPTY
44010: LIST
44011: LIST
44012: PUSH
44013: LD_INT 1
44015: NEG
44016: PUSH
44017: LD_INT 1
44019: PUSH
44020: EMPTY
44021: LIST
44022: LIST
44023: PUSH
44024: LD_INT 2
44026: NEG
44027: PUSH
44028: LD_INT 0
44030: PUSH
44031: EMPTY
44032: LIST
44033: LIST
44034: PUSH
44035: LD_INT 2
44037: NEG
44038: PUSH
44039: LD_INT 1
44041: NEG
44042: PUSH
44043: EMPTY
44044: LIST
44045: LIST
44046: PUSH
44047: LD_INT 2
44049: NEG
44050: PUSH
44051: LD_INT 2
44053: NEG
44054: PUSH
44055: EMPTY
44056: LIST
44057: LIST
44058: PUSH
44059: EMPTY
44060: LIST
44061: LIST
44062: LIST
44063: LIST
44064: LIST
44065: LIST
44066: LIST
44067: LIST
44068: LIST
44069: LIST
44070: LIST
44071: LIST
44072: LIST
44073: LIST
44074: LIST
44075: LIST
44076: LIST
44077: LIST
44078: LIST
44079: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
44080: LD_ADDR_VAR 0 54
44084: PUSH
44085: LD_INT 0
44087: PUSH
44088: LD_INT 0
44090: PUSH
44091: EMPTY
44092: LIST
44093: LIST
44094: PUSH
44095: LD_INT 0
44097: PUSH
44098: LD_INT 1
44100: NEG
44101: PUSH
44102: EMPTY
44103: LIST
44104: LIST
44105: PUSH
44106: LD_INT 1
44108: PUSH
44109: LD_INT 0
44111: PUSH
44112: EMPTY
44113: LIST
44114: LIST
44115: PUSH
44116: LD_INT 1
44118: PUSH
44119: LD_INT 1
44121: PUSH
44122: EMPTY
44123: LIST
44124: LIST
44125: PUSH
44126: LD_INT 0
44128: PUSH
44129: LD_INT 1
44131: PUSH
44132: EMPTY
44133: LIST
44134: LIST
44135: PUSH
44136: LD_INT 1
44138: NEG
44139: PUSH
44140: LD_INT 0
44142: PUSH
44143: EMPTY
44144: LIST
44145: LIST
44146: PUSH
44147: LD_INT 1
44149: NEG
44150: PUSH
44151: LD_INT 1
44153: NEG
44154: PUSH
44155: EMPTY
44156: LIST
44157: LIST
44158: PUSH
44159: LD_INT 1
44161: NEG
44162: PUSH
44163: LD_INT 2
44165: NEG
44166: PUSH
44167: EMPTY
44168: LIST
44169: LIST
44170: PUSH
44171: LD_INT 0
44173: PUSH
44174: LD_INT 2
44176: NEG
44177: PUSH
44178: EMPTY
44179: LIST
44180: LIST
44181: PUSH
44182: LD_INT 1
44184: PUSH
44185: LD_INT 1
44187: NEG
44188: PUSH
44189: EMPTY
44190: LIST
44191: LIST
44192: PUSH
44193: LD_INT 2
44195: PUSH
44196: LD_INT 0
44198: PUSH
44199: EMPTY
44200: LIST
44201: LIST
44202: PUSH
44203: LD_INT 2
44205: PUSH
44206: LD_INT 1
44208: PUSH
44209: EMPTY
44210: LIST
44211: LIST
44212: PUSH
44213: LD_INT 2
44215: PUSH
44216: LD_INT 2
44218: PUSH
44219: EMPTY
44220: LIST
44221: LIST
44222: PUSH
44223: LD_INT 1
44225: PUSH
44226: LD_INT 2
44228: PUSH
44229: EMPTY
44230: LIST
44231: LIST
44232: PUSH
44233: LD_INT 0
44235: PUSH
44236: LD_INT 2
44238: PUSH
44239: EMPTY
44240: LIST
44241: LIST
44242: PUSH
44243: LD_INT 1
44245: NEG
44246: PUSH
44247: LD_INT 1
44249: PUSH
44250: EMPTY
44251: LIST
44252: LIST
44253: PUSH
44254: LD_INT 2
44256: NEG
44257: PUSH
44258: LD_INT 0
44260: PUSH
44261: EMPTY
44262: LIST
44263: LIST
44264: PUSH
44265: LD_INT 2
44267: NEG
44268: PUSH
44269: LD_INT 1
44271: NEG
44272: PUSH
44273: EMPTY
44274: LIST
44275: LIST
44276: PUSH
44277: LD_INT 2
44279: NEG
44280: PUSH
44281: LD_INT 2
44283: NEG
44284: PUSH
44285: EMPTY
44286: LIST
44287: LIST
44288: PUSH
44289: EMPTY
44290: LIST
44291: LIST
44292: LIST
44293: LIST
44294: LIST
44295: LIST
44296: LIST
44297: LIST
44298: LIST
44299: LIST
44300: LIST
44301: LIST
44302: LIST
44303: LIST
44304: LIST
44305: LIST
44306: LIST
44307: LIST
44308: LIST
44309: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
44310: LD_ADDR_VAR 0 55
44314: PUSH
44315: LD_INT 0
44317: PUSH
44318: LD_INT 0
44320: PUSH
44321: EMPTY
44322: LIST
44323: LIST
44324: PUSH
44325: LD_INT 0
44327: PUSH
44328: LD_INT 1
44330: NEG
44331: PUSH
44332: EMPTY
44333: LIST
44334: LIST
44335: PUSH
44336: LD_INT 1
44338: PUSH
44339: LD_INT 0
44341: PUSH
44342: EMPTY
44343: LIST
44344: LIST
44345: PUSH
44346: LD_INT 1
44348: PUSH
44349: LD_INT 1
44351: PUSH
44352: EMPTY
44353: LIST
44354: LIST
44355: PUSH
44356: LD_INT 0
44358: PUSH
44359: LD_INT 1
44361: PUSH
44362: EMPTY
44363: LIST
44364: LIST
44365: PUSH
44366: LD_INT 1
44368: NEG
44369: PUSH
44370: LD_INT 0
44372: PUSH
44373: EMPTY
44374: LIST
44375: LIST
44376: PUSH
44377: LD_INT 1
44379: NEG
44380: PUSH
44381: LD_INT 1
44383: NEG
44384: PUSH
44385: EMPTY
44386: LIST
44387: LIST
44388: PUSH
44389: LD_INT 1
44391: NEG
44392: PUSH
44393: LD_INT 2
44395: NEG
44396: PUSH
44397: EMPTY
44398: LIST
44399: LIST
44400: PUSH
44401: LD_INT 0
44403: PUSH
44404: LD_INT 2
44406: NEG
44407: PUSH
44408: EMPTY
44409: LIST
44410: LIST
44411: PUSH
44412: LD_INT 1
44414: PUSH
44415: LD_INT 1
44417: NEG
44418: PUSH
44419: EMPTY
44420: LIST
44421: LIST
44422: PUSH
44423: LD_INT 2
44425: PUSH
44426: LD_INT 0
44428: PUSH
44429: EMPTY
44430: LIST
44431: LIST
44432: PUSH
44433: LD_INT 2
44435: PUSH
44436: LD_INT 1
44438: PUSH
44439: EMPTY
44440: LIST
44441: LIST
44442: PUSH
44443: LD_INT 2
44445: PUSH
44446: LD_INT 2
44448: PUSH
44449: EMPTY
44450: LIST
44451: LIST
44452: PUSH
44453: LD_INT 1
44455: PUSH
44456: LD_INT 2
44458: PUSH
44459: EMPTY
44460: LIST
44461: LIST
44462: PUSH
44463: LD_INT 0
44465: PUSH
44466: LD_INT 2
44468: PUSH
44469: EMPTY
44470: LIST
44471: LIST
44472: PUSH
44473: LD_INT 1
44475: NEG
44476: PUSH
44477: LD_INT 1
44479: PUSH
44480: EMPTY
44481: LIST
44482: LIST
44483: PUSH
44484: LD_INT 2
44486: NEG
44487: PUSH
44488: LD_INT 0
44490: PUSH
44491: EMPTY
44492: LIST
44493: LIST
44494: PUSH
44495: LD_INT 2
44497: NEG
44498: PUSH
44499: LD_INT 1
44501: NEG
44502: PUSH
44503: EMPTY
44504: LIST
44505: LIST
44506: PUSH
44507: LD_INT 2
44509: NEG
44510: PUSH
44511: LD_INT 2
44513: NEG
44514: PUSH
44515: EMPTY
44516: LIST
44517: LIST
44518: PUSH
44519: EMPTY
44520: LIST
44521: LIST
44522: LIST
44523: LIST
44524: LIST
44525: LIST
44526: LIST
44527: LIST
44528: LIST
44529: LIST
44530: LIST
44531: LIST
44532: LIST
44533: LIST
44534: LIST
44535: LIST
44536: LIST
44537: LIST
44538: LIST
44539: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
44540: LD_ADDR_VAR 0 56
44544: PUSH
44545: LD_INT 0
44547: PUSH
44548: LD_INT 0
44550: PUSH
44551: EMPTY
44552: LIST
44553: LIST
44554: PUSH
44555: LD_INT 0
44557: PUSH
44558: LD_INT 1
44560: NEG
44561: PUSH
44562: EMPTY
44563: LIST
44564: LIST
44565: PUSH
44566: LD_INT 1
44568: PUSH
44569: LD_INT 0
44571: PUSH
44572: EMPTY
44573: LIST
44574: LIST
44575: PUSH
44576: LD_INT 1
44578: PUSH
44579: LD_INT 1
44581: PUSH
44582: EMPTY
44583: LIST
44584: LIST
44585: PUSH
44586: LD_INT 0
44588: PUSH
44589: LD_INT 1
44591: PUSH
44592: EMPTY
44593: LIST
44594: LIST
44595: PUSH
44596: LD_INT 1
44598: NEG
44599: PUSH
44600: LD_INT 0
44602: PUSH
44603: EMPTY
44604: LIST
44605: LIST
44606: PUSH
44607: LD_INT 1
44609: NEG
44610: PUSH
44611: LD_INT 1
44613: NEG
44614: PUSH
44615: EMPTY
44616: LIST
44617: LIST
44618: PUSH
44619: LD_INT 1
44621: NEG
44622: PUSH
44623: LD_INT 2
44625: NEG
44626: PUSH
44627: EMPTY
44628: LIST
44629: LIST
44630: PUSH
44631: LD_INT 0
44633: PUSH
44634: LD_INT 2
44636: NEG
44637: PUSH
44638: EMPTY
44639: LIST
44640: LIST
44641: PUSH
44642: LD_INT 1
44644: PUSH
44645: LD_INT 1
44647: NEG
44648: PUSH
44649: EMPTY
44650: LIST
44651: LIST
44652: PUSH
44653: LD_INT 2
44655: PUSH
44656: LD_INT 0
44658: PUSH
44659: EMPTY
44660: LIST
44661: LIST
44662: PUSH
44663: LD_INT 2
44665: PUSH
44666: LD_INT 1
44668: PUSH
44669: EMPTY
44670: LIST
44671: LIST
44672: PUSH
44673: LD_INT 2
44675: PUSH
44676: LD_INT 2
44678: PUSH
44679: EMPTY
44680: LIST
44681: LIST
44682: PUSH
44683: LD_INT 1
44685: PUSH
44686: LD_INT 2
44688: PUSH
44689: EMPTY
44690: LIST
44691: LIST
44692: PUSH
44693: LD_INT 0
44695: PUSH
44696: LD_INT 2
44698: PUSH
44699: EMPTY
44700: LIST
44701: LIST
44702: PUSH
44703: LD_INT 1
44705: NEG
44706: PUSH
44707: LD_INT 1
44709: PUSH
44710: EMPTY
44711: LIST
44712: LIST
44713: PUSH
44714: LD_INT 2
44716: NEG
44717: PUSH
44718: LD_INT 0
44720: PUSH
44721: EMPTY
44722: LIST
44723: LIST
44724: PUSH
44725: LD_INT 2
44727: NEG
44728: PUSH
44729: LD_INT 1
44731: NEG
44732: PUSH
44733: EMPTY
44734: LIST
44735: LIST
44736: PUSH
44737: LD_INT 2
44739: NEG
44740: PUSH
44741: LD_INT 2
44743: NEG
44744: PUSH
44745: EMPTY
44746: LIST
44747: LIST
44748: PUSH
44749: EMPTY
44750: LIST
44751: LIST
44752: LIST
44753: LIST
44754: LIST
44755: LIST
44756: LIST
44757: LIST
44758: LIST
44759: LIST
44760: LIST
44761: LIST
44762: LIST
44763: LIST
44764: LIST
44765: LIST
44766: LIST
44767: LIST
44768: LIST
44769: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
44770: LD_ADDR_VAR 0 57
44774: PUSH
44775: LD_INT 0
44777: PUSH
44778: LD_INT 0
44780: PUSH
44781: EMPTY
44782: LIST
44783: LIST
44784: PUSH
44785: LD_INT 0
44787: PUSH
44788: LD_INT 1
44790: NEG
44791: PUSH
44792: EMPTY
44793: LIST
44794: LIST
44795: PUSH
44796: LD_INT 1
44798: PUSH
44799: LD_INT 0
44801: PUSH
44802: EMPTY
44803: LIST
44804: LIST
44805: PUSH
44806: LD_INT 1
44808: PUSH
44809: LD_INT 1
44811: PUSH
44812: EMPTY
44813: LIST
44814: LIST
44815: PUSH
44816: LD_INT 0
44818: PUSH
44819: LD_INT 1
44821: PUSH
44822: EMPTY
44823: LIST
44824: LIST
44825: PUSH
44826: LD_INT 1
44828: NEG
44829: PUSH
44830: LD_INT 0
44832: PUSH
44833: EMPTY
44834: LIST
44835: LIST
44836: PUSH
44837: LD_INT 1
44839: NEG
44840: PUSH
44841: LD_INT 1
44843: NEG
44844: PUSH
44845: EMPTY
44846: LIST
44847: LIST
44848: PUSH
44849: LD_INT 1
44851: NEG
44852: PUSH
44853: LD_INT 2
44855: NEG
44856: PUSH
44857: EMPTY
44858: LIST
44859: LIST
44860: PUSH
44861: LD_INT 0
44863: PUSH
44864: LD_INT 2
44866: NEG
44867: PUSH
44868: EMPTY
44869: LIST
44870: LIST
44871: PUSH
44872: LD_INT 1
44874: PUSH
44875: LD_INT 1
44877: NEG
44878: PUSH
44879: EMPTY
44880: LIST
44881: LIST
44882: PUSH
44883: LD_INT 2
44885: PUSH
44886: LD_INT 0
44888: PUSH
44889: EMPTY
44890: LIST
44891: LIST
44892: PUSH
44893: LD_INT 2
44895: PUSH
44896: LD_INT 1
44898: PUSH
44899: EMPTY
44900: LIST
44901: LIST
44902: PUSH
44903: LD_INT 2
44905: PUSH
44906: LD_INT 2
44908: PUSH
44909: EMPTY
44910: LIST
44911: LIST
44912: PUSH
44913: LD_INT 1
44915: PUSH
44916: LD_INT 2
44918: PUSH
44919: EMPTY
44920: LIST
44921: LIST
44922: PUSH
44923: LD_INT 0
44925: PUSH
44926: LD_INT 2
44928: PUSH
44929: EMPTY
44930: LIST
44931: LIST
44932: PUSH
44933: LD_INT 1
44935: NEG
44936: PUSH
44937: LD_INT 1
44939: PUSH
44940: EMPTY
44941: LIST
44942: LIST
44943: PUSH
44944: LD_INT 2
44946: NEG
44947: PUSH
44948: LD_INT 0
44950: PUSH
44951: EMPTY
44952: LIST
44953: LIST
44954: PUSH
44955: LD_INT 2
44957: NEG
44958: PUSH
44959: LD_INT 1
44961: NEG
44962: PUSH
44963: EMPTY
44964: LIST
44965: LIST
44966: PUSH
44967: LD_INT 2
44969: NEG
44970: PUSH
44971: LD_INT 2
44973: NEG
44974: PUSH
44975: EMPTY
44976: LIST
44977: LIST
44978: PUSH
44979: EMPTY
44980: LIST
44981: LIST
44982: LIST
44983: LIST
44984: LIST
44985: LIST
44986: LIST
44987: LIST
44988: LIST
44989: LIST
44990: LIST
44991: LIST
44992: LIST
44993: LIST
44994: LIST
44995: LIST
44996: LIST
44997: LIST
44998: LIST
44999: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
45000: LD_ADDR_VAR 0 58
45004: PUSH
45005: LD_INT 0
45007: PUSH
45008: LD_INT 0
45010: PUSH
45011: EMPTY
45012: LIST
45013: LIST
45014: PUSH
45015: LD_INT 0
45017: PUSH
45018: LD_INT 1
45020: NEG
45021: PUSH
45022: EMPTY
45023: LIST
45024: LIST
45025: PUSH
45026: LD_INT 1
45028: PUSH
45029: LD_INT 0
45031: PUSH
45032: EMPTY
45033: LIST
45034: LIST
45035: PUSH
45036: LD_INT 1
45038: PUSH
45039: LD_INT 1
45041: PUSH
45042: EMPTY
45043: LIST
45044: LIST
45045: PUSH
45046: LD_INT 0
45048: PUSH
45049: LD_INT 1
45051: PUSH
45052: EMPTY
45053: LIST
45054: LIST
45055: PUSH
45056: LD_INT 1
45058: NEG
45059: PUSH
45060: LD_INT 0
45062: PUSH
45063: EMPTY
45064: LIST
45065: LIST
45066: PUSH
45067: LD_INT 1
45069: NEG
45070: PUSH
45071: LD_INT 1
45073: NEG
45074: PUSH
45075: EMPTY
45076: LIST
45077: LIST
45078: PUSH
45079: LD_INT 1
45081: NEG
45082: PUSH
45083: LD_INT 2
45085: NEG
45086: PUSH
45087: EMPTY
45088: LIST
45089: LIST
45090: PUSH
45091: LD_INT 0
45093: PUSH
45094: LD_INT 2
45096: NEG
45097: PUSH
45098: EMPTY
45099: LIST
45100: LIST
45101: PUSH
45102: LD_INT 1
45104: PUSH
45105: LD_INT 1
45107: NEG
45108: PUSH
45109: EMPTY
45110: LIST
45111: LIST
45112: PUSH
45113: LD_INT 2
45115: PUSH
45116: LD_INT 0
45118: PUSH
45119: EMPTY
45120: LIST
45121: LIST
45122: PUSH
45123: LD_INT 2
45125: PUSH
45126: LD_INT 1
45128: PUSH
45129: EMPTY
45130: LIST
45131: LIST
45132: PUSH
45133: LD_INT 2
45135: PUSH
45136: LD_INT 2
45138: PUSH
45139: EMPTY
45140: LIST
45141: LIST
45142: PUSH
45143: LD_INT 1
45145: PUSH
45146: LD_INT 2
45148: PUSH
45149: EMPTY
45150: LIST
45151: LIST
45152: PUSH
45153: LD_INT 0
45155: PUSH
45156: LD_INT 2
45158: PUSH
45159: EMPTY
45160: LIST
45161: LIST
45162: PUSH
45163: LD_INT 1
45165: NEG
45166: PUSH
45167: LD_INT 1
45169: PUSH
45170: EMPTY
45171: LIST
45172: LIST
45173: PUSH
45174: LD_INT 2
45176: NEG
45177: PUSH
45178: LD_INT 0
45180: PUSH
45181: EMPTY
45182: LIST
45183: LIST
45184: PUSH
45185: LD_INT 2
45187: NEG
45188: PUSH
45189: LD_INT 1
45191: NEG
45192: PUSH
45193: EMPTY
45194: LIST
45195: LIST
45196: PUSH
45197: LD_INT 2
45199: NEG
45200: PUSH
45201: LD_INT 2
45203: NEG
45204: PUSH
45205: EMPTY
45206: LIST
45207: LIST
45208: PUSH
45209: EMPTY
45210: LIST
45211: LIST
45212: LIST
45213: LIST
45214: LIST
45215: LIST
45216: LIST
45217: LIST
45218: LIST
45219: LIST
45220: LIST
45221: LIST
45222: LIST
45223: LIST
45224: LIST
45225: LIST
45226: LIST
45227: LIST
45228: LIST
45229: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
45230: LD_ADDR_VAR 0 59
45234: PUSH
45235: LD_INT 0
45237: PUSH
45238: LD_INT 0
45240: PUSH
45241: EMPTY
45242: LIST
45243: LIST
45244: PUSH
45245: LD_INT 0
45247: PUSH
45248: LD_INT 1
45250: NEG
45251: PUSH
45252: EMPTY
45253: LIST
45254: LIST
45255: PUSH
45256: LD_INT 1
45258: PUSH
45259: LD_INT 0
45261: PUSH
45262: EMPTY
45263: LIST
45264: LIST
45265: PUSH
45266: LD_INT 1
45268: PUSH
45269: LD_INT 1
45271: PUSH
45272: EMPTY
45273: LIST
45274: LIST
45275: PUSH
45276: LD_INT 0
45278: PUSH
45279: LD_INT 1
45281: PUSH
45282: EMPTY
45283: LIST
45284: LIST
45285: PUSH
45286: LD_INT 1
45288: NEG
45289: PUSH
45290: LD_INT 0
45292: PUSH
45293: EMPTY
45294: LIST
45295: LIST
45296: PUSH
45297: LD_INT 1
45299: NEG
45300: PUSH
45301: LD_INT 1
45303: NEG
45304: PUSH
45305: EMPTY
45306: LIST
45307: LIST
45308: PUSH
45309: EMPTY
45310: LIST
45311: LIST
45312: LIST
45313: LIST
45314: LIST
45315: LIST
45316: LIST
45317: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
45318: LD_ADDR_VAR 0 60
45322: PUSH
45323: LD_INT 0
45325: PUSH
45326: LD_INT 0
45328: PUSH
45329: EMPTY
45330: LIST
45331: LIST
45332: PUSH
45333: LD_INT 0
45335: PUSH
45336: LD_INT 1
45338: NEG
45339: PUSH
45340: EMPTY
45341: LIST
45342: LIST
45343: PUSH
45344: LD_INT 1
45346: PUSH
45347: LD_INT 0
45349: PUSH
45350: EMPTY
45351: LIST
45352: LIST
45353: PUSH
45354: LD_INT 1
45356: PUSH
45357: LD_INT 1
45359: PUSH
45360: EMPTY
45361: LIST
45362: LIST
45363: PUSH
45364: LD_INT 0
45366: PUSH
45367: LD_INT 1
45369: PUSH
45370: EMPTY
45371: LIST
45372: LIST
45373: PUSH
45374: LD_INT 1
45376: NEG
45377: PUSH
45378: LD_INT 0
45380: PUSH
45381: EMPTY
45382: LIST
45383: LIST
45384: PUSH
45385: LD_INT 1
45387: NEG
45388: PUSH
45389: LD_INT 1
45391: NEG
45392: PUSH
45393: EMPTY
45394: LIST
45395: LIST
45396: PUSH
45397: EMPTY
45398: LIST
45399: LIST
45400: LIST
45401: LIST
45402: LIST
45403: LIST
45404: LIST
45405: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
45406: LD_ADDR_VAR 0 61
45410: PUSH
45411: LD_INT 0
45413: PUSH
45414: LD_INT 0
45416: PUSH
45417: EMPTY
45418: LIST
45419: LIST
45420: PUSH
45421: LD_INT 0
45423: PUSH
45424: LD_INT 1
45426: NEG
45427: PUSH
45428: EMPTY
45429: LIST
45430: LIST
45431: PUSH
45432: LD_INT 1
45434: PUSH
45435: LD_INT 0
45437: PUSH
45438: EMPTY
45439: LIST
45440: LIST
45441: PUSH
45442: LD_INT 1
45444: PUSH
45445: LD_INT 1
45447: PUSH
45448: EMPTY
45449: LIST
45450: LIST
45451: PUSH
45452: LD_INT 0
45454: PUSH
45455: LD_INT 1
45457: PUSH
45458: EMPTY
45459: LIST
45460: LIST
45461: PUSH
45462: LD_INT 1
45464: NEG
45465: PUSH
45466: LD_INT 0
45468: PUSH
45469: EMPTY
45470: LIST
45471: LIST
45472: PUSH
45473: LD_INT 1
45475: NEG
45476: PUSH
45477: LD_INT 1
45479: NEG
45480: PUSH
45481: EMPTY
45482: LIST
45483: LIST
45484: PUSH
45485: EMPTY
45486: LIST
45487: LIST
45488: LIST
45489: LIST
45490: LIST
45491: LIST
45492: LIST
45493: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
45494: LD_ADDR_VAR 0 62
45498: PUSH
45499: LD_INT 0
45501: PUSH
45502: LD_INT 0
45504: PUSH
45505: EMPTY
45506: LIST
45507: LIST
45508: PUSH
45509: LD_INT 0
45511: PUSH
45512: LD_INT 1
45514: NEG
45515: PUSH
45516: EMPTY
45517: LIST
45518: LIST
45519: PUSH
45520: LD_INT 1
45522: PUSH
45523: LD_INT 0
45525: PUSH
45526: EMPTY
45527: LIST
45528: LIST
45529: PUSH
45530: LD_INT 1
45532: PUSH
45533: LD_INT 1
45535: PUSH
45536: EMPTY
45537: LIST
45538: LIST
45539: PUSH
45540: LD_INT 0
45542: PUSH
45543: LD_INT 1
45545: PUSH
45546: EMPTY
45547: LIST
45548: LIST
45549: PUSH
45550: LD_INT 1
45552: NEG
45553: PUSH
45554: LD_INT 0
45556: PUSH
45557: EMPTY
45558: LIST
45559: LIST
45560: PUSH
45561: LD_INT 1
45563: NEG
45564: PUSH
45565: LD_INT 1
45567: NEG
45568: PUSH
45569: EMPTY
45570: LIST
45571: LIST
45572: PUSH
45573: EMPTY
45574: LIST
45575: LIST
45576: LIST
45577: LIST
45578: LIST
45579: LIST
45580: LIST
45581: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
45582: LD_ADDR_VAR 0 63
45586: PUSH
45587: LD_INT 0
45589: PUSH
45590: LD_INT 0
45592: PUSH
45593: EMPTY
45594: LIST
45595: LIST
45596: PUSH
45597: LD_INT 0
45599: PUSH
45600: LD_INT 1
45602: NEG
45603: PUSH
45604: EMPTY
45605: LIST
45606: LIST
45607: PUSH
45608: LD_INT 1
45610: PUSH
45611: LD_INT 0
45613: PUSH
45614: EMPTY
45615: LIST
45616: LIST
45617: PUSH
45618: LD_INT 1
45620: PUSH
45621: LD_INT 1
45623: PUSH
45624: EMPTY
45625: LIST
45626: LIST
45627: PUSH
45628: LD_INT 0
45630: PUSH
45631: LD_INT 1
45633: PUSH
45634: EMPTY
45635: LIST
45636: LIST
45637: PUSH
45638: LD_INT 1
45640: NEG
45641: PUSH
45642: LD_INT 0
45644: PUSH
45645: EMPTY
45646: LIST
45647: LIST
45648: PUSH
45649: LD_INT 1
45651: NEG
45652: PUSH
45653: LD_INT 1
45655: NEG
45656: PUSH
45657: EMPTY
45658: LIST
45659: LIST
45660: PUSH
45661: EMPTY
45662: LIST
45663: LIST
45664: LIST
45665: LIST
45666: LIST
45667: LIST
45668: LIST
45669: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
45670: LD_ADDR_VAR 0 64
45674: PUSH
45675: LD_INT 0
45677: PUSH
45678: LD_INT 0
45680: PUSH
45681: EMPTY
45682: LIST
45683: LIST
45684: PUSH
45685: LD_INT 0
45687: PUSH
45688: LD_INT 1
45690: NEG
45691: PUSH
45692: EMPTY
45693: LIST
45694: LIST
45695: PUSH
45696: LD_INT 1
45698: PUSH
45699: LD_INT 0
45701: PUSH
45702: EMPTY
45703: LIST
45704: LIST
45705: PUSH
45706: LD_INT 1
45708: PUSH
45709: LD_INT 1
45711: PUSH
45712: EMPTY
45713: LIST
45714: LIST
45715: PUSH
45716: LD_INT 0
45718: PUSH
45719: LD_INT 1
45721: PUSH
45722: EMPTY
45723: LIST
45724: LIST
45725: PUSH
45726: LD_INT 1
45728: NEG
45729: PUSH
45730: LD_INT 0
45732: PUSH
45733: EMPTY
45734: LIST
45735: LIST
45736: PUSH
45737: LD_INT 1
45739: NEG
45740: PUSH
45741: LD_INT 1
45743: NEG
45744: PUSH
45745: EMPTY
45746: LIST
45747: LIST
45748: PUSH
45749: EMPTY
45750: LIST
45751: LIST
45752: LIST
45753: LIST
45754: LIST
45755: LIST
45756: LIST
45757: ST_TO_ADDR
// end ; 1 :
45758: GO 51655
45760: LD_INT 1
45762: DOUBLE
45763: EQUAL
45764: IFTRUE 45768
45766: GO 48391
45768: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
45769: LD_ADDR_VAR 0 11
45773: PUSH
45774: LD_INT 1
45776: NEG
45777: PUSH
45778: LD_INT 3
45780: NEG
45781: PUSH
45782: EMPTY
45783: LIST
45784: LIST
45785: PUSH
45786: LD_INT 0
45788: PUSH
45789: LD_INT 3
45791: NEG
45792: PUSH
45793: EMPTY
45794: LIST
45795: LIST
45796: PUSH
45797: LD_INT 1
45799: PUSH
45800: LD_INT 2
45802: NEG
45803: PUSH
45804: EMPTY
45805: LIST
45806: LIST
45807: PUSH
45808: EMPTY
45809: LIST
45810: LIST
45811: LIST
45812: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
45813: LD_ADDR_VAR 0 12
45817: PUSH
45818: LD_INT 2
45820: PUSH
45821: LD_INT 1
45823: NEG
45824: PUSH
45825: EMPTY
45826: LIST
45827: LIST
45828: PUSH
45829: LD_INT 3
45831: PUSH
45832: LD_INT 0
45834: PUSH
45835: EMPTY
45836: LIST
45837: LIST
45838: PUSH
45839: LD_INT 3
45841: PUSH
45842: LD_INT 1
45844: PUSH
45845: EMPTY
45846: LIST
45847: LIST
45848: PUSH
45849: EMPTY
45850: LIST
45851: LIST
45852: LIST
45853: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
45854: LD_ADDR_VAR 0 13
45858: PUSH
45859: LD_INT 3
45861: PUSH
45862: LD_INT 2
45864: PUSH
45865: EMPTY
45866: LIST
45867: LIST
45868: PUSH
45869: LD_INT 3
45871: PUSH
45872: LD_INT 3
45874: PUSH
45875: EMPTY
45876: LIST
45877: LIST
45878: PUSH
45879: LD_INT 2
45881: PUSH
45882: LD_INT 3
45884: PUSH
45885: EMPTY
45886: LIST
45887: LIST
45888: PUSH
45889: EMPTY
45890: LIST
45891: LIST
45892: LIST
45893: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
45894: LD_ADDR_VAR 0 14
45898: PUSH
45899: LD_INT 1
45901: PUSH
45902: LD_INT 3
45904: PUSH
45905: EMPTY
45906: LIST
45907: LIST
45908: PUSH
45909: LD_INT 0
45911: PUSH
45912: LD_INT 3
45914: PUSH
45915: EMPTY
45916: LIST
45917: LIST
45918: PUSH
45919: LD_INT 1
45921: NEG
45922: PUSH
45923: LD_INT 2
45925: PUSH
45926: EMPTY
45927: LIST
45928: LIST
45929: PUSH
45930: EMPTY
45931: LIST
45932: LIST
45933: LIST
45934: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
45935: LD_ADDR_VAR 0 15
45939: PUSH
45940: LD_INT 2
45942: NEG
45943: PUSH
45944: LD_INT 1
45946: PUSH
45947: EMPTY
45948: LIST
45949: LIST
45950: PUSH
45951: LD_INT 3
45953: NEG
45954: PUSH
45955: LD_INT 0
45957: PUSH
45958: EMPTY
45959: LIST
45960: LIST
45961: PUSH
45962: LD_INT 3
45964: NEG
45965: PUSH
45966: LD_INT 1
45968: NEG
45969: PUSH
45970: EMPTY
45971: LIST
45972: LIST
45973: PUSH
45974: EMPTY
45975: LIST
45976: LIST
45977: LIST
45978: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
45979: LD_ADDR_VAR 0 16
45983: PUSH
45984: LD_INT 2
45986: NEG
45987: PUSH
45988: LD_INT 3
45990: NEG
45991: PUSH
45992: EMPTY
45993: LIST
45994: LIST
45995: PUSH
45996: LD_INT 3
45998: NEG
45999: PUSH
46000: LD_INT 2
46002: NEG
46003: PUSH
46004: EMPTY
46005: LIST
46006: LIST
46007: PUSH
46008: LD_INT 3
46010: NEG
46011: PUSH
46012: LD_INT 3
46014: NEG
46015: PUSH
46016: EMPTY
46017: LIST
46018: LIST
46019: PUSH
46020: EMPTY
46021: LIST
46022: LIST
46023: LIST
46024: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
46025: LD_ADDR_VAR 0 17
46029: PUSH
46030: LD_INT 1
46032: NEG
46033: PUSH
46034: LD_INT 3
46036: NEG
46037: PUSH
46038: EMPTY
46039: LIST
46040: LIST
46041: PUSH
46042: LD_INT 0
46044: PUSH
46045: LD_INT 3
46047: NEG
46048: PUSH
46049: EMPTY
46050: LIST
46051: LIST
46052: PUSH
46053: LD_INT 1
46055: PUSH
46056: LD_INT 2
46058: NEG
46059: PUSH
46060: EMPTY
46061: LIST
46062: LIST
46063: PUSH
46064: EMPTY
46065: LIST
46066: LIST
46067: LIST
46068: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
46069: LD_ADDR_VAR 0 18
46073: PUSH
46074: LD_INT 2
46076: PUSH
46077: LD_INT 1
46079: NEG
46080: PUSH
46081: EMPTY
46082: LIST
46083: LIST
46084: PUSH
46085: LD_INT 3
46087: PUSH
46088: LD_INT 0
46090: PUSH
46091: EMPTY
46092: LIST
46093: LIST
46094: PUSH
46095: LD_INT 3
46097: PUSH
46098: LD_INT 1
46100: PUSH
46101: EMPTY
46102: LIST
46103: LIST
46104: PUSH
46105: EMPTY
46106: LIST
46107: LIST
46108: LIST
46109: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
46110: LD_ADDR_VAR 0 19
46114: PUSH
46115: LD_INT 3
46117: PUSH
46118: LD_INT 2
46120: PUSH
46121: EMPTY
46122: LIST
46123: LIST
46124: PUSH
46125: LD_INT 3
46127: PUSH
46128: LD_INT 3
46130: PUSH
46131: EMPTY
46132: LIST
46133: LIST
46134: PUSH
46135: LD_INT 2
46137: PUSH
46138: LD_INT 3
46140: PUSH
46141: EMPTY
46142: LIST
46143: LIST
46144: PUSH
46145: EMPTY
46146: LIST
46147: LIST
46148: LIST
46149: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
46150: LD_ADDR_VAR 0 20
46154: PUSH
46155: LD_INT 1
46157: PUSH
46158: LD_INT 3
46160: PUSH
46161: EMPTY
46162: LIST
46163: LIST
46164: PUSH
46165: LD_INT 0
46167: PUSH
46168: LD_INT 3
46170: PUSH
46171: EMPTY
46172: LIST
46173: LIST
46174: PUSH
46175: LD_INT 1
46177: NEG
46178: PUSH
46179: LD_INT 2
46181: PUSH
46182: EMPTY
46183: LIST
46184: LIST
46185: PUSH
46186: EMPTY
46187: LIST
46188: LIST
46189: LIST
46190: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
46191: LD_ADDR_VAR 0 21
46195: PUSH
46196: LD_INT 2
46198: NEG
46199: PUSH
46200: LD_INT 1
46202: PUSH
46203: EMPTY
46204: LIST
46205: LIST
46206: PUSH
46207: LD_INT 3
46209: NEG
46210: PUSH
46211: LD_INT 0
46213: PUSH
46214: EMPTY
46215: LIST
46216: LIST
46217: PUSH
46218: LD_INT 3
46220: NEG
46221: PUSH
46222: LD_INT 1
46224: NEG
46225: PUSH
46226: EMPTY
46227: LIST
46228: LIST
46229: PUSH
46230: EMPTY
46231: LIST
46232: LIST
46233: LIST
46234: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
46235: LD_ADDR_VAR 0 22
46239: PUSH
46240: LD_INT 2
46242: NEG
46243: PUSH
46244: LD_INT 3
46246: NEG
46247: PUSH
46248: EMPTY
46249: LIST
46250: LIST
46251: PUSH
46252: LD_INT 3
46254: NEG
46255: PUSH
46256: LD_INT 2
46258: NEG
46259: PUSH
46260: EMPTY
46261: LIST
46262: LIST
46263: PUSH
46264: LD_INT 3
46266: NEG
46267: PUSH
46268: LD_INT 3
46270: NEG
46271: PUSH
46272: EMPTY
46273: LIST
46274: LIST
46275: PUSH
46276: EMPTY
46277: LIST
46278: LIST
46279: LIST
46280: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
46281: LD_ADDR_VAR 0 23
46285: PUSH
46286: LD_INT 0
46288: PUSH
46289: LD_INT 3
46291: NEG
46292: PUSH
46293: EMPTY
46294: LIST
46295: LIST
46296: PUSH
46297: LD_INT 1
46299: NEG
46300: PUSH
46301: LD_INT 4
46303: NEG
46304: PUSH
46305: EMPTY
46306: LIST
46307: LIST
46308: PUSH
46309: LD_INT 1
46311: PUSH
46312: LD_INT 3
46314: NEG
46315: PUSH
46316: EMPTY
46317: LIST
46318: LIST
46319: PUSH
46320: EMPTY
46321: LIST
46322: LIST
46323: LIST
46324: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
46325: LD_ADDR_VAR 0 24
46329: PUSH
46330: LD_INT 3
46332: PUSH
46333: LD_INT 0
46335: PUSH
46336: EMPTY
46337: LIST
46338: LIST
46339: PUSH
46340: LD_INT 3
46342: PUSH
46343: LD_INT 1
46345: NEG
46346: PUSH
46347: EMPTY
46348: LIST
46349: LIST
46350: PUSH
46351: LD_INT 4
46353: PUSH
46354: LD_INT 1
46356: PUSH
46357: EMPTY
46358: LIST
46359: LIST
46360: PUSH
46361: EMPTY
46362: LIST
46363: LIST
46364: LIST
46365: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
46366: LD_ADDR_VAR 0 25
46370: PUSH
46371: LD_INT 3
46373: PUSH
46374: LD_INT 3
46376: PUSH
46377: EMPTY
46378: LIST
46379: LIST
46380: PUSH
46381: LD_INT 4
46383: PUSH
46384: LD_INT 3
46386: PUSH
46387: EMPTY
46388: LIST
46389: LIST
46390: PUSH
46391: LD_INT 3
46393: PUSH
46394: LD_INT 4
46396: PUSH
46397: EMPTY
46398: LIST
46399: LIST
46400: PUSH
46401: EMPTY
46402: LIST
46403: LIST
46404: LIST
46405: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
46406: LD_ADDR_VAR 0 26
46410: PUSH
46411: LD_INT 0
46413: PUSH
46414: LD_INT 3
46416: PUSH
46417: EMPTY
46418: LIST
46419: LIST
46420: PUSH
46421: LD_INT 1
46423: PUSH
46424: LD_INT 4
46426: PUSH
46427: EMPTY
46428: LIST
46429: LIST
46430: PUSH
46431: LD_INT 1
46433: NEG
46434: PUSH
46435: LD_INT 3
46437: PUSH
46438: EMPTY
46439: LIST
46440: LIST
46441: PUSH
46442: EMPTY
46443: LIST
46444: LIST
46445: LIST
46446: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
46447: LD_ADDR_VAR 0 27
46451: PUSH
46452: LD_INT 3
46454: NEG
46455: PUSH
46456: LD_INT 0
46458: PUSH
46459: EMPTY
46460: LIST
46461: LIST
46462: PUSH
46463: LD_INT 3
46465: NEG
46466: PUSH
46467: LD_INT 1
46469: PUSH
46470: EMPTY
46471: LIST
46472: LIST
46473: PUSH
46474: LD_INT 4
46476: NEG
46477: PUSH
46478: LD_INT 1
46480: NEG
46481: PUSH
46482: EMPTY
46483: LIST
46484: LIST
46485: PUSH
46486: EMPTY
46487: LIST
46488: LIST
46489: LIST
46490: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
46491: LD_ADDR_VAR 0 28
46495: PUSH
46496: LD_INT 3
46498: NEG
46499: PUSH
46500: LD_INT 3
46502: NEG
46503: PUSH
46504: EMPTY
46505: LIST
46506: LIST
46507: PUSH
46508: LD_INT 3
46510: NEG
46511: PUSH
46512: LD_INT 4
46514: NEG
46515: PUSH
46516: EMPTY
46517: LIST
46518: LIST
46519: PUSH
46520: LD_INT 4
46522: NEG
46523: PUSH
46524: LD_INT 3
46526: NEG
46527: PUSH
46528: EMPTY
46529: LIST
46530: LIST
46531: PUSH
46532: EMPTY
46533: LIST
46534: LIST
46535: LIST
46536: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
46537: LD_ADDR_VAR 0 29
46541: PUSH
46542: LD_INT 1
46544: NEG
46545: PUSH
46546: LD_INT 3
46548: NEG
46549: PUSH
46550: EMPTY
46551: LIST
46552: LIST
46553: PUSH
46554: LD_INT 0
46556: PUSH
46557: LD_INT 3
46559: NEG
46560: PUSH
46561: EMPTY
46562: LIST
46563: LIST
46564: PUSH
46565: LD_INT 1
46567: PUSH
46568: LD_INT 2
46570: NEG
46571: PUSH
46572: EMPTY
46573: LIST
46574: LIST
46575: PUSH
46576: LD_INT 1
46578: NEG
46579: PUSH
46580: LD_INT 4
46582: NEG
46583: PUSH
46584: EMPTY
46585: LIST
46586: LIST
46587: PUSH
46588: LD_INT 0
46590: PUSH
46591: LD_INT 4
46593: NEG
46594: PUSH
46595: EMPTY
46596: LIST
46597: LIST
46598: PUSH
46599: LD_INT 1
46601: PUSH
46602: LD_INT 3
46604: NEG
46605: PUSH
46606: EMPTY
46607: LIST
46608: LIST
46609: PUSH
46610: LD_INT 1
46612: NEG
46613: PUSH
46614: LD_INT 5
46616: NEG
46617: PUSH
46618: EMPTY
46619: LIST
46620: LIST
46621: PUSH
46622: LD_INT 0
46624: PUSH
46625: LD_INT 5
46627: NEG
46628: PUSH
46629: EMPTY
46630: LIST
46631: LIST
46632: PUSH
46633: LD_INT 1
46635: PUSH
46636: LD_INT 4
46638: NEG
46639: PUSH
46640: EMPTY
46641: LIST
46642: LIST
46643: PUSH
46644: LD_INT 1
46646: NEG
46647: PUSH
46648: LD_INT 6
46650: NEG
46651: PUSH
46652: EMPTY
46653: LIST
46654: LIST
46655: PUSH
46656: LD_INT 0
46658: PUSH
46659: LD_INT 6
46661: NEG
46662: PUSH
46663: EMPTY
46664: LIST
46665: LIST
46666: PUSH
46667: LD_INT 1
46669: PUSH
46670: LD_INT 5
46672: NEG
46673: PUSH
46674: EMPTY
46675: LIST
46676: LIST
46677: PUSH
46678: EMPTY
46679: LIST
46680: LIST
46681: LIST
46682: LIST
46683: LIST
46684: LIST
46685: LIST
46686: LIST
46687: LIST
46688: LIST
46689: LIST
46690: LIST
46691: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
46692: LD_ADDR_VAR 0 30
46696: PUSH
46697: LD_INT 2
46699: PUSH
46700: LD_INT 1
46702: NEG
46703: PUSH
46704: EMPTY
46705: LIST
46706: LIST
46707: PUSH
46708: LD_INT 3
46710: PUSH
46711: LD_INT 0
46713: PUSH
46714: EMPTY
46715: LIST
46716: LIST
46717: PUSH
46718: LD_INT 3
46720: PUSH
46721: LD_INT 1
46723: PUSH
46724: EMPTY
46725: LIST
46726: LIST
46727: PUSH
46728: LD_INT 3
46730: PUSH
46731: LD_INT 1
46733: NEG
46734: PUSH
46735: EMPTY
46736: LIST
46737: LIST
46738: PUSH
46739: LD_INT 4
46741: PUSH
46742: LD_INT 0
46744: PUSH
46745: EMPTY
46746: LIST
46747: LIST
46748: PUSH
46749: LD_INT 4
46751: PUSH
46752: LD_INT 1
46754: PUSH
46755: EMPTY
46756: LIST
46757: LIST
46758: PUSH
46759: LD_INT 4
46761: PUSH
46762: LD_INT 1
46764: NEG
46765: PUSH
46766: EMPTY
46767: LIST
46768: LIST
46769: PUSH
46770: LD_INT 5
46772: PUSH
46773: LD_INT 0
46775: PUSH
46776: EMPTY
46777: LIST
46778: LIST
46779: PUSH
46780: LD_INT 5
46782: PUSH
46783: LD_INT 1
46785: PUSH
46786: EMPTY
46787: LIST
46788: LIST
46789: PUSH
46790: LD_INT 5
46792: PUSH
46793: LD_INT 1
46795: NEG
46796: PUSH
46797: EMPTY
46798: LIST
46799: LIST
46800: PUSH
46801: LD_INT 6
46803: PUSH
46804: LD_INT 0
46806: PUSH
46807: EMPTY
46808: LIST
46809: LIST
46810: PUSH
46811: LD_INT 6
46813: PUSH
46814: LD_INT 1
46816: PUSH
46817: EMPTY
46818: LIST
46819: LIST
46820: PUSH
46821: EMPTY
46822: LIST
46823: LIST
46824: LIST
46825: LIST
46826: LIST
46827: LIST
46828: LIST
46829: LIST
46830: LIST
46831: LIST
46832: LIST
46833: LIST
46834: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
46835: LD_ADDR_VAR 0 31
46839: PUSH
46840: LD_INT 3
46842: PUSH
46843: LD_INT 2
46845: PUSH
46846: EMPTY
46847: LIST
46848: LIST
46849: PUSH
46850: LD_INT 3
46852: PUSH
46853: LD_INT 3
46855: PUSH
46856: EMPTY
46857: LIST
46858: LIST
46859: PUSH
46860: LD_INT 2
46862: PUSH
46863: LD_INT 3
46865: PUSH
46866: EMPTY
46867: LIST
46868: LIST
46869: PUSH
46870: LD_INT 4
46872: PUSH
46873: LD_INT 3
46875: PUSH
46876: EMPTY
46877: LIST
46878: LIST
46879: PUSH
46880: LD_INT 4
46882: PUSH
46883: LD_INT 4
46885: PUSH
46886: EMPTY
46887: LIST
46888: LIST
46889: PUSH
46890: LD_INT 3
46892: PUSH
46893: LD_INT 4
46895: PUSH
46896: EMPTY
46897: LIST
46898: LIST
46899: PUSH
46900: LD_INT 5
46902: PUSH
46903: LD_INT 4
46905: PUSH
46906: EMPTY
46907: LIST
46908: LIST
46909: PUSH
46910: LD_INT 5
46912: PUSH
46913: LD_INT 5
46915: PUSH
46916: EMPTY
46917: LIST
46918: LIST
46919: PUSH
46920: LD_INT 4
46922: PUSH
46923: LD_INT 5
46925: PUSH
46926: EMPTY
46927: LIST
46928: LIST
46929: PUSH
46930: LD_INT 6
46932: PUSH
46933: LD_INT 5
46935: PUSH
46936: EMPTY
46937: LIST
46938: LIST
46939: PUSH
46940: LD_INT 6
46942: PUSH
46943: LD_INT 6
46945: PUSH
46946: EMPTY
46947: LIST
46948: LIST
46949: PUSH
46950: LD_INT 5
46952: PUSH
46953: LD_INT 6
46955: PUSH
46956: EMPTY
46957: LIST
46958: LIST
46959: PUSH
46960: EMPTY
46961: LIST
46962: LIST
46963: LIST
46964: LIST
46965: LIST
46966: LIST
46967: LIST
46968: LIST
46969: LIST
46970: LIST
46971: LIST
46972: LIST
46973: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
46974: LD_ADDR_VAR 0 32
46978: PUSH
46979: LD_INT 1
46981: PUSH
46982: LD_INT 3
46984: PUSH
46985: EMPTY
46986: LIST
46987: LIST
46988: PUSH
46989: LD_INT 0
46991: PUSH
46992: LD_INT 3
46994: PUSH
46995: EMPTY
46996: LIST
46997: LIST
46998: PUSH
46999: LD_INT 1
47001: NEG
47002: PUSH
47003: LD_INT 2
47005: PUSH
47006: EMPTY
47007: LIST
47008: LIST
47009: PUSH
47010: LD_INT 1
47012: PUSH
47013: LD_INT 4
47015: PUSH
47016: EMPTY
47017: LIST
47018: LIST
47019: PUSH
47020: LD_INT 0
47022: PUSH
47023: LD_INT 4
47025: PUSH
47026: EMPTY
47027: LIST
47028: LIST
47029: PUSH
47030: LD_INT 1
47032: NEG
47033: PUSH
47034: LD_INT 3
47036: PUSH
47037: EMPTY
47038: LIST
47039: LIST
47040: PUSH
47041: LD_INT 1
47043: PUSH
47044: LD_INT 5
47046: PUSH
47047: EMPTY
47048: LIST
47049: LIST
47050: PUSH
47051: LD_INT 0
47053: PUSH
47054: LD_INT 5
47056: PUSH
47057: EMPTY
47058: LIST
47059: LIST
47060: PUSH
47061: LD_INT 1
47063: NEG
47064: PUSH
47065: LD_INT 4
47067: PUSH
47068: EMPTY
47069: LIST
47070: LIST
47071: PUSH
47072: LD_INT 1
47074: PUSH
47075: LD_INT 6
47077: PUSH
47078: EMPTY
47079: LIST
47080: LIST
47081: PUSH
47082: LD_INT 0
47084: PUSH
47085: LD_INT 6
47087: PUSH
47088: EMPTY
47089: LIST
47090: LIST
47091: PUSH
47092: LD_INT 1
47094: NEG
47095: PUSH
47096: LD_INT 5
47098: PUSH
47099: EMPTY
47100: LIST
47101: LIST
47102: PUSH
47103: EMPTY
47104: LIST
47105: LIST
47106: LIST
47107: LIST
47108: LIST
47109: LIST
47110: LIST
47111: LIST
47112: LIST
47113: LIST
47114: LIST
47115: LIST
47116: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
47117: LD_ADDR_VAR 0 33
47121: PUSH
47122: LD_INT 2
47124: NEG
47125: PUSH
47126: LD_INT 1
47128: PUSH
47129: EMPTY
47130: LIST
47131: LIST
47132: PUSH
47133: LD_INT 3
47135: NEG
47136: PUSH
47137: LD_INT 0
47139: PUSH
47140: EMPTY
47141: LIST
47142: LIST
47143: PUSH
47144: LD_INT 3
47146: NEG
47147: PUSH
47148: LD_INT 1
47150: NEG
47151: PUSH
47152: EMPTY
47153: LIST
47154: LIST
47155: PUSH
47156: LD_INT 3
47158: NEG
47159: PUSH
47160: LD_INT 1
47162: PUSH
47163: EMPTY
47164: LIST
47165: LIST
47166: PUSH
47167: LD_INT 4
47169: NEG
47170: PUSH
47171: LD_INT 0
47173: PUSH
47174: EMPTY
47175: LIST
47176: LIST
47177: PUSH
47178: LD_INT 4
47180: NEG
47181: PUSH
47182: LD_INT 1
47184: NEG
47185: PUSH
47186: EMPTY
47187: LIST
47188: LIST
47189: PUSH
47190: LD_INT 4
47192: NEG
47193: PUSH
47194: LD_INT 1
47196: PUSH
47197: EMPTY
47198: LIST
47199: LIST
47200: PUSH
47201: LD_INT 5
47203: NEG
47204: PUSH
47205: LD_INT 0
47207: PUSH
47208: EMPTY
47209: LIST
47210: LIST
47211: PUSH
47212: LD_INT 5
47214: NEG
47215: PUSH
47216: LD_INT 1
47218: NEG
47219: PUSH
47220: EMPTY
47221: LIST
47222: LIST
47223: PUSH
47224: LD_INT 5
47226: NEG
47227: PUSH
47228: LD_INT 1
47230: PUSH
47231: EMPTY
47232: LIST
47233: LIST
47234: PUSH
47235: LD_INT 6
47237: NEG
47238: PUSH
47239: LD_INT 0
47241: PUSH
47242: EMPTY
47243: LIST
47244: LIST
47245: PUSH
47246: LD_INT 6
47248: NEG
47249: PUSH
47250: LD_INT 1
47252: NEG
47253: PUSH
47254: EMPTY
47255: LIST
47256: LIST
47257: PUSH
47258: EMPTY
47259: LIST
47260: LIST
47261: LIST
47262: LIST
47263: LIST
47264: LIST
47265: LIST
47266: LIST
47267: LIST
47268: LIST
47269: LIST
47270: LIST
47271: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
47272: LD_ADDR_VAR 0 34
47276: PUSH
47277: LD_INT 2
47279: NEG
47280: PUSH
47281: LD_INT 3
47283: NEG
47284: PUSH
47285: EMPTY
47286: LIST
47287: LIST
47288: PUSH
47289: LD_INT 3
47291: NEG
47292: PUSH
47293: LD_INT 2
47295: NEG
47296: PUSH
47297: EMPTY
47298: LIST
47299: LIST
47300: PUSH
47301: LD_INT 3
47303: NEG
47304: PUSH
47305: LD_INT 3
47307: NEG
47308: PUSH
47309: EMPTY
47310: LIST
47311: LIST
47312: PUSH
47313: LD_INT 3
47315: NEG
47316: PUSH
47317: LD_INT 4
47319: NEG
47320: PUSH
47321: EMPTY
47322: LIST
47323: LIST
47324: PUSH
47325: LD_INT 4
47327: NEG
47328: PUSH
47329: LD_INT 3
47331: NEG
47332: PUSH
47333: EMPTY
47334: LIST
47335: LIST
47336: PUSH
47337: LD_INT 4
47339: NEG
47340: PUSH
47341: LD_INT 4
47343: NEG
47344: PUSH
47345: EMPTY
47346: LIST
47347: LIST
47348: PUSH
47349: LD_INT 4
47351: NEG
47352: PUSH
47353: LD_INT 5
47355: NEG
47356: PUSH
47357: EMPTY
47358: LIST
47359: LIST
47360: PUSH
47361: LD_INT 5
47363: NEG
47364: PUSH
47365: LD_INT 4
47367: NEG
47368: PUSH
47369: EMPTY
47370: LIST
47371: LIST
47372: PUSH
47373: LD_INT 5
47375: NEG
47376: PUSH
47377: LD_INT 5
47379: NEG
47380: PUSH
47381: EMPTY
47382: LIST
47383: LIST
47384: PUSH
47385: LD_INT 5
47387: NEG
47388: PUSH
47389: LD_INT 6
47391: NEG
47392: PUSH
47393: EMPTY
47394: LIST
47395: LIST
47396: PUSH
47397: LD_INT 6
47399: NEG
47400: PUSH
47401: LD_INT 5
47403: NEG
47404: PUSH
47405: EMPTY
47406: LIST
47407: LIST
47408: PUSH
47409: LD_INT 6
47411: NEG
47412: PUSH
47413: LD_INT 6
47415: NEG
47416: PUSH
47417: EMPTY
47418: LIST
47419: LIST
47420: PUSH
47421: EMPTY
47422: LIST
47423: LIST
47424: LIST
47425: LIST
47426: LIST
47427: LIST
47428: LIST
47429: LIST
47430: LIST
47431: LIST
47432: LIST
47433: LIST
47434: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
47435: LD_ADDR_VAR 0 41
47439: PUSH
47440: LD_INT 0
47442: PUSH
47443: LD_INT 2
47445: NEG
47446: PUSH
47447: EMPTY
47448: LIST
47449: LIST
47450: PUSH
47451: LD_INT 1
47453: NEG
47454: PUSH
47455: LD_INT 3
47457: NEG
47458: PUSH
47459: EMPTY
47460: LIST
47461: LIST
47462: PUSH
47463: LD_INT 1
47465: PUSH
47466: LD_INT 2
47468: NEG
47469: PUSH
47470: EMPTY
47471: LIST
47472: LIST
47473: PUSH
47474: EMPTY
47475: LIST
47476: LIST
47477: LIST
47478: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
47479: LD_ADDR_VAR 0 42
47483: PUSH
47484: LD_INT 2
47486: PUSH
47487: LD_INT 0
47489: PUSH
47490: EMPTY
47491: LIST
47492: LIST
47493: PUSH
47494: LD_INT 2
47496: PUSH
47497: LD_INT 1
47499: NEG
47500: PUSH
47501: EMPTY
47502: LIST
47503: LIST
47504: PUSH
47505: LD_INT 3
47507: PUSH
47508: LD_INT 1
47510: PUSH
47511: EMPTY
47512: LIST
47513: LIST
47514: PUSH
47515: EMPTY
47516: LIST
47517: LIST
47518: LIST
47519: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
47520: LD_ADDR_VAR 0 43
47524: PUSH
47525: LD_INT 2
47527: PUSH
47528: LD_INT 2
47530: PUSH
47531: EMPTY
47532: LIST
47533: LIST
47534: PUSH
47535: LD_INT 3
47537: PUSH
47538: LD_INT 2
47540: PUSH
47541: EMPTY
47542: LIST
47543: LIST
47544: PUSH
47545: LD_INT 2
47547: PUSH
47548: LD_INT 3
47550: PUSH
47551: EMPTY
47552: LIST
47553: LIST
47554: PUSH
47555: EMPTY
47556: LIST
47557: LIST
47558: LIST
47559: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
47560: LD_ADDR_VAR 0 44
47564: PUSH
47565: LD_INT 0
47567: PUSH
47568: LD_INT 2
47570: PUSH
47571: EMPTY
47572: LIST
47573: LIST
47574: PUSH
47575: LD_INT 1
47577: PUSH
47578: LD_INT 3
47580: PUSH
47581: EMPTY
47582: LIST
47583: LIST
47584: PUSH
47585: LD_INT 1
47587: NEG
47588: PUSH
47589: LD_INT 2
47591: PUSH
47592: EMPTY
47593: LIST
47594: LIST
47595: PUSH
47596: EMPTY
47597: LIST
47598: LIST
47599: LIST
47600: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
47601: LD_ADDR_VAR 0 45
47605: PUSH
47606: LD_INT 2
47608: NEG
47609: PUSH
47610: LD_INT 0
47612: PUSH
47613: EMPTY
47614: LIST
47615: LIST
47616: PUSH
47617: LD_INT 2
47619: NEG
47620: PUSH
47621: LD_INT 1
47623: PUSH
47624: EMPTY
47625: LIST
47626: LIST
47627: PUSH
47628: LD_INT 3
47630: NEG
47631: PUSH
47632: LD_INT 1
47634: NEG
47635: PUSH
47636: EMPTY
47637: LIST
47638: LIST
47639: PUSH
47640: EMPTY
47641: LIST
47642: LIST
47643: LIST
47644: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
47645: LD_ADDR_VAR 0 46
47649: PUSH
47650: LD_INT 2
47652: NEG
47653: PUSH
47654: LD_INT 2
47656: NEG
47657: PUSH
47658: EMPTY
47659: LIST
47660: LIST
47661: PUSH
47662: LD_INT 2
47664: NEG
47665: PUSH
47666: LD_INT 3
47668: NEG
47669: PUSH
47670: EMPTY
47671: LIST
47672: LIST
47673: PUSH
47674: LD_INT 3
47676: NEG
47677: PUSH
47678: LD_INT 2
47680: NEG
47681: PUSH
47682: EMPTY
47683: LIST
47684: LIST
47685: PUSH
47686: EMPTY
47687: LIST
47688: LIST
47689: LIST
47690: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
47691: LD_ADDR_VAR 0 47
47695: PUSH
47696: LD_INT 2
47698: NEG
47699: PUSH
47700: LD_INT 3
47702: NEG
47703: PUSH
47704: EMPTY
47705: LIST
47706: LIST
47707: PUSH
47708: LD_INT 1
47710: NEG
47711: PUSH
47712: LD_INT 3
47714: NEG
47715: PUSH
47716: EMPTY
47717: LIST
47718: LIST
47719: PUSH
47720: EMPTY
47721: LIST
47722: LIST
47723: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
47724: LD_ADDR_VAR 0 48
47728: PUSH
47729: LD_INT 1
47731: PUSH
47732: LD_INT 2
47734: NEG
47735: PUSH
47736: EMPTY
47737: LIST
47738: LIST
47739: PUSH
47740: LD_INT 2
47742: PUSH
47743: LD_INT 1
47745: NEG
47746: PUSH
47747: EMPTY
47748: LIST
47749: LIST
47750: PUSH
47751: EMPTY
47752: LIST
47753: LIST
47754: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
47755: LD_ADDR_VAR 0 49
47759: PUSH
47760: LD_INT 3
47762: PUSH
47763: LD_INT 1
47765: PUSH
47766: EMPTY
47767: LIST
47768: LIST
47769: PUSH
47770: LD_INT 3
47772: PUSH
47773: LD_INT 2
47775: PUSH
47776: EMPTY
47777: LIST
47778: LIST
47779: PUSH
47780: EMPTY
47781: LIST
47782: LIST
47783: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
47784: LD_ADDR_VAR 0 50
47788: PUSH
47789: LD_INT 2
47791: PUSH
47792: LD_INT 3
47794: PUSH
47795: EMPTY
47796: LIST
47797: LIST
47798: PUSH
47799: LD_INT 1
47801: PUSH
47802: LD_INT 3
47804: PUSH
47805: EMPTY
47806: LIST
47807: LIST
47808: PUSH
47809: EMPTY
47810: LIST
47811: LIST
47812: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
47813: LD_ADDR_VAR 0 51
47817: PUSH
47818: LD_INT 1
47820: NEG
47821: PUSH
47822: LD_INT 2
47824: PUSH
47825: EMPTY
47826: LIST
47827: LIST
47828: PUSH
47829: LD_INT 2
47831: NEG
47832: PUSH
47833: LD_INT 1
47835: PUSH
47836: EMPTY
47837: LIST
47838: LIST
47839: PUSH
47840: EMPTY
47841: LIST
47842: LIST
47843: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
47844: LD_ADDR_VAR 0 52
47848: PUSH
47849: LD_INT 3
47851: NEG
47852: PUSH
47853: LD_INT 1
47855: NEG
47856: PUSH
47857: EMPTY
47858: LIST
47859: LIST
47860: PUSH
47861: LD_INT 3
47863: NEG
47864: PUSH
47865: LD_INT 2
47867: NEG
47868: PUSH
47869: EMPTY
47870: LIST
47871: LIST
47872: PUSH
47873: EMPTY
47874: LIST
47875: LIST
47876: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
47877: LD_ADDR_VAR 0 53
47881: PUSH
47882: LD_INT 1
47884: NEG
47885: PUSH
47886: LD_INT 3
47888: NEG
47889: PUSH
47890: EMPTY
47891: LIST
47892: LIST
47893: PUSH
47894: LD_INT 0
47896: PUSH
47897: LD_INT 3
47899: NEG
47900: PUSH
47901: EMPTY
47902: LIST
47903: LIST
47904: PUSH
47905: LD_INT 1
47907: PUSH
47908: LD_INT 2
47910: NEG
47911: PUSH
47912: EMPTY
47913: LIST
47914: LIST
47915: PUSH
47916: EMPTY
47917: LIST
47918: LIST
47919: LIST
47920: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
47921: LD_ADDR_VAR 0 54
47925: PUSH
47926: LD_INT 2
47928: PUSH
47929: LD_INT 1
47931: NEG
47932: PUSH
47933: EMPTY
47934: LIST
47935: LIST
47936: PUSH
47937: LD_INT 3
47939: PUSH
47940: LD_INT 0
47942: PUSH
47943: EMPTY
47944: LIST
47945: LIST
47946: PUSH
47947: LD_INT 3
47949: PUSH
47950: LD_INT 1
47952: PUSH
47953: EMPTY
47954: LIST
47955: LIST
47956: PUSH
47957: EMPTY
47958: LIST
47959: LIST
47960: LIST
47961: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
47962: LD_ADDR_VAR 0 55
47966: PUSH
47967: LD_INT 3
47969: PUSH
47970: LD_INT 2
47972: PUSH
47973: EMPTY
47974: LIST
47975: LIST
47976: PUSH
47977: LD_INT 3
47979: PUSH
47980: LD_INT 3
47982: PUSH
47983: EMPTY
47984: LIST
47985: LIST
47986: PUSH
47987: LD_INT 2
47989: PUSH
47990: LD_INT 3
47992: PUSH
47993: EMPTY
47994: LIST
47995: LIST
47996: PUSH
47997: EMPTY
47998: LIST
47999: LIST
48000: LIST
48001: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
48002: LD_ADDR_VAR 0 56
48006: PUSH
48007: LD_INT 1
48009: PUSH
48010: LD_INT 3
48012: PUSH
48013: EMPTY
48014: LIST
48015: LIST
48016: PUSH
48017: LD_INT 0
48019: PUSH
48020: LD_INT 3
48022: PUSH
48023: EMPTY
48024: LIST
48025: LIST
48026: PUSH
48027: LD_INT 1
48029: NEG
48030: PUSH
48031: LD_INT 2
48033: PUSH
48034: EMPTY
48035: LIST
48036: LIST
48037: PUSH
48038: EMPTY
48039: LIST
48040: LIST
48041: LIST
48042: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
48043: LD_ADDR_VAR 0 57
48047: PUSH
48048: LD_INT 2
48050: NEG
48051: PUSH
48052: LD_INT 1
48054: PUSH
48055: EMPTY
48056: LIST
48057: LIST
48058: PUSH
48059: LD_INT 3
48061: NEG
48062: PUSH
48063: LD_INT 0
48065: PUSH
48066: EMPTY
48067: LIST
48068: LIST
48069: PUSH
48070: LD_INT 3
48072: NEG
48073: PUSH
48074: LD_INT 1
48076: NEG
48077: PUSH
48078: EMPTY
48079: LIST
48080: LIST
48081: PUSH
48082: EMPTY
48083: LIST
48084: LIST
48085: LIST
48086: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
48087: LD_ADDR_VAR 0 58
48091: PUSH
48092: LD_INT 2
48094: NEG
48095: PUSH
48096: LD_INT 3
48098: NEG
48099: PUSH
48100: EMPTY
48101: LIST
48102: LIST
48103: PUSH
48104: LD_INT 3
48106: NEG
48107: PUSH
48108: LD_INT 2
48110: NEG
48111: PUSH
48112: EMPTY
48113: LIST
48114: LIST
48115: PUSH
48116: LD_INT 3
48118: NEG
48119: PUSH
48120: LD_INT 3
48122: NEG
48123: PUSH
48124: EMPTY
48125: LIST
48126: LIST
48127: PUSH
48128: EMPTY
48129: LIST
48130: LIST
48131: LIST
48132: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
48133: LD_ADDR_VAR 0 59
48137: PUSH
48138: LD_INT 1
48140: NEG
48141: PUSH
48142: LD_INT 2
48144: NEG
48145: PUSH
48146: EMPTY
48147: LIST
48148: LIST
48149: PUSH
48150: LD_INT 0
48152: PUSH
48153: LD_INT 2
48155: NEG
48156: PUSH
48157: EMPTY
48158: LIST
48159: LIST
48160: PUSH
48161: LD_INT 1
48163: PUSH
48164: LD_INT 1
48166: NEG
48167: PUSH
48168: EMPTY
48169: LIST
48170: LIST
48171: PUSH
48172: EMPTY
48173: LIST
48174: LIST
48175: LIST
48176: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
48177: LD_ADDR_VAR 0 60
48181: PUSH
48182: LD_INT 1
48184: PUSH
48185: LD_INT 1
48187: NEG
48188: PUSH
48189: EMPTY
48190: LIST
48191: LIST
48192: PUSH
48193: LD_INT 2
48195: PUSH
48196: LD_INT 0
48198: PUSH
48199: EMPTY
48200: LIST
48201: LIST
48202: PUSH
48203: LD_INT 2
48205: PUSH
48206: LD_INT 1
48208: PUSH
48209: EMPTY
48210: LIST
48211: LIST
48212: PUSH
48213: EMPTY
48214: LIST
48215: LIST
48216: LIST
48217: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
48218: LD_ADDR_VAR 0 61
48222: PUSH
48223: LD_INT 2
48225: PUSH
48226: LD_INT 1
48228: PUSH
48229: EMPTY
48230: LIST
48231: LIST
48232: PUSH
48233: LD_INT 2
48235: PUSH
48236: LD_INT 2
48238: PUSH
48239: EMPTY
48240: LIST
48241: LIST
48242: PUSH
48243: LD_INT 1
48245: PUSH
48246: LD_INT 2
48248: PUSH
48249: EMPTY
48250: LIST
48251: LIST
48252: PUSH
48253: EMPTY
48254: LIST
48255: LIST
48256: LIST
48257: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
48258: LD_ADDR_VAR 0 62
48262: PUSH
48263: LD_INT 1
48265: PUSH
48266: LD_INT 2
48268: PUSH
48269: EMPTY
48270: LIST
48271: LIST
48272: PUSH
48273: LD_INT 0
48275: PUSH
48276: LD_INT 2
48278: PUSH
48279: EMPTY
48280: LIST
48281: LIST
48282: PUSH
48283: LD_INT 1
48285: NEG
48286: PUSH
48287: LD_INT 1
48289: PUSH
48290: EMPTY
48291: LIST
48292: LIST
48293: PUSH
48294: EMPTY
48295: LIST
48296: LIST
48297: LIST
48298: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
48299: LD_ADDR_VAR 0 63
48303: PUSH
48304: LD_INT 1
48306: NEG
48307: PUSH
48308: LD_INT 1
48310: PUSH
48311: EMPTY
48312: LIST
48313: LIST
48314: PUSH
48315: LD_INT 2
48317: NEG
48318: PUSH
48319: LD_INT 0
48321: PUSH
48322: EMPTY
48323: LIST
48324: LIST
48325: PUSH
48326: LD_INT 2
48328: NEG
48329: PUSH
48330: LD_INT 1
48332: NEG
48333: PUSH
48334: EMPTY
48335: LIST
48336: LIST
48337: PUSH
48338: EMPTY
48339: LIST
48340: LIST
48341: LIST
48342: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
48343: LD_ADDR_VAR 0 64
48347: PUSH
48348: LD_INT 1
48350: NEG
48351: PUSH
48352: LD_INT 2
48354: NEG
48355: PUSH
48356: EMPTY
48357: LIST
48358: LIST
48359: PUSH
48360: LD_INT 2
48362: NEG
48363: PUSH
48364: LD_INT 1
48366: NEG
48367: PUSH
48368: EMPTY
48369: LIST
48370: LIST
48371: PUSH
48372: LD_INT 2
48374: NEG
48375: PUSH
48376: LD_INT 2
48378: NEG
48379: PUSH
48380: EMPTY
48381: LIST
48382: LIST
48383: PUSH
48384: EMPTY
48385: LIST
48386: LIST
48387: LIST
48388: ST_TO_ADDR
// end ; 2 :
48389: GO 51655
48391: LD_INT 2
48393: DOUBLE
48394: EQUAL
48395: IFTRUE 48399
48397: GO 51654
48399: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
48400: LD_ADDR_VAR 0 29
48404: PUSH
48405: LD_INT 4
48407: PUSH
48408: LD_INT 0
48410: PUSH
48411: EMPTY
48412: LIST
48413: LIST
48414: PUSH
48415: LD_INT 4
48417: PUSH
48418: LD_INT 1
48420: NEG
48421: PUSH
48422: EMPTY
48423: LIST
48424: LIST
48425: PUSH
48426: LD_INT 5
48428: PUSH
48429: LD_INT 0
48431: PUSH
48432: EMPTY
48433: LIST
48434: LIST
48435: PUSH
48436: LD_INT 5
48438: PUSH
48439: LD_INT 1
48441: PUSH
48442: EMPTY
48443: LIST
48444: LIST
48445: PUSH
48446: LD_INT 4
48448: PUSH
48449: LD_INT 1
48451: PUSH
48452: EMPTY
48453: LIST
48454: LIST
48455: PUSH
48456: LD_INT 3
48458: PUSH
48459: LD_INT 0
48461: PUSH
48462: EMPTY
48463: LIST
48464: LIST
48465: PUSH
48466: LD_INT 3
48468: PUSH
48469: LD_INT 1
48471: NEG
48472: PUSH
48473: EMPTY
48474: LIST
48475: LIST
48476: PUSH
48477: LD_INT 3
48479: PUSH
48480: LD_INT 2
48482: NEG
48483: PUSH
48484: EMPTY
48485: LIST
48486: LIST
48487: PUSH
48488: LD_INT 5
48490: PUSH
48491: LD_INT 2
48493: PUSH
48494: EMPTY
48495: LIST
48496: LIST
48497: PUSH
48498: LD_INT 3
48500: PUSH
48501: LD_INT 3
48503: PUSH
48504: EMPTY
48505: LIST
48506: LIST
48507: PUSH
48508: LD_INT 3
48510: PUSH
48511: LD_INT 2
48513: PUSH
48514: EMPTY
48515: LIST
48516: LIST
48517: PUSH
48518: LD_INT 4
48520: PUSH
48521: LD_INT 3
48523: PUSH
48524: EMPTY
48525: LIST
48526: LIST
48527: PUSH
48528: LD_INT 4
48530: PUSH
48531: LD_INT 4
48533: PUSH
48534: EMPTY
48535: LIST
48536: LIST
48537: PUSH
48538: LD_INT 3
48540: PUSH
48541: LD_INT 4
48543: PUSH
48544: EMPTY
48545: LIST
48546: LIST
48547: PUSH
48548: LD_INT 2
48550: PUSH
48551: LD_INT 3
48553: PUSH
48554: EMPTY
48555: LIST
48556: LIST
48557: PUSH
48558: LD_INT 2
48560: PUSH
48561: LD_INT 2
48563: PUSH
48564: EMPTY
48565: LIST
48566: LIST
48567: PUSH
48568: LD_INT 4
48570: PUSH
48571: LD_INT 2
48573: PUSH
48574: EMPTY
48575: LIST
48576: LIST
48577: PUSH
48578: LD_INT 2
48580: PUSH
48581: LD_INT 4
48583: PUSH
48584: EMPTY
48585: LIST
48586: LIST
48587: PUSH
48588: LD_INT 0
48590: PUSH
48591: LD_INT 4
48593: PUSH
48594: EMPTY
48595: LIST
48596: LIST
48597: PUSH
48598: LD_INT 0
48600: PUSH
48601: LD_INT 3
48603: PUSH
48604: EMPTY
48605: LIST
48606: LIST
48607: PUSH
48608: LD_INT 1
48610: PUSH
48611: LD_INT 4
48613: PUSH
48614: EMPTY
48615: LIST
48616: LIST
48617: PUSH
48618: LD_INT 1
48620: PUSH
48621: LD_INT 5
48623: PUSH
48624: EMPTY
48625: LIST
48626: LIST
48627: PUSH
48628: LD_INT 0
48630: PUSH
48631: LD_INT 5
48633: PUSH
48634: EMPTY
48635: LIST
48636: LIST
48637: PUSH
48638: LD_INT 1
48640: NEG
48641: PUSH
48642: LD_INT 4
48644: PUSH
48645: EMPTY
48646: LIST
48647: LIST
48648: PUSH
48649: LD_INT 1
48651: NEG
48652: PUSH
48653: LD_INT 3
48655: PUSH
48656: EMPTY
48657: LIST
48658: LIST
48659: PUSH
48660: LD_INT 2
48662: PUSH
48663: LD_INT 5
48665: PUSH
48666: EMPTY
48667: LIST
48668: LIST
48669: PUSH
48670: LD_INT 2
48672: NEG
48673: PUSH
48674: LD_INT 3
48676: PUSH
48677: EMPTY
48678: LIST
48679: LIST
48680: PUSH
48681: LD_INT 3
48683: NEG
48684: PUSH
48685: LD_INT 0
48687: PUSH
48688: EMPTY
48689: LIST
48690: LIST
48691: PUSH
48692: LD_INT 3
48694: NEG
48695: PUSH
48696: LD_INT 1
48698: NEG
48699: PUSH
48700: EMPTY
48701: LIST
48702: LIST
48703: PUSH
48704: LD_INT 2
48706: NEG
48707: PUSH
48708: LD_INT 0
48710: PUSH
48711: EMPTY
48712: LIST
48713: LIST
48714: PUSH
48715: LD_INT 2
48717: NEG
48718: PUSH
48719: LD_INT 1
48721: PUSH
48722: EMPTY
48723: LIST
48724: LIST
48725: PUSH
48726: LD_INT 3
48728: NEG
48729: PUSH
48730: LD_INT 1
48732: PUSH
48733: EMPTY
48734: LIST
48735: LIST
48736: PUSH
48737: LD_INT 4
48739: NEG
48740: PUSH
48741: LD_INT 0
48743: PUSH
48744: EMPTY
48745: LIST
48746: LIST
48747: PUSH
48748: LD_INT 4
48750: NEG
48751: PUSH
48752: LD_INT 1
48754: NEG
48755: PUSH
48756: EMPTY
48757: LIST
48758: LIST
48759: PUSH
48760: LD_INT 4
48762: NEG
48763: PUSH
48764: LD_INT 2
48766: NEG
48767: PUSH
48768: EMPTY
48769: LIST
48770: LIST
48771: PUSH
48772: LD_INT 2
48774: NEG
48775: PUSH
48776: LD_INT 2
48778: PUSH
48779: EMPTY
48780: LIST
48781: LIST
48782: PUSH
48783: LD_INT 4
48785: NEG
48786: PUSH
48787: LD_INT 4
48789: NEG
48790: PUSH
48791: EMPTY
48792: LIST
48793: LIST
48794: PUSH
48795: LD_INT 4
48797: NEG
48798: PUSH
48799: LD_INT 5
48801: NEG
48802: PUSH
48803: EMPTY
48804: LIST
48805: LIST
48806: PUSH
48807: LD_INT 3
48809: NEG
48810: PUSH
48811: LD_INT 4
48813: NEG
48814: PUSH
48815: EMPTY
48816: LIST
48817: LIST
48818: PUSH
48819: LD_INT 3
48821: NEG
48822: PUSH
48823: LD_INT 3
48825: NEG
48826: PUSH
48827: EMPTY
48828: LIST
48829: LIST
48830: PUSH
48831: LD_INT 4
48833: NEG
48834: PUSH
48835: LD_INT 3
48837: NEG
48838: PUSH
48839: EMPTY
48840: LIST
48841: LIST
48842: PUSH
48843: LD_INT 5
48845: NEG
48846: PUSH
48847: LD_INT 4
48849: NEG
48850: PUSH
48851: EMPTY
48852: LIST
48853: LIST
48854: PUSH
48855: LD_INT 5
48857: NEG
48858: PUSH
48859: LD_INT 5
48861: NEG
48862: PUSH
48863: EMPTY
48864: LIST
48865: LIST
48866: PUSH
48867: LD_INT 3
48869: NEG
48870: PUSH
48871: LD_INT 5
48873: NEG
48874: PUSH
48875: EMPTY
48876: LIST
48877: LIST
48878: PUSH
48879: LD_INT 5
48881: NEG
48882: PUSH
48883: LD_INT 3
48885: NEG
48886: PUSH
48887: EMPTY
48888: LIST
48889: LIST
48890: PUSH
48891: EMPTY
48892: LIST
48893: LIST
48894: LIST
48895: LIST
48896: LIST
48897: LIST
48898: LIST
48899: LIST
48900: LIST
48901: LIST
48902: LIST
48903: LIST
48904: LIST
48905: LIST
48906: LIST
48907: LIST
48908: LIST
48909: LIST
48910: LIST
48911: LIST
48912: LIST
48913: LIST
48914: LIST
48915: LIST
48916: LIST
48917: LIST
48918: LIST
48919: LIST
48920: LIST
48921: LIST
48922: LIST
48923: LIST
48924: LIST
48925: LIST
48926: LIST
48927: LIST
48928: LIST
48929: LIST
48930: LIST
48931: LIST
48932: LIST
48933: LIST
48934: LIST
48935: LIST
48936: LIST
48937: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
48938: LD_ADDR_VAR 0 30
48942: PUSH
48943: LD_INT 4
48945: PUSH
48946: LD_INT 4
48948: PUSH
48949: EMPTY
48950: LIST
48951: LIST
48952: PUSH
48953: LD_INT 4
48955: PUSH
48956: LD_INT 3
48958: PUSH
48959: EMPTY
48960: LIST
48961: LIST
48962: PUSH
48963: LD_INT 5
48965: PUSH
48966: LD_INT 4
48968: PUSH
48969: EMPTY
48970: LIST
48971: LIST
48972: PUSH
48973: LD_INT 5
48975: PUSH
48976: LD_INT 5
48978: PUSH
48979: EMPTY
48980: LIST
48981: LIST
48982: PUSH
48983: LD_INT 4
48985: PUSH
48986: LD_INT 5
48988: PUSH
48989: EMPTY
48990: LIST
48991: LIST
48992: PUSH
48993: LD_INT 3
48995: PUSH
48996: LD_INT 4
48998: PUSH
48999: EMPTY
49000: LIST
49001: LIST
49002: PUSH
49003: LD_INT 3
49005: PUSH
49006: LD_INT 3
49008: PUSH
49009: EMPTY
49010: LIST
49011: LIST
49012: PUSH
49013: LD_INT 5
49015: PUSH
49016: LD_INT 3
49018: PUSH
49019: EMPTY
49020: LIST
49021: LIST
49022: PUSH
49023: LD_INT 3
49025: PUSH
49026: LD_INT 5
49028: PUSH
49029: EMPTY
49030: LIST
49031: LIST
49032: PUSH
49033: LD_INT 0
49035: PUSH
49036: LD_INT 3
49038: PUSH
49039: EMPTY
49040: LIST
49041: LIST
49042: PUSH
49043: LD_INT 0
49045: PUSH
49046: LD_INT 2
49048: PUSH
49049: EMPTY
49050: LIST
49051: LIST
49052: PUSH
49053: LD_INT 1
49055: PUSH
49056: LD_INT 3
49058: PUSH
49059: EMPTY
49060: LIST
49061: LIST
49062: PUSH
49063: LD_INT 1
49065: PUSH
49066: LD_INT 4
49068: PUSH
49069: EMPTY
49070: LIST
49071: LIST
49072: PUSH
49073: LD_INT 0
49075: PUSH
49076: LD_INT 4
49078: PUSH
49079: EMPTY
49080: LIST
49081: LIST
49082: PUSH
49083: LD_INT 1
49085: NEG
49086: PUSH
49087: LD_INT 3
49089: PUSH
49090: EMPTY
49091: LIST
49092: LIST
49093: PUSH
49094: LD_INT 1
49096: NEG
49097: PUSH
49098: LD_INT 2
49100: PUSH
49101: EMPTY
49102: LIST
49103: LIST
49104: PUSH
49105: LD_INT 2
49107: PUSH
49108: LD_INT 4
49110: PUSH
49111: EMPTY
49112: LIST
49113: LIST
49114: PUSH
49115: LD_INT 2
49117: NEG
49118: PUSH
49119: LD_INT 2
49121: PUSH
49122: EMPTY
49123: LIST
49124: LIST
49125: PUSH
49126: LD_INT 4
49128: NEG
49129: PUSH
49130: LD_INT 0
49132: PUSH
49133: EMPTY
49134: LIST
49135: LIST
49136: PUSH
49137: LD_INT 4
49139: NEG
49140: PUSH
49141: LD_INT 1
49143: NEG
49144: PUSH
49145: EMPTY
49146: LIST
49147: LIST
49148: PUSH
49149: LD_INT 3
49151: NEG
49152: PUSH
49153: LD_INT 0
49155: PUSH
49156: EMPTY
49157: LIST
49158: LIST
49159: PUSH
49160: LD_INT 3
49162: NEG
49163: PUSH
49164: LD_INT 1
49166: PUSH
49167: EMPTY
49168: LIST
49169: LIST
49170: PUSH
49171: LD_INT 4
49173: NEG
49174: PUSH
49175: LD_INT 1
49177: PUSH
49178: EMPTY
49179: LIST
49180: LIST
49181: PUSH
49182: LD_INT 5
49184: NEG
49185: PUSH
49186: LD_INT 0
49188: PUSH
49189: EMPTY
49190: LIST
49191: LIST
49192: PUSH
49193: LD_INT 5
49195: NEG
49196: PUSH
49197: LD_INT 1
49199: NEG
49200: PUSH
49201: EMPTY
49202: LIST
49203: LIST
49204: PUSH
49205: LD_INT 5
49207: NEG
49208: PUSH
49209: LD_INT 2
49211: NEG
49212: PUSH
49213: EMPTY
49214: LIST
49215: LIST
49216: PUSH
49217: LD_INT 3
49219: NEG
49220: PUSH
49221: LD_INT 2
49223: PUSH
49224: EMPTY
49225: LIST
49226: LIST
49227: PUSH
49228: LD_INT 3
49230: NEG
49231: PUSH
49232: LD_INT 3
49234: NEG
49235: PUSH
49236: EMPTY
49237: LIST
49238: LIST
49239: PUSH
49240: LD_INT 3
49242: NEG
49243: PUSH
49244: LD_INT 4
49246: NEG
49247: PUSH
49248: EMPTY
49249: LIST
49250: LIST
49251: PUSH
49252: LD_INT 2
49254: NEG
49255: PUSH
49256: LD_INT 3
49258: NEG
49259: PUSH
49260: EMPTY
49261: LIST
49262: LIST
49263: PUSH
49264: LD_INT 2
49266: NEG
49267: PUSH
49268: LD_INT 2
49270: NEG
49271: PUSH
49272: EMPTY
49273: LIST
49274: LIST
49275: PUSH
49276: LD_INT 3
49278: NEG
49279: PUSH
49280: LD_INT 2
49282: NEG
49283: PUSH
49284: EMPTY
49285: LIST
49286: LIST
49287: PUSH
49288: LD_INT 4
49290: NEG
49291: PUSH
49292: LD_INT 3
49294: NEG
49295: PUSH
49296: EMPTY
49297: LIST
49298: LIST
49299: PUSH
49300: LD_INT 4
49302: NEG
49303: PUSH
49304: LD_INT 4
49306: NEG
49307: PUSH
49308: EMPTY
49309: LIST
49310: LIST
49311: PUSH
49312: LD_INT 2
49314: NEG
49315: PUSH
49316: LD_INT 4
49318: NEG
49319: PUSH
49320: EMPTY
49321: LIST
49322: LIST
49323: PUSH
49324: LD_INT 4
49326: NEG
49327: PUSH
49328: LD_INT 2
49330: NEG
49331: PUSH
49332: EMPTY
49333: LIST
49334: LIST
49335: PUSH
49336: LD_INT 0
49338: PUSH
49339: LD_INT 4
49341: NEG
49342: PUSH
49343: EMPTY
49344: LIST
49345: LIST
49346: PUSH
49347: LD_INT 0
49349: PUSH
49350: LD_INT 5
49352: NEG
49353: PUSH
49354: EMPTY
49355: LIST
49356: LIST
49357: PUSH
49358: LD_INT 1
49360: PUSH
49361: LD_INT 4
49363: NEG
49364: PUSH
49365: EMPTY
49366: LIST
49367: LIST
49368: PUSH
49369: LD_INT 1
49371: PUSH
49372: LD_INT 3
49374: NEG
49375: PUSH
49376: EMPTY
49377: LIST
49378: LIST
49379: PUSH
49380: LD_INT 0
49382: PUSH
49383: LD_INT 3
49385: NEG
49386: PUSH
49387: EMPTY
49388: LIST
49389: LIST
49390: PUSH
49391: LD_INT 1
49393: NEG
49394: PUSH
49395: LD_INT 4
49397: NEG
49398: PUSH
49399: EMPTY
49400: LIST
49401: LIST
49402: PUSH
49403: LD_INT 1
49405: NEG
49406: PUSH
49407: LD_INT 5
49409: NEG
49410: PUSH
49411: EMPTY
49412: LIST
49413: LIST
49414: PUSH
49415: LD_INT 2
49417: PUSH
49418: LD_INT 3
49420: NEG
49421: PUSH
49422: EMPTY
49423: LIST
49424: LIST
49425: PUSH
49426: LD_INT 2
49428: NEG
49429: PUSH
49430: LD_INT 5
49432: NEG
49433: PUSH
49434: EMPTY
49435: LIST
49436: LIST
49437: PUSH
49438: EMPTY
49439: LIST
49440: LIST
49441: LIST
49442: LIST
49443: LIST
49444: LIST
49445: LIST
49446: LIST
49447: LIST
49448: LIST
49449: LIST
49450: LIST
49451: LIST
49452: LIST
49453: LIST
49454: LIST
49455: LIST
49456: LIST
49457: LIST
49458: LIST
49459: LIST
49460: LIST
49461: LIST
49462: LIST
49463: LIST
49464: LIST
49465: LIST
49466: LIST
49467: LIST
49468: LIST
49469: LIST
49470: LIST
49471: LIST
49472: LIST
49473: LIST
49474: LIST
49475: LIST
49476: LIST
49477: LIST
49478: LIST
49479: LIST
49480: LIST
49481: LIST
49482: LIST
49483: LIST
49484: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
49485: LD_ADDR_VAR 0 31
49489: PUSH
49490: LD_INT 0
49492: PUSH
49493: LD_INT 4
49495: PUSH
49496: EMPTY
49497: LIST
49498: LIST
49499: PUSH
49500: LD_INT 0
49502: PUSH
49503: LD_INT 3
49505: PUSH
49506: EMPTY
49507: LIST
49508: LIST
49509: PUSH
49510: LD_INT 1
49512: PUSH
49513: LD_INT 4
49515: PUSH
49516: EMPTY
49517: LIST
49518: LIST
49519: PUSH
49520: LD_INT 1
49522: PUSH
49523: LD_INT 5
49525: PUSH
49526: EMPTY
49527: LIST
49528: LIST
49529: PUSH
49530: LD_INT 0
49532: PUSH
49533: LD_INT 5
49535: PUSH
49536: EMPTY
49537: LIST
49538: LIST
49539: PUSH
49540: LD_INT 1
49542: NEG
49543: PUSH
49544: LD_INT 4
49546: PUSH
49547: EMPTY
49548: LIST
49549: LIST
49550: PUSH
49551: LD_INT 1
49553: NEG
49554: PUSH
49555: LD_INT 3
49557: PUSH
49558: EMPTY
49559: LIST
49560: LIST
49561: PUSH
49562: LD_INT 2
49564: PUSH
49565: LD_INT 5
49567: PUSH
49568: EMPTY
49569: LIST
49570: LIST
49571: PUSH
49572: LD_INT 2
49574: NEG
49575: PUSH
49576: LD_INT 3
49578: PUSH
49579: EMPTY
49580: LIST
49581: LIST
49582: PUSH
49583: LD_INT 3
49585: NEG
49586: PUSH
49587: LD_INT 0
49589: PUSH
49590: EMPTY
49591: LIST
49592: LIST
49593: PUSH
49594: LD_INT 3
49596: NEG
49597: PUSH
49598: LD_INT 1
49600: NEG
49601: PUSH
49602: EMPTY
49603: LIST
49604: LIST
49605: PUSH
49606: LD_INT 2
49608: NEG
49609: PUSH
49610: LD_INT 0
49612: PUSH
49613: EMPTY
49614: LIST
49615: LIST
49616: PUSH
49617: LD_INT 2
49619: NEG
49620: PUSH
49621: LD_INT 1
49623: PUSH
49624: EMPTY
49625: LIST
49626: LIST
49627: PUSH
49628: LD_INT 3
49630: NEG
49631: PUSH
49632: LD_INT 1
49634: PUSH
49635: EMPTY
49636: LIST
49637: LIST
49638: PUSH
49639: LD_INT 4
49641: NEG
49642: PUSH
49643: LD_INT 0
49645: PUSH
49646: EMPTY
49647: LIST
49648: LIST
49649: PUSH
49650: LD_INT 4
49652: NEG
49653: PUSH
49654: LD_INT 1
49656: NEG
49657: PUSH
49658: EMPTY
49659: LIST
49660: LIST
49661: PUSH
49662: LD_INT 4
49664: NEG
49665: PUSH
49666: LD_INT 2
49668: NEG
49669: PUSH
49670: EMPTY
49671: LIST
49672: LIST
49673: PUSH
49674: LD_INT 2
49676: NEG
49677: PUSH
49678: LD_INT 2
49680: PUSH
49681: EMPTY
49682: LIST
49683: LIST
49684: PUSH
49685: LD_INT 4
49687: NEG
49688: PUSH
49689: LD_INT 4
49691: NEG
49692: PUSH
49693: EMPTY
49694: LIST
49695: LIST
49696: PUSH
49697: LD_INT 4
49699: NEG
49700: PUSH
49701: LD_INT 5
49703: NEG
49704: PUSH
49705: EMPTY
49706: LIST
49707: LIST
49708: PUSH
49709: LD_INT 3
49711: NEG
49712: PUSH
49713: LD_INT 4
49715: NEG
49716: PUSH
49717: EMPTY
49718: LIST
49719: LIST
49720: PUSH
49721: LD_INT 3
49723: NEG
49724: PUSH
49725: LD_INT 3
49727: NEG
49728: PUSH
49729: EMPTY
49730: LIST
49731: LIST
49732: PUSH
49733: LD_INT 4
49735: NEG
49736: PUSH
49737: LD_INT 3
49739: NEG
49740: PUSH
49741: EMPTY
49742: LIST
49743: LIST
49744: PUSH
49745: LD_INT 5
49747: NEG
49748: PUSH
49749: LD_INT 4
49751: NEG
49752: PUSH
49753: EMPTY
49754: LIST
49755: LIST
49756: PUSH
49757: LD_INT 5
49759: NEG
49760: PUSH
49761: LD_INT 5
49763: NEG
49764: PUSH
49765: EMPTY
49766: LIST
49767: LIST
49768: PUSH
49769: LD_INT 3
49771: NEG
49772: PUSH
49773: LD_INT 5
49775: NEG
49776: PUSH
49777: EMPTY
49778: LIST
49779: LIST
49780: PUSH
49781: LD_INT 5
49783: NEG
49784: PUSH
49785: LD_INT 3
49787: NEG
49788: PUSH
49789: EMPTY
49790: LIST
49791: LIST
49792: PUSH
49793: LD_INT 0
49795: PUSH
49796: LD_INT 3
49798: NEG
49799: PUSH
49800: EMPTY
49801: LIST
49802: LIST
49803: PUSH
49804: LD_INT 0
49806: PUSH
49807: LD_INT 4
49809: NEG
49810: PUSH
49811: EMPTY
49812: LIST
49813: LIST
49814: PUSH
49815: LD_INT 1
49817: PUSH
49818: LD_INT 3
49820: NEG
49821: PUSH
49822: EMPTY
49823: LIST
49824: LIST
49825: PUSH
49826: LD_INT 1
49828: PUSH
49829: LD_INT 2
49831: NEG
49832: PUSH
49833: EMPTY
49834: LIST
49835: LIST
49836: PUSH
49837: LD_INT 0
49839: PUSH
49840: LD_INT 2
49842: NEG
49843: PUSH
49844: EMPTY
49845: LIST
49846: LIST
49847: PUSH
49848: LD_INT 1
49850: NEG
49851: PUSH
49852: LD_INT 3
49854: NEG
49855: PUSH
49856: EMPTY
49857: LIST
49858: LIST
49859: PUSH
49860: LD_INT 1
49862: NEG
49863: PUSH
49864: LD_INT 4
49866: NEG
49867: PUSH
49868: EMPTY
49869: LIST
49870: LIST
49871: PUSH
49872: LD_INT 2
49874: PUSH
49875: LD_INT 2
49877: NEG
49878: PUSH
49879: EMPTY
49880: LIST
49881: LIST
49882: PUSH
49883: LD_INT 2
49885: NEG
49886: PUSH
49887: LD_INT 4
49889: NEG
49890: PUSH
49891: EMPTY
49892: LIST
49893: LIST
49894: PUSH
49895: LD_INT 4
49897: PUSH
49898: LD_INT 0
49900: PUSH
49901: EMPTY
49902: LIST
49903: LIST
49904: PUSH
49905: LD_INT 4
49907: PUSH
49908: LD_INT 1
49910: NEG
49911: PUSH
49912: EMPTY
49913: LIST
49914: LIST
49915: PUSH
49916: LD_INT 5
49918: PUSH
49919: LD_INT 0
49921: PUSH
49922: EMPTY
49923: LIST
49924: LIST
49925: PUSH
49926: LD_INT 5
49928: PUSH
49929: LD_INT 1
49931: PUSH
49932: EMPTY
49933: LIST
49934: LIST
49935: PUSH
49936: LD_INT 4
49938: PUSH
49939: LD_INT 1
49941: PUSH
49942: EMPTY
49943: LIST
49944: LIST
49945: PUSH
49946: LD_INT 3
49948: PUSH
49949: LD_INT 0
49951: PUSH
49952: EMPTY
49953: LIST
49954: LIST
49955: PUSH
49956: LD_INT 3
49958: PUSH
49959: LD_INT 1
49961: NEG
49962: PUSH
49963: EMPTY
49964: LIST
49965: LIST
49966: PUSH
49967: LD_INT 3
49969: PUSH
49970: LD_INT 2
49972: NEG
49973: PUSH
49974: EMPTY
49975: LIST
49976: LIST
49977: PUSH
49978: LD_INT 5
49980: PUSH
49981: LD_INT 2
49983: PUSH
49984: EMPTY
49985: LIST
49986: LIST
49987: PUSH
49988: EMPTY
49989: LIST
49990: LIST
49991: LIST
49992: LIST
49993: LIST
49994: LIST
49995: LIST
49996: LIST
49997: LIST
49998: LIST
49999: LIST
50000: LIST
50001: LIST
50002: LIST
50003: LIST
50004: LIST
50005: LIST
50006: LIST
50007: LIST
50008: LIST
50009: LIST
50010: LIST
50011: LIST
50012: LIST
50013: LIST
50014: LIST
50015: LIST
50016: LIST
50017: LIST
50018: LIST
50019: LIST
50020: LIST
50021: LIST
50022: LIST
50023: LIST
50024: LIST
50025: LIST
50026: LIST
50027: LIST
50028: LIST
50029: LIST
50030: LIST
50031: LIST
50032: LIST
50033: LIST
50034: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
50035: LD_ADDR_VAR 0 32
50039: PUSH
50040: LD_INT 4
50042: NEG
50043: PUSH
50044: LD_INT 0
50046: PUSH
50047: EMPTY
50048: LIST
50049: LIST
50050: PUSH
50051: LD_INT 4
50053: NEG
50054: PUSH
50055: LD_INT 1
50057: NEG
50058: PUSH
50059: EMPTY
50060: LIST
50061: LIST
50062: PUSH
50063: LD_INT 3
50065: NEG
50066: PUSH
50067: LD_INT 0
50069: PUSH
50070: EMPTY
50071: LIST
50072: LIST
50073: PUSH
50074: LD_INT 3
50076: NEG
50077: PUSH
50078: LD_INT 1
50080: PUSH
50081: EMPTY
50082: LIST
50083: LIST
50084: PUSH
50085: LD_INT 4
50087: NEG
50088: PUSH
50089: LD_INT 1
50091: PUSH
50092: EMPTY
50093: LIST
50094: LIST
50095: PUSH
50096: LD_INT 5
50098: NEG
50099: PUSH
50100: LD_INT 0
50102: PUSH
50103: EMPTY
50104: LIST
50105: LIST
50106: PUSH
50107: LD_INT 5
50109: NEG
50110: PUSH
50111: LD_INT 1
50113: NEG
50114: PUSH
50115: EMPTY
50116: LIST
50117: LIST
50118: PUSH
50119: LD_INT 5
50121: NEG
50122: PUSH
50123: LD_INT 2
50125: NEG
50126: PUSH
50127: EMPTY
50128: LIST
50129: LIST
50130: PUSH
50131: LD_INT 3
50133: NEG
50134: PUSH
50135: LD_INT 2
50137: PUSH
50138: EMPTY
50139: LIST
50140: LIST
50141: PUSH
50142: LD_INT 3
50144: NEG
50145: PUSH
50146: LD_INT 3
50148: NEG
50149: PUSH
50150: EMPTY
50151: LIST
50152: LIST
50153: PUSH
50154: LD_INT 3
50156: NEG
50157: PUSH
50158: LD_INT 4
50160: NEG
50161: PUSH
50162: EMPTY
50163: LIST
50164: LIST
50165: PUSH
50166: LD_INT 2
50168: NEG
50169: PUSH
50170: LD_INT 3
50172: NEG
50173: PUSH
50174: EMPTY
50175: LIST
50176: LIST
50177: PUSH
50178: LD_INT 2
50180: NEG
50181: PUSH
50182: LD_INT 2
50184: NEG
50185: PUSH
50186: EMPTY
50187: LIST
50188: LIST
50189: PUSH
50190: LD_INT 3
50192: NEG
50193: PUSH
50194: LD_INT 2
50196: NEG
50197: PUSH
50198: EMPTY
50199: LIST
50200: LIST
50201: PUSH
50202: LD_INT 4
50204: NEG
50205: PUSH
50206: LD_INT 3
50208: NEG
50209: PUSH
50210: EMPTY
50211: LIST
50212: LIST
50213: PUSH
50214: LD_INT 4
50216: NEG
50217: PUSH
50218: LD_INT 4
50220: NEG
50221: PUSH
50222: EMPTY
50223: LIST
50224: LIST
50225: PUSH
50226: LD_INT 2
50228: NEG
50229: PUSH
50230: LD_INT 4
50232: NEG
50233: PUSH
50234: EMPTY
50235: LIST
50236: LIST
50237: PUSH
50238: LD_INT 4
50240: NEG
50241: PUSH
50242: LD_INT 2
50244: NEG
50245: PUSH
50246: EMPTY
50247: LIST
50248: LIST
50249: PUSH
50250: LD_INT 0
50252: PUSH
50253: LD_INT 4
50255: NEG
50256: PUSH
50257: EMPTY
50258: LIST
50259: LIST
50260: PUSH
50261: LD_INT 0
50263: PUSH
50264: LD_INT 5
50266: NEG
50267: PUSH
50268: EMPTY
50269: LIST
50270: LIST
50271: PUSH
50272: LD_INT 1
50274: PUSH
50275: LD_INT 4
50277: NEG
50278: PUSH
50279: EMPTY
50280: LIST
50281: LIST
50282: PUSH
50283: LD_INT 1
50285: PUSH
50286: LD_INT 3
50288: NEG
50289: PUSH
50290: EMPTY
50291: LIST
50292: LIST
50293: PUSH
50294: LD_INT 0
50296: PUSH
50297: LD_INT 3
50299: NEG
50300: PUSH
50301: EMPTY
50302: LIST
50303: LIST
50304: PUSH
50305: LD_INT 1
50307: NEG
50308: PUSH
50309: LD_INT 4
50311: NEG
50312: PUSH
50313: EMPTY
50314: LIST
50315: LIST
50316: PUSH
50317: LD_INT 1
50319: NEG
50320: PUSH
50321: LD_INT 5
50323: NEG
50324: PUSH
50325: EMPTY
50326: LIST
50327: LIST
50328: PUSH
50329: LD_INT 2
50331: PUSH
50332: LD_INT 3
50334: NEG
50335: PUSH
50336: EMPTY
50337: LIST
50338: LIST
50339: PUSH
50340: LD_INT 2
50342: NEG
50343: PUSH
50344: LD_INT 5
50346: NEG
50347: PUSH
50348: EMPTY
50349: LIST
50350: LIST
50351: PUSH
50352: LD_INT 3
50354: PUSH
50355: LD_INT 0
50357: PUSH
50358: EMPTY
50359: LIST
50360: LIST
50361: PUSH
50362: LD_INT 3
50364: PUSH
50365: LD_INT 1
50367: NEG
50368: PUSH
50369: EMPTY
50370: LIST
50371: LIST
50372: PUSH
50373: LD_INT 4
50375: PUSH
50376: LD_INT 0
50378: PUSH
50379: EMPTY
50380: LIST
50381: LIST
50382: PUSH
50383: LD_INT 4
50385: PUSH
50386: LD_INT 1
50388: PUSH
50389: EMPTY
50390: LIST
50391: LIST
50392: PUSH
50393: LD_INT 3
50395: PUSH
50396: LD_INT 1
50398: PUSH
50399: EMPTY
50400: LIST
50401: LIST
50402: PUSH
50403: LD_INT 2
50405: PUSH
50406: LD_INT 0
50408: PUSH
50409: EMPTY
50410: LIST
50411: LIST
50412: PUSH
50413: LD_INT 2
50415: PUSH
50416: LD_INT 1
50418: NEG
50419: PUSH
50420: EMPTY
50421: LIST
50422: LIST
50423: PUSH
50424: LD_INT 2
50426: PUSH
50427: LD_INT 2
50429: NEG
50430: PUSH
50431: EMPTY
50432: LIST
50433: LIST
50434: PUSH
50435: LD_INT 4
50437: PUSH
50438: LD_INT 2
50440: PUSH
50441: EMPTY
50442: LIST
50443: LIST
50444: PUSH
50445: LD_INT 4
50447: PUSH
50448: LD_INT 4
50450: PUSH
50451: EMPTY
50452: LIST
50453: LIST
50454: PUSH
50455: LD_INT 4
50457: PUSH
50458: LD_INT 3
50460: PUSH
50461: EMPTY
50462: LIST
50463: LIST
50464: PUSH
50465: LD_INT 5
50467: PUSH
50468: LD_INT 4
50470: PUSH
50471: EMPTY
50472: LIST
50473: LIST
50474: PUSH
50475: LD_INT 5
50477: PUSH
50478: LD_INT 5
50480: PUSH
50481: EMPTY
50482: LIST
50483: LIST
50484: PUSH
50485: LD_INT 4
50487: PUSH
50488: LD_INT 5
50490: PUSH
50491: EMPTY
50492: LIST
50493: LIST
50494: PUSH
50495: LD_INT 3
50497: PUSH
50498: LD_INT 4
50500: PUSH
50501: EMPTY
50502: LIST
50503: LIST
50504: PUSH
50505: LD_INT 3
50507: PUSH
50508: LD_INT 3
50510: PUSH
50511: EMPTY
50512: LIST
50513: LIST
50514: PUSH
50515: LD_INT 5
50517: PUSH
50518: LD_INT 3
50520: PUSH
50521: EMPTY
50522: LIST
50523: LIST
50524: PUSH
50525: LD_INT 3
50527: PUSH
50528: LD_INT 5
50530: PUSH
50531: EMPTY
50532: LIST
50533: LIST
50534: PUSH
50535: EMPTY
50536: LIST
50537: LIST
50538: LIST
50539: LIST
50540: LIST
50541: LIST
50542: LIST
50543: LIST
50544: LIST
50545: LIST
50546: LIST
50547: LIST
50548: LIST
50549: LIST
50550: LIST
50551: LIST
50552: LIST
50553: LIST
50554: LIST
50555: LIST
50556: LIST
50557: LIST
50558: LIST
50559: LIST
50560: LIST
50561: LIST
50562: LIST
50563: LIST
50564: LIST
50565: LIST
50566: LIST
50567: LIST
50568: LIST
50569: LIST
50570: LIST
50571: LIST
50572: LIST
50573: LIST
50574: LIST
50575: LIST
50576: LIST
50577: LIST
50578: LIST
50579: LIST
50580: LIST
50581: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
50582: LD_ADDR_VAR 0 33
50586: PUSH
50587: LD_INT 4
50589: NEG
50590: PUSH
50591: LD_INT 4
50593: NEG
50594: PUSH
50595: EMPTY
50596: LIST
50597: LIST
50598: PUSH
50599: LD_INT 4
50601: NEG
50602: PUSH
50603: LD_INT 5
50605: NEG
50606: PUSH
50607: EMPTY
50608: LIST
50609: LIST
50610: PUSH
50611: LD_INT 3
50613: NEG
50614: PUSH
50615: LD_INT 4
50617: NEG
50618: PUSH
50619: EMPTY
50620: LIST
50621: LIST
50622: PUSH
50623: LD_INT 3
50625: NEG
50626: PUSH
50627: LD_INT 3
50629: NEG
50630: PUSH
50631: EMPTY
50632: LIST
50633: LIST
50634: PUSH
50635: LD_INT 4
50637: NEG
50638: PUSH
50639: LD_INT 3
50641: NEG
50642: PUSH
50643: EMPTY
50644: LIST
50645: LIST
50646: PUSH
50647: LD_INT 5
50649: NEG
50650: PUSH
50651: LD_INT 4
50653: NEG
50654: PUSH
50655: EMPTY
50656: LIST
50657: LIST
50658: PUSH
50659: LD_INT 5
50661: NEG
50662: PUSH
50663: LD_INT 5
50665: NEG
50666: PUSH
50667: EMPTY
50668: LIST
50669: LIST
50670: PUSH
50671: LD_INT 3
50673: NEG
50674: PUSH
50675: LD_INT 5
50677: NEG
50678: PUSH
50679: EMPTY
50680: LIST
50681: LIST
50682: PUSH
50683: LD_INT 5
50685: NEG
50686: PUSH
50687: LD_INT 3
50689: NEG
50690: PUSH
50691: EMPTY
50692: LIST
50693: LIST
50694: PUSH
50695: LD_INT 0
50697: PUSH
50698: LD_INT 3
50700: NEG
50701: PUSH
50702: EMPTY
50703: LIST
50704: LIST
50705: PUSH
50706: LD_INT 0
50708: PUSH
50709: LD_INT 4
50711: NEG
50712: PUSH
50713: EMPTY
50714: LIST
50715: LIST
50716: PUSH
50717: LD_INT 1
50719: PUSH
50720: LD_INT 3
50722: NEG
50723: PUSH
50724: EMPTY
50725: LIST
50726: LIST
50727: PUSH
50728: LD_INT 1
50730: PUSH
50731: LD_INT 2
50733: NEG
50734: PUSH
50735: EMPTY
50736: LIST
50737: LIST
50738: PUSH
50739: LD_INT 0
50741: PUSH
50742: LD_INT 2
50744: NEG
50745: PUSH
50746: EMPTY
50747: LIST
50748: LIST
50749: PUSH
50750: LD_INT 1
50752: NEG
50753: PUSH
50754: LD_INT 3
50756: NEG
50757: PUSH
50758: EMPTY
50759: LIST
50760: LIST
50761: PUSH
50762: LD_INT 1
50764: NEG
50765: PUSH
50766: LD_INT 4
50768: NEG
50769: PUSH
50770: EMPTY
50771: LIST
50772: LIST
50773: PUSH
50774: LD_INT 2
50776: PUSH
50777: LD_INT 2
50779: NEG
50780: PUSH
50781: EMPTY
50782: LIST
50783: LIST
50784: PUSH
50785: LD_INT 2
50787: NEG
50788: PUSH
50789: LD_INT 4
50791: NEG
50792: PUSH
50793: EMPTY
50794: LIST
50795: LIST
50796: PUSH
50797: LD_INT 4
50799: PUSH
50800: LD_INT 0
50802: PUSH
50803: EMPTY
50804: LIST
50805: LIST
50806: PUSH
50807: LD_INT 4
50809: PUSH
50810: LD_INT 1
50812: NEG
50813: PUSH
50814: EMPTY
50815: LIST
50816: LIST
50817: PUSH
50818: LD_INT 5
50820: PUSH
50821: LD_INT 0
50823: PUSH
50824: EMPTY
50825: LIST
50826: LIST
50827: PUSH
50828: LD_INT 5
50830: PUSH
50831: LD_INT 1
50833: PUSH
50834: EMPTY
50835: LIST
50836: LIST
50837: PUSH
50838: LD_INT 4
50840: PUSH
50841: LD_INT 1
50843: PUSH
50844: EMPTY
50845: LIST
50846: LIST
50847: PUSH
50848: LD_INT 3
50850: PUSH
50851: LD_INT 0
50853: PUSH
50854: EMPTY
50855: LIST
50856: LIST
50857: PUSH
50858: LD_INT 3
50860: PUSH
50861: LD_INT 1
50863: NEG
50864: PUSH
50865: EMPTY
50866: LIST
50867: LIST
50868: PUSH
50869: LD_INT 3
50871: PUSH
50872: LD_INT 2
50874: NEG
50875: PUSH
50876: EMPTY
50877: LIST
50878: LIST
50879: PUSH
50880: LD_INT 5
50882: PUSH
50883: LD_INT 2
50885: PUSH
50886: EMPTY
50887: LIST
50888: LIST
50889: PUSH
50890: LD_INT 3
50892: PUSH
50893: LD_INT 3
50895: PUSH
50896: EMPTY
50897: LIST
50898: LIST
50899: PUSH
50900: LD_INT 3
50902: PUSH
50903: LD_INT 2
50905: PUSH
50906: EMPTY
50907: LIST
50908: LIST
50909: PUSH
50910: LD_INT 4
50912: PUSH
50913: LD_INT 3
50915: PUSH
50916: EMPTY
50917: LIST
50918: LIST
50919: PUSH
50920: LD_INT 4
50922: PUSH
50923: LD_INT 4
50925: PUSH
50926: EMPTY
50927: LIST
50928: LIST
50929: PUSH
50930: LD_INT 3
50932: PUSH
50933: LD_INT 4
50935: PUSH
50936: EMPTY
50937: LIST
50938: LIST
50939: PUSH
50940: LD_INT 2
50942: PUSH
50943: LD_INT 3
50945: PUSH
50946: EMPTY
50947: LIST
50948: LIST
50949: PUSH
50950: LD_INT 2
50952: PUSH
50953: LD_INT 2
50955: PUSH
50956: EMPTY
50957: LIST
50958: LIST
50959: PUSH
50960: LD_INT 4
50962: PUSH
50963: LD_INT 2
50965: PUSH
50966: EMPTY
50967: LIST
50968: LIST
50969: PUSH
50970: LD_INT 2
50972: PUSH
50973: LD_INT 4
50975: PUSH
50976: EMPTY
50977: LIST
50978: LIST
50979: PUSH
50980: LD_INT 0
50982: PUSH
50983: LD_INT 4
50985: PUSH
50986: EMPTY
50987: LIST
50988: LIST
50989: PUSH
50990: LD_INT 0
50992: PUSH
50993: LD_INT 3
50995: PUSH
50996: EMPTY
50997: LIST
50998: LIST
50999: PUSH
51000: LD_INT 1
51002: PUSH
51003: LD_INT 4
51005: PUSH
51006: EMPTY
51007: LIST
51008: LIST
51009: PUSH
51010: LD_INT 1
51012: PUSH
51013: LD_INT 5
51015: PUSH
51016: EMPTY
51017: LIST
51018: LIST
51019: PUSH
51020: LD_INT 0
51022: PUSH
51023: LD_INT 5
51025: PUSH
51026: EMPTY
51027: LIST
51028: LIST
51029: PUSH
51030: LD_INT 1
51032: NEG
51033: PUSH
51034: LD_INT 4
51036: PUSH
51037: EMPTY
51038: LIST
51039: LIST
51040: PUSH
51041: LD_INT 1
51043: NEG
51044: PUSH
51045: LD_INT 3
51047: PUSH
51048: EMPTY
51049: LIST
51050: LIST
51051: PUSH
51052: LD_INT 2
51054: PUSH
51055: LD_INT 5
51057: PUSH
51058: EMPTY
51059: LIST
51060: LIST
51061: PUSH
51062: LD_INT 2
51064: NEG
51065: PUSH
51066: LD_INT 3
51068: PUSH
51069: EMPTY
51070: LIST
51071: LIST
51072: PUSH
51073: EMPTY
51074: LIST
51075: LIST
51076: LIST
51077: LIST
51078: LIST
51079: LIST
51080: LIST
51081: LIST
51082: LIST
51083: LIST
51084: LIST
51085: LIST
51086: LIST
51087: LIST
51088: LIST
51089: LIST
51090: LIST
51091: LIST
51092: LIST
51093: LIST
51094: LIST
51095: LIST
51096: LIST
51097: LIST
51098: LIST
51099: LIST
51100: LIST
51101: LIST
51102: LIST
51103: LIST
51104: LIST
51105: LIST
51106: LIST
51107: LIST
51108: LIST
51109: LIST
51110: LIST
51111: LIST
51112: LIST
51113: LIST
51114: LIST
51115: LIST
51116: LIST
51117: LIST
51118: LIST
51119: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
51120: LD_ADDR_VAR 0 34
51124: PUSH
51125: LD_INT 0
51127: PUSH
51128: LD_INT 4
51130: NEG
51131: PUSH
51132: EMPTY
51133: LIST
51134: LIST
51135: PUSH
51136: LD_INT 0
51138: PUSH
51139: LD_INT 5
51141: NEG
51142: PUSH
51143: EMPTY
51144: LIST
51145: LIST
51146: PUSH
51147: LD_INT 1
51149: PUSH
51150: LD_INT 4
51152: NEG
51153: PUSH
51154: EMPTY
51155: LIST
51156: LIST
51157: PUSH
51158: LD_INT 1
51160: PUSH
51161: LD_INT 3
51163: NEG
51164: PUSH
51165: EMPTY
51166: LIST
51167: LIST
51168: PUSH
51169: LD_INT 0
51171: PUSH
51172: LD_INT 3
51174: NEG
51175: PUSH
51176: EMPTY
51177: LIST
51178: LIST
51179: PUSH
51180: LD_INT 1
51182: NEG
51183: PUSH
51184: LD_INT 4
51186: NEG
51187: PUSH
51188: EMPTY
51189: LIST
51190: LIST
51191: PUSH
51192: LD_INT 1
51194: NEG
51195: PUSH
51196: LD_INT 5
51198: NEG
51199: PUSH
51200: EMPTY
51201: LIST
51202: LIST
51203: PUSH
51204: LD_INT 2
51206: PUSH
51207: LD_INT 3
51209: NEG
51210: PUSH
51211: EMPTY
51212: LIST
51213: LIST
51214: PUSH
51215: LD_INT 2
51217: NEG
51218: PUSH
51219: LD_INT 5
51221: NEG
51222: PUSH
51223: EMPTY
51224: LIST
51225: LIST
51226: PUSH
51227: LD_INT 3
51229: PUSH
51230: LD_INT 0
51232: PUSH
51233: EMPTY
51234: LIST
51235: LIST
51236: PUSH
51237: LD_INT 3
51239: PUSH
51240: LD_INT 1
51242: NEG
51243: PUSH
51244: EMPTY
51245: LIST
51246: LIST
51247: PUSH
51248: LD_INT 4
51250: PUSH
51251: LD_INT 0
51253: PUSH
51254: EMPTY
51255: LIST
51256: LIST
51257: PUSH
51258: LD_INT 4
51260: PUSH
51261: LD_INT 1
51263: PUSH
51264: EMPTY
51265: LIST
51266: LIST
51267: PUSH
51268: LD_INT 3
51270: PUSH
51271: LD_INT 1
51273: PUSH
51274: EMPTY
51275: LIST
51276: LIST
51277: PUSH
51278: LD_INT 2
51280: PUSH
51281: LD_INT 0
51283: PUSH
51284: EMPTY
51285: LIST
51286: LIST
51287: PUSH
51288: LD_INT 2
51290: PUSH
51291: LD_INT 1
51293: NEG
51294: PUSH
51295: EMPTY
51296: LIST
51297: LIST
51298: PUSH
51299: LD_INT 2
51301: PUSH
51302: LD_INT 2
51304: NEG
51305: PUSH
51306: EMPTY
51307: LIST
51308: LIST
51309: PUSH
51310: LD_INT 4
51312: PUSH
51313: LD_INT 2
51315: PUSH
51316: EMPTY
51317: LIST
51318: LIST
51319: PUSH
51320: LD_INT 4
51322: PUSH
51323: LD_INT 4
51325: PUSH
51326: EMPTY
51327: LIST
51328: LIST
51329: PUSH
51330: LD_INT 4
51332: PUSH
51333: LD_INT 3
51335: PUSH
51336: EMPTY
51337: LIST
51338: LIST
51339: PUSH
51340: LD_INT 5
51342: PUSH
51343: LD_INT 4
51345: PUSH
51346: EMPTY
51347: LIST
51348: LIST
51349: PUSH
51350: LD_INT 5
51352: PUSH
51353: LD_INT 5
51355: PUSH
51356: EMPTY
51357: LIST
51358: LIST
51359: PUSH
51360: LD_INT 4
51362: PUSH
51363: LD_INT 5
51365: PUSH
51366: EMPTY
51367: LIST
51368: LIST
51369: PUSH
51370: LD_INT 3
51372: PUSH
51373: LD_INT 4
51375: PUSH
51376: EMPTY
51377: LIST
51378: LIST
51379: PUSH
51380: LD_INT 3
51382: PUSH
51383: LD_INT 3
51385: PUSH
51386: EMPTY
51387: LIST
51388: LIST
51389: PUSH
51390: LD_INT 5
51392: PUSH
51393: LD_INT 3
51395: PUSH
51396: EMPTY
51397: LIST
51398: LIST
51399: PUSH
51400: LD_INT 3
51402: PUSH
51403: LD_INT 5
51405: PUSH
51406: EMPTY
51407: LIST
51408: LIST
51409: PUSH
51410: LD_INT 0
51412: PUSH
51413: LD_INT 3
51415: PUSH
51416: EMPTY
51417: LIST
51418: LIST
51419: PUSH
51420: LD_INT 0
51422: PUSH
51423: LD_INT 2
51425: PUSH
51426: EMPTY
51427: LIST
51428: LIST
51429: PUSH
51430: LD_INT 1
51432: PUSH
51433: LD_INT 3
51435: PUSH
51436: EMPTY
51437: LIST
51438: LIST
51439: PUSH
51440: LD_INT 1
51442: PUSH
51443: LD_INT 4
51445: PUSH
51446: EMPTY
51447: LIST
51448: LIST
51449: PUSH
51450: LD_INT 0
51452: PUSH
51453: LD_INT 4
51455: PUSH
51456: EMPTY
51457: LIST
51458: LIST
51459: PUSH
51460: LD_INT 1
51462: NEG
51463: PUSH
51464: LD_INT 3
51466: PUSH
51467: EMPTY
51468: LIST
51469: LIST
51470: PUSH
51471: LD_INT 1
51473: NEG
51474: PUSH
51475: LD_INT 2
51477: PUSH
51478: EMPTY
51479: LIST
51480: LIST
51481: PUSH
51482: LD_INT 2
51484: PUSH
51485: LD_INT 4
51487: PUSH
51488: EMPTY
51489: LIST
51490: LIST
51491: PUSH
51492: LD_INT 2
51494: NEG
51495: PUSH
51496: LD_INT 2
51498: PUSH
51499: EMPTY
51500: LIST
51501: LIST
51502: PUSH
51503: LD_INT 4
51505: NEG
51506: PUSH
51507: LD_INT 0
51509: PUSH
51510: EMPTY
51511: LIST
51512: LIST
51513: PUSH
51514: LD_INT 4
51516: NEG
51517: PUSH
51518: LD_INT 1
51520: NEG
51521: PUSH
51522: EMPTY
51523: LIST
51524: LIST
51525: PUSH
51526: LD_INT 3
51528: NEG
51529: PUSH
51530: LD_INT 0
51532: PUSH
51533: EMPTY
51534: LIST
51535: LIST
51536: PUSH
51537: LD_INT 3
51539: NEG
51540: PUSH
51541: LD_INT 1
51543: PUSH
51544: EMPTY
51545: LIST
51546: LIST
51547: PUSH
51548: LD_INT 4
51550: NEG
51551: PUSH
51552: LD_INT 1
51554: PUSH
51555: EMPTY
51556: LIST
51557: LIST
51558: PUSH
51559: LD_INT 5
51561: NEG
51562: PUSH
51563: LD_INT 0
51565: PUSH
51566: EMPTY
51567: LIST
51568: LIST
51569: PUSH
51570: LD_INT 5
51572: NEG
51573: PUSH
51574: LD_INT 1
51576: NEG
51577: PUSH
51578: EMPTY
51579: LIST
51580: LIST
51581: PUSH
51582: LD_INT 5
51584: NEG
51585: PUSH
51586: LD_INT 2
51588: NEG
51589: PUSH
51590: EMPTY
51591: LIST
51592: LIST
51593: PUSH
51594: LD_INT 3
51596: NEG
51597: PUSH
51598: LD_INT 2
51600: PUSH
51601: EMPTY
51602: LIST
51603: LIST
51604: PUSH
51605: EMPTY
51606: LIST
51607: LIST
51608: LIST
51609: LIST
51610: LIST
51611: LIST
51612: LIST
51613: LIST
51614: LIST
51615: LIST
51616: LIST
51617: LIST
51618: LIST
51619: LIST
51620: LIST
51621: LIST
51622: LIST
51623: LIST
51624: LIST
51625: LIST
51626: LIST
51627: LIST
51628: LIST
51629: LIST
51630: LIST
51631: LIST
51632: LIST
51633: LIST
51634: LIST
51635: LIST
51636: LIST
51637: LIST
51638: LIST
51639: LIST
51640: LIST
51641: LIST
51642: LIST
51643: LIST
51644: LIST
51645: LIST
51646: LIST
51647: LIST
51648: LIST
51649: LIST
51650: LIST
51651: ST_TO_ADDR
// end ; end ;
51652: GO 51655
51654: POP
// case btype of b_depot , b_warehouse :
51655: LD_VAR 0 1
51659: PUSH
51660: LD_INT 0
51662: DOUBLE
51663: EQUAL
51664: IFTRUE 51674
51666: LD_INT 1
51668: DOUBLE
51669: EQUAL
51670: IFTRUE 51674
51672: GO 51875
51674: POP
// case nation of nation_american :
51675: LD_VAR 0 5
51679: PUSH
51680: LD_INT 1
51682: DOUBLE
51683: EQUAL
51684: IFTRUE 51688
51686: GO 51744
51688: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
51689: LD_ADDR_VAR 0 9
51693: PUSH
51694: LD_VAR 0 11
51698: PUSH
51699: LD_VAR 0 12
51703: PUSH
51704: LD_VAR 0 13
51708: PUSH
51709: LD_VAR 0 14
51713: PUSH
51714: LD_VAR 0 15
51718: PUSH
51719: LD_VAR 0 16
51723: PUSH
51724: EMPTY
51725: LIST
51726: LIST
51727: LIST
51728: LIST
51729: LIST
51730: LIST
51731: PUSH
51732: LD_VAR 0 4
51736: PUSH
51737: LD_INT 1
51739: PLUS
51740: ARRAY
51741: ST_TO_ADDR
51742: GO 51873
51744: LD_INT 2
51746: DOUBLE
51747: EQUAL
51748: IFTRUE 51752
51750: GO 51808
51752: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
51753: LD_ADDR_VAR 0 9
51757: PUSH
51758: LD_VAR 0 17
51762: PUSH
51763: LD_VAR 0 18
51767: PUSH
51768: LD_VAR 0 19
51772: PUSH
51773: LD_VAR 0 20
51777: PUSH
51778: LD_VAR 0 21
51782: PUSH
51783: LD_VAR 0 22
51787: PUSH
51788: EMPTY
51789: LIST
51790: LIST
51791: LIST
51792: LIST
51793: LIST
51794: LIST
51795: PUSH
51796: LD_VAR 0 4
51800: PUSH
51801: LD_INT 1
51803: PLUS
51804: ARRAY
51805: ST_TO_ADDR
51806: GO 51873
51808: LD_INT 3
51810: DOUBLE
51811: EQUAL
51812: IFTRUE 51816
51814: GO 51872
51816: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
51817: LD_ADDR_VAR 0 9
51821: PUSH
51822: LD_VAR 0 23
51826: PUSH
51827: LD_VAR 0 24
51831: PUSH
51832: LD_VAR 0 25
51836: PUSH
51837: LD_VAR 0 26
51841: PUSH
51842: LD_VAR 0 27
51846: PUSH
51847: LD_VAR 0 28
51851: PUSH
51852: EMPTY
51853: LIST
51854: LIST
51855: LIST
51856: LIST
51857: LIST
51858: LIST
51859: PUSH
51860: LD_VAR 0 4
51864: PUSH
51865: LD_INT 1
51867: PLUS
51868: ARRAY
51869: ST_TO_ADDR
51870: GO 51873
51872: POP
51873: GO 52428
51875: LD_INT 2
51877: DOUBLE
51878: EQUAL
51879: IFTRUE 51889
51881: LD_INT 3
51883: DOUBLE
51884: EQUAL
51885: IFTRUE 51889
51887: GO 51945
51889: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
51890: LD_ADDR_VAR 0 9
51894: PUSH
51895: LD_VAR 0 29
51899: PUSH
51900: LD_VAR 0 30
51904: PUSH
51905: LD_VAR 0 31
51909: PUSH
51910: LD_VAR 0 32
51914: PUSH
51915: LD_VAR 0 33
51919: PUSH
51920: LD_VAR 0 34
51924: PUSH
51925: EMPTY
51926: LIST
51927: LIST
51928: LIST
51929: LIST
51930: LIST
51931: LIST
51932: PUSH
51933: LD_VAR 0 4
51937: PUSH
51938: LD_INT 1
51940: PLUS
51941: ARRAY
51942: ST_TO_ADDR
51943: GO 52428
51945: LD_INT 16
51947: DOUBLE
51948: EQUAL
51949: IFTRUE 52007
51951: LD_INT 17
51953: DOUBLE
51954: EQUAL
51955: IFTRUE 52007
51957: LD_INT 18
51959: DOUBLE
51960: EQUAL
51961: IFTRUE 52007
51963: LD_INT 19
51965: DOUBLE
51966: EQUAL
51967: IFTRUE 52007
51969: LD_INT 22
51971: DOUBLE
51972: EQUAL
51973: IFTRUE 52007
51975: LD_INT 20
51977: DOUBLE
51978: EQUAL
51979: IFTRUE 52007
51981: LD_INT 21
51983: DOUBLE
51984: EQUAL
51985: IFTRUE 52007
51987: LD_INT 23
51989: DOUBLE
51990: EQUAL
51991: IFTRUE 52007
51993: LD_INT 24
51995: DOUBLE
51996: EQUAL
51997: IFTRUE 52007
51999: LD_INT 25
52001: DOUBLE
52002: EQUAL
52003: IFTRUE 52007
52005: GO 52063
52007: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
52008: LD_ADDR_VAR 0 9
52012: PUSH
52013: LD_VAR 0 35
52017: PUSH
52018: LD_VAR 0 36
52022: PUSH
52023: LD_VAR 0 37
52027: PUSH
52028: LD_VAR 0 38
52032: PUSH
52033: LD_VAR 0 39
52037: PUSH
52038: LD_VAR 0 40
52042: PUSH
52043: EMPTY
52044: LIST
52045: LIST
52046: LIST
52047: LIST
52048: LIST
52049: LIST
52050: PUSH
52051: LD_VAR 0 4
52055: PUSH
52056: LD_INT 1
52058: PLUS
52059: ARRAY
52060: ST_TO_ADDR
52061: GO 52428
52063: LD_INT 6
52065: DOUBLE
52066: EQUAL
52067: IFTRUE 52119
52069: LD_INT 7
52071: DOUBLE
52072: EQUAL
52073: IFTRUE 52119
52075: LD_INT 8
52077: DOUBLE
52078: EQUAL
52079: IFTRUE 52119
52081: LD_INT 13
52083: DOUBLE
52084: EQUAL
52085: IFTRUE 52119
52087: LD_INT 12
52089: DOUBLE
52090: EQUAL
52091: IFTRUE 52119
52093: LD_INT 15
52095: DOUBLE
52096: EQUAL
52097: IFTRUE 52119
52099: LD_INT 11
52101: DOUBLE
52102: EQUAL
52103: IFTRUE 52119
52105: LD_INT 14
52107: DOUBLE
52108: EQUAL
52109: IFTRUE 52119
52111: LD_INT 10
52113: DOUBLE
52114: EQUAL
52115: IFTRUE 52119
52117: GO 52175
52119: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
52120: LD_ADDR_VAR 0 9
52124: PUSH
52125: LD_VAR 0 41
52129: PUSH
52130: LD_VAR 0 42
52134: PUSH
52135: LD_VAR 0 43
52139: PUSH
52140: LD_VAR 0 44
52144: PUSH
52145: LD_VAR 0 45
52149: PUSH
52150: LD_VAR 0 46
52154: PUSH
52155: EMPTY
52156: LIST
52157: LIST
52158: LIST
52159: LIST
52160: LIST
52161: LIST
52162: PUSH
52163: LD_VAR 0 4
52167: PUSH
52168: LD_INT 1
52170: PLUS
52171: ARRAY
52172: ST_TO_ADDR
52173: GO 52428
52175: LD_INT 36
52177: DOUBLE
52178: EQUAL
52179: IFTRUE 52183
52181: GO 52239
52183: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
52184: LD_ADDR_VAR 0 9
52188: PUSH
52189: LD_VAR 0 47
52193: PUSH
52194: LD_VAR 0 48
52198: PUSH
52199: LD_VAR 0 49
52203: PUSH
52204: LD_VAR 0 50
52208: PUSH
52209: LD_VAR 0 51
52213: PUSH
52214: LD_VAR 0 52
52218: PUSH
52219: EMPTY
52220: LIST
52221: LIST
52222: LIST
52223: LIST
52224: LIST
52225: LIST
52226: PUSH
52227: LD_VAR 0 4
52231: PUSH
52232: LD_INT 1
52234: PLUS
52235: ARRAY
52236: ST_TO_ADDR
52237: GO 52428
52239: LD_INT 4
52241: DOUBLE
52242: EQUAL
52243: IFTRUE 52265
52245: LD_INT 5
52247: DOUBLE
52248: EQUAL
52249: IFTRUE 52265
52251: LD_INT 34
52253: DOUBLE
52254: EQUAL
52255: IFTRUE 52265
52257: LD_INT 37
52259: DOUBLE
52260: EQUAL
52261: IFTRUE 52265
52263: GO 52321
52265: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
52266: LD_ADDR_VAR 0 9
52270: PUSH
52271: LD_VAR 0 53
52275: PUSH
52276: LD_VAR 0 54
52280: PUSH
52281: LD_VAR 0 55
52285: PUSH
52286: LD_VAR 0 56
52290: PUSH
52291: LD_VAR 0 57
52295: PUSH
52296: LD_VAR 0 58
52300: PUSH
52301: EMPTY
52302: LIST
52303: LIST
52304: LIST
52305: LIST
52306: LIST
52307: LIST
52308: PUSH
52309: LD_VAR 0 4
52313: PUSH
52314: LD_INT 1
52316: PLUS
52317: ARRAY
52318: ST_TO_ADDR
52319: GO 52428
52321: LD_INT 31
52323: DOUBLE
52324: EQUAL
52325: IFTRUE 52371
52327: LD_INT 32
52329: DOUBLE
52330: EQUAL
52331: IFTRUE 52371
52333: LD_INT 33
52335: DOUBLE
52336: EQUAL
52337: IFTRUE 52371
52339: LD_INT 27
52341: DOUBLE
52342: EQUAL
52343: IFTRUE 52371
52345: LD_INT 26
52347: DOUBLE
52348: EQUAL
52349: IFTRUE 52371
52351: LD_INT 28
52353: DOUBLE
52354: EQUAL
52355: IFTRUE 52371
52357: LD_INT 29
52359: DOUBLE
52360: EQUAL
52361: IFTRUE 52371
52363: LD_INT 30
52365: DOUBLE
52366: EQUAL
52367: IFTRUE 52371
52369: GO 52427
52371: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
52372: LD_ADDR_VAR 0 9
52376: PUSH
52377: LD_VAR 0 59
52381: PUSH
52382: LD_VAR 0 60
52386: PUSH
52387: LD_VAR 0 61
52391: PUSH
52392: LD_VAR 0 62
52396: PUSH
52397: LD_VAR 0 63
52401: PUSH
52402: LD_VAR 0 64
52406: PUSH
52407: EMPTY
52408: LIST
52409: LIST
52410: LIST
52411: LIST
52412: LIST
52413: LIST
52414: PUSH
52415: LD_VAR 0 4
52419: PUSH
52420: LD_INT 1
52422: PLUS
52423: ARRAY
52424: ST_TO_ADDR
52425: GO 52428
52427: POP
// temp_list2 = [ ] ;
52428: LD_ADDR_VAR 0 10
52432: PUSH
52433: EMPTY
52434: ST_TO_ADDR
// for i in temp_list do
52435: LD_ADDR_VAR 0 8
52439: PUSH
52440: LD_VAR 0 9
52444: PUSH
52445: FOR_IN
52446: IFFALSE 52498
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
52448: LD_ADDR_VAR 0 10
52452: PUSH
52453: LD_VAR 0 10
52457: PUSH
52458: LD_VAR 0 8
52462: PUSH
52463: LD_INT 1
52465: ARRAY
52466: PUSH
52467: LD_VAR 0 2
52471: PLUS
52472: PUSH
52473: LD_VAR 0 8
52477: PUSH
52478: LD_INT 2
52480: ARRAY
52481: PUSH
52482: LD_VAR 0 3
52486: PLUS
52487: PUSH
52488: EMPTY
52489: LIST
52490: LIST
52491: PUSH
52492: EMPTY
52493: LIST
52494: ADD
52495: ST_TO_ADDR
52496: GO 52445
52498: POP
52499: POP
// result = temp_list2 ;
52500: LD_ADDR_VAR 0 7
52504: PUSH
52505: LD_VAR 0 10
52509: ST_TO_ADDR
// end ;
52510: LD_VAR 0 7
52514: RET
// export function EnemyInRange ( unit , dist ) ; begin
52515: LD_INT 0
52517: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
52518: LD_ADDR_VAR 0 3
52522: PUSH
52523: LD_VAR 0 1
52527: PPUSH
52528: CALL_OW 255
52532: PPUSH
52533: LD_VAR 0 1
52537: PPUSH
52538: CALL_OW 250
52542: PPUSH
52543: LD_VAR 0 1
52547: PPUSH
52548: CALL_OW 251
52552: PPUSH
52553: LD_VAR 0 2
52557: PPUSH
52558: CALL 25917 0 4
52562: PUSH
52563: LD_INT 4
52565: ARRAY
52566: ST_TO_ADDR
// end ;
52567: LD_VAR 0 3
52571: RET
// export function PlayerSeeMe ( unit ) ; begin
52572: LD_INT 0
52574: PPUSH
// result := See ( your_side , unit ) ;
52575: LD_ADDR_VAR 0 2
52579: PUSH
52580: LD_OWVAR 2
52584: PPUSH
52585: LD_VAR 0 1
52589: PPUSH
52590: CALL_OW 292
52594: ST_TO_ADDR
// end ;
52595: LD_VAR 0 2
52599: RET
// export function ReverseDir ( unit ) ; begin
52600: LD_INT 0
52602: PPUSH
// if not unit then
52603: LD_VAR 0 1
52607: NOT
52608: IFFALSE 52612
// exit ;
52610: GO 52635
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
52612: LD_ADDR_VAR 0 2
52616: PUSH
52617: LD_VAR 0 1
52621: PPUSH
52622: CALL_OW 254
52626: PUSH
52627: LD_INT 3
52629: PLUS
52630: PUSH
52631: LD_INT 6
52633: MOD
52634: ST_TO_ADDR
// end ;
52635: LD_VAR 0 2
52639: RET
// export function ReverseArray ( array ) ; var i ; begin
52640: LD_INT 0
52642: PPUSH
52643: PPUSH
// if not array then
52644: LD_VAR 0 1
52648: NOT
52649: IFFALSE 52653
// exit ;
52651: GO 52708
// result := [ ] ;
52653: LD_ADDR_VAR 0 2
52657: PUSH
52658: EMPTY
52659: ST_TO_ADDR
// for i := array downto 1 do
52660: LD_ADDR_VAR 0 3
52664: PUSH
52665: DOUBLE
52666: LD_VAR 0 1
52670: INC
52671: ST_TO_ADDR
52672: LD_INT 1
52674: PUSH
52675: FOR_DOWNTO
52676: IFFALSE 52706
// result := Join ( result , array [ i ] ) ;
52678: LD_ADDR_VAR 0 2
52682: PUSH
52683: LD_VAR 0 2
52687: PPUSH
52688: LD_VAR 0 1
52692: PUSH
52693: LD_VAR 0 3
52697: ARRAY
52698: PPUSH
52699: CALL 57333 0 2
52703: ST_TO_ADDR
52704: GO 52675
52706: POP
52707: POP
// end ;
52708: LD_VAR 0 2
52712: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tdist , tmp , hex ; begin
52713: LD_INT 0
52715: PPUSH
52716: PPUSH
52717: PPUSH
52718: PPUSH
52719: PPUSH
52720: PPUSH
// if not unit or not hexes then
52721: LD_VAR 0 1
52725: NOT
52726: PUSH
52727: LD_VAR 0 2
52731: NOT
52732: OR
52733: IFFALSE 52737
// exit ;
52735: GO 52860
// dist := 9999 ;
52737: LD_ADDR_VAR 0 5
52741: PUSH
52742: LD_INT 9999
52744: ST_TO_ADDR
// for i = 1 to hexes do
52745: LD_ADDR_VAR 0 4
52749: PUSH
52750: DOUBLE
52751: LD_INT 1
52753: DEC
52754: ST_TO_ADDR
52755: LD_VAR 0 2
52759: PUSH
52760: FOR_TO
52761: IFFALSE 52848
// begin tdist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
52763: LD_ADDR_VAR 0 6
52767: PUSH
52768: LD_VAR 0 1
52772: PPUSH
52773: LD_VAR 0 2
52777: PUSH
52778: LD_VAR 0 4
52782: ARRAY
52783: PUSH
52784: LD_INT 1
52786: ARRAY
52787: PPUSH
52788: LD_VAR 0 2
52792: PUSH
52793: LD_VAR 0 4
52797: ARRAY
52798: PUSH
52799: LD_INT 2
52801: ARRAY
52802: PPUSH
52803: CALL_OW 297
52807: ST_TO_ADDR
// if tdist < dist then
52808: LD_VAR 0 6
52812: PUSH
52813: LD_VAR 0 5
52817: LESS
52818: IFFALSE 52846
// begin hex := hexes [ i ] ;
52820: LD_ADDR_VAR 0 8
52824: PUSH
52825: LD_VAR 0 2
52829: PUSH
52830: LD_VAR 0 4
52834: ARRAY
52835: ST_TO_ADDR
// dist := tdist ;
52836: LD_ADDR_VAR 0 5
52840: PUSH
52841: LD_VAR 0 6
52845: ST_TO_ADDR
// end ; end ;
52846: GO 52760
52848: POP
52849: POP
// result := hex ;
52850: LD_ADDR_VAR 0 3
52854: PUSH
52855: LD_VAR 0 8
52859: ST_TO_ADDR
// end ;
52860: LD_VAR 0 3
52864: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
52865: LD_INT 0
52867: PPUSH
52868: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
52869: LD_VAR 0 1
52873: NOT
52874: PUSH
52875: LD_VAR 0 1
52879: PUSH
52880: LD_INT 21
52882: PUSH
52883: LD_INT 2
52885: PUSH
52886: EMPTY
52887: LIST
52888: LIST
52889: PUSH
52890: LD_INT 23
52892: PUSH
52893: LD_INT 2
52895: PUSH
52896: EMPTY
52897: LIST
52898: LIST
52899: PUSH
52900: EMPTY
52901: LIST
52902: LIST
52903: PPUSH
52904: CALL_OW 69
52908: IN
52909: NOT
52910: OR
52911: IFFALSE 52915
// exit ;
52913: GO 52962
// for i = 1 to 3 do
52915: LD_ADDR_VAR 0 3
52919: PUSH
52920: DOUBLE
52921: LD_INT 1
52923: DEC
52924: ST_TO_ADDR
52925: LD_INT 3
52927: PUSH
52928: FOR_TO
52929: IFFALSE 52960
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
52931: LD_VAR 0 1
52935: PPUSH
52936: CALL_OW 250
52940: PPUSH
52941: LD_VAR 0 1
52945: PPUSH
52946: CALL_OW 251
52950: PPUSH
52951: LD_INT 1
52953: PPUSH
52954: CALL_OW 453
52958: GO 52928
52960: POP
52961: POP
// end ;
52962: LD_VAR 0 2
52966: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
52967: LD_INT 0
52969: PPUSH
52970: PPUSH
52971: PPUSH
52972: PPUSH
52973: PPUSH
52974: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
52975: LD_VAR 0 1
52979: NOT
52980: PUSH
52981: LD_VAR 0 2
52985: NOT
52986: OR
52987: PUSH
52988: LD_VAR 0 1
52992: PPUSH
52993: CALL_OW 314
52997: OR
52998: IFFALSE 53002
// exit ;
53000: GO 53443
// x := GetX ( enemy_unit ) ;
53002: LD_ADDR_VAR 0 7
53006: PUSH
53007: LD_VAR 0 2
53011: PPUSH
53012: CALL_OW 250
53016: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
53017: LD_ADDR_VAR 0 8
53021: PUSH
53022: LD_VAR 0 2
53026: PPUSH
53027: CALL_OW 251
53031: ST_TO_ADDR
// if not x or not y then
53032: LD_VAR 0 7
53036: NOT
53037: PUSH
53038: LD_VAR 0 8
53042: NOT
53043: OR
53044: IFFALSE 53048
// exit ;
53046: GO 53443
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
53048: LD_ADDR_VAR 0 6
53052: PUSH
53053: LD_VAR 0 7
53057: PPUSH
53058: LD_INT 0
53060: PPUSH
53061: LD_INT 4
53063: PPUSH
53064: CALL_OW 272
53068: PUSH
53069: LD_VAR 0 8
53073: PPUSH
53074: LD_INT 0
53076: PPUSH
53077: LD_INT 4
53079: PPUSH
53080: CALL_OW 273
53084: PUSH
53085: EMPTY
53086: LIST
53087: LIST
53088: PUSH
53089: LD_VAR 0 7
53093: PPUSH
53094: LD_INT 1
53096: PPUSH
53097: LD_INT 4
53099: PPUSH
53100: CALL_OW 272
53104: PUSH
53105: LD_VAR 0 8
53109: PPUSH
53110: LD_INT 1
53112: PPUSH
53113: LD_INT 4
53115: PPUSH
53116: CALL_OW 273
53120: PUSH
53121: EMPTY
53122: LIST
53123: LIST
53124: PUSH
53125: LD_VAR 0 7
53129: PPUSH
53130: LD_INT 2
53132: PPUSH
53133: LD_INT 4
53135: PPUSH
53136: CALL_OW 272
53140: PUSH
53141: LD_VAR 0 8
53145: PPUSH
53146: LD_INT 2
53148: PPUSH
53149: LD_INT 4
53151: PPUSH
53152: CALL_OW 273
53156: PUSH
53157: EMPTY
53158: LIST
53159: LIST
53160: PUSH
53161: LD_VAR 0 7
53165: PPUSH
53166: LD_INT 3
53168: PPUSH
53169: LD_INT 4
53171: PPUSH
53172: CALL_OW 272
53176: PUSH
53177: LD_VAR 0 8
53181: PPUSH
53182: LD_INT 3
53184: PPUSH
53185: LD_INT 4
53187: PPUSH
53188: CALL_OW 273
53192: PUSH
53193: EMPTY
53194: LIST
53195: LIST
53196: PUSH
53197: LD_VAR 0 7
53201: PPUSH
53202: LD_INT 4
53204: PPUSH
53205: LD_INT 4
53207: PPUSH
53208: CALL_OW 272
53212: PUSH
53213: LD_VAR 0 8
53217: PPUSH
53218: LD_INT 4
53220: PPUSH
53221: LD_INT 4
53223: PPUSH
53224: CALL_OW 273
53228: PUSH
53229: EMPTY
53230: LIST
53231: LIST
53232: PUSH
53233: LD_VAR 0 7
53237: PPUSH
53238: LD_INT 5
53240: PPUSH
53241: LD_INT 4
53243: PPUSH
53244: CALL_OW 272
53248: PUSH
53249: LD_VAR 0 8
53253: PPUSH
53254: LD_INT 5
53256: PPUSH
53257: LD_INT 4
53259: PPUSH
53260: CALL_OW 273
53264: PUSH
53265: EMPTY
53266: LIST
53267: LIST
53268: PUSH
53269: EMPTY
53270: LIST
53271: LIST
53272: LIST
53273: LIST
53274: LIST
53275: LIST
53276: ST_TO_ADDR
// for i = tmp downto 1 do
53277: LD_ADDR_VAR 0 4
53281: PUSH
53282: DOUBLE
53283: LD_VAR 0 6
53287: INC
53288: ST_TO_ADDR
53289: LD_INT 1
53291: PUSH
53292: FOR_DOWNTO
53293: IFFALSE 53394
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
53295: LD_VAR 0 6
53299: PUSH
53300: LD_VAR 0 4
53304: ARRAY
53305: PUSH
53306: LD_INT 1
53308: ARRAY
53309: PPUSH
53310: LD_VAR 0 6
53314: PUSH
53315: LD_VAR 0 4
53319: ARRAY
53320: PUSH
53321: LD_INT 2
53323: ARRAY
53324: PPUSH
53325: CALL_OW 488
53329: NOT
53330: PUSH
53331: LD_VAR 0 6
53335: PUSH
53336: LD_VAR 0 4
53340: ARRAY
53341: PUSH
53342: LD_INT 1
53344: ARRAY
53345: PPUSH
53346: LD_VAR 0 6
53350: PUSH
53351: LD_VAR 0 4
53355: ARRAY
53356: PUSH
53357: LD_INT 2
53359: ARRAY
53360: PPUSH
53361: CALL_OW 428
53365: PUSH
53366: LD_INT 0
53368: NONEQUAL
53369: OR
53370: IFFALSE 53392
// tmp := Delete ( tmp , i ) ;
53372: LD_ADDR_VAR 0 6
53376: PUSH
53377: LD_VAR 0 6
53381: PPUSH
53382: LD_VAR 0 4
53386: PPUSH
53387: CALL_OW 3
53391: ST_TO_ADDR
53392: GO 53292
53394: POP
53395: POP
// j := GetClosestHex ( unit , tmp ) ;
53396: LD_ADDR_VAR 0 5
53400: PUSH
53401: LD_VAR 0 1
53405: PPUSH
53406: LD_VAR 0 6
53410: PPUSH
53411: CALL 52713 0 2
53415: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
53416: LD_VAR 0 1
53420: PPUSH
53421: LD_VAR 0 5
53425: PUSH
53426: LD_INT 1
53428: ARRAY
53429: PPUSH
53430: LD_VAR 0 5
53434: PUSH
53435: LD_INT 2
53437: ARRAY
53438: PPUSH
53439: CALL_OW 111
// end ;
53443: LD_VAR 0 3
53447: RET
// export function PrepareApemanSoldier ( ) ; begin
53448: LD_INT 0
53450: PPUSH
// uc_nation := 0 ;
53451: LD_ADDR_OWVAR 21
53455: PUSH
53456: LD_INT 0
53458: ST_TO_ADDR
// hc_sex := sex_male ;
53459: LD_ADDR_OWVAR 27
53463: PUSH
53464: LD_INT 1
53466: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
53467: LD_ADDR_OWVAR 28
53471: PUSH
53472: LD_INT 15
53474: ST_TO_ADDR
// hc_gallery :=  ;
53475: LD_ADDR_OWVAR 33
53479: PUSH
53480: LD_STRING 
53482: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
53483: LD_ADDR_OWVAR 31
53487: PUSH
53488: LD_INT 0
53490: PPUSH
53491: LD_INT 3
53493: PPUSH
53494: CALL_OW 12
53498: PUSH
53499: LD_INT 0
53501: PPUSH
53502: LD_INT 3
53504: PPUSH
53505: CALL_OW 12
53509: PUSH
53510: LD_INT 0
53512: PUSH
53513: LD_INT 0
53515: PUSH
53516: EMPTY
53517: LIST
53518: LIST
53519: LIST
53520: LIST
53521: ST_TO_ADDR
// end ;
53522: LD_VAR 0 1
53526: RET
// export function PrepareApemanEngineer ( ) ; begin
53527: LD_INT 0
53529: PPUSH
// uc_nation := 0 ;
53530: LD_ADDR_OWVAR 21
53534: PUSH
53535: LD_INT 0
53537: ST_TO_ADDR
// hc_sex := sex_male ;
53538: LD_ADDR_OWVAR 27
53542: PUSH
53543: LD_INT 1
53545: ST_TO_ADDR
// hc_class := class_apeman_engineer ;
53546: LD_ADDR_OWVAR 28
53550: PUSH
53551: LD_INT 16
53553: ST_TO_ADDR
// hc_gallery :=  ;
53554: LD_ADDR_OWVAR 33
53558: PUSH
53559: LD_STRING 
53561: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
53562: LD_ADDR_OWVAR 31
53566: PUSH
53567: LD_INT 0
53569: PPUSH
53570: LD_INT 3
53572: PPUSH
53573: CALL_OW 12
53577: PUSH
53578: LD_INT 0
53580: PPUSH
53581: LD_INT 3
53583: PPUSH
53584: CALL_OW 12
53588: PUSH
53589: LD_INT 0
53591: PUSH
53592: LD_INT 0
53594: PUSH
53595: EMPTY
53596: LIST
53597: LIST
53598: LIST
53599: LIST
53600: ST_TO_ADDR
// end ;
53601: LD_VAR 0 1
53605: RET
// export function PrepareApeman ( agressivity ) ; begin
53606: LD_INT 0
53608: PPUSH
// uc_side := 0 ;
53609: LD_ADDR_OWVAR 20
53613: PUSH
53614: LD_INT 0
53616: ST_TO_ADDR
// uc_nation := 0 ;
53617: LD_ADDR_OWVAR 21
53621: PUSH
53622: LD_INT 0
53624: ST_TO_ADDR
// hc_sex := sex_male ;
53625: LD_ADDR_OWVAR 27
53629: PUSH
53630: LD_INT 1
53632: ST_TO_ADDR
// hc_class := class_apeman ;
53633: LD_ADDR_OWVAR 28
53637: PUSH
53638: LD_INT 12
53640: ST_TO_ADDR
// hc_gallery :=  ;
53641: LD_ADDR_OWVAR 33
53645: PUSH
53646: LD_STRING 
53648: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
53649: LD_ADDR_OWVAR 35
53653: PUSH
53654: LD_VAR 0 1
53658: NEG
53659: PPUSH
53660: LD_VAR 0 1
53664: PPUSH
53665: CALL_OW 12
53669: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
53670: LD_ADDR_OWVAR 31
53674: PUSH
53675: LD_INT 0
53677: PPUSH
53678: LD_INT 3
53680: PPUSH
53681: CALL_OW 12
53685: PUSH
53686: LD_INT 0
53688: PPUSH
53689: LD_INT 3
53691: PPUSH
53692: CALL_OW 12
53696: PUSH
53697: LD_INT 0
53699: PUSH
53700: LD_INT 0
53702: PUSH
53703: EMPTY
53704: LIST
53705: LIST
53706: LIST
53707: LIST
53708: ST_TO_ADDR
// end ;
53709: LD_VAR 0 2
53713: RET
// export function PrepareTiger ( agressivity ) ; begin
53714: LD_INT 0
53716: PPUSH
// uc_side := 0 ;
53717: LD_ADDR_OWVAR 20
53721: PUSH
53722: LD_INT 0
53724: ST_TO_ADDR
// uc_nation := 0 ;
53725: LD_ADDR_OWVAR 21
53729: PUSH
53730: LD_INT 0
53732: ST_TO_ADDR
// hc_class := class_tiger ;
53733: LD_ADDR_OWVAR 28
53737: PUSH
53738: LD_INT 14
53740: ST_TO_ADDR
// hc_gallery :=  ;
53741: LD_ADDR_OWVAR 33
53745: PUSH
53746: LD_STRING 
53748: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
53749: LD_ADDR_OWVAR 35
53753: PUSH
53754: LD_VAR 0 1
53758: NEG
53759: PPUSH
53760: LD_VAR 0 1
53764: PPUSH
53765: CALL_OW 12
53769: ST_TO_ADDR
// end ;
53770: LD_VAR 0 2
53774: RET
// export function PrepareEnchidna ( ) ; begin
53775: LD_INT 0
53777: PPUSH
// uc_side := 0 ;
53778: LD_ADDR_OWVAR 20
53782: PUSH
53783: LD_INT 0
53785: ST_TO_ADDR
// uc_nation := 0 ;
53786: LD_ADDR_OWVAR 21
53790: PUSH
53791: LD_INT 0
53793: ST_TO_ADDR
// hc_class := class_baggie ;
53794: LD_ADDR_OWVAR 28
53798: PUSH
53799: LD_INT 13
53801: ST_TO_ADDR
// hc_gallery :=  ;
53802: LD_ADDR_OWVAR 33
53806: PUSH
53807: LD_STRING 
53809: ST_TO_ADDR
// end ;
53810: LD_VAR 0 1
53814: RET
// export function PrepareFrog ( ) ; begin
53815: LD_INT 0
53817: PPUSH
// uc_side := 0 ;
53818: LD_ADDR_OWVAR 20
53822: PUSH
53823: LD_INT 0
53825: ST_TO_ADDR
// uc_nation := 0 ;
53826: LD_ADDR_OWVAR 21
53830: PUSH
53831: LD_INT 0
53833: ST_TO_ADDR
// hc_class := class_frog ;
53834: LD_ADDR_OWVAR 28
53838: PUSH
53839: LD_INT 19
53841: ST_TO_ADDR
// hc_gallery :=  ;
53842: LD_ADDR_OWVAR 33
53846: PUSH
53847: LD_STRING 
53849: ST_TO_ADDR
// end ;
53850: LD_VAR 0 1
53854: RET
// export function PrepareFish ( ) ; begin
53855: LD_INT 0
53857: PPUSH
// uc_side := 0 ;
53858: LD_ADDR_OWVAR 20
53862: PUSH
53863: LD_INT 0
53865: ST_TO_ADDR
// uc_nation := 0 ;
53866: LD_ADDR_OWVAR 21
53870: PUSH
53871: LD_INT 0
53873: ST_TO_ADDR
// hc_class := class_fish ;
53874: LD_ADDR_OWVAR 28
53878: PUSH
53879: LD_INT 20
53881: ST_TO_ADDR
// hc_gallery :=  ;
53882: LD_ADDR_OWVAR 33
53886: PUSH
53887: LD_STRING 
53889: ST_TO_ADDR
// end ;
53890: LD_VAR 0 1
53894: RET
// export function PrepareBird ( ) ; begin
53895: LD_INT 0
53897: PPUSH
// uc_side := 0 ;
53898: LD_ADDR_OWVAR 20
53902: PUSH
53903: LD_INT 0
53905: ST_TO_ADDR
// uc_nation := 0 ;
53906: LD_ADDR_OWVAR 21
53910: PUSH
53911: LD_INT 0
53913: ST_TO_ADDR
// hc_class := class_phororhacos ;
53914: LD_ADDR_OWVAR 28
53918: PUSH
53919: LD_INT 18
53921: ST_TO_ADDR
// hc_gallery :=  ;
53922: LD_ADDR_OWVAR 33
53926: PUSH
53927: LD_STRING 
53929: ST_TO_ADDR
// end ;
53930: LD_VAR 0 1
53934: RET
// export function PrepareHorse ( ) ; begin
53935: LD_INT 0
53937: PPUSH
// uc_side := 0 ;
53938: LD_ADDR_OWVAR 20
53942: PUSH
53943: LD_INT 0
53945: ST_TO_ADDR
// uc_nation := 0 ;
53946: LD_ADDR_OWVAR 21
53950: PUSH
53951: LD_INT 0
53953: ST_TO_ADDR
// hc_class := class_horse ;
53954: LD_ADDR_OWVAR 28
53958: PUSH
53959: LD_INT 21
53961: ST_TO_ADDR
// hc_gallery :=  ;
53962: LD_ADDR_OWVAR 33
53966: PUSH
53967: LD_STRING 
53969: ST_TO_ADDR
// end ;
53970: LD_VAR 0 1
53974: RET
// export function PrepareMastodont ( ) ; begin
53975: LD_INT 0
53977: PPUSH
// uc_side := 0 ;
53978: LD_ADDR_OWVAR 20
53982: PUSH
53983: LD_INT 0
53985: ST_TO_ADDR
// uc_nation := 0 ;
53986: LD_ADDR_OWVAR 21
53990: PUSH
53991: LD_INT 0
53993: ST_TO_ADDR
// vc_chassis := class_mastodont ;
53994: LD_ADDR_OWVAR 37
53998: PUSH
53999: LD_INT 31
54001: ST_TO_ADDR
// vc_control := control_rider ;
54002: LD_ADDR_OWVAR 38
54006: PUSH
54007: LD_INT 4
54009: ST_TO_ADDR
// end ;
54010: LD_VAR 0 1
54014: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
54015: LD_INT 0
54017: PPUSH
54018: PPUSH
54019: PPUSH
// uc_side = 0 ;
54020: LD_ADDR_OWVAR 20
54024: PUSH
54025: LD_INT 0
54027: ST_TO_ADDR
// uc_nation = 0 ;
54028: LD_ADDR_OWVAR 21
54032: PUSH
54033: LD_INT 0
54035: ST_TO_ADDR
// InitHc_All ( ) ;
54036: CALL_OW 584
// InitVc ;
54040: CALL_OW 20
// if mastodonts then
54044: LD_VAR 0 6
54048: IFFALSE 54115
// for i = 1 to mastodonts do
54050: LD_ADDR_VAR 0 11
54054: PUSH
54055: DOUBLE
54056: LD_INT 1
54058: DEC
54059: ST_TO_ADDR
54060: LD_VAR 0 6
54064: PUSH
54065: FOR_TO
54066: IFFALSE 54113
// begin vc_chassis := 31 ;
54068: LD_ADDR_OWVAR 37
54072: PUSH
54073: LD_INT 31
54075: ST_TO_ADDR
// vc_control := control_rider ;
54076: LD_ADDR_OWVAR 38
54080: PUSH
54081: LD_INT 4
54083: ST_TO_ADDR
// animal := CreateVehicle ;
54084: LD_ADDR_VAR 0 12
54088: PUSH
54089: CALL_OW 45
54093: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
54094: LD_VAR 0 12
54098: PPUSH
54099: LD_VAR 0 8
54103: PPUSH
54104: LD_INT 0
54106: PPUSH
54107: CALL 56250 0 3
// end ;
54111: GO 54065
54113: POP
54114: POP
// if horses then
54115: LD_VAR 0 5
54119: IFFALSE 54186
// for i = 1 to horses do
54121: LD_ADDR_VAR 0 11
54125: PUSH
54126: DOUBLE
54127: LD_INT 1
54129: DEC
54130: ST_TO_ADDR
54131: LD_VAR 0 5
54135: PUSH
54136: FOR_TO
54137: IFFALSE 54184
// begin hc_class := 21 ;
54139: LD_ADDR_OWVAR 28
54143: PUSH
54144: LD_INT 21
54146: ST_TO_ADDR
// hc_gallery :=  ;
54147: LD_ADDR_OWVAR 33
54151: PUSH
54152: LD_STRING 
54154: ST_TO_ADDR
// animal := CreateHuman ;
54155: LD_ADDR_VAR 0 12
54159: PUSH
54160: CALL_OW 44
54164: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
54165: LD_VAR 0 12
54169: PPUSH
54170: LD_VAR 0 8
54174: PPUSH
54175: LD_INT 0
54177: PPUSH
54178: CALL 56250 0 3
// end ;
54182: GO 54136
54184: POP
54185: POP
// if birds then
54186: LD_VAR 0 1
54190: IFFALSE 54257
// for i = 1 to birds do
54192: LD_ADDR_VAR 0 11
54196: PUSH
54197: DOUBLE
54198: LD_INT 1
54200: DEC
54201: ST_TO_ADDR
54202: LD_VAR 0 1
54206: PUSH
54207: FOR_TO
54208: IFFALSE 54255
// begin hc_class = 18 ;
54210: LD_ADDR_OWVAR 28
54214: PUSH
54215: LD_INT 18
54217: ST_TO_ADDR
// hc_gallery =  ;
54218: LD_ADDR_OWVAR 33
54222: PUSH
54223: LD_STRING 
54225: ST_TO_ADDR
// animal := CreateHuman ;
54226: LD_ADDR_VAR 0 12
54230: PUSH
54231: CALL_OW 44
54235: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
54236: LD_VAR 0 12
54240: PPUSH
54241: LD_VAR 0 8
54245: PPUSH
54246: LD_INT 0
54248: PPUSH
54249: CALL 56250 0 3
// end ;
54253: GO 54207
54255: POP
54256: POP
// if tigers then
54257: LD_VAR 0 2
54261: IFFALSE 54345
// for i = 1 to tigers do
54263: LD_ADDR_VAR 0 11
54267: PUSH
54268: DOUBLE
54269: LD_INT 1
54271: DEC
54272: ST_TO_ADDR
54273: LD_VAR 0 2
54277: PUSH
54278: FOR_TO
54279: IFFALSE 54343
// begin hc_class = class_tiger ;
54281: LD_ADDR_OWVAR 28
54285: PUSH
54286: LD_INT 14
54288: ST_TO_ADDR
// hc_gallery =  ;
54289: LD_ADDR_OWVAR 33
54293: PUSH
54294: LD_STRING 
54296: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
54297: LD_ADDR_OWVAR 35
54301: PUSH
54302: LD_INT 7
54304: NEG
54305: PPUSH
54306: LD_INT 7
54308: PPUSH
54309: CALL_OW 12
54313: ST_TO_ADDR
// animal := CreateHuman ;
54314: LD_ADDR_VAR 0 12
54318: PUSH
54319: CALL_OW 44
54323: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
54324: LD_VAR 0 12
54328: PPUSH
54329: LD_VAR 0 8
54333: PPUSH
54334: LD_INT 0
54336: PPUSH
54337: CALL 56250 0 3
// end ;
54341: GO 54278
54343: POP
54344: POP
// if apemans then
54345: LD_VAR 0 3
54349: IFFALSE 54472
// for i = 1 to apemans do
54351: LD_ADDR_VAR 0 11
54355: PUSH
54356: DOUBLE
54357: LD_INT 1
54359: DEC
54360: ST_TO_ADDR
54361: LD_VAR 0 3
54365: PUSH
54366: FOR_TO
54367: IFFALSE 54470
// begin hc_class = class_apeman ;
54369: LD_ADDR_OWVAR 28
54373: PUSH
54374: LD_INT 12
54376: ST_TO_ADDR
// hc_gallery =  ;
54377: LD_ADDR_OWVAR 33
54381: PUSH
54382: LD_STRING 
54384: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
54385: LD_ADDR_OWVAR 35
54389: PUSH
54390: LD_INT 2
54392: NEG
54393: PPUSH
54394: LD_INT 2
54396: PPUSH
54397: CALL_OW 12
54401: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
54402: LD_ADDR_OWVAR 31
54406: PUSH
54407: LD_INT 1
54409: PPUSH
54410: LD_INT 3
54412: PPUSH
54413: CALL_OW 12
54417: PUSH
54418: LD_INT 1
54420: PPUSH
54421: LD_INT 3
54423: PPUSH
54424: CALL_OW 12
54428: PUSH
54429: LD_INT 0
54431: PUSH
54432: LD_INT 0
54434: PUSH
54435: EMPTY
54436: LIST
54437: LIST
54438: LIST
54439: LIST
54440: ST_TO_ADDR
// animal := CreateHuman ;
54441: LD_ADDR_VAR 0 12
54445: PUSH
54446: CALL_OW 44
54450: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
54451: LD_VAR 0 12
54455: PPUSH
54456: LD_VAR 0 8
54460: PPUSH
54461: LD_INT 0
54463: PPUSH
54464: CALL 56250 0 3
// end ;
54468: GO 54366
54470: POP
54471: POP
// if enchidnas then
54472: LD_VAR 0 4
54476: IFFALSE 54543
// for i = 1 to enchidnas do
54478: LD_ADDR_VAR 0 11
54482: PUSH
54483: DOUBLE
54484: LD_INT 1
54486: DEC
54487: ST_TO_ADDR
54488: LD_VAR 0 4
54492: PUSH
54493: FOR_TO
54494: IFFALSE 54541
// begin hc_class = 13 ;
54496: LD_ADDR_OWVAR 28
54500: PUSH
54501: LD_INT 13
54503: ST_TO_ADDR
// hc_gallery =  ;
54504: LD_ADDR_OWVAR 33
54508: PUSH
54509: LD_STRING 
54511: ST_TO_ADDR
// animal := CreateHuman ;
54512: LD_ADDR_VAR 0 12
54516: PUSH
54517: CALL_OW 44
54521: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
54522: LD_VAR 0 12
54526: PPUSH
54527: LD_VAR 0 8
54531: PPUSH
54532: LD_INT 0
54534: PPUSH
54535: CALL 56250 0 3
// end ;
54539: GO 54493
54541: POP
54542: POP
// if fishes then
54543: LD_VAR 0 7
54547: IFFALSE 54614
// for i = 1 to fishes do
54549: LD_ADDR_VAR 0 11
54553: PUSH
54554: DOUBLE
54555: LD_INT 1
54557: DEC
54558: ST_TO_ADDR
54559: LD_VAR 0 7
54563: PUSH
54564: FOR_TO
54565: IFFALSE 54612
// begin hc_class = 20 ;
54567: LD_ADDR_OWVAR 28
54571: PUSH
54572: LD_INT 20
54574: ST_TO_ADDR
// hc_gallery =  ;
54575: LD_ADDR_OWVAR 33
54579: PUSH
54580: LD_STRING 
54582: ST_TO_ADDR
// animal := CreateHuman ;
54583: LD_ADDR_VAR 0 12
54587: PUSH
54588: CALL_OW 44
54592: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
54593: LD_VAR 0 12
54597: PPUSH
54598: LD_VAR 0 9
54602: PPUSH
54603: LD_INT 0
54605: PPUSH
54606: CALL 56250 0 3
// end ;
54610: GO 54564
54612: POP
54613: POP
// end ;
54614: LD_VAR 0 10
54618: RET
// export function WantHeal ( sci , unit ) ; begin
54619: LD_INT 0
54621: PPUSH
// if GetTaskList ( sci ) > 0 then
54622: LD_VAR 0 1
54626: PPUSH
54627: CALL_OW 437
54631: PUSH
54632: LD_INT 0
54634: GREATER
54635: IFFALSE 54705
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
54637: LD_VAR 0 1
54641: PPUSH
54642: CALL_OW 437
54646: PUSH
54647: LD_INT 1
54649: ARRAY
54650: PUSH
54651: LD_INT 1
54653: ARRAY
54654: PUSH
54655: LD_STRING l
54657: EQUAL
54658: PUSH
54659: LD_VAR 0 1
54663: PPUSH
54664: CALL_OW 437
54668: PUSH
54669: LD_INT 1
54671: ARRAY
54672: PUSH
54673: LD_INT 4
54675: ARRAY
54676: PUSH
54677: LD_VAR 0 2
54681: EQUAL
54682: AND
54683: IFFALSE 54695
// result := true else
54685: LD_ADDR_VAR 0 3
54689: PUSH
54690: LD_INT 1
54692: ST_TO_ADDR
54693: GO 54703
// result := false ;
54695: LD_ADDR_VAR 0 3
54699: PUSH
54700: LD_INT 0
54702: ST_TO_ADDR
// end else
54703: GO 54713
// result := false ;
54705: LD_ADDR_VAR 0 3
54709: PUSH
54710: LD_INT 0
54712: ST_TO_ADDR
// end ;
54713: LD_VAR 0 3
54717: RET
// export function HealTarget ( sci ) ; begin
54718: LD_INT 0
54720: PPUSH
// if not sci then
54721: LD_VAR 0 1
54725: NOT
54726: IFFALSE 54730
// exit ;
54728: GO 54795
// result := 0 ;
54730: LD_ADDR_VAR 0 2
54734: PUSH
54735: LD_INT 0
54737: ST_TO_ADDR
// if GetTaskList ( sci ) then
54738: LD_VAR 0 1
54742: PPUSH
54743: CALL_OW 437
54747: IFFALSE 54795
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
54749: LD_VAR 0 1
54753: PPUSH
54754: CALL_OW 437
54758: PUSH
54759: LD_INT 1
54761: ARRAY
54762: PUSH
54763: LD_INT 1
54765: ARRAY
54766: PUSH
54767: LD_STRING l
54769: EQUAL
54770: IFFALSE 54795
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
54772: LD_ADDR_VAR 0 2
54776: PUSH
54777: LD_VAR 0 1
54781: PPUSH
54782: CALL_OW 437
54786: PUSH
54787: LD_INT 1
54789: ARRAY
54790: PUSH
54791: LD_INT 4
54793: ARRAY
54794: ST_TO_ADDR
// end ;
54795: LD_VAR 0 2
54799: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
54800: LD_INT 0
54802: PPUSH
54803: PPUSH
54804: PPUSH
54805: PPUSH
// if not base_units then
54806: LD_VAR 0 1
54810: NOT
54811: IFFALSE 54815
// exit ;
54813: GO 54902
// result := false ;
54815: LD_ADDR_VAR 0 2
54819: PUSH
54820: LD_INT 0
54822: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
54823: LD_ADDR_VAR 0 5
54827: PUSH
54828: LD_VAR 0 1
54832: PPUSH
54833: LD_INT 21
54835: PUSH
54836: LD_INT 3
54838: PUSH
54839: EMPTY
54840: LIST
54841: LIST
54842: PPUSH
54843: CALL_OW 72
54847: ST_TO_ADDR
// if not tmp then
54848: LD_VAR 0 5
54852: NOT
54853: IFFALSE 54857
// exit ;
54855: GO 54902
// for i in tmp do
54857: LD_ADDR_VAR 0 3
54861: PUSH
54862: LD_VAR 0 5
54866: PUSH
54867: FOR_IN
54868: IFFALSE 54900
// begin result := EnemyInRange ( i , 22 ) ;
54870: LD_ADDR_VAR 0 2
54874: PUSH
54875: LD_VAR 0 3
54879: PPUSH
54880: LD_INT 22
54882: PPUSH
54883: CALL 52515 0 2
54887: ST_TO_ADDR
// if result then
54888: LD_VAR 0 2
54892: IFFALSE 54898
// exit ;
54894: POP
54895: POP
54896: GO 54902
// end ;
54898: GO 54867
54900: POP
54901: POP
// end ;
54902: LD_VAR 0 2
54906: RET
// export function FilterByTag ( units , tag ) ; begin
54907: LD_INT 0
54909: PPUSH
// result := UnitFilter ( units , [ f_tag , tag ] ) ;
54910: LD_ADDR_VAR 0 3
54914: PUSH
54915: LD_VAR 0 1
54919: PPUSH
54920: LD_INT 120
54922: PUSH
54923: LD_VAR 0 2
54927: PUSH
54928: EMPTY
54929: LIST
54930: LIST
54931: PPUSH
54932: CALL_OW 72
54936: ST_TO_ADDR
// end ;
54937: LD_VAR 0 3
54941: RET
// export function IsDriver ( un ) ; begin
54942: LD_INT 0
54944: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
54945: LD_ADDR_VAR 0 2
54949: PUSH
54950: LD_VAR 0 1
54954: PUSH
54955: LD_INT 55
54957: PUSH
54958: EMPTY
54959: LIST
54960: PPUSH
54961: CALL_OW 69
54965: IN
54966: ST_TO_ADDR
// end ;
54967: LD_VAR 0 2
54971: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
54972: LD_INT 0
54974: PPUSH
54975: PPUSH
// list := [ ] ;
54976: LD_ADDR_VAR 0 5
54980: PUSH
54981: EMPTY
54982: ST_TO_ADDR
// case d of 0 :
54983: LD_VAR 0 3
54987: PUSH
54988: LD_INT 0
54990: DOUBLE
54991: EQUAL
54992: IFTRUE 54996
54994: GO 55129
54996: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
54997: LD_ADDR_VAR 0 5
55001: PUSH
55002: LD_VAR 0 1
55006: PUSH
55007: LD_INT 4
55009: MINUS
55010: PUSH
55011: LD_VAR 0 2
55015: PUSH
55016: LD_INT 4
55018: MINUS
55019: PUSH
55020: LD_INT 2
55022: PUSH
55023: EMPTY
55024: LIST
55025: LIST
55026: LIST
55027: PUSH
55028: LD_VAR 0 1
55032: PUSH
55033: LD_INT 3
55035: MINUS
55036: PUSH
55037: LD_VAR 0 2
55041: PUSH
55042: LD_INT 1
55044: PUSH
55045: EMPTY
55046: LIST
55047: LIST
55048: LIST
55049: PUSH
55050: LD_VAR 0 1
55054: PUSH
55055: LD_INT 4
55057: PLUS
55058: PUSH
55059: LD_VAR 0 2
55063: PUSH
55064: LD_INT 4
55066: PUSH
55067: EMPTY
55068: LIST
55069: LIST
55070: LIST
55071: PUSH
55072: LD_VAR 0 1
55076: PUSH
55077: LD_INT 3
55079: PLUS
55080: PUSH
55081: LD_VAR 0 2
55085: PUSH
55086: LD_INT 3
55088: PLUS
55089: PUSH
55090: LD_INT 5
55092: PUSH
55093: EMPTY
55094: LIST
55095: LIST
55096: LIST
55097: PUSH
55098: LD_VAR 0 1
55102: PUSH
55103: LD_VAR 0 2
55107: PUSH
55108: LD_INT 4
55110: PLUS
55111: PUSH
55112: LD_INT 0
55114: PUSH
55115: EMPTY
55116: LIST
55117: LIST
55118: LIST
55119: PUSH
55120: EMPTY
55121: LIST
55122: LIST
55123: LIST
55124: LIST
55125: LIST
55126: ST_TO_ADDR
// end ; 1 :
55127: GO 55827
55129: LD_INT 1
55131: DOUBLE
55132: EQUAL
55133: IFTRUE 55137
55135: GO 55270
55137: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
55138: LD_ADDR_VAR 0 5
55142: PUSH
55143: LD_VAR 0 1
55147: PUSH
55148: LD_VAR 0 2
55152: PUSH
55153: LD_INT 4
55155: MINUS
55156: PUSH
55157: LD_INT 3
55159: PUSH
55160: EMPTY
55161: LIST
55162: LIST
55163: LIST
55164: PUSH
55165: LD_VAR 0 1
55169: PUSH
55170: LD_INT 3
55172: MINUS
55173: PUSH
55174: LD_VAR 0 2
55178: PUSH
55179: LD_INT 3
55181: MINUS
55182: PUSH
55183: LD_INT 2
55185: PUSH
55186: EMPTY
55187: LIST
55188: LIST
55189: LIST
55190: PUSH
55191: LD_VAR 0 1
55195: PUSH
55196: LD_INT 4
55198: MINUS
55199: PUSH
55200: LD_VAR 0 2
55204: PUSH
55205: LD_INT 1
55207: PUSH
55208: EMPTY
55209: LIST
55210: LIST
55211: LIST
55212: PUSH
55213: LD_VAR 0 1
55217: PUSH
55218: LD_VAR 0 2
55222: PUSH
55223: LD_INT 3
55225: PLUS
55226: PUSH
55227: LD_INT 0
55229: PUSH
55230: EMPTY
55231: LIST
55232: LIST
55233: LIST
55234: PUSH
55235: LD_VAR 0 1
55239: PUSH
55240: LD_INT 4
55242: PLUS
55243: PUSH
55244: LD_VAR 0 2
55248: PUSH
55249: LD_INT 4
55251: PLUS
55252: PUSH
55253: LD_INT 5
55255: PUSH
55256: EMPTY
55257: LIST
55258: LIST
55259: LIST
55260: PUSH
55261: EMPTY
55262: LIST
55263: LIST
55264: LIST
55265: LIST
55266: LIST
55267: ST_TO_ADDR
// end ; 2 :
55268: GO 55827
55270: LD_INT 2
55272: DOUBLE
55273: EQUAL
55274: IFTRUE 55278
55276: GO 55407
55278: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
55279: LD_ADDR_VAR 0 5
55283: PUSH
55284: LD_VAR 0 1
55288: PUSH
55289: LD_VAR 0 2
55293: PUSH
55294: LD_INT 3
55296: MINUS
55297: PUSH
55298: LD_INT 3
55300: PUSH
55301: EMPTY
55302: LIST
55303: LIST
55304: LIST
55305: PUSH
55306: LD_VAR 0 1
55310: PUSH
55311: LD_INT 4
55313: PLUS
55314: PUSH
55315: LD_VAR 0 2
55319: PUSH
55320: LD_INT 4
55322: PUSH
55323: EMPTY
55324: LIST
55325: LIST
55326: LIST
55327: PUSH
55328: LD_VAR 0 1
55332: PUSH
55333: LD_VAR 0 2
55337: PUSH
55338: LD_INT 4
55340: PLUS
55341: PUSH
55342: LD_INT 0
55344: PUSH
55345: EMPTY
55346: LIST
55347: LIST
55348: LIST
55349: PUSH
55350: LD_VAR 0 1
55354: PUSH
55355: LD_INT 3
55357: MINUS
55358: PUSH
55359: LD_VAR 0 2
55363: PUSH
55364: LD_INT 1
55366: PUSH
55367: EMPTY
55368: LIST
55369: LIST
55370: LIST
55371: PUSH
55372: LD_VAR 0 1
55376: PUSH
55377: LD_INT 4
55379: MINUS
55380: PUSH
55381: LD_VAR 0 2
55385: PUSH
55386: LD_INT 4
55388: MINUS
55389: PUSH
55390: LD_INT 2
55392: PUSH
55393: EMPTY
55394: LIST
55395: LIST
55396: LIST
55397: PUSH
55398: EMPTY
55399: LIST
55400: LIST
55401: LIST
55402: LIST
55403: LIST
55404: ST_TO_ADDR
// end ; 3 :
55405: GO 55827
55407: LD_INT 3
55409: DOUBLE
55410: EQUAL
55411: IFTRUE 55415
55413: GO 55548
55415: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
55416: LD_ADDR_VAR 0 5
55420: PUSH
55421: LD_VAR 0 1
55425: PUSH
55426: LD_INT 3
55428: PLUS
55429: PUSH
55430: LD_VAR 0 2
55434: PUSH
55435: LD_INT 4
55437: PUSH
55438: EMPTY
55439: LIST
55440: LIST
55441: LIST
55442: PUSH
55443: LD_VAR 0 1
55447: PUSH
55448: LD_INT 4
55450: PLUS
55451: PUSH
55452: LD_VAR 0 2
55456: PUSH
55457: LD_INT 4
55459: PLUS
55460: PUSH
55461: LD_INT 5
55463: PUSH
55464: EMPTY
55465: LIST
55466: LIST
55467: LIST
55468: PUSH
55469: LD_VAR 0 1
55473: PUSH
55474: LD_INT 4
55476: MINUS
55477: PUSH
55478: LD_VAR 0 2
55482: PUSH
55483: LD_INT 1
55485: PUSH
55486: EMPTY
55487: LIST
55488: LIST
55489: LIST
55490: PUSH
55491: LD_VAR 0 1
55495: PUSH
55496: LD_VAR 0 2
55500: PUSH
55501: LD_INT 4
55503: MINUS
55504: PUSH
55505: LD_INT 3
55507: PUSH
55508: EMPTY
55509: LIST
55510: LIST
55511: LIST
55512: PUSH
55513: LD_VAR 0 1
55517: PUSH
55518: LD_INT 3
55520: MINUS
55521: PUSH
55522: LD_VAR 0 2
55526: PUSH
55527: LD_INT 3
55529: MINUS
55530: PUSH
55531: LD_INT 2
55533: PUSH
55534: EMPTY
55535: LIST
55536: LIST
55537: LIST
55538: PUSH
55539: EMPTY
55540: LIST
55541: LIST
55542: LIST
55543: LIST
55544: LIST
55545: ST_TO_ADDR
// end ; 4 :
55546: GO 55827
55548: LD_INT 4
55550: DOUBLE
55551: EQUAL
55552: IFTRUE 55556
55554: GO 55689
55556: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
55557: LD_ADDR_VAR 0 5
55561: PUSH
55562: LD_VAR 0 1
55566: PUSH
55567: LD_VAR 0 2
55571: PUSH
55572: LD_INT 4
55574: PLUS
55575: PUSH
55576: LD_INT 0
55578: PUSH
55579: EMPTY
55580: LIST
55581: LIST
55582: LIST
55583: PUSH
55584: LD_VAR 0 1
55588: PUSH
55589: LD_INT 3
55591: PLUS
55592: PUSH
55593: LD_VAR 0 2
55597: PUSH
55598: LD_INT 3
55600: PLUS
55601: PUSH
55602: LD_INT 5
55604: PUSH
55605: EMPTY
55606: LIST
55607: LIST
55608: LIST
55609: PUSH
55610: LD_VAR 0 1
55614: PUSH
55615: LD_INT 4
55617: PLUS
55618: PUSH
55619: LD_VAR 0 2
55623: PUSH
55624: LD_INT 4
55626: PUSH
55627: EMPTY
55628: LIST
55629: LIST
55630: LIST
55631: PUSH
55632: LD_VAR 0 1
55636: PUSH
55637: LD_VAR 0 2
55641: PUSH
55642: LD_INT 3
55644: MINUS
55645: PUSH
55646: LD_INT 3
55648: PUSH
55649: EMPTY
55650: LIST
55651: LIST
55652: LIST
55653: PUSH
55654: LD_VAR 0 1
55658: PUSH
55659: LD_INT 4
55661: MINUS
55662: PUSH
55663: LD_VAR 0 2
55667: PUSH
55668: LD_INT 4
55670: MINUS
55671: PUSH
55672: LD_INT 2
55674: PUSH
55675: EMPTY
55676: LIST
55677: LIST
55678: LIST
55679: PUSH
55680: EMPTY
55681: LIST
55682: LIST
55683: LIST
55684: LIST
55685: LIST
55686: ST_TO_ADDR
// end ; 5 :
55687: GO 55827
55689: LD_INT 5
55691: DOUBLE
55692: EQUAL
55693: IFTRUE 55697
55695: GO 55826
55697: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
55698: LD_ADDR_VAR 0 5
55702: PUSH
55703: LD_VAR 0 1
55707: PUSH
55708: LD_INT 4
55710: MINUS
55711: PUSH
55712: LD_VAR 0 2
55716: PUSH
55717: LD_INT 1
55719: PUSH
55720: EMPTY
55721: LIST
55722: LIST
55723: LIST
55724: PUSH
55725: LD_VAR 0 1
55729: PUSH
55730: LD_VAR 0 2
55734: PUSH
55735: LD_INT 4
55737: MINUS
55738: PUSH
55739: LD_INT 3
55741: PUSH
55742: EMPTY
55743: LIST
55744: LIST
55745: LIST
55746: PUSH
55747: LD_VAR 0 1
55751: PUSH
55752: LD_INT 4
55754: PLUS
55755: PUSH
55756: LD_VAR 0 2
55760: PUSH
55761: LD_INT 4
55763: PLUS
55764: PUSH
55765: LD_INT 5
55767: PUSH
55768: EMPTY
55769: LIST
55770: LIST
55771: LIST
55772: PUSH
55773: LD_VAR 0 1
55777: PUSH
55778: LD_INT 3
55780: PLUS
55781: PUSH
55782: LD_VAR 0 2
55786: PUSH
55787: LD_INT 4
55789: PUSH
55790: EMPTY
55791: LIST
55792: LIST
55793: LIST
55794: PUSH
55795: LD_VAR 0 1
55799: PUSH
55800: LD_VAR 0 2
55804: PUSH
55805: LD_INT 3
55807: PLUS
55808: PUSH
55809: LD_INT 0
55811: PUSH
55812: EMPTY
55813: LIST
55814: LIST
55815: LIST
55816: PUSH
55817: EMPTY
55818: LIST
55819: LIST
55820: LIST
55821: LIST
55822: LIST
55823: ST_TO_ADDR
// end ; end ;
55824: GO 55827
55826: POP
// result := list ;
55827: LD_ADDR_VAR 0 4
55831: PUSH
55832: LD_VAR 0 5
55836: ST_TO_ADDR
// end ;
55837: LD_VAR 0 4
55841: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
55842: LD_INT 0
55844: PPUSH
55845: PPUSH
55846: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
55847: LD_VAR 0 1
55851: NOT
55852: PUSH
55853: LD_VAR 0 2
55857: PUSH
55858: LD_INT 1
55860: PUSH
55861: LD_INT 2
55863: PUSH
55864: LD_INT 3
55866: PUSH
55867: LD_INT 4
55869: PUSH
55870: EMPTY
55871: LIST
55872: LIST
55873: LIST
55874: LIST
55875: IN
55876: NOT
55877: OR
55878: IFFALSE 55882
// exit ;
55880: GO 55974
// tmp := [ ] ;
55882: LD_ADDR_VAR 0 5
55886: PUSH
55887: EMPTY
55888: ST_TO_ADDR
// for i in units do
55889: LD_ADDR_VAR 0 4
55893: PUSH
55894: LD_VAR 0 1
55898: PUSH
55899: FOR_IN
55900: IFFALSE 55943
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
55902: LD_ADDR_VAR 0 5
55906: PUSH
55907: LD_VAR 0 5
55911: PPUSH
55912: LD_VAR 0 5
55916: PUSH
55917: LD_INT 1
55919: PLUS
55920: PPUSH
55921: LD_VAR 0 4
55925: PPUSH
55926: LD_VAR 0 2
55930: PPUSH
55931: CALL_OW 259
55935: PPUSH
55936: CALL_OW 2
55940: ST_TO_ADDR
55941: GO 55899
55943: POP
55944: POP
// if not tmp then
55945: LD_VAR 0 5
55949: NOT
55950: IFFALSE 55954
// exit ;
55952: GO 55974
// result := SortListByListDesc ( units , tmp ) ;
55954: LD_ADDR_VAR 0 3
55958: PUSH
55959: LD_VAR 0 1
55963: PPUSH
55964: LD_VAR 0 5
55968: PPUSH
55969: CALL_OW 77
55973: ST_TO_ADDR
// end ;
55974: LD_VAR 0 3
55978: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
55979: LD_INT 0
55981: PPUSH
55982: PPUSH
55983: PPUSH
// result := false ;
55984: LD_ADDR_VAR 0 3
55988: PUSH
55989: LD_INT 0
55991: ST_TO_ADDR
// x := GetX ( building ) ;
55992: LD_ADDR_VAR 0 4
55996: PUSH
55997: LD_VAR 0 2
56001: PPUSH
56002: CALL_OW 250
56006: ST_TO_ADDR
// y := GetY ( building ) ;
56007: LD_ADDR_VAR 0 5
56011: PUSH
56012: LD_VAR 0 2
56016: PPUSH
56017: CALL_OW 251
56021: ST_TO_ADDR
// if not building or not x or not y then
56022: LD_VAR 0 2
56026: NOT
56027: PUSH
56028: LD_VAR 0 4
56032: NOT
56033: OR
56034: PUSH
56035: LD_VAR 0 5
56039: NOT
56040: OR
56041: IFFALSE 56045
// exit ;
56043: GO 56137
// if GetTaskList ( unit ) then
56045: LD_VAR 0 1
56049: PPUSH
56050: CALL_OW 437
56054: IFFALSE 56137
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
56056: LD_STRING e
56058: PUSH
56059: LD_VAR 0 1
56063: PPUSH
56064: CALL_OW 437
56068: PUSH
56069: LD_INT 1
56071: ARRAY
56072: PUSH
56073: LD_INT 1
56075: ARRAY
56076: EQUAL
56077: PUSH
56078: LD_VAR 0 4
56082: PUSH
56083: LD_VAR 0 1
56087: PPUSH
56088: CALL_OW 437
56092: PUSH
56093: LD_INT 1
56095: ARRAY
56096: PUSH
56097: LD_INT 2
56099: ARRAY
56100: EQUAL
56101: AND
56102: PUSH
56103: LD_VAR 0 5
56107: PUSH
56108: LD_VAR 0 1
56112: PPUSH
56113: CALL_OW 437
56117: PUSH
56118: LD_INT 1
56120: ARRAY
56121: PUSH
56122: LD_INT 3
56124: ARRAY
56125: EQUAL
56126: AND
56127: IFFALSE 56137
// result := true end ;
56129: LD_ADDR_VAR 0 3
56133: PUSH
56134: LD_INT 1
56136: ST_TO_ADDR
// end ;
56137: LD_VAR 0 3
56141: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
56142: LD_INT 0
56144: PPUSH
// result := false ;
56145: LD_ADDR_VAR 0 4
56149: PUSH
56150: LD_INT 0
56152: ST_TO_ADDR
// if GetTaskList ( unit ) then
56153: LD_VAR 0 1
56157: PPUSH
56158: CALL_OW 437
56162: IFFALSE 56245
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
56164: LD_STRING M
56166: PUSH
56167: LD_VAR 0 1
56171: PPUSH
56172: CALL_OW 437
56176: PUSH
56177: LD_INT 1
56179: ARRAY
56180: PUSH
56181: LD_INT 1
56183: ARRAY
56184: EQUAL
56185: PUSH
56186: LD_VAR 0 2
56190: PUSH
56191: LD_VAR 0 1
56195: PPUSH
56196: CALL_OW 437
56200: PUSH
56201: LD_INT 1
56203: ARRAY
56204: PUSH
56205: LD_INT 2
56207: ARRAY
56208: EQUAL
56209: AND
56210: PUSH
56211: LD_VAR 0 3
56215: PUSH
56216: LD_VAR 0 1
56220: PPUSH
56221: CALL_OW 437
56225: PUSH
56226: LD_INT 1
56228: ARRAY
56229: PUSH
56230: LD_INT 3
56232: ARRAY
56233: EQUAL
56234: AND
56235: IFFALSE 56245
// result := true ;
56237: LD_ADDR_VAR 0 4
56241: PUSH
56242: LD_INT 1
56244: ST_TO_ADDR
// end ; end ;
56245: LD_VAR 0 4
56249: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
56250: LD_INT 0
56252: PPUSH
56253: PPUSH
56254: PPUSH
56255: PPUSH
// if not unit or not area then
56256: LD_VAR 0 1
56260: NOT
56261: PUSH
56262: LD_VAR 0 2
56266: NOT
56267: OR
56268: IFFALSE 56272
// exit ;
56270: GO 56436
// tmp := AreaToList ( area , i ) ;
56272: LD_ADDR_VAR 0 6
56276: PUSH
56277: LD_VAR 0 2
56281: PPUSH
56282: LD_VAR 0 5
56286: PPUSH
56287: CALL_OW 517
56291: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
56292: LD_ADDR_VAR 0 5
56296: PUSH
56297: DOUBLE
56298: LD_INT 1
56300: DEC
56301: ST_TO_ADDR
56302: LD_VAR 0 6
56306: PUSH
56307: LD_INT 1
56309: ARRAY
56310: PUSH
56311: FOR_TO
56312: IFFALSE 56434
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
56314: LD_ADDR_VAR 0 7
56318: PUSH
56319: LD_VAR 0 6
56323: PUSH
56324: LD_INT 1
56326: ARRAY
56327: PUSH
56328: LD_VAR 0 5
56332: ARRAY
56333: PUSH
56334: LD_VAR 0 6
56338: PUSH
56339: LD_INT 2
56341: ARRAY
56342: PUSH
56343: LD_VAR 0 5
56347: ARRAY
56348: PUSH
56349: EMPTY
56350: LIST
56351: LIST
56352: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
56353: LD_VAR 0 7
56357: PUSH
56358: LD_INT 1
56360: ARRAY
56361: PPUSH
56362: LD_VAR 0 7
56366: PUSH
56367: LD_INT 2
56369: ARRAY
56370: PPUSH
56371: CALL_OW 428
56375: PUSH
56376: LD_INT 0
56378: EQUAL
56379: IFFALSE 56432
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
56381: LD_VAR 0 1
56385: PPUSH
56386: LD_VAR 0 7
56390: PUSH
56391: LD_INT 1
56393: ARRAY
56394: PPUSH
56395: LD_VAR 0 7
56399: PUSH
56400: LD_INT 2
56402: ARRAY
56403: PPUSH
56404: LD_VAR 0 3
56408: PPUSH
56409: CALL_OW 48
// result := IsPlaced ( unit ) ;
56413: LD_ADDR_VAR 0 4
56417: PUSH
56418: LD_VAR 0 1
56422: PPUSH
56423: CALL_OW 305
56427: ST_TO_ADDR
// exit ;
56428: POP
56429: POP
56430: GO 56436
// end ; end ;
56432: GO 56311
56434: POP
56435: POP
// end ;
56436: LD_VAR 0 4
56440: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
56441: LD_INT 0
56443: PPUSH
56444: PPUSH
56445: PPUSH
// if not side or side > 8 then
56446: LD_VAR 0 1
56450: NOT
56451: PUSH
56452: LD_VAR 0 1
56456: PUSH
56457: LD_INT 8
56459: GREATER
56460: OR
56461: IFFALSE 56465
// exit ;
56463: GO 56652
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
56465: LD_ADDR_VAR 0 4
56469: PUSH
56470: LD_INT 22
56472: PUSH
56473: LD_VAR 0 1
56477: PUSH
56478: EMPTY
56479: LIST
56480: LIST
56481: PUSH
56482: LD_INT 21
56484: PUSH
56485: LD_INT 3
56487: PUSH
56488: EMPTY
56489: LIST
56490: LIST
56491: PUSH
56492: EMPTY
56493: LIST
56494: LIST
56495: PPUSH
56496: CALL_OW 69
56500: ST_TO_ADDR
// if not tmp then
56501: LD_VAR 0 4
56505: NOT
56506: IFFALSE 56510
// exit ;
56508: GO 56652
// enable_addtolog := true ;
56510: LD_ADDR_OWVAR 81
56514: PUSH
56515: LD_INT 1
56517: ST_TO_ADDR
// AddToLog ( [ ) ;
56518: LD_STRING [
56520: PPUSH
56521: CALL_OW 561
// for i in tmp do
56525: LD_ADDR_VAR 0 3
56529: PUSH
56530: LD_VAR 0 4
56534: PUSH
56535: FOR_IN
56536: IFFALSE 56643
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
56538: LD_STRING [
56540: PUSH
56541: LD_VAR 0 3
56545: PPUSH
56546: CALL_OW 266
56550: STR
56551: PUSH
56552: LD_STRING , 
56554: STR
56555: PUSH
56556: LD_VAR 0 3
56560: PPUSH
56561: CALL_OW 250
56565: STR
56566: PUSH
56567: LD_STRING , 
56569: STR
56570: PUSH
56571: LD_VAR 0 3
56575: PPUSH
56576: CALL_OW 251
56580: STR
56581: PUSH
56582: LD_STRING , 
56584: STR
56585: PUSH
56586: LD_VAR 0 3
56590: PPUSH
56591: CALL_OW 254
56595: STR
56596: PUSH
56597: LD_STRING , 
56599: STR
56600: PUSH
56601: LD_VAR 0 3
56605: PPUSH
56606: LD_INT 1
56608: PPUSH
56609: CALL_OW 268
56613: STR
56614: PUSH
56615: LD_STRING , 
56617: STR
56618: PUSH
56619: LD_VAR 0 3
56623: PPUSH
56624: LD_INT 2
56626: PPUSH
56627: CALL_OW 268
56631: STR
56632: PUSH
56633: LD_STRING ],
56635: STR
56636: PPUSH
56637: CALL_OW 561
// end ;
56641: GO 56535
56643: POP
56644: POP
// AddToLog ( ]; ) ;
56645: LD_STRING ];
56647: PPUSH
56648: CALL_OW 561
// end ;
56652: LD_VAR 0 2
56656: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
56657: LD_INT 0
56659: PPUSH
56660: PPUSH
56661: PPUSH
56662: PPUSH
56663: PPUSH
// if not area or not rate or not max then
56664: LD_VAR 0 1
56668: NOT
56669: PUSH
56670: LD_VAR 0 2
56674: NOT
56675: OR
56676: PUSH
56677: LD_VAR 0 4
56681: NOT
56682: OR
56683: IFFALSE 56687
// exit ;
56685: GO 56876
// while 1 do
56687: LD_INT 1
56689: IFFALSE 56876
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
56691: LD_ADDR_VAR 0 9
56695: PUSH
56696: LD_VAR 0 1
56700: PPUSH
56701: LD_INT 1
56703: PPUSH
56704: CALL_OW 287
56708: PUSH
56709: LD_INT 10
56711: MUL
56712: ST_TO_ADDR
// r := rate / 10 ;
56713: LD_ADDR_VAR 0 7
56717: PUSH
56718: LD_VAR 0 2
56722: PUSH
56723: LD_INT 10
56725: DIVREAL
56726: ST_TO_ADDR
// time := 1 1$00 ;
56727: LD_ADDR_VAR 0 8
56731: PUSH
56732: LD_INT 2100
56734: ST_TO_ADDR
// if amount < min then
56735: LD_VAR 0 9
56739: PUSH
56740: LD_VAR 0 3
56744: LESS
56745: IFFALSE 56763
// r := r * 2 else
56747: LD_ADDR_VAR 0 7
56751: PUSH
56752: LD_VAR 0 7
56756: PUSH
56757: LD_INT 2
56759: MUL
56760: ST_TO_ADDR
56761: GO 56789
// if amount > max then
56763: LD_VAR 0 9
56767: PUSH
56768: LD_VAR 0 4
56772: GREATER
56773: IFFALSE 56789
// r := r / 2 ;
56775: LD_ADDR_VAR 0 7
56779: PUSH
56780: LD_VAR 0 7
56784: PUSH
56785: LD_INT 2
56787: DIVREAL
56788: ST_TO_ADDR
// time := time / r ;
56789: LD_ADDR_VAR 0 8
56793: PUSH
56794: LD_VAR 0 8
56798: PUSH
56799: LD_VAR 0 7
56803: DIVREAL
56804: ST_TO_ADDR
// if time < 0 then
56805: LD_VAR 0 8
56809: PUSH
56810: LD_INT 0
56812: LESS
56813: IFFALSE 56830
// time := time * - 1 ;
56815: LD_ADDR_VAR 0 8
56819: PUSH
56820: LD_VAR 0 8
56824: PUSH
56825: LD_INT 1
56827: NEG
56828: MUL
56829: ST_TO_ADDR
// wait ( time + rand ( 0 0$01 , 0 0$25 ) ) ;
56830: LD_VAR 0 8
56834: PUSH
56835: LD_INT 35
56837: PPUSH
56838: LD_INT 875
56840: PPUSH
56841: CALL_OW 12
56845: PLUS
56846: PPUSH
56847: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
56851: LD_INT 1
56853: PPUSH
56854: LD_INT 5
56856: PPUSH
56857: CALL_OW 12
56861: PPUSH
56862: LD_VAR 0 1
56866: PPUSH
56867: LD_INT 1
56869: PPUSH
56870: CALL_OW 55
// end ;
56874: GO 56687
// end ;
56876: LD_VAR 0 5
56880: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
56881: LD_INT 0
56883: PPUSH
56884: PPUSH
56885: PPUSH
56886: PPUSH
56887: PPUSH
56888: PPUSH
56889: PPUSH
56890: PPUSH
// if not turrets or not factories then
56891: LD_VAR 0 1
56895: NOT
56896: PUSH
56897: LD_VAR 0 2
56901: NOT
56902: OR
56903: IFFALSE 56907
// exit ;
56905: GO 57214
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
56907: LD_ADDR_VAR 0 10
56911: PUSH
56912: LD_INT 5
56914: PUSH
56915: LD_INT 6
56917: PUSH
56918: EMPTY
56919: LIST
56920: LIST
56921: PUSH
56922: LD_INT 2
56924: PUSH
56925: LD_INT 4
56927: PUSH
56928: EMPTY
56929: LIST
56930: LIST
56931: PUSH
56932: LD_INT 3
56934: PUSH
56935: LD_INT 5
56937: PUSH
56938: EMPTY
56939: LIST
56940: LIST
56941: PUSH
56942: EMPTY
56943: LIST
56944: LIST
56945: LIST
56946: PUSH
56947: LD_INT 24
56949: PUSH
56950: LD_INT 25
56952: PUSH
56953: EMPTY
56954: LIST
56955: LIST
56956: PUSH
56957: LD_INT 23
56959: PUSH
56960: LD_INT 27
56962: PUSH
56963: EMPTY
56964: LIST
56965: LIST
56966: PUSH
56967: EMPTY
56968: LIST
56969: LIST
56970: PUSH
56971: LD_INT 42
56973: PUSH
56974: LD_INT 43
56976: PUSH
56977: EMPTY
56978: LIST
56979: LIST
56980: PUSH
56981: LD_INT 44
56983: PUSH
56984: LD_INT 46
56986: PUSH
56987: EMPTY
56988: LIST
56989: LIST
56990: PUSH
56991: LD_INT 45
56993: PUSH
56994: LD_INT 47
56996: PUSH
56997: EMPTY
56998: LIST
56999: LIST
57000: PUSH
57001: EMPTY
57002: LIST
57003: LIST
57004: LIST
57005: PUSH
57006: EMPTY
57007: LIST
57008: LIST
57009: LIST
57010: ST_TO_ADDR
// result := [ ] ;
57011: LD_ADDR_VAR 0 3
57015: PUSH
57016: EMPTY
57017: ST_TO_ADDR
// for i in turrets do
57018: LD_ADDR_VAR 0 4
57022: PUSH
57023: LD_VAR 0 1
57027: PUSH
57028: FOR_IN
57029: IFFALSE 57212
// begin nat := GetNation ( i ) ;
57031: LD_ADDR_VAR 0 7
57035: PUSH
57036: LD_VAR 0 4
57040: PPUSH
57041: CALL_OW 248
57045: ST_TO_ADDR
// weapon := 0 ;
57046: LD_ADDR_VAR 0 8
57050: PUSH
57051: LD_INT 0
57053: ST_TO_ADDR
// if not nat then
57054: LD_VAR 0 7
57058: NOT
57059: IFFALSE 57063
// continue ;
57061: GO 57028
// for j in list [ nat ] do
57063: LD_ADDR_VAR 0 5
57067: PUSH
57068: LD_VAR 0 10
57072: PUSH
57073: LD_VAR 0 7
57077: ARRAY
57078: PUSH
57079: FOR_IN
57080: IFFALSE 57121
// if GetBWeapon ( i ) = j [ 1 ] then
57082: LD_VAR 0 4
57086: PPUSH
57087: CALL_OW 269
57091: PUSH
57092: LD_VAR 0 5
57096: PUSH
57097: LD_INT 1
57099: ARRAY
57100: EQUAL
57101: IFFALSE 57119
// begin weapon := j [ 2 ] ;
57103: LD_ADDR_VAR 0 8
57107: PUSH
57108: LD_VAR 0 5
57112: PUSH
57113: LD_INT 2
57115: ARRAY
57116: ST_TO_ADDR
// break ;
57117: GO 57121
// end ;
57119: GO 57079
57121: POP
57122: POP
// if not weapon then
57123: LD_VAR 0 8
57127: NOT
57128: IFFALSE 57132
// continue ;
57130: GO 57028
// for k in factories do
57132: LD_ADDR_VAR 0 6
57136: PUSH
57137: LD_VAR 0 2
57141: PUSH
57142: FOR_IN
57143: IFFALSE 57208
// begin weapons := AvailableWeaponList ( k ) ;
57145: LD_ADDR_VAR 0 9
57149: PUSH
57150: LD_VAR 0 6
57154: PPUSH
57155: CALL_OW 478
57159: ST_TO_ADDR
// if not weapons then
57160: LD_VAR 0 9
57164: NOT
57165: IFFALSE 57169
// continue ;
57167: GO 57142
// if weapon in weapons then
57169: LD_VAR 0 8
57173: PUSH
57174: LD_VAR 0 9
57178: IN
57179: IFFALSE 57206
// begin result := [ i , weapon ] ;
57181: LD_ADDR_VAR 0 3
57185: PUSH
57186: LD_VAR 0 4
57190: PUSH
57191: LD_VAR 0 8
57195: PUSH
57196: EMPTY
57197: LIST
57198: LIST
57199: ST_TO_ADDR
// exit ;
57200: POP
57201: POP
57202: POP
57203: POP
57204: GO 57214
// end ; end ;
57206: GO 57142
57208: POP
57209: POP
// end ;
57210: GO 57028
57212: POP
57213: POP
// end ;
57214: LD_VAR 0 3
57218: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
57219: LD_INT 0
57221: PPUSH
// if not side or side > 8 then
57222: LD_VAR 0 3
57226: NOT
57227: PUSH
57228: LD_VAR 0 3
57232: PUSH
57233: LD_INT 8
57235: GREATER
57236: OR
57237: IFFALSE 57241
// exit ;
57239: GO 57300
// if not range then
57241: LD_VAR 0 4
57245: NOT
57246: IFFALSE 57257
// range := - 12 ;
57248: LD_ADDR_VAR 0 4
57252: PUSH
57253: LD_INT 12
57255: NEG
57256: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
57257: LD_VAR 0 1
57261: PPUSH
57262: LD_VAR 0 2
57266: PPUSH
57267: LD_VAR 0 3
57271: PPUSH
57272: LD_VAR 0 4
57276: PPUSH
57277: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
57281: LD_VAR 0 1
57285: PPUSH
57286: LD_VAR 0 2
57290: PPUSH
57291: LD_VAR 0 3
57295: PPUSH
57296: CALL_OW 331
// end ;
57300: LD_VAR 0 5
57304: RET
// export function Video ( mode ) ; begin
57305: LD_INT 0
57307: PPUSH
// ingame_video = mode ;
57308: LD_ADDR_OWVAR 52
57312: PUSH
57313: LD_VAR 0 1
57317: ST_TO_ADDR
// interface_hidden = mode ;
57318: LD_ADDR_OWVAR 54
57322: PUSH
57323: LD_VAR 0 1
57327: ST_TO_ADDR
// end ;
57328: LD_VAR 0 2
57332: RET
// export function Join ( array , element ) ; begin
57333: LD_INT 0
57335: PPUSH
// result := Replace ( array , array + 1 , element ) ;
57336: LD_ADDR_VAR 0 3
57340: PUSH
57341: LD_VAR 0 1
57345: PPUSH
57346: LD_VAR 0 1
57350: PUSH
57351: LD_INT 1
57353: PLUS
57354: PPUSH
57355: LD_VAR 0 2
57359: PPUSH
57360: CALL_OW 1
57364: ST_TO_ADDR
// end ;
57365: LD_VAR 0 3
57369: RET
// export function JoinUnion ( array , element ) ; begin
57370: LD_INT 0
57372: PPUSH
// result := array union element ;
57373: LD_ADDR_VAR 0 3
57377: PUSH
57378: LD_VAR 0 1
57382: PUSH
57383: LD_VAR 0 2
57387: UNION
57388: ST_TO_ADDR
// end ;
57389: LD_VAR 0 3
57393: RET
// export function GetBehemoths ( side ) ; begin
57394: LD_INT 0
57396: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , ru_behemoth ] ] ) ;
57397: LD_ADDR_VAR 0 2
57401: PUSH
57402: LD_INT 22
57404: PUSH
57405: LD_VAR 0 1
57409: PUSH
57410: EMPTY
57411: LIST
57412: LIST
57413: PUSH
57414: LD_INT 31
57416: PUSH
57417: LD_INT 25
57419: PUSH
57420: EMPTY
57421: LIST
57422: LIST
57423: PUSH
57424: EMPTY
57425: LIST
57426: LIST
57427: PPUSH
57428: CALL_OW 69
57432: ST_TO_ADDR
// end ;
57433: LD_VAR 0 2
57437: RET
// export function Shuffle ( array ) ; var i , index ; begin
57438: LD_INT 0
57440: PPUSH
57441: PPUSH
57442: PPUSH
// result := [ ] ;
57443: LD_ADDR_VAR 0 2
57447: PUSH
57448: EMPTY
57449: ST_TO_ADDR
// if not array then
57450: LD_VAR 0 1
57454: NOT
57455: IFFALSE 57459
// exit ;
57457: GO 57558
// Randomize ;
57459: CALL_OW 10
// for i = array downto 1 do
57463: LD_ADDR_VAR 0 3
57467: PUSH
57468: DOUBLE
57469: LD_VAR 0 1
57473: INC
57474: ST_TO_ADDR
57475: LD_INT 1
57477: PUSH
57478: FOR_DOWNTO
57479: IFFALSE 57556
// begin index := rand ( 1 , array ) ;
57481: LD_ADDR_VAR 0 4
57485: PUSH
57486: LD_INT 1
57488: PPUSH
57489: LD_VAR 0 1
57493: PPUSH
57494: CALL_OW 12
57498: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
57499: LD_ADDR_VAR 0 2
57503: PUSH
57504: LD_VAR 0 2
57508: PPUSH
57509: LD_VAR 0 2
57513: PUSH
57514: LD_INT 1
57516: PLUS
57517: PPUSH
57518: LD_VAR 0 1
57522: PUSH
57523: LD_VAR 0 4
57527: ARRAY
57528: PPUSH
57529: CALL_OW 2
57533: ST_TO_ADDR
// array := Delete ( array , index ) ;
57534: LD_ADDR_VAR 0 1
57538: PUSH
57539: LD_VAR 0 1
57543: PPUSH
57544: LD_VAR 0 4
57548: PPUSH
57549: CALL_OW 3
57553: ST_TO_ADDR
// end ;
57554: GO 57478
57556: POP
57557: POP
// end ;
57558: LD_VAR 0 2
57562: RET
// export function GetBaseMaterials ( base ) ; begin
57563: LD_INT 0
57565: PPUSH
// result := [ 0 , 0 , 0 ] ;
57566: LD_ADDR_VAR 0 2
57570: PUSH
57571: LD_INT 0
57573: PUSH
57574: LD_INT 0
57576: PUSH
57577: LD_INT 0
57579: PUSH
57580: EMPTY
57581: LIST
57582: LIST
57583: LIST
57584: ST_TO_ADDR
// if not base then
57585: LD_VAR 0 1
57589: NOT
57590: IFFALSE 57594
// exit ;
57592: GO 57643
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
57594: LD_ADDR_VAR 0 2
57598: PUSH
57599: LD_VAR 0 1
57603: PPUSH
57604: LD_INT 1
57606: PPUSH
57607: CALL_OW 275
57611: PUSH
57612: LD_VAR 0 1
57616: PPUSH
57617: LD_INT 2
57619: PPUSH
57620: CALL_OW 275
57624: PUSH
57625: LD_VAR 0 1
57629: PPUSH
57630: LD_INT 3
57632: PPUSH
57633: CALL_OW 275
57637: PUSH
57638: EMPTY
57639: LIST
57640: LIST
57641: LIST
57642: ST_TO_ADDR
// end ;
57643: LD_VAR 0 2
57647: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
57648: LD_INT 0
57650: PPUSH
57651: PPUSH
// result := array ;
57652: LD_ADDR_VAR 0 3
57656: PUSH
57657: LD_VAR 0 1
57661: ST_TO_ADDR
// if size >= result then
57662: LD_VAR 0 2
57666: PUSH
57667: LD_VAR 0 3
57671: GREATEREQUAL
57672: IFFALSE 57676
// exit ;
57674: GO 57726
// if size then
57676: LD_VAR 0 2
57680: IFFALSE 57726
// for i := array downto size do
57682: LD_ADDR_VAR 0 4
57686: PUSH
57687: DOUBLE
57688: LD_VAR 0 1
57692: INC
57693: ST_TO_ADDR
57694: LD_VAR 0 2
57698: PUSH
57699: FOR_DOWNTO
57700: IFFALSE 57724
// result := Delete ( result , result ) ;
57702: LD_ADDR_VAR 0 3
57706: PUSH
57707: LD_VAR 0 3
57711: PPUSH
57712: LD_VAR 0 3
57716: PPUSH
57717: CALL_OW 3
57721: ST_TO_ADDR
57722: GO 57699
57724: POP
57725: POP
// end ;
57726: LD_VAR 0 3
57730: RET
// export function ComExit ( unit ) ; var tmp ; begin
57731: LD_INT 0
57733: PPUSH
57734: PPUSH
// if not IsInUnit ( unit ) then
57735: LD_VAR 0 1
57739: PPUSH
57740: CALL_OW 310
57744: NOT
57745: IFFALSE 57749
// exit ;
57747: GO 57809
// tmp := IsInUnit ( unit ) ;
57749: LD_ADDR_VAR 0 3
57753: PUSH
57754: LD_VAR 0 1
57758: PPUSH
57759: CALL_OW 310
57763: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
57764: LD_VAR 0 3
57768: PPUSH
57769: CALL_OW 247
57773: PUSH
57774: LD_INT 2
57776: EQUAL
57777: IFFALSE 57790
// ComExitVehicle ( unit ) else
57779: LD_VAR 0 1
57783: PPUSH
57784: CALL_OW 121
57788: GO 57799
// ComExitBuilding ( unit ) ;
57790: LD_VAR 0 1
57794: PPUSH
57795: CALL_OW 122
// result := tmp ;
57799: LD_ADDR_VAR 0 2
57803: PUSH
57804: LD_VAR 0 3
57808: ST_TO_ADDR
// end ;
57809: LD_VAR 0 2
57813: RET
// export function ComExitAll ( units ) ; var i ; begin
57814: LD_INT 0
57816: PPUSH
57817: PPUSH
// if not units then
57818: LD_VAR 0 1
57822: NOT
57823: IFFALSE 57827
// exit ;
57825: GO 57853
// for i in units do
57827: LD_ADDR_VAR 0 3
57831: PUSH
57832: LD_VAR 0 1
57836: PUSH
57837: FOR_IN
57838: IFFALSE 57851
// ComExit ( i ) ;
57840: LD_VAR 0 3
57844: PPUSH
57845: CALL 57731 0 1
57849: GO 57837
57851: POP
57852: POP
// end ;
57853: LD_VAR 0 2
57857: RET
// export function ResetHc ; begin
57858: LD_INT 0
57860: PPUSH
// InitHc ;
57861: CALL_OW 19
// hc_importance := 0 ;
57865: LD_ADDR_OWVAR 32
57869: PUSH
57870: LD_INT 0
57872: ST_TO_ADDR
// end ;
57873: LD_VAR 0 1
57877: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
57878: LD_INT 0
57880: PPUSH
57881: PPUSH
57882: PPUSH
// _x := ( x1 + x2 ) div 2 ;
57883: LD_ADDR_VAR 0 6
57887: PUSH
57888: LD_VAR 0 1
57892: PUSH
57893: LD_VAR 0 3
57897: PLUS
57898: PUSH
57899: LD_INT 2
57901: DIV
57902: ST_TO_ADDR
// if _x < 0 then
57903: LD_VAR 0 6
57907: PUSH
57908: LD_INT 0
57910: LESS
57911: IFFALSE 57928
// _x := _x * - 1 ;
57913: LD_ADDR_VAR 0 6
57917: PUSH
57918: LD_VAR 0 6
57922: PUSH
57923: LD_INT 1
57925: NEG
57926: MUL
57927: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
57928: LD_ADDR_VAR 0 7
57932: PUSH
57933: LD_VAR 0 2
57937: PUSH
57938: LD_VAR 0 4
57942: PLUS
57943: PUSH
57944: LD_INT 2
57946: DIV
57947: ST_TO_ADDR
// if _y < 0 then
57948: LD_VAR 0 7
57952: PUSH
57953: LD_INT 0
57955: LESS
57956: IFFALSE 57973
// _y := _y * - 1 ;
57958: LD_ADDR_VAR 0 7
57962: PUSH
57963: LD_VAR 0 7
57967: PUSH
57968: LD_INT 1
57970: NEG
57971: MUL
57972: ST_TO_ADDR
// result := [ _x , _y ] ;
57973: LD_ADDR_VAR 0 5
57977: PUSH
57978: LD_VAR 0 6
57982: PUSH
57983: LD_VAR 0 7
57987: PUSH
57988: EMPTY
57989: LIST
57990: LIST
57991: ST_TO_ADDR
// end ;
57992: LD_VAR 0 5
57996: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
57997: LD_INT 0
57999: PPUSH
58000: PPUSH
58001: PPUSH
58002: PPUSH
// task := GetTaskList ( unit ) ;
58003: LD_ADDR_VAR 0 7
58007: PUSH
58008: LD_VAR 0 1
58012: PPUSH
58013: CALL_OW 437
58017: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
58018: LD_VAR 0 7
58022: NOT
58023: PUSH
58024: LD_VAR 0 1
58028: PPUSH
58029: LD_VAR 0 2
58033: PPUSH
58034: CALL_OW 308
58038: NOT
58039: AND
58040: IFFALSE 58044
// exit ;
58042: GO 58162
// if IsInArea ( unit , area ) then
58044: LD_VAR 0 1
58048: PPUSH
58049: LD_VAR 0 2
58053: PPUSH
58054: CALL_OW 308
58058: IFFALSE 58076
// begin ComMoveToArea ( unit , goAway ) ;
58060: LD_VAR 0 1
58064: PPUSH
58065: LD_VAR 0 3
58069: PPUSH
58070: CALL_OW 113
// exit ;
58074: GO 58162
// end ; if task [ 1 ] [ 1 ] <> M then
58076: LD_VAR 0 7
58080: PUSH
58081: LD_INT 1
58083: ARRAY
58084: PUSH
58085: LD_INT 1
58087: ARRAY
58088: PUSH
58089: LD_STRING M
58091: NONEQUAL
58092: IFFALSE 58096
// exit ;
58094: GO 58162
// x := task [ 1 ] [ 2 ] ;
58096: LD_ADDR_VAR 0 5
58100: PUSH
58101: LD_VAR 0 7
58105: PUSH
58106: LD_INT 1
58108: ARRAY
58109: PUSH
58110: LD_INT 2
58112: ARRAY
58113: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
58114: LD_ADDR_VAR 0 6
58118: PUSH
58119: LD_VAR 0 7
58123: PUSH
58124: LD_INT 1
58126: ARRAY
58127: PUSH
58128: LD_INT 3
58130: ARRAY
58131: ST_TO_ADDR
// if InArea ( x , y , area ) then
58132: LD_VAR 0 5
58136: PPUSH
58137: LD_VAR 0 6
58141: PPUSH
58142: LD_VAR 0 2
58146: PPUSH
58147: CALL_OW 309
58151: IFFALSE 58162
// ComStop ( unit ) ;
58153: LD_VAR 0 1
58157: PPUSH
58158: CALL_OW 141
// end ;
58162: LD_VAR 0 4
58166: RET
// export function Abs ( value ) ; begin
58167: LD_INT 0
58169: PPUSH
// result := value ;
58170: LD_ADDR_VAR 0 2
58174: PUSH
58175: LD_VAR 0 1
58179: ST_TO_ADDR
// if value < 0 then
58180: LD_VAR 0 1
58184: PUSH
58185: LD_INT 0
58187: LESS
58188: IFFALSE 58205
// result := value * - 1 ;
58190: LD_ADDR_VAR 0 2
58194: PUSH
58195: LD_VAR 0 1
58199: PUSH
58200: LD_INT 1
58202: NEG
58203: MUL
58204: ST_TO_ADDR
// end ;
58205: LD_VAR 0 2
58209: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
58210: LD_INT 0
58212: PPUSH
58213: PPUSH
58214: PPUSH
58215: PPUSH
58216: PPUSH
58217: PPUSH
58218: PPUSH
58219: PPUSH
// if not unit or not building then
58220: LD_VAR 0 1
58224: NOT
58225: PUSH
58226: LD_VAR 0 2
58230: NOT
58231: OR
58232: IFFALSE 58236
// exit ;
58234: GO 58462
// x := GetX ( building ) ;
58236: LD_ADDR_VAR 0 4
58240: PUSH
58241: LD_VAR 0 2
58245: PPUSH
58246: CALL_OW 250
58250: ST_TO_ADDR
// y := GetY ( building ) ;
58251: LD_ADDR_VAR 0 6
58255: PUSH
58256: LD_VAR 0 2
58260: PPUSH
58261: CALL_OW 251
58265: ST_TO_ADDR
// d := GetDir ( building ) ;
58266: LD_ADDR_VAR 0 8
58270: PUSH
58271: LD_VAR 0 2
58275: PPUSH
58276: CALL_OW 254
58280: ST_TO_ADDR
// r := 4 ;
58281: LD_ADDR_VAR 0 9
58285: PUSH
58286: LD_INT 4
58288: ST_TO_ADDR
// for i := 1 to 5 do
58289: LD_ADDR_VAR 0 10
58293: PUSH
58294: DOUBLE
58295: LD_INT 1
58297: DEC
58298: ST_TO_ADDR
58299: LD_INT 5
58301: PUSH
58302: FOR_TO
58303: IFFALSE 58460
// begin _x := ShiftX ( x , d , r + i ) ;
58305: LD_ADDR_VAR 0 5
58309: PUSH
58310: LD_VAR 0 4
58314: PPUSH
58315: LD_VAR 0 8
58319: PPUSH
58320: LD_VAR 0 9
58324: PUSH
58325: LD_VAR 0 10
58329: PLUS
58330: PPUSH
58331: CALL_OW 272
58335: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
58336: LD_ADDR_VAR 0 7
58340: PUSH
58341: LD_VAR 0 6
58345: PPUSH
58346: LD_VAR 0 8
58350: PPUSH
58351: LD_VAR 0 9
58355: PUSH
58356: LD_VAR 0 10
58360: PLUS
58361: PPUSH
58362: CALL_OW 273
58366: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
58367: LD_VAR 0 5
58371: PPUSH
58372: LD_VAR 0 7
58376: PPUSH
58377: CALL_OW 488
58381: PUSH
58382: LD_VAR 0 5
58386: PPUSH
58387: LD_VAR 0 7
58391: PPUSH
58392: CALL_OW 428
58396: PPUSH
58397: CALL_OW 247
58401: PUSH
58402: LD_INT 3
58404: PUSH
58405: LD_INT 2
58407: PUSH
58408: EMPTY
58409: LIST
58410: LIST
58411: IN
58412: NOT
58413: AND
58414: IFFALSE 58458
// begin ComMoveXY ( unit , _x , _y ) ;
58416: LD_VAR 0 1
58420: PPUSH
58421: LD_VAR 0 5
58425: PPUSH
58426: LD_VAR 0 7
58430: PPUSH
58431: CALL_OW 111
// result := [ _x , _y ] ;
58435: LD_ADDR_VAR 0 3
58439: PUSH
58440: LD_VAR 0 5
58444: PUSH
58445: LD_VAR 0 7
58449: PUSH
58450: EMPTY
58451: LIST
58452: LIST
58453: ST_TO_ADDR
// exit ;
58454: POP
58455: POP
58456: GO 58462
// end ; end ;
58458: GO 58302
58460: POP
58461: POP
// end ;
58462: LD_VAR 0 3
58466: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
58467: LD_INT 0
58469: PPUSH
58470: PPUSH
58471: PPUSH
// result := 0 ;
58472: LD_ADDR_VAR 0 3
58476: PUSH
58477: LD_INT 0
58479: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
58480: LD_VAR 0 1
58484: PUSH
58485: LD_INT 0
58487: LESS
58488: PUSH
58489: LD_VAR 0 1
58493: PUSH
58494: LD_INT 8
58496: GREATER
58497: OR
58498: PUSH
58499: LD_VAR 0 2
58503: PUSH
58504: LD_INT 0
58506: LESS
58507: OR
58508: PUSH
58509: LD_VAR 0 2
58513: PUSH
58514: LD_INT 8
58516: GREATER
58517: OR
58518: IFFALSE 58522
// exit ;
58520: GO 58597
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
58522: LD_ADDR_VAR 0 4
58526: PUSH
58527: LD_INT 22
58529: PUSH
58530: LD_VAR 0 2
58534: PUSH
58535: EMPTY
58536: LIST
58537: LIST
58538: PPUSH
58539: CALL_OW 69
58543: PUSH
58544: FOR_IN
58545: IFFALSE 58595
// begin un := UnitShoot ( i ) ;
58547: LD_ADDR_VAR 0 5
58551: PUSH
58552: LD_VAR 0 4
58556: PPUSH
58557: CALL_OW 504
58561: ST_TO_ADDR
// if GetSide ( un ) = side1 then
58562: LD_VAR 0 5
58566: PPUSH
58567: CALL_OW 255
58571: PUSH
58572: LD_VAR 0 1
58576: EQUAL
58577: IFFALSE 58593
// begin result := un ;
58579: LD_ADDR_VAR 0 3
58583: PUSH
58584: LD_VAR 0 5
58588: ST_TO_ADDR
// exit ;
58589: POP
58590: POP
58591: GO 58597
// end ; end ;
58593: GO 58544
58595: POP
58596: POP
// end ;
58597: LD_VAR 0 3
58601: RET
// export function GetCargoBay ( units ) ; begin
58602: LD_INT 0
58604: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
58605: LD_ADDR_VAR 0 2
58609: PUSH
58610: LD_VAR 0 1
58614: PPUSH
58615: LD_INT 2
58617: PUSH
58618: LD_INT 34
58620: PUSH
58621: LD_INT 12
58623: PUSH
58624: EMPTY
58625: LIST
58626: LIST
58627: PUSH
58628: LD_INT 34
58630: PUSH
58631: LD_INT 51
58633: PUSH
58634: EMPTY
58635: LIST
58636: LIST
58637: PUSH
58638: LD_INT 34
58640: PUSH
58641: LD_INT 32
58643: PUSH
58644: EMPTY
58645: LIST
58646: LIST
58647: PUSH
58648: LD_INT 34
58650: PUSH
58651: LD_INT 89
58653: PUSH
58654: EMPTY
58655: LIST
58656: LIST
58657: PUSH
58658: EMPTY
58659: LIST
58660: LIST
58661: LIST
58662: LIST
58663: LIST
58664: PPUSH
58665: CALL_OW 72
58669: ST_TO_ADDR
// end ;
58670: LD_VAR 0 2
58674: RET
// export function Negate ( value ) ; begin
58675: LD_INT 0
58677: PPUSH
// result := not value ;
58678: LD_ADDR_VAR 0 2
58682: PUSH
58683: LD_VAR 0 1
58687: NOT
58688: ST_TO_ADDR
// end ;
58689: LD_VAR 0 2
58693: RET
// export function Inc ( value ) ; begin
58694: LD_INT 0
58696: PPUSH
// result := value + 1 ;
58697: LD_ADDR_VAR 0 2
58701: PUSH
58702: LD_VAR 0 1
58706: PUSH
58707: LD_INT 1
58709: PLUS
58710: ST_TO_ADDR
// end ;
58711: LD_VAR 0 2
58715: RET
// export function Dec ( value ) ; begin
58716: LD_INT 0
58718: PPUSH
// result := value - 1 ;
58719: LD_ADDR_VAR 0 2
58723: PUSH
58724: LD_VAR 0 1
58728: PUSH
58729: LD_INT 1
58731: MINUS
58732: ST_TO_ADDR
// end ;
58733: LD_VAR 0 2
58737: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; var i , _x , _y , tmp , distance , centerDist , centerPoint ; begin
58738: LD_INT 0
58740: PPUSH
58741: PPUSH
58742: PPUSH
58743: PPUSH
58744: PPUSH
58745: PPUSH
58746: PPUSH
58747: PPUSH
// if not ValidHex ( x1 , y1 ) or not ValidHex ( x2 , y2 ) then
58748: LD_VAR 0 1
58752: PPUSH
58753: LD_VAR 0 2
58757: PPUSH
58758: CALL_OW 488
58762: NOT
58763: PUSH
58764: LD_VAR 0 3
58768: PPUSH
58769: LD_VAR 0 4
58773: PPUSH
58774: CALL_OW 488
58778: NOT
58779: OR
58780: IFFALSE 58793
// begin result := - 1 ;
58782: LD_ADDR_VAR 0 5
58786: PUSH
58787: LD_INT 1
58789: NEG
58790: ST_TO_ADDR
// exit ;
58791: GO 59028
// end ; centerPoint := PointBetweenXY ( x1 , y1 , x2 , y2 ) ;
58793: LD_ADDR_VAR 0 12
58797: PUSH
58798: LD_VAR 0 1
58802: PPUSH
58803: LD_VAR 0 2
58807: PPUSH
58808: LD_VAR 0 3
58812: PPUSH
58813: LD_VAR 0 4
58817: PPUSH
58818: CALL 57878 0 4
58822: ST_TO_ADDR
// centerDist := GetDistXY ( x1 , y1 , centerPoint [ 1 ] , centerPoint [ 2 ] ) ;
58823: LD_ADDR_VAR 0 11
58827: PUSH
58828: LD_VAR 0 1
58832: PPUSH
58833: LD_VAR 0 2
58837: PPUSH
58838: LD_VAR 0 12
58842: PUSH
58843: LD_INT 1
58845: ARRAY
58846: PPUSH
58847: LD_VAR 0 12
58851: PUSH
58852: LD_INT 2
58854: ARRAY
58855: PPUSH
58856: CALL_OW 298
58860: ST_TO_ADDR
// distance := 9999 ;
58861: LD_ADDR_VAR 0 10
58865: PUSH
58866: LD_INT 9999
58868: ST_TO_ADDR
// for i := 0 to 5 do
58869: LD_ADDR_VAR 0 6
58873: PUSH
58874: DOUBLE
58875: LD_INT 0
58877: DEC
58878: ST_TO_ADDR
58879: LD_INT 5
58881: PUSH
58882: FOR_TO
58883: IFFALSE 59026
// begin _x := ShiftX ( x1 , i , centerDist ) ;
58885: LD_ADDR_VAR 0 7
58889: PUSH
58890: LD_VAR 0 1
58894: PPUSH
58895: LD_VAR 0 6
58899: PPUSH
58900: LD_VAR 0 11
58904: PPUSH
58905: CALL_OW 272
58909: ST_TO_ADDR
// _y := ShiftY ( y1 , i , centerDist ) ;
58910: LD_ADDR_VAR 0 8
58914: PUSH
58915: LD_VAR 0 2
58919: PPUSH
58920: LD_VAR 0 6
58924: PPUSH
58925: LD_VAR 0 11
58929: PPUSH
58930: CALL_OW 273
58934: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
58935: LD_VAR 0 7
58939: PPUSH
58940: LD_VAR 0 8
58944: PPUSH
58945: CALL_OW 488
58949: NOT
58950: IFFALSE 58954
// continue ;
58952: GO 58882
// tmp := GetDistXY ( centerPoint [ 1 ] , centerPoint [ 2 ] , _x , _y ) ;
58954: LD_ADDR_VAR 0 9
58958: PUSH
58959: LD_VAR 0 12
58963: PUSH
58964: LD_INT 1
58966: ARRAY
58967: PPUSH
58968: LD_VAR 0 12
58972: PUSH
58973: LD_INT 2
58975: ARRAY
58976: PPUSH
58977: LD_VAR 0 7
58981: PPUSH
58982: LD_VAR 0 8
58986: PPUSH
58987: CALL_OW 298
58991: ST_TO_ADDR
// if tmp < distance then
58992: LD_VAR 0 9
58996: PUSH
58997: LD_VAR 0 10
59001: LESS
59002: IFFALSE 59024
// begin result := i ;
59004: LD_ADDR_VAR 0 5
59008: PUSH
59009: LD_VAR 0 6
59013: ST_TO_ADDR
// distance := tmp ;
59014: LD_ADDR_VAR 0 10
59018: PUSH
59019: LD_VAR 0 9
59023: ST_TO_ADDR
// end ; end ;
59024: GO 58882
59026: POP
59027: POP
// end ;
59028: LD_VAR 0 5
59032: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
59033: LD_INT 0
59035: PPUSH
59036: PPUSH
// if not driver or not IsInUnit ( driver ) then
59037: LD_VAR 0 1
59041: NOT
59042: PUSH
59043: LD_VAR 0 1
59047: PPUSH
59048: CALL_OW 310
59052: NOT
59053: OR
59054: IFFALSE 59058
// exit ;
59056: GO 59148
// vehicle := IsInUnit ( driver ) ;
59058: LD_ADDR_VAR 0 3
59062: PUSH
59063: LD_VAR 0 1
59067: PPUSH
59068: CALL_OW 310
59072: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
59073: LD_VAR 0 1
59077: PPUSH
59078: LD_STRING \
59080: PUSH
59081: LD_INT 0
59083: PUSH
59084: LD_INT 0
59086: PUSH
59087: LD_INT 0
59089: PUSH
59090: LD_INT 0
59092: PUSH
59093: LD_INT 0
59095: PUSH
59096: LD_INT 0
59098: PUSH
59099: EMPTY
59100: LIST
59101: LIST
59102: LIST
59103: LIST
59104: LIST
59105: LIST
59106: LIST
59107: PUSH
59108: LD_STRING E
59110: PUSH
59111: LD_INT 0
59113: PUSH
59114: LD_INT 0
59116: PUSH
59117: LD_VAR 0 3
59121: PUSH
59122: LD_INT 0
59124: PUSH
59125: LD_INT 0
59127: PUSH
59128: LD_INT 0
59130: PUSH
59131: EMPTY
59132: LIST
59133: LIST
59134: LIST
59135: LIST
59136: LIST
59137: LIST
59138: LIST
59139: PUSH
59140: EMPTY
59141: LIST
59142: LIST
59143: PPUSH
59144: CALL_OW 446
// end ;
59148: LD_VAR 0 2
59152: RET
// export function AddComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
59153: LD_INT 0
59155: PPUSH
59156: PPUSH
// if not driver or not IsInUnit ( driver ) then
59157: LD_VAR 0 1
59161: NOT
59162: PUSH
59163: LD_VAR 0 1
59167: PPUSH
59168: CALL_OW 310
59172: NOT
59173: OR
59174: IFFALSE 59178
// exit ;
59176: GO 59268
// vehicle := IsInUnit ( driver ) ;
59178: LD_ADDR_VAR 0 3
59182: PUSH
59183: LD_VAR 0 1
59187: PPUSH
59188: CALL_OW 310
59192: ST_TO_ADDR
// AddTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
59193: LD_VAR 0 1
59197: PPUSH
59198: LD_STRING \
59200: PUSH
59201: LD_INT 0
59203: PUSH
59204: LD_INT 0
59206: PUSH
59207: LD_INT 0
59209: PUSH
59210: LD_INT 0
59212: PUSH
59213: LD_INT 0
59215: PUSH
59216: LD_INT 0
59218: PUSH
59219: EMPTY
59220: LIST
59221: LIST
59222: LIST
59223: LIST
59224: LIST
59225: LIST
59226: LIST
59227: PUSH
59228: LD_STRING E
59230: PUSH
59231: LD_INT 0
59233: PUSH
59234: LD_INT 0
59236: PUSH
59237: LD_VAR 0 3
59241: PUSH
59242: LD_INT 0
59244: PUSH
59245: LD_INT 0
59247: PUSH
59248: LD_INT 0
59250: PUSH
59251: EMPTY
59252: LIST
59253: LIST
59254: LIST
59255: LIST
59256: LIST
59257: LIST
59258: LIST
59259: PUSH
59260: EMPTY
59261: LIST
59262: LIST
59263: PPUSH
59264: CALL_OW 447
// end ;
59268: LD_VAR 0 2
59272: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
59273: LD_INT 0
59275: PPUSH
59276: PPUSH
59277: PPUSH
// tmp := [ ] ;
59278: LD_ADDR_VAR 0 5
59282: PUSH
59283: EMPTY
59284: ST_TO_ADDR
// for i in units do
59285: LD_ADDR_VAR 0 4
59289: PUSH
59290: LD_VAR 0 1
59294: PUSH
59295: FOR_IN
59296: IFFALSE 59334
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
59298: LD_ADDR_VAR 0 5
59302: PUSH
59303: LD_VAR 0 5
59307: PPUSH
59308: LD_VAR 0 5
59312: PUSH
59313: LD_INT 1
59315: PLUS
59316: PPUSH
59317: LD_VAR 0 4
59321: PPUSH
59322: CALL_OW 256
59326: PPUSH
59327: CALL_OW 2
59331: ST_TO_ADDR
59332: GO 59295
59334: POP
59335: POP
// if not tmp then
59336: LD_VAR 0 5
59340: NOT
59341: IFFALSE 59345
// exit ;
59343: GO 59393
// if asc then
59345: LD_VAR 0 2
59349: IFFALSE 59373
// result := SortListByListAsc ( units , tmp ) else
59351: LD_ADDR_VAR 0 3
59355: PUSH
59356: LD_VAR 0 1
59360: PPUSH
59361: LD_VAR 0 5
59365: PPUSH
59366: CALL_OW 76
59370: ST_TO_ADDR
59371: GO 59393
// result := SortListByListDesc ( units , tmp ) ;
59373: LD_ADDR_VAR 0 3
59377: PUSH
59378: LD_VAR 0 1
59382: PPUSH
59383: LD_VAR 0 5
59387: PPUSH
59388: CALL_OW 77
59392: ST_TO_ADDR
// end ;
59393: LD_VAR 0 3
59397: RET
// export function WantToRepairVehicle ( mech , vehicle ) ; var task ; begin
59398: LD_INT 0
59400: PPUSH
59401: PPUSH
// task := GetTaskList ( mech ) ;
59402: LD_ADDR_VAR 0 4
59406: PUSH
59407: LD_VAR 0 1
59411: PPUSH
59412: CALL_OW 437
59416: ST_TO_ADDR
// if not task then
59417: LD_VAR 0 4
59421: NOT
59422: IFFALSE 59426
// exit ;
59424: GO 59468
// result := task [ 1 ] [ 1 ] = r and task [ 1 ] [ 4 ] = vehicle ;
59426: LD_ADDR_VAR 0 3
59430: PUSH
59431: LD_VAR 0 4
59435: PUSH
59436: LD_INT 1
59438: ARRAY
59439: PUSH
59440: LD_INT 1
59442: ARRAY
59443: PUSH
59444: LD_STRING r
59446: EQUAL
59447: PUSH
59448: LD_VAR 0 4
59452: PUSH
59453: LD_INT 1
59455: ARRAY
59456: PUSH
59457: LD_INT 4
59459: ARRAY
59460: PUSH
59461: LD_VAR 0 2
59465: EQUAL
59466: AND
59467: ST_TO_ADDR
// end ;
59468: LD_VAR 0 3
59472: RET
// export function PlaceUnitXYD ( unit , x , y , d , mode ) ; begin
59473: LD_INT 0
59475: PPUSH
// SetDir ( unit , d ) ;
59476: LD_VAR 0 1
59480: PPUSH
59481: LD_VAR 0 4
59485: PPUSH
59486: CALL_OW 233
// PlaceUnitXY ( unit , x , y , mode ) ;
59490: LD_VAR 0 1
59494: PPUSH
59495: LD_VAR 0 2
59499: PPUSH
59500: LD_VAR 0 3
59504: PPUSH
59505: LD_VAR 0 5
59509: PPUSH
59510: CALL_OW 48
// end ;
59514: LD_VAR 0 6
59518: RET
// export function ToNaturalNumber ( number ) ; begin
59519: LD_INT 0
59521: PPUSH
// result := number div 1 ;
59522: LD_ADDR_VAR 0 2
59526: PUSH
59527: LD_VAR 0 1
59531: PUSH
59532: LD_INT 1
59534: DIV
59535: ST_TO_ADDR
// if number < 0 then
59536: LD_VAR 0 1
59540: PUSH
59541: LD_INT 0
59543: LESS
59544: IFFALSE 59554
// result := 0 ;
59546: LD_ADDR_VAR 0 2
59550: PUSH
59551: LD_INT 0
59553: ST_TO_ADDR
// end ;
59554: LD_VAR 0 2
59558: RET
// export function SortByClass ( units , class ) ; var un ; begin
59559: LD_INT 0
59561: PPUSH
59562: PPUSH
// if not units or not class then
59563: LD_VAR 0 1
59567: NOT
59568: PUSH
59569: LD_VAR 0 2
59573: NOT
59574: OR
59575: IFFALSE 59579
// exit ;
59577: GO 59674
// result := [ ] ;
59579: LD_ADDR_VAR 0 3
59583: PUSH
59584: EMPTY
59585: ST_TO_ADDR
// for un in units do
59586: LD_ADDR_VAR 0 4
59590: PUSH
59591: LD_VAR 0 1
59595: PUSH
59596: FOR_IN
59597: IFFALSE 59672
// if GetClass ( un ) = class then
59599: LD_VAR 0 4
59603: PPUSH
59604: CALL_OW 257
59608: PUSH
59609: LD_VAR 0 2
59613: EQUAL
59614: IFFALSE 59641
// result := Insert ( result , 1 , un ) else
59616: LD_ADDR_VAR 0 3
59620: PUSH
59621: LD_VAR 0 3
59625: PPUSH
59626: LD_INT 1
59628: PPUSH
59629: LD_VAR 0 4
59633: PPUSH
59634: CALL_OW 2
59638: ST_TO_ADDR
59639: GO 59670
// result := Replace ( result , result + 1 , un ) ;
59641: LD_ADDR_VAR 0 3
59645: PUSH
59646: LD_VAR 0 3
59650: PPUSH
59651: LD_VAR 0 3
59655: PUSH
59656: LD_INT 1
59658: PLUS
59659: PPUSH
59660: LD_VAR 0 4
59664: PPUSH
59665: CALL_OW 1
59669: ST_TO_ADDR
59670: GO 59596
59672: POP
59673: POP
// end ;
59674: LD_VAR 0 3
59678: RET
// export function GetCratesNearbyXY ( x , y , r ) ; var _x , _y , min_y , min_x , max_x , max_y ; begin
59679: LD_INT 0
59681: PPUSH
59682: PPUSH
59683: PPUSH
59684: PPUSH
59685: PPUSH
59686: PPUSH
59687: PPUSH
// result := [ ] ;
59688: LD_ADDR_VAR 0 4
59692: PUSH
59693: EMPTY
59694: ST_TO_ADDR
// if x - r < 0 then
59695: LD_VAR 0 1
59699: PUSH
59700: LD_VAR 0 3
59704: MINUS
59705: PUSH
59706: LD_INT 0
59708: LESS
59709: IFFALSE 59721
// min_x := 0 else
59711: LD_ADDR_VAR 0 8
59715: PUSH
59716: LD_INT 0
59718: ST_TO_ADDR
59719: GO 59737
// min_x := x - r ;
59721: LD_ADDR_VAR 0 8
59725: PUSH
59726: LD_VAR 0 1
59730: PUSH
59731: LD_VAR 0 3
59735: MINUS
59736: ST_TO_ADDR
// if y - r < 0 then
59737: LD_VAR 0 2
59741: PUSH
59742: LD_VAR 0 3
59746: MINUS
59747: PUSH
59748: LD_INT 0
59750: LESS
59751: IFFALSE 59763
// min_y := 0 else
59753: LD_ADDR_VAR 0 7
59757: PUSH
59758: LD_INT 0
59760: ST_TO_ADDR
59761: GO 59779
// min_y := y - r ;
59763: LD_ADDR_VAR 0 7
59767: PUSH
59768: LD_VAR 0 2
59772: PUSH
59773: LD_VAR 0 3
59777: MINUS
59778: ST_TO_ADDR
// max_x := x + r ;
59779: LD_ADDR_VAR 0 9
59783: PUSH
59784: LD_VAR 0 1
59788: PUSH
59789: LD_VAR 0 3
59793: PLUS
59794: ST_TO_ADDR
// max_y := y + r ;
59795: LD_ADDR_VAR 0 10
59799: PUSH
59800: LD_VAR 0 2
59804: PUSH
59805: LD_VAR 0 3
59809: PLUS
59810: ST_TO_ADDR
// for _x = min_x to max_x do
59811: LD_ADDR_VAR 0 5
59815: PUSH
59816: DOUBLE
59817: LD_VAR 0 8
59821: DEC
59822: ST_TO_ADDR
59823: LD_VAR 0 9
59827: PUSH
59828: FOR_TO
59829: IFFALSE 59930
// for _y = min_y to max_y do
59831: LD_ADDR_VAR 0 6
59835: PUSH
59836: DOUBLE
59837: LD_VAR 0 7
59841: DEC
59842: ST_TO_ADDR
59843: LD_VAR 0 10
59847: PUSH
59848: FOR_TO
59849: IFFALSE 59926
// begin if not ValidHex ( _x , _y ) then
59851: LD_VAR 0 5
59855: PPUSH
59856: LD_VAR 0 6
59860: PPUSH
59861: CALL_OW 488
59865: NOT
59866: IFFALSE 59870
// continue ;
59868: GO 59848
// if GetResourceTypeXY ( _x , _y ) then
59870: LD_VAR 0 5
59874: PPUSH
59875: LD_VAR 0 6
59879: PPUSH
59880: CALL_OW 283
59884: IFFALSE 59924
// result := Replace ( result , result + 1 , [ _x , _y ] ) ;
59886: LD_ADDR_VAR 0 4
59890: PUSH
59891: LD_VAR 0 4
59895: PPUSH
59896: LD_VAR 0 4
59900: PUSH
59901: LD_INT 1
59903: PLUS
59904: PPUSH
59905: LD_VAR 0 5
59909: PUSH
59910: LD_VAR 0 6
59914: PUSH
59915: EMPTY
59916: LIST
59917: LIST
59918: PPUSH
59919: CALL_OW 1
59923: ST_TO_ADDR
// end ;
59924: GO 59848
59926: POP
59927: POP
59928: GO 59828
59930: POP
59931: POP
// end ;
59932: LD_VAR 0 4
59936: RET
// export function AgressiveMove ( units , path ) ; var i , enemy , nearEnemy , cr , side , tag , ignoreCratesWeapon ; begin
59937: LD_INT 0
59939: PPUSH
59940: PPUSH
59941: PPUSH
59942: PPUSH
59943: PPUSH
59944: PPUSH
59945: PPUSH
59946: PPUSH
// if not units then
59947: LD_VAR 0 1
59951: NOT
59952: IFFALSE 59956
// exit ;
59954: GO 60480
// result := UnitFilter ( units , [ f_ok ] ) ;
59956: LD_ADDR_VAR 0 3
59960: PUSH
59961: LD_VAR 0 1
59965: PPUSH
59966: LD_INT 50
59968: PUSH
59969: EMPTY
59970: LIST
59971: PPUSH
59972: CALL_OW 72
59976: ST_TO_ADDR
// side := GetSide ( units [ 1 ] ) ;
59977: LD_ADDR_VAR 0 8
59981: PUSH
59982: LD_VAR 0 1
59986: PUSH
59987: LD_INT 1
59989: ARRAY
59990: PPUSH
59991: CALL_OW 255
59995: ST_TO_ADDR
// ignoreCratesWeapon := [ ar_selfpropelled_bomb , ar_bio_bomb , ru_time_lapser ] ;
59996: LD_ADDR_VAR 0 10
60000: PUSH
60001: LD_INT 29
60003: PUSH
60004: LD_INT 91
60006: PUSH
60007: LD_INT 49
60009: PUSH
60010: EMPTY
60011: LIST
60012: LIST
60013: LIST
60014: ST_TO_ADDR
// if not result then
60015: LD_VAR 0 3
60019: NOT
60020: IFFALSE 60024
// exit ;
60022: GO 60480
// enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
60024: LD_ADDR_VAR 0 5
60028: PUSH
60029: LD_INT 81
60031: PUSH
60032: LD_VAR 0 8
60036: PUSH
60037: EMPTY
60038: LIST
60039: LIST
60040: PPUSH
60041: CALL_OW 69
60045: ST_TO_ADDR
// for i in result do
60046: LD_ADDR_VAR 0 4
60050: PUSH
60051: LD_VAR 0 3
60055: PUSH
60056: FOR_IN
60057: IFFALSE 60478
// begin tag := GetTag ( i ) + 1 ;
60059: LD_ADDR_VAR 0 9
60063: PUSH
60064: LD_VAR 0 4
60068: PPUSH
60069: CALL_OW 110
60073: PUSH
60074: LD_INT 1
60076: PLUS
60077: ST_TO_ADDR
// cr := GetCratesNearbyXY ( GetX ( i ) , GetY ( i ) , 6 ) ;
60078: LD_ADDR_VAR 0 7
60082: PUSH
60083: LD_VAR 0 4
60087: PPUSH
60088: CALL_OW 250
60092: PPUSH
60093: LD_VAR 0 4
60097: PPUSH
60098: CALL_OW 251
60102: PPUSH
60103: LD_INT 6
60105: PPUSH
60106: CALL 59679 0 3
60110: ST_TO_ADDR
// if GetType ( i ) = unit_vehicle and cr and not GetWeapon ( i ) in ignoreCratesWeapon then
60111: LD_VAR 0 4
60115: PPUSH
60116: CALL_OW 247
60120: PUSH
60121: LD_INT 2
60123: EQUAL
60124: PUSH
60125: LD_VAR 0 7
60129: AND
60130: PUSH
60131: LD_VAR 0 4
60135: PPUSH
60136: CALL_OW 264
60140: PUSH
60141: LD_VAR 0 10
60145: IN
60146: NOT
60147: AND
60148: IFFALSE 60187
// ComAttackPlace ( i , cr [ 1 ] [ 1 ] , cr [ 1 ] [ 2 ] ) else
60150: LD_VAR 0 4
60154: PPUSH
60155: LD_VAR 0 7
60159: PUSH
60160: LD_INT 1
60162: ARRAY
60163: PUSH
60164: LD_INT 1
60166: ARRAY
60167: PPUSH
60168: LD_VAR 0 7
60172: PUSH
60173: LD_INT 1
60175: ARRAY
60176: PUSH
60177: LD_INT 2
60179: ARRAY
60180: PPUSH
60181: CALL_OW 116
60185: GO 60476
// if path > tag then
60187: LD_VAR 0 2
60191: PUSH
60192: LD_VAR 0 9
60196: GREATER
60197: IFFALSE 60405
// begin nearEnemy := UnitFilter ( enemy , [ f_dist , i , 8 ] ) ;
60199: LD_ADDR_VAR 0 6
60203: PUSH
60204: LD_VAR 0 5
60208: PPUSH
60209: LD_INT 91
60211: PUSH
60212: LD_VAR 0 4
60216: PUSH
60217: LD_INT 8
60219: PUSH
60220: EMPTY
60221: LIST
60222: LIST
60223: LIST
60224: PPUSH
60225: CALL_OW 72
60229: ST_TO_ADDR
// if nearEnemy then
60230: LD_VAR 0 6
60234: IFFALSE 60303
// begin if GetWeapon ( i ) = ru_time_lapser then
60236: LD_VAR 0 4
60240: PPUSH
60241: CALL_OW 264
60245: PUSH
60246: LD_INT 49
60248: EQUAL
60249: IFFALSE 60277
// ComMoveUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) else
60251: LD_VAR 0 4
60255: PPUSH
60256: LD_VAR 0 6
60260: PPUSH
60261: LD_VAR 0 4
60265: PPUSH
60266: CALL_OW 74
60270: PPUSH
60271: CALL_OW 112
60275: GO 60301
// ComAttackUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) ;
60277: LD_VAR 0 4
60281: PPUSH
60282: LD_VAR 0 6
60286: PPUSH
60287: LD_VAR 0 4
60291: PPUSH
60292: CALL_OW 74
60296: PPUSH
60297: CALL_OW 115
// end else
60301: GO 60403
// if GetDistUnitXY ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) > 6 then
60303: LD_VAR 0 4
60307: PPUSH
60308: LD_VAR 0 2
60312: PUSH
60313: LD_VAR 0 9
60317: ARRAY
60318: PUSH
60319: LD_INT 1
60321: ARRAY
60322: PPUSH
60323: LD_VAR 0 2
60327: PUSH
60328: LD_VAR 0 9
60332: ARRAY
60333: PUSH
60334: LD_INT 2
60336: ARRAY
60337: PPUSH
60338: CALL_OW 297
60342: PUSH
60343: LD_INT 6
60345: GREATER
60346: IFFALSE 60389
// ComAgressiveMove ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) else
60348: LD_VAR 0 4
60352: PPUSH
60353: LD_VAR 0 2
60357: PUSH
60358: LD_VAR 0 9
60362: ARRAY
60363: PUSH
60364: LD_INT 1
60366: ARRAY
60367: PPUSH
60368: LD_VAR 0 2
60372: PUSH
60373: LD_VAR 0 9
60377: ARRAY
60378: PUSH
60379: LD_INT 2
60381: ARRAY
60382: PPUSH
60383: CALL_OW 114
60387: GO 60403
// SetTag ( i , tag ) ;
60389: LD_VAR 0 4
60393: PPUSH
60394: LD_VAR 0 9
60398: PPUSH
60399: CALL_OW 109
// end else
60403: GO 60476
// if enemy then
60405: LD_VAR 0 5
60409: IFFALSE 60476
// begin if GetWeapon ( i ) = ru_time_lapser then
60411: LD_VAR 0 4
60415: PPUSH
60416: CALL_OW 264
60420: PUSH
60421: LD_INT 49
60423: EQUAL
60424: IFFALSE 60452
// ComMoveUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
60426: LD_VAR 0 4
60430: PPUSH
60431: LD_VAR 0 5
60435: PPUSH
60436: LD_VAR 0 4
60440: PPUSH
60441: CALL_OW 74
60445: PPUSH
60446: CALL_OW 112
60450: GO 60476
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
60452: LD_VAR 0 4
60456: PPUSH
60457: LD_VAR 0 5
60461: PPUSH
60462: LD_VAR 0 4
60466: PPUSH
60467: CALL_OW 74
60471: PPUSH
60472: CALL_OW 115
// end ; end ;
60476: GO 60056
60478: POP
60479: POP
// end ;
60480: LD_VAR 0 3
60484: RET
// export function ComLookAtDir ( unit , direction ) ; var x , y ; begin
60485: LD_INT 0
60487: PPUSH
60488: PPUSH
60489: PPUSH
// if not unit or IsInUnit ( unit ) then
60490: LD_VAR 0 1
60494: NOT
60495: PUSH
60496: LD_VAR 0 1
60500: PPUSH
60501: CALL_OW 310
60505: OR
60506: IFFALSE 60510
// exit ;
60508: GO 60601
// x := ShiftX ( GetX ( unit ) , direction , 1 ) ;
60510: LD_ADDR_VAR 0 4
60514: PUSH
60515: LD_VAR 0 1
60519: PPUSH
60520: CALL_OW 250
60524: PPUSH
60525: LD_VAR 0 2
60529: PPUSH
60530: LD_INT 1
60532: PPUSH
60533: CALL_OW 272
60537: ST_TO_ADDR
// y := ShiftY ( GetY ( unit ) , direction , 1 ) ;
60538: LD_ADDR_VAR 0 5
60542: PUSH
60543: LD_VAR 0 1
60547: PPUSH
60548: CALL_OW 251
60552: PPUSH
60553: LD_VAR 0 2
60557: PPUSH
60558: LD_INT 1
60560: PPUSH
60561: CALL_OW 273
60565: ST_TO_ADDR
// if ValidHex ( x , y ) then
60566: LD_VAR 0 4
60570: PPUSH
60571: LD_VAR 0 5
60575: PPUSH
60576: CALL_OW 488
60580: IFFALSE 60601
// ComTurnXY ( unit , x , y ) ;
60582: LD_VAR 0 1
60586: PPUSH
60587: LD_VAR 0 4
60591: PPUSH
60592: LD_VAR 0 5
60596: PPUSH
60597: CALL_OW 118
// end ;
60601: LD_VAR 0 3
60605: RET
// export function SeeUnits ( side , units ) ; var i ; begin
60606: LD_INT 0
60608: PPUSH
60609: PPUSH
// result := false ;
60610: LD_ADDR_VAR 0 3
60614: PUSH
60615: LD_INT 0
60617: ST_TO_ADDR
// if not units then
60618: LD_VAR 0 2
60622: NOT
60623: IFFALSE 60627
// exit ;
60625: GO 60672
// for i in units do
60627: LD_ADDR_VAR 0 4
60631: PUSH
60632: LD_VAR 0 2
60636: PUSH
60637: FOR_IN
60638: IFFALSE 60670
// if See ( side , i ) then
60640: LD_VAR 0 1
60644: PPUSH
60645: LD_VAR 0 4
60649: PPUSH
60650: CALL_OW 292
60654: IFFALSE 60668
// begin result := true ;
60656: LD_ADDR_VAR 0 3
60660: PUSH
60661: LD_INT 1
60663: ST_TO_ADDR
// exit ;
60664: POP
60665: POP
60666: GO 60672
// end ;
60668: GO 60637
60670: POP
60671: POP
// end ;
60672: LD_VAR 0 3
60676: RET
// export function GetNearestPoint ( unit , points ) ; var i , dist , tmpDist ; begin
60677: LD_INT 0
60679: PPUSH
60680: PPUSH
60681: PPUSH
60682: PPUSH
// if not unit or not points then
60683: LD_VAR 0 1
60687: NOT
60688: PUSH
60689: LD_VAR 0 2
60693: NOT
60694: OR
60695: IFFALSE 60699
// exit ;
60697: GO 60789
// dist := 99999 ;
60699: LD_ADDR_VAR 0 5
60703: PUSH
60704: LD_INT 99999
60706: ST_TO_ADDR
// for i in points do
60707: LD_ADDR_VAR 0 4
60711: PUSH
60712: LD_VAR 0 2
60716: PUSH
60717: FOR_IN
60718: IFFALSE 60787
// begin tmpDist := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
60720: LD_ADDR_VAR 0 6
60724: PUSH
60725: LD_VAR 0 1
60729: PPUSH
60730: LD_VAR 0 4
60734: PUSH
60735: LD_INT 1
60737: ARRAY
60738: PPUSH
60739: LD_VAR 0 4
60743: PUSH
60744: LD_INT 2
60746: ARRAY
60747: PPUSH
60748: CALL_OW 297
60752: ST_TO_ADDR
// if tmpDist < dist then
60753: LD_VAR 0 6
60757: PUSH
60758: LD_VAR 0 5
60762: LESS
60763: IFFALSE 60785
// begin result := i ;
60765: LD_ADDR_VAR 0 3
60769: PUSH
60770: LD_VAR 0 4
60774: ST_TO_ADDR
// dist := tmpDist ;
60775: LD_ADDR_VAR 0 5
60779: PUSH
60780: LD_VAR 0 6
60784: ST_TO_ADDR
// end ; end ;
60785: GO 60717
60787: POP
60788: POP
// end ;
60789: LD_VAR 0 3
60793: RET
// export function CreateBehemoth ( side , x , y , d ) ; begin
60794: LD_INT 0
60796: PPUSH
// uc_side := side ;
60797: LD_ADDR_OWVAR 20
60801: PUSH
60802: LD_VAR 0 1
60806: ST_TO_ADDR
// uc_nation := 3 ;
60807: LD_ADDR_OWVAR 21
60811: PUSH
60812: LD_INT 3
60814: ST_TO_ADDR
// vc_chassis := 25 ;
60815: LD_ADDR_OWVAR 37
60819: PUSH
60820: LD_INT 25
60822: ST_TO_ADDR
// vc_engine := engine_siberite ;
60823: LD_ADDR_OWVAR 39
60827: PUSH
60828: LD_INT 3
60830: ST_TO_ADDR
// vc_control := control_computer ;
60831: LD_ADDR_OWVAR 38
60835: PUSH
60836: LD_INT 3
60838: ST_TO_ADDR
// vc_weapon := 59 ;
60839: LD_ADDR_OWVAR 40
60843: PUSH
60844: LD_INT 59
60846: ST_TO_ADDR
// result := CreateVehicle ;
60847: LD_ADDR_VAR 0 5
60851: PUSH
60852: CALL_OW 45
60856: ST_TO_ADDR
// SetDir ( result , d ) ;
60857: LD_VAR 0 5
60861: PPUSH
60862: LD_VAR 0 4
60866: PPUSH
60867: CALL_OW 233
// PlaceUnitXY ( result , x , y , false ) ;
60871: LD_VAR 0 5
60875: PPUSH
60876: LD_VAR 0 2
60880: PPUSH
60881: LD_VAR 0 3
60885: PPUSH
60886: LD_INT 0
60888: PPUSH
60889: CALL_OW 48
// end ;
60893: LD_VAR 0 5
60897: RET
// export function GetMultiCargo ( cargo ) ; var i , tmp ; begin
60898: LD_INT 0
60900: PPUSH
60901: PPUSH
60902: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
60903: LD_ADDR_VAR 0 2
60907: PUSH
60908: LD_INT 0
60910: PUSH
60911: LD_INT 0
60913: PUSH
60914: LD_INT 0
60916: PUSH
60917: LD_INT 0
60919: PUSH
60920: EMPTY
60921: LIST
60922: LIST
60923: LIST
60924: LIST
60925: ST_TO_ADDR
// if not cargo or not GetWeapon ( cargo ) in [ us_cargo_bay , ru_cargo_bay , ar_cargo_bay , ru_big_cargo_bay ] then
60926: LD_VAR 0 1
60930: NOT
60931: PUSH
60932: LD_VAR 0 1
60936: PPUSH
60937: CALL_OW 264
60941: PUSH
60942: LD_INT 12
60944: PUSH
60945: LD_INT 51
60947: PUSH
60948: LD_INT 32
60950: PUSH
60951: LD_INT 89
60953: PUSH
60954: EMPTY
60955: LIST
60956: LIST
60957: LIST
60958: LIST
60959: IN
60960: NOT
60961: OR
60962: IFFALSE 60966
// exit ;
60964: GO 61064
// for i := 1 to 3 do
60966: LD_ADDR_VAR 0 3
60970: PUSH
60971: DOUBLE
60972: LD_INT 1
60974: DEC
60975: ST_TO_ADDR
60976: LD_INT 3
60978: PUSH
60979: FOR_TO
60980: IFFALSE 61062
// begin tmp := GetCargo ( cargo , i ) ;
60982: LD_ADDR_VAR 0 4
60986: PUSH
60987: LD_VAR 0 1
60991: PPUSH
60992: LD_VAR 0 3
60996: PPUSH
60997: CALL_OW 289
61001: ST_TO_ADDR
// result := Replace ( result , i , tmp ) ;
61002: LD_ADDR_VAR 0 2
61006: PUSH
61007: LD_VAR 0 2
61011: PPUSH
61012: LD_VAR 0 3
61016: PPUSH
61017: LD_VAR 0 4
61021: PPUSH
61022: CALL_OW 1
61026: ST_TO_ADDR
// result := Replace ( result , 4 , result [ 4 ] + tmp ) ;
61027: LD_ADDR_VAR 0 2
61031: PUSH
61032: LD_VAR 0 2
61036: PPUSH
61037: LD_INT 4
61039: PPUSH
61040: LD_VAR 0 2
61044: PUSH
61045: LD_INT 4
61047: ARRAY
61048: PUSH
61049: LD_VAR 0 4
61053: PLUS
61054: PPUSH
61055: CALL_OW 1
61059: ST_TO_ADDR
// end ;
61060: GO 60979
61062: POP
61063: POP
// end ;
61064: LD_VAR 0 2
61068: RET
// export function Length ( array ) ; begin
61069: LD_INT 0
61071: PPUSH
// result := array + 0 ;
61072: LD_ADDR_VAR 0 2
61076: PUSH
61077: LD_VAR 0 1
61081: PUSH
61082: LD_INT 0
61084: PLUS
61085: ST_TO_ADDR
// end ;
61086: LD_VAR 0 2
61090: RET
// export function PrepareArray ( array ) ; begin
61091: LD_INT 0
61093: PPUSH
// result := array diff 0 ;
61094: LD_ADDR_VAR 0 2
61098: PUSH
61099: LD_VAR 0 1
61103: PUSH
61104: LD_INT 0
61106: DIFF
61107: ST_TO_ADDR
// if not result [ 1 ] then
61108: LD_VAR 0 2
61112: PUSH
61113: LD_INT 1
61115: ARRAY
61116: NOT
61117: IFFALSE 61137
// result := Delete ( result , 1 ) ;
61119: LD_ADDR_VAR 0 2
61123: PUSH
61124: LD_VAR 0 2
61128: PPUSH
61129: LD_INT 1
61131: PPUSH
61132: CALL_OW 3
61136: ST_TO_ADDR
// end ;
61137: LD_VAR 0 2
61141: RET
// export function IsInSibRocketRange ( x , y , area ) ; var i , sibRocketRange , tmp ; begin
61142: LD_INT 0
61144: PPUSH
61145: PPUSH
61146: PPUSH
61147: PPUSH
// sibRocketRange := 25 ;
61148: LD_ADDR_VAR 0 6
61152: PUSH
61153: LD_INT 25
61155: ST_TO_ADDR
// result := false ;
61156: LD_ADDR_VAR 0 4
61160: PUSH
61161: LD_INT 0
61163: ST_TO_ADDR
// for i := 0 to 5 do
61164: LD_ADDR_VAR 0 5
61168: PUSH
61169: DOUBLE
61170: LD_INT 0
61172: DEC
61173: ST_TO_ADDR
61174: LD_INT 5
61176: PUSH
61177: FOR_TO
61178: IFFALSE 61245
// if InArea ( ShiftX ( x , i , sibRocketRange ) , ShiftY ( y , i , sibRocketRange ) , area ) then
61180: LD_VAR 0 1
61184: PPUSH
61185: LD_VAR 0 5
61189: PPUSH
61190: LD_VAR 0 6
61194: PPUSH
61195: CALL_OW 272
61199: PPUSH
61200: LD_VAR 0 2
61204: PPUSH
61205: LD_VAR 0 5
61209: PPUSH
61210: LD_VAR 0 6
61214: PPUSH
61215: CALL_OW 273
61219: PPUSH
61220: LD_VAR 0 3
61224: PPUSH
61225: CALL_OW 309
61229: IFFALSE 61243
// begin result := true ;
61231: LD_ADDR_VAR 0 4
61235: PUSH
61236: LD_INT 1
61238: ST_TO_ADDR
// exit ;
61239: POP
61240: POP
61241: GO 61247
// end ;
61243: GO 61177
61245: POP
61246: POP
// end ; end_of_file
61247: LD_VAR 0 4
61251: RET
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use , mc_is_defending ; export function InitMacro ; var i ; begin
61252: LD_INT 0
61254: PPUSH
61255: PPUSH
// skirmish := false ;
61256: LD_ADDR_EXP 29
61260: PUSH
61261: LD_INT 0
61263: ST_TO_ADDR
// debug_mc := false ;
61264: LD_ADDR_EXP 30
61268: PUSH
61269: LD_INT 0
61271: ST_TO_ADDR
// mc_bases := [ ] ;
61272: LD_ADDR_EXP 31
61276: PUSH
61277: EMPTY
61278: ST_TO_ADDR
// mc_sides := [ ] ;
61279: LD_ADDR_EXP 57
61283: PUSH
61284: EMPTY
61285: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
61286: LD_ADDR_EXP 32
61290: PUSH
61291: EMPTY
61292: ST_TO_ADDR
// mc_building_repairs := [ ] ;
61293: LD_ADDR_EXP 33
61297: PUSH
61298: EMPTY
61299: ST_TO_ADDR
// mc_need_heal := [ ] ;
61300: LD_ADDR_EXP 34
61304: PUSH
61305: EMPTY
61306: ST_TO_ADDR
// mc_healers := [ ] ;
61307: LD_ADDR_EXP 35
61311: PUSH
61312: EMPTY
61313: ST_TO_ADDR
// mc_build_list := [ ] ;
61314: LD_ADDR_EXP 36
61318: PUSH
61319: EMPTY
61320: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
61321: LD_ADDR_EXP 63
61325: PUSH
61326: EMPTY
61327: ST_TO_ADDR
// mc_builders := [ ] ;
61328: LD_ADDR_EXP 37
61332: PUSH
61333: EMPTY
61334: ST_TO_ADDR
// mc_construct_list := [ ] ;
61335: LD_ADDR_EXP 38
61339: PUSH
61340: EMPTY
61341: ST_TO_ADDR
// mc_turret_list := [ ] ;
61342: LD_ADDR_EXP 39
61346: PUSH
61347: EMPTY
61348: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
61349: LD_ADDR_EXP 40
61353: PUSH
61354: EMPTY
61355: ST_TO_ADDR
// mc_miners := [ ] ;
61356: LD_ADDR_EXP 45
61360: PUSH
61361: EMPTY
61362: ST_TO_ADDR
// mc_mines := [ ] ;
61363: LD_ADDR_EXP 44
61367: PUSH
61368: EMPTY
61369: ST_TO_ADDR
// mc_minefields := [ ] ;
61370: LD_ADDR_EXP 46
61374: PUSH
61375: EMPTY
61376: ST_TO_ADDR
// mc_crates := [ ] ;
61377: LD_ADDR_EXP 47
61381: PUSH
61382: EMPTY
61383: ST_TO_ADDR
// mc_crates_collector := [ ] ;
61384: LD_ADDR_EXP 48
61388: PUSH
61389: EMPTY
61390: ST_TO_ADDR
// mc_crates_area := [ ] ;
61391: LD_ADDR_EXP 49
61395: PUSH
61396: EMPTY
61397: ST_TO_ADDR
// mc_vehicles := [ ] ;
61398: LD_ADDR_EXP 50
61402: PUSH
61403: EMPTY
61404: ST_TO_ADDR
// mc_attack := [ ] ;
61405: LD_ADDR_EXP 51
61409: PUSH
61410: EMPTY
61411: ST_TO_ADDR
// mc_produce := [ ] ;
61412: LD_ADDR_EXP 52
61416: PUSH
61417: EMPTY
61418: ST_TO_ADDR
// mc_defender := [ ] ;
61419: LD_ADDR_EXP 53
61423: PUSH
61424: EMPTY
61425: ST_TO_ADDR
// mc_parking := [ ] ;
61426: LD_ADDR_EXP 55
61430: PUSH
61431: EMPTY
61432: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
61433: LD_ADDR_EXP 41
61437: PUSH
61438: EMPTY
61439: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
61440: LD_ADDR_EXP 43
61444: PUSH
61445: EMPTY
61446: ST_TO_ADDR
// mc_scan := [ ] ;
61447: LD_ADDR_EXP 54
61451: PUSH
61452: EMPTY
61453: ST_TO_ADDR
// mc_scan_area := [ ] ;
61454: LD_ADDR_EXP 56
61458: PUSH
61459: EMPTY
61460: ST_TO_ADDR
// mc_tech := [ ] ;
61461: LD_ADDR_EXP 58
61465: PUSH
61466: EMPTY
61467: ST_TO_ADDR
// mc_class := [ ] ;
61468: LD_ADDR_EXP 72
61472: PUSH
61473: EMPTY
61474: ST_TO_ADDR
// mc_class_case_use := [ ] ;
61475: LD_ADDR_EXP 73
61479: PUSH
61480: EMPTY
61481: ST_TO_ADDR
// mc_is_defending := [ ] ;
61482: LD_ADDR_EXP 74
61486: PUSH
61487: EMPTY
61488: ST_TO_ADDR
// mc_lab_upgrade := [ ] ;
61489: LD_ADDR_EXP 65
61493: PUSH
61494: EMPTY
61495: ST_TO_ADDR
// end ;
61496: LD_VAR 0 1
61500: RET
// export function MC_Kill ( base ) ; begin
61501: LD_INT 0
61503: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
61504: LD_ADDR_EXP 31
61508: PUSH
61509: LD_EXP 31
61513: PPUSH
61514: LD_VAR 0 1
61518: PPUSH
61519: EMPTY
61520: PPUSH
61521: CALL_OW 1
61525: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
61526: LD_ADDR_EXP 32
61530: PUSH
61531: LD_EXP 32
61535: PPUSH
61536: LD_VAR 0 1
61540: PPUSH
61541: EMPTY
61542: PPUSH
61543: CALL_OW 1
61547: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
61548: LD_ADDR_EXP 33
61552: PUSH
61553: LD_EXP 33
61557: PPUSH
61558: LD_VAR 0 1
61562: PPUSH
61563: EMPTY
61564: PPUSH
61565: CALL_OW 1
61569: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
61570: LD_ADDR_EXP 34
61574: PUSH
61575: LD_EXP 34
61579: PPUSH
61580: LD_VAR 0 1
61584: PPUSH
61585: EMPTY
61586: PPUSH
61587: CALL_OW 1
61591: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
61592: LD_ADDR_EXP 35
61596: PUSH
61597: LD_EXP 35
61601: PPUSH
61602: LD_VAR 0 1
61606: PPUSH
61607: EMPTY
61608: PPUSH
61609: CALL_OW 1
61613: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
61614: LD_ADDR_EXP 36
61618: PUSH
61619: LD_EXP 36
61623: PPUSH
61624: LD_VAR 0 1
61628: PPUSH
61629: EMPTY
61630: PPUSH
61631: CALL_OW 1
61635: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
61636: LD_ADDR_EXP 37
61640: PUSH
61641: LD_EXP 37
61645: PPUSH
61646: LD_VAR 0 1
61650: PPUSH
61651: EMPTY
61652: PPUSH
61653: CALL_OW 1
61657: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
61658: LD_ADDR_EXP 38
61662: PUSH
61663: LD_EXP 38
61667: PPUSH
61668: LD_VAR 0 1
61672: PPUSH
61673: EMPTY
61674: PPUSH
61675: CALL_OW 1
61679: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
61680: LD_ADDR_EXP 39
61684: PUSH
61685: LD_EXP 39
61689: PPUSH
61690: LD_VAR 0 1
61694: PPUSH
61695: EMPTY
61696: PPUSH
61697: CALL_OW 1
61701: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
61702: LD_ADDR_EXP 40
61706: PUSH
61707: LD_EXP 40
61711: PPUSH
61712: LD_VAR 0 1
61716: PPUSH
61717: EMPTY
61718: PPUSH
61719: CALL_OW 1
61723: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
61724: LD_ADDR_EXP 41
61728: PUSH
61729: LD_EXP 41
61733: PPUSH
61734: LD_VAR 0 1
61738: PPUSH
61739: EMPTY
61740: PPUSH
61741: CALL_OW 1
61745: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
61746: LD_ADDR_EXP 42
61750: PUSH
61751: LD_EXP 42
61755: PPUSH
61756: LD_VAR 0 1
61760: PPUSH
61761: LD_INT 0
61763: PPUSH
61764: CALL_OW 1
61768: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
61769: LD_ADDR_EXP 43
61773: PUSH
61774: LD_EXP 43
61778: PPUSH
61779: LD_VAR 0 1
61783: PPUSH
61784: EMPTY
61785: PPUSH
61786: CALL_OW 1
61790: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
61791: LD_ADDR_EXP 44
61795: PUSH
61796: LD_EXP 44
61800: PPUSH
61801: LD_VAR 0 1
61805: PPUSH
61806: EMPTY
61807: PPUSH
61808: CALL_OW 1
61812: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
61813: LD_ADDR_EXP 45
61817: PUSH
61818: LD_EXP 45
61822: PPUSH
61823: LD_VAR 0 1
61827: PPUSH
61828: EMPTY
61829: PPUSH
61830: CALL_OW 1
61834: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
61835: LD_ADDR_EXP 46
61839: PUSH
61840: LD_EXP 46
61844: PPUSH
61845: LD_VAR 0 1
61849: PPUSH
61850: EMPTY
61851: PPUSH
61852: CALL_OW 1
61856: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
61857: LD_ADDR_EXP 47
61861: PUSH
61862: LD_EXP 47
61866: PPUSH
61867: LD_VAR 0 1
61871: PPUSH
61872: EMPTY
61873: PPUSH
61874: CALL_OW 1
61878: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
61879: LD_ADDR_EXP 48
61883: PUSH
61884: LD_EXP 48
61888: PPUSH
61889: LD_VAR 0 1
61893: PPUSH
61894: EMPTY
61895: PPUSH
61896: CALL_OW 1
61900: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
61901: LD_ADDR_EXP 49
61905: PUSH
61906: LD_EXP 49
61910: PPUSH
61911: LD_VAR 0 1
61915: PPUSH
61916: EMPTY
61917: PPUSH
61918: CALL_OW 1
61922: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
61923: LD_ADDR_EXP 50
61927: PUSH
61928: LD_EXP 50
61932: PPUSH
61933: LD_VAR 0 1
61937: PPUSH
61938: EMPTY
61939: PPUSH
61940: CALL_OW 1
61944: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
61945: LD_ADDR_EXP 51
61949: PUSH
61950: LD_EXP 51
61954: PPUSH
61955: LD_VAR 0 1
61959: PPUSH
61960: EMPTY
61961: PPUSH
61962: CALL_OW 1
61966: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
61967: LD_ADDR_EXP 52
61971: PUSH
61972: LD_EXP 52
61976: PPUSH
61977: LD_VAR 0 1
61981: PPUSH
61982: EMPTY
61983: PPUSH
61984: CALL_OW 1
61988: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
61989: LD_ADDR_EXP 53
61993: PUSH
61994: LD_EXP 53
61998: PPUSH
61999: LD_VAR 0 1
62003: PPUSH
62004: EMPTY
62005: PPUSH
62006: CALL_OW 1
62010: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
62011: LD_ADDR_EXP 54
62015: PUSH
62016: LD_EXP 54
62020: PPUSH
62021: LD_VAR 0 1
62025: PPUSH
62026: EMPTY
62027: PPUSH
62028: CALL_OW 1
62032: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
62033: LD_ADDR_EXP 55
62037: PUSH
62038: LD_EXP 55
62042: PPUSH
62043: LD_VAR 0 1
62047: PPUSH
62048: EMPTY
62049: PPUSH
62050: CALL_OW 1
62054: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
62055: LD_ADDR_EXP 56
62059: PUSH
62060: LD_EXP 56
62064: PPUSH
62065: LD_VAR 0 1
62069: PPUSH
62070: EMPTY
62071: PPUSH
62072: CALL_OW 1
62076: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
62077: LD_ADDR_EXP 58
62081: PUSH
62082: LD_EXP 58
62086: PPUSH
62087: LD_VAR 0 1
62091: PPUSH
62092: EMPTY
62093: PPUSH
62094: CALL_OW 1
62098: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
62099: LD_ADDR_EXP 60
62103: PUSH
62104: LD_EXP 60
62108: PPUSH
62109: LD_VAR 0 1
62113: PPUSH
62114: EMPTY
62115: PPUSH
62116: CALL_OW 1
62120: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
62121: LD_ADDR_EXP 61
62125: PUSH
62126: LD_EXP 61
62130: PPUSH
62131: LD_VAR 0 1
62135: PPUSH
62136: EMPTY
62137: PPUSH
62138: CALL_OW 1
62142: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
62143: LD_ADDR_EXP 62
62147: PUSH
62148: LD_EXP 62
62152: PPUSH
62153: LD_VAR 0 1
62157: PPUSH
62158: EMPTY
62159: PPUSH
62160: CALL_OW 1
62164: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
62165: LD_ADDR_EXP 63
62169: PUSH
62170: LD_EXP 63
62174: PPUSH
62175: LD_VAR 0 1
62179: PPUSH
62180: EMPTY
62181: PPUSH
62182: CALL_OW 1
62186: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
62187: LD_ADDR_EXP 64
62191: PUSH
62192: LD_EXP 64
62196: PPUSH
62197: LD_VAR 0 1
62201: PPUSH
62202: EMPTY
62203: PPUSH
62204: CALL_OW 1
62208: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
62209: LD_ADDR_EXP 65
62213: PUSH
62214: LD_EXP 65
62218: PPUSH
62219: LD_VAR 0 1
62223: PPUSH
62224: EMPTY
62225: PPUSH
62226: CALL_OW 1
62230: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
62231: LD_ADDR_EXP 66
62235: PUSH
62236: LD_EXP 66
62240: PPUSH
62241: LD_VAR 0 1
62245: PPUSH
62246: EMPTY
62247: PPUSH
62248: CALL_OW 1
62252: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
62253: LD_ADDR_EXP 67
62257: PUSH
62258: LD_EXP 67
62262: PPUSH
62263: LD_VAR 0 1
62267: PPUSH
62268: EMPTY
62269: PPUSH
62270: CALL_OW 1
62274: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
62275: LD_ADDR_EXP 68
62279: PUSH
62280: LD_EXP 68
62284: PPUSH
62285: LD_VAR 0 1
62289: PPUSH
62290: EMPTY
62291: PPUSH
62292: CALL_OW 1
62296: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
62297: LD_ADDR_EXP 69
62301: PUSH
62302: LD_EXP 69
62306: PPUSH
62307: LD_VAR 0 1
62311: PPUSH
62312: EMPTY
62313: PPUSH
62314: CALL_OW 1
62318: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
62319: LD_ADDR_EXP 70
62323: PUSH
62324: LD_EXP 70
62328: PPUSH
62329: LD_VAR 0 1
62333: PPUSH
62334: EMPTY
62335: PPUSH
62336: CALL_OW 1
62340: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
62341: LD_ADDR_EXP 71
62345: PUSH
62346: LD_EXP 71
62350: PPUSH
62351: LD_VAR 0 1
62355: PPUSH
62356: EMPTY
62357: PPUSH
62358: CALL_OW 1
62362: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
62363: LD_ADDR_EXP 72
62367: PUSH
62368: LD_EXP 72
62372: PPUSH
62373: LD_VAR 0 1
62377: PPUSH
62378: EMPTY
62379: PPUSH
62380: CALL_OW 1
62384: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
62385: LD_ADDR_EXP 73
62389: PUSH
62390: LD_EXP 73
62394: PPUSH
62395: LD_VAR 0 1
62399: PPUSH
62400: LD_INT 0
62402: PPUSH
62403: CALL_OW 1
62407: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
62408: LD_ADDR_EXP 74
62412: PUSH
62413: LD_EXP 74
62417: PPUSH
62418: LD_VAR 0 1
62422: PPUSH
62423: LD_INT 0
62425: PPUSH
62426: CALL_OW 1
62430: ST_TO_ADDR
// end ;
62431: LD_VAR 0 2
62435: RET
// export function MC_Add ( side , units ) ; var base ; begin
62436: LD_INT 0
62438: PPUSH
62439: PPUSH
// base := mc_bases + 1 ;
62440: LD_ADDR_VAR 0 4
62444: PUSH
62445: LD_EXP 31
62449: PUSH
62450: LD_INT 1
62452: PLUS
62453: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
62454: LD_ADDR_EXP 57
62458: PUSH
62459: LD_EXP 57
62463: PPUSH
62464: LD_VAR 0 4
62468: PPUSH
62469: LD_VAR 0 1
62473: PPUSH
62474: CALL_OW 1
62478: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
62479: LD_ADDR_EXP 31
62483: PUSH
62484: LD_EXP 31
62488: PPUSH
62489: LD_VAR 0 4
62493: PPUSH
62494: LD_VAR 0 2
62498: PPUSH
62499: CALL_OW 1
62503: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
62504: LD_ADDR_EXP 32
62508: PUSH
62509: LD_EXP 32
62513: PPUSH
62514: LD_VAR 0 4
62518: PPUSH
62519: EMPTY
62520: PPUSH
62521: CALL_OW 1
62525: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
62526: LD_ADDR_EXP 33
62530: PUSH
62531: LD_EXP 33
62535: PPUSH
62536: LD_VAR 0 4
62540: PPUSH
62541: EMPTY
62542: PPUSH
62543: CALL_OW 1
62547: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
62548: LD_ADDR_EXP 34
62552: PUSH
62553: LD_EXP 34
62557: PPUSH
62558: LD_VAR 0 4
62562: PPUSH
62563: EMPTY
62564: PPUSH
62565: CALL_OW 1
62569: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
62570: LD_ADDR_EXP 35
62574: PUSH
62575: LD_EXP 35
62579: PPUSH
62580: LD_VAR 0 4
62584: PPUSH
62585: EMPTY
62586: PPUSH
62587: CALL_OW 1
62591: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
62592: LD_ADDR_EXP 36
62596: PUSH
62597: LD_EXP 36
62601: PPUSH
62602: LD_VAR 0 4
62606: PPUSH
62607: EMPTY
62608: PPUSH
62609: CALL_OW 1
62613: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
62614: LD_ADDR_EXP 37
62618: PUSH
62619: LD_EXP 37
62623: PPUSH
62624: LD_VAR 0 4
62628: PPUSH
62629: EMPTY
62630: PPUSH
62631: CALL_OW 1
62635: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
62636: LD_ADDR_EXP 38
62640: PUSH
62641: LD_EXP 38
62645: PPUSH
62646: LD_VAR 0 4
62650: PPUSH
62651: EMPTY
62652: PPUSH
62653: CALL_OW 1
62657: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
62658: LD_ADDR_EXP 39
62662: PUSH
62663: LD_EXP 39
62667: PPUSH
62668: LD_VAR 0 4
62672: PPUSH
62673: EMPTY
62674: PPUSH
62675: CALL_OW 1
62679: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
62680: LD_ADDR_EXP 40
62684: PUSH
62685: LD_EXP 40
62689: PPUSH
62690: LD_VAR 0 4
62694: PPUSH
62695: EMPTY
62696: PPUSH
62697: CALL_OW 1
62701: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
62702: LD_ADDR_EXP 41
62706: PUSH
62707: LD_EXP 41
62711: PPUSH
62712: LD_VAR 0 4
62716: PPUSH
62717: EMPTY
62718: PPUSH
62719: CALL_OW 1
62723: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
62724: LD_ADDR_EXP 42
62728: PUSH
62729: LD_EXP 42
62733: PPUSH
62734: LD_VAR 0 4
62738: PPUSH
62739: LD_INT 0
62741: PPUSH
62742: CALL_OW 1
62746: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
62747: LD_ADDR_EXP 43
62751: PUSH
62752: LD_EXP 43
62756: PPUSH
62757: LD_VAR 0 4
62761: PPUSH
62762: EMPTY
62763: PPUSH
62764: CALL_OW 1
62768: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
62769: LD_ADDR_EXP 44
62773: PUSH
62774: LD_EXP 44
62778: PPUSH
62779: LD_VAR 0 4
62783: PPUSH
62784: EMPTY
62785: PPUSH
62786: CALL_OW 1
62790: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
62791: LD_ADDR_EXP 45
62795: PUSH
62796: LD_EXP 45
62800: PPUSH
62801: LD_VAR 0 4
62805: PPUSH
62806: EMPTY
62807: PPUSH
62808: CALL_OW 1
62812: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
62813: LD_ADDR_EXP 46
62817: PUSH
62818: LD_EXP 46
62822: PPUSH
62823: LD_VAR 0 4
62827: PPUSH
62828: EMPTY
62829: PPUSH
62830: CALL_OW 1
62834: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
62835: LD_ADDR_EXP 47
62839: PUSH
62840: LD_EXP 47
62844: PPUSH
62845: LD_VAR 0 4
62849: PPUSH
62850: EMPTY
62851: PPUSH
62852: CALL_OW 1
62856: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
62857: LD_ADDR_EXP 48
62861: PUSH
62862: LD_EXP 48
62866: PPUSH
62867: LD_VAR 0 4
62871: PPUSH
62872: EMPTY
62873: PPUSH
62874: CALL_OW 1
62878: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
62879: LD_ADDR_EXP 49
62883: PUSH
62884: LD_EXP 49
62888: PPUSH
62889: LD_VAR 0 4
62893: PPUSH
62894: EMPTY
62895: PPUSH
62896: CALL_OW 1
62900: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
62901: LD_ADDR_EXP 50
62905: PUSH
62906: LD_EXP 50
62910: PPUSH
62911: LD_VAR 0 4
62915: PPUSH
62916: EMPTY
62917: PPUSH
62918: CALL_OW 1
62922: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
62923: LD_ADDR_EXP 51
62927: PUSH
62928: LD_EXP 51
62932: PPUSH
62933: LD_VAR 0 4
62937: PPUSH
62938: EMPTY
62939: PPUSH
62940: CALL_OW 1
62944: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
62945: LD_ADDR_EXP 52
62949: PUSH
62950: LD_EXP 52
62954: PPUSH
62955: LD_VAR 0 4
62959: PPUSH
62960: EMPTY
62961: PPUSH
62962: CALL_OW 1
62966: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
62967: LD_ADDR_EXP 53
62971: PUSH
62972: LD_EXP 53
62976: PPUSH
62977: LD_VAR 0 4
62981: PPUSH
62982: EMPTY
62983: PPUSH
62984: CALL_OW 1
62988: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
62989: LD_ADDR_EXP 54
62993: PUSH
62994: LD_EXP 54
62998: PPUSH
62999: LD_VAR 0 4
63003: PPUSH
63004: EMPTY
63005: PPUSH
63006: CALL_OW 1
63010: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
63011: LD_ADDR_EXP 55
63015: PUSH
63016: LD_EXP 55
63020: PPUSH
63021: LD_VAR 0 4
63025: PPUSH
63026: EMPTY
63027: PPUSH
63028: CALL_OW 1
63032: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
63033: LD_ADDR_EXP 56
63037: PUSH
63038: LD_EXP 56
63042: PPUSH
63043: LD_VAR 0 4
63047: PPUSH
63048: EMPTY
63049: PPUSH
63050: CALL_OW 1
63054: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
63055: LD_ADDR_EXP 58
63059: PUSH
63060: LD_EXP 58
63064: PPUSH
63065: LD_VAR 0 4
63069: PPUSH
63070: EMPTY
63071: PPUSH
63072: CALL_OW 1
63076: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
63077: LD_ADDR_EXP 60
63081: PUSH
63082: LD_EXP 60
63086: PPUSH
63087: LD_VAR 0 4
63091: PPUSH
63092: EMPTY
63093: PPUSH
63094: CALL_OW 1
63098: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
63099: LD_ADDR_EXP 61
63103: PUSH
63104: LD_EXP 61
63108: PPUSH
63109: LD_VAR 0 4
63113: PPUSH
63114: EMPTY
63115: PPUSH
63116: CALL_OW 1
63120: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
63121: LD_ADDR_EXP 62
63125: PUSH
63126: LD_EXP 62
63130: PPUSH
63131: LD_VAR 0 4
63135: PPUSH
63136: EMPTY
63137: PPUSH
63138: CALL_OW 1
63142: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
63143: LD_ADDR_EXP 63
63147: PUSH
63148: LD_EXP 63
63152: PPUSH
63153: LD_VAR 0 4
63157: PPUSH
63158: EMPTY
63159: PPUSH
63160: CALL_OW 1
63164: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
63165: LD_ADDR_EXP 64
63169: PUSH
63170: LD_EXP 64
63174: PPUSH
63175: LD_VAR 0 4
63179: PPUSH
63180: EMPTY
63181: PPUSH
63182: CALL_OW 1
63186: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
63187: LD_ADDR_EXP 65
63191: PUSH
63192: LD_EXP 65
63196: PPUSH
63197: LD_VAR 0 4
63201: PPUSH
63202: EMPTY
63203: PPUSH
63204: CALL_OW 1
63208: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
63209: LD_ADDR_EXP 66
63213: PUSH
63214: LD_EXP 66
63218: PPUSH
63219: LD_VAR 0 4
63223: PPUSH
63224: EMPTY
63225: PPUSH
63226: CALL_OW 1
63230: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
63231: LD_ADDR_EXP 67
63235: PUSH
63236: LD_EXP 67
63240: PPUSH
63241: LD_VAR 0 4
63245: PPUSH
63246: EMPTY
63247: PPUSH
63248: CALL_OW 1
63252: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
63253: LD_ADDR_EXP 68
63257: PUSH
63258: LD_EXP 68
63262: PPUSH
63263: LD_VAR 0 4
63267: PPUSH
63268: EMPTY
63269: PPUSH
63270: CALL_OW 1
63274: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
63275: LD_ADDR_EXP 69
63279: PUSH
63280: LD_EXP 69
63284: PPUSH
63285: LD_VAR 0 4
63289: PPUSH
63290: EMPTY
63291: PPUSH
63292: CALL_OW 1
63296: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
63297: LD_ADDR_EXP 70
63301: PUSH
63302: LD_EXP 70
63306: PPUSH
63307: LD_VAR 0 4
63311: PPUSH
63312: EMPTY
63313: PPUSH
63314: CALL_OW 1
63318: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
63319: LD_ADDR_EXP 71
63323: PUSH
63324: LD_EXP 71
63328: PPUSH
63329: LD_VAR 0 4
63333: PPUSH
63334: EMPTY
63335: PPUSH
63336: CALL_OW 1
63340: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
63341: LD_ADDR_EXP 72
63345: PUSH
63346: LD_EXP 72
63350: PPUSH
63351: LD_VAR 0 4
63355: PPUSH
63356: EMPTY
63357: PPUSH
63358: CALL_OW 1
63362: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
63363: LD_ADDR_EXP 73
63367: PUSH
63368: LD_EXP 73
63372: PPUSH
63373: LD_VAR 0 4
63377: PPUSH
63378: LD_INT 0
63380: PPUSH
63381: CALL_OW 1
63385: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
63386: LD_ADDR_EXP 74
63390: PUSH
63391: LD_EXP 74
63395: PPUSH
63396: LD_VAR 0 4
63400: PPUSH
63401: LD_INT 0
63403: PPUSH
63404: CALL_OW 1
63408: ST_TO_ADDR
// result := base ;
63409: LD_ADDR_VAR 0 3
63413: PUSH
63414: LD_VAR 0 4
63418: ST_TO_ADDR
// end ;
63419: LD_VAR 0 3
63423: RET
// export function MC_Start ( ) ; var i ; begin
63424: LD_INT 0
63426: PPUSH
63427: PPUSH
// for i = 1 to mc_bases do
63428: LD_ADDR_VAR 0 2
63432: PUSH
63433: DOUBLE
63434: LD_INT 1
63436: DEC
63437: ST_TO_ADDR
63438: LD_EXP 31
63442: PUSH
63443: FOR_TO
63444: IFFALSE 64544
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
63446: LD_ADDR_EXP 31
63450: PUSH
63451: LD_EXP 31
63455: PPUSH
63456: LD_VAR 0 2
63460: PPUSH
63461: LD_EXP 31
63465: PUSH
63466: LD_VAR 0 2
63470: ARRAY
63471: PUSH
63472: LD_INT 0
63474: DIFF
63475: PPUSH
63476: CALL_OW 1
63480: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
63481: LD_ADDR_EXP 32
63485: PUSH
63486: LD_EXP 32
63490: PPUSH
63491: LD_VAR 0 2
63495: PPUSH
63496: EMPTY
63497: PPUSH
63498: CALL_OW 1
63502: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
63503: LD_ADDR_EXP 33
63507: PUSH
63508: LD_EXP 33
63512: PPUSH
63513: LD_VAR 0 2
63517: PPUSH
63518: EMPTY
63519: PPUSH
63520: CALL_OW 1
63524: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
63525: LD_ADDR_EXP 34
63529: PUSH
63530: LD_EXP 34
63534: PPUSH
63535: LD_VAR 0 2
63539: PPUSH
63540: EMPTY
63541: PPUSH
63542: CALL_OW 1
63546: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
63547: LD_ADDR_EXP 35
63551: PUSH
63552: LD_EXP 35
63556: PPUSH
63557: LD_VAR 0 2
63561: PPUSH
63562: EMPTY
63563: PUSH
63564: EMPTY
63565: PUSH
63566: EMPTY
63567: LIST
63568: LIST
63569: PPUSH
63570: CALL_OW 1
63574: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
63575: LD_ADDR_EXP 36
63579: PUSH
63580: LD_EXP 36
63584: PPUSH
63585: LD_VAR 0 2
63589: PPUSH
63590: EMPTY
63591: PPUSH
63592: CALL_OW 1
63596: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
63597: LD_ADDR_EXP 63
63601: PUSH
63602: LD_EXP 63
63606: PPUSH
63607: LD_VAR 0 2
63611: PPUSH
63612: EMPTY
63613: PPUSH
63614: CALL_OW 1
63618: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
63619: LD_ADDR_EXP 37
63623: PUSH
63624: LD_EXP 37
63628: PPUSH
63629: LD_VAR 0 2
63633: PPUSH
63634: EMPTY
63635: PPUSH
63636: CALL_OW 1
63640: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
63641: LD_ADDR_EXP 38
63645: PUSH
63646: LD_EXP 38
63650: PPUSH
63651: LD_VAR 0 2
63655: PPUSH
63656: EMPTY
63657: PPUSH
63658: CALL_OW 1
63662: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
63663: LD_ADDR_EXP 39
63667: PUSH
63668: LD_EXP 39
63672: PPUSH
63673: LD_VAR 0 2
63677: PPUSH
63678: LD_EXP 31
63682: PUSH
63683: LD_VAR 0 2
63687: ARRAY
63688: PPUSH
63689: LD_INT 2
63691: PUSH
63692: LD_INT 30
63694: PUSH
63695: LD_INT 32
63697: PUSH
63698: EMPTY
63699: LIST
63700: LIST
63701: PUSH
63702: LD_INT 30
63704: PUSH
63705: LD_INT 33
63707: PUSH
63708: EMPTY
63709: LIST
63710: LIST
63711: PUSH
63712: EMPTY
63713: LIST
63714: LIST
63715: LIST
63716: PPUSH
63717: CALL_OW 72
63721: PPUSH
63722: CALL_OW 1
63726: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
63727: LD_ADDR_EXP 40
63731: PUSH
63732: LD_EXP 40
63736: PPUSH
63737: LD_VAR 0 2
63741: PPUSH
63742: LD_EXP 31
63746: PUSH
63747: LD_VAR 0 2
63751: ARRAY
63752: PPUSH
63753: LD_INT 2
63755: PUSH
63756: LD_INT 30
63758: PUSH
63759: LD_INT 32
63761: PUSH
63762: EMPTY
63763: LIST
63764: LIST
63765: PUSH
63766: LD_INT 30
63768: PUSH
63769: LD_INT 31
63771: PUSH
63772: EMPTY
63773: LIST
63774: LIST
63775: PUSH
63776: EMPTY
63777: LIST
63778: LIST
63779: LIST
63780: PUSH
63781: LD_INT 58
63783: PUSH
63784: EMPTY
63785: LIST
63786: PUSH
63787: EMPTY
63788: LIST
63789: LIST
63790: PPUSH
63791: CALL_OW 72
63795: PPUSH
63796: CALL_OW 1
63800: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
63801: LD_ADDR_EXP 41
63805: PUSH
63806: LD_EXP 41
63810: PPUSH
63811: LD_VAR 0 2
63815: PPUSH
63816: EMPTY
63817: PPUSH
63818: CALL_OW 1
63822: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
63823: LD_ADDR_EXP 45
63827: PUSH
63828: LD_EXP 45
63832: PPUSH
63833: LD_VAR 0 2
63837: PPUSH
63838: EMPTY
63839: PPUSH
63840: CALL_OW 1
63844: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
63845: LD_ADDR_EXP 44
63849: PUSH
63850: LD_EXP 44
63854: PPUSH
63855: LD_VAR 0 2
63859: PPUSH
63860: EMPTY
63861: PPUSH
63862: CALL_OW 1
63866: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
63867: LD_ADDR_EXP 46
63871: PUSH
63872: LD_EXP 46
63876: PPUSH
63877: LD_VAR 0 2
63881: PPUSH
63882: EMPTY
63883: PPUSH
63884: CALL_OW 1
63888: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
63889: LD_ADDR_EXP 47
63893: PUSH
63894: LD_EXP 47
63898: PPUSH
63899: LD_VAR 0 2
63903: PPUSH
63904: EMPTY
63905: PPUSH
63906: CALL_OW 1
63910: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
63911: LD_ADDR_EXP 48
63915: PUSH
63916: LD_EXP 48
63920: PPUSH
63921: LD_VAR 0 2
63925: PPUSH
63926: EMPTY
63927: PPUSH
63928: CALL_OW 1
63932: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
63933: LD_ADDR_EXP 49
63937: PUSH
63938: LD_EXP 49
63942: PPUSH
63943: LD_VAR 0 2
63947: PPUSH
63948: EMPTY
63949: PPUSH
63950: CALL_OW 1
63954: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
63955: LD_ADDR_EXP 50
63959: PUSH
63960: LD_EXP 50
63964: PPUSH
63965: LD_VAR 0 2
63969: PPUSH
63970: EMPTY
63971: PPUSH
63972: CALL_OW 1
63976: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
63977: LD_ADDR_EXP 51
63981: PUSH
63982: LD_EXP 51
63986: PPUSH
63987: LD_VAR 0 2
63991: PPUSH
63992: EMPTY
63993: PPUSH
63994: CALL_OW 1
63998: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
63999: LD_ADDR_EXP 52
64003: PUSH
64004: LD_EXP 52
64008: PPUSH
64009: LD_VAR 0 2
64013: PPUSH
64014: EMPTY
64015: PPUSH
64016: CALL_OW 1
64020: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
64021: LD_ADDR_EXP 53
64025: PUSH
64026: LD_EXP 53
64030: PPUSH
64031: LD_VAR 0 2
64035: PPUSH
64036: EMPTY
64037: PPUSH
64038: CALL_OW 1
64042: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
64043: LD_ADDR_EXP 42
64047: PUSH
64048: LD_EXP 42
64052: PPUSH
64053: LD_VAR 0 2
64057: PPUSH
64058: LD_INT 0
64060: PPUSH
64061: CALL_OW 1
64065: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
64066: LD_ADDR_EXP 55
64070: PUSH
64071: LD_EXP 55
64075: PPUSH
64076: LD_VAR 0 2
64080: PPUSH
64081: LD_INT 0
64083: PPUSH
64084: CALL_OW 1
64088: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
64089: LD_ADDR_EXP 43
64093: PUSH
64094: LD_EXP 43
64098: PPUSH
64099: LD_VAR 0 2
64103: PPUSH
64104: EMPTY
64105: PPUSH
64106: CALL_OW 1
64110: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
64111: LD_ADDR_EXP 54
64115: PUSH
64116: LD_EXP 54
64120: PPUSH
64121: LD_VAR 0 2
64125: PPUSH
64126: LD_INT 0
64128: PPUSH
64129: CALL_OW 1
64133: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
64134: LD_ADDR_EXP 56
64138: PUSH
64139: LD_EXP 56
64143: PPUSH
64144: LD_VAR 0 2
64148: PPUSH
64149: EMPTY
64150: PPUSH
64151: CALL_OW 1
64155: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
64156: LD_ADDR_EXP 59
64160: PUSH
64161: LD_EXP 59
64165: PPUSH
64166: LD_VAR 0 2
64170: PPUSH
64171: LD_INT 0
64173: PPUSH
64174: CALL_OW 1
64178: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
64179: LD_ADDR_EXP 60
64183: PUSH
64184: LD_EXP 60
64188: PPUSH
64189: LD_VAR 0 2
64193: PPUSH
64194: EMPTY
64195: PPUSH
64196: CALL_OW 1
64200: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
64201: LD_ADDR_EXP 61
64205: PUSH
64206: LD_EXP 61
64210: PPUSH
64211: LD_VAR 0 2
64215: PPUSH
64216: EMPTY
64217: PPUSH
64218: CALL_OW 1
64222: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
64223: LD_ADDR_EXP 62
64227: PUSH
64228: LD_EXP 62
64232: PPUSH
64233: LD_VAR 0 2
64237: PPUSH
64238: EMPTY
64239: PPUSH
64240: CALL_OW 1
64244: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
64245: LD_ADDR_EXP 64
64249: PUSH
64250: LD_EXP 64
64254: PPUSH
64255: LD_VAR 0 2
64259: PPUSH
64260: LD_EXP 31
64264: PUSH
64265: LD_VAR 0 2
64269: ARRAY
64270: PPUSH
64271: LD_INT 2
64273: PUSH
64274: LD_INT 30
64276: PUSH
64277: LD_INT 6
64279: PUSH
64280: EMPTY
64281: LIST
64282: LIST
64283: PUSH
64284: LD_INT 30
64286: PUSH
64287: LD_INT 7
64289: PUSH
64290: EMPTY
64291: LIST
64292: LIST
64293: PUSH
64294: LD_INT 30
64296: PUSH
64297: LD_INT 8
64299: PUSH
64300: EMPTY
64301: LIST
64302: LIST
64303: PUSH
64304: EMPTY
64305: LIST
64306: LIST
64307: LIST
64308: LIST
64309: PPUSH
64310: CALL_OW 72
64314: PPUSH
64315: CALL_OW 1
64319: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
64320: LD_ADDR_EXP 65
64324: PUSH
64325: LD_EXP 65
64329: PPUSH
64330: LD_VAR 0 2
64334: PPUSH
64335: EMPTY
64336: PPUSH
64337: CALL_OW 1
64341: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
64342: LD_ADDR_EXP 66
64346: PUSH
64347: LD_EXP 66
64351: PPUSH
64352: LD_VAR 0 2
64356: PPUSH
64357: EMPTY
64358: PPUSH
64359: CALL_OW 1
64363: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
64364: LD_ADDR_EXP 67
64368: PUSH
64369: LD_EXP 67
64373: PPUSH
64374: LD_VAR 0 2
64378: PPUSH
64379: EMPTY
64380: PPUSH
64381: CALL_OW 1
64385: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
64386: LD_ADDR_EXP 68
64390: PUSH
64391: LD_EXP 68
64395: PPUSH
64396: LD_VAR 0 2
64400: PPUSH
64401: EMPTY
64402: PPUSH
64403: CALL_OW 1
64407: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
64408: LD_ADDR_EXP 69
64412: PUSH
64413: LD_EXP 69
64417: PPUSH
64418: LD_VAR 0 2
64422: PPUSH
64423: EMPTY
64424: PPUSH
64425: CALL_OW 1
64429: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
64430: LD_ADDR_EXP 70
64434: PUSH
64435: LD_EXP 70
64439: PPUSH
64440: LD_VAR 0 2
64444: PPUSH
64445: EMPTY
64446: PPUSH
64447: CALL_OW 1
64451: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
64452: LD_ADDR_EXP 71
64456: PUSH
64457: LD_EXP 71
64461: PPUSH
64462: LD_VAR 0 2
64466: PPUSH
64467: EMPTY
64468: PPUSH
64469: CALL_OW 1
64473: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
64474: LD_ADDR_EXP 72
64478: PUSH
64479: LD_EXP 72
64483: PPUSH
64484: LD_VAR 0 2
64488: PPUSH
64489: EMPTY
64490: PPUSH
64491: CALL_OW 1
64495: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
64496: LD_ADDR_EXP 73
64500: PUSH
64501: LD_EXP 73
64505: PPUSH
64506: LD_VAR 0 2
64510: PPUSH
64511: LD_INT 0
64513: PPUSH
64514: CALL_OW 1
64518: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
64519: LD_ADDR_EXP 74
64523: PUSH
64524: LD_EXP 74
64528: PPUSH
64529: LD_VAR 0 2
64533: PPUSH
64534: LD_INT 0
64536: PPUSH
64537: CALL_OW 1
64541: ST_TO_ADDR
// end ;
64542: GO 63443
64544: POP
64545: POP
// MC_InitSides ( ) ;
64546: CALL 64832 0 0
// MC_InitResearch ( ) ;
64550: CALL 64571 0 0
// CustomInitMacro ( ) ;
64554: CALL 1411 0 0
// skirmish := true ;
64558: LD_ADDR_EXP 29
64562: PUSH
64563: LD_INT 1
64565: ST_TO_ADDR
// end ;
64566: LD_VAR 0 1
64570: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
64571: LD_INT 0
64573: PPUSH
64574: PPUSH
64575: PPUSH
64576: PPUSH
64577: PPUSH
64578: PPUSH
// if not mc_bases then
64579: LD_EXP 31
64583: NOT
64584: IFFALSE 64588
// exit ;
64586: GO 64827
// for i = 1 to 8 do
64588: LD_ADDR_VAR 0 2
64592: PUSH
64593: DOUBLE
64594: LD_INT 1
64596: DEC
64597: ST_TO_ADDR
64598: LD_INT 8
64600: PUSH
64601: FOR_TO
64602: IFFALSE 64628
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
64604: LD_ADDR_EXP 58
64608: PUSH
64609: LD_EXP 58
64613: PPUSH
64614: LD_VAR 0 2
64618: PPUSH
64619: EMPTY
64620: PPUSH
64621: CALL_OW 1
64625: ST_TO_ADDR
64626: GO 64601
64628: POP
64629: POP
// tmp := [ ] ;
64630: LD_ADDR_VAR 0 5
64634: PUSH
64635: EMPTY
64636: ST_TO_ADDR
// for i = 1 to mc_sides do
64637: LD_ADDR_VAR 0 2
64641: PUSH
64642: DOUBLE
64643: LD_INT 1
64645: DEC
64646: ST_TO_ADDR
64647: LD_EXP 57
64651: PUSH
64652: FOR_TO
64653: IFFALSE 64711
// if not mc_sides [ i ] in tmp then
64655: LD_EXP 57
64659: PUSH
64660: LD_VAR 0 2
64664: ARRAY
64665: PUSH
64666: LD_VAR 0 5
64670: IN
64671: NOT
64672: IFFALSE 64709
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
64674: LD_ADDR_VAR 0 5
64678: PUSH
64679: LD_VAR 0 5
64683: PPUSH
64684: LD_VAR 0 5
64688: PUSH
64689: LD_INT 1
64691: PLUS
64692: PPUSH
64693: LD_EXP 57
64697: PUSH
64698: LD_VAR 0 2
64702: ARRAY
64703: PPUSH
64704: CALL_OW 2
64708: ST_TO_ADDR
64709: GO 64652
64711: POP
64712: POP
// if not tmp then
64713: LD_VAR 0 5
64717: NOT
64718: IFFALSE 64722
// exit ;
64720: GO 64827
// for j in tmp do
64722: LD_ADDR_VAR 0 3
64726: PUSH
64727: LD_VAR 0 5
64731: PUSH
64732: FOR_IN
64733: IFFALSE 64825
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
64735: LD_ADDR_VAR 0 6
64739: PUSH
64740: LD_INT 22
64742: PUSH
64743: LD_VAR 0 3
64747: PUSH
64748: EMPTY
64749: LIST
64750: LIST
64751: PPUSH
64752: CALL_OW 69
64756: ST_TO_ADDR
// if not un then
64757: LD_VAR 0 6
64761: NOT
64762: IFFALSE 64766
// continue ;
64764: GO 64732
// nation := GetNation ( un [ 1 ] ) ;
64766: LD_ADDR_VAR 0 4
64770: PUSH
64771: LD_VAR 0 6
64775: PUSH
64776: LD_INT 1
64778: ARRAY
64779: PPUSH
64780: CALL_OW 248
64784: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
64785: LD_ADDR_EXP 58
64789: PUSH
64790: LD_EXP 58
64794: PPUSH
64795: LD_VAR 0 3
64799: PPUSH
64800: LD_VAR 0 3
64804: PPUSH
64805: LD_VAR 0 4
64809: PPUSH
64810: LD_INT 1
64812: PPUSH
64813: CALL 19947 0 3
64817: PPUSH
64818: CALL_OW 1
64822: ST_TO_ADDR
// end ;
64823: GO 64732
64825: POP
64826: POP
// end ;
64827: LD_VAR 0 1
64831: RET
// export function MC_InitSides ( ) ; var i ; begin
64832: LD_INT 0
64834: PPUSH
64835: PPUSH
// if not mc_bases then
64836: LD_EXP 31
64840: NOT
64841: IFFALSE 64845
// exit ;
64843: GO 64919
// for i = 1 to mc_bases do
64845: LD_ADDR_VAR 0 2
64849: PUSH
64850: DOUBLE
64851: LD_INT 1
64853: DEC
64854: ST_TO_ADDR
64855: LD_EXP 31
64859: PUSH
64860: FOR_TO
64861: IFFALSE 64917
// if mc_bases [ i ] then
64863: LD_EXP 31
64867: PUSH
64868: LD_VAR 0 2
64872: ARRAY
64873: IFFALSE 64915
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
64875: LD_ADDR_EXP 57
64879: PUSH
64880: LD_EXP 57
64884: PPUSH
64885: LD_VAR 0 2
64889: PPUSH
64890: LD_EXP 31
64894: PUSH
64895: LD_VAR 0 2
64899: ARRAY
64900: PUSH
64901: LD_INT 1
64903: ARRAY
64904: PPUSH
64905: CALL_OW 255
64909: PPUSH
64910: CALL_OW 1
64914: ST_TO_ADDR
64915: GO 64860
64917: POP
64918: POP
// end ;
64919: LD_VAR 0 1
64923: RET
// every 0 0$03 trigger skirmish do
64924: LD_EXP 29
64928: IFFALSE 65082
64930: GO 64932
64932: DISABLE
// begin enable ;
64933: ENABLE
// MC_CheckBuildings ( ) ;
64934: CALL 69580 0 0
// MC_CheckPeopleLife ( ) ;
64938: CALL 69741 0 0
// RaiseSailEvent ( 100 ) ;
64942: LD_INT 100
64944: PPUSH
64945: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
64949: LD_INT 103
64951: PPUSH
64952: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
64956: LD_INT 104
64958: PPUSH
64959: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
64963: LD_INT 105
64965: PPUSH
64966: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
64970: LD_INT 106
64972: PPUSH
64973: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
64977: LD_INT 107
64979: PPUSH
64980: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
64984: LD_INT 108
64986: PPUSH
64987: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
64991: LD_INT 109
64993: PPUSH
64994: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
64998: LD_INT 110
65000: PPUSH
65001: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
65005: LD_INT 111
65007: PPUSH
65008: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
65012: LD_INT 112
65014: PPUSH
65015: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
65019: LD_INT 113
65021: PPUSH
65022: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
65026: LD_INT 120
65028: PPUSH
65029: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
65033: LD_INT 121
65035: PPUSH
65036: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
65040: LD_INT 122
65042: PPUSH
65043: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
65047: LD_INT 123
65049: PPUSH
65050: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
65054: LD_INT 124
65056: PPUSH
65057: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
65061: LD_INT 125
65063: PPUSH
65064: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
65068: LD_INT 126
65070: PPUSH
65071: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
65075: LD_INT 200
65077: PPUSH
65078: CALL_OW 427
// end ;
65082: END
// on SailEvent ( event ) do begin if event < 100 then
65083: LD_VAR 0 1
65087: PUSH
65088: LD_INT 100
65090: LESS
65091: IFFALSE 65102
// CustomEvent ( event ) ;
65093: LD_VAR 0 1
65097: PPUSH
65098: CALL 19111 0 1
// if event = 100 then
65102: LD_VAR 0 1
65106: PUSH
65107: LD_INT 100
65109: EQUAL
65110: IFFALSE 65116
// MC_ClassManager ( ) ;
65112: CALL 65508 0 0
// if event = 101 then
65116: LD_VAR 0 1
65120: PUSH
65121: LD_INT 101
65123: EQUAL
65124: IFFALSE 65130
// MC_RepairBuildings ( ) ;
65126: CALL 70326 0 0
// if event = 102 then
65130: LD_VAR 0 1
65134: PUSH
65135: LD_INT 102
65137: EQUAL
65138: IFFALSE 65144
// MC_Heal ( ) ;
65140: CALL 71261 0 0
// if event = 103 then
65144: LD_VAR 0 1
65148: PUSH
65149: LD_INT 103
65151: EQUAL
65152: IFFALSE 65158
// MC_Build ( ) ;
65154: CALL 71683 0 0
// if event = 104 then
65158: LD_VAR 0 1
65162: PUSH
65163: LD_INT 104
65165: EQUAL
65166: IFFALSE 65172
// MC_TurretWeapon ( ) ;
65168: CALL 73317 0 0
// if event = 105 then
65172: LD_VAR 0 1
65176: PUSH
65177: LD_INT 105
65179: EQUAL
65180: IFFALSE 65186
// MC_BuildUpgrade ( ) ;
65182: CALL 72868 0 0
// if event = 106 then
65186: LD_VAR 0 1
65190: PUSH
65191: LD_INT 106
65193: EQUAL
65194: IFFALSE 65200
// MC_PlantMines ( ) ;
65196: CALL 73747 0 0
// if event = 107 then
65200: LD_VAR 0 1
65204: PUSH
65205: LD_INT 107
65207: EQUAL
65208: IFFALSE 65214
// MC_CollectCrates ( ) ;
65210: CALL 74538 0 0
// if event = 108 then
65214: LD_VAR 0 1
65218: PUSH
65219: LD_INT 108
65221: EQUAL
65222: IFFALSE 65228
// MC_LinkRemoteControl ( ) ;
65224: CALL 76388 0 0
// if event = 109 then
65228: LD_VAR 0 1
65232: PUSH
65233: LD_INT 109
65235: EQUAL
65236: IFFALSE 65242
// MC_ProduceVehicle ( ) ;
65238: CALL 76569 0 0
// if event = 110 then
65242: LD_VAR 0 1
65246: PUSH
65247: LD_INT 110
65249: EQUAL
65250: IFFALSE 65256
// MC_SendAttack ( ) ;
65252: CALL 77035 0 0
// if event = 111 then
65256: LD_VAR 0 1
65260: PUSH
65261: LD_INT 111
65263: EQUAL
65264: IFFALSE 65270
// MC_Defend ( ) ;
65266: CALL 77143 0 0
// if event = 112 then
65270: LD_VAR 0 1
65274: PUSH
65275: LD_INT 112
65277: EQUAL
65278: IFFALSE 65284
// MC_Research ( ) ;
65280: CALL 78023 0 0
// if event = 113 then
65284: LD_VAR 0 1
65288: PUSH
65289: LD_INT 113
65291: EQUAL
65292: IFFALSE 65298
// MC_MinesTrigger ( ) ;
65294: CALL 79137 0 0
// if event = 120 then
65298: LD_VAR 0 1
65302: PUSH
65303: LD_INT 120
65305: EQUAL
65306: IFFALSE 65312
// MC_RepairVehicle ( ) ;
65308: CALL 79236 0 0
// if event = 121 then
65312: LD_VAR 0 1
65316: PUSH
65317: LD_INT 121
65319: EQUAL
65320: IFFALSE 65326
// MC_TameApe ( ) ;
65322: CALL 80005 0 0
// if event = 122 then
65326: LD_VAR 0 1
65330: PUSH
65331: LD_INT 122
65333: EQUAL
65334: IFFALSE 65340
// MC_ChangeApeClass ( ) ;
65336: CALL 80834 0 0
// if event = 123 then
65340: LD_VAR 0 1
65344: PUSH
65345: LD_INT 123
65347: EQUAL
65348: IFFALSE 65354
// MC_Bazooka ( ) ;
65350: CALL 81484 0 0
// if event = 124 then
65354: LD_VAR 0 1
65358: PUSH
65359: LD_INT 124
65361: EQUAL
65362: IFFALSE 65368
// MC_TeleportExit ( ) ;
65364: CALL 81682 0 0
// if event = 125 then
65368: LD_VAR 0 1
65372: PUSH
65373: LD_INT 125
65375: EQUAL
65376: IFFALSE 65382
// MC_Deposits ( ) ;
65378: CALL 82329 0 0
// if event = 126 then
65382: LD_VAR 0 1
65386: PUSH
65387: LD_INT 126
65389: EQUAL
65390: IFFALSE 65396
// MC_RemoteDriver ( ) ;
65392: CALL 82954 0 0
// if event = 200 then
65396: LD_VAR 0 1
65400: PUSH
65401: LD_INT 200
65403: EQUAL
65404: IFFALSE 65410
// MC_Idle ( ) ;
65406: CALL 84903 0 0
// end ;
65410: PPOPN 1
65412: END
// export function MC_Reset ( base , tag ) ; var i ; begin
65413: LD_INT 0
65415: PPUSH
65416: PPUSH
// if not mc_bases [ base ] or not tag then
65417: LD_EXP 31
65421: PUSH
65422: LD_VAR 0 1
65426: ARRAY
65427: NOT
65428: PUSH
65429: LD_VAR 0 2
65433: NOT
65434: OR
65435: IFFALSE 65439
// exit ;
65437: GO 65503
// for i in mc_bases [ base ] union mc_ape [ base ] do
65439: LD_ADDR_VAR 0 4
65443: PUSH
65444: LD_EXP 31
65448: PUSH
65449: LD_VAR 0 1
65453: ARRAY
65454: PUSH
65455: LD_EXP 60
65459: PUSH
65460: LD_VAR 0 1
65464: ARRAY
65465: UNION
65466: PUSH
65467: FOR_IN
65468: IFFALSE 65501
// if GetTag ( i ) = tag then
65470: LD_VAR 0 4
65474: PPUSH
65475: CALL_OW 110
65479: PUSH
65480: LD_VAR 0 2
65484: EQUAL
65485: IFFALSE 65499
// SetTag ( i , 0 ) ;
65487: LD_VAR 0 4
65491: PPUSH
65492: LD_INT 0
65494: PPUSH
65495: CALL_OW 109
65499: GO 65467
65501: POP
65502: POP
// end ;
65503: LD_VAR 0 3
65507: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
65508: LD_INT 0
65510: PPUSH
65511: PPUSH
65512: PPUSH
65513: PPUSH
65514: PPUSH
65515: PPUSH
65516: PPUSH
65517: PPUSH
// if not mc_bases then
65518: LD_EXP 31
65522: NOT
65523: IFFALSE 65527
// exit ;
65525: GO 65985
// for i = 1 to mc_bases do
65527: LD_ADDR_VAR 0 2
65531: PUSH
65532: DOUBLE
65533: LD_INT 1
65535: DEC
65536: ST_TO_ADDR
65537: LD_EXP 31
65541: PUSH
65542: FOR_TO
65543: IFFALSE 65983
// begin tmp := MC_ClassCheckReq ( i ) ;
65545: LD_ADDR_VAR 0 4
65549: PUSH
65550: LD_VAR 0 2
65554: PPUSH
65555: CALL 65990 0 1
65559: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
65560: LD_ADDR_EXP 72
65564: PUSH
65565: LD_EXP 72
65569: PPUSH
65570: LD_VAR 0 2
65574: PPUSH
65575: LD_VAR 0 4
65579: PPUSH
65580: CALL_OW 1
65584: ST_TO_ADDR
// if not tmp then
65585: LD_VAR 0 4
65589: NOT
65590: IFFALSE 65594
// continue ;
65592: GO 65542
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
65594: LD_ADDR_VAR 0 6
65598: PUSH
65599: LD_EXP 31
65603: PUSH
65604: LD_VAR 0 2
65608: ARRAY
65609: PPUSH
65610: LD_INT 2
65612: PUSH
65613: LD_INT 30
65615: PUSH
65616: LD_INT 4
65618: PUSH
65619: EMPTY
65620: LIST
65621: LIST
65622: PUSH
65623: LD_INT 30
65625: PUSH
65626: LD_INT 5
65628: PUSH
65629: EMPTY
65630: LIST
65631: LIST
65632: PUSH
65633: EMPTY
65634: LIST
65635: LIST
65636: LIST
65637: PPUSH
65638: CALL_OW 72
65642: PUSH
65643: LD_EXP 31
65647: PUSH
65648: LD_VAR 0 2
65652: ARRAY
65653: PPUSH
65654: LD_INT 2
65656: PUSH
65657: LD_INT 30
65659: PUSH
65660: LD_INT 0
65662: PUSH
65663: EMPTY
65664: LIST
65665: LIST
65666: PUSH
65667: LD_INT 30
65669: PUSH
65670: LD_INT 1
65672: PUSH
65673: EMPTY
65674: LIST
65675: LIST
65676: PUSH
65677: EMPTY
65678: LIST
65679: LIST
65680: LIST
65681: PPUSH
65682: CALL_OW 72
65686: PUSH
65687: LD_EXP 31
65691: PUSH
65692: LD_VAR 0 2
65696: ARRAY
65697: PPUSH
65698: LD_INT 30
65700: PUSH
65701: LD_INT 3
65703: PUSH
65704: EMPTY
65705: LIST
65706: LIST
65707: PPUSH
65708: CALL_OW 72
65712: PUSH
65713: LD_EXP 31
65717: PUSH
65718: LD_VAR 0 2
65722: ARRAY
65723: PPUSH
65724: LD_INT 2
65726: PUSH
65727: LD_INT 30
65729: PUSH
65730: LD_INT 6
65732: PUSH
65733: EMPTY
65734: LIST
65735: LIST
65736: PUSH
65737: LD_INT 30
65739: PUSH
65740: LD_INT 7
65742: PUSH
65743: EMPTY
65744: LIST
65745: LIST
65746: PUSH
65747: LD_INT 30
65749: PUSH
65750: LD_INT 8
65752: PUSH
65753: EMPTY
65754: LIST
65755: LIST
65756: PUSH
65757: EMPTY
65758: LIST
65759: LIST
65760: LIST
65761: LIST
65762: PPUSH
65763: CALL_OW 72
65767: PUSH
65768: EMPTY
65769: LIST
65770: LIST
65771: LIST
65772: LIST
65773: ST_TO_ADDR
// for j = 1 to 4 do
65774: LD_ADDR_VAR 0 3
65778: PUSH
65779: DOUBLE
65780: LD_INT 1
65782: DEC
65783: ST_TO_ADDR
65784: LD_INT 4
65786: PUSH
65787: FOR_TO
65788: IFFALSE 65979
// begin if not tmp [ j ] then
65790: LD_VAR 0 4
65794: PUSH
65795: LD_VAR 0 3
65799: ARRAY
65800: NOT
65801: IFFALSE 65805
// continue ;
65803: GO 65787
// for p in tmp [ j ] do
65805: LD_ADDR_VAR 0 5
65809: PUSH
65810: LD_VAR 0 4
65814: PUSH
65815: LD_VAR 0 3
65819: ARRAY
65820: PUSH
65821: FOR_IN
65822: IFFALSE 65975
// begin if not b [ j ] then
65824: LD_VAR 0 6
65828: PUSH
65829: LD_VAR 0 3
65833: ARRAY
65834: NOT
65835: IFFALSE 65839
// break ;
65837: GO 65975
// e := 0 ;
65839: LD_ADDR_VAR 0 7
65843: PUSH
65844: LD_INT 0
65846: ST_TO_ADDR
// for k in b [ j ] do
65847: LD_ADDR_VAR 0 8
65851: PUSH
65852: LD_VAR 0 6
65856: PUSH
65857: LD_VAR 0 3
65861: ARRAY
65862: PUSH
65863: FOR_IN
65864: IFFALSE 65891
// if IsNotFull ( k ) then
65866: LD_VAR 0 8
65870: PPUSH
65871: CALL 22100 0 1
65875: IFFALSE 65889
// begin e := k ;
65877: LD_ADDR_VAR 0 7
65881: PUSH
65882: LD_VAR 0 8
65886: ST_TO_ADDR
// break ;
65887: GO 65891
// end ;
65889: GO 65863
65891: POP
65892: POP
// if e and not UnitGoingToBuilding ( p , e ) then
65893: LD_VAR 0 7
65897: PUSH
65898: LD_VAR 0 5
65902: PPUSH
65903: LD_VAR 0 7
65907: PPUSH
65908: CALL 55979 0 2
65912: NOT
65913: AND
65914: IFFALSE 65973
// begin if IsInUnit ( p ) then
65916: LD_VAR 0 5
65920: PPUSH
65921: CALL_OW 310
65925: IFFALSE 65936
// ComExitBuilding ( p ) ;
65927: LD_VAR 0 5
65931: PPUSH
65932: CALL_OW 122
// ComEnterUnit ( p , e ) ;
65936: LD_VAR 0 5
65940: PPUSH
65941: LD_VAR 0 7
65945: PPUSH
65946: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
65950: LD_VAR 0 5
65954: PPUSH
65955: LD_VAR 0 3
65959: PPUSH
65960: CALL_OW 183
// AddComExitBuilding ( p ) ;
65964: LD_VAR 0 5
65968: PPUSH
65969: CALL_OW 182
// end ; end ;
65973: GO 65821
65975: POP
65976: POP
// end ;
65977: GO 65787
65979: POP
65980: POP
// end ;
65981: GO 65542
65983: POP
65984: POP
// end ;
65985: LD_VAR 0 1
65989: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
65990: LD_INT 0
65992: PPUSH
65993: PPUSH
65994: PPUSH
65995: PPUSH
65996: PPUSH
65997: PPUSH
65998: PPUSH
65999: PPUSH
66000: PPUSH
66001: PPUSH
66002: PPUSH
66003: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
66004: LD_VAR 0 1
66008: NOT
66009: PUSH
66010: LD_EXP 31
66014: PUSH
66015: LD_VAR 0 1
66019: ARRAY
66020: NOT
66021: OR
66022: PUSH
66023: LD_EXP 31
66027: PUSH
66028: LD_VAR 0 1
66032: ARRAY
66033: PPUSH
66034: LD_INT 2
66036: PUSH
66037: LD_INT 30
66039: PUSH
66040: LD_INT 0
66042: PUSH
66043: EMPTY
66044: LIST
66045: LIST
66046: PUSH
66047: LD_INT 30
66049: PUSH
66050: LD_INT 1
66052: PUSH
66053: EMPTY
66054: LIST
66055: LIST
66056: PUSH
66057: EMPTY
66058: LIST
66059: LIST
66060: LIST
66061: PPUSH
66062: CALL_OW 72
66066: NOT
66067: OR
66068: IFFALSE 66072
// exit ;
66070: GO 69575
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
66072: LD_ADDR_VAR 0 4
66076: PUSH
66077: LD_EXP 31
66081: PUSH
66082: LD_VAR 0 1
66086: ARRAY
66087: PPUSH
66088: LD_INT 2
66090: PUSH
66091: LD_INT 25
66093: PUSH
66094: LD_INT 1
66096: PUSH
66097: EMPTY
66098: LIST
66099: LIST
66100: PUSH
66101: LD_INT 25
66103: PUSH
66104: LD_INT 2
66106: PUSH
66107: EMPTY
66108: LIST
66109: LIST
66110: PUSH
66111: LD_INT 25
66113: PUSH
66114: LD_INT 3
66116: PUSH
66117: EMPTY
66118: LIST
66119: LIST
66120: PUSH
66121: LD_INT 25
66123: PUSH
66124: LD_INT 4
66126: PUSH
66127: EMPTY
66128: LIST
66129: LIST
66130: PUSH
66131: LD_INT 25
66133: PUSH
66134: LD_INT 5
66136: PUSH
66137: EMPTY
66138: LIST
66139: LIST
66140: PUSH
66141: LD_INT 25
66143: PUSH
66144: LD_INT 8
66146: PUSH
66147: EMPTY
66148: LIST
66149: LIST
66150: PUSH
66151: LD_INT 25
66153: PUSH
66154: LD_INT 9
66156: PUSH
66157: EMPTY
66158: LIST
66159: LIST
66160: PUSH
66161: EMPTY
66162: LIST
66163: LIST
66164: LIST
66165: LIST
66166: LIST
66167: LIST
66168: LIST
66169: LIST
66170: PPUSH
66171: CALL_OW 72
66175: ST_TO_ADDR
// if not tmp then
66176: LD_VAR 0 4
66180: NOT
66181: IFFALSE 66185
// exit ;
66183: GO 69575
// for i in tmp do
66185: LD_ADDR_VAR 0 3
66189: PUSH
66190: LD_VAR 0 4
66194: PUSH
66195: FOR_IN
66196: IFFALSE 66227
// if GetTag ( i ) then
66198: LD_VAR 0 3
66202: PPUSH
66203: CALL_OW 110
66207: IFFALSE 66225
// tmp := tmp diff i ;
66209: LD_ADDR_VAR 0 4
66213: PUSH
66214: LD_VAR 0 4
66218: PUSH
66219: LD_VAR 0 3
66223: DIFF
66224: ST_TO_ADDR
66225: GO 66195
66227: POP
66228: POP
// if not tmp then
66229: LD_VAR 0 4
66233: NOT
66234: IFFALSE 66238
// exit ;
66236: GO 69575
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
66238: LD_ADDR_VAR 0 5
66242: PUSH
66243: LD_EXP 31
66247: PUSH
66248: LD_VAR 0 1
66252: ARRAY
66253: PPUSH
66254: LD_INT 2
66256: PUSH
66257: LD_INT 25
66259: PUSH
66260: LD_INT 1
66262: PUSH
66263: EMPTY
66264: LIST
66265: LIST
66266: PUSH
66267: LD_INT 25
66269: PUSH
66270: LD_INT 5
66272: PUSH
66273: EMPTY
66274: LIST
66275: LIST
66276: PUSH
66277: LD_INT 25
66279: PUSH
66280: LD_INT 8
66282: PUSH
66283: EMPTY
66284: LIST
66285: LIST
66286: PUSH
66287: LD_INT 25
66289: PUSH
66290: LD_INT 9
66292: PUSH
66293: EMPTY
66294: LIST
66295: LIST
66296: PUSH
66297: EMPTY
66298: LIST
66299: LIST
66300: LIST
66301: LIST
66302: LIST
66303: PPUSH
66304: CALL_OW 72
66308: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
66309: LD_ADDR_VAR 0 6
66313: PUSH
66314: LD_EXP 31
66318: PUSH
66319: LD_VAR 0 1
66323: ARRAY
66324: PPUSH
66325: LD_INT 25
66327: PUSH
66328: LD_INT 2
66330: PUSH
66331: EMPTY
66332: LIST
66333: LIST
66334: PPUSH
66335: CALL_OW 72
66339: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
66340: LD_ADDR_VAR 0 7
66344: PUSH
66345: LD_EXP 31
66349: PUSH
66350: LD_VAR 0 1
66354: ARRAY
66355: PPUSH
66356: LD_INT 25
66358: PUSH
66359: LD_INT 3
66361: PUSH
66362: EMPTY
66363: LIST
66364: LIST
66365: PPUSH
66366: CALL_OW 72
66370: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
66371: LD_ADDR_VAR 0 8
66375: PUSH
66376: LD_EXP 31
66380: PUSH
66381: LD_VAR 0 1
66385: ARRAY
66386: PPUSH
66387: LD_INT 25
66389: PUSH
66390: LD_INT 4
66392: PUSH
66393: EMPTY
66394: LIST
66395: LIST
66396: PUSH
66397: LD_INT 24
66399: PUSH
66400: LD_INT 251
66402: PUSH
66403: EMPTY
66404: LIST
66405: LIST
66406: PUSH
66407: EMPTY
66408: LIST
66409: LIST
66410: PPUSH
66411: CALL_OW 72
66415: ST_TO_ADDR
// if mc_is_defending [ base ] then
66416: LD_EXP 74
66420: PUSH
66421: LD_VAR 0 1
66425: ARRAY
66426: IFFALSE 66887
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
66428: LD_ADDR_EXP 73
66432: PUSH
66433: LD_EXP 73
66437: PPUSH
66438: LD_VAR 0 1
66442: PPUSH
66443: LD_INT 4
66445: PPUSH
66446: CALL_OW 1
66450: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
66451: LD_ADDR_VAR 0 12
66455: PUSH
66456: LD_EXP 31
66460: PUSH
66461: LD_VAR 0 1
66465: ARRAY
66466: PPUSH
66467: LD_INT 2
66469: PUSH
66470: LD_INT 30
66472: PUSH
66473: LD_INT 4
66475: PUSH
66476: EMPTY
66477: LIST
66478: LIST
66479: PUSH
66480: LD_INT 30
66482: PUSH
66483: LD_INT 5
66485: PUSH
66486: EMPTY
66487: LIST
66488: LIST
66489: PUSH
66490: EMPTY
66491: LIST
66492: LIST
66493: LIST
66494: PPUSH
66495: CALL_OW 72
66499: ST_TO_ADDR
// if not b then
66500: LD_VAR 0 12
66504: NOT
66505: IFFALSE 66509
// exit ;
66507: GO 69575
// p := [ ] ;
66509: LD_ADDR_VAR 0 11
66513: PUSH
66514: EMPTY
66515: ST_TO_ADDR
// if sci >= 2 then
66516: LD_VAR 0 8
66520: PUSH
66521: LD_INT 2
66523: GREATEREQUAL
66524: IFFALSE 66555
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
66526: LD_ADDR_VAR 0 8
66530: PUSH
66531: LD_VAR 0 8
66535: PUSH
66536: LD_INT 1
66538: ARRAY
66539: PUSH
66540: LD_VAR 0 8
66544: PUSH
66545: LD_INT 2
66547: ARRAY
66548: PUSH
66549: EMPTY
66550: LIST
66551: LIST
66552: ST_TO_ADDR
66553: GO 66616
// if sci = 1 then
66555: LD_VAR 0 8
66559: PUSH
66560: LD_INT 1
66562: EQUAL
66563: IFFALSE 66584
// sci := [ sci [ 1 ] ] else
66565: LD_ADDR_VAR 0 8
66569: PUSH
66570: LD_VAR 0 8
66574: PUSH
66575: LD_INT 1
66577: ARRAY
66578: PUSH
66579: EMPTY
66580: LIST
66581: ST_TO_ADDR
66582: GO 66616
// if sci = 0 then
66584: LD_VAR 0 8
66588: PUSH
66589: LD_INT 0
66591: EQUAL
66592: IFFALSE 66616
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
66594: LD_ADDR_VAR 0 11
66598: PUSH
66599: LD_VAR 0 4
66603: PPUSH
66604: LD_INT 4
66606: PPUSH
66607: CALL 55842 0 2
66611: PUSH
66612: LD_INT 1
66614: ARRAY
66615: ST_TO_ADDR
// if eng > 4 then
66616: LD_VAR 0 6
66620: PUSH
66621: LD_INT 4
66623: GREATER
66624: IFFALSE 66670
// for i = eng downto 4 do
66626: LD_ADDR_VAR 0 3
66630: PUSH
66631: DOUBLE
66632: LD_VAR 0 6
66636: INC
66637: ST_TO_ADDR
66638: LD_INT 4
66640: PUSH
66641: FOR_DOWNTO
66642: IFFALSE 66668
// eng := eng diff eng [ i ] ;
66644: LD_ADDR_VAR 0 6
66648: PUSH
66649: LD_VAR 0 6
66653: PUSH
66654: LD_VAR 0 6
66658: PUSH
66659: LD_VAR 0 3
66663: ARRAY
66664: DIFF
66665: ST_TO_ADDR
66666: GO 66641
66668: POP
66669: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
66670: LD_ADDR_VAR 0 4
66674: PUSH
66675: LD_VAR 0 4
66679: PUSH
66680: LD_VAR 0 5
66684: PUSH
66685: LD_VAR 0 6
66689: UNION
66690: PUSH
66691: LD_VAR 0 7
66695: UNION
66696: PUSH
66697: LD_VAR 0 8
66701: UNION
66702: DIFF
66703: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
66704: LD_ADDR_VAR 0 13
66708: PUSH
66709: LD_EXP 31
66713: PUSH
66714: LD_VAR 0 1
66718: ARRAY
66719: PPUSH
66720: LD_INT 2
66722: PUSH
66723: LD_INT 30
66725: PUSH
66726: LD_INT 32
66728: PUSH
66729: EMPTY
66730: LIST
66731: LIST
66732: PUSH
66733: LD_INT 30
66735: PUSH
66736: LD_INT 31
66738: PUSH
66739: EMPTY
66740: LIST
66741: LIST
66742: PUSH
66743: EMPTY
66744: LIST
66745: LIST
66746: LIST
66747: PPUSH
66748: CALL_OW 72
66752: PUSH
66753: LD_EXP 31
66757: PUSH
66758: LD_VAR 0 1
66762: ARRAY
66763: PPUSH
66764: LD_INT 2
66766: PUSH
66767: LD_INT 30
66769: PUSH
66770: LD_INT 4
66772: PUSH
66773: EMPTY
66774: LIST
66775: LIST
66776: PUSH
66777: LD_INT 30
66779: PUSH
66780: LD_INT 5
66782: PUSH
66783: EMPTY
66784: LIST
66785: LIST
66786: PUSH
66787: EMPTY
66788: LIST
66789: LIST
66790: LIST
66791: PPUSH
66792: CALL_OW 72
66796: PUSH
66797: LD_INT 6
66799: MUL
66800: PLUS
66801: ST_TO_ADDR
// if bcount < tmp then
66802: LD_VAR 0 13
66806: PUSH
66807: LD_VAR 0 4
66811: LESS
66812: IFFALSE 66858
// for i = tmp downto bcount do
66814: LD_ADDR_VAR 0 3
66818: PUSH
66819: DOUBLE
66820: LD_VAR 0 4
66824: INC
66825: ST_TO_ADDR
66826: LD_VAR 0 13
66830: PUSH
66831: FOR_DOWNTO
66832: IFFALSE 66856
// tmp := Delete ( tmp , tmp ) ;
66834: LD_ADDR_VAR 0 4
66838: PUSH
66839: LD_VAR 0 4
66843: PPUSH
66844: LD_VAR 0 4
66848: PPUSH
66849: CALL_OW 3
66853: ST_TO_ADDR
66854: GO 66831
66856: POP
66857: POP
// result := [ tmp , 0 , 0 , p ] ;
66858: LD_ADDR_VAR 0 2
66862: PUSH
66863: LD_VAR 0 4
66867: PUSH
66868: LD_INT 0
66870: PUSH
66871: LD_INT 0
66873: PUSH
66874: LD_VAR 0 11
66878: PUSH
66879: EMPTY
66880: LIST
66881: LIST
66882: LIST
66883: LIST
66884: ST_TO_ADDR
// exit ;
66885: GO 69575
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
66887: LD_EXP 31
66891: PUSH
66892: LD_VAR 0 1
66896: ARRAY
66897: PPUSH
66898: LD_INT 2
66900: PUSH
66901: LD_INT 30
66903: PUSH
66904: LD_INT 6
66906: PUSH
66907: EMPTY
66908: LIST
66909: LIST
66910: PUSH
66911: LD_INT 30
66913: PUSH
66914: LD_INT 7
66916: PUSH
66917: EMPTY
66918: LIST
66919: LIST
66920: PUSH
66921: LD_INT 30
66923: PUSH
66924: LD_INT 8
66926: PUSH
66927: EMPTY
66928: LIST
66929: LIST
66930: PUSH
66931: EMPTY
66932: LIST
66933: LIST
66934: LIST
66935: LIST
66936: PPUSH
66937: CALL_OW 72
66941: NOT
66942: PUSH
66943: LD_EXP 31
66947: PUSH
66948: LD_VAR 0 1
66952: ARRAY
66953: PPUSH
66954: LD_INT 30
66956: PUSH
66957: LD_INT 3
66959: PUSH
66960: EMPTY
66961: LIST
66962: LIST
66963: PPUSH
66964: CALL_OW 72
66968: NOT
66969: AND
66970: IFFALSE 67042
// begin if eng = tmp then
66972: LD_VAR 0 6
66976: PUSH
66977: LD_VAR 0 4
66981: EQUAL
66982: IFFALSE 66986
// exit ;
66984: GO 69575
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
66986: LD_ADDR_EXP 73
66990: PUSH
66991: LD_EXP 73
66995: PPUSH
66996: LD_VAR 0 1
67000: PPUSH
67001: LD_INT 1
67003: PPUSH
67004: CALL_OW 1
67008: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
67009: LD_ADDR_VAR 0 2
67013: PUSH
67014: LD_INT 0
67016: PUSH
67017: LD_VAR 0 4
67021: PUSH
67022: LD_VAR 0 6
67026: DIFF
67027: PUSH
67028: LD_INT 0
67030: PUSH
67031: LD_INT 0
67033: PUSH
67034: EMPTY
67035: LIST
67036: LIST
67037: LIST
67038: LIST
67039: ST_TO_ADDR
// exit ;
67040: GO 69575
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
67042: LD_EXP 58
67046: PUSH
67047: LD_EXP 57
67051: PUSH
67052: LD_VAR 0 1
67056: ARRAY
67057: ARRAY
67058: PUSH
67059: LD_EXP 31
67063: PUSH
67064: LD_VAR 0 1
67068: ARRAY
67069: PPUSH
67070: LD_INT 2
67072: PUSH
67073: LD_INT 30
67075: PUSH
67076: LD_INT 6
67078: PUSH
67079: EMPTY
67080: LIST
67081: LIST
67082: PUSH
67083: LD_INT 30
67085: PUSH
67086: LD_INT 7
67088: PUSH
67089: EMPTY
67090: LIST
67091: LIST
67092: PUSH
67093: LD_INT 30
67095: PUSH
67096: LD_INT 8
67098: PUSH
67099: EMPTY
67100: LIST
67101: LIST
67102: PUSH
67103: EMPTY
67104: LIST
67105: LIST
67106: LIST
67107: LIST
67108: PPUSH
67109: CALL_OW 72
67113: AND
67114: PUSH
67115: LD_EXP 31
67119: PUSH
67120: LD_VAR 0 1
67124: ARRAY
67125: PPUSH
67126: LD_INT 30
67128: PUSH
67129: LD_INT 3
67131: PUSH
67132: EMPTY
67133: LIST
67134: LIST
67135: PPUSH
67136: CALL_OW 72
67140: NOT
67141: AND
67142: IFFALSE 67356
// begin if sci >= 6 then
67144: LD_VAR 0 8
67148: PUSH
67149: LD_INT 6
67151: GREATEREQUAL
67152: IFFALSE 67156
// exit ;
67154: GO 69575
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
67156: LD_ADDR_EXP 73
67160: PUSH
67161: LD_EXP 73
67165: PPUSH
67166: LD_VAR 0 1
67170: PPUSH
67171: LD_INT 2
67173: PPUSH
67174: CALL_OW 1
67178: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
67179: LD_ADDR_VAR 0 9
67183: PUSH
67184: LD_VAR 0 4
67188: PUSH
67189: LD_VAR 0 8
67193: DIFF
67194: PPUSH
67195: LD_INT 4
67197: PPUSH
67198: CALL 55842 0 2
67202: ST_TO_ADDR
// p := [ ] ;
67203: LD_ADDR_VAR 0 11
67207: PUSH
67208: EMPTY
67209: ST_TO_ADDR
// if sci < 6 and sort > 6 then
67210: LD_VAR 0 8
67214: PUSH
67215: LD_INT 6
67217: LESS
67218: PUSH
67219: LD_VAR 0 9
67223: PUSH
67224: LD_INT 6
67226: GREATER
67227: AND
67228: IFFALSE 67309
// begin for i = 1 to 6 - sci do
67230: LD_ADDR_VAR 0 3
67234: PUSH
67235: DOUBLE
67236: LD_INT 1
67238: DEC
67239: ST_TO_ADDR
67240: LD_INT 6
67242: PUSH
67243: LD_VAR 0 8
67247: MINUS
67248: PUSH
67249: FOR_TO
67250: IFFALSE 67305
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
67252: LD_ADDR_VAR 0 11
67256: PUSH
67257: LD_VAR 0 11
67261: PPUSH
67262: LD_VAR 0 11
67266: PUSH
67267: LD_INT 1
67269: PLUS
67270: PPUSH
67271: LD_VAR 0 9
67275: PUSH
67276: LD_INT 1
67278: ARRAY
67279: PPUSH
67280: CALL_OW 2
67284: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
67285: LD_ADDR_VAR 0 9
67289: PUSH
67290: LD_VAR 0 9
67294: PPUSH
67295: LD_INT 1
67297: PPUSH
67298: CALL_OW 3
67302: ST_TO_ADDR
// end ;
67303: GO 67249
67305: POP
67306: POP
// end else
67307: GO 67329
// if sort then
67309: LD_VAR 0 9
67313: IFFALSE 67329
// p := sort [ 1 ] ;
67315: LD_ADDR_VAR 0 11
67319: PUSH
67320: LD_VAR 0 9
67324: PUSH
67325: LD_INT 1
67327: ARRAY
67328: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
67329: LD_ADDR_VAR 0 2
67333: PUSH
67334: LD_INT 0
67336: PUSH
67337: LD_INT 0
67339: PUSH
67340: LD_INT 0
67342: PUSH
67343: LD_VAR 0 11
67347: PUSH
67348: EMPTY
67349: LIST
67350: LIST
67351: LIST
67352: LIST
67353: ST_TO_ADDR
// exit ;
67354: GO 69575
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
67356: LD_EXP 58
67360: PUSH
67361: LD_EXP 57
67365: PUSH
67366: LD_VAR 0 1
67370: ARRAY
67371: ARRAY
67372: PUSH
67373: LD_EXP 31
67377: PUSH
67378: LD_VAR 0 1
67382: ARRAY
67383: PPUSH
67384: LD_INT 2
67386: PUSH
67387: LD_INT 30
67389: PUSH
67390: LD_INT 6
67392: PUSH
67393: EMPTY
67394: LIST
67395: LIST
67396: PUSH
67397: LD_INT 30
67399: PUSH
67400: LD_INT 7
67402: PUSH
67403: EMPTY
67404: LIST
67405: LIST
67406: PUSH
67407: LD_INT 30
67409: PUSH
67410: LD_INT 8
67412: PUSH
67413: EMPTY
67414: LIST
67415: LIST
67416: PUSH
67417: EMPTY
67418: LIST
67419: LIST
67420: LIST
67421: LIST
67422: PPUSH
67423: CALL_OW 72
67427: AND
67428: PUSH
67429: LD_EXP 31
67433: PUSH
67434: LD_VAR 0 1
67438: ARRAY
67439: PPUSH
67440: LD_INT 30
67442: PUSH
67443: LD_INT 3
67445: PUSH
67446: EMPTY
67447: LIST
67448: LIST
67449: PPUSH
67450: CALL_OW 72
67454: AND
67455: IFFALSE 68189
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
67457: LD_ADDR_EXP 73
67461: PUSH
67462: LD_EXP 73
67466: PPUSH
67467: LD_VAR 0 1
67471: PPUSH
67472: LD_INT 3
67474: PPUSH
67475: CALL_OW 1
67479: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
67480: LD_ADDR_VAR 0 2
67484: PUSH
67485: LD_INT 0
67487: PUSH
67488: LD_INT 0
67490: PUSH
67491: LD_INT 0
67493: PUSH
67494: LD_INT 0
67496: PUSH
67497: EMPTY
67498: LIST
67499: LIST
67500: LIST
67501: LIST
67502: ST_TO_ADDR
// if not eng then
67503: LD_VAR 0 6
67507: NOT
67508: IFFALSE 67571
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
67510: LD_ADDR_VAR 0 11
67514: PUSH
67515: LD_VAR 0 4
67519: PPUSH
67520: LD_INT 2
67522: PPUSH
67523: CALL 55842 0 2
67527: PUSH
67528: LD_INT 1
67530: ARRAY
67531: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
67532: LD_ADDR_VAR 0 2
67536: PUSH
67537: LD_VAR 0 2
67541: PPUSH
67542: LD_INT 2
67544: PPUSH
67545: LD_VAR 0 11
67549: PPUSH
67550: CALL_OW 1
67554: ST_TO_ADDR
// tmp := tmp diff p ;
67555: LD_ADDR_VAR 0 4
67559: PUSH
67560: LD_VAR 0 4
67564: PUSH
67565: LD_VAR 0 11
67569: DIFF
67570: ST_TO_ADDR
// end ; if tmp and sci < 6 then
67571: LD_VAR 0 4
67575: PUSH
67576: LD_VAR 0 8
67580: PUSH
67581: LD_INT 6
67583: LESS
67584: AND
67585: IFFALSE 67773
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
67587: LD_ADDR_VAR 0 9
67591: PUSH
67592: LD_VAR 0 4
67596: PUSH
67597: LD_VAR 0 8
67601: PUSH
67602: LD_VAR 0 7
67606: UNION
67607: DIFF
67608: PPUSH
67609: LD_INT 4
67611: PPUSH
67612: CALL 55842 0 2
67616: ST_TO_ADDR
// p := [ ] ;
67617: LD_ADDR_VAR 0 11
67621: PUSH
67622: EMPTY
67623: ST_TO_ADDR
// if sort then
67624: LD_VAR 0 9
67628: IFFALSE 67744
// for i = 1 to 6 - sci do
67630: LD_ADDR_VAR 0 3
67634: PUSH
67635: DOUBLE
67636: LD_INT 1
67638: DEC
67639: ST_TO_ADDR
67640: LD_INT 6
67642: PUSH
67643: LD_VAR 0 8
67647: MINUS
67648: PUSH
67649: FOR_TO
67650: IFFALSE 67742
// begin if i = sort then
67652: LD_VAR 0 3
67656: PUSH
67657: LD_VAR 0 9
67661: EQUAL
67662: IFFALSE 67666
// break ;
67664: GO 67742
// if GetClass ( i ) = 4 then
67666: LD_VAR 0 3
67670: PPUSH
67671: CALL_OW 257
67675: PUSH
67676: LD_INT 4
67678: EQUAL
67679: IFFALSE 67683
// continue ;
67681: GO 67649
// p := Insert ( p , p + 1 , sort [ i ] ) ;
67683: LD_ADDR_VAR 0 11
67687: PUSH
67688: LD_VAR 0 11
67692: PPUSH
67693: LD_VAR 0 11
67697: PUSH
67698: LD_INT 1
67700: PLUS
67701: PPUSH
67702: LD_VAR 0 9
67706: PUSH
67707: LD_VAR 0 3
67711: ARRAY
67712: PPUSH
67713: CALL_OW 2
67717: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
67718: LD_ADDR_VAR 0 4
67722: PUSH
67723: LD_VAR 0 4
67727: PUSH
67728: LD_VAR 0 9
67732: PUSH
67733: LD_VAR 0 3
67737: ARRAY
67738: DIFF
67739: ST_TO_ADDR
// end ;
67740: GO 67649
67742: POP
67743: POP
// if p then
67744: LD_VAR 0 11
67748: IFFALSE 67773
// result := Replace ( result , 4 , p ) ;
67750: LD_ADDR_VAR 0 2
67754: PUSH
67755: LD_VAR 0 2
67759: PPUSH
67760: LD_INT 4
67762: PPUSH
67763: LD_VAR 0 11
67767: PPUSH
67768: CALL_OW 1
67772: ST_TO_ADDR
// end ; if tmp and mech < 6 then
67773: LD_VAR 0 4
67777: PUSH
67778: LD_VAR 0 7
67782: PUSH
67783: LD_INT 6
67785: LESS
67786: AND
67787: IFFALSE 67975
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
67789: LD_ADDR_VAR 0 9
67793: PUSH
67794: LD_VAR 0 4
67798: PUSH
67799: LD_VAR 0 8
67803: PUSH
67804: LD_VAR 0 7
67808: UNION
67809: DIFF
67810: PPUSH
67811: LD_INT 3
67813: PPUSH
67814: CALL 55842 0 2
67818: ST_TO_ADDR
// p := [ ] ;
67819: LD_ADDR_VAR 0 11
67823: PUSH
67824: EMPTY
67825: ST_TO_ADDR
// if sort then
67826: LD_VAR 0 9
67830: IFFALSE 67946
// for i = 1 to 6 - mech do
67832: LD_ADDR_VAR 0 3
67836: PUSH
67837: DOUBLE
67838: LD_INT 1
67840: DEC
67841: ST_TO_ADDR
67842: LD_INT 6
67844: PUSH
67845: LD_VAR 0 7
67849: MINUS
67850: PUSH
67851: FOR_TO
67852: IFFALSE 67944
// begin if i = sort then
67854: LD_VAR 0 3
67858: PUSH
67859: LD_VAR 0 9
67863: EQUAL
67864: IFFALSE 67868
// break ;
67866: GO 67944
// if GetClass ( i ) = 3 then
67868: LD_VAR 0 3
67872: PPUSH
67873: CALL_OW 257
67877: PUSH
67878: LD_INT 3
67880: EQUAL
67881: IFFALSE 67885
// continue ;
67883: GO 67851
// p := Insert ( p , p + 1 , sort [ i ] ) ;
67885: LD_ADDR_VAR 0 11
67889: PUSH
67890: LD_VAR 0 11
67894: PPUSH
67895: LD_VAR 0 11
67899: PUSH
67900: LD_INT 1
67902: PLUS
67903: PPUSH
67904: LD_VAR 0 9
67908: PUSH
67909: LD_VAR 0 3
67913: ARRAY
67914: PPUSH
67915: CALL_OW 2
67919: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
67920: LD_ADDR_VAR 0 4
67924: PUSH
67925: LD_VAR 0 4
67929: PUSH
67930: LD_VAR 0 9
67934: PUSH
67935: LD_VAR 0 3
67939: ARRAY
67940: DIFF
67941: ST_TO_ADDR
// end ;
67942: GO 67851
67944: POP
67945: POP
// if p then
67946: LD_VAR 0 11
67950: IFFALSE 67975
// result := Replace ( result , 3 , p ) ;
67952: LD_ADDR_VAR 0 2
67956: PUSH
67957: LD_VAR 0 2
67961: PPUSH
67962: LD_INT 3
67964: PPUSH
67965: LD_VAR 0 11
67969: PPUSH
67970: CALL_OW 1
67974: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
67975: LD_VAR 0 4
67979: PUSH
67980: LD_INT 6
67982: GREATER
67983: PUSH
67984: LD_VAR 0 6
67988: PUSH
67989: LD_INT 6
67991: LESS
67992: AND
67993: IFFALSE 68187
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
67995: LD_ADDR_VAR 0 9
67999: PUSH
68000: LD_VAR 0 4
68004: PUSH
68005: LD_VAR 0 8
68009: PUSH
68010: LD_VAR 0 7
68014: UNION
68015: PUSH
68016: LD_VAR 0 6
68020: UNION
68021: DIFF
68022: PPUSH
68023: LD_INT 2
68025: PPUSH
68026: CALL 55842 0 2
68030: ST_TO_ADDR
// p := [ ] ;
68031: LD_ADDR_VAR 0 11
68035: PUSH
68036: EMPTY
68037: ST_TO_ADDR
// if sort then
68038: LD_VAR 0 9
68042: IFFALSE 68158
// for i = 1 to 6 - eng do
68044: LD_ADDR_VAR 0 3
68048: PUSH
68049: DOUBLE
68050: LD_INT 1
68052: DEC
68053: ST_TO_ADDR
68054: LD_INT 6
68056: PUSH
68057: LD_VAR 0 6
68061: MINUS
68062: PUSH
68063: FOR_TO
68064: IFFALSE 68156
// begin if i = sort then
68066: LD_VAR 0 3
68070: PUSH
68071: LD_VAR 0 9
68075: EQUAL
68076: IFFALSE 68080
// break ;
68078: GO 68156
// if GetClass ( i ) = 2 then
68080: LD_VAR 0 3
68084: PPUSH
68085: CALL_OW 257
68089: PUSH
68090: LD_INT 2
68092: EQUAL
68093: IFFALSE 68097
// continue ;
68095: GO 68063
// p := Insert ( p , p + 1 , sort [ i ] ) ;
68097: LD_ADDR_VAR 0 11
68101: PUSH
68102: LD_VAR 0 11
68106: PPUSH
68107: LD_VAR 0 11
68111: PUSH
68112: LD_INT 1
68114: PLUS
68115: PPUSH
68116: LD_VAR 0 9
68120: PUSH
68121: LD_VAR 0 3
68125: ARRAY
68126: PPUSH
68127: CALL_OW 2
68131: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
68132: LD_ADDR_VAR 0 4
68136: PUSH
68137: LD_VAR 0 4
68141: PUSH
68142: LD_VAR 0 9
68146: PUSH
68147: LD_VAR 0 3
68151: ARRAY
68152: DIFF
68153: ST_TO_ADDR
// end ;
68154: GO 68063
68156: POP
68157: POP
// if p then
68158: LD_VAR 0 11
68162: IFFALSE 68187
// result := Replace ( result , 2 , p ) ;
68164: LD_ADDR_VAR 0 2
68168: PUSH
68169: LD_VAR 0 2
68173: PPUSH
68174: LD_INT 2
68176: PPUSH
68177: LD_VAR 0 11
68181: PPUSH
68182: CALL_OW 1
68186: ST_TO_ADDR
// end ; exit ;
68187: GO 69575
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
68189: LD_EXP 58
68193: PUSH
68194: LD_EXP 57
68198: PUSH
68199: LD_VAR 0 1
68203: ARRAY
68204: ARRAY
68205: NOT
68206: PUSH
68207: LD_EXP 31
68211: PUSH
68212: LD_VAR 0 1
68216: ARRAY
68217: PPUSH
68218: LD_INT 30
68220: PUSH
68221: LD_INT 3
68223: PUSH
68224: EMPTY
68225: LIST
68226: LIST
68227: PPUSH
68228: CALL_OW 72
68232: AND
68233: PUSH
68234: LD_EXP 36
68238: PUSH
68239: LD_VAR 0 1
68243: ARRAY
68244: AND
68245: IFFALSE 68853
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
68247: LD_ADDR_EXP 73
68251: PUSH
68252: LD_EXP 73
68256: PPUSH
68257: LD_VAR 0 1
68261: PPUSH
68262: LD_INT 5
68264: PPUSH
68265: CALL_OW 1
68269: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
68270: LD_ADDR_VAR 0 2
68274: PUSH
68275: LD_INT 0
68277: PUSH
68278: LD_INT 0
68280: PUSH
68281: LD_INT 0
68283: PUSH
68284: LD_INT 0
68286: PUSH
68287: EMPTY
68288: LIST
68289: LIST
68290: LIST
68291: LIST
68292: ST_TO_ADDR
// if sci > 1 then
68293: LD_VAR 0 8
68297: PUSH
68298: LD_INT 1
68300: GREATER
68301: IFFALSE 68329
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
68303: LD_ADDR_VAR 0 4
68307: PUSH
68308: LD_VAR 0 4
68312: PUSH
68313: LD_VAR 0 8
68317: PUSH
68318: LD_VAR 0 8
68322: PUSH
68323: LD_INT 1
68325: ARRAY
68326: DIFF
68327: DIFF
68328: ST_TO_ADDR
// if tmp and not sci then
68329: LD_VAR 0 4
68333: PUSH
68334: LD_VAR 0 8
68338: NOT
68339: AND
68340: IFFALSE 68409
// begin sort := SortBySkill ( tmp , 4 ) ;
68342: LD_ADDR_VAR 0 9
68346: PUSH
68347: LD_VAR 0 4
68351: PPUSH
68352: LD_INT 4
68354: PPUSH
68355: CALL 55842 0 2
68359: ST_TO_ADDR
// if sort then
68360: LD_VAR 0 9
68364: IFFALSE 68380
// p := sort [ 1 ] ;
68366: LD_ADDR_VAR 0 11
68370: PUSH
68371: LD_VAR 0 9
68375: PUSH
68376: LD_INT 1
68378: ARRAY
68379: ST_TO_ADDR
// if p then
68380: LD_VAR 0 11
68384: IFFALSE 68409
// result := Replace ( result , 4 , p ) ;
68386: LD_ADDR_VAR 0 2
68390: PUSH
68391: LD_VAR 0 2
68395: PPUSH
68396: LD_INT 4
68398: PPUSH
68399: LD_VAR 0 11
68403: PPUSH
68404: CALL_OW 1
68408: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
68409: LD_ADDR_VAR 0 4
68413: PUSH
68414: LD_VAR 0 4
68418: PUSH
68419: LD_VAR 0 7
68423: DIFF
68424: ST_TO_ADDR
// if tmp and mech < 6 then
68425: LD_VAR 0 4
68429: PUSH
68430: LD_VAR 0 7
68434: PUSH
68435: LD_INT 6
68437: LESS
68438: AND
68439: IFFALSE 68627
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
68441: LD_ADDR_VAR 0 9
68445: PUSH
68446: LD_VAR 0 4
68450: PUSH
68451: LD_VAR 0 8
68455: PUSH
68456: LD_VAR 0 7
68460: UNION
68461: DIFF
68462: PPUSH
68463: LD_INT 3
68465: PPUSH
68466: CALL 55842 0 2
68470: ST_TO_ADDR
// p := [ ] ;
68471: LD_ADDR_VAR 0 11
68475: PUSH
68476: EMPTY
68477: ST_TO_ADDR
// if sort then
68478: LD_VAR 0 9
68482: IFFALSE 68598
// for i = 1 to 6 - mech do
68484: LD_ADDR_VAR 0 3
68488: PUSH
68489: DOUBLE
68490: LD_INT 1
68492: DEC
68493: ST_TO_ADDR
68494: LD_INT 6
68496: PUSH
68497: LD_VAR 0 7
68501: MINUS
68502: PUSH
68503: FOR_TO
68504: IFFALSE 68596
// begin if i = sort then
68506: LD_VAR 0 3
68510: PUSH
68511: LD_VAR 0 9
68515: EQUAL
68516: IFFALSE 68520
// break ;
68518: GO 68596
// if GetClass ( i ) = 3 then
68520: LD_VAR 0 3
68524: PPUSH
68525: CALL_OW 257
68529: PUSH
68530: LD_INT 3
68532: EQUAL
68533: IFFALSE 68537
// continue ;
68535: GO 68503
// p := Insert ( p , p + 1 , sort [ i ] ) ;
68537: LD_ADDR_VAR 0 11
68541: PUSH
68542: LD_VAR 0 11
68546: PPUSH
68547: LD_VAR 0 11
68551: PUSH
68552: LD_INT 1
68554: PLUS
68555: PPUSH
68556: LD_VAR 0 9
68560: PUSH
68561: LD_VAR 0 3
68565: ARRAY
68566: PPUSH
68567: CALL_OW 2
68571: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
68572: LD_ADDR_VAR 0 4
68576: PUSH
68577: LD_VAR 0 4
68581: PUSH
68582: LD_VAR 0 9
68586: PUSH
68587: LD_VAR 0 3
68591: ARRAY
68592: DIFF
68593: ST_TO_ADDR
// end ;
68594: GO 68503
68596: POP
68597: POP
// if p then
68598: LD_VAR 0 11
68602: IFFALSE 68627
// result := Replace ( result , 3 , p ) ;
68604: LD_ADDR_VAR 0 2
68608: PUSH
68609: LD_VAR 0 2
68613: PPUSH
68614: LD_INT 3
68616: PPUSH
68617: LD_VAR 0 11
68621: PPUSH
68622: CALL_OW 1
68626: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
68627: LD_ADDR_VAR 0 4
68631: PUSH
68632: LD_VAR 0 4
68636: PUSH
68637: LD_VAR 0 6
68641: DIFF
68642: ST_TO_ADDR
// if tmp and eng < 6 then
68643: LD_VAR 0 4
68647: PUSH
68648: LD_VAR 0 6
68652: PUSH
68653: LD_INT 6
68655: LESS
68656: AND
68657: IFFALSE 68851
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
68659: LD_ADDR_VAR 0 9
68663: PUSH
68664: LD_VAR 0 4
68668: PUSH
68669: LD_VAR 0 8
68673: PUSH
68674: LD_VAR 0 7
68678: UNION
68679: PUSH
68680: LD_VAR 0 6
68684: UNION
68685: DIFF
68686: PPUSH
68687: LD_INT 2
68689: PPUSH
68690: CALL 55842 0 2
68694: ST_TO_ADDR
// p := [ ] ;
68695: LD_ADDR_VAR 0 11
68699: PUSH
68700: EMPTY
68701: ST_TO_ADDR
// if sort then
68702: LD_VAR 0 9
68706: IFFALSE 68822
// for i = 1 to 6 - eng do
68708: LD_ADDR_VAR 0 3
68712: PUSH
68713: DOUBLE
68714: LD_INT 1
68716: DEC
68717: ST_TO_ADDR
68718: LD_INT 6
68720: PUSH
68721: LD_VAR 0 6
68725: MINUS
68726: PUSH
68727: FOR_TO
68728: IFFALSE 68820
// begin if i = sort then
68730: LD_VAR 0 3
68734: PUSH
68735: LD_VAR 0 9
68739: EQUAL
68740: IFFALSE 68744
// break ;
68742: GO 68820
// if GetClass ( i ) = 2 then
68744: LD_VAR 0 3
68748: PPUSH
68749: CALL_OW 257
68753: PUSH
68754: LD_INT 2
68756: EQUAL
68757: IFFALSE 68761
// continue ;
68759: GO 68727
// p := Insert ( p , p + 1 , sort [ i ] ) ;
68761: LD_ADDR_VAR 0 11
68765: PUSH
68766: LD_VAR 0 11
68770: PPUSH
68771: LD_VAR 0 11
68775: PUSH
68776: LD_INT 1
68778: PLUS
68779: PPUSH
68780: LD_VAR 0 9
68784: PUSH
68785: LD_VAR 0 3
68789: ARRAY
68790: PPUSH
68791: CALL_OW 2
68795: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
68796: LD_ADDR_VAR 0 4
68800: PUSH
68801: LD_VAR 0 4
68805: PUSH
68806: LD_VAR 0 9
68810: PUSH
68811: LD_VAR 0 3
68815: ARRAY
68816: DIFF
68817: ST_TO_ADDR
// end ;
68818: GO 68727
68820: POP
68821: POP
// if p then
68822: LD_VAR 0 11
68826: IFFALSE 68851
// result := Replace ( result , 2 , p ) ;
68828: LD_ADDR_VAR 0 2
68832: PUSH
68833: LD_VAR 0 2
68837: PPUSH
68838: LD_INT 2
68840: PPUSH
68841: LD_VAR 0 11
68845: PPUSH
68846: CALL_OW 1
68850: ST_TO_ADDR
// end ; exit ;
68851: GO 69575
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
68853: LD_EXP 58
68857: PUSH
68858: LD_EXP 57
68862: PUSH
68863: LD_VAR 0 1
68867: ARRAY
68868: ARRAY
68869: NOT
68870: PUSH
68871: LD_EXP 31
68875: PUSH
68876: LD_VAR 0 1
68880: ARRAY
68881: PPUSH
68882: LD_INT 30
68884: PUSH
68885: LD_INT 3
68887: PUSH
68888: EMPTY
68889: LIST
68890: LIST
68891: PPUSH
68892: CALL_OW 72
68896: AND
68897: PUSH
68898: LD_EXP 36
68902: PUSH
68903: LD_VAR 0 1
68907: ARRAY
68908: NOT
68909: AND
68910: IFFALSE 69575
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
68912: LD_ADDR_EXP 73
68916: PUSH
68917: LD_EXP 73
68921: PPUSH
68922: LD_VAR 0 1
68926: PPUSH
68927: LD_INT 6
68929: PPUSH
68930: CALL_OW 1
68934: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
68935: LD_ADDR_VAR 0 2
68939: PUSH
68940: LD_INT 0
68942: PUSH
68943: LD_INT 0
68945: PUSH
68946: LD_INT 0
68948: PUSH
68949: LD_INT 0
68951: PUSH
68952: EMPTY
68953: LIST
68954: LIST
68955: LIST
68956: LIST
68957: ST_TO_ADDR
// if sci >= 1 then
68958: LD_VAR 0 8
68962: PUSH
68963: LD_INT 1
68965: GREATEREQUAL
68966: IFFALSE 68988
// tmp := tmp diff sci [ 1 ] ;
68968: LD_ADDR_VAR 0 4
68972: PUSH
68973: LD_VAR 0 4
68977: PUSH
68978: LD_VAR 0 8
68982: PUSH
68983: LD_INT 1
68985: ARRAY
68986: DIFF
68987: ST_TO_ADDR
// if tmp and not sci then
68988: LD_VAR 0 4
68992: PUSH
68993: LD_VAR 0 8
68997: NOT
68998: AND
68999: IFFALSE 69068
// begin sort := SortBySkill ( tmp , 4 ) ;
69001: LD_ADDR_VAR 0 9
69005: PUSH
69006: LD_VAR 0 4
69010: PPUSH
69011: LD_INT 4
69013: PPUSH
69014: CALL 55842 0 2
69018: ST_TO_ADDR
// if sort then
69019: LD_VAR 0 9
69023: IFFALSE 69039
// p := sort [ 1 ] ;
69025: LD_ADDR_VAR 0 11
69029: PUSH
69030: LD_VAR 0 9
69034: PUSH
69035: LD_INT 1
69037: ARRAY
69038: ST_TO_ADDR
// if p then
69039: LD_VAR 0 11
69043: IFFALSE 69068
// result := Replace ( result , 4 , p ) ;
69045: LD_ADDR_VAR 0 2
69049: PUSH
69050: LD_VAR 0 2
69054: PPUSH
69055: LD_INT 4
69057: PPUSH
69058: LD_VAR 0 11
69062: PPUSH
69063: CALL_OW 1
69067: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
69068: LD_ADDR_VAR 0 4
69072: PUSH
69073: LD_VAR 0 4
69077: PUSH
69078: LD_VAR 0 7
69082: DIFF
69083: ST_TO_ADDR
// if tmp and mech < 6 then
69084: LD_VAR 0 4
69088: PUSH
69089: LD_VAR 0 7
69093: PUSH
69094: LD_INT 6
69096: LESS
69097: AND
69098: IFFALSE 69280
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
69100: LD_ADDR_VAR 0 9
69104: PUSH
69105: LD_VAR 0 4
69109: PUSH
69110: LD_VAR 0 7
69114: DIFF
69115: PPUSH
69116: LD_INT 3
69118: PPUSH
69119: CALL 55842 0 2
69123: ST_TO_ADDR
// p := [ ] ;
69124: LD_ADDR_VAR 0 11
69128: PUSH
69129: EMPTY
69130: ST_TO_ADDR
// if sort then
69131: LD_VAR 0 9
69135: IFFALSE 69251
// for i = 1 to 6 - mech do
69137: LD_ADDR_VAR 0 3
69141: PUSH
69142: DOUBLE
69143: LD_INT 1
69145: DEC
69146: ST_TO_ADDR
69147: LD_INT 6
69149: PUSH
69150: LD_VAR 0 7
69154: MINUS
69155: PUSH
69156: FOR_TO
69157: IFFALSE 69249
// begin if i = sort then
69159: LD_VAR 0 3
69163: PUSH
69164: LD_VAR 0 9
69168: EQUAL
69169: IFFALSE 69173
// break ;
69171: GO 69249
// if GetClass ( i ) = 3 then
69173: LD_VAR 0 3
69177: PPUSH
69178: CALL_OW 257
69182: PUSH
69183: LD_INT 3
69185: EQUAL
69186: IFFALSE 69190
// continue ;
69188: GO 69156
// p := Insert ( p , p + 1 , sort [ i ] ) ;
69190: LD_ADDR_VAR 0 11
69194: PUSH
69195: LD_VAR 0 11
69199: PPUSH
69200: LD_VAR 0 11
69204: PUSH
69205: LD_INT 1
69207: PLUS
69208: PPUSH
69209: LD_VAR 0 9
69213: PUSH
69214: LD_VAR 0 3
69218: ARRAY
69219: PPUSH
69220: CALL_OW 2
69224: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
69225: LD_ADDR_VAR 0 4
69229: PUSH
69230: LD_VAR 0 4
69234: PUSH
69235: LD_VAR 0 9
69239: PUSH
69240: LD_VAR 0 3
69244: ARRAY
69245: DIFF
69246: ST_TO_ADDR
// end ;
69247: GO 69156
69249: POP
69250: POP
// if p then
69251: LD_VAR 0 11
69255: IFFALSE 69280
// result := Replace ( result , 3 , p ) ;
69257: LD_ADDR_VAR 0 2
69261: PUSH
69262: LD_VAR 0 2
69266: PPUSH
69267: LD_INT 3
69269: PPUSH
69270: LD_VAR 0 11
69274: PPUSH
69275: CALL_OW 1
69279: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
69280: LD_ADDR_VAR 0 4
69284: PUSH
69285: LD_VAR 0 4
69289: PUSH
69290: LD_VAR 0 6
69294: DIFF
69295: ST_TO_ADDR
// if tmp and eng < 4 then
69296: LD_VAR 0 4
69300: PUSH
69301: LD_VAR 0 6
69305: PUSH
69306: LD_INT 4
69308: LESS
69309: AND
69310: IFFALSE 69500
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
69312: LD_ADDR_VAR 0 9
69316: PUSH
69317: LD_VAR 0 4
69321: PUSH
69322: LD_VAR 0 7
69326: PUSH
69327: LD_VAR 0 6
69331: UNION
69332: DIFF
69333: PPUSH
69334: LD_INT 2
69336: PPUSH
69337: CALL 55842 0 2
69341: ST_TO_ADDR
// p := [ ] ;
69342: LD_ADDR_VAR 0 11
69346: PUSH
69347: EMPTY
69348: ST_TO_ADDR
// if sort then
69349: LD_VAR 0 9
69353: IFFALSE 69469
// for i = 1 to 4 - eng do
69355: LD_ADDR_VAR 0 3
69359: PUSH
69360: DOUBLE
69361: LD_INT 1
69363: DEC
69364: ST_TO_ADDR
69365: LD_INT 4
69367: PUSH
69368: LD_VAR 0 6
69372: MINUS
69373: PUSH
69374: FOR_TO
69375: IFFALSE 69467
// begin if i = sort then
69377: LD_VAR 0 3
69381: PUSH
69382: LD_VAR 0 9
69386: EQUAL
69387: IFFALSE 69391
// break ;
69389: GO 69467
// if GetClass ( i ) = 2 then
69391: LD_VAR 0 3
69395: PPUSH
69396: CALL_OW 257
69400: PUSH
69401: LD_INT 2
69403: EQUAL
69404: IFFALSE 69408
// continue ;
69406: GO 69374
// p := Insert ( p , p + 1 , sort [ i ] ) ;
69408: LD_ADDR_VAR 0 11
69412: PUSH
69413: LD_VAR 0 11
69417: PPUSH
69418: LD_VAR 0 11
69422: PUSH
69423: LD_INT 1
69425: PLUS
69426: PPUSH
69427: LD_VAR 0 9
69431: PUSH
69432: LD_VAR 0 3
69436: ARRAY
69437: PPUSH
69438: CALL_OW 2
69442: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
69443: LD_ADDR_VAR 0 4
69447: PUSH
69448: LD_VAR 0 4
69452: PUSH
69453: LD_VAR 0 9
69457: PUSH
69458: LD_VAR 0 3
69462: ARRAY
69463: DIFF
69464: ST_TO_ADDR
// end ;
69465: GO 69374
69467: POP
69468: POP
// if p then
69469: LD_VAR 0 11
69473: IFFALSE 69498
// result := Replace ( result , 2 , p ) ;
69475: LD_ADDR_VAR 0 2
69479: PUSH
69480: LD_VAR 0 2
69484: PPUSH
69485: LD_INT 2
69487: PPUSH
69488: LD_VAR 0 11
69492: PPUSH
69493: CALL_OW 1
69497: ST_TO_ADDR
// end else
69498: GO 69544
// for i = eng downto 5 do
69500: LD_ADDR_VAR 0 3
69504: PUSH
69505: DOUBLE
69506: LD_VAR 0 6
69510: INC
69511: ST_TO_ADDR
69512: LD_INT 5
69514: PUSH
69515: FOR_DOWNTO
69516: IFFALSE 69542
// tmp := tmp union eng [ i ] ;
69518: LD_ADDR_VAR 0 4
69522: PUSH
69523: LD_VAR 0 4
69527: PUSH
69528: LD_VAR 0 6
69532: PUSH
69533: LD_VAR 0 3
69537: ARRAY
69538: UNION
69539: ST_TO_ADDR
69540: GO 69515
69542: POP
69543: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
69544: LD_ADDR_VAR 0 2
69548: PUSH
69549: LD_VAR 0 2
69553: PPUSH
69554: LD_INT 1
69556: PPUSH
69557: LD_VAR 0 4
69561: PUSH
69562: LD_VAR 0 5
69566: DIFF
69567: PPUSH
69568: CALL_OW 1
69572: ST_TO_ADDR
// exit ;
69573: GO 69575
// end ; end ;
69575: LD_VAR 0 2
69579: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
69580: LD_INT 0
69582: PPUSH
69583: PPUSH
69584: PPUSH
// if not mc_bases then
69585: LD_EXP 31
69589: NOT
69590: IFFALSE 69594
// exit ;
69592: GO 69736
// for i = 1 to mc_bases do
69594: LD_ADDR_VAR 0 2
69598: PUSH
69599: DOUBLE
69600: LD_INT 1
69602: DEC
69603: ST_TO_ADDR
69604: LD_EXP 31
69608: PUSH
69609: FOR_TO
69610: IFFALSE 69727
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
69612: LD_ADDR_VAR 0 3
69616: PUSH
69617: LD_EXP 31
69621: PUSH
69622: LD_VAR 0 2
69626: ARRAY
69627: PPUSH
69628: LD_INT 21
69630: PUSH
69631: LD_INT 3
69633: PUSH
69634: EMPTY
69635: LIST
69636: LIST
69637: PUSH
69638: LD_INT 3
69640: PUSH
69641: LD_INT 2
69643: PUSH
69644: LD_INT 30
69646: PUSH
69647: LD_INT 29
69649: PUSH
69650: EMPTY
69651: LIST
69652: LIST
69653: PUSH
69654: LD_INT 30
69656: PUSH
69657: LD_INT 30
69659: PUSH
69660: EMPTY
69661: LIST
69662: LIST
69663: PUSH
69664: EMPTY
69665: LIST
69666: LIST
69667: LIST
69668: PUSH
69669: EMPTY
69670: LIST
69671: LIST
69672: PUSH
69673: LD_INT 3
69675: PUSH
69676: LD_INT 24
69678: PUSH
69679: LD_INT 1000
69681: PUSH
69682: EMPTY
69683: LIST
69684: LIST
69685: PUSH
69686: EMPTY
69687: LIST
69688: LIST
69689: PUSH
69690: EMPTY
69691: LIST
69692: LIST
69693: LIST
69694: PPUSH
69695: CALL_OW 72
69699: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
69700: LD_ADDR_EXP 32
69704: PUSH
69705: LD_EXP 32
69709: PPUSH
69710: LD_VAR 0 2
69714: PPUSH
69715: LD_VAR 0 3
69719: PPUSH
69720: CALL_OW 1
69724: ST_TO_ADDR
// end ;
69725: GO 69609
69727: POP
69728: POP
// RaiseSailEvent ( 101 ) ;
69729: LD_INT 101
69731: PPUSH
69732: CALL_OW 427
// end ;
69736: LD_VAR 0 1
69740: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
69741: LD_INT 0
69743: PPUSH
69744: PPUSH
69745: PPUSH
69746: PPUSH
69747: PPUSH
69748: PPUSH
69749: PPUSH
// if not mc_bases then
69750: LD_EXP 31
69754: NOT
69755: IFFALSE 69759
// exit ;
69757: GO 70321
// for i = 1 to mc_bases do
69759: LD_ADDR_VAR 0 2
69763: PUSH
69764: DOUBLE
69765: LD_INT 1
69767: DEC
69768: ST_TO_ADDR
69769: LD_EXP 31
69773: PUSH
69774: FOR_TO
69775: IFFALSE 70312
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
69777: LD_ADDR_VAR 0 5
69781: PUSH
69782: LD_EXP 31
69786: PUSH
69787: LD_VAR 0 2
69791: ARRAY
69792: PUSH
69793: LD_EXP 60
69797: PUSH
69798: LD_VAR 0 2
69802: ARRAY
69803: UNION
69804: PPUSH
69805: LD_INT 21
69807: PUSH
69808: LD_INT 1
69810: PUSH
69811: EMPTY
69812: LIST
69813: LIST
69814: PUSH
69815: LD_INT 1
69817: PUSH
69818: LD_INT 3
69820: PUSH
69821: LD_INT 54
69823: PUSH
69824: EMPTY
69825: LIST
69826: PUSH
69827: EMPTY
69828: LIST
69829: LIST
69830: PUSH
69831: LD_INT 3
69833: PUSH
69834: LD_INT 24
69836: PUSH
69837: LD_INT 1000
69839: PUSH
69840: EMPTY
69841: LIST
69842: LIST
69843: PUSH
69844: EMPTY
69845: LIST
69846: LIST
69847: PUSH
69848: EMPTY
69849: LIST
69850: LIST
69851: LIST
69852: PUSH
69853: EMPTY
69854: LIST
69855: LIST
69856: PPUSH
69857: CALL_OW 72
69861: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
69862: LD_ADDR_VAR 0 6
69866: PUSH
69867: LD_EXP 31
69871: PUSH
69872: LD_VAR 0 2
69876: ARRAY
69877: PPUSH
69878: LD_INT 21
69880: PUSH
69881: LD_INT 1
69883: PUSH
69884: EMPTY
69885: LIST
69886: LIST
69887: PUSH
69888: LD_INT 1
69890: PUSH
69891: LD_INT 3
69893: PUSH
69894: LD_INT 54
69896: PUSH
69897: EMPTY
69898: LIST
69899: PUSH
69900: EMPTY
69901: LIST
69902: LIST
69903: PUSH
69904: LD_INT 3
69906: PUSH
69907: LD_INT 24
69909: PUSH
69910: LD_INT 250
69912: PUSH
69913: EMPTY
69914: LIST
69915: LIST
69916: PUSH
69917: EMPTY
69918: LIST
69919: LIST
69920: PUSH
69921: EMPTY
69922: LIST
69923: LIST
69924: LIST
69925: PUSH
69926: EMPTY
69927: LIST
69928: LIST
69929: PPUSH
69930: CALL_OW 72
69934: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
69935: LD_ADDR_VAR 0 7
69939: PUSH
69940: LD_VAR 0 5
69944: PUSH
69945: LD_VAR 0 6
69949: DIFF
69950: ST_TO_ADDR
// if not need_heal_1 then
69951: LD_VAR 0 6
69955: NOT
69956: IFFALSE 69989
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
69958: LD_ADDR_EXP 34
69962: PUSH
69963: LD_EXP 34
69967: PPUSH
69968: LD_VAR 0 2
69972: PUSH
69973: LD_INT 1
69975: PUSH
69976: EMPTY
69977: LIST
69978: LIST
69979: PPUSH
69980: EMPTY
69981: PPUSH
69982: CALL 25021 0 3
69986: ST_TO_ADDR
69987: GO 70059
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
69989: LD_ADDR_EXP 34
69993: PUSH
69994: LD_EXP 34
69998: PPUSH
69999: LD_VAR 0 2
70003: PUSH
70004: LD_INT 1
70006: PUSH
70007: EMPTY
70008: LIST
70009: LIST
70010: PPUSH
70011: LD_EXP 34
70015: PUSH
70016: LD_VAR 0 2
70020: ARRAY
70021: PUSH
70022: LD_INT 1
70024: ARRAY
70025: PPUSH
70026: LD_INT 3
70028: PUSH
70029: LD_INT 24
70031: PUSH
70032: LD_INT 1000
70034: PUSH
70035: EMPTY
70036: LIST
70037: LIST
70038: PUSH
70039: EMPTY
70040: LIST
70041: LIST
70042: PPUSH
70043: CALL_OW 72
70047: PUSH
70048: LD_VAR 0 6
70052: UNION
70053: PPUSH
70054: CALL 25021 0 3
70058: ST_TO_ADDR
// if not need_heal_2 then
70059: LD_VAR 0 7
70063: NOT
70064: IFFALSE 70097
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
70066: LD_ADDR_EXP 34
70070: PUSH
70071: LD_EXP 34
70075: PPUSH
70076: LD_VAR 0 2
70080: PUSH
70081: LD_INT 2
70083: PUSH
70084: EMPTY
70085: LIST
70086: LIST
70087: PPUSH
70088: EMPTY
70089: PPUSH
70090: CALL 25021 0 3
70094: ST_TO_ADDR
70095: GO 70129
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
70097: LD_ADDR_EXP 34
70101: PUSH
70102: LD_EXP 34
70106: PPUSH
70107: LD_VAR 0 2
70111: PUSH
70112: LD_INT 2
70114: PUSH
70115: EMPTY
70116: LIST
70117: LIST
70118: PPUSH
70119: LD_VAR 0 7
70123: PPUSH
70124: CALL 25021 0 3
70128: ST_TO_ADDR
// if need_heal_2 then
70129: LD_VAR 0 7
70133: IFFALSE 70294
// for j in need_heal_2 do
70135: LD_ADDR_VAR 0 3
70139: PUSH
70140: LD_VAR 0 7
70144: PUSH
70145: FOR_IN
70146: IFFALSE 70292
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
70148: LD_ADDR_VAR 0 5
70152: PUSH
70153: LD_EXP 31
70157: PUSH
70158: LD_VAR 0 2
70162: ARRAY
70163: PPUSH
70164: LD_INT 2
70166: PUSH
70167: LD_INT 30
70169: PUSH
70170: LD_INT 6
70172: PUSH
70173: EMPTY
70174: LIST
70175: LIST
70176: PUSH
70177: LD_INT 30
70179: PUSH
70180: LD_INT 7
70182: PUSH
70183: EMPTY
70184: LIST
70185: LIST
70186: PUSH
70187: LD_INT 30
70189: PUSH
70190: LD_INT 8
70192: PUSH
70193: EMPTY
70194: LIST
70195: LIST
70196: PUSH
70197: LD_INT 30
70199: PUSH
70200: LD_INT 0
70202: PUSH
70203: EMPTY
70204: LIST
70205: LIST
70206: PUSH
70207: LD_INT 30
70209: PUSH
70210: LD_INT 1
70212: PUSH
70213: EMPTY
70214: LIST
70215: LIST
70216: PUSH
70217: EMPTY
70218: LIST
70219: LIST
70220: LIST
70221: LIST
70222: LIST
70223: LIST
70224: PPUSH
70225: CALL_OW 72
70229: ST_TO_ADDR
// if tmp then
70230: LD_VAR 0 5
70234: IFFALSE 70290
// begin k := NearestUnitToUnit ( tmp , j ) ;
70236: LD_ADDR_VAR 0 4
70240: PUSH
70241: LD_VAR 0 5
70245: PPUSH
70246: LD_VAR 0 3
70250: PPUSH
70251: CALL_OW 74
70255: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
70256: LD_VAR 0 3
70260: PPUSH
70261: LD_VAR 0 4
70265: PPUSH
70266: CALL_OW 296
70270: PUSH
70271: LD_INT 5
70273: GREATER
70274: IFFALSE 70290
// ComMoveToNearbyEntrance ( j , k ) ;
70276: LD_VAR 0 3
70280: PPUSH
70281: LD_VAR 0 4
70285: PPUSH
70286: CALL 58210 0 2
// end ; end ;
70290: GO 70145
70292: POP
70293: POP
// if not need_heal_1 and not need_heal_2 then
70294: LD_VAR 0 6
70298: NOT
70299: PUSH
70300: LD_VAR 0 7
70304: NOT
70305: AND
70306: IFFALSE 70310
// continue ;
70308: GO 69774
// end ;
70310: GO 69774
70312: POP
70313: POP
// RaiseSailEvent ( 102 ) ;
70314: LD_INT 102
70316: PPUSH
70317: CALL_OW 427
// end ;
70321: LD_VAR 0 1
70325: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
70326: LD_INT 0
70328: PPUSH
70329: PPUSH
70330: PPUSH
70331: PPUSH
70332: PPUSH
70333: PPUSH
70334: PPUSH
70335: PPUSH
// if not mc_bases then
70336: LD_EXP 31
70340: NOT
70341: IFFALSE 70345
// exit ;
70343: GO 71256
// for i = 1 to mc_bases do
70345: LD_ADDR_VAR 0 2
70349: PUSH
70350: DOUBLE
70351: LD_INT 1
70353: DEC
70354: ST_TO_ADDR
70355: LD_EXP 31
70359: PUSH
70360: FOR_TO
70361: IFFALSE 71254
// begin if not mc_building_need_repair [ i ] then
70363: LD_EXP 32
70367: PUSH
70368: LD_VAR 0 2
70372: ARRAY
70373: NOT
70374: IFFALSE 70559
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
70376: LD_ADDR_VAR 0 6
70380: PUSH
70381: LD_EXP 50
70385: PUSH
70386: LD_VAR 0 2
70390: ARRAY
70391: PPUSH
70392: LD_INT 3
70394: PUSH
70395: LD_INT 24
70397: PUSH
70398: LD_INT 1000
70400: PUSH
70401: EMPTY
70402: LIST
70403: LIST
70404: PUSH
70405: EMPTY
70406: LIST
70407: LIST
70408: PUSH
70409: LD_INT 2
70411: PUSH
70412: LD_INT 34
70414: PUSH
70415: LD_INT 13
70417: PUSH
70418: EMPTY
70419: LIST
70420: LIST
70421: PUSH
70422: LD_INT 34
70424: PUSH
70425: LD_INT 52
70427: PUSH
70428: EMPTY
70429: LIST
70430: LIST
70431: PUSH
70432: LD_INT 34
70434: PUSH
70435: LD_INT 88
70437: PUSH
70438: EMPTY
70439: LIST
70440: LIST
70441: PUSH
70442: EMPTY
70443: LIST
70444: LIST
70445: LIST
70446: LIST
70447: PUSH
70448: EMPTY
70449: LIST
70450: LIST
70451: PPUSH
70452: CALL_OW 72
70456: ST_TO_ADDR
// if cranes then
70457: LD_VAR 0 6
70461: IFFALSE 70523
// for j in cranes do
70463: LD_ADDR_VAR 0 3
70467: PUSH
70468: LD_VAR 0 6
70472: PUSH
70473: FOR_IN
70474: IFFALSE 70521
// if not IsInArea ( j , mc_parking [ i ] ) then
70476: LD_VAR 0 3
70480: PPUSH
70481: LD_EXP 55
70485: PUSH
70486: LD_VAR 0 2
70490: ARRAY
70491: PPUSH
70492: CALL_OW 308
70496: NOT
70497: IFFALSE 70519
// ComMoveToArea ( j , mc_parking [ i ] ) ;
70499: LD_VAR 0 3
70503: PPUSH
70504: LD_EXP 55
70508: PUSH
70509: LD_VAR 0 2
70513: ARRAY
70514: PPUSH
70515: CALL_OW 113
70519: GO 70473
70521: POP
70522: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
70523: LD_ADDR_EXP 33
70527: PUSH
70528: LD_EXP 33
70532: PPUSH
70533: LD_VAR 0 2
70537: PPUSH
70538: EMPTY
70539: PPUSH
70540: CALL_OW 1
70544: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
70545: LD_VAR 0 2
70549: PPUSH
70550: LD_INT 101
70552: PPUSH
70553: CALL 65413 0 2
// continue ;
70557: GO 70360
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
70559: LD_ADDR_EXP 37
70563: PUSH
70564: LD_EXP 37
70568: PPUSH
70569: LD_VAR 0 2
70573: PPUSH
70574: EMPTY
70575: PPUSH
70576: CALL_OW 1
70580: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
70581: LD_VAR 0 2
70585: PPUSH
70586: LD_INT 103
70588: PPUSH
70589: CALL 65413 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
70593: LD_ADDR_VAR 0 5
70597: PUSH
70598: LD_EXP 31
70602: PUSH
70603: LD_VAR 0 2
70607: ARRAY
70608: PUSH
70609: LD_EXP 60
70613: PUSH
70614: LD_VAR 0 2
70618: ARRAY
70619: UNION
70620: PPUSH
70621: LD_INT 2
70623: PUSH
70624: LD_INT 25
70626: PUSH
70627: LD_INT 2
70629: PUSH
70630: EMPTY
70631: LIST
70632: LIST
70633: PUSH
70634: LD_INT 25
70636: PUSH
70637: LD_INT 16
70639: PUSH
70640: EMPTY
70641: LIST
70642: LIST
70643: PUSH
70644: EMPTY
70645: LIST
70646: LIST
70647: LIST
70648: PUSH
70649: EMPTY
70650: LIST
70651: PPUSH
70652: CALL_OW 72
70656: ST_TO_ADDR
// if mc_need_heal [ i ] then
70657: LD_EXP 34
70661: PUSH
70662: LD_VAR 0 2
70666: ARRAY
70667: IFFALSE 70711
// tmp := tmp diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
70669: LD_ADDR_VAR 0 5
70673: PUSH
70674: LD_VAR 0 5
70678: PUSH
70679: LD_EXP 34
70683: PUSH
70684: LD_VAR 0 2
70688: ARRAY
70689: PUSH
70690: LD_INT 1
70692: ARRAY
70693: PUSH
70694: LD_EXP 34
70698: PUSH
70699: LD_VAR 0 2
70703: ARRAY
70704: PUSH
70705: LD_INT 2
70707: ARRAY
70708: UNION
70709: DIFF
70710: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
70711: LD_ADDR_VAR 0 6
70715: PUSH
70716: LD_EXP 50
70720: PUSH
70721: LD_VAR 0 2
70725: ARRAY
70726: PPUSH
70727: LD_INT 2
70729: PUSH
70730: LD_INT 34
70732: PUSH
70733: LD_INT 13
70735: PUSH
70736: EMPTY
70737: LIST
70738: LIST
70739: PUSH
70740: LD_INT 34
70742: PUSH
70743: LD_INT 52
70745: PUSH
70746: EMPTY
70747: LIST
70748: LIST
70749: PUSH
70750: LD_INT 34
70752: PUSH
70753: LD_INT 88
70755: PUSH
70756: EMPTY
70757: LIST
70758: LIST
70759: PUSH
70760: EMPTY
70761: LIST
70762: LIST
70763: LIST
70764: LIST
70765: PPUSH
70766: CALL_OW 72
70770: ST_TO_ADDR
// if cranes then
70771: LD_VAR 0 6
70775: IFFALSE 70943
// begin for j in cranes do
70777: LD_ADDR_VAR 0 3
70781: PUSH
70782: LD_VAR 0 6
70786: PUSH
70787: FOR_IN
70788: IFFALSE 70941
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
70790: LD_VAR 0 3
70794: PPUSH
70795: CALL_OW 256
70799: PUSH
70800: LD_INT 1000
70802: EQUAL
70803: PUSH
70804: LD_VAR 0 3
70808: PPUSH
70809: CALL_OW 314
70813: NOT
70814: AND
70815: IFFALSE 70881
// begin to_repair := NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ;
70817: LD_ADDR_VAR 0 8
70821: PUSH
70822: LD_EXP 32
70826: PUSH
70827: LD_VAR 0 2
70831: ARRAY
70832: PPUSH
70833: LD_VAR 0 3
70837: PPUSH
70838: CALL_OW 74
70842: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
70843: LD_VAR 0 8
70847: PPUSH
70848: LD_INT 16
70850: PPUSH
70851: CALL 27618 0 2
70855: PUSH
70856: LD_INT 4
70858: ARRAY
70859: PUSH
70860: LD_INT 10
70862: LESS
70863: IFFALSE 70879
// ComRepairBuilding ( j , to_repair ) ;
70865: LD_VAR 0 3
70869: PPUSH
70870: LD_VAR 0 8
70874: PPUSH
70875: CALL_OW 130
// end else
70879: GO 70939
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
70881: LD_VAR 0 3
70885: PPUSH
70886: CALL_OW 256
70890: PUSH
70891: LD_INT 500
70893: LESS
70894: PUSH
70895: LD_VAR 0 3
70899: PPUSH
70900: LD_EXP 55
70904: PUSH
70905: LD_VAR 0 2
70909: ARRAY
70910: PPUSH
70911: CALL_OW 308
70915: NOT
70916: AND
70917: IFFALSE 70939
// ComMoveToArea ( j , mc_parking [ i ] ) ;
70919: LD_VAR 0 3
70923: PPUSH
70924: LD_EXP 55
70928: PUSH
70929: LD_VAR 0 2
70933: ARRAY
70934: PPUSH
70935: CALL_OW 113
// end ;
70939: GO 70787
70941: POP
70942: POP
// end ; if tmp > 3 then
70943: LD_VAR 0 5
70947: PUSH
70948: LD_INT 3
70950: GREATER
70951: IFFALSE 70971
// tmp := ShrinkArray ( tmp , 4 ) ;
70953: LD_ADDR_VAR 0 5
70957: PUSH
70958: LD_VAR 0 5
70962: PPUSH
70963: LD_INT 4
70965: PPUSH
70966: CALL 57648 0 2
70970: ST_TO_ADDR
// if not tmp then
70971: LD_VAR 0 5
70975: NOT
70976: IFFALSE 70980
// continue ;
70978: GO 70360
// for j in tmp do
70980: LD_ADDR_VAR 0 3
70984: PUSH
70985: LD_VAR 0 5
70989: PUSH
70990: FOR_IN
70991: IFFALSE 71250
// begin if IsInUnit ( j ) then
70993: LD_VAR 0 3
70997: PPUSH
70998: CALL_OW 310
71002: IFFALSE 71013
// ComExitBuilding ( j ) ;
71004: LD_VAR 0 3
71008: PPUSH
71009: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
71013: LD_VAR 0 3
71017: PUSH
71018: LD_EXP 33
71022: PUSH
71023: LD_VAR 0 2
71027: ARRAY
71028: IN
71029: NOT
71030: IFFALSE 71088
// begin SetTag ( j , 101 ) ;
71032: LD_VAR 0 3
71036: PPUSH
71037: LD_INT 101
71039: PPUSH
71040: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
71044: LD_ADDR_EXP 33
71048: PUSH
71049: LD_EXP 33
71053: PPUSH
71054: LD_VAR 0 2
71058: PUSH
71059: LD_EXP 33
71063: PUSH
71064: LD_VAR 0 2
71068: ARRAY
71069: PUSH
71070: LD_INT 1
71072: PLUS
71073: PUSH
71074: EMPTY
71075: LIST
71076: LIST
71077: PPUSH
71078: LD_VAR 0 3
71082: PPUSH
71083: CALL 25021 0 3
71087: ST_TO_ADDR
// end ; wait ( 1 ) ;
71088: LD_INT 1
71090: PPUSH
71091: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
71095: LD_ADDR_VAR 0 7
71099: PUSH
71100: LD_EXP 32
71104: PUSH
71105: LD_VAR 0 2
71109: ARRAY
71110: ST_TO_ADDR
// if mc_scan [ i ] then
71111: LD_EXP 54
71115: PUSH
71116: LD_VAR 0 2
71120: ARRAY
71121: IFFALSE 71183
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
71123: LD_ADDR_VAR 0 7
71127: PUSH
71128: LD_EXP 32
71132: PUSH
71133: LD_VAR 0 2
71137: ARRAY
71138: PPUSH
71139: LD_INT 3
71141: PUSH
71142: LD_INT 30
71144: PUSH
71145: LD_INT 32
71147: PUSH
71148: EMPTY
71149: LIST
71150: LIST
71151: PUSH
71152: LD_INT 30
71154: PUSH
71155: LD_INT 33
71157: PUSH
71158: EMPTY
71159: LIST
71160: LIST
71161: PUSH
71162: LD_INT 30
71164: PUSH
71165: LD_INT 31
71167: PUSH
71168: EMPTY
71169: LIST
71170: LIST
71171: PUSH
71172: EMPTY
71173: LIST
71174: LIST
71175: LIST
71176: LIST
71177: PPUSH
71178: CALL_OW 72
71182: ST_TO_ADDR
// if not to_repair_tmp then
71183: LD_VAR 0 7
71187: NOT
71188: IFFALSE 71192
// continue ;
71190: GO 70990
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
71192: LD_ADDR_VAR 0 8
71196: PUSH
71197: LD_VAR 0 7
71201: PPUSH
71202: LD_VAR 0 3
71206: PPUSH
71207: CALL_OW 74
71211: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 14 then
71212: LD_VAR 0 8
71216: PPUSH
71217: LD_INT 16
71219: PPUSH
71220: CALL 27618 0 2
71224: PUSH
71225: LD_INT 4
71227: ARRAY
71228: PUSH
71229: LD_INT 14
71231: LESS
71232: IFFALSE 71248
// ComRepairBuilding ( j , to_repair ) ;
71234: LD_VAR 0 3
71238: PPUSH
71239: LD_VAR 0 8
71243: PPUSH
71244: CALL_OW 130
// end ;
71248: GO 70990
71250: POP
71251: POP
// end ;
71252: GO 70360
71254: POP
71255: POP
// end ;
71256: LD_VAR 0 1
71260: RET
// export function MC_Heal ; var i , j , tmp ; begin
71261: LD_INT 0
71263: PPUSH
71264: PPUSH
71265: PPUSH
71266: PPUSH
// if not mc_bases then
71267: LD_EXP 31
71271: NOT
71272: IFFALSE 71276
// exit ;
71274: GO 71678
// for i = 1 to mc_bases do
71276: LD_ADDR_VAR 0 2
71280: PUSH
71281: DOUBLE
71282: LD_INT 1
71284: DEC
71285: ST_TO_ADDR
71286: LD_EXP 31
71290: PUSH
71291: FOR_TO
71292: IFFALSE 71676
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
71294: LD_EXP 34
71298: PUSH
71299: LD_VAR 0 2
71303: ARRAY
71304: PUSH
71305: LD_INT 1
71307: ARRAY
71308: NOT
71309: PUSH
71310: LD_EXP 34
71314: PUSH
71315: LD_VAR 0 2
71319: ARRAY
71320: PUSH
71321: LD_INT 2
71323: ARRAY
71324: NOT
71325: AND
71326: IFFALSE 71364
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
71328: LD_ADDR_EXP 35
71332: PUSH
71333: LD_EXP 35
71337: PPUSH
71338: LD_VAR 0 2
71342: PPUSH
71343: EMPTY
71344: PPUSH
71345: CALL_OW 1
71349: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
71350: LD_VAR 0 2
71354: PPUSH
71355: LD_INT 102
71357: PPUSH
71358: CALL 65413 0 2
// continue ;
71362: GO 71291
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
71364: LD_ADDR_VAR 0 4
71368: PUSH
71369: LD_EXP 31
71373: PUSH
71374: LD_VAR 0 2
71378: ARRAY
71379: PPUSH
71380: LD_INT 25
71382: PUSH
71383: LD_INT 4
71385: PUSH
71386: EMPTY
71387: LIST
71388: LIST
71389: PPUSH
71390: CALL_OW 72
71394: ST_TO_ADDR
// if not tmp then
71395: LD_VAR 0 4
71399: NOT
71400: IFFALSE 71404
// continue ;
71402: GO 71291
// if mc_taming [ i ] then
71404: LD_EXP 62
71408: PUSH
71409: LD_VAR 0 2
71413: ARRAY
71414: IFFALSE 71438
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
71416: LD_ADDR_EXP 62
71420: PUSH
71421: LD_EXP 62
71425: PPUSH
71426: LD_VAR 0 2
71430: PPUSH
71431: EMPTY
71432: PPUSH
71433: CALL_OW 1
71437: ST_TO_ADDR
// for j in tmp do
71438: LD_ADDR_VAR 0 3
71442: PUSH
71443: LD_VAR 0 4
71447: PUSH
71448: FOR_IN
71449: IFFALSE 71672
// begin if IsInUnit ( j ) then
71451: LD_VAR 0 3
71455: PPUSH
71456: CALL_OW 310
71460: IFFALSE 71471
// ComExitBuilding ( j ) ;
71462: LD_VAR 0 3
71466: PPUSH
71467: CALL_OW 122
// if not j in mc_healers [ i ] then
71471: LD_VAR 0 3
71475: PUSH
71476: LD_EXP 35
71480: PUSH
71481: LD_VAR 0 2
71485: ARRAY
71486: IN
71487: NOT
71488: IFFALSE 71534
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
71490: LD_ADDR_EXP 35
71494: PUSH
71495: LD_EXP 35
71499: PPUSH
71500: LD_VAR 0 2
71504: PUSH
71505: LD_EXP 35
71509: PUSH
71510: LD_VAR 0 2
71514: ARRAY
71515: PUSH
71516: LD_INT 1
71518: PLUS
71519: PUSH
71520: EMPTY
71521: LIST
71522: LIST
71523: PPUSH
71524: LD_VAR 0 3
71528: PPUSH
71529: CALL 25021 0 3
71533: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
71534: LD_VAR 0 3
71538: PPUSH
71539: CALL_OW 110
71543: PUSH
71544: LD_INT 102
71546: NONEQUAL
71547: IFFALSE 71561
// SetTag ( j , 102 ) ;
71549: LD_VAR 0 3
71553: PPUSH
71554: LD_INT 102
71556: PPUSH
71557: CALL_OW 109
// Wait ( 3 ) ;
71561: LD_INT 3
71563: PPUSH
71564: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
71568: LD_EXP 34
71572: PUSH
71573: LD_VAR 0 2
71577: ARRAY
71578: PUSH
71579: LD_INT 1
71581: ARRAY
71582: IFFALSE 71614
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
71584: LD_VAR 0 3
71588: PPUSH
71589: LD_EXP 34
71593: PUSH
71594: LD_VAR 0 2
71598: ARRAY
71599: PUSH
71600: LD_INT 1
71602: ARRAY
71603: PUSH
71604: LD_INT 1
71606: ARRAY
71607: PPUSH
71608: CALL_OW 128
71612: GO 71670
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
71614: LD_VAR 0 3
71618: PPUSH
71619: CALL_OW 314
71623: NOT
71624: PUSH
71625: LD_EXP 34
71629: PUSH
71630: LD_VAR 0 2
71634: ARRAY
71635: PUSH
71636: LD_INT 2
71638: ARRAY
71639: AND
71640: IFFALSE 71670
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
71642: LD_VAR 0 3
71646: PPUSH
71647: LD_EXP 34
71651: PUSH
71652: LD_VAR 0 2
71656: ARRAY
71657: PUSH
71658: LD_INT 2
71660: ARRAY
71661: PUSH
71662: LD_INT 1
71664: ARRAY
71665: PPUSH
71666: CALL_OW 128
// end ;
71670: GO 71448
71672: POP
71673: POP
// end ;
71674: GO 71291
71676: POP
71677: POP
// end ;
71678: LD_VAR 0 1
71682: RET
// export function MC_Build ( ) ; var i , j , k , tmp , depot ; begin
71683: LD_INT 0
71685: PPUSH
71686: PPUSH
71687: PPUSH
71688: PPUSH
71689: PPUSH
71690: PPUSH
// if not mc_bases then
71691: LD_EXP 31
71695: NOT
71696: IFFALSE 71700
// exit ;
71698: GO 72863
// for i = 1 to mc_bases do
71700: LD_ADDR_VAR 0 2
71704: PUSH
71705: DOUBLE
71706: LD_INT 1
71708: DEC
71709: ST_TO_ADDR
71710: LD_EXP 31
71714: PUSH
71715: FOR_TO
71716: IFFALSE 72861
// begin if mc_scan [ i ] then
71718: LD_EXP 54
71722: PUSH
71723: LD_VAR 0 2
71727: ARRAY
71728: IFFALSE 71732
// continue ;
71730: GO 71715
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
71732: LD_EXP 36
71736: PUSH
71737: LD_VAR 0 2
71741: ARRAY
71742: NOT
71743: PUSH
71744: LD_EXP 38
71748: PUSH
71749: LD_VAR 0 2
71753: ARRAY
71754: NOT
71755: AND
71756: PUSH
71757: LD_EXP 37
71761: PUSH
71762: LD_VAR 0 2
71766: ARRAY
71767: AND
71768: IFFALSE 71806
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
71770: LD_ADDR_EXP 37
71774: PUSH
71775: LD_EXP 37
71779: PPUSH
71780: LD_VAR 0 2
71784: PPUSH
71785: EMPTY
71786: PPUSH
71787: CALL_OW 1
71791: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
71792: LD_VAR 0 2
71796: PPUSH
71797: LD_INT 103
71799: PPUSH
71800: CALL 65413 0 2
// continue ;
71804: GO 71715
// end ; if mc_construct_list [ i ] then
71806: LD_EXP 38
71810: PUSH
71811: LD_VAR 0 2
71815: ARRAY
71816: IFFALSE 72036
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
71818: LD_ADDR_VAR 0 5
71822: PUSH
71823: LD_EXP 31
71827: PUSH
71828: LD_VAR 0 2
71832: ARRAY
71833: PPUSH
71834: LD_INT 25
71836: PUSH
71837: LD_INT 2
71839: PUSH
71840: EMPTY
71841: LIST
71842: LIST
71843: PPUSH
71844: CALL_OW 72
71848: PUSH
71849: LD_EXP 33
71853: PUSH
71854: LD_VAR 0 2
71858: ARRAY
71859: DIFF
71860: ST_TO_ADDR
// if not tmp then
71861: LD_VAR 0 5
71865: NOT
71866: IFFALSE 71870
// continue ;
71868: GO 71715
// for j in tmp do
71870: LD_ADDR_VAR 0 3
71874: PUSH
71875: LD_VAR 0 5
71879: PUSH
71880: FOR_IN
71881: IFFALSE 72032
// begin if not mc_builders [ i ] then
71883: LD_EXP 37
71887: PUSH
71888: LD_VAR 0 2
71892: ARRAY
71893: NOT
71894: IFFALSE 71952
// begin SetTag ( j , 103 ) ;
71896: LD_VAR 0 3
71900: PPUSH
71901: LD_INT 103
71903: PPUSH
71904: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
71908: LD_ADDR_EXP 37
71912: PUSH
71913: LD_EXP 37
71917: PPUSH
71918: LD_VAR 0 2
71922: PUSH
71923: LD_EXP 37
71927: PUSH
71928: LD_VAR 0 2
71932: ARRAY
71933: PUSH
71934: LD_INT 1
71936: PLUS
71937: PUSH
71938: EMPTY
71939: LIST
71940: LIST
71941: PPUSH
71942: LD_VAR 0 3
71946: PPUSH
71947: CALL 25021 0 3
71951: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
71952: LD_VAR 0 3
71956: PPUSH
71957: CALL_OW 310
71961: IFFALSE 71972
// ComExitBuilding ( j ) ;
71963: LD_VAR 0 3
71967: PPUSH
71968: CALL_OW 122
// wait ( 3 ) ;
71972: LD_INT 3
71974: PPUSH
71975: CALL_OW 67
// if not mc_construct_list [ i ] then
71979: LD_EXP 38
71983: PUSH
71984: LD_VAR 0 2
71988: ARRAY
71989: NOT
71990: IFFALSE 71994
// break ;
71992: GO 72032
// if not HasTask ( j ) then
71994: LD_VAR 0 3
71998: PPUSH
71999: CALL_OW 314
72003: NOT
72004: IFFALSE 72030
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
72006: LD_VAR 0 3
72010: PPUSH
72011: LD_EXP 38
72015: PUSH
72016: LD_VAR 0 2
72020: ARRAY
72021: PUSH
72022: LD_INT 1
72024: ARRAY
72025: PPUSH
72026: CALL 27882 0 2
// end ;
72030: GO 71880
72032: POP
72033: POP
// end else
72034: GO 72859
// if mc_build_list [ i ] then
72036: LD_EXP 36
72040: PUSH
72041: LD_VAR 0 2
72045: ARRAY
72046: IFFALSE 72859
// begin if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
72048: LD_EXP 36
72052: PUSH
72053: LD_VAR 0 2
72057: ARRAY
72058: PUSH
72059: LD_INT 1
72061: ARRAY
72062: PUSH
72063: LD_INT 1
72065: ARRAY
72066: PPUSH
72067: CALL 27706 0 1
72071: PUSH
72072: LD_EXP 31
72076: PUSH
72077: LD_VAR 0 2
72081: ARRAY
72082: PPUSH
72083: LD_INT 2
72085: PUSH
72086: LD_INT 30
72088: PUSH
72089: LD_INT 2
72091: PUSH
72092: EMPTY
72093: LIST
72094: LIST
72095: PUSH
72096: LD_INT 30
72098: PUSH
72099: LD_INT 3
72101: PUSH
72102: EMPTY
72103: LIST
72104: LIST
72105: PUSH
72106: EMPTY
72107: LIST
72108: LIST
72109: LIST
72110: PPUSH
72111: CALL_OW 72
72115: NOT
72116: AND
72117: IFFALSE 72222
// begin for j = 1 to mc_build_list [ i ] do
72119: LD_ADDR_VAR 0 3
72123: PUSH
72124: DOUBLE
72125: LD_INT 1
72127: DEC
72128: ST_TO_ADDR
72129: LD_EXP 36
72133: PUSH
72134: LD_VAR 0 2
72138: ARRAY
72139: PUSH
72140: FOR_TO
72141: IFFALSE 72220
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
72143: LD_EXP 36
72147: PUSH
72148: LD_VAR 0 2
72152: ARRAY
72153: PUSH
72154: LD_VAR 0 3
72158: ARRAY
72159: PUSH
72160: LD_INT 1
72162: ARRAY
72163: PUSH
72164: LD_INT 2
72166: EQUAL
72167: IFFALSE 72218
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
72169: LD_ADDR_EXP 36
72173: PUSH
72174: LD_EXP 36
72178: PPUSH
72179: LD_VAR 0 2
72183: PPUSH
72184: LD_EXP 36
72188: PUSH
72189: LD_VAR 0 2
72193: ARRAY
72194: PPUSH
72195: LD_VAR 0 3
72199: PPUSH
72200: LD_INT 1
72202: PPUSH
72203: LD_INT 0
72205: PPUSH
72206: CALL 24439 0 4
72210: PPUSH
72211: CALL_OW 1
72215: ST_TO_ADDR
// break ;
72216: GO 72220
// end ;
72218: GO 72140
72220: POP
72221: POP
// end ; depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
72222: LD_ADDR_VAR 0 6
72226: PUSH
72227: LD_EXP 31
72231: PUSH
72232: LD_VAR 0 2
72236: ARRAY
72237: PPUSH
72238: LD_INT 2
72240: PUSH
72241: LD_INT 30
72243: PUSH
72244: LD_INT 0
72246: PUSH
72247: EMPTY
72248: LIST
72249: LIST
72250: PUSH
72251: LD_INT 30
72253: PUSH
72254: LD_INT 1
72256: PUSH
72257: EMPTY
72258: LIST
72259: LIST
72260: PUSH
72261: EMPTY
72262: LIST
72263: LIST
72264: LIST
72265: PPUSH
72266: CALL_OW 72
72270: ST_TO_ADDR
// for k := 1 to depot do
72271: LD_ADDR_VAR 0 4
72275: PUSH
72276: DOUBLE
72277: LD_INT 1
72279: DEC
72280: ST_TO_ADDR
72281: LD_VAR 0 6
72285: PUSH
72286: FOR_TO
72287: IFFALSE 72857
// begin if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or CanBeBuilt ( depot [ k ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
72289: LD_EXP 36
72293: PUSH
72294: LD_VAR 0 2
72298: ARRAY
72299: PUSH
72300: LD_INT 1
72302: ARRAY
72303: PUSH
72304: LD_INT 1
72306: ARRAY
72307: PUSH
72308: LD_INT 0
72310: EQUAL
72311: PUSH
72312: LD_VAR 0 6
72316: PUSH
72317: LD_VAR 0 4
72321: ARRAY
72322: PPUSH
72323: LD_EXP 36
72327: PUSH
72328: LD_VAR 0 2
72332: ARRAY
72333: PUSH
72334: LD_INT 1
72336: ARRAY
72337: PUSH
72338: LD_INT 1
72340: ARRAY
72341: PPUSH
72342: LD_EXP 36
72346: PUSH
72347: LD_VAR 0 2
72351: ARRAY
72352: PUSH
72353: LD_INT 1
72355: ARRAY
72356: PUSH
72357: LD_INT 2
72359: ARRAY
72360: PPUSH
72361: LD_EXP 36
72365: PUSH
72366: LD_VAR 0 2
72370: ARRAY
72371: PUSH
72372: LD_INT 1
72374: ARRAY
72375: PUSH
72376: LD_INT 3
72378: ARRAY
72379: PPUSH
72380: LD_EXP 36
72384: PUSH
72385: LD_VAR 0 2
72389: ARRAY
72390: PUSH
72391: LD_INT 1
72393: ARRAY
72394: PUSH
72395: LD_INT 4
72397: ARRAY
72398: PPUSH
72399: CALL 33118 0 5
72403: OR
72404: IFFALSE 72685
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
72406: LD_ADDR_VAR 0 5
72410: PUSH
72411: LD_EXP 31
72415: PUSH
72416: LD_VAR 0 2
72420: ARRAY
72421: PPUSH
72422: LD_INT 25
72424: PUSH
72425: LD_INT 2
72427: PUSH
72428: EMPTY
72429: LIST
72430: LIST
72431: PPUSH
72432: CALL_OW 72
72436: PUSH
72437: LD_EXP 33
72441: PUSH
72442: LD_VAR 0 2
72446: ARRAY
72447: DIFF
72448: ST_TO_ADDR
// if not tmp then
72449: LD_VAR 0 5
72453: NOT
72454: IFFALSE 72458
// continue ;
72456: GO 72286
// for j in tmp do
72458: LD_ADDR_VAR 0 3
72462: PUSH
72463: LD_VAR 0 5
72467: PUSH
72468: FOR_IN
72469: IFFALSE 72681
// begin if not mc_builders [ i ] then
72471: LD_EXP 37
72475: PUSH
72476: LD_VAR 0 2
72480: ARRAY
72481: NOT
72482: IFFALSE 72540
// begin SetTag ( j , 103 ) ;
72484: LD_VAR 0 3
72488: PPUSH
72489: LD_INT 103
72491: PPUSH
72492: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
72496: LD_ADDR_EXP 37
72500: PUSH
72501: LD_EXP 37
72505: PPUSH
72506: LD_VAR 0 2
72510: PUSH
72511: LD_EXP 37
72515: PUSH
72516: LD_VAR 0 2
72520: ARRAY
72521: PUSH
72522: LD_INT 1
72524: PLUS
72525: PUSH
72526: EMPTY
72527: LIST
72528: LIST
72529: PPUSH
72530: LD_VAR 0 3
72534: PPUSH
72535: CALL 25021 0 3
72539: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
72540: LD_VAR 0 3
72544: PPUSH
72545: CALL_OW 310
72549: IFFALSE 72560
// ComExitBuilding ( j ) ;
72551: LD_VAR 0 3
72555: PPUSH
72556: CALL_OW 122
// wait ( 3 ) ;
72560: LD_INT 3
72562: PPUSH
72563: CALL_OW 67
// if not mc_build_list [ i ] then
72567: LD_EXP 36
72571: PUSH
72572: LD_VAR 0 2
72576: ARRAY
72577: NOT
72578: IFFALSE 72582
// break ;
72580: GO 72681
// if not HasTask ( j ) then
72582: LD_VAR 0 3
72586: PPUSH
72587: CALL_OW 314
72591: NOT
72592: IFFALSE 72679
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
72594: LD_VAR 0 3
72598: PPUSH
72599: LD_EXP 36
72603: PUSH
72604: LD_VAR 0 2
72608: ARRAY
72609: PUSH
72610: LD_INT 1
72612: ARRAY
72613: PUSH
72614: LD_INT 1
72616: ARRAY
72617: PPUSH
72618: LD_EXP 36
72622: PUSH
72623: LD_VAR 0 2
72627: ARRAY
72628: PUSH
72629: LD_INT 1
72631: ARRAY
72632: PUSH
72633: LD_INT 2
72635: ARRAY
72636: PPUSH
72637: LD_EXP 36
72641: PUSH
72642: LD_VAR 0 2
72646: ARRAY
72647: PUSH
72648: LD_INT 1
72650: ARRAY
72651: PUSH
72652: LD_INT 3
72654: ARRAY
72655: PPUSH
72656: LD_EXP 36
72660: PUSH
72661: LD_VAR 0 2
72665: ARRAY
72666: PUSH
72667: LD_INT 1
72669: ARRAY
72670: PUSH
72671: LD_INT 4
72673: ARRAY
72674: PPUSH
72675: CALL_OW 145
// end ;
72679: GO 72468
72681: POP
72682: POP
// end else
72683: GO 72855
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
72685: LD_EXP 31
72689: PUSH
72690: LD_VAR 0 2
72694: ARRAY
72695: PPUSH
72696: LD_EXP 36
72700: PUSH
72701: LD_VAR 0 2
72705: ARRAY
72706: PUSH
72707: LD_INT 1
72709: ARRAY
72710: PUSH
72711: LD_INT 1
72713: ARRAY
72714: PPUSH
72715: LD_EXP 36
72719: PUSH
72720: LD_VAR 0 2
72724: ARRAY
72725: PUSH
72726: LD_INT 1
72728: ARRAY
72729: PUSH
72730: LD_INT 2
72732: ARRAY
72733: PPUSH
72734: LD_EXP 36
72738: PUSH
72739: LD_VAR 0 2
72743: ARRAY
72744: PUSH
72745: LD_INT 1
72747: ARRAY
72748: PUSH
72749: LD_INT 3
72751: ARRAY
72752: PPUSH
72753: LD_EXP 36
72757: PUSH
72758: LD_VAR 0 2
72762: ARRAY
72763: PUSH
72764: LD_INT 1
72766: ARRAY
72767: PUSH
72768: LD_INT 4
72770: ARRAY
72771: PPUSH
72772: LD_EXP 31
72776: PUSH
72777: LD_VAR 0 2
72781: ARRAY
72782: PPUSH
72783: LD_INT 21
72785: PUSH
72786: LD_INT 3
72788: PUSH
72789: EMPTY
72790: LIST
72791: LIST
72792: PPUSH
72793: CALL_OW 72
72797: PPUSH
72798: EMPTY
72799: PPUSH
72800: CALL 31872 0 7
72804: NOT
72805: IFFALSE 72855
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
72807: LD_ADDR_EXP 36
72811: PUSH
72812: LD_EXP 36
72816: PPUSH
72817: LD_VAR 0 2
72821: PPUSH
72822: LD_EXP 36
72826: PUSH
72827: LD_VAR 0 2
72831: ARRAY
72832: PPUSH
72833: LD_INT 1
72835: PPUSH
72836: LD_INT 1
72838: NEG
72839: PPUSH
72840: LD_INT 0
72842: PPUSH
72843: CALL 24439 0 4
72847: PPUSH
72848: CALL_OW 1
72852: ST_TO_ADDR
// continue ;
72853: GO 72286
// end ; end ;
72855: GO 72286
72857: POP
72858: POP
// end ; end ;
72859: GO 71715
72861: POP
72862: POP
// end ;
72863: LD_VAR 0 1
72867: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
72868: LD_INT 0
72870: PPUSH
72871: PPUSH
72872: PPUSH
72873: PPUSH
72874: PPUSH
72875: PPUSH
// if not mc_bases then
72876: LD_EXP 31
72880: NOT
72881: IFFALSE 72885
// exit ;
72883: GO 73312
// for i = 1 to mc_bases do
72885: LD_ADDR_VAR 0 2
72889: PUSH
72890: DOUBLE
72891: LD_INT 1
72893: DEC
72894: ST_TO_ADDR
72895: LD_EXP 31
72899: PUSH
72900: FOR_TO
72901: IFFALSE 73310
// begin tmp := mc_build_upgrade [ i ] ;
72903: LD_ADDR_VAR 0 4
72907: PUSH
72908: LD_EXP 63
72912: PUSH
72913: LD_VAR 0 2
72917: ARRAY
72918: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
72919: LD_ADDR_VAR 0 6
72923: PUSH
72924: LD_EXP 64
72928: PUSH
72929: LD_VAR 0 2
72933: ARRAY
72934: PPUSH
72935: LD_INT 2
72937: PUSH
72938: LD_INT 30
72940: PUSH
72941: LD_INT 6
72943: PUSH
72944: EMPTY
72945: LIST
72946: LIST
72947: PUSH
72948: LD_INT 30
72950: PUSH
72951: LD_INT 7
72953: PUSH
72954: EMPTY
72955: LIST
72956: LIST
72957: PUSH
72958: EMPTY
72959: LIST
72960: LIST
72961: LIST
72962: PPUSH
72963: CALL_OW 72
72967: ST_TO_ADDR
// if not tmp and not lab then
72968: LD_VAR 0 4
72972: NOT
72973: PUSH
72974: LD_VAR 0 6
72978: NOT
72979: AND
72980: IFFALSE 72984
// continue ;
72982: GO 72900
// if tmp then
72984: LD_VAR 0 4
72988: IFFALSE 73108
// for j in tmp do
72990: LD_ADDR_VAR 0 3
72994: PUSH
72995: LD_VAR 0 4
72999: PUSH
73000: FOR_IN
73001: IFFALSE 73106
// begin if UpgradeCost ( j ) then
73003: LD_VAR 0 3
73007: PPUSH
73008: CALL 31532 0 1
73012: IFFALSE 73104
// begin ComUpgrade ( j ) ;
73014: LD_VAR 0 3
73018: PPUSH
73019: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
73023: LD_ADDR_EXP 63
73027: PUSH
73028: LD_EXP 63
73032: PPUSH
73033: LD_VAR 0 2
73037: PPUSH
73038: LD_EXP 63
73042: PUSH
73043: LD_VAR 0 2
73047: ARRAY
73048: PUSH
73049: LD_VAR 0 3
73053: DIFF
73054: PPUSH
73055: CALL_OW 1
73059: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
73060: LD_ADDR_EXP 38
73064: PUSH
73065: LD_EXP 38
73069: PPUSH
73070: LD_VAR 0 2
73074: PUSH
73075: LD_EXP 38
73079: PUSH
73080: LD_VAR 0 2
73084: ARRAY
73085: PUSH
73086: LD_INT 1
73088: PLUS
73089: PUSH
73090: EMPTY
73091: LIST
73092: LIST
73093: PPUSH
73094: LD_VAR 0 3
73098: PPUSH
73099: CALL 25021 0 3
73103: ST_TO_ADDR
// end ; end ;
73104: GO 73000
73106: POP
73107: POP
// if not lab or not mc_lab_upgrade [ i ] then
73108: LD_VAR 0 6
73112: NOT
73113: PUSH
73114: LD_EXP 65
73118: PUSH
73119: LD_VAR 0 2
73123: ARRAY
73124: NOT
73125: OR
73126: IFFALSE 73130
// continue ;
73128: GO 72900
// for j in lab do
73130: LD_ADDR_VAR 0 3
73134: PUSH
73135: LD_VAR 0 6
73139: PUSH
73140: FOR_IN
73141: IFFALSE 73306
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
73143: LD_VAR 0 3
73147: PPUSH
73148: CALL_OW 266
73152: PUSH
73153: LD_INT 6
73155: PUSH
73156: LD_INT 7
73158: PUSH
73159: EMPTY
73160: LIST
73161: LIST
73162: IN
73163: PUSH
73164: LD_VAR 0 3
73168: PPUSH
73169: CALL_OW 461
73173: PUSH
73174: LD_INT 1
73176: NONEQUAL
73177: AND
73178: IFFALSE 73304
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
73180: LD_VAR 0 3
73184: PPUSH
73185: LD_EXP 65
73189: PUSH
73190: LD_VAR 0 2
73194: ARRAY
73195: PUSH
73196: LD_INT 1
73198: ARRAY
73199: PPUSH
73200: CALL 31737 0 2
73204: IFFALSE 73304
// begin ComCancel ( j ) ;
73206: LD_VAR 0 3
73210: PPUSH
73211: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
73215: LD_VAR 0 3
73219: PPUSH
73220: LD_EXP 65
73224: PUSH
73225: LD_VAR 0 2
73229: ARRAY
73230: PUSH
73231: LD_INT 1
73233: ARRAY
73234: PPUSH
73235: CALL_OW 207
// if not j in mc_construct_list [ i ] then
73239: LD_VAR 0 3
73243: PUSH
73244: LD_EXP 38
73248: PUSH
73249: LD_VAR 0 2
73253: ARRAY
73254: IN
73255: NOT
73256: IFFALSE 73302
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
73258: LD_ADDR_EXP 38
73262: PUSH
73263: LD_EXP 38
73267: PPUSH
73268: LD_VAR 0 2
73272: PUSH
73273: LD_EXP 38
73277: PUSH
73278: LD_VAR 0 2
73282: ARRAY
73283: PUSH
73284: LD_INT 1
73286: PLUS
73287: PUSH
73288: EMPTY
73289: LIST
73290: LIST
73291: PPUSH
73292: LD_VAR 0 3
73296: PPUSH
73297: CALL 25021 0 3
73301: ST_TO_ADDR
// break ;
73302: GO 73306
// end ; end ; end ;
73304: GO 73140
73306: POP
73307: POP
// end ;
73308: GO 72900
73310: POP
73311: POP
// end ;
73312: LD_VAR 0 1
73316: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
73317: LD_INT 0
73319: PPUSH
73320: PPUSH
73321: PPUSH
73322: PPUSH
73323: PPUSH
73324: PPUSH
73325: PPUSH
73326: PPUSH
73327: PPUSH
// if not mc_bases then
73328: LD_EXP 31
73332: NOT
73333: IFFALSE 73337
// exit ;
73335: GO 73742
// for i = 1 to mc_bases do
73337: LD_ADDR_VAR 0 2
73341: PUSH
73342: DOUBLE
73343: LD_INT 1
73345: DEC
73346: ST_TO_ADDR
73347: LD_EXP 31
73351: PUSH
73352: FOR_TO
73353: IFFALSE 73740
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
73355: LD_EXP 39
73359: PUSH
73360: LD_VAR 0 2
73364: ARRAY
73365: NOT
73366: PUSH
73367: LD_EXP 31
73371: PUSH
73372: LD_VAR 0 2
73376: ARRAY
73377: PPUSH
73378: LD_INT 30
73380: PUSH
73381: LD_INT 3
73383: PUSH
73384: EMPTY
73385: LIST
73386: LIST
73387: PPUSH
73388: CALL_OW 72
73392: NOT
73393: OR
73394: IFFALSE 73398
// continue ;
73396: GO 73352
// busy := false ;
73398: LD_ADDR_VAR 0 8
73402: PUSH
73403: LD_INT 0
73405: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
73406: LD_ADDR_VAR 0 4
73410: PUSH
73411: LD_EXP 31
73415: PUSH
73416: LD_VAR 0 2
73420: ARRAY
73421: PPUSH
73422: LD_INT 30
73424: PUSH
73425: LD_INT 3
73427: PUSH
73428: EMPTY
73429: LIST
73430: LIST
73431: PPUSH
73432: CALL_OW 72
73436: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
73437: LD_ADDR_VAR 0 6
73441: PUSH
73442: LD_EXP 39
73446: PUSH
73447: LD_VAR 0 2
73451: ARRAY
73452: PPUSH
73453: LD_INT 2
73455: PUSH
73456: LD_INT 30
73458: PUSH
73459: LD_INT 32
73461: PUSH
73462: EMPTY
73463: LIST
73464: LIST
73465: PUSH
73466: LD_INT 30
73468: PUSH
73469: LD_INT 33
73471: PUSH
73472: EMPTY
73473: LIST
73474: LIST
73475: PUSH
73476: EMPTY
73477: LIST
73478: LIST
73479: LIST
73480: PPUSH
73481: CALL_OW 72
73485: ST_TO_ADDR
// if not t then
73486: LD_VAR 0 6
73490: NOT
73491: IFFALSE 73495
// continue ;
73493: GO 73352
// for j in tmp do
73495: LD_ADDR_VAR 0 3
73499: PUSH
73500: LD_VAR 0 4
73504: PUSH
73505: FOR_IN
73506: IFFALSE 73536
// if not BuildingStatus ( j ) = bs_idle then
73508: LD_VAR 0 3
73512: PPUSH
73513: CALL_OW 461
73517: PUSH
73518: LD_INT 2
73520: EQUAL
73521: NOT
73522: IFFALSE 73534
// begin busy := true ;
73524: LD_ADDR_VAR 0 8
73528: PUSH
73529: LD_INT 1
73531: ST_TO_ADDR
// break ;
73532: GO 73536
// end ;
73534: GO 73505
73536: POP
73537: POP
// if busy then
73538: LD_VAR 0 8
73542: IFFALSE 73546
// continue ;
73544: GO 73352
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
73546: LD_ADDR_VAR 0 7
73550: PUSH
73551: LD_VAR 0 6
73555: PPUSH
73556: LD_INT 35
73558: PUSH
73559: LD_INT 0
73561: PUSH
73562: EMPTY
73563: LIST
73564: LIST
73565: PPUSH
73566: CALL_OW 72
73570: ST_TO_ADDR
// if tw then
73571: LD_VAR 0 7
73575: IFFALSE 73652
// begin tw := tw [ 1 ] ;
73577: LD_ADDR_VAR 0 7
73581: PUSH
73582: LD_VAR 0 7
73586: PUSH
73587: LD_INT 1
73589: ARRAY
73590: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
73591: LD_ADDR_VAR 0 9
73595: PUSH
73596: LD_VAR 0 7
73600: PPUSH
73601: LD_EXP 56
73605: PUSH
73606: LD_VAR 0 2
73610: ARRAY
73611: PPUSH
73612: CALL 30029 0 2
73616: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
73617: LD_EXP 70
73621: PUSH
73622: LD_VAR 0 2
73626: ARRAY
73627: IFFALSE 73650
// if not weapon in mc_allowed_tower_weapons [ i ] then
73629: LD_VAR 0 9
73633: PUSH
73634: LD_EXP 70
73638: PUSH
73639: LD_VAR 0 2
73643: ARRAY
73644: IN
73645: NOT
73646: IFFALSE 73650
// continue ;
73648: GO 73352
// end else
73650: GO 73715
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
73652: LD_ADDR_VAR 0 5
73656: PUSH
73657: LD_EXP 39
73661: PUSH
73662: LD_VAR 0 2
73666: ARRAY
73667: PPUSH
73668: LD_VAR 0 4
73672: PPUSH
73673: CALL 56881 0 2
73677: ST_TO_ADDR
// if not tmp2 then
73678: LD_VAR 0 5
73682: NOT
73683: IFFALSE 73687
// continue ;
73685: GO 73352
// tw := tmp2 [ 1 ] ;
73687: LD_ADDR_VAR 0 7
73691: PUSH
73692: LD_VAR 0 5
73696: PUSH
73697: LD_INT 1
73699: ARRAY
73700: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
73701: LD_ADDR_VAR 0 9
73705: PUSH
73706: LD_VAR 0 5
73710: PUSH
73711: LD_INT 2
73713: ARRAY
73714: ST_TO_ADDR
// end ; if not weapon then
73715: LD_VAR 0 9
73719: NOT
73720: IFFALSE 73724
// continue ;
73722: GO 73352
// ComPlaceWeapon ( tw , weapon ) ;
73724: LD_VAR 0 7
73728: PPUSH
73729: LD_VAR 0 9
73733: PPUSH
73734: CALL_OW 148
// end ;
73738: GO 73352
73740: POP
73741: POP
// end ;
73742: LD_VAR 0 1
73746: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
73747: LD_INT 0
73749: PPUSH
73750: PPUSH
73751: PPUSH
73752: PPUSH
73753: PPUSH
73754: PPUSH
73755: PPUSH
// if not mc_bases then
73756: LD_EXP 31
73760: NOT
73761: IFFALSE 73765
// exit ;
73763: GO 74533
// for i = 1 to mc_bases do
73765: LD_ADDR_VAR 0 2
73769: PUSH
73770: DOUBLE
73771: LD_INT 1
73773: DEC
73774: ST_TO_ADDR
73775: LD_EXP 31
73779: PUSH
73780: FOR_TO
73781: IFFALSE 74531
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
73783: LD_EXP 44
73787: PUSH
73788: LD_VAR 0 2
73792: ARRAY
73793: NOT
73794: PUSH
73795: LD_EXP 44
73799: PUSH
73800: LD_VAR 0 2
73804: ARRAY
73805: PUSH
73806: LD_EXP 45
73810: PUSH
73811: LD_VAR 0 2
73815: ARRAY
73816: EQUAL
73817: OR
73818: PUSH
73819: LD_EXP 54
73823: PUSH
73824: LD_VAR 0 2
73828: ARRAY
73829: OR
73830: IFFALSE 73834
// continue ;
73832: GO 73780
// if mc_miners [ i ] then
73834: LD_EXP 45
73838: PUSH
73839: LD_VAR 0 2
73843: ARRAY
73844: IFFALSE 74218
// begin for j = mc_miners [ i ] downto 1 do
73846: LD_ADDR_VAR 0 3
73850: PUSH
73851: DOUBLE
73852: LD_EXP 45
73856: PUSH
73857: LD_VAR 0 2
73861: ARRAY
73862: INC
73863: ST_TO_ADDR
73864: LD_INT 1
73866: PUSH
73867: FOR_DOWNTO
73868: IFFALSE 74216
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
73870: LD_EXP 45
73874: PUSH
73875: LD_VAR 0 2
73879: ARRAY
73880: PUSH
73881: LD_VAR 0 3
73885: ARRAY
73886: PPUSH
73887: CALL_OW 301
73891: PUSH
73892: LD_EXP 45
73896: PUSH
73897: LD_VAR 0 2
73901: ARRAY
73902: PUSH
73903: LD_VAR 0 3
73907: ARRAY
73908: PPUSH
73909: CALL_OW 257
73913: PUSH
73914: LD_INT 1
73916: NONEQUAL
73917: OR
73918: IFFALSE 73981
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
73920: LD_ADDR_VAR 0 5
73924: PUSH
73925: LD_EXP 45
73929: PUSH
73930: LD_VAR 0 2
73934: ARRAY
73935: PUSH
73936: LD_EXP 45
73940: PUSH
73941: LD_VAR 0 2
73945: ARRAY
73946: PUSH
73947: LD_VAR 0 3
73951: ARRAY
73952: DIFF
73953: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
73954: LD_ADDR_EXP 45
73958: PUSH
73959: LD_EXP 45
73963: PPUSH
73964: LD_VAR 0 2
73968: PPUSH
73969: LD_VAR 0 5
73973: PPUSH
73974: CALL_OW 1
73978: ST_TO_ADDR
// continue ;
73979: GO 73867
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
73981: LD_EXP 45
73985: PUSH
73986: LD_VAR 0 2
73990: ARRAY
73991: PUSH
73992: LD_VAR 0 3
73996: ARRAY
73997: PPUSH
73998: CALL_OW 257
74002: PUSH
74003: LD_INT 1
74005: EQUAL
74006: PUSH
74007: LD_EXP 45
74011: PUSH
74012: LD_VAR 0 2
74016: ARRAY
74017: PUSH
74018: LD_VAR 0 3
74022: ARRAY
74023: PPUSH
74024: CALL_OW 459
74028: NOT
74029: AND
74030: PUSH
74031: LD_EXP 45
74035: PUSH
74036: LD_VAR 0 2
74040: ARRAY
74041: PUSH
74042: LD_VAR 0 3
74046: ARRAY
74047: PPUSH
74048: CALL_OW 314
74052: NOT
74053: AND
74054: IFFALSE 74214
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
74056: LD_EXP 45
74060: PUSH
74061: LD_VAR 0 2
74065: ARRAY
74066: PUSH
74067: LD_VAR 0 3
74071: ARRAY
74072: PPUSH
74073: CALL_OW 310
74077: IFFALSE 74100
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
74079: LD_EXP 45
74083: PUSH
74084: LD_VAR 0 2
74088: ARRAY
74089: PUSH
74090: LD_VAR 0 3
74094: ARRAY
74095: PPUSH
74096: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
74100: LD_EXP 45
74104: PUSH
74105: LD_VAR 0 2
74109: ARRAY
74110: PUSH
74111: LD_VAR 0 3
74115: ARRAY
74116: PPUSH
74117: CALL_OW 314
74121: NOT
74122: IFFALSE 74214
// begin r := rand ( 1 , mc_mines [ i ] ) ;
74124: LD_ADDR_VAR 0 7
74128: PUSH
74129: LD_INT 1
74131: PPUSH
74132: LD_EXP 44
74136: PUSH
74137: LD_VAR 0 2
74141: ARRAY
74142: PPUSH
74143: CALL_OW 12
74147: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
74148: LD_EXP 45
74152: PUSH
74153: LD_VAR 0 2
74157: ARRAY
74158: PUSH
74159: LD_VAR 0 3
74163: ARRAY
74164: PPUSH
74165: LD_EXP 44
74169: PUSH
74170: LD_VAR 0 2
74174: ARRAY
74175: PUSH
74176: LD_VAR 0 7
74180: ARRAY
74181: PUSH
74182: LD_INT 1
74184: ARRAY
74185: PPUSH
74186: LD_EXP 44
74190: PUSH
74191: LD_VAR 0 2
74195: ARRAY
74196: PUSH
74197: LD_VAR 0 7
74201: ARRAY
74202: PUSH
74203: LD_INT 2
74205: ARRAY
74206: PPUSH
74207: LD_INT 0
74209: PPUSH
74210: CALL_OW 193
// end ; end ; end ;
74214: GO 73867
74216: POP
74217: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
74218: LD_ADDR_VAR 0 5
74222: PUSH
74223: LD_EXP 31
74227: PUSH
74228: LD_VAR 0 2
74232: ARRAY
74233: PPUSH
74234: LD_INT 2
74236: PUSH
74237: LD_INT 30
74239: PUSH
74240: LD_INT 4
74242: PUSH
74243: EMPTY
74244: LIST
74245: LIST
74246: PUSH
74247: LD_INT 30
74249: PUSH
74250: LD_INT 5
74252: PUSH
74253: EMPTY
74254: LIST
74255: LIST
74256: PUSH
74257: LD_INT 30
74259: PUSH
74260: LD_INT 32
74262: PUSH
74263: EMPTY
74264: LIST
74265: LIST
74266: PUSH
74267: EMPTY
74268: LIST
74269: LIST
74270: LIST
74271: LIST
74272: PPUSH
74273: CALL_OW 72
74277: ST_TO_ADDR
// if not tmp then
74278: LD_VAR 0 5
74282: NOT
74283: IFFALSE 74287
// continue ;
74285: GO 73780
// list := [ ] ;
74287: LD_ADDR_VAR 0 6
74291: PUSH
74292: EMPTY
74293: ST_TO_ADDR
// for j in tmp do
74294: LD_ADDR_VAR 0 3
74298: PUSH
74299: LD_VAR 0 5
74303: PUSH
74304: FOR_IN
74305: IFFALSE 74374
// begin for k in UnitsInside ( j ) do
74307: LD_ADDR_VAR 0 4
74311: PUSH
74312: LD_VAR 0 3
74316: PPUSH
74317: CALL_OW 313
74321: PUSH
74322: FOR_IN
74323: IFFALSE 74370
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
74325: LD_VAR 0 4
74329: PPUSH
74330: CALL_OW 257
74334: PUSH
74335: LD_INT 1
74337: EQUAL
74338: PUSH
74339: LD_VAR 0 4
74343: PPUSH
74344: CALL_OW 459
74348: NOT
74349: AND
74350: IFFALSE 74368
// list := list ^ k ;
74352: LD_ADDR_VAR 0 6
74356: PUSH
74357: LD_VAR 0 6
74361: PUSH
74362: LD_VAR 0 4
74366: ADD
74367: ST_TO_ADDR
74368: GO 74322
74370: POP
74371: POP
// end ;
74372: GO 74304
74374: POP
74375: POP
// list := list diff mc_miners [ i ] ;
74376: LD_ADDR_VAR 0 6
74380: PUSH
74381: LD_VAR 0 6
74385: PUSH
74386: LD_EXP 45
74390: PUSH
74391: LD_VAR 0 2
74395: ARRAY
74396: DIFF
74397: ST_TO_ADDR
// if not list then
74398: LD_VAR 0 6
74402: NOT
74403: IFFALSE 74407
// continue ;
74405: GO 73780
// k := mc_mines [ i ] - mc_miners [ i ] ;
74407: LD_ADDR_VAR 0 4
74411: PUSH
74412: LD_EXP 44
74416: PUSH
74417: LD_VAR 0 2
74421: ARRAY
74422: PUSH
74423: LD_EXP 45
74427: PUSH
74428: LD_VAR 0 2
74432: ARRAY
74433: MINUS
74434: ST_TO_ADDR
// if k > list then
74435: LD_VAR 0 4
74439: PUSH
74440: LD_VAR 0 6
74444: GREATER
74445: IFFALSE 74457
// k := list ;
74447: LD_ADDR_VAR 0 4
74451: PUSH
74452: LD_VAR 0 6
74456: ST_TO_ADDR
// for j = 1 to k do
74457: LD_ADDR_VAR 0 3
74461: PUSH
74462: DOUBLE
74463: LD_INT 1
74465: DEC
74466: ST_TO_ADDR
74467: LD_VAR 0 4
74471: PUSH
74472: FOR_TO
74473: IFFALSE 74527
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
74475: LD_ADDR_EXP 45
74479: PUSH
74480: LD_EXP 45
74484: PPUSH
74485: LD_VAR 0 2
74489: PUSH
74490: LD_EXP 45
74494: PUSH
74495: LD_VAR 0 2
74499: ARRAY
74500: PUSH
74501: LD_INT 1
74503: PLUS
74504: PUSH
74505: EMPTY
74506: LIST
74507: LIST
74508: PPUSH
74509: LD_VAR 0 6
74513: PUSH
74514: LD_VAR 0 3
74518: ARRAY
74519: PPUSH
74520: CALL 25021 0 3
74524: ST_TO_ADDR
74525: GO 74472
74527: POP
74528: POP
// end ;
74529: GO 73780
74531: POP
74532: POP
// end ;
74533: LD_VAR 0 1
74537: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , side , target , cargo , depot , fac , components ; begin
74538: LD_INT 0
74540: PPUSH
74541: PPUSH
74542: PPUSH
74543: PPUSH
74544: PPUSH
74545: PPUSH
74546: PPUSH
74547: PPUSH
74548: PPUSH
74549: PPUSH
74550: PPUSH
// if not mc_bases then
74551: LD_EXP 31
74555: NOT
74556: IFFALSE 74560
// exit ;
74558: GO 76383
// for i = 1 to mc_bases do
74560: LD_ADDR_VAR 0 2
74564: PUSH
74565: DOUBLE
74566: LD_INT 1
74568: DEC
74569: ST_TO_ADDR
74570: LD_EXP 31
74574: PUSH
74575: FOR_TO
74576: IFFALSE 76381
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
74578: LD_EXP 31
74582: PUSH
74583: LD_VAR 0 2
74587: ARRAY
74588: NOT
74589: PUSH
74590: LD_EXP 38
74594: PUSH
74595: LD_VAR 0 2
74599: ARRAY
74600: OR
74601: IFFALSE 74605
// continue ;
74603: GO 74575
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
74605: LD_EXP 47
74609: PUSH
74610: LD_VAR 0 2
74614: ARRAY
74615: NOT
74616: PUSH
74617: LD_EXP 48
74621: PUSH
74622: LD_VAR 0 2
74626: ARRAY
74627: AND
74628: IFFALSE 74666
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
74630: LD_ADDR_EXP 48
74634: PUSH
74635: LD_EXP 48
74639: PPUSH
74640: LD_VAR 0 2
74644: PPUSH
74645: EMPTY
74646: PPUSH
74647: CALL_OW 1
74651: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
74652: LD_VAR 0 2
74656: PPUSH
74657: LD_INT 107
74659: PPUSH
74660: CALL 65413 0 2
// continue ;
74664: GO 74575
// end ; target := [ ] ;
74666: LD_ADDR_VAR 0 7
74670: PUSH
74671: EMPTY
74672: ST_TO_ADDR
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
74673: LD_ADDR_VAR 0 6
74677: PUSH
74678: LD_EXP 31
74682: PUSH
74683: LD_VAR 0 2
74687: ARRAY
74688: PUSH
74689: LD_INT 1
74691: ARRAY
74692: PPUSH
74693: CALL_OW 255
74697: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
74698: LD_ADDR_VAR 0 9
74702: PUSH
74703: LD_EXP 31
74707: PUSH
74708: LD_VAR 0 2
74712: ARRAY
74713: PPUSH
74714: LD_INT 2
74716: PUSH
74717: LD_INT 30
74719: PUSH
74720: LD_INT 0
74722: PUSH
74723: EMPTY
74724: LIST
74725: LIST
74726: PUSH
74727: LD_INT 30
74729: PUSH
74730: LD_INT 1
74732: PUSH
74733: EMPTY
74734: LIST
74735: LIST
74736: PUSH
74737: EMPTY
74738: LIST
74739: LIST
74740: LIST
74741: PPUSH
74742: CALL_OW 72
74746: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
74747: LD_ADDR_VAR 0 3
74751: PUSH
74752: DOUBLE
74753: LD_EXP 47
74757: PUSH
74758: LD_VAR 0 2
74762: ARRAY
74763: INC
74764: ST_TO_ADDR
74765: LD_INT 1
74767: PUSH
74768: FOR_DOWNTO
74769: IFFALSE 75014
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
74771: LD_EXP 47
74775: PUSH
74776: LD_VAR 0 2
74780: ARRAY
74781: PUSH
74782: LD_VAR 0 3
74786: ARRAY
74787: PUSH
74788: LD_INT 2
74790: ARRAY
74791: PPUSH
74792: LD_EXP 47
74796: PUSH
74797: LD_VAR 0 2
74801: ARRAY
74802: PUSH
74803: LD_VAR 0 3
74807: ARRAY
74808: PUSH
74809: LD_INT 3
74811: ARRAY
74812: PPUSH
74813: CALL_OW 488
74817: PUSH
74818: LD_EXP 47
74822: PUSH
74823: LD_VAR 0 2
74827: ARRAY
74828: PUSH
74829: LD_VAR 0 3
74833: ARRAY
74834: PUSH
74835: LD_INT 2
74837: ARRAY
74838: PPUSH
74839: LD_EXP 47
74843: PUSH
74844: LD_VAR 0 2
74848: ARRAY
74849: PUSH
74850: LD_VAR 0 3
74854: ARRAY
74855: PUSH
74856: LD_INT 3
74858: ARRAY
74859: PPUSH
74860: CALL_OW 284
74864: PUSH
74865: LD_INT 0
74867: EQUAL
74868: AND
74869: IFFALSE 74924
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
74871: LD_ADDR_VAR 0 5
74875: PUSH
74876: LD_EXP 47
74880: PUSH
74881: LD_VAR 0 2
74885: ARRAY
74886: PPUSH
74887: LD_VAR 0 3
74891: PPUSH
74892: CALL_OW 3
74896: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
74897: LD_ADDR_EXP 47
74901: PUSH
74902: LD_EXP 47
74906: PPUSH
74907: LD_VAR 0 2
74911: PPUSH
74912: LD_VAR 0 5
74916: PPUSH
74917: CALL_OW 1
74921: ST_TO_ADDR
// continue ;
74922: GO 74768
// end ; if DangerAtRangeXY ( side , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
74924: LD_VAR 0 6
74928: PPUSH
74929: LD_EXP 47
74933: PUSH
74934: LD_VAR 0 2
74938: ARRAY
74939: PUSH
74940: LD_VAR 0 3
74944: ARRAY
74945: PUSH
74946: LD_INT 2
74948: ARRAY
74949: PPUSH
74950: LD_EXP 47
74954: PUSH
74955: LD_VAR 0 2
74959: ARRAY
74960: PUSH
74961: LD_VAR 0 3
74965: ARRAY
74966: PUSH
74967: LD_INT 3
74969: ARRAY
74970: PPUSH
74971: LD_INT 30
74973: PPUSH
74974: CALL 25917 0 4
74978: PUSH
74979: LD_INT 4
74981: ARRAY
74982: PUSH
74983: LD_INT 0
74985: EQUAL
74986: IFFALSE 75012
// begin target := mc_crates [ i ] [ j ] ;
74988: LD_ADDR_VAR 0 7
74992: PUSH
74993: LD_EXP 47
74997: PUSH
74998: LD_VAR 0 2
75002: ARRAY
75003: PUSH
75004: LD_VAR 0 3
75008: ARRAY
75009: ST_TO_ADDR
// break ;
75010: GO 75014
// end ; end ;
75012: GO 74768
75014: POP
75015: POP
// if not target then
75016: LD_VAR 0 7
75020: NOT
75021: IFFALSE 75025
// continue ;
75023: GO 74575
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
75025: LD_ADDR_VAR 0 8
75029: PUSH
75030: LD_EXP 50
75034: PUSH
75035: LD_VAR 0 2
75039: ARRAY
75040: PPUSH
75041: LD_INT 2
75043: PUSH
75044: LD_INT 3
75046: PUSH
75047: LD_INT 58
75049: PUSH
75050: EMPTY
75051: LIST
75052: PUSH
75053: EMPTY
75054: LIST
75055: LIST
75056: PUSH
75057: LD_INT 61
75059: PUSH
75060: EMPTY
75061: LIST
75062: PUSH
75063: LD_INT 33
75065: PUSH
75066: LD_INT 5
75068: PUSH
75069: EMPTY
75070: LIST
75071: LIST
75072: PUSH
75073: LD_INT 33
75075: PUSH
75076: LD_INT 3
75078: PUSH
75079: EMPTY
75080: LIST
75081: LIST
75082: PUSH
75083: EMPTY
75084: LIST
75085: LIST
75086: LIST
75087: LIST
75088: LIST
75089: PUSH
75090: LD_INT 2
75092: PUSH
75093: LD_INT 34
75095: PUSH
75096: LD_INT 32
75098: PUSH
75099: EMPTY
75100: LIST
75101: LIST
75102: PUSH
75103: LD_INT 34
75105: PUSH
75106: LD_INT 51
75108: PUSH
75109: EMPTY
75110: LIST
75111: LIST
75112: PUSH
75113: LD_INT 34
75115: PUSH
75116: LD_INT 12
75118: PUSH
75119: EMPTY
75120: LIST
75121: LIST
75122: PUSH
75123: EMPTY
75124: LIST
75125: LIST
75126: LIST
75127: LIST
75128: PUSH
75129: EMPTY
75130: LIST
75131: LIST
75132: PPUSH
75133: CALL_OW 72
75137: ST_TO_ADDR
// if not cargo then
75138: LD_VAR 0 8
75142: NOT
75143: IFFALSE 75849
// begin if mc_crates_collector [ i ] < 5 then
75145: LD_EXP 48
75149: PUSH
75150: LD_VAR 0 2
75154: ARRAY
75155: PUSH
75156: LD_INT 5
75158: LESS
75159: IFFALSE 75525
// begin if mc_ape [ i ] then
75161: LD_EXP 60
75165: PUSH
75166: LD_VAR 0 2
75170: ARRAY
75171: IFFALSE 75218
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
75173: LD_ADDR_VAR 0 5
75177: PUSH
75178: LD_EXP 60
75182: PUSH
75183: LD_VAR 0 2
75187: ARRAY
75188: PPUSH
75189: LD_INT 25
75191: PUSH
75192: LD_INT 16
75194: PUSH
75195: EMPTY
75196: LIST
75197: LIST
75198: PUSH
75199: LD_INT 24
75201: PUSH
75202: LD_INT 750
75204: PUSH
75205: EMPTY
75206: LIST
75207: LIST
75208: PUSH
75209: EMPTY
75210: LIST
75211: LIST
75212: PPUSH
75213: CALL_OW 72
75217: ST_TO_ADDR
// if not tmp then
75218: LD_VAR 0 5
75222: NOT
75223: IFFALSE 75270
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
75225: LD_ADDR_VAR 0 5
75229: PUSH
75230: LD_EXP 31
75234: PUSH
75235: LD_VAR 0 2
75239: ARRAY
75240: PPUSH
75241: LD_INT 25
75243: PUSH
75244: LD_INT 2
75246: PUSH
75247: EMPTY
75248: LIST
75249: LIST
75250: PUSH
75251: LD_INT 24
75253: PUSH
75254: LD_INT 750
75256: PUSH
75257: EMPTY
75258: LIST
75259: LIST
75260: PUSH
75261: EMPTY
75262: LIST
75263: LIST
75264: PPUSH
75265: CALL_OW 72
75269: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
75270: LD_EXP 60
75274: PUSH
75275: LD_VAR 0 2
75279: ARRAY
75280: PUSH
75281: LD_EXP 31
75285: PUSH
75286: LD_VAR 0 2
75290: ARRAY
75291: PPUSH
75292: LD_INT 25
75294: PUSH
75295: LD_INT 2
75297: PUSH
75298: EMPTY
75299: LIST
75300: LIST
75301: PUSH
75302: LD_INT 24
75304: PUSH
75305: LD_INT 750
75307: PUSH
75308: EMPTY
75309: LIST
75310: LIST
75311: PUSH
75312: EMPTY
75313: LIST
75314: LIST
75315: PPUSH
75316: CALL_OW 72
75320: AND
75321: PUSH
75322: LD_VAR 0 5
75326: PUSH
75327: LD_INT 5
75329: LESS
75330: AND
75331: IFFALSE 75413
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
75333: LD_ADDR_VAR 0 3
75337: PUSH
75338: LD_EXP 31
75342: PUSH
75343: LD_VAR 0 2
75347: ARRAY
75348: PPUSH
75349: LD_INT 25
75351: PUSH
75352: LD_INT 2
75354: PUSH
75355: EMPTY
75356: LIST
75357: LIST
75358: PUSH
75359: LD_INT 24
75361: PUSH
75362: LD_INT 750
75364: PUSH
75365: EMPTY
75366: LIST
75367: LIST
75368: PUSH
75369: EMPTY
75370: LIST
75371: LIST
75372: PPUSH
75373: CALL_OW 72
75377: PUSH
75378: FOR_IN
75379: IFFALSE 75411
// begin tmp := tmp union j ;
75381: LD_ADDR_VAR 0 5
75385: PUSH
75386: LD_VAR 0 5
75390: PUSH
75391: LD_VAR 0 3
75395: UNION
75396: ST_TO_ADDR
// if tmp >= 5 then
75397: LD_VAR 0 5
75401: PUSH
75402: LD_INT 5
75404: GREATEREQUAL
75405: IFFALSE 75409
// break ;
75407: GO 75411
// end ;
75409: GO 75378
75411: POP
75412: POP
// end ; if not tmp then
75413: LD_VAR 0 5
75417: NOT
75418: IFFALSE 75422
// continue ;
75420: GO 74575
// for j in tmp do
75422: LD_ADDR_VAR 0 3
75426: PUSH
75427: LD_VAR 0 5
75431: PUSH
75432: FOR_IN
75433: IFFALSE 75523
// if not GetTag ( j ) then
75435: LD_VAR 0 3
75439: PPUSH
75440: CALL_OW 110
75444: NOT
75445: IFFALSE 75521
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
75447: LD_ADDR_EXP 48
75451: PUSH
75452: LD_EXP 48
75456: PPUSH
75457: LD_VAR 0 2
75461: PUSH
75462: LD_EXP 48
75466: PUSH
75467: LD_VAR 0 2
75471: ARRAY
75472: PUSH
75473: LD_INT 1
75475: PLUS
75476: PUSH
75477: EMPTY
75478: LIST
75479: LIST
75480: PPUSH
75481: LD_VAR 0 3
75485: PPUSH
75486: CALL 25021 0 3
75490: ST_TO_ADDR
// SetTag ( j , 107 ) ;
75491: LD_VAR 0 3
75495: PPUSH
75496: LD_INT 107
75498: PPUSH
75499: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
75503: LD_EXP 48
75507: PUSH
75508: LD_VAR 0 2
75512: ARRAY
75513: PUSH
75514: LD_INT 5
75516: GREATEREQUAL
75517: IFFALSE 75521
// break ;
75519: GO 75523
// end ;
75521: GO 75432
75523: POP
75524: POP
// end ; if mc_crates_collector [ i ] and target then
75525: LD_EXP 48
75529: PUSH
75530: LD_VAR 0 2
75534: ARRAY
75535: PUSH
75536: LD_VAR 0 7
75540: AND
75541: IFFALSE 75847
// begin if mc_crates_collector [ i ] < target [ 1 ] then
75543: LD_EXP 48
75547: PUSH
75548: LD_VAR 0 2
75552: ARRAY
75553: PUSH
75554: LD_VAR 0 7
75558: PUSH
75559: LD_INT 1
75561: ARRAY
75562: LESS
75563: IFFALSE 75583
// tmp := mc_crates_collector [ i ] else
75565: LD_ADDR_VAR 0 5
75569: PUSH
75570: LD_EXP 48
75574: PUSH
75575: LD_VAR 0 2
75579: ARRAY
75580: ST_TO_ADDR
75581: GO 75597
// tmp := target [ 1 ] ;
75583: LD_ADDR_VAR 0 5
75587: PUSH
75588: LD_VAR 0 7
75592: PUSH
75593: LD_INT 1
75595: ARRAY
75596: ST_TO_ADDR
// k := 0 ;
75597: LD_ADDR_VAR 0 4
75601: PUSH
75602: LD_INT 0
75604: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
75605: LD_ADDR_VAR 0 3
75609: PUSH
75610: LD_EXP 48
75614: PUSH
75615: LD_VAR 0 2
75619: ARRAY
75620: PUSH
75621: FOR_IN
75622: IFFALSE 75845
// begin k := k + 1 ;
75624: LD_ADDR_VAR 0 4
75628: PUSH
75629: LD_VAR 0 4
75633: PUSH
75634: LD_INT 1
75636: PLUS
75637: ST_TO_ADDR
// if k > tmp then
75638: LD_VAR 0 4
75642: PUSH
75643: LD_VAR 0 5
75647: GREATER
75648: IFFALSE 75652
// break ;
75650: GO 75845
// if not GetClass ( j ) in [ 2 , 16 ] then
75652: LD_VAR 0 3
75656: PPUSH
75657: CALL_OW 257
75661: PUSH
75662: LD_INT 2
75664: PUSH
75665: LD_INT 16
75667: PUSH
75668: EMPTY
75669: LIST
75670: LIST
75671: IN
75672: NOT
75673: IFFALSE 75726
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
75675: LD_ADDR_EXP 48
75679: PUSH
75680: LD_EXP 48
75684: PPUSH
75685: LD_VAR 0 2
75689: PPUSH
75690: LD_EXP 48
75694: PUSH
75695: LD_VAR 0 2
75699: ARRAY
75700: PUSH
75701: LD_VAR 0 3
75705: DIFF
75706: PPUSH
75707: CALL_OW 1
75711: ST_TO_ADDR
// SetTag ( j , 0 ) ;
75712: LD_VAR 0 3
75716: PPUSH
75717: LD_INT 0
75719: PPUSH
75720: CALL_OW 109
// continue ;
75724: GO 75621
// end ; if IsInUnit ( j ) then
75726: LD_VAR 0 3
75730: PPUSH
75731: CALL_OW 310
75735: IFFALSE 75746
// ComExitBuilding ( j ) ;
75737: LD_VAR 0 3
75741: PPUSH
75742: CALL_OW 122
// wait ( 3 ) ;
75746: LD_INT 3
75748: PPUSH
75749: CALL_OW 67
// if HasTask ( j ) and DangerAtRangeXY ( side , target [ 2 ] , target [ 3 ] , 30 ) [ 4 ] then
75753: LD_VAR 0 3
75757: PPUSH
75758: CALL_OW 314
75762: PUSH
75763: LD_VAR 0 6
75767: PPUSH
75768: LD_VAR 0 7
75772: PUSH
75773: LD_INT 2
75775: ARRAY
75776: PPUSH
75777: LD_VAR 0 7
75781: PUSH
75782: LD_INT 3
75784: ARRAY
75785: PPUSH
75786: LD_INT 30
75788: PPUSH
75789: CALL 25917 0 4
75793: PUSH
75794: LD_INT 4
75796: ARRAY
75797: AND
75798: IFFALSE 75816
// ComStandNearbyBuilding ( j , depot ) else
75800: LD_VAR 0 3
75804: PPUSH
75805: LD_VAR 0 9
75809: PPUSH
75810: CALL 21448 0 2
75814: GO 75843
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
75816: LD_VAR 0 3
75820: PPUSH
75821: LD_VAR 0 7
75825: PUSH
75826: LD_INT 2
75828: ARRAY
75829: PPUSH
75830: LD_VAR 0 7
75834: PUSH
75835: LD_INT 3
75837: ARRAY
75838: PPUSH
75839: CALL_OW 117
// end ;
75843: GO 75621
75845: POP
75846: POP
// end ; end else
75847: GO 76379
// begin for j in cargo do
75849: LD_ADDR_VAR 0 3
75853: PUSH
75854: LD_VAR 0 8
75858: PUSH
75859: FOR_IN
75860: IFFALSE 76377
// begin if GetTag ( j ) <> 0 then
75862: LD_VAR 0 3
75866: PPUSH
75867: CALL_OW 110
75871: PUSH
75872: LD_INT 0
75874: NONEQUAL
75875: IFFALSE 75879
// continue ;
75877: GO 75859
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
75879: LD_VAR 0 3
75883: PPUSH
75884: CALL_OW 256
75888: PUSH
75889: LD_INT 1000
75891: LESS
75892: PUSH
75893: LD_VAR 0 3
75897: PPUSH
75898: LD_EXP 55
75902: PUSH
75903: LD_VAR 0 2
75907: ARRAY
75908: PPUSH
75909: CALL_OW 308
75913: NOT
75914: AND
75915: IFFALSE 75937
// ComMoveToArea ( j , mc_parking [ i ] ) ;
75917: LD_VAR 0 3
75921: PPUSH
75922: LD_EXP 55
75926: PUSH
75927: LD_VAR 0 2
75931: ARRAY
75932: PPUSH
75933: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
75937: LD_VAR 0 3
75941: PPUSH
75942: CALL_OW 256
75946: PUSH
75947: LD_INT 1000
75949: LESS
75950: PUSH
75951: LD_VAR 0 3
75955: PPUSH
75956: LD_EXP 55
75960: PUSH
75961: LD_VAR 0 2
75965: ARRAY
75966: PPUSH
75967: CALL_OW 308
75971: AND
75972: IFFALSE 75976
// continue ;
75974: GO 75859
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
75976: LD_VAR 0 3
75980: PPUSH
75981: CALL_OW 262
75985: PUSH
75986: LD_INT 2
75988: EQUAL
75989: PUSH
75990: LD_VAR 0 3
75994: PPUSH
75995: CALL_OW 261
75999: PUSH
76000: LD_INT 15
76002: LESS
76003: AND
76004: IFFALSE 76008
// continue ;
76006: GO 75859
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
76008: LD_VAR 0 3
76012: PPUSH
76013: CALL_OW 262
76017: PUSH
76018: LD_INT 1
76020: EQUAL
76021: PUSH
76022: LD_VAR 0 3
76026: PPUSH
76027: CALL_OW 261
76031: PUSH
76032: LD_INT 10
76034: LESS
76035: AND
76036: IFFALSE 76316
// begin if not depot then
76038: LD_VAR 0 9
76042: NOT
76043: IFFALSE 76047
// continue ;
76045: GO 75859
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
76047: LD_VAR 0 3
76051: PPUSH
76052: LD_VAR 0 9
76056: PPUSH
76057: LD_VAR 0 3
76061: PPUSH
76062: CALL_OW 74
76066: PPUSH
76067: CALL_OW 296
76071: PUSH
76072: LD_INT 6
76074: LESS
76075: IFFALSE 76091
// SetFuel ( j , 100 ) else
76077: LD_VAR 0 3
76081: PPUSH
76082: LD_INT 100
76084: PPUSH
76085: CALL_OW 240
76089: GO 76316
// if GetFuel ( j ) = 0 then
76091: LD_VAR 0 3
76095: PPUSH
76096: CALL_OW 261
76100: PUSH
76101: LD_INT 0
76103: EQUAL
76104: IFFALSE 76316
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
76106: LD_ADDR_EXP 50
76110: PUSH
76111: LD_EXP 50
76115: PPUSH
76116: LD_VAR 0 2
76120: PPUSH
76121: LD_EXP 50
76125: PUSH
76126: LD_VAR 0 2
76130: ARRAY
76131: PUSH
76132: LD_VAR 0 3
76136: DIFF
76137: PPUSH
76138: CALL_OW 1
76142: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
76143: LD_VAR 0 3
76147: PPUSH
76148: CALL_OW 263
76152: PUSH
76153: LD_INT 1
76155: EQUAL
76156: IFFALSE 76172
// ComExitVehicle ( IsInUnit ( j ) ) ;
76158: LD_VAR 0 3
76162: PPUSH
76163: CALL_OW 310
76167: PPUSH
76168: CALL_OW 121
// if GetControl ( j ) = control_remote then
76172: LD_VAR 0 3
76176: PPUSH
76177: CALL_OW 263
76181: PUSH
76182: LD_INT 2
76184: EQUAL
76185: IFFALSE 76196
// ComUnlink ( j ) ;
76187: LD_VAR 0 3
76191: PPUSH
76192: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
76196: LD_ADDR_VAR 0 10
76200: PUSH
76201: LD_VAR 0 2
76205: PPUSH
76206: LD_INT 3
76208: PPUSH
76209: CALL 85983 0 2
76213: ST_TO_ADDR
// if fac then
76214: LD_VAR 0 10
76218: IFFALSE 76314
// begin for k in fac do
76220: LD_ADDR_VAR 0 4
76224: PUSH
76225: LD_VAR 0 10
76229: PUSH
76230: FOR_IN
76231: IFFALSE 76312
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
76233: LD_ADDR_VAR 0 11
76237: PUSH
76238: LD_VAR 0 10
76242: PPUSH
76243: LD_VAR 0 3
76247: PPUSH
76248: CALL_OW 265
76252: PPUSH
76253: LD_VAR 0 3
76257: PPUSH
76258: CALL_OW 262
76262: PPUSH
76263: LD_VAR 0 3
76267: PPUSH
76268: CALL_OW 263
76272: PPUSH
76273: LD_VAR 0 3
76277: PPUSH
76278: CALL_OW 264
76282: PPUSH
76283: CALL 22519 0 5
76287: ST_TO_ADDR
// if components then
76288: LD_VAR 0 11
76292: IFFALSE 76310
// begin MC_InsertProduceList ( i , components ) ;
76294: LD_VAR 0 2
76298: PPUSH
76299: LD_VAR 0 11
76303: PPUSH
76304: CALL 85528 0 2
// break ;
76308: GO 76312
// end ; end ;
76310: GO 76230
76312: POP
76313: POP
// end ; continue ;
76314: GO 75859
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
76316: LD_VAR 0 3
76320: PPUSH
76321: LD_INT 1
76323: PPUSH
76324: CALL_OW 289
76328: PUSH
76329: LD_INT 100
76331: LESS
76332: PUSH
76333: LD_VAR 0 3
76337: PPUSH
76338: CALL_OW 314
76342: NOT
76343: AND
76344: IFFALSE 76373
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
76346: LD_VAR 0 3
76350: PPUSH
76351: LD_VAR 0 7
76355: PUSH
76356: LD_INT 2
76358: ARRAY
76359: PPUSH
76360: LD_VAR 0 7
76364: PUSH
76365: LD_INT 3
76367: ARRAY
76368: PPUSH
76369: CALL_OW 117
// break ;
76373: GO 76377
// end ;
76375: GO 75859
76377: POP
76378: POP
// end ; end ;
76379: GO 74575
76381: POP
76382: POP
// end ;
76383: LD_VAR 0 1
76387: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
76388: LD_INT 0
76390: PPUSH
76391: PPUSH
76392: PPUSH
76393: PPUSH
// if not mc_bases then
76394: LD_EXP 31
76398: NOT
76399: IFFALSE 76403
// exit ;
76401: GO 76564
// for i = 1 to mc_bases do
76403: LD_ADDR_VAR 0 2
76407: PUSH
76408: DOUBLE
76409: LD_INT 1
76411: DEC
76412: ST_TO_ADDR
76413: LD_EXP 31
76417: PUSH
76418: FOR_TO
76419: IFFALSE 76562
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
76421: LD_ADDR_VAR 0 4
76425: PUSH
76426: LD_EXP 50
76430: PUSH
76431: LD_VAR 0 2
76435: ARRAY
76436: PUSH
76437: LD_EXP 53
76441: PUSH
76442: LD_VAR 0 2
76446: ARRAY
76447: UNION
76448: PPUSH
76449: LD_INT 33
76451: PUSH
76452: LD_INT 2
76454: PUSH
76455: EMPTY
76456: LIST
76457: LIST
76458: PPUSH
76459: CALL_OW 72
76463: ST_TO_ADDR
// if tmp then
76464: LD_VAR 0 4
76468: IFFALSE 76560
// for j in tmp do
76470: LD_ADDR_VAR 0 3
76474: PUSH
76475: LD_VAR 0 4
76479: PUSH
76480: FOR_IN
76481: IFFALSE 76558
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
76483: LD_VAR 0 3
76487: PPUSH
76488: CALL_OW 312
76492: NOT
76493: PUSH
76494: LD_VAR 0 3
76498: PPUSH
76499: CALL_OW 256
76503: PUSH
76504: LD_INT 250
76506: GREATEREQUAL
76507: AND
76508: IFFALSE 76521
// Connect ( j ) else
76510: LD_VAR 0 3
76514: PPUSH
76515: CALL 27990 0 1
76519: GO 76556
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
76521: LD_VAR 0 3
76525: PPUSH
76526: CALL_OW 256
76530: PUSH
76531: LD_INT 250
76533: LESS
76534: PUSH
76535: LD_VAR 0 3
76539: PPUSH
76540: CALL_OW 312
76544: AND
76545: IFFALSE 76556
// ComUnlink ( j ) ;
76547: LD_VAR 0 3
76551: PPUSH
76552: CALL_OW 136
76556: GO 76480
76558: POP
76559: POP
// end ;
76560: GO 76418
76562: POP
76563: POP
// end ;
76564: LD_VAR 0 1
76568: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
76569: LD_INT 0
76571: PPUSH
76572: PPUSH
76573: PPUSH
76574: PPUSH
76575: PPUSH
// if not mc_bases then
76576: LD_EXP 31
76580: NOT
76581: IFFALSE 76585
// exit ;
76583: GO 77030
// for i = 1 to mc_bases do
76585: LD_ADDR_VAR 0 2
76589: PUSH
76590: DOUBLE
76591: LD_INT 1
76593: DEC
76594: ST_TO_ADDR
76595: LD_EXP 31
76599: PUSH
76600: FOR_TO
76601: IFFALSE 77028
// begin if not mc_produce [ i ] then
76603: LD_EXP 52
76607: PUSH
76608: LD_VAR 0 2
76612: ARRAY
76613: NOT
76614: IFFALSE 76618
// continue ;
76616: GO 76600
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
76618: LD_ADDR_VAR 0 5
76622: PUSH
76623: LD_EXP 31
76627: PUSH
76628: LD_VAR 0 2
76632: ARRAY
76633: PPUSH
76634: LD_INT 30
76636: PUSH
76637: LD_INT 3
76639: PUSH
76640: EMPTY
76641: LIST
76642: LIST
76643: PPUSH
76644: CALL_OW 72
76648: ST_TO_ADDR
// if not fac then
76649: LD_VAR 0 5
76653: NOT
76654: IFFALSE 76658
// continue ;
76656: GO 76600
// for j in fac do
76658: LD_ADDR_VAR 0 3
76662: PUSH
76663: LD_VAR 0 5
76667: PUSH
76668: FOR_IN
76669: IFFALSE 77024
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
76671: LD_VAR 0 3
76675: PPUSH
76676: CALL_OW 461
76680: PUSH
76681: LD_INT 2
76683: NONEQUAL
76684: PUSH
76685: LD_VAR 0 3
76689: PPUSH
76690: LD_INT 15
76692: PPUSH
76693: CALL 27618 0 2
76697: PUSH
76698: LD_INT 4
76700: ARRAY
76701: OR
76702: IFFALSE 76706
// continue ;
76704: GO 76668
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
76706: LD_VAR 0 3
76710: PPUSH
76711: LD_EXP 52
76715: PUSH
76716: LD_VAR 0 2
76720: ARRAY
76721: PUSH
76722: LD_INT 1
76724: ARRAY
76725: PUSH
76726: LD_INT 1
76728: ARRAY
76729: PPUSH
76730: LD_EXP 52
76734: PUSH
76735: LD_VAR 0 2
76739: ARRAY
76740: PUSH
76741: LD_INT 1
76743: ARRAY
76744: PUSH
76745: LD_INT 2
76747: ARRAY
76748: PPUSH
76749: LD_EXP 52
76753: PUSH
76754: LD_VAR 0 2
76758: ARRAY
76759: PUSH
76760: LD_INT 1
76762: ARRAY
76763: PUSH
76764: LD_INT 3
76766: ARRAY
76767: PPUSH
76768: LD_EXP 52
76772: PUSH
76773: LD_VAR 0 2
76777: ARRAY
76778: PUSH
76779: LD_INT 1
76781: ARRAY
76782: PUSH
76783: LD_INT 4
76785: ARRAY
76786: PPUSH
76787: CALL_OW 448
76791: PUSH
76792: LD_VAR 0 3
76796: PPUSH
76797: LD_EXP 52
76801: PUSH
76802: LD_VAR 0 2
76806: ARRAY
76807: PUSH
76808: LD_INT 1
76810: ARRAY
76811: PUSH
76812: LD_INT 1
76814: ARRAY
76815: PUSH
76816: LD_EXP 52
76820: PUSH
76821: LD_VAR 0 2
76825: ARRAY
76826: PUSH
76827: LD_INT 1
76829: ARRAY
76830: PUSH
76831: LD_INT 2
76833: ARRAY
76834: PUSH
76835: LD_EXP 52
76839: PUSH
76840: LD_VAR 0 2
76844: ARRAY
76845: PUSH
76846: LD_INT 1
76848: ARRAY
76849: PUSH
76850: LD_INT 3
76852: ARRAY
76853: PUSH
76854: LD_EXP 52
76858: PUSH
76859: LD_VAR 0 2
76863: ARRAY
76864: PUSH
76865: LD_INT 1
76867: ARRAY
76868: PUSH
76869: LD_INT 4
76871: ARRAY
76872: PUSH
76873: EMPTY
76874: LIST
76875: LIST
76876: LIST
76877: LIST
76878: PPUSH
76879: CALL 31385 0 2
76883: AND
76884: IFFALSE 77022
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
76886: LD_VAR 0 3
76890: PPUSH
76891: LD_EXP 52
76895: PUSH
76896: LD_VAR 0 2
76900: ARRAY
76901: PUSH
76902: LD_INT 1
76904: ARRAY
76905: PUSH
76906: LD_INT 1
76908: ARRAY
76909: PPUSH
76910: LD_EXP 52
76914: PUSH
76915: LD_VAR 0 2
76919: ARRAY
76920: PUSH
76921: LD_INT 1
76923: ARRAY
76924: PUSH
76925: LD_INT 2
76927: ARRAY
76928: PPUSH
76929: LD_EXP 52
76933: PUSH
76934: LD_VAR 0 2
76938: ARRAY
76939: PUSH
76940: LD_INT 1
76942: ARRAY
76943: PUSH
76944: LD_INT 3
76946: ARRAY
76947: PPUSH
76948: LD_EXP 52
76952: PUSH
76953: LD_VAR 0 2
76957: ARRAY
76958: PUSH
76959: LD_INT 1
76961: ARRAY
76962: PUSH
76963: LD_INT 4
76965: ARRAY
76966: PPUSH
76967: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
76971: LD_ADDR_VAR 0 4
76975: PUSH
76976: LD_EXP 52
76980: PUSH
76981: LD_VAR 0 2
76985: ARRAY
76986: PPUSH
76987: LD_INT 1
76989: PPUSH
76990: CALL_OW 3
76994: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
76995: LD_ADDR_EXP 52
76999: PUSH
77000: LD_EXP 52
77004: PPUSH
77005: LD_VAR 0 2
77009: PPUSH
77010: LD_VAR 0 4
77014: PPUSH
77015: CALL_OW 1
77019: ST_TO_ADDR
// break ;
77020: GO 77024
// end ; end ;
77022: GO 76668
77024: POP
77025: POP
// end ;
77026: GO 76600
77028: POP
77029: POP
// end ;
77030: LD_VAR 0 1
77034: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
77035: LD_INT 0
77037: PPUSH
77038: PPUSH
77039: PPUSH
// if not mc_bases then
77040: LD_EXP 31
77044: NOT
77045: IFFALSE 77049
// exit ;
77047: GO 77138
// for i = 1 to mc_bases do
77049: LD_ADDR_VAR 0 2
77053: PUSH
77054: DOUBLE
77055: LD_INT 1
77057: DEC
77058: ST_TO_ADDR
77059: LD_EXP 31
77063: PUSH
77064: FOR_TO
77065: IFFALSE 77136
// begin if mc_attack [ i ] then
77067: LD_EXP 51
77071: PUSH
77072: LD_VAR 0 2
77076: ARRAY
77077: IFFALSE 77134
// begin tmp := mc_attack [ i ] [ 1 ] ;
77079: LD_ADDR_VAR 0 3
77083: PUSH
77084: LD_EXP 51
77088: PUSH
77089: LD_VAR 0 2
77093: ARRAY
77094: PUSH
77095: LD_INT 1
77097: ARRAY
77098: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
77099: LD_ADDR_EXP 51
77103: PUSH
77104: LD_EXP 51
77108: PPUSH
77109: LD_VAR 0 2
77113: PPUSH
77114: EMPTY
77115: PPUSH
77116: CALL_OW 1
77120: ST_TO_ADDR
// Attack ( tmp ) ;
77121: LD_VAR 0 3
77125: PPUSH
77126: CALL 111854 0 1
// exit ;
77130: POP
77131: POP
77132: GO 77138
// end ; end ;
77134: GO 77064
77136: POP
77137: POP
// end ;
77138: LD_VAR 0 1
77142: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
77143: LD_INT 0
77145: PPUSH
77146: PPUSH
77147: PPUSH
77148: PPUSH
77149: PPUSH
77150: PPUSH
77151: PPUSH
// if not mc_bases then
77152: LD_EXP 31
77156: NOT
77157: IFFALSE 77161
// exit ;
77159: GO 78018
// for i = 1 to mc_bases do
77161: LD_ADDR_VAR 0 2
77165: PUSH
77166: DOUBLE
77167: LD_INT 1
77169: DEC
77170: ST_TO_ADDR
77171: LD_EXP 31
77175: PUSH
77176: FOR_TO
77177: IFFALSE 78016
// begin if not mc_bases [ i ] then
77179: LD_EXP 31
77183: PUSH
77184: LD_VAR 0 2
77188: ARRAY
77189: NOT
77190: IFFALSE 77194
// continue ;
77192: GO 77176
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
77194: LD_ADDR_VAR 0 7
77198: PUSH
77199: LD_EXP 31
77203: PUSH
77204: LD_VAR 0 2
77208: ARRAY
77209: PUSH
77210: LD_INT 1
77212: ARRAY
77213: PPUSH
77214: CALL 21670 0 1
77218: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
77219: LD_ADDR_EXP 54
77223: PUSH
77224: LD_EXP 54
77228: PPUSH
77229: LD_VAR 0 2
77233: PPUSH
77234: LD_EXP 31
77238: PUSH
77239: LD_VAR 0 2
77243: ARRAY
77244: PUSH
77245: LD_INT 1
77247: ARRAY
77248: PPUSH
77249: CALL_OW 255
77253: PPUSH
77254: LD_EXP 56
77258: PUSH
77259: LD_VAR 0 2
77263: ARRAY
77264: PPUSH
77265: CALL 21635 0 2
77269: PPUSH
77270: CALL_OW 1
77274: ST_TO_ADDR
// if not mc_scan [ i ] then
77275: LD_EXP 54
77279: PUSH
77280: LD_VAR 0 2
77284: ARRAY
77285: NOT
77286: IFFALSE 77464
// begin mc_is_defending := Replace ( mc_is_defending , i , false ) ;
77288: LD_ADDR_EXP 74
77292: PUSH
77293: LD_EXP 74
77297: PPUSH
77298: LD_VAR 0 2
77302: PPUSH
77303: LD_INT 0
77305: PPUSH
77306: CALL_OW 1
77310: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
77311: LD_ADDR_VAR 0 4
77315: PUSH
77316: LD_EXP 31
77320: PUSH
77321: LD_VAR 0 2
77325: ARRAY
77326: PPUSH
77327: LD_INT 2
77329: PUSH
77330: LD_INT 25
77332: PUSH
77333: LD_INT 5
77335: PUSH
77336: EMPTY
77337: LIST
77338: LIST
77339: PUSH
77340: LD_INT 25
77342: PUSH
77343: LD_INT 8
77345: PUSH
77346: EMPTY
77347: LIST
77348: LIST
77349: PUSH
77350: LD_INT 25
77352: PUSH
77353: LD_INT 9
77355: PUSH
77356: EMPTY
77357: LIST
77358: LIST
77359: PUSH
77360: EMPTY
77361: LIST
77362: LIST
77363: LIST
77364: LIST
77365: PPUSH
77366: CALL_OW 72
77370: ST_TO_ADDR
// if not tmp then
77371: LD_VAR 0 4
77375: NOT
77376: IFFALSE 77380
// continue ;
77378: GO 77176
// for j in tmp do
77380: LD_ADDR_VAR 0 3
77384: PUSH
77385: LD_VAR 0 4
77389: PUSH
77390: FOR_IN
77391: IFFALSE 77462
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
77393: LD_VAR 0 3
77397: PPUSH
77398: CALL_OW 310
77402: PPUSH
77403: CALL_OW 266
77407: PUSH
77408: LD_INT 5
77410: EQUAL
77411: PUSH
77412: LD_VAR 0 3
77416: PPUSH
77417: CALL_OW 257
77421: PUSH
77422: LD_INT 1
77424: EQUAL
77425: AND
77426: PUSH
77427: LD_VAR 0 3
77431: PPUSH
77432: CALL_OW 459
77436: NOT
77437: AND
77438: PUSH
77439: LD_VAR 0 7
77443: AND
77444: IFFALSE 77460
// ComChangeProfession ( j , class ) ;
77446: LD_VAR 0 3
77450: PPUSH
77451: LD_VAR 0 7
77455: PPUSH
77456: CALL_OW 123
77460: GO 77390
77462: POP
77463: POP
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and not mc_defender [ i ] and ( UnitFilter ( mc_bases [ i ] , [ [ f_ok ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) < 4 or UnitFilter ( mc_bases [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ) then
77464: LD_EXP 54
77468: PUSH
77469: LD_VAR 0 2
77473: ARRAY
77474: PUSH
77475: LD_EXP 74
77479: PUSH
77480: LD_VAR 0 2
77484: ARRAY
77485: NOT
77486: AND
77487: PUSH
77488: LD_EXP 53
77492: PUSH
77493: LD_VAR 0 2
77497: ARRAY
77498: NOT
77499: AND
77500: PUSH
77501: LD_EXP 31
77505: PUSH
77506: LD_VAR 0 2
77510: ARRAY
77511: PPUSH
77512: LD_INT 50
77514: PUSH
77515: EMPTY
77516: LIST
77517: PUSH
77518: LD_INT 2
77520: PUSH
77521: LD_INT 30
77523: PUSH
77524: LD_INT 32
77526: PUSH
77527: EMPTY
77528: LIST
77529: LIST
77530: PUSH
77531: LD_INT 30
77533: PUSH
77534: LD_INT 33
77536: PUSH
77537: EMPTY
77538: LIST
77539: LIST
77540: PUSH
77541: LD_INT 30
77543: PUSH
77544: LD_INT 4
77546: PUSH
77547: EMPTY
77548: LIST
77549: LIST
77550: PUSH
77551: LD_INT 30
77553: PUSH
77554: LD_INT 5
77556: PUSH
77557: EMPTY
77558: LIST
77559: LIST
77560: PUSH
77561: EMPTY
77562: LIST
77563: LIST
77564: LIST
77565: LIST
77566: LIST
77567: PUSH
77568: EMPTY
77569: LIST
77570: LIST
77571: PPUSH
77572: CALL_OW 72
77576: PUSH
77577: LD_INT 4
77579: LESS
77580: PUSH
77581: LD_EXP 31
77585: PUSH
77586: LD_VAR 0 2
77590: ARRAY
77591: PPUSH
77592: LD_INT 3
77594: PUSH
77595: LD_INT 24
77597: PUSH
77598: LD_INT 1000
77600: PUSH
77601: EMPTY
77602: LIST
77603: LIST
77604: PUSH
77605: EMPTY
77606: LIST
77607: LIST
77608: PUSH
77609: LD_INT 2
77611: PUSH
77612: LD_INT 30
77614: PUSH
77615: LD_INT 0
77617: PUSH
77618: EMPTY
77619: LIST
77620: LIST
77621: PUSH
77622: LD_INT 30
77624: PUSH
77625: LD_INT 1
77627: PUSH
77628: EMPTY
77629: LIST
77630: LIST
77631: PUSH
77632: EMPTY
77633: LIST
77634: LIST
77635: LIST
77636: PUSH
77637: EMPTY
77638: LIST
77639: LIST
77640: PPUSH
77641: CALL_OW 72
77645: OR
77646: AND
77647: IFFALSE 77898
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
77649: LD_ADDR_EXP 74
77653: PUSH
77654: LD_EXP 74
77658: PPUSH
77659: LD_VAR 0 2
77663: PPUSH
77664: LD_INT 1
77666: PPUSH
77667: CALL_OW 1
77671: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
77672: LD_ADDR_VAR 0 4
77676: PUSH
77677: LD_EXP 31
77681: PUSH
77682: LD_VAR 0 2
77686: ARRAY
77687: PPUSH
77688: LD_INT 2
77690: PUSH
77691: LD_INT 25
77693: PUSH
77694: LD_INT 1
77696: PUSH
77697: EMPTY
77698: LIST
77699: LIST
77700: PUSH
77701: LD_INT 25
77703: PUSH
77704: LD_INT 5
77706: PUSH
77707: EMPTY
77708: LIST
77709: LIST
77710: PUSH
77711: LD_INT 25
77713: PUSH
77714: LD_INT 8
77716: PUSH
77717: EMPTY
77718: LIST
77719: LIST
77720: PUSH
77721: LD_INT 25
77723: PUSH
77724: LD_INT 9
77726: PUSH
77727: EMPTY
77728: LIST
77729: LIST
77730: PUSH
77731: EMPTY
77732: LIST
77733: LIST
77734: LIST
77735: LIST
77736: LIST
77737: PPUSH
77738: CALL_OW 72
77742: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
77743: LD_ADDR_VAR 0 4
77747: PUSH
77748: LD_VAR 0 4
77752: PUSH
77753: LD_VAR 0 4
77757: PPUSH
77758: LD_INT 18
77760: PPUSH
77761: CALL 54907 0 2
77765: DIFF
77766: ST_TO_ADDR
// if not tmp and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
77767: LD_VAR 0 4
77771: NOT
77772: PUSH
77773: LD_EXP 31
77777: PUSH
77778: LD_VAR 0 2
77782: ARRAY
77783: PPUSH
77784: LD_INT 2
77786: PUSH
77787: LD_INT 30
77789: PUSH
77790: LD_INT 4
77792: PUSH
77793: EMPTY
77794: LIST
77795: LIST
77796: PUSH
77797: LD_INT 30
77799: PUSH
77800: LD_INT 5
77802: PUSH
77803: EMPTY
77804: LIST
77805: LIST
77806: PUSH
77807: EMPTY
77808: LIST
77809: LIST
77810: LIST
77811: PPUSH
77812: CALL_OW 72
77816: NOT
77817: AND
77818: IFFALSE 77880
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
77820: LD_ADDR_VAR 0 4
77824: PUSH
77825: LD_EXP 31
77829: PUSH
77830: LD_VAR 0 2
77834: ARRAY
77835: PPUSH
77836: LD_INT 2
77838: PUSH
77839: LD_INT 25
77841: PUSH
77842: LD_INT 2
77844: PUSH
77845: EMPTY
77846: LIST
77847: LIST
77848: PUSH
77849: LD_INT 25
77851: PUSH
77852: LD_INT 3
77854: PUSH
77855: EMPTY
77856: LIST
77857: LIST
77858: PUSH
77859: LD_INT 25
77861: PUSH
77862: LD_INT 4
77864: PUSH
77865: EMPTY
77866: LIST
77867: LIST
77868: PUSH
77869: EMPTY
77870: LIST
77871: LIST
77872: LIST
77873: LIST
77874: PPUSH
77875: CALL_OW 72
77879: ST_TO_ADDR
// BasicDefend ( i , tmp ) ;
77880: LD_VAR 0 2
77884: PPUSH
77885: LD_VAR 0 4
77889: PPUSH
77890: CALL 116563 0 2
// exit ;
77894: POP
77895: POP
77896: GO 78018
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and mc_defender [ i ] then
77898: LD_EXP 54
77902: PUSH
77903: LD_VAR 0 2
77907: ARRAY
77908: PUSH
77909: LD_EXP 74
77913: PUSH
77914: LD_VAR 0 2
77918: ARRAY
77919: NOT
77920: AND
77921: PUSH
77922: LD_EXP 53
77926: PUSH
77927: LD_VAR 0 2
77931: ARRAY
77932: AND
77933: IFFALSE 78014
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
77935: LD_ADDR_EXP 74
77939: PUSH
77940: LD_EXP 74
77944: PPUSH
77945: LD_VAR 0 2
77949: PPUSH
77950: LD_INT 1
77952: PPUSH
77953: CALL_OW 1
77957: ST_TO_ADDR
// tmp := mc_defender [ i ] ;
77958: LD_ADDR_VAR 0 4
77962: PUSH
77963: LD_EXP 53
77967: PUSH
77968: LD_VAR 0 2
77972: ARRAY
77973: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
77974: LD_ADDR_EXP 53
77978: PUSH
77979: LD_EXP 53
77983: PPUSH
77984: LD_VAR 0 2
77988: PPUSH
77989: EMPTY
77990: PPUSH
77991: CALL_OW 1
77995: ST_TO_ADDR
// Defend ( i , tmp ) ;
77996: LD_VAR 0 2
78000: PPUSH
78001: LD_VAR 0 4
78005: PPUSH
78006: CALL 117159 0 2
// exit ;
78010: POP
78011: POP
78012: GO 78018
// end ; end ;
78014: GO 77176
78016: POP
78017: POP
// end ;
78018: LD_VAR 0 1
78022: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
78023: LD_INT 0
78025: PPUSH
78026: PPUSH
78027: PPUSH
78028: PPUSH
78029: PPUSH
78030: PPUSH
78031: PPUSH
78032: PPUSH
78033: PPUSH
78034: PPUSH
78035: PPUSH
// if not mc_bases then
78036: LD_EXP 31
78040: NOT
78041: IFFALSE 78045
// exit ;
78043: GO 79132
// for i = 1 to mc_bases do
78045: LD_ADDR_VAR 0 2
78049: PUSH
78050: DOUBLE
78051: LD_INT 1
78053: DEC
78054: ST_TO_ADDR
78055: LD_EXP 31
78059: PUSH
78060: FOR_TO
78061: IFFALSE 79130
// begin tmp := mc_lab [ i ] ;
78063: LD_ADDR_VAR 0 6
78067: PUSH
78068: LD_EXP 64
78072: PUSH
78073: LD_VAR 0 2
78077: ARRAY
78078: ST_TO_ADDR
// if not tmp then
78079: LD_VAR 0 6
78083: NOT
78084: IFFALSE 78088
// continue ;
78086: GO 78060
// idle_lab := 0 ;
78088: LD_ADDR_VAR 0 11
78092: PUSH
78093: LD_INT 0
78095: ST_TO_ADDR
// for j in tmp do
78096: LD_ADDR_VAR 0 3
78100: PUSH
78101: LD_VAR 0 6
78105: PUSH
78106: FOR_IN
78107: IFFALSE 79126
// begin researching := false ;
78109: LD_ADDR_VAR 0 10
78113: PUSH
78114: LD_INT 0
78116: ST_TO_ADDR
// side := GetSide ( j ) ;
78117: LD_ADDR_VAR 0 4
78121: PUSH
78122: LD_VAR 0 3
78126: PPUSH
78127: CALL_OW 255
78131: ST_TO_ADDR
// if not mc_tech [ side ] then
78132: LD_EXP 58
78136: PUSH
78137: LD_VAR 0 4
78141: ARRAY
78142: NOT
78143: IFFALSE 78147
// continue ;
78145: GO 78106
// if BuildingStatus ( j ) = bs_idle then
78147: LD_VAR 0 3
78151: PPUSH
78152: CALL_OW 461
78156: PUSH
78157: LD_INT 2
78159: EQUAL
78160: IFFALSE 78348
// begin if idle_lab and UnitsInside ( j ) < 6 then
78162: LD_VAR 0 11
78166: PUSH
78167: LD_VAR 0 3
78171: PPUSH
78172: CALL_OW 313
78176: PUSH
78177: LD_INT 6
78179: LESS
78180: AND
78181: IFFALSE 78252
// begin tmp2 := UnitsInside ( idle_lab ) ;
78183: LD_ADDR_VAR 0 9
78187: PUSH
78188: LD_VAR 0 11
78192: PPUSH
78193: CALL_OW 313
78197: ST_TO_ADDR
// if tmp2 then
78198: LD_VAR 0 9
78202: IFFALSE 78244
// for x in tmp2 do
78204: LD_ADDR_VAR 0 7
78208: PUSH
78209: LD_VAR 0 9
78213: PUSH
78214: FOR_IN
78215: IFFALSE 78242
// begin ComExitBuilding ( x ) ;
78217: LD_VAR 0 7
78221: PPUSH
78222: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
78226: LD_VAR 0 7
78230: PPUSH
78231: LD_VAR 0 3
78235: PPUSH
78236: CALL_OW 180
// end ;
78240: GO 78214
78242: POP
78243: POP
// idle_lab := 0 ;
78244: LD_ADDR_VAR 0 11
78248: PUSH
78249: LD_INT 0
78251: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
78252: LD_ADDR_VAR 0 5
78256: PUSH
78257: LD_EXP 58
78261: PUSH
78262: LD_VAR 0 4
78266: ARRAY
78267: PUSH
78268: FOR_IN
78269: IFFALSE 78329
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
78271: LD_VAR 0 3
78275: PPUSH
78276: LD_VAR 0 5
78280: PPUSH
78281: CALL_OW 430
78285: PUSH
78286: LD_VAR 0 4
78290: PPUSH
78291: LD_VAR 0 5
78295: PPUSH
78296: CALL 20740 0 2
78300: AND
78301: IFFALSE 78327
// begin researching := true ;
78303: LD_ADDR_VAR 0 10
78307: PUSH
78308: LD_INT 1
78310: ST_TO_ADDR
// ComResearch ( j , t ) ;
78311: LD_VAR 0 3
78315: PPUSH
78316: LD_VAR 0 5
78320: PPUSH
78321: CALL_OW 124
// break ;
78325: GO 78329
// end ;
78327: GO 78268
78329: POP
78330: POP
// if not researching then
78331: LD_VAR 0 10
78335: NOT
78336: IFFALSE 78348
// idle_lab := j ;
78338: LD_ADDR_VAR 0 11
78342: PUSH
78343: LD_VAR 0 3
78347: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
78348: LD_VAR 0 3
78352: PPUSH
78353: CALL_OW 461
78357: PUSH
78358: LD_INT 10
78360: EQUAL
78361: IFFALSE 78949
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
78363: LD_EXP 60
78367: PUSH
78368: LD_VAR 0 2
78372: ARRAY
78373: NOT
78374: PUSH
78375: LD_EXP 61
78379: PUSH
78380: LD_VAR 0 2
78384: ARRAY
78385: NOT
78386: AND
78387: PUSH
78388: LD_EXP 58
78392: PUSH
78393: LD_VAR 0 4
78397: ARRAY
78398: PUSH
78399: LD_INT 1
78401: GREATER
78402: AND
78403: IFFALSE 78534
// begin ComCancel ( j ) ;
78405: LD_VAR 0 3
78409: PPUSH
78410: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
78414: LD_ADDR_EXP 58
78418: PUSH
78419: LD_EXP 58
78423: PPUSH
78424: LD_VAR 0 4
78428: PPUSH
78429: LD_EXP 58
78433: PUSH
78434: LD_VAR 0 4
78438: ARRAY
78439: PPUSH
78440: LD_EXP 58
78444: PUSH
78445: LD_VAR 0 4
78449: ARRAY
78450: PUSH
78451: LD_INT 1
78453: MINUS
78454: PPUSH
78455: LD_EXP 58
78459: PUSH
78460: LD_VAR 0 4
78464: ARRAY
78465: PPUSH
78466: LD_INT 0
78468: PPUSH
78469: CALL 24439 0 4
78473: PPUSH
78474: CALL_OW 1
78478: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
78479: LD_ADDR_EXP 58
78483: PUSH
78484: LD_EXP 58
78488: PPUSH
78489: LD_VAR 0 4
78493: PPUSH
78494: LD_EXP 58
78498: PUSH
78499: LD_VAR 0 4
78503: ARRAY
78504: PPUSH
78505: LD_EXP 58
78509: PUSH
78510: LD_VAR 0 4
78514: ARRAY
78515: PPUSH
78516: LD_INT 1
78518: PPUSH
78519: LD_INT 0
78521: PPUSH
78522: CALL 24439 0 4
78526: PPUSH
78527: CALL_OW 1
78531: ST_TO_ADDR
// continue ;
78532: GO 78106
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
78534: LD_EXP 60
78538: PUSH
78539: LD_VAR 0 2
78543: ARRAY
78544: PUSH
78545: LD_EXP 61
78549: PUSH
78550: LD_VAR 0 2
78554: ARRAY
78555: NOT
78556: AND
78557: IFFALSE 78684
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
78559: LD_ADDR_EXP 61
78563: PUSH
78564: LD_EXP 61
78568: PPUSH
78569: LD_VAR 0 2
78573: PUSH
78574: LD_EXP 61
78578: PUSH
78579: LD_VAR 0 2
78583: ARRAY
78584: PUSH
78585: LD_INT 1
78587: PLUS
78588: PUSH
78589: EMPTY
78590: LIST
78591: LIST
78592: PPUSH
78593: LD_EXP 60
78597: PUSH
78598: LD_VAR 0 2
78602: ARRAY
78603: PUSH
78604: LD_INT 1
78606: ARRAY
78607: PPUSH
78608: CALL 25021 0 3
78612: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
78613: LD_EXP 60
78617: PUSH
78618: LD_VAR 0 2
78622: ARRAY
78623: PUSH
78624: LD_INT 1
78626: ARRAY
78627: PPUSH
78628: LD_INT 112
78630: PPUSH
78631: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
78635: LD_ADDR_VAR 0 9
78639: PUSH
78640: LD_EXP 60
78644: PUSH
78645: LD_VAR 0 2
78649: ARRAY
78650: PPUSH
78651: LD_INT 1
78653: PPUSH
78654: CALL_OW 3
78658: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
78659: LD_ADDR_EXP 60
78663: PUSH
78664: LD_EXP 60
78668: PPUSH
78669: LD_VAR 0 2
78673: PPUSH
78674: LD_VAR 0 9
78678: PPUSH
78679: CALL_OW 1
78683: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
78684: LD_EXP 60
78688: PUSH
78689: LD_VAR 0 2
78693: ARRAY
78694: PUSH
78695: LD_EXP 61
78699: PUSH
78700: LD_VAR 0 2
78704: ARRAY
78705: AND
78706: PUSH
78707: LD_EXP 61
78711: PUSH
78712: LD_VAR 0 2
78716: ARRAY
78717: PUSH
78718: LD_INT 1
78720: ARRAY
78721: PPUSH
78722: CALL_OW 310
78726: NOT
78727: AND
78728: PUSH
78729: LD_VAR 0 3
78733: PPUSH
78734: CALL_OW 313
78738: PUSH
78739: LD_INT 6
78741: EQUAL
78742: AND
78743: IFFALSE 78799
// begin tmp2 := UnitsInside ( j ) ;
78745: LD_ADDR_VAR 0 9
78749: PUSH
78750: LD_VAR 0 3
78754: PPUSH
78755: CALL_OW 313
78759: ST_TO_ADDR
// if tmp2 = 6 then
78760: LD_VAR 0 9
78764: PUSH
78765: LD_INT 6
78767: EQUAL
78768: IFFALSE 78799
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
78770: LD_VAR 0 9
78774: PUSH
78775: LD_INT 1
78777: ARRAY
78778: PPUSH
78779: LD_INT 112
78781: PPUSH
78782: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
78786: LD_VAR 0 9
78790: PUSH
78791: LD_INT 1
78793: ARRAY
78794: PPUSH
78795: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
78799: LD_EXP 61
78803: PUSH
78804: LD_VAR 0 2
78808: ARRAY
78809: PUSH
78810: LD_EXP 61
78814: PUSH
78815: LD_VAR 0 2
78819: ARRAY
78820: PUSH
78821: LD_INT 1
78823: ARRAY
78824: PPUSH
78825: CALL_OW 314
78829: NOT
78830: AND
78831: PUSH
78832: LD_EXP 61
78836: PUSH
78837: LD_VAR 0 2
78841: ARRAY
78842: PUSH
78843: LD_INT 1
78845: ARRAY
78846: PPUSH
78847: CALL_OW 310
78851: NOT
78852: AND
78853: IFFALSE 78879
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
78855: LD_EXP 61
78859: PUSH
78860: LD_VAR 0 2
78864: ARRAY
78865: PUSH
78866: LD_INT 1
78868: ARRAY
78869: PPUSH
78870: LD_VAR 0 3
78874: PPUSH
78875: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
78879: LD_EXP 61
78883: PUSH
78884: LD_VAR 0 2
78888: ARRAY
78889: PUSH
78890: LD_INT 1
78892: ARRAY
78893: PPUSH
78894: CALL_OW 310
78898: PUSH
78899: LD_EXP 61
78903: PUSH
78904: LD_VAR 0 2
78908: ARRAY
78909: PUSH
78910: LD_INT 1
78912: ARRAY
78913: PPUSH
78914: CALL_OW 310
78918: PPUSH
78919: CALL_OW 461
78923: PUSH
78924: LD_INT 3
78926: NONEQUAL
78927: AND
78928: IFFALSE 78949
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
78930: LD_EXP 61
78934: PUSH
78935: LD_VAR 0 2
78939: ARRAY
78940: PUSH
78941: LD_INT 1
78943: ARRAY
78944: PPUSH
78945: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
78949: LD_VAR 0 3
78953: PPUSH
78954: CALL_OW 461
78958: PUSH
78959: LD_INT 6
78961: EQUAL
78962: PUSH
78963: LD_VAR 0 6
78967: PUSH
78968: LD_INT 1
78970: GREATER
78971: AND
78972: IFFALSE 79124
// begin sci := [ ] ;
78974: LD_ADDR_VAR 0 8
78978: PUSH
78979: EMPTY
78980: ST_TO_ADDR
// for x in ( tmp diff j ) do
78981: LD_ADDR_VAR 0 7
78985: PUSH
78986: LD_VAR 0 6
78990: PUSH
78991: LD_VAR 0 3
78995: DIFF
78996: PUSH
78997: FOR_IN
78998: IFFALSE 79050
// begin if sci = 6 then
79000: LD_VAR 0 8
79004: PUSH
79005: LD_INT 6
79007: EQUAL
79008: IFFALSE 79012
// break ;
79010: GO 79050
// if BuildingStatus ( x ) = bs_idle then
79012: LD_VAR 0 7
79016: PPUSH
79017: CALL_OW 461
79021: PUSH
79022: LD_INT 2
79024: EQUAL
79025: IFFALSE 79048
// sci := sci ^ UnitsInside ( x ) ;
79027: LD_ADDR_VAR 0 8
79031: PUSH
79032: LD_VAR 0 8
79036: PUSH
79037: LD_VAR 0 7
79041: PPUSH
79042: CALL_OW 313
79046: ADD
79047: ST_TO_ADDR
// end ;
79048: GO 78997
79050: POP
79051: POP
// if not sci then
79052: LD_VAR 0 8
79056: NOT
79057: IFFALSE 79061
// continue ;
79059: GO 78106
// for x in sci do
79061: LD_ADDR_VAR 0 7
79065: PUSH
79066: LD_VAR 0 8
79070: PUSH
79071: FOR_IN
79072: IFFALSE 79122
// if IsInUnit ( x ) and not HasTask ( x ) then
79074: LD_VAR 0 7
79078: PPUSH
79079: CALL_OW 310
79083: PUSH
79084: LD_VAR 0 7
79088: PPUSH
79089: CALL_OW 314
79093: NOT
79094: AND
79095: IFFALSE 79120
// begin ComExitBuilding ( x ) ;
79097: LD_VAR 0 7
79101: PPUSH
79102: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
79106: LD_VAR 0 7
79110: PPUSH
79111: LD_VAR 0 3
79115: PPUSH
79116: CALL_OW 180
// end ;
79120: GO 79071
79122: POP
79123: POP
// end ; end ;
79124: GO 78106
79126: POP
79127: POP
// end ;
79128: GO 78060
79130: POP
79131: POP
// end ;
79132: LD_VAR 0 1
79136: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
79137: LD_INT 0
79139: PPUSH
79140: PPUSH
// if not mc_bases then
79141: LD_EXP 31
79145: NOT
79146: IFFALSE 79150
// exit ;
79148: GO 79231
// for i = 1 to mc_bases do
79150: LD_ADDR_VAR 0 2
79154: PUSH
79155: DOUBLE
79156: LD_INT 1
79158: DEC
79159: ST_TO_ADDR
79160: LD_EXP 31
79164: PUSH
79165: FOR_TO
79166: IFFALSE 79229
// if mc_mines [ i ] and mc_miners [ i ] then
79168: LD_EXP 44
79172: PUSH
79173: LD_VAR 0 2
79177: ARRAY
79178: PUSH
79179: LD_EXP 45
79183: PUSH
79184: LD_VAR 0 2
79188: ARRAY
79189: AND
79190: IFFALSE 79227
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
79192: LD_EXP 45
79196: PUSH
79197: LD_VAR 0 2
79201: ARRAY
79202: PUSH
79203: LD_INT 1
79205: ARRAY
79206: PPUSH
79207: CALL_OW 255
79211: PPUSH
79212: LD_EXP 44
79216: PUSH
79217: LD_VAR 0 2
79221: ARRAY
79222: PPUSH
79223: CALL 21823 0 2
79227: GO 79165
79229: POP
79230: POP
// end ;
79231: LD_VAR 0 1
79235: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
79236: LD_INT 0
79238: PPUSH
79239: PPUSH
79240: PPUSH
79241: PPUSH
79242: PPUSH
79243: PPUSH
79244: PPUSH
79245: PPUSH
// if not mc_bases or not mc_parking then
79246: LD_EXP 31
79250: NOT
79251: PUSH
79252: LD_EXP 55
79256: NOT
79257: OR
79258: IFFALSE 79262
// exit ;
79260: GO 80000
// for i = 1 to mc_bases do
79262: LD_ADDR_VAR 0 2
79266: PUSH
79267: DOUBLE
79268: LD_INT 1
79270: DEC
79271: ST_TO_ADDR
79272: LD_EXP 31
79276: PUSH
79277: FOR_TO
79278: IFFALSE 79998
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
79280: LD_EXP 31
79284: PUSH
79285: LD_VAR 0 2
79289: ARRAY
79290: NOT
79291: PUSH
79292: LD_EXP 55
79296: PUSH
79297: LD_VAR 0 2
79301: ARRAY
79302: NOT
79303: OR
79304: IFFALSE 79308
// continue ;
79306: GO 79277
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
79308: LD_ADDR_VAR 0 5
79312: PUSH
79313: LD_EXP 31
79317: PUSH
79318: LD_VAR 0 2
79322: ARRAY
79323: PUSH
79324: LD_INT 1
79326: ARRAY
79327: PPUSH
79328: CALL_OW 255
79332: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
79333: LD_ADDR_VAR 0 6
79337: PUSH
79338: LD_EXP 31
79342: PUSH
79343: LD_VAR 0 2
79347: ARRAY
79348: PPUSH
79349: LD_INT 30
79351: PUSH
79352: LD_INT 3
79354: PUSH
79355: EMPTY
79356: LIST
79357: LIST
79358: PPUSH
79359: CALL_OW 72
79363: ST_TO_ADDR
// if not fac then
79364: LD_VAR 0 6
79368: NOT
79369: IFFALSE 79420
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
79371: LD_ADDR_VAR 0 6
79375: PUSH
79376: LD_EXP 31
79380: PUSH
79381: LD_VAR 0 2
79385: ARRAY
79386: PPUSH
79387: LD_INT 2
79389: PUSH
79390: LD_INT 30
79392: PUSH
79393: LD_INT 0
79395: PUSH
79396: EMPTY
79397: LIST
79398: LIST
79399: PUSH
79400: LD_INT 30
79402: PUSH
79403: LD_INT 1
79405: PUSH
79406: EMPTY
79407: LIST
79408: LIST
79409: PUSH
79410: EMPTY
79411: LIST
79412: LIST
79413: LIST
79414: PPUSH
79415: CALL_OW 72
79419: ST_TO_ADDR
// if not fac then
79420: LD_VAR 0 6
79424: NOT
79425: IFFALSE 79429
// continue ;
79427: GO 79277
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
79429: LD_ADDR_VAR 0 7
79433: PUSH
79434: LD_EXP 55
79438: PUSH
79439: LD_VAR 0 2
79443: ARRAY
79444: PPUSH
79445: LD_INT 22
79447: PUSH
79448: LD_VAR 0 5
79452: PUSH
79453: EMPTY
79454: LIST
79455: LIST
79456: PUSH
79457: LD_INT 21
79459: PUSH
79460: LD_INT 2
79462: PUSH
79463: EMPTY
79464: LIST
79465: LIST
79466: PUSH
79467: LD_INT 3
79469: PUSH
79470: LD_INT 60
79472: PUSH
79473: EMPTY
79474: LIST
79475: PUSH
79476: EMPTY
79477: LIST
79478: LIST
79479: PUSH
79480: LD_INT 3
79482: PUSH
79483: LD_INT 24
79485: PUSH
79486: LD_INT 1000
79488: PUSH
79489: EMPTY
79490: LIST
79491: LIST
79492: PUSH
79493: EMPTY
79494: LIST
79495: LIST
79496: PUSH
79497: EMPTY
79498: LIST
79499: LIST
79500: LIST
79501: LIST
79502: PPUSH
79503: CALL_OW 70
79507: ST_TO_ADDR
// for j in fac do
79508: LD_ADDR_VAR 0 3
79512: PUSH
79513: LD_VAR 0 6
79517: PUSH
79518: FOR_IN
79519: IFFALSE 79614
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
79521: LD_ADDR_VAR 0 7
79525: PUSH
79526: LD_VAR 0 7
79530: PUSH
79531: LD_INT 22
79533: PUSH
79534: LD_VAR 0 5
79538: PUSH
79539: EMPTY
79540: LIST
79541: LIST
79542: PUSH
79543: LD_INT 91
79545: PUSH
79546: LD_VAR 0 3
79550: PUSH
79551: LD_INT 15
79553: PUSH
79554: EMPTY
79555: LIST
79556: LIST
79557: LIST
79558: PUSH
79559: LD_INT 21
79561: PUSH
79562: LD_INT 2
79564: PUSH
79565: EMPTY
79566: LIST
79567: LIST
79568: PUSH
79569: LD_INT 3
79571: PUSH
79572: LD_INT 60
79574: PUSH
79575: EMPTY
79576: LIST
79577: PUSH
79578: EMPTY
79579: LIST
79580: LIST
79581: PUSH
79582: LD_INT 3
79584: PUSH
79585: LD_INT 24
79587: PUSH
79588: LD_INT 1000
79590: PUSH
79591: EMPTY
79592: LIST
79593: LIST
79594: PUSH
79595: EMPTY
79596: LIST
79597: LIST
79598: PUSH
79599: EMPTY
79600: LIST
79601: LIST
79602: LIST
79603: LIST
79604: LIST
79605: PPUSH
79606: CALL_OW 69
79610: UNION
79611: ST_TO_ADDR
79612: GO 79518
79614: POP
79615: POP
// if not vehs then
79616: LD_VAR 0 7
79620: NOT
79621: IFFALSE 79647
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
79623: LD_ADDR_EXP 43
79627: PUSH
79628: LD_EXP 43
79632: PPUSH
79633: LD_VAR 0 2
79637: PPUSH
79638: EMPTY
79639: PPUSH
79640: CALL_OW 1
79644: ST_TO_ADDR
// continue ;
79645: GO 79277
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
79647: LD_ADDR_VAR 0 8
79651: PUSH
79652: LD_EXP 31
79656: PUSH
79657: LD_VAR 0 2
79661: ARRAY
79662: PPUSH
79663: LD_INT 30
79665: PUSH
79666: LD_INT 3
79668: PUSH
79669: EMPTY
79670: LIST
79671: LIST
79672: PPUSH
79673: CALL_OW 72
79677: ST_TO_ADDR
// if tmp then
79678: LD_VAR 0 8
79682: IFFALSE 79785
// begin for j in tmp do
79684: LD_ADDR_VAR 0 3
79688: PUSH
79689: LD_VAR 0 8
79693: PUSH
79694: FOR_IN
79695: IFFALSE 79783
// for k in UnitsInside ( j ) do
79697: LD_ADDR_VAR 0 4
79701: PUSH
79702: LD_VAR 0 3
79706: PPUSH
79707: CALL_OW 313
79711: PUSH
79712: FOR_IN
79713: IFFALSE 79779
// if k then
79715: LD_VAR 0 4
79719: IFFALSE 79777
// if not k in mc_repair_vehicle [ i ] then
79721: LD_VAR 0 4
79725: PUSH
79726: LD_EXP 43
79730: PUSH
79731: LD_VAR 0 2
79735: ARRAY
79736: IN
79737: NOT
79738: IFFALSE 79777
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
79740: LD_ADDR_EXP 43
79744: PUSH
79745: LD_EXP 43
79749: PPUSH
79750: LD_VAR 0 2
79754: PPUSH
79755: LD_EXP 43
79759: PUSH
79760: LD_VAR 0 2
79764: ARRAY
79765: PUSH
79766: LD_VAR 0 4
79770: UNION
79771: PPUSH
79772: CALL_OW 1
79776: ST_TO_ADDR
79777: GO 79712
79779: POP
79780: POP
79781: GO 79694
79783: POP
79784: POP
// end ; if not mc_repair_vehicle [ i ] then
79785: LD_EXP 43
79789: PUSH
79790: LD_VAR 0 2
79794: ARRAY
79795: NOT
79796: IFFALSE 79800
// continue ;
79798: GO 79277
// for j in mc_repair_vehicle [ i ] do
79800: LD_ADDR_VAR 0 3
79804: PUSH
79805: LD_EXP 43
79809: PUSH
79810: LD_VAR 0 2
79814: ARRAY
79815: PUSH
79816: FOR_IN
79817: IFFALSE 79994
// begin if GetClass ( j ) <> 3 then
79819: LD_VAR 0 3
79823: PPUSH
79824: CALL_OW 257
79828: PUSH
79829: LD_INT 3
79831: NONEQUAL
79832: IFFALSE 79873
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
79834: LD_ADDR_EXP 43
79838: PUSH
79839: LD_EXP 43
79843: PPUSH
79844: LD_VAR 0 2
79848: PPUSH
79849: LD_EXP 43
79853: PUSH
79854: LD_VAR 0 2
79858: ARRAY
79859: PUSH
79860: LD_VAR 0 3
79864: DIFF
79865: PPUSH
79866: CALL_OW 1
79870: ST_TO_ADDR
// continue ;
79871: GO 79816
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
79873: LD_VAR 0 3
79877: PPUSH
79878: CALL_OW 311
79882: NOT
79883: PUSH
79884: LD_VAR 0 3
79888: PUSH
79889: LD_EXP 34
79893: PUSH
79894: LD_VAR 0 2
79898: ARRAY
79899: PUSH
79900: LD_INT 1
79902: ARRAY
79903: IN
79904: NOT
79905: AND
79906: PUSH
79907: LD_VAR 0 3
79911: PUSH
79912: LD_EXP 34
79916: PUSH
79917: LD_VAR 0 2
79921: ARRAY
79922: PUSH
79923: LD_INT 2
79925: ARRAY
79926: IN
79927: NOT
79928: AND
79929: IFFALSE 79992
// begin if IsInUnit ( j ) then
79931: LD_VAR 0 3
79935: PPUSH
79936: CALL_OW 310
79940: IFFALSE 79953
// ComExitBuilding ( j ) else
79942: LD_VAR 0 3
79946: PPUSH
79947: CALL_OW 122
79951: GO 79992
// if not WantToRepairVehicle ( j , vehs [ 1 ] ) then
79953: LD_VAR 0 3
79957: PPUSH
79958: LD_VAR 0 7
79962: PUSH
79963: LD_INT 1
79965: ARRAY
79966: PPUSH
79967: CALL 59398 0 2
79971: NOT
79972: IFFALSE 79992
// ComRepairVehicle ( j , vehs [ 1 ] ) ;
79974: LD_VAR 0 3
79978: PPUSH
79979: LD_VAR 0 7
79983: PUSH
79984: LD_INT 1
79986: ARRAY
79987: PPUSH
79988: CALL_OW 129
// end ; end ;
79992: GO 79816
79994: POP
79995: POP
// end ;
79996: GO 79277
79998: POP
79999: POP
// end ;
80000: LD_VAR 0 1
80004: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
80005: LD_INT 0
80007: PPUSH
80008: PPUSH
80009: PPUSH
80010: PPUSH
80011: PPUSH
80012: PPUSH
80013: PPUSH
80014: PPUSH
80015: PPUSH
80016: PPUSH
80017: PPUSH
// if not mc_bases then
80018: LD_EXP 31
80022: NOT
80023: IFFALSE 80027
// exit ;
80025: GO 80829
// for i = 1 to mc_bases do
80027: LD_ADDR_VAR 0 2
80031: PUSH
80032: DOUBLE
80033: LD_INT 1
80035: DEC
80036: ST_TO_ADDR
80037: LD_EXP 31
80041: PUSH
80042: FOR_TO
80043: IFFALSE 80827
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
80045: LD_EXP 59
80049: PUSH
80050: LD_VAR 0 2
80054: ARRAY
80055: NOT
80056: PUSH
80057: LD_EXP 34
80061: PUSH
80062: LD_VAR 0 2
80066: ARRAY
80067: PUSH
80068: LD_INT 1
80070: ARRAY
80071: OR
80072: PUSH
80073: LD_EXP 34
80077: PUSH
80078: LD_VAR 0 2
80082: ARRAY
80083: PUSH
80084: LD_INT 2
80086: ARRAY
80087: OR
80088: PUSH
80089: LD_EXP 57
80093: PUSH
80094: LD_VAR 0 2
80098: ARRAY
80099: PPUSH
80100: LD_INT 1
80102: PPUSH
80103: CALL_OW 325
80107: NOT
80108: OR
80109: PUSH
80110: LD_EXP 54
80114: PUSH
80115: LD_VAR 0 2
80119: ARRAY
80120: OR
80121: IFFALSE 80125
// continue ;
80123: GO 80042
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
80125: LD_ADDR_VAR 0 8
80129: PUSH
80130: LD_EXP 31
80134: PUSH
80135: LD_VAR 0 2
80139: ARRAY
80140: PPUSH
80141: LD_INT 25
80143: PUSH
80144: LD_INT 4
80146: PUSH
80147: EMPTY
80148: LIST
80149: LIST
80150: PUSH
80151: LD_INT 50
80153: PUSH
80154: EMPTY
80155: LIST
80156: PUSH
80157: LD_INT 3
80159: PUSH
80160: LD_INT 60
80162: PUSH
80163: EMPTY
80164: LIST
80165: PUSH
80166: EMPTY
80167: LIST
80168: LIST
80169: PUSH
80170: EMPTY
80171: LIST
80172: LIST
80173: LIST
80174: PPUSH
80175: CALL_OW 72
80179: PUSH
80180: LD_EXP 35
80184: PUSH
80185: LD_VAR 0 2
80189: ARRAY
80190: DIFF
80191: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
80192: LD_ADDR_VAR 0 9
80196: PUSH
80197: LD_EXP 31
80201: PUSH
80202: LD_VAR 0 2
80206: ARRAY
80207: PPUSH
80208: LD_INT 2
80210: PUSH
80211: LD_INT 30
80213: PUSH
80214: LD_INT 0
80216: PUSH
80217: EMPTY
80218: LIST
80219: LIST
80220: PUSH
80221: LD_INT 30
80223: PUSH
80224: LD_INT 1
80226: PUSH
80227: EMPTY
80228: LIST
80229: LIST
80230: PUSH
80231: EMPTY
80232: LIST
80233: LIST
80234: LIST
80235: PPUSH
80236: CALL_OW 72
80240: ST_TO_ADDR
// if not tmp or not dep then
80241: LD_VAR 0 8
80245: NOT
80246: PUSH
80247: LD_VAR 0 9
80251: NOT
80252: OR
80253: IFFALSE 80257
// continue ;
80255: GO 80042
// side := GetSide ( tmp [ 1 ] ) ;
80257: LD_ADDR_VAR 0 11
80261: PUSH
80262: LD_VAR 0 8
80266: PUSH
80267: LD_INT 1
80269: ARRAY
80270: PPUSH
80271: CALL_OW 255
80275: ST_TO_ADDR
// dep := dep [ 1 ] ;
80276: LD_ADDR_VAR 0 9
80280: PUSH
80281: LD_VAR 0 9
80285: PUSH
80286: LD_INT 1
80288: ARRAY
80289: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
80290: LD_ADDR_VAR 0 7
80294: PUSH
80295: LD_EXP 59
80299: PUSH
80300: LD_VAR 0 2
80304: ARRAY
80305: PPUSH
80306: LD_INT 22
80308: PUSH
80309: LD_INT 0
80311: PUSH
80312: EMPTY
80313: LIST
80314: LIST
80315: PUSH
80316: LD_INT 25
80318: PUSH
80319: LD_INT 12
80321: PUSH
80322: EMPTY
80323: LIST
80324: LIST
80325: PUSH
80326: EMPTY
80327: LIST
80328: LIST
80329: PPUSH
80330: CALL_OW 70
80334: PUSH
80335: LD_INT 22
80337: PUSH
80338: LD_INT 0
80340: PUSH
80341: EMPTY
80342: LIST
80343: LIST
80344: PUSH
80345: LD_INT 25
80347: PUSH
80348: LD_INT 12
80350: PUSH
80351: EMPTY
80352: LIST
80353: LIST
80354: PUSH
80355: LD_INT 91
80357: PUSH
80358: LD_VAR 0 9
80362: PUSH
80363: LD_INT 20
80365: PUSH
80366: EMPTY
80367: LIST
80368: LIST
80369: LIST
80370: PUSH
80371: EMPTY
80372: LIST
80373: LIST
80374: LIST
80375: PPUSH
80376: CALL_OW 69
80380: UNION
80381: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
80382: LD_ADDR_VAR 0 10
80386: PUSH
80387: LD_EXP 59
80391: PUSH
80392: LD_VAR 0 2
80396: ARRAY
80397: PPUSH
80398: LD_INT 81
80400: PUSH
80401: LD_VAR 0 11
80405: PUSH
80406: EMPTY
80407: LIST
80408: LIST
80409: PPUSH
80410: CALL_OW 70
80414: ST_TO_ADDR
// if not apes or danger_at_area then
80415: LD_VAR 0 7
80419: NOT
80420: PUSH
80421: LD_VAR 0 10
80425: OR
80426: IFFALSE 80476
// begin if mc_taming [ i ] then
80428: LD_EXP 62
80432: PUSH
80433: LD_VAR 0 2
80437: ARRAY
80438: IFFALSE 80474
// begin MC_Reset ( i , 121 ) ;
80440: LD_VAR 0 2
80444: PPUSH
80445: LD_INT 121
80447: PPUSH
80448: CALL 65413 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
80452: LD_ADDR_EXP 62
80456: PUSH
80457: LD_EXP 62
80461: PPUSH
80462: LD_VAR 0 2
80466: PPUSH
80467: EMPTY
80468: PPUSH
80469: CALL_OW 1
80473: ST_TO_ADDR
// end ; continue ;
80474: GO 80042
// end ; for j in tmp do
80476: LD_ADDR_VAR 0 3
80480: PUSH
80481: LD_VAR 0 8
80485: PUSH
80486: FOR_IN
80487: IFFALSE 80823
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
80489: LD_VAR 0 3
80493: PUSH
80494: LD_EXP 62
80498: PUSH
80499: LD_VAR 0 2
80503: ARRAY
80504: IN
80505: NOT
80506: PUSH
80507: LD_EXP 62
80511: PUSH
80512: LD_VAR 0 2
80516: ARRAY
80517: PUSH
80518: LD_INT 3
80520: LESS
80521: AND
80522: IFFALSE 80580
// begin SetTag ( j , 121 ) ;
80524: LD_VAR 0 3
80528: PPUSH
80529: LD_INT 121
80531: PPUSH
80532: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
80536: LD_ADDR_EXP 62
80540: PUSH
80541: LD_EXP 62
80545: PPUSH
80546: LD_VAR 0 2
80550: PUSH
80551: LD_EXP 62
80555: PUSH
80556: LD_VAR 0 2
80560: ARRAY
80561: PUSH
80562: LD_INT 1
80564: PLUS
80565: PUSH
80566: EMPTY
80567: LIST
80568: LIST
80569: PPUSH
80570: LD_VAR 0 3
80574: PPUSH
80575: CALL 25021 0 3
80579: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
80580: LD_VAR 0 3
80584: PUSH
80585: LD_EXP 62
80589: PUSH
80590: LD_VAR 0 2
80594: ARRAY
80595: IN
80596: IFFALSE 80821
// begin if GetClass ( j ) <> 4 then
80598: LD_VAR 0 3
80602: PPUSH
80603: CALL_OW 257
80607: PUSH
80608: LD_INT 4
80610: NONEQUAL
80611: IFFALSE 80664
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
80613: LD_ADDR_EXP 62
80617: PUSH
80618: LD_EXP 62
80622: PPUSH
80623: LD_VAR 0 2
80627: PPUSH
80628: LD_EXP 62
80632: PUSH
80633: LD_VAR 0 2
80637: ARRAY
80638: PUSH
80639: LD_VAR 0 3
80643: DIFF
80644: PPUSH
80645: CALL_OW 1
80649: ST_TO_ADDR
// SetTag ( j , 0 ) ;
80650: LD_VAR 0 3
80654: PPUSH
80655: LD_INT 0
80657: PPUSH
80658: CALL_OW 109
// continue ;
80662: GO 80486
// end ; if IsInUnit ( j ) then
80664: LD_VAR 0 3
80668: PPUSH
80669: CALL_OW 310
80673: IFFALSE 80684
// ComExitBuilding ( j ) ;
80675: LD_VAR 0 3
80679: PPUSH
80680: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
80684: LD_ADDR_VAR 0 6
80688: PUSH
80689: LD_VAR 0 7
80693: PPUSH
80694: LD_VAR 0 3
80698: PPUSH
80699: CALL_OW 74
80703: ST_TO_ADDR
// if not ape then
80704: LD_VAR 0 6
80708: NOT
80709: IFFALSE 80713
// break ;
80711: GO 80823
// x := GetX ( ape ) ;
80713: LD_ADDR_VAR 0 4
80717: PUSH
80718: LD_VAR 0 6
80722: PPUSH
80723: CALL_OW 250
80727: ST_TO_ADDR
// y := GetY ( ape ) ;
80728: LD_ADDR_VAR 0 5
80732: PUSH
80733: LD_VAR 0 6
80737: PPUSH
80738: CALL_OW 251
80742: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
80743: LD_VAR 0 4
80747: PPUSH
80748: LD_VAR 0 5
80752: PPUSH
80753: CALL_OW 488
80757: NOT
80758: PUSH
80759: LD_VAR 0 11
80763: PPUSH
80764: LD_VAR 0 4
80768: PPUSH
80769: LD_VAR 0 5
80773: PPUSH
80774: LD_INT 20
80776: PPUSH
80777: CALL 25917 0 4
80781: PUSH
80782: LD_INT 4
80784: ARRAY
80785: OR
80786: IFFALSE 80790
// break ;
80788: GO 80823
// if not HasTask ( j ) then
80790: LD_VAR 0 3
80794: PPUSH
80795: CALL_OW 314
80799: NOT
80800: IFFALSE 80821
// ComTameXY ( j , x , y ) ;
80802: LD_VAR 0 3
80806: PPUSH
80807: LD_VAR 0 4
80811: PPUSH
80812: LD_VAR 0 5
80816: PPUSH
80817: CALL_OW 131
// end ; end ;
80821: GO 80486
80823: POP
80824: POP
// end ;
80825: GO 80042
80827: POP
80828: POP
// end ;
80829: LD_VAR 0 1
80833: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
80834: LD_INT 0
80836: PPUSH
80837: PPUSH
80838: PPUSH
80839: PPUSH
80840: PPUSH
80841: PPUSH
80842: PPUSH
80843: PPUSH
// if not mc_bases then
80844: LD_EXP 31
80848: NOT
80849: IFFALSE 80853
// exit ;
80851: GO 81479
// for i = 1 to mc_bases do
80853: LD_ADDR_VAR 0 2
80857: PUSH
80858: DOUBLE
80859: LD_INT 1
80861: DEC
80862: ST_TO_ADDR
80863: LD_EXP 31
80867: PUSH
80868: FOR_TO
80869: IFFALSE 81477
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
80871: LD_EXP 60
80875: PUSH
80876: LD_VAR 0 2
80880: ARRAY
80881: NOT
80882: PUSH
80883: LD_EXP 60
80887: PUSH
80888: LD_VAR 0 2
80892: ARRAY
80893: PPUSH
80894: LD_INT 25
80896: PUSH
80897: LD_INT 12
80899: PUSH
80900: EMPTY
80901: LIST
80902: LIST
80903: PPUSH
80904: CALL_OW 72
80908: NOT
80909: OR
80910: IFFALSE 80914
// continue ;
80912: GO 80868
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
80914: LD_ADDR_VAR 0 5
80918: PUSH
80919: LD_EXP 60
80923: PUSH
80924: LD_VAR 0 2
80928: ARRAY
80929: PUSH
80930: LD_INT 1
80932: ARRAY
80933: PPUSH
80934: CALL_OW 255
80938: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
80939: LD_VAR 0 5
80943: PPUSH
80944: LD_INT 2
80946: PPUSH
80947: CALL_OW 325
80951: IFFALSE 81204
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
80953: LD_ADDR_VAR 0 4
80957: PUSH
80958: LD_EXP 60
80962: PUSH
80963: LD_VAR 0 2
80967: ARRAY
80968: PPUSH
80969: LD_INT 25
80971: PUSH
80972: LD_INT 16
80974: PUSH
80975: EMPTY
80976: LIST
80977: LIST
80978: PPUSH
80979: CALL_OW 72
80983: ST_TO_ADDR
// if tmp < 6 then
80984: LD_VAR 0 4
80988: PUSH
80989: LD_INT 6
80991: LESS
80992: IFFALSE 81204
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
80994: LD_ADDR_VAR 0 6
80998: PUSH
80999: LD_EXP 31
81003: PUSH
81004: LD_VAR 0 2
81008: ARRAY
81009: PPUSH
81010: LD_INT 2
81012: PUSH
81013: LD_INT 30
81015: PUSH
81016: LD_INT 0
81018: PUSH
81019: EMPTY
81020: LIST
81021: LIST
81022: PUSH
81023: LD_INT 30
81025: PUSH
81026: LD_INT 1
81028: PUSH
81029: EMPTY
81030: LIST
81031: LIST
81032: PUSH
81033: EMPTY
81034: LIST
81035: LIST
81036: LIST
81037: PPUSH
81038: CALL_OW 72
81042: ST_TO_ADDR
// if depot then
81043: LD_VAR 0 6
81047: IFFALSE 81204
// begin selected := 0 ;
81049: LD_ADDR_VAR 0 7
81053: PUSH
81054: LD_INT 0
81056: ST_TO_ADDR
// for j in depot do
81057: LD_ADDR_VAR 0 3
81061: PUSH
81062: LD_VAR 0 6
81066: PUSH
81067: FOR_IN
81068: IFFALSE 81099
// begin if UnitsInside ( j ) < 6 then
81070: LD_VAR 0 3
81074: PPUSH
81075: CALL_OW 313
81079: PUSH
81080: LD_INT 6
81082: LESS
81083: IFFALSE 81097
// begin selected := j ;
81085: LD_ADDR_VAR 0 7
81089: PUSH
81090: LD_VAR 0 3
81094: ST_TO_ADDR
// break ;
81095: GO 81099
// end ; end ;
81097: GO 81067
81099: POP
81100: POP
// if selected then
81101: LD_VAR 0 7
81105: IFFALSE 81204
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
81107: LD_ADDR_VAR 0 3
81111: PUSH
81112: LD_EXP 60
81116: PUSH
81117: LD_VAR 0 2
81121: ARRAY
81122: PPUSH
81123: LD_INT 25
81125: PUSH
81126: LD_INT 12
81128: PUSH
81129: EMPTY
81130: LIST
81131: LIST
81132: PPUSH
81133: CALL_OW 72
81137: PUSH
81138: FOR_IN
81139: IFFALSE 81202
// if not HasTask ( j ) then
81141: LD_VAR 0 3
81145: PPUSH
81146: CALL_OW 314
81150: NOT
81151: IFFALSE 81200
// begin if not IsInUnit ( j ) then
81153: LD_VAR 0 3
81157: PPUSH
81158: CALL_OW 310
81162: NOT
81163: IFFALSE 81179
// ComEnterUnit ( j , selected ) ;
81165: LD_VAR 0 3
81169: PPUSH
81170: LD_VAR 0 7
81174: PPUSH
81175: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
81179: LD_VAR 0 3
81183: PPUSH
81184: LD_INT 16
81186: PPUSH
81187: CALL_OW 183
// AddComExitBuilding ( j ) ;
81191: LD_VAR 0 3
81195: PPUSH
81196: CALL_OW 182
// end ;
81200: GO 81138
81202: POP
81203: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
81204: LD_VAR 0 5
81208: PPUSH
81209: LD_INT 11
81211: PPUSH
81212: CALL_OW 325
81216: IFFALSE 81475
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
81218: LD_ADDR_VAR 0 4
81222: PUSH
81223: LD_EXP 60
81227: PUSH
81228: LD_VAR 0 2
81232: ARRAY
81233: PPUSH
81234: LD_INT 25
81236: PUSH
81237: LD_INT 16
81239: PUSH
81240: EMPTY
81241: LIST
81242: LIST
81243: PPUSH
81244: CALL_OW 72
81248: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
81249: LD_VAR 0 4
81253: PUSH
81254: LD_INT 6
81256: GREATEREQUAL
81257: PUSH
81258: LD_VAR 0 5
81262: PPUSH
81263: LD_INT 2
81265: PPUSH
81266: CALL_OW 325
81270: NOT
81271: OR
81272: IFFALSE 81475
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
81274: LD_ADDR_VAR 0 8
81278: PUSH
81279: LD_EXP 31
81283: PUSH
81284: LD_VAR 0 2
81288: ARRAY
81289: PPUSH
81290: LD_INT 2
81292: PUSH
81293: LD_INT 30
81295: PUSH
81296: LD_INT 4
81298: PUSH
81299: EMPTY
81300: LIST
81301: LIST
81302: PUSH
81303: LD_INT 30
81305: PUSH
81306: LD_INT 5
81308: PUSH
81309: EMPTY
81310: LIST
81311: LIST
81312: PUSH
81313: EMPTY
81314: LIST
81315: LIST
81316: LIST
81317: PPUSH
81318: CALL_OW 72
81322: ST_TO_ADDR
// if barracks then
81323: LD_VAR 0 8
81327: IFFALSE 81475
// begin selected := 0 ;
81329: LD_ADDR_VAR 0 7
81333: PUSH
81334: LD_INT 0
81336: ST_TO_ADDR
// for j in barracks do
81337: LD_ADDR_VAR 0 3
81341: PUSH
81342: LD_VAR 0 8
81346: PUSH
81347: FOR_IN
81348: IFFALSE 81379
// begin if UnitsInside ( j ) < 6 then
81350: LD_VAR 0 3
81354: PPUSH
81355: CALL_OW 313
81359: PUSH
81360: LD_INT 6
81362: LESS
81363: IFFALSE 81377
// begin selected := j ;
81365: LD_ADDR_VAR 0 7
81369: PUSH
81370: LD_VAR 0 3
81374: ST_TO_ADDR
// break ;
81375: GO 81379
// end ; end ;
81377: GO 81347
81379: POP
81380: POP
// if selected then
81381: LD_VAR 0 7
81385: IFFALSE 81475
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
81387: LD_ADDR_VAR 0 3
81391: PUSH
81392: LD_EXP 60
81396: PUSH
81397: LD_VAR 0 2
81401: ARRAY
81402: PPUSH
81403: LD_INT 25
81405: PUSH
81406: LD_INT 12
81408: PUSH
81409: EMPTY
81410: LIST
81411: LIST
81412: PPUSH
81413: CALL_OW 72
81417: PUSH
81418: FOR_IN
81419: IFFALSE 81473
// if not IsInUnit ( j ) and not HasTask ( j ) then
81421: LD_VAR 0 3
81425: PPUSH
81426: CALL_OW 310
81430: NOT
81431: PUSH
81432: LD_VAR 0 3
81436: PPUSH
81437: CALL_OW 314
81441: NOT
81442: AND
81443: IFFALSE 81471
// begin ComEnterUnit ( j , selected ) ;
81445: LD_VAR 0 3
81449: PPUSH
81450: LD_VAR 0 7
81454: PPUSH
81455: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
81459: LD_VAR 0 3
81463: PPUSH
81464: LD_INT 15
81466: PPUSH
81467: CALL_OW 183
// end ;
81471: GO 81418
81473: POP
81474: POP
// end ; end ; end ; end ; end ;
81475: GO 80868
81477: POP
81478: POP
// end ;
81479: LD_VAR 0 1
81483: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
81484: LD_INT 0
81486: PPUSH
81487: PPUSH
81488: PPUSH
81489: PPUSH
// if not mc_bases then
81490: LD_EXP 31
81494: NOT
81495: IFFALSE 81499
// exit ;
81497: GO 81677
// for i = 1 to mc_bases do
81499: LD_ADDR_VAR 0 2
81503: PUSH
81504: DOUBLE
81505: LD_INT 1
81507: DEC
81508: ST_TO_ADDR
81509: LD_EXP 31
81513: PUSH
81514: FOR_TO
81515: IFFALSE 81675
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
81517: LD_ADDR_VAR 0 4
81521: PUSH
81522: LD_EXP 31
81526: PUSH
81527: LD_VAR 0 2
81531: ARRAY
81532: PPUSH
81533: LD_INT 25
81535: PUSH
81536: LD_INT 9
81538: PUSH
81539: EMPTY
81540: LIST
81541: LIST
81542: PPUSH
81543: CALL_OW 72
81547: ST_TO_ADDR
// if not tmp then
81548: LD_VAR 0 4
81552: NOT
81553: IFFALSE 81557
// continue ;
81555: GO 81514
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
81557: LD_EXP 57
81561: PUSH
81562: LD_VAR 0 2
81566: ARRAY
81567: PPUSH
81568: LD_INT 29
81570: PPUSH
81571: CALL_OW 325
81575: NOT
81576: PUSH
81577: LD_EXP 57
81581: PUSH
81582: LD_VAR 0 2
81586: ARRAY
81587: PPUSH
81588: LD_INT 28
81590: PPUSH
81591: CALL_OW 325
81595: NOT
81596: AND
81597: IFFALSE 81601
// continue ;
81599: GO 81514
// for j in tmp do
81601: LD_ADDR_VAR 0 3
81605: PUSH
81606: LD_VAR 0 4
81610: PUSH
81611: FOR_IN
81612: IFFALSE 81671
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
81614: LD_VAR 0 3
81618: PUSH
81619: LD_EXP 34
81623: PUSH
81624: LD_VAR 0 2
81628: ARRAY
81629: PUSH
81630: LD_INT 1
81632: ARRAY
81633: IN
81634: NOT
81635: PUSH
81636: LD_VAR 0 3
81640: PUSH
81641: LD_EXP 34
81645: PUSH
81646: LD_VAR 0 2
81650: ARRAY
81651: PUSH
81652: LD_INT 2
81654: ARRAY
81655: IN
81656: NOT
81657: AND
81658: IFFALSE 81669
// ComSpaceTimeShoot ( j ) ;
81660: LD_VAR 0 3
81664: PPUSH
81665: CALL 20831 0 1
81669: GO 81611
81671: POP
81672: POP
// end ;
81673: GO 81514
81675: POP
81676: POP
// end ;
81677: LD_VAR 0 1
81681: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
81682: LD_INT 0
81684: PPUSH
81685: PPUSH
81686: PPUSH
81687: PPUSH
81688: PPUSH
81689: PPUSH
81690: PPUSH
81691: PPUSH
81692: PPUSH
// if not mc_bases then
81693: LD_EXP 31
81697: NOT
81698: IFFALSE 81702
// exit ;
81700: GO 82324
// for i = 1 to mc_bases do
81702: LD_ADDR_VAR 0 2
81706: PUSH
81707: DOUBLE
81708: LD_INT 1
81710: DEC
81711: ST_TO_ADDR
81712: LD_EXP 31
81716: PUSH
81717: FOR_TO
81718: IFFALSE 82322
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
81720: LD_EXP 66
81724: PUSH
81725: LD_VAR 0 2
81729: ARRAY
81730: NOT
81731: PUSH
81732: LD_INT 38
81734: PPUSH
81735: LD_EXP 57
81739: PUSH
81740: LD_VAR 0 2
81744: ARRAY
81745: PPUSH
81746: CALL_OW 321
81750: PUSH
81751: LD_INT 2
81753: NONEQUAL
81754: OR
81755: IFFALSE 81759
// continue ;
81757: GO 81717
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
81759: LD_ADDR_VAR 0 8
81763: PUSH
81764: LD_EXP 31
81768: PUSH
81769: LD_VAR 0 2
81773: ARRAY
81774: PPUSH
81775: LD_INT 30
81777: PUSH
81778: LD_INT 34
81780: PUSH
81781: EMPTY
81782: LIST
81783: LIST
81784: PPUSH
81785: CALL_OW 72
81789: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
81790: LD_ADDR_VAR 0 9
81794: PUSH
81795: LD_EXP 31
81799: PUSH
81800: LD_VAR 0 2
81804: ARRAY
81805: PPUSH
81806: LD_INT 25
81808: PUSH
81809: LD_INT 4
81811: PUSH
81812: EMPTY
81813: LIST
81814: LIST
81815: PPUSH
81816: CALL_OW 72
81820: PPUSH
81821: LD_INT 0
81823: PPUSH
81824: CALL 54907 0 2
81828: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
81829: LD_VAR 0 9
81833: NOT
81834: PUSH
81835: LD_VAR 0 8
81839: NOT
81840: OR
81841: PUSH
81842: LD_EXP 31
81846: PUSH
81847: LD_VAR 0 2
81851: ARRAY
81852: PPUSH
81853: LD_INT 124
81855: PPUSH
81856: CALL 54907 0 2
81860: OR
81861: IFFALSE 81865
// continue ;
81863: GO 81717
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
81865: LD_EXP 67
81869: PUSH
81870: LD_VAR 0 2
81874: ARRAY
81875: PUSH
81876: LD_EXP 66
81880: PUSH
81881: LD_VAR 0 2
81885: ARRAY
81886: LESS
81887: PUSH
81888: LD_EXP 67
81892: PUSH
81893: LD_VAR 0 2
81897: ARRAY
81898: PUSH
81899: LD_VAR 0 8
81903: LESS
81904: AND
81905: IFFALSE 82320
// begin tmp := sci [ 1 ] ;
81907: LD_ADDR_VAR 0 7
81911: PUSH
81912: LD_VAR 0 9
81916: PUSH
81917: LD_INT 1
81919: ARRAY
81920: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
81921: LD_VAR 0 7
81925: PPUSH
81926: LD_INT 124
81928: PPUSH
81929: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
81933: LD_ADDR_VAR 0 3
81937: PUSH
81938: DOUBLE
81939: LD_EXP 66
81943: PUSH
81944: LD_VAR 0 2
81948: ARRAY
81949: INC
81950: ST_TO_ADDR
81951: LD_EXP 66
81955: PUSH
81956: LD_VAR 0 2
81960: ARRAY
81961: PUSH
81962: FOR_DOWNTO
81963: IFFALSE 82306
// begin if IsInUnit ( tmp ) then
81965: LD_VAR 0 7
81969: PPUSH
81970: CALL_OW 310
81974: IFFALSE 81985
// ComExitBuilding ( tmp ) ;
81976: LD_VAR 0 7
81980: PPUSH
81981: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
81985: LD_INT 35
81987: PPUSH
81988: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
81992: LD_VAR 0 7
81996: PPUSH
81997: CALL_OW 310
82001: NOT
82002: PUSH
82003: LD_VAR 0 7
82007: PPUSH
82008: CALL_OW 314
82012: NOT
82013: AND
82014: IFFALSE 81985
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
82016: LD_ADDR_VAR 0 6
82020: PUSH
82021: LD_VAR 0 7
82025: PPUSH
82026: CALL_OW 250
82030: PUSH
82031: LD_VAR 0 7
82035: PPUSH
82036: CALL_OW 251
82040: PUSH
82041: EMPTY
82042: LIST
82043: LIST
82044: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
82045: LD_INT 35
82047: PPUSH
82048: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
82052: LD_ADDR_VAR 0 4
82056: PUSH
82057: LD_EXP 66
82061: PUSH
82062: LD_VAR 0 2
82066: ARRAY
82067: PUSH
82068: LD_VAR 0 3
82072: ARRAY
82073: PUSH
82074: LD_INT 1
82076: ARRAY
82077: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
82078: LD_ADDR_VAR 0 5
82082: PUSH
82083: LD_EXP 66
82087: PUSH
82088: LD_VAR 0 2
82092: ARRAY
82093: PUSH
82094: LD_VAR 0 3
82098: ARRAY
82099: PUSH
82100: LD_INT 2
82102: ARRAY
82103: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
82104: LD_VAR 0 7
82108: PPUSH
82109: LD_INT 10
82111: PPUSH
82112: CALL 27618 0 2
82116: PUSH
82117: LD_INT 4
82119: ARRAY
82120: IFFALSE 82158
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
82122: LD_VAR 0 7
82126: PPUSH
82127: LD_VAR 0 6
82131: PUSH
82132: LD_INT 1
82134: ARRAY
82135: PPUSH
82136: LD_VAR 0 6
82140: PUSH
82141: LD_INT 2
82143: ARRAY
82144: PPUSH
82145: CALL_OW 111
// wait ( 0 0$10 ) ;
82149: LD_INT 350
82151: PPUSH
82152: CALL_OW 67
// end else
82156: GO 82184
// begin ComMoveXY ( tmp , x , y ) ;
82158: LD_VAR 0 7
82162: PPUSH
82163: LD_VAR 0 4
82167: PPUSH
82168: LD_VAR 0 5
82172: PPUSH
82173: CALL_OW 111
// wait ( 0 0$3 ) ;
82177: LD_INT 105
82179: PPUSH
82180: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
82184: LD_VAR 0 7
82188: PPUSH
82189: LD_VAR 0 4
82193: PPUSH
82194: LD_VAR 0 5
82198: PPUSH
82199: CALL_OW 307
82203: IFFALSE 82045
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
82205: LD_VAR 0 7
82209: PPUSH
82210: LD_VAR 0 4
82214: PPUSH
82215: LD_VAR 0 5
82219: PPUSH
82220: LD_VAR 0 8
82224: PUSH
82225: LD_VAR 0 3
82229: ARRAY
82230: PPUSH
82231: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
82235: LD_INT 35
82237: PPUSH
82238: CALL_OW 67
// until not HasTask ( tmp ) ;
82242: LD_VAR 0 7
82246: PPUSH
82247: CALL_OW 314
82251: NOT
82252: IFFALSE 82235
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
82254: LD_ADDR_EXP 67
82258: PUSH
82259: LD_EXP 67
82263: PPUSH
82264: LD_VAR 0 2
82268: PUSH
82269: LD_EXP 67
82273: PUSH
82274: LD_VAR 0 2
82278: ARRAY
82279: PUSH
82280: LD_INT 1
82282: PLUS
82283: PUSH
82284: EMPTY
82285: LIST
82286: LIST
82287: PPUSH
82288: LD_VAR 0 8
82292: PUSH
82293: LD_VAR 0 3
82297: ARRAY
82298: PPUSH
82299: CALL 25021 0 3
82303: ST_TO_ADDR
// end ;
82304: GO 81962
82306: POP
82307: POP
// MC_Reset ( i , 124 ) ;
82308: LD_VAR 0 2
82312: PPUSH
82313: LD_INT 124
82315: PPUSH
82316: CALL 65413 0 2
// end ; end ;
82320: GO 81717
82322: POP
82323: POP
// end ;
82324: LD_VAR 0 1
82328: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
82329: LD_INT 0
82331: PPUSH
82332: PPUSH
82333: PPUSH
// if not mc_bases then
82334: LD_EXP 31
82338: NOT
82339: IFFALSE 82343
// exit ;
82341: GO 82949
// for i = 1 to mc_bases do
82343: LD_ADDR_VAR 0 2
82347: PUSH
82348: DOUBLE
82349: LD_INT 1
82351: DEC
82352: ST_TO_ADDR
82353: LD_EXP 31
82357: PUSH
82358: FOR_TO
82359: IFFALSE 82947
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
82361: LD_ADDR_VAR 0 3
82365: PUSH
82366: LD_EXP 31
82370: PUSH
82371: LD_VAR 0 2
82375: ARRAY
82376: PPUSH
82377: LD_INT 25
82379: PUSH
82380: LD_INT 4
82382: PUSH
82383: EMPTY
82384: LIST
82385: LIST
82386: PPUSH
82387: CALL_OW 72
82391: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
82392: LD_VAR 0 3
82396: NOT
82397: PUSH
82398: LD_EXP 68
82402: PUSH
82403: LD_VAR 0 2
82407: ARRAY
82408: NOT
82409: OR
82410: PUSH
82411: LD_EXP 31
82415: PUSH
82416: LD_VAR 0 2
82420: ARRAY
82421: PPUSH
82422: LD_INT 2
82424: PUSH
82425: LD_INT 30
82427: PUSH
82428: LD_INT 0
82430: PUSH
82431: EMPTY
82432: LIST
82433: LIST
82434: PUSH
82435: LD_INT 30
82437: PUSH
82438: LD_INT 1
82440: PUSH
82441: EMPTY
82442: LIST
82443: LIST
82444: PUSH
82445: EMPTY
82446: LIST
82447: LIST
82448: LIST
82449: PPUSH
82450: CALL_OW 72
82454: NOT
82455: OR
82456: IFFALSE 82506
// begin if mc_deposits_finder [ i ] then
82458: LD_EXP 69
82462: PUSH
82463: LD_VAR 0 2
82467: ARRAY
82468: IFFALSE 82504
// begin MC_Reset ( i , 125 ) ;
82470: LD_VAR 0 2
82474: PPUSH
82475: LD_INT 125
82477: PPUSH
82478: CALL 65413 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
82482: LD_ADDR_EXP 69
82486: PUSH
82487: LD_EXP 69
82491: PPUSH
82492: LD_VAR 0 2
82496: PPUSH
82497: EMPTY
82498: PPUSH
82499: CALL_OW 1
82503: ST_TO_ADDR
// end ; continue ;
82504: GO 82358
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
82506: LD_EXP 68
82510: PUSH
82511: LD_VAR 0 2
82515: ARRAY
82516: PUSH
82517: LD_INT 1
82519: ARRAY
82520: PUSH
82521: LD_INT 3
82523: ARRAY
82524: PUSH
82525: LD_INT 1
82527: EQUAL
82528: PUSH
82529: LD_INT 20
82531: PPUSH
82532: LD_EXP 57
82536: PUSH
82537: LD_VAR 0 2
82541: ARRAY
82542: PPUSH
82543: CALL_OW 321
82547: PUSH
82548: LD_INT 2
82550: NONEQUAL
82551: AND
82552: IFFALSE 82602
// begin if mc_deposits_finder [ i ] then
82554: LD_EXP 69
82558: PUSH
82559: LD_VAR 0 2
82563: ARRAY
82564: IFFALSE 82600
// begin MC_Reset ( i , 125 ) ;
82566: LD_VAR 0 2
82570: PPUSH
82571: LD_INT 125
82573: PPUSH
82574: CALL 65413 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
82578: LD_ADDR_EXP 69
82582: PUSH
82583: LD_EXP 69
82587: PPUSH
82588: LD_VAR 0 2
82592: PPUSH
82593: EMPTY
82594: PPUSH
82595: CALL_OW 1
82599: ST_TO_ADDR
// end ; continue ;
82600: GO 82358
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
82602: LD_EXP 68
82606: PUSH
82607: LD_VAR 0 2
82611: ARRAY
82612: PUSH
82613: LD_INT 1
82615: ARRAY
82616: PUSH
82617: LD_INT 1
82619: ARRAY
82620: PPUSH
82621: LD_EXP 68
82625: PUSH
82626: LD_VAR 0 2
82630: ARRAY
82631: PUSH
82632: LD_INT 1
82634: ARRAY
82635: PUSH
82636: LD_INT 2
82638: ARRAY
82639: PPUSH
82640: LD_EXP 57
82644: PUSH
82645: LD_VAR 0 2
82649: ARRAY
82650: PPUSH
82651: CALL_OW 440
82655: IFFALSE 82698
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
82657: LD_ADDR_EXP 68
82661: PUSH
82662: LD_EXP 68
82666: PPUSH
82667: LD_VAR 0 2
82671: PPUSH
82672: LD_EXP 68
82676: PUSH
82677: LD_VAR 0 2
82681: ARRAY
82682: PPUSH
82683: LD_INT 1
82685: PPUSH
82686: CALL_OW 3
82690: PPUSH
82691: CALL_OW 1
82695: ST_TO_ADDR
82696: GO 82945
// begin if not mc_deposits_finder [ i ] then
82698: LD_EXP 69
82702: PUSH
82703: LD_VAR 0 2
82707: ARRAY
82708: NOT
82709: IFFALSE 82761
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
82711: LD_ADDR_EXP 69
82715: PUSH
82716: LD_EXP 69
82720: PPUSH
82721: LD_VAR 0 2
82725: PPUSH
82726: LD_VAR 0 3
82730: PUSH
82731: LD_INT 1
82733: ARRAY
82734: PUSH
82735: EMPTY
82736: LIST
82737: PPUSH
82738: CALL_OW 1
82742: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
82743: LD_VAR 0 3
82747: PUSH
82748: LD_INT 1
82750: ARRAY
82751: PPUSH
82752: LD_INT 125
82754: PPUSH
82755: CALL_OW 109
// end else
82759: GO 82945
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
82761: LD_EXP 69
82765: PUSH
82766: LD_VAR 0 2
82770: ARRAY
82771: PUSH
82772: LD_INT 1
82774: ARRAY
82775: PPUSH
82776: CALL_OW 310
82780: IFFALSE 82803
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
82782: LD_EXP 69
82786: PUSH
82787: LD_VAR 0 2
82791: ARRAY
82792: PUSH
82793: LD_INT 1
82795: ARRAY
82796: PPUSH
82797: CALL_OW 122
82801: GO 82945
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
82803: LD_EXP 69
82807: PUSH
82808: LD_VAR 0 2
82812: ARRAY
82813: PUSH
82814: LD_INT 1
82816: ARRAY
82817: PPUSH
82818: CALL_OW 314
82822: NOT
82823: PUSH
82824: LD_EXP 69
82828: PUSH
82829: LD_VAR 0 2
82833: ARRAY
82834: PUSH
82835: LD_INT 1
82837: ARRAY
82838: PPUSH
82839: LD_EXP 68
82843: PUSH
82844: LD_VAR 0 2
82848: ARRAY
82849: PUSH
82850: LD_INT 1
82852: ARRAY
82853: PUSH
82854: LD_INT 1
82856: ARRAY
82857: PPUSH
82858: LD_EXP 68
82862: PUSH
82863: LD_VAR 0 2
82867: ARRAY
82868: PUSH
82869: LD_INT 1
82871: ARRAY
82872: PUSH
82873: LD_INT 2
82875: ARRAY
82876: PPUSH
82877: CALL_OW 297
82881: PUSH
82882: LD_INT 6
82884: GREATER
82885: AND
82886: IFFALSE 82945
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
82888: LD_EXP 69
82892: PUSH
82893: LD_VAR 0 2
82897: ARRAY
82898: PUSH
82899: LD_INT 1
82901: ARRAY
82902: PPUSH
82903: LD_EXP 68
82907: PUSH
82908: LD_VAR 0 2
82912: ARRAY
82913: PUSH
82914: LD_INT 1
82916: ARRAY
82917: PUSH
82918: LD_INT 1
82920: ARRAY
82921: PPUSH
82922: LD_EXP 68
82926: PUSH
82927: LD_VAR 0 2
82931: ARRAY
82932: PUSH
82933: LD_INT 1
82935: ARRAY
82936: PUSH
82937: LD_INT 2
82939: ARRAY
82940: PPUSH
82941: CALL_OW 111
// end ; end ; end ;
82945: GO 82358
82947: POP
82948: POP
// end ;
82949: LD_VAR 0 1
82953: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
82954: LD_INT 0
82956: PPUSH
82957: PPUSH
82958: PPUSH
82959: PPUSH
82960: PPUSH
82961: PPUSH
82962: PPUSH
82963: PPUSH
82964: PPUSH
82965: PPUSH
82966: PPUSH
// if not mc_bases then
82967: LD_EXP 31
82971: NOT
82972: IFFALSE 82976
// exit ;
82974: GO 83916
// for i = 1 to mc_bases do
82976: LD_ADDR_VAR 0 2
82980: PUSH
82981: DOUBLE
82982: LD_INT 1
82984: DEC
82985: ST_TO_ADDR
82986: LD_EXP 31
82990: PUSH
82991: FOR_TO
82992: IFFALSE 83914
// begin if not mc_bases [ i ] or mc_scan [ i ] then
82994: LD_EXP 31
82998: PUSH
82999: LD_VAR 0 2
83003: ARRAY
83004: NOT
83005: PUSH
83006: LD_EXP 54
83010: PUSH
83011: LD_VAR 0 2
83015: ARRAY
83016: OR
83017: IFFALSE 83021
// continue ;
83019: GO 82991
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
83021: LD_ADDR_VAR 0 7
83025: PUSH
83026: LD_EXP 31
83030: PUSH
83031: LD_VAR 0 2
83035: ARRAY
83036: PUSH
83037: LD_INT 1
83039: ARRAY
83040: PPUSH
83041: CALL_OW 248
83045: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
83046: LD_VAR 0 7
83050: PUSH
83051: LD_INT 3
83053: EQUAL
83054: PUSH
83055: LD_EXP 50
83059: PUSH
83060: LD_VAR 0 2
83064: ARRAY
83065: PUSH
83066: LD_EXP 53
83070: PUSH
83071: LD_VAR 0 2
83075: ARRAY
83076: UNION
83077: PPUSH
83078: LD_INT 33
83080: PUSH
83081: LD_INT 2
83083: PUSH
83084: EMPTY
83085: LIST
83086: LIST
83087: PPUSH
83088: CALL_OW 72
83092: NOT
83093: OR
83094: IFFALSE 83098
// continue ;
83096: GO 82991
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
83098: LD_ADDR_VAR 0 9
83102: PUSH
83103: LD_EXP 31
83107: PUSH
83108: LD_VAR 0 2
83112: ARRAY
83113: PPUSH
83114: LD_INT 30
83116: PUSH
83117: LD_INT 36
83119: PUSH
83120: EMPTY
83121: LIST
83122: LIST
83123: PPUSH
83124: CALL_OW 72
83128: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
83129: LD_ADDR_VAR 0 10
83133: PUSH
83134: LD_EXP 50
83138: PUSH
83139: LD_VAR 0 2
83143: ARRAY
83144: PPUSH
83145: LD_INT 34
83147: PUSH
83148: LD_INT 31
83150: PUSH
83151: EMPTY
83152: LIST
83153: LIST
83154: PPUSH
83155: CALL_OW 72
83159: ST_TO_ADDR
// if not cts and not mcts then
83160: LD_VAR 0 9
83164: NOT
83165: PUSH
83166: LD_VAR 0 10
83170: NOT
83171: AND
83172: IFFALSE 83176
// continue ;
83174: GO 82991
// x := cts ;
83176: LD_ADDR_VAR 0 11
83180: PUSH
83181: LD_VAR 0 9
83185: ST_TO_ADDR
// if not x then
83186: LD_VAR 0 11
83190: NOT
83191: IFFALSE 83203
// x := mcts ;
83193: LD_ADDR_VAR 0 11
83197: PUSH
83198: LD_VAR 0 10
83202: ST_TO_ADDR
// if not x then
83203: LD_VAR 0 11
83207: NOT
83208: IFFALSE 83212
// continue ;
83210: GO 82991
// if mc_remote_driver [ i ] then
83212: LD_EXP 71
83216: PUSH
83217: LD_VAR 0 2
83221: ARRAY
83222: IFFALSE 83609
// for j in mc_remote_driver [ i ] do
83224: LD_ADDR_VAR 0 3
83228: PUSH
83229: LD_EXP 71
83233: PUSH
83234: LD_VAR 0 2
83238: ARRAY
83239: PUSH
83240: FOR_IN
83241: IFFALSE 83607
// begin if GetClass ( j ) <> 3 then
83243: LD_VAR 0 3
83247: PPUSH
83248: CALL_OW 257
83252: PUSH
83253: LD_INT 3
83255: NONEQUAL
83256: IFFALSE 83309
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
83258: LD_ADDR_EXP 71
83262: PUSH
83263: LD_EXP 71
83267: PPUSH
83268: LD_VAR 0 2
83272: PPUSH
83273: LD_EXP 71
83277: PUSH
83278: LD_VAR 0 2
83282: ARRAY
83283: PUSH
83284: LD_VAR 0 3
83288: DIFF
83289: PPUSH
83290: CALL_OW 1
83294: ST_TO_ADDR
// SetTag ( j , 0 ) ;
83295: LD_VAR 0 3
83299: PPUSH
83300: LD_INT 0
83302: PPUSH
83303: CALL_OW 109
// continue ;
83307: GO 83240
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
83309: LD_EXP 50
83313: PUSH
83314: LD_VAR 0 2
83318: ARRAY
83319: PPUSH
83320: LD_INT 34
83322: PUSH
83323: LD_INT 31
83325: PUSH
83326: EMPTY
83327: LIST
83328: LIST
83329: PUSH
83330: LD_INT 58
83332: PUSH
83333: EMPTY
83334: LIST
83335: PUSH
83336: EMPTY
83337: LIST
83338: LIST
83339: PPUSH
83340: CALL_OW 72
83344: PUSH
83345: LD_VAR 0 3
83349: PPUSH
83350: CALL 54942 0 1
83354: NOT
83355: AND
83356: IFFALSE 83427
// begin if IsInUnit ( j ) then
83358: LD_VAR 0 3
83362: PPUSH
83363: CALL_OW 310
83367: IFFALSE 83378
// ComExitBuilding ( j ) ;
83369: LD_VAR 0 3
83373: PPUSH
83374: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
83378: LD_VAR 0 3
83382: PPUSH
83383: LD_EXP 50
83387: PUSH
83388: LD_VAR 0 2
83392: ARRAY
83393: PPUSH
83394: LD_INT 34
83396: PUSH
83397: LD_INT 31
83399: PUSH
83400: EMPTY
83401: LIST
83402: LIST
83403: PUSH
83404: LD_INT 58
83406: PUSH
83407: EMPTY
83408: LIST
83409: PUSH
83410: EMPTY
83411: LIST
83412: LIST
83413: PPUSH
83414: CALL_OW 72
83418: PUSH
83419: LD_INT 1
83421: ARRAY
83422: PPUSH
83423: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
83427: LD_VAR 0 3
83431: PPUSH
83432: CALL_OW 310
83436: NOT
83437: PUSH
83438: LD_VAR 0 3
83442: PPUSH
83443: CALL_OW 310
83447: PPUSH
83448: CALL_OW 266
83452: PUSH
83453: LD_INT 36
83455: NONEQUAL
83456: PUSH
83457: LD_VAR 0 3
83461: PPUSH
83462: CALL 54942 0 1
83466: NOT
83467: AND
83468: OR
83469: IFFALSE 83605
// begin if IsInUnit ( j ) then
83471: LD_VAR 0 3
83475: PPUSH
83476: CALL_OW 310
83480: IFFALSE 83491
// ComExitBuilding ( j ) ;
83482: LD_VAR 0 3
83486: PPUSH
83487: CALL_OW 122
// ct := 0 ;
83491: LD_ADDR_VAR 0 8
83495: PUSH
83496: LD_INT 0
83498: ST_TO_ADDR
// for k in x do
83499: LD_ADDR_VAR 0 4
83503: PUSH
83504: LD_VAR 0 11
83508: PUSH
83509: FOR_IN
83510: IFFALSE 83583
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
83512: LD_VAR 0 4
83516: PPUSH
83517: CALL_OW 264
83521: PUSH
83522: LD_INT 31
83524: EQUAL
83525: PUSH
83526: LD_VAR 0 4
83530: PPUSH
83531: CALL_OW 311
83535: NOT
83536: AND
83537: PUSH
83538: LD_VAR 0 4
83542: PPUSH
83543: CALL_OW 266
83547: PUSH
83548: LD_INT 36
83550: EQUAL
83551: PUSH
83552: LD_VAR 0 4
83556: PPUSH
83557: CALL_OW 313
83561: PUSH
83562: LD_INT 3
83564: LESS
83565: AND
83566: OR
83567: IFFALSE 83581
// begin ct := k ;
83569: LD_ADDR_VAR 0 8
83573: PUSH
83574: LD_VAR 0 4
83578: ST_TO_ADDR
// break ;
83579: GO 83583
// end ;
83581: GO 83509
83583: POP
83584: POP
// if ct then
83585: LD_VAR 0 8
83589: IFFALSE 83605
// ComEnterUnit ( j , ct ) ;
83591: LD_VAR 0 3
83595: PPUSH
83596: LD_VAR 0 8
83600: PPUSH
83601: CALL_OW 120
// end ; end ;
83605: GO 83240
83607: POP
83608: POP
// places := 0 ;
83609: LD_ADDR_VAR 0 5
83613: PUSH
83614: LD_INT 0
83616: ST_TO_ADDR
// for j = 1 to x do
83617: LD_ADDR_VAR 0 3
83621: PUSH
83622: DOUBLE
83623: LD_INT 1
83625: DEC
83626: ST_TO_ADDR
83627: LD_VAR 0 11
83631: PUSH
83632: FOR_TO
83633: IFFALSE 83709
// if GetWeapon ( x [ j ] ) = ar_control_tower then
83635: LD_VAR 0 11
83639: PUSH
83640: LD_VAR 0 3
83644: ARRAY
83645: PPUSH
83646: CALL_OW 264
83650: PUSH
83651: LD_INT 31
83653: EQUAL
83654: IFFALSE 83672
// places := places + 1 else
83656: LD_ADDR_VAR 0 5
83660: PUSH
83661: LD_VAR 0 5
83665: PUSH
83666: LD_INT 1
83668: PLUS
83669: ST_TO_ADDR
83670: GO 83707
// if GetBType ( x [ j ] ) = b_control_tower then
83672: LD_VAR 0 11
83676: PUSH
83677: LD_VAR 0 3
83681: ARRAY
83682: PPUSH
83683: CALL_OW 266
83687: PUSH
83688: LD_INT 36
83690: EQUAL
83691: IFFALSE 83707
// places := places + 3 ;
83693: LD_ADDR_VAR 0 5
83697: PUSH
83698: LD_VAR 0 5
83702: PUSH
83703: LD_INT 3
83705: PLUS
83706: ST_TO_ADDR
83707: GO 83632
83709: POP
83710: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
83711: LD_VAR 0 5
83715: PUSH
83716: LD_INT 0
83718: EQUAL
83719: PUSH
83720: LD_VAR 0 5
83724: PUSH
83725: LD_EXP 71
83729: PUSH
83730: LD_VAR 0 2
83734: ARRAY
83735: LESSEQUAL
83736: OR
83737: IFFALSE 83741
// continue ;
83739: GO 82991
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
83741: LD_ADDR_VAR 0 6
83745: PUSH
83746: LD_EXP 31
83750: PUSH
83751: LD_VAR 0 2
83755: ARRAY
83756: PPUSH
83757: LD_INT 25
83759: PUSH
83760: LD_INT 3
83762: PUSH
83763: EMPTY
83764: LIST
83765: LIST
83766: PPUSH
83767: CALL_OW 72
83771: PUSH
83772: LD_EXP 71
83776: PUSH
83777: LD_VAR 0 2
83781: ARRAY
83782: DIFF
83783: PPUSH
83784: LD_INT 3
83786: PPUSH
83787: CALL 55842 0 2
83791: ST_TO_ADDR
// for j in tmp do
83792: LD_ADDR_VAR 0 3
83796: PUSH
83797: LD_VAR 0 6
83801: PUSH
83802: FOR_IN
83803: IFFALSE 83838
// if GetTag ( j ) > 0 then
83805: LD_VAR 0 3
83809: PPUSH
83810: CALL_OW 110
83814: PUSH
83815: LD_INT 0
83817: GREATER
83818: IFFALSE 83836
// tmp := tmp diff j ;
83820: LD_ADDR_VAR 0 6
83824: PUSH
83825: LD_VAR 0 6
83829: PUSH
83830: LD_VAR 0 3
83834: DIFF
83835: ST_TO_ADDR
83836: GO 83802
83838: POP
83839: POP
// if not tmp then
83840: LD_VAR 0 6
83844: NOT
83845: IFFALSE 83849
// continue ;
83847: GO 82991
// if places then
83849: LD_VAR 0 5
83853: IFFALSE 83912
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
83855: LD_ADDR_EXP 71
83859: PUSH
83860: LD_EXP 71
83864: PPUSH
83865: LD_VAR 0 2
83869: PPUSH
83870: LD_EXP 71
83874: PUSH
83875: LD_VAR 0 2
83879: ARRAY
83880: PUSH
83881: LD_VAR 0 6
83885: PUSH
83886: LD_INT 1
83888: ARRAY
83889: UNION
83890: PPUSH
83891: CALL_OW 1
83895: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
83896: LD_VAR 0 6
83900: PUSH
83901: LD_INT 1
83903: ARRAY
83904: PPUSH
83905: LD_INT 126
83907: PPUSH
83908: CALL_OW 109
// end ; end ;
83912: GO 82991
83914: POP
83915: POP
// end ;
83916: LD_VAR 0 1
83920: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
83921: LD_INT 0
83923: PPUSH
83924: PPUSH
83925: PPUSH
83926: PPUSH
83927: PPUSH
83928: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
83929: LD_VAR 0 1
83933: NOT
83934: PUSH
83935: LD_VAR 0 2
83939: NOT
83940: OR
83941: PUSH
83942: LD_VAR 0 3
83946: NOT
83947: OR
83948: PUSH
83949: LD_VAR 0 4
83953: PUSH
83954: LD_INT 1
83956: PUSH
83957: LD_INT 2
83959: PUSH
83960: LD_INT 3
83962: PUSH
83963: LD_INT 4
83965: PUSH
83966: LD_INT 5
83968: PUSH
83969: LD_INT 8
83971: PUSH
83972: LD_INT 9
83974: PUSH
83975: LD_INT 15
83977: PUSH
83978: LD_INT 16
83980: PUSH
83981: EMPTY
83982: LIST
83983: LIST
83984: LIST
83985: LIST
83986: LIST
83987: LIST
83988: LIST
83989: LIST
83990: LIST
83991: IN
83992: NOT
83993: OR
83994: IFFALSE 83998
// exit ;
83996: GO 84898
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
83998: LD_ADDR_VAR 0 2
84002: PUSH
84003: LD_VAR 0 2
84007: PPUSH
84008: LD_INT 21
84010: PUSH
84011: LD_INT 3
84013: PUSH
84014: EMPTY
84015: LIST
84016: LIST
84017: PUSH
84018: LD_INT 24
84020: PUSH
84021: LD_INT 250
84023: PUSH
84024: EMPTY
84025: LIST
84026: LIST
84027: PUSH
84028: EMPTY
84029: LIST
84030: LIST
84031: PPUSH
84032: CALL_OW 72
84036: ST_TO_ADDR
// case class of 1 , 15 :
84037: LD_VAR 0 4
84041: PUSH
84042: LD_INT 1
84044: DOUBLE
84045: EQUAL
84046: IFTRUE 84056
84048: LD_INT 15
84050: DOUBLE
84051: EQUAL
84052: IFTRUE 84056
84054: GO 84141
84056: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
84057: LD_ADDR_VAR 0 8
84061: PUSH
84062: LD_VAR 0 2
84066: PPUSH
84067: LD_INT 2
84069: PUSH
84070: LD_INT 30
84072: PUSH
84073: LD_INT 32
84075: PUSH
84076: EMPTY
84077: LIST
84078: LIST
84079: PUSH
84080: LD_INT 30
84082: PUSH
84083: LD_INT 31
84085: PUSH
84086: EMPTY
84087: LIST
84088: LIST
84089: PUSH
84090: EMPTY
84091: LIST
84092: LIST
84093: LIST
84094: PPUSH
84095: CALL_OW 72
84099: PUSH
84100: LD_VAR 0 2
84104: PPUSH
84105: LD_INT 2
84107: PUSH
84108: LD_INT 30
84110: PUSH
84111: LD_INT 4
84113: PUSH
84114: EMPTY
84115: LIST
84116: LIST
84117: PUSH
84118: LD_INT 30
84120: PUSH
84121: LD_INT 5
84123: PUSH
84124: EMPTY
84125: LIST
84126: LIST
84127: PUSH
84128: EMPTY
84129: LIST
84130: LIST
84131: LIST
84132: PPUSH
84133: CALL_OW 72
84137: ADD
84138: ST_TO_ADDR
84139: GO 84387
84141: LD_INT 2
84143: DOUBLE
84144: EQUAL
84145: IFTRUE 84155
84147: LD_INT 16
84149: DOUBLE
84150: EQUAL
84151: IFTRUE 84155
84153: GO 84201
84155: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
84156: LD_ADDR_VAR 0 8
84160: PUSH
84161: LD_VAR 0 2
84165: PPUSH
84166: LD_INT 2
84168: PUSH
84169: LD_INT 30
84171: PUSH
84172: LD_INT 0
84174: PUSH
84175: EMPTY
84176: LIST
84177: LIST
84178: PUSH
84179: LD_INT 30
84181: PUSH
84182: LD_INT 1
84184: PUSH
84185: EMPTY
84186: LIST
84187: LIST
84188: PUSH
84189: EMPTY
84190: LIST
84191: LIST
84192: LIST
84193: PPUSH
84194: CALL_OW 72
84198: ST_TO_ADDR
84199: GO 84387
84201: LD_INT 3
84203: DOUBLE
84204: EQUAL
84205: IFTRUE 84209
84207: GO 84255
84209: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
84210: LD_ADDR_VAR 0 8
84214: PUSH
84215: LD_VAR 0 2
84219: PPUSH
84220: LD_INT 2
84222: PUSH
84223: LD_INT 30
84225: PUSH
84226: LD_INT 2
84228: PUSH
84229: EMPTY
84230: LIST
84231: LIST
84232: PUSH
84233: LD_INT 30
84235: PUSH
84236: LD_INT 3
84238: PUSH
84239: EMPTY
84240: LIST
84241: LIST
84242: PUSH
84243: EMPTY
84244: LIST
84245: LIST
84246: LIST
84247: PPUSH
84248: CALL_OW 72
84252: ST_TO_ADDR
84253: GO 84387
84255: LD_INT 4
84257: DOUBLE
84258: EQUAL
84259: IFTRUE 84263
84261: GO 84320
84263: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
84264: LD_ADDR_VAR 0 8
84268: PUSH
84269: LD_VAR 0 2
84273: PPUSH
84274: LD_INT 2
84276: PUSH
84277: LD_INT 30
84279: PUSH
84280: LD_INT 6
84282: PUSH
84283: EMPTY
84284: LIST
84285: LIST
84286: PUSH
84287: LD_INT 30
84289: PUSH
84290: LD_INT 7
84292: PUSH
84293: EMPTY
84294: LIST
84295: LIST
84296: PUSH
84297: LD_INT 30
84299: PUSH
84300: LD_INT 8
84302: PUSH
84303: EMPTY
84304: LIST
84305: LIST
84306: PUSH
84307: EMPTY
84308: LIST
84309: LIST
84310: LIST
84311: LIST
84312: PPUSH
84313: CALL_OW 72
84317: ST_TO_ADDR
84318: GO 84387
84320: LD_INT 5
84322: DOUBLE
84323: EQUAL
84324: IFTRUE 84340
84326: LD_INT 8
84328: DOUBLE
84329: EQUAL
84330: IFTRUE 84340
84332: LD_INT 9
84334: DOUBLE
84335: EQUAL
84336: IFTRUE 84340
84338: GO 84386
84340: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
84341: LD_ADDR_VAR 0 8
84345: PUSH
84346: LD_VAR 0 2
84350: PPUSH
84351: LD_INT 2
84353: PUSH
84354: LD_INT 30
84356: PUSH
84357: LD_INT 4
84359: PUSH
84360: EMPTY
84361: LIST
84362: LIST
84363: PUSH
84364: LD_INT 30
84366: PUSH
84367: LD_INT 5
84369: PUSH
84370: EMPTY
84371: LIST
84372: LIST
84373: PUSH
84374: EMPTY
84375: LIST
84376: LIST
84377: LIST
84378: PPUSH
84379: CALL_OW 72
84383: ST_TO_ADDR
84384: GO 84387
84386: POP
// if not tmp then
84387: LD_VAR 0 8
84391: NOT
84392: IFFALSE 84396
// exit ;
84394: GO 84898
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
84396: LD_VAR 0 4
84400: PUSH
84401: LD_INT 1
84403: PUSH
84404: LD_INT 15
84406: PUSH
84407: EMPTY
84408: LIST
84409: LIST
84410: IN
84411: PUSH
84412: LD_EXP 40
84416: PUSH
84417: LD_VAR 0 1
84421: ARRAY
84422: AND
84423: IFFALSE 84579
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
84425: LD_ADDR_VAR 0 9
84429: PUSH
84430: LD_EXP 40
84434: PUSH
84435: LD_VAR 0 1
84439: ARRAY
84440: PUSH
84441: LD_INT 1
84443: ARRAY
84444: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
84445: LD_VAR 0 9
84449: PUSH
84450: LD_EXP 41
84454: PUSH
84455: LD_VAR 0 1
84459: ARRAY
84460: IN
84461: NOT
84462: IFFALSE 84577
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
84464: LD_ADDR_EXP 41
84468: PUSH
84469: LD_EXP 41
84473: PPUSH
84474: LD_VAR 0 1
84478: PUSH
84479: LD_EXP 41
84483: PUSH
84484: LD_VAR 0 1
84488: ARRAY
84489: PUSH
84490: LD_INT 1
84492: PLUS
84493: PUSH
84494: EMPTY
84495: LIST
84496: LIST
84497: PPUSH
84498: LD_VAR 0 9
84502: PPUSH
84503: CALL 25021 0 3
84507: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
84508: LD_ADDR_EXP 40
84512: PUSH
84513: LD_EXP 40
84517: PPUSH
84518: LD_VAR 0 1
84522: PPUSH
84523: LD_EXP 40
84527: PUSH
84528: LD_VAR 0 1
84532: ARRAY
84533: PUSH
84534: LD_VAR 0 9
84538: DIFF
84539: PPUSH
84540: CALL_OW 1
84544: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
84545: LD_VAR 0 3
84549: PPUSH
84550: LD_EXP 41
84554: PUSH
84555: LD_VAR 0 1
84559: ARRAY
84560: PUSH
84561: LD_EXP 41
84565: PUSH
84566: LD_VAR 0 1
84570: ARRAY
84571: ARRAY
84572: PPUSH
84573: CALL_OW 120
// end ; exit ;
84577: GO 84898
// end ; if tmp > 1 then
84579: LD_VAR 0 8
84583: PUSH
84584: LD_INT 1
84586: GREATER
84587: IFFALSE 84691
// for i = 2 to tmp do
84589: LD_ADDR_VAR 0 6
84593: PUSH
84594: DOUBLE
84595: LD_INT 2
84597: DEC
84598: ST_TO_ADDR
84599: LD_VAR 0 8
84603: PUSH
84604: FOR_TO
84605: IFFALSE 84689
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
84607: LD_VAR 0 8
84611: PUSH
84612: LD_VAR 0 6
84616: ARRAY
84617: PPUSH
84618: CALL_OW 461
84622: PUSH
84623: LD_INT 6
84625: EQUAL
84626: IFFALSE 84687
// begin x := tmp [ i ] ;
84628: LD_ADDR_VAR 0 9
84632: PUSH
84633: LD_VAR 0 8
84637: PUSH
84638: LD_VAR 0 6
84642: ARRAY
84643: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
84644: LD_ADDR_VAR 0 8
84648: PUSH
84649: LD_VAR 0 8
84653: PPUSH
84654: LD_VAR 0 6
84658: PPUSH
84659: CALL_OW 3
84663: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
84664: LD_ADDR_VAR 0 8
84668: PUSH
84669: LD_VAR 0 8
84673: PPUSH
84674: LD_INT 1
84676: PPUSH
84677: LD_VAR 0 9
84681: PPUSH
84682: CALL_OW 2
84686: ST_TO_ADDR
// end ;
84687: GO 84604
84689: POP
84690: POP
// for i in tmp do
84691: LD_ADDR_VAR 0 6
84695: PUSH
84696: LD_VAR 0 8
84700: PUSH
84701: FOR_IN
84702: IFFALSE 84771
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
84704: LD_VAR 0 6
84708: PPUSH
84709: CALL_OW 313
84713: PUSH
84714: LD_INT 6
84716: LESS
84717: PUSH
84718: LD_VAR 0 6
84722: PPUSH
84723: CALL_OW 266
84727: PUSH
84728: LD_INT 31
84730: PUSH
84731: LD_INT 32
84733: PUSH
84734: EMPTY
84735: LIST
84736: LIST
84737: IN
84738: NOT
84739: AND
84740: PUSH
84741: LD_VAR 0 6
84745: PPUSH
84746: CALL_OW 313
84750: PUSH
84751: LD_INT 0
84753: EQUAL
84754: OR
84755: IFFALSE 84769
// begin j := i ;
84757: LD_ADDR_VAR 0 7
84761: PUSH
84762: LD_VAR 0 6
84766: ST_TO_ADDR
// break ;
84767: GO 84771
// end ; end ;
84769: GO 84701
84771: POP
84772: POP
// if j then
84773: LD_VAR 0 7
84777: IFFALSE 84795
// ComEnterUnit ( unit , j ) else
84779: LD_VAR 0 3
84783: PPUSH
84784: LD_VAR 0 7
84788: PPUSH
84789: CALL_OW 120
84793: GO 84898
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
84795: LD_ADDR_VAR 0 10
84799: PUSH
84800: LD_VAR 0 2
84804: PPUSH
84805: LD_INT 2
84807: PUSH
84808: LD_INT 30
84810: PUSH
84811: LD_INT 0
84813: PUSH
84814: EMPTY
84815: LIST
84816: LIST
84817: PUSH
84818: LD_INT 30
84820: PUSH
84821: LD_INT 1
84823: PUSH
84824: EMPTY
84825: LIST
84826: LIST
84827: PUSH
84828: EMPTY
84829: LIST
84830: LIST
84831: LIST
84832: PPUSH
84833: CALL_OW 72
84837: ST_TO_ADDR
// if depot then
84838: LD_VAR 0 10
84842: IFFALSE 84898
// begin depot := NearestUnitToUnit ( depot , unit ) ;
84844: LD_ADDR_VAR 0 10
84848: PUSH
84849: LD_VAR 0 10
84853: PPUSH
84854: LD_VAR 0 3
84858: PPUSH
84859: CALL_OW 74
84863: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
84864: LD_VAR 0 3
84868: PPUSH
84869: LD_VAR 0 10
84873: PPUSH
84874: CALL_OW 296
84878: PUSH
84879: LD_INT 10
84881: GREATER
84882: IFFALSE 84898
// ComStandNearbyBuilding ( unit , depot ) ;
84884: LD_VAR 0 3
84888: PPUSH
84889: LD_VAR 0 10
84893: PPUSH
84894: CALL 21448 0 2
// end ; end ; end ;
84898: LD_VAR 0 5
84902: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
84903: LD_INT 0
84905: PPUSH
84906: PPUSH
84907: PPUSH
84908: PPUSH
// if not mc_bases then
84909: LD_EXP 31
84913: NOT
84914: IFFALSE 84918
// exit ;
84916: GO 85157
// for i = 1 to mc_bases do
84918: LD_ADDR_VAR 0 2
84922: PUSH
84923: DOUBLE
84924: LD_INT 1
84926: DEC
84927: ST_TO_ADDR
84928: LD_EXP 31
84932: PUSH
84933: FOR_TO
84934: IFFALSE 85155
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
84936: LD_ADDR_VAR 0 4
84940: PUSH
84941: LD_EXP 31
84945: PUSH
84946: LD_VAR 0 2
84950: ARRAY
84951: PPUSH
84952: LD_INT 21
84954: PUSH
84955: LD_INT 1
84957: PUSH
84958: EMPTY
84959: LIST
84960: LIST
84961: PPUSH
84962: CALL_OW 72
84966: PUSH
84967: LD_EXP 60
84971: PUSH
84972: LD_VAR 0 2
84976: ARRAY
84977: UNION
84978: ST_TO_ADDR
// if not tmp then
84979: LD_VAR 0 4
84983: NOT
84984: IFFALSE 84988
// continue ;
84986: GO 84933
// for j in tmp do
84988: LD_ADDR_VAR 0 3
84992: PUSH
84993: LD_VAR 0 4
84997: PUSH
84998: FOR_IN
84999: IFFALSE 85151
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
85001: LD_VAR 0 3
85005: PPUSH
85006: CALL_OW 110
85010: NOT
85011: PUSH
85012: LD_VAR 0 3
85016: PPUSH
85017: CALL_OW 314
85021: NOT
85022: AND
85023: PUSH
85024: LD_VAR 0 3
85028: PPUSH
85029: CALL_OW 311
85033: NOT
85034: AND
85035: PUSH
85036: LD_VAR 0 3
85040: PPUSH
85041: CALL_OW 310
85045: NOT
85046: AND
85047: PUSH
85048: LD_VAR 0 3
85052: PUSH
85053: LD_EXP 34
85057: PUSH
85058: LD_VAR 0 2
85062: ARRAY
85063: PUSH
85064: LD_INT 1
85066: ARRAY
85067: IN
85068: NOT
85069: AND
85070: PUSH
85071: LD_VAR 0 3
85075: PUSH
85076: LD_EXP 34
85080: PUSH
85081: LD_VAR 0 2
85085: ARRAY
85086: PUSH
85087: LD_INT 2
85089: ARRAY
85090: IN
85091: NOT
85092: AND
85093: PUSH
85094: LD_VAR 0 3
85098: PUSH
85099: LD_EXP 43
85103: PUSH
85104: LD_VAR 0 2
85108: ARRAY
85109: IN
85110: NOT
85111: AND
85112: IFFALSE 85149
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
85114: LD_VAR 0 2
85118: PPUSH
85119: LD_EXP 31
85123: PUSH
85124: LD_VAR 0 2
85128: ARRAY
85129: PPUSH
85130: LD_VAR 0 3
85134: PPUSH
85135: LD_VAR 0 3
85139: PPUSH
85140: CALL_OW 257
85144: PPUSH
85145: CALL 83921 0 4
// end ;
85149: GO 84998
85151: POP
85152: POP
// end ;
85153: GO 84933
85155: POP
85156: POP
// end ;
85157: LD_VAR 0 1
85161: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
85162: LD_INT 0
85164: PPUSH
85165: PPUSH
85166: PPUSH
85167: PPUSH
85168: PPUSH
85169: PPUSH
// if not mc_bases [ base ] then
85170: LD_EXP 31
85174: PUSH
85175: LD_VAR 0 1
85179: ARRAY
85180: NOT
85181: IFFALSE 85185
// exit ;
85183: GO 85367
// tmp := [ ] ;
85185: LD_ADDR_VAR 0 6
85189: PUSH
85190: EMPTY
85191: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
85192: LD_ADDR_VAR 0 7
85196: PUSH
85197: LD_VAR 0 3
85201: PPUSH
85202: LD_INT 0
85204: PPUSH
85205: CALL_OW 517
85209: ST_TO_ADDR
// if not list then
85210: LD_VAR 0 7
85214: NOT
85215: IFFALSE 85219
// exit ;
85217: GO 85367
// for i = 1 to amount do
85219: LD_ADDR_VAR 0 5
85223: PUSH
85224: DOUBLE
85225: LD_INT 1
85227: DEC
85228: ST_TO_ADDR
85229: LD_VAR 0 2
85233: PUSH
85234: FOR_TO
85235: IFFALSE 85315
// begin x := rand ( 1 , list [ 1 ] ) ;
85237: LD_ADDR_VAR 0 8
85241: PUSH
85242: LD_INT 1
85244: PPUSH
85245: LD_VAR 0 7
85249: PUSH
85250: LD_INT 1
85252: ARRAY
85253: PPUSH
85254: CALL_OW 12
85258: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
85259: LD_ADDR_VAR 0 6
85263: PUSH
85264: LD_VAR 0 6
85268: PPUSH
85269: LD_VAR 0 5
85273: PPUSH
85274: LD_VAR 0 7
85278: PUSH
85279: LD_INT 1
85281: ARRAY
85282: PUSH
85283: LD_VAR 0 8
85287: ARRAY
85288: PUSH
85289: LD_VAR 0 7
85293: PUSH
85294: LD_INT 2
85296: ARRAY
85297: PUSH
85298: LD_VAR 0 8
85302: ARRAY
85303: PUSH
85304: EMPTY
85305: LIST
85306: LIST
85307: PPUSH
85308: CALL_OW 1
85312: ST_TO_ADDR
// end ;
85313: GO 85234
85315: POP
85316: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
85317: LD_ADDR_EXP 44
85321: PUSH
85322: LD_EXP 44
85326: PPUSH
85327: LD_VAR 0 1
85331: PPUSH
85332: LD_VAR 0 6
85336: PPUSH
85337: CALL_OW 1
85341: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
85342: LD_ADDR_EXP 46
85346: PUSH
85347: LD_EXP 46
85351: PPUSH
85352: LD_VAR 0 1
85356: PPUSH
85357: LD_VAR 0 3
85361: PPUSH
85362: CALL_OW 1
85366: ST_TO_ADDR
// end ;
85367: LD_VAR 0 4
85371: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
85372: LD_INT 0
85374: PPUSH
// if not mc_bases [ base ] then
85375: LD_EXP 31
85379: PUSH
85380: LD_VAR 0 1
85384: ARRAY
85385: NOT
85386: IFFALSE 85390
// exit ;
85388: GO 85415
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
85390: LD_ADDR_EXP 36
85394: PUSH
85395: LD_EXP 36
85399: PPUSH
85400: LD_VAR 0 1
85404: PPUSH
85405: LD_VAR 0 2
85409: PPUSH
85410: CALL_OW 1
85414: ST_TO_ADDR
// end ;
85415: LD_VAR 0 3
85419: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
85420: LD_INT 0
85422: PPUSH
// if not mc_bases [ base ] then
85423: LD_EXP 31
85427: PUSH
85428: LD_VAR 0 1
85432: ARRAY
85433: NOT
85434: IFFALSE 85438
// exit ;
85436: GO 85475
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
85438: LD_ADDR_EXP 36
85442: PUSH
85443: LD_EXP 36
85447: PPUSH
85448: LD_VAR 0 1
85452: PPUSH
85453: LD_EXP 36
85457: PUSH
85458: LD_VAR 0 1
85462: ARRAY
85463: PUSH
85464: LD_VAR 0 2
85468: UNION
85469: PPUSH
85470: CALL_OW 1
85474: ST_TO_ADDR
// end ;
85475: LD_VAR 0 3
85479: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
85480: LD_INT 0
85482: PPUSH
// if not mc_bases [ base ] then
85483: LD_EXP 31
85487: PUSH
85488: LD_VAR 0 1
85492: ARRAY
85493: NOT
85494: IFFALSE 85498
// exit ;
85496: GO 85523
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
85498: LD_ADDR_EXP 52
85502: PUSH
85503: LD_EXP 52
85507: PPUSH
85508: LD_VAR 0 1
85512: PPUSH
85513: LD_VAR 0 2
85517: PPUSH
85518: CALL_OW 1
85522: ST_TO_ADDR
// end ;
85523: LD_VAR 0 3
85527: RET
// export function MC_InsertProduceList ( base , components ) ; begin
85528: LD_INT 0
85530: PPUSH
// if not mc_bases [ base ] then
85531: LD_EXP 31
85535: PUSH
85536: LD_VAR 0 1
85540: ARRAY
85541: NOT
85542: IFFALSE 85546
// exit ;
85544: GO 85583
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
85546: LD_ADDR_EXP 52
85550: PUSH
85551: LD_EXP 52
85555: PPUSH
85556: LD_VAR 0 1
85560: PPUSH
85561: LD_EXP 52
85565: PUSH
85566: LD_VAR 0 1
85570: ARRAY
85571: PUSH
85572: LD_VAR 0 2
85576: ADD
85577: PPUSH
85578: CALL_OW 1
85582: ST_TO_ADDR
// end ;
85583: LD_VAR 0 3
85587: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
85588: LD_INT 0
85590: PPUSH
// if not mc_bases [ base ] then
85591: LD_EXP 31
85595: PUSH
85596: LD_VAR 0 1
85600: ARRAY
85601: NOT
85602: IFFALSE 85606
// exit ;
85604: GO 85660
// mc_defender := Replace ( mc_defender , base , deflist ) ;
85606: LD_ADDR_EXP 53
85610: PUSH
85611: LD_EXP 53
85615: PPUSH
85616: LD_VAR 0 1
85620: PPUSH
85621: LD_VAR 0 2
85625: PPUSH
85626: CALL_OW 1
85630: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
85631: LD_ADDR_EXP 42
85635: PUSH
85636: LD_EXP 42
85640: PPUSH
85641: LD_VAR 0 1
85645: PPUSH
85646: LD_VAR 0 2
85650: PUSH
85651: LD_INT 0
85653: PLUS
85654: PPUSH
85655: CALL_OW 1
85659: ST_TO_ADDR
// end ;
85660: LD_VAR 0 3
85664: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
85665: LD_INT 0
85667: PPUSH
// if not mc_bases [ base ] then
85668: LD_EXP 31
85672: PUSH
85673: LD_VAR 0 1
85677: ARRAY
85678: NOT
85679: IFFALSE 85683
// exit ;
85681: GO 85708
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
85683: LD_ADDR_EXP 42
85687: PUSH
85688: LD_EXP 42
85692: PPUSH
85693: LD_VAR 0 1
85697: PPUSH
85698: LD_VAR 0 2
85702: PPUSH
85703: CALL_OW 1
85707: ST_TO_ADDR
// end ;
85708: LD_VAR 0 3
85712: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
85713: LD_INT 0
85715: PPUSH
85716: PPUSH
85717: PPUSH
85718: PPUSH
// if not mc_bases [ base ] then
85719: LD_EXP 31
85723: PUSH
85724: LD_VAR 0 1
85728: ARRAY
85729: NOT
85730: IFFALSE 85734
// exit ;
85732: GO 85799
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
85734: LD_ADDR_EXP 51
85738: PUSH
85739: LD_EXP 51
85743: PPUSH
85744: LD_VAR 0 1
85748: PUSH
85749: LD_EXP 51
85753: PUSH
85754: LD_VAR 0 1
85758: ARRAY
85759: PUSH
85760: LD_INT 1
85762: PLUS
85763: PUSH
85764: EMPTY
85765: LIST
85766: LIST
85767: PPUSH
85768: LD_VAR 0 1
85772: PUSH
85773: LD_VAR 0 2
85777: PUSH
85778: LD_VAR 0 3
85782: PUSH
85783: LD_VAR 0 4
85787: PUSH
85788: EMPTY
85789: LIST
85790: LIST
85791: LIST
85792: LIST
85793: PPUSH
85794: CALL 25021 0 3
85798: ST_TO_ADDR
// end ;
85799: LD_VAR 0 5
85803: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
85804: LD_INT 0
85806: PPUSH
// if not mc_bases [ base ] then
85807: LD_EXP 31
85811: PUSH
85812: LD_VAR 0 1
85816: ARRAY
85817: NOT
85818: IFFALSE 85822
// exit ;
85820: GO 85847
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
85822: LD_ADDR_EXP 68
85826: PUSH
85827: LD_EXP 68
85831: PPUSH
85832: LD_VAR 0 1
85836: PPUSH
85837: LD_VAR 0 2
85841: PPUSH
85842: CALL_OW 1
85846: ST_TO_ADDR
// end ;
85847: LD_VAR 0 3
85851: RET
// export function MC_GetMinesField ( base ) ; begin
85852: LD_INT 0
85854: PPUSH
// result := mc_mines [ base ] ;
85855: LD_ADDR_VAR 0 2
85859: PUSH
85860: LD_EXP 44
85864: PUSH
85865: LD_VAR 0 1
85869: ARRAY
85870: ST_TO_ADDR
// end ;
85871: LD_VAR 0 2
85875: RET
// export function MC_GetProduceList ( base ) ; begin
85876: LD_INT 0
85878: PPUSH
// result := mc_produce [ base ] ;
85879: LD_ADDR_VAR 0 2
85883: PUSH
85884: LD_EXP 52
85888: PUSH
85889: LD_VAR 0 1
85893: ARRAY
85894: ST_TO_ADDR
// end ;
85895: LD_VAR 0 2
85899: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
85900: LD_INT 0
85902: PPUSH
85903: PPUSH
// if not mc_bases then
85904: LD_EXP 31
85908: NOT
85909: IFFALSE 85913
// exit ;
85911: GO 85978
// if mc_bases [ base ] then
85913: LD_EXP 31
85917: PUSH
85918: LD_VAR 0 1
85922: ARRAY
85923: IFFALSE 85978
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
85925: LD_ADDR_VAR 0 3
85929: PUSH
85930: LD_EXP 31
85934: PUSH
85935: LD_VAR 0 1
85939: ARRAY
85940: PPUSH
85941: LD_INT 30
85943: PUSH
85944: LD_VAR 0 2
85948: PUSH
85949: EMPTY
85950: LIST
85951: LIST
85952: PPUSH
85953: CALL_OW 72
85957: ST_TO_ADDR
// if result then
85958: LD_VAR 0 3
85962: IFFALSE 85978
// result := result [ 1 ] ;
85964: LD_ADDR_VAR 0 3
85968: PUSH
85969: LD_VAR 0 3
85973: PUSH
85974: LD_INT 1
85976: ARRAY
85977: ST_TO_ADDR
// end ; end ;
85978: LD_VAR 0 3
85982: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
85983: LD_INT 0
85985: PPUSH
85986: PPUSH
// if not mc_bases then
85987: LD_EXP 31
85991: NOT
85992: IFFALSE 85996
// exit ;
85994: GO 86041
// if mc_bases [ base ] then
85996: LD_EXP 31
86000: PUSH
86001: LD_VAR 0 1
86005: ARRAY
86006: IFFALSE 86041
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
86008: LD_ADDR_VAR 0 3
86012: PUSH
86013: LD_EXP 31
86017: PUSH
86018: LD_VAR 0 1
86022: ARRAY
86023: PPUSH
86024: LD_INT 30
86026: PUSH
86027: LD_VAR 0 2
86031: PUSH
86032: EMPTY
86033: LIST
86034: LIST
86035: PPUSH
86036: CALL_OW 72
86040: ST_TO_ADDR
// end ;
86041: LD_VAR 0 3
86045: RET
// export function MC_SetTame ( base , area ) ; begin
86046: LD_INT 0
86048: PPUSH
// if not mc_bases or not base then
86049: LD_EXP 31
86053: NOT
86054: PUSH
86055: LD_VAR 0 1
86059: NOT
86060: OR
86061: IFFALSE 86065
// exit ;
86063: GO 86090
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
86065: LD_ADDR_EXP 59
86069: PUSH
86070: LD_EXP 59
86074: PPUSH
86075: LD_VAR 0 1
86079: PPUSH
86080: LD_VAR 0 2
86084: PPUSH
86085: CALL_OW 1
86089: ST_TO_ADDR
// end ;
86090: LD_VAR 0 3
86094: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
86095: LD_INT 0
86097: PPUSH
86098: PPUSH
// if not mc_bases or not base then
86099: LD_EXP 31
86103: NOT
86104: PUSH
86105: LD_VAR 0 1
86109: NOT
86110: OR
86111: IFFALSE 86115
// exit ;
86113: GO 86217
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
86115: LD_ADDR_VAR 0 4
86119: PUSH
86120: LD_EXP 31
86124: PUSH
86125: LD_VAR 0 1
86129: ARRAY
86130: PPUSH
86131: LD_INT 30
86133: PUSH
86134: LD_VAR 0 2
86138: PUSH
86139: EMPTY
86140: LIST
86141: LIST
86142: PPUSH
86143: CALL_OW 72
86147: ST_TO_ADDR
// if not tmp then
86148: LD_VAR 0 4
86152: NOT
86153: IFFALSE 86157
// exit ;
86155: GO 86217
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
86157: LD_ADDR_EXP 63
86161: PUSH
86162: LD_EXP 63
86166: PPUSH
86167: LD_VAR 0 1
86171: PPUSH
86172: LD_EXP 63
86176: PUSH
86177: LD_VAR 0 1
86181: ARRAY
86182: PPUSH
86183: LD_EXP 63
86187: PUSH
86188: LD_VAR 0 1
86192: ARRAY
86193: PUSH
86194: LD_INT 1
86196: PLUS
86197: PPUSH
86198: LD_VAR 0 4
86202: PUSH
86203: LD_INT 1
86205: ARRAY
86206: PPUSH
86207: CALL_OW 2
86211: PPUSH
86212: CALL_OW 1
86216: ST_TO_ADDR
// end ;
86217: LD_VAR 0 3
86221: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
86222: LD_INT 0
86224: PPUSH
86225: PPUSH
// if not mc_bases or not base or not kinds then
86226: LD_EXP 31
86230: NOT
86231: PUSH
86232: LD_VAR 0 1
86236: NOT
86237: OR
86238: PUSH
86239: LD_VAR 0 2
86243: NOT
86244: OR
86245: IFFALSE 86249
// exit ;
86247: GO 86310
// for i in kinds do
86249: LD_ADDR_VAR 0 4
86253: PUSH
86254: LD_VAR 0 2
86258: PUSH
86259: FOR_IN
86260: IFFALSE 86308
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
86262: LD_ADDR_EXP 65
86266: PUSH
86267: LD_EXP 65
86271: PPUSH
86272: LD_VAR 0 1
86276: PUSH
86277: LD_EXP 65
86281: PUSH
86282: LD_VAR 0 1
86286: ARRAY
86287: PUSH
86288: LD_INT 1
86290: PLUS
86291: PUSH
86292: EMPTY
86293: LIST
86294: LIST
86295: PPUSH
86296: LD_VAR 0 4
86300: PPUSH
86301: CALL 25021 0 3
86305: ST_TO_ADDR
86306: GO 86259
86308: POP
86309: POP
// end ;
86310: LD_VAR 0 3
86314: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
86315: LD_INT 0
86317: PPUSH
// if not mc_bases or not base or not areas then
86318: LD_EXP 31
86322: NOT
86323: PUSH
86324: LD_VAR 0 1
86328: NOT
86329: OR
86330: PUSH
86331: LD_VAR 0 2
86335: NOT
86336: OR
86337: IFFALSE 86341
// exit ;
86339: GO 86366
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
86341: LD_ADDR_EXP 49
86345: PUSH
86346: LD_EXP 49
86350: PPUSH
86351: LD_VAR 0 1
86355: PPUSH
86356: LD_VAR 0 2
86360: PPUSH
86361: CALL_OW 1
86365: ST_TO_ADDR
// end ;
86366: LD_VAR 0 3
86370: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
86371: LD_INT 0
86373: PPUSH
// if not mc_bases or not base or not teleports_exit then
86374: LD_EXP 31
86378: NOT
86379: PUSH
86380: LD_VAR 0 1
86384: NOT
86385: OR
86386: PUSH
86387: LD_VAR 0 2
86391: NOT
86392: OR
86393: IFFALSE 86397
// exit ;
86395: GO 86422
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
86397: LD_ADDR_EXP 66
86401: PUSH
86402: LD_EXP 66
86406: PPUSH
86407: LD_VAR 0 1
86411: PPUSH
86412: LD_VAR 0 2
86416: PPUSH
86417: CALL_OW 1
86421: ST_TO_ADDR
// end ;
86422: LD_VAR 0 3
86426: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
86427: LD_INT 0
86429: PPUSH
86430: PPUSH
86431: PPUSH
// if not mc_bases or not base or not ext_list then
86432: LD_EXP 31
86436: NOT
86437: PUSH
86438: LD_VAR 0 1
86442: NOT
86443: OR
86444: PUSH
86445: LD_VAR 0 5
86449: NOT
86450: OR
86451: IFFALSE 86455
// exit ;
86453: GO 86628
// tmp := GetFacExtXYD ( x , y , d ) ;
86455: LD_ADDR_VAR 0 8
86459: PUSH
86460: LD_VAR 0 2
86464: PPUSH
86465: LD_VAR 0 3
86469: PPUSH
86470: LD_VAR 0 4
86474: PPUSH
86475: CALL 54972 0 3
86479: ST_TO_ADDR
// if not tmp then
86480: LD_VAR 0 8
86484: NOT
86485: IFFALSE 86489
// exit ;
86487: GO 86628
// for i in tmp do
86489: LD_ADDR_VAR 0 7
86493: PUSH
86494: LD_VAR 0 8
86498: PUSH
86499: FOR_IN
86500: IFFALSE 86626
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
86502: LD_ADDR_EXP 36
86506: PUSH
86507: LD_EXP 36
86511: PPUSH
86512: LD_VAR 0 1
86516: PPUSH
86517: LD_EXP 36
86521: PUSH
86522: LD_VAR 0 1
86526: ARRAY
86527: PPUSH
86528: LD_EXP 36
86532: PUSH
86533: LD_VAR 0 1
86537: ARRAY
86538: PUSH
86539: LD_INT 1
86541: PLUS
86542: PPUSH
86543: LD_VAR 0 5
86547: PUSH
86548: LD_INT 1
86550: ARRAY
86551: PUSH
86552: LD_VAR 0 7
86556: PUSH
86557: LD_INT 1
86559: ARRAY
86560: PUSH
86561: LD_VAR 0 7
86565: PUSH
86566: LD_INT 2
86568: ARRAY
86569: PUSH
86570: LD_VAR 0 7
86574: PUSH
86575: LD_INT 3
86577: ARRAY
86578: PUSH
86579: EMPTY
86580: LIST
86581: LIST
86582: LIST
86583: LIST
86584: PPUSH
86585: CALL_OW 2
86589: PPUSH
86590: CALL_OW 1
86594: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
86595: LD_ADDR_VAR 0 5
86599: PUSH
86600: LD_VAR 0 5
86604: PPUSH
86605: LD_INT 1
86607: PPUSH
86608: CALL_OW 3
86612: ST_TO_ADDR
// if not ext_list then
86613: LD_VAR 0 5
86617: NOT
86618: IFFALSE 86624
// exit ;
86620: POP
86621: POP
86622: GO 86628
// end ;
86624: GO 86499
86626: POP
86627: POP
// end ;
86628: LD_VAR 0 6
86632: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
86633: LD_INT 0
86635: PPUSH
// if not mc_bases or not base or not weapon_list then
86636: LD_EXP 31
86640: NOT
86641: PUSH
86642: LD_VAR 0 1
86646: NOT
86647: OR
86648: PUSH
86649: LD_VAR 0 2
86653: NOT
86654: OR
86655: IFFALSE 86659
// exit ;
86657: GO 86684
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
86659: LD_ADDR_EXP 70
86663: PUSH
86664: LD_EXP 70
86668: PPUSH
86669: LD_VAR 0 1
86673: PPUSH
86674: LD_VAR 0 2
86678: PPUSH
86679: CALL_OW 1
86683: ST_TO_ADDR
// end ;
86684: LD_VAR 0 3
86688: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
86689: LD_INT 0
86691: PPUSH
// if not mc_bases or not base or not tech_list then
86692: LD_EXP 31
86696: NOT
86697: PUSH
86698: LD_VAR 0 1
86702: NOT
86703: OR
86704: PUSH
86705: LD_VAR 0 2
86709: NOT
86710: OR
86711: IFFALSE 86715
// exit ;
86713: GO 86740
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
86715: LD_ADDR_EXP 58
86719: PUSH
86720: LD_EXP 58
86724: PPUSH
86725: LD_VAR 0 1
86729: PPUSH
86730: LD_VAR 0 2
86734: PPUSH
86735: CALL_OW 1
86739: ST_TO_ADDR
// end ;
86740: LD_VAR 0 3
86744: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
86745: LD_INT 0
86747: PPUSH
// if not mc_bases or not parking_area or not base then
86748: LD_EXP 31
86752: NOT
86753: PUSH
86754: LD_VAR 0 2
86758: NOT
86759: OR
86760: PUSH
86761: LD_VAR 0 1
86765: NOT
86766: OR
86767: IFFALSE 86771
// exit ;
86769: GO 86796
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
86771: LD_ADDR_EXP 55
86775: PUSH
86776: LD_EXP 55
86780: PPUSH
86781: LD_VAR 0 1
86785: PPUSH
86786: LD_VAR 0 2
86790: PPUSH
86791: CALL_OW 1
86795: ST_TO_ADDR
// end ;
86796: LD_VAR 0 3
86800: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
86801: LD_INT 0
86803: PPUSH
// if not mc_bases or not base or not scan_area then
86804: LD_EXP 31
86808: NOT
86809: PUSH
86810: LD_VAR 0 1
86814: NOT
86815: OR
86816: PUSH
86817: LD_VAR 0 2
86821: NOT
86822: OR
86823: IFFALSE 86827
// exit ;
86825: GO 86852
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
86827: LD_ADDR_EXP 56
86831: PUSH
86832: LD_EXP 56
86836: PPUSH
86837: LD_VAR 0 1
86841: PPUSH
86842: LD_VAR 0 2
86846: PPUSH
86847: CALL_OW 1
86851: ST_TO_ADDR
// end ;
86852: LD_VAR 0 3
86856: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
86857: LD_INT 0
86859: PPUSH
86860: PPUSH
// if not mc_bases or not base then
86861: LD_EXP 31
86865: NOT
86866: PUSH
86867: LD_VAR 0 1
86871: NOT
86872: OR
86873: IFFALSE 86877
// exit ;
86875: GO 86941
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
86877: LD_ADDR_VAR 0 3
86881: PUSH
86882: LD_INT 1
86884: PUSH
86885: LD_INT 2
86887: PUSH
86888: LD_INT 3
86890: PUSH
86891: LD_INT 4
86893: PUSH
86894: LD_INT 11
86896: PUSH
86897: EMPTY
86898: LIST
86899: LIST
86900: LIST
86901: LIST
86902: LIST
86903: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
86904: LD_ADDR_EXP 58
86908: PUSH
86909: LD_EXP 58
86913: PPUSH
86914: LD_VAR 0 1
86918: PPUSH
86919: LD_EXP 58
86923: PUSH
86924: LD_VAR 0 1
86928: ARRAY
86929: PUSH
86930: LD_VAR 0 3
86934: DIFF
86935: PPUSH
86936: CALL_OW 1
86940: ST_TO_ADDR
// end ;
86941: LD_VAR 0 2
86945: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
86946: LD_INT 0
86948: PPUSH
// result := mc_vehicles [ base ] ;
86949: LD_ADDR_VAR 0 3
86953: PUSH
86954: LD_EXP 50
86958: PUSH
86959: LD_VAR 0 1
86963: ARRAY
86964: ST_TO_ADDR
// if onlyCombat then
86965: LD_VAR 0 2
86969: IFFALSE 87141
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
86971: LD_ADDR_VAR 0 3
86975: PUSH
86976: LD_VAR 0 3
86980: PUSH
86981: LD_VAR 0 3
86985: PPUSH
86986: LD_INT 2
86988: PUSH
86989: LD_INT 34
86991: PUSH
86992: LD_INT 12
86994: PUSH
86995: EMPTY
86996: LIST
86997: LIST
86998: PUSH
86999: LD_INT 34
87001: PUSH
87002: LD_INT 51
87004: PUSH
87005: EMPTY
87006: LIST
87007: LIST
87008: PUSH
87009: LD_INT 34
87011: PUSH
87012: LD_INT 89
87014: PUSH
87015: EMPTY
87016: LIST
87017: LIST
87018: PUSH
87019: LD_INT 34
87021: PUSH
87022: LD_INT 32
87024: PUSH
87025: EMPTY
87026: LIST
87027: LIST
87028: PUSH
87029: LD_INT 34
87031: PUSH
87032: LD_INT 13
87034: PUSH
87035: EMPTY
87036: LIST
87037: LIST
87038: PUSH
87039: LD_INT 34
87041: PUSH
87042: LD_INT 52
87044: PUSH
87045: EMPTY
87046: LIST
87047: LIST
87048: PUSH
87049: LD_INT 34
87051: PUSH
87052: LD_INT 88
87054: PUSH
87055: EMPTY
87056: LIST
87057: LIST
87058: PUSH
87059: LD_INT 34
87061: PUSH
87062: LD_INT 14
87064: PUSH
87065: EMPTY
87066: LIST
87067: LIST
87068: PUSH
87069: LD_INT 34
87071: PUSH
87072: LD_INT 53
87074: PUSH
87075: EMPTY
87076: LIST
87077: LIST
87078: PUSH
87079: LD_INT 34
87081: PUSH
87082: LD_INT 98
87084: PUSH
87085: EMPTY
87086: LIST
87087: LIST
87088: PUSH
87089: LD_INT 34
87091: PUSH
87092: LD_INT 31
87094: PUSH
87095: EMPTY
87096: LIST
87097: LIST
87098: PUSH
87099: LD_INT 34
87101: PUSH
87102: LD_INT 48
87104: PUSH
87105: EMPTY
87106: LIST
87107: LIST
87108: PUSH
87109: LD_INT 34
87111: PUSH
87112: LD_INT 8
87114: PUSH
87115: EMPTY
87116: LIST
87117: LIST
87118: PUSH
87119: EMPTY
87120: LIST
87121: LIST
87122: LIST
87123: LIST
87124: LIST
87125: LIST
87126: LIST
87127: LIST
87128: LIST
87129: LIST
87130: LIST
87131: LIST
87132: LIST
87133: LIST
87134: PPUSH
87135: CALL_OW 72
87139: DIFF
87140: ST_TO_ADDR
// end ; end_of_file
87141: LD_VAR 0 3
87145: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
87146: LD_INT 0
87148: PPUSH
87149: PPUSH
87150: PPUSH
// if not mc_bases or not skirmish then
87151: LD_EXP 31
87155: NOT
87156: PUSH
87157: LD_EXP 29
87161: NOT
87162: OR
87163: IFFALSE 87167
// exit ;
87165: GO 87332
// for i = 1 to mc_bases do
87167: LD_ADDR_VAR 0 4
87171: PUSH
87172: DOUBLE
87173: LD_INT 1
87175: DEC
87176: ST_TO_ADDR
87177: LD_EXP 31
87181: PUSH
87182: FOR_TO
87183: IFFALSE 87330
// begin if sci in mc_bases [ i ] then
87185: LD_VAR 0 2
87189: PUSH
87190: LD_EXP 31
87194: PUSH
87195: LD_VAR 0 4
87199: ARRAY
87200: IN
87201: IFFALSE 87328
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
87203: LD_ADDR_EXP 60
87207: PUSH
87208: LD_EXP 60
87212: PPUSH
87213: LD_VAR 0 4
87217: PUSH
87218: LD_EXP 60
87222: PUSH
87223: LD_VAR 0 4
87227: ARRAY
87228: PUSH
87229: LD_INT 1
87231: PLUS
87232: PUSH
87233: EMPTY
87234: LIST
87235: LIST
87236: PPUSH
87237: LD_VAR 0 1
87241: PPUSH
87242: CALL 25021 0 3
87246: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
87247: LD_ADDR_VAR 0 5
87251: PUSH
87252: LD_EXP 31
87256: PUSH
87257: LD_VAR 0 4
87261: ARRAY
87262: PPUSH
87263: LD_INT 2
87265: PUSH
87266: LD_INT 30
87268: PUSH
87269: LD_INT 0
87271: PUSH
87272: EMPTY
87273: LIST
87274: LIST
87275: PUSH
87276: LD_INT 30
87278: PUSH
87279: LD_INT 1
87281: PUSH
87282: EMPTY
87283: LIST
87284: LIST
87285: PUSH
87286: EMPTY
87287: LIST
87288: LIST
87289: LIST
87290: PPUSH
87291: CALL_OW 72
87295: PPUSH
87296: LD_VAR 0 1
87300: PPUSH
87301: CALL_OW 74
87305: ST_TO_ADDR
// if tmp then
87306: LD_VAR 0 5
87310: IFFALSE 87326
// ComStandNearbyBuilding ( ape , tmp ) ;
87312: LD_VAR 0 1
87316: PPUSH
87317: LD_VAR 0 5
87321: PPUSH
87322: CALL 21448 0 2
// break ;
87326: GO 87330
// end ; end ;
87328: GO 87182
87330: POP
87331: POP
// end ;
87332: LD_VAR 0 3
87336: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
87337: LD_INT 0
87339: PPUSH
87340: PPUSH
87341: PPUSH
// if not mc_bases or not skirmish then
87342: LD_EXP 31
87346: NOT
87347: PUSH
87348: LD_EXP 29
87352: NOT
87353: OR
87354: IFFALSE 87358
// exit ;
87356: GO 87447
// for i = 1 to mc_bases do
87358: LD_ADDR_VAR 0 4
87362: PUSH
87363: DOUBLE
87364: LD_INT 1
87366: DEC
87367: ST_TO_ADDR
87368: LD_EXP 31
87372: PUSH
87373: FOR_TO
87374: IFFALSE 87445
// begin if building in mc_busy_turret_list [ i ] then
87376: LD_VAR 0 1
87380: PUSH
87381: LD_EXP 41
87385: PUSH
87386: LD_VAR 0 4
87390: ARRAY
87391: IN
87392: IFFALSE 87443
// begin tmp := mc_busy_turret_list [ i ] diff building ;
87394: LD_ADDR_VAR 0 5
87398: PUSH
87399: LD_EXP 41
87403: PUSH
87404: LD_VAR 0 4
87408: ARRAY
87409: PUSH
87410: LD_VAR 0 1
87414: DIFF
87415: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
87416: LD_ADDR_EXP 41
87420: PUSH
87421: LD_EXP 41
87425: PPUSH
87426: LD_VAR 0 4
87430: PPUSH
87431: LD_VAR 0 5
87435: PPUSH
87436: CALL_OW 1
87440: ST_TO_ADDR
// break ;
87441: GO 87445
// end ; end ;
87443: GO 87373
87445: POP
87446: POP
// end ;
87447: LD_VAR 0 3
87451: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
87452: LD_INT 0
87454: PPUSH
87455: PPUSH
87456: PPUSH
// if not mc_bases or not skirmish then
87457: LD_EXP 31
87461: NOT
87462: PUSH
87463: LD_EXP 29
87467: NOT
87468: OR
87469: IFFALSE 87473
// exit ;
87471: GO 87672
// for i = 1 to mc_bases do
87473: LD_ADDR_VAR 0 5
87477: PUSH
87478: DOUBLE
87479: LD_INT 1
87481: DEC
87482: ST_TO_ADDR
87483: LD_EXP 31
87487: PUSH
87488: FOR_TO
87489: IFFALSE 87670
// if building in mc_bases [ i ] then
87491: LD_VAR 0 1
87495: PUSH
87496: LD_EXP 31
87500: PUSH
87501: LD_VAR 0 5
87505: ARRAY
87506: IN
87507: IFFALSE 87668
// begin tmp := mc_bases [ i ] diff building ;
87509: LD_ADDR_VAR 0 6
87513: PUSH
87514: LD_EXP 31
87518: PUSH
87519: LD_VAR 0 5
87523: ARRAY
87524: PUSH
87525: LD_VAR 0 1
87529: DIFF
87530: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
87531: LD_ADDR_EXP 31
87535: PUSH
87536: LD_EXP 31
87540: PPUSH
87541: LD_VAR 0 5
87545: PPUSH
87546: LD_VAR 0 6
87550: PPUSH
87551: CALL_OW 1
87555: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
87556: LD_VAR 0 1
87560: PUSH
87561: LD_EXP 39
87565: PUSH
87566: LD_VAR 0 5
87570: ARRAY
87571: IN
87572: IFFALSE 87611
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
87574: LD_ADDR_EXP 39
87578: PUSH
87579: LD_EXP 39
87583: PPUSH
87584: LD_VAR 0 5
87588: PPUSH
87589: LD_EXP 39
87593: PUSH
87594: LD_VAR 0 5
87598: ARRAY
87599: PUSH
87600: LD_VAR 0 1
87604: DIFF
87605: PPUSH
87606: CALL_OW 1
87610: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
87611: LD_VAR 0 1
87615: PUSH
87616: LD_EXP 40
87620: PUSH
87621: LD_VAR 0 5
87625: ARRAY
87626: IN
87627: IFFALSE 87666
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
87629: LD_ADDR_EXP 40
87633: PUSH
87634: LD_EXP 40
87638: PPUSH
87639: LD_VAR 0 5
87643: PPUSH
87644: LD_EXP 40
87648: PUSH
87649: LD_VAR 0 5
87653: ARRAY
87654: PUSH
87655: LD_VAR 0 1
87659: DIFF
87660: PPUSH
87661: CALL_OW 1
87665: ST_TO_ADDR
// break ;
87666: GO 87670
// end ;
87668: GO 87488
87670: POP
87671: POP
// end ;
87672: LD_VAR 0 4
87676: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
87677: LD_INT 0
87679: PPUSH
87680: PPUSH
87681: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
87682: LD_EXP 31
87686: NOT
87687: PUSH
87688: LD_EXP 29
87692: NOT
87693: OR
87694: PUSH
87695: LD_VAR 0 3
87699: PUSH
87700: LD_EXP 57
87704: IN
87705: NOT
87706: OR
87707: IFFALSE 87711
// exit ;
87709: GO 87834
// for i = 1 to mc_vehicles do
87711: LD_ADDR_VAR 0 6
87715: PUSH
87716: DOUBLE
87717: LD_INT 1
87719: DEC
87720: ST_TO_ADDR
87721: LD_EXP 50
87725: PUSH
87726: FOR_TO
87727: IFFALSE 87832
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
87729: LD_VAR 0 2
87733: PUSH
87734: LD_EXP 50
87738: PUSH
87739: LD_VAR 0 6
87743: ARRAY
87744: IN
87745: PUSH
87746: LD_VAR 0 1
87750: PUSH
87751: LD_EXP 50
87755: PUSH
87756: LD_VAR 0 6
87760: ARRAY
87761: IN
87762: OR
87763: IFFALSE 87830
// begin tmp := mc_vehicles [ i ] diff old ;
87765: LD_ADDR_VAR 0 7
87769: PUSH
87770: LD_EXP 50
87774: PUSH
87775: LD_VAR 0 6
87779: ARRAY
87780: PUSH
87781: LD_VAR 0 2
87785: DIFF
87786: ST_TO_ADDR
// tmp := tmp diff new ;
87787: LD_ADDR_VAR 0 7
87791: PUSH
87792: LD_VAR 0 7
87796: PUSH
87797: LD_VAR 0 1
87801: DIFF
87802: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
87803: LD_ADDR_EXP 50
87807: PUSH
87808: LD_EXP 50
87812: PPUSH
87813: LD_VAR 0 6
87817: PPUSH
87818: LD_VAR 0 7
87822: PPUSH
87823: CALL_OW 1
87827: ST_TO_ADDR
// break ;
87828: GO 87832
// end ;
87830: GO 87726
87832: POP
87833: POP
// end ;
87834: LD_VAR 0 5
87838: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
87839: LD_INT 0
87841: PPUSH
87842: PPUSH
87843: PPUSH
87844: PPUSH
// if not mc_bases or not skirmish then
87845: LD_EXP 31
87849: NOT
87850: PUSH
87851: LD_EXP 29
87855: NOT
87856: OR
87857: IFFALSE 87861
// exit ;
87859: GO 88243
// side := GetSide ( vehicle ) ;
87861: LD_ADDR_VAR 0 5
87865: PUSH
87866: LD_VAR 0 1
87870: PPUSH
87871: CALL_OW 255
87875: ST_TO_ADDR
// for i = 1 to mc_bases do
87876: LD_ADDR_VAR 0 4
87880: PUSH
87881: DOUBLE
87882: LD_INT 1
87884: DEC
87885: ST_TO_ADDR
87886: LD_EXP 31
87890: PUSH
87891: FOR_TO
87892: IFFALSE 88241
// begin if factory in mc_bases [ i ] then
87894: LD_VAR 0 2
87898: PUSH
87899: LD_EXP 31
87903: PUSH
87904: LD_VAR 0 4
87908: ARRAY
87909: IN
87910: IFFALSE 88239
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
87912: LD_EXP 53
87916: PUSH
87917: LD_VAR 0 4
87921: ARRAY
87922: PUSH
87923: LD_EXP 42
87927: PUSH
87928: LD_VAR 0 4
87932: ARRAY
87933: LESS
87934: PUSH
87935: LD_VAR 0 1
87939: PPUSH
87940: CALL_OW 264
87944: PUSH
87945: LD_INT 31
87947: PUSH
87948: LD_INT 32
87950: PUSH
87951: LD_INT 51
87953: PUSH
87954: LD_INT 89
87956: PUSH
87957: LD_INT 12
87959: PUSH
87960: LD_INT 30
87962: PUSH
87963: LD_INT 98
87965: PUSH
87966: LD_INT 11
87968: PUSH
87969: LD_INT 53
87971: PUSH
87972: LD_INT 14
87974: PUSH
87975: LD_INT 91
87977: PUSH
87978: LD_INT 29
87980: PUSH
87981: LD_INT 99
87983: PUSH
87984: LD_INT 13
87986: PUSH
87987: LD_INT 52
87989: PUSH
87990: LD_INT 88
87992: PUSH
87993: LD_INT 48
87995: PUSH
87996: LD_INT 8
87998: PUSH
87999: EMPTY
88000: LIST
88001: LIST
88002: LIST
88003: LIST
88004: LIST
88005: LIST
88006: LIST
88007: LIST
88008: LIST
88009: LIST
88010: LIST
88011: LIST
88012: LIST
88013: LIST
88014: LIST
88015: LIST
88016: LIST
88017: LIST
88018: IN
88019: NOT
88020: AND
88021: IFFALSE 88069
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
88023: LD_ADDR_EXP 53
88027: PUSH
88028: LD_EXP 53
88032: PPUSH
88033: LD_VAR 0 4
88037: PUSH
88038: LD_EXP 53
88042: PUSH
88043: LD_VAR 0 4
88047: ARRAY
88048: PUSH
88049: LD_INT 1
88051: PLUS
88052: PUSH
88053: EMPTY
88054: LIST
88055: LIST
88056: PPUSH
88057: LD_VAR 0 1
88061: PPUSH
88062: CALL 25021 0 3
88066: ST_TO_ADDR
88067: GO 88113
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
88069: LD_ADDR_EXP 50
88073: PUSH
88074: LD_EXP 50
88078: PPUSH
88079: LD_VAR 0 4
88083: PUSH
88084: LD_EXP 50
88088: PUSH
88089: LD_VAR 0 4
88093: ARRAY
88094: PUSH
88095: LD_INT 1
88097: PLUS
88098: PUSH
88099: EMPTY
88100: LIST
88101: LIST
88102: PPUSH
88103: LD_VAR 0 1
88107: PPUSH
88108: CALL 25021 0 3
88112: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
88113: LD_VAR 0 1
88117: PPUSH
88118: CALL_OW 263
88122: PUSH
88123: LD_INT 2
88125: EQUAL
88126: IFFALSE 88155
// begin repeat wait ( 0 0$3 ) ;
88128: LD_INT 105
88130: PPUSH
88131: CALL_OW 67
// Connect ( vehicle ) ;
88135: LD_VAR 0 1
88139: PPUSH
88140: CALL 27990 0 1
// until IsControledBy ( vehicle ) ;
88144: LD_VAR 0 1
88148: PPUSH
88149: CALL_OW 312
88153: IFFALSE 88128
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
88155: LD_VAR 0 1
88159: PPUSH
88160: LD_EXP 55
88164: PUSH
88165: LD_VAR 0 4
88169: ARRAY
88170: PPUSH
88171: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
88175: LD_VAR 0 1
88179: PPUSH
88180: CALL_OW 263
88184: PUSH
88185: LD_INT 1
88187: NONEQUAL
88188: IFFALSE 88192
// break ;
88190: GO 88241
// repeat wait ( 0 0$1 ) ;
88192: LD_INT 35
88194: PPUSH
88195: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
88199: LD_VAR 0 1
88203: PPUSH
88204: LD_EXP 55
88208: PUSH
88209: LD_VAR 0 4
88213: ARRAY
88214: PPUSH
88215: CALL_OW 308
88219: IFFALSE 88192
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
88221: LD_VAR 0 1
88225: PPUSH
88226: CALL_OW 311
88230: PPUSH
88231: CALL_OW 121
// exit ;
88235: POP
88236: POP
88237: GO 88243
// end ; end ;
88239: GO 87891
88241: POP
88242: POP
// end ;
88243: LD_VAR 0 3
88247: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
88248: LD_INT 0
88250: PPUSH
88251: PPUSH
88252: PPUSH
88253: PPUSH
// if not mc_bases or not skirmish then
88254: LD_EXP 31
88258: NOT
88259: PUSH
88260: LD_EXP 29
88264: NOT
88265: OR
88266: IFFALSE 88270
// exit ;
88268: GO 88623
// repeat wait ( 0 0$1 ) ;
88270: LD_INT 35
88272: PPUSH
88273: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
88277: LD_VAR 0 2
88281: PPUSH
88282: LD_VAR 0 3
88286: PPUSH
88287: CALL_OW 284
88291: IFFALSE 88270
// if GetResourceTypeXY ( x , y ) = mat_artefact then
88293: LD_VAR 0 2
88297: PPUSH
88298: LD_VAR 0 3
88302: PPUSH
88303: CALL_OW 283
88307: PUSH
88308: LD_INT 4
88310: EQUAL
88311: IFFALSE 88315
// exit ;
88313: GO 88623
// for i = 1 to mc_bases do
88315: LD_ADDR_VAR 0 7
88319: PUSH
88320: DOUBLE
88321: LD_INT 1
88323: DEC
88324: ST_TO_ADDR
88325: LD_EXP 31
88329: PUSH
88330: FOR_TO
88331: IFFALSE 88621
// begin if mc_crates_area [ i ] then
88333: LD_EXP 49
88337: PUSH
88338: LD_VAR 0 7
88342: ARRAY
88343: IFFALSE 88454
// for j in mc_crates_area [ i ] do
88345: LD_ADDR_VAR 0 8
88349: PUSH
88350: LD_EXP 49
88354: PUSH
88355: LD_VAR 0 7
88359: ARRAY
88360: PUSH
88361: FOR_IN
88362: IFFALSE 88452
// if InArea ( x , y , j ) then
88364: LD_VAR 0 2
88368: PPUSH
88369: LD_VAR 0 3
88373: PPUSH
88374: LD_VAR 0 8
88378: PPUSH
88379: CALL_OW 309
88383: IFFALSE 88450
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
88385: LD_ADDR_EXP 47
88389: PUSH
88390: LD_EXP 47
88394: PPUSH
88395: LD_VAR 0 7
88399: PUSH
88400: LD_EXP 47
88404: PUSH
88405: LD_VAR 0 7
88409: ARRAY
88410: PUSH
88411: LD_INT 1
88413: PLUS
88414: PUSH
88415: EMPTY
88416: LIST
88417: LIST
88418: PPUSH
88419: LD_VAR 0 4
88423: PUSH
88424: LD_VAR 0 2
88428: PUSH
88429: LD_VAR 0 3
88433: PUSH
88434: EMPTY
88435: LIST
88436: LIST
88437: LIST
88438: PPUSH
88439: CALL 25021 0 3
88443: ST_TO_ADDR
// exit ;
88444: POP
88445: POP
88446: POP
88447: POP
88448: GO 88623
// end ;
88450: GO 88361
88452: POP
88453: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
88454: LD_ADDR_VAR 0 9
88458: PUSH
88459: LD_EXP 31
88463: PUSH
88464: LD_VAR 0 7
88468: ARRAY
88469: PPUSH
88470: LD_INT 2
88472: PUSH
88473: LD_INT 30
88475: PUSH
88476: LD_INT 0
88478: PUSH
88479: EMPTY
88480: LIST
88481: LIST
88482: PUSH
88483: LD_INT 30
88485: PUSH
88486: LD_INT 1
88488: PUSH
88489: EMPTY
88490: LIST
88491: LIST
88492: PUSH
88493: EMPTY
88494: LIST
88495: LIST
88496: LIST
88497: PPUSH
88498: CALL_OW 72
88502: ST_TO_ADDR
// if not depot then
88503: LD_VAR 0 9
88507: NOT
88508: IFFALSE 88512
// continue ;
88510: GO 88330
// for j in depot do
88512: LD_ADDR_VAR 0 8
88516: PUSH
88517: LD_VAR 0 9
88521: PUSH
88522: FOR_IN
88523: IFFALSE 88617
// if GetDistUnitXY ( j , x , y ) < 30 then
88525: LD_VAR 0 8
88529: PPUSH
88530: LD_VAR 0 2
88534: PPUSH
88535: LD_VAR 0 3
88539: PPUSH
88540: CALL_OW 297
88544: PUSH
88545: LD_INT 30
88547: LESS
88548: IFFALSE 88615
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
88550: LD_ADDR_EXP 47
88554: PUSH
88555: LD_EXP 47
88559: PPUSH
88560: LD_VAR 0 7
88564: PUSH
88565: LD_EXP 47
88569: PUSH
88570: LD_VAR 0 7
88574: ARRAY
88575: PUSH
88576: LD_INT 1
88578: PLUS
88579: PUSH
88580: EMPTY
88581: LIST
88582: LIST
88583: PPUSH
88584: LD_VAR 0 4
88588: PUSH
88589: LD_VAR 0 2
88593: PUSH
88594: LD_VAR 0 3
88598: PUSH
88599: EMPTY
88600: LIST
88601: LIST
88602: LIST
88603: PPUSH
88604: CALL 25021 0 3
88608: ST_TO_ADDR
// exit ;
88609: POP
88610: POP
88611: POP
88612: POP
88613: GO 88623
// end ;
88615: GO 88522
88617: POP
88618: POP
// end ;
88619: GO 88330
88621: POP
88622: POP
// end ;
88623: LD_VAR 0 6
88627: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
88628: LD_INT 0
88630: PPUSH
88631: PPUSH
88632: PPUSH
88633: PPUSH
// if not mc_bases or not skirmish then
88634: LD_EXP 31
88638: NOT
88639: PUSH
88640: LD_EXP 29
88644: NOT
88645: OR
88646: IFFALSE 88650
// exit ;
88648: GO 88927
// side := GetSide ( lab ) ;
88650: LD_ADDR_VAR 0 4
88654: PUSH
88655: LD_VAR 0 2
88659: PPUSH
88660: CALL_OW 255
88664: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
88665: LD_VAR 0 4
88669: PUSH
88670: LD_EXP 57
88674: IN
88675: NOT
88676: PUSH
88677: LD_EXP 58
88681: NOT
88682: OR
88683: PUSH
88684: LD_EXP 31
88688: NOT
88689: OR
88690: IFFALSE 88694
// exit ;
88692: GO 88927
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
88694: LD_ADDR_EXP 58
88698: PUSH
88699: LD_EXP 58
88703: PPUSH
88704: LD_VAR 0 4
88708: PPUSH
88709: LD_EXP 58
88713: PUSH
88714: LD_VAR 0 4
88718: ARRAY
88719: PUSH
88720: LD_VAR 0 1
88724: DIFF
88725: PPUSH
88726: CALL_OW 1
88730: ST_TO_ADDR
// for i = 1 to mc_bases do
88731: LD_ADDR_VAR 0 5
88735: PUSH
88736: DOUBLE
88737: LD_INT 1
88739: DEC
88740: ST_TO_ADDR
88741: LD_EXP 31
88745: PUSH
88746: FOR_TO
88747: IFFALSE 88925
// begin if lab in mc_bases [ i ] then
88749: LD_VAR 0 2
88753: PUSH
88754: LD_EXP 31
88758: PUSH
88759: LD_VAR 0 5
88763: ARRAY
88764: IN
88765: IFFALSE 88923
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
88767: LD_VAR 0 1
88771: PUSH
88772: LD_INT 11
88774: PUSH
88775: LD_INT 4
88777: PUSH
88778: LD_INT 3
88780: PUSH
88781: LD_INT 2
88783: PUSH
88784: EMPTY
88785: LIST
88786: LIST
88787: LIST
88788: LIST
88789: IN
88790: PUSH
88791: LD_EXP 61
88795: PUSH
88796: LD_VAR 0 5
88800: ARRAY
88801: AND
88802: IFFALSE 88923
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
88804: LD_ADDR_VAR 0 6
88808: PUSH
88809: LD_EXP 61
88813: PUSH
88814: LD_VAR 0 5
88818: ARRAY
88819: PUSH
88820: LD_INT 1
88822: ARRAY
88823: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
88824: LD_ADDR_EXP 61
88828: PUSH
88829: LD_EXP 61
88833: PPUSH
88834: LD_VAR 0 5
88838: PPUSH
88839: EMPTY
88840: PPUSH
88841: CALL_OW 1
88845: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
88846: LD_VAR 0 6
88850: PPUSH
88851: LD_INT 0
88853: PPUSH
88854: CALL_OW 109
// ComExitBuilding ( tmp ) ;
88858: LD_VAR 0 6
88862: PPUSH
88863: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
88867: LD_ADDR_EXP 60
88871: PUSH
88872: LD_EXP 60
88876: PPUSH
88877: LD_VAR 0 5
88881: PPUSH
88882: LD_EXP 60
88886: PUSH
88887: LD_VAR 0 5
88891: ARRAY
88892: PPUSH
88893: LD_INT 1
88895: PPUSH
88896: LD_VAR 0 6
88900: PPUSH
88901: CALL_OW 2
88905: PPUSH
88906: CALL_OW 1
88910: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
88911: LD_VAR 0 5
88915: PPUSH
88916: LD_INT 112
88918: PPUSH
88919: CALL 65413 0 2
// end ; end ; end ;
88923: GO 88746
88925: POP
88926: POP
// end ;
88927: LD_VAR 0 3
88931: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
88932: LD_INT 0
88934: PPUSH
88935: PPUSH
88936: PPUSH
88937: PPUSH
88938: PPUSH
88939: PPUSH
88940: PPUSH
88941: PPUSH
// if not mc_bases or not skirmish then
88942: LD_EXP 31
88946: NOT
88947: PUSH
88948: LD_EXP 29
88952: NOT
88953: OR
88954: IFFALSE 88958
// exit ;
88956: GO 90327
// for i = 1 to mc_bases do
88958: LD_ADDR_VAR 0 3
88962: PUSH
88963: DOUBLE
88964: LD_INT 1
88966: DEC
88967: ST_TO_ADDR
88968: LD_EXP 31
88972: PUSH
88973: FOR_TO
88974: IFFALSE 90325
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
88976: LD_VAR 0 1
88980: PUSH
88981: LD_EXP 31
88985: PUSH
88986: LD_VAR 0 3
88990: ARRAY
88991: IN
88992: PUSH
88993: LD_VAR 0 1
88997: PUSH
88998: LD_EXP 38
89002: PUSH
89003: LD_VAR 0 3
89007: ARRAY
89008: IN
89009: OR
89010: PUSH
89011: LD_VAR 0 1
89015: PUSH
89016: LD_EXP 53
89020: PUSH
89021: LD_VAR 0 3
89025: ARRAY
89026: IN
89027: OR
89028: PUSH
89029: LD_VAR 0 1
89033: PUSH
89034: LD_EXP 50
89038: PUSH
89039: LD_VAR 0 3
89043: ARRAY
89044: IN
89045: OR
89046: PUSH
89047: LD_VAR 0 1
89051: PUSH
89052: LD_EXP 60
89056: PUSH
89057: LD_VAR 0 3
89061: ARRAY
89062: IN
89063: OR
89064: PUSH
89065: LD_VAR 0 1
89069: PUSH
89070: LD_EXP 61
89074: PUSH
89075: LD_VAR 0 3
89079: ARRAY
89080: IN
89081: OR
89082: IFFALSE 90323
// begin if un in mc_ape [ i ] then
89084: LD_VAR 0 1
89088: PUSH
89089: LD_EXP 60
89093: PUSH
89094: LD_VAR 0 3
89098: ARRAY
89099: IN
89100: IFFALSE 89139
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
89102: LD_ADDR_EXP 60
89106: PUSH
89107: LD_EXP 60
89111: PPUSH
89112: LD_VAR 0 3
89116: PPUSH
89117: LD_EXP 60
89121: PUSH
89122: LD_VAR 0 3
89126: ARRAY
89127: PUSH
89128: LD_VAR 0 1
89132: DIFF
89133: PPUSH
89134: CALL_OW 1
89138: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
89139: LD_VAR 0 1
89143: PUSH
89144: LD_EXP 61
89148: PUSH
89149: LD_VAR 0 3
89153: ARRAY
89154: IN
89155: IFFALSE 89179
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
89157: LD_ADDR_EXP 61
89161: PUSH
89162: LD_EXP 61
89166: PPUSH
89167: LD_VAR 0 3
89171: PPUSH
89172: EMPTY
89173: PPUSH
89174: CALL_OW 1
89178: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
89179: LD_VAR 0 1
89183: PPUSH
89184: CALL_OW 247
89188: PUSH
89189: LD_INT 2
89191: EQUAL
89192: PUSH
89193: LD_VAR 0 1
89197: PPUSH
89198: CALL_OW 110
89202: PUSH
89203: LD_INT 20
89205: EQUAL
89206: PUSH
89207: LD_VAR 0 1
89211: PUSH
89212: LD_EXP 53
89216: PUSH
89217: LD_VAR 0 3
89221: ARRAY
89222: IN
89223: OR
89224: PUSH
89225: LD_VAR 0 1
89229: PPUSH
89230: CALL_OW 264
89234: PUSH
89235: LD_INT 12
89237: PUSH
89238: LD_INT 51
89240: PUSH
89241: LD_INT 89
89243: PUSH
89244: LD_INT 32
89246: PUSH
89247: LD_INT 13
89249: PUSH
89250: LD_INT 52
89252: PUSH
89253: LD_INT 31
89255: PUSH
89256: EMPTY
89257: LIST
89258: LIST
89259: LIST
89260: LIST
89261: LIST
89262: LIST
89263: LIST
89264: IN
89265: OR
89266: AND
89267: IFFALSE 89575
// begin if un in mc_defender [ i ] then
89269: LD_VAR 0 1
89273: PUSH
89274: LD_EXP 53
89278: PUSH
89279: LD_VAR 0 3
89283: ARRAY
89284: IN
89285: IFFALSE 89324
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
89287: LD_ADDR_EXP 53
89291: PUSH
89292: LD_EXP 53
89296: PPUSH
89297: LD_VAR 0 3
89301: PPUSH
89302: LD_EXP 53
89306: PUSH
89307: LD_VAR 0 3
89311: ARRAY
89312: PUSH
89313: LD_VAR 0 1
89317: DIFF
89318: PPUSH
89319: CALL_OW 1
89323: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
89324: LD_ADDR_VAR 0 8
89328: PUSH
89329: LD_VAR 0 3
89333: PPUSH
89334: LD_INT 3
89336: PPUSH
89337: CALL 85983 0 2
89341: ST_TO_ADDR
// if fac then
89342: LD_VAR 0 8
89346: IFFALSE 89575
// begin for j in fac do
89348: LD_ADDR_VAR 0 4
89352: PUSH
89353: LD_VAR 0 8
89357: PUSH
89358: FOR_IN
89359: IFFALSE 89573
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
89361: LD_ADDR_VAR 0 9
89365: PUSH
89366: LD_VAR 0 8
89370: PPUSH
89371: LD_VAR 0 1
89375: PPUSH
89376: CALL_OW 265
89380: PPUSH
89381: LD_VAR 0 1
89385: PPUSH
89386: CALL_OW 262
89390: PPUSH
89391: LD_VAR 0 1
89395: PPUSH
89396: CALL_OW 263
89400: PPUSH
89401: LD_VAR 0 1
89405: PPUSH
89406: CALL_OW 264
89410: PPUSH
89411: CALL 22519 0 5
89415: ST_TO_ADDR
// if components then
89416: LD_VAR 0 9
89420: IFFALSE 89571
// begin if GetWeapon ( un ) = ar_control_tower then
89422: LD_VAR 0 1
89426: PPUSH
89427: CALL_OW 264
89431: PUSH
89432: LD_INT 31
89434: EQUAL
89435: IFFALSE 89552
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
89437: LD_VAR 0 1
89441: PPUSH
89442: CALL_OW 311
89446: PPUSH
89447: LD_INT 0
89449: PPUSH
89450: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
89454: LD_ADDR_EXP 71
89458: PUSH
89459: LD_EXP 71
89463: PPUSH
89464: LD_VAR 0 3
89468: PPUSH
89469: LD_EXP 71
89473: PUSH
89474: LD_VAR 0 3
89478: ARRAY
89479: PUSH
89480: LD_VAR 0 1
89484: PPUSH
89485: CALL_OW 311
89489: DIFF
89490: PPUSH
89491: CALL_OW 1
89495: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
89496: LD_ADDR_VAR 0 7
89500: PUSH
89501: LD_EXP 52
89505: PUSH
89506: LD_VAR 0 3
89510: ARRAY
89511: PPUSH
89512: LD_INT 1
89514: PPUSH
89515: LD_VAR 0 9
89519: PPUSH
89520: CALL_OW 2
89524: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
89525: LD_ADDR_EXP 52
89529: PUSH
89530: LD_EXP 52
89534: PPUSH
89535: LD_VAR 0 3
89539: PPUSH
89540: LD_VAR 0 7
89544: PPUSH
89545: CALL_OW 1
89549: ST_TO_ADDR
// end else
89550: GO 89569
// MC_InsertProduceList ( i , [ components ] ) ;
89552: LD_VAR 0 3
89556: PPUSH
89557: LD_VAR 0 9
89561: PUSH
89562: EMPTY
89563: LIST
89564: PPUSH
89565: CALL 85528 0 2
// break ;
89569: GO 89573
// end ; end ;
89571: GO 89358
89573: POP
89574: POP
// end ; end ; if GetType ( un ) = unit_building then
89575: LD_VAR 0 1
89579: PPUSH
89580: CALL_OW 247
89584: PUSH
89585: LD_INT 3
89587: EQUAL
89588: IFFALSE 89991
// begin btype := GetBType ( un ) ;
89590: LD_ADDR_VAR 0 5
89594: PUSH
89595: LD_VAR 0 1
89599: PPUSH
89600: CALL_OW 266
89604: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
89605: LD_VAR 0 5
89609: PUSH
89610: LD_INT 29
89612: PUSH
89613: LD_INT 30
89615: PUSH
89616: EMPTY
89617: LIST
89618: LIST
89619: IN
89620: IFFALSE 89693
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
89622: LD_VAR 0 1
89626: PPUSH
89627: CALL_OW 250
89631: PPUSH
89632: LD_VAR 0 1
89636: PPUSH
89637: CALL_OW 251
89641: PPUSH
89642: LD_VAR 0 1
89646: PPUSH
89647: CALL_OW 255
89651: PPUSH
89652: CALL_OW 440
89656: NOT
89657: IFFALSE 89693
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
89659: LD_VAR 0 1
89663: PPUSH
89664: CALL_OW 250
89668: PPUSH
89669: LD_VAR 0 1
89673: PPUSH
89674: CALL_OW 251
89678: PPUSH
89679: LD_VAR 0 1
89683: PPUSH
89684: CALL_OW 255
89688: PPUSH
89689: CALL_OW 441
// end ; if btype = b_warehouse then
89693: LD_VAR 0 5
89697: PUSH
89698: LD_INT 1
89700: EQUAL
89701: IFFALSE 89719
// begin btype := b_depot ;
89703: LD_ADDR_VAR 0 5
89707: PUSH
89708: LD_INT 0
89710: ST_TO_ADDR
// pos := 1 ;
89711: LD_ADDR_VAR 0 6
89715: PUSH
89716: LD_INT 1
89718: ST_TO_ADDR
// end ; if btype = b_factory then
89719: LD_VAR 0 5
89723: PUSH
89724: LD_INT 3
89726: EQUAL
89727: IFFALSE 89745
// begin btype := b_workshop ;
89729: LD_ADDR_VAR 0 5
89733: PUSH
89734: LD_INT 2
89736: ST_TO_ADDR
// pos := 1 ;
89737: LD_ADDR_VAR 0 6
89741: PUSH
89742: LD_INT 1
89744: ST_TO_ADDR
// end ; if btype = b_barracks then
89745: LD_VAR 0 5
89749: PUSH
89750: LD_INT 5
89752: EQUAL
89753: IFFALSE 89763
// btype := b_armoury ;
89755: LD_ADDR_VAR 0 5
89759: PUSH
89760: LD_INT 4
89762: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
89763: LD_VAR 0 5
89767: PUSH
89768: LD_INT 7
89770: PUSH
89771: LD_INT 8
89773: PUSH
89774: EMPTY
89775: LIST
89776: LIST
89777: IN
89778: IFFALSE 89788
// btype := b_lab ;
89780: LD_ADDR_VAR 0 5
89784: PUSH
89785: LD_INT 6
89787: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
89788: LD_ADDR_EXP 36
89792: PUSH
89793: LD_EXP 36
89797: PPUSH
89798: LD_VAR 0 3
89802: PUSH
89803: LD_EXP 36
89807: PUSH
89808: LD_VAR 0 3
89812: ARRAY
89813: PUSH
89814: LD_INT 1
89816: PLUS
89817: PUSH
89818: EMPTY
89819: LIST
89820: LIST
89821: PPUSH
89822: LD_VAR 0 5
89826: PUSH
89827: LD_VAR 0 1
89831: PPUSH
89832: CALL_OW 250
89836: PUSH
89837: LD_VAR 0 1
89841: PPUSH
89842: CALL_OW 251
89846: PUSH
89847: LD_VAR 0 1
89851: PPUSH
89852: CALL_OW 254
89856: PUSH
89857: EMPTY
89858: LIST
89859: LIST
89860: LIST
89861: LIST
89862: PPUSH
89863: CALL 25021 0 3
89867: ST_TO_ADDR
// if pos = 1 then
89868: LD_VAR 0 6
89872: PUSH
89873: LD_INT 1
89875: EQUAL
89876: IFFALSE 89991
// begin tmp := mc_build_list [ i ] ;
89878: LD_ADDR_VAR 0 7
89882: PUSH
89883: LD_EXP 36
89887: PUSH
89888: LD_VAR 0 3
89892: ARRAY
89893: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
89894: LD_VAR 0 7
89898: PPUSH
89899: LD_INT 2
89901: PUSH
89902: LD_INT 30
89904: PUSH
89905: LD_INT 0
89907: PUSH
89908: EMPTY
89909: LIST
89910: LIST
89911: PUSH
89912: LD_INT 30
89914: PUSH
89915: LD_INT 1
89917: PUSH
89918: EMPTY
89919: LIST
89920: LIST
89921: PUSH
89922: EMPTY
89923: LIST
89924: LIST
89925: LIST
89926: PPUSH
89927: CALL_OW 72
89931: IFFALSE 89941
// pos := 2 ;
89933: LD_ADDR_VAR 0 6
89937: PUSH
89938: LD_INT 2
89940: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
89941: LD_ADDR_VAR 0 7
89945: PUSH
89946: LD_VAR 0 7
89950: PPUSH
89951: LD_VAR 0 6
89955: PPUSH
89956: LD_VAR 0 7
89960: PPUSH
89961: CALL 25347 0 3
89965: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
89966: LD_ADDR_EXP 36
89970: PUSH
89971: LD_EXP 36
89975: PPUSH
89976: LD_VAR 0 3
89980: PPUSH
89981: LD_VAR 0 7
89985: PPUSH
89986: CALL_OW 1
89990: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
89991: LD_VAR 0 1
89995: PUSH
89996: LD_EXP 31
90000: PUSH
90001: LD_VAR 0 3
90005: ARRAY
90006: IN
90007: IFFALSE 90046
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
90009: LD_ADDR_EXP 31
90013: PUSH
90014: LD_EXP 31
90018: PPUSH
90019: LD_VAR 0 3
90023: PPUSH
90024: LD_EXP 31
90028: PUSH
90029: LD_VAR 0 3
90033: ARRAY
90034: PUSH
90035: LD_VAR 0 1
90039: DIFF
90040: PPUSH
90041: CALL_OW 1
90045: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
90046: LD_VAR 0 1
90050: PUSH
90051: LD_EXP 38
90055: PUSH
90056: LD_VAR 0 3
90060: ARRAY
90061: IN
90062: IFFALSE 90101
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
90064: LD_ADDR_EXP 38
90068: PUSH
90069: LD_EXP 38
90073: PPUSH
90074: LD_VAR 0 3
90078: PPUSH
90079: LD_EXP 38
90083: PUSH
90084: LD_VAR 0 3
90088: ARRAY
90089: PUSH
90090: LD_VAR 0 1
90094: DIFF
90095: PPUSH
90096: CALL_OW 1
90100: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
90101: LD_VAR 0 1
90105: PUSH
90106: LD_EXP 50
90110: PUSH
90111: LD_VAR 0 3
90115: ARRAY
90116: IN
90117: IFFALSE 90156
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
90119: LD_ADDR_EXP 50
90123: PUSH
90124: LD_EXP 50
90128: PPUSH
90129: LD_VAR 0 3
90133: PPUSH
90134: LD_EXP 50
90138: PUSH
90139: LD_VAR 0 3
90143: ARRAY
90144: PUSH
90145: LD_VAR 0 1
90149: DIFF
90150: PPUSH
90151: CALL_OW 1
90155: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
90156: LD_VAR 0 1
90160: PUSH
90161: LD_EXP 53
90165: PUSH
90166: LD_VAR 0 3
90170: ARRAY
90171: IN
90172: IFFALSE 90211
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
90174: LD_ADDR_EXP 53
90178: PUSH
90179: LD_EXP 53
90183: PPUSH
90184: LD_VAR 0 3
90188: PPUSH
90189: LD_EXP 53
90193: PUSH
90194: LD_VAR 0 3
90198: ARRAY
90199: PUSH
90200: LD_VAR 0 1
90204: DIFF
90205: PPUSH
90206: CALL_OW 1
90210: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
90211: LD_VAR 0 1
90215: PUSH
90216: LD_EXP 40
90220: PUSH
90221: LD_VAR 0 3
90225: ARRAY
90226: IN
90227: IFFALSE 90266
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
90229: LD_ADDR_EXP 40
90233: PUSH
90234: LD_EXP 40
90238: PPUSH
90239: LD_VAR 0 3
90243: PPUSH
90244: LD_EXP 40
90248: PUSH
90249: LD_VAR 0 3
90253: ARRAY
90254: PUSH
90255: LD_VAR 0 1
90259: DIFF
90260: PPUSH
90261: CALL_OW 1
90265: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
90266: LD_VAR 0 1
90270: PUSH
90271: LD_EXP 39
90275: PUSH
90276: LD_VAR 0 3
90280: ARRAY
90281: IN
90282: IFFALSE 90321
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
90284: LD_ADDR_EXP 39
90288: PUSH
90289: LD_EXP 39
90293: PPUSH
90294: LD_VAR 0 3
90298: PPUSH
90299: LD_EXP 39
90303: PUSH
90304: LD_VAR 0 3
90308: ARRAY
90309: PUSH
90310: LD_VAR 0 1
90314: DIFF
90315: PPUSH
90316: CALL_OW 1
90320: ST_TO_ADDR
// end ; break ;
90321: GO 90325
// end ;
90323: GO 88973
90325: POP
90326: POP
// end ;
90327: LD_VAR 0 2
90331: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
90332: LD_INT 0
90334: PPUSH
90335: PPUSH
90336: PPUSH
// if not mc_bases or not skirmish then
90337: LD_EXP 31
90341: NOT
90342: PUSH
90343: LD_EXP 29
90347: NOT
90348: OR
90349: IFFALSE 90353
// exit ;
90351: GO 90568
// for i = 1 to mc_bases do
90353: LD_ADDR_VAR 0 3
90357: PUSH
90358: DOUBLE
90359: LD_INT 1
90361: DEC
90362: ST_TO_ADDR
90363: LD_EXP 31
90367: PUSH
90368: FOR_TO
90369: IFFALSE 90566
// begin if building in mc_construct_list [ i ] then
90371: LD_VAR 0 1
90375: PUSH
90376: LD_EXP 38
90380: PUSH
90381: LD_VAR 0 3
90385: ARRAY
90386: IN
90387: IFFALSE 90564
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
90389: LD_ADDR_EXP 38
90393: PUSH
90394: LD_EXP 38
90398: PPUSH
90399: LD_VAR 0 3
90403: PPUSH
90404: LD_EXP 38
90408: PUSH
90409: LD_VAR 0 3
90413: ARRAY
90414: PUSH
90415: LD_VAR 0 1
90419: DIFF
90420: PPUSH
90421: CALL_OW 1
90425: ST_TO_ADDR
// if building in mc_lab [ i ] then
90426: LD_VAR 0 1
90430: PUSH
90431: LD_EXP 64
90435: PUSH
90436: LD_VAR 0 3
90440: ARRAY
90441: IN
90442: IFFALSE 90497
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
90444: LD_ADDR_EXP 65
90448: PUSH
90449: LD_EXP 65
90453: PPUSH
90454: LD_VAR 0 3
90458: PPUSH
90459: LD_EXP 65
90463: PUSH
90464: LD_VAR 0 3
90468: ARRAY
90469: PPUSH
90470: LD_INT 1
90472: PPUSH
90473: LD_EXP 65
90477: PUSH
90478: LD_VAR 0 3
90482: ARRAY
90483: PPUSH
90484: LD_INT 0
90486: PPUSH
90487: CALL 24439 0 4
90491: PPUSH
90492: CALL_OW 1
90496: ST_TO_ADDR
// if not building in mc_bases [ i ] then
90497: LD_VAR 0 1
90501: PUSH
90502: LD_EXP 31
90506: PUSH
90507: LD_VAR 0 3
90511: ARRAY
90512: IN
90513: NOT
90514: IFFALSE 90560
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
90516: LD_ADDR_EXP 31
90520: PUSH
90521: LD_EXP 31
90525: PPUSH
90526: LD_VAR 0 3
90530: PUSH
90531: LD_EXP 31
90535: PUSH
90536: LD_VAR 0 3
90540: ARRAY
90541: PUSH
90542: LD_INT 1
90544: PLUS
90545: PUSH
90546: EMPTY
90547: LIST
90548: LIST
90549: PPUSH
90550: LD_VAR 0 1
90554: PPUSH
90555: CALL 25021 0 3
90559: ST_TO_ADDR
// exit ;
90560: POP
90561: POP
90562: GO 90568
// end ; end ;
90564: GO 90368
90566: POP
90567: POP
// end ;
90568: LD_VAR 0 2
90572: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
90573: LD_INT 0
90575: PPUSH
90576: PPUSH
90577: PPUSH
90578: PPUSH
90579: PPUSH
90580: PPUSH
90581: PPUSH
// if not mc_bases or not skirmish then
90582: LD_EXP 31
90586: NOT
90587: PUSH
90588: LD_EXP 29
90592: NOT
90593: OR
90594: IFFALSE 90598
// exit ;
90596: GO 91259
// for i = 1 to mc_bases do
90598: LD_ADDR_VAR 0 3
90602: PUSH
90603: DOUBLE
90604: LD_INT 1
90606: DEC
90607: ST_TO_ADDR
90608: LD_EXP 31
90612: PUSH
90613: FOR_TO
90614: IFFALSE 91257
// begin if building in mc_construct_list [ i ] then
90616: LD_VAR 0 1
90620: PUSH
90621: LD_EXP 38
90625: PUSH
90626: LD_VAR 0 3
90630: ARRAY
90631: IN
90632: IFFALSE 91255
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
90634: LD_ADDR_EXP 38
90638: PUSH
90639: LD_EXP 38
90643: PPUSH
90644: LD_VAR 0 3
90648: PPUSH
90649: LD_EXP 38
90653: PUSH
90654: LD_VAR 0 3
90658: ARRAY
90659: PUSH
90660: LD_VAR 0 1
90664: DIFF
90665: PPUSH
90666: CALL_OW 1
90670: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
90671: LD_ADDR_EXP 31
90675: PUSH
90676: LD_EXP 31
90680: PPUSH
90681: LD_VAR 0 3
90685: PUSH
90686: LD_EXP 31
90690: PUSH
90691: LD_VAR 0 3
90695: ARRAY
90696: PUSH
90697: LD_INT 1
90699: PLUS
90700: PUSH
90701: EMPTY
90702: LIST
90703: LIST
90704: PPUSH
90705: LD_VAR 0 1
90709: PPUSH
90710: CALL 25021 0 3
90714: ST_TO_ADDR
// btype := GetBType ( building ) ;
90715: LD_ADDR_VAR 0 5
90719: PUSH
90720: LD_VAR 0 1
90724: PPUSH
90725: CALL_OW 266
90729: ST_TO_ADDR
// side := GetSide ( building ) ;
90730: LD_ADDR_VAR 0 8
90734: PUSH
90735: LD_VAR 0 1
90739: PPUSH
90740: CALL_OW 255
90744: ST_TO_ADDR
// if btype = b_lab then
90745: LD_VAR 0 5
90749: PUSH
90750: LD_INT 6
90752: EQUAL
90753: IFFALSE 90803
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
90755: LD_ADDR_EXP 64
90759: PUSH
90760: LD_EXP 64
90764: PPUSH
90765: LD_VAR 0 3
90769: PUSH
90770: LD_EXP 64
90774: PUSH
90775: LD_VAR 0 3
90779: ARRAY
90780: PUSH
90781: LD_INT 1
90783: PLUS
90784: PUSH
90785: EMPTY
90786: LIST
90787: LIST
90788: PPUSH
90789: LD_VAR 0 1
90793: PPUSH
90794: CALL 25021 0 3
90798: ST_TO_ADDR
// exit ;
90799: POP
90800: POP
90801: GO 91259
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
90803: LD_VAR 0 5
90807: PUSH
90808: LD_INT 0
90810: PUSH
90811: LD_INT 2
90813: PUSH
90814: LD_INT 4
90816: PUSH
90817: EMPTY
90818: LIST
90819: LIST
90820: LIST
90821: IN
90822: IFFALSE 90946
// begin if btype = b_armoury then
90824: LD_VAR 0 5
90828: PUSH
90829: LD_INT 4
90831: EQUAL
90832: IFFALSE 90842
// btype := b_barracks ;
90834: LD_ADDR_VAR 0 5
90838: PUSH
90839: LD_INT 5
90841: ST_TO_ADDR
// if btype = b_depot then
90842: LD_VAR 0 5
90846: PUSH
90847: LD_INT 0
90849: EQUAL
90850: IFFALSE 90860
// btype := b_warehouse ;
90852: LD_ADDR_VAR 0 5
90856: PUSH
90857: LD_INT 1
90859: ST_TO_ADDR
// if btype = b_workshop then
90860: LD_VAR 0 5
90864: PUSH
90865: LD_INT 2
90867: EQUAL
90868: IFFALSE 90878
// btype := b_factory ;
90870: LD_ADDR_VAR 0 5
90874: PUSH
90875: LD_INT 3
90877: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
90878: LD_VAR 0 5
90882: PPUSH
90883: LD_VAR 0 8
90887: PPUSH
90888: CALL_OW 323
90892: PUSH
90893: LD_INT 1
90895: EQUAL
90896: IFFALSE 90942
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
90898: LD_ADDR_EXP 63
90902: PUSH
90903: LD_EXP 63
90907: PPUSH
90908: LD_VAR 0 3
90912: PUSH
90913: LD_EXP 63
90917: PUSH
90918: LD_VAR 0 3
90922: ARRAY
90923: PUSH
90924: LD_INT 1
90926: PLUS
90927: PUSH
90928: EMPTY
90929: LIST
90930: LIST
90931: PPUSH
90932: LD_VAR 0 1
90936: PPUSH
90937: CALL 25021 0 3
90941: ST_TO_ADDR
// exit ;
90942: POP
90943: POP
90944: GO 91259
// end ; if btype in [ b_bunker , b_turret ] then
90946: LD_VAR 0 5
90950: PUSH
90951: LD_INT 32
90953: PUSH
90954: LD_INT 33
90956: PUSH
90957: EMPTY
90958: LIST
90959: LIST
90960: IN
90961: IFFALSE 91251
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
90963: LD_ADDR_EXP 39
90967: PUSH
90968: LD_EXP 39
90972: PPUSH
90973: LD_VAR 0 3
90977: PUSH
90978: LD_EXP 39
90982: PUSH
90983: LD_VAR 0 3
90987: ARRAY
90988: PUSH
90989: LD_INT 1
90991: PLUS
90992: PUSH
90993: EMPTY
90994: LIST
90995: LIST
90996: PPUSH
90997: LD_VAR 0 1
91001: PPUSH
91002: CALL 25021 0 3
91006: ST_TO_ADDR
// if btype = b_bunker then
91007: LD_VAR 0 5
91011: PUSH
91012: LD_INT 32
91014: EQUAL
91015: IFFALSE 91251
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
91017: LD_ADDR_EXP 40
91021: PUSH
91022: LD_EXP 40
91026: PPUSH
91027: LD_VAR 0 3
91031: PUSH
91032: LD_EXP 40
91036: PUSH
91037: LD_VAR 0 3
91041: ARRAY
91042: PUSH
91043: LD_INT 1
91045: PLUS
91046: PUSH
91047: EMPTY
91048: LIST
91049: LIST
91050: PPUSH
91051: LD_VAR 0 1
91055: PPUSH
91056: CALL 25021 0 3
91060: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
91061: LD_ADDR_VAR 0 6
91065: PUSH
91066: LD_EXP 31
91070: PUSH
91071: LD_VAR 0 3
91075: ARRAY
91076: PPUSH
91077: LD_INT 25
91079: PUSH
91080: LD_INT 1
91082: PUSH
91083: EMPTY
91084: LIST
91085: LIST
91086: PUSH
91087: LD_INT 3
91089: PUSH
91090: LD_INT 54
91092: PUSH
91093: EMPTY
91094: LIST
91095: PUSH
91096: EMPTY
91097: LIST
91098: LIST
91099: PUSH
91100: EMPTY
91101: LIST
91102: LIST
91103: PPUSH
91104: CALL_OW 72
91108: ST_TO_ADDR
// if tmp then
91109: LD_VAR 0 6
91113: IFFALSE 91119
// exit ;
91115: POP
91116: POP
91117: GO 91259
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
91119: LD_ADDR_VAR 0 6
91123: PUSH
91124: LD_EXP 31
91128: PUSH
91129: LD_VAR 0 3
91133: ARRAY
91134: PPUSH
91135: LD_INT 2
91137: PUSH
91138: LD_INT 30
91140: PUSH
91141: LD_INT 4
91143: PUSH
91144: EMPTY
91145: LIST
91146: LIST
91147: PUSH
91148: LD_INT 30
91150: PUSH
91151: LD_INT 5
91153: PUSH
91154: EMPTY
91155: LIST
91156: LIST
91157: PUSH
91158: EMPTY
91159: LIST
91160: LIST
91161: LIST
91162: PPUSH
91163: CALL_OW 72
91167: ST_TO_ADDR
// if not tmp then
91168: LD_VAR 0 6
91172: NOT
91173: IFFALSE 91179
// exit ;
91175: POP
91176: POP
91177: GO 91259
// for j in tmp do
91179: LD_ADDR_VAR 0 4
91183: PUSH
91184: LD_VAR 0 6
91188: PUSH
91189: FOR_IN
91190: IFFALSE 91249
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
91192: LD_ADDR_VAR 0 7
91196: PUSH
91197: LD_VAR 0 4
91201: PPUSH
91202: CALL_OW 313
91206: PPUSH
91207: LD_INT 25
91209: PUSH
91210: LD_INT 1
91212: PUSH
91213: EMPTY
91214: LIST
91215: LIST
91216: PPUSH
91217: CALL_OW 72
91221: ST_TO_ADDR
// if units then
91222: LD_VAR 0 7
91226: IFFALSE 91247
// begin ComExitBuilding ( units [ 1 ] ) ;
91228: LD_VAR 0 7
91232: PUSH
91233: LD_INT 1
91235: ARRAY
91236: PPUSH
91237: CALL_OW 122
// exit ;
91241: POP
91242: POP
91243: POP
91244: POP
91245: GO 91259
// end ; end ;
91247: GO 91189
91249: POP
91250: POP
// end ; end ; exit ;
91251: POP
91252: POP
91253: GO 91259
// end ; end ;
91255: GO 90613
91257: POP
91258: POP
// end ;
91259: LD_VAR 0 2
91263: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
91264: LD_INT 0
91266: PPUSH
91267: PPUSH
91268: PPUSH
91269: PPUSH
91270: PPUSH
91271: PPUSH
91272: PPUSH
// if not mc_bases or not skirmish then
91273: LD_EXP 31
91277: NOT
91278: PUSH
91279: LD_EXP 29
91283: NOT
91284: OR
91285: IFFALSE 91289
// exit ;
91287: GO 91554
// btype := GetBType ( building ) ;
91289: LD_ADDR_VAR 0 6
91293: PUSH
91294: LD_VAR 0 1
91298: PPUSH
91299: CALL_OW 266
91303: ST_TO_ADDR
// x := GetX ( building ) ;
91304: LD_ADDR_VAR 0 7
91308: PUSH
91309: LD_VAR 0 1
91313: PPUSH
91314: CALL_OW 250
91318: ST_TO_ADDR
// y := GetY ( building ) ;
91319: LD_ADDR_VAR 0 8
91323: PUSH
91324: LD_VAR 0 1
91328: PPUSH
91329: CALL_OW 251
91333: ST_TO_ADDR
// d := GetDir ( building ) ;
91334: LD_ADDR_VAR 0 9
91338: PUSH
91339: LD_VAR 0 1
91343: PPUSH
91344: CALL_OW 254
91348: ST_TO_ADDR
// for i = 1 to mc_bases do
91349: LD_ADDR_VAR 0 4
91353: PUSH
91354: DOUBLE
91355: LD_INT 1
91357: DEC
91358: ST_TO_ADDR
91359: LD_EXP 31
91363: PUSH
91364: FOR_TO
91365: IFFALSE 91552
// begin if not mc_build_list [ i ] then
91367: LD_EXP 36
91371: PUSH
91372: LD_VAR 0 4
91376: ARRAY
91377: NOT
91378: IFFALSE 91382
// continue ;
91380: GO 91364
// for j := 1 to mc_build_list [ i ] do
91382: LD_ADDR_VAR 0 5
91386: PUSH
91387: DOUBLE
91388: LD_INT 1
91390: DEC
91391: ST_TO_ADDR
91392: LD_EXP 36
91396: PUSH
91397: LD_VAR 0 4
91401: ARRAY
91402: PUSH
91403: FOR_TO
91404: IFFALSE 91548
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ j ] ) then
91406: LD_VAR 0 6
91410: PUSH
91411: LD_VAR 0 7
91415: PUSH
91416: LD_VAR 0 8
91420: PUSH
91421: LD_VAR 0 9
91425: PUSH
91426: EMPTY
91427: LIST
91428: LIST
91429: LIST
91430: LIST
91431: PPUSH
91432: LD_EXP 36
91436: PUSH
91437: LD_VAR 0 4
91441: ARRAY
91442: PUSH
91443: LD_VAR 0 5
91447: ARRAY
91448: PPUSH
91449: CALL 31201 0 2
91453: IFFALSE 91546
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , j ) ) ;
91455: LD_ADDR_EXP 36
91459: PUSH
91460: LD_EXP 36
91464: PPUSH
91465: LD_VAR 0 4
91469: PPUSH
91470: LD_EXP 36
91474: PUSH
91475: LD_VAR 0 4
91479: ARRAY
91480: PPUSH
91481: LD_VAR 0 5
91485: PPUSH
91486: CALL_OW 3
91490: PPUSH
91491: CALL_OW 1
91495: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
91496: LD_ADDR_EXP 38
91500: PUSH
91501: LD_EXP 38
91505: PPUSH
91506: LD_VAR 0 4
91510: PUSH
91511: LD_EXP 38
91515: PUSH
91516: LD_VAR 0 4
91520: ARRAY
91521: PUSH
91522: LD_INT 1
91524: PLUS
91525: PUSH
91526: EMPTY
91527: LIST
91528: LIST
91529: PPUSH
91530: LD_VAR 0 1
91534: PPUSH
91535: CALL 25021 0 3
91539: ST_TO_ADDR
// exit ;
91540: POP
91541: POP
91542: POP
91543: POP
91544: GO 91554
// end ;
91546: GO 91403
91548: POP
91549: POP
// end ;
91550: GO 91364
91552: POP
91553: POP
// end ;
91554: LD_VAR 0 3
91558: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
91559: LD_INT 0
91561: PPUSH
91562: PPUSH
91563: PPUSH
// if not mc_bases or not skirmish then
91564: LD_EXP 31
91568: NOT
91569: PUSH
91570: LD_EXP 29
91574: NOT
91575: OR
91576: IFFALSE 91580
// exit ;
91578: GO 91770
// for i = 1 to mc_bases do
91580: LD_ADDR_VAR 0 4
91584: PUSH
91585: DOUBLE
91586: LD_INT 1
91588: DEC
91589: ST_TO_ADDR
91590: LD_EXP 31
91594: PUSH
91595: FOR_TO
91596: IFFALSE 91683
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
91598: LD_VAR 0 1
91602: PUSH
91603: LD_EXP 39
91607: PUSH
91608: LD_VAR 0 4
91612: ARRAY
91613: IN
91614: PUSH
91615: LD_VAR 0 1
91619: PUSH
91620: LD_EXP 40
91624: PUSH
91625: LD_VAR 0 4
91629: ARRAY
91630: IN
91631: NOT
91632: AND
91633: IFFALSE 91681
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
91635: LD_ADDR_EXP 40
91639: PUSH
91640: LD_EXP 40
91644: PPUSH
91645: LD_VAR 0 4
91649: PUSH
91650: LD_EXP 40
91654: PUSH
91655: LD_VAR 0 4
91659: ARRAY
91660: PUSH
91661: LD_INT 1
91663: PLUS
91664: PUSH
91665: EMPTY
91666: LIST
91667: LIST
91668: PPUSH
91669: LD_VAR 0 1
91673: PPUSH
91674: CALL 25021 0 3
91678: ST_TO_ADDR
// break ;
91679: GO 91683
// end ; end ;
91681: GO 91595
91683: POP
91684: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
91685: LD_VAR 0 1
91689: PPUSH
91690: CALL_OW 257
91694: PUSH
91695: LD_EXP 57
91699: IN
91700: PUSH
91701: LD_VAR 0 1
91705: PPUSH
91706: CALL_OW 266
91710: PUSH
91711: LD_INT 5
91713: EQUAL
91714: AND
91715: PUSH
91716: LD_VAR 0 2
91720: PPUSH
91721: CALL_OW 110
91725: PUSH
91726: LD_INT 18
91728: NONEQUAL
91729: AND
91730: IFFALSE 91770
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
91732: LD_VAR 0 2
91736: PPUSH
91737: CALL_OW 257
91741: PUSH
91742: LD_INT 5
91744: PUSH
91745: LD_INT 8
91747: PUSH
91748: LD_INT 9
91750: PUSH
91751: EMPTY
91752: LIST
91753: LIST
91754: LIST
91755: IN
91756: IFFALSE 91770
// SetClass ( unit , 1 ) ;
91758: LD_VAR 0 2
91762: PPUSH
91763: LD_INT 1
91765: PPUSH
91766: CALL_OW 336
// end ;
91770: LD_VAR 0 3
91774: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
91775: LD_INT 0
91777: PPUSH
91778: PPUSH
// if not mc_bases or not skirmish then
91779: LD_EXP 31
91783: NOT
91784: PUSH
91785: LD_EXP 29
91789: NOT
91790: OR
91791: IFFALSE 91795
// exit ;
91793: GO 91911
// if GetLives ( abandoned_vehicle ) > 250 then
91795: LD_VAR 0 2
91799: PPUSH
91800: CALL_OW 256
91804: PUSH
91805: LD_INT 250
91807: GREATER
91808: IFFALSE 91812
// exit ;
91810: GO 91911
// for i = 1 to mc_bases do
91812: LD_ADDR_VAR 0 6
91816: PUSH
91817: DOUBLE
91818: LD_INT 1
91820: DEC
91821: ST_TO_ADDR
91822: LD_EXP 31
91826: PUSH
91827: FOR_TO
91828: IFFALSE 91909
// begin if driver in mc_bases [ i ] then
91830: LD_VAR 0 1
91834: PUSH
91835: LD_EXP 31
91839: PUSH
91840: LD_VAR 0 6
91844: ARRAY
91845: IN
91846: IFFALSE 91907
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
91848: LD_VAR 0 1
91852: PPUSH
91853: LD_EXP 31
91857: PUSH
91858: LD_VAR 0 6
91862: ARRAY
91863: PPUSH
91864: LD_INT 2
91866: PUSH
91867: LD_INT 30
91869: PUSH
91870: LD_INT 0
91872: PUSH
91873: EMPTY
91874: LIST
91875: LIST
91876: PUSH
91877: LD_INT 30
91879: PUSH
91880: LD_INT 1
91882: PUSH
91883: EMPTY
91884: LIST
91885: LIST
91886: PUSH
91887: EMPTY
91888: LIST
91889: LIST
91890: LIST
91891: PPUSH
91892: CALL_OW 72
91896: PUSH
91897: LD_INT 1
91899: ARRAY
91900: PPUSH
91901: CALL 58210 0 2
// break ;
91905: GO 91909
// end ; end ;
91907: GO 91827
91909: POP
91910: POP
// end ; end_of_file end_of_file
91911: LD_VAR 0 5
91915: RET
// every 0 0$1 do
91916: GO 91918
91918: DISABLE
// begin enable ;
91919: ENABLE
// ToLua ( updateTimer( & tick & ); ) ;
91920: LD_STRING updateTimer(
91922: PUSH
91923: LD_OWVAR 1
91927: STR
91928: PUSH
91929: LD_STRING );
91931: STR
91932: PPUSH
91933: CALL_OW 559
// end ;
91937: END
// export function SOS_MapStart ( ) ; begin
91938: LD_INT 0
91940: PPUSH
// if streamModeActive then
91941: LD_EXP 75
91945: IFFALSE 91954
// DefineStreamItems ( true ) ;
91947: LD_INT 1
91949: PPUSH
91950: CALL 93608 0 1
// UpdateFactoryWaypoints ( ) ;
91954: CALL 106469 0 0
// UpdateWarehouseGatheringPoints ( ) ;
91958: CALL 106726 0 0
// end ;
91962: LD_VAR 0 1
91966: RET
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
91967: LD_INT 0
91969: PPUSH
// if p2 = hack_mode then
91970: LD_VAR 0 2
91974: PUSH
91975: LD_INT 100
91977: EQUAL
91978: IFFALSE 92981
// begin if not StreamModeActive then
91980: LD_EXP 75
91984: NOT
91985: IFFALSE 91995
// StreamModeActive := true ;
91987: LD_ADDR_EXP 75
91991: PUSH
91992: LD_INT 1
91994: ST_TO_ADDR
// if p3 = 0 then
91995: LD_VAR 0 3
91999: PUSH
92000: LD_INT 0
92002: EQUAL
92003: IFFALSE 92009
// InitStreamMode ;
92005: CALL 93144 0 0
// if p3 = 1 then
92009: LD_VAR 0 3
92013: PUSH
92014: LD_INT 1
92016: EQUAL
92017: IFFALSE 92027
// sRocket := true ;
92019: LD_ADDR_EXP 80
92023: PUSH
92024: LD_INT 1
92026: ST_TO_ADDR
// if p3 = 2 then
92027: LD_VAR 0 3
92031: PUSH
92032: LD_INT 2
92034: EQUAL
92035: IFFALSE 92045
// sSpeed := true ;
92037: LD_ADDR_EXP 79
92041: PUSH
92042: LD_INT 1
92044: ST_TO_ADDR
// if p3 = 3 then
92045: LD_VAR 0 3
92049: PUSH
92050: LD_INT 3
92052: EQUAL
92053: IFFALSE 92063
// sEngine := true ;
92055: LD_ADDR_EXP 81
92059: PUSH
92060: LD_INT 1
92062: ST_TO_ADDR
// if p3 = 4 then
92063: LD_VAR 0 3
92067: PUSH
92068: LD_INT 4
92070: EQUAL
92071: IFFALSE 92081
// sSpec := true ;
92073: LD_ADDR_EXP 78
92077: PUSH
92078: LD_INT 1
92080: ST_TO_ADDR
// if p3 = 5 then
92081: LD_VAR 0 3
92085: PUSH
92086: LD_INT 5
92088: EQUAL
92089: IFFALSE 92099
// sLevel := true ;
92091: LD_ADDR_EXP 82
92095: PUSH
92096: LD_INT 1
92098: ST_TO_ADDR
// if p3 = 6 then
92099: LD_VAR 0 3
92103: PUSH
92104: LD_INT 6
92106: EQUAL
92107: IFFALSE 92117
// sArmoury := true ;
92109: LD_ADDR_EXP 83
92113: PUSH
92114: LD_INT 1
92116: ST_TO_ADDR
// if p3 = 7 then
92117: LD_VAR 0 3
92121: PUSH
92122: LD_INT 7
92124: EQUAL
92125: IFFALSE 92135
// sRadar := true ;
92127: LD_ADDR_EXP 84
92131: PUSH
92132: LD_INT 1
92134: ST_TO_ADDR
// if p3 = 8 then
92135: LD_VAR 0 3
92139: PUSH
92140: LD_INT 8
92142: EQUAL
92143: IFFALSE 92153
// sBunker := true ;
92145: LD_ADDR_EXP 85
92149: PUSH
92150: LD_INT 1
92152: ST_TO_ADDR
// if p3 = 9 then
92153: LD_VAR 0 3
92157: PUSH
92158: LD_INT 9
92160: EQUAL
92161: IFFALSE 92171
// sHack := true ;
92163: LD_ADDR_EXP 86
92167: PUSH
92168: LD_INT 1
92170: ST_TO_ADDR
// if p3 = 10 then
92171: LD_VAR 0 3
92175: PUSH
92176: LD_INT 10
92178: EQUAL
92179: IFFALSE 92189
// sFire := true ;
92181: LD_ADDR_EXP 87
92185: PUSH
92186: LD_INT 1
92188: ST_TO_ADDR
// if p3 = 11 then
92189: LD_VAR 0 3
92193: PUSH
92194: LD_INT 11
92196: EQUAL
92197: IFFALSE 92207
// sRefresh := true ;
92199: LD_ADDR_EXP 88
92203: PUSH
92204: LD_INT 1
92206: ST_TO_ADDR
// if p3 = 12 then
92207: LD_VAR 0 3
92211: PUSH
92212: LD_INT 12
92214: EQUAL
92215: IFFALSE 92225
// sExp := true ;
92217: LD_ADDR_EXP 89
92221: PUSH
92222: LD_INT 1
92224: ST_TO_ADDR
// if p3 = 13 then
92225: LD_VAR 0 3
92229: PUSH
92230: LD_INT 13
92232: EQUAL
92233: IFFALSE 92243
// sDepot := true ;
92235: LD_ADDR_EXP 90
92239: PUSH
92240: LD_INT 1
92242: ST_TO_ADDR
// if p3 = 14 then
92243: LD_VAR 0 3
92247: PUSH
92248: LD_INT 14
92250: EQUAL
92251: IFFALSE 92261
// sFlag := true ;
92253: LD_ADDR_EXP 91
92257: PUSH
92258: LD_INT 1
92260: ST_TO_ADDR
// if p3 = 15 then
92261: LD_VAR 0 3
92265: PUSH
92266: LD_INT 15
92268: EQUAL
92269: IFFALSE 92279
// sKamikadze := true ;
92271: LD_ADDR_EXP 99
92275: PUSH
92276: LD_INT 1
92278: ST_TO_ADDR
// if p3 = 16 then
92279: LD_VAR 0 3
92283: PUSH
92284: LD_INT 16
92286: EQUAL
92287: IFFALSE 92297
// sTroll := true ;
92289: LD_ADDR_EXP 100
92293: PUSH
92294: LD_INT 1
92296: ST_TO_ADDR
// if p3 = 17 then
92297: LD_VAR 0 3
92301: PUSH
92302: LD_INT 17
92304: EQUAL
92305: IFFALSE 92315
// sSlow := true ;
92307: LD_ADDR_EXP 101
92311: PUSH
92312: LD_INT 1
92314: ST_TO_ADDR
// if p3 = 18 then
92315: LD_VAR 0 3
92319: PUSH
92320: LD_INT 18
92322: EQUAL
92323: IFFALSE 92333
// sLack := true ;
92325: LD_ADDR_EXP 102
92329: PUSH
92330: LD_INT 1
92332: ST_TO_ADDR
// if p3 = 19 then
92333: LD_VAR 0 3
92337: PUSH
92338: LD_INT 19
92340: EQUAL
92341: IFFALSE 92351
// sTank := true ;
92343: LD_ADDR_EXP 104
92347: PUSH
92348: LD_INT 1
92350: ST_TO_ADDR
// if p3 = 20 then
92351: LD_VAR 0 3
92355: PUSH
92356: LD_INT 20
92358: EQUAL
92359: IFFALSE 92369
// sRemote := true ;
92361: LD_ADDR_EXP 105
92365: PUSH
92366: LD_INT 1
92368: ST_TO_ADDR
// if p3 = 21 then
92369: LD_VAR 0 3
92373: PUSH
92374: LD_INT 21
92376: EQUAL
92377: IFFALSE 92387
// sPowell := true ;
92379: LD_ADDR_EXP 106
92383: PUSH
92384: LD_INT 1
92386: ST_TO_ADDR
// if p3 = 22 then
92387: LD_VAR 0 3
92391: PUSH
92392: LD_INT 22
92394: EQUAL
92395: IFFALSE 92405
// sTeleport := true ;
92397: LD_ADDR_EXP 109
92401: PUSH
92402: LD_INT 1
92404: ST_TO_ADDR
// if p3 = 23 then
92405: LD_VAR 0 3
92409: PUSH
92410: LD_INT 23
92412: EQUAL
92413: IFFALSE 92423
// sOilTower := true ;
92415: LD_ADDR_EXP 111
92419: PUSH
92420: LD_INT 1
92422: ST_TO_ADDR
// if p3 = 24 then
92423: LD_VAR 0 3
92427: PUSH
92428: LD_INT 24
92430: EQUAL
92431: IFFALSE 92441
// sShovel := true ;
92433: LD_ADDR_EXP 112
92437: PUSH
92438: LD_INT 1
92440: ST_TO_ADDR
// if p3 = 25 then
92441: LD_VAR 0 3
92445: PUSH
92446: LD_INT 25
92448: EQUAL
92449: IFFALSE 92459
// sSheik := true ;
92451: LD_ADDR_EXP 113
92455: PUSH
92456: LD_INT 1
92458: ST_TO_ADDR
// if p3 = 26 then
92459: LD_VAR 0 3
92463: PUSH
92464: LD_INT 26
92466: EQUAL
92467: IFFALSE 92477
// sEarthquake := true ;
92469: LD_ADDR_EXP 115
92473: PUSH
92474: LD_INT 1
92476: ST_TO_ADDR
// if p3 = 27 then
92477: LD_VAR 0 3
92481: PUSH
92482: LD_INT 27
92484: EQUAL
92485: IFFALSE 92495
// sAI := true ;
92487: LD_ADDR_EXP 116
92491: PUSH
92492: LD_INT 1
92494: ST_TO_ADDR
// if p3 = 28 then
92495: LD_VAR 0 3
92499: PUSH
92500: LD_INT 28
92502: EQUAL
92503: IFFALSE 92513
// sCargo := true ;
92505: LD_ADDR_EXP 119
92509: PUSH
92510: LD_INT 1
92512: ST_TO_ADDR
// if p3 = 29 then
92513: LD_VAR 0 3
92517: PUSH
92518: LD_INT 29
92520: EQUAL
92521: IFFALSE 92531
// sDLaser := true ;
92523: LD_ADDR_EXP 120
92527: PUSH
92528: LD_INT 1
92530: ST_TO_ADDR
// if p3 = 30 then
92531: LD_VAR 0 3
92535: PUSH
92536: LD_INT 30
92538: EQUAL
92539: IFFALSE 92549
// sExchange := true ;
92541: LD_ADDR_EXP 121
92545: PUSH
92546: LD_INT 1
92548: ST_TO_ADDR
// if p3 = 31 then
92549: LD_VAR 0 3
92553: PUSH
92554: LD_INT 31
92556: EQUAL
92557: IFFALSE 92567
// sFac := true ;
92559: LD_ADDR_EXP 122
92563: PUSH
92564: LD_INT 1
92566: ST_TO_ADDR
// if p3 = 32 then
92567: LD_VAR 0 3
92571: PUSH
92572: LD_INT 32
92574: EQUAL
92575: IFFALSE 92585
// sPower := true ;
92577: LD_ADDR_EXP 123
92581: PUSH
92582: LD_INT 1
92584: ST_TO_ADDR
// if p3 = 33 then
92585: LD_VAR 0 3
92589: PUSH
92590: LD_INT 33
92592: EQUAL
92593: IFFALSE 92603
// sRandom := true ;
92595: LD_ADDR_EXP 124
92599: PUSH
92600: LD_INT 1
92602: ST_TO_ADDR
// if p3 = 34 then
92603: LD_VAR 0 3
92607: PUSH
92608: LD_INT 34
92610: EQUAL
92611: IFFALSE 92621
// sShield := true ;
92613: LD_ADDR_EXP 125
92617: PUSH
92618: LD_INT 1
92620: ST_TO_ADDR
// if p3 = 35 then
92621: LD_VAR 0 3
92625: PUSH
92626: LD_INT 35
92628: EQUAL
92629: IFFALSE 92639
// sTime := true ;
92631: LD_ADDR_EXP 126
92635: PUSH
92636: LD_INT 1
92638: ST_TO_ADDR
// if p3 = 36 then
92639: LD_VAR 0 3
92643: PUSH
92644: LD_INT 36
92646: EQUAL
92647: IFFALSE 92657
// sTools := true ;
92649: LD_ADDR_EXP 127
92653: PUSH
92654: LD_INT 1
92656: ST_TO_ADDR
// if p3 = 101 then
92657: LD_VAR 0 3
92661: PUSH
92662: LD_INT 101
92664: EQUAL
92665: IFFALSE 92675
// sSold := true ;
92667: LD_ADDR_EXP 92
92671: PUSH
92672: LD_INT 1
92674: ST_TO_ADDR
// if p3 = 102 then
92675: LD_VAR 0 3
92679: PUSH
92680: LD_INT 102
92682: EQUAL
92683: IFFALSE 92693
// sDiff := true ;
92685: LD_ADDR_EXP 93
92689: PUSH
92690: LD_INT 1
92692: ST_TO_ADDR
// if p3 = 103 then
92693: LD_VAR 0 3
92697: PUSH
92698: LD_INT 103
92700: EQUAL
92701: IFFALSE 92711
// sFog := true ;
92703: LD_ADDR_EXP 96
92707: PUSH
92708: LD_INT 1
92710: ST_TO_ADDR
// if p3 = 104 then
92711: LD_VAR 0 3
92715: PUSH
92716: LD_INT 104
92718: EQUAL
92719: IFFALSE 92729
// sReset := true ;
92721: LD_ADDR_EXP 97
92725: PUSH
92726: LD_INT 1
92728: ST_TO_ADDR
// if p3 = 105 then
92729: LD_VAR 0 3
92733: PUSH
92734: LD_INT 105
92736: EQUAL
92737: IFFALSE 92747
// sSun := true ;
92739: LD_ADDR_EXP 98
92743: PUSH
92744: LD_INT 1
92746: ST_TO_ADDR
// if p3 = 106 then
92747: LD_VAR 0 3
92751: PUSH
92752: LD_INT 106
92754: EQUAL
92755: IFFALSE 92765
// sTiger := true ;
92757: LD_ADDR_EXP 94
92761: PUSH
92762: LD_INT 1
92764: ST_TO_ADDR
// if p3 = 107 then
92765: LD_VAR 0 3
92769: PUSH
92770: LD_INT 107
92772: EQUAL
92773: IFFALSE 92783
// sBomb := true ;
92775: LD_ADDR_EXP 95
92779: PUSH
92780: LD_INT 1
92782: ST_TO_ADDR
// if p3 = 108 then
92783: LD_VAR 0 3
92787: PUSH
92788: LD_INT 108
92790: EQUAL
92791: IFFALSE 92801
// sWound := true ;
92793: LD_ADDR_EXP 103
92797: PUSH
92798: LD_INT 1
92800: ST_TO_ADDR
// if p3 = 109 then
92801: LD_VAR 0 3
92805: PUSH
92806: LD_INT 109
92808: EQUAL
92809: IFFALSE 92819
// sBetray := true ;
92811: LD_ADDR_EXP 107
92815: PUSH
92816: LD_INT 1
92818: ST_TO_ADDR
// if p3 = 110 then
92819: LD_VAR 0 3
92823: PUSH
92824: LD_INT 110
92826: EQUAL
92827: IFFALSE 92837
// sContamin := true ;
92829: LD_ADDR_EXP 108
92833: PUSH
92834: LD_INT 1
92836: ST_TO_ADDR
// if p3 = 111 then
92837: LD_VAR 0 3
92841: PUSH
92842: LD_INT 111
92844: EQUAL
92845: IFFALSE 92855
// sOil := true ;
92847: LD_ADDR_EXP 110
92851: PUSH
92852: LD_INT 1
92854: ST_TO_ADDR
// if p3 = 112 then
92855: LD_VAR 0 3
92859: PUSH
92860: LD_INT 112
92862: EQUAL
92863: IFFALSE 92873
// sStu := true ;
92865: LD_ADDR_EXP 114
92869: PUSH
92870: LD_INT 1
92872: ST_TO_ADDR
// if p3 = 113 then
92873: LD_VAR 0 3
92877: PUSH
92878: LD_INT 113
92880: EQUAL
92881: IFFALSE 92891
// sBazooka := true ;
92883: LD_ADDR_EXP 117
92887: PUSH
92888: LD_INT 1
92890: ST_TO_ADDR
// if p3 = 114 then
92891: LD_VAR 0 3
92895: PUSH
92896: LD_INT 114
92898: EQUAL
92899: IFFALSE 92909
// sMortar := true ;
92901: LD_ADDR_EXP 118
92905: PUSH
92906: LD_INT 1
92908: ST_TO_ADDR
// if p3 = 115 then
92909: LD_VAR 0 3
92913: PUSH
92914: LD_INT 115
92916: EQUAL
92917: IFFALSE 92927
// sRanger := true ;
92919: LD_ADDR_EXP 128
92923: PUSH
92924: LD_INT 1
92926: ST_TO_ADDR
// if p3 = 116 then
92927: LD_VAR 0 3
92931: PUSH
92932: LD_INT 116
92934: EQUAL
92935: IFFALSE 92945
// sComputer := true ;
92937: LD_ADDR_EXP 129
92941: PUSH
92942: LD_INT 1
92944: ST_TO_ADDR
// if p3 = 117 then
92945: LD_VAR 0 3
92949: PUSH
92950: LD_INT 117
92952: EQUAL
92953: IFFALSE 92963
// s30 := true ;
92955: LD_ADDR_EXP 130
92959: PUSH
92960: LD_INT 1
92962: ST_TO_ADDR
// if p3 = 118 then
92963: LD_VAR 0 3
92967: PUSH
92968: LD_INT 118
92970: EQUAL
92971: IFFALSE 92981
// s60 := true ;
92973: LD_ADDR_EXP 131
92977: PUSH
92978: LD_INT 1
92980: ST_TO_ADDR
// end ; if p2 = stream_mode then
92981: LD_VAR 0 2
92985: PUSH
92986: LD_INT 101
92988: EQUAL
92989: IFFALSE 93117
// begin case p3 of 1 :
92991: LD_VAR 0 3
92995: PUSH
92996: LD_INT 1
92998: DOUBLE
92999: EQUAL
93000: IFTRUE 93004
93002: GO 93011
93004: POP
// hHackUnlimitedResources ; 2 :
93005: CALL 105215 0 0
93009: GO 93117
93011: LD_INT 2
93013: DOUBLE
93014: EQUAL
93015: IFTRUE 93019
93017: GO 93026
93019: POP
// hHackSetLevel10 ; 3 :
93020: CALL 105348 0 0
93024: GO 93117
93026: LD_INT 3
93028: DOUBLE
93029: EQUAL
93030: IFTRUE 93034
93032: GO 93041
93034: POP
// hHackSetLevel10YourUnits ; 4 :
93035: CALL 105433 0 0
93039: GO 93117
93041: LD_INT 4
93043: DOUBLE
93044: EQUAL
93045: IFTRUE 93049
93047: GO 93056
93049: POP
// hHackInvincible ; 5 :
93050: CALL 105881 0 0
93054: GO 93117
93056: LD_INT 5
93058: DOUBLE
93059: EQUAL
93060: IFTRUE 93064
93062: GO 93071
93064: POP
// hHackInvisible ; 6 :
93065: CALL 105992 0 0
93069: GO 93117
93071: LD_INT 6
93073: DOUBLE
93074: EQUAL
93075: IFTRUE 93079
93077: GO 93086
93079: POP
// hHackChangeYourSide ; 7 :
93080: CALL 106049 0 0
93084: GO 93117
93086: LD_INT 7
93088: DOUBLE
93089: EQUAL
93090: IFTRUE 93094
93092: GO 93101
93094: POP
// hHackChangeUnitSide ; 8 :
93095: CALL 106091 0 0
93099: GO 93117
93101: LD_INT 8
93103: DOUBLE
93104: EQUAL
93105: IFTRUE 93109
93107: GO 93116
93109: POP
// hHackFog ; end ;
93110: CALL 106192 0 0
93114: GO 93117
93116: POP
// end ; end ;
93117: LD_VAR 0 7
93121: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger , sComputer , s30 , s60 ; every 0 0$1 do
93122: GO 93124
93124: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
93125: LD_STRING initStreamRollete();
93127: PPUSH
93128: CALL_OW 559
// InitStreamMode ;
93132: CALL 93144 0 0
// DefineStreamItems ( false ) ;
93136: LD_INT 0
93138: PPUSH
93139: CALL 93608 0 1
// end ;
93143: END
// function InitStreamMode ; begin
93144: LD_INT 0
93146: PPUSH
// streamModeActive := false ;
93147: LD_ADDR_EXP 75
93151: PUSH
93152: LD_INT 0
93154: ST_TO_ADDR
// normalCounter := 36 ;
93155: LD_ADDR_EXP 76
93159: PUSH
93160: LD_INT 36
93162: ST_TO_ADDR
// hardcoreCounter := 18 ;
93163: LD_ADDR_EXP 77
93167: PUSH
93168: LD_INT 18
93170: ST_TO_ADDR
// sRocket := false ;
93171: LD_ADDR_EXP 80
93175: PUSH
93176: LD_INT 0
93178: ST_TO_ADDR
// sSpeed := false ;
93179: LD_ADDR_EXP 79
93183: PUSH
93184: LD_INT 0
93186: ST_TO_ADDR
// sEngine := false ;
93187: LD_ADDR_EXP 81
93191: PUSH
93192: LD_INT 0
93194: ST_TO_ADDR
// sSpec := false ;
93195: LD_ADDR_EXP 78
93199: PUSH
93200: LD_INT 0
93202: ST_TO_ADDR
// sLevel := false ;
93203: LD_ADDR_EXP 82
93207: PUSH
93208: LD_INT 0
93210: ST_TO_ADDR
// sArmoury := false ;
93211: LD_ADDR_EXP 83
93215: PUSH
93216: LD_INT 0
93218: ST_TO_ADDR
// sRadar := false ;
93219: LD_ADDR_EXP 84
93223: PUSH
93224: LD_INT 0
93226: ST_TO_ADDR
// sBunker := false ;
93227: LD_ADDR_EXP 85
93231: PUSH
93232: LD_INT 0
93234: ST_TO_ADDR
// sHack := false ;
93235: LD_ADDR_EXP 86
93239: PUSH
93240: LD_INT 0
93242: ST_TO_ADDR
// sFire := false ;
93243: LD_ADDR_EXP 87
93247: PUSH
93248: LD_INT 0
93250: ST_TO_ADDR
// sRefresh := false ;
93251: LD_ADDR_EXP 88
93255: PUSH
93256: LD_INT 0
93258: ST_TO_ADDR
// sExp := false ;
93259: LD_ADDR_EXP 89
93263: PUSH
93264: LD_INT 0
93266: ST_TO_ADDR
// sDepot := false ;
93267: LD_ADDR_EXP 90
93271: PUSH
93272: LD_INT 0
93274: ST_TO_ADDR
// sFlag := false ;
93275: LD_ADDR_EXP 91
93279: PUSH
93280: LD_INT 0
93282: ST_TO_ADDR
// sKamikadze := false ;
93283: LD_ADDR_EXP 99
93287: PUSH
93288: LD_INT 0
93290: ST_TO_ADDR
// sTroll := false ;
93291: LD_ADDR_EXP 100
93295: PUSH
93296: LD_INT 0
93298: ST_TO_ADDR
// sSlow := false ;
93299: LD_ADDR_EXP 101
93303: PUSH
93304: LD_INT 0
93306: ST_TO_ADDR
// sLack := false ;
93307: LD_ADDR_EXP 102
93311: PUSH
93312: LD_INT 0
93314: ST_TO_ADDR
// sTank := false ;
93315: LD_ADDR_EXP 104
93319: PUSH
93320: LD_INT 0
93322: ST_TO_ADDR
// sRemote := false ;
93323: LD_ADDR_EXP 105
93327: PUSH
93328: LD_INT 0
93330: ST_TO_ADDR
// sPowell := false ;
93331: LD_ADDR_EXP 106
93335: PUSH
93336: LD_INT 0
93338: ST_TO_ADDR
// sTeleport := false ;
93339: LD_ADDR_EXP 109
93343: PUSH
93344: LD_INT 0
93346: ST_TO_ADDR
// sOilTower := false ;
93347: LD_ADDR_EXP 111
93351: PUSH
93352: LD_INT 0
93354: ST_TO_ADDR
// sShovel := false ;
93355: LD_ADDR_EXP 112
93359: PUSH
93360: LD_INT 0
93362: ST_TO_ADDR
// sSheik := false ;
93363: LD_ADDR_EXP 113
93367: PUSH
93368: LD_INT 0
93370: ST_TO_ADDR
// sEarthquake := false ;
93371: LD_ADDR_EXP 115
93375: PUSH
93376: LD_INT 0
93378: ST_TO_ADDR
// sAI := false ;
93379: LD_ADDR_EXP 116
93383: PUSH
93384: LD_INT 0
93386: ST_TO_ADDR
// sCargo := false ;
93387: LD_ADDR_EXP 119
93391: PUSH
93392: LD_INT 0
93394: ST_TO_ADDR
// sDLaser := false ;
93395: LD_ADDR_EXP 120
93399: PUSH
93400: LD_INT 0
93402: ST_TO_ADDR
// sExchange := false ;
93403: LD_ADDR_EXP 121
93407: PUSH
93408: LD_INT 0
93410: ST_TO_ADDR
// sFac := false ;
93411: LD_ADDR_EXP 122
93415: PUSH
93416: LD_INT 0
93418: ST_TO_ADDR
// sPower := false ;
93419: LD_ADDR_EXP 123
93423: PUSH
93424: LD_INT 0
93426: ST_TO_ADDR
// sRandom := false ;
93427: LD_ADDR_EXP 124
93431: PUSH
93432: LD_INT 0
93434: ST_TO_ADDR
// sShield := false ;
93435: LD_ADDR_EXP 125
93439: PUSH
93440: LD_INT 0
93442: ST_TO_ADDR
// sTime := false ;
93443: LD_ADDR_EXP 126
93447: PUSH
93448: LD_INT 0
93450: ST_TO_ADDR
// sTools := false ;
93451: LD_ADDR_EXP 127
93455: PUSH
93456: LD_INT 0
93458: ST_TO_ADDR
// sSold := false ;
93459: LD_ADDR_EXP 92
93463: PUSH
93464: LD_INT 0
93466: ST_TO_ADDR
// sDiff := false ;
93467: LD_ADDR_EXP 93
93471: PUSH
93472: LD_INT 0
93474: ST_TO_ADDR
// sFog := false ;
93475: LD_ADDR_EXP 96
93479: PUSH
93480: LD_INT 0
93482: ST_TO_ADDR
// sReset := false ;
93483: LD_ADDR_EXP 97
93487: PUSH
93488: LD_INT 0
93490: ST_TO_ADDR
// sSun := false ;
93491: LD_ADDR_EXP 98
93495: PUSH
93496: LD_INT 0
93498: ST_TO_ADDR
// sTiger := false ;
93499: LD_ADDR_EXP 94
93503: PUSH
93504: LD_INT 0
93506: ST_TO_ADDR
// sBomb := false ;
93507: LD_ADDR_EXP 95
93511: PUSH
93512: LD_INT 0
93514: ST_TO_ADDR
// sWound := false ;
93515: LD_ADDR_EXP 103
93519: PUSH
93520: LD_INT 0
93522: ST_TO_ADDR
// sBetray := false ;
93523: LD_ADDR_EXP 107
93527: PUSH
93528: LD_INT 0
93530: ST_TO_ADDR
// sContamin := false ;
93531: LD_ADDR_EXP 108
93535: PUSH
93536: LD_INT 0
93538: ST_TO_ADDR
// sOil := false ;
93539: LD_ADDR_EXP 110
93543: PUSH
93544: LD_INT 0
93546: ST_TO_ADDR
// sStu := false ;
93547: LD_ADDR_EXP 114
93551: PUSH
93552: LD_INT 0
93554: ST_TO_ADDR
// sBazooka := false ;
93555: LD_ADDR_EXP 117
93559: PUSH
93560: LD_INT 0
93562: ST_TO_ADDR
// sMortar := false ;
93563: LD_ADDR_EXP 118
93567: PUSH
93568: LD_INT 0
93570: ST_TO_ADDR
// sRanger := false ;
93571: LD_ADDR_EXP 128
93575: PUSH
93576: LD_INT 0
93578: ST_TO_ADDR
// sComputer := false ;
93579: LD_ADDR_EXP 129
93583: PUSH
93584: LD_INT 0
93586: ST_TO_ADDR
// s30 := false ;
93587: LD_ADDR_EXP 130
93591: PUSH
93592: LD_INT 0
93594: ST_TO_ADDR
// s60 := false ;
93595: LD_ADDR_EXP 131
93599: PUSH
93600: LD_INT 0
93602: ST_TO_ADDR
// end ;
93603: LD_VAR 0 1
93607: RET
// function DefineStreamItems ( isGameLoad ) ; var tmp , flags , normal , hardcore , active , i ; begin
93608: LD_INT 0
93610: PPUSH
93611: PPUSH
93612: PPUSH
93613: PPUSH
93614: PPUSH
93615: PPUSH
93616: PPUSH
// result := [ ] ;
93617: LD_ADDR_VAR 0 2
93621: PUSH
93622: EMPTY
93623: ST_TO_ADDR
// if campaign_id = 1 then
93624: LD_OWVAR 69
93628: PUSH
93629: LD_INT 1
93631: EQUAL
93632: IFFALSE 96798
// begin case mission_number of 1 :
93634: LD_OWVAR 70
93638: PUSH
93639: LD_INT 1
93641: DOUBLE
93642: EQUAL
93643: IFTRUE 93647
93645: GO 93723
93647: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 , 116 , 117 , 118 ] ] ; 2 :
93648: LD_ADDR_VAR 0 2
93652: PUSH
93653: LD_INT 2
93655: PUSH
93656: LD_INT 4
93658: PUSH
93659: LD_INT 11
93661: PUSH
93662: LD_INT 12
93664: PUSH
93665: LD_INT 15
93667: PUSH
93668: LD_INT 16
93670: PUSH
93671: LD_INT 22
93673: PUSH
93674: LD_INT 23
93676: PUSH
93677: LD_INT 26
93679: PUSH
93680: EMPTY
93681: LIST
93682: LIST
93683: LIST
93684: LIST
93685: LIST
93686: LIST
93687: LIST
93688: LIST
93689: LIST
93690: PUSH
93691: LD_INT 101
93693: PUSH
93694: LD_INT 102
93696: PUSH
93697: LD_INT 106
93699: PUSH
93700: LD_INT 116
93702: PUSH
93703: LD_INT 117
93705: PUSH
93706: LD_INT 118
93708: PUSH
93709: EMPTY
93710: LIST
93711: LIST
93712: LIST
93713: LIST
93714: LIST
93715: LIST
93716: PUSH
93717: EMPTY
93718: LIST
93719: LIST
93720: ST_TO_ADDR
93721: GO 96796
93723: LD_INT 2
93725: DOUBLE
93726: EQUAL
93727: IFTRUE 93731
93729: GO 93815
93731: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 3 :
93732: LD_ADDR_VAR 0 2
93736: PUSH
93737: LD_INT 2
93739: PUSH
93740: LD_INT 4
93742: PUSH
93743: LD_INT 11
93745: PUSH
93746: LD_INT 12
93748: PUSH
93749: LD_INT 15
93751: PUSH
93752: LD_INT 16
93754: PUSH
93755: LD_INT 22
93757: PUSH
93758: LD_INT 23
93760: PUSH
93761: LD_INT 26
93763: PUSH
93764: EMPTY
93765: LIST
93766: LIST
93767: LIST
93768: LIST
93769: LIST
93770: LIST
93771: LIST
93772: LIST
93773: LIST
93774: PUSH
93775: LD_INT 101
93777: PUSH
93778: LD_INT 102
93780: PUSH
93781: LD_INT 105
93783: PUSH
93784: LD_INT 106
93786: PUSH
93787: LD_INT 108
93789: PUSH
93790: LD_INT 116
93792: PUSH
93793: LD_INT 117
93795: PUSH
93796: LD_INT 118
93798: PUSH
93799: EMPTY
93800: LIST
93801: LIST
93802: LIST
93803: LIST
93804: LIST
93805: LIST
93806: LIST
93807: LIST
93808: PUSH
93809: EMPTY
93810: LIST
93811: LIST
93812: ST_TO_ADDR
93813: GO 96796
93815: LD_INT 3
93817: DOUBLE
93818: EQUAL
93819: IFTRUE 93823
93821: GO 93911
93823: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 4 :
93824: LD_ADDR_VAR 0 2
93828: PUSH
93829: LD_INT 2
93831: PUSH
93832: LD_INT 4
93834: PUSH
93835: LD_INT 5
93837: PUSH
93838: LD_INT 11
93840: PUSH
93841: LD_INT 12
93843: PUSH
93844: LD_INT 15
93846: PUSH
93847: LD_INT 16
93849: PUSH
93850: LD_INT 22
93852: PUSH
93853: LD_INT 26
93855: PUSH
93856: LD_INT 36
93858: PUSH
93859: EMPTY
93860: LIST
93861: LIST
93862: LIST
93863: LIST
93864: LIST
93865: LIST
93866: LIST
93867: LIST
93868: LIST
93869: LIST
93870: PUSH
93871: LD_INT 101
93873: PUSH
93874: LD_INT 102
93876: PUSH
93877: LD_INT 105
93879: PUSH
93880: LD_INT 106
93882: PUSH
93883: LD_INT 108
93885: PUSH
93886: LD_INT 116
93888: PUSH
93889: LD_INT 117
93891: PUSH
93892: LD_INT 118
93894: PUSH
93895: EMPTY
93896: LIST
93897: LIST
93898: LIST
93899: LIST
93900: LIST
93901: LIST
93902: LIST
93903: LIST
93904: PUSH
93905: EMPTY
93906: LIST
93907: LIST
93908: ST_TO_ADDR
93909: GO 96796
93911: LD_INT 4
93913: DOUBLE
93914: EQUAL
93915: IFTRUE 93919
93917: GO 94015
93919: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 5 :
93920: LD_ADDR_VAR 0 2
93924: PUSH
93925: LD_INT 2
93927: PUSH
93928: LD_INT 4
93930: PUSH
93931: LD_INT 5
93933: PUSH
93934: LD_INT 8
93936: PUSH
93937: LD_INT 11
93939: PUSH
93940: LD_INT 12
93942: PUSH
93943: LD_INT 15
93945: PUSH
93946: LD_INT 16
93948: PUSH
93949: LD_INT 22
93951: PUSH
93952: LD_INT 23
93954: PUSH
93955: LD_INT 26
93957: PUSH
93958: LD_INT 36
93960: PUSH
93961: EMPTY
93962: LIST
93963: LIST
93964: LIST
93965: LIST
93966: LIST
93967: LIST
93968: LIST
93969: LIST
93970: LIST
93971: LIST
93972: LIST
93973: LIST
93974: PUSH
93975: LD_INT 101
93977: PUSH
93978: LD_INT 102
93980: PUSH
93981: LD_INT 105
93983: PUSH
93984: LD_INT 106
93986: PUSH
93987: LD_INT 108
93989: PUSH
93990: LD_INT 116
93992: PUSH
93993: LD_INT 117
93995: PUSH
93996: LD_INT 118
93998: PUSH
93999: EMPTY
94000: LIST
94001: LIST
94002: LIST
94003: LIST
94004: LIST
94005: LIST
94006: LIST
94007: LIST
94008: PUSH
94009: EMPTY
94010: LIST
94011: LIST
94012: ST_TO_ADDR
94013: GO 96796
94015: LD_INT 5
94017: DOUBLE
94018: EQUAL
94019: IFTRUE 94023
94021: GO 94135
94023: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 6 :
94024: LD_ADDR_VAR 0 2
94028: PUSH
94029: LD_INT 2
94031: PUSH
94032: LD_INT 4
94034: PUSH
94035: LD_INT 5
94037: PUSH
94038: LD_INT 6
94040: PUSH
94041: LD_INT 8
94043: PUSH
94044: LD_INT 11
94046: PUSH
94047: LD_INT 12
94049: PUSH
94050: LD_INT 15
94052: PUSH
94053: LD_INT 16
94055: PUSH
94056: LD_INT 22
94058: PUSH
94059: LD_INT 23
94061: PUSH
94062: LD_INT 25
94064: PUSH
94065: LD_INT 26
94067: PUSH
94068: LD_INT 36
94070: PUSH
94071: EMPTY
94072: LIST
94073: LIST
94074: LIST
94075: LIST
94076: LIST
94077: LIST
94078: LIST
94079: LIST
94080: LIST
94081: LIST
94082: LIST
94083: LIST
94084: LIST
94085: LIST
94086: PUSH
94087: LD_INT 101
94089: PUSH
94090: LD_INT 102
94092: PUSH
94093: LD_INT 105
94095: PUSH
94096: LD_INT 106
94098: PUSH
94099: LD_INT 108
94101: PUSH
94102: LD_INT 109
94104: PUSH
94105: LD_INT 112
94107: PUSH
94108: LD_INT 116
94110: PUSH
94111: LD_INT 117
94113: PUSH
94114: LD_INT 118
94116: PUSH
94117: EMPTY
94118: LIST
94119: LIST
94120: LIST
94121: LIST
94122: LIST
94123: LIST
94124: LIST
94125: LIST
94126: LIST
94127: LIST
94128: PUSH
94129: EMPTY
94130: LIST
94131: LIST
94132: ST_TO_ADDR
94133: GO 96796
94135: LD_INT 6
94137: DOUBLE
94138: EQUAL
94139: IFTRUE 94143
94141: GO 94275
94143: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 7 :
94144: LD_ADDR_VAR 0 2
94148: PUSH
94149: LD_INT 2
94151: PUSH
94152: LD_INT 4
94154: PUSH
94155: LD_INT 5
94157: PUSH
94158: LD_INT 6
94160: PUSH
94161: LD_INT 8
94163: PUSH
94164: LD_INT 11
94166: PUSH
94167: LD_INT 12
94169: PUSH
94170: LD_INT 15
94172: PUSH
94173: LD_INT 16
94175: PUSH
94176: LD_INT 20
94178: PUSH
94179: LD_INT 21
94181: PUSH
94182: LD_INT 22
94184: PUSH
94185: LD_INT 23
94187: PUSH
94188: LD_INT 25
94190: PUSH
94191: LD_INT 26
94193: PUSH
94194: LD_INT 30
94196: PUSH
94197: LD_INT 31
94199: PUSH
94200: LD_INT 32
94202: PUSH
94203: LD_INT 36
94205: PUSH
94206: EMPTY
94207: LIST
94208: LIST
94209: LIST
94210: LIST
94211: LIST
94212: LIST
94213: LIST
94214: LIST
94215: LIST
94216: LIST
94217: LIST
94218: LIST
94219: LIST
94220: LIST
94221: LIST
94222: LIST
94223: LIST
94224: LIST
94225: LIST
94226: PUSH
94227: LD_INT 101
94229: PUSH
94230: LD_INT 102
94232: PUSH
94233: LD_INT 105
94235: PUSH
94236: LD_INT 106
94238: PUSH
94239: LD_INT 108
94241: PUSH
94242: LD_INT 109
94244: PUSH
94245: LD_INT 112
94247: PUSH
94248: LD_INT 116
94250: PUSH
94251: LD_INT 117
94253: PUSH
94254: LD_INT 118
94256: PUSH
94257: EMPTY
94258: LIST
94259: LIST
94260: LIST
94261: LIST
94262: LIST
94263: LIST
94264: LIST
94265: LIST
94266: LIST
94267: LIST
94268: PUSH
94269: EMPTY
94270: LIST
94271: LIST
94272: ST_TO_ADDR
94273: GO 96796
94275: LD_INT 7
94277: DOUBLE
94278: EQUAL
94279: IFTRUE 94283
94281: GO 94395
94283: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 , 116 , 117 , 118 ] ] ; 8 :
94284: LD_ADDR_VAR 0 2
94288: PUSH
94289: LD_INT 2
94291: PUSH
94292: LD_INT 4
94294: PUSH
94295: LD_INT 5
94297: PUSH
94298: LD_INT 7
94300: PUSH
94301: LD_INT 11
94303: PUSH
94304: LD_INT 12
94306: PUSH
94307: LD_INT 15
94309: PUSH
94310: LD_INT 16
94312: PUSH
94313: LD_INT 20
94315: PUSH
94316: LD_INT 21
94318: PUSH
94319: LD_INT 22
94321: PUSH
94322: LD_INT 23
94324: PUSH
94325: LD_INT 25
94327: PUSH
94328: LD_INT 26
94330: PUSH
94331: EMPTY
94332: LIST
94333: LIST
94334: LIST
94335: LIST
94336: LIST
94337: LIST
94338: LIST
94339: LIST
94340: LIST
94341: LIST
94342: LIST
94343: LIST
94344: LIST
94345: LIST
94346: PUSH
94347: LD_INT 101
94349: PUSH
94350: LD_INT 102
94352: PUSH
94353: LD_INT 103
94355: PUSH
94356: LD_INT 105
94358: PUSH
94359: LD_INT 106
94361: PUSH
94362: LD_INT 108
94364: PUSH
94365: LD_INT 112
94367: PUSH
94368: LD_INT 116
94370: PUSH
94371: LD_INT 117
94373: PUSH
94374: LD_INT 118
94376: PUSH
94377: EMPTY
94378: LIST
94379: LIST
94380: LIST
94381: LIST
94382: LIST
94383: LIST
94384: LIST
94385: LIST
94386: LIST
94387: LIST
94388: PUSH
94389: EMPTY
94390: LIST
94391: LIST
94392: ST_TO_ADDR
94393: GO 96796
94395: LD_INT 8
94397: DOUBLE
94398: EQUAL
94399: IFTRUE 94403
94401: GO 94543
94403: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 9 :
94404: LD_ADDR_VAR 0 2
94408: PUSH
94409: LD_INT 2
94411: PUSH
94412: LD_INT 4
94414: PUSH
94415: LD_INT 5
94417: PUSH
94418: LD_INT 6
94420: PUSH
94421: LD_INT 7
94423: PUSH
94424: LD_INT 8
94426: PUSH
94427: LD_INT 11
94429: PUSH
94430: LD_INT 12
94432: PUSH
94433: LD_INT 15
94435: PUSH
94436: LD_INT 16
94438: PUSH
94439: LD_INT 20
94441: PUSH
94442: LD_INT 21
94444: PUSH
94445: LD_INT 22
94447: PUSH
94448: LD_INT 23
94450: PUSH
94451: LD_INT 25
94453: PUSH
94454: LD_INT 26
94456: PUSH
94457: LD_INT 30
94459: PUSH
94460: LD_INT 31
94462: PUSH
94463: LD_INT 32
94465: PUSH
94466: LD_INT 36
94468: PUSH
94469: EMPTY
94470: LIST
94471: LIST
94472: LIST
94473: LIST
94474: LIST
94475: LIST
94476: LIST
94477: LIST
94478: LIST
94479: LIST
94480: LIST
94481: LIST
94482: LIST
94483: LIST
94484: LIST
94485: LIST
94486: LIST
94487: LIST
94488: LIST
94489: LIST
94490: PUSH
94491: LD_INT 101
94493: PUSH
94494: LD_INT 102
94496: PUSH
94497: LD_INT 103
94499: PUSH
94500: LD_INT 105
94502: PUSH
94503: LD_INT 106
94505: PUSH
94506: LD_INT 108
94508: PUSH
94509: LD_INT 109
94511: PUSH
94512: LD_INT 112
94514: PUSH
94515: LD_INT 116
94517: PUSH
94518: LD_INT 117
94520: PUSH
94521: LD_INT 118
94523: PUSH
94524: EMPTY
94525: LIST
94526: LIST
94527: LIST
94528: LIST
94529: LIST
94530: LIST
94531: LIST
94532: LIST
94533: LIST
94534: LIST
94535: LIST
94536: PUSH
94537: EMPTY
94538: LIST
94539: LIST
94540: ST_TO_ADDR
94541: GO 96796
94543: LD_INT 9
94545: DOUBLE
94546: EQUAL
94547: IFTRUE 94551
94549: GO 94699
94551: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 , 116 , 117 , 118 ] ] ; 10 :
94552: LD_ADDR_VAR 0 2
94556: PUSH
94557: LD_INT 2
94559: PUSH
94560: LD_INT 4
94562: PUSH
94563: LD_INT 5
94565: PUSH
94566: LD_INT 6
94568: PUSH
94569: LD_INT 7
94571: PUSH
94572: LD_INT 8
94574: PUSH
94575: LD_INT 11
94577: PUSH
94578: LD_INT 12
94580: PUSH
94581: LD_INT 15
94583: PUSH
94584: LD_INT 16
94586: PUSH
94587: LD_INT 20
94589: PUSH
94590: LD_INT 21
94592: PUSH
94593: LD_INT 22
94595: PUSH
94596: LD_INT 23
94598: PUSH
94599: LD_INT 25
94601: PUSH
94602: LD_INT 26
94604: PUSH
94605: LD_INT 28
94607: PUSH
94608: LD_INT 30
94610: PUSH
94611: LD_INT 31
94613: PUSH
94614: LD_INT 32
94616: PUSH
94617: LD_INT 36
94619: PUSH
94620: EMPTY
94621: LIST
94622: LIST
94623: LIST
94624: LIST
94625: LIST
94626: LIST
94627: LIST
94628: LIST
94629: LIST
94630: LIST
94631: LIST
94632: LIST
94633: LIST
94634: LIST
94635: LIST
94636: LIST
94637: LIST
94638: LIST
94639: LIST
94640: LIST
94641: LIST
94642: PUSH
94643: LD_INT 101
94645: PUSH
94646: LD_INT 102
94648: PUSH
94649: LD_INT 103
94651: PUSH
94652: LD_INT 105
94654: PUSH
94655: LD_INT 106
94657: PUSH
94658: LD_INT 108
94660: PUSH
94661: LD_INT 109
94663: PUSH
94664: LD_INT 112
94666: PUSH
94667: LD_INT 114
94669: PUSH
94670: LD_INT 116
94672: PUSH
94673: LD_INT 117
94675: PUSH
94676: LD_INT 118
94678: PUSH
94679: EMPTY
94680: LIST
94681: LIST
94682: LIST
94683: LIST
94684: LIST
94685: LIST
94686: LIST
94687: LIST
94688: LIST
94689: LIST
94690: LIST
94691: LIST
94692: PUSH
94693: EMPTY
94694: LIST
94695: LIST
94696: ST_TO_ADDR
94697: GO 96796
94699: LD_INT 10
94701: DOUBLE
94702: EQUAL
94703: IFTRUE 94707
94705: GO 94903
94707: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 11 :
94708: LD_ADDR_VAR 0 2
94712: PUSH
94713: LD_INT 2
94715: PUSH
94716: LD_INT 4
94718: PUSH
94719: LD_INT 5
94721: PUSH
94722: LD_INT 6
94724: PUSH
94725: LD_INT 7
94727: PUSH
94728: LD_INT 8
94730: PUSH
94731: LD_INT 9
94733: PUSH
94734: LD_INT 10
94736: PUSH
94737: LD_INT 11
94739: PUSH
94740: LD_INT 12
94742: PUSH
94743: LD_INT 13
94745: PUSH
94746: LD_INT 14
94748: PUSH
94749: LD_INT 15
94751: PUSH
94752: LD_INT 16
94754: PUSH
94755: LD_INT 17
94757: PUSH
94758: LD_INT 18
94760: PUSH
94761: LD_INT 19
94763: PUSH
94764: LD_INT 20
94766: PUSH
94767: LD_INT 21
94769: PUSH
94770: LD_INT 22
94772: PUSH
94773: LD_INT 23
94775: PUSH
94776: LD_INT 24
94778: PUSH
94779: LD_INT 25
94781: PUSH
94782: LD_INT 26
94784: PUSH
94785: LD_INT 28
94787: PUSH
94788: LD_INT 30
94790: PUSH
94791: LD_INT 31
94793: PUSH
94794: LD_INT 32
94796: PUSH
94797: LD_INT 36
94799: PUSH
94800: EMPTY
94801: LIST
94802: LIST
94803: LIST
94804: LIST
94805: LIST
94806: LIST
94807: LIST
94808: LIST
94809: LIST
94810: LIST
94811: LIST
94812: LIST
94813: LIST
94814: LIST
94815: LIST
94816: LIST
94817: LIST
94818: LIST
94819: LIST
94820: LIST
94821: LIST
94822: LIST
94823: LIST
94824: LIST
94825: LIST
94826: LIST
94827: LIST
94828: LIST
94829: LIST
94830: PUSH
94831: LD_INT 101
94833: PUSH
94834: LD_INT 102
94836: PUSH
94837: LD_INT 103
94839: PUSH
94840: LD_INT 104
94842: PUSH
94843: LD_INT 105
94845: PUSH
94846: LD_INT 106
94848: PUSH
94849: LD_INT 107
94851: PUSH
94852: LD_INT 108
94854: PUSH
94855: LD_INT 109
94857: PUSH
94858: LD_INT 110
94860: PUSH
94861: LD_INT 111
94863: PUSH
94864: LD_INT 112
94866: PUSH
94867: LD_INT 114
94869: PUSH
94870: LD_INT 116
94872: PUSH
94873: LD_INT 117
94875: PUSH
94876: LD_INT 118
94878: PUSH
94879: EMPTY
94880: LIST
94881: LIST
94882: LIST
94883: LIST
94884: LIST
94885: LIST
94886: LIST
94887: LIST
94888: LIST
94889: LIST
94890: LIST
94891: LIST
94892: LIST
94893: LIST
94894: LIST
94895: LIST
94896: PUSH
94897: EMPTY
94898: LIST
94899: LIST
94900: ST_TO_ADDR
94901: GO 96796
94903: LD_INT 11
94905: DOUBLE
94906: EQUAL
94907: IFTRUE 94911
94909: GO 95115
94911: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 12 :
94912: LD_ADDR_VAR 0 2
94916: PUSH
94917: LD_INT 2
94919: PUSH
94920: LD_INT 3
94922: PUSH
94923: LD_INT 4
94925: PUSH
94926: LD_INT 5
94928: PUSH
94929: LD_INT 6
94931: PUSH
94932: LD_INT 7
94934: PUSH
94935: LD_INT 8
94937: PUSH
94938: LD_INT 9
94940: PUSH
94941: LD_INT 10
94943: PUSH
94944: LD_INT 11
94946: PUSH
94947: LD_INT 12
94949: PUSH
94950: LD_INT 13
94952: PUSH
94953: LD_INT 14
94955: PUSH
94956: LD_INT 15
94958: PUSH
94959: LD_INT 16
94961: PUSH
94962: LD_INT 17
94964: PUSH
94965: LD_INT 18
94967: PUSH
94968: LD_INT 19
94970: PUSH
94971: LD_INT 20
94973: PUSH
94974: LD_INT 21
94976: PUSH
94977: LD_INT 22
94979: PUSH
94980: LD_INT 23
94982: PUSH
94983: LD_INT 24
94985: PUSH
94986: LD_INT 25
94988: PUSH
94989: LD_INT 26
94991: PUSH
94992: LD_INT 28
94994: PUSH
94995: LD_INT 30
94997: PUSH
94998: LD_INT 31
95000: PUSH
95001: LD_INT 32
95003: PUSH
95004: LD_INT 34
95006: PUSH
95007: LD_INT 36
95009: PUSH
95010: EMPTY
95011: LIST
95012: LIST
95013: LIST
95014: LIST
95015: LIST
95016: LIST
95017: LIST
95018: LIST
95019: LIST
95020: LIST
95021: LIST
95022: LIST
95023: LIST
95024: LIST
95025: LIST
95026: LIST
95027: LIST
95028: LIST
95029: LIST
95030: LIST
95031: LIST
95032: LIST
95033: LIST
95034: LIST
95035: LIST
95036: LIST
95037: LIST
95038: LIST
95039: LIST
95040: LIST
95041: LIST
95042: PUSH
95043: LD_INT 101
95045: PUSH
95046: LD_INT 102
95048: PUSH
95049: LD_INT 103
95051: PUSH
95052: LD_INT 104
95054: PUSH
95055: LD_INT 105
95057: PUSH
95058: LD_INT 106
95060: PUSH
95061: LD_INT 107
95063: PUSH
95064: LD_INT 108
95066: PUSH
95067: LD_INT 109
95069: PUSH
95070: LD_INT 110
95072: PUSH
95073: LD_INT 111
95075: PUSH
95076: LD_INT 112
95078: PUSH
95079: LD_INT 114
95081: PUSH
95082: LD_INT 116
95084: PUSH
95085: LD_INT 117
95087: PUSH
95088: LD_INT 118
95090: PUSH
95091: EMPTY
95092: LIST
95093: LIST
95094: LIST
95095: LIST
95096: LIST
95097: LIST
95098: LIST
95099: LIST
95100: LIST
95101: LIST
95102: LIST
95103: LIST
95104: LIST
95105: LIST
95106: LIST
95107: LIST
95108: PUSH
95109: EMPTY
95110: LIST
95111: LIST
95112: ST_TO_ADDR
95113: GO 96796
95115: LD_INT 12
95117: DOUBLE
95118: EQUAL
95119: IFTRUE 95123
95121: GO 95343
95123: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 13 :
95124: LD_ADDR_VAR 0 2
95128: PUSH
95129: LD_INT 1
95131: PUSH
95132: LD_INT 2
95134: PUSH
95135: LD_INT 3
95137: PUSH
95138: LD_INT 4
95140: PUSH
95141: LD_INT 5
95143: PUSH
95144: LD_INT 6
95146: PUSH
95147: LD_INT 7
95149: PUSH
95150: LD_INT 8
95152: PUSH
95153: LD_INT 9
95155: PUSH
95156: LD_INT 10
95158: PUSH
95159: LD_INT 11
95161: PUSH
95162: LD_INT 12
95164: PUSH
95165: LD_INT 13
95167: PUSH
95168: LD_INT 14
95170: PUSH
95171: LD_INT 15
95173: PUSH
95174: LD_INT 16
95176: PUSH
95177: LD_INT 17
95179: PUSH
95180: LD_INT 18
95182: PUSH
95183: LD_INT 19
95185: PUSH
95186: LD_INT 20
95188: PUSH
95189: LD_INT 21
95191: PUSH
95192: LD_INT 22
95194: PUSH
95195: LD_INT 23
95197: PUSH
95198: LD_INT 24
95200: PUSH
95201: LD_INT 25
95203: PUSH
95204: LD_INT 26
95206: PUSH
95207: LD_INT 27
95209: PUSH
95210: LD_INT 28
95212: PUSH
95213: LD_INT 30
95215: PUSH
95216: LD_INT 31
95218: PUSH
95219: LD_INT 32
95221: PUSH
95222: LD_INT 33
95224: PUSH
95225: LD_INT 34
95227: PUSH
95228: LD_INT 36
95230: PUSH
95231: EMPTY
95232: LIST
95233: LIST
95234: LIST
95235: LIST
95236: LIST
95237: LIST
95238: LIST
95239: LIST
95240: LIST
95241: LIST
95242: LIST
95243: LIST
95244: LIST
95245: LIST
95246: LIST
95247: LIST
95248: LIST
95249: LIST
95250: LIST
95251: LIST
95252: LIST
95253: LIST
95254: LIST
95255: LIST
95256: LIST
95257: LIST
95258: LIST
95259: LIST
95260: LIST
95261: LIST
95262: LIST
95263: LIST
95264: LIST
95265: LIST
95266: PUSH
95267: LD_INT 101
95269: PUSH
95270: LD_INT 102
95272: PUSH
95273: LD_INT 103
95275: PUSH
95276: LD_INT 104
95278: PUSH
95279: LD_INT 105
95281: PUSH
95282: LD_INT 106
95284: PUSH
95285: LD_INT 107
95287: PUSH
95288: LD_INT 108
95290: PUSH
95291: LD_INT 109
95293: PUSH
95294: LD_INT 110
95296: PUSH
95297: LD_INT 111
95299: PUSH
95300: LD_INT 112
95302: PUSH
95303: LD_INT 113
95305: PUSH
95306: LD_INT 114
95308: PUSH
95309: LD_INT 116
95311: PUSH
95312: LD_INT 117
95314: PUSH
95315: LD_INT 118
95317: PUSH
95318: EMPTY
95319: LIST
95320: LIST
95321: LIST
95322: LIST
95323: LIST
95324: LIST
95325: LIST
95326: LIST
95327: LIST
95328: LIST
95329: LIST
95330: LIST
95331: LIST
95332: LIST
95333: LIST
95334: LIST
95335: LIST
95336: PUSH
95337: EMPTY
95338: LIST
95339: LIST
95340: ST_TO_ADDR
95341: GO 96796
95343: LD_INT 13
95345: DOUBLE
95346: EQUAL
95347: IFTRUE 95351
95349: GO 95559
95351: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 14 :
95352: LD_ADDR_VAR 0 2
95356: PUSH
95357: LD_INT 1
95359: PUSH
95360: LD_INT 2
95362: PUSH
95363: LD_INT 3
95365: PUSH
95366: LD_INT 4
95368: PUSH
95369: LD_INT 5
95371: PUSH
95372: LD_INT 8
95374: PUSH
95375: LD_INT 9
95377: PUSH
95378: LD_INT 10
95380: PUSH
95381: LD_INT 11
95383: PUSH
95384: LD_INT 12
95386: PUSH
95387: LD_INT 14
95389: PUSH
95390: LD_INT 15
95392: PUSH
95393: LD_INT 16
95395: PUSH
95396: LD_INT 17
95398: PUSH
95399: LD_INT 18
95401: PUSH
95402: LD_INT 19
95404: PUSH
95405: LD_INT 20
95407: PUSH
95408: LD_INT 21
95410: PUSH
95411: LD_INT 22
95413: PUSH
95414: LD_INT 23
95416: PUSH
95417: LD_INT 24
95419: PUSH
95420: LD_INT 25
95422: PUSH
95423: LD_INT 26
95425: PUSH
95426: LD_INT 27
95428: PUSH
95429: LD_INT 28
95431: PUSH
95432: LD_INT 30
95434: PUSH
95435: LD_INT 31
95437: PUSH
95438: LD_INT 32
95440: PUSH
95441: LD_INT 33
95443: PUSH
95444: LD_INT 34
95446: PUSH
95447: LD_INT 36
95449: PUSH
95450: EMPTY
95451: LIST
95452: LIST
95453: LIST
95454: LIST
95455: LIST
95456: LIST
95457: LIST
95458: LIST
95459: LIST
95460: LIST
95461: LIST
95462: LIST
95463: LIST
95464: LIST
95465: LIST
95466: LIST
95467: LIST
95468: LIST
95469: LIST
95470: LIST
95471: LIST
95472: LIST
95473: LIST
95474: LIST
95475: LIST
95476: LIST
95477: LIST
95478: LIST
95479: LIST
95480: LIST
95481: LIST
95482: PUSH
95483: LD_INT 101
95485: PUSH
95486: LD_INT 102
95488: PUSH
95489: LD_INT 103
95491: PUSH
95492: LD_INT 104
95494: PUSH
95495: LD_INT 105
95497: PUSH
95498: LD_INT 106
95500: PUSH
95501: LD_INT 107
95503: PUSH
95504: LD_INT 108
95506: PUSH
95507: LD_INT 109
95509: PUSH
95510: LD_INT 110
95512: PUSH
95513: LD_INT 111
95515: PUSH
95516: LD_INT 112
95518: PUSH
95519: LD_INT 113
95521: PUSH
95522: LD_INT 114
95524: PUSH
95525: LD_INT 116
95527: PUSH
95528: LD_INT 117
95530: PUSH
95531: LD_INT 118
95533: PUSH
95534: EMPTY
95535: LIST
95536: LIST
95537: LIST
95538: LIST
95539: LIST
95540: LIST
95541: LIST
95542: LIST
95543: LIST
95544: LIST
95545: LIST
95546: LIST
95547: LIST
95548: LIST
95549: LIST
95550: LIST
95551: LIST
95552: PUSH
95553: EMPTY
95554: LIST
95555: LIST
95556: ST_TO_ADDR
95557: GO 96796
95559: LD_INT 14
95561: DOUBLE
95562: EQUAL
95563: IFTRUE 95567
95565: GO 95791
95567: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 15 :
95568: LD_ADDR_VAR 0 2
95572: PUSH
95573: LD_INT 1
95575: PUSH
95576: LD_INT 2
95578: PUSH
95579: LD_INT 3
95581: PUSH
95582: LD_INT 4
95584: PUSH
95585: LD_INT 5
95587: PUSH
95588: LD_INT 6
95590: PUSH
95591: LD_INT 7
95593: PUSH
95594: LD_INT 8
95596: PUSH
95597: LD_INT 9
95599: PUSH
95600: LD_INT 10
95602: PUSH
95603: LD_INT 11
95605: PUSH
95606: LD_INT 12
95608: PUSH
95609: LD_INT 13
95611: PUSH
95612: LD_INT 14
95614: PUSH
95615: LD_INT 15
95617: PUSH
95618: LD_INT 16
95620: PUSH
95621: LD_INT 17
95623: PUSH
95624: LD_INT 18
95626: PUSH
95627: LD_INT 19
95629: PUSH
95630: LD_INT 20
95632: PUSH
95633: LD_INT 21
95635: PUSH
95636: LD_INT 22
95638: PUSH
95639: LD_INT 23
95641: PUSH
95642: LD_INT 24
95644: PUSH
95645: LD_INT 25
95647: PUSH
95648: LD_INT 26
95650: PUSH
95651: LD_INT 27
95653: PUSH
95654: LD_INT 28
95656: PUSH
95657: LD_INT 29
95659: PUSH
95660: LD_INT 30
95662: PUSH
95663: LD_INT 31
95665: PUSH
95666: LD_INT 32
95668: PUSH
95669: LD_INT 33
95671: PUSH
95672: LD_INT 34
95674: PUSH
95675: LD_INT 36
95677: PUSH
95678: EMPTY
95679: LIST
95680: LIST
95681: LIST
95682: LIST
95683: LIST
95684: LIST
95685: LIST
95686: LIST
95687: LIST
95688: LIST
95689: LIST
95690: LIST
95691: LIST
95692: LIST
95693: LIST
95694: LIST
95695: LIST
95696: LIST
95697: LIST
95698: LIST
95699: LIST
95700: LIST
95701: LIST
95702: LIST
95703: LIST
95704: LIST
95705: LIST
95706: LIST
95707: LIST
95708: LIST
95709: LIST
95710: LIST
95711: LIST
95712: LIST
95713: LIST
95714: PUSH
95715: LD_INT 101
95717: PUSH
95718: LD_INT 102
95720: PUSH
95721: LD_INT 103
95723: PUSH
95724: LD_INT 104
95726: PUSH
95727: LD_INT 105
95729: PUSH
95730: LD_INT 106
95732: PUSH
95733: LD_INT 107
95735: PUSH
95736: LD_INT 108
95738: PUSH
95739: LD_INT 109
95741: PUSH
95742: LD_INT 110
95744: PUSH
95745: LD_INT 111
95747: PUSH
95748: LD_INT 112
95750: PUSH
95751: LD_INT 113
95753: PUSH
95754: LD_INT 114
95756: PUSH
95757: LD_INT 116
95759: PUSH
95760: LD_INT 117
95762: PUSH
95763: LD_INT 118
95765: PUSH
95766: EMPTY
95767: LIST
95768: LIST
95769: LIST
95770: LIST
95771: LIST
95772: LIST
95773: LIST
95774: LIST
95775: LIST
95776: LIST
95777: LIST
95778: LIST
95779: LIST
95780: LIST
95781: LIST
95782: LIST
95783: LIST
95784: PUSH
95785: EMPTY
95786: LIST
95787: LIST
95788: ST_TO_ADDR
95789: GO 96796
95791: LD_INT 15
95793: DOUBLE
95794: EQUAL
95795: IFTRUE 95799
95797: GO 96023
95799: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 16 :
95800: LD_ADDR_VAR 0 2
95804: PUSH
95805: LD_INT 1
95807: PUSH
95808: LD_INT 2
95810: PUSH
95811: LD_INT 3
95813: PUSH
95814: LD_INT 4
95816: PUSH
95817: LD_INT 5
95819: PUSH
95820: LD_INT 6
95822: PUSH
95823: LD_INT 7
95825: PUSH
95826: LD_INT 8
95828: PUSH
95829: LD_INT 9
95831: PUSH
95832: LD_INT 10
95834: PUSH
95835: LD_INT 11
95837: PUSH
95838: LD_INT 12
95840: PUSH
95841: LD_INT 13
95843: PUSH
95844: LD_INT 14
95846: PUSH
95847: LD_INT 15
95849: PUSH
95850: LD_INT 16
95852: PUSH
95853: LD_INT 17
95855: PUSH
95856: LD_INT 18
95858: PUSH
95859: LD_INT 19
95861: PUSH
95862: LD_INT 20
95864: PUSH
95865: LD_INT 21
95867: PUSH
95868: LD_INT 22
95870: PUSH
95871: LD_INT 23
95873: PUSH
95874: LD_INT 24
95876: PUSH
95877: LD_INT 25
95879: PUSH
95880: LD_INT 26
95882: PUSH
95883: LD_INT 27
95885: PUSH
95886: LD_INT 28
95888: PUSH
95889: LD_INT 29
95891: PUSH
95892: LD_INT 30
95894: PUSH
95895: LD_INT 31
95897: PUSH
95898: LD_INT 32
95900: PUSH
95901: LD_INT 33
95903: PUSH
95904: LD_INT 34
95906: PUSH
95907: LD_INT 36
95909: PUSH
95910: EMPTY
95911: LIST
95912: LIST
95913: LIST
95914: LIST
95915: LIST
95916: LIST
95917: LIST
95918: LIST
95919: LIST
95920: LIST
95921: LIST
95922: LIST
95923: LIST
95924: LIST
95925: LIST
95926: LIST
95927: LIST
95928: LIST
95929: LIST
95930: LIST
95931: LIST
95932: LIST
95933: LIST
95934: LIST
95935: LIST
95936: LIST
95937: LIST
95938: LIST
95939: LIST
95940: LIST
95941: LIST
95942: LIST
95943: LIST
95944: LIST
95945: LIST
95946: PUSH
95947: LD_INT 101
95949: PUSH
95950: LD_INT 102
95952: PUSH
95953: LD_INT 103
95955: PUSH
95956: LD_INT 104
95958: PUSH
95959: LD_INT 105
95961: PUSH
95962: LD_INT 106
95964: PUSH
95965: LD_INT 107
95967: PUSH
95968: LD_INT 108
95970: PUSH
95971: LD_INT 109
95973: PUSH
95974: LD_INT 110
95976: PUSH
95977: LD_INT 111
95979: PUSH
95980: LD_INT 112
95982: PUSH
95983: LD_INT 113
95985: PUSH
95986: LD_INT 114
95988: PUSH
95989: LD_INT 116
95991: PUSH
95992: LD_INT 117
95994: PUSH
95995: LD_INT 118
95997: PUSH
95998: EMPTY
95999: LIST
96000: LIST
96001: LIST
96002: LIST
96003: LIST
96004: LIST
96005: LIST
96006: LIST
96007: LIST
96008: LIST
96009: LIST
96010: LIST
96011: LIST
96012: LIST
96013: LIST
96014: LIST
96015: LIST
96016: PUSH
96017: EMPTY
96018: LIST
96019: LIST
96020: ST_TO_ADDR
96021: GO 96796
96023: LD_INT 16
96025: DOUBLE
96026: EQUAL
96027: IFTRUE 96031
96029: GO 96167
96031: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 17 :
96032: LD_ADDR_VAR 0 2
96036: PUSH
96037: LD_INT 2
96039: PUSH
96040: LD_INT 4
96042: PUSH
96043: LD_INT 5
96045: PUSH
96046: LD_INT 7
96048: PUSH
96049: LD_INT 11
96051: PUSH
96052: LD_INT 12
96054: PUSH
96055: LD_INT 15
96057: PUSH
96058: LD_INT 16
96060: PUSH
96061: LD_INT 20
96063: PUSH
96064: LD_INT 21
96066: PUSH
96067: LD_INT 22
96069: PUSH
96070: LD_INT 23
96072: PUSH
96073: LD_INT 25
96075: PUSH
96076: LD_INT 26
96078: PUSH
96079: LD_INT 30
96081: PUSH
96082: LD_INT 31
96084: PUSH
96085: LD_INT 32
96087: PUSH
96088: LD_INT 33
96090: PUSH
96091: LD_INT 34
96093: PUSH
96094: EMPTY
96095: LIST
96096: LIST
96097: LIST
96098: LIST
96099: LIST
96100: LIST
96101: LIST
96102: LIST
96103: LIST
96104: LIST
96105: LIST
96106: LIST
96107: LIST
96108: LIST
96109: LIST
96110: LIST
96111: LIST
96112: LIST
96113: LIST
96114: PUSH
96115: LD_INT 101
96117: PUSH
96118: LD_INT 102
96120: PUSH
96121: LD_INT 103
96123: PUSH
96124: LD_INT 106
96126: PUSH
96127: LD_INT 108
96129: PUSH
96130: LD_INT 112
96132: PUSH
96133: LD_INT 113
96135: PUSH
96136: LD_INT 114
96138: PUSH
96139: LD_INT 116
96141: PUSH
96142: LD_INT 117
96144: PUSH
96145: LD_INT 118
96147: PUSH
96148: EMPTY
96149: LIST
96150: LIST
96151: LIST
96152: LIST
96153: LIST
96154: LIST
96155: LIST
96156: LIST
96157: LIST
96158: LIST
96159: LIST
96160: PUSH
96161: EMPTY
96162: LIST
96163: LIST
96164: ST_TO_ADDR
96165: GO 96796
96167: LD_INT 17
96169: DOUBLE
96170: EQUAL
96171: IFTRUE 96175
96173: GO 96399
96175: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 18 :
96176: LD_ADDR_VAR 0 2
96180: PUSH
96181: LD_INT 1
96183: PUSH
96184: LD_INT 2
96186: PUSH
96187: LD_INT 3
96189: PUSH
96190: LD_INT 4
96192: PUSH
96193: LD_INT 5
96195: PUSH
96196: LD_INT 6
96198: PUSH
96199: LD_INT 7
96201: PUSH
96202: LD_INT 8
96204: PUSH
96205: LD_INT 9
96207: PUSH
96208: LD_INT 10
96210: PUSH
96211: LD_INT 11
96213: PUSH
96214: LD_INT 12
96216: PUSH
96217: LD_INT 13
96219: PUSH
96220: LD_INT 14
96222: PUSH
96223: LD_INT 15
96225: PUSH
96226: LD_INT 16
96228: PUSH
96229: LD_INT 17
96231: PUSH
96232: LD_INT 18
96234: PUSH
96235: LD_INT 19
96237: PUSH
96238: LD_INT 20
96240: PUSH
96241: LD_INT 21
96243: PUSH
96244: LD_INT 22
96246: PUSH
96247: LD_INT 23
96249: PUSH
96250: LD_INT 24
96252: PUSH
96253: LD_INT 25
96255: PUSH
96256: LD_INT 26
96258: PUSH
96259: LD_INT 27
96261: PUSH
96262: LD_INT 28
96264: PUSH
96265: LD_INT 29
96267: PUSH
96268: LD_INT 30
96270: PUSH
96271: LD_INT 31
96273: PUSH
96274: LD_INT 32
96276: PUSH
96277: LD_INT 33
96279: PUSH
96280: LD_INT 34
96282: PUSH
96283: LD_INT 36
96285: PUSH
96286: EMPTY
96287: LIST
96288: LIST
96289: LIST
96290: LIST
96291: LIST
96292: LIST
96293: LIST
96294: LIST
96295: LIST
96296: LIST
96297: LIST
96298: LIST
96299: LIST
96300: LIST
96301: LIST
96302: LIST
96303: LIST
96304: LIST
96305: LIST
96306: LIST
96307: LIST
96308: LIST
96309: LIST
96310: LIST
96311: LIST
96312: LIST
96313: LIST
96314: LIST
96315: LIST
96316: LIST
96317: LIST
96318: LIST
96319: LIST
96320: LIST
96321: LIST
96322: PUSH
96323: LD_INT 101
96325: PUSH
96326: LD_INT 102
96328: PUSH
96329: LD_INT 103
96331: PUSH
96332: LD_INT 104
96334: PUSH
96335: LD_INT 105
96337: PUSH
96338: LD_INT 106
96340: PUSH
96341: LD_INT 107
96343: PUSH
96344: LD_INT 108
96346: PUSH
96347: LD_INT 109
96349: PUSH
96350: LD_INT 110
96352: PUSH
96353: LD_INT 111
96355: PUSH
96356: LD_INT 112
96358: PUSH
96359: LD_INT 113
96361: PUSH
96362: LD_INT 114
96364: PUSH
96365: LD_INT 116
96367: PUSH
96368: LD_INT 117
96370: PUSH
96371: LD_INT 118
96373: PUSH
96374: EMPTY
96375: LIST
96376: LIST
96377: LIST
96378: LIST
96379: LIST
96380: LIST
96381: LIST
96382: LIST
96383: LIST
96384: LIST
96385: LIST
96386: LIST
96387: LIST
96388: LIST
96389: LIST
96390: LIST
96391: LIST
96392: PUSH
96393: EMPTY
96394: LIST
96395: LIST
96396: ST_TO_ADDR
96397: GO 96796
96399: LD_INT 18
96401: DOUBLE
96402: EQUAL
96403: IFTRUE 96407
96405: GO 96555
96407: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; 19 :
96408: LD_ADDR_VAR 0 2
96412: PUSH
96413: LD_INT 2
96415: PUSH
96416: LD_INT 4
96418: PUSH
96419: LD_INT 5
96421: PUSH
96422: LD_INT 7
96424: PUSH
96425: LD_INT 11
96427: PUSH
96428: LD_INT 12
96430: PUSH
96431: LD_INT 15
96433: PUSH
96434: LD_INT 16
96436: PUSH
96437: LD_INT 20
96439: PUSH
96440: LD_INT 21
96442: PUSH
96443: LD_INT 22
96445: PUSH
96446: LD_INT 23
96448: PUSH
96449: LD_INT 25
96451: PUSH
96452: LD_INT 26
96454: PUSH
96455: LD_INT 30
96457: PUSH
96458: LD_INT 31
96460: PUSH
96461: LD_INT 32
96463: PUSH
96464: LD_INT 33
96466: PUSH
96467: LD_INT 34
96469: PUSH
96470: LD_INT 35
96472: PUSH
96473: LD_INT 36
96475: PUSH
96476: EMPTY
96477: LIST
96478: LIST
96479: LIST
96480: LIST
96481: LIST
96482: LIST
96483: LIST
96484: LIST
96485: LIST
96486: LIST
96487: LIST
96488: LIST
96489: LIST
96490: LIST
96491: LIST
96492: LIST
96493: LIST
96494: LIST
96495: LIST
96496: LIST
96497: LIST
96498: PUSH
96499: LD_INT 101
96501: PUSH
96502: LD_INT 102
96504: PUSH
96505: LD_INT 103
96507: PUSH
96508: LD_INT 106
96510: PUSH
96511: LD_INT 108
96513: PUSH
96514: LD_INT 112
96516: PUSH
96517: LD_INT 113
96519: PUSH
96520: LD_INT 114
96522: PUSH
96523: LD_INT 115
96525: PUSH
96526: LD_INT 116
96528: PUSH
96529: LD_INT 117
96531: PUSH
96532: LD_INT 118
96534: PUSH
96535: EMPTY
96536: LIST
96537: LIST
96538: LIST
96539: LIST
96540: LIST
96541: LIST
96542: LIST
96543: LIST
96544: LIST
96545: LIST
96546: LIST
96547: LIST
96548: PUSH
96549: EMPTY
96550: LIST
96551: LIST
96552: ST_TO_ADDR
96553: GO 96796
96555: LD_INT 19
96557: DOUBLE
96558: EQUAL
96559: IFTRUE 96563
96561: GO 96795
96563: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; end ;
96564: LD_ADDR_VAR 0 2
96568: PUSH
96569: LD_INT 1
96571: PUSH
96572: LD_INT 2
96574: PUSH
96575: LD_INT 3
96577: PUSH
96578: LD_INT 4
96580: PUSH
96581: LD_INT 5
96583: PUSH
96584: LD_INT 6
96586: PUSH
96587: LD_INT 7
96589: PUSH
96590: LD_INT 8
96592: PUSH
96593: LD_INT 9
96595: PUSH
96596: LD_INT 10
96598: PUSH
96599: LD_INT 11
96601: PUSH
96602: LD_INT 12
96604: PUSH
96605: LD_INT 13
96607: PUSH
96608: LD_INT 14
96610: PUSH
96611: LD_INT 15
96613: PUSH
96614: LD_INT 16
96616: PUSH
96617: LD_INT 17
96619: PUSH
96620: LD_INT 18
96622: PUSH
96623: LD_INT 19
96625: PUSH
96626: LD_INT 20
96628: PUSH
96629: LD_INT 21
96631: PUSH
96632: LD_INT 22
96634: PUSH
96635: LD_INT 23
96637: PUSH
96638: LD_INT 24
96640: PUSH
96641: LD_INT 25
96643: PUSH
96644: LD_INT 26
96646: PUSH
96647: LD_INT 27
96649: PUSH
96650: LD_INT 28
96652: PUSH
96653: LD_INT 29
96655: PUSH
96656: LD_INT 30
96658: PUSH
96659: LD_INT 31
96661: PUSH
96662: LD_INT 32
96664: PUSH
96665: LD_INT 33
96667: PUSH
96668: LD_INT 34
96670: PUSH
96671: LD_INT 35
96673: PUSH
96674: LD_INT 36
96676: PUSH
96677: EMPTY
96678: LIST
96679: LIST
96680: LIST
96681: LIST
96682: LIST
96683: LIST
96684: LIST
96685: LIST
96686: LIST
96687: LIST
96688: LIST
96689: LIST
96690: LIST
96691: LIST
96692: LIST
96693: LIST
96694: LIST
96695: LIST
96696: LIST
96697: LIST
96698: LIST
96699: LIST
96700: LIST
96701: LIST
96702: LIST
96703: LIST
96704: LIST
96705: LIST
96706: LIST
96707: LIST
96708: LIST
96709: LIST
96710: LIST
96711: LIST
96712: LIST
96713: LIST
96714: PUSH
96715: LD_INT 101
96717: PUSH
96718: LD_INT 102
96720: PUSH
96721: LD_INT 103
96723: PUSH
96724: LD_INT 104
96726: PUSH
96727: LD_INT 105
96729: PUSH
96730: LD_INT 106
96732: PUSH
96733: LD_INT 107
96735: PUSH
96736: LD_INT 108
96738: PUSH
96739: LD_INT 109
96741: PUSH
96742: LD_INT 110
96744: PUSH
96745: LD_INT 111
96747: PUSH
96748: LD_INT 112
96750: PUSH
96751: LD_INT 113
96753: PUSH
96754: LD_INT 114
96756: PUSH
96757: LD_INT 115
96759: PUSH
96760: LD_INT 116
96762: PUSH
96763: LD_INT 117
96765: PUSH
96766: LD_INT 118
96768: PUSH
96769: EMPTY
96770: LIST
96771: LIST
96772: LIST
96773: LIST
96774: LIST
96775: LIST
96776: LIST
96777: LIST
96778: LIST
96779: LIST
96780: LIST
96781: LIST
96782: LIST
96783: LIST
96784: LIST
96785: LIST
96786: LIST
96787: LIST
96788: PUSH
96789: EMPTY
96790: LIST
96791: LIST
96792: ST_TO_ADDR
96793: GO 96796
96795: POP
// end else
96796: GO 97027
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ;
96798: LD_ADDR_VAR 0 2
96802: PUSH
96803: LD_INT 1
96805: PUSH
96806: LD_INT 2
96808: PUSH
96809: LD_INT 3
96811: PUSH
96812: LD_INT 4
96814: PUSH
96815: LD_INT 5
96817: PUSH
96818: LD_INT 6
96820: PUSH
96821: LD_INT 7
96823: PUSH
96824: LD_INT 8
96826: PUSH
96827: LD_INT 9
96829: PUSH
96830: LD_INT 10
96832: PUSH
96833: LD_INT 11
96835: PUSH
96836: LD_INT 12
96838: PUSH
96839: LD_INT 13
96841: PUSH
96842: LD_INT 14
96844: PUSH
96845: LD_INT 15
96847: PUSH
96848: LD_INT 16
96850: PUSH
96851: LD_INT 17
96853: PUSH
96854: LD_INT 18
96856: PUSH
96857: LD_INT 19
96859: PUSH
96860: LD_INT 20
96862: PUSH
96863: LD_INT 21
96865: PUSH
96866: LD_INT 22
96868: PUSH
96869: LD_INT 23
96871: PUSH
96872: LD_INT 24
96874: PUSH
96875: LD_INT 25
96877: PUSH
96878: LD_INT 26
96880: PUSH
96881: LD_INT 27
96883: PUSH
96884: LD_INT 28
96886: PUSH
96887: LD_INT 29
96889: PUSH
96890: LD_INT 30
96892: PUSH
96893: LD_INT 31
96895: PUSH
96896: LD_INT 32
96898: PUSH
96899: LD_INT 33
96901: PUSH
96902: LD_INT 34
96904: PUSH
96905: LD_INT 35
96907: PUSH
96908: LD_INT 36
96910: PUSH
96911: EMPTY
96912: LIST
96913: LIST
96914: LIST
96915: LIST
96916: LIST
96917: LIST
96918: LIST
96919: LIST
96920: LIST
96921: LIST
96922: LIST
96923: LIST
96924: LIST
96925: LIST
96926: LIST
96927: LIST
96928: LIST
96929: LIST
96930: LIST
96931: LIST
96932: LIST
96933: LIST
96934: LIST
96935: LIST
96936: LIST
96937: LIST
96938: LIST
96939: LIST
96940: LIST
96941: LIST
96942: LIST
96943: LIST
96944: LIST
96945: LIST
96946: LIST
96947: LIST
96948: PUSH
96949: LD_INT 101
96951: PUSH
96952: LD_INT 102
96954: PUSH
96955: LD_INT 103
96957: PUSH
96958: LD_INT 104
96960: PUSH
96961: LD_INT 105
96963: PUSH
96964: LD_INT 106
96966: PUSH
96967: LD_INT 107
96969: PUSH
96970: LD_INT 108
96972: PUSH
96973: LD_INT 109
96975: PUSH
96976: LD_INT 110
96978: PUSH
96979: LD_INT 111
96981: PUSH
96982: LD_INT 112
96984: PUSH
96985: LD_INT 113
96987: PUSH
96988: LD_INT 114
96990: PUSH
96991: LD_INT 115
96993: PUSH
96994: LD_INT 116
96996: PUSH
96997: LD_INT 117
96999: PUSH
97000: LD_INT 118
97002: PUSH
97003: EMPTY
97004: LIST
97005: LIST
97006: LIST
97007: LIST
97008: LIST
97009: LIST
97010: LIST
97011: LIST
97012: LIST
97013: LIST
97014: LIST
97015: LIST
97016: LIST
97017: LIST
97018: LIST
97019: LIST
97020: LIST
97021: LIST
97022: PUSH
97023: EMPTY
97024: LIST
97025: LIST
97026: ST_TO_ADDR
// if result then
97027: LD_VAR 0 2
97031: IFFALSE 97817
// begin normal :=  ;
97033: LD_ADDR_VAR 0 5
97037: PUSH
97038: LD_STRING 
97040: ST_TO_ADDR
// hardcore :=  ;
97041: LD_ADDR_VAR 0 6
97045: PUSH
97046: LD_STRING 
97048: ST_TO_ADDR
// active :=  ;
97049: LD_ADDR_VAR 0 7
97053: PUSH
97054: LD_STRING 
97056: ST_TO_ADDR
// for i = 1 to normalCounter do
97057: LD_ADDR_VAR 0 8
97061: PUSH
97062: DOUBLE
97063: LD_INT 1
97065: DEC
97066: ST_TO_ADDR
97067: LD_EXP 76
97071: PUSH
97072: FOR_TO
97073: IFFALSE 97174
// begin tmp := 0 ;
97075: LD_ADDR_VAR 0 3
97079: PUSH
97080: LD_STRING 0
97082: ST_TO_ADDR
// if result [ 1 ] then
97083: LD_VAR 0 2
97087: PUSH
97088: LD_INT 1
97090: ARRAY
97091: IFFALSE 97156
// if result [ 1 ] [ 1 ] = i then
97093: LD_VAR 0 2
97097: PUSH
97098: LD_INT 1
97100: ARRAY
97101: PUSH
97102: LD_INT 1
97104: ARRAY
97105: PUSH
97106: LD_VAR 0 8
97110: EQUAL
97111: IFFALSE 97156
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
97113: LD_ADDR_VAR 0 2
97117: PUSH
97118: LD_VAR 0 2
97122: PPUSH
97123: LD_INT 1
97125: PPUSH
97126: LD_VAR 0 2
97130: PUSH
97131: LD_INT 1
97133: ARRAY
97134: PPUSH
97135: LD_INT 1
97137: PPUSH
97138: CALL_OW 3
97142: PPUSH
97143: CALL_OW 1
97147: ST_TO_ADDR
// tmp := 1 ;
97148: LD_ADDR_VAR 0 3
97152: PUSH
97153: LD_STRING 1
97155: ST_TO_ADDR
// end ; normal := normal & tmp ;
97156: LD_ADDR_VAR 0 5
97160: PUSH
97161: LD_VAR 0 5
97165: PUSH
97166: LD_VAR 0 3
97170: STR
97171: ST_TO_ADDR
// end ;
97172: GO 97072
97174: POP
97175: POP
// for i = 1 to hardcoreCounter do
97176: LD_ADDR_VAR 0 8
97180: PUSH
97181: DOUBLE
97182: LD_INT 1
97184: DEC
97185: ST_TO_ADDR
97186: LD_EXP 77
97190: PUSH
97191: FOR_TO
97192: IFFALSE 97297
// begin tmp := 0 ;
97194: LD_ADDR_VAR 0 3
97198: PUSH
97199: LD_STRING 0
97201: ST_TO_ADDR
// if result [ 2 ] then
97202: LD_VAR 0 2
97206: PUSH
97207: LD_INT 2
97209: ARRAY
97210: IFFALSE 97279
// if result [ 2 ] [ 1 ] = 100 + i then
97212: LD_VAR 0 2
97216: PUSH
97217: LD_INT 2
97219: ARRAY
97220: PUSH
97221: LD_INT 1
97223: ARRAY
97224: PUSH
97225: LD_INT 100
97227: PUSH
97228: LD_VAR 0 8
97232: PLUS
97233: EQUAL
97234: IFFALSE 97279
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
97236: LD_ADDR_VAR 0 2
97240: PUSH
97241: LD_VAR 0 2
97245: PPUSH
97246: LD_INT 2
97248: PPUSH
97249: LD_VAR 0 2
97253: PUSH
97254: LD_INT 2
97256: ARRAY
97257: PPUSH
97258: LD_INT 1
97260: PPUSH
97261: CALL_OW 3
97265: PPUSH
97266: CALL_OW 1
97270: ST_TO_ADDR
// tmp := 1 ;
97271: LD_ADDR_VAR 0 3
97275: PUSH
97276: LD_STRING 1
97278: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
97279: LD_ADDR_VAR 0 6
97283: PUSH
97284: LD_VAR 0 6
97288: PUSH
97289: LD_VAR 0 3
97293: STR
97294: ST_TO_ADDR
// end ;
97295: GO 97191
97297: POP
97298: POP
// if isGameLoad then
97299: LD_VAR 0 1
97303: IFFALSE 97778
// begin flags := [ sRocket , sSpeed , sEngine , sSpec , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sKamikadze , sTroll , sSlow , sLack , sTank , sRemote , sPowell , sTeleport , sOilTower , sShovel , sSheik , sEarthquake , sAI , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sSold , sDiff , sFog , sReset , sSun , sTiger , sBomb , sWound , sBetray , sContamin , sOil , sStu , sBazooka , sMortar , sRanger , sComputer , s30 , s60 ] ;
97305: LD_ADDR_VAR 0 4
97309: PUSH
97310: LD_EXP 80
97314: PUSH
97315: LD_EXP 79
97319: PUSH
97320: LD_EXP 81
97324: PUSH
97325: LD_EXP 78
97329: PUSH
97330: LD_EXP 82
97334: PUSH
97335: LD_EXP 83
97339: PUSH
97340: LD_EXP 84
97344: PUSH
97345: LD_EXP 85
97349: PUSH
97350: LD_EXP 86
97354: PUSH
97355: LD_EXP 87
97359: PUSH
97360: LD_EXP 88
97364: PUSH
97365: LD_EXP 89
97369: PUSH
97370: LD_EXP 90
97374: PUSH
97375: LD_EXP 91
97379: PUSH
97380: LD_EXP 99
97384: PUSH
97385: LD_EXP 100
97389: PUSH
97390: LD_EXP 101
97394: PUSH
97395: LD_EXP 102
97399: PUSH
97400: LD_EXP 104
97404: PUSH
97405: LD_EXP 105
97409: PUSH
97410: LD_EXP 106
97414: PUSH
97415: LD_EXP 109
97419: PUSH
97420: LD_EXP 111
97424: PUSH
97425: LD_EXP 112
97429: PUSH
97430: LD_EXP 113
97434: PUSH
97435: LD_EXP 115
97439: PUSH
97440: LD_EXP 116
97444: PUSH
97445: LD_EXP 119
97449: PUSH
97450: LD_EXP 120
97454: PUSH
97455: LD_EXP 121
97459: PUSH
97460: LD_EXP 122
97464: PUSH
97465: LD_EXP 123
97469: PUSH
97470: LD_EXP 124
97474: PUSH
97475: LD_EXP 125
97479: PUSH
97480: LD_EXP 126
97484: PUSH
97485: LD_EXP 127
97489: PUSH
97490: LD_EXP 92
97494: PUSH
97495: LD_EXP 93
97499: PUSH
97500: LD_EXP 96
97504: PUSH
97505: LD_EXP 97
97509: PUSH
97510: LD_EXP 98
97514: PUSH
97515: LD_EXP 94
97519: PUSH
97520: LD_EXP 95
97524: PUSH
97525: LD_EXP 103
97529: PUSH
97530: LD_EXP 107
97534: PUSH
97535: LD_EXP 108
97539: PUSH
97540: LD_EXP 110
97544: PUSH
97545: LD_EXP 114
97549: PUSH
97550: LD_EXP 117
97554: PUSH
97555: LD_EXP 118
97559: PUSH
97560: LD_EXP 128
97564: PUSH
97565: LD_EXP 129
97569: PUSH
97570: LD_EXP 130
97574: PUSH
97575: LD_EXP 131
97579: PUSH
97580: EMPTY
97581: LIST
97582: LIST
97583: LIST
97584: LIST
97585: LIST
97586: LIST
97587: LIST
97588: LIST
97589: LIST
97590: LIST
97591: LIST
97592: LIST
97593: LIST
97594: LIST
97595: LIST
97596: LIST
97597: LIST
97598: LIST
97599: LIST
97600: LIST
97601: LIST
97602: LIST
97603: LIST
97604: LIST
97605: LIST
97606: LIST
97607: LIST
97608: LIST
97609: LIST
97610: LIST
97611: LIST
97612: LIST
97613: LIST
97614: LIST
97615: LIST
97616: LIST
97617: LIST
97618: LIST
97619: LIST
97620: LIST
97621: LIST
97622: LIST
97623: LIST
97624: LIST
97625: LIST
97626: LIST
97627: LIST
97628: LIST
97629: LIST
97630: LIST
97631: LIST
97632: LIST
97633: LIST
97634: LIST
97635: ST_TO_ADDR
// tmp :=  ;
97636: LD_ADDR_VAR 0 3
97640: PUSH
97641: LD_STRING 
97643: ST_TO_ADDR
// for i = 1 to normalCounter do
97644: LD_ADDR_VAR 0 8
97648: PUSH
97649: DOUBLE
97650: LD_INT 1
97652: DEC
97653: ST_TO_ADDR
97654: LD_EXP 76
97658: PUSH
97659: FOR_TO
97660: IFFALSE 97696
// begin if flags [ i ] then
97662: LD_VAR 0 4
97666: PUSH
97667: LD_VAR 0 8
97671: ARRAY
97672: IFFALSE 97694
// tmp := tmp & i & ; ;
97674: LD_ADDR_VAR 0 3
97678: PUSH
97679: LD_VAR 0 3
97683: PUSH
97684: LD_VAR 0 8
97688: STR
97689: PUSH
97690: LD_STRING ;
97692: STR
97693: ST_TO_ADDR
// end ;
97694: GO 97659
97696: POP
97697: POP
// for i = 1 to hardcoreCounter do
97698: LD_ADDR_VAR 0 8
97702: PUSH
97703: DOUBLE
97704: LD_INT 1
97706: DEC
97707: ST_TO_ADDR
97708: LD_EXP 77
97712: PUSH
97713: FOR_TO
97714: IFFALSE 97760
// begin if flags [ normalCounter + i ] then
97716: LD_VAR 0 4
97720: PUSH
97721: LD_EXP 76
97725: PUSH
97726: LD_VAR 0 8
97730: PLUS
97731: ARRAY
97732: IFFALSE 97758
// tmp := tmp & ( 100 + i ) & ; ;
97734: LD_ADDR_VAR 0 3
97738: PUSH
97739: LD_VAR 0 3
97743: PUSH
97744: LD_INT 100
97746: PUSH
97747: LD_VAR 0 8
97751: PLUS
97752: STR
97753: PUSH
97754: LD_STRING ;
97756: STR
97757: ST_TO_ADDR
// end ;
97758: GO 97713
97760: POP
97761: POP
// if tmp then
97762: LD_VAR 0 3
97766: IFFALSE 97778
// active := tmp ;
97768: LD_ADDR_VAR 0 7
97772: PUSH
97773: LD_VAR 0 3
97777: ST_TO_ADDR
// end ; ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & "," & active & ") ) ;
97778: LD_STRING getStreamItemsFromMission("
97780: PUSH
97781: LD_VAR 0 5
97785: STR
97786: PUSH
97787: LD_STRING ","
97789: STR
97790: PUSH
97791: LD_VAR 0 6
97795: STR
97796: PUSH
97797: LD_STRING ","
97799: STR
97800: PUSH
97801: LD_VAR 0 7
97805: STR
97806: PUSH
97807: LD_STRING ")
97809: STR
97810: PPUSH
97811: CALL_OW 559
// end else
97815: GO 97824
// ToLua ( getStreamItemsFromMission("","","") ) ;
97817: LD_STRING getStreamItemsFromMission("","","")
97819: PPUSH
97820: CALL_OW 559
// end ;
97824: LD_VAR 0 2
97828: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
97829: LD_EXP 75
97833: PUSH
97834: LD_EXP 80
97838: AND
97839: IFFALSE 97963
97841: GO 97843
97843: DISABLE
97844: LD_INT 0
97846: PPUSH
97847: PPUSH
// begin enable ;
97848: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
97849: LD_ADDR_VAR 0 2
97853: PUSH
97854: LD_INT 22
97856: PUSH
97857: LD_OWVAR 2
97861: PUSH
97862: EMPTY
97863: LIST
97864: LIST
97865: PUSH
97866: LD_INT 2
97868: PUSH
97869: LD_INT 34
97871: PUSH
97872: LD_INT 7
97874: PUSH
97875: EMPTY
97876: LIST
97877: LIST
97878: PUSH
97879: LD_INT 34
97881: PUSH
97882: LD_INT 45
97884: PUSH
97885: EMPTY
97886: LIST
97887: LIST
97888: PUSH
97889: LD_INT 34
97891: PUSH
97892: LD_INT 28
97894: PUSH
97895: EMPTY
97896: LIST
97897: LIST
97898: PUSH
97899: LD_INT 34
97901: PUSH
97902: LD_INT 47
97904: PUSH
97905: EMPTY
97906: LIST
97907: LIST
97908: PUSH
97909: EMPTY
97910: LIST
97911: LIST
97912: LIST
97913: LIST
97914: LIST
97915: PUSH
97916: EMPTY
97917: LIST
97918: LIST
97919: PPUSH
97920: CALL_OW 69
97924: ST_TO_ADDR
// if not tmp then
97925: LD_VAR 0 2
97929: NOT
97930: IFFALSE 97934
// exit ;
97932: GO 97963
// for i in tmp do
97934: LD_ADDR_VAR 0 1
97938: PUSH
97939: LD_VAR 0 2
97943: PUSH
97944: FOR_IN
97945: IFFALSE 97961
// begin SetLives ( i , 0 ) ;
97947: LD_VAR 0 1
97951: PPUSH
97952: LD_INT 0
97954: PPUSH
97955: CALL_OW 234
// end ;
97959: GO 97944
97961: POP
97962: POP
// end ;
97963: PPOPN 2
97965: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
97966: LD_EXP 75
97970: PUSH
97971: LD_EXP 81
97975: AND
97976: IFFALSE 98060
97978: GO 97980
97980: DISABLE
97981: LD_INT 0
97983: PPUSH
97984: PPUSH
// begin enable ;
97985: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
97986: LD_ADDR_VAR 0 2
97990: PUSH
97991: LD_INT 22
97993: PUSH
97994: LD_OWVAR 2
97998: PUSH
97999: EMPTY
98000: LIST
98001: LIST
98002: PUSH
98003: LD_INT 32
98005: PUSH
98006: LD_INT 3
98008: PUSH
98009: EMPTY
98010: LIST
98011: LIST
98012: PUSH
98013: EMPTY
98014: LIST
98015: LIST
98016: PPUSH
98017: CALL_OW 69
98021: ST_TO_ADDR
// if not tmp then
98022: LD_VAR 0 2
98026: NOT
98027: IFFALSE 98031
// exit ;
98029: GO 98060
// for i in tmp do
98031: LD_ADDR_VAR 0 1
98035: PUSH
98036: LD_VAR 0 2
98040: PUSH
98041: FOR_IN
98042: IFFALSE 98058
// begin SetLives ( i , 0 ) ;
98044: LD_VAR 0 1
98048: PPUSH
98049: LD_INT 0
98051: PPUSH
98052: CALL_OW 234
// end ;
98056: GO 98041
98058: POP
98059: POP
// end ;
98060: PPOPN 2
98062: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
98063: LD_EXP 75
98067: PUSH
98068: LD_EXP 78
98072: AND
98073: IFFALSE 98166
98075: GO 98077
98077: DISABLE
98078: LD_INT 0
98080: PPUSH
// begin enable ;
98081: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
98082: LD_ADDR_VAR 0 1
98086: PUSH
98087: LD_INT 22
98089: PUSH
98090: LD_OWVAR 2
98094: PUSH
98095: EMPTY
98096: LIST
98097: LIST
98098: PUSH
98099: LD_INT 2
98101: PUSH
98102: LD_INT 25
98104: PUSH
98105: LD_INT 5
98107: PUSH
98108: EMPTY
98109: LIST
98110: LIST
98111: PUSH
98112: LD_INT 25
98114: PUSH
98115: LD_INT 9
98117: PUSH
98118: EMPTY
98119: LIST
98120: LIST
98121: PUSH
98122: LD_INT 25
98124: PUSH
98125: LD_INT 8
98127: PUSH
98128: EMPTY
98129: LIST
98130: LIST
98131: PUSH
98132: EMPTY
98133: LIST
98134: LIST
98135: LIST
98136: LIST
98137: PUSH
98138: EMPTY
98139: LIST
98140: LIST
98141: PPUSH
98142: CALL_OW 69
98146: PUSH
98147: FOR_IN
98148: IFFALSE 98164
// begin SetClass ( i , 1 ) ;
98150: LD_VAR 0 1
98154: PPUSH
98155: LD_INT 1
98157: PPUSH
98158: CALL_OW 336
// end ;
98162: GO 98147
98164: POP
98165: POP
// end ;
98166: PPOPN 1
98168: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
98169: LD_EXP 75
98173: PUSH
98174: LD_EXP 79
98178: AND
98179: PUSH
98180: LD_OWVAR 65
98184: PUSH
98185: LD_INT 7
98187: LESS
98188: AND
98189: IFFALSE 98203
98191: GO 98193
98193: DISABLE
// begin enable ;
98194: ENABLE
// game_speed := 7 ;
98195: LD_ADDR_OWVAR 65
98199: PUSH
98200: LD_INT 7
98202: ST_TO_ADDR
// end ;
98203: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
98204: LD_EXP 75
98208: PUSH
98209: LD_EXP 82
98213: AND
98214: IFFALSE 98416
98216: GO 98218
98218: DISABLE
98219: LD_INT 0
98221: PPUSH
98222: PPUSH
98223: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
98224: LD_ADDR_VAR 0 3
98228: PUSH
98229: LD_INT 81
98231: PUSH
98232: LD_OWVAR 2
98236: PUSH
98237: EMPTY
98238: LIST
98239: LIST
98240: PUSH
98241: LD_INT 21
98243: PUSH
98244: LD_INT 1
98246: PUSH
98247: EMPTY
98248: LIST
98249: LIST
98250: PUSH
98251: EMPTY
98252: LIST
98253: LIST
98254: PPUSH
98255: CALL_OW 69
98259: ST_TO_ADDR
// if not tmp then
98260: LD_VAR 0 3
98264: NOT
98265: IFFALSE 98269
// exit ;
98267: GO 98416
// if tmp > 5 then
98269: LD_VAR 0 3
98273: PUSH
98274: LD_INT 5
98276: GREATER
98277: IFFALSE 98289
// k := 5 else
98279: LD_ADDR_VAR 0 2
98283: PUSH
98284: LD_INT 5
98286: ST_TO_ADDR
98287: GO 98299
// k := tmp ;
98289: LD_ADDR_VAR 0 2
98293: PUSH
98294: LD_VAR 0 3
98298: ST_TO_ADDR
// for i := 1 to k do
98299: LD_ADDR_VAR 0 1
98303: PUSH
98304: DOUBLE
98305: LD_INT 1
98307: DEC
98308: ST_TO_ADDR
98309: LD_VAR 0 2
98313: PUSH
98314: FOR_TO
98315: IFFALSE 98414
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
98317: LD_VAR 0 3
98321: PUSH
98322: LD_VAR 0 1
98326: ARRAY
98327: PPUSH
98328: LD_VAR 0 1
98332: PUSH
98333: LD_INT 4
98335: MOD
98336: PUSH
98337: LD_INT 1
98339: PLUS
98340: PPUSH
98341: CALL_OW 259
98345: PUSH
98346: LD_INT 10
98348: LESS
98349: IFFALSE 98412
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
98351: LD_VAR 0 3
98355: PUSH
98356: LD_VAR 0 1
98360: ARRAY
98361: PPUSH
98362: LD_VAR 0 1
98366: PUSH
98367: LD_INT 4
98369: MOD
98370: PUSH
98371: LD_INT 1
98373: PLUS
98374: PPUSH
98375: LD_VAR 0 3
98379: PUSH
98380: LD_VAR 0 1
98384: ARRAY
98385: PPUSH
98386: LD_VAR 0 1
98390: PUSH
98391: LD_INT 4
98393: MOD
98394: PUSH
98395: LD_INT 1
98397: PLUS
98398: PPUSH
98399: CALL_OW 259
98403: PUSH
98404: LD_INT 1
98406: PLUS
98407: PPUSH
98408: CALL_OW 237
98412: GO 98314
98414: POP
98415: POP
// end ;
98416: PPOPN 3
98418: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
98419: LD_EXP 75
98423: PUSH
98424: LD_EXP 83
98428: AND
98429: IFFALSE 98449
98431: GO 98433
98433: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
98434: LD_INT 4
98436: PPUSH
98437: LD_OWVAR 2
98441: PPUSH
98442: LD_INT 0
98444: PPUSH
98445: CALL_OW 324
98449: END
// every 0 0$1 trigger StreamModeActive and sShovel do
98450: LD_EXP 75
98454: PUSH
98455: LD_EXP 112
98459: AND
98460: IFFALSE 98480
98462: GO 98464
98464: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
98465: LD_INT 19
98467: PPUSH
98468: LD_OWVAR 2
98472: PPUSH
98473: LD_INT 0
98475: PPUSH
98476: CALL_OW 324
98480: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
98481: LD_EXP 75
98485: PUSH
98486: LD_EXP 84
98490: AND
98491: IFFALSE 98593
98493: GO 98495
98495: DISABLE
98496: LD_INT 0
98498: PPUSH
98499: PPUSH
// begin enable ;
98500: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
98501: LD_ADDR_VAR 0 2
98505: PUSH
98506: LD_INT 22
98508: PUSH
98509: LD_OWVAR 2
98513: PUSH
98514: EMPTY
98515: LIST
98516: LIST
98517: PUSH
98518: LD_INT 2
98520: PUSH
98521: LD_INT 34
98523: PUSH
98524: LD_INT 11
98526: PUSH
98527: EMPTY
98528: LIST
98529: LIST
98530: PUSH
98531: LD_INT 34
98533: PUSH
98534: LD_INT 30
98536: PUSH
98537: EMPTY
98538: LIST
98539: LIST
98540: PUSH
98541: EMPTY
98542: LIST
98543: LIST
98544: LIST
98545: PUSH
98546: EMPTY
98547: LIST
98548: LIST
98549: PPUSH
98550: CALL_OW 69
98554: ST_TO_ADDR
// if not tmp then
98555: LD_VAR 0 2
98559: NOT
98560: IFFALSE 98564
// exit ;
98562: GO 98593
// for i in tmp do
98564: LD_ADDR_VAR 0 1
98568: PUSH
98569: LD_VAR 0 2
98573: PUSH
98574: FOR_IN
98575: IFFALSE 98591
// begin SetLives ( i , 0 ) ;
98577: LD_VAR 0 1
98581: PPUSH
98582: LD_INT 0
98584: PPUSH
98585: CALL_OW 234
// end ;
98589: GO 98574
98591: POP
98592: POP
// end ;
98593: PPOPN 2
98595: END
// every 0 0$1 trigger StreamModeActive and sBunker do
98596: LD_EXP 75
98600: PUSH
98601: LD_EXP 85
98605: AND
98606: IFFALSE 98626
98608: GO 98610
98610: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
98611: LD_INT 32
98613: PPUSH
98614: LD_OWVAR 2
98618: PPUSH
98619: LD_INT 0
98621: PPUSH
98622: CALL_OW 324
98626: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
98627: LD_EXP 75
98631: PUSH
98632: LD_EXP 86
98636: AND
98637: IFFALSE 98818
98639: GO 98641
98641: DISABLE
98642: LD_INT 0
98644: PPUSH
98645: PPUSH
98646: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
98647: LD_ADDR_VAR 0 2
98651: PUSH
98652: LD_INT 22
98654: PUSH
98655: LD_OWVAR 2
98659: PUSH
98660: EMPTY
98661: LIST
98662: LIST
98663: PUSH
98664: LD_INT 33
98666: PUSH
98667: LD_INT 3
98669: PUSH
98670: EMPTY
98671: LIST
98672: LIST
98673: PUSH
98674: EMPTY
98675: LIST
98676: LIST
98677: PPUSH
98678: CALL_OW 69
98682: ST_TO_ADDR
// if not tmp then
98683: LD_VAR 0 2
98687: NOT
98688: IFFALSE 98692
// exit ;
98690: GO 98818
// side := 0 ;
98692: LD_ADDR_VAR 0 3
98696: PUSH
98697: LD_INT 0
98699: ST_TO_ADDR
// for i := 1 to 8 do
98700: LD_ADDR_VAR 0 1
98704: PUSH
98705: DOUBLE
98706: LD_INT 1
98708: DEC
98709: ST_TO_ADDR
98710: LD_INT 8
98712: PUSH
98713: FOR_TO
98714: IFFALSE 98762
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
98716: LD_OWVAR 2
98720: PUSH
98721: LD_VAR 0 1
98725: NONEQUAL
98726: PUSH
98727: LD_OWVAR 2
98731: PPUSH
98732: LD_VAR 0 1
98736: PPUSH
98737: CALL_OW 81
98741: PUSH
98742: LD_INT 2
98744: EQUAL
98745: AND
98746: IFFALSE 98760
// begin side := i ;
98748: LD_ADDR_VAR 0 3
98752: PUSH
98753: LD_VAR 0 1
98757: ST_TO_ADDR
// break ;
98758: GO 98762
// end ;
98760: GO 98713
98762: POP
98763: POP
// if not side then
98764: LD_VAR 0 3
98768: NOT
98769: IFFALSE 98773
// exit ;
98771: GO 98818
// for i := 1 to tmp do
98773: LD_ADDR_VAR 0 1
98777: PUSH
98778: DOUBLE
98779: LD_INT 1
98781: DEC
98782: ST_TO_ADDR
98783: LD_VAR 0 2
98787: PUSH
98788: FOR_TO
98789: IFFALSE 98816
// if Prob ( 60 ) then
98791: LD_INT 60
98793: PPUSH
98794: CALL_OW 13
98798: IFFALSE 98814
// SetSide ( i , side ) ;
98800: LD_VAR 0 1
98804: PPUSH
98805: LD_VAR 0 3
98809: PPUSH
98810: CALL_OW 235
98814: GO 98788
98816: POP
98817: POP
// end ;
98818: PPOPN 3
98820: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
98821: LD_EXP 75
98825: PUSH
98826: LD_EXP 88
98830: AND
98831: IFFALSE 98950
98833: GO 98835
98835: DISABLE
98836: LD_INT 0
98838: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
98839: LD_ADDR_VAR 0 1
98843: PUSH
98844: LD_INT 22
98846: PUSH
98847: LD_OWVAR 2
98851: PUSH
98852: EMPTY
98853: LIST
98854: LIST
98855: PUSH
98856: LD_INT 21
98858: PUSH
98859: LD_INT 1
98861: PUSH
98862: EMPTY
98863: LIST
98864: LIST
98865: PUSH
98866: LD_INT 3
98868: PUSH
98869: LD_INT 23
98871: PUSH
98872: LD_INT 0
98874: PUSH
98875: EMPTY
98876: LIST
98877: LIST
98878: PUSH
98879: EMPTY
98880: LIST
98881: LIST
98882: PUSH
98883: EMPTY
98884: LIST
98885: LIST
98886: LIST
98887: PPUSH
98888: CALL_OW 69
98892: PUSH
98893: FOR_IN
98894: IFFALSE 98948
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
98896: LD_VAR 0 1
98900: PPUSH
98901: CALL_OW 257
98905: PUSH
98906: LD_INT 1
98908: PUSH
98909: LD_INT 2
98911: PUSH
98912: LD_INT 3
98914: PUSH
98915: LD_INT 4
98917: PUSH
98918: EMPTY
98919: LIST
98920: LIST
98921: LIST
98922: LIST
98923: IN
98924: IFFALSE 98946
// SetClass ( un , rand ( 1 , 4 ) ) ;
98926: LD_VAR 0 1
98930: PPUSH
98931: LD_INT 1
98933: PPUSH
98934: LD_INT 4
98936: PPUSH
98937: CALL_OW 12
98941: PPUSH
98942: CALL_OW 336
98946: GO 98893
98948: POP
98949: POP
// end ;
98950: PPOPN 1
98952: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
98953: LD_EXP 75
98957: PUSH
98958: LD_EXP 87
98962: AND
98963: IFFALSE 99042
98965: GO 98967
98967: DISABLE
98968: LD_INT 0
98970: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
98971: LD_ADDR_VAR 0 1
98975: PUSH
98976: LD_INT 22
98978: PUSH
98979: LD_OWVAR 2
98983: PUSH
98984: EMPTY
98985: LIST
98986: LIST
98987: PUSH
98988: LD_INT 21
98990: PUSH
98991: LD_INT 3
98993: PUSH
98994: EMPTY
98995: LIST
98996: LIST
98997: PUSH
98998: EMPTY
98999: LIST
99000: LIST
99001: PPUSH
99002: CALL_OW 69
99006: ST_TO_ADDR
// if not tmp then
99007: LD_VAR 0 1
99011: NOT
99012: IFFALSE 99016
// exit ;
99014: GO 99042
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
99016: LD_VAR 0 1
99020: PUSH
99021: LD_INT 1
99023: PPUSH
99024: LD_VAR 0 1
99028: PPUSH
99029: CALL_OW 12
99033: ARRAY
99034: PPUSH
99035: LD_INT 100
99037: PPUSH
99038: CALL_OW 234
// end ;
99042: PPOPN 1
99044: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
99045: LD_EXP 75
99049: PUSH
99050: LD_EXP 89
99054: AND
99055: IFFALSE 99153
99057: GO 99059
99059: DISABLE
99060: LD_INT 0
99062: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
99063: LD_ADDR_VAR 0 1
99067: PUSH
99068: LD_INT 22
99070: PUSH
99071: LD_OWVAR 2
99075: PUSH
99076: EMPTY
99077: LIST
99078: LIST
99079: PUSH
99080: LD_INT 21
99082: PUSH
99083: LD_INT 1
99085: PUSH
99086: EMPTY
99087: LIST
99088: LIST
99089: PUSH
99090: EMPTY
99091: LIST
99092: LIST
99093: PPUSH
99094: CALL_OW 69
99098: ST_TO_ADDR
// if not tmp then
99099: LD_VAR 0 1
99103: NOT
99104: IFFALSE 99108
// exit ;
99106: GO 99153
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
99108: LD_VAR 0 1
99112: PUSH
99113: LD_INT 1
99115: PPUSH
99116: LD_VAR 0 1
99120: PPUSH
99121: CALL_OW 12
99125: ARRAY
99126: PPUSH
99127: LD_INT 1
99129: PPUSH
99130: LD_INT 4
99132: PPUSH
99133: CALL_OW 12
99137: PPUSH
99138: LD_INT 3000
99140: PPUSH
99141: LD_INT 9000
99143: PPUSH
99144: CALL_OW 12
99148: PPUSH
99149: CALL_OW 492
// end ;
99153: PPOPN 1
99155: END
// every 0 0$1 trigger StreamModeActive and sDepot do
99156: LD_EXP 75
99160: PUSH
99161: LD_EXP 90
99165: AND
99166: IFFALSE 99186
99168: GO 99170
99170: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
99171: LD_INT 1
99173: PPUSH
99174: LD_OWVAR 2
99178: PPUSH
99179: LD_INT 0
99181: PPUSH
99182: CALL_OW 324
99186: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
99187: LD_EXP 75
99191: PUSH
99192: LD_EXP 91
99196: AND
99197: IFFALSE 99280
99199: GO 99201
99201: DISABLE
99202: LD_INT 0
99204: PPUSH
99205: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
99206: LD_ADDR_VAR 0 2
99210: PUSH
99211: LD_INT 22
99213: PUSH
99214: LD_OWVAR 2
99218: PUSH
99219: EMPTY
99220: LIST
99221: LIST
99222: PUSH
99223: LD_INT 21
99225: PUSH
99226: LD_INT 3
99228: PUSH
99229: EMPTY
99230: LIST
99231: LIST
99232: PUSH
99233: EMPTY
99234: LIST
99235: LIST
99236: PPUSH
99237: CALL_OW 69
99241: ST_TO_ADDR
// if not tmp then
99242: LD_VAR 0 2
99246: NOT
99247: IFFALSE 99251
// exit ;
99249: GO 99280
// for i in tmp do
99251: LD_ADDR_VAR 0 1
99255: PUSH
99256: LD_VAR 0 2
99260: PUSH
99261: FOR_IN
99262: IFFALSE 99278
// SetBLevel ( i , 10 ) ;
99264: LD_VAR 0 1
99268: PPUSH
99269: LD_INT 10
99271: PPUSH
99272: CALL_OW 241
99276: GO 99261
99278: POP
99279: POP
// end ;
99280: PPOPN 2
99282: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
99283: LD_EXP 75
99287: PUSH
99288: LD_EXP 92
99292: AND
99293: IFFALSE 99404
99295: GO 99297
99297: DISABLE
99298: LD_INT 0
99300: PPUSH
99301: PPUSH
99302: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
99303: LD_ADDR_VAR 0 3
99307: PUSH
99308: LD_INT 22
99310: PUSH
99311: LD_OWVAR 2
99315: PUSH
99316: EMPTY
99317: LIST
99318: LIST
99319: PUSH
99320: LD_INT 25
99322: PUSH
99323: LD_INT 1
99325: PUSH
99326: EMPTY
99327: LIST
99328: LIST
99329: PUSH
99330: EMPTY
99331: LIST
99332: LIST
99333: PPUSH
99334: CALL_OW 69
99338: ST_TO_ADDR
// if not tmp then
99339: LD_VAR 0 3
99343: NOT
99344: IFFALSE 99348
// exit ;
99346: GO 99404
// un := tmp [ rand ( 1 , tmp ) ] ;
99348: LD_ADDR_VAR 0 2
99352: PUSH
99353: LD_VAR 0 3
99357: PUSH
99358: LD_INT 1
99360: PPUSH
99361: LD_VAR 0 3
99365: PPUSH
99366: CALL_OW 12
99370: ARRAY
99371: ST_TO_ADDR
// if Crawls ( un ) then
99372: LD_VAR 0 2
99376: PPUSH
99377: CALL_OW 318
99381: IFFALSE 99392
// ComWalk ( un ) ;
99383: LD_VAR 0 2
99387: PPUSH
99388: CALL_OW 138
// SetClass ( un , class_sniper ) ;
99392: LD_VAR 0 2
99396: PPUSH
99397: LD_INT 5
99399: PPUSH
99400: CALL_OW 336
// end ;
99404: PPOPN 3
99406: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 4 do
99407: LD_EXP 75
99411: PUSH
99412: LD_EXP 93
99416: AND
99417: PUSH
99418: LD_OWVAR 67
99422: PUSH
99423: LD_INT 4
99425: LESS
99426: AND
99427: IFFALSE 99446
99429: GO 99431
99431: DISABLE
// begin Difficulty := Difficulty + 1 ;
99432: LD_ADDR_OWVAR 67
99436: PUSH
99437: LD_OWVAR 67
99441: PUSH
99442: LD_INT 1
99444: PLUS
99445: ST_TO_ADDR
// end ;
99446: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
99447: LD_EXP 75
99451: PUSH
99452: LD_EXP 94
99456: AND
99457: IFFALSE 99560
99459: GO 99461
99461: DISABLE
99462: LD_INT 0
99464: PPUSH
// begin for i := 1 to 5 do
99465: LD_ADDR_VAR 0 1
99469: PUSH
99470: DOUBLE
99471: LD_INT 1
99473: DEC
99474: ST_TO_ADDR
99475: LD_INT 5
99477: PUSH
99478: FOR_TO
99479: IFFALSE 99558
// begin uc_nation := nation_nature ;
99481: LD_ADDR_OWVAR 21
99485: PUSH
99486: LD_INT 0
99488: ST_TO_ADDR
// uc_side := 0 ;
99489: LD_ADDR_OWVAR 20
99493: PUSH
99494: LD_INT 0
99496: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
99497: LD_ADDR_OWVAR 29
99501: PUSH
99502: LD_INT 12
99504: PUSH
99505: LD_INT 12
99507: PUSH
99508: EMPTY
99509: LIST
99510: LIST
99511: ST_TO_ADDR
// hc_agressivity := 20 ;
99512: LD_ADDR_OWVAR 35
99516: PUSH
99517: LD_INT 20
99519: ST_TO_ADDR
// hc_class := class_tiger ;
99520: LD_ADDR_OWVAR 28
99524: PUSH
99525: LD_INT 14
99527: ST_TO_ADDR
// hc_gallery :=  ;
99528: LD_ADDR_OWVAR 33
99532: PUSH
99533: LD_STRING 
99535: ST_TO_ADDR
// hc_name :=  ;
99536: LD_ADDR_OWVAR 26
99540: PUSH
99541: LD_STRING 
99543: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
99544: CALL_OW 44
99548: PPUSH
99549: LD_INT 0
99551: PPUSH
99552: CALL_OW 51
// end ;
99556: GO 99478
99558: POP
99559: POP
// end ;
99560: PPOPN 1
99562: END
// every 0 0$1 trigger StreamModeActive and sBomb do
99563: LD_EXP 75
99567: PUSH
99568: LD_EXP 95
99572: AND
99573: IFFALSE 99582
99575: GO 99577
99577: DISABLE
// StreamSibBomb ;
99578: CALL 99583 0 0
99582: END
// export function StreamSibBomb ; var i , x , y ; begin
99583: LD_INT 0
99585: PPUSH
99586: PPUSH
99587: PPUSH
99588: PPUSH
// result := false ;
99589: LD_ADDR_VAR 0 1
99593: PUSH
99594: LD_INT 0
99596: ST_TO_ADDR
// for i := 1 to 16 do
99597: LD_ADDR_VAR 0 2
99601: PUSH
99602: DOUBLE
99603: LD_INT 1
99605: DEC
99606: ST_TO_ADDR
99607: LD_INT 16
99609: PUSH
99610: FOR_TO
99611: IFFALSE 99810
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
99613: LD_ADDR_VAR 0 3
99617: PUSH
99618: LD_INT 10
99620: PUSH
99621: LD_INT 20
99623: PUSH
99624: LD_INT 30
99626: PUSH
99627: LD_INT 40
99629: PUSH
99630: LD_INT 50
99632: PUSH
99633: LD_INT 60
99635: PUSH
99636: LD_INT 70
99638: PUSH
99639: LD_INT 80
99641: PUSH
99642: LD_INT 90
99644: PUSH
99645: LD_INT 100
99647: PUSH
99648: LD_INT 110
99650: PUSH
99651: LD_INT 120
99653: PUSH
99654: LD_INT 130
99656: PUSH
99657: LD_INT 140
99659: PUSH
99660: LD_INT 150
99662: PUSH
99663: EMPTY
99664: LIST
99665: LIST
99666: LIST
99667: LIST
99668: LIST
99669: LIST
99670: LIST
99671: LIST
99672: LIST
99673: LIST
99674: LIST
99675: LIST
99676: LIST
99677: LIST
99678: LIST
99679: PUSH
99680: LD_INT 1
99682: PPUSH
99683: LD_INT 15
99685: PPUSH
99686: CALL_OW 12
99690: ARRAY
99691: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
99692: LD_ADDR_VAR 0 4
99696: PUSH
99697: LD_INT 10
99699: PUSH
99700: LD_INT 20
99702: PUSH
99703: LD_INT 30
99705: PUSH
99706: LD_INT 40
99708: PUSH
99709: LD_INT 50
99711: PUSH
99712: LD_INT 60
99714: PUSH
99715: LD_INT 70
99717: PUSH
99718: LD_INT 80
99720: PUSH
99721: LD_INT 90
99723: PUSH
99724: LD_INT 100
99726: PUSH
99727: LD_INT 110
99729: PUSH
99730: LD_INT 120
99732: PUSH
99733: LD_INT 130
99735: PUSH
99736: LD_INT 140
99738: PUSH
99739: LD_INT 150
99741: PUSH
99742: EMPTY
99743: LIST
99744: LIST
99745: LIST
99746: LIST
99747: LIST
99748: LIST
99749: LIST
99750: LIST
99751: LIST
99752: LIST
99753: LIST
99754: LIST
99755: LIST
99756: LIST
99757: LIST
99758: PUSH
99759: LD_INT 1
99761: PPUSH
99762: LD_INT 15
99764: PPUSH
99765: CALL_OW 12
99769: ARRAY
99770: ST_TO_ADDR
// if ValidHex ( x , y ) then
99771: LD_VAR 0 3
99775: PPUSH
99776: LD_VAR 0 4
99780: PPUSH
99781: CALL_OW 488
99785: IFFALSE 99808
// begin result := [ x , y ] ;
99787: LD_ADDR_VAR 0 1
99791: PUSH
99792: LD_VAR 0 3
99796: PUSH
99797: LD_VAR 0 4
99801: PUSH
99802: EMPTY
99803: LIST
99804: LIST
99805: ST_TO_ADDR
// break ;
99806: GO 99810
// end ; end ;
99808: GO 99610
99810: POP
99811: POP
// if result then
99812: LD_VAR 0 1
99816: IFFALSE 99876
// begin ToLua ( playSibBomb() ) ;
99818: LD_STRING playSibBomb()
99820: PPUSH
99821: CALL_OW 559
// wait ( 0 0$14 ) ;
99825: LD_INT 490
99827: PPUSH
99828: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
99832: LD_VAR 0 1
99836: PUSH
99837: LD_INT 1
99839: ARRAY
99840: PPUSH
99841: LD_VAR 0 1
99845: PUSH
99846: LD_INT 2
99848: ARRAY
99849: PPUSH
99850: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
99854: LD_VAR 0 1
99858: PUSH
99859: LD_INT 1
99861: ARRAY
99862: PPUSH
99863: LD_VAR 0 1
99867: PUSH
99868: LD_INT 2
99870: ARRAY
99871: PPUSH
99872: CALL_OW 429
// end ; end ;
99876: LD_VAR 0 1
99880: RET
// every 0 0$1 trigger StreamModeActive and sReset do
99881: LD_EXP 75
99885: PUSH
99886: LD_EXP 97
99890: AND
99891: IFFALSE 99903
99893: GO 99895
99895: DISABLE
// YouLost (  ) ;
99896: LD_STRING 
99898: PPUSH
99899: CALL_OW 104
99903: END
// every 0 0$1 trigger StreamModeActive and sFog do
99904: LD_EXP 75
99908: PUSH
99909: LD_EXP 96
99913: AND
99914: IFFALSE 99928
99916: GO 99918
99918: DISABLE
// FogOff ( your_side ) ;
99919: LD_OWVAR 2
99923: PPUSH
99924: CALL_OW 344
99928: END
// every 0 0$1 trigger StreamModeActive and sSun do
99929: LD_EXP 75
99933: PUSH
99934: LD_EXP 98
99938: AND
99939: IFFALSE 99967
99941: GO 99943
99943: DISABLE
// begin solar_recharge_percent := 0 ;
99944: LD_ADDR_OWVAR 79
99948: PUSH
99949: LD_INT 0
99951: ST_TO_ADDR
// wait ( 5 5$00 ) ;
99952: LD_INT 10500
99954: PPUSH
99955: CALL_OW 67
// solar_recharge_percent := 100 ;
99959: LD_ADDR_OWVAR 79
99963: PUSH
99964: LD_INT 100
99966: ST_TO_ADDR
// end ;
99967: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
99968: LD_EXP 75
99972: PUSH
99973: LD_EXP 99
99977: AND
99978: IFFALSE 100217
99980: GO 99982
99982: DISABLE
99983: LD_INT 0
99985: PPUSH
99986: PPUSH
99987: PPUSH
// begin tmp := [ ] ;
99988: LD_ADDR_VAR 0 3
99992: PUSH
99993: EMPTY
99994: ST_TO_ADDR
// for i := 1 to 6 do
99995: LD_ADDR_VAR 0 1
99999: PUSH
100000: DOUBLE
100001: LD_INT 1
100003: DEC
100004: ST_TO_ADDR
100005: LD_INT 6
100007: PUSH
100008: FOR_TO
100009: IFFALSE 100114
// begin uc_nation := nation_nature ;
100011: LD_ADDR_OWVAR 21
100015: PUSH
100016: LD_INT 0
100018: ST_TO_ADDR
// uc_side := 0 ;
100019: LD_ADDR_OWVAR 20
100023: PUSH
100024: LD_INT 0
100026: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
100027: LD_ADDR_OWVAR 29
100031: PUSH
100032: LD_INT 12
100034: PUSH
100035: LD_INT 12
100037: PUSH
100038: EMPTY
100039: LIST
100040: LIST
100041: ST_TO_ADDR
// hc_agressivity := 20 ;
100042: LD_ADDR_OWVAR 35
100046: PUSH
100047: LD_INT 20
100049: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
100050: LD_ADDR_OWVAR 28
100054: PUSH
100055: LD_INT 17
100057: ST_TO_ADDR
// hc_gallery :=  ;
100058: LD_ADDR_OWVAR 33
100062: PUSH
100063: LD_STRING 
100065: ST_TO_ADDR
// hc_name :=  ;
100066: LD_ADDR_OWVAR 26
100070: PUSH
100071: LD_STRING 
100073: ST_TO_ADDR
// un := CreateHuman ;
100074: LD_ADDR_VAR 0 2
100078: PUSH
100079: CALL_OW 44
100083: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
100084: LD_VAR 0 2
100088: PPUSH
100089: LD_INT 1
100091: PPUSH
100092: CALL_OW 51
// tmp := tmp ^ un ;
100096: LD_ADDR_VAR 0 3
100100: PUSH
100101: LD_VAR 0 3
100105: PUSH
100106: LD_VAR 0 2
100110: ADD
100111: ST_TO_ADDR
// end ;
100112: GO 100008
100114: POP
100115: POP
// repeat wait ( 0 0$1 ) ;
100116: LD_INT 35
100118: PPUSH
100119: CALL_OW 67
// for un in tmp do
100123: LD_ADDR_VAR 0 2
100127: PUSH
100128: LD_VAR 0 3
100132: PUSH
100133: FOR_IN
100134: IFFALSE 100208
// begin if IsDead ( un ) then
100136: LD_VAR 0 2
100140: PPUSH
100141: CALL_OW 301
100145: IFFALSE 100165
// begin tmp := tmp diff un ;
100147: LD_ADDR_VAR 0 3
100151: PUSH
100152: LD_VAR 0 3
100156: PUSH
100157: LD_VAR 0 2
100161: DIFF
100162: ST_TO_ADDR
// continue ;
100163: GO 100133
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
100165: LD_VAR 0 2
100169: PPUSH
100170: LD_INT 3
100172: PUSH
100173: LD_INT 22
100175: PUSH
100176: LD_INT 0
100178: PUSH
100179: EMPTY
100180: LIST
100181: LIST
100182: PUSH
100183: EMPTY
100184: LIST
100185: LIST
100186: PPUSH
100187: CALL_OW 69
100191: PPUSH
100192: LD_VAR 0 2
100196: PPUSH
100197: CALL_OW 74
100201: PPUSH
100202: CALL_OW 115
// end ;
100206: GO 100133
100208: POP
100209: POP
// until not tmp ;
100210: LD_VAR 0 3
100214: NOT
100215: IFFALSE 100116
// end ;
100217: PPOPN 3
100219: END
// every 0 0$1 trigger StreamModeActive and sTroll do
100220: LD_EXP 75
100224: PUSH
100225: LD_EXP 100
100229: AND
100230: IFFALSE 100284
100232: GO 100234
100234: DISABLE
// begin ToLua ( displayTroll(); ) ;
100235: LD_STRING displayTroll();
100237: PPUSH
100238: CALL_OW 559
// wait ( 3 3$00 ) ;
100242: LD_INT 6300
100244: PPUSH
100245: CALL_OW 67
// ToLua ( hideTroll(); ) ;
100249: LD_STRING hideTroll();
100251: PPUSH
100252: CALL_OW 559
// wait ( 1 1$00 ) ;
100256: LD_INT 2100
100258: PPUSH
100259: CALL_OW 67
// ToLua ( displayTroll(); ) ;
100263: LD_STRING displayTroll();
100265: PPUSH
100266: CALL_OW 559
// wait ( 1 1$00 ) ;
100270: LD_INT 2100
100272: PPUSH
100273: CALL_OW 67
// ToLua ( hideTroll(); ) ;
100277: LD_STRING hideTroll();
100279: PPUSH
100280: CALL_OW 559
// end ;
100284: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
100285: LD_EXP 75
100289: PUSH
100290: LD_EXP 101
100294: AND
100295: IFFALSE 100358
100297: GO 100299
100299: DISABLE
100300: LD_INT 0
100302: PPUSH
// begin p := 0 ;
100303: LD_ADDR_VAR 0 1
100307: PUSH
100308: LD_INT 0
100310: ST_TO_ADDR
// repeat game_speed := 1 ;
100311: LD_ADDR_OWVAR 65
100315: PUSH
100316: LD_INT 1
100318: ST_TO_ADDR
// wait ( 0 0$1 ) ;
100319: LD_INT 35
100321: PPUSH
100322: CALL_OW 67
// p := p + 1 ;
100326: LD_ADDR_VAR 0 1
100330: PUSH
100331: LD_VAR 0 1
100335: PUSH
100336: LD_INT 1
100338: PLUS
100339: ST_TO_ADDR
// until p >= 60 ;
100340: LD_VAR 0 1
100344: PUSH
100345: LD_INT 60
100347: GREATEREQUAL
100348: IFFALSE 100311
// game_speed := 4 ;
100350: LD_ADDR_OWVAR 65
100354: PUSH
100355: LD_INT 4
100357: ST_TO_ADDR
// end ;
100358: PPOPN 1
100360: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
100361: LD_EXP 75
100365: PUSH
100366: LD_EXP 102
100370: AND
100371: IFFALSE 100517
100373: GO 100375
100375: DISABLE
100376: LD_INT 0
100378: PPUSH
100379: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
100380: LD_ADDR_VAR 0 1
100384: PUSH
100385: LD_INT 22
100387: PUSH
100388: LD_OWVAR 2
100392: PUSH
100393: EMPTY
100394: LIST
100395: LIST
100396: PUSH
100397: LD_INT 2
100399: PUSH
100400: LD_INT 30
100402: PUSH
100403: LD_INT 0
100405: PUSH
100406: EMPTY
100407: LIST
100408: LIST
100409: PUSH
100410: LD_INT 30
100412: PUSH
100413: LD_INT 1
100415: PUSH
100416: EMPTY
100417: LIST
100418: LIST
100419: PUSH
100420: EMPTY
100421: LIST
100422: LIST
100423: LIST
100424: PUSH
100425: EMPTY
100426: LIST
100427: LIST
100428: PPUSH
100429: CALL_OW 69
100433: ST_TO_ADDR
// if not depot then
100434: LD_VAR 0 1
100438: NOT
100439: IFFALSE 100443
// exit ;
100441: GO 100517
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
100443: LD_ADDR_VAR 0 2
100447: PUSH
100448: LD_VAR 0 1
100452: PUSH
100453: LD_INT 1
100455: PPUSH
100456: LD_VAR 0 1
100460: PPUSH
100461: CALL_OW 12
100465: ARRAY
100466: PPUSH
100467: CALL_OW 274
100471: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
100472: LD_VAR 0 2
100476: PPUSH
100477: LD_INT 1
100479: PPUSH
100480: LD_INT 0
100482: PPUSH
100483: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
100487: LD_VAR 0 2
100491: PPUSH
100492: LD_INT 2
100494: PPUSH
100495: LD_INT 0
100497: PPUSH
100498: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
100502: LD_VAR 0 2
100506: PPUSH
100507: LD_INT 3
100509: PPUSH
100510: LD_INT 0
100512: PPUSH
100513: CALL_OW 277
// end ;
100517: PPOPN 2
100519: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
100520: LD_EXP 75
100524: PUSH
100525: LD_EXP 103
100529: AND
100530: IFFALSE 100627
100532: GO 100534
100534: DISABLE
100535: LD_INT 0
100537: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
100538: LD_ADDR_VAR 0 1
100542: PUSH
100543: LD_INT 22
100545: PUSH
100546: LD_OWVAR 2
100550: PUSH
100551: EMPTY
100552: LIST
100553: LIST
100554: PUSH
100555: LD_INT 21
100557: PUSH
100558: LD_INT 1
100560: PUSH
100561: EMPTY
100562: LIST
100563: LIST
100564: PUSH
100565: LD_INT 3
100567: PUSH
100568: LD_INT 23
100570: PUSH
100571: LD_INT 0
100573: PUSH
100574: EMPTY
100575: LIST
100576: LIST
100577: PUSH
100578: EMPTY
100579: LIST
100580: LIST
100581: PUSH
100582: EMPTY
100583: LIST
100584: LIST
100585: LIST
100586: PPUSH
100587: CALL_OW 69
100591: ST_TO_ADDR
// if not tmp then
100592: LD_VAR 0 1
100596: NOT
100597: IFFALSE 100601
// exit ;
100599: GO 100627
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
100601: LD_VAR 0 1
100605: PUSH
100606: LD_INT 1
100608: PPUSH
100609: LD_VAR 0 1
100613: PPUSH
100614: CALL_OW 12
100618: ARRAY
100619: PPUSH
100620: LD_INT 200
100622: PPUSH
100623: CALL_OW 234
// end ;
100627: PPOPN 1
100629: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
100630: LD_EXP 75
100634: PUSH
100635: LD_EXP 104
100639: AND
100640: IFFALSE 100719
100642: GO 100644
100644: DISABLE
100645: LD_INT 0
100647: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
100648: LD_ADDR_VAR 0 1
100652: PUSH
100653: LD_INT 22
100655: PUSH
100656: LD_OWVAR 2
100660: PUSH
100661: EMPTY
100662: LIST
100663: LIST
100664: PUSH
100665: LD_INT 21
100667: PUSH
100668: LD_INT 2
100670: PUSH
100671: EMPTY
100672: LIST
100673: LIST
100674: PUSH
100675: EMPTY
100676: LIST
100677: LIST
100678: PPUSH
100679: CALL_OW 69
100683: ST_TO_ADDR
// if not tmp then
100684: LD_VAR 0 1
100688: NOT
100689: IFFALSE 100693
// exit ;
100691: GO 100719
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
100693: LD_VAR 0 1
100697: PUSH
100698: LD_INT 1
100700: PPUSH
100701: LD_VAR 0 1
100705: PPUSH
100706: CALL_OW 12
100710: ARRAY
100711: PPUSH
100712: LD_INT 60
100714: PPUSH
100715: CALL_OW 234
// end ;
100719: PPOPN 1
100721: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
100722: LD_EXP 75
100726: PUSH
100727: LD_EXP 105
100731: AND
100732: IFFALSE 100831
100734: GO 100736
100736: DISABLE
100737: LD_INT 0
100739: PPUSH
100740: PPUSH
// begin enable ;
100741: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
100742: LD_ADDR_VAR 0 1
100746: PUSH
100747: LD_INT 22
100749: PUSH
100750: LD_OWVAR 2
100754: PUSH
100755: EMPTY
100756: LIST
100757: LIST
100758: PUSH
100759: LD_INT 61
100761: PUSH
100762: EMPTY
100763: LIST
100764: PUSH
100765: LD_INT 33
100767: PUSH
100768: LD_INT 2
100770: PUSH
100771: EMPTY
100772: LIST
100773: LIST
100774: PUSH
100775: EMPTY
100776: LIST
100777: LIST
100778: LIST
100779: PPUSH
100780: CALL_OW 69
100784: ST_TO_ADDR
// if not tmp then
100785: LD_VAR 0 1
100789: NOT
100790: IFFALSE 100794
// exit ;
100792: GO 100831
// for i in tmp do
100794: LD_ADDR_VAR 0 2
100798: PUSH
100799: LD_VAR 0 1
100803: PUSH
100804: FOR_IN
100805: IFFALSE 100829
// if IsControledBy ( i ) then
100807: LD_VAR 0 2
100811: PPUSH
100812: CALL_OW 312
100816: IFFALSE 100827
// ComUnlink ( i ) ;
100818: LD_VAR 0 2
100822: PPUSH
100823: CALL_OW 136
100827: GO 100804
100829: POP
100830: POP
// end ;
100831: PPOPN 2
100833: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
100834: LD_EXP 75
100838: PUSH
100839: LD_EXP 106
100843: AND
100844: IFFALSE 100984
100846: GO 100848
100848: DISABLE
100849: LD_INT 0
100851: PPUSH
100852: PPUSH
// begin ToLua ( displayPowell(); ) ;
100853: LD_STRING displayPowell();
100855: PPUSH
100856: CALL_OW 559
// uc_side := 0 ;
100860: LD_ADDR_OWVAR 20
100864: PUSH
100865: LD_INT 0
100867: ST_TO_ADDR
// uc_nation := 2 ;
100868: LD_ADDR_OWVAR 21
100872: PUSH
100873: LD_INT 2
100875: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
100876: LD_ADDR_OWVAR 37
100880: PUSH
100881: LD_INT 14
100883: ST_TO_ADDR
// vc_engine := engine_siberite ;
100884: LD_ADDR_OWVAR 39
100888: PUSH
100889: LD_INT 3
100891: ST_TO_ADDR
// vc_control := control_apeman ;
100892: LD_ADDR_OWVAR 38
100896: PUSH
100897: LD_INT 5
100899: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
100900: LD_ADDR_OWVAR 40
100904: PUSH
100905: LD_INT 29
100907: ST_TO_ADDR
// un := CreateVehicle ;
100908: LD_ADDR_VAR 0 2
100912: PUSH
100913: CALL_OW 45
100917: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
100918: LD_VAR 0 2
100922: PPUSH
100923: LD_INT 1
100925: PPUSH
100926: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
100930: LD_INT 35
100932: PPUSH
100933: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
100937: LD_VAR 0 2
100941: PPUSH
100942: LD_INT 22
100944: PUSH
100945: LD_OWVAR 2
100949: PUSH
100950: EMPTY
100951: LIST
100952: LIST
100953: PPUSH
100954: CALL_OW 69
100958: PPUSH
100959: LD_VAR 0 2
100963: PPUSH
100964: CALL_OW 74
100968: PPUSH
100969: CALL_OW 115
// until IsDead ( un ) ;
100973: LD_VAR 0 2
100977: PPUSH
100978: CALL_OW 301
100982: IFFALSE 100930
// end ;
100984: PPOPN 2
100986: END
// every 0 0$1 trigger StreamModeActive and sStu do
100987: LD_EXP 75
100991: PUSH
100992: LD_EXP 114
100996: AND
100997: IFFALSE 101013
100999: GO 101001
101001: DISABLE
// begin ToLua ( displayStucuk(); ) ;
101002: LD_STRING displayStucuk();
101004: PPUSH
101005: CALL_OW 559
// ResetFog ;
101009: CALL_OW 335
// end ;
101013: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
101014: LD_EXP 75
101018: PUSH
101019: LD_EXP 107
101023: AND
101024: IFFALSE 101165
101026: GO 101028
101028: DISABLE
101029: LD_INT 0
101031: PPUSH
101032: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
101033: LD_ADDR_VAR 0 2
101037: PUSH
101038: LD_INT 22
101040: PUSH
101041: LD_OWVAR 2
101045: PUSH
101046: EMPTY
101047: LIST
101048: LIST
101049: PUSH
101050: LD_INT 21
101052: PUSH
101053: LD_INT 1
101055: PUSH
101056: EMPTY
101057: LIST
101058: LIST
101059: PUSH
101060: EMPTY
101061: LIST
101062: LIST
101063: PPUSH
101064: CALL_OW 69
101068: ST_TO_ADDR
// if not tmp then
101069: LD_VAR 0 2
101073: NOT
101074: IFFALSE 101078
// exit ;
101076: GO 101165
// un := tmp [ rand ( 1 , tmp ) ] ;
101078: LD_ADDR_VAR 0 1
101082: PUSH
101083: LD_VAR 0 2
101087: PUSH
101088: LD_INT 1
101090: PPUSH
101091: LD_VAR 0 2
101095: PPUSH
101096: CALL_OW 12
101100: ARRAY
101101: ST_TO_ADDR
// SetSide ( un , 0 ) ;
101102: LD_VAR 0 1
101106: PPUSH
101107: LD_INT 0
101109: PPUSH
101110: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
101114: LD_VAR 0 1
101118: PPUSH
101119: LD_OWVAR 3
101123: PUSH
101124: LD_VAR 0 1
101128: DIFF
101129: PPUSH
101130: LD_VAR 0 1
101134: PPUSH
101135: CALL_OW 74
101139: PPUSH
101140: CALL_OW 115
// wait ( 0 0$20 ) ;
101144: LD_INT 700
101146: PPUSH
101147: CALL_OW 67
// SetSide ( un , your_side ) ;
101151: LD_VAR 0 1
101155: PPUSH
101156: LD_OWVAR 2
101160: PPUSH
101161: CALL_OW 235
// end ;
101165: PPOPN 2
101167: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
101168: LD_EXP 75
101172: PUSH
101173: LD_EXP 108
101177: AND
101178: IFFALSE 101284
101180: GO 101182
101182: DISABLE
101183: LD_INT 0
101185: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
101186: LD_ADDR_VAR 0 1
101190: PUSH
101191: LD_INT 22
101193: PUSH
101194: LD_OWVAR 2
101198: PUSH
101199: EMPTY
101200: LIST
101201: LIST
101202: PUSH
101203: LD_INT 2
101205: PUSH
101206: LD_INT 30
101208: PUSH
101209: LD_INT 0
101211: PUSH
101212: EMPTY
101213: LIST
101214: LIST
101215: PUSH
101216: LD_INT 30
101218: PUSH
101219: LD_INT 1
101221: PUSH
101222: EMPTY
101223: LIST
101224: LIST
101225: PUSH
101226: EMPTY
101227: LIST
101228: LIST
101229: LIST
101230: PUSH
101231: EMPTY
101232: LIST
101233: LIST
101234: PPUSH
101235: CALL_OW 69
101239: ST_TO_ADDR
// if not depot then
101240: LD_VAR 0 1
101244: NOT
101245: IFFALSE 101249
// exit ;
101247: GO 101284
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
101249: LD_VAR 0 1
101253: PUSH
101254: LD_INT 1
101256: ARRAY
101257: PPUSH
101258: CALL_OW 250
101262: PPUSH
101263: LD_VAR 0 1
101267: PUSH
101268: LD_INT 1
101270: ARRAY
101271: PPUSH
101272: CALL_OW 251
101276: PPUSH
101277: LD_INT 70
101279: PPUSH
101280: CALL_OW 495
// end ;
101284: PPOPN 1
101286: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
101287: LD_EXP 75
101291: PUSH
101292: LD_EXP 109
101296: AND
101297: IFFALSE 101508
101299: GO 101301
101301: DISABLE
101302: LD_INT 0
101304: PPUSH
101305: PPUSH
101306: PPUSH
101307: PPUSH
101308: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
101309: LD_ADDR_VAR 0 5
101313: PUSH
101314: LD_INT 22
101316: PUSH
101317: LD_OWVAR 2
101321: PUSH
101322: EMPTY
101323: LIST
101324: LIST
101325: PUSH
101326: LD_INT 21
101328: PUSH
101329: LD_INT 1
101331: PUSH
101332: EMPTY
101333: LIST
101334: LIST
101335: PUSH
101336: EMPTY
101337: LIST
101338: LIST
101339: PPUSH
101340: CALL_OW 69
101344: ST_TO_ADDR
// if not tmp then
101345: LD_VAR 0 5
101349: NOT
101350: IFFALSE 101354
// exit ;
101352: GO 101508
// for i in tmp do
101354: LD_ADDR_VAR 0 1
101358: PUSH
101359: LD_VAR 0 5
101363: PUSH
101364: FOR_IN
101365: IFFALSE 101506
// begin d := rand ( 0 , 5 ) ;
101367: LD_ADDR_VAR 0 4
101371: PUSH
101372: LD_INT 0
101374: PPUSH
101375: LD_INT 5
101377: PPUSH
101378: CALL_OW 12
101382: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
101383: LD_ADDR_VAR 0 2
101387: PUSH
101388: LD_VAR 0 1
101392: PPUSH
101393: CALL_OW 250
101397: PPUSH
101398: LD_VAR 0 4
101402: PPUSH
101403: LD_INT 3
101405: PPUSH
101406: LD_INT 12
101408: PPUSH
101409: CALL_OW 12
101413: PPUSH
101414: CALL_OW 272
101418: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
101419: LD_ADDR_VAR 0 3
101423: PUSH
101424: LD_VAR 0 1
101428: PPUSH
101429: CALL_OW 251
101433: PPUSH
101434: LD_VAR 0 4
101438: PPUSH
101439: LD_INT 3
101441: PPUSH
101442: LD_INT 12
101444: PPUSH
101445: CALL_OW 12
101449: PPUSH
101450: CALL_OW 273
101454: ST_TO_ADDR
// if ValidHex ( x , y ) then
101455: LD_VAR 0 2
101459: PPUSH
101460: LD_VAR 0 3
101464: PPUSH
101465: CALL_OW 488
101469: IFFALSE 101504
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
101471: LD_VAR 0 1
101475: PPUSH
101476: LD_VAR 0 2
101480: PPUSH
101481: LD_VAR 0 3
101485: PPUSH
101486: LD_INT 3
101488: PPUSH
101489: LD_INT 6
101491: PPUSH
101492: CALL_OW 12
101496: PPUSH
101497: LD_INT 1
101499: PPUSH
101500: CALL_OW 483
// end ;
101504: GO 101364
101506: POP
101507: POP
// end ;
101508: PPOPN 5
101510: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
101511: LD_EXP 75
101515: PUSH
101516: LD_EXP 110
101520: AND
101521: IFFALSE 101615
101523: GO 101525
101525: DISABLE
101526: LD_INT 0
101528: PPUSH
101529: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
101530: LD_ADDR_VAR 0 2
101534: PUSH
101535: LD_INT 22
101537: PUSH
101538: LD_OWVAR 2
101542: PUSH
101543: EMPTY
101544: LIST
101545: LIST
101546: PUSH
101547: LD_INT 32
101549: PUSH
101550: LD_INT 1
101552: PUSH
101553: EMPTY
101554: LIST
101555: LIST
101556: PUSH
101557: LD_INT 21
101559: PUSH
101560: LD_INT 2
101562: PUSH
101563: EMPTY
101564: LIST
101565: LIST
101566: PUSH
101567: EMPTY
101568: LIST
101569: LIST
101570: LIST
101571: PPUSH
101572: CALL_OW 69
101576: ST_TO_ADDR
// if not tmp then
101577: LD_VAR 0 2
101581: NOT
101582: IFFALSE 101586
// exit ;
101584: GO 101615
// for i in tmp do
101586: LD_ADDR_VAR 0 1
101590: PUSH
101591: LD_VAR 0 2
101595: PUSH
101596: FOR_IN
101597: IFFALSE 101613
// SetFuel ( i , 0 ) ;
101599: LD_VAR 0 1
101603: PPUSH
101604: LD_INT 0
101606: PPUSH
101607: CALL_OW 240
101611: GO 101596
101613: POP
101614: POP
// end ;
101615: PPOPN 2
101617: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
101618: LD_EXP 75
101622: PUSH
101623: LD_EXP 111
101627: AND
101628: IFFALSE 101694
101630: GO 101632
101632: DISABLE
101633: LD_INT 0
101635: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
101636: LD_ADDR_VAR 0 1
101640: PUSH
101641: LD_INT 22
101643: PUSH
101644: LD_OWVAR 2
101648: PUSH
101649: EMPTY
101650: LIST
101651: LIST
101652: PUSH
101653: LD_INT 30
101655: PUSH
101656: LD_INT 29
101658: PUSH
101659: EMPTY
101660: LIST
101661: LIST
101662: PUSH
101663: EMPTY
101664: LIST
101665: LIST
101666: PPUSH
101667: CALL_OW 69
101671: ST_TO_ADDR
// if not tmp then
101672: LD_VAR 0 1
101676: NOT
101677: IFFALSE 101681
// exit ;
101679: GO 101694
// DestroyUnit ( tmp [ 1 ] ) ;
101681: LD_VAR 0 1
101685: PUSH
101686: LD_INT 1
101688: ARRAY
101689: PPUSH
101690: CALL_OW 65
// end ;
101694: PPOPN 1
101696: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
101697: LD_EXP 75
101701: PUSH
101702: LD_EXP 113
101706: AND
101707: IFFALSE 101836
101709: GO 101711
101711: DISABLE
101712: LD_INT 0
101714: PPUSH
// begin uc_side := 0 ;
101715: LD_ADDR_OWVAR 20
101719: PUSH
101720: LD_INT 0
101722: ST_TO_ADDR
// uc_nation := nation_arabian ;
101723: LD_ADDR_OWVAR 21
101727: PUSH
101728: LD_INT 2
101730: ST_TO_ADDR
// hc_gallery :=  ;
101731: LD_ADDR_OWVAR 33
101735: PUSH
101736: LD_STRING 
101738: ST_TO_ADDR
// hc_name :=  ;
101739: LD_ADDR_OWVAR 26
101743: PUSH
101744: LD_STRING 
101746: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
101747: LD_INT 1
101749: PPUSH
101750: LD_INT 11
101752: PPUSH
101753: LD_INT 10
101755: PPUSH
101756: CALL_OW 380
// un := CreateHuman ;
101760: LD_ADDR_VAR 0 1
101764: PUSH
101765: CALL_OW 44
101769: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
101770: LD_VAR 0 1
101774: PPUSH
101775: LD_INT 1
101777: PPUSH
101778: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
101782: LD_INT 35
101784: PPUSH
101785: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
101789: LD_VAR 0 1
101793: PPUSH
101794: LD_INT 22
101796: PUSH
101797: LD_OWVAR 2
101801: PUSH
101802: EMPTY
101803: LIST
101804: LIST
101805: PPUSH
101806: CALL_OW 69
101810: PPUSH
101811: LD_VAR 0 1
101815: PPUSH
101816: CALL_OW 74
101820: PPUSH
101821: CALL_OW 115
// until IsDead ( un ) ;
101825: LD_VAR 0 1
101829: PPUSH
101830: CALL_OW 301
101834: IFFALSE 101782
// end ;
101836: PPOPN 1
101838: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
101839: LD_EXP 75
101843: PUSH
101844: LD_EXP 115
101848: AND
101849: IFFALSE 101861
101851: GO 101853
101853: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
101854: LD_STRING earthquake(getX(game), 0, 32)
101856: PPUSH
101857: CALL_OW 559
101861: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
101862: LD_EXP 75
101866: PUSH
101867: LD_EXP 116
101871: AND
101872: IFFALSE 101963
101874: GO 101876
101876: DISABLE
101877: LD_INT 0
101879: PPUSH
// begin enable ;
101880: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
101881: LD_ADDR_VAR 0 1
101885: PUSH
101886: LD_INT 22
101888: PUSH
101889: LD_OWVAR 2
101893: PUSH
101894: EMPTY
101895: LIST
101896: LIST
101897: PUSH
101898: LD_INT 21
101900: PUSH
101901: LD_INT 2
101903: PUSH
101904: EMPTY
101905: LIST
101906: LIST
101907: PUSH
101908: LD_INT 33
101910: PUSH
101911: LD_INT 3
101913: PUSH
101914: EMPTY
101915: LIST
101916: LIST
101917: PUSH
101918: EMPTY
101919: LIST
101920: LIST
101921: LIST
101922: PPUSH
101923: CALL_OW 69
101927: ST_TO_ADDR
// if not tmp then
101928: LD_VAR 0 1
101932: NOT
101933: IFFALSE 101937
// exit ;
101935: GO 101963
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
101937: LD_VAR 0 1
101941: PUSH
101942: LD_INT 1
101944: PPUSH
101945: LD_VAR 0 1
101949: PPUSH
101950: CALL_OW 12
101954: ARRAY
101955: PPUSH
101956: LD_INT 1
101958: PPUSH
101959: CALL_OW 234
// end ;
101963: PPOPN 1
101965: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
101966: LD_EXP 75
101970: PUSH
101971: LD_EXP 117
101975: AND
101976: IFFALSE 102117
101978: GO 101980
101980: DISABLE
101981: LD_INT 0
101983: PPUSH
101984: PPUSH
101985: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
101986: LD_ADDR_VAR 0 3
101990: PUSH
101991: LD_INT 22
101993: PUSH
101994: LD_OWVAR 2
101998: PUSH
101999: EMPTY
102000: LIST
102001: LIST
102002: PUSH
102003: LD_INT 25
102005: PUSH
102006: LD_INT 1
102008: PUSH
102009: EMPTY
102010: LIST
102011: LIST
102012: PUSH
102013: EMPTY
102014: LIST
102015: LIST
102016: PPUSH
102017: CALL_OW 69
102021: ST_TO_ADDR
// if not tmp then
102022: LD_VAR 0 3
102026: NOT
102027: IFFALSE 102031
// exit ;
102029: GO 102117
// un := tmp [ rand ( 1 , tmp ) ] ;
102031: LD_ADDR_VAR 0 2
102035: PUSH
102036: LD_VAR 0 3
102040: PUSH
102041: LD_INT 1
102043: PPUSH
102044: LD_VAR 0 3
102048: PPUSH
102049: CALL_OW 12
102053: ARRAY
102054: ST_TO_ADDR
// if Crawls ( un ) then
102055: LD_VAR 0 2
102059: PPUSH
102060: CALL_OW 318
102064: IFFALSE 102075
// ComWalk ( un ) ;
102066: LD_VAR 0 2
102070: PPUSH
102071: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
102075: LD_VAR 0 2
102079: PPUSH
102080: LD_INT 9
102082: PPUSH
102083: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
102087: LD_INT 28
102089: PPUSH
102090: LD_OWVAR 2
102094: PPUSH
102095: LD_INT 2
102097: PPUSH
102098: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
102102: LD_INT 29
102104: PPUSH
102105: LD_OWVAR 2
102109: PPUSH
102110: LD_INT 2
102112: PPUSH
102113: CALL_OW 322
// end ;
102117: PPOPN 3
102119: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
102120: LD_EXP 75
102124: PUSH
102125: LD_EXP 118
102129: AND
102130: IFFALSE 102241
102132: GO 102134
102134: DISABLE
102135: LD_INT 0
102137: PPUSH
102138: PPUSH
102139: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
102140: LD_ADDR_VAR 0 3
102144: PUSH
102145: LD_INT 22
102147: PUSH
102148: LD_OWVAR 2
102152: PUSH
102153: EMPTY
102154: LIST
102155: LIST
102156: PUSH
102157: LD_INT 25
102159: PUSH
102160: LD_INT 1
102162: PUSH
102163: EMPTY
102164: LIST
102165: LIST
102166: PUSH
102167: EMPTY
102168: LIST
102169: LIST
102170: PPUSH
102171: CALL_OW 69
102175: ST_TO_ADDR
// if not tmp then
102176: LD_VAR 0 3
102180: NOT
102181: IFFALSE 102185
// exit ;
102183: GO 102241
// un := tmp [ rand ( 1 , tmp ) ] ;
102185: LD_ADDR_VAR 0 2
102189: PUSH
102190: LD_VAR 0 3
102194: PUSH
102195: LD_INT 1
102197: PPUSH
102198: LD_VAR 0 3
102202: PPUSH
102203: CALL_OW 12
102207: ARRAY
102208: ST_TO_ADDR
// if Crawls ( un ) then
102209: LD_VAR 0 2
102213: PPUSH
102214: CALL_OW 318
102218: IFFALSE 102229
// ComWalk ( un ) ;
102220: LD_VAR 0 2
102224: PPUSH
102225: CALL_OW 138
// SetClass ( un , class_mortar ) ;
102229: LD_VAR 0 2
102233: PPUSH
102234: LD_INT 8
102236: PPUSH
102237: CALL_OW 336
// end ;
102241: PPOPN 3
102243: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
102244: LD_EXP 75
102248: PUSH
102249: LD_EXP 119
102253: AND
102254: IFFALSE 102398
102256: GO 102258
102258: DISABLE
102259: LD_INT 0
102261: PPUSH
102262: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
102263: LD_ADDR_VAR 0 2
102267: PUSH
102268: LD_INT 22
102270: PUSH
102271: LD_OWVAR 2
102275: PUSH
102276: EMPTY
102277: LIST
102278: LIST
102279: PUSH
102280: LD_INT 21
102282: PUSH
102283: LD_INT 2
102285: PUSH
102286: EMPTY
102287: LIST
102288: LIST
102289: PUSH
102290: LD_INT 2
102292: PUSH
102293: LD_INT 34
102295: PUSH
102296: LD_INT 12
102298: PUSH
102299: EMPTY
102300: LIST
102301: LIST
102302: PUSH
102303: LD_INT 34
102305: PUSH
102306: LD_INT 51
102308: PUSH
102309: EMPTY
102310: LIST
102311: LIST
102312: PUSH
102313: LD_INT 34
102315: PUSH
102316: LD_INT 32
102318: PUSH
102319: EMPTY
102320: LIST
102321: LIST
102322: PUSH
102323: EMPTY
102324: LIST
102325: LIST
102326: LIST
102327: LIST
102328: PUSH
102329: EMPTY
102330: LIST
102331: LIST
102332: LIST
102333: PPUSH
102334: CALL_OW 69
102338: ST_TO_ADDR
// if not tmp then
102339: LD_VAR 0 2
102343: NOT
102344: IFFALSE 102348
// exit ;
102346: GO 102398
// for i in tmp do
102348: LD_ADDR_VAR 0 1
102352: PUSH
102353: LD_VAR 0 2
102357: PUSH
102358: FOR_IN
102359: IFFALSE 102396
// if GetCargo ( i , mat_artifact ) = 0 then
102361: LD_VAR 0 1
102365: PPUSH
102366: LD_INT 4
102368: PPUSH
102369: CALL_OW 289
102373: PUSH
102374: LD_INT 0
102376: EQUAL
102377: IFFALSE 102394
// SetCargo ( i , mat_siberit , 100 ) ;
102379: LD_VAR 0 1
102383: PPUSH
102384: LD_INT 3
102386: PPUSH
102387: LD_INT 100
102389: PPUSH
102390: CALL_OW 290
102394: GO 102358
102396: POP
102397: POP
// end ;
102398: PPOPN 2
102400: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
102401: LD_EXP 75
102405: PUSH
102406: LD_EXP 120
102410: AND
102411: IFFALSE 102594
102413: GO 102415
102415: DISABLE
102416: LD_INT 0
102418: PPUSH
102419: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
102420: LD_ADDR_VAR 0 2
102424: PUSH
102425: LD_INT 22
102427: PUSH
102428: LD_OWVAR 2
102432: PUSH
102433: EMPTY
102434: LIST
102435: LIST
102436: PPUSH
102437: CALL_OW 69
102441: ST_TO_ADDR
// if not tmp then
102442: LD_VAR 0 2
102446: NOT
102447: IFFALSE 102451
// exit ;
102449: GO 102594
// for i := 1 to 2 do
102451: LD_ADDR_VAR 0 1
102455: PUSH
102456: DOUBLE
102457: LD_INT 1
102459: DEC
102460: ST_TO_ADDR
102461: LD_INT 2
102463: PUSH
102464: FOR_TO
102465: IFFALSE 102592
// begin uc_side := your_side ;
102467: LD_ADDR_OWVAR 20
102471: PUSH
102472: LD_OWVAR 2
102476: ST_TO_ADDR
// uc_nation := nation_american ;
102477: LD_ADDR_OWVAR 21
102481: PUSH
102482: LD_INT 1
102484: ST_TO_ADDR
// vc_chassis := us_morphling ;
102485: LD_ADDR_OWVAR 37
102489: PUSH
102490: LD_INT 5
102492: ST_TO_ADDR
// vc_engine := engine_siberite ;
102493: LD_ADDR_OWVAR 39
102497: PUSH
102498: LD_INT 3
102500: ST_TO_ADDR
// vc_control := control_computer ;
102501: LD_ADDR_OWVAR 38
102505: PUSH
102506: LD_INT 3
102508: ST_TO_ADDR
// vc_weapon := us_double_laser ;
102509: LD_ADDR_OWVAR 40
102513: PUSH
102514: LD_INT 10
102516: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
102517: LD_VAR 0 2
102521: PUSH
102522: LD_INT 1
102524: ARRAY
102525: PPUSH
102526: CALL_OW 310
102530: NOT
102531: IFFALSE 102578
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
102533: CALL_OW 45
102537: PPUSH
102538: LD_VAR 0 2
102542: PUSH
102543: LD_INT 1
102545: ARRAY
102546: PPUSH
102547: CALL_OW 250
102551: PPUSH
102552: LD_VAR 0 2
102556: PUSH
102557: LD_INT 1
102559: ARRAY
102560: PPUSH
102561: CALL_OW 251
102565: PPUSH
102566: LD_INT 12
102568: PPUSH
102569: LD_INT 1
102571: PPUSH
102572: CALL_OW 50
102576: GO 102590
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
102578: CALL_OW 45
102582: PPUSH
102583: LD_INT 1
102585: PPUSH
102586: CALL_OW 51
// end ;
102590: GO 102464
102592: POP
102593: POP
// end ;
102594: PPOPN 2
102596: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
102597: LD_EXP 75
102601: PUSH
102602: LD_EXP 121
102606: AND
102607: IFFALSE 102829
102609: GO 102611
102611: DISABLE
102612: LD_INT 0
102614: PPUSH
102615: PPUSH
102616: PPUSH
102617: PPUSH
102618: PPUSH
102619: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
102620: LD_ADDR_VAR 0 6
102624: PUSH
102625: LD_INT 22
102627: PUSH
102628: LD_OWVAR 2
102632: PUSH
102633: EMPTY
102634: LIST
102635: LIST
102636: PUSH
102637: LD_INT 21
102639: PUSH
102640: LD_INT 1
102642: PUSH
102643: EMPTY
102644: LIST
102645: LIST
102646: PUSH
102647: LD_INT 3
102649: PUSH
102650: LD_INT 23
102652: PUSH
102653: LD_INT 0
102655: PUSH
102656: EMPTY
102657: LIST
102658: LIST
102659: PUSH
102660: EMPTY
102661: LIST
102662: LIST
102663: PUSH
102664: EMPTY
102665: LIST
102666: LIST
102667: LIST
102668: PPUSH
102669: CALL_OW 69
102673: ST_TO_ADDR
// if not tmp then
102674: LD_VAR 0 6
102678: NOT
102679: IFFALSE 102683
// exit ;
102681: GO 102829
// s1 := rand ( 1 , 4 ) ;
102683: LD_ADDR_VAR 0 2
102687: PUSH
102688: LD_INT 1
102690: PPUSH
102691: LD_INT 4
102693: PPUSH
102694: CALL_OW 12
102698: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
102699: LD_ADDR_VAR 0 4
102703: PUSH
102704: LD_VAR 0 6
102708: PUSH
102709: LD_INT 1
102711: ARRAY
102712: PPUSH
102713: LD_VAR 0 2
102717: PPUSH
102718: CALL_OW 259
102722: ST_TO_ADDR
// if s1 = 1 then
102723: LD_VAR 0 2
102727: PUSH
102728: LD_INT 1
102730: EQUAL
102731: IFFALSE 102751
// s2 := rand ( 2 , 4 ) else
102733: LD_ADDR_VAR 0 3
102737: PUSH
102738: LD_INT 2
102740: PPUSH
102741: LD_INT 4
102743: PPUSH
102744: CALL_OW 12
102748: ST_TO_ADDR
102749: GO 102759
// s2 := 1 ;
102751: LD_ADDR_VAR 0 3
102755: PUSH
102756: LD_INT 1
102758: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
102759: LD_ADDR_VAR 0 5
102763: PUSH
102764: LD_VAR 0 6
102768: PUSH
102769: LD_INT 1
102771: ARRAY
102772: PPUSH
102773: LD_VAR 0 3
102777: PPUSH
102778: CALL_OW 259
102782: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
102783: LD_VAR 0 6
102787: PUSH
102788: LD_INT 1
102790: ARRAY
102791: PPUSH
102792: LD_VAR 0 2
102796: PPUSH
102797: LD_VAR 0 5
102801: PPUSH
102802: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
102806: LD_VAR 0 6
102810: PUSH
102811: LD_INT 1
102813: ARRAY
102814: PPUSH
102815: LD_VAR 0 3
102819: PPUSH
102820: LD_VAR 0 4
102824: PPUSH
102825: CALL_OW 237
// end ;
102829: PPOPN 6
102831: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
102832: LD_EXP 75
102836: PUSH
102837: LD_EXP 122
102841: AND
102842: IFFALSE 102921
102844: GO 102846
102846: DISABLE
102847: LD_INT 0
102849: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
102850: LD_ADDR_VAR 0 1
102854: PUSH
102855: LD_INT 22
102857: PUSH
102858: LD_OWVAR 2
102862: PUSH
102863: EMPTY
102864: LIST
102865: LIST
102866: PUSH
102867: LD_INT 30
102869: PUSH
102870: LD_INT 3
102872: PUSH
102873: EMPTY
102874: LIST
102875: LIST
102876: PUSH
102877: EMPTY
102878: LIST
102879: LIST
102880: PPUSH
102881: CALL_OW 69
102885: ST_TO_ADDR
// if not tmp then
102886: LD_VAR 0 1
102890: NOT
102891: IFFALSE 102895
// exit ;
102893: GO 102921
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
102895: LD_VAR 0 1
102899: PUSH
102900: LD_INT 1
102902: PPUSH
102903: LD_VAR 0 1
102907: PPUSH
102908: CALL_OW 12
102912: ARRAY
102913: PPUSH
102914: LD_INT 1
102916: PPUSH
102917: CALL_OW 234
// end ;
102921: PPOPN 1
102923: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
102924: LD_EXP 75
102928: PUSH
102929: LD_EXP 123
102933: AND
102934: IFFALSE 103046
102936: GO 102938
102938: DISABLE
102939: LD_INT 0
102941: PPUSH
102942: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
102943: LD_ADDR_VAR 0 2
102947: PUSH
102948: LD_INT 22
102950: PUSH
102951: LD_OWVAR 2
102955: PUSH
102956: EMPTY
102957: LIST
102958: LIST
102959: PUSH
102960: LD_INT 2
102962: PUSH
102963: LD_INT 30
102965: PUSH
102966: LD_INT 27
102968: PUSH
102969: EMPTY
102970: LIST
102971: LIST
102972: PUSH
102973: LD_INT 30
102975: PUSH
102976: LD_INT 26
102978: PUSH
102979: EMPTY
102980: LIST
102981: LIST
102982: PUSH
102983: LD_INT 30
102985: PUSH
102986: LD_INT 28
102988: PUSH
102989: EMPTY
102990: LIST
102991: LIST
102992: PUSH
102993: EMPTY
102994: LIST
102995: LIST
102996: LIST
102997: LIST
102998: PUSH
102999: EMPTY
103000: LIST
103001: LIST
103002: PPUSH
103003: CALL_OW 69
103007: ST_TO_ADDR
// if not tmp then
103008: LD_VAR 0 2
103012: NOT
103013: IFFALSE 103017
// exit ;
103015: GO 103046
// for i in tmp do
103017: LD_ADDR_VAR 0 1
103021: PUSH
103022: LD_VAR 0 2
103026: PUSH
103027: FOR_IN
103028: IFFALSE 103044
// SetLives ( i , 1 ) ;
103030: LD_VAR 0 1
103034: PPUSH
103035: LD_INT 1
103037: PPUSH
103038: CALL_OW 234
103042: GO 103027
103044: POP
103045: POP
// end ;
103046: PPOPN 2
103048: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
103049: LD_EXP 75
103053: PUSH
103054: LD_EXP 124
103058: AND
103059: IFFALSE 103346
103061: GO 103063
103063: DISABLE
103064: LD_INT 0
103066: PPUSH
103067: PPUSH
103068: PPUSH
// begin i := rand ( 1 , 7 ) ;
103069: LD_ADDR_VAR 0 1
103073: PUSH
103074: LD_INT 1
103076: PPUSH
103077: LD_INT 7
103079: PPUSH
103080: CALL_OW 12
103084: ST_TO_ADDR
// case i of 1 :
103085: LD_VAR 0 1
103089: PUSH
103090: LD_INT 1
103092: DOUBLE
103093: EQUAL
103094: IFTRUE 103098
103096: GO 103108
103098: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
103099: LD_STRING earthquake(getX(game), 0, 32)
103101: PPUSH
103102: CALL_OW 559
103106: GO 103346
103108: LD_INT 2
103110: DOUBLE
103111: EQUAL
103112: IFTRUE 103116
103114: GO 103130
103116: POP
// begin ToLua ( displayStucuk(); ) ;
103117: LD_STRING displayStucuk();
103119: PPUSH
103120: CALL_OW 559
// ResetFog ;
103124: CALL_OW 335
// end ; 3 :
103128: GO 103346
103130: LD_INT 3
103132: DOUBLE
103133: EQUAL
103134: IFTRUE 103138
103136: GO 103242
103138: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
103139: LD_ADDR_VAR 0 2
103143: PUSH
103144: LD_INT 22
103146: PUSH
103147: LD_OWVAR 2
103151: PUSH
103152: EMPTY
103153: LIST
103154: LIST
103155: PUSH
103156: LD_INT 25
103158: PUSH
103159: LD_INT 1
103161: PUSH
103162: EMPTY
103163: LIST
103164: LIST
103165: PUSH
103166: EMPTY
103167: LIST
103168: LIST
103169: PPUSH
103170: CALL_OW 69
103174: ST_TO_ADDR
// if not tmp then
103175: LD_VAR 0 2
103179: NOT
103180: IFFALSE 103184
// exit ;
103182: GO 103346
// un := tmp [ rand ( 1 , tmp ) ] ;
103184: LD_ADDR_VAR 0 3
103188: PUSH
103189: LD_VAR 0 2
103193: PUSH
103194: LD_INT 1
103196: PPUSH
103197: LD_VAR 0 2
103201: PPUSH
103202: CALL_OW 12
103206: ARRAY
103207: ST_TO_ADDR
// if Crawls ( un ) then
103208: LD_VAR 0 3
103212: PPUSH
103213: CALL_OW 318
103217: IFFALSE 103228
// ComWalk ( un ) ;
103219: LD_VAR 0 3
103223: PPUSH
103224: CALL_OW 138
// SetClass ( un , class_mortar ) ;
103228: LD_VAR 0 3
103232: PPUSH
103233: LD_INT 8
103235: PPUSH
103236: CALL_OW 336
// end ; 4 :
103240: GO 103346
103242: LD_INT 4
103244: DOUBLE
103245: EQUAL
103246: IFTRUE 103250
103248: GO 103324
103250: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
103251: LD_ADDR_VAR 0 2
103255: PUSH
103256: LD_INT 22
103258: PUSH
103259: LD_OWVAR 2
103263: PUSH
103264: EMPTY
103265: LIST
103266: LIST
103267: PUSH
103268: LD_INT 30
103270: PUSH
103271: LD_INT 29
103273: PUSH
103274: EMPTY
103275: LIST
103276: LIST
103277: PUSH
103278: EMPTY
103279: LIST
103280: LIST
103281: PPUSH
103282: CALL_OW 69
103286: ST_TO_ADDR
// if not tmp then
103287: LD_VAR 0 2
103291: NOT
103292: IFFALSE 103296
// exit ;
103294: GO 103346
// CenterNowOnUnits ( tmp [ 1 ] ) ;
103296: LD_VAR 0 2
103300: PUSH
103301: LD_INT 1
103303: ARRAY
103304: PPUSH
103305: CALL_OW 87
// DestroyUnit ( tmp [ 1 ] ) ;
103309: LD_VAR 0 2
103313: PUSH
103314: LD_INT 1
103316: ARRAY
103317: PPUSH
103318: CALL_OW 65
// end ; 5 .. 7 :
103322: GO 103346
103324: LD_INT 5
103326: DOUBLE
103327: GREATEREQUAL
103328: IFFALSE 103336
103330: LD_INT 7
103332: DOUBLE
103333: LESSEQUAL
103334: IFTRUE 103338
103336: GO 103345
103338: POP
// StreamSibBomb ; end ;
103339: CALL 99583 0 0
103343: GO 103346
103345: POP
// end ;
103346: PPOPN 3
103348: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
103349: LD_EXP 75
103353: PUSH
103354: LD_EXP 125
103358: AND
103359: IFFALSE 103515
103361: GO 103363
103363: DISABLE
103364: LD_INT 0
103366: PPUSH
103367: PPUSH
103368: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
103369: LD_ADDR_VAR 0 2
103373: PUSH
103374: LD_INT 81
103376: PUSH
103377: LD_OWVAR 2
103381: PUSH
103382: EMPTY
103383: LIST
103384: LIST
103385: PUSH
103386: LD_INT 2
103388: PUSH
103389: LD_INT 21
103391: PUSH
103392: LD_INT 1
103394: PUSH
103395: EMPTY
103396: LIST
103397: LIST
103398: PUSH
103399: LD_INT 21
103401: PUSH
103402: LD_INT 2
103404: PUSH
103405: EMPTY
103406: LIST
103407: LIST
103408: PUSH
103409: EMPTY
103410: LIST
103411: LIST
103412: LIST
103413: PUSH
103414: EMPTY
103415: LIST
103416: LIST
103417: PPUSH
103418: CALL_OW 69
103422: ST_TO_ADDR
// if not tmp then
103423: LD_VAR 0 2
103427: NOT
103428: IFFALSE 103432
// exit ;
103430: GO 103515
// p := 0 ;
103432: LD_ADDR_VAR 0 3
103436: PUSH
103437: LD_INT 0
103439: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
103440: LD_INT 35
103442: PPUSH
103443: CALL_OW 67
// p := p + 1 ;
103447: LD_ADDR_VAR 0 3
103451: PUSH
103452: LD_VAR 0 3
103456: PUSH
103457: LD_INT 1
103459: PLUS
103460: ST_TO_ADDR
// for i in tmp do
103461: LD_ADDR_VAR 0 1
103465: PUSH
103466: LD_VAR 0 2
103470: PUSH
103471: FOR_IN
103472: IFFALSE 103503
// if GetLives ( i ) < 1000 then
103474: LD_VAR 0 1
103478: PPUSH
103479: CALL_OW 256
103483: PUSH
103484: LD_INT 1000
103486: LESS
103487: IFFALSE 103501
// SetLives ( i , 1000 ) ;
103489: LD_VAR 0 1
103493: PPUSH
103494: LD_INT 1000
103496: PPUSH
103497: CALL_OW 234
103501: GO 103471
103503: POP
103504: POP
// until p > 20 ;
103505: LD_VAR 0 3
103509: PUSH
103510: LD_INT 20
103512: GREATER
103513: IFFALSE 103440
// end ;
103515: PPOPN 3
103517: END
// every 0 0$1 trigger StreamModeActive and sTime do
103518: LD_EXP 75
103522: PUSH
103523: LD_EXP 126
103527: AND
103528: IFFALSE 103563
103530: GO 103532
103532: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
103533: LD_INT 28
103535: PPUSH
103536: LD_OWVAR 2
103540: PPUSH
103541: LD_INT 2
103543: PPUSH
103544: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
103548: LD_INT 30
103550: PPUSH
103551: LD_OWVAR 2
103555: PPUSH
103556: LD_INT 2
103558: PPUSH
103559: CALL_OW 322
// end ;
103563: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
103564: LD_EXP 75
103568: PUSH
103569: LD_EXP 127
103573: AND
103574: IFFALSE 103695
103576: GO 103578
103578: DISABLE
103579: LD_INT 0
103581: PPUSH
103582: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
103583: LD_ADDR_VAR 0 2
103587: PUSH
103588: LD_INT 22
103590: PUSH
103591: LD_OWVAR 2
103595: PUSH
103596: EMPTY
103597: LIST
103598: LIST
103599: PUSH
103600: LD_INT 21
103602: PUSH
103603: LD_INT 1
103605: PUSH
103606: EMPTY
103607: LIST
103608: LIST
103609: PUSH
103610: LD_INT 3
103612: PUSH
103613: LD_INT 23
103615: PUSH
103616: LD_INT 0
103618: PUSH
103619: EMPTY
103620: LIST
103621: LIST
103622: PUSH
103623: EMPTY
103624: LIST
103625: LIST
103626: PUSH
103627: EMPTY
103628: LIST
103629: LIST
103630: LIST
103631: PPUSH
103632: CALL_OW 69
103636: ST_TO_ADDR
// if not tmp then
103637: LD_VAR 0 2
103641: NOT
103642: IFFALSE 103646
// exit ;
103644: GO 103695
// for i in tmp do
103646: LD_ADDR_VAR 0 1
103650: PUSH
103651: LD_VAR 0 2
103655: PUSH
103656: FOR_IN
103657: IFFALSE 103693
// begin if Crawls ( i ) then
103659: LD_VAR 0 1
103663: PPUSH
103664: CALL_OW 318
103668: IFFALSE 103679
// ComWalk ( i ) ;
103670: LD_VAR 0 1
103674: PPUSH
103675: CALL_OW 138
// SetClass ( i , 2 ) ;
103679: LD_VAR 0 1
103683: PPUSH
103684: LD_INT 2
103686: PPUSH
103687: CALL_OW 336
// end ;
103691: GO 103656
103693: POP
103694: POP
// end ;
103695: PPOPN 2
103697: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
103698: LD_EXP 75
103702: PUSH
103703: LD_EXP 128
103707: AND
103708: IFFALSE 103996
103710: GO 103712
103712: DISABLE
103713: LD_INT 0
103715: PPUSH
103716: PPUSH
103717: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
103718: LD_OWVAR 2
103722: PPUSH
103723: LD_INT 9
103725: PPUSH
103726: LD_INT 1
103728: PPUSH
103729: LD_INT 1
103731: PPUSH
103732: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
103736: LD_INT 9
103738: PPUSH
103739: LD_OWVAR 2
103743: PPUSH
103744: CALL_OW 343
// uc_side := 9 ;
103748: LD_ADDR_OWVAR 20
103752: PUSH
103753: LD_INT 9
103755: ST_TO_ADDR
// uc_nation := 2 ;
103756: LD_ADDR_OWVAR 21
103760: PUSH
103761: LD_INT 2
103763: ST_TO_ADDR
// hc_name := Dark Warrior ;
103764: LD_ADDR_OWVAR 26
103768: PUSH
103769: LD_STRING Dark Warrior
103771: ST_TO_ADDR
// hc_gallery :=  ;
103772: LD_ADDR_OWVAR 33
103776: PUSH
103777: LD_STRING 
103779: ST_TO_ADDR
// hc_noskilllimit := true ;
103780: LD_ADDR_OWVAR 76
103784: PUSH
103785: LD_INT 1
103787: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
103788: LD_ADDR_OWVAR 31
103792: PUSH
103793: LD_INT 30
103795: PUSH
103796: LD_INT 30
103798: PUSH
103799: LD_INT 30
103801: PUSH
103802: LD_INT 30
103804: PUSH
103805: EMPTY
103806: LIST
103807: LIST
103808: LIST
103809: LIST
103810: ST_TO_ADDR
// un := CreateHuman ;
103811: LD_ADDR_VAR 0 3
103815: PUSH
103816: CALL_OW 44
103820: ST_TO_ADDR
// hc_noskilllimit := false ;
103821: LD_ADDR_OWVAR 76
103825: PUSH
103826: LD_INT 0
103828: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
103829: LD_VAR 0 3
103833: PPUSH
103834: LD_INT 1
103836: PPUSH
103837: CALL_OW 51
// ToLua ( playRanger() ) ;
103841: LD_STRING playRanger()
103843: PPUSH
103844: CALL_OW 559
// p := 0 ;
103848: LD_ADDR_VAR 0 2
103852: PUSH
103853: LD_INT 0
103855: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
103856: LD_INT 35
103858: PPUSH
103859: CALL_OW 67
// p := p + 1 ;
103863: LD_ADDR_VAR 0 2
103867: PUSH
103868: LD_VAR 0 2
103872: PUSH
103873: LD_INT 1
103875: PLUS
103876: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
103877: LD_VAR 0 3
103881: PPUSH
103882: CALL_OW 256
103886: PUSH
103887: LD_INT 1000
103889: LESS
103890: IFFALSE 103904
// SetLives ( un , 1000 ) ;
103892: LD_VAR 0 3
103896: PPUSH
103897: LD_INT 1000
103899: PPUSH
103900: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
103904: LD_VAR 0 3
103908: PPUSH
103909: LD_INT 81
103911: PUSH
103912: LD_OWVAR 2
103916: PUSH
103917: EMPTY
103918: LIST
103919: LIST
103920: PUSH
103921: LD_INT 91
103923: PUSH
103924: LD_VAR 0 3
103928: PUSH
103929: LD_INT 30
103931: PUSH
103932: EMPTY
103933: LIST
103934: LIST
103935: LIST
103936: PUSH
103937: EMPTY
103938: LIST
103939: LIST
103940: PPUSH
103941: CALL_OW 69
103945: PPUSH
103946: LD_VAR 0 3
103950: PPUSH
103951: CALL_OW 74
103955: PPUSH
103956: CALL_OW 115
// until p > 80 or IsDead ( un ) ;
103960: LD_VAR 0 2
103964: PUSH
103965: LD_INT 80
103967: GREATER
103968: PUSH
103969: LD_VAR 0 3
103973: PPUSH
103974: CALL_OW 301
103978: OR
103979: IFFALSE 103856
// if un then
103981: LD_VAR 0 3
103985: IFFALSE 103996
// RemoveUnit ( un ) ;
103987: LD_VAR 0 3
103991: PPUSH
103992: CALL_OW 64
// end ;
103996: PPOPN 3
103998: END
// every 0 0$1 trigger sComputer do var i , tmp , j ;
103999: LD_EXP 129
104003: IFFALSE 104119
104005: GO 104007
104007: DISABLE
104008: LD_INT 0
104010: PPUSH
104011: PPUSH
104012: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
104013: LD_ADDR_VAR 0 2
104017: PUSH
104018: LD_INT 81
104020: PUSH
104021: LD_OWVAR 2
104025: PUSH
104026: EMPTY
104027: LIST
104028: LIST
104029: PUSH
104030: LD_INT 21
104032: PUSH
104033: LD_INT 1
104035: PUSH
104036: EMPTY
104037: LIST
104038: LIST
104039: PUSH
104040: EMPTY
104041: LIST
104042: LIST
104043: PPUSH
104044: CALL_OW 69
104048: ST_TO_ADDR
// ToLua ( playComputer() ) ;
104049: LD_STRING playComputer()
104051: PPUSH
104052: CALL_OW 559
// if not tmp then
104056: LD_VAR 0 2
104060: NOT
104061: IFFALSE 104065
// exit ;
104063: GO 104119
// for i in tmp do
104065: LD_ADDR_VAR 0 1
104069: PUSH
104070: LD_VAR 0 2
104074: PUSH
104075: FOR_IN
104076: IFFALSE 104117
// for j := 1 to 4 do
104078: LD_ADDR_VAR 0 3
104082: PUSH
104083: DOUBLE
104084: LD_INT 1
104086: DEC
104087: ST_TO_ADDR
104088: LD_INT 4
104090: PUSH
104091: FOR_TO
104092: IFFALSE 104113
// SetSkill ( i , j , 10 ) ;
104094: LD_VAR 0 1
104098: PPUSH
104099: LD_VAR 0 3
104103: PPUSH
104104: LD_INT 10
104106: PPUSH
104107: CALL_OW 237
104111: GO 104091
104113: POP
104114: POP
104115: GO 104075
104117: POP
104118: POP
// end ;
104119: PPOPN 3
104121: END
// every 0 0$1 trigger s30 do var i , tmp ;
104122: LD_EXP 130
104126: IFFALSE 104195
104128: GO 104130
104130: DISABLE
104131: LD_INT 0
104133: PPUSH
104134: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
104135: LD_ADDR_VAR 0 2
104139: PUSH
104140: LD_INT 22
104142: PUSH
104143: LD_OWVAR 2
104147: PUSH
104148: EMPTY
104149: LIST
104150: LIST
104151: PPUSH
104152: CALL_OW 69
104156: ST_TO_ADDR
// if not tmp then
104157: LD_VAR 0 2
104161: NOT
104162: IFFALSE 104166
// exit ;
104164: GO 104195
// for i in tmp do
104166: LD_ADDR_VAR 0 1
104170: PUSH
104171: LD_VAR 0 2
104175: PUSH
104176: FOR_IN
104177: IFFALSE 104193
// SetLives ( i , 300 ) ;
104179: LD_VAR 0 1
104183: PPUSH
104184: LD_INT 300
104186: PPUSH
104187: CALL_OW 234
104191: GO 104176
104193: POP
104194: POP
// end ;
104195: PPOPN 2
104197: END
// every 0 0$1 trigger s60 do var i , tmp ;
104198: LD_EXP 131
104202: IFFALSE 104271
104204: GO 104206
104206: DISABLE
104207: LD_INT 0
104209: PPUSH
104210: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
104211: LD_ADDR_VAR 0 2
104215: PUSH
104216: LD_INT 22
104218: PUSH
104219: LD_OWVAR 2
104223: PUSH
104224: EMPTY
104225: LIST
104226: LIST
104227: PPUSH
104228: CALL_OW 69
104232: ST_TO_ADDR
// if not tmp then
104233: LD_VAR 0 2
104237: NOT
104238: IFFALSE 104242
// exit ;
104240: GO 104271
// for i in tmp do
104242: LD_ADDR_VAR 0 1
104246: PUSH
104247: LD_VAR 0 2
104251: PUSH
104252: FOR_IN
104253: IFFALSE 104269
// SetLives ( i , 600 ) ;
104255: LD_VAR 0 1
104259: PPUSH
104260: LD_INT 600
104262: PPUSH
104263: CALL_OW 234
104267: GO 104252
104269: POP
104270: POP
// end ;
104271: PPOPN 2
104273: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
104274: LD_INT 0
104276: PPUSH
// case cmd of 301 :
104277: LD_VAR 0 1
104281: PUSH
104282: LD_INT 301
104284: DOUBLE
104285: EQUAL
104286: IFTRUE 104290
104288: GO 104322
104290: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
104291: LD_VAR 0 6
104295: PPUSH
104296: LD_VAR 0 7
104300: PPUSH
104301: LD_VAR 0 8
104305: PPUSH
104306: LD_VAR 0 4
104310: PPUSH
104311: LD_VAR 0 5
104315: PPUSH
104316: CALL 105523 0 5
104320: GO 104443
104322: LD_INT 302
104324: DOUBLE
104325: EQUAL
104326: IFTRUE 104330
104328: GO 104367
104330: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
104331: LD_VAR 0 6
104335: PPUSH
104336: LD_VAR 0 7
104340: PPUSH
104341: LD_VAR 0 8
104345: PPUSH
104346: LD_VAR 0 9
104350: PPUSH
104351: LD_VAR 0 4
104355: PPUSH
104356: LD_VAR 0 5
104360: PPUSH
104361: CALL 105614 0 6
104365: GO 104443
104367: LD_INT 303
104369: DOUBLE
104370: EQUAL
104371: IFTRUE 104375
104373: GO 104412
104375: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
104376: LD_VAR 0 6
104380: PPUSH
104381: LD_VAR 0 7
104385: PPUSH
104386: LD_VAR 0 8
104390: PPUSH
104391: LD_VAR 0 9
104395: PPUSH
104396: LD_VAR 0 4
104400: PPUSH
104401: LD_VAR 0 5
104405: PPUSH
104406: CALL 104448 0 6
104410: GO 104443
104412: LD_INT 304
104414: DOUBLE
104415: EQUAL
104416: IFTRUE 104420
104418: GO 104442
104420: POP
// hHackTeleport ( unit , x , y ) ; end ;
104421: LD_VAR 0 2
104425: PPUSH
104426: LD_VAR 0 4
104430: PPUSH
104431: LD_VAR 0 5
104435: PPUSH
104436: CALL 106207 0 3
104440: GO 104443
104442: POP
// end ;
104443: LD_VAR 0 12
104447: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
104448: LD_INT 0
104450: PPUSH
104451: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
104452: LD_VAR 0 1
104456: PUSH
104457: LD_INT 1
104459: LESS
104460: PUSH
104461: LD_VAR 0 1
104465: PUSH
104466: LD_INT 3
104468: GREATER
104469: OR
104470: PUSH
104471: LD_VAR 0 5
104475: PPUSH
104476: LD_VAR 0 6
104480: PPUSH
104481: CALL_OW 428
104485: OR
104486: IFFALSE 104490
// exit ;
104488: GO 105210
// uc_side := your_side ;
104490: LD_ADDR_OWVAR 20
104494: PUSH
104495: LD_OWVAR 2
104499: ST_TO_ADDR
// uc_nation := nation ;
104500: LD_ADDR_OWVAR 21
104504: PUSH
104505: LD_VAR 0 1
104509: ST_TO_ADDR
// bc_level = 1 ;
104510: LD_ADDR_OWVAR 43
104514: PUSH
104515: LD_INT 1
104517: ST_TO_ADDR
// case btype of 1 :
104518: LD_VAR 0 2
104522: PUSH
104523: LD_INT 1
104525: DOUBLE
104526: EQUAL
104527: IFTRUE 104531
104529: GO 104542
104531: POP
// bc_type := b_depot ; 2 :
104532: LD_ADDR_OWVAR 42
104536: PUSH
104537: LD_INT 0
104539: ST_TO_ADDR
104540: GO 105154
104542: LD_INT 2
104544: DOUBLE
104545: EQUAL
104546: IFTRUE 104550
104548: GO 104561
104550: POP
// bc_type := b_warehouse ; 3 :
104551: LD_ADDR_OWVAR 42
104555: PUSH
104556: LD_INT 1
104558: ST_TO_ADDR
104559: GO 105154
104561: LD_INT 3
104563: DOUBLE
104564: EQUAL
104565: IFTRUE 104569
104567: GO 104580
104569: POP
// bc_type := b_lab ; 4 .. 9 :
104570: LD_ADDR_OWVAR 42
104574: PUSH
104575: LD_INT 6
104577: ST_TO_ADDR
104578: GO 105154
104580: LD_INT 4
104582: DOUBLE
104583: GREATEREQUAL
104584: IFFALSE 104592
104586: LD_INT 9
104588: DOUBLE
104589: LESSEQUAL
104590: IFTRUE 104594
104592: GO 104646
104594: POP
// begin bc_type := b_lab_half ;
104595: LD_ADDR_OWVAR 42
104599: PUSH
104600: LD_INT 7
104602: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
104603: LD_ADDR_OWVAR 44
104607: PUSH
104608: LD_INT 10
104610: PUSH
104611: LD_INT 11
104613: PUSH
104614: LD_INT 12
104616: PUSH
104617: LD_INT 15
104619: PUSH
104620: LD_INT 14
104622: PUSH
104623: LD_INT 13
104625: PUSH
104626: EMPTY
104627: LIST
104628: LIST
104629: LIST
104630: LIST
104631: LIST
104632: LIST
104633: PUSH
104634: LD_VAR 0 2
104638: PUSH
104639: LD_INT 3
104641: MINUS
104642: ARRAY
104643: ST_TO_ADDR
// end ; 10 .. 13 :
104644: GO 105154
104646: LD_INT 10
104648: DOUBLE
104649: GREATEREQUAL
104650: IFFALSE 104658
104652: LD_INT 13
104654: DOUBLE
104655: LESSEQUAL
104656: IFTRUE 104660
104658: GO 104737
104660: POP
// begin bc_type := b_lab_full ;
104661: LD_ADDR_OWVAR 42
104665: PUSH
104666: LD_INT 8
104668: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
104669: LD_ADDR_OWVAR 44
104673: PUSH
104674: LD_INT 10
104676: PUSH
104677: LD_INT 12
104679: PUSH
104680: LD_INT 14
104682: PUSH
104683: LD_INT 13
104685: PUSH
104686: EMPTY
104687: LIST
104688: LIST
104689: LIST
104690: LIST
104691: PUSH
104692: LD_VAR 0 2
104696: PUSH
104697: LD_INT 9
104699: MINUS
104700: ARRAY
104701: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
104702: LD_ADDR_OWVAR 45
104706: PUSH
104707: LD_INT 11
104709: PUSH
104710: LD_INT 15
104712: PUSH
104713: LD_INT 12
104715: PUSH
104716: LD_INT 15
104718: PUSH
104719: EMPTY
104720: LIST
104721: LIST
104722: LIST
104723: LIST
104724: PUSH
104725: LD_VAR 0 2
104729: PUSH
104730: LD_INT 9
104732: MINUS
104733: ARRAY
104734: ST_TO_ADDR
// end ; 14 :
104735: GO 105154
104737: LD_INT 14
104739: DOUBLE
104740: EQUAL
104741: IFTRUE 104745
104743: GO 104756
104745: POP
// bc_type := b_workshop ; 15 :
104746: LD_ADDR_OWVAR 42
104750: PUSH
104751: LD_INT 2
104753: ST_TO_ADDR
104754: GO 105154
104756: LD_INT 15
104758: DOUBLE
104759: EQUAL
104760: IFTRUE 104764
104762: GO 104775
104764: POP
// bc_type := b_factory ; 16 :
104765: LD_ADDR_OWVAR 42
104769: PUSH
104770: LD_INT 3
104772: ST_TO_ADDR
104773: GO 105154
104775: LD_INT 16
104777: DOUBLE
104778: EQUAL
104779: IFTRUE 104783
104781: GO 104794
104783: POP
// bc_type := b_ext_gun ; 17 :
104784: LD_ADDR_OWVAR 42
104788: PUSH
104789: LD_INT 17
104791: ST_TO_ADDR
104792: GO 105154
104794: LD_INT 17
104796: DOUBLE
104797: EQUAL
104798: IFTRUE 104802
104800: GO 104830
104802: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
104803: LD_ADDR_OWVAR 42
104807: PUSH
104808: LD_INT 19
104810: PUSH
104811: LD_INT 23
104813: PUSH
104814: LD_INT 19
104816: PUSH
104817: EMPTY
104818: LIST
104819: LIST
104820: LIST
104821: PUSH
104822: LD_VAR 0 1
104826: ARRAY
104827: ST_TO_ADDR
104828: GO 105154
104830: LD_INT 18
104832: DOUBLE
104833: EQUAL
104834: IFTRUE 104838
104836: GO 104849
104838: POP
// bc_type := b_ext_radar ; 19 :
104839: LD_ADDR_OWVAR 42
104843: PUSH
104844: LD_INT 20
104846: ST_TO_ADDR
104847: GO 105154
104849: LD_INT 19
104851: DOUBLE
104852: EQUAL
104853: IFTRUE 104857
104855: GO 104868
104857: POP
// bc_type := b_ext_radio ; 20 :
104858: LD_ADDR_OWVAR 42
104862: PUSH
104863: LD_INT 22
104865: ST_TO_ADDR
104866: GO 105154
104868: LD_INT 20
104870: DOUBLE
104871: EQUAL
104872: IFTRUE 104876
104874: GO 104887
104876: POP
// bc_type := b_ext_siberium ; 21 :
104877: LD_ADDR_OWVAR 42
104881: PUSH
104882: LD_INT 21
104884: ST_TO_ADDR
104885: GO 105154
104887: LD_INT 21
104889: DOUBLE
104890: EQUAL
104891: IFTRUE 104895
104893: GO 104906
104895: POP
// bc_type := b_ext_computer ; 22 :
104896: LD_ADDR_OWVAR 42
104900: PUSH
104901: LD_INT 24
104903: ST_TO_ADDR
104904: GO 105154
104906: LD_INT 22
104908: DOUBLE
104909: EQUAL
104910: IFTRUE 104914
104912: GO 104925
104914: POP
// bc_type := b_ext_track ; 23 :
104915: LD_ADDR_OWVAR 42
104919: PUSH
104920: LD_INT 16
104922: ST_TO_ADDR
104923: GO 105154
104925: LD_INT 23
104927: DOUBLE
104928: EQUAL
104929: IFTRUE 104933
104931: GO 104944
104933: POP
// bc_type := b_ext_laser ; 24 :
104934: LD_ADDR_OWVAR 42
104938: PUSH
104939: LD_INT 25
104941: ST_TO_ADDR
104942: GO 105154
104944: LD_INT 24
104946: DOUBLE
104947: EQUAL
104948: IFTRUE 104952
104950: GO 104963
104952: POP
// bc_type := b_control_tower ; 25 :
104953: LD_ADDR_OWVAR 42
104957: PUSH
104958: LD_INT 36
104960: ST_TO_ADDR
104961: GO 105154
104963: LD_INT 25
104965: DOUBLE
104966: EQUAL
104967: IFTRUE 104971
104969: GO 104982
104971: POP
// bc_type := b_breastwork ; 26 :
104972: LD_ADDR_OWVAR 42
104976: PUSH
104977: LD_INT 31
104979: ST_TO_ADDR
104980: GO 105154
104982: LD_INT 26
104984: DOUBLE
104985: EQUAL
104986: IFTRUE 104990
104988: GO 105001
104990: POP
// bc_type := b_bunker ; 27 :
104991: LD_ADDR_OWVAR 42
104995: PUSH
104996: LD_INT 32
104998: ST_TO_ADDR
104999: GO 105154
105001: LD_INT 27
105003: DOUBLE
105004: EQUAL
105005: IFTRUE 105009
105007: GO 105020
105009: POP
// bc_type := b_turret ; 28 :
105010: LD_ADDR_OWVAR 42
105014: PUSH
105015: LD_INT 33
105017: ST_TO_ADDR
105018: GO 105154
105020: LD_INT 28
105022: DOUBLE
105023: EQUAL
105024: IFTRUE 105028
105026: GO 105039
105028: POP
// bc_type := b_armoury ; 29 :
105029: LD_ADDR_OWVAR 42
105033: PUSH
105034: LD_INT 4
105036: ST_TO_ADDR
105037: GO 105154
105039: LD_INT 29
105041: DOUBLE
105042: EQUAL
105043: IFTRUE 105047
105045: GO 105058
105047: POP
// bc_type := b_barracks ; 30 :
105048: LD_ADDR_OWVAR 42
105052: PUSH
105053: LD_INT 5
105055: ST_TO_ADDR
105056: GO 105154
105058: LD_INT 30
105060: DOUBLE
105061: EQUAL
105062: IFTRUE 105066
105064: GO 105077
105066: POP
// bc_type := b_solar_power ; 31 :
105067: LD_ADDR_OWVAR 42
105071: PUSH
105072: LD_INT 27
105074: ST_TO_ADDR
105075: GO 105154
105077: LD_INT 31
105079: DOUBLE
105080: EQUAL
105081: IFTRUE 105085
105083: GO 105096
105085: POP
// bc_type := b_oil_power ; 32 :
105086: LD_ADDR_OWVAR 42
105090: PUSH
105091: LD_INT 26
105093: ST_TO_ADDR
105094: GO 105154
105096: LD_INT 32
105098: DOUBLE
105099: EQUAL
105100: IFTRUE 105104
105102: GO 105115
105104: POP
// bc_type := b_siberite_power ; 33 :
105105: LD_ADDR_OWVAR 42
105109: PUSH
105110: LD_INT 28
105112: ST_TO_ADDR
105113: GO 105154
105115: LD_INT 33
105117: DOUBLE
105118: EQUAL
105119: IFTRUE 105123
105121: GO 105134
105123: POP
// bc_type := b_oil_mine ; 34 :
105124: LD_ADDR_OWVAR 42
105128: PUSH
105129: LD_INT 29
105131: ST_TO_ADDR
105132: GO 105154
105134: LD_INT 34
105136: DOUBLE
105137: EQUAL
105138: IFTRUE 105142
105140: GO 105153
105142: POP
// bc_type := b_siberite_mine ; end ;
105143: LD_ADDR_OWVAR 42
105147: PUSH
105148: LD_INT 30
105150: ST_TO_ADDR
105151: GO 105154
105153: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
105154: LD_ADDR_VAR 0 8
105158: PUSH
105159: LD_VAR 0 5
105163: PPUSH
105164: LD_VAR 0 6
105168: PPUSH
105169: LD_VAR 0 3
105173: PPUSH
105174: CALL_OW 47
105178: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
105179: LD_OWVAR 42
105183: PUSH
105184: LD_INT 32
105186: PUSH
105187: LD_INT 33
105189: PUSH
105190: EMPTY
105191: LIST
105192: LIST
105193: IN
105194: IFFALSE 105210
// PlaceWeaponTurret ( b , weapon ) ;
105196: LD_VAR 0 8
105200: PPUSH
105201: LD_VAR 0 4
105205: PPUSH
105206: CALL_OW 431
// end ;
105210: LD_VAR 0 7
105214: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
105215: LD_INT 0
105217: PPUSH
105218: PPUSH
105219: PPUSH
105220: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
105221: LD_ADDR_VAR 0 4
105225: PUSH
105226: LD_INT 22
105228: PUSH
105229: LD_OWVAR 2
105233: PUSH
105234: EMPTY
105235: LIST
105236: LIST
105237: PUSH
105238: LD_INT 2
105240: PUSH
105241: LD_INT 30
105243: PUSH
105244: LD_INT 0
105246: PUSH
105247: EMPTY
105248: LIST
105249: LIST
105250: PUSH
105251: LD_INT 30
105253: PUSH
105254: LD_INT 1
105256: PUSH
105257: EMPTY
105258: LIST
105259: LIST
105260: PUSH
105261: EMPTY
105262: LIST
105263: LIST
105264: LIST
105265: PUSH
105266: EMPTY
105267: LIST
105268: LIST
105269: PPUSH
105270: CALL_OW 69
105274: ST_TO_ADDR
// if not tmp then
105275: LD_VAR 0 4
105279: NOT
105280: IFFALSE 105284
// exit ;
105282: GO 105343
// for i in tmp do
105284: LD_ADDR_VAR 0 2
105288: PUSH
105289: LD_VAR 0 4
105293: PUSH
105294: FOR_IN
105295: IFFALSE 105341
// for j = 1 to 3 do
105297: LD_ADDR_VAR 0 3
105301: PUSH
105302: DOUBLE
105303: LD_INT 1
105305: DEC
105306: ST_TO_ADDR
105307: LD_INT 3
105309: PUSH
105310: FOR_TO
105311: IFFALSE 105337
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
105313: LD_VAR 0 2
105317: PPUSH
105318: CALL_OW 274
105322: PPUSH
105323: LD_VAR 0 3
105327: PPUSH
105328: LD_INT 99999
105330: PPUSH
105331: CALL_OW 277
105335: GO 105310
105337: POP
105338: POP
105339: GO 105294
105341: POP
105342: POP
// end ;
105343: LD_VAR 0 1
105347: RET
// export function hHackSetLevel10 ; var i , j ; begin
105348: LD_INT 0
105350: PPUSH
105351: PPUSH
105352: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
105353: LD_ADDR_VAR 0 2
105357: PUSH
105358: LD_INT 21
105360: PUSH
105361: LD_INT 1
105363: PUSH
105364: EMPTY
105365: LIST
105366: LIST
105367: PPUSH
105368: CALL_OW 69
105372: PUSH
105373: FOR_IN
105374: IFFALSE 105426
// if IsSelected ( i ) then
105376: LD_VAR 0 2
105380: PPUSH
105381: CALL_OW 306
105385: IFFALSE 105424
// begin for j := 1 to 4 do
105387: LD_ADDR_VAR 0 3
105391: PUSH
105392: DOUBLE
105393: LD_INT 1
105395: DEC
105396: ST_TO_ADDR
105397: LD_INT 4
105399: PUSH
105400: FOR_TO
105401: IFFALSE 105422
// SetSkill ( i , j , 10 ) ;
105403: LD_VAR 0 2
105407: PPUSH
105408: LD_VAR 0 3
105412: PPUSH
105413: LD_INT 10
105415: PPUSH
105416: CALL_OW 237
105420: GO 105400
105422: POP
105423: POP
// end ;
105424: GO 105373
105426: POP
105427: POP
// end ;
105428: LD_VAR 0 1
105432: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
105433: LD_INT 0
105435: PPUSH
105436: PPUSH
105437: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
105438: LD_ADDR_VAR 0 2
105442: PUSH
105443: LD_INT 22
105445: PUSH
105446: LD_OWVAR 2
105450: PUSH
105451: EMPTY
105452: LIST
105453: LIST
105454: PUSH
105455: LD_INT 21
105457: PUSH
105458: LD_INT 1
105460: PUSH
105461: EMPTY
105462: LIST
105463: LIST
105464: PUSH
105465: EMPTY
105466: LIST
105467: LIST
105468: PPUSH
105469: CALL_OW 69
105473: PUSH
105474: FOR_IN
105475: IFFALSE 105516
// begin for j := 1 to 4 do
105477: LD_ADDR_VAR 0 3
105481: PUSH
105482: DOUBLE
105483: LD_INT 1
105485: DEC
105486: ST_TO_ADDR
105487: LD_INT 4
105489: PUSH
105490: FOR_TO
105491: IFFALSE 105512
// SetSkill ( i , j , 10 ) ;
105493: LD_VAR 0 2
105497: PPUSH
105498: LD_VAR 0 3
105502: PPUSH
105503: LD_INT 10
105505: PPUSH
105506: CALL_OW 237
105510: GO 105490
105512: POP
105513: POP
// end ;
105514: GO 105474
105516: POP
105517: POP
// end ;
105518: LD_VAR 0 1
105522: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
105523: LD_INT 0
105525: PPUSH
// uc_side := your_side ;
105526: LD_ADDR_OWVAR 20
105530: PUSH
105531: LD_OWVAR 2
105535: ST_TO_ADDR
// uc_nation := nation ;
105536: LD_ADDR_OWVAR 21
105540: PUSH
105541: LD_VAR 0 1
105545: ST_TO_ADDR
// InitHc ;
105546: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
105550: LD_INT 0
105552: PPUSH
105553: LD_VAR 0 2
105557: PPUSH
105558: LD_VAR 0 3
105562: PPUSH
105563: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
105567: LD_VAR 0 4
105571: PPUSH
105572: LD_VAR 0 5
105576: PPUSH
105577: CALL_OW 428
105581: PUSH
105582: LD_INT 0
105584: EQUAL
105585: IFFALSE 105609
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
105587: CALL_OW 44
105591: PPUSH
105592: LD_VAR 0 4
105596: PPUSH
105597: LD_VAR 0 5
105601: PPUSH
105602: LD_INT 1
105604: PPUSH
105605: CALL_OW 48
// end ;
105609: LD_VAR 0 6
105613: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
105614: LD_INT 0
105616: PPUSH
105617: PPUSH
// uc_side := your_side ;
105618: LD_ADDR_OWVAR 20
105622: PUSH
105623: LD_OWVAR 2
105627: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
105628: LD_VAR 0 1
105632: PUSH
105633: LD_INT 1
105635: PUSH
105636: LD_INT 2
105638: PUSH
105639: LD_INT 3
105641: PUSH
105642: LD_INT 4
105644: PUSH
105645: LD_INT 5
105647: PUSH
105648: EMPTY
105649: LIST
105650: LIST
105651: LIST
105652: LIST
105653: LIST
105654: IN
105655: IFFALSE 105667
// uc_nation := nation_american else
105657: LD_ADDR_OWVAR 21
105661: PUSH
105662: LD_INT 1
105664: ST_TO_ADDR
105665: GO 105710
// if chassis in [ 11 , 12 , 13 , 14 ] then
105667: LD_VAR 0 1
105671: PUSH
105672: LD_INT 11
105674: PUSH
105675: LD_INT 12
105677: PUSH
105678: LD_INT 13
105680: PUSH
105681: LD_INT 14
105683: PUSH
105684: EMPTY
105685: LIST
105686: LIST
105687: LIST
105688: LIST
105689: IN
105690: IFFALSE 105702
// uc_nation := nation_arabian else
105692: LD_ADDR_OWVAR 21
105696: PUSH
105697: LD_INT 2
105699: ST_TO_ADDR
105700: GO 105710
// uc_nation := nation_russian ;
105702: LD_ADDR_OWVAR 21
105706: PUSH
105707: LD_INT 3
105709: ST_TO_ADDR
// vc_chassis := chassis ;
105710: LD_ADDR_OWVAR 37
105714: PUSH
105715: LD_VAR 0 1
105719: ST_TO_ADDR
// vc_engine := engine ;
105720: LD_ADDR_OWVAR 39
105724: PUSH
105725: LD_VAR 0 2
105729: ST_TO_ADDR
// vc_control := control ;
105730: LD_ADDR_OWVAR 38
105734: PUSH
105735: LD_VAR 0 3
105739: ST_TO_ADDR
// vc_weapon := weapon ;
105740: LD_ADDR_OWVAR 40
105744: PUSH
105745: LD_VAR 0 4
105749: ST_TO_ADDR
// un := CreateVehicle ;
105750: LD_ADDR_VAR 0 8
105754: PUSH
105755: CALL_OW 45
105759: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
105760: LD_VAR 0 8
105764: PPUSH
105765: LD_INT 0
105767: PPUSH
105768: LD_INT 5
105770: PPUSH
105771: CALL_OW 12
105775: PPUSH
105776: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
105780: LD_VAR 0 8
105784: PPUSH
105785: LD_VAR 0 5
105789: PPUSH
105790: LD_VAR 0 6
105794: PPUSH
105795: LD_INT 1
105797: PPUSH
105798: CALL_OW 48
// end ;
105802: LD_VAR 0 7
105806: RET
// export hInvincible ; every 1 do
105807: GO 105809
105809: DISABLE
// hInvincible := [ ] ;
105810: LD_ADDR_EXP 132
105814: PUSH
105815: EMPTY
105816: ST_TO_ADDR
105817: END
// every 10 do var i ;
105818: GO 105820
105820: DISABLE
105821: LD_INT 0
105823: PPUSH
// begin enable ;
105824: ENABLE
// if not hInvincible then
105825: LD_EXP 132
105829: NOT
105830: IFFALSE 105834
// exit ;
105832: GO 105878
// for i in hInvincible do
105834: LD_ADDR_VAR 0 1
105838: PUSH
105839: LD_EXP 132
105843: PUSH
105844: FOR_IN
105845: IFFALSE 105876
// if GetLives ( i ) < 1000 then
105847: LD_VAR 0 1
105851: PPUSH
105852: CALL_OW 256
105856: PUSH
105857: LD_INT 1000
105859: LESS
105860: IFFALSE 105874
// SetLives ( i , 1000 ) ;
105862: LD_VAR 0 1
105866: PPUSH
105867: LD_INT 1000
105869: PPUSH
105870: CALL_OW 234
105874: GO 105844
105876: POP
105877: POP
// end ;
105878: PPOPN 1
105880: END
// export function hHackInvincible ; var i ; begin
105881: LD_INT 0
105883: PPUSH
105884: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
105885: LD_ADDR_VAR 0 2
105889: PUSH
105890: LD_INT 2
105892: PUSH
105893: LD_INT 21
105895: PUSH
105896: LD_INT 1
105898: PUSH
105899: EMPTY
105900: LIST
105901: LIST
105902: PUSH
105903: LD_INT 21
105905: PUSH
105906: LD_INT 2
105908: PUSH
105909: EMPTY
105910: LIST
105911: LIST
105912: PUSH
105913: EMPTY
105914: LIST
105915: LIST
105916: LIST
105917: PPUSH
105918: CALL_OW 69
105922: PUSH
105923: FOR_IN
105924: IFFALSE 105985
// if IsSelected ( i ) then
105926: LD_VAR 0 2
105930: PPUSH
105931: CALL_OW 306
105935: IFFALSE 105983
// begin if i in hInvincible then
105937: LD_VAR 0 2
105941: PUSH
105942: LD_EXP 132
105946: IN
105947: IFFALSE 105967
// hInvincible := hInvincible diff i else
105949: LD_ADDR_EXP 132
105953: PUSH
105954: LD_EXP 132
105958: PUSH
105959: LD_VAR 0 2
105963: DIFF
105964: ST_TO_ADDR
105965: GO 105983
// hInvincible := hInvincible union i ;
105967: LD_ADDR_EXP 132
105971: PUSH
105972: LD_EXP 132
105976: PUSH
105977: LD_VAR 0 2
105981: UNION
105982: ST_TO_ADDR
// end ;
105983: GO 105923
105985: POP
105986: POP
// end ;
105987: LD_VAR 0 1
105991: RET
// export function hHackInvisible ; var i , j ; begin
105992: LD_INT 0
105994: PPUSH
105995: PPUSH
105996: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
105997: LD_ADDR_VAR 0 2
106001: PUSH
106002: LD_INT 21
106004: PUSH
106005: LD_INT 1
106007: PUSH
106008: EMPTY
106009: LIST
106010: LIST
106011: PPUSH
106012: CALL_OW 69
106016: PUSH
106017: FOR_IN
106018: IFFALSE 106042
// if IsSelected ( i ) then
106020: LD_VAR 0 2
106024: PPUSH
106025: CALL_OW 306
106029: IFFALSE 106040
// ComForceInvisible ( i ) ;
106031: LD_VAR 0 2
106035: PPUSH
106036: CALL_OW 496
106040: GO 106017
106042: POP
106043: POP
// end ;
106044: LD_VAR 0 1
106048: RET
// export function hHackChangeYourSide ; begin
106049: LD_INT 0
106051: PPUSH
// if your_side = 8 then
106052: LD_OWVAR 2
106056: PUSH
106057: LD_INT 8
106059: EQUAL
106060: IFFALSE 106072
// your_side := 0 else
106062: LD_ADDR_OWVAR 2
106066: PUSH
106067: LD_INT 0
106069: ST_TO_ADDR
106070: GO 106086
// your_side := your_side + 1 ;
106072: LD_ADDR_OWVAR 2
106076: PUSH
106077: LD_OWVAR 2
106081: PUSH
106082: LD_INT 1
106084: PLUS
106085: ST_TO_ADDR
// end ;
106086: LD_VAR 0 1
106090: RET
// export function hHackChangeUnitSide ; var i , j ; begin
106091: LD_INT 0
106093: PPUSH
106094: PPUSH
106095: PPUSH
// for i in all_units do
106096: LD_ADDR_VAR 0 2
106100: PUSH
106101: LD_OWVAR 3
106105: PUSH
106106: FOR_IN
106107: IFFALSE 106185
// if IsSelected ( i ) then
106109: LD_VAR 0 2
106113: PPUSH
106114: CALL_OW 306
106118: IFFALSE 106183
// begin j := GetSide ( i ) ;
106120: LD_ADDR_VAR 0 3
106124: PUSH
106125: LD_VAR 0 2
106129: PPUSH
106130: CALL_OW 255
106134: ST_TO_ADDR
// if j = 8 then
106135: LD_VAR 0 3
106139: PUSH
106140: LD_INT 8
106142: EQUAL
106143: IFFALSE 106155
// j := 0 else
106145: LD_ADDR_VAR 0 3
106149: PUSH
106150: LD_INT 0
106152: ST_TO_ADDR
106153: GO 106169
// j := j + 1 ;
106155: LD_ADDR_VAR 0 3
106159: PUSH
106160: LD_VAR 0 3
106164: PUSH
106165: LD_INT 1
106167: PLUS
106168: ST_TO_ADDR
// SetSide ( i , j ) ;
106169: LD_VAR 0 2
106173: PPUSH
106174: LD_VAR 0 3
106178: PPUSH
106179: CALL_OW 235
// end ;
106183: GO 106106
106185: POP
106186: POP
// end ;
106187: LD_VAR 0 1
106191: RET
// export function hHackFog ; begin
106192: LD_INT 0
106194: PPUSH
// FogOff ( true ) ;
106195: LD_INT 1
106197: PPUSH
106198: CALL_OW 344
// end ;
106202: LD_VAR 0 1
106206: RET
// export function hHackTeleport ( unit , x , y ) ; begin
106207: LD_INT 0
106209: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
106210: LD_VAR 0 1
106214: PPUSH
106215: LD_VAR 0 2
106219: PPUSH
106220: LD_VAR 0 3
106224: PPUSH
106225: LD_INT 1
106227: PPUSH
106228: LD_INT 1
106230: PPUSH
106231: CALL_OW 483
// CenterOnXY ( x , y ) ;
106235: LD_VAR 0 2
106239: PPUSH
106240: LD_VAR 0 3
106244: PPUSH
106245: CALL_OW 84
// end ;
106249: LD_VAR 0 4
106253: RET
// export factoryWaypoints ; export function SetFactoryWaypoint ( factory , x , y ) ; var i ; begin
106254: LD_INT 0
106256: PPUSH
106257: PPUSH
// if not factory or not ValidHex ( x , y ) or ( GetBType ( factory ) <> b_factory and not GetType ( factory ) = unit_human ) then
106258: LD_VAR 0 1
106262: NOT
106263: PUSH
106264: LD_VAR 0 2
106268: PPUSH
106269: LD_VAR 0 3
106273: PPUSH
106274: CALL_OW 488
106278: NOT
106279: OR
106280: PUSH
106281: LD_VAR 0 1
106285: PPUSH
106286: CALL_OW 266
106290: PUSH
106291: LD_INT 3
106293: NONEQUAL
106294: PUSH
106295: LD_VAR 0 1
106299: PPUSH
106300: CALL_OW 247
106304: PUSH
106305: LD_INT 1
106307: EQUAL
106308: NOT
106309: AND
106310: OR
106311: IFFALSE 106315
// exit ;
106313: GO 106464
// if GetType ( factory ) = unit_human then
106315: LD_VAR 0 1
106319: PPUSH
106320: CALL_OW 247
106324: PUSH
106325: LD_INT 1
106327: EQUAL
106328: IFFALSE 106345
// factory := IsInUnit ( factory ) ;
106330: LD_ADDR_VAR 0 1
106334: PUSH
106335: LD_VAR 0 1
106339: PPUSH
106340: CALL_OW 310
106344: ST_TO_ADDR
// if GetBType ( factory ) <> b_factory then
106345: LD_VAR 0 1
106349: PPUSH
106350: CALL_OW 266
106354: PUSH
106355: LD_INT 3
106357: NONEQUAL
106358: IFFALSE 106362
// exit ;
106360: GO 106464
// if HexInfo ( x , y ) = factory then
106362: LD_VAR 0 2
106366: PPUSH
106367: LD_VAR 0 3
106371: PPUSH
106372: CALL_OW 428
106376: PUSH
106377: LD_VAR 0 1
106381: EQUAL
106382: IFFALSE 106409
// factoryWaypoints := Replace ( factoryWaypoints , factory , 0 ) else
106384: LD_ADDR_EXP 133
106388: PUSH
106389: LD_EXP 133
106393: PPUSH
106394: LD_VAR 0 1
106398: PPUSH
106399: LD_INT 0
106401: PPUSH
106402: CALL_OW 1
106406: ST_TO_ADDR
106407: GO 106460
// factoryWaypoints := Replace ( factoryWaypoints , factory , [ GetSide ( factory ) , factory , x , y ] ) ;
106409: LD_ADDR_EXP 133
106413: PUSH
106414: LD_EXP 133
106418: PPUSH
106419: LD_VAR 0 1
106423: PPUSH
106424: LD_VAR 0 1
106428: PPUSH
106429: CALL_OW 255
106433: PUSH
106434: LD_VAR 0 1
106438: PUSH
106439: LD_VAR 0 2
106443: PUSH
106444: LD_VAR 0 3
106448: PUSH
106449: EMPTY
106450: LIST
106451: LIST
106452: LIST
106453: LIST
106454: PPUSH
106455: CALL_OW 1
106459: ST_TO_ADDR
// UpdateFactoryWaypoints ;
106460: CALL 106469 0 0
// end ;
106464: LD_VAR 0 4
106468: RET
// export function UpdateFactoryWaypoints ( ) ; var i , list ; begin
106469: LD_INT 0
106471: PPUSH
106472: PPUSH
106473: PPUSH
// ToLua ( resetFactoryWaypoint(); ) ;
106474: LD_STRING resetFactoryWaypoint();
106476: PPUSH
106477: CALL_OW 559
// if factoryWaypoints then
106481: LD_EXP 133
106485: IFFALSE 106611
// begin list := PrepareArray ( factoryWaypoints ) ;
106487: LD_ADDR_VAR 0 3
106491: PUSH
106492: LD_EXP 133
106496: PPUSH
106497: CALL 61091 0 1
106501: ST_TO_ADDR
// for i := 1 to list do
106502: LD_ADDR_VAR 0 2
106506: PUSH
106507: DOUBLE
106508: LD_INT 1
106510: DEC
106511: ST_TO_ADDR
106512: LD_VAR 0 3
106516: PUSH
106517: FOR_TO
106518: IFFALSE 106609
// ToLua ( setFactoryWaypointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
106520: LD_STRING setFactoryWaypointXY(
106522: PUSH
106523: LD_VAR 0 3
106527: PUSH
106528: LD_VAR 0 2
106532: ARRAY
106533: PUSH
106534: LD_INT 1
106536: ARRAY
106537: STR
106538: PUSH
106539: LD_STRING ,
106541: STR
106542: PUSH
106543: LD_VAR 0 3
106547: PUSH
106548: LD_VAR 0 2
106552: ARRAY
106553: PUSH
106554: LD_INT 2
106556: ARRAY
106557: STR
106558: PUSH
106559: LD_STRING ,
106561: STR
106562: PUSH
106563: LD_VAR 0 3
106567: PUSH
106568: LD_VAR 0 2
106572: ARRAY
106573: PUSH
106574: LD_INT 3
106576: ARRAY
106577: STR
106578: PUSH
106579: LD_STRING ,
106581: STR
106582: PUSH
106583: LD_VAR 0 3
106587: PUSH
106588: LD_VAR 0 2
106592: ARRAY
106593: PUSH
106594: LD_INT 4
106596: ARRAY
106597: STR
106598: PUSH
106599: LD_STRING )
106601: STR
106602: PPUSH
106603: CALL_OW 559
106607: GO 106517
106609: POP
106610: POP
// end ; end ;
106611: LD_VAR 0 1
106615: RET
// export warehouseGatheringPoints , warehouseCratesCollectors ; export function SetWarehouseGatheringPoint ( warehouse , x , y ) ; begin
106616: LD_INT 0
106618: PPUSH
// if HexInfo ( x , y ) = warehouse then
106619: LD_VAR 0 2
106623: PPUSH
106624: LD_VAR 0 3
106628: PPUSH
106629: CALL_OW 428
106633: PUSH
106634: LD_VAR 0 1
106638: EQUAL
106639: IFFALSE 106666
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , 0 ) else
106641: LD_ADDR_EXP 134
106645: PUSH
106646: LD_EXP 134
106650: PPUSH
106651: LD_VAR 0 1
106655: PPUSH
106656: LD_INT 0
106658: PPUSH
106659: CALL_OW 1
106663: ST_TO_ADDR
106664: GO 106717
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , [ GetSide ( warehouse ) , warehouse , x , y ] ) ;
106666: LD_ADDR_EXP 134
106670: PUSH
106671: LD_EXP 134
106675: PPUSH
106676: LD_VAR 0 1
106680: PPUSH
106681: LD_VAR 0 1
106685: PPUSH
106686: CALL_OW 255
106690: PUSH
106691: LD_VAR 0 1
106695: PUSH
106696: LD_VAR 0 2
106700: PUSH
106701: LD_VAR 0 3
106705: PUSH
106706: EMPTY
106707: LIST
106708: LIST
106709: LIST
106710: LIST
106711: PPUSH
106712: CALL_OW 1
106716: ST_TO_ADDR
// UpdateWarehouseGatheringPoints ;
106717: CALL 106726 0 0
// end ;
106721: LD_VAR 0 4
106725: RET
// export function UpdateWarehouseGatheringPoints ( ) ; var i , list ; begin
106726: LD_INT 0
106728: PPUSH
106729: PPUSH
106730: PPUSH
// ToLua ( resetWarehouseGatheringPoints(); ) ;
106731: LD_STRING resetWarehouseGatheringPoints();
106733: PPUSH
106734: CALL_OW 559
// if warehouseGatheringPoints then
106738: LD_EXP 134
106742: IFFALSE 106868
// begin list := PrepareArray ( warehouseGatheringPoints ) ;
106744: LD_ADDR_VAR 0 3
106748: PUSH
106749: LD_EXP 134
106753: PPUSH
106754: CALL 61091 0 1
106758: ST_TO_ADDR
// for i := 1 to list do
106759: LD_ADDR_VAR 0 2
106763: PUSH
106764: DOUBLE
106765: LD_INT 1
106767: DEC
106768: ST_TO_ADDR
106769: LD_VAR 0 3
106773: PUSH
106774: FOR_TO
106775: IFFALSE 106866
// ToLua ( setWarehouseGatheringPointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
106777: LD_STRING setWarehouseGatheringPointXY(
106779: PUSH
106780: LD_VAR 0 3
106784: PUSH
106785: LD_VAR 0 2
106789: ARRAY
106790: PUSH
106791: LD_INT 1
106793: ARRAY
106794: STR
106795: PUSH
106796: LD_STRING ,
106798: STR
106799: PUSH
106800: LD_VAR 0 3
106804: PUSH
106805: LD_VAR 0 2
106809: ARRAY
106810: PUSH
106811: LD_INT 2
106813: ARRAY
106814: STR
106815: PUSH
106816: LD_STRING ,
106818: STR
106819: PUSH
106820: LD_VAR 0 3
106824: PUSH
106825: LD_VAR 0 2
106829: ARRAY
106830: PUSH
106831: LD_INT 3
106833: ARRAY
106834: STR
106835: PUSH
106836: LD_STRING ,
106838: STR
106839: PUSH
106840: LD_VAR 0 3
106844: PUSH
106845: LD_VAR 0 2
106849: ARRAY
106850: PUSH
106851: LD_INT 4
106853: ARRAY
106854: STR
106855: PUSH
106856: LD_STRING )
106858: STR
106859: PPUSH
106860: CALL_OW 559
106864: GO 106774
106866: POP
106867: POP
// end ; end ;
106868: LD_VAR 0 1
106872: RET
// every 0 0$20 trigger warehouseGatheringPoints do var i , j , list , tmp , side , x , y , depot , cratesNearbyPoint ;
106873: LD_EXP 134
106877: IFFALSE 107562
106879: GO 106881
106881: DISABLE
106882: LD_INT 0
106884: PPUSH
106885: PPUSH
106886: PPUSH
106887: PPUSH
106888: PPUSH
106889: PPUSH
106890: PPUSH
106891: PPUSH
106892: PPUSH
// begin enable ;
106893: ENABLE
// list := PrepareArray ( warehouseGatheringPoints ) ;
106894: LD_ADDR_VAR 0 3
106898: PUSH
106899: LD_EXP 134
106903: PPUSH
106904: CALL 61091 0 1
106908: ST_TO_ADDR
// if not list then
106909: LD_VAR 0 3
106913: NOT
106914: IFFALSE 106918
// exit ;
106916: GO 107562
// for i := 1 to list do
106918: LD_ADDR_VAR 0 1
106922: PUSH
106923: DOUBLE
106924: LD_INT 1
106926: DEC
106927: ST_TO_ADDR
106928: LD_VAR 0 3
106932: PUSH
106933: FOR_TO
106934: IFFALSE 107560
// begin depot := list [ i ] [ 2 ] ;
106936: LD_ADDR_VAR 0 8
106940: PUSH
106941: LD_VAR 0 3
106945: PUSH
106946: LD_VAR 0 1
106950: ARRAY
106951: PUSH
106952: LD_INT 2
106954: ARRAY
106955: ST_TO_ADDR
// side := list [ i ] [ 1 ] ;
106956: LD_ADDR_VAR 0 5
106960: PUSH
106961: LD_VAR 0 3
106965: PUSH
106966: LD_VAR 0 1
106970: ARRAY
106971: PUSH
106972: LD_INT 1
106974: ARRAY
106975: ST_TO_ADDR
// if IsDead ( depot ) or side <> GetSide ( depot ) then
106976: LD_VAR 0 8
106980: PPUSH
106981: CALL_OW 301
106985: PUSH
106986: LD_VAR 0 5
106990: PUSH
106991: LD_VAR 0 8
106995: PPUSH
106996: CALL_OW 255
107000: NONEQUAL
107001: OR
107002: IFFALSE 107031
// begin warehouseGatheringPoints := Replace ( warehouseGatheringPoints , depot , 0 ) ;
107004: LD_ADDR_EXP 134
107008: PUSH
107009: LD_EXP 134
107013: PPUSH
107014: LD_VAR 0 8
107018: PPUSH
107019: LD_INT 0
107021: PPUSH
107022: CALL_OW 1
107026: ST_TO_ADDR
// exit ;
107027: POP
107028: POP
107029: GO 107562
// end ; x := list [ i ] [ 3 ] ;
107031: LD_ADDR_VAR 0 6
107035: PUSH
107036: LD_VAR 0 3
107040: PUSH
107041: LD_VAR 0 1
107045: ARRAY
107046: PUSH
107047: LD_INT 3
107049: ARRAY
107050: ST_TO_ADDR
// y := list [ i ] [ 4 ] ;
107051: LD_ADDR_VAR 0 7
107055: PUSH
107056: LD_VAR 0 3
107060: PUSH
107061: LD_VAR 0 1
107065: ARRAY
107066: PUSH
107067: LD_INT 4
107069: ARRAY
107070: ST_TO_ADDR
// cratesNearbyPoint := GetCratesNearbyXY ( x , y , 16 ) ;
107071: LD_ADDR_VAR 0 9
107075: PUSH
107076: LD_VAR 0 6
107080: PPUSH
107081: LD_VAR 0 7
107085: PPUSH
107086: LD_INT 16
107088: PPUSH
107089: CALL 59679 0 3
107093: ST_TO_ADDR
// if not cratesNearbyPoint then
107094: LD_VAR 0 9
107098: NOT
107099: IFFALSE 107105
// exit ;
107101: POP
107102: POP
107103: GO 107562
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_hastask ] ] , [ f_dist , depot , 6 ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) union UnitFilter ( UnitsInside ( depot ) , [ [ f_not , [ f_hastask ] ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) ;
107105: LD_ADDR_VAR 0 4
107109: PUSH
107110: LD_INT 22
107112: PUSH
107113: LD_VAR 0 5
107117: PUSH
107118: EMPTY
107119: LIST
107120: LIST
107121: PUSH
107122: LD_INT 3
107124: PUSH
107125: LD_INT 60
107127: PUSH
107128: EMPTY
107129: LIST
107130: PUSH
107131: EMPTY
107132: LIST
107133: LIST
107134: PUSH
107135: LD_INT 91
107137: PUSH
107138: LD_VAR 0 8
107142: PUSH
107143: LD_INT 6
107145: PUSH
107146: EMPTY
107147: LIST
107148: LIST
107149: LIST
107150: PUSH
107151: LD_INT 2
107153: PUSH
107154: LD_INT 25
107156: PUSH
107157: LD_INT 2
107159: PUSH
107160: EMPTY
107161: LIST
107162: LIST
107163: PUSH
107164: LD_INT 25
107166: PUSH
107167: LD_INT 16
107169: PUSH
107170: EMPTY
107171: LIST
107172: LIST
107173: PUSH
107174: EMPTY
107175: LIST
107176: LIST
107177: LIST
107178: PUSH
107179: EMPTY
107180: LIST
107181: LIST
107182: LIST
107183: LIST
107184: PPUSH
107185: CALL_OW 69
107189: PUSH
107190: LD_VAR 0 8
107194: PPUSH
107195: CALL_OW 313
107199: PPUSH
107200: LD_INT 3
107202: PUSH
107203: LD_INT 60
107205: PUSH
107206: EMPTY
107207: LIST
107208: PUSH
107209: EMPTY
107210: LIST
107211: LIST
107212: PUSH
107213: LD_INT 2
107215: PUSH
107216: LD_INT 25
107218: PUSH
107219: LD_INT 2
107221: PUSH
107222: EMPTY
107223: LIST
107224: LIST
107225: PUSH
107226: LD_INT 25
107228: PUSH
107229: LD_INT 16
107231: PUSH
107232: EMPTY
107233: LIST
107234: LIST
107235: PUSH
107236: EMPTY
107237: LIST
107238: LIST
107239: LIST
107240: PUSH
107241: EMPTY
107242: LIST
107243: LIST
107244: PPUSH
107245: CALL_OW 72
107249: UNION
107250: ST_TO_ADDR
// if tmp then
107251: LD_VAR 0 4
107255: IFFALSE 107335
// begin tmp := ShrinkArray ( tmp , 3 ) ;
107257: LD_ADDR_VAR 0 4
107261: PUSH
107262: LD_VAR 0 4
107266: PPUSH
107267: LD_INT 3
107269: PPUSH
107270: CALL 57648 0 2
107274: ST_TO_ADDR
// for j in tmp do
107275: LD_ADDR_VAR 0 2
107279: PUSH
107280: LD_VAR 0 4
107284: PUSH
107285: FOR_IN
107286: IFFALSE 107329
// begin if IsInUnit ( j ) then
107288: LD_VAR 0 2
107292: PPUSH
107293: CALL_OW 310
107297: IFFALSE 107308
// ComExit ( j ) ;
107299: LD_VAR 0 2
107303: PPUSH
107304: CALL 57731 0 1
// AddComCollect ( j , x , y ) ;
107308: LD_VAR 0 2
107312: PPUSH
107313: LD_VAR 0 6
107317: PPUSH
107318: LD_VAR 0 7
107322: PPUSH
107323: CALL_OW 177
// end ;
107327: GO 107285
107329: POP
107330: POP
// exit ;
107331: POP
107332: POP
107333: GO 107562
// end ; tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_dist , depot , 8 ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ] ) ;
107335: LD_ADDR_VAR 0 4
107339: PUSH
107340: LD_INT 22
107342: PUSH
107343: LD_VAR 0 5
107347: PUSH
107348: EMPTY
107349: LIST
107350: LIST
107351: PUSH
107352: LD_INT 91
107354: PUSH
107355: LD_VAR 0 8
107359: PUSH
107360: LD_INT 8
107362: PUSH
107363: EMPTY
107364: LIST
107365: LIST
107366: LIST
107367: PUSH
107368: LD_INT 2
107370: PUSH
107371: LD_INT 34
107373: PUSH
107374: LD_INT 12
107376: PUSH
107377: EMPTY
107378: LIST
107379: LIST
107380: PUSH
107381: LD_INT 34
107383: PUSH
107384: LD_INT 51
107386: PUSH
107387: EMPTY
107388: LIST
107389: LIST
107390: PUSH
107391: LD_INT 34
107393: PUSH
107394: LD_INT 32
107396: PUSH
107397: EMPTY
107398: LIST
107399: LIST
107400: PUSH
107401: LD_INT 34
107403: PUSH
107404: LD_INT 89
107406: PUSH
107407: EMPTY
107408: LIST
107409: LIST
107410: PUSH
107411: EMPTY
107412: LIST
107413: LIST
107414: LIST
107415: LIST
107416: LIST
107417: PUSH
107418: EMPTY
107419: LIST
107420: LIST
107421: LIST
107422: PPUSH
107423: CALL_OW 69
107427: ST_TO_ADDR
// if tmp then
107428: LD_VAR 0 4
107432: IFFALSE 107558
// begin for j in tmp do
107434: LD_ADDR_VAR 0 2
107438: PUSH
107439: LD_VAR 0 4
107443: PUSH
107444: FOR_IN
107445: IFFALSE 107556
// if ( GetEngine ( j ) = engine_siberite or GetFuel ( j ) > 20 ) and not HasTask ( j ) and ( GetControl ( j ) <> control_manual or IsDrivenBy ( j ) ) then
107447: LD_VAR 0 2
107451: PPUSH
107452: CALL_OW 262
107456: PUSH
107457: LD_INT 3
107459: EQUAL
107460: PUSH
107461: LD_VAR 0 2
107465: PPUSH
107466: CALL_OW 261
107470: PUSH
107471: LD_INT 20
107473: GREATER
107474: OR
107475: PUSH
107476: LD_VAR 0 2
107480: PPUSH
107481: CALL_OW 314
107485: NOT
107486: AND
107487: PUSH
107488: LD_VAR 0 2
107492: PPUSH
107493: CALL_OW 263
107497: PUSH
107498: LD_INT 1
107500: NONEQUAL
107501: PUSH
107502: LD_VAR 0 2
107506: PPUSH
107507: CALL_OW 311
107511: OR
107512: AND
107513: IFFALSE 107554
// begin ComCollect ( j , x , y ) ;
107515: LD_VAR 0 2
107519: PPUSH
107520: LD_VAR 0 6
107524: PPUSH
107525: LD_VAR 0 7
107529: PPUSH
107530: CALL_OW 117
// AddComMoveUnit ( j , depot ) ;
107534: LD_VAR 0 2
107538: PPUSH
107539: LD_VAR 0 8
107543: PPUSH
107544: CALL_OW 172
// exit ;
107548: POP
107549: POP
107550: POP
107551: POP
107552: GO 107562
// end ;
107554: GO 107444
107556: POP
107557: POP
// end ; end ;
107558: GO 106933
107560: POP
107561: POP
// end ; end_of_file
107562: PPOPN 9
107564: END
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
107565: LD_INT 0
107567: PPUSH
107568: PPUSH
107569: PPUSH
107570: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
107571: LD_VAR 0 1
107575: PPUSH
107576: CALL_OW 264
107580: PUSH
107581: LD_INT 91
107583: EQUAL
107584: IFFALSE 107656
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
107586: LD_INT 68
107588: PPUSH
107589: LD_VAR 0 1
107593: PPUSH
107594: CALL_OW 255
107598: PPUSH
107599: CALL_OW 321
107603: PUSH
107604: LD_INT 2
107606: EQUAL
107607: IFFALSE 107619
// eff := 70 else
107609: LD_ADDR_VAR 0 4
107613: PUSH
107614: LD_INT 70
107616: ST_TO_ADDR
107617: GO 107627
// eff := 30 ;
107619: LD_ADDR_VAR 0 4
107623: PUSH
107624: LD_INT 30
107626: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
107627: LD_VAR 0 1
107631: PPUSH
107632: CALL_OW 250
107636: PPUSH
107637: LD_VAR 0 1
107641: PPUSH
107642: CALL_OW 251
107646: PPUSH
107647: LD_VAR 0 4
107651: PPUSH
107652: CALL_OW 495
// end ; end ;
107656: LD_VAR 0 2
107660: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
107661: LD_INT 0
107663: PPUSH
// end ;
107664: LD_VAR 0 4
107668: RET
// export function SOS_Command ( cmd ) ; begin
107669: LD_INT 0
107671: PPUSH
// end ;
107672: LD_VAR 0 2
107676: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
107677: LD_INT 0
107679: PPUSH
// end ;
107680: LD_VAR 0 6
107684: RET
// export function SOS_VehicleConstructed ( vehicle , factory ) ; var driver ; begin
107685: LD_INT 0
107687: PPUSH
107688: PPUSH
// if not vehicle or not factory then
107689: LD_VAR 0 1
107693: NOT
107694: PUSH
107695: LD_VAR 0 2
107699: NOT
107700: OR
107701: IFFALSE 107705
// exit ;
107703: GO 107936
// if factoryWaypoints >= factory then
107705: LD_EXP 133
107709: PUSH
107710: LD_VAR 0 2
107714: GREATEREQUAL
107715: IFFALSE 107936
// if factoryWaypoints [ factory ] then
107717: LD_EXP 133
107721: PUSH
107722: LD_VAR 0 2
107726: ARRAY
107727: IFFALSE 107936
// begin if GetControl ( vehicle ) = control_manual then
107729: LD_VAR 0 1
107733: PPUSH
107734: CALL_OW 263
107738: PUSH
107739: LD_INT 1
107741: EQUAL
107742: IFFALSE 107823
// begin driver := IsDrivenBy ( vehicle ) ;
107744: LD_ADDR_VAR 0 4
107748: PUSH
107749: LD_VAR 0 1
107753: PPUSH
107754: CALL_OW 311
107758: ST_TO_ADDR
// AddComMoveXY ( driver , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
107759: LD_VAR 0 4
107763: PPUSH
107764: LD_EXP 133
107768: PUSH
107769: LD_VAR 0 2
107773: ARRAY
107774: PUSH
107775: LD_INT 3
107777: ARRAY
107778: PPUSH
107779: LD_EXP 133
107783: PUSH
107784: LD_VAR 0 2
107788: ARRAY
107789: PUSH
107790: LD_INT 4
107792: ARRAY
107793: PPUSH
107794: CALL_OW 171
// AddComExitVehicle ( driver ) ;
107798: LD_VAR 0 4
107802: PPUSH
107803: CALL_OW 181
// AddComEnterUnit ( driver , factory ) ;
107807: LD_VAR 0 4
107811: PPUSH
107812: LD_VAR 0 2
107816: PPUSH
107817: CALL_OW 180
// end else
107821: GO 107936
// if GetControl ( vehicle ) = control_remote then
107823: LD_VAR 0 1
107827: PPUSH
107828: CALL_OW 263
107832: PUSH
107833: LD_INT 2
107835: EQUAL
107836: IFFALSE 107897
// begin wait ( 0 0$2 ) ;
107838: LD_INT 70
107840: PPUSH
107841: CALL_OW 67
// if Connect ( vehicle ) then
107845: LD_VAR 0 1
107849: PPUSH
107850: CALL 27990 0 1
107854: IFFALSE 107895
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
107856: LD_VAR 0 1
107860: PPUSH
107861: LD_EXP 133
107865: PUSH
107866: LD_VAR 0 2
107870: ARRAY
107871: PUSH
107872: LD_INT 3
107874: ARRAY
107875: PPUSH
107876: LD_EXP 133
107880: PUSH
107881: LD_VAR 0 2
107885: ARRAY
107886: PUSH
107887: LD_INT 4
107889: ARRAY
107890: PPUSH
107891: CALL_OW 171
// end else
107895: GO 107936
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
107897: LD_VAR 0 1
107901: PPUSH
107902: LD_EXP 133
107906: PUSH
107907: LD_VAR 0 2
107911: ARRAY
107912: PUSH
107913: LD_INT 3
107915: ARRAY
107916: PPUSH
107917: LD_EXP 133
107921: PUSH
107922: LD_VAR 0 2
107926: ARRAY
107927: PUSH
107928: LD_INT 4
107930: ARRAY
107931: PPUSH
107932: CALL_OW 171
// end ; end ;
107936: LD_VAR 0 3
107940: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
107941: LD_INT 0
107943: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
107944: LD_VAR 0 1
107948: PUSH
107949: LD_INT 250
107951: EQUAL
107952: PUSH
107953: LD_VAR 0 2
107957: PPUSH
107958: CALL_OW 264
107962: PUSH
107963: LD_INT 81
107965: EQUAL
107966: AND
107967: IFFALSE 107988
// MinerPlaceMine ( unit , x , y ) ;
107969: LD_VAR 0 2
107973: PPUSH
107974: LD_VAR 0 4
107978: PPUSH
107979: LD_VAR 0 5
107983: PPUSH
107984: CALL 110373 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
107988: LD_VAR 0 1
107992: PUSH
107993: LD_INT 251
107995: EQUAL
107996: PUSH
107997: LD_VAR 0 2
108001: PPUSH
108002: CALL_OW 264
108006: PUSH
108007: LD_INT 81
108009: EQUAL
108010: AND
108011: IFFALSE 108032
// MinerDetonateMine ( unit , x , y ) ;
108013: LD_VAR 0 2
108017: PPUSH
108018: LD_VAR 0 4
108022: PPUSH
108023: LD_VAR 0 5
108027: PPUSH
108028: CALL 110648 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
108032: LD_VAR 0 1
108036: PUSH
108037: LD_INT 252
108039: EQUAL
108040: PUSH
108041: LD_VAR 0 2
108045: PPUSH
108046: CALL_OW 264
108050: PUSH
108051: LD_INT 81
108053: EQUAL
108054: AND
108055: IFFALSE 108076
// MinerCreateMinefield ( unit , x , y ) ;
108057: LD_VAR 0 2
108061: PPUSH
108062: LD_VAR 0 4
108066: PPUSH
108067: LD_VAR 0 5
108071: PPUSH
108072: CALL 111065 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
108076: LD_VAR 0 1
108080: PUSH
108081: LD_INT 253
108083: EQUAL
108084: PUSH
108085: LD_VAR 0 2
108089: PPUSH
108090: CALL_OW 257
108094: PUSH
108095: LD_INT 5
108097: EQUAL
108098: AND
108099: IFFALSE 108120
// ComBinocular ( unit , x , y ) ;
108101: LD_VAR 0 2
108105: PPUSH
108106: LD_VAR 0 4
108110: PPUSH
108111: LD_VAR 0 5
108115: PPUSH
108116: CALL 111434 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
108120: LD_VAR 0 1
108124: PUSH
108125: LD_INT 254
108127: EQUAL
108128: PUSH
108129: LD_VAR 0 2
108133: PPUSH
108134: CALL_OW 264
108138: PUSH
108139: LD_INT 99
108141: EQUAL
108142: AND
108143: PUSH
108144: LD_VAR 0 3
108148: PPUSH
108149: CALL_OW 263
108153: PUSH
108154: LD_INT 3
108156: EQUAL
108157: AND
108158: IFFALSE 108174
// HackDestroyVehicle ( unit , selectedUnit ) ;
108160: LD_VAR 0 2
108164: PPUSH
108165: LD_VAR 0 3
108169: PPUSH
108170: CALL 109737 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
108174: LD_VAR 0 1
108178: PUSH
108179: LD_INT 255
108181: EQUAL
108182: PUSH
108183: LD_VAR 0 2
108187: PPUSH
108188: CALL_OW 264
108192: PUSH
108193: LD_INT 14
108195: PUSH
108196: LD_INT 53
108198: PUSH
108199: EMPTY
108200: LIST
108201: LIST
108202: IN
108203: AND
108204: PUSH
108205: LD_VAR 0 4
108209: PPUSH
108210: LD_VAR 0 5
108214: PPUSH
108215: CALL_OW 488
108219: AND
108220: IFFALSE 108244
// CutTreeXYR ( unit , x , y , 12 ) ;
108222: LD_VAR 0 2
108226: PPUSH
108227: LD_VAR 0 4
108231: PPUSH
108232: LD_VAR 0 5
108236: PPUSH
108237: LD_INT 12
108239: PPUSH
108240: CALL 108307 0 4
// if cmd = 256 then
108244: LD_VAR 0 1
108248: PUSH
108249: LD_INT 256
108251: EQUAL
108252: IFFALSE 108273
// SetFactoryWaypoint ( unit , x , y ) ;
108254: LD_VAR 0 2
108258: PPUSH
108259: LD_VAR 0 4
108263: PPUSH
108264: LD_VAR 0 5
108268: PPUSH
108269: CALL 106254 0 3
// if cmd = 257 then
108273: LD_VAR 0 1
108277: PUSH
108278: LD_INT 257
108280: EQUAL
108281: IFFALSE 108302
// SetWarehouseGatheringPoint ( unit , x , y ) ;
108283: LD_VAR 0 2
108287: PPUSH
108288: LD_VAR 0 4
108292: PPUSH
108293: LD_VAR 0 5
108297: PPUSH
108298: CALL 106616 0 3
// end ;
108302: LD_VAR 0 6
108306: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
108307: LD_INT 0
108309: PPUSH
108310: PPUSH
108311: PPUSH
108312: PPUSH
108313: PPUSH
108314: PPUSH
108315: PPUSH
108316: PPUSH
108317: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
108318: LD_VAR 0 1
108322: NOT
108323: PUSH
108324: LD_VAR 0 2
108328: PPUSH
108329: LD_VAR 0 3
108333: PPUSH
108334: CALL_OW 488
108338: NOT
108339: OR
108340: PUSH
108341: LD_VAR 0 4
108345: NOT
108346: OR
108347: IFFALSE 108351
// exit ;
108349: GO 108691
// list := [ ] ;
108351: LD_ADDR_VAR 0 13
108355: PUSH
108356: EMPTY
108357: ST_TO_ADDR
// if x - r < 0 then
108358: LD_VAR 0 2
108362: PUSH
108363: LD_VAR 0 4
108367: MINUS
108368: PUSH
108369: LD_INT 0
108371: LESS
108372: IFFALSE 108384
// min_x := 0 else
108374: LD_ADDR_VAR 0 7
108378: PUSH
108379: LD_INT 0
108381: ST_TO_ADDR
108382: GO 108400
// min_x := x - r ;
108384: LD_ADDR_VAR 0 7
108388: PUSH
108389: LD_VAR 0 2
108393: PUSH
108394: LD_VAR 0 4
108398: MINUS
108399: ST_TO_ADDR
// if y - r < 0 then
108400: LD_VAR 0 3
108404: PUSH
108405: LD_VAR 0 4
108409: MINUS
108410: PUSH
108411: LD_INT 0
108413: LESS
108414: IFFALSE 108426
// min_y := 0 else
108416: LD_ADDR_VAR 0 8
108420: PUSH
108421: LD_INT 0
108423: ST_TO_ADDR
108424: GO 108442
// min_y := y - r ;
108426: LD_ADDR_VAR 0 8
108430: PUSH
108431: LD_VAR 0 3
108435: PUSH
108436: LD_VAR 0 4
108440: MINUS
108441: ST_TO_ADDR
// max_x := x + r ;
108442: LD_ADDR_VAR 0 9
108446: PUSH
108447: LD_VAR 0 2
108451: PUSH
108452: LD_VAR 0 4
108456: PLUS
108457: ST_TO_ADDR
// max_y := y + r ;
108458: LD_ADDR_VAR 0 10
108462: PUSH
108463: LD_VAR 0 3
108467: PUSH
108468: LD_VAR 0 4
108472: PLUS
108473: ST_TO_ADDR
// for _x = min_x to max_x do
108474: LD_ADDR_VAR 0 11
108478: PUSH
108479: DOUBLE
108480: LD_VAR 0 7
108484: DEC
108485: ST_TO_ADDR
108486: LD_VAR 0 9
108490: PUSH
108491: FOR_TO
108492: IFFALSE 108609
// for _y = min_y to max_y do
108494: LD_ADDR_VAR 0 12
108498: PUSH
108499: DOUBLE
108500: LD_VAR 0 8
108504: DEC
108505: ST_TO_ADDR
108506: LD_VAR 0 10
108510: PUSH
108511: FOR_TO
108512: IFFALSE 108605
// begin if not ValidHex ( _x , _y ) then
108514: LD_VAR 0 11
108518: PPUSH
108519: LD_VAR 0 12
108523: PPUSH
108524: CALL_OW 488
108528: NOT
108529: IFFALSE 108533
// continue ;
108531: GO 108511
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
108533: LD_VAR 0 11
108537: PPUSH
108538: LD_VAR 0 12
108542: PPUSH
108543: CALL_OW 351
108547: PUSH
108548: LD_VAR 0 11
108552: PPUSH
108553: LD_VAR 0 12
108557: PPUSH
108558: CALL_OW 554
108562: AND
108563: IFFALSE 108603
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
108565: LD_ADDR_VAR 0 13
108569: PUSH
108570: LD_VAR 0 13
108574: PPUSH
108575: LD_VAR 0 13
108579: PUSH
108580: LD_INT 1
108582: PLUS
108583: PPUSH
108584: LD_VAR 0 11
108588: PUSH
108589: LD_VAR 0 12
108593: PUSH
108594: EMPTY
108595: LIST
108596: LIST
108597: PPUSH
108598: CALL_OW 2
108602: ST_TO_ADDR
// end ;
108603: GO 108511
108605: POP
108606: POP
108607: GO 108491
108609: POP
108610: POP
// if not list then
108611: LD_VAR 0 13
108615: NOT
108616: IFFALSE 108620
// exit ;
108618: GO 108691
// for i in list do
108620: LD_ADDR_VAR 0 6
108624: PUSH
108625: LD_VAR 0 13
108629: PUSH
108630: FOR_IN
108631: IFFALSE 108689
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
108633: LD_VAR 0 1
108637: PPUSH
108638: LD_STRING M
108640: PUSH
108641: LD_VAR 0 6
108645: PUSH
108646: LD_INT 1
108648: ARRAY
108649: PUSH
108650: LD_VAR 0 6
108654: PUSH
108655: LD_INT 2
108657: ARRAY
108658: PUSH
108659: LD_INT 0
108661: PUSH
108662: LD_INT 0
108664: PUSH
108665: LD_INT 0
108667: PUSH
108668: LD_INT 0
108670: PUSH
108671: EMPTY
108672: LIST
108673: LIST
108674: LIST
108675: LIST
108676: LIST
108677: LIST
108678: LIST
108679: PUSH
108680: EMPTY
108681: LIST
108682: PPUSH
108683: CALL_OW 447
108687: GO 108630
108689: POP
108690: POP
// end ;
108691: LD_VAR 0 5
108695: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
108696: LD_EXP 136
108700: NOT
108701: IFFALSE 108751
108703: GO 108705
108705: DISABLE
// begin initHack := true ;
108706: LD_ADDR_EXP 136
108710: PUSH
108711: LD_INT 1
108713: ST_TO_ADDR
// hackTanks := [ ] ;
108714: LD_ADDR_EXP 137
108718: PUSH
108719: EMPTY
108720: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
108721: LD_ADDR_EXP 138
108725: PUSH
108726: EMPTY
108727: ST_TO_ADDR
// hackLimit := 3 ;
108728: LD_ADDR_EXP 139
108732: PUSH
108733: LD_INT 3
108735: ST_TO_ADDR
// hackDist := 12 ;
108736: LD_ADDR_EXP 140
108740: PUSH
108741: LD_INT 12
108743: ST_TO_ADDR
// hackCounter := [ ] ;
108744: LD_ADDR_EXP 141
108748: PUSH
108749: EMPTY
108750: ST_TO_ADDR
// end ;
108751: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
108752: LD_EXP 136
108756: PUSH
108757: LD_INT 34
108759: PUSH
108760: LD_INT 99
108762: PUSH
108763: EMPTY
108764: LIST
108765: LIST
108766: PPUSH
108767: CALL_OW 69
108771: AND
108772: IFFALSE 109025
108774: GO 108776
108776: DISABLE
108777: LD_INT 0
108779: PPUSH
108780: PPUSH
// begin enable ;
108781: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
108782: LD_ADDR_VAR 0 1
108786: PUSH
108787: LD_INT 34
108789: PUSH
108790: LD_INT 99
108792: PUSH
108793: EMPTY
108794: LIST
108795: LIST
108796: PPUSH
108797: CALL_OW 69
108801: PUSH
108802: FOR_IN
108803: IFFALSE 109023
// begin if not i in hackTanks then
108805: LD_VAR 0 1
108809: PUSH
108810: LD_EXP 137
108814: IN
108815: NOT
108816: IFFALSE 108899
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
108818: LD_ADDR_EXP 137
108822: PUSH
108823: LD_EXP 137
108827: PPUSH
108828: LD_EXP 137
108832: PUSH
108833: LD_INT 1
108835: PLUS
108836: PPUSH
108837: LD_VAR 0 1
108841: PPUSH
108842: CALL_OW 1
108846: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
108847: LD_ADDR_EXP 138
108851: PUSH
108852: LD_EXP 138
108856: PPUSH
108857: LD_EXP 138
108861: PUSH
108862: LD_INT 1
108864: PLUS
108865: PPUSH
108866: EMPTY
108867: PPUSH
108868: CALL_OW 1
108872: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
108873: LD_ADDR_EXP 141
108877: PUSH
108878: LD_EXP 141
108882: PPUSH
108883: LD_EXP 141
108887: PUSH
108888: LD_INT 1
108890: PLUS
108891: PPUSH
108892: EMPTY
108893: PPUSH
108894: CALL_OW 1
108898: ST_TO_ADDR
// end ; if not IsOk ( i ) then
108899: LD_VAR 0 1
108903: PPUSH
108904: CALL_OW 302
108908: NOT
108909: IFFALSE 108922
// begin HackUnlinkAll ( i ) ;
108911: LD_VAR 0 1
108915: PPUSH
108916: CALL 109028 0 1
// continue ;
108920: GO 108802
// end ; HackCheckCapturedStatus ( i ) ;
108922: LD_VAR 0 1
108926: PPUSH
108927: CALL 109471 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
108931: LD_ADDR_VAR 0 2
108935: PUSH
108936: LD_INT 81
108938: PUSH
108939: LD_VAR 0 1
108943: PPUSH
108944: CALL_OW 255
108948: PUSH
108949: EMPTY
108950: LIST
108951: LIST
108952: PUSH
108953: LD_INT 33
108955: PUSH
108956: LD_INT 3
108958: PUSH
108959: EMPTY
108960: LIST
108961: LIST
108962: PUSH
108963: LD_INT 91
108965: PUSH
108966: LD_VAR 0 1
108970: PUSH
108971: LD_EXP 140
108975: PUSH
108976: EMPTY
108977: LIST
108978: LIST
108979: LIST
108980: PUSH
108981: LD_INT 50
108983: PUSH
108984: EMPTY
108985: LIST
108986: PUSH
108987: EMPTY
108988: LIST
108989: LIST
108990: LIST
108991: LIST
108992: PPUSH
108993: CALL_OW 69
108997: ST_TO_ADDR
// if not tmp then
108998: LD_VAR 0 2
109002: NOT
109003: IFFALSE 109007
// continue ;
109005: GO 108802
// HackLink ( i , tmp ) ;
109007: LD_VAR 0 1
109011: PPUSH
109012: LD_VAR 0 2
109016: PPUSH
109017: CALL 109164 0 2
// end ;
109021: GO 108802
109023: POP
109024: POP
// end ;
109025: PPOPN 2
109027: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
109028: LD_INT 0
109030: PPUSH
109031: PPUSH
109032: PPUSH
// if not hack in hackTanks then
109033: LD_VAR 0 1
109037: PUSH
109038: LD_EXP 137
109042: IN
109043: NOT
109044: IFFALSE 109048
// exit ;
109046: GO 109159
// index := GetElementIndex ( hackTanks , hack ) ;
109048: LD_ADDR_VAR 0 4
109052: PUSH
109053: LD_EXP 137
109057: PPUSH
109058: LD_VAR 0 1
109062: PPUSH
109063: CALL 24806 0 2
109067: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
109068: LD_EXP 138
109072: PUSH
109073: LD_VAR 0 4
109077: ARRAY
109078: IFFALSE 109159
// begin for i in hackTanksCaptured [ index ] do
109080: LD_ADDR_VAR 0 3
109084: PUSH
109085: LD_EXP 138
109089: PUSH
109090: LD_VAR 0 4
109094: ARRAY
109095: PUSH
109096: FOR_IN
109097: IFFALSE 109123
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
109099: LD_VAR 0 3
109103: PUSH
109104: LD_INT 1
109106: ARRAY
109107: PPUSH
109108: LD_VAR 0 3
109112: PUSH
109113: LD_INT 2
109115: ARRAY
109116: PPUSH
109117: CALL_OW 235
109121: GO 109096
109123: POP
109124: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
109125: LD_ADDR_EXP 138
109129: PUSH
109130: LD_EXP 138
109134: PPUSH
109135: LD_VAR 0 4
109139: PPUSH
109140: EMPTY
109141: PPUSH
109142: CALL_OW 1
109146: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
109147: LD_VAR 0 1
109151: PPUSH
109152: LD_INT 0
109154: PPUSH
109155: CALL_OW 505
// end ; end ;
109159: LD_VAR 0 2
109163: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
109164: LD_INT 0
109166: PPUSH
109167: PPUSH
109168: PPUSH
// if not hack in hackTanks or not vehicles then
109169: LD_VAR 0 1
109173: PUSH
109174: LD_EXP 137
109178: IN
109179: NOT
109180: PUSH
109181: LD_VAR 0 2
109185: NOT
109186: OR
109187: IFFALSE 109191
// exit ;
109189: GO 109466
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
109191: LD_ADDR_VAR 0 2
109195: PUSH
109196: LD_VAR 0 1
109200: PPUSH
109201: LD_VAR 0 2
109205: PPUSH
109206: LD_INT 1
109208: PPUSH
109209: LD_INT 1
109211: PPUSH
109212: CALL 25456 0 4
109216: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
109217: LD_ADDR_VAR 0 5
109221: PUSH
109222: LD_EXP 137
109226: PPUSH
109227: LD_VAR 0 1
109231: PPUSH
109232: CALL 24806 0 2
109236: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
109237: LD_EXP 138
109241: PUSH
109242: LD_VAR 0 5
109246: ARRAY
109247: PUSH
109248: LD_EXP 139
109252: LESS
109253: IFFALSE 109442
// begin for i := 1 to vehicles do
109255: LD_ADDR_VAR 0 4
109259: PUSH
109260: DOUBLE
109261: LD_INT 1
109263: DEC
109264: ST_TO_ADDR
109265: LD_VAR 0 2
109269: PUSH
109270: FOR_TO
109271: IFFALSE 109440
// begin if hackTanksCaptured [ index ] = hackLimit then
109273: LD_EXP 138
109277: PUSH
109278: LD_VAR 0 5
109282: ARRAY
109283: PUSH
109284: LD_EXP 139
109288: EQUAL
109289: IFFALSE 109293
// break ;
109291: GO 109440
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
109293: LD_ADDR_EXP 141
109297: PUSH
109298: LD_EXP 141
109302: PPUSH
109303: LD_VAR 0 5
109307: PPUSH
109308: LD_EXP 141
109312: PUSH
109313: LD_VAR 0 5
109317: ARRAY
109318: PUSH
109319: LD_INT 1
109321: PLUS
109322: PPUSH
109323: CALL_OW 1
109327: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
109328: LD_ADDR_EXP 138
109332: PUSH
109333: LD_EXP 138
109337: PPUSH
109338: LD_VAR 0 5
109342: PUSH
109343: LD_EXP 138
109347: PUSH
109348: LD_VAR 0 5
109352: ARRAY
109353: PUSH
109354: LD_INT 1
109356: PLUS
109357: PUSH
109358: EMPTY
109359: LIST
109360: LIST
109361: PPUSH
109362: LD_VAR 0 2
109366: PUSH
109367: LD_VAR 0 4
109371: ARRAY
109372: PUSH
109373: LD_VAR 0 2
109377: PUSH
109378: LD_VAR 0 4
109382: ARRAY
109383: PPUSH
109384: CALL_OW 255
109388: PUSH
109389: EMPTY
109390: LIST
109391: LIST
109392: PPUSH
109393: CALL 25021 0 3
109397: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
109398: LD_VAR 0 2
109402: PUSH
109403: LD_VAR 0 4
109407: ARRAY
109408: PPUSH
109409: LD_VAR 0 1
109413: PPUSH
109414: CALL_OW 255
109418: PPUSH
109419: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
109423: LD_VAR 0 2
109427: PUSH
109428: LD_VAR 0 4
109432: ARRAY
109433: PPUSH
109434: CALL_OW 141
// end ;
109438: GO 109270
109440: POP
109441: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
109442: LD_VAR 0 1
109446: PPUSH
109447: LD_EXP 138
109451: PUSH
109452: LD_VAR 0 5
109456: ARRAY
109457: PUSH
109458: LD_INT 0
109460: PLUS
109461: PPUSH
109462: CALL_OW 505
// end ;
109466: LD_VAR 0 3
109470: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
109471: LD_INT 0
109473: PPUSH
109474: PPUSH
109475: PPUSH
109476: PPUSH
// if not hack in hackTanks then
109477: LD_VAR 0 1
109481: PUSH
109482: LD_EXP 137
109486: IN
109487: NOT
109488: IFFALSE 109492
// exit ;
109490: GO 109732
// index := GetElementIndex ( hackTanks , hack ) ;
109492: LD_ADDR_VAR 0 4
109496: PUSH
109497: LD_EXP 137
109501: PPUSH
109502: LD_VAR 0 1
109506: PPUSH
109507: CALL 24806 0 2
109511: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
109512: LD_ADDR_VAR 0 3
109516: PUSH
109517: DOUBLE
109518: LD_EXP 138
109522: PUSH
109523: LD_VAR 0 4
109527: ARRAY
109528: INC
109529: ST_TO_ADDR
109530: LD_INT 1
109532: PUSH
109533: FOR_DOWNTO
109534: IFFALSE 109706
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
109536: LD_ADDR_VAR 0 5
109540: PUSH
109541: LD_EXP 138
109545: PUSH
109546: LD_VAR 0 4
109550: ARRAY
109551: PUSH
109552: LD_VAR 0 3
109556: ARRAY
109557: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
109558: LD_VAR 0 5
109562: PUSH
109563: LD_INT 1
109565: ARRAY
109566: PPUSH
109567: CALL_OW 302
109571: NOT
109572: PUSH
109573: LD_VAR 0 5
109577: PUSH
109578: LD_INT 1
109580: ARRAY
109581: PPUSH
109582: CALL_OW 255
109586: PUSH
109587: LD_VAR 0 1
109591: PPUSH
109592: CALL_OW 255
109596: NONEQUAL
109597: OR
109598: IFFALSE 109704
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
109600: LD_VAR 0 5
109604: PUSH
109605: LD_INT 1
109607: ARRAY
109608: PPUSH
109609: CALL_OW 305
109613: PUSH
109614: LD_VAR 0 5
109618: PUSH
109619: LD_INT 1
109621: ARRAY
109622: PPUSH
109623: CALL_OW 255
109627: PUSH
109628: LD_VAR 0 1
109632: PPUSH
109633: CALL_OW 255
109637: EQUAL
109638: AND
109639: IFFALSE 109663
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
109641: LD_VAR 0 5
109645: PUSH
109646: LD_INT 1
109648: ARRAY
109649: PPUSH
109650: LD_VAR 0 5
109654: PUSH
109655: LD_INT 2
109657: ARRAY
109658: PPUSH
109659: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
109663: LD_ADDR_EXP 138
109667: PUSH
109668: LD_EXP 138
109672: PPUSH
109673: LD_VAR 0 4
109677: PPUSH
109678: LD_EXP 138
109682: PUSH
109683: LD_VAR 0 4
109687: ARRAY
109688: PPUSH
109689: LD_VAR 0 3
109693: PPUSH
109694: CALL_OW 3
109698: PPUSH
109699: CALL_OW 1
109703: ST_TO_ADDR
// end ; end ;
109704: GO 109533
109706: POP
109707: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
109708: LD_VAR 0 1
109712: PPUSH
109713: LD_EXP 138
109717: PUSH
109718: LD_VAR 0 4
109722: ARRAY
109723: PUSH
109724: LD_INT 0
109726: PLUS
109727: PPUSH
109728: CALL_OW 505
// end ;
109732: LD_VAR 0 2
109736: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
109737: LD_INT 0
109739: PPUSH
109740: PPUSH
109741: PPUSH
109742: PPUSH
// if not hack in hackTanks then
109743: LD_VAR 0 1
109747: PUSH
109748: LD_EXP 137
109752: IN
109753: NOT
109754: IFFALSE 109758
// exit ;
109756: GO 109843
// index := GetElementIndex ( hackTanks , hack ) ;
109758: LD_ADDR_VAR 0 5
109762: PUSH
109763: LD_EXP 137
109767: PPUSH
109768: LD_VAR 0 1
109772: PPUSH
109773: CALL 24806 0 2
109777: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
109778: LD_ADDR_VAR 0 4
109782: PUSH
109783: DOUBLE
109784: LD_INT 1
109786: DEC
109787: ST_TO_ADDR
109788: LD_EXP 138
109792: PUSH
109793: LD_VAR 0 5
109797: ARRAY
109798: PUSH
109799: FOR_TO
109800: IFFALSE 109841
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
109802: LD_EXP 138
109806: PUSH
109807: LD_VAR 0 5
109811: ARRAY
109812: PUSH
109813: LD_VAR 0 4
109817: ARRAY
109818: PUSH
109819: LD_INT 1
109821: ARRAY
109822: PUSH
109823: LD_VAR 0 2
109827: EQUAL
109828: IFFALSE 109839
// KillUnit ( vehicle ) ;
109830: LD_VAR 0 2
109834: PPUSH
109835: CALL_OW 66
109839: GO 109799
109841: POP
109842: POP
// end ;
109843: LD_VAR 0 3
109847: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
109848: LD_EXP 142
109852: NOT
109853: IFFALSE 109888
109855: GO 109857
109857: DISABLE
// begin initMiner := true ;
109858: LD_ADDR_EXP 142
109862: PUSH
109863: LD_INT 1
109865: ST_TO_ADDR
// minersList := [ ] ;
109866: LD_ADDR_EXP 143
109870: PUSH
109871: EMPTY
109872: ST_TO_ADDR
// minerMinesList := [ ] ;
109873: LD_ADDR_EXP 144
109877: PUSH
109878: EMPTY
109879: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
109880: LD_ADDR_EXP 145
109884: PUSH
109885: LD_INT 5
109887: ST_TO_ADDR
// end ;
109888: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
109889: LD_EXP 142
109893: PUSH
109894: LD_INT 34
109896: PUSH
109897: LD_INT 81
109899: PUSH
109900: EMPTY
109901: LIST
109902: LIST
109903: PPUSH
109904: CALL_OW 69
109908: AND
109909: IFFALSE 110370
109911: GO 109913
109913: DISABLE
109914: LD_INT 0
109916: PPUSH
109917: PPUSH
109918: PPUSH
109919: PPUSH
// begin enable ;
109920: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
109921: LD_ADDR_VAR 0 1
109925: PUSH
109926: LD_INT 34
109928: PUSH
109929: LD_INT 81
109931: PUSH
109932: EMPTY
109933: LIST
109934: LIST
109935: PPUSH
109936: CALL_OW 69
109940: PUSH
109941: FOR_IN
109942: IFFALSE 110014
// begin if not i in minersList then
109944: LD_VAR 0 1
109948: PUSH
109949: LD_EXP 143
109953: IN
109954: NOT
109955: IFFALSE 110012
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
109957: LD_ADDR_EXP 143
109961: PUSH
109962: LD_EXP 143
109966: PPUSH
109967: LD_EXP 143
109971: PUSH
109972: LD_INT 1
109974: PLUS
109975: PPUSH
109976: LD_VAR 0 1
109980: PPUSH
109981: CALL_OW 1
109985: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
109986: LD_ADDR_EXP 144
109990: PUSH
109991: LD_EXP 144
109995: PPUSH
109996: LD_EXP 144
110000: PUSH
110001: LD_INT 1
110003: PLUS
110004: PPUSH
110005: EMPTY
110006: PPUSH
110007: CALL_OW 1
110011: ST_TO_ADDR
// end end ;
110012: GO 109941
110014: POP
110015: POP
// for i := minerMinesList downto 1 do
110016: LD_ADDR_VAR 0 1
110020: PUSH
110021: DOUBLE
110022: LD_EXP 144
110026: INC
110027: ST_TO_ADDR
110028: LD_INT 1
110030: PUSH
110031: FOR_DOWNTO
110032: IFFALSE 110368
// begin if IsLive ( minersList [ i ] ) then
110034: LD_EXP 143
110038: PUSH
110039: LD_VAR 0 1
110043: ARRAY
110044: PPUSH
110045: CALL_OW 300
110049: IFFALSE 110077
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
110051: LD_EXP 143
110055: PUSH
110056: LD_VAR 0 1
110060: ARRAY
110061: PPUSH
110062: LD_EXP 144
110066: PUSH
110067: LD_VAR 0 1
110071: ARRAY
110072: PPUSH
110073: CALL_OW 505
// if not minerMinesList [ i ] then
110077: LD_EXP 144
110081: PUSH
110082: LD_VAR 0 1
110086: ARRAY
110087: NOT
110088: IFFALSE 110092
// continue ;
110090: GO 110031
// for j := minerMinesList [ i ] downto 1 do
110092: LD_ADDR_VAR 0 2
110096: PUSH
110097: DOUBLE
110098: LD_EXP 144
110102: PUSH
110103: LD_VAR 0 1
110107: ARRAY
110108: INC
110109: ST_TO_ADDR
110110: LD_INT 1
110112: PUSH
110113: FOR_DOWNTO
110114: IFFALSE 110364
// begin side := GetSide ( minersList [ i ] ) ;
110116: LD_ADDR_VAR 0 3
110120: PUSH
110121: LD_EXP 143
110125: PUSH
110126: LD_VAR 0 1
110130: ARRAY
110131: PPUSH
110132: CALL_OW 255
110136: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
110137: LD_ADDR_VAR 0 4
110141: PUSH
110142: LD_EXP 144
110146: PUSH
110147: LD_VAR 0 1
110151: ARRAY
110152: PUSH
110153: LD_VAR 0 2
110157: ARRAY
110158: PUSH
110159: LD_INT 1
110161: ARRAY
110162: PPUSH
110163: LD_EXP 144
110167: PUSH
110168: LD_VAR 0 1
110172: ARRAY
110173: PUSH
110174: LD_VAR 0 2
110178: ARRAY
110179: PUSH
110180: LD_INT 2
110182: ARRAY
110183: PPUSH
110184: CALL_OW 428
110188: ST_TO_ADDR
// if not tmp then
110189: LD_VAR 0 4
110193: NOT
110194: IFFALSE 110198
// continue ;
110196: GO 110113
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
110198: LD_VAR 0 4
110202: PUSH
110203: LD_INT 81
110205: PUSH
110206: LD_VAR 0 3
110210: PUSH
110211: EMPTY
110212: LIST
110213: LIST
110214: PPUSH
110215: CALL_OW 69
110219: IN
110220: PUSH
110221: LD_EXP 144
110225: PUSH
110226: LD_VAR 0 1
110230: ARRAY
110231: PUSH
110232: LD_VAR 0 2
110236: ARRAY
110237: PUSH
110238: LD_INT 1
110240: ARRAY
110241: PPUSH
110242: LD_EXP 144
110246: PUSH
110247: LD_VAR 0 1
110251: ARRAY
110252: PUSH
110253: LD_VAR 0 2
110257: ARRAY
110258: PUSH
110259: LD_INT 2
110261: ARRAY
110262: PPUSH
110263: CALL_OW 458
110267: AND
110268: IFFALSE 110362
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
110270: LD_EXP 144
110274: PUSH
110275: LD_VAR 0 1
110279: ARRAY
110280: PUSH
110281: LD_VAR 0 2
110285: ARRAY
110286: PUSH
110287: LD_INT 1
110289: ARRAY
110290: PPUSH
110291: LD_EXP 144
110295: PUSH
110296: LD_VAR 0 1
110300: ARRAY
110301: PUSH
110302: LD_VAR 0 2
110306: ARRAY
110307: PUSH
110308: LD_INT 2
110310: ARRAY
110311: PPUSH
110312: LD_VAR 0 3
110316: PPUSH
110317: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
110321: LD_ADDR_EXP 144
110325: PUSH
110326: LD_EXP 144
110330: PPUSH
110331: LD_VAR 0 1
110335: PPUSH
110336: LD_EXP 144
110340: PUSH
110341: LD_VAR 0 1
110345: ARRAY
110346: PPUSH
110347: LD_VAR 0 2
110351: PPUSH
110352: CALL_OW 3
110356: PPUSH
110357: CALL_OW 1
110361: ST_TO_ADDR
// end ; end ;
110362: GO 110113
110364: POP
110365: POP
// end ;
110366: GO 110031
110368: POP
110369: POP
// end ;
110370: PPOPN 4
110372: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
110373: LD_INT 0
110375: PPUSH
110376: PPUSH
// result := false ;
110377: LD_ADDR_VAR 0 4
110381: PUSH
110382: LD_INT 0
110384: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
110385: LD_VAR 0 1
110389: PPUSH
110390: CALL_OW 264
110394: PUSH
110395: LD_INT 81
110397: EQUAL
110398: NOT
110399: IFFALSE 110403
// exit ;
110401: GO 110643
// index := GetElementIndex ( minersList , unit ) ;
110403: LD_ADDR_VAR 0 5
110407: PUSH
110408: LD_EXP 143
110412: PPUSH
110413: LD_VAR 0 1
110417: PPUSH
110418: CALL 24806 0 2
110422: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
110423: LD_EXP 144
110427: PUSH
110428: LD_VAR 0 5
110432: ARRAY
110433: PUSH
110434: LD_EXP 145
110438: GREATEREQUAL
110439: IFFALSE 110443
// exit ;
110441: GO 110643
// ComMoveXY ( unit , x , y ) ;
110443: LD_VAR 0 1
110447: PPUSH
110448: LD_VAR 0 2
110452: PPUSH
110453: LD_VAR 0 3
110457: PPUSH
110458: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
110462: LD_INT 35
110464: PPUSH
110465: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
110469: LD_VAR 0 1
110473: PPUSH
110474: LD_VAR 0 2
110478: PPUSH
110479: LD_VAR 0 3
110483: PPUSH
110484: CALL 56142 0 3
110488: NOT
110489: PUSH
110490: LD_VAR 0 1
110494: PPUSH
110495: CALL_OW 314
110499: AND
110500: IFFALSE 110504
// exit ;
110502: GO 110643
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
110504: LD_VAR 0 2
110508: PPUSH
110509: LD_VAR 0 3
110513: PPUSH
110514: CALL_OW 428
110518: PUSH
110519: LD_VAR 0 1
110523: EQUAL
110524: PUSH
110525: LD_VAR 0 1
110529: PPUSH
110530: CALL_OW 314
110534: NOT
110535: AND
110536: IFFALSE 110462
// PlaySoundXY ( x , y , PlantMine ) ;
110538: LD_VAR 0 2
110542: PPUSH
110543: LD_VAR 0 3
110547: PPUSH
110548: LD_STRING PlantMine
110550: PPUSH
110551: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
110555: LD_VAR 0 2
110559: PPUSH
110560: LD_VAR 0 3
110564: PPUSH
110565: LD_VAR 0 1
110569: PPUSH
110570: CALL_OW 255
110574: PPUSH
110575: LD_INT 0
110577: PPUSH
110578: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
110582: LD_ADDR_EXP 144
110586: PUSH
110587: LD_EXP 144
110591: PPUSH
110592: LD_VAR 0 5
110596: PUSH
110597: LD_EXP 144
110601: PUSH
110602: LD_VAR 0 5
110606: ARRAY
110607: PUSH
110608: LD_INT 1
110610: PLUS
110611: PUSH
110612: EMPTY
110613: LIST
110614: LIST
110615: PPUSH
110616: LD_VAR 0 2
110620: PUSH
110621: LD_VAR 0 3
110625: PUSH
110626: EMPTY
110627: LIST
110628: LIST
110629: PPUSH
110630: CALL 25021 0 3
110634: ST_TO_ADDR
// result := true ;
110635: LD_ADDR_VAR 0 4
110639: PUSH
110640: LD_INT 1
110642: ST_TO_ADDR
// end ;
110643: LD_VAR 0 4
110647: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
110648: LD_INT 0
110650: PPUSH
110651: PPUSH
110652: PPUSH
// if not unit in minersList then
110653: LD_VAR 0 1
110657: PUSH
110658: LD_EXP 143
110662: IN
110663: NOT
110664: IFFALSE 110668
// exit ;
110666: GO 111060
// index := GetElementIndex ( minersList , unit ) ;
110668: LD_ADDR_VAR 0 6
110672: PUSH
110673: LD_EXP 143
110677: PPUSH
110678: LD_VAR 0 1
110682: PPUSH
110683: CALL 24806 0 2
110687: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
110688: LD_ADDR_VAR 0 5
110692: PUSH
110693: DOUBLE
110694: LD_EXP 144
110698: PUSH
110699: LD_VAR 0 6
110703: ARRAY
110704: INC
110705: ST_TO_ADDR
110706: LD_INT 1
110708: PUSH
110709: FOR_DOWNTO
110710: IFFALSE 110871
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
110712: LD_EXP 144
110716: PUSH
110717: LD_VAR 0 6
110721: ARRAY
110722: PUSH
110723: LD_VAR 0 5
110727: ARRAY
110728: PUSH
110729: LD_INT 1
110731: ARRAY
110732: PUSH
110733: LD_VAR 0 2
110737: EQUAL
110738: PUSH
110739: LD_EXP 144
110743: PUSH
110744: LD_VAR 0 6
110748: ARRAY
110749: PUSH
110750: LD_VAR 0 5
110754: ARRAY
110755: PUSH
110756: LD_INT 2
110758: ARRAY
110759: PUSH
110760: LD_VAR 0 3
110764: EQUAL
110765: AND
110766: IFFALSE 110869
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
110768: LD_EXP 144
110772: PUSH
110773: LD_VAR 0 6
110777: ARRAY
110778: PUSH
110779: LD_VAR 0 5
110783: ARRAY
110784: PUSH
110785: LD_INT 1
110787: ARRAY
110788: PPUSH
110789: LD_EXP 144
110793: PUSH
110794: LD_VAR 0 6
110798: ARRAY
110799: PUSH
110800: LD_VAR 0 5
110804: ARRAY
110805: PUSH
110806: LD_INT 2
110808: ARRAY
110809: PPUSH
110810: LD_VAR 0 1
110814: PPUSH
110815: CALL_OW 255
110819: PPUSH
110820: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
110824: LD_ADDR_EXP 144
110828: PUSH
110829: LD_EXP 144
110833: PPUSH
110834: LD_VAR 0 6
110838: PPUSH
110839: LD_EXP 144
110843: PUSH
110844: LD_VAR 0 6
110848: ARRAY
110849: PPUSH
110850: LD_VAR 0 5
110854: PPUSH
110855: CALL_OW 3
110859: PPUSH
110860: CALL_OW 1
110864: ST_TO_ADDR
// exit ;
110865: POP
110866: POP
110867: GO 111060
// end ; end ;
110869: GO 110709
110871: POP
110872: POP
// for i := minerMinesList [ index ] downto 1 do
110873: LD_ADDR_VAR 0 5
110877: PUSH
110878: DOUBLE
110879: LD_EXP 144
110883: PUSH
110884: LD_VAR 0 6
110888: ARRAY
110889: INC
110890: ST_TO_ADDR
110891: LD_INT 1
110893: PUSH
110894: FOR_DOWNTO
110895: IFFALSE 111058
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
110897: LD_EXP 144
110901: PUSH
110902: LD_VAR 0 6
110906: ARRAY
110907: PUSH
110908: LD_VAR 0 5
110912: ARRAY
110913: PUSH
110914: LD_INT 1
110916: ARRAY
110917: PPUSH
110918: LD_EXP 144
110922: PUSH
110923: LD_VAR 0 6
110927: ARRAY
110928: PUSH
110929: LD_VAR 0 5
110933: ARRAY
110934: PUSH
110935: LD_INT 2
110937: ARRAY
110938: PPUSH
110939: LD_VAR 0 2
110943: PPUSH
110944: LD_VAR 0 3
110948: PPUSH
110949: CALL_OW 298
110953: PUSH
110954: LD_INT 6
110956: LESS
110957: IFFALSE 111056
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
110959: LD_EXP 144
110963: PUSH
110964: LD_VAR 0 6
110968: ARRAY
110969: PUSH
110970: LD_VAR 0 5
110974: ARRAY
110975: PUSH
110976: LD_INT 1
110978: ARRAY
110979: PPUSH
110980: LD_EXP 144
110984: PUSH
110985: LD_VAR 0 6
110989: ARRAY
110990: PUSH
110991: LD_VAR 0 5
110995: ARRAY
110996: PUSH
110997: LD_INT 2
110999: ARRAY
111000: PPUSH
111001: LD_VAR 0 1
111005: PPUSH
111006: CALL_OW 255
111010: PPUSH
111011: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
111015: LD_ADDR_EXP 144
111019: PUSH
111020: LD_EXP 144
111024: PPUSH
111025: LD_VAR 0 6
111029: PPUSH
111030: LD_EXP 144
111034: PUSH
111035: LD_VAR 0 6
111039: ARRAY
111040: PPUSH
111041: LD_VAR 0 5
111045: PPUSH
111046: CALL_OW 3
111050: PPUSH
111051: CALL_OW 1
111055: ST_TO_ADDR
// end ; end ;
111056: GO 110894
111058: POP
111059: POP
// end ;
111060: LD_VAR 0 4
111064: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
111065: LD_INT 0
111067: PPUSH
111068: PPUSH
111069: PPUSH
111070: PPUSH
111071: PPUSH
111072: PPUSH
111073: PPUSH
111074: PPUSH
111075: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
111076: LD_VAR 0 1
111080: PPUSH
111081: CALL_OW 264
111085: PUSH
111086: LD_INT 81
111088: EQUAL
111089: NOT
111090: PUSH
111091: LD_VAR 0 1
111095: PUSH
111096: LD_EXP 143
111100: IN
111101: NOT
111102: OR
111103: IFFALSE 111107
// exit ;
111105: GO 111429
// index := GetElementIndex ( minersList , unit ) ;
111107: LD_ADDR_VAR 0 6
111111: PUSH
111112: LD_EXP 143
111116: PPUSH
111117: LD_VAR 0 1
111121: PPUSH
111122: CALL 24806 0 2
111126: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
111127: LD_ADDR_VAR 0 8
111131: PUSH
111132: LD_EXP 145
111136: PUSH
111137: LD_EXP 144
111141: PUSH
111142: LD_VAR 0 6
111146: ARRAY
111147: MINUS
111148: ST_TO_ADDR
// if not minesFreeAmount then
111149: LD_VAR 0 8
111153: NOT
111154: IFFALSE 111158
// exit ;
111156: GO 111429
// tmp := [ ] ;
111158: LD_ADDR_VAR 0 7
111162: PUSH
111163: EMPTY
111164: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
111165: LD_ADDR_VAR 0 5
111169: PUSH
111170: DOUBLE
111171: LD_INT 1
111173: DEC
111174: ST_TO_ADDR
111175: LD_VAR 0 8
111179: PUSH
111180: FOR_TO
111181: IFFALSE 111376
// begin _d := rand ( 0 , 5 ) ;
111183: LD_ADDR_VAR 0 11
111187: PUSH
111188: LD_INT 0
111190: PPUSH
111191: LD_INT 5
111193: PPUSH
111194: CALL_OW 12
111198: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
111199: LD_ADDR_VAR 0 12
111203: PUSH
111204: LD_INT 2
111206: PPUSH
111207: LD_INT 6
111209: PPUSH
111210: CALL_OW 12
111214: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
111215: LD_ADDR_VAR 0 9
111219: PUSH
111220: LD_VAR 0 2
111224: PPUSH
111225: LD_VAR 0 11
111229: PPUSH
111230: LD_VAR 0 12
111234: PPUSH
111235: CALL_OW 272
111239: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
111240: LD_ADDR_VAR 0 10
111244: PUSH
111245: LD_VAR 0 3
111249: PPUSH
111250: LD_VAR 0 11
111254: PPUSH
111255: LD_VAR 0 12
111259: PPUSH
111260: CALL_OW 273
111264: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
111265: LD_VAR 0 9
111269: PPUSH
111270: LD_VAR 0 10
111274: PPUSH
111275: CALL_OW 488
111279: PUSH
111280: LD_VAR 0 9
111284: PUSH
111285: LD_VAR 0 10
111289: PUSH
111290: EMPTY
111291: LIST
111292: LIST
111293: PUSH
111294: LD_VAR 0 7
111298: IN
111299: NOT
111300: AND
111301: PUSH
111302: LD_VAR 0 9
111306: PPUSH
111307: LD_VAR 0 10
111311: PPUSH
111312: CALL_OW 458
111316: NOT
111317: AND
111318: IFFALSE 111360
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
111320: LD_ADDR_VAR 0 7
111324: PUSH
111325: LD_VAR 0 7
111329: PPUSH
111330: LD_VAR 0 7
111334: PUSH
111335: LD_INT 1
111337: PLUS
111338: PPUSH
111339: LD_VAR 0 9
111343: PUSH
111344: LD_VAR 0 10
111348: PUSH
111349: EMPTY
111350: LIST
111351: LIST
111352: PPUSH
111353: CALL_OW 1
111357: ST_TO_ADDR
111358: GO 111374
// i := i - 1 ;
111360: LD_ADDR_VAR 0 5
111364: PUSH
111365: LD_VAR 0 5
111369: PUSH
111370: LD_INT 1
111372: MINUS
111373: ST_TO_ADDR
// end ;
111374: GO 111180
111376: POP
111377: POP
// for i in tmp do
111378: LD_ADDR_VAR 0 5
111382: PUSH
111383: LD_VAR 0 7
111387: PUSH
111388: FOR_IN
111389: IFFALSE 111427
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
111391: LD_VAR 0 1
111395: PPUSH
111396: LD_VAR 0 5
111400: PUSH
111401: LD_INT 1
111403: ARRAY
111404: PPUSH
111405: LD_VAR 0 5
111409: PUSH
111410: LD_INT 2
111412: ARRAY
111413: PPUSH
111414: CALL 110373 0 3
111418: NOT
111419: IFFALSE 111425
// exit ;
111421: POP
111422: POP
111423: GO 111429
111425: GO 111388
111427: POP
111428: POP
// end ;
111429: LD_VAR 0 4
111433: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
111434: LD_INT 0
111436: PPUSH
111437: PPUSH
111438: PPUSH
111439: PPUSH
111440: PPUSH
111441: PPUSH
111442: PPUSH
// if not GetClass ( unit ) = class_sniper then
111443: LD_VAR 0 1
111447: PPUSH
111448: CALL_OW 257
111452: PUSH
111453: LD_INT 5
111455: EQUAL
111456: NOT
111457: IFFALSE 111461
// exit ;
111459: GO 111849
// dist := 8 ;
111461: LD_ADDR_VAR 0 5
111465: PUSH
111466: LD_INT 8
111468: ST_TO_ADDR
// viewRange := 12 ;
111469: LD_ADDR_VAR 0 7
111473: PUSH
111474: LD_INT 12
111476: ST_TO_ADDR
// side := GetSide ( unit ) ;
111477: LD_ADDR_VAR 0 6
111481: PUSH
111482: LD_VAR 0 1
111486: PPUSH
111487: CALL_OW 255
111491: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
111492: LD_INT 61
111494: PPUSH
111495: LD_VAR 0 6
111499: PPUSH
111500: CALL_OW 321
111504: PUSH
111505: LD_INT 2
111507: EQUAL
111508: IFFALSE 111518
// viewRange := 16 ;
111510: LD_ADDR_VAR 0 7
111514: PUSH
111515: LD_INT 16
111517: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
111518: LD_VAR 0 1
111522: PPUSH
111523: LD_VAR 0 2
111527: PPUSH
111528: LD_VAR 0 3
111532: PPUSH
111533: CALL_OW 297
111537: PUSH
111538: LD_VAR 0 5
111542: GREATER
111543: IFFALSE 111622
// begin ComMoveXY ( unit , x , y ) ;
111545: LD_VAR 0 1
111549: PPUSH
111550: LD_VAR 0 2
111554: PPUSH
111555: LD_VAR 0 3
111559: PPUSH
111560: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
111564: LD_INT 35
111566: PPUSH
111567: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
111571: LD_VAR 0 1
111575: PPUSH
111576: LD_VAR 0 2
111580: PPUSH
111581: LD_VAR 0 3
111585: PPUSH
111586: CALL 56142 0 3
111590: NOT
111591: IFFALSE 111595
// exit ;
111593: GO 111849
// until GetDistUnitXY ( unit , x , y ) < dist ;
111595: LD_VAR 0 1
111599: PPUSH
111600: LD_VAR 0 2
111604: PPUSH
111605: LD_VAR 0 3
111609: PPUSH
111610: CALL_OW 297
111614: PUSH
111615: LD_VAR 0 5
111619: LESS
111620: IFFALSE 111564
// end ; ComTurnXY ( unit , x , y ) ;
111622: LD_VAR 0 1
111626: PPUSH
111627: LD_VAR 0 2
111631: PPUSH
111632: LD_VAR 0 3
111636: PPUSH
111637: CALL_OW 118
// wait ( 5 ) ;
111641: LD_INT 5
111643: PPUSH
111644: CALL_OW 67
// _d := GetDir ( unit ) ;
111648: LD_ADDR_VAR 0 10
111652: PUSH
111653: LD_VAR 0 1
111657: PPUSH
111658: CALL_OW 254
111662: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
111663: LD_ADDR_VAR 0 8
111667: PUSH
111668: LD_VAR 0 1
111672: PPUSH
111673: CALL_OW 250
111677: PPUSH
111678: LD_VAR 0 10
111682: PPUSH
111683: LD_VAR 0 5
111687: PPUSH
111688: CALL_OW 272
111692: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
111693: LD_ADDR_VAR 0 9
111697: PUSH
111698: LD_VAR 0 1
111702: PPUSH
111703: CALL_OW 251
111707: PPUSH
111708: LD_VAR 0 10
111712: PPUSH
111713: LD_VAR 0 5
111717: PPUSH
111718: CALL_OW 273
111722: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
111723: LD_VAR 0 8
111727: PPUSH
111728: LD_VAR 0 9
111732: PPUSH
111733: CALL_OW 488
111737: NOT
111738: IFFALSE 111742
// exit ;
111740: GO 111849
// ComAnimCustom ( unit , 1 ) ;
111742: LD_VAR 0 1
111746: PPUSH
111747: LD_INT 1
111749: PPUSH
111750: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
111754: LD_VAR 0 8
111758: PPUSH
111759: LD_VAR 0 9
111763: PPUSH
111764: LD_VAR 0 6
111768: PPUSH
111769: LD_VAR 0 7
111773: PPUSH
111774: CALL_OW 330
// repeat wait ( 1 ) ;
111778: LD_INT 1
111780: PPUSH
111781: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
111785: LD_VAR 0 1
111789: PPUSH
111790: CALL_OW 316
111794: PUSH
111795: LD_VAR 0 1
111799: PPUSH
111800: CALL_OW 314
111804: OR
111805: PUSH
111806: LD_VAR 0 1
111810: PPUSH
111811: CALL_OW 302
111815: NOT
111816: OR
111817: PUSH
111818: LD_VAR 0 1
111822: PPUSH
111823: CALL_OW 301
111827: OR
111828: IFFALSE 111778
// RemoveSeeing ( _x , _y , side ) ;
111830: LD_VAR 0 8
111834: PPUSH
111835: LD_VAR 0 9
111839: PPUSH
111840: LD_VAR 0 6
111844: PPUSH
111845: CALL_OW 331
// end ; end_of_file
111849: LD_VAR 0 4
111853: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
111854: LD_INT 0
111856: PPUSH
111857: PPUSH
111858: PPUSH
111859: PPUSH
111860: PPUSH
111861: PPUSH
111862: PPUSH
111863: PPUSH
111864: PPUSH
111865: PPUSH
111866: PPUSH
111867: PPUSH
111868: PPUSH
111869: PPUSH
111870: PPUSH
111871: PPUSH
111872: PPUSH
111873: PPUSH
111874: PPUSH
111875: PPUSH
111876: PPUSH
111877: PPUSH
111878: PPUSH
111879: PPUSH
111880: PPUSH
111881: PPUSH
111882: PPUSH
111883: PPUSH
111884: PPUSH
111885: PPUSH
111886: PPUSH
111887: PPUSH
111888: PPUSH
111889: PPUSH
// if not list then
111890: LD_VAR 0 1
111894: NOT
111895: IFFALSE 111899
// exit ;
111897: GO 116558
// base := list [ 1 ] ;
111899: LD_ADDR_VAR 0 3
111903: PUSH
111904: LD_VAR 0 1
111908: PUSH
111909: LD_INT 1
111911: ARRAY
111912: ST_TO_ADDR
// group := list [ 2 ] ;
111913: LD_ADDR_VAR 0 4
111917: PUSH
111918: LD_VAR 0 1
111922: PUSH
111923: LD_INT 2
111925: ARRAY
111926: ST_TO_ADDR
// path := list [ 3 ] ;
111927: LD_ADDR_VAR 0 5
111931: PUSH
111932: LD_VAR 0 1
111936: PUSH
111937: LD_INT 3
111939: ARRAY
111940: ST_TO_ADDR
// flags := list [ 4 ] ;
111941: LD_ADDR_VAR 0 6
111945: PUSH
111946: LD_VAR 0 1
111950: PUSH
111951: LD_INT 4
111953: ARRAY
111954: ST_TO_ADDR
// mined := [ ] ;
111955: LD_ADDR_VAR 0 27
111959: PUSH
111960: EMPTY
111961: ST_TO_ADDR
// bombed := [ ] ;
111962: LD_ADDR_VAR 0 28
111966: PUSH
111967: EMPTY
111968: ST_TO_ADDR
// healers := [ ] ;
111969: LD_ADDR_VAR 0 31
111973: PUSH
111974: EMPTY
111975: ST_TO_ADDR
// to_heal := [ ] ;
111976: LD_ADDR_VAR 0 30
111980: PUSH
111981: EMPTY
111982: ST_TO_ADDR
// repairs := [ ] ;
111983: LD_ADDR_VAR 0 33
111987: PUSH
111988: EMPTY
111989: ST_TO_ADDR
// to_repair := [ ] ;
111990: LD_ADDR_VAR 0 32
111994: PUSH
111995: EMPTY
111996: ST_TO_ADDR
// if not group or not path then
111997: LD_VAR 0 4
112001: NOT
112002: PUSH
112003: LD_VAR 0 5
112007: NOT
112008: OR
112009: IFFALSE 112013
// exit ;
112011: GO 116558
// side := GetSide ( group [ 1 ] ) ;
112013: LD_ADDR_VAR 0 35
112017: PUSH
112018: LD_VAR 0 4
112022: PUSH
112023: LD_INT 1
112025: ARRAY
112026: PPUSH
112027: CALL_OW 255
112031: ST_TO_ADDR
// if flags then
112032: LD_VAR 0 6
112036: IFFALSE 112180
// begin f_ignore_area := flags [ 1 ] ;
112038: LD_ADDR_VAR 0 17
112042: PUSH
112043: LD_VAR 0 6
112047: PUSH
112048: LD_INT 1
112050: ARRAY
112051: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
112052: LD_ADDR_VAR 0 18
112056: PUSH
112057: LD_VAR 0 6
112061: PUSH
112062: LD_INT 2
112064: ARRAY
112065: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
112066: LD_ADDR_VAR 0 19
112070: PUSH
112071: LD_VAR 0 6
112075: PUSH
112076: LD_INT 3
112078: ARRAY
112079: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
112080: LD_ADDR_VAR 0 20
112084: PUSH
112085: LD_VAR 0 6
112089: PUSH
112090: LD_INT 4
112092: ARRAY
112093: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
112094: LD_ADDR_VAR 0 21
112098: PUSH
112099: LD_VAR 0 6
112103: PUSH
112104: LD_INT 5
112106: ARRAY
112107: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
112108: LD_ADDR_VAR 0 22
112112: PUSH
112113: LD_VAR 0 6
112117: PUSH
112118: LD_INT 6
112120: ARRAY
112121: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
112122: LD_ADDR_VAR 0 23
112126: PUSH
112127: LD_VAR 0 6
112131: PUSH
112132: LD_INT 7
112134: ARRAY
112135: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
112136: LD_ADDR_VAR 0 24
112140: PUSH
112141: LD_VAR 0 6
112145: PUSH
112146: LD_INT 8
112148: ARRAY
112149: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
112150: LD_ADDR_VAR 0 25
112154: PUSH
112155: LD_VAR 0 6
112159: PUSH
112160: LD_INT 9
112162: ARRAY
112163: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
112164: LD_ADDR_VAR 0 26
112168: PUSH
112169: LD_VAR 0 6
112173: PUSH
112174: LD_INT 10
112176: ARRAY
112177: ST_TO_ADDR
// end else
112178: GO 112260
// begin f_ignore_area := false ;
112180: LD_ADDR_VAR 0 17
112184: PUSH
112185: LD_INT 0
112187: ST_TO_ADDR
// f_capture := false ;
112188: LD_ADDR_VAR 0 18
112192: PUSH
112193: LD_INT 0
112195: ST_TO_ADDR
// f_ignore_civ := false ;
112196: LD_ADDR_VAR 0 19
112200: PUSH
112201: LD_INT 0
112203: ST_TO_ADDR
// f_murder := false ;
112204: LD_ADDR_VAR 0 20
112208: PUSH
112209: LD_INT 0
112211: ST_TO_ADDR
// f_mines := false ;
112212: LD_ADDR_VAR 0 21
112216: PUSH
112217: LD_INT 0
112219: ST_TO_ADDR
// f_repair := false ;
112220: LD_ADDR_VAR 0 22
112224: PUSH
112225: LD_INT 0
112227: ST_TO_ADDR
// f_heal := false ;
112228: LD_ADDR_VAR 0 23
112232: PUSH
112233: LD_INT 0
112235: ST_TO_ADDR
// f_spacetime := false ;
112236: LD_ADDR_VAR 0 24
112240: PUSH
112241: LD_INT 0
112243: ST_TO_ADDR
// f_attack_depot := false ;
112244: LD_ADDR_VAR 0 25
112248: PUSH
112249: LD_INT 0
112251: ST_TO_ADDR
// f_crawl := false ;
112252: LD_ADDR_VAR 0 26
112256: PUSH
112257: LD_INT 0
112259: ST_TO_ADDR
// end ; if f_heal then
112260: LD_VAR 0 23
112264: IFFALSE 112291
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
112266: LD_ADDR_VAR 0 31
112270: PUSH
112271: LD_VAR 0 4
112275: PPUSH
112276: LD_INT 25
112278: PUSH
112279: LD_INT 4
112281: PUSH
112282: EMPTY
112283: LIST
112284: LIST
112285: PPUSH
112286: CALL_OW 72
112290: ST_TO_ADDR
// if f_repair then
112291: LD_VAR 0 22
112295: IFFALSE 112322
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
112297: LD_ADDR_VAR 0 33
112301: PUSH
112302: LD_VAR 0 4
112306: PPUSH
112307: LD_INT 25
112309: PUSH
112310: LD_INT 3
112312: PUSH
112313: EMPTY
112314: LIST
112315: LIST
112316: PPUSH
112317: CALL_OW 72
112321: ST_TO_ADDR
// units_path := [ ] ;
112322: LD_ADDR_VAR 0 16
112326: PUSH
112327: EMPTY
112328: ST_TO_ADDR
// for i = 1 to group do
112329: LD_ADDR_VAR 0 7
112333: PUSH
112334: DOUBLE
112335: LD_INT 1
112337: DEC
112338: ST_TO_ADDR
112339: LD_VAR 0 4
112343: PUSH
112344: FOR_TO
112345: IFFALSE 112374
// units_path := Replace ( units_path , i , path ) ;
112347: LD_ADDR_VAR 0 16
112351: PUSH
112352: LD_VAR 0 16
112356: PPUSH
112357: LD_VAR 0 7
112361: PPUSH
112362: LD_VAR 0 5
112366: PPUSH
112367: CALL_OW 1
112371: ST_TO_ADDR
112372: GO 112344
112374: POP
112375: POP
// repeat for i = group downto 1 do
112376: LD_ADDR_VAR 0 7
112380: PUSH
112381: DOUBLE
112382: LD_VAR 0 4
112386: INC
112387: ST_TO_ADDR
112388: LD_INT 1
112390: PUSH
112391: FOR_DOWNTO
112392: IFFALSE 116514
// begin wait ( 5 ) ;
112394: LD_INT 5
112396: PPUSH
112397: CALL_OW 67
// tmp := [ ] ;
112401: LD_ADDR_VAR 0 14
112405: PUSH
112406: EMPTY
112407: ST_TO_ADDR
// attacking := false ;
112408: LD_ADDR_VAR 0 29
112412: PUSH
112413: LD_INT 0
112415: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
112416: LD_VAR 0 4
112420: PUSH
112421: LD_VAR 0 7
112425: ARRAY
112426: PPUSH
112427: CALL_OW 301
112431: PUSH
112432: LD_VAR 0 4
112436: PUSH
112437: LD_VAR 0 7
112441: ARRAY
112442: NOT
112443: OR
112444: IFFALSE 112553
// begin if GetType ( group [ i ] ) = unit_human then
112446: LD_VAR 0 4
112450: PUSH
112451: LD_VAR 0 7
112455: ARRAY
112456: PPUSH
112457: CALL_OW 247
112461: PUSH
112462: LD_INT 1
112464: EQUAL
112465: IFFALSE 112511
// begin to_heal := to_heal diff group [ i ] ;
112467: LD_ADDR_VAR 0 30
112471: PUSH
112472: LD_VAR 0 30
112476: PUSH
112477: LD_VAR 0 4
112481: PUSH
112482: LD_VAR 0 7
112486: ARRAY
112487: DIFF
112488: ST_TO_ADDR
// healers := healers diff group [ i ] ;
112489: LD_ADDR_VAR 0 31
112493: PUSH
112494: LD_VAR 0 31
112498: PUSH
112499: LD_VAR 0 4
112503: PUSH
112504: LD_VAR 0 7
112508: ARRAY
112509: DIFF
112510: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
112511: LD_ADDR_VAR 0 4
112515: PUSH
112516: LD_VAR 0 4
112520: PPUSH
112521: LD_VAR 0 7
112525: PPUSH
112526: CALL_OW 3
112530: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
112531: LD_ADDR_VAR 0 16
112535: PUSH
112536: LD_VAR 0 16
112540: PPUSH
112541: LD_VAR 0 7
112545: PPUSH
112546: CALL_OW 3
112550: ST_TO_ADDR
// continue ;
112551: GO 112391
// end ; if f_repair then
112553: LD_VAR 0 22
112557: IFFALSE 113046
// begin if GetType ( group [ i ] ) = unit_vehicle then
112559: LD_VAR 0 4
112563: PUSH
112564: LD_VAR 0 7
112568: ARRAY
112569: PPUSH
112570: CALL_OW 247
112574: PUSH
112575: LD_INT 2
112577: EQUAL
112578: IFFALSE 112768
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
112580: LD_VAR 0 4
112584: PUSH
112585: LD_VAR 0 7
112589: ARRAY
112590: PPUSH
112591: CALL_OW 256
112595: PUSH
112596: LD_INT 700
112598: LESS
112599: PUSH
112600: LD_VAR 0 4
112604: PUSH
112605: LD_VAR 0 7
112609: ARRAY
112610: PUSH
112611: LD_VAR 0 32
112615: IN
112616: NOT
112617: AND
112618: IFFALSE 112642
// to_repair := to_repair union group [ i ] ;
112620: LD_ADDR_VAR 0 32
112624: PUSH
112625: LD_VAR 0 32
112629: PUSH
112630: LD_VAR 0 4
112634: PUSH
112635: LD_VAR 0 7
112639: ARRAY
112640: UNION
112641: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
112642: LD_VAR 0 4
112646: PUSH
112647: LD_VAR 0 7
112651: ARRAY
112652: PPUSH
112653: CALL_OW 256
112657: PUSH
112658: LD_INT 1000
112660: EQUAL
112661: PUSH
112662: LD_VAR 0 4
112666: PUSH
112667: LD_VAR 0 7
112671: ARRAY
112672: PUSH
112673: LD_VAR 0 32
112677: IN
112678: AND
112679: IFFALSE 112703
// to_repair := to_repair diff group [ i ] ;
112681: LD_ADDR_VAR 0 32
112685: PUSH
112686: LD_VAR 0 32
112690: PUSH
112691: LD_VAR 0 4
112695: PUSH
112696: LD_VAR 0 7
112700: ARRAY
112701: DIFF
112702: ST_TO_ADDR
// if group [ i ] in to_repair then
112703: LD_VAR 0 4
112707: PUSH
112708: LD_VAR 0 7
112712: ARRAY
112713: PUSH
112714: LD_VAR 0 32
112718: IN
112719: IFFALSE 112766
// begin if not IsInArea ( group [ i ] , f_repair ) then
112721: LD_VAR 0 4
112725: PUSH
112726: LD_VAR 0 7
112730: ARRAY
112731: PPUSH
112732: LD_VAR 0 22
112736: PPUSH
112737: CALL_OW 308
112741: NOT
112742: IFFALSE 112764
// ComMoveToArea ( group [ i ] , f_repair ) ;
112744: LD_VAR 0 4
112748: PUSH
112749: LD_VAR 0 7
112753: ARRAY
112754: PPUSH
112755: LD_VAR 0 22
112759: PPUSH
112760: CALL_OW 113
// continue ;
112764: GO 112391
// end ; end else
112766: GO 113046
// if group [ i ] in repairs then
112768: LD_VAR 0 4
112772: PUSH
112773: LD_VAR 0 7
112777: ARRAY
112778: PUSH
112779: LD_VAR 0 33
112783: IN
112784: IFFALSE 113046
// begin if IsInUnit ( group [ i ] ) then
112786: LD_VAR 0 4
112790: PUSH
112791: LD_VAR 0 7
112795: ARRAY
112796: PPUSH
112797: CALL_OW 310
112801: IFFALSE 112869
// begin z := IsInUnit ( group [ i ] ) ;
112803: LD_ADDR_VAR 0 13
112807: PUSH
112808: LD_VAR 0 4
112812: PUSH
112813: LD_VAR 0 7
112817: ARRAY
112818: PPUSH
112819: CALL_OW 310
112823: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
112824: LD_VAR 0 13
112828: PUSH
112829: LD_VAR 0 32
112833: IN
112834: PUSH
112835: LD_VAR 0 13
112839: PPUSH
112840: LD_VAR 0 22
112844: PPUSH
112845: CALL_OW 308
112849: AND
112850: IFFALSE 112867
// ComExitVehicle ( group [ i ] ) ;
112852: LD_VAR 0 4
112856: PUSH
112857: LD_VAR 0 7
112861: ARRAY
112862: PPUSH
112863: CALL_OW 121
// end else
112867: GO 113046
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
112869: LD_ADDR_VAR 0 13
112873: PUSH
112874: LD_VAR 0 4
112878: PPUSH
112879: LD_INT 95
112881: PUSH
112882: LD_VAR 0 22
112886: PUSH
112887: EMPTY
112888: LIST
112889: LIST
112890: PUSH
112891: LD_INT 58
112893: PUSH
112894: EMPTY
112895: LIST
112896: PUSH
112897: EMPTY
112898: LIST
112899: LIST
112900: PPUSH
112901: CALL_OW 72
112905: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
112906: LD_VAR 0 4
112910: PUSH
112911: LD_VAR 0 7
112915: ARRAY
112916: PPUSH
112917: CALL_OW 314
112921: NOT
112922: IFFALSE 113044
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
112924: LD_ADDR_VAR 0 10
112928: PUSH
112929: LD_VAR 0 13
112933: PPUSH
112934: LD_VAR 0 4
112938: PUSH
112939: LD_VAR 0 7
112943: ARRAY
112944: PPUSH
112945: CALL_OW 74
112949: ST_TO_ADDR
// if not x then
112950: LD_VAR 0 10
112954: NOT
112955: IFFALSE 112959
// continue ;
112957: GO 112391
// if GetLives ( x ) < 1000 then
112959: LD_VAR 0 10
112963: PPUSH
112964: CALL_OW 256
112968: PUSH
112969: LD_INT 1000
112971: LESS
112972: IFFALSE 112996
// ComRepairVehicle ( group [ i ] , x ) else
112974: LD_VAR 0 4
112978: PUSH
112979: LD_VAR 0 7
112983: ARRAY
112984: PPUSH
112985: LD_VAR 0 10
112989: PPUSH
112990: CALL_OW 129
112994: GO 113044
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
112996: LD_VAR 0 23
113000: PUSH
113001: LD_VAR 0 4
113005: PUSH
113006: LD_VAR 0 7
113010: ARRAY
113011: PPUSH
113012: CALL_OW 256
113016: PUSH
113017: LD_INT 1000
113019: LESS
113020: AND
113021: NOT
113022: IFFALSE 113044
// ComEnterUnit ( group [ i ] , x ) ;
113024: LD_VAR 0 4
113028: PUSH
113029: LD_VAR 0 7
113033: ARRAY
113034: PPUSH
113035: LD_VAR 0 10
113039: PPUSH
113040: CALL_OW 120
// end ; continue ;
113044: GO 112391
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
113046: LD_VAR 0 23
113050: PUSH
113051: LD_VAR 0 4
113055: PUSH
113056: LD_VAR 0 7
113060: ARRAY
113061: PPUSH
113062: CALL_OW 247
113066: PUSH
113067: LD_INT 1
113069: EQUAL
113070: AND
113071: IFFALSE 113549
// begin if group [ i ] in healers then
113073: LD_VAR 0 4
113077: PUSH
113078: LD_VAR 0 7
113082: ARRAY
113083: PUSH
113084: LD_VAR 0 31
113088: IN
113089: IFFALSE 113362
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
113091: LD_VAR 0 4
113095: PUSH
113096: LD_VAR 0 7
113100: ARRAY
113101: PPUSH
113102: LD_VAR 0 23
113106: PPUSH
113107: CALL_OW 308
113111: NOT
113112: PUSH
113113: LD_VAR 0 4
113117: PUSH
113118: LD_VAR 0 7
113122: ARRAY
113123: PPUSH
113124: CALL_OW 314
113128: NOT
113129: AND
113130: IFFALSE 113154
// ComMoveToArea ( group [ i ] , f_heal ) else
113132: LD_VAR 0 4
113136: PUSH
113137: LD_VAR 0 7
113141: ARRAY
113142: PPUSH
113143: LD_VAR 0 23
113147: PPUSH
113148: CALL_OW 113
113152: GO 113360
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
113154: LD_VAR 0 4
113158: PUSH
113159: LD_VAR 0 7
113163: ARRAY
113164: PPUSH
113165: CALL 54718 0 1
113169: PPUSH
113170: CALL_OW 256
113174: PUSH
113175: LD_INT 1000
113177: EQUAL
113178: IFFALSE 113197
// ComStop ( group [ i ] ) else
113180: LD_VAR 0 4
113184: PUSH
113185: LD_VAR 0 7
113189: ARRAY
113190: PPUSH
113191: CALL_OW 141
113195: GO 113360
// if not HasTask ( group [ i ] ) and to_heal then
113197: LD_VAR 0 4
113201: PUSH
113202: LD_VAR 0 7
113206: ARRAY
113207: PPUSH
113208: CALL_OW 314
113212: NOT
113213: PUSH
113214: LD_VAR 0 30
113218: AND
113219: IFFALSE 113360
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
113221: LD_ADDR_VAR 0 13
113225: PUSH
113226: LD_VAR 0 30
113230: PPUSH
113231: LD_INT 3
113233: PUSH
113234: LD_INT 54
113236: PUSH
113237: EMPTY
113238: LIST
113239: PUSH
113240: EMPTY
113241: LIST
113242: LIST
113243: PPUSH
113244: CALL_OW 72
113248: PPUSH
113249: LD_VAR 0 4
113253: PUSH
113254: LD_VAR 0 7
113258: ARRAY
113259: PPUSH
113260: CALL_OW 74
113264: ST_TO_ADDR
// if z then
113265: LD_VAR 0 13
113269: IFFALSE 113360
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
113271: LD_INT 91
113273: PUSH
113274: LD_VAR 0 13
113278: PUSH
113279: LD_INT 10
113281: PUSH
113282: EMPTY
113283: LIST
113284: LIST
113285: LIST
113286: PUSH
113287: LD_INT 81
113289: PUSH
113290: LD_VAR 0 13
113294: PPUSH
113295: CALL_OW 255
113299: PUSH
113300: EMPTY
113301: LIST
113302: LIST
113303: PUSH
113304: EMPTY
113305: LIST
113306: LIST
113307: PPUSH
113308: CALL_OW 69
113312: PUSH
113313: LD_INT 0
113315: EQUAL
113316: IFFALSE 113340
// ComHeal ( group [ i ] , z ) else
113318: LD_VAR 0 4
113322: PUSH
113323: LD_VAR 0 7
113327: ARRAY
113328: PPUSH
113329: LD_VAR 0 13
113333: PPUSH
113334: CALL_OW 128
113338: GO 113360
// ComMoveToArea ( group [ i ] , f_heal ) ;
113340: LD_VAR 0 4
113344: PUSH
113345: LD_VAR 0 7
113349: ARRAY
113350: PPUSH
113351: LD_VAR 0 23
113355: PPUSH
113356: CALL_OW 113
// end ; continue ;
113360: GO 112391
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
113362: LD_VAR 0 4
113366: PUSH
113367: LD_VAR 0 7
113371: ARRAY
113372: PPUSH
113373: CALL_OW 256
113377: PUSH
113378: LD_INT 700
113380: LESS
113381: PUSH
113382: LD_VAR 0 4
113386: PUSH
113387: LD_VAR 0 7
113391: ARRAY
113392: PUSH
113393: LD_VAR 0 30
113397: IN
113398: NOT
113399: AND
113400: IFFALSE 113424
// to_heal := to_heal union group [ i ] ;
113402: LD_ADDR_VAR 0 30
113406: PUSH
113407: LD_VAR 0 30
113411: PUSH
113412: LD_VAR 0 4
113416: PUSH
113417: LD_VAR 0 7
113421: ARRAY
113422: UNION
113423: ST_TO_ADDR
// if group [ i ] in to_heal then
113424: LD_VAR 0 4
113428: PUSH
113429: LD_VAR 0 7
113433: ARRAY
113434: PUSH
113435: LD_VAR 0 30
113439: IN
113440: IFFALSE 113549
// begin if GetLives ( group [ i ] ) = 1000 then
113442: LD_VAR 0 4
113446: PUSH
113447: LD_VAR 0 7
113451: ARRAY
113452: PPUSH
113453: CALL_OW 256
113457: PUSH
113458: LD_INT 1000
113460: EQUAL
113461: IFFALSE 113487
// to_heal := to_heal diff group [ i ] else
113463: LD_ADDR_VAR 0 30
113467: PUSH
113468: LD_VAR 0 30
113472: PUSH
113473: LD_VAR 0 4
113477: PUSH
113478: LD_VAR 0 7
113482: ARRAY
113483: DIFF
113484: ST_TO_ADDR
113485: GO 113549
// begin if not IsInArea ( group [ i ] , to_heal ) then
113487: LD_VAR 0 4
113491: PUSH
113492: LD_VAR 0 7
113496: ARRAY
113497: PPUSH
113498: LD_VAR 0 30
113502: PPUSH
113503: CALL_OW 308
113507: NOT
113508: IFFALSE 113532
// ComMoveToArea ( group [ i ] , f_heal ) else
113510: LD_VAR 0 4
113514: PUSH
113515: LD_VAR 0 7
113519: ARRAY
113520: PPUSH
113521: LD_VAR 0 23
113525: PPUSH
113526: CALL_OW 113
113530: GO 113547
// ComHold ( group [ i ] ) ;
113532: LD_VAR 0 4
113536: PUSH
113537: LD_VAR 0 7
113541: ARRAY
113542: PPUSH
113543: CALL_OW 140
// continue ;
113547: GO 112391
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
113549: LD_VAR 0 4
113553: PUSH
113554: LD_VAR 0 7
113558: ARRAY
113559: PPUSH
113560: LD_INT 10
113562: PPUSH
113563: CALL 52515 0 2
113567: NOT
113568: PUSH
113569: LD_VAR 0 16
113573: PUSH
113574: LD_VAR 0 7
113578: ARRAY
113579: PUSH
113580: EMPTY
113581: EQUAL
113582: NOT
113583: AND
113584: IFFALSE 113850
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
113586: LD_VAR 0 4
113590: PUSH
113591: LD_VAR 0 7
113595: ARRAY
113596: PPUSH
113597: CALL_OW 262
113601: PUSH
113602: LD_INT 1
113604: PUSH
113605: LD_INT 2
113607: PUSH
113608: EMPTY
113609: LIST
113610: LIST
113611: IN
113612: IFFALSE 113653
// if GetFuel ( group [ i ] ) < 10 then
113614: LD_VAR 0 4
113618: PUSH
113619: LD_VAR 0 7
113623: ARRAY
113624: PPUSH
113625: CALL_OW 261
113629: PUSH
113630: LD_INT 10
113632: LESS
113633: IFFALSE 113653
// SetFuel ( group [ i ] , 12 ) ;
113635: LD_VAR 0 4
113639: PUSH
113640: LD_VAR 0 7
113644: ARRAY
113645: PPUSH
113646: LD_INT 12
113648: PPUSH
113649: CALL_OW 240
// if units_path [ i ] then
113653: LD_VAR 0 16
113657: PUSH
113658: LD_VAR 0 7
113662: ARRAY
113663: IFFALSE 113848
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
113665: LD_VAR 0 4
113669: PUSH
113670: LD_VAR 0 7
113674: ARRAY
113675: PPUSH
113676: LD_VAR 0 16
113680: PUSH
113681: LD_VAR 0 7
113685: ARRAY
113686: PUSH
113687: LD_INT 1
113689: ARRAY
113690: PUSH
113691: LD_INT 1
113693: ARRAY
113694: PPUSH
113695: LD_VAR 0 16
113699: PUSH
113700: LD_VAR 0 7
113704: ARRAY
113705: PUSH
113706: LD_INT 1
113708: ARRAY
113709: PUSH
113710: LD_INT 2
113712: ARRAY
113713: PPUSH
113714: CALL_OW 297
113718: PUSH
113719: LD_INT 6
113721: GREATER
113722: IFFALSE 113797
// begin if not HasTask ( group [ i ] ) then
113724: LD_VAR 0 4
113728: PUSH
113729: LD_VAR 0 7
113733: ARRAY
113734: PPUSH
113735: CALL_OW 314
113739: NOT
113740: IFFALSE 113795
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
113742: LD_VAR 0 4
113746: PUSH
113747: LD_VAR 0 7
113751: ARRAY
113752: PPUSH
113753: LD_VAR 0 16
113757: PUSH
113758: LD_VAR 0 7
113762: ARRAY
113763: PUSH
113764: LD_INT 1
113766: ARRAY
113767: PUSH
113768: LD_INT 1
113770: ARRAY
113771: PPUSH
113772: LD_VAR 0 16
113776: PUSH
113777: LD_VAR 0 7
113781: ARRAY
113782: PUSH
113783: LD_INT 1
113785: ARRAY
113786: PUSH
113787: LD_INT 2
113789: ARRAY
113790: PPUSH
113791: CALL_OW 114
// end else
113795: GO 113848
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
113797: LD_ADDR_VAR 0 15
113801: PUSH
113802: LD_VAR 0 16
113806: PUSH
113807: LD_VAR 0 7
113811: ARRAY
113812: PPUSH
113813: LD_INT 1
113815: PPUSH
113816: CALL_OW 3
113820: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
113821: LD_ADDR_VAR 0 16
113825: PUSH
113826: LD_VAR 0 16
113830: PPUSH
113831: LD_VAR 0 7
113835: PPUSH
113836: LD_VAR 0 15
113840: PPUSH
113841: CALL_OW 1
113845: ST_TO_ADDR
// continue ;
113846: GO 112391
// end ; end ; end else
113848: GO 116512
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
113850: LD_ADDR_VAR 0 14
113854: PUSH
113855: LD_INT 81
113857: PUSH
113858: LD_VAR 0 4
113862: PUSH
113863: LD_VAR 0 7
113867: ARRAY
113868: PPUSH
113869: CALL_OW 255
113873: PUSH
113874: EMPTY
113875: LIST
113876: LIST
113877: PPUSH
113878: CALL_OW 69
113882: ST_TO_ADDR
// if not tmp then
113883: LD_VAR 0 14
113887: NOT
113888: IFFALSE 113892
// continue ;
113890: GO 112391
// if f_ignore_area then
113892: LD_VAR 0 17
113896: IFFALSE 113984
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
113898: LD_ADDR_VAR 0 15
113902: PUSH
113903: LD_VAR 0 14
113907: PPUSH
113908: LD_INT 3
113910: PUSH
113911: LD_INT 92
113913: PUSH
113914: LD_VAR 0 17
113918: PUSH
113919: LD_INT 1
113921: ARRAY
113922: PUSH
113923: LD_VAR 0 17
113927: PUSH
113928: LD_INT 2
113930: ARRAY
113931: PUSH
113932: LD_VAR 0 17
113936: PUSH
113937: LD_INT 3
113939: ARRAY
113940: PUSH
113941: EMPTY
113942: LIST
113943: LIST
113944: LIST
113945: LIST
113946: PUSH
113947: EMPTY
113948: LIST
113949: LIST
113950: PPUSH
113951: CALL_OW 72
113955: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
113956: LD_VAR 0 14
113960: PUSH
113961: LD_VAR 0 15
113965: DIFF
113966: IFFALSE 113984
// tmp := tmp diff tmp2 ;
113968: LD_ADDR_VAR 0 14
113972: PUSH
113973: LD_VAR 0 14
113977: PUSH
113978: LD_VAR 0 15
113982: DIFF
113983: ST_TO_ADDR
// end ; if not f_murder then
113984: LD_VAR 0 20
113988: NOT
113989: IFFALSE 114047
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
113991: LD_ADDR_VAR 0 15
113995: PUSH
113996: LD_VAR 0 14
114000: PPUSH
114001: LD_INT 3
114003: PUSH
114004: LD_INT 50
114006: PUSH
114007: EMPTY
114008: LIST
114009: PUSH
114010: EMPTY
114011: LIST
114012: LIST
114013: PPUSH
114014: CALL_OW 72
114018: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
114019: LD_VAR 0 14
114023: PUSH
114024: LD_VAR 0 15
114028: DIFF
114029: IFFALSE 114047
// tmp := tmp diff tmp2 ;
114031: LD_ADDR_VAR 0 14
114035: PUSH
114036: LD_VAR 0 14
114040: PUSH
114041: LD_VAR 0 15
114045: DIFF
114046: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
114047: LD_ADDR_VAR 0 14
114051: PUSH
114052: LD_VAR 0 4
114056: PUSH
114057: LD_VAR 0 7
114061: ARRAY
114062: PPUSH
114063: LD_VAR 0 14
114067: PPUSH
114068: LD_INT 1
114070: PPUSH
114071: LD_INT 1
114073: PPUSH
114074: CALL 25456 0 4
114078: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
114079: LD_VAR 0 4
114083: PUSH
114084: LD_VAR 0 7
114088: ARRAY
114089: PPUSH
114090: CALL_OW 257
114094: PUSH
114095: LD_INT 1
114097: EQUAL
114098: IFFALSE 114546
// begin if WantPlant ( group [ i ] ) then
114100: LD_VAR 0 4
114104: PUSH
114105: LD_VAR 0 7
114109: ARRAY
114110: PPUSH
114111: CALL 24957 0 1
114115: IFFALSE 114119
// continue ;
114117: GO 112391
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
114119: LD_VAR 0 18
114123: PUSH
114124: LD_VAR 0 4
114128: PUSH
114129: LD_VAR 0 7
114133: ARRAY
114134: PPUSH
114135: CALL_OW 310
114139: NOT
114140: AND
114141: PUSH
114142: LD_VAR 0 14
114146: PUSH
114147: LD_INT 1
114149: ARRAY
114150: PUSH
114151: LD_VAR 0 14
114155: PPUSH
114156: LD_INT 21
114158: PUSH
114159: LD_INT 2
114161: PUSH
114162: EMPTY
114163: LIST
114164: LIST
114165: PUSH
114166: LD_INT 58
114168: PUSH
114169: EMPTY
114170: LIST
114171: PUSH
114172: EMPTY
114173: LIST
114174: LIST
114175: PPUSH
114176: CALL_OW 72
114180: IN
114181: AND
114182: IFFALSE 114218
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
114184: LD_VAR 0 4
114188: PUSH
114189: LD_VAR 0 7
114193: ARRAY
114194: PPUSH
114195: LD_VAR 0 14
114199: PUSH
114200: LD_INT 1
114202: ARRAY
114203: PPUSH
114204: CALL_OW 120
// attacking := true ;
114208: LD_ADDR_VAR 0 29
114212: PUSH
114213: LD_INT 1
114215: ST_TO_ADDR
// continue ;
114216: GO 112391
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
114218: LD_VAR 0 26
114222: PUSH
114223: LD_VAR 0 4
114227: PUSH
114228: LD_VAR 0 7
114232: ARRAY
114233: PPUSH
114234: CALL_OW 257
114238: PUSH
114239: LD_INT 1
114241: EQUAL
114242: AND
114243: PUSH
114244: LD_VAR 0 4
114248: PUSH
114249: LD_VAR 0 7
114253: ARRAY
114254: PPUSH
114255: CALL_OW 256
114259: PUSH
114260: LD_INT 800
114262: LESS
114263: AND
114264: PUSH
114265: LD_VAR 0 4
114269: PUSH
114270: LD_VAR 0 7
114274: ARRAY
114275: PPUSH
114276: CALL_OW 318
114280: NOT
114281: AND
114282: IFFALSE 114299
// ComCrawl ( group [ i ] ) ;
114284: LD_VAR 0 4
114288: PUSH
114289: LD_VAR 0 7
114293: ARRAY
114294: PPUSH
114295: CALL_OW 137
// if f_mines then
114299: LD_VAR 0 21
114303: IFFALSE 114546
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
114305: LD_VAR 0 14
114309: PUSH
114310: LD_INT 1
114312: ARRAY
114313: PPUSH
114314: CALL_OW 247
114318: PUSH
114319: LD_INT 3
114321: EQUAL
114322: PUSH
114323: LD_VAR 0 14
114327: PUSH
114328: LD_INT 1
114330: ARRAY
114331: PUSH
114332: LD_VAR 0 27
114336: IN
114337: NOT
114338: AND
114339: IFFALSE 114546
// begin x := GetX ( tmp [ 1 ] ) ;
114341: LD_ADDR_VAR 0 10
114345: PUSH
114346: LD_VAR 0 14
114350: PUSH
114351: LD_INT 1
114353: ARRAY
114354: PPUSH
114355: CALL_OW 250
114359: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
114360: LD_ADDR_VAR 0 11
114364: PUSH
114365: LD_VAR 0 14
114369: PUSH
114370: LD_INT 1
114372: ARRAY
114373: PPUSH
114374: CALL_OW 251
114378: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
114379: LD_ADDR_VAR 0 12
114383: PUSH
114384: LD_VAR 0 4
114388: PUSH
114389: LD_VAR 0 7
114393: ARRAY
114394: PPUSH
114395: CALL 52600 0 1
114399: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
114400: LD_VAR 0 4
114404: PUSH
114405: LD_VAR 0 7
114409: ARRAY
114410: PPUSH
114411: LD_VAR 0 10
114415: PPUSH
114416: LD_VAR 0 11
114420: PPUSH
114421: LD_VAR 0 14
114425: PUSH
114426: LD_INT 1
114428: ARRAY
114429: PPUSH
114430: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
114434: LD_VAR 0 4
114438: PUSH
114439: LD_VAR 0 7
114443: ARRAY
114444: PPUSH
114445: LD_VAR 0 10
114449: PPUSH
114450: LD_VAR 0 12
114454: PPUSH
114455: LD_INT 7
114457: PPUSH
114458: CALL_OW 272
114462: PPUSH
114463: LD_VAR 0 11
114467: PPUSH
114468: LD_VAR 0 12
114472: PPUSH
114473: LD_INT 7
114475: PPUSH
114476: CALL_OW 273
114480: PPUSH
114481: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
114485: LD_VAR 0 4
114489: PUSH
114490: LD_VAR 0 7
114494: ARRAY
114495: PPUSH
114496: LD_INT 71
114498: PPUSH
114499: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
114503: LD_ADDR_VAR 0 27
114507: PUSH
114508: LD_VAR 0 27
114512: PPUSH
114513: LD_VAR 0 27
114517: PUSH
114518: LD_INT 1
114520: PLUS
114521: PPUSH
114522: LD_VAR 0 14
114526: PUSH
114527: LD_INT 1
114529: ARRAY
114530: PPUSH
114531: CALL_OW 1
114535: ST_TO_ADDR
// attacking := true ;
114536: LD_ADDR_VAR 0 29
114540: PUSH
114541: LD_INT 1
114543: ST_TO_ADDR
// continue ;
114544: GO 112391
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
114546: LD_VAR 0 4
114550: PUSH
114551: LD_VAR 0 7
114555: ARRAY
114556: PPUSH
114557: CALL_OW 257
114561: PUSH
114562: LD_INT 17
114564: EQUAL
114565: PUSH
114566: LD_VAR 0 4
114570: PUSH
114571: LD_VAR 0 7
114575: ARRAY
114576: PPUSH
114577: CALL_OW 110
114581: PUSH
114582: LD_INT 71
114584: EQUAL
114585: NOT
114586: AND
114587: IFFALSE 114733
// begin attacking := false ;
114589: LD_ADDR_VAR 0 29
114593: PUSH
114594: LD_INT 0
114596: ST_TO_ADDR
// k := 5 ;
114597: LD_ADDR_VAR 0 9
114601: PUSH
114602: LD_INT 5
114604: ST_TO_ADDR
// if tmp < k then
114605: LD_VAR 0 14
114609: PUSH
114610: LD_VAR 0 9
114614: LESS
114615: IFFALSE 114627
// k := tmp ;
114617: LD_ADDR_VAR 0 9
114621: PUSH
114622: LD_VAR 0 14
114626: ST_TO_ADDR
// for j = 1 to k do
114627: LD_ADDR_VAR 0 8
114631: PUSH
114632: DOUBLE
114633: LD_INT 1
114635: DEC
114636: ST_TO_ADDR
114637: LD_VAR 0 9
114641: PUSH
114642: FOR_TO
114643: IFFALSE 114731
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
114645: LD_VAR 0 14
114649: PUSH
114650: LD_VAR 0 8
114654: ARRAY
114655: PUSH
114656: LD_VAR 0 14
114660: PPUSH
114661: LD_INT 58
114663: PUSH
114664: EMPTY
114665: LIST
114666: PPUSH
114667: CALL_OW 72
114671: IN
114672: NOT
114673: IFFALSE 114729
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
114675: LD_VAR 0 4
114679: PUSH
114680: LD_VAR 0 7
114684: ARRAY
114685: PPUSH
114686: LD_VAR 0 14
114690: PUSH
114691: LD_VAR 0 8
114695: ARRAY
114696: PPUSH
114697: CALL_OW 115
// attacking := true ;
114701: LD_ADDR_VAR 0 29
114705: PUSH
114706: LD_INT 1
114708: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
114709: LD_VAR 0 4
114713: PUSH
114714: LD_VAR 0 7
114718: ARRAY
114719: PPUSH
114720: LD_INT 71
114722: PPUSH
114723: CALL_OW 109
// continue ;
114727: GO 114642
// end ; end ;
114729: GO 114642
114731: POP
114732: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
114733: LD_VAR 0 4
114737: PUSH
114738: LD_VAR 0 7
114742: ARRAY
114743: PPUSH
114744: CALL_OW 257
114748: PUSH
114749: LD_INT 8
114751: EQUAL
114752: PUSH
114753: LD_VAR 0 4
114757: PUSH
114758: LD_VAR 0 7
114762: ARRAY
114763: PPUSH
114764: CALL_OW 264
114768: PUSH
114769: LD_INT 28
114771: PUSH
114772: LD_INT 45
114774: PUSH
114775: LD_INT 7
114777: PUSH
114778: LD_INT 47
114780: PUSH
114781: EMPTY
114782: LIST
114783: LIST
114784: LIST
114785: LIST
114786: IN
114787: OR
114788: IFFALSE 115044
// begin attacking := false ;
114790: LD_ADDR_VAR 0 29
114794: PUSH
114795: LD_INT 0
114797: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
114798: LD_VAR 0 14
114802: PUSH
114803: LD_INT 1
114805: ARRAY
114806: PPUSH
114807: CALL_OW 266
114811: PUSH
114812: LD_INT 32
114814: PUSH
114815: LD_INT 31
114817: PUSH
114818: LD_INT 33
114820: PUSH
114821: LD_INT 4
114823: PUSH
114824: LD_INT 5
114826: PUSH
114827: EMPTY
114828: LIST
114829: LIST
114830: LIST
114831: LIST
114832: LIST
114833: IN
114834: IFFALSE 115020
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
114836: LD_ADDR_VAR 0 9
114840: PUSH
114841: LD_VAR 0 14
114845: PUSH
114846: LD_INT 1
114848: ARRAY
114849: PPUSH
114850: CALL_OW 266
114854: PPUSH
114855: LD_VAR 0 14
114859: PUSH
114860: LD_INT 1
114862: ARRAY
114863: PPUSH
114864: CALL_OW 250
114868: PPUSH
114869: LD_VAR 0 14
114873: PUSH
114874: LD_INT 1
114876: ARRAY
114877: PPUSH
114878: CALL_OW 251
114882: PPUSH
114883: LD_VAR 0 14
114887: PUSH
114888: LD_INT 1
114890: ARRAY
114891: PPUSH
114892: CALL_OW 254
114896: PPUSH
114897: LD_VAR 0 14
114901: PUSH
114902: LD_INT 1
114904: ARRAY
114905: PPUSH
114906: CALL_OW 248
114910: PPUSH
114911: LD_INT 0
114913: PPUSH
114914: CALL 33970 0 6
114918: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
114919: LD_ADDR_VAR 0 8
114923: PUSH
114924: LD_VAR 0 4
114928: PUSH
114929: LD_VAR 0 7
114933: ARRAY
114934: PPUSH
114935: LD_VAR 0 9
114939: PPUSH
114940: CALL 52713 0 2
114944: ST_TO_ADDR
// if j then
114945: LD_VAR 0 8
114949: IFFALSE 115018
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
114951: LD_VAR 0 8
114955: PUSH
114956: LD_INT 1
114958: ARRAY
114959: PPUSH
114960: LD_VAR 0 8
114964: PUSH
114965: LD_INT 2
114967: ARRAY
114968: PPUSH
114969: CALL_OW 488
114973: IFFALSE 115018
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
114975: LD_VAR 0 4
114979: PUSH
114980: LD_VAR 0 7
114984: ARRAY
114985: PPUSH
114986: LD_VAR 0 8
114990: PUSH
114991: LD_INT 1
114993: ARRAY
114994: PPUSH
114995: LD_VAR 0 8
114999: PUSH
115000: LD_INT 2
115002: ARRAY
115003: PPUSH
115004: CALL_OW 116
// attacking := true ;
115008: LD_ADDR_VAR 0 29
115012: PUSH
115013: LD_INT 1
115015: ST_TO_ADDR
// continue ;
115016: GO 112391
// end ; end else
115018: GO 115044
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
115020: LD_VAR 0 4
115024: PUSH
115025: LD_VAR 0 7
115029: ARRAY
115030: PPUSH
115031: LD_VAR 0 14
115035: PUSH
115036: LD_INT 1
115038: ARRAY
115039: PPUSH
115040: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
115044: LD_VAR 0 4
115048: PUSH
115049: LD_VAR 0 7
115053: ARRAY
115054: PPUSH
115055: CALL_OW 265
115059: PUSH
115060: LD_INT 11
115062: EQUAL
115063: IFFALSE 115341
// begin k := 10 ;
115065: LD_ADDR_VAR 0 9
115069: PUSH
115070: LD_INT 10
115072: ST_TO_ADDR
// x := 0 ;
115073: LD_ADDR_VAR 0 10
115077: PUSH
115078: LD_INT 0
115080: ST_TO_ADDR
// if tmp < k then
115081: LD_VAR 0 14
115085: PUSH
115086: LD_VAR 0 9
115090: LESS
115091: IFFALSE 115103
// k := tmp ;
115093: LD_ADDR_VAR 0 9
115097: PUSH
115098: LD_VAR 0 14
115102: ST_TO_ADDR
// for j = k downto 1 do
115103: LD_ADDR_VAR 0 8
115107: PUSH
115108: DOUBLE
115109: LD_VAR 0 9
115113: INC
115114: ST_TO_ADDR
115115: LD_INT 1
115117: PUSH
115118: FOR_DOWNTO
115119: IFFALSE 115194
// begin if GetType ( tmp [ j ] ) = unit_human then
115121: LD_VAR 0 14
115125: PUSH
115126: LD_VAR 0 8
115130: ARRAY
115131: PPUSH
115132: CALL_OW 247
115136: PUSH
115137: LD_INT 1
115139: EQUAL
115140: IFFALSE 115192
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
115142: LD_VAR 0 4
115146: PUSH
115147: LD_VAR 0 7
115151: ARRAY
115152: PPUSH
115153: LD_VAR 0 14
115157: PUSH
115158: LD_VAR 0 8
115162: ARRAY
115163: PPUSH
115164: CALL 52967 0 2
// x := tmp [ j ] ;
115168: LD_ADDR_VAR 0 10
115172: PUSH
115173: LD_VAR 0 14
115177: PUSH
115178: LD_VAR 0 8
115182: ARRAY
115183: ST_TO_ADDR
// attacking := true ;
115184: LD_ADDR_VAR 0 29
115188: PUSH
115189: LD_INT 1
115191: ST_TO_ADDR
// end ; end ;
115192: GO 115118
115194: POP
115195: POP
// if not x then
115196: LD_VAR 0 10
115200: NOT
115201: IFFALSE 115341
// begin attacking := true ;
115203: LD_ADDR_VAR 0 29
115207: PUSH
115208: LD_INT 1
115210: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
115211: LD_VAR 0 4
115215: PUSH
115216: LD_VAR 0 7
115220: ARRAY
115221: PPUSH
115222: CALL_OW 250
115226: PPUSH
115227: LD_VAR 0 4
115231: PUSH
115232: LD_VAR 0 7
115236: ARRAY
115237: PPUSH
115238: CALL_OW 251
115242: PPUSH
115243: CALL_OW 546
115247: PUSH
115248: LD_INT 2
115250: ARRAY
115251: PUSH
115252: LD_VAR 0 14
115256: PUSH
115257: LD_INT 1
115259: ARRAY
115260: PPUSH
115261: CALL_OW 250
115265: PPUSH
115266: LD_VAR 0 14
115270: PUSH
115271: LD_INT 1
115273: ARRAY
115274: PPUSH
115275: CALL_OW 251
115279: PPUSH
115280: CALL_OW 546
115284: PUSH
115285: LD_INT 2
115287: ARRAY
115288: EQUAL
115289: IFFALSE 115317
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
115291: LD_VAR 0 4
115295: PUSH
115296: LD_VAR 0 7
115300: ARRAY
115301: PPUSH
115302: LD_VAR 0 14
115306: PUSH
115307: LD_INT 1
115309: ARRAY
115310: PPUSH
115311: CALL 52967 0 2
115315: GO 115341
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
115317: LD_VAR 0 4
115321: PUSH
115322: LD_VAR 0 7
115326: ARRAY
115327: PPUSH
115328: LD_VAR 0 14
115332: PUSH
115333: LD_INT 1
115335: ARRAY
115336: PPUSH
115337: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
115341: LD_VAR 0 4
115345: PUSH
115346: LD_VAR 0 7
115350: ARRAY
115351: PPUSH
115352: CALL_OW 264
115356: PUSH
115357: LD_INT 29
115359: EQUAL
115360: IFFALSE 115726
// begin if WantsToAttack ( group [ i ] ) in bombed then
115362: LD_VAR 0 4
115366: PUSH
115367: LD_VAR 0 7
115371: ARRAY
115372: PPUSH
115373: CALL_OW 319
115377: PUSH
115378: LD_VAR 0 28
115382: IN
115383: IFFALSE 115387
// continue ;
115385: GO 112391
// k := 8 ;
115387: LD_ADDR_VAR 0 9
115391: PUSH
115392: LD_INT 8
115394: ST_TO_ADDR
// x := 0 ;
115395: LD_ADDR_VAR 0 10
115399: PUSH
115400: LD_INT 0
115402: ST_TO_ADDR
// if tmp < k then
115403: LD_VAR 0 14
115407: PUSH
115408: LD_VAR 0 9
115412: LESS
115413: IFFALSE 115425
// k := tmp ;
115415: LD_ADDR_VAR 0 9
115419: PUSH
115420: LD_VAR 0 14
115424: ST_TO_ADDR
// for j = 1 to k do
115425: LD_ADDR_VAR 0 8
115429: PUSH
115430: DOUBLE
115431: LD_INT 1
115433: DEC
115434: ST_TO_ADDR
115435: LD_VAR 0 9
115439: PUSH
115440: FOR_TO
115441: IFFALSE 115573
// begin if GetType ( tmp [ j ] ) = unit_building then
115443: LD_VAR 0 14
115447: PUSH
115448: LD_VAR 0 8
115452: ARRAY
115453: PPUSH
115454: CALL_OW 247
115458: PUSH
115459: LD_INT 3
115461: EQUAL
115462: IFFALSE 115571
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
115464: LD_VAR 0 14
115468: PUSH
115469: LD_VAR 0 8
115473: ARRAY
115474: PUSH
115475: LD_VAR 0 28
115479: IN
115480: NOT
115481: PUSH
115482: LD_VAR 0 14
115486: PUSH
115487: LD_VAR 0 8
115491: ARRAY
115492: PPUSH
115493: CALL_OW 313
115497: AND
115498: IFFALSE 115571
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
115500: LD_VAR 0 4
115504: PUSH
115505: LD_VAR 0 7
115509: ARRAY
115510: PPUSH
115511: LD_VAR 0 14
115515: PUSH
115516: LD_VAR 0 8
115520: ARRAY
115521: PPUSH
115522: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
115526: LD_ADDR_VAR 0 28
115530: PUSH
115531: LD_VAR 0 28
115535: PPUSH
115536: LD_VAR 0 28
115540: PUSH
115541: LD_INT 1
115543: PLUS
115544: PPUSH
115545: LD_VAR 0 14
115549: PUSH
115550: LD_VAR 0 8
115554: ARRAY
115555: PPUSH
115556: CALL_OW 1
115560: ST_TO_ADDR
// attacking := true ;
115561: LD_ADDR_VAR 0 29
115565: PUSH
115566: LD_INT 1
115568: ST_TO_ADDR
// break ;
115569: GO 115573
// end ; end ;
115571: GO 115440
115573: POP
115574: POP
// if not attacking and f_attack_depot then
115575: LD_VAR 0 29
115579: NOT
115580: PUSH
115581: LD_VAR 0 25
115585: AND
115586: IFFALSE 115681
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
115588: LD_ADDR_VAR 0 13
115592: PUSH
115593: LD_VAR 0 14
115597: PPUSH
115598: LD_INT 2
115600: PUSH
115601: LD_INT 30
115603: PUSH
115604: LD_INT 0
115606: PUSH
115607: EMPTY
115608: LIST
115609: LIST
115610: PUSH
115611: LD_INT 30
115613: PUSH
115614: LD_INT 1
115616: PUSH
115617: EMPTY
115618: LIST
115619: LIST
115620: PUSH
115621: EMPTY
115622: LIST
115623: LIST
115624: LIST
115625: PPUSH
115626: CALL_OW 72
115630: ST_TO_ADDR
// if z then
115631: LD_VAR 0 13
115635: IFFALSE 115681
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
115637: LD_VAR 0 4
115641: PUSH
115642: LD_VAR 0 7
115646: ARRAY
115647: PPUSH
115648: LD_VAR 0 13
115652: PPUSH
115653: LD_VAR 0 4
115657: PUSH
115658: LD_VAR 0 7
115662: ARRAY
115663: PPUSH
115664: CALL_OW 74
115668: PPUSH
115669: CALL_OW 115
// attacking := true ;
115673: LD_ADDR_VAR 0 29
115677: PUSH
115678: LD_INT 1
115680: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
115681: LD_VAR 0 4
115685: PUSH
115686: LD_VAR 0 7
115690: ARRAY
115691: PPUSH
115692: CALL_OW 256
115696: PUSH
115697: LD_INT 500
115699: LESS
115700: IFFALSE 115726
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
115702: LD_VAR 0 4
115706: PUSH
115707: LD_VAR 0 7
115711: ARRAY
115712: PPUSH
115713: LD_VAR 0 14
115717: PUSH
115718: LD_INT 1
115720: ARRAY
115721: PPUSH
115722: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
115726: LD_VAR 0 4
115730: PUSH
115731: LD_VAR 0 7
115735: ARRAY
115736: PPUSH
115737: CALL_OW 264
115741: PUSH
115742: LD_INT 49
115744: EQUAL
115745: IFFALSE 115866
// begin if not HasTask ( group [ i ] ) then
115747: LD_VAR 0 4
115751: PUSH
115752: LD_VAR 0 7
115756: ARRAY
115757: PPUSH
115758: CALL_OW 314
115762: NOT
115763: IFFALSE 115866
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
115765: LD_ADDR_VAR 0 9
115769: PUSH
115770: LD_INT 81
115772: PUSH
115773: LD_VAR 0 4
115777: PUSH
115778: LD_VAR 0 7
115782: ARRAY
115783: PPUSH
115784: CALL_OW 255
115788: PUSH
115789: EMPTY
115790: LIST
115791: LIST
115792: PPUSH
115793: CALL_OW 69
115797: PPUSH
115798: LD_VAR 0 4
115802: PUSH
115803: LD_VAR 0 7
115807: ARRAY
115808: PPUSH
115809: CALL_OW 74
115813: ST_TO_ADDR
// if k then
115814: LD_VAR 0 9
115818: IFFALSE 115866
// if GetDistUnits ( group [ i ] , k ) > 10 then
115820: LD_VAR 0 4
115824: PUSH
115825: LD_VAR 0 7
115829: ARRAY
115830: PPUSH
115831: LD_VAR 0 9
115835: PPUSH
115836: CALL_OW 296
115840: PUSH
115841: LD_INT 10
115843: GREATER
115844: IFFALSE 115866
// ComMoveUnit ( group [ i ] , k ) ;
115846: LD_VAR 0 4
115850: PUSH
115851: LD_VAR 0 7
115855: ARRAY
115856: PPUSH
115857: LD_VAR 0 9
115861: PPUSH
115862: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
115866: LD_VAR 0 4
115870: PUSH
115871: LD_VAR 0 7
115875: ARRAY
115876: PPUSH
115877: CALL_OW 256
115881: PUSH
115882: LD_INT 250
115884: LESS
115885: PUSH
115886: LD_VAR 0 4
115890: PUSH
115891: LD_VAR 0 7
115895: ARRAY
115896: PUSH
115897: LD_INT 21
115899: PUSH
115900: LD_INT 2
115902: PUSH
115903: EMPTY
115904: LIST
115905: LIST
115906: PUSH
115907: LD_INT 23
115909: PUSH
115910: LD_INT 2
115912: PUSH
115913: EMPTY
115914: LIST
115915: LIST
115916: PUSH
115917: EMPTY
115918: LIST
115919: LIST
115920: PPUSH
115921: CALL_OW 69
115925: IN
115926: AND
115927: IFFALSE 116052
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
115929: LD_ADDR_VAR 0 9
115933: PUSH
115934: LD_OWVAR 3
115938: PUSH
115939: LD_VAR 0 4
115943: PUSH
115944: LD_VAR 0 7
115948: ARRAY
115949: DIFF
115950: PPUSH
115951: LD_VAR 0 4
115955: PUSH
115956: LD_VAR 0 7
115960: ARRAY
115961: PPUSH
115962: CALL_OW 74
115966: ST_TO_ADDR
// if not k then
115967: LD_VAR 0 9
115971: NOT
115972: IFFALSE 115976
// continue ;
115974: GO 112391
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
115976: LD_VAR 0 9
115980: PUSH
115981: LD_INT 81
115983: PUSH
115984: LD_VAR 0 4
115988: PUSH
115989: LD_VAR 0 7
115993: ARRAY
115994: PPUSH
115995: CALL_OW 255
115999: PUSH
116000: EMPTY
116001: LIST
116002: LIST
116003: PPUSH
116004: CALL_OW 69
116008: IN
116009: PUSH
116010: LD_VAR 0 9
116014: PPUSH
116015: LD_VAR 0 4
116019: PUSH
116020: LD_VAR 0 7
116024: ARRAY
116025: PPUSH
116026: CALL_OW 296
116030: PUSH
116031: LD_INT 5
116033: LESS
116034: AND
116035: IFFALSE 116052
// ComAutodestruct ( group [ i ] ) ;
116037: LD_VAR 0 4
116041: PUSH
116042: LD_VAR 0 7
116046: ARRAY
116047: PPUSH
116048: CALL 52865 0 1
// end ; if f_attack_depot then
116052: LD_VAR 0 25
116056: IFFALSE 116168
// begin k := 6 ;
116058: LD_ADDR_VAR 0 9
116062: PUSH
116063: LD_INT 6
116065: ST_TO_ADDR
// if tmp < k then
116066: LD_VAR 0 14
116070: PUSH
116071: LD_VAR 0 9
116075: LESS
116076: IFFALSE 116088
// k := tmp ;
116078: LD_ADDR_VAR 0 9
116082: PUSH
116083: LD_VAR 0 14
116087: ST_TO_ADDR
// for j = 1 to k do
116088: LD_ADDR_VAR 0 8
116092: PUSH
116093: DOUBLE
116094: LD_INT 1
116096: DEC
116097: ST_TO_ADDR
116098: LD_VAR 0 9
116102: PUSH
116103: FOR_TO
116104: IFFALSE 116166
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
116106: LD_VAR 0 8
116110: PPUSH
116111: CALL_OW 266
116115: PUSH
116116: LD_INT 0
116118: PUSH
116119: LD_INT 1
116121: PUSH
116122: EMPTY
116123: LIST
116124: LIST
116125: IN
116126: IFFALSE 116164
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
116128: LD_VAR 0 4
116132: PUSH
116133: LD_VAR 0 7
116137: ARRAY
116138: PPUSH
116139: LD_VAR 0 14
116143: PUSH
116144: LD_VAR 0 8
116148: ARRAY
116149: PPUSH
116150: CALL_OW 115
// attacking := true ;
116154: LD_ADDR_VAR 0 29
116158: PUSH
116159: LD_INT 1
116161: ST_TO_ADDR
// break ;
116162: GO 116166
// end ;
116164: GO 116103
116166: POP
116167: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
116168: LD_VAR 0 4
116172: PUSH
116173: LD_VAR 0 7
116177: ARRAY
116178: PPUSH
116179: CALL_OW 302
116183: PUSH
116184: LD_VAR 0 29
116188: NOT
116189: AND
116190: IFFALSE 116512
// begin if GetTag ( group [ i ] ) = 71 then
116192: LD_VAR 0 4
116196: PUSH
116197: LD_VAR 0 7
116201: ARRAY
116202: PPUSH
116203: CALL_OW 110
116207: PUSH
116208: LD_INT 71
116210: EQUAL
116211: IFFALSE 116252
// begin if HasTask ( group [ i ] ) then
116213: LD_VAR 0 4
116217: PUSH
116218: LD_VAR 0 7
116222: ARRAY
116223: PPUSH
116224: CALL_OW 314
116228: IFFALSE 116234
// continue else
116230: GO 112391
116232: GO 116252
// SetTag ( group [ i ] , 0 ) ;
116234: LD_VAR 0 4
116238: PUSH
116239: LD_VAR 0 7
116243: ARRAY
116244: PPUSH
116245: LD_INT 0
116247: PPUSH
116248: CALL_OW 109
// end ; k := 8 ;
116252: LD_ADDR_VAR 0 9
116256: PUSH
116257: LD_INT 8
116259: ST_TO_ADDR
// x := 0 ;
116260: LD_ADDR_VAR 0 10
116264: PUSH
116265: LD_INT 0
116267: ST_TO_ADDR
// if tmp < k then
116268: LD_VAR 0 14
116272: PUSH
116273: LD_VAR 0 9
116277: LESS
116278: IFFALSE 116290
// k := tmp ;
116280: LD_ADDR_VAR 0 9
116284: PUSH
116285: LD_VAR 0 14
116289: ST_TO_ADDR
// for j = 1 to k do
116290: LD_ADDR_VAR 0 8
116294: PUSH
116295: DOUBLE
116296: LD_INT 1
116298: DEC
116299: ST_TO_ADDR
116300: LD_VAR 0 9
116304: PUSH
116305: FOR_TO
116306: IFFALSE 116404
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
116308: LD_VAR 0 14
116312: PUSH
116313: LD_VAR 0 8
116317: ARRAY
116318: PPUSH
116319: CALL_OW 247
116323: PUSH
116324: LD_INT 1
116326: EQUAL
116327: PUSH
116328: LD_VAR 0 14
116332: PUSH
116333: LD_VAR 0 8
116337: ARRAY
116338: PPUSH
116339: CALL_OW 256
116343: PUSH
116344: LD_INT 250
116346: LESS
116347: PUSH
116348: LD_VAR 0 20
116352: AND
116353: PUSH
116354: LD_VAR 0 20
116358: NOT
116359: PUSH
116360: LD_VAR 0 14
116364: PUSH
116365: LD_VAR 0 8
116369: ARRAY
116370: PPUSH
116371: CALL_OW 256
116375: PUSH
116376: LD_INT 250
116378: GREATEREQUAL
116379: AND
116380: OR
116381: AND
116382: IFFALSE 116402
// begin x := tmp [ j ] ;
116384: LD_ADDR_VAR 0 10
116388: PUSH
116389: LD_VAR 0 14
116393: PUSH
116394: LD_VAR 0 8
116398: ARRAY
116399: ST_TO_ADDR
// break ;
116400: GO 116404
// end ;
116402: GO 116305
116404: POP
116405: POP
// if x then
116406: LD_VAR 0 10
116410: IFFALSE 116434
// ComAttackUnit ( group [ i ] , x ) else
116412: LD_VAR 0 4
116416: PUSH
116417: LD_VAR 0 7
116421: ARRAY
116422: PPUSH
116423: LD_VAR 0 10
116427: PPUSH
116428: CALL_OW 115
116432: GO 116458
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
116434: LD_VAR 0 4
116438: PUSH
116439: LD_VAR 0 7
116443: ARRAY
116444: PPUSH
116445: LD_VAR 0 14
116449: PUSH
116450: LD_INT 1
116452: ARRAY
116453: PPUSH
116454: CALL_OW 115
// if not HasTask ( group [ i ] ) then
116458: LD_VAR 0 4
116462: PUSH
116463: LD_VAR 0 7
116467: ARRAY
116468: PPUSH
116469: CALL_OW 314
116473: NOT
116474: IFFALSE 116512
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
116476: LD_VAR 0 4
116480: PUSH
116481: LD_VAR 0 7
116485: ARRAY
116486: PPUSH
116487: LD_VAR 0 14
116491: PPUSH
116492: LD_VAR 0 4
116496: PUSH
116497: LD_VAR 0 7
116501: ARRAY
116502: PPUSH
116503: CALL_OW 74
116507: PPUSH
116508: CALL_OW 115
// end ; end ; end ;
116512: GO 112391
116514: POP
116515: POP
// wait ( 0 0$2 ) ;
116516: LD_INT 70
116518: PPUSH
116519: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
116523: LD_VAR 0 4
116527: NOT
116528: PUSH
116529: LD_VAR 0 4
116533: PUSH
116534: EMPTY
116535: EQUAL
116536: OR
116537: PUSH
116538: LD_INT 81
116540: PUSH
116541: LD_VAR 0 35
116545: PUSH
116546: EMPTY
116547: LIST
116548: LIST
116549: PPUSH
116550: CALL_OW 69
116554: NOT
116555: OR
116556: IFFALSE 112376
// end ;
116558: LD_VAR 0 2
116562: RET
// export function BasicDefend ( base , solds ) ; var enemy , e , side , i , hex ; begin
116563: LD_INT 0
116565: PPUSH
116566: PPUSH
116567: PPUSH
116568: PPUSH
116569: PPUSH
116570: PPUSH
// if not base or not mc_bases [ base ] or not solds then
116571: LD_VAR 0 1
116575: NOT
116576: PUSH
116577: LD_EXP 31
116581: PUSH
116582: LD_VAR 0 1
116586: ARRAY
116587: NOT
116588: OR
116589: PUSH
116590: LD_VAR 0 2
116594: NOT
116595: OR
116596: IFFALSE 116600
// exit ;
116598: GO 117154
// side := mc_sides [ base ] ;
116600: LD_ADDR_VAR 0 6
116604: PUSH
116605: LD_EXP 57
116609: PUSH
116610: LD_VAR 0 1
116614: ARRAY
116615: ST_TO_ADDR
// if not side then
116616: LD_VAR 0 6
116620: NOT
116621: IFFALSE 116625
// exit ;
116623: GO 117154
// for i in solds do
116625: LD_ADDR_VAR 0 7
116629: PUSH
116630: LD_VAR 0 2
116634: PUSH
116635: FOR_IN
116636: IFFALSE 116697
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
116638: LD_VAR 0 7
116642: PPUSH
116643: CALL_OW 310
116647: PPUSH
116648: CALL_OW 266
116652: PUSH
116653: LD_INT 32
116655: PUSH
116656: LD_INT 31
116658: PUSH
116659: EMPTY
116660: LIST
116661: LIST
116662: IN
116663: IFFALSE 116683
// solds := solds diff i else
116665: LD_ADDR_VAR 0 2
116669: PUSH
116670: LD_VAR 0 2
116674: PUSH
116675: LD_VAR 0 7
116679: DIFF
116680: ST_TO_ADDR
116681: GO 116695
// SetTag ( i , 18 ) ;
116683: LD_VAR 0 7
116687: PPUSH
116688: LD_INT 18
116690: PPUSH
116691: CALL_OW 109
116695: GO 116635
116697: POP
116698: POP
// if not solds then
116699: LD_VAR 0 2
116703: NOT
116704: IFFALSE 116708
// exit ;
116706: GO 117154
// repeat wait ( 0 0$2 ) ;
116708: LD_INT 70
116710: PPUSH
116711: CALL_OW 67
// enemy := mc_scan [ base ] ;
116715: LD_ADDR_VAR 0 4
116719: PUSH
116720: LD_EXP 54
116724: PUSH
116725: LD_VAR 0 1
116729: ARRAY
116730: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
116731: LD_EXP 31
116735: PUSH
116736: LD_VAR 0 1
116740: ARRAY
116741: NOT
116742: PUSH
116743: LD_EXP 31
116747: PUSH
116748: LD_VAR 0 1
116752: ARRAY
116753: PUSH
116754: EMPTY
116755: EQUAL
116756: OR
116757: IFFALSE 116794
// begin for i in solds do
116759: LD_ADDR_VAR 0 7
116763: PUSH
116764: LD_VAR 0 2
116768: PUSH
116769: FOR_IN
116770: IFFALSE 116783
// ComStop ( i ) ;
116772: LD_VAR 0 7
116776: PPUSH
116777: CALL_OW 141
116781: GO 116769
116783: POP
116784: POP
// solds := [ ] ;
116785: LD_ADDR_VAR 0 2
116789: PUSH
116790: EMPTY
116791: ST_TO_ADDR
// exit ;
116792: GO 117154
// end ; for i in solds do
116794: LD_ADDR_VAR 0 7
116798: PUSH
116799: LD_VAR 0 2
116803: PUSH
116804: FOR_IN
116805: IFFALSE 117126
// begin if IsInUnit ( i ) then
116807: LD_VAR 0 7
116811: PPUSH
116812: CALL_OW 310
116816: IFFALSE 116827
// ComExitBuilding ( i ) ;
116818: LD_VAR 0 7
116822: PPUSH
116823: CALL_OW 122
// if GetLives ( i ) > 500 then
116827: LD_VAR 0 7
116831: PPUSH
116832: CALL_OW 256
116836: PUSH
116837: LD_INT 500
116839: GREATER
116840: IFFALSE 116893
// begin e := NearestUnitToUnit ( enemy , i ) ;
116842: LD_ADDR_VAR 0 5
116846: PUSH
116847: LD_VAR 0 4
116851: PPUSH
116852: LD_VAR 0 7
116856: PPUSH
116857: CALL_OW 74
116861: ST_TO_ADDR
// ComAgressiveMove ( i , GetX ( e ) , GetY ( e ) ) ;
116862: LD_VAR 0 7
116866: PPUSH
116867: LD_VAR 0 5
116871: PPUSH
116872: CALL_OW 250
116876: PPUSH
116877: LD_VAR 0 5
116881: PPUSH
116882: CALL_OW 251
116886: PPUSH
116887: CALL_OW 114
// end else
116891: GO 117124
// if GetDistUnits ( i , NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ) > 10 then
116893: LD_VAR 0 7
116897: PPUSH
116898: LD_EXP 31
116902: PUSH
116903: LD_VAR 0 1
116907: ARRAY
116908: PPUSH
116909: LD_INT 2
116911: PUSH
116912: LD_INT 30
116914: PUSH
116915: LD_INT 0
116917: PUSH
116918: EMPTY
116919: LIST
116920: LIST
116921: PUSH
116922: LD_INT 30
116924: PUSH
116925: LD_INT 1
116927: PUSH
116928: EMPTY
116929: LIST
116930: LIST
116931: PUSH
116932: LD_INT 30
116934: PUSH
116935: LD_INT 6
116937: PUSH
116938: EMPTY
116939: LIST
116940: LIST
116941: PUSH
116942: EMPTY
116943: LIST
116944: LIST
116945: LIST
116946: LIST
116947: PPUSH
116948: CALL_OW 72
116952: PPUSH
116953: LD_VAR 0 7
116957: PPUSH
116958: CALL_OW 74
116962: PPUSH
116963: CALL_OW 296
116967: PUSH
116968: LD_INT 10
116970: GREATER
116971: IFFALSE 117124
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
116973: LD_ADDR_VAR 0 8
116977: PUSH
116978: LD_EXP 31
116982: PUSH
116983: LD_VAR 0 1
116987: ARRAY
116988: PPUSH
116989: LD_INT 2
116991: PUSH
116992: LD_INT 30
116994: PUSH
116995: LD_INT 0
116997: PUSH
116998: EMPTY
116999: LIST
117000: LIST
117001: PUSH
117002: LD_INT 30
117004: PUSH
117005: LD_INT 1
117007: PUSH
117008: EMPTY
117009: LIST
117010: LIST
117011: PUSH
117012: LD_INT 30
117014: PUSH
117015: LD_INT 6
117017: PUSH
117018: EMPTY
117019: LIST
117020: LIST
117021: PUSH
117022: EMPTY
117023: LIST
117024: LIST
117025: LIST
117026: LIST
117027: PPUSH
117028: CALL_OW 72
117032: PPUSH
117033: LD_VAR 0 7
117037: PPUSH
117038: CALL_OW 74
117042: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
117043: LD_VAR 0 7
117047: PPUSH
117048: LD_VAR 0 8
117052: PPUSH
117053: CALL_OW 250
117057: PPUSH
117058: LD_INT 3
117060: PPUSH
117061: LD_INT 5
117063: PPUSH
117064: CALL_OW 272
117068: PPUSH
117069: LD_VAR 0 8
117073: PPUSH
117074: CALL_OW 251
117078: PPUSH
117079: LD_INT 3
117081: PPUSH
117082: LD_INT 5
117084: PPUSH
117085: CALL_OW 273
117089: PPUSH
117090: CALL_OW 111
// SetTag ( i , 0 ) ;
117094: LD_VAR 0 7
117098: PPUSH
117099: LD_INT 0
117101: PPUSH
117102: CALL_OW 109
// solds := solds diff i ;
117106: LD_ADDR_VAR 0 2
117110: PUSH
117111: LD_VAR 0 2
117115: PUSH
117116: LD_VAR 0 7
117120: DIFF
117121: ST_TO_ADDR
// continue ;
117122: GO 116804
// end ; end ;
117124: GO 116804
117126: POP
117127: POP
// until not solds or not enemy ;
117128: LD_VAR 0 2
117132: NOT
117133: PUSH
117134: LD_VAR 0 4
117138: NOT
117139: OR
117140: IFFALSE 116708
// MC_Reset ( base , 18 ) ;
117142: LD_VAR 0 1
117146: PPUSH
117147: LD_INT 18
117149: PPUSH
117150: CALL 65413 0 2
// end ;
117154: LD_VAR 0 3
117158: RET
// export function Defend ( base , defenders ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend , class , enemy ; begin
117159: LD_INT 0
117161: PPUSH
117162: PPUSH
117163: PPUSH
117164: PPUSH
117165: PPUSH
117166: PPUSH
117167: PPUSH
117168: PPUSH
117169: PPUSH
117170: PPUSH
117171: PPUSH
117172: PPUSH
117173: PPUSH
117174: PPUSH
117175: PPUSH
117176: PPUSH
117177: PPUSH
117178: PPUSH
117179: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
117180: LD_ADDR_VAR 0 12
117184: PUSH
117185: LD_EXP 31
117189: PUSH
117190: LD_VAR 0 1
117194: ARRAY
117195: PPUSH
117196: LD_INT 25
117198: PUSH
117199: LD_INT 3
117201: PUSH
117202: EMPTY
117203: LIST
117204: LIST
117205: PPUSH
117206: CALL_OW 72
117210: ST_TO_ADDR
// if mc_remote_driver [ base ] then
117211: LD_EXP 71
117215: PUSH
117216: LD_VAR 0 1
117220: ARRAY
117221: IFFALSE 117245
// mechs := mechs diff mc_remote_driver [ base ] ;
117223: LD_ADDR_VAR 0 12
117227: PUSH
117228: LD_VAR 0 12
117232: PUSH
117233: LD_EXP 71
117237: PUSH
117238: LD_VAR 0 1
117242: ARRAY
117243: DIFF
117244: ST_TO_ADDR
// for i in mechs do
117245: LD_ADDR_VAR 0 4
117249: PUSH
117250: LD_VAR 0 12
117254: PUSH
117255: FOR_IN
117256: IFFALSE 117291
// if GetTag ( i ) > 0 then
117258: LD_VAR 0 4
117262: PPUSH
117263: CALL_OW 110
117267: PUSH
117268: LD_INT 0
117270: GREATER
117271: IFFALSE 117289
// mechs := mechs diff i ;
117273: LD_ADDR_VAR 0 12
117277: PUSH
117278: LD_VAR 0 12
117282: PUSH
117283: LD_VAR 0 4
117287: DIFF
117288: ST_TO_ADDR
117289: GO 117255
117291: POP
117292: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
117293: LD_ADDR_VAR 0 8
117297: PUSH
117298: LD_EXP 31
117302: PUSH
117303: LD_VAR 0 1
117307: ARRAY
117308: PPUSH
117309: LD_INT 2
117311: PUSH
117312: LD_INT 25
117314: PUSH
117315: LD_INT 1
117317: PUSH
117318: EMPTY
117319: LIST
117320: LIST
117321: PUSH
117322: LD_INT 25
117324: PUSH
117325: LD_INT 5
117327: PUSH
117328: EMPTY
117329: LIST
117330: LIST
117331: PUSH
117332: LD_INT 25
117334: PUSH
117335: LD_INT 8
117337: PUSH
117338: EMPTY
117339: LIST
117340: LIST
117341: PUSH
117342: LD_INT 25
117344: PUSH
117345: LD_INT 9
117347: PUSH
117348: EMPTY
117349: LIST
117350: LIST
117351: PUSH
117352: EMPTY
117353: LIST
117354: LIST
117355: LIST
117356: LIST
117357: LIST
117358: PPUSH
117359: CALL_OW 72
117363: ST_TO_ADDR
// if not defenders and not solds then
117364: LD_VAR 0 2
117368: NOT
117369: PUSH
117370: LD_VAR 0 8
117374: NOT
117375: AND
117376: IFFALSE 117380
// exit ;
117378: GO 119150
// depot_under_attack := false ;
117380: LD_ADDR_VAR 0 16
117384: PUSH
117385: LD_INT 0
117387: ST_TO_ADDR
// sold_defenders := [ ] ;
117388: LD_ADDR_VAR 0 17
117392: PUSH
117393: EMPTY
117394: ST_TO_ADDR
// if mechs then
117395: LD_VAR 0 12
117399: IFFALSE 117552
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
117401: LD_ADDR_VAR 0 4
117405: PUSH
117406: LD_VAR 0 2
117410: PPUSH
117411: LD_INT 21
117413: PUSH
117414: LD_INT 2
117416: PUSH
117417: EMPTY
117418: LIST
117419: LIST
117420: PPUSH
117421: CALL_OW 72
117425: PUSH
117426: FOR_IN
117427: IFFALSE 117550
// begin if GetTag ( i ) <> 20 then
117429: LD_VAR 0 4
117433: PPUSH
117434: CALL_OW 110
117438: PUSH
117439: LD_INT 20
117441: NONEQUAL
117442: IFFALSE 117456
// SetTag ( i , 20 ) ;
117444: LD_VAR 0 4
117448: PPUSH
117449: LD_INT 20
117451: PPUSH
117452: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
117456: LD_VAR 0 4
117460: PPUSH
117461: CALL_OW 263
117465: PUSH
117466: LD_INT 1
117468: EQUAL
117469: PUSH
117470: LD_VAR 0 4
117474: PPUSH
117475: CALL_OW 311
117479: NOT
117480: AND
117481: IFFALSE 117548
// begin un := mechs [ 1 ] ;
117483: LD_ADDR_VAR 0 10
117487: PUSH
117488: LD_VAR 0 12
117492: PUSH
117493: LD_INT 1
117495: ARRAY
117496: ST_TO_ADDR
// ComExit ( un ) ;
117497: LD_VAR 0 10
117501: PPUSH
117502: CALL 57731 0 1
// AddComEnterUnit ( un , i ) ;
117506: LD_VAR 0 10
117510: PPUSH
117511: LD_VAR 0 4
117515: PPUSH
117516: CALL_OW 180
// SetTag ( un , 19 ) ;
117520: LD_VAR 0 10
117524: PPUSH
117525: LD_INT 19
117527: PPUSH
117528: CALL_OW 109
// mechs := mechs diff un ;
117532: LD_ADDR_VAR 0 12
117536: PUSH
117537: LD_VAR 0 12
117541: PUSH
117542: LD_VAR 0 10
117546: DIFF
117547: ST_TO_ADDR
// end ; end ;
117548: GO 117426
117550: POP
117551: POP
// if solds then
117552: LD_VAR 0 8
117556: IFFALSE 117615
// for i in solds do
117558: LD_ADDR_VAR 0 4
117562: PUSH
117563: LD_VAR 0 8
117567: PUSH
117568: FOR_IN
117569: IFFALSE 117613
// if not GetTag ( i ) then
117571: LD_VAR 0 4
117575: PPUSH
117576: CALL_OW 110
117580: NOT
117581: IFFALSE 117611
// begin defenders := defenders union i ;
117583: LD_ADDR_VAR 0 2
117587: PUSH
117588: LD_VAR 0 2
117592: PUSH
117593: LD_VAR 0 4
117597: UNION
117598: ST_TO_ADDR
// SetTag ( i , 18 ) ;
117599: LD_VAR 0 4
117603: PPUSH
117604: LD_INT 18
117606: PPUSH
117607: CALL_OW 109
// end ;
117611: GO 117568
117613: POP
117614: POP
// repeat wait ( 0 0$2 ) ;
117615: LD_INT 70
117617: PPUSH
117618: CALL_OW 67
// enemy := mc_scan [ base ] ;
117622: LD_ADDR_VAR 0 21
117626: PUSH
117627: LD_EXP 54
117631: PUSH
117632: LD_VAR 0 1
117636: ARRAY
117637: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
117638: LD_EXP 31
117642: PUSH
117643: LD_VAR 0 1
117647: ARRAY
117648: NOT
117649: PUSH
117650: LD_EXP 31
117654: PUSH
117655: LD_VAR 0 1
117659: ARRAY
117660: PUSH
117661: EMPTY
117662: EQUAL
117663: OR
117664: IFFALSE 117701
// begin for i in defenders do
117666: LD_ADDR_VAR 0 4
117670: PUSH
117671: LD_VAR 0 2
117675: PUSH
117676: FOR_IN
117677: IFFALSE 117690
// ComStop ( i ) ;
117679: LD_VAR 0 4
117683: PPUSH
117684: CALL_OW 141
117688: GO 117676
117690: POP
117691: POP
// defenders := [ ] ;
117692: LD_ADDR_VAR 0 2
117696: PUSH
117697: EMPTY
117698: ST_TO_ADDR
// exit ;
117699: GO 119150
// end ; for i in defenders do
117701: LD_ADDR_VAR 0 4
117705: PUSH
117706: LD_VAR 0 2
117710: PUSH
117711: FOR_IN
117712: IFFALSE 118610
// begin e := NearestUnitToUnit ( enemy , i ) ;
117714: LD_ADDR_VAR 0 13
117718: PUSH
117719: LD_VAR 0 21
117723: PPUSH
117724: LD_VAR 0 4
117728: PPUSH
117729: CALL_OW 74
117733: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
117734: LD_ADDR_VAR 0 7
117738: PUSH
117739: LD_EXP 31
117743: PUSH
117744: LD_VAR 0 1
117748: ARRAY
117749: PPUSH
117750: LD_INT 2
117752: PUSH
117753: LD_INT 30
117755: PUSH
117756: LD_INT 0
117758: PUSH
117759: EMPTY
117760: LIST
117761: LIST
117762: PUSH
117763: LD_INT 30
117765: PUSH
117766: LD_INT 1
117768: PUSH
117769: EMPTY
117770: LIST
117771: LIST
117772: PUSH
117773: EMPTY
117774: LIST
117775: LIST
117776: LIST
117777: PPUSH
117778: CALL_OW 72
117782: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
117783: LD_ADDR_VAR 0 16
117787: PUSH
117788: LD_VAR 0 7
117792: NOT
117793: PUSH
117794: LD_VAR 0 7
117798: PPUSH
117799: LD_INT 3
117801: PUSH
117802: LD_INT 24
117804: PUSH
117805: LD_INT 600
117807: PUSH
117808: EMPTY
117809: LIST
117810: LIST
117811: PUSH
117812: EMPTY
117813: LIST
117814: LIST
117815: PPUSH
117816: CALL_OW 72
117820: OR
117821: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
117822: LD_VAR 0 4
117826: PPUSH
117827: CALL_OW 247
117831: PUSH
117832: LD_INT 2
117834: DOUBLE
117835: EQUAL
117836: IFTRUE 117840
117838: GO 118236
117840: POP
// begin if GetLives ( i ) = 1000 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
117841: LD_VAR 0 4
117845: PPUSH
117846: CALL_OW 256
117850: PUSH
117851: LD_INT 1000
117853: EQUAL
117854: PUSH
117855: LD_VAR 0 4
117859: PPUSH
117860: LD_VAR 0 13
117864: PPUSH
117865: CALL_OW 296
117869: PUSH
117870: LD_INT 40
117872: LESS
117873: PUSH
117874: LD_VAR 0 13
117878: PPUSH
117879: LD_EXP 56
117883: PUSH
117884: LD_VAR 0 1
117888: ARRAY
117889: PPUSH
117890: CALL_OW 308
117894: OR
117895: AND
117896: IFFALSE 118018
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
117898: LD_VAR 0 4
117902: PPUSH
117903: CALL_OW 262
117907: PUSH
117908: LD_INT 1
117910: EQUAL
117911: PUSH
117912: LD_VAR 0 4
117916: PPUSH
117917: CALL_OW 261
117921: PUSH
117922: LD_INT 30
117924: LESS
117925: AND
117926: PUSH
117927: LD_VAR 0 7
117931: AND
117932: IFFALSE 118002
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
117934: LD_VAR 0 4
117938: PPUSH
117939: LD_VAR 0 7
117943: PPUSH
117944: LD_VAR 0 4
117948: PPUSH
117949: CALL_OW 74
117953: PPUSH
117954: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
117958: LD_VAR 0 4
117962: PPUSH
117963: LD_VAR 0 7
117967: PPUSH
117968: LD_VAR 0 4
117972: PPUSH
117973: CALL_OW 74
117977: PPUSH
117978: CALL_OW 296
117982: PUSH
117983: LD_INT 6
117985: LESS
117986: IFFALSE 118000
// SetFuel ( i , 100 ) ;
117988: LD_VAR 0 4
117992: PPUSH
117993: LD_INT 100
117995: PPUSH
117996: CALL_OW 240
// end else
118000: GO 118016
// ComAttackUnit ( i , e ) ;
118002: LD_VAR 0 4
118006: PPUSH
118007: LD_VAR 0 13
118011: PPUSH
118012: CALL_OW 115
// end else
118016: GO 118119
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
118018: LD_VAR 0 13
118022: PPUSH
118023: LD_EXP 56
118027: PUSH
118028: LD_VAR 0 1
118032: ARRAY
118033: PPUSH
118034: CALL_OW 308
118038: NOT
118039: PUSH
118040: LD_VAR 0 4
118044: PPUSH
118045: LD_VAR 0 13
118049: PPUSH
118050: CALL_OW 296
118054: PUSH
118055: LD_INT 40
118057: GREATEREQUAL
118058: AND
118059: PUSH
118060: LD_VAR 0 4
118064: PPUSH
118065: CALL_OW 256
118069: PUSH
118070: LD_INT 650
118072: LESSEQUAL
118073: OR
118074: PUSH
118075: LD_VAR 0 4
118079: PPUSH
118080: LD_EXP 55
118084: PUSH
118085: LD_VAR 0 1
118089: ARRAY
118090: PPUSH
118091: CALL_OW 308
118095: NOT
118096: AND
118097: IFFALSE 118119
// ComMoveToArea ( i , mc_parking [ base ] ) ;
118099: LD_VAR 0 4
118103: PPUSH
118104: LD_EXP 55
118108: PUSH
118109: LD_VAR 0 1
118113: ARRAY
118114: PPUSH
118115: CALL_OW 113
// if GetLives ( i ) < 1000 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
118119: LD_VAR 0 4
118123: PPUSH
118124: CALL_OW 256
118128: PUSH
118129: LD_INT 1000
118131: LESS
118132: PUSH
118133: LD_VAR 0 4
118137: PPUSH
118138: CALL_OW 263
118142: PUSH
118143: LD_INT 1
118145: EQUAL
118146: AND
118147: PUSH
118148: LD_VAR 0 4
118152: PPUSH
118153: CALL_OW 311
118157: AND
118158: PUSH
118159: LD_VAR 0 4
118163: PPUSH
118164: LD_EXP 55
118168: PUSH
118169: LD_VAR 0 1
118173: ARRAY
118174: PPUSH
118175: CALL_OW 308
118179: AND
118180: IFFALSE 118234
// begin mech := IsDrivenBy ( i ) ;
118182: LD_ADDR_VAR 0 9
118186: PUSH
118187: LD_VAR 0 4
118191: PPUSH
118192: CALL_OW 311
118196: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
118197: LD_VAR 0 9
118201: PPUSH
118202: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
118206: LD_VAR 0 9
118210: PPUSH
118211: LD_VAR 0 4
118215: PPUSH
118216: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
118220: LD_VAR 0 9
118224: PPUSH
118225: LD_VAR 0 4
118229: PPUSH
118230: CALL_OW 180
// end ; end ; unit_human :
118234: GO 118581
118236: LD_INT 1
118238: DOUBLE
118239: EQUAL
118240: IFTRUE 118244
118242: GO 118580
118244: POP
// begin b := IsInUnit ( i ) ;
118245: LD_ADDR_VAR 0 18
118249: PUSH
118250: LD_VAR 0 4
118254: PPUSH
118255: CALL_OW 310
118259: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
118260: LD_ADDR_VAR 0 19
118264: PUSH
118265: LD_VAR 0 18
118269: NOT
118270: PUSH
118271: LD_VAR 0 18
118275: PPUSH
118276: CALL_OW 266
118280: PUSH
118281: LD_INT 32
118283: PUSH
118284: LD_INT 31
118286: PUSH
118287: EMPTY
118288: LIST
118289: LIST
118290: IN
118291: OR
118292: ST_TO_ADDR
// if GetBType ( b ) = b_barracks and GetClass ( i ) in [ 1 , 2 , 3 , 4 ] then
118293: LD_VAR 0 18
118297: PPUSH
118298: CALL_OW 266
118302: PUSH
118303: LD_INT 5
118305: EQUAL
118306: PUSH
118307: LD_VAR 0 4
118311: PPUSH
118312: CALL_OW 257
118316: PUSH
118317: LD_INT 1
118319: PUSH
118320: LD_INT 2
118322: PUSH
118323: LD_INT 3
118325: PUSH
118326: LD_INT 4
118328: PUSH
118329: EMPTY
118330: LIST
118331: LIST
118332: LIST
118333: LIST
118334: IN
118335: AND
118336: IFFALSE 118373
// begin class := AllowSpecClass ( i ) ;
118338: LD_ADDR_VAR 0 20
118342: PUSH
118343: LD_VAR 0 4
118347: PPUSH
118348: CALL 21670 0 1
118352: ST_TO_ADDR
// if class then
118353: LD_VAR 0 20
118357: IFFALSE 118373
// ComChangeProfession ( i , class ) ;
118359: LD_VAR 0 4
118363: PPUSH
118364: LD_VAR 0 20
118368: PPUSH
118369: CALL_OW 123
// end ; if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
118373: LD_VAR 0 16
118377: PUSH
118378: LD_VAR 0 2
118382: PPUSH
118383: LD_INT 21
118385: PUSH
118386: LD_INT 2
118388: PUSH
118389: EMPTY
118390: LIST
118391: LIST
118392: PPUSH
118393: CALL_OW 72
118397: PUSH
118398: LD_INT 1
118400: LESSEQUAL
118401: OR
118402: PUSH
118403: LD_VAR 0 19
118407: AND
118408: PUSH
118409: LD_VAR 0 4
118413: PUSH
118414: LD_VAR 0 17
118418: IN
118419: NOT
118420: AND
118421: IFFALSE 118514
// begin if b then
118423: LD_VAR 0 18
118427: IFFALSE 118476
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
118429: LD_VAR 0 18
118433: PPUSH
118434: LD_VAR 0 21
118438: PPUSH
118439: LD_VAR 0 18
118443: PPUSH
118444: CALL_OW 74
118448: PPUSH
118449: CALL_OW 296
118453: PUSH
118454: LD_INT 10
118456: LESS
118457: PUSH
118458: LD_VAR 0 18
118462: PPUSH
118463: CALL_OW 461
118467: PUSH
118468: LD_INT 7
118470: NONEQUAL
118471: AND
118472: IFFALSE 118476
// continue ;
118474: GO 117711
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
118476: LD_ADDR_VAR 0 17
118480: PUSH
118481: LD_VAR 0 17
118485: PPUSH
118486: LD_VAR 0 17
118490: PUSH
118491: LD_INT 1
118493: PLUS
118494: PPUSH
118495: LD_VAR 0 4
118499: PPUSH
118500: CALL_OW 1
118504: ST_TO_ADDR
// ComExitBuilding ( i ) ;
118505: LD_VAR 0 4
118509: PPUSH
118510: CALL_OW 122
// end ; if sold_defenders then
118514: LD_VAR 0 17
118518: IFFALSE 118578
// if i in sold_defenders then
118520: LD_VAR 0 4
118524: PUSH
118525: LD_VAR 0 17
118529: IN
118530: IFFALSE 118578
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
118532: LD_VAR 0 4
118536: PPUSH
118537: CALL_OW 314
118541: NOT
118542: PUSH
118543: LD_VAR 0 4
118547: PPUSH
118548: LD_VAR 0 13
118552: PPUSH
118553: CALL_OW 296
118557: PUSH
118558: LD_INT 30
118560: LESS
118561: AND
118562: IFFALSE 118578
// ComAttackUnit ( i , e ) ;
118564: LD_VAR 0 4
118568: PPUSH
118569: LD_VAR 0 13
118573: PPUSH
118574: CALL_OW 115
// end ; end ; end ;
118578: GO 118581
118580: POP
// if IsDead ( i ) then
118581: LD_VAR 0 4
118585: PPUSH
118586: CALL_OW 301
118590: IFFALSE 118608
// defenders := defenders diff i ;
118592: LD_ADDR_VAR 0 2
118596: PUSH
118597: LD_VAR 0 2
118601: PUSH
118602: LD_VAR 0 4
118606: DIFF
118607: ST_TO_ADDR
// end ;
118608: GO 117711
118610: POP
118611: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
118612: LD_VAR 0 21
118616: NOT
118617: PUSH
118618: LD_VAR 0 2
118622: NOT
118623: OR
118624: PUSH
118625: LD_EXP 31
118629: PUSH
118630: LD_VAR 0 1
118634: ARRAY
118635: NOT
118636: OR
118637: IFFALSE 117615
// MC_Reset ( base , 18 ) ;
118639: LD_VAR 0 1
118643: PPUSH
118644: LD_INT 18
118646: PPUSH
118647: CALL 65413 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
118651: LD_ADDR_VAR 0 2
118655: PUSH
118656: LD_VAR 0 2
118660: PUSH
118661: LD_VAR 0 2
118665: PPUSH
118666: LD_INT 2
118668: PUSH
118669: LD_INT 25
118671: PUSH
118672: LD_INT 1
118674: PUSH
118675: EMPTY
118676: LIST
118677: LIST
118678: PUSH
118679: LD_INT 25
118681: PUSH
118682: LD_INT 5
118684: PUSH
118685: EMPTY
118686: LIST
118687: LIST
118688: PUSH
118689: LD_INT 25
118691: PUSH
118692: LD_INT 8
118694: PUSH
118695: EMPTY
118696: LIST
118697: LIST
118698: PUSH
118699: LD_INT 25
118701: PUSH
118702: LD_INT 9
118704: PUSH
118705: EMPTY
118706: LIST
118707: LIST
118708: PUSH
118709: EMPTY
118710: LIST
118711: LIST
118712: LIST
118713: LIST
118714: LIST
118715: PPUSH
118716: CALL_OW 72
118720: DIFF
118721: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
118722: LD_VAR 0 21
118726: NOT
118727: PUSH
118728: LD_VAR 0 2
118732: PPUSH
118733: LD_INT 21
118735: PUSH
118736: LD_INT 2
118738: PUSH
118739: EMPTY
118740: LIST
118741: LIST
118742: PPUSH
118743: CALL_OW 72
118747: AND
118748: IFFALSE 119086
// begin tmp := FilterByTag ( defenders , 19 ) ;
118750: LD_ADDR_VAR 0 11
118754: PUSH
118755: LD_VAR 0 2
118759: PPUSH
118760: LD_INT 19
118762: PPUSH
118763: CALL 54907 0 2
118767: ST_TO_ADDR
// if tmp then
118768: LD_VAR 0 11
118772: IFFALSE 118842
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
118774: LD_ADDR_VAR 0 11
118778: PUSH
118779: LD_VAR 0 11
118783: PPUSH
118784: LD_INT 25
118786: PUSH
118787: LD_INT 3
118789: PUSH
118790: EMPTY
118791: LIST
118792: LIST
118793: PPUSH
118794: CALL_OW 72
118798: ST_TO_ADDR
// if tmp then
118799: LD_VAR 0 11
118803: IFFALSE 118842
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
118805: LD_ADDR_EXP 43
118809: PUSH
118810: LD_EXP 43
118814: PPUSH
118815: LD_VAR 0 1
118819: PPUSH
118820: LD_EXP 43
118824: PUSH
118825: LD_VAR 0 1
118829: ARRAY
118830: PUSH
118831: LD_VAR 0 11
118835: UNION
118836: PPUSH
118837: CALL_OW 1
118841: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
118842: LD_VAR 0 1
118846: PPUSH
118847: LD_INT 19
118849: PPUSH
118850: CALL 65413 0 2
// repeat wait ( 0 0$1 ) ;
118854: LD_INT 35
118856: PPUSH
118857: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
118861: LD_EXP 31
118865: PUSH
118866: LD_VAR 0 1
118870: ARRAY
118871: NOT
118872: PUSH
118873: LD_EXP 31
118877: PUSH
118878: LD_VAR 0 1
118882: ARRAY
118883: PUSH
118884: EMPTY
118885: EQUAL
118886: OR
118887: IFFALSE 118924
// begin for i in defenders do
118889: LD_ADDR_VAR 0 4
118893: PUSH
118894: LD_VAR 0 2
118898: PUSH
118899: FOR_IN
118900: IFFALSE 118913
// ComStop ( i ) ;
118902: LD_VAR 0 4
118906: PPUSH
118907: CALL_OW 141
118911: GO 118899
118913: POP
118914: POP
// defenders := [ ] ;
118915: LD_ADDR_VAR 0 2
118919: PUSH
118920: EMPTY
118921: ST_TO_ADDR
// exit ;
118922: GO 119150
// end ; for i in defenders do
118924: LD_ADDR_VAR 0 4
118928: PUSH
118929: LD_VAR 0 2
118933: PUSH
118934: FOR_IN
118935: IFFALSE 119024
// begin if not IsInArea ( i , mc_parking [ base ] ) then
118937: LD_VAR 0 4
118941: PPUSH
118942: LD_EXP 55
118946: PUSH
118947: LD_VAR 0 1
118951: ARRAY
118952: PPUSH
118953: CALL_OW 308
118957: NOT
118958: IFFALSE 118982
// ComMoveToArea ( i , mc_parking [ base ] ) else
118960: LD_VAR 0 4
118964: PPUSH
118965: LD_EXP 55
118969: PUSH
118970: LD_VAR 0 1
118974: ARRAY
118975: PPUSH
118976: CALL_OW 113
118980: GO 119022
// if GetControl ( i ) = control_manual then
118982: LD_VAR 0 4
118986: PPUSH
118987: CALL_OW 263
118991: PUSH
118992: LD_INT 1
118994: EQUAL
118995: IFFALSE 119022
// if IsDrivenBy ( i ) then
118997: LD_VAR 0 4
119001: PPUSH
119002: CALL_OW 311
119006: IFFALSE 119022
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
119008: LD_VAR 0 4
119012: PPUSH
119013: CALL_OW 311
119017: PPUSH
119018: CALL_OW 121
// end ;
119022: GO 118934
119024: POP
119025: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
119026: LD_VAR 0 2
119030: PPUSH
119031: LD_INT 95
119033: PUSH
119034: LD_EXP 55
119038: PUSH
119039: LD_VAR 0 1
119043: ARRAY
119044: PUSH
119045: EMPTY
119046: LIST
119047: LIST
119048: PPUSH
119049: CALL_OW 72
119053: PUSH
119054: LD_VAR 0 2
119058: EQUAL
119059: PUSH
119060: LD_EXP 54
119064: PUSH
119065: LD_VAR 0 1
119069: ARRAY
119070: OR
119071: PUSH
119072: LD_EXP 31
119076: PUSH
119077: LD_VAR 0 1
119081: ARRAY
119082: NOT
119083: OR
119084: IFFALSE 118854
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
119086: LD_ADDR_EXP 53
119090: PUSH
119091: LD_EXP 53
119095: PPUSH
119096: LD_VAR 0 1
119100: PPUSH
119101: LD_VAR 0 2
119105: PPUSH
119106: LD_INT 21
119108: PUSH
119109: LD_INT 2
119111: PUSH
119112: EMPTY
119113: LIST
119114: LIST
119115: PPUSH
119116: CALL_OW 72
119120: PPUSH
119121: CALL_OW 1
119125: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
119126: LD_VAR 0 1
119130: PPUSH
119131: LD_INT 19
119133: PPUSH
119134: CALL 65413 0 2
// MC_Reset ( base , 20 ) ;
119138: LD_VAR 0 1
119142: PPUSH
119143: LD_INT 20
119145: PPUSH
119146: CALL 65413 0 2
// end ; end_of_file
119150: LD_VAR 0 3
119154: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
119155: LD_VAR 0 1
119159: PUSH
119160: LD_INT 200
119162: DOUBLE
119163: GREATEREQUAL
119164: IFFALSE 119172
119166: LD_INT 299
119168: DOUBLE
119169: LESSEQUAL
119170: IFTRUE 119174
119172: GO 119206
119174: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
119175: LD_VAR 0 1
119179: PPUSH
119180: LD_VAR 0 2
119184: PPUSH
119185: LD_VAR 0 3
119189: PPUSH
119190: LD_VAR 0 4
119194: PPUSH
119195: LD_VAR 0 5
119199: PPUSH
119200: CALL 107941 0 5
119204: GO 119283
119206: LD_INT 300
119208: DOUBLE
119209: GREATEREQUAL
119210: IFFALSE 119218
119212: LD_INT 399
119214: DOUBLE
119215: LESSEQUAL
119216: IFTRUE 119220
119218: GO 119282
119220: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
119221: LD_VAR 0 1
119225: PPUSH
119226: LD_VAR 0 2
119230: PPUSH
119231: LD_VAR 0 3
119235: PPUSH
119236: LD_VAR 0 4
119240: PPUSH
119241: LD_VAR 0 5
119245: PPUSH
119246: LD_VAR 0 6
119250: PPUSH
119251: LD_VAR 0 7
119255: PPUSH
119256: LD_VAR 0 8
119260: PPUSH
119261: LD_VAR 0 9
119265: PPUSH
119266: LD_VAR 0 10
119270: PPUSH
119271: LD_VAR 0 11
119275: PPUSH
119276: CALL 104274 0 11
119280: GO 119283
119282: POP
// end ;
119283: PPOPN 11
119285: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
119286: LD_VAR 0 1
119290: PPUSH
119291: LD_VAR 0 2
119295: PPUSH
119296: LD_VAR 0 3
119300: PPUSH
119301: LD_VAR 0 4
119305: PPUSH
119306: LD_VAR 0 5
119310: PPUSH
119311: CALL 107677 0 5
// end ; end_of_file
119315: PPOPN 5
119317: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ;
119318: LD_VAR 0 1
119322: PPUSH
119323: LD_VAR 0 2
119327: PPUSH
119328: LD_VAR 0 3
119332: PPUSH
119333: LD_VAR 0 4
119337: PPUSH
119338: LD_VAR 0 5
119342: PPUSH
119343: LD_VAR 0 6
119347: PPUSH
119348: CALL 91967 0 6
// end ;
119352: PPOPN 6
119354: END
// on CommPanelCommand ( units , p1 , p2 , p3 , p4 , p5 ) do var i ;
119355: LD_INT 0
119357: PPUSH
// begin if not units then
119358: LD_VAR 0 1
119362: NOT
119363: IFFALSE 119367
// exit ;
119365: GO 119367
// end ;
119367: PPOPN 7
119369: END
// on MapStart ( p ) do begin SOS_MapStart ( ) ;
119370: CALL 91938 0 0
// end ;
119374: PPOPN 1
119376: END
