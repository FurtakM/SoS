// starting begin ResetFog ;
   0: CALL_OW 335
// GameOption ;
   4: CALL 1729 0 0
// PreparePlayer ;
   8: CALL 13 0 0
// end ; end_of_file
  12: END
// export player_side , player_nation , player_number , level ; export main_depot ; export s ; export function PreparePlayer ; var side , nat , num , lvl , crates , oil_source , sib_source , un , com , units , i , x , y , op ; begin
  13: LD_INT 0
  15: PPUSH
  16: PPUSH
  17: PPUSH
  18: PPUSH
  19: PPUSH
  20: PPUSH
  21: PPUSH
  22: PPUSH
  23: PPUSH
  24: PPUSH
  25: PPUSH
  26: PPUSH
  27: PPUSH
  28: PPUSH
  29: PPUSH
// units := [ ] ;
  30: LD_ADDR_VAR 0 11
  34: PUSH
  35: EMPTY
  36: ST_TO_ADDR
// side = player_side ;
  37: LD_ADDR_VAR 0 2
  41: PUSH
  42: LD_EXP 1
  46: ST_TO_ADDR
// nat = player_nation ;
  47: LD_ADDR_VAR 0 3
  51: PUSH
  52: LD_EXP 2
  56: ST_TO_ADDR
// num = player_number ;
  57: LD_ADDR_VAR 0 4
  61: PUSH
  62: LD_EXP 3
  66: ST_TO_ADDR
// lvl = level ;
  67: LD_ADDR_VAR 0 5
  71: PUSH
  72: LD_EXP 4
  76: ST_TO_ADDR
// oil_source := [ 105 , 83 , 88 , 61 ] ;
  77: LD_ADDR_VAR 0 7
  81: PUSH
  82: LD_INT 105
  84: PUSH
  85: LD_INT 83
  87: PUSH
  88: LD_INT 88
  90: PUSH
  91: LD_INT 61
  93: PUSH
  94: EMPTY
  95: LIST
  96: LIST
  97: LIST
  98: LIST
  99: ST_TO_ADDR
// sib_source := [ 89 , 90 , 65 , 75 ] ;
 100: LD_ADDR_VAR 0 8
 104: PUSH
 105: LD_INT 89
 107: PUSH
 108: LD_INT 90
 110: PUSH
 111: LD_INT 65
 113: PUSH
 114: LD_INT 75
 116: PUSH
 117: EMPTY
 118: LIST
 119: LIST
 120: LIST
 121: LIST
 122: ST_TO_ADDR
// case lvl of 1 :
 123: LD_VAR 0 5
 127: PUSH
 128: LD_INT 1
 130: DOUBLE
 131: EQUAL
 132: IFTRUE 136
 134: GO 147
 136: POP
// s := 0 ; 2 :
 137: LD_ADDR_EXP 6
 141: PUSH
 142: LD_INT 0
 144: ST_TO_ADDR
 145: GO 205
 147: LD_INT 2
 149: DOUBLE
 150: EQUAL
 151: IFTRUE 155
 153: GO 166
 155: POP
// s := 3 ; 3 :
 156: LD_ADDR_EXP 6
 160: PUSH
 161: LD_INT 3
 163: ST_TO_ADDR
 164: GO 205
 166: LD_INT 3
 168: DOUBLE
 169: EQUAL
 170: IFTRUE 174
 172: GO 185
 174: POP
// s := 5 ; 4 :
 175: LD_ADDR_EXP 6
 179: PUSH
 180: LD_INT 5
 182: ST_TO_ADDR
 183: GO 205
 185: LD_INT 4
 187: DOUBLE
 188: EQUAL
 189: IFTRUE 193
 191: GO 204
 193: POP
// s := 7 ; end ;
 194: LD_ADDR_EXP 6
 198: PUSH
 199: LD_INT 7
 201: ST_TO_ADDR
 202: GO 205
 204: POP
// uc_side = side ;
 205: LD_ADDR_OWVAR 20
 209: PUSH
 210: LD_VAR 0 2
 214: ST_TO_ADDR
// uc_nation = nat ;
 215: LD_ADDR_OWVAR 21
 219: PUSH
 220: LD_VAR 0 3
 224: ST_TO_ADDR
// com := HumUnit ( 1 , 100 , s + 1 ) ;
 225: LD_ADDR_VAR 0 10
 229: PUSH
 230: LD_INT 1
 232: PPUSH
 233: LD_INT 100
 235: PPUSH
 236: LD_EXP 6
 240: PUSH
 241: LD_INT 1
 243: PLUS
 244: PPUSH
 245: CALL 1213 0 3
 249: ST_TO_ADDR
// units = units ^ com ;
 250: LD_ADDR_VAR 0 11
 254: PUSH
 255: LD_VAR 0 11
 259: PUSH
 260: LD_VAR 0 10
 264: ADD
 265: ST_TO_ADDR
// for i = 1 to num do
 266: LD_ADDR_VAR 0 12
 270: PUSH
 271: DOUBLE
 272: LD_INT 1
 274: DEC
 275: ST_TO_ADDR
 276: LD_VAR 0 4
 280: PUSH
 281: FOR_TO
 282: IFFALSE 546
// begin if i < ( num / 4 ) then
 284: LD_VAR 0 12
 288: PUSH
 289: LD_VAR 0 4
 293: PUSH
 294: LD_INT 4
 296: DIVREAL
 297: LESS
 298: IFFALSE 333
// un := HumUnit ( class_soldier , 0 , s + Rand ( 0 , 2 ) ) ;
 300: LD_ADDR_VAR 0 9
 304: PUSH
 305: LD_INT 1
 307: PPUSH
 308: LD_INT 0
 310: PPUSH
 311: LD_EXP 6
 315: PUSH
 316: LD_INT 0
 318: PPUSH
 319: LD_INT 2
 321: PPUSH
 322: CALL_OW 12
 326: PLUS
 327: PPUSH
 328: CALL 1213 0 3
 332: ST_TO_ADDR
// if i >= ( num / 4 ) and i <= 2 * ( num / 4 ) then
 333: LD_VAR 0 12
 337: PUSH
 338: LD_VAR 0 4
 342: PUSH
 343: LD_INT 4
 345: DIVREAL
 346: GREATEREQUAL
 347: PUSH
 348: LD_VAR 0 12
 352: PUSH
 353: LD_INT 2
 355: PUSH
 356: LD_VAR 0 4
 360: PUSH
 361: LD_INT 4
 363: DIVREAL
 364: MUL
 365: LESSEQUAL
 366: AND
 367: IFFALSE 402
// un := HumUnit ( class_engineer , 0 , s + Rand ( 0 , 2 ) ) ;
 369: LD_ADDR_VAR 0 9
 373: PUSH
 374: LD_INT 2
 376: PPUSH
 377: LD_INT 0
 379: PPUSH
 380: LD_EXP 6
 384: PUSH
 385: LD_INT 0
 387: PPUSH
 388: LD_INT 2
 390: PPUSH
 391: CALL_OW 12
 395: PLUS
 396: PPUSH
 397: CALL 1213 0 3
 401: ST_TO_ADDR
// if i > 2 * ( num / 4 ) and i <= 3 * ( num / 4 ) then
 402: LD_VAR 0 12
 406: PUSH
 407: LD_INT 2
 409: PUSH
 410: LD_VAR 0 4
 414: PUSH
 415: LD_INT 4
 417: DIVREAL
 418: MUL
 419: GREATER
 420: PUSH
 421: LD_VAR 0 12
 425: PUSH
 426: LD_INT 3
 428: PUSH
 429: LD_VAR 0 4
 433: PUSH
 434: LD_INT 4
 436: DIVREAL
 437: MUL
 438: LESSEQUAL
 439: AND
 440: IFFALSE 475
// un := HumUnit ( class_mechanic , 0 , s + Rand ( 0 , 2 ) ) ;
 442: LD_ADDR_VAR 0 9
 446: PUSH
 447: LD_INT 3
 449: PPUSH
 450: LD_INT 0
 452: PPUSH
 453: LD_EXP 6
 457: PUSH
 458: LD_INT 0
 460: PPUSH
 461: LD_INT 2
 463: PPUSH
 464: CALL_OW 12
 468: PLUS
 469: PPUSH
 470: CALL 1213 0 3
 474: ST_TO_ADDR
// if i > 3 * ( num / 4 ) then
 475: LD_VAR 0 12
 479: PUSH
 480: LD_INT 3
 482: PUSH
 483: LD_VAR 0 4
 487: PUSH
 488: LD_INT 4
 490: DIVREAL
 491: MUL
 492: GREATER
 493: IFFALSE 528
// un := HumUnit ( class_scientistic , 0 , s + Rand ( 0 , 2 ) ) ;
 495: LD_ADDR_VAR 0 9
 499: PUSH
 500: LD_INT 4
 502: PPUSH
 503: LD_INT 0
 505: PPUSH
 506: LD_EXP 6
 510: PUSH
 511: LD_INT 0
 513: PPUSH
 514: LD_INT 2
 516: PPUSH
 517: CALL_OW 12
 521: PLUS
 522: PPUSH
 523: CALL 1213 0 3
 527: ST_TO_ADDR
// units := units ^ un ;
 528: LD_ADDR_VAR 0 11
 532: PUSH
 533: LD_VAR 0 11
 537: PUSH
 538: LD_VAR 0 9
 542: ADD
 543: ST_TO_ADDR
// end ;
 544: GO 281
 546: POP
 547: POP
// for i = 1 to units do
 548: LD_ADDR_VAR 0 12
 552: PUSH
 553: DOUBLE
 554: LD_INT 1
 556: DEC
 557: ST_TO_ADDR
 558: LD_VAR 0 11
 562: PUSH
 563: FOR_TO
 564: IFFALSE 610
// begin PlaceUnitArea ( units [ i ] , respawnplayer , false ) ;
 566: LD_VAR 0 11
 570: PUSH
 571: LD_VAR 0 12
 575: ARRAY
 576: PPUSH
 577: LD_INT 1
 579: PPUSH
 580: LD_INT 0
 582: PPUSH
 583: CALL_OW 49
// ComTurnXY ( units [ i ] , 0 , 0 ) ;
 587: LD_VAR 0 11
 591: PUSH
 592: LD_VAR 0 12
 596: ARRAY
 597: PPUSH
 598: LD_INT 0
 600: PPUSH
 601: LD_INT 0
 603: PPUSH
 604: CALL_OW 118
// end ;
 608: GO 563
 610: POP
 611: POP
// if lvl = 1 then
 612: LD_VAR 0 5
 616: PUSH
 617: LD_INT 1
 619: EQUAL
 620: IFFALSE 755
// begin CreateDepositXY ( oil_source [ 1 ] , oil_source [ 2 ] , mat_oil ) ;
 622: LD_VAR 0 7
 626: PUSH
 627: LD_INT 1
 629: ARRAY
 630: PPUSH
 631: LD_VAR 0 7
 635: PUSH
 636: LD_INT 2
 638: ARRAY
 639: PPUSH
 640: LD_INT 2
 642: PPUSH
 643: CALL_OW 62
// CreateDepositXY ( oil_source [ 3 ] , oil_source [ 4 ] , mat_oil ) ;
 647: LD_VAR 0 7
 651: PUSH
 652: LD_INT 3
 654: ARRAY
 655: PPUSH
 656: LD_VAR 0 7
 660: PUSH
 661: LD_INT 4
 663: ARRAY
 664: PPUSH
 665: LD_INT 2
 667: PPUSH
 668: CALL_OW 62
// CreateDepositXY ( sib_source [ 1 ] , sib_source [ 2 ] , mat_siberit ) ;
 672: LD_VAR 0 8
 676: PUSH
 677: LD_INT 1
 679: ARRAY
 680: PPUSH
 681: LD_VAR 0 8
 685: PUSH
 686: LD_INT 2
 688: ARRAY
 689: PPUSH
 690: LD_INT 3
 692: PPUSH
 693: CALL_OW 62
// CreateDepositXY ( sib_source [ 3 ] , sib_source [ 4 ] , mat_siberit ) ;
 697: LD_VAR 0 8
 701: PUSH
 702: LD_INT 3
 704: ARRAY
 705: PPUSH
 706: LD_VAR 0 8
 710: PUSH
 711: LD_INT 4
 713: ARRAY
 714: PPUSH
 715: LD_INT 3
 717: PPUSH
 718: CALL_OW 62
// for i = 1 to 4 do
 722: LD_ADDR_VAR 0 12
 726: PUSH
 727: DOUBLE
 728: LD_INT 1
 730: DEC
 731: ST_TO_ADDR
 732: LD_INT 4
 734: PUSH
 735: FOR_TO
 736: IFFALSE 753
// CreateCratesArea ( 5 , cratessarea , false ) ;
 738: LD_INT 5
 740: PPUSH
 741: LD_INT 2
 743: PPUSH
 744: LD_INT 0
 746: PPUSH
 747: CALL_OW 55
 751: GO 735
 753: POP
 754: POP
// end ; if lvl = 2 then
 755: LD_VAR 0 5
 759: PUSH
 760: LD_INT 2
 762: EQUAL
 763: IFFALSE 873
// begin CreateDepositXY ( oil_source [ 1 ] , oil_source [ 2 ] , mat_oil ) ;
 765: LD_VAR 0 7
 769: PUSH
 770: LD_INT 1
 772: ARRAY
 773: PPUSH
 774: LD_VAR 0 7
 778: PUSH
 779: LD_INT 2
 781: ARRAY
 782: PPUSH
 783: LD_INT 2
 785: PPUSH
 786: CALL_OW 62
// CreateDepositXY ( oil_source [ 3 ] , oil_source [ 4 ] , mat_oil ) ;
 790: LD_VAR 0 7
 794: PUSH
 795: LD_INT 3
 797: ARRAY
 798: PPUSH
 799: LD_VAR 0 7
 803: PUSH
 804: LD_INT 4
 806: ARRAY
 807: PPUSH
 808: LD_INT 2
 810: PPUSH
 811: CALL_OW 62
// CreateDepositXY ( sib_source [ 1 ] , sib_source [ 2 ] , mat_siberit ) ;
 815: LD_VAR 0 8
 819: PUSH
 820: LD_INT 1
 822: ARRAY
 823: PPUSH
 824: LD_VAR 0 8
 828: PUSH
 829: LD_INT 2
 831: ARRAY
 832: PPUSH
 833: LD_INT 3
 835: PPUSH
 836: CALL_OW 62
// for i = 1 to 2 do
 840: LD_ADDR_VAR 0 12
 844: PUSH
 845: DOUBLE
 846: LD_INT 1
 848: DEC
 849: ST_TO_ADDR
 850: LD_INT 2
 852: PUSH
 853: FOR_TO
 854: IFFALSE 871
// CreateCratesArea ( 5 , cratessarea , false ) ;
 856: LD_INT 5
 858: PPUSH
 859: LD_INT 2
 861: PPUSH
 862: LD_INT 0
 864: PPUSH
 865: CALL_OW 55
 869: GO 853
 871: POP
 872: POP
// end ; if lvl = 3 then
 873: LD_VAR 0 5
 877: PUSH
 878: LD_INT 3
 880: EQUAL
 881: IFFALSE 966
// begin CreateDepositXY ( oil_source [ 1 ] , oil_source [ 2 ] , mat_oil ) ;
 883: LD_VAR 0 7
 887: PUSH
 888: LD_INT 1
 890: ARRAY
 891: PPUSH
 892: LD_VAR 0 7
 896: PUSH
 897: LD_INT 2
 899: ARRAY
 900: PPUSH
 901: LD_INT 2
 903: PPUSH
 904: CALL_OW 62
// CreateDepositXY ( sib_source [ 1 ] , sib_source [ 2 ] , mat_siberit ) ;
 908: LD_VAR 0 8
 912: PUSH
 913: LD_INT 1
 915: ARRAY
 916: PPUSH
 917: LD_VAR 0 8
 921: PUSH
 922: LD_INT 2
 924: ARRAY
 925: PPUSH
 926: LD_INT 3
 928: PPUSH
 929: CALL_OW 62
// for i = 1 to 3 do
 933: LD_ADDR_VAR 0 12
 937: PUSH
 938: DOUBLE
 939: LD_INT 1
 941: DEC
 942: ST_TO_ADDR
 943: LD_INT 3
 945: PUSH
 946: FOR_TO
 947: IFFALSE 964
// CreateCratesArea ( 2 , cratessarea , false ) ;
 949: LD_INT 2
 951: PPUSH
 952: LD_INT 2
 954: PPUSH
 955: LD_INT 0
 957: PPUSH
 958: CALL_OW 55
 962: GO 946
 964: POP
 965: POP
// end ; if lvl = 4 then
 966: LD_VAR 0 5
 970: PUSH
 971: LD_INT 4
 973: EQUAL
 974: IFFALSE 1034
// begin CreateDepositXY ( oil_source [ 1 ] , oil_source [ 2 ] , mat_oil ) ;
 976: LD_VAR 0 7
 980: PUSH
 981: LD_INT 1
 983: ARRAY
 984: PPUSH
 985: LD_VAR 0 7
 989: PUSH
 990: LD_INT 2
 992: ARRAY
 993: PPUSH
 994: LD_INT 2
 996: PPUSH
 997: CALL_OW 62
// for i = 1 to 2 do
1001: LD_ADDR_VAR 0 12
1005: PUSH
1006: DOUBLE
1007: LD_INT 1
1009: DEC
1010: ST_TO_ADDR
1011: LD_INT 2
1013: PUSH
1014: FOR_TO
1015: IFFALSE 1032
// CreateCratesArea ( 2 , cratessarea , false ) ;
1017: LD_INT 2
1019: PPUSH
1020: LD_INT 2
1022: PPUSH
1023: LD_INT 0
1025: PPUSH
1026: CALL_OW 55
1030: GO 1014
1032: POP
1033: POP
// end ; CenterNowOnUnits ( com ) ;
1034: LD_VAR 0 10
1038: PPUSH
1039: CALL_OW 87
// end ;
1043: LD_VAR 0 1
1047: RET
// on BuildingComplete ( build ) do begin if GetSide ( build ) = player_side then
1048: LD_VAR 0 1
1052: PPUSH
1053: CALL_OW 255
1057: PUSH
1058: LD_EXP 1
1062: EQUAL
1063: IFFALSE 1135
// if GetBType ( build ) = b_depot then
1065: LD_VAR 0 1
1069: PPUSH
1070: CALL_OW 266
1074: PUSH
1075: LD_INT 0
1077: EQUAL
1078: IFFALSE 1135
// begin main_depot = FilterAllUnits ( [ f_btype , b_depot ] ) ;
1080: LD_ADDR_EXP 5
1084: PUSH
1085: LD_INT 30
1087: PUSH
1088: LD_INT 0
1090: PUSH
1091: EMPTY
1092: LIST
1093: LIST
1094: PPUSH
1095: CALL_OW 69
1099: ST_TO_ADDR
// if points = 0 then
1100: LD_EXP 7
1104: PUSH
1105: LD_INT 0
1107: EQUAL
1108: IFFALSE 1135
// SetResourceType ( main_depot , mat_cans , 500 + 100 * level ) ;
1110: LD_EXP 5
1114: PPUSH
1115: LD_INT 1
1117: PPUSH
1118: LD_INT 500
1120: PUSH
1121: LD_INT 100
1123: PUSH
1124: LD_EXP 4
1128: MUL
1129: PLUS
1130: PPUSH
1131: CALL_OW 277
// end ; end ;
1135: PPOPN 1
1137: END
// every 0 0$0.1 do var un ;
1138: GO 1140
1140: DISABLE
1141: LD_INT 0
1143: PPUSH
// begin enable ;
1144: ENABLE
// SetAreaMapShow ( Close , 3 ) ;
1145: LD_INT 5
1147: PPUSH
1148: LD_INT 3
1150: PPUSH
1151: CALL_OW 424
// for un in FilterAllUnits ( [ f_side , player_side ] ) do
1155: LD_ADDR_VAR 0 1
1159: PUSH
1160: LD_INT 22
1162: PUSH
1163: LD_EXP 1
1167: PUSH
1168: EMPTY
1169: LIST
1170: LIST
1171: PPUSH
1172: CALL_OW 69
1176: PUSH
1177: FOR_IN
1178: IFFALSE 1208
// begin if IsInArea ( un , Close ) then
1180: LD_VAR 0 1
1184: PPUSH
1185: LD_INT 5
1187: PPUSH
1188: CALL_OW 308
1192: IFFALSE 1206
// SetLives ( un , 0 ) ;
1194: LD_VAR 0 1
1198: PPUSH
1199: LD_INT 0
1201: PPUSH
1202: CALL_OW 234
// end ;
1206: GO 1177
1208: POP
1209: POP
// end ; end_of_file
1210: PPOPN 1
1212: END
// export function HumUnit ( clas , imp , s ) ; var un ; begin
1213: LD_INT 0
1215: PPUSH
1216: PPUSH
// hc_class := clas ;
1217: LD_ADDR_OWVAR 28
1221: PUSH
1222: LD_VAR 0 1
1226: ST_TO_ADDR
// hc_sex := Rand ( sex_male , sex_female ) ;
1227: LD_ADDR_OWVAR 27
1231: PUSH
1232: LD_INT 1
1234: PPUSH
1235: LD_INT 2
1237: PPUSH
1238: CALL_OW 12
1242: ST_TO_ADDR
// if clas = 1 or clas > 4 then
1243: LD_VAR 0 1
1247: PUSH
1248: LD_INT 1
1250: EQUAL
1251: PUSH
1252: LD_VAR 0 1
1256: PUSH
1257: LD_INT 4
1259: GREATER
1260: OR
1261: IFFALSE 1354
// hc_skills := [ Rand ( s , s + 2 ) , Rand ( s , s + 2 + 1 ) , Rand ( s , s + 2 ) , Rand ( s , s + 2 ) ] ;
1263: LD_ADDR_OWVAR 31
1267: PUSH
1268: LD_VAR 0 3
1272: PPUSH
1273: LD_VAR 0 3
1277: PUSH
1278: LD_INT 2
1280: PLUS
1281: PPUSH
1282: CALL_OW 12
1286: PUSH
1287: LD_VAR 0 3
1291: PPUSH
1292: LD_VAR 0 3
1296: PUSH
1297: LD_INT 2
1299: PLUS
1300: PUSH
1301: LD_INT 1
1303: PLUS
1304: PPUSH
1305: CALL_OW 12
1309: PUSH
1310: LD_VAR 0 3
1314: PPUSH
1315: LD_VAR 0 3
1319: PUSH
1320: LD_INT 2
1322: PLUS
1323: PPUSH
1324: CALL_OW 12
1328: PUSH
1329: LD_VAR 0 3
1333: PPUSH
1334: LD_VAR 0 3
1338: PUSH
1339: LD_INT 2
1341: PLUS
1342: PPUSH
1343: CALL_OW 12
1347: PUSH
1348: EMPTY
1349: LIST
1350: LIST
1351: LIST
1352: LIST
1353: ST_TO_ADDR
// if clas = 2 then
1354: LD_VAR 0 1
1358: PUSH
1359: LD_INT 2
1361: EQUAL
1362: IFFALSE 1455
// hc_skills := [ Rand ( s , s + 2 ) , Rand ( s , s + 2 + 1 ) , Rand ( s , s + 2 ) , Rand ( s , s + 2 ) ] ;
1364: LD_ADDR_OWVAR 31
1368: PUSH
1369: LD_VAR 0 3
1373: PPUSH
1374: LD_VAR 0 3
1378: PUSH
1379: LD_INT 2
1381: PLUS
1382: PPUSH
1383: CALL_OW 12
1387: PUSH
1388: LD_VAR 0 3
1392: PPUSH
1393: LD_VAR 0 3
1397: PUSH
1398: LD_INT 2
1400: PLUS
1401: PUSH
1402: LD_INT 1
1404: PLUS
1405: PPUSH
1406: CALL_OW 12
1410: PUSH
1411: LD_VAR 0 3
1415: PPUSH
1416: LD_VAR 0 3
1420: PUSH
1421: LD_INT 2
1423: PLUS
1424: PPUSH
1425: CALL_OW 12
1429: PUSH
1430: LD_VAR 0 3
1434: PPUSH
1435: LD_VAR 0 3
1439: PUSH
1440: LD_INT 2
1442: PLUS
1443: PPUSH
1444: CALL_OW 12
1448: PUSH
1449: EMPTY
1450: LIST
1451: LIST
1452: LIST
1453: LIST
1454: ST_TO_ADDR
// if clas = 3 then
1455: LD_VAR 0 1
1459: PUSH
1460: LD_INT 3
1462: EQUAL
1463: IFFALSE 1556
// hc_skills := [ Rand ( s , s + 2 ) , Rand ( s , s + 2 ) , Rand ( s , s + 2 + 1 ) , Rand ( s , s + 2 ) ] ;
1465: LD_ADDR_OWVAR 31
1469: PUSH
1470: LD_VAR 0 3
1474: PPUSH
1475: LD_VAR 0 3
1479: PUSH
1480: LD_INT 2
1482: PLUS
1483: PPUSH
1484: CALL_OW 12
1488: PUSH
1489: LD_VAR 0 3
1493: PPUSH
1494: LD_VAR 0 3
1498: PUSH
1499: LD_INT 2
1501: PLUS
1502: PPUSH
1503: CALL_OW 12
1507: PUSH
1508: LD_VAR 0 3
1512: PPUSH
1513: LD_VAR 0 3
1517: PUSH
1518: LD_INT 2
1520: PLUS
1521: PUSH
1522: LD_INT 1
1524: PLUS
1525: PPUSH
1526: CALL_OW 12
1530: PUSH
1531: LD_VAR 0 3
1535: PPUSH
1536: LD_VAR 0 3
1540: PUSH
1541: LD_INT 2
1543: PLUS
1544: PPUSH
1545: CALL_OW 12
1549: PUSH
1550: EMPTY
1551: LIST
1552: LIST
1553: LIST
1554: LIST
1555: ST_TO_ADDR
// if clas = 4 then
1556: LD_VAR 0 1
1560: PUSH
1561: LD_INT 4
1563: EQUAL
1564: IFFALSE 1657
// hc_skills := [ Rand ( s , s + 2 ) , Rand ( s , s + 2 ) , Rand ( s , s + 2 ) , Rand ( s , s + 2 + 1 ) ] ;
1566: LD_ADDR_OWVAR 31
1570: PUSH
1571: LD_VAR 0 3
1575: PPUSH
1576: LD_VAR 0 3
1580: PUSH
1581: LD_INT 2
1583: PLUS
1584: PPUSH
1585: CALL_OW 12
1589: PUSH
1590: LD_VAR 0 3
1594: PPUSH
1595: LD_VAR 0 3
1599: PUSH
1600: LD_INT 2
1602: PLUS
1603: PPUSH
1604: CALL_OW 12
1608: PUSH
1609: LD_VAR 0 3
1613: PPUSH
1614: LD_VAR 0 3
1618: PUSH
1619: LD_INT 2
1621: PLUS
1622: PPUSH
1623: CALL_OW 12
1627: PUSH
1628: LD_VAR 0 3
1632: PPUSH
1633: LD_VAR 0 3
1637: PUSH
1638: LD_INT 2
1640: PLUS
1641: PUSH
1642: LD_INT 1
1644: PLUS
1645: PPUSH
1646: CALL_OW 12
1650: PUSH
1651: EMPTY
1652: LIST
1653: LIST
1654: LIST
1655: LIST
1656: ST_TO_ADDR
// hc_attr := [ Rand ( 8 , 12 ) , Rand ( 9 , 11 ) ] ;
1657: LD_ADDR_OWVAR 29
1661: PUSH
1662: LD_INT 8
1664: PPUSH
1665: LD_INT 12
1667: PPUSH
1668: CALL_OW 12
1672: PUSH
1673: LD_INT 9
1675: PPUSH
1676: LD_INT 11
1678: PPUSH
1679: CALL_OW 12
1683: PUSH
1684: EMPTY
1685: LIST
1686: LIST
1687: ST_TO_ADDR
// hc_gallery :=  ;
1688: LD_ADDR_OWVAR 33
1692: PUSH
1693: LD_STRING 
1695: ST_TO_ADDR
// hc_name :=  ;
1696: LD_ADDR_OWVAR 26
1700: PUSH
1701: LD_STRING 
1703: ST_TO_ADDR
// hc_importance := imp ;
1704: LD_ADDR_OWVAR 32
1708: PUSH
1709: LD_VAR 0 2
1713: ST_TO_ADDR
// result = CreateHuman ;
1714: LD_ADDR_VAR 0 4
1718: PUSH
1719: CALL_OW 44
1723: ST_TO_ADDR
// end ; end_of_file
1724: LD_VAR 0 4
1728: RET
// export function GameOption ; begin
1729: LD_INT 0
1731: PPUSH
// case Query ( StartQuery ) of 1 :
1732: LD_STRING StartQuery
1734: PPUSH
1735: CALL_OW 97
1739: PUSH
1740: LD_INT 1
1742: DOUBLE
1743: EQUAL
1744: IFTRUE 1748
1746: GO 1755
1748: POP
// ResetFog ; end ;
1749: CALL_OW 335
1753: GO 1756
1755: POP
// case Query ( SelectNat ) of 1 :
1756: LD_STRING SelectNat
1758: PPUSH
1759: CALL_OW 97
1763: PUSH
1764: LD_INT 1
1766: DOUBLE
1767: EQUAL
1768: IFTRUE 1772
1770: GO 1783
1772: POP
// player_nation := nation_american ; 2 :
1773: LD_ADDR_EXP 2
1777: PUSH
1778: LD_INT 1
1780: ST_TO_ADDR
1781: GO 1849
1783: LD_INT 2
1785: DOUBLE
1786: EQUAL
1787: IFTRUE 1791
1789: GO 1802
1791: POP
// player_nation := nation_arabian ; 3 :
1792: LD_ADDR_EXP 2
1796: PUSH
1797: LD_INT 2
1799: ST_TO_ADDR
1800: GO 1849
1802: LD_INT 3
1804: DOUBLE
1805: EQUAL
1806: IFTRUE 1810
1808: GO 1821
1810: POP
// player_nation := nation_russian ; 4 :
1811: LD_ADDR_EXP 2
1815: PUSH
1816: LD_INT 3
1818: ST_TO_ADDR
1819: GO 1849
1821: LD_INT 4
1823: DOUBLE
1824: EQUAL
1825: IFTRUE 1829
1827: GO 1848
1829: POP
// player_nation := Rand ( 1 , 3 ) ; end ;
1830: LD_ADDR_EXP 2
1834: PUSH
1835: LD_INT 1
1837: PPUSH
1838: LD_INT 3
1840: PPUSH
1841: CALL_OW 12
1845: ST_TO_ADDR
1846: GO 1849
1848: POP
// case Query ( SelectSid ) of 1 :
1849: LD_STRING SelectSid
1851: PPUSH
1852: CALL_OW 97
1856: PUSH
1857: LD_INT 1
1859: DOUBLE
1860: EQUAL
1861: IFTRUE 1865
1863: GO 1876
1865: POP
// player_side := 5 ; 2 :
1866: LD_ADDR_EXP 1
1870: PUSH
1871: LD_INT 5
1873: ST_TO_ADDR
1874: GO 1934
1876: LD_INT 2
1878: DOUBLE
1879: EQUAL
1880: IFTRUE 1884
1882: GO 1895
1884: POP
// player_side := 6 ; 3 :
1885: LD_ADDR_EXP 1
1889: PUSH
1890: LD_INT 6
1892: ST_TO_ADDR
1893: GO 1934
1895: LD_INT 3
1897: DOUBLE
1898: EQUAL
1899: IFTRUE 1903
1901: GO 1914
1903: POP
// player_side := 7 ; 4 :
1904: LD_ADDR_EXP 1
1908: PUSH
1909: LD_INT 7
1911: ST_TO_ADDR
1912: GO 1934
1914: LD_INT 4
1916: DOUBLE
1917: EQUAL
1918: IFTRUE 1922
1920: GO 1933
1922: POP
// player_side := 8 ; end ;
1923: LD_ADDR_EXP 1
1927: PUSH
1928: LD_INT 8
1930: ST_TO_ADDR
1931: GO 1934
1933: POP
// Your_Side := player_side ;
1934: LD_ADDR_OWVAR 2
1938: PUSH
1939: LD_EXP 1
1943: ST_TO_ADDR
// ChangeSideFog ( 5 , player_side ) ;
1944: LD_INT 5
1946: PPUSH
1947: LD_EXP 1
1951: PPUSH
1952: CALL_OW 343
// case Query ( SelectNum ) of 1 :
1956: LD_STRING SelectNum
1958: PPUSH
1959: CALL_OW 97
1963: PUSH
1964: LD_INT 1
1966: DOUBLE
1967: EQUAL
1968: IFTRUE 1972
1970: GO 1983
1972: POP
// player_number := 12 ; 2 :
1973: LD_ADDR_EXP 3
1977: PUSH
1978: LD_INT 12
1980: ST_TO_ADDR
1981: GO 2022
1983: LD_INT 2
1985: DOUBLE
1986: EQUAL
1987: IFTRUE 1991
1989: GO 2002
1991: POP
// player_number := 16 ; 3 :
1992: LD_ADDR_EXP 3
1996: PUSH
1997: LD_INT 16
1999: ST_TO_ADDR
2000: GO 2022
2002: LD_INT 3
2004: DOUBLE
2005: EQUAL
2006: IFTRUE 2010
2008: GO 2021
2010: POP
// player_number := 20 ; end ;
2011: LD_ADDR_EXP 3
2015: PUSH
2016: LD_INT 20
2018: ST_TO_ADDR
2019: GO 2022
2021: POP
// case Query ( SelectDif ) of 1 :
2022: LD_STRING SelectDif
2024: PPUSH
2025: CALL_OW 97
2029: PUSH
2030: LD_INT 1
2032: DOUBLE
2033: EQUAL
2034: IFTRUE 2038
2036: GO 2049
2038: POP
// level := 1 ; 2 :
2039: LD_ADDR_EXP 4
2043: PUSH
2044: LD_INT 1
2046: ST_TO_ADDR
2047: GO 2107
2049: LD_INT 2
2051: DOUBLE
2052: EQUAL
2053: IFTRUE 2057
2055: GO 2068
2057: POP
// level := 2 ; 3 :
2058: LD_ADDR_EXP 4
2062: PUSH
2063: LD_INT 2
2065: ST_TO_ADDR
2066: GO 2107
2068: LD_INT 3
2070: DOUBLE
2071: EQUAL
2072: IFTRUE 2076
2074: GO 2087
2076: POP
// level := 3 ; 4 :
2077: LD_ADDR_EXP 4
2081: PUSH
2082: LD_INT 3
2084: ST_TO_ADDR
2085: GO 2107
2087: LD_INT 4
2089: DOUBLE
2090: EQUAL
2091: IFTRUE 2095
2093: GO 2106
2095: POP
// level := 4 ; end ;
2096: LD_ADDR_EXP 4
2100: PUSH
2101: LD_INT 4
2103: ST_TO_ADDR
2104: GO 2107
2106: POP
// end ; end_of_file
2107: LD_VAR 0 1
2111: RET
// every 0 0$01 do
2112: GO 2114
2114: DISABLE
// begin enable ;
2115: ENABLE
// Display_Strings := [ #Tick , tick , #Attack , time_to , #Points , points , #Wave , wave , #Type , p ] ;
2116: LD_ADDR_OWVAR 47
2120: PUSH
2121: LD_STRING #Tick
2123: PUSH
2124: LD_OWVAR 1
2128: PUSH
2129: LD_STRING #Attack
2131: PUSH
2132: LD_EXP 9
2136: PUSH
2137: LD_STRING #Points
2139: PUSH
2140: LD_EXP 7
2144: PUSH
2145: LD_STRING #Wave
2147: PUSH
2148: LD_EXP 10
2152: PUSH
2153: LD_STRING #Type
2155: PUSH
2156: LD_EXP 11
2160: PUSH
2161: EMPTY
2162: LIST
2163: LIST
2164: LIST
2165: LIST
2166: LIST
2167: LIST
2168: LIST
2169: LIST
2170: LIST
2171: LIST
2172: ST_TO_ADDR
// end ;
2173: END
// export points , bonus_points , time_to , wave , p ; every 0 0$01 do
2174: GO 2176
2176: DISABLE
// begin points := 0 ;
2177: LD_ADDR_EXP 7
2181: PUSH
2182: LD_INT 0
2184: ST_TO_ADDR
// bonus_points := 0 ;
2185: LD_ADDR_EXP 8
2189: PUSH
2190: LD_INT 0
2192: ST_TO_ADDR
// time_to := 0 0$00 ;
2193: LD_ADDR_EXP 9
2197: PUSH
2198: LD_INT 0
2200: ST_TO_ADDR
// wave := 1 ;
2201: LD_ADDR_EXP 10
2205: PUSH
2206: LD_INT 1
2208: ST_TO_ADDR
// p := 1 ;
2209: LD_ADDR_EXP 11
2213: PUSH
2214: LD_INT 1
2216: ST_TO_ADDR
// end ; end_of_file
2217: END
// export function CreateWave ( nat , typ , num , lvl ) ; var i , un , coords , x , y , veh , units , area , enemy , target1 , target2 ; begin
2218: LD_INT 0
2220: PPUSH
2221: PPUSH
2222: PPUSH
2223: PPUSH
2224: PPUSH
2225: PPUSH
2226: PPUSH
2227: PPUSH
2228: PPUSH
2229: PPUSH
2230: PPUSH
2231: PPUSH
// units := [ ] ;
2232: LD_ADDR_VAR 0 12
2236: PUSH
2237: EMPTY
2238: ST_TO_ADDR
// area := Rand ( enemy1 , enemy2 ) ;
2239: LD_ADDR_VAR 0 13
2243: PUSH
2244: LD_INT 3
2246: PPUSH
2247: LD_INT 4
2249: PPUSH
2250: CALL_OW 12
2254: ST_TO_ADDR
// coords = [ 90 , 3 , 94 , 3 , 98 , 3 , 102 , 3 , 106 , 3 , 110 , 3 , 140 , 132 , 144 , 132 , 148 , 132 , 152 , 132 , 156 , 132 , 160 , 132 , 164 , 132 , 168 , 132 , 72 , 132 , 70 , 123 ] ;
2255: LD_ADDR_VAR 0 8
2259: PUSH
2260: LD_INT 90
2262: PUSH
2263: LD_INT 3
2265: PUSH
2266: LD_INT 94
2268: PUSH
2269: LD_INT 3
2271: PUSH
2272: LD_INT 98
2274: PUSH
2275: LD_INT 3
2277: PUSH
2278: LD_INT 102
2280: PUSH
2281: LD_INT 3
2283: PUSH
2284: LD_INT 106
2286: PUSH
2287: LD_INT 3
2289: PUSH
2290: LD_INT 110
2292: PUSH
2293: LD_INT 3
2295: PUSH
2296: LD_INT 140
2298: PUSH
2299: LD_INT 132
2301: PUSH
2302: LD_INT 144
2304: PUSH
2305: LD_INT 132
2307: PUSH
2308: LD_INT 148
2310: PUSH
2311: LD_INT 132
2313: PUSH
2314: LD_INT 152
2316: PUSH
2317: LD_INT 132
2319: PUSH
2320: LD_INT 156
2322: PUSH
2323: LD_INT 132
2325: PUSH
2326: LD_INT 160
2328: PUSH
2329: LD_INT 132
2331: PUSH
2332: LD_INT 164
2334: PUSH
2335: LD_INT 132
2337: PUSH
2338: LD_INT 168
2340: PUSH
2341: LD_INT 132
2343: PUSH
2344: LD_INT 72
2346: PUSH
2347: LD_INT 132
2349: PUSH
2350: LD_INT 70
2352: PUSH
2353: LD_INT 123
2355: PUSH
2356: EMPTY
2357: LIST
2358: LIST
2359: LIST
2360: LIST
2361: LIST
2362: LIST
2363: LIST
2364: LIST
2365: LIST
2366: LIST
2367: LIST
2368: LIST
2369: LIST
2370: LIST
2371: LIST
2372: LIST
2373: LIST
2374: LIST
2375: LIST
2376: LIST
2377: LIST
2378: LIST
2379: LIST
2380: LIST
2381: LIST
2382: LIST
2383: LIST
2384: LIST
2385: LIST
2386: LIST
2387: LIST
2388: LIST
2389: ST_TO_ADDR
// uc_side := 3 ;
2390: LD_ADDR_OWVAR 20
2394: PUSH
2395: LD_INT 3
2397: ST_TO_ADDR
// uc_nation := nat ;
2398: LD_ADDR_OWVAR 21
2402: PUSH
2403: LD_VAR 0 1
2407: ST_TO_ADDR
// if typ = 1 then
2408: LD_VAR 0 2
2412: PUSH
2413: LD_INT 1
2415: EQUAL
2416: IFFALSE 2494
// begin for i = 1 to num do
2418: LD_ADDR_VAR 0 6
2422: PUSH
2423: DOUBLE
2424: LD_INT 1
2426: DEC
2427: ST_TO_ADDR
2428: LD_VAR 0 3
2432: PUSH
2433: FOR_TO
2434: IFFALSE 2492
// begin un = HumUnit ( 1 , 0 , lvl ) ;
2436: LD_ADDR_VAR 0 7
2440: PUSH
2441: LD_INT 1
2443: PPUSH
2444: LD_INT 0
2446: PPUSH
2447: LD_VAR 0 4
2451: PPUSH
2452: CALL 1213 0 3
2456: ST_TO_ADDR
// PlaceUnitArea ( un , area , false ) ;
2457: LD_VAR 0 7
2461: PPUSH
2462: LD_VAR 0 13
2466: PPUSH
2467: LD_INT 0
2469: PPUSH
2470: CALL_OW 49
// units = units ^ un ;
2474: LD_ADDR_VAR 0 12
2478: PUSH
2479: LD_VAR 0 12
2483: PUSH
2484: LD_VAR 0 7
2488: ADD
2489: ST_TO_ADDR
// end ;
2490: GO 2433
2492: POP
2493: POP
// end ; if typ = 2 then
2494: LD_VAR 0 2
2498: PUSH
2499: LD_INT 2
2501: EQUAL
2502: IFFALSE 2642
// begin for i = 1 to num do
2504: LD_ADDR_VAR 0 6
2508: PUSH
2509: DOUBLE
2510: LD_INT 1
2512: DEC
2513: ST_TO_ADDR
2514: LD_VAR 0 3
2518: PUSH
2519: FOR_TO
2520: IFFALSE 2640
// begin un = HumUnit ( 1 , 0 , lvl ) ;
2522: LD_ADDR_VAR 0 7
2526: PUSH
2527: LD_INT 1
2529: PPUSH
2530: LD_INT 0
2532: PPUSH
2533: LD_VAR 0 4
2537: PPUSH
2538: CALL 1213 0 3
2542: ST_TO_ADDR
// PlaceUnitArea ( un , area , false ) ;
2543: LD_VAR 0 7
2547: PPUSH
2548: LD_VAR 0 13
2552: PPUSH
2553: LD_INT 0
2555: PPUSH
2556: CALL_OW 49
// units = units ^ un ;
2560: LD_ADDR_VAR 0 12
2564: PUSH
2565: LD_VAR 0 12
2569: PUSH
2570: LD_VAR 0 7
2574: ADD
2575: ST_TO_ADDR
// un = HumUnit ( Rand ( 8 , 9 ) , 0 , lvl ) ;
2576: LD_ADDR_VAR 0 7
2580: PUSH
2581: LD_INT 8
2583: PPUSH
2584: LD_INT 9
2586: PPUSH
2587: CALL_OW 12
2591: PPUSH
2592: LD_INT 0
2594: PPUSH
2595: LD_VAR 0 4
2599: PPUSH
2600: CALL 1213 0 3
2604: ST_TO_ADDR
// PlaceUnitArea ( un , area , false ) ;
2605: LD_VAR 0 7
2609: PPUSH
2610: LD_VAR 0 13
2614: PPUSH
2615: LD_INT 0
2617: PPUSH
2618: CALL_OW 49
// units = units ^ un ;
2622: LD_ADDR_VAR 0 12
2626: PUSH
2627: LD_VAR 0 12
2631: PUSH
2632: LD_VAR 0 7
2636: ADD
2637: ST_TO_ADDR
// end ;
2638: GO 2519
2640: POP
2641: POP
// end ; if typ = 3 then
2642: LD_VAR 0 2
2646: PUSH
2647: LD_INT 3
2649: EQUAL
2650: IFFALSE 2894
// begin for i = 1 to num do
2652: LD_ADDR_VAR 0 6
2656: PUSH
2657: DOUBLE
2658: LD_INT 1
2660: DEC
2661: ST_TO_ADDR
2662: LD_VAR 0 3
2666: PUSH
2667: FOR_TO
2668: IFFALSE 2892
// begin un = HumUnit ( 3 , 0 , lvl ) ;
2670: LD_ADDR_VAR 0 7
2674: PUSH
2675: LD_INT 3
2677: PPUSH
2678: LD_INT 0
2680: PPUSH
2681: LD_VAR 0 4
2685: PPUSH
2686: CALL 1213 0 3
2690: ST_TO_ADDR
// if nat = 1 then
2691: LD_VAR 0 1
2695: PUSH
2696: LD_INT 1
2698: EQUAL
2699: IFFALSE 2733
// begin vc_chassis = us_medium_tracked ;
2701: LD_ADDR_OWVAR 37
2705: PUSH
2706: LD_INT 3
2708: ST_TO_ADDR
// vc_engine = engine_siberite ;
2709: LD_ADDR_OWVAR 39
2713: PUSH
2714: LD_INT 3
2716: ST_TO_ADDR
// vc_control = control_manual ;
2717: LD_ADDR_OWVAR 38
2721: PUSH
2722: LD_INT 1
2724: ST_TO_ADDR
// vc_weapon = us_double_gun ;
2725: LD_ADDR_OWVAR 40
2729: PUSH
2730: LD_INT 5
2732: ST_TO_ADDR
// end ; if nat = 2 then
2733: LD_VAR 0 1
2737: PUSH
2738: LD_INT 2
2740: EQUAL
2741: IFFALSE 2775
// begin vc_chassis = ar_medium_trike ;
2743: LD_ADDR_OWVAR 37
2747: PUSH
2748: LD_INT 13
2750: ST_TO_ADDR
// vc_engine = engine_siberite ;
2751: LD_ADDR_OWVAR 39
2755: PUSH
2756: LD_INT 3
2758: ST_TO_ADDR
// vc_control = control_manual ;
2759: LD_ADDR_OWVAR 38
2763: PUSH
2764: LD_INT 1
2766: ST_TO_ADDR
// vc_weapon = ar_gun ;
2767: LD_ADDR_OWVAR 40
2771: PUSH
2772: LD_INT 27
2774: ST_TO_ADDR
// end ; if nat = 3 then
2775: LD_VAR 0 1
2779: PUSH
2780: LD_INT 3
2782: EQUAL
2783: IFFALSE 2817
// begin vc_chassis = ru_medium_tracked ;
2785: LD_ADDR_OWVAR 37
2789: PUSH
2790: LD_INT 22
2792: ST_TO_ADDR
// vc_engine = engine_siberite ;
2793: LD_ADDR_OWVAR 39
2797: PUSH
2798: LD_INT 3
2800: ST_TO_ADDR
// vc_control = control_manual ;
2801: LD_ADDR_OWVAR 38
2805: PUSH
2806: LD_INT 1
2808: ST_TO_ADDR
// vc_weapon = ru_gun ;
2809: LD_ADDR_OWVAR 40
2813: PUSH
2814: LD_INT 44
2816: ST_TO_ADDR
// end ; veh = CreateVehicle ;
2817: LD_ADDR_VAR 0 11
2821: PUSH
2822: CALL_OW 45
2826: ST_TO_ADDR
// PlaceUnitArea ( veh , area , false ) ;
2827: LD_VAR 0 11
2831: PPUSH
2832: LD_VAR 0 13
2836: PPUSH
2837: LD_INT 0
2839: PPUSH
2840: CALL_OW 49
// PlaceHumanInUnit ( un , veh ) ;
2844: LD_VAR 0 7
2848: PPUSH
2849: LD_VAR 0 11
2853: PPUSH
2854: CALL_OW 52
// units = units ^ un ;
2858: LD_ADDR_VAR 0 12
2862: PUSH
2863: LD_VAR 0 12
2867: PUSH
2868: LD_VAR 0 7
2872: ADD
2873: ST_TO_ADDR
// units = units ^ veh ;
2874: LD_ADDR_VAR 0 12
2878: PUSH
2879: LD_VAR 0 12
2883: PUSH
2884: LD_VAR 0 11
2888: ADD
2889: ST_TO_ADDR
// end ;
2890: GO 2667
2892: POP
2893: POP
// end ; if typ = 4 then
2894: LD_VAR 0 2
2898: PUSH
2899: LD_INT 4
2901: EQUAL
2902: IFFALSE 3146
// begin for i = 1 to num do
2904: LD_ADDR_VAR 0 6
2908: PUSH
2909: DOUBLE
2910: LD_INT 1
2912: DEC
2913: ST_TO_ADDR
2914: LD_VAR 0 3
2918: PUSH
2919: FOR_TO
2920: IFFALSE 3144
// begin un = HumUnit ( 3 , 0 , lvl ) ;
2922: LD_ADDR_VAR 0 7
2926: PUSH
2927: LD_INT 3
2929: PPUSH
2930: LD_INT 0
2932: PPUSH
2933: LD_VAR 0 4
2937: PPUSH
2938: CALL 1213 0 3
2942: ST_TO_ADDR
// if nat = 1 then
2943: LD_VAR 0 1
2947: PUSH
2948: LD_INT 1
2950: EQUAL
2951: IFFALSE 2985
// begin vc_chassis = us_medium_tracked ;
2953: LD_ADDR_OWVAR 37
2957: PUSH
2958: LD_INT 3
2960: ST_TO_ADDR
// vc_engine = engine_siberite ;
2961: LD_ADDR_OWVAR 39
2965: PUSH
2966: LD_INT 3
2968: ST_TO_ADDR
// vc_control = control_manual ;
2969: LD_ADDR_OWVAR 38
2973: PUSH
2974: LD_INT 1
2976: ST_TO_ADDR
// vc_weapon = us_rocket_launcher ;
2977: LD_ADDR_OWVAR 40
2981: PUSH
2982: LD_INT 7
2984: ST_TO_ADDR
// end ; if nat = 2 then
2985: LD_VAR 0 1
2989: PUSH
2990: LD_INT 2
2992: EQUAL
2993: IFFALSE 3027
// begin vc_chassis = ar_medium_trike ;
2995: LD_ADDR_OWVAR 37
2999: PUSH
3000: LD_INT 13
3002: ST_TO_ADDR
// vc_engine = engine_siberite ;
3003: LD_ADDR_OWVAR 39
3007: PUSH
3008: LD_INT 3
3010: ST_TO_ADDR
// vc_control = control_manual ;
3011: LD_ADDR_OWVAR 38
3015: PUSH
3016: LD_INT 1
3018: ST_TO_ADDR
// vc_weapon = ar_rocket_launcher ;
3019: LD_ADDR_OWVAR 40
3023: PUSH
3024: LD_INT 28
3026: ST_TO_ADDR
// end ; if nat = 3 then
3027: LD_VAR 0 1
3031: PUSH
3032: LD_INT 3
3034: EQUAL
3035: IFFALSE 3069
// begin vc_chassis = ru_medium_tracked ;
3037: LD_ADDR_OWVAR 37
3041: PUSH
3042: LD_INT 22
3044: ST_TO_ADDR
// vc_engine = engine_siberite ;
3045: LD_ADDR_OWVAR 39
3049: PUSH
3050: LD_INT 3
3052: ST_TO_ADDR
// vc_control = control_manual ;
3053: LD_ADDR_OWVAR 38
3057: PUSH
3058: LD_INT 1
3060: ST_TO_ADDR
// vc_weapon = ru_rocket_launcher ;
3061: LD_ADDR_OWVAR 40
3065: PUSH
3066: LD_INT 45
3068: ST_TO_ADDR
// end ; veh = CreateVehicle ;
3069: LD_ADDR_VAR 0 11
3073: PUSH
3074: CALL_OW 45
3078: ST_TO_ADDR
// PlaceUnitArea ( veh , area , false ) ;
3079: LD_VAR 0 11
3083: PPUSH
3084: LD_VAR 0 13
3088: PPUSH
3089: LD_INT 0
3091: PPUSH
3092: CALL_OW 49
// PlaceHumanInUnit ( un , veh ) ;
3096: LD_VAR 0 7
3100: PPUSH
3101: LD_VAR 0 11
3105: PPUSH
3106: CALL_OW 52
// units = units ^ un ;
3110: LD_ADDR_VAR 0 12
3114: PUSH
3115: LD_VAR 0 12
3119: PUSH
3120: LD_VAR 0 7
3124: ADD
3125: ST_TO_ADDR
// units = units ^ veh ;
3126: LD_ADDR_VAR 0 12
3130: PUSH
3131: LD_VAR 0 12
3135: PUSH
3136: LD_VAR 0 11
3140: ADD
3141: ST_TO_ADDR
// end ;
3142: GO 2919
3144: POP
3145: POP
// end ; if typ = 5 then
3146: LD_VAR 0 2
3150: PUSH
3151: LD_INT 5
3153: EQUAL
3154: IFFALSE 3398
// begin for i = 1 to num do
3156: LD_ADDR_VAR 0 6
3160: PUSH
3161: DOUBLE
3162: LD_INT 1
3164: DEC
3165: ST_TO_ADDR
3166: LD_VAR 0 3
3170: PUSH
3171: FOR_TO
3172: IFFALSE 3396
// begin un = HumUnit ( 3 , 0 , lvl ) ;
3174: LD_ADDR_VAR 0 7
3178: PUSH
3179: LD_INT 3
3181: PPUSH
3182: LD_INT 0
3184: PPUSH
3185: LD_VAR 0 4
3189: PPUSH
3190: CALL 1213 0 3
3194: ST_TO_ADDR
// if nat = 1 then
3195: LD_VAR 0 1
3199: PUSH
3200: LD_INT 1
3202: EQUAL
3203: IFFALSE 3237
// begin vc_chassis = us_heavy_tracked ;
3205: LD_ADDR_OWVAR 37
3209: PUSH
3210: LD_INT 4
3212: ST_TO_ADDR
// vc_engine = engine_siberite ;
3213: LD_ADDR_OWVAR 39
3217: PUSH
3218: LD_INT 3
3220: ST_TO_ADDR
// vc_control = control_manual ;
3221: LD_ADDR_OWVAR 38
3225: PUSH
3226: LD_INT 1
3228: ST_TO_ADDR
// vc_weapon = us_heavy_gun ;
3229: LD_ADDR_OWVAR 40
3233: PUSH
3234: LD_INT 6
3236: ST_TO_ADDR
// end ; if nat = 2 then
3237: LD_VAR 0 1
3241: PUSH
3242: LD_INT 2
3244: EQUAL
3245: IFFALSE 3279
// begin vc_chassis = ar_half_tracked ;
3247: LD_ADDR_OWVAR 37
3251: PUSH
3252: LD_INT 14
3254: ST_TO_ADDR
// vc_engine = engine_siberite ;
3255: LD_ADDR_OWVAR 39
3259: PUSH
3260: LD_INT 3
3262: ST_TO_ADDR
// vc_control = control_manual ;
3263: LD_ADDR_OWVAR 38
3267: PUSH
3268: LD_INT 1
3270: ST_TO_ADDR
// vc_weapon = ar_rocket_launcher ;
3271: LD_ADDR_OWVAR 40
3275: PUSH
3276: LD_INT 28
3278: ST_TO_ADDR
// end ; if nat = 3 then
3279: LD_VAR 0 1
3283: PUSH
3284: LD_INT 3
3286: EQUAL
3287: IFFALSE 3321
// begin vc_chassis = ru_heavy_tracked ;
3289: LD_ADDR_OWVAR 37
3293: PUSH
3294: LD_INT 24
3296: ST_TO_ADDR
// vc_engine = engine_siberite ;
3297: LD_ADDR_OWVAR 39
3301: PUSH
3302: LD_INT 3
3304: ST_TO_ADDR
// vc_control = control_manual ;
3305: LD_ADDR_OWVAR 38
3309: PUSH
3310: LD_INT 1
3312: ST_TO_ADDR
// vc_weapon = ru_heavy_gun ;
3313: LD_ADDR_OWVAR 40
3317: PUSH
3318: LD_INT 46
3320: ST_TO_ADDR
// end ; veh = CreateVehicle ;
3321: LD_ADDR_VAR 0 11
3325: PUSH
3326: CALL_OW 45
3330: ST_TO_ADDR
// PlaceUnitArea ( veh , area , false ) ;
3331: LD_VAR 0 11
3335: PPUSH
3336: LD_VAR 0 13
3340: PPUSH
3341: LD_INT 0
3343: PPUSH
3344: CALL_OW 49
// PlaceHumanInUnit ( un , veh ) ;
3348: LD_VAR 0 7
3352: PPUSH
3353: LD_VAR 0 11
3357: PPUSH
3358: CALL_OW 52
// units = units ^ un ;
3362: LD_ADDR_VAR 0 12
3366: PUSH
3367: LD_VAR 0 12
3371: PUSH
3372: LD_VAR 0 7
3376: ADD
3377: ST_TO_ADDR
// units = units ^ veh ;
3378: LD_ADDR_VAR 0 12
3382: PUSH
3383: LD_VAR 0 12
3387: PUSH
3388: LD_VAR 0 11
3392: ADD
3393: ST_TO_ADDR
// end ;
3394: GO 3171
3396: POP
3397: POP
// end ; if typ = 6 then
3398: LD_VAR 0 2
3402: PUSH
3403: LD_INT 6
3405: EQUAL
3406: IFFALSE 3650
// begin for i = 1 to num do
3408: LD_ADDR_VAR 0 6
3412: PUSH
3413: DOUBLE
3414: LD_INT 1
3416: DEC
3417: ST_TO_ADDR
3418: LD_VAR 0 3
3422: PUSH
3423: FOR_TO
3424: IFFALSE 3648
// begin un = HumUnit ( 3 , 0 , lvl ) ;
3426: LD_ADDR_VAR 0 7
3430: PUSH
3431: LD_INT 3
3433: PPUSH
3434: LD_INT 0
3436: PPUSH
3437: LD_VAR 0 4
3441: PPUSH
3442: CALL 1213 0 3
3446: ST_TO_ADDR
// if nat = 1 then
3447: LD_VAR 0 1
3451: PUSH
3452: LD_INT 1
3454: EQUAL
3455: IFFALSE 3489
// begin vc_chassis = us_morphling ;
3457: LD_ADDR_OWVAR 37
3461: PUSH
3462: LD_INT 5
3464: ST_TO_ADDR
// vc_engine = engine_siberite ;
3465: LD_ADDR_OWVAR 39
3469: PUSH
3470: LD_INT 3
3472: ST_TO_ADDR
// vc_control = control_manual ;
3473: LD_ADDR_OWVAR 38
3477: PUSH
3478: LD_INT 1
3480: ST_TO_ADDR
// vc_weapon = us_double_laser ;
3481: LD_ADDR_OWVAR 40
3485: PUSH
3486: LD_INT 10
3488: ST_TO_ADDR
// end ; if nat = 2 then
3489: LD_VAR 0 1
3493: PUSH
3494: LD_INT 2
3496: EQUAL
3497: IFFALSE 3531
// begin vc_chassis = ar_medium_trike ;
3499: LD_ADDR_OWVAR 37
3503: PUSH
3504: LD_INT 13
3506: ST_TO_ADDR
// vc_engine = engine_siberite ;
3507: LD_ADDR_OWVAR 39
3511: PUSH
3512: LD_INT 3
3514: ST_TO_ADDR
// vc_control = control_apeman ;
3515: LD_ADDR_OWVAR 38
3519: PUSH
3520: LD_INT 5
3522: ST_TO_ADDR
// vc_weapon = 29 ;
3523: LD_ADDR_OWVAR 40
3527: PUSH
3528: LD_INT 29
3530: ST_TO_ADDR
// end ; if nat = 3 then
3531: LD_VAR 0 1
3535: PUSH
3536: LD_INT 3
3538: EQUAL
3539: IFFALSE 3573
// begin vc_chassis = ru_heavy_tracked ;
3541: LD_ADDR_OWVAR 37
3545: PUSH
3546: LD_INT 24
3548: ST_TO_ADDR
// vc_engine = engine_siberite ;
3549: LD_ADDR_OWVAR 39
3553: PUSH
3554: LD_INT 3
3556: ST_TO_ADDR
// vc_control = control_manual ;
3557: LD_ADDR_OWVAR 38
3561: PUSH
3562: LD_INT 1
3564: ST_TO_ADDR
// vc_weapon = ru_rocket ;
3565: LD_ADDR_OWVAR 40
3569: PUSH
3570: LD_INT 47
3572: ST_TO_ADDR
// end ; veh = CreateVehicle ;
3573: LD_ADDR_VAR 0 11
3577: PUSH
3578: CALL_OW 45
3582: ST_TO_ADDR
// PlaceUnitArea ( veh , area , false ) ;
3583: LD_VAR 0 11
3587: PPUSH
3588: LD_VAR 0 13
3592: PPUSH
3593: LD_INT 0
3595: PPUSH
3596: CALL_OW 49
// PlaceHumanInUnit ( un , veh ) ;
3600: LD_VAR 0 7
3604: PPUSH
3605: LD_VAR 0 11
3609: PPUSH
3610: CALL_OW 52
// units = units ^ un ;
3614: LD_ADDR_VAR 0 12
3618: PUSH
3619: LD_VAR 0 12
3623: PUSH
3624: LD_VAR 0 7
3628: ADD
3629: ST_TO_ADDR
// units = units ^ veh ;
3630: LD_ADDR_VAR 0 12
3634: PUSH
3635: LD_VAR 0 12
3639: PUSH
3640: LD_VAR 0 11
3644: ADD
3645: ST_TO_ADDR
// end ;
3646: GO 3423
3648: POP
3649: POP
// end ; if typ = 7 then
3650: LD_VAR 0 2
3654: PUSH
3655: LD_INT 7
3657: EQUAL
3658: IFFALSE 3808
// begin for i = 1 to num do
3660: LD_ADDR_VAR 0 6
3664: PUSH
3665: DOUBLE
3666: LD_INT 1
3668: DEC
3669: ST_TO_ADDR
3670: LD_VAR 0 3
3674: PUSH
3675: FOR_TO
3676: IFFALSE 3806
// begin un = HumUnit ( 3 , 0 , lvl ) ;
3678: LD_ADDR_VAR 0 7
3682: PUSH
3683: LD_INT 3
3685: PPUSH
3686: LD_INT 0
3688: PPUSH
3689: LD_VAR 0 4
3693: PPUSH
3694: CALL 1213 0 3
3698: ST_TO_ADDR
// vc_chassis = ru_heavy_tracked ;
3699: LD_ADDR_OWVAR 37
3703: PUSH
3704: LD_INT 24
3706: ST_TO_ADDR
// vc_engine = engine_combustion ;
3707: LD_ADDR_OWVAR 39
3711: PUSH
3712: LD_INT 1
3714: ST_TO_ADDR
// vc_control = control_manual ;
3715: LD_ADDR_OWVAR 38
3719: PUSH
3720: LD_INT 1
3722: ST_TO_ADDR
// vc_weapon = ru_rocket ;
3723: LD_ADDR_OWVAR 40
3727: PUSH
3728: LD_INT 47
3730: ST_TO_ADDR
// veh = CreateVehicle ;
3731: LD_ADDR_VAR 0 11
3735: PUSH
3736: CALL_OW 45
3740: ST_TO_ADDR
// PlaceUnitArea ( veh , area , false ) ;
3741: LD_VAR 0 11
3745: PPUSH
3746: LD_VAR 0 13
3750: PPUSH
3751: LD_INT 0
3753: PPUSH
3754: CALL_OW 49
// PlaceHumanInUnit ( un , veh ) ;
3758: LD_VAR 0 7
3762: PPUSH
3763: LD_VAR 0 11
3767: PPUSH
3768: CALL_OW 52
// units = units ^ un ;
3772: LD_ADDR_VAR 0 12
3776: PUSH
3777: LD_VAR 0 12
3781: PUSH
3782: LD_VAR 0 7
3786: ADD
3787: ST_TO_ADDR
// units = units ^ veh ;
3788: LD_ADDR_VAR 0 12
3792: PUSH
3793: LD_VAR 0 12
3797: PUSH
3798: LD_VAR 0 11
3802: ADD
3803: ST_TO_ADDR
// end ;
3804: GO 3675
3806: POP
3807: POP
// end ; repeat begin Wait ( 0 0$01 ) ;
3808: LD_INT 35
3810: PPUSH
3811: CALL_OW 67
// enemy := FilterAllUnits ( [ f_side , player_side ] ) ;
3815: LD_ADDR_VAR 0 14
3819: PUSH
3820: LD_INT 22
3822: PUSH
3823: LD_EXP 1
3827: PUSH
3828: EMPTY
3829: LIST
3830: LIST
3831: PPUSH
3832: CALL_OW 69
3836: ST_TO_ADDR
// for un in units do
3837: LD_ADDR_VAR 0 7
3841: PUSH
3842: LD_VAR 0 12
3846: PUSH
3847: FOR_IN
3848: IFFALSE 4006
// begin target1 := NearestUnitToUnit ( FilterAllUnits ( [ f_side , player_side ] ) , un ) ;
3850: LD_ADDR_VAR 0 15
3854: PUSH
3855: LD_INT 22
3857: PUSH
3858: LD_EXP 1
3862: PUSH
3863: EMPTY
3864: LIST
3865: LIST
3866: PPUSH
3867: CALL_OW 69
3871: PPUSH
3872: LD_VAR 0 7
3876: PPUSH
3877: CALL_OW 74
3881: ST_TO_ADDR
// target2 := NearestUnitToUnit ( FilterAllUnits ( [ [ [ f_side , player_side ] , [ f_btype , b_bunker ] , [ f_occupied ] ] ] ) , un ) ;
3882: LD_ADDR_VAR 0 16
3886: PUSH
3887: LD_INT 22
3889: PUSH
3890: LD_EXP 1
3894: PUSH
3895: EMPTY
3896: LIST
3897: LIST
3898: PUSH
3899: LD_INT 30
3901: PUSH
3902: LD_INT 32
3904: PUSH
3905: EMPTY
3906: LIST
3907: LIST
3908: PUSH
3909: LD_INT 59
3911: PUSH
3912: EMPTY
3913: LIST
3914: PUSH
3915: EMPTY
3916: LIST
3917: LIST
3918: LIST
3919: PUSH
3920: EMPTY
3921: LIST
3922: PPUSH
3923: CALL_OW 69
3927: PPUSH
3928: LD_VAR 0 7
3932: PPUSH
3933: CALL_OW 74
3937: ST_TO_ADDR
// if GetDistUnits ( un , target1 ) + 3 < GetDistUnits ( un , target2 ) then
3938: LD_VAR 0 7
3942: PPUSH
3943: LD_VAR 0 15
3947: PPUSH
3948: CALL_OW 296
3952: PUSH
3953: LD_INT 3
3955: PLUS
3956: PUSH
3957: LD_VAR 0 7
3961: PPUSH
3962: LD_VAR 0 16
3966: PPUSH
3967: CALL_OW 296
3971: LESS
3972: IFFALSE 3990
// begin ComAttackUnit ( un , target1 ) ;
3974: LD_VAR 0 7
3978: PPUSH
3979: LD_VAR 0 15
3983: PPUSH
3984: CALL_OW 115
// end else
3988: GO 4004
// begin ComAttackUnit ( un , target2 ) ;
3990: LD_VAR 0 7
3994: PPUSH
3995: LD_VAR 0 16
3999: PPUSH
4000: CALL_OW 115
// end ; end ;
4004: GO 3847
4006: POP
4007: POP
// end until FilterAllUnits ( [ f_side , 3 ] ) < 3 ;
4008: LD_INT 22
4010: PUSH
4011: LD_INT 3
4013: PUSH
4014: EMPTY
4015: LIST
4016: LIST
4017: PPUSH
4018: CALL_OW 69
4022: PUSH
4023: LD_INT 3
4025: LESS
4026: IFFALSE 3808
// Wait ( 0 0$05 ) ;
4028: LD_INT 175
4030: PPUSH
4031: CALL_OW 67
// for un in FilterAllUnits ( [ f_side , 3 ] ) do
4035: LD_ADDR_VAR 0 7
4039: PUSH
4040: LD_INT 22
4042: PUSH
4043: LD_INT 3
4045: PUSH
4046: EMPTY
4047: LIST
4048: LIST
4049: PPUSH
4050: CALL_OW 69
4054: PUSH
4055: FOR_IN
4056: IFFALSE 4076
// begin RemoveUnit ( un ) ;
4058: LD_VAR 0 7
4062: PPUSH
4063: CALL_OW 64
// Wait ( 0 0$0.1 ) ;
4067: LD_INT 4
4069: PPUSH
4070: CALL_OW 67
// end ;
4074: GO 4055
4076: POP
4077: POP
// wave = wave + 1 ;
4078: LD_ADDR_EXP 10
4082: PUSH
4083: LD_EXP 10
4087: PUSH
4088: LD_INT 1
4090: PLUS
4091: ST_TO_ADDR
// end ;
4092: LD_VAR 0 5
4096: RET
// every 0 0$01 do var un , units ;
4097: GO 4099
4099: DISABLE
4100: LD_INT 0
4102: PPUSH
4103: PPUSH
// begin enable ;
4104: ENABLE
// units := FilterAllUnits ( [ [ f_side , 3 ] , [ f_empty ] ] ) ;
4105: LD_ADDR_VAR 0 2
4109: PUSH
4110: LD_INT 22
4112: PUSH
4113: LD_INT 3
4115: PUSH
4116: EMPTY
4117: LIST
4118: LIST
4119: PUSH
4120: LD_INT 58
4122: PUSH
4123: EMPTY
4124: LIST
4125: PUSH
4126: EMPTY
4127: LIST
4128: LIST
4129: PPUSH
4130: CALL_OW 69
4134: ST_TO_ADDR
// for un in units do
4135: LD_ADDR_VAR 0 1
4139: PUSH
4140: LD_VAR 0 2
4144: PUSH
4145: FOR_IN
4146: IFFALSE 4159
// begin RemoveUnit ( un ) ;
4148: LD_VAR 0 1
4152: PPUSH
4153: CALL_OW 64
// end ;
4157: GO 4145
4159: POP
4160: POP
// end ; end_of_file
4161: PPOPN 2
4163: END
// every 0 0$01 trigger main_depot do
4164: LD_EXP 5
4168: IFFALSE 4178
4170: GO 4172
4172: DISABLE
// begin CreatorWaves ;
4173: CALL 4179 0 0
// enable ;
4177: ENABLE
// end ;
4178: END
// function CreatorWaves ; var randmin , randmax , randmaxx , x , ad , i , filter ; begin
4179: LD_INT 0
4181: PPUSH
4182: PPUSH
4183: PPUSH
4184: PPUSH
4185: PPUSH
4186: PPUSH
4187: PPUSH
4188: PPUSH
// filter := FilterAllUnits ( [ f_side , 3 ] ) ;
4189: LD_ADDR_VAR 0 8
4193: PUSH
4194: LD_INT 22
4196: PUSH
4197: LD_INT 3
4199: PUSH
4200: EMPTY
4201: LIST
4202: LIST
4203: PPUSH
4204: CALL_OW 69
4208: ST_TO_ADDR
// if filter > 0 then
4209: LD_VAR 0 8
4213: PUSH
4214: LD_INT 0
4216: GREATER
4217: IFFALSE 4256
// for i = 1 to filter do
4219: LD_ADDR_VAR 0 7
4223: PUSH
4224: DOUBLE
4225: LD_INT 1
4227: DEC
4228: ST_TO_ADDR
4229: LD_VAR 0 8
4233: PUSH
4234: FOR_TO
4235: IFFALSE 4254
// RemoveUnit ( filter [ i ] ) ;
4237: LD_VAR 0 8
4241: PUSH
4242: LD_VAR 0 7
4246: ARRAY
4247: PPUSH
4248: CALL_OW 64
4252: GO 4234
4254: POP
4255: POP
// randmin = 3 + ( level * 2 ) ;
4256: LD_ADDR_VAR 0 2
4260: PUSH
4261: LD_INT 3
4263: PUSH
4264: LD_EXP 4
4268: PUSH
4269: LD_INT 2
4271: MUL
4272: PLUS
4273: ST_TO_ADDR
// randmax = 8 + ( level * 2 ) ;
4274: LD_ADDR_VAR 0 3
4278: PUSH
4279: LD_INT 8
4281: PUSH
4282: LD_EXP 4
4286: PUSH
4287: LD_INT 2
4289: MUL
4290: PLUS
4291: ST_TO_ADDR
// randmaxx = 15 + ( level * 2 ) ;
4292: LD_ADDR_VAR 0 4
4296: PUSH
4297: LD_INT 15
4299: PUSH
4300: LD_EXP 4
4304: PUSH
4305: LD_INT 2
4307: MUL
4308: PLUS
4309: ST_TO_ADDR
// ad = 1 ;
4310: LD_ADDR_VAR 0 6
4314: PUSH
4315: LD_INT 1
4317: ST_TO_ADDR
// if wave = 1 then
4318: LD_EXP 10
4322: PUSH
4323: LD_INT 1
4325: EQUAL
4326: IFFALSE 4457
// begin time_to = 5 5$00 ;
4328: LD_ADDR_EXP 9
4332: PUSH
4333: LD_INT 10500
4335: ST_TO_ADDR
// while ( time_to > 0 ) do
4336: LD_EXP 9
4340: PUSH
4341: LD_INT 0
4343: GREATER
4344: IFFALSE 4369
// begin time_to = time_to - 0 0$01 ;
4346: LD_ADDR_EXP 9
4350: PUSH
4351: LD_EXP 9
4355: PUSH
4356: LD_INT 35
4358: MINUS
4359: ST_TO_ADDR
// Wait ( 0 0$01 ) ;
4360: LD_INT 35
4362: PPUSH
4363: CALL_OW 67
// end ;
4367: GO 4336
// CreateWave ( Rand ( 1 , 3 ) , p , Rand ( randmin , randmax ) , Rand ( 2 + 1 * level , 2 + 2 * level ) ) ;
4369: LD_INT 1
4371: PPUSH
4372: LD_INT 3
4374: PPUSH
4375: CALL_OW 12
4379: PPUSH
4380: LD_EXP 11
4384: PPUSH
4385: LD_VAR 0 2
4389: PPUSH
4390: LD_VAR 0 3
4394: PPUSH
4395: CALL_OW 12
4399: PPUSH
4400: LD_INT 2
4402: PUSH
4403: LD_INT 1
4405: PUSH
4406: LD_EXP 4
4410: MUL
4411: PLUS
4412: PPUSH
4413: LD_INT 2
4415: PUSH
4416: LD_INT 2
4418: PUSH
4419: LD_EXP 4
4423: MUL
4424: PLUS
4425: PPUSH
4426: CALL_OW 12
4430: PPUSH
4431: CALL 2218 0 4
// p = p + Rand ( 1 , 2 ) ;
4435: LD_ADDR_EXP 11
4439: PUSH
4440: LD_EXP 11
4444: PUSH
4445: LD_INT 1
4447: PPUSH
4448: LD_INT 2
4450: PPUSH
4451: CALL_OW 12
4455: PLUS
4456: ST_TO_ADDR
// end ; if wave > 1 then
4457: LD_EXP 10
4461: PUSH
4462: LD_INT 1
4464: GREATER
4465: IFFALSE 4774
// begin time_to = Rand ( 3 3$40 , 5 5$00 ) ;
4467: LD_ADDR_EXP 9
4471: PUSH
4472: LD_INT 7700
4474: PPUSH
4475: LD_INT 10500
4477: PPUSH
4478: CALL_OW 12
4482: ST_TO_ADDR
// while ( time_to > 0 ) do
4483: LD_EXP 9
4487: PUSH
4488: LD_INT 0
4490: GREATER
4491: IFFALSE 4516
// begin time_to = time_to - 0 0$01 ;
4493: LD_ADDR_EXP 9
4497: PUSH
4498: LD_EXP 9
4502: PUSH
4503: LD_INT 35
4505: MINUS
4506: ST_TO_ADDR
// Wait ( 0 0$01 ) ;
4507: LD_INT 35
4509: PPUSH
4510: CALL_OW 67
// end ;
4514: GO 4483
// if wave = 6 then
4516: LD_EXP 10
4520: PUSH
4521: LD_INT 6
4523: EQUAL
4524: IFFALSE 4548
// p = p - ( Rand ( 1 , 2 ) ) ;
4526: LD_ADDR_EXP 11
4530: PUSH
4531: LD_EXP 11
4535: PUSH
4536: LD_INT 1
4538: PPUSH
4539: LD_INT 2
4541: PPUSH
4542: CALL_OW 12
4546: MINUS
4547: ST_TO_ADDR
// if wave = 8 then
4548: LD_EXP 10
4552: PUSH
4553: LD_INT 8
4555: EQUAL
4556: IFFALSE 4566
// p = 4 ;
4558: LD_ADDR_EXP 11
4562: PUSH
4563: LD_INT 4
4565: ST_TO_ADDR
// if wave = 10 then
4566: LD_EXP 10
4570: PUSH
4571: LD_INT 10
4573: EQUAL
4574: IFFALSE 4584
// p = 6 ;
4576: LD_ADDR_EXP 11
4580: PUSH
4581: LD_INT 6
4583: ST_TO_ADDR
// if wave in [ 20 , 30 , 40 , 60 , 80 , 90 , 95 , 99 ] then
4584: LD_EXP 10
4588: PUSH
4589: LD_INT 20
4591: PUSH
4592: LD_INT 30
4594: PUSH
4595: LD_INT 40
4597: PUSH
4598: LD_INT 60
4600: PUSH
4601: LD_INT 80
4603: PUSH
4604: LD_INT 90
4606: PUSH
4607: LD_INT 95
4609: PUSH
4610: LD_INT 99
4612: PUSH
4613: EMPTY
4614: LIST
4615: LIST
4616: LIST
4617: LIST
4618: LIST
4619: LIST
4620: LIST
4621: LIST
4622: IN
4623: IFFALSE 4644
// begin Wait ( Rand ( 0 0$03 , 0 0$10 ) ) ;
4625: LD_INT 105
4627: PPUSH
4628: LD_INT 350
4630: PPUSH
4631: CALL_OW 12
4635: PPUSH
4636: CALL_OW 67
// SendBombWave ;
4640: CALL 4880 0 0
// end ; if p > 6 then
4644: LD_EXP 11
4648: PUSH
4649: LD_INT 6
4651: GREATER
4652: IFFALSE 4662
// begin p = 2 ;
4654: LD_ADDR_EXP 11
4658: PUSH
4659: LD_INT 2
4661: ST_TO_ADDR
// end ; CreateWave ( Rand ( 1 , 3 ) , p , ( Rand ( randmin , randmax ) + Rand ( ad - 1 , ad + 1 ) ) , Rand ( 2 + 1 * level , 2 + 2 * level ) ) ;
4662: LD_INT 1
4664: PPUSH
4665: LD_INT 3
4667: PPUSH
4668: CALL_OW 12
4672: PPUSH
4673: LD_EXP 11
4677: PPUSH
4678: LD_VAR 0 2
4682: PPUSH
4683: LD_VAR 0 3
4687: PPUSH
4688: CALL_OW 12
4692: PUSH
4693: LD_VAR 0 6
4697: PUSH
4698: LD_INT 1
4700: MINUS
4701: PPUSH
4702: LD_VAR 0 6
4706: PUSH
4707: LD_INT 1
4709: PLUS
4710: PPUSH
4711: CALL_OW 12
4715: PLUS
4716: PPUSH
4717: LD_INT 2
4719: PUSH
4720: LD_INT 1
4722: PUSH
4723: LD_EXP 4
4727: MUL
4728: PLUS
4729: PPUSH
4730: LD_INT 2
4732: PUSH
4733: LD_INT 2
4735: PUSH
4736: LD_EXP 4
4740: MUL
4741: PLUS
4742: PPUSH
4743: CALL_OW 12
4747: PPUSH
4748: CALL 2218 0 4
// p = p + Rand ( 0 , 1 ) ;
4752: LD_ADDR_EXP 11
4756: PUSH
4757: LD_EXP 11
4761: PUSH
4762: LD_INT 0
4764: PPUSH
4765: LD_INT 1
4767: PPUSH
4768: CALL_OW 12
4772: PLUS
4773: ST_TO_ADDR
// end ; if wave in [ 5 , 10 , 15 , 20 , 25 , 30 , 40 , 50 , 60 , 80 , 90 , 92 , 94 , 96 , 97 , 98 , 99 ] and ad <= 10 then
4774: LD_EXP 10
4778: PUSH
4779: LD_INT 5
4781: PUSH
4782: LD_INT 10
4784: PUSH
4785: LD_INT 15
4787: PUSH
4788: LD_INT 20
4790: PUSH
4791: LD_INT 25
4793: PUSH
4794: LD_INT 30
4796: PUSH
4797: LD_INT 40
4799: PUSH
4800: LD_INT 50
4802: PUSH
4803: LD_INT 60
4805: PUSH
4806: LD_INT 80
4808: PUSH
4809: LD_INT 90
4811: PUSH
4812: LD_INT 92
4814: PUSH
4815: LD_INT 94
4817: PUSH
4818: LD_INT 96
4820: PUSH
4821: LD_INT 97
4823: PUSH
4824: LD_INT 98
4826: PUSH
4827: LD_INT 99
4829: PUSH
4830: EMPTY
4831: LIST
4832: LIST
4833: LIST
4834: LIST
4835: LIST
4836: LIST
4837: LIST
4838: LIST
4839: LIST
4840: LIST
4841: LIST
4842: LIST
4843: LIST
4844: LIST
4845: LIST
4846: LIST
4847: LIST
4848: IN
4849: PUSH
4850: LD_VAR 0 6
4854: PUSH
4855: LD_INT 10
4857: LESSEQUAL
4858: AND
4859: IFFALSE 4875
// begin ad := ad + 2 ;
4861: LD_ADDR_VAR 0 6
4865: PUSH
4866: LD_VAR 0 6
4870: PUSH
4871: LD_INT 2
4873: PLUS
4874: ST_TO_ADDR
// end ; end ;
4875: LD_VAR 0 1
4879: RET
// export function SendBombWave ; var x ; begin
4880: LD_INT 0
4882: PPUSH
4883: PPUSH
// x := 0 ;
4884: LD_ADDR_VAR 0 2
4888: PUSH
4889: LD_INT 0
4891: ST_TO_ADDR
// x := Rand ( 1 , 3 ) ;
4892: LD_ADDR_VAR 0 2
4896: PUSH
4897: LD_INT 1
4899: PPUSH
4900: LD_INT 3
4902: PPUSH
4903: CALL_OW 12
4907: ST_TO_ADDR
// case x of 1 :
4908: LD_VAR 0 2
4912: PUSH
4913: LD_INT 1
4915: DOUBLE
4916: EQUAL
4917: IFTRUE 4921
4919: GO 4934
4921: POP
// SendSiberiteRocket ( 71 , 52 ) ; 2 :
4922: LD_INT 71
4924: PPUSH
4925: LD_INT 52
4927: PPUSH
4928: CALL_OW 429
4932: GO 4967
4934: LD_INT 2
4936: DOUBLE
4937: EQUAL
4938: IFTRUE 4942
4940: GO 4955
4942: POP
// SendSiberiteRocket ( 118 , 96 ) ; 3 :
4943: LD_INT 118
4945: PPUSH
4946: LD_INT 96
4948: PPUSH
4949: CALL_OW 429
4953: GO 4967
4955: LD_INT 3
4957: DOUBLE
4958: EQUAL
4959: IFTRUE 4963
4961: GO 4966
4963: POP
// ; end ;
4964: GO 4967
4966: POP
// Wait ( 2 2$00 ) ;
4967: LD_INT 4200
4969: PPUSH
4970: CALL_OW 67
// end ; end_of_file
4974: LD_VAR 0 1
4978: RET
// on UnitDestroyed ( un ) do begin if GetSide ( un ) = 3 then
4979: LD_VAR 0 1
4983: PPUSH
4984: CALL_OW 255
4988: PUSH
4989: LD_INT 3
4991: EQUAL
4992: IFFALSE 5138
// begin if un in FilterAllUnits ( [ f_type , unit_human ] ) then
4994: LD_VAR 0 1
4998: PUSH
4999: LD_INT 21
5001: PUSH
5002: LD_INT 1
5004: PUSH
5005: EMPTY
5006: LIST
5007: LIST
5008: PPUSH
5009: CALL_OW 69
5013: IN
5014: IFFALSE 5046
// points := ( points + 10 * level ) - ( player_number / 2 ) ;
5016: LD_ADDR_EXP 7
5020: PUSH
5021: LD_EXP 7
5025: PUSH
5026: LD_INT 10
5028: PUSH
5029: LD_EXP 4
5033: MUL
5034: PLUS
5035: PUSH
5036: LD_EXP 3
5040: PUSH
5041: LD_INT 2
5043: DIVREAL
5044: MINUS
5045: ST_TO_ADDR
// bonus_points := bonus_points + 5 * level ;
5046: LD_ADDR_EXP 8
5050: PUSH
5051: LD_EXP 8
5055: PUSH
5056: LD_INT 5
5058: PUSH
5059: LD_EXP 4
5063: MUL
5064: PLUS
5065: ST_TO_ADDR
// if un in FilterAllUnits ( [ f_type , unit_vehicle ] ) then
5066: LD_VAR 0 1
5070: PUSH
5071: LD_INT 21
5073: PUSH
5074: LD_INT 2
5076: PUSH
5077: EMPTY
5078: LIST
5079: LIST
5080: PPUSH
5081: CALL_OW 69
5085: IN
5086: IFFALSE 5118
// points := ( points + 10 * level ) - ( player_number / 2 ) ;
5088: LD_ADDR_EXP 7
5092: PUSH
5093: LD_EXP 7
5097: PUSH
5098: LD_INT 10
5100: PUSH
5101: LD_EXP 4
5105: MUL
5106: PLUS
5107: PUSH
5108: LD_EXP 3
5112: PUSH
5113: LD_INT 2
5115: DIVREAL
5116: MINUS
5117: ST_TO_ADDR
// bonus_points := bonus_points + 10 * level ;
5118: LD_ADDR_EXP 8
5122: PUSH
5123: LD_EXP 8
5127: PUSH
5128: LD_INT 10
5130: PUSH
5131: LD_EXP 4
5135: MUL
5136: PLUS
5137: ST_TO_ADDR
// end ; if un = main_depot then
5138: LD_VAR 0 1
5142: PUSH
5143: LD_EXP 5
5147: EQUAL
5148: IFFALSE 5173
// begin main_depot = 0 ;
5150: LD_ADDR_EXP 5
5154: PUSH
5155: LD_INT 0
5157: ST_TO_ADDR
// SetRestrict ( b_depot , player_side , state_enabled ) ;
5158: LD_INT 0
5160: PPUSH
5161: LD_EXP 1
5165: PPUSH
5166: LD_INT 1
5168: PPUSH
5169: CALL_OW 324
// end ; end ;
5173: PPOPN 1
5175: END
// on UnitGoesToRed ( un ) do begin if GetSide ( un ) = 3 then
5176: LD_VAR 0 1
5180: PPUSH
5181: CALL_OW 255
5185: PUSH
5186: LD_INT 3
5188: EQUAL
5189: IFFALSE 5277
// begin if un in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_control , control_manual ] ] ) then
5191: LD_VAR 0 1
5195: PUSH
5196: LD_INT 21
5198: PUSH
5199: LD_INT 2
5201: PUSH
5202: EMPTY
5203: LIST
5204: LIST
5205: PUSH
5206: LD_INT 33
5208: PUSH
5209: LD_INT 1
5211: PUSH
5212: EMPTY
5213: LIST
5214: LIST
5215: PUSH
5216: EMPTY
5217: LIST
5218: LIST
5219: PPUSH
5220: CALL_OW 69
5224: IN
5225: IFFALSE 5257
// points := ( points + 10 * level ) - ( player_number / 2 ) ;
5227: LD_ADDR_EXP 7
5231: PUSH
5232: LD_EXP 7
5236: PUSH
5237: LD_INT 10
5239: PUSH
5240: LD_EXP 4
5244: MUL
5245: PLUS
5246: PUSH
5247: LD_EXP 3
5251: PUSH
5252: LD_INT 2
5254: DIVREAL
5255: MINUS
5256: ST_TO_ADDR
// bonus_points := bonus_points + 10 * level ;
5257: LD_ADDR_EXP 8
5261: PUSH
5262: LD_EXP 8
5266: PUSH
5267: LD_INT 10
5269: PUSH
5270: LD_EXP 4
5274: MUL
5275: PLUS
5276: ST_TO_ADDR
// end ; end ; end_of_file
5277: PPOPN 1
5279: END
// every 0 0$03 trigger bonus_points >= [ 35 , 65 , 80 , 100 ] [ level ] and FilterAllUnits ( [ f_side , 3 ] ) < 1 do var un , veh , beh , i , k ;
5280: LD_EXP 8
5284: PUSH
5285: LD_INT 35
5287: PUSH
5288: LD_INT 65
5290: PUSH
5291: LD_INT 80
5293: PUSH
5294: LD_INT 100
5296: PUSH
5297: EMPTY
5298: LIST
5299: LIST
5300: LIST
5301: LIST
5302: PUSH
5303: LD_EXP 4
5307: ARRAY
5308: GREATEREQUAL
5309: PUSH
5310: LD_INT 22
5312: PUSH
5313: LD_INT 3
5315: PUSH
5316: EMPTY
5317: LIST
5318: LIST
5319: PPUSH
5320: CALL_OW 69
5324: PUSH
5325: LD_INT 1
5327: LESS
5328: AND
5329: IFFALSE 6411
5331: GO 5333
5333: DISABLE
5334: LD_INT 0
5336: PPUSH
5337: PPUSH
5338: PPUSH
5339: PPUSH
5340: PPUSH
// begin enable ;
5341: ENABLE
// bonus_points = 0 ;
5342: LD_ADDR_EXP 8
5346: PUSH
5347: LD_INT 0
5349: ST_TO_ADDR
// k = 0 ;
5350: LD_ADDR_VAR 0 5
5354: PUSH
5355: LD_INT 0
5357: ST_TO_ADDR
// k = Rand ( 1 , 3 ) ;
5358: LD_ADDR_VAR 0 5
5362: PUSH
5363: LD_INT 1
5365: PPUSH
5366: LD_INT 3
5368: PPUSH
5369: CALL_OW 12
5373: ST_TO_ADDR
// if k = 1 then
5374: LD_VAR 0 5
5378: PUSH
5379: LD_INT 1
5381: EQUAL
5382: IFFALSE 5706
// begin case Query ( AddGift1 ) of 1 :
5384: LD_STRING AddGift1
5386: PPUSH
5387: CALL_OW 97
5391: PUSH
5392: LD_INT 1
5394: DOUBLE
5395: EQUAL
5396: IFTRUE 5400
5398: GO 5461
5400: POP
// begin SetResourceType ( main_depot , mat_cans , GetResourceType ( GetBase ( main_depot ) , mat_cans ) + 1000 - Rand ( level * 100 , level * 200 ) ) ;
5401: LD_EXP 5
5405: PPUSH
5406: LD_INT 1
5408: PPUSH
5409: LD_EXP 5
5413: PPUSH
5414: CALL_OW 274
5418: PPUSH
5419: LD_INT 1
5421: PPUSH
5422: CALL_OW 275
5426: PUSH
5427: LD_INT 1000
5429: PLUS
5430: PUSH
5431: LD_EXP 4
5435: PUSH
5436: LD_INT 100
5438: MUL
5439: PPUSH
5440: LD_EXP 4
5444: PUSH
5445: LD_INT 200
5447: MUL
5448: PPUSH
5449: CALL_OW 12
5453: MINUS
5454: PPUSH
5455: CALL_OW 277
// end ; 2 :
5459: GO 5706
5461: LD_INT 2
5463: DOUBLE
5464: EQUAL
5465: IFTRUE 5469
5467: GO 5544
5469: POP
// begin uc_side = player_side ;
5470: LD_ADDR_OWVAR 20
5474: PUSH
5475: LD_EXP 1
5479: ST_TO_ADDR
// uc_nation = Rand ( 1 , 3 ) ;
5480: LD_ADDR_OWVAR 21
5484: PUSH
5485: LD_INT 1
5487: PPUSH
5488: LD_INT 3
5490: PPUSH
5491: CALL_OW 12
5495: ST_TO_ADDR
// for i = 1 to 2 do
5496: LD_ADDR_VAR 0 4
5500: PUSH
5501: DOUBLE
5502: LD_INT 1
5504: DEC
5505: ST_TO_ADDR
5506: LD_INT 2
5508: PUSH
5509: FOR_TO
5510: IFFALSE 5540
// PlaceUnitArea ( HumUnit ( 2 , 0 , s ) , gifta , true ) ;
5512: LD_INT 2
5514: PPUSH
5515: LD_INT 0
5517: PPUSH
5518: LD_EXP 6
5522: PPUSH
5523: CALL 1213 0 3
5527: PPUSH
5528: LD_INT 6
5530: PPUSH
5531: LD_INT 1
5533: PPUSH
5534: CALL_OW 49
5538: GO 5509
5540: POP
5541: POP
// end ; 3 :
5542: GO 5706
5544: LD_INT 3
5546: DOUBLE
5547: EQUAL
5548: IFTRUE 5552
5550: GO 5609
5552: POP
// begin uc_side = player_side ;
5553: LD_ADDR_OWVAR 20
5557: PUSH
5558: LD_EXP 1
5562: ST_TO_ADDR
// uc_nation = nation_russian ;
5563: LD_ADDR_OWVAR 21
5567: PUSH
5568: LD_INT 3
5570: ST_TO_ADDR
// vc_chassis = 25 ;
5571: LD_ADDR_OWVAR 37
5575: PUSH
5576: LD_INT 25
5578: ST_TO_ADDR
// beh := CreateVehicle ;
5579: LD_ADDR_VAR 0 3
5583: PUSH
5584: CALL_OW 45
5588: ST_TO_ADDR
// PlaceUnitXY ( beh , 75 , 95 , true ) ;
5589: LD_VAR 0 3
5593: PPUSH
5594: LD_INT 75
5596: PPUSH
5597: LD_INT 95
5599: PPUSH
5600: LD_INT 1
5602: PPUSH
5603: CALL_OW 48
// end ; 4 :
5607: GO 5706
5609: LD_INT 4
5611: DOUBLE
5612: EQUAL
5613: IFTRUE 5617
5615: GO 5705
5617: POP
// begin uc_side = player_side ;
5618: LD_ADDR_OWVAR 20
5622: PUSH
5623: LD_EXP 1
5627: ST_TO_ADDR
// uc_nation = 3 ;
5628: LD_ADDR_OWVAR 21
5632: PUSH
5633: LD_INT 3
5635: ST_TO_ADDR
// vc_chassis = ru_heavy_tracked ;
5636: LD_ADDR_OWVAR 37
5640: PUSH
5641: LD_INT 24
5643: ST_TO_ADDR
// vc_control = control_computer ;
5644: LD_ADDR_OWVAR 38
5648: PUSH
5649: LD_INT 3
5651: ST_TO_ADDR
// vc_engine = engine_siberite ;
5652: LD_ADDR_OWVAR 39
5656: PUSH
5657: LD_INT 3
5659: ST_TO_ADDR
// vc_weapon = ru_crane ;
5660: LD_ADDR_OWVAR 40
5664: PUSH
5665: LD_INT 52
5667: ST_TO_ADDR
// for i = 1 to 3 do
5668: LD_ADDR_VAR 0 4
5672: PUSH
5673: DOUBLE
5674: LD_INT 1
5676: DEC
5677: ST_TO_ADDR
5678: LD_INT 3
5680: PUSH
5681: FOR_TO
5682: IFFALSE 5701
// PlaceUnitArea ( CreateVehicle , respawnplayer , true ) ;
5684: CALL_OW 45
5688: PPUSH
5689: LD_INT 1
5691: PPUSH
5692: LD_INT 1
5694: PPUSH
5695: CALL_OW 49
5699: GO 5681
5701: POP
5702: POP
// end ; end ;
5703: GO 5706
5705: POP
// end ; if k = 2 then
5706: LD_VAR 0 5
5710: PUSH
5711: LD_INT 2
5713: EQUAL
5714: IFFALSE 6052
// begin case Query ( AddGift2 ) of 1 :
5716: LD_STRING AddGift2
5718: PPUSH
5719: CALL_OW 97
5723: PUSH
5724: LD_INT 1
5726: DOUBLE
5727: EQUAL
5728: IFTRUE 5732
5730: GO 5793
5732: POP
// begin SetResourceType ( main_depot , mat_cans , GetResourceType ( GetBase ( main_depot ) , mat_cans ) + 1000 - Rand ( level * 100 , level * 200 ) ) ;
5733: LD_EXP 5
5737: PPUSH
5738: LD_INT 1
5740: PPUSH
5741: LD_EXP 5
5745: PPUSH
5746: CALL_OW 274
5750: PPUSH
5751: LD_INT 1
5753: PPUSH
5754: CALL_OW 275
5758: PUSH
5759: LD_INT 1000
5761: PLUS
5762: PUSH
5763: LD_EXP 4
5767: PUSH
5768: LD_INT 100
5770: MUL
5771: PPUSH
5772: LD_EXP 4
5776: PUSH
5777: LD_INT 200
5779: MUL
5780: PPUSH
5781: CALL_OW 12
5785: MINUS
5786: PPUSH
5787: CALL_OW 277
// end ; 2 :
5791: GO 6052
5793: LD_INT 2
5795: DOUBLE
5796: EQUAL
5797: IFTRUE 5801
5799: GO 5876
5801: POP
// begin uc_side = player_side ;
5802: LD_ADDR_OWVAR 20
5806: PUSH
5807: LD_EXP 1
5811: ST_TO_ADDR
// uc_nation = Rand ( 1 , 3 ) ;
5812: LD_ADDR_OWVAR 21
5816: PUSH
5817: LD_INT 1
5819: PPUSH
5820: LD_INT 3
5822: PPUSH
5823: CALL_OW 12
5827: ST_TO_ADDR
// for i = 1 to 3 do
5828: LD_ADDR_VAR 0 4
5832: PUSH
5833: DOUBLE
5834: LD_INT 1
5836: DEC
5837: ST_TO_ADDR
5838: LD_INT 3
5840: PUSH
5841: FOR_TO
5842: IFFALSE 5872
// PlaceUnitArea ( HumUnit ( 9 , 0 , s ) , gifta , true ) ;
5844: LD_INT 9
5846: PPUSH
5847: LD_INT 0
5849: PPUSH
5850: LD_EXP 6
5854: PPUSH
5855: CALL 1213 0 3
5859: PPUSH
5860: LD_INT 6
5862: PPUSH
5863: LD_INT 1
5865: PPUSH
5866: CALL_OW 49
5870: GO 5841
5872: POP
5873: POP
// end ; 3 :
5874: GO 6052
5876: LD_INT 3
5878: DOUBLE
5879: EQUAL
5880: IFTRUE 5884
5882: GO 5955
5884: POP
// begin uc_side = player_side ;
5885: LD_ADDR_OWVAR 20
5889: PUSH
5890: LD_EXP 1
5894: ST_TO_ADDR
// uc_nation = nation_russian ;
5895: LD_ADDR_OWVAR 21
5899: PUSH
5900: LD_INT 3
5902: ST_TO_ADDR
// vc_chassis = ru_heavy_tracked ;
5903: LD_ADDR_OWVAR 37
5907: PUSH
5908: LD_INT 24
5910: ST_TO_ADDR
// vc_engine = engine_siberite ;
5911: LD_ADDR_OWVAR 39
5915: PUSH
5916: LD_INT 3
5918: ST_TO_ADDR
// vc_control = control_computer ;
5919: LD_ADDR_OWVAR 38
5923: PUSH
5924: LD_INT 3
5926: ST_TO_ADDR
// vc_weapon = ru_siberium_rocket ;
5927: LD_ADDR_OWVAR 40
5931: PUSH
5932: LD_INT 48
5934: ST_TO_ADDR
// PlaceUnitXY ( CreateVehicle , 75 , 95 , true ) ;
5935: CALL_OW 45
5939: PPUSH
5940: LD_INT 75
5942: PPUSH
5943: LD_INT 95
5945: PPUSH
5946: LD_INT 1
5948: PPUSH
5949: CALL_OW 48
// end ; 4 :
5953: GO 6052
5955: LD_INT 4
5957: DOUBLE
5958: EQUAL
5959: IFTRUE 5963
5961: GO 6051
5963: POP
// begin uc_side = player_side ;
5964: LD_ADDR_OWVAR 20
5968: PUSH
5969: LD_EXP 1
5973: ST_TO_ADDR
// uc_nation = 3 ;
5974: LD_ADDR_OWVAR 21
5978: PUSH
5979: LD_INT 3
5981: ST_TO_ADDR
// vc_chassis = us_morphling ;
5982: LD_ADDR_OWVAR 37
5986: PUSH
5987: LD_INT 5
5989: ST_TO_ADDR
// vc_control = control_manual ;
5990: LD_ADDR_OWVAR 38
5994: PUSH
5995: LD_INT 1
5997: ST_TO_ADDR
// vc_engine = engine_siberite ;
5998: LD_ADDR_OWVAR 39
6002: PUSH
6003: LD_INT 3
6005: ST_TO_ADDR
// vc_weapon = us_heavy_gun ;
6006: LD_ADDR_OWVAR 40
6010: PUSH
6011: LD_INT 6
6013: ST_TO_ADDR
// for i = 1 to 2 do
6014: LD_ADDR_VAR 0 4
6018: PUSH
6019: DOUBLE
6020: LD_INT 1
6022: DEC
6023: ST_TO_ADDR
6024: LD_INT 2
6026: PUSH
6027: FOR_TO
6028: IFFALSE 6047
// PlaceUnitArea ( CreateVehicle , respawnplayer , true ) ;
6030: CALL_OW 45
6034: PPUSH
6035: LD_INT 1
6037: PPUSH
6038: LD_INT 1
6040: PPUSH
6041: CALL_OW 49
6045: GO 6027
6047: POP
6048: POP
// end ; end ;
6049: GO 6052
6051: POP
// end ; if k = 3 then
6052: LD_VAR 0 5
6056: PUSH
6057: LD_INT 3
6059: EQUAL
6060: IFFALSE 6411
// begin case Query ( AddGift3 ) of 1 :
6062: LD_STRING AddGift3
6064: PPUSH
6065: CALL_OW 97
6069: PUSH
6070: LD_INT 1
6072: DOUBLE
6073: EQUAL
6074: IFTRUE 6078
6076: GO 6139
6078: POP
// begin SetResourceType ( main_depot , mat_cans , GetResourceType ( GetBase ( main_depot ) , mat_cans ) + 1000 - Rand ( level * 100 , level * 200 ) ) ;
6079: LD_EXP 5
6083: PPUSH
6084: LD_INT 1
6086: PPUSH
6087: LD_EXP 5
6091: PPUSH
6092: CALL_OW 274
6096: PPUSH
6097: LD_INT 1
6099: PPUSH
6100: CALL_OW 275
6104: PUSH
6105: LD_INT 1000
6107: PLUS
6108: PUSH
6109: LD_EXP 4
6113: PUSH
6114: LD_INT 100
6116: MUL
6117: PPUSH
6118: LD_EXP 4
6122: PUSH
6123: LD_INT 200
6125: MUL
6126: PPUSH
6127: CALL_OW 12
6131: MINUS
6132: PPUSH
6133: CALL_OW 277
// end ; 2 :
6137: GO 6411
6139: LD_INT 2
6141: DOUBLE
6142: EQUAL
6143: IFTRUE 6147
6145: GO 6220
6147: POP
// begin uc_side = player_side ;
6148: LD_ADDR_OWVAR 20
6152: PUSH
6153: LD_EXP 1
6157: ST_TO_ADDR
// uc_nation = player_nation ;
6158: LD_ADDR_OWVAR 21
6162: PUSH
6163: LD_EXP 2
6167: ST_TO_ADDR
// for i = 1 to 2 do
6168: LD_ADDR_VAR 0 4
6172: PUSH
6173: DOUBLE
6174: LD_INT 1
6176: DEC
6177: ST_TO_ADDR
6178: LD_INT 2
6180: PUSH
6181: FOR_TO
6182: IFFALSE 6216
// PlaceUnitArea ( HumUnit ( 3 , 0 , s + 1 ) , gifta , true ) ;
6184: LD_INT 3
6186: PPUSH
6187: LD_INT 0
6189: PPUSH
6190: LD_EXP 6
6194: PUSH
6195: LD_INT 1
6197: PLUS
6198: PPUSH
6199: CALL 1213 0 3
6203: PPUSH
6204: LD_INT 6
6206: PPUSH
6207: LD_INT 1
6209: PPUSH
6210: CALL_OW 49
6214: GO 6181
6216: POP
6217: POP
// end ; 3 :
6218: GO 6411
6220: LD_INT 3
6222: DOUBLE
6223: EQUAL
6224: IFTRUE 6228
6226: GO 6314
6228: POP
// begin SetRestrict ( 31 , player_side , state_researched ) ;
6229: LD_INT 31
6231: PPUSH
6232: LD_EXP 1
6236: PPUSH
6237: LD_INT 2
6239: PPUSH
6240: CALL_OW 324
// uc_side = player_side ;
6244: LD_ADDR_OWVAR 20
6248: PUSH
6249: LD_EXP 1
6253: ST_TO_ADDR
// uc_nation = nation_russian ;
6254: LD_ADDR_OWVAR 21
6258: PUSH
6259: LD_INT 3
6261: ST_TO_ADDR
// vc_chassis = ru_medium_tracked ;
6262: LD_ADDR_OWVAR 37
6266: PUSH
6267: LD_INT 22
6269: ST_TO_ADDR
// vc_engine = engine_siberite ;
6270: LD_ADDR_OWVAR 39
6274: PUSH
6275: LD_INT 3
6277: ST_TO_ADDR
// vc_control = control_manual ;
6278: LD_ADDR_OWVAR 38
6282: PUSH
6283: LD_INT 1
6285: ST_TO_ADDR
// vc_weapon = ru_time_lapser ;
6286: LD_ADDR_OWVAR 40
6290: PUSH
6291: LD_INT 49
6293: ST_TO_ADDR
// PlaceUnitXY ( CreateVehicle , 75 , 95 , true ) ;
6294: CALL_OW 45
6298: PPUSH
6299: LD_INT 75
6301: PPUSH
6302: LD_INT 95
6304: PPUSH
6305: LD_INT 1
6307: PPUSH
6308: CALL_OW 48
// end ; 4 :
6312: GO 6411
6314: LD_INT 4
6316: DOUBLE
6317: EQUAL
6318: IFTRUE 6322
6320: GO 6410
6322: POP
// begin uc_side = player_side ;
6323: LD_ADDR_OWVAR 20
6327: PUSH
6328: LD_EXP 1
6332: ST_TO_ADDR
// uc_nation = 3 ;
6333: LD_ADDR_OWVAR 21
6337: PUSH
6338: LD_INT 3
6340: ST_TO_ADDR
// vc_chassis = ru_heavy_tracked ;
6341: LD_ADDR_OWVAR 37
6345: PUSH
6346: LD_INT 24
6348: ST_TO_ADDR
// vc_control = control_computer ;
6349: LD_ADDR_OWVAR 38
6353: PUSH
6354: LD_INT 3
6356: ST_TO_ADDR
// vc_engine = engine_siberite ;
6357: LD_ADDR_OWVAR 39
6361: PUSH
6362: LD_INT 3
6364: ST_TO_ADDR
// vc_weapon = ru_rocket ;
6365: LD_ADDR_OWVAR 40
6369: PUSH
6370: LD_INT 47
6372: ST_TO_ADDR
// for i = 1 to 2 do
6373: LD_ADDR_VAR 0 4
6377: PUSH
6378: DOUBLE
6379: LD_INT 1
6381: DEC
6382: ST_TO_ADDR
6383: LD_INT 2
6385: PUSH
6386: FOR_TO
6387: IFFALSE 6406
// PlaceUnitArea ( CreateVehicle , respawnplayer , true ) ;
6389: CALL_OW 45
6393: PPUSH
6394: LD_INT 1
6396: PPUSH
6397: LD_INT 1
6399: PPUSH
6400: CALL_OW 49
6404: GO 6386
6406: POP
6407: POP
// end ; end ;
6408: GO 6411
6410: POP
// end ; end ; end_of_file
6411: PPOPN 5
6413: END
// every 0 0$01 trigger wave >= 100 do var i ;
6414: LD_EXP 10
6418: PUSH
6419: LD_INT 100
6421: GREATEREQUAL
6422: IFFALSE 6480
6424: GO 6426
6426: DISABLE
6427: LD_INT 0
6429: PPUSH
// begin case Query ( Win ) of end ;
6430: LD_STRING Win
6432: PPUSH
6433: CALL_OW 97
6437: PUSH
6438: POP
// for i = 1 to 3 do
6439: LD_ADDR_VAR 0 1
6443: PUSH
6444: DOUBLE
6445: LD_INT 1
6447: DEC
6448: ST_TO_ADDR
6449: LD_INT 3
6451: PUSH
6452: FOR_TO
6453: IFFALSE 6467
// begin AddMedal (  , 1 ) ;
6455: LD_STRING 
6457: PPUSH
6458: LD_INT 1
6460: PPUSH
6461: CALL_OW 101
// end ;
6465: GO 6452
6467: POP
6468: POP
// GiveMedals (  ) ;
6469: LD_STRING 
6471: PPUSH
6472: CALL_OW 102
// YouWin ;
6476: CALL_OW 103
// end ;
6480: PPOPN 1
6482: END
