// export debug ; starting begin ResetFog ;
   0: CALL_OW 335
// RandomizeAll ;
   4: CALL_OW 11
// debug := false ;
   8: LD_ADDR_EXP 1
  12: PUSH
  13: LD_INT 0
  15: ST_TO_ADDR
// if debug then
  16: LD_EXP 1
  20: IFFALSE 29
// FogOff ( 1 ) ;
  22: LD_INT 1
  24: PPUSH
  25: CALL_OW 344
// InitForest ;
  29: CALL 93 0 0
// music_nat := 3 ;
  33: LD_ADDR_OWVAR 71
  37: PUSH
  38: LD_INT 3
  40: ST_TO_ADDR
// music_class := 3 ;
  41: LD_ADDR_OWVAR 72
  45: PUSH
  46: LD_INT 3
  48: ST_TO_ADDR
// if debug then
  49: LD_EXP 1
  53: IFFALSE 72
// begin Difficulty := 2 ;
  55: LD_ADDR_OWVAR 67
  59: PUSH
  60: LD_INT 2
  62: ST_TO_ADDR
// SetRoad ( 2 ) ;
  63: LD_INT 2
  65: PPUSH
  66: CALL 251 0 1
// end else
  70: GO 76
// InitSettings ;
  72: CALL 395 0 0
// PrepareConvoy ;
  76: CALL 2186 0 0
// InitPlayer ;
  80: CALL 428 0 0
// InitEnemy ;
  84: CALL 3121 0 0
// Action ;
  88: CALL 1261 0 0
// end ; end_of_file
  92: END
// export function InitForest ; begin
  93: LD_INT 0
  95: PPUSH
// PlaceTreesToArea ( forest , [ 21 , 22 , 24 , 21 , 22 , 24 , 38 , 39 ] , 385 , 100 , 1 ) ;
  96: LD_INT 1
  98: PPUSH
  99: LD_INT 21
 101: PUSH
 102: LD_INT 22
 104: PUSH
 105: LD_INT 24
 107: PUSH
 108: LD_INT 21
 110: PUSH
 111: LD_INT 22
 113: PUSH
 114: LD_INT 24
 116: PUSH
 117: LD_INT 38
 119: PUSH
 120: LD_INT 39
 122: PUSH
 123: EMPTY
 124: LIST
 125: LIST
 126: LIST
 127: LIST
 128: LIST
 129: LIST
 130: LIST
 131: LIST
 132: PPUSH
 133: LD_INT 385
 135: PPUSH
 136: LD_INT 100
 138: PPUSH
 139: LD_INT 1
 141: PPUSH
 142: CALL_OW 352
// PlaceTreesToArea ( forest , [ 21 , 22 , 24 , 21 , 22 , 24 , 38 , 39 ] , 140 , 75 , 2 ) ;
 146: LD_INT 1
 148: PPUSH
 149: LD_INT 21
 151: PUSH
 152: LD_INT 22
 154: PUSH
 155: LD_INT 24
 157: PUSH
 158: LD_INT 21
 160: PUSH
 161: LD_INT 22
 163: PUSH
 164: LD_INT 24
 166: PUSH
 167: LD_INT 38
 169: PUSH
 170: LD_INT 39
 172: PUSH
 173: EMPTY
 174: LIST
 175: LIST
 176: LIST
 177: LIST
 178: LIST
 179: LIST
 180: LIST
 181: LIST
 182: PPUSH
 183: LD_INT 140
 185: PPUSH
 186: LD_INT 75
 188: PPUSH
 189: LD_INT 2
 191: PPUSH
 192: CALL_OW 352
// PlaceTreesToArea ( forest , [ 21 , 22 , 24 , 21 , 22 , 24 , 38 , 39 ] , 460 , 70 , 2 ) ;
 196: LD_INT 1
 198: PPUSH
 199: LD_INT 21
 201: PUSH
 202: LD_INT 22
 204: PUSH
 205: LD_INT 24
 207: PUSH
 208: LD_INT 21
 210: PUSH
 211: LD_INT 22
 213: PUSH
 214: LD_INT 24
 216: PUSH
 217: LD_INT 38
 219: PUSH
 220: LD_INT 39
 222: PUSH
 223: EMPTY
 224: LIST
 225: LIST
 226: LIST
 227: LIST
 228: LIST
 229: LIST
 230: LIST
 231: LIST
 232: PPUSH
 233: LD_INT 460
 235: PPUSH
 236: LD_INT 70
 238: PPUSH
 239: LD_INT 2
 241: PPUSH
 242: CALL_OW 352
// end ;
 246: LD_VAR 0 1
 250: RET
// export function SetRoad ( num ) ; begin
 251: LD_INT 0
 253: PPUSH
// case num of 1 :
 254: LD_VAR 0 1
 258: PUSH
 259: LD_INT 1
 261: DOUBLE
 262: EQUAL
 263: IFTRUE 267
 265: GO 319
 267: POP
// begin RemoveEnvironmentArea ( pos2 ) ;
 268: LD_INT 4
 270: PPUSH
 271: CALL_OW 355
// RemoveEnvironmentArea ( pos3 ) ;
 275: LD_INT 6
 277: PPUSH
 278: CALL_OW 355
// RemoveEnvironmentArea ( road2 ) ;
 282: LD_INT 5
 284: PPUSH
 285: CALL_OW 355
// RemoveEnvironmentArea ( road2 ) ;
 289: LD_INT 5
 291: PPUSH
 292: CALL_OW 355
// RemoveEnvironmentArea ( road2 ) ;
 296: LD_INT 5
 298: PPUSH
 299: CALL_OW 355
// RemoveEnvironmentArea ( road2 ) ;
 303: LD_INT 5
 305: PPUSH
 306: CALL_OW 355
// RemoveEnvironmentArea ( road2 ) ;
 310: LD_INT 5
 312: PPUSH
 313: CALL_OW 355
// end ; 2 :
 317: GO 380
 319: LD_INT 2
 321: DOUBLE
 322: EQUAL
 323: IFTRUE 327
 325: GO 379
 327: POP
// begin RemoveEnvironmentArea ( pos2 ) ;
 328: LD_INT 4
 330: PPUSH
 331: CALL_OW 355
// RemoveEnvironmentArea ( pos1 ) ;
 335: LD_INT 2
 337: PPUSH
 338: CALL_OW 355
// RemoveEnvironmentArea ( road1 ) ;
 342: LD_INT 3
 344: PPUSH
 345: CALL_OW 355
// RemoveEnvironmentArea ( road1 ) ;
 349: LD_INT 3
 351: PPUSH
 352: CALL_OW 355
// RemoveEnvironmentArea ( road1 ) ;
 356: LD_INT 3
 358: PPUSH
 359: CALL_OW 355
// RemoveEnvironmentArea ( road1 ) ;
 363: LD_INT 3
 365: PPUSH
 366: CALL_OW 355
// RemoveEnvironmentArea ( road1 ) ;
 370: LD_INT 3
 372: PPUSH
 373: CALL_OW 355
// end ; end ;
 377: GO 380
 379: POP
// road := num ;
 380: LD_ADDR_EXP 2
 384: PUSH
 385: LD_VAR 0 1
 389: ST_TO_ADDR
// end ; end_of_file
 390: LD_VAR 0 2
 394: RET
// export road , skill , cargos ; export function InitSettings ; begin
 395: LD_INT 0
 397: PPUSH
// Difficulty := GetMultiplayerSetting ( 0 ) ;
 398: LD_ADDR_OWVAR 67
 402: PUSH
 403: LD_INT 0
 405: PPUSH
 406: CALL_OW 426
 410: ST_TO_ADDR
// SetRoad ( GetMultiplayerSetting ( 1 ) ) ;
 411: LD_INT 1
 413: PPUSH
 414: CALL_OW 426
 418: PPUSH
 419: CALL 251 0 1
// end ; end_of_file
 423: LD_VAR 0 1
 427: RET
// export player_force , player_commander , start_area , finish_area , hurt , mines_trigger ; export function InitPlayer ; var i , un , s , sk , veh , vehs , mech , mech_group ; begin
 428: LD_INT 0
 430: PPUSH
 431: PPUSH
 432: PPUSH
 433: PPUSH
 434: PPUSH
 435: PPUSH
 436: PPUSH
 437: PPUSH
 438: PPUSH
// uc_nation := nation_russian ;
 439: LD_ADDR_OWVAR 21
 443: PUSH
 444: LD_INT 3
 446: ST_TO_ADDR
// uc_side := your_side ;
 447: LD_ADDR_OWVAR 20
 451: PUSH
 452: LD_OWVAR 2
 456: ST_TO_ADDR
// player_force := [ ] ;
 457: LD_ADDR_EXP 5
 461: PUSH
 462: EMPTY
 463: ST_TO_ADDR
// mech_group := [ ] ;
 464: LD_ADDR_VAR 0 9
 468: PUSH
 469: EMPTY
 470: ST_TO_ADDR
// vehs := [ ] ;
 471: LD_ADDR_VAR 0 7
 475: PUSH
 476: EMPTY
 477: ST_TO_ADDR
// hurt := false ;
 478: LD_ADDR_EXP 9
 482: PUSH
 483: LD_INT 0
 485: ST_TO_ADDR
// mines_trigger := false ;
 486: LD_ADDR_EXP 10
 490: PUSH
 491: LD_INT 0
 493: ST_TO_ADDR
// sk := [ 7 , 6 , 5 ] [ Difficulty ] ;
 494: LD_ADDR_VAR 0 5
 498: PUSH
 499: LD_INT 7
 501: PUSH
 502: LD_INT 6
 504: PUSH
 505: LD_INT 5
 507: PUSH
 508: EMPTY
 509: LIST
 510: LIST
 511: LIST
 512: PUSH
 513: LD_OWVAR 67
 517: ARRAY
 518: ST_TO_ADDR
// hc_gallery :=  ;
 519: LD_ADDR_OWVAR 33
 523: PUSH
 524: LD_STRING 
 526: ST_TO_ADDR
// hc_name :=  ;
 527: LD_ADDR_OWVAR 26
 531: PUSH
 532: LD_STRING 
 534: ST_TO_ADDR
// hc_importance := 100 ;
 535: LD_ADDR_OWVAR 32
 539: PUSH
 540: LD_INT 100
 542: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , sk + 1 ) ;
 543: LD_INT 1
 545: PPUSH
 546: LD_INT 1
 548: PPUSH
 549: LD_VAR 0 5
 553: PUSH
 554: LD_INT 1
 556: PLUS
 557: PPUSH
 558: CALL_OW 380
// player_commander := CreateHuman ;
 562: LD_ADDR_EXP 6
 566: PUSH
 567: CALL_OW 44
 571: ST_TO_ADDR
// player_force := player_force ^ player_commander ;
 572: LD_ADDR_EXP 5
 576: PUSH
 577: LD_EXP 5
 581: PUSH
 582: LD_EXP 6
 586: ADD
 587: ST_TO_ADDR
// hc_importance := 0 ;
 588: LD_ADDR_OWVAR 32
 592: PUSH
 593: LD_INT 0
 595: ST_TO_ADDR
// case difficulty of 1 :
 596: LD_OWVAR 67
 600: PUSH
 601: LD_INT 1
 603: DOUBLE
 604: EQUAL
 605: IFTRUE 609
 607: GO 631
 609: POP
// s = [ 4 , 3 , 2 ] ; 2 :
 610: LD_ADDR_VAR 0 4
 614: PUSH
 615: LD_INT 4
 617: PUSH
 618: LD_INT 3
 620: PUSH
 621: LD_INT 2
 623: PUSH
 624: EMPTY
 625: LIST
 626: LIST
 627: LIST
 628: ST_TO_ADDR
 629: GO 692
 631: LD_INT 2
 633: DOUBLE
 634: EQUAL
 635: IFTRUE 639
 637: GO 661
 639: POP
// s = [ 3 , 2 , 2 ] ; 3 :
 640: LD_ADDR_VAR 0 4
 644: PUSH
 645: LD_INT 3
 647: PUSH
 648: LD_INT 2
 650: PUSH
 651: LD_INT 2
 653: PUSH
 654: EMPTY
 655: LIST
 656: LIST
 657: LIST
 658: ST_TO_ADDR
 659: GO 692
 661: LD_INT 3
 663: DOUBLE
 664: EQUAL
 665: IFTRUE 669
 667: GO 691
 669: POP
// s = [ 3 , 1 , 1 ] ; end ;
 670: LD_ADDR_VAR 0 4
 674: PUSH
 675: LD_INT 3
 677: PUSH
 678: LD_INT 1
 680: PUSH
 681: LD_INT 1
 683: PUSH
 684: EMPTY
 685: LIST
 686: LIST
 687: LIST
 688: ST_TO_ADDR
 689: GO 692
 691: POP
// ChangeSideFog ( 3 , 6 ) ;
 692: LD_INT 3
 694: PPUSH
 695: LD_INT 6
 697: PPUSH
 698: CALL_OW 343
// for i = 1 to s [ 1 ] do
 702: LD_ADDR_VAR 0 2
 706: PUSH
 707: DOUBLE
 708: LD_INT 1
 710: DEC
 711: ST_TO_ADDR
 712: LD_VAR 0 4
 716: PUSH
 717: LD_INT 1
 719: ARRAY
 720: PUSH
 721: FOR_TO
 722: IFFALSE 767
// begin PrepareHuman ( false , 1 , sk ) ;
 724: LD_INT 0
 726: PPUSH
 727: LD_INT 1
 729: PPUSH
 730: LD_VAR 0 5
 734: PPUSH
 735: CALL_OW 380
// un := CreateHuman ;
 739: LD_ADDR_VAR 0 3
 743: PUSH
 744: CALL_OW 44
 748: ST_TO_ADDR
// player_force := player_force ^ un ;
 749: LD_ADDR_EXP 5
 753: PUSH
 754: LD_EXP 5
 758: PUSH
 759: LD_VAR 0 3
 763: ADD
 764: ST_TO_ADDR
// end ;
 765: GO 721
 767: POP
 768: POP
// SetClass ( un , class_bazooker ) ;
 769: LD_VAR 0 3
 773: PPUSH
 774: LD_INT 9
 776: PPUSH
 777: CALL_OW 336
// for i = 1 to s [ 2 ] do
 781: LD_ADDR_VAR 0 2
 785: PUSH
 786: DOUBLE
 787: LD_INT 1
 789: DEC
 790: ST_TO_ADDR
 791: LD_VAR 0 4
 795: PUSH
 796: LD_INT 2
 798: ARRAY
 799: PUSH
 800: FOR_TO
 801: IFFALSE 999
// begin if Prob ( 30 ) then
 803: LD_INT 30
 805: PPUSH
 806: CALL_OW 13
 810: IFFALSE 865
// veh := CreateTank ( 3 , 3 , ru_medium_tracked , engine_siberite , control_manual , [ ru_gatling_gun , ru_heavy_machine_gun , ru_gun ] [ Rand ( 1 , 3 ) ] ) else
 812: LD_ADDR_VAR 0 6
 816: PUSH
 817: LD_INT 3
 819: PPUSH
 820: LD_INT 3
 822: PPUSH
 823: LD_INT 22
 825: PPUSH
 826: LD_INT 3
 828: PPUSH
 829: LD_INT 1
 831: PPUSH
 832: LD_INT 43
 834: PUSH
 835: LD_INT 42
 837: PUSH
 838: LD_INT 44
 840: PUSH
 841: EMPTY
 842: LIST
 843: LIST
 844: LIST
 845: PUSH
 846: LD_INT 1
 848: PPUSH
 849: LD_INT 3
 851: PPUSH
 852: CALL_OW 12
 856: ARRAY
 857: PPUSH
 858: CALL 7075 0 6
 862: ST_TO_ADDR
 863: GO 924
// veh := CreateTank ( 3 , 3 , ru_medium_tracked , engine_combustion , control_manual , [ ru_gatling_gun , ru_heavy_machine_gun , ru_gun , ru_heavy_machine_gun , ru_gun ] [ Rand ( 1 , 5 ) ] ) ;
 865: LD_ADDR_VAR 0 6
 869: PUSH
 870: LD_INT 3
 872: PPUSH
 873: LD_INT 3
 875: PPUSH
 876: LD_INT 22
 878: PPUSH
 879: LD_INT 1
 881: PPUSH
 882: LD_INT 1
 884: PPUSH
 885: LD_INT 43
 887: PUSH
 888: LD_INT 42
 890: PUSH
 891: LD_INT 44
 893: PUSH
 894: LD_INT 42
 896: PUSH
 897: LD_INT 44
 899: PUSH
 900: EMPTY
 901: LIST
 902: LIST
 903: LIST
 904: LIST
 905: LIST
 906: PUSH
 907: LD_INT 1
 909: PPUSH
 910: LD_INT 5
 912: PPUSH
 913: CALL_OW 12
 917: ARRAY
 918: PPUSH
 919: CALL 7075 0 6
 923: ST_TO_ADDR
// PrepareHuman ( false , 3 , sk ) ;
 924: LD_INT 0
 926: PPUSH
 927: LD_INT 3
 929: PPUSH
 930: LD_VAR 0 5
 934: PPUSH
 935: CALL_OW 380
// mech := CreateHuman ;
 939: LD_ADDR_VAR 0 8
 943: PUSH
 944: CALL_OW 44
 948: ST_TO_ADDR
// vehs := vehs ^ veh ;
 949: LD_ADDR_VAR 0 7
 953: PUSH
 954: LD_VAR 0 7
 958: PUSH
 959: LD_VAR 0 6
 963: ADD
 964: ST_TO_ADDR
// player_force := player_force ^ veh ;
 965: LD_ADDR_EXP 5
 969: PUSH
 970: LD_EXP 5
 974: PUSH
 975: LD_VAR 0 6
 979: ADD
 980: ST_TO_ADDR
// mech_group := mech_group ^ mech ;
 981: LD_ADDR_VAR 0 9
 985: PUSH
 986: LD_VAR 0 9
 990: PUSH
 991: LD_VAR 0 8
 995: ADD
 996: ST_TO_ADDR
// end ;
 997: GO 800
 999: POP
1000: POP
// for i = 1 to s [ 3 ] do
1001: LD_ADDR_VAR 0 2
1005: PUSH
1006: DOUBLE
1007: LD_INT 1
1009: DEC
1010: ST_TO_ADDR
1011: LD_VAR 0 4
1015: PUSH
1016: LD_INT 3
1018: ARRAY
1019: PUSH
1020: FOR_TO
1021: IFFALSE 1066
// begin PrepareHuman ( false , 4 , sk ) ;
1023: LD_INT 0
1025: PPUSH
1026: LD_INT 4
1028: PPUSH
1029: LD_VAR 0 5
1033: PPUSH
1034: CALL_OW 380
// un := CreateHuman ;
1038: LD_ADDR_VAR 0 3
1042: PUSH
1043: CALL_OW 44
1047: ST_TO_ADDR
// player_force := player_force ^ un ;
1048: LD_ADDR_EXP 5
1052: PUSH
1053: LD_EXP 5
1057: PUSH
1058: LD_VAR 0 3
1062: ADD
1063: ST_TO_ADDR
// end ;
1064: GO 1020
1066: POP
1067: POP
// case road of 1 :
1068: LD_EXP 2
1072: PUSH
1073: LD_INT 1
1075: DOUBLE
1076: EQUAL
1077: IFTRUE 1081
1079: GO 1100
1081: POP
// begin start_area := pos2 ;
1082: LD_ADDR_EXP 7
1086: PUSH
1087: LD_INT 4
1089: ST_TO_ADDR
// finish_area := pos3 ;
1090: LD_ADDR_EXP 8
1094: PUSH
1095: LD_INT 6
1097: ST_TO_ADDR
// end ; 2 :
1098: GO 1128
1100: LD_INT 2
1102: DOUBLE
1103: EQUAL
1104: IFTRUE 1108
1106: GO 1127
1108: POP
// begin start_area := pos1 ;
1109: LD_ADDR_EXP 7
1113: PUSH
1114: LD_INT 2
1116: ST_TO_ADDR
// finish_area := pos2 ;
1117: LD_ADDR_EXP 8
1121: PUSH
1122: LD_INT 4
1124: ST_TO_ADDR
// end ; end ;
1125: GO 1128
1127: POP
// for i = 1 to player_force do
1128: LD_ADDR_VAR 0 2
1132: PUSH
1133: DOUBLE
1134: LD_INT 1
1136: DEC
1137: ST_TO_ADDR
1138: LD_EXP 5
1142: PUSH
1143: FOR_TO
1144: IFFALSE 1202
// begin SetDir ( player_force [ i ] , [ 1 , 2 ] [ road ] ) ;
1146: LD_EXP 5
1150: PUSH
1151: LD_VAR 0 2
1155: ARRAY
1156: PPUSH
1157: LD_INT 1
1159: PUSH
1160: LD_INT 2
1162: PUSH
1163: EMPTY
1164: LIST
1165: LIST
1166: PUSH
1167: LD_EXP 2
1171: ARRAY
1172: PPUSH
1173: CALL_OW 233
// PlaceUnitArea ( player_force [ i ] , start_area , false ) ;
1177: LD_EXP 5
1181: PUSH
1182: LD_VAR 0 2
1186: ARRAY
1187: PPUSH
1188: LD_EXP 7
1192: PPUSH
1193: LD_INT 0
1195: PPUSH
1196: CALL_OW 49
// end ;
1200: GO 1143
1202: POP
1203: POP
// for i = 1 to s [ 2 ] do
1204: LD_ADDR_VAR 0 2
1208: PUSH
1209: DOUBLE
1210: LD_INT 1
1212: DEC
1213: ST_TO_ADDR
1214: LD_VAR 0 4
1218: PUSH
1219: LD_INT 2
1221: ARRAY
1222: PUSH
1223: FOR_TO
1224: IFFALSE 1254
// PlaceHumanInUnit ( mech_group [ i ] , vehs [ i ] ) ;
1226: LD_VAR 0 9
1230: PUSH
1231: LD_VAR 0 2
1235: ARRAY
1236: PPUSH
1237: LD_VAR 0 7
1241: PUSH
1242: LD_VAR 0 2
1246: ARRAY
1247: PPUSH
1248: CALL_OW 52
1252: GO 1223
1254: POP
1255: POP
// end ;
1256: LD_VAR 0 1
1260: RET
// export function Action ; begin
1261: LD_INT 0
1263: PPUSH
// CenterNowOnUnits ( player_commander ) ;
1264: LD_EXP 6
1268: PPUSH
1269: CALL_OW 87
// InGameOn ;
1273: CALL_OW 8
// Say ( player_commander , DS1 ) ;
1277: LD_EXP 6
1281: PPUSH
1282: LD_STRING DS1
1284: PPUSH
1285: CALL_OW 88
// Say ( player_commander , DS2 ) ;
1289: LD_EXP 6
1293: PPUSH
1294: LD_STRING DS2
1296: PPUSH
1297: CALL_OW 88
// Say ( player_commander , DS3 ) ;
1301: LD_EXP 6
1305: PPUSH
1306: LD_STRING DS3
1308: PPUSH
1309: CALL_OW 88
// InGameOff ;
1313: CALL_OW 9
// ChangeMissionObjectives ( ObConv ) ;
1317: LD_STRING ObConv
1319: PPUSH
1320: CALL_OW 337
// if road = 1 then
1324: LD_EXP 2
1328: PUSH
1329: LD_INT 1
1331: EQUAL
1332: IFFALSE 1346
// SetAreaMapShow ( pos3 , 1 ) else
1334: LD_INT 6
1336: PPUSH
1337: LD_INT 1
1339: PPUSH
1340: CALL_OW 424
1344: GO 1366
// if road = 2 then
1346: LD_EXP 2
1350: PUSH
1351: LD_INT 2
1353: EQUAL
1354: IFFALSE 1366
// SetAreaMapShow ( pos2 , 1 ) ;
1356: LD_INT 4
1358: PPUSH
1359: LD_INT 1
1361: PPUSH
1362: CALL_OW 424
// end ;
1366: LD_VAR 0 1
1370: RET
// every 0 0$01 trigger FilterUnitsInArea ( finish_area , [ f_weapon , ru_cargo_bay ] ) > 0 or ( FilterAllUnits ( [ f_side , 2 ] ) = 0 and not debug ) do var i ;
1371: LD_EXP 8
1375: PPUSH
1376: LD_INT 34
1378: PUSH
1379: LD_INT 51
1381: PUSH
1382: EMPTY
1383: LIST
1384: LIST
1385: PPUSH
1386: CALL_OW 70
1390: PUSH
1391: LD_INT 0
1393: GREATER
1394: PUSH
1395: LD_INT 22
1397: PUSH
1398: LD_INT 2
1400: PUSH
1401: EMPTY
1402: LIST
1403: LIST
1404: PPUSH
1405: CALL_OW 69
1409: PUSH
1410: LD_INT 0
1412: EQUAL
1413: PUSH
1414: LD_EXP 1
1418: NOT
1419: AND
1420: OR
1421: IFFALSE 1555
1423: GO 1425
1425: DISABLE
1426: LD_INT 0
1428: PPUSH
// begin Say ( player_commander , DS-6 ) ;
1429: LD_EXP 6
1433: PPUSH
1434: LD_STRING DS-6
1436: PPUSH
1437: CALL_OW 88
// Wait ( 0 0$01 ) ;
1441: LD_INT 35
1443: PPUSH
1444: CALL_OW 67
// AddMedal ( med , 1 ) ;
1448: LD_STRING med
1450: PPUSH
1451: LD_INT 1
1453: PPUSH
1454: CALL_OW 101
// if FilterAllUnits ( [ f_side , 2 ] ) = 0 then
1458: LD_INT 22
1460: PUSH
1461: LD_INT 2
1463: PUSH
1464: EMPTY
1465: LIST
1466: LIST
1467: PPUSH
1468: CALL_OW 69
1472: PUSH
1473: LD_INT 0
1475: EQUAL
1476: IFFALSE 1490
// AddMedal ( convoy_clear , 1 ) else
1478: LD_STRING convoy_clear
1480: PPUSH
1481: LD_INT 1
1483: PPUSH
1484: CALL_OW 101
1488: GO 1501
// AddMedal ( convoy_clear , - 1 ) ;
1490: LD_STRING convoy_clear
1492: PPUSH
1493: LD_INT 1
1495: NEG
1496: PPUSH
1497: CALL_OW 101
// if FilterAllUnits ( [ f_side , 6 ] ) >= 2 then
1501: LD_INT 22
1503: PUSH
1504: LD_INT 6
1506: PUSH
1507: EMPTY
1508: LIST
1509: LIST
1510: PPUSH
1511: CALL_OW 69
1515: PUSH
1516: LD_INT 2
1518: GREATEREQUAL
1519: IFFALSE 1533
// AddMedal ( convoy_cargos , 1 ) else
1521: LD_STRING convoy_cargos
1523: PPUSH
1524: LD_INT 1
1526: PPUSH
1527: CALL_OW 101
1531: GO 1544
// AddMedal ( convoy_cargos , - 1 ) ;
1533: LD_STRING convoy_cargos
1535: PPUSH
1536: LD_INT 1
1538: NEG
1539: PPUSH
1540: CALL_OW 101
// GiveMedals ( MAIN ) ;
1544: LD_STRING MAIN
1546: PPUSH
1547: CALL_OW 102
// YouWin ;
1551: CALL_OW 103
// end ;
1555: PPOPN 1
1557: END
// on UnitGoesToRed ( un ) do begin if GetSide ( un ) = 3 and GetType ( un ) = unit_human and FilterAllUnits ( [ [ f_side , 3 ] , [ f_sex , sex_male ] ] ) > 1 and not hurt then
1558: LD_VAR 0 1
1562: PPUSH
1563: CALL_OW 255
1567: PUSH
1568: LD_INT 3
1570: EQUAL
1571: PUSH
1572: LD_VAR 0 1
1576: PPUSH
1577: CALL_OW 247
1581: PUSH
1582: LD_INT 1
1584: EQUAL
1585: AND
1586: PUSH
1587: LD_INT 22
1589: PUSH
1590: LD_INT 3
1592: PUSH
1593: EMPTY
1594: LIST
1595: LIST
1596: PUSH
1597: LD_INT 26
1599: PUSH
1600: LD_INT 1
1602: PUSH
1603: EMPTY
1604: LIST
1605: LIST
1606: PUSH
1607: EMPTY
1608: LIST
1609: LIST
1610: PPUSH
1611: CALL_OW 69
1615: PUSH
1616: LD_INT 1
1618: GREATER
1619: AND
1620: PUSH
1621: LD_EXP 9
1625: NOT
1626: AND
1627: IFFALSE 1683
// begin hurt := true ;
1629: LD_ADDR_EXP 9
1633: PUSH
1634: LD_INT 1
1636: ST_TO_ADDR
// Say ( ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_sex , sex_male ] ] ) diff player_commander ) [ 1 ] , DM4 ) ;
1637: LD_INT 22
1639: PUSH
1640: LD_INT 3
1642: PUSH
1643: EMPTY
1644: LIST
1645: LIST
1646: PUSH
1647: LD_INT 26
1649: PUSH
1650: LD_INT 1
1652: PUSH
1653: EMPTY
1654: LIST
1655: LIST
1656: PUSH
1657: EMPTY
1658: LIST
1659: LIST
1660: PPUSH
1661: CALL_OW 69
1665: PUSH
1666: LD_EXP 6
1670: DIFF
1671: PUSH
1672: LD_INT 1
1674: ARRAY
1675: PPUSH
1676: LD_STRING DM4
1678: PPUSH
1679: CALL_OW 88
// end ; if un in FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] ] ) then
1683: LD_VAR 0 1
1687: PUSH
1688: LD_INT 22
1690: PUSH
1691: LD_INT 2
1693: PUSH
1694: EMPTY
1695: LIST
1696: LIST
1697: PUSH
1698: LD_INT 21
1700: PUSH
1701: LD_INT 2
1703: PUSH
1704: EMPTY
1705: LIST
1706: LIST
1707: PUSH
1708: EMPTY
1709: LIST
1710: LIST
1711: PPUSH
1712: CALL_OW 69
1716: IN
1717: IFFALSE 1842
// begin Wait ( Rand ( 0 0$08 , 0 0$14 ) ) ;
1719: LD_INT 280
1721: PPUSH
1722: LD_INT 490
1724: PPUSH
1725: CALL_OW 12
1729: PPUSH
1730: CALL_OW 67
// MineExplosion ( GetX ( un ) , GetY ( un ) , 10 ) ;
1734: LD_VAR 0 1
1738: PPUSH
1739: CALL_OW 250
1743: PPUSH
1744: LD_VAR 0 1
1748: PPUSH
1749: CALL_OW 251
1753: PPUSH
1754: LD_INT 10
1756: PPUSH
1757: CALL_OW 453
// MineExplosion ( GetX ( un ) , GetY ( un ) , 10 ) ;
1761: LD_VAR 0 1
1765: PPUSH
1766: CALL_OW 250
1770: PPUSH
1771: LD_VAR 0 1
1775: PPUSH
1776: CALL_OW 251
1780: PPUSH
1781: LD_INT 10
1783: PPUSH
1784: CALL_OW 453
// MineExplosion ( GetX ( un ) , GetY ( un ) , 10 ) ;
1788: LD_VAR 0 1
1792: PPUSH
1793: CALL_OW 250
1797: PPUSH
1798: LD_VAR 0 1
1802: PPUSH
1803: CALL_OW 251
1807: PPUSH
1808: LD_INT 10
1810: PPUSH
1811: CALL_OW 453
// MineExplosion ( GetX ( un ) , GetY ( un ) , 5 ) ;
1815: LD_VAR 0 1
1819: PPUSH
1820: CALL_OW 250
1824: PPUSH
1825: LD_VAR 0 1
1829: PPUSH
1830: CALL_OW 251
1834: PPUSH
1835: LD_INT 5
1837: PPUSH
1838: CALL_OW 453
// end ; end ;
1842: PPOPN 1
1844: END
// every 0 0$01 trigger See ( 3 , FilterAllUnits ( [ f_chassis , ar_hovercraft ] ) [ 1 ] ) do
1845: LD_INT 3
1847: PPUSH
1848: LD_INT 31
1850: PUSH
1851: LD_INT 11
1853: PUSH
1854: EMPTY
1855: LIST
1856: LIST
1857: PPUSH
1858: CALL_OW 69
1862: PUSH
1863: LD_INT 1
1865: ARRAY
1866: PPUSH
1867: CALL_OW 292
1871: IFFALSE 1922
1873: GO 1875
1875: DISABLE
// begin Say ( ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_sex , sex_male ] ] ) diff player_commander ) [ 1 ] , DM2 ) ;
1876: LD_INT 22
1878: PUSH
1879: LD_INT 3
1881: PUSH
1882: EMPTY
1883: LIST
1884: LIST
1885: PUSH
1886: LD_INT 26
1888: PUSH
1889: LD_INT 1
1891: PUSH
1892: EMPTY
1893: LIST
1894: LIST
1895: PUSH
1896: EMPTY
1897: LIST
1898: LIST
1899: PPUSH
1900: CALL_OW 69
1904: PUSH
1905: LD_EXP 6
1909: DIFF
1910: PUSH
1911: LD_INT 1
1913: ARRAY
1914: PPUSH
1915: LD_STRING DM2
1917: PPUSH
1918: CALL_OW 88
// end ;
1922: END
// every 0 0$03 trigger See ( 3 , NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , 1 ] ] ) , player_commander ) ) do
1923: LD_INT 3
1925: PPUSH
1926: LD_INT 22
1928: PUSH
1929: LD_INT 2
1931: PUSH
1932: EMPTY
1933: LIST
1934: LIST
1935: PUSH
1936: LD_INT 25
1938: PUSH
1939: LD_INT 1
1941: PUSH
1942: EMPTY
1943: LIST
1944: LIST
1945: PUSH
1946: EMPTY
1947: LIST
1948: LIST
1949: PPUSH
1950: CALL_OW 69
1954: PPUSH
1955: LD_EXP 6
1959: PPUSH
1960: CALL_OW 74
1964: PPUSH
1965: CALL_OW 292
1969: IFFALSE 2020
1971: GO 1973
1973: DISABLE
// begin Say ( ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_sex , sex_male ] ] ) diff player_commander ) [ 1 ] , DM3 ) ;
1974: LD_INT 22
1976: PUSH
1977: LD_INT 3
1979: PUSH
1980: EMPTY
1981: LIST
1982: LIST
1983: PUSH
1984: LD_INT 26
1986: PUSH
1987: LD_INT 1
1989: PUSH
1990: EMPTY
1991: LIST
1992: LIST
1993: PUSH
1994: EMPTY
1995: LIST
1996: LIST
1997: PPUSH
1998: CALL_OW 69
2002: PUSH
2003: LD_EXP 6
2007: DIFF
2008: PUSH
2009: LD_INT 1
2011: ARRAY
2012: PPUSH
2013: LD_STRING DM3
2015: PPUSH
2016: CALL_OW 88
// end ;
2020: END
// every 0 0$01 trigger mines_trigger do
2021: LD_EXP 10
2025: IFFALSE 2096
2027: GO 2029
2029: DISABLE
// begin DialogueOn ;
2030: CALL_OW 6
// Say ( ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_sex , sex_male ] ] ) diff player_commander ) [ 1 ] , DM1 ) ;
2034: LD_INT 22
2036: PUSH
2037: LD_INT 3
2039: PUSH
2040: EMPTY
2041: LIST
2042: LIST
2043: PUSH
2044: LD_INT 26
2046: PUSH
2047: LD_INT 1
2049: PUSH
2050: EMPTY
2051: LIST
2052: LIST
2053: PUSH
2054: EMPTY
2055: LIST
2056: LIST
2057: PPUSH
2058: CALL_OW 69
2062: PUSH
2063: LD_EXP 6
2067: DIFF
2068: PUSH
2069: LD_INT 1
2071: ARRAY
2072: PPUSH
2073: LD_STRING DM1
2075: PPUSH
2076: CALL_OW 88
// Say ( player_commander , DS4 ) ;
2080: LD_EXP 6
2084: PPUSH
2085: LD_STRING DS4
2087: PPUSH
2088: CALL_OW 88
// DialogueOff ;
2092: CALL_OW 7
// end ;
2096: END
// every 0 0$01 trigger FilterAllUnits ( [ f_weapon , ru_cargo_bay ] ) = 1 do
2097: LD_INT 34
2099: PUSH
2100: LD_INT 51
2102: PUSH
2103: EMPTY
2104: LIST
2105: LIST
2106: PPUSH
2107: CALL_OW 69
2111: PUSH
2112: LD_INT 1
2114: EQUAL
2115: IFFALSE 2132
2117: GO 2119
2119: DISABLE
// begin Say ( player_commander , DS5 ) ;
2120: LD_EXP 6
2124: PPUSH
2125: LD_STRING DS5
2127: PPUSH
2128: CALL_OW 88
// end ;
2132: END
// every 0 0$01 trigger FilterAllUnits ( [ f_weapon , ru_cargo_bay ] ) = 0 do
2133: LD_INT 34
2135: PUSH
2136: LD_INT 51
2138: PUSH
2139: EMPTY
2140: LIST
2141: LIST
2142: PPUSH
2143: CALL_OW 69
2147: PUSH
2148: LD_INT 0
2150: EQUAL
2151: IFFALSE 2163
2153: GO 2155
2155: DISABLE
// begin YouLost ( qconvl ) ;
2156: LD_STRING qconvl
2158: PPUSH
2159: CALL_OW 104
// end ;
2163: END
// every 0 0$01 trigger IsDead ( player_commander ) do
2164: LD_EXP 6
2168: PPUSH
2169: CALL_OW 301
2173: IFFALSE 2185
2175: GO 2177
2177: DISABLE
// begin YouLost ( qcom ) ;
2178: LD_STRING qcom
2180: PPUSH
2181: CALL_OW 104
// end ; end_of_file
2185: END
// export function PrepareConvoy ; var un , area , i , bull_xy ; begin
2186: LD_INT 0
2188: PPUSH
2189: PPUSH
2190: PPUSH
2191: PPUSH
2192: PPUSH
// SetAttitude ( 3 , 6 , att_friend , true ) ;
2193: LD_INT 3
2195: PPUSH
2196: LD_INT 6
2198: PPUSH
2199: LD_INT 1
2201: PPUSH
2202: LD_INT 1
2204: PPUSH
2205: CALL_OW 80
// case road of 1 :
2209: LD_EXP 2
2213: PUSH
2214: LD_INT 1
2216: DOUBLE
2217: EQUAL
2218: IFTRUE 2222
2220: GO 2248
2222: POP
// begin area := pos2 ;
2223: LD_ADDR_VAR 0 3
2227: PUSH
2228: LD_INT 4
2230: ST_TO_ADDR
// bull_xy := [ 30 , 46 ] ;
2231: LD_ADDR_VAR 0 5
2235: PUSH
2236: LD_INT 30
2238: PUSH
2239: LD_INT 46
2241: PUSH
2242: EMPTY
2243: LIST
2244: LIST
2245: ST_TO_ADDR
// end ; 2 :
2246: GO 2283
2248: LD_INT 2
2250: DOUBLE
2251: EQUAL
2252: IFTRUE 2256
2254: GO 2282
2256: POP
// begin area := pos1 ;
2257: LD_ADDR_VAR 0 3
2261: PUSH
2262: LD_INT 2
2264: ST_TO_ADDR
// bull_xy := [ 18 , 3 ] ;
2265: LD_ADDR_VAR 0 5
2269: PUSH
2270: LD_INT 18
2272: PUSH
2273: LD_INT 3
2275: PUSH
2276: EMPTY
2277: LIST
2278: LIST
2279: ST_TO_ADDR
// end ; end ;
2280: GO 2283
2282: POP
// if road = 1 then
2283: LD_EXP 2
2287: PUSH
2288: LD_INT 1
2290: EQUAL
2291: IFFALSE 2404
// conv_road := [ 36 , 43 , 40 , 29 , 56 , 37 , 70 , 32 , 63 , 6 , 84 , 8 , 90 , 24 , 96 , 47 , 110 , 73 , 143 , 102 , 121 , 93 , 98 , 100 , 62 , 114 ] ;
2293: LD_ADDR_EXP 13
2297: PUSH
2298: LD_INT 36
2300: PUSH
2301: LD_INT 43
2303: PUSH
2304: LD_INT 40
2306: PUSH
2307: LD_INT 29
2309: PUSH
2310: LD_INT 56
2312: PUSH
2313: LD_INT 37
2315: PUSH
2316: LD_INT 70
2318: PUSH
2319: LD_INT 32
2321: PUSH
2322: LD_INT 63
2324: PUSH
2325: LD_INT 6
2327: PUSH
2328: LD_INT 84
2330: PUSH
2331: LD_INT 8
2333: PUSH
2334: LD_INT 90
2336: PUSH
2337: LD_INT 24
2339: PUSH
2340: LD_INT 96
2342: PUSH
2343: LD_INT 47
2345: PUSH
2346: LD_INT 110
2348: PUSH
2349: LD_INT 73
2351: PUSH
2352: LD_INT 143
2354: PUSH
2355: LD_INT 102
2357: PUSH
2358: LD_INT 121
2360: PUSH
2361: LD_INT 93
2363: PUSH
2364: LD_INT 98
2366: PUSH
2367: LD_INT 100
2369: PUSH
2370: LD_INT 62
2372: PUSH
2373: LD_INT 114
2375: PUSH
2376: EMPTY
2377: LIST
2378: LIST
2379: LIST
2380: LIST
2381: LIST
2382: LIST
2383: LIST
2384: LIST
2385: LIST
2386: LIST
2387: LIST
2388: LIST
2389: LIST
2390: LIST
2391: LIST
2392: LIST
2393: LIST
2394: LIST
2395: LIST
2396: LIST
2397: LIST
2398: LIST
2399: LIST
2400: LIST
2401: LIST
2402: LIST
2403: ST_TO_ADDR
// if road = 2 then
2404: LD_EXP 2
2408: PUSH
2409: LD_INT 2
2411: EQUAL
2412: IFFALSE 2549
// conv_road := [ 39 , 18 , 61 , 36 , 62 , 15 , 75 , 5 , 97 , 17 , 98 , 30 , 95 , 49 , 110 , 71 , 146 , 112 , 100 , 81 , 99 , 115 , 77 , 105 , 65 , 75 , 45 , 46 , 26 , 47 , 29 , 54 ] ;
2414: LD_ADDR_EXP 13
2418: PUSH
2419: LD_INT 39
2421: PUSH
2422: LD_INT 18
2424: PUSH
2425: LD_INT 61
2427: PUSH
2428: LD_INT 36
2430: PUSH
2431: LD_INT 62
2433: PUSH
2434: LD_INT 15
2436: PUSH
2437: LD_INT 75
2439: PUSH
2440: LD_INT 5
2442: PUSH
2443: LD_INT 97
2445: PUSH
2446: LD_INT 17
2448: PUSH
2449: LD_INT 98
2451: PUSH
2452: LD_INT 30
2454: PUSH
2455: LD_INT 95
2457: PUSH
2458: LD_INT 49
2460: PUSH
2461: LD_INT 110
2463: PUSH
2464: LD_INT 71
2466: PUSH
2467: LD_INT 146
2469: PUSH
2470: LD_INT 112
2472: PUSH
2473: LD_INT 100
2475: PUSH
2476: LD_INT 81
2478: PUSH
2479: LD_INT 99
2481: PUSH
2482: LD_INT 115
2484: PUSH
2485: LD_INT 77
2487: PUSH
2488: LD_INT 105
2490: PUSH
2491: LD_INT 65
2493: PUSH
2494: LD_INT 75
2496: PUSH
2497: LD_INT 45
2499: PUSH
2500: LD_INT 46
2502: PUSH
2503: LD_INT 26
2505: PUSH
2506: LD_INT 47
2508: PUSH
2509: LD_INT 29
2511: PUSH
2512: LD_INT 54
2514: PUSH
2515: EMPTY
2516: LIST
2517: LIST
2518: LIST
2519: LIST
2520: LIST
2521: LIST
2522: LIST
2523: LIST
2524: LIST
2525: LIST
2526: LIST
2527: LIST
2528: LIST
2529: LIST
2530: LIST
2531: LIST
2532: LIST
2533: LIST
2534: LIST
2535: LIST
2536: LIST
2537: LIST
2538: LIST
2539: LIST
2540: LIST
2541: LIST
2542: LIST
2543: LIST
2544: LIST
2545: LIST
2546: LIST
2547: LIST
2548: ST_TO_ADDR
// conv_am := 1 ;
2549: LD_ADDR_EXP 12
2553: PUSH
2554: LD_INT 1
2556: ST_TO_ADDR
// conv := 0 ;
2557: LD_ADDR_EXP 11
2561: PUSH
2562: LD_INT 0
2564: ST_TO_ADDR
// uc_side := 6 ;
2565: LD_ADDR_OWVAR 20
2569: PUSH
2570: LD_INT 6
2572: ST_TO_ADDR
// uc_nation := 3 ;
2573: LD_ADDR_OWVAR 21
2577: PUSH
2578: LD_INT 3
2580: ST_TO_ADDR
// for i = 1 to 2 do
2581: LD_ADDR_VAR 0 4
2585: PUSH
2586: DOUBLE
2587: LD_INT 1
2589: DEC
2590: ST_TO_ADDR
2591: LD_INT 2
2593: PUSH
2594: FOR_TO
2595: IFFALSE 2700
// begin un := CreateTank ( 6 , 3 , ru_medium_tracked , engine_siberite , control_computer , ru_cargo_bay ) ;
2597: LD_ADDR_VAR 0 2
2601: PUSH
2602: LD_INT 6
2604: PPUSH
2605: LD_INT 3
2607: PPUSH
2608: LD_INT 22
2610: PPUSH
2611: LD_INT 3
2613: PPUSH
2614: LD_INT 3
2616: PPUSH
2617: LD_INT 51
2619: PPUSH
2620: CALL 7075 0 6
2624: ST_TO_ADDR
// cargos := cargos ^ un ;
2625: LD_ADDR_EXP 4
2629: PUSH
2630: LD_EXP 4
2634: PUSH
2635: LD_VAR 0 2
2639: ADD
2640: ST_TO_ADDR
// SetDir ( un , [ 1 , 2 ] [ road ] ) ;
2641: LD_VAR 0 2
2645: PPUSH
2646: LD_INT 1
2648: PUSH
2649: LD_INT 2
2651: PUSH
2652: EMPTY
2653: LIST
2654: LIST
2655: PUSH
2656: LD_EXP 2
2660: ARRAY
2661: PPUSH
2662: CALL_OW 233
// PlaceUnitArea ( un , area , false ) ;
2666: LD_VAR 0 2
2670: PPUSH
2671: LD_VAR 0 3
2675: PPUSH
2676: LD_INT 0
2678: PPUSH
2679: CALL_OW 49
// SetCargo ( un , 3 , 100 ) ;
2683: LD_VAR 0 2
2687: PPUSH
2688: LD_INT 3
2690: PPUSH
2691: LD_INT 100
2693: PPUSH
2694: CALL_OW 290
// end ;
2698: GO 2594
2700: POP
2701: POP
// end ;
2702: LD_VAR 0 1
2706: RET
// export conv , conv_am , conv_road ; every 0 0$01 trigger cargos marked 01 do
2707: LD_EXP 4
2711: IFFALSE 2823
2713: GO 2715
2715: DISABLE
// begin enable ;
2716: ENABLE
// if IsSelected ( cargos [ 1 ] ) or IsSelected ( cargos [ 2 ] ) then
2717: LD_EXP 4
2721: PUSH
2722: LD_INT 1
2724: ARRAY
2725: PPUSH
2726: CALL_OW 306
2730: PUSH
2731: LD_EXP 4
2735: PUSH
2736: LD_INT 2
2738: ARRAY
2739: PPUSH
2740: CALL_OW 306
2744: OR
2745: IFFALSE 2823
// begin if debug then
2747: LD_EXP 1
2751: IFFALSE 2763
// display_strings := conv ;
2753: LD_ADDR_OWVAR 47
2757: PUSH
2758: LD_EXP 11
2762: ST_TO_ADDR
// case Query ( QConv ) of 1 :
2763: LD_STRING QConv
2765: PPUSH
2766: CALL_OW 97
2770: PUSH
2771: LD_INT 1
2773: DOUBLE
2774: EQUAL
2775: IFTRUE 2779
2777: GO 2790
2779: POP
// conv := 0 ; 2 :
2780: LD_ADDR_EXP 11
2784: PUSH
2785: LD_INT 0
2787: ST_TO_ADDR
2788: GO 2810
2790: LD_INT 2
2792: DOUBLE
2793: EQUAL
2794: IFTRUE 2798
2796: GO 2809
2798: POP
// conv := 1 ; end ;
2799: LD_ADDR_EXP 11
2803: PUSH
2804: LD_INT 1
2806: ST_TO_ADDR
2807: GO 2810
2809: POP
// disable ( 01 ) ;
2810: LD_INT 1
2812: DISABLE_MARKED
// Wait ( 0 0$05 ) ;
2813: LD_INT 175
2815: PPUSH
2816: CALL_OW 67
// enable ( 01 ) ;
2820: LD_INT 1
2822: ENABLE_MARKED
// end ; end ;
2823: END
// every 0 0$01 trigger conv = 1 do var i , area , car ;
2824: LD_EXP 11
2828: PUSH
2829: LD_INT 1
2831: EQUAL
2832: IFFALSE 3044
2834: GO 2836
2836: DISABLE
2837: LD_INT 0
2839: PPUSH
2840: PPUSH
2841: PPUSH
// begin enable ;
2842: ENABLE
// car := FilterAllUnits ( [ f_weapon , ru_cargo_bay ] ) ;
2843: LD_ADDR_VAR 0 3
2847: PUSH
2848: LD_INT 34
2850: PUSH
2851: LD_INT 51
2853: PUSH
2854: EMPTY
2855: LIST
2856: LIST
2857: PPUSH
2858: CALL_OW 69
2862: ST_TO_ADDR
// if debug then
2863: LD_EXP 1
2867: IFFALSE 2904
// display_strings := [ conv_road [ conv_am ] , conv_road [ conv_am + 1 ] ] ;
2869: LD_ADDR_OWVAR 47
2873: PUSH
2874: LD_EXP 13
2878: PUSH
2879: LD_EXP 12
2883: ARRAY
2884: PUSH
2885: LD_EXP 13
2889: PUSH
2890: LD_EXP 12
2894: PUSH
2895: LD_INT 1
2897: PLUS
2898: ARRAY
2899: PUSH
2900: EMPTY
2901: LIST
2902: LIST
2903: ST_TO_ADDR
// for i = 1 to car do
2904: LD_ADDR_VAR 0 1
2908: PUSH
2909: DOUBLE
2910: LD_INT 1
2912: DEC
2913: ST_TO_ADDR
2914: LD_VAR 0 3
2918: PUSH
2919: FOR_TO
2920: IFFALSE 3042
// begin if IsNearbyPoint ( car [ i ] , conv_road [ conv_am ] , conv_road [ conv_am + 1 ] ) then
2922: LD_VAR 0 3
2926: PUSH
2927: LD_VAR 0 1
2931: ARRAY
2932: PPUSH
2933: LD_EXP 13
2937: PUSH
2938: LD_EXP 12
2942: ARRAY
2943: PPUSH
2944: LD_EXP 13
2948: PUSH
2949: LD_EXP 12
2953: PUSH
2954: LD_INT 1
2956: PLUS
2957: ARRAY
2958: PPUSH
2959: CALL 7153 0 3
2963: IFFALSE 2981
// conv_am := conv_am + 2 else
2965: LD_ADDR_EXP 12
2969: PUSH
2970: LD_EXP 12
2974: PUSH
2975: LD_INT 2
2977: PLUS
2978: ST_TO_ADDR
2979: GO 3040
// if not HasTask ( car [ i ] ) then
2981: LD_VAR 0 3
2985: PUSH
2986: LD_VAR 0 1
2990: ARRAY
2991: PPUSH
2992: CALL_OW 314
2996: NOT
2997: IFFALSE 3040
// ComMoveXY ( car [ i ] , conv_road [ conv_am ] , conv_road [ conv_am + 1 ] ) ;
2999: LD_VAR 0 3
3003: PUSH
3004: LD_VAR 0 1
3008: ARRAY
3009: PPUSH
3010: LD_EXP 13
3014: PUSH
3015: LD_EXP 12
3019: ARRAY
3020: PPUSH
3021: LD_EXP 13
3025: PUSH
3026: LD_EXP 12
3030: PUSH
3031: LD_INT 1
3033: PLUS
3034: ARRAY
3035: PPUSH
3036: CALL_OW 111
// end ;
3040: GO 2919
3042: POP
3043: POP
// end ;
3044: PPOPN 3
3046: END
// every 0 0$01 trigger conv = 0 do var i ;
3047: LD_EXP 11
3051: PUSH
3052: LD_INT 0
3054: EQUAL
3055: IFFALSE 3118
3057: GO 3059
3059: DISABLE
3060: LD_INT 0
3062: PPUSH
// begin enable ;
3063: ENABLE
// for i = 1 to cargos do
3064: LD_ADDR_VAR 0 1
3068: PUSH
3069: DOUBLE
3070: LD_INT 1
3072: DEC
3073: ST_TO_ADDR
3074: LD_EXP 4
3078: PUSH
3079: FOR_TO
3080: IFFALSE 3116
// if HasTask ( cargos [ i ] ) then
3082: LD_EXP 4
3086: PUSH
3087: LD_VAR 0 1
3091: ARRAY
3092: PPUSH
3093: CALL_OW 314
3097: IFFALSE 3114
// ComStop ( cargos [ i ] ) ;
3099: LD_EXP 4
3103: PUSH
3104: LD_VAR 0 1
3108: ARRAY
3109: PPUSH
3110: CALL_OW 141
3114: GO 3079
3116: POP
3117: POP
// end ; end_of_file
3118: PPOPN 1
3120: END
// export function InitEnemy ; var bunker_xy , sold_stand , sold_crawl , tanks_xy , hover_x , mines_xy , camera_xy , i , p , veh , un , b , x , d , dir ; begin
3121: LD_INT 0
3123: PPUSH
3124: PPUSH
3125: PPUSH
3126: PPUSH
3127: PPUSH
3128: PPUSH
3129: PPUSH
3130: PPUSH
3131: PPUSH
3132: PPUSH
3133: PPUSH
3134: PPUSH
3135: PPUSH
3136: PPUSH
3137: PPUSH
3138: PPUSH
// uc_side := 2 ;
3139: LD_ADDR_OWVAR 20
3143: PUSH
3144: LD_INT 2
3146: ST_TO_ADDR
// uc_nation := 2 ;
3147: LD_ADDR_OWVAR 21
3151: PUSH
3152: LD_INT 2
3154: ST_TO_ADDR
// if road = 1 then
3155: LD_EXP 2
3159: PUSH
3160: LD_INT 1
3162: EQUAL
3163: IFFALSE 3925
// begin case Difficulty of 1 :
3165: LD_OWVAR 67
3169: PUSH
3170: LD_INT 1
3172: DOUBLE
3173: EQUAL
3174: IFTRUE 3178
3176: GO 3485
3178: POP
// begin bunker_xy := [ 56 , 37 , 2 , 81 , 6 , 1 , 90 , 25 , 3 , 105 , 68 , 2 , 96 , 82 , 4 , 80 , 109 , 4 ] ;
3179: LD_ADDR_VAR 0 2
3183: PUSH
3184: LD_INT 56
3186: PUSH
3187: LD_INT 37
3189: PUSH
3190: LD_INT 2
3192: PUSH
3193: LD_INT 81
3195: PUSH
3196: LD_INT 6
3198: PUSH
3199: LD_INT 1
3201: PUSH
3202: LD_INT 90
3204: PUSH
3205: LD_INT 25
3207: PUSH
3208: LD_INT 3
3210: PUSH
3211: LD_INT 105
3213: PUSH
3214: LD_INT 68
3216: PUSH
3217: LD_INT 2
3219: PUSH
3220: LD_INT 96
3222: PUSH
3223: LD_INT 82
3225: PUSH
3226: LD_INT 4
3228: PUSH
3229: LD_INT 80
3231: PUSH
3232: LD_INT 109
3234: PUSH
3235: LD_INT 4
3237: PUSH
3238: EMPTY
3239: LIST
3240: LIST
3241: LIST
3242: LIST
3243: LIST
3244: LIST
3245: LIST
3246: LIST
3247: LIST
3248: LIST
3249: LIST
3250: LIST
3251: LIST
3252: LIST
3253: LIST
3254: LIST
3255: LIST
3256: LIST
3257: ST_TO_ADDR
// sold_stand := [ sold1 , sold3 , sold4 , sold5 ] ;
3258: LD_ADDR_VAR 0 3
3262: PUSH
3263: LD_INT 7
3265: PUSH
3266: LD_INT 9
3268: PUSH
3269: LD_INT 10
3271: PUSH
3272: LD_INT 11
3274: PUSH
3275: EMPTY
3276: LIST
3277: LIST
3278: LIST
3279: LIST
3280: ST_TO_ADDR
// sold_crawl := [ cr1 , cr2 , cr3 , cr4 ] ;
3281: LD_ADDR_VAR 0 4
3285: PUSH
3286: LD_INT 13
3288: PUSH
3289: LD_INT 14
3291: PUSH
3292: LD_INT 15
3294: PUSH
3295: LD_INT 16
3297: PUSH
3298: EMPTY
3299: LIST
3300: LIST
3301: LIST
3302: LIST
3303: ST_TO_ADDR
// d := [ 4 , 5 , 0 , 1 ] ;
3304: LD_ADDR_VAR 0 15
3308: PUSH
3309: LD_INT 4
3311: PUSH
3312: LD_INT 5
3314: PUSH
3315: LD_INT 0
3317: PUSH
3318: LD_INT 1
3320: PUSH
3321: EMPTY
3322: LIST
3323: LIST
3324: LIST
3325: LIST
3326: ST_TO_ADDR
// camera_xy := [ 68 , 5 , 96 , 53 , 142 , 98 , 96 , 82 ] ;
3327: LD_ADDR_VAR 0 8
3331: PUSH
3332: LD_INT 68
3334: PUSH
3335: LD_INT 5
3337: PUSH
3338: LD_INT 96
3340: PUSH
3341: LD_INT 53
3343: PUSH
3344: LD_INT 142
3346: PUSH
3347: LD_INT 98
3349: PUSH
3350: LD_INT 96
3352: PUSH
3353: LD_INT 82
3355: PUSH
3356: EMPTY
3357: LIST
3358: LIST
3359: LIST
3360: LIST
3361: LIST
3362: LIST
3363: LIST
3364: LIST
3365: ST_TO_ADDR
// hover_x := [ hovercraft_area , 2 ] ;
3366: LD_ADDR_VAR 0 6
3370: PUSH
3371: LD_INT 17
3373: PUSH
3374: LD_INT 2
3376: PUSH
3377: EMPTY
3378: LIST
3379: LIST
3380: ST_TO_ADDR
// tanks_xy := [ 104 , 21 , 4 , 100 , 21 , 4 ] ;
3381: LD_ADDR_VAR 0 5
3385: PUSH
3386: LD_INT 104
3388: PUSH
3389: LD_INT 21
3391: PUSH
3392: LD_INT 4
3394: PUSH
3395: LD_INT 100
3397: PUSH
3398: LD_INT 21
3400: PUSH
3401: LD_INT 4
3403: PUSH
3404: EMPTY
3405: LIST
3406: LIST
3407: LIST
3408: LIST
3409: LIST
3410: LIST
3411: ST_TO_ADDR
// mines_xy := [ 38 , 28 , 41 , 29 , 62 , 5 , 65 , 7 , 95 , 55 , 98 , 54 , 96 , 111 , 99 , 112 ] ;
3412: LD_ADDR_VAR 0 7
3416: PUSH
3417: LD_INT 38
3419: PUSH
3420: LD_INT 28
3422: PUSH
3423: LD_INT 41
3425: PUSH
3426: LD_INT 29
3428: PUSH
3429: LD_INT 62
3431: PUSH
3432: LD_INT 5
3434: PUSH
3435: LD_INT 65
3437: PUSH
3438: LD_INT 7
3440: PUSH
3441: LD_INT 95
3443: PUSH
3444: LD_INT 55
3446: PUSH
3447: LD_INT 98
3449: PUSH
3450: LD_INT 54
3452: PUSH
3453: LD_INT 96
3455: PUSH
3456: LD_INT 111
3458: PUSH
3459: LD_INT 99
3461: PUSH
3462: LD_INT 112
3464: PUSH
3465: EMPTY
3466: LIST
3467: LIST
3468: LIST
3469: LIST
3470: LIST
3471: LIST
3472: LIST
3473: LIST
3474: LIST
3475: LIST
3476: LIST
3477: LIST
3478: LIST
3479: LIST
3480: LIST
3481: LIST
3482: ST_TO_ADDR
// end ; 2 , 3 :
3483: GO 3923
3485: LD_INT 2
3487: DOUBLE
3488: EQUAL
3489: IFTRUE 3499
3491: LD_INT 3
3493: DOUBLE
3494: EQUAL
3495: IFTRUE 3499
3497: GO 3922
3499: POP
// begin bunker_xy := [ 56 , 37 , 2 , 81 , 6 , 1 , 90 , 25 , 3 , 105 , 68 , 2 , 96 , 82 , 4 , 80 , 109 , 4 ] ;
3500: LD_ADDR_VAR 0 2
3504: PUSH
3505: LD_INT 56
3507: PUSH
3508: LD_INT 37
3510: PUSH
3511: LD_INT 2
3513: PUSH
3514: LD_INT 81
3516: PUSH
3517: LD_INT 6
3519: PUSH
3520: LD_INT 1
3522: PUSH
3523: LD_INT 90
3525: PUSH
3526: LD_INT 25
3528: PUSH
3529: LD_INT 3
3531: PUSH
3532: LD_INT 105
3534: PUSH
3535: LD_INT 68
3537: PUSH
3538: LD_INT 2
3540: PUSH
3541: LD_INT 96
3543: PUSH
3544: LD_INT 82
3546: PUSH
3547: LD_INT 4
3549: PUSH
3550: LD_INT 80
3552: PUSH
3553: LD_INT 109
3555: PUSH
3556: LD_INT 4
3558: PUSH
3559: EMPTY
3560: LIST
3561: LIST
3562: LIST
3563: LIST
3564: LIST
3565: LIST
3566: LIST
3567: LIST
3568: LIST
3569: LIST
3570: LIST
3571: LIST
3572: LIST
3573: LIST
3574: LIST
3575: LIST
3576: LIST
3577: LIST
3578: ST_TO_ADDR
// sold_stand := [ sold1 , sold2 , sold3 , sold4 , sold5 , sold6 , sold7 , sold8 ] ;
3579: LD_ADDR_VAR 0 3
3583: PUSH
3584: LD_INT 7
3586: PUSH
3587: LD_INT 8
3589: PUSH
3590: LD_INT 9
3592: PUSH
3593: LD_INT 10
3595: PUSH
3596: LD_INT 11
3598: PUSH
3599: LD_INT 12
3601: PUSH
3602: LD_INT 42
3604: PUSH
3605: LD_INT 43
3607: PUSH
3608: EMPTY
3609: LIST
3610: LIST
3611: LIST
3612: LIST
3613: LIST
3614: LIST
3615: LIST
3616: LIST
3617: ST_TO_ADDR
// sold_crawl := [ cr1 , cr2 , cr3 , cr4 ] ;
3618: LD_ADDR_VAR 0 4
3622: PUSH
3623: LD_INT 13
3625: PUSH
3626: LD_INT 14
3628: PUSH
3629: LD_INT 15
3631: PUSH
3632: LD_INT 16
3634: PUSH
3635: EMPTY
3636: LIST
3637: LIST
3638: LIST
3639: LIST
3640: ST_TO_ADDR
// d := [ 4 , 5 , 0 , 1 ] ;
3641: LD_ADDR_VAR 0 15
3645: PUSH
3646: LD_INT 4
3648: PUSH
3649: LD_INT 5
3651: PUSH
3652: LD_INT 0
3654: PUSH
3655: LD_INT 1
3657: PUSH
3658: EMPTY
3659: LIST
3660: LIST
3661: LIST
3662: LIST
3663: ST_TO_ADDR
// camera_xy := [ 68 , 5 , 96 , 53 , 142 , 98 , 96 , 82 ] ;
3664: LD_ADDR_VAR 0 8
3668: PUSH
3669: LD_INT 68
3671: PUSH
3672: LD_INT 5
3674: PUSH
3675: LD_INT 96
3677: PUSH
3678: LD_INT 53
3680: PUSH
3681: LD_INT 142
3683: PUSH
3684: LD_INT 98
3686: PUSH
3687: LD_INT 96
3689: PUSH
3690: LD_INT 82
3692: PUSH
3693: EMPTY
3694: LIST
3695: LIST
3696: LIST
3697: LIST
3698: LIST
3699: LIST
3700: LIST
3701: LIST
3702: ST_TO_ADDR
// hover_x := [ hovercraft_area , 3 ] ;
3703: LD_ADDR_VAR 0 6
3707: PUSH
3708: LD_INT 17
3710: PUSH
3711: LD_INT 3
3713: PUSH
3714: EMPTY
3715: LIST
3716: LIST
3717: ST_TO_ADDR
// tanks_xy := [ 104 , 21 , 4 , 100 , 21 , 4 , 91 , 28 , 0 , 92 , 31 , 1 , 71 , 106 , 2 , 71 , 103 , 2 , 66 , 102 , 2 ] ;
3718: LD_ADDR_VAR 0 5
3722: PUSH
3723: LD_INT 104
3725: PUSH
3726: LD_INT 21
3728: PUSH
3729: LD_INT 4
3731: PUSH
3732: LD_INT 100
3734: PUSH
3735: LD_INT 21
3737: PUSH
3738: LD_INT 4
3740: PUSH
3741: LD_INT 91
3743: PUSH
3744: LD_INT 28
3746: PUSH
3747: LD_INT 0
3749: PUSH
3750: LD_INT 92
3752: PUSH
3753: LD_INT 31
3755: PUSH
3756: LD_INT 1
3758: PUSH
3759: LD_INT 71
3761: PUSH
3762: LD_INT 106
3764: PUSH
3765: LD_INT 2
3767: PUSH
3768: LD_INT 71
3770: PUSH
3771: LD_INT 103
3773: PUSH
3774: LD_INT 2
3776: PUSH
3777: LD_INT 66
3779: PUSH
3780: LD_INT 102
3782: PUSH
3783: LD_INT 2
3785: PUSH
3786: EMPTY
3787: LIST
3788: LIST
3789: LIST
3790: LIST
3791: LIST
3792: LIST
3793: LIST
3794: LIST
3795: LIST
3796: LIST
3797: LIST
3798: LIST
3799: LIST
3800: LIST
3801: LIST
3802: LIST
3803: LIST
3804: LIST
3805: LIST
3806: LIST
3807: LIST
3808: ST_TO_ADDR
// mines_xy := [ 38 , 28 , 41 , 29 , 62 , 5 , 65 , 7 , 95 , 55 , 98 , 54 , 96 , 111 , 99 , 112 , 86 , 17 , 89 , 17 , 136 , 91 , 140 , 91 , 102 , 54 ] ;
3809: LD_ADDR_VAR 0 7
3813: PUSH
3814: LD_INT 38
3816: PUSH
3817: LD_INT 28
3819: PUSH
3820: LD_INT 41
3822: PUSH
3823: LD_INT 29
3825: PUSH
3826: LD_INT 62
3828: PUSH
3829: LD_INT 5
3831: PUSH
3832: LD_INT 65
3834: PUSH
3835: LD_INT 7
3837: PUSH
3838: LD_INT 95
3840: PUSH
3841: LD_INT 55
3843: PUSH
3844: LD_INT 98
3846: PUSH
3847: LD_INT 54
3849: PUSH
3850: LD_INT 96
3852: PUSH
3853: LD_INT 111
3855: PUSH
3856: LD_INT 99
3858: PUSH
3859: LD_INT 112
3861: PUSH
3862: LD_INT 86
3864: PUSH
3865: LD_INT 17
3867: PUSH
3868: LD_INT 89
3870: PUSH
3871: LD_INT 17
3873: PUSH
3874: LD_INT 136
3876: PUSH
3877: LD_INT 91
3879: PUSH
3880: LD_INT 140
3882: PUSH
3883: LD_INT 91
3885: PUSH
3886: LD_INT 102
3888: PUSH
3889: LD_INT 54
3891: PUSH
3892: EMPTY
3893: LIST
3894: LIST
3895: LIST
3896: LIST
3897: LIST
3898: LIST
3899: LIST
3900: LIST
3901: LIST
3902: LIST
3903: LIST
3904: LIST
3905: LIST
3906: LIST
3907: LIST
3908: LIST
3909: LIST
3910: LIST
3911: LIST
3912: LIST
3913: LIST
3914: LIST
3915: LIST
3916: LIST
3917: LIST
3918: LIST
3919: ST_TO_ADDR
// end ; end ;
3920: GO 3923
3922: POP
// end else
3923: GO 4865
// if road = 2 then
3925: LD_EXP 2
3929: PUSH
3930: LD_INT 2
3932: EQUAL
3933: IFFALSE 4865
// begin case Difficulty of 1 :
3935: LD_OWVAR 67
3939: PUSH
3940: LD_INT 1
3942: DOUBLE
3943: EQUAL
3944: IFTRUE 3948
3946: GO 4359
3948: POP
// begin bunker_xy := [ 44 , 22 , 2 , 62 , 8 , 0 , 106 , 68 , 2 , 143 , 96 , 3 , 90 , 115 , 4 , 56 , 59 , 5 ] ;
3949: LD_ADDR_VAR 0 2
3953: PUSH
3954: LD_INT 44
3956: PUSH
3957: LD_INT 22
3959: PUSH
3960: LD_INT 2
3962: PUSH
3963: LD_INT 62
3965: PUSH
3966: LD_INT 8
3968: PUSH
3969: LD_INT 0
3971: PUSH
3972: LD_INT 106
3974: PUSH
3975: LD_INT 68
3977: PUSH
3978: LD_INT 2
3980: PUSH
3981: LD_INT 143
3983: PUSH
3984: LD_INT 96
3986: PUSH
3987: LD_INT 3
3989: PUSH
3990: LD_INT 90
3992: PUSH
3993: LD_INT 115
3995: PUSH
3996: LD_INT 4
3998: PUSH
3999: LD_INT 56
4001: PUSH
4002: LD_INT 59
4004: PUSH
4005: LD_INT 5
4007: PUSH
4008: EMPTY
4009: LIST
4010: LIST
4011: LIST
4012: LIST
4013: LIST
4014: LIST
4015: LIST
4016: LIST
4017: LIST
4018: LIST
4019: LIST
4020: LIST
4021: LIST
4022: LIST
4023: LIST
4024: LIST
4025: LIST
4026: LIST
4027: ST_TO_ADDR
// sold_stand := [ ccr1 , ccr2 , ccr3 , ccr4 , ccr5 , ccr6 ] ;
4028: LD_ADDR_VAR 0 3
4032: PUSH
4033: LD_INT 45
4035: PUSH
4036: LD_INT 46
4038: PUSH
4039: LD_INT 47
4041: PUSH
4042: LD_INT 48
4044: PUSH
4045: LD_INT 49
4047: PUSH
4048: LD_INT 50
4050: PUSH
4051: EMPTY
4052: LIST
4053: LIST
4054: LIST
4055: LIST
4056: LIST
4057: LIST
4058: ST_TO_ADDR
// sold_crawl := [ ccr1 , ccr2 , ccr3 , ccr4 , ccr5 , ccr6 ] ;
4059: LD_ADDR_VAR 0 4
4063: PUSH
4064: LD_INT 45
4066: PUSH
4067: LD_INT 46
4069: PUSH
4070: LD_INT 47
4072: PUSH
4073: LD_INT 48
4075: PUSH
4076: LD_INT 49
4078: PUSH
4079: LD_INT 50
4081: PUSH
4082: EMPTY
4083: LIST
4084: LIST
4085: LIST
4086: LIST
4087: LIST
4088: LIST
4089: ST_TO_ADDR
// d := [ 0 , 0 , 5 , 0 , 1 , 1 ] ;
4090: LD_ADDR_VAR 0 15
4094: PUSH
4095: LD_INT 0
4097: PUSH
4098: LD_INT 0
4100: PUSH
4101: LD_INT 5
4103: PUSH
4104: LD_INT 0
4106: PUSH
4107: LD_INT 1
4109: PUSH
4110: LD_INT 1
4112: PUSH
4113: EMPTY
4114: LIST
4115: LIST
4116: LIST
4117: LIST
4118: LIST
4119: LIST
4120: ST_TO_ADDR
// camera_xy := [ 44 , 22 , 62 , 8 , 106 , 68 , 143 , 96 , 90 , 115 , 56 , 59 ] ;
4121: LD_ADDR_VAR 0 8
4125: PUSH
4126: LD_INT 44
4128: PUSH
4129: LD_INT 22
4131: PUSH
4132: LD_INT 62
4134: PUSH
4135: LD_INT 8
4137: PUSH
4138: LD_INT 106
4140: PUSH
4141: LD_INT 68
4143: PUSH
4144: LD_INT 143
4146: PUSH
4147: LD_INT 96
4149: PUSH
4150: LD_INT 90
4152: PUSH
4153: LD_INT 115
4155: PUSH
4156: LD_INT 56
4158: PUSH
4159: LD_INT 59
4161: PUSH
4162: EMPTY
4163: LIST
4164: LIST
4165: LIST
4166: LIST
4167: LIST
4168: LIST
4169: LIST
4170: LIST
4171: LIST
4172: LIST
4173: LIST
4174: LIST
4175: ST_TO_ADDR
// hover_x := [ hovercraft_area , 3 ] ;
4176: LD_ADDR_VAR 0 6
4180: PUSH
4181: LD_INT 17
4183: PUSH
4184: LD_INT 3
4186: PUSH
4187: EMPTY
4188: LIST
4189: LIST
4190: ST_TO_ADDR
// tanks_xy := [ 51 , 29 , 5 , 55 , 33 , 5 ] ;
4191: LD_ADDR_VAR 0 5
4195: PUSH
4196: LD_INT 51
4198: PUSH
4199: LD_INT 29
4201: PUSH
4202: LD_INT 5
4204: PUSH
4205: LD_INT 55
4207: PUSH
4208: LD_INT 33
4210: PUSH
4211: LD_INT 5
4213: PUSH
4214: EMPTY
4215: LIST
4216: LIST
4217: LIST
4218: LIST
4219: LIST
4220: LIST
4221: ST_TO_ADDR
// mines_xy := [ 31 , 13 , 33 , 13 , 35 , 13 , 98 , 20 , 102 , 25 , 97 , 33 , 101 , 54 , 98 , 54 , 96 , 55 , 94 , 56 , 145 , 102 , 146 , 100 , 97 , 114 , 99 , 117 , 54 , 58 , 55 , 56 ] ;
4222: LD_ADDR_VAR 0 7
4226: PUSH
4227: LD_INT 31
4229: PUSH
4230: LD_INT 13
4232: PUSH
4233: LD_INT 33
4235: PUSH
4236: LD_INT 13
4238: PUSH
4239: LD_INT 35
4241: PUSH
4242: LD_INT 13
4244: PUSH
4245: LD_INT 98
4247: PUSH
4248: LD_INT 20
4250: PUSH
4251: LD_INT 102
4253: PUSH
4254: LD_INT 25
4256: PUSH
4257: LD_INT 97
4259: PUSH
4260: LD_INT 33
4262: PUSH
4263: LD_INT 101
4265: PUSH
4266: LD_INT 54
4268: PUSH
4269: LD_INT 98
4271: PUSH
4272: LD_INT 54
4274: PUSH
4275: LD_INT 96
4277: PUSH
4278: LD_INT 55
4280: PUSH
4281: LD_INT 94
4283: PUSH
4284: LD_INT 56
4286: PUSH
4287: LD_INT 145
4289: PUSH
4290: LD_INT 102
4292: PUSH
4293: LD_INT 146
4295: PUSH
4296: LD_INT 100
4298: PUSH
4299: LD_INT 97
4301: PUSH
4302: LD_INT 114
4304: PUSH
4305: LD_INT 99
4307: PUSH
4308: LD_INT 117
4310: PUSH
4311: LD_INT 54
4313: PUSH
4314: LD_INT 58
4316: PUSH
4317: LD_INT 55
4319: PUSH
4320: LD_INT 56
4322: PUSH
4323: EMPTY
4324: LIST
4325: LIST
4326: LIST
4327: LIST
4328: LIST
4329: LIST
4330: LIST
4331: LIST
4332: LIST
4333: LIST
4334: LIST
4335: LIST
4336: LIST
4337: LIST
4338: LIST
4339: LIST
4340: LIST
4341: LIST
4342: LIST
4343: LIST
4344: LIST
4345: LIST
4346: LIST
4347: LIST
4348: LIST
4349: LIST
4350: LIST
4351: LIST
4352: LIST
4353: LIST
4354: LIST
4355: LIST
4356: ST_TO_ADDR
// end ; 2 , 3 :
4357: GO 4865
4359: LD_INT 2
4361: DOUBLE
4362: EQUAL
4363: IFTRUE 4373
4365: LD_INT 3
4367: DOUBLE
4368: EQUAL
4369: IFTRUE 4373
4371: GO 4864
4373: POP
// begin bunker_xy := [ 44 , 22 , 2 , 62 , 8 , 0 , 106 , 68 , 2 , 143 , 96 , 3 , 90 , 115 , 4 , 56 , 59 , 5 ] ;
4374: LD_ADDR_VAR 0 2
4378: PUSH
4379: LD_INT 44
4381: PUSH
4382: LD_INT 22
4384: PUSH
4385: LD_INT 2
4387: PUSH
4388: LD_INT 62
4390: PUSH
4391: LD_INT 8
4393: PUSH
4394: LD_INT 0
4396: PUSH
4397: LD_INT 106
4399: PUSH
4400: LD_INT 68
4402: PUSH
4403: LD_INT 2
4405: PUSH
4406: LD_INT 143
4408: PUSH
4409: LD_INT 96
4411: PUSH
4412: LD_INT 3
4414: PUSH
4415: LD_INT 90
4417: PUSH
4418: LD_INT 115
4420: PUSH
4421: LD_INT 4
4423: PUSH
4424: LD_INT 56
4426: PUSH
4427: LD_INT 59
4429: PUSH
4430: LD_INT 5
4432: PUSH
4433: EMPTY
4434: LIST
4435: LIST
4436: LIST
4437: LIST
4438: LIST
4439: LIST
4440: LIST
4441: LIST
4442: LIST
4443: LIST
4444: LIST
4445: LIST
4446: LIST
4447: LIST
4448: LIST
4449: LIST
4450: LIST
4451: LIST
4452: ST_TO_ADDR
// sold_stand := [ ccr1 , ccr2 , ccr3 , ccr4 , ccr5 , ccr6 ] ;
4453: LD_ADDR_VAR 0 3
4457: PUSH
4458: LD_INT 45
4460: PUSH
4461: LD_INT 46
4463: PUSH
4464: LD_INT 47
4466: PUSH
4467: LD_INT 48
4469: PUSH
4470: LD_INT 49
4472: PUSH
4473: LD_INT 50
4475: PUSH
4476: EMPTY
4477: LIST
4478: LIST
4479: LIST
4480: LIST
4481: LIST
4482: LIST
4483: ST_TO_ADDR
// sold_crawl := [ ccr1 , ccr2 , ccr3 , ccr4 , ccr5 , ccr6 ] ;
4484: LD_ADDR_VAR 0 4
4488: PUSH
4489: LD_INT 45
4491: PUSH
4492: LD_INT 46
4494: PUSH
4495: LD_INT 47
4497: PUSH
4498: LD_INT 48
4500: PUSH
4501: LD_INT 49
4503: PUSH
4504: LD_INT 50
4506: PUSH
4507: EMPTY
4508: LIST
4509: LIST
4510: LIST
4511: LIST
4512: LIST
4513: LIST
4514: ST_TO_ADDR
// d := [ 0 , 0 , 5 , 0 , 1 , 1 ] ;
4515: LD_ADDR_VAR 0 15
4519: PUSH
4520: LD_INT 0
4522: PUSH
4523: LD_INT 0
4525: PUSH
4526: LD_INT 5
4528: PUSH
4529: LD_INT 0
4531: PUSH
4532: LD_INT 1
4534: PUSH
4535: LD_INT 1
4537: PUSH
4538: EMPTY
4539: LIST
4540: LIST
4541: LIST
4542: LIST
4543: LIST
4544: LIST
4545: ST_TO_ADDR
// camera_xy := [ 21 , 27 , 44 , 22 , 62 , 8 , 106 , 68 , 143 , 96 , 90 , 115 , 56 , 59 ] ;
4546: LD_ADDR_VAR 0 8
4550: PUSH
4551: LD_INT 21
4553: PUSH
4554: LD_INT 27
4556: PUSH
4557: LD_INT 44
4559: PUSH
4560: LD_INT 22
4562: PUSH
4563: LD_INT 62
4565: PUSH
4566: LD_INT 8
4568: PUSH
4569: LD_INT 106
4571: PUSH
4572: LD_INT 68
4574: PUSH
4575: LD_INT 143
4577: PUSH
4578: LD_INT 96
4580: PUSH
4581: LD_INT 90
4583: PUSH
4584: LD_INT 115
4586: PUSH
4587: LD_INT 56
4589: PUSH
4590: LD_INT 59
4592: PUSH
4593: EMPTY
4594: LIST
4595: LIST
4596: LIST
4597: LIST
4598: LIST
4599: LIST
4600: LIST
4601: LIST
4602: LIST
4603: LIST
4604: LIST
4605: LIST
4606: LIST
4607: LIST
4608: ST_TO_ADDR
// hover_x := [ hovercraft_area , 4 ] ;
4609: LD_ADDR_VAR 0 6
4613: PUSH
4614: LD_INT 17
4616: PUSH
4617: LD_INT 4
4619: PUSH
4620: EMPTY
4621: LIST
4622: LIST
4623: ST_TO_ADDR
// tanks_xy := [ 51 , 29 , 5 , 55 , 33 , 5 , 97 , 37 , 0 , 112 , 72 , 5 , 120 , 93 , 2 , 25 , 45 , 1 , 27 , 48 , 1 , 28 , 51 , 1 ] ;
4624: LD_ADDR_VAR 0 5
4628: PUSH
4629: LD_INT 51
4631: PUSH
4632: LD_INT 29
4634: PUSH
4635: LD_INT 5
4637: PUSH
4638: LD_INT 55
4640: PUSH
4641: LD_INT 33
4643: PUSH
4644: LD_INT 5
4646: PUSH
4647: LD_INT 97
4649: PUSH
4650: LD_INT 37
4652: PUSH
4653: LD_INT 0
4655: PUSH
4656: LD_INT 112
4658: PUSH
4659: LD_INT 72
4661: PUSH
4662: LD_INT 5
4664: PUSH
4665: LD_INT 120
4667: PUSH
4668: LD_INT 93
4670: PUSH
4671: LD_INT 2
4673: PUSH
4674: LD_INT 25
4676: PUSH
4677: LD_INT 45
4679: PUSH
4680: LD_INT 1
4682: PUSH
4683: LD_INT 27
4685: PUSH
4686: LD_INT 48
4688: PUSH
4689: LD_INT 1
4691: PUSH
4692: LD_INT 28
4694: PUSH
4695: LD_INT 51
4697: PUSH
4698: LD_INT 1
4700: PUSH
4701: EMPTY
4702: LIST
4703: LIST
4704: LIST
4705: LIST
4706: LIST
4707: LIST
4708: LIST
4709: LIST
4710: LIST
4711: LIST
4712: LIST
4713: LIST
4714: LIST
4715: LIST
4716: LIST
4717: LIST
4718: LIST
4719: LIST
4720: LIST
4721: LIST
4722: LIST
4723: LIST
4724: LIST
4725: LIST
4726: ST_TO_ADDR
// mines_xy := [ 31 , 13 , 33 , 13 , 35 , 13 , 98 , 20 , 102 , 25 , 97 , 33 , 101 , 54 , 98 , 54 , 96 , 55 , 94 , 56 , 145 , 102 , 146 , 100 , 97 , 114 , 99 , 117 , 54 , 58 , 55 , 56 ] ;
4727: LD_ADDR_VAR 0 7
4731: PUSH
4732: LD_INT 31
4734: PUSH
4735: LD_INT 13
4737: PUSH
4738: LD_INT 33
4740: PUSH
4741: LD_INT 13
4743: PUSH
4744: LD_INT 35
4746: PUSH
4747: LD_INT 13
4749: PUSH
4750: LD_INT 98
4752: PUSH
4753: LD_INT 20
4755: PUSH
4756: LD_INT 102
4758: PUSH
4759: LD_INT 25
4761: PUSH
4762: LD_INT 97
4764: PUSH
4765: LD_INT 33
4767: PUSH
4768: LD_INT 101
4770: PUSH
4771: LD_INT 54
4773: PUSH
4774: LD_INT 98
4776: PUSH
4777: LD_INT 54
4779: PUSH
4780: LD_INT 96
4782: PUSH
4783: LD_INT 55
4785: PUSH
4786: LD_INT 94
4788: PUSH
4789: LD_INT 56
4791: PUSH
4792: LD_INT 145
4794: PUSH
4795: LD_INT 102
4797: PUSH
4798: LD_INT 146
4800: PUSH
4801: LD_INT 100
4803: PUSH
4804: LD_INT 97
4806: PUSH
4807: LD_INT 114
4809: PUSH
4810: LD_INT 99
4812: PUSH
4813: LD_INT 117
4815: PUSH
4816: LD_INT 54
4818: PUSH
4819: LD_INT 58
4821: PUSH
4822: LD_INT 55
4824: PUSH
4825: LD_INT 56
4827: PUSH
4828: EMPTY
4829: LIST
4830: LIST
4831: LIST
4832: LIST
4833: LIST
4834: LIST
4835: LIST
4836: LIST
4837: LIST
4838: LIST
4839: LIST
4840: LIST
4841: LIST
4842: LIST
4843: LIST
4844: LIST
4845: LIST
4846: LIST
4847: LIST
4848: LIST
4849: LIST
4850: LIST
4851: LIST
4852: LIST
4853: LIST
4854: LIST
4855: LIST
4856: LIST
4857: LIST
4858: LIST
4859: LIST
4860: LIST
4861: ST_TO_ADDR
// end ; end ;
4862: GO 4865
4864: POP
// end ; skill := [ 4 , 5 , 6 ] [ Difficulty ] ;
4865: LD_ADDR_EXP 3
4869: PUSH
4870: LD_INT 4
4872: PUSH
4873: LD_INT 5
4875: PUSH
4876: LD_INT 6
4878: PUSH
4879: EMPTY
4880: LIST
4881: LIST
4882: LIST
4883: PUSH
4884: LD_OWVAR 67
4888: ARRAY
4889: ST_TO_ADDR
// if Difficulty > 1 then
4890: LD_OWVAR 67
4894: PUSH
4895: LD_INT 1
4897: GREATER
4898: IFFALSE 4913
// SetTech ( tech_stimdrugs , 2 , state_researched ) ;
4900: LD_INT 5
4902: PPUSH
4903: LD_INT 2
4905: PPUSH
4906: LD_INT 2
4908: PPUSH
4909: CALL_OW 322
// if Difficulty > 1 then
4913: LD_OWVAR 67
4917: PUSH
4918: LD_INT 1
4920: GREATER
4921: IFFALSE 4936
// SetTech ( tech_weap2 , 2 , state_researched ) ;
4923: LD_INT 52
4925: PPUSH
4926: LD_INT 2
4928: PPUSH
4929: LD_INT 2
4931: PPUSH
4932: CALL_OW 322
// miners := [ ] ;
4936: LD_ADDR_EXP 15
4940: PUSH
4941: EMPTY
4942: ST_TO_ADDR
// hovers := [ ] ;
4943: LD_ADDR_EXP 16
4947: PUSH
4948: EMPTY
4949: ST_TO_ADDR
// hovers_driver := [ ] ;
4950: LD_ADDR_EXP 17
4954: PUSH
4955: EMPTY
4956: ST_TO_ADDR
// tanks := [ ] ;
4957: LD_ADDR_EXP 18
4961: PUSH
4962: EMPTY
4963: ST_TO_ADDR
// p := 1 ;
4964: LD_ADDR_VAR 0 10
4968: PUSH
4969: LD_INT 1
4971: ST_TO_ADDR
// bc_level = [ 4 , 5 , 6 , 7 ] [ Difficulty + 1 ] ;
4972: LD_ADDR_OWVAR 43
4976: PUSH
4977: LD_INT 4
4979: PUSH
4980: LD_INT 5
4982: PUSH
4983: LD_INT 6
4985: PUSH
4986: LD_INT 7
4988: PUSH
4989: EMPTY
4990: LIST
4991: LIST
4992: LIST
4993: LIST
4994: PUSH
4995: LD_OWVAR 67
4999: PUSH
5000: LD_INT 1
5002: PLUS
5003: ARRAY
5004: ST_TO_ADDR
// bc_type = b_breastwork ;
5005: LD_ADDR_OWVAR 42
5009: PUSH
5010: LD_INT 31
5012: ST_TO_ADDR
// for i = 1 to ( bunker_xy / 3 ) do
5013: LD_ADDR_VAR 0 9
5017: PUSH
5018: DOUBLE
5019: LD_INT 1
5021: DEC
5022: ST_TO_ADDR
5023: LD_VAR 0 2
5027: PUSH
5028: LD_INT 3
5030: DIVREAL
5031: PUSH
5032: FOR_TO
5033: IFFALSE 5210
// begin b := CreateAndPlaceBuildingXYD ( bunker_xy [ p ] , bunker_xy [ p + 1 ] , bunker_xy [ p + 2 ] ) ;
5035: LD_ADDR_VAR 0 13
5039: PUSH
5040: LD_VAR 0 2
5044: PUSH
5045: LD_VAR 0 10
5049: ARRAY
5050: PPUSH
5051: LD_VAR 0 2
5055: PUSH
5056: LD_VAR 0 10
5060: PUSH
5061: LD_INT 1
5063: PLUS
5064: ARRAY
5065: PPUSH
5066: LD_VAR 0 2
5070: PUSH
5071: LD_VAR 0 10
5075: PUSH
5076: LD_INT 2
5078: PLUS
5079: ARRAY
5080: PPUSH
5081: CALL_OW 47
5085: ST_TO_ADDR
// PrepareHuman ( false , 1 , skill ) ;
5086: LD_INT 0
5088: PPUSH
5089: LD_INT 1
5091: PPUSH
5092: LD_EXP 3
5096: PPUSH
5097: CALL_OW 380
// un := CreateHuman ;
5101: LD_ADDR_VAR 0 12
5105: PUSH
5106: CALL_OW 44
5110: ST_TO_ADDR
// dir := GetDir ( b ) ;
5111: LD_ADDR_VAR 0 16
5115: PUSH
5116: LD_VAR 0 13
5120: PPUSH
5121: CALL_OW 254
5125: ST_TO_ADDR
// if dir < 3 then
5126: LD_VAR 0 16
5130: PUSH
5131: LD_INT 3
5133: LESS
5134: IFFALSE 5152
// dir := dir + 3 else
5136: LD_ADDR_VAR 0 16
5140: PUSH
5141: LD_VAR 0 16
5145: PUSH
5146: LD_INT 3
5148: PLUS
5149: ST_TO_ADDR
5150: GO 5166
// dir := dir - 3 ;
5152: LD_ADDR_VAR 0 16
5156: PUSH
5157: LD_VAR 0 16
5161: PUSH
5162: LD_INT 3
5164: MINUS
5165: ST_TO_ADDR
// SetDir ( un , dir ) ;
5166: LD_VAR 0 12
5170: PPUSH
5171: LD_VAR 0 16
5175: PPUSH
5176: CALL_OW 233
// PlaceHumanInUnit ( un , b ) ;
5180: LD_VAR 0 12
5184: PPUSH
5185: LD_VAR 0 13
5189: PPUSH
5190: CALL_OW 52
// p := p + 3 ;
5194: LD_ADDR_VAR 0 10
5198: PUSH
5199: LD_VAR 0 10
5203: PUSH
5204: LD_INT 3
5206: PLUS
5207: ST_TO_ADDR
// end ;
5208: GO 5032
5210: POP
5211: POP
// x := [ 2 , 3 , 4 ] [ Difficulty ] ;
5212: LD_ADDR_VAR 0 14
5216: PUSH
5217: LD_INT 2
5219: PUSH
5220: LD_INT 3
5222: PUSH
5223: LD_INT 4
5225: PUSH
5226: EMPTY
5227: LIST
5228: LIST
5229: LIST
5230: PUSH
5231: LD_OWVAR 67
5235: ARRAY
5236: ST_TO_ADDR
// for i = 1 to sold_stand do
5237: LD_ADDR_VAR 0 9
5241: PUSH
5242: DOUBLE
5243: LD_INT 1
5245: DEC
5246: ST_TO_ADDR
5247: LD_VAR 0 3
5251: PUSH
5252: FOR_TO
5253: IFFALSE 5432
// for p = 1 to x do
5255: LD_ADDR_VAR 0 10
5259: PUSH
5260: DOUBLE
5261: LD_INT 1
5263: DEC
5264: ST_TO_ADDR
5265: LD_VAR 0 14
5269: PUSH
5270: FOR_TO
5271: IFFALSE 5428
// begin if sold_stand [ i ] = sold4 or ( road = 2 and difficulty > 1 and p = x ) then
5273: LD_VAR 0 3
5277: PUSH
5278: LD_VAR 0 9
5282: ARRAY
5283: PUSH
5284: LD_INT 10
5286: EQUAL
5287: PUSH
5288: LD_EXP 2
5292: PUSH
5293: LD_INT 2
5295: EQUAL
5296: PUSH
5297: LD_OWVAR 67
5301: PUSH
5302: LD_INT 1
5304: GREATER
5305: AND
5306: PUSH
5307: LD_VAR 0 10
5311: PUSH
5312: LD_VAR 0 14
5316: EQUAL
5317: AND
5318: OR
5319: IFFALSE 5338
// PrepareHuman ( false , class_mortar , skill ) else
5321: LD_INT 0
5323: PPUSH
5324: LD_INT 8
5326: PPUSH
5327: LD_EXP 3
5331: PPUSH
5332: CALL_OW 380
5336: GO 5353
// PrepareHuman ( false , 1 , skill ) ;
5338: LD_INT 0
5340: PPUSH
5341: LD_INT 1
5343: PPUSH
5344: LD_EXP 3
5348: PPUSH
5349: CALL_OW 380
// un := CreateHuman ;
5353: LD_ADDR_VAR 0 12
5357: PUSH
5358: CALL_OW 44
5362: ST_TO_ADDR
// if GetClass ( un ) = 1 then
5363: LD_VAR 0 12
5367: PPUSH
5368: CALL_OW 257
5372: PUSH
5373: LD_INT 1
5375: EQUAL
5376: IFFALSE 5394
// miners := miners ^ un ;
5378: LD_ADDR_EXP 15
5382: PUSH
5383: LD_EXP 15
5387: PUSH
5388: LD_VAR 0 12
5392: ADD
5393: ST_TO_ADDR
// PlaceUnitArea ( un , sold_stand [ i ] , false ) ;
5394: LD_VAR 0 12
5398: PPUSH
5399: LD_VAR 0 3
5403: PUSH
5404: LD_VAR 0 9
5408: ARRAY
5409: PPUSH
5410: LD_INT 0
5412: PPUSH
5413: CALL_OW 49
// ComHold ( un ) ;
5417: LD_VAR 0 12
5421: PPUSH
5422: CALL_OW 140
// end ;
5426: GO 5270
5428: POP
5429: POP
5430: GO 5252
5432: POP
5433: POP
// x := [ 3 , 4 , 4 ] [ Difficulty ] ;
5434: LD_ADDR_VAR 0 14
5438: PUSH
5439: LD_INT 3
5441: PUSH
5442: LD_INT 4
5444: PUSH
5445: LD_INT 4
5447: PUSH
5448: EMPTY
5449: LIST
5450: LIST
5451: LIST
5452: PUSH
5453: LD_OWVAR 67
5457: ARRAY
5458: ST_TO_ADDR
// for i = 1 to sold_crawl do
5459: LD_ADDR_VAR 0 9
5463: PUSH
5464: DOUBLE
5465: LD_INT 1
5467: DEC
5468: ST_TO_ADDR
5469: LD_VAR 0 4
5473: PUSH
5474: FOR_TO
5475: IFFALSE 5587
// for p = 1 to x do
5477: LD_ADDR_VAR 0 10
5481: PUSH
5482: DOUBLE
5483: LD_INT 1
5485: DEC
5486: ST_TO_ADDR
5487: LD_VAR 0 14
5491: PUSH
5492: FOR_TO
5493: IFFALSE 5583
// begin PrepareHuman ( false , 1 , skill ) ;
5495: LD_INT 0
5497: PPUSH
5498: LD_INT 1
5500: PPUSH
5501: LD_EXP 3
5505: PPUSH
5506: CALL_OW 380
// un := CreateHuman ;
5510: LD_ADDR_VAR 0 12
5514: PUSH
5515: CALL_OW 44
5519: ST_TO_ADDR
// SetDir ( un , d [ i ] ) ;
5520: LD_VAR 0 12
5524: PPUSH
5525: LD_VAR 0 15
5529: PUSH
5530: LD_VAR 0 9
5534: ARRAY
5535: PPUSH
5536: CALL_OW 233
// PlaceUnitArea ( un , sold_crawl [ i ] , false ) ;
5540: LD_VAR 0 12
5544: PPUSH
5545: LD_VAR 0 4
5549: PUSH
5550: LD_VAR 0 9
5554: ARRAY
5555: PPUSH
5556: LD_INT 0
5558: PPUSH
5559: CALL_OW 49
// ComCrawl ( un ) ;
5563: LD_VAR 0 12
5567: PPUSH
5568: CALL_OW 137
// AddComHold ( un ) ;
5572: LD_VAR 0 12
5576: PPUSH
5577: CALL_OW 200
// end ;
5581: GO 5492
5583: POP
5584: POP
5585: GO 5474
5587: POP
5588: POP
// p := 1 ;
5589: LD_ADDR_VAR 0 10
5593: PUSH
5594: LD_INT 1
5596: ST_TO_ADDR
// for i = 1 to ( camera_xy / 2 ) do
5597: LD_ADDR_VAR 0 9
5601: PUSH
5602: DOUBLE
5603: LD_INT 1
5605: DEC
5606: ST_TO_ADDR
5607: LD_VAR 0 8
5611: PUSH
5612: LD_INT 2
5614: DIVREAL
5615: PUSH
5616: FOR_TO
5617: IFFALSE 5671
// begin PlaceSeeing ( camera_xy [ p ] , camera_xy [ p + 1 ] , 2 , 10 ) ;
5619: LD_VAR 0 8
5623: PUSH
5624: LD_VAR 0 10
5628: ARRAY
5629: PPUSH
5630: LD_VAR 0 8
5634: PUSH
5635: LD_VAR 0 10
5639: PUSH
5640: LD_INT 1
5642: PLUS
5643: ARRAY
5644: PPUSH
5645: LD_INT 2
5647: PPUSH
5648: LD_INT 10
5650: PPUSH
5651: CALL_OW 330
// p := p + 2 ;
5655: LD_ADDR_VAR 0 10
5659: PUSH
5660: LD_VAR 0 10
5664: PUSH
5665: LD_INT 2
5667: PLUS
5668: ST_TO_ADDR
// end ;
5669: GO 5616
5671: POP
5672: POP
// for i = 1 to hover_x [ 2 ] do
5673: LD_ADDR_VAR 0 9
5677: PUSH
5678: DOUBLE
5679: LD_INT 1
5681: DEC
5682: ST_TO_ADDR
5683: LD_VAR 0 6
5687: PUSH
5688: LD_INT 2
5690: ARRAY
5691: PUSH
5692: FOR_TO
5693: IFFALSE 5842
// begin PrepareHuman ( false , 3 , skill + 1 ) ;
5695: LD_INT 0
5697: PPUSH
5698: LD_INT 3
5700: PPUSH
5701: LD_EXP 3
5705: PUSH
5706: LD_INT 1
5708: PLUS
5709: PPUSH
5710: CALL_OW 380
// un := CreateHuman ;
5714: LD_ADDR_VAR 0 12
5718: PUSH
5719: CALL_OW 44
5723: ST_TO_ADDR
// hovers_driver := hovers_driver ^ un ;
5724: LD_ADDR_EXP 17
5728: PUSH
5729: LD_EXP 17
5733: PUSH
5734: LD_VAR 0 12
5738: ADD
5739: ST_TO_ADDR
// veh := CreateTank ( 2 , 2 , ar_hovercraft , engine_solar , control_manual , [ 92 , ar_double_machine_gun ] [ i mod 2 + 1 ] ) ;
5740: LD_ADDR_VAR 0 11
5744: PUSH
5745: LD_INT 2
5747: PPUSH
5748: LD_INT 2
5750: PPUSH
5751: LD_INT 11
5753: PPUSH
5754: LD_INT 2
5756: PPUSH
5757: LD_INT 1
5759: PPUSH
5760: LD_INT 92
5762: PUSH
5763: LD_INT 24
5765: PUSH
5766: EMPTY
5767: LIST
5768: LIST
5769: PUSH
5770: LD_VAR 0 9
5774: PUSH
5775: LD_INT 2
5777: MOD
5778: PUSH
5779: LD_INT 1
5781: PLUS
5782: ARRAY
5783: PPUSH
5784: CALL 7075 0 6
5788: ST_TO_ADDR
// hovers := hovers ^ veh ;
5789: LD_ADDR_EXP 16
5793: PUSH
5794: LD_EXP 16
5798: PUSH
5799: LD_VAR 0 11
5803: ADD
5804: ST_TO_ADDR
// PlaceUnitArea ( veh , hover_x [ 1 ] , false ) ;
5805: LD_VAR 0 11
5809: PPUSH
5810: LD_VAR 0 6
5814: PUSH
5815: LD_INT 1
5817: ARRAY
5818: PPUSH
5819: LD_INT 0
5821: PPUSH
5822: CALL_OW 49
// PlaceHumanInUnit ( un , veh ) ;
5826: LD_VAR 0 12
5830: PPUSH
5831: LD_VAR 0 11
5835: PPUSH
5836: CALL_OW 52
// end ;
5840: GO 5692
5842: POP
5843: POP
// p := 1 ;
5844: LD_ADDR_VAR 0 10
5848: PUSH
5849: LD_INT 1
5851: ST_TO_ADDR
// for i = 1 to ( tanks_xy / 3 ) do
5852: LD_ADDR_VAR 0 9
5856: PUSH
5857: DOUBLE
5858: LD_INT 1
5860: DEC
5861: ST_TO_ADDR
5862: LD_VAR 0 5
5866: PUSH
5867: LD_INT 3
5869: DIVREAL
5870: PUSH
5871: FOR_TO
5872: IFFALSE 6046
// begin PrepareHuman ( false , 1 , skill + 1 ) ;
5874: LD_INT 0
5876: PPUSH
5877: LD_INT 1
5879: PPUSH
5880: LD_EXP 3
5884: PUSH
5885: LD_INT 1
5887: PLUS
5888: PPUSH
5889: CALL_OW 380
// un := CreateHuman ;
5893: LD_ADDR_VAR 0 12
5897: PUSH
5898: CALL_OW 44
5902: ST_TO_ADDR
// veh := CreateTank ( 2 , 2 , ar_half_tracked , engine_solar , control_manual , [ ar_gun , ar_gatling_gun , ar_flame_thrower ] [ Rand ( 1 , 3 ) ] ) ;
5903: LD_ADDR_VAR 0 11
5907: PUSH
5908: LD_INT 2
5910: PPUSH
5911: LD_INT 2
5913: PPUSH
5914: LD_INT 14
5916: PPUSH
5917: LD_INT 2
5919: PPUSH
5920: LD_INT 1
5922: PPUSH
5923: LD_INT 27
5925: PUSH
5926: LD_INT 25
5928: PUSH
5929: LD_INT 26
5931: PUSH
5932: EMPTY
5933: LIST
5934: LIST
5935: LIST
5936: PUSH
5937: LD_INT 1
5939: PPUSH
5940: LD_INT 3
5942: PPUSH
5943: CALL_OW 12
5947: ARRAY
5948: PPUSH
5949: CALL 7075 0 6
5953: ST_TO_ADDR
// SetDir ( veh , tanks_xy [ p + 2 ] ) ;
5954: LD_VAR 0 11
5958: PPUSH
5959: LD_VAR 0 5
5963: PUSH
5964: LD_VAR 0 10
5968: PUSH
5969: LD_INT 2
5971: PLUS
5972: ARRAY
5973: PPUSH
5974: CALL_OW 233
// PlaceUnitXY ( veh , tanks_xy [ p ] , tanks_xy [ p + 1 ] , false ) ;
5978: LD_VAR 0 11
5982: PPUSH
5983: LD_VAR 0 5
5987: PUSH
5988: LD_VAR 0 10
5992: ARRAY
5993: PPUSH
5994: LD_VAR 0 5
5998: PUSH
5999: LD_VAR 0 10
6003: PUSH
6004: LD_INT 1
6006: PLUS
6007: ARRAY
6008: PPUSH
6009: LD_INT 0
6011: PPUSH
6012: CALL_OW 48
// PlaceHumanInUnit ( un , veh ) ;
6016: LD_VAR 0 12
6020: PPUSH
6021: LD_VAR 0 11
6025: PPUSH
6026: CALL_OW 52
// p := p + 3 ;
6030: LD_ADDR_VAR 0 10
6034: PUSH
6035: LD_VAR 0 10
6039: PUSH
6040: LD_INT 3
6042: PLUS
6043: ST_TO_ADDR
// end ;
6044: GO 5871
6046: POP
6047: POP
// p := 1 ;
6048: LD_ADDR_VAR 0 10
6052: PUSH
6053: LD_INT 1
6055: ST_TO_ADDR
// for i = 1 to ( mines_xy / 2 ) do
6056: LD_ADDR_VAR 0 9
6060: PUSH
6061: DOUBLE
6062: LD_INT 1
6064: DEC
6065: ST_TO_ADDR
6066: LD_VAR 0 7
6070: PUSH
6071: LD_INT 2
6073: DIVREAL
6074: PUSH
6075: FOR_TO
6076: IFFALSE 6130
// begin PlaceMine ( mines_xy [ p ] , mines_xy [ p + 1 ] , 2 , 0 ) ;
6078: LD_VAR 0 7
6082: PUSH
6083: LD_VAR 0 10
6087: ARRAY
6088: PPUSH
6089: LD_VAR 0 7
6093: PUSH
6094: LD_VAR 0 10
6098: PUSH
6099: LD_INT 1
6101: PLUS
6102: ARRAY
6103: PPUSH
6104: LD_INT 2
6106: PPUSH
6107: LD_INT 0
6109: PPUSH
6110: CALL_OW 454
// p := p + 2 ;
6114: LD_ADDR_VAR 0 10
6118: PUSH
6119: LD_VAR 0 10
6123: PUSH
6124: LD_INT 2
6126: PLUS
6127: ST_TO_ADDR
// end ;
6128: GO 6075
6130: POP
6131: POP
// mines := mines_xy ;
6132: LD_ADDR_EXP 14
6136: PUSH
6137: LD_VAR 0 7
6141: ST_TO_ADDR
// end ;
6142: LD_VAR 0 1
6146: RET
// export mines , miners , hovers , hovers_driver , tanks ; every 0 0$01 do var un , p , i ;
6147: GO 6149
6149: DISABLE
6150: LD_INT 0
6152: PPUSH
6153: PPUSH
6154: PPUSH
// begin enable ;
6155: ENABLE
// if tanks > 0 then
6156: LD_EXP 18
6160: PUSH
6161: LD_INT 0
6163: GREATER
6164: IFFALSE 6272
// begin for i = 1 to tanks do
6166: LD_ADDR_VAR 0 3
6170: PUSH
6171: DOUBLE
6172: LD_INT 1
6174: DEC
6175: ST_TO_ADDR
6176: LD_EXP 18
6180: PUSH
6181: FOR_TO
6182: IFFALSE 6270
// if See ( 2 , tanks [ i ] ) and not HasTask ( tanks [ i ] ) then
6184: LD_INT 2
6186: PPUSH
6187: LD_EXP 18
6191: PUSH
6192: LD_VAR 0 3
6196: ARRAY
6197: PPUSH
6198: CALL_OW 292
6202: PUSH
6203: LD_EXP 18
6207: PUSH
6208: LD_VAR 0 3
6212: ARRAY
6213: PPUSH
6214: CALL_OW 314
6218: NOT
6219: AND
6220: IFFALSE 6268
// ComAttackUnit ( tanks [ i ] , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 2 ] ) , tanks [ i ] ) ) ;
6222: LD_EXP 18
6226: PUSH
6227: LD_VAR 0 3
6231: ARRAY
6232: PPUSH
6233: LD_INT 22
6235: PUSH
6236: LD_INT 2
6238: PUSH
6239: EMPTY
6240: LIST
6241: LIST
6242: PPUSH
6243: CALL_OW 69
6247: PPUSH
6248: LD_EXP 18
6252: PUSH
6253: LD_VAR 0 3
6257: ARRAY
6258: PPUSH
6259: CALL_OW 74
6263: PPUSH
6264: CALL_OW 115
6268: GO 6181
6270: POP
6271: POP
// end ; if hovers > 0 then
6272: LD_EXP 16
6276: PUSH
6277: LD_INT 0
6279: GREATER
6280: IFFALSE 6605
// begin for i = 1 to hovers do
6282: LD_ADDR_VAR 0 3
6286: PUSH
6287: DOUBLE
6288: LD_INT 1
6290: DEC
6291: ST_TO_ADDR
6292: LD_EXP 16
6296: PUSH
6297: FOR_TO
6298: IFFALSE 6603
// begin if GetLives ( hovers [ i ] ) < 600 then
6300: LD_EXP 16
6304: PUSH
6305: LD_VAR 0 3
6309: ARRAY
6310: PPUSH
6311: CALL_OW 256
6315: PUSH
6316: LD_INT 600
6318: LESS
6319: IFFALSE 6430
// begin if not IsInArea ( hovers [ i ] , hovercraft_park ) then
6321: LD_EXP 16
6325: PUSH
6326: LD_VAR 0 3
6330: ARRAY
6331: PPUSH
6332: LD_INT 18
6334: PPUSH
6335: CALL_OW 308
6339: NOT
6340: IFFALSE 6362
// ComMoveToArea ( hovers [ i ] , hovercraft_park ) else
6342: LD_EXP 16
6346: PUSH
6347: LD_VAR 0 3
6351: ARRAY
6352: PPUSH
6353: LD_INT 18
6355: PPUSH
6356: CALL_OW 113
6360: GO 6430
// if IsDrivenBy ( hovers [ i ] ) then
6362: LD_EXP 16
6366: PUSH
6367: LD_VAR 0 3
6371: ARRAY
6372: PPUSH
6373: CALL_OW 311
6377: IFFALSE 6430
// begin ComExitVehicle ( IsDrivenBy ( hovers [ i ] ) ) ;
6379: LD_EXP 16
6383: PUSH
6384: LD_VAR 0 3
6388: ARRAY
6389: PPUSH
6390: CALL_OW 311
6394: PPUSH
6395: CALL_OW 121
// AddComRepairVehicle ( IsDrivenBy ( hovers [ i ] ) , hovers [ i ] ) ;
6399: LD_EXP 16
6403: PUSH
6404: LD_VAR 0 3
6408: ARRAY
6409: PPUSH
6410: CALL_OW 311
6414: PPUSH
6415: LD_EXP 16
6419: PUSH
6420: LD_VAR 0 3
6424: ARRAY
6425: PPUSH
6426: CALL_OW 189
// end ; end ; if GetLives ( hovers [ i ] ) > 998 then
6430: LD_EXP 16
6434: PUSH
6435: LD_VAR 0 3
6439: ARRAY
6440: PPUSH
6441: CALL_OW 256
6445: PUSH
6446: LD_INT 998
6448: GREATER
6449: IFFALSE 6601
// begin if not IsDrivenBy ( hovers [ i ] ) then
6451: LD_EXP 16
6455: PUSH
6456: LD_VAR 0 3
6460: ARRAY
6461: PPUSH
6462: CALL_OW 311
6466: NOT
6467: IFFALSE 6504
// ComEnterUnit ( hovers_driver [ i ] , UnitFilter ( hovers , [ f_empty ] ) [ 1 ] ) ;
6469: LD_EXP 17
6473: PUSH
6474: LD_VAR 0 3
6478: ARRAY
6479: PPUSH
6480: LD_EXP 16
6484: PPUSH
6485: LD_INT 58
6487: PUSH
6488: EMPTY
6489: LIST
6490: PPUSH
6491: CALL_OW 72
6495: PUSH
6496: LD_INT 1
6498: ARRAY
6499: PPUSH
6500: CALL_OW 120
// if FilterUnitsInArea ( water_area , [ f_side , 3 ] ) > 0 then
6504: LD_INT 19
6506: PPUSH
6507: LD_INT 22
6509: PUSH
6510: LD_INT 3
6512: PUSH
6513: EMPTY
6514: LIST
6515: LIST
6516: PPUSH
6517: CALL_OW 70
6521: PUSH
6522: LD_INT 0
6524: GREATER
6525: IFFALSE 6601
// if not HasTask ( IsDrivenBy ( hovers [ i ] ) ) then
6527: LD_EXP 16
6531: PUSH
6532: LD_VAR 0 3
6536: ARRAY
6537: PPUSH
6538: CALL_OW 311
6542: PPUSH
6543: CALL_OW 314
6547: NOT
6548: IFFALSE 6601
// ComAttackUnit ( IsDrivenBy ( hovers [ i ] ) , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 3 ] ) , hovers [ i ] ) ) ;
6550: LD_EXP 16
6554: PUSH
6555: LD_VAR 0 3
6559: ARRAY
6560: PPUSH
6561: CALL_OW 311
6565: PPUSH
6566: LD_INT 22
6568: PUSH
6569: LD_INT 3
6571: PUSH
6572: EMPTY
6573: LIST
6574: LIST
6575: PPUSH
6576: CALL_OW 69
6580: PPUSH
6581: LD_EXP 16
6585: PUSH
6586: LD_VAR 0 3
6590: ARRAY
6591: PPUSH
6592: CALL_OW 74
6596: PPUSH
6597: CALL_OW 115
// end ; end ;
6601: GO 6297
6603: POP
6604: POP
// end ; p := 1 ;
6605: LD_ADDR_VAR 0 2
6609: PUSH
6610: LD_INT 1
6612: ST_TO_ADDR
// for i = 1 to ( mines / 2 ) do
6613: LD_ADDR_VAR 0 3
6617: PUSH
6618: DOUBLE
6619: LD_INT 1
6621: DEC
6622: ST_TO_ADDR
6623: LD_EXP 14
6627: PUSH
6628: LD_INT 2
6630: DIVREAL
6631: PUSH
6632: FOR_TO
6633: IFFALSE 6851
// begin if GetSide ( HexInfo ( mines [ p ] , mines [ p + 1 ] ) ) in [ 3 , 6 ] then
6635: LD_EXP 14
6639: PUSH
6640: LD_VAR 0 2
6644: ARRAY
6645: PPUSH
6646: LD_EXP 14
6650: PUSH
6651: LD_VAR 0 2
6655: PUSH
6656: LD_INT 1
6658: PLUS
6659: ARRAY
6660: PPUSH
6661: CALL_OW 428
6665: PPUSH
6666: CALL_OW 255
6670: PUSH
6671: LD_INT 3
6673: PUSH
6674: LD_INT 6
6676: PUSH
6677: EMPTY
6678: LIST
6679: LIST
6680: IN
6681: IFFALSE 6835
// if MineAtPos ( mines [ p ] , mines [ p + 1 ] ) then
6683: LD_EXP 14
6687: PUSH
6688: LD_VAR 0 2
6692: ARRAY
6693: PPUSH
6694: LD_EXP 14
6698: PUSH
6699: LD_VAR 0 2
6703: PUSH
6704: LD_INT 1
6706: PLUS
6707: ARRAY
6708: PPUSH
6709: CALL_OW 458
6713: IFFALSE 6835
// if GetDistUnitXY ( NearestUnitToXY ( miners , mines [ p ] , mines [ p + 1 ] ) , mines [ p ] , mines [ p + 1 ] ) < 30 then
6715: LD_EXP 15
6719: PPUSH
6720: LD_EXP 14
6724: PUSH
6725: LD_VAR 0 2
6729: ARRAY
6730: PPUSH
6731: LD_EXP 14
6735: PUSH
6736: LD_VAR 0 2
6740: PUSH
6741: LD_INT 1
6743: PLUS
6744: ARRAY
6745: PPUSH
6746: CALL_OW 73
6750: PPUSH
6751: LD_EXP 14
6755: PUSH
6756: LD_VAR 0 2
6760: ARRAY
6761: PPUSH
6762: LD_EXP 14
6766: PUSH
6767: LD_VAR 0 2
6771: PUSH
6772: LD_INT 1
6774: PLUS
6775: ARRAY
6776: PPUSH
6777: CALL_OW 297
6781: PUSH
6782: LD_INT 30
6784: LESS
6785: IFFALSE 6835
// begin LaunchMineAtPos ( mines [ p ] , mines [ p + 1 ] , 2 ) ;
6787: LD_EXP 14
6791: PUSH
6792: LD_VAR 0 2
6796: ARRAY
6797: PPUSH
6798: LD_EXP 14
6802: PUSH
6803: LD_VAR 0 2
6807: PUSH
6808: LD_INT 1
6810: PLUS
6811: ARRAY
6812: PPUSH
6813: LD_INT 2
6815: PPUSH
6816: CALL_OW 456
// if not mines_trigger then
6820: LD_EXP 10
6824: NOT
6825: IFFALSE 6835
// mines_trigger := true ;
6827: LD_ADDR_EXP 10
6831: PUSH
6832: LD_INT 1
6834: ST_TO_ADDR
// end ; p := p + 2 ;
6835: LD_ADDR_VAR 0 2
6839: PUSH
6840: LD_VAR 0 2
6844: PUSH
6845: LD_INT 2
6847: PLUS
6848: ST_TO_ADDR
// end ;
6849: GO 6632
6851: POP
6852: POP
// end ;
6853: PPOPN 3
6855: END
// every 0 0$30 trigger GetDistUnits ( cargos [ 1 ] , player_commander ) > 20 or GetDistUnits ( cargos [ 1 ] , player_commander ) > 20 do var i , un ;
6856: LD_EXP 4
6860: PUSH
6861: LD_INT 1
6863: ARRAY
6864: PPUSH
6865: LD_EXP 6
6869: PPUSH
6870: CALL_OW 296
6874: PUSH
6875: LD_INT 20
6877: GREATER
6878: PUSH
6879: LD_EXP 4
6883: PUSH
6884: LD_INT 1
6886: ARRAY
6887: PPUSH
6888: LD_EXP 6
6892: PPUSH
6893: CALL_OW 296
6897: PUSH
6898: LD_INT 20
6900: GREATER
6901: OR
6902: IFFALSE 7017
6904: GO 6906
6906: DISABLE
6907: LD_INT 0
6909: PPUSH
6910: PPUSH
// begin for i = 1 to Difficulty + 1 do
6911: LD_ADDR_VAR 0 1
6915: PUSH
6916: DOUBLE
6917: LD_INT 1
6919: DEC
6920: ST_TO_ADDR
6921: LD_OWVAR 67
6925: PUSH
6926: LD_INT 1
6928: PLUS
6929: PUSH
6930: FOR_TO
6931: IFFALSE 7015
// begin uc_side := 2 ;
6933: LD_ADDR_OWVAR 20
6937: PUSH
6938: LD_INT 2
6940: ST_TO_ADDR
// uc_nation := 2 ;
6941: LD_ADDR_OWVAR 21
6945: PUSH
6946: LD_INT 2
6948: ST_TO_ADDR
// PrepareHuman ( false , 1 , skill ) ;
6949: LD_INT 0
6951: PPUSH
6952: LD_INT 1
6954: PPUSH
6955: LD_EXP 3
6959: PPUSH
6960: CALL_OW 380
// un := CreateHuman ;
6964: LD_ADDR_VAR 0 2
6968: PUSH
6969: CALL_OW 44
6973: ST_TO_ADDR
// PlaceUnitArea ( un , back , false ) ;
6974: LD_VAR 0 2
6978: PPUSH
6979: LD_INT 44
6981: PPUSH
6982: LD_INT 0
6984: PPUSH
6985: CALL_OW 49
// ComAttackUnit ( un , NearestUnitToUnit ( cargos , un ) ) ;
6989: LD_VAR 0 2
6993: PPUSH
6994: LD_EXP 4
6998: PPUSH
6999: LD_VAR 0 2
7003: PPUSH
7004: CALL_OW 74
7008: PPUSH
7009: CALL_OW 115
// end ;
7013: GO 6930
7015: POP
7016: POP
// end ;
7017: PPOPN 2
7019: END
// on EvacuateVehicle ( driver , veh , p1 , p2 ) do begin if veh in FilterAllUnits ( [ [ f_side , 2 ] , [ f_not , [ f_chassis , ar_hovercraft ] ] ] ) then
7020: LD_VAR 0 2
7024: PUSH
7025: LD_INT 22
7027: PUSH
7028: LD_INT 2
7030: PUSH
7031: EMPTY
7032: LIST
7033: LIST
7034: PUSH
7035: LD_INT 3
7037: PUSH
7038: LD_INT 31
7040: PUSH
7041: LD_INT 11
7043: PUSH
7044: EMPTY
7045: LIST
7046: LIST
7047: PUSH
7048: EMPTY
7049: LIST
7050: LIST
7051: PUSH
7052: EMPTY
7053: LIST
7054: LIST
7055: PPUSH
7056: CALL_OW 69
7060: IN
7061: IFFALSE 7072
// ComRetreat ( driver ) ;
7063: LD_VAR 0 1
7067: PPUSH
7068: CALL 7204 0 1
// end ; end_of_file
7072: PPOPN 4
7074: END
// export function CreateTank ( side , nation , chassis , engine , control , weapon ) ; begin
7075: LD_INT 0
7077: PPUSH
// uc_side := side ;
7078: LD_ADDR_OWVAR 20
7082: PUSH
7083: LD_VAR 0 1
7087: ST_TO_ADDR
// uc_nation := nation ;
7088: LD_ADDR_OWVAR 21
7092: PUSH
7093: LD_VAR 0 2
7097: ST_TO_ADDR
// vc_chassis := chassis ;
7098: LD_ADDR_OWVAR 37
7102: PUSH
7103: LD_VAR 0 3
7107: ST_TO_ADDR
// vc_engine := engine ;
7108: LD_ADDR_OWVAR 39
7112: PUSH
7113: LD_VAR 0 4
7117: ST_TO_ADDR
// vc_control := control ;
7118: LD_ADDR_OWVAR 38
7122: PUSH
7123: LD_VAR 0 5
7127: ST_TO_ADDR
// vc_weapon := weapon ;
7128: LD_ADDR_OWVAR 40
7132: PUSH
7133: LD_VAR 0 6
7137: ST_TO_ADDR
// result := CreateVehicle ;
7138: LD_ADDR_VAR 0 7
7142: PUSH
7143: CALL_OW 45
7147: ST_TO_ADDR
// end ;
7148: LD_VAR 0 7
7152: RET
// export function IsNearbyPoint ( un , x , y ) ; begin
7153: LD_INT 0
7155: PPUSH
// if GetDistUnitXY ( un , x , y ) < 6 then
7156: LD_VAR 0 1
7160: PPUSH
7161: LD_VAR 0 2
7165: PPUSH
7166: LD_VAR 0 3
7170: PPUSH
7171: CALL_OW 297
7175: PUSH
7176: LD_INT 6
7178: LESS
7179: IFFALSE 7191
// result := true else
7181: LD_ADDR_VAR 0 4
7185: PUSH
7186: LD_INT 1
7188: ST_TO_ADDR
7189: GO 7199
// result := false ;
7191: LD_ADDR_VAR 0 4
7195: PUSH
7196: LD_INT 0
7198: ST_TO_ADDR
// end ;
7199: LD_VAR 0 4
7203: RET
// export function ComRetreat ( un ) ; var coord_dist , dir , x , y ; begin
7204: LD_INT 0
7206: PPUSH
7207: PPUSH
7208: PPUSH
7209: PPUSH
7210: PPUSH
// ComTurnUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( un ) ] ) , un ) ) ;
7211: LD_VAR 0 1
7215: PPUSH
7216: LD_INT 81
7218: PUSH
7219: LD_VAR 0 1
7223: PPUSH
7224: CALL_OW 255
7228: PUSH
7229: EMPTY
7230: LIST
7231: LIST
7232: PPUSH
7233: CALL_OW 69
7237: PPUSH
7238: LD_VAR 0 1
7242: PPUSH
7243: CALL_OW 74
7247: PPUSH
7248: CALL_OW 119
// dir := GetDir ( un ) ;
7252: LD_ADDR_VAR 0 4
7256: PUSH
7257: LD_VAR 0 1
7261: PPUSH
7262: CALL_OW 254
7266: ST_TO_ADDR
// dir := dir - 3 ;
7267: LD_ADDR_VAR 0 4
7271: PUSH
7272: LD_VAR 0 4
7276: PUSH
7277: LD_INT 3
7279: MINUS
7280: ST_TO_ADDR
// if dir < 0 then
7281: LD_VAR 0 4
7285: PUSH
7286: LD_INT 0
7288: LESS
7289: IFFALSE 7305
// dir := dir + 6 ;
7291: LD_ADDR_VAR 0 4
7295: PUSH
7296: LD_VAR 0 4
7300: PUSH
7301: LD_INT 6
7303: PLUS
7304: ST_TO_ADDR
// while true do
7305: LD_INT 1
7307: IFFALSE 7678
// begin coord_dist := 3 ;
7309: LD_ADDR_VAR 0 3
7313: PUSH
7314: LD_INT 3
7316: ST_TO_ADDR
// x := ShiftX ( GetX ( un ) , dir , coord_dist ) ;
7317: LD_ADDR_VAR 0 5
7321: PUSH
7322: LD_VAR 0 1
7326: PPUSH
7327: CALL_OW 250
7331: PPUSH
7332: LD_VAR 0 4
7336: PPUSH
7337: LD_VAR 0 3
7341: PPUSH
7342: CALL_OW 272
7346: ST_TO_ADDR
// y := ShiftY ( GetY ( un ) , dir , coord_dist ) ;
7347: LD_ADDR_VAR 0 6
7351: PUSH
7352: LD_VAR 0 1
7356: PPUSH
7357: CALL_OW 251
7361: PPUSH
7362: LD_VAR 0 4
7366: PPUSH
7367: LD_VAR 0 3
7371: PPUSH
7372: CALL_OW 273
7376: ST_TO_ADDR
// if IsEnvironment ( x , y ) or ValidHex ( x , y ) = 0 or HexInfo ( x , y ) <> 0 then
7377: LD_VAR 0 5
7381: PPUSH
7382: LD_VAR 0 6
7386: PPUSH
7387: CALL_OW 351
7391: PUSH
7392: LD_VAR 0 5
7396: PPUSH
7397: LD_VAR 0 6
7401: PPUSH
7402: CALL_OW 488
7406: PUSH
7407: LD_INT 0
7409: EQUAL
7410: OR
7411: PUSH
7412: LD_VAR 0 5
7416: PPUSH
7417: LD_VAR 0 6
7421: PPUSH
7422: CALL_OW 428
7426: PUSH
7427: LD_INT 0
7429: NONEQUAL
7430: OR
7431: IFFALSE 7592
// begin repeat begin coord_dist := coord_dist + 1 ;
7433: LD_ADDR_VAR 0 3
7437: PUSH
7438: LD_VAR 0 3
7442: PUSH
7443: LD_INT 1
7445: PLUS
7446: ST_TO_ADDR
// dir := dir + 1 ;
7447: LD_ADDR_VAR 0 4
7451: PUSH
7452: LD_VAR 0 4
7456: PUSH
7457: LD_INT 1
7459: PLUS
7460: ST_TO_ADDR
// if dir > 5 then
7461: LD_VAR 0 4
7465: PUSH
7466: LD_INT 5
7468: GREATER
7469: IFFALSE 7479
// dir = 0 ;
7471: LD_ADDR_VAR 0 4
7475: PUSH
7476: LD_INT 0
7478: ST_TO_ADDR
// x := ShiftX ( GetX ( un ) , dir , coord_dist ) ;
7479: LD_ADDR_VAR 0 5
7483: PUSH
7484: LD_VAR 0 1
7488: PPUSH
7489: CALL_OW 250
7493: PPUSH
7494: LD_VAR 0 4
7498: PPUSH
7499: LD_VAR 0 3
7503: PPUSH
7504: CALL_OW 272
7508: ST_TO_ADDR
// y := ShiftY ( GetY ( un ) , dir , coord_dist ) ;
7509: LD_ADDR_VAR 0 6
7513: PUSH
7514: LD_VAR 0 1
7518: PPUSH
7519: CALL_OW 251
7523: PPUSH
7524: LD_VAR 0 4
7528: PPUSH
7529: LD_VAR 0 3
7533: PPUSH
7534: CALL_OW 273
7538: ST_TO_ADDR
// end until not IsEnvironment ( x , y ) and ValidHex ( x , y ) and HexInfo ( x , y ) = 0 ;
7539: LD_VAR 0 5
7543: PPUSH
7544: LD_VAR 0 6
7548: PPUSH
7549: CALL_OW 351
7553: NOT
7554: PUSH
7555: LD_VAR 0 5
7559: PPUSH
7560: LD_VAR 0 6
7564: PPUSH
7565: CALL_OW 488
7569: AND
7570: PUSH
7571: LD_VAR 0 5
7575: PPUSH
7576: LD_VAR 0 6
7580: PPUSH
7581: CALL_OW 428
7585: PUSH
7586: LD_INT 0
7588: EQUAL
7589: AND
7590: IFFALSE 7433
// end ; ComMoveXY ( un , x , y ) ;
7592: LD_VAR 0 1
7596: PPUSH
7597: LD_VAR 0 5
7601: PPUSH
7602: LD_VAR 0 6
7606: PPUSH
7607: CALL_OW 111
// Wait ( 0 0$1 ) ;
7611: LD_INT 35
7613: PPUSH
7614: CALL_OW 67
// if GetDistUnits ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( un ) ] ) , un ) ) >= 10 then
7618: LD_VAR 0 1
7622: PPUSH
7623: LD_INT 81
7625: PUSH
7626: LD_VAR 0 1
7630: PPUSH
7631: CALL_OW 255
7635: PUSH
7636: EMPTY
7637: LIST
7638: LIST
7639: PPUSH
7640: CALL_OW 69
7644: PPUSH
7645: LD_VAR 0 1
7649: PPUSH
7650: CALL_OW 74
7654: PPUSH
7655: CALL_OW 296
7659: PUSH
7660: LD_INT 10
7662: GREATEREQUAL
7663: IFFALSE 7676
// begin ComStop ( un ) ;
7665: LD_VAR 0 1
7669: PPUSH
7670: CALL_OW 141
// break ;
7674: GO 7678
// end ; end ;
7676: GO 7305
// end ; end_of_file end_of_file
7678: LD_VAR 0 2
7682: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger ; every 0 0$1 do
7683: GO 7685
7685: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
7686: LD_STRING initStreamRollete();
7688: PPUSH
7689: CALL_OW 559
// InitStreamMode ;
7693: CALL 7702 0 0
// DefineStreamItems ( ) ;
7697: CALL 8142 0 0
// end ;
7701: END
// function InitStreamMode ; begin
7702: LD_INT 0
7704: PPUSH
// streamModeActive := false ;
7705: LD_ADDR_EXP 19
7709: PUSH
7710: LD_INT 0
7712: ST_TO_ADDR
// normalCounter := 26 ;
7713: LD_ADDR_EXP 20
7717: PUSH
7718: LD_INT 26
7720: ST_TO_ADDR
// hardcoreCounter := 12 ;
7721: LD_ADDR_EXP 21
7725: PUSH
7726: LD_INT 12
7728: ST_TO_ADDR
// sRocket := false ;
7729: LD_ADDR_EXP 24
7733: PUSH
7734: LD_INT 0
7736: ST_TO_ADDR
// sSpeed := false ;
7737: LD_ADDR_EXP 23
7741: PUSH
7742: LD_INT 0
7744: ST_TO_ADDR
// sEngine := false ;
7745: LD_ADDR_EXP 25
7749: PUSH
7750: LD_INT 0
7752: ST_TO_ADDR
// sSpec := false ;
7753: LD_ADDR_EXP 22
7757: PUSH
7758: LD_INT 0
7760: ST_TO_ADDR
// sLevel := false ;
7761: LD_ADDR_EXP 26
7765: PUSH
7766: LD_INT 0
7768: ST_TO_ADDR
// sArmoury := false ;
7769: LD_ADDR_EXP 27
7773: PUSH
7774: LD_INT 0
7776: ST_TO_ADDR
// sRadar := false ;
7777: LD_ADDR_EXP 28
7781: PUSH
7782: LD_INT 0
7784: ST_TO_ADDR
// sBunker := false ;
7785: LD_ADDR_EXP 29
7789: PUSH
7790: LD_INT 0
7792: ST_TO_ADDR
// sHack := false ;
7793: LD_ADDR_EXP 30
7797: PUSH
7798: LD_INT 0
7800: ST_TO_ADDR
// sFire := false ;
7801: LD_ADDR_EXP 31
7805: PUSH
7806: LD_INT 0
7808: ST_TO_ADDR
// sRefresh := false ;
7809: LD_ADDR_EXP 32
7813: PUSH
7814: LD_INT 0
7816: ST_TO_ADDR
// sExp := false ;
7817: LD_ADDR_EXP 33
7821: PUSH
7822: LD_INT 0
7824: ST_TO_ADDR
// sDepot := false ;
7825: LD_ADDR_EXP 34
7829: PUSH
7830: LD_INT 0
7832: ST_TO_ADDR
// sFlag := false ;
7833: LD_ADDR_EXP 35
7837: PUSH
7838: LD_INT 0
7840: ST_TO_ADDR
// sKamikadze := false ;
7841: LD_ADDR_EXP 43
7845: PUSH
7846: LD_INT 0
7848: ST_TO_ADDR
// sTroll := false ;
7849: LD_ADDR_EXP 44
7853: PUSH
7854: LD_INT 0
7856: ST_TO_ADDR
// sSlow := false ;
7857: LD_ADDR_EXP 45
7861: PUSH
7862: LD_INT 0
7864: ST_TO_ADDR
// sLack := false ;
7865: LD_ADDR_EXP 46
7869: PUSH
7870: LD_INT 0
7872: ST_TO_ADDR
// sTank := false ;
7873: LD_ADDR_EXP 48
7877: PUSH
7878: LD_INT 0
7880: ST_TO_ADDR
// sRemote := false ;
7881: LD_ADDR_EXP 49
7885: PUSH
7886: LD_INT 0
7888: ST_TO_ADDR
// sPowell := false ;
7889: LD_ADDR_EXP 50
7893: PUSH
7894: LD_INT 0
7896: ST_TO_ADDR
// sTeleport := false ;
7897: LD_ADDR_EXP 53
7901: PUSH
7902: LD_INT 0
7904: ST_TO_ADDR
// sOilTower := false ;
7905: LD_ADDR_EXP 55
7909: PUSH
7910: LD_INT 0
7912: ST_TO_ADDR
// sShovel := false ;
7913: LD_ADDR_EXP 56
7917: PUSH
7918: LD_INT 0
7920: ST_TO_ADDR
// sSheik := false ;
7921: LD_ADDR_EXP 57
7925: PUSH
7926: LD_INT 0
7928: ST_TO_ADDR
// sEarthquake := false ;
7929: LD_ADDR_EXP 59
7933: PUSH
7934: LD_INT 0
7936: ST_TO_ADDR
// sAI := false ;
7937: LD_ADDR_EXP 60
7941: PUSH
7942: LD_INT 0
7944: ST_TO_ADDR
// sCargo := false ;
7945: LD_ADDR_EXP 63
7949: PUSH
7950: LD_INT 0
7952: ST_TO_ADDR
// sDLaser := false ;
7953: LD_ADDR_EXP 64
7957: PUSH
7958: LD_INT 0
7960: ST_TO_ADDR
// sExchange := false ;
7961: LD_ADDR_EXP 65
7965: PUSH
7966: LD_INT 0
7968: ST_TO_ADDR
// sFac := false ;
7969: LD_ADDR_EXP 66
7973: PUSH
7974: LD_INT 0
7976: ST_TO_ADDR
// sPower := false ;
7977: LD_ADDR_EXP 67
7981: PUSH
7982: LD_INT 0
7984: ST_TO_ADDR
// sRandom := false ;
7985: LD_ADDR_EXP 68
7989: PUSH
7990: LD_INT 0
7992: ST_TO_ADDR
// sShield := false ;
7993: LD_ADDR_EXP 69
7997: PUSH
7998: LD_INT 0
8000: ST_TO_ADDR
// sTime := false ;
8001: LD_ADDR_EXP 70
8005: PUSH
8006: LD_INT 0
8008: ST_TO_ADDR
// sTools := false ;
8009: LD_ADDR_EXP 71
8013: PUSH
8014: LD_INT 0
8016: ST_TO_ADDR
// sSold := false ;
8017: LD_ADDR_EXP 36
8021: PUSH
8022: LD_INT 0
8024: ST_TO_ADDR
// sDiff := false ;
8025: LD_ADDR_EXP 37
8029: PUSH
8030: LD_INT 0
8032: ST_TO_ADDR
// sFog := false ;
8033: LD_ADDR_EXP 40
8037: PUSH
8038: LD_INT 0
8040: ST_TO_ADDR
// sReset := false ;
8041: LD_ADDR_EXP 41
8045: PUSH
8046: LD_INT 0
8048: ST_TO_ADDR
// sSun := false ;
8049: LD_ADDR_EXP 42
8053: PUSH
8054: LD_INT 0
8056: ST_TO_ADDR
// sTiger := false ;
8057: LD_ADDR_EXP 38
8061: PUSH
8062: LD_INT 0
8064: ST_TO_ADDR
// sBomb := false ;
8065: LD_ADDR_EXP 39
8069: PUSH
8070: LD_INT 0
8072: ST_TO_ADDR
// sWound := false ;
8073: LD_ADDR_EXP 47
8077: PUSH
8078: LD_INT 0
8080: ST_TO_ADDR
// sBetray := false ;
8081: LD_ADDR_EXP 51
8085: PUSH
8086: LD_INT 0
8088: ST_TO_ADDR
// sContamin := false ;
8089: LD_ADDR_EXP 52
8093: PUSH
8094: LD_INT 0
8096: ST_TO_ADDR
// sOil := false ;
8097: LD_ADDR_EXP 54
8101: PUSH
8102: LD_INT 0
8104: ST_TO_ADDR
// sStu := false ;
8105: LD_ADDR_EXP 58
8109: PUSH
8110: LD_INT 0
8112: ST_TO_ADDR
// sBazooka := false ;
8113: LD_ADDR_EXP 61
8117: PUSH
8118: LD_INT 0
8120: ST_TO_ADDR
// sMortar := false ;
8121: LD_ADDR_EXP 62
8125: PUSH
8126: LD_INT 0
8128: ST_TO_ADDR
// sRanger := false ;
8129: LD_ADDR_EXP 72
8133: PUSH
8134: LD_INT 0
8136: ST_TO_ADDR
// end ;
8137: LD_VAR 0 1
8141: RET
// function DefineStreamItems ( ) ; var tmp , normal , hardcore , i ; begin
8142: LD_INT 0
8144: PPUSH
8145: PPUSH
8146: PPUSH
8147: PPUSH
8148: PPUSH
// result := [ ] ;
8149: LD_ADDR_VAR 0 1
8153: PUSH
8154: EMPTY
8155: ST_TO_ADDR
// if campaign_id = 1 then
8156: LD_OWVAR 69
8160: PUSH
8161: LD_INT 1
8163: EQUAL
8164: IFFALSE 11100
// begin case mission_number of 1 :
8166: LD_OWVAR 70
8170: PUSH
8171: LD_INT 1
8173: DOUBLE
8174: EQUAL
8175: IFTRUE 8179
8177: GO 8243
8179: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 ] ] ; 2 :
8180: LD_ADDR_VAR 0 1
8184: PUSH
8185: LD_INT 2
8187: PUSH
8188: LD_INT 4
8190: PUSH
8191: LD_INT 11
8193: PUSH
8194: LD_INT 12
8196: PUSH
8197: LD_INT 15
8199: PUSH
8200: LD_INT 16
8202: PUSH
8203: LD_INT 22
8205: PUSH
8206: LD_INT 23
8208: PUSH
8209: LD_INT 26
8211: PUSH
8212: EMPTY
8213: LIST
8214: LIST
8215: LIST
8216: LIST
8217: LIST
8218: LIST
8219: LIST
8220: LIST
8221: LIST
8222: PUSH
8223: LD_INT 101
8225: PUSH
8226: LD_INT 102
8228: PUSH
8229: LD_INT 106
8231: PUSH
8232: EMPTY
8233: LIST
8234: LIST
8235: LIST
8236: PUSH
8237: EMPTY
8238: LIST
8239: LIST
8240: ST_TO_ADDR
8241: GO 11100
8243: LD_INT 2
8245: DOUBLE
8246: EQUAL
8247: IFTRUE 8251
8249: GO 8323
8251: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 3 :
8252: LD_ADDR_VAR 0 1
8256: PUSH
8257: LD_INT 2
8259: PUSH
8260: LD_INT 4
8262: PUSH
8263: LD_INT 11
8265: PUSH
8266: LD_INT 12
8268: PUSH
8269: LD_INT 15
8271: PUSH
8272: LD_INT 16
8274: PUSH
8275: LD_INT 22
8277: PUSH
8278: LD_INT 23
8280: PUSH
8281: LD_INT 26
8283: PUSH
8284: EMPTY
8285: LIST
8286: LIST
8287: LIST
8288: LIST
8289: LIST
8290: LIST
8291: LIST
8292: LIST
8293: LIST
8294: PUSH
8295: LD_INT 101
8297: PUSH
8298: LD_INT 102
8300: PUSH
8301: LD_INT 105
8303: PUSH
8304: LD_INT 106
8306: PUSH
8307: LD_INT 108
8309: PUSH
8310: EMPTY
8311: LIST
8312: LIST
8313: LIST
8314: LIST
8315: LIST
8316: PUSH
8317: EMPTY
8318: LIST
8319: LIST
8320: ST_TO_ADDR
8321: GO 11100
8323: LD_INT 3
8325: DOUBLE
8326: EQUAL
8327: IFTRUE 8331
8329: GO 8407
8331: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 4 :
8332: LD_ADDR_VAR 0 1
8336: PUSH
8337: LD_INT 2
8339: PUSH
8340: LD_INT 4
8342: PUSH
8343: LD_INT 5
8345: PUSH
8346: LD_INT 11
8348: PUSH
8349: LD_INT 12
8351: PUSH
8352: LD_INT 15
8354: PUSH
8355: LD_INT 16
8357: PUSH
8358: LD_INT 22
8360: PUSH
8361: LD_INT 26
8363: PUSH
8364: LD_INT 36
8366: PUSH
8367: EMPTY
8368: LIST
8369: LIST
8370: LIST
8371: LIST
8372: LIST
8373: LIST
8374: LIST
8375: LIST
8376: LIST
8377: LIST
8378: PUSH
8379: LD_INT 101
8381: PUSH
8382: LD_INT 102
8384: PUSH
8385: LD_INT 105
8387: PUSH
8388: LD_INT 106
8390: PUSH
8391: LD_INT 108
8393: PUSH
8394: EMPTY
8395: LIST
8396: LIST
8397: LIST
8398: LIST
8399: LIST
8400: PUSH
8401: EMPTY
8402: LIST
8403: LIST
8404: ST_TO_ADDR
8405: GO 11100
8407: LD_INT 4
8409: DOUBLE
8410: EQUAL
8411: IFTRUE 8415
8413: GO 8499
8415: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 5 :
8416: LD_ADDR_VAR 0 1
8420: PUSH
8421: LD_INT 2
8423: PUSH
8424: LD_INT 4
8426: PUSH
8427: LD_INT 5
8429: PUSH
8430: LD_INT 8
8432: PUSH
8433: LD_INT 11
8435: PUSH
8436: LD_INT 12
8438: PUSH
8439: LD_INT 15
8441: PUSH
8442: LD_INT 16
8444: PUSH
8445: LD_INT 22
8447: PUSH
8448: LD_INT 23
8450: PUSH
8451: LD_INT 26
8453: PUSH
8454: LD_INT 36
8456: PUSH
8457: EMPTY
8458: LIST
8459: LIST
8460: LIST
8461: LIST
8462: LIST
8463: LIST
8464: LIST
8465: LIST
8466: LIST
8467: LIST
8468: LIST
8469: LIST
8470: PUSH
8471: LD_INT 101
8473: PUSH
8474: LD_INT 102
8476: PUSH
8477: LD_INT 105
8479: PUSH
8480: LD_INT 106
8482: PUSH
8483: LD_INT 108
8485: PUSH
8486: EMPTY
8487: LIST
8488: LIST
8489: LIST
8490: LIST
8491: LIST
8492: PUSH
8493: EMPTY
8494: LIST
8495: LIST
8496: ST_TO_ADDR
8497: GO 11100
8499: LD_INT 5
8501: DOUBLE
8502: EQUAL
8503: IFTRUE 8507
8505: GO 8607
8507: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 6 :
8508: LD_ADDR_VAR 0 1
8512: PUSH
8513: LD_INT 2
8515: PUSH
8516: LD_INT 4
8518: PUSH
8519: LD_INT 5
8521: PUSH
8522: LD_INT 6
8524: PUSH
8525: LD_INT 8
8527: PUSH
8528: LD_INT 11
8530: PUSH
8531: LD_INT 12
8533: PUSH
8534: LD_INT 15
8536: PUSH
8537: LD_INT 16
8539: PUSH
8540: LD_INT 22
8542: PUSH
8543: LD_INT 23
8545: PUSH
8546: LD_INT 25
8548: PUSH
8549: LD_INT 26
8551: PUSH
8552: LD_INT 36
8554: PUSH
8555: EMPTY
8556: LIST
8557: LIST
8558: LIST
8559: LIST
8560: LIST
8561: LIST
8562: LIST
8563: LIST
8564: LIST
8565: LIST
8566: LIST
8567: LIST
8568: LIST
8569: LIST
8570: PUSH
8571: LD_INT 101
8573: PUSH
8574: LD_INT 102
8576: PUSH
8577: LD_INT 105
8579: PUSH
8580: LD_INT 106
8582: PUSH
8583: LD_INT 108
8585: PUSH
8586: LD_INT 109
8588: PUSH
8589: LD_INT 112
8591: PUSH
8592: EMPTY
8593: LIST
8594: LIST
8595: LIST
8596: LIST
8597: LIST
8598: LIST
8599: LIST
8600: PUSH
8601: EMPTY
8602: LIST
8603: LIST
8604: ST_TO_ADDR
8605: GO 11100
8607: LD_INT 6
8609: DOUBLE
8610: EQUAL
8611: IFTRUE 8615
8613: GO 8735
8615: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 7 :
8616: LD_ADDR_VAR 0 1
8620: PUSH
8621: LD_INT 2
8623: PUSH
8624: LD_INT 4
8626: PUSH
8627: LD_INT 5
8629: PUSH
8630: LD_INT 6
8632: PUSH
8633: LD_INT 8
8635: PUSH
8636: LD_INT 11
8638: PUSH
8639: LD_INT 12
8641: PUSH
8642: LD_INT 15
8644: PUSH
8645: LD_INT 16
8647: PUSH
8648: LD_INT 20
8650: PUSH
8651: LD_INT 21
8653: PUSH
8654: LD_INT 22
8656: PUSH
8657: LD_INT 23
8659: PUSH
8660: LD_INT 25
8662: PUSH
8663: LD_INT 26
8665: PUSH
8666: LD_INT 30
8668: PUSH
8669: LD_INT 31
8671: PUSH
8672: LD_INT 32
8674: PUSH
8675: LD_INT 36
8677: PUSH
8678: EMPTY
8679: LIST
8680: LIST
8681: LIST
8682: LIST
8683: LIST
8684: LIST
8685: LIST
8686: LIST
8687: LIST
8688: LIST
8689: LIST
8690: LIST
8691: LIST
8692: LIST
8693: LIST
8694: LIST
8695: LIST
8696: LIST
8697: LIST
8698: PUSH
8699: LD_INT 101
8701: PUSH
8702: LD_INT 102
8704: PUSH
8705: LD_INT 105
8707: PUSH
8708: LD_INT 106
8710: PUSH
8711: LD_INT 108
8713: PUSH
8714: LD_INT 109
8716: PUSH
8717: LD_INT 112
8719: PUSH
8720: EMPTY
8721: LIST
8722: LIST
8723: LIST
8724: LIST
8725: LIST
8726: LIST
8727: LIST
8728: PUSH
8729: EMPTY
8730: LIST
8731: LIST
8732: ST_TO_ADDR
8733: GO 11100
8735: LD_INT 7
8737: DOUBLE
8738: EQUAL
8739: IFTRUE 8743
8741: GO 8843
8743: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 ] ] ; 8 :
8744: LD_ADDR_VAR 0 1
8748: PUSH
8749: LD_INT 2
8751: PUSH
8752: LD_INT 4
8754: PUSH
8755: LD_INT 5
8757: PUSH
8758: LD_INT 7
8760: PUSH
8761: LD_INT 11
8763: PUSH
8764: LD_INT 12
8766: PUSH
8767: LD_INT 15
8769: PUSH
8770: LD_INT 16
8772: PUSH
8773: LD_INT 20
8775: PUSH
8776: LD_INT 21
8778: PUSH
8779: LD_INT 22
8781: PUSH
8782: LD_INT 23
8784: PUSH
8785: LD_INT 25
8787: PUSH
8788: LD_INT 26
8790: PUSH
8791: EMPTY
8792: LIST
8793: LIST
8794: LIST
8795: LIST
8796: LIST
8797: LIST
8798: LIST
8799: LIST
8800: LIST
8801: LIST
8802: LIST
8803: LIST
8804: LIST
8805: LIST
8806: PUSH
8807: LD_INT 101
8809: PUSH
8810: LD_INT 102
8812: PUSH
8813: LD_INT 103
8815: PUSH
8816: LD_INT 105
8818: PUSH
8819: LD_INT 106
8821: PUSH
8822: LD_INT 108
8824: PUSH
8825: LD_INT 112
8827: PUSH
8828: EMPTY
8829: LIST
8830: LIST
8831: LIST
8832: LIST
8833: LIST
8834: LIST
8835: LIST
8836: PUSH
8837: EMPTY
8838: LIST
8839: LIST
8840: ST_TO_ADDR
8841: GO 11100
8843: LD_INT 8
8845: DOUBLE
8846: EQUAL
8847: IFTRUE 8851
8849: GO 8979
8851: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 ] ] ; 9 :
8852: LD_ADDR_VAR 0 1
8856: PUSH
8857: LD_INT 2
8859: PUSH
8860: LD_INT 4
8862: PUSH
8863: LD_INT 5
8865: PUSH
8866: LD_INT 6
8868: PUSH
8869: LD_INT 7
8871: PUSH
8872: LD_INT 8
8874: PUSH
8875: LD_INT 11
8877: PUSH
8878: LD_INT 12
8880: PUSH
8881: LD_INT 15
8883: PUSH
8884: LD_INT 16
8886: PUSH
8887: LD_INT 20
8889: PUSH
8890: LD_INT 21
8892: PUSH
8893: LD_INT 22
8895: PUSH
8896: LD_INT 23
8898: PUSH
8899: LD_INT 25
8901: PUSH
8902: LD_INT 26
8904: PUSH
8905: LD_INT 30
8907: PUSH
8908: LD_INT 31
8910: PUSH
8911: LD_INT 32
8913: PUSH
8914: LD_INT 36
8916: PUSH
8917: EMPTY
8918: LIST
8919: LIST
8920: LIST
8921: LIST
8922: LIST
8923: LIST
8924: LIST
8925: LIST
8926: LIST
8927: LIST
8928: LIST
8929: LIST
8930: LIST
8931: LIST
8932: LIST
8933: LIST
8934: LIST
8935: LIST
8936: LIST
8937: LIST
8938: PUSH
8939: LD_INT 101
8941: PUSH
8942: LD_INT 102
8944: PUSH
8945: LD_INT 103
8947: PUSH
8948: LD_INT 105
8950: PUSH
8951: LD_INT 106
8953: PUSH
8954: LD_INT 108
8956: PUSH
8957: LD_INT 109
8959: PUSH
8960: LD_INT 112
8962: PUSH
8963: EMPTY
8964: LIST
8965: LIST
8966: LIST
8967: LIST
8968: LIST
8969: LIST
8970: LIST
8971: LIST
8972: PUSH
8973: EMPTY
8974: LIST
8975: LIST
8976: ST_TO_ADDR
8977: GO 11100
8979: LD_INT 9
8981: DOUBLE
8982: EQUAL
8983: IFTRUE 8987
8985: GO 9123
8987: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 ] ] ; 10 :
8988: LD_ADDR_VAR 0 1
8992: PUSH
8993: LD_INT 2
8995: PUSH
8996: LD_INT 4
8998: PUSH
8999: LD_INT 5
9001: PUSH
9002: LD_INT 6
9004: PUSH
9005: LD_INT 7
9007: PUSH
9008: LD_INT 8
9010: PUSH
9011: LD_INT 11
9013: PUSH
9014: LD_INT 12
9016: PUSH
9017: LD_INT 15
9019: PUSH
9020: LD_INT 16
9022: PUSH
9023: LD_INT 20
9025: PUSH
9026: LD_INT 21
9028: PUSH
9029: LD_INT 22
9031: PUSH
9032: LD_INT 23
9034: PUSH
9035: LD_INT 25
9037: PUSH
9038: LD_INT 26
9040: PUSH
9041: LD_INT 28
9043: PUSH
9044: LD_INT 30
9046: PUSH
9047: LD_INT 31
9049: PUSH
9050: LD_INT 32
9052: PUSH
9053: LD_INT 36
9055: PUSH
9056: EMPTY
9057: LIST
9058: LIST
9059: LIST
9060: LIST
9061: LIST
9062: LIST
9063: LIST
9064: LIST
9065: LIST
9066: LIST
9067: LIST
9068: LIST
9069: LIST
9070: LIST
9071: LIST
9072: LIST
9073: LIST
9074: LIST
9075: LIST
9076: LIST
9077: LIST
9078: PUSH
9079: LD_INT 101
9081: PUSH
9082: LD_INT 102
9084: PUSH
9085: LD_INT 103
9087: PUSH
9088: LD_INT 105
9090: PUSH
9091: LD_INT 106
9093: PUSH
9094: LD_INT 108
9096: PUSH
9097: LD_INT 109
9099: PUSH
9100: LD_INT 112
9102: PUSH
9103: LD_INT 114
9105: PUSH
9106: EMPTY
9107: LIST
9108: LIST
9109: LIST
9110: LIST
9111: LIST
9112: LIST
9113: LIST
9114: LIST
9115: LIST
9116: PUSH
9117: EMPTY
9118: LIST
9119: LIST
9120: ST_TO_ADDR
9121: GO 11100
9123: LD_INT 10
9125: DOUBLE
9126: EQUAL
9127: IFTRUE 9131
9129: GO 9315
9131: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 11 :
9132: LD_ADDR_VAR 0 1
9136: PUSH
9137: LD_INT 2
9139: PUSH
9140: LD_INT 4
9142: PUSH
9143: LD_INT 5
9145: PUSH
9146: LD_INT 6
9148: PUSH
9149: LD_INT 7
9151: PUSH
9152: LD_INT 8
9154: PUSH
9155: LD_INT 9
9157: PUSH
9158: LD_INT 10
9160: PUSH
9161: LD_INT 11
9163: PUSH
9164: LD_INT 12
9166: PUSH
9167: LD_INT 13
9169: PUSH
9170: LD_INT 14
9172: PUSH
9173: LD_INT 15
9175: PUSH
9176: LD_INT 16
9178: PUSH
9179: LD_INT 17
9181: PUSH
9182: LD_INT 18
9184: PUSH
9185: LD_INT 19
9187: PUSH
9188: LD_INT 20
9190: PUSH
9191: LD_INT 21
9193: PUSH
9194: LD_INT 22
9196: PUSH
9197: LD_INT 23
9199: PUSH
9200: LD_INT 24
9202: PUSH
9203: LD_INT 25
9205: PUSH
9206: LD_INT 26
9208: PUSH
9209: LD_INT 28
9211: PUSH
9212: LD_INT 30
9214: PUSH
9215: LD_INT 31
9217: PUSH
9218: LD_INT 32
9220: PUSH
9221: LD_INT 36
9223: PUSH
9224: EMPTY
9225: LIST
9226: LIST
9227: LIST
9228: LIST
9229: LIST
9230: LIST
9231: LIST
9232: LIST
9233: LIST
9234: LIST
9235: LIST
9236: LIST
9237: LIST
9238: LIST
9239: LIST
9240: LIST
9241: LIST
9242: LIST
9243: LIST
9244: LIST
9245: LIST
9246: LIST
9247: LIST
9248: LIST
9249: LIST
9250: LIST
9251: LIST
9252: LIST
9253: LIST
9254: PUSH
9255: LD_INT 101
9257: PUSH
9258: LD_INT 102
9260: PUSH
9261: LD_INT 103
9263: PUSH
9264: LD_INT 104
9266: PUSH
9267: LD_INT 105
9269: PUSH
9270: LD_INT 106
9272: PUSH
9273: LD_INT 107
9275: PUSH
9276: LD_INT 108
9278: PUSH
9279: LD_INT 109
9281: PUSH
9282: LD_INT 110
9284: PUSH
9285: LD_INT 111
9287: PUSH
9288: LD_INT 112
9290: PUSH
9291: LD_INT 114
9293: PUSH
9294: EMPTY
9295: LIST
9296: LIST
9297: LIST
9298: LIST
9299: LIST
9300: LIST
9301: LIST
9302: LIST
9303: LIST
9304: LIST
9305: LIST
9306: LIST
9307: LIST
9308: PUSH
9309: EMPTY
9310: LIST
9311: LIST
9312: ST_TO_ADDR
9313: GO 11100
9315: LD_INT 11
9317: DOUBLE
9318: EQUAL
9319: IFTRUE 9323
9321: GO 9515
9323: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 12 :
9324: LD_ADDR_VAR 0 1
9328: PUSH
9329: LD_INT 2
9331: PUSH
9332: LD_INT 3
9334: PUSH
9335: LD_INT 4
9337: PUSH
9338: LD_INT 5
9340: PUSH
9341: LD_INT 6
9343: PUSH
9344: LD_INT 7
9346: PUSH
9347: LD_INT 8
9349: PUSH
9350: LD_INT 9
9352: PUSH
9353: LD_INT 10
9355: PUSH
9356: LD_INT 11
9358: PUSH
9359: LD_INT 12
9361: PUSH
9362: LD_INT 13
9364: PUSH
9365: LD_INT 14
9367: PUSH
9368: LD_INT 15
9370: PUSH
9371: LD_INT 16
9373: PUSH
9374: LD_INT 17
9376: PUSH
9377: LD_INT 18
9379: PUSH
9380: LD_INT 19
9382: PUSH
9383: LD_INT 20
9385: PUSH
9386: LD_INT 21
9388: PUSH
9389: LD_INT 22
9391: PUSH
9392: LD_INT 23
9394: PUSH
9395: LD_INT 24
9397: PUSH
9398: LD_INT 25
9400: PUSH
9401: LD_INT 26
9403: PUSH
9404: LD_INT 28
9406: PUSH
9407: LD_INT 30
9409: PUSH
9410: LD_INT 31
9412: PUSH
9413: LD_INT 32
9415: PUSH
9416: LD_INT 34
9418: PUSH
9419: LD_INT 36
9421: PUSH
9422: EMPTY
9423: LIST
9424: LIST
9425: LIST
9426: LIST
9427: LIST
9428: LIST
9429: LIST
9430: LIST
9431: LIST
9432: LIST
9433: LIST
9434: LIST
9435: LIST
9436: LIST
9437: LIST
9438: LIST
9439: LIST
9440: LIST
9441: LIST
9442: LIST
9443: LIST
9444: LIST
9445: LIST
9446: LIST
9447: LIST
9448: LIST
9449: LIST
9450: LIST
9451: LIST
9452: LIST
9453: LIST
9454: PUSH
9455: LD_INT 101
9457: PUSH
9458: LD_INT 102
9460: PUSH
9461: LD_INT 103
9463: PUSH
9464: LD_INT 104
9466: PUSH
9467: LD_INT 105
9469: PUSH
9470: LD_INT 106
9472: PUSH
9473: LD_INT 107
9475: PUSH
9476: LD_INT 108
9478: PUSH
9479: LD_INT 109
9481: PUSH
9482: LD_INT 110
9484: PUSH
9485: LD_INT 111
9487: PUSH
9488: LD_INT 112
9490: PUSH
9491: LD_INT 114
9493: PUSH
9494: EMPTY
9495: LIST
9496: LIST
9497: LIST
9498: LIST
9499: LIST
9500: LIST
9501: LIST
9502: LIST
9503: LIST
9504: LIST
9505: LIST
9506: LIST
9507: LIST
9508: PUSH
9509: EMPTY
9510: LIST
9511: LIST
9512: ST_TO_ADDR
9513: GO 11100
9515: LD_INT 12
9517: DOUBLE
9518: EQUAL
9519: IFTRUE 9523
9521: GO 9731
9523: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 13 :
9524: LD_ADDR_VAR 0 1
9528: PUSH
9529: LD_INT 1
9531: PUSH
9532: LD_INT 2
9534: PUSH
9535: LD_INT 3
9537: PUSH
9538: LD_INT 4
9540: PUSH
9541: LD_INT 5
9543: PUSH
9544: LD_INT 6
9546: PUSH
9547: LD_INT 7
9549: PUSH
9550: LD_INT 8
9552: PUSH
9553: LD_INT 9
9555: PUSH
9556: LD_INT 10
9558: PUSH
9559: LD_INT 11
9561: PUSH
9562: LD_INT 12
9564: PUSH
9565: LD_INT 13
9567: PUSH
9568: LD_INT 14
9570: PUSH
9571: LD_INT 15
9573: PUSH
9574: LD_INT 16
9576: PUSH
9577: LD_INT 17
9579: PUSH
9580: LD_INT 18
9582: PUSH
9583: LD_INT 19
9585: PUSH
9586: LD_INT 20
9588: PUSH
9589: LD_INT 21
9591: PUSH
9592: LD_INT 22
9594: PUSH
9595: LD_INT 23
9597: PUSH
9598: LD_INT 24
9600: PUSH
9601: LD_INT 25
9603: PUSH
9604: LD_INT 26
9606: PUSH
9607: LD_INT 27
9609: PUSH
9610: LD_INT 28
9612: PUSH
9613: LD_INT 30
9615: PUSH
9616: LD_INT 31
9618: PUSH
9619: LD_INT 32
9621: PUSH
9622: LD_INT 33
9624: PUSH
9625: LD_INT 34
9627: PUSH
9628: LD_INT 36
9630: PUSH
9631: EMPTY
9632: LIST
9633: LIST
9634: LIST
9635: LIST
9636: LIST
9637: LIST
9638: LIST
9639: LIST
9640: LIST
9641: LIST
9642: LIST
9643: LIST
9644: LIST
9645: LIST
9646: LIST
9647: LIST
9648: LIST
9649: LIST
9650: LIST
9651: LIST
9652: LIST
9653: LIST
9654: LIST
9655: LIST
9656: LIST
9657: LIST
9658: LIST
9659: LIST
9660: LIST
9661: LIST
9662: LIST
9663: LIST
9664: LIST
9665: LIST
9666: PUSH
9667: LD_INT 101
9669: PUSH
9670: LD_INT 102
9672: PUSH
9673: LD_INT 103
9675: PUSH
9676: LD_INT 104
9678: PUSH
9679: LD_INT 105
9681: PUSH
9682: LD_INT 106
9684: PUSH
9685: LD_INT 107
9687: PUSH
9688: LD_INT 108
9690: PUSH
9691: LD_INT 109
9693: PUSH
9694: LD_INT 110
9696: PUSH
9697: LD_INT 111
9699: PUSH
9700: LD_INT 112
9702: PUSH
9703: LD_INT 113
9705: PUSH
9706: LD_INT 114
9708: PUSH
9709: EMPTY
9710: LIST
9711: LIST
9712: LIST
9713: LIST
9714: LIST
9715: LIST
9716: LIST
9717: LIST
9718: LIST
9719: LIST
9720: LIST
9721: LIST
9722: LIST
9723: LIST
9724: PUSH
9725: EMPTY
9726: LIST
9727: LIST
9728: ST_TO_ADDR
9729: GO 11100
9731: LD_INT 13
9733: DOUBLE
9734: EQUAL
9735: IFTRUE 9739
9737: GO 9935
9739: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 14 :
9740: LD_ADDR_VAR 0 1
9744: PUSH
9745: LD_INT 1
9747: PUSH
9748: LD_INT 2
9750: PUSH
9751: LD_INT 3
9753: PUSH
9754: LD_INT 4
9756: PUSH
9757: LD_INT 5
9759: PUSH
9760: LD_INT 8
9762: PUSH
9763: LD_INT 9
9765: PUSH
9766: LD_INT 10
9768: PUSH
9769: LD_INT 11
9771: PUSH
9772: LD_INT 12
9774: PUSH
9775: LD_INT 14
9777: PUSH
9778: LD_INT 15
9780: PUSH
9781: LD_INT 16
9783: PUSH
9784: LD_INT 17
9786: PUSH
9787: LD_INT 18
9789: PUSH
9790: LD_INT 19
9792: PUSH
9793: LD_INT 20
9795: PUSH
9796: LD_INT 21
9798: PUSH
9799: LD_INT 22
9801: PUSH
9802: LD_INT 23
9804: PUSH
9805: LD_INT 24
9807: PUSH
9808: LD_INT 25
9810: PUSH
9811: LD_INT 26
9813: PUSH
9814: LD_INT 27
9816: PUSH
9817: LD_INT 28
9819: PUSH
9820: LD_INT 30
9822: PUSH
9823: LD_INT 31
9825: PUSH
9826: LD_INT 32
9828: PUSH
9829: LD_INT 33
9831: PUSH
9832: LD_INT 34
9834: PUSH
9835: LD_INT 36
9837: PUSH
9838: EMPTY
9839: LIST
9840: LIST
9841: LIST
9842: LIST
9843: LIST
9844: LIST
9845: LIST
9846: LIST
9847: LIST
9848: LIST
9849: LIST
9850: LIST
9851: LIST
9852: LIST
9853: LIST
9854: LIST
9855: LIST
9856: LIST
9857: LIST
9858: LIST
9859: LIST
9860: LIST
9861: LIST
9862: LIST
9863: LIST
9864: LIST
9865: LIST
9866: LIST
9867: LIST
9868: LIST
9869: LIST
9870: PUSH
9871: LD_INT 101
9873: PUSH
9874: LD_INT 102
9876: PUSH
9877: LD_INT 103
9879: PUSH
9880: LD_INT 104
9882: PUSH
9883: LD_INT 105
9885: PUSH
9886: LD_INT 106
9888: PUSH
9889: LD_INT 107
9891: PUSH
9892: LD_INT 108
9894: PUSH
9895: LD_INT 109
9897: PUSH
9898: LD_INT 110
9900: PUSH
9901: LD_INT 111
9903: PUSH
9904: LD_INT 112
9906: PUSH
9907: LD_INT 113
9909: PUSH
9910: LD_INT 114
9912: PUSH
9913: EMPTY
9914: LIST
9915: LIST
9916: LIST
9917: LIST
9918: LIST
9919: LIST
9920: LIST
9921: LIST
9922: LIST
9923: LIST
9924: LIST
9925: LIST
9926: LIST
9927: LIST
9928: PUSH
9929: EMPTY
9930: LIST
9931: LIST
9932: ST_TO_ADDR
9933: GO 11100
9935: LD_INT 14
9937: DOUBLE
9938: EQUAL
9939: IFTRUE 9943
9941: GO 10155
9943: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 15 :
9944: LD_ADDR_VAR 0 1
9948: PUSH
9949: LD_INT 1
9951: PUSH
9952: LD_INT 2
9954: PUSH
9955: LD_INT 3
9957: PUSH
9958: LD_INT 4
9960: PUSH
9961: LD_INT 5
9963: PUSH
9964: LD_INT 6
9966: PUSH
9967: LD_INT 7
9969: PUSH
9970: LD_INT 8
9972: PUSH
9973: LD_INT 9
9975: PUSH
9976: LD_INT 10
9978: PUSH
9979: LD_INT 11
9981: PUSH
9982: LD_INT 12
9984: PUSH
9985: LD_INT 13
9987: PUSH
9988: LD_INT 14
9990: PUSH
9991: LD_INT 15
9993: PUSH
9994: LD_INT 16
9996: PUSH
9997: LD_INT 17
9999: PUSH
10000: LD_INT 18
10002: PUSH
10003: LD_INT 19
10005: PUSH
10006: LD_INT 20
10008: PUSH
10009: LD_INT 21
10011: PUSH
10012: LD_INT 22
10014: PUSH
10015: LD_INT 23
10017: PUSH
10018: LD_INT 24
10020: PUSH
10021: LD_INT 25
10023: PUSH
10024: LD_INT 26
10026: PUSH
10027: LD_INT 27
10029: PUSH
10030: LD_INT 28
10032: PUSH
10033: LD_INT 29
10035: PUSH
10036: LD_INT 30
10038: PUSH
10039: LD_INT 31
10041: PUSH
10042: LD_INT 32
10044: PUSH
10045: LD_INT 33
10047: PUSH
10048: LD_INT 34
10050: PUSH
10051: LD_INT 36
10053: PUSH
10054: EMPTY
10055: LIST
10056: LIST
10057: LIST
10058: LIST
10059: LIST
10060: LIST
10061: LIST
10062: LIST
10063: LIST
10064: LIST
10065: LIST
10066: LIST
10067: LIST
10068: LIST
10069: LIST
10070: LIST
10071: LIST
10072: LIST
10073: LIST
10074: LIST
10075: LIST
10076: LIST
10077: LIST
10078: LIST
10079: LIST
10080: LIST
10081: LIST
10082: LIST
10083: LIST
10084: LIST
10085: LIST
10086: LIST
10087: LIST
10088: LIST
10089: LIST
10090: PUSH
10091: LD_INT 101
10093: PUSH
10094: LD_INT 102
10096: PUSH
10097: LD_INT 103
10099: PUSH
10100: LD_INT 104
10102: PUSH
10103: LD_INT 105
10105: PUSH
10106: LD_INT 106
10108: PUSH
10109: LD_INT 107
10111: PUSH
10112: LD_INT 108
10114: PUSH
10115: LD_INT 109
10117: PUSH
10118: LD_INT 110
10120: PUSH
10121: LD_INT 111
10123: PUSH
10124: LD_INT 112
10126: PUSH
10127: LD_INT 113
10129: PUSH
10130: LD_INT 114
10132: PUSH
10133: EMPTY
10134: LIST
10135: LIST
10136: LIST
10137: LIST
10138: LIST
10139: LIST
10140: LIST
10141: LIST
10142: LIST
10143: LIST
10144: LIST
10145: LIST
10146: LIST
10147: LIST
10148: PUSH
10149: EMPTY
10150: LIST
10151: LIST
10152: ST_TO_ADDR
10153: GO 11100
10155: LD_INT 15
10157: DOUBLE
10158: EQUAL
10159: IFTRUE 10163
10161: GO 10375
10163: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 16 :
10164: LD_ADDR_VAR 0 1
10168: PUSH
10169: LD_INT 1
10171: PUSH
10172: LD_INT 2
10174: PUSH
10175: LD_INT 3
10177: PUSH
10178: LD_INT 4
10180: PUSH
10181: LD_INT 5
10183: PUSH
10184: LD_INT 6
10186: PUSH
10187: LD_INT 7
10189: PUSH
10190: LD_INT 8
10192: PUSH
10193: LD_INT 9
10195: PUSH
10196: LD_INT 10
10198: PUSH
10199: LD_INT 11
10201: PUSH
10202: LD_INT 12
10204: PUSH
10205: LD_INT 13
10207: PUSH
10208: LD_INT 14
10210: PUSH
10211: LD_INT 15
10213: PUSH
10214: LD_INT 16
10216: PUSH
10217: LD_INT 17
10219: PUSH
10220: LD_INT 18
10222: PUSH
10223: LD_INT 19
10225: PUSH
10226: LD_INT 20
10228: PUSH
10229: LD_INT 21
10231: PUSH
10232: LD_INT 22
10234: PUSH
10235: LD_INT 23
10237: PUSH
10238: LD_INT 24
10240: PUSH
10241: LD_INT 25
10243: PUSH
10244: LD_INT 26
10246: PUSH
10247: LD_INT 27
10249: PUSH
10250: LD_INT 28
10252: PUSH
10253: LD_INT 29
10255: PUSH
10256: LD_INT 30
10258: PUSH
10259: LD_INT 31
10261: PUSH
10262: LD_INT 32
10264: PUSH
10265: LD_INT 33
10267: PUSH
10268: LD_INT 34
10270: PUSH
10271: LD_INT 36
10273: PUSH
10274: EMPTY
10275: LIST
10276: LIST
10277: LIST
10278: LIST
10279: LIST
10280: LIST
10281: LIST
10282: LIST
10283: LIST
10284: LIST
10285: LIST
10286: LIST
10287: LIST
10288: LIST
10289: LIST
10290: LIST
10291: LIST
10292: LIST
10293: LIST
10294: LIST
10295: LIST
10296: LIST
10297: LIST
10298: LIST
10299: LIST
10300: LIST
10301: LIST
10302: LIST
10303: LIST
10304: LIST
10305: LIST
10306: LIST
10307: LIST
10308: LIST
10309: LIST
10310: PUSH
10311: LD_INT 101
10313: PUSH
10314: LD_INT 102
10316: PUSH
10317: LD_INT 103
10319: PUSH
10320: LD_INT 104
10322: PUSH
10323: LD_INT 105
10325: PUSH
10326: LD_INT 106
10328: PUSH
10329: LD_INT 107
10331: PUSH
10332: LD_INT 108
10334: PUSH
10335: LD_INT 109
10337: PUSH
10338: LD_INT 110
10340: PUSH
10341: LD_INT 111
10343: PUSH
10344: LD_INT 112
10346: PUSH
10347: LD_INT 113
10349: PUSH
10350: LD_INT 114
10352: PUSH
10353: EMPTY
10354: LIST
10355: LIST
10356: LIST
10357: LIST
10358: LIST
10359: LIST
10360: LIST
10361: LIST
10362: LIST
10363: LIST
10364: LIST
10365: LIST
10366: LIST
10367: LIST
10368: PUSH
10369: EMPTY
10370: LIST
10371: LIST
10372: ST_TO_ADDR
10373: GO 11100
10375: LD_INT 16
10377: DOUBLE
10378: EQUAL
10379: IFTRUE 10383
10381: GO 10507
10383: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 ] ] ; 17 :
10384: LD_ADDR_VAR 0 1
10388: PUSH
10389: LD_INT 2
10391: PUSH
10392: LD_INT 4
10394: PUSH
10395: LD_INT 5
10397: PUSH
10398: LD_INT 7
10400: PUSH
10401: LD_INT 11
10403: PUSH
10404: LD_INT 12
10406: PUSH
10407: LD_INT 15
10409: PUSH
10410: LD_INT 16
10412: PUSH
10413: LD_INT 20
10415: PUSH
10416: LD_INT 21
10418: PUSH
10419: LD_INT 22
10421: PUSH
10422: LD_INT 23
10424: PUSH
10425: LD_INT 25
10427: PUSH
10428: LD_INT 26
10430: PUSH
10431: LD_INT 30
10433: PUSH
10434: LD_INT 31
10436: PUSH
10437: LD_INT 32
10439: PUSH
10440: LD_INT 33
10442: PUSH
10443: LD_INT 34
10445: PUSH
10446: EMPTY
10447: LIST
10448: LIST
10449: LIST
10450: LIST
10451: LIST
10452: LIST
10453: LIST
10454: LIST
10455: LIST
10456: LIST
10457: LIST
10458: LIST
10459: LIST
10460: LIST
10461: LIST
10462: LIST
10463: LIST
10464: LIST
10465: LIST
10466: PUSH
10467: LD_INT 101
10469: PUSH
10470: LD_INT 102
10472: PUSH
10473: LD_INT 103
10475: PUSH
10476: LD_INT 106
10478: PUSH
10479: LD_INT 108
10481: PUSH
10482: LD_INT 112
10484: PUSH
10485: LD_INT 113
10487: PUSH
10488: LD_INT 114
10490: PUSH
10491: EMPTY
10492: LIST
10493: LIST
10494: LIST
10495: LIST
10496: LIST
10497: LIST
10498: LIST
10499: LIST
10500: PUSH
10501: EMPTY
10502: LIST
10503: LIST
10504: ST_TO_ADDR
10505: GO 11100
10507: LD_INT 17
10509: DOUBLE
10510: EQUAL
10511: IFTRUE 10515
10513: GO 10727
10515: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 18 :
10516: LD_ADDR_VAR 0 1
10520: PUSH
10521: LD_INT 1
10523: PUSH
10524: LD_INT 2
10526: PUSH
10527: LD_INT 3
10529: PUSH
10530: LD_INT 4
10532: PUSH
10533: LD_INT 5
10535: PUSH
10536: LD_INT 6
10538: PUSH
10539: LD_INT 7
10541: PUSH
10542: LD_INT 8
10544: PUSH
10545: LD_INT 9
10547: PUSH
10548: LD_INT 10
10550: PUSH
10551: LD_INT 11
10553: PUSH
10554: LD_INT 12
10556: PUSH
10557: LD_INT 13
10559: PUSH
10560: LD_INT 14
10562: PUSH
10563: LD_INT 15
10565: PUSH
10566: LD_INT 16
10568: PUSH
10569: LD_INT 17
10571: PUSH
10572: LD_INT 18
10574: PUSH
10575: LD_INT 19
10577: PUSH
10578: LD_INT 20
10580: PUSH
10581: LD_INT 21
10583: PUSH
10584: LD_INT 22
10586: PUSH
10587: LD_INT 23
10589: PUSH
10590: LD_INT 24
10592: PUSH
10593: LD_INT 25
10595: PUSH
10596: LD_INT 26
10598: PUSH
10599: LD_INT 27
10601: PUSH
10602: LD_INT 28
10604: PUSH
10605: LD_INT 29
10607: PUSH
10608: LD_INT 30
10610: PUSH
10611: LD_INT 31
10613: PUSH
10614: LD_INT 32
10616: PUSH
10617: LD_INT 33
10619: PUSH
10620: LD_INT 34
10622: PUSH
10623: LD_INT 36
10625: PUSH
10626: EMPTY
10627: LIST
10628: LIST
10629: LIST
10630: LIST
10631: LIST
10632: LIST
10633: LIST
10634: LIST
10635: LIST
10636: LIST
10637: LIST
10638: LIST
10639: LIST
10640: LIST
10641: LIST
10642: LIST
10643: LIST
10644: LIST
10645: LIST
10646: LIST
10647: LIST
10648: LIST
10649: LIST
10650: LIST
10651: LIST
10652: LIST
10653: LIST
10654: LIST
10655: LIST
10656: LIST
10657: LIST
10658: LIST
10659: LIST
10660: LIST
10661: LIST
10662: PUSH
10663: LD_INT 101
10665: PUSH
10666: LD_INT 102
10668: PUSH
10669: LD_INT 103
10671: PUSH
10672: LD_INT 104
10674: PUSH
10675: LD_INT 105
10677: PUSH
10678: LD_INT 106
10680: PUSH
10681: LD_INT 107
10683: PUSH
10684: LD_INT 108
10686: PUSH
10687: LD_INT 109
10689: PUSH
10690: LD_INT 110
10692: PUSH
10693: LD_INT 111
10695: PUSH
10696: LD_INT 112
10698: PUSH
10699: LD_INT 113
10701: PUSH
10702: LD_INT 114
10704: PUSH
10705: EMPTY
10706: LIST
10707: LIST
10708: LIST
10709: LIST
10710: LIST
10711: LIST
10712: LIST
10713: LIST
10714: LIST
10715: LIST
10716: LIST
10717: LIST
10718: LIST
10719: LIST
10720: PUSH
10721: EMPTY
10722: LIST
10723: LIST
10724: ST_TO_ADDR
10725: GO 11100
10727: LD_INT 18
10729: DOUBLE
10730: EQUAL
10731: IFTRUE 10735
10733: GO 10871
10735: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 ] ] ; 19 :
10736: LD_ADDR_VAR 0 1
10740: PUSH
10741: LD_INT 2
10743: PUSH
10744: LD_INT 4
10746: PUSH
10747: LD_INT 5
10749: PUSH
10750: LD_INT 7
10752: PUSH
10753: LD_INT 11
10755: PUSH
10756: LD_INT 12
10758: PUSH
10759: LD_INT 15
10761: PUSH
10762: LD_INT 16
10764: PUSH
10765: LD_INT 20
10767: PUSH
10768: LD_INT 21
10770: PUSH
10771: LD_INT 22
10773: PUSH
10774: LD_INT 23
10776: PUSH
10777: LD_INT 25
10779: PUSH
10780: LD_INT 26
10782: PUSH
10783: LD_INT 30
10785: PUSH
10786: LD_INT 31
10788: PUSH
10789: LD_INT 32
10791: PUSH
10792: LD_INT 33
10794: PUSH
10795: LD_INT 34
10797: PUSH
10798: LD_INT 35
10800: PUSH
10801: LD_INT 36
10803: PUSH
10804: EMPTY
10805: LIST
10806: LIST
10807: LIST
10808: LIST
10809: LIST
10810: LIST
10811: LIST
10812: LIST
10813: LIST
10814: LIST
10815: LIST
10816: LIST
10817: LIST
10818: LIST
10819: LIST
10820: LIST
10821: LIST
10822: LIST
10823: LIST
10824: LIST
10825: LIST
10826: PUSH
10827: LD_INT 101
10829: PUSH
10830: LD_INT 102
10832: PUSH
10833: LD_INT 103
10835: PUSH
10836: LD_INT 106
10838: PUSH
10839: LD_INT 108
10841: PUSH
10842: LD_INT 112
10844: PUSH
10845: LD_INT 113
10847: PUSH
10848: LD_INT 114
10850: PUSH
10851: LD_INT 115
10853: PUSH
10854: EMPTY
10855: LIST
10856: LIST
10857: LIST
10858: LIST
10859: LIST
10860: LIST
10861: LIST
10862: LIST
10863: LIST
10864: PUSH
10865: EMPTY
10866: LIST
10867: LIST
10868: ST_TO_ADDR
10869: GO 11100
10871: LD_INT 19
10873: DOUBLE
10874: EQUAL
10875: IFTRUE 10879
10877: GO 11099
10879: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ; end ;
10880: LD_ADDR_VAR 0 1
10884: PUSH
10885: LD_INT 1
10887: PUSH
10888: LD_INT 2
10890: PUSH
10891: LD_INT 3
10893: PUSH
10894: LD_INT 4
10896: PUSH
10897: LD_INT 5
10899: PUSH
10900: LD_INT 6
10902: PUSH
10903: LD_INT 7
10905: PUSH
10906: LD_INT 8
10908: PUSH
10909: LD_INT 9
10911: PUSH
10912: LD_INT 10
10914: PUSH
10915: LD_INT 11
10917: PUSH
10918: LD_INT 12
10920: PUSH
10921: LD_INT 13
10923: PUSH
10924: LD_INT 14
10926: PUSH
10927: LD_INT 15
10929: PUSH
10930: LD_INT 16
10932: PUSH
10933: LD_INT 17
10935: PUSH
10936: LD_INT 18
10938: PUSH
10939: LD_INT 19
10941: PUSH
10942: LD_INT 20
10944: PUSH
10945: LD_INT 21
10947: PUSH
10948: LD_INT 22
10950: PUSH
10951: LD_INT 23
10953: PUSH
10954: LD_INT 24
10956: PUSH
10957: LD_INT 25
10959: PUSH
10960: LD_INT 26
10962: PUSH
10963: LD_INT 27
10965: PUSH
10966: LD_INT 28
10968: PUSH
10969: LD_INT 29
10971: PUSH
10972: LD_INT 30
10974: PUSH
10975: LD_INT 31
10977: PUSH
10978: LD_INT 32
10980: PUSH
10981: LD_INT 33
10983: PUSH
10984: LD_INT 34
10986: PUSH
10987: LD_INT 35
10989: PUSH
10990: LD_INT 36
10992: PUSH
10993: EMPTY
10994: LIST
10995: LIST
10996: LIST
10997: LIST
10998: LIST
10999: LIST
11000: LIST
11001: LIST
11002: LIST
11003: LIST
11004: LIST
11005: LIST
11006: LIST
11007: LIST
11008: LIST
11009: LIST
11010: LIST
11011: LIST
11012: LIST
11013: LIST
11014: LIST
11015: LIST
11016: LIST
11017: LIST
11018: LIST
11019: LIST
11020: LIST
11021: LIST
11022: LIST
11023: LIST
11024: LIST
11025: LIST
11026: LIST
11027: LIST
11028: LIST
11029: LIST
11030: PUSH
11031: LD_INT 101
11033: PUSH
11034: LD_INT 102
11036: PUSH
11037: LD_INT 103
11039: PUSH
11040: LD_INT 104
11042: PUSH
11043: LD_INT 105
11045: PUSH
11046: LD_INT 106
11048: PUSH
11049: LD_INT 107
11051: PUSH
11052: LD_INT 108
11054: PUSH
11055: LD_INT 109
11057: PUSH
11058: LD_INT 110
11060: PUSH
11061: LD_INT 111
11063: PUSH
11064: LD_INT 112
11066: PUSH
11067: LD_INT 113
11069: PUSH
11070: LD_INT 114
11072: PUSH
11073: LD_INT 115
11075: PUSH
11076: EMPTY
11077: LIST
11078: LIST
11079: LIST
11080: LIST
11081: LIST
11082: LIST
11083: LIST
11084: LIST
11085: LIST
11086: LIST
11087: LIST
11088: LIST
11089: LIST
11090: LIST
11091: LIST
11092: PUSH
11093: EMPTY
11094: LIST
11095: LIST
11096: ST_TO_ADDR
11097: GO 11100
11099: POP
// end ; if result then
11100: LD_VAR 0 1
11104: IFFALSE 11393
// begin normal :=  ;
11106: LD_ADDR_VAR 0 3
11110: PUSH
11111: LD_STRING 
11113: ST_TO_ADDR
// hardcore :=  ;
11114: LD_ADDR_VAR 0 4
11118: PUSH
11119: LD_STRING 
11121: ST_TO_ADDR
// for i = 1 to normalCounter do
11122: LD_ADDR_VAR 0 5
11126: PUSH
11127: DOUBLE
11128: LD_INT 1
11130: DEC
11131: ST_TO_ADDR
11132: LD_EXP 20
11136: PUSH
11137: FOR_TO
11138: IFFALSE 11239
// begin tmp := 0 ;
11140: LD_ADDR_VAR 0 2
11144: PUSH
11145: LD_STRING 0
11147: ST_TO_ADDR
// if result [ 1 ] then
11148: LD_VAR 0 1
11152: PUSH
11153: LD_INT 1
11155: ARRAY
11156: IFFALSE 11221
// if result [ 1 ] [ 1 ] = i then
11158: LD_VAR 0 1
11162: PUSH
11163: LD_INT 1
11165: ARRAY
11166: PUSH
11167: LD_INT 1
11169: ARRAY
11170: PUSH
11171: LD_VAR 0 5
11175: EQUAL
11176: IFFALSE 11221
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
11178: LD_ADDR_VAR 0 1
11182: PUSH
11183: LD_VAR 0 1
11187: PPUSH
11188: LD_INT 1
11190: PPUSH
11191: LD_VAR 0 1
11195: PUSH
11196: LD_INT 1
11198: ARRAY
11199: PPUSH
11200: LD_INT 1
11202: PPUSH
11203: CALL_OW 3
11207: PPUSH
11208: CALL_OW 1
11212: ST_TO_ADDR
// tmp := 1 ;
11213: LD_ADDR_VAR 0 2
11217: PUSH
11218: LD_STRING 1
11220: ST_TO_ADDR
// end ; normal := normal & tmp ;
11221: LD_ADDR_VAR 0 3
11225: PUSH
11226: LD_VAR 0 3
11230: PUSH
11231: LD_VAR 0 2
11235: STR
11236: ST_TO_ADDR
// end ;
11237: GO 11137
11239: POP
11240: POP
// for i = 1 to hardcoreCounter do
11241: LD_ADDR_VAR 0 5
11245: PUSH
11246: DOUBLE
11247: LD_INT 1
11249: DEC
11250: ST_TO_ADDR
11251: LD_EXP 21
11255: PUSH
11256: FOR_TO
11257: IFFALSE 11362
// begin tmp := 0 ;
11259: LD_ADDR_VAR 0 2
11263: PUSH
11264: LD_STRING 0
11266: ST_TO_ADDR
// if result [ 2 ] then
11267: LD_VAR 0 1
11271: PUSH
11272: LD_INT 2
11274: ARRAY
11275: IFFALSE 11344
// if result [ 2 ] [ 1 ] = 100 + i then
11277: LD_VAR 0 1
11281: PUSH
11282: LD_INT 2
11284: ARRAY
11285: PUSH
11286: LD_INT 1
11288: ARRAY
11289: PUSH
11290: LD_INT 100
11292: PUSH
11293: LD_VAR 0 5
11297: PLUS
11298: EQUAL
11299: IFFALSE 11344
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
11301: LD_ADDR_VAR 0 1
11305: PUSH
11306: LD_VAR 0 1
11310: PPUSH
11311: LD_INT 2
11313: PPUSH
11314: LD_VAR 0 1
11318: PUSH
11319: LD_INT 2
11321: ARRAY
11322: PPUSH
11323: LD_INT 1
11325: PPUSH
11326: CALL_OW 3
11330: PPUSH
11331: CALL_OW 1
11335: ST_TO_ADDR
// tmp := 1 ;
11336: LD_ADDR_VAR 0 2
11340: PUSH
11341: LD_STRING 1
11343: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
11344: LD_ADDR_VAR 0 4
11348: PUSH
11349: LD_VAR 0 4
11353: PUSH
11354: LD_VAR 0 2
11358: STR
11359: ST_TO_ADDR
// end ;
11360: GO 11256
11362: POP
11363: POP
// ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & ") ) ;
11364: LD_STRING getStreamItemsFromMission("
11366: PUSH
11367: LD_VAR 0 3
11371: STR
11372: PUSH
11373: LD_STRING ","
11375: STR
11376: PUSH
11377: LD_VAR 0 4
11381: STR
11382: PUSH
11383: LD_STRING ")
11385: STR
11386: PPUSH
11387: CALL_OW 559
// end else
11391: GO 11400
// ToLua ( getStreamItemsFromMission("","") ) ;
11393: LD_STRING getStreamItemsFromMission("","")
11395: PPUSH
11396: CALL_OW 559
// end ;
11400: LD_VAR 0 1
11404: RET
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin if p2 = 100 then
11405: LD_VAR 0 2
11409: PUSH
11410: LD_INT 100
11412: EQUAL
11413: IFFALSE 12362
// begin if not StreamModeActive then
11415: LD_EXP 19
11419: NOT
11420: IFFALSE 11430
// StreamModeActive := true ;
11422: LD_ADDR_EXP 19
11426: PUSH
11427: LD_INT 1
11429: ST_TO_ADDR
// if p3 = 0 then
11430: LD_VAR 0 3
11434: PUSH
11435: LD_INT 0
11437: EQUAL
11438: IFFALSE 11444
// InitStreamMode ;
11440: CALL 7702 0 0
// if p3 = 1 then
11444: LD_VAR 0 3
11448: PUSH
11449: LD_INT 1
11451: EQUAL
11452: IFFALSE 11462
// sRocket := true ;
11454: LD_ADDR_EXP 24
11458: PUSH
11459: LD_INT 1
11461: ST_TO_ADDR
// if p3 = 2 then
11462: LD_VAR 0 3
11466: PUSH
11467: LD_INT 2
11469: EQUAL
11470: IFFALSE 11480
// sSpeed := true ;
11472: LD_ADDR_EXP 23
11476: PUSH
11477: LD_INT 1
11479: ST_TO_ADDR
// if p3 = 3 then
11480: LD_VAR 0 3
11484: PUSH
11485: LD_INT 3
11487: EQUAL
11488: IFFALSE 11498
// sEngine := true ;
11490: LD_ADDR_EXP 25
11494: PUSH
11495: LD_INT 1
11497: ST_TO_ADDR
// if p3 = 4 then
11498: LD_VAR 0 3
11502: PUSH
11503: LD_INT 4
11505: EQUAL
11506: IFFALSE 11516
// sSpec := true ;
11508: LD_ADDR_EXP 22
11512: PUSH
11513: LD_INT 1
11515: ST_TO_ADDR
// if p3 = 5 then
11516: LD_VAR 0 3
11520: PUSH
11521: LD_INT 5
11523: EQUAL
11524: IFFALSE 11534
// sLevel := true ;
11526: LD_ADDR_EXP 26
11530: PUSH
11531: LD_INT 1
11533: ST_TO_ADDR
// if p3 = 6 then
11534: LD_VAR 0 3
11538: PUSH
11539: LD_INT 6
11541: EQUAL
11542: IFFALSE 11552
// sArmoury := true ;
11544: LD_ADDR_EXP 27
11548: PUSH
11549: LD_INT 1
11551: ST_TO_ADDR
// if p3 = 7 then
11552: LD_VAR 0 3
11556: PUSH
11557: LD_INT 7
11559: EQUAL
11560: IFFALSE 11570
// sRadar := true ;
11562: LD_ADDR_EXP 28
11566: PUSH
11567: LD_INT 1
11569: ST_TO_ADDR
// if p3 = 8 then
11570: LD_VAR 0 3
11574: PUSH
11575: LD_INT 8
11577: EQUAL
11578: IFFALSE 11588
// sBunker := true ;
11580: LD_ADDR_EXP 29
11584: PUSH
11585: LD_INT 1
11587: ST_TO_ADDR
// if p3 = 9 then
11588: LD_VAR 0 3
11592: PUSH
11593: LD_INT 9
11595: EQUAL
11596: IFFALSE 11606
// sHack := true ;
11598: LD_ADDR_EXP 30
11602: PUSH
11603: LD_INT 1
11605: ST_TO_ADDR
// if p3 = 10 then
11606: LD_VAR 0 3
11610: PUSH
11611: LD_INT 10
11613: EQUAL
11614: IFFALSE 11624
// sFire := true ;
11616: LD_ADDR_EXP 31
11620: PUSH
11621: LD_INT 1
11623: ST_TO_ADDR
// if p3 = 11 then
11624: LD_VAR 0 3
11628: PUSH
11629: LD_INT 11
11631: EQUAL
11632: IFFALSE 11642
// sRefresh := true ;
11634: LD_ADDR_EXP 32
11638: PUSH
11639: LD_INT 1
11641: ST_TO_ADDR
// if p3 = 12 then
11642: LD_VAR 0 3
11646: PUSH
11647: LD_INT 12
11649: EQUAL
11650: IFFALSE 11660
// sExp := true ;
11652: LD_ADDR_EXP 33
11656: PUSH
11657: LD_INT 1
11659: ST_TO_ADDR
// if p3 = 13 then
11660: LD_VAR 0 3
11664: PUSH
11665: LD_INT 13
11667: EQUAL
11668: IFFALSE 11678
// sDepot := true ;
11670: LD_ADDR_EXP 34
11674: PUSH
11675: LD_INT 1
11677: ST_TO_ADDR
// if p3 = 14 then
11678: LD_VAR 0 3
11682: PUSH
11683: LD_INT 14
11685: EQUAL
11686: IFFALSE 11696
// sFlag := true ;
11688: LD_ADDR_EXP 35
11692: PUSH
11693: LD_INT 1
11695: ST_TO_ADDR
// if p3 = 15 then
11696: LD_VAR 0 3
11700: PUSH
11701: LD_INT 15
11703: EQUAL
11704: IFFALSE 11714
// sKamikadze := true ;
11706: LD_ADDR_EXP 43
11710: PUSH
11711: LD_INT 1
11713: ST_TO_ADDR
// if p3 = 16 then
11714: LD_VAR 0 3
11718: PUSH
11719: LD_INT 16
11721: EQUAL
11722: IFFALSE 11732
// sTroll := true ;
11724: LD_ADDR_EXP 44
11728: PUSH
11729: LD_INT 1
11731: ST_TO_ADDR
// if p3 = 17 then
11732: LD_VAR 0 3
11736: PUSH
11737: LD_INT 17
11739: EQUAL
11740: IFFALSE 11750
// sSlow := true ;
11742: LD_ADDR_EXP 45
11746: PUSH
11747: LD_INT 1
11749: ST_TO_ADDR
// if p3 = 18 then
11750: LD_VAR 0 3
11754: PUSH
11755: LD_INT 18
11757: EQUAL
11758: IFFALSE 11768
// sLack := true ;
11760: LD_ADDR_EXP 46
11764: PUSH
11765: LD_INT 1
11767: ST_TO_ADDR
// if p3 = 19 then
11768: LD_VAR 0 3
11772: PUSH
11773: LD_INT 19
11775: EQUAL
11776: IFFALSE 11786
// sTank := true ;
11778: LD_ADDR_EXP 48
11782: PUSH
11783: LD_INT 1
11785: ST_TO_ADDR
// if p3 = 20 then
11786: LD_VAR 0 3
11790: PUSH
11791: LD_INT 20
11793: EQUAL
11794: IFFALSE 11804
// sRemote := true ;
11796: LD_ADDR_EXP 49
11800: PUSH
11801: LD_INT 1
11803: ST_TO_ADDR
// if p3 = 21 then
11804: LD_VAR 0 3
11808: PUSH
11809: LD_INT 21
11811: EQUAL
11812: IFFALSE 11822
// sPowell := true ;
11814: LD_ADDR_EXP 50
11818: PUSH
11819: LD_INT 1
11821: ST_TO_ADDR
// if p3 = 22 then
11822: LD_VAR 0 3
11826: PUSH
11827: LD_INT 22
11829: EQUAL
11830: IFFALSE 11840
// sTeleport := true ;
11832: LD_ADDR_EXP 53
11836: PUSH
11837: LD_INT 1
11839: ST_TO_ADDR
// if p3 = 23 then
11840: LD_VAR 0 3
11844: PUSH
11845: LD_INT 23
11847: EQUAL
11848: IFFALSE 11858
// sOilTower := true ;
11850: LD_ADDR_EXP 55
11854: PUSH
11855: LD_INT 1
11857: ST_TO_ADDR
// if p3 = 24 then
11858: LD_VAR 0 3
11862: PUSH
11863: LD_INT 24
11865: EQUAL
11866: IFFALSE 11876
// sShovel := true ;
11868: LD_ADDR_EXP 56
11872: PUSH
11873: LD_INT 1
11875: ST_TO_ADDR
// if p3 = 25 then
11876: LD_VAR 0 3
11880: PUSH
11881: LD_INT 25
11883: EQUAL
11884: IFFALSE 11894
// sSheik := true ;
11886: LD_ADDR_EXP 57
11890: PUSH
11891: LD_INT 1
11893: ST_TO_ADDR
// if p3 = 26 then
11894: LD_VAR 0 3
11898: PUSH
11899: LD_INT 26
11901: EQUAL
11902: IFFALSE 11912
// sEarthquake := true ;
11904: LD_ADDR_EXP 59
11908: PUSH
11909: LD_INT 1
11911: ST_TO_ADDR
// if p3 = 27 then
11912: LD_VAR 0 3
11916: PUSH
11917: LD_INT 27
11919: EQUAL
11920: IFFALSE 11930
// sAI := true ;
11922: LD_ADDR_EXP 60
11926: PUSH
11927: LD_INT 1
11929: ST_TO_ADDR
// if p3 = 28 then
11930: LD_VAR 0 3
11934: PUSH
11935: LD_INT 28
11937: EQUAL
11938: IFFALSE 11948
// sCargo := true ;
11940: LD_ADDR_EXP 63
11944: PUSH
11945: LD_INT 1
11947: ST_TO_ADDR
// if p3 = 29 then
11948: LD_VAR 0 3
11952: PUSH
11953: LD_INT 29
11955: EQUAL
11956: IFFALSE 11966
// sDLaser := true ;
11958: LD_ADDR_EXP 64
11962: PUSH
11963: LD_INT 1
11965: ST_TO_ADDR
// if p3 = 30 then
11966: LD_VAR 0 3
11970: PUSH
11971: LD_INT 30
11973: EQUAL
11974: IFFALSE 11984
// sExchange := true ;
11976: LD_ADDR_EXP 65
11980: PUSH
11981: LD_INT 1
11983: ST_TO_ADDR
// if p3 = 31 then
11984: LD_VAR 0 3
11988: PUSH
11989: LD_INT 31
11991: EQUAL
11992: IFFALSE 12002
// sFac := true ;
11994: LD_ADDR_EXP 66
11998: PUSH
11999: LD_INT 1
12001: ST_TO_ADDR
// if p3 = 32 then
12002: LD_VAR 0 3
12006: PUSH
12007: LD_INT 32
12009: EQUAL
12010: IFFALSE 12020
// sPower := true ;
12012: LD_ADDR_EXP 67
12016: PUSH
12017: LD_INT 1
12019: ST_TO_ADDR
// if p3 = 33 then
12020: LD_VAR 0 3
12024: PUSH
12025: LD_INT 33
12027: EQUAL
12028: IFFALSE 12038
// sRandom := true ;
12030: LD_ADDR_EXP 68
12034: PUSH
12035: LD_INT 1
12037: ST_TO_ADDR
// if p3 = 34 then
12038: LD_VAR 0 3
12042: PUSH
12043: LD_INT 34
12045: EQUAL
12046: IFFALSE 12056
// sShield := true ;
12048: LD_ADDR_EXP 69
12052: PUSH
12053: LD_INT 1
12055: ST_TO_ADDR
// if p3 = 35 then
12056: LD_VAR 0 3
12060: PUSH
12061: LD_INT 35
12063: EQUAL
12064: IFFALSE 12074
// sTime := true ;
12066: LD_ADDR_EXP 70
12070: PUSH
12071: LD_INT 1
12073: ST_TO_ADDR
// if p3 = 36 then
12074: LD_VAR 0 3
12078: PUSH
12079: LD_INT 36
12081: EQUAL
12082: IFFALSE 12092
// sTools := true ;
12084: LD_ADDR_EXP 71
12088: PUSH
12089: LD_INT 1
12091: ST_TO_ADDR
// if p3 = 101 then
12092: LD_VAR 0 3
12096: PUSH
12097: LD_INT 101
12099: EQUAL
12100: IFFALSE 12110
// sSold := true ;
12102: LD_ADDR_EXP 36
12106: PUSH
12107: LD_INT 1
12109: ST_TO_ADDR
// if p3 = 102 then
12110: LD_VAR 0 3
12114: PUSH
12115: LD_INT 102
12117: EQUAL
12118: IFFALSE 12128
// sDiff := true ;
12120: LD_ADDR_EXP 37
12124: PUSH
12125: LD_INT 1
12127: ST_TO_ADDR
// if p3 = 103 then
12128: LD_VAR 0 3
12132: PUSH
12133: LD_INT 103
12135: EQUAL
12136: IFFALSE 12146
// sFog := true ;
12138: LD_ADDR_EXP 40
12142: PUSH
12143: LD_INT 1
12145: ST_TO_ADDR
// if p3 = 104 then
12146: LD_VAR 0 3
12150: PUSH
12151: LD_INT 104
12153: EQUAL
12154: IFFALSE 12164
// sReset := true ;
12156: LD_ADDR_EXP 41
12160: PUSH
12161: LD_INT 1
12163: ST_TO_ADDR
// if p3 = 105 then
12164: LD_VAR 0 3
12168: PUSH
12169: LD_INT 105
12171: EQUAL
12172: IFFALSE 12182
// sSun := true ;
12174: LD_ADDR_EXP 42
12178: PUSH
12179: LD_INT 1
12181: ST_TO_ADDR
// if p3 = 106 then
12182: LD_VAR 0 3
12186: PUSH
12187: LD_INT 106
12189: EQUAL
12190: IFFALSE 12200
// sTiger := true ;
12192: LD_ADDR_EXP 38
12196: PUSH
12197: LD_INT 1
12199: ST_TO_ADDR
// if p3 = 107 then
12200: LD_VAR 0 3
12204: PUSH
12205: LD_INT 107
12207: EQUAL
12208: IFFALSE 12218
// sBomb := true ;
12210: LD_ADDR_EXP 39
12214: PUSH
12215: LD_INT 1
12217: ST_TO_ADDR
// if p3 = 108 then
12218: LD_VAR 0 3
12222: PUSH
12223: LD_INT 108
12225: EQUAL
12226: IFFALSE 12236
// sWound := true ;
12228: LD_ADDR_EXP 47
12232: PUSH
12233: LD_INT 1
12235: ST_TO_ADDR
// if p3 = 109 then
12236: LD_VAR 0 3
12240: PUSH
12241: LD_INT 109
12243: EQUAL
12244: IFFALSE 12254
// sBetray := true ;
12246: LD_ADDR_EXP 51
12250: PUSH
12251: LD_INT 1
12253: ST_TO_ADDR
// if p3 = 110 then
12254: LD_VAR 0 3
12258: PUSH
12259: LD_INT 110
12261: EQUAL
12262: IFFALSE 12272
// sContamin := true ;
12264: LD_ADDR_EXP 52
12268: PUSH
12269: LD_INT 1
12271: ST_TO_ADDR
// if p3 = 111 then
12272: LD_VAR 0 3
12276: PUSH
12277: LD_INT 111
12279: EQUAL
12280: IFFALSE 12290
// sOil := true ;
12282: LD_ADDR_EXP 54
12286: PUSH
12287: LD_INT 1
12289: ST_TO_ADDR
// if p3 = 112 then
12290: LD_VAR 0 3
12294: PUSH
12295: LD_INT 112
12297: EQUAL
12298: IFFALSE 12308
// sStu := true ;
12300: LD_ADDR_EXP 58
12304: PUSH
12305: LD_INT 1
12307: ST_TO_ADDR
// if p3 = 113 then
12308: LD_VAR 0 3
12312: PUSH
12313: LD_INT 113
12315: EQUAL
12316: IFFALSE 12326
// sBazooka := true ;
12318: LD_ADDR_EXP 61
12322: PUSH
12323: LD_INT 1
12325: ST_TO_ADDR
// if p3 = 114 then
12326: LD_VAR 0 3
12330: PUSH
12331: LD_INT 114
12333: EQUAL
12334: IFFALSE 12344
// sMortar := true ;
12336: LD_ADDR_EXP 62
12340: PUSH
12341: LD_INT 1
12343: ST_TO_ADDR
// if p3 = 115 then
12344: LD_VAR 0 3
12348: PUSH
12349: LD_INT 115
12351: EQUAL
12352: IFFALSE 12362
// sRanger := true ;
12354: LD_ADDR_EXP 72
12358: PUSH
12359: LD_INT 1
12361: ST_TO_ADDR
// end ; end ;
12362: PPOPN 6
12364: END
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
12365: LD_EXP 19
12369: PUSH
12370: LD_EXP 24
12374: AND
12375: IFFALSE 12499
12377: GO 12379
12379: DISABLE
12380: LD_INT 0
12382: PPUSH
12383: PPUSH
// begin enable ;
12384: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
12385: LD_ADDR_VAR 0 2
12389: PUSH
12390: LD_INT 22
12392: PUSH
12393: LD_OWVAR 2
12397: PUSH
12398: EMPTY
12399: LIST
12400: LIST
12401: PUSH
12402: LD_INT 2
12404: PUSH
12405: LD_INT 34
12407: PUSH
12408: LD_INT 7
12410: PUSH
12411: EMPTY
12412: LIST
12413: LIST
12414: PUSH
12415: LD_INT 34
12417: PUSH
12418: LD_INT 45
12420: PUSH
12421: EMPTY
12422: LIST
12423: LIST
12424: PUSH
12425: LD_INT 34
12427: PUSH
12428: LD_INT 28
12430: PUSH
12431: EMPTY
12432: LIST
12433: LIST
12434: PUSH
12435: LD_INT 34
12437: PUSH
12438: LD_INT 47
12440: PUSH
12441: EMPTY
12442: LIST
12443: LIST
12444: PUSH
12445: EMPTY
12446: LIST
12447: LIST
12448: LIST
12449: LIST
12450: LIST
12451: PUSH
12452: EMPTY
12453: LIST
12454: LIST
12455: PPUSH
12456: CALL_OW 69
12460: ST_TO_ADDR
// if not tmp then
12461: LD_VAR 0 2
12465: NOT
12466: IFFALSE 12470
// exit ;
12468: GO 12499
// for i in tmp do
12470: LD_ADDR_VAR 0 1
12474: PUSH
12475: LD_VAR 0 2
12479: PUSH
12480: FOR_IN
12481: IFFALSE 12497
// begin SetLives ( i , 0 ) ;
12483: LD_VAR 0 1
12487: PPUSH
12488: LD_INT 0
12490: PPUSH
12491: CALL_OW 234
// end ;
12495: GO 12480
12497: POP
12498: POP
// end ;
12499: PPOPN 2
12501: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
12502: LD_EXP 19
12506: PUSH
12507: LD_EXP 25
12511: AND
12512: IFFALSE 12596
12514: GO 12516
12516: DISABLE
12517: LD_INT 0
12519: PPUSH
12520: PPUSH
// begin enable ;
12521: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
12522: LD_ADDR_VAR 0 2
12526: PUSH
12527: LD_INT 22
12529: PUSH
12530: LD_OWVAR 2
12534: PUSH
12535: EMPTY
12536: LIST
12537: LIST
12538: PUSH
12539: LD_INT 32
12541: PUSH
12542: LD_INT 3
12544: PUSH
12545: EMPTY
12546: LIST
12547: LIST
12548: PUSH
12549: EMPTY
12550: LIST
12551: LIST
12552: PPUSH
12553: CALL_OW 69
12557: ST_TO_ADDR
// if not tmp then
12558: LD_VAR 0 2
12562: NOT
12563: IFFALSE 12567
// exit ;
12565: GO 12596
// for i in tmp do
12567: LD_ADDR_VAR 0 1
12571: PUSH
12572: LD_VAR 0 2
12576: PUSH
12577: FOR_IN
12578: IFFALSE 12594
// begin SetLives ( i , 0 ) ;
12580: LD_VAR 0 1
12584: PPUSH
12585: LD_INT 0
12587: PPUSH
12588: CALL_OW 234
// end ;
12592: GO 12577
12594: POP
12595: POP
// end ;
12596: PPOPN 2
12598: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
12599: LD_EXP 19
12603: PUSH
12604: LD_EXP 22
12608: AND
12609: IFFALSE 12702
12611: GO 12613
12613: DISABLE
12614: LD_INT 0
12616: PPUSH
// begin enable ;
12617: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
12618: LD_ADDR_VAR 0 1
12622: PUSH
12623: LD_INT 22
12625: PUSH
12626: LD_OWVAR 2
12630: PUSH
12631: EMPTY
12632: LIST
12633: LIST
12634: PUSH
12635: LD_INT 2
12637: PUSH
12638: LD_INT 25
12640: PUSH
12641: LD_INT 5
12643: PUSH
12644: EMPTY
12645: LIST
12646: LIST
12647: PUSH
12648: LD_INT 25
12650: PUSH
12651: LD_INT 9
12653: PUSH
12654: EMPTY
12655: LIST
12656: LIST
12657: PUSH
12658: LD_INT 25
12660: PUSH
12661: LD_INT 8
12663: PUSH
12664: EMPTY
12665: LIST
12666: LIST
12667: PUSH
12668: EMPTY
12669: LIST
12670: LIST
12671: LIST
12672: LIST
12673: PUSH
12674: EMPTY
12675: LIST
12676: LIST
12677: PPUSH
12678: CALL_OW 69
12682: PUSH
12683: FOR_IN
12684: IFFALSE 12700
// begin SetClass ( i , 1 ) ;
12686: LD_VAR 0 1
12690: PPUSH
12691: LD_INT 1
12693: PPUSH
12694: CALL_OW 336
// end ;
12698: GO 12683
12700: POP
12701: POP
// end ;
12702: PPOPN 1
12704: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
12705: LD_EXP 19
12709: PUSH
12710: LD_EXP 23
12714: AND
12715: PUSH
12716: LD_OWVAR 65
12720: PUSH
12721: LD_INT 7
12723: LESS
12724: AND
12725: IFFALSE 12739
12727: GO 12729
12729: DISABLE
// begin enable ;
12730: ENABLE
// game_speed := 7 ;
12731: LD_ADDR_OWVAR 65
12735: PUSH
12736: LD_INT 7
12738: ST_TO_ADDR
// end ;
12739: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
12740: LD_EXP 19
12744: PUSH
12745: LD_EXP 26
12749: AND
12750: IFFALSE 12952
12752: GO 12754
12754: DISABLE
12755: LD_INT 0
12757: PPUSH
12758: PPUSH
12759: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
12760: LD_ADDR_VAR 0 3
12764: PUSH
12765: LD_INT 81
12767: PUSH
12768: LD_OWVAR 2
12772: PUSH
12773: EMPTY
12774: LIST
12775: LIST
12776: PUSH
12777: LD_INT 21
12779: PUSH
12780: LD_INT 1
12782: PUSH
12783: EMPTY
12784: LIST
12785: LIST
12786: PUSH
12787: EMPTY
12788: LIST
12789: LIST
12790: PPUSH
12791: CALL_OW 69
12795: ST_TO_ADDR
// if not tmp then
12796: LD_VAR 0 3
12800: NOT
12801: IFFALSE 12805
// exit ;
12803: GO 12952
// if tmp > 5 then
12805: LD_VAR 0 3
12809: PUSH
12810: LD_INT 5
12812: GREATER
12813: IFFALSE 12825
// k := 5 else
12815: LD_ADDR_VAR 0 2
12819: PUSH
12820: LD_INT 5
12822: ST_TO_ADDR
12823: GO 12835
// k := tmp ;
12825: LD_ADDR_VAR 0 2
12829: PUSH
12830: LD_VAR 0 3
12834: ST_TO_ADDR
// for i := 1 to k do
12835: LD_ADDR_VAR 0 1
12839: PUSH
12840: DOUBLE
12841: LD_INT 1
12843: DEC
12844: ST_TO_ADDR
12845: LD_VAR 0 2
12849: PUSH
12850: FOR_TO
12851: IFFALSE 12950
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
12853: LD_VAR 0 3
12857: PUSH
12858: LD_VAR 0 1
12862: ARRAY
12863: PPUSH
12864: LD_VAR 0 1
12868: PUSH
12869: LD_INT 4
12871: MOD
12872: PUSH
12873: LD_INT 1
12875: PLUS
12876: PPUSH
12877: CALL_OW 259
12881: PUSH
12882: LD_INT 10
12884: LESS
12885: IFFALSE 12948
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
12887: LD_VAR 0 3
12891: PUSH
12892: LD_VAR 0 1
12896: ARRAY
12897: PPUSH
12898: LD_VAR 0 1
12902: PUSH
12903: LD_INT 4
12905: MOD
12906: PUSH
12907: LD_INT 1
12909: PLUS
12910: PPUSH
12911: LD_VAR 0 3
12915: PUSH
12916: LD_VAR 0 1
12920: ARRAY
12921: PPUSH
12922: LD_VAR 0 1
12926: PUSH
12927: LD_INT 4
12929: MOD
12930: PUSH
12931: LD_INT 1
12933: PLUS
12934: PPUSH
12935: CALL_OW 259
12939: PUSH
12940: LD_INT 1
12942: PLUS
12943: PPUSH
12944: CALL_OW 237
12948: GO 12850
12950: POP
12951: POP
// end ;
12952: PPOPN 3
12954: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
12955: LD_EXP 19
12959: PUSH
12960: LD_EXP 27
12964: AND
12965: IFFALSE 12985
12967: GO 12969
12969: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
12970: LD_INT 4
12972: PPUSH
12973: LD_OWVAR 2
12977: PPUSH
12978: LD_INT 0
12980: PPUSH
12981: CALL_OW 324
12985: END
// every 0 0$1 trigger StreamModeActive and sShovel do
12986: LD_EXP 19
12990: PUSH
12991: LD_EXP 56
12995: AND
12996: IFFALSE 13016
12998: GO 13000
13000: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
13001: LD_INT 19
13003: PPUSH
13004: LD_OWVAR 2
13008: PPUSH
13009: LD_INT 0
13011: PPUSH
13012: CALL_OW 324
13016: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
13017: LD_EXP 19
13021: PUSH
13022: LD_EXP 28
13026: AND
13027: IFFALSE 13129
13029: GO 13031
13031: DISABLE
13032: LD_INT 0
13034: PPUSH
13035: PPUSH
// begin enable ;
13036: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
13037: LD_ADDR_VAR 0 2
13041: PUSH
13042: LD_INT 22
13044: PUSH
13045: LD_OWVAR 2
13049: PUSH
13050: EMPTY
13051: LIST
13052: LIST
13053: PUSH
13054: LD_INT 2
13056: PUSH
13057: LD_INT 34
13059: PUSH
13060: LD_INT 11
13062: PUSH
13063: EMPTY
13064: LIST
13065: LIST
13066: PUSH
13067: LD_INT 34
13069: PUSH
13070: LD_INT 30
13072: PUSH
13073: EMPTY
13074: LIST
13075: LIST
13076: PUSH
13077: EMPTY
13078: LIST
13079: LIST
13080: LIST
13081: PUSH
13082: EMPTY
13083: LIST
13084: LIST
13085: PPUSH
13086: CALL_OW 69
13090: ST_TO_ADDR
// if not tmp then
13091: LD_VAR 0 2
13095: NOT
13096: IFFALSE 13100
// exit ;
13098: GO 13129
// for i in tmp do
13100: LD_ADDR_VAR 0 1
13104: PUSH
13105: LD_VAR 0 2
13109: PUSH
13110: FOR_IN
13111: IFFALSE 13127
// begin SetLives ( i , 0 ) ;
13113: LD_VAR 0 1
13117: PPUSH
13118: LD_INT 0
13120: PPUSH
13121: CALL_OW 234
// end ;
13125: GO 13110
13127: POP
13128: POP
// end ;
13129: PPOPN 2
13131: END
// every 0 0$1 trigger StreamModeActive and sBunker do
13132: LD_EXP 19
13136: PUSH
13137: LD_EXP 29
13141: AND
13142: IFFALSE 13162
13144: GO 13146
13146: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
13147: LD_INT 32
13149: PPUSH
13150: LD_OWVAR 2
13154: PPUSH
13155: LD_INT 0
13157: PPUSH
13158: CALL_OW 324
13162: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
13163: LD_EXP 19
13167: PUSH
13168: LD_EXP 30
13172: AND
13173: IFFALSE 13354
13175: GO 13177
13177: DISABLE
13178: LD_INT 0
13180: PPUSH
13181: PPUSH
13182: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
13183: LD_ADDR_VAR 0 2
13187: PUSH
13188: LD_INT 22
13190: PUSH
13191: LD_OWVAR 2
13195: PUSH
13196: EMPTY
13197: LIST
13198: LIST
13199: PUSH
13200: LD_INT 33
13202: PUSH
13203: LD_INT 3
13205: PUSH
13206: EMPTY
13207: LIST
13208: LIST
13209: PUSH
13210: EMPTY
13211: LIST
13212: LIST
13213: PPUSH
13214: CALL_OW 69
13218: ST_TO_ADDR
// if not tmp then
13219: LD_VAR 0 2
13223: NOT
13224: IFFALSE 13228
// exit ;
13226: GO 13354
// side := 0 ;
13228: LD_ADDR_VAR 0 3
13232: PUSH
13233: LD_INT 0
13235: ST_TO_ADDR
// for i := 1 to 8 do
13236: LD_ADDR_VAR 0 1
13240: PUSH
13241: DOUBLE
13242: LD_INT 1
13244: DEC
13245: ST_TO_ADDR
13246: LD_INT 8
13248: PUSH
13249: FOR_TO
13250: IFFALSE 13298
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
13252: LD_OWVAR 2
13256: PUSH
13257: LD_VAR 0 1
13261: NONEQUAL
13262: PUSH
13263: LD_OWVAR 2
13267: PPUSH
13268: LD_VAR 0 1
13272: PPUSH
13273: CALL_OW 81
13277: PUSH
13278: LD_INT 2
13280: EQUAL
13281: AND
13282: IFFALSE 13296
// begin side := i ;
13284: LD_ADDR_VAR 0 3
13288: PUSH
13289: LD_VAR 0 1
13293: ST_TO_ADDR
// break ;
13294: GO 13298
// end ;
13296: GO 13249
13298: POP
13299: POP
// if not side then
13300: LD_VAR 0 3
13304: NOT
13305: IFFALSE 13309
// exit ;
13307: GO 13354
// for i := 1 to tmp do
13309: LD_ADDR_VAR 0 1
13313: PUSH
13314: DOUBLE
13315: LD_INT 1
13317: DEC
13318: ST_TO_ADDR
13319: LD_VAR 0 2
13323: PUSH
13324: FOR_TO
13325: IFFALSE 13352
// if Prob ( 60 ) then
13327: LD_INT 60
13329: PPUSH
13330: CALL_OW 13
13334: IFFALSE 13350
// SetSide ( i , side ) ;
13336: LD_VAR 0 1
13340: PPUSH
13341: LD_VAR 0 3
13345: PPUSH
13346: CALL_OW 235
13350: GO 13324
13352: POP
13353: POP
// end ;
13354: PPOPN 3
13356: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
13357: LD_EXP 19
13361: PUSH
13362: LD_EXP 32
13366: AND
13367: IFFALSE 13486
13369: GO 13371
13371: DISABLE
13372: LD_INT 0
13374: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
13375: LD_ADDR_VAR 0 1
13379: PUSH
13380: LD_INT 22
13382: PUSH
13383: LD_OWVAR 2
13387: PUSH
13388: EMPTY
13389: LIST
13390: LIST
13391: PUSH
13392: LD_INT 21
13394: PUSH
13395: LD_INT 1
13397: PUSH
13398: EMPTY
13399: LIST
13400: LIST
13401: PUSH
13402: LD_INT 3
13404: PUSH
13405: LD_INT 23
13407: PUSH
13408: LD_INT 0
13410: PUSH
13411: EMPTY
13412: LIST
13413: LIST
13414: PUSH
13415: EMPTY
13416: LIST
13417: LIST
13418: PUSH
13419: EMPTY
13420: LIST
13421: LIST
13422: LIST
13423: PPUSH
13424: CALL_OW 69
13428: PUSH
13429: FOR_IN
13430: IFFALSE 13484
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
13432: LD_VAR 0 1
13436: PPUSH
13437: CALL_OW 257
13441: PUSH
13442: LD_INT 1
13444: PUSH
13445: LD_INT 2
13447: PUSH
13448: LD_INT 3
13450: PUSH
13451: LD_INT 4
13453: PUSH
13454: EMPTY
13455: LIST
13456: LIST
13457: LIST
13458: LIST
13459: IN
13460: IFFALSE 13482
// SetClass ( un , rand ( 1 , 4 ) ) ;
13462: LD_VAR 0 1
13466: PPUSH
13467: LD_INT 1
13469: PPUSH
13470: LD_INT 4
13472: PPUSH
13473: CALL_OW 12
13477: PPUSH
13478: CALL_OW 336
13482: GO 13429
13484: POP
13485: POP
// end ;
13486: PPOPN 1
13488: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
13489: LD_EXP 19
13493: PUSH
13494: LD_EXP 31
13498: AND
13499: IFFALSE 13578
13501: GO 13503
13503: DISABLE
13504: LD_INT 0
13506: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
13507: LD_ADDR_VAR 0 1
13511: PUSH
13512: LD_INT 22
13514: PUSH
13515: LD_OWVAR 2
13519: PUSH
13520: EMPTY
13521: LIST
13522: LIST
13523: PUSH
13524: LD_INT 21
13526: PUSH
13527: LD_INT 3
13529: PUSH
13530: EMPTY
13531: LIST
13532: LIST
13533: PUSH
13534: EMPTY
13535: LIST
13536: LIST
13537: PPUSH
13538: CALL_OW 69
13542: ST_TO_ADDR
// if not tmp then
13543: LD_VAR 0 1
13547: NOT
13548: IFFALSE 13552
// exit ;
13550: GO 13578
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
13552: LD_VAR 0 1
13556: PUSH
13557: LD_INT 1
13559: PPUSH
13560: LD_VAR 0 1
13564: PPUSH
13565: CALL_OW 12
13569: ARRAY
13570: PPUSH
13571: LD_INT 100
13573: PPUSH
13574: CALL_OW 234
// end ;
13578: PPOPN 1
13580: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
13581: LD_EXP 19
13585: PUSH
13586: LD_EXP 33
13590: AND
13591: IFFALSE 13689
13593: GO 13595
13595: DISABLE
13596: LD_INT 0
13598: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
13599: LD_ADDR_VAR 0 1
13603: PUSH
13604: LD_INT 22
13606: PUSH
13607: LD_OWVAR 2
13611: PUSH
13612: EMPTY
13613: LIST
13614: LIST
13615: PUSH
13616: LD_INT 21
13618: PUSH
13619: LD_INT 1
13621: PUSH
13622: EMPTY
13623: LIST
13624: LIST
13625: PUSH
13626: EMPTY
13627: LIST
13628: LIST
13629: PPUSH
13630: CALL_OW 69
13634: ST_TO_ADDR
// if not tmp then
13635: LD_VAR 0 1
13639: NOT
13640: IFFALSE 13644
// exit ;
13642: GO 13689
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
13644: LD_VAR 0 1
13648: PUSH
13649: LD_INT 1
13651: PPUSH
13652: LD_VAR 0 1
13656: PPUSH
13657: CALL_OW 12
13661: ARRAY
13662: PPUSH
13663: LD_INT 1
13665: PPUSH
13666: LD_INT 4
13668: PPUSH
13669: CALL_OW 12
13673: PPUSH
13674: LD_INT 3000
13676: PPUSH
13677: LD_INT 9000
13679: PPUSH
13680: CALL_OW 12
13684: PPUSH
13685: CALL_OW 492
// end ;
13689: PPOPN 1
13691: END
// every 0 0$1 trigger StreamModeActive and sDepot do
13692: LD_EXP 19
13696: PUSH
13697: LD_EXP 34
13701: AND
13702: IFFALSE 13722
13704: GO 13706
13706: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
13707: LD_INT 1
13709: PPUSH
13710: LD_OWVAR 2
13714: PPUSH
13715: LD_INT 0
13717: PPUSH
13718: CALL_OW 324
13722: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
13723: LD_EXP 19
13727: PUSH
13728: LD_EXP 35
13732: AND
13733: IFFALSE 13816
13735: GO 13737
13737: DISABLE
13738: LD_INT 0
13740: PPUSH
13741: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
13742: LD_ADDR_VAR 0 2
13746: PUSH
13747: LD_INT 22
13749: PUSH
13750: LD_OWVAR 2
13754: PUSH
13755: EMPTY
13756: LIST
13757: LIST
13758: PUSH
13759: LD_INT 21
13761: PUSH
13762: LD_INT 3
13764: PUSH
13765: EMPTY
13766: LIST
13767: LIST
13768: PUSH
13769: EMPTY
13770: LIST
13771: LIST
13772: PPUSH
13773: CALL_OW 69
13777: ST_TO_ADDR
// if not tmp then
13778: LD_VAR 0 2
13782: NOT
13783: IFFALSE 13787
// exit ;
13785: GO 13816
// for i in tmp do
13787: LD_ADDR_VAR 0 1
13791: PUSH
13792: LD_VAR 0 2
13796: PUSH
13797: FOR_IN
13798: IFFALSE 13814
// SetBLevel ( i , 10 ) ;
13800: LD_VAR 0 1
13804: PPUSH
13805: LD_INT 10
13807: PPUSH
13808: CALL_OW 241
13812: GO 13797
13814: POP
13815: POP
// end ;
13816: PPOPN 2
13818: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
13819: LD_EXP 19
13823: PUSH
13824: LD_EXP 36
13828: AND
13829: IFFALSE 13940
13831: GO 13833
13833: DISABLE
13834: LD_INT 0
13836: PPUSH
13837: PPUSH
13838: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
13839: LD_ADDR_VAR 0 3
13843: PUSH
13844: LD_INT 22
13846: PUSH
13847: LD_OWVAR 2
13851: PUSH
13852: EMPTY
13853: LIST
13854: LIST
13855: PUSH
13856: LD_INT 25
13858: PUSH
13859: LD_INT 1
13861: PUSH
13862: EMPTY
13863: LIST
13864: LIST
13865: PUSH
13866: EMPTY
13867: LIST
13868: LIST
13869: PPUSH
13870: CALL_OW 69
13874: ST_TO_ADDR
// if not tmp then
13875: LD_VAR 0 3
13879: NOT
13880: IFFALSE 13884
// exit ;
13882: GO 13940
// un := tmp [ rand ( 1 , tmp ) ] ;
13884: LD_ADDR_VAR 0 2
13888: PUSH
13889: LD_VAR 0 3
13893: PUSH
13894: LD_INT 1
13896: PPUSH
13897: LD_VAR 0 3
13901: PPUSH
13902: CALL_OW 12
13906: ARRAY
13907: ST_TO_ADDR
// if Crawls ( un ) then
13908: LD_VAR 0 2
13912: PPUSH
13913: CALL_OW 318
13917: IFFALSE 13928
// ComWalk ( un ) ;
13919: LD_VAR 0 2
13923: PPUSH
13924: CALL_OW 138
// SetClass ( un , class_sniper ) ;
13928: LD_VAR 0 2
13932: PPUSH
13933: LD_INT 5
13935: PPUSH
13936: CALL_OW 336
// end ;
13940: PPOPN 3
13942: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
13943: LD_EXP 19
13947: PUSH
13948: LD_EXP 37
13952: AND
13953: PUSH
13954: LD_OWVAR 67
13958: PUSH
13959: LD_INT 3
13961: LESS
13962: AND
13963: IFFALSE 13982
13965: GO 13967
13967: DISABLE
// Difficulty := Difficulty + 1 ;
13968: LD_ADDR_OWVAR 67
13972: PUSH
13973: LD_OWVAR 67
13977: PUSH
13978: LD_INT 1
13980: PLUS
13981: ST_TO_ADDR
13982: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
13983: LD_EXP 19
13987: PUSH
13988: LD_EXP 38
13992: AND
13993: IFFALSE 14096
13995: GO 13997
13997: DISABLE
13998: LD_INT 0
14000: PPUSH
// begin for i := 1 to 5 do
14001: LD_ADDR_VAR 0 1
14005: PUSH
14006: DOUBLE
14007: LD_INT 1
14009: DEC
14010: ST_TO_ADDR
14011: LD_INT 5
14013: PUSH
14014: FOR_TO
14015: IFFALSE 14094
// begin uc_nation := nation_nature ;
14017: LD_ADDR_OWVAR 21
14021: PUSH
14022: LD_INT 0
14024: ST_TO_ADDR
// uc_side := 0 ;
14025: LD_ADDR_OWVAR 20
14029: PUSH
14030: LD_INT 0
14032: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
14033: LD_ADDR_OWVAR 29
14037: PUSH
14038: LD_INT 12
14040: PUSH
14041: LD_INT 12
14043: PUSH
14044: EMPTY
14045: LIST
14046: LIST
14047: ST_TO_ADDR
// hc_agressivity := 20 ;
14048: LD_ADDR_OWVAR 35
14052: PUSH
14053: LD_INT 20
14055: ST_TO_ADDR
// hc_class := class_tiger ;
14056: LD_ADDR_OWVAR 28
14060: PUSH
14061: LD_INT 14
14063: ST_TO_ADDR
// hc_gallery :=  ;
14064: LD_ADDR_OWVAR 33
14068: PUSH
14069: LD_STRING 
14071: ST_TO_ADDR
// hc_name :=  ;
14072: LD_ADDR_OWVAR 26
14076: PUSH
14077: LD_STRING 
14079: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
14080: CALL_OW 44
14084: PPUSH
14085: LD_INT 0
14087: PPUSH
14088: CALL_OW 51
// end ;
14092: GO 14014
14094: POP
14095: POP
// end ;
14096: PPOPN 1
14098: END
// every 0 0$1 trigger StreamModeActive and sBomb do
14099: LD_EXP 19
14103: PUSH
14104: LD_EXP 39
14108: AND
14109: IFFALSE 14118
14111: GO 14113
14113: DISABLE
// StreamSibBomb ;
14114: CALL 14119 0 0
14118: END
// export function StreamSibBomb ; var i , x , y ; begin
14119: LD_INT 0
14121: PPUSH
14122: PPUSH
14123: PPUSH
14124: PPUSH
// result := false ;
14125: LD_ADDR_VAR 0 1
14129: PUSH
14130: LD_INT 0
14132: ST_TO_ADDR
// for i := 1 to 16 do
14133: LD_ADDR_VAR 0 2
14137: PUSH
14138: DOUBLE
14139: LD_INT 1
14141: DEC
14142: ST_TO_ADDR
14143: LD_INT 16
14145: PUSH
14146: FOR_TO
14147: IFFALSE 14346
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
14149: LD_ADDR_VAR 0 3
14153: PUSH
14154: LD_INT 10
14156: PUSH
14157: LD_INT 20
14159: PUSH
14160: LD_INT 30
14162: PUSH
14163: LD_INT 40
14165: PUSH
14166: LD_INT 50
14168: PUSH
14169: LD_INT 60
14171: PUSH
14172: LD_INT 70
14174: PUSH
14175: LD_INT 80
14177: PUSH
14178: LD_INT 90
14180: PUSH
14181: LD_INT 100
14183: PUSH
14184: LD_INT 110
14186: PUSH
14187: LD_INT 120
14189: PUSH
14190: LD_INT 130
14192: PUSH
14193: LD_INT 140
14195: PUSH
14196: LD_INT 150
14198: PUSH
14199: EMPTY
14200: LIST
14201: LIST
14202: LIST
14203: LIST
14204: LIST
14205: LIST
14206: LIST
14207: LIST
14208: LIST
14209: LIST
14210: LIST
14211: LIST
14212: LIST
14213: LIST
14214: LIST
14215: PUSH
14216: LD_INT 1
14218: PPUSH
14219: LD_INT 15
14221: PPUSH
14222: CALL_OW 12
14226: ARRAY
14227: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
14228: LD_ADDR_VAR 0 4
14232: PUSH
14233: LD_INT 10
14235: PUSH
14236: LD_INT 20
14238: PUSH
14239: LD_INT 30
14241: PUSH
14242: LD_INT 40
14244: PUSH
14245: LD_INT 50
14247: PUSH
14248: LD_INT 60
14250: PUSH
14251: LD_INT 70
14253: PUSH
14254: LD_INT 80
14256: PUSH
14257: LD_INT 90
14259: PUSH
14260: LD_INT 100
14262: PUSH
14263: LD_INT 110
14265: PUSH
14266: LD_INT 120
14268: PUSH
14269: LD_INT 130
14271: PUSH
14272: LD_INT 140
14274: PUSH
14275: LD_INT 150
14277: PUSH
14278: EMPTY
14279: LIST
14280: LIST
14281: LIST
14282: LIST
14283: LIST
14284: LIST
14285: LIST
14286: LIST
14287: LIST
14288: LIST
14289: LIST
14290: LIST
14291: LIST
14292: LIST
14293: LIST
14294: PUSH
14295: LD_INT 1
14297: PPUSH
14298: LD_INT 15
14300: PPUSH
14301: CALL_OW 12
14305: ARRAY
14306: ST_TO_ADDR
// if ValidHex ( x , y ) then
14307: LD_VAR 0 3
14311: PPUSH
14312: LD_VAR 0 4
14316: PPUSH
14317: CALL_OW 488
14321: IFFALSE 14344
// begin result := [ x , y ] ;
14323: LD_ADDR_VAR 0 1
14327: PUSH
14328: LD_VAR 0 3
14332: PUSH
14333: LD_VAR 0 4
14337: PUSH
14338: EMPTY
14339: LIST
14340: LIST
14341: ST_TO_ADDR
// break ;
14342: GO 14346
// end ; end ;
14344: GO 14146
14346: POP
14347: POP
// if result then
14348: LD_VAR 0 1
14352: IFFALSE 14412
// begin ToLua ( playSibBomb() ) ;
14354: LD_STRING playSibBomb()
14356: PPUSH
14357: CALL_OW 559
// wait ( 0 0$14 ) ;
14361: LD_INT 490
14363: PPUSH
14364: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
14368: LD_VAR 0 1
14372: PUSH
14373: LD_INT 1
14375: ARRAY
14376: PPUSH
14377: LD_VAR 0 1
14381: PUSH
14382: LD_INT 2
14384: ARRAY
14385: PPUSH
14386: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
14390: LD_VAR 0 1
14394: PUSH
14395: LD_INT 1
14397: ARRAY
14398: PPUSH
14399: LD_VAR 0 1
14403: PUSH
14404: LD_INT 2
14406: ARRAY
14407: PPUSH
14408: CALL_OW 429
// end ; end ;
14412: LD_VAR 0 1
14416: RET
// every 0 0$1 trigger StreamModeActive and sReset do
14417: LD_EXP 19
14421: PUSH
14422: LD_EXP 41
14426: AND
14427: IFFALSE 14439
14429: GO 14431
14431: DISABLE
// YouLost (  ) ;
14432: LD_STRING 
14434: PPUSH
14435: CALL_OW 104
14439: END
// every 0 0$1 trigger StreamModeActive and sFog do
14440: LD_EXP 19
14444: PUSH
14445: LD_EXP 40
14449: AND
14450: IFFALSE 14464
14452: GO 14454
14454: DISABLE
// FogOff ( your_side ) ;
14455: LD_OWVAR 2
14459: PPUSH
14460: CALL_OW 344
14464: END
// every 0 0$1 trigger StreamModeActive and sSun do
14465: LD_EXP 19
14469: PUSH
14470: LD_EXP 42
14474: AND
14475: IFFALSE 14503
14477: GO 14479
14479: DISABLE
// begin solar_recharge_percent := 0 ;
14480: LD_ADDR_OWVAR 79
14484: PUSH
14485: LD_INT 0
14487: ST_TO_ADDR
// wait ( 5 5$00 ) ;
14488: LD_INT 10500
14490: PPUSH
14491: CALL_OW 67
// solar_recharge_percent := 100 ;
14495: LD_ADDR_OWVAR 79
14499: PUSH
14500: LD_INT 100
14502: ST_TO_ADDR
// end ;
14503: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
14504: LD_EXP 19
14508: PUSH
14509: LD_EXP 43
14513: AND
14514: IFFALSE 14753
14516: GO 14518
14518: DISABLE
14519: LD_INT 0
14521: PPUSH
14522: PPUSH
14523: PPUSH
// begin tmp := [ ] ;
14524: LD_ADDR_VAR 0 3
14528: PUSH
14529: EMPTY
14530: ST_TO_ADDR
// for i := 1 to 6 do
14531: LD_ADDR_VAR 0 1
14535: PUSH
14536: DOUBLE
14537: LD_INT 1
14539: DEC
14540: ST_TO_ADDR
14541: LD_INT 6
14543: PUSH
14544: FOR_TO
14545: IFFALSE 14650
// begin uc_nation := nation_nature ;
14547: LD_ADDR_OWVAR 21
14551: PUSH
14552: LD_INT 0
14554: ST_TO_ADDR
// uc_side := 0 ;
14555: LD_ADDR_OWVAR 20
14559: PUSH
14560: LD_INT 0
14562: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
14563: LD_ADDR_OWVAR 29
14567: PUSH
14568: LD_INT 12
14570: PUSH
14571: LD_INT 12
14573: PUSH
14574: EMPTY
14575: LIST
14576: LIST
14577: ST_TO_ADDR
// hc_agressivity := 20 ;
14578: LD_ADDR_OWVAR 35
14582: PUSH
14583: LD_INT 20
14585: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
14586: LD_ADDR_OWVAR 28
14590: PUSH
14591: LD_INT 17
14593: ST_TO_ADDR
// hc_gallery :=  ;
14594: LD_ADDR_OWVAR 33
14598: PUSH
14599: LD_STRING 
14601: ST_TO_ADDR
// hc_name :=  ;
14602: LD_ADDR_OWVAR 26
14606: PUSH
14607: LD_STRING 
14609: ST_TO_ADDR
// un := CreateHuman ;
14610: LD_ADDR_VAR 0 2
14614: PUSH
14615: CALL_OW 44
14619: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
14620: LD_VAR 0 2
14624: PPUSH
14625: LD_INT 1
14627: PPUSH
14628: CALL_OW 51
// tmp := tmp ^ un ;
14632: LD_ADDR_VAR 0 3
14636: PUSH
14637: LD_VAR 0 3
14641: PUSH
14642: LD_VAR 0 2
14646: ADD
14647: ST_TO_ADDR
// end ;
14648: GO 14544
14650: POP
14651: POP
// repeat wait ( 0 0$1 ) ;
14652: LD_INT 35
14654: PPUSH
14655: CALL_OW 67
// for un in tmp do
14659: LD_ADDR_VAR 0 2
14663: PUSH
14664: LD_VAR 0 3
14668: PUSH
14669: FOR_IN
14670: IFFALSE 14744
// begin if IsDead ( un ) then
14672: LD_VAR 0 2
14676: PPUSH
14677: CALL_OW 301
14681: IFFALSE 14701
// begin tmp := tmp diff un ;
14683: LD_ADDR_VAR 0 3
14687: PUSH
14688: LD_VAR 0 3
14692: PUSH
14693: LD_VAR 0 2
14697: DIFF
14698: ST_TO_ADDR
// continue ;
14699: GO 14669
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
14701: LD_VAR 0 2
14705: PPUSH
14706: LD_INT 3
14708: PUSH
14709: LD_INT 22
14711: PUSH
14712: LD_INT 0
14714: PUSH
14715: EMPTY
14716: LIST
14717: LIST
14718: PUSH
14719: EMPTY
14720: LIST
14721: LIST
14722: PPUSH
14723: CALL_OW 69
14727: PPUSH
14728: LD_VAR 0 2
14732: PPUSH
14733: CALL_OW 74
14737: PPUSH
14738: CALL_OW 115
// end ;
14742: GO 14669
14744: POP
14745: POP
// until not tmp ;
14746: LD_VAR 0 3
14750: NOT
14751: IFFALSE 14652
// end ;
14753: PPOPN 3
14755: END
// every 0 0$1 trigger StreamModeActive and sTroll do
14756: LD_EXP 19
14760: PUSH
14761: LD_EXP 44
14765: AND
14766: IFFALSE 14820
14768: GO 14770
14770: DISABLE
// begin ToLua ( displayTroll(); ) ;
14771: LD_STRING displayTroll();
14773: PPUSH
14774: CALL_OW 559
// wait ( 3 3$00 ) ;
14778: LD_INT 6300
14780: PPUSH
14781: CALL_OW 67
// ToLua ( hideTroll(); ) ;
14785: LD_STRING hideTroll();
14787: PPUSH
14788: CALL_OW 559
// wait ( 1 1$00 ) ;
14792: LD_INT 2100
14794: PPUSH
14795: CALL_OW 67
// ToLua ( displayTroll(); ) ;
14799: LD_STRING displayTroll();
14801: PPUSH
14802: CALL_OW 559
// wait ( 1 1$00 ) ;
14806: LD_INT 2100
14808: PPUSH
14809: CALL_OW 67
// ToLua ( hideTroll(); ) ;
14813: LD_STRING hideTroll();
14815: PPUSH
14816: CALL_OW 559
// end ;
14820: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
14821: LD_EXP 19
14825: PUSH
14826: LD_EXP 45
14830: AND
14831: IFFALSE 14894
14833: GO 14835
14835: DISABLE
14836: LD_INT 0
14838: PPUSH
// begin p := 0 ;
14839: LD_ADDR_VAR 0 1
14843: PUSH
14844: LD_INT 0
14846: ST_TO_ADDR
// repeat game_speed := 1 ;
14847: LD_ADDR_OWVAR 65
14851: PUSH
14852: LD_INT 1
14854: ST_TO_ADDR
// wait ( 0 0$1 ) ;
14855: LD_INT 35
14857: PPUSH
14858: CALL_OW 67
// p := p + 1 ;
14862: LD_ADDR_VAR 0 1
14866: PUSH
14867: LD_VAR 0 1
14871: PUSH
14872: LD_INT 1
14874: PLUS
14875: ST_TO_ADDR
// until p >= 60 ;
14876: LD_VAR 0 1
14880: PUSH
14881: LD_INT 60
14883: GREATEREQUAL
14884: IFFALSE 14847
// game_speed := 4 ;
14886: LD_ADDR_OWVAR 65
14890: PUSH
14891: LD_INT 4
14893: ST_TO_ADDR
// end ;
14894: PPOPN 1
14896: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
14897: LD_EXP 19
14901: PUSH
14902: LD_EXP 46
14906: AND
14907: IFFALSE 15053
14909: GO 14911
14911: DISABLE
14912: LD_INT 0
14914: PPUSH
14915: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
14916: LD_ADDR_VAR 0 1
14920: PUSH
14921: LD_INT 22
14923: PUSH
14924: LD_OWVAR 2
14928: PUSH
14929: EMPTY
14930: LIST
14931: LIST
14932: PUSH
14933: LD_INT 2
14935: PUSH
14936: LD_INT 30
14938: PUSH
14939: LD_INT 0
14941: PUSH
14942: EMPTY
14943: LIST
14944: LIST
14945: PUSH
14946: LD_INT 30
14948: PUSH
14949: LD_INT 1
14951: PUSH
14952: EMPTY
14953: LIST
14954: LIST
14955: PUSH
14956: EMPTY
14957: LIST
14958: LIST
14959: LIST
14960: PUSH
14961: EMPTY
14962: LIST
14963: LIST
14964: PPUSH
14965: CALL_OW 69
14969: ST_TO_ADDR
// if not depot then
14970: LD_VAR 0 1
14974: NOT
14975: IFFALSE 14979
// exit ;
14977: GO 15053
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
14979: LD_ADDR_VAR 0 2
14983: PUSH
14984: LD_VAR 0 1
14988: PUSH
14989: LD_INT 1
14991: PPUSH
14992: LD_VAR 0 1
14996: PPUSH
14997: CALL_OW 12
15001: ARRAY
15002: PPUSH
15003: CALL_OW 274
15007: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
15008: LD_VAR 0 2
15012: PPUSH
15013: LD_INT 1
15015: PPUSH
15016: LD_INT 0
15018: PPUSH
15019: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
15023: LD_VAR 0 2
15027: PPUSH
15028: LD_INT 2
15030: PPUSH
15031: LD_INT 0
15033: PPUSH
15034: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
15038: LD_VAR 0 2
15042: PPUSH
15043: LD_INT 3
15045: PPUSH
15046: LD_INT 0
15048: PPUSH
15049: CALL_OW 277
// end ;
15053: PPOPN 2
15055: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
15056: LD_EXP 19
15060: PUSH
15061: LD_EXP 47
15065: AND
15066: IFFALSE 15163
15068: GO 15070
15070: DISABLE
15071: LD_INT 0
15073: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
15074: LD_ADDR_VAR 0 1
15078: PUSH
15079: LD_INT 22
15081: PUSH
15082: LD_OWVAR 2
15086: PUSH
15087: EMPTY
15088: LIST
15089: LIST
15090: PUSH
15091: LD_INT 21
15093: PUSH
15094: LD_INT 1
15096: PUSH
15097: EMPTY
15098: LIST
15099: LIST
15100: PUSH
15101: LD_INT 3
15103: PUSH
15104: LD_INT 23
15106: PUSH
15107: LD_INT 0
15109: PUSH
15110: EMPTY
15111: LIST
15112: LIST
15113: PUSH
15114: EMPTY
15115: LIST
15116: LIST
15117: PUSH
15118: EMPTY
15119: LIST
15120: LIST
15121: LIST
15122: PPUSH
15123: CALL_OW 69
15127: ST_TO_ADDR
// if not tmp then
15128: LD_VAR 0 1
15132: NOT
15133: IFFALSE 15137
// exit ;
15135: GO 15163
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
15137: LD_VAR 0 1
15141: PUSH
15142: LD_INT 1
15144: PPUSH
15145: LD_VAR 0 1
15149: PPUSH
15150: CALL_OW 12
15154: ARRAY
15155: PPUSH
15156: LD_INT 200
15158: PPUSH
15159: CALL_OW 234
// end ;
15163: PPOPN 1
15165: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
15166: LD_EXP 19
15170: PUSH
15171: LD_EXP 48
15175: AND
15176: IFFALSE 15255
15178: GO 15180
15180: DISABLE
15181: LD_INT 0
15183: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
15184: LD_ADDR_VAR 0 1
15188: PUSH
15189: LD_INT 22
15191: PUSH
15192: LD_OWVAR 2
15196: PUSH
15197: EMPTY
15198: LIST
15199: LIST
15200: PUSH
15201: LD_INT 21
15203: PUSH
15204: LD_INT 2
15206: PUSH
15207: EMPTY
15208: LIST
15209: LIST
15210: PUSH
15211: EMPTY
15212: LIST
15213: LIST
15214: PPUSH
15215: CALL_OW 69
15219: ST_TO_ADDR
// if not tmp then
15220: LD_VAR 0 1
15224: NOT
15225: IFFALSE 15229
// exit ;
15227: GO 15255
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
15229: LD_VAR 0 1
15233: PUSH
15234: LD_INT 1
15236: PPUSH
15237: LD_VAR 0 1
15241: PPUSH
15242: CALL_OW 12
15246: ARRAY
15247: PPUSH
15248: LD_INT 60
15250: PPUSH
15251: CALL_OW 234
// end ;
15255: PPOPN 1
15257: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
15258: LD_EXP 19
15262: PUSH
15263: LD_EXP 49
15267: AND
15268: IFFALSE 15367
15270: GO 15272
15272: DISABLE
15273: LD_INT 0
15275: PPUSH
15276: PPUSH
// begin enable ;
15277: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
15278: LD_ADDR_VAR 0 1
15282: PUSH
15283: LD_INT 22
15285: PUSH
15286: LD_OWVAR 2
15290: PUSH
15291: EMPTY
15292: LIST
15293: LIST
15294: PUSH
15295: LD_INT 61
15297: PUSH
15298: EMPTY
15299: LIST
15300: PUSH
15301: LD_INT 33
15303: PUSH
15304: LD_INT 2
15306: PUSH
15307: EMPTY
15308: LIST
15309: LIST
15310: PUSH
15311: EMPTY
15312: LIST
15313: LIST
15314: LIST
15315: PPUSH
15316: CALL_OW 69
15320: ST_TO_ADDR
// if not tmp then
15321: LD_VAR 0 1
15325: NOT
15326: IFFALSE 15330
// exit ;
15328: GO 15367
// for i in tmp do
15330: LD_ADDR_VAR 0 2
15334: PUSH
15335: LD_VAR 0 1
15339: PUSH
15340: FOR_IN
15341: IFFALSE 15365
// if IsControledBy ( i ) then
15343: LD_VAR 0 2
15347: PPUSH
15348: CALL_OW 312
15352: IFFALSE 15363
// ComUnlink ( i ) ;
15354: LD_VAR 0 2
15358: PPUSH
15359: CALL_OW 136
15363: GO 15340
15365: POP
15366: POP
// end ;
15367: PPOPN 2
15369: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
15370: LD_EXP 19
15374: PUSH
15375: LD_EXP 50
15379: AND
15380: IFFALSE 15520
15382: GO 15384
15384: DISABLE
15385: LD_INT 0
15387: PPUSH
15388: PPUSH
// begin ToLua ( displayPowell(); ) ;
15389: LD_STRING displayPowell();
15391: PPUSH
15392: CALL_OW 559
// uc_side := 0 ;
15396: LD_ADDR_OWVAR 20
15400: PUSH
15401: LD_INT 0
15403: ST_TO_ADDR
// uc_nation := 2 ;
15404: LD_ADDR_OWVAR 21
15408: PUSH
15409: LD_INT 2
15411: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
15412: LD_ADDR_OWVAR 37
15416: PUSH
15417: LD_INT 14
15419: ST_TO_ADDR
// vc_engine := engine_siberite ;
15420: LD_ADDR_OWVAR 39
15424: PUSH
15425: LD_INT 3
15427: ST_TO_ADDR
// vc_control := control_apeman ;
15428: LD_ADDR_OWVAR 38
15432: PUSH
15433: LD_INT 5
15435: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
15436: LD_ADDR_OWVAR 40
15440: PUSH
15441: LD_INT 29
15443: ST_TO_ADDR
// un := CreateVehicle ;
15444: LD_ADDR_VAR 0 2
15448: PUSH
15449: CALL_OW 45
15453: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
15454: LD_VAR 0 2
15458: PPUSH
15459: LD_INT 1
15461: PPUSH
15462: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
15466: LD_INT 35
15468: PPUSH
15469: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
15473: LD_VAR 0 2
15477: PPUSH
15478: LD_INT 22
15480: PUSH
15481: LD_OWVAR 2
15485: PUSH
15486: EMPTY
15487: LIST
15488: LIST
15489: PPUSH
15490: CALL_OW 69
15494: PPUSH
15495: LD_VAR 0 2
15499: PPUSH
15500: CALL_OW 74
15504: PPUSH
15505: CALL_OW 115
// until IsDead ( un ) ;
15509: LD_VAR 0 2
15513: PPUSH
15514: CALL_OW 301
15518: IFFALSE 15466
// end ;
15520: PPOPN 2
15522: END
// every 0 0$1 trigger StreamModeActive and sStu do
15523: LD_EXP 19
15527: PUSH
15528: LD_EXP 58
15532: AND
15533: IFFALSE 15549
15535: GO 15537
15537: DISABLE
// begin ToLua ( displayStucuk(); ) ;
15538: LD_STRING displayStucuk();
15540: PPUSH
15541: CALL_OW 559
// ResetFog ;
15545: CALL_OW 335
// end ;
15549: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
15550: LD_EXP 19
15554: PUSH
15555: LD_EXP 51
15559: AND
15560: IFFALSE 15701
15562: GO 15564
15564: DISABLE
15565: LD_INT 0
15567: PPUSH
15568: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
15569: LD_ADDR_VAR 0 2
15573: PUSH
15574: LD_INT 22
15576: PUSH
15577: LD_OWVAR 2
15581: PUSH
15582: EMPTY
15583: LIST
15584: LIST
15585: PUSH
15586: LD_INT 21
15588: PUSH
15589: LD_INT 1
15591: PUSH
15592: EMPTY
15593: LIST
15594: LIST
15595: PUSH
15596: EMPTY
15597: LIST
15598: LIST
15599: PPUSH
15600: CALL_OW 69
15604: ST_TO_ADDR
// if not tmp then
15605: LD_VAR 0 2
15609: NOT
15610: IFFALSE 15614
// exit ;
15612: GO 15701
// un := tmp [ rand ( 1 , tmp ) ] ;
15614: LD_ADDR_VAR 0 1
15618: PUSH
15619: LD_VAR 0 2
15623: PUSH
15624: LD_INT 1
15626: PPUSH
15627: LD_VAR 0 2
15631: PPUSH
15632: CALL_OW 12
15636: ARRAY
15637: ST_TO_ADDR
// SetSide ( un , 0 ) ;
15638: LD_VAR 0 1
15642: PPUSH
15643: LD_INT 0
15645: PPUSH
15646: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
15650: LD_VAR 0 1
15654: PPUSH
15655: LD_OWVAR 3
15659: PUSH
15660: LD_VAR 0 1
15664: DIFF
15665: PPUSH
15666: LD_VAR 0 1
15670: PPUSH
15671: CALL_OW 74
15675: PPUSH
15676: CALL_OW 115
// wait ( 0 0$20 ) ;
15680: LD_INT 700
15682: PPUSH
15683: CALL_OW 67
// SetSide ( un , your_side ) ;
15687: LD_VAR 0 1
15691: PPUSH
15692: LD_OWVAR 2
15696: PPUSH
15697: CALL_OW 235
// end ;
15701: PPOPN 2
15703: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
15704: LD_EXP 19
15708: PUSH
15709: LD_EXP 52
15713: AND
15714: IFFALSE 15820
15716: GO 15718
15718: DISABLE
15719: LD_INT 0
15721: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
15722: LD_ADDR_VAR 0 1
15726: PUSH
15727: LD_INT 22
15729: PUSH
15730: LD_OWVAR 2
15734: PUSH
15735: EMPTY
15736: LIST
15737: LIST
15738: PUSH
15739: LD_INT 2
15741: PUSH
15742: LD_INT 30
15744: PUSH
15745: LD_INT 0
15747: PUSH
15748: EMPTY
15749: LIST
15750: LIST
15751: PUSH
15752: LD_INT 30
15754: PUSH
15755: LD_INT 1
15757: PUSH
15758: EMPTY
15759: LIST
15760: LIST
15761: PUSH
15762: EMPTY
15763: LIST
15764: LIST
15765: LIST
15766: PUSH
15767: EMPTY
15768: LIST
15769: LIST
15770: PPUSH
15771: CALL_OW 69
15775: ST_TO_ADDR
// if not depot then
15776: LD_VAR 0 1
15780: NOT
15781: IFFALSE 15785
// exit ;
15783: GO 15820
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
15785: LD_VAR 0 1
15789: PUSH
15790: LD_INT 1
15792: ARRAY
15793: PPUSH
15794: CALL_OW 250
15798: PPUSH
15799: LD_VAR 0 1
15803: PUSH
15804: LD_INT 1
15806: ARRAY
15807: PPUSH
15808: CALL_OW 251
15812: PPUSH
15813: LD_INT 70
15815: PPUSH
15816: CALL_OW 495
// end ;
15820: PPOPN 1
15822: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
15823: LD_EXP 19
15827: PUSH
15828: LD_EXP 53
15832: AND
15833: IFFALSE 16044
15835: GO 15837
15837: DISABLE
15838: LD_INT 0
15840: PPUSH
15841: PPUSH
15842: PPUSH
15843: PPUSH
15844: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
15845: LD_ADDR_VAR 0 5
15849: PUSH
15850: LD_INT 22
15852: PUSH
15853: LD_OWVAR 2
15857: PUSH
15858: EMPTY
15859: LIST
15860: LIST
15861: PUSH
15862: LD_INT 21
15864: PUSH
15865: LD_INT 1
15867: PUSH
15868: EMPTY
15869: LIST
15870: LIST
15871: PUSH
15872: EMPTY
15873: LIST
15874: LIST
15875: PPUSH
15876: CALL_OW 69
15880: ST_TO_ADDR
// if not tmp then
15881: LD_VAR 0 5
15885: NOT
15886: IFFALSE 15890
// exit ;
15888: GO 16044
// for i in tmp do
15890: LD_ADDR_VAR 0 1
15894: PUSH
15895: LD_VAR 0 5
15899: PUSH
15900: FOR_IN
15901: IFFALSE 16042
// begin d := rand ( 0 , 5 ) ;
15903: LD_ADDR_VAR 0 4
15907: PUSH
15908: LD_INT 0
15910: PPUSH
15911: LD_INT 5
15913: PPUSH
15914: CALL_OW 12
15918: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
15919: LD_ADDR_VAR 0 2
15923: PUSH
15924: LD_VAR 0 1
15928: PPUSH
15929: CALL_OW 250
15933: PPUSH
15934: LD_VAR 0 4
15938: PPUSH
15939: LD_INT 3
15941: PPUSH
15942: LD_INT 12
15944: PPUSH
15945: CALL_OW 12
15949: PPUSH
15950: CALL_OW 272
15954: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
15955: LD_ADDR_VAR 0 3
15959: PUSH
15960: LD_VAR 0 1
15964: PPUSH
15965: CALL_OW 251
15969: PPUSH
15970: LD_VAR 0 4
15974: PPUSH
15975: LD_INT 3
15977: PPUSH
15978: LD_INT 12
15980: PPUSH
15981: CALL_OW 12
15985: PPUSH
15986: CALL_OW 273
15990: ST_TO_ADDR
// if ValidHex ( x , y ) then
15991: LD_VAR 0 2
15995: PPUSH
15996: LD_VAR 0 3
16000: PPUSH
16001: CALL_OW 488
16005: IFFALSE 16040
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
16007: LD_VAR 0 1
16011: PPUSH
16012: LD_VAR 0 2
16016: PPUSH
16017: LD_VAR 0 3
16021: PPUSH
16022: LD_INT 3
16024: PPUSH
16025: LD_INT 6
16027: PPUSH
16028: CALL_OW 12
16032: PPUSH
16033: LD_INT 1
16035: PPUSH
16036: CALL_OW 483
// end ;
16040: GO 15900
16042: POP
16043: POP
// end ;
16044: PPOPN 5
16046: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
16047: LD_EXP 19
16051: PUSH
16052: LD_EXP 54
16056: AND
16057: IFFALSE 16151
16059: GO 16061
16061: DISABLE
16062: LD_INT 0
16064: PPUSH
16065: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
16066: LD_ADDR_VAR 0 2
16070: PUSH
16071: LD_INT 22
16073: PUSH
16074: LD_OWVAR 2
16078: PUSH
16079: EMPTY
16080: LIST
16081: LIST
16082: PUSH
16083: LD_INT 32
16085: PUSH
16086: LD_INT 1
16088: PUSH
16089: EMPTY
16090: LIST
16091: LIST
16092: PUSH
16093: LD_INT 21
16095: PUSH
16096: LD_INT 2
16098: PUSH
16099: EMPTY
16100: LIST
16101: LIST
16102: PUSH
16103: EMPTY
16104: LIST
16105: LIST
16106: LIST
16107: PPUSH
16108: CALL_OW 69
16112: ST_TO_ADDR
// if not tmp then
16113: LD_VAR 0 2
16117: NOT
16118: IFFALSE 16122
// exit ;
16120: GO 16151
// for i in tmp do
16122: LD_ADDR_VAR 0 1
16126: PUSH
16127: LD_VAR 0 2
16131: PUSH
16132: FOR_IN
16133: IFFALSE 16149
// SetFuel ( i , 0 ) ;
16135: LD_VAR 0 1
16139: PPUSH
16140: LD_INT 0
16142: PPUSH
16143: CALL_OW 240
16147: GO 16132
16149: POP
16150: POP
// end ;
16151: PPOPN 2
16153: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
16154: LD_EXP 19
16158: PUSH
16159: LD_EXP 55
16163: AND
16164: IFFALSE 16230
16166: GO 16168
16168: DISABLE
16169: LD_INT 0
16171: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
16172: LD_ADDR_VAR 0 1
16176: PUSH
16177: LD_INT 22
16179: PUSH
16180: LD_OWVAR 2
16184: PUSH
16185: EMPTY
16186: LIST
16187: LIST
16188: PUSH
16189: LD_INT 30
16191: PUSH
16192: LD_INT 29
16194: PUSH
16195: EMPTY
16196: LIST
16197: LIST
16198: PUSH
16199: EMPTY
16200: LIST
16201: LIST
16202: PPUSH
16203: CALL_OW 69
16207: ST_TO_ADDR
// if not tmp then
16208: LD_VAR 0 1
16212: NOT
16213: IFFALSE 16217
// exit ;
16215: GO 16230
// DestroyUnit ( tmp [ 1 ] ) ;
16217: LD_VAR 0 1
16221: PUSH
16222: LD_INT 1
16224: ARRAY
16225: PPUSH
16226: CALL_OW 65
// end ;
16230: PPOPN 1
16232: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
16233: LD_EXP 19
16237: PUSH
16238: LD_EXP 57
16242: AND
16243: IFFALSE 16372
16245: GO 16247
16247: DISABLE
16248: LD_INT 0
16250: PPUSH
// begin uc_side := 0 ;
16251: LD_ADDR_OWVAR 20
16255: PUSH
16256: LD_INT 0
16258: ST_TO_ADDR
// uc_nation := nation_arabian ;
16259: LD_ADDR_OWVAR 21
16263: PUSH
16264: LD_INT 2
16266: ST_TO_ADDR
// hc_gallery :=  ;
16267: LD_ADDR_OWVAR 33
16271: PUSH
16272: LD_STRING 
16274: ST_TO_ADDR
// hc_name :=  ;
16275: LD_ADDR_OWVAR 26
16279: PUSH
16280: LD_STRING 
16282: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
16283: LD_INT 1
16285: PPUSH
16286: LD_INT 11
16288: PPUSH
16289: LD_INT 10
16291: PPUSH
16292: CALL_OW 380
// un := CreateHuman ;
16296: LD_ADDR_VAR 0 1
16300: PUSH
16301: CALL_OW 44
16305: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
16306: LD_VAR 0 1
16310: PPUSH
16311: LD_INT 1
16313: PPUSH
16314: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
16318: LD_INT 35
16320: PPUSH
16321: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
16325: LD_VAR 0 1
16329: PPUSH
16330: LD_INT 22
16332: PUSH
16333: LD_OWVAR 2
16337: PUSH
16338: EMPTY
16339: LIST
16340: LIST
16341: PPUSH
16342: CALL_OW 69
16346: PPUSH
16347: LD_VAR 0 1
16351: PPUSH
16352: CALL_OW 74
16356: PPUSH
16357: CALL_OW 115
// until IsDead ( un ) ;
16361: LD_VAR 0 1
16365: PPUSH
16366: CALL_OW 301
16370: IFFALSE 16318
// end ;
16372: PPOPN 1
16374: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
16375: LD_EXP 19
16379: PUSH
16380: LD_EXP 59
16384: AND
16385: IFFALSE 16397
16387: GO 16389
16389: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
16390: LD_STRING earthquake(getX(game), 0, 32)
16392: PPUSH
16393: CALL_OW 559
16397: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
16398: LD_EXP 19
16402: PUSH
16403: LD_EXP 60
16407: AND
16408: IFFALSE 16499
16410: GO 16412
16412: DISABLE
16413: LD_INT 0
16415: PPUSH
// begin enable ;
16416: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
16417: LD_ADDR_VAR 0 1
16421: PUSH
16422: LD_INT 22
16424: PUSH
16425: LD_OWVAR 2
16429: PUSH
16430: EMPTY
16431: LIST
16432: LIST
16433: PUSH
16434: LD_INT 21
16436: PUSH
16437: LD_INT 2
16439: PUSH
16440: EMPTY
16441: LIST
16442: LIST
16443: PUSH
16444: LD_INT 33
16446: PUSH
16447: LD_INT 3
16449: PUSH
16450: EMPTY
16451: LIST
16452: LIST
16453: PUSH
16454: EMPTY
16455: LIST
16456: LIST
16457: LIST
16458: PPUSH
16459: CALL_OW 69
16463: ST_TO_ADDR
// if not tmp then
16464: LD_VAR 0 1
16468: NOT
16469: IFFALSE 16473
// exit ;
16471: GO 16499
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
16473: LD_VAR 0 1
16477: PUSH
16478: LD_INT 1
16480: PPUSH
16481: LD_VAR 0 1
16485: PPUSH
16486: CALL_OW 12
16490: ARRAY
16491: PPUSH
16492: LD_INT 1
16494: PPUSH
16495: CALL_OW 234
// end ;
16499: PPOPN 1
16501: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
16502: LD_EXP 19
16506: PUSH
16507: LD_EXP 61
16511: AND
16512: IFFALSE 16653
16514: GO 16516
16516: DISABLE
16517: LD_INT 0
16519: PPUSH
16520: PPUSH
16521: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
16522: LD_ADDR_VAR 0 3
16526: PUSH
16527: LD_INT 22
16529: PUSH
16530: LD_OWVAR 2
16534: PUSH
16535: EMPTY
16536: LIST
16537: LIST
16538: PUSH
16539: LD_INT 25
16541: PUSH
16542: LD_INT 1
16544: PUSH
16545: EMPTY
16546: LIST
16547: LIST
16548: PUSH
16549: EMPTY
16550: LIST
16551: LIST
16552: PPUSH
16553: CALL_OW 69
16557: ST_TO_ADDR
// if not tmp then
16558: LD_VAR 0 3
16562: NOT
16563: IFFALSE 16567
// exit ;
16565: GO 16653
// un := tmp [ rand ( 1 , tmp ) ] ;
16567: LD_ADDR_VAR 0 2
16571: PUSH
16572: LD_VAR 0 3
16576: PUSH
16577: LD_INT 1
16579: PPUSH
16580: LD_VAR 0 3
16584: PPUSH
16585: CALL_OW 12
16589: ARRAY
16590: ST_TO_ADDR
// if Crawls ( un ) then
16591: LD_VAR 0 2
16595: PPUSH
16596: CALL_OW 318
16600: IFFALSE 16611
// ComWalk ( un ) ;
16602: LD_VAR 0 2
16606: PPUSH
16607: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
16611: LD_VAR 0 2
16615: PPUSH
16616: LD_INT 9
16618: PPUSH
16619: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
16623: LD_INT 28
16625: PPUSH
16626: LD_OWVAR 2
16630: PPUSH
16631: LD_INT 2
16633: PPUSH
16634: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
16638: LD_INT 29
16640: PPUSH
16641: LD_OWVAR 2
16645: PPUSH
16646: LD_INT 2
16648: PPUSH
16649: CALL_OW 322
// end ;
16653: PPOPN 3
16655: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
16656: LD_EXP 19
16660: PUSH
16661: LD_EXP 62
16665: AND
16666: IFFALSE 16777
16668: GO 16670
16670: DISABLE
16671: LD_INT 0
16673: PPUSH
16674: PPUSH
16675: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
16676: LD_ADDR_VAR 0 3
16680: PUSH
16681: LD_INT 22
16683: PUSH
16684: LD_OWVAR 2
16688: PUSH
16689: EMPTY
16690: LIST
16691: LIST
16692: PUSH
16693: LD_INT 25
16695: PUSH
16696: LD_INT 1
16698: PUSH
16699: EMPTY
16700: LIST
16701: LIST
16702: PUSH
16703: EMPTY
16704: LIST
16705: LIST
16706: PPUSH
16707: CALL_OW 69
16711: ST_TO_ADDR
// if not tmp then
16712: LD_VAR 0 3
16716: NOT
16717: IFFALSE 16721
// exit ;
16719: GO 16777
// un := tmp [ rand ( 1 , tmp ) ] ;
16721: LD_ADDR_VAR 0 2
16725: PUSH
16726: LD_VAR 0 3
16730: PUSH
16731: LD_INT 1
16733: PPUSH
16734: LD_VAR 0 3
16738: PPUSH
16739: CALL_OW 12
16743: ARRAY
16744: ST_TO_ADDR
// if Crawls ( un ) then
16745: LD_VAR 0 2
16749: PPUSH
16750: CALL_OW 318
16754: IFFALSE 16765
// ComWalk ( un ) ;
16756: LD_VAR 0 2
16760: PPUSH
16761: CALL_OW 138
// SetClass ( un , class_mortar ) ;
16765: LD_VAR 0 2
16769: PPUSH
16770: LD_INT 8
16772: PPUSH
16773: CALL_OW 336
// end ;
16777: PPOPN 3
16779: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
16780: LD_EXP 19
16784: PUSH
16785: LD_EXP 63
16789: AND
16790: IFFALSE 16934
16792: GO 16794
16794: DISABLE
16795: LD_INT 0
16797: PPUSH
16798: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
16799: LD_ADDR_VAR 0 2
16803: PUSH
16804: LD_INT 22
16806: PUSH
16807: LD_OWVAR 2
16811: PUSH
16812: EMPTY
16813: LIST
16814: LIST
16815: PUSH
16816: LD_INT 21
16818: PUSH
16819: LD_INT 2
16821: PUSH
16822: EMPTY
16823: LIST
16824: LIST
16825: PUSH
16826: LD_INT 2
16828: PUSH
16829: LD_INT 34
16831: PUSH
16832: LD_INT 12
16834: PUSH
16835: EMPTY
16836: LIST
16837: LIST
16838: PUSH
16839: LD_INT 34
16841: PUSH
16842: LD_INT 51
16844: PUSH
16845: EMPTY
16846: LIST
16847: LIST
16848: PUSH
16849: LD_INT 34
16851: PUSH
16852: LD_INT 32
16854: PUSH
16855: EMPTY
16856: LIST
16857: LIST
16858: PUSH
16859: EMPTY
16860: LIST
16861: LIST
16862: LIST
16863: LIST
16864: PUSH
16865: EMPTY
16866: LIST
16867: LIST
16868: LIST
16869: PPUSH
16870: CALL_OW 69
16874: ST_TO_ADDR
// if not tmp then
16875: LD_VAR 0 2
16879: NOT
16880: IFFALSE 16884
// exit ;
16882: GO 16934
// for i in tmp do
16884: LD_ADDR_VAR 0 1
16888: PUSH
16889: LD_VAR 0 2
16893: PUSH
16894: FOR_IN
16895: IFFALSE 16932
// if GetCargo ( i , mat_artifact ) = 0 then
16897: LD_VAR 0 1
16901: PPUSH
16902: LD_INT 4
16904: PPUSH
16905: CALL_OW 289
16909: PUSH
16910: LD_INT 0
16912: EQUAL
16913: IFFALSE 16930
// SetCargo ( i , mat_siberit , 100 ) ;
16915: LD_VAR 0 1
16919: PPUSH
16920: LD_INT 3
16922: PPUSH
16923: LD_INT 100
16925: PPUSH
16926: CALL_OW 290
16930: GO 16894
16932: POP
16933: POP
// end ;
16934: PPOPN 2
16936: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
16937: LD_EXP 19
16941: PUSH
16942: LD_EXP 64
16946: AND
16947: IFFALSE 17100
16949: GO 16951
16951: DISABLE
16952: LD_INT 0
16954: PPUSH
16955: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
16956: LD_ADDR_VAR 0 2
16960: PUSH
16961: LD_INT 22
16963: PUSH
16964: LD_OWVAR 2
16968: PUSH
16969: EMPTY
16970: LIST
16971: LIST
16972: PPUSH
16973: CALL_OW 69
16977: ST_TO_ADDR
// if not tmp then
16978: LD_VAR 0 2
16982: NOT
16983: IFFALSE 16987
// exit ;
16985: GO 17100
// for i := 1 to 2 do
16987: LD_ADDR_VAR 0 1
16991: PUSH
16992: DOUBLE
16993: LD_INT 1
16995: DEC
16996: ST_TO_ADDR
16997: LD_INT 2
16999: PUSH
17000: FOR_TO
17001: IFFALSE 17098
// begin uc_side := your_side ;
17003: LD_ADDR_OWVAR 20
17007: PUSH
17008: LD_OWVAR 2
17012: ST_TO_ADDR
// uc_nation := nation_american ;
17013: LD_ADDR_OWVAR 21
17017: PUSH
17018: LD_INT 1
17020: ST_TO_ADDR
// vc_chassis := us_morphling ;
17021: LD_ADDR_OWVAR 37
17025: PUSH
17026: LD_INT 5
17028: ST_TO_ADDR
// vc_engine := engine_siberite ;
17029: LD_ADDR_OWVAR 39
17033: PUSH
17034: LD_INT 3
17036: ST_TO_ADDR
// vc_control := control_computer ;
17037: LD_ADDR_OWVAR 38
17041: PUSH
17042: LD_INT 3
17044: ST_TO_ADDR
// vc_weapon := us_double_laser ;
17045: LD_ADDR_OWVAR 40
17049: PUSH
17050: LD_INT 10
17052: ST_TO_ADDR
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) ;
17053: CALL_OW 45
17057: PPUSH
17058: LD_VAR 0 2
17062: PUSH
17063: LD_INT 1
17065: ARRAY
17066: PPUSH
17067: CALL_OW 250
17071: PPUSH
17072: LD_VAR 0 2
17076: PUSH
17077: LD_INT 1
17079: ARRAY
17080: PPUSH
17081: CALL_OW 251
17085: PPUSH
17086: LD_INT 12
17088: PPUSH
17089: LD_INT 1
17091: PPUSH
17092: CALL_OW 50
// end ;
17096: GO 17000
17098: POP
17099: POP
// end ;
17100: PPOPN 2
17102: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
17103: LD_EXP 19
17107: PUSH
17108: LD_EXP 65
17112: AND
17113: IFFALSE 17335
17115: GO 17117
17117: DISABLE
17118: LD_INT 0
17120: PPUSH
17121: PPUSH
17122: PPUSH
17123: PPUSH
17124: PPUSH
17125: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
17126: LD_ADDR_VAR 0 6
17130: PUSH
17131: LD_INT 22
17133: PUSH
17134: LD_OWVAR 2
17138: PUSH
17139: EMPTY
17140: LIST
17141: LIST
17142: PUSH
17143: LD_INT 21
17145: PUSH
17146: LD_INT 1
17148: PUSH
17149: EMPTY
17150: LIST
17151: LIST
17152: PUSH
17153: LD_INT 3
17155: PUSH
17156: LD_INT 23
17158: PUSH
17159: LD_INT 0
17161: PUSH
17162: EMPTY
17163: LIST
17164: LIST
17165: PUSH
17166: EMPTY
17167: LIST
17168: LIST
17169: PUSH
17170: EMPTY
17171: LIST
17172: LIST
17173: LIST
17174: PPUSH
17175: CALL_OW 69
17179: ST_TO_ADDR
// if not tmp then
17180: LD_VAR 0 6
17184: NOT
17185: IFFALSE 17189
// exit ;
17187: GO 17335
// s1 := rand ( 1 , 4 ) ;
17189: LD_ADDR_VAR 0 2
17193: PUSH
17194: LD_INT 1
17196: PPUSH
17197: LD_INT 4
17199: PPUSH
17200: CALL_OW 12
17204: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
17205: LD_ADDR_VAR 0 4
17209: PUSH
17210: LD_VAR 0 6
17214: PUSH
17215: LD_INT 1
17217: ARRAY
17218: PPUSH
17219: LD_VAR 0 2
17223: PPUSH
17224: CALL_OW 259
17228: ST_TO_ADDR
// if s1 = 1 then
17229: LD_VAR 0 2
17233: PUSH
17234: LD_INT 1
17236: EQUAL
17237: IFFALSE 17257
// s2 := rand ( 2 , 4 ) else
17239: LD_ADDR_VAR 0 3
17243: PUSH
17244: LD_INT 2
17246: PPUSH
17247: LD_INT 4
17249: PPUSH
17250: CALL_OW 12
17254: ST_TO_ADDR
17255: GO 17265
// s2 := 1 ;
17257: LD_ADDR_VAR 0 3
17261: PUSH
17262: LD_INT 1
17264: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
17265: LD_ADDR_VAR 0 5
17269: PUSH
17270: LD_VAR 0 6
17274: PUSH
17275: LD_INT 1
17277: ARRAY
17278: PPUSH
17279: LD_VAR 0 3
17283: PPUSH
17284: CALL_OW 259
17288: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
17289: LD_VAR 0 6
17293: PUSH
17294: LD_INT 1
17296: ARRAY
17297: PPUSH
17298: LD_VAR 0 2
17302: PPUSH
17303: LD_VAR 0 5
17307: PPUSH
17308: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
17312: LD_VAR 0 6
17316: PUSH
17317: LD_INT 1
17319: ARRAY
17320: PPUSH
17321: LD_VAR 0 3
17325: PPUSH
17326: LD_VAR 0 4
17330: PPUSH
17331: CALL_OW 237
// end ;
17335: PPOPN 6
17337: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
17338: LD_EXP 19
17342: PUSH
17343: LD_EXP 66
17347: AND
17348: IFFALSE 17427
17350: GO 17352
17352: DISABLE
17353: LD_INT 0
17355: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
17356: LD_ADDR_VAR 0 1
17360: PUSH
17361: LD_INT 22
17363: PUSH
17364: LD_OWVAR 2
17368: PUSH
17369: EMPTY
17370: LIST
17371: LIST
17372: PUSH
17373: LD_INT 30
17375: PUSH
17376: LD_INT 3
17378: PUSH
17379: EMPTY
17380: LIST
17381: LIST
17382: PUSH
17383: EMPTY
17384: LIST
17385: LIST
17386: PPUSH
17387: CALL_OW 69
17391: ST_TO_ADDR
// if not tmp then
17392: LD_VAR 0 1
17396: NOT
17397: IFFALSE 17401
// exit ;
17399: GO 17427
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
17401: LD_VAR 0 1
17405: PUSH
17406: LD_INT 1
17408: PPUSH
17409: LD_VAR 0 1
17413: PPUSH
17414: CALL_OW 12
17418: ARRAY
17419: PPUSH
17420: LD_INT 1
17422: PPUSH
17423: CALL_OW 234
// end ;
17427: PPOPN 1
17429: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
17430: LD_EXP 19
17434: PUSH
17435: LD_EXP 67
17439: AND
17440: IFFALSE 17552
17442: GO 17444
17444: DISABLE
17445: LD_INT 0
17447: PPUSH
17448: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
17449: LD_ADDR_VAR 0 2
17453: PUSH
17454: LD_INT 22
17456: PUSH
17457: LD_OWVAR 2
17461: PUSH
17462: EMPTY
17463: LIST
17464: LIST
17465: PUSH
17466: LD_INT 2
17468: PUSH
17469: LD_INT 30
17471: PUSH
17472: LD_INT 27
17474: PUSH
17475: EMPTY
17476: LIST
17477: LIST
17478: PUSH
17479: LD_INT 30
17481: PUSH
17482: LD_INT 26
17484: PUSH
17485: EMPTY
17486: LIST
17487: LIST
17488: PUSH
17489: LD_INT 30
17491: PUSH
17492: LD_INT 28
17494: PUSH
17495: EMPTY
17496: LIST
17497: LIST
17498: PUSH
17499: EMPTY
17500: LIST
17501: LIST
17502: LIST
17503: LIST
17504: PUSH
17505: EMPTY
17506: LIST
17507: LIST
17508: PPUSH
17509: CALL_OW 69
17513: ST_TO_ADDR
// if not tmp then
17514: LD_VAR 0 2
17518: NOT
17519: IFFALSE 17523
// exit ;
17521: GO 17552
// for i in tmp do
17523: LD_ADDR_VAR 0 1
17527: PUSH
17528: LD_VAR 0 2
17532: PUSH
17533: FOR_IN
17534: IFFALSE 17550
// SetLives ( i , 1 ) ;
17536: LD_VAR 0 1
17540: PPUSH
17541: LD_INT 1
17543: PPUSH
17544: CALL_OW 234
17548: GO 17533
17550: POP
17551: POP
// end ;
17552: PPOPN 2
17554: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
17555: LD_EXP 19
17559: PUSH
17560: LD_EXP 68
17564: AND
17565: IFFALSE 17839
17567: GO 17569
17569: DISABLE
17570: LD_INT 0
17572: PPUSH
17573: PPUSH
17574: PPUSH
// begin i := rand ( 1 , 7 ) ;
17575: LD_ADDR_VAR 0 1
17579: PUSH
17580: LD_INT 1
17582: PPUSH
17583: LD_INT 7
17585: PPUSH
17586: CALL_OW 12
17590: ST_TO_ADDR
// case i of 1 :
17591: LD_VAR 0 1
17595: PUSH
17596: LD_INT 1
17598: DOUBLE
17599: EQUAL
17600: IFTRUE 17604
17602: GO 17614
17604: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
17605: LD_STRING earthquake(getX(game), 0, 32)
17607: PPUSH
17608: CALL_OW 559
17612: GO 17839
17614: LD_INT 2
17616: DOUBLE
17617: EQUAL
17618: IFTRUE 17622
17620: GO 17636
17622: POP
// begin ToLua ( displayStucuk(); ) ;
17623: LD_STRING displayStucuk();
17625: PPUSH
17626: CALL_OW 559
// ResetFog ;
17630: CALL_OW 335
// end ; 3 :
17634: GO 17839
17636: LD_INT 3
17638: DOUBLE
17639: EQUAL
17640: IFTRUE 17644
17642: GO 17748
17644: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
17645: LD_ADDR_VAR 0 2
17649: PUSH
17650: LD_INT 22
17652: PUSH
17653: LD_OWVAR 2
17657: PUSH
17658: EMPTY
17659: LIST
17660: LIST
17661: PUSH
17662: LD_INT 25
17664: PUSH
17665: LD_INT 1
17667: PUSH
17668: EMPTY
17669: LIST
17670: LIST
17671: PUSH
17672: EMPTY
17673: LIST
17674: LIST
17675: PPUSH
17676: CALL_OW 69
17680: ST_TO_ADDR
// if not tmp then
17681: LD_VAR 0 2
17685: NOT
17686: IFFALSE 17690
// exit ;
17688: GO 17839
// un := tmp [ rand ( 1 , tmp ) ] ;
17690: LD_ADDR_VAR 0 3
17694: PUSH
17695: LD_VAR 0 2
17699: PUSH
17700: LD_INT 1
17702: PPUSH
17703: LD_VAR 0 2
17707: PPUSH
17708: CALL_OW 12
17712: ARRAY
17713: ST_TO_ADDR
// if Crawls ( un ) then
17714: LD_VAR 0 3
17718: PPUSH
17719: CALL_OW 318
17723: IFFALSE 17734
// ComWalk ( un ) ;
17725: LD_VAR 0 3
17729: PPUSH
17730: CALL_OW 138
// SetClass ( un , class_mortar ) ;
17734: LD_VAR 0 3
17738: PPUSH
17739: LD_INT 8
17741: PPUSH
17742: CALL_OW 336
// end ; 4 :
17746: GO 17839
17748: LD_INT 4
17750: DOUBLE
17751: EQUAL
17752: IFTRUE 17756
17754: GO 17817
17756: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
17757: LD_ADDR_VAR 0 2
17761: PUSH
17762: LD_INT 22
17764: PUSH
17765: LD_OWVAR 2
17769: PUSH
17770: EMPTY
17771: LIST
17772: LIST
17773: PUSH
17774: LD_INT 30
17776: PUSH
17777: LD_INT 29
17779: PUSH
17780: EMPTY
17781: LIST
17782: LIST
17783: PUSH
17784: EMPTY
17785: LIST
17786: LIST
17787: PPUSH
17788: CALL_OW 69
17792: ST_TO_ADDR
// if not tmp then
17793: LD_VAR 0 2
17797: NOT
17798: IFFALSE 17802
// exit ;
17800: GO 17839
// DestroyUnit ( tmp [ 1 ] ) ;
17802: LD_VAR 0 2
17806: PUSH
17807: LD_INT 1
17809: ARRAY
17810: PPUSH
17811: CALL_OW 65
// end ; 5 .. 7 :
17815: GO 17839
17817: LD_INT 5
17819: DOUBLE
17820: GREATEREQUAL
17821: IFFALSE 17829
17823: LD_INT 7
17825: DOUBLE
17826: LESSEQUAL
17827: IFTRUE 17831
17829: GO 17838
17831: POP
// StreamSibBomb ; end ;
17832: CALL 14119 0 0
17836: GO 17839
17838: POP
// end ;
17839: PPOPN 3
17841: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
17842: LD_EXP 19
17846: PUSH
17847: LD_EXP 69
17851: AND
17852: IFFALSE 18008
17854: GO 17856
17856: DISABLE
17857: LD_INT 0
17859: PPUSH
17860: PPUSH
17861: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
17862: LD_ADDR_VAR 0 2
17866: PUSH
17867: LD_INT 81
17869: PUSH
17870: LD_OWVAR 2
17874: PUSH
17875: EMPTY
17876: LIST
17877: LIST
17878: PUSH
17879: LD_INT 2
17881: PUSH
17882: LD_INT 21
17884: PUSH
17885: LD_INT 1
17887: PUSH
17888: EMPTY
17889: LIST
17890: LIST
17891: PUSH
17892: LD_INT 21
17894: PUSH
17895: LD_INT 2
17897: PUSH
17898: EMPTY
17899: LIST
17900: LIST
17901: PUSH
17902: EMPTY
17903: LIST
17904: LIST
17905: LIST
17906: PUSH
17907: EMPTY
17908: LIST
17909: LIST
17910: PPUSH
17911: CALL_OW 69
17915: ST_TO_ADDR
// if not tmp then
17916: LD_VAR 0 2
17920: NOT
17921: IFFALSE 17925
// exit ;
17923: GO 18008
// p := 0 ;
17925: LD_ADDR_VAR 0 3
17929: PUSH
17930: LD_INT 0
17932: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
17933: LD_INT 35
17935: PPUSH
17936: CALL_OW 67
// p := p + 1 ;
17940: LD_ADDR_VAR 0 3
17944: PUSH
17945: LD_VAR 0 3
17949: PUSH
17950: LD_INT 1
17952: PLUS
17953: ST_TO_ADDR
// for i in tmp do
17954: LD_ADDR_VAR 0 1
17958: PUSH
17959: LD_VAR 0 2
17963: PUSH
17964: FOR_IN
17965: IFFALSE 17996
// if GetLives ( i ) < 1000 then
17967: LD_VAR 0 1
17971: PPUSH
17972: CALL_OW 256
17976: PUSH
17977: LD_INT 1000
17979: LESS
17980: IFFALSE 17994
// SetLives ( i , 1000 ) ;
17982: LD_VAR 0 1
17986: PPUSH
17987: LD_INT 1000
17989: PPUSH
17990: CALL_OW 234
17994: GO 17964
17996: POP
17997: POP
// until p > 20 ;
17998: LD_VAR 0 3
18002: PUSH
18003: LD_INT 20
18005: GREATER
18006: IFFALSE 17933
// end ;
18008: PPOPN 3
18010: END
// every 0 0$1 trigger StreamModeActive and sTime do
18011: LD_EXP 19
18015: PUSH
18016: LD_EXP 70
18020: AND
18021: IFFALSE 18056
18023: GO 18025
18025: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
18026: LD_INT 28
18028: PPUSH
18029: LD_OWVAR 2
18033: PPUSH
18034: LD_INT 2
18036: PPUSH
18037: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
18041: LD_INT 30
18043: PPUSH
18044: LD_OWVAR 2
18048: PPUSH
18049: LD_INT 2
18051: PPUSH
18052: CALL_OW 322
// end ;
18056: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
18057: LD_EXP 19
18061: PUSH
18062: LD_EXP 71
18066: AND
18067: IFFALSE 18188
18069: GO 18071
18071: DISABLE
18072: LD_INT 0
18074: PPUSH
18075: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
18076: LD_ADDR_VAR 0 2
18080: PUSH
18081: LD_INT 22
18083: PUSH
18084: LD_OWVAR 2
18088: PUSH
18089: EMPTY
18090: LIST
18091: LIST
18092: PUSH
18093: LD_INT 21
18095: PUSH
18096: LD_INT 1
18098: PUSH
18099: EMPTY
18100: LIST
18101: LIST
18102: PUSH
18103: LD_INT 3
18105: PUSH
18106: LD_INT 23
18108: PUSH
18109: LD_INT 0
18111: PUSH
18112: EMPTY
18113: LIST
18114: LIST
18115: PUSH
18116: EMPTY
18117: LIST
18118: LIST
18119: PUSH
18120: EMPTY
18121: LIST
18122: LIST
18123: LIST
18124: PPUSH
18125: CALL_OW 69
18129: ST_TO_ADDR
// if not tmp then
18130: LD_VAR 0 2
18134: NOT
18135: IFFALSE 18139
// exit ;
18137: GO 18188
// for i in tmp do
18139: LD_ADDR_VAR 0 1
18143: PUSH
18144: LD_VAR 0 2
18148: PUSH
18149: FOR_IN
18150: IFFALSE 18186
// begin if Crawls ( i ) then
18152: LD_VAR 0 1
18156: PPUSH
18157: CALL_OW 318
18161: IFFALSE 18172
// ComWalk ( i ) ;
18163: LD_VAR 0 1
18167: PPUSH
18168: CALL_OW 138
// SetClass ( i , 2 ) ;
18172: LD_VAR 0 1
18176: PPUSH
18177: LD_INT 2
18179: PPUSH
18180: CALL_OW 336
// end ;
18184: GO 18149
18186: POP
18187: POP
// end ;
18188: PPOPN 2
18190: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
18191: LD_EXP 19
18195: PUSH
18196: LD_EXP 72
18200: AND
18201: IFFALSE 18422
18203: GO 18205
18205: DISABLE
18206: LD_INT 0
18208: PPUSH
18209: PPUSH
18210: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
18211: LD_OWVAR 2
18215: PPUSH
18216: LD_INT 9
18218: PPUSH
18219: LD_INT 1
18221: PPUSH
18222: LD_INT 1
18224: PPUSH
18225: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
18229: LD_INT 9
18231: PPUSH
18232: LD_OWVAR 2
18236: PPUSH
18237: CALL_OW 343
// uc_side := 9 ;
18241: LD_ADDR_OWVAR 20
18245: PUSH
18246: LD_INT 9
18248: ST_TO_ADDR
// uc_nation := 2 ;
18249: LD_ADDR_OWVAR 21
18253: PUSH
18254: LD_INT 2
18256: ST_TO_ADDR
// hc_name := Dark Warrior ;
18257: LD_ADDR_OWVAR 26
18261: PUSH
18262: LD_STRING Dark Warrior
18264: ST_TO_ADDR
// hc_gallery :=  ;
18265: LD_ADDR_OWVAR 33
18269: PUSH
18270: LD_STRING 
18272: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , 10 ) ;
18273: LD_INT 1
18275: PPUSH
18276: LD_INT 1
18278: PPUSH
18279: LD_INT 10
18281: PPUSH
18282: CALL_OW 380
// un := CreateHuman ;
18286: LD_ADDR_VAR 0 3
18290: PUSH
18291: CALL_OW 44
18295: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
18296: LD_VAR 0 3
18300: PPUSH
18301: LD_INT 1
18303: PPUSH
18304: CALL_OW 51
// p := 0 ;
18308: LD_ADDR_VAR 0 2
18312: PUSH
18313: LD_INT 0
18315: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
18316: LD_INT 35
18318: PPUSH
18319: CALL_OW 67
// if GetLives ( un ) < 1000 then
18323: LD_VAR 0 3
18327: PPUSH
18328: CALL_OW 256
18332: PUSH
18333: LD_INT 1000
18335: LESS
18336: IFFALSE 18350
// SetLives ( un , 1000 ) ;
18338: LD_VAR 0 3
18342: PPUSH
18343: LD_INT 1000
18345: PPUSH
18346: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , your_side ] ) , un ) ) ;
18350: LD_VAR 0 3
18354: PPUSH
18355: LD_INT 81
18357: PUSH
18358: LD_OWVAR 2
18362: PUSH
18363: EMPTY
18364: LIST
18365: LIST
18366: PPUSH
18367: CALL_OW 69
18371: PPUSH
18372: LD_VAR 0 3
18376: PPUSH
18377: CALL_OW 74
18381: PPUSH
18382: CALL_OW 115
// until p > 60 or IsDead ( un ) ;
18386: LD_VAR 0 2
18390: PUSH
18391: LD_INT 60
18393: GREATER
18394: PUSH
18395: LD_VAR 0 3
18399: PPUSH
18400: CALL_OW 301
18404: OR
18405: IFFALSE 18316
// if un then
18407: LD_VAR 0 3
18411: IFFALSE 18422
// RemoveUnit ( un ) ;
18413: LD_VAR 0 3
18417: PPUSH
18418: CALL_OW 64
// end ;
18422: PPOPN 3
18424: END
