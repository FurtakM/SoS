// starting begin PrepareMap ;
   0: CALL 13 0 0
// Main_Variables ;
   4: CALL 136 0 0
// Start_Mission ;
   8: CALL 3416 0 0
// end ;
  12: END
// function PrepareMap ; begin
  13: LD_INT 0
  15: PPUSH
// ResetFog ;
  16: CALL_OW 335
// RandomizeAll ;
  20: CALL_OW 11
// game_difficulty := GetMultiplayerSetting ( 0 ) ;
  24: LD_ADDR_EXP 2
  28: PUSH
  29: LD_INT 0
  31: PPUSH
  32: CALL_OW 426
  36: ST_TO_ADDR
// Difficulty := game_difficulty ;
  37: LD_ADDR_OWVAR 67
  41: PUSH
  42: LD_EXP 2
  46: ST_TO_ADDR
// ChangeSideFog ( 8 , 6 ) ;
  47: LD_INT 8
  49: PPUSH
  50: LD_INT 6
  52: PPUSH
  53: CALL_OW 343
// PlaceSeeing ( 1 , 1 , 8 , - 37963 ) ;
  57: LD_INT 1
  59: PPUSH
  60: LD_INT 1
  62: PPUSH
  63: LD_INT 8
  65: PPUSH
  66: LD_INT 37963
  68: NEG
  69: PPUSH
  70: CALL_OW 330
// RemoveSeeing ( 1 , 1 , 8 ) ;
  74: LD_INT 1
  76: PPUSH
  77: LD_INT 1
  79: PPUSH
  80: LD_INT 8
  82: PPUSH
  83: CALL_OW 331
// PlaceCamera ;
  87: CALL 3880 0 0
// PrepareNature ( nature , 4 , 3 , 2 , 1 ) ;
  91: LD_INT 2
  93: PPUSH
  94: LD_INT 4
  96: PPUSH
  97: LD_INT 3
  99: PPUSH
 100: LD_INT 2
 102: PPUSH
 103: LD_INT 1
 105: PPUSH
 106: CALL 7745 0 5
// PrepareComm ;
 110: CALL 8228 0 0
// SetSide ( fort , 6 ) ;
 114: LD_INT 23
 116: PPUSH
 117: LD_INT 6
 119: PPUSH
 120: CALL_OW 235
// CenterNowOnUnits ( fort ) ;
 124: LD_INT 23
 126: PPUSH
 127: CALL_OW 87
// end ;
 131: LD_VAR 0 1
 135: RET
// export game_on , game_difficulty , game_time , game_option , game_end , game_strings ; export leopold , leopold_in_fort , samuel , samuel_in_fort , mortars_in_fort , scout ; export u_mine , u_fac ; export areas ; export skill ; export ar_weapons , ru_weapons , us_weapons ; export arabian_force , russian_force , american_force , arabian_timeing , russian_timeing , american_timeing ; export meeting_start , meeting_arive , meeting_break , meeting_end , meeting_time , russian_timer , fort_destroyed , hero_died , mission_time , cargo_ok , american_hchan , dezert , arabian_attack , russian_attack , american_attack , american_help , american_sib_bomb , russian_trade , heike_dialog1 , heike_dialog2 ; export am_comander , ru_comander , ar_comander ; function Main_Variables ; begin
 136: LD_INT 0
 138: PPUSH
// game_on := false ;
 139: LD_ADDR_EXP 1
 143: PUSH
 144: LD_INT 0
 146: ST_TO_ADDR
// game_time := 0 0$00 ;
 147: LD_ADDR_EXP 3
 151: PUSH
 152: LD_INT 0
 154: ST_TO_ADDR
// game_option := [ 1 ] ;
 155: LD_ADDR_EXP 4
 159: PUSH
 160: LD_INT 1
 162: PUSH
 163: EMPTY
 164: LIST
 165: ST_TO_ADDR
// game_end := false ;
 166: LD_ADDR_EXP 5
 170: PUSH
 171: LD_INT 0
 173: ST_TO_ADDR
// game_strings := [ ] ;
 174: LD_ADDR_EXP 6
 178: PUSH
 179: EMPTY
 180: ST_TO_ADDR
// game_time := 0 0$00 ;
 181: LD_ADDR_EXP 3
 185: PUSH
 186: LD_INT 0
 188: ST_TO_ADDR
// mission_time := 0 0$00 ;
 189: LD_ADDR_EXP 34
 193: PUSH
 194: LD_INT 0
 196: ST_TO_ADDR
// skill := [ 5 , 7 , 9 ] [ game_difficulty ] ;
 197: LD_ADDR_EXP 16
 201: PUSH
 202: LD_INT 5
 204: PUSH
 205: LD_INT 7
 207: PUSH
 208: LD_INT 9
 210: PUSH
 211: EMPTY
 212: LIST
 213: LIST
 214: LIST
 215: PUSH
 216: LD_EXP 2
 220: ARRAY
 221: ST_TO_ADDR
// areas := [ a_swest , a_nwest , a_neast , a_seast ] ;
 222: LD_ADDR_EXP 15
 226: PUSH
 227: LD_INT 5
 229: PUSH
 230: LD_INT 6
 232: PUSH
 233: LD_INT 7
 235: PUSH
 236: LD_INT 8
 238: PUSH
 239: EMPTY
 240: LIST
 241: LIST
 242: LIST
 243: LIST
 244: ST_TO_ADDR
// meeting_start := false ;
 245: LD_ADDR_EXP 26
 249: PUSH
 250: LD_INT 0
 252: ST_TO_ADDR
// meeting_arive := false ;
 253: LD_ADDR_EXP 27
 257: PUSH
 258: LD_INT 0
 260: ST_TO_ADDR
// meeting_break := false ;
 261: LD_ADDR_EXP 28
 265: PUSH
 266: LD_INT 0
 268: ST_TO_ADDR
// meeting_end := false ;
 269: LD_ADDR_EXP 29
 273: PUSH
 274: LD_INT 0
 276: ST_TO_ADDR
// meeting_time := [ 4 4$00 , 3 3$40 , 3 3$20 ] [ game_difficulty ] ;
 277: LD_ADDR_EXP 30
 281: PUSH
 282: LD_INT 8400
 284: PUSH
 285: LD_INT 7700
 287: PUSH
 288: LD_INT 7000
 290: PUSH
 291: EMPTY
 292: LIST
 293: LIST
 294: LIST
 295: PUSH
 296: LD_EXP 2
 300: ARRAY
 301: ST_TO_ADDR
// arabian_force := [ 5 , 6 , 7 ] [ game_difficulty ] ;
 302: LD_ADDR_EXP 20
 306: PUSH
 307: LD_INT 5
 309: PUSH
 310: LD_INT 6
 312: PUSH
 313: LD_INT 7
 315: PUSH
 316: EMPTY
 317: LIST
 318: LIST
 319: LIST
 320: PUSH
 321: LD_EXP 2
 325: ARRAY
 326: ST_TO_ADDR
// american_force := [ 6 , 8 , 9 ] [ game_difficulty ] ;
 327: LD_ADDR_EXP 22
 331: PUSH
 332: LD_INT 6
 334: PUSH
 335: LD_INT 8
 337: PUSH
 338: LD_INT 9
 340: PUSH
 341: EMPTY
 342: LIST
 343: LIST
 344: LIST
 345: PUSH
 346: LD_EXP 2
 350: ARRAY
 351: ST_TO_ADDR
// russian_force := [ 7 , 9 , 10 ] [ game_difficulty ] ;
 352: LD_ADDR_EXP 21
 356: PUSH
 357: LD_INT 7
 359: PUSH
 360: LD_INT 9
 362: PUSH
 363: LD_INT 10
 365: PUSH
 366: EMPTY
 367: LIST
 368: LIST
 369: LIST
 370: PUSH
 371: LD_EXP 2
 375: ARRAY
 376: ST_TO_ADDR
// u_mine := false ;
 377: LD_ADDR_EXP 13
 381: PUSH
 382: LD_INT 0
 384: ST_TO_ADDR
// u_fac := false ;
 385: LD_ADDR_EXP 14
 389: PUSH
 390: LD_INT 0
 392: ST_TO_ADDR
// leopold_in_fort := false ;
 393: LD_ADDR_EXP 8
 397: PUSH
 398: LD_INT 0
 400: ST_TO_ADDR
// samuel_in_fort := false ;
 401: LD_ADDR_EXP 10
 405: PUSH
 406: LD_INT 0
 408: ST_TO_ADDR
// mortars_in_fort := false ;
 409: LD_ADDR_EXP 11
 413: PUSH
 414: LD_INT 0
 416: ST_TO_ADDR
// fort_destroyed := false ;
 417: LD_ADDR_EXP 32
 421: PUSH
 422: LD_INT 0
 424: ST_TO_ADDR
// hero_died := false ;
 425: LD_ADDR_EXP 33
 429: PUSH
 430: LD_INT 0
 432: ST_TO_ADDR
// dezert := false ;
 433: LD_ADDR_EXP 37
 437: PUSH
 438: LD_INT 0
 440: ST_TO_ADDR
// arabian_attack := false ;
 441: LD_ADDR_EXP 38
 445: PUSH
 446: LD_INT 0
 448: ST_TO_ADDR
// russian_attack := false ;
 449: LD_ADDR_EXP 39
 453: PUSH
 454: LD_INT 0
 456: ST_TO_ADDR
// american_attack := false ;
 457: LD_ADDR_EXP 40
 461: PUSH
 462: LD_INT 0
 464: ST_TO_ADDR
// american_help := false ;
 465: LD_ADDR_EXP 41
 469: PUSH
 470: LD_INT 0
 472: ST_TO_ADDR
// american_hchan := [ 91 , 81 , 71 ] [ game_difficulty ] ;
 473: LD_ADDR_EXP 36
 477: PUSH
 478: LD_INT 91
 480: PUSH
 481: LD_INT 81
 483: PUSH
 484: LD_INT 71
 486: PUSH
 487: EMPTY
 488: LIST
 489: LIST
 490: LIST
 491: PUSH
 492: LD_EXP 2
 496: ARRAY
 497: ST_TO_ADDR
// american_sib_bomb := false ;
 498: LD_ADDR_EXP 42
 502: PUSH
 503: LD_INT 0
 505: ST_TO_ADDR
// russian_trade := false ;
 506: LD_ADDR_EXP 43
 510: PUSH
 511: LD_INT 0
 513: ST_TO_ADDR
// russian_timer := 5 5$00 ;
 514: LD_ADDR_EXP 31
 518: PUSH
 519: LD_INT 10500
 521: ST_TO_ADDR
// cargo_ok := false ;
 522: LD_ADDR_EXP 35
 526: PUSH
 527: LD_INT 0
 529: ST_TO_ADDR
// heike_dialog1 := false ;
 530: LD_ADDR_EXP 44
 534: PUSH
 535: LD_INT 0
 537: ST_TO_ADDR
// heike_dialog2 := false ;
 538: LD_ADDR_EXP 45
 542: PUSH
 543: LD_INT 0
 545: ST_TO_ADDR
// american_timeing := [ 10 10$00 , 9 9$40 , 9 9$10 ] [ game_difficulty ] ;
 546: LD_ADDR_EXP 25
 550: PUSH
 551: LD_INT 21000
 553: PUSH
 554: LD_INT 20300
 556: PUSH
 557: LD_INT 19250
 559: PUSH
 560: EMPTY
 561: LIST
 562: LIST
 563: LIST
 564: PUSH
 565: LD_EXP 2
 569: ARRAY
 570: ST_TO_ADDR
// arabian_timeing := [ 8 8$00 , 7 7$10 , 6 6$20 ] [ game_difficulty ] ;
 571: LD_ADDR_EXP 23
 575: PUSH
 576: LD_INT 16800
 578: PUSH
 579: LD_INT 15050
 581: PUSH
 582: LD_INT 13300
 584: PUSH
 585: EMPTY
 586: LIST
 587: LIST
 588: LIST
 589: PUSH
 590: LD_EXP 2
 594: ARRAY
 595: ST_TO_ADDR
// russian_timeing := [ 11 11$00 , 10 10$30 , 9 9$20 ] [ game_difficulty ] ;
 596: LD_ADDR_EXP 24
 600: PUSH
 601: LD_INT 23100
 603: PUSH
 604: LD_INT 22050
 606: PUSH
 607: LD_INT 19600
 609: PUSH
 610: EMPTY
 611: LIST
 612: LIST
 613: LIST
 614: PUSH
 615: LD_EXP 2
 619: ARRAY
 620: ST_TO_ADDR
// ar_weapons := [ ar_rocket_launcher , ar_gun , ar_flame_thrower , ar_selfpropelled_bomb , ar_bio_bomb ] ;
 621: LD_ADDR_EXP 17
 625: PUSH
 626: LD_INT 28
 628: PUSH
 629: LD_INT 27
 631: PUSH
 632: LD_INT 26
 634: PUSH
 635: LD_INT 29
 637: PUSH
 638: LD_EXP 56
 642: PUSH
 643: EMPTY
 644: LIST
 645: LIST
 646: LIST
 647: LIST
 648: LIST
 649: ST_TO_ADDR
// us_weapons := [ us_rocket_launcher , us_heavy_gun , us_double_laser ] ;
 650: LD_ADDR_EXP 19
 654: PUSH
 655: LD_INT 7
 657: PUSH
 658: LD_INT 6
 660: PUSH
 661: LD_INT 10
 663: PUSH
 664: EMPTY
 665: LIST
 666: LIST
 667: LIST
 668: ST_TO_ADDR
// ru_weapons := [ ru_rocket_launcher , ru_rocket , ru_heavy_gun ] ;
 669: LD_ADDR_EXP 18
 673: PUSH
 674: LD_INT 45
 676: PUSH
 677: LD_INT 47
 679: PUSH
 680: LD_INT 46
 682: PUSH
 683: EMPTY
 684: LIST
 685: LIST
 686: LIST
 687: ST_TO_ADDR
// end ;
 688: LD_VAR 0 1
 692: RET
// every 0 0$01 trigger game_on do var i , p , x , filter ;
 693: LD_EXP 1
 697: IFFALSE 3413
 699: GO 701
 701: DISABLE
 702: LD_INT 0
 704: PPUSH
 705: PPUSH
 706: PPUSH
 707: PPUSH
// begin enable ;
 708: ENABLE
// Display_Strings := [ #tick , game_time ] ^ game_strings ;
 709: LD_ADDR_OWVAR 47
 713: PUSH
 714: LD_STRING #tick
 716: PUSH
 717: LD_EXP 3
 721: PUSH
 722: EMPTY
 723: LIST
 724: LIST
 725: PUSH
 726: LD_EXP 6
 730: ADD
 731: ST_TO_ADDR
// game_time := RefreshTime ( game_time , true ) ;
 732: LD_ADDR_EXP 3
 736: PUSH
 737: LD_EXP 3
 741: PPUSH
 742: LD_INT 1
 744: PPUSH
 745: CALL 6831 0 2
 749: ST_TO_ADDR
// if meeting_start and meeting_time > 0 0$00 then
 750: LD_EXP 26
 754: PUSH
 755: LD_EXP 30
 759: PUSH
 760: LD_INT 0
 762: GREATER
 763: AND
 764: IFFALSE 801
// begin game_strings := [ #mtime , meeting_time ] ;
 766: LD_ADDR_EXP 6
 770: PUSH
 771: LD_STRING #mtime
 773: PUSH
 774: LD_EXP 30
 778: PUSH
 779: EMPTY
 780: LIST
 781: LIST
 782: ST_TO_ADDR
// meeting_time := RefreshTime ( meeting_time , false ) ;
 783: LD_ADDR_EXP 30
 787: PUSH
 788: LD_EXP 30
 792: PPUSH
 793: LD_INT 0
 795: PPUSH
 796: CALL 6831 0 2
 800: ST_TO_ADDR
// end ; if meeting_arive then
 801: LD_EXP 27
 805: IFFALSE 825
// mission_time := RefreshTime ( mission_time , true ) ;
 807: LD_ADDR_EXP 34
 811: PUSH
 812: LD_EXP 34
 816: PPUSH
 817: LD_INT 1
 819: PPUSH
 820: CALL 6831 0 2
 824: ST_TO_ADDR
// if arabian_attack and arabian_timeing > 0 0$00 and meeting_arive then
 825: LD_EXP 38
 829: PUSH
 830: LD_EXP 23
 834: PUSH
 835: LD_INT 0
 837: GREATER
 838: AND
 839: PUSH
 840: LD_EXP 27
 844: AND
 845: IFFALSE 865
// begin arabian_timeing := RefreshTime ( arabian_timeing , false ) ;
 847: LD_ADDR_EXP 23
 851: PUSH
 852: LD_EXP 23
 856: PPUSH
 857: LD_INT 0
 859: PPUSH
 860: CALL 6831 0 2
 864: ST_TO_ADDR
// end ; if russian_attack and russian_timeing > 0 0$00 and meeting_arive then
 865: LD_EXP 39
 869: PUSH
 870: LD_EXP 24
 874: PUSH
 875: LD_INT 0
 877: GREATER
 878: AND
 879: PUSH
 880: LD_EXP 27
 884: AND
 885: IFFALSE 905
// begin russian_timeing := RefreshTime ( russian_timeing , false ) ;
 887: LD_ADDR_EXP 24
 891: PUSH
 892: LD_EXP 24
 896: PPUSH
 897: LD_INT 0
 899: PPUSH
 900: CALL 6831 0 2
 904: ST_TO_ADDR
// end ; if american_attack and american_timeing > 0 0$00 and meeting_arive then
 905: LD_EXP 40
 909: PUSH
 910: LD_EXP 25
 914: PUSH
 915: LD_INT 0
 917: GREATER
 918: AND
 919: PUSH
 920: LD_EXP 27
 924: AND
 925: IFFALSE 945
// begin american_timeing := RefreshTime ( american_timeing , false ) ;
 927: LD_ADDR_EXP 25
 931: PUSH
 932: LD_EXP 25
 936: PPUSH
 937: LD_INT 0
 939: PPUSH
 940: CALL 6831 0 2
 944: ST_TO_ADDR
// end ; if russian_trade and russian_timer > 0 0$00 then
 945: LD_EXP 43
 949: PUSH
 950: LD_EXP 31
 954: PUSH
 955: LD_INT 0
 957: GREATER
 958: AND
 959: IFFALSE 996
// begin game_strings := [ #rtime , russian_timer ] ;
 961: LD_ADDR_EXP 6
 965: PUSH
 966: LD_STRING #rtime
 968: PUSH
 969: LD_EXP 31
 973: PUSH
 974: EMPTY
 975: LIST
 976: LIST
 977: ST_TO_ADDR
// russian_timer := RefreshTime ( russian_timer , false ) ;
 978: LD_ADDR_EXP 31
 982: PUSH
 983: LD_EXP 31
 987: PPUSH
 988: LD_INT 0
 990: PPUSH
 991: CALL 6831 0 2
 995: ST_TO_ADDR
// end ; if russian_trade and russian_timer = 0 0$00 or cargo_ok then
 996: LD_EXP 43
1000: PUSH
1001: LD_EXP 31
1005: PUSH
1006: LD_INT 0
1008: EQUAL
1009: AND
1010: PUSH
1011: LD_EXP 35
1015: OR
1016: IFFALSE 1025
// game_strings := [ ] ;
1018: LD_ADDR_EXP 6
1022: PUSH
1023: EMPTY
1024: ST_TO_ADDR
// if dezert = false and tick mod 33600 = 0 then
1025: LD_EXP 37
1029: PUSH
1030: LD_INT 0
1032: EQUAL
1033: PUSH
1034: LD_OWVAR 1
1038: PUSH
1039: LD_INT 33600
1041: MOD
1042: PUSH
1043: LD_INT 0
1045: EQUAL
1046: AND
1047: IFFALSE 1107
// begin p := Rand ( 1 , 5 ) ;
1049: LD_ADDR_VAR 0 2
1053: PUSH
1054: LD_INT 1
1056: PPUSH
1057: LD_INT 5
1059: PPUSH
1060: CALL_OW 12
1064: ST_TO_ADDR
// if p <= [ 4 , 3 , 3 ] [ game_difficulty ] then
1065: LD_VAR 0 2
1069: PUSH
1070: LD_INT 4
1072: PUSH
1073: LD_INT 3
1075: PUSH
1076: LD_INT 3
1078: PUSH
1079: EMPTY
1080: LIST
1081: LIST
1082: LIST
1083: PUSH
1084: LD_EXP 2
1088: ARRAY
1089: LESSEQUAL
1090: IFFALSE 1107
// begin RaiseSailEvent ( 92 ) ;
1092: LD_INT 92
1094: PPUSH
1095: CALL_OW 427
// dezert := true ;
1099: LD_ADDR_EXP 37
1103: PUSH
1104: LD_INT 1
1106: ST_TO_ADDR
// end ; end ; if tick mod 8400 = 0 then
1107: LD_OWVAR 1
1111: PUSH
1112: LD_INT 8400
1114: MOD
1115: PUSH
1116: LD_INT 0
1118: EQUAL
1119: IFFALSE 1128
// RaiseSailEvent ( 101 ) ;
1121: LD_INT 101
1123: PPUSH
1124: CALL_OW 427
// if MineExist ( 8 ) and u_mine = false then
1128: LD_INT 8
1130: PPUSH
1131: CALL 6885 0 1
1135: PUSH
1136: LD_EXP 13
1140: PUSH
1141: LD_INT 0
1143: EQUAL
1144: AND
1145: IFFALSE 1162
// begin u_mine := true ;
1147: LD_ADDR_EXP 13
1151: PUSH
1152: LD_INT 1
1154: ST_TO_ADDR
// ChangeMissionObjectives ( DS-T1m ) ;
1155: LD_STRING DS-T1m
1157: PPUSH
1158: CALL_OW 337
// end ; if FacExist ( 8 ) and u_fac = false then
1162: LD_INT 8
1164: PPUSH
1165: CALL 6947 0 1
1169: PUSH
1170: LD_EXP 14
1174: PUSH
1175: LD_INT 0
1177: EQUAL
1178: AND
1179: IFFALSE 1196
// begin u_fac := true ;
1181: LD_ADDR_EXP 14
1185: PUSH
1186: LD_INT 1
1188: ST_TO_ADDR
// ChangeMissionObjectives ( DS-T1f ) ;
1189: LD_STRING DS-T1f
1191: PPUSH
1192: CALL_OW 337
// end ; if hero_died then
1196: LD_EXP 33
1200: IFFALSE 1209
// YouLost ( DS-h1 ) ;
1202: LD_STRING DS-h1
1204: PPUSH
1205: CALL_OW 104
// if fort_destroyed then
1209: LD_EXP 32
1213: IFFALSE 1222
// YouLost ( DS-h2 ) ;
1215: LD_STRING DS-h2
1217: PPUSH
1218: CALL_OW 104
// if GetDistUnits ( leopold , l_cmndr ) > 6 and meeting_start = false then
1222: LD_EXP 7
1226: PPUSH
1227: LD_EXP 49
1231: PPUSH
1232: CALL_OW 296
1236: PUSH
1237: LD_INT 6
1239: GREATER
1240: PUSH
1241: LD_EXP 26
1245: PUSH
1246: LD_INT 0
1248: EQUAL
1249: AND
1250: IFFALSE 1273
// begin if not HasTask ( leopold ) then
1252: LD_EXP 7
1256: PPUSH
1257: CALL_OW 314
1261: NOT
1262: IFFALSE 1271
// RaiseSailEvent ( 1 ) ;
1264: LD_INT 1
1266: PPUSH
1267: CALL_OW 427
// end else
1271: GO 1290
// if meeting_start = false then
1273: LD_EXP 26
1277: PUSH
1278: LD_INT 0
1280: EQUAL
1281: IFFALSE 1290
// begin RaiseSailEvent ( 2 ) ;
1283: LD_INT 2
1285: PPUSH
1286: CALL_OW 427
// end ; if game_time >= [ 50 50$00 , 62 62$30 , 75 75$00 ] [ game_difficulty ] and meeting_end = false then
1290: LD_EXP 3
1294: PUSH
1295: LD_INT 105000
1297: PUSH
1298: LD_INT 131250
1300: PUSH
1301: LD_INT 157500
1303: PUSH
1304: EMPTY
1305: LIST
1306: LIST
1307: LIST
1308: PUSH
1309: LD_EXP 2
1313: ARRAY
1314: GREATEREQUAL
1315: PUSH
1316: LD_EXP 29
1320: PUSH
1321: LD_INT 0
1323: EQUAL
1324: AND
1325: IFFALSE 1342
// begin meeting_end := true ;
1327: LD_ADDR_EXP 29
1331: PUSH
1332: LD_INT 1
1334: ST_TO_ADDR
// RaiseSailEvent ( 200 ) ;
1335: LD_INT 200
1337: PPUSH
1338: CALL_OW 427
// end ; if meeting_time = 0 0$00 and meeting_arive = false then
1342: LD_EXP 30
1346: PUSH
1347: LD_INT 0
1349: EQUAL
1350: PUSH
1351: LD_EXP 27
1355: PUSH
1356: LD_INT 0
1358: EQUAL
1359: AND
1360: IFFALSE 1384
// begin meeting_arive := true ;
1362: LD_ADDR_EXP 27
1366: PUSH
1367: LD_INT 1
1369: ST_TO_ADDR
// game_strings := [ ] ;
1370: LD_ADDR_EXP 6
1374: PUSH
1375: EMPTY
1376: ST_TO_ADDR
// RaiseSailEvent ( 10 ) ;
1377: LD_INT 10
1379: PPUSH
1380: CALL_OW 427
// end ; if meeting_arive then
1384: LD_EXP 27
1388: IFFALSE 2133
// begin if arabian_attack = false and tick mod 4200 = 0 then
1390: LD_EXP 38
1394: PUSH
1395: LD_INT 0
1397: EQUAL
1398: PUSH
1399: LD_OWVAR 1
1403: PUSH
1404: LD_INT 4200
1406: MOD
1407: PUSH
1408: LD_INT 0
1410: EQUAL
1411: AND
1412: IFFALSE 1465
// begin p := Rand ( 1 , 100 ) ;
1414: LD_ADDR_VAR 0 2
1418: PUSH
1419: LD_INT 1
1421: PPUSH
1422: LD_INT 100
1424: PPUSH
1425: CALL_OW 12
1429: ST_TO_ADDR
// if p <= [ 80 , 85 , 90 ] [ game_difficulty ] then
1430: LD_VAR 0 2
1434: PUSH
1435: LD_INT 80
1437: PUSH
1438: LD_INT 85
1440: PUSH
1441: LD_INT 90
1443: PUSH
1444: EMPTY
1445: LIST
1446: LIST
1447: LIST
1448: PUSH
1449: LD_EXP 2
1453: ARRAY
1454: LESSEQUAL
1455: IFFALSE 1465
// arabian_attack := true ;
1457: LD_ADDR_EXP 38
1461: PUSH
1462: LD_INT 1
1464: ST_TO_ADDR
// end ; if russian_trade = false and russian_attack = false and tick > 52500 then
1465: LD_EXP 43
1469: PUSH
1470: LD_INT 0
1472: EQUAL
1473: PUSH
1474: LD_EXP 39
1478: PUSH
1479: LD_INT 0
1481: EQUAL
1482: AND
1483: PUSH
1484: LD_OWVAR 1
1488: PUSH
1489: LD_INT 52500
1491: GREATER
1492: AND
1493: IFFALSE 1564
// begin russian_trade = true ;
1495: LD_ADDR_EXP 43
1499: PUSH
1500: LD_INT 1
1502: ST_TO_ADDR
// DialogueOn ;
1503: CALL_OW 6
// SayRadio ( ru_comander , DS-DR-RTr ) ;
1507: LD_EXP 47
1511: PPUSH
1512: LD_STRING DS-DR-RTr
1514: PPUSH
1515: CALL_OW 94
// Say ( l_cmndr , DS-DC-RTr ) ;
1519: LD_EXP 49
1523: PPUSH
1524: LD_STRING DS-DC-RTr
1526: PPUSH
1527: CALL_OW 88
// SayRadio ( ru_comander , DS-DR-RTr2 ) ;
1531: LD_EXP 47
1535: PPUSH
1536: LD_STRING DS-DR-RTr2
1538: PPUSH
1539: CALL_OW 94
// DialogueOff ;
1543: CALL_OW 7
// ChangeMissionObjectives ( DS-T2 ) ;
1547: LD_STRING DS-T2
1549: PPUSH
1550: CALL_OW 337
// SetAreaMapShow ( tree , 1 ) ;
1554: LD_INT 10
1556: PPUSH
1557: LD_INT 1
1559: PPUSH
1560: CALL_OW 424
// end ; if russian_trade and cargo_ok = false and russian_timer > 0 0$00 then
1564: LD_EXP 43
1568: PUSH
1569: LD_EXP 35
1573: PUSH
1574: LD_INT 0
1576: EQUAL
1577: AND
1578: PUSH
1579: LD_EXP 31
1583: PUSH
1584: LD_INT 0
1586: GREATER
1587: AND
1588: IFFALSE 1783
// begin if FilterUnitsInArea ( tree , ( [ [ f_empty ] , [ f_weapon , ar_cargo_bay ] , [ f_not , [ f_control , control_remote ] ] ] ) ) > 0 then
1590: LD_INT 10
1592: PPUSH
1593: LD_INT 58
1595: PUSH
1596: EMPTY
1597: LIST
1598: PUSH
1599: LD_INT 34
1601: PUSH
1602: LD_INT 32
1604: PUSH
1605: EMPTY
1606: LIST
1607: LIST
1608: PUSH
1609: LD_INT 3
1611: PUSH
1612: LD_INT 33
1614: PUSH
1615: LD_INT 2
1617: PUSH
1618: EMPTY
1619: LIST
1620: LIST
1621: PUSH
1622: EMPTY
1623: LIST
1624: LIST
1625: PUSH
1626: EMPTY
1627: LIST
1628: LIST
1629: LIST
1630: PPUSH
1631: CALL_OW 70
1635: PUSH
1636: LD_INT 0
1638: GREATER
1639: IFFALSE 1783
// if GetCargo ( FilterUnitsInArea ( tree , ( [ [ f_empty ] , [ f_weapon , ar_cargo_bay ] , [ f_not , [ f_control , control_remote ] ] ] ) ) [ 1 ] , mat_siberit ) = 100 then
1641: LD_INT 10
1643: PPUSH
1644: LD_INT 58
1646: PUSH
1647: EMPTY
1648: LIST
1649: PUSH
1650: LD_INT 34
1652: PUSH
1653: LD_INT 32
1655: PUSH
1656: EMPTY
1657: LIST
1658: LIST
1659: PUSH
1660: LD_INT 3
1662: PUSH
1663: LD_INT 33
1665: PUSH
1666: LD_INT 2
1668: PUSH
1669: EMPTY
1670: LIST
1671: LIST
1672: PUSH
1673: EMPTY
1674: LIST
1675: LIST
1676: PUSH
1677: EMPTY
1678: LIST
1679: LIST
1680: LIST
1681: PPUSH
1682: CALL_OW 70
1686: PUSH
1687: LD_INT 1
1689: ARRAY
1690: PPUSH
1691: LD_INT 3
1693: PPUSH
1694: CALL_OW 289
1698: PUSH
1699: LD_INT 100
1701: EQUAL
1702: IFFALSE 1783
// begin cargo_ok := true ;
1704: LD_ADDR_EXP 35
1708: PUSH
1709: LD_INT 1
1711: ST_TO_ADDR
// RemoveUnit ( FilterUnitsInArea ( tree , ( [ [ f_empty ] , [ f_weapon , ar_cargo_bay ] , [ f_not , [ f_control , control_remote ] ] ] ) ) [ 1 ] ) ;
1712: LD_INT 10
1714: PPUSH
1715: LD_INT 58
1717: PUSH
1718: EMPTY
1719: LIST
1720: PUSH
1721: LD_INT 34
1723: PUSH
1724: LD_INT 32
1726: PUSH
1727: EMPTY
1728: LIST
1729: LIST
1730: PUSH
1731: LD_INT 3
1733: PUSH
1734: LD_INT 33
1736: PUSH
1737: LD_INT 2
1739: PUSH
1740: EMPTY
1741: LIST
1742: LIST
1743: PUSH
1744: EMPTY
1745: LIST
1746: LIST
1747: PUSH
1748: EMPTY
1749: LIST
1750: LIST
1751: LIST
1752: PPUSH
1753: CALL_OW 70
1757: PUSH
1758: LD_INT 1
1760: ARRAY
1761: PPUSH
1762: CALL_OW 64
// ChangeMissionObjectives ( DS-T2-out ) ;
1766: LD_STRING DS-T2-out
1768: PPUSH
1769: CALL_OW 337
// SetAreaMapShow ( tree , 0 ) ;
1773: LD_INT 10
1775: PPUSH
1776: LD_INT 0
1778: PPUSH
1779: CALL_OW 424
// end ; end ; if russian_attack = false and russian_trade and cargo_ok = false and russian_timer = 0 0$00 then
1783: LD_EXP 39
1787: PUSH
1788: LD_INT 0
1790: EQUAL
1791: PUSH
1792: LD_EXP 43
1796: AND
1797: PUSH
1798: LD_EXP 35
1802: PUSH
1803: LD_INT 0
1805: EQUAL
1806: AND
1807: PUSH
1808: LD_EXP 31
1812: PUSH
1813: LD_INT 0
1815: EQUAL
1816: AND
1817: IFFALSE 1844
// begin russian_attack := true ;
1819: LD_ADDR_EXP 39
1823: PUSH
1824: LD_INT 1
1826: ST_TO_ADDR
// ChangeMissionObjectives ( DS-T2-out ) ;
1827: LD_STRING DS-T2-out
1829: PPUSH
1830: CALL_OW 337
// SetAreaMapShow ( tree , 0 ) ;
1834: LD_INT 10
1836: PPUSH
1837: LD_INT 0
1839: PPUSH
1840: CALL_OW 424
// end ; if russian_trade = false and russian_attack = false and american_attack = false and tick mod 21000 = 0 then
1844: LD_EXP 43
1848: PUSH
1849: LD_INT 0
1851: EQUAL
1852: PUSH
1853: LD_EXP 39
1857: PUSH
1858: LD_INT 0
1860: EQUAL
1861: AND
1862: PUSH
1863: LD_EXP 40
1867: PUSH
1868: LD_INT 0
1870: EQUAL
1871: AND
1872: PUSH
1873: LD_OWVAR 1
1877: PUSH
1878: LD_INT 21000
1880: MOD
1881: PUSH
1882: LD_INT 0
1884: EQUAL
1885: AND
1886: IFFALSE 1939
// begin p := Rand ( 1 , 100 ) ;
1888: LD_ADDR_VAR 0 2
1892: PUSH
1893: LD_INT 1
1895: PPUSH
1896: LD_INT 100
1898: PPUSH
1899: CALL_OW 12
1903: ST_TO_ADDR
// if p <= [ 25 , 35 , 45 ] [ game_difficulty ] then
1904: LD_VAR 0 2
1908: PUSH
1909: LD_INT 25
1911: PUSH
1912: LD_INT 35
1914: PUSH
1915: LD_INT 45
1917: PUSH
1918: EMPTY
1919: LIST
1920: LIST
1921: LIST
1922: PUSH
1923: LD_EXP 2
1927: ARRAY
1928: LESSEQUAL
1929: IFFALSE 1939
// russian_attack := true ;
1931: LD_ADDR_EXP 39
1935: PUSH
1936: LD_INT 1
1938: ST_TO_ADDR
// end ; if american_help = false and american_attack = false and russian_attack = false and tick mod 31500 = 0 then
1939: LD_EXP 41
1943: PUSH
1944: LD_INT 0
1946: EQUAL
1947: PUSH
1948: LD_EXP 40
1952: PUSH
1953: LD_INT 0
1955: EQUAL
1956: AND
1957: PUSH
1958: LD_EXP 39
1962: PUSH
1963: LD_INT 0
1965: EQUAL
1966: AND
1967: PUSH
1968: LD_OWVAR 1
1972: PUSH
1973: LD_INT 31500
1975: MOD
1976: PUSH
1977: LD_INT 0
1979: EQUAL
1980: AND
1981: IFFALSE 2034
// begin p := Rand ( 1 , 100 ) ;
1983: LD_ADDR_VAR 0 2
1987: PUSH
1988: LD_INT 1
1990: PPUSH
1991: LD_INT 100
1993: PPUSH
1994: CALL_OW 12
1998: ST_TO_ADDR
// if p <= [ 22 , 33 , 44 ] [ game_difficulty ] then
1999: LD_VAR 0 2
2003: PUSH
2004: LD_INT 22
2006: PUSH
2007: LD_INT 33
2009: PUSH
2010: LD_INT 44
2012: PUSH
2013: EMPTY
2014: LIST
2015: LIST
2016: LIST
2017: PUSH
2018: LD_EXP 2
2022: ARRAY
2023: LESSEQUAL
2024: IFFALSE 2034
// american_attack := true ;
2026: LD_ADDR_EXP 40
2030: PUSH
2031: LD_INT 1
2033: ST_TO_ADDR
// end ; if american_attack = false and russian_attack = false and american_help = false and tick mod 21200 = 0 then
2034: LD_EXP 40
2038: PUSH
2039: LD_INT 0
2041: EQUAL
2042: PUSH
2043: LD_EXP 39
2047: PUSH
2048: LD_INT 0
2050: EQUAL
2051: AND
2052: PUSH
2053: LD_EXP 41
2057: PUSH
2058: LD_INT 0
2060: EQUAL
2061: AND
2062: PUSH
2063: LD_OWVAR 1
2067: PUSH
2068: LD_INT 21200
2070: MOD
2071: PUSH
2072: LD_INT 0
2074: EQUAL
2075: AND
2076: IFFALSE 2133
// begin p := Rand ( 1 , 100 ) ;
2078: LD_ADDR_VAR 0 2
2082: PUSH
2083: LD_INT 1
2085: PPUSH
2086: LD_INT 100
2088: PPUSH
2089: CALL_OW 12
2093: ST_TO_ADDR
// if p <= american_hchan then
2094: LD_VAR 0 2
2098: PUSH
2099: LD_EXP 36
2103: LESSEQUAL
2104: IFFALSE 2133
// begin american_help := true ;
2106: LD_ADDR_EXP 41
2110: PUSH
2111: LD_INT 1
2113: ST_TO_ADDR
// SayRadio ( am_comander , DS-amhelp ) ;
2114: LD_EXP 46
2118: PPUSH
2119: LD_STRING DS-amhelp
2121: PPUSH
2122: CALL_OW 94
// RaiseSailEvent ( 91 ) ;
2126: LD_INT 91
2128: PPUSH
2129: CALL_OW 427
// end ; end ; end ; if american_attack and american_timeing = 0 0$00 and FilterAllUnits ( [ f_side , 1 ] ) = 0 then
2133: LD_EXP 40
2137: PUSH
2138: LD_EXP 25
2142: PUSH
2143: LD_INT 0
2145: EQUAL
2146: AND
2147: PUSH
2148: LD_INT 22
2150: PUSH
2151: LD_INT 1
2153: PUSH
2154: EMPTY
2155: LIST
2156: LIST
2157: PPUSH
2158: CALL_OW 69
2162: PUSH
2163: LD_INT 0
2165: EQUAL
2166: AND
2167: IFFALSE 2269
// begin american_timeing := Rand ( 17 17$00 , 20 20$00 ) ;
2169: LD_ADDR_EXP 25
2173: PUSH
2174: LD_INT 35700
2176: PPUSH
2177: LD_INT 42000
2179: PPUSH
2180: CALL_OW 12
2184: ST_TO_ADDR
// SayRadio ( scout , DS-DZ-U ) ;
2185: LD_EXP 12
2189: PPUSH
2190: LD_STRING DS-DZ-U
2192: PPUSH
2193: CALL_OW 94
// Wait ( 0 0$33 ) ;
2197: LD_INT 1155
2199: PPUSH
2200: CALL_OW 67
// x := Rand ( 1 , 2 ) ;
2204: LD_ADDR_VAR 0 3
2208: PUSH
2209: LD_INT 1
2211: PPUSH
2212: LD_INT 2
2214: PPUSH
2215: CALL_OW 12
2219: ST_TO_ADDR
// case x of 1 :
2220: LD_VAR 0 3
2224: PUSH
2225: LD_INT 1
2227: DOUBLE
2228: EQUAL
2229: IFTRUE 2233
2231: GO 2243
2233: POP
// RaiseSailEvent ( 41 ) ; 2 :
2234: LD_INT 41
2236: PPUSH
2237: CALL_OW 427
2241: GO 2262
2243: LD_INT 2
2245: DOUBLE
2246: EQUAL
2247: IFTRUE 2251
2249: GO 2261
2251: POP
// RaiseSailEvent ( 42 ) ; end ;
2252: LD_INT 42
2254: PPUSH
2255: CALL_OW 427
2259: GO 2262
2261: POP
// RaiseSailEvent ( 42 ) ;
2262: LD_INT 42
2264: PPUSH
2265: CALL_OW 427
// end ; if russian_attack and russian_timeing = 0 0$00 and FilterAllUnits ( [ f_side , 3 ] ) = 0 then
2269: LD_EXP 39
2273: PUSH
2274: LD_EXP 24
2278: PUSH
2279: LD_INT 0
2281: EQUAL
2282: AND
2283: PUSH
2284: LD_INT 22
2286: PUSH
2287: LD_INT 3
2289: PUSH
2290: EMPTY
2291: LIST
2292: LIST
2293: PPUSH
2294: CALL_OW 69
2298: PUSH
2299: LD_INT 0
2301: EQUAL
2302: AND
2303: IFFALSE 2359
// begin russian_timeing := Rand ( 17 17$00 , 20 20$00 ) ;
2305: LD_ADDR_EXP 24
2309: PUSH
2310: LD_INT 35700
2312: PPUSH
2313: LD_INT 42000
2315: PPUSH
2316: CALL_OW 12
2320: ST_TO_ADDR
// SayRadio ( scout , DS-DZ-R ) ;
2321: LD_EXP 12
2325: PPUSH
2326: LD_STRING DS-DZ-R
2328: PPUSH
2329: CALL_OW 94
// Wait ( 0 0$45 ) ;
2333: LD_INT 1575
2335: PPUSH
2336: CALL_OW 67
// SayRadio ( ru_comander , DS-DR-R1 ) ;
2340: LD_EXP 47
2344: PPUSH
2345: LD_STRING DS-DR-R1
2347: PPUSH
2348: CALL_OW 94
// RaiseSailEvent ( 51 ) ;
2352: LD_INT 51
2354: PPUSH
2355: CALL_OW 427
// end ; if mission_time >= 10 10$00 and arabian_force < 10 then
2359: LD_EXP 34
2363: PUSH
2364: LD_INT 21000
2366: GREATEREQUAL
2367: PUSH
2368: LD_EXP 20
2372: PUSH
2373: LD_INT 10
2375: LESS
2376: AND
2377: IFFALSE 2401
// begin mission_time := 0 0$00 ;
2379: LD_ADDR_EXP 34
2383: PUSH
2384: LD_INT 0
2386: ST_TO_ADDR
// arabian_force := arabian_force + 1 ;
2387: LD_ADDR_EXP 20
2391: PUSH
2392: LD_EXP 20
2396: PUSH
2397: LD_INT 1
2399: PLUS
2400: ST_TO_ADDR
// end ; if arabian_timeing = 0 0$00 and FilterAllUnits ( [ [ f_side , 2 ] , [ f_not , [ f_weapon , ar_control_tower ] ] ] ) = 0 then
2401: LD_EXP 23
2405: PUSH
2406: LD_INT 0
2408: EQUAL
2409: PUSH
2410: LD_INT 22
2412: PUSH
2413: LD_INT 2
2415: PUSH
2416: EMPTY
2417: LIST
2418: LIST
2419: PUSH
2420: LD_INT 3
2422: PUSH
2423: LD_INT 34
2425: PUSH
2426: LD_INT 31
2428: PUSH
2429: EMPTY
2430: LIST
2431: LIST
2432: PUSH
2433: EMPTY
2434: LIST
2435: LIST
2436: PUSH
2437: EMPTY
2438: LIST
2439: LIST
2440: PPUSH
2441: CALL_OW 69
2445: PUSH
2446: LD_INT 0
2448: EQUAL
2449: AND
2450: IFFALSE 2648
// begin arabian_timeing := 7 7$30 ;
2452: LD_ADDR_EXP 23
2456: PUSH
2457: LD_INT 15750
2459: ST_TO_ADDR
// x := Rand ( 1 , 3 ) ;
2460: LD_ADDR_VAR 0 3
2464: PUSH
2465: LD_INT 1
2467: PPUSH
2468: LD_INT 3
2470: PPUSH
2471: CALL_OW 12
2475: ST_TO_ADDR
// SayRadio ( scout , DS-DZ-H ) ;
2476: LD_EXP 12
2480: PPUSH
2481: LD_STRING DS-DZ-H
2483: PPUSH
2484: CALL_OW 94
// case x of 1 :
2488: LD_VAR 0 3
2492: PUSH
2493: LD_INT 1
2495: DOUBLE
2496: EQUAL
2497: IFTRUE 2501
2499: GO 2511
2501: POP
// RaiseSailEvent ( 31 ) ; 2 :
2502: LD_INT 31
2504: PPUSH
2505: CALL_OW 427
2509: GO 2548
2511: LD_INT 2
2513: DOUBLE
2514: EQUAL
2515: IFTRUE 2519
2517: GO 2529
2519: POP
// RaiseSailEvent ( 32 ) ; 3 :
2520: LD_INT 32
2522: PPUSH
2523: CALL_OW 427
2527: GO 2548
2529: LD_INT 3
2531: DOUBLE
2532: EQUAL
2533: IFTRUE 2537
2535: GO 2547
2537: POP
// RaiseSailEvent ( 33 ) ; end ;
2538: LD_INT 33
2540: PPUSH
2541: CALL_OW 427
2545: GO 2548
2547: POP
// RaiseSailEvent ( 33 ) ;
2548: LD_INT 33
2550: PPUSH
2551: CALL_OW 427
// if game_difficulty > 1 then
2555: LD_EXP 2
2559: PUSH
2560: LD_INT 1
2562: GREATER
2563: IFFALSE 2572
// RaiseSailEvent ( 33 ) ;
2565: LD_INT 33
2567: PPUSH
2568: CALL_OW 427
// if heike_dialog1 = false then
2572: LD_EXP 44
2576: PUSH
2577: LD_INT 0
2579: EQUAL
2580: IFFALSE 2611
// begin heike_dialog1 := true ;
2582: LD_ADDR_EXP 44
2586: PUSH
2587: LD_INT 1
2589: ST_TO_ADDR
// Wait ( 0 0$03 ) ;
2590: LD_INT 105
2592: PPUSH
2593: CALL_OW 67
// SayRadio ( ar_comander , heike1 ) ;
2597: LD_EXP 48
2601: PPUSH
2602: LD_STRING heike1
2604: PPUSH
2605: CALL_OW 94
// end else
2609: GO 2648
// if heike_dialog2 = false then
2611: LD_EXP 45
2615: PUSH
2616: LD_INT 0
2618: EQUAL
2619: IFFALSE 2648
// begin heike_dialog2 := true ;
2621: LD_ADDR_EXP 45
2625: PUSH
2626: LD_INT 1
2628: ST_TO_ADDR
// Wait ( 0 0$03 ) ;
2629: LD_INT 105
2631: PPUSH
2632: CALL_OW 67
// SayRadio ( ar_comander , heike2 ) ;
2636: LD_EXP 48
2640: PPUSH
2641: LD_STRING heike2
2643: PPUSH
2644: CALL_OW 94
// end ; end ; if FilterAllUnits ( [ [ f_side , 2 ] , [ f_control , control_remote ] ] ) > 0 then
2648: LD_INT 22
2650: PUSH
2651: LD_INT 2
2653: PUSH
2654: EMPTY
2655: LIST
2656: LIST
2657: PUSH
2658: LD_INT 33
2660: PUSH
2661: LD_INT 2
2663: PUSH
2664: EMPTY
2665: LIST
2666: LIST
2667: PUSH
2668: EMPTY
2669: LIST
2670: LIST
2671: PPUSH
2672: CALL_OW 69
2676: PUSH
2677: LD_INT 0
2679: GREATER
2680: IFFALSE 2689
// ConnectWithTower ( 2 ) ;
2682: LD_INT 2
2684: PPUSH
2685: CALL 6995 0 1
// if FilterAllUnits ( [ [ [ f_side , 2 ] , [ f_not , [ f_weapon , ar_control_tower ] ] , [ f_not , [ f_hastask ] ] ] ] ) > 0 then
2689: LD_INT 22
2691: PUSH
2692: LD_INT 2
2694: PUSH
2695: EMPTY
2696: LIST
2697: LIST
2698: PUSH
2699: LD_INT 3
2701: PUSH
2702: LD_INT 34
2704: PUSH
2705: LD_INT 31
2707: PUSH
2708: EMPTY
2709: LIST
2710: LIST
2711: PUSH
2712: EMPTY
2713: LIST
2714: LIST
2715: PUSH
2716: LD_INT 3
2718: PUSH
2719: LD_INT 60
2721: PUSH
2722: EMPTY
2723: LIST
2724: PUSH
2725: EMPTY
2726: LIST
2727: LIST
2728: PUSH
2729: EMPTY
2730: LIST
2731: LIST
2732: LIST
2733: PUSH
2734: EMPTY
2735: LIST
2736: PPUSH
2737: CALL_OW 69
2741: PUSH
2742: LD_INT 0
2744: GREATER
2745: IFFALSE 2891
// begin filter := FilterAllUnits ( [ [ [ f_side , 2 ] , [ f_not , [ f_weapon , ar_control_tower ] ] , [ f_not , [ f_hastask ] ] ] ] ) ;
2747: LD_ADDR_VAR 0 4
2751: PUSH
2752: LD_INT 22
2754: PUSH
2755: LD_INT 2
2757: PUSH
2758: EMPTY
2759: LIST
2760: LIST
2761: PUSH
2762: LD_INT 3
2764: PUSH
2765: LD_INT 34
2767: PUSH
2768: LD_INT 31
2770: PUSH
2771: EMPTY
2772: LIST
2773: LIST
2774: PUSH
2775: EMPTY
2776: LIST
2777: LIST
2778: PUSH
2779: LD_INT 3
2781: PUSH
2782: LD_INT 60
2784: PUSH
2785: EMPTY
2786: LIST
2787: PUSH
2788: EMPTY
2789: LIST
2790: LIST
2791: PUSH
2792: EMPTY
2793: LIST
2794: LIST
2795: LIST
2796: PUSH
2797: EMPTY
2798: LIST
2799: PPUSH
2800: CALL_OW 69
2804: ST_TO_ADDR
// x := SpeedFilter ( FilterAllUnits ( [ f_enemy , 2 ] ) , 20 ) ;
2805: LD_ADDR_VAR 0 3
2809: PUSH
2810: LD_INT 81
2812: PUSH
2813: LD_INT 2
2815: PUSH
2816: EMPTY
2817: LIST
2818: LIST
2819: PPUSH
2820: CALL_OW 69
2824: PPUSH
2825: LD_INT 20
2827: PPUSH
2828: CALL 8378 0 2
2832: ST_TO_ADDR
// for i = 1 to filter do
2833: LD_ADDR_VAR 0 1
2837: PUSH
2838: DOUBLE
2839: LD_INT 1
2841: DEC
2842: ST_TO_ADDR
2843: LD_VAR 0 4
2847: PUSH
2848: FOR_TO
2849: IFFALSE 2889
// ComAttackUnit ( filter [ i ] , NearestUnitToUnit ( x , filter [ i ] ) ) ;
2851: LD_VAR 0 4
2855: PUSH
2856: LD_VAR 0 1
2860: ARRAY
2861: PPUSH
2862: LD_VAR 0 3
2866: PPUSH
2867: LD_VAR 0 4
2871: PUSH
2872: LD_VAR 0 1
2876: ARRAY
2877: PPUSH
2878: CALL_OW 74
2882: PPUSH
2883: CALL_OW 115
2887: GO 2848
2889: POP
2890: POP
// end ; if FilterAllUnits ( [ [ [ f_side , 3 ] , [ f_not , [ f_hastask ] ] ] ] ) > 0 then
2891: LD_INT 22
2893: PUSH
2894: LD_INT 3
2896: PUSH
2897: EMPTY
2898: LIST
2899: LIST
2900: PUSH
2901: LD_INT 3
2903: PUSH
2904: LD_INT 60
2906: PUSH
2907: EMPTY
2908: LIST
2909: PUSH
2910: EMPTY
2911: LIST
2912: LIST
2913: PUSH
2914: EMPTY
2915: LIST
2916: LIST
2917: PUSH
2918: EMPTY
2919: LIST
2920: PPUSH
2921: CALL_OW 69
2925: PUSH
2926: LD_INT 0
2928: GREATER
2929: IFFALSE 3075
// begin filter := FilterAllUnits ( [ [ [ f_side , 3 ] , [ f_not , [ f_weapon , ar_control_tower ] ] , [ f_not , [ f_hastask ] ] ] ] ) ;
2931: LD_ADDR_VAR 0 4
2935: PUSH
2936: LD_INT 22
2938: PUSH
2939: LD_INT 3
2941: PUSH
2942: EMPTY
2943: LIST
2944: LIST
2945: PUSH
2946: LD_INT 3
2948: PUSH
2949: LD_INT 34
2951: PUSH
2952: LD_INT 31
2954: PUSH
2955: EMPTY
2956: LIST
2957: LIST
2958: PUSH
2959: EMPTY
2960: LIST
2961: LIST
2962: PUSH
2963: LD_INT 3
2965: PUSH
2966: LD_INT 60
2968: PUSH
2969: EMPTY
2970: LIST
2971: PUSH
2972: EMPTY
2973: LIST
2974: LIST
2975: PUSH
2976: EMPTY
2977: LIST
2978: LIST
2979: LIST
2980: PUSH
2981: EMPTY
2982: LIST
2983: PPUSH
2984: CALL_OW 69
2988: ST_TO_ADDR
// x := SpeedFilter ( FilterAllUnits ( [ f_enemy , 3 ] ) , 20 ) ;
2989: LD_ADDR_VAR 0 3
2993: PUSH
2994: LD_INT 81
2996: PUSH
2997: LD_INT 3
2999: PUSH
3000: EMPTY
3001: LIST
3002: LIST
3003: PPUSH
3004: CALL_OW 69
3008: PPUSH
3009: LD_INT 20
3011: PPUSH
3012: CALL 8378 0 2
3016: ST_TO_ADDR
// for i = 1 to filter do
3017: LD_ADDR_VAR 0 1
3021: PUSH
3022: DOUBLE
3023: LD_INT 1
3025: DEC
3026: ST_TO_ADDR
3027: LD_VAR 0 4
3031: PUSH
3032: FOR_TO
3033: IFFALSE 3073
// ComAttackUnit ( filter [ i ] , NearestUnitToUnit ( x , filter [ i ] ) ) ;
3035: LD_VAR 0 4
3039: PUSH
3040: LD_VAR 0 1
3044: ARRAY
3045: PPUSH
3046: LD_VAR 0 3
3050: PPUSH
3051: LD_VAR 0 4
3055: PUSH
3056: LD_VAR 0 1
3060: ARRAY
3061: PPUSH
3062: CALL_OW 74
3066: PPUSH
3067: CALL_OW 115
3071: GO 3032
3073: POP
3074: POP
// end ; if FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_not , [ f_hastask ] ] ] ] ) > 0 then
3075: LD_INT 22
3077: PUSH
3078: LD_INT 1
3080: PUSH
3081: EMPTY
3082: LIST
3083: LIST
3084: PUSH
3085: LD_INT 3
3087: PUSH
3088: LD_INT 60
3090: PUSH
3091: EMPTY
3092: LIST
3093: PUSH
3094: EMPTY
3095: LIST
3096: LIST
3097: PUSH
3098: EMPTY
3099: LIST
3100: LIST
3101: PUSH
3102: EMPTY
3103: LIST
3104: PPUSH
3105: CALL_OW 69
3109: PUSH
3110: LD_INT 0
3112: GREATER
3113: IFFALSE 3259
// begin filter := FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_not , [ f_weapon , ar_control_tower ] ] , [ f_not , [ f_hastask ] ] ] ] ) ;
3115: LD_ADDR_VAR 0 4
3119: PUSH
3120: LD_INT 22
3122: PUSH
3123: LD_INT 1
3125: PUSH
3126: EMPTY
3127: LIST
3128: LIST
3129: PUSH
3130: LD_INT 3
3132: PUSH
3133: LD_INT 34
3135: PUSH
3136: LD_INT 31
3138: PUSH
3139: EMPTY
3140: LIST
3141: LIST
3142: PUSH
3143: EMPTY
3144: LIST
3145: LIST
3146: PUSH
3147: LD_INT 3
3149: PUSH
3150: LD_INT 60
3152: PUSH
3153: EMPTY
3154: LIST
3155: PUSH
3156: EMPTY
3157: LIST
3158: LIST
3159: PUSH
3160: EMPTY
3161: LIST
3162: LIST
3163: LIST
3164: PUSH
3165: EMPTY
3166: LIST
3167: PPUSH
3168: CALL_OW 69
3172: ST_TO_ADDR
// x := SpeedFilter ( FilterAllUnits ( [ f_enemy , 1 ] ) , 20 ) ;
3173: LD_ADDR_VAR 0 3
3177: PUSH
3178: LD_INT 81
3180: PUSH
3181: LD_INT 1
3183: PUSH
3184: EMPTY
3185: LIST
3186: LIST
3187: PPUSH
3188: CALL_OW 69
3192: PPUSH
3193: LD_INT 20
3195: PPUSH
3196: CALL 8378 0 2
3200: ST_TO_ADDR
// for i = 1 to filter do
3201: LD_ADDR_VAR 0 1
3205: PUSH
3206: DOUBLE
3207: LD_INT 1
3209: DEC
3210: ST_TO_ADDR
3211: LD_VAR 0 4
3215: PUSH
3216: FOR_TO
3217: IFFALSE 3257
// ComAttackUnit ( filter [ i ] , NearestUnitToUnit ( x , filter [ i ] ) ) ;
3219: LD_VAR 0 4
3223: PUSH
3224: LD_VAR 0 1
3228: ARRAY
3229: PPUSH
3230: LD_VAR 0 3
3234: PPUSH
3235: LD_VAR 0 4
3239: PUSH
3240: LD_VAR 0 1
3244: ARRAY
3245: PPUSH
3246: CALL_OW 74
3250: PPUSH
3251: CALL_OW 115
3255: GO 3216
3257: POP
3258: POP
// end ; if FilterAllUnits ( [ [ [ f_side , 2 ] , [ f_weapon , ar_bio_bomb ] , [ f_not , [ f_lives , 700 ] ] ] ] ) > 0 then
3259: LD_INT 22
3261: PUSH
3262: LD_INT 2
3264: PUSH
3265: EMPTY
3266: LIST
3267: LIST
3268: PUSH
3269: LD_INT 34
3271: PUSH
3272: LD_EXP 56
3276: PUSH
3277: EMPTY
3278: LIST
3279: LIST
3280: PUSH
3281: LD_INT 3
3283: PUSH
3284: LD_INT 24
3286: PUSH
3287: LD_INT 700
3289: PUSH
3290: EMPTY
3291: LIST
3292: LIST
3293: PUSH
3294: EMPTY
3295: LIST
3296: LIST
3297: PUSH
3298: EMPTY
3299: LIST
3300: LIST
3301: LIST
3302: PUSH
3303: EMPTY
3304: LIST
3305: PPUSH
3306: CALL_OW 69
3310: PUSH
3311: LD_INT 0
3313: GREATER
3314: IFFALSE 3413
// begin filter := FilterAllUnits ( [ [ [ f_side , 2 ] , [ f_weapon , ar_bio_bomb ] , [ f_not , [ f_lives , 700 ] ] ] ] ) ;
3316: LD_ADDR_VAR 0 4
3320: PUSH
3321: LD_INT 22
3323: PUSH
3324: LD_INT 2
3326: PUSH
3327: EMPTY
3328: LIST
3329: LIST
3330: PUSH
3331: LD_INT 34
3333: PUSH
3334: LD_EXP 56
3338: PUSH
3339: EMPTY
3340: LIST
3341: LIST
3342: PUSH
3343: LD_INT 3
3345: PUSH
3346: LD_INT 24
3348: PUSH
3349: LD_INT 700
3351: PUSH
3352: EMPTY
3353: LIST
3354: LIST
3355: PUSH
3356: EMPTY
3357: LIST
3358: LIST
3359: PUSH
3360: EMPTY
3361: LIST
3362: LIST
3363: LIST
3364: PUSH
3365: EMPTY
3366: LIST
3367: PPUSH
3368: CALL_OW 69
3372: ST_TO_ADDR
// for i = 1 to filter do
3373: LD_ADDR_VAR 0 1
3377: PUSH
3378: DOUBLE
3379: LD_INT 1
3381: DEC
3382: ST_TO_ADDR
3383: LD_VAR 0 4
3387: PUSH
3388: FOR_TO
3389: IFFALSE 3411
// SetLives ( filter [ i ] , 1 ) ;
3391: LD_VAR 0 4
3395: PUSH
3396: LD_VAR 0 1
3400: ARRAY
3401: PPUSH
3402: LD_INT 1
3404: PPUSH
3405: CALL_OW 234
3409: GO 3388
3411: POP
3412: POP
// end ; end ; end_of_file
3413: PPOPN 4
3415: END
// export function Start_Mission ; begin
3416: LD_INT 0
3418: PPUSH
// PrepareLegion ;
3419: CALL 3460 0 0
// PrepareMeeting ;
3423: CALL 4074 0 0
// case Query ( DS-text-beg ) of 1 :
3427: LD_STRING DS-text-beg
3429: PPUSH
3430: CALL_OW 97
3434: PUSH
3435: LD_INT 1
3437: DOUBLE
3438: EQUAL
3439: IFTRUE 3443
3441: GO 3446
3443: POP
// ; end ;
3444: GO 3447
3446: POP
// game_on := true ;
3447: LD_ADDR_EXP 1
3451: PUSH
3452: LD_INT 1
3454: ST_TO_ADDR
// end ;
3455: LD_VAR 0 1
3459: RET
// export l_cmndr , l_skill , l_units ; function PrepareLegion ; var i , p , filter , team ; begin
3460: LD_INT 0
3462: PPUSH
3463: PPUSH
3464: PPUSH
3465: PPUSH
3466: PPUSH
// uc_side := 8 ;
3467: LD_ADDR_OWVAR 20
3471: PUSH
3472: LD_INT 8
3474: ST_TO_ADDR
// uc_nation := 2 ;
3475: LD_ADDR_OWVAR 21
3479: PUSH
3480: LD_INT 2
3482: ST_TO_ADDR
// l_skill := [ 7 , 6 , 5 ] [ difficulty ] ;
3483: LD_ADDR_EXP 50
3487: PUSH
3488: LD_INT 7
3490: PUSH
3491: LD_INT 6
3493: PUSH
3494: LD_INT 5
3496: PUSH
3497: EMPTY
3498: LIST
3499: LIST
3500: LIST
3501: PUSH
3502: LD_OWVAR 67
3506: ARRAY
3507: ST_TO_ADDR
// l_units := [ 8 , 7 , 6 ] [ difficulty ] ;
3508: LD_ADDR_EXP 51
3512: PUSH
3513: LD_INT 8
3515: PUSH
3516: LD_INT 7
3518: PUSH
3519: LD_INT 6
3521: PUSH
3522: EMPTY
3523: LIST
3524: LIST
3525: LIST
3526: PUSH
3527: LD_OWVAR 67
3531: ARRAY
3532: ST_TO_ADDR
// filter := [ ] ;
3533: LD_ADDR_VAR 0 4
3537: PUSH
3538: EMPTY
3539: ST_TO_ADDR
// hc_gallery := desert ;
3540: LD_ADDR_OWVAR 33
3544: PUSH
3545: LD_STRING desert
3547: ST_TO_ADDR
// hc_face_number := 1 ;
3548: LD_ADDR_OWVAR 34
3552: PUSH
3553: LD_INT 1
3555: ST_TO_ADDR
// hc_skills := [ l_skill + 2 , l_skill - 1 , l_skill , l_skill + 1 ] ;
3556: LD_ADDR_OWVAR 31
3560: PUSH
3561: LD_EXP 50
3565: PUSH
3566: LD_INT 2
3568: PLUS
3569: PUSH
3570: LD_EXP 50
3574: PUSH
3575: LD_INT 1
3577: MINUS
3578: PUSH
3579: LD_EXP 50
3583: PUSH
3584: LD_EXP 50
3588: PUSH
3589: LD_INT 1
3591: PLUS
3592: PUSH
3593: EMPTY
3594: LIST
3595: LIST
3596: LIST
3597: LIST
3598: ST_TO_ADDR
// hc_sex := sex_male ;
3599: LD_ADDR_OWVAR 27
3603: PUSH
3604: LD_INT 1
3606: ST_TO_ADDR
// hc_name := Henri Ruotz ;
3607: LD_ADDR_OWVAR 26
3611: PUSH
3612: LD_STRING Henri Ruotz
3614: ST_TO_ADDR
// hc_attr := [ 10 , 10 ] ;
3615: LD_ADDR_OWVAR 29
3619: PUSH
3620: LD_INT 10
3622: PUSH
3623: LD_INT 10
3625: PUSH
3626: EMPTY
3627: LIST
3628: LIST
3629: ST_TO_ADDR
// hc_class := 1 ;
3630: LD_ADDR_OWVAR 28
3634: PUSH
3635: LD_INT 1
3637: ST_TO_ADDR
// hc_importance := 100 ;
3638: LD_ADDR_OWVAR 32
3642: PUSH
3643: LD_INT 100
3645: ST_TO_ADDR
// l_cmndr := CreateHuman ;
3646: LD_ADDR_EXP 49
3650: PUSH
3651: CALL_OW 44
3655: ST_TO_ADDR
// hc_importance := 0 ;
3656: LD_ADDR_OWVAR 32
3660: PUSH
3661: LD_INT 0
3663: ST_TO_ADDR
// scout := CreateHumanWithClass ( 1 , 0 ) ;
3664: LD_ADDR_EXP 12
3668: PUSH
3669: LD_INT 1
3671: PPUSH
3672: LD_INT 0
3674: PPUSH
3675: CALL 7179 0 2
3679: ST_TO_ADDR
// for i = 1 to 4 do
3680: LD_ADDR_VAR 0 2
3684: PUSH
3685: DOUBLE
3686: LD_INT 1
3688: DEC
3689: ST_TO_ADDR
3690: LD_INT 4
3692: PUSH
3693: FOR_TO
3694: IFFALSE 3744
// for p = 1 to 6 do
3696: LD_ADDR_VAR 0 3
3700: PUSH
3701: DOUBLE
3702: LD_INT 1
3704: DEC
3705: ST_TO_ADDR
3706: LD_INT 6
3708: PUSH
3709: FOR_TO
3710: IFFALSE 3740
// filter := filter ^ CreateHumanWithClass ( i , l_skill ) ;
3712: LD_ADDR_VAR 0 4
3716: PUSH
3717: LD_VAR 0 4
3721: PUSH
3722: LD_VAR 0 2
3726: PPUSH
3727: LD_EXP 50
3731: PPUSH
3732: CALL 7179 0 2
3736: ADD
3737: ST_TO_ADDR
3738: GO 3709
3740: POP
3741: POP
3742: GO 3693
3744: POP
3745: POP
// team := CharacterSelection ( text , l_units , l_units , [ sel_change_class , l_cmndr , sel_changeable , sel_not_hired ] ^ filter , [ class_soldier , class_mechanic , class_engineer , class_scientistic , class_mortar ] ) ;
3746: LD_ADDR_VAR 0 5
3750: PUSH
3751: LD_STRING text
3753: PPUSH
3754: LD_EXP 51
3758: PPUSH
3759: LD_EXP 51
3763: PPUSH
3764: LD_INT -5
3766: PUSH
3767: LD_EXP 49
3771: PUSH
3772: LD_INT -3
3774: PUSH
3775: LD_INT -2
3777: PUSH
3778: EMPTY
3779: LIST
3780: LIST
3781: LIST
3782: LIST
3783: PUSH
3784: LD_VAR 0 4
3788: ADD
3789: PPUSH
3790: LD_INT 1
3792: PUSH
3793: LD_INT 3
3795: PUSH
3796: LD_INT 2
3798: PUSH
3799: LD_INT 4
3801: PUSH
3802: LD_INT 8
3804: PUSH
3805: EMPTY
3806: LIST
3807: LIST
3808: LIST
3809: LIST
3810: LIST
3811: PPUSH
3812: CALL_OW 42
3816: ST_TO_ADDR
// for i = 1 to l_units do
3817: LD_ADDR_VAR 0 2
3821: PUSH
3822: DOUBLE
3823: LD_INT 1
3825: DEC
3826: ST_TO_ADDR
3827: LD_EXP 51
3831: PUSH
3832: FOR_TO
3833: IFFALSE 3858
// PlaceUnitArea ( team [ i ] , legion_spawn , false ) ;
3835: LD_VAR 0 5
3839: PUSH
3840: LD_VAR 0 2
3844: ARRAY
3845: PPUSH
3846: LD_INT 1
3848: PPUSH
3849: LD_INT 0
3851: PPUSH
3852: CALL_OW 49
3856: GO 3832
3858: POP
3859: POP
// PlaceUnitArea ( l_cmndr , legion_spawn , false ) ;
3860: LD_EXP 49
3864: PPUSH
3865: LD_INT 1
3867: PPUSH
3868: LD_INT 0
3870: PPUSH
3871: CALL_OW 49
// end ;
3875: LD_VAR 0 1
3879: RET
// export function PlaceCamera ; begin
3880: LD_INT 0
3882: PPUSH
// PlaceSeeing ( 46 , 48 , 8 , 10 ) ;
3883: LD_INT 46
3885: PPUSH
3886: LD_INT 48
3888: PPUSH
3889: LD_INT 8
3891: PPUSH
3892: LD_INT 10
3894: PPUSH
3895: CALL_OW 330
// PlaceSeeing ( 58 , 66 , 8 , 10 ) ;
3899: LD_INT 58
3901: PPUSH
3902: LD_INT 66
3904: PPUSH
3905: LD_INT 8
3907: PPUSH
3908: LD_INT 10
3910: PPUSH
3911: CALL_OW 330
// PlaceSeeing ( 82 , 82 , 8 , 10 ) ;
3915: LD_INT 82
3917: PPUSH
3918: LD_INT 82
3920: PPUSH
3921: LD_INT 8
3923: PPUSH
3924: LD_INT 10
3926: PPUSH
3927: CALL_OW 330
// PlaceSeeing ( 107 , 79 , 8 , 10 ) ;
3931: LD_INT 107
3933: PPUSH
3934: LD_INT 79
3936: PPUSH
3937: LD_INT 8
3939: PPUSH
3940: LD_INT 10
3942: PPUSH
3943: CALL_OW 330
// PlaceSeeing ( 101 , 57 , 8 , 10 ) ;
3947: LD_INT 101
3949: PPUSH
3950: LD_INT 57
3952: PPUSH
3953: LD_INT 8
3955: PPUSH
3956: LD_INT 10
3958: PPUSH
3959: CALL_OW 330
// PlaceSeeing ( 85 , 32 , 8 , 10 ) ;
3963: LD_INT 85
3965: PPUSH
3966: LD_INT 32
3968: PPUSH
3969: LD_INT 8
3971: PPUSH
3972: LD_INT 10
3974: PPUSH
3975: CALL_OW 330
// PlaceSeeing ( 108 , 72 , 8 , 10 ) ;
3979: LD_INT 108
3981: PPUSH
3982: LD_INT 72
3984: PPUSH
3985: LD_INT 8
3987: PPUSH
3988: LD_INT 10
3990: PPUSH
3991: CALL_OW 330
// PlaceSeeing ( 124 , 74 , 8 , 10 ) ;
3995: LD_INT 124
3997: PPUSH
3998: LD_INT 74
4000: PPUSH
4001: LD_INT 8
4003: PPUSH
4004: LD_INT 10
4006: PPUSH
4007: CALL_OW 330
// PlaceSeeing ( 67 , 33 , 8 , 20 ) ;
4011: LD_INT 67
4013: PPUSH
4014: LD_INT 33
4016: PPUSH
4017: LD_INT 8
4019: PPUSH
4020: LD_INT 20
4022: PPUSH
4023: CALL_OW 330
// RemoveSeeing ( 67 , 33 , 8 ) ;
4027: LD_INT 67
4029: PPUSH
4030: LD_INT 33
4032: PPUSH
4033: LD_INT 8
4035: PPUSH
4036: CALL_OW 331
// PlaceSeeing ( 94 , 84 , 8 , 20 ) ;
4040: LD_INT 94
4042: PPUSH
4043: LD_INT 84
4045: PPUSH
4046: LD_INT 8
4048: PPUSH
4049: LD_INT 20
4051: PPUSH
4052: CALL_OW 330
// RemoveSeeing ( 94 , 84 , 8 ) ;
4056: LD_INT 94
4058: PPUSH
4059: LD_INT 84
4061: PPUSH
4062: LD_INT 8
4064: PPUSH
4065: CALL_OW 331
// end ;
4069: LD_VAR 0 1
4073: RET
// export function PrepareMeeting ; begin
4074: LD_INT 0
4076: PPUSH
// uc_side := 6 ;
4077: LD_ADDR_OWVAR 20
4081: PUSH
4082: LD_INT 6
4084: ST_TO_ADDR
// hc_gallery := desert ;
4085: LD_ADDR_OWVAR 33
4089: PUSH
4090: LD_STRING desert
4092: ST_TO_ADDR
// hc_face_number := 2 ;
4093: LD_ADDR_OWVAR 34
4097: PUSH
4098: LD_INT 2
4100: ST_TO_ADDR
// hc_name := Leopold Drass ;
4101: LD_ADDR_OWVAR 26
4105: PUSH
4106: LD_STRING Leopold Drass
4108: ST_TO_ADDR
// hc_class := 1 ;
4109: LD_ADDR_OWVAR 28
4113: PUSH
4114: LD_INT 1
4116: ST_TO_ADDR
// hc_sex := sex_male ;
4117: LD_ADDR_OWVAR 27
4121: PUSH
4122: LD_INT 1
4124: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
4125: LD_ADDR_OWVAR 29
4129: PUSH
4130: LD_INT 12
4132: PUSH
4133: LD_INT 12
4135: PUSH
4136: EMPTY
4137: LIST
4138: LIST
4139: ST_TO_ADDR
// Leopold := CreateHuman ;
4140: LD_ADDR_EXP 7
4144: PUSH
4145: CALL_OW 44
4149: ST_TO_ADDR
// PlaceUnitArea ( Leopold , north_spawn , false ) ;
4150: LD_EXP 7
4154: PPUSH
4155: LD_INT 3
4157: PPUSH
4158: LD_INT 0
4160: PPUSH
4161: CALL_OW 49
// end ; end_of_file
4165: LD_VAR 0 1
4169: RET
// on SailEvent ( num ) do var i , filter , un , p , area ;
4170: LD_INT 0
4172: PPUSH
4173: PPUSH
4174: PPUSH
4175: PPUSH
4176: PPUSH
// begin case num of 1 :
4177: LD_VAR 0 1
4181: PUSH
4182: LD_INT 1
4184: DOUBLE
4185: EQUAL
4186: IFTRUE 4190
4188: GO 4222
4190: POP
// begin ComMoveXY ( leopold , GetX ( l_cmndr ) , GetY ( l_cmndr ) ) ;
4191: LD_EXP 7
4195: PPUSH
4196: LD_EXP 49
4200: PPUSH
4201: CALL_OW 250
4205: PPUSH
4206: LD_EXP 49
4210: PPUSH
4211: CALL_OW 251
4215: PPUSH
4216: CALL_OW 111
// end ; 2 :
4220: GO 6591
4222: LD_INT 2
4224: DOUBLE
4225: EQUAL
4226: IFTRUE 4230
4228: GO 4339
4230: POP
// begin InGameOn ;
4231: CALL_OW 8
// meeting_start := true ;
4235: LD_ADDR_EXP 26
4239: PUSH
4240: LD_INT 1
4242: ST_TO_ADDR
// ComTurnUnit ( leopold , l_cmndr ) ;
4243: LD_EXP 7
4247: PPUSH
4248: LD_EXP 49
4252: PPUSH
4253: CALL_OW 119
// ComTurnUnit ( l_cmndr , leopold ) ;
4257: LD_EXP 49
4261: PPUSH
4262: LD_EXP 7
4266: PPUSH
4267: CALL_OW 119
// Say ( leopold , DS-DL-1 ) ;
4271: LD_EXP 7
4275: PPUSH
4276: LD_STRING DS-DL-1
4278: PPUSH
4279: CALL_OW 88
// Say ( l_cmndr , DS-DC-1 ) ;
4283: LD_EXP 49
4287: PPUSH
4288: LD_STRING DS-DC-1
4290: PPUSH
4291: CALL_OW 88
// Say ( leopold , DS-DL-2 ) ;
4295: LD_EXP 7
4299: PPUSH
4300: LD_STRING DS-DL-2
4302: PPUSH
4303: CALL_OW 88
// ComEnterUnit ( leopold , fort ) ;
4307: LD_EXP 7
4311: PPUSH
4312: LD_INT 23
4314: PPUSH
4315: CALL_OW 120
// InGameOff ;
4319: CALL_OW 9
// Wait ( 0 0$01 ) ;
4323: LD_INT 35
4325: PPUSH
4326: CALL_OW 67
// ChangeMissionObjectives ( DS-T1 ) ;
4330: LD_STRING DS-T1
4332: PPUSH
4333: CALL_OW 337
// end ; 10 :
4337: GO 6591
4339: LD_INT 10
4341: DOUBLE
4342: EQUAL
4343: IFTRUE 4347
4345: GO 4559
4347: POP
// begin uc_side := 6 ;
4348: LD_ADDR_OWVAR 20
4352: PUSH
4353: LD_INT 6
4355: ST_TO_ADDR
// uc_nation := 2 ;
4356: LD_ADDR_OWVAR 21
4360: PUSH
4361: LD_INT 2
4363: ST_TO_ADDR
// hc_gallery :=  ;
4364: LD_ADDR_OWVAR 33
4368: PUSH
4369: LD_STRING 
4371: ST_TO_ADDR
// hc_skills := [ skill + 2 , skill - 1 , skill , skill + 1 ] ;
4372: LD_ADDR_OWVAR 31
4376: PUSH
4377: LD_EXP 16
4381: PUSH
4382: LD_INT 2
4384: PLUS
4385: PUSH
4386: LD_EXP 16
4390: PUSH
4391: LD_INT 1
4393: MINUS
4394: PUSH
4395: LD_EXP 16
4399: PUSH
4400: LD_EXP 16
4404: PUSH
4405: LD_INT 1
4407: PLUS
4408: PUSH
4409: EMPTY
4410: LIST
4411: LIST
4412: LIST
4413: LIST
4414: ST_TO_ADDR
// hc_sex := sex_male ;
4415: LD_ADDR_OWVAR 27
4419: PUSH
4420: LD_INT 1
4422: ST_TO_ADDR
// hc_name := Samuel van Horn ;
4423: LD_ADDR_OWVAR 26
4427: PUSH
4428: LD_STRING Samuel van Horn
4430: ST_TO_ADDR
// hc_attr := [ 11 , 10 ] ;
4431: LD_ADDR_OWVAR 29
4435: PUSH
4436: LD_INT 11
4438: PUSH
4439: LD_INT 10
4441: PUSH
4442: EMPTY
4443: LIST
4444: LIST
4445: ST_TO_ADDR
// hc_class := 1 ;
4446: LD_ADDR_OWVAR 28
4450: PUSH
4451: LD_INT 1
4453: ST_TO_ADDR
// samuel := CreateHuman ;
4454: LD_ADDR_EXP 9
4458: PUSH
4459: CALL_OW 44
4463: ST_TO_ADDR
// PlaceUnitArea ( samuel , south_spawn , false ) ;
4464: LD_EXP 9
4468: PPUSH
4469: LD_INT 4
4471: PPUSH
4472: LD_INT 0
4474: PPUSH
4475: CALL_OW 49
// for i = 1 to 3 do
4479: LD_ADDR_VAR 0 2
4483: PUSH
4484: DOUBLE
4485: LD_INT 1
4487: DEC
4488: ST_TO_ADDR
4489: LD_INT 3
4491: PUSH
4492: FOR_TO
4493: IFFALSE 4520
// PlaceUnitArea ( CreateHumanWithClass ( class_mortar , skill ) , south_spawn , false ) ;
4495: LD_INT 8
4497: PPUSH
4498: LD_EXP 16
4502: PPUSH
4503: CALL 7179 0 2
4507: PPUSH
4508: LD_INT 4
4510: PPUSH
4511: LD_INT 0
4513: PPUSH
4514: CALL_OW 49
4518: GO 4492
4520: POP
4521: POP
// ComEnterUnit ( FilterAllUnits ( [ f_side , 6 ] ) diff [ leopold , fort ] , fort ) ;
4522: LD_INT 22
4524: PUSH
4525: LD_INT 6
4527: PUSH
4528: EMPTY
4529: LIST
4530: LIST
4531: PPUSH
4532: CALL_OW 69
4536: PUSH
4537: LD_EXP 7
4541: PUSH
4542: LD_INT 23
4544: PUSH
4545: EMPTY
4546: LIST
4547: LIST
4548: DIFF
4549: PPUSH
4550: LD_INT 23
4552: PPUSH
4553: CALL_OW 120
// end ; 3 :
4557: GO 6591
4559: LD_INT 3
4561: DOUBLE
4562: EQUAL
4563: IFTRUE 4567
4565: GO 4578
4567: POP
// begin arabian_attack := true ;
4568: LD_ADDR_EXP 38
4572: PUSH
4573: LD_INT 1
4575: ST_TO_ADDR
// end ; 4 :
4576: GO 6591
4578: LD_INT 4
4580: DOUBLE
4581: EQUAL
4582: IFTRUE 4586
4584: GO 4597
4586: POP
// begin american_attack := true ;
4587: LD_ADDR_EXP 40
4591: PUSH
4592: LD_INT 1
4594: ST_TO_ADDR
// end ; 5 :
4595: GO 6591
4597: LD_INT 5
4599: DOUBLE
4600: EQUAL
4601: IFTRUE 4605
4603: GO 4616
4605: POP
// begin russian_attack := true ;
4606: LD_ADDR_EXP 39
4610: PUSH
4611: LD_INT 1
4613: ST_TO_ADDR
// end ; 31 :
4614: GO 6591
4616: LD_INT 31
4618: DOUBLE
4619: EQUAL
4620: IFTRUE 4624
4622: GO 4899
4624: POP
// begin area := areas [ Rand ( 1 , areas ) ] ;
4625: LD_ADDR_VAR 0 6
4629: PUSH
4630: LD_EXP 15
4634: PUSH
4635: LD_INT 1
4637: PPUSH
4638: LD_EXP 15
4642: PPUSH
4643: CALL_OW 12
4647: ARRAY
4648: ST_TO_ADDR
// uc_side := 2 ;
4649: LD_ADDR_OWVAR 20
4653: PUSH
4654: LD_INT 2
4656: ST_TO_ADDR
// uc_nation := 2 ;
4657: LD_ADDR_OWVAR 21
4661: PUSH
4662: LD_INT 2
4664: ST_TO_ADDR
// for i = 1 to arabian_force do
4665: LD_ADDR_VAR 0 2
4669: PUSH
4670: DOUBLE
4671: LD_INT 1
4673: DEC
4674: ST_TO_ADDR
4675: LD_EXP 20
4679: PUSH
4680: FOR_TO
4681: IFFALSE 4760
// begin vc_chassis := ar_half_tracked ;
4683: LD_ADDR_OWVAR 37
4687: PUSH
4688: LD_INT 14
4690: ST_TO_ADDR
// vc_engine := engine_siberite ;
4691: LD_ADDR_OWVAR 39
4695: PUSH
4696: LD_INT 3
4698: ST_TO_ADDR
// vc_control := control_remote ;
4699: LD_ADDR_OWVAR 38
4703: PUSH
4704: LD_INT 2
4706: ST_TO_ADDR
// vc_weapon := ar_weapons [ Rand ( 1 , ar_weapons ) ] ;
4707: LD_ADDR_OWVAR 40
4711: PUSH
4712: LD_EXP 17
4716: PUSH
4717: LD_INT 1
4719: PPUSH
4720: LD_EXP 17
4724: PPUSH
4725: CALL_OW 12
4729: ARRAY
4730: ST_TO_ADDR
// un := CreateVehicle ;
4731: LD_ADDR_VAR 0 4
4735: PUSH
4736: CALL_OW 45
4740: ST_TO_ADDR
// PlaceUnitArea ( un , area , false ) ;
4741: LD_VAR 0 4
4745: PPUSH
4746: LD_VAR 0 6
4750: PPUSH
4751: LD_INT 0
4753: PPUSH
4754: CALL_OW 49
// end ;
4758: GO 4680
4760: POP
4761: POP
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_control , control_manual ] ] ) < 2 then
4762: LD_INT 22
4764: PUSH
4765: LD_INT 2
4767: PUSH
4768: EMPTY
4769: LIST
4770: LIST
4771: PUSH
4772: LD_INT 33
4774: PUSH
4775: LD_INT 1
4777: PUSH
4778: EMPTY
4779: LIST
4780: LIST
4781: PUSH
4782: EMPTY
4783: LIST
4784: LIST
4785: PPUSH
4786: CALL_OW 69
4790: PUSH
4791: LD_INT 2
4793: LESS
4794: IFFALSE 4897
// for i = 1 to 2 do
4796: LD_ADDR_VAR 0 2
4800: PUSH
4801: DOUBLE
4802: LD_INT 1
4804: DEC
4805: ST_TO_ADDR
4806: LD_INT 2
4808: PUSH
4809: FOR_TO
4810: IFFALSE 4895
// begin vc_chassis := ar_half_tracked ;
4812: LD_ADDR_OWVAR 37
4816: PUSH
4817: LD_INT 14
4819: ST_TO_ADDR
// vc_engine := engine_siberite ;
4820: LD_ADDR_OWVAR 39
4824: PUSH
4825: LD_INT 3
4827: ST_TO_ADDR
// vc_control := control_manual ;
4828: LD_ADDR_OWVAR 38
4832: PUSH
4833: LD_INT 1
4835: ST_TO_ADDR
// vc_weapon := ar_control_tower ;
4836: LD_ADDR_OWVAR 40
4840: PUSH
4841: LD_INT 31
4843: ST_TO_ADDR
// un := CreateVehicle ;
4844: LD_ADDR_VAR 0 4
4848: PUSH
4849: CALL_OW 45
4853: ST_TO_ADDR
// PlaceUnitArea ( un , area , false ) ;
4854: LD_VAR 0 4
4858: PPUSH
4859: LD_VAR 0 6
4863: PPUSH
4864: LD_INT 0
4866: PPUSH
4867: CALL_OW 49
// PlaceHumanInUnit ( CreateHumanWithClass ( 3 , skill ) , un ) ;
4871: LD_INT 3
4873: PPUSH
4874: LD_EXP 16
4878: PPUSH
4879: CALL 7179 0 2
4883: PPUSH
4884: LD_VAR 0 4
4888: PPUSH
4889: CALL_OW 52
// end ;
4893: GO 4809
4895: POP
4896: POP
// end ; 32 :
4897: GO 6591
4899: LD_INT 32
4901: DOUBLE
4902: EQUAL
4903: IFTRUE 4907
4905: GO 5280
4907: POP
// begin area := areas [ Rand ( 1 , areas ) ] ;
4908: LD_ADDR_VAR 0 6
4912: PUSH
4913: LD_EXP 15
4917: PUSH
4918: LD_INT 1
4920: PPUSH
4921: LD_EXP 15
4925: PPUSH
4926: CALL_OW 12
4930: ARRAY
4931: ST_TO_ADDR
// uc_side := 2 ;
4932: LD_ADDR_OWVAR 20
4936: PUSH
4937: LD_INT 2
4939: ST_TO_ADDR
// uc_nation := 2 ;
4940: LD_ADDR_OWVAR 21
4944: PUSH
4945: LD_INT 2
4947: ST_TO_ADDR
// for i = 1 to ( arabian_force - 2 ) do
4948: LD_ADDR_VAR 0 2
4952: PUSH
4953: DOUBLE
4954: LD_INT 1
4956: DEC
4957: ST_TO_ADDR
4958: LD_EXP 20
4962: PUSH
4963: LD_INT 2
4965: MINUS
4966: PUSH
4967: FOR_TO
4968: IFFALSE 5051
// begin vc_chassis := ar_half_tracked ;
4970: LD_ADDR_OWVAR 37
4974: PUSH
4975: LD_INT 14
4977: ST_TO_ADDR
// vc_engine := engine_siberite ;
4978: LD_ADDR_OWVAR 39
4982: PUSH
4983: LD_INT 3
4985: ST_TO_ADDR
// vc_control := control_remote ;
4986: LD_ADDR_OWVAR 38
4990: PUSH
4991: LD_INT 2
4993: ST_TO_ADDR
// vc_weapon := ar_weapons [ Rand ( 1 , ar_weapons - 1 ) ] ;
4994: LD_ADDR_OWVAR 40
4998: PUSH
4999: LD_EXP 17
5003: PUSH
5004: LD_INT 1
5006: PPUSH
5007: LD_EXP 17
5011: PUSH
5012: LD_INT 1
5014: MINUS
5015: PPUSH
5016: CALL_OW 12
5020: ARRAY
5021: ST_TO_ADDR
// un := CreateVehicle ;
5022: LD_ADDR_VAR 0 4
5026: PUSH
5027: CALL_OW 45
5031: ST_TO_ADDR
// PlaceUnitArea ( un , area , false ) ;
5032: LD_VAR 0 4
5036: PPUSH
5037: LD_VAR 0 6
5041: PPUSH
5042: LD_INT 0
5044: PPUSH
5045: CALL_OW 49
// end ;
5049: GO 4967
5051: POP
5052: POP
// for i = 1 to Rand ( 0 , 1 ) + [ 3 , 4 , 5 ] [ game_difficulty ] do
5053: LD_ADDR_VAR 0 2
5057: PUSH
5058: DOUBLE
5059: LD_INT 1
5061: DEC
5062: ST_TO_ADDR
5063: LD_INT 0
5065: PPUSH
5066: LD_INT 1
5068: PPUSH
5069: CALL_OW 12
5073: PUSH
5074: LD_INT 3
5076: PUSH
5077: LD_INT 4
5079: PUSH
5080: LD_INT 5
5082: PUSH
5083: EMPTY
5084: LIST
5085: LIST
5086: LIST
5087: PUSH
5088: LD_EXP 2
5092: ARRAY
5093: PLUS
5094: PUSH
5095: FOR_TO
5096: IFFALSE 5133
// begin uc_nation := 0 ;
5098: LD_ADDR_OWVAR 21
5102: PUSH
5103: LD_INT 0
5105: ST_TO_ADDR
// PlaceUnitArea ( CreateHumanWithClass ( 17 , skill ) , area , false ) ;
5106: LD_INT 17
5108: PPUSH
5109: LD_EXP 16
5113: PPUSH
5114: CALL 7179 0 2
5118: PPUSH
5119: LD_VAR 0 6
5123: PPUSH
5124: LD_INT 0
5126: PPUSH
5127: CALL_OW 49
// end ;
5131: GO 5095
5133: POP
5134: POP
// uc_nation := 2 ;
5135: LD_ADDR_OWVAR 21
5139: PUSH
5140: LD_INT 2
5142: ST_TO_ADDR
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_control , control_manual ] ] ) < 2 then
5143: LD_INT 22
5145: PUSH
5146: LD_INT 2
5148: PUSH
5149: EMPTY
5150: LIST
5151: LIST
5152: PUSH
5153: LD_INT 33
5155: PUSH
5156: LD_INT 1
5158: PUSH
5159: EMPTY
5160: LIST
5161: LIST
5162: PUSH
5163: EMPTY
5164: LIST
5165: LIST
5166: PPUSH
5167: CALL_OW 69
5171: PUSH
5172: LD_INT 2
5174: LESS
5175: IFFALSE 5278
// for i = 1 to 2 do
5177: LD_ADDR_VAR 0 2
5181: PUSH
5182: DOUBLE
5183: LD_INT 1
5185: DEC
5186: ST_TO_ADDR
5187: LD_INT 2
5189: PUSH
5190: FOR_TO
5191: IFFALSE 5276
// begin vc_chassis := ar_half_tracked ;
5193: LD_ADDR_OWVAR 37
5197: PUSH
5198: LD_INT 14
5200: ST_TO_ADDR
// vc_engine := engine_siberite ;
5201: LD_ADDR_OWVAR 39
5205: PUSH
5206: LD_INT 3
5208: ST_TO_ADDR
// vc_control := control_manual ;
5209: LD_ADDR_OWVAR 38
5213: PUSH
5214: LD_INT 1
5216: ST_TO_ADDR
// vc_weapon := ar_control_tower ;
5217: LD_ADDR_OWVAR 40
5221: PUSH
5222: LD_INT 31
5224: ST_TO_ADDR
// un := CreateVehicle ;
5225: LD_ADDR_VAR 0 4
5229: PUSH
5230: CALL_OW 45
5234: ST_TO_ADDR
// PlaceUnitArea ( un , area , false ) ;
5235: LD_VAR 0 4
5239: PPUSH
5240: LD_VAR 0 6
5244: PPUSH
5245: LD_INT 0
5247: PPUSH
5248: CALL_OW 49
// PlaceHumanInUnit ( CreateHumanWithClass ( 3 , skill ) , un ) ;
5252: LD_INT 3
5254: PPUSH
5255: LD_EXP 16
5259: PPUSH
5260: CALL 7179 0 2
5264: PPUSH
5265: LD_VAR 0 4
5269: PPUSH
5270: CALL_OW 52
// end ;
5274: GO 5190
5276: POP
5277: POP
// end ; 33 :
5278: GO 6591
5280: LD_INT 33
5282: DOUBLE
5283: EQUAL
5284: IFTRUE 5288
5286: GO 5559
5288: POP
// begin area := areas [ Rand ( 1 , areas ) ] ;
5289: LD_ADDR_VAR 0 6
5293: PUSH
5294: LD_EXP 15
5298: PUSH
5299: LD_INT 1
5301: PPUSH
5302: LD_EXP 15
5306: PPUSH
5307: CALL_OW 12
5311: ARRAY
5312: ST_TO_ADDR
// uc_side := 2 ;
5313: LD_ADDR_OWVAR 20
5317: PUSH
5318: LD_INT 2
5320: ST_TO_ADDR
// uc_nation := 2 ;
5321: LD_ADDR_OWVAR 21
5325: PUSH
5326: LD_INT 2
5328: ST_TO_ADDR
// for i = 1 to ( arabian_force / 2 ) do
5329: LD_ADDR_VAR 0 2
5333: PUSH
5334: DOUBLE
5335: LD_INT 1
5337: DEC
5338: ST_TO_ADDR
5339: LD_EXP 20
5343: PUSH
5344: LD_INT 2
5346: DIVREAL
5347: PUSH
5348: FOR_TO
5349: IFFALSE 5454
// begin vc_chassis := ar_half_tracked ;
5351: LD_ADDR_OWVAR 37
5355: PUSH
5356: LD_INT 14
5358: ST_TO_ADDR
// vc_engine := engine_siberite ;
5359: LD_ADDR_OWVAR 39
5363: PUSH
5364: LD_INT 3
5366: ST_TO_ADDR
// vc_control := control_manual ;
5367: LD_ADDR_OWVAR 38
5371: PUSH
5372: LD_INT 1
5374: ST_TO_ADDR
// vc_weapon := ar_weapons [ Rand ( 1 , ar_weapons - 2 ) ] ;
5375: LD_ADDR_OWVAR 40
5379: PUSH
5380: LD_EXP 17
5384: PUSH
5385: LD_INT 1
5387: PPUSH
5388: LD_EXP 17
5392: PUSH
5393: LD_INT 2
5395: MINUS
5396: PPUSH
5397: CALL_OW 12
5401: ARRAY
5402: ST_TO_ADDR
// un := CreateVehicle ;
5403: LD_ADDR_VAR 0 4
5407: PUSH
5408: CALL_OW 45
5412: ST_TO_ADDR
// PlaceUnitArea ( un , area , false ) ;
5413: LD_VAR 0 4
5417: PPUSH
5418: LD_VAR 0 6
5422: PPUSH
5423: LD_INT 0
5425: PPUSH
5426: CALL_OW 49
// PlaceHumanInUnit ( CreateHumanWithClass ( 3 , skill ) , un ) ;
5430: LD_INT 3
5432: PPUSH
5433: LD_EXP 16
5437: PPUSH
5438: CALL 7179 0 2
5442: PPUSH
5443: LD_VAR 0 4
5447: PPUSH
5448: CALL_OW 52
// end ;
5452: GO 5348
5454: POP
5455: POP
// for i = 1 to ( arabian_force / 2 ) do
5456: LD_ADDR_VAR 0 2
5460: PUSH
5461: DOUBLE
5462: LD_INT 1
5464: DEC
5465: ST_TO_ADDR
5466: LD_EXP 20
5470: PUSH
5471: LD_INT 2
5473: DIVREAL
5474: PUSH
5475: FOR_TO
5476: IFFALSE 5555
// begin vc_chassis := ar_half_tracked ;
5478: LD_ADDR_OWVAR 37
5482: PUSH
5483: LD_INT 14
5485: ST_TO_ADDR
// vc_engine := engine_siberite ;
5486: LD_ADDR_OWVAR 39
5490: PUSH
5491: LD_INT 3
5493: ST_TO_ADDR
// vc_control := control_apeman ;
5494: LD_ADDR_OWVAR 38
5498: PUSH
5499: LD_INT 5
5501: ST_TO_ADDR
// vc_weapon := ar_weapons [ Rand ( 2 , ar_weapons ) ] ;
5502: LD_ADDR_OWVAR 40
5506: PUSH
5507: LD_EXP 17
5511: PUSH
5512: LD_INT 2
5514: PPUSH
5515: LD_EXP 17
5519: PPUSH
5520: CALL_OW 12
5524: ARRAY
5525: ST_TO_ADDR
// un := CreateVehicle ;
5526: LD_ADDR_VAR 0 4
5530: PUSH
5531: CALL_OW 45
5535: ST_TO_ADDR
// PlaceUnitArea ( un , area , false ) ;
5536: LD_VAR 0 4
5540: PPUSH
5541: LD_VAR 0 6
5545: PPUSH
5546: LD_INT 0
5548: PPUSH
5549: CALL_OW 49
// end ;
5553: GO 5475
5555: POP
5556: POP
// end ; 41 :
5557: GO 6591
5559: LD_INT 41
5561: DOUBLE
5562: EQUAL
5563: IFTRUE 5567
5565: GO 5711
5567: POP
// begin area := areas [ Rand ( 1 , areas ) ] ;
5568: LD_ADDR_VAR 0 6
5572: PUSH
5573: LD_EXP 15
5577: PUSH
5578: LD_INT 1
5580: PPUSH
5581: LD_EXP 15
5585: PPUSH
5586: CALL_OW 12
5590: ARRAY
5591: ST_TO_ADDR
// uc_side := 1 ;
5592: LD_ADDR_OWVAR 20
5596: PUSH
5597: LD_INT 1
5599: ST_TO_ADDR
// uc_nation := 1 ;
5600: LD_ADDR_OWVAR 21
5604: PUSH
5605: LD_INT 1
5607: ST_TO_ADDR
// for i = 1 to american_force do
5608: LD_ADDR_VAR 0 2
5612: PUSH
5613: DOUBLE
5614: LD_INT 1
5616: DEC
5617: ST_TO_ADDR
5618: LD_EXP 22
5622: PUSH
5623: FOR_TO
5624: IFFALSE 5707
// begin vc_chassis := us_morphling ;
5626: LD_ADDR_OWVAR 37
5630: PUSH
5631: LD_INT 5
5633: ST_TO_ADDR
// vc_engine := engine_siberite ;
5634: LD_ADDR_OWVAR 39
5638: PUSH
5639: LD_INT 3
5641: ST_TO_ADDR
// vc_control := control_computer ;
5642: LD_ADDR_OWVAR 38
5646: PUSH
5647: LD_INT 3
5649: ST_TO_ADDR
// vc_weapon := us_weapons [ Rand ( 1 , us_weapons - 1 ) ] ;
5650: LD_ADDR_OWVAR 40
5654: PUSH
5655: LD_EXP 19
5659: PUSH
5660: LD_INT 1
5662: PPUSH
5663: LD_EXP 19
5667: PUSH
5668: LD_INT 1
5670: MINUS
5671: PPUSH
5672: CALL_OW 12
5676: ARRAY
5677: ST_TO_ADDR
// un := CreateVehicle ;
5678: LD_ADDR_VAR 0 4
5682: PUSH
5683: CALL_OW 45
5687: ST_TO_ADDR
// PlaceUnitArea ( un , area , false ) ;
5688: LD_VAR 0 4
5692: PPUSH
5693: LD_VAR 0 6
5697: PPUSH
5698: LD_INT 0
5700: PPUSH
5701: CALL_OW 49
// end ;
5705: GO 5623
5707: POP
5708: POP
// end ; 42 :
5709: GO 6591
5711: LD_INT 42
5713: DOUBLE
5714: EQUAL
5715: IFTRUE 5719
5717: GO 5859
5719: POP
// begin area := areas [ Rand ( 1 , areas ) ] ;
5720: LD_ADDR_VAR 0 6
5724: PUSH
5725: LD_EXP 15
5729: PUSH
5730: LD_INT 1
5732: PPUSH
5733: LD_EXP 15
5737: PPUSH
5738: CALL_OW 12
5742: ARRAY
5743: ST_TO_ADDR
// uc_side := 1 ;
5744: LD_ADDR_OWVAR 20
5748: PUSH
5749: LD_INT 1
5751: ST_TO_ADDR
// uc_nation := 1 ;
5752: LD_ADDR_OWVAR 21
5756: PUSH
5757: LD_INT 1
5759: ST_TO_ADDR
// for i = 1 to american_force do
5760: LD_ADDR_VAR 0 2
5764: PUSH
5765: DOUBLE
5766: LD_INT 1
5768: DEC
5769: ST_TO_ADDR
5770: LD_EXP 22
5774: PUSH
5775: FOR_TO
5776: IFFALSE 5855
// begin vc_chassis := us_morphling ;
5778: LD_ADDR_OWVAR 37
5782: PUSH
5783: LD_INT 5
5785: ST_TO_ADDR
// vc_engine := engine_siberite ;
5786: LD_ADDR_OWVAR 39
5790: PUSH
5791: LD_INT 3
5793: ST_TO_ADDR
// vc_control := control_computer ;
5794: LD_ADDR_OWVAR 38
5798: PUSH
5799: LD_INT 3
5801: ST_TO_ADDR
// vc_weapon := us_weapons [ Rand ( 1 , us_weapons ) ] ;
5802: LD_ADDR_OWVAR 40
5806: PUSH
5807: LD_EXP 19
5811: PUSH
5812: LD_INT 1
5814: PPUSH
5815: LD_EXP 19
5819: PPUSH
5820: CALL_OW 12
5824: ARRAY
5825: ST_TO_ADDR
// un := CreateVehicle ;
5826: LD_ADDR_VAR 0 4
5830: PUSH
5831: CALL_OW 45
5835: ST_TO_ADDR
// PlaceUnitArea ( un , area , false ) ;
5836: LD_VAR 0 4
5840: PPUSH
5841: LD_VAR 0 6
5845: PPUSH
5846: LD_INT 0
5848: PPUSH
5849: CALL_OW 49
// end ;
5853: GO 5775
5855: POP
5856: POP
// end ; 51 :
5857: GO 6591
5859: LD_INT 51
5861: DOUBLE
5862: EQUAL
5863: IFTRUE 5867
5865: GO 6007
5867: POP
// begin area := areas [ Rand ( 1 , areas ) ] ;
5868: LD_ADDR_VAR 0 6
5872: PUSH
5873: LD_EXP 15
5877: PUSH
5878: LD_INT 1
5880: PPUSH
5881: LD_EXP 15
5885: PPUSH
5886: CALL_OW 12
5890: ARRAY
5891: ST_TO_ADDR
// uc_side := 3 ;
5892: LD_ADDR_OWVAR 20
5896: PUSH
5897: LD_INT 3
5899: ST_TO_ADDR
// uc_nation := 3 ;
5900: LD_ADDR_OWVAR 21
5904: PUSH
5905: LD_INT 3
5907: ST_TO_ADDR
// for i = 1 to russian_force do
5908: LD_ADDR_VAR 0 2
5912: PUSH
5913: DOUBLE
5914: LD_INT 1
5916: DEC
5917: ST_TO_ADDR
5918: LD_EXP 21
5922: PUSH
5923: FOR_TO
5924: IFFALSE 6003
// begin vc_chassis := ru_heavy_tracked ;
5926: LD_ADDR_OWVAR 37
5930: PUSH
5931: LD_INT 24
5933: ST_TO_ADDR
// vc_engine := engine_siberite ;
5934: LD_ADDR_OWVAR 39
5938: PUSH
5939: LD_INT 3
5941: ST_TO_ADDR
// vc_control := control_computer ;
5942: LD_ADDR_OWVAR 38
5946: PUSH
5947: LD_INT 3
5949: ST_TO_ADDR
// vc_weapon := ru_weapons [ Rand ( 1 , ru_weapons ) ] ;
5950: LD_ADDR_OWVAR 40
5954: PUSH
5955: LD_EXP 18
5959: PUSH
5960: LD_INT 1
5962: PPUSH
5963: LD_EXP 18
5967: PPUSH
5968: CALL_OW 12
5972: ARRAY
5973: ST_TO_ADDR
// un := CreateVehicle ;
5974: LD_ADDR_VAR 0 4
5978: PUSH
5979: CALL_OW 45
5983: ST_TO_ADDR
// PlaceUnitArea ( un , area , false ) ;
5984: LD_VAR 0 4
5988: PPUSH
5989: LD_VAR 0 6
5993: PPUSH
5994: LD_INT 0
5996: PPUSH
5997: CALL_OW 49
// end ;
6001: GO 5923
6003: POP
6004: POP
// end ; 91 :
6005: GO 6591
6007: LD_INT 91
6009: DOUBLE
6010: EQUAL
6011: IFTRUE 6015
6013: GO 6153
6015: POP
// begin uc_side := 8 ;
6016: LD_ADDR_OWVAR 20
6020: PUSH
6021: LD_INT 8
6023: ST_TO_ADDR
// uc_nation := 1 ;
6024: LD_ADDR_OWVAR 21
6028: PUSH
6029: LD_INT 1
6031: ST_TO_ADDR
// for i = 1 to [ 5 , 4 , 3 ] [ game_difficulty ] do
6032: LD_ADDR_VAR 0 2
6036: PUSH
6037: DOUBLE
6038: LD_INT 1
6040: DEC
6041: ST_TO_ADDR
6042: LD_INT 5
6044: PUSH
6045: LD_INT 4
6047: PUSH
6048: LD_INT 3
6050: PUSH
6051: EMPTY
6052: LIST
6053: LIST
6054: LIST
6055: PUSH
6056: LD_EXP 2
6060: ARRAY
6061: PUSH
6062: FOR_TO
6063: IFFALSE 6149
// begin vc_chassis := us_heavy_tracked ;
6065: LD_ADDR_OWVAR 37
6069: PUSH
6070: LD_INT 4
6072: ST_TO_ADDR
// vc_engine := engine_siberite ;
6073: LD_ADDR_OWVAR 39
6077: PUSH
6078: LD_INT 3
6080: ST_TO_ADDR
// vc_control := control_computer ;
6081: LD_ADDR_OWVAR 38
6085: PUSH
6086: LD_INT 3
6088: ST_TO_ADDR
// vc_weapon := [ us_double_gun , us_heavy_gun ] [ Rand ( 1 , 2 ) ] ;
6089: LD_ADDR_OWVAR 40
6093: PUSH
6094: LD_INT 5
6096: PUSH
6097: LD_INT 6
6099: PUSH
6100: EMPTY
6101: LIST
6102: LIST
6103: PUSH
6104: LD_INT 1
6106: PPUSH
6107: LD_INT 2
6109: PPUSH
6110: CALL_OW 12
6114: ARRAY
6115: ST_TO_ADDR
// un := CreateVehicle ;
6116: LD_ADDR_VAR 0 4
6120: PUSH
6121: CALL_OW 45
6125: ST_TO_ADDR
// PlaceUnitArea ( un , areas [ 1 ] , false ) ;
6126: LD_VAR 0 4
6130: PPUSH
6131: LD_EXP 15
6135: PUSH
6136: LD_INT 1
6138: ARRAY
6139: PPUSH
6140: LD_INT 0
6142: PPUSH
6143: CALL_OW 49
// end ;
6147: GO 6062
6149: POP
6150: POP
// end ; 92 :
6151: GO 6591
6153: LD_INT 92
6155: DOUBLE
6156: EQUAL
6157: IFTRUE 6161
6159: GO 6466
6161: POP
// begin uc_side := 5 ;
6162: LD_ADDR_OWVAR 20
6166: PUSH
6167: LD_INT 5
6169: ST_TO_ADDR
// uc_nation := 2 ;
6170: LD_ADDR_OWVAR 21
6174: PUSH
6175: LD_INT 2
6177: ST_TO_ADDR
// filter := [ ] ;
6178: LD_ADDR_VAR 0 3
6182: PUSH
6183: EMPTY
6184: ST_TO_ADDR
// hc_sex := sex_male ;
6185: LD_ADDR_OWVAR 27
6189: PUSH
6190: LD_INT 1
6192: ST_TO_ADDR
// hc_gallery :=  ;
6193: LD_ADDR_OWVAR 33
6197: PUSH
6198: LD_STRING 
6200: ST_TO_ADDR
// hc_class := 1 ;
6201: LD_ADDR_OWVAR 28
6205: PUSH
6206: LD_INT 1
6208: ST_TO_ADDR
// hc_name :=  ;
6209: LD_ADDR_OWVAR 26
6213: PUSH
6214: LD_STRING 
6216: ST_TO_ADDR
// un := CreateHuman ;
6217: LD_ADDR_VAR 0 4
6221: PUSH
6222: CALL_OW 44
6226: ST_TO_ADDR
// filter := filter ^ un ;
6227: LD_ADDR_VAR 0 3
6231: PUSH
6232: LD_VAR 0 3
6236: PUSH
6237: LD_VAR 0 4
6241: ADD
6242: ST_TO_ADDR
// for i = 1 to [ 4 , 3 , 2 ] [ game_difficulty ] do
6243: LD_ADDR_VAR 0 2
6247: PUSH
6248: DOUBLE
6249: LD_INT 1
6251: DEC
6252: ST_TO_ADDR
6253: LD_INT 4
6255: PUSH
6256: LD_INT 3
6258: PUSH
6259: LD_INT 2
6261: PUSH
6262: EMPTY
6263: LIST
6264: LIST
6265: LIST
6266: PUSH
6267: LD_EXP 2
6271: ARRAY
6272: PUSH
6273: FOR_TO
6274: IFFALSE 6312
// begin un := CreateHumanWithClass ( 1 , l_skill ) ;
6276: LD_ADDR_VAR 0 4
6280: PUSH
6281: LD_INT 1
6283: PPUSH
6284: LD_EXP 50
6288: PPUSH
6289: CALL 7179 0 2
6293: ST_TO_ADDR
// filter := filter ^ un ;
6294: LD_ADDR_VAR 0 3
6298: PUSH
6299: LD_VAR 0 3
6303: PUSH
6304: LD_VAR 0 4
6308: ADD
6309: ST_TO_ADDR
// end ;
6310: GO 6273
6312: POP
6313: POP
// DialogueOn ;
6314: CALL_OW 6
// SayRadio ( filter [ 1 ] , DS-DF-1 ) ;
6318: LD_VAR 0 3
6322: PUSH
6323: LD_INT 1
6325: ARRAY
6326: PPUSH
6327: LD_STRING DS-DF-1
6329: PPUSH
6330: CALL_OW 94
// case Query ( DS-dezert ) of 1 :
6334: LD_STRING DS-dezert
6336: PPUSH
6337: CALL_OW 97
6341: PUSH
6342: LD_INT 1
6344: DOUBLE
6345: EQUAL
6346: IFTRUE 6350
6348: GO 6365
6350: POP
// Say ( l_cmndr , DS-DC-dis ) ; 2 :
6351: LD_EXP 49
6355: PPUSH
6356: LD_STRING DS-DC-dis
6358: PPUSH
6359: CALL_OW 88
6363: GO 6460
6365: LD_INT 2
6367: DOUBLE
6368: EQUAL
6369: IFTRUE 6373
6371: GO 6459
6373: POP
// begin Say ( l_cmndr , DS-DC-acp ) ;
6374: LD_EXP 49
6378: PPUSH
6379: LD_STRING DS-DC-acp
6381: PPUSH
6382: CALL_OW 88
// for i = 1 to filter do
6386: LD_ADDR_VAR 0 2
6390: PUSH
6391: DOUBLE
6392: LD_INT 1
6394: DEC
6395: ST_TO_ADDR
6396: LD_VAR 0 3
6400: PUSH
6401: FOR_TO
6402: IFFALSE 6455
// begin SetSide ( filter [ i ] , 8 ) ;
6404: LD_VAR 0 3
6408: PUSH
6409: LD_VAR 0 2
6413: ARRAY
6414: PPUSH
6415: LD_INT 8
6417: PPUSH
6418: CALL_OW 235
// PlaceUnitArea ( filter [ i ] , south_spawn , false ) ;
6422: LD_VAR 0 3
6426: PUSH
6427: LD_VAR 0 2
6431: ARRAY
6432: PPUSH
6433: LD_INT 4
6435: PPUSH
6436: LD_INT 0
6438: PPUSH
6439: CALL_OW 49
// CenterNowOnXY ( 111 , 121 ) ;
6443: LD_INT 111
6445: PPUSH
6446: LD_INT 121
6448: PPUSH
6449: CALL_OW 86
// end ;
6453: GO 6401
6455: POP
6456: POP
// end ; end ;
6457: GO 6460
6459: POP
// DialogueOff ;
6460: CALL_OW 7
// end ; 101 :
6464: GO 6591
6466: LD_INT 101
6468: DOUBLE
6469: EQUAL
6470: IFTRUE 6474
6472: GO 6526
6474: POP
// begin CreateCratesArea ( Rand ( 3 , 5 ) , crates_area , true ) ;
6475: LD_INT 3
6477: PPUSH
6478: LD_INT 5
6480: PPUSH
6481: CALL_OW 12
6485: PPUSH
6486: LD_INT 9
6488: PPUSH
6489: LD_INT 1
6491: PPUSH
6492: CALL_OW 55
// Wait ( 0 0$11 ) ;
6496: LD_INT 385
6498: PPUSH
6499: CALL_OW 67
// CreateCratesArea ( Rand ( 3 , 5 ) , crates_area , true ) ;
6503: LD_INT 3
6505: PPUSH
6506: LD_INT 5
6508: PPUSH
6509: CALL_OW 12
6513: PPUSH
6514: LD_INT 9
6516: PPUSH
6517: LD_INT 1
6519: PPUSH
6520: CALL_OW 55
// end ; 200 :
6524: GO 6591
6526: LD_INT 200
6528: DOUBLE
6529: EQUAL
6530: IFTRUE 6534
6532: GO 6590
6534: POP
// begin Say ( Leopold , DS-end ) ;
6535: LD_EXP 7
6539: PPUSH
6540: LD_STRING DS-end
6542: PPUSH
6543: CALL_OW 88
// AddMedal ( dsmed1 , 1 ) ;
6547: LD_STRING dsmed1
6549: PPUSH
6550: LD_INT 1
6552: PPUSH
6553: CALL_OW 101
// AddMedal ( dsmed1 , 1 ) ;
6557: LD_STRING dsmed1
6559: PPUSH
6560: LD_INT 1
6562: PPUSH
6563: CALL_OW 101
// AddMedal ( dsmed1 , 1 ) ;
6567: LD_STRING dsmed1
6569: PPUSH
6570: LD_INT 1
6572: PPUSH
6573: CALL_OW 101
// GiveMedals ( MAIN ) ;
6577: LD_STRING MAIN
6579: PPUSH
6580: CALL_OW 102
// YouWin ;
6584: CALL_OW 103
// end ; end ;
6588: GO 6591
6590: POP
// end ;
6591: PPOPN 6
6593: END
// on UnitGoesToRed ( un ) do begin if un in FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] ] ) then
6594: LD_VAR 0 1
6598: PUSH
6599: LD_INT 22
6601: PUSH
6602: LD_INT 2
6604: PUSH
6605: EMPTY
6606: LIST
6607: LIST
6608: PUSH
6609: LD_INT 21
6611: PUSH
6612: LD_INT 2
6614: PUSH
6615: EMPTY
6616: LIST
6617: LIST
6618: PUSH
6619: EMPTY
6620: LIST
6621: LIST
6622: PPUSH
6623: CALL_OW 69
6627: IN
6628: IFFALSE 6753
// begin Wait ( Rand ( 0 0$03 , 0 0$06 ) ) ;
6630: LD_INT 105
6632: PPUSH
6633: LD_INT 210
6635: PPUSH
6636: CALL_OW 12
6640: PPUSH
6641: CALL_OW 67
// MineExplosion ( GetX ( un ) , GetY ( un ) , 3 ) ;
6645: LD_VAR 0 1
6649: PPUSH
6650: CALL_OW 250
6654: PPUSH
6655: LD_VAR 0 1
6659: PPUSH
6660: CALL_OW 251
6664: PPUSH
6665: LD_INT 3
6667: PPUSH
6668: CALL_OW 453
// MineExplosion ( GetX ( un ) , GetY ( un ) , 3 ) ;
6672: LD_VAR 0 1
6676: PPUSH
6677: CALL_OW 250
6681: PPUSH
6682: LD_VAR 0 1
6686: PPUSH
6687: CALL_OW 251
6691: PPUSH
6692: LD_INT 3
6694: PPUSH
6695: CALL_OW 453
// MineExplosion ( GetX ( un ) , GetY ( un ) , 3 ) ;
6699: LD_VAR 0 1
6703: PPUSH
6704: CALL_OW 250
6708: PPUSH
6709: LD_VAR 0 1
6713: PPUSH
6714: CALL_OW 251
6718: PPUSH
6719: LD_INT 3
6721: PPUSH
6722: CALL_OW 453
// MineExplosion ( GetX ( un ) , GetY ( un ) , 3 ) ;
6726: LD_VAR 0 1
6730: PPUSH
6731: CALL_OW 250
6735: PPUSH
6736: LD_VAR 0 1
6740: PPUSH
6741: CALL_OW 251
6745: PPUSH
6746: LD_INT 3
6748: PPUSH
6749: CALL_OW 453
// end ; end ;
6753: PPOPN 1
6755: END
// on UnitDestroyed ( un ) do begin if un = fort then
6756: LD_VAR 0 1
6760: PUSH
6761: LD_INT 23
6763: EQUAL
6764: IFFALSE 6774
// fort_destroyed := true ;
6766: LD_ADDR_EXP 32
6770: PUSH
6771: LD_INT 1
6773: ST_TO_ADDR
// if un = l_cmndr then
6774: LD_VAR 0 1
6778: PUSH
6779: LD_EXP 49
6783: EQUAL
6784: IFFALSE 6794
// hero_died := true ;
6786: LD_ADDR_EXP 33
6790: PUSH
6791: LD_INT 1
6793: ST_TO_ADDR
// end ;
6794: PPOPN 1
6796: END
// on UnitDestroyed_Extra ( un , killerSide , killerUnit ) do begin SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ;
6797: LD_VAR 0 1
6801: PPUSH
6802: LD_VAR 0 2
6806: PPUSH
6807: LD_VAR 0 3
6811: PPUSH
6812: CALL 8516 0 3
// end ;
6816: PPOPN 3
6818: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
6819: LD_VAR 0 1
6823: PPUSH
6824: CALL 8614 0 1
// end ; end_of_file
6828: PPOPN 1
6830: END
// export function RefreshTime ( time , bool ) ; begin
6831: LD_INT 0
6833: PPUSH
// if bool then
6834: LD_VAR 0 2
6838: IFFALSE 6856
// time := time + 0 0$01 else
6840: LD_ADDR_VAR 0 1
6844: PUSH
6845: LD_VAR 0 1
6849: PUSH
6850: LD_INT 35
6852: PLUS
6853: ST_TO_ADDR
6854: GO 6870
// time := time - 0 0$01 ;
6856: LD_ADDR_VAR 0 1
6860: PUSH
6861: LD_VAR 0 1
6865: PUSH
6866: LD_INT 35
6868: MINUS
6869: ST_TO_ADDR
// result := time ;
6870: LD_ADDR_VAR 0 3
6874: PUSH
6875: LD_VAR 0 1
6879: ST_TO_ADDR
// end ;
6880: LD_VAR 0 3
6884: RET
// export function MineExist ( side ) ; begin
6885: LD_INT 0
6887: PPUSH
// if FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_siberite_mine ] ] ) > 0 then
6888: LD_INT 22
6890: PUSH
6891: LD_VAR 0 1
6895: PUSH
6896: EMPTY
6897: LIST
6898: LIST
6899: PUSH
6900: LD_INT 30
6902: PUSH
6903: LD_INT 30
6905: PUSH
6906: EMPTY
6907: LIST
6908: LIST
6909: PUSH
6910: EMPTY
6911: LIST
6912: LIST
6913: PPUSH
6914: CALL_OW 69
6918: PUSH
6919: LD_INT 0
6921: GREATER
6922: IFFALSE 6934
// result := true else
6924: LD_ADDR_VAR 0 2
6928: PUSH
6929: LD_INT 1
6931: ST_TO_ADDR
6932: GO 6942
// result := false ;
6934: LD_ADDR_VAR 0 2
6938: PUSH
6939: LD_INT 0
6941: ST_TO_ADDR
// end ;
6942: LD_VAR 0 2
6946: RET
// export function FacExist ( side ) ; begin
6947: LD_INT 0
6949: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_factory ] ] ) > 0 ;
6950: LD_ADDR_VAR 0 2
6954: PUSH
6955: LD_INT 22
6957: PUSH
6958: LD_VAR 0 1
6962: PUSH
6963: EMPTY
6964: LIST
6965: LIST
6966: PUSH
6967: LD_INT 30
6969: PUSH
6970: LD_INT 3
6972: PUSH
6973: EMPTY
6974: LIST
6975: LIST
6976: PUSH
6977: EMPTY
6978: LIST
6979: LIST
6980: PPUSH
6981: CALL_OW 69
6985: PUSH
6986: LD_INT 0
6988: GREATER
6989: ST_TO_ADDR
// end ;
6990: LD_VAR 0 2
6994: RET
// export function ConnectWithTower ( side ) ; var i , filter , tower ; begin
6995: LD_INT 0
6997: PPUSH
6998: PPUSH
6999: PPUSH
7000: PPUSH
// filter := FilterAllUnits ( [ [ f_side , side ] , [ f_control , control_remote ] , [ f_ok ] ] ) ;
7001: LD_ADDR_VAR 0 4
7005: PUSH
7006: LD_INT 22
7008: PUSH
7009: LD_VAR 0 1
7013: PUSH
7014: EMPTY
7015: LIST
7016: LIST
7017: PUSH
7018: LD_INT 33
7020: PUSH
7021: LD_INT 2
7023: PUSH
7024: EMPTY
7025: LIST
7026: LIST
7027: PUSH
7028: LD_INT 50
7030: PUSH
7031: EMPTY
7032: LIST
7033: PUSH
7034: EMPTY
7035: LIST
7036: LIST
7037: LIST
7038: PPUSH
7039: CALL_OW 69
7043: ST_TO_ADDR
// tower := FilterAllUnits ( [ [ f_side , side ] , [ f_weapon , ar_control_tower ] ] ) ;
7044: LD_ADDR_VAR 0 5
7048: PUSH
7049: LD_INT 22
7051: PUSH
7052: LD_VAR 0 1
7056: PUSH
7057: EMPTY
7058: LIST
7059: LIST
7060: PUSH
7061: LD_INT 34
7063: PUSH
7064: LD_INT 31
7066: PUSH
7067: EMPTY
7068: LIST
7069: LIST
7070: PUSH
7071: EMPTY
7072: LIST
7073: LIST
7074: PPUSH
7075: CALL_OW 69
7079: ST_TO_ADDR
// if tower > 0 and filter > 0 then
7080: LD_VAR 0 5
7084: PUSH
7085: LD_INT 0
7087: GREATER
7088: PUSH
7089: LD_VAR 0 4
7093: PUSH
7094: LD_INT 0
7096: GREATER
7097: AND
7098: IFFALSE 7174
// for i = 1 to filter do
7100: LD_ADDR_VAR 0 3
7104: PUSH
7105: DOUBLE
7106: LD_INT 1
7108: DEC
7109: ST_TO_ADDR
7110: LD_VAR 0 4
7114: PUSH
7115: FOR_TO
7116: IFFALSE 7172
// if not IsControledBy ( filter [ i ] ) then
7118: LD_VAR 0 4
7122: PUSH
7123: LD_VAR 0 3
7127: ARRAY
7128: PPUSH
7129: CALL_OW 312
7133: NOT
7134: IFFALSE 7170
// ComLinkTo ( filter [ i ] , tower [ Rand ( 1 , tower ) ] ) ;
7136: LD_VAR 0 4
7140: PUSH
7141: LD_VAR 0 3
7145: ARRAY
7146: PPUSH
7147: LD_VAR 0 5
7151: PUSH
7152: LD_INT 1
7154: PPUSH
7155: LD_VAR 0 5
7159: PPUSH
7160: CALL_OW 12
7164: ARRAY
7165: PPUSH
7166: CALL_OW 135
7170: GO 7115
7172: POP
7173: POP
// end ;
7174: LD_VAR 0 2
7178: RET
// export function CreateHumanWithClass ( clas , lvl ) ; var skill_com , skill_eng , skill_mech , skill_sci , bonus ; begin
7179: LD_INT 0
7181: PPUSH
7182: PPUSH
7183: PPUSH
7184: PPUSH
7185: PPUSH
7186: PPUSH
// hc_class := clas ;
7187: LD_ADDR_OWVAR 28
7191: PUSH
7192: LD_VAR 0 1
7196: ST_TO_ADDR
// skill_com := ( lvl + Rand ( - 1 , 1 ) ) ;
7197: LD_ADDR_VAR 0 4
7201: PUSH
7202: LD_VAR 0 2
7206: PUSH
7207: LD_INT 1
7209: NEG
7210: PPUSH
7211: LD_INT 1
7213: PPUSH
7214: CALL_OW 12
7218: PLUS
7219: ST_TO_ADDR
// skill_eng := ( lvl + Rand ( - 1 , 1 ) ) ;
7220: LD_ADDR_VAR 0 5
7224: PUSH
7225: LD_VAR 0 2
7229: PUSH
7230: LD_INT 1
7232: NEG
7233: PPUSH
7234: LD_INT 1
7236: PPUSH
7237: CALL_OW 12
7241: PLUS
7242: ST_TO_ADDR
// skill_mech := ( lvl + Rand ( - 1 , 1 ) ) ;
7243: LD_ADDR_VAR 0 6
7247: PUSH
7248: LD_VAR 0 2
7252: PUSH
7253: LD_INT 1
7255: NEG
7256: PPUSH
7257: LD_INT 1
7259: PPUSH
7260: CALL_OW 12
7264: PLUS
7265: ST_TO_ADDR
// skill_sci := ( lvl + Rand ( - 1 , 1 ) ) ;
7266: LD_ADDR_VAR 0 7
7270: PUSH
7271: LD_VAR 0 2
7275: PUSH
7276: LD_INT 1
7278: NEG
7279: PPUSH
7280: LD_INT 1
7282: PPUSH
7283: CALL_OW 12
7287: PLUS
7288: ST_TO_ADDR
// if clas = 1 or clas = 9 or clas = class_sniper or clas = class_mortar then
7289: LD_VAR 0 1
7293: PUSH
7294: LD_INT 1
7296: EQUAL
7297: PUSH
7298: LD_VAR 0 1
7302: PUSH
7303: LD_INT 9
7305: EQUAL
7306: OR
7307: PUSH
7308: LD_VAR 0 1
7312: PUSH
7313: LD_INT 5
7315: EQUAL
7316: OR
7317: PUSH
7318: LD_VAR 0 1
7322: PUSH
7323: LD_INT 8
7325: EQUAL
7326: OR
7327: IFFALSE 7352
// bonus := [ 2 , 0 , 0 , 0 ] ;
7329: LD_ADDR_VAR 0 8
7333: PUSH
7334: LD_INT 2
7336: PUSH
7337: LD_INT 0
7339: PUSH
7340: LD_INT 0
7342: PUSH
7343: LD_INT 0
7345: PUSH
7346: EMPTY
7347: LIST
7348: LIST
7349: LIST
7350: LIST
7351: ST_TO_ADDR
// if clas = 2 then
7352: LD_VAR 0 1
7356: PUSH
7357: LD_INT 2
7359: EQUAL
7360: IFFALSE 7385
// bonus := [ 0 , 2 , 0 , 0 ] ;
7362: LD_ADDR_VAR 0 8
7366: PUSH
7367: LD_INT 0
7369: PUSH
7370: LD_INT 2
7372: PUSH
7373: LD_INT 0
7375: PUSH
7376: LD_INT 0
7378: PUSH
7379: EMPTY
7380: LIST
7381: LIST
7382: LIST
7383: LIST
7384: ST_TO_ADDR
// if clas = 3 then
7385: LD_VAR 0 1
7389: PUSH
7390: LD_INT 3
7392: EQUAL
7393: IFFALSE 7418
// bonus := [ 0 , 0 , 2 , 0 ] ;
7395: LD_ADDR_VAR 0 8
7399: PUSH
7400: LD_INT 0
7402: PUSH
7403: LD_INT 0
7405: PUSH
7406: LD_INT 2
7408: PUSH
7409: LD_INT 0
7411: PUSH
7412: EMPTY
7413: LIST
7414: LIST
7415: LIST
7416: LIST
7417: ST_TO_ADDR
// if clas = 4 then
7418: LD_VAR 0 1
7422: PUSH
7423: LD_INT 4
7425: EQUAL
7426: IFFALSE 7451
// bonus := [ 0 , 0 , 0 , 2 ] ;
7428: LD_ADDR_VAR 0 8
7432: PUSH
7433: LD_INT 0
7435: PUSH
7436: LD_INT 0
7438: PUSH
7439: LD_INT 0
7441: PUSH
7442: LD_INT 2
7444: PUSH
7445: EMPTY
7446: LIST
7447: LIST
7448: LIST
7449: LIST
7450: ST_TO_ADDR
// if clas > 4 and clas <> 9 and clas <> class_sniper and clas <> class_mortar then
7451: LD_VAR 0 1
7455: PUSH
7456: LD_INT 4
7458: GREATER
7459: PUSH
7460: LD_VAR 0 1
7464: PUSH
7465: LD_INT 9
7467: NONEQUAL
7468: AND
7469: PUSH
7470: LD_VAR 0 1
7474: PUSH
7475: LD_INT 5
7477: NONEQUAL
7478: AND
7479: PUSH
7480: LD_VAR 0 1
7484: PUSH
7485: LD_INT 8
7487: NONEQUAL
7488: AND
7489: IFFALSE 7514
// bonus := [ 0 , 0 , 0 , 0 ] ;
7491: LD_ADDR_VAR 0 8
7495: PUSH
7496: LD_INT 0
7498: PUSH
7499: LD_INT 0
7501: PUSH
7502: LD_INT 0
7504: PUSH
7505: LD_INT 0
7507: PUSH
7508: EMPTY
7509: LIST
7510: LIST
7511: LIST
7512: LIST
7513: ST_TO_ADDR
// hc_basic_skills := [ Rand ( 0 , 2 ) , Rand ( 0 , 2 ) , Rand ( 0 , 2 ) , Rand ( 0 , 2 ) ] ;
7514: LD_ADDR_OWVAR 30
7518: PUSH
7519: LD_INT 0
7521: PPUSH
7522: LD_INT 2
7524: PPUSH
7525: CALL_OW 12
7529: PUSH
7530: LD_INT 0
7532: PPUSH
7533: LD_INT 2
7535: PPUSH
7536: CALL_OW 12
7540: PUSH
7541: LD_INT 0
7543: PPUSH
7544: LD_INT 2
7546: PPUSH
7547: CALL_OW 12
7551: PUSH
7552: LD_INT 0
7554: PPUSH
7555: LD_INT 2
7557: PPUSH
7558: CALL_OW 12
7562: PUSH
7563: EMPTY
7564: LIST
7565: LIST
7566: LIST
7567: LIST
7568: ST_TO_ADDR
// hc_skills := [ skill_com + bonus [ 1 ] , skill_eng + bonus [ 2 ] , skill_mech + bonus [ 3 ] , skill_sci + bonus [ 4 ] ] ;
7569: LD_ADDR_OWVAR 31
7573: PUSH
7574: LD_VAR 0 4
7578: PUSH
7579: LD_VAR 0 8
7583: PUSH
7584: LD_INT 1
7586: ARRAY
7587: PLUS
7588: PUSH
7589: LD_VAR 0 5
7593: PUSH
7594: LD_VAR 0 8
7598: PUSH
7599: LD_INT 2
7601: ARRAY
7602: PLUS
7603: PUSH
7604: LD_VAR 0 6
7608: PUSH
7609: LD_VAR 0 8
7613: PUSH
7614: LD_INT 3
7616: ARRAY
7617: PLUS
7618: PUSH
7619: LD_VAR 0 7
7623: PUSH
7624: LD_VAR 0 8
7628: PUSH
7629: LD_INT 4
7631: ARRAY
7632: PLUS
7633: PUSH
7634: EMPTY
7635: LIST
7636: LIST
7637: LIST
7638: LIST
7639: ST_TO_ADDR
// hc_sex := Rand ( sex_male , sex_female ) ;
7640: LD_ADDR_OWVAR 27
7644: PUSH
7645: LD_INT 1
7647: PPUSH
7648: LD_INT 2
7650: PPUSH
7651: CALL_OW 12
7655: ST_TO_ADDR
// hc_gallery :=  ;
7656: LD_ADDR_OWVAR 33
7660: PUSH
7661: LD_STRING 
7663: ST_TO_ADDR
// hc_attr := [ Rand ( 8 , 12 ) , Rand ( 9 , 11 ) ] ;
7664: LD_ADDR_OWVAR 29
7668: PUSH
7669: LD_INT 8
7671: PPUSH
7672: LD_INT 12
7674: PPUSH
7675: CALL_OW 12
7679: PUSH
7680: LD_INT 9
7682: PPUSH
7683: LD_INT 11
7685: PPUSH
7686: CALL_OW 12
7690: PUSH
7691: EMPTY
7692: LIST
7693: LIST
7694: ST_TO_ADDR
// hc_name :=  ;
7695: LD_ADDR_OWVAR 26
7699: PUSH
7700: LD_STRING 
7702: ST_TO_ADDR
// result := CreateHuman ;
7703: LD_ADDR_VAR 0 3
7707: PUSH
7708: CALL_OW 44
7712: ST_TO_ADDR
// end ;
7713: LD_VAR 0 3
7717: RET
// export function GetSpeed ( unit ) ; begin
7718: LD_INT 0
7720: PPUSH
// result := GetProperties ( unit ) [ 1 ] ;
7721: LD_ADDR_VAR 0 2
7725: PUSH
7726: LD_VAR 0 1
7730: PPUSH
7731: CALL_OW 464
7735: PUSH
7736: LD_INT 1
7738: ARRAY
7739: ST_TO_ADDR
// end ;
7740: LD_VAR 0 2
7744: RET
// export function PrepareNature ( area , num1 , num2 , num3 , num4 ) ; var l , apeman , tiger , bird , horse ; begin
7745: LD_INT 0
7747: PPUSH
7748: PPUSH
7749: PPUSH
7750: PPUSH
7751: PPUSH
7752: PPUSH
// uc_nation = nation_nature ;
7753: LD_ADDR_OWVAR 21
7757: PUSH
7758: LD_INT 0
7760: ST_TO_ADDR
// uc_side = 0 ;
7761: LD_ADDR_OWVAR 20
7765: PUSH
7766: LD_INT 0
7768: ST_TO_ADDR
// l = 0 ;
7769: LD_ADDR_VAR 0 7
7773: PUSH
7774: LD_INT 0
7776: ST_TO_ADDR
// repeat begin uc_direction = Rand ( 0 , 5 ) ;
7777: LD_ADDR_OWVAR 24
7781: PUSH
7782: LD_INT 0
7784: PPUSH
7785: LD_INT 5
7787: PPUSH
7788: CALL_OW 12
7792: ST_TO_ADDR
// hc_agressivity = Rand ( - 5 , 0 ) ;
7793: LD_ADDR_OWVAR 35
7797: PUSH
7798: LD_INT 5
7800: NEG
7801: PPUSH
7802: LD_INT 0
7804: PPUSH
7805: CALL_OW 12
7809: ST_TO_ADDR
// hc_gallery =  ;
7810: LD_ADDR_OWVAR 33
7814: PUSH
7815: LD_STRING 
7817: ST_TO_ADDR
// hc_class = class_apeman ;
7818: LD_ADDR_OWVAR 28
7822: PUSH
7823: LD_INT 12
7825: ST_TO_ADDR
// hc_attr = [ Rand ( 11 , 13 ) , Rand ( 10 , 11 ) ] ;
7826: LD_ADDR_OWVAR 29
7830: PUSH
7831: LD_INT 11
7833: PPUSH
7834: LD_INT 13
7836: PPUSH
7837: CALL_OW 12
7841: PUSH
7842: LD_INT 10
7844: PPUSH
7845: LD_INT 11
7847: PPUSH
7848: CALL_OW 12
7852: PUSH
7853: EMPTY
7854: LIST
7855: LIST
7856: ST_TO_ADDR
// hc_sex = sex_male ;
7857: LD_ADDR_OWVAR 27
7861: PUSH
7862: LD_INT 1
7864: ST_TO_ADDR
// hc_skills = [ Rand ( 0 , 2 ) , 0 , 0 , 0 ] ;
7865: LD_ADDR_OWVAR 31
7869: PUSH
7870: LD_INT 0
7872: PPUSH
7873: LD_INT 2
7875: PPUSH
7876: CALL_OW 12
7880: PUSH
7881: LD_INT 0
7883: PUSH
7884: LD_INT 0
7886: PUSH
7887: LD_INT 0
7889: PUSH
7890: EMPTY
7891: LIST
7892: LIST
7893: LIST
7894: LIST
7895: ST_TO_ADDR
// apeman = CreateHuman ;
7896: LD_ADDR_VAR 0 8
7900: PUSH
7901: CALL_OW 44
7905: ST_TO_ADDR
// PlaceUnitArea ( apeman , area , false ) ;
7906: LD_VAR 0 8
7910: PPUSH
7911: LD_VAR 0 1
7915: PPUSH
7916: LD_INT 0
7918: PPUSH
7919: CALL_OW 49
// l = l + 1 ;
7923: LD_ADDR_VAR 0 7
7927: PUSH
7928: LD_VAR 0 7
7932: PUSH
7933: LD_INT 1
7935: PLUS
7936: ST_TO_ADDR
// end until l = num1 ;
7937: LD_VAR 0 7
7941: PUSH
7942: LD_VAR 0 2
7946: EQUAL
7947: IFFALSE 7777
// l = 0 ;
7949: LD_ADDR_VAR 0 7
7953: PUSH
7954: LD_INT 0
7956: ST_TO_ADDR
// repeat begin hc_agressivity = Rand ( 0 , 25 ) ;
7957: LD_ADDR_OWVAR 35
7961: PUSH
7962: LD_INT 0
7964: PPUSH
7965: LD_INT 25
7967: PPUSH
7968: CALL_OW 12
7972: ST_TO_ADDR
// hc_class = class_tiger ;
7973: LD_ADDR_OWVAR 28
7977: PUSH
7978: LD_INT 14
7980: ST_TO_ADDR
// hc_sex = sex_male ;
7981: LD_ADDR_OWVAR 27
7985: PUSH
7986: LD_INT 1
7988: ST_TO_ADDR
// hc_gallery = sandnature ;
7989: LD_ADDR_OWVAR 33
7993: PUSH
7994: LD_STRING sandnature
7996: ST_TO_ADDR
// hc_face_number = 3 ;
7997: LD_ADDR_OWVAR 34
8001: PUSH
8002: LD_INT 3
8004: ST_TO_ADDR
// tiger = CreateHuman ;
8005: LD_ADDR_VAR 0 9
8009: PUSH
8010: CALL_OW 44
8014: ST_TO_ADDR
// PlaceUnitArea ( tiger , area , false ) ;
8015: LD_VAR 0 9
8019: PPUSH
8020: LD_VAR 0 1
8024: PPUSH
8025: LD_INT 0
8027: PPUSH
8028: CALL_OW 49
// l = l + 1 ;
8032: LD_ADDR_VAR 0 7
8036: PUSH
8037: LD_VAR 0 7
8041: PUSH
8042: LD_INT 1
8044: PLUS
8045: ST_TO_ADDR
// end until l = num2 ;
8046: LD_VAR 0 7
8050: PUSH
8051: LD_VAR 0 3
8055: EQUAL
8056: IFFALSE 7957
// l = 0 ;
8058: LD_ADDR_VAR 0 7
8062: PUSH
8063: LD_INT 0
8065: ST_TO_ADDR
// repeat begin hc_class = class_phororhacos ;
8066: LD_ADDR_OWVAR 28
8070: PUSH
8071: LD_INT 18
8073: ST_TO_ADDR
// hc_gallery = sandnature ;
8074: LD_ADDR_OWVAR 33
8078: PUSH
8079: LD_STRING sandnature
8081: ST_TO_ADDR
// hc_face_number = 1 ;
8082: LD_ADDR_OWVAR 34
8086: PUSH
8087: LD_INT 1
8089: ST_TO_ADDR
// bird = CreateHuman ;
8090: LD_ADDR_VAR 0 10
8094: PUSH
8095: CALL_OW 44
8099: ST_TO_ADDR
// PlaceUnitAnywhere ( bird , false ) ;
8100: LD_VAR 0 10
8104: PPUSH
8105: LD_INT 0
8107: PPUSH
8108: CALL_OW 51
// l = l + 1 ;
8112: LD_ADDR_VAR 0 7
8116: PUSH
8117: LD_VAR 0 7
8121: PUSH
8122: LD_INT 1
8124: PLUS
8125: ST_TO_ADDR
// end until l = num3 ;
8126: LD_VAR 0 7
8130: PUSH
8131: LD_VAR 0 4
8135: EQUAL
8136: IFFALSE 8066
// l = 0 ;
8138: LD_ADDR_VAR 0 7
8142: PUSH
8143: LD_INT 0
8145: ST_TO_ADDR
// repeat begin hc_class = 21 ;
8146: LD_ADDR_OWVAR 28
8150: PUSH
8151: LD_INT 21
8153: ST_TO_ADDR
// hc_gallery = sandnature ;
8154: LD_ADDR_OWVAR 33
8158: PUSH
8159: LD_STRING sandnature
8161: ST_TO_ADDR
// hc_face_number = 5 ;
8162: LD_ADDR_OWVAR 34
8166: PUSH
8167: LD_INT 5
8169: ST_TO_ADDR
// horse := CreateHuman ;
8170: LD_ADDR_VAR 0 11
8174: PUSH
8175: CALL_OW 44
8179: ST_TO_ADDR
// PlaceUnitArea ( horse , area , false ) ;
8180: LD_VAR 0 11
8184: PPUSH
8185: LD_VAR 0 1
8189: PPUSH
8190: LD_INT 0
8192: PPUSH
8193: CALL_OW 49
// l = l + 1 ;
8197: LD_ADDR_VAR 0 7
8201: PUSH
8202: LD_VAR 0 7
8206: PUSH
8207: LD_INT 1
8209: PLUS
8210: ST_TO_ADDR
// end until l = num4 ;
8211: LD_VAR 0 7
8215: PUSH
8216: LD_VAR 0 5
8220: EQUAL
8221: IFFALSE 8146
// end ;
8223: LD_VAR 0 6
8227: RET
// export function PrepareComm ; begin
8228: LD_INT 0
8230: PPUSH
// uc_side := 1 ;
8231: LD_ADDR_OWVAR 20
8235: PUSH
8236: LD_INT 1
8238: ST_TO_ADDR
// uc_nation := 1 ;
8239: LD_ADDR_OWVAR 21
8243: PUSH
8244: LD_INT 1
8246: ST_TO_ADDR
// hc_gallery :=  ;
8247: LD_ADDR_OWVAR 33
8251: PUSH
8252: LD_STRING 
8254: ST_TO_ADDR
// hc_name :=  ;
8255: LD_ADDR_OWVAR 26
8259: PUSH
8260: LD_STRING 
8262: ST_TO_ADDR
// hc_class := 1 ;
8263: LD_ADDR_OWVAR 28
8267: PUSH
8268: LD_INT 1
8270: ST_TO_ADDR
// hc_sex := sex_male ;
8271: LD_ADDR_OWVAR 27
8275: PUSH
8276: LD_INT 1
8278: ST_TO_ADDR
// am_comander := CreateHuman ;
8279: LD_ADDR_EXP 46
8283: PUSH
8284: CALL_OW 44
8288: ST_TO_ADDR
// uc_side := 3 ;
8289: LD_ADDR_OWVAR 20
8293: PUSH
8294: LD_INT 3
8296: ST_TO_ADDR
// uc_nation := 3 ;
8297: LD_ADDR_OWVAR 21
8301: PUSH
8302: LD_INT 3
8304: ST_TO_ADDR
// ru_comander := CreateHuman ;
8305: LD_ADDR_EXP 47
8309: PUSH
8310: CALL_OW 44
8314: ST_TO_ADDR
// uc_side := 2 ;
8315: LD_ADDR_OWVAR 20
8319: PUSH
8320: LD_INT 2
8322: ST_TO_ADDR
// uc_nation := 2 ;
8323: LD_ADDR_OWVAR 21
8327: PUSH
8328: LD_INT 2
8330: ST_TO_ADDR
// hc_name := Heike Steyer ;
8331: LD_ADDR_OWVAR 26
8335: PUSH
8336: LD_STRING Heike Steyer
8338: ST_TO_ADDR
// hc_sex := sex_female ;
8339: LD_ADDR_OWVAR 27
8343: PUSH
8344: LD_INT 2
8346: ST_TO_ADDR
// hc_gallery := sandar ;
8347: LD_ADDR_OWVAR 33
8351: PUSH
8352: LD_STRING sandar
8354: ST_TO_ADDR
// hc_face_number := 14 ;
8355: LD_ADDR_OWVAR 34
8359: PUSH
8360: LD_INT 14
8362: ST_TO_ADDR
// ar_comander := CreateHuman ;
8363: LD_ADDR_EXP 48
8367: PUSH
8368: CALL_OW 44
8372: ST_TO_ADDR
// end ;
8373: LD_VAR 0 1
8377: RET
// export function SpeedFilter ( filter , speed ) ; var list , i ; begin
8378: LD_INT 0
8380: PPUSH
8381: PPUSH
8382: PPUSH
// list := [ ] ;
8383: LD_ADDR_VAR 0 4
8387: PUSH
8388: EMPTY
8389: ST_TO_ADDR
// for i = 1 to filter do
8390: LD_ADDR_VAR 0 5
8394: PUSH
8395: DOUBLE
8396: LD_INT 1
8398: DEC
8399: ST_TO_ADDR
8400: LD_VAR 0 1
8404: PUSH
8405: FOR_TO
8406: IFFALSE 8455
// if GetSpeed ( filter [ i ] ) < speed then
8408: LD_VAR 0 1
8412: PUSH
8413: LD_VAR 0 5
8417: ARRAY
8418: PPUSH
8419: CALL 7718 0 1
8423: PUSH
8424: LD_VAR 0 2
8428: LESS
8429: IFFALSE 8453
// list := list ^ filter [ i ] ;
8431: LD_ADDR_VAR 0 4
8435: PUSH
8436: LD_VAR 0 4
8440: PUSH
8441: LD_VAR 0 1
8445: PUSH
8446: LD_VAR 0 5
8450: ARRAY
8451: ADD
8452: ST_TO_ADDR
8453: GO 8405
8455: POP
8456: POP
// result := list ;
8457: LD_ADDR_VAR 0 3
8461: PUSH
8462: LD_VAR 0 4
8466: ST_TO_ADDR
// end ; end_of_file
8467: LD_VAR 0 3
8471: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; every 1 do
8472: GO 8474
8474: DISABLE
// begin ru_radar := 98 ;
8475: LD_ADDR_EXP 52
8479: PUSH
8480: LD_INT 98
8482: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
8483: LD_ADDR_EXP 53
8487: PUSH
8488: LD_INT 89
8490: ST_TO_ADDR
// us_hack := 99 ;
8491: LD_ADDR_EXP 54
8495: PUSH
8496: LD_INT 99
8498: ST_TO_ADDR
// us_artillery := 97 ;
8499: LD_ADDR_EXP 55
8503: PUSH
8504: LD_INT 97
8506: ST_TO_ADDR
// ar_bio_bomb := 91 ;
8507: LD_ADDR_EXP 56
8511: PUSH
8512: LD_INT 91
8514: ST_TO_ADDR
// end ; end_of_file end_of_file end_of_file
8515: END
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; var i , eff , side ; begin
8516: LD_INT 0
8518: PPUSH
8519: PPUSH
8520: PPUSH
8521: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
8522: LD_VAR 0 1
8526: PPUSH
8527: CALL_OW 264
8531: PUSH
8532: LD_EXP 56
8536: EQUAL
8537: IFFALSE 8609
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
8539: LD_INT 68
8541: PPUSH
8542: LD_VAR 0 1
8546: PPUSH
8547: CALL_OW 255
8551: PPUSH
8552: CALL_OW 321
8556: PUSH
8557: LD_INT 2
8559: EQUAL
8560: IFFALSE 8572
// eff := 70 else
8562: LD_ADDR_VAR 0 6
8566: PUSH
8567: LD_INT 70
8569: ST_TO_ADDR
8570: GO 8580
// eff := 30 ;
8572: LD_ADDR_VAR 0 6
8576: PUSH
8577: LD_INT 30
8579: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
8580: LD_VAR 0 1
8584: PPUSH
8585: CALL_OW 250
8589: PPUSH
8590: LD_VAR 0 1
8594: PPUSH
8595: CALL_OW 251
8599: PPUSH
8600: LD_VAR 0 6
8604: PPUSH
8605: CALL_OW 495
// end ; end ;
8609: LD_VAR 0 4
8613: RET
// export function SOS_Command ( cmd ) ; var i , j , tmp , taskList , _taskList ; begin
8614: LD_INT 0
8616: PPUSH
8617: PPUSH
8618: PPUSH
8619: PPUSH
8620: PPUSH
8621: PPUSH
// if cmd = 124 then
8622: LD_VAR 0 1
8626: PUSH
8627: LD_INT 124
8629: EQUAL
8630: IFFALSE 8836
// begin tmp := FilterAllUnits ( [ f_or , [ f_weapon , ru_bulldozer ] , [ f_weapon , us_bulldozer ] ] ) ;
8632: LD_ADDR_VAR 0 5
8636: PUSH
8637: LD_INT 2
8639: PUSH
8640: LD_INT 34
8642: PUSH
8643: LD_INT 53
8645: PUSH
8646: EMPTY
8647: LIST
8648: LIST
8649: PUSH
8650: LD_INT 34
8652: PUSH
8653: LD_INT 14
8655: PUSH
8656: EMPTY
8657: LIST
8658: LIST
8659: PUSH
8660: EMPTY
8661: LIST
8662: LIST
8663: LIST
8664: PPUSH
8665: CALL_OW 69
8669: ST_TO_ADDR
// if not tmp then
8670: LD_VAR 0 5
8674: NOT
8675: IFFALSE 8679
// exit ;
8677: GO 8836
// for i in tmp do
8679: LD_ADDR_VAR 0 3
8683: PUSH
8684: LD_VAR 0 5
8688: PUSH
8689: FOR_IN
8690: IFFALSE 8834
// begin taskList := GetTaskList ( i ) ;
8692: LD_ADDR_VAR 0 6
8696: PUSH
8697: LD_VAR 0 3
8701: PPUSH
8702: CALL_OW 437
8706: ST_TO_ADDR
// if not taskList then
8707: LD_VAR 0 6
8711: NOT
8712: IFFALSE 8716
// continue ;
8714: GO 8689
// for j = 1 to taskList do
8716: LD_ADDR_VAR 0 4
8720: PUSH
8721: DOUBLE
8722: LD_INT 1
8724: DEC
8725: ST_TO_ADDR
8726: LD_VAR 0 6
8730: PUSH
8731: FOR_TO
8732: IFFALSE 8830
// if taskList [ j ] [ 1 ] = | then
8734: LD_VAR 0 6
8738: PUSH
8739: LD_VAR 0 4
8743: ARRAY
8744: PUSH
8745: LD_INT 1
8747: ARRAY
8748: PUSH
8749: LD_STRING |
8751: EQUAL
8752: IFFALSE 8828
// begin _taskList := Delete ( taskList , 1 ) ;
8754: LD_ADDR_VAR 0 7
8758: PUSH
8759: LD_VAR 0 6
8763: PPUSH
8764: LD_INT 1
8766: PPUSH
8767: CALL_OW 3
8771: ST_TO_ADDR
// SetTaskList ( i , _taskList ) ;
8772: LD_VAR 0 3
8776: PPUSH
8777: LD_VAR 0 7
8781: PPUSH
8782: CALL_OW 446
// CutTreeXYR ( i , taskList [ j ] [ 2 ] , taskList [ j ] [ 3 ] , 8 ) ;
8786: LD_VAR 0 3
8790: PPUSH
8791: LD_VAR 0 6
8795: PUSH
8796: LD_VAR 0 4
8800: ARRAY
8801: PUSH
8802: LD_INT 2
8804: ARRAY
8805: PPUSH
8806: LD_VAR 0 6
8810: PUSH
8811: LD_VAR 0 4
8815: ARRAY
8816: PUSH
8817: LD_INT 3
8819: ARRAY
8820: PPUSH
8821: LD_INT 8
8823: PPUSH
8824: CALL 8841 0 4
// end ;
8828: GO 8731
8830: POP
8831: POP
// end ;
8832: GO 8689
8834: POP
8835: POP
// end ; end ;
8836: LD_VAR 0 2
8840: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
8841: LD_INT 0
8843: PPUSH
8844: PPUSH
8845: PPUSH
8846: PPUSH
8847: PPUSH
8848: PPUSH
8849: PPUSH
8850: PPUSH
8851: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
8852: LD_VAR 0 1
8856: NOT
8857: PUSH
8858: LD_VAR 0 2
8862: PPUSH
8863: LD_VAR 0 3
8867: PPUSH
8868: CALL_OW 488
8872: NOT
8873: OR
8874: PUSH
8875: LD_VAR 0 4
8879: NOT
8880: OR
8881: IFFALSE 8885
// exit ;
8883: GO 9225
// list := [ ] ;
8885: LD_ADDR_VAR 0 13
8889: PUSH
8890: EMPTY
8891: ST_TO_ADDR
// if x - r < 0 then
8892: LD_VAR 0 2
8896: PUSH
8897: LD_VAR 0 4
8901: MINUS
8902: PUSH
8903: LD_INT 0
8905: LESS
8906: IFFALSE 8918
// min_x := 0 else
8908: LD_ADDR_VAR 0 7
8912: PUSH
8913: LD_INT 0
8915: ST_TO_ADDR
8916: GO 8934
// min_x := x - r ;
8918: LD_ADDR_VAR 0 7
8922: PUSH
8923: LD_VAR 0 2
8927: PUSH
8928: LD_VAR 0 4
8932: MINUS
8933: ST_TO_ADDR
// if y - r < 0 then
8934: LD_VAR 0 3
8938: PUSH
8939: LD_VAR 0 4
8943: MINUS
8944: PUSH
8945: LD_INT 0
8947: LESS
8948: IFFALSE 8960
// min_y := 0 else
8950: LD_ADDR_VAR 0 8
8954: PUSH
8955: LD_INT 0
8957: ST_TO_ADDR
8958: GO 8976
// min_y := y - r ;
8960: LD_ADDR_VAR 0 8
8964: PUSH
8965: LD_VAR 0 3
8969: PUSH
8970: LD_VAR 0 4
8974: MINUS
8975: ST_TO_ADDR
// max_x := x + r ;
8976: LD_ADDR_VAR 0 9
8980: PUSH
8981: LD_VAR 0 2
8985: PUSH
8986: LD_VAR 0 4
8990: PLUS
8991: ST_TO_ADDR
// max_y := y + r ;
8992: LD_ADDR_VAR 0 10
8996: PUSH
8997: LD_VAR 0 3
9001: PUSH
9002: LD_VAR 0 4
9006: PLUS
9007: ST_TO_ADDR
// for _x = min_x to max_x do
9008: LD_ADDR_VAR 0 11
9012: PUSH
9013: DOUBLE
9014: LD_VAR 0 7
9018: DEC
9019: ST_TO_ADDR
9020: LD_VAR 0 9
9024: PUSH
9025: FOR_TO
9026: IFFALSE 9143
// for _y = min_y to max_y do
9028: LD_ADDR_VAR 0 12
9032: PUSH
9033: DOUBLE
9034: LD_VAR 0 8
9038: DEC
9039: ST_TO_ADDR
9040: LD_VAR 0 10
9044: PUSH
9045: FOR_TO
9046: IFFALSE 9139
// begin if not ValidHex ( _x , _y ) then
9048: LD_VAR 0 11
9052: PPUSH
9053: LD_VAR 0 12
9057: PPUSH
9058: CALL_OW 488
9062: NOT
9063: IFFALSE 9067
// continue ;
9065: GO 9045
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
9067: LD_VAR 0 11
9071: PPUSH
9072: LD_VAR 0 12
9076: PPUSH
9077: CALL_OW 351
9081: PUSH
9082: LD_VAR 0 11
9086: PPUSH
9087: LD_VAR 0 12
9091: PPUSH
9092: CALL_OW 554
9096: AND
9097: IFFALSE 9137
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
9099: LD_ADDR_VAR 0 13
9103: PUSH
9104: LD_VAR 0 13
9108: PPUSH
9109: LD_VAR 0 13
9113: PUSH
9114: LD_INT 1
9116: PLUS
9117: PPUSH
9118: LD_VAR 0 11
9122: PUSH
9123: LD_VAR 0 12
9127: PUSH
9128: EMPTY
9129: LIST
9130: LIST
9131: PPUSH
9132: CALL_OW 2
9136: ST_TO_ADDR
// end ;
9137: GO 9045
9139: POP
9140: POP
9141: GO 9025
9143: POP
9144: POP
// if not list then
9145: LD_VAR 0 13
9149: NOT
9150: IFFALSE 9154
// exit ;
9152: GO 9225
// for i in list do
9154: LD_ADDR_VAR 0 6
9158: PUSH
9159: LD_VAR 0 13
9163: PUSH
9164: FOR_IN
9165: IFFALSE 9223
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
9167: LD_VAR 0 1
9171: PPUSH
9172: LD_STRING M
9174: PUSH
9175: LD_VAR 0 6
9179: PUSH
9180: LD_INT 1
9182: ARRAY
9183: PUSH
9184: LD_VAR 0 6
9188: PUSH
9189: LD_INT 2
9191: ARRAY
9192: PUSH
9193: LD_INT 0
9195: PUSH
9196: LD_INT 0
9198: PUSH
9199: LD_INT 0
9201: PUSH
9202: LD_INT 0
9204: PUSH
9205: EMPTY
9206: LIST
9207: LIST
9208: LIST
9209: LIST
9210: LIST
9211: LIST
9212: LIST
9213: PUSH
9214: EMPTY
9215: LIST
9216: PPUSH
9217: CALL_OW 447
9221: GO 9164
9223: POP
9224: POP
// end ;
9225: LD_VAR 0 5
9229: RET
