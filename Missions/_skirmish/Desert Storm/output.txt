// starting begin PrepareMap ;
   0: CALL 13 0 0
// Main_Variables ;
   4: CALL 136 0 0
// Start_Mission ;
   8: CALL 3478 0 0
// end ;
  12: END
// function PrepareMap ; begin
  13: LD_INT 0
  15: PPUSH
// ResetFog ;
  16: CALL_OW 335
// RandomizeAll ;
  20: CALL_OW 11
// game_difficulty := GetMultiplayerSetting ( 0 ) ;
  24: LD_ADDR_EXP 2
  28: PUSH
  29: LD_INT 0
  31: PPUSH
  32: CALL_OW 426
  36: ST_TO_ADDR
// Difficulty := game_difficulty ;
  37: LD_ADDR_OWVAR 67
  41: PUSH
  42: LD_EXP 2
  46: ST_TO_ADDR
// ChangeSideFog ( 8 , 6 ) ;
  47: LD_INT 8
  49: PPUSH
  50: LD_INT 6
  52: PPUSH
  53: CALL_OW 343
// PlaceSeeing ( 1 , 1 , 8 , - 37963 ) ;
  57: LD_INT 1
  59: PPUSH
  60: LD_INT 1
  62: PPUSH
  63: LD_INT 8
  65: PPUSH
  66: LD_INT 37963
  68: NEG
  69: PPUSH
  70: CALL_OW 330
// RemoveSeeing ( 1 , 1 , 8 ) ;
  74: LD_INT 1
  76: PPUSH
  77: LD_INT 1
  79: PPUSH
  80: LD_INT 8
  82: PPUSH
  83: CALL_OW 331
// PlaceCamera ;
  87: CALL 3945 0 0
// PrepareNature ( nature , 4 , 3 , 2 , 1 ) ;
  91: LD_INT 2
  93: PPUSH
  94: LD_INT 4
  96: PPUSH
  97: LD_INT 3
  99: PPUSH
 100: LD_INT 2
 102: PPUSH
 103: LD_INT 1
 105: PPUSH
 106: CALL 7869 0 5
// PrepareComm ;
 110: CALL 8352 0 0
// SetSide ( fort , 6 ) ;
 114: LD_INT 23
 116: PPUSH
 117: LD_INT 6
 119: PPUSH
 120: CALL_OW 235
// CenterNowOnUnits ( fort ) ;
 124: LD_INT 23
 126: PPUSH
 127: CALL_OW 87
// end ;
 131: LD_VAR 0 1
 135: RET
// export game_on , game_difficulty , game_time , game_option , game_end , game_strings ; export leopold , leopold_in_fort , samuel , samuel_in_fort , mortars_in_fort , scout ; export u_mine , u_fac ; export areas ; export skill ; export ar_weapons , ru_weapons , us_weapons ; export arabian_force , russian_force , american_force , arabian_timeing , russian_timeing , american_timeing ; export meeting_start , meeting_arive , meeting_break , meeting_end , meeting_time , russian_timer , fort_destroyed , hero_died , mission_time , cargo_ok , american_hchan , dezert , arabian_attack , russian_attack , american_attack , american_help , american_sib_bomb , russian_trade , heike_dialog1 , heike_dialog2 ; export am_comander , ru_comander , ar_comander ; function Main_Variables ; begin
 136: LD_INT 0
 138: PPUSH
// game_on := false ;
 139: LD_ADDR_EXP 1
 143: PUSH
 144: LD_INT 0
 146: ST_TO_ADDR
// game_time := 0 0$00 ;
 147: LD_ADDR_EXP 3
 151: PUSH
 152: LD_INT 0
 154: ST_TO_ADDR
// game_option := [ 1 ] ;
 155: LD_ADDR_EXP 4
 159: PUSH
 160: LD_INT 1
 162: PUSH
 163: EMPTY
 164: LIST
 165: ST_TO_ADDR
// game_end := false ;
 166: LD_ADDR_EXP 5
 170: PUSH
 171: LD_INT 0
 173: ST_TO_ADDR
// game_strings := [ ] ;
 174: LD_ADDR_EXP 6
 178: PUSH
 179: EMPTY
 180: ST_TO_ADDR
// game_time := 0 0$00 ;
 181: LD_ADDR_EXP 3
 185: PUSH
 186: LD_INT 0
 188: ST_TO_ADDR
// mission_time := 0 0$00 ;
 189: LD_ADDR_EXP 34
 193: PUSH
 194: LD_INT 0
 196: ST_TO_ADDR
// skill := [ 5 , 7 , 9 ] [ game_difficulty ] ;
 197: LD_ADDR_EXP 16
 201: PUSH
 202: LD_INT 5
 204: PUSH
 205: LD_INT 7
 207: PUSH
 208: LD_INT 9
 210: PUSH
 211: EMPTY
 212: LIST
 213: LIST
 214: LIST
 215: PUSH
 216: LD_EXP 2
 220: ARRAY
 221: ST_TO_ADDR
// areas := [ a_swest , a_nwest , a_neast , a_seast ] ;
 222: LD_ADDR_EXP 15
 226: PUSH
 227: LD_INT 5
 229: PUSH
 230: LD_INT 6
 232: PUSH
 233: LD_INT 7
 235: PUSH
 236: LD_INT 8
 238: PUSH
 239: EMPTY
 240: LIST
 241: LIST
 242: LIST
 243: LIST
 244: ST_TO_ADDR
// meeting_start := false ;
 245: LD_ADDR_EXP 26
 249: PUSH
 250: LD_INT 0
 252: ST_TO_ADDR
// meeting_arive := false ;
 253: LD_ADDR_EXP 27
 257: PUSH
 258: LD_INT 0
 260: ST_TO_ADDR
// meeting_break := false ;
 261: LD_ADDR_EXP 28
 265: PUSH
 266: LD_INT 0
 268: ST_TO_ADDR
// meeting_end := false ;
 269: LD_ADDR_EXP 29
 273: PUSH
 274: LD_INT 0
 276: ST_TO_ADDR
// meeting_time := [ 4 4$00 , 3 3$40 , 3 3$20 ] [ game_difficulty ] ;
 277: LD_ADDR_EXP 30
 281: PUSH
 282: LD_INT 8400
 284: PUSH
 285: LD_INT 7700
 287: PUSH
 288: LD_INT 7000
 290: PUSH
 291: EMPTY
 292: LIST
 293: LIST
 294: LIST
 295: PUSH
 296: LD_EXP 2
 300: ARRAY
 301: ST_TO_ADDR
// arabian_force := [ 5 , 6 , 7 ] [ game_difficulty ] ;
 302: LD_ADDR_EXP 20
 306: PUSH
 307: LD_INT 5
 309: PUSH
 310: LD_INT 6
 312: PUSH
 313: LD_INT 7
 315: PUSH
 316: EMPTY
 317: LIST
 318: LIST
 319: LIST
 320: PUSH
 321: LD_EXP 2
 325: ARRAY
 326: ST_TO_ADDR
// american_force := [ 6 , 8 , 9 ] [ game_difficulty ] ;
 327: LD_ADDR_EXP 22
 331: PUSH
 332: LD_INT 6
 334: PUSH
 335: LD_INT 8
 337: PUSH
 338: LD_INT 9
 340: PUSH
 341: EMPTY
 342: LIST
 343: LIST
 344: LIST
 345: PUSH
 346: LD_EXP 2
 350: ARRAY
 351: ST_TO_ADDR
// russian_force := [ 7 , 9 , 10 ] [ game_difficulty ] ;
 352: LD_ADDR_EXP 21
 356: PUSH
 357: LD_INT 7
 359: PUSH
 360: LD_INT 9
 362: PUSH
 363: LD_INT 10
 365: PUSH
 366: EMPTY
 367: LIST
 368: LIST
 369: LIST
 370: PUSH
 371: LD_EXP 2
 375: ARRAY
 376: ST_TO_ADDR
// u_mine := false ;
 377: LD_ADDR_EXP 13
 381: PUSH
 382: LD_INT 0
 384: ST_TO_ADDR
// u_fac := false ;
 385: LD_ADDR_EXP 14
 389: PUSH
 390: LD_INT 0
 392: ST_TO_ADDR
// leopold_in_fort := false ;
 393: LD_ADDR_EXP 8
 397: PUSH
 398: LD_INT 0
 400: ST_TO_ADDR
// samuel_in_fort := false ;
 401: LD_ADDR_EXP 10
 405: PUSH
 406: LD_INT 0
 408: ST_TO_ADDR
// mortars_in_fort := false ;
 409: LD_ADDR_EXP 11
 413: PUSH
 414: LD_INT 0
 416: ST_TO_ADDR
// fort_destroyed := false ;
 417: LD_ADDR_EXP 32
 421: PUSH
 422: LD_INT 0
 424: ST_TO_ADDR
// hero_died := false ;
 425: LD_ADDR_EXP 33
 429: PUSH
 430: LD_INT 0
 432: ST_TO_ADDR
// dezert := false ;
 433: LD_ADDR_EXP 37
 437: PUSH
 438: LD_INT 0
 440: ST_TO_ADDR
// arabian_attack := false ;
 441: LD_ADDR_EXP 38
 445: PUSH
 446: LD_INT 0
 448: ST_TO_ADDR
// russian_attack := false ;
 449: LD_ADDR_EXP 39
 453: PUSH
 454: LD_INT 0
 456: ST_TO_ADDR
// american_attack := false ;
 457: LD_ADDR_EXP 40
 461: PUSH
 462: LD_INT 0
 464: ST_TO_ADDR
// american_help := false ;
 465: LD_ADDR_EXP 41
 469: PUSH
 470: LD_INT 0
 472: ST_TO_ADDR
// american_hchan := [ 91 , 81 , 71 ] [ game_difficulty ] ;
 473: LD_ADDR_EXP 36
 477: PUSH
 478: LD_INT 91
 480: PUSH
 481: LD_INT 81
 483: PUSH
 484: LD_INT 71
 486: PUSH
 487: EMPTY
 488: LIST
 489: LIST
 490: LIST
 491: PUSH
 492: LD_EXP 2
 496: ARRAY
 497: ST_TO_ADDR
// american_sib_bomb := false ;
 498: LD_ADDR_EXP 42
 502: PUSH
 503: LD_INT 0
 505: ST_TO_ADDR
// russian_trade := false ;
 506: LD_ADDR_EXP 43
 510: PUSH
 511: LD_INT 0
 513: ST_TO_ADDR
// russian_timer := 5 5$00 ;
 514: LD_ADDR_EXP 31
 518: PUSH
 519: LD_INT 10500
 521: ST_TO_ADDR
// cargo_ok := false ;
 522: LD_ADDR_EXP 35
 526: PUSH
 527: LD_INT 0
 529: ST_TO_ADDR
// heike_dialog1 := false ;
 530: LD_ADDR_EXP 44
 534: PUSH
 535: LD_INT 0
 537: ST_TO_ADDR
// heike_dialog2 := false ;
 538: LD_ADDR_EXP 45
 542: PUSH
 543: LD_INT 0
 545: ST_TO_ADDR
// american_timeing := [ 10 10$00 , 9 9$40 , 9 9$10 ] [ game_difficulty ] ;
 546: LD_ADDR_EXP 25
 550: PUSH
 551: LD_INT 21000
 553: PUSH
 554: LD_INT 20300
 556: PUSH
 557: LD_INT 19250
 559: PUSH
 560: EMPTY
 561: LIST
 562: LIST
 563: LIST
 564: PUSH
 565: LD_EXP 2
 569: ARRAY
 570: ST_TO_ADDR
// arabian_timeing := [ 8 8$00 , 7 7$10 , 6 6$20 ] [ game_difficulty ] ;
 571: LD_ADDR_EXP 23
 575: PUSH
 576: LD_INT 16800
 578: PUSH
 579: LD_INT 15050
 581: PUSH
 582: LD_INT 13300
 584: PUSH
 585: EMPTY
 586: LIST
 587: LIST
 588: LIST
 589: PUSH
 590: LD_EXP 2
 594: ARRAY
 595: ST_TO_ADDR
// russian_timeing := [ 11 11$00 , 10 10$30 , 9 9$20 ] [ game_difficulty ] ;
 596: LD_ADDR_EXP 24
 600: PUSH
 601: LD_INT 23100
 603: PUSH
 604: LD_INT 22050
 606: PUSH
 607: LD_INT 19600
 609: PUSH
 610: EMPTY
 611: LIST
 612: LIST
 613: LIST
 614: PUSH
 615: LD_EXP 2
 619: ARRAY
 620: ST_TO_ADDR
// ar_weapons := [ ar_rocket_launcher , ar_gun , ar_flame_thrower , ar_selfpropelled_bomb , ar_bio_bomb ] ;
 621: LD_ADDR_EXP 17
 625: PUSH
 626: LD_INT 28
 628: PUSH
 629: LD_INT 27
 631: PUSH
 632: LD_INT 26
 634: PUSH
 635: LD_INT 29
 637: PUSH
 638: LD_EXP 56
 642: PUSH
 643: EMPTY
 644: LIST
 645: LIST
 646: LIST
 647: LIST
 648: LIST
 649: ST_TO_ADDR
// us_weapons := [ us_rocket_launcher , us_heavy_gun , us_double_laser , us_laser ] ;
 650: LD_ADDR_EXP 19
 654: PUSH
 655: LD_INT 7
 657: PUSH
 658: LD_INT 6
 660: PUSH
 661: LD_INT 10
 663: PUSH
 664: LD_INT 9
 666: PUSH
 667: EMPTY
 668: LIST
 669: LIST
 670: LIST
 671: LIST
 672: ST_TO_ADDR
// ru_weapons := [ ru_rocket_launcher , ru_rocket , ru_heavy_gun , ru_heavy_gun ] ;
 673: LD_ADDR_EXP 18
 677: PUSH
 678: LD_INT 45
 680: PUSH
 681: LD_INT 47
 683: PUSH
 684: LD_INT 46
 686: PUSH
 687: LD_INT 46
 689: PUSH
 690: EMPTY
 691: LIST
 692: LIST
 693: LIST
 694: LIST
 695: ST_TO_ADDR
// end ;
 696: LD_VAR 0 1
 700: RET
// every 0 0$01 trigger game_on do var i , p , x , filter ;
 701: LD_EXP 1
 705: IFFALSE 3475
 707: GO 709
 709: DISABLE
 710: LD_INT 0
 712: PPUSH
 713: PPUSH
 714: PPUSH
 715: PPUSH
// begin enable ;
 716: ENABLE
// Display_Strings := [ #tick , game_time ] ^ game_strings ;
 717: LD_ADDR_OWVAR 47
 721: PUSH
 722: LD_STRING #tick
 724: PUSH
 725: LD_EXP 3
 729: PUSH
 730: EMPTY
 731: LIST
 732: LIST
 733: PUSH
 734: LD_EXP 6
 738: ADD
 739: ST_TO_ADDR
// game_time := RefreshTime ( game_time , true ) ;
 740: LD_ADDR_EXP 3
 744: PUSH
 745: LD_EXP 3
 749: PPUSH
 750: LD_INT 1
 752: PPUSH
 753: CALL 6955 0 2
 757: ST_TO_ADDR
// if meeting_start and meeting_time > 0 0$00 then
 758: LD_EXP 26
 762: PUSH
 763: LD_EXP 30
 767: PUSH
 768: LD_INT 0
 770: GREATER
 771: AND
 772: IFFALSE 809
// begin game_strings := [ #mtime , meeting_time ] ;
 774: LD_ADDR_EXP 6
 778: PUSH
 779: LD_STRING #mtime
 781: PUSH
 782: LD_EXP 30
 786: PUSH
 787: EMPTY
 788: LIST
 789: LIST
 790: ST_TO_ADDR
// meeting_time := RefreshTime ( meeting_time , false ) ;
 791: LD_ADDR_EXP 30
 795: PUSH
 796: LD_EXP 30
 800: PPUSH
 801: LD_INT 0
 803: PPUSH
 804: CALL 6955 0 2
 808: ST_TO_ADDR
// end ; if meeting_arive then
 809: LD_EXP 27
 813: IFFALSE 833
// mission_time := RefreshTime ( mission_time , true ) ;
 815: LD_ADDR_EXP 34
 819: PUSH
 820: LD_EXP 34
 824: PPUSH
 825: LD_INT 1
 827: PPUSH
 828: CALL 6955 0 2
 832: ST_TO_ADDR
// if arabian_attack and arabian_timeing > 0 0$00 and meeting_arive then
 833: LD_EXP 38
 837: PUSH
 838: LD_EXP 23
 842: PUSH
 843: LD_INT 0
 845: GREATER
 846: AND
 847: PUSH
 848: LD_EXP 27
 852: AND
 853: IFFALSE 873
// begin arabian_timeing := RefreshTime ( arabian_timeing , false ) ;
 855: LD_ADDR_EXP 23
 859: PUSH
 860: LD_EXP 23
 864: PPUSH
 865: LD_INT 0
 867: PPUSH
 868: CALL 6955 0 2
 872: ST_TO_ADDR
// end ; if russian_attack and russian_timeing > 0 0$00 and meeting_arive then
 873: LD_EXP 39
 877: PUSH
 878: LD_EXP 24
 882: PUSH
 883: LD_INT 0
 885: GREATER
 886: AND
 887: PUSH
 888: LD_EXP 27
 892: AND
 893: IFFALSE 913
// begin russian_timeing := RefreshTime ( russian_timeing , false ) ;
 895: LD_ADDR_EXP 24
 899: PUSH
 900: LD_EXP 24
 904: PPUSH
 905: LD_INT 0
 907: PPUSH
 908: CALL 6955 0 2
 912: ST_TO_ADDR
// end ; if american_attack and american_timeing > 0 0$00 and meeting_arive then
 913: LD_EXP 40
 917: PUSH
 918: LD_EXP 25
 922: PUSH
 923: LD_INT 0
 925: GREATER
 926: AND
 927: PUSH
 928: LD_EXP 27
 932: AND
 933: IFFALSE 953
// begin american_timeing := RefreshTime ( american_timeing , false ) ;
 935: LD_ADDR_EXP 25
 939: PUSH
 940: LD_EXP 25
 944: PPUSH
 945: LD_INT 0
 947: PPUSH
 948: CALL 6955 0 2
 952: ST_TO_ADDR
// end ; if russian_trade and russian_timer > 0 0$00 then
 953: LD_EXP 43
 957: PUSH
 958: LD_EXP 31
 962: PUSH
 963: LD_INT 0
 965: GREATER
 966: AND
 967: IFFALSE 1004
// begin game_strings := [ #rtime , russian_timer ] ;
 969: LD_ADDR_EXP 6
 973: PUSH
 974: LD_STRING #rtime
 976: PUSH
 977: LD_EXP 31
 981: PUSH
 982: EMPTY
 983: LIST
 984: LIST
 985: ST_TO_ADDR
// russian_timer := RefreshTime ( russian_timer , false ) ;
 986: LD_ADDR_EXP 31
 990: PUSH
 991: LD_EXP 31
 995: PPUSH
 996: LD_INT 0
 998: PPUSH
 999: CALL 6955 0 2
1003: ST_TO_ADDR
// end ; if russian_trade and russian_timer = 0 0$00 or cargo_ok then
1004: LD_EXP 43
1008: PUSH
1009: LD_EXP 31
1013: PUSH
1014: LD_INT 0
1016: EQUAL
1017: AND
1018: PUSH
1019: LD_EXP 35
1023: OR
1024: IFFALSE 1033
// game_strings := [ ] ;
1026: LD_ADDR_EXP 6
1030: PUSH
1031: EMPTY
1032: ST_TO_ADDR
// if dezert = false and tick mod 33600 = 0 then
1033: LD_EXP 37
1037: PUSH
1038: LD_INT 0
1040: EQUAL
1041: PUSH
1042: LD_OWVAR 1
1046: PUSH
1047: LD_INT 33600
1049: MOD
1050: PUSH
1051: LD_INT 0
1053: EQUAL
1054: AND
1055: IFFALSE 1115
// begin p := Rand ( 1 , 5 ) ;
1057: LD_ADDR_VAR 0 2
1061: PUSH
1062: LD_INT 1
1064: PPUSH
1065: LD_INT 5
1067: PPUSH
1068: CALL_OW 12
1072: ST_TO_ADDR
// if p <= [ 4 , 3 , 3 ] [ game_difficulty ] then
1073: LD_VAR 0 2
1077: PUSH
1078: LD_INT 4
1080: PUSH
1081: LD_INT 3
1083: PUSH
1084: LD_INT 3
1086: PUSH
1087: EMPTY
1088: LIST
1089: LIST
1090: LIST
1091: PUSH
1092: LD_EXP 2
1096: ARRAY
1097: LESSEQUAL
1098: IFFALSE 1115
// begin RaiseSailEvent ( 92 ) ;
1100: LD_INT 92
1102: PPUSH
1103: CALL_OW 427
// dezert := true ;
1107: LD_ADDR_EXP 37
1111: PUSH
1112: LD_INT 1
1114: ST_TO_ADDR
// end ; end ; if tick mod 8400 = 0 then
1115: LD_OWVAR 1
1119: PUSH
1120: LD_INT 8400
1122: MOD
1123: PUSH
1124: LD_INT 0
1126: EQUAL
1127: IFFALSE 1136
// RaiseSailEvent ( 101 ) ;
1129: LD_INT 101
1131: PPUSH
1132: CALL_OW 427
// if MineExist ( 8 ) and u_mine = false then
1136: LD_INT 8
1138: PPUSH
1139: CALL 7009 0 1
1143: PUSH
1144: LD_EXP 13
1148: PUSH
1149: LD_INT 0
1151: EQUAL
1152: AND
1153: IFFALSE 1170
// begin u_mine := true ;
1155: LD_ADDR_EXP 13
1159: PUSH
1160: LD_INT 1
1162: ST_TO_ADDR
// ChangeMissionObjectives ( DS-T1m ) ;
1163: LD_STRING DS-T1m
1165: PPUSH
1166: CALL_OW 337
// end ; if FacExist ( 8 ) and u_fac = false then
1170: LD_INT 8
1172: PPUSH
1173: CALL 7071 0 1
1177: PUSH
1178: LD_EXP 14
1182: PUSH
1183: LD_INT 0
1185: EQUAL
1186: AND
1187: IFFALSE 1204
// begin u_fac := true ;
1189: LD_ADDR_EXP 14
1193: PUSH
1194: LD_INT 1
1196: ST_TO_ADDR
// ChangeMissionObjectives ( DS-T1f ) ;
1197: LD_STRING DS-T1f
1199: PPUSH
1200: CALL_OW 337
// end ; if hero_died then
1204: LD_EXP 33
1208: IFFALSE 1217
// YouLost ( DS-h1 ) ;
1210: LD_STRING DS-h1
1212: PPUSH
1213: CALL_OW 104
// if fort_destroyed then
1217: LD_EXP 32
1221: IFFALSE 1230
// YouLost ( DS-h2 ) ;
1223: LD_STRING DS-h2
1225: PPUSH
1226: CALL_OW 104
// if GetDistUnits ( leopold , l_cmndr ) > 6 and meeting_start = false then
1230: LD_EXP 7
1234: PPUSH
1235: LD_EXP 49
1239: PPUSH
1240: CALL_OW 296
1244: PUSH
1245: LD_INT 6
1247: GREATER
1248: PUSH
1249: LD_EXP 26
1253: PUSH
1254: LD_INT 0
1256: EQUAL
1257: AND
1258: IFFALSE 1281
// begin if not HasTask ( leopold ) then
1260: LD_EXP 7
1264: PPUSH
1265: CALL_OW 314
1269: NOT
1270: IFFALSE 1279
// RaiseSailEvent ( 1 ) ;
1272: LD_INT 1
1274: PPUSH
1275: CALL_OW 427
// end else
1279: GO 1298
// if meeting_start = false then
1281: LD_EXP 26
1285: PUSH
1286: LD_INT 0
1288: EQUAL
1289: IFFALSE 1298
// begin RaiseSailEvent ( 2 ) ;
1291: LD_INT 2
1293: PPUSH
1294: CALL_OW 427
// end ; if game_time >= [ 50 50$00 , 62 62$30 , 75 75$00 ] [ game_difficulty ] and meeting_end = false then
1298: LD_EXP 3
1302: PUSH
1303: LD_INT 105000
1305: PUSH
1306: LD_INT 131250
1308: PUSH
1309: LD_INT 157500
1311: PUSH
1312: EMPTY
1313: LIST
1314: LIST
1315: LIST
1316: PUSH
1317: LD_EXP 2
1321: ARRAY
1322: GREATEREQUAL
1323: PUSH
1324: LD_EXP 29
1328: PUSH
1329: LD_INT 0
1331: EQUAL
1332: AND
1333: IFFALSE 1350
// begin meeting_end := true ;
1335: LD_ADDR_EXP 29
1339: PUSH
1340: LD_INT 1
1342: ST_TO_ADDR
// RaiseSailEvent ( 200 ) ;
1343: LD_INT 200
1345: PPUSH
1346: CALL_OW 427
// end ; if meeting_time = 0 0$00 and meeting_arive = false then
1350: LD_EXP 30
1354: PUSH
1355: LD_INT 0
1357: EQUAL
1358: PUSH
1359: LD_EXP 27
1363: PUSH
1364: LD_INT 0
1366: EQUAL
1367: AND
1368: IFFALSE 1392
// begin meeting_arive := true ;
1370: LD_ADDR_EXP 27
1374: PUSH
1375: LD_INT 1
1377: ST_TO_ADDR
// game_strings := [ ] ;
1378: LD_ADDR_EXP 6
1382: PUSH
1383: EMPTY
1384: ST_TO_ADDR
// RaiseSailEvent ( 10 ) ;
1385: LD_INT 10
1387: PPUSH
1388: CALL_OW 427
// end ; if meeting_arive then
1392: LD_EXP 27
1396: IFFALSE 2195
// begin if arabian_attack = false and tick mod 4200 = 0 then
1398: LD_EXP 38
1402: PUSH
1403: LD_INT 0
1405: EQUAL
1406: PUSH
1407: LD_OWVAR 1
1411: PUSH
1412: LD_INT 4200
1414: MOD
1415: PUSH
1416: LD_INT 0
1418: EQUAL
1419: AND
1420: IFFALSE 1473
// begin p := Rand ( 1 , 100 ) ;
1422: LD_ADDR_VAR 0 2
1426: PUSH
1427: LD_INT 1
1429: PPUSH
1430: LD_INT 100
1432: PPUSH
1433: CALL_OW 12
1437: ST_TO_ADDR
// if p <= [ 80 , 85 , 90 ] [ game_difficulty ] then
1438: LD_VAR 0 2
1442: PUSH
1443: LD_INT 80
1445: PUSH
1446: LD_INT 85
1448: PUSH
1449: LD_INT 90
1451: PUSH
1452: EMPTY
1453: LIST
1454: LIST
1455: LIST
1456: PUSH
1457: LD_EXP 2
1461: ARRAY
1462: LESSEQUAL
1463: IFFALSE 1473
// arabian_attack := true ;
1465: LD_ADDR_EXP 38
1469: PUSH
1470: LD_INT 1
1472: ST_TO_ADDR
// end ; if russian_trade = false and russian_attack = false and tick > 52500 then
1473: LD_EXP 43
1477: PUSH
1478: LD_INT 0
1480: EQUAL
1481: PUSH
1482: LD_EXP 39
1486: PUSH
1487: LD_INT 0
1489: EQUAL
1490: AND
1491: PUSH
1492: LD_OWVAR 1
1496: PUSH
1497: LD_INT 52500
1499: GREATER
1500: AND
1501: IFFALSE 1572
// begin russian_trade = true ;
1503: LD_ADDR_EXP 43
1507: PUSH
1508: LD_INT 1
1510: ST_TO_ADDR
// DialogueOn ;
1511: CALL_OW 6
// SayRadio ( ru_comander , DS-DR-RTr ) ;
1515: LD_EXP 47
1519: PPUSH
1520: LD_STRING DS-DR-RTr
1522: PPUSH
1523: CALL_OW 94
// Say ( l_cmndr , DS-DC-RTr ) ;
1527: LD_EXP 49
1531: PPUSH
1532: LD_STRING DS-DC-RTr
1534: PPUSH
1535: CALL_OW 88
// SayRadio ( ru_comander , DS-DR-RTr2 ) ;
1539: LD_EXP 47
1543: PPUSH
1544: LD_STRING DS-DR-RTr2
1546: PPUSH
1547: CALL_OW 94
// DialogueOff ;
1551: CALL_OW 7
// ChangeMissionObjectives ( DS-T2 ) ;
1555: LD_STRING DS-T2
1557: PPUSH
1558: CALL_OW 337
// SetAreaMapShow ( tree , 1 ) ;
1562: LD_INT 10
1564: PPUSH
1565: LD_INT 1
1567: PPUSH
1568: CALL_OW 424
// end ; if russian_trade and cargo_ok = false and russian_timer > 0 0$00 then
1572: LD_EXP 43
1576: PUSH
1577: LD_EXP 35
1581: PUSH
1582: LD_INT 0
1584: EQUAL
1585: AND
1586: PUSH
1587: LD_EXP 31
1591: PUSH
1592: LD_INT 0
1594: GREATER
1595: AND
1596: IFFALSE 1845
// begin if FilterUnitsInArea ( tree , ( [ [ f_empty ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] , [ f_not , [ f_control , control_remote ] ] ] ) ) > 0 then
1598: LD_INT 10
1600: PPUSH
1601: LD_INT 58
1603: PUSH
1604: EMPTY
1605: LIST
1606: PUSH
1607: LD_INT 2
1609: PUSH
1610: LD_INT 34
1612: PUSH
1613: LD_INT 32
1615: PUSH
1616: EMPTY
1617: LIST
1618: LIST
1619: PUSH
1620: LD_INT 34
1622: PUSH
1623: LD_INT 12
1625: PUSH
1626: EMPTY
1627: LIST
1628: LIST
1629: PUSH
1630: EMPTY
1631: LIST
1632: LIST
1633: LIST
1634: PUSH
1635: LD_INT 3
1637: PUSH
1638: LD_INT 33
1640: PUSH
1641: LD_INT 2
1643: PUSH
1644: EMPTY
1645: LIST
1646: LIST
1647: PUSH
1648: EMPTY
1649: LIST
1650: LIST
1651: PUSH
1652: EMPTY
1653: LIST
1654: LIST
1655: LIST
1656: PPUSH
1657: CALL_OW 70
1661: PUSH
1662: LD_INT 0
1664: GREATER
1665: IFFALSE 1845
// if GetCargo ( FilterUnitsInArea ( tree , ( [ [ f_empty ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] , [ f_not , [ f_control , control_remote ] ] ] ) ) [ 1 ] , mat_siberit ) = 100 then
1667: LD_INT 10
1669: PPUSH
1670: LD_INT 58
1672: PUSH
1673: EMPTY
1674: LIST
1675: PUSH
1676: LD_INT 2
1678: PUSH
1679: LD_INT 34
1681: PUSH
1682: LD_INT 32
1684: PUSH
1685: EMPTY
1686: LIST
1687: LIST
1688: PUSH
1689: LD_INT 34
1691: PUSH
1692: LD_INT 12
1694: PUSH
1695: EMPTY
1696: LIST
1697: LIST
1698: PUSH
1699: EMPTY
1700: LIST
1701: LIST
1702: LIST
1703: PUSH
1704: LD_INT 3
1706: PUSH
1707: LD_INT 33
1709: PUSH
1710: LD_INT 2
1712: PUSH
1713: EMPTY
1714: LIST
1715: LIST
1716: PUSH
1717: EMPTY
1718: LIST
1719: LIST
1720: PUSH
1721: EMPTY
1722: LIST
1723: LIST
1724: LIST
1725: PPUSH
1726: CALL_OW 70
1730: PUSH
1731: LD_INT 1
1733: ARRAY
1734: PPUSH
1735: LD_INT 3
1737: PPUSH
1738: CALL_OW 289
1742: PUSH
1743: LD_INT 100
1745: EQUAL
1746: IFFALSE 1845
// begin cargo_ok := true ;
1748: LD_ADDR_EXP 35
1752: PUSH
1753: LD_INT 1
1755: ST_TO_ADDR
// RemoveUnit ( FilterUnitsInArea ( tree , ( [ [ f_empty ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] , [ f_not , [ f_control , control_remote ] ] ] ) ) [ 1 ] ) ;
1756: LD_INT 10
1758: PPUSH
1759: LD_INT 58
1761: PUSH
1762: EMPTY
1763: LIST
1764: PUSH
1765: LD_INT 2
1767: PUSH
1768: LD_INT 34
1770: PUSH
1771: LD_INT 32
1773: PUSH
1774: EMPTY
1775: LIST
1776: LIST
1777: PUSH
1778: LD_INT 34
1780: PUSH
1781: LD_INT 12
1783: PUSH
1784: EMPTY
1785: LIST
1786: LIST
1787: PUSH
1788: EMPTY
1789: LIST
1790: LIST
1791: LIST
1792: PUSH
1793: LD_INT 3
1795: PUSH
1796: LD_INT 33
1798: PUSH
1799: LD_INT 2
1801: PUSH
1802: EMPTY
1803: LIST
1804: LIST
1805: PUSH
1806: EMPTY
1807: LIST
1808: LIST
1809: PUSH
1810: EMPTY
1811: LIST
1812: LIST
1813: LIST
1814: PPUSH
1815: CALL_OW 70
1819: PUSH
1820: LD_INT 1
1822: ARRAY
1823: PPUSH
1824: CALL_OW 64
// ChangeMissionObjectives ( DS-T2-out ) ;
1828: LD_STRING DS-T2-out
1830: PPUSH
1831: CALL_OW 337
// SetAreaMapShow ( tree , 0 ) ;
1835: LD_INT 10
1837: PPUSH
1838: LD_INT 0
1840: PPUSH
1841: CALL_OW 424
// end ; end ; if russian_attack = false and russian_trade and cargo_ok = false and russian_timer = 0 0$00 then
1845: LD_EXP 39
1849: PUSH
1850: LD_INT 0
1852: EQUAL
1853: PUSH
1854: LD_EXP 43
1858: AND
1859: PUSH
1860: LD_EXP 35
1864: PUSH
1865: LD_INT 0
1867: EQUAL
1868: AND
1869: PUSH
1870: LD_EXP 31
1874: PUSH
1875: LD_INT 0
1877: EQUAL
1878: AND
1879: IFFALSE 1906
// begin russian_attack := true ;
1881: LD_ADDR_EXP 39
1885: PUSH
1886: LD_INT 1
1888: ST_TO_ADDR
// ChangeMissionObjectives ( DS-T2-out ) ;
1889: LD_STRING DS-T2-out
1891: PPUSH
1892: CALL_OW 337
// SetAreaMapShow ( tree , 0 ) ;
1896: LD_INT 10
1898: PPUSH
1899: LD_INT 0
1901: PPUSH
1902: CALL_OW 424
// end ; if russian_trade = false and russian_attack = false and american_attack = false and tick mod 21000 = 0 then
1906: LD_EXP 43
1910: PUSH
1911: LD_INT 0
1913: EQUAL
1914: PUSH
1915: LD_EXP 39
1919: PUSH
1920: LD_INT 0
1922: EQUAL
1923: AND
1924: PUSH
1925: LD_EXP 40
1929: PUSH
1930: LD_INT 0
1932: EQUAL
1933: AND
1934: PUSH
1935: LD_OWVAR 1
1939: PUSH
1940: LD_INT 21000
1942: MOD
1943: PUSH
1944: LD_INT 0
1946: EQUAL
1947: AND
1948: IFFALSE 2001
// begin p := Rand ( 1 , 100 ) ;
1950: LD_ADDR_VAR 0 2
1954: PUSH
1955: LD_INT 1
1957: PPUSH
1958: LD_INT 100
1960: PPUSH
1961: CALL_OW 12
1965: ST_TO_ADDR
// if p <= [ 25 , 35 , 45 ] [ game_difficulty ] then
1966: LD_VAR 0 2
1970: PUSH
1971: LD_INT 25
1973: PUSH
1974: LD_INT 35
1976: PUSH
1977: LD_INT 45
1979: PUSH
1980: EMPTY
1981: LIST
1982: LIST
1983: LIST
1984: PUSH
1985: LD_EXP 2
1989: ARRAY
1990: LESSEQUAL
1991: IFFALSE 2001
// russian_attack := true ;
1993: LD_ADDR_EXP 39
1997: PUSH
1998: LD_INT 1
2000: ST_TO_ADDR
// end ; if american_help = false and american_attack = false and russian_attack = false and tick mod 31500 = 0 then
2001: LD_EXP 41
2005: PUSH
2006: LD_INT 0
2008: EQUAL
2009: PUSH
2010: LD_EXP 40
2014: PUSH
2015: LD_INT 0
2017: EQUAL
2018: AND
2019: PUSH
2020: LD_EXP 39
2024: PUSH
2025: LD_INT 0
2027: EQUAL
2028: AND
2029: PUSH
2030: LD_OWVAR 1
2034: PUSH
2035: LD_INT 31500
2037: MOD
2038: PUSH
2039: LD_INT 0
2041: EQUAL
2042: AND
2043: IFFALSE 2096
// begin p := Rand ( 1 , 100 ) ;
2045: LD_ADDR_VAR 0 2
2049: PUSH
2050: LD_INT 1
2052: PPUSH
2053: LD_INT 100
2055: PPUSH
2056: CALL_OW 12
2060: ST_TO_ADDR
// if p <= [ 22 , 33 , 44 ] [ game_difficulty ] then
2061: LD_VAR 0 2
2065: PUSH
2066: LD_INT 22
2068: PUSH
2069: LD_INT 33
2071: PUSH
2072: LD_INT 44
2074: PUSH
2075: EMPTY
2076: LIST
2077: LIST
2078: LIST
2079: PUSH
2080: LD_EXP 2
2084: ARRAY
2085: LESSEQUAL
2086: IFFALSE 2096
// american_attack := true ;
2088: LD_ADDR_EXP 40
2092: PUSH
2093: LD_INT 1
2095: ST_TO_ADDR
// end ; if american_attack = false and russian_attack = false and american_help = false and tick mod 21200 = 0 then
2096: LD_EXP 40
2100: PUSH
2101: LD_INT 0
2103: EQUAL
2104: PUSH
2105: LD_EXP 39
2109: PUSH
2110: LD_INT 0
2112: EQUAL
2113: AND
2114: PUSH
2115: LD_EXP 41
2119: PUSH
2120: LD_INT 0
2122: EQUAL
2123: AND
2124: PUSH
2125: LD_OWVAR 1
2129: PUSH
2130: LD_INT 21200
2132: MOD
2133: PUSH
2134: LD_INT 0
2136: EQUAL
2137: AND
2138: IFFALSE 2195
// begin p := Rand ( 1 , 100 ) ;
2140: LD_ADDR_VAR 0 2
2144: PUSH
2145: LD_INT 1
2147: PPUSH
2148: LD_INT 100
2150: PPUSH
2151: CALL_OW 12
2155: ST_TO_ADDR
// if p <= american_hchan then
2156: LD_VAR 0 2
2160: PUSH
2161: LD_EXP 36
2165: LESSEQUAL
2166: IFFALSE 2195
// begin american_help := true ;
2168: LD_ADDR_EXP 41
2172: PUSH
2173: LD_INT 1
2175: ST_TO_ADDR
// SayRadio ( am_comander , DS-amhelp ) ;
2176: LD_EXP 46
2180: PPUSH
2181: LD_STRING DS-amhelp
2183: PPUSH
2184: CALL_OW 94
// RaiseSailEvent ( 91 ) ;
2188: LD_INT 91
2190: PPUSH
2191: CALL_OW 427
// end ; end ; end ; if american_attack and american_timeing = 0 0$00 and FilterAllUnits ( [ f_side , 1 ] ) = 0 then
2195: LD_EXP 40
2199: PUSH
2200: LD_EXP 25
2204: PUSH
2205: LD_INT 0
2207: EQUAL
2208: AND
2209: PUSH
2210: LD_INT 22
2212: PUSH
2213: LD_INT 1
2215: PUSH
2216: EMPTY
2217: LIST
2218: LIST
2219: PPUSH
2220: CALL_OW 69
2224: PUSH
2225: LD_INT 0
2227: EQUAL
2228: AND
2229: IFFALSE 2331
// begin american_timeing := Rand ( 17 17$00 , 20 20$00 ) ;
2231: LD_ADDR_EXP 25
2235: PUSH
2236: LD_INT 35700
2238: PPUSH
2239: LD_INT 42000
2241: PPUSH
2242: CALL_OW 12
2246: ST_TO_ADDR
// SayRadio ( scout , DS-DZ-U ) ;
2247: LD_EXP 12
2251: PPUSH
2252: LD_STRING DS-DZ-U
2254: PPUSH
2255: CALL_OW 94
// Wait ( 0 0$33 ) ;
2259: LD_INT 1155
2261: PPUSH
2262: CALL_OW 67
// x := Rand ( 1 , 2 ) ;
2266: LD_ADDR_VAR 0 3
2270: PUSH
2271: LD_INT 1
2273: PPUSH
2274: LD_INT 2
2276: PPUSH
2277: CALL_OW 12
2281: ST_TO_ADDR
// case x of 1 :
2282: LD_VAR 0 3
2286: PUSH
2287: LD_INT 1
2289: DOUBLE
2290: EQUAL
2291: IFTRUE 2295
2293: GO 2305
2295: POP
// RaiseSailEvent ( 41 ) ; 2 :
2296: LD_INT 41
2298: PPUSH
2299: CALL_OW 427
2303: GO 2324
2305: LD_INT 2
2307: DOUBLE
2308: EQUAL
2309: IFTRUE 2313
2311: GO 2323
2313: POP
// RaiseSailEvent ( 42 ) ; end ;
2314: LD_INT 42
2316: PPUSH
2317: CALL_OW 427
2321: GO 2324
2323: POP
// RaiseSailEvent ( 42 ) ;
2324: LD_INT 42
2326: PPUSH
2327: CALL_OW 427
// end ; if russian_attack and russian_timeing = 0 0$00 and FilterAllUnits ( [ f_side , 3 ] ) = 0 then
2331: LD_EXP 39
2335: PUSH
2336: LD_EXP 24
2340: PUSH
2341: LD_INT 0
2343: EQUAL
2344: AND
2345: PUSH
2346: LD_INT 22
2348: PUSH
2349: LD_INT 3
2351: PUSH
2352: EMPTY
2353: LIST
2354: LIST
2355: PPUSH
2356: CALL_OW 69
2360: PUSH
2361: LD_INT 0
2363: EQUAL
2364: AND
2365: IFFALSE 2421
// begin russian_timeing := Rand ( 17 17$00 , 20 20$00 ) ;
2367: LD_ADDR_EXP 24
2371: PUSH
2372: LD_INT 35700
2374: PPUSH
2375: LD_INT 42000
2377: PPUSH
2378: CALL_OW 12
2382: ST_TO_ADDR
// SayRadio ( scout , DS-DZ-R ) ;
2383: LD_EXP 12
2387: PPUSH
2388: LD_STRING DS-DZ-R
2390: PPUSH
2391: CALL_OW 94
// Wait ( 0 0$45 ) ;
2395: LD_INT 1575
2397: PPUSH
2398: CALL_OW 67
// SayRadio ( ru_comander , DS-DR-R1 ) ;
2402: LD_EXP 47
2406: PPUSH
2407: LD_STRING DS-DR-R1
2409: PPUSH
2410: CALL_OW 94
// RaiseSailEvent ( 51 ) ;
2414: LD_INT 51
2416: PPUSH
2417: CALL_OW 427
// end ; if mission_time >= 10 10$00 and arabian_force < 10 then
2421: LD_EXP 34
2425: PUSH
2426: LD_INT 21000
2428: GREATEREQUAL
2429: PUSH
2430: LD_EXP 20
2434: PUSH
2435: LD_INT 10
2437: LESS
2438: AND
2439: IFFALSE 2463
// begin mission_time := 0 0$00 ;
2441: LD_ADDR_EXP 34
2445: PUSH
2446: LD_INT 0
2448: ST_TO_ADDR
// arabian_force := arabian_force + 1 ;
2449: LD_ADDR_EXP 20
2453: PUSH
2454: LD_EXP 20
2458: PUSH
2459: LD_INT 1
2461: PLUS
2462: ST_TO_ADDR
// end ; if arabian_timeing = 0 0$00 and FilterAllUnits ( [ [ f_side , 2 ] , [ f_not , [ f_weapon , ar_control_tower ] ] ] ) = 0 then
2463: LD_EXP 23
2467: PUSH
2468: LD_INT 0
2470: EQUAL
2471: PUSH
2472: LD_INT 22
2474: PUSH
2475: LD_INT 2
2477: PUSH
2478: EMPTY
2479: LIST
2480: LIST
2481: PUSH
2482: LD_INT 3
2484: PUSH
2485: LD_INT 34
2487: PUSH
2488: LD_INT 31
2490: PUSH
2491: EMPTY
2492: LIST
2493: LIST
2494: PUSH
2495: EMPTY
2496: LIST
2497: LIST
2498: PUSH
2499: EMPTY
2500: LIST
2501: LIST
2502: PPUSH
2503: CALL_OW 69
2507: PUSH
2508: LD_INT 0
2510: EQUAL
2511: AND
2512: IFFALSE 2710
// begin arabian_timeing := 7 7$30 ;
2514: LD_ADDR_EXP 23
2518: PUSH
2519: LD_INT 15750
2521: ST_TO_ADDR
// x := Rand ( 1 , 3 ) ;
2522: LD_ADDR_VAR 0 3
2526: PUSH
2527: LD_INT 1
2529: PPUSH
2530: LD_INT 3
2532: PPUSH
2533: CALL_OW 12
2537: ST_TO_ADDR
// SayRadio ( scout , DS-DZ-H ) ;
2538: LD_EXP 12
2542: PPUSH
2543: LD_STRING DS-DZ-H
2545: PPUSH
2546: CALL_OW 94
// case x of 1 :
2550: LD_VAR 0 3
2554: PUSH
2555: LD_INT 1
2557: DOUBLE
2558: EQUAL
2559: IFTRUE 2563
2561: GO 2573
2563: POP
// RaiseSailEvent ( 31 ) ; 2 :
2564: LD_INT 31
2566: PPUSH
2567: CALL_OW 427
2571: GO 2610
2573: LD_INT 2
2575: DOUBLE
2576: EQUAL
2577: IFTRUE 2581
2579: GO 2591
2581: POP
// RaiseSailEvent ( 32 ) ; 3 :
2582: LD_INT 32
2584: PPUSH
2585: CALL_OW 427
2589: GO 2610
2591: LD_INT 3
2593: DOUBLE
2594: EQUAL
2595: IFTRUE 2599
2597: GO 2609
2599: POP
// RaiseSailEvent ( 33 ) ; end ;
2600: LD_INT 33
2602: PPUSH
2603: CALL_OW 427
2607: GO 2610
2609: POP
// RaiseSailEvent ( 33 ) ;
2610: LD_INT 33
2612: PPUSH
2613: CALL_OW 427
// if game_difficulty > 1 then
2617: LD_EXP 2
2621: PUSH
2622: LD_INT 1
2624: GREATER
2625: IFFALSE 2634
// RaiseSailEvent ( 33 ) ;
2627: LD_INT 33
2629: PPUSH
2630: CALL_OW 427
// if heike_dialog1 = false then
2634: LD_EXP 44
2638: PUSH
2639: LD_INT 0
2641: EQUAL
2642: IFFALSE 2673
// begin heike_dialog1 := true ;
2644: LD_ADDR_EXP 44
2648: PUSH
2649: LD_INT 1
2651: ST_TO_ADDR
// Wait ( 0 0$03 ) ;
2652: LD_INT 105
2654: PPUSH
2655: CALL_OW 67
// SayRadio ( ar_comander , heike1 ) ;
2659: LD_EXP 48
2663: PPUSH
2664: LD_STRING heike1
2666: PPUSH
2667: CALL_OW 94
// end else
2671: GO 2710
// if heike_dialog2 = false then
2673: LD_EXP 45
2677: PUSH
2678: LD_INT 0
2680: EQUAL
2681: IFFALSE 2710
// begin heike_dialog2 := true ;
2683: LD_ADDR_EXP 45
2687: PUSH
2688: LD_INT 1
2690: ST_TO_ADDR
// Wait ( 0 0$03 ) ;
2691: LD_INT 105
2693: PPUSH
2694: CALL_OW 67
// SayRadio ( ar_comander , heike2 ) ;
2698: LD_EXP 48
2702: PPUSH
2703: LD_STRING heike2
2705: PPUSH
2706: CALL_OW 94
// end ; end ; if FilterAllUnits ( [ [ f_side , 2 ] , [ f_control , control_remote ] ] ) > 0 then
2710: LD_INT 22
2712: PUSH
2713: LD_INT 2
2715: PUSH
2716: EMPTY
2717: LIST
2718: LIST
2719: PUSH
2720: LD_INT 33
2722: PUSH
2723: LD_INT 2
2725: PUSH
2726: EMPTY
2727: LIST
2728: LIST
2729: PUSH
2730: EMPTY
2731: LIST
2732: LIST
2733: PPUSH
2734: CALL_OW 69
2738: PUSH
2739: LD_INT 0
2741: GREATER
2742: IFFALSE 2751
// ConnectWithTower ( 2 ) ;
2744: LD_INT 2
2746: PPUSH
2747: CALL 7119 0 1
// if FilterAllUnits ( [ [ [ f_side , 2 ] , [ f_not , [ f_weapon , ar_control_tower ] ] , [ f_not , [ f_hastask ] ] ] ] ) > 0 then
2751: LD_INT 22
2753: PUSH
2754: LD_INT 2
2756: PUSH
2757: EMPTY
2758: LIST
2759: LIST
2760: PUSH
2761: LD_INT 3
2763: PUSH
2764: LD_INT 34
2766: PUSH
2767: LD_INT 31
2769: PUSH
2770: EMPTY
2771: LIST
2772: LIST
2773: PUSH
2774: EMPTY
2775: LIST
2776: LIST
2777: PUSH
2778: LD_INT 3
2780: PUSH
2781: LD_INT 60
2783: PUSH
2784: EMPTY
2785: LIST
2786: PUSH
2787: EMPTY
2788: LIST
2789: LIST
2790: PUSH
2791: EMPTY
2792: LIST
2793: LIST
2794: LIST
2795: PUSH
2796: EMPTY
2797: LIST
2798: PPUSH
2799: CALL_OW 69
2803: PUSH
2804: LD_INT 0
2806: GREATER
2807: IFFALSE 2953
// begin filter := FilterAllUnits ( [ [ [ f_side , 2 ] , [ f_not , [ f_weapon , ar_control_tower ] ] , [ f_not , [ f_hastask ] ] ] ] ) ;
2809: LD_ADDR_VAR 0 4
2813: PUSH
2814: LD_INT 22
2816: PUSH
2817: LD_INT 2
2819: PUSH
2820: EMPTY
2821: LIST
2822: LIST
2823: PUSH
2824: LD_INT 3
2826: PUSH
2827: LD_INT 34
2829: PUSH
2830: LD_INT 31
2832: PUSH
2833: EMPTY
2834: LIST
2835: LIST
2836: PUSH
2837: EMPTY
2838: LIST
2839: LIST
2840: PUSH
2841: LD_INT 3
2843: PUSH
2844: LD_INT 60
2846: PUSH
2847: EMPTY
2848: LIST
2849: PUSH
2850: EMPTY
2851: LIST
2852: LIST
2853: PUSH
2854: EMPTY
2855: LIST
2856: LIST
2857: LIST
2858: PUSH
2859: EMPTY
2860: LIST
2861: PPUSH
2862: CALL_OW 69
2866: ST_TO_ADDR
// x := SpeedFilter ( FilterAllUnits ( [ f_enemy , 2 ] ) , 20 ) ;
2867: LD_ADDR_VAR 0 3
2871: PUSH
2872: LD_INT 81
2874: PUSH
2875: LD_INT 2
2877: PUSH
2878: EMPTY
2879: LIST
2880: LIST
2881: PPUSH
2882: CALL_OW 69
2886: PPUSH
2887: LD_INT 20
2889: PPUSH
2890: CALL 8502 0 2
2894: ST_TO_ADDR
// for i = 1 to filter do
2895: LD_ADDR_VAR 0 1
2899: PUSH
2900: DOUBLE
2901: LD_INT 1
2903: DEC
2904: ST_TO_ADDR
2905: LD_VAR 0 4
2909: PUSH
2910: FOR_TO
2911: IFFALSE 2951
// ComAttackUnit ( filter [ i ] , NearestUnitToUnit ( x , filter [ i ] ) ) ;
2913: LD_VAR 0 4
2917: PUSH
2918: LD_VAR 0 1
2922: ARRAY
2923: PPUSH
2924: LD_VAR 0 3
2928: PPUSH
2929: LD_VAR 0 4
2933: PUSH
2934: LD_VAR 0 1
2938: ARRAY
2939: PPUSH
2940: CALL_OW 74
2944: PPUSH
2945: CALL_OW 115
2949: GO 2910
2951: POP
2952: POP
// end ; if FilterAllUnits ( [ [ [ f_side , 3 ] , [ f_not , [ f_hastask ] ] ] ] ) > 0 then
2953: LD_INT 22
2955: PUSH
2956: LD_INT 3
2958: PUSH
2959: EMPTY
2960: LIST
2961: LIST
2962: PUSH
2963: LD_INT 3
2965: PUSH
2966: LD_INT 60
2968: PUSH
2969: EMPTY
2970: LIST
2971: PUSH
2972: EMPTY
2973: LIST
2974: LIST
2975: PUSH
2976: EMPTY
2977: LIST
2978: LIST
2979: PUSH
2980: EMPTY
2981: LIST
2982: PPUSH
2983: CALL_OW 69
2987: PUSH
2988: LD_INT 0
2990: GREATER
2991: IFFALSE 3137
// begin filter := FilterAllUnits ( [ [ [ f_side , 3 ] , [ f_not , [ f_weapon , ar_control_tower ] ] , [ f_not , [ f_hastask ] ] ] ] ) ;
2993: LD_ADDR_VAR 0 4
2997: PUSH
2998: LD_INT 22
3000: PUSH
3001: LD_INT 3
3003: PUSH
3004: EMPTY
3005: LIST
3006: LIST
3007: PUSH
3008: LD_INT 3
3010: PUSH
3011: LD_INT 34
3013: PUSH
3014: LD_INT 31
3016: PUSH
3017: EMPTY
3018: LIST
3019: LIST
3020: PUSH
3021: EMPTY
3022: LIST
3023: LIST
3024: PUSH
3025: LD_INT 3
3027: PUSH
3028: LD_INT 60
3030: PUSH
3031: EMPTY
3032: LIST
3033: PUSH
3034: EMPTY
3035: LIST
3036: LIST
3037: PUSH
3038: EMPTY
3039: LIST
3040: LIST
3041: LIST
3042: PUSH
3043: EMPTY
3044: LIST
3045: PPUSH
3046: CALL_OW 69
3050: ST_TO_ADDR
// x := SpeedFilter ( FilterAllUnits ( [ f_enemy , 3 ] ) , 20 ) ;
3051: LD_ADDR_VAR 0 3
3055: PUSH
3056: LD_INT 81
3058: PUSH
3059: LD_INT 3
3061: PUSH
3062: EMPTY
3063: LIST
3064: LIST
3065: PPUSH
3066: CALL_OW 69
3070: PPUSH
3071: LD_INT 20
3073: PPUSH
3074: CALL 8502 0 2
3078: ST_TO_ADDR
// for i = 1 to filter do
3079: LD_ADDR_VAR 0 1
3083: PUSH
3084: DOUBLE
3085: LD_INT 1
3087: DEC
3088: ST_TO_ADDR
3089: LD_VAR 0 4
3093: PUSH
3094: FOR_TO
3095: IFFALSE 3135
// ComAttackUnit ( filter [ i ] , NearestUnitToUnit ( x , filter [ i ] ) ) ;
3097: LD_VAR 0 4
3101: PUSH
3102: LD_VAR 0 1
3106: ARRAY
3107: PPUSH
3108: LD_VAR 0 3
3112: PPUSH
3113: LD_VAR 0 4
3117: PUSH
3118: LD_VAR 0 1
3122: ARRAY
3123: PPUSH
3124: CALL_OW 74
3128: PPUSH
3129: CALL_OW 115
3133: GO 3094
3135: POP
3136: POP
// end ; if FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_not , [ f_hastask ] ] ] ] ) > 0 then
3137: LD_INT 22
3139: PUSH
3140: LD_INT 1
3142: PUSH
3143: EMPTY
3144: LIST
3145: LIST
3146: PUSH
3147: LD_INT 3
3149: PUSH
3150: LD_INT 60
3152: PUSH
3153: EMPTY
3154: LIST
3155: PUSH
3156: EMPTY
3157: LIST
3158: LIST
3159: PUSH
3160: EMPTY
3161: LIST
3162: LIST
3163: PUSH
3164: EMPTY
3165: LIST
3166: PPUSH
3167: CALL_OW 69
3171: PUSH
3172: LD_INT 0
3174: GREATER
3175: IFFALSE 3321
// begin filter := FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_not , [ f_weapon , ar_control_tower ] ] , [ f_not , [ f_hastask ] ] ] ] ) ;
3177: LD_ADDR_VAR 0 4
3181: PUSH
3182: LD_INT 22
3184: PUSH
3185: LD_INT 1
3187: PUSH
3188: EMPTY
3189: LIST
3190: LIST
3191: PUSH
3192: LD_INT 3
3194: PUSH
3195: LD_INT 34
3197: PUSH
3198: LD_INT 31
3200: PUSH
3201: EMPTY
3202: LIST
3203: LIST
3204: PUSH
3205: EMPTY
3206: LIST
3207: LIST
3208: PUSH
3209: LD_INT 3
3211: PUSH
3212: LD_INT 60
3214: PUSH
3215: EMPTY
3216: LIST
3217: PUSH
3218: EMPTY
3219: LIST
3220: LIST
3221: PUSH
3222: EMPTY
3223: LIST
3224: LIST
3225: LIST
3226: PUSH
3227: EMPTY
3228: LIST
3229: PPUSH
3230: CALL_OW 69
3234: ST_TO_ADDR
// x := SpeedFilter ( FilterAllUnits ( [ f_enemy , 1 ] ) , 20 ) ;
3235: LD_ADDR_VAR 0 3
3239: PUSH
3240: LD_INT 81
3242: PUSH
3243: LD_INT 1
3245: PUSH
3246: EMPTY
3247: LIST
3248: LIST
3249: PPUSH
3250: CALL_OW 69
3254: PPUSH
3255: LD_INT 20
3257: PPUSH
3258: CALL 8502 0 2
3262: ST_TO_ADDR
// for i = 1 to filter do
3263: LD_ADDR_VAR 0 1
3267: PUSH
3268: DOUBLE
3269: LD_INT 1
3271: DEC
3272: ST_TO_ADDR
3273: LD_VAR 0 4
3277: PUSH
3278: FOR_TO
3279: IFFALSE 3319
// ComAttackUnit ( filter [ i ] , NearestUnitToUnit ( x , filter [ i ] ) ) ;
3281: LD_VAR 0 4
3285: PUSH
3286: LD_VAR 0 1
3290: ARRAY
3291: PPUSH
3292: LD_VAR 0 3
3296: PPUSH
3297: LD_VAR 0 4
3301: PUSH
3302: LD_VAR 0 1
3306: ARRAY
3307: PPUSH
3308: CALL_OW 74
3312: PPUSH
3313: CALL_OW 115
3317: GO 3278
3319: POP
3320: POP
// end ; if FilterAllUnits ( [ [ [ f_side , 2 ] , [ f_weapon , ar_bio_bomb ] , [ f_not , [ f_lives , 700 ] ] ] ] ) > 0 then
3321: LD_INT 22
3323: PUSH
3324: LD_INT 2
3326: PUSH
3327: EMPTY
3328: LIST
3329: LIST
3330: PUSH
3331: LD_INT 34
3333: PUSH
3334: LD_EXP 56
3338: PUSH
3339: EMPTY
3340: LIST
3341: LIST
3342: PUSH
3343: LD_INT 3
3345: PUSH
3346: LD_INT 24
3348: PUSH
3349: LD_INT 700
3351: PUSH
3352: EMPTY
3353: LIST
3354: LIST
3355: PUSH
3356: EMPTY
3357: LIST
3358: LIST
3359: PUSH
3360: EMPTY
3361: LIST
3362: LIST
3363: LIST
3364: PUSH
3365: EMPTY
3366: LIST
3367: PPUSH
3368: CALL_OW 69
3372: PUSH
3373: LD_INT 0
3375: GREATER
3376: IFFALSE 3475
// begin filter := FilterAllUnits ( [ [ [ f_side , 2 ] , [ f_weapon , ar_bio_bomb ] , [ f_not , [ f_lives , 700 ] ] ] ] ) ;
3378: LD_ADDR_VAR 0 4
3382: PUSH
3383: LD_INT 22
3385: PUSH
3386: LD_INT 2
3388: PUSH
3389: EMPTY
3390: LIST
3391: LIST
3392: PUSH
3393: LD_INT 34
3395: PUSH
3396: LD_EXP 56
3400: PUSH
3401: EMPTY
3402: LIST
3403: LIST
3404: PUSH
3405: LD_INT 3
3407: PUSH
3408: LD_INT 24
3410: PUSH
3411: LD_INT 700
3413: PUSH
3414: EMPTY
3415: LIST
3416: LIST
3417: PUSH
3418: EMPTY
3419: LIST
3420: LIST
3421: PUSH
3422: EMPTY
3423: LIST
3424: LIST
3425: LIST
3426: PUSH
3427: EMPTY
3428: LIST
3429: PPUSH
3430: CALL_OW 69
3434: ST_TO_ADDR
// for i = 1 to filter do
3435: LD_ADDR_VAR 0 1
3439: PUSH
3440: DOUBLE
3441: LD_INT 1
3443: DEC
3444: ST_TO_ADDR
3445: LD_VAR 0 4
3449: PUSH
3450: FOR_TO
3451: IFFALSE 3473
// SetLives ( filter [ i ] , 1 ) ;
3453: LD_VAR 0 4
3457: PUSH
3458: LD_VAR 0 1
3462: ARRAY
3463: PPUSH
3464: LD_INT 1
3466: PPUSH
3467: CALL_OW 234
3471: GO 3450
3473: POP
3474: POP
// end ; end ; end_of_file
3475: PPOPN 4
3477: END
// export function Start_Mission ; begin
3478: LD_INT 0
3480: PPUSH
// PrepareLegion ;
3481: CALL 3522 0 0
// PrepareMeeting ;
3485: CALL 4139 0 0
// case Query ( DS-text-beg ) of 1 :
3489: LD_STRING DS-text-beg
3491: PPUSH
3492: CALL_OW 97
3496: PUSH
3497: LD_INT 1
3499: DOUBLE
3500: EQUAL
3501: IFTRUE 3505
3503: GO 3508
3505: POP
// ; end ;
3506: GO 3509
3508: POP
// game_on := true ;
3509: LD_ADDR_EXP 1
3513: PUSH
3514: LD_INT 1
3516: ST_TO_ADDR
// end ;
3517: LD_VAR 0 1
3521: RET
// export l_cmndr , l_skill , l_units ; function PrepareLegion ; var i , p , filter , team ; begin
3522: LD_INT 0
3524: PPUSH
3525: PPUSH
3526: PPUSH
3527: PPUSH
3528: PPUSH
// uc_side := 8 ;
3529: LD_ADDR_OWVAR 20
3533: PUSH
3534: LD_INT 8
3536: ST_TO_ADDR
// uc_nation := 2 ;
3537: LD_ADDR_OWVAR 21
3541: PUSH
3542: LD_INT 2
3544: ST_TO_ADDR
// l_skill := [ 7 , 6 , 5 ] [ difficulty ] ;
3545: LD_ADDR_EXP 50
3549: PUSH
3550: LD_INT 7
3552: PUSH
3553: LD_INT 6
3555: PUSH
3556: LD_INT 5
3558: PUSH
3559: EMPTY
3560: LIST
3561: LIST
3562: LIST
3563: PUSH
3564: LD_OWVAR 67
3568: ARRAY
3569: ST_TO_ADDR
// l_units := [ 8 , 7 , 6 ] [ difficulty ] ;
3570: LD_ADDR_EXP 51
3574: PUSH
3575: LD_INT 8
3577: PUSH
3578: LD_INT 7
3580: PUSH
3581: LD_INT 6
3583: PUSH
3584: EMPTY
3585: LIST
3586: LIST
3587: LIST
3588: PUSH
3589: LD_OWVAR 67
3593: ARRAY
3594: ST_TO_ADDR
// filter := [ ] ;
3595: LD_ADDR_VAR 0 4
3599: PUSH
3600: EMPTY
3601: ST_TO_ADDR
// hc_gallery := desert ;
3602: LD_ADDR_OWVAR 33
3606: PUSH
3607: LD_STRING desert
3609: ST_TO_ADDR
// hc_face_number := 1 ;
3610: LD_ADDR_OWVAR 34
3614: PUSH
3615: LD_INT 1
3617: ST_TO_ADDR
// hc_skills := [ l_skill + 2 , l_skill - 1 , l_skill , l_skill + 1 ] ;
3618: LD_ADDR_OWVAR 31
3622: PUSH
3623: LD_EXP 50
3627: PUSH
3628: LD_INT 2
3630: PLUS
3631: PUSH
3632: LD_EXP 50
3636: PUSH
3637: LD_INT 1
3639: MINUS
3640: PUSH
3641: LD_EXP 50
3645: PUSH
3646: LD_EXP 50
3650: PUSH
3651: LD_INT 1
3653: PLUS
3654: PUSH
3655: EMPTY
3656: LIST
3657: LIST
3658: LIST
3659: LIST
3660: ST_TO_ADDR
// hc_sex := sex_male ;
3661: LD_ADDR_OWVAR 27
3665: PUSH
3666: LD_INT 1
3668: ST_TO_ADDR
// hc_name := Henri Ruotz ;
3669: LD_ADDR_OWVAR 26
3673: PUSH
3674: LD_STRING Henri Ruotz
3676: ST_TO_ADDR
// hc_attr := [ 10 , 10 ] ;
3677: LD_ADDR_OWVAR 29
3681: PUSH
3682: LD_INT 10
3684: PUSH
3685: LD_INT 10
3687: PUSH
3688: EMPTY
3689: LIST
3690: LIST
3691: ST_TO_ADDR
// hc_class := 1 ;
3692: LD_ADDR_OWVAR 28
3696: PUSH
3697: LD_INT 1
3699: ST_TO_ADDR
// hc_importance := 100 ;
3700: LD_ADDR_OWVAR 32
3704: PUSH
3705: LD_INT 100
3707: ST_TO_ADDR
// l_cmndr := CreateHuman ;
3708: LD_ADDR_EXP 49
3712: PUSH
3713: CALL_OW 44
3717: ST_TO_ADDR
// hc_importance := 0 ;
3718: LD_ADDR_OWVAR 32
3722: PUSH
3723: LD_INT 0
3725: ST_TO_ADDR
// scout := PrepareHuman ( sex_male , 1 , 0 ) ;
3726: LD_ADDR_EXP 12
3730: PUSH
3731: LD_INT 1
3733: PPUSH
3734: LD_INT 1
3736: PPUSH
3737: LD_INT 0
3739: PPUSH
3740: CALL_OW 380
3744: ST_TO_ADDR
// for i = 1 to 4 do
3745: LD_ADDR_VAR 0 2
3749: PUSH
3750: DOUBLE
3751: LD_INT 1
3753: DEC
3754: ST_TO_ADDR
3755: LD_INT 4
3757: PUSH
3758: FOR_TO
3759: IFFALSE 3809
// for p = 1 to 6 do
3761: LD_ADDR_VAR 0 3
3765: PUSH
3766: DOUBLE
3767: LD_INT 1
3769: DEC
3770: ST_TO_ADDR
3771: LD_INT 6
3773: PUSH
3774: FOR_TO
3775: IFFALSE 3805
// filter := filter ^ CreateHumanWithClass ( i , l_skill ) ;
3777: LD_ADDR_VAR 0 4
3781: PUSH
3782: LD_VAR 0 4
3786: PUSH
3787: LD_VAR 0 2
3791: PPUSH
3792: LD_EXP 50
3796: PPUSH
3797: CALL 7303 0 2
3801: ADD
3802: ST_TO_ADDR
3803: GO 3774
3805: POP
3806: POP
3807: GO 3758
3809: POP
3810: POP
// team := CharacterSelection ( text , l_units , l_units , [ sel_change_class , l_cmndr , sel_changeable , sel_not_hired ] ^ filter , [ class_soldier , class_mechanic , class_engineer , class_scientistic , class_mortar ] ) ;
3811: LD_ADDR_VAR 0 5
3815: PUSH
3816: LD_STRING text
3818: PPUSH
3819: LD_EXP 51
3823: PPUSH
3824: LD_EXP 51
3828: PPUSH
3829: LD_INT -5
3831: PUSH
3832: LD_EXP 49
3836: PUSH
3837: LD_INT -3
3839: PUSH
3840: LD_INT -2
3842: PUSH
3843: EMPTY
3844: LIST
3845: LIST
3846: LIST
3847: LIST
3848: PUSH
3849: LD_VAR 0 4
3853: ADD
3854: PPUSH
3855: LD_INT 1
3857: PUSH
3858: LD_INT 3
3860: PUSH
3861: LD_INT 2
3863: PUSH
3864: LD_INT 4
3866: PUSH
3867: LD_INT 8
3869: PUSH
3870: EMPTY
3871: LIST
3872: LIST
3873: LIST
3874: LIST
3875: LIST
3876: PPUSH
3877: CALL_OW 42
3881: ST_TO_ADDR
// for i = 1 to l_units do
3882: LD_ADDR_VAR 0 2
3886: PUSH
3887: DOUBLE
3888: LD_INT 1
3890: DEC
3891: ST_TO_ADDR
3892: LD_EXP 51
3896: PUSH
3897: FOR_TO
3898: IFFALSE 3923
// PlaceUnitArea ( team [ i ] , legion_spawn , false ) ;
3900: LD_VAR 0 5
3904: PUSH
3905: LD_VAR 0 2
3909: ARRAY
3910: PPUSH
3911: LD_INT 1
3913: PPUSH
3914: LD_INT 0
3916: PPUSH
3917: CALL_OW 49
3921: GO 3897
3923: POP
3924: POP
// PlaceUnitArea ( l_cmndr , legion_spawn , false ) ;
3925: LD_EXP 49
3929: PPUSH
3930: LD_INT 1
3932: PPUSH
3933: LD_INT 0
3935: PPUSH
3936: CALL_OW 49
// end ;
3940: LD_VAR 0 1
3944: RET
// export function PlaceCamera ; begin
3945: LD_INT 0
3947: PPUSH
// PlaceSeeing ( 46 , 48 , 8 , 10 ) ;
3948: LD_INT 46
3950: PPUSH
3951: LD_INT 48
3953: PPUSH
3954: LD_INT 8
3956: PPUSH
3957: LD_INT 10
3959: PPUSH
3960: CALL_OW 330
// PlaceSeeing ( 58 , 66 , 8 , 10 ) ;
3964: LD_INT 58
3966: PPUSH
3967: LD_INT 66
3969: PPUSH
3970: LD_INT 8
3972: PPUSH
3973: LD_INT 10
3975: PPUSH
3976: CALL_OW 330
// PlaceSeeing ( 82 , 82 , 8 , 10 ) ;
3980: LD_INT 82
3982: PPUSH
3983: LD_INT 82
3985: PPUSH
3986: LD_INT 8
3988: PPUSH
3989: LD_INT 10
3991: PPUSH
3992: CALL_OW 330
// PlaceSeeing ( 107 , 79 , 8 , 10 ) ;
3996: LD_INT 107
3998: PPUSH
3999: LD_INT 79
4001: PPUSH
4002: LD_INT 8
4004: PPUSH
4005: LD_INT 10
4007: PPUSH
4008: CALL_OW 330
// PlaceSeeing ( 101 , 57 , 8 , 10 ) ;
4012: LD_INT 101
4014: PPUSH
4015: LD_INT 57
4017: PPUSH
4018: LD_INT 8
4020: PPUSH
4021: LD_INT 10
4023: PPUSH
4024: CALL_OW 330
// PlaceSeeing ( 85 , 32 , 8 , 10 ) ;
4028: LD_INT 85
4030: PPUSH
4031: LD_INT 32
4033: PPUSH
4034: LD_INT 8
4036: PPUSH
4037: LD_INT 10
4039: PPUSH
4040: CALL_OW 330
// PlaceSeeing ( 108 , 72 , 8 , 10 ) ;
4044: LD_INT 108
4046: PPUSH
4047: LD_INT 72
4049: PPUSH
4050: LD_INT 8
4052: PPUSH
4053: LD_INT 10
4055: PPUSH
4056: CALL_OW 330
// PlaceSeeing ( 124 , 74 , 8 , 10 ) ;
4060: LD_INT 124
4062: PPUSH
4063: LD_INT 74
4065: PPUSH
4066: LD_INT 8
4068: PPUSH
4069: LD_INT 10
4071: PPUSH
4072: CALL_OW 330
// PlaceSeeing ( 67 , 33 , 8 , 20 ) ;
4076: LD_INT 67
4078: PPUSH
4079: LD_INT 33
4081: PPUSH
4082: LD_INT 8
4084: PPUSH
4085: LD_INT 20
4087: PPUSH
4088: CALL_OW 330
// RemoveSeeing ( 67 , 33 , 8 ) ;
4092: LD_INT 67
4094: PPUSH
4095: LD_INT 33
4097: PPUSH
4098: LD_INT 8
4100: PPUSH
4101: CALL_OW 331
// PlaceSeeing ( 94 , 84 , 8 , 20 ) ;
4105: LD_INT 94
4107: PPUSH
4108: LD_INT 84
4110: PPUSH
4111: LD_INT 8
4113: PPUSH
4114: LD_INT 20
4116: PPUSH
4117: CALL_OW 330
// RemoveSeeing ( 94 , 84 , 8 ) ;
4121: LD_INT 94
4123: PPUSH
4124: LD_INT 84
4126: PPUSH
4127: LD_INT 8
4129: PPUSH
4130: CALL_OW 331
// end ;
4134: LD_VAR 0 1
4138: RET
// export function PrepareMeeting ; begin
4139: LD_INT 0
4141: PPUSH
// uc_side := 6 ;
4142: LD_ADDR_OWVAR 20
4146: PUSH
4147: LD_INT 6
4149: ST_TO_ADDR
// hc_gallery := desert ;
4150: LD_ADDR_OWVAR 33
4154: PUSH
4155: LD_STRING desert
4157: ST_TO_ADDR
// hc_face_number := 2 ;
4158: LD_ADDR_OWVAR 34
4162: PUSH
4163: LD_INT 2
4165: ST_TO_ADDR
// hc_name := Leopold Drass ;
4166: LD_ADDR_OWVAR 26
4170: PUSH
4171: LD_STRING Leopold Drass
4173: ST_TO_ADDR
// hc_class := 1 ;
4174: LD_ADDR_OWVAR 28
4178: PUSH
4179: LD_INT 1
4181: ST_TO_ADDR
// hc_sex := sex_male ;
4182: LD_ADDR_OWVAR 27
4186: PUSH
4187: LD_INT 1
4189: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
4190: LD_ADDR_OWVAR 29
4194: PUSH
4195: LD_INT 12
4197: PUSH
4198: LD_INT 12
4200: PUSH
4201: EMPTY
4202: LIST
4203: LIST
4204: ST_TO_ADDR
// Leopold := CreateHuman ;
4205: LD_ADDR_EXP 7
4209: PUSH
4210: CALL_OW 44
4214: ST_TO_ADDR
// PlaceUnitArea ( Leopold , north_spawn , false ) ;
4215: LD_EXP 7
4219: PPUSH
4220: LD_INT 3
4222: PPUSH
4223: LD_INT 0
4225: PPUSH
4226: CALL_OW 49
// end ; end_of_file
4230: LD_VAR 0 1
4234: RET
// on SailEvent ( num ) do var i , filter , un , p , area ;
4235: LD_INT 0
4237: PPUSH
4238: PPUSH
4239: PPUSH
4240: PPUSH
4241: PPUSH
// begin case num of 1 :
4242: LD_VAR 0 1
4246: PUSH
4247: LD_INT 1
4249: DOUBLE
4250: EQUAL
4251: IFTRUE 4255
4253: GO 4287
4255: POP
// begin ComMoveXY ( leopold , GetX ( l_cmndr ) , GetY ( l_cmndr ) ) ;
4256: LD_EXP 7
4260: PPUSH
4261: LD_EXP 49
4265: PPUSH
4266: CALL_OW 250
4270: PPUSH
4271: LD_EXP 49
4275: PPUSH
4276: CALL_OW 251
4280: PPUSH
4281: CALL_OW 111
// end ; 2 :
4285: GO 6705
4287: LD_INT 2
4289: DOUBLE
4290: EQUAL
4291: IFTRUE 4295
4293: GO 4404
4295: POP
// begin InGameOn ;
4296: CALL_OW 8
// meeting_start := true ;
4300: LD_ADDR_EXP 26
4304: PUSH
4305: LD_INT 1
4307: ST_TO_ADDR
// ComTurnUnit ( leopold , l_cmndr ) ;
4308: LD_EXP 7
4312: PPUSH
4313: LD_EXP 49
4317: PPUSH
4318: CALL_OW 119
// ComTurnUnit ( l_cmndr , leopold ) ;
4322: LD_EXP 49
4326: PPUSH
4327: LD_EXP 7
4331: PPUSH
4332: CALL_OW 119
// Say ( leopold , DS-DL-1 ) ;
4336: LD_EXP 7
4340: PPUSH
4341: LD_STRING DS-DL-1
4343: PPUSH
4344: CALL_OW 88
// Say ( l_cmndr , DS-DC-1 ) ;
4348: LD_EXP 49
4352: PPUSH
4353: LD_STRING DS-DC-1
4355: PPUSH
4356: CALL_OW 88
// Say ( leopold , DS-DL-2 ) ;
4360: LD_EXP 7
4364: PPUSH
4365: LD_STRING DS-DL-2
4367: PPUSH
4368: CALL_OW 88
// ComEnterUnit ( leopold , fort ) ;
4372: LD_EXP 7
4376: PPUSH
4377: LD_INT 23
4379: PPUSH
4380: CALL_OW 120
// InGameOff ;
4384: CALL_OW 9
// Wait ( 0 0$01 ) ;
4388: LD_INT 35
4390: PPUSH
4391: CALL_OW 67
// ChangeMissionObjectives ( DS-T1 ) ;
4395: LD_STRING DS-T1
4397: PPUSH
4398: CALL_OW 337
// end ; 10 :
4402: GO 6705
4404: LD_INT 10
4406: DOUBLE
4407: EQUAL
4408: IFTRUE 4412
4410: GO 4624
4412: POP
// begin uc_side := 6 ;
4413: LD_ADDR_OWVAR 20
4417: PUSH
4418: LD_INT 6
4420: ST_TO_ADDR
// uc_nation := 2 ;
4421: LD_ADDR_OWVAR 21
4425: PUSH
4426: LD_INT 2
4428: ST_TO_ADDR
// hc_gallery :=  ;
4429: LD_ADDR_OWVAR 33
4433: PUSH
4434: LD_STRING 
4436: ST_TO_ADDR
// hc_skills := [ skill + 2 , skill - 1 , skill , skill + 1 ] ;
4437: LD_ADDR_OWVAR 31
4441: PUSH
4442: LD_EXP 16
4446: PUSH
4447: LD_INT 2
4449: PLUS
4450: PUSH
4451: LD_EXP 16
4455: PUSH
4456: LD_INT 1
4458: MINUS
4459: PUSH
4460: LD_EXP 16
4464: PUSH
4465: LD_EXP 16
4469: PUSH
4470: LD_INT 1
4472: PLUS
4473: PUSH
4474: EMPTY
4475: LIST
4476: LIST
4477: LIST
4478: LIST
4479: ST_TO_ADDR
// hc_sex := sex_male ;
4480: LD_ADDR_OWVAR 27
4484: PUSH
4485: LD_INT 1
4487: ST_TO_ADDR
// hc_name := Samuel van Horn ;
4488: LD_ADDR_OWVAR 26
4492: PUSH
4493: LD_STRING Samuel van Horn
4495: ST_TO_ADDR
// hc_attr := [ 11 , 10 ] ;
4496: LD_ADDR_OWVAR 29
4500: PUSH
4501: LD_INT 11
4503: PUSH
4504: LD_INT 10
4506: PUSH
4507: EMPTY
4508: LIST
4509: LIST
4510: ST_TO_ADDR
// hc_class := 1 ;
4511: LD_ADDR_OWVAR 28
4515: PUSH
4516: LD_INT 1
4518: ST_TO_ADDR
// samuel := CreateHuman ;
4519: LD_ADDR_EXP 9
4523: PUSH
4524: CALL_OW 44
4528: ST_TO_ADDR
// PlaceUnitArea ( samuel , south_spawn , false ) ;
4529: LD_EXP 9
4533: PPUSH
4534: LD_INT 4
4536: PPUSH
4537: LD_INT 0
4539: PPUSH
4540: CALL_OW 49
// for i = 1 to 3 do
4544: LD_ADDR_VAR 0 2
4548: PUSH
4549: DOUBLE
4550: LD_INT 1
4552: DEC
4553: ST_TO_ADDR
4554: LD_INT 3
4556: PUSH
4557: FOR_TO
4558: IFFALSE 4585
// PlaceUnitArea ( CreateHumanWithClass ( class_mortar , skill ) , south_spawn , false ) ;
4560: LD_INT 8
4562: PPUSH
4563: LD_EXP 16
4567: PPUSH
4568: CALL 7303 0 2
4572: PPUSH
4573: LD_INT 4
4575: PPUSH
4576: LD_INT 0
4578: PPUSH
4579: CALL_OW 49
4583: GO 4557
4585: POP
4586: POP
// ComEnterUnit ( FilterAllUnits ( [ f_side , 6 ] ) diff [ leopold , fort ] , fort ) ;
4587: LD_INT 22
4589: PUSH
4590: LD_INT 6
4592: PUSH
4593: EMPTY
4594: LIST
4595: LIST
4596: PPUSH
4597: CALL_OW 69
4601: PUSH
4602: LD_EXP 7
4606: PUSH
4607: LD_INT 23
4609: PUSH
4610: EMPTY
4611: LIST
4612: LIST
4613: DIFF
4614: PPUSH
4615: LD_INT 23
4617: PPUSH
4618: CALL_OW 120
// end ; 3 :
4622: GO 6705
4624: LD_INT 3
4626: DOUBLE
4627: EQUAL
4628: IFTRUE 4632
4630: GO 4643
4632: POP
// begin arabian_attack := true ;
4633: LD_ADDR_EXP 38
4637: PUSH
4638: LD_INT 1
4640: ST_TO_ADDR
// end ; 4 :
4641: GO 6705
4643: LD_INT 4
4645: DOUBLE
4646: EQUAL
4647: IFTRUE 4651
4649: GO 4662
4651: POP
// begin american_attack := true ;
4652: LD_ADDR_EXP 40
4656: PUSH
4657: LD_INT 1
4659: ST_TO_ADDR
// end ; 5 :
4660: GO 6705
4662: LD_INT 5
4664: DOUBLE
4665: EQUAL
4666: IFTRUE 4670
4668: GO 4681
4670: POP
// begin russian_attack := true ;
4671: LD_ADDR_EXP 39
4675: PUSH
4676: LD_INT 1
4678: ST_TO_ADDR
// end ; 31 :
4679: GO 6705
4681: LD_INT 31
4683: DOUBLE
4684: EQUAL
4685: IFTRUE 4689
4687: GO 4964
4689: POP
// begin area := areas [ Rand ( 1 , areas ) ] ;
4690: LD_ADDR_VAR 0 6
4694: PUSH
4695: LD_EXP 15
4699: PUSH
4700: LD_INT 1
4702: PPUSH
4703: LD_EXP 15
4707: PPUSH
4708: CALL_OW 12
4712: ARRAY
4713: ST_TO_ADDR
// uc_side := 2 ;
4714: LD_ADDR_OWVAR 20
4718: PUSH
4719: LD_INT 2
4721: ST_TO_ADDR
// uc_nation := 2 ;
4722: LD_ADDR_OWVAR 21
4726: PUSH
4727: LD_INT 2
4729: ST_TO_ADDR
// for i = 1 to arabian_force do
4730: LD_ADDR_VAR 0 2
4734: PUSH
4735: DOUBLE
4736: LD_INT 1
4738: DEC
4739: ST_TO_ADDR
4740: LD_EXP 20
4744: PUSH
4745: FOR_TO
4746: IFFALSE 4825
// begin vc_chassis := ar_half_tracked ;
4748: LD_ADDR_OWVAR 37
4752: PUSH
4753: LD_INT 14
4755: ST_TO_ADDR
// vc_engine := engine_siberite ;
4756: LD_ADDR_OWVAR 39
4760: PUSH
4761: LD_INT 3
4763: ST_TO_ADDR
// vc_control := control_remote ;
4764: LD_ADDR_OWVAR 38
4768: PUSH
4769: LD_INT 2
4771: ST_TO_ADDR
// vc_weapon := ar_weapons [ Rand ( 1 , ar_weapons ) ] ;
4772: LD_ADDR_OWVAR 40
4776: PUSH
4777: LD_EXP 17
4781: PUSH
4782: LD_INT 1
4784: PPUSH
4785: LD_EXP 17
4789: PPUSH
4790: CALL_OW 12
4794: ARRAY
4795: ST_TO_ADDR
// un := CreateVehicle ;
4796: LD_ADDR_VAR 0 4
4800: PUSH
4801: CALL_OW 45
4805: ST_TO_ADDR
// PlaceUnitArea ( un , area , false ) ;
4806: LD_VAR 0 4
4810: PPUSH
4811: LD_VAR 0 6
4815: PPUSH
4816: LD_INT 0
4818: PPUSH
4819: CALL_OW 49
// end ;
4823: GO 4745
4825: POP
4826: POP
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_control , control_manual ] ] ) < 2 then
4827: LD_INT 22
4829: PUSH
4830: LD_INT 2
4832: PUSH
4833: EMPTY
4834: LIST
4835: LIST
4836: PUSH
4837: LD_INT 33
4839: PUSH
4840: LD_INT 1
4842: PUSH
4843: EMPTY
4844: LIST
4845: LIST
4846: PUSH
4847: EMPTY
4848: LIST
4849: LIST
4850: PPUSH
4851: CALL_OW 69
4855: PUSH
4856: LD_INT 2
4858: LESS
4859: IFFALSE 4962
// for i = 1 to 2 do
4861: LD_ADDR_VAR 0 2
4865: PUSH
4866: DOUBLE
4867: LD_INT 1
4869: DEC
4870: ST_TO_ADDR
4871: LD_INT 2
4873: PUSH
4874: FOR_TO
4875: IFFALSE 4960
// begin vc_chassis := ar_half_tracked ;
4877: LD_ADDR_OWVAR 37
4881: PUSH
4882: LD_INT 14
4884: ST_TO_ADDR
// vc_engine := engine_siberite ;
4885: LD_ADDR_OWVAR 39
4889: PUSH
4890: LD_INT 3
4892: ST_TO_ADDR
// vc_control := control_manual ;
4893: LD_ADDR_OWVAR 38
4897: PUSH
4898: LD_INT 1
4900: ST_TO_ADDR
// vc_weapon := ar_control_tower ;
4901: LD_ADDR_OWVAR 40
4905: PUSH
4906: LD_INT 31
4908: ST_TO_ADDR
// un := CreateVehicle ;
4909: LD_ADDR_VAR 0 4
4913: PUSH
4914: CALL_OW 45
4918: ST_TO_ADDR
// PlaceUnitArea ( un , area , false ) ;
4919: LD_VAR 0 4
4923: PPUSH
4924: LD_VAR 0 6
4928: PPUSH
4929: LD_INT 0
4931: PPUSH
4932: CALL_OW 49
// PlaceHumanInUnit ( CreateHumanWithClass ( 3 , skill ) , un ) ;
4936: LD_INT 3
4938: PPUSH
4939: LD_EXP 16
4943: PPUSH
4944: CALL 7303 0 2
4948: PPUSH
4949: LD_VAR 0 4
4953: PPUSH
4954: CALL_OW 52
// end ;
4958: GO 4874
4960: POP
4961: POP
// end ; 32 :
4962: GO 6705
4964: LD_INT 32
4966: DOUBLE
4967: EQUAL
4968: IFTRUE 4972
4970: GO 5345
4972: POP
// begin area := areas [ Rand ( 1 , areas ) ] ;
4973: LD_ADDR_VAR 0 6
4977: PUSH
4978: LD_EXP 15
4982: PUSH
4983: LD_INT 1
4985: PPUSH
4986: LD_EXP 15
4990: PPUSH
4991: CALL_OW 12
4995: ARRAY
4996: ST_TO_ADDR
// uc_side := 2 ;
4997: LD_ADDR_OWVAR 20
5001: PUSH
5002: LD_INT 2
5004: ST_TO_ADDR
// uc_nation := 2 ;
5005: LD_ADDR_OWVAR 21
5009: PUSH
5010: LD_INT 2
5012: ST_TO_ADDR
// for i = 1 to ( arabian_force - 2 ) do
5013: LD_ADDR_VAR 0 2
5017: PUSH
5018: DOUBLE
5019: LD_INT 1
5021: DEC
5022: ST_TO_ADDR
5023: LD_EXP 20
5027: PUSH
5028: LD_INT 2
5030: MINUS
5031: PUSH
5032: FOR_TO
5033: IFFALSE 5116
// begin vc_chassis := ar_half_tracked ;
5035: LD_ADDR_OWVAR 37
5039: PUSH
5040: LD_INT 14
5042: ST_TO_ADDR
// vc_engine := engine_siberite ;
5043: LD_ADDR_OWVAR 39
5047: PUSH
5048: LD_INT 3
5050: ST_TO_ADDR
// vc_control := control_remote ;
5051: LD_ADDR_OWVAR 38
5055: PUSH
5056: LD_INT 2
5058: ST_TO_ADDR
// vc_weapon := ar_weapons [ Rand ( 1 , ar_weapons - 1 ) ] ;
5059: LD_ADDR_OWVAR 40
5063: PUSH
5064: LD_EXP 17
5068: PUSH
5069: LD_INT 1
5071: PPUSH
5072: LD_EXP 17
5076: PUSH
5077: LD_INT 1
5079: MINUS
5080: PPUSH
5081: CALL_OW 12
5085: ARRAY
5086: ST_TO_ADDR
// un := CreateVehicle ;
5087: LD_ADDR_VAR 0 4
5091: PUSH
5092: CALL_OW 45
5096: ST_TO_ADDR
// PlaceUnitArea ( un , area , false ) ;
5097: LD_VAR 0 4
5101: PPUSH
5102: LD_VAR 0 6
5106: PPUSH
5107: LD_INT 0
5109: PPUSH
5110: CALL_OW 49
// end ;
5114: GO 5032
5116: POP
5117: POP
// for i = 1 to Rand ( 0 , 1 ) + [ 3 , 4 , 5 ] [ game_difficulty ] do
5118: LD_ADDR_VAR 0 2
5122: PUSH
5123: DOUBLE
5124: LD_INT 1
5126: DEC
5127: ST_TO_ADDR
5128: LD_INT 0
5130: PPUSH
5131: LD_INT 1
5133: PPUSH
5134: CALL_OW 12
5138: PUSH
5139: LD_INT 3
5141: PUSH
5142: LD_INT 4
5144: PUSH
5145: LD_INT 5
5147: PUSH
5148: EMPTY
5149: LIST
5150: LIST
5151: LIST
5152: PUSH
5153: LD_EXP 2
5157: ARRAY
5158: PLUS
5159: PUSH
5160: FOR_TO
5161: IFFALSE 5198
// begin uc_nation := 0 ;
5163: LD_ADDR_OWVAR 21
5167: PUSH
5168: LD_INT 0
5170: ST_TO_ADDR
// PlaceUnitArea ( CreateHumanWithClass ( 17 , skill ) , area , false ) ;
5171: LD_INT 17
5173: PPUSH
5174: LD_EXP 16
5178: PPUSH
5179: CALL 7303 0 2
5183: PPUSH
5184: LD_VAR 0 6
5188: PPUSH
5189: LD_INT 0
5191: PPUSH
5192: CALL_OW 49
// end ;
5196: GO 5160
5198: POP
5199: POP
// uc_nation := 2 ;
5200: LD_ADDR_OWVAR 21
5204: PUSH
5205: LD_INT 2
5207: ST_TO_ADDR
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_control , control_manual ] ] ) < 2 then
5208: LD_INT 22
5210: PUSH
5211: LD_INT 2
5213: PUSH
5214: EMPTY
5215: LIST
5216: LIST
5217: PUSH
5218: LD_INT 33
5220: PUSH
5221: LD_INT 1
5223: PUSH
5224: EMPTY
5225: LIST
5226: LIST
5227: PUSH
5228: EMPTY
5229: LIST
5230: LIST
5231: PPUSH
5232: CALL_OW 69
5236: PUSH
5237: LD_INT 2
5239: LESS
5240: IFFALSE 5343
// for i = 1 to 2 do
5242: LD_ADDR_VAR 0 2
5246: PUSH
5247: DOUBLE
5248: LD_INT 1
5250: DEC
5251: ST_TO_ADDR
5252: LD_INT 2
5254: PUSH
5255: FOR_TO
5256: IFFALSE 5341
// begin vc_chassis := ar_half_tracked ;
5258: LD_ADDR_OWVAR 37
5262: PUSH
5263: LD_INT 14
5265: ST_TO_ADDR
// vc_engine := engine_siberite ;
5266: LD_ADDR_OWVAR 39
5270: PUSH
5271: LD_INT 3
5273: ST_TO_ADDR
// vc_control := control_manual ;
5274: LD_ADDR_OWVAR 38
5278: PUSH
5279: LD_INT 1
5281: ST_TO_ADDR
// vc_weapon := ar_control_tower ;
5282: LD_ADDR_OWVAR 40
5286: PUSH
5287: LD_INT 31
5289: ST_TO_ADDR
// un := CreateVehicle ;
5290: LD_ADDR_VAR 0 4
5294: PUSH
5295: CALL_OW 45
5299: ST_TO_ADDR
// PlaceUnitArea ( un , area , false ) ;
5300: LD_VAR 0 4
5304: PPUSH
5305: LD_VAR 0 6
5309: PPUSH
5310: LD_INT 0
5312: PPUSH
5313: CALL_OW 49
// PlaceHumanInUnit ( CreateHumanWithClass ( 3 , skill ) , un ) ;
5317: LD_INT 3
5319: PPUSH
5320: LD_EXP 16
5324: PPUSH
5325: CALL 7303 0 2
5329: PPUSH
5330: LD_VAR 0 4
5334: PPUSH
5335: CALL_OW 52
// end ;
5339: GO 5255
5341: POP
5342: POP
// end ; 33 :
5343: GO 6705
5345: LD_INT 33
5347: DOUBLE
5348: EQUAL
5349: IFTRUE 5353
5351: GO 5624
5353: POP
// begin area := areas [ Rand ( 1 , areas ) ] ;
5354: LD_ADDR_VAR 0 6
5358: PUSH
5359: LD_EXP 15
5363: PUSH
5364: LD_INT 1
5366: PPUSH
5367: LD_EXP 15
5371: PPUSH
5372: CALL_OW 12
5376: ARRAY
5377: ST_TO_ADDR
// uc_side := 2 ;
5378: LD_ADDR_OWVAR 20
5382: PUSH
5383: LD_INT 2
5385: ST_TO_ADDR
// uc_nation := 2 ;
5386: LD_ADDR_OWVAR 21
5390: PUSH
5391: LD_INT 2
5393: ST_TO_ADDR
// for i = 1 to ( arabian_force / 2 ) do
5394: LD_ADDR_VAR 0 2
5398: PUSH
5399: DOUBLE
5400: LD_INT 1
5402: DEC
5403: ST_TO_ADDR
5404: LD_EXP 20
5408: PUSH
5409: LD_INT 2
5411: DIVREAL
5412: PUSH
5413: FOR_TO
5414: IFFALSE 5519
// begin vc_chassis := ar_half_tracked ;
5416: LD_ADDR_OWVAR 37
5420: PUSH
5421: LD_INT 14
5423: ST_TO_ADDR
// vc_engine := engine_siberite ;
5424: LD_ADDR_OWVAR 39
5428: PUSH
5429: LD_INT 3
5431: ST_TO_ADDR
// vc_control := control_manual ;
5432: LD_ADDR_OWVAR 38
5436: PUSH
5437: LD_INT 1
5439: ST_TO_ADDR
// vc_weapon := ar_weapons [ Rand ( 1 , ar_weapons - 2 ) ] ;
5440: LD_ADDR_OWVAR 40
5444: PUSH
5445: LD_EXP 17
5449: PUSH
5450: LD_INT 1
5452: PPUSH
5453: LD_EXP 17
5457: PUSH
5458: LD_INT 2
5460: MINUS
5461: PPUSH
5462: CALL_OW 12
5466: ARRAY
5467: ST_TO_ADDR
// un := CreateVehicle ;
5468: LD_ADDR_VAR 0 4
5472: PUSH
5473: CALL_OW 45
5477: ST_TO_ADDR
// PlaceUnitArea ( un , area , false ) ;
5478: LD_VAR 0 4
5482: PPUSH
5483: LD_VAR 0 6
5487: PPUSH
5488: LD_INT 0
5490: PPUSH
5491: CALL_OW 49
// PlaceHumanInUnit ( CreateHumanWithClass ( 3 , skill ) , un ) ;
5495: LD_INT 3
5497: PPUSH
5498: LD_EXP 16
5502: PPUSH
5503: CALL 7303 0 2
5507: PPUSH
5508: LD_VAR 0 4
5512: PPUSH
5513: CALL_OW 52
// end ;
5517: GO 5413
5519: POP
5520: POP
// for i = 1 to ( arabian_force / 2 ) do
5521: LD_ADDR_VAR 0 2
5525: PUSH
5526: DOUBLE
5527: LD_INT 1
5529: DEC
5530: ST_TO_ADDR
5531: LD_EXP 20
5535: PUSH
5536: LD_INT 2
5538: DIVREAL
5539: PUSH
5540: FOR_TO
5541: IFFALSE 5620
// begin vc_chassis := ar_half_tracked ;
5543: LD_ADDR_OWVAR 37
5547: PUSH
5548: LD_INT 14
5550: ST_TO_ADDR
// vc_engine := engine_siberite ;
5551: LD_ADDR_OWVAR 39
5555: PUSH
5556: LD_INT 3
5558: ST_TO_ADDR
// vc_control := control_apeman ;
5559: LD_ADDR_OWVAR 38
5563: PUSH
5564: LD_INT 5
5566: ST_TO_ADDR
// vc_weapon := ar_weapons [ Rand ( 2 , ar_weapons ) ] ;
5567: LD_ADDR_OWVAR 40
5571: PUSH
5572: LD_EXP 17
5576: PUSH
5577: LD_INT 2
5579: PPUSH
5580: LD_EXP 17
5584: PPUSH
5585: CALL_OW 12
5589: ARRAY
5590: ST_TO_ADDR
// un := CreateVehicle ;
5591: LD_ADDR_VAR 0 4
5595: PUSH
5596: CALL_OW 45
5600: ST_TO_ADDR
// PlaceUnitArea ( un , area , false ) ;
5601: LD_VAR 0 4
5605: PPUSH
5606: LD_VAR 0 6
5610: PPUSH
5611: LD_INT 0
5613: PPUSH
5614: CALL_OW 49
// end ;
5618: GO 5540
5620: POP
5621: POP
// end ; 41 :
5622: GO 6705
5624: LD_INT 41
5626: DOUBLE
5627: EQUAL
5628: IFTRUE 5632
5630: GO 5776
5632: POP
// begin area := areas [ Rand ( 1 , areas ) ] ;
5633: LD_ADDR_VAR 0 6
5637: PUSH
5638: LD_EXP 15
5642: PUSH
5643: LD_INT 1
5645: PPUSH
5646: LD_EXP 15
5650: PPUSH
5651: CALL_OW 12
5655: ARRAY
5656: ST_TO_ADDR
// uc_side := 1 ;
5657: LD_ADDR_OWVAR 20
5661: PUSH
5662: LD_INT 1
5664: ST_TO_ADDR
// uc_nation := 1 ;
5665: LD_ADDR_OWVAR 21
5669: PUSH
5670: LD_INT 1
5672: ST_TO_ADDR
// for i = 1 to american_force do
5673: LD_ADDR_VAR 0 2
5677: PUSH
5678: DOUBLE
5679: LD_INT 1
5681: DEC
5682: ST_TO_ADDR
5683: LD_EXP 22
5687: PUSH
5688: FOR_TO
5689: IFFALSE 5772
// begin vc_chassis := us_morphling ;
5691: LD_ADDR_OWVAR 37
5695: PUSH
5696: LD_INT 5
5698: ST_TO_ADDR
// vc_engine := engine_siberite ;
5699: LD_ADDR_OWVAR 39
5703: PUSH
5704: LD_INT 3
5706: ST_TO_ADDR
// vc_control := control_computer ;
5707: LD_ADDR_OWVAR 38
5711: PUSH
5712: LD_INT 3
5714: ST_TO_ADDR
// vc_weapon := us_weapons [ Rand ( 1 , us_weapons - 1 ) ] ;
5715: LD_ADDR_OWVAR 40
5719: PUSH
5720: LD_EXP 19
5724: PUSH
5725: LD_INT 1
5727: PPUSH
5728: LD_EXP 19
5732: PUSH
5733: LD_INT 1
5735: MINUS
5736: PPUSH
5737: CALL_OW 12
5741: ARRAY
5742: ST_TO_ADDR
// un := CreateVehicle ;
5743: LD_ADDR_VAR 0 4
5747: PUSH
5748: CALL_OW 45
5752: ST_TO_ADDR
// PlaceUnitArea ( un , area , false ) ;
5753: LD_VAR 0 4
5757: PPUSH
5758: LD_VAR 0 6
5762: PPUSH
5763: LD_INT 0
5765: PPUSH
5766: CALL_OW 49
// end ;
5770: GO 5688
5772: POP
5773: POP
// end ; 42 :
5774: GO 6705
5776: LD_INT 42
5778: DOUBLE
5779: EQUAL
5780: IFTRUE 5784
5782: GO 5924
5784: POP
// begin area := areas [ Rand ( 1 , areas ) ] ;
5785: LD_ADDR_VAR 0 6
5789: PUSH
5790: LD_EXP 15
5794: PUSH
5795: LD_INT 1
5797: PPUSH
5798: LD_EXP 15
5802: PPUSH
5803: CALL_OW 12
5807: ARRAY
5808: ST_TO_ADDR
// uc_side := 1 ;
5809: LD_ADDR_OWVAR 20
5813: PUSH
5814: LD_INT 1
5816: ST_TO_ADDR
// uc_nation := 1 ;
5817: LD_ADDR_OWVAR 21
5821: PUSH
5822: LD_INT 1
5824: ST_TO_ADDR
// for i = 1 to american_force do
5825: LD_ADDR_VAR 0 2
5829: PUSH
5830: DOUBLE
5831: LD_INT 1
5833: DEC
5834: ST_TO_ADDR
5835: LD_EXP 22
5839: PUSH
5840: FOR_TO
5841: IFFALSE 5920
// begin vc_chassis := us_morphling ;
5843: LD_ADDR_OWVAR 37
5847: PUSH
5848: LD_INT 5
5850: ST_TO_ADDR
// vc_engine := engine_siberite ;
5851: LD_ADDR_OWVAR 39
5855: PUSH
5856: LD_INT 3
5858: ST_TO_ADDR
// vc_control := control_computer ;
5859: LD_ADDR_OWVAR 38
5863: PUSH
5864: LD_INT 3
5866: ST_TO_ADDR
// vc_weapon := us_weapons [ Rand ( 1 , us_weapons ) ] ;
5867: LD_ADDR_OWVAR 40
5871: PUSH
5872: LD_EXP 19
5876: PUSH
5877: LD_INT 1
5879: PPUSH
5880: LD_EXP 19
5884: PPUSH
5885: CALL_OW 12
5889: ARRAY
5890: ST_TO_ADDR
// un := CreateVehicle ;
5891: LD_ADDR_VAR 0 4
5895: PUSH
5896: CALL_OW 45
5900: ST_TO_ADDR
// PlaceUnitArea ( un , area , false ) ;
5901: LD_VAR 0 4
5905: PPUSH
5906: LD_VAR 0 6
5910: PPUSH
5911: LD_INT 0
5913: PPUSH
5914: CALL_OW 49
// end ;
5918: GO 5840
5920: POP
5921: POP
// end ; 51 :
5922: GO 6705
5924: LD_INT 51
5926: DOUBLE
5927: EQUAL
5928: IFTRUE 5932
5930: GO 6072
5932: POP
// begin area := areas [ Rand ( 1 , areas ) ] ;
5933: LD_ADDR_VAR 0 6
5937: PUSH
5938: LD_EXP 15
5942: PUSH
5943: LD_INT 1
5945: PPUSH
5946: LD_EXP 15
5950: PPUSH
5951: CALL_OW 12
5955: ARRAY
5956: ST_TO_ADDR
// uc_side := 3 ;
5957: LD_ADDR_OWVAR 20
5961: PUSH
5962: LD_INT 3
5964: ST_TO_ADDR
// uc_nation := 3 ;
5965: LD_ADDR_OWVAR 21
5969: PUSH
5970: LD_INT 3
5972: ST_TO_ADDR
// for i = 1 to russian_force do
5973: LD_ADDR_VAR 0 2
5977: PUSH
5978: DOUBLE
5979: LD_INT 1
5981: DEC
5982: ST_TO_ADDR
5983: LD_EXP 21
5987: PUSH
5988: FOR_TO
5989: IFFALSE 6068
// begin vc_chassis := ru_heavy_tracked ;
5991: LD_ADDR_OWVAR 37
5995: PUSH
5996: LD_INT 24
5998: ST_TO_ADDR
// vc_engine := engine_siberite ;
5999: LD_ADDR_OWVAR 39
6003: PUSH
6004: LD_INT 3
6006: ST_TO_ADDR
// vc_control := control_computer ;
6007: LD_ADDR_OWVAR 38
6011: PUSH
6012: LD_INT 3
6014: ST_TO_ADDR
// vc_weapon := ru_weapons [ Rand ( 1 , ru_weapons ) ] ;
6015: LD_ADDR_OWVAR 40
6019: PUSH
6020: LD_EXP 18
6024: PUSH
6025: LD_INT 1
6027: PPUSH
6028: LD_EXP 18
6032: PPUSH
6033: CALL_OW 12
6037: ARRAY
6038: ST_TO_ADDR
// un := CreateVehicle ;
6039: LD_ADDR_VAR 0 4
6043: PUSH
6044: CALL_OW 45
6048: ST_TO_ADDR
// PlaceUnitArea ( un , area , false ) ;
6049: LD_VAR 0 4
6053: PPUSH
6054: LD_VAR 0 6
6058: PPUSH
6059: LD_INT 0
6061: PPUSH
6062: CALL_OW 49
// end ;
6066: GO 5988
6068: POP
6069: POP
// end ; 91 :
6070: GO 6705
6072: LD_INT 91
6074: DOUBLE
6075: EQUAL
6076: IFTRUE 6080
6078: GO 6218
6080: POP
// begin uc_side := 8 ;
6081: LD_ADDR_OWVAR 20
6085: PUSH
6086: LD_INT 8
6088: ST_TO_ADDR
// uc_nation := 1 ;
6089: LD_ADDR_OWVAR 21
6093: PUSH
6094: LD_INT 1
6096: ST_TO_ADDR
// for i = 1 to [ 5 , 4 , 3 ] [ game_difficulty ] do
6097: LD_ADDR_VAR 0 2
6101: PUSH
6102: DOUBLE
6103: LD_INT 1
6105: DEC
6106: ST_TO_ADDR
6107: LD_INT 5
6109: PUSH
6110: LD_INT 4
6112: PUSH
6113: LD_INT 3
6115: PUSH
6116: EMPTY
6117: LIST
6118: LIST
6119: LIST
6120: PUSH
6121: LD_EXP 2
6125: ARRAY
6126: PUSH
6127: FOR_TO
6128: IFFALSE 6214
// begin vc_chassis := us_heavy_tracked ;
6130: LD_ADDR_OWVAR 37
6134: PUSH
6135: LD_INT 4
6137: ST_TO_ADDR
// vc_engine := engine_siberite ;
6138: LD_ADDR_OWVAR 39
6142: PUSH
6143: LD_INT 3
6145: ST_TO_ADDR
// vc_control := control_computer ;
6146: LD_ADDR_OWVAR 38
6150: PUSH
6151: LD_INT 3
6153: ST_TO_ADDR
// vc_weapon := [ us_double_gun , us_heavy_gun ] [ Rand ( 1 , 2 ) ] ;
6154: LD_ADDR_OWVAR 40
6158: PUSH
6159: LD_INT 5
6161: PUSH
6162: LD_INT 6
6164: PUSH
6165: EMPTY
6166: LIST
6167: LIST
6168: PUSH
6169: LD_INT 1
6171: PPUSH
6172: LD_INT 2
6174: PPUSH
6175: CALL_OW 12
6179: ARRAY
6180: ST_TO_ADDR
// un := CreateVehicle ;
6181: LD_ADDR_VAR 0 4
6185: PUSH
6186: CALL_OW 45
6190: ST_TO_ADDR
// PlaceUnitArea ( un , areas [ 1 ] , false ) ;
6191: LD_VAR 0 4
6195: PPUSH
6196: LD_EXP 15
6200: PUSH
6201: LD_INT 1
6203: ARRAY
6204: PPUSH
6205: LD_INT 0
6207: PPUSH
6208: CALL_OW 49
// end ;
6212: GO 6127
6214: POP
6215: POP
// end ; 92 :
6216: GO 6705
6218: LD_INT 92
6220: DOUBLE
6221: EQUAL
6222: IFTRUE 6226
6224: GO 6555
6226: POP
// begin uc_side := 5 ;
6227: LD_ADDR_OWVAR 20
6231: PUSH
6232: LD_INT 5
6234: ST_TO_ADDR
// uc_nation := 2 ;
6235: LD_ADDR_OWVAR 21
6239: PUSH
6240: LD_INT 2
6242: ST_TO_ADDR
// filter := [ ] ;
6243: LD_ADDR_VAR 0 3
6247: PUSH
6248: EMPTY
6249: ST_TO_ADDR
// InitHc ;
6250: CALL_OW 19
// PrepareHuman ( false , 1 , l_skill ) ;
6254: LD_INT 0
6256: PPUSH
6257: LD_INT 1
6259: PPUSH
6260: LD_EXP 50
6264: PPUSH
6265: CALL_OW 380
// un := CreateHuman ;
6269: LD_ADDR_VAR 0 4
6273: PUSH
6274: CALL_OW 44
6278: ST_TO_ADDR
// filter := filter ^ un ;
6279: LD_ADDR_VAR 0 3
6283: PUSH
6284: LD_VAR 0 3
6288: PUSH
6289: LD_VAR 0 4
6293: ADD
6294: ST_TO_ADDR
// for i = 1 to [ 4 , 3 , 2 ] [ game_difficulty ] do
6295: LD_ADDR_VAR 0 2
6299: PUSH
6300: DOUBLE
6301: LD_INT 1
6303: DEC
6304: ST_TO_ADDR
6305: LD_INT 4
6307: PUSH
6308: LD_INT 3
6310: PUSH
6311: LD_INT 2
6313: PUSH
6314: EMPTY
6315: LIST
6316: LIST
6317: LIST
6318: PUSH
6319: LD_EXP 2
6323: ARRAY
6324: PUSH
6325: FOR_TO
6326: IFFALSE 6364
// begin un := CreateHumanWithClass ( 1 , l_skill ) ;
6328: LD_ADDR_VAR 0 4
6332: PUSH
6333: LD_INT 1
6335: PPUSH
6336: LD_EXP 50
6340: PPUSH
6341: CALL 7303 0 2
6345: ST_TO_ADDR
// filter := filter ^ un ;
6346: LD_ADDR_VAR 0 3
6350: PUSH
6351: LD_VAR 0 3
6355: PUSH
6356: LD_VAR 0 4
6360: ADD
6361: ST_TO_ADDR
// end ;
6362: GO 6325
6364: POP
6365: POP
// DialogueOn ;
6366: CALL_OW 6
// if GetSex ( filter [ 1 ] ) = sex_male then
6370: LD_VAR 0 3
6374: PUSH
6375: LD_INT 1
6377: ARRAY
6378: PPUSH
6379: CALL_OW 258
6383: PUSH
6384: LD_INT 1
6386: EQUAL
6387: IFFALSE 6407
// SayRadio ( filter [ 1 ] , DS-DF-1 ) else
6389: LD_VAR 0 3
6393: PUSH
6394: LD_INT 1
6396: ARRAY
6397: PPUSH
6398: LD_STRING DS-DF-1
6400: PPUSH
6401: CALL_OW 94
6405: GO 6423
// SayRadio ( filter [ 1 ] , DS-DF-f1 ) ;
6407: LD_VAR 0 3
6411: PUSH
6412: LD_INT 1
6414: ARRAY
6415: PPUSH
6416: LD_STRING DS-DF-f1
6418: PPUSH
6419: CALL_OW 94
// case Query ( DS-dezert ) of 1 :
6423: LD_STRING DS-dezert
6425: PPUSH
6426: CALL_OW 97
6430: PUSH
6431: LD_INT 1
6433: DOUBLE
6434: EQUAL
6435: IFTRUE 6439
6437: GO 6454
6439: POP
// Say ( l_cmndr , DS-DC-dis ) ; 2 :
6440: LD_EXP 49
6444: PPUSH
6445: LD_STRING DS-DC-dis
6447: PPUSH
6448: CALL_OW 88
6452: GO 6549
6454: LD_INT 2
6456: DOUBLE
6457: EQUAL
6458: IFTRUE 6462
6460: GO 6548
6462: POP
// begin Say ( l_cmndr , DS-DC-acp ) ;
6463: LD_EXP 49
6467: PPUSH
6468: LD_STRING DS-DC-acp
6470: PPUSH
6471: CALL_OW 88
// for i = 1 to filter do
6475: LD_ADDR_VAR 0 2
6479: PUSH
6480: DOUBLE
6481: LD_INT 1
6483: DEC
6484: ST_TO_ADDR
6485: LD_VAR 0 3
6489: PUSH
6490: FOR_TO
6491: IFFALSE 6544
// begin SetSide ( filter [ i ] , 8 ) ;
6493: LD_VAR 0 3
6497: PUSH
6498: LD_VAR 0 2
6502: ARRAY
6503: PPUSH
6504: LD_INT 8
6506: PPUSH
6507: CALL_OW 235
// PlaceUnitArea ( filter [ i ] , south_spawn , false ) ;
6511: LD_VAR 0 3
6515: PUSH
6516: LD_VAR 0 2
6520: ARRAY
6521: PPUSH
6522: LD_INT 4
6524: PPUSH
6525: LD_INT 0
6527: PPUSH
6528: CALL_OW 49
// CenterNowOnXY ( 111 , 121 ) ;
6532: LD_INT 111
6534: PPUSH
6535: LD_INT 121
6537: PPUSH
6538: CALL_OW 86
// end ;
6542: GO 6490
6544: POP
6545: POP
// end ; end ;
6546: GO 6549
6548: POP
// DialogueOff ;
6549: CALL_OW 7
// end ; 101 :
6553: GO 6705
6555: LD_INT 101
6557: DOUBLE
6558: EQUAL
6559: IFTRUE 6563
6561: GO 6615
6563: POP
// begin CreateCratesArea ( Rand ( 3 , 5 ) , crates_area , true ) ;
6564: LD_INT 3
6566: PPUSH
6567: LD_INT 5
6569: PPUSH
6570: CALL_OW 12
6574: PPUSH
6575: LD_INT 9
6577: PPUSH
6578: LD_INT 1
6580: PPUSH
6581: CALL_OW 55
// Wait ( 0 0$11 ) ;
6585: LD_INT 385
6587: PPUSH
6588: CALL_OW 67
// CreateCratesArea ( Rand ( 3 , 5 ) , crates_area , true ) ;
6592: LD_INT 3
6594: PPUSH
6595: LD_INT 5
6597: PPUSH
6598: CALL_OW 12
6602: PPUSH
6603: LD_INT 9
6605: PPUSH
6606: LD_INT 1
6608: PPUSH
6609: CALL_OW 55
// end ; 200 :
6613: GO 6705
6615: LD_INT 200
6617: DOUBLE
6618: EQUAL
6619: IFTRUE 6623
6621: GO 6704
6623: POP
// begin Say ( Leopold , DS-end ) ;
6624: LD_EXP 7
6628: PPUSH
6629: LD_STRING DS-end
6631: PPUSH
6632: CALL_OW 88
// if Difficulty = 3 then
6636: LD_OWVAR 67
6640: PUSH
6641: LD_INT 3
6643: EQUAL
6644: IFFALSE 6653
// SetAchievement ( ACH_DESERT ) ;
6646: LD_STRING ACH_DESERT
6648: PPUSH
6649: CALL_OW 543
// music_nat := 5 ;
6653: LD_ADDR_OWVAR 71
6657: PUSH
6658: LD_INT 5
6660: ST_TO_ADDR
// AddMedal ( dsmed1 , 1 ) ;
6661: LD_STRING dsmed1
6663: PPUSH
6664: LD_INT 1
6666: PPUSH
6667: CALL_OW 101
// AddMedal ( dsmed1 , 1 ) ;
6671: LD_STRING dsmed1
6673: PPUSH
6674: LD_INT 1
6676: PPUSH
6677: CALL_OW 101
// AddMedal ( dsmed1 , 1 ) ;
6681: LD_STRING dsmed1
6683: PPUSH
6684: LD_INT 1
6686: PPUSH
6687: CALL_OW 101
// GiveMedals ( MAIN ) ;
6691: LD_STRING MAIN
6693: PPUSH
6694: CALL_OW 102
// YouWin ;
6698: CALL_OW 103
// end ; end ;
6702: GO 6705
6704: POP
// end ;
6705: PPOPN 6
6707: END
// on UnitGoesToRed ( un ) do begin if un in FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] ] ) then
6708: LD_VAR 0 1
6712: PUSH
6713: LD_INT 22
6715: PUSH
6716: LD_INT 2
6718: PUSH
6719: EMPTY
6720: LIST
6721: LIST
6722: PUSH
6723: LD_INT 21
6725: PUSH
6726: LD_INT 2
6728: PUSH
6729: EMPTY
6730: LIST
6731: LIST
6732: PUSH
6733: EMPTY
6734: LIST
6735: LIST
6736: PPUSH
6737: CALL_OW 69
6741: IN
6742: IFFALSE 6867
// begin Wait ( Rand ( 0 0$03 , 0 0$06 ) ) ;
6744: LD_INT 105
6746: PPUSH
6747: LD_INT 210
6749: PPUSH
6750: CALL_OW 12
6754: PPUSH
6755: CALL_OW 67
// MineExplosion ( GetX ( un ) , GetY ( un ) , 3 ) ;
6759: LD_VAR 0 1
6763: PPUSH
6764: CALL_OW 250
6768: PPUSH
6769: LD_VAR 0 1
6773: PPUSH
6774: CALL_OW 251
6778: PPUSH
6779: LD_INT 3
6781: PPUSH
6782: CALL_OW 453
// MineExplosion ( GetX ( un ) , GetY ( un ) , 3 ) ;
6786: LD_VAR 0 1
6790: PPUSH
6791: CALL_OW 250
6795: PPUSH
6796: LD_VAR 0 1
6800: PPUSH
6801: CALL_OW 251
6805: PPUSH
6806: LD_INT 3
6808: PPUSH
6809: CALL_OW 453
// MineExplosion ( GetX ( un ) , GetY ( un ) , 3 ) ;
6813: LD_VAR 0 1
6817: PPUSH
6818: CALL_OW 250
6822: PPUSH
6823: LD_VAR 0 1
6827: PPUSH
6828: CALL_OW 251
6832: PPUSH
6833: LD_INT 3
6835: PPUSH
6836: CALL_OW 453
// MineExplosion ( GetX ( un ) , GetY ( un ) , 3 ) ;
6840: LD_VAR 0 1
6844: PPUSH
6845: CALL_OW 250
6849: PPUSH
6850: LD_VAR 0 1
6854: PPUSH
6855: CALL_OW 251
6859: PPUSH
6860: LD_INT 3
6862: PPUSH
6863: CALL_OW 453
// end ; end ;
6867: PPOPN 1
6869: END
// on UnitDestroyed ( un ) do begin if un = fort then
6870: LD_VAR 0 1
6874: PUSH
6875: LD_INT 23
6877: EQUAL
6878: IFFALSE 6888
// fort_destroyed := true ;
6880: LD_ADDR_EXP 32
6884: PUSH
6885: LD_INT 1
6887: ST_TO_ADDR
// if un = l_cmndr then
6888: LD_VAR 0 1
6892: PUSH
6893: LD_EXP 49
6897: EQUAL
6898: IFFALSE 6908
// hero_died := true ;
6900: LD_ADDR_EXP 33
6904: PUSH
6905: LD_INT 1
6907: ST_TO_ADDR
// end ;
6908: PPOPN 1
6910: END
// on UnitDestroyed_Extra ( un , killerSide , killerUnit ) do begin debug_strings := un ;
6911: LD_ADDR_OWVAR 48
6915: PUSH
6916: LD_VAR 0 1
6920: ST_TO_ADDR
// SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ;
6921: LD_VAR 0 1
6925: PPUSH
6926: LD_VAR 0 2
6930: PPUSH
6931: LD_VAR 0 3
6935: PPUSH
6936: CALL 19382 0 3
// end ;
6940: PPOPN 3
6942: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
6943: LD_VAR 0 1
6947: PPUSH
6948: CALL 19480 0 1
// end ; end_of_file
6952: PPOPN 1
6954: END
// export function RefreshTime ( time , bool ) ; begin
6955: LD_INT 0
6957: PPUSH
// if bool then
6958: LD_VAR 0 2
6962: IFFALSE 6980
// time := time + 0 0$01 else
6964: LD_ADDR_VAR 0 1
6968: PUSH
6969: LD_VAR 0 1
6973: PUSH
6974: LD_INT 35
6976: PLUS
6977: ST_TO_ADDR
6978: GO 6994
// time := time - 0 0$01 ;
6980: LD_ADDR_VAR 0 1
6984: PUSH
6985: LD_VAR 0 1
6989: PUSH
6990: LD_INT 35
6992: MINUS
6993: ST_TO_ADDR
// result := time ;
6994: LD_ADDR_VAR 0 3
6998: PUSH
6999: LD_VAR 0 1
7003: ST_TO_ADDR
// end ;
7004: LD_VAR 0 3
7008: RET
// export function MineExist ( side ) ; begin
7009: LD_INT 0
7011: PPUSH
// if FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_siberite_mine ] ] ) > 0 then
7012: LD_INT 22
7014: PUSH
7015: LD_VAR 0 1
7019: PUSH
7020: EMPTY
7021: LIST
7022: LIST
7023: PUSH
7024: LD_INT 30
7026: PUSH
7027: LD_INT 30
7029: PUSH
7030: EMPTY
7031: LIST
7032: LIST
7033: PUSH
7034: EMPTY
7035: LIST
7036: LIST
7037: PPUSH
7038: CALL_OW 69
7042: PUSH
7043: LD_INT 0
7045: GREATER
7046: IFFALSE 7058
// result := true else
7048: LD_ADDR_VAR 0 2
7052: PUSH
7053: LD_INT 1
7055: ST_TO_ADDR
7056: GO 7066
// result := false ;
7058: LD_ADDR_VAR 0 2
7062: PUSH
7063: LD_INT 0
7065: ST_TO_ADDR
// end ;
7066: LD_VAR 0 2
7070: RET
// export function FacExist ( side ) ; begin
7071: LD_INT 0
7073: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_factory ] ] ) > 0 ;
7074: LD_ADDR_VAR 0 2
7078: PUSH
7079: LD_INT 22
7081: PUSH
7082: LD_VAR 0 1
7086: PUSH
7087: EMPTY
7088: LIST
7089: LIST
7090: PUSH
7091: LD_INT 30
7093: PUSH
7094: LD_INT 3
7096: PUSH
7097: EMPTY
7098: LIST
7099: LIST
7100: PUSH
7101: EMPTY
7102: LIST
7103: LIST
7104: PPUSH
7105: CALL_OW 69
7109: PUSH
7110: LD_INT 0
7112: GREATER
7113: ST_TO_ADDR
// end ;
7114: LD_VAR 0 2
7118: RET
// export function ConnectWithTower ( side ) ; var i , filter , tower ; begin
7119: LD_INT 0
7121: PPUSH
7122: PPUSH
7123: PPUSH
7124: PPUSH
// filter := FilterAllUnits ( [ [ f_side , side ] , [ f_control , control_remote ] , [ f_ok ] ] ) ;
7125: LD_ADDR_VAR 0 4
7129: PUSH
7130: LD_INT 22
7132: PUSH
7133: LD_VAR 0 1
7137: PUSH
7138: EMPTY
7139: LIST
7140: LIST
7141: PUSH
7142: LD_INT 33
7144: PUSH
7145: LD_INT 2
7147: PUSH
7148: EMPTY
7149: LIST
7150: LIST
7151: PUSH
7152: LD_INT 50
7154: PUSH
7155: EMPTY
7156: LIST
7157: PUSH
7158: EMPTY
7159: LIST
7160: LIST
7161: LIST
7162: PPUSH
7163: CALL_OW 69
7167: ST_TO_ADDR
// tower := FilterAllUnits ( [ [ f_side , side ] , [ f_weapon , ar_control_tower ] ] ) ;
7168: LD_ADDR_VAR 0 5
7172: PUSH
7173: LD_INT 22
7175: PUSH
7176: LD_VAR 0 1
7180: PUSH
7181: EMPTY
7182: LIST
7183: LIST
7184: PUSH
7185: LD_INT 34
7187: PUSH
7188: LD_INT 31
7190: PUSH
7191: EMPTY
7192: LIST
7193: LIST
7194: PUSH
7195: EMPTY
7196: LIST
7197: LIST
7198: PPUSH
7199: CALL_OW 69
7203: ST_TO_ADDR
// if tower > 0 and filter > 0 then
7204: LD_VAR 0 5
7208: PUSH
7209: LD_INT 0
7211: GREATER
7212: PUSH
7213: LD_VAR 0 4
7217: PUSH
7218: LD_INT 0
7220: GREATER
7221: AND
7222: IFFALSE 7298
// for i = 1 to filter do
7224: LD_ADDR_VAR 0 3
7228: PUSH
7229: DOUBLE
7230: LD_INT 1
7232: DEC
7233: ST_TO_ADDR
7234: LD_VAR 0 4
7238: PUSH
7239: FOR_TO
7240: IFFALSE 7296
// if not IsControledBy ( filter [ i ] ) then
7242: LD_VAR 0 4
7246: PUSH
7247: LD_VAR 0 3
7251: ARRAY
7252: PPUSH
7253: CALL_OW 312
7257: NOT
7258: IFFALSE 7294
// ComLinkTo ( filter [ i ] , tower [ Rand ( 1 , tower ) ] ) ;
7260: LD_VAR 0 4
7264: PUSH
7265: LD_VAR 0 3
7269: ARRAY
7270: PPUSH
7271: LD_VAR 0 5
7275: PUSH
7276: LD_INT 1
7278: PPUSH
7279: LD_VAR 0 5
7283: PPUSH
7284: CALL_OW 12
7288: ARRAY
7289: PPUSH
7290: CALL_OW 135
7294: GO 7239
7296: POP
7297: POP
// end ;
7298: LD_VAR 0 2
7302: RET
// export function CreateHumanWithClass ( clas , lvl ) ; var skill_com , skill_eng , skill_mech , skill_sci , bonus ; begin
7303: LD_INT 0
7305: PPUSH
7306: PPUSH
7307: PPUSH
7308: PPUSH
7309: PPUSH
7310: PPUSH
// hc_class := clas ;
7311: LD_ADDR_OWVAR 28
7315: PUSH
7316: LD_VAR 0 1
7320: ST_TO_ADDR
// skill_com := ( lvl + Rand ( - 1 , 1 ) ) ;
7321: LD_ADDR_VAR 0 4
7325: PUSH
7326: LD_VAR 0 2
7330: PUSH
7331: LD_INT 1
7333: NEG
7334: PPUSH
7335: LD_INT 1
7337: PPUSH
7338: CALL_OW 12
7342: PLUS
7343: ST_TO_ADDR
// skill_eng := ( lvl + Rand ( - 1 , 1 ) ) ;
7344: LD_ADDR_VAR 0 5
7348: PUSH
7349: LD_VAR 0 2
7353: PUSH
7354: LD_INT 1
7356: NEG
7357: PPUSH
7358: LD_INT 1
7360: PPUSH
7361: CALL_OW 12
7365: PLUS
7366: ST_TO_ADDR
// skill_mech := ( lvl + Rand ( - 1 , 1 ) ) ;
7367: LD_ADDR_VAR 0 6
7371: PUSH
7372: LD_VAR 0 2
7376: PUSH
7377: LD_INT 1
7379: NEG
7380: PPUSH
7381: LD_INT 1
7383: PPUSH
7384: CALL_OW 12
7388: PLUS
7389: ST_TO_ADDR
// skill_sci := ( lvl + Rand ( - 1 , 1 ) ) ;
7390: LD_ADDR_VAR 0 7
7394: PUSH
7395: LD_VAR 0 2
7399: PUSH
7400: LD_INT 1
7402: NEG
7403: PPUSH
7404: LD_INT 1
7406: PPUSH
7407: CALL_OW 12
7411: PLUS
7412: ST_TO_ADDR
// if clas = 1 or clas = 9 or clas = class_sniper or clas = class_mortar then
7413: LD_VAR 0 1
7417: PUSH
7418: LD_INT 1
7420: EQUAL
7421: PUSH
7422: LD_VAR 0 1
7426: PUSH
7427: LD_INT 9
7429: EQUAL
7430: OR
7431: PUSH
7432: LD_VAR 0 1
7436: PUSH
7437: LD_INT 5
7439: EQUAL
7440: OR
7441: PUSH
7442: LD_VAR 0 1
7446: PUSH
7447: LD_INT 8
7449: EQUAL
7450: OR
7451: IFFALSE 7476
// bonus := [ 2 , 0 , 0 , 0 ] ;
7453: LD_ADDR_VAR 0 8
7457: PUSH
7458: LD_INT 2
7460: PUSH
7461: LD_INT 0
7463: PUSH
7464: LD_INT 0
7466: PUSH
7467: LD_INT 0
7469: PUSH
7470: EMPTY
7471: LIST
7472: LIST
7473: LIST
7474: LIST
7475: ST_TO_ADDR
// if clas = 2 then
7476: LD_VAR 0 1
7480: PUSH
7481: LD_INT 2
7483: EQUAL
7484: IFFALSE 7509
// bonus := [ 0 , 2 , 0 , 0 ] ;
7486: LD_ADDR_VAR 0 8
7490: PUSH
7491: LD_INT 0
7493: PUSH
7494: LD_INT 2
7496: PUSH
7497: LD_INT 0
7499: PUSH
7500: LD_INT 0
7502: PUSH
7503: EMPTY
7504: LIST
7505: LIST
7506: LIST
7507: LIST
7508: ST_TO_ADDR
// if clas = 3 then
7509: LD_VAR 0 1
7513: PUSH
7514: LD_INT 3
7516: EQUAL
7517: IFFALSE 7542
// bonus := [ 0 , 0 , 2 , 0 ] ;
7519: LD_ADDR_VAR 0 8
7523: PUSH
7524: LD_INT 0
7526: PUSH
7527: LD_INT 0
7529: PUSH
7530: LD_INT 2
7532: PUSH
7533: LD_INT 0
7535: PUSH
7536: EMPTY
7537: LIST
7538: LIST
7539: LIST
7540: LIST
7541: ST_TO_ADDR
// if clas = 4 then
7542: LD_VAR 0 1
7546: PUSH
7547: LD_INT 4
7549: EQUAL
7550: IFFALSE 7575
// bonus := [ 0 , 0 , 0 , 2 ] ;
7552: LD_ADDR_VAR 0 8
7556: PUSH
7557: LD_INT 0
7559: PUSH
7560: LD_INT 0
7562: PUSH
7563: LD_INT 0
7565: PUSH
7566: LD_INT 2
7568: PUSH
7569: EMPTY
7570: LIST
7571: LIST
7572: LIST
7573: LIST
7574: ST_TO_ADDR
// if clas > 4 and clas <> 9 and clas <> class_sniper and clas <> class_mortar then
7575: LD_VAR 0 1
7579: PUSH
7580: LD_INT 4
7582: GREATER
7583: PUSH
7584: LD_VAR 0 1
7588: PUSH
7589: LD_INT 9
7591: NONEQUAL
7592: AND
7593: PUSH
7594: LD_VAR 0 1
7598: PUSH
7599: LD_INT 5
7601: NONEQUAL
7602: AND
7603: PUSH
7604: LD_VAR 0 1
7608: PUSH
7609: LD_INT 8
7611: NONEQUAL
7612: AND
7613: IFFALSE 7638
// bonus := [ 0 , 0 , 0 , 0 ] ;
7615: LD_ADDR_VAR 0 8
7619: PUSH
7620: LD_INT 0
7622: PUSH
7623: LD_INT 0
7625: PUSH
7626: LD_INT 0
7628: PUSH
7629: LD_INT 0
7631: PUSH
7632: EMPTY
7633: LIST
7634: LIST
7635: LIST
7636: LIST
7637: ST_TO_ADDR
// hc_basic_skills := [ Rand ( 0 , 2 ) , Rand ( 0 , 2 ) , Rand ( 0 , 2 ) , Rand ( 0 , 2 ) ] ;
7638: LD_ADDR_OWVAR 30
7642: PUSH
7643: LD_INT 0
7645: PPUSH
7646: LD_INT 2
7648: PPUSH
7649: CALL_OW 12
7653: PUSH
7654: LD_INT 0
7656: PPUSH
7657: LD_INT 2
7659: PPUSH
7660: CALL_OW 12
7664: PUSH
7665: LD_INT 0
7667: PPUSH
7668: LD_INT 2
7670: PPUSH
7671: CALL_OW 12
7675: PUSH
7676: LD_INT 0
7678: PPUSH
7679: LD_INT 2
7681: PPUSH
7682: CALL_OW 12
7686: PUSH
7687: EMPTY
7688: LIST
7689: LIST
7690: LIST
7691: LIST
7692: ST_TO_ADDR
// hc_skills := [ skill_com + bonus [ 1 ] , skill_eng + bonus [ 2 ] , skill_mech + bonus [ 3 ] , skill_sci + bonus [ 4 ] ] ;
7693: LD_ADDR_OWVAR 31
7697: PUSH
7698: LD_VAR 0 4
7702: PUSH
7703: LD_VAR 0 8
7707: PUSH
7708: LD_INT 1
7710: ARRAY
7711: PLUS
7712: PUSH
7713: LD_VAR 0 5
7717: PUSH
7718: LD_VAR 0 8
7722: PUSH
7723: LD_INT 2
7725: ARRAY
7726: PLUS
7727: PUSH
7728: LD_VAR 0 6
7732: PUSH
7733: LD_VAR 0 8
7737: PUSH
7738: LD_INT 3
7740: ARRAY
7741: PLUS
7742: PUSH
7743: LD_VAR 0 7
7747: PUSH
7748: LD_VAR 0 8
7752: PUSH
7753: LD_INT 4
7755: ARRAY
7756: PLUS
7757: PUSH
7758: EMPTY
7759: LIST
7760: LIST
7761: LIST
7762: LIST
7763: ST_TO_ADDR
// hc_sex := Rand ( sex_male , sex_female ) ;
7764: LD_ADDR_OWVAR 27
7768: PUSH
7769: LD_INT 1
7771: PPUSH
7772: LD_INT 2
7774: PPUSH
7775: CALL_OW 12
7779: ST_TO_ADDR
// hc_gallery :=  ;
7780: LD_ADDR_OWVAR 33
7784: PUSH
7785: LD_STRING 
7787: ST_TO_ADDR
// hc_attr := [ Rand ( 8 , 12 ) , Rand ( 9 , 11 ) ] ;
7788: LD_ADDR_OWVAR 29
7792: PUSH
7793: LD_INT 8
7795: PPUSH
7796: LD_INT 12
7798: PPUSH
7799: CALL_OW 12
7803: PUSH
7804: LD_INT 9
7806: PPUSH
7807: LD_INT 11
7809: PPUSH
7810: CALL_OW 12
7814: PUSH
7815: EMPTY
7816: LIST
7817: LIST
7818: ST_TO_ADDR
// hc_name :=  ;
7819: LD_ADDR_OWVAR 26
7823: PUSH
7824: LD_STRING 
7826: ST_TO_ADDR
// result := CreateHuman ;
7827: LD_ADDR_VAR 0 3
7831: PUSH
7832: CALL_OW 44
7836: ST_TO_ADDR
// end ;
7837: LD_VAR 0 3
7841: RET
// export function GetSpeed ( unit ) ; begin
7842: LD_INT 0
7844: PPUSH
// result := GetProperties ( unit ) [ 1 ] ;
7845: LD_ADDR_VAR 0 2
7849: PUSH
7850: LD_VAR 0 1
7854: PPUSH
7855: CALL_OW 464
7859: PUSH
7860: LD_INT 1
7862: ARRAY
7863: ST_TO_ADDR
// end ;
7864: LD_VAR 0 2
7868: RET
// export function PrepareNature ( area , num1 , num2 , num3 , num4 ) ; var l , apeman , tiger , bird , horse ; begin
7869: LD_INT 0
7871: PPUSH
7872: PPUSH
7873: PPUSH
7874: PPUSH
7875: PPUSH
7876: PPUSH
// uc_nation = nation_nature ;
7877: LD_ADDR_OWVAR 21
7881: PUSH
7882: LD_INT 0
7884: ST_TO_ADDR
// uc_side = 0 ;
7885: LD_ADDR_OWVAR 20
7889: PUSH
7890: LD_INT 0
7892: ST_TO_ADDR
// l = 0 ;
7893: LD_ADDR_VAR 0 7
7897: PUSH
7898: LD_INT 0
7900: ST_TO_ADDR
// repeat begin uc_direction = Rand ( 0 , 5 ) ;
7901: LD_ADDR_OWVAR 24
7905: PUSH
7906: LD_INT 0
7908: PPUSH
7909: LD_INT 5
7911: PPUSH
7912: CALL_OW 12
7916: ST_TO_ADDR
// hc_agressivity = Rand ( - 5 , 0 ) ;
7917: LD_ADDR_OWVAR 35
7921: PUSH
7922: LD_INT 5
7924: NEG
7925: PPUSH
7926: LD_INT 0
7928: PPUSH
7929: CALL_OW 12
7933: ST_TO_ADDR
// hc_gallery =  ;
7934: LD_ADDR_OWVAR 33
7938: PUSH
7939: LD_STRING 
7941: ST_TO_ADDR
// hc_class = class_apeman ;
7942: LD_ADDR_OWVAR 28
7946: PUSH
7947: LD_INT 12
7949: ST_TO_ADDR
// hc_attr = [ Rand ( 11 , 13 ) , Rand ( 10 , 11 ) ] ;
7950: LD_ADDR_OWVAR 29
7954: PUSH
7955: LD_INT 11
7957: PPUSH
7958: LD_INT 13
7960: PPUSH
7961: CALL_OW 12
7965: PUSH
7966: LD_INT 10
7968: PPUSH
7969: LD_INT 11
7971: PPUSH
7972: CALL_OW 12
7976: PUSH
7977: EMPTY
7978: LIST
7979: LIST
7980: ST_TO_ADDR
// hc_sex = sex_male ;
7981: LD_ADDR_OWVAR 27
7985: PUSH
7986: LD_INT 1
7988: ST_TO_ADDR
// hc_skills = [ Rand ( 0 , 2 ) , 0 , 0 , 0 ] ;
7989: LD_ADDR_OWVAR 31
7993: PUSH
7994: LD_INT 0
7996: PPUSH
7997: LD_INT 2
7999: PPUSH
8000: CALL_OW 12
8004: PUSH
8005: LD_INT 0
8007: PUSH
8008: LD_INT 0
8010: PUSH
8011: LD_INT 0
8013: PUSH
8014: EMPTY
8015: LIST
8016: LIST
8017: LIST
8018: LIST
8019: ST_TO_ADDR
// apeman = CreateHuman ;
8020: LD_ADDR_VAR 0 8
8024: PUSH
8025: CALL_OW 44
8029: ST_TO_ADDR
// PlaceUnitArea ( apeman , area , false ) ;
8030: LD_VAR 0 8
8034: PPUSH
8035: LD_VAR 0 1
8039: PPUSH
8040: LD_INT 0
8042: PPUSH
8043: CALL_OW 49
// l = l + 1 ;
8047: LD_ADDR_VAR 0 7
8051: PUSH
8052: LD_VAR 0 7
8056: PUSH
8057: LD_INT 1
8059: PLUS
8060: ST_TO_ADDR
// end until l = num1 ;
8061: LD_VAR 0 7
8065: PUSH
8066: LD_VAR 0 2
8070: EQUAL
8071: IFFALSE 7901
// l = 0 ;
8073: LD_ADDR_VAR 0 7
8077: PUSH
8078: LD_INT 0
8080: ST_TO_ADDR
// repeat begin hc_agressivity = Rand ( 0 , 25 ) ;
8081: LD_ADDR_OWVAR 35
8085: PUSH
8086: LD_INT 0
8088: PPUSH
8089: LD_INT 25
8091: PPUSH
8092: CALL_OW 12
8096: ST_TO_ADDR
// hc_class = class_tiger ;
8097: LD_ADDR_OWVAR 28
8101: PUSH
8102: LD_INT 14
8104: ST_TO_ADDR
// hc_sex = sex_male ;
8105: LD_ADDR_OWVAR 27
8109: PUSH
8110: LD_INT 1
8112: ST_TO_ADDR
// hc_gallery = sandnature ;
8113: LD_ADDR_OWVAR 33
8117: PUSH
8118: LD_STRING sandnature
8120: ST_TO_ADDR
// hc_face_number = 3 ;
8121: LD_ADDR_OWVAR 34
8125: PUSH
8126: LD_INT 3
8128: ST_TO_ADDR
// tiger = CreateHuman ;
8129: LD_ADDR_VAR 0 9
8133: PUSH
8134: CALL_OW 44
8138: ST_TO_ADDR
// PlaceUnitArea ( tiger , area , false ) ;
8139: LD_VAR 0 9
8143: PPUSH
8144: LD_VAR 0 1
8148: PPUSH
8149: LD_INT 0
8151: PPUSH
8152: CALL_OW 49
// l = l + 1 ;
8156: LD_ADDR_VAR 0 7
8160: PUSH
8161: LD_VAR 0 7
8165: PUSH
8166: LD_INT 1
8168: PLUS
8169: ST_TO_ADDR
// end until l = num2 ;
8170: LD_VAR 0 7
8174: PUSH
8175: LD_VAR 0 3
8179: EQUAL
8180: IFFALSE 8081
// l = 0 ;
8182: LD_ADDR_VAR 0 7
8186: PUSH
8187: LD_INT 0
8189: ST_TO_ADDR
// repeat begin hc_class = class_phororhacos ;
8190: LD_ADDR_OWVAR 28
8194: PUSH
8195: LD_INT 18
8197: ST_TO_ADDR
// hc_gallery = sandnature ;
8198: LD_ADDR_OWVAR 33
8202: PUSH
8203: LD_STRING sandnature
8205: ST_TO_ADDR
// hc_face_number = 1 ;
8206: LD_ADDR_OWVAR 34
8210: PUSH
8211: LD_INT 1
8213: ST_TO_ADDR
// bird = CreateHuman ;
8214: LD_ADDR_VAR 0 10
8218: PUSH
8219: CALL_OW 44
8223: ST_TO_ADDR
// PlaceUnitAnywhere ( bird , false ) ;
8224: LD_VAR 0 10
8228: PPUSH
8229: LD_INT 0
8231: PPUSH
8232: CALL_OW 51
// l = l + 1 ;
8236: LD_ADDR_VAR 0 7
8240: PUSH
8241: LD_VAR 0 7
8245: PUSH
8246: LD_INT 1
8248: PLUS
8249: ST_TO_ADDR
// end until l = num3 ;
8250: LD_VAR 0 7
8254: PUSH
8255: LD_VAR 0 4
8259: EQUAL
8260: IFFALSE 8190
// l = 0 ;
8262: LD_ADDR_VAR 0 7
8266: PUSH
8267: LD_INT 0
8269: ST_TO_ADDR
// repeat begin hc_class = 21 ;
8270: LD_ADDR_OWVAR 28
8274: PUSH
8275: LD_INT 21
8277: ST_TO_ADDR
// hc_gallery = sandnature ;
8278: LD_ADDR_OWVAR 33
8282: PUSH
8283: LD_STRING sandnature
8285: ST_TO_ADDR
// hc_face_number = 5 ;
8286: LD_ADDR_OWVAR 34
8290: PUSH
8291: LD_INT 5
8293: ST_TO_ADDR
// horse := CreateHuman ;
8294: LD_ADDR_VAR 0 11
8298: PUSH
8299: CALL_OW 44
8303: ST_TO_ADDR
// PlaceUnitArea ( horse , area , false ) ;
8304: LD_VAR 0 11
8308: PPUSH
8309: LD_VAR 0 1
8313: PPUSH
8314: LD_INT 0
8316: PPUSH
8317: CALL_OW 49
// l = l + 1 ;
8321: LD_ADDR_VAR 0 7
8325: PUSH
8326: LD_VAR 0 7
8330: PUSH
8331: LD_INT 1
8333: PLUS
8334: ST_TO_ADDR
// end until l = num4 ;
8335: LD_VAR 0 7
8339: PUSH
8340: LD_VAR 0 5
8344: EQUAL
8345: IFFALSE 8270
// end ;
8347: LD_VAR 0 6
8351: RET
// export function PrepareComm ; begin
8352: LD_INT 0
8354: PPUSH
// uc_side := 1 ;
8355: LD_ADDR_OWVAR 20
8359: PUSH
8360: LD_INT 1
8362: ST_TO_ADDR
// uc_nation := 1 ;
8363: LD_ADDR_OWVAR 21
8367: PUSH
8368: LD_INT 1
8370: ST_TO_ADDR
// hc_gallery :=  ;
8371: LD_ADDR_OWVAR 33
8375: PUSH
8376: LD_STRING 
8378: ST_TO_ADDR
// hc_name :=  ;
8379: LD_ADDR_OWVAR 26
8383: PUSH
8384: LD_STRING 
8386: ST_TO_ADDR
// hc_class := 1 ;
8387: LD_ADDR_OWVAR 28
8391: PUSH
8392: LD_INT 1
8394: ST_TO_ADDR
// hc_sex := sex_male ;
8395: LD_ADDR_OWVAR 27
8399: PUSH
8400: LD_INT 1
8402: ST_TO_ADDR
// am_comander := CreateHuman ;
8403: LD_ADDR_EXP 46
8407: PUSH
8408: CALL_OW 44
8412: ST_TO_ADDR
// uc_side := 3 ;
8413: LD_ADDR_OWVAR 20
8417: PUSH
8418: LD_INT 3
8420: ST_TO_ADDR
// uc_nation := 3 ;
8421: LD_ADDR_OWVAR 21
8425: PUSH
8426: LD_INT 3
8428: ST_TO_ADDR
// ru_comander := CreateHuman ;
8429: LD_ADDR_EXP 47
8433: PUSH
8434: CALL_OW 44
8438: ST_TO_ADDR
// uc_side := 2 ;
8439: LD_ADDR_OWVAR 20
8443: PUSH
8444: LD_INT 2
8446: ST_TO_ADDR
// uc_nation := 2 ;
8447: LD_ADDR_OWVAR 21
8451: PUSH
8452: LD_INT 2
8454: ST_TO_ADDR
// hc_name := Heike Steyer ;
8455: LD_ADDR_OWVAR 26
8459: PUSH
8460: LD_STRING Heike Steyer
8462: ST_TO_ADDR
// hc_sex := sex_female ;
8463: LD_ADDR_OWVAR 27
8467: PUSH
8468: LD_INT 2
8470: ST_TO_ADDR
// hc_gallery := sandar ;
8471: LD_ADDR_OWVAR 33
8475: PUSH
8476: LD_STRING sandar
8478: ST_TO_ADDR
// hc_face_number := 14 ;
8479: LD_ADDR_OWVAR 34
8483: PUSH
8484: LD_INT 14
8486: ST_TO_ADDR
// ar_comander := CreateHuman ;
8487: LD_ADDR_EXP 48
8491: PUSH
8492: CALL_OW 44
8496: ST_TO_ADDR
// end ;
8497: LD_VAR 0 1
8501: RET
// export function SpeedFilter ( filter , speed ) ; var list , i ; begin
8502: LD_INT 0
8504: PPUSH
8505: PPUSH
8506: PPUSH
// list := [ ] ;
8507: LD_ADDR_VAR 0 4
8511: PUSH
8512: EMPTY
8513: ST_TO_ADDR
// for i = 1 to filter do
8514: LD_ADDR_VAR 0 5
8518: PUSH
8519: DOUBLE
8520: LD_INT 1
8522: DEC
8523: ST_TO_ADDR
8524: LD_VAR 0 1
8528: PUSH
8529: FOR_TO
8530: IFFALSE 8579
// if GetSpeed ( filter [ i ] ) < speed then
8532: LD_VAR 0 1
8536: PUSH
8537: LD_VAR 0 5
8541: ARRAY
8542: PPUSH
8543: CALL 7842 0 1
8547: PUSH
8548: LD_VAR 0 2
8552: LESS
8553: IFFALSE 8577
// list := list ^ filter [ i ] ;
8555: LD_ADDR_VAR 0 4
8559: PUSH
8560: LD_VAR 0 4
8564: PUSH
8565: LD_VAR 0 1
8569: PUSH
8570: LD_VAR 0 5
8574: ARRAY
8575: ADD
8576: ST_TO_ADDR
8577: GO 8529
8579: POP
8580: POP
// result := list ;
8581: LD_ADDR_VAR 0 3
8585: PUSH
8586: LD_VAR 0 4
8590: ST_TO_ADDR
// end ; end_of_file
8591: LD_VAR 0 3
8595: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; every 1 do
8596: GO 8598
8598: DISABLE
// begin ru_radar := 98 ;
8599: LD_ADDR_EXP 52
8603: PUSH
8604: LD_INT 98
8606: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
8607: LD_ADDR_EXP 53
8611: PUSH
8612: LD_INT 89
8614: ST_TO_ADDR
// us_hack := 99 ;
8615: LD_ADDR_EXP 54
8619: PUSH
8620: LD_INT 99
8622: ST_TO_ADDR
// us_artillery := 97 ;
8623: LD_ADDR_EXP 55
8627: PUSH
8628: LD_INT 97
8630: ST_TO_ADDR
// ar_bio_bomb := 91 ;
8631: LD_ADDR_EXP 56
8635: PUSH
8636: LD_INT 91
8638: ST_TO_ADDR
// end ; end_of_file end_of_file
8639: END
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger ; every 0 0$1 do
8640: GO 8642
8642: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
8643: LD_STRING initStreamRollete();
8645: PPUSH
8646: CALL_OW 559
// InitStreamMode ;
8650: CALL 8659 0 0
// DefineStreamItems ( ) ;
8654: CALL 9099 0 0
// end ;
8658: END
// function InitStreamMode ; begin
8659: LD_INT 0
8661: PPUSH
// streamModeActive := false ;
8662: LD_ADDR_EXP 57
8666: PUSH
8667: LD_INT 0
8669: ST_TO_ADDR
// normalCounter := 26 ;
8670: LD_ADDR_EXP 58
8674: PUSH
8675: LD_INT 26
8677: ST_TO_ADDR
// hardcoreCounter := 12 ;
8678: LD_ADDR_EXP 59
8682: PUSH
8683: LD_INT 12
8685: ST_TO_ADDR
// sRocket := false ;
8686: LD_ADDR_EXP 62
8690: PUSH
8691: LD_INT 0
8693: ST_TO_ADDR
// sSpeed := false ;
8694: LD_ADDR_EXP 61
8698: PUSH
8699: LD_INT 0
8701: ST_TO_ADDR
// sEngine := false ;
8702: LD_ADDR_EXP 63
8706: PUSH
8707: LD_INT 0
8709: ST_TO_ADDR
// sSpec := false ;
8710: LD_ADDR_EXP 60
8714: PUSH
8715: LD_INT 0
8717: ST_TO_ADDR
// sLevel := false ;
8718: LD_ADDR_EXP 64
8722: PUSH
8723: LD_INT 0
8725: ST_TO_ADDR
// sArmoury := false ;
8726: LD_ADDR_EXP 65
8730: PUSH
8731: LD_INT 0
8733: ST_TO_ADDR
// sRadar := false ;
8734: LD_ADDR_EXP 66
8738: PUSH
8739: LD_INT 0
8741: ST_TO_ADDR
// sBunker := false ;
8742: LD_ADDR_EXP 67
8746: PUSH
8747: LD_INT 0
8749: ST_TO_ADDR
// sHack := false ;
8750: LD_ADDR_EXP 68
8754: PUSH
8755: LD_INT 0
8757: ST_TO_ADDR
// sFire := false ;
8758: LD_ADDR_EXP 69
8762: PUSH
8763: LD_INT 0
8765: ST_TO_ADDR
// sRefresh := false ;
8766: LD_ADDR_EXP 70
8770: PUSH
8771: LD_INT 0
8773: ST_TO_ADDR
// sExp := false ;
8774: LD_ADDR_EXP 71
8778: PUSH
8779: LD_INT 0
8781: ST_TO_ADDR
// sDepot := false ;
8782: LD_ADDR_EXP 72
8786: PUSH
8787: LD_INT 0
8789: ST_TO_ADDR
// sFlag := false ;
8790: LD_ADDR_EXP 73
8794: PUSH
8795: LD_INT 0
8797: ST_TO_ADDR
// sKamikadze := false ;
8798: LD_ADDR_EXP 81
8802: PUSH
8803: LD_INT 0
8805: ST_TO_ADDR
// sTroll := false ;
8806: LD_ADDR_EXP 82
8810: PUSH
8811: LD_INT 0
8813: ST_TO_ADDR
// sSlow := false ;
8814: LD_ADDR_EXP 83
8818: PUSH
8819: LD_INT 0
8821: ST_TO_ADDR
// sLack := false ;
8822: LD_ADDR_EXP 84
8826: PUSH
8827: LD_INT 0
8829: ST_TO_ADDR
// sTank := false ;
8830: LD_ADDR_EXP 86
8834: PUSH
8835: LD_INT 0
8837: ST_TO_ADDR
// sRemote := false ;
8838: LD_ADDR_EXP 87
8842: PUSH
8843: LD_INT 0
8845: ST_TO_ADDR
// sPowell := false ;
8846: LD_ADDR_EXP 88
8850: PUSH
8851: LD_INT 0
8853: ST_TO_ADDR
// sTeleport := false ;
8854: LD_ADDR_EXP 91
8858: PUSH
8859: LD_INT 0
8861: ST_TO_ADDR
// sOilTower := false ;
8862: LD_ADDR_EXP 93
8866: PUSH
8867: LD_INT 0
8869: ST_TO_ADDR
// sShovel := false ;
8870: LD_ADDR_EXP 94
8874: PUSH
8875: LD_INT 0
8877: ST_TO_ADDR
// sSheik := false ;
8878: LD_ADDR_EXP 95
8882: PUSH
8883: LD_INT 0
8885: ST_TO_ADDR
// sEarthquake := false ;
8886: LD_ADDR_EXP 97
8890: PUSH
8891: LD_INT 0
8893: ST_TO_ADDR
// sAI := false ;
8894: LD_ADDR_EXP 98
8898: PUSH
8899: LD_INT 0
8901: ST_TO_ADDR
// sCargo := false ;
8902: LD_ADDR_EXP 101
8906: PUSH
8907: LD_INT 0
8909: ST_TO_ADDR
// sDLaser := false ;
8910: LD_ADDR_EXP 102
8914: PUSH
8915: LD_INT 0
8917: ST_TO_ADDR
// sExchange := false ;
8918: LD_ADDR_EXP 103
8922: PUSH
8923: LD_INT 0
8925: ST_TO_ADDR
// sFac := false ;
8926: LD_ADDR_EXP 104
8930: PUSH
8931: LD_INT 0
8933: ST_TO_ADDR
// sPower := false ;
8934: LD_ADDR_EXP 105
8938: PUSH
8939: LD_INT 0
8941: ST_TO_ADDR
// sRandom := false ;
8942: LD_ADDR_EXP 106
8946: PUSH
8947: LD_INT 0
8949: ST_TO_ADDR
// sShield := false ;
8950: LD_ADDR_EXP 107
8954: PUSH
8955: LD_INT 0
8957: ST_TO_ADDR
// sTime := false ;
8958: LD_ADDR_EXP 108
8962: PUSH
8963: LD_INT 0
8965: ST_TO_ADDR
// sTools := false ;
8966: LD_ADDR_EXP 109
8970: PUSH
8971: LD_INT 0
8973: ST_TO_ADDR
// sSold := false ;
8974: LD_ADDR_EXP 74
8978: PUSH
8979: LD_INT 0
8981: ST_TO_ADDR
// sDiff := false ;
8982: LD_ADDR_EXP 75
8986: PUSH
8987: LD_INT 0
8989: ST_TO_ADDR
// sFog := false ;
8990: LD_ADDR_EXP 78
8994: PUSH
8995: LD_INT 0
8997: ST_TO_ADDR
// sReset := false ;
8998: LD_ADDR_EXP 79
9002: PUSH
9003: LD_INT 0
9005: ST_TO_ADDR
// sSun := false ;
9006: LD_ADDR_EXP 80
9010: PUSH
9011: LD_INT 0
9013: ST_TO_ADDR
// sTiger := false ;
9014: LD_ADDR_EXP 76
9018: PUSH
9019: LD_INT 0
9021: ST_TO_ADDR
// sBomb := false ;
9022: LD_ADDR_EXP 77
9026: PUSH
9027: LD_INT 0
9029: ST_TO_ADDR
// sWound := false ;
9030: LD_ADDR_EXP 85
9034: PUSH
9035: LD_INT 0
9037: ST_TO_ADDR
// sBetray := false ;
9038: LD_ADDR_EXP 89
9042: PUSH
9043: LD_INT 0
9045: ST_TO_ADDR
// sContamin := false ;
9046: LD_ADDR_EXP 90
9050: PUSH
9051: LD_INT 0
9053: ST_TO_ADDR
// sOil := false ;
9054: LD_ADDR_EXP 92
9058: PUSH
9059: LD_INT 0
9061: ST_TO_ADDR
// sStu := false ;
9062: LD_ADDR_EXP 96
9066: PUSH
9067: LD_INT 0
9069: ST_TO_ADDR
// sBazooka := false ;
9070: LD_ADDR_EXP 99
9074: PUSH
9075: LD_INT 0
9077: ST_TO_ADDR
// sMortar := false ;
9078: LD_ADDR_EXP 100
9082: PUSH
9083: LD_INT 0
9085: ST_TO_ADDR
// sRanger := false ;
9086: LD_ADDR_EXP 110
9090: PUSH
9091: LD_INT 0
9093: ST_TO_ADDR
// end ;
9094: LD_VAR 0 1
9098: RET
// function DefineStreamItems ( ) ; var tmp , normal , hardcore , i ; begin
9099: LD_INT 0
9101: PPUSH
9102: PPUSH
9103: PPUSH
9104: PPUSH
9105: PPUSH
// result := [ ] ;
9106: LD_ADDR_VAR 0 1
9110: PUSH
9111: EMPTY
9112: ST_TO_ADDR
// if campaign_id = 1 then
9113: LD_OWVAR 69
9117: PUSH
9118: LD_INT 1
9120: EQUAL
9121: IFFALSE 12057
// begin case mission_number of 1 :
9123: LD_OWVAR 70
9127: PUSH
9128: LD_INT 1
9130: DOUBLE
9131: EQUAL
9132: IFTRUE 9136
9134: GO 9200
9136: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 ] ] ; 2 :
9137: LD_ADDR_VAR 0 1
9141: PUSH
9142: LD_INT 2
9144: PUSH
9145: LD_INT 4
9147: PUSH
9148: LD_INT 11
9150: PUSH
9151: LD_INT 12
9153: PUSH
9154: LD_INT 15
9156: PUSH
9157: LD_INT 16
9159: PUSH
9160: LD_INT 22
9162: PUSH
9163: LD_INT 23
9165: PUSH
9166: LD_INT 26
9168: PUSH
9169: EMPTY
9170: LIST
9171: LIST
9172: LIST
9173: LIST
9174: LIST
9175: LIST
9176: LIST
9177: LIST
9178: LIST
9179: PUSH
9180: LD_INT 101
9182: PUSH
9183: LD_INT 102
9185: PUSH
9186: LD_INT 106
9188: PUSH
9189: EMPTY
9190: LIST
9191: LIST
9192: LIST
9193: PUSH
9194: EMPTY
9195: LIST
9196: LIST
9197: ST_TO_ADDR
9198: GO 12057
9200: LD_INT 2
9202: DOUBLE
9203: EQUAL
9204: IFTRUE 9208
9206: GO 9280
9208: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 3 :
9209: LD_ADDR_VAR 0 1
9213: PUSH
9214: LD_INT 2
9216: PUSH
9217: LD_INT 4
9219: PUSH
9220: LD_INT 11
9222: PUSH
9223: LD_INT 12
9225: PUSH
9226: LD_INT 15
9228: PUSH
9229: LD_INT 16
9231: PUSH
9232: LD_INT 22
9234: PUSH
9235: LD_INT 23
9237: PUSH
9238: LD_INT 26
9240: PUSH
9241: EMPTY
9242: LIST
9243: LIST
9244: LIST
9245: LIST
9246: LIST
9247: LIST
9248: LIST
9249: LIST
9250: LIST
9251: PUSH
9252: LD_INT 101
9254: PUSH
9255: LD_INT 102
9257: PUSH
9258: LD_INT 105
9260: PUSH
9261: LD_INT 106
9263: PUSH
9264: LD_INT 108
9266: PUSH
9267: EMPTY
9268: LIST
9269: LIST
9270: LIST
9271: LIST
9272: LIST
9273: PUSH
9274: EMPTY
9275: LIST
9276: LIST
9277: ST_TO_ADDR
9278: GO 12057
9280: LD_INT 3
9282: DOUBLE
9283: EQUAL
9284: IFTRUE 9288
9286: GO 9364
9288: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 4 :
9289: LD_ADDR_VAR 0 1
9293: PUSH
9294: LD_INT 2
9296: PUSH
9297: LD_INT 4
9299: PUSH
9300: LD_INT 5
9302: PUSH
9303: LD_INT 11
9305: PUSH
9306: LD_INT 12
9308: PUSH
9309: LD_INT 15
9311: PUSH
9312: LD_INT 16
9314: PUSH
9315: LD_INT 22
9317: PUSH
9318: LD_INT 26
9320: PUSH
9321: LD_INT 36
9323: PUSH
9324: EMPTY
9325: LIST
9326: LIST
9327: LIST
9328: LIST
9329: LIST
9330: LIST
9331: LIST
9332: LIST
9333: LIST
9334: LIST
9335: PUSH
9336: LD_INT 101
9338: PUSH
9339: LD_INT 102
9341: PUSH
9342: LD_INT 105
9344: PUSH
9345: LD_INT 106
9347: PUSH
9348: LD_INT 108
9350: PUSH
9351: EMPTY
9352: LIST
9353: LIST
9354: LIST
9355: LIST
9356: LIST
9357: PUSH
9358: EMPTY
9359: LIST
9360: LIST
9361: ST_TO_ADDR
9362: GO 12057
9364: LD_INT 4
9366: DOUBLE
9367: EQUAL
9368: IFTRUE 9372
9370: GO 9456
9372: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 5 :
9373: LD_ADDR_VAR 0 1
9377: PUSH
9378: LD_INT 2
9380: PUSH
9381: LD_INT 4
9383: PUSH
9384: LD_INT 5
9386: PUSH
9387: LD_INT 8
9389: PUSH
9390: LD_INT 11
9392: PUSH
9393: LD_INT 12
9395: PUSH
9396: LD_INT 15
9398: PUSH
9399: LD_INT 16
9401: PUSH
9402: LD_INT 22
9404: PUSH
9405: LD_INT 23
9407: PUSH
9408: LD_INT 26
9410: PUSH
9411: LD_INT 36
9413: PUSH
9414: EMPTY
9415: LIST
9416: LIST
9417: LIST
9418: LIST
9419: LIST
9420: LIST
9421: LIST
9422: LIST
9423: LIST
9424: LIST
9425: LIST
9426: LIST
9427: PUSH
9428: LD_INT 101
9430: PUSH
9431: LD_INT 102
9433: PUSH
9434: LD_INT 105
9436: PUSH
9437: LD_INT 106
9439: PUSH
9440: LD_INT 108
9442: PUSH
9443: EMPTY
9444: LIST
9445: LIST
9446: LIST
9447: LIST
9448: LIST
9449: PUSH
9450: EMPTY
9451: LIST
9452: LIST
9453: ST_TO_ADDR
9454: GO 12057
9456: LD_INT 5
9458: DOUBLE
9459: EQUAL
9460: IFTRUE 9464
9462: GO 9564
9464: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 6 :
9465: LD_ADDR_VAR 0 1
9469: PUSH
9470: LD_INT 2
9472: PUSH
9473: LD_INT 4
9475: PUSH
9476: LD_INT 5
9478: PUSH
9479: LD_INT 6
9481: PUSH
9482: LD_INT 8
9484: PUSH
9485: LD_INT 11
9487: PUSH
9488: LD_INT 12
9490: PUSH
9491: LD_INT 15
9493: PUSH
9494: LD_INT 16
9496: PUSH
9497: LD_INT 22
9499: PUSH
9500: LD_INT 23
9502: PUSH
9503: LD_INT 25
9505: PUSH
9506: LD_INT 26
9508: PUSH
9509: LD_INT 36
9511: PUSH
9512: EMPTY
9513: LIST
9514: LIST
9515: LIST
9516: LIST
9517: LIST
9518: LIST
9519: LIST
9520: LIST
9521: LIST
9522: LIST
9523: LIST
9524: LIST
9525: LIST
9526: LIST
9527: PUSH
9528: LD_INT 101
9530: PUSH
9531: LD_INT 102
9533: PUSH
9534: LD_INT 105
9536: PUSH
9537: LD_INT 106
9539: PUSH
9540: LD_INT 108
9542: PUSH
9543: LD_INT 109
9545: PUSH
9546: LD_INT 112
9548: PUSH
9549: EMPTY
9550: LIST
9551: LIST
9552: LIST
9553: LIST
9554: LIST
9555: LIST
9556: LIST
9557: PUSH
9558: EMPTY
9559: LIST
9560: LIST
9561: ST_TO_ADDR
9562: GO 12057
9564: LD_INT 6
9566: DOUBLE
9567: EQUAL
9568: IFTRUE 9572
9570: GO 9692
9572: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 7 :
9573: LD_ADDR_VAR 0 1
9577: PUSH
9578: LD_INT 2
9580: PUSH
9581: LD_INT 4
9583: PUSH
9584: LD_INT 5
9586: PUSH
9587: LD_INT 6
9589: PUSH
9590: LD_INT 8
9592: PUSH
9593: LD_INT 11
9595: PUSH
9596: LD_INT 12
9598: PUSH
9599: LD_INT 15
9601: PUSH
9602: LD_INT 16
9604: PUSH
9605: LD_INT 20
9607: PUSH
9608: LD_INT 21
9610: PUSH
9611: LD_INT 22
9613: PUSH
9614: LD_INT 23
9616: PUSH
9617: LD_INT 25
9619: PUSH
9620: LD_INT 26
9622: PUSH
9623: LD_INT 30
9625: PUSH
9626: LD_INT 31
9628: PUSH
9629: LD_INT 32
9631: PUSH
9632: LD_INT 36
9634: PUSH
9635: EMPTY
9636: LIST
9637: LIST
9638: LIST
9639: LIST
9640: LIST
9641: LIST
9642: LIST
9643: LIST
9644: LIST
9645: LIST
9646: LIST
9647: LIST
9648: LIST
9649: LIST
9650: LIST
9651: LIST
9652: LIST
9653: LIST
9654: LIST
9655: PUSH
9656: LD_INT 101
9658: PUSH
9659: LD_INT 102
9661: PUSH
9662: LD_INT 105
9664: PUSH
9665: LD_INT 106
9667: PUSH
9668: LD_INT 108
9670: PUSH
9671: LD_INT 109
9673: PUSH
9674: LD_INT 112
9676: PUSH
9677: EMPTY
9678: LIST
9679: LIST
9680: LIST
9681: LIST
9682: LIST
9683: LIST
9684: LIST
9685: PUSH
9686: EMPTY
9687: LIST
9688: LIST
9689: ST_TO_ADDR
9690: GO 12057
9692: LD_INT 7
9694: DOUBLE
9695: EQUAL
9696: IFTRUE 9700
9698: GO 9800
9700: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 ] ] ; 8 :
9701: LD_ADDR_VAR 0 1
9705: PUSH
9706: LD_INT 2
9708: PUSH
9709: LD_INT 4
9711: PUSH
9712: LD_INT 5
9714: PUSH
9715: LD_INT 7
9717: PUSH
9718: LD_INT 11
9720: PUSH
9721: LD_INT 12
9723: PUSH
9724: LD_INT 15
9726: PUSH
9727: LD_INT 16
9729: PUSH
9730: LD_INT 20
9732: PUSH
9733: LD_INT 21
9735: PUSH
9736: LD_INT 22
9738: PUSH
9739: LD_INT 23
9741: PUSH
9742: LD_INT 25
9744: PUSH
9745: LD_INT 26
9747: PUSH
9748: EMPTY
9749: LIST
9750: LIST
9751: LIST
9752: LIST
9753: LIST
9754: LIST
9755: LIST
9756: LIST
9757: LIST
9758: LIST
9759: LIST
9760: LIST
9761: LIST
9762: LIST
9763: PUSH
9764: LD_INT 101
9766: PUSH
9767: LD_INT 102
9769: PUSH
9770: LD_INT 103
9772: PUSH
9773: LD_INT 105
9775: PUSH
9776: LD_INT 106
9778: PUSH
9779: LD_INT 108
9781: PUSH
9782: LD_INT 112
9784: PUSH
9785: EMPTY
9786: LIST
9787: LIST
9788: LIST
9789: LIST
9790: LIST
9791: LIST
9792: LIST
9793: PUSH
9794: EMPTY
9795: LIST
9796: LIST
9797: ST_TO_ADDR
9798: GO 12057
9800: LD_INT 8
9802: DOUBLE
9803: EQUAL
9804: IFTRUE 9808
9806: GO 9936
9808: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 ] ] ; 9 :
9809: LD_ADDR_VAR 0 1
9813: PUSH
9814: LD_INT 2
9816: PUSH
9817: LD_INT 4
9819: PUSH
9820: LD_INT 5
9822: PUSH
9823: LD_INT 6
9825: PUSH
9826: LD_INT 7
9828: PUSH
9829: LD_INT 8
9831: PUSH
9832: LD_INT 11
9834: PUSH
9835: LD_INT 12
9837: PUSH
9838: LD_INT 15
9840: PUSH
9841: LD_INT 16
9843: PUSH
9844: LD_INT 20
9846: PUSH
9847: LD_INT 21
9849: PUSH
9850: LD_INT 22
9852: PUSH
9853: LD_INT 23
9855: PUSH
9856: LD_INT 25
9858: PUSH
9859: LD_INT 26
9861: PUSH
9862: LD_INT 30
9864: PUSH
9865: LD_INT 31
9867: PUSH
9868: LD_INT 32
9870: PUSH
9871: LD_INT 36
9873: PUSH
9874: EMPTY
9875: LIST
9876: LIST
9877: LIST
9878: LIST
9879: LIST
9880: LIST
9881: LIST
9882: LIST
9883: LIST
9884: LIST
9885: LIST
9886: LIST
9887: LIST
9888: LIST
9889: LIST
9890: LIST
9891: LIST
9892: LIST
9893: LIST
9894: LIST
9895: PUSH
9896: LD_INT 101
9898: PUSH
9899: LD_INT 102
9901: PUSH
9902: LD_INT 103
9904: PUSH
9905: LD_INT 105
9907: PUSH
9908: LD_INT 106
9910: PUSH
9911: LD_INT 108
9913: PUSH
9914: LD_INT 109
9916: PUSH
9917: LD_INT 112
9919: PUSH
9920: EMPTY
9921: LIST
9922: LIST
9923: LIST
9924: LIST
9925: LIST
9926: LIST
9927: LIST
9928: LIST
9929: PUSH
9930: EMPTY
9931: LIST
9932: LIST
9933: ST_TO_ADDR
9934: GO 12057
9936: LD_INT 9
9938: DOUBLE
9939: EQUAL
9940: IFTRUE 9944
9942: GO 10080
9944: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 ] ] ; 10 :
9945: LD_ADDR_VAR 0 1
9949: PUSH
9950: LD_INT 2
9952: PUSH
9953: LD_INT 4
9955: PUSH
9956: LD_INT 5
9958: PUSH
9959: LD_INT 6
9961: PUSH
9962: LD_INT 7
9964: PUSH
9965: LD_INT 8
9967: PUSH
9968: LD_INT 11
9970: PUSH
9971: LD_INT 12
9973: PUSH
9974: LD_INT 15
9976: PUSH
9977: LD_INT 16
9979: PUSH
9980: LD_INT 20
9982: PUSH
9983: LD_INT 21
9985: PUSH
9986: LD_INT 22
9988: PUSH
9989: LD_INT 23
9991: PUSH
9992: LD_INT 25
9994: PUSH
9995: LD_INT 26
9997: PUSH
9998: LD_INT 28
10000: PUSH
10001: LD_INT 30
10003: PUSH
10004: LD_INT 31
10006: PUSH
10007: LD_INT 32
10009: PUSH
10010: LD_INT 36
10012: PUSH
10013: EMPTY
10014: LIST
10015: LIST
10016: LIST
10017: LIST
10018: LIST
10019: LIST
10020: LIST
10021: LIST
10022: LIST
10023: LIST
10024: LIST
10025: LIST
10026: LIST
10027: LIST
10028: LIST
10029: LIST
10030: LIST
10031: LIST
10032: LIST
10033: LIST
10034: LIST
10035: PUSH
10036: LD_INT 101
10038: PUSH
10039: LD_INT 102
10041: PUSH
10042: LD_INT 103
10044: PUSH
10045: LD_INT 105
10047: PUSH
10048: LD_INT 106
10050: PUSH
10051: LD_INT 108
10053: PUSH
10054: LD_INT 109
10056: PUSH
10057: LD_INT 112
10059: PUSH
10060: LD_INT 114
10062: PUSH
10063: EMPTY
10064: LIST
10065: LIST
10066: LIST
10067: LIST
10068: LIST
10069: LIST
10070: LIST
10071: LIST
10072: LIST
10073: PUSH
10074: EMPTY
10075: LIST
10076: LIST
10077: ST_TO_ADDR
10078: GO 12057
10080: LD_INT 10
10082: DOUBLE
10083: EQUAL
10084: IFTRUE 10088
10086: GO 10272
10088: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 11 :
10089: LD_ADDR_VAR 0 1
10093: PUSH
10094: LD_INT 2
10096: PUSH
10097: LD_INT 4
10099: PUSH
10100: LD_INT 5
10102: PUSH
10103: LD_INT 6
10105: PUSH
10106: LD_INT 7
10108: PUSH
10109: LD_INT 8
10111: PUSH
10112: LD_INT 9
10114: PUSH
10115: LD_INT 10
10117: PUSH
10118: LD_INT 11
10120: PUSH
10121: LD_INT 12
10123: PUSH
10124: LD_INT 13
10126: PUSH
10127: LD_INT 14
10129: PUSH
10130: LD_INT 15
10132: PUSH
10133: LD_INT 16
10135: PUSH
10136: LD_INT 17
10138: PUSH
10139: LD_INT 18
10141: PUSH
10142: LD_INT 19
10144: PUSH
10145: LD_INT 20
10147: PUSH
10148: LD_INT 21
10150: PUSH
10151: LD_INT 22
10153: PUSH
10154: LD_INT 23
10156: PUSH
10157: LD_INT 24
10159: PUSH
10160: LD_INT 25
10162: PUSH
10163: LD_INT 26
10165: PUSH
10166: LD_INT 28
10168: PUSH
10169: LD_INT 30
10171: PUSH
10172: LD_INT 31
10174: PUSH
10175: LD_INT 32
10177: PUSH
10178: LD_INT 36
10180: PUSH
10181: EMPTY
10182: LIST
10183: LIST
10184: LIST
10185: LIST
10186: LIST
10187: LIST
10188: LIST
10189: LIST
10190: LIST
10191: LIST
10192: LIST
10193: LIST
10194: LIST
10195: LIST
10196: LIST
10197: LIST
10198: LIST
10199: LIST
10200: LIST
10201: LIST
10202: LIST
10203: LIST
10204: LIST
10205: LIST
10206: LIST
10207: LIST
10208: LIST
10209: LIST
10210: LIST
10211: PUSH
10212: LD_INT 101
10214: PUSH
10215: LD_INT 102
10217: PUSH
10218: LD_INT 103
10220: PUSH
10221: LD_INT 104
10223: PUSH
10224: LD_INT 105
10226: PUSH
10227: LD_INT 106
10229: PUSH
10230: LD_INT 107
10232: PUSH
10233: LD_INT 108
10235: PUSH
10236: LD_INT 109
10238: PUSH
10239: LD_INT 110
10241: PUSH
10242: LD_INT 111
10244: PUSH
10245: LD_INT 112
10247: PUSH
10248: LD_INT 114
10250: PUSH
10251: EMPTY
10252: LIST
10253: LIST
10254: LIST
10255: LIST
10256: LIST
10257: LIST
10258: LIST
10259: LIST
10260: LIST
10261: LIST
10262: LIST
10263: LIST
10264: LIST
10265: PUSH
10266: EMPTY
10267: LIST
10268: LIST
10269: ST_TO_ADDR
10270: GO 12057
10272: LD_INT 11
10274: DOUBLE
10275: EQUAL
10276: IFTRUE 10280
10278: GO 10472
10280: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 12 :
10281: LD_ADDR_VAR 0 1
10285: PUSH
10286: LD_INT 2
10288: PUSH
10289: LD_INT 3
10291: PUSH
10292: LD_INT 4
10294: PUSH
10295: LD_INT 5
10297: PUSH
10298: LD_INT 6
10300: PUSH
10301: LD_INT 7
10303: PUSH
10304: LD_INT 8
10306: PUSH
10307: LD_INT 9
10309: PUSH
10310: LD_INT 10
10312: PUSH
10313: LD_INT 11
10315: PUSH
10316: LD_INT 12
10318: PUSH
10319: LD_INT 13
10321: PUSH
10322: LD_INT 14
10324: PUSH
10325: LD_INT 15
10327: PUSH
10328: LD_INT 16
10330: PUSH
10331: LD_INT 17
10333: PUSH
10334: LD_INT 18
10336: PUSH
10337: LD_INT 19
10339: PUSH
10340: LD_INT 20
10342: PUSH
10343: LD_INT 21
10345: PUSH
10346: LD_INT 22
10348: PUSH
10349: LD_INT 23
10351: PUSH
10352: LD_INT 24
10354: PUSH
10355: LD_INT 25
10357: PUSH
10358: LD_INT 26
10360: PUSH
10361: LD_INT 28
10363: PUSH
10364: LD_INT 30
10366: PUSH
10367: LD_INT 31
10369: PUSH
10370: LD_INT 32
10372: PUSH
10373: LD_INT 34
10375: PUSH
10376: LD_INT 36
10378: PUSH
10379: EMPTY
10380: LIST
10381: LIST
10382: LIST
10383: LIST
10384: LIST
10385: LIST
10386: LIST
10387: LIST
10388: LIST
10389: LIST
10390: LIST
10391: LIST
10392: LIST
10393: LIST
10394: LIST
10395: LIST
10396: LIST
10397: LIST
10398: LIST
10399: LIST
10400: LIST
10401: LIST
10402: LIST
10403: LIST
10404: LIST
10405: LIST
10406: LIST
10407: LIST
10408: LIST
10409: LIST
10410: LIST
10411: PUSH
10412: LD_INT 101
10414: PUSH
10415: LD_INT 102
10417: PUSH
10418: LD_INT 103
10420: PUSH
10421: LD_INT 104
10423: PUSH
10424: LD_INT 105
10426: PUSH
10427: LD_INT 106
10429: PUSH
10430: LD_INT 107
10432: PUSH
10433: LD_INT 108
10435: PUSH
10436: LD_INT 109
10438: PUSH
10439: LD_INT 110
10441: PUSH
10442: LD_INT 111
10444: PUSH
10445: LD_INT 112
10447: PUSH
10448: LD_INT 114
10450: PUSH
10451: EMPTY
10452: LIST
10453: LIST
10454: LIST
10455: LIST
10456: LIST
10457: LIST
10458: LIST
10459: LIST
10460: LIST
10461: LIST
10462: LIST
10463: LIST
10464: LIST
10465: PUSH
10466: EMPTY
10467: LIST
10468: LIST
10469: ST_TO_ADDR
10470: GO 12057
10472: LD_INT 12
10474: DOUBLE
10475: EQUAL
10476: IFTRUE 10480
10478: GO 10688
10480: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 13 :
10481: LD_ADDR_VAR 0 1
10485: PUSH
10486: LD_INT 1
10488: PUSH
10489: LD_INT 2
10491: PUSH
10492: LD_INT 3
10494: PUSH
10495: LD_INT 4
10497: PUSH
10498: LD_INT 5
10500: PUSH
10501: LD_INT 6
10503: PUSH
10504: LD_INT 7
10506: PUSH
10507: LD_INT 8
10509: PUSH
10510: LD_INT 9
10512: PUSH
10513: LD_INT 10
10515: PUSH
10516: LD_INT 11
10518: PUSH
10519: LD_INT 12
10521: PUSH
10522: LD_INT 13
10524: PUSH
10525: LD_INT 14
10527: PUSH
10528: LD_INT 15
10530: PUSH
10531: LD_INT 16
10533: PUSH
10534: LD_INT 17
10536: PUSH
10537: LD_INT 18
10539: PUSH
10540: LD_INT 19
10542: PUSH
10543: LD_INT 20
10545: PUSH
10546: LD_INT 21
10548: PUSH
10549: LD_INT 22
10551: PUSH
10552: LD_INT 23
10554: PUSH
10555: LD_INT 24
10557: PUSH
10558: LD_INT 25
10560: PUSH
10561: LD_INT 26
10563: PUSH
10564: LD_INT 27
10566: PUSH
10567: LD_INT 28
10569: PUSH
10570: LD_INT 30
10572: PUSH
10573: LD_INT 31
10575: PUSH
10576: LD_INT 32
10578: PUSH
10579: LD_INT 33
10581: PUSH
10582: LD_INT 34
10584: PUSH
10585: LD_INT 36
10587: PUSH
10588: EMPTY
10589: LIST
10590: LIST
10591: LIST
10592: LIST
10593: LIST
10594: LIST
10595: LIST
10596: LIST
10597: LIST
10598: LIST
10599: LIST
10600: LIST
10601: LIST
10602: LIST
10603: LIST
10604: LIST
10605: LIST
10606: LIST
10607: LIST
10608: LIST
10609: LIST
10610: LIST
10611: LIST
10612: LIST
10613: LIST
10614: LIST
10615: LIST
10616: LIST
10617: LIST
10618: LIST
10619: LIST
10620: LIST
10621: LIST
10622: LIST
10623: PUSH
10624: LD_INT 101
10626: PUSH
10627: LD_INT 102
10629: PUSH
10630: LD_INT 103
10632: PUSH
10633: LD_INT 104
10635: PUSH
10636: LD_INT 105
10638: PUSH
10639: LD_INT 106
10641: PUSH
10642: LD_INT 107
10644: PUSH
10645: LD_INT 108
10647: PUSH
10648: LD_INT 109
10650: PUSH
10651: LD_INT 110
10653: PUSH
10654: LD_INT 111
10656: PUSH
10657: LD_INT 112
10659: PUSH
10660: LD_INT 113
10662: PUSH
10663: LD_INT 114
10665: PUSH
10666: EMPTY
10667: LIST
10668: LIST
10669: LIST
10670: LIST
10671: LIST
10672: LIST
10673: LIST
10674: LIST
10675: LIST
10676: LIST
10677: LIST
10678: LIST
10679: LIST
10680: LIST
10681: PUSH
10682: EMPTY
10683: LIST
10684: LIST
10685: ST_TO_ADDR
10686: GO 12057
10688: LD_INT 13
10690: DOUBLE
10691: EQUAL
10692: IFTRUE 10696
10694: GO 10892
10696: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 14 :
10697: LD_ADDR_VAR 0 1
10701: PUSH
10702: LD_INT 1
10704: PUSH
10705: LD_INT 2
10707: PUSH
10708: LD_INT 3
10710: PUSH
10711: LD_INT 4
10713: PUSH
10714: LD_INT 5
10716: PUSH
10717: LD_INT 8
10719: PUSH
10720: LD_INT 9
10722: PUSH
10723: LD_INT 10
10725: PUSH
10726: LD_INT 11
10728: PUSH
10729: LD_INT 12
10731: PUSH
10732: LD_INT 14
10734: PUSH
10735: LD_INT 15
10737: PUSH
10738: LD_INT 16
10740: PUSH
10741: LD_INT 17
10743: PUSH
10744: LD_INT 18
10746: PUSH
10747: LD_INT 19
10749: PUSH
10750: LD_INT 20
10752: PUSH
10753: LD_INT 21
10755: PUSH
10756: LD_INT 22
10758: PUSH
10759: LD_INT 23
10761: PUSH
10762: LD_INT 24
10764: PUSH
10765: LD_INT 25
10767: PUSH
10768: LD_INT 26
10770: PUSH
10771: LD_INT 27
10773: PUSH
10774: LD_INT 28
10776: PUSH
10777: LD_INT 30
10779: PUSH
10780: LD_INT 31
10782: PUSH
10783: LD_INT 32
10785: PUSH
10786: LD_INT 33
10788: PUSH
10789: LD_INT 34
10791: PUSH
10792: LD_INT 36
10794: PUSH
10795: EMPTY
10796: LIST
10797: LIST
10798: LIST
10799: LIST
10800: LIST
10801: LIST
10802: LIST
10803: LIST
10804: LIST
10805: LIST
10806: LIST
10807: LIST
10808: LIST
10809: LIST
10810: LIST
10811: LIST
10812: LIST
10813: LIST
10814: LIST
10815: LIST
10816: LIST
10817: LIST
10818: LIST
10819: LIST
10820: LIST
10821: LIST
10822: LIST
10823: LIST
10824: LIST
10825: LIST
10826: LIST
10827: PUSH
10828: LD_INT 101
10830: PUSH
10831: LD_INT 102
10833: PUSH
10834: LD_INT 103
10836: PUSH
10837: LD_INT 104
10839: PUSH
10840: LD_INT 105
10842: PUSH
10843: LD_INT 106
10845: PUSH
10846: LD_INT 107
10848: PUSH
10849: LD_INT 108
10851: PUSH
10852: LD_INT 109
10854: PUSH
10855: LD_INT 110
10857: PUSH
10858: LD_INT 111
10860: PUSH
10861: LD_INT 112
10863: PUSH
10864: LD_INT 113
10866: PUSH
10867: LD_INT 114
10869: PUSH
10870: EMPTY
10871: LIST
10872: LIST
10873: LIST
10874: LIST
10875: LIST
10876: LIST
10877: LIST
10878: LIST
10879: LIST
10880: LIST
10881: LIST
10882: LIST
10883: LIST
10884: LIST
10885: PUSH
10886: EMPTY
10887: LIST
10888: LIST
10889: ST_TO_ADDR
10890: GO 12057
10892: LD_INT 14
10894: DOUBLE
10895: EQUAL
10896: IFTRUE 10900
10898: GO 11112
10900: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 15 :
10901: LD_ADDR_VAR 0 1
10905: PUSH
10906: LD_INT 1
10908: PUSH
10909: LD_INT 2
10911: PUSH
10912: LD_INT 3
10914: PUSH
10915: LD_INT 4
10917: PUSH
10918: LD_INT 5
10920: PUSH
10921: LD_INT 6
10923: PUSH
10924: LD_INT 7
10926: PUSH
10927: LD_INT 8
10929: PUSH
10930: LD_INT 9
10932: PUSH
10933: LD_INT 10
10935: PUSH
10936: LD_INT 11
10938: PUSH
10939: LD_INT 12
10941: PUSH
10942: LD_INT 13
10944: PUSH
10945: LD_INT 14
10947: PUSH
10948: LD_INT 15
10950: PUSH
10951: LD_INT 16
10953: PUSH
10954: LD_INT 17
10956: PUSH
10957: LD_INT 18
10959: PUSH
10960: LD_INT 19
10962: PUSH
10963: LD_INT 20
10965: PUSH
10966: LD_INT 21
10968: PUSH
10969: LD_INT 22
10971: PUSH
10972: LD_INT 23
10974: PUSH
10975: LD_INT 24
10977: PUSH
10978: LD_INT 25
10980: PUSH
10981: LD_INT 26
10983: PUSH
10984: LD_INT 27
10986: PUSH
10987: LD_INT 28
10989: PUSH
10990: LD_INT 29
10992: PUSH
10993: LD_INT 30
10995: PUSH
10996: LD_INT 31
10998: PUSH
10999: LD_INT 32
11001: PUSH
11002: LD_INT 33
11004: PUSH
11005: LD_INT 34
11007: PUSH
11008: LD_INT 36
11010: PUSH
11011: EMPTY
11012: LIST
11013: LIST
11014: LIST
11015: LIST
11016: LIST
11017: LIST
11018: LIST
11019: LIST
11020: LIST
11021: LIST
11022: LIST
11023: LIST
11024: LIST
11025: LIST
11026: LIST
11027: LIST
11028: LIST
11029: LIST
11030: LIST
11031: LIST
11032: LIST
11033: LIST
11034: LIST
11035: LIST
11036: LIST
11037: LIST
11038: LIST
11039: LIST
11040: LIST
11041: LIST
11042: LIST
11043: LIST
11044: LIST
11045: LIST
11046: LIST
11047: PUSH
11048: LD_INT 101
11050: PUSH
11051: LD_INT 102
11053: PUSH
11054: LD_INT 103
11056: PUSH
11057: LD_INT 104
11059: PUSH
11060: LD_INT 105
11062: PUSH
11063: LD_INT 106
11065: PUSH
11066: LD_INT 107
11068: PUSH
11069: LD_INT 108
11071: PUSH
11072: LD_INT 109
11074: PUSH
11075: LD_INT 110
11077: PUSH
11078: LD_INT 111
11080: PUSH
11081: LD_INT 112
11083: PUSH
11084: LD_INT 113
11086: PUSH
11087: LD_INT 114
11089: PUSH
11090: EMPTY
11091: LIST
11092: LIST
11093: LIST
11094: LIST
11095: LIST
11096: LIST
11097: LIST
11098: LIST
11099: LIST
11100: LIST
11101: LIST
11102: LIST
11103: LIST
11104: LIST
11105: PUSH
11106: EMPTY
11107: LIST
11108: LIST
11109: ST_TO_ADDR
11110: GO 12057
11112: LD_INT 15
11114: DOUBLE
11115: EQUAL
11116: IFTRUE 11120
11118: GO 11332
11120: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 16 :
11121: LD_ADDR_VAR 0 1
11125: PUSH
11126: LD_INT 1
11128: PUSH
11129: LD_INT 2
11131: PUSH
11132: LD_INT 3
11134: PUSH
11135: LD_INT 4
11137: PUSH
11138: LD_INT 5
11140: PUSH
11141: LD_INT 6
11143: PUSH
11144: LD_INT 7
11146: PUSH
11147: LD_INT 8
11149: PUSH
11150: LD_INT 9
11152: PUSH
11153: LD_INT 10
11155: PUSH
11156: LD_INT 11
11158: PUSH
11159: LD_INT 12
11161: PUSH
11162: LD_INT 13
11164: PUSH
11165: LD_INT 14
11167: PUSH
11168: LD_INT 15
11170: PUSH
11171: LD_INT 16
11173: PUSH
11174: LD_INT 17
11176: PUSH
11177: LD_INT 18
11179: PUSH
11180: LD_INT 19
11182: PUSH
11183: LD_INT 20
11185: PUSH
11186: LD_INT 21
11188: PUSH
11189: LD_INT 22
11191: PUSH
11192: LD_INT 23
11194: PUSH
11195: LD_INT 24
11197: PUSH
11198: LD_INT 25
11200: PUSH
11201: LD_INT 26
11203: PUSH
11204: LD_INT 27
11206: PUSH
11207: LD_INT 28
11209: PUSH
11210: LD_INT 29
11212: PUSH
11213: LD_INT 30
11215: PUSH
11216: LD_INT 31
11218: PUSH
11219: LD_INT 32
11221: PUSH
11222: LD_INT 33
11224: PUSH
11225: LD_INT 34
11227: PUSH
11228: LD_INT 36
11230: PUSH
11231: EMPTY
11232: LIST
11233: LIST
11234: LIST
11235: LIST
11236: LIST
11237: LIST
11238: LIST
11239: LIST
11240: LIST
11241: LIST
11242: LIST
11243: LIST
11244: LIST
11245: LIST
11246: LIST
11247: LIST
11248: LIST
11249: LIST
11250: LIST
11251: LIST
11252: LIST
11253: LIST
11254: LIST
11255: LIST
11256: LIST
11257: LIST
11258: LIST
11259: LIST
11260: LIST
11261: LIST
11262: LIST
11263: LIST
11264: LIST
11265: LIST
11266: LIST
11267: PUSH
11268: LD_INT 101
11270: PUSH
11271: LD_INT 102
11273: PUSH
11274: LD_INT 103
11276: PUSH
11277: LD_INT 104
11279: PUSH
11280: LD_INT 105
11282: PUSH
11283: LD_INT 106
11285: PUSH
11286: LD_INT 107
11288: PUSH
11289: LD_INT 108
11291: PUSH
11292: LD_INT 109
11294: PUSH
11295: LD_INT 110
11297: PUSH
11298: LD_INT 111
11300: PUSH
11301: LD_INT 112
11303: PUSH
11304: LD_INT 113
11306: PUSH
11307: LD_INT 114
11309: PUSH
11310: EMPTY
11311: LIST
11312: LIST
11313: LIST
11314: LIST
11315: LIST
11316: LIST
11317: LIST
11318: LIST
11319: LIST
11320: LIST
11321: LIST
11322: LIST
11323: LIST
11324: LIST
11325: PUSH
11326: EMPTY
11327: LIST
11328: LIST
11329: ST_TO_ADDR
11330: GO 12057
11332: LD_INT 16
11334: DOUBLE
11335: EQUAL
11336: IFTRUE 11340
11338: GO 11464
11340: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 ] ] ; 17 :
11341: LD_ADDR_VAR 0 1
11345: PUSH
11346: LD_INT 2
11348: PUSH
11349: LD_INT 4
11351: PUSH
11352: LD_INT 5
11354: PUSH
11355: LD_INT 7
11357: PUSH
11358: LD_INT 11
11360: PUSH
11361: LD_INT 12
11363: PUSH
11364: LD_INT 15
11366: PUSH
11367: LD_INT 16
11369: PUSH
11370: LD_INT 20
11372: PUSH
11373: LD_INT 21
11375: PUSH
11376: LD_INT 22
11378: PUSH
11379: LD_INT 23
11381: PUSH
11382: LD_INT 25
11384: PUSH
11385: LD_INT 26
11387: PUSH
11388: LD_INT 30
11390: PUSH
11391: LD_INT 31
11393: PUSH
11394: LD_INT 32
11396: PUSH
11397: LD_INT 33
11399: PUSH
11400: LD_INT 34
11402: PUSH
11403: EMPTY
11404: LIST
11405: LIST
11406: LIST
11407: LIST
11408: LIST
11409: LIST
11410: LIST
11411: LIST
11412: LIST
11413: LIST
11414: LIST
11415: LIST
11416: LIST
11417: LIST
11418: LIST
11419: LIST
11420: LIST
11421: LIST
11422: LIST
11423: PUSH
11424: LD_INT 101
11426: PUSH
11427: LD_INT 102
11429: PUSH
11430: LD_INT 103
11432: PUSH
11433: LD_INT 106
11435: PUSH
11436: LD_INT 108
11438: PUSH
11439: LD_INT 112
11441: PUSH
11442: LD_INT 113
11444: PUSH
11445: LD_INT 114
11447: PUSH
11448: EMPTY
11449: LIST
11450: LIST
11451: LIST
11452: LIST
11453: LIST
11454: LIST
11455: LIST
11456: LIST
11457: PUSH
11458: EMPTY
11459: LIST
11460: LIST
11461: ST_TO_ADDR
11462: GO 12057
11464: LD_INT 17
11466: DOUBLE
11467: EQUAL
11468: IFTRUE 11472
11470: GO 11684
11472: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 18 :
11473: LD_ADDR_VAR 0 1
11477: PUSH
11478: LD_INT 1
11480: PUSH
11481: LD_INT 2
11483: PUSH
11484: LD_INT 3
11486: PUSH
11487: LD_INT 4
11489: PUSH
11490: LD_INT 5
11492: PUSH
11493: LD_INT 6
11495: PUSH
11496: LD_INT 7
11498: PUSH
11499: LD_INT 8
11501: PUSH
11502: LD_INT 9
11504: PUSH
11505: LD_INT 10
11507: PUSH
11508: LD_INT 11
11510: PUSH
11511: LD_INT 12
11513: PUSH
11514: LD_INT 13
11516: PUSH
11517: LD_INT 14
11519: PUSH
11520: LD_INT 15
11522: PUSH
11523: LD_INT 16
11525: PUSH
11526: LD_INT 17
11528: PUSH
11529: LD_INT 18
11531: PUSH
11532: LD_INT 19
11534: PUSH
11535: LD_INT 20
11537: PUSH
11538: LD_INT 21
11540: PUSH
11541: LD_INT 22
11543: PUSH
11544: LD_INT 23
11546: PUSH
11547: LD_INT 24
11549: PUSH
11550: LD_INT 25
11552: PUSH
11553: LD_INT 26
11555: PUSH
11556: LD_INT 27
11558: PUSH
11559: LD_INT 28
11561: PUSH
11562: LD_INT 29
11564: PUSH
11565: LD_INT 30
11567: PUSH
11568: LD_INT 31
11570: PUSH
11571: LD_INT 32
11573: PUSH
11574: LD_INT 33
11576: PUSH
11577: LD_INT 34
11579: PUSH
11580: LD_INT 36
11582: PUSH
11583: EMPTY
11584: LIST
11585: LIST
11586: LIST
11587: LIST
11588: LIST
11589: LIST
11590: LIST
11591: LIST
11592: LIST
11593: LIST
11594: LIST
11595: LIST
11596: LIST
11597: LIST
11598: LIST
11599: LIST
11600: LIST
11601: LIST
11602: LIST
11603: LIST
11604: LIST
11605: LIST
11606: LIST
11607: LIST
11608: LIST
11609: LIST
11610: LIST
11611: LIST
11612: LIST
11613: LIST
11614: LIST
11615: LIST
11616: LIST
11617: LIST
11618: LIST
11619: PUSH
11620: LD_INT 101
11622: PUSH
11623: LD_INT 102
11625: PUSH
11626: LD_INT 103
11628: PUSH
11629: LD_INT 104
11631: PUSH
11632: LD_INT 105
11634: PUSH
11635: LD_INT 106
11637: PUSH
11638: LD_INT 107
11640: PUSH
11641: LD_INT 108
11643: PUSH
11644: LD_INT 109
11646: PUSH
11647: LD_INT 110
11649: PUSH
11650: LD_INT 111
11652: PUSH
11653: LD_INT 112
11655: PUSH
11656: LD_INT 113
11658: PUSH
11659: LD_INT 114
11661: PUSH
11662: EMPTY
11663: LIST
11664: LIST
11665: LIST
11666: LIST
11667: LIST
11668: LIST
11669: LIST
11670: LIST
11671: LIST
11672: LIST
11673: LIST
11674: LIST
11675: LIST
11676: LIST
11677: PUSH
11678: EMPTY
11679: LIST
11680: LIST
11681: ST_TO_ADDR
11682: GO 12057
11684: LD_INT 18
11686: DOUBLE
11687: EQUAL
11688: IFTRUE 11692
11690: GO 11828
11692: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 ] ] ; 19 :
11693: LD_ADDR_VAR 0 1
11697: PUSH
11698: LD_INT 2
11700: PUSH
11701: LD_INT 4
11703: PUSH
11704: LD_INT 5
11706: PUSH
11707: LD_INT 7
11709: PUSH
11710: LD_INT 11
11712: PUSH
11713: LD_INT 12
11715: PUSH
11716: LD_INT 15
11718: PUSH
11719: LD_INT 16
11721: PUSH
11722: LD_INT 20
11724: PUSH
11725: LD_INT 21
11727: PUSH
11728: LD_INT 22
11730: PUSH
11731: LD_INT 23
11733: PUSH
11734: LD_INT 25
11736: PUSH
11737: LD_INT 26
11739: PUSH
11740: LD_INT 30
11742: PUSH
11743: LD_INT 31
11745: PUSH
11746: LD_INT 32
11748: PUSH
11749: LD_INT 33
11751: PUSH
11752: LD_INT 34
11754: PUSH
11755: LD_INT 35
11757: PUSH
11758: LD_INT 36
11760: PUSH
11761: EMPTY
11762: LIST
11763: LIST
11764: LIST
11765: LIST
11766: LIST
11767: LIST
11768: LIST
11769: LIST
11770: LIST
11771: LIST
11772: LIST
11773: LIST
11774: LIST
11775: LIST
11776: LIST
11777: LIST
11778: LIST
11779: LIST
11780: LIST
11781: LIST
11782: LIST
11783: PUSH
11784: LD_INT 101
11786: PUSH
11787: LD_INT 102
11789: PUSH
11790: LD_INT 103
11792: PUSH
11793: LD_INT 106
11795: PUSH
11796: LD_INT 108
11798: PUSH
11799: LD_INT 112
11801: PUSH
11802: LD_INT 113
11804: PUSH
11805: LD_INT 114
11807: PUSH
11808: LD_INT 115
11810: PUSH
11811: EMPTY
11812: LIST
11813: LIST
11814: LIST
11815: LIST
11816: LIST
11817: LIST
11818: LIST
11819: LIST
11820: LIST
11821: PUSH
11822: EMPTY
11823: LIST
11824: LIST
11825: ST_TO_ADDR
11826: GO 12057
11828: LD_INT 19
11830: DOUBLE
11831: EQUAL
11832: IFTRUE 11836
11834: GO 12056
11836: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ; end ;
11837: LD_ADDR_VAR 0 1
11841: PUSH
11842: LD_INT 1
11844: PUSH
11845: LD_INT 2
11847: PUSH
11848: LD_INT 3
11850: PUSH
11851: LD_INT 4
11853: PUSH
11854: LD_INT 5
11856: PUSH
11857: LD_INT 6
11859: PUSH
11860: LD_INT 7
11862: PUSH
11863: LD_INT 8
11865: PUSH
11866: LD_INT 9
11868: PUSH
11869: LD_INT 10
11871: PUSH
11872: LD_INT 11
11874: PUSH
11875: LD_INT 12
11877: PUSH
11878: LD_INT 13
11880: PUSH
11881: LD_INT 14
11883: PUSH
11884: LD_INT 15
11886: PUSH
11887: LD_INT 16
11889: PUSH
11890: LD_INT 17
11892: PUSH
11893: LD_INT 18
11895: PUSH
11896: LD_INT 19
11898: PUSH
11899: LD_INT 20
11901: PUSH
11902: LD_INT 21
11904: PUSH
11905: LD_INT 22
11907: PUSH
11908: LD_INT 23
11910: PUSH
11911: LD_INT 24
11913: PUSH
11914: LD_INT 25
11916: PUSH
11917: LD_INT 26
11919: PUSH
11920: LD_INT 27
11922: PUSH
11923: LD_INT 28
11925: PUSH
11926: LD_INT 29
11928: PUSH
11929: LD_INT 30
11931: PUSH
11932: LD_INT 31
11934: PUSH
11935: LD_INT 32
11937: PUSH
11938: LD_INT 33
11940: PUSH
11941: LD_INT 34
11943: PUSH
11944: LD_INT 35
11946: PUSH
11947: LD_INT 36
11949: PUSH
11950: EMPTY
11951: LIST
11952: LIST
11953: LIST
11954: LIST
11955: LIST
11956: LIST
11957: LIST
11958: LIST
11959: LIST
11960: LIST
11961: LIST
11962: LIST
11963: LIST
11964: LIST
11965: LIST
11966: LIST
11967: LIST
11968: LIST
11969: LIST
11970: LIST
11971: LIST
11972: LIST
11973: LIST
11974: LIST
11975: LIST
11976: LIST
11977: LIST
11978: LIST
11979: LIST
11980: LIST
11981: LIST
11982: LIST
11983: LIST
11984: LIST
11985: LIST
11986: LIST
11987: PUSH
11988: LD_INT 101
11990: PUSH
11991: LD_INT 102
11993: PUSH
11994: LD_INT 103
11996: PUSH
11997: LD_INT 104
11999: PUSH
12000: LD_INT 105
12002: PUSH
12003: LD_INT 106
12005: PUSH
12006: LD_INT 107
12008: PUSH
12009: LD_INT 108
12011: PUSH
12012: LD_INT 109
12014: PUSH
12015: LD_INT 110
12017: PUSH
12018: LD_INT 111
12020: PUSH
12021: LD_INT 112
12023: PUSH
12024: LD_INT 113
12026: PUSH
12027: LD_INT 114
12029: PUSH
12030: LD_INT 115
12032: PUSH
12033: EMPTY
12034: LIST
12035: LIST
12036: LIST
12037: LIST
12038: LIST
12039: LIST
12040: LIST
12041: LIST
12042: LIST
12043: LIST
12044: LIST
12045: LIST
12046: LIST
12047: LIST
12048: LIST
12049: PUSH
12050: EMPTY
12051: LIST
12052: LIST
12053: ST_TO_ADDR
12054: GO 12057
12056: POP
// end ; if result then
12057: LD_VAR 0 1
12061: IFFALSE 12350
// begin normal :=  ;
12063: LD_ADDR_VAR 0 3
12067: PUSH
12068: LD_STRING 
12070: ST_TO_ADDR
// hardcore :=  ;
12071: LD_ADDR_VAR 0 4
12075: PUSH
12076: LD_STRING 
12078: ST_TO_ADDR
// for i = 1 to normalCounter do
12079: LD_ADDR_VAR 0 5
12083: PUSH
12084: DOUBLE
12085: LD_INT 1
12087: DEC
12088: ST_TO_ADDR
12089: LD_EXP 58
12093: PUSH
12094: FOR_TO
12095: IFFALSE 12196
// begin tmp := 0 ;
12097: LD_ADDR_VAR 0 2
12101: PUSH
12102: LD_STRING 0
12104: ST_TO_ADDR
// if result [ 1 ] then
12105: LD_VAR 0 1
12109: PUSH
12110: LD_INT 1
12112: ARRAY
12113: IFFALSE 12178
// if result [ 1 ] [ 1 ] = i then
12115: LD_VAR 0 1
12119: PUSH
12120: LD_INT 1
12122: ARRAY
12123: PUSH
12124: LD_INT 1
12126: ARRAY
12127: PUSH
12128: LD_VAR 0 5
12132: EQUAL
12133: IFFALSE 12178
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
12135: LD_ADDR_VAR 0 1
12139: PUSH
12140: LD_VAR 0 1
12144: PPUSH
12145: LD_INT 1
12147: PPUSH
12148: LD_VAR 0 1
12152: PUSH
12153: LD_INT 1
12155: ARRAY
12156: PPUSH
12157: LD_INT 1
12159: PPUSH
12160: CALL_OW 3
12164: PPUSH
12165: CALL_OW 1
12169: ST_TO_ADDR
// tmp := 1 ;
12170: LD_ADDR_VAR 0 2
12174: PUSH
12175: LD_STRING 1
12177: ST_TO_ADDR
// end ; normal := normal & tmp ;
12178: LD_ADDR_VAR 0 3
12182: PUSH
12183: LD_VAR 0 3
12187: PUSH
12188: LD_VAR 0 2
12192: STR
12193: ST_TO_ADDR
// end ;
12194: GO 12094
12196: POP
12197: POP
// for i = 1 to hardcoreCounter do
12198: LD_ADDR_VAR 0 5
12202: PUSH
12203: DOUBLE
12204: LD_INT 1
12206: DEC
12207: ST_TO_ADDR
12208: LD_EXP 59
12212: PUSH
12213: FOR_TO
12214: IFFALSE 12319
// begin tmp := 0 ;
12216: LD_ADDR_VAR 0 2
12220: PUSH
12221: LD_STRING 0
12223: ST_TO_ADDR
// if result [ 2 ] then
12224: LD_VAR 0 1
12228: PUSH
12229: LD_INT 2
12231: ARRAY
12232: IFFALSE 12301
// if result [ 2 ] [ 1 ] = 100 + i then
12234: LD_VAR 0 1
12238: PUSH
12239: LD_INT 2
12241: ARRAY
12242: PUSH
12243: LD_INT 1
12245: ARRAY
12246: PUSH
12247: LD_INT 100
12249: PUSH
12250: LD_VAR 0 5
12254: PLUS
12255: EQUAL
12256: IFFALSE 12301
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
12258: LD_ADDR_VAR 0 1
12262: PUSH
12263: LD_VAR 0 1
12267: PPUSH
12268: LD_INT 2
12270: PPUSH
12271: LD_VAR 0 1
12275: PUSH
12276: LD_INT 2
12278: ARRAY
12279: PPUSH
12280: LD_INT 1
12282: PPUSH
12283: CALL_OW 3
12287: PPUSH
12288: CALL_OW 1
12292: ST_TO_ADDR
// tmp := 1 ;
12293: LD_ADDR_VAR 0 2
12297: PUSH
12298: LD_STRING 1
12300: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
12301: LD_ADDR_VAR 0 4
12305: PUSH
12306: LD_VAR 0 4
12310: PUSH
12311: LD_VAR 0 2
12315: STR
12316: ST_TO_ADDR
// end ;
12317: GO 12213
12319: POP
12320: POP
// ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & ") ) ;
12321: LD_STRING getStreamItemsFromMission("
12323: PUSH
12324: LD_VAR 0 3
12328: STR
12329: PUSH
12330: LD_STRING ","
12332: STR
12333: PUSH
12334: LD_VAR 0 4
12338: STR
12339: PUSH
12340: LD_STRING ")
12342: STR
12343: PPUSH
12344: CALL_OW 559
// end else
12348: GO 12357
// ToLua ( getStreamItemsFromMission("","") ) ;
12350: LD_STRING getStreamItemsFromMission("","")
12352: PPUSH
12353: CALL_OW 559
// end ;
12357: LD_VAR 0 1
12361: RET
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin if p2 = 100 then
12362: LD_VAR 0 2
12366: PUSH
12367: LD_INT 100
12369: EQUAL
12370: IFFALSE 13319
// begin if not StreamModeActive then
12372: LD_EXP 57
12376: NOT
12377: IFFALSE 12387
// StreamModeActive := true ;
12379: LD_ADDR_EXP 57
12383: PUSH
12384: LD_INT 1
12386: ST_TO_ADDR
// if p3 = 0 then
12387: LD_VAR 0 3
12391: PUSH
12392: LD_INT 0
12394: EQUAL
12395: IFFALSE 12401
// InitStreamMode ;
12397: CALL 8659 0 0
// if p3 = 1 then
12401: LD_VAR 0 3
12405: PUSH
12406: LD_INT 1
12408: EQUAL
12409: IFFALSE 12419
// sRocket := true ;
12411: LD_ADDR_EXP 62
12415: PUSH
12416: LD_INT 1
12418: ST_TO_ADDR
// if p3 = 2 then
12419: LD_VAR 0 3
12423: PUSH
12424: LD_INT 2
12426: EQUAL
12427: IFFALSE 12437
// sSpeed := true ;
12429: LD_ADDR_EXP 61
12433: PUSH
12434: LD_INT 1
12436: ST_TO_ADDR
// if p3 = 3 then
12437: LD_VAR 0 3
12441: PUSH
12442: LD_INT 3
12444: EQUAL
12445: IFFALSE 12455
// sEngine := true ;
12447: LD_ADDR_EXP 63
12451: PUSH
12452: LD_INT 1
12454: ST_TO_ADDR
// if p3 = 4 then
12455: LD_VAR 0 3
12459: PUSH
12460: LD_INT 4
12462: EQUAL
12463: IFFALSE 12473
// sSpec := true ;
12465: LD_ADDR_EXP 60
12469: PUSH
12470: LD_INT 1
12472: ST_TO_ADDR
// if p3 = 5 then
12473: LD_VAR 0 3
12477: PUSH
12478: LD_INT 5
12480: EQUAL
12481: IFFALSE 12491
// sLevel := true ;
12483: LD_ADDR_EXP 64
12487: PUSH
12488: LD_INT 1
12490: ST_TO_ADDR
// if p3 = 6 then
12491: LD_VAR 0 3
12495: PUSH
12496: LD_INT 6
12498: EQUAL
12499: IFFALSE 12509
// sArmoury := true ;
12501: LD_ADDR_EXP 65
12505: PUSH
12506: LD_INT 1
12508: ST_TO_ADDR
// if p3 = 7 then
12509: LD_VAR 0 3
12513: PUSH
12514: LD_INT 7
12516: EQUAL
12517: IFFALSE 12527
// sRadar := true ;
12519: LD_ADDR_EXP 66
12523: PUSH
12524: LD_INT 1
12526: ST_TO_ADDR
// if p3 = 8 then
12527: LD_VAR 0 3
12531: PUSH
12532: LD_INT 8
12534: EQUAL
12535: IFFALSE 12545
// sBunker := true ;
12537: LD_ADDR_EXP 67
12541: PUSH
12542: LD_INT 1
12544: ST_TO_ADDR
// if p3 = 9 then
12545: LD_VAR 0 3
12549: PUSH
12550: LD_INT 9
12552: EQUAL
12553: IFFALSE 12563
// sHack := true ;
12555: LD_ADDR_EXP 68
12559: PUSH
12560: LD_INT 1
12562: ST_TO_ADDR
// if p3 = 10 then
12563: LD_VAR 0 3
12567: PUSH
12568: LD_INT 10
12570: EQUAL
12571: IFFALSE 12581
// sFire := true ;
12573: LD_ADDR_EXP 69
12577: PUSH
12578: LD_INT 1
12580: ST_TO_ADDR
// if p3 = 11 then
12581: LD_VAR 0 3
12585: PUSH
12586: LD_INT 11
12588: EQUAL
12589: IFFALSE 12599
// sRefresh := true ;
12591: LD_ADDR_EXP 70
12595: PUSH
12596: LD_INT 1
12598: ST_TO_ADDR
// if p3 = 12 then
12599: LD_VAR 0 3
12603: PUSH
12604: LD_INT 12
12606: EQUAL
12607: IFFALSE 12617
// sExp := true ;
12609: LD_ADDR_EXP 71
12613: PUSH
12614: LD_INT 1
12616: ST_TO_ADDR
// if p3 = 13 then
12617: LD_VAR 0 3
12621: PUSH
12622: LD_INT 13
12624: EQUAL
12625: IFFALSE 12635
// sDepot := true ;
12627: LD_ADDR_EXP 72
12631: PUSH
12632: LD_INT 1
12634: ST_TO_ADDR
// if p3 = 14 then
12635: LD_VAR 0 3
12639: PUSH
12640: LD_INT 14
12642: EQUAL
12643: IFFALSE 12653
// sFlag := true ;
12645: LD_ADDR_EXP 73
12649: PUSH
12650: LD_INT 1
12652: ST_TO_ADDR
// if p3 = 15 then
12653: LD_VAR 0 3
12657: PUSH
12658: LD_INT 15
12660: EQUAL
12661: IFFALSE 12671
// sKamikadze := true ;
12663: LD_ADDR_EXP 81
12667: PUSH
12668: LD_INT 1
12670: ST_TO_ADDR
// if p3 = 16 then
12671: LD_VAR 0 3
12675: PUSH
12676: LD_INT 16
12678: EQUAL
12679: IFFALSE 12689
// sTroll := true ;
12681: LD_ADDR_EXP 82
12685: PUSH
12686: LD_INT 1
12688: ST_TO_ADDR
// if p3 = 17 then
12689: LD_VAR 0 3
12693: PUSH
12694: LD_INT 17
12696: EQUAL
12697: IFFALSE 12707
// sSlow := true ;
12699: LD_ADDR_EXP 83
12703: PUSH
12704: LD_INT 1
12706: ST_TO_ADDR
// if p3 = 18 then
12707: LD_VAR 0 3
12711: PUSH
12712: LD_INT 18
12714: EQUAL
12715: IFFALSE 12725
// sLack := true ;
12717: LD_ADDR_EXP 84
12721: PUSH
12722: LD_INT 1
12724: ST_TO_ADDR
// if p3 = 19 then
12725: LD_VAR 0 3
12729: PUSH
12730: LD_INT 19
12732: EQUAL
12733: IFFALSE 12743
// sTank := true ;
12735: LD_ADDR_EXP 86
12739: PUSH
12740: LD_INT 1
12742: ST_TO_ADDR
// if p3 = 20 then
12743: LD_VAR 0 3
12747: PUSH
12748: LD_INT 20
12750: EQUAL
12751: IFFALSE 12761
// sRemote := true ;
12753: LD_ADDR_EXP 87
12757: PUSH
12758: LD_INT 1
12760: ST_TO_ADDR
// if p3 = 21 then
12761: LD_VAR 0 3
12765: PUSH
12766: LD_INT 21
12768: EQUAL
12769: IFFALSE 12779
// sPowell := true ;
12771: LD_ADDR_EXP 88
12775: PUSH
12776: LD_INT 1
12778: ST_TO_ADDR
// if p3 = 22 then
12779: LD_VAR 0 3
12783: PUSH
12784: LD_INT 22
12786: EQUAL
12787: IFFALSE 12797
// sTeleport := true ;
12789: LD_ADDR_EXP 91
12793: PUSH
12794: LD_INT 1
12796: ST_TO_ADDR
// if p3 = 23 then
12797: LD_VAR 0 3
12801: PUSH
12802: LD_INT 23
12804: EQUAL
12805: IFFALSE 12815
// sOilTower := true ;
12807: LD_ADDR_EXP 93
12811: PUSH
12812: LD_INT 1
12814: ST_TO_ADDR
// if p3 = 24 then
12815: LD_VAR 0 3
12819: PUSH
12820: LD_INT 24
12822: EQUAL
12823: IFFALSE 12833
// sShovel := true ;
12825: LD_ADDR_EXP 94
12829: PUSH
12830: LD_INT 1
12832: ST_TO_ADDR
// if p3 = 25 then
12833: LD_VAR 0 3
12837: PUSH
12838: LD_INT 25
12840: EQUAL
12841: IFFALSE 12851
// sSheik := true ;
12843: LD_ADDR_EXP 95
12847: PUSH
12848: LD_INT 1
12850: ST_TO_ADDR
// if p3 = 26 then
12851: LD_VAR 0 3
12855: PUSH
12856: LD_INT 26
12858: EQUAL
12859: IFFALSE 12869
// sEarthquake := true ;
12861: LD_ADDR_EXP 97
12865: PUSH
12866: LD_INT 1
12868: ST_TO_ADDR
// if p3 = 27 then
12869: LD_VAR 0 3
12873: PUSH
12874: LD_INT 27
12876: EQUAL
12877: IFFALSE 12887
// sAI := true ;
12879: LD_ADDR_EXP 98
12883: PUSH
12884: LD_INT 1
12886: ST_TO_ADDR
// if p3 = 28 then
12887: LD_VAR 0 3
12891: PUSH
12892: LD_INT 28
12894: EQUAL
12895: IFFALSE 12905
// sCargo := true ;
12897: LD_ADDR_EXP 101
12901: PUSH
12902: LD_INT 1
12904: ST_TO_ADDR
// if p3 = 29 then
12905: LD_VAR 0 3
12909: PUSH
12910: LD_INT 29
12912: EQUAL
12913: IFFALSE 12923
// sDLaser := true ;
12915: LD_ADDR_EXP 102
12919: PUSH
12920: LD_INT 1
12922: ST_TO_ADDR
// if p3 = 30 then
12923: LD_VAR 0 3
12927: PUSH
12928: LD_INT 30
12930: EQUAL
12931: IFFALSE 12941
// sExchange := true ;
12933: LD_ADDR_EXP 103
12937: PUSH
12938: LD_INT 1
12940: ST_TO_ADDR
// if p3 = 31 then
12941: LD_VAR 0 3
12945: PUSH
12946: LD_INT 31
12948: EQUAL
12949: IFFALSE 12959
// sFac := true ;
12951: LD_ADDR_EXP 104
12955: PUSH
12956: LD_INT 1
12958: ST_TO_ADDR
// if p3 = 32 then
12959: LD_VAR 0 3
12963: PUSH
12964: LD_INT 32
12966: EQUAL
12967: IFFALSE 12977
// sPower := true ;
12969: LD_ADDR_EXP 105
12973: PUSH
12974: LD_INT 1
12976: ST_TO_ADDR
// if p3 = 33 then
12977: LD_VAR 0 3
12981: PUSH
12982: LD_INT 33
12984: EQUAL
12985: IFFALSE 12995
// sRandom := true ;
12987: LD_ADDR_EXP 106
12991: PUSH
12992: LD_INT 1
12994: ST_TO_ADDR
// if p3 = 34 then
12995: LD_VAR 0 3
12999: PUSH
13000: LD_INT 34
13002: EQUAL
13003: IFFALSE 13013
// sShield := true ;
13005: LD_ADDR_EXP 107
13009: PUSH
13010: LD_INT 1
13012: ST_TO_ADDR
// if p3 = 35 then
13013: LD_VAR 0 3
13017: PUSH
13018: LD_INT 35
13020: EQUAL
13021: IFFALSE 13031
// sTime := true ;
13023: LD_ADDR_EXP 108
13027: PUSH
13028: LD_INT 1
13030: ST_TO_ADDR
// if p3 = 36 then
13031: LD_VAR 0 3
13035: PUSH
13036: LD_INT 36
13038: EQUAL
13039: IFFALSE 13049
// sTools := true ;
13041: LD_ADDR_EXP 109
13045: PUSH
13046: LD_INT 1
13048: ST_TO_ADDR
// if p3 = 101 then
13049: LD_VAR 0 3
13053: PUSH
13054: LD_INT 101
13056: EQUAL
13057: IFFALSE 13067
// sSold := true ;
13059: LD_ADDR_EXP 74
13063: PUSH
13064: LD_INT 1
13066: ST_TO_ADDR
// if p3 = 102 then
13067: LD_VAR 0 3
13071: PUSH
13072: LD_INT 102
13074: EQUAL
13075: IFFALSE 13085
// sDiff := true ;
13077: LD_ADDR_EXP 75
13081: PUSH
13082: LD_INT 1
13084: ST_TO_ADDR
// if p3 = 103 then
13085: LD_VAR 0 3
13089: PUSH
13090: LD_INT 103
13092: EQUAL
13093: IFFALSE 13103
// sFog := true ;
13095: LD_ADDR_EXP 78
13099: PUSH
13100: LD_INT 1
13102: ST_TO_ADDR
// if p3 = 104 then
13103: LD_VAR 0 3
13107: PUSH
13108: LD_INT 104
13110: EQUAL
13111: IFFALSE 13121
// sReset := true ;
13113: LD_ADDR_EXP 79
13117: PUSH
13118: LD_INT 1
13120: ST_TO_ADDR
// if p3 = 105 then
13121: LD_VAR 0 3
13125: PUSH
13126: LD_INT 105
13128: EQUAL
13129: IFFALSE 13139
// sSun := true ;
13131: LD_ADDR_EXP 80
13135: PUSH
13136: LD_INT 1
13138: ST_TO_ADDR
// if p3 = 106 then
13139: LD_VAR 0 3
13143: PUSH
13144: LD_INT 106
13146: EQUAL
13147: IFFALSE 13157
// sTiger := true ;
13149: LD_ADDR_EXP 76
13153: PUSH
13154: LD_INT 1
13156: ST_TO_ADDR
// if p3 = 107 then
13157: LD_VAR 0 3
13161: PUSH
13162: LD_INT 107
13164: EQUAL
13165: IFFALSE 13175
// sBomb := true ;
13167: LD_ADDR_EXP 77
13171: PUSH
13172: LD_INT 1
13174: ST_TO_ADDR
// if p3 = 108 then
13175: LD_VAR 0 3
13179: PUSH
13180: LD_INT 108
13182: EQUAL
13183: IFFALSE 13193
// sWound := true ;
13185: LD_ADDR_EXP 85
13189: PUSH
13190: LD_INT 1
13192: ST_TO_ADDR
// if p3 = 109 then
13193: LD_VAR 0 3
13197: PUSH
13198: LD_INT 109
13200: EQUAL
13201: IFFALSE 13211
// sBetray := true ;
13203: LD_ADDR_EXP 89
13207: PUSH
13208: LD_INT 1
13210: ST_TO_ADDR
// if p3 = 110 then
13211: LD_VAR 0 3
13215: PUSH
13216: LD_INT 110
13218: EQUAL
13219: IFFALSE 13229
// sContamin := true ;
13221: LD_ADDR_EXP 90
13225: PUSH
13226: LD_INT 1
13228: ST_TO_ADDR
// if p3 = 111 then
13229: LD_VAR 0 3
13233: PUSH
13234: LD_INT 111
13236: EQUAL
13237: IFFALSE 13247
// sOil := true ;
13239: LD_ADDR_EXP 92
13243: PUSH
13244: LD_INT 1
13246: ST_TO_ADDR
// if p3 = 112 then
13247: LD_VAR 0 3
13251: PUSH
13252: LD_INT 112
13254: EQUAL
13255: IFFALSE 13265
// sStu := true ;
13257: LD_ADDR_EXP 96
13261: PUSH
13262: LD_INT 1
13264: ST_TO_ADDR
// if p3 = 113 then
13265: LD_VAR 0 3
13269: PUSH
13270: LD_INT 113
13272: EQUAL
13273: IFFALSE 13283
// sBazooka := true ;
13275: LD_ADDR_EXP 99
13279: PUSH
13280: LD_INT 1
13282: ST_TO_ADDR
// if p3 = 114 then
13283: LD_VAR 0 3
13287: PUSH
13288: LD_INT 114
13290: EQUAL
13291: IFFALSE 13301
// sMortar := true ;
13293: LD_ADDR_EXP 100
13297: PUSH
13298: LD_INT 1
13300: ST_TO_ADDR
// if p3 = 115 then
13301: LD_VAR 0 3
13305: PUSH
13306: LD_INT 115
13308: EQUAL
13309: IFFALSE 13319
// sRanger := true ;
13311: LD_ADDR_EXP 110
13315: PUSH
13316: LD_INT 1
13318: ST_TO_ADDR
// end ; end ;
13319: PPOPN 6
13321: END
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
13322: LD_EXP 57
13326: PUSH
13327: LD_EXP 62
13331: AND
13332: IFFALSE 13456
13334: GO 13336
13336: DISABLE
13337: LD_INT 0
13339: PPUSH
13340: PPUSH
// begin enable ;
13341: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
13342: LD_ADDR_VAR 0 2
13346: PUSH
13347: LD_INT 22
13349: PUSH
13350: LD_OWVAR 2
13354: PUSH
13355: EMPTY
13356: LIST
13357: LIST
13358: PUSH
13359: LD_INT 2
13361: PUSH
13362: LD_INT 34
13364: PUSH
13365: LD_INT 7
13367: PUSH
13368: EMPTY
13369: LIST
13370: LIST
13371: PUSH
13372: LD_INT 34
13374: PUSH
13375: LD_INT 45
13377: PUSH
13378: EMPTY
13379: LIST
13380: LIST
13381: PUSH
13382: LD_INT 34
13384: PUSH
13385: LD_INT 28
13387: PUSH
13388: EMPTY
13389: LIST
13390: LIST
13391: PUSH
13392: LD_INT 34
13394: PUSH
13395: LD_INT 47
13397: PUSH
13398: EMPTY
13399: LIST
13400: LIST
13401: PUSH
13402: EMPTY
13403: LIST
13404: LIST
13405: LIST
13406: LIST
13407: LIST
13408: PUSH
13409: EMPTY
13410: LIST
13411: LIST
13412: PPUSH
13413: CALL_OW 69
13417: ST_TO_ADDR
// if not tmp then
13418: LD_VAR 0 2
13422: NOT
13423: IFFALSE 13427
// exit ;
13425: GO 13456
// for i in tmp do
13427: LD_ADDR_VAR 0 1
13431: PUSH
13432: LD_VAR 0 2
13436: PUSH
13437: FOR_IN
13438: IFFALSE 13454
// begin SetLives ( i , 0 ) ;
13440: LD_VAR 0 1
13444: PPUSH
13445: LD_INT 0
13447: PPUSH
13448: CALL_OW 234
// end ;
13452: GO 13437
13454: POP
13455: POP
// end ;
13456: PPOPN 2
13458: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
13459: LD_EXP 57
13463: PUSH
13464: LD_EXP 63
13468: AND
13469: IFFALSE 13553
13471: GO 13473
13473: DISABLE
13474: LD_INT 0
13476: PPUSH
13477: PPUSH
// begin enable ;
13478: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
13479: LD_ADDR_VAR 0 2
13483: PUSH
13484: LD_INT 22
13486: PUSH
13487: LD_OWVAR 2
13491: PUSH
13492: EMPTY
13493: LIST
13494: LIST
13495: PUSH
13496: LD_INT 32
13498: PUSH
13499: LD_INT 3
13501: PUSH
13502: EMPTY
13503: LIST
13504: LIST
13505: PUSH
13506: EMPTY
13507: LIST
13508: LIST
13509: PPUSH
13510: CALL_OW 69
13514: ST_TO_ADDR
// if not tmp then
13515: LD_VAR 0 2
13519: NOT
13520: IFFALSE 13524
// exit ;
13522: GO 13553
// for i in tmp do
13524: LD_ADDR_VAR 0 1
13528: PUSH
13529: LD_VAR 0 2
13533: PUSH
13534: FOR_IN
13535: IFFALSE 13551
// begin SetLives ( i , 0 ) ;
13537: LD_VAR 0 1
13541: PPUSH
13542: LD_INT 0
13544: PPUSH
13545: CALL_OW 234
// end ;
13549: GO 13534
13551: POP
13552: POP
// end ;
13553: PPOPN 2
13555: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
13556: LD_EXP 57
13560: PUSH
13561: LD_EXP 60
13565: AND
13566: IFFALSE 13659
13568: GO 13570
13570: DISABLE
13571: LD_INT 0
13573: PPUSH
// begin enable ;
13574: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
13575: LD_ADDR_VAR 0 1
13579: PUSH
13580: LD_INT 22
13582: PUSH
13583: LD_OWVAR 2
13587: PUSH
13588: EMPTY
13589: LIST
13590: LIST
13591: PUSH
13592: LD_INT 2
13594: PUSH
13595: LD_INT 25
13597: PUSH
13598: LD_INT 5
13600: PUSH
13601: EMPTY
13602: LIST
13603: LIST
13604: PUSH
13605: LD_INT 25
13607: PUSH
13608: LD_INT 9
13610: PUSH
13611: EMPTY
13612: LIST
13613: LIST
13614: PUSH
13615: LD_INT 25
13617: PUSH
13618: LD_INT 8
13620: PUSH
13621: EMPTY
13622: LIST
13623: LIST
13624: PUSH
13625: EMPTY
13626: LIST
13627: LIST
13628: LIST
13629: LIST
13630: PUSH
13631: EMPTY
13632: LIST
13633: LIST
13634: PPUSH
13635: CALL_OW 69
13639: PUSH
13640: FOR_IN
13641: IFFALSE 13657
// begin SetClass ( i , 1 ) ;
13643: LD_VAR 0 1
13647: PPUSH
13648: LD_INT 1
13650: PPUSH
13651: CALL_OW 336
// end ;
13655: GO 13640
13657: POP
13658: POP
// end ;
13659: PPOPN 1
13661: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
13662: LD_EXP 57
13666: PUSH
13667: LD_EXP 61
13671: AND
13672: PUSH
13673: LD_OWVAR 65
13677: PUSH
13678: LD_INT 7
13680: LESS
13681: AND
13682: IFFALSE 13696
13684: GO 13686
13686: DISABLE
// begin enable ;
13687: ENABLE
// game_speed := 7 ;
13688: LD_ADDR_OWVAR 65
13692: PUSH
13693: LD_INT 7
13695: ST_TO_ADDR
// end ;
13696: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
13697: LD_EXP 57
13701: PUSH
13702: LD_EXP 64
13706: AND
13707: IFFALSE 13909
13709: GO 13711
13711: DISABLE
13712: LD_INT 0
13714: PPUSH
13715: PPUSH
13716: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
13717: LD_ADDR_VAR 0 3
13721: PUSH
13722: LD_INT 81
13724: PUSH
13725: LD_OWVAR 2
13729: PUSH
13730: EMPTY
13731: LIST
13732: LIST
13733: PUSH
13734: LD_INT 21
13736: PUSH
13737: LD_INT 1
13739: PUSH
13740: EMPTY
13741: LIST
13742: LIST
13743: PUSH
13744: EMPTY
13745: LIST
13746: LIST
13747: PPUSH
13748: CALL_OW 69
13752: ST_TO_ADDR
// if not tmp then
13753: LD_VAR 0 3
13757: NOT
13758: IFFALSE 13762
// exit ;
13760: GO 13909
// if tmp > 5 then
13762: LD_VAR 0 3
13766: PUSH
13767: LD_INT 5
13769: GREATER
13770: IFFALSE 13782
// k := 5 else
13772: LD_ADDR_VAR 0 2
13776: PUSH
13777: LD_INT 5
13779: ST_TO_ADDR
13780: GO 13792
// k := tmp ;
13782: LD_ADDR_VAR 0 2
13786: PUSH
13787: LD_VAR 0 3
13791: ST_TO_ADDR
// for i := 1 to k do
13792: LD_ADDR_VAR 0 1
13796: PUSH
13797: DOUBLE
13798: LD_INT 1
13800: DEC
13801: ST_TO_ADDR
13802: LD_VAR 0 2
13806: PUSH
13807: FOR_TO
13808: IFFALSE 13907
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
13810: LD_VAR 0 3
13814: PUSH
13815: LD_VAR 0 1
13819: ARRAY
13820: PPUSH
13821: LD_VAR 0 1
13825: PUSH
13826: LD_INT 4
13828: MOD
13829: PUSH
13830: LD_INT 1
13832: PLUS
13833: PPUSH
13834: CALL_OW 259
13838: PUSH
13839: LD_INT 10
13841: LESS
13842: IFFALSE 13905
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
13844: LD_VAR 0 3
13848: PUSH
13849: LD_VAR 0 1
13853: ARRAY
13854: PPUSH
13855: LD_VAR 0 1
13859: PUSH
13860: LD_INT 4
13862: MOD
13863: PUSH
13864: LD_INT 1
13866: PLUS
13867: PPUSH
13868: LD_VAR 0 3
13872: PUSH
13873: LD_VAR 0 1
13877: ARRAY
13878: PPUSH
13879: LD_VAR 0 1
13883: PUSH
13884: LD_INT 4
13886: MOD
13887: PUSH
13888: LD_INT 1
13890: PLUS
13891: PPUSH
13892: CALL_OW 259
13896: PUSH
13897: LD_INT 1
13899: PLUS
13900: PPUSH
13901: CALL_OW 237
13905: GO 13807
13907: POP
13908: POP
// end ;
13909: PPOPN 3
13911: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
13912: LD_EXP 57
13916: PUSH
13917: LD_EXP 65
13921: AND
13922: IFFALSE 13942
13924: GO 13926
13926: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
13927: LD_INT 4
13929: PPUSH
13930: LD_OWVAR 2
13934: PPUSH
13935: LD_INT 0
13937: PPUSH
13938: CALL_OW 324
13942: END
// every 0 0$1 trigger StreamModeActive and sShovel do
13943: LD_EXP 57
13947: PUSH
13948: LD_EXP 94
13952: AND
13953: IFFALSE 13973
13955: GO 13957
13957: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
13958: LD_INT 19
13960: PPUSH
13961: LD_OWVAR 2
13965: PPUSH
13966: LD_INT 0
13968: PPUSH
13969: CALL_OW 324
13973: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
13974: LD_EXP 57
13978: PUSH
13979: LD_EXP 66
13983: AND
13984: IFFALSE 14086
13986: GO 13988
13988: DISABLE
13989: LD_INT 0
13991: PPUSH
13992: PPUSH
// begin enable ;
13993: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
13994: LD_ADDR_VAR 0 2
13998: PUSH
13999: LD_INT 22
14001: PUSH
14002: LD_OWVAR 2
14006: PUSH
14007: EMPTY
14008: LIST
14009: LIST
14010: PUSH
14011: LD_INT 2
14013: PUSH
14014: LD_INT 34
14016: PUSH
14017: LD_INT 11
14019: PUSH
14020: EMPTY
14021: LIST
14022: LIST
14023: PUSH
14024: LD_INT 34
14026: PUSH
14027: LD_INT 30
14029: PUSH
14030: EMPTY
14031: LIST
14032: LIST
14033: PUSH
14034: EMPTY
14035: LIST
14036: LIST
14037: LIST
14038: PUSH
14039: EMPTY
14040: LIST
14041: LIST
14042: PPUSH
14043: CALL_OW 69
14047: ST_TO_ADDR
// if not tmp then
14048: LD_VAR 0 2
14052: NOT
14053: IFFALSE 14057
// exit ;
14055: GO 14086
// for i in tmp do
14057: LD_ADDR_VAR 0 1
14061: PUSH
14062: LD_VAR 0 2
14066: PUSH
14067: FOR_IN
14068: IFFALSE 14084
// begin SetLives ( i , 0 ) ;
14070: LD_VAR 0 1
14074: PPUSH
14075: LD_INT 0
14077: PPUSH
14078: CALL_OW 234
// end ;
14082: GO 14067
14084: POP
14085: POP
// end ;
14086: PPOPN 2
14088: END
// every 0 0$1 trigger StreamModeActive and sBunker do
14089: LD_EXP 57
14093: PUSH
14094: LD_EXP 67
14098: AND
14099: IFFALSE 14119
14101: GO 14103
14103: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
14104: LD_INT 32
14106: PPUSH
14107: LD_OWVAR 2
14111: PPUSH
14112: LD_INT 0
14114: PPUSH
14115: CALL_OW 324
14119: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
14120: LD_EXP 57
14124: PUSH
14125: LD_EXP 68
14129: AND
14130: IFFALSE 14311
14132: GO 14134
14134: DISABLE
14135: LD_INT 0
14137: PPUSH
14138: PPUSH
14139: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
14140: LD_ADDR_VAR 0 2
14144: PUSH
14145: LD_INT 22
14147: PUSH
14148: LD_OWVAR 2
14152: PUSH
14153: EMPTY
14154: LIST
14155: LIST
14156: PUSH
14157: LD_INT 33
14159: PUSH
14160: LD_INT 3
14162: PUSH
14163: EMPTY
14164: LIST
14165: LIST
14166: PUSH
14167: EMPTY
14168: LIST
14169: LIST
14170: PPUSH
14171: CALL_OW 69
14175: ST_TO_ADDR
// if not tmp then
14176: LD_VAR 0 2
14180: NOT
14181: IFFALSE 14185
// exit ;
14183: GO 14311
// side := 0 ;
14185: LD_ADDR_VAR 0 3
14189: PUSH
14190: LD_INT 0
14192: ST_TO_ADDR
// for i := 1 to 8 do
14193: LD_ADDR_VAR 0 1
14197: PUSH
14198: DOUBLE
14199: LD_INT 1
14201: DEC
14202: ST_TO_ADDR
14203: LD_INT 8
14205: PUSH
14206: FOR_TO
14207: IFFALSE 14255
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
14209: LD_OWVAR 2
14213: PUSH
14214: LD_VAR 0 1
14218: NONEQUAL
14219: PUSH
14220: LD_OWVAR 2
14224: PPUSH
14225: LD_VAR 0 1
14229: PPUSH
14230: CALL_OW 81
14234: PUSH
14235: LD_INT 2
14237: EQUAL
14238: AND
14239: IFFALSE 14253
// begin side := i ;
14241: LD_ADDR_VAR 0 3
14245: PUSH
14246: LD_VAR 0 1
14250: ST_TO_ADDR
// break ;
14251: GO 14255
// end ;
14253: GO 14206
14255: POP
14256: POP
// if not side then
14257: LD_VAR 0 3
14261: NOT
14262: IFFALSE 14266
// exit ;
14264: GO 14311
// for i := 1 to tmp do
14266: LD_ADDR_VAR 0 1
14270: PUSH
14271: DOUBLE
14272: LD_INT 1
14274: DEC
14275: ST_TO_ADDR
14276: LD_VAR 0 2
14280: PUSH
14281: FOR_TO
14282: IFFALSE 14309
// if Prob ( 60 ) then
14284: LD_INT 60
14286: PPUSH
14287: CALL_OW 13
14291: IFFALSE 14307
// SetSide ( i , side ) ;
14293: LD_VAR 0 1
14297: PPUSH
14298: LD_VAR 0 3
14302: PPUSH
14303: CALL_OW 235
14307: GO 14281
14309: POP
14310: POP
// end ;
14311: PPOPN 3
14313: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
14314: LD_EXP 57
14318: PUSH
14319: LD_EXP 70
14323: AND
14324: IFFALSE 14443
14326: GO 14328
14328: DISABLE
14329: LD_INT 0
14331: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
14332: LD_ADDR_VAR 0 1
14336: PUSH
14337: LD_INT 22
14339: PUSH
14340: LD_OWVAR 2
14344: PUSH
14345: EMPTY
14346: LIST
14347: LIST
14348: PUSH
14349: LD_INT 21
14351: PUSH
14352: LD_INT 1
14354: PUSH
14355: EMPTY
14356: LIST
14357: LIST
14358: PUSH
14359: LD_INT 3
14361: PUSH
14362: LD_INT 23
14364: PUSH
14365: LD_INT 0
14367: PUSH
14368: EMPTY
14369: LIST
14370: LIST
14371: PUSH
14372: EMPTY
14373: LIST
14374: LIST
14375: PUSH
14376: EMPTY
14377: LIST
14378: LIST
14379: LIST
14380: PPUSH
14381: CALL_OW 69
14385: PUSH
14386: FOR_IN
14387: IFFALSE 14441
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
14389: LD_VAR 0 1
14393: PPUSH
14394: CALL_OW 257
14398: PUSH
14399: LD_INT 1
14401: PUSH
14402: LD_INT 2
14404: PUSH
14405: LD_INT 3
14407: PUSH
14408: LD_INT 4
14410: PUSH
14411: EMPTY
14412: LIST
14413: LIST
14414: LIST
14415: LIST
14416: IN
14417: IFFALSE 14439
// SetClass ( un , rand ( 1 , 4 ) ) ;
14419: LD_VAR 0 1
14423: PPUSH
14424: LD_INT 1
14426: PPUSH
14427: LD_INT 4
14429: PPUSH
14430: CALL_OW 12
14434: PPUSH
14435: CALL_OW 336
14439: GO 14386
14441: POP
14442: POP
// end ;
14443: PPOPN 1
14445: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
14446: LD_EXP 57
14450: PUSH
14451: LD_EXP 69
14455: AND
14456: IFFALSE 14535
14458: GO 14460
14460: DISABLE
14461: LD_INT 0
14463: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
14464: LD_ADDR_VAR 0 1
14468: PUSH
14469: LD_INT 22
14471: PUSH
14472: LD_OWVAR 2
14476: PUSH
14477: EMPTY
14478: LIST
14479: LIST
14480: PUSH
14481: LD_INT 21
14483: PUSH
14484: LD_INT 3
14486: PUSH
14487: EMPTY
14488: LIST
14489: LIST
14490: PUSH
14491: EMPTY
14492: LIST
14493: LIST
14494: PPUSH
14495: CALL_OW 69
14499: ST_TO_ADDR
// if not tmp then
14500: LD_VAR 0 1
14504: NOT
14505: IFFALSE 14509
// exit ;
14507: GO 14535
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
14509: LD_VAR 0 1
14513: PUSH
14514: LD_INT 1
14516: PPUSH
14517: LD_VAR 0 1
14521: PPUSH
14522: CALL_OW 12
14526: ARRAY
14527: PPUSH
14528: LD_INT 100
14530: PPUSH
14531: CALL_OW 234
// end ;
14535: PPOPN 1
14537: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
14538: LD_EXP 57
14542: PUSH
14543: LD_EXP 71
14547: AND
14548: IFFALSE 14646
14550: GO 14552
14552: DISABLE
14553: LD_INT 0
14555: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
14556: LD_ADDR_VAR 0 1
14560: PUSH
14561: LD_INT 22
14563: PUSH
14564: LD_OWVAR 2
14568: PUSH
14569: EMPTY
14570: LIST
14571: LIST
14572: PUSH
14573: LD_INT 21
14575: PUSH
14576: LD_INT 1
14578: PUSH
14579: EMPTY
14580: LIST
14581: LIST
14582: PUSH
14583: EMPTY
14584: LIST
14585: LIST
14586: PPUSH
14587: CALL_OW 69
14591: ST_TO_ADDR
// if not tmp then
14592: LD_VAR 0 1
14596: NOT
14597: IFFALSE 14601
// exit ;
14599: GO 14646
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
14601: LD_VAR 0 1
14605: PUSH
14606: LD_INT 1
14608: PPUSH
14609: LD_VAR 0 1
14613: PPUSH
14614: CALL_OW 12
14618: ARRAY
14619: PPUSH
14620: LD_INT 1
14622: PPUSH
14623: LD_INT 4
14625: PPUSH
14626: CALL_OW 12
14630: PPUSH
14631: LD_INT 3000
14633: PPUSH
14634: LD_INT 9000
14636: PPUSH
14637: CALL_OW 12
14641: PPUSH
14642: CALL_OW 492
// end ;
14646: PPOPN 1
14648: END
// every 0 0$1 trigger StreamModeActive and sDepot do
14649: LD_EXP 57
14653: PUSH
14654: LD_EXP 72
14658: AND
14659: IFFALSE 14679
14661: GO 14663
14663: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
14664: LD_INT 1
14666: PPUSH
14667: LD_OWVAR 2
14671: PPUSH
14672: LD_INT 0
14674: PPUSH
14675: CALL_OW 324
14679: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
14680: LD_EXP 57
14684: PUSH
14685: LD_EXP 73
14689: AND
14690: IFFALSE 14773
14692: GO 14694
14694: DISABLE
14695: LD_INT 0
14697: PPUSH
14698: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
14699: LD_ADDR_VAR 0 2
14703: PUSH
14704: LD_INT 22
14706: PUSH
14707: LD_OWVAR 2
14711: PUSH
14712: EMPTY
14713: LIST
14714: LIST
14715: PUSH
14716: LD_INT 21
14718: PUSH
14719: LD_INT 3
14721: PUSH
14722: EMPTY
14723: LIST
14724: LIST
14725: PUSH
14726: EMPTY
14727: LIST
14728: LIST
14729: PPUSH
14730: CALL_OW 69
14734: ST_TO_ADDR
// if not tmp then
14735: LD_VAR 0 2
14739: NOT
14740: IFFALSE 14744
// exit ;
14742: GO 14773
// for i in tmp do
14744: LD_ADDR_VAR 0 1
14748: PUSH
14749: LD_VAR 0 2
14753: PUSH
14754: FOR_IN
14755: IFFALSE 14771
// SetBLevel ( i , 10 ) ;
14757: LD_VAR 0 1
14761: PPUSH
14762: LD_INT 10
14764: PPUSH
14765: CALL_OW 241
14769: GO 14754
14771: POP
14772: POP
// end ;
14773: PPOPN 2
14775: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
14776: LD_EXP 57
14780: PUSH
14781: LD_EXP 74
14785: AND
14786: IFFALSE 14897
14788: GO 14790
14790: DISABLE
14791: LD_INT 0
14793: PPUSH
14794: PPUSH
14795: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
14796: LD_ADDR_VAR 0 3
14800: PUSH
14801: LD_INT 22
14803: PUSH
14804: LD_OWVAR 2
14808: PUSH
14809: EMPTY
14810: LIST
14811: LIST
14812: PUSH
14813: LD_INT 25
14815: PUSH
14816: LD_INT 1
14818: PUSH
14819: EMPTY
14820: LIST
14821: LIST
14822: PUSH
14823: EMPTY
14824: LIST
14825: LIST
14826: PPUSH
14827: CALL_OW 69
14831: ST_TO_ADDR
// if not tmp then
14832: LD_VAR 0 3
14836: NOT
14837: IFFALSE 14841
// exit ;
14839: GO 14897
// un := tmp [ rand ( 1 , tmp ) ] ;
14841: LD_ADDR_VAR 0 2
14845: PUSH
14846: LD_VAR 0 3
14850: PUSH
14851: LD_INT 1
14853: PPUSH
14854: LD_VAR 0 3
14858: PPUSH
14859: CALL_OW 12
14863: ARRAY
14864: ST_TO_ADDR
// if Crawls ( un ) then
14865: LD_VAR 0 2
14869: PPUSH
14870: CALL_OW 318
14874: IFFALSE 14885
// ComWalk ( un ) ;
14876: LD_VAR 0 2
14880: PPUSH
14881: CALL_OW 138
// SetClass ( un , class_sniper ) ;
14885: LD_VAR 0 2
14889: PPUSH
14890: LD_INT 5
14892: PPUSH
14893: CALL_OW 336
// end ;
14897: PPOPN 3
14899: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
14900: LD_EXP 57
14904: PUSH
14905: LD_EXP 75
14909: AND
14910: PUSH
14911: LD_OWVAR 67
14915: PUSH
14916: LD_INT 3
14918: LESS
14919: AND
14920: IFFALSE 14939
14922: GO 14924
14924: DISABLE
// Difficulty := Difficulty + 1 ;
14925: LD_ADDR_OWVAR 67
14929: PUSH
14930: LD_OWVAR 67
14934: PUSH
14935: LD_INT 1
14937: PLUS
14938: ST_TO_ADDR
14939: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
14940: LD_EXP 57
14944: PUSH
14945: LD_EXP 76
14949: AND
14950: IFFALSE 15053
14952: GO 14954
14954: DISABLE
14955: LD_INT 0
14957: PPUSH
// begin for i := 1 to 5 do
14958: LD_ADDR_VAR 0 1
14962: PUSH
14963: DOUBLE
14964: LD_INT 1
14966: DEC
14967: ST_TO_ADDR
14968: LD_INT 5
14970: PUSH
14971: FOR_TO
14972: IFFALSE 15051
// begin uc_nation := nation_nature ;
14974: LD_ADDR_OWVAR 21
14978: PUSH
14979: LD_INT 0
14981: ST_TO_ADDR
// uc_side := 0 ;
14982: LD_ADDR_OWVAR 20
14986: PUSH
14987: LD_INT 0
14989: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
14990: LD_ADDR_OWVAR 29
14994: PUSH
14995: LD_INT 12
14997: PUSH
14998: LD_INT 12
15000: PUSH
15001: EMPTY
15002: LIST
15003: LIST
15004: ST_TO_ADDR
// hc_agressivity := 20 ;
15005: LD_ADDR_OWVAR 35
15009: PUSH
15010: LD_INT 20
15012: ST_TO_ADDR
// hc_class := class_tiger ;
15013: LD_ADDR_OWVAR 28
15017: PUSH
15018: LD_INT 14
15020: ST_TO_ADDR
// hc_gallery :=  ;
15021: LD_ADDR_OWVAR 33
15025: PUSH
15026: LD_STRING 
15028: ST_TO_ADDR
// hc_name :=  ;
15029: LD_ADDR_OWVAR 26
15033: PUSH
15034: LD_STRING 
15036: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
15037: CALL_OW 44
15041: PPUSH
15042: LD_INT 0
15044: PPUSH
15045: CALL_OW 51
// end ;
15049: GO 14971
15051: POP
15052: POP
// end ;
15053: PPOPN 1
15055: END
// every 0 0$1 trigger StreamModeActive and sBomb do
15056: LD_EXP 57
15060: PUSH
15061: LD_EXP 77
15065: AND
15066: IFFALSE 15075
15068: GO 15070
15070: DISABLE
// StreamSibBomb ;
15071: CALL 15076 0 0
15075: END
// export function StreamSibBomb ; var i , x , y ; begin
15076: LD_INT 0
15078: PPUSH
15079: PPUSH
15080: PPUSH
15081: PPUSH
// result := false ;
15082: LD_ADDR_VAR 0 1
15086: PUSH
15087: LD_INT 0
15089: ST_TO_ADDR
// for i := 1 to 16 do
15090: LD_ADDR_VAR 0 2
15094: PUSH
15095: DOUBLE
15096: LD_INT 1
15098: DEC
15099: ST_TO_ADDR
15100: LD_INT 16
15102: PUSH
15103: FOR_TO
15104: IFFALSE 15303
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
15106: LD_ADDR_VAR 0 3
15110: PUSH
15111: LD_INT 10
15113: PUSH
15114: LD_INT 20
15116: PUSH
15117: LD_INT 30
15119: PUSH
15120: LD_INT 40
15122: PUSH
15123: LD_INT 50
15125: PUSH
15126: LD_INT 60
15128: PUSH
15129: LD_INT 70
15131: PUSH
15132: LD_INT 80
15134: PUSH
15135: LD_INT 90
15137: PUSH
15138: LD_INT 100
15140: PUSH
15141: LD_INT 110
15143: PUSH
15144: LD_INT 120
15146: PUSH
15147: LD_INT 130
15149: PUSH
15150: LD_INT 140
15152: PUSH
15153: LD_INT 150
15155: PUSH
15156: EMPTY
15157: LIST
15158: LIST
15159: LIST
15160: LIST
15161: LIST
15162: LIST
15163: LIST
15164: LIST
15165: LIST
15166: LIST
15167: LIST
15168: LIST
15169: LIST
15170: LIST
15171: LIST
15172: PUSH
15173: LD_INT 1
15175: PPUSH
15176: LD_INT 15
15178: PPUSH
15179: CALL_OW 12
15183: ARRAY
15184: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
15185: LD_ADDR_VAR 0 4
15189: PUSH
15190: LD_INT 10
15192: PUSH
15193: LD_INT 20
15195: PUSH
15196: LD_INT 30
15198: PUSH
15199: LD_INT 40
15201: PUSH
15202: LD_INT 50
15204: PUSH
15205: LD_INT 60
15207: PUSH
15208: LD_INT 70
15210: PUSH
15211: LD_INT 80
15213: PUSH
15214: LD_INT 90
15216: PUSH
15217: LD_INT 100
15219: PUSH
15220: LD_INT 110
15222: PUSH
15223: LD_INT 120
15225: PUSH
15226: LD_INT 130
15228: PUSH
15229: LD_INT 140
15231: PUSH
15232: LD_INT 150
15234: PUSH
15235: EMPTY
15236: LIST
15237: LIST
15238: LIST
15239: LIST
15240: LIST
15241: LIST
15242: LIST
15243: LIST
15244: LIST
15245: LIST
15246: LIST
15247: LIST
15248: LIST
15249: LIST
15250: LIST
15251: PUSH
15252: LD_INT 1
15254: PPUSH
15255: LD_INT 15
15257: PPUSH
15258: CALL_OW 12
15262: ARRAY
15263: ST_TO_ADDR
// if ValidHex ( x , y ) then
15264: LD_VAR 0 3
15268: PPUSH
15269: LD_VAR 0 4
15273: PPUSH
15274: CALL_OW 488
15278: IFFALSE 15301
// begin result := [ x , y ] ;
15280: LD_ADDR_VAR 0 1
15284: PUSH
15285: LD_VAR 0 3
15289: PUSH
15290: LD_VAR 0 4
15294: PUSH
15295: EMPTY
15296: LIST
15297: LIST
15298: ST_TO_ADDR
// break ;
15299: GO 15303
// end ; end ;
15301: GO 15103
15303: POP
15304: POP
// if result then
15305: LD_VAR 0 1
15309: IFFALSE 15369
// begin ToLua ( playSibBomb() ) ;
15311: LD_STRING playSibBomb()
15313: PPUSH
15314: CALL_OW 559
// wait ( 0 0$14 ) ;
15318: LD_INT 490
15320: PPUSH
15321: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
15325: LD_VAR 0 1
15329: PUSH
15330: LD_INT 1
15332: ARRAY
15333: PPUSH
15334: LD_VAR 0 1
15338: PUSH
15339: LD_INT 2
15341: ARRAY
15342: PPUSH
15343: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
15347: LD_VAR 0 1
15351: PUSH
15352: LD_INT 1
15354: ARRAY
15355: PPUSH
15356: LD_VAR 0 1
15360: PUSH
15361: LD_INT 2
15363: ARRAY
15364: PPUSH
15365: CALL_OW 429
// end ; end ;
15369: LD_VAR 0 1
15373: RET
// every 0 0$1 trigger StreamModeActive and sReset do
15374: LD_EXP 57
15378: PUSH
15379: LD_EXP 79
15383: AND
15384: IFFALSE 15396
15386: GO 15388
15388: DISABLE
// YouLost (  ) ;
15389: LD_STRING 
15391: PPUSH
15392: CALL_OW 104
15396: END
// every 0 0$1 trigger StreamModeActive and sFog do
15397: LD_EXP 57
15401: PUSH
15402: LD_EXP 78
15406: AND
15407: IFFALSE 15421
15409: GO 15411
15411: DISABLE
// FogOff ( your_side ) ;
15412: LD_OWVAR 2
15416: PPUSH
15417: CALL_OW 344
15421: END
// every 0 0$1 trigger StreamModeActive and sSun do
15422: LD_EXP 57
15426: PUSH
15427: LD_EXP 80
15431: AND
15432: IFFALSE 15460
15434: GO 15436
15436: DISABLE
// begin solar_recharge_percent := 0 ;
15437: LD_ADDR_OWVAR 79
15441: PUSH
15442: LD_INT 0
15444: ST_TO_ADDR
// wait ( 5 5$00 ) ;
15445: LD_INT 10500
15447: PPUSH
15448: CALL_OW 67
// solar_recharge_percent := 100 ;
15452: LD_ADDR_OWVAR 79
15456: PUSH
15457: LD_INT 100
15459: ST_TO_ADDR
// end ;
15460: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
15461: LD_EXP 57
15465: PUSH
15466: LD_EXP 81
15470: AND
15471: IFFALSE 15710
15473: GO 15475
15475: DISABLE
15476: LD_INT 0
15478: PPUSH
15479: PPUSH
15480: PPUSH
// begin tmp := [ ] ;
15481: LD_ADDR_VAR 0 3
15485: PUSH
15486: EMPTY
15487: ST_TO_ADDR
// for i := 1 to 6 do
15488: LD_ADDR_VAR 0 1
15492: PUSH
15493: DOUBLE
15494: LD_INT 1
15496: DEC
15497: ST_TO_ADDR
15498: LD_INT 6
15500: PUSH
15501: FOR_TO
15502: IFFALSE 15607
// begin uc_nation := nation_nature ;
15504: LD_ADDR_OWVAR 21
15508: PUSH
15509: LD_INT 0
15511: ST_TO_ADDR
// uc_side := 0 ;
15512: LD_ADDR_OWVAR 20
15516: PUSH
15517: LD_INT 0
15519: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
15520: LD_ADDR_OWVAR 29
15524: PUSH
15525: LD_INT 12
15527: PUSH
15528: LD_INT 12
15530: PUSH
15531: EMPTY
15532: LIST
15533: LIST
15534: ST_TO_ADDR
// hc_agressivity := 20 ;
15535: LD_ADDR_OWVAR 35
15539: PUSH
15540: LD_INT 20
15542: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
15543: LD_ADDR_OWVAR 28
15547: PUSH
15548: LD_INT 17
15550: ST_TO_ADDR
// hc_gallery :=  ;
15551: LD_ADDR_OWVAR 33
15555: PUSH
15556: LD_STRING 
15558: ST_TO_ADDR
// hc_name :=  ;
15559: LD_ADDR_OWVAR 26
15563: PUSH
15564: LD_STRING 
15566: ST_TO_ADDR
// un := CreateHuman ;
15567: LD_ADDR_VAR 0 2
15571: PUSH
15572: CALL_OW 44
15576: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
15577: LD_VAR 0 2
15581: PPUSH
15582: LD_INT 1
15584: PPUSH
15585: CALL_OW 51
// tmp := tmp ^ un ;
15589: LD_ADDR_VAR 0 3
15593: PUSH
15594: LD_VAR 0 3
15598: PUSH
15599: LD_VAR 0 2
15603: ADD
15604: ST_TO_ADDR
// end ;
15605: GO 15501
15607: POP
15608: POP
// repeat wait ( 0 0$1 ) ;
15609: LD_INT 35
15611: PPUSH
15612: CALL_OW 67
// for un in tmp do
15616: LD_ADDR_VAR 0 2
15620: PUSH
15621: LD_VAR 0 3
15625: PUSH
15626: FOR_IN
15627: IFFALSE 15701
// begin if IsDead ( un ) then
15629: LD_VAR 0 2
15633: PPUSH
15634: CALL_OW 301
15638: IFFALSE 15658
// begin tmp := tmp diff un ;
15640: LD_ADDR_VAR 0 3
15644: PUSH
15645: LD_VAR 0 3
15649: PUSH
15650: LD_VAR 0 2
15654: DIFF
15655: ST_TO_ADDR
// continue ;
15656: GO 15626
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
15658: LD_VAR 0 2
15662: PPUSH
15663: LD_INT 3
15665: PUSH
15666: LD_INT 22
15668: PUSH
15669: LD_INT 0
15671: PUSH
15672: EMPTY
15673: LIST
15674: LIST
15675: PUSH
15676: EMPTY
15677: LIST
15678: LIST
15679: PPUSH
15680: CALL_OW 69
15684: PPUSH
15685: LD_VAR 0 2
15689: PPUSH
15690: CALL_OW 74
15694: PPUSH
15695: CALL_OW 115
// end ;
15699: GO 15626
15701: POP
15702: POP
// until not tmp ;
15703: LD_VAR 0 3
15707: NOT
15708: IFFALSE 15609
// end ;
15710: PPOPN 3
15712: END
// every 0 0$1 trigger StreamModeActive and sTroll do
15713: LD_EXP 57
15717: PUSH
15718: LD_EXP 82
15722: AND
15723: IFFALSE 15777
15725: GO 15727
15727: DISABLE
// begin ToLua ( displayTroll(); ) ;
15728: LD_STRING displayTroll();
15730: PPUSH
15731: CALL_OW 559
// wait ( 3 3$00 ) ;
15735: LD_INT 6300
15737: PPUSH
15738: CALL_OW 67
// ToLua ( hideTroll(); ) ;
15742: LD_STRING hideTroll();
15744: PPUSH
15745: CALL_OW 559
// wait ( 1 1$00 ) ;
15749: LD_INT 2100
15751: PPUSH
15752: CALL_OW 67
// ToLua ( displayTroll(); ) ;
15756: LD_STRING displayTroll();
15758: PPUSH
15759: CALL_OW 559
// wait ( 1 1$00 ) ;
15763: LD_INT 2100
15765: PPUSH
15766: CALL_OW 67
// ToLua ( hideTroll(); ) ;
15770: LD_STRING hideTroll();
15772: PPUSH
15773: CALL_OW 559
// end ;
15777: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
15778: LD_EXP 57
15782: PUSH
15783: LD_EXP 83
15787: AND
15788: IFFALSE 15851
15790: GO 15792
15792: DISABLE
15793: LD_INT 0
15795: PPUSH
// begin p := 0 ;
15796: LD_ADDR_VAR 0 1
15800: PUSH
15801: LD_INT 0
15803: ST_TO_ADDR
// repeat game_speed := 1 ;
15804: LD_ADDR_OWVAR 65
15808: PUSH
15809: LD_INT 1
15811: ST_TO_ADDR
// wait ( 0 0$1 ) ;
15812: LD_INT 35
15814: PPUSH
15815: CALL_OW 67
// p := p + 1 ;
15819: LD_ADDR_VAR 0 1
15823: PUSH
15824: LD_VAR 0 1
15828: PUSH
15829: LD_INT 1
15831: PLUS
15832: ST_TO_ADDR
// until p >= 60 ;
15833: LD_VAR 0 1
15837: PUSH
15838: LD_INT 60
15840: GREATEREQUAL
15841: IFFALSE 15804
// game_speed := 4 ;
15843: LD_ADDR_OWVAR 65
15847: PUSH
15848: LD_INT 4
15850: ST_TO_ADDR
// end ;
15851: PPOPN 1
15853: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
15854: LD_EXP 57
15858: PUSH
15859: LD_EXP 84
15863: AND
15864: IFFALSE 16010
15866: GO 15868
15868: DISABLE
15869: LD_INT 0
15871: PPUSH
15872: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
15873: LD_ADDR_VAR 0 1
15877: PUSH
15878: LD_INT 22
15880: PUSH
15881: LD_OWVAR 2
15885: PUSH
15886: EMPTY
15887: LIST
15888: LIST
15889: PUSH
15890: LD_INT 2
15892: PUSH
15893: LD_INT 30
15895: PUSH
15896: LD_INT 0
15898: PUSH
15899: EMPTY
15900: LIST
15901: LIST
15902: PUSH
15903: LD_INT 30
15905: PUSH
15906: LD_INT 1
15908: PUSH
15909: EMPTY
15910: LIST
15911: LIST
15912: PUSH
15913: EMPTY
15914: LIST
15915: LIST
15916: LIST
15917: PUSH
15918: EMPTY
15919: LIST
15920: LIST
15921: PPUSH
15922: CALL_OW 69
15926: ST_TO_ADDR
// if not depot then
15927: LD_VAR 0 1
15931: NOT
15932: IFFALSE 15936
// exit ;
15934: GO 16010
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
15936: LD_ADDR_VAR 0 2
15940: PUSH
15941: LD_VAR 0 1
15945: PUSH
15946: LD_INT 1
15948: PPUSH
15949: LD_VAR 0 1
15953: PPUSH
15954: CALL_OW 12
15958: ARRAY
15959: PPUSH
15960: CALL_OW 274
15964: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
15965: LD_VAR 0 2
15969: PPUSH
15970: LD_INT 1
15972: PPUSH
15973: LD_INT 0
15975: PPUSH
15976: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
15980: LD_VAR 0 2
15984: PPUSH
15985: LD_INT 2
15987: PPUSH
15988: LD_INT 0
15990: PPUSH
15991: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
15995: LD_VAR 0 2
15999: PPUSH
16000: LD_INT 3
16002: PPUSH
16003: LD_INT 0
16005: PPUSH
16006: CALL_OW 277
// end ;
16010: PPOPN 2
16012: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
16013: LD_EXP 57
16017: PUSH
16018: LD_EXP 85
16022: AND
16023: IFFALSE 16120
16025: GO 16027
16027: DISABLE
16028: LD_INT 0
16030: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
16031: LD_ADDR_VAR 0 1
16035: PUSH
16036: LD_INT 22
16038: PUSH
16039: LD_OWVAR 2
16043: PUSH
16044: EMPTY
16045: LIST
16046: LIST
16047: PUSH
16048: LD_INT 21
16050: PUSH
16051: LD_INT 1
16053: PUSH
16054: EMPTY
16055: LIST
16056: LIST
16057: PUSH
16058: LD_INT 3
16060: PUSH
16061: LD_INT 23
16063: PUSH
16064: LD_INT 0
16066: PUSH
16067: EMPTY
16068: LIST
16069: LIST
16070: PUSH
16071: EMPTY
16072: LIST
16073: LIST
16074: PUSH
16075: EMPTY
16076: LIST
16077: LIST
16078: LIST
16079: PPUSH
16080: CALL_OW 69
16084: ST_TO_ADDR
// if not tmp then
16085: LD_VAR 0 1
16089: NOT
16090: IFFALSE 16094
// exit ;
16092: GO 16120
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
16094: LD_VAR 0 1
16098: PUSH
16099: LD_INT 1
16101: PPUSH
16102: LD_VAR 0 1
16106: PPUSH
16107: CALL_OW 12
16111: ARRAY
16112: PPUSH
16113: LD_INT 200
16115: PPUSH
16116: CALL_OW 234
// end ;
16120: PPOPN 1
16122: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
16123: LD_EXP 57
16127: PUSH
16128: LD_EXP 86
16132: AND
16133: IFFALSE 16212
16135: GO 16137
16137: DISABLE
16138: LD_INT 0
16140: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
16141: LD_ADDR_VAR 0 1
16145: PUSH
16146: LD_INT 22
16148: PUSH
16149: LD_OWVAR 2
16153: PUSH
16154: EMPTY
16155: LIST
16156: LIST
16157: PUSH
16158: LD_INT 21
16160: PUSH
16161: LD_INT 2
16163: PUSH
16164: EMPTY
16165: LIST
16166: LIST
16167: PUSH
16168: EMPTY
16169: LIST
16170: LIST
16171: PPUSH
16172: CALL_OW 69
16176: ST_TO_ADDR
// if not tmp then
16177: LD_VAR 0 1
16181: NOT
16182: IFFALSE 16186
// exit ;
16184: GO 16212
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
16186: LD_VAR 0 1
16190: PUSH
16191: LD_INT 1
16193: PPUSH
16194: LD_VAR 0 1
16198: PPUSH
16199: CALL_OW 12
16203: ARRAY
16204: PPUSH
16205: LD_INT 60
16207: PPUSH
16208: CALL_OW 234
// end ;
16212: PPOPN 1
16214: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
16215: LD_EXP 57
16219: PUSH
16220: LD_EXP 87
16224: AND
16225: IFFALSE 16324
16227: GO 16229
16229: DISABLE
16230: LD_INT 0
16232: PPUSH
16233: PPUSH
// begin enable ;
16234: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
16235: LD_ADDR_VAR 0 1
16239: PUSH
16240: LD_INT 22
16242: PUSH
16243: LD_OWVAR 2
16247: PUSH
16248: EMPTY
16249: LIST
16250: LIST
16251: PUSH
16252: LD_INT 61
16254: PUSH
16255: EMPTY
16256: LIST
16257: PUSH
16258: LD_INT 33
16260: PUSH
16261: LD_INT 2
16263: PUSH
16264: EMPTY
16265: LIST
16266: LIST
16267: PUSH
16268: EMPTY
16269: LIST
16270: LIST
16271: LIST
16272: PPUSH
16273: CALL_OW 69
16277: ST_TO_ADDR
// if not tmp then
16278: LD_VAR 0 1
16282: NOT
16283: IFFALSE 16287
// exit ;
16285: GO 16324
// for i in tmp do
16287: LD_ADDR_VAR 0 2
16291: PUSH
16292: LD_VAR 0 1
16296: PUSH
16297: FOR_IN
16298: IFFALSE 16322
// if IsControledBy ( i ) then
16300: LD_VAR 0 2
16304: PPUSH
16305: CALL_OW 312
16309: IFFALSE 16320
// ComUnlink ( i ) ;
16311: LD_VAR 0 2
16315: PPUSH
16316: CALL_OW 136
16320: GO 16297
16322: POP
16323: POP
// end ;
16324: PPOPN 2
16326: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
16327: LD_EXP 57
16331: PUSH
16332: LD_EXP 88
16336: AND
16337: IFFALSE 16477
16339: GO 16341
16341: DISABLE
16342: LD_INT 0
16344: PPUSH
16345: PPUSH
// begin ToLua ( displayPowell(); ) ;
16346: LD_STRING displayPowell();
16348: PPUSH
16349: CALL_OW 559
// uc_side := 0 ;
16353: LD_ADDR_OWVAR 20
16357: PUSH
16358: LD_INT 0
16360: ST_TO_ADDR
// uc_nation := 2 ;
16361: LD_ADDR_OWVAR 21
16365: PUSH
16366: LD_INT 2
16368: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
16369: LD_ADDR_OWVAR 37
16373: PUSH
16374: LD_INT 14
16376: ST_TO_ADDR
// vc_engine := engine_siberite ;
16377: LD_ADDR_OWVAR 39
16381: PUSH
16382: LD_INT 3
16384: ST_TO_ADDR
// vc_control := control_apeman ;
16385: LD_ADDR_OWVAR 38
16389: PUSH
16390: LD_INT 5
16392: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
16393: LD_ADDR_OWVAR 40
16397: PUSH
16398: LD_INT 29
16400: ST_TO_ADDR
// un := CreateVehicle ;
16401: LD_ADDR_VAR 0 2
16405: PUSH
16406: CALL_OW 45
16410: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
16411: LD_VAR 0 2
16415: PPUSH
16416: LD_INT 1
16418: PPUSH
16419: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
16423: LD_INT 35
16425: PPUSH
16426: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
16430: LD_VAR 0 2
16434: PPUSH
16435: LD_INT 22
16437: PUSH
16438: LD_OWVAR 2
16442: PUSH
16443: EMPTY
16444: LIST
16445: LIST
16446: PPUSH
16447: CALL_OW 69
16451: PPUSH
16452: LD_VAR 0 2
16456: PPUSH
16457: CALL_OW 74
16461: PPUSH
16462: CALL_OW 115
// until IsDead ( un ) ;
16466: LD_VAR 0 2
16470: PPUSH
16471: CALL_OW 301
16475: IFFALSE 16423
// end ;
16477: PPOPN 2
16479: END
// every 0 0$1 trigger StreamModeActive and sStu do
16480: LD_EXP 57
16484: PUSH
16485: LD_EXP 96
16489: AND
16490: IFFALSE 16506
16492: GO 16494
16494: DISABLE
// begin ToLua ( displayStucuk(); ) ;
16495: LD_STRING displayStucuk();
16497: PPUSH
16498: CALL_OW 559
// ResetFog ;
16502: CALL_OW 335
// end ;
16506: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
16507: LD_EXP 57
16511: PUSH
16512: LD_EXP 89
16516: AND
16517: IFFALSE 16658
16519: GO 16521
16521: DISABLE
16522: LD_INT 0
16524: PPUSH
16525: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
16526: LD_ADDR_VAR 0 2
16530: PUSH
16531: LD_INT 22
16533: PUSH
16534: LD_OWVAR 2
16538: PUSH
16539: EMPTY
16540: LIST
16541: LIST
16542: PUSH
16543: LD_INT 21
16545: PUSH
16546: LD_INT 1
16548: PUSH
16549: EMPTY
16550: LIST
16551: LIST
16552: PUSH
16553: EMPTY
16554: LIST
16555: LIST
16556: PPUSH
16557: CALL_OW 69
16561: ST_TO_ADDR
// if not tmp then
16562: LD_VAR 0 2
16566: NOT
16567: IFFALSE 16571
// exit ;
16569: GO 16658
// un := tmp [ rand ( 1 , tmp ) ] ;
16571: LD_ADDR_VAR 0 1
16575: PUSH
16576: LD_VAR 0 2
16580: PUSH
16581: LD_INT 1
16583: PPUSH
16584: LD_VAR 0 2
16588: PPUSH
16589: CALL_OW 12
16593: ARRAY
16594: ST_TO_ADDR
// SetSide ( un , 0 ) ;
16595: LD_VAR 0 1
16599: PPUSH
16600: LD_INT 0
16602: PPUSH
16603: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
16607: LD_VAR 0 1
16611: PPUSH
16612: LD_OWVAR 3
16616: PUSH
16617: LD_VAR 0 1
16621: DIFF
16622: PPUSH
16623: LD_VAR 0 1
16627: PPUSH
16628: CALL_OW 74
16632: PPUSH
16633: CALL_OW 115
// wait ( 0 0$20 ) ;
16637: LD_INT 700
16639: PPUSH
16640: CALL_OW 67
// SetSide ( un , your_side ) ;
16644: LD_VAR 0 1
16648: PPUSH
16649: LD_OWVAR 2
16653: PPUSH
16654: CALL_OW 235
// end ;
16658: PPOPN 2
16660: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
16661: LD_EXP 57
16665: PUSH
16666: LD_EXP 90
16670: AND
16671: IFFALSE 16777
16673: GO 16675
16675: DISABLE
16676: LD_INT 0
16678: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
16679: LD_ADDR_VAR 0 1
16683: PUSH
16684: LD_INT 22
16686: PUSH
16687: LD_OWVAR 2
16691: PUSH
16692: EMPTY
16693: LIST
16694: LIST
16695: PUSH
16696: LD_INT 2
16698: PUSH
16699: LD_INT 30
16701: PUSH
16702: LD_INT 0
16704: PUSH
16705: EMPTY
16706: LIST
16707: LIST
16708: PUSH
16709: LD_INT 30
16711: PUSH
16712: LD_INT 1
16714: PUSH
16715: EMPTY
16716: LIST
16717: LIST
16718: PUSH
16719: EMPTY
16720: LIST
16721: LIST
16722: LIST
16723: PUSH
16724: EMPTY
16725: LIST
16726: LIST
16727: PPUSH
16728: CALL_OW 69
16732: ST_TO_ADDR
// if not depot then
16733: LD_VAR 0 1
16737: NOT
16738: IFFALSE 16742
// exit ;
16740: GO 16777
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
16742: LD_VAR 0 1
16746: PUSH
16747: LD_INT 1
16749: ARRAY
16750: PPUSH
16751: CALL_OW 250
16755: PPUSH
16756: LD_VAR 0 1
16760: PUSH
16761: LD_INT 1
16763: ARRAY
16764: PPUSH
16765: CALL_OW 251
16769: PPUSH
16770: LD_INT 70
16772: PPUSH
16773: CALL_OW 495
// end ;
16777: PPOPN 1
16779: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
16780: LD_EXP 57
16784: PUSH
16785: LD_EXP 91
16789: AND
16790: IFFALSE 17001
16792: GO 16794
16794: DISABLE
16795: LD_INT 0
16797: PPUSH
16798: PPUSH
16799: PPUSH
16800: PPUSH
16801: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
16802: LD_ADDR_VAR 0 5
16806: PUSH
16807: LD_INT 22
16809: PUSH
16810: LD_OWVAR 2
16814: PUSH
16815: EMPTY
16816: LIST
16817: LIST
16818: PUSH
16819: LD_INT 21
16821: PUSH
16822: LD_INT 1
16824: PUSH
16825: EMPTY
16826: LIST
16827: LIST
16828: PUSH
16829: EMPTY
16830: LIST
16831: LIST
16832: PPUSH
16833: CALL_OW 69
16837: ST_TO_ADDR
// if not tmp then
16838: LD_VAR 0 5
16842: NOT
16843: IFFALSE 16847
// exit ;
16845: GO 17001
// for i in tmp do
16847: LD_ADDR_VAR 0 1
16851: PUSH
16852: LD_VAR 0 5
16856: PUSH
16857: FOR_IN
16858: IFFALSE 16999
// begin d := rand ( 0 , 5 ) ;
16860: LD_ADDR_VAR 0 4
16864: PUSH
16865: LD_INT 0
16867: PPUSH
16868: LD_INT 5
16870: PPUSH
16871: CALL_OW 12
16875: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
16876: LD_ADDR_VAR 0 2
16880: PUSH
16881: LD_VAR 0 1
16885: PPUSH
16886: CALL_OW 250
16890: PPUSH
16891: LD_VAR 0 4
16895: PPUSH
16896: LD_INT 3
16898: PPUSH
16899: LD_INT 12
16901: PPUSH
16902: CALL_OW 12
16906: PPUSH
16907: CALL_OW 272
16911: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
16912: LD_ADDR_VAR 0 3
16916: PUSH
16917: LD_VAR 0 1
16921: PPUSH
16922: CALL_OW 251
16926: PPUSH
16927: LD_VAR 0 4
16931: PPUSH
16932: LD_INT 3
16934: PPUSH
16935: LD_INT 12
16937: PPUSH
16938: CALL_OW 12
16942: PPUSH
16943: CALL_OW 273
16947: ST_TO_ADDR
// if ValidHex ( x , y ) then
16948: LD_VAR 0 2
16952: PPUSH
16953: LD_VAR 0 3
16957: PPUSH
16958: CALL_OW 488
16962: IFFALSE 16997
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
16964: LD_VAR 0 1
16968: PPUSH
16969: LD_VAR 0 2
16973: PPUSH
16974: LD_VAR 0 3
16978: PPUSH
16979: LD_INT 3
16981: PPUSH
16982: LD_INT 6
16984: PPUSH
16985: CALL_OW 12
16989: PPUSH
16990: LD_INT 1
16992: PPUSH
16993: CALL_OW 483
// end ;
16997: GO 16857
16999: POP
17000: POP
// end ;
17001: PPOPN 5
17003: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
17004: LD_EXP 57
17008: PUSH
17009: LD_EXP 92
17013: AND
17014: IFFALSE 17108
17016: GO 17018
17018: DISABLE
17019: LD_INT 0
17021: PPUSH
17022: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
17023: LD_ADDR_VAR 0 2
17027: PUSH
17028: LD_INT 22
17030: PUSH
17031: LD_OWVAR 2
17035: PUSH
17036: EMPTY
17037: LIST
17038: LIST
17039: PUSH
17040: LD_INT 32
17042: PUSH
17043: LD_INT 1
17045: PUSH
17046: EMPTY
17047: LIST
17048: LIST
17049: PUSH
17050: LD_INT 21
17052: PUSH
17053: LD_INT 2
17055: PUSH
17056: EMPTY
17057: LIST
17058: LIST
17059: PUSH
17060: EMPTY
17061: LIST
17062: LIST
17063: LIST
17064: PPUSH
17065: CALL_OW 69
17069: ST_TO_ADDR
// if not tmp then
17070: LD_VAR 0 2
17074: NOT
17075: IFFALSE 17079
// exit ;
17077: GO 17108
// for i in tmp do
17079: LD_ADDR_VAR 0 1
17083: PUSH
17084: LD_VAR 0 2
17088: PUSH
17089: FOR_IN
17090: IFFALSE 17106
// SetFuel ( i , 0 ) ;
17092: LD_VAR 0 1
17096: PPUSH
17097: LD_INT 0
17099: PPUSH
17100: CALL_OW 240
17104: GO 17089
17106: POP
17107: POP
// end ;
17108: PPOPN 2
17110: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
17111: LD_EXP 57
17115: PUSH
17116: LD_EXP 93
17120: AND
17121: IFFALSE 17187
17123: GO 17125
17125: DISABLE
17126: LD_INT 0
17128: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
17129: LD_ADDR_VAR 0 1
17133: PUSH
17134: LD_INT 22
17136: PUSH
17137: LD_OWVAR 2
17141: PUSH
17142: EMPTY
17143: LIST
17144: LIST
17145: PUSH
17146: LD_INT 30
17148: PUSH
17149: LD_INT 29
17151: PUSH
17152: EMPTY
17153: LIST
17154: LIST
17155: PUSH
17156: EMPTY
17157: LIST
17158: LIST
17159: PPUSH
17160: CALL_OW 69
17164: ST_TO_ADDR
// if not tmp then
17165: LD_VAR 0 1
17169: NOT
17170: IFFALSE 17174
// exit ;
17172: GO 17187
// DestroyUnit ( tmp [ 1 ] ) ;
17174: LD_VAR 0 1
17178: PUSH
17179: LD_INT 1
17181: ARRAY
17182: PPUSH
17183: CALL_OW 65
// end ;
17187: PPOPN 1
17189: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
17190: LD_EXP 57
17194: PUSH
17195: LD_EXP 95
17199: AND
17200: IFFALSE 17329
17202: GO 17204
17204: DISABLE
17205: LD_INT 0
17207: PPUSH
// begin uc_side := 0 ;
17208: LD_ADDR_OWVAR 20
17212: PUSH
17213: LD_INT 0
17215: ST_TO_ADDR
// uc_nation := nation_arabian ;
17216: LD_ADDR_OWVAR 21
17220: PUSH
17221: LD_INT 2
17223: ST_TO_ADDR
// hc_gallery :=  ;
17224: LD_ADDR_OWVAR 33
17228: PUSH
17229: LD_STRING 
17231: ST_TO_ADDR
// hc_name :=  ;
17232: LD_ADDR_OWVAR 26
17236: PUSH
17237: LD_STRING 
17239: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
17240: LD_INT 1
17242: PPUSH
17243: LD_INT 11
17245: PPUSH
17246: LD_INT 10
17248: PPUSH
17249: CALL_OW 380
// un := CreateHuman ;
17253: LD_ADDR_VAR 0 1
17257: PUSH
17258: CALL_OW 44
17262: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
17263: LD_VAR 0 1
17267: PPUSH
17268: LD_INT 1
17270: PPUSH
17271: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
17275: LD_INT 35
17277: PPUSH
17278: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
17282: LD_VAR 0 1
17286: PPUSH
17287: LD_INT 22
17289: PUSH
17290: LD_OWVAR 2
17294: PUSH
17295: EMPTY
17296: LIST
17297: LIST
17298: PPUSH
17299: CALL_OW 69
17303: PPUSH
17304: LD_VAR 0 1
17308: PPUSH
17309: CALL_OW 74
17313: PPUSH
17314: CALL_OW 115
// until IsDead ( un ) ;
17318: LD_VAR 0 1
17322: PPUSH
17323: CALL_OW 301
17327: IFFALSE 17275
// end ;
17329: PPOPN 1
17331: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
17332: LD_EXP 57
17336: PUSH
17337: LD_EXP 97
17341: AND
17342: IFFALSE 17354
17344: GO 17346
17346: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
17347: LD_STRING earthquake(getX(game), 0, 32)
17349: PPUSH
17350: CALL_OW 559
17354: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
17355: LD_EXP 57
17359: PUSH
17360: LD_EXP 98
17364: AND
17365: IFFALSE 17456
17367: GO 17369
17369: DISABLE
17370: LD_INT 0
17372: PPUSH
// begin enable ;
17373: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
17374: LD_ADDR_VAR 0 1
17378: PUSH
17379: LD_INT 22
17381: PUSH
17382: LD_OWVAR 2
17386: PUSH
17387: EMPTY
17388: LIST
17389: LIST
17390: PUSH
17391: LD_INT 21
17393: PUSH
17394: LD_INT 2
17396: PUSH
17397: EMPTY
17398: LIST
17399: LIST
17400: PUSH
17401: LD_INT 33
17403: PUSH
17404: LD_INT 3
17406: PUSH
17407: EMPTY
17408: LIST
17409: LIST
17410: PUSH
17411: EMPTY
17412: LIST
17413: LIST
17414: LIST
17415: PPUSH
17416: CALL_OW 69
17420: ST_TO_ADDR
// if not tmp then
17421: LD_VAR 0 1
17425: NOT
17426: IFFALSE 17430
// exit ;
17428: GO 17456
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
17430: LD_VAR 0 1
17434: PUSH
17435: LD_INT 1
17437: PPUSH
17438: LD_VAR 0 1
17442: PPUSH
17443: CALL_OW 12
17447: ARRAY
17448: PPUSH
17449: LD_INT 1
17451: PPUSH
17452: CALL_OW 234
// end ;
17456: PPOPN 1
17458: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
17459: LD_EXP 57
17463: PUSH
17464: LD_EXP 99
17468: AND
17469: IFFALSE 17610
17471: GO 17473
17473: DISABLE
17474: LD_INT 0
17476: PPUSH
17477: PPUSH
17478: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
17479: LD_ADDR_VAR 0 3
17483: PUSH
17484: LD_INT 22
17486: PUSH
17487: LD_OWVAR 2
17491: PUSH
17492: EMPTY
17493: LIST
17494: LIST
17495: PUSH
17496: LD_INT 25
17498: PUSH
17499: LD_INT 1
17501: PUSH
17502: EMPTY
17503: LIST
17504: LIST
17505: PUSH
17506: EMPTY
17507: LIST
17508: LIST
17509: PPUSH
17510: CALL_OW 69
17514: ST_TO_ADDR
// if not tmp then
17515: LD_VAR 0 3
17519: NOT
17520: IFFALSE 17524
// exit ;
17522: GO 17610
// un := tmp [ rand ( 1 , tmp ) ] ;
17524: LD_ADDR_VAR 0 2
17528: PUSH
17529: LD_VAR 0 3
17533: PUSH
17534: LD_INT 1
17536: PPUSH
17537: LD_VAR 0 3
17541: PPUSH
17542: CALL_OW 12
17546: ARRAY
17547: ST_TO_ADDR
// if Crawls ( un ) then
17548: LD_VAR 0 2
17552: PPUSH
17553: CALL_OW 318
17557: IFFALSE 17568
// ComWalk ( un ) ;
17559: LD_VAR 0 2
17563: PPUSH
17564: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
17568: LD_VAR 0 2
17572: PPUSH
17573: LD_INT 9
17575: PPUSH
17576: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
17580: LD_INT 28
17582: PPUSH
17583: LD_OWVAR 2
17587: PPUSH
17588: LD_INT 2
17590: PPUSH
17591: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
17595: LD_INT 29
17597: PPUSH
17598: LD_OWVAR 2
17602: PPUSH
17603: LD_INT 2
17605: PPUSH
17606: CALL_OW 322
// end ;
17610: PPOPN 3
17612: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
17613: LD_EXP 57
17617: PUSH
17618: LD_EXP 100
17622: AND
17623: IFFALSE 17734
17625: GO 17627
17627: DISABLE
17628: LD_INT 0
17630: PPUSH
17631: PPUSH
17632: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
17633: LD_ADDR_VAR 0 3
17637: PUSH
17638: LD_INT 22
17640: PUSH
17641: LD_OWVAR 2
17645: PUSH
17646: EMPTY
17647: LIST
17648: LIST
17649: PUSH
17650: LD_INT 25
17652: PUSH
17653: LD_INT 1
17655: PUSH
17656: EMPTY
17657: LIST
17658: LIST
17659: PUSH
17660: EMPTY
17661: LIST
17662: LIST
17663: PPUSH
17664: CALL_OW 69
17668: ST_TO_ADDR
// if not tmp then
17669: LD_VAR 0 3
17673: NOT
17674: IFFALSE 17678
// exit ;
17676: GO 17734
// un := tmp [ rand ( 1 , tmp ) ] ;
17678: LD_ADDR_VAR 0 2
17682: PUSH
17683: LD_VAR 0 3
17687: PUSH
17688: LD_INT 1
17690: PPUSH
17691: LD_VAR 0 3
17695: PPUSH
17696: CALL_OW 12
17700: ARRAY
17701: ST_TO_ADDR
// if Crawls ( un ) then
17702: LD_VAR 0 2
17706: PPUSH
17707: CALL_OW 318
17711: IFFALSE 17722
// ComWalk ( un ) ;
17713: LD_VAR 0 2
17717: PPUSH
17718: CALL_OW 138
// SetClass ( un , class_mortar ) ;
17722: LD_VAR 0 2
17726: PPUSH
17727: LD_INT 8
17729: PPUSH
17730: CALL_OW 336
// end ;
17734: PPOPN 3
17736: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
17737: LD_EXP 57
17741: PUSH
17742: LD_EXP 101
17746: AND
17747: IFFALSE 17891
17749: GO 17751
17751: DISABLE
17752: LD_INT 0
17754: PPUSH
17755: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
17756: LD_ADDR_VAR 0 2
17760: PUSH
17761: LD_INT 22
17763: PUSH
17764: LD_OWVAR 2
17768: PUSH
17769: EMPTY
17770: LIST
17771: LIST
17772: PUSH
17773: LD_INT 21
17775: PUSH
17776: LD_INT 2
17778: PUSH
17779: EMPTY
17780: LIST
17781: LIST
17782: PUSH
17783: LD_INT 2
17785: PUSH
17786: LD_INT 34
17788: PUSH
17789: LD_INT 12
17791: PUSH
17792: EMPTY
17793: LIST
17794: LIST
17795: PUSH
17796: LD_INT 34
17798: PUSH
17799: LD_INT 51
17801: PUSH
17802: EMPTY
17803: LIST
17804: LIST
17805: PUSH
17806: LD_INT 34
17808: PUSH
17809: LD_INT 32
17811: PUSH
17812: EMPTY
17813: LIST
17814: LIST
17815: PUSH
17816: EMPTY
17817: LIST
17818: LIST
17819: LIST
17820: LIST
17821: PUSH
17822: EMPTY
17823: LIST
17824: LIST
17825: LIST
17826: PPUSH
17827: CALL_OW 69
17831: ST_TO_ADDR
// if not tmp then
17832: LD_VAR 0 2
17836: NOT
17837: IFFALSE 17841
// exit ;
17839: GO 17891
// for i in tmp do
17841: LD_ADDR_VAR 0 1
17845: PUSH
17846: LD_VAR 0 2
17850: PUSH
17851: FOR_IN
17852: IFFALSE 17889
// if GetCargo ( i , mat_artifact ) = 0 then
17854: LD_VAR 0 1
17858: PPUSH
17859: LD_INT 4
17861: PPUSH
17862: CALL_OW 289
17866: PUSH
17867: LD_INT 0
17869: EQUAL
17870: IFFALSE 17887
// SetCargo ( i , mat_siberit , 100 ) ;
17872: LD_VAR 0 1
17876: PPUSH
17877: LD_INT 3
17879: PPUSH
17880: LD_INT 100
17882: PPUSH
17883: CALL_OW 290
17887: GO 17851
17889: POP
17890: POP
// end ;
17891: PPOPN 2
17893: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
17894: LD_EXP 57
17898: PUSH
17899: LD_EXP 102
17903: AND
17904: IFFALSE 18057
17906: GO 17908
17908: DISABLE
17909: LD_INT 0
17911: PPUSH
17912: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
17913: LD_ADDR_VAR 0 2
17917: PUSH
17918: LD_INT 22
17920: PUSH
17921: LD_OWVAR 2
17925: PUSH
17926: EMPTY
17927: LIST
17928: LIST
17929: PPUSH
17930: CALL_OW 69
17934: ST_TO_ADDR
// if not tmp then
17935: LD_VAR 0 2
17939: NOT
17940: IFFALSE 17944
// exit ;
17942: GO 18057
// for i := 1 to 2 do
17944: LD_ADDR_VAR 0 1
17948: PUSH
17949: DOUBLE
17950: LD_INT 1
17952: DEC
17953: ST_TO_ADDR
17954: LD_INT 2
17956: PUSH
17957: FOR_TO
17958: IFFALSE 18055
// begin uc_side := your_side ;
17960: LD_ADDR_OWVAR 20
17964: PUSH
17965: LD_OWVAR 2
17969: ST_TO_ADDR
// uc_nation := nation_american ;
17970: LD_ADDR_OWVAR 21
17974: PUSH
17975: LD_INT 1
17977: ST_TO_ADDR
// vc_chassis := us_morphling ;
17978: LD_ADDR_OWVAR 37
17982: PUSH
17983: LD_INT 5
17985: ST_TO_ADDR
// vc_engine := engine_siberite ;
17986: LD_ADDR_OWVAR 39
17990: PUSH
17991: LD_INT 3
17993: ST_TO_ADDR
// vc_control := control_computer ;
17994: LD_ADDR_OWVAR 38
17998: PUSH
17999: LD_INT 3
18001: ST_TO_ADDR
// vc_weapon := us_double_laser ;
18002: LD_ADDR_OWVAR 40
18006: PUSH
18007: LD_INT 10
18009: ST_TO_ADDR
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) ;
18010: CALL_OW 45
18014: PPUSH
18015: LD_VAR 0 2
18019: PUSH
18020: LD_INT 1
18022: ARRAY
18023: PPUSH
18024: CALL_OW 250
18028: PPUSH
18029: LD_VAR 0 2
18033: PUSH
18034: LD_INT 1
18036: ARRAY
18037: PPUSH
18038: CALL_OW 251
18042: PPUSH
18043: LD_INT 12
18045: PPUSH
18046: LD_INT 1
18048: PPUSH
18049: CALL_OW 50
// end ;
18053: GO 17957
18055: POP
18056: POP
// end ;
18057: PPOPN 2
18059: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
18060: LD_EXP 57
18064: PUSH
18065: LD_EXP 103
18069: AND
18070: IFFALSE 18292
18072: GO 18074
18074: DISABLE
18075: LD_INT 0
18077: PPUSH
18078: PPUSH
18079: PPUSH
18080: PPUSH
18081: PPUSH
18082: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
18083: LD_ADDR_VAR 0 6
18087: PUSH
18088: LD_INT 22
18090: PUSH
18091: LD_OWVAR 2
18095: PUSH
18096: EMPTY
18097: LIST
18098: LIST
18099: PUSH
18100: LD_INT 21
18102: PUSH
18103: LD_INT 1
18105: PUSH
18106: EMPTY
18107: LIST
18108: LIST
18109: PUSH
18110: LD_INT 3
18112: PUSH
18113: LD_INT 23
18115: PUSH
18116: LD_INT 0
18118: PUSH
18119: EMPTY
18120: LIST
18121: LIST
18122: PUSH
18123: EMPTY
18124: LIST
18125: LIST
18126: PUSH
18127: EMPTY
18128: LIST
18129: LIST
18130: LIST
18131: PPUSH
18132: CALL_OW 69
18136: ST_TO_ADDR
// if not tmp then
18137: LD_VAR 0 6
18141: NOT
18142: IFFALSE 18146
// exit ;
18144: GO 18292
// s1 := rand ( 1 , 4 ) ;
18146: LD_ADDR_VAR 0 2
18150: PUSH
18151: LD_INT 1
18153: PPUSH
18154: LD_INT 4
18156: PPUSH
18157: CALL_OW 12
18161: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
18162: LD_ADDR_VAR 0 4
18166: PUSH
18167: LD_VAR 0 6
18171: PUSH
18172: LD_INT 1
18174: ARRAY
18175: PPUSH
18176: LD_VAR 0 2
18180: PPUSH
18181: CALL_OW 259
18185: ST_TO_ADDR
// if s1 = 1 then
18186: LD_VAR 0 2
18190: PUSH
18191: LD_INT 1
18193: EQUAL
18194: IFFALSE 18214
// s2 := rand ( 2 , 4 ) else
18196: LD_ADDR_VAR 0 3
18200: PUSH
18201: LD_INT 2
18203: PPUSH
18204: LD_INT 4
18206: PPUSH
18207: CALL_OW 12
18211: ST_TO_ADDR
18212: GO 18222
// s2 := 1 ;
18214: LD_ADDR_VAR 0 3
18218: PUSH
18219: LD_INT 1
18221: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
18222: LD_ADDR_VAR 0 5
18226: PUSH
18227: LD_VAR 0 6
18231: PUSH
18232: LD_INT 1
18234: ARRAY
18235: PPUSH
18236: LD_VAR 0 3
18240: PPUSH
18241: CALL_OW 259
18245: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
18246: LD_VAR 0 6
18250: PUSH
18251: LD_INT 1
18253: ARRAY
18254: PPUSH
18255: LD_VAR 0 2
18259: PPUSH
18260: LD_VAR 0 5
18264: PPUSH
18265: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
18269: LD_VAR 0 6
18273: PUSH
18274: LD_INT 1
18276: ARRAY
18277: PPUSH
18278: LD_VAR 0 3
18282: PPUSH
18283: LD_VAR 0 4
18287: PPUSH
18288: CALL_OW 237
// end ;
18292: PPOPN 6
18294: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
18295: LD_EXP 57
18299: PUSH
18300: LD_EXP 104
18304: AND
18305: IFFALSE 18384
18307: GO 18309
18309: DISABLE
18310: LD_INT 0
18312: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
18313: LD_ADDR_VAR 0 1
18317: PUSH
18318: LD_INT 22
18320: PUSH
18321: LD_OWVAR 2
18325: PUSH
18326: EMPTY
18327: LIST
18328: LIST
18329: PUSH
18330: LD_INT 30
18332: PUSH
18333: LD_INT 3
18335: PUSH
18336: EMPTY
18337: LIST
18338: LIST
18339: PUSH
18340: EMPTY
18341: LIST
18342: LIST
18343: PPUSH
18344: CALL_OW 69
18348: ST_TO_ADDR
// if not tmp then
18349: LD_VAR 0 1
18353: NOT
18354: IFFALSE 18358
// exit ;
18356: GO 18384
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
18358: LD_VAR 0 1
18362: PUSH
18363: LD_INT 1
18365: PPUSH
18366: LD_VAR 0 1
18370: PPUSH
18371: CALL_OW 12
18375: ARRAY
18376: PPUSH
18377: LD_INT 1
18379: PPUSH
18380: CALL_OW 234
// end ;
18384: PPOPN 1
18386: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
18387: LD_EXP 57
18391: PUSH
18392: LD_EXP 105
18396: AND
18397: IFFALSE 18509
18399: GO 18401
18401: DISABLE
18402: LD_INT 0
18404: PPUSH
18405: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
18406: LD_ADDR_VAR 0 2
18410: PUSH
18411: LD_INT 22
18413: PUSH
18414: LD_OWVAR 2
18418: PUSH
18419: EMPTY
18420: LIST
18421: LIST
18422: PUSH
18423: LD_INT 2
18425: PUSH
18426: LD_INT 30
18428: PUSH
18429: LD_INT 27
18431: PUSH
18432: EMPTY
18433: LIST
18434: LIST
18435: PUSH
18436: LD_INT 30
18438: PUSH
18439: LD_INT 26
18441: PUSH
18442: EMPTY
18443: LIST
18444: LIST
18445: PUSH
18446: LD_INT 30
18448: PUSH
18449: LD_INT 28
18451: PUSH
18452: EMPTY
18453: LIST
18454: LIST
18455: PUSH
18456: EMPTY
18457: LIST
18458: LIST
18459: LIST
18460: LIST
18461: PUSH
18462: EMPTY
18463: LIST
18464: LIST
18465: PPUSH
18466: CALL_OW 69
18470: ST_TO_ADDR
// if not tmp then
18471: LD_VAR 0 2
18475: NOT
18476: IFFALSE 18480
// exit ;
18478: GO 18509
// for i in tmp do
18480: LD_ADDR_VAR 0 1
18484: PUSH
18485: LD_VAR 0 2
18489: PUSH
18490: FOR_IN
18491: IFFALSE 18507
// SetLives ( i , 1 ) ;
18493: LD_VAR 0 1
18497: PPUSH
18498: LD_INT 1
18500: PPUSH
18501: CALL_OW 234
18505: GO 18490
18507: POP
18508: POP
// end ;
18509: PPOPN 2
18511: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
18512: LD_EXP 57
18516: PUSH
18517: LD_EXP 106
18521: AND
18522: IFFALSE 18796
18524: GO 18526
18526: DISABLE
18527: LD_INT 0
18529: PPUSH
18530: PPUSH
18531: PPUSH
// begin i := rand ( 1 , 7 ) ;
18532: LD_ADDR_VAR 0 1
18536: PUSH
18537: LD_INT 1
18539: PPUSH
18540: LD_INT 7
18542: PPUSH
18543: CALL_OW 12
18547: ST_TO_ADDR
// case i of 1 :
18548: LD_VAR 0 1
18552: PUSH
18553: LD_INT 1
18555: DOUBLE
18556: EQUAL
18557: IFTRUE 18561
18559: GO 18571
18561: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
18562: LD_STRING earthquake(getX(game), 0, 32)
18564: PPUSH
18565: CALL_OW 559
18569: GO 18796
18571: LD_INT 2
18573: DOUBLE
18574: EQUAL
18575: IFTRUE 18579
18577: GO 18593
18579: POP
// begin ToLua ( displayStucuk(); ) ;
18580: LD_STRING displayStucuk();
18582: PPUSH
18583: CALL_OW 559
// ResetFog ;
18587: CALL_OW 335
// end ; 3 :
18591: GO 18796
18593: LD_INT 3
18595: DOUBLE
18596: EQUAL
18597: IFTRUE 18601
18599: GO 18705
18601: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
18602: LD_ADDR_VAR 0 2
18606: PUSH
18607: LD_INT 22
18609: PUSH
18610: LD_OWVAR 2
18614: PUSH
18615: EMPTY
18616: LIST
18617: LIST
18618: PUSH
18619: LD_INT 25
18621: PUSH
18622: LD_INT 1
18624: PUSH
18625: EMPTY
18626: LIST
18627: LIST
18628: PUSH
18629: EMPTY
18630: LIST
18631: LIST
18632: PPUSH
18633: CALL_OW 69
18637: ST_TO_ADDR
// if not tmp then
18638: LD_VAR 0 2
18642: NOT
18643: IFFALSE 18647
// exit ;
18645: GO 18796
// un := tmp [ rand ( 1 , tmp ) ] ;
18647: LD_ADDR_VAR 0 3
18651: PUSH
18652: LD_VAR 0 2
18656: PUSH
18657: LD_INT 1
18659: PPUSH
18660: LD_VAR 0 2
18664: PPUSH
18665: CALL_OW 12
18669: ARRAY
18670: ST_TO_ADDR
// if Crawls ( un ) then
18671: LD_VAR 0 3
18675: PPUSH
18676: CALL_OW 318
18680: IFFALSE 18691
// ComWalk ( un ) ;
18682: LD_VAR 0 3
18686: PPUSH
18687: CALL_OW 138
// SetClass ( un , class_mortar ) ;
18691: LD_VAR 0 3
18695: PPUSH
18696: LD_INT 8
18698: PPUSH
18699: CALL_OW 336
// end ; 4 :
18703: GO 18796
18705: LD_INT 4
18707: DOUBLE
18708: EQUAL
18709: IFTRUE 18713
18711: GO 18774
18713: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
18714: LD_ADDR_VAR 0 2
18718: PUSH
18719: LD_INT 22
18721: PUSH
18722: LD_OWVAR 2
18726: PUSH
18727: EMPTY
18728: LIST
18729: LIST
18730: PUSH
18731: LD_INT 30
18733: PUSH
18734: LD_INT 29
18736: PUSH
18737: EMPTY
18738: LIST
18739: LIST
18740: PUSH
18741: EMPTY
18742: LIST
18743: LIST
18744: PPUSH
18745: CALL_OW 69
18749: ST_TO_ADDR
// if not tmp then
18750: LD_VAR 0 2
18754: NOT
18755: IFFALSE 18759
// exit ;
18757: GO 18796
// DestroyUnit ( tmp [ 1 ] ) ;
18759: LD_VAR 0 2
18763: PUSH
18764: LD_INT 1
18766: ARRAY
18767: PPUSH
18768: CALL_OW 65
// end ; 5 .. 7 :
18772: GO 18796
18774: LD_INT 5
18776: DOUBLE
18777: GREATEREQUAL
18778: IFFALSE 18786
18780: LD_INT 7
18782: DOUBLE
18783: LESSEQUAL
18784: IFTRUE 18788
18786: GO 18795
18788: POP
// StreamSibBomb ; end ;
18789: CALL 15076 0 0
18793: GO 18796
18795: POP
// end ;
18796: PPOPN 3
18798: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
18799: LD_EXP 57
18803: PUSH
18804: LD_EXP 107
18808: AND
18809: IFFALSE 18965
18811: GO 18813
18813: DISABLE
18814: LD_INT 0
18816: PPUSH
18817: PPUSH
18818: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
18819: LD_ADDR_VAR 0 2
18823: PUSH
18824: LD_INT 81
18826: PUSH
18827: LD_OWVAR 2
18831: PUSH
18832: EMPTY
18833: LIST
18834: LIST
18835: PUSH
18836: LD_INT 2
18838: PUSH
18839: LD_INT 21
18841: PUSH
18842: LD_INT 1
18844: PUSH
18845: EMPTY
18846: LIST
18847: LIST
18848: PUSH
18849: LD_INT 21
18851: PUSH
18852: LD_INT 2
18854: PUSH
18855: EMPTY
18856: LIST
18857: LIST
18858: PUSH
18859: EMPTY
18860: LIST
18861: LIST
18862: LIST
18863: PUSH
18864: EMPTY
18865: LIST
18866: LIST
18867: PPUSH
18868: CALL_OW 69
18872: ST_TO_ADDR
// if not tmp then
18873: LD_VAR 0 2
18877: NOT
18878: IFFALSE 18882
// exit ;
18880: GO 18965
// p := 0 ;
18882: LD_ADDR_VAR 0 3
18886: PUSH
18887: LD_INT 0
18889: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
18890: LD_INT 35
18892: PPUSH
18893: CALL_OW 67
// p := p + 1 ;
18897: LD_ADDR_VAR 0 3
18901: PUSH
18902: LD_VAR 0 3
18906: PUSH
18907: LD_INT 1
18909: PLUS
18910: ST_TO_ADDR
// for i in tmp do
18911: LD_ADDR_VAR 0 1
18915: PUSH
18916: LD_VAR 0 2
18920: PUSH
18921: FOR_IN
18922: IFFALSE 18953
// if GetLives ( i ) < 1000 then
18924: LD_VAR 0 1
18928: PPUSH
18929: CALL_OW 256
18933: PUSH
18934: LD_INT 1000
18936: LESS
18937: IFFALSE 18951
// SetLives ( i , 1000 ) ;
18939: LD_VAR 0 1
18943: PPUSH
18944: LD_INT 1000
18946: PPUSH
18947: CALL_OW 234
18951: GO 18921
18953: POP
18954: POP
// until p > 20 ;
18955: LD_VAR 0 3
18959: PUSH
18960: LD_INT 20
18962: GREATER
18963: IFFALSE 18890
// end ;
18965: PPOPN 3
18967: END
// every 0 0$1 trigger StreamModeActive and sTime do
18968: LD_EXP 57
18972: PUSH
18973: LD_EXP 108
18977: AND
18978: IFFALSE 19013
18980: GO 18982
18982: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
18983: LD_INT 28
18985: PPUSH
18986: LD_OWVAR 2
18990: PPUSH
18991: LD_INT 2
18993: PPUSH
18994: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
18998: LD_INT 30
19000: PPUSH
19001: LD_OWVAR 2
19005: PPUSH
19006: LD_INT 2
19008: PPUSH
19009: CALL_OW 322
// end ;
19013: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
19014: LD_EXP 57
19018: PUSH
19019: LD_EXP 109
19023: AND
19024: IFFALSE 19145
19026: GO 19028
19028: DISABLE
19029: LD_INT 0
19031: PPUSH
19032: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
19033: LD_ADDR_VAR 0 2
19037: PUSH
19038: LD_INT 22
19040: PUSH
19041: LD_OWVAR 2
19045: PUSH
19046: EMPTY
19047: LIST
19048: LIST
19049: PUSH
19050: LD_INT 21
19052: PUSH
19053: LD_INT 1
19055: PUSH
19056: EMPTY
19057: LIST
19058: LIST
19059: PUSH
19060: LD_INT 3
19062: PUSH
19063: LD_INT 23
19065: PUSH
19066: LD_INT 0
19068: PUSH
19069: EMPTY
19070: LIST
19071: LIST
19072: PUSH
19073: EMPTY
19074: LIST
19075: LIST
19076: PUSH
19077: EMPTY
19078: LIST
19079: LIST
19080: LIST
19081: PPUSH
19082: CALL_OW 69
19086: ST_TO_ADDR
// if not tmp then
19087: LD_VAR 0 2
19091: NOT
19092: IFFALSE 19096
// exit ;
19094: GO 19145
// for i in tmp do
19096: LD_ADDR_VAR 0 1
19100: PUSH
19101: LD_VAR 0 2
19105: PUSH
19106: FOR_IN
19107: IFFALSE 19143
// begin if Crawls ( i ) then
19109: LD_VAR 0 1
19113: PPUSH
19114: CALL_OW 318
19118: IFFALSE 19129
// ComWalk ( i ) ;
19120: LD_VAR 0 1
19124: PPUSH
19125: CALL_OW 138
// SetClass ( i , 2 ) ;
19129: LD_VAR 0 1
19133: PPUSH
19134: LD_INT 2
19136: PPUSH
19137: CALL_OW 336
// end ;
19141: GO 19106
19143: POP
19144: POP
// end ;
19145: PPOPN 2
19147: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
19148: LD_EXP 57
19152: PUSH
19153: LD_EXP 110
19157: AND
19158: IFFALSE 19379
19160: GO 19162
19162: DISABLE
19163: LD_INT 0
19165: PPUSH
19166: PPUSH
19167: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
19168: LD_OWVAR 2
19172: PPUSH
19173: LD_INT 9
19175: PPUSH
19176: LD_INT 1
19178: PPUSH
19179: LD_INT 1
19181: PPUSH
19182: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
19186: LD_INT 9
19188: PPUSH
19189: LD_OWVAR 2
19193: PPUSH
19194: CALL_OW 343
// uc_side := 9 ;
19198: LD_ADDR_OWVAR 20
19202: PUSH
19203: LD_INT 9
19205: ST_TO_ADDR
// uc_nation := 2 ;
19206: LD_ADDR_OWVAR 21
19210: PUSH
19211: LD_INT 2
19213: ST_TO_ADDR
// hc_name := Dark Warrior ;
19214: LD_ADDR_OWVAR 26
19218: PUSH
19219: LD_STRING Dark Warrior
19221: ST_TO_ADDR
// hc_gallery :=  ;
19222: LD_ADDR_OWVAR 33
19226: PUSH
19227: LD_STRING 
19229: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , 10 ) ;
19230: LD_INT 1
19232: PPUSH
19233: LD_INT 1
19235: PPUSH
19236: LD_INT 10
19238: PPUSH
19239: CALL_OW 380
// un := CreateHuman ;
19243: LD_ADDR_VAR 0 3
19247: PUSH
19248: CALL_OW 44
19252: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
19253: LD_VAR 0 3
19257: PPUSH
19258: LD_INT 1
19260: PPUSH
19261: CALL_OW 51
// p := 0 ;
19265: LD_ADDR_VAR 0 2
19269: PUSH
19270: LD_INT 0
19272: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
19273: LD_INT 35
19275: PPUSH
19276: CALL_OW 67
// if GetLives ( un ) < 1000 then
19280: LD_VAR 0 3
19284: PPUSH
19285: CALL_OW 256
19289: PUSH
19290: LD_INT 1000
19292: LESS
19293: IFFALSE 19307
// SetLives ( un , 1000 ) ;
19295: LD_VAR 0 3
19299: PPUSH
19300: LD_INT 1000
19302: PPUSH
19303: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , your_side ] ) , un ) ) ;
19307: LD_VAR 0 3
19311: PPUSH
19312: LD_INT 81
19314: PUSH
19315: LD_OWVAR 2
19319: PUSH
19320: EMPTY
19321: LIST
19322: LIST
19323: PPUSH
19324: CALL_OW 69
19328: PPUSH
19329: LD_VAR 0 3
19333: PPUSH
19334: CALL_OW 74
19338: PPUSH
19339: CALL_OW 115
// until p > 60 or IsDead ( un ) ;
19343: LD_VAR 0 2
19347: PUSH
19348: LD_INT 60
19350: GREATER
19351: PUSH
19352: LD_VAR 0 3
19356: PPUSH
19357: CALL_OW 301
19361: OR
19362: IFFALSE 19273
// if un then
19364: LD_VAR 0 3
19368: IFFALSE 19379
// RemoveUnit ( un ) ;
19370: LD_VAR 0 3
19374: PPUSH
19375: CALL_OW 64
// end ; end_of_file
19379: PPOPN 3
19381: END
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; var i , eff , side ; begin
19382: LD_INT 0
19384: PPUSH
19385: PPUSH
19386: PPUSH
19387: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
19388: LD_VAR 0 1
19392: PPUSH
19393: CALL_OW 264
19397: PUSH
19398: LD_EXP 56
19402: EQUAL
19403: IFFALSE 19475
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
19405: LD_INT 68
19407: PPUSH
19408: LD_VAR 0 1
19412: PPUSH
19413: CALL_OW 255
19417: PPUSH
19418: CALL_OW 321
19422: PUSH
19423: LD_INT 2
19425: EQUAL
19426: IFFALSE 19438
// eff := 70 else
19428: LD_ADDR_VAR 0 6
19432: PUSH
19433: LD_INT 70
19435: ST_TO_ADDR
19436: GO 19446
// eff := 30 ;
19438: LD_ADDR_VAR 0 6
19442: PUSH
19443: LD_INT 30
19445: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
19446: LD_VAR 0 1
19450: PPUSH
19451: CALL_OW 250
19455: PPUSH
19456: LD_VAR 0 1
19460: PPUSH
19461: CALL_OW 251
19465: PPUSH
19466: LD_VAR 0 6
19470: PPUSH
19471: CALL_OW 495
// end ; end ;
19475: LD_VAR 0 4
19479: RET
// export function SOS_Command ( cmd ) ; var i , j , tmp , taskList , _taskList ; begin
19480: LD_INT 0
19482: PPUSH
19483: PPUSH
19484: PPUSH
19485: PPUSH
19486: PPUSH
19487: PPUSH
// if cmd = 124 then
19488: LD_VAR 0 1
19492: PUSH
19493: LD_INT 124
19495: EQUAL
19496: IFFALSE 19702
// begin tmp := FilterAllUnits ( [ f_or , [ f_weapon , ru_bulldozer ] , [ f_weapon , us_bulldozer ] ] ) ;
19498: LD_ADDR_VAR 0 5
19502: PUSH
19503: LD_INT 2
19505: PUSH
19506: LD_INT 34
19508: PUSH
19509: LD_INT 53
19511: PUSH
19512: EMPTY
19513: LIST
19514: LIST
19515: PUSH
19516: LD_INT 34
19518: PUSH
19519: LD_INT 14
19521: PUSH
19522: EMPTY
19523: LIST
19524: LIST
19525: PUSH
19526: EMPTY
19527: LIST
19528: LIST
19529: LIST
19530: PPUSH
19531: CALL_OW 69
19535: ST_TO_ADDR
// if not tmp then
19536: LD_VAR 0 5
19540: NOT
19541: IFFALSE 19545
// exit ;
19543: GO 19702
// for i in tmp do
19545: LD_ADDR_VAR 0 3
19549: PUSH
19550: LD_VAR 0 5
19554: PUSH
19555: FOR_IN
19556: IFFALSE 19700
// begin taskList := GetTaskList ( i ) ;
19558: LD_ADDR_VAR 0 6
19562: PUSH
19563: LD_VAR 0 3
19567: PPUSH
19568: CALL_OW 437
19572: ST_TO_ADDR
// if not taskList then
19573: LD_VAR 0 6
19577: NOT
19578: IFFALSE 19582
// continue ;
19580: GO 19555
// for j = 1 to taskList do
19582: LD_ADDR_VAR 0 4
19586: PUSH
19587: DOUBLE
19588: LD_INT 1
19590: DEC
19591: ST_TO_ADDR
19592: LD_VAR 0 6
19596: PUSH
19597: FOR_TO
19598: IFFALSE 19696
// if taskList [ j ] [ 1 ] = | then
19600: LD_VAR 0 6
19604: PUSH
19605: LD_VAR 0 4
19609: ARRAY
19610: PUSH
19611: LD_INT 1
19613: ARRAY
19614: PUSH
19615: LD_STRING |
19617: EQUAL
19618: IFFALSE 19694
// begin _taskList := Delete ( taskList , 1 ) ;
19620: LD_ADDR_VAR 0 7
19624: PUSH
19625: LD_VAR 0 6
19629: PPUSH
19630: LD_INT 1
19632: PPUSH
19633: CALL_OW 3
19637: ST_TO_ADDR
// SetTaskList ( i , _taskList ) ;
19638: LD_VAR 0 3
19642: PPUSH
19643: LD_VAR 0 7
19647: PPUSH
19648: CALL_OW 446
// CutTreeXYR ( i , taskList [ j ] [ 2 ] , taskList [ j ] [ 3 ] , 8 ) ;
19652: LD_VAR 0 3
19656: PPUSH
19657: LD_VAR 0 6
19661: PUSH
19662: LD_VAR 0 4
19666: ARRAY
19667: PUSH
19668: LD_INT 2
19670: ARRAY
19671: PPUSH
19672: LD_VAR 0 6
19676: PUSH
19677: LD_VAR 0 4
19681: ARRAY
19682: PUSH
19683: LD_INT 3
19685: ARRAY
19686: PPUSH
19687: LD_INT 8
19689: PPUSH
19690: CALL 19707 0 4
// end ;
19694: GO 19597
19696: POP
19697: POP
// end ;
19698: GO 19555
19700: POP
19701: POP
// end ; end ;
19702: LD_VAR 0 2
19706: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
19707: LD_INT 0
19709: PPUSH
19710: PPUSH
19711: PPUSH
19712: PPUSH
19713: PPUSH
19714: PPUSH
19715: PPUSH
19716: PPUSH
19717: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
19718: LD_VAR 0 1
19722: NOT
19723: PUSH
19724: LD_VAR 0 2
19728: PPUSH
19729: LD_VAR 0 3
19733: PPUSH
19734: CALL_OW 488
19738: NOT
19739: OR
19740: PUSH
19741: LD_VAR 0 4
19745: NOT
19746: OR
19747: IFFALSE 19751
// exit ;
19749: GO 20091
// list := [ ] ;
19751: LD_ADDR_VAR 0 13
19755: PUSH
19756: EMPTY
19757: ST_TO_ADDR
// if x - r < 0 then
19758: LD_VAR 0 2
19762: PUSH
19763: LD_VAR 0 4
19767: MINUS
19768: PUSH
19769: LD_INT 0
19771: LESS
19772: IFFALSE 19784
// min_x := 0 else
19774: LD_ADDR_VAR 0 7
19778: PUSH
19779: LD_INT 0
19781: ST_TO_ADDR
19782: GO 19800
// min_x := x - r ;
19784: LD_ADDR_VAR 0 7
19788: PUSH
19789: LD_VAR 0 2
19793: PUSH
19794: LD_VAR 0 4
19798: MINUS
19799: ST_TO_ADDR
// if y - r < 0 then
19800: LD_VAR 0 3
19804: PUSH
19805: LD_VAR 0 4
19809: MINUS
19810: PUSH
19811: LD_INT 0
19813: LESS
19814: IFFALSE 19826
// min_y := 0 else
19816: LD_ADDR_VAR 0 8
19820: PUSH
19821: LD_INT 0
19823: ST_TO_ADDR
19824: GO 19842
// min_y := y - r ;
19826: LD_ADDR_VAR 0 8
19830: PUSH
19831: LD_VAR 0 3
19835: PUSH
19836: LD_VAR 0 4
19840: MINUS
19841: ST_TO_ADDR
// max_x := x + r ;
19842: LD_ADDR_VAR 0 9
19846: PUSH
19847: LD_VAR 0 2
19851: PUSH
19852: LD_VAR 0 4
19856: PLUS
19857: ST_TO_ADDR
// max_y := y + r ;
19858: LD_ADDR_VAR 0 10
19862: PUSH
19863: LD_VAR 0 3
19867: PUSH
19868: LD_VAR 0 4
19872: PLUS
19873: ST_TO_ADDR
// for _x = min_x to max_x do
19874: LD_ADDR_VAR 0 11
19878: PUSH
19879: DOUBLE
19880: LD_VAR 0 7
19884: DEC
19885: ST_TO_ADDR
19886: LD_VAR 0 9
19890: PUSH
19891: FOR_TO
19892: IFFALSE 20009
// for _y = min_y to max_y do
19894: LD_ADDR_VAR 0 12
19898: PUSH
19899: DOUBLE
19900: LD_VAR 0 8
19904: DEC
19905: ST_TO_ADDR
19906: LD_VAR 0 10
19910: PUSH
19911: FOR_TO
19912: IFFALSE 20005
// begin if not ValidHex ( _x , _y ) then
19914: LD_VAR 0 11
19918: PPUSH
19919: LD_VAR 0 12
19923: PPUSH
19924: CALL_OW 488
19928: NOT
19929: IFFALSE 19933
// continue ;
19931: GO 19911
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
19933: LD_VAR 0 11
19937: PPUSH
19938: LD_VAR 0 12
19942: PPUSH
19943: CALL_OW 351
19947: PUSH
19948: LD_VAR 0 11
19952: PPUSH
19953: LD_VAR 0 12
19957: PPUSH
19958: CALL_OW 554
19962: AND
19963: IFFALSE 20003
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
19965: LD_ADDR_VAR 0 13
19969: PUSH
19970: LD_VAR 0 13
19974: PPUSH
19975: LD_VAR 0 13
19979: PUSH
19980: LD_INT 1
19982: PLUS
19983: PPUSH
19984: LD_VAR 0 11
19988: PUSH
19989: LD_VAR 0 12
19993: PUSH
19994: EMPTY
19995: LIST
19996: LIST
19997: PPUSH
19998: CALL_OW 2
20002: ST_TO_ADDR
// end ;
20003: GO 19911
20005: POP
20006: POP
20007: GO 19891
20009: POP
20010: POP
// if not list then
20011: LD_VAR 0 13
20015: NOT
20016: IFFALSE 20020
// exit ;
20018: GO 20091
// for i in list do
20020: LD_ADDR_VAR 0 6
20024: PUSH
20025: LD_VAR 0 13
20029: PUSH
20030: FOR_IN
20031: IFFALSE 20089
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
20033: LD_VAR 0 1
20037: PPUSH
20038: LD_STRING M
20040: PUSH
20041: LD_VAR 0 6
20045: PUSH
20046: LD_INT 1
20048: ARRAY
20049: PUSH
20050: LD_VAR 0 6
20054: PUSH
20055: LD_INT 2
20057: ARRAY
20058: PUSH
20059: LD_INT 0
20061: PUSH
20062: LD_INT 0
20064: PUSH
20065: LD_INT 0
20067: PUSH
20068: LD_INT 0
20070: PUSH
20071: EMPTY
20072: LIST
20073: LIST
20074: LIST
20075: LIST
20076: LIST
20077: LIST
20078: LIST
20079: PUSH
20080: EMPTY
20081: LIST
20082: PPUSH
20083: CALL_OW 447
20087: GO 20030
20089: POP
20090: POP
// end ;
20091: LD_VAR 0 5
20095: RET
