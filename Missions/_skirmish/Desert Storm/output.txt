// starting begin PrepareMap ;
   0: CALL 13 0 0
// Main_Variables ;
   4: CALL 136 0 0
// Start_Mission ;
   8: CALL 3416 0 0
// end ;
  12: END
// function PrepareMap ; begin
  13: LD_INT 0
  15: PPUSH
// ResetFog ;
  16: CALL_OW 335
// RandomizeAll ;
  20: CALL_OW 11
// game_difficulty := GetMultiplayerSetting ( 0 ) ;
  24: LD_ADDR_EXP 2
  28: PUSH
  29: LD_INT 0
  31: PPUSH
  32: CALL_OW 426
  36: ST_TO_ADDR
// Difficulty := game_difficulty ;
  37: LD_ADDR_OWVAR 67
  41: PUSH
  42: LD_EXP 2
  46: ST_TO_ADDR
// ChangeSideFog ( 8 , 6 ) ;
  47: LD_INT 8
  49: PPUSH
  50: LD_INT 6
  52: PPUSH
  53: CALL_OW 343
// PlaceSeeing ( 1 , 1 , 8 , - 37963 ) ;
  57: LD_INT 1
  59: PPUSH
  60: LD_INT 1
  62: PPUSH
  63: LD_INT 8
  65: PPUSH
  66: LD_INT 37963
  68: NEG
  69: PPUSH
  70: CALL_OW 330
// RemoveSeeing ( 1 , 1 , 8 ) ;
  74: LD_INT 1
  76: PPUSH
  77: LD_INT 1
  79: PPUSH
  80: LD_INT 8
  82: PPUSH
  83: CALL_OW 331
// PlaceCamera ;
  87: CALL 3883 0 0
// PrepareNature ( nature , 4 , 3 , 2 , 1 ) ;
  91: LD_INT 2
  93: PPUSH
  94: LD_INT 4
  96: PPUSH
  97: LD_INT 3
  99: PPUSH
 100: LD_INT 2
 102: PPUSH
 103: LD_INT 1
 105: PPUSH
 106: CALL 7756 0 5
// PrepareComm ;
 110: CALL 8239 0 0
// SetSide ( fort , 6 ) ;
 114: LD_INT 23
 116: PPUSH
 117: LD_INT 6
 119: PPUSH
 120: CALL_OW 235
// CenterNowOnUnits ( fort ) ;
 124: LD_INT 23
 126: PPUSH
 127: CALL_OW 87
// end ;
 131: LD_VAR 0 1
 135: RET
// export game_on , game_difficulty , game_time , game_option , game_end , game_strings ; export leopold , leopold_in_fort , samuel , samuel_in_fort , mortars_in_fort , scout ; export u_mine , u_fac ; export areas ; export skill ; export ar_weapons , ru_weapons , us_weapons ; export arabian_force , russian_force , american_force , arabian_timeing , russian_timeing , american_timeing ; export meeting_start , meeting_arive , meeting_break , meeting_end , meeting_time , russian_timer , fort_destroyed , hero_died , mission_time , cargo_ok , american_hchan , dezert , arabian_attack , russian_attack , american_attack , american_help , american_sib_bomb , russian_trade , heike_dialog1 , heike_dialog2 ; export am_comander , ru_comander , ar_comander ; function Main_Variables ; begin
 136: LD_INT 0
 138: PPUSH
// game_on := false ;
 139: LD_ADDR_EXP 1
 143: PUSH
 144: LD_INT 0
 146: ST_TO_ADDR
// game_time := 0 0$00 ;
 147: LD_ADDR_EXP 3
 151: PUSH
 152: LD_INT 0
 154: ST_TO_ADDR
// game_option := [ 1 ] ;
 155: LD_ADDR_EXP 4
 159: PUSH
 160: LD_INT 1
 162: PUSH
 163: EMPTY
 164: LIST
 165: ST_TO_ADDR
// game_end := false ;
 166: LD_ADDR_EXP 5
 170: PUSH
 171: LD_INT 0
 173: ST_TO_ADDR
// game_strings := [ ] ;
 174: LD_ADDR_EXP 6
 178: PUSH
 179: EMPTY
 180: ST_TO_ADDR
// game_time := 0 0$00 ;
 181: LD_ADDR_EXP 3
 185: PUSH
 186: LD_INT 0
 188: ST_TO_ADDR
// mission_time := 0 0$00 ;
 189: LD_ADDR_EXP 34
 193: PUSH
 194: LD_INT 0
 196: ST_TO_ADDR
// skill := [ 5 , 7 , 9 ] [ game_difficulty ] ;
 197: LD_ADDR_EXP 16
 201: PUSH
 202: LD_INT 5
 204: PUSH
 205: LD_INT 7
 207: PUSH
 208: LD_INT 9
 210: PUSH
 211: EMPTY
 212: LIST
 213: LIST
 214: LIST
 215: PUSH
 216: LD_EXP 2
 220: ARRAY
 221: ST_TO_ADDR
// areas := [ a_swest , a_nwest , a_neast , a_seast ] ;
 222: LD_ADDR_EXP 15
 226: PUSH
 227: LD_INT 5
 229: PUSH
 230: LD_INT 6
 232: PUSH
 233: LD_INT 7
 235: PUSH
 236: LD_INT 8
 238: PUSH
 239: EMPTY
 240: LIST
 241: LIST
 242: LIST
 243: LIST
 244: ST_TO_ADDR
// meeting_start := false ;
 245: LD_ADDR_EXP 26
 249: PUSH
 250: LD_INT 0
 252: ST_TO_ADDR
// meeting_arive := false ;
 253: LD_ADDR_EXP 27
 257: PUSH
 258: LD_INT 0
 260: ST_TO_ADDR
// meeting_break := false ;
 261: LD_ADDR_EXP 28
 265: PUSH
 266: LD_INT 0
 268: ST_TO_ADDR
// meeting_end := false ;
 269: LD_ADDR_EXP 29
 273: PUSH
 274: LD_INT 0
 276: ST_TO_ADDR
// meeting_time := [ 4 4$00 , 3 3$40 , 3 3$20 ] [ game_difficulty ] ;
 277: LD_ADDR_EXP 30
 281: PUSH
 282: LD_INT 8400
 284: PUSH
 285: LD_INT 7700
 287: PUSH
 288: LD_INT 7000
 290: PUSH
 291: EMPTY
 292: LIST
 293: LIST
 294: LIST
 295: PUSH
 296: LD_EXP 2
 300: ARRAY
 301: ST_TO_ADDR
// arabian_force := [ 5 , 6 , 7 ] [ game_difficulty ] ;
 302: LD_ADDR_EXP 20
 306: PUSH
 307: LD_INT 5
 309: PUSH
 310: LD_INT 6
 312: PUSH
 313: LD_INT 7
 315: PUSH
 316: EMPTY
 317: LIST
 318: LIST
 319: LIST
 320: PUSH
 321: LD_EXP 2
 325: ARRAY
 326: ST_TO_ADDR
// american_force := [ 6 , 8 , 9 ] [ game_difficulty ] ;
 327: LD_ADDR_EXP 22
 331: PUSH
 332: LD_INT 6
 334: PUSH
 335: LD_INT 8
 337: PUSH
 338: LD_INT 9
 340: PUSH
 341: EMPTY
 342: LIST
 343: LIST
 344: LIST
 345: PUSH
 346: LD_EXP 2
 350: ARRAY
 351: ST_TO_ADDR
// russian_force := [ 7 , 9 , 10 ] [ game_difficulty ] ;
 352: LD_ADDR_EXP 21
 356: PUSH
 357: LD_INT 7
 359: PUSH
 360: LD_INT 9
 362: PUSH
 363: LD_INT 10
 365: PUSH
 366: EMPTY
 367: LIST
 368: LIST
 369: LIST
 370: PUSH
 371: LD_EXP 2
 375: ARRAY
 376: ST_TO_ADDR
// u_mine := false ;
 377: LD_ADDR_EXP 13
 381: PUSH
 382: LD_INT 0
 384: ST_TO_ADDR
// u_fac := false ;
 385: LD_ADDR_EXP 14
 389: PUSH
 390: LD_INT 0
 392: ST_TO_ADDR
// leopold_in_fort := false ;
 393: LD_ADDR_EXP 8
 397: PUSH
 398: LD_INT 0
 400: ST_TO_ADDR
// samuel_in_fort := false ;
 401: LD_ADDR_EXP 10
 405: PUSH
 406: LD_INT 0
 408: ST_TO_ADDR
// mortars_in_fort := false ;
 409: LD_ADDR_EXP 11
 413: PUSH
 414: LD_INT 0
 416: ST_TO_ADDR
// fort_destroyed := false ;
 417: LD_ADDR_EXP 32
 421: PUSH
 422: LD_INT 0
 424: ST_TO_ADDR
// hero_died := false ;
 425: LD_ADDR_EXP 33
 429: PUSH
 430: LD_INT 0
 432: ST_TO_ADDR
// dezert := false ;
 433: LD_ADDR_EXP 37
 437: PUSH
 438: LD_INT 0
 440: ST_TO_ADDR
// arabian_attack := false ;
 441: LD_ADDR_EXP 38
 445: PUSH
 446: LD_INT 0
 448: ST_TO_ADDR
// russian_attack := false ;
 449: LD_ADDR_EXP 39
 453: PUSH
 454: LD_INT 0
 456: ST_TO_ADDR
// american_attack := false ;
 457: LD_ADDR_EXP 40
 461: PUSH
 462: LD_INT 0
 464: ST_TO_ADDR
// american_help := false ;
 465: LD_ADDR_EXP 41
 469: PUSH
 470: LD_INT 0
 472: ST_TO_ADDR
// american_hchan := [ 91 , 81 , 71 ] [ game_difficulty ] ;
 473: LD_ADDR_EXP 36
 477: PUSH
 478: LD_INT 91
 480: PUSH
 481: LD_INT 81
 483: PUSH
 484: LD_INT 71
 486: PUSH
 487: EMPTY
 488: LIST
 489: LIST
 490: LIST
 491: PUSH
 492: LD_EXP 2
 496: ARRAY
 497: ST_TO_ADDR
// american_sib_bomb := false ;
 498: LD_ADDR_EXP 42
 502: PUSH
 503: LD_INT 0
 505: ST_TO_ADDR
// russian_trade := false ;
 506: LD_ADDR_EXP 43
 510: PUSH
 511: LD_INT 0
 513: ST_TO_ADDR
// russian_timer := 5 5$00 ;
 514: LD_ADDR_EXP 31
 518: PUSH
 519: LD_INT 10500
 521: ST_TO_ADDR
// cargo_ok := false ;
 522: LD_ADDR_EXP 35
 526: PUSH
 527: LD_INT 0
 529: ST_TO_ADDR
// heike_dialog1 := false ;
 530: LD_ADDR_EXP 44
 534: PUSH
 535: LD_INT 0
 537: ST_TO_ADDR
// heike_dialog2 := false ;
 538: LD_ADDR_EXP 45
 542: PUSH
 543: LD_INT 0
 545: ST_TO_ADDR
// american_timeing := [ 10 10$00 , 9 9$40 , 9 9$10 ] [ game_difficulty ] ;
 546: LD_ADDR_EXP 25
 550: PUSH
 551: LD_INT 21000
 553: PUSH
 554: LD_INT 20300
 556: PUSH
 557: LD_INT 19250
 559: PUSH
 560: EMPTY
 561: LIST
 562: LIST
 563: LIST
 564: PUSH
 565: LD_EXP 2
 569: ARRAY
 570: ST_TO_ADDR
// arabian_timeing := [ 8 8$00 , 7 7$10 , 6 6$20 ] [ game_difficulty ] ;
 571: LD_ADDR_EXP 23
 575: PUSH
 576: LD_INT 16800
 578: PUSH
 579: LD_INT 15050
 581: PUSH
 582: LD_INT 13300
 584: PUSH
 585: EMPTY
 586: LIST
 587: LIST
 588: LIST
 589: PUSH
 590: LD_EXP 2
 594: ARRAY
 595: ST_TO_ADDR
// russian_timeing := [ 11 11$00 , 10 10$30 , 9 9$20 ] [ game_difficulty ] ;
 596: LD_ADDR_EXP 24
 600: PUSH
 601: LD_INT 23100
 603: PUSH
 604: LD_INT 22050
 606: PUSH
 607: LD_INT 19600
 609: PUSH
 610: EMPTY
 611: LIST
 612: LIST
 613: LIST
 614: PUSH
 615: LD_EXP 2
 619: ARRAY
 620: ST_TO_ADDR
// ar_weapons := [ ar_rocket_launcher , ar_gun , ar_flame_thrower , ar_selfpropelled_bomb , ar_bio_bomb ] ;
 621: LD_ADDR_EXP 17
 625: PUSH
 626: LD_INT 28
 628: PUSH
 629: LD_INT 27
 631: PUSH
 632: LD_INT 26
 634: PUSH
 635: LD_INT 29
 637: PUSH
 638: LD_EXP 56
 642: PUSH
 643: EMPTY
 644: LIST
 645: LIST
 646: LIST
 647: LIST
 648: LIST
 649: ST_TO_ADDR
// us_weapons := [ us_rocket_launcher , us_heavy_gun , us_double_laser ] ;
 650: LD_ADDR_EXP 19
 654: PUSH
 655: LD_INT 7
 657: PUSH
 658: LD_INT 6
 660: PUSH
 661: LD_INT 10
 663: PUSH
 664: EMPTY
 665: LIST
 666: LIST
 667: LIST
 668: ST_TO_ADDR
// ru_weapons := [ ru_rocket_launcher , ru_rocket , ru_heavy_gun ] ;
 669: LD_ADDR_EXP 18
 673: PUSH
 674: LD_INT 45
 676: PUSH
 677: LD_INT 47
 679: PUSH
 680: LD_INT 46
 682: PUSH
 683: EMPTY
 684: LIST
 685: LIST
 686: LIST
 687: ST_TO_ADDR
// end ;
 688: LD_VAR 0 1
 692: RET
// every 0 0$01 trigger game_on do var i , p , x , filter ;
 693: LD_EXP 1
 697: IFFALSE 3413
 699: GO 701
 701: DISABLE
 702: LD_INT 0
 704: PPUSH
 705: PPUSH
 706: PPUSH
 707: PPUSH
// begin enable ;
 708: ENABLE
// Display_Strings := [ #tick , game_time ] ^ game_strings ;
 709: LD_ADDR_OWVAR 47
 713: PUSH
 714: LD_STRING #tick
 716: PUSH
 717: LD_EXP 3
 721: PUSH
 722: EMPTY
 723: LIST
 724: LIST
 725: PUSH
 726: LD_EXP 6
 730: ADD
 731: ST_TO_ADDR
// game_time := RefreshTime ( game_time , true ) ;
 732: LD_ADDR_EXP 3
 736: PUSH
 737: LD_EXP 3
 741: PPUSH
 742: LD_INT 1
 744: PPUSH
 745: CALL 6842 0 2
 749: ST_TO_ADDR
// if meeting_start and meeting_time > 0 0$00 then
 750: LD_EXP 26
 754: PUSH
 755: LD_EXP 30
 759: PUSH
 760: LD_INT 0
 762: GREATER
 763: AND
 764: IFFALSE 801
// begin game_strings := [ #mtime , meeting_time ] ;
 766: LD_ADDR_EXP 6
 770: PUSH
 771: LD_STRING #mtime
 773: PUSH
 774: LD_EXP 30
 778: PUSH
 779: EMPTY
 780: LIST
 781: LIST
 782: ST_TO_ADDR
// meeting_time := RefreshTime ( meeting_time , false ) ;
 783: LD_ADDR_EXP 30
 787: PUSH
 788: LD_EXP 30
 792: PPUSH
 793: LD_INT 0
 795: PPUSH
 796: CALL 6842 0 2
 800: ST_TO_ADDR
// end ; if meeting_arive then
 801: LD_EXP 27
 805: IFFALSE 825
// mission_time := RefreshTime ( mission_time , true ) ;
 807: LD_ADDR_EXP 34
 811: PUSH
 812: LD_EXP 34
 816: PPUSH
 817: LD_INT 1
 819: PPUSH
 820: CALL 6842 0 2
 824: ST_TO_ADDR
// if arabian_attack and arabian_timeing > 0 0$00 and meeting_arive then
 825: LD_EXP 38
 829: PUSH
 830: LD_EXP 23
 834: PUSH
 835: LD_INT 0
 837: GREATER
 838: AND
 839: PUSH
 840: LD_EXP 27
 844: AND
 845: IFFALSE 865
// begin arabian_timeing := RefreshTime ( arabian_timeing , false ) ;
 847: LD_ADDR_EXP 23
 851: PUSH
 852: LD_EXP 23
 856: PPUSH
 857: LD_INT 0
 859: PPUSH
 860: CALL 6842 0 2
 864: ST_TO_ADDR
// end ; if russian_attack and russian_timeing > 0 0$00 and meeting_arive then
 865: LD_EXP 39
 869: PUSH
 870: LD_EXP 24
 874: PUSH
 875: LD_INT 0
 877: GREATER
 878: AND
 879: PUSH
 880: LD_EXP 27
 884: AND
 885: IFFALSE 905
// begin russian_timeing := RefreshTime ( russian_timeing , false ) ;
 887: LD_ADDR_EXP 24
 891: PUSH
 892: LD_EXP 24
 896: PPUSH
 897: LD_INT 0
 899: PPUSH
 900: CALL 6842 0 2
 904: ST_TO_ADDR
// end ; if american_attack and american_timeing > 0 0$00 and meeting_arive then
 905: LD_EXP 40
 909: PUSH
 910: LD_EXP 25
 914: PUSH
 915: LD_INT 0
 917: GREATER
 918: AND
 919: PUSH
 920: LD_EXP 27
 924: AND
 925: IFFALSE 945
// begin american_timeing := RefreshTime ( american_timeing , false ) ;
 927: LD_ADDR_EXP 25
 931: PUSH
 932: LD_EXP 25
 936: PPUSH
 937: LD_INT 0
 939: PPUSH
 940: CALL 6842 0 2
 944: ST_TO_ADDR
// end ; if russian_trade and russian_timer > 0 0$00 then
 945: LD_EXP 43
 949: PUSH
 950: LD_EXP 31
 954: PUSH
 955: LD_INT 0
 957: GREATER
 958: AND
 959: IFFALSE 996
// begin game_strings := [ #rtime , russian_timer ] ;
 961: LD_ADDR_EXP 6
 965: PUSH
 966: LD_STRING #rtime
 968: PUSH
 969: LD_EXP 31
 973: PUSH
 974: EMPTY
 975: LIST
 976: LIST
 977: ST_TO_ADDR
// russian_timer := RefreshTime ( russian_timer , false ) ;
 978: LD_ADDR_EXP 31
 982: PUSH
 983: LD_EXP 31
 987: PPUSH
 988: LD_INT 0
 990: PPUSH
 991: CALL 6842 0 2
 995: ST_TO_ADDR
// end ; if russian_trade and russian_timer = 0 0$00 or cargo_ok then
 996: LD_EXP 43
1000: PUSH
1001: LD_EXP 31
1005: PUSH
1006: LD_INT 0
1008: EQUAL
1009: AND
1010: PUSH
1011: LD_EXP 35
1015: OR
1016: IFFALSE 1025
// game_strings := [ ] ;
1018: LD_ADDR_EXP 6
1022: PUSH
1023: EMPTY
1024: ST_TO_ADDR
// if dezert = false and tick mod 33600 = 0 then
1025: LD_EXP 37
1029: PUSH
1030: LD_INT 0
1032: EQUAL
1033: PUSH
1034: LD_OWVAR 1
1038: PUSH
1039: LD_INT 33600
1041: MOD
1042: PUSH
1043: LD_INT 0
1045: EQUAL
1046: AND
1047: IFFALSE 1107
// begin p := Rand ( 1 , 5 ) ;
1049: LD_ADDR_VAR 0 2
1053: PUSH
1054: LD_INT 1
1056: PPUSH
1057: LD_INT 5
1059: PPUSH
1060: CALL_OW 12
1064: ST_TO_ADDR
// if p <= [ 4 , 3 , 3 ] [ game_difficulty ] then
1065: LD_VAR 0 2
1069: PUSH
1070: LD_INT 4
1072: PUSH
1073: LD_INT 3
1075: PUSH
1076: LD_INT 3
1078: PUSH
1079: EMPTY
1080: LIST
1081: LIST
1082: LIST
1083: PUSH
1084: LD_EXP 2
1088: ARRAY
1089: LESSEQUAL
1090: IFFALSE 1107
// begin RaiseSailEvent ( 92 ) ;
1092: LD_INT 92
1094: PPUSH
1095: CALL_OW 427
// dezert := true ;
1099: LD_ADDR_EXP 37
1103: PUSH
1104: LD_INT 1
1106: ST_TO_ADDR
// end ; end ; if tick mod 8400 = 0 then
1107: LD_OWVAR 1
1111: PUSH
1112: LD_INT 8400
1114: MOD
1115: PUSH
1116: LD_INT 0
1118: EQUAL
1119: IFFALSE 1128
// RaiseSailEvent ( 101 ) ;
1121: LD_INT 101
1123: PPUSH
1124: CALL_OW 427
// if MineExist ( 8 ) and u_mine = false then
1128: LD_INT 8
1130: PPUSH
1131: CALL 6896 0 1
1135: PUSH
1136: LD_EXP 13
1140: PUSH
1141: LD_INT 0
1143: EQUAL
1144: AND
1145: IFFALSE 1162
// begin u_mine := true ;
1147: LD_ADDR_EXP 13
1151: PUSH
1152: LD_INT 1
1154: ST_TO_ADDR
// ChangeMissionObjectives ( DS-T1m ) ;
1155: LD_STRING DS-T1m
1157: PPUSH
1158: CALL_OW 337
// end ; if FacExist ( 8 ) and u_fac = false then
1162: LD_INT 8
1164: PPUSH
1165: CALL 6958 0 1
1169: PUSH
1170: LD_EXP 14
1174: PUSH
1175: LD_INT 0
1177: EQUAL
1178: AND
1179: IFFALSE 1196
// begin u_fac := true ;
1181: LD_ADDR_EXP 14
1185: PUSH
1186: LD_INT 1
1188: ST_TO_ADDR
// ChangeMissionObjectives ( DS-T1f ) ;
1189: LD_STRING DS-T1f
1191: PPUSH
1192: CALL_OW 337
// end ; if hero_died then
1196: LD_EXP 33
1200: IFFALSE 1209
// YouLost ( DS-h1 ) ;
1202: LD_STRING DS-h1
1204: PPUSH
1205: CALL_OW 104
// if fort_destroyed then
1209: LD_EXP 32
1213: IFFALSE 1222
// YouLost ( DS-h2 ) ;
1215: LD_STRING DS-h2
1217: PPUSH
1218: CALL_OW 104
// if GetDistUnits ( leopold , l_cmndr ) > 6 and meeting_start = false then
1222: LD_EXP 7
1226: PPUSH
1227: LD_EXP 49
1231: PPUSH
1232: CALL_OW 296
1236: PUSH
1237: LD_INT 6
1239: GREATER
1240: PUSH
1241: LD_EXP 26
1245: PUSH
1246: LD_INT 0
1248: EQUAL
1249: AND
1250: IFFALSE 1273
// begin if not HasTask ( leopold ) then
1252: LD_EXP 7
1256: PPUSH
1257: CALL_OW 314
1261: NOT
1262: IFFALSE 1271
// RaiseSailEvent ( 1 ) ;
1264: LD_INT 1
1266: PPUSH
1267: CALL_OW 427
// end else
1271: GO 1290
// if meeting_start = false then
1273: LD_EXP 26
1277: PUSH
1278: LD_INT 0
1280: EQUAL
1281: IFFALSE 1290
// begin RaiseSailEvent ( 2 ) ;
1283: LD_INT 2
1285: PPUSH
1286: CALL_OW 427
// end ; if game_time >= [ 50 50$00 , 62 62$30 , 75 75$00 ] [ game_difficulty ] and meeting_end = false then
1290: LD_EXP 3
1294: PUSH
1295: LD_INT 105000
1297: PUSH
1298: LD_INT 131250
1300: PUSH
1301: LD_INT 157500
1303: PUSH
1304: EMPTY
1305: LIST
1306: LIST
1307: LIST
1308: PUSH
1309: LD_EXP 2
1313: ARRAY
1314: GREATEREQUAL
1315: PUSH
1316: LD_EXP 29
1320: PUSH
1321: LD_INT 0
1323: EQUAL
1324: AND
1325: IFFALSE 1342
// begin meeting_end := true ;
1327: LD_ADDR_EXP 29
1331: PUSH
1332: LD_INT 1
1334: ST_TO_ADDR
// RaiseSailEvent ( 200 ) ;
1335: LD_INT 200
1337: PPUSH
1338: CALL_OW 427
// end ; if meeting_time = 0 0$00 and meeting_arive = false then
1342: LD_EXP 30
1346: PUSH
1347: LD_INT 0
1349: EQUAL
1350: PUSH
1351: LD_EXP 27
1355: PUSH
1356: LD_INT 0
1358: EQUAL
1359: AND
1360: IFFALSE 1384
// begin meeting_arive := true ;
1362: LD_ADDR_EXP 27
1366: PUSH
1367: LD_INT 1
1369: ST_TO_ADDR
// game_strings := [ ] ;
1370: LD_ADDR_EXP 6
1374: PUSH
1375: EMPTY
1376: ST_TO_ADDR
// RaiseSailEvent ( 10 ) ;
1377: LD_INT 10
1379: PPUSH
1380: CALL_OW 427
// end ; if meeting_arive then
1384: LD_EXP 27
1388: IFFALSE 2133
// begin if arabian_attack = false and tick mod 4200 = 0 then
1390: LD_EXP 38
1394: PUSH
1395: LD_INT 0
1397: EQUAL
1398: PUSH
1399: LD_OWVAR 1
1403: PUSH
1404: LD_INT 4200
1406: MOD
1407: PUSH
1408: LD_INT 0
1410: EQUAL
1411: AND
1412: IFFALSE 1465
// begin p := Rand ( 1 , 100 ) ;
1414: LD_ADDR_VAR 0 2
1418: PUSH
1419: LD_INT 1
1421: PPUSH
1422: LD_INT 100
1424: PPUSH
1425: CALL_OW 12
1429: ST_TO_ADDR
// if p <= [ 80 , 85 , 90 ] [ game_difficulty ] then
1430: LD_VAR 0 2
1434: PUSH
1435: LD_INT 80
1437: PUSH
1438: LD_INT 85
1440: PUSH
1441: LD_INT 90
1443: PUSH
1444: EMPTY
1445: LIST
1446: LIST
1447: LIST
1448: PUSH
1449: LD_EXP 2
1453: ARRAY
1454: LESSEQUAL
1455: IFFALSE 1465
// arabian_attack := true ;
1457: LD_ADDR_EXP 38
1461: PUSH
1462: LD_INT 1
1464: ST_TO_ADDR
// end ; if russian_trade = false and russian_attack = false and tick > 52500 then
1465: LD_EXP 43
1469: PUSH
1470: LD_INT 0
1472: EQUAL
1473: PUSH
1474: LD_EXP 39
1478: PUSH
1479: LD_INT 0
1481: EQUAL
1482: AND
1483: PUSH
1484: LD_OWVAR 1
1488: PUSH
1489: LD_INT 52500
1491: GREATER
1492: AND
1493: IFFALSE 1564
// begin russian_trade = true ;
1495: LD_ADDR_EXP 43
1499: PUSH
1500: LD_INT 1
1502: ST_TO_ADDR
// DialogueOn ;
1503: CALL_OW 6
// SayRadio ( ru_comander , DS-DR-RTr ) ;
1507: LD_EXP 47
1511: PPUSH
1512: LD_STRING DS-DR-RTr
1514: PPUSH
1515: CALL_OW 94
// Say ( l_cmndr , DS-DC-RTr ) ;
1519: LD_EXP 49
1523: PPUSH
1524: LD_STRING DS-DC-RTr
1526: PPUSH
1527: CALL_OW 88
// SayRadio ( ru_comander , DS-DR-RTr2 ) ;
1531: LD_EXP 47
1535: PPUSH
1536: LD_STRING DS-DR-RTr2
1538: PPUSH
1539: CALL_OW 94
// DialogueOff ;
1543: CALL_OW 7
// ChangeMissionObjectives ( DS-T2 ) ;
1547: LD_STRING DS-T2
1549: PPUSH
1550: CALL_OW 337
// SetAreaMapShow ( tree , 1 ) ;
1554: LD_INT 10
1556: PPUSH
1557: LD_INT 1
1559: PPUSH
1560: CALL_OW 424
// end ; if russian_trade and cargo_ok = false and russian_timer > 0 0$00 then
1564: LD_EXP 43
1568: PUSH
1569: LD_EXP 35
1573: PUSH
1574: LD_INT 0
1576: EQUAL
1577: AND
1578: PUSH
1579: LD_EXP 31
1583: PUSH
1584: LD_INT 0
1586: GREATER
1587: AND
1588: IFFALSE 1783
// begin if FilterUnitsInArea ( tree , ( [ [ f_empty ] , [ f_weapon , ar_cargo_bay ] , [ f_not , [ f_control , control_remote ] ] ] ) ) > 0 then
1590: LD_INT 10
1592: PPUSH
1593: LD_INT 58
1595: PUSH
1596: EMPTY
1597: LIST
1598: PUSH
1599: LD_INT 34
1601: PUSH
1602: LD_INT 32
1604: PUSH
1605: EMPTY
1606: LIST
1607: LIST
1608: PUSH
1609: LD_INT 3
1611: PUSH
1612: LD_INT 33
1614: PUSH
1615: LD_INT 2
1617: PUSH
1618: EMPTY
1619: LIST
1620: LIST
1621: PUSH
1622: EMPTY
1623: LIST
1624: LIST
1625: PUSH
1626: EMPTY
1627: LIST
1628: LIST
1629: LIST
1630: PPUSH
1631: CALL_OW 70
1635: PUSH
1636: LD_INT 0
1638: GREATER
1639: IFFALSE 1783
// if GetCargo ( FilterUnitsInArea ( tree , ( [ [ f_empty ] , [ f_weapon , ar_cargo_bay ] , [ f_not , [ f_control , control_remote ] ] ] ) ) [ 1 ] , mat_siberit ) = 100 then
1641: LD_INT 10
1643: PPUSH
1644: LD_INT 58
1646: PUSH
1647: EMPTY
1648: LIST
1649: PUSH
1650: LD_INT 34
1652: PUSH
1653: LD_INT 32
1655: PUSH
1656: EMPTY
1657: LIST
1658: LIST
1659: PUSH
1660: LD_INT 3
1662: PUSH
1663: LD_INT 33
1665: PUSH
1666: LD_INT 2
1668: PUSH
1669: EMPTY
1670: LIST
1671: LIST
1672: PUSH
1673: EMPTY
1674: LIST
1675: LIST
1676: PUSH
1677: EMPTY
1678: LIST
1679: LIST
1680: LIST
1681: PPUSH
1682: CALL_OW 70
1686: PUSH
1687: LD_INT 1
1689: ARRAY
1690: PPUSH
1691: LD_INT 3
1693: PPUSH
1694: CALL_OW 289
1698: PUSH
1699: LD_INT 100
1701: EQUAL
1702: IFFALSE 1783
// begin cargo_ok := true ;
1704: LD_ADDR_EXP 35
1708: PUSH
1709: LD_INT 1
1711: ST_TO_ADDR
// RemoveUnit ( FilterUnitsInArea ( tree , ( [ [ f_empty ] , [ f_weapon , ar_cargo_bay ] , [ f_not , [ f_control , control_remote ] ] ] ) ) [ 1 ] ) ;
1712: LD_INT 10
1714: PPUSH
1715: LD_INT 58
1717: PUSH
1718: EMPTY
1719: LIST
1720: PUSH
1721: LD_INT 34
1723: PUSH
1724: LD_INT 32
1726: PUSH
1727: EMPTY
1728: LIST
1729: LIST
1730: PUSH
1731: LD_INT 3
1733: PUSH
1734: LD_INT 33
1736: PUSH
1737: LD_INT 2
1739: PUSH
1740: EMPTY
1741: LIST
1742: LIST
1743: PUSH
1744: EMPTY
1745: LIST
1746: LIST
1747: PUSH
1748: EMPTY
1749: LIST
1750: LIST
1751: LIST
1752: PPUSH
1753: CALL_OW 70
1757: PUSH
1758: LD_INT 1
1760: ARRAY
1761: PPUSH
1762: CALL_OW 64
// ChangeMissionObjectives ( DS-T2-out ) ;
1766: LD_STRING DS-T2-out
1768: PPUSH
1769: CALL_OW 337
// SetAreaMapShow ( tree , 0 ) ;
1773: LD_INT 10
1775: PPUSH
1776: LD_INT 0
1778: PPUSH
1779: CALL_OW 424
// end ; end ; if russian_attack = false and russian_trade and cargo_ok = false and russian_timer = 0 0$00 then
1783: LD_EXP 39
1787: PUSH
1788: LD_INT 0
1790: EQUAL
1791: PUSH
1792: LD_EXP 43
1796: AND
1797: PUSH
1798: LD_EXP 35
1802: PUSH
1803: LD_INT 0
1805: EQUAL
1806: AND
1807: PUSH
1808: LD_EXP 31
1812: PUSH
1813: LD_INT 0
1815: EQUAL
1816: AND
1817: IFFALSE 1844
// begin russian_attack := true ;
1819: LD_ADDR_EXP 39
1823: PUSH
1824: LD_INT 1
1826: ST_TO_ADDR
// ChangeMissionObjectives ( DS-T2-out ) ;
1827: LD_STRING DS-T2-out
1829: PPUSH
1830: CALL_OW 337
// SetAreaMapShow ( tree , 0 ) ;
1834: LD_INT 10
1836: PPUSH
1837: LD_INT 0
1839: PPUSH
1840: CALL_OW 424
// end ; if russian_trade = false and russian_attack = false and american_attack = false and tick mod 21000 = 0 then
1844: LD_EXP 43
1848: PUSH
1849: LD_INT 0
1851: EQUAL
1852: PUSH
1853: LD_EXP 39
1857: PUSH
1858: LD_INT 0
1860: EQUAL
1861: AND
1862: PUSH
1863: LD_EXP 40
1867: PUSH
1868: LD_INT 0
1870: EQUAL
1871: AND
1872: PUSH
1873: LD_OWVAR 1
1877: PUSH
1878: LD_INT 21000
1880: MOD
1881: PUSH
1882: LD_INT 0
1884: EQUAL
1885: AND
1886: IFFALSE 1939
// begin p := Rand ( 1 , 100 ) ;
1888: LD_ADDR_VAR 0 2
1892: PUSH
1893: LD_INT 1
1895: PPUSH
1896: LD_INT 100
1898: PPUSH
1899: CALL_OW 12
1903: ST_TO_ADDR
// if p <= [ 25 , 35 , 45 ] [ game_difficulty ] then
1904: LD_VAR 0 2
1908: PUSH
1909: LD_INT 25
1911: PUSH
1912: LD_INT 35
1914: PUSH
1915: LD_INT 45
1917: PUSH
1918: EMPTY
1919: LIST
1920: LIST
1921: LIST
1922: PUSH
1923: LD_EXP 2
1927: ARRAY
1928: LESSEQUAL
1929: IFFALSE 1939
// russian_attack := true ;
1931: LD_ADDR_EXP 39
1935: PUSH
1936: LD_INT 1
1938: ST_TO_ADDR
// end ; if american_help = false and american_attack = false and russian_attack = false and tick mod 31500 = 0 then
1939: LD_EXP 41
1943: PUSH
1944: LD_INT 0
1946: EQUAL
1947: PUSH
1948: LD_EXP 40
1952: PUSH
1953: LD_INT 0
1955: EQUAL
1956: AND
1957: PUSH
1958: LD_EXP 39
1962: PUSH
1963: LD_INT 0
1965: EQUAL
1966: AND
1967: PUSH
1968: LD_OWVAR 1
1972: PUSH
1973: LD_INT 31500
1975: MOD
1976: PUSH
1977: LD_INT 0
1979: EQUAL
1980: AND
1981: IFFALSE 2034
// begin p := Rand ( 1 , 100 ) ;
1983: LD_ADDR_VAR 0 2
1987: PUSH
1988: LD_INT 1
1990: PPUSH
1991: LD_INT 100
1993: PPUSH
1994: CALL_OW 12
1998: ST_TO_ADDR
// if p <= [ 22 , 33 , 44 ] [ game_difficulty ] then
1999: LD_VAR 0 2
2003: PUSH
2004: LD_INT 22
2006: PUSH
2007: LD_INT 33
2009: PUSH
2010: LD_INT 44
2012: PUSH
2013: EMPTY
2014: LIST
2015: LIST
2016: LIST
2017: PUSH
2018: LD_EXP 2
2022: ARRAY
2023: LESSEQUAL
2024: IFFALSE 2034
// american_attack := true ;
2026: LD_ADDR_EXP 40
2030: PUSH
2031: LD_INT 1
2033: ST_TO_ADDR
// end ; if american_attack = false and russian_attack = false and american_help = false and tick mod 21200 = 0 then
2034: LD_EXP 40
2038: PUSH
2039: LD_INT 0
2041: EQUAL
2042: PUSH
2043: LD_EXP 39
2047: PUSH
2048: LD_INT 0
2050: EQUAL
2051: AND
2052: PUSH
2053: LD_EXP 41
2057: PUSH
2058: LD_INT 0
2060: EQUAL
2061: AND
2062: PUSH
2063: LD_OWVAR 1
2067: PUSH
2068: LD_INT 21200
2070: MOD
2071: PUSH
2072: LD_INT 0
2074: EQUAL
2075: AND
2076: IFFALSE 2133
// begin p := Rand ( 1 , 100 ) ;
2078: LD_ADDR_VAR 0 2
2082: PUSH
2083: LD_INT 1
2085: PPUSH
2086: LD_INT 100
2088: PPUSH
2089: CALL_OW 12
2093: ST_TO_ADDR
// if p <= american_hchan then
2094: LD_VAR 0 2
2098: PUSH
2099: LD_EXP 36
2103: LESSEQUAL
2104: IFFALSE 2133
// begin american_help := true ;
2106: LD_ADDR_EXP 41
2110: PUSH
2111: LD_INT 1
2113: ST_TO_ADDR
// SayRadio ( am_comander , DS-amhelp ) ;
2114: LD_EXP 46
2118: PPUSH
2119: LD_STRING DS-amhelp
2121: PPUSH
2122: CALL_OW 94
// RaiseSailEvent ( 91 ) ;
2126: LD_INT 91
2128: PPUSH
2129: CALL_OW 427
// end ; end ; end ; if american_attack and american_timeing = 0 0$00 and FilterAllUnits ( [ f_side , 1 ] ) = 0 then
2133: LD_EXP 40
2137: PUSH
2138: LD_EXP 25
2142: PUSH
2143: LD_INT 0
2145: EQUAL
2146: AND
2147: PUSH
2148: LD_INT 22
2150: PUSH
2151: LD_INT 1
2153: PUSH
2154: EMPTY
2155: LIST
2156: LIST
2157: PPUSH
2158: CALL_OW 69
2162: PUSH
2163: LD_INT 0
2165: EQUAL
2166: AND
2167: IFFALSE 2269
// begin american_timeing := Rand ( 17 17$00 , 20 20$00 ) ;
2169: LD_ADDR_EXP 25
2173: PUSH
2174: LD_INT 35700
2176: PPUSH
2177: LD_INT 42000
2179: PPUSH
2180: CALL_OW 12
2184: ST_TO_ADDR
// SayRadio ( scout , DS-DZ-U ) ;
2185: LD_EXP 12
2189: PPUSH
2190: LD_STRING DS-DZ-U
2192: PPUSH
2193: CALL_OW 94
// Wait ( 0 0$33 ) ;
2197: LD_INT 1155
2199: PPUSH
2200: CALL_OW 67
// x := Rand ( 1 , 2 ) ;
2204: LD_ADDR_VAR 0 3
2208: PUSH
2209: LD_INT 1
2211: PPUSH
2212: LD_INT 2
2214: PPUSH
2215: CALL_OW 12
2219: ST_TO_ADDR
// case x of 1 :
2220: LD_VAR 0 3
2224: PUSH
2225: LD_INT 1
2227: DOUBLE
2228: EQUAL
2229: IFTRUE 2233
2231: GO 2243
2233: POP
// RaiseSailEvent ( 41 ) ; 2 :
2234: LD_INT 41
2236: PPUSH
2237: CALL_OW 427
2241: GO 2262
2243: LD_INT 2
2245: DOUBLE
2246: EQUAL
2247: IFTRUE 2251
2249: GO 2261
2251: POP
// RaiseSailEvent ( 42 ) ; end ;
2252: LD_INT 42
2254: PPUSH
2255: CALL_OW 427
2259: GO 2262
2261: POP
// RaiseSailEvent ( 42 ) ;
2262: LD_INT 42
2264: PPUSH
2265: CALL_OW 427
// end ; if russian_attack and russian_timeing = 0 0$00 and FilterAllUnits ( [ f_side , 3 ] ) = 0 then
2269: LD_EXP 39
2273: PUSH
2274: LD_EXP 24
2278: PUSH
2279: LD_INT 0
2281: EQUAL
2282: AND
2283: PUSH
2284: LD_INT 22
2286: PUSH
2287: LD_INT 3
2289: PUSH
2290: EMPTY
2291: LIST
2292: LIST
2293: PPUSH
2294: CALL_OW 69
2298: PUSH
2299: LD_INT 0
2301: EQUAL
2302: AND
2303: IFFALSE 2359
// begin russian_timeing := Rand ( 17 17$00 , 20 20$00 ) ;
2305: LD_ADDR_EXP 24
2309: PUSH
2310: LD_INT 35700
2312: PPUSH
2313: LD_INT 42000
2315: PPUSH
2316: CALL_OW 12
2320: ST_TO_ADDR
// SayRadio ( scout , DS-DZ-R ) ;
2321: LD_EXP 12
2325: PPUSH
2326: LD_STRING DS-DZ-R
2328: PPUSH
2329: CALL_OW 94
// Wait ( 0 0$45 ) ;
2333: LD_INT 1575
2335: PPUSH
2336: CALL_OW 67
// SayRadio ( ru_comander , DS-DR-R1 ) ;
2340: LD_EXP 47
2344: PPUSH
2345: LD_STRING DS-DR-R1
2347: PPUSH
2348: CALL_OW 94
// RaiseSailEvent ( 51 ) ;
2352: LD_INT 51
2354: PPUSH
2355: CALL_OW 427
// end ; if mission_time >= 10 10$00 and arabian_force < 10 then
2359: LD_EXP 34
2363: PUSH
2364: LD_INT 21000
2366: GREATEREQUAL
2367: PUSH
2368: LD_EXP 20
2372: PUSH
2373: LD_INT 10
2375: LESS
2376: AND
2377: IFFALSE 2401
// begin mission_time := 0 0$00 ;
2379: LD_ADDR_EXP 34
2383: PUSH
2384: LD_INT 0
2386: ST_TO_ADDR
// arabian_force := arabian_force + 1 ;
2387: LD_ADDR_EXP 20
2391: PUSH
2392: LD_EXP 20
2396: PUSH
2397: LD_INT 1
2399: PLUS
2400: ST_TO_ADDR
// end ; if arabian_timeing = 0 0$00 and FilterAllUnits ( [ [ f_side , 2 ] , [ f_not , [ f_weapon , ar_control_tower ] ] ] ) = 0 then
2401: LD_EXP 23
2405: PUSH
2406: LD_INT 0
2408: EQUAL
2409: PUSH
2410: LD_INT 22
2412: PUSH
2413: LD_INT 2
2415: PUSH
2416: EMPTY
2417: LIST
2418: LIST
2419: PUSH
2420: LD_INT 3
2422: PUSH
2423: LD_INT 34
2425: PUSH
2426: LD_INT 31
2428: PUSH
2429: EMPTY
2430: LIST
2431: LIST
2432: PUSH
2433: EMPTY
2434: LIST
2435: LIST
2436: PUSH
2437: EMPTY
2438: LIST
2439: LIST
2440: PPUSH
2441: CALL_OW 69
2445: PUSH
2446: LD_INT 0
2448: EQUAL
2449: AND
2450: IFFALSE 2648
// begin arabian_timeing := 7 7$30 ;
2452: LD_ADDR_EXP 23
2456: PUSH
2457: LD_INT 15750
2459: ST_TO_ADDR
// x := Rand ( 1 , 3 ) ;
2460: LD_ADDR_VAR 0 3
2464: PUSH
2465: LD_INT 1
2467: PPUSH
2468: LD_INT 3
2470: PPUSH
2471: CALL_OW 12
2475: ST_TO_ADDR
// SayRadio ( scout , DS-DZ-H ) ;
2476: LD_EXP 12
2480: PPUSH
2481: LD_STRING DS-DZ-H
2483: PPUSH
2484: CALL_OW 94
// case x of 1 :
2488: LD_VAR 0 3
2492: PUSH
2493: LD_INT 1
2495: DOUBLE
2496: EQUAL
2497: IFTRUE 2501
2499: GO 2511
2501: POP
// RaiseSailEvent ( 31 ) ; 2 :
2502: LD_INT 31
2504: PPUSH
2505: CALL_OW 427
2509: GO 2548
2511: LD_INT 2
2513: DOUBLE
2514: EQUAL
2515: IFTRUE 2519
2517: GO 2529
2519: POP
// RaiseSailEvent ( 32 ) ; 3 :
2520: LD_INT 32
2522: PPUSH
2523: CALL_OW 427
2527: GO 2548
2529: LD_INT 3
2531: DOUBLE
2532: EQUAL
2533: IFTRUE 2537
2535: GO 2547
2537: POP
// RaiseSailEvent ( 33 ) ; end ;
2538: LD_INT 33
2540: PPUSH
2541: CALL_OW 427
2545: GO 2548
2547: POP
// RaiseSailEvent ( 33 ) ;
2548: LD_INT 33
2550: PPUSH
2551: CALL_OW 427
// if game_difficulty > 1 then
2555: LD_EXP 2
2559: PUSH
2560: LD_INT 1
2562: GREATER
2563: IFFALSE 2572
// RaiseSailEvent ( 33 ) ;
2565: LD_INT 33
2567: PPUSH
2568: CALL_OW 427
// if heike_dialog1 = false then
2572: LD_EXP 44
2576: PUSH
2577: LD_INT 0
2579: EQUAL
2580: IFFALSE 2611
// begin heike_dialog1 := true ;
2582: LD_ADDR_EXP 44
2586: PUSH
2587: LD_INT 1
2589: ST_TO_ADDR
// Wait ( 0 0$03 ) ;
2590: LD_INT 105
2592: PPUSH
2593: CALL_OW 67
// SayRadio ( ar_comander , heike1 ) ;
2597: LD_EXP 48
2601: PPUSH
2602: LD_STRING heike1
2604: PPUSH
2605: CALL_OW 94
// end else
2609: GO 2648
// if heike_dialog2 = false then
2611: LD_EXP 45
2615: PUSH
2616: LD_INT 0
2618: EQUAL
2619: IFFALSE 2648
// begin heike_dialog2 := true ;
2621: LD_ADDR_EXP 45
2625: PUSH
2626: LD_INT 1
2628: ST_TO_ADDR
// Wait ( 0 0$03 ) ;
2629: LD_INT 105
2631: PPUSH
2632: CALL_OW 67
// SayRadio ( ar_comander , heike2 ) ;
2636: LD_EXP 48
2640: PPUSH
2641: LD_STRING heike2
2643: PPUSH
2644: CALL_OW 94
// end ; end ; if FilterAllUnits ( [ [ f_side , 2 ] , [ f_control , control_remote ] ] ) > 0 then
2648: LD_INT 22
2650: PUSH
2651: LD_INT 2
2653: PUSH
2654: EMPTY
2655: LIST
2656: LIST
2657: PUSH
2658: LD_INT 33
2660: PUSH
2661: LD_INT 2
2663: PUSH
2664: EMPTY
2665: LIST
2666: LIST
2667: PUSH
2668: EMPTY
2669: LIST
2670: LIST
2671: PPUSH
2672: CALL_OW 69
2676: PUSH
2677: LD_INT 0
2679: GREATER
2680: IFFALSE 2689
// ConnectWithTower ( 2 ) ;
2682: LD_INT 2
2684: PPUSH
2685: CALL 7006 0 1
// if FilterAllUnits ( [ [ [ f_side , 2 ] , [ f_not , [ f_weapon , ar_control_tower ] ] , [ f_not , [ f_hastask ] ] ] ] ) > 0 then
2689: LD_INT 22
2691: PUSH
2692: LD_INT 2
2694: PUSH
2695: EMPTY
2696: LIST
2697: LIST
2698: PUSH
2699: LD_INT 3
2701: PUSH
2702: LD_INT 34
2704: PUSH
2705: LD_INT 31
2707: PUSH
2708: EMPTY
2709: LIST
2710: LIST
2711: PUSH
2712: EMPTY
2713: LIST
2714: LIST
2715: PUSH
2716: LD_INT 3
2718: PUSH
2719: LD_INT 60
2721: PUSH
2722: EMPTY
2723: LIST
2724: PUSH
2725: EMPTY
2726: LIST
2727: LIST
2728: PUSH
2729: EMPTY
2730: LIST
2731: LIST
2732: LIST
2733: PUSH
2734: EMPTY
2735: LIST
2736: PPUSH
2737: CALL_OW 69
2741: PUSH
2742: LD_INT 0
2744: GREATER
2745: IFFALSE 2891
// begin filter := FilterAllUnits ( [ [ [ f_side , 2 ] , [ f_not , [ f_weapon , ar_control_tower ] ] , [ f_not , [ f_hastask ] ] ] ] ) ;
2747: LD_ADDR_VAR 0 4
2751: PUSH
2752: LD_INT 22
2754: PUSH
2755: LD_INT 2
2757: PUSH
2758: EMPTY
2759: LIST
2760: LIST
2761: PUSH
2762: LD_INT 3
2764: PUSH
2765: LD_INT 34
2767: PUSH
2768: LD_INT 31
2770: PUSH
2771: EMPTY
2772: LIST
2773: LIST
2774: PUSH
2775: EMPTY
2776: LIST
2777: LIST
2778: PUSH
2779: LD_INT 3
2781: PUSH
2782: LD_INT 60
2784: PUSH
2785: EMPTY
2786: LIST
2787: PUSH
2788: EMPTY
2789: LIST
2790: LIST
2791: PUSH
2792: EMPTY
2793: LIST
2794: LIST
2795: LIST
2796: PUSH
2797: EMPTY
2798: LIST
2799: PPUSH
2800: CALL_OW 69
2804: ST_TO_ADDR
// x := SpeedFilter ( FilterAllUnits ( [ f_enemy , 2 ] ) , 20 ) ;
2805: LD_ADDR_VAR 0 3
2809: PUSH
2810: LD_INT 81
2812: PUSH
2813: LD_INT 2
2815: PUSH
2816: EMPTY
2817: LIST
2818: LIST
2819: PPUSH
2820: CALL_OW 69
2824: PPUSH
2825: LD_INT 20
2827: PPUSH
2828: CALL 8389 0 2
2832: ST_TO_ADDR
// for i = 1 to filter do
2833: LD_ADDR_VAR 0 1
2837: PUSH
2838: DOUBLE
2839: LD_INT 1
2841: DEC
2842: ST_TO_ADDR
2843: LD_VAR 0 4
2847: PUSH
2848: FOR_TO
2849: IFFALSE 2889
// ComAttackUnit ( filter [ i ] , NearestUnitToUnit ( x , filter [ i ] ) ) ;
2851: LD_VAR 0 4
2855: PUSH
2856: LD_VAR 0 1
2860: ARRAY
2861: PPUSH
2862: LD_VAR 0 3
2866: PPUSH
2867: LD_VAR 0 4
2871: PUSH
2872: LD_VAR 0 1
2876: ARRAY
2877: PPUSH
2878: CALL_OW 74
2882: PPUSH
2883: CALL_OW 115
2887: GO 2848
2889: POP
2890: POP
// end ; if FilterAllUnits ( [ [ [ f_side , 3 ] , [ f_not , [ f_hastask ] ] ] ] ) > 0 then
2891: LD_INT 22
2893: PUSH
2894: LD_INT 3
2896: PUSH
2897: EMPTY
2898: LIST
2899: LIST
2900: PUSH
2901: LD_INT 3
2903: PUSH
2904: LD_INT 60
2906: PUSH
2907: EMPTY
2908: LIST
2909: PUSH
2910: EMPTY
2911: LIST
2912: LIST
2913: PUSH
2914: EMPTY
2915: LIST
2916: LIST
2917: PUSH
2918: EMPTY
2919: LIST
2920: PPUSH
2921: CALL_OW 69
2925: PUSH
2926: LD_INT 0
2928: GREATER
2929: IFFALSE 3075
// begin filter := FilterAllUnits ( [ [ [ f_side , 3 ] , [ f_not , [ f_weapon , ar_control_tower ] ] , [ f_not , [ f_hastask ] ] ] ] ) ;
2931: LD_ADDR_VAR 0 4
2935: PUSH
2936: LD_INT 22
2938: PUSH
2939: LD_INT 3
2941: PUSH
2942: EMPTY
2943: LIST
2944: LIST
2945: PUSH
2946: LD_INT 3
2948: PUSH
2949: LD_INT 34
2951: PUSH
2952: LD_INT 31
2954: PUSH
2955: EMPTY
2956: LIST
2957: LIST
2958: PUSH
2959: EMPTY
2960: LIST
2961: LIST
2962: PUSH
2963: LD_INT 3
2965: PUSH
2966: LD_INT 60
2968: PUSH
2969: EMPTY
2970: LIST
2971: PUSH
2972: EMPTY
2973: LIST
2974: LIST
2975: PUSH
2976: EMPTY
2977: LIST
2978: LIST
2979: LIST
2980: PUSH
2981: EMPTY
2982: LIST
2983: PPUSH
2984: CALL_OW 69
2988: ST_TO_ADDR
// x := SpeedFilter ( FilterAllUnits ( [ f_enemy , 3 ] ) , 20 ) ;
2989: LD_ADDR_VAR 0 3
2993: PUSH
2994: LD_INT 81
2996: PUSH
2997: LD_INT 3
2999: PUSH
3000: EMPTY
3001: LIST
3002: LIST
3003: PPUSH
3004: CALL_OW 69
3008: PPUSH
3009: LD_INT 20
3011: PPUSH
3012: CALL 8389 0 2
3016: ST_TO_ADDR
// for i = 1 to filter do
3017: LD_ADDR_VAR 0 1
3021: PUSH
3022: DOUBLE
3023: LD_INT 1
3025: DEC
3026: ST_TO_ADDR
3027: LD_VAR 0 4
3031: PUSH
3032: FOR_TO
3033: IFFALSE 3073
// ComAttackUnit ( filter [ i ] , NearestUnitToUnit ( x , filter [ i ] ) ) ;
3035: LD_VAR 0 4
3039: PUSH
3040: LD_VAR 0 1
3044: ARRAY
3045: PPUSH
3046: LD_VAR 0 3
3050: PPUSH
3051: LD_VAR 0 4
3055: PUSH
3056: LD_VAR 0 1
3060: ARRAY
3061: PPUSH
3062: CALL_OW 74
3066: PPUSH
3067: CALL_OW 115
3071: GO 3032
3073: POP
3074: POP
// end ; if FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_not , [ f_hastask ] ] ] ] ) > 0 then
3075: LD_INT 22
3077: PUSH
3078: LD_INT 1
3080: PUSH
3081: EMPTY
3082: LIST
3083: LIST
3084: PUSH
3085: LD_INT 3
3087: PUSH
3088: LD_INT 60
3090: PUSH
3091: EMPTY
3092: LIST
3093: PUSH
3094: EMPTY
3095: LIST
3096: LIST
3097: PUSH
3098: EMPTY
3099: LIST
3100: LIST
3101: PUSH
3102: EMPTY
3103: LIST
3104: PPUSH
3105: CALL_OW 69
3109: PUSH
3110: LD_INT 0
3112: GREATER
3113: IFFALSE 3259
// begin filter := FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_not , [ f_weapon , ar_control_tower ] ] , [ f_not , [ f_hastask ] ] ] ] ) ;
3115: LD_ADDR_VAR 0 4
3119: PUSH
3120: LD_INT 22
3122: PUSH
3123: LD_INT 1
3125: PUSH
3126: EMPTY
3127: LIST
3128: LIST
3129: PUSH
3130: LD_INT 3
3132: PUSH
3133: LD_INT 34
3135: PUSH
3136: LD_INT 31
3138: PUSH
3139: EMPTY
3140: LIST
3141: LIST
3142: PUSH
3143: EMPTY
3144: LIST
3145: LIST
3146: PUSH
3147: LD_INT 3
3149: PUSH
3150: LD_INT 60
3152: PUSH
3153: EMPTY
3154: LIST
3155: PUSH
3156: EMPTY
3157: LIST
3158: LIST
3159: PUSH
3160: EMPTY
3161: LIST
3162: LIST
3163: LIST
3164: PUSH
3165: EMPTY
3166: LIST
3167: PPUSH
3168: CALL_OW 69
3172: ST_TO_ADDR
// x := SpeedFilter ( FilterAllUnits ( [ f_enemy , 1 ] ) , 20 ) ;
3173: LD_ADDR_VAR 0 3
3177: PUSH
3178: LD_INT 81
3180: PUSH
3181: LD_INT 1
3183: PUSH
3184: EMPTY
3185: LIST
3186: LIST
3187: PPUSH
3188: CALL_OW 69
3192: PPUSH
3193: LD_INT 20
3195: PPUSH
3196: CALL 8389 0 2
3200: ST_TO_ADDR
// for i = 1 to filter do
3201: LD_ADDR_VAR 0 1
3205: PUSH
3206: DOUBLE
3207: LD_INT 1
3209: DEC
3210: ST_TO_ADDR
3211: LD_VAR 0 4
3215: PUSH
3216: FOR_TO
3217: IFFALSE 3257
// ComAttackUnit ( filter [ i ] , NearestUnitToUnit ( x , filter [ i ] ) ) ;
3219: LD_VAR 0 4
3223: PUSH
3224: LD_VAR 0 1
3228: ARRAY
3229: PPUSH
3230: LD_VAR 0 3
3234: PPUSH
3235: LD_VAR 0 4
3239: PUSH
3240: LD_VAR 0 1
3244: ARRAY
3245: PPUSH
3246: CALL_OW 74
3250: PPUSH
3251: CALL_OW 115
3255: GO 3216
3257: POP
3258: POP
// end ; if FilterAllUnits ( [ [ [ f_side , 2 ] , [ f_weapon , ar_bio_bomb ] , [ f_not , [ f_lives , 700 ] ] ] ] ) > 0 then
3259: LD_INT 22
3261: PUSH
3262: LD_INT 2
3264: PUSH
3265: EMPTY
3266: LIST
3267: LIST
3268: PUSH
3269: LD_INT 34
3271: PUSH
3272: LD_EXP 56
3276: PUSH
3277: EMPTY
3278: LIST
3279: LIST
3280: PUSH
3281: LD_INT 3
3283: PUSH
3284: LD_INT 24
3286: PUSH
3287: LD_INT 700
3289: PUSH
3290: EMPTY
3291: LIST
3292: LIST
3293: PUSH
3294: EMPTY
3295: LIST
3296: LIST
3297: PUSH
3298: EMPTY
3299: LIST
3300: LIST
3301: LIST
3302: PUSH
3303: EMPTY
3304: LIST
3305: PPUSH
3306: CALL_OW 69
3310: PUSH
3311: LD_INT 0
3313: GREATER
3314: IFFALSE 3413
// begin filter := FilterAllUnits ( [ [ [ f_side , 2 ] , [ f_weapon , ar_bio_bomb ] , [ f_not , [ f_lives , 700 ] ] ] ] ) ;
3316: LD_ADDR_VAR 0 4
3320: PUSH
3321: LD_INT 22
3323: PUSH
3324: LD_INT 2
3326: PUSH
3327: EMPTY
3328: LIST
3329: LIST
3330: PUSH
3331: LD_INT 34
3333: PUSH
3334: LD_EXP 56
3338: PUSH
3339: EMPTY
3340: LIST
3341: LIST
3342: PUSH
3343: LD_INT 3
3345: PUSH
3346: LD_INT 24
3348: PUSH
3349: LD_INT 700
3351: PUSH
3352: EMPTY
3353: LIST
3354: LIST
3355: PUSH
3356: EMPTY
3357: LIST
3358: LIST
3359: PUSH
3360: EMPTY
3361: LIST
3362: LIST
3363: LIST
3364: PUSH
3365: EMPTY
3366: LIST
3367: PPUSH
3368: CALL_OW 69
3372: ST_TO_ADDR
// for i = 1 to filter do
3373: LD_ADDR_VAR 0 1
3377: PUSH
3378: DOUBLE
3379: LD_INT 1
3381: DEC
3382: ST_TO_ADDR
3383: LD_VAR 0 4
3387: PUSH
3388: FOR_TO
3389: IFFALSE 3411
// SetLives ( filter [ i ] , 1 ) ;
3391: LD_VAR 0 4
3395: PUSH
3396: LD_VAR 0 1
3400: ARRAY
3401: PPUSH
3402: LD_INT 1
3404: PPUSH
3405: CALL_OW 234
3409: GO 3388
3411: POP
3412: POP
// end ; end ; end_of_file
3413: PPOPN 4
3415: END
// export function Start_Mission ; begin
3416: LD_INT 0
3418: PPUSH
// PrepareLegion ;
3419: CALL 3460 0 0
// PrepareMeeting ;
3423: CALL 4077 0 0
// case Query ( DS-text-beg ) of 1 :
3427: LD_STRING DS-text-beg
3429: PPUSH
3430: CALL_OW 97
3434: PUSH
3435: LD_INT 1
3437: DOUBLE
3438: EQUAL
3439: IFTRUE 3443
3441: GO 3446
3443: POP
// ; end ;
3444: GO 3447
3446: POP
// game_on := true ;
3447: LD_ADDR_EXP 1
3451: PUSH
3452: LD_INT 1
3454: ST_TO_ADDR
// end ;
3455: LD_VAR 0 1
3459: RET
// export l_cmndr , l_skill , l_units ; function PrepareLegion ; var i , p , filter , team ; begin
3460: LD_INT 0
3462: PPUSH
3463: PPUSH
3464: PPUSH
3465: PPUSH
3466: PPUSH
// uc_side := 8 ;
3467: LD_ADDR_OWVAR 20
3471: PUSH
3472: LD_INT 8
3474: ST_TO_ADDR
// uc_nation := 2 ;
3475: LD_ADDR_OWVAR 21
3479: PUSH
3480: LD_INT 2
3482: ST_TO_ADDR
// l_skill := [ 7 , 6 , 5 ] [ difficulty ] ;
3483: LD_ADDR_EXP 50
3487: PUSH
3488: LD_INT 7
3490: PUSH
3491: LD_INT 6
3493: PUSH
3494: LD_INT 5
3496: PUSH
3497: EMPTY
3498: LIST
3499: LIST
3500: LIST
3501: PUSH
3502: LD_OWVAR 67
3506: ARRAY
3507: ST_TO_ADDR
// l_units := [ 8 , 7 , 6 ] [ difficulty ] ;
3508: LD_ADDR_EXP 51
3512: PUSH
3513: LD_INT 8
3515: PUSH
3516: LD_INT 7
3518: PUSH
3519: LD_INT 6
3521: PUSH
3522: EMPTY
3523: LIST
3524: LIST
3525: LIST
3526: PUSH
3527: LD_OWVAR 67
3531: ARRAY
3532: ST_TO_ADDR
// filter := [ ] ;
3533: LD_ADDR_VAR 0 4
3537: PUSH
3538: EMPTY
3539: ST_TO_ADDR
// hc_gallery := desert ;
3540: LD_ADDR_OWVAR 33
3544: PUSH
3545: LD_STRING desert
3547: ST_TO_ADDR
// hc_face_number := 1 ;
3548: LD_ADDR_OWVAR 34
3552: PUSH
3553: LD_INT 1
3555: ST_TO_ADDR
// hc_skills := [ l_skill + 2 , l_skill - 1 , l_skill , l_skill + 1 ] ;
3556: LD_ADDR_OWVAR 31
3560: PUSH
3561: LD_EXP 50
3565: PUSH
3566: LD_INT 2
3568: PLUS
3569: PUSH
3570: LD_EXP 50
3574: PUSH
3575: LD_INT 1
3577: MINUS
3578: PUSH
3579: LD_EXP 50
3583: PUSH
3584: LD_EXP 50
3588: PUSH
3589: LD_INT 1
3591: PLUS
3592: PUSH
3593: EMPTY
3594: LIST
3595: LIST
3596: LIST
3597: LIST
3598: ST_TO_ADDR
// hc_sex := sex_male ;
3599: LD_ADDR_OWVAR 27
3603: PUSH
3604: LD_INT 1
3606: ST_TO_ADDR
// hc_name := Henri Ruotz ;
3607: LD_ADDR_OWVAR 26
3611: PUSH
3612: LD_STRING Henri Ruotz
3614: ST_TO_ADDR
// hc_attr := [ 10 , 10 ] ;
3615: LD_ADDR_OWVAR 29
3619: PUSH
3620: LD_INT 10
3622: PUSH
3623: LD_INT 10
3625: PUSH
3626: EMPTY
3627: LIST
3628: LIST
3629: ST_TO_ADDR
// hc_class := 1 ;
3630: LD_ADDR_OWVAR 28
3634: PUSH
3635: LD_INT 1
3637: ST_TO_ADDR
// hc_importance := 100 ;
3638: LD_ADDR_OWVAR 32
3642: PUSH
3643: LD_INT 100
3645: ST_TO_ADDR
// l_cmndr := CreateHuman ;
3646: LD_ADDR_EXP 49
3650: PUSH
3651: CALL_OW 44
3655: ST_TO_ADDR
// hc_importance := 0 ;
3656: LD_ADDR_OWVAR 32
3660: PUSH
3661: LD_INT 0
3663: ST_TO_ADDR
// scout := PrepareHuman ( sex_male , 1 , 0 ) ;
3664: LD_ADDR_EXP 12
3668: PUSH
3669: LD_INT 1
3671: PPUSH
3672: LD_INT 1
3674: PPUSH
3675: LD_INT 0
3677: PPUSH
3678: CALL_OW 380
3682: ST_TO_ADDR
// for i = 1 to 4 do
3683: LD_ADDR_VAR 0 2
3687: PUSH
3688: DOUBLE
3689: LD_INT 1
3691: DEC
3692: ST_TO_ADDR
3693: LD_INT 4
3695: PUSH
3696: FOR_TO
3697: IFFALSE 3747
// for p = 1 to 6 do
3699: LD_ADDR_VAR 0 3
3703: PUSH
3704: DOUBLE
3705: LD_INT 1
3707: DEC
3708: ST_TO_ADDR
3709: LD_INT 6
3711: PUSH
3712: FOR_TO
3713: IFFALSE 3743
// filter := filter ^ CreateHumanWithClass ( i , l_skill ) ;
3715: LD_ADDR_VAR 0 4
3719: PUSH
3720: LD_VAR 0 4
3724: PUSH
3725: LD_VAR 0 2
3729: PPUSH
3730: LD_EXP 50
3734: PPUSH
3735: CALL 7190 0 2
3739: ADD
3740: ST_TO_ADDR
3741: GO 3712
3743: POP
3744: POP
3745: GO 3696
3747: POP
3748: POP
// team := CharacterSelection ( text , l_units , l_units , [ sel_change_class , l_cmndr , sel_changeable , sel_not_hired ] ^ filter , [ class_soldier , class_mechanic , class_engineer , class_scientistic , class_mortar ] ) ;
3749: LD_ADDR_VAR 0 5
3753: PUSH
3754: LD_STRING text
3756: PPUSH
3757: LD_EXP 51
3761: PPUSH
3762: LD_EXP 51
3766: PPUSH
3767: LD_INT -5
3769: PUSH
3770: LD_EXP 49
3774: PUSH
3775: LD_INT -3
3777: PUSH
3778: LD_INT -2
3780: PUSH
3781: EMPTY
3782: LIST
3783: LIST
3784: LIST
3785: LIST
3786: PUSH
3787: LD_VAR 0 4
3791: ADD
3792: PPUSH
3793: LD_INT 1
3795: PUSH
3796: LD_INT 3
3798: PUSH
3799: LD_INT 2
3801: PUSH
3802: LD_INT 4
3804: PUSH
3805: LD_INT 8
3807: PUSH
3808: EMPTY
3809: LIST
3810: LIST
3811: LIST
3812: LIST
3813: LIST
3814: PPUSH
3815: CALL_OW 42
3819: ST_TO_ADDR
// for i = 1 to l_units do
3820: LD_ADDR_VAR 0 2
3824: PUSH
3825: DOUBLE
3826: LD_INT 1
3828: DEC
3829: ST_TO_ADDR
3830: LD_EXP 51
3834: PUSH
3835: FOR_TO
3836: IFFALSE 3861
// PlaceUnitArea ( team [ i ] , legion_spawn , false ) ;
3838: LD_VAR 0 5
3842: PUSH
3843: LD_VAR 0 2
3847: ARRAY
3848: PPUSH
3849: LD_INT 1
3851: PPUSH
3852: LD_INT 0
3854: PPUSH
3855: CALL_OW 49
3859: GO 3835
3861: POP
3862: POP
// PlaceUnitArea ( l_cmndr , legion_spawn , false ) ;
3863: LD_EXP 49
3867: PPUSH
3868: LD_INT 1
3870: PPUSH
3871: LD_INT 0
3873: PPUSH
3874: CALL_OW 49
// end ;
3878: LD_VAR 0 1
3882: RET
// export function PlaceCamera ; begin
3883: LD_INT 0
3885: PPUSH
// PlaceSeeing ( 46 , 48 , 8 , 10 ) ;
3886: LD_INT 46
3888: PPUSH
3889: LD_INT 48
3891: PPUSH
3892: LD_INT 8
3894: PPUSH
3895: LD_INT 10
3897: PPUSH
3898: CALL_OW 330
// PlaceSeeing ( 58 , 66 , 8 , 10 ) ;
3902: LD_INT 58
3904: PPUSH
3905: LD_INT 66
3907: PPUSH
3908: LD_INT 8
3910: PPUSH
3911: LD_INT 10
3913: PPUSH
3914: CALL_OW 330
// PlaceSeeing ( 82 , 82 , 8 , 10 ) ;
3918: LD_INT 82
3920: PPUSH
3921: LD_INT 82
3923: PPUSH
3924: LD_INT 8
3926: PPUSH
3927: LD_INT 10
3929: PPUSH
3930: CALL_OW 330
// PlaceSeeing ( 107 , 79 , 8 , 10 ) ;
3934: LD_INT 107
3936: PPUSH
3937: LD_INT 79
3939: PPUSH
3940: LD_INT 8
3942: PPUSH
3943: LD_INT 10
3945: PPUSH
3946: CALL_OW 330
// PlaceSeeing ( 101 , 57 , 8 , 10 ) ;
3950: LD_INT 101
3952: PPUSH
3953: LD_INT 57
3955: PPUSH
3956: LD_INT 8
3958: PPUSH
3959: LD_INT 10
3961: PPUSH
3962: CALL_OW 330
// PlaceSeeing ( 85 , 32 , 8 , 10 ) ;
3966: LD_INT 85
3968: PPUSH
3969: LD_INT 32
3971: PPUSH
3972: LD_INT 8
3974: PPUSH
3975: LD_INT 10
3977: PPUSH
3978: CALL_OW 330
// PlaceSeeing ( 108 , 72 , 8 , 10 ) ;
3982: LD_INT 108
3984: PPUSH
3985: LD_INT 72
3987: PPUSH
3988: LD_INT 8
3990: PPUSH
3991: LD_INT 10
3993: PPUSH
3994: CALL_OW 330
// PlaceSeeing ( 124 , 74 , 8 , 10 ) ;
3998: LD_INT 124
4000: PPUSH
4001: LD_INT 74
4003: PPUSH
4004: LD_INT 8
4006: PPUSH
4007: LD_INT 10
4009: PPUSH
4010: CALL_OW 330
// PlaceSeeing ( 67 , 33 , 8 , 20 ) ;
4014: LD_INT 67
4016: PPUSH
4017: LD_INT 33
4019: PPUSH
4020: LD_INT 8
4022: PPUSH
4023: LD_INT 20
4025: PPUSH
4026: CALL_OW 330
// RemoveSeeing ( 67 , 33 , 8 ) ;
4030: LD_INT 67
4032: PPUSH
4033: LD_INT 33
4035: PPUSH
4036: LD_INT 8
4038: PPUSH
4039: CALL_OW 331
// PlaceSeeing ( 94 , 84 , 8 , 20 ) ;
4043: LD_INT 94
4045: PPUSH
4046: LD_INT 84
4048: PPUSH
4049: LD_INT 8
4051: PPUSH
4052: LD_INT 20
4054: PPUSH
4055: CALL_OW 330
// RemoveSeeing ( 94 , 84 , 8 ) ;
4059: LD_INT 94
4061: PPUSH
4062: LD_INT 84
4064: PPUSH
4065: LD_INT 8
4067: PPUSH
4068: CALL_OW 331
// end ;
4072: LD_VAR 0 1
4076: RET
// export function PrepareMeeting ; begin
4077: LD_INT 0
4079: PPUSH
// uc_side := 6 ;
4080: LD_ADDR_OWVAR 20
4084: PUSH
4085: LD_INT 6
4087: ST_TO_ADDR
// hc_gallery := desert ;
4088: LD_ADDR_OWVAR 33
4092: PUSH
4093: LD_STRING desert
4095: ST_TO_ADDR
// hc_face_number := 2 ;
4096: LD_ADDR_OWVAR 34
4100: PUSH
4101: LD_INT 2
4103: ST_TO_ADDR
// hc_name := Leopold Drass ;
4104: LD_ADDR_OWVAR 26
4108: PUSH
4109: LD_STRING Leopold Drass
4111: ST_TO_ADDR
// hc_class := 1 ;
4112: LD_ADDR_OWVAR 28
4116: PUSH
4117: LD_INT 1
4119: ST_TO_ADDR
// hc_sex := sex_male ;
4120: LD_ADDR_OWVAR 27
4124: PUSH
4125: LD_INT 1
4127: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
4128: LD_ADDR_OWVAR 29
4132: PUSH
4133: LD_INT 12
4135: PUSH
4136: LD_INT 12
4138: PUSH
4139: EMPTY
4140: LIST
4141: LIST
4142: ST_TO_ADDR
// Leopold := CreateHuman ;
4143: LD_ADDR_EXP 7
4147: PUSH
4148: CALL_OW 44
4152: ST_TO_ADDR
// PlaceUnitArea ( Leopold , north_spawn , false ) ;
4153: LD_EXP 7
4157: PPUSH
4158: LD_INT 3
4160: PPUSH
4161: LD_INT 0
4163: PPUSH
4164: CALL_OW 49
// end ; end_of_file
4168: LD_VAR 0 1
4172: RET
// on SailEvent ( num ) do var i , filter , un , p , area ;
4173: LD_INT 0
4175: PPUSH
4176: PPUSH
4177: PPUSH
4178: PPUSH
4179: PPUSH
// begin case num of 1 :
4180: LD_VAR 0 1
4184: PUSH
4185: LD_INT 1
4187: DOUBLE
4188: EQUAL
4189: IFTRUE 4193
4191: GO 4225
4193: POP
// begin ComMoveXY ( leopold , GetX ( l_cmndr ) , GetY ( l_cmndr ) ) ;
4194: LD_EXP 7
4198: PPUSH
4199: LD_EXP 49
4203: PPUSH
4204: CALL_OW 250
4208: PPUSH
4209: LD_EXP 49
4213: PPUSH
4214: CALL_OW 251
4218: PPUSH
4219: CALL_OW 111
// end ; 2 :
4223: GO 6602
4225: LD_INT 2
4227: DOUBLE
4228: EQUAL
4229: IFTRUE 4233
4231: GO 4342
4233: POP
// begin InGameOn ;
4234: CALL_OW 8
// meeting_start := true ;
4238: LD_ADDR_EXP 26
4242: PUSH
4243: LD_INT 1
4245: ST_TO_ADDR
// ComTurnUnit ( leopold , l_cmndr ) ;
4246: LD_EXP 7
4250: PPUSH
4251: LD_EXP 49
4255: PPUSH
4256: CALL_OW 119
// ComTurnUnit ( l_cmndr , leopold ) ;
4260: LD_EXP 49
4264: PPUSH
4265: LD_EXP 7
4269: PPUSH
4270: CALL_OW 119
// Say ( leopold , DS-DL-1 ) ;
4274: LD_EXP 7
4278: PPUSH
4279: LD_STRING DS-DL-1
4281: PPUSH
4282: CALL_OW 88
// Say ( l_cmndr , DS-DC-1 ) ;
4286: LD_EXP 49
4290: PPUSH
4291: LD_STRING DS-DC-1
4293: PPUSH
4294: CALL_OW 88
// Say ( leopold , DS-DL-2 ) ;
4298: LD_EXP 7
4302: PPUSH
4303: LD_STRING DS-DL-2
4305: PPUSH
4306: CALL_OW 88
// ComEnterUnit ( leopold , fort ) ;
4310: LD_EXP 7
4314: PPUSH
4315: LD_INT 23
4317: PPUSH
4318: CALL_OW 120
// InGameOff ;
4322: CALL_OW 9
// Wait ( 0 0$01 ) ;
4326: LD_INT 35
4328: PPUSH
4329: CALL_OW 67
// ChangeMissionObjectives ( DS-T1 ) ;
4333: LD_STRING DS-T1
4335: PPUSH
4336: CALL_OW 337
// end ; 10 :
4340: GO 6602
4342: LD_INT 10
4344: DOUBLE
4345: EQUAL
4346: IFTRUE 4350
4348: GO 4562
4350: POP
// begin uc_side := 6 ;
4351: LD_ADDR_OWVAR 20
4355: PUSH
4356: LD_INT 6
4358: ST_TO_ADDR
// uc_nation := 2 ;
4359: LD_ADDR_OWVAR 21
4363: PUSH
4364: LD_INT 2
4366: ST_TO_ADDR
// hc_gallery :=  ;
4367: LD_ADDR_OWVAR 33
4371: PUSH
4372: LD_STRING 
4374: ST_TO_ADDR
// hc_skills := [ skill + 2 , skill - 1 , skill , skill + 1 ] ;
4375: LD_ADDR_OWVAR 31
4379: PUSH
4380: LD_EXP 16
4384: PUSH
4385: LD_INT 2
4387: PLUS
4388: PUSH
4389: LD_EXP 16
4393: PUSH
4394: LD_INT 1
4396: MINUS
4397: PUSH
4398: LD_EXP 16
4402: PUSH
4403: LD_EXP 16
4407: PUSH
4408: LD_INT 1
4410: PLUS
4411: PUSH
4412: EMPTY
4413: LIST
4414: LIST
4415: LIST
4416: LIST
4417: ST_TO_ADDR
// hc_sex := sex_male ;
4418: LD_ADDR_OWVAR 27
4422: PUSH
4423: LD_INT 1
4425: ST_TO_ADDR
// hc_name := Samuel van Horn ;
4426: LD_ADDR_OWVAR 26
4430: PUSH
4431: LD_STRING Samuel van Horn
4433: ST_TO_ADDR
// hc_attr := [ 11 , 10 ] ;
4434: LD_ADDR_OWVAR 29
4438: PUSH
4439: LD_INT 11
4441: PUSH
4442: LD_INT 10
4444: PUSH
4445: EMPTY
4446: LIST
4447: LIST
4448: ST_TO_ADDR
// hc_class := 1 ;
4449: LD_ADDR_OWVAR 28
4453: PUSH
4454: LD_INT 1
4456: ST_TO_ADDR
// samuel := CreateHuman ;
4457: LD_ADDR_EXP 9
4461: PUSH
4462: CALL_OW 44
4466: ST_TO_ADDR
// PlaceUnitArea ( samuel , south_spawn , false ) ;
4467: LD_EXP 9
4471: PPUSH
4472: LD_INT 4
4474: PPUSH
4475: LD_INT 0
4477: PPUSH
4478: CALL_OW 49
// for i = 1 to 3 do
4482: LD_ADDR_VAR 0 2
4486: PUSH
4487: DOUBLE
4488: LD_INT 1
4490: DEC
4491: ST_TO_ADDR
4492: LD_INT 3
4494: PUSH
4495: FOR_TO
4496: IFFALSE 4523
// PlaceUnitArea ( CreateHumanWithClass ( class_mortar , skill ) , south_spawn , false ) ;
4498: LD_INT 8
4500: PPUSH
4501: LD_EXP 16
4505: PPUSH
4506: CALL 7190 0 2
4510: PPUSH
4511: LD_INT 4
4513: PPUSH
4514: LD_INT 0
4516: PPUSH
4517: CALL_OW 49
4521: GO 4495
4523: POP
4524: POP
// ComEnterUnit ( FilterAllUnits ( [ f_side , 6 ] ) diff [ leopold , fort ] , fort ) ;
4525: LD_INT 22
4527: PUSH
4528: LD_INT 6
4530: PUSH
4531: EMPTY
4532: LIST
4533: LIST
4534: PPUSH
4535: CALL_OW 69
4539: PUSH
4540: LD_EXP 7
4544: PUSH
4545: LD_INT 23
4547: PUSH
4548: EMPTY
4549: LIST
4550: LIST
4551: DIFF
4552: PPUSH
4553: LD_INT 23
4555: PPUSH
4556: CALL_OW 120
// end ; 3 :
4560: GO 6602
4562: LD_INT 3
4564: DOUBLE
4565: EQUAL
4566: IFTRUE 4570
4568: GO 4581
4570: POP
// begin arabian_attack := true ;
4571: LD_ADDR_EXP 38
4575: PUSH
4576: LD_INT 1
4578: ST_TO_ADDR
// end ; 4 :
4579: GO 6602
4581: LD_INT 4
4583: DOUBLE
4584: EQUAL
4585: IFTRUE 4589
4587: GO 4600
4589: POP
// begin american_attack := true ;
4590: LD_ADDR_EXP 40
4594: PUSH
4595: LD_INT 1
4597: ST_TO_ADDR
// end ; 5 :
4598: GO 6602
4600: LD_INT 5
4602: DOUBLE
4603: EQUAL
4604: IFTRUE 4608
4606: GO 4619
4608: POP
// begin russian_attack := true ;
4609: LD_ADDR_EXP 39
4613: PUSH
4614: LD_INT 1
4616: ST_TO_ADDR
// end ; 31 :
4617: GO 6602
4619: LD_INT 31
4621: DOUBLE
4622: EQUAL
4623: IFTRUE 4627
4625: GO 4902
4627: POP
// begin area := areas [ Rand ( 1 , areas ) ] ;
4628: LD_ADDR_VAR 0 6
4632: PUSH
4633: LD_EXP 15
4637: PUSH
4638: LD_INT 1
4640: PPUSH
4641: LD_EXP 15
4645: PPUSH
4646: CALL_OW 12
4650: ARRAY
4651: ST_TO_ADDR
// uc_side := 2 ;
4652: LD_ADDR_OWVAR 20
4656: PUSH
4657: LD_INT 2
4659: ST_TO_ADDR
// uc_nation := 2 ;
4660: LD_ADDR_OWVAR 21
4664: PUSH
4665: LD_INT 2
4667: ST_TO_ADDR
// for i = 1 to arabian_force do
4668: LD_ADDR_VAR 0 2
4672: PUSH
4673: DOUBLE
4674: LD_INT 1
4676: DEC
4677: ST_TO_ADDR
4678: LD_EXP 20
4682: PUSH
4683: FOR_TO
4684: IFFALSE 4763
// begin vc_chassis := ar_half_tracked ;
4686: LD_ADDR_OWVAR 37
4690: PUSH
4691: LD_INT 14
4693: ST_TO_ADDR
// vc_engine := engine_siberite ;
4694: LD_ADDR_OWVAR 39
4698: PUSH
4699: LD_INT 3
4701: ST_TO_ADDR
// vc_control := control_remote ;
4702: LD_ADDR_OWVAR 38
4706: PUSH
4707: LD_INT 2
4709: ST_TO_ADDR
// vc_weapon := ar_weapons [ Rand ( 1 , ar_weapons ) ] ;
4710: LD_ADDR_OWVAR 40
4714: PUSH
4715: LD_EXP 17
4719: PUSH
4720: LD_INT 1
4722: PPUSH
4723: LD_EXP 17
4727: PPUSH
4728: CALL_OW 12
4732: ARRAY
4733: ST_TO_ADDR
// un := CreateVehicle ;
4734: LD_ADDR_VAR 0 4
4738: PUSH
4739: CALL_OW 45
4743: ST_TO_ADDR
// PlaceUnitArea ( un , area , false ) ;
4744: LD_VAR 0 4
4748: PPUSH
4749: LD_VAR 0 6
4753: PPUSH
4754: LD_INT 0
4756: PPUSH
4757: CALL_OW 49
// end ;
4761: GO 4683
4763: POP
4764: POP
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_control , control_manual ] ] ) < 2 then
4765: LD_INT 22
4767: PUSH
4768: LD_INT 2
4770: PUSH
4771: EMPTY
4772: LIST
4773: LIST
4774: PUSH
4775: LD_INT 33
4777: PUSH
4778: LD_INT 1
4780: PUSH
4781: EMPTY
4782: LIST
4783: LIST
4784: PUSH
4785: EMPTY
4786: LIST
4787: LIST
4788: PPUSH
4789: CALL_OW 69
4793: PUSH
4794: LD_INT 2
4796: LESS
4797: IFFALSE 4900
// for i = 1 to 2 do
4799: LD_ADDR_VAR 0 2
4803: PUSH
4804: DOUBLE
4805: LD_INT 1
4807: DEC
4808: ST_TO_ADDR
4809: LD_INT 2
4811: PUSH
4812: FOR_TO
4813: IFFALSE 4898
// begin vc_chassis := ar_half_tracked ;
4815: LD_ADDR_OWVAR 37
4819: PUSH
4820: LD_INT 14
4822: ST_TO_ADDR
// vc_engine := engine_siberite ;
4823: LD_ADDR_OWVAR 39
4827: PUSH
4828: LD_INT 3
4830: ST_TO_ADDR
// vc_control := control_manual ;
4831: LD_ADDR_OWVAR 38
4835: PUSH
4836: LD_INT 1
4838: ST_TO_ADDR
// vc_weapon := ar_control_tower ;
4839: LD_ADDR_OWVAR 40
4843: PUSH
4844: LD_INT 31
4846: ST_TO_ADDR
// un := CreateVehicle ;
4847: LD_ADDR_VAR 0 4
4851: PUSH
4852: CALL_OW 45
4856: ST_TO_ADDR
// PlaceUnitArea ( un , area , false ) ;
4857: LD_VAR 0 4
4861: PPUSH
4862: LD_VAR 0 6
4866: PPUSH
4867: LD_INT 0
4869: PPUSH
4870: CALL_OW 49
// PlaceHumanInUnit ( CreateHumanWithClass ( 3 , skill ) , un ) ;
4874: LD_INT 3
4876: PPUSH
4877: LD_EXP 16
4881: PPUSH
4882: CALL 7190 0 2
4886: PPUSH
4887: LD_VAR 0 4
4891: PPUSH
4892: CALL_OW 52
// end ;
4896: GO 4812
4898: POP
4899: POP
// end ; 32 :
4900: GO 6602
4902: LD_INT 32
4904: DOUBLE
4905: EQUAL
4906: IFTRUE 4910
4908: GO 5283
4910: POP
// begin area := areas [ Rand ( 1 , areas ) ] ;
4911: LD_ADDR_VAR 0 6
4915: PUSH
4916: LD_EXP 15
4920: PUSH
4921: LD_INT 1
4923: PPUSH
4924: LD_EXP 15
4928: PPUSH
4929: CALL_OW 12
4933: ARRAY
4934: ST_TO_ADDR
// uc_side := 2 ;
4935: LD_ADDR_OWVAR 20
4939: PUSH
4940: LD_INT 2
4942: ST_TO_ADDR
// uc_nation := 2 ;
4943: LD_ADDR_OWVAR 21
4947: PUSH
4948: LD_INT 2
4950: ST_TO_ADDR
// for i = 1 to ( arabian_force - 2 ) do
4951: LD_ADDR_VAR 0 2
4955: PUSH
4956: DOUBLE
4957: LD_INT 1
4959: DEC
4960: ST_TO_ADDR
4961: LD_EXP 20
4965: PUSH
4966: LD_INT 2
4968: MINUS
4969: PUSH
4970: FOR_TO
4971: IFFALSE 5054
// begin vc_chassis := ar_half_tracked ;
4973: LD_ADDR_OWVAR 37
4977: PUSH
4978: LD_INT 14
4980: ST_TO_ADDR
// vc_engine := engine_siberite ;
4981: LD_ADDR_OWVAR 39
4985: PUSH
4986: LD_INT 3
4988: ST_TO_ADDR
// vc_control := control_remote ;
4989: LD_ADDR_OWVAR 38
4993: PUSH
4994: LD_INT 2
4996: ST_TO_ADDR
// vc_weapon := ar_weapons [ Rand ( 1 , ar_weapons - 1 ) ] ;
4997: LD_ADDR_OWVAR 40
5001: PUSH
5002: LD_EXP 17
5006: PUSH
5007: LD_INT 1
5009: PPUSH
5010: LD_EXP 17
5014: PUSH
5015: LD_INT 1
5017: MINUS
5018: PPUSH
5019: CALL_OW 12
5023: ARRAY
5024: ST_TO_ADDR
// un := CreateVehicle ;
5025: LD_ADDR_VAR 0 4
5029: PUSH
5030: CALL_OW 45
5034: ST_TO_ADDR
// PlaceUnitArea ( un , area , false ) ;
5035: LD_VAR 0 4
5039: PPUSH
5040: LD_VAR 0 6
5044: PPUSH
5045: LD_INT 0
5047: PPUSH
5048: CALL_OW 49
// end ;
5052: GO 4970
5054: POP
5055: POP
// for i = 1 to Rand ( 0 , 1 ) + [ 3 , 4 , 5 ] [ game_difficulty ] do
5056: LD_ADDR_VAR 0 2
5060: PUSH
5061: DOUBLE
5062: LD_INT 1
5064: DEC
5065: ST_TO_ADDR
5066: LD_INT 0
5068: PPUSH
5069: LD_INT 1
5071: PPUSH
5072: CALL_OW 12
5076: PUSH
5077: LD_INT 3
5079: PUSH
5080: LD_INT 4
5082: PUSH
5083: LD_INT 5
5085: PUSH
5086: EMPTY
5087: LIST
5088: LIST
5089: LIST
5090: PUSH
5091: LD_EXP 2
5095: ARRAY
5096: PLUS
5097: PUSH
5098: FOR_TO
5099: IFFALSE 5136
// begin uc_nation := 0 ;
5101: LD_ADDR_OWVAR 21
5105: PUSH
5106: LD_INT 0
5108: ST_TO_ADDR
// PlaceUnitArea ( CreateHumanWithClass ( 17 , skill ) , area , false ) ;
5109: LD_INT 17
5111: PPUSH
5112: LD_EXP 16
5116: PPUSH
5117: CALL 7190 0 2
5121: PPUSH
5122: LD_VAR 0 6
5126: PPUSH
5127: LD_INT 0
5129: PPUSH
5130: CALL_OW 49
// end ;
5134: GO 5098
5136: POP
5137: POP
// uc_nation := 2 ;
5138: LD_ADDR_OWVAR 21
5142: PUSH
5143: LD_INT 2
5145: ST_TO_ADDR
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_control , control_manual ] ] ) < 2 then
5146: LD_INT 22
5148: PUSH
5149: LD_INT 2
5151: PUSH
5152: EMPTY
5153: LIST
5154: LIST
5155: PUSH
5156: LD_INT 33
5158: PUSH
5159: LD_INT 1
5161: PUSH
5162: EMPTY
5163: LIST
5164: LIST
5165: PUSH
5166: EMPTY
5167: LIST
5168: LIST
5169: PPUSH
5170: CALL_OW 69
5174: PUSH
5175: LD_INT 2
5177: LESS
5178: IFFALSE 5281
// for i = 1 to 2 do
5180: LD_ADDR_VAR 0 2
5184: PUSH
5185: DOUBLE
5186: LD_INT 1
5188: DEC
5189: ST_TO_ADDR
5190: LD_INT 2
5192: PUSH
5193: FOR_TO
5194: IFFALSE 5279
// begin vc_chassis := ar_half_tracked ;
5196: LD_ADDR_OWVAR 37
5200: PUSH
5201: LD_INT 14
5203: ST_TO_ADDR
// vc_engine := engine_siberite ;
5204: LD_ADDR_OWVAR 39
5208: PUSH
5209: LD_INT 3
5211: ST_TO_ADDR
// vc_control := control_manual ;
5212: LD_ADDR_OWVAR 38
5216: PUSH
5217: LD_INT 1
5219: ST_TO_ADDR
// vc_weapon := ar_control_tower ;
5220: LD_ADDR_OWVAR 40
5224: PUSH
5225: LD_INT 31
5227: ST_TO_ADDR
// un := CreateVehicle ;
5228: LD_ADDR_VAR 0 4
5232: PUSH
5233: CALL_OW 45
5237: ST_TO_ADDR
// PlaceUnitArea ( un , area , false ) ;
5238: LD_VAR 0 4
5242: PPUSH
5243: LD_VAR 0 6
5247: PPUSH
5248: LD_INT 0
5250: PPUSH
5251: CALL_OW 49
// PlaceHumanInUnit ( CreateHumanWithClass ( 3 , skill ) , un ) ;
5255: LD_INT 3
5257: PPUSH
5258: LD_EXP 16
5262: PPUSH
5263: CALL 7190 0 2
5267: PPUSH
5268: LD_VAR 0 4
5272: PPUSH
5273: CALL_OW 52
// end ;
5277: GO 5193
5279: POP
5280: POP
// end ; 33 :
5281: GO 6602
5283: LD_INT 33
5285: DOUBLE
5286: EQUAL
5287: IFTRUE 5291
5289: GO 5562
5291: POP
// begin area := areas [ Rand ( 1 , areas ) ] ;
5292: LD_ADDR_VAR 0 6
5296: PUSH
5297: LD_EXP 15
5301: PUSH
5302: LD_INT 1
5304: PPUSH
5305: LD_EXP 15
5309: PPUSH
5310: CALL_OW 12
5314: ARRAY
5315: ST_TO_ADDR
// uc_side := 2 ;
5316: LD_ADDR_OWVAR 20
5320: PUSH
5321: LD_INT 2
5323: ST_TO_ADDR
// uc_nation := 2 ;
5324: LD_ADDR_OWVAR 21
5328: PUSH
5329: LD_INT 2
5331: ST_TO_ADDR
// for i = 1 to ( arabian_force / 2 ) do
5332: LD_ADDR_VAR 0 2
5336: PUSH
5337: DOUBLE
5338: LD_INT 1
5340: DEC
5341: ST_TO_ADDR
5342: LD_EXP 20
5346: PUSH
5347: LD_INT 2
5349: DIVREAL
5350: PUSH
5351: FOR_TO
5352: IFFALSE 5457
// begin vc_chassis := ar_half_tracked ;
5354: LD_ADDR_OWVAR 37
5358: PUSH
5359: LD_INT 14
5361: ST_TO_ADDR
// vc_engine := engine_siberite ;
5362: LD_ADDR_OWVAR 39
5366: PUSH
5367: LD_INT 3
5369: ST_TO_ADDR
// vc_control := control_manual ;
5370: LD_ADDR_OWVAR 38
5374: PUSH
5375: LD_INT 1
5377: ST_TO_ADDR
// vc_weapon := ar_weapons [ Rand ( 1 , ar_weapons - 2 ) ] ;
5378: LD_ADDR_OWVAR 40
5382: PUSH
5383: LD_EXP 17
5387: PUSH
5388: LD_INT 1
5390: PPUSH
5391: LD_EXP 17
5395: PUSH
5396: LD_INT 2
5398: MINUS
5399: PPUSH
5400: CALL_OW 12
5404: ARRAY
5405: ST_TO_ADDR
// un := CreateVehicle ;
5406: LD_ADDR_VAR 0 4
5410: PUSH
5411: CALL_OW 45
5415: ST_TO_ADDR
// PlaceUnitArea ( un , area , false ) ;
5416: LD_VAR 0 4
5420: PPUSH
5421: LD_VAR 0 6
5425: PPUSH
5426: LD_INT 0
5428: PPUSH
5429: CALL_OW 49
// PlaceHumanInUnit ( CreateHumanWithClass ( 3 , skill ) , un ) ;
5433: LD_INT 3
5435: PPUSH
5436: LD_EXP 16
5440: PPUSH
5441: CALL 7190 0 2
5445: PPUSH
5446: LD_VAR 0 4
5450: PPUSH
5451: CALL_OW 52
// end ;
5455: GO 5351
5457: POP
5458: POP
// for i = 1 to ( arabian_force / 2 ) do
5459: LD_ADDR_VAR 0 2
5463: PUSH
5464: DOUBLE
5465: LD_INT 1
5467: DEC
5468: ST_TO_ADDR
5469: LD_EXP 20
5473: PUSH
5474: LD_INT 2
5476: DIVREAL
5477: PUSH
5478: FOR_TO
5479: IFFALSE 5558
// begin vc_chassis := ar_half_tracked ;
5481: LD_ADDR_OWVAR 37
5485: PUSH
5486: LD_INT 14
5488: ST_TO_ADDR
// vc_engine := engine_siberite ;
5489: LD_ADDR_OWVAR 39
5493: PUSH
5494: LD_INT 3
5496: ST_TO_ADDR
// vc_control := control_apeman ;
5497: LD_ADDR_OWVAR 38
5501: PUSH
5502: LD_INT 5
5504: ST_TO_ADDR
// vc_weapon := ar_weapons [ Rand ( 2 , ar_weapons ) ] ;
5505: LD_ADDR_OWVAR 40
5509: PUSH
5510: LD_EXP 17
5514: PUSH
5515: LD_INT 2
5517: PPUSH
5518: LD_EXP 17
5522: PPUSH
5523: CALL_OW 12
5527: ARRAY
5528: ST_TO_ADDR
// un := CreateVehicle ;
5529: LD_ADDR_VAR 0 4
5533: PUSH
5534: CALL_OW 45
5538: ST_TO_ADDR
// PlaceUnitArea ( un , area , false ) ;
5539: LD_VAR 0 4
5543: PPUSH
5544: LD_VAR 0 6
5548: PPUSH
5549: LD_INT 0
5551: PPUSH
5552: CALL_OW 49
// end ;
5556: GO 5478
5558: POP
5559: POP
// end ; 41 :
5560: GO 6602
5562: LD_INT 41
5564: DOUBLE
5565: EQUAL
5566: IFTRUE 5570
5568: GO 5714
5570: POP
// begin area := areas [ Rand ( 1 , areas ) ] ;
5571: LD_ADDR_VAR 0 6
5575: PUSH
5576: LD_EXP 15
5580: PUSH
5581: LD_INT 1
5583: PPUSH
5584: LD_EXP 15
5588: PPUSH
5589: CALL_OW 12
5593: ARRAY
5594: ST_TO_ADDR
// uc_side := 1 ;
5595: LD_ADDR_OWVAR 20
5599: PUSH
5600: LD_INT 1
5602: ST_TO_ADDR
// uc_nation := 1 ;
5603: LD_ADDR_OWVAR 21
5607: PUSH
5608: LD_INT 1
5610: ST_TO_ADDR
// for i = 1 to american_force do
5611: LD_ADDR_VAR 0 2
5615: PUSH
5616: DOUBLE
5617: LD_INT 1
5619: DEC
5620: ST_TO_ADDR
5621: LD_EXP 22
5625: PUSH
5626: FOR_TO
5627: IFFALSE 5710
// begin vc_chassis := us_morphling ;
5629: LD_ADDR_OWVAR 37
5633: PUSH
5634: LD_INT 5
5636: ST_TO_ADDR
// vc_engine := engine_siberite ;
5637: LD_ADDR_OWVAR 39
5641: PUSH
5642: LD_INT 3
5644: ST_TO_ADDR
// vc_control := control_computer ;
5645: LD_ADDR_OWVAR 38
5649: PUSH
5650: LD_INT 3
5652: ST_TO_ADDR
// vc_weapon := us_weapons [ Rand ( 1 , us_weapons - 1 ) ] ;
5653: LD_ADDR_OWVAR 40
5657: PUSH
5658: LD_EXP 19
5662: PUSH
5663: LD_INT 1
5665: PPUSH
5666: LD_EXP 19
5670: PUSH
5671: LD_INT 1
5673: MINUS
5674: PPUSH
5675: CALL_OW 12
5679: ARRAY
5680: ST_TO_ADDR
// un := CreateVehicle ;
5681: LD_ADDR_VAR 0 4
5685: PUSH
5686: CALL_OW 45
5690: ST_TO_ADDR
// PlaceUnitArea ( un , area , false ) ;
5691: LD_VAR 0 4
5695: PPUSH
5696: LD_VAR 0 6
5700: PPUSH
5701: LD_INT 0
5703: PPUSH
5704: CALL_OW 49
// end ;
5708: GO 5626
5710: POP
5711: POP
// end ; 42 :
5712: GO 6602
5714: LD_INT 42
5716: DOUBLE
5717: EQUAL
5718: IFTRUE 5722
5720: GO 5862
5722: POP
// begin area := areas [ Rand ( 1 , areas ) ] ;
5723: LD_ADDR_VAR 0 6
5727: PUSH
5728: LD_EXP 15
5732: PUSH
5733: LD_INT 1
5735: PPUSH
5736: LD_EXP 15
5740: PPUSH
5741: CALL_OW 12
5745: ARRAY
5746: ST_TO_ADDR
// uc_side := 1 ;
5747: LD_ADDR_OWVAR 20
5751: PUSH
5752: LD_INT 1
5754: ST_TO_ADDR
// uc_nation := 1 ;
5755: LD_ADDR_OWVAR 21
5759: PUSH
5760: LD_INT 1
5762: ST_TO_ADDR
// for i = 1 to american_force do
5763: LD_ADDR_VAR 0 2
5767: PUSH
5768: DOUBLE
5769: LD_INT 1
5771: DEC
5772: ST_TO_ADDR
5773: LD_EXP 22
5777: PUSH
5778: FOR_TO
5779: IFFALSE 5858
// begin vc_chassis := us_morphling ;
5781: LD_ADDR_OWVAR 37
5785: PUSH
5786: LD_INT 5
5788: ST_TO_ADDR
// vc_engine := engine_siberite ;
5789: LD_ADDR_OWVAR 39
5793: PUSH
5794: LD_INT 3
5796: ST_TO_ADDR
// vc_control := control_computer ;
5797: LD_ADDR_OWVAR 38
5801: PUSH
5802: LD_INT 3
5804: ST_TO_ADDR
// vc_weapon := us_weapons [ Rand ( 1 , us_weapons ) ] ;
5805: LD_ADDR_OWVAR 40
5809: PUSH
5810: LD_EXP 19
5814: PUSH
5815: LD_INT 1
5817: PPUSH
5818: LD_EXP 19
5822: PPUSH
5823: CALL_OW 12
5827: ARRAY
5828: ST_TO_ADDR
// un := CreateVehicle ;
5829: LD_ADDR_VAR 0 4
5833: PUSH
5834: CALL_OW 45
5838: ST_TO_ADDR
// PlaceUnitArea ( un , area , false ) ;
5839: LD_VAR 0 4
5843: PPUSH
5844: LD_VAR 0 6
5848: PPUSH
5849: LD_INT 0
5851: PPUSH
5852: CALL_OW 49
// end ;
5856: GO 5778
5858: POP
5859: POP
// end ; 51 :
5860: GO 6602
5862: LD_INT 51
5864: DOUBLE
5865: EQUAL
5866: IFTRUE 5870
5868: GO 6010
5870: POP
// begin area := areas [ Rand ( 1 , areas ) ] ;
5871: LD_ADDR_VAR 0 6
5875: PUSH
5876: LD_EXP 15
5880: PUSH
5881: LD_INT 1
5883: PPUSH
5884: LD_EXP 15
5888: PPUSH
5889: CALL_OW 12
5893: ARRAY
5894: ST_TO_ADDR
// uc_side := 3 ;
5895: LD_ADDR_OWVAR 20
5899: PUSH
5900: LD_INT 3
5902: ST_TO_ADDR
// uc_nation := 3 ;
5903: LD_ADDR_OWVAR 21
5907: PUSH
5908: LD_INT 3
5910: ST_TO_ADDR
// for i = 1 to russian_force do
5911: LD_ADDR_VAR 0 2
5915: PUSH
5916: DOUBLE
5917: LD_INT 1
5919: DEC
5920: ST_TO_ADDR
5921: LD_EXP 21
5925: PUSH
5926: FOR_TO
5927: IFFALSE 6006
// begin vc_chassis := ru_heavy_tracked ;
5929: LD_ADDR_OWVAR 37
5933: PUSH
5934: LD_INT 24
5936: ST_TO_ADDR
// vc_engine := engine_siberite ;
5937: LD_ADDR_OWVAR 39
5941: PUSH
5942: LD_INT 3
5944: ST_TO_ADDR
// vc_control := control_computer ;
5945: LD_ADDR_OWVAR 38
5949: PUSH
5950: LD_INT 3
5952: ST_TO_ADDR
// vc_weapon := ru_weapons [ Rand ( 1 , ru_weapons ) ] ;
5953: LD_ADDR_OWVAR 40
5957: PUSH
5958: LD_EXP 18
5962: PUSH
5963: LD_INT 1
5965: PPUSH
5966: LD_EXP 18
5970: PPUSH
5971: CALL_OW 12
5975: ARRAY
5976: ST_TO_ADDR
// un := CreateVehicle ;
5977: LD_ADDR_VAR 0 4
5981: PUSH
5982: CALL_OW 45
5986: ST_TO_ADDR
// PlaceUnitArea ( un , area , false ) ;
5987: LD_VAR 0 4
5991: PPUSH
5992: LD_VAR 0 6
5996: PPUSH
5997: LD_INT 0
5999: PPUSH
6000: CALL_OW 49
// end ;
6004: GO 5926
6006: POP
6007: POP
// end ; 91 :
6008: GO 6602
6010: LD_INT 91
6012: DOUBLE
6013: EQUAL
6014: IFTRUE 6018
6016: GO 6156
6018: POP
// begin uc_side := 8 ;
6019: LD_ADDR_OWVAR 20
6023: PUSH
6024: LD_INT 8
6026: ST_TO_ADDR
// uc_nation := 1 ;
6027: LD_ADDR_OWVAR 21
6031: PUSH
6032: LD_INT 1
6034: ST_TO_ADDR
// for i = 1 to [ 5 , 4 , 3 ] [ game_difficulty ] do
6035: LD_ADDR_VAR 0 2
6039: PUSH
6040: DOUBLE
6041: LD_INT 1
6043: DEC
6044: ST_TO_ADDR
6045: LD_INT 5
6047: PUSH
6048: LD_INT 4
6050: PUSH
6051: LD_INT 3
6053: PUSH
6054: EMPTY
6055: LIST
6056: LIST
6057: LIST
6058: PUSH
6059: LD_EXP 2
6063: ARRAY
6064: PUSH
6065: FOR_TO
6066: IFFALSE 6152
// begin vc_chassis := us_heavy_tracked ;
6068: LD_ADDR_OWVAR 37
6072: PUSH
6073: LD_INT 4
6075: ST_TO_ADDR
// vc_engine := engine_siberite ;
6076: LD_ADDR_OWVAR 39
6080: PUSH
6081: LD_INT 3
6083: ST_TO_ADDR
// vc_control := control_computer ;
6084: LD_ADDR_OWVAR 38
6088: PUSH
6089: LD_INT 3
6091: ST_TO_ADDR
// vc_weapon := [ us_double_gun , us_heavy_gun ] [ Rand ( 1 , 2 ) ] ;
6092: LD_ADDR_OWVAR 40
6096: PUSH
6097: LD_INT 5
6099: PUSH
6100: LD_INT 6
6102: PUSH
6103: EMPTY
6104: LIST
6105: LIST
6106: PUSH
6107: LD_INT 1
6109: PPUSH
6110: LD_INT 2
6112: PPUSH
6113: CALL_OW 12
6117: ARRAY
6118: ST_TO_ADDR
// un := CreateVehicle ;
6119: LD_ADDR_VAR 0 4
6123: PUSH
6124: CALL_OW 45
6128: ST_TO_ADDR
// PlaceUnitArea ( un , areas [ 1 ] , false ) ;
6129: LD_VAR 0 4
6133: PPUSH
6134: LD_EXP 15
6138: PUSH
6139: LD_INT 1
6141: ARRAY
6142: PPUSH
6143: LD_INT 0
6145: PPUSH
6146: CALL_OW 49
// end ;
6150: GO 6065
6152: POP
6153: POP
// end ; 92 :
6154: GO 6602
6156: LD_INT 92
6158: DOUBLE
6159: EQUAL
6160: IFTRUE 6164
6162: GO 6469
6164: POP
// begin uc_side := 5 ;
6165: LD_ADDR_OWVAR 20
6169: PUSH
6170: LD_INT 5
6172: ST_TO_ADDR
// uc_nation := 2 ;
6173: LD_ADDR_OWVAR 21
6177: PUSH
6178: LD_INT 2
6180: ST_TO_ADDR
// filter := [ ] ;
6181: LD_ADDR_VAR 0 3
6185: PUSH
6186: EMPTY
6187: ST_TO_ADDR
// hc_sex := sex_male ;
6188: LD_ADDR_OWVAR 27
6192: PUSH
6193: LD_INT 1
6195: ST_TO_ADDR
// hc_gallery :=  ;
6196: LD_ADDR_OWVAR 33
6200: PUSH
6201: LD_STRING 
6203: ST_TO_ADDR
// hc_class := 1 ;
6204: LD_ADDR_OWVAR 28
6208: PUSH
6209: LD_INT 1
6211: ST_TO_ADDR
// hc_name :=  ;
6212: LD_ADDR_OWVAR 26
6216: PUSH
6217: LD_STRING 
6219: ST_TO_ADDR
// un := CreateHuman ;
6220: LD_ADDR_VAR 0 4
6224: PUSH
6225: CALL_OW 44
6229: ST_TO_ADDR
// filter := filter ^ un ;
6230: LD_ADDR_VAR 0 3
6234: PUSH
6235: LD_VAR 0 3
6239: PUSH
6240: LD_VAR 0 4
6244: ADD
6245: ST_TO_ADDR
// for i = 1 to [ 4 , 3 , 2 ] [ game_difficulty ] do
6246: LD_ADDR_VAR 0 2
6250: PUSH
6251: DOUBLE
6252: LD_INT 1
6254: DEC
6255: ST_TO_ADDR
6256: LD_INT 4
6258: PUSH
6259: LD_INT 3
6261: PUSH
6262: LD_INT 2
6264: PUSH
6265: EMPTY
6266: LIST
6267: LIST
6268: LIST
6269: PUSH
6270: LD_EXP 2
6274: ARRAY
6275: PUSH
6276: FOR_TO
6277: IFFALSE 6315
// begin un := CreateHumanWithClass ( 1 , l_skill ) ;
6279: LD_ADDR_VAR 0 4
6283: PUSH
6284: LD_INT 1
6286: PPUSH
6287: LD_EXP 50
6291: PPUSH
6292: CALL 7190 0 2
6296: ST_TO_ADDR
// filter := filter ^ un ;
6297: LD_ADDR_VAR 0 3
6301: PUSH
6302: LD_VAR 0 3
6306: PUSH
6307: LD_VAR 0 4
6311: ADD
6312: ST_TO_ADDR
// end ;
6313: GO 6276
6315: POP
6316: POP
// DialogueOn ;
6317: CALL_OW 6
// SayRadio ( filter [ 1 ] , DS-DF-1 ) ;
6321: LD_VAR 0 3
6325: PUSH
6326: LD_INT 1
6328: ARRAY
6329: PPUSH
6330: LD_STRING DS-DF-1
6332: PPUSH
6333: CALL_OW 94
// case Query ( DS-dezert ) of 1 :
6337: LD_STRING DS-dezert
6339: PPUSH
6340: CALL_OW 97
6344: PUSH
6345: LD_INT 1
6347: DOUBLE
6348: EQUAL
6349: IFTRUE 6353
6351: GO 6368
6353: POP
// Say ( l_cmndr , DS-DC-dis ) ; 2 :
6354: LD_EXP 49
6358: PPUSH
6359: LD_STRING DS-DC-dis
6361: PPUSH
6362: CALL_OW 88
6366: GO 6463
6368: LD_INT 2
6370: DOUBLE
6371: EQUAL
6372: IFTRUE 6376
6374: GO 6462
6376: POP
// begin Say ( l_cmndr , DS-DC-acp ) ;
6377: LD_EXP 49
6381: PPUSH
6382: LD_STRING DS-DC-acp
6384: PPUSH
6385: CALL_OW 88
// for i = 1 to filter do
6389: LD_ADDR_VAR 0 2
6393: PUSH
6394: DOUBLE
6395: LD_INT 1
6397: DEC
6398: ST_TO_ADDR
6399: LD_VAR 0 3
6403: PUSH
6404: FOR_TO
6405: IFFALSE 6458
// begin SetSide ( filter [ i ] , 8 ) ;
6407: LD_VAR 0 3
6411: PUSH
6412: LD_VAR 0 2
6416: ARRAY
6417: PPUSH
6418: LD_INT 8
6420: PPUSH
6421: CALL_OW 235
// PlaceUnitArea ( filter [ i ] , south_spawn , false ) ;
6425: LD_VAR 0 3
6429: PUSH
6430: LD_VAR 0 2
6434: ARRAY
6435: PPUSH
6436: LD_INT 4
6438: PPUSH
6439: LD_INT 0
6441: PPUSH
6442: CALL_OW 49
// CenterNowOnXY ( 111 , 121 ) ;
6446: LD_INT 111
6448: PPUSH
6449: LD_INT 121
6451: PPUSH
6452: CALL_OW 86
// end ;
6456: GO 6404
6458: POP
6459: POP
// end ; end ;
6460: GO 6463
6462: POP
// DialogueOff ;
6463: CALL_OW 7
// end ; 101 :
6467: GO 6602
6469: LD_INT 101
6471: DOUBLE
6472: EQUAL
6473: IFTRUE 6477
6475: GO 6529
6477: POP
// begin CreateCratesArea ( Rand ( 3 , 5 ) , crates_area , true ) ;
6478: LD_INT 3
6480: PPUSH
6481: LD_INT 5
6483: PPUSH
6484: CALL_OW 12
6488: PPUSH
6489: LD_INT 9
6491: PPUSH
6492: LD_INT 1
6494: PPUSH
6495: CALL_OW 55
// Wait ( 0 0$11 ) ;
6499: LD_INT 385
6501: PPUSH
6502: CALL_OW 67
// CreateCratesArea ( Rand ( 3 , 5 ) , crates_area , true ) ;
6506: LD_INT 3
6508: PPUSH
6509: LD_INT 5
6511: PPUSH
6512: CALL_OW 12
6516: PPUSH
6517: LD_INT 9
6519: PPUSH
6520: LD_INT 1
6522: PPUSH
6523: CALL_OW 55
// end ; 200 :
6527: GO 6602
6529: LD_INT 200
6531: DOUBLE
6532: EQUAL
6533: IFTRUE 6537
6535: GO 6601
6537: POP
// begin Say ( Leopold , DS-end ) ;
6538: LD_EXP 7
6542: PPUSH
6543: LD_STRING DS-end
6545: PPUSH
6546: CALL_OW 88
// music_nat := 5 ;
6550: LD_ADDR_OWVAR 71
6554: PUSH
6555: LD_INT 5
6557: ST_TO_ADDR
// AddMedal ( dsmed1 , 1 ) ;
6558: LD_STRING dsmed1
6560: PPUSH
6561: LD_INT 1
6563: PPUSH
6564: CALL_OW 101
// AddMedal ( dsmed1 , 1 ) ;
6568: LD_STRING dsmed1
6570: PPUSH
6571: LD_INT 1
6573: PPUSH
6574: CALL_OW 101
// AddMedal ( dsmed1 , 1 ) ;
6578: LD_STRING dsmed1
6580: PPUSH
6581: LD_INT 1
6583: PPUSH
6584: CALL_OW 101
// GiveMedals ( MAIN ) ;
6588: LD_STRING MAIN
6590: PPUSH
6591: CALL_OW 102
// YouWin ;
6595: CALL_OW 103
// end ; end ;
6599: GO 6602
6601: POP
// end ;
6602: PPOPN 6
6604: END
// on UnitGoesToRed ( un ) do begin if un in FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] ] ) then
6605: LD_VAR 0 1
6609: PUSH
6610: LD_INT 22
6612: PUSH
6613: LD_INT 2
6615: PUSH
6616: EMPTY
6617: LIST
6618: LIST
6619: PUSH
6620: LD_INT 21
6622: PUSH
6623: LD_INT 2
6625: PUSH
6626: EMPTY
6627: LIST
6628: LIST
6629: PUSH
6630: EMPTY
6631: LIST
6632: LIST
6633: PPUSH
6634: CALL_OW 69
6638: IN
6639: IFFALSE 6764
// begin Wait ( Rand ( 0 0$03 , 0 0$06 ) ) ;
6641: LD_INT 105
6643: PPUSH
6644: LD_INT 210
6646: PPUSH
6647: CALL_OW 12
6651: PPUSH
6652: CALL_OW 67
// MineExplosion ( GetX ( un ) , GetY ( un ) , 3 ) ;
6656: LD_VAR 0 1
6660: PPUSH
6661: CALL_OW 250
6665: PPUSH
6666: LD_VAR 0 1
6670: PPUSH
6671: CALL_OW 251
6675: PPUSH
6676: LD_INT 3
6678: PPUSH
6679: CALL_OW 453
// MineExplosion ( GetX ( un ) , GetY ( un ) , 3 ) ;
6683: LD_VAR 0 1
6687: PPUSH
6688: CALL_OW 250
6692: PPUSH
6693: LD_VAR 0 1
6697: PPUSH
6698: CALL_OW 251
6702: PPUSH
6703: LD_INT 3
6705: PPUSH
6706: CALL_OW 453
// MineExplosion ( GetX ( un ) , GetY ( un ) , 3 ) ;
6710: LD_VAR 0 1
6714: PPUSH
6715: CALL_OW 250
6719: PPUSH
6720: LD_VAR 0 1
6724: PPUSH
6725: CALL_OW 251
6729: PPUSH
6730: LD_INT 3
6732: PPUSH
6733: CALL_OW 453
// MineExplosion ( GetX ( un ) , GetY ( un ) , 3 ) ;
6737: LD_VAR 0 1
6741: PPUSH
6742: CALL_OW 250
6746: PPUSH
6747: LD_VAR 0 1
6751: PPUSH
6752: CALL_OW 251
6756: PPUSH
6757: LD_INT 3
6759: PPUSH
6760: CALL_OW 453
// end ; end ;
6764: PPOPN 1
6766: END
// on UnitDestroyed ( un ) do begin if un = fort then
6767: LD_VAR 0 1
6771: PUSH
6772: LD_INT 23
6774: EQUAL
6775: IFFALSE 6785
// fort_destroyed := true ;
6777: LD_ADDR_EXP 32
6781: PUSH
6782: LD_INT 1
6784: ST_TO_ADDR
// if un = l_cmndr then
6785: LD_VAR 0 1
6789: PUSH
6790: LD_EXP 49
6794: EQUAL
6795: IFFALSE 6805
// hero_died := true ;
6797: LD_ADDR_EXP 33
6801: PUSH
6802: LD_INT 1
6804: ST_TO_ADDR
// end ;
6805: PPOPN 1
6807: END
// on UnitDestroyed_Extra ( un , killerSide , killerUnit ) do begin SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ;
6808: LD_VAR 0 1
6812: PPUSH
6813: LD_VAR 0 2
6817: PPUSH
6818: LD_VAR 0 3
6822: PPUSH
6823: CALL 8527 0 3
// end ;
6827: PPOPN 3
6829: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
6830: LD_VAR 0 1
6834: PPUSH
6835: CALL 8625 0 1
// end ; end_of_file
6839: PPOPN 1
6841: END
// export function RefreshTime ( time , bool ) ; begin
6842: LD_INT 0
6844: PPUSH
// if bool then
6845: LD_VAR 0 2
6849: IFFALSE 6867
// time := time + 0 0$01 else
6851: LD_ADDR_VAR 0 1
6855: PUSH
6856: LD_VAR 0 1
6860: PUSH
6861: LD_INT 35
6863: PLUS
6864: ST_TO_ADDR
6865: GO 6881
// time := time - 0 0$01 ;
6867: LD_ADDR_VAR 0 1
6871: PUSH
6872: LD_VAR 0 1
6876: PUSH
6877: LD_INT 35
6879: MINUS
6880: ST_TO_ADDR
// result := time ;
6881: LD_ADDR_VAR 0 3
6885: PUSH
6886: LD_VAR 0 1
6890: ST_TO_ADDR
// end ;
6891: LD_VAR 0 3
6895: RET
// export function MineExist ( side ) ; begin
6896: LD_INT 0
6898: PPUSH
// if FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_siberite_mine ] ] ) > 0 then
6899: LD_INT 22
6901: PUSH
6902: LD_VAR 0 1
6906: PUSH
6907: EMPTY
6908: LIST
6909: LIST
6910: PUSH
6911: LD_INT 30
6913: PUSH
6914: LD_INT 30
6916: PUSH
6917: EMPTY
6918: LIST
6919: LIST
6920: PUSH
6921: EMPTY
6922: LIST
6923: LIST
6924: PPUSH
6925: CALL_OW 69
6929: PUSH
6930: LD_INT 0
6932: GREATER
6933: IFFALSE 6945
// result := true else
6935: LD_ADDR_VAR 0 2
6939: PUSH
6940: LD_INT 1
6942: ST_TO_ADDR
6943: GO 6953
// result := false ;
6945: LD_ADDR_VAR 0 2
6949: PUSH
6950: LD_INT 0
6952: ST_TO_ADDR
// end ;
6953: LD_VAR 0 2
6957: RET
// export function FacExist ( side ) ; begin
6958: LD_INT 0
6960: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_factory ] ] ) > 0 ;
6961: LD_ADDR_VAR 0 2
6965: PUSH
6966: LD_INT 22
6968: PUSH
6969: LD_VAR 0 1
6973: PUSH
6974: EMPTY
6975: LIST
6976: LIST
6977: PUSH
6978: LD_INT 30
6980: PUSH
6981: LD_INT 3
6983: PUSH
6984: EMPTY
6985: LIST
6986: LIST
6987: PUSH
6988: EMPTY
6989: LIST
6990: LIST
6991: PPUSH
6992: CALL_OW 69
6996: PUSH
6997: LD_INT 0
6999: GREATER
7000: ST_TO_ADDR
// end ;
7001: LD_VAR 0 2
7005: RET
// export function ConnectWithTower ( side ) ; var i , filter , tower ; begin
7006: LD_INT 0
7008: PPUSH
7009: PPUSH
7010: PPUSH
7011: PPUSH
// filter := FilterAllUnits ( [ [ f_side , side ] , [ f_control , control_remote ] , [ f_ok ] ] ) ;
7012: LD_ADDR_VAR 0 4
7016: PUSH
7017: LD_INT 22
7019: PUSH
7020: LD_VAR 0 1
7024: PUSH
7025: EMPTY
7026: LIST
7027: LIST
7028: PUSH
7029: LD_INT 33
7031: PUSH
7032: LD_INT 2
7034: PUSH
7035: EMPTY
7036: LIST
7037: LIST
7038: PUSH
7039: LD_INT 50
7041: PUSH
7042: EMPTY
7043: LIST
7044: PUSH
7045: EMPTY
7046: LIST
7047: LIST
7048: LIST
7049: PPUSH
7050: CALL_OW 69
7054: ST_TO_ADDR
// tower := FilterAllUnits ( [ [ f_side , side ] , [ f_weapon , ar_control_tower ] ] ) ;
7055: LD_ADDR_VAR 0 5
7059: PUSH
7060: LD_INT 22
7062: PUSH
7063: LD_VAR 0 1
7067: PUSH
7068: EMPTY
7069: LIST
7070: LIST
7071: PUSH
7072: LD_INT 34
7074: PUSH
7075: LD_INT 31
7077: PUSH
7078: EMPTY
7079: LIST
7080: LIST
7081: PUSH
7082: EMPTY
7083: LIST
7084: LIST
7085: PPUSH
7086: CALL_OW 69
7090: ST_TO_ADDR
// if tower > 0 and filter > 0 then
7091: LD_VAR 0 5
7095: PUSH
7096: LD_INT 0
7098: GREATER
7099: PUSH
7100: LD_VAR 0 4
7104: PUSH
7105: LD_INT 0
7107: GREATER
7108: AND
7109: IFFALSE 7185
// for i = 1 to filter do
7111: LD_ADDR_VAR 0 3
7115: PUSH
7116: DOUBLE
7117: LD_INT 1
7119: DEC
7120: ST_TO_ADDR
7121: LD_VAR 0 4
7125: PUSH
7126: FOR_TO
7127: IFFALSE 7183
// if not IsControledBy ( filter [ i ] ) then
7129: LD_VAR 0 4
7133: PUSH
7134: LD_VAR 0 3
7138: ARRAY
7139: PPUSH
7140: CALL_OW 312
7144: NOT
7145: IFFALSE 7181
// ComLinkTo ( filter [ i ] , tower [ Rand ( 1 , tower ) ] ) ;
7147: LD_VAR 0 4
7151: PUSH
7152: LD_VAR 0 3
7156: ARRAY
7157: PPUSH
7158: LD_VAR 0 5
7162: PUSH
7163: LD_INT 1
7165: PPUSH
7166: LD_VAR 0 5
7170: PPUSH
7171: CALL_OW 12
7175: ARRAY
7176: PPUSH
7177: CALL_OW 135
7181: GO 7126
7183: POP
7184: POP
// end ;
7185: LD_VAR 0 2
7189: RET
// export function CreateHumanWithClass ( clas , lvl ) ; var skill_com , skill_eng , skill_mech , skill_sci , bonus ; begin
7190: LD_INT 0
7192: PPUSH
7193: PPUSH
7194: PPUSH
7195: PPUSH
7196: PPUSH
7197: PPUSH
// hc_class := clas ;
7198: LD_ADDR_OWVAR 28
7202: PUSH
7203: LD_VAR 0 1
7207: ST_TO_ADDR
// skill_com := ( lvl + Rand ( - 1 , 1 ) ) ;
7208: LD_ADDR_VAR 0 4
7212: PUSH
7213: LD_VAR 0 2
7217: PUSH
7218: LD_INT 1
7220: NEG
7221: PPUSH
7222: LD_INT 1
7224: PPUSH
7225: CALL_OW 12
7229: PLUS
7230: ST_TO_ADDR
// skill_eng := ( lvl + Rand ( - 1 , 1 ) ) ;
7231: LD_ADDR_VAR 0 5
7235: PUSH
7236: LD_VAR 0 2
7240: PUSH
7241: LD_INT 1
7243: NEG
7244: PPUSH
7245: LD_INT 1
7247: PPUSH
7248: CALL_OW 12
7252: PLUS
7253: ST_TO_ADDR
// skill_mech := ( lvl + Rand ( - 1 , 1 ) ) ;
7254: LD_ADDR_VAR 0 6
7258: PUSH
7259: LD_VAR 0 2
7263: PUSH
7264: LD_INT 1
7266: NEG
7267: PPUSH
7268: LD_INT 1
7270: PPUSH
7271: CALL_OW 12
7275: PLUS
7276: ST_TO_ADDR
// skill_sci := ( lvl + Rand ( - 1 , 1 ) ) ;
7277: LD_ADDR_VAR 0 7
7281: PUSH
7282: LD_VAR 0 2
7286: PUSH
7287: LD_INT 1
7289: NEG
7290: PPUSH
7291: LD_INT 1
7293: PPUSH
7294: CALL_OW 12
7298: PLUS
7299: ST_TO_ADDR
// if clas = 1 or clas = 9 or clas = class_sniper or clas = class_mortar then
7300: LD_VAR 0 1
7304: PUSH
7305: LD_INT 1
7307: EQUAL
7308: PUSH
7309: LD_VAR 0 1
7313: PUSH
7314: LD_INT 9
7316: EQUAL
7317: OR
7318: PUSH
7319: LD_VAR 0 1
7323: PUSH
7324: LD_INT 5
7326: EQUAL
7327: OR
7328: PUSH
7329: LD_VAR 0 1
7333: PUSH
7334: LD_INT 8
7336: EQUAL
7337: OR
7338: IFFALSE 7363
// bonus := [ 2 , 0 , 0 , 0 ] ;
7340: LD_ADDR_VAR 0 8
7344: PUSH
7345: LD_INT 2
7347: PUSH
7348: LD_INT 0
7350: PUSH
7351: LD_INT 0
7353: PUSH
7354: LD_INT 0
7356: PUSH
7357: EMPTY
7358: LIST
7359: LIST
7360: LIST
7361: LIST
7362: ST_TO_ADDR
// if clas = 2 then
7363: LD_VAR 0 1
7367: PUSH
7368: LD_INT 2
7370: EQUAL
7371: IFFALSE 7396
// bonus := [ 0 , 2 , 0 , 0 ] ;
7373: LD_ADDR_VAR 0 8
7377: PUSH
7378: LD_INT 0
7380: PUSH
7381: LD_INT 2
7383: PUSH
7384: LD_INT 0
7386: PUSH
7387: LD_INT 0
7389: PUSH
7390: EMPTY
7391: LIST
7392: LIST
7393: LIST
7394: LIST
7395: ST_TO_ADDR
// if clas = 3 then
7396: LD_VAR 0 1
7400: PUSH
7401: LD_INT 3
7403: EQUAL
7404: IFFALSE 7429
// bonus := [ 0 , 0 , 2 , 0 ] ;
7406: LD_ADDR_VAR 0 8
7410: PUSH
7411: LD_INT 0
7413: PUSH
7414: LD_INT 0
7416: PUSH
7417: LD_INT 2
7419: PUSH
7420: LD_INT 0
7422: PUSH
7423: EMPTY
7424: LIST
7425: LIST
7426: LIST
7427: LIST
7428: ST_TO_ADDR
// if clas = 4 then
7429: LD_VAR 0 1
7433: PUSH
7434: LD_INT 4
7436: EQUAL
7437: IFFALSE 7462
// bonus := [ 0 , 0 , 0 , 2 ] ;
7439: LD_ADDR_VAR 0 8
7443: PUSH
7444: LD_INT 0
7446: PUSH
7447: LD_INT 0
7449: PUSH
7450: LD_INT 0
7452: PUSH
7453: LD_INT 2
7455: PUSH
7456: EMPTY
7457: LIST
7458: LIST
7459: LIST
7460: LIST
7461: ST_TO_ADDR
// if clas > 4 and clas <> 9 and clas <> class_sniper and clas <> class_mortar then
7462: LD_VAR 0 1
7466: PUSH
7467: LD_INT 4
7469: GREATER
7470: PUSH
7471: LD_VAR 0 1
7475: PUSH
7476: LD_INT 9
7478: NONEQUAL
7479: AND
7480: PUSH
7481: LD_VAR 0 1
7485: PUSH
7486: LD_INT 5
7488: NONEQUAL
7489: AND
7490: PUSH
7491: LD_VAR 0 1
7495: PUSH
7496: LD_INT 8
7498: NONEQUAL
7499: AND
7500: IFFALSE 7525
// bonus := [ 0 , 0 , 0 , 0 ] ;
7502: LD_ADDR_VAR 0 8
7506: PUSH
7507: LD_INT 0
7509: PUSH
7510: LD_INT 0
7512: PUSH
7513: LD_INT 0
7515: PUSH
7516: LD_INT 0
7518: PUSH
7519: EMPTY
7520: LIST
7521: LIST
7522: LIST
7523: LIST
7524: ST_TO_ADDR
// hc_basic_skills := [ Rand ( 0 , 2 ) , Rand ( 0 , 2 ) , Rand ( 0 , 2 ) , Rand ( 0 , 2 ) ] ;
7525: LD_ADDR_OWVAR 30
7529: PUSH
7530: LD_INT 0
7532: PPUSH
7533: LD_INT 2
7535: PPUSH
7536: CALL_OW 12
7540: PUSH
7541: LD_INT 0
7543: PPUSH
7544: LD_INT 2
7546: PPUSH
7547: CALL_OW 12
7551: PUSH
7552: LD_INT 0
7554: PPUSH
7555: LD_INT 2
7557: PPUSH
7558: CALL_OW 12
7562: PUSH
7563: LD_INT 0
7565: PPUSH
7566: LD_INT 2
7568: PPUSH
7569: CALL_OW 12
7573: PUSH
7574: EMPTY
7575: LIST
7576: LIST
7577: LIST
7578: LIST
7579: ST_TO_ADDR
// hc_skills := [ skill_com + bonus [ 1 ] , skill_eng + bonus [ 2 ] , skill_mech + bonus [ 3 ] , skill_sci + bonus [ 4 ] ] ;
7580: LD_ADDR_OWVAR 31
7584: PUSH
7585: LD_VAR 0 4
7589: PUSH
7590: LD_VAR 0 8
7594: PUSH
7595: LD_INT 1
7597: ARRAY
7598: PLUS
7599: PUSH
7600: LD_VAR 0 5
7604: PUSH
7605: LD_VAR 0 8
7609: PUSH
7610: LD_INT 2
7612: ARRAY
7613: PLUS
7614: PUSH
7615: LD_VAR 0 6
7619: PUSH
7620: LD_VAR 0 8
7624: PUSH
7625: LD_INT 3
7627: ARRAY
7628: PLUS
7629: PUSH
7630: LD_VAR 0 7
7634: PUSH
7635: LD_VAR 0 8
7639: PUSH
7640: LD_INT 4
7642: ARRAY
7643: PLUS
7644: PUSH
7645: EMPTY
7646: LIST
7647: LIST
7648: LIST
7649: LIST
7650: ST_TO_ADDR
// hc_sex := Rand ( sex_male , sex_female ) ;
7651: LD_ADDR_OWVAR 27
7655: PUSH
7656: LD_INT 1
7658: PPUSH
7659: LD_INT 2
7661: PPUSH
7662: CALL_OW 12
7666: ST_TO_ADDR
// hc_gallery :=  ;
7667: LD_ADDR_OWVAR 33
7671: PUSH
7672: LD_STRING 
7674: ST_TO_ADDR
// hc_attr := [ Rand ( 8 , 12 ) , Rand ( 9 , 11 ) ] ;
7675: LD_ADDR_OWVAR 29
7679: PUSH
7680: LD_INT 8
7682: PPUSH
7683: LD_INT 12
7685: PPUSH
7686: CALL_OW 12
7690: PUSH
7691: LD_INT 9
7693: PPUSH
7694: LD_INT 11
7696: PPUSH
7697: CALL_OW 12
7701: PUSH
7702: EMPTY
7703: LIST
7704: LIST
7705: ST_TO_ADDR
// hc_name :=  ;
7706: LD_ADDR_OWVAR 26
7710: PUSH
7711: LD_STRING 
7713: ST_TO_ADDR
// result := CreateHuman ;
7714: LD_ADDR_VAR 0 3
7718: PUSH
7719: CALL_OW 44
7723: ST_TO_ADDR
// end ;
7724: LD_VAR 0 3
7728: RET
// export function GetSpeed ( unit ) ; begin
7729: LD_INT 0
7731: PPUSH
// result := GetProperties ( unit ) [ 1 ] ;
7732: LD_ADDR_VAR 0 2
7736: PUSH
7737: LD_VAR 0 1
7741: PPUSH
7742: CALL_OW 464
7746: PUSH
7747: LD_INT 1
7749: ARRAY
7750: ST_TO_ADDR
// end ;
7751: LD_VAR 0 2
7755: RET
// export function PrepareNature ( area , num1 , num2 , num3 , num4 ) ; var l , apeman , tiger , bird , horse ; begin
7756: LD_INT 0
7758: PPUSH
7759: PPUSH
7760: PPUSH
7761: PPUSH
7762: PPUSH
7763: PPUSH
// uc_nation = nation_nature ;
7764: LD_ADDR_OWVAR 21
7768: PUSH
7769: LD_INT 0
7771: ST_TO_ADDR
// uc_side = 0 ;
7772: LD_ADDR_OWVAR 20
7776: PUSH
7777: LD_INT 0
7779: ST_TO_ADDR
// l = 0 ;
7780: LD_ADDR_VAR 0 7
7784: PUSH
7785: LD_INT 0
7787: ST_TO_ADDR
// repeat begin uc_direction = Rand ( 0 , 5 ) ;
7788: LD_ADDR_OWVAR 24
7792: PUSH
7793: LD_INT 0
7795: PPUSH
7796: LD_INT 5
7798: PPUSH
7799: CALL_OW 12
7803: ST_TO_ADDR
// hc_agressivity = Rand ( - 5 , 0 ) ;
7804: LD_ADDR_OWVAR 35
7808: PUSH
7809: LD_INT 5
7811: NEG
7812: PPUSH
7813: LD_INT 0
7815: PPUSH
7816: CALL_OW 12
7820: ST_TO_ADDR
// hc_gallery =  ;
7821: LD_ADDR_OWVAR 33
7825: PUSH
7826: LD_STRING 
7828: ST_TO_ADDR
// hc_class = class_apeman ;
7829: LD_ADDR_OWVAR 28
7833: PUSH
7834: LD_INT 12
7836: ST_TO_ADDR
// hc_attr = [ Rand ( 11 , 13 ) , Rand ( 10 , 11 ) ] ;
7837: LD_ADDR_OWVAR 29
7841: PUSH
7842: LD_INT 11
7844: PPUSH
7845: LD_INT 13
7847: PPUSH
7848: CALL_OW 12
7852: PUSH
7853: LD_INT 10
7855: PPUSH
7856: LD_INT 11
7858: PPUSH
7859: CALL_OW 12
7863: PUSH
7864: EMPTY
7865: LIST
7866: LIST
7867: ST_TO_ADDR
// hc_sex = sex_male ;
7868: LD_ADDR_OWVAR 27
7872: PUSH
7873: LD_INT 1
7875: ST_TO_ADDR
// hc_skills = [ Rand ( 0 , 2 ) , 0 , 0 , 0 ] ;
7876: LD_ADDR_OWVAR 31
7880: PUSH
7881: LD_INT 0
7883: PPUSH
7884: LD_INT 2
7886: PPUSH
7887: CALL_OW 12
7891: PUSH
7892: LD_INT 0
7894: PUSH
7895: LD_INT 0
7897: PUSH
7898: LD_INT 0
7900: PUSH
7901: EMPTY
7902: LIST
7903: LIST
7904: LIST
7905: LIST
7906: ST_TO_ADDR
// apeman = CreateHuman ;
7907: LD_ADDR_VAR 0 8
7911: PUSH
7912: CALL_OW 44
7916: ST_TO_ADDR
// PlaceUnitArea ( apeman , area , false ) ;
7917: LD_VAR 0 8
7921: PPUSH
7922: LD_VAR 0 1
7926: PPUSH
7927: LD_INT 0
7929: PPUSH
7930: CALL_OW 49
// l = l + 1 ;
7934: LD_ADDR_VAR 0 7
7938: PUSH
7939: LD_VAR 0 7
7943: PUSH
7944: LD_INT 1
7946: PLUS
7947: ST_TO_ADDR
// end until l = num1 ;
7948: LD_VAR 0 7
7952: PUSH
7953: LD_VAR 0 2
7957: EQUAL
7958: IFFALSE 7788
// l = 0 ;
7960: LD_ADDR_VAR 0 7
7964: PUSH
7965: LD_INT 0
7967: ST_TO_ADDR
// repeat begin hc_agressivity = Rand ( 0 , 25 ) ;
7968: LD_ADDR_OWVAR 35
7972: PUSH
7973: LD_INT 0
7975: PPUSH
7976: LD_INT 25
7978: PPUSH
7979: CALL_OW 12
7983: ST_TO_ADDR
// hc_class = class_tiger ;
7984: LD_ADDR_OWVAR 28
7988: PUSH
7989: LD_INT 14
7991: ST_TO_ADDR
// hc_sex = sex_male ;
7992: LD_ADDR_OWVAR 27
7996: PUSH
7997: LD_INT 1
7999: ST_TO_ADDR
// hc_gallery = sandnature ;
8000: LD_ADDR_OWVAR 33
8004: PUSH
8005: LD_STRING sandnature
8007: ST_TO_ADDR
// hc_face_number = 3 ;
8008: LD_ADDR_OWVAR 34
8012: PUSH
8013: LD_INT 3
8015: ST_TO_ADDR
// tiger = CreateHuman ;
8016: LD_ADDR_VAR 0 9
8020: PUSH
8021: CALL_OW 44
8025: ST_TO_ADDR
// PlaceUnitArea ( tiger , area , false ) ;
8026: LD_VAR 0 9
8030: PPUSH
8031: LD_VAR 0 1
8035: PPUSH
8036: LD_INT 0
8038: PPUSH
8039: CALL_OW 49
// l = l + 1 ;
8043: LD_ADDR_VAR 0 7
8047: PUSH
8048: LD_VAR 0 7
8052: PUSH
8053: LD_INT 1
8055: PLUS
8056: ST_TO_ADDR
// end until l = num2 ;
8057: LD_VAR 0 7
8061: PUSH
8062: LD_VAR 0 3
8066: EQUAL
8067: IFFALSE 7968
// l = 0 ;
8069: LD_ADDR_VAR 0 7
8073: PUSH
8074: LD_INT 0
8076: ST_TO_ADDR
// repeat begin hc_class = class_phororhacos ;
8077: LD_ADDR_OWVAR 28
8081: PUSH
8082: LD_INT 18
8084: ST_TO_ADDR
// hc_gallery = sandnature ;
8085: LD_ADDR_OWVAR 33
8089: PUSH
8090: LD_STRING sandnature
8092: ST_TO_ADDR
// hc_face_number = 1 ;
8093: LD_ADDR_OWVAR 34
8097: PUSH
8098: LD_INT 1
8100: ST_TO_ADDR
// bird = CreateHuman ;
8101: LD_ADDR_VAR 0 10
8105: PUSH
8106: CALL_OW 44
8110: ST_TO_ADDR
// PlaceUnitAnywhere ( bird , false ) ;
8111: LD_VAR 0 10
8115: PPUSH
8116: LD_INT 0
8118: PPUSH
8119: CALL_OW 51
// l = l + 1 ;
8123: LD_ADDR_VAR 0 7
8127: PUSH
8128: LD_VAR 0 7
8132: PUSH
8133: LD_INT 1
8135: PLUS
8136: ST_TO_ADDR
// end until l = num3 ;
8137: LD_VAR 0 7
8141: PUSH
8142: LD_VAR 0 4
8146: EQUAL
8147: IFFALSE 8077
// l = 0 ;
8149: LD_ADDR_VAR 0 7
8153: PUSH
8154: LD_INT 0
8156: ST_TO_ADDR
// repeat begin hc_class = 21 ;
8157: LD_ADDR_OWVAR 28
8161: PUSH
8162: LD_INT 21
8164: ST_TO_ADDR
// hc_gallery = sandnature ;
8165: LD_ADDR_OWVAR 33
8169: PUSH
8170: LD_STRING sandnature
8172: ST_TO_ADDR
// hc_face_number = 5 ;
8173: LD_ADDR_OWVAR 34
8177: PUSH
8178: LD_INT 5
8180: ST_TO_ADDR
// horse := CreateHuman ;
8181: LD_ADDR_VAR 0 11
8185: PUSH
8186: CALL_OW 44
8190: ST_TO_ADDR
// PlaceUnitArea ( horse , area , false ) ;
8191: LD_VAR 0 11
8195: PPUSH
8196: LD_VAR 0 1
8200: PPUSH
8201: LD_INT 0
8203: PPUSH
8204: CALL_OW 49
// l = l + 1 ;
8208: LD_ADDR_VAR 0 7
8212: PUSH
8213: LD_VAR 0 7
8217: PUSH
8218: LD_INT 1
8220: PLUS
8221: ST_TO_ADDR
// end until l = num4 ;
8222: LD_VAR 0 7
8226: PUSH
8227: LD_VAR 0 5
8231: EQUAL
8232: IFFALSE 8157
// end ;
8234: LD_VAR 0 6
8238: RET
// export function PrepareComm ; begin
8239: LD_INT 0
8241: PPUSH
// uc_side := 1 ;
8242: LD_ADDR_OWVAR 20
8246: PUSH
8247: LD_INT 1
8249: ST_TO_ADDR
// uc_nation := 1 ;
8250: LD_ADDR_OWVAR 21
8254: PUSH
8255: LD_INT 1
8257: ST_TO_ADDR
// hc_gallery :=  ;
8258: LD_ADDR_OWVAR 33
8262: PUSH
8263: LD_STRING 
8265: ST_TO_ADDR
// hc_name :=  ;
8266: LD_ADDR_OWVAR 26
8270: PUSH
8271: LD_STRING 
8273: ST_TO_ADDR
// hc_class := 1 ;
8274: LD_ADDR_OWVAR 28
8278: PUSH
8279: LD_INT 1
8281: ST_TO_ADDR
// hc_sex := sex_male ;
8282: LD_ADDR_OWVAR 27
8286: PUSH
8287: LD_INT 1
8289: ST_TO_ADDR
// am_comander := CreateHuman ;
8290: LD_ADDR_EXP 46
8294: PUSH
8295: CALL_OW 44
8299: ST_TO_ADDR
// uc_side := 3 ;
8300: LD_ADDR_OWVAR 20
8304: PUSH
8305: LD_INT 3
8307: ST_TO_ADDR
// uc_nation := 3 ;
8308: LD_ADDR_OWVAR 21
8312: PUSH
8313: LD_INT 3
8315: ST_TO_ADDR
// ru_comander := CreateHuman ;
8316: LD_ADDR_EXP 47
8320: PUSH
8321: CALL_OW 44
8325: ST_TO_ADDR
// uc_side := 2 ;
8326: LD_ADDR_OWVAR 20
8330: PUSH
8331: LD_INT 2
8333: ST_TO_ADDR
// uc_nation := 2 ;
8334: LD_ADDR_OWVAR 21
8338: PUSH
8339: LD_INT 2
8341: ST_TO_ADDR
// hc_name := Heike Steyer ;
8342: LD_ADDR_OWVAR 26
8346: PUSH
8347: LD_STRING Heike Steyer
8349: ST_TO_ADDR
// hc_sex := sex_female ;
8350: LD_ADDR_OWVAR 27
8354: PUSH
8355: LD_INT 2
8357: ST_TO_ADDR
// hc_gallery := sandar ;
8358: LD_ADDR_OWVAR 33
8362: PUSH
8363: LD_STRING sandar
8365: ST_TO_ADDR
// hc_face_number := 14 ;
8366: LD_ADDR_OWVAR 34
8370: PUSH
8371: LD_INT 14
8373: ST_TO_ADDR
// ar_comander := CreateHuman ;
8374: LD_ADDR_EXP 48
8378: PUSH
8379: CALL_OW 44
8383: ST_TO_ADDR
// end ;
8384: LD_VAR 0 1
8388: RET
// export function SpeedFilter ( filter , speed ) ; var list , i ; begin
8389: LD_INT 0
8391: PPUSH
8392: PPUSH
8393: PPUSH
// list := [ ] ;
8394: LD_ADDR_VAR 0 4
8398: PUSH
8399: EMPTY
8400: ST_TO_ADDR
// for i = 1 to filter do
8401: LD_ADDR_VAR 0 5
8405: PUSH
8406: DOUBLE
8407: LD_INT 1
8409: DEC
8410: ST_TO_ADDR
8411: LD_VAR 0 1
8415: PUSH
8416: FOR_TO
8417: IFFALSE 8466
// if GetSpeed ( filter [ i ] ) < speed then
8419: LD_VAR 0 1
8423: PUSH
8424: LD_VAR 0 5
8428: ARRAY
8429: PPUSH
8430: CALL 7729 0 1
8434: PUSH
8435: LD_VAR 0 2
8439: LESS
8440: IFFALSE 8464
// list := list ^ filter [ i ] ;
8442: LD_ADDR_VAR 0 4
8446: PUSH
8447: LD_VAR 0 4
8451: PUSH
8452: LD_VAR 0 1
8456: PUSH
8457: LD_VAR 0 5
8461: ARRAY
8462: ADD
8463: ST_TO_ADDR
8464: GO 8416
8466: POP
8467: POP
// result := list ;
8468: LD_ADDR_VAR 0 3
8472: PUSH
8473: LD_VAR 0 4
8477: ST_TO_ADDR
// end ; end_of_file
8478: LD_VAR 0 3
8482: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; every 1 do
8483: GO 8485
8485: DISABLE
// begin ru_radar := 98 ;
8486: LD_ADDR_EXP 52
8490: PUSH
8491: LD_INT 98
8493: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
8494: LD_ADDR_EXP 53
8498: PUSH
8499: LD_INT 89
8501: ST_TO_ADDR
// us_hack := 99 ;
8502: LD_ADDR_EXP 54
8506: PUSH
8507: LD_INT 99
8509: ST_TO_ADDR
// us_artillery := 97 ;
8510: LD_ADDR_EXP 55
8514: PUSH
8515: LD_INT 97
8517: ST_TO_ADDR
// ar_bio_bomb := 91 ;
8518: LD_ADDR_EXP 56
8522: PUSH
8523: LD_INT 91
8525: ST_TO_ADDR
// end ; end_of_file end_of_file end_of_file
8526: END
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; var i , eff , side ; begin
8527: LD_INT 0
8529: PPUSH
8530: PPUSH
8531: PPUSH
8532: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
8533: LD_VAR 0 1
8537: PPUSH
8538: CALL_OW 264
8542: PUSH
8543: LD_EXP 56
8547: EQUAL
8548: IFFALSE 8620
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
8550: LD_INT 68
8552: PPUSH
8553: LD_VAR 0 1
8557: PPUSH
8558: CALL_OW 255
8562: PPUSH
8563: CALL_OW 321
8567: PUSH
8568: LD_INT 2
8570: EQUAL
8571: IFFALSE 8583
// eff := 70 else
8573: LD_ADDR_VAR 0 6
8577: PUSH
8578: LD_INT 70
8580: ST_TO_ADDR
8581: GO 8591
// eff := 30 ;
8583: LD_ADDR_VAR 0 6
8587: PUSH
8588: LD_INT 30
8590: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
8591: LD_VAR 0 1
8595: PPUSH
8596: CALL_OW 250
8600: PPUSH
8601: LD_VAR 0 1
8605: PPUSH
8606: CALL_OW 251
8610: PPUSH
8611: LD_VAR 0 6
8615: PPUSH
8616: CALL_OW 495
// end ; end ;
8620: LD_VAR 0 4
8624: RET
// export function SOS_Command ( cmd ) ; var i , j , tmp , taskList , _taskList ; begin
8625: LD_INT 0
8627: PPUSH
8628: PPUSH
8629: PPUSH
8630: PPUSH
8631: PPUSH
8632: PPUSH
// if cmd = 124 then
8633: LD_VAR 0 1
8637: PUSH
8638: LD_INT 124
8640: EQUAL
8641: IFFALSE 8847
// begin tmp := FilterAllUnits ( [ f_or , [ f_weapon , ru_bulldozer ] , [ f_weapon , us_bulldozer ] ] ) ;
8643: LD_ADDR_VAR 0 5
8647: PUSH
8648: LD_INT 2
8650: PUSH
8651: LD_INT 34
8653: PUSH
8654: LD_INT 53
8656: PUSH
8657: EMPTY
8658: LIST
8659: LIST
8660: PUSH
8661: LD_INT 34
8663: PUSH
8664: LD_INT 14
8666: PUSH
8667: EMPTY
8668: LIST
8669: LIST
8670: PUSH
8671: EMPTY
8672: LIST
8673: LIST
8674: LIST
8675: PPUSH
8676: CALL_OW 69
8680: ST_TO_ADDR
// if not tmp then
8681: LD_VAR 0 5
8685: NOT
8686: IFFALSE 8690
// exit ;
8688: GO 8847
// for i in tmp do
8690: LD_ADDR_VAR 0 3
8694: PUSH
8695: LD_VAR 0 5
8699: PUSH
8700: FOR_IN
8701: IFFALSE 8845
// begin taskList := GetTaskList ( i ) ;
8703: LD_ADDR_VAR 0 6
8707: PUSH
8708: LD_VAR 0 3
8712: PPUSH
8713: CALL_OW 437
8717: ST_TO_ADDR
// if not taskList then
8718: LD_VAR 0 6
8722: NOT
8723: IFFALSE 8727
// continue ;
8725: GO 8700
// for j = 1 to taskList do
8727: LD_ADDR_VAR 0 4
8731: PUSH
8732: DOUBLE
8733: LD_INT 1
8735: DEC
8736: ST_TO_ADDR
8737: LD_VAR 0 6
8741: PUSH
8742: FOR_TO
8743: IFFALSE 8841
// if taskList [ j ] [ 1 ] = | then
8745: LD_VAR 0 6
8749: PUSH
8750: LD_VAR 0 4
8754: ARRAY
8755: PUSH
8756: LD_INT 1
8758: ARRAY
8759: PUSH
8760: LD_STRING |
8762: EQUAL
8763: IFFALSE 8839
// begin _taskList := Delete ( taskList , 1 ) ;
8765: LD_ADDR_VAR 0 7
8769: PUSH
8770: LD_VAR 0 6
8774: PPUSH
8775: LD_INT 1
8777: PPUSH
8778: CALL_OW 3
8782: ST_TO_ADDR
// SetTaskList ( i , _taskList ) ;
8783: LD_VAR 0 3
8787: PPUSH
8788: LD_VAR 0 7
8792: PPUSH
8793: CALL_OW 446
// CutTreeXYR ( i , taskList [ j ] [ 2 ] , taskList [ j ] [ 3 ] , 8 ) ;
8797: LD_VAR 0 3
8801: PPUSH
8802: LD_VAR 0 6
8806: PUSH
8807: LD_VAR 0 4
8811: ARRAY
8812: PUSH
8813: LD_INT 2
8815: ARRAY
8816: PPUSH
8817: LD_VAR 0 6
8821: PUSH
8822: LD_VAR 0 4
8826: ARRAY
8827: PUSH
8828: LD_INT 3
8830: ARRAY
8831: PPUSH
8832: LD_INT 8
8834: PPUSH
8835: CALL 8852 0 4
// end ;
8839: GO 8742
8841: POP
8842: POP
// end ;
8843: GO 8700
8845: POP
8846: POP
// end ; end ;
8847: LD_VAR 0 2
8851: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
8852: LD_INT 0
8854: PPUSH
8855: PPUSH
8856: PPUSH
8857: PPUSH
8858: PPUSH
8859: PPUSH
8860: PPUSH
8861: PPUSH
8862: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
8863: LD_VAR 0 1
8867: NOT
8868: PUSH
8869: LD_VAR 0 2
8873: PPUSH
8874: LD_VAR 0 3
8878: PPUSH
8879: CALL_OW 488
8883: NOT
8884: OR
8885: PUSH
8886: LD_VAR 0 4
8890: NOT
8891: OR
8892: IFFALSE 8896
// exit ;
8894: GO 9236
// list := [ ] ;
8896: LD_ADDR_VAR 0 13
8900: PUSH
8901: EMPTY
8902: ST_TO_ADDR
// if x - r < 0 then
8903: LD_VAR 0 2
8907: PUSH
8908: LD_VAR 0 4
8912: MINUS
8913: PUSH
8914: LD_INT 0
8916: LESS
8917: IFFALSE 8929
// min_x := 0 else
8919: LD_ADDR_VAR 0 7
8923: PUSH
8924: LD_INT 0
8926: ST_TO_ADDR
8927: GO 8945
// min_x := x - r ;
8929: LD_ADDR_VAR 0 7
8933: PUSH
8934: LD_VAR 0 2
8938: PUSH
8939: LD_VAR 0 4
8943: MINUS
8944: ST_TO_ADDR
// if y - r < 0 then
8945: LD_VAR 0 3
8949: PUSH
8950: LD_VAR 0 4
8954: MINUS
8955: PUSH
8956: LD_INT 0
8958: LESS
8959: IFFALSE 8971
// min_y := 0 else
8961: LD_ADDR_VAR 0 8
8965: PUSH
8966: LD_INT 0
8968: ST_TO_ADDR
8969: GO 8987
// min_y := y - r ;
8971: LD_ADDR_VAR 0 8
8975: PUSH
8976: LD_VAR 0 3
8980: PUSH
8981: LD_VAR 0 4
8985: MINUS
8986: ST_TO_ADDR
// max_x := x + r ;
8987: LD_ADDR_VAR 0 9
8991: PUSH
8992: LD_VAR 0 2
8996: PUSH
8997: LD_VAR 0 4
9001: PLUS
9002: ST_TO_ADDR
// max_y := y + r ;
9003: LD_ADDR_VAR 0 10
9007: PUSH
9008: LD_VAR 0 3
9012: PUSH
9013: LD_VAR 0 4
9017: PLUS
9018: ST_TO_ADDR
// for _x = min_x to max_x do
9019: LD_ADDR_VAR 0 11
9023: PUSH
9024: DOUBLE
9025: LD_VAR 0 7
9029: DEC
9030: ST_TO_ADDR
9031: LD_VAR 0 9
9035: PUSH
9036: FOR_TO
9037: IFFALSE 9154
// for _y = min_y to max_y do
9039: LD_ADDR_VAR 0 12
9043: PUSH
9044: DOUBLE
9045: LD_VAR 0 8
9049: DEC
9050: ST_TO_ADDR
9051: LD_VAR 0 10
9055: PUSH
9056: FOR_TO
9057: IFFALSE 9150
// begin if not ValidHex ( _x , _y ) then
9059: LD_VAR 0 11
9063: PPUSH
9064: LD_VAR 0 12
9068: PPUSH
9069: CALL_OW 488
9073: NOT
9074: IFFALSE 9078
// continue ;
9076: GO 9056
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
9078: LD_VAR 0 11
9082: PPUSH
9083: LD_VAR 0 12
9087: PPUSH
9088: CALL_OW 351
9092: PUSH
9093: LD_VAR 0 11
9097: PPUSH
9098: LD_VAR 0 12
9102: PPUSH
9103: CALL_OW 554
9107: AND
9108: IFFALSE 9148
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
9110: LD_ADDR_VAR 0 13
9114: PUSH
9115: LD_VAR 0 13
9119: PPUSH
9120: LD_VAR 0 13
9124: PUSH
9125: LD_INT 1
9127: PLUS
9128: PPUSH
9129: LD_VAR 0 11
9133: PUSH
9134: LD_VAR 0 12
9138: PUSH
9139: EMPTY
9140: LIST
9141: LIST
9142: PPUSH
9143: CALL_OW 2
9147: ST_TO_ADDR
// end ;
9148: GO 9056
9150: POP
9151: POP
9152: GO 9036
9154: POP
9155: POP
// if not list then
9156: LD_VAR 0 13
9160: NOT
9161: IFFALSE 9165
// exit ;
9163: GO 9236
// for i in list do
9165: LD_ADDR_VAR 0 6
9169: PUSH
9170: LD_VAR 0 13
9174: PUSH
9175: FOR_IN
9176: IFFALSE 9234
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
9178: LD_VAR 0 1
9182: PPUSH
9183: LD_STRING M
9185: PUSH
9186: LD_VAR 0 6
9190: PUSH
9191: LD_INT 1
9193: ARRAY
9194: PUSH
9195: LD_VAR 0 6
9199: PUSH
9200: LD_INT 2
9202: ARRAY
9203: PUSH
9204: LD_INT 0
9206: PUSH
9207: LD_INT 0
9209: PUSH
9210: LD_INT 0
9212: PUSH
9213: LD_INT 0
9215: PUSH
9216: EMPTY
9217: LIST
9218: LIST
9219: LIST
9220: LIST
9221: LIST
9222: LIST
9223: LIST
9224: PUSH
9225: EMPTY
9226: LIST
9227: PPUSH
9228: CALL_OW 447
9232: GO 9175
9234: POP
9235: POP
// end ;
9236: LD_VAR 0 5
9240: RET
