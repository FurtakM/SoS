// starting begin PrepareMap ;
   0: CALL 13 0 0
// Main_Variables ;
   4: CALL 136 0 0
// Start_Mission ;
   8: CALL 3416 0 0
// end ;
  12: END
// function PrepareMap ; begin
  13: LD_INT 0
  15: PPUSH
// ResetFog ;
  16: CALL_OW 335
// RandomizeAll ;
  20: CALL_OW 11
// game_difficulty := GetMultiplayerSetting ( 0 ) ;
  24: LD_ADDR_EXP 2
  28: PUSH
  29: LD_INT 0
  31: PPUSH
  32: CALL_OW 426
  36: ST_TO_ADDR
// Difficulty := game_difficulty ;
  37: LD_ADDR_OWVAR 67
  41: PUSH
  42: LD_EXP 2
  46: ST_TO_ADDR
// ChangeSideFog ( 8 , 6 ) ;
  47: LD_INT 8
  49: PPUSH
  50: LD_INT 6
  52: PPUSH
  53: CALL_OW 343
// PlaceSeeing ( 1 , 1 , 8 , - 37963 ) ;
  57: LD_INT 1
  59: PPUSH
  60: LD_INT 1
  62: PPUSH
  63: LD_INT 8
  65: PPUSH
  66: LD_INT 37963
  68: NEG
  69: PPUSH
  70: CALL_OW 330
// RemoveSeeing ( 1 , 1 , 8 ) ;
  74: LD_INT 1
  76: PPUSH
  77: LD_INT 1
  79: PPUSH
  80: LD_INT 8
  82: PPUSH
  83: CALL_OW 331
// PlaceCamera ;
  87: CALL 3883 0 0
// PrepareNature ( nature , 4 , 3 , 2 , 1 ) ;
  91: LD_INT 2
  93: PPUSH
  94: LD_INT 4
  96: PPUSH
  97: LD_INT 3
  99: PPUSH
 100: LD_INT 2
 102: PPUSH
 103: LD_INT 1
 105: PPUSH
 106: CALL 7780 0 5
// PrepareComm ;
 110: CALL 8263 0 0
// SetSide ( fort , 6 ) ;
 114: LD_INT 23
 116: PPUSH
 117: LD_INT 6
 119: PPUSH
 120: CALL_OW 235
// CenterNowOnUnits ( fort ) ;
 124: LD_INT 23
 126: PPUSH
 127: CALL_OW 87
// end ;
 131: LD_VAR 0 1
 135: RET
// export game_on , game_difficulty , game_time , game_option , game_end , game_strings ; export leopold , leopold_in_fort , samuel , samuel_in_fort , mortars_in_fort , scout ; export u_mine , u_fac ; export areas ; export skill ; export ar_weapons , ru_weapons , us_weapons ; export arabian_force , russian_force , american_force , arabian_timeing , russian_timeing , american_timeing ; export meeting_start , meeting_arive , meeting_break , meeting_end , meeting_time , russian_timer , fort_destroyed , hero_died , mission_time , cargo_ok , american_hchan , dezert , arabian_attack , russian_attack , american_attack , american_help , american_sib_bomb , russian_trade , heike_dialog1 , heike_dialog2 ; export am_comander , ru_comander , ar_comander ; function Main_Variables ; begin
 136: LD_INT 0
 138: PPUSH
// game_on := false ;
 139: LD_ADDR_EXP 1
 143: PUSH
 144: LD_INT 0
 146: ST_TO_ADDR
// game_time := 0 0$00 ;
 147: LD_ADDR_EXP 3
 151: PUSH
 152: LD_INT 0
 154: ST_TO_ADDR
// game_option := [ 1 ] ;
 155: LD_ADDR_EXP 4
 159: PUSH
 160: LD_INT 1
 162: PUSH
 163: EMPTY
 164: LIST
 165: ST_TO_ADDR
// game_end := false ;
 166: LD_ADDR_EXP 5
 170: PUSH
 171: LD_INT 0
 173: ST_TO_ADDR
// game_strings := [ ] ;
 174: LD_ADDR_EXP 6
 178: PUSH
 179: EMPTY
 180: ST_TO_ADDR
// game_time := 0 0$00 ;
 181: LD_ADDR_EXP 3
 185: PUSH
 186: LD_INT 0
 188: ST_TO_ADDR
// mission_time := 0 0$00 ;
 189: LD_ADDR_EXP 34
 193: PUSH
 194: LD_INT 0
 196: ST_TO_ADDR
// skill := [ 5 , 7 , 9 ] [ game_difficulty ] ;
 197: LD_ADDR_EXP 16
 201: PUSH
 202: LD_INT 5
 204: PUSH
 205: LD_INT 7
 207: PUSH
 208: LD_INT 9
 210: PUSH
 211: EMPTY
 212: LIST
 213: LIST
 214: LIST
 215: PUSH
 216: LD_EXP 2
 220: ARRAY
 221: ST_TO_ADDR
// areas := [ a_swest , a_nwest , a_neast , a_seast ] ;
 222: LD_ADDR_EXP 15
 226: PUSH
 227: LD_INT 5
 229: PUSH
 230: LD_INT 6
 232: PUSH
 233: LD_INT 7
 235: PUSH
 236: LD_INT 8
 238: PUSH
 239: EMPTY
 240: LIST
 241: LIST
 242: LIST
 243: LIST
 244: ST_TO_ADDR
// meeting_start := false ;
 245: LD_ADDR_EXP 26
 249: PUSH
 250: LD_INT 0
 252: ST_TO_ADDR
// meeting_arive := false ;
 253: LD_ADDR_EXP 27
 257: PUSH
 258: LD_INT 0
 260: ST_TO_ADDR
// meeting_break := false ;
 261: LD_ADDR_EXP 28
 265: PUSH
 266: LD_INT 0
 268: ST_TO_ADDR
// meeting_end := false ;
 269: LD_ADDR_EXP 29
 273: PUSH
 274: LD_INT 0
 276: ST_TO_ADDR
// meeting_time := [ 4 4$00 , 3 3$40 , 3 3$20 ] [ game_difficulty ] ;
 277: LD_ADDR_EXP 30
 281: PUSH
 282: LD_INT 8400
 284: PUSH
 285: LD_INT 7700
 287: PUSH
 288: LD_INT 7000
 290: PUSH
 291: EMPTY
 292: LIST
 293: LIST
 294: LIST
 295: PUSH
 296: LD_EXP 2
 300: ARRAY
 301: ST_TO_ADDR
// arabian_force := [ 5 , 6 , 7 ] [ game_difficulty ] ;
 302: LD_ADDR_EXP 20
 306: PUSH
 307: LD_INT 5
 309: PUSH
 310: LD_INT 6
 312: PUSH
 313: LD_INT 7
 315: PUSH
 316: EMPTY
 317: LIST
 318: LIST
 319: LIST
 320: PUSH
 321: LD_EXP 2
 325: ARRAY
 326: ST_TO_ADDR
// american_force := [ 6 , 8 , 9 ] [ game_difficulty ] ;
 327: LD_ADDR_EXP 22
 331: PUSH
 332: LD_INT 6
 334: PUSH
 335: LD_INT 8
 337: PUSH
 338: LD_INT 9
 340: PUSH
 341: EMPTY
 342: LIST
 343: LIST
 344: LIST
 345: PUSH
 346: LD_EXP 2
 350: ARRAY
 351: ST_TO_ADDR
// russian_force := [ 7 , 9 , 10 ] [ game_difficulty ] ;
 352: LD_ADDR_EXP 21
 356: PUSH
 357: LD_INT 7
 359: PUSH
 360: LD_INT 9
 362: PUSH
 363: LD_INT 10
 365: PUSH
 366: EMPTY
 367: LIST
 368: LIST
 369: LIST
 370: PUSH
 371: LD_EXP 2
 375: ARRAY
 376: ST_TO_ADDR
// u_mine := false ;
 377: LD_ADDR_EXP 13
 381: PUSH
 382: LD_INT 0
 384: ST_TO_ADDR
// u_fac := false ;
 385: LD_ADDR_EXP 14
 389: PUSH
 390: LD_INT 0
 392: ST_TO_ADDR
// leopold_in_fort := false ;
 393: LD_ADDR_EXP 8
 397: PUSH
 398: LD_INT 0
 400: ST_TO_ADDR
// samuel_in_fort := false ;
 401: LD_ADDR_EXP 10
 405: PUSH
 406: LD_INT 0
 408: ST_TO_ADDR
// mortars_in_fort := false ;
 409: LD_ADDR_EXP 11
 413: PUSH
 414: LD_INT 0
 416: ST_TO_ADDR
// fort_destroyed := false ;
 417: LD_ADDR_EXP 32
 421: PUSH
 422: LD_INT 0
 424: ST_TO_ADDR
// hero_died := false ;
 425: LD_ADDR_EXP 33
 429: PUSH
 430: LD_INT 0
 432: ST_TO_ADDR
// dezert := false ;
 433: LD_ADDR_EXP 37
 437: PUSH
 438: LD_INT 0
 440: ST_TO_ADDR
// arabian_attack := false ;
 441: LD_ADDR_EXP 38
 445: PUSH
 446: LD_INT 0
 448: ST_TO_ADDR
// russian_attack := false ;
 449: LD_ADDR_EXP 39
 453: PUSH
 454: LD_INT 0
 456: ST_TO_ADDR
// american_attack := false ;
 457: LD_ADDR_EXP 40
 461: PUSH
 462: LD_INT 0
 464: ST_TO_ADDR
// american_help := false ;
 465: LD_ADDR_EXP 41
 469: PUSH
 470: LD_INT 0
 472: ST_TO_ADDR
// american_hchan := [ 91 , 81 , 71 ] [ game_difficulty ] ;
 473: LD_ADDR_EXP 36
 477: PUSH
 478: LD_INT 91
 480: PUSH
 481: LD_INT 81
 483: PUSH
 484: LD_INT 71
 486: PUSH
 487: EMPTY
 488: LIST
 489: LIST
 490: LIST
 491: PUSH
 492: LD_EXP 2
 496: ARRAY
 497: ST_TO_ADDR
// american_sib_bomb := false ;
 498: LD_ADDR_EXP 42
 502: PUSH
 503: LD_INT 0
 505: ST_TO_ADDR
// russian_trade := false ;
 506: LD_ADDR_EXP 43
 510: PUSH
 511: LD_INT 0
 513: ST_TO_ADDR
// russian_timer := 5 5$00 ;
 514: LD_ADDR_EXP 31
 518: PUSH
 519: LD_INT 10500
 521: ST_TO_ADDR
// cargo_ok := false ;
 522: LD_ADDR_EXP 35
 526: PUSH
 527: LD_INT 0
 529: ST_TO_ADDR
// heike_dialog1 := false ;
 530: LD_ADDR_EXP 44
 534: PUSH
 535: LD_INT 0
 537: ST_TO_ADDR
// heike_dialog2 := false ;
 538: LD_ADDR_EXP 45
 542: PUSH
 543: LD_INT 0
 545: ST_TO_ADDR
// american_timeing := [ 10 10$00 , 9 9$40 , 9 9$10 ] [ game_difficulty ] ;
 546: LD_ADDR_EXP 25
 550: PUSH
 551: LD_INT 21000
 553: PUSH
 554: LD_INT 20300
 556: PUSH
 557: LD_INT 19250
 559: PUSH
 560: EMPTY
 561: LIST
 562: LIST
 563: LIST
 564: PUSH
 565: LD_EXP 2
 569: ARRAY
 570: ST_TO_ADDR
// arabian_timeing := [ 8 8$00 , 7 7$10 , 6 6$20 ] [ game_difficulty ] ;
 571: LD_ADDR_EXP 23
 575: PUSH
 576: LD_INT 16800
 578: PUSH
 579: LD_INT 15050
 581: PUSH
 582: LD_INT 13300
 584: PUSH
 585: EMPTY
 586: LIST
 587: LIST
 588: LIST
 589: PUSH
 590: LD_EXP 2
 594: ARRAY
 595: ST_TO_ADDR
// russian_timeing := [ 11 11$00 , 10 10$30 , 9 9$20 ] [ game_difficulty ] ;
 596: LD_ADDR_EXP 24
 600: PUSH
 601: LD_INT 23100
 603: PUSH
 604: LD_INT 22050
 606: PUSH
 607: LD_INT 19600
 609: PUSH
 610: EMPTY
 611: LIST
 612: LIST
 613: LIST
 614: PUSH
 615: LD_EXP 2
 619: ARRAY
 620: ST_TO_ADDR
// ar_weapons := [ ar_rocket_launcher , ar_gun , ar_flame_thrower , ar_selfpropelled_bomb , ar_bio_bomb ] ;
 621: LD_ADDR_EXP 17
 625: PUSH
 626: LD_INT 28
 628: PUSH
 629: LD_INT 27
 631: PUSH
 632: LD_INT 26
 634: PUSH
 635: LD_INT 29
 637: PUSH
 638: LD_EXP 56
 642: PUSH
 643: EMPTY
 644: LIST
 645: LIST
 646: LIST
 647: LIST
 648: LIST
 649: ST_TO_ADDR
// us_weapons := [ us_rocket_launcher , us_heavy_gun , us_double_laser ] ;
 650: LD_ADDR_EXP 19
 654: PUSH
 655: LD_INT 7
 657: PUSH
 658: LD_INT 6
 660: PUSH
 661: LD_INT 10
 663: PUSH
 664: EMPTY
 665: LIST
 666: LIST
 667: LIST
 668: ST_TO_ADDR
// ru_weapons := [ ru_rocket_launcher , ru_rocket , ru_heavy_gun ] ;
 669: LD_ADDR_EXP 18
 673: PUSH
 674: LD_INT 45
 676: PUSH
 677: LD_INT 47
 679: PUSH
 680: LD_INT 46
 682: PUSH
 683: EMPTY
 684: LIST
 685: LIST
 686: LIST
 687: ST_TO_ADDR
// end ;
 688: LD_VAR 0 1
 692: RET
// every 0 0$01 trigger game_on do var i , p , x , filter ;
 693: LD_EXP 1
 697: IFFALSE 3413
 699: GO 701
 701: DISABLE
 702: LD_INT 0
 704: PPUSH
 705: PPUSH
 706: PPUSH
 707: PPUSH
// begin enable ;
 708: ENABLE
// Display_Strings := [ #tick , game_time ] ^ game_strings ;
 709: LD_ADDR_OWVAR 47
 713: PUSH
 714: LD_STRING #tick
 716: PUSH
 717: LD_EXP 3
 721: PUSH
 722: EMPTY
 723: LIST
 724: LIST
 725: PUSH
 726: LD_EXP 6
 730: ADD
 731: ST_TO_ADDR
// game_time := RefreshTime ( game_time , true ) ;
 732: LD_ADDR_EXP 3
 736: PUSH
 737: LD_EXP 3
 741: PPUSH
 742: LD_INT 1
 744: PPUSH
 745: CALL 6866 0 2
 749: ST_TO_ADDR
// if meeting_start and meeting_time > 0 0$00 then
 750: LD_EXP 26
 754: PUSH
 755: LD_EXP 30
 759: PUSH
 760: LD_INT 0
 762: GREATER
 763: AND
 764: IFFALSE 801
// begin game_strings := [ #mtime , meeting_time ] ;
 766: LD_ADDR_EXP 6
 770: PUSH
 771: LD_STRING #mtime
 773: PUSH
 774: LD_EXP 30
 778: PUSH
 779: EMPTY
 780: LIST
 781: LIST
 782: ST_TO_ADDR
// meeting_time := RefreshTime ( meeting_time , false ) ;
 783: LD_ADDR_EXP 30
 787: PUSH
 788: LD_EXP 30
 792: PPUSH
 793: LD_INT 0
 795: PPUSH
 796: CALL 6866 0 2
 800: ST_TO_ADDR
// end ; if meeting_arive then
 801: LD_EXP 27
 805: IFFALSE 825
// mission_time := RefreshTime ( mission_time , true ) ;
 807: LD_ADDR_EXP 34
 811: PUSH
 812: LD_EXP 34
 816: PPUSH
 817: LD_INT 1
 819: PPUSH
 820: CALL 6866 0 2
 824: ST_TO_ADDR
// if arabian_attack and arabian_timeing > 0 0$00 and meeting_arive then
 825: LD_EXP 38
 829: PUSH
 830: LD_EXP 23
 834: PUSH
 835: LD_INT 0
 837: GREATER
 838: AND
 839: PUSH
 840: LD_EXP 27
 844: AND
 845: IFFALSE 865
// begin arabian_timeing := RefreshTime ( arabian_timeing , false ) ;
 847: LD_ADDR_EXP 23
 851: PUSH
 852: LD_EXP 23
 856: PPUSH
 857: LD_INT 0
 859: PPUSH
 860: CALL 6866 0 2
 864: ST_TO_ADDR
// end ; if russian_attack and russian_timeing > 0 0$00 and meeting_arive then
 865: LD_EXP 39
 869: PUSH
 870: LD_EXP 24
 874: PUSH
 875: LD_INT 0
 877: GREATER
 878: AND
 879: PUSH
 880: LD_EXP 27
 884: AND
 885: IFFALSE 905
// begin russian_timeing := RefreshTime ( russian_timeing , false ) ;
 887: LD_ADDR_EXP 24
 891: PUSH
 892: LD_EXP 24
 896: PPUSH
 897: LD_INT 0
 899: PPUSH
 900: CALL 6866 0 2
 904: ST_TO_ADDR
// end ; if american_attack and american_timeing > 0 0$00 and meeting_arive then
 905: LD_EXP 40
 909: PUSH
 910: LD_EXP 25
 914: PUSH
 915: LD_INT 0
 917: GREATER
 918: AND
 919: PUSH
 920: LD_EXP 27
 924: AND
 925: IFFALSE 945
// begin american_timeing := RefreshTime ( american_timeing , false ) ;
 927: LD_ADDR_EXP 25
 931: PUSH
 932: LD_EXP 25
 936: PPUSH
 937: LD_INT 0
 939: PPUSH
 940: CALL 6866 0 2
 944: ST_TO_ADDR
// end ; if russian_trade and russian_timer > 0 0$00 then
 945: LD_EXP 43
 949: PUSH
 950: LD_EXP 31
 954: PUSH
 955: LD_INT 0
 957: GREATER
 958: AND
 959: IFFALSE 996
// begin game_strings := [ #rtime , russian_timer ] ;
 961: LD_ADDR_EXP 6
 965: PUSH
 966: LD_STRING #rtime
 968: PUSH
 969: LD_EXP 31
 973: PUSH
 974: EMPTY
 975: LIST
 976: LIST
 977: ST_TO_ADDR
// russian_timer := RefreshTime ( russian_timer , false ) ;
 978: LD_ADDR_EXP 31
 982: PUSH
 983: LD_EXP 31
 987: PPUSH
 988: LD_INT 0
 990: PPUSH
 991: CALL 6866 0 2
 995: ST_TO_ADDR
// end ; if russian_trade and russian_timer = 0 0$00 or cargo_ok then
 996: LD_EXP 43
1000: PUSH
1001: LD_EXP 31
1005: PUSH
1006: LD_INT 0
1008: EQUAL
1009: AND
1010: PUSH
1011: LD_EXP 35
1015: OR
1016: IFFALSE 1025
// game_strings := [ ] ;
1018: LD_ADDR_EXP 6
1022: PUSH
1023: EMPTY
1024: ST_TO_ADDR
// if dezert = false and tick mod 33600 = 0 then
1025: LD_EXP 37
1029: PUSH
1030: LD_INT 0
1032: EQUAL
1033: PUSH
1034: LD_OWVAR 1
1038: PUSH
1039: LD_INT 33600
1041: MOD
1042: PUSH
1043: LD_INT 0
1045: EQUAL
1046: AND
1047: IFFALSE 1107
// begin p := Rand ( 1 , 5 ) ;
1049: LD_ADDR_VAR 0 2
1053: PUSH
1054: LD_INT 1
1056: PPUSH
1057: LD_INT 5
1059: PPUSH
1060: CALL_OW 12
1064: ST_TO_ADDR
// if p <= [ 4 , 3 , 3 ] [ game_difficulty ] then
1065: LD_VAR 0 2
1069: PUSH
1070: LD_INT 4
1072: PUSH
1073: LD_INT 3
1075: PUSH
1076: LD_INT 3
1078: PUSH
1079: EMPTY
1080: LIST
1081: LIST
1082: LIST
1083: PUSH
1084: LD_EXP 2
1088: ARRAY
1089: LESSEQUAL
1090: IFFALSE 1107
// begin RaiseSailEvent ( 92 ) ;
1092: LD_INT 92
1094: PPUSH
1095: CALL_OW 427
// dezert := true ;
1099: LD_ADDR_EXP 37
1103: PUSH
1104: LD_INT 1
1106: ST_TO_ADDR
// end ; end ; if tick mod 8400 = 0 then
1107: LD_OWVAR 1
1111: PUSH
1112: LD_INT 8400
1114: MOD
1115: PUSH
1116: LD_INT 0
1118: EQUAL
1119: IFFALSE 1128
// RaiseSailEvent ( 101 ) ;
1121: LD_INT 101
1123: PPUSH
1124: CALL_OW 427
// if MineExist ( 8 ) and u_mine = false then
1128: LD_INT 8
1130: PPUSH
1131: CALL 6920 0 1
1135: PUSH
1136: LD_EXP 13
1140: PUSH
1141: LD_INT 0
1143: EQUAL
1144: AND
1145: IFFALSE 1162
// begin u_mine := true ;
1147: LD_ADDR_EXP 13
1151: PUSH
1152: LD_INT 1
1154: ST_TO_ADDR
// ChangeMissionObjectives ( DS-T1m ) ;
1155: LD_STRING DS-T1m
1157: PPUSH
1158: CALL_OW 337
// end ; if FacExist ( 8 ) and u_fac = false then
1162: LD_INT 8
1164: PPUSH
1165: CALL 6982 0 1
1169: PUSH
1170: LD_EXP 14
1174: PUSH
1175: LD_INT 0
1177: EQUAL
1178: AND
1179: IFFALSE 1196
// begin u_fac := true ;
1181: LD_ADDR_EXP 14
1185: PUSH
1186: LD_INT 1
1188: ST_TO_ADDR
// ChangeMissionObjectives ( DS-T1f ) ;
1189: LD_STRING DS-T1f
1191: PPUSH
1192: CALL_OW 337
// end ; if hero_died then
1196: LD_EXP 33
1200: IFFALSE 1209
// YouLost ( DS-h1 ) ;
1202: LD_STRING DS-h1
1204: PPUSH
1205: CALL_OW 104
// if fort_destroyed then
1209: LD_EXP 32
1213: IFFALSE 1222
// YouLost ( DS-h2 ) ;
1215: LD_STRING DS-h2
1217: PPUSH
1218: CALL_OW 104
// if GetDistUnits ( leopold , l_cmndr ) > 6 and meeting_start = false then
1222: LD_EXP 7
1226: PPUSH
1227: LD_EXP 49
1231: PPUSH
1232: CALL_OW 296
1236: PUSH
1237: LD_INT 6
1239: GREATER
1240: PUSH
1241: LD_EXP 26
1245: PUSH
1246: LD_INT 0
1248: EQUAL
1249: AND
1250: IFFALSE 1273
// begin if not HasTask ( leopold ) then
1252: LD_EXP 7
1256: PPUSH
1257: CALL_OW 314
1261: NOT
1262: IFFALSE 1271
// RaiseSailEvent ( 1 ) ;
1264: LD_INT 1
1266: PPUSH
1267: CALL_OW 427
// end else
1271: GO 1290
// if meeting_start = false then
1273: LD_EXP 26
1277: PUSH
1278: LD_INT 0
1280: EQUAL
1281: IFFALSE 1290
// begin RaiseSailEvent ( 2 ) ;
1283: LD_INT 2
1285: PPUSH
1286: CALL_OW 427
// end ; if game_time >= [ 50 50$00 , 62 62$30 , 75 75$00 ] [ game_difficulty ] and meeting_end = false then
1290: LD_EXP 3
1294: PUSH
1295: LD_INT 105000
1297: PUSH
1298: LD_INT 131250
1300: PUSH
1301: LD_INT 157500
1303: PUSH
1304: EMPTY
1305: LIST
1306: LIST
1307: LIST
1308: PUSH
1309: LD_EXP 2
1313: ARRAY
1314: GREATEREQUAL
1315: PUSH
1316: LD_EXP 29
1320: PUSH
1321: LD_INT 0
1323: EQUAL
1324: AND
1325: IFFALSE 1342
// begin meeting_end := true ;
1327: LD_ADDR_EXP 29
1331: PUSH
1332: LD_INT 1
1334: ST_TO_ADDR
// RaiseSailEvent ( 200 ) ;
1335: LD_INT 200
1337: PPUSH
1338: CALL_OW 427
// end ; if meeting_time = 0 0$00 and meeting_arive = false then
1342: LD_EXP 30
1346: PUSH
1347: LD_INT 0
1349: EQUAL
1350: PUSH
1351: LD_EXP 27
1355: PUSH
1356: LD_INT 0
1358: EQUAL
1359: AND
1360: IFFALSE 1384
// begin meeting_arive := true ;
1362: LD_ADDR_EXP 27
1366: PUSH
1367: LD_INT 1
1369: ST_TO_ADDR
// game_strings := [ ] ;
1370: LD_ADDR_EXP 6
1374: PUSH
1375: EMPTY
1376: ST_TO_ADDR
// RaiseSailEvent ( 10 ) ;
1377: LD_INT 10
1379: PPUSH
1380: CALL_OW 427
// end ; if meeting_arive then
1384: LD_EXP 27
1388: IFFALSE 2133
// begin if arabian_attack = false and tick mod 4200 = 0 then
1390: LD_EXP 38
1394: PUSH
1395: LD_INT 0
1397: EQUAL
1398: PUSH
1399: LD_OWVAR 1
1403: PUSH
1404: LD_INT 4200
1406: MOD
1407: PUSH
1408: LD_INT 0
1410: EQUAL
1411: AND
1412: IFFALSE 1465
// begin p := Rand ( 1 , 100 ) ;
1414: LD_ADDR_VAR 0 2
1418: PUSH
1419: LD_INT 1
1421: PPUSH
1422: LD_INT 100
1424: PPUSH
1425: CALL_OW 12
1429: ST_TO_ADDR
// if p <= [ 80 , 85 , 90 ] [ game_difficulty ] then
1430: LD_VAR 0 2
1434: PUSH
1435: LD_INT 80
1437: PUSH
1438: LD_INT 85
1440: PUSH
1441: LD_INT 90
1443: PUSH
1444: EMPTY
1445: LIST
1446: LIST
1447: LIST
1448: PUSH
1449: LD_EXP 2
1453: ARRAY
1454: LESSEQUAL
1455: IFFALSE 1465
// arabian_attack := true ;
1457: LD_ADDR_EXP 38
1461: PUSH
1462: LD_INT 1
1464: ST_TO_ADDR
// end ; if russian_trade = false and russian_attack = false and tick > 52500 then
1465: LD_EXP 43
1469: PUSH
1470: LD_INT 0
1472: EQUAL
1473: PUSH
1474: LD_EXP 39
1478: PUSH
1479: LD_INT 0
1481: EQUAL
1482: AND
1483: PUSH
1484: LD_OWVAR 1
1488: PUSH
1489: LD_INT 52500
1491: GREATER
1492: AND
1493: IFFALSE 1564
// begin russian_trade = true ;
1495: LD_ADDR_EXP 43
1499: PUSH
1500: LD_INT 1
1502: ST_TO_ADDR
// DialogueOn ;
1503: CALL_OW 6
// SayRadio ( ru_comander , DS-DR-RTr ) ;
1507: LD_EXP 47
1511: PPUSH
1512: LD_STRING DS-DR-RTr
1514: PPUSH
1515: CALL_OW 94
// Say ( l_cmndr , DS-DC-RTr ) ;
1519: LD_EXP 49
1523: PPUSH
1524: LD_STRING DS-DC-RTr
1526: PPUSH
1527: CALL_OW 88
// SayRadio ( ru_comander , DS-DR-RTr2 ) ;
1531: LD_EXP 47
1535: PPUSH
1536: LD_STRING DS-DR-RTr2
1538: PPUSH
1539: CALL_OW 94
// DialogueOff ;
1543: CALL_OW 7
// ChangeMissionObjectives ( DS-T2 ) ;
1547: LD_STRING DS-T2
1549: PPUSH
1550: CALL_OW 337
// SetAreaMapShow ( tree , 1 ) ;
1554: LD_INT 10
1556: PPUSH
1557: LD_INT 1
1559: PPUSH
1560: CALL_OW 424
// end ; if russian_trade and cargo_ok = false and russian_timer > 0 0$00 then
1564: LD_EXP 43
1568: PUSH
1569: LD_EXP 35
1573: PUSH
1574: LD_INT 0
1576: EQUAL
1577: AND
1578: PUSH
1579: LD_EXP 31
1583: PUSH
1584: LD_INT 0
1586: GREATER
1587: AND
1588: IFFALSE 1783
// begin if FilterUnitsInArea ( tree , ( [ [ f_empty ] , [ f_weapon , ar_cargo_bay ] , [ f_not , [ f_control , control_remote ] ] ] ) ) > 0 then
1590: LD_INT 10
1592: PPUSH
1593: LD_INT 58
1595: PUSH
1596: EMPTY
1597: LIST
1598: PUSH
1599: LD_INT 34
1601: PUSH
1602: LD_INT 32
1604: PUSH
1605: EMPTY
1606: LIST
1607: LIST
1608: PUSH
1609: LD_INT 3
1611: PUSH
1612: LD_INT 33
1614: PUSH
1615: LD_INT 2
1617: PUSH
1618: EMPTY
1619: LIST
1620: LIST
1621: PUSH
1622: EMPTY
1623: LIST
1624: LIST
1625: PUSH
1626: EMPTY
1627: LIST
1628: LIST
1629: LIST
1630: PPUSH
1631: CALL_OW 70
1635: PUSH
1636: LD_INT 0
1638: GREATER
1639: IFFALSE 1783
// if GetCargo ( FilterUnitsInArea ( tree , ( [ [ f_empty ] , [ f_weapon , ar_cargo_bay ] , [ f_not , [ f_control , control_remote ] ] ] ) ) [ 1 ] , mat_siberit ) = 100 then
1641: LD_INT 10
1643: PPUSH
1644: LD_INT 58
1646: PUSH
1647: EMPTY
1648: LIST
1649: PUSH
1650: LD_INT 34
1652: PUSH
1653: LD_INT 32
1655: PUSH
1656: EMPTY
1657: LIST
1658: LIST
1659: PUSH
1660: LD_INT 3
1662: PUSH
1663: LD_INT 33
1665: PUSH
1666: LD_INT 2
1668: PUSH
1669: EMPTY
1670: LIST
1671: LIST
1672: PUSH
1673: EMPTY
1674: LIST
1675: LIST
1676: PUSH
1677: EMPTY
1678: LIST
1679: LIST
1680: LIST
1681: PPUSH
1682: CALL_OW 70
1686: PUSH
1687: LD_INT 1
1689: ARRAY
1690: PPUSH
1691: LD_INT 3
1693: PPUSH
1694: CALL_OW 289
1698: PUSH
1699: LD_INT 100
1701: EQUAL
1702: IFFALSE 1783
// begin cargo_ok := true ;
1704: LD_ADDR_EXP 35
1708: PUSH
1709: LD_INT 1
1711: ST_TO_ADDR
// RemoveUnit ( FilterUnitsInArea ( tree , ( [ [ f_empty ] , [ f_weapon , ar_cargo_bay ] , [ f_not , [ f_control , control_remote ] ] ] ) ) [ 1 ] ) ;
1712: LD_INT 10
1714: PPUSH
1715: LD_INT 58
1717: PUSH
1718: EMPTY
1719: LIST
1720: PUSH
1721: LD_INT 34
1723: PUSH
1724: LD_INT 32
1726: PUSH
1727: EMPTY
1728: LIST
1729: LIST
1730: PUSH
1731: LD_INT 3
1733: PUSH
1734: LD_INT 33
1736: PUSH
1737: LD_INT 2
1739: PUSH
1740: EMPTY
1741: LIST
1742: LIST
1743: PUSH
1744: EMPTY
1745: LIST
1746: LIST
1747: PUSH
1748: EMPTY
1749: LIST
1750: LIST
1751: LIST
1752: PPUSH
1753: CALL_OW 70
1757: PUSH
1758: LD_INT 1
1760: ARRAY
1761: PPUSH
1762: CALL_OW 64
// ChangeMissionObjectives ( DS-T2-out ) ;
1766: LD_STRING DS-T2-out
1768: PPUSH
1769: CALL_OW 337
// SetAreaMapShow ( tree , 0 ) ;
1773: LD_INT 10
1775: PPUSH
1776: LD_INT 0
1778: PPUSH
1779: CALL_OW 424
// end ; end ; if russian_attack = false and russian_trade and cargo_ok = false and russian_timer = 0 0$00 then
1783: LD_EXP 39
1787: PUSH
1788: LD_INT 0
1790: EQUAL
1791: PUSH
1792: LD_EXP 43
1796: AND
1797: PUSH
1798: LD_EXP 35
1802: PUSH
1803: LD_INT 0
1805: EQUAL
1806: AND
1807: PUSH
1808: LD_EXP 31
1812: PUSH
1813: LD_INT 0
1815: EQUAL
1816: AND
1817: IFFALSE 1844
// begin russian_attack := true ;
1819: LD_ADDR_EXP 39
1823: PUSH
1824: LD_INT 1
1826: ST_TO_ADDR
// ChangeMissionObjectives ( DS-T2-out ) ;
1827: LD_STRING DS-T2-out
1829: PPUSH
1830: CALL_OW 337
// SetAreaMapShow ( tree , 0 ) ;
1834: LD_INT 10
1836: PPUSH
1837: LD_INT 0
1839: PPUSH
1840: CALL_OW 424
// end ; if russian_trade = false and russian_attack = false and american_attack = false and tick mod 21000 = 0 then
1844: LD_EXP 43
1848: PUSH
1849: LD_INT 0
1851: EQUAL
1852: PUSH
1853: LD_EXP 39
1857: PUSH
1858: LD_INT 0
1860: EQUAL
1861: AND
1862: PUSH
1863: LD_EXP 40
1867: PUSH
1868: LD_INT 0
1870: EQUAL
1871: AND
1872: PUSH
1873: LD_OWVAR 1
1877: PUSH
1878: LD_INT 21000
1880: MOD
1881: PUSH
1882: LD_INT 0
1884: EQUAL
1885: AND
1886: IFFALSE 1939
// begin p := Rand ( 1 , 100 ) ;
1888: LD_ADDR_VAR 0 2
1892: PUSH
1893: LD_INT 1
1895: PPUSH
1896: LD_INT 100
1898: PPUSH
1899: CALL_OW 12
1903: ST_TO_ADDR
// if p <= [ 25 , 35 , 45 ] [ game_difficulty ] then
1904: LD_VAR 0 2
1908: PUSH
1909: LD_INT 25
1911: PUSH
1912: LD_INT 35
1914: PUSH
1915: LD_INT 45
1917: PUSH
1918: EMPTY
1919: LIST
1920: LIST
1921: LIST
1922: PUSH
1923: LD_EXP 2
1927: ARRAY
1928: LESSEQUAL
1929: IFFALSE 1939
// russian_attack := true ;
1931: LD_ADDR_EXP 39
1935: PUSH
1936: LD_INT 1
1938: ST_TO_ADDR
// end ; if american_help = false and american_attack = false and russian_attack = false and tick mod 31500 = 0 then
1939: LD_EXP 41
1943: PUSH
1944: LD_INT 0
1946: EQUAL
1947: PUSH
1948: LD_EXP 40
1952: PUSH
1953: LD_INT 0
1955: EQUAL
1956: AND
1957: PUSH
1958: LD_EXP 39
1962: PUSH
1963: LD_INT 0
1965: EQUAL
1966: AND
1967: PUSH
1968: LD_OWVAR 1
1972: PUSH
1973: LD_INT 31500
1975: MOD
1976: PUSH
1977: LD_INT 0
1979: EQUAL
1980: AND
1981: IFFALSE 2034
// begin p := Rand ( 1 , 100 ) ;
1983: LD_ADDR_VAR 0 2
1987: PUSH
1988: LD_INT 1
1990: PPUSH
1991: LD_INT 100
1993: PPUSH
1994: CALL_OW 12
1998: ST_TO_ADDR
// if p <= [ 22 , 33 , 44 ] [ game_difficulty ] then
1999: LD_VAR 0 2
2003: PUSH
2004: LD_INT 22
2006: PUSH
2007: LD_INT 33
2009: PUSH
2010: LD_INT 44
2012: PUSH
2013: EMPTY
2014: LIST
2015: LIST
2016: LIST
2017: PUSH
2018: LD_EXP 2
2022: ARRAY
2023: LESSEQUAL
2024: IFFALSE 2034
// american_attack := true ;
2026: LD_ADDR_EXP 40
2030: PUSH
2031: LD_INT 1
2033: ST_TO_ADDR
// end ; if american_attack = false and russian_attack = false and american_help = false and tick mod 21200 = 0 then
2034: LD_EXP 40
2038: PUSH
2039: LD_INT 0
2041: EQUAL
2042: PUSH
2043: LD_EXP 39
2047: PUSH
2048: LD_INT 0
2050: EQUAL
2051: AND
2052: PUSH
2053: LD_EXP 41
2057: PUSH
2058: LD_INT 0
2060: EQUAL
2061: AND
2062: PUSH
2063: LD_OWVAR 1
2067: PUSH
2068: LD_INT 21200
2070: MOD
2071: PUSH
2072: LD_INT 0
2074: EQUAL
2075: AND
2076: IFFALSE 2133
// begin p := Rand ( 1 , 100 ) ;
2078: LD_ADDR_VAR 0 2
2082: PUSH
2083: LD_INT 1
2085: PPUSH
2086: LD_INT 100
2088: PPUSH
2089: CALL_OW 12
2093: ST_TO_ADDR
// if p <= american_hchan then
2094: LD_VAR 0 2
2098: PUSH
2099: LD_EXP 36
2103: LESSEQUAL
2104: IFFALSE 2133
// begin american_help := true ;
2106: LD_ADDR_EXP 41
2110: PUSH
2111: LD_INT 1
2113: ST_TO_ADDR
// SayRadio ( am_comander , DS-amhelp ) ;
2114: LD_EXP 46
2118: PPUSH
2119: LD_STRING DS-amhelp
2121: PPUSH
2122: CALL_OW 94
// RaiseSailEvent ( 91 ) ;
2126: LD_INT 91
2128: PPUSH
2129: CALL_OW 427
// end ; end ; end ; if american_attack and american_timeing = 0 0$00 and FilterAllUnits ( [ f_side , 1 ] ) = 0 then
2133: LD_EXP 40
2137: PUSH
2138: LD_EXP 25
2142: PUSH
2143: LD_INT 0
2145: EQUAL
2146: AND
2147: PUSH
2148: LD_INT 22
2150: PUSH
2151: LD_INT 1
2153: PUSH
2154: EMPTY
2155: LIST
2156: LIST
2157: PPUSH
2158: CALL_OW 69
2162: PUSH
2163: LD_INT 0
2165: EQUAL
2166: AND
2167: IFFALSE 2269
// begin american_timeing := Rand ( 17 17$00 , 20 20$00 ) ;
2169: LD_ADDR_EXP 25
2173: PUSH
2174: LD_INT 35700
2176: PPUSH
2177: LD_INT 42000
2179: PPUSH
2180: CALL_OW 12
2184: ST_TO_ADDR
// SayRadio ( scout , DS-DZ-U ) ;
2185: LD_EXP 12
2189: PPUSH
2190: LD_STRING DS-DZ-U
2192: PPUSH
2193: CALL_OW 94
// Wait ( 0 0$33 ) ;
2197: LD_INT 1155
2199: PPUSH
2200: CALL_OW 67
// x := Rand ( 1 , 2 ) ;
2204: LD_ADDR_VAR 0 3
2208: PUSH
2209: LD_INT 1
2211: PPUSH
2212: LD_INT 2
2214: PPUSH
2215: CALL_OW 12
2219: ST_TO_ADDR
// case x of 1 :
2220: LD_VAR 0 3
2224: PUSH
2225: LD_INT 1
2227: DOUBLE
2228: EQUAL
2229: IFTRUE 2233
2231: GO 2243
2233: POP
// RaiseSailEvent ( 41 ) ; 2 :
2234: LD_INT 41
2236: PPUSH
2237: CALL_OW 427
2241: GO 2262
2243: LD_INT 2
2245: DOUBLE
2246: EQUAL
2247: IFTRUE 2251
2249: GO 2261
2251: POP
// RaiseSailEvent ( 42 ) ; end ;
2252: LD_INT 42
2254: PPUSH
2255: CALL_OW 427
2259: GO 2262
2261: POP
// RaiseSailEvent ( 42 ) ;
2262: LD_INT 42
2264: PPUSH
2265: CALL_OW 427
// end ; if russian_attack and russian_timeing = 0 0$00 and FilterAllUnits ( [ f_side , 3 ] ) = 0 then
2269: LD_EXP 39
2273: PUSH
2274: LD_EXP 24
2278: PUSH
2279: LD_INT 0
2281: EQUAL
2282: AND
2283: PUSH
2284: LD_INT 22
2286: PUSH
2287: LD_INT 3
2289: PUSH
2290: EMPTY
2291: LIST
2292: LIST
2293: PPUSH
2294: CALL_OW 69
2298: PUSH
2299: LD_INT 0
2301: EQUAL
2302: AND
2303: IFFALSE 2359
// begin russian_timeing := Rand ( 17 17$00 , 20 20$00 ) ;
2305: LD_ADDR_EXP 24
2309: PUSH
2310: LD_INT 35700
2312: PPUSH
2313: LD_INT 42000
2315: PPUSH
2316: CALL_OW 12
2320: ST_TO_ADDR
// SayRadio ( scout , DS-DZ-R ) ;
2321: LD_EXP 12
2325: PPUSH
2326: LD_STRING DS-DZ-R
2328: PPUSH
2329: CALL_OW 94
// Wait ( 0 0$45 ) ;
2333: LD_INT 1575
2335: PPUSH
2336: CALL_OW 67
// SayRadio ( ru_comander , DS-DR-R1 ) ;
2340: LD_EXP 47
2344: PPUSH
2345: LD_STRING DS-DR-R1
2347: PPUSH
2348: CALL_OW 94
// RaiseSailEvent ( 51 ) ;
2352: LD_INT 51
2354: PPUSH
2355: CALL_OW 427
// end ; if mission_time >= 10 10$00 and arabian_force < 10 then
2359: LD_EXP 34
2363: PUSH
2364: LD_INT 21000
2366: GREATEREQUAL
2367: PUSH
2368: LD_EXP 20
2372: PUSH
2373: LD_INT 10
2375: LESS
2376: AND
2377: IFFALSE 2401
// begin mission_time := 0 0$00 ;
2379: LD_ADDR_EXP 34
2383: PUSH
2384: LD_INT 0
2386: ST_TO_ADDR
// arabian_force := arabian_force + 1 ;
2387: LD_ADDR_EXP 20
2391: PUSH
2392: LD_EXP 20
2396: PUSH
2397: LD_INT 1
2399: PLUS
2400: ST_TO_ADDR
// end ; if arabian_timeing = 0 0$00 and FilterAllUnits ( [ [ f_side , 2 ] , [ f_not , [ f_weapon , ar_control_tower ] ] ] ) = 0 then
2401: LD_EXP 23
2405: PUSH
2406: LD_INT 0
2408: EQUAL
2409: PUSH
2410: LD_INT 22
2412: PUSH
2413: LD_INT 2
2415: PUSH
2416: EMPTY
2417: LIST
2418: LIST
2419: PUSH
2420: LD_INT 3
2422: PUSH
2423: LD_INT 34
2425: PUSH
2426: LD_INT 31
2428: PUSH
2429: EMPTY
2430: LIST
2431: LIST
2432: PUSH
2433: EMPTY
2434: LIST
2435: LIST
2436: PUSH
2437: EMPTY
2438: LIST
2439: LIST
2440: PPUSH
2441: CALL_OW 69
2445: PUSH
2446: LD_INT 0
2448: EQUAL
2449: AND
2450: IFFALSE 2648
// begin arabian_timeing := 7 7$30 ;
2452: LD_ADDR_EXP 23
2456: PUSH
2457: LD_INT 15750
2459: ST_TO_ADDR
// x := Rand ( 1 , 3 ) ;
2460: LD_ADDR_VAR 0 3
2464: PUSH
2465: LD_INT 1
2467: PPUSH
2468: LD_INT 3
2470: PPUSH
2471: CALL_OW 12
2475: ST_TO_ADDR
// SayRadio ( scout , DS-DZ-H ) ;
2476: LD_EXP 12
2480: PPUSH
2481: LD_STRING DS-DZ-H
2483: PPUSH
2484: CALL_OW 94
// case x of 1 :
2488: LD_VAR 0 3
2492: PUSH
2493: LD_INT 1
2495: DOUBLE
2496: EQUAL
2497: IFTRUE 2501
2499: GO 2511
2501: POP
// RaiseSailEvent ( 31 ) ; 2 :
2502: LD_INT 31
2504: PPUSH
2505: CALL_OW 427
2509: GO 2548
2511: LD_INT 2
2513: DOUBLE
2514: EQUAL
2515: IFTRUE 2519
2517: GO 2529
2519: POP
// RaiseSailEvent ( 32 ) ; 3 :
2520: LD_INT 32
2522: PPUSH
2523: CALL_OW 427
2527: GO 2548
2529: LD_INT 3
2531: DOUBLE
2532: EQUAL
2533: IFTRUE 2537
2535: GO 2547
2537: POP
// RaiseSailEvent ( 33 ) ; end ;
2538: LD_INT 33
2540: PPUSH
2541: CALL_OW 427
2545: GO 2548
2547: POP
// RaiseSailEvent ( 33 ) ;
2548: LD_INT 33
2550: PPUSH
2551: CALL_OW 427
// if game_difficulty > 1 then
2555: LD_EXP 2
2559: PUSH
2560: LD_INT 1
2562: GREATER
2563: IFFALSE 2572
// RaiseSailEvent ( 33 ) ;
2565: LD_INT 33
2567: PPUSH
2568: CALL_OW 427
// if heike_dialog1 = false then
2572: LD_EXP 44
2576: PUSH
2577: LD_INT 0
2579: EQUAL
2580: IFFALSE 2611
// begin heike_dialog1 := true ;
2582: LD_ADDR_EXP 44
2586: PUSH
2587: LD_INT 1
2589: ST_TO_ADDR
// Wait ( 0 0$03 ) ;
2590: LD_INT 105
2592: PPUSH
2593: CALL_OW 67
// SayRadio ( ar_comander , heike1 ) ;
2597: LD_EXP 48
2601: PPUSH
2602: LD_STRING heike1
2604: PPUSH
2605: CALL_OW 94
// end else
2609: GO 2648
// if heike_dialog2 = false then
2611: LD_EXP 45
2615: PUSH
2616: LD_INT 0
2618: EQUAL
2619: IFFALSE 2648
// begin heike_dialog2 := true ;
2621: LD_ADDR_EXP 45
2625: PUSH
2626: LD_INT 1
2628: ST_TO_ADDR
// Wait ( 0 0$03 ) ;
2629: LD_INT 105
2631: PPUSH
2632: CALL_OW 67
// SayRadio ( ar_comander , heike2 ) ;
2636: LD_EXP 48
2640: PPUSH
2641: LD_STRING heike2
2643: PPUSH
2644: CALL_OW 94
// end ; end ; if FilterAllUnits ( [ [ f_side , 2 ] , [ f_control , control_remote ] ] ) > 0 then
2648: LD_INT 22
2650: PUSH
2651: LD_INT 2
2653: PUSH
2654: EMPTY
2655: LIST
2656: LIST
2657: PUSH
2658: LD_INT 33
2660: PUSH
2661: LD_INT 2
2663: PUSH
2664: EMPTY
2665: LIST
2666: LIST
2667: PUSH
2668: EMPTY
2669: LIST
2670: LIST
2671: PPUSH
2672: CALL_OW 69
2676: PUSH
2677: LD_INT 0
2679: GREATER
2680: IFFALSE 2689
// ConnectWithTower ( 2 ) ;
2682: LD_INT 2
2684: PPUSH
2685: CALL 7030 0 1
// if FilterAllUnits ( [ [ [ f_side , 2 ] , [ f_not , [ f_weapon , ar_control_tower ] ] , [ f_not , [ f_hastask ] ] ] ] ) > 0 then
2689: LD_INT 22
2691: PUSH
2692: LD_INT 2
2694: PUSH
2695: EMPTY
2696: LIST
2697: LIST
2698: PUSH
2699: LD_INT 3
2701: PUSH
2702: LD_INT 34
2704: PUSH
2705: LD_INT 31
2707: PUSH
2708: EMPTY
2709: LIST
2710: LIST
2711: PUSH
2712: EMPTY
2713: LIST
2714: LIST
2715: PUSH
2716: LD_INT 3
2718: PUSH
2719: LD_INT 60
2721: PUSH
2722: EMPTY
2723: LIST
2724: PUSH
2725: EMPTY
2726: LIST
2727: LIST
2728: PUSH
2729: EMPTY
2730: LIST
2731: LIST
2732: LIST
2733: PUSH
2734: EMPTY
2735: LIST
2736: PPUSH
2737: CALL_OW 69
2741: PUSH
2742: LD_INT 0
2744: GREATER
2745: IFFALSE 2891
// begin filter := FilterAllUnits ( [ [ [ f_side , 2 ] , [ f_not , [ f_weapon , ar_control_tower ] ] , [ f_not , [ f_hastask ] ] ] ] ) ;
2747: LD_ADDR_VAR 0 4
2751: PUSH
2752: LD_INT 22
2754: PUSH
2755: LD_INT 2
2757: PUSH
2758: EMPTY
2759: LIST
2760: LIST
2761: PUSH
2762: LD_INT 3
2764: PUSH
2765: LD_INT 34
2767: PUSH
2768: LD_INT 31
2770: PUSH
2771: EMPTY
2772: LIST
2773: LIST
2774: PUSH
2775: EMPTY
2776: LIST
2777: LIST
2778: PUSH
2779: LD_INT 3
2781: PUSH
2782: LD_INT 60
2784: PUSH
2785: EMPTY
2786: LIST
2787: PUSH
2788: EMPTY
2789: LIST
2790: LIST
2791: PUSH
2792: EMPTY
2793: LIST
2794: LIST
2795: LIST
2796: PUSH
2797: EMPTY
2798: LIST
2799: PPUSH
2800: CALL_OW 69
2804: ST_TO_ADDR
// x := SpeedFilter ( FilterAllUnits ( [ f_enemy , 2 ] ) , 20 ) ;
2805: LD_ADDR_VAR 0 3
2809: PUSH
2810: LD_INT 81
2812: PUSH
2813: LD_INT 2
2815: PUSH
2816: EMPTY
2817: LIST
2818: LIST
2819: PPUSH
2820: CALL_OW 69
2824: PPUSH
2825: LD_INT 20
2827: PPUSH
2828: CALL 8413 0 2
2832: ST_TO_ADDR
// for i = 1 to filter do
2833: LD_ADDR_VAR 0 1
2837: PUSH
2838: DOUBLE
2839: LD_INT 1
2841: DEC
2842: ST_TO_ADDR
2843: LD_VAR 0 4
2847: PUSH
2848: FOR_TO
2849: IFFALSE 2889
// ComAttackUnit ( filter [ i ] , NearestUnitToUnit ( x , filter [ i ] ) ) ;
2851: LD_VAR 0 4
2855: PUSH
2856: LD_VAR 0 1
2860: ARRAY
2861: PPUSH
2862: LD_VAR 0 3
2866: PPUSH
2867: LD_VAR 0 4
2871: PUSH
2872: LD_VAR 0 1
2876: ARRAY
2877: PPUSH
2878: CALL_OW 74
2882: PPUSH
2883: CALL_OW 115
2887: GO 2848
2889: POP
2890: POP
// end ; if FilterAllUnits ( [ [ [ f_side , 3 ] , [ f_not , [ f_hastask ] ] ] ] ) > 0 then
2891: LD_INT 22
2893: PUSH
2894: LD_INT 3
2896: PUSH
2897: EMPTY
2898: LIST
2899: LIST
2900: PUSH
2901: LD_INT 3
2903: PUSH
2904: LD_INT 60
2906: PUSH
2907: EMPTY
2908: LIST
2909: PUSH
2910: EMPTY
2911: LIST
2912: LIST
2913: PUSH
2914: EMPTY
2915: LIST
2916: LIST
2917: PUSH
2918: EMPTY
2919: LIST
2920: PPUSH
2921: CALL_OW 69
2925: PUSH
2926: LD_INT 0
2928: GREATER
2929: IFFALSE 3075
// begin filter := FilterAllUnits ( [ [ [ f_side , 3 ] , [ f_not , [ f_weapon , ar_control_tower ] ] , [ f_not , [ f_hastask ] ] ] ] ) ;
2931: LD_ADDR_VAR 0 4
2935: PUSH
2936: LD_INT 22
2938: PUSH
2939: LD_INT 3
2941: PUSH
2942: EMPTY
2943: LIST
2944: LIST
2945: PUSH
2946: LD_INT 3
2948: PUSH
2949: LD_INT 34
2951: PUSH
2952: LD_INT 31
2954: PUSH
2955: EMPTY
2956: LIST
2957: LIST
2958: PUSH
2959: EMPTY
2960: LIST
2961: LIST
2962: PUSH
2963: LD_INT 3
2965: PUSH
2966: LD_INT 60
2968: PUSH
2969: EMPTY
2970: LIST
2971: PUSH
2972: EMPTY
2973: LIST
2974: LIST
2975: PUSH
2976: EMPTY
2977: LIST
2978: LIST
2979: LIST
2980: PUSH
2981: EMPTY
2982: LIST
2983: PPUSH
2984: CALL_OW 69
2988: ST_TO_ADDR
// x := SpeedFilter ( FilterAllUnits ( [ f_enemy , 3 ] ) , 20 ) ;
2989: LD_ADDR_VAR 0 3
2993: PUSH
2994: LD_INT 81
2996: PUSH
2997: LD_INT 3
2999: PUSH
3000: EMPTY
3001: LIST
3002: LIST
3003: PPUSH
3004: CALL_OW 69
3008: PPUSH
3009: LD_INT 20
3011: PPUSH
3012: CALL 8413 0 2
3016: ST_TO_ADDR
// for i = 1 to filter do
3017: LD_ADDR_VAR 0 1
3021: PUSH
3022: DOUBLE
3023: LD_INT 1
3025: DEC
3026: ST_TO_ADDR
3027: LD_VAR 0 4
3031: PUSH
3032: FOR_TO
3033: IFFALSE 3073
// ComAttackUnit ( filter [ i ] , NearestUnitToUnit ( x , filter [ i ] ) ) ;
3035: LD_VAR 0 4
3039: PUSH
3040: LD_VAR 0 1
3044: ARRAY
3045: PPUSH
3046: LD_VAR 0 3
3050: PPUSH
3051: LD_VAR 0 4
3055: PUSH
3056: LD_VAR 0 1
3060: ARRAY
3061: PPUSH
3062: CALL_OW 74
3066: PPUSH
3067: CALL_OW 115
3071: GO 3032
3073: POP
3074: POP
// end ; if FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_not , [ f_hastask ] ] ] ] ) > 0 then
3075: LD_INT 22
3077: PUSH
3078: LD_INT 1
3080: PUSH
3081: EMPTY
3082: LIST
3083: LIST
3084: PUSH
3085: LD_INT 3
3087: PUSH
3088: LD_INT 60
3090: PUSH
3091: EMPTY
3092: LIST
3093: PUSH
3094: EMPTY
3095: LIST
3096: LIST
3097: PUSH
3098: EMPTY
3099: LIST
3100: LIST
3101: PUSH
3102: EMPTY
3103: LIST
3104: PPUSH
3105: CALL_OW 69
3109: PUSH
3110: LD_INT 0
3112: GREATER
3113: IFFALSE 3259
// begin filter := FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_not , [ f_weapon , ar_control_tower ] ] , [ f_not , [ f_hastask ] ] ] ] ) ;
3115: LD_ADDR_VAR 0 4
3119: PUSH
3120: LD_INT 22
3122: PUSH
3123: LD_INT 1
3125: PUSH
3126: EMPTY
3127: LIST
3128: LIST
3129: PUSH
3130: LD_INT 3
3132: PUSH
3133: LD_INT 34
3135: PUSH
3136: LD_INT 31
3138: PUSH
3139: EMPTY
3140: LIST
3141: LIST
3142: PUSH
3143: EMPTY
3144: LIST
3145: LIST
3146: PUSH
3147: LD_INT 3
3149: PUSH
3150: LD_INT 60
3152: PUSH
3153: EMPTY
3154: LIST
3155: PUSH
3156: EMPTY
3157: LIST
3158: LIST
3159: PUSH
3160: EMPTY
3161: LIST
3162: LIST
3163: LIST
3164: PUSH
3165: EMPTY
3166: LIST
3167: PPUSH
3168: CALL_OW 69
3172: ST_TO_ADDR
// x := SpeedFilter ( FilterAllUnits ( [ f_enemy , 1 ] ) , 20 ) ;
3173: LD_ADDR_VAR 0 3
3177: PUSH
3178: LD_INT 81
3180: PUSH
3181: LD_INT 1
3183: PUSH
3184: EMPTY
3185: LIST
3186: LIST
3187: PPUSH
3188: CALL_OW 69
3192: PPUSH
3193: LD_INT 20
3195: PPUSH
3196: CALL 8413 0 2
3200: ST_TO_ADDR
// for i = 1 to filter do
3201: LD_ADDR_VAR 0 1
3205: PUSH
3206: DOUBLE
3207: LD_INT 1
3209: DEC
3210: ST_TO_ADDR
3211: LD_VAR 0 4
3215: PUSH
3216: FOR_TO
3217: IFFALSE 3257
// ComAttackUnit ( filter [ i ] , NearestUnitToUnit ( x , filter [ i ] ) ) ;
3219: LD_VAR 0 4
3223: PUSH
3224: LD_VAR 0 1
3228: ARRAY
3229: PPUSH
3230: LD_VAR 0 3
3234: PPUSH
3235: LD_VAR 0 4
3239: PUSH
3240: LD_VAR 0 1
3244: ARRAY
3245: PPUSH
3246: CALL_OW 74
3250: PPUSH
3251: CALL_OW 115
3255: GO 3216
3257: POP
3258: POP
// end ; if FilterAllUnits ( [ [ [ f_side , 2 ] , [ f_weapon , ar_bio_bomb ] , [ f_not , [ f_lives , 700 ] ] ] ] ) > 0 then
3259: LD_INT 22
3261: PUSH
3262: LD_INT 2
3264: PUSH
3265: EMPTY
3266: LIST
3267: LIST
3268: PUSH
3269: LD_INT 34
3271: PUSH
3272: LD_EXP 56
3276: PUSH
3277: EMPTY
3278: LIST
3279: LIST
3280: PUSH
3281: LD_INT 3
3283: PUSH
3284: LD_INT 24
3286: PUSH
3287: LD_INT 700
3289: PUSH
3290: EMPTY
3291: LIST
3292: LIST
3293: PUSH
3294: EMPTY
3295: LIST
3296: LIST
3297: PUSH
3298: EMPTY
3299: LIST
3300: LIST
3301: LIST
3302: PUSH
3303: EMPTY
3304: LIST
3305: PPUSH
3306: CALL_OW 69
3310: PUSH
3311: LD_INT 0
3313: GREATER
3314: IFFALSE 3413
// begin filter := FilterAllUnits ( [ [ [ f_side , 2 ] , [ f_weapon , ar_bio_bomb ] , [ f_not , [ f_lives , 700 ] ] ] ] ) ;
3316: LD_ADDR_VAR 0 4
3320: PUSH
3321: LD_INT 22
3323: PUSH
3324: LD_INT 2
3326: PUSH
3327: EMPTY
3328: LIST
3329: LIST
3330: PUSH
3331: LD_INT 34
3333: PUSH
3334: LD_EXP 56
3338: PUSH
3339: EMPTY
3340: LIST
3341: LIST
3342: PUSH
3343: LD_INT 3
3345: PUSH
3346: LD_INT 24
3348: PUSH
3349: LD_INT 700
3351: PUSH
3352: EMPTY
3353: LIST
3354: LIST
3355: PUSH
3356: EMPTY
3357: LIST
3358: LIST
3359: PUSH
3360: EMPTY
3361: LIST
3362: LIST
3363: LIST
3364: PUSH
3365: EMPTY
3366: LIST
3367: PPUSH
3368: CALL_OW 69
3372: ST_TO_ADDR
// for i = 1 to filter do
3373: LD_ADDR_VAR 0 1
3377: PUSH
3378: DOUBLE
3379: LD_INT 1
3381: DEC
3382: ST_TO_ADDR
3383: LD_VAR 0 4
3387: PUSH
3388: FOR_TO
3389: IFFALSE 3411
// SetLives ( filter [ i ] , 1 ) ;
3391: LD_VAR 0 4
3395: PUSH
3396: LD_VAR 0 1
3400: ARRAY
3401: PPUSH
3402: LD_INT 1
3404: PPUSH
3405: CALL_OW 234
3409: GO 3388
3411: POP
3412: POP
// end ; end ; end_of_file
3413: PPOPN 4
3415: END
// export function Start_Mission ; begin
3416: LD_INT 0
3418: PPUSH
// PrepareLegion ;
3419: CALL 3460 0 0
// PrepareMeeting ;
3423: CALL 4077 0 0
// case Query ( DS-text-beg ) of 1 :
3427: LD_STRING DS-text-beg
3429: PPUSH
3430: CALL_OW 97
3434: PUSH
3435: LD_INT 1
3437: DOUBLE
3438: EQUAL
3439: IFTRUE 3443
3441: GO 3446
3443: POP
// ; end ;
3444: GO 3447
3446: POP
// game_on := true ;
3447: LD_ADDR_EXP 1
3451: PUSH
3452: LD_INT 1
3454: ST_TO_ADDR
// end ;
3455: LD_VAR 0 1
3459: RET
// export l_cmndr , l_skill , l_units ; function PrepareLegion ; var i , p , filter , team ; begin
3460: LD_INT 0
3462: PPUSH
3463: PPUSH
3464: PPUSH
3465: PPUSH
3466: PPUSH
// uc_side := 8 ;
3467: LD_ADDR_OWVAR 20
3471: PUSH
3472: LD_INT 8
3474: ST_TO_ADDR
// uc_nation := 2 ;
3475: LD_ADDR_OWVAR 21
3479: PUSH
3480: LD_INT 2
3482: ST_TO_ADDR
// l_skill := [ 7 , 6 , 5 ] [ difficulty ] ;
3483: LD_ADDR_EXP 50
3487: PUSH
3488: LD_INT 7
3490: PUSH
3491: LD_INT 6
3493: PUSH
3494: LD_INT 5
3496: PUSH
3497: EMPTY
3498: LIST
3499: LIST
3500: LIST
3501: PUSH
3502: LD_OWVAR 67
3506: ARRAY
3507: ST_TO_ADDR
// l_units := [ 8 , 7 , 6 ] [ difficulty ] ;
3508: LD_ADDR_EXP 51
3512: PUSH
3513: LD_INT 8
3515: PUSH
3516: LD_INT 7
3518: PUSH
3519: LD_INT 6
3521: PUSH
3522: EMPTY
3523: LIST
3524: LIST
3525: LIST
3526: PUSH
3527: LD_OWVAR 67
3531: ARRAY
3532: ST_TO_ADDR
// filter := [ ] ;
3533: LD_ADDR_VAR 0 4
3537: PUSH
3538: EMPTY
3539: ST_TO_ADDR
// hc_gallery := desert ;
3540: LD_ADDR_OWVAR 33
3544: PUSH
3545: LD_STRING desert
3547: ST_TO_ADDR
// hc_face_number := 1 ;
3548: LD_ADDR_OWVAR 34
3552: PUSH
3553: LD_INT 1
3555: ST_TO_ADDR
// hc_skills := [ l_skill + 2 , l_skill - 1 , l_skill , l_skill + 1 ] ;
3556: LD_ADDR_OWVAR 31
3560: PUSH
3561: LD_EXP 50
3565: PUSH
3566: LD_INT 2
3568: PLUS
3569: PUSH
3570: LD_EXP 50
3574: PUSH
3575: LD_INT 1
3577: MINUS
3578: PUSH
3579: LD_EXP 50
3583: PUSH
3584: LD_EXP 50
3588: PUSH
3589: LD_INT 1
3591: PLUS
3592: PUSH
3593: EMPTY
3594: LIST
3595: LIST
3596: LIST
3597: LIST
3598: ST_TO_ADDR
// hc_sex := sex_male ;
3599: LD_ADDR_OWVAR 27
3603: PUSH
3604: LD_INT 1
3606: ST_TO_ADDR
// hc_name := Henri Ruotz ;
3607: LD_ADDR_OWVAR 26
3611: PUSH
3612: LD_STRING Henri Ruotz
3614: ST_TO_ADDR
// hc_attr := [ 10 , 10 ] ;
3615: LD_ADDR_OWVAR 29
3619: PUSH
3620: LD_INT 10
3622: PUSH
3623: LD_INT 10
3625: PUSH
3626: EMPTY
3627: LIST
3628: LIST
3629: ST_TO_ADDR
// hc_class := 1 ;
3630: LD_ADDR_OWVAR 28
3634: PUSH
3635: LD_INT 1
3637: ST_TO_ADDR
// hc_importance := 100 ;
3638: LD_ADDR_OWVAR 32
3642: PUSH
3643: LD_INT 100
3645: ST_TO_ADDR
// l_cmndr := CreateHuman ;
3646: LD_ADDR_EXP 49
3650: PUSH
3651: CALL_OW 44
3655: ST_TO_ADDR
// hc_importance := 0 ;
3656: LD_ADDR_OWVAR 32
3660: PUSH
3661: LD_INT 0
3663: ST_TO_ADDR
// scout := PrepareHuman ( sex_male , 1 , 0 ) ;
3664: LD_ADDR_EXP 12
3668: PUSH
3669: LD_INT 1
3671: PPUSH
3672: LD_INT 1
3674: PPUSH
3675: LD_INT 0
3677: PPUSH
3678: CALL_OW 380
3682: ST_TO_ADDR
// for i = 1 to 4 do
3683: LD_ADDR_VAR 0 2
3687: PUSH
3688: DOUBLE
3689: LD_INT 1
3691: DEC
3692: ST_TO_ADDR
3693: LD_INT 4
3695: PUSH
3696: FOR_TO
3697: IFFALSE 3747
// for p = 1 to 6 do
3699: LD_ADDR_VAR 0 3
3703: PUSH
3704: DOUBLE
3705: LD_INT 1
3707: DEC
3708: ST_TO_ADDR
3709: LD_INT 6
3711: PUSH
3712: FOR_TO
3713: IFFALSE 3743
// filter := filter ^ CreateHumanWithClass ( i , l_skill ) ;
3715: LD_ADDR_VAR 0 4
3719: PUSH
3720: LD_VAR 0 4
3724: PUSH
3725: LD_VAR 0 2
3729: PPUSH
3730: LD_EXP 50
3734: PPUSH
3735: CALL 7214 0 2
3739: ADD
3740: ST_TO_ADDR
3741: GO 3712
3743: POP
3744: POP
3745: GO 3696
3747: POP
3748: POP
// team := CharacterSelection ( text , l_units , l_units , [ sel_change_class , l_cmndr , sel_changeable , sel_not_hired ] ^ filter , [ class_soldier , class_mechanic , class_engineer , class_scientistic , class_mortar ] ) ;
3749: LD_ADDR_VAR 0 5
3753: PUSH
3754: LD_STRING text
3756: PPUSH
3757: LD_EXP 51
3761: PPUSH
3762: LD_EXP 51
3766: PPUSH
3767: LD_INT -5
3769: PUSH
3770: LD_EXP 49
3774: PUSH
3775: LD_INT -3
3777: PUSH
3778: LD_INT -2
3780: PUSH
3781: EMPTY
3782: LIST
3783: LIST
3784: LIST
3785: LIST
3786: PUSH
3787: LD_VAR 0 4
3791: ADD
3792: PPUSH
3793: LD_INT 1
3795: PUSH
3796: LD_INT 3
3798: PUSH
3799: LD_INT 2
3801: PUSH
3802: LD_INT 4
3804: PUSH
3805: LD_INT 8
3807: PUSH
3808: EMPTY
3809: LIST
3810: LIST
3811: LIST
3812: LIST
3813: LIST
3814: PPUSH
3815: CALL_OW 42
3819: ST_TO_ADDR
// for i = 1 to l_units do
3820: LD_ADDR_VAR 0 2
3824: PUSH
3825: DOUBLE
3826: LD_INT 1
3828: DEC
3829: ST_TO_ADDR
3830: LD_EXP 51
3834: PUSH
3835: FOR_TO
3836: IFFALSE 3861
// PlaceUnitArea ( team [ i ] , legion_spawn , false ) ;
3838: LD_VAR 0 5
3842: PUSH
3843: LD_VAR 0 2
3847: ARRAY
3848: PPUSH
3849: LD_INT 1
3851: PPUSH
3852: LD_INT 0
3854: PPUSH
3855: CALL_OW 49
3859: GO 3835
3861: POP
3862: POP
// PlaceUnitArea ( l_cmndr , legion_spawn , false ) ;
3863: LD_EXP 49
3867: PPUSH
3868: LD_INT 1
3870: PPUSH
3871: LD_INT 0
3873: PPUSH
3874: CALL_OW 49
// end ;
3878: LD_VAR 0 1
3882: RET
// export function PlaceCamera ; begin
3883: LD_INT 0
3885: PPUSH
// PlaceSeeing ( 46 , 48 , 8 , 10 ) ;
3886: LD_INT 46
3888: PPUSH
3889: LD_INT 48
3891: PPUSH
3892: LD_INT 8
3894: PPUSH
3895: LD_INT 10
3897: PPUSH
3898: CALL_OW 330
// PlaceSeeing ( 58 , 66 , 8 , 10 ) ;
3902: LD_INT 58
3904: PPUSH
3905: LD_INT 66
3907: PPUSH
3908: LD_INT 8
3910: PPUSH
3911: LD_INT 10
3913: PPUSH
3914: CALL_OW 330
// PlaceSeeing ( 82 , 82 , 8 , 10 ) ;
3918: LD_INT 82
3920: PPUSH
3921: LD_INT 82
3923: PPUSH
3924: LD_INT 8
3926: PPUSH
3927: LD_INT 10
3929: PPUSH
3930: CALL_OW 330
// PlaceSeeing ( 107 , 79 , 8 , 10 ) ;
3934: LD_INT 107
3936: PPUSH
3937: LD_INT 79
3939: PPUSH
3940: LD_INT 8
3942: PPUSH
3943: LD_INT 10
3945: PPUSH
3946: CALL_OW 330
// PlaceSeeing ( 101 , 57 , 8 , 10 ) ;
3950: LD_INT 101
3952: PPUSH
3953: LD_INT 57
3955: PPUSH
3956: LD_INT 8
3958: PPUSH
3959: LD_INT 10
3961: PPUSH
3962: CALL_OW 330
// PlaceSeeing ( 85 , 32 , 8 , 10 ) ;
3966: LD_INT 85
3968: PPUSH
3969: LD_INT 32
3971: PPUSH
3972: LD_INT 8
3974: PPUSH
3975: LD_INT 10
3977: PPUSH
3978: CALL_OW 330
// PlaceSeeing ( 108 , 72 , 8 , 10 ) ;
3982: LD_INT 108
3984: PPUSH
3985: LD_INT 72
3987: PPUSH
3988: LD_INT 8
3990: PPUSH
3991: LD_INT 10
3993: PPUSH
3994: CALL_OW 330
// PlaceSeeing ( 124 , 74 , 8 , 10 ) ;
3998: LD_INT 124
4000: PPUSH
4001: LD_INT 74
4003: PPUSH
4004: LD_INT 8
4006: PPUSH
4007: LD_INT 10
4009: PPUSH
4010: CALL_OW 330
// PlaceSeeing ( 67 , 33 , 8 , 20 ) ;
4014: LD_INT 67
4016: PPUSH
4017: LD_INT 33
4019: PPUSH
4020: LD_INT 8
4022: PPUSH
4023: LD_INT 20
4025: PPUSH
4026: CALL_OW 330
// RemoveSeeing ( 67 , 33 , 8 ) ;
4030: LD_INT 67
4032: PPUSH
4033: LD_INT 33
4035: PPUSH
4036: LD_INT 8
4038: PPUSH
4039: CALL_OW 331
// PlaceSeeing ( 94 , 84 , 8 , 20 ) ;
4043: LD_INT 94
4045: PPUSH
4046: LD_INT 84
4048: PPUSH
4049: LD_INT 8
4051: PPUSH
4052: LD_INT 20
4054: PPUSH
4055: CALL_OW 330
// RemoveSeeing ( 94 , 84 , 8 ) ;
4059: LD_INT 94
4061: PPUSH
4062: LD_INT 84
4064: PPUSH
4065: LD_INT 8
4067: PPUSH
4068: CALL_OW 331
// end ;
4072: LD_VAR 0 1
4076: RET
// export function PrepareMeeting ; begin
4077: LD_INT 0
4079: PPUSH
// uc_side := 6 ;
4080: LD_ADDR_OWVAR 20
4084: PUSH
4085: LD_INT 6
4087: ST_TO_ADDR
// hc_gallery := desert ;
4088: LD_ADDR_OWVAR 33
4092: PUSH
4093: LD_STRING desert
4095: ST_TO_ADDR
// hc_face_number := 2 ;
4096: LD_ADDR_OWVAR 34
4100: PUSH
4101: LD_INT 2
4103: ST_TO_ADDR
// hc_name := Leopold Drass ;
4104: LD_ADDR_OWVAR 26
4108: PUSH
4109: LD_STRING Leopold Drass
4111: ST_TO_ADDR
// hc_class := 1 ;
4112: LD_ADDR_OWVAR 28
4116: PUSH
4117: LD_INT 1
4119: ST_TO_ADDR
// hc_sex := sex_male ;
4120: LD_ADDR_OWVAR 27
4124: PUSH
4125: LD_INT 1
4127: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
4128: LD_ADDR_OWVAR 29
4132: PUSH
4133: LD_INT 12
4135: PUSH
4136: LD_INT 12
4138: PUSH
4139: EMPTY
4140: LIST
4141: LIST
4142: ST_TO_ADDR
// Leopold := CreateHuman ;
4143: LD_ADDR_EXP 7
4147: PUSH
4148: CALL_OW 44
4152: ST_TO_ADDR
// PlaceUnitArea ( Leopold , north_spawn , false ) ;
4153: LD_EXP 7
4157: PPUSH
4158: LD_INT 3
4160: PPUSH
4161: LD_INT 0
4163: PPUSH
4164: CALL_OW 49
// end ; end_of_file
4168: LD_VAR 0 1
4172: RET
// on SailEvent ( num ) do var i , filter , un , p , area ;
4173: LD_INT 0
4175: PPUSH
4176: PPUSH
4177: PPUSH
4178: PPUSH
4179: PPUSH
// begin case num of 1 :
4180: LD_VAR 0 1
4184: PUSH
4185: LD_INT 1
4187: DOUBLE
4188: EQUAL
4189: IFTRUE 4193
4191: GO 4225
4193: POP
// begin ComMoveXY ( leopold , GetX ( l_cmndr ) , GetY ( l_cmndr ) ) ;
4194: LD_EXP 7
4198: PPUSH
4199: LD_EXP 49
4203: PPUSH
4204: CALL_OW 250
4208: PPUSH
4209: LD_EXP 49
4213: PPUSH
4214: CALL_OW 251
4218: PPUSH
4219: CALL_OW 111
// end ; 2 :
4223: GO 6626
4225: LD_INT 2
4227: DOUBLE
4228: EQUAL
4229: IFTRUE 4233
4231: GO 4342
4233: POP
// begin InGameOn ;
4234: CALL_OW 8
// meeting_start := true ;
4238: LD_ADDR_EXP 26
4242: PUSH
4243: LD_INT 1
4245: ST_TO_ADDR
// ComTurnUnit ( leopold , l_cmndr ) ;
4246: LD_EXP 7
4250: PPUSH
4251: LD_EXP 49
4255: PPUSH
4256: CALL_OW 119
// ComTurnUnit ( l_cmndr , leopold ) ;
4260: LD_EXP 49
4264: PPUSH
4265: LD_EXP 7
4269: PPUSH
4270: CALL_OW 119
// Say ( leopold , DS-DL-1 ) ;
4274: LD_EXP 7
4278: PPUSH
4279: LD_STRING DS-DL-1
4281: PPUSH
4282: CALL_OW 88
// Say ( l_cmndr , DS-DC-1 ) ;
4286: LD_EXP 49
4290: PPUSH
4291: LD_STRING DS-DC-1
4293: PPUSH
4294: CALL_OW 88
// Say ( leopold , DS-DL-2 ) ;
4298: LD_EXP 7
4302: PPUSH
4303: LD_STRING DS-DL-2
4305: PPUSH
4306: CALL_OW 88
// ComEnterUnit ( leopold , fort ) ;
4310: LD_EXP 7
4314: PPUSH
4315: LD_INT 23
4317: PPUSH
4318: CALL_OW 120
// InGameOff ;
4322: CALL_OW 9
// Wait ( 0 0$01 ) ;
4326: LD_INT 35
4328: PPUSH
4329: CALL_OW 67
// ChangeMissionObjectives ( DS-T1 ) ;
4333: LD_STRING DS-T1
4335: PPUSH
4336: CALL_OW 337
// end ; 10 :
4340: GO 6626
4342: LD_INT 10
4344: DOUBLE
4345: EQUAL
4346: IFTRUE 4350
4348: GO 4562
4350: POP
// begin uc_side := 6 ;
4351: LD_ADDR_OWVAR 20
4355: PUSH
4356: LD_INT 6
4358: ST_TO_ADDR
// uc_nation := 2 ;
4359: LD_ADDR_OWVAR 21
4363: PUSH
4364: LD_INT 2
4366: ST_TO_ADDR
// hc_gallery :=  ;
4367: LD_ADDR_OWVAR 33
4371: PUSH
4372: LD_STRING 
4374: ST_TO_ADDR
// hc_skills := [ skill + 2 , skill - 1 , skill , skill + 1 ] ;
4375: LD_ADDR_OWVAR 31
4379: PUSH
4380: LD_EXP 16
4384: PUSH
4385: LD_INT 2
4387: PLUS
4388: PUSH
4389: LD_EXP 16
4393: PUSH
4394: LD_INT 1
4396: MINUS
4397: PUSH
4398: LD_EXP 16
4402: PUSH
4403: LD_EXP 16
4407: PUSH
4408: LD_INT 1
4410: PLUS
4411: PUSH
4412: EMPTY
4413: LIST
4414: LIST
4415: LIST
4416: LIST
4417: ST_TO_ADDR
// hc_sex := sex_male ;
4418: LD_ADDR_OWVAR 27
4422: PUSH
4423: LD_INT 1
4425: ST_TO_ADDR
// hc_name := Samuel van Horn ;
4426: LD_ADDR_OWVAR 26
4430: PUSH
4431: LD_STRING Samuel van Horn
4433: ST_TO_ADDR
// hc_attr := [ 11 , 10 ] ;
4434: LD_ADDR_OWVAR 29
4438: PUSH
4439: LD_INT 11
4441: PUSH
4442: LD_INT 10
4444: PUSH
4445: EMPTY
4446: LIST
4447: LIST
4448: ST_TO_ADDR
// hc_class := 1 ;
4449: LD_ADDR_OWVAR 28
4453: PUSH
4454: LD_INT 1
4456: ST_TO_ADDR
// samuel := CreateHuman ;
4457: LD_ADDR_EXP 9
4461: PUSH
4462: CALL_OW 44
4466: ST_TO_ADDR
// PlaceUnitArea ( samuel , south_spawn , false ) ;
4467: LD_EXP 9
4471: PPUSH
4472: LD_INT 4
4474: PPUSH
4475: LD_INT 0
4477: PPUSH
4478: CALL_OW 49
// for i = 1 to 3 do
4482: LD_ADDR_VAR 0 2
4486: PUSH
4487: DOUBLE
4488: LD_INT 1
4490: DEC
4491: ST_TO_ADDR
4492: LD_INT 3
4494: PUSH
4495: FOR_TO
4496: IFFALSE 4523
// PlaceUnitArea ( CreateHumanWithClass ( class_mortar , skill ) , south_spawn , false ) ;
4498: LD_INT 8
4500: PPUSH
4501: LD_EXP 16
4505: PPUSH
4506: CALL 7214 0 2
4510: PPUSH
4511: LD_INT 4
4513: PPUSH
4514: LD_INT 0
4516: PPUSH
4517: CALL_OW 49
4521: GO 4495
4523: POP
4524: POP
// ComEnterUnit ( FilterAllUnits ( [ f_side , 6 ] ) diff [ leopold , fort ] , fort ) ;
4525: LD_INT 22
4527: PUSH
4528: LD_INT 6
4530: PUSH
4531: EMPTY
4532: LIST
4533: LIST
4534: PPUSH
4535: CALL_OW 69
4539: PUSH
4540: LD_EXP 7
4544: PUSH
4545: LD_INT 23
4547: PUSH
4548: EMPTY
4549: LIST
4550: LIST
4551: DIFF
4552: PPUSH
4553: LD_INT 23
4555: PPUSH
4556: CALL_OW 120
// end ; 3 :
4560: GO 6626
4562: LD_INT 3
4564: DOUBLE
4565: EQUAL
4566: IFTRUE 4570
4568: GO 4581
4570: POP
// begin arabian_attack := true ;
4571: LD_ADDR_EXP 38
4575: PUSH
4576: LD_INT 1
4578: ST_TO_ADDR
// end ; 4 :
4579: GO 6626
4581: LD_INT 4
4583: DOUBLE
4584: EQUAL
4585: IFTRUE 4589
4587: GO 4600
4589: POP
// begin american_attack := true ;
4590: LD_ADDR_EXP 40
4594: PUSH
4595: LD_INT 1
4597: ST_TO_ADDR
// end ; 5 :
4598: GO 6626
4600: LD_INT 5
4602: DOUBLE
4603: EQUAL
4604: IFTRUE 4608
4606: GO 4619
4608: POP
// begin russian_attack := true ;
4609: LD_ADDR_EXP 39
4613: PUSH
4614: LD_INT 1
4616: ST_TO_ADDR
// end ; 31 :
4617: GO 6626
4619: LD_INT 31
4621: DOUBLE
4622: EQUAL
4623: IFTRUE 4627
4625: GO 4902
4627: POP
// begin area := areas [ Rand ( 1 , areas ) ] ;
4628: LD_ADDR_VAR 0 6
4632: PUSH
4633: LD_EXP 15
4637: PUSH
4638: LD_INT 1
4640: PPUSH
4641: LD_EXP 15
4645: PPUSH
4646: CALL_OW 12
4650: ARRAY
4651: ST_TO_ADDR
// uc_side := 2 ;
4652: LD_ADDR_OWVAR 20
4656: PUSH
4657: LD_INT 2
4659: ST_TO_ADDR
// uc_nation := 2 ;
4660: LD_ADDR_OWVAR 21
4664: PUSH
4665: LD_INT 2
4667: ST_TO_ADDR
// for i = 1 to arabian_force do
4668: LD_ADDR_VAR 0 2
4672: PUSH
4673: DOUBLE
4674: LD_INT 1
4676: DEC
4677: ST_TO_ADDR
4678: LD_EXP 20
4682: PUSH
4683: FOR_TO
4684: IFFALSE 4763
// begin vc_chassis := ar_half_tracked ;
4686: LD_ADDR_OWVAR 37
4690: PUSH
4691: LD_INT 14
4693: ST_TO_ADDR
// vc_engine := engine_siberite ;
4694: LD_ADDR_OWVAR 39
4698: PUSH
4699: LD_INT 3
4701: ST_TO_ADDR
// vc_control := control_remote ;
4702: LD_ADDR_OWVAR 38
4706: PUSH
4707: LD_INT 2
4709: ST_TO_ADDR
// vc_weapon := ar_weapons [ Rand ( 1 , ar_weapons ) ] ;
4710: LD_ADDR_OWVAR 40
4714: PUSH
4715: LD_EXP 17
4719: PUSH
4720: LD_INT 1
4722: PPUSH
4723: LD_EXP 17
4727: PPUSH
4728: CALL_OW 12
4732: ARRAY
4733: ST_TO_ADDR
// un := CreateVehicle ;
4734: LD_ADDR_VAR 0 4
4738: PUSH
4739: CALL_OW 45
4743: ST_TO_ADDR
// PlaceUnitArea ( un , area , false ) ;
4744: LD_VAR 0 4
4748: PPUSH
4749: LD_VAR 0 6
4753: PPUSH
4754: LD_INT 0
4756: PPUSH
4757: CALL_OW 49
// end ;
4761: GO 4683
4763: POP
4764: POP
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_control , control_manual ] ] ) < 2 then
4765: LD_INT 22
4767: PUSH
4768: LD_INT 2
4770: PUSH
4771: EMPTY
4772: LIST
4773: LIST
4774: PUSH
4775: LD_INT 33
4777: PUSH
4778: LD_INT 1
4780: PUSH
4781: EMPTY
4782: LIST
4783: LIST
4784: PUSH
4785: EMPTY
4786: LIST
4787: LIST
4788: PPUSH
4789: CALL_OW 69
4793: PUSH
4794: LD_INT 2
4796: LESS
4797: IFFALSE 4900
// for i = 1 to 2 do
4799: LD_ADDR_VAR 0 2
4803: PUSH
4804: DOUBLE
4805: LD_INT 1
4807: DEC
4808: ST_TO_ADDR
4809: LD_INT 2
4811: PUSH
4812: FOR_TO
4813: IFFALSE 4898
// begin vc_chassis := ar_half_tracked ;
4815: LD_ADDR_OWVAR 37
4819: PUSH
4820: LD_INT 14
4822: ST_TO_ADDR
// vc_engine := engine_siberite ;
4823: LD_ADDR_OWVAR 39
4827: PUSH
4828: LD_INT 3
4830: ST_TO_ADDR
// vc_control := control_manual ;
4831: LD_ADDR_OWVAR 38
4835: PUSH
4836: LD_INT 1
4838: ST_TO_ADDR
// vc_weapon := ar_control_tower ;
4839: LD_ADDR_OWVAR 40
4843: PUSH
4844: LD_INT 31
4846: ST_TO_ADDR
// un := CreateVehicle ;
4847: LD_ADDR_VAR 0 4
4851: PUSH
4852: CALL_OW 45
4856: ST_TO_ADDR
// PlaceUnitArea ( un , area , false ) ;
4857: LD_VAR 0 4
4861: PPUSH
4862: LD_VAR 0 6
4866: PPUSH
4867: LD_INT 0
4869: PPUSH
4870: CALL_OW 49
// PlaceHumanInUnit ( CreateHumanWithClass ( 3 , skill ) , un ) ;
4874: LD_INT 3
4876: PPUSH
4877: LD_EXP 16
4881: PPUSH
4882: CALL 7214 0 2
4886: PPUSH
4887: LD_VAR 0 4
4891: PPUSH
4892: CALL_OW 52
// end ;
4896: GO 4812
4898: POP
4899: POP
// end ; 32 :
4900: GO 6626
4902: LD_INT 32
4904: DOUBLE
4905: EQUAL
4906: IFTRUE 4910
4908: GO 5283
4910: POP
// begin area := areas [ Rand ( 1 , areas ) ] ;
4911: LD_ADDR_VAR 0 6
4915: PUSH
4916: LD_EXP 15
4920: PUSH
4921: LD_INT 1
4923: PPUSH
4924: LD_EXP 15
4928: PPUSH
4929: CALL_OW 12
4933: ARRAY
4934: ST_TO_ADDR
// uc_side := 2 ;
4935: LD_ADDR_OWVAR 20
4939: PUSH
4940: LD_INT 2
4942: ST_TO_ADDR
// uc_nation := 2 ;
4943: LD_ADDR_OWVAR 21
4947: PUSH
4948: LD_INT 2
4950: ST_TO_ADDR
// for i = 1 to ( arabian_force - 2 ) do
4951: LD_ADDR_VAR 0 2
4955: PUSH
4956: DOUBLE
4957: LD_INT 1
4959: DEC
4960: ST_TO_ADDR
4961: LD_EXP 20
4965: PUSH
4966: LD_INT 2
4968: MINUS
4969: PUSH
4970: FOR_TO
4971: IFFALSE 5054
// begin vc_chassis := ar_half_tracked ;
4973: LD_ADDR_OWVAR 37
4977: PUSH
4978: LD_INT 14
4980: ST_TO_ADDR
// vc_engine := engine_siberite ;
4981: LD_ADDR_OWVAR 39
4985: PUSH
4986: LD_INT 3
4988: ST_TO_ADDR
// vc_control := control_remote ;
4989: LD_ADDR_OWVAR 38
4993: PUSH
4994: LD_INT 2
4996: ST_TO_ADDR
// vc_weapon := ar_weapons [ Rand ( 1 , ar_weapons - 1 ) ] ;
4997: LD_ADDR_OWVAR 40
5001: PUSH
5002: LD_EXP 17
5006: PUSH
5007: LD_INT 1
5009: PPUSH
5010: LD_EXP 17
5014: PUSH
5015: LD_INT 1
5017: MINUS
5018: PPUSH
5019: CALL_OW 12
5023: ARRAY
5024: ST_TO_ADDR
// un := CreateVehicle ;
5025: LD_ADDR_VAR 0 4
5029: PUSH
5030: CALL_OW 45
5034: ST_TO_ADDR
// PlaceUnitArea ( un , area , false ) ;
5035: LD_VAR 0 4
5039: PPUSH
5040: LD_VAR 0 6
5044: PPUSH
5045: LD_INT 0
5047: PPUSH
5048: CALL_OW 49
// end ;
5052: GO 4970
5054: POP
5055: POP
// for i = 1 to Rand ( 0 , 1 ) + [ 3 , 4 , 5 ] [ game_difficulty ] do
5056: LD_ADDR_VAR 0 2
5060: PUSH
5061: DOUBLE
5062: LD_INT 1
5064: DEC
5065: ST_TO_ADDR
5066: LD_INT 0
5068: PPUSH
5069: LD_INT 1
5071: PPUSH
5072: CALL_OW 12
5076: PUSH
5077: LD_INT 3
5079: PUSH
5080: LD_INT 4
5082: PUSH
5083: LD_INT 5
5085: PUSH
5086: EMPTY
5087: LIST
5088: LIST
5089: LIST
5090: PUSH
5091: LD_EXP 2
5095: ARRAY
5096: PLUS
5097: PUSH
5098: FOR_TO
5099: IFFALSE 5136
// begin uc_nation := 0 ;
5101: LD_ADDR_OWVAR 21
5105: PUSH
5106: LD_INT 0
5108: ST_TO_ADDR
// PlaceUnitArea ( CreateHumanWithClass ( 17 , skill ) , area , false ) ;
5109: LD_INT 17
5111: PPUSH
5112: LD_EXP 16
5116: PPUSH
5117: CALL 7214 0 2
5121: PPUSH
5122: LD_VAR 0 6
5126: PPUSH
5127: LD_INT 0
5129: PPUSH
5130: CALL_OW 49
// end ;
5134: GO 5098
5136: POP
5137: POP
// uc_nation := 2 ;
5138: LD_ADDR_OWVAR 21
5142: PUSH
5143: LD_INT 2
5145: ST_TO_ADDR
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_control , control_manual ] ] ) < 2 then
5146: LD_INT 22
5148: PUSH
5149: LD_INT 2
5151: PUSH
5152: EMPTY
5153: LIST
5154: LIST
5155: PUSH
5156: LD_INT 33
5158: PUSH
5159: LD_INT 1
5161: PUSH
5162: EMPTY
5163: LIST
5164: LIST
5165: PUSH
5166: EMPTY
5167: LIST
5168: LIST
5169: PPUSH
5170: CALL_OW 69
5174: PUSH
5175: LD_INT 2
5177: LESS
5178: IFFALSE 5281
// for i = 1 to 2 do
5180: LD_ADDR_VAR 0 2
5184: PUSH
5185: DOUBLE
5186: LD_INT 1
5188: DEC
5189: ST_TO_ADDR
5190: LD_INT 2
5192: PUSH
5193: FOR_TO
5194: IFFALSE 5279
// begin vc_chassis := ar_half_tracked ;
5196: LD_ADDR_OWVAR 37
5200: PUSH
5201: LD_INT 14
5203: ST_TO_ADDR
// vc_engine := engine_siberite ;
5204: LD_ADDR_OWVAR 39
5208: PUSH
5209: LD_INT 3
5211: ST_TO_ADDR
// vc_control := control_manual ;
5212: LD_ADDR_OWVAR 38
5216: PUSH
5217: LD_INT 1
5219: ST_TO_ADDR
// vc_weapon := ar_control_tower ;
5220: LD_ADDR_OWVAR 40
5224: PUSH
5225: LD_INT 31
5227: ST_TO_ADDR
// un := CreateVehicle ;
5228: LD_ADDR_VAR 0 4
5232: PUSH
5233: CALL_OW 45
5237: ST_TO_ADDR
// PlaceUnitArea ( un , area , false ) ;
5238: LD_VAR 0 4
5242: PPUSH
5243: LD_VAR 0 6
5247: PPUSH
5248: LD_INT 0
5250: PPUSH
5251: CALL_OW 49
// PlaceHumanInUnit ( CreateHumanWithClass ( 3 , skill ) , un ) ;
5255: LD_INT 3
5257: PPUSH
5258: LD_EXP 16
5262: PPUSH
5263: CALL 7214 0 2
5267: PPUSH
5268: LD_VAR 0 4
5272: PPUSH
5273: CALL_OW 52
// end ;
5277: GO 5193
5279: POP
5280: POP
// end ; 33 :
5281: GO 6626
5283: LD_INT 33
5285: DOUBLE
5286: EQUAL
5287: IFTRUE 5291
5289: GO 5562
5291: POP
// begin area := areas [ Rand ( 1 , areas ) ] ;
5292: LD_ADDR_VAR 0 6
5296: PUSH
5297: LD_EXP 15
5301: PUSH
5302: LD_INT 1
5304: PPUSH
5305: LD_EXP 15
5309: PPUSH
5310: CALL_OW 12
5314: ARRAY
5315: ST_TO_ADDR
// uc_side := 2 ;
5316: LD_ADDR_OWVAR 20
5320: PUSH
5321: LD_INT 2
5323: ST_TO_ADDR
// uc_nation := 2 ;
5324: LD_ADDR_OWVAR 21
5328: PUSH
5329: LD_INT 2
5331: ST_TO_ADDR
// for i = 1 to ( arabian_force / 2 ) do
5332: LD_ADDR_VAR 0 2
5336: PUSH
5337: DOUBLE
5338: LD_INT 1
5340: DEC
5341: ST_TO_ADDR
5342: LD_EXP 20
5346: PUSH
5347: LD_INT 2
5349: DIVREAL
5350: PUSH
5351: FOR_TO
5352: IFFALSE 5457
// begin vc_chassis := ar_half_tracked ;
5354: LD_ADDR_OWVAR 37
5358: PUSH
5359: LD_INT 14
5361: ST_TO_ADDR
// vc_engine := engine_siberite ;
5362: LD_ADDR_OWVAR 39
5366: PUSH
5367: LD_INT 3
5369: ST_TO_ADDR
// vc_control := control_manual ;
5370: LD_ADDR_OWVAR 38
5374: PUSH
5375: LD_INT 1
5377: ST_TO_ADDR
// vc_weapon := ar_weapons [ Rand ( 1 , ar_weapons - 2 ) ] ;
5378: LD_ADDR_OWVAR 40
5382: PUSH
5383: LD_EXP 17
5387: PUSH
5388: LD_INT 1
5390: PPUSH
5391: LD_EXP 17
5395: PUSH
5396: LD_INT 2
5398: MINUS
5399: PPUSH
5400: CALL_OW 12
5404: ARRAY
5405: ST_TO_ADDR
// un := CreateVehicle ;
5406: LD_ADDR_VAR 0 4
5410: PUSH
5411: CALL_OW 45
5415: ST_TO_ADDR
// PlaceUnitArea ( un , area , false ) ;
5416: LD_VAR 0 4
5420: PPUSH
5421: LD_VAR 0 6
5425: PPUSH
5426: LD_INT 0
5428: PPUSH
5429: CALL_OW 49
// PlaceHumanInUnit ( CreateHumanWithClass ( 3 , skill ) , un ) ;
5433: LD_INT 3
5435: PPUSH
5436: LD_EXP 16
5440: PPUSH
5441: CALL 7214 0 2
5445: PPUSH
5446: LD_VAR 0 4
5450: PPUSH
5451: CALL_OW 52
// end ;
5455: GO 5351
5457: POP
5458: POP
// for i = 1 to ( arabian_force / 2 ) do
5459: LD_ADDR_VAR 0 2
5463: PUSH
5464: DOUBLE
5465: LD_INT 1
5467: DEC
5468: ST_TO_ADDR
5469: LD_EXP 20
5473: PUSH
5474: LD_INT 2
5476: DIVREAL
5477: PUSH
5478: FOR_TO
5479: IFFALSE 5558
// begin vc_chassis := ar_half_tracked ;
5481: LD_ADDR_OWVAR 37
5485: PUSH
5486: LD_INT 14
5488: ST_TO_ADDR
// vc_engine := engine_siberite ;
5489: LD_ADDR_OWVAR 39
5493: PUSH
5494: LD_INT 3
5496: ST_TO_ADDR
// vc_control := control_apeman ;
5497: LD_ADDR_OWVAR 38
5501: PUSH
5502: LD_INT 5
5504: ST_TO_ADDR
// vc_weapon := ar_weapons [ Rand ( 2 , ar_weapons ) ] ;
5505: LD_ADDR_OWVAR 40
5509: PUSH
5510: LD_EXP 17
5514: PUSH
5515: LD_INT 2
5517: PPUSH
5518: LD_EXP 17
5522: PPUSH
5523: CALL_OW 12
5527: ARRAY
5528: ST_TO_ADDR
// un := CreateVehicle ;
5529: LD_ADDR_VAR 0 4
5533: PUSH
5534: CALL_OW 45
5538: ST_TO_ADDR
// PlaceUnitArea ( un , area , false ) ;
5539: LD_VAR 0 4
5543: PPUSH
5544: LD_VAR 0 6
5548: PPUSH
5549: LD_INT 0
5551: PPUSH
5552: CALL_OW 49
// end ;
5556: GO 5478
5558: POP
5559: POP
// end ; 41 :
5560: GO 6626
5562: LD_INT 41
5564: DOUBLE
5565: EQUAL
5566: IFTRUE 5570
5568: GO 5714
5570: POP
// begin area := areas [ Rand ( 1 , areas ) ] ;
5571: LD_ADDR_VAR 0 6
5575: PUSH
5576: LD_EXP 15
5580: PUSH
5581: LD_INT 1
5583: PPUSH
5584: LD_EXP 15
5588: PPUSH
5589: CALL_OW 12
5593: ARRAY
5594: ST_TO_ADDR
// uc_side := 1 ;
5595: LD_ADDR_OWVAR 20
5599: PUSH
5600: LD_INT 1
5602: ST_TO_ADDR
// uc_nation := 1 ;
5603: LD_ADDR_OWVAR 21
5607: PUSH
5608: LD_INT 1
5610: ST_TO_ADDR
// for i = 1 to american_force do
5611: LD_ADDR_VAR 0 2
5615: PUSH
5616: DOUBLE
5617: LD_INT 1
5619: DEC
5620: ST_TO_ADDR
5621: LD_EXP 22
5625: PUSH
5626: FOR_TO
5627: IFFALSE 5710
// begin vc_chassis := us_morphling ;
5629: LD_ADDR_OWVAR 37
5633: PUSH
5634: LD_INT 5
5636: ST_TO_ADDR
// vc_engine := engine_siberite ;
5637: LD_ADDR_OWVAR 39
5641: PUSH
5642: LD_INT 3
5644: ST_TO_ADDR
// vc_control := control_computer ;
5645: LD_ADDR_OWVAR 38
5649: PUSH
5650: LD_INT 3
5652: ST_TO_ADDR
// vc_weapon := us_weapons [ Rand ( 1 , us_weapons - 1 ) ] ;
5653: LD_ADDR_OWVAR 40
5657: PUSH
5658: LD_EXP 19
5662: PUSH
5663: LD_INT 1
5665: PPUSH
5666: LD_EXP 19
5670: PUSH
5671: LD_INT 1
5673: MINUS
5674: PPUSH
5675: CALL_OW 12
5679: ARRAY
5680: ST_TO_ADDR
// un := CreateVehicle ;
5681: LD_ADDR_VAR 0 4
5685: PUSH
5686: CALL_OW 45
5690: ST_TO_ADDR
// PlaceUnitArea ( un , area , false ) ;
5691: LD_VAR 0 4
5695: PPUSH
5696: LD_VAR 0 6
5700: PPUSH
5701: LD_INT 0
5703: PPUSH
5704: CALL_OW 49
// end ;
5708: GO 5626
5710: POP
5711: POP
// end ; 42 :
5712: GO 6626
5714: LD_INT 42
5716: DOUBLE
5717: EQUAL
5718: IFTRUE 5722
5720: GO 5862
5722: POP
// begin area := areas [ Rand ( 1 , areas ) ] ;
5723: LD_ADDR_VAR 0 6
5727: PUSH
5728: LD_EXP 15
5732: PUSH
5733: LD_INT 1
5735: PPUSH
5736: LD_EXP 15
5740: PPUSH
5741: CALL_OW 12
5745: ARRAY
5746: ST_TO_ADDR
// uc_side := 1 ;
5747: LD_ADDR_OWVAR 20
5751: PUSH
5752: LD_INT 1
5754: ST_TO_ADDR
// uc_nation := 1 ;
5755: LD_ADDR_OWVAR 21
5759: PUSH
5760: LD_INT 1
5762: ST_TO_ADDR
// for i = 1 to american_force do
5763: LD_ADDR_VAR 0 2
5767: PUSH
5768: DOUBLE
5769: LD_INT 1
5771: DEC
5772: ST_TO_ADDR
5773: LD_EXP 22
5777: PUSH
5778: FOR_TO
5779: IFFALSE 5858
// begin vc_chassis := us_morphling ;
5781: LD_ADDR_OWVAR 37
5785: PUSH
5786: LD_INT 5
5788: ST_TO_ADDR
// vc_engine := engine_siberite ;
5789: LD_ADDR_OWVAR 39
5793: PUSH
5794: LD_INT 3
5796: ST_TO_ADDR
// vc_control := control_computer ;
5797: LD_ADDR_OWVAR 38
5801: PUSH
5802: LD_INT 3
5804: ST_TO_ADDR
// vc_weapon := us_weapons [ Rand ( 1 , us_weapons ) ] ;
5805: LD_ADDR_OWVAR 40
5809: PUSH
5810: LD_EXP 19
5814: PUSH
5815: LD_INT 1
5817: PPUSH
5818: LD_EXP 19
5822: PPUSH
5823: CALL_OW 12
5827: ARRAY
5828: ST_TO_ADDR
// un := CreateVehicle ;
5829: LD_ADDR_VAR 0 4
5833: PUSH
5834: CALL_OW 45
5838: ST_TO_ADDR
// PlaceUnitArea ( un , area , false ) ;
5839: LD_VAR 0 4
5843: PPUSH
5844: LD_VAR 0 6
5848: PPUSH
5849: LD_INT 0
5851: PPUSH
5852: CALL_OW 49
// end ;
5856: GO 5778
5858: POP
5859: POP
// end ; 51 :
5860: GO 6626
5862: LD_INT 51
5864: DOUBLE
5865: EQUAL
5866: IFTRUE 5870
5868: GO 6010
5870: POP
// begin area := areas [ Rand ( 1 , areas ) ] ;
5871: LD_ADDR_VAR 0 6
5875: PUSH
5876: LD_EXP 15
5880: PUSH
5881: LD_INT 1
5883: PPUSH
5884: LD_EXP 15
5888: PPUSH
5889: CALL_OW 12
5893: ARRAY
5894: ST_TO_ADDR
// uc_side := 3 ;
5895: LD_ADDR_OWVAR 20
5899: PUSH
5900: LD_INT 3
5902: ST_TO_ADDR
// uc_nation := 3 ;
5903: LD_ADDR_OWVAR 21
5907: PUSH
5908: LD_INT 3
5910: ST_TO_ADDR
// for i = 1 to russian_force do
5911: LD_ADDR_VAR 0 2
5915: PUSH
5916: DOUBLE
5917: LD_INT 1
5919: DEC
5920: ST_TO_ADDR
5921: LD_EXP 21
5925: PUSH
5926: FOR_TO
5927: IFFALSE 6006
// begin vc_chassis := ru_heavy_tracked ;
5929: LD_ADDR_OWVAR 37
5933: PUSH
5934: LD_INT 24
5936: ST_TO_ADDR
// vc_engine := engine_siberite ;
5937: LD_ADDR_OWVAR 39
5941: PUSH
5942: LD_INT 3
5944: ST_TO_ADDR
// vc_control := control_computer ;
5945: LD_ADDR_OWVAR 38
5949: PUSH
5950: LD_INT 3
5952: ST_TO_ADDR
// vc_weapon := ru_weapons [ Rand ( 1 , ru_weapons ) ] ;
5953: LD_ADDR_OWVAR 40
5957: PUSH
5958: LD_EXP 18
5962: PUSH
5963: LD_INT 1
5965: PPUSH
5966: LD_EXP 18
5970: PPUSH
5971: CALL_OW 12
5975: ARRAY
5976: ST_TO_ADDR
// un := CreateVehicle ;
5977: LD_ADDR_VAR 0 4
5981: PUSH
5982: CALL_OW 45
5986: ST_TO_ADDR
// PlaceUnitArea ( un , area , false ) ;
5987: LD_VAR 0 4
5991: PPUSH
5992: LD_VAR 0 6
5996: PPUSH
5997: LD_INT 0
5999: PPUSH
6000: CALL_OW 49
// end ;
6004: GO 5926
6006: POP
6007: POP
// end ; 91 :
6008: GO 6626
6010: LD_INT 91
6012: DOUBLE
6013: EQUAL
6014: IFTRUE 6018
6016: GO 6156
6018: POP
// begin uc_side := 8 ;
6019: LD_ADDR_OWVAR 20
6023: PUSH
6024: LD_INT 8
6026: ST_TO_ADDR
// uc_nation := 1 ;
6027: LD_ADDR_OWVAR 21
6031: PUSH
6032: LD_INT 1
6034: ST_TO_ADDR
// for i = 1 to [ 5 , 4 , 3 ] [ game_difficulty ] do
6035: LD_ADDR_VAR 0 2
6039: PUSH
6040: DOUBLE
6041: LD_INT 1
6043: DEC
6044: ST_TO_ADDR
6045: LD_INT 5
6047: PUSH
6048: LD_INT 4
6050: PUSH
6051: LD_INT 3
6053: PUSH
6054: EMPTY
6055: LIST
6056: LIST
6057: LIST
6058: PUSH
6059: LD_EXP 2
6063: ARRAY
6064: PUSH
6065: FOR_TO
6066: IFFALSE 6152
// begin vc_chassis := us_heavy_tracked ;
6068: LD_ADDR_OWVAR 37
6072: PUSH
6073: LD_INT 4
6075: ST_TO_ADDR
// vc_engine := engine_siberite ;
6076: LD_ADDR_OWVAR 39
6080: PUSH
6081: LD_INT 3
6083: ST_TO_ADDR
// vc_control := control_computer ;
6084: LD_ADDR_OWVAR 38
6088: PUSH
6089: LD_INT 3
6091: ST_TO_ADDR
// vc_weapon := [ us_double_gun , us_heavy_gun ] [ Rand ( 1 , 2 ) ] ;
6092: LD_ADDR_OWVAR 40
6096: PUSH
6097: LD_INT 5
6099: PUSH
6100: LD_INT 6
6102: PUSH
6103: EMPTY
6104: LIST
6105: LIST
6106: PUSH
6107: LD_INT 1
6109: PPUSH
6110: LD_INT 2
6112: PPUSH
6113: CALL_OW 12
6117: ARRAY
6118: ST_TO_ADDR
// un := CreateVehicle ;
6119: LD_ADDR_VAR 0 4
6123: PUSH
6124: CALL_OW 45
6128: ST_TO_ADDR
// PlaceUnitArea ( un , areas [ 1 ] , false ) ;
6129: LD_VAR 0 4
6133: PPUSH
6134: LD_EXP 15
6138: PUSH
6139: LD_INT 1
6141: ARRAY
6142: PPUSH
6143: LD_INT 0
6145: PPUSH
6146: CALL_OW 49
// end ;
6150: GO 6065
6152: POP
6153: POP
// end ; 92 :
6154: GO 6626
6156: LD_INT 92
6158: DOUBLE
6159: EQUAL
6160: IFTRUE 6164
6162: GO 6493
6164: POP
// begin uc_side := 5 ;
6165: LD_ADDR_OWVAR 20
6169: PUSH
6170: LD_INT 5
6172: ST_TO_ADDR
// uc_nation := 2 ;
6173: LD_ADDR_OWVAR 21
6177: PUSH
6178: LD_INT 2
6180: ST_TO_ADDR
// filter := [ ] ;
6181: LD_ADDR_VAR 0 3
6185: PUSH
6186: EMPTY
6187: ST_TO_ADDR
// InitHc ;
6188: CALL_OW 19
// PrepareHuman ( false , 1 , l_skill ) ;
6192: LD_INT 0
6194: PPUSH
6195: LD_INT 1
6197: PPUSH
6198: LD_EXP 50
6202: PPUSH
6203: CALL_OW 380
// un := CreateHuman ;
6207: LD_ADDR_VAR 0 4
6211: PUSH
6212: CALL_OW 44
6216: ST_TO_ADDR
// filter := filter ^ un ;
6217: LD_ADDR_VAR 0 3
6221: PUSH
6222: LD_VAR 0 3
6226: PUSH
6227: LD_VAR 0 4
6231: ADD
6232: ST_TO_ADDR
// for i = 1 to [ 4 , 3 , 2 ] [ game_difficulty ] do
6233: LD_ADDR_VAR 0 2
6237: PUSH
6238: DOUBLE
6239: LD_INT 1
6241: DEC
6242: ST_TO_ADDR
6243: LD_INT 4
6245: PUSH
6246: LD_INT 3
6248: PUSH
6249: LD_INT 2
6251: PUSH
6252: EMPTY
6253: LIST
6254: LIST
6255: LIST
6256: PUSH
6257: LD_EXP 2
6261: ARRAY
6262: PUSH
6263: FOR_TO
6264: IFFALSE 6302
// begin un := CreateHumanWithClass ( 1 , l_skill ) ;
6266: LD_ADDR_VAR 0 4
6270: PUSH
6271: LD_INT 1
6273: PPUSH
6274: LD_EXP 50
6278: PPUSH
6279: CALL 7214 0 2
6283: ST_TO_ADDR
// filter := filter ^ un ;
6284: LD_ADDR_VAR 0 3
6288: PUSH
6289: LD_VAR 0 3
6293: PUSH
6294: LD_VAR 0 4
6298: ADD
6299: ST_TO_ADDR
// end ;
6300: GO 6263
6302: POP
6303: POP
// DialogueOn ;
6304: CALL_OW 6
// if GetSex ( filter [ 1 ] ) = sex_male then
6308: LD_VAR 0 3
6312: PUSH
6313: LD_INT 1
6315: ARRAY
6316: PPUSH
6317: CALL_OW 258
6321: PUSH
6322: LD_INT 1
6324: EQUAL
6325: IFFALSE 6345
// SayRadio ( filter [ 1 ] , DS-DF-1 ) else
6327: LD_VAR 0 3
6331: PUSH
6332: LD_INT 1
6334: ARRAY
6335: PPUSH
6336: LD_STRING DS-DF-1
6338: PPUSH
6339: CALL_OW 94
6343: GO 6361
// SayRadio ( filter [ 1 ] , DS-DF-f1 ) ;
6345: LD_VAR 0 3
6349: PUSH
6350: LD_INT 1
6352: ARRAY
6353: PPUSH
6354: LD_STRING DS-DF-f1
6356: PPUSH
6357: CALL_OW 94
// case Query ( DS-dezert ) of 1 :
6361: LD_STRING DS-dezert
6363: PPUSH
6364: CALL_OW 97
6368: PUSH
6369: LD_INT 1
6371: DOUBLE
6372: EQUAL
6373: IFTRUE 6377
6375: GO 6392
6377: POP
// Say ( l_cmndr , DS-DC-dis ) ; 2 :
6378: LD_EXP 49
6382: PPUSH
6383: LD_STRING DS-DC-dis
6385: PPUSH
6386: CALL_OW 88
6390: GO 6487
6392: LD_INT 2
6394: DOUBLE
6395: EQUAL
6396: IFTRUE 6400
6398: GO 6486
6400: POP
// begin Say ( l_cmndr , DS-DC-acp ) ;
6401: LD_EXP 49
6405: PPUSH
6406: LD_STRING DS-DC-acp
6408: PPUSH
6409: CALL_OW 88
// for i = 1 to filter do
6413: LD_ADDR_VAR 0 2
6417: PUSH
6418: DOUBLE
6419: LD_INT 1
6421: DEC
6422: ST_TO_ADDR
6423: LD_VAR 0 3
6427: PUSH
6428: FOR_TO
6429: IFFALSE 6482
// begin SetSide ( filter [ i ] , 8 ) ;
6431: LD_VAR 0 3
6435: PUSH
6436: LD_VAR 0 2
6440: ARRAY
6441: PPUSH
6442: LD_INT 8
6444: PPUSH
6445: CALL_OW 235
// PlaceUnitArea ( filter [ i ] , south_spawn , false ) ;
6449: LD_VAR 0 3
6453: PUSH
6454: LD_VAR 0 2
6458: ARRAY
6459: PPUSH
6460: LD_INT 4
6462: PPUSH
6463: LD_INT 0
6465: PPUSH
6466: CALL_OW 49
// CenterNowOnXY ( 111 , 121 ) ;
6470: LD_INT 111
6472: PPUSH
6473: LD_INT 121
6475: PPUSH
6476: CALL_OW 86
// end ;
6480: GO 6428
6482: POP
6483: POP
// end ; end ;
6484: GO 6487
6486: POP
// DialogueOff ;
6487: CALL_OW 7
// end ; 101 :
6491: GO 6626
6493: LD_INT 101
6495: DOUBLE
6496: EQUAL
6497: IFTRUE 6501
6499: GO 6553
6501: POP
// begin CreateCratesArea ( Rand ( 3 , 5 ) , crates_area , true ) ;
6502: LD_INT 3
6504: PPUSH
6505: LD_INT 5
6507: PPUSH
6508: CALL_OW 12
6512: PPUSH
6513: LD_INT 9
6515: PPUSH
6516: LD_INT 1
6518: PPUSH
6519: CALL_OW 55
// Wait ( 0 0$11 ) ;
6523: LD_INT 385
6525: PPUSH
6526: CALL_OW 67
// CreateCratesArea ( Rand ( 3 , 5 ) , crates_area , true ) ;
6530: LD_INT 3
6532: PPUSH
6533: LD_INT 5
6535: PPUSH
6536: CALL_OW 12
6540: PPUSH
6541: LD_INT 9
6543: PPUSH
6544: LD_INT 1
6546: PPUSH
6547: CALL_OW 55
// end ; 200 :
6551: GO 6626
6553: LD_INT 200
6555: DOUBLE
6556: EQUAL
6557: IFTRUE 6561
6559: GO 6625
6561: POP
// begin Say ( Leopold , DS-end ) ;
6562: LD_EXP 7
6566: PPUSH
6567: LD_STRING DS-end
6569: PPUSH
6570: CALL_OW 88
// music_nat := 5 ;
6574: LD_ADDR_OWVAR 71
6578: PUSH
6579: LD_INT 5
6581: ST_TO_ADDR
// AddMedal ( dsmed1 , 1 ) ;
6582: LD_STRING dsmed1
6584: PPUSH
6585: LD_INT 1
6587: PPUSH
6588: CALL_OW 101
// AddMedal ( dsmed1 , 1 ) ;
6592: LD_STRING dsmed1
6594: PPUSH
6595: LD_INT 1
6597: PPUSH
6598: CALL_OW 101
// AddMedal ( dsmed1 , 1 ) ;
6602: LD_STRING dsmed1
6604: PPUSH
6605: LD_INT 1
6607: PPUSH
6608: CALL_OW 101
// GiveMedals ( MAIN ) ;
6612: LD_STRING MAIN
6614: PPUSH
6615: CALL_OW 102
// YouWin ;
6619: CALL_OW 103
// end ; end ;
6623: GO 6626
6625: POP
// end ;
6626: PPOPN 6
6628: END
// on UnitGoesToRed ( un ) do begin if un in FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] ] ) then
6629: LD_VAR 0 1
6633: PUSH
6634: LD_INT 22
6636: PUSH
6637: LD_INT 2
6639: PUSH
6640: EMPTY
6641: LIST
6642: LIST
6643: PUSH
6644: LD_INT 21
6646: PUSH
6647: LD_INT 2
6649: PUSH
6650: EMPTY
6651: LIST
6652: LIST
6653: PUSH
6654: EMPTY
6655: LIST
6656: LIST
6657: PPUSH
6658: CALL_OW 69
6662: IN
6663: IFFALSE 6788
// begin Wait ( Rand ( 0 0$03 , 0 0$06 ) ) ;
6665: LD_INT 105
6667: PPUSH
6668: LD_INT 210
6670: PPUSH
6671: CALL_OW 12
6675: PPUSH
6676: CALL_OW 67
// MineExplosion ( GetX ( un ) , GetY ( un ) , 3 ) ;
6680: LD_VAR 0 1
6684: PPUSH
6685: CALL_OW 250
6689: PPUSH
6690: LD_VAR 0 1
6694: PPUSH
6695: CALL_OW 251
6699: PPUSH
6700: LD_INT 3
6702: PPUSH
6703: CALL_OW 453
// MineExplosion ( GetX ( un ) , GetY ( un ) , 3 ) ;
6707: LD_VAR 0 1
6711: PPUSH
6712: CALL_OW 250
6716: PPUSH
6717: LD_VAR 0 1
6721: PPUSH
6722: CALL_OW 251
6726: PPUSH
6727: LD_INT 3
6729: PPUSH
6730: CALL_OW 453
// MineExplosion ( GetX ( un ) , GetY ( un ) , 3 ) ;
6734: LD_VAR 0 1
6738: PPUSH
6739: CALL_OW 250
6743: PPUSH
6744: LD_VAR 0 1
6748: PPUSH
6749: CALL_OW 251
6753: PPUSH
6754: LD_INT 3
6756: PPUSH
6757: CALL_OW 453
// MineExplosion ( GetX ( un ) , GetY ( un ) , 3 ) ;
6761: LD_VAR 0 1
6765: PPUSH
6766: CALL_OW 250
6770: PPUSH
6771: LD_VAR 0 1
6775: PPUSH
6776: CALL_OW 251
6780: PPUSH
6781: LD_INT 3
6783: PPUSH
6784: CALL_OW 453
// end ; end ;
6788: PPOPN 1
6790: END
// on UnitDestroyed ( un ) do begin if un = fort then
6791: LD_VAR 0 1
6795: PUSH
6796: LD_INT 23
6798: EQUAL
6799: IFFALSE 6809
// fort_destroyed := true ;
6801: LD_ADDR_EXP 32
6805: PUSH
6806: LD_INT 1
6808: ST_TO_ADDR
// if un = l_cmndr then
6809: LD_VAR 0 1
6813: PUSH
6814: LD_EXP 49
6818: EQUAL
6819: IFFALSE 6829
// hero_died := true ;
6821: LD_ADDR_EXP 33
6825: PUSH
6826: LD_INT 1
6828: ST_TO_ADDR
// end ;
6829: PPOPN 1
6831: END
// on UnitDestroyed_Extra ( un , killerSide , killerUnit ) do begin SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ;
6832: LD_VAR 0 1
6836: PPUSH
6837: LD_VAR 0 2
6841: PPUSH
6842: LD_VAR 0 3
6846: PPUSH
6847: CALL 8551 0 3
// end ;
6851: PPOPN 3
6853: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
6854: LD_VAR 0 1
6858: PPUSH
6859: CALL 8649 0 1
// end ; end_of_file
6863: PPOPN 1
6865: END
// export function RefreshTime ( time , bool ) ; begin
6866: LD_INT 0
6868: PPUSH
// if bool then
6869: LD_VAR 0 2
6873: IFFALSE 6891
// time := time + 0 0$01 else
6875: LD_ADDR_VAR 0 1
6879: PUSH
6880: LD_VAR 0 1
6884: PUSH
6885: LD_INT 35
6887: PLUS
6888: ST_TO_ADDR
6889: GO 6905
// time := time - 0 0$01 ;
6891: LD_ADDR_VAR 0 1
6895: PUSH
6896: LD_VAR 0 1
6900: PUSH
6901: LD_INT 35
6903: MINUS
6904: ST_TO_ADDR
// result := time ;
6905: LD_ADDR_VAR 0 3
6909: PUSH
6910: LD_VAR 0 1
6914: ST_TO_ADDR
// end ;
6915: LD_VAR 0 3
6919: RET
// export function MineExist ( side ) ; begin
6920: LD_INT 0
6922: PPUSH
// if FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_siberite_mine ] ] ) > 0 then
6923: LD_INT 22
6925: PUSH
6926: LD_VAR 0 1
6930: PUSH
6931: EMPTY
6932: LIST
6933: LIST
6934: PUSH
6935: LD_INT 30
6937: PUSH
6938: LD_INT 30
6940: PUSH
6941: EMPTY
6942: LIST
6943: LIST
6944: PUSH
6945: EMPTY
6946: LIST
6947: LIST
6948: PPUSH
6949: CALL_OW 69
6953: PUSH
6954: LD_INT 0
6956: GREATER
6957: IFFALSE 6969
// result := true else
6959: LD_ADDR_VAR 0 2
6963: PUSH
6964: LD_INT 1
6966: ST_TO_ADDR
6967: GO 6977
// result := false ;
6969: LD_ADDR_VAR 0 2
6973: PUSH
6974: LD_INT 0
6976: ST_TO_ADDR
// end ;
6977: LD_VAR 0 2
6981: RET
// export function FacExist ( side ) ; begin
6982: LD_INT 0
6984: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_factory ] ] ) > 0 ;
6985: LD_ADDR_VAR 0 2
6989: PUSH
6990: LD_INT 22
6992: PUSH
6993: LD_VAR 0 1
6997: PUSH
6998: EMPTY
6999: LIST
7000: LIST
7001: PUSH
7002: LD_INT 30
7004: PUSH
7005: LD_INT 3
7007: PUSH
7008: EMPTY
7009: LIST
7010: LIST
7011: PUSH
7012: EMPTY
7013: LIST
7014: LIST
7015: PPUSH
7016: CALL_OW 69
7020: PUSH
7021: LD_INT 0
7023: GREATER
7024: ST_TO_ADDR
// end ;
7025: LD_VAR 0 2
7029: RET
// export function ConnectWithTower ( side ) ; var i , filter , tower ; begin
7030: LD_INT 0
7032: PPUSH
7033: PPUSH
7034: PPUSH
7035: PPUSH
// filter := FilterAllUnits ( [ [ f_side , side ] , [ f_control , control_remote ] , [ f_ok ] ] ) ;
7036: LD_ADDR_VAR 0 4
7040: PUSH
7041: LD_INT 22
7043: PUSH
7044: LD_VAR 0 1
7048: PUSH
7049: EMPTY
7050: LIST
7051: LIST
7052: PUSH
7053: LD_INT 33
7055: PUSH
7056: LD_INT 2
7058: PUSH
7059: EMPTY
7060: LIST
7061: LIST
7062: PUSH
7063: LD_INT 50
7065: PUSH
7066: EMPTY
7067: LIST
7068: PUSH
7069: EMPTY
7070: LIST
7071: LIST
7072: LIST
7073: PPUSH
7074: CALL_OW 69
7078: ST_TO_ADDR
// tower := FilterAllUnits ( [ [ f_side , side ] , [ f_weapon , ar_control_tower ] ] ) ;
7079: LD_ADDR_VAR 0 5
7083: PUSH
7084: LD_INT 22
7086: PUSH
7087: LD_VAR 0 1
7091: PUSH
7092: EMPTY
7093: LIST
7094: LIST
7095: PUSH
7096: LD_INT 34
7098: PUSH
7099: LD_INT 31
7101: PUSH
7102: EMPTY
7103: LIST
7104: LIST
7105: PUSH
7106: EMPTY
7107: LIST
7108: LIST
7109: PPUSH
7110: CALL_OW 69
7114: ST_TO_ADDR
// if tower > 0 and filter > 0 then
7115: LD_VAR 0 5
7119: PUSH
7120: LD_INT 0
7122: GREATER
7123: PUSH
7124: LD_VAR 0 4
7128: PUSH
7129: LD_INT 0
7131: GREATER
7132: AND
7133: IFFALSE 7209
// for i = 1 to filter do
7135: LD_ADDR_VAR 0 3
7139: PUSH
7140: DOUBLE
7141: LD_INT 1
7143: DEC
7144: ST_TO_ADDR
7145: LD_VAR 0 4
7149: PUSH
7150: FOR_TO
7151: IFFALSE 7207
// if not IsControledBy ( filter [ i ] ) then
7153: LD_VAR 0 4
7157: PUSH
7158: LD_VAR 0 3
7162: ARRAY
7163: PPUSH
7164: CALL_OW 312
7168: NOT
7169: IFFALSE 7205
// ComLinkTo ( filter [ i ] , tower [ Rand ( 1 , tower ) ] ) ;
7171: LD_VAR 0 4
7175: PUSH
7176: LD_VAR 0 3
7180: ARRAY
7181: PPUSH
7182: LD_VAR 0 5
7186: PUSH
7187: LD_INT 1
7189: PPUSH
7190: LD_VAR 0 5
7194: PPUSH
7195: CALL_OW 12
7199: ARRAY
7200: PPUSH
7201: CALL_OW 135
7205: GO 7150
7207: POP
7208: POP
// end ;
7209: LD_VAR 0 2
7213: RET
// export function CreateHumanWithClass ( clas , lvl ) ; var skill_com , skill_eng , skill_mech , skill_sci , bonus ; begin
7214: LD_INT 0
7216: PPUSH
7217: PPUSH
7218: PPUSH
7219: PPUSH
7220: PPUSH
7221: PPUSH
// hc_class := clas ;
7222: LD_ADDR_OWVAR 28
7226: PUSH
7227: LD_VAR 0 1
7231: ST_TO_ADDR
// skill_com := ( lvl + Rand ( - 1 , 1 ) ) ;
7232: LD_ADDR_VAR 0 4
7236: PUSH
7237: LD_VAR 0 2
7241: PUSH
7242: LD_INT 1
7244: NEG
7245: PPUSH
7246: LD_INT 1
7248: PPUSH
7249: CALL_OW 12
7253: PLUS
7254: ST_TO_ADDR
// skill_eng := ( lvl + Rand ( - 1 , 1 ) ) ;
7255: LD_ADDR_VAR 0 5
7259: PUSH
7260: LD_VAR 0 2
7264: PUSH
7265: LD_INT 1
7267: NEG
7268: PPUSH
7269: LD_INT 1
7271: PPUSH
7272: CALL_OW 12
7276: PLUS
7277: ST_TO_ADDR
// skill_mech := ( lvl + Rand ( - 1 , 1 ) ) ;
7278: LD_ADDR_VAR 0 6
7282: PUSH
7283: LD_VAR 0 2
7287: PUSH
7288: LD_INT 1
7290: NEG
7291: PPUSH
7292: LD_INT 1
7294: PPUSH
7295: CALL_OW 12
7299: PLUS
7300: ST_TO_ADDR
// skill_sci := ( lvl + Rand ( - 1 , 1 ) ) ;
7301: LD_ADDR_VAR 0 7
7305: PUSH
7306: LD_VAR 0 2
7310: PUSH
7311: LD_INT 1
7313: NEG
7314: PPUSH
7315: LD_INT 1
7317: PPUSH
7318: CALL_OW 12
7322: PLUS
7323: ST_TO_ADDR
// if clas = 1 or clas = 9 or clas = class_sniper or clas = class_mortar then
7324: LD_VAR 0 1
7328: PUSH
7329: LD_INT 1
7331: EQUAL
7332: PUSH
7333: LD_VAR 0 1
7337: PUSH
7338: LD_INT 9
7340: EQUAL
7341: OR
7342: PUSH
7343: LD_VAR 0 1
7347: PUSH
7348: LD_INT 5
7350: EQUAL
7351: OR
7352: PUSH
7353: LD_VAR 0 1
7357: PUSH
7358: LD_INT 8
7360: EQUAL
7361: OR
7362: IFFALSE 7387
// bonus := [ 2 , 0 , 0 , 0 ] ;
7364: LD_ADDR_VAR 0 8
7368: PUSH
7369: LD_INT 2
7371: PUSH
7372: LD_INT 0
7374: PUSH
7375: LD_INT 0
7377: PUSH
7378: LD_INT 0
7380: PUSH
7381: EMPTY
7382: LIST
7383: LIST
7384: LIST
7385: LIST
7386: ST_TO_ADDR
// if clas = 2 then
7387: LD_VAR 0 1
7391: PUSH
7392: LD_INT 2
7394: EQUAL
7395: IFFALSE 7420
// bonus := [ 0 , 2 , 0 , 0 ] ;
7397: LD_ADDR_VAR 0 8
7401: PUSH
7402: LD_INT 0
7404: PUSH
7405: LD_INT 2
7407: PUSH
7408: LD_INT 0
7410: PUSH
7411: LD_INT 0
7413: PUSH
7414: EMPTY
7415: LIST
7416: LIST
7417: LIST
7418: LIST
7419: ST_TO_ADDR
// if clas = 3 then
7420: LD_VAR 0 1
7424: PUSH
7425: LD_INT 3
7427: EQUAL
7428: IFFALSE 7453
// bonus := [ 0 , 0 , 2 , 0 ] ;
7430: LD_ADDR_VAR 0 8
7434: PUSH
7435: LD_INT 0
7437: PUSH
7438: LD_INT 0
7440: PUSH
7441: LD_INT 2
7443: PUSH
7444: LD_INT 0
7446: PUSH
7447: EMPTY
7448: LIST
7449: LIST
7450: LIST
7451: LIST
7452: ST_TO_ADDR
// if clas = 4 then
7453: LD_VAR 0 1
7457: PUSH
7458: LD_INT 4
7460: EQUAL
7461: IFFALSE 7486
// bonus := [ 0 , 0 , 0 , 2 ] ;
7463: LD_ADDR_VAR 0 8
7467: PUSH
7468: LD_INT 0
7470: PUSH
7471: LD_INT 0
7473: PUSH
7474: LD_INT 0
7476: PUSH
7477: LD_INT 2
7479: PUSH
7480: EMPTY
7481: LIST
7482: LIST
7483: LIST
7484: LIST
7485: ST_TO_ADDR
// if clas > 4 and clas <> 9 and clas <> class_sniper and clas <> class_mortar then
7486: LD_VAR 0 1
7490: PUSH
7491: LD_INT 4
7493: GREATER
7494: PUSH
7495: LD_VAR 0 1
7499: PUSH
7500: LD_INT 9
7502: NONEQUAL
7503: AND
7504: PUSH
7505: LD_VAR 0 1
7509: PUSH
7510: LD_INT 5
7512: NONEQUAL
7513: AND
7514: PUSH
7515: LD_VAR 0 1
7519: PUSH
7520: LD_INT 8
7522: NONEQUAL
7523: AND
7524: IFFALSE 7549
// bonus := [ 0 , 0 , 0 , 0 ] ;
7526: LD_ADDR_VAR 0 8
7530: PUSH
7531: LD_INT 0
7533: PUSH
7534: LD_INT 0
7536: PUSH
7537: LD_INT 0
7539: PUSH
7540: LD_INT 0
7542: PUSH
7543: EMPTY
7544: LIST
7545: LIST
7546: LIST
7547: LIST
7548: ST_TO_ADDR
// hc_basic_skills := [ Rand ( 0 , 2 ) , Rand ( 0 , 2 ) , Rand ( 0 , 2 ) , Rand ( 0 , 2 ) ] ;
7549: LD_ADDR_OWVAR 30
7553: PUSH
7554: LD_INT 0
7556: PPUSH
7557: LD_INT 2
7559: PPUSH
7560: CALL_OW 12
7564: PUSH
7565: LD_INT 0
7567: PPUSH
7568: LD_INT 2
7570: PPUSH
7571: CALL_OW 12
7575: PUSH
7576: LD_INT 0
7578: PPUSH
7579: LD_INT 2
7581: PPUSH
7582: CALL_OW 12
7586: PUSH
7587: LD_INT 0
7589: PPUSH
7590: LD_INT 2
7592: PPUSH
7593: CALL_OW 12
7597: PUSH
7598: EMPTY
7599: LIST
7600: LIST
7601: LIST
7602: LIST
7603: ST_TO_ADDR
// hc_skills := [ skill_com + bonus [ 1 ] , skill_eng + bonus [ 2 ] , skill_mech + bonus [ 3 ] , skill_sci + bonus [ 4 ] ] ;
7604: LD_ADDR_OWVAR 31
7608: PUSH
7609: LD_VAR 0 4
7613: PUSH
7614: LD_VAR 0 8
7618: PUSH
7619: LD_INT 1
7621: ARRAY
7622: PLUS
7623: PUSH
7624: LD_VAR 0 5
7628: PUSH
7629: LD_VAR 0 8
7633: PUSH
7634: LD_INT 2
7636: ARRAY
7637: PLUS
7638: PUSH
7639: LD_VAR 0 6
7643: PUSH
7644: LD_VAR 0 8
7648: PUSH
7649: LD_INT 3
7651: ARRAY
7652: PLUS
7653: PUSH
7654: LD_VAR 0 7
7658: PUSH
7659: LD_VAR 0 8
7663: PUSH
7664: LD_INT 4
7666: ARRAY
7667: PLUS
7668: PUSH
7669: EMPTY
7670: LIST
7671: LIST
7672: LIST
7673: LIST
7674: ST_TO_ADDR
// hc_sex := Rand ( sex_male , sex_female ) ;
7675: LD_ADDR_OWVAR 27
7679: PUSH
7680: LD_INT 1
7682: PPUSH
7683: LD_INT 2
7685: PPUSH
7686: CALL_OW 12
7690: ST_TO_ADDR
// hc_gallery :=  ;
7691: LD_ADDR_OWVAR 33
7695: PUSH
7696: LD_STRING 
7698: ST_TO_ADDR
// hc_attr := [ Rand ( 8 , 12 ) , Rand ( 9 , 11 ) ] ;
7699: LD_ADDR_OWVAR 29
7703: PUSH
7704: LD_INT 8
7706: PPUSH
7707: LD_INT 12
7709: PPUSH
7710: CALL_OW 12
7714: PUSH
7715: LD_INT 9
7717: PPUSH
7718: LD_INT 11
7720: PPUSH
7721: CALL_OW 12
7725: PUSH
7726: EMPTY
7727: LIST
7728: LIST
7729: ST_TO_ADDR
// hc_name :=  ;
7730: LD_ADDR_OWVAR 26
7734: PUSH
7735: LD_STRING 
7737: ST_TO_ADDR
// result := CreateHuman ;
7738: LD_ADDR_VAR 0 3
7742: PUSH
7743: CALL_OW 44
7747: ST_TO_ADDR
// end ;
7748: LD_VAR 0 3
7752: RET
// export function GetSpeed ( unit ) ; begin
7753: LD_INT 0
7755: PPUSH
// result := GetProperties ( unit ) [ 1 ] ;
7756: LD_ADDR_VAR 0 2
7760: PUSH
7761: LD_VAR 0 1
7765: PPUSH
7766: CALL_OW 464
7770: PUSH
7771: LD_INT 1
7773: ARRAY
7774: ST_TO_ADDR
// end ;
7775: LD_VAR 0 2
7779: RET
// export function PrepareNature ( area , num1 , num2 , num3 , num4 ) ; var l , apeman , tiger , bird , horse ; begin
7780: LD_INT 0
7782: PPUSH
7783: PPUSH
7784: PPUSH
7785: PPUSH
7786: PPUSH
7787: PPUSH
// uc_nation = nation_nature ;
7788: LD_ADDR_OWVAR 21
7792: PUSH
7793: LD_INT 0
7795: ST_TO_ADDR
// uc_side = 0 ;
7796: LD_ADDR_OWVAR 20
7800: PUSH
7801: LD_INT 0
7803: ST_TO_ADDR
// l = 0 ;
7804: LD_ADDR_VAR 0 7
7808: PUSH
7809: LD_INT 0
7811: ST_TO_ADDR
// repeat begin uc_direction = Rand ( 0 , 5 ) ;
7812: LD_ADDR_OWVAR 24
7816: PUSH
7817: LD_INT 0
7819: PPUSH
7820: LD_INT 5
7822: PPUSH
7823: CALL_OW 12
7827: ST_TO_ADDR
// hc_agressivity = Rand ( - 5 , 0 ) ;
7828: LD_ADDR_OWVAR 35
7832: PUSH
7833: LD_INT 5
7835: NEG
7836: PPUSH
7837: LD_INT 0
7839: PPUSH
7840: CALL_OW 12
7844: ST_TO_ADDR
// hc_gallery =  ;
7845: LD_ADDR_OWVAR 33
7849: PUSH
7850: LD_STRING 
7852: ST_TO_ADDR
// hc_class = class_apeman ;
7853: LD_ADDR_OWVAR 28
7857: PUSH
7858: LD_INT 12
7860: ST_TO_ADDR
// hc_attr = [ Rand ( 11 , 13 ) , Rand ( 10 , 11 ) ] ;
7861: LD_ADDR_OWVAR 29
7865: PUSH
7866: LD_INT 11
7868: PPUSH
7869: LD_INT 13
7871: PPUSH
7872: CALL_OW 12
7876: PUSH
7877: LD_INT 10
7879: PPUSH
7880: LD_INT 11
7882: PPUSH
7883: CALL_OW 12
7887: PUSH
7888: EMPTY
7889: LIST
7890: LIST
7891: ST_TO_ADDR
// hc_sex = sex_male ;
7892: LD_ADDR_OWVAR 27
7896: PUSH
7897: LD_INT 1
7899: ST_TO_ADDR
// hc_skills = [ Rand ( 0 , 2 ) , 0 , 0 , 0 ] ;
7900: LD_ADDR_OWVAR 31
7904: PUSH
7905: LD_INT 0
7907: PPUSH
7908: LD_INT 2
7910: PPUSH
7911: CALL_OW 12
7915: PUSH
7916: LD_INT 0
7918: PUSH
7919: LD_INT 0
7921: PUSH
7922: LD_INT 0
7924: PUSH
7925: EMPTY
7926: LIST
7927: LIST
7928: LIST
7929: LIST
7930: ST_TO_ADDR
// apeman = CreateHuman ;
7931: LD_ADDR_VAR 0 8
7935: PUSH
7936: CALL_OW 44
7940: ST_TO_ADDR
// PlaceUnitArea ( apeman , area , false ) ;
7941: LD_VAR 0 8
7945: PPUSH
7946: LD_VAR 0 1
7950: PPUSH
7951: LD_INT 0
7953: PPUSH
7954: CALL_OW 49
// l = l + 1 ;
7958: LD_ADDR_VAR 0 7
7962: PUSH
7963: LD_VAR 0 7
7967: PUSH
7968: LD_INT 1
7970: PLUS
7971: ST_TO_ADDR
// end until l = num1 ;
7972: LD_VAR 0 7
7976: PUSH
7977: LD_VAR 0 2
7981: EQUAL
7982: IFFALSE 7812
// l = 0 ;
7984: LD_ADDR_VAR 0 7
7988: PUSH
7989: LD_INT 0
7991: ST_TO_ADDR
// repeat begin hc_agressivity = Rand ( 0 , 25 ) ;
7992: LD_ADDR_OWVAR 35
7996: PUSH
7997: LD_INT 0
7999: PPUSH
8000: LD_INT 25
8002: PPUSH
8003: CALL_OW 12
8007: ST_TO_ADDR
// hc_class = class_tiger ;
8008: LD_ADDR_OWVAR 28
8012: PUSH
8013: LD_INT 14
8015: ST_TO_ADDR
// hc_sex = sex_male ;
8016: LD_ADDR_OWVAR 27
8020: PUSH
8021: LD_INT 1
8023: ST_TO_ADDR
// hc_gallery = sandnature ;
8024: LD_ADDR_OWVAR 33
8028: PUSH
8029: LD_STRING sandnature
8031: ST_TO_ADDR
// hc_face_number = 3 ;
8032: LD_ADDR_OWVAR 34
8036: PUSH
8037: LD_INT 3
8039: ST_TO_ADDR
// tiger = CreateHuman ;
8040: LD_ADDR_VAR 0 9
8044: PUSH
8045: CALL_OW 44
8049: ST_TO_ADDR
// PlaceUnitArea ( tiger , area , false ) ;
8050: LD_VAR 0 9
8054: PPUSH
8055: LD_VAR 0 1
8059: PPUSH
8060: LD_INT 0
8062: PPUSH
8063: CALL_OW 49
// l = l + 1 ;
8067: LD_ADDR_VAR 0 7
8071: PUSH
8072: LD_VAR 0 7
8076: PUSH
8077: LD_INT 1
8079: PLUS
8080: ST_TO_ADDR
// end until l = num2 ;
8081: LD_VAR 0 7
8085: PUSH
8086: LD_VAR 0 3
8090: EQUAL
8091: IFFALSE 7992
// l = 0 ;
8093: LD_ADDR_VAR 0 7
8097: PUSH
8098: LD_INT 0
8100: ST_TO_ADDR
// repeat begin hc_class = class_phororhacos ;
8101: LD_ADDR_OWVAR 28
8105: PUSH
8106: LD_INT 18
8108: ST_TO_ADDR
// hc_gallery = sandnature ;
8109: LD_ADDR_OWVAR 33
8113: PUSH
8114: LD_STRING sandnature
8116: ST_TO_ADDR
// hc_face_number = 1 ;
8117: LD_ADDR_OWVAR 34
8121: PUSH
8122: LD_INT 1
8124: ST_TO_ADDR
// bird = CreateHuman ;
8125: LD_ADDR_VAR 0 10
8129: PUSH
8130: CALL_OW 44
8134: ST_TO_ADDR
// PlaceUnitAnywhere ( bird , false ) ;
8135: LD_VAR 0 10
8139: PPUSH
8140: LD_INT 0
8142: PPUSH
8143: CALL_OW 51
// l = l + 1 ;
8147: LD_ADDR_VAR 0 7
8151: PUSH
8152: LD_VAR 0 7
8156: PUSH
8157: LD_INT 1
8159: PLUS
8160: ST_TO_ADDR
// end until l = num3 ;
8161: LD_VAR 0 7
8165: PUSH
8166: LD_VAR 0 4
8170: EQUAL
8171: IFFALSE 8101
// l = 0 ;
8173: LD_ADDR_VAR 0 7
8177: PUSH
8178: LD_INT 0
8180: ST_TO_ADDR
// repeat begin hc_class = 21 ;
8181: LD_ADDR_OWVAR 28
8185: PUSH
8186: LD_INT 21
8188: ST_TO_ADDR
// hc_gallery = sandnature ;
8189: LD_ADDR_OWVAR 33
8193: PUSH
8194: LD_STRING sandnature
8196: ST_TO_ADDR
// hc_face_number = 5 ;
8197: LD_ADDR_OWVAR 34
8201: PUSH
8202: LD_INT 5
8204: ST_TO_ADDR
// horse := CreateHuman ;
8205: LD_ADDR_VAR 0 11
8209: PUSH
8210: CALL_OW 44
8214: ST_TO_ADDR
// PlaceUnitArea ( horse , area , false ) ;
8215: LD_VAR 0 11
8219: PPUSH
8220: LD_VAR 0 1
8224: PPUSH
8225: LD_INT 0
8227: PPUSH
8228: CALL_OW 49
// l = l + 1 ;
8232: LD_ADDR_VAR 0 7
8236: PUSH
8237: LD_VAR 0 7
8241: PUSH
8242: LD_INT 1
8244: PLUS
8245: ST_TO_ADDR
// end until l = num4 ;
8246: LD_VAR 0 7
8250: PUSH
8251: LD_VAR 0 5
8255: EQUAL
8256: IFFALSE 8181
// end ;
8258: LD_VAR 0 6
8262: RET
// export function PrepareComm ; begin
8263: LD_INT 0
8265: PPUSH
// uc_side := 1 ;
8266: LD_ADDR_OWVAR 20
8270: PUSH
8271: LD_INT 1
8273: ST_TO_ADDR
// uc_nation := 1 ;
8274: LD_ADDR_OWVAR 21
8278: PUSH
8279: LD_INT 1
8281: ST_TO_ADDR
// hc_gallery :=  ;
8282: LD_ADDR_OWVAR 33
8286: PUSH
8287: LD_STRING 
8289: ST_TO_ADDR
// hc_name :=  ;
8290: LD_ADDR_OWVAR 26
8294: PUSH
8295: LD_STRING 
8297: ST_TO_ADDR
// hc_class := 1 ;
8298: LD_ADDR_OWVAR 28
8302: PUSH
8303: LD_INT 1
8305: ST_TO_ADDR
// hc_sex := sex_male ;
8306: LD_ADDR_OWVAR 27
8310: PUSH
8311: LD_INT 1
8313: ST_TO_ADDR
// am_comander := CreateHuman ;
8314: LD_ADDR_EXP 46
8318: PUSH
8319: CALL_OW 44
8323: ST_TO_ADDR
// uc_side := 3 ;
8324: LD_ADDR_OWVAR 20
8328: PUSH
8329: LD_INT 3
8331: ST_TO_ADDR
// uc_nation := 3 ;
8332: LD_ADDR_OWVAR 21
8336: PUSH
8337: LD_INT 3
8339: ST_TO_ADDR
// ru_comander := CreateHuman ;
8340: LD_ADDR_EXP 47
8344: PUSH
8345: CALL_OW 44
8349: ST_TO_ADDR
// uc_side := 2 ;
8350: LD_ADDR_OWVAR 20
8354: PUSH
8355: LD_INT 2
8357: ST_TO_ADDR
// uc_nation := 2 ;
8358: LD_ADDR_OWVAR 21
8362: PUSH
8363: LD_INT 2
8365: ST_TO_ADDR
// hc_name := Heike Steyer ;
8366: LD_ADDR_OWVAR 26
8370: PUSH
8371: LD_STRING Heike Steyer
8373: ST_TO_ADDR
// hc_sex := sex_female ;
8374: LD_ADDR_OWVAR 27
8378: PUSH
8379: LD_INT 2
8381: ST_TO_ADDR
// hc_gallery := sandar ;
8382: LD_ADDR_OWVAR 33
8386: PUSH
8387: LD_STRING sandar
8389: ST_TO_ADDR
// hc_face_number := 14 ;
8390: LD_ADDR_OWVAR 34
8394: PUSH
8395: LD_INT 14
8397: ST_TO_ADDR
// ar_comander := CreateHuman ;
8398: LD_ADDR_EXP 48
8402: PUSH
8403: CALL_OW 44
8407: ST_TO_ADDR
// end ;
8408: LD_VAR 0 1
8412: RET
// export function SpeedFilter ( filter , speed ) ; var list , i ; begin
8413: LD_INT 0
8415: PPUSH
8416: PPUSH
8417: PPUSH
// list := [ ] ;
8418: LD_ADDR_VAR 0 4
8422: PUSH
8423: EMPTY
8424: ST_TO_ADDR
// for i = 1 to filter do
8425: LD_ADDR_VAR 0 5
8429: PUSH
8430: DOUBLE
8431: LD_INT 1
8433: DEC
8434: ST_TO_ADDR
8435: LD_VAR 0 1
8439: PUSH
8440: FOR_TO
8441: IFFALSE 8490
// if GetSpeed ( filter [ i ] ) < speed then
8443: LD_VAR 0 1
8447: PUSH
8448: LD_VAR 0 5
8452: ARRAY
8453: PPUSH
8454: CALL 7753 0 1
8458: PUSH
8459: LD_VAR 0 2
8463: LESS
8464: IFFALSE 8488
// list := list ^ filter [ i ] ;
8466: LD_ADDR_VAR 0 4
8470: PUSH
8471: LD_VAR 0 4
8475: PUSH
8476: LD_VAR 0 1
8480: PUSH
8481: LD_VAR 0 5
8485: ARRAY
8486: ADD
8487: ST_TO_ADDR
8488: GO 8440
8490: POP
8491: POP
// result := list ;
8492: LD_ADDR_VAR 0 3
8496: PUSH
8497: LD_VAR 0 4
8501: ST_TO_ADDR
// end ; end_of_file
8502: LD_VAR 0 3
8506: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; every 1 do
8507: GO 8509
8509: DISABLE
// begin ru_radar := 98 ;
8510: LD_ADDR_EXP 52
8514: PUSH
8515: LD_INT 98
8517: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
8518: LD_ADDR_EXP 53
8522: PUSH
8523: LD_INT 89
8525: ST_TO_ADDR
// us_hack := 99 ;
8526: LD_ADDR_EXP 54
8530: PUSH
8531: LD_INT 99
8533: ST_TO_ADDR
// us_artillery := 97 ;
8534: LD_ADDR_EXP 55
8538: PUSH
8539: LD_INT 97
8541: ST_TO_ADDR
// ar_bio_bomb := 91 ;
8542: LD_ADDR_EXP 56
8546: PUSH
8547: LD_INT 91
8549: ST_TO_ADDR
// end ; end_of_file end_of_file end_of_file
8550: END
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; var i , eff , side ; begin
8551: LD_INT 0
8553: PPUSH
8554: PPUSH
8555: PPUSH
8556: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
8557: LD_VAR 0 1
8561: PPUSH
8562: CALL_OW 264
8566: PUSH
8567: LD_EXP 56
8571: EQUAL
8572: IFFALSE 8644
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
8574: LD_INT 68
8576: PPUSH
8577: LD_VAR 0 1
8581: PPUSH
8582: CALL_OW 255
8586: PPUSH
8587: CALL_OW 321
8591: PUSH
8592: LD_INT 2
8594: EQUAL
8595: IFFALSE 8607
// eff := 70 else
8597: LD_ADDR_VAR 0 6
8601: PUSH
8602: LD_INT 70
8604: ST_TO_ADDR
8605: GO 8615
// eff := 30 ;
8607: LD_ADDR_VAR 0 6
8611: PUSH
8612: LD_INT 30
8614: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
8615: LD_VAR 0 1
8619: PPUSH
8620: CALL_OW 250
8624: PPUSH
8625: LD_VAR 0 1
8629: PPUSH
8630: CALL_OW 251
8634: PPUSH
8635: LD_VAR 0 6
8639: PPUSH
8640: CALL_OW 495
// end ; end ;
8644: LD_VAR 0 4
8648: RET
// export function SOS_Command ( cmd ) ; var i , j , tmp , taskList , _taskList ; begin
8649: LD_INT 0
8651: PPUSH
8652: PPUSH
8653: PPUSH
8654: PPUSH
8655: PPUSH
8656: PPUSH
// if cmd = 124 then
8657: LD_VAR 0 1
8661: PUSH
8662: LD_INT 124
8664: EQUAL
8665: IFFALSE 8871
// begin tmp := FilterAllUnits ( [ f_or , [ f_weapon , ru_bulldozer ] , [ f_weapon , us_bulldozer ] ] ) ;
8667: LD_ADDR_VAR 0 5
8671: PUSH
8672: LD_INT 2
8674: PUSH
8675: LD_INT 34
8677: PUSH
8678: LD_INT 53
8680: PUSH
8681: EMPTY
8682: LIST
8683: LIST
8684: PUSH
8685: LD_INT 34
8687: PUSH
8688: LD_INT 14
8690: PUSH
8691: EMPTY
8692: LIST
8693: LIST
8694: PUSH
8695: EMPTY
8696: LIST
8697: LIST
8698: LIST
8699: PPUSH
8700: CALL_OW 69
8704: ST_TO_ADDR
// if not tmp then
8705: LD_VAR 0 5
8709: NOT
8710: IFFALSE 8714
// exit ;
8712: GO 8871
// for i in tmp do
8714: LD_ADDR_VAR 0 3
8718: PUSH
8719: LD_VAR 0 5
8723: PUSH
8724: FOR_IN
8725: IFFALSE 8869
// begin taskList := GetTaskList ( i ) ;
8727: LD_ADDR_VAR 0 6
8731: PUSH
8732: LD_VAR 0 3
8736: PPUSH
8737: CALL_OW 437
8741: ST_TO_ADDR
// if not taskList then
8742: LD_VAR 0 6
8746: NOT
8747: IFFALSE 8751
// continue ;
8749: GO 8724
// for j = 1 to taskList do
8751: LD_ADDR_VAR 0 4
8755: PUSH
8756: DOUBLE
8757: LD_INT 1
8759: DEC
8760: ST_TO_ADDR
8761: LD_VAR 0 6
8765: PUSH
8766: FOR_TO
8767: IFFALSE 8865
// if taskList [ j ] [ 1 ] = | then
8769: LD_VAR 0 6
8773: PUSH
8774: LD_VAR 0 4
8778: ARRAY
8779: PUSH
8780: LD_INT 1
8782: ARRAY
8783: PUSH
8784: LD_STRING |
8786: EQUAL
8787: IFFALSE 8863
// begin _taskList := Delete ( taskList , 1 ) ;
8789: LD_ADDR_VAR 0 7
8793: PUSH
8794: LD_VAR 0 6
8798: PPUSH
8799: LD_INT 1
8801: PPUSH
8802: CALL_OW 3
8806: ST_TO_ADDR
// SetTaskList ( i , _taskList ) ;
8807: LD_VAR 0 3
8811: PPUSH
8812: LD_VAR 0 7
8816: PPUSH
8817: CALL_OW 446
// CutTreeXYR ( i , taskList [ j ] [ 2 ] , taskList [ j ] [ 3 ] , 8 ) ;
8821: LD_VAR 0 3
8825: PPUSH
8826: LD_VAR 0 6
8830: PUSH
8831: LD_VAR 0 4
8835: ARRAY
8836: PUSH
8837: LD_INT 2
8839: ARRAY
8840: PPUSH
8841: LD_VAR 0 6
8845: PUSH
8846: LD_VAR 0 4
8850: ARRAY
8851: PUSH
8852: LD_INT 3
8854: ARRAY
8855: PPUSH
8856: LD_INT 8
8858: PPUSH
8859: CALL 8876 0 4
// end ;
8863: GO 8766
8865: POP
8866: POP
// end ;
8867: GO 8724
8869: POP
8870: POP
// end ; end ;
8871: LD_VAR 0 2
8875: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
8876: LD_INT 0
8878: PPUSH
8879: PPUSH
8880: PPUSH
8881: PPUSH
8882: PPUSH
8883: PPUSH
8884: PPUSH
8885: PPUSH
8886: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
8887: LD_VAR 0 1
8891: NOT
8892: PUSH
8893: LD_VAR 0 2
8897: PPUSH
8898: LD_VAR 0 3
8902: PPUSH
8903: CALL_OW 488
8907: NOT
8908: OR
8909: PUSH
8910: LD_VAR 0 4
8914: NOT
8915: OR
8916: IFFALSE 8920
// exit ;
8918: GO 9260
// list := [ ] ;
8920: LD_ADDR_VAR 0 13
8924: PUSH
8925: EMPTY
8926: ST_TO_ADDR
// if x - r < 0 then
8927: LD_VAR 0 2
8931: PUSH
8932: LD_VAR 0 4
8936: MINUS
8937: PUSH
8938: LD_INT 0
8940: LESS
8941: IFFALSE 8953
// min_x := 0 else
8943: LD_ADDR_VAR 0 7
8947: PUSH
8948: LD_INT 0
8950: ST_TO_ADDR
8951: GO 8969
// min_x := x - r ;
8953: LD_ADDR_VAR 0 7
8957: PUSH
8958: LD_VAR 0 2
8962: PUSH
8963: LD_VAR 0 4
8967: MINUS
8968: ST_TO_ADDR
// if y - r < 0 then
8969: LD_VAR 0 3
8973: PUSH
8974: LD_VAR 0 4
8978: MINUS
8979: PUSH
8980: LD_INT 0
8982: LESS
8983: IFFALSE 8995
// min_y := 0 else
8985: LD_ADDR_VAR 0 8
8989: PUSH
8990: LD_INT 0
8992: ST_TO_ADDR
8993: GO 9011
// min_y := y - r ;
8995: LD_ADDR_VAR 0 8
8999: PUSH
9000: LD_VAR 0 3
9004: PUSH
9005: LD_VAR 0 4
9009: MINUS
9010: ST_TO_ADDR
// max_x := x + r ;
9011: LD_ADDR_VAR 0 9
9015: PUSH
9016: LD_VAR 0 2
9020: PUSH
9021: LD_VAR 0 4
9025: PLUS
9026: ST_TO_ADDR
// max_y := y + r ;
9027: LD_ADDR_VAR 0 10
9031: PUSH
9032: LD_VAR 0 3
9036: PUSH
9037: LD_VAR 0 4
9041: PLUS
9042: ST_TO_ADDR
// for _x = min_x to max_x do
9043: LD_ADDR_VAR 0 11
9047: PUSH
9048: DOUBLE
9049: LD_VAR 0 7
9053: DEC
9054: ST_TO_ADDR
9055: LD_VAR 0 9
9059: PUSH
9060: FOR_TO
9061: IFFALSE 9178
// for _y = min_y to max_y do
9063: LD_ADDR_VAR 0 12
9067: PUSH
9068: DOUBLE
9069: LD_VAR 0 8
9073: DEC
9074: ST_TO_ADDR
9075: LD_VAR 0 10
9079: PUSH
9080: FOR_TO
9081: IFFALSE 9174
// begin if not ValidHex ( _x , _y ) then
9083: LD_VAR 0 11
9087: PPUSH
9088: LD_VAR 0 12
9092: PPUSH
9093: CALL_OW 488
9097: NOT
9098: IFFALSE 9102
// continue ;
9100: GO 9080
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
9102: LD_VAR 0 11
9106: PPUSH
9107: LD_VAR 0 12
9111: PPUSH
9112: CALL_OW 351
9116: PUSH
9117: LD_VAR 0 11
9121: PPUSH
9122: LD_VAR 0 12
9126: PPUSH
9127: CALL_OW 554
9131: AND
9132: IFFALSE 9172
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
9134: LD_ADDR_VAR 0 13
9138: PUSH
9139: LD_VAR 0 13
9143: PPUSH
9144: LD_VAR 0 13
9148: PUSH
9149: LD_INT 1
9151: PLUS
9152: PPUSH
9153: LD_VAR 0 11
9157: PUSH
9158: LD_VAR 0 12
9162: PUSH
9163: EMPTY
9164: LIST
9165: LIST
9166: PPUSH
9167: CALL_OW 2
9171: ST_TO_ADDR
// end ;
9172: GO 9080
9174: POP
9175: POP
9176: GO 9060
9178: POP
9179: POP
// if not list then
9180: LD_VAR 0 13
9184: NOT
9185: IFFALSE 9189
// exit ;
9187: GO 9260
// for i in list do
9189: LD_ADDR_VAR 0 6
9193: PUSH
9194: LD_VAR 0 13
9198: PUSH
9199: FOR_IN
9200: IFFALSE 9258
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
9202: LD_VAR 0 1
9206: PPUSH
9207: LD_STRING M
9209: PUSH
9210: LD_VAR 0 6
9214: PUSH
9215: LD_INT 1
9217: ARRAY
9218: PUSH
9219: LD_VAR 0 6
9223: PUSH
9224: LD_INT 2
9226: ARRAY
9227: PUSH
9228: LD_INT 0
9230: PUSH
9231: LD_INT 0
9233: PUSH
9234: LD_INT 0
9236: PUSH
9237: LD_INT 0
9239: PUSH
9240: EMPTY
9241: LIST
9242: LIST
9243: LIST
9244: LIST
9245: LIST
9246: LIST
9247: LIST
9248: PUSH
9249: EMPTY
9250: LIST
9251: PPUSH
9252: CALL_OW 447
9256: GO 9199
9258: POP
9259: POP
// end ;
9260: LD_VAR 0 5
9264: RET
