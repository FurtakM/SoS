// starting begin PrepareMap ;
   0: CALL 13 0 0
// Main_Variables ;
   4: CALL 136 0 0
// Start_Mission ;
   8: CALL 3416 0 0
// end ;
  12: END
// function PrepareMap ; begin
  13: LD_INT 0
  15: PPUSH
// ResetFog ;
  16: CALL_OW 335
// RandomizeAll ;
  20: CALL_OW 11
// game_difficulty := GetMultiplayerSetting ( 0 ) ;
  24: LD_ADDR_EXP 2
  28: PUSH
  29: LD_INT 0
  31: PPUSH
  32: CALL_OW 426
  36: ST_TO_ADDR
// Difficulty := game_difficulty ;
  37: LD_ADDR_OWVAR 67
  41: PUSH
  42: LD_EXP 2
  46: ST_TO_ADDR
// ChangeSideFog ( 8 , 6 ) ;
  47: LD_INT 8
  49: PPUSH
  50: LD_INT 6
  52: PPUSH
  53: CALL_OW 343
// PlaceSeeing ( 1 , 1 , 8 , - 37963 ) ;
  57: LD_INT 1
  59: PPUSH
  60: LD_INT 1
  62: PPUSH
  63: LD_INT 8
  65: PPUSH
  66: LD_INT 37963
  68: NEG
  69: PPUSH
  70: CALL_OW 330
// RemoveSeeing ( 1 , 1 , 8 ) ;
  74: LD_INT 1
  76: PPUSH
  77: LD_INT 1
  79: PPUSH
  80: LD_INT 8
  82: PPUSH
  83: CALL_OW 331
// PlaceCamera ;
  87: CALL 3883 0 0
// PrepareNature ( nature , 4 , 3 , 2 , 1 ) ;
  91: LD_INT 2
  93: PPUSH
  94: LD_INT 4
  96: PPUSH
  97: LD_INT 3
  99: PPUSH
 100: LD_INT 2
 102: PPUSH
 103: LD_INT 1
 105: PPUSH
 106: CALL 7797 0 5
// PrepareComm ;
 110: CALL 8280 0 0
// SetSide ( fort , 6 ) ;
 114: LD_INT 23
 116: PPUSH
 117: LD_INT 6
 119: PPUSH
 120: CALL_OW 235
// CenterNowOnUnits ( fort ) ;
 124: LD_INT 23
 126: PPUSH
 127: CALL_OW 87
// end ;
 131: LD_VAR 0 1
 135: RET
// export game_on , game_difficulty , game_time , game_option , game_end , game_strings ; export leopold , leopold_in_fort , samuel , samuel_in_fort , mortars_in_fort , scout ; export u_mine , u_fac ; export areas ; export skill ; export ar_weapons , ru_weapons , us_weapons ; export arabian_force , russian_force , american_force , arabian_timeing , russian_timeing , american_timeing ; export meeting_start , meeting_arive , meeting_break , meeting_end , meeting_time , russian_timer , fort_destroyed , hero_died , mission_time , cargo_ok , american_hchan , dezert , arabian_attack , russian_attack , american_attack , american_help , american_sib_bomb , russian_trade , heike_dialog1 , heike_dialog2 ; export am_comander , ru_comander , ar_comander ; function Main_Variables ; begin
 136: LD_INT 0
 138: PPUSH
// game_on := false ;
 139: LD_ADDR_EXP 1
 143: PUSH
 144: LD_INT 0
 146: ST_TO_ADDR
// game_time := 0 0$00 ;
 147: LD_ADDR_EXP 3
 151: PUSH
 152: LD_INT 0
 154: ST_TO_ADDR
// game_option := [ 1 ] ;
 155: LD_ADDR_EXP 4
 159: PUSH
 160: LD_INT 1
 162: PUSH
 163: EMPTY
 164: LIST
 165: ST_TO_ADDR
// game_end := false ;
 166: LD_ADDR_EXP 5
 170: PUSH
 171: LD_INT 0
 173: ST_TO_ADDR
// game_strings := [ ] ;
 174: LD_ADDR_EXP 6
 178: PUSH
 179: EMPTY
 180: ST_TO_ADDR
// game_time := 0 0$00 ;
 181: LD_ADDR_EXP 3
 185: PUSH
 186: LD_INT 0
 188: ST_TO_ADDR
// mission_time := 0 0$00 ;
 189: LD_ADDR_EXP 34
 193: PUSH
 194: LD_INT 0
 196: ST_TO_ADDR
// skill := [ 5 , 7 , 9 ] [ game_difficulty ] ;
 197: LD_ADDR_EXP 16
 201: PUSH
 202: LD_INT 5
 204: PUSH
 205: LD_INT 7
 207: PUSH
 208: LD_INT 9
 210: PUSH
 211: EMPTY
 212: LIST
 213: LIST
 214: LIST
 215: PUSH
 216: LD_EXP 2
 220: ARRAY
 221: ST_TO_ADDR
// areas := [ a_swest , a_nwest , a_neast , a_seast ] ;
 222: LD_ADDR_EXP 15
 226: PUSH
 227: LD_INT 5
 229: PUSH
 230: LD_INT 6
 232: PUSH
 233: LD_INT 7
 235: PUSH
 236: LD_INT 8
 238: PUSH
 239: EMPTY
 240: LIST
 241: LIST
 242: LIST
 243: LIST
 244: ST_TO_ADDR
// meeting_start := false ;
 245: LD_ADDR_EXP 26
 249: PUSH
 250: LD_INT 0
 252: ST_TO_ADDR
// meeting_arive := false ;
 253: LD_ADDR_EXP 27
 257: PUSH
 258: LD_INT 0
 260: ST_TO_ADDR
// meeting_break := false ;
 261: LD_ADDR_EXP 28
 265: PUSH
 266: LD_INT 0
 268: ST_TO_ADDR
// meeting_end := false ;
 269: LD_ADDR_EXP 29
 273: PUSH
 274: LD_INT 0
 276: ST_TO_ADDR
// meeting_time := [ 4 4$00 , 3 3$40 , 3 3$20 ] [ game_difficulty ] ;
 277: LD_ADDR_EXP 30
 281: PUSH
 282: LD_INT 8400
 284: PUSH
 285: LD_INT 7700
 287: PUSH
 288: LD_INT 7000
 290: PUSH
 291: EMPTY
 292: LIST
 293: LIST
 294: LIST
 295: PUSH
 296: LD_EXP 2
 300: ARRAY
 301: ST_TO_ADDR
// arabian_force := [ 5 , 6 , 7 ] [ game_difficulty ] ;
 302: LD_ADDR_EXP 20
 306: PUSH
 307: LD_INT 5
 309: PUSH
 310: LD_INT 6
 312: PUSH
 313: LD_INT 7
 315: PUSH
 316: EMPTY
 317: LIST
 318: LIST
 319: LIST
 320: PUSH
 321: LD_EXP 2
 325: ARRAY
 326: ST_TO_ADDR
// american_force := [ 6 , 8 , 9 ] [ game_difficulty ] ;
 327: LD_ADDR_EXP 22
 331: PUSH
 332: LD_INT 6
 334: PUSH
 335: LD_INT 8
 337: PUSH
 338: LD_INT 9
 340: PUSH
 341: EMPTY
 342: LIST
 343: LIST
 344: LIST
 345: PUSH
 346: LD_EXP 2
 350: ARRAY
 351: ST_TO_ADDR
// russian_force := [ 7 , 9 , 10 ] [ game_difficulty ] ;
 352: LD_ADDR_EXP 21
 356: PUSH
 357: LD_INT 7
 359: PUSH
 360: LD_INT 9
 362: PUSH
 363: LD_INT 10
 365: PUSH
 366: EMPTY
 367: LIST
 368: LIST
 369: LIST
 370: PUSH
 371: LD_EXP 2
 375: ARRAY
 376: ST_TO_ADDR
// u_mine := false ;
 377: LD_ADDR_EXP 13
 381: PUSH
 382: LD_INT 0
 384: ST_TO_ADDR
// u_fac := false ;
 385: LD_ADDR_EXP 14
 389: PUSH
 390: LD_INT 0
 392: ST_TO_ADDR
// leopold_in_fort := false ;
 393: LD_ADDR_EXP 8
 397: PUSH
 398: LD_INT 0
 400: ST_TO_ADDR
// samuel_in_fort := false ;
 401: LD_ADDR_EXP 10
 405: PUSH
 406: LD_INT 0
 408: ST_TO_ADDR
// mortars_in_fort := false ;
 409: LD_ADDR_EXP 11
 413: PUSH
 414: LD_INT 0
 416: ST_TO_ADDR
// fort_destroyed := false ;
 417: LD_ADDR_EXP 32
 421: PUSH
 422: LD_INT 0
 424: ST_TO_ADDR
// hero_died := false ;
 425: LD_ADDR_EXP 33
 429: PUSH
 430: LD_INT 0
 432: ST_TO_ADDR
// dezert := false ;
 433: LD_ADDR_EXP 37
 437: PUSH
 438: LD_INT 0
 440: ST_TO_ADDR
// arabian_attack := false ;
 441: LD_ADDR_EXP 38
 445: PUSH
 446: LD_INT 0
 448: ST_TO_ADDR
// russian_attack := false ;
 449: LD_ADDR_EXP 39
 453: PUSH
 454: LD_INT 0
 456: ST_TO_ADDR
// american_attack := false ;
 457: LD_ADDR_EXP 40
 461: PUSH
 462: LD_INT 0
 464: ST_TO_ADDR
// american_help := false ;
 465: LD_ADDR_EXP 41
 469: PUSH
 470: LD_INT 0
 472: ST_TO_ADDR
// american_hchan := [ 91 , 81 , 71 ] [ game_difficulty ] ;
 473: LD_ADDR_EXP 36
 477: PUSH
 478: LD_INT 91
 480: PUSH
 481: LD_INT 81
 483: PUSH
 484: LD_INT 71
 486: PUSH
 487: EMPTY
 488: LIST
 489: LIST
 490: LIST
 491: PUSH
 492: LD_EXP 2
 496: ARRAY
 497: ST_TO_ADDR
// american_sib_bomb := false ;
 498: LD_ADDR_EXP 42
 502: PUSH
 503: LD_INT 0
 505: ST_TO_ADDR
// russian_trade := false ;
 506: LD_ADDR_EXP 43
 510: PUSH
 511: LD_INT 0
 513: ST_TO_ADDR
// russian_timer := 5 5$00 ;
 514: LD_ADDR_EXP 31
 518: PUSH
 519: LD_INT 10500
 521: ST_TO_ADDR
// cargo_ok := false ;
 522: LD_ADDR_EXP 35
 526: PUSH
 527: LD_INT 0
 529: ST_TO_ADDR
// heike_dialog1 := false ;
 530: LD_ADDR_EXP 44
 534: PUSH
 535: LD_INT 0
 537: ST_TO_ADDR
// heike_dialog2 := false ;
 538: LD_ADDR_EXP 45
 542: PUSH
 543: LD_INT 0
 545: ST_TO_ADDR
// american_timeing := [ 10 10$00 , 9 9$40 , 9 9$10 ] [ game_difficulty ] ;
 546: LD_ADDR_EXP 25
 550: PUSH
 551: LD_INT 21000
 553: PUSH
 554: LD_INT 20300
 556: PUSH
 557: LD_INT 19250
 559: PUSH
 560: EMPTY
 561: LIST
 562: LIST
 563: LIST
 564: PUSH
 565: LD_EXP 2
 569: ARRAY
 570: ST_TO_ADDR
// arabian_timeing := [ 8 8$00 , 7 7$10 , 6 6$20 ] [ game_difficulty ] ;
 571: LD_ADDR_EXP 23
 575: PUSH
 576: LD_INT 16800
 578: PUSH
 579: LD_INT 15050
 581: PUSH
 582: LD_INT 13300
 584: PUSH
 585: EMPTY
 586: LIST
 587: LIST
 588: LIST
 589: PUSH
 590: LD_EXP 2
 594: ARRAY
 595: ST_TO_ADDR
// russian_timeing := [ 11 11$00 , 10 10$30 , 9 9$20 ] [ game_difficulty ] ;
 596: LD_ADDR_EXP 24
 600: PUSH
 601: LD_INT 23100
 603: PUSH
 604: LD_INT 22050
 606: PUSH
 607: LD_INT 19600
 609: PUSH
 610: EMPTY
 611: LIST
 612: LIST
 613: LIST
 614: PUSH
 615: LD_EXP 2
 619: ARRAY
 620: ST_TO_ADDR
// ar_weapons := [ ar_rocket_launcher , ar_gun , ar_flame_thrower , ar_selfpropelled_bomb , ar_bio_bomb ] ;
 621: LD_ADDR_EXP 17
 625: PUSH
 626: LD_INT 28
 628: PUSH
 629: LD_INT 27
 631: PUSH
 632: LD_INT 26
 634: PUSH
 635: LD_INT 29
 637: PUSH
 638: LD_EXP 56
 642: PUSH
 643: EMPTY
 644: LIST
 645: LIST
 646: LIST
 647: LIST
 648: LIST
 649: ST_TO_ADDR
// us_weapons := [ us_rocket_launcher , us_heavy_gun , us_double_laser ] ;
 650: LD_ADDR_EXP 19
 654: PUSH
 655: LD_INT 7
 657: PUSH
 658: LD_INT 6
 660: PUSH
 661: LD_INT 10
 663: PUSH
 664: EMPTY
 665: LIST
 666: LIST
 667: LIST
 668: ST_TO_ADDR
// ru_weapons := [ ru_rocket_launcher , ru_rocket , ru_heavy_gun ] ;
 669: LD_ADDR_EXP 18
 673: PUSH
 674: LD_INT 45
 676: PUSH
 677: LD_INT 47
 679: PUSH
 680: LD_INT 46
 682: PUSH
 683: EMPTY
 684: LIST
 685: LIST
 686: LIST
 687: ST_TO_ADDR
// end ;
 688: LD_VAR 0 1
 692: RET
// every 0 0$01 trigger game_on do var i , p , x , filter ;
 693: LD_EXP 1
 697: IFFALSE 3413
 699: GO 701
 701: DISABLE
 702: LD_INT 0
 704: PPUSH
 705: PPUSH
 706: PPUSH
 707: PPUSH
// begin enable ;
 708: ENABLE
// Display_Strings := [ #tick , game_time ] ^ game_strings ;
 709: LD_ADDR_OWVAR 47
 713: PUSH
 714: LD_STRING #tick
 716: PUSH
 717: LD_EXP 3
 721: PUSH
 722: EMPTY
 723: LIST
 724: LIST
 725: PUSH
 726: LD_EXP 6
 730: ADD
 731: ST_TO_ADDR
// game_time := RefreshTime ( game_time , true ) ;
 732: LD_ADDR_EXP 3
 736: PUSH
 737: LD_EXP 3
 741: PPUSH
 742: LD_INT 1
 744: PPUSH
 745: CALL 6883 0 2
 749: ST_TO_ADDR
// if meeting_start and meeting_time > 0 0$00 then
 750: LD_EXP 26
 754: PUSH
 755: LD_EXP 30
 759: PUSH
 760: LD_INT 0
 762: GREATER
 763: AND
 764: IFFALSE 801
// begin game_strings := [ #mtime , meeting_time ] ;
 766: LD_ADDR_EXP 6
 770: PUSH
 771: LD_STRING #mtime
 773: PUSH
 774: LD_EXP 30
 778: PUSH
 779: EMPTY
 780: LIST
 781: LIST
 782: ST_TO_ADDR
// meeting_time := RefreshTime ( meeting_time , false ) ;
 783: LD_ADDR_EXP 30
 787: PUSH
 788: LD_EXP 30
 792: PPUSH
 793: LD_INT 0
 795: PPUSH
 796: CALL 6883 0 2
 800: ST_TO_ADDR
// end ; if meeting_arive then
 801: LD_EXP 27
 805: IFFALSE 825
// mission_time := RefreshTime ( mission_time , true ) ;
 807: LD_ADDR_EXP 34
 811: PUSH
 812: LD_EXP 34
 816: PPUSH
 817: LD_INT 1
 819: PPUSH
 820: CALL 6883 0 2
 824: ST_TO_ADDR
// if arabian_attack and arabian_timeing > 0 0$00 and meeting_arive then
 825: LD_EXP 38
 829: PUSH
 830: LD_EXP 23
 834: PUSH
 835: LD_INT 0
 837: GREATER
 838: AND
 839: PUSH
 840: LD_EXP 27
 844: AND
 845: IFFALSE 865
// begin arabian_timeing := RefreshTime ( arabian_timeing , false ) ;
 847: LD_ADDR_EXP 23
 851: PUSH
 852: LD_EXP 23
 856: PPUSH
 857: LD_INT 0
 859: PPUSH
 860: CALL 6883 0 2
 864: ST_TO_ADDR
// end ; if russian_attack and russian_timeing > 0 0$00 and meeting_arive then
 865: LD_EXP 39
 869: PUSH
 870: LD_EXP 24
 874: PUSH
 875: LD_INT 0
 877: GREATER
 878: AND
 879: PUSH
 880: LD_EXP 27
 884: AND
 885: IFFALSE 905
// begin russian_timeing := RefreshTime ( russian_timeing , false ) ;
 887: LD_ADDR_EXP 24
 891: PUSH
 892: LD_EXP 24
 896: PPUSH
 897: LD_INT 0
 899: PPUSH
 900: CALL 6883 0 2
 904: ST_TO_ADDR
// end ; if american_attack and american_timeing > 0 0$00 and meeting_arive then
 905: LD_EXP 40
 909: PUSH
 910: LD_EXP 25
 914: PUSH
 915: LD_INT 0
 917: GREATER
 918: AND
 919: PUSH
 920: LD_EXP 27
 924: AND
 925: IFFALSE 945
// begin american_timeing := RefreshTime ( american_timeing , false ) ;
 927: LD_ADDR_EXP 25
 931: PUSH
 932: LD_EXP 25
 936: PPUSH
 937: LD_INT 0
 939: PPUSH
 940: CALL 6883 0 2
 944: ST_TO_ADDR
// end ; if russian_trade and russian_timer > 0 0$00 then
 945: LD_EXP 43
 949: PUSH
 950: LD_EXP 31
 954: PUSH
 955: LD_INT 0
 957: GREATER
 958: AND
 959: IFFALSE 996
// begin game_strings := [ #rtime , russian_timer ] ;
 961: LD_ADDR_EXP 6
 965: PUSH
 966: LD_STRING #rtime
 968: PUSH
 969: LD_EXP 31
 973: PUSH
 974: EMPTY
 975: LIST
 976: LIST
 977: ST_TO_ADDR
// russian_timer := RefreshTime ( russian_timer , false ) ;
 978: LD_ADDR_EXP 31
 982: PUSH
 983: LD_EXP 31
 987: PPUSH
 988: LD_INT 0
 990: PPUSH
 991: CALL 6883 0 2
 995: ST_TO_ADDR
// end ; if russian_trade and russian_timer = 0 0$00 or cargo_ok then
 996: LD_EXP 43
1000: PUSH
1001: LD_EXP 31
1005: PUSH
1006: LD_INT 0
1008: EQUAL
1009: AND
1010: PUSH
1011: LD_EXP 35
1015: OR
1016: IFFALSE 1025
// game_strings := [ ] ;
1018: LD_ADDR_EXP 6
1022: PUSH
1023: EMPTY
1024: ST_TO_ADDR
// if dezert = false and tick mod 33600 = 0 then
1025: LD_EXP 37
1029: PUSH
1030: LD_INT 0
1032: EQUAL
1033: PUSH
1034: LD_OWVAR 1
1038: PUSH
1039: LD_INT 33600
1041: MOD
1042: PUSH
1043: LD_INT 0
1045: EQUAL
1046: AND
1047: IFFALSE 1107
// begin p := Rand ( 1 , 5 ) ;
1049: LD_ADDR_VAR 0 2
1053: PUSH
1054: LD_INT 1
1056: PPUSH
1057: LD_INT 5
1059: PPUSH
1060: CALL_OW 12
1064: ST_TO_ADDR
// if p <= [ 4 , 3 , 3 ] [ game_difficulty ] then
1065: LD_VAR 0 2
1069: PUSH
1070: LD_INT 4
1072: PUSH
1073: LD_INT 3
1075: PUSH
1076: LD_INT 3
1078: PUSH
1079: EMPTY
1080: LIST
1081: LIST
1082: LIST
1083: PUSH
1084: LD_EXP 2
1088: ARRAY
1089: LESSEQUAL
1090: IFFALSE 1107
// begin RaiseSailEvent ( 92 ) ;
1092: LD_INT 92
1094: PPUSH
1095: CALL_OW 427
// dezert := true ;
1099: LD_ADDR_EXP 37
1103: PUSH
1104: LD_INT 1
1106: ST_TO_ADDR
// end ; end ; if tick mod 8400 = 0 then
1107: LD_OWVAR 1
1111: PUSH
1112: LD_INT 8400
1114: MOD
1115: PUSH
1116: LD_INT 0
1118: EQUAL
1119: IFFALSE 1128
// RaiseSailEvent ( 101 ) ;
1121: LD_INT 101
1123: PPUSH
1124: CALL_OW 427
// if MineExist ( 8 ) and u_mine = false then
1128: LD_INT 8
1130: PPUSH
1131: CALL 6937 0 1
1135: PUSH
1136: LD_EXP 13
1140: PUSH
1141: LD_INT 0
1143: EQUAL
1144: AND
1145: IFFALSE 1162
// begin u_mine := true ;
1147: LD_ADDR_EXP 13
1151: PUSH
1152: LD_INT 1
1154: ST_TO_ADDR
// ChangeMissionObjectives ( DS-T1m ) ;
1155: LD_STRING DS-T1m
1157: PPUSH
1158: CALL_OW 337
// end ; if FacExist ( 8 ) and u_fac = false then
1162: LD_INT 8
1164: PPUSH
1165: CALL 6999 0 1
1169: PUSH
1170: LD_EXP 14
1174: PUSH
1175: LD_INT 0
1177: EQUAL
1178: AND
1179: IFFALSE 1196
// begin u_fac := true ;
1181: LD_ADDR_EXP 14
1185: PUSH
1186: LD_INT 1
1188: ST_TO_ADDR
// ChangeMissionObjectives ( DS-T1f ) ;
1189: LD_STRING DS-T1f
1191: PPUSH
1192: CALL_OW 337
// end ; if hero_died then
1196: LD_EXP 33
1200: IFFALSE 1209
// YouLost ( DS-h1 ) ;
1202: LD_STRING DS-h1
1204: PPUSH
1205: CALL_OW 104
// if fort_destroyed then
1209: LD_EXP 32
1213: IFFALSE 1222
// YouLost ( DS-h2 ) ;
1215: LD_STRING DS-h2
1217: PPUSH
1218: CALL_OW 104
// if GetDistUnits ( leopold , l_cmndr ) > 6 and meeting_start = false then
1222: LD_EXP 7
1226: PPUSH
1227: LD_EXP 49
1231: PPUSH
1232: CALL_OW 296
1236: PUSH
1237: LD_INT 6
1239: GREATER
1240: PUSH
1241: LD_EXP 26
1245: PUSH
1246: LD_INT 0
1248: EQUAL
1249: AND
1250: IFFALSE 1273
// begin if not HasTask ( leopold ) then
1252: LD_EXP 7
1256: PPUSH
1257: CALL_OW 314
1261: NOT
1262: IFFALSE 1271
// RaiseSailEvent ( 1 ) ;
1264: LD_INT 1
1266: PPUSH
1267: CALL_OW 427
// end else
1271: GO 1290
// if meeting_start = false then
1273: LD_EXP 26
1277: PUSH
1278: LD_INT 0
1280: EQUAL
1281: IFFALSE 1290
// begin RaiseSailEvent ( 2 ) ;
1283: LD_INT 2
1285: PPUSH
1286: CALL_OW 427
// end ; if game_time >= [ 50 50$00 , 62 62$30 , 75 75$00 ] [ game_difficulty ] and meeting_end = false then
1290: LD_EXP 3
1294: PUSH
1295: LD_INT 105000
1297: PUSH
1298: LD_INT 131250
1300: PUSH
1301: LD_INT 157500
1303: PUSH
1304: EMPTY
1305: LIST
1306: LIST
1307: LIST
1308: PUSH
1309: LD_EXP 2
1313: ARRAY
1314: GREATEREQUAL
1315: PUSH
1316: LD_EXP 29
1320: PUSH
1321: LD_INT 0
1323: EQUAL
1324: AND
1325: IFFALSE 1342
// begin meeting_end := true ;
1327: LD_ADDR_EXP 29
1331: PUSH
1332: LD_INT 1
1334: ST_TO_ADDR
// RaiseSailEvent ( 200 ) ;
1335: LD_INT 200
1337: PPUSH
1338: CALL_OW 427
// end ; if meeting_time = 0 0$00 and meeting_arive = false then
1342: LD_EXP 30
1346: PUSH
1347: LD_INT 0
1349: EQUAL
1350: PUSH
1351: LD_EXP 27
1355: PUSH
1356: LD_INT 0
1358: EQUAL
1359: AND
1360: IFFALSE 1384
// begin meeting_arive := true ;
1362: LD_ADDR_EXP 27
1366: PUSH
1367: LD_INT 1
1369: ST_TO_ADDR
// game_strings := [ ] ;
1370: LD_ADDR_EXP 6
1374: PUSH
1375: EMPTY
1376: ST_TO_ADDR
// RaiseSailEvent ( 10 ) ;
1377: LD_INT 10
1379: PPUSH
1380: CALL_OW 427
// end ; if meeting_arive then
1384: LD_EXP 27
1388: IFFALSE 2133
// begin if arabian_attack = false and tick mod 4200 = 0 then
1390: LD_EXP 38
1394: PUSH
1395: LD_INT 0
1397: EQUAL
1398: PUSH
1399: LD_OWVAR 1
1403: PUSH
1404: LD_INT 4200
1406: MOD
1407: PUSH
1408: LD_INT 0
1410: EQUAL
1411: AND
1412: IFFALSE 1465
// begin p := Rand ( 1 , 100 ) ;
1414: LD_ADDR_VAR 0 2
1418: PUSH
1419: LD_INT 1
1421: PPUSH
1422: LD_INT 100
1424: PPUSH
1425: CALL_OW 12
1429: ST_TO_ADDR
// if p <= [ 80 , 85 , 90 ] [ game_difficulty ] then
1430: LD_VAR 0 2
1434: PUSH
1435: LD_INT 80
1437: PUSH
1438: LD_INT 85
1440: PUSH
1441: LD_INT 90
1443: PUSH
1444: EMPTY
1445: LIST
1446: LIST
1447: LIST
1448: PUSH
1449: LD_EXP 2
1453: ARRAY
1454: LESSEQUAL
1455: IFFALSE 1465
// arabian_attack := true ;
1457: LD_ADDR_EXP 38
1461: PUSH
1462: LD_INT 1
1464: ST_TO_ADDR
// end ; if russian_trade = false and russian_attack = false and tick > 52500 then
1465: LD_EXP 43
1469: PUSH
1470: LD_INT 0
1472: EQUAL
1473: PUSH
1474: LD_EXP 39
1478: PUSH
1479: LD_INT 0
1481: EQUAL
1482: AND
1483: PUSH
1484: LD_OWVAR 1
1488: PUSH
1489: LD_INT 52500
1491: GREATER
1492: AND
1493: IFFALSE 1564
// begin russian_trade = true ;
1495: LD_ADDR_EXP 43
1499: PUSH
1500: LD_INT 1
1502: ST_TO_ADDR
// DialogueOn ;
1503: CALL_OW 6
// SayRadio ( ru_comander , DS-DR-RTr ) ;
1507: LD_EXP 47
1511: PPUSH
1512: LD_STRING DS-DR-RTr
1514: PPUSH
1515: CALL_OW 94
// Say ( l_cmndr , DS-DC-RTr ) ;
1519: LD_EXP 49
1523: PPUSH
1524: LD_STRING DS-DC-RTr
1526: PPUSH
1527: CALL_OW 88
// SayRadio ( ru_comander , DS-DR-RTr2 ) ;
1531: LD_EXP 47
1535: PPUSH
1536: LD_STRING DS-DR-RTr2
1538: PPUSH
1539: CALL_OW 94
// DialogueOff ;
1543: CALL_OW 7
// ChangeMissionObjectives ( DS-T2 ) ;
1547: LD_STRING DS-T2
1549: PPUSH
1550: CALL_OW 337
// SetAreaMapShow ( tree , 1 ) ;
1554: LD_INT 10
1556: PPUSH
1557: LD_INT 1
1559: PPUSH
1560: CALL_OW 424
// end ; if russian_trade and cargo_ok = false and russian_timer > 0 0$00 then
1564: LD_EXP 43
1568: PUSH
1569: LD_EXP 35
1573: PUSH
1574: LD_INT 0
1576: EQUAL
1577: AND
1578: PUSH
1579: LD_EXP 31
1583: PUSH
1584: LD_INT 0
1586: GREATER
1587: AND
1588: IFFALSE 1783
// begin if FilterUnitsInArea ( tree , ( [ [ f_empty ] , [ f_weapon , ar_cargo_bay ] , [ f_not , [ f_control , control_remote ] ] ] ) ) > 0 then
1590: LD_INT 10
1592: PPUSH
1593: LD_INT 58
1595: PUSH
1596: EMPTY
1597: LIST
1598: PUSH
1599: LD_INT 34
1601: PUSH
1602: LD_INT 32
1604: PUSH
1605: EMPTY
1606: LIST
1607: LIST
1608: PUSH
1609: LD_INT 3
1611: PUSH
1612: LD_INT 33
1614: PUSH
1615: LD_INT 2
1617: PUSH
1618: EMPTY
1619: LIST
1620: LIST
1621: PUSH
1622: EMPTY
1623: LIST
1624: LIST
1625: PUSH
1626: EMPTY
1627: LIST
1628: LIST
1629: LIST
1630: PPUSH
1631: CALL_OW 70
1635: PUSH
1636: LD_INT 0
1638: GREATER
1639: IFFALSE 1783
// if GetCargo ( FilterUnitsInArea ( tree , ( [ [ f_empty ] , [ f_weapon , ar_cargo_bay ] , [ f_not , [ f_control , control_remote ] ] ] ) ) [ 1 ] , mat_siberit ) = 100 then
1641: LD_INT 10
1643: PPUSH
1644: LD_INT 58
1646: PUSH
1647: EMPTY
1648: LIST
1649: PUSH
1650: LD_INT 34
1652: PUSH
1653: LD_INT 32
1655: PUSH
1656: EMPTY
1657: LIST
1658: LIST
1659: PUSH
1660: LD_INT 3
1662: PUSH
1663: LD_INT 33
1665: PUSH
1666: LD_INT 2
1668: PUSH
1669: EMPTY
1670: LIST
1671: LIST
1672: PUSH
1673: EMPTY
1674: LIST
1675: LIST
1676: PUSH
1677: EMPTY
1678: LIST
1679: LIST
1680: LIST
1681: PPUSH
1682: CALL_OW 70
1686: PUSH
1687: LD_INT 1
1689: ARRAY
1690: PPUSH
1691: LD_INT 3
1693: PPUSH
1694: CALL_OW 289
1698: PUSH
1699: LD_INT 100
1701: EQUAL
1702: IFFALSE 1783
// begin cargo_ok := true ;
1704: LD_ADDR_EXP 35
1708: PUSH
1709: LD_INT 1
1711: ST_TO_ADDR
// RemoveUnit ( FilterUnitsInArea ( tree , ( [ [ f_empty ] , [ f_weapon , ar_cargo_bay ] , [ f_not , [ f_control , control_remote ] ] ] ) ) [ 1 ] ) ;
1712: LD_INT 10
1714: PPUSH
1715: LD_INT 58
1717: PUSH
1718: EMPTY
1719: LIST
1720: PUSH
1721: LD_INT 34
1723: PUSH
1724: LD_INT 32
1726: PUSH
1727: EMPTY
1728: LIST
1729: LIST
1730: PUSH
1731: LD_INT 3
1733: PUSH
1734: LD_INT 33
1736: PUSH
1737: LD_INT 2
1739: PUSH
1740: EMPTY
1741: LIST
1742: LIST
1743: PUSH
1744: EMPTY
1745: LIST
1746: LIST
1747: PUSH
1748: EMPTY
1749: LIST
1750: LIST
1751: LIST
1752: PPUSH
1753: CALL_OW 70
1757: PUSH
1758: LD_INT 1
1760: ARRAY
1761: PPUSH
1762: CALL_OW 64
// ChangeMissionObjectives ( DS-T2-out ) ;
1766: LD_STRING DS-T2-out
1768: PPUSH
1769: CALL_OW 337
// SetAreaMapShow ( tree , 0 ) ;
1773: LD_INT 10
1775: PPUSH
1776: LD_INT 0
1778: PPUSH
1779: CALL_OW 424
// end ; end ; if russian_attack = false and russian_trade and cargo_ok = false and russian_timer = 0 0$00 then
1783: LD_EXP 39
1787: PUSH
1788: LD_INT 0
1790: EQUAL
1791: PUSH
1792: LD_EXP 43
1796: AND
1797: PUSH
1798: LD_EXP 35
1802: PUSH
1803: LD_INT 0
1805: EQUAL
1806: AND
1807: PUSH
1808: LD_EXP 31
1812: PUSH
1813: LD_INT 0
1815: EQUAL
1816: AND
1817: IFFALSE 1844
// begin russian_attack := true ;
1819: LD_ADDR_EXP 39
1823: PUSH
1824: LD_INT 1
1826: ST_TO_ADDR
// ChangeMissionObjectives ( DS-T2-out ) ;
1827: LD_STRING DS-T2-out
1829: PPUSH
1830: CALL_OW 337
// SetAreaMapShow ( tree , 0 ) ;
1834: LD_INT 10
1836: PPUSH
1837: LD_INT 0
1839: PPUSH
1840: CALL_OW 424
// end ; if russian_trade = false and russian_attack = false and american_attack = false and tick mod 21000 = 0 then
1844: LD_EXP 43
1848: PUSH
1849: LD_INT 0
1851: EQUAL
1852: PUSH
1853: LD_EXP 39
1857: PUSH
1858: LD_INT 0
1860: EQUAL
1861: AND
1862: PUSH
1863: LD_EXP 40
1867: PUSH
1868: LD_INT 0
1870: EQUAL
1871: AND
1872: PUSH
1873: LD_OWVAR 1
1877: PUSH
1878: LD_INT 21000
1880: MOD
1881: PUSH
1882: LD_INT 0
1884: EQUAL
1885: AND
1886: IFFALSE 1939
// begin p := Rand ( 1 , 100 ) ;
1888: LD_ADDR_VAR 0 2
1892: PUSH
1893: LD_INT 1
1895: PPUSH
1896: LD_INT 100
1898: PPUSH
1899: CALL_OW 12
1903: ST_TO_ADDR
// if p <= [ 25 , 35 , 45 ] [ game_difficulty ] then
1904: LD_VAR 0 2
1908: PUSH
1909: LD_INT 25
1911: PUSH
1912: LD_INT 35
1914: PUSH
1915: LD_INT 45
1917: PUSH
1918: EMPTY
1919: LIST
1920: LIST
1921: LIST
1922: PUSH
1923: LD_EXP 2
1927: ARRAY
1928: LESSEQUAL
1929: IFFALSE 1939
// russian_attack := true ;
1931: LD_ADDR_EXP 39
1935: PUSH
1936: LD_INT 1
1938: ST_TO_ADDR
// end ; if american_help = false and american_attack = false and russian_attack = false and tick mod 31500 = 0 then
1939: LD_EXP 41
1943: PUSH
1944: LD_INT 0
1946: EQUAL
1947: PUSH
1948: LD_EXP 40
1952: PUSH
1953: LD_INT 0
1955: EQUAL
1956: AND
1957: PUSH
1958: LD_EXP 39
1962: PUSH
1963: LD_INT 0
1965: EQUAL
1966: AND
1967: PUSH
1968: LD_OWVAR 1
1972: PUSH
1973: LD_INT 31500
1975: MOD
1976: PUSH
1977: LD_INT 0
1979: EQUAL
1980: AND
1981: IFFALSE 2034
// begin p := Rand ( 1 , 100 ) ;
1983: LD_ADDR_VAR 0 2
1987: PUSH
1988: LD_INT 1
1990: PPUSH
1991: LD_INT 100
1993: PPUSH
1994: CALL_OW 12
1998: ST_TO_ADDR
// if p <= [ 22 , 33 , 44 ] [ game_difficulty ] then
1999: LD_VAR 0 2
2003: PUSH
2004: LD_INT 22
2006: PUSH
2007: LD_INT 33
2009: PUSH
2010: LD_INT 44
2012: PUSH
2013: EMPTY
2014: LIST
2015: LIST
2016: LIST
2017: PUSH
2018: LD_EXP 2
2022: ARRAY
2023: LESSEQUAL
2024: IFFALSE 2034
// american_attack := true ;
2026: LD_ADDR_EXP 40
2030: PUSH
2031: LD_INT 1
2033: ST_TO_ADDR
// end ; if american_attack = false and russian_attack = false and american_help = false and tick mod 21200 = 0 then
2034: LD_EXP 40
2038: PUSH
2039: LD_INT 0
2041: EQUAL
2042: PUSH
2043: LD_EXP 39
2047: PUSH
2048: LD_INT 0
2050: EQUAL
2051: AND
2052: PUSH
2053: LD_EXP 41
2057: PUSH
2058: LD_INT 0
2060: EQUAL
2061: AND
2062: PUSH
2063: LD_OWVAR 1
2067: PUSH
2068: LD_INT 21200
2070: MOD
2071: PUSH
2072: LD_INT 0
2074: EQUAL
2075: AND
2076: IFFALSE 2133
// begin p := Rand ( 1 , 100 ) ;
2078: LD_ADDR_VAR 0 2
2082: PUSH
2083: LD_INT 1
2085: PPUSH
2086: LD_INT 100
2088: PPUSH
2089: CALL_OW 12
2093: ST_TO_ADDR
// if p <= american_hchan then
2094: LD_VAR 0 2
2098: PUSH
2099: LD_EXP 36
2103: LESSEQUAL
2104: IFFALSE 2133
// begin american_help := true ;
2106: LD_ADDR_EXP 41
2110: PUSH
2111: LD_INT 1
2113: ST_TO_ADDR
// SayRadio ( am_comander , DS-amhelp ) ;
2114: LD_EXP 46
2118: PPUSH
2119: LD_STRING DS-amhelp
2121: PPUSH
2122: CALL_OW 94
// RaiseSailEvent ( 91 ) ;
2126: LD_INT 91
2128: PPUSH
2129: CALL_OW 427
// end ; end ; end ; if american_attack and american_timeing = 0 0$00 and FilterAllUnits ( [ f_side , 1 ] ) = 0 then
2133: LD_EXP 40
2137: PUSH
2138: LD_EXP 25
2142: PUSH
2143: LD_INT 0
2145: EQUAL
2146: AND
2147: PUSH
2148: LD_INT 22
2150: PUSH
2151: LD_INT 1
2153: PUSH
2154: EMPTY
2155: LIST
2156: LIST
2157: PPUSH
2158: CALL_OW 69
2162: PUSH
2163: LD_INT 0
2165: EQUAL
2166: AND
2167: IFFALSE 2269
// begin american_timeing := Rand ( 17 17$00 , 20 20$00 ) ;
2169: LD_ADDR_EXP 25
2173: PUSH
2174: LD_INT 35700
2176: PPUSH
2177: LD_INT 42000
2179: PPUSH
2180: CALL_OW 12
2184: ST_TO_ADDR
// SayRadio ( scout , DS-DZ-U ) ;
2185: LD_EXP 12
2189: PPUSH
2190: LD_STRING DS-DZ-U
2192: PPUSH
2193: CALL_OW 94
// Wait ( 0 0$33 ) ;
2197: LD_INT 1155
2199: PPUSH
2200: CALL_OW 67
// x := Rand ( 1 , 2 ) ;
2204: LD_ADDR_VAR 0 3
2208: PUSH
2209: LD_INT 1
2211: PPUSH
2212: LD_INT 2
2214: PPUSH
2215: CALL_OW 12
2219: ST_TO_ADDR
// case x of 1 :
2220: LD_VAR 0 3
2224: PUSH
2225: LD_INT 1
2227: DOUBLE
2228: EQUAL
2229: IFTRUE 2233
2231: GO 2243
2233: POP
// RaiseSailEvent ( 41 ) ; 2 :
2234: LD_INT 41
2236: PPUSH
2237: CALL_OW 427
2241: GO 2262
2243: LD_INT 2
2245: DOUBLE
2246: EQUAL
2247: IFTRUE 2251
2249: GO 2261
2251: POP
// RaiseSailEvent ( 42 ) ; end ;
2252: LD_INT 42
2254: PPUSH
2255: CALL_OW 427
2259: GO 2262
2261: POP
// RaiseSailEvent ( 42 ) ;
2262: LD_INT 42
2264: PPUSH
2265: CALL_OW 427
// end ; if russian_attack and russian_timeing = 0 0$00 and FilterAllUnits ( [ f_side , 3 ] ) = 0 then
2269: LD_EXP 39
2273: PUSH
2274: LD_EXP 24
2278: PUSH
2279: LD_INT 0
2281: EQUAL
2282: AND
2283: PUSH
2284: LD_INT 22
2286: PUSH
2287: LD_INT 3
2289: PUSH
2290: EMPTY
2291: LIST
2292: LIST
2293: PPUSH
2294: CALL_OW 69
2298: PUSH
2299: LD_INT 0
2301: EQUAL
2302: AND
2303: IFFALSE 2359
// begin russian_timeing := Rand ( 17 17$00 , 20 20$00 ) ;
2305: LD_ADDR_EXP 24
2309: PUSH
2310: LD_INT 35700
2312: PPUSH
2313: LD_INT 42000
2315: PPUSH
2316: CALL_OW 12
2320: ST_TO_ADDR
// SayRadio ( scout , DS-DZ-R ) ;
2321: LD_EXP 12
2325: PPUSH
2326: LD_STRING DS-DZ-R
2328: PPUSH
2329: CALL_OW 94
// Wait ( 0 0$45 ) ;
2333: LD_INT 1575
2335: PPUSH
2336: CALL_OW 67
// SayRadio ( ru_comander , DS-DR-R1 ) ;
2340: LD_EXP 47
2344: PPUSH
2345: LD_STRING DS-DR-R1
2347: PPUSH
2348: CALL_OW 94
// RaiseSailEvent ( 51 ) ;
2352: LD_INT 51
2354: PPUSH
2355: CALL_OW 427
// end ; if mission_time >= 10 10$00 and arabian_force < 10 then
2359: LD_EXP 34
2363: PUSH
2364: LD_INT 21000
2366: GREATEREQUAL
2367: PUSH
2368: LD_EXP 20
2372: PUSH
2373: LD_INT 10
2375: LESS
2376: AND
2377: IFFALSE 2401
// begin mission_time := 0 0$00 ;
2379: LD_ADDR_EXP 34
2383: PUSH
2384: LD_INT 0
2386: ST_TO_ADDR
// arabian_force := arabian_force + 1 ;
2387: LD_ADDR_EXP 20
2391: PUSH
2392: LD_EXP 20
2396: PUSH
2397: LD_INT 1
2399: PLUS
2400: ST_TO_ADDR
// end ; if arabian_timeing = 0 0$00 and FilterAllUnits ( [ [ f_side , 2 ] , [ f_not , [ f_weapon , ar_control_tower ] ] ] ) = 0 then
2401: LD_EXP 23
2405: PUSH
2406: LD_INT 0
2408: EQUAL
2409: PUSH
2410: LD_INT 22
2412: PUSH
2413: LD_INT 2
2415: PUSH
2416: EMPTY
2417: LIST
2418: LIST
2419: PUSH
2420: LD_INT 3
2422: PUSH
2423: LD_INT 34
2425: PUSH
2426: LD_INT 31
2428: PUSH
2429: EMPTY
2430: LIST
2431: LIST
2432: PUSH
2433: EMPTY
2434: LIST
2435: LIST
2436: PUSH
2437: EMPTY
2438: LIST
2439: LIST
2440: PPUSH
2441: CALL_OW 69
2445: PUSH
2446: LD_INT 0
2448: EQUAL
2449: AND
2450: IFFALSE 2648
// begin arabian_timeing := 7 7$30 ;
2452: LD_ADDR_EXP 23
2456: PUSH
2457: LD_INT 15750
2459: ST_TO_ADDR
// x := Rand ( 1 , 3 ) ;
2460: LD_ADDR_VAR 0 3
2464: PUSH
2465: LD_INT 1
2467: PPUSH
2468: LD_INT 3
2470: PPUSH
2471: CALL_OW 12
2475: ST_TO_ADDR
// SayRadio ( scout , DS-DZ-H ) ;
2476: LD_EXP 12
2480: PPUSH
2481: LD_STRING DS-DZ-H
2483: PPUSH
2484: CALL_OW 94
// case x of 1 :
2488: LD_VAR 0 3
2492: PUSH
2493: LD_INT 1
2495: DOUBLE
2496: EQUAL
2497: IFTRUE 2501
2499: GO 2511
2501: POP
// RaiseSailEvent ( 31 ) ; 2 :
2502: LD_INT 31
2504: PPUSH
2505: CALL_OW 427
2509: GO 2548
2511: LD_INT 2
2513: DOUBLE
2514: EQUAL
2515: IFTRUE 2519
2517: GO 2529
2519: POP
// RaiseSailEvent ( 32 ) ; 3 :
2520: LD_INT 32
2522: PPUSH
2523: CALL_OW 427
2527: GO 2548
2529: LD_INT 3
2531: DOUBLE
2532: EQUAL
2533: IFTRUE 2537
2535: GO 2547
2537: POP
// RaiseSailEvent ( 33 ) ; end ;
2538: LD_INT 33
2540: PPUSH
2541: CALL_OW 427
2545: GO 2548
2547: POP
// RaiseSailEvent ( 33 ) ;
2548: LD_INT 33
2550: PPUSH
2551: CALL_OW 427
// if game_difficulty > 1 then
2555: LD_EXP 2
2559: PUSH
2560: LD_INT 1
2562: GREATER
2563: IFFALSE 2572
// RaiseSailEvent ( 33 ) ;
2565: LD_INT 33
2567: PPUSH
2568: CALL_OW 427
// if heike_dialog1 = false then
2572: LD_EXP 44
2576: PUSH
2577: LD_INT 0
2579: EQUAL
2580: IFFALSE 2611
// begin heike_dialog1 := true ;
2582: LD_ADDR_EXP 44
2586: PUSH
2587: LD_INT 1
2589: ST_TO_ADDR
// Wait ( 0 0$03 ) ;
2590: LD_INT 105
2592: PPUSH
2593: CALL_OW 67
// SayRadio ( ar_comander , heike1 ) ;
2597: LD_EXP 48
2601: PPUSH
2602: LD_STRING heike1
2604: PPUSH
2605: CALL_OW 94
// end else
2609: GO 2648
// if heike_dialog2 = false then
2611: LD_EXP 45
2615: PUSH
2616: LD_INT 0
2618: EQUAL
2619: IFFALSE 2648
// begin heike_dialog2 := true ;
2621: LD_ADDR_EXP 45
2625: PUSH
2626: LD_INT 1
2628: ST_TO_ADDR
// Wait ( 0 0$03 ) ;
2629: LD_INT 105
2631: PPUSH
2632: CALL_OW 67
// SayRadio ( ar_comander , heike2 ) ;
2636: LD_EXP 48
2640: PPUSH
2641: LD_STRING heike2
2643: PPUSH
2644: CALL_OW 94
// end ; end ; if FilterAllUnits ( [ [ f_side , 2 ] , [ f_control , control_remote ] ] ) > 0 then
2648: LD_INT 22
2650: PUSH
2651: LD_INT 2
2653: PUSH
2654: EMPTY
2655: LIST
2656: LIST
2657: PUSH
2658: LD_INT 33
2660: PUSH
2661: LD_INT 2
2663: PUSH
2664: EMPTY
2665: LIST
2666: LIST
2667: PUSH
2668: EMPTY
2669: LIST
2670: LIST
2671: PPUSH
2672: CALL_OW 69
2676: PUSH
2677: LD_INT 0
2679: GREATER
2680: IFFALSE 2689
// ConnectWithTower ( 2 ) ;
2682: LD_INT 2
2684: PPUSH
2685: CALL 7047 0 1
// if FilterAllUnits ( [ [ [ f_side , 2 ] , [ f_not , [ f_weapon , ar_control_tower ] ] , [ f_not , [ f_hastask ] ] ] ] ) > 0 then
2689: LD_INT 22
2691: PUSH
2692: LD_INT 2
2694: PUSH
2695: EMPTY
2696: LIST
2697: LIST
2698: PUSH
2699: LD_INT 3
2701: PUSH
2702: LD_INT 34
2704: PUSH
2705: LD_INT 31
2707: PUSH
2708: EMPTY
2709: LIST
2710: LIST
2711: PUSH
2712: EMPTY
2713: LIST
2714: LIST
2715: PUSH
2716: LD_INT 3
2718: PUSH
2719: LD_INT 60
2721: PUSH
2722: EMPTY
2723: LIST
2724: PUSH
2725: EMPTY
2726: LIST
2727: LIST
2728: PUSH
2729: EMPTY
2730: LIST
2731: LIST
2732: LIST
2733: PUSH
2734: EMPTY
2735: LIST
2736: PPUSH
2737: CALL_OW 69
2741: PUSH
2742: LD_INT 0
2744: GREATER
2745: IFFALSE 2891
// begin filter := FilterAllUnits ( [ [ [ f_side , 2 ] , [ f_not , [ f_weapon , ar_control_tower ] ] , [ f_not , [ f_hastask ] ] ] ] ) ;
2747: LD_ADDR_VAR 0 4
2751: PUSH
2752: LD_INT 22
2754: PUSH
2755: LD_INT 2
2757: PUSH
2758: EMPTY
2759: LIST
2760: LIST
2761: PUSH
2762: LD_INT 3
2764: PUSH
2765: LD_INT 34
2767: PUSH
2768: LD_INT 31
2770: PUSH
2771: EMPTY
2772: LIST
2773: LIST
2774: PUSH
2775: EMPTY
2776: LIST
2777: LIST
2778: PUSH
2779: LD_INT 3
2781: PUSH
2782: LD_INT 60
2784: PUSH
2785: EMPTY
2786: LIST
2787: PUSH
2788: EMPTY
2789: LIST
2790: LIST
2791: PUSH
2792: EMPTY
2793: LIST
2794: LIST
2795: LIST
2796: PUSH
2797: EMPTY
2798: LIST
2799: PPUSH
2800: CALL_OW 69
2804: ST_TO_ADDR
// x := SpeedFilter ( FilterAllUnits ( [ f_enemy , 2 ] ) , 20 ) ;
2805: LD_ADDR_VAR 0 3
2809: PUSH
2810: LD_INT 81
2812: PUSH
2813: LD_INT 2
2815: PUSH
2816: EMPTY
2817: LIST
2818: LIST
2819: PPUSH
2820: CALL_OW 69
2824: PPUSH
2825: LD_INT 20
2827: PPUSH
2828: CALL 8430 0 2
2832: ST_TO_ADDR
// for i = 1 to filter do
2833: LD_ADDR_VAR 0 1
2837: PUSH
2838: DOUBLE
2839: LD_INT 1
2841: DEC
2842: ST_TO_ADDR
2843: LD_VAR 0 4
2847: PUSH
2848: FOR_TO
2849: IFFALSE 2889
// ComAttackUnit ( filter [ i ] , NearestUnitToUnit ( x , filter [ i ] ) ) ;
2851: LD_VAR 0 4
2855: PUSH
2856: LD_VAR 0 1
2860: ARRAY
2861: PPUSH
2862: LD_VAR 0 3
2866: PPUSH
2867: LD_VAR 0 4
2871: PUSH
2872: LD_VAR 0 1
2876: ARRAY
2877: PPUSH
2878: CALL_OW 74
2882: PPUSH
2883: CALL_OW 115
2887: GO 2848
2889: POP
2890: POP
// end ; if FilterAllUnits ( [ [ [ f_side , 3 ] , [ f_not , [ f_hastask ] ] ] ] ) > 0 then
2891: LD_INT 22
2893: PUSH
2894: LD_INT 3
2896: PUSH
2897: EMPTY
2898: LIST
2899: LIST
2900: PUSH
2901: LD_INT 3
2903: PUSH
2904: LD_INT 60
2906: PUSH
2907: EMPTY
2908: LIST
2909: PUSH
2910: EMPTY
2911: LIST
2912: LIST
2913: PUSH
2914: EMPTY
2915: LIST
2916: LIST
2917: PUSH
2918: EMPTY
2919: LIST
2920: PPUSH
2921: CALL_OW 69
2925: PUSH
2926: LD_INT 0
2928: GREATER
2929: IFFALSE 3075
// begin filter := FilterAllUnits ( [ [ [ f_side , 3 ] , [ f_not , [ f_weapon , ar_control_tower ] ] , [ f_not , [ f_hastask ] ] ] ] ) ;
2931: LD_ADDR_VAR 0 4
2935: PUSH
2936: LD_INT 22
2938: PUSH
2939: LD_INT 3
2941: PUSH
2942: EMPTY
2943: LIST
2944: LIST
2945: PUSH
2946: LD_INT 3
2948: PUSH
2949: LD_INT 34
2951: PUSH
2952: LD_INT 31
2954: PUSH
2955: EMPTY
2956: LIST
2957: LIST
2958: PUSH
2959: EMPTY
2960: LIST
2961: LIST
2962: PUSH
2963: LD_INT 3
2965: PUSH
2966: LD_INT 60
2968: PUSH
2969: EMPTY
2970: LIST
2971: PUSH
2972: EMPTY
2973: LIST
2974: LIST
2975: PUSH
2976: EMPTY
2977: LIST
2978: LIST
2979: LIST
2980: PUSH
2981: EMPTY
2982: LIST
2983: PPUSH
2984: CALL_OW 69
2988: ST_TO_ADDR
// x := SpeedFilter ( FilterAllUnits ( [ f_enemy , 3 ] ) , 20 ) ;
2989: LD_ADDR_VAR 0 3
2993: PUSH
2994: LD_INT 81
2996: PUSH
2997: LD_INT 3
2999: PUSH
3000: EMPTY
3001: LIST
3002: LIST
3003: PPUSH
3004: CALL_OW 69
3008: PPUSH
3009: LD_INT 20
3011: PPUSH
3012: CALL 8430 0 2
3016: ST_TO_ADDR
// for i = 1 to filter do
3017: LD_ADDR_VAR 0 1
3021: PUSH
3022: DOUBLE
3023: LD_INT 1
3025: DEC
3026: ST_TO_ADDR
3027: LD_VAR 0 4
3031: PUSH
3032: FOR_TO
3033: IFFALSE 3073
// ComAttackUnit ( filter [ i ] , NearestUnitToUnit ( x , filter [ i ] ) ) ;
3035: LD_VAR 0 4
3039: PUSH
3040: LD_VAR 0 1
3044: ARRAY
3045: PPUSH
3046: LD_VAR 0 3
3050: PPUSH
3051: LD_VAR 0 4
3055: PUSH
3056: LD_VAR 0 1
3060: ARRAY
3061: PPUSH
3062: CALL_OW 74
3066: PPUSH
3067: CALL_OW 115
3071: GO 3032
3073: POP
3074: POP
// end ; if FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_not , [ f_hastask ] ] ] ] ) > 0 then
3075: LD_INT 22
3077: PUSH
3078: LD_INT 1
3080: PUSH
3081: EMPTY
3082: LIST
3083: LIST
3084: PUSH
3085: LD_INT 3
3087: PUSH
3088: LD_INT 60
3090: PUSH
3091: EMPTY
3092: LIST
3093: PUSH
3094: EMPTY
3095: LIST
3096: LIST
3097: PUSH
3098: EMPTY
3099: LIST
3100: LIST
3101: PUSH
3102: EMPTY
3103: LIST
3104: PPUSH
3105: CALL_OW 69
3109: PUSH
3110: LD_INT 0
3112: GREATER
3113: IFFALSE 3259
// begin filter := FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_not , [ f_weapon , ar_control_tower ] ] , [ f_not , [ f_hastask ] ] ] ] ) ;
3115: LD_ADDR_VAR 0 4
3119: PUSH
3120: LD_INT 22
3122: PUSH
3123: LD_INT 1
3125: PUSH
3126: EMPTY
3127: LIST
3128: LIST
3129: PUSH
3130: LD_INT 3
3132: PUSH
3133: LD_INT 34
3135: PUSH
3136: LD_INT 31
3138: PUSH
3139: EMPTY
3140: LIST
3141: LIST
3142: PUSH
3143: EMPTY
3144: LIST
3145: LIST
3146: PUSH
3147: LD_INT 3
3149: PUSH
3150: LD_INT 60
3152: PUSH
3153: EMPTY
3154: LIST
3155: PUSH
3156: EMPTY
3157: LIST
3158: LIST
3159: PUSH
3160: EMPTY
3161: LIST
3162: LIST
3163: LIST
3164: PUSH
3165: EMPTY
3166: LIST
3167: PPUSH
3168: CALL_OW 69
3172: ST_TO_ADDR
// x := SpeedFilter ( FilterAllUnits ( [ f_enemy , 1 ] ) , 20 ) ;
3173: LD_ADDR_VAR 0 3
3177: PUSH
3178: LD_INT 81
3180: PUSH
3181: LD_INT 1
3183: PUSH
3184: EMPTY
3185: LIST
3186: LIST
3187: PPUSH
3188: CALL_OW 69
3192: PPUSH
3193: LD_INT 20
3195: PPUSH
3196: CALL 8430 0 2
3200: ST_TO_ADDR
// for i = 1 to filter do
3201: LD_ADDR_VAR 0 1
3205: PUSH
3206: DOUBLE
3207: LD_INT 1
3209: DEC
3210: ST_TO_ADDR
3211: LD_VAR 0 4
3215: PUSH
3216: FOR_TO
3217: IFFALSE 3257
// ComAttackUnit ( filter [ i ] , NearestUnitToUnit ( x , filter [ i ] ) ) ;
3219: LD_VAR 0 4
3223: PUSH
3224: LD_VAR 0 1
3228: ARRAY
3229: PPUSH
3230: LD_VAR 0 3
3234: PPUSH
3235: LD_VAR 0 4
3239: PUSH
3240: LD_VAR 0 1
3244: ARRAY
3245: PPUSH
3246: CALL_OW 74
3250: PPUSH
3251: CALL_OW 115
3255: GO 3216
3257: POP
3258: POP
// end ; if FilterAllUnits ( [ [ [ f_side , 2 ] , [ f_weapon , ar_bio_bomb ] , [ f_not , [ f_lives , 700 ] ] ] ] ) > 0 then
3259: LD_INT 22
3261: PUSH
3262: LD_INT 2
3264: PUSH
3265: EMPTY
3266: LIST
3267: LIST
3268: PUSH
3269: LD_INT 34
3271: PUSH
3272: LD_EXP 56
3276: PUSH
3277: EMPTY
3278: LIST
3279: LIST
3280: PUSH
3281: LD_INT 3
3283: PUSH
3284: LD_INT 24
3286: PUSH
3287: LD_INT 700
3289: PUSH
3290: EMPTY
3291: LIST
3292: LIST
3293: PUSH
3294: EMPTY
3295: LIST
3296: LIST
3297: PUSH
3298: EMPTY
3299: LIST
3300: LIST
3301: LIST
3302: PUSH
3303: EMPTY
3304: LIST
3305: PPUSH
3306: CALL_OW 69
3310: PUSH
3311: LD_INT 0
3313: GREATER
3314: IFFALSE 3413
// begin filter := FilterAllUnits ( [ [ [ f_side , 2 ] , [ f_weapon , ar_bio_bomb ] , [ f_not , [ f_lives , 700 ] ] ] ] ) ;
3316: LD_ADDR_VAR 0 4
3320: PUSH
3321: LD_INT 22
3323: PUSH
3324: LD_INT 2
3326: PUSH
3327: EMPTY
3328: LIST
3329: LIST
3330: PUSH
3331: LD_INT 34
3333: PUSH
3334: LD_EXP 56
3338: PUSH
3339: EMPTY
3340: LIST
3341: LIST
3342: PUSH
3343: LD_INT 3
3345: PUSH
3346: LD_INT 24
3348: PUSH
3349: LD_INT 700
3351: PUSH
3352: EMPTY
3353: LIST
3354: LIST
3355: PUSH
3356: EMPTY
3357: LIST
3358: LIST
3359: PUSH
3360: EMPTY
3361: LIST
3362: LIST
3363: LIST
3364: PUSH
3365: EMPTY
3366: LIST
3367: PPUSH
3368: CALL_OW 69
3372: ST_TO_ADDR
// for i = 1 to filter do
3373: LD_ADDR_VAR 0 1
3377: PUSH
3378: DOUBLE
3379: LD_INT 1
3381: DEC
3382: ST_TO_ADDR
3383: LD_VAR 0 4
3387: PUSH
3388: FOR_TO
3389: IFFALSE 3411
// SetLives ( filter [ i ] , 1 ) ;
3391: LD_VAR 0 4
3395: PUSH
3396: LD_VAR 0 1
3400: ARRAY
3401: PPUSH
3402: LD_INT 1
3404: PPUSH
3405: CALL_OW 234
3409: GO 3388
3411: POP
3412: POP
// end ; end ; end_of_file
3413: PPOPN 4
3415: END
// export function Start_Mission ; begin
3416: LD_INT 0
3418: PPUSH
// PrepareLegion ;
3419: CALL 3460 0 0
// PrepareMeeting ;
3423: CALL 4077 0 0
// case Query ( DS-text-beg ) of 1 :
3427: LD_STRING DS-text-beg
3429: PPUSH
3430: CALL_OW 97
3434: PUSH
3435: LD_INT 1
3437: DOUBLE
3438: EQUAL
3439: IFTRUE 3443
3441: GO 3446
3443: POP
// ; end ;
3444: GO 3447
3446: POP
// game_on := true ;
3447: LD_ADDR_EXP 1
3451: PUSH
3452: LD_INT 1
3454: ST_TO_ADDR
// end ;
3455: LD_VAR 0 1
3459: RET
// export l_cmndr , l_skill , l_units ; function PrepareLegion ; var i , p , filter , team ; begin
3460: LD_INT 0
3462: PPUSH
3463: PPUSH
3464: PPUSH
3465: PPUSH
3466: PPUSH
// uc_side := 8 ;
3467: LD_ADDR_OWVAR 20
3471: PUSH
3472: LD_INT 8
3474: ST_TO_ADDR
// uc_nation := 2 ;
3475: LD_ADDR_OWVAR 21
3479: PUSH
3480: LD_INT 2
3482: ST_TO_ADDR
// l_skill := [ 7 , 6 , 5 ] [ difficulty ] ;
3483: LD_ADDR_EXP 50
3487: PUSH
3488: LD_INT 7
3490: PUSH
3491: LD_INT 6
3493: PUSH
3494: LD_INT 5
3496: PUSH
3497: EMPTY
3498: LIST
3499: LIST
3500: LIST
3501: PUSH
3502: LD_OWVAR 67
3506: ARRAY
3507: ST_TO_ADDR
// l_units := [ 8 , 7 , 6 ] [ difficulty ] ;
3508: LD_ADDR_EXP 51
3512: PUSH
3513: LD_INT 8
3515: PUSH
3516: LD_INT 7
3518: PUSH
3519: LD_INT 6
3521: PUSH
3522: EMPTY
3523: LIST
3524: LIST
3525: LIST
3526: PUSH
3527: LD_OWVAR 67
3531: ARRAY
3532: ST_TO_ADDR
// filter := [ ] ;
3533: LD_ADDR_VAR 0 4
3537: PUSH
3538: EMPTY
3539: ST_TO_ADDR
// hc_gallery := desert ;
3540: LD_ADDR_OWVAR 33
3544: PUSH
3545: LD_STRING desert
3547: ST_TO_ADDR
// hc_face_number := 1 ;
3548: LD_ADDR_OWVAR 34
3552: PUSH
3553: LD_INT 1
3555: ST_TO_ADDR
// hc_skills := [ l_skill + 2 , l_skill - 1 , l_skill , l_skill + 1 ] ;
3556: LD_ADDR_OWVAR 31
3560: PUSH
3561: LD_EXP 50
3565: PUSH
3566: LD_INT 2
3568: PLUS
3569: PUSH
3570: LD_EXP 50
3574: PUSH
3575: LD_INT 1
3577: MINUS
3578: PUSH
3579: LD_EXP 50
3583: PUSH
3584: LD_EXP 50
3588: PUSH
3589: LD_INT 1
3591: PLUS
3592: PUSH
3593: EMPTY
3594: LIST
3595: LIST
3596: LIST
3597: LIST
3598: ST_TO_ADDR
// hc_sex := sex_male ;
3599: LD_ADDR_OWVAR 27
3603: PUSH
3604: LD_INT 1
3606: ST_TO_ADDR
// hc_name := Henri Ruotz ;
3607: LD_ADDR_OWVAR 26
3611: PUSH
3612: LD_STRING Henri Ruotz
3614: ST_TO_ADDR
// hc_attr := [ 10 , 10 ] ;
3615: LD_ADDR_OWVAR 29
3619: PUSH
3620: LD_INT 10
3622: PUSH
3623: LD_INT 10
3625: PUSH
3626: EMPTY
3627: LIST
3628: LIST
3629: ST_TO_ADDR
// hc_class := 1 ;
3630: LD_ADDR_OWVAR 28
3634: PUSH
3635: LD_INT 1
3637: ST_TO_ADDR
// hc_importance := 100 ;
3638: LD_ADDR_OWVAR 32
3642: PUSH
3643: LD_INT 100
3645: ST_TO_ADDR
// l_cmndr := CreateHuman ;
3646: LD_ADDR_EXP 49
3650: PUSH
3651: CALL_OW 44
3655: ST_TO_ADDR
// hc_importance := 0 ;
3656: LD_ADDR_OWVAR 32
3660: PUSH
3661: LD_INT 0
3663: ST_TO_ADDR
// scout := PrepareHuman ( sex_male , 1 , 0 ) ;
3664: LD_ADDR_EXP 12
3668: PUSH
3669: LD_INT 1
3671: PPUSH
3672: LD_INT 1
3674: PPUSH
3675: LD_INT 0
3677: PPUSH
3678: CALL_OW 380
3682: ST_TO_ADDR
// for i = 1 to 4 do
3683: LD_ADDR_VAR 0 2
3687: PUSH
3688: DOUBLE
3689: LD_INT 1
3691: DEC
3692: ST_TO_ADDR
3693: LD_INT 4
3695: PUSH
3696: FOR_TO
3697: IFFALSE 3747
// for p = 1 to 6 do
3699: LD_ADDR_VAR 0 3
3703: PUSH
3704: DOUBLE
3705: LD_INT 1
3707: DEC
3708: ST_TO_ADDR
3709: LD_INT 6
3711: PUSH
3712: FOR_TO
3713: IFFALSE 3743
// filter := filter ^ CreateHumanWithClass ( i , l_skill ) ;
3715: LD_ADDR_VAR 0 4
3719: PUSH
3720: LD_VAR 0 4
3724: PUSH
3725: LD_VAR 0 2
3729: PPUSH
3730: LD_EXP 50
3734: PPUSH
3735: CALL 7231 0 2
3739: ADD
3740: ST_TO_ADDR
3741: GO 3712
3743: POP
3744: POP
3745: GO 3696
3747: POP
3748: POP
// team := CharacterSelection ( text , l_units , l_units , [ sel_change_class , l_cmndr , sel_changeable , sel_not_hired ] ^ filter , [ class_soldier , class_mechanic , class_engineer , class_scientistic , class_mortar ] ) ;
3749: LD_ADDR_VAR 0 5
3753: PUSH
3754: LD_STRING text
3756: PPUSH
3757: LD_EXP 51
3761: PPUSH
3762: LD_EXP 51
3766: PPUSH
3767: LD_INT -5
3769: PUSH
3770: LD_EXP 49
3774: PUSH
3775: LD_INT -3
3777: PUSH
3778: LD_INT -2
3780: PUSH
3781: EMPTY
3782: LIST
3783: LIST
3784: LIST
3785: LIST
3786: PUSH
3787: LD_VAR 0 4
3791: ADD
3792: PPUSH
3793: LD_INT 1
3795: PUSH
3796: LD_INT 3
3798: PUSH
3799: LD_INT 2
3801: PUSH
3802: LD_INT 4
3804: PUSH
3805: LD_INT 8
3807: PUSH
3808: EMPTY
3809: LIST
3810: LIST
3811: LIST
3812: LIST
3813: LIST
3814: PPUSH
3815: CALL_OW 42
3819: ST_TO_ADDR
// for i = 1 to l_units do
3820: LD_ADDR_VAR 0 2
3824: PUSH
3825: DOUBLE
3826: LD_INT 1
3828: DEC
3829: ST_TO_ADDR
3830: LD_EXP 51
3834: PUSH
3835: FOR_TO
3836: IFFALSE 3861
// PlaceUnitArea ( team [ i ] , legion_spawn , false ) ;
3838: LD_VAR 0 5
3842: PUSH
3843: LD_VAR 0 2
3847: ARRAY
3848: PPUSH
3849: LD_INT 1
3851: PPUSH
3852: LD_INT 0
3854: PPUSH
3855: CALL_OW 49
3859: GO 3835
3861: POP
3862: POP
// PlaceUnitArea ( l_cmndr , legion_spawn , false ) ;
3863: LD_EXP 49
3867: PPUSH
3868: LD_INT 1
3870: PPUSH
3871: LD_INT 0
3873: PPUSH
3874: CALL_OW 49
// end ;
3878: LD_VAR 0 1
3882: RET
// export function PlaceCamera ; begin
3883: LD_INT 0
3885: PPUSH
// PlaceSeeing ( 46 , 48 , 8 , 10 ) ;
3886: LD_INT 46
3888: PPUSH
3889: LD_INT 48
3891: PPUSH
3892: LD_INT 8
3894: PPUSH
3895: LD_INT 10
3897: PPUSH
3898: CALL_OW 330
// PlaceSeeing ( 58 , 66 , 8 , 10 ) ;
3902: LD_INT 58
3904: PPUSH
3905: LD_INT 66
3907: PPUSH
3908: LD_INT 8
3910: PPUSH
3911: LD_INT 10
3913: PPUSH
3914: CALL_OW 330
// PlaceSeeing ( 82 , 82 , 8 , 10 ) ;
3918: LD_INT 82
3920: PPUSH
3921: LD_INT 82
3923: PPUSH
3924: LD_INT 8
3926: PPUSH
3927: LD_INT 10
3929: PPUSH
3930: CALL_OW 330
// PlaceSeeing ( 107 , 79 , 8 , 10 ) ;
3934: LD_INT 107
3936: PPUSH
3937: LD_INT 79
3939: PPUSH
3940: LD_INT 8
3942: PPUSH
3943: LD_INT 10
3945: PPUSH
3946: CALL_OW 330
// PlaceSeeing ( 101 , 57 , 8 , 10 ) ;
3950: LD_INT 101
3952: PPUSH
3953: LD_INT 57
3955: PPUSH
3956: LD_INT 8
3958: PPUSH
3959: LD_INT 10
3961: PPUSH
3962: CALL_OW 330
// PlaceSeeing ( 85 , 32 , 8 , 10 ) ;
3966: LD_INT 85
3968: PPUSH
3969: LD_INT 32
3971: PPUSH
3972: LD_INT 8
3974: PPUSH
3975: LD_INT 10
3977: PPUSH
3978: CALL_OW 330
// PlaceSeeing ( 108 , 72 , 8 , 10 ) ;
3982: LD_INT 108
3984: PPUSH
3985: LD_INT 72
3987: PPUSH
3988: LD_INT 8
3990: PPUSH
3991: LD_INT 10
3993: PPUSH
3994: CALL_OW 330
// PlaceSeeing ( 124 , 74 , 8 , 10 ) ;
3998: LD_INT 124
4000: PPUSH
4001: LD_INT 74
4003: PPUSH
4004: LD_INT 8
4006: PPUSH
4007: LD_INT 10
4009: PPUSH
4010: CALL_OW 330
// PlaceSeeing ( 67 , 33 , 8 , 20 ) ;
4014: LD_INT 67
4016: PPUSH
4017: LD_INT 33
4019: PPUSH
4020: LD_INT 8
4022: PPUSH
4023: LD_INT 20
4025: PPUSH
4026: CALL_OW 330
// RemoveSeeing ( 67 , 33 , 8 ) ;
4030: LD_INT 67
4032: PPUSH
4033: LD_INT 33
4035: PPUSH
4036: LD_INT 8
4038: PPUSH
4039: CALL_OW 331
// PlaceSeeing ( 94 , 84 , 8 , 20 ) ;
4043: LD_INT 94
4045: PPUSH
4046: LD_INT 84
4048: PPUSH
4049: LD_INT 8
4051: PPUSH
4052: LD_INT 20
4054: PPUSH
4055: CALL_OW 330
// RemoveSeeing ( 94 , 84 , 8 ) ;
4059: LD_INT 94
4061: PPUSH
4062: LD_INT 84
4064: PPUSH
4065: LD_INT 8
4067: PPUSH
4068: CALL_OW 331
// end ;
4072: LD_VAR 0 1
4076: RET
// export function PrepareMeeting ; begin
4077: LD_INT 0
4079: PPUSH
// uc_side := 6 ;
4080: LD_ADDR_OWVAR 20
4084: PUSH
4085: LD_INT 6
4087: ST_TO_ADDR
// hc_gallery := desert ;
4088: LD_ADDR_OWVAR 33
4092: PUSH
4093: LD_STRING desert
4095: ST_TO_ADDR
// hc_face_number := 2 ;
4096: LD_ADDR_OWVAR 34
4100: PUSH
4101: LD_INT 2
4103: ST_TO_ADDR
// hc_name := Leopold Drass ;
4104: LD_ADDR_OWVAR 26
4108: PUSH
4109: LD_STRING Leopold Drass
4111: ST_TO_ADDR
// hc_class := 1 ;
4112: LD_ADDR_OWVAR 28
4116: PUSH
4117: LD_INT 1
4119: ST_TO_ADDR
// hc_sex := sex_male ;
4120: LD_ADDR_OWVAR 27
4124: PUSH
4125: LD_INT 1
4127: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
4128: LD_ADDR_OWVAR 29
4132: PUSH
4133: LD_INT 12
4135: PUSH
4136: LD_INT 12
4138: PUSH
4139: EMPTY
4140: LIST
4141: LIST
4142: ST_TO_ADDR
// Leopold := CreateHuman ;
4143: LD_ADDR_EXP 7
4147: PUSH
4148: CALL_OW 44
4152: ST_TO_ADDR
// PlaceUnitArea ( Leopold , north_spawn , false ) ;
4153: LD_EXP 7
4157: PPUSH
4158: LD_INT 3
4160: PPUSH
4161: LD_INT 0
4163: PPUSH
4164: CALL_OW 49
// end ; end_of_file
4168: LD_VAR 0 1
4172: RET
// on SailEvent ( num ) do var i , filter , un , p , area ;
4173: LD_INT 0
4175: PPUSH
4176: PPUSH
4177: PPUSH
4178: PPUSH
4179: PPUSH
// begin case num of 1 :
4180: LD_VAR 0 1
4184: PUSH
4185: LD_INT 1
4187: DOUBLE
4188: EQUAL
4189: IFTRUE 4193
4191: GO 4225
4193: POP
// begin ComMoveXY ( leopold , GetX ( l_cmndr ) , GetY ( l_cmndr ) ) ;
4194: LD_EXP 7
4198: PPUSH
4199: LD_EXP 49
4203: PPUSH
4204: CALL_OW 250
4208: PPUSH
4209: LD_EXP 49
4213: PPUSH
4214: CALL_OW 251
4218: PPUSH
4219: CALL_OW 111
// end ; 2 :
4223: GO 6643
4225: LD_INT 2
4227: DOUBLE
4228: EQUAL
4229: IFTRUE 4233
4231: GO 4342
4233: POP
// begin InGameOn ;
4234: CALL_OW 8
// meeting_start := true ;
4238: LD_ADDR_EXP 26
4242: PUSH
4243: LD_INT 1
4245: ST_TO_ADDR
// ComTurnUnit ( leopold , l_cmndr ) ;
4246: LD_EXP 7
4250: PPUSH
4251: LD_EXP 49
4255: PPUSH
4256: CALL_OW 119
// ComTurnUnit ( l_cmndr , leopold ) ;
4260: LD_EXP 49
4264: PPUSH
4265: LD_EXP 7
4269: PPUSH
4270: CALL_OW 119
// Say ( leopold , DS-DL-1 ) ;
4274: LD_EXP 7
4278: PPUSH
4279: LD_STRING DS-DL-1
4281: PPUSH
4282: CALL_OW 88
// Say ( l_cmndr , DS-DC-1 ) ;
4286: LD_EXP 49
4290: PPUSH
4291: LD_STRING DS-DC-1
4293: PPUSH
4294: CALL_OW 88
// Say ( leopold , DS-DL-2 ) ;
4298: LD_EXP 7
4302: PPUSH
4303: LD_STRING DS-DL-2
4305: PPUSH
4306: CALL_OW 88
// ComEnterUnit ( leopold , fort ) ;
4310: LD_EXP 7
4314: PPUSH
4315: LD_INT 23
4317: PPUSH
4318: CALL_OW 120
// InGameOff ;
4322: CALL_OW 9
// Wait ( 0 0$01 ) ;
4326: LD_INT 35
4328: PPUSH
4329: CALL_OW 67
// ChangeMissionObjectives ( DS-T1 ) ;
4333: LD_STRING DS-T1
4335: PPUSH
4336: CALL_OW 337
// end ; 10 :
4340: GO 6643
4342: LD_INT 10
4344: DOUBLE
4345: EQUAL
4346: IFTRUE 4350
4348: GO 4562
4350: POP
// begin uc_side := 6 ;
4351: LD_ADDR_OWVAR 20
4355: PUSH
4356: LD_INT 6
4358: ST_TO_ADDR
// uc_nation := 2 ;
4359: LD_ADDR_OWVAR 21
4363: PUSH
4364: LD_INT 2
4366: ST_TO_ADDR
// hc_gallery :=  ;
4367: LD_ADDR_OWVAR 33
4371: PUSH
4372: LD_STRING 
4374: ST_TO_ADDR
// hc_skills := [ skill + 2 , skill - 1 , skill , skill + 1 ] ;
4375: LD_ADDR_OWVAR 31
4379: PUSH
4380: LD_EXP 16
4384: PUSH
4385: LD_INT 2
4387: PLUS
4388: PUSH
4389: LD_EXP 16
4393: PUSH
4394: LD_INT 1
4396: MINUS
4397: PUSH
4398: LD_EXP 16
4402: PUSH
4403: LD_EXP 16
4407: PUSH
4408: LD_INT 1
4410: PLUS
4411: PUSH
4412: EMPTY
4413: LIST
4414: LIST
4415: LIST
4416: LIST
4417: ST_TO_ADDR
// hc_sex := sex_male ;
4418: LD_ADDR_OWVAR 27
4422: PUSH
4423: LD_INT 1
4425: ST_TO_ADDR
// hc_name := Samuel van Horn ;
4426: LD_ADDR_OWVAR 26
4430: PUSH
4431: LD_STRING Samuel van Horn
4433: ST_TO_ADDR
// hc_attr := [ 11 , 10 ] ;
4434: LD_ADDR_OWVAR 29
4438: PUSH
4439: LD_INT 11
4441: PUSH
4442: LD_INT 10
4444: PUSH
4445: EMPTY
4446: LIST
4447: LIST
4448: ST_TO_ADDR
// hc_class := 1 ;
4449: LD_ADDR_OWVAR 28
4453: PUSH
4454: LD_INT 1
4456: ST_TO_ADDR
// samuel := CreateHuman ;
4457: LD_ADDR_EXP 9
4461: PUSH
4462: CALL_OW 44
4466: ST_TO_ADDR
// PlaceUnitArea ( samuel , south_spawn , false ) ;
4467: LD_EXP 9
4471: PPUSH
4472: LD_INT 4
4474: PPUSH
4475: LD_INT 0
4477: PPUSH
4478: CALL_OW 49
// for i = 1 to 3 do
4482: LD_ADDR_VAR 0 2
4486: PUSH
4487: DOUBLE
4488: LD_INT 1
4490: DEC
4491: ST_TO_ADDR
4492: LD_INT 3
4494: PUSH
4495: FOR_TO
4496: IFFALSE 4523
// PlaceUnitArea ( CreateHumanWithClass ( class_mortar , skill ) , south_spawn , false ) ;
4498: LD_INT 8
4500: PPUSH
4501: LD_EXP 16
4505: PPUSH
4506: CALL 7231 0 2
4510: PPUSH
4511: LD_INT 4
4513: PPUSH
4514: LD_INT 0
4516: PPUSH
4517: CALL_OW 49
4521: GO 4495
4523: POP
4524: POP
// ComEnterUnit ( FilterAllUnits ( [ f_side , 6 ] ) diff [ leopold , fort ] , fort ) ;
4525: LD_INT 22
4527: PUSH
4528: LD_INT 6
4530: PUSH
4531: EMPTY
4532: LIST
4533: LIST
4534: PPUSH
4535: CALL_OW 69
4539: PUSH
4540: LD_EXP 7
4544: PUSH
4545: LD_INT 23
4547: PUSH
4548: EMPTY
4549: LIST
4550: LIST
4551: DIFF
4552: PPUSH
4553: LD_INT 23
4555: PPUSH
4556: CALL_OW 120
// end ; 3 :
4560: GO 6643
4562: LD_INT 3
4564: DOUBLE
4565: EQUAL
4566: IFTRUE 4570
4568: GO 4581
4570: POP
// begin arabian_attack := true ;
4571: LD_ADDR_EXP 38
4575: PUSH
4576: LD_INT 1
4578: ST_TO_ADDR
// end ; 4 :
4579: GO 6643
4581: LD_INT 4
4583: DOUBLE
4584: EQUAL
4585: IFTRUE 4589
4587: GO 4600
4589: POP
// begin american_attack := true ;
4590: LD_ADDR_EXP 40
4594: PUSH
4595: LD_INT 1
4597: ST_TO_ADDR
// end ; 5 :
4598: GO 6643
4600: LD_INT 5
4602: DOUBLE
4603: EQUAL
4604: IFTRUE 4608
4606: GO 4619
4608: POP
// begin russian_attack := true ;
4609: LD_ADDR_EXP 39
4613: PUSH
4614: LD_INT 1
4616: ST_TO_ADDR
// end ; 31 :
4617: GO 6643
4619: LD_INT 31
4621: DOUBLE
4622: EQUAL
4623: IFTRUE 4627
4625: GO 4902
4627: POP
// begin area := areas [ Rand ( 1 , areas ) ] ;
4628: LD_ADDR_VAR 0 6
4632: PUSH
4633: LD_EXP 15
4637: PUSH
4638: LD_INT 1
4640: PPUSH
4641: LD_EXP 15
4645: PPUSH
4646: CALL_OW 12
4650: ARRAY
4651: ST_TO_ADDR
// uc_side := 2 ;
4652: LD_ADDR_OWVAR 20
4656: PUSH
4657: LD_INT 2
4659: ST_TO_ADDR
// uc_nation := 2 ;
4660: LD_ADDR_OWVAR 21
4664: PUSH
4665: LD_INT 2
4667: ST_TO_ADDR
// for i = 1 to arabian_force do
4668: LD_ADDR_VAR 0 2
4672: PUSH
4673: DOUBLE
4674: LD_INT 1
4676: DEC
4677: ST_TO_ADDR
4678: LD_EXP 20
4682: PUSH
4683: FOR_TO
4684: IFFALSE 4763
// begin vc_chassis := ar_half_tracked ;
4686: LD_ADDR_OWVAR 37
4690: PUSH
4691: LD_INT 14
4693: ST_TO_ADDR
// vc_engine := engine_siberite ;
4694: LD_ADDR_OWVAR 39
4698: PUSH
4699: LD_INT 3
4701: ST_TO_ADDR
// vc_control := control_remote ;
4702: LD_ADDR_OWVAR 38
4706: PUSH
4707: LD_INT 2
4709: ST_TO_ADDR
// vc_weapon := ar_weapons [ Rand ( 1 , ar_weapons ) ] ;
4710: LD_ADDR_OWVAR 40
4714: PUSH
4715: LD_EXP 17
4719: PUSH
4720: LD_INT 1
4722: PPUSH
4723: LD_EXP 17
4727: PPUSH
4728: CALL_OW 12
4732: ARRAY
4733: ST_TO_ADDR
// un := CreateVehicle ;
4734: LD_ADDR_VAR 0 4
4738: PUSH
4739: CALL_OW 45
4743: ST_TO_ADDR
// PlaceUnitArea ( un , area , false ) ;
4744: LD_VAR 0 4
4748: PPUSH
4749: LD_VAR 0 6
4753: PPUSH
4754: LD_INT 0
4756: PPUSH
4757: CALL_OW 49
// end ;
4761: GO 4683
4763: POP
4764: POP
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_control , control_manual ] ] ) < 2 then
4765: LD_INT 22
4767: PUSH
4768: LD_INT 2
4770: PUSH
4771: EMPTY
4772: LIST
4773: LIST
4774: PUSH
4775: LD_INT 33
4777: PUSH
4778: LD_INT 1
4780: PUSH
4781: EMPTY
4782: LIST
4783: LIST
4784: PUSH
4785: EMPTY
4786: LIST
4787: LIST
4788: PPUSH
4789: CALL_OW 69
4793: PUSH
4794: LD_INT 2
4796: LESS
4797: IFFALSE 4900
// for i = 1 to 2 do
4799: LD_ADDR_VAR 0 2
4803: PUSH
4804: DOUBLE
4805: LD_INT 1
4807: DEC
4808: ST_TO_ADDR
4809: LD_INT 2
4811: PUSH
4812: FOR_TO
4813: IFFALSE 4898
// begin vc_chassis := ar_half_tracked ;
4815: LD_ADDR_OWVAR 37
4819: PUSH
4820: LD_INT 14
4822: ST_TO_ADDR
// vc_engine := engine_siberite ;
4823: LD_ADDR_OWVAR 39
4827: PUSH
4828: LD_INT 3
4830: ST_TO_ADDR
// vc_control := control_manual ;
4831: LD_ADDR_OWVAR 38
4835: PUSH
4836: LD_INT 1
4838: ST_TO_ADDR
// vc_weapon := ar_control_tower ;
4839: LD_ADDR_OWVAR 40
4843: PUSH
4844: LD_INT 31
4846: ST_TO_ADDR
// un := CreateVehicle ;
4847: LD_ADDR_VAR 0 4
4851: PUSH
4852: CALL_OW 45
4856: ST_TO_ADDR
// PlaceUnitArea ( un , area , false ) ;
4857: LD_VAR 0 4
4861: PPUSH
4862: LD_VAR 0 6
4866: PPUSH
4867: LD_INT 0
4869: PPUSH
4870: CALL_OW 49
// PlaceHumanInUnit ( CreateHumanWithClass ( 3 , skill ) , un ) ;
4874: LD_INT 3
4876: PPUSH
4877: LD_EXP 16
4881: PPUSH
4882: CALL 7231 0 2
4886: PPUSH
4887: LD_VAR 0 4
4891: PPUSH
4892: CALL_OW 52
// end ;
4896: GO 4812
4898: POP
4899: POP
// end ; 32 :
4900: GO 6643
4902: LD_INT 32
4904: DOUBLE
4905: EQUAL
4906: IFTRUE 4910
4908: GO 5283
4910: POP
// begin area := areas [ Rand ( 1 , areas ) ] ;
4911: LD_ADDR_VAR 0 6
4915: PUSH
4916: LD_EXP 15
4920: PUSH
4921: LD_INT 1
4923: PPUSH
4924: LD_EXP 15
4928: PPUSH
4929: CALL_OW 12
4933: ARRAY
4934: ST_TO_ADDR
// uc_side := 2 ;
4935: LD_ADDR_OWVAR 20
4939: PUSH
4940: LD_INT 2
4942: ST_TO_ADDR
// uc_nation := 2 ;
4943: LD_ADDR_OWVAR 21
4947: PUSH
4948: LD_INT 2
4950: ST_TO_ADDR
// for i = 1 to ( arabian_force - 2 ) do
4951: LD_ADDR_VAR 0 2
4955: PUSH
4956: DOUBLE
4957: LD_INT 1
4959: DEC
4960: ST_TO_ADDR
4961: LD_EXP 20
4965: PUSH
4966: LD_INT 2
4968: MINUS
4969: PUSH
4970: FOR_TO
4971: IFFALSE 5054
// begin vc_chassis := ar_half_tracked ;
4973: LD_ADDR_OWVAR 37
4977: PUSH
4978: LD_INT 14
4980: ST_TO_ADDR
// vc_engine := engine_siberite ;
4981: LD_ADDR_OWVAR 39
4985: PUSH
4986: LD_INT 3
4988: ST_TO_ADDR
// vc_control := control_remote ;
4989: LD_ADDR_OWVAR 38
4993: PUSH
4994: LD_INT 2
4996: ST_TO_ADDR
// vc_weapon := ar_weapons [ Rand ( 1 , ar_weapons - 1 ) ] ;
4997: LD_ADDR_OWVAR 40
5001: PUSH
5002: LD_EXP 17
5006: PUSH
5007: LD_INT 1
5009: PPUSH
5010: LD_EXP 17
5014: PUSH
5015: LD_INT 1
5017: MINUS
5018: PPUSH
5019: CALL_OW 12
5023: ARRAY
5024: ST_TO_ADDR
// un := CreateVehicle ;
5025: LD_ADDR_VAR 0 4
5029: PUSH
5030: CALL_OW 45
5034: ST_TO_ADDR
// PlaceUnitArea ( un , area , false ) ;
5035: LD_VAR 0 4
5039: PPUSH
5040: LD_VAR 0 6
5044: PPUSH
5045: LD_INT 0
5047: PPUSH
5048: CALL_OW 49
// end ;
5052: GO 4970
5054: POP
5055: POP
// for i = 1 to Rand ( 0 , 1 ) + [ 3 , 4 , 5 ] [ game_difficulty ] do
5056: LD_ADDR_VAR 0 2
5060: PUSH
5061: DOUBLE
5062: LD_INT 1
5064: DEC
5065: ST_TO_ADDR
5066: LD_INT 0
5068: PPUSH
5069: LD_INT 1
5071: PPUSH
5072: CALL_OW 12
5076: PUSH
5077: LD_INT 3
5079: PUSH
5080: LD_INT 4
5082: PUSH
5083: LD_INT 5
5085: PUSH
5086: EMPTY
5087: LIST
5088: LIST
5089: LIST
5090: PUSH
5091: LD_EXP 2
5095: ARRAY
5096: PLUS
5097: PUSH
5098: FOR_TO
5099: IFFALSE 5136
// begin uc_nation := 0 ;
5101: LD_ADDR_OWVAR 21
5105: PUSH
5106: LD_INT 0
5108: ST_TO_ADDR
// PlaceUnitArea ( CreateHumanWithClass ( 17 , skill ) , area , false ) ;
5109: LD_INT 17
5111: PPUSH
5112: LD_EXP 16
5116: PPUSH
5117: CALL 7231 0 2
5121: PPUSH
5122: LD_VAR 0 6
5126: PPUSH
5127: LD_INT 0
5129: PPUSH
5130: CALL_OW 49
// end ;
5134: GO 5098
5136: POP
5137: POP
// uc_nation := 2 ;
5138: LD_ADDR_OWVAR 21
5142: PUSH
5143: LD_INT 2
5145: ST_TO_ADDR
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_control , control_manual ] ] ) < 2 then
5146: LD_INT 22
5148: PUSH
5149: LD_INT 2
5151: PUSH
5152: EMPTY
5153: LIST
5154: LIST
5155: PUSH
5156: LD_INT 33
5158: PUSH
5159: LD_INT 1
5161: PUSH
5162: EMPTY
5163: LIST
5164: LIST
5165: PUSH
5166: EMPTY
5167: LIST
5168: LIST
5169: PPUSH
5170: CALL_OW 69
5174: PUSH
5175: LD_INT 2
5177: LESS
5178: IFFALSE 5281
// for i = 1 to 2 do
5180: LD_ADDR_VAR 0 2
5184: PUSH
5185: DOUBLE
5186: LD_INT 1
5188: DEC
5189: ST_TO_ADDR
5190: LD_INT 2
5192: PUSH
5193: FOR_TO
5194: IFFALSE 5279
// begin vc_chassis := ar_half_tracked ;
5196: LD_ADDR_OWVAR 37
5200: PUSH
5201: LD_INT 14
5203: ST_TO_ADDR
// vc_engine := engine_siberite ;
5204: LD_ADDR_OWVAR 39
5208: PUSH
5209: LD_INT 3
5211: ST_TO_ADDR
// vc_control := control_manual ;
5212: LD_ADDR_OWVAR 38
5216: PUSH
5217: LD_INT 1
5219: ST_TO_ADDR
// vc_weapon := ar_control_tower ;
5220: LD_ADDR_OWVAR 40
5224: PUSH
5225: LD_INT 31
5227: ST_TO_ADDR
// un := CreateVehicle ;
5228: LD_ADDR_VAR 0 4
5232: PUSH
5233: CALL_OW 45
5237: ST_TO_ADDR
// PlaceUnitArea ( un , area , false ) ;
5238: LD_VAR 0 4
5242: PPUSH
5243: LD_VAR 0 6
5247: PPUSH
5248: LD_INT 0
5250: PPUSH
5251: CALL_OW 49
// PlaceHumanInUnit ( CreateHumanWithClass ( 3 , skill ) , un ) ;
5255: LD_INT 3
5257: PPUSH
5258: LD_EXP 16
5262: PPUSH
5263: CALL 7231 0 2
5267: PPUSH
5268: LD_VAR 0 4
5272: PPUSH
5273: CALL_OW 52
// end ;
5277: GO 5193
5279: POP
5280: POP
// end ; 33 :
5281: GO 6643
5283: LD_INT 33
5285: DOUBLE
5286: EQUAL
5287: IFTRUE 5291
5289: GO 5562
5291: POP
// begin area := areas [ Rand ( 1 , areas ) ] ;
5292: LD_ADDR_VAR 0 6
5296: PUSH
5297: LD_EXP 15
5301: PUSH
5302: LD_INT 1
5304: PPUSH
5305: LD_EXP 15
5309: PPUSH
5310: CALL_OW 12
5314: ARRAY
5315: ST_TO_ADDR
// uc_side := 2 ;
5316: LD_ADDR_OWVAR 20
5320: PUSH
5321: LD_INT 2
5323: ST_TO_ADDR
// uc_nation := 2 ;
5324: LD_ADDR_OWVAR 21
5328: PUSH
5329: LD_INT 2
5331: ST_TO_ADDR
// for i = 1 to ( arabian_force / 2 ) do
5332: LD_ADDR_VAR 0 2
5336: PUSH
5337: DOUBLE
5338: LD_INT 1
5340: DEC
5341: ST_TO_ADDR
5342: LD_EXP 20
5346: PUSH
5347: LD_INT 2
5349: DIVREAL
5350: PUSH
5351: FOR_TO
5352: IFFALSE 5457
// begin vc_chassis := ar_half_tracked ;
5354: LD_ADDR_OWVAR 37
5358: PUSH
5359: LD_INT 14
5361: ST_TO_ADDR
// vc_engine := engine_siberite ;
5362: LD_ADDR_OWVAR 39
5366: PUSH
5367: LD_INT 3
5369: ST_TO_ADDR
// vc_control := control_manual ;
5370: LD_ADDR_OWVAR 38
5374: PUSH
5375: LD_INT 1
5377: ST_TO_ADDR
// vc_weapon := ar_weapons [ Rand ( 1 , ar_weapons - 2 ) ] ;
5378: LD_ADDR_OWVAR 40
5382: PUSH
5383: LD_EXP 17
5387: PUSH
5388: LD_INT 1
5390: PPUSH
5391: LD_EXP 17
5395: PUSH
5396: LD_INT 2
5398: MINUS
5399: PPUSH
5400: CALL_OW 12
5404: ARRAY
5405: ST_TO_ADDR
// un := CreateVehicle ;
5406: LD_ADDR_VAR 0 4
5410: PUSH
5411: CALL_OW 45
5415: ST_TO_ADDR
// PlaceUnitArea ( un , area , false ) ;
5416: LD_VAR 0 4
5420: PPUSH
5421: LD_VAR 0 6
5425: PPUSH
5426: LD_INT 0
5428: PPUSH
5429: CALL_OW 49
// PlaceHumanInUnit ( CreateHumanWithClass ( 3 , skill ) , un ) ;
5433: LD_INT 3
5435: PPUSH
5436: LD_EXP 16
5440: PPUSH
5441: CALL 7231 0 2
5445: PPUSH
5446: LD_VAR 0 4
5450: PPUSH
5451: CALL_OW 52
// end ;
5455: GO 5351
5457: POP
5458: POP
// for i = 1 to ( arabian_force / 2 ) do
5459: LD_ADDR_VAR 0 2
5463: PUSH
5464: DOUBLE
5465: LD_INT 1
5467: DEC
5468: ST_TO_ADDR
5469: LD_EXP 20
5473: PUSH
5474: LD_INT 2
5476: DIVREAL
5477: PUSH
5478: FOR_TO
5479: IFFALSE 5558
// begin vc_chassis := ar_half_tracked ;
5481: LD_ADDR_OWVAR 37
5485: PUSH
5486: LD_INT 14
5488: ST_TO_ADDR
// vc_engine := engine_siberite ;
5489: LD_ADDR_OWVAR 39
5493: PUSH
5494: LD_INT 3
5496: ST_TO_ADDR
// vc_control := control_apeman ;
5497: LD_ADDR_OWVAR 38
5501: PUSH
5502: LD_INT 5
5504: ST_TO_ADDR
// vc_weapon := ar_weapons [ Rand ( 2 , ar_weapons ) ] ;
5505: LD_ADDR_OWVAR 40
5509: PUSH
5510: LD_EXP 17
5514: PUSH
5515: LD_INT 2
5517: PPUSH
5518: LD_EXP 17
5522: PPUSH
5523: CALL_OW 12
5527: ARRAY
5528: ST_TO_ADDR
// un := CreateVehicle ;
5529: LD_ADDR_VAR 0 4
5533: PUSH
5534: CALL_OW 45
5538: ST_TO_ADDR
// PlaceUnitArea ( un , area , false ) ;
5539: LD_VAR 0 4
5543: PPUSH
5544: LD_VAR 0 6
5548: PPUSH
5549: LD_INT 0
5551: PPUSH
5552: CALL_OW 49
// end ;
5556: GO 5478
5558: POP
5559: POP
// end ; 41 :
5560: GO 6643
5562: LD_INT 41
5564: DOUBLE
5565: EQUAL
5566: IFTRUE 5570
5568: GO 5714
5570: POP
// begin area := areas [ Rand ( 1 , areas ) ] ;
5571: LD_ADDR_VAR 0 6
5575: PUSH
5576: LD_EXP 15
5580: PUSH
5581: LD_INT 1
5583: PPUSH
5584: LD_EXP 15
5588: PPUSH
5589: CALL_OW 12
5593: ARRAY
5594: ST_TO_ADDR
// uc_side := 1 ;
5595: LD_ADDR_OWVAR 20
5599: PUSH
5600: LD_INT 1
5602: ST_TO_ADDR
// uc_nation := 1 ;
5603: LD_ADDR_OWVAR 21
5607: PUSH
5608: LD_INT 1
5610: ST_TO_ADDR
// for i = 1 to american_force do
5611: LD_ADDR_VAR 0 2
5615: PUSH
5616: DOUBLE
5617: LD_INT 1
5619: DEC
5620: ST_TO_ADDR
5621: LD_EXP 22
5625: PUSH
5626: FOR_TO
5627: IFFALSE 5710
// begin vc_chassis := us_morphling ;
5629: LD_ADDR_OWVAR 37
5633: PUSH
5634: LD_INT 5
5636: ST_TO_ADDR
// vc_engine := engine_siberite ;
5637: LD_ADDR_OWVAR 39
5641: PUSH
5642: LD_INT 3
5644: ST_TO_ADDR
// vc_control := control_computer ;
5645: LD_ADDR_OWVAR 38
5649: PUSH
5650: LD_INT 3
5652: ST_TO_ADDR
// vc_weapon := us_weapons [ Rand ( 1 , us_weapons - 1 ) ] ;
5653: LD_ADDR_OWVAR 40
5657: PUSH
5658: LD_EXP 19
5662: PUSH
5663: LD_INT 1
5665: PPUSH
5666: LD_EXP 19
5670: PUSH
5671: LD_INT 1
5673: MINUS
5674: PPUSH
5675: CALL_OW 12
5679: ARRAY
5680: ST_TO_ADDR
// un := CreateVehicle ;
5681: LD_ADDR_VAR 0 4
5685: PUSH
5686: CALL_OW 45
5690: ST_TO_ADDR
// PlaceUnitArea ( un , area , false ) ;
5691: LD_VAR 0 4
5695: PPUSH
5696: LD_VAR 0 6
5700: PPUSH
5701: LD_INT 0
5703: PPUSH
5704: CALL_OW 49
// end ;
5708: GO 5626
5710: POP
5711: POP
// end ; 42 :
5712: GO 6643
5714: LD_INT 42
5716: DOUBLE
5717: EQUAL
5718: IFTRUE 5722
5720: GO 5862
5722: POP
// begin area := areas [ Rand ( 1 , areas ) ] ;
5723: LD_ADDR_VAR 0 6
5727: PUSH
5728: LD_EXP 15
5732: PUSH
5733: LD_INT 1
5735: PPUSH
5736: LD_EXP 15
5740: PPUSH
5741: CALL_OW 12
5745: ARRAY
5746: ST_TO_ADDR
// uc_side := 1 ;
5747: LD_ADDR_OWVAR 20
5751: PUSH
5752: LD_INT 1
5754: ST_TO_ADDR
// uc_nation := 1 ;
5755: LD_ADDR_OWVAR 21
5759: PUSH
5760: LD_INT 1
5762: ST_TO_ADDR
// for i = 1 to american_force do
5763: LD_ADDR_VAR 0 2
5767: PUSH
5768: DOUBLE
5769: LD_INT 1
5771: DEC
5772: ST_TO_ADDR
5773: LD_EXP 22
5777: PUSH
5778: FOR_TO
5779: IFFALSE 5858
// begin vc_chassis := us_morphling ;
5781: LD_ADDR_OWVAR 37
5785: PUSH
5786: LD_INT 5
5788: ST_TO_ADDR
// vc_engine := engine_siberite ;
5789: LD_ADDR_OWVAR 39
5793: PUSH
5794: LD_INT 3
5796: ST_TO_ADDR
// vc_control := control_computer ;
5797: LD_ADDR_OWVAR 38
5801: PUSH
5802: LD_INT 3
5804: ST_TO_ADDR
// vc_weapon := us_weapons [ Rand ( 1 , us_weapons ) ] ;
5805: LD_ADDR_OWVAR 40
5809: PUSH
5810: LD_EXP 19
5814: PUSH
5815: LD_INT 1
5817: PPUSH
5818: LD_EXP 19
5822: PPUSH
5823: CALL_OW 12
5827: ARRAY
5828: ST_TO_ADDR
// un := CreateVehicle ;
5829: LD_ADDR_VAR 0 4
5833: PUSH
5834: CALL_OW 45
5838: ST_TO_ADDR
// PlaceUnitArea ( un , area , false ) ;
5839: LD_VAR 0 4
5843: PPUSH
5844: LD_VAR 0 6
5848: PPUSH
5849: LD_INT 0
5851: PPUSH
5852: CALL_OW 49
// end ;
5856: GO 5778
5858: POP
5859: POP
// end ; 51 :
5860: GO 6643
5862: LD_INT 51
5864: DOUBLE
5865: EQUAL
5866: IFTRUE 5870
5868: GO 6010
5870: POP
// begin area := areas [ Rand ( 1 , areas ) ] ;
5871: LD_ADDR_VAR 0 6
5875: PUSH
5876: LD_EXP 15
5880: PUSH
5881: LD_INT 1
5883: PPUSH
5884: LD_EXP 15
5888: PPUSH
5889: CALL_OW 12
5893: ARRAY
5894: ST_TO_ADDR
// uc_side := 3 ;
5895: LD_ADDR_OWVAR 20
5899: PUSH
5900: LD_INT 3
5902: ST_TO_ADDR
// uc_nation := 3 ;
5903: LD_ADDR_OWVAR 21
5907: PUSH
5908: LD_INT 3
5910: ST_TO_ADDR
// for i = 1 to russian_force do
5911: LD_ADDR_VAR 0 2
5915: PUSH
5916: DOUBLE
5917: LD_INT 1
5919: DEC
5920: ST_TO_ADDR
5921: LD_EXP 21
5925: PUSH
5926: FOR_TO
5927: IFFALSE 6006
// begin vc_chassis := ru_heavy_tracked ;
5929: LD_ADDR_OWVAR 37
5933: PUSH
5934: LD_INT 24
5936: ST_TO_ADDR
// vc_engine := engine_siberite ;
5937: LD_ADDR_OWVAR 39
5941: PUSH
5942: LD_INT 3
5944: ST_TO_ADDR
// vc_control := control_computer ;
5945: LD_ADDR_OWVAR 38
5949: PUSH
5950: LD_INT 3
5952: ST_TO_ADDR
// vc_weapon := ru_weapons [ Rand ( 1 , ru_weapons ) ] ;
5953: LD_ADDR_OWVAR 40
5957: PUSH
5958: LD_EXP 18
5962: PUSH
5963: LD_INT 1
5965: PPUSH
5966: LD_EXP 18
5970: PPUSH
5971: CALL_OW 12
5975: ARRAY
5976: ST_TO_ADDR
// un := CreateVehicle ;
5977: LD_ADDR_VAR 0 4
5981: PUSH
5982: CALL_OW 45
5986: ST_TO_ADDR
// PlaceUnitArea ( un , area , false ) ;
5987: LD_VAR 0 4
5991: PPUSH
5992: LD_VAR 0 6
5996: PPUSH
5997: LD_INT 0
5999: PPUSH
6000: CALL_OW 49
// end ;
6004: GO 5926
6006: POP
6007: POP
// end ; 91 :
6008: GO 6643
6010: LD_INT 91
6012: DOUBLE
6013: EQUAL
6014: IFTRUE 6018
6016: GO 6156
6018: POP
// begin uc_side := 8 ;
6019: LD_ADDR_OWVAR 20
6023: PUSH
6024: LD_INT 8
6026: ST_TO_ADDR
// uc_nation := 1 ;
6027: LD_ADDR_OWVAR 21
6031: PUSH
6032: LD_INT 1
6034: ST_TO_ADDR
// for i = 1 to [ 5 , 4 , 3 ] [ game_difficulty ] do
6035: LD_ADDR_VAR 0 2
6039: PUSH
6040: DOUBLE
6041: LD_INT 1
6043: DEC
6044: ST_TO_ADDR
6045: LD_INT 5
6047: PUSH
6048: LD_INT 4
6050: PUSH
6051: LD_INT 3
6053: PUSH
6054: EMPTY
6055: LIST
6056: LIST
6057: LIST
6058: PUSH
6059: LD_EXP 2
6063: ARRAY
6064: PUSH
6065: FOR_TO
6066: IFFALSE 6152
// begin vc_chassis := us_heavy_tracked ;
6068: LD_ADDR_OWVAR 37
6072: PUSH
6073: LD_INT 4
6075: ST_TO_ADDR
// vc_engine := engine_siberite ;
6076: LD_ADDR_OWVAR 39
6080: PUSH
6081: LD_INT 3
6083: ST_TO_ADDR
// vc_control := control_computer ;
6084: LD_ADDR_OWVAR 38
6088: PUSH
6089: LD_INT 3
6091: ST_TO_ADDR
// vc_weapon := [ us_double_gun , us_heavy_gun ] [ Rand ( 1 , 2 ) ] ;
6092: LD_ADDR_OWVAR 40
6096: PUSH
6097: LD_INT 5
6099: PUSH
6100: LD_INT 6
6102: PUSH
6103: EMPTY
6104: LIST
6105: LIST
6106: PUSH
6107: LD_INT 1
6109: PPUSH
6110: LD_INT 2
6112: PPUSH
6113: CALL_OW 12
6117: ARRAY
6118: ST_TO_ADDR
// un := CreateVehicle ;
6119: LD_ADDR_VAR 0 4
6123: PUSH
6124: CALL_OW 45
6128: ST_TO_ADDR
// PlaceUnitArea ( un , areas [ 1 ] , false ) ;
6129: LD_VAR 0 4
6133: PPUSH
6134: LD_EXP 15
6138: PUSH
6139: LD_INT 1
6141: ARRAY
6142: PPUSH
6143: LD_INT 0
6145: PPUSH
6146: CALL_OW 49
// end ;
6150: GO 6065
6152: POP
6153: POP
// end ; 92 :
6154: GO 6643
6156: LD_INT 92
6158: DOUBLE
6159: EQUAL
6160: IFTRUE 6164
6162: GO 6493
6164: POP
// begin uc_side := 5 ;
6165: LD_ADDR_OWVAR 20
6169: PUSH
6170: LD_INT 5
6172: ST_TO_ADDR
// uc_nation := 2 ;
6173: LD_ADDR_OWVAR 21
6177: PUSH
6178: LD_INT 2
6180: ST_TO_ADDR
// filter := [ ] ;
6181: LD_ADDR_VAR 0 3
6185: PUSH
6186: EMPTY
6187: ST_TO_ADDR
// InitHc ;
6188: CALL_OW 19
// PrepareHuman ( false , 1 , l_skill ) ;
6192: LD_INT 0
6194: PPUSH
6195: LD_INT 1
6197: PPUSH
6198: LD_EXP 50
6202: PPUSH
6203: CALL_OW 380
// un := CreateHuman ;
6207: LD_ADDR_VAR 0 4
6211: PUSH
6212: CALL_OW 44
6216: ST_TO_ADDR
// filter := filter ^ un ;
6217: LD_ADDR_VAR 0 3
6221: PUSH
6222: LD_VAR 0 3
6226: PUSH
6227: LD_VAR 0 4
6231: ADD
6232: ST_TO_ADDR
// for i = 1 to [ 4 , 3 , 2 ] [ game_difficulty ] do
6233: LD_ADDR_VAR 0 2
6237: PUSH
6238: DOUBLE
6239: LD_INT 1
6241: DEC
6242: ST_TO_ADDR
6243: LD_INT 4
6245: PUSH
6246: LD_INT 3
6248: PUSH
6249: LD_INT 2
6251: PUSH
6252: EMPTY
6253: LIST
6254: LIST
6255: LIST
6256: PUSH
6257: LD_EXP 2
6261: ARRAY
6262: PUSH
6263: FOR_TO
6264: IFFALSE 6302
// begin un := CreateHumanWithClass ( 1 , l_skill ) ;
6266: LD_ADDR_VAR 0 4
6270: PUSH
6271: LD_INT 1
6273: PPUSH
6274: LD_EXP 50
6278: PPUSH
6279: CALL 7231 0 2
6283: ST_TO_ADDR
// filter := filter ^ un ;
6284: LD_ADDR_VAR 0 3
6288: PUSH
6289: LD_VAR 0 3
6293: PUSH
6294: LD_VAR 0 4
6298: ADD
6299: ST_TO_ADDR
// end ;
6300: GO 6263
6302: POP
6303: POP
// DialogueOn ;
6304: CALL_OW 6
// if GetSex ( filter [ 1 ] ) = sex_male then
6308: LD_VAR 0 3
6312: PUSH
6313: LD_INT 1
6315: ARRAY
6316: PPUSH
6317: CALL_OW 258
6321: PUSH
6322: LD_INT 1
6324: EQUAL
6325: IFFALSE 6345
// SayRadio ( filter [ 1 ] , DS-DF-1 ) else
6327: LD_VAR 0 3
6331: PUSH
6332: LD_INT 1
6334: ARRAY
6335: PPUSH
6336: LD_STRING DS-DF-1
6338: PPUSH
6339: CALL_OW 94
6343: GO 6361
// SayRadio ( filter [ 1 ] , DS-DF-f1 ) ;
6345: LD_VAR 0 3
6349: PUSH
6350: LD_INT 1
6352: ARRAY
6353: PPUSH
6354: LD_STRING DS-DF-f1
6356: PPUSH
6357: CALL_OW 94
// case Query ( DS-dezert ) of 1 :
6361: LD_STRING DS-dezert
6363: PPUSH
6364: CALL_OW 97
6368: PUSH
6369: LD_INT 1
6371: DOUBLE
6372: EQUAL
6373: IFTRUE 6377
6375: GO 6392
6377: POP
// Say ( l_cmndr , DS-DC-dis ) ; 2 :
6378: LD_EXP 49
6382: PPUSH
6383: LD_STRING DS-DC-dis
6385: PPUSH
6386: CALL_OW 88
6390: GO 6487
6392: LD_INT 2
6394: DOUBLE
6395: EQUAL
6396: IFTRUE 6400
6398: GO 6486
6400: POP
// begin Say ( l_cmndr , DS-DC-acp ) ;
6401: LD_EXP 49
6405: PPUSH
6406: LD_STRING DS-DC-acp
6408: PPUSH
6409: CALL_OW 88
// for i = 1 to filter do
6413: LD_ADDR_VAR 0 2
6417: PUSH
6418: DOUBLE
6419: LD_INT 1
6421: DEC
6422: ST_TO_ADDR
6423: LD_VAR 0 3
6427: PUSH
6428: FOR_TO
6429: IFFALSE 6482
// begin SetSide ( filter [ i ] , 8 ) ;
6431: LD_VAR 0 3
6435: PUSH
6436: LD_VAR 0 2
6440: ARRAY
6441: PPUSH
6442: LD_INT 8
6444: PPUSH
6445: CALL_OW 235
// PlaceUnitArea ( filter [ i ] , south_spawn , false ) ;
6449: LD_VAR 0 3
6453: PUSH
6454: LD_VAR 0 2
6458: ARRAY
6459: PPUSH
6460: LD_INT 4
6462: PPUSH
6463: LD_INT 0
6465: PPUSH
6466: CALL_OW 49
// CenterNowOnXY ( 111 , 121 ) ;
6470: LD_INT 111
6472: PPUSH
6473: LD_INT 121
6475: PPUSH
6476: CALL_OW 86
// end ;
6480: GO 6428
6482: POP
6483: POP
// end ; end ;
6484: GO 6487
6486: POP
// DialogueOff ;
6487: CALL_OW 7
// end ; 101 :
6491: GO 6643
6493: LD_INT 101
6495: DOUBLE
6496: EQUAL
6497: IFTRUE 6501
6499: GO 6553
6501: POP
// begin CreateCratesArea ( Rand ( 3 , 5 ) , crates_area , true ) ;
6502: LD_INT 3
6504: PPUSH
6505: LD_INT 5
6507: PPUSH
6508: CALL_OW 12
6512: PPUSH
6513: LD_INT 9
6515: PPUSH
6516: LD_INT 1
6518: PPUSH
6519: CALL_OW 55
// Wait ( 0 0$11 ) ;
6523: LD_INT 385
6525: PPUSH
6526: CALL_OW 67
// CreateCratesArea ( Rand ( 3 , 5 ) , crates_area , true ) ;
6530: LD_INT 3
6532: PPUSH
6533: LD_INT 5
6535: PPUSH
6536: CALL_OW 12
6540: PPUSH
6541: LD_INT 9
6543: PPUSH
6544: LD_INT 1
6546: PPUSH
6547: CALL_OW 55
// end ; 200 :
6551: GO 6643
6553: LD_INT 200
6555: DOUBLE
6556: EQUAL
6557: IFTRUE 6561
6559: GO 6642
6561: POP
// begin Say ( Leopold , DS-end ) ;
6562: LD_EXP 7
6566: PPUSH
6567: LD_STRING DS-end
6569: PPUSH
6570: CALL_OW 88
// if Difficulty = 3 then
6574: LD_OWVAR 67
6578: PUSH
6579: LD_INT 3
6581: EQUAL
6582: IFFALSE 6591
// SetAchievement ( ACH_DESERT ) ;
6584: LD_STRING ACH_DESERT
6586: PPUSH
6587: CALL_OW 543
// music_nat := 5 ;
6591: LD_ADDR_OWVAR 71
6595: PUSH
6596: LD_INT 5
6598: ST_TO_ADDR
// AddMedal ( dsmed1 , 1 ) ;
6599: LD_STRING dsmed1
6601: PPUSH
6602: LD_INT 1
6604: PPUSH
6605: CALL_OW 101
// AddMedal ( dsmed1 , 1 ) ;
6609: LD_STRING dsmed1
6611: PPUSH
6612: LD_INT 1
6614: PPUSH
6615: CALL_OW 101
// AddMedal ( dsmed1 , 1 ) ;
6619: LD_STRING dsmed1
6621: PPUSH
6622: LD_INT 1
6624: PPUSH
6625: CALL_OW 101
// GiveMedals ( MAIN ) ;
6629: LD_STRING MAIN
6631: PPUSH
6632: CALL_OW 102
// YouWin ;
6636: CALL_OW 103
// end ; end ;
6640: GO 6643
6642: POP
// end ;
6643: PPOPN 6
6645: END
// on UnitGoesToRed ( un ) do begin if un in FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] ] ) then
6646: LD_VAR 0 1
6650: PUSH
6651: LD_INT 22
6653: PUSH
6654: LD_INT 2
6656: PUSH
6657: EMPTY
6658: LIST
6659: LIST
6660: PUSH
6661: LD_INT 21
6663: PUSH
6664: LD_INT 2
6666: PUSH
6667: EMPTY
6668: LIST
6669: LIST
6670: PUSH
6671: EMPTY
6672: LIST
6673: LIST
6674: PPUSH
6675: CALL_OW 69
6679: IN
6680: IFFALSE 6805
// begin Wait ( Rand ( 0 0$03 , 0 0$06 ) ) ;
6682: LD_INT 105
6684: PPUSH
6685: LD_INT 210
6687: PPUSH
6688: CALL_OW 12
6692: PPUSH
6693: CALL_OW 67
// MineExplosion ( GetX ( un ) , GetY ( un ) , 3 ) ;
6697: LD_VAR 0 1
6701: PPUSH
6702: CALL_OW 250
6706: PPUSH
6707: LD_VAR 0 1
6711: PPUSH
6712: CALL_OW 251
6716: PPUSH
6717: LD_INT 3
6719: PPUSH
6720: CALL_OW 453
// MineExplosion ( GetX ( un ) , GetY ( un ) , 3 ) ;
6724: LD_VAR 0 1
6728: PPUSH
6729: CALL_OW 250
6733: PPUSH
6734: LD_VAR 0 1
6738: PPUSH
6739: CALL_OW 251
6743: PPUSH
6744: LD_INT 3
6746: PPUSH
6747: CALL_OW 453
// MineExplosion ( GetX ( un ) , GetY ( un ) , 3 ) ;
6751: LD_VAR 0 1
6755: PPUSH
6756: CALL_OW 250
6760: PPUSH
6761: LD_VAR 0 1
6765: PPUSH
6766: CALL_OW 251
6770: PPUSH
6771: LD_INT 3
6773: PPUSH
6774: CALL_OW 453
// MineExplosion ( GetX ( un ) , GetY ( un ) , 3 ) ;
6778: LD_VAR 0 1
6782: PPUSH
6783: CALL_OW 250
6787: PPUSH
6788: LD_VAR 0 1
6792: PPUSH
6793: CALL_OW 251
6797: PPUSH
6798: LD_INT 3
6800: PPUSH
6801: CALL_OW 453
// end ; end ;
6805: PPOPN 1
6807: END
// on UnitDestroyed ( un ) do begin if un = fort then
6808: LD_VAR 0 1
6812: PUSH
6813: LD_INT 23
6815: EQUAL
6816: IFFALSE 6826
// fort_destroyed := true ;
6818: LD_ADDR_EXP 32
6822: PUSH
6823: LD_INT 1
6825: ST_TO_ADDR
// if un = l_cmndr then
6826: LD_VAR 0 1
6830: PUSH
6831: LD_EXP 49
6835: EQUAL
6836: IFFALSE 6846
// hero_died := true ;
6838: LD_ADDR_EXP 33
6842: PUSH
6843: LD_INT 1
6845: ST_TO_ADDR
// end ;
6846: PPOPN 1
6848: END
// on UnitDestroyed_Extra ( un , killerSide , killerUnit ) do begin SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ;
6849: LD_VAR 0 1
6853: PPUSH
6854: LD_VAR 0 2
6858: PPUSH
6859: LD_VAR 0 3
6863: PPUSH
6864: CALL 8568 0 3
// end ;
6868: PPOPN 3
6870: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
6871: LD_VAR 0 1
6875: PPUSH
6876: CALL 8666 0 1
// end ; end_of_file
6880: PPOPN 1
6882: END
// export function RefreshTime ( time , bool ) ; begin
6883: LD_INT 0
6885: PPUSH
// if bool then
6886: LD_VAR 0 2
6890: IFFALSE 6908
// time := time + 0 0$01 else
6892: LD_ADDR_VAR 0 1
6896: PUSH
6897: LD_VAR 0 1
6901: PUSH
6902: LD_INT 35
6904: PLUS
6905: ST_TO_ADDR
6906: GO 6922
// time := time - 0 0$01 ;
6908: LD_ADDR_VAR 0 1
6912: PUSH
6913: LD_VAR 0 1
6917: PUSH
6918: LD_INT 35
6920: MINUS
6921: ST_TO_ADDR
// result := time ;
6922: LD_ADDR_VAR 0 3
6926: PUSH
6927: LD_VAR 0 1
6931: ST_TO_ADDR
// end ;
6932: LD_VAR 0 3
6936: RET
// export function MineExist ( side ) ; begin
6937: LD_INT 0
6939: PPUSH
// if FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_siberite_mine ] ] ) > 0 then
6940: LD_INT 22
6942: PUSH
6943: LD_VAR 0 1
6947: PUSH
6948: EMPTY
6949: LIST
6950: LIST
6951: PUSH
6952: LD_INT 30
6954: PUSH
6955: LD_INT 30
6957: PUSH
6958: EMPTY
6959: LIST
6960: LIST
6961: PUSH
6962: EMPTY
6963: LIST
6964: LIST
6965: PPUSH
6966: CALL_OW 69
6970: PUSH
6971: LD_INT 0
6973: GREATER
6974: IFFALSE 6986
// result := true else
6976: LD_ADDR_VAR 0 2
6980: PUSH
6981: LD_INT 1
6983: ST_TO_ADDR
6984: GO 6994
// result := false ;
6986: LD_ADDR_VAR 0 2
6990: PUSH
6991: LD_INT 0
6993: ST_TO_ADDR
// end ;
6994: LD_VAR 0 2
6998: RET
// export function FacExist ( side ) ; begin
6999: LD_INT 0
7001: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_factory ] ] ) > 0 ;
7002: LD_ADDR_VAR 0 2
7006: PUSH
7007: LD_INT 22
7009: PUSH
7010: LD_VAR 0 1
7014: PUSH
7015: EMPTY
7016: LIST
7017: LIST
7018: PUSH
7019: LD_INT 30
7021: PUSH
7022: LD_INT 3
7024: PUSH
7025: EMPTY
7026: LIST
7027: LIST
7028: PUSH
7029: EMPTY
7030: LIST
7031: LIST
7032: PPUSH
7033: CALL_OW 69
7037: PUSH
7038: LD_INT 0
7040: GREATER
7041: ST_TO_ADDR
// end ;
7042: LD_VAR 0 2
7046: RET
// export function ConnectWithTower ( side ) ; var i , filter , tower ; begin
7047: LD_INT 0
7049: PPUSH
7050: PPUSH
7051: PPUSH
7052: PPUSH
// filter := FilterAllUnits ( [ [ f_side , side ] , [ f_control , control_remote ] , [ f_ok ] ] ) ;
7053: LD_ADDR_VAR 0 4
7057: PUSH
7058: LD_INT 22
7060: PUSH
7061: LD_VAR 0 1
7065: PUSH
7066: EMPTY
7067: LIST
7068: LIST
7069: PUSH
7070: LD_INT 33
7072: PUSH
7073: LD_INT 2
7075: PUSH
7076: EMPTY
7077: LIST
7078: LIST
7079: PUSH
7080: LD_INT 50
7082: PUSH
7083: EMPTY
7084: LIST
7085: PUSH
7086: EMPTY
7087: LIST
7088: LIST
7089: LIST
7090: PPUSH
7091: CALL_OW 69
7095: ST_TO_ADDR
// tower := FilterAllUnits ( [ [ f_side , side ] , [ f_weapon , ar_control_tower ] ] ) ;
7096: LD_ADDR_VAR 0 5
7100: PUSH
7101: LD_INT 22
7103: PUSH
7104: LD_VAR 0 1
7108: PUSH
7109: EMPTY
7110: LIST
7111: LIST
7112: PUSH
7113: LD_INT 34
7115: PUSH
7116: LD_INT 31
7118: PUSH
7119: EMPTY
7120: LIST
7121: LIST
7122: PUSH
7123: EMPTY
7124: LIST
7125: LIST
7126: PPUSH
7127: CALL_OW 69
7131: ST_TO_ADDR
// if tower > 0 and filter > 0 then
7132: LD_VAR 0 5
7136: PUSH
7137: LD_INT 0
7139: GREATER
7140: PUSH
7141: LD_VAR 0 4
7145: PUSH
7146: LD_INT 0
7148: GREATER
7149: AND
7150: IFFALSE 7226
// for i = 1 to filter do
7152: LD_ADDR_VAR 0 3
7156: PUSH
7157: DOUBLE
7158: LD_INT 1
7160: DEC
7161: ST_TO_ADDR
7162: LD_VAR 0 4
7166: PUSH
7167: FOR_TO
7168: IFFALSE 7224
// if not IsControledBy ( filter [ i ] ) then
7170: LD_VAR 0 4
7174: PUSH
7175: LD_VAR 0 3
7179: ARRAY
7180: PPUSH
7181: CALL_OW 312
7185: NOT
7186: IFFALSE 7222
// ComLinkTo ( filter [ i ] , tower [ Rand ( 1 , tower ) ] ) ;
7188: LD_VAR 0 4
7192: PUSH
7193: LD_VAR 0 3
7197: ARRAY
7198: PPUSH
7199: LD_VAR 0 5
7203: PUSH
7204: LD_INT 1
7206: PPUSH
7207: LD_VAR 0 5
7211: PPUSH
7212: CALL_OW 12
7216: ARRAY
7217: PPUSH
7218: CALL_OW 135
7222: GO 7167
7224: POP
7225: POP
// end ;
7226: LD_VAR 0 2
7230: RET
// export function CreateHumanWithClass ( clas , lvl ) ; var skill_com , skill_eng , skill_mech , skill_sci , bonus ; begin
7231: LD_INT 0
7233: PPUSH
7234: PPUSH
7235: PPUSH
7236: PPUSH
7237: PPUSH
7238: PPUSH
// hc_class := clas ;
7239: LD_ADDR_OWVAR 28
7243: PUSH
7244: LD_VAR 0 1
7248: ST_TO_ADDR
// skill_com := ( lvl + Rand ( - 1 , 1 ) ) ;
7249: LD_ADDR_VAR 0 4
7253: PUSH
7254: LD_VAR 0 2
7258: PUSH
7259: LD_INT 1
7261: NEG
7262: PPUSH
7263: LD_INT 1
7265: PPUSH
7266: CALL_OW 12
7270: PLUS
7271: ST_TO_ADDR
// skill_eng := ( lvl + Rand ( - 1 , 1 ) ) ;
7272: LD_ADDR_VAR 0 5
7276: PUSH
7277: LD_VAR 0 2
7281: PUSH
7282: LD_INT 1
7284: NEG
7285: PPUSH
7286: LD_INT 1
7288: PPUSH
7289: CALL_OW 12
7293: PLUS
7294: ST_TO_ADDR
// skill_mech := ( lvl + Rand ( - 1 , 1 ) ) ;
7295: LD_ADDR_VAR 0 6
7299: PUSH
7300: LD_VAR 0 2
7304: PUSH
7305: LD_INT 1
7307: NEG
7308: PPUSH
7309: LD_INT 1
7311: PPUSH
7312: CALL_OW 12
7316: PLUS
7317: ST_TO_ADDR
// skill_sci := ( lvl + Rand ( - 1 , 1 ) ) ;
7318: LD_ADDR_VAR 0 7
7322: PUSH
7323: LD_VAR 0 2
7327: PUSH
7328: LD_INT 1
7330: NEG
7331: PPUSH
7332: LD_INT 1
7334: PPUSH
7335: CALL_OW 12
7339: PLUS
7340: ST_TO_ADDR
// if clas = 1 or clas = 9 or clas = class_sniper or clas = class_mortar then
7341: LD_VAR 0 1
7345: PUSH
7346: LD_INT 1
7348: EQUAL
7349: PUSH
7350: LD_VAR 0 1
7354: PUSH
7355: LD_INT 9
7357: EQUAL
7358: OR
7359: PUSH
7360: LD_VAR 0 1
7364: PUSH
7365: LD_INT 5
7367: EQUAL
7368: OR
7369: PUSH
7370: LD_VAR 0 1
7374: PUSH
7375: LD_INT 8
7377: EQUAL
7378: OR
7379: IFFALSE 7404
// bonus := [ 2 , 0 , 0 , 0 ] ;
7381: LD_ADDR_VAR 0 8
7385: PUSH
7386: LD_INT 2
7388: PUSH
7389: LD_INT 0
7391: PUSH
7392: LD_INT 0
7394: PUSH
7395: LD_INT 0
7397: PUSH
7398: EMPTY
7399: LIST
7400: LIST
7401: LIST
7402: LIST
7403: ST_TO_ADDR
// if clas = 2 then
7404: LD_VAR 0 1
7408: PUSH
7409: LD_INT 2
7411: EQUAL
7412: IFFALSE 7437
// bonus := [ 0 , 2 , 0 , 0 ] ;
7414: LD_ADDR_VAR 0 8
7418: PUSH
7419: LD_INT 0
7421: PUSH
7422: LD_INT 2
7424: PUSH
7425: LD_INT 0
7427: PUSH
7428: LD_INT 0
7430: PUSH
7431: EMPTY
7432: LIST
7433: LIST
7434: LIST
7435: LIST
7436: ST_TO_ADDR
// if clas = 3 then
7437: LD_VAR 0 1
7441: PUSH
7442: LD_INT 3
7444: EQUAL
7445: IFFALSE 7470
// bonus := [ 0 , 0 , 2 , 0 ] ;
7447: LD_ADDR_VAR 0 8
7451: PUSH
7452: LD_INT 0
7454: PUSH
7455: LD_INT 0
7457: PUSH
7458: LD_INT 2
7460: PUSH
7461: LD_INT 0
7463: PUSH
7464: EMPTY
7465: LIST
7466: LIST
7467: LIST
7468: LIST
7469: ST_TO_ADDR
// if clas = 4 then
7470: LD_VAR 0 1
7474: PUSH
7475: LD_INT 4
7477: EQUAL
7478: IFFALSE 7503
// bonus := [ 0 , 0 , 0 , 2 ] ;
7480: LD_ADDR_VAR 0 8
7484: PUSH
7485: LD_INT 0
7487: PUSH
7488: LD_INT 0
7490: PUSH
7491: LD_INT 0
7493: PUSH
7494: LD_INT 2
7496: PUSH
7497: EMPTY
7498: LIST
7499: LIST
7500: LIST
7501: LIST
7502: ST_TO_ADDR
// if clas > 4 and clas <> 9 and clas <> class_sniper and clas <> class_mortar then
7503: LD_VAR 0 1
7507: PUSH
7508: LD_INT 4
7510: GREATER
7511: PUSH
7512: LD_VAR 0 1
7516: PUSH
7517: LD_INT 9
7519: NONEQUAL
7520: AND
7521: PUSH
7522: LD_VAR 0 1
7526: PUSH
7527: LD_INT 5
7529: NONEQUAL
7530: AND
7531: PUSH
7532: LD_VAR 0 1
7536: PUSH
7537: LD_INT 8
7539: NONEQUAL
7540: AND
7541: IFFALSE 7566
// bonus := [ 0 , 0 , 0 , 0 ] ;
7543: LD_ADDR_VAR 0 8
7547: PUSH
7548: LD_INT 0
7550: PUSH
7551: LD_INT 0
7553: PUSH
7554: LD_INT 0
7556: PUSH
7557: LD_INT 0
7559: PUSH
7560: EMPTY
7561: LIST
7562: LIST
7563: LIST
7564: LIST
7565: ST_TO_ADDR
// hc_basic_skills := [ Rand ( 0 , 2 ) , Rand ( 0 , 2 ) , Rand ( 0 , 2 ) , Rand ( 0 , 2 ) ] ;
7566: LD_ADDR_OWVAR 30
7570: PUSH
7571: LD_INT 0
7573: PPUSH
7574: LD_INT 2
7576: PPUSH
7577: CALL_OW 12
7581: PUSH
7582: LD_INT 0
7584: PPUSH
7585: LD_INT 2
7587: PPUSH
7588: CALL_OW 12
7592: PUSH
7593: LD_INT 0
7595: PPUSH
7596: LD_INT 2
7598: PPUSH
7599: CALL_OW 12
7603: PUSH
7604: LD_INT 0
7606: PPUSH
7607: LD_INT 2
7609: PPUSH
7610: CALL_OW 12
7614: PUSH
7615: EMPTY
7616: LIST
7617: LIST
7618: LIST
7619: LIST
7620: ST_TO_ADDR
// hc_skills := [ skill_com + bonus [ 1 ] , skill_eng + bonus [ 2 ] , skill_mech + bonus [ 3 ] , skill_sci + bonus [ 4 ] ] ;
7621: LD_ADDR_OWVAR 31
7625: PUSH
7626: LD_VAR 0 4
7630: PUSH
7631: LD_VAR 0 8
7635: PUSH
7636: LD_INT 1
7638: ARRAY
7639: PLUS
7640: PUSH
7641: LD_VAR 0 5
7645: PUSH
7646: LD_VAR 0 8
7650: PUSH
7651: LD_INT 2
7653: ARRAY
7654: PLUS
7655: PUSH
7656: LD_VAR 0 6
7660: PUSH
7661: LD_VAR 0 8
7665: PUSH
7666: LD_INT 3
7668: ARRAY
7669: PLUS
7670: PUSH
7671: LD_VAR 0 7
7675: PUSH
7676: LD_VAR 0 8
7680: PUSH
7681: LD_INT 4
7683: ARRAY
7684: PLUS
7685: PUSH
7686: EMPTY
7687: LIST
7688: LIST
7689: LIST
7690: LIST
7691: ST_TO_ADDR
// hc_sex := Rand ( sex_male , sex_female ) ;
7692: LD_ADDR_OWVAR 27
7696: PUSH
7697: LD_INT 1
7699: PPUSH
7700: LD_INT 2
7702: PPUSH
7703: CALL_OW 12
7707: ST_TO_ADDR
// hc_gallery :=  ;
7708: LD_ADDR_OWVAR 33
7712: PUSH
7713: LD_STRING 
7715: ST_TO_ADDR
// hc_attr := [ Rand ( 8 , 12 ) , Rand ( 9 , 11 ) ] ;
7716: LD_ADDR_OWVAR 29
7720: PUSH
7721: LD_INT 8
7723: PPUSH
7724: LD_INT 12
7726: PPUSH
7727: CALL_OW 12
7731: PUSH
7732: LD_INT 9
7734: PPUSH
7735: LD_INT 11
7737: PPUSH
7738: CALL_OW 12
7742: PUSH
7743: EMPTY
7744: LIST
7745: LIST
7746: ST_TO_ADDR
// hc_name :=  ;
7747: LD_ADDR_OWVAR 26
7751: PUSH
7752: LD_STRING 
7754: ST_TO_ADDR
// result := CreateHuman ;
7755: LD_ADDR_VAR 0 3
7759: PUSH
7760: CALL_OW 44
7764: ST_TO_ADDR
// end ;
7765: LD_VAR 0 3
7769: RET
// export function GetSpeed ( unit ) ; begin
7770: LD_INT 0
7772: PPUSH
// result := GetProperties ( unit ) [ 1 ] ;
7773: LD_ADDR_VAR 0 2
7777: PUSH
7778: LD_VAR 0 1
7782: PPUSH
7783: CALL_OW 464
7787: PUSH
7788: LD_INT 1
7790: ARRAY
7791: ST_TO_ADDR
// end ;
7792: LD_VAR 0 2
7796: RET
// export function PrepareNature ( area , num1 , num2 , num3 , num4 ) ; var l , apeman , tiger , bird , horse ; begin
7797: LD_INT 0
7799: PPUSH
7800: PPUSH
7801: PPUSH
7802: PPUSH
7803: PPUSH
7804: PPUSH
// uc_nation = nation_nature ;
7805: LD_ADDR_OWVAR 21
7809: PUSH
7810: LD_INT 0
7812: ST_TO_ADDR
// uc_side = 0 ;
7813: LD_ADDR_OWVAR 20
7817: PUSH
7818: LD_INT 0
7820: ST_TO_ADDR
// l = 0 ;
7821: LD_ADDR_VAR 0 7
7825: PUSH
7826: LD_INT 0
7828: ST_TO_ADDR
// repeat begin uc_direction = Rand ( 0 , 5 ) ;
7829: LD_ADDR_OWVAR 24
7833: PUSH
7834: LD_INT 0
7836: PPUSH
7837: LD_INT 5
7839: PPUSH
7840: CALL_OW 12
7844: ST_TO_ADDR
// hc_agressivity = Rand ( - 5 , 0 ) ;
7845: LD_ADDR_OWVAR 35
7849: PUSH
7850: LD_INT 5
7852: NEG
7853: PPUSH
7854: LD_INT 0
7856: PPUSH
7857: CALL_OW 12
7861: ST_TO_ADDR
// hc_gallery =  ;
7862: LD_ADDR_OWVAR 33
7866: PUSH
7867: LD_STRING 
7869: ST_TO_ADDR
// hc_class = class_apeman ;
7870: LD_ADDR_OWVAR 28
7874: PUSH
7875: LD_INT 12
7877: ST_TO_ADDR
// hc_attr = [ Rand ( 11 , 13 ) , Rand ( 10 , 11 ) ] ;
7878: LD_ADDR_OWVAR 29
7882: PUSH
7883: LD_INT 11
7885: PPUSH
7886: LD_INT 13
7888: PPUSH
7889: CALL_OW 12
7893: PUSH
7894: LD_INT 10
7896: PPUSH
7897: LD_INT 11
7899: PPUSH
7900: CALL_OW 12
7904: PUSH
7905: EMPTY
7906: LIST
7907: LIST
7908: ST_TO_ADDR
// hc_sex = sex_male ;
7909: LD_ADDR_OWVAR 27
7913: PUSH
7914: LD_INT 1
7916: ST_TO_ADDR
// hc_skills = [ Rand ( 0 , 2 ) , 0 , 0 , 0 ] ;
7917: LD_ADDR_OWVAR 31
7921: PUSH
7922: LD_INT 0
7924: PPUSH
7925: LD_INT 2
7927: PPUSH
7928: CALL_OW 12
7932: PUSH
7933: LD_INT 0
7935: PUSH
7936: LD_INT 0
7938: PUSH
7939: LD_INT 0
7941: PUSH
7942: EMPTY
7943: LIST
7944: LIST
7945: LIST
7946: LIST
7947: ST_TO_ADDR
// apeman = CreateHuman ;
7948: LD_ADDR_VAR 0 8
7952: PUSH
7953: CALL_OW 44
7957: ST_TO_ADDR
// PlaceUnitArea ( apeman , area , false ) ;
7958: LD_VAR 0 8
7962: PPUSH
7963: LD_VAR 0 1
7967: PPUSH
7968: LD_INT 0
7970: PPUSH
7971: CALL_OW 49
// l = l + 1 ;
7975: LD_ADDR_VAR 0 7
7979: PUSH
7980: LD_VAR 0 7
7984: PUSH
7985: LD_INT 1
7987: PLUS
7988: ST_TO_ADDR
// end until l = num1 ;
7989: LD_VAR 0 7
7993: PUSH
7994: LD_VAR 0 2
7998: EQUAL
7999: IFFALSE 7829
// l = 0 ;
8001: LD_ADDR_VAR 0 7
8005: PUSH
8006: LD_INT 0
8008: ST_TO_ADDR
// repeat begin hc_agressivity = Rand ( 0 , 25 ) ;
8009: LD_ADDR_OWVAR 35
8013: PUSH
8014: LD_INT 0
8016: PPUSH
8017: LD_INT 25
8019: PPUSH
8020: CALL_OW 12
8024: ST_TO_ADDR
// hc_class = class_tiger ;
8025: LD_ADDR_OWVAR 28
8029: PUSH
8030: LD_INT 14
8032: ST_TO_ADDR
// hc_sex = sex_male ;
8033: LD_ADDR_OWVAR 27
8037: PUSH
8038: LD_INT 1
8040: ST_TO_ADDR
// hc_gallery = sandnature ;
8041: LD_ADDR_OWVAR 33
8045: PUSH
8046: LD_STRING sandnature
8048: ST_TO_ADDR
// hc_face_number = 3 ;
8049: LD_ADDR_OWVAR 34
8053: PUSH
8054: LD_INT 3
8056: ST_TO_ADDR
// tiger = CreateHuman ;
8057: LD_ADDR_VAR 0 9
8061: PUSH
8062: CALL_OW 44
8066: ST_TO_ADDR
// PlaceUnitArea ( tiger , area , false ) ;
8067: LD_VAR 0 9
8071: PPUSH
8072: LD_VAR 0 1
8076: PPUSH
8077: LD_INT 0
8079: PPUSH
8080: CALL_OW 49
// l = l + 1 ;
8084: LD_ADDR_VAR 0 7
8088: PUSH
8089: LD_VAR 0 7
8093: PUSH
8094: LD_INT 1
8096: PLUS
8097: ST_TO_ADDR
// end until l = num2 ;
8098: LD_VAR 0 7
8102: PUSH
8103: LD_VAR 0 3
8107: EQUAL
8108: IFFALSE 8009
// l = 0 ;
8110: LD_ADDR_VAR 0 7
8114: PUSH
8115: LD_INT 0
8117: ST_TO_ADDR
// repeat begin hc_class = class_phororhacos ;
8118: LD_ADDR_OWVAR 28
8122: PUSH
8123: LD_INT 18
8125: ST_TO_ADDR
// hc_gallery = sandnature ;
8126: LD_ADDR_OWVAR 33
8130: PUSH
8131: LD_STRING sandnature
8133: ST_TO_ADDR
// hc_face_number = 1 ;
8134: LD_ADDR_OWVAR 34
8138: PUSH
8139: LD_INT 1
8141: ST_TO_ADDR
// bird = CreateHuman ;
8142: LD_ADDR_VAR 0 10
8146: PUSH
8147: CALL_OW 44
8151: ST_TO_ADDR
// PlaceUnitAnywhere ( bird , false ) ;
8152: LD_VAR 0 10
8156: PPUSH
8157: LD_INT 0
8159: PPUSH
8160: CALL_OW 51
// l = l + 1 ;
8164: LD_ADDR_VAR 0 7
8168: PUSH
8169: LD_VAR 0 7
8173: PUSH
8174: LD_INT 1
8176: PLUS
8177: ST_TO_ADDR
// end until l = num3 ;
8178: LD_VAR 0 7
8182: PUSH
8183: LD_VAR 0 4
8187: EQUAL
8188: IFFALSE 8118
// l = 0 ;
8190: LD_ADDR_VAR 0 7
8194: PUSH
8195: LD_INT 0
8197: ST_TO_ADDR
// repeat begin hc_class = 21 ;
8198: LD_ADDR_OWVAR 28
8202: PUSH
8203: LD_INT 21
8205: ST_TO_ADDR
// hc_gallery = sandnature ;
8206: LD_ADDR_OWVAR 33
8210: PUSH
8211: LD_STRING sandnature
8213: ST_TO_ADDR
// hc_face_number = 5 ;
8214: LD_ADDR_OWVAR 34
8218: PUSH
8219: LD_INT 5
8221: ST_TO_ADDR
// horse := CreateHuman ;
8222: LD_ADDR_VAR 0 11
8226: PUSH
8227: CALL_OW 44
8231: ST_TO_ADDR
// PlaceUnitArea ( horse , area , false ) ;
8232: LD_VAR 0 11
8236: PPUSH
8237: LD_VAR 0 1
8241: PPUSH
8242: LD_INT 0
8244: PPUSH
8245: CALL_OW 49
// l = l + 1 ;
8249: LD_ADDR_VAR 0 7
8253: PUSH
8254: LD_VAR 0 7
8258: PUSH
8259: LD_INT 1
8261: PLUS
8262: ST_TO_ADDR
// end until l = num4 ;
8263: LD_VAR 0 7
8267: PUSH
8268: LD_VAR 0 5
8272: EQUAL
8273: IFFALSE 8198
// end ;
8275: LD_VAR 0 6
8279: RET
// export function PrepareComm ; begin
8280: LD_INT 0
8282: PPUSH
// uc_side := 1 ;
8283: LD_ADDR_OWVAR 20
8287: PUSH
8288: LD_INT 1
8290: ST_TO_ADDR
// uc_nation := 1 ;
8291: LD_ADDR_OWVAR 21
8295: PUSH
8296: LD_INT 1
8298: ST_TO_ADDR
// hc_gallery :=  ;
8299: LD_ADDR_OWVAR 33
8303: PUSH
8304: LD_STRING 
8306: ST_TO_ADDR
// hc_name :=  ;
8307: LD_ADDR_OWVAR 26
8311: PUSH
8312: LD_STRING 
8314: ST_TO_ADDR
// hc_class := 1 ;
8315: LD_ADDR_OWVAR 28
8319: PUSH
8320: LD_INT 1
8322: ST_TO_ADDR
// hc_sex := sex_male ;
8323: LD_ADDR_OWVAR 27
8327: PUSH
8328: LD_INT 1
8330: ST_TO_ADDR
// am_comander := CreateHuman ;
8331: LD_ADDR_EXP 46
8335: PUSH
8336: CALL_OW 44
8340: ST_TO_ADDR
// uc_side := 3 ;
8341: LD_ADDR_OWVAR 20
8345: PUSH
8346: LD_INT 3
8348: ST_TO_ADDR
// uc_nation := 3 ;
8349: LD_ADDR_OWVAR 21
8353: PUSH
8354: LD_INT 3
8356: ST_TO_ADDR
// ru_comander := CreateHuman ;
8357: LD_ADDR_EXP 47
8361: PUSH
8362: CALL_OW 44
8366: ST_TO_ADDR
// uc_side := 2 ;
8367: LD_ADDR_OWVAR 20
8371: PUSH
8372: LD_INT 2
8374: ST_TO_ADDR
// uc_nation := 2 ;
8375: LD_ADDR_OWVAR 21
8379: PUSH
8380: LD_INT 2
8382: ST_TO_ADDR
// hc_name := Heike Steyer ;
8383: LD_ADDR_OWVAR 26
8387: PUSH
8388: LD_STRING Heike Steyer
8390: ST_TO_ADDR
// hc_sex := sex_female ;
8391: LD_ADDR_OWVAR 27
8395: PUSH
8396: LD_INT 2
8398: ST_TO_ADDR
// hc_gallery := sandar ;
8399: LD_ADDR_OWVAR 33
8403: PUSH
8404: LD_STRING sandar
8406: ST_TO_ADDR
// hc_face_number := 14 ;
8407: LD_ADDR_OWVAR 34
8411: PUSH
8412: LD_INT 14
8414: ST_TO_ADDR
// ar_comander := CreateHuman ;
8415: LD_ADDR_EXP 48
8419: PUSH
8420: CALL_OW 44
8424: ST_TO_ADDR
// end ;
8425: LD_VAR 0 1
8429: RET
// export function SpeedFilter ( filter , speed ) ; var list , i ; begin
8430: LD_INT 0
8432: PPUSH
8433: PPUSH
8434: PPUSH
// list := [ ] ;
8435: LD_ADDR_VAR 0 4
8439: PUSH
8440: EMPTY
8441: ST_TO_ADDR
// for i = 1 to filter do
8442: LD_ADDR_VAR 0 5
8446: PUSH
8447: DOUBLE
8448: LD_INT 1
8450: DEC
8451: ST_TO_ADDR
8452: LD_VAR 0 1
8456: PUSH
8457: FOR_TO
8458: IFFALSE 8507
// if GetSpeed ( filter [ i ] ) < speed then
8460: LD_VAR 0 1
8464: PUSH
8465: LD_VAR 0 5
8469: ARRAY
8470: PPUSH
8471: CALL 7770 0 1
8475: PUSH
8476: LD_VAR 0 2
8480: LESS
8481: IFFALSE 8505
// list := list ^ filter [ i ] ;
8483: LD_ADDR_VAR 0 4
8487: PUSH
8488: LD_VAR 0 4
8492: PUSH
8493: LD_VAR 0 1
8497: PUSH
8498: LD_VAR 0 5
8502: ARRAY
8503: ADD
8504: ST_TO_ADDR
8505: GO 8457
8507: POP
8508: POP
// result := list ;
8509: LD_ADDR_VAR 0 3
8513: PUSH
8514: LD_VAR 0 4
8518: ST_TO_ADDR
// end ; end_of_file
8519: LD_VAR 0 3
8523: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; every 1 do
8524: GO 8526
8526: DISABLE
// begin ru_radar := 98 ;
8527: LD_ADDR_EXP 52
8531: PUSH
8532: LD_INT 98
8534: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
8535: LD_ADDR_EXP 53
8539: PUSH
8540: LD_INT 89
8542: ST_TO_ADDR
// us_hack := 99 ;
8543: LD_ADDR_EXP 54
8547: PUSH
8548: LD_INT 99
8550: ST_TO_ADDR
// us_artillery := 97 ;
8551: LD_ADDR_EXP 55
8555: PUSH
8556: LD_INT 97
8558: ST_TO_ADDR
// ar_bio_bomb := 91 ;
8559: LD_ADDR_EXP 56
8563: PUSH
8564: LD_INT 91
8566: ST_TO_ADDR
// end ; end_of_file end_of_file end_of_file
8567: END
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; var i , eff , side ; begin
8568: LD_INT 0
8570: PPUSH
8571: PPUSH
8572: PPUSH
8573: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
8574: LD_VAR 0 1
8578: PPUSH
8579: CALL_OW 264
8583: PUSH
8584: LD_EXP 56
8588: EQUAL
8589: IFFALSE 8661
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
8591: LD_INT 68
8593: PPUSH
8594: LD_VAR 0 1
8598: PPUSH
8599: CALL_OW 255
8603: PPUSH
8604: CALL_OW 321
8608: PUSH
8609: LD_INT 2
8611: EQUAL
8612: IFFALSE 8624
// eff := 70 else
8614: LD_ADDR_VAR 0 6
8618: PUSH
8619: LD_INT 70
8621: ST_TO_ADDR
8622: GO 8632
// eff := 30 ;
8624: LD_ADDR_VAR 0 6
8628: PUSH
8629: LD_INT 30
8631: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
8632: LD_VAR 0 1
8636: PPUSH
8637: CALL_OW 250
8641: PPUSH
8642: LD_VAR 0 1
8646: PPUSH
8647: CALL_OW 251
8651: PPUSH
8652: LD_VAR 0 6
8656: PPUSH
8657: CALL_OW 495
// end ; end ;
8661: LD_VAR 0 4
8665: RET
// export function SOS_Command ( cmd ) ; var i , j , tmp , taskList , _taskList ; begin
8666: LD_INT 0
8668: PPUSH
8669: PPUSH
8670: PPUSH
8671: PPUSH
8672: PPUSH
8673: PPUSH
// if cmd = 124 then
8674: LD_VAR 0 1
8678: PUSH
8679: LD_INT 124
8681: EQUAL
8682: IFFALSE 8888
// begin tmp := FilterAllUnits ( [ f_or , [ f_weapon , ru_bulldozer ] , [ f_weapon , us_bulldozer ] ] ) ;
8684: LD_ADDR_VAR 0 5
8688: PUSH
8689: LD_INT 2
8691: PUSH
8692: LD_INT 34
8694: PUSH
8695: LD_INT 53
8697: PUSH
8698: EMPTY
8699: LIST
8700: LIST
8701: PUSH
8702: LD_INT 34
8704: PUSH
8705: LD_INT 14
8707: PUSH
8708: EMPTY
8709: LIST
8710: LIST
8711: PUSH
8712: EMPTY
8713: LIST
8714: LIST
8715: LIST
8716: PPUSH
8717: CALL_OW 69
8721: ST_TO_ADDR
// if not tmp then
8722: LD_VAR 0 5
8726: NOT
8727: IFFALSE 8731
// exit ;
8729: GO 8888
// for i in tmp do
8731: LD_ADDR_VAR 0 3
8735: PUSH
8736: LD_VAR 0 5
8740: PUSH
8741: FOR_IN
8742: IFFALSE 8886
// begin taskList := GetTaskList ( i ) ;
8744: LD_ADDR_VAR 0 6
8748: PUSH
8749: LD_VAR 0 3
8753: PPUSH
8754: CALL_OW 437
8758: ST_TO_ADDR
// if not taskList then
8759: LD_VAR 0 6
8763: NOT
8764: IFFALSE 8768
// continue ;
8766: GO 8741
// for j = 1 to taskList do
8768: LD_ADDR_VAR 0 4
8772: PUSH
8773: DOUBLE
8774: LD_INT 1
8776: DEC
8777: ST_TO_ADDR
8778: LD_VAR 0 6
8782: PUSH
8783: FOR_TO
8784: IFFALSE 8882
// if taskList [ j ] [ 1 ] = | then
8786: LD_VAR 0 6
8790: PUSH
8791: LD_VAR 0 4
8795: ARRAY
8796: PUSH
8797: LD_INT 1
8799: ARRAY
8800: PUSH
8801: LD_STRING |
8803: EQUAL
8804: IFFALSE 8880
// begin _taskList := Delete ( taskList , 1 ) ;
8806: LD_ADDR_VAR 0 7
8810: PUSH
8811: LD_VAR 0 6
8815: PPUSH
8816: LD_INT 1
8818: PPUSH
8819: CALL_OW 3
8823: ST_TO_ADDR
// SetTaskList ( i , _taskList ) ;
8824: LD_VAR 0 3
8828: PPUSH
8829: LD_VAR 0 7
8833: PPUSH
8834: CALL_OW 446
// CutTreeXYR ( i , taskList [ j ] [ 2 ] , taskList [ j ] [ 3 ] , 8 ) ;
8838: LD_VAR 0 3
8842: PPUSH
8843: LD_VAR 0 6
8847: PUSH
8848: LD_VAR 0 4
8852: ARRAY
8853: PUSH
8854: LD_INT 2
8856: ARRAY
8857: PPUSH
8858: LD_VAR 0 6
8862: PUSH
8863: LD_VAR 0 4
8867: ARRAY
8868: PUSH
8869: LD_INT 3
8871: ARRAY
8872: PPUSH
8873: LD_INT 8
8875: PPUSH
8876: CALL 8893 0 4
// end ;
8880: GO 8783
8882: POP
8883: POP
// end ;
8884: GO 8741
8886: POP
8887: POP
// end ; end ;
8888: LD_VAR 0 2
8892: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
8893: LD_INT 0
8895: PPUSH
8896: PPUSH
8897: PPUSH
8898: PPUSH
8899: PPUSH
8900: PPUSH
8901: PPUSH
8902: PPUSH
8903: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
8904: LD_VAR 0 1
8908: NOT
8909: PUSH
8910: LD_VAR 0 2
8914: PPUSH
8915: LD_VAR 0 3
8919: PPUSH
8920: CALL_OW 488
8924: NOT
8925: OR
8926: PUSH
8927: LD_VAR 0 4
8931: NOT
8932: OR
8933: IFFALSE 8937
// exit ;
8935: GO 9277
// list := [ ] ;
8937: LD_ADDR_VAR 0 13
8941: PUSH
8942: EMPTY
8943: ST_TO_ADDR
// if x - r < 0 then
8944: LD_VAR 0 2
8948: PUSH
8949: LD_VAR 0 4
8953: MINUS
8954: PUSH
8955: LD_INT 0
8957: LESS
8958: IFFALSE 8970
// min_x := 0 else
8960: LD_ADDR_VAR 0 7
8964: PUSH
8965: LD_INT 0
8967: ST_TO_ADDR
8968: GO 8986
// min_x := x - r ;
8970: LD_ADDR_VAR 0 7
8974: PUSH
8975: LD_VAR 0 2
8979: PUSH
8980: LD_VAR 0 4
8984: MINUS
8985: ST_TO_ADDR
// if y - r < 0 then
8986: LD_VAR 0 3
8990: PUSH
8991: LD_VAR 0 4
8995: MINUS
8996: PUSH
8997: LD_INT 0
8999: LESS
9000: IFFALSE 9012
// min_y := 0 else
9002: LD_ADDR_VAR 0 8
9006: PUSH
9007: LD_INT 0
9009: ST_TO_ADDR
9010: GO 9028
// min_y := y - r ;
9012: LD_ADDR_VAR 0 8
9016: PUSH
9017: LD_VAR 0 3
9021: PUSH
9022: LD_VAR 0 4
9026: MINUS
9027: ST_TO_ADDR
// max_x := x + r ;
9028: LD_ADDR_VAR 0 9
9032: PUSH
9033: LD_VAR 0 2
9037: PUSH
9038: LD_VAR 0 4
9042: PLUS
9043: ST_TO_ADDR
// max_y := y + r ;
9044: LD_ADDR_VAR 0 10
9048: PUSH
9049: LD_VAR 0 3
9053: PUSH
9054: LD_VAR 0 4
9058: PLUS
9059: ST_TO_ADDR
// for _x = min_x to max_x do
9060: LD_ADDR_VAR 0 11
9064: PUSH
9065: DOUBLE
9066: LD_VAR 0 7
9070: DEC
9071: ST_TO_ADDR
9072: LD_VAR 0 9
9076: PUSH
9077: FOR_TO
9078: IFFALSE 9195
// for _y = min_y to max_y do
9080: LD_ADDR_VAR 0 12
9084: PUSH
9085: DOUBLE
9086: LD_VAR 0 8
9090: DEC
9091: ST_TO_ADDR
9092: LD_VAR 0 10
9096: PUSH
9097: FOR_TO
9098: IFFALSE 9191
// begin if not ValidHex ( _x , _y ) then
9100: LD_VAR 0 11
9104: PPUSH
9105: LD_VAR 0 12
9109: PPUSH
9110: CALL_OW 488
9114: NOT
9115: IFFALSE 9119
// continue ;
9117: GO 9097
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
9119: LD_VAR 0 11
9123: PPUSH
9124: LD_VAR 0 12
9128: PPUSH
9129: CALL_OW 351
9133: PUSH
9134: LD_VAR 0 11
9138: PPUSH
9139: LD_VAR 0 12
9143: PPUSH
9144: CALL_OW 554
9148: AND
9149: IFFALSE 9189
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
9151: LD_ADDR_VAR 0 13
9155: PUSH
9156: LD_VAR 0 13
9160: PPUSH
9161: LD_VAR 0 13
9165: PUSH
9166: LD_INT 1
9168: PLUS
9169: PPUSH
9170: LD_VAR 0 11
9174: PUSH
9175: LD_VAR 0 12
9179: PUSH
9180: EMPTY
9181: LIST
9182: LIST
9183: PPUSH
9184: CALL_OW 2
9188: ST_TO_ADDR
// end ;
9189: GO 9097
9191: POP
9192: POP
9193: GO 9077
9195: POP
9196: POP
// if not list then
9197: LD_VAR 0 13
9201: NOT
9202: IFFALSE 9206
// exit ;
9204: GO 9277
// for i in list do
9206: LD_ADDR_VAR 0 6
9210: PUSH
9211: LD_VAR 0 13
9215: PUSH
9216: FOR_IN
9217: IFFALSE 9275
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
9219: LD_VAR 0 1
9223: PPUSH
9224: LD_STRING M
9226: PUSH
9227: LD_VAR 0 6
9231: PUSH
9232: LD_INT 1
9234: ARRAY
9235: PUSH
9236: LD_VAR 0 6
9240: PUSH
9241: LD_INT 2
9243: ARRAY
9244: PUSH
9245: LD_INT 0
9247: PUSH
9248: LD_INT 0
9250: PUSH
9251: LD_INT 0
9253: PUSH
9254: LD_INT 0
9256: PUSH
9257: EMPTY
9258: LIST
9259: LIST
9260: LIST
9261: LIST
9262: LIST
9263: LIST
9264: LIST
9265: PUSH
9266: EMPTY
9267: LIST
9268: PPUSH
9269: CALL_OW 447
9273: GO 9216
9275: POP
9276: POP
// end ;
9277: LD_VAR 0 5
9281: RET
