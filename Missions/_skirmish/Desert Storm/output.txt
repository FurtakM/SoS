// starting begin PrepareMap ;
   0: CALL 13 0 0
// Main_Variables ;
   4: CALL 136 0 0
// Start_Mission ;
   8: CALL 3478 0 0
// end ;
  12: END
// function PrepareMap ; begin
  13: LD_INT 0
  15: PPUSH
// ResetFog ;
  16: CALL_OW 335
// RandomizeAll ;
  20: CALL_OW 11
// game_difficulty := GetMultiplayerSetting ( 0 ) ;
  24: LD_ADDR_EXP 2
  28: PUSH
  29: LD_INT 0
  31: PPUSH
  32: CALL_OW 426
  36: ST_TO_ADDR
// Difficulty := game_difficulty ;
  37: LD_ADDR_OWVAR 67
  41: PUSH
  42: LD_EXP 2
  46: ST_TO_ADDR
// ChangeSideFog ( 8 , 6 ) ;
  47: LD_INT 8
  49: PPUSH
  50: LD_INT 6
  52: PPUSH
  53: CALL_OW 343
// PlaceSeeing ( 1 , 1 , 8 , - 37963 ) ;
  57: LD_INT 1
  59: PPUSH
  60: LD_INT 1
  62: PPUSH
  63: LD_INT 8
  65: PPUSH
  66: LD_INT 37963
  68: NEG
  69: PPUSH
  70: CALL_OW 330
// RemoveSeeing ( 1 , 1 , 8 ) ;
  74: LD_INT 1
  76: PPUSH
  77: LD_INT 1
  79: PPUSH
  80: LD_INT 8
  82: PPUSH
  83: CALL_OW 331
// PlaceCamera ;
  87: CALL 3945 0 0
// PrepareNature ( nature , 4 , 3 , 2 , 1 ) ;
  91: LD_INT 2
  93: PPUSH
  94: LD_INT 4
  96: PPUSH
  97: LD_INT 3
  99: PPUSH
 100: LD_INT 2
 102: PPUSH
 103: LD_INT 1
 105: PPUSH
 106: CALL 7878 0 5
// PrepareComm ;
 110: CALL 8361 0 0
// SetSide ( fort , 6 ) ;
 114: LD_INT 23
 116: PPUSH
 117: LD_INT 6
 119: PPUSH
 120: CALL_OW 235
// CenterNowOnUnits ( fort ) ;
 124: LD_INT 23
 126: PPUSH
 127: CALL_OW 87
// end ;
 131: LD_VAR 0 1
 135: RET
// export game_on , game_difficulty , game_time , game_option , game_end , game_strings ; export leopold , leopold_in_fort , samuel , samuel_in_fort , mortars_in_fort , scout ; export u_mine , u_fac ; export areas ; export skill ; export ar_weapons , ru_weapons , us_weapons ; export arabian_force , russian_force , american_force , arabian_timeing , russian_timeing , american_timeing ; export meeting_start , meeting_arive , meeting_break , meeting_end , meeting_time , russian_timer , fort_destroyed , hero_died , mission_time , cargo_ok , american_hchan , dezert , arabian_attack , russian_attack , american_attack , american_help , american_sib_bomb , russian_trade , heike_dialog1 , heike_dialog2 ; export am_comander , ru_comander , ar_comander ; function Main_Variables ; begin
 136: LD_INT 0
 138: PPUSH
// game_on := false ;
 139: LD_ADDR_EXP 1
 143: PUSH
 144: LD_INT 0
 146: ST_TO_ADDR
// game_time := 0 0$00 ;
 147: LD_ADDR_EXP 3
 151: PUSH
 152: LD_INT 0
 154: ST_TO_ADDR
// game_option := [ 1 ] ;
 155: LD_ADDR_EXP 4
 159: PUSH
 160: LD_INT 1
 162: PUSH
 163: EMPTY
 164: LIST
 165: ST_TO_ADDR
// game_end := false ;
 166: LD_ADDR_EXP 5
 170: PUSH
 171: LD_INT 0
 173: ST_TO_ADDR
// game_strings := [ ] ;
 174: LD_ADDR_EXP 6
 178: PUSH
 179: EMPTY
 180: ST_TO_ADDR
// game_time := 0 0$00 ;
 181: LD_ADDR_EXP 3
 185: PUSH
 186: LD_INT 0
 188: ST_TO_ADDR
// mission_time := 0 0$00 ;
 189: LD_ADDR_EXP 34
 193: PUSH
 194: LD_INT 0
 196: ST_TO_ADDR
// skill := [ 5 , 7 , 9 ] [ game_difficulty ] ;
 197: LD_ADDR_EXP 16
 201: PUSH
 202: LD_INT 5
 204: PUSH
 205: LD_INT 7
 207: PUSH
 208: LD_INT 9
 210: PUSH
 211: EMPTY
 212: LIST
 213: LIST
 214: LIST
 215: PUSH
 216: LD_EXP 2
 220: ARRAY
 221: ST_TO_ADDR
// areas := [ a_swest , a_nwest , a_neast , a_seast ] ;
 222: LD_ADDR_EXP 15
 226: PUSH
 227: LD_INT 5
 229: PUSH
 230: LD_INT 6
 232: PUSH
 233: LD_INT 7
 235: PUSH
 236: LD_INT 8
 238: PUSH
 239: EMPTY
 240: LIST
 241: LIST
 242: LIST
 243: LIST
 244: ST_TO_ADDR
// meeting_start := false ;
 245: LD_ADDR_EXP 26
 249: PUSH
 250: LD_INT 0
 252: ST_TO_ADDR
// meeting_arive := false ;
 253: LD_ADDR_EXP 27
 257: PUSH
 258: LD_INT 0
 260: ST_TO_ADDR
// meeting_break := false ;
 261: LD_ADDR_EXP 28
 265: PUSH
 266: LD_INT 0
 268: ST_TO_ADDR
// meeting_end := false ;
 269: LD_ADDR_EXP 29
 273: PUSH
 274: LD_INT 0
 276: ST_TO_ADDR
// meeting_time := [ 4 4$00 , 3 3$40 , 3 3$20 ] [ game_difficulty ] ;
 277: LD_ADDR_EXP 30
 281: PUSH
 282: LD_INT 8400
 284: PUSH
 285: LD_INT 7700
 287: PUSH
 288: LD_INT 7000
 290: PUSH
 291: EMPTY
 292: LIST
 293: LIST
 294: LIST
 295: PUSH
 296: LD_EXP 2
 300: ARRAY
 301: ST_TO_ADDR
// arabian_force := [ 5 , 6 , 7 ] [ game_difficulty ] ;
 302: LD_ADDR_EXP 20
 306: PUSH
 307: LD_INT 5
 309: PUSH
 310: LD_INT 6
 312: PUSH
 313: LD_INT 7
 315: PUSH
 316: EMPTY
 317: LIST
 318: LIST
 319: LIST
 320: PUSH
 321: LD_EXP 2
 325: ARRAY
 326: ST_TO_ADDR
// american_force := [ 6 , 8 , 9 ] [ game_difficulty ] ;
 327: LD_ADDR_EXP 22
 331: PUSH
 332: LD_INT 6
 334: PUSH
 335: LD_INT 8
 337: PUSH
 338: LD_INT 9
 340: PUSH
 341: EMPTY
 342: LIST
 343: LIST
 344: LIST
 345: PUSH
 346: LD_EXP 2
 350: ARRAY
 351: ST_TO_ADDR
// russian_force := [ 7 , 9 , 10 ] [ game_difficulty ] ;
 352: LD_ADDR_EXP 21
 356: PUSH
 357: LD_INT 7
 359: PUSH
 360: LD_INT 9
 362: PUSH
 363: LD_INT 10
 365: PUSH
 366: EMPTY
 367: LIST
 368: LIST
 369: LIST
 370: PUSH
 371: LD_EXP 2
 375: ARRAY
 376: ST_TO_ADDR
// u_mine := false ;
 377: LD_ADDR_EXP 13
 381: PUSH
 382: LD_INT 0
 384: ST_TO_ADDR
// u_fac := false ;
 385: LD_ADDR_EXP 14
 389: PUSH
 390: LD_INT 0
 392: ST_TO_ADDR
// leopold_in_fort := false ;
 393: LD_ADDR_EXP 8
 397: PUSH
 398: LD_INT 0
 400: ST_TO_ADDR
// samuel_in_fort := false ;
 401: LD_ADDR_EXP 10
 405: PUSH
 406: LD_INT 0
 408: ST_TO_ADDR
// mortars_in_fort := false ;
 409: LD_ADDR_EXP 11
 413: PUSH
 414: LD_INT 0
 416: ST_TO_ADDR
// fort_destroyed := false ;
 417: LD_ADDR_EXP 32
 421: PUSH
 422: LD_INT 0
 424: ST_TO_ADDR
// hero_died := false ;
 425: LD_ADDR_EXP 33
 429: PUSH
 430: LD_INT 0
 432: ST_TO_ADDR
// dezert := false ;
 433: LD_ADDR_EXP 37
 437: PUSH
 438: LD_INT 0
 440: ST_TO_ADDR
// arabian_attack := false ;
 441: LD_ADDR_EXP 38
 445: PUSH
 446: LD_INT 0
 448: ST_TO_ADDR
// russian_attack := false ;
 449: LD_ADDR_EXP 39
 453: PUSH
 454: LD_INT 0
 456: ST_TO_ADDR
// american_attack := false ;
 457: LD_ADDR_EXP 40
 461: PUSH
 462: LD_INT 0
 464: ST_TO_ADDR
// american_help := false ;
 465: LD_ADDR_EXP 41
 469: PUSH
 470: LD_INT 0
 472: ST_TO_ADDR
// american_hchan := [ 91 , 81 , 71 ] [ game_difficulty ] ;
 473: LD_ADDR_EXP 36
 477: PUSH
 478: LD_INT 91
 480: PUSH
 481: LD_INT 81
 483: PUSH
 484: LD_INT 71
 486: PUSH
 487: EMPTY
 488: LIST
 489: LIST
 490: LIST
 491: PUSH
 492: LD_EXP 2
 496: ARRAY
 497: ST_TO_ADDR
// american_sib_bomb := false ;
 498: LD_ADDR_EXP 42
 502: PUSH
 503: LD_INT 0
 505: ST_TO_ADDR
// russian_trade := false ;
 506: LD_ADDR_EXP 43
 510: PUSH
 511: LD_INT 0
 513: ST_TO_ADDR
// russian_timer := 5 5$00 ;
 514: LD_ADDR_EXP 31
 518: PUSH
 519: LD_INT 10500
 521: ST_TO_ADDR
// cargo_ok := false ;
 522: LD_ADDR_EXP 35
 526: PUSH
 527: LD_INT 0
 529: ST_TO_ADDR
// heike_dialog1 := false ;
 530: LD_ADDR_EXP 44
 534: PUSH
 535: LD_INT 0
 537: ST_TO_ADDR
// heike_dialog2 := false ;
 538: LD_ADDR_EXP 45
 542: PUSH
 543: LD_INT 0
 545: ST_TO_ADDR
// american_timeing := [ 10 10$00 , 9 9$40 , 9 9$10 ] [ game_difficulty ] ;
 546: LD_ADDR_EXP 25
 550: PUSH
 551: LD_INT 21000
 553: PUSH
 554: LD_INT 20300
 556: PUSH
 557: LD_INT 19250
 559: PUSH
 560: EMPTY
 561: LIST
 562: LIST
 563: LIST
 564: PUSH
 565: LD_EXP 2
 569: ARRAY
 570: ST_TO_ADDR
// arabian_timeing := [ 8 8$00 , 7 7$10 , 6 6$20 ] [ game_difficulty ] ;
 571: LD_ADDR_EXP 23
 575: PUSH
 576: LD_INT 16800
 578: PUSH
 579: LD_INT 15050
 581: PUSH
 582: LD_INT 13300
 584: PUSH
 585: EMPTY
 586: LIST
 587: LIST
 588: LIST
 589: PUSH
 590: LD_EXP 2
 594: ARRAY
 595: ST_TO_ADDR
// russian_timeing := [ 11 11$00 , 10 10$30 , 9 9$20 ] [ game_difficulty ] ;
 596: LD_ADDR_EXP 24
 600: PUSH
 601: LD_INT 23100
 603: PUSH
 604: LD_INT 22050
 606: PUSH
 607: LD_INT 19600
 609: PUSH
 610: EMPTY
 611: LIST
 612: LIST
 613: LIST
 614: PUSH
 615: LD_EXP 2
 619: ARRAY
 620: ST_TO_ADDR
// ar_weapons := [ ar_rocket_launcher , ar_gun , ar_flame_thrower , ar_selfpropelled_bomb , ar_bio_bomb ] ;
 621: LD_ADDR_EXP 17
 625: PUSH
 626: LD_INT 28
 628: PUSH
 629: LD_INT 27
 631: PUSH
 632: LD_INT 26
 634: PUSH
 635: LD_INT 29
 637: PUSH
 638: LD_EXP 56
 642: PUSH
 643: EMPTY
 644: LIST
 645: LIST
 646: LIST
 647: LIST
 648: LIST
 649: ST_TO_ADDR
// us_weapons := [ us_rocket_launcher , us_heavy_gun , us_double_laser , us_laser ] ;
 650: LD_ADDR_EXP 19
 654: PUSH
 655: LD_INT 7
 657: PUSH
 658: LD_INT 6
 660: PUSH
 661: LD_INT 10
 663: PUSH
 664: LD_INT 9
 666: PUSH
 667: EMPTY
 668: LIST
 669: LIST
 670: LIST
 671: LIST
 672: ST_TO_ADDR
// ru_weapons := [ ru_rocket_launcher , ru_rocket , ru_heavy_gun , ru_heavy_gun ] ;
 673: LD_ADDR_EXP 18
 677: PUSH
 678: LD_INT 45
 680: PUSH
 681: LD_INT 47
 683: PUSH
 684: LD_INT 46
 686: PUSH
 687: LD_INT 46
 689: PUSH
 690: EMPTY
 691: LIST
 692: LIST
 693: LIST
 694: LIST
 695: ST_TO_ADDR
// end ;
 696: LD_VAR 0 1
 700: RET
// every 0 0$01 trigger game_on do var i , p , x , filter ;
 701: LD_EXP 1
 705: IFFALSE 3475
 707: GO 709
 709: DISABLE
 710: LD_INT 0
 712: PPUSH
 713: PPUSH
 714: PPUSH
 715: PPUSH
// begin enable ;
 716: ENABLE
// Display_Strings := [ #tick , game_time ] ^ game_strings ;
 717: LD_ADDR_OWVAR 47
 721: PUSH
 722: LD_STRING #tick
 724: PUSH
 725: LD_EXP 3
 729: PUSH
 730: EMPTY
 731: LIST
 732: LIST
 733: PUSH
 734: LD_EXP 6
 738: ADD
 739: ST_TO_ADDR
// game_time := RefreshTime ( game_time , true ) ;
 740: LD_ADDR_EXP 3
 744: PUSH
 745: LD_EXP 3
 749: PPUSH
 750: LD_INT 1
 752: PPUSH
 753: CALL 6964 0 2
 757: ST_TO_ADDR
// if meeting_start and meeting_time > 0 0$00 then
 758: LD_EXP 26
 762: PUSH
 763: LD_EXP 30
 767: PUSH
 768: LD_INT 0
 770: GREATER
 771: AND
 772: IFFALSE 809
// begin game_strings := [ #mtime , meeting_time ] ;
 774: LD_ADDR_EXP 6
 778: PUSH
 779: LD_STRING #mtime
 781: PUSH
 782: LD_EXP 30
 786: PUSH
 787: EMPTY
 788: LIST
 789: LIST
 790: ST_TO_ADDR
// meeting_time := RefreshTime ( meeting_time , false ) ;
 791: LD_ADDR_EXP 30
 795: PUSH
 796: LD_EXP 30
 800: PPUSH
 801: LD_INT 0
 803: PPUSH
 804: CALL 6964 0 2
 808: ST_TO_ADDR
// end ; if meeting_arive then
 809: LD_EXP 27
 813: IFFALSE 833
// mission_time := RefreshTime ( mission_time , true ) ;
 815: LD_ADDR_EXP 34
 819: PUSH
 820: LD_EXP 34
 824: PPUSH
 825: LD_INT 1
 827: PPUSH
 828: CALL 6964 0 2
 832: ST_TO_ADDR
// if arabian_attack and arabian_timeing > 0 0$00 and meeting_arive then
 833: LD_EXP 38
 837: PUSH
 838: LD_EXP 23
 842: PUSH
 843: LD_INT 0
 845: GREATER
 846: AND
 847: PUSH
 848: LD_EXP 27
 852: AND
 853: IFFALSE 873
// begin arabian_timeing := RefreshTime ( arabian_timeing , false ) ;
 855: LD_ADDR_EXP 23
 859: PUSH
 860: LD_EXP 23
 864: PPUSH
 865: LD_INT 0
 867: PPUSH
 868: CALL 6964 0 2
 872: ST_TO_ADDR
// end ; if russian_attack and russian_timeing > 0 0$00 and meeting_arive then
 873: LD_EXP 39
 877: PUSH
 878: LD_EXP 24
 882: PUSH
 883: LD_INT 0
 885: GREATER
 886: AND
 887: PUSH
 888: LD_EXP 27
 892: AND
 893: IFFALSE 913
// begin russian_timeing := RefreshTime ( russian_timeing , false ) ;
 895: LD_ADDR_EXP 24
 899: PUSH
 900: LD_EXP 24
 904: PPUSH
 905: LD_INT 0
 907: PPUSH
 908: CALL 6964 0 2
 912: ST_TO_ADDR
// end ; if american_attack and american_timeing > 0 0$00 and meeting_arive then
 913: LD_EXP 40
 917: PUSH
 918: LD_EXP 25
 922: PUSH
 923: LD_INT 0
 925: GREATER
 926: AND
 927: PUSH
 928: LD_EXP 27
 932: AND
 933: IFFALSE 953
// begin american_timeing := RefreshTime ( american_timeing , false ) ;
 935: LD_ADDR_EXP 25
 939: PUSH
 940: LD_EXP 25
 944: PPUSH
 945: LD_INT 0
 947: PPUSH
 948: CALL 6964 0 2
 952: ST_TO_ADDR
// end ; if russian_trade and russian_timer > 0 0$00 then
 953: LD_EXP 43
 957: PUSH
 958: LD_EXP 31
 962: PUSH
 963: LD_INT 0
 965: GREATER
 966: AND
 967: IFFALSE 1004
// begin game_strings := [ #rtime , russian_timer ] ;
 969: LD_ADDR_EXP 6
 973: PUSH
 974: LD_STRING #rtime
 976: PUSH
 977: LD_EXP 31
 981: PUSH
 982: EMPTY
 983: LIST
 984: LIST
 985: ST_TO_ADDR
// russian_timer := RefreshTime ( russian_timer , false ) ;
 986: LD_ADDR_EXP 31
 990: PUSH
 991: LD_EXP 31
 995: PPUSH
 996: LD_INT 0
 998: PPUSH
 999: CALL 6964 0 2
1003: ST_TO_ADDR
// end ; if russian_trade and russian_timer = 0 0$00 or cargo_ok then
1004: LD_EXP 43
1008: PUSH
1009: LD_EXP 31
1013: PUSH
1014: LD_INT 0
1016: EQUAL
1017: AND
1018: PUSH
1019: LD_EXP 35
1023: OR
1024: IFFALSE 1033
// game_strings := [ ] ;
1026: LD_ADDR_EXP 6
1030: PUSH
1031: EMPTY
1032: ST_TO_ADDR
// if dezert = false and tick mod 33600 = 0 then
1033: LD_EXP 37
1037: PUSH
1038: LD_INT 0
1040: EQUAL
1041: PUSH
1042: LD_OWVAR 1
1046: PUSH
1047: LD_INT 33600
1049: MOD
1050: PUSH
1051: LD_INT 0
1053: EQUAL
1054: AND
1055: IFFALSE 1115
// begin p := Rand ( 1 , 5 ) ;
1057: LD_ADDR_VAR 0 2
1061: PUSH
1062: LD_INT 1
1064: PPUSH
1065: LD_INT 5
1067: PPUSH
1068: CALL_OW 12
1072: ST_TO_ADDR
// if p <= [ 4 , 3 , 3 ] [ game_difficulty ] then
1073: LD_VAR 0 2
1077: PUSH
1078: LD_INT 4
1080: PUSH
1081: LD_INT 3
1083: PUSH
1084: LD_INT 3
1086: PUSH
1087: EMPTY
1088: LIST
1089: LIST
1090: LIST
1091: PUSH
1092: LD_EXP 2
1096: ARRAY
1097: LESSEQUAL
1098: IFFALSE 1115
// begin RaiseSailEvent ( 92 ) ;
1100: LD_INT 92
1102: PPUSH
1103: CALL_OW 427
// dezert := true ;
1107: LD_ADDR_EXP 37
1111: PUSH
1112: LD_INT 1
1114: ST_TO_ADDR
// end ; end ; if tick mod 8400 = 0 then
1115: LD_OWVAR 1
1119: PUSH
1120: LD_INT 8400
1122: MOD
1123: PUSH
1124: LD_INT 0
1126: EQUAL
1127: IFFALSE 1136
// RaiseSailEvent ( 101 ) ;
1129: LD_INT 101
1131: PPUSH
1132: CALL_OW 427
// if MineExist ( 8 ) and u_mine = false then
1136: LD_INT 8
1138: PPUSH
1139: CALL 7018 0 1
1143: PUSH
1144: LD_EXP 13
1148: PUSH
1149: LD_INT 0
1151: EQUAL
1152: AND
1153: IFFALSE 1170
// begin u_mine := true ;
1155: LD_ADDR_EXP 13
1159: PUSH
1160: LD_INT 1
1162: ST_TO_ADDR
// ChangeMissionObjectives ( DS-T1m ) ;
1163: LD_STRING DS-T1m
1165: PPUSH
1166: CALL_OW 337
// end ; if FacExist ( 8 ) and u_fac = false then
1170: LD_INT 8
1172: PPUSH
1173: CALL 7080 0 1
1177: PUSH
1178: LD_EXP 14
1182: PUSH
1183: LD_INT 0
1185: EQUAL
1186: AND
1187: IFFALSE 1204
// begin u_fac := true ;
1189: LD_ADDR_EXP 14
1193: PUSH
1194: LD_INT 1
1196: ST_TO_ADDR
// ChangeMissionObjectives ( DS-T1f ) ;
1197: LD_STRING DS-T1f
1199: PPUSH
1200: CALL_OW 337
// end ; if hero_died then
1204: LD_EXP 33
1208: IFFALSE 1217
// YouLost ( DS-h1 ) ;
1210: LD_STRING DS-h1
1212: PPUSH
1213: CALL_OW 104
// if fort_destroyed then
1217: LD_EXP 32
1221: IFFALSE 1230
// YouLost ( DS-h2 ) ;
1223: LD_STRING DS-h2
1225: PPUSH
1226: CALL_OW 104
// if GetDistUnits ( leopold , l_cmndr ) > 6 and meeting_start = false then
1230: LD_EXP 7
1234: PPUSH
1235: LD_EXP 49
1239: PPUSH
1240: CALL_OW 296
1244: PUSH
1245: LD_INT 6
1247: GREATER
1248: PUSH
1249: LD_EXP 26
1253: PUSH
1254: LD_INT 0
1256: EQUAL
1257: AND
1258: IFFALSE 1281
// begin if not HasTask ( leopold ) then
1260: LD_EXP 7
1264: PPUSH
1265: CALL_OW 314
1269: NOT
1270: IFFALSE 1279
// RaiseSailEvent ( 1 ) ;
1272: LD_INT 1
1274: PPUSH
1275: CALL_OW 427
// end else
1279: GO 1298
// if meeting_start = false then
1281: LD_EXP 26
1285: PUSH
1286: LD_INT 0
1288: EQUAL
1289: IFFALSE 1298
// begin RaiseSailEvent ( 2 ) ;
1291: LD_INT 2
1293: PPUSH
1294: CALL_OW 427
// end ; if game_time >= [ 50 50$00 , 62 62$30 , 75 75$00 ] [ game_difficulty ] and meeting_end = false then
1298: LD_EXP 3
1302: PUSH
1303: LD_INT 105000
1305: PUSH
1306: LD_INT 131250
1308: PUSH
1309: LD_INT 157500
1311: PUSH
1312: EMPTY
1313: LIST
1314: LIST
1315: LIST
1316: PUSH
1317: LD_EXP 2
1321: ARRAY
1322: GREATEREQUAL
1323: PUSH
1324: LD_EXP 29
1328: PUSH
1329: LD_INT 0
1331: EQUAL
1332: AND
1333: IFFALSE 1350
// begin meeting_end := true ;
1335: LD_ADDR_EXP 29
1339: PUSH
1340: LD_INT 1
1342: ST_TO_ADDR
// RaiseSailEvent ( 200 ) ;
1343: LD_INT 200
1345: PPUSH
1346: CALL_OW 427
// end ; if meeting_time = 0 0$00 and meeting_arive = false then
1350: LD_EXP 30
1354: PUSH
1355: LD_INT 0
1357: EQUAL
1358: PUSH
1359: LD_EXP 27
1363: PUSH
1364: LD_INT 0
1366: EQUAL
1367: AND
1368: IFFALSE 1392
// begin meeting_arive := true ;
1370: LD_ADDR_EXP 27
1374: PUSH
1375: LD_INT 1
1377: ST_TO_ADDR
// game_strings := [ ] ;
1378: LD_ADDR_EXP 6
1382: PUSH
1383: EMPTY
1384: ST_TO_ADDR
// RaiseSailEvent ( 10 ) ;
1385: LD_INT 10
1387: PPUSH
1388: CALL_OW 427
// end ; if meeting_arive then
1392: LD_EXP 27
1396: IFFALSE 2195
// begin if arabian_attack = false and tick mod 4200 = 0 then
1398: LD_EXP 38
1402: PUSH
1403: LD_INT 0
1405: EQUAL
1406: PUSH
1407: LD_OWVAR 1
1411: PUSH
1412: LD_INT 4200
1414: MOD
1415: PUSH
1416: LD_INT 0
1418: EQUAL
1419: AND
1420: IFFALSE 1473
// begin p := Rand ( 1 , 100 ) ;
1422: LD_ADDR_VAR 0 2
1426: PUSH
1427: LD_INT 1
1429: PPUSH
1430: LD_INT 100
1432: PPUSH
1433: CALL_OW 12
1437: ST_TO_ADDR
// if p <= [ 80 , 85 , 90 ] [ game_difficulty ] then
1438: LD_VAR 0 2
1442: PUSH
1443: LD_INT 80
1445: PUSH
1446: LD_INT 85
1448: PUSH
1449: LD_INT 90
1451: PUSH
1452: EMPTY
1453: LIST
1454: LIST
1455: LIST
1456: PUSH
1457: LD_EXP 2
1461: ARRAY
1462: LESSEQUAL
1463: IFFALSE 1473
// arabian_attack := true ;
1465: LD_ADDR_EXP 38
1469: PUSH
1470: LD_INT 1
1472: ST_TO_ADDR
// end ; if russian_trade = false and russian_attack = false and tick > 52500 then
1473: LD_EXP 43
1477: PUSH
1478: LD_INT 0
1480: EQUAL
1481: PUSH
1482: LD_EXP 39
1486: PUSH
1487: LD_INT 0
1489: EQUAL
1490: AND
1491: PUSH
1492: LD_OWVAR 1
1496: PUSH
1497: LD_INT 52500
1499: GREATER
1500: AND
1501: IFFALSE 1572
// begin russian_trade = true ;
1503: LD_ADDR_EXP 43
1507: PUSH
1508: LD_INT 1
1510: ST_TO_ADDR
// DialogueOn ;
1511: CALL_OW 6
// SayRadio ( ru_comander , DS-DR-RTr ) ;
1515: LD_EXP 47
1519: PPUSH
1520: LD_STRING DS-DR-RTr
1522: PPUSH
1523: CALL_OW 94
// Say ( l_cmndr , DS-DC-RTr ) ;
1527: LD_EXP 49
1531: PPUSH
1532: LD_STRING DS-DC-RTr
1534: PPUSH
1535: CALL_OW 88
// SayRadio ( ru_comander , DS-DR-RTr2 ) ;
1539: LD_EXP 47
1543: PPUSH
1544: LD_STRING DS-DR-RTr2
1546: PPUSH
1547: CALL_OW 94
// DialogueOff ;
1551: CALL_OW 7
// ChangeMissionObjectives ( DS-T2 ) ;
1555: LD_STRING DS-T2
1557: PPUSH
1558: CALL_OW 337
// SetAreaMapShow ( tree , 1 ) ;
1562: LD_INT 10
1564: PPUSH
1565: LD_INT 1
1567: PPUSH
1568: CALL_OW 424
// end ; if russian_trade and cargo_ok = false and russian_timer > 0 0$00 then
1572: LD_EXP 43
1576: PUSH
1577: LD_EXP 35
1581: PUSH
1582: LD_INT 0
1584: EQUAL
1585: AND
1586: PUSH
1587: LD_EXP 31
1591: PUSH
1592: LD_INT 0
1594: GREATER
1595: AND
1596: IFFALSE 1845
// begin if FilterUnitsInArea ( tree , ( [ [ f_empty ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] , [ f_not , [ f_control , control_remote ] ] ] ) ) > 0 then
1598: LD_INT 10
1600: PPUSH
1601: LD_INT 58
1603: PUSH
1604: EMPTY
1605: LIST
1606: PUSH
1607: LD_INT 2
1609: PUSH
1610: LD_INT 34
1612: PUSH
1613: LD_INT 32
1615: PUSH
1616: EMPTY
1617: LIST
1618: LIST
1619: PUSH
1620: LD_INT 34
1622: PUSH
1623: LD_INT 12
1625: PUSH
1626: EMPTY
1627: LIST
1628: LIST
1629: PUSH
1630: EMPTY
1631: LIST
1632: LIST
1633: LIST
1634: PUSH
1635: LD_INT 3
1637: PUSH
1638: LD_INT 33
1640: PUSH
1641: LD_INT 2
1643: PUSH
1644: EMPTY
1645: LIST
1646: LIST
1647: PUSH
1648: EMPTY
1649: LIST
1650: LIST
1651: PUSH
1652: EMPTY
1653: LIST
1654: LIST
1655: LIST
1656: PPUSH
1657: CALL_OW 70
1661: PUSH
1662: LD_INT 0
1664: GREATER
1665: IFFALSE 1845
// if GetCargo ( FilterUnitsInArea ( tree , ( [ [ f_empty ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] , [ f_not , [ f_control , control_remote ] ] ] ) ) [ 1 ] , mat_siberit ) = 100 then
1667: LD_INT 10
1669: PPUSH
1670: LD_INT 58
1672: PUSH
1673: EMPTY
1674: LIST
1675: PUSH
1676: LD_INT 2
1678: PUSH
1679: LD_INT 34
1681: PUSH
1682: LD_INT 32
1684: PUSH
1685: EMPTY
1686: LIST
1687: LIST
1688: PUSH
1689: LD_INT 34
1691: PUSH
1692: LD_INT 12
1694: PUSH
1695: EMPTY
1696: LIST
1697: LIST
1698: PUSH
1699: EMPTY
1700: LIST
1701: LIST
1702: LIST
1703: PUSH
1704: LD_INT 3
1706: PUSH
1707: LD_INT 33
1709: PUSH
1710: LD_INT 2
1712: PUSH
1713: EMPTY
1714: LIST
1715: LIST
1716: PUSH
1717: EMPTY
1718: LIST
1719: LIST
1720: PUSH
1721: EMPTY
1722: LIST
1723: LIST
1724: LIST
1725: PPUSH
1726: CALL_OW 70
1730: PUSH
1731: LD_INT 1
1733: ARRAY
1734: PPUSH
1735: LD_INT 3
1737: PPUSH
1738: CALL_OW 289
1742: PUSH
1743: LD_INT 100
1745: EQUAL
1746: IFFALSE 1845
// begin cargo_ok := true ;
1748: LD_ADDR_EXP 35
1752: PUSH
1753: LD_INT 1
1755: ST_TO_ADDR
// RemoveUnit ( FilterUnitsInArea ( tree , ( [ [ f_empty ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] , [ f_not , [ f_control , control_remote ] ] ] ) ) [ 1 ] ) ;
1756: LD_INT 10
1758: PPUSH
1759: LD_INT 58
1761: PUSH
1762: EMPTY
1763: LIST
1764: PUSH
1765: LD_INT 2
1767: PUSH
1768: LD_INT 34
1770: PUSH
1771: LD_INT 32
1773: PUSH
1774: EMPTY
1775: LIST
1776: LIST
1777: PUSH
1778: LD_INT 34
1780: PUSH
1781: LD_INT 12
1783: PUSH
1784: EMPTY
1785: LIST
1786: LIST
1787: PUSH
1788: EMPTY
1789: LIST
1790: LIST
1791: LIST
1792: PUSH
1793: LD_INT 3
1795: PUSH
1796: LD_INT 33
1798: PUSH
1799: LD_INT 2
1801: PUSH
1802: EMPTY
1803: LIST
1804: LIST
1805: PUSH
1806: EMPTY
1807: LIST
1808: LIST
1809: PUSH
1810: EMPTY
1811: LIST
1812: LIST
1813: LIST
1814: PPUSH
1815: CALL_OW 70
1819: PUSH
1820: LD_INT 1
1822: ARRAY
1823: PPUSH
1824: CALL_OW 64
// ChangeMissionObjectives ( DS-T2-out ) ;
1828: LD_STRING DS-T2-out
1830: PPUSH
1831: CALL_OW 337
// SetAreaMapShow ( tree , 0 ) ;
1835: LD_INT 10
1837: PPUSH
1838: LD_INT 0
1840: PPUSH
1841: CALL_OW 424
// end ; end ; if russian_attack = false and russian_trade and cargo_ok = false and russian_timer = 0 0$00 then
1845: LD_EXP 39
1849: PUSH
1850: LD_INT 0
1852: EQUAL
1853: PUSH
1854: LD_EXP 43
1858: AND
1859: PUSH
1860: LD_EXP 35
1864: PUSH
1865: LD_INT 0
1867: EQUAL
1868: AND
1869: PUSH
1870: LD_EXP 31
1874: PUSH
1875: LD_INT 0
1877: EQUAL
1878: AND
1879: IFFALSE 1906
// begin russian_attack := true ;
1881: LD_ADDR_EXP 39
1885: PUSH
1886: LD_INT 1
1888: ST_TO_ADDR
// ChangeMissionObjectives ( DS-T2-out ) ;
1889: LD_STRING DS-T2-out
1891: PPUSH
1892: CALL_OW 337
// SetAreaMapShow ( tree , 0 ) ;
1896: LD_INT 10
1898: PPUSH
1899: LD_INT 0
1901: PPUSH
1902: CALL_OW 424
// end ; if russian_trade = false and russian_attack = false and american_attack = false and tick mod 21000 = 0 then
1906: LD_EXP 43
1910: PUSH
1911: LD_INT 0
1913: EQUAL
1914: PUSH
1915: LD_EXP 39
1919: PUSH
1920: LD_INT 0
1922: EQUAL
1923: AND
1924: PUSH
1925: LD_EXP 40
1929: PUSH
1930: LD_INT 0
1932: EQUAL
1933: AND
1934: PUSH
1935: LD_OWVAR 1
1939: PUSH
1940: LD_INT 21000
1942: MOD
1943: PUSH
1944: LD_INT 0
1946: EQUAL
1947: AND
1948: IFFALSE 2001
// begin p := Rand ( 1 , 100 ) ;
1950: LD_ADDR_VAR 0 2
1954: PUSH
1955: LD_INT 1
1957: PPUSH
1958: LD_INT 100
1960: PPUSH
1961: CALL_OW 12
1965: ST_TO_ADDR
// if p <= [ 25 , 35 , 45 ] [ game_difficulty ] then
1966: LD_VAR 0 2
1970: PUSH
1971: LD_INT 25
1973: PUSH
1974: LD_INT 35
1976: PUSH
1977: LD_INT 45
1979: PUSH
1980: EMPTY
1981: LIST
1982: LIST
1983: LIST
1984: PUSH
1985: LD_EXP 2
1989: ARRAY
1990: LESSEQUAL
1991: IFFALSE 2001
// russian_attack := true ;
1993: LD_ADDR_EXP 39
1997: PUSH
1998: LD_INT 1
2000: ST_TO_ADDR
// end ; if american_help = false and american_attack = false and russian_attack = false and tick mod 31500 = 0 then
2001: LD_EXP 41
2005: PUSH
2006: LD_INT 0
2008: EQUAL
2009: PUSH
2010: LD_EXP 40
2014: PUSH
2015: LD_INT 0
2017: EQUAL
2018: AND
2019: PUSH
2020: LD_EXP 39
2024: PUSH
2025: LD_INT 0
2027: EQUAL
2028: AND
2029: PUSH
2030: LD_OWVAR 1
2034: PUSH
2035: LD_INT 31500
2037: MOD
2038: PUSH
2039: LD_INT 0
2041: EQUAL
2042: AND
2043: IFFALSE 2096
// begin p := Rand ( 1 , 100 ) ;
2045: LD_ADDR_VAR 0 2
2049: PUSH
2050: LD_INT 1
2052: PPUSH
2053: LD_INT 100
2055: PPUSH
2056: CALL_OW 12
2060: ST_TO_ADDR
// if p <= [ 22 , 33 , 44 ] [ game_difficulty ] then
2061: LD_VAR 0 2
2065: PUSH
2066: LD_INT 22
2068: PUSH
2069: LD_INT 33
2071: PUSH
2072: LD_INT 44
2074: PUSH
2075: EMPTY
2076: LIST
2077: LIST
2078: LIST
2079: PUSH
2080: LD_EXP 2
2084: ARRAY
2085: LESSEQUAL
2086: IFFALSE 2096
// american_attack := true ;
2088: LD_ADDR_EXP 40
2092: PUSH
2093: LD_INT 1
2095: ST_TO_ADDR
// end ; if american_attack = false and russian_attack = false and american_help = false and tick mod 21200 = 0 then
2096: LD_EXP 40
2100: PUSH
2101: LD_INT 0
2103: EQUAL
2104: PUSH
2105: LD_EXP 39
2109: PUSH
2110: LD_INT 0
2112: EQUAL
2113: AND
2114: PUSH
2115: LD_EXP 41
2119: PUSH
2120: LD_INT 0
2122: EQUAL
2123: AND
2124: PUSH
2125: LD_OWVAR 1
2129: PUSH
2130: LD_INT 21200
2132: MOD
2133: PUSH
2134: LD_INT 0
2136: EQUAL
2137: AND
2138: IFFALSE 2195
// begin p := Rand ( 1 , 100 ) ;
2140: LD_ADDR_VAR 0 2
2144: PUSH
2145: LD_INT 1
2147: PPUSH
2148: LD_INT 100
2150: PPUSH
2151: CALL_OW 12
2155: ST_TO_ADDR
// if p <= american_hchan then
2156: LD_VAR 0 2
2160: PUSH
2161: LD_EXP 36
2165: LESSEQUAL
2166: IFFALSE 2195
// begin american_help := true ;
2168: LD_ADDR_EXP 41
2172: PUSH
2173: LD_INT 1
2175: ST_TO_ADDR
// SayRadio ( am_comander , DS-amhelp ) ;
2176: LD_EXP 46
2180: PPUSH
2181: LD_STRING DS-amhelp
2183: PPUSH
2184: CALL_OW 94
// RaiseSailEvent ( 91 ) ;
2188: LD_INT 91
2190: PPUSH
2191: CALL_OW 427
// end ; end ; end ; if american_attack and american_timeing = 0 0$00 and FilterAllUnits ( [ f_side , 1 ] ) = 0 then
2195: LD_EXP 40
2199: PUSH
2200: LD_EXP 25
2204: PUSH
2205: LD_INT 0
2207: EQUAL
2208: AND
2209: PUSH
2210: LD_INT 22
2212: PUSH
2213: LD_INT 1
2215: PUSH
2216: EMPTY
2217: LIST
2218: LIST
2219: PPUSH
2220: CALL_OW 69
2224: PUSH
2225: LD_INT 0
2227: EQUAL
2228: AND
2229: IFFALSE 2331
// begin american_timeing := Rand ( 17 17$00 , 20 20$00 ) ;
2231: LD_ADDR_EXP 25
2235: PUSH
2236: LD_INT 35700
2238: PPUSH
2239: LD_INT 42000
2241: PPUSH
2242: CALL_OW 12
2246: ST_TO_ADDR
// SayRadio ( scout , DS-DZ-U ) ;
2247: LD_EXP 12
2251: PPUSH
2252: LD_STRING DS-DZ-U
2254: PPUSH
2255: CALL_OW 94
// Wait ( 0 0$33 ) ;
2259: LD_INT 1155
2261: PPUSH
2262: CALL_OW 67
// x := Rand ( 1 , 2 ) ;
2266: LD_ADDR_VAR 0 3
2270: PUSH
2271: LD_INT 1
2273: PPUSH
2274: LD_INT 2
2276: PPUSH
2277: CALL_OW 12
2281: ST_TO_ADDR
// case x of 1 :
2282: LD_VAR 0 3
2286: PUSH
2287: LD_INT 1
2289: DOUBLE
2290: EQUAL
2291: IFTRUE 2295
2293: GO 2305
2295: POP
// RaiseSailEvent ( 41 ) ; 2 :
2296: LD_INT 41
2298: PPUSH
2299: CALL_OW 427
2303: GO 2324
2305: LD_INT 2
2307: DOUBLE
2308: EQUAL
2309: IFTRUE 2313
2311: GO 2323
2313: POP
// RaiseSailEvent ( 42 ) ; end ;
2314: LD_INT 42
2316: PPUSH
2317: CALL_OW 427
2321: GO 2324
2323: POP
// RaiseSailEvent ( 42 ) ;
2324: LD_INT 42
2326: PPUSH
2327: CALL_OW 427
// end ; if russian_attack and russian_timeing = 0 0$00 and FilterAllUnits ( [ f_side , 3 ] ) = 0 then
2331: LD_EXP 39
2335: PUSH
2336: LD_EXP 24
2340: PUSH
2341: LD_INT 0
2343: EQUAL
2344: AND
2345: PUSH
2346: LD_INT 22
2348: PUSH
2349: LD_INT 3
2351: PUSH
2352: EMPTY
2353: LIST
2354: LIST
2355: PPUSH
2356: CALL_OW 69
2360: PUSH
2361: LD_INT 0
2363: EQUAL
2364: AND
2365: IFFALSE 2421
// begin russian_timeing := Rand ( 17 17$00 , 20 20$00 ) ;
2367: LD_ADDR_EXP 24
2371: PUSH
2372: LD_INT 35700
2374: PPUSH
2375: LD_INT 42000
2377: PPUSH
2378: CALL_OW 12
2382: ST_TO_ADDR
// SayRadio ( scout , DS-DZ-R ) ;
2383: LD_EXP 12
2387: PPUSH
2388: LD_STRING DS-DZ-R
2390: PPUSH
2391: CALL_OW 94
// Wait ( 0 0$45 ) ;
2395: LD_INT 1575
2397: PPUSH
2398: CALL_OW 67
// SayRadio ( ru_comander , DS-DR-R1 ) ;
2402: LD_EXP 47
2406: PPUSH
2407: LD_STRING DS-DR-R1
2409: PPUSH
2410: CALL_OW 94
// RaiseSailEvent ( 51 ) ;
2414: LD_INT 51
2416: PPUSH
2417: CALL_OW 427
// end ; if mission_time >= 10 10$00 and arabian_force < 10 then
2421: LD_EXP 34
2425: PUSH
2426: LD_INT 21000
2428: GREATEREQUAL
2429: PUSH
2430: LD_EXP 20
2434: PUSH
2435: LD_INT 10
2437: LESS
2438: AND
2439: IFFALSE 2463
// begin mission_time := 0 0$00 ;
2441: LD_ADDR_EXP 34
2445: PUSH
2446: LD_INT 0
2448: ST_TO_ADDR
// arabian_force := arabian_force + 1 ;
2449: LD_ADDR_EXP 20
2453: PUSH
2454: LD_EXP 20
2458: PUSH
2459: LD_INT 1
2461: PLUS
2462: ST_TO_ADDR
// end ; if arabian_timeing = 0 0$00 and FilterAllUnits ( [ [ f_side , 2 ] , [ f_not , [ f_weapon , ar_control_tower ] ] ] ) = 0 then
2463: LD_EXP 23
2467: PUSH
2468: LD_INT 0
2470: EQUAL
2471: PUSH
2472: LD_INT 22
2474: PUSH
2475: LD_INT 2
2477: PUSH
2478: EMPTY
2479: LIST
2480: LIST
2481: PUSH
2482: LD_INT 3
2484: PUSH
2485: LD_INT 34
2487: PUSH
2488: LD_INT 31
2490: PUSH
2491: EMPTY
2492: LIST
2493: LIST
2494: PUSH
2495: EMPTY
2496: LIST
2497: LIST
2498: PUSH
2499: EMPTY
2500: LIST
2501: LIST
2502: PPUSH
2503: CALL_OW 69
2507: PUSH
2508: LD_INT 0
2510: EQUAL
2511: AND
2512: IFFALSE 2710
// begin arabian_timeing := 7 7$30 ;
2514: LD_ADDR_EXP 23
2518: PUSH
2519: LD_INT 15750
2521: ST_TO_ADDR
// x := Rand ( 1 , 3 ) ;
2522: LD_ADDR_VAR 0 3
2526: PUSH
2527: LD_INT 1
2529: PPUSH
2530: LD_INT 3
2532: PPUSH
2533: CALL_OW 12
2537: ST_TO_ADDR
// SayRadio ( scout , DS-DZ-H ) ;
2538: LD_EXP 12
2542: PPUSH
2543: LD_STRING DS-DZ-H
2545: PPUSH
2546: CALL_OW 94
// case x of 1 :
2550: LD_VAR 0 3
2554: PUSH
2555: LD_INT 1
2557: DOUBLE
2558: EQUAL
2559: IFTRUE 2563
2561: GO 2573
2563: POP
// RaiseSailEvent ( 31 ) ; 2 :
2564: LD_INT 31
2566: PPUSH
2567: CALL_OW 427
2571: GO 2610
2573: LD_INT 2
2575: DOUBLE
2576: EQUAL
2577: IFTRUE 2581
2579: GO 2591
2581: POP
// RaiseSailEvent ( 32 ) ; 3 :
2582: LD_INT 32
2584: PPUSH
2585: CALL_OW 427
2589: GO 2610
2591: LD_INT 3
2593: DOUBLE
2594: EQUAL
2595: IFTRUE 2599
2597: GO 2609
2599: POP
// RaiseSailEvent ( 33 ) ; end ;
2600: LD_INT 33
2602: PPUSH
2603: CALL_OW 427
2607: GO 2610
2609: POP
// RaiseSailEvent ( 33 ) ;
2610: LD_INT 33
2612: PPUSH
2613: CALL_OW 427
// if game_difficulty > 1 then
2617: LD_EXP 2
2621: PUSH
2622: LD_INT 1
2624: GREATER
2625: IFFALSE 2634
// RaiseSailEvent ( 33 ) ;
2627: LD_INT 33
2629: PPUSH
2630: CALL_OW 427
// if heike_dialog1 = false then
2634: LD_EXP 44
2638: PUSH
2639: LD_INT 0
2641: EQUAL
2642: IFFALSE 2673
// begin heike_dialog1 := true ;
2644: LD_ADDR_EXP 44
2648: PUSH
2649: LD_INT 1
2651: ST_TO_ADDR
// Wait ( 0 0$03 ) ;
2652: LD_INT 105
2654: PPUSH
2655: CALL_OW 67
// SayRadio ( ar_comander , heike1 ) ;
2659: LD_EXP 48
2663: PPUSH
2664: LD_STRING heike1
2666: PPUSH
2667: CALL_OW 94
// end else
2671: GO 2710
// if heike_dialog2 = false then
2673: LD_EXP 45
2677: PUSH
2678: LD_INT 0
2680: EQUAL
2681: IFFALSE 2710
// begin heike_dialog2 := true ;
2683: LD_ADDR_EXP 45
2687: PUSH
2688: LD_INT 1
2690: ST_TO_ADDR
// Wait ( 0 0$03 ) ;
2691: LD_INT 105
2693: PPUSH
2694: CALL_OW 67
// SayRadio ( ar_comander , heike2 ) ;
2698: LD_EXP 48
2702: PPUSH
2703: LD_STRING heike2
2705: PPUSH
2706: CALL_OW 94
// end ; end ; if FilterAllUnits ( [ [ f_side , 2 ] , [ f_control , control_remote ] ] ) > 0 then
2710: LD_INT 22
2712: PUSH
2713: LD_INT 2
2715: PUSH
2716: EMPTY
2717: LIST
2718: LIST
2719: PUSH
2720: LD_INT 33
2722: PUSH
2723: LD_INT 2
2725: PUSH
2726: EMPTY
2727: LIST
2728: LIST
2729: PUSH
2730: EMPTY
2731: LIST
2732: LIST
2733: PPUSH
2734: CALL_OW 69
2738: PUSH
2739: LD_INT 0
2741: GREATER
2742: IFFALSE 2751
// ConnectWithTower ( 2 ) ;
2744: LD_INT 2
2746: PPUSH
2747: CALL 7128 0 1
// if FilterAllUnits ( [ [ [ f_side , 2 ] , [ f_not , [ f_weapon , ar_control_tower ] ] , [ f_not , [ f_hastask ] ] ] ] ) > 0 then
2751: LD_INT 22
2753: PUSH
2754: LD_INT 2
2756: PUSH
2757: EMPTY
2758: LIST
2759: LIST
2760: PUSH
2761: LD_INT 3
2763: PUSH
2764: LD_INT 34
2766: PUSH
2767: LD_INT 31
2769: PUSH
2770: EMPTY
2771: LIST
2772: LIST
2773: PUSH
2774: EMPTY
2775: LIST
2776: LIST
2777: PUSH
2778: LD_INT 3
2780: PUSH
2781: LD_INT 60
2783: PUSH
2784: EMPTY
2785: LIST
2786: PUSH
2787: EMPTY
2788: LIST
2789: LIST
2790: PUSH
2791: EMPTY
2792: LIST
2793: LIST
2794: LIST
2795: PUSH
2796: EMPTY
2797: LIST
2798: PPUSH
2799: CALL_OW 69
2803: PUSH
2804: LD_INT 0
2806: GREATER
2807: IFFALSE 2953
// begin filter := FilterAllUnits ( [ [ [ f_side , 2 ] , [ f_not , [ f_weapon , ar_control_tower ] ] , [ f_not , [ f_hastask ] ] ] ] ) ;
2809: LD_ADDR_VAR 0 4
2813: PUSH
2814: LD_INT 22
2816: PUSH
2817: LD_INT 2
2819: PUSH
2820: EMPTY
2821: LIST
2822: LIST
2823: PUSH
2824: LD_INT 3
2826: PUSH
2827: LD_INT 34
2829: PUSH
2830: LD_INT 31
2832: PUSH
2833: EMPTY
2834: LIST
2835: LIST
2836: PUSH
2837: EMPTY
2838: LIST
2839: LIST
2840: PUSH
2841: LD_INT 3
2843: PUSH
2844: LD_INT 60
2846: PUSH
2847: EMPTY
2848: LIST
2849: PUSH
2850: EMPTY
2851: LIST
2852: LIST
2853: PUSH
2854: EMPTY
2855: LIST
2856: LIST
2857: LIST
2858: PUSH
2859: EMPTY
2860: LIST
2861: PPUSH
2862: CALL_OW 69
2866: ST_TO_ADDR
// x := SpeedFilter ( FilterAllUnits ( [ f_enemy , 2 ] ) , 20 ) ;
2867: LD_ADDR_VAR 0 3
2871: PUSH
2872: LD_INT 81
2874: PUSH
2875: LD_INT 2
2877: PUSH
2878: EMPTY
2879: LIST
2880: LIST
2881: PPUSH
2882: CALL_OW 69
2886: PPUSH
2887: LD_INT 20
2889: PPUSH
2890: CALL 8511 0 2
2894: ST_TO_ADDR
// for i = 1 to filter do
2895: LD_ADDR_VAR 0 1
2899: PUSH
2900: DOUBLE
2901: LD_INT 1
2903: DEC
2904: ST_TO_ADDR
2905: LD_VAR 0 4
2909: PUSH
2910: FOR_TO
2911: IFFALSE 2951
// ComAttackUnit ( filter [ i ] , NearestUnitToUnit ( x , filter [ i ] ) ) ;
2913: LD_VAR 0 4
2917: PUSH
2918: LD_VAR 0 1
2922: ARRAY
2923: PPUSH
2924: LD_VAR 0 3
2928: PPUSH
2929: LD_VAR 0 4
2933: PUSH
2934: LD_VAR 0 1
2938: ARRAY
2939: PPUSH
2940: CALL_OW 74
2944: PPUSH
2945: CALL_OW 115
2949: GO 2910
2951: POP
2952: POP
// end ; if FilterAllUnits ( [ [ [ f_side , 3 ] , [ f_not , [ f_hastask ] ] ] ] ) > 0 then
2953: LD_INT 22
2955: PUSH
2956: LD_INT 3
2958: PUSH
2959: EMPTY
2960: LIST
2961: LIST
2962: PUSH
2963: LD_INT 3
2965: PUSH
2966: LD_INT 60
2968: PUSH
2969: EMPTY
2970: LIST
2971: PUSH
2972: EMPTY
2973: LIST
2974: LIST
2975: PUSH
2976: EMPTY
2977: LIST
2978: LIST
2979: PUSH
2980: EMPTY
2981: LIST
2982: PPUSH
2983: CALL_OW 69
2987: PUSH
2988: LD_INT 0
2990: GREATER
2991: IFFALSE 3137
// begin filter := FilterAllUnits ( [ [ [ f_side , 3 ] , [ f_not , [ f_weapon , ar_control_tower ] ] , [ f_not , [ f_hastask ] ] ] ] ) ;
2993: LD_ADDR_VAR 0 4
2997: PUSH
2998: LD_INT 22
3000: PUSH
3001: LD_INT 3
3003: PUSH
3004: EMPTY
3005: LIST
3006: LIST
3007: PUSH
3008: LD_INT 3
3010: PUSH
3011: LD_INT 34
3013: PUSH
3014: LD_INT 31
3016: PUSH
3017: EMPTY
3018: LIST
3019: LIST
3020: PUSH
3021: EMPTY
3022: LIST
3023: LIST
3024: PUSH
3025: LD_INT 3
3027: PUSH
3028: LD_INT 60
3030: PUSH
3031: EMPTY
3032: LIST
3033: PUSH
3034: EMPTY
3035: LIST
3036: LIST
3037: PUSH
3038: EMPTY
3039: LIST
3040: LIST
3041: LIST
3042: PUSH
3043: EMPTY
3044: LIST
3045: PPUSH
3046: CALL_OW 69
3050: ST_TO_ADDR
// x := SpeedFilter ( FilterAllUnits ( [ f_enemy , 3 ] ) , 20 ) ;
3051: LD_ADDR_VAR 0 3
3055: PUSH
3056: LD_INT 81
3058: PUSH
3059: LD_INT 3
3061: PUSH
3062: EMPTY
3063: LIST
3064: LIST
3065: PPUSH
3066: CALL_OW 69
3070: PPUSH
3071: LD_INT 20
3073: PPUSH
3074: CALL 8511 0 2
3078: ST_TO_ADDR
// for i = 1 to filter do
3079: LD_ADDR_VAR 0 1
3083: PUSH
3084: DOUBLE
3085: LD_INT 1
3087: DEC
3088: ST_TO_ADDR
3089: LD_VAR 0 4
3093: PUSH
3094: FOR_TO
3095: IFFALSE 3135
// ComAttackUnit ( filter [ i ] , NearestUnitToUnit ( x , filter [ i ] ) ) ;
3097: LD_VAR 0 4
3101: PUSH
3102: LD_VAR 0 1
3106: ARRAY
3107: PPUSH
3108: LD_VAR 0 3
3112: PPUSH
3113: LD_VAR 0 4
3117: PUSH
3118: LD_VAR 0 1
3122: ARRAY
3123: PPUSH
3124: CALL_OW 74
3128: PPUSH
3129: CALL_OW 115
3133: GO 3094
3135: POP
3136: POP
// end ; if FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_not , [ f_hastask ] ] ] ] ) > 0 then
3137: LD_INT 22
3139: PUSH
3140: LD_INT 1
3142: PUSH
3143: EMPTY
3144: LIST
3145: LIST
3146: PUSH
3147: LD_INT 3
3149: PUSH
3150: LD_INT 60
3152: PUSH
3153: EMPTY
3154: LIST
3155: PUSH
3156: EMPTY
3157: LIST
3158: LIST
3159: PUSH
3160: EMPTY
3161: LIST
3162: LIST
3163: PUSH
3164: EMPTY
3165: LIST
3166: PPUSH
3167: CALL_OW 69
3171: PUSH
3172: LD_INT 0
3174: GREATER
3175: IFFALSE 3321
// begin filter := FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_not , [ f_weapon , ar_control_tower ] ] , [ f_not , [ f_hastask ] ] ] ] ) ;
3177: LD_ADDR_VAR 0 4
3181: PUSH
3182: LD_INT 22
3184: PUSH
3185: LD_INT 1
3187: PUSH
3188: EMPTY
3189: LIST
3190: LIST
3191: PUSH
3192: LD_INT 3
3194: PUSH
3195: LD_INT 34
3197: PUSH
3198: LD_INT 31
3200: PUSH
3201: EMPTY
3202: LIST
3203: LIST
3204: PUSH
3205: EMPTY
3206: LIST
3207: LIST
3208: PUSH
3209: LD_INT 3
3211: PUSH
3212: LD_INT 60
3214: PUSH
3215: EMPTY
3216: LIST
3217: PUSH
3218: EMPTY
3219: LIST
3220: LIST
3221: PUSH
3222: EMPTY
3223: LIST
3224: LIST
3225: LIST
3226: PUSH
3227: EMPTY
3228: LIST
3229: PPUSH
3230: CALL_OW 69
3234: ST_TO_ADDR
// x := SpeedFilter ( FilterAllUnits ( [ f_enemy , 1 ] ) , 20 ) ;
3235: LD_ADDR_VAR 0 3
3239: PUSH
3240: LD_INT 81
3242: PUSH
3243: LD_INT 1
3245: PUSH
3246: EMPTY
3247: LIST
3248: LIST
3249: PPUSH
3250: CALL_OW 69
3254: PPUSH
3255: LD_INT 20
3257: PPUSH
3258: CALL 8511 0 2
3262: ST_TO_ADDR
// for i = 1 to filter do
3263: LD_ADDR_VAR 0 1
3267: PUSH
3268: DOUBLE
3269: LD_INT 1
3271: DEC
3272: ST_TO_ADDR
3273: LD_VAR 0 4
3277: PUSH
3278: FOR_TO
3279: IFFALSE 3319
// ComAttackUnit ( filter [ i ] , NearestUnitToUnit ( x , filter [ i ] ) ) ;
3281: LD_VAR 0 4
3285: PUSH
3286: LD_VAR 0 1
3290: ARRAY
3291: PPUSH
3292: LD_VAR 0 3
3296: PPUSH
3297: LD_VAR 0 4
3301: PUSH
3302: LD_VAR 0 1
3306: ARRAY
3307: PPUSH
3308: CALL_OW 74
3312: PPUSH
3313: CALL_OW 115
3317: GO 3278
3319: POP
3320: POP
// end ; if FilterAllUnits ( [ [ [ f_side , 2 ] , [ f_weapon , ar_bio_bomb ] , [ f_not , [ f_lives , 700 ] ] ] ] ) > 0 then
3321: LD_INT 22
3323: PUSH
3324: LD_INT 2
3326: PUSH
3327: EMPTY
3328: LIST
3329: LIST
3330: PUSH
3331: LD_INT 34
3333: PUSH
3334: LD_EXP 56
3338: PUSH
3339: EMPTY
3340: LIST
3341: LIST
3342: PUSH
3343: LD_INT 3
3345: PUSH
3346: LD_INT 24
3348: PUSH
3349: LD_INT 700
3351: PUSH
3352: EMPTY
3353: LIST
3354: LIST
3355: PUSH
3356: EMPTY
3357: LIST
3358: LIST
3359: PUSH
3360: EMPTY
3361: LIST
3362: LIST
3363: LIST
3364: PUSH
3365: EMPTY
3366: LIST
3367: PPUSH
3368: CALL_OW 69
3372: PUSH
3373: LD_INT 0
3375: GREATER
3376: IFFALSE 3475
// begin filter := FilterAllUnits ( [ [ [ f_side , 2 ] , [ f_weapon , ar_bio_bomb ] , [ f_not , [ f_lives , 700 ] ] ] ] ) ;
3378: LD_ADDR_VAR 0 4
3382: PUSH
3383: LD_INT 22
3385: PUSH
3386: LD_INT 2
3388: PUSH
3389: EMPTY
3390: LIST
3391: LIST
3392: PUSH
3393: LD_INT 34
3395: PUSH
3396: LD_EXP 56
3400: PUSH
3401: EMPTY
3402: LIST
3403: LIST
3404: PUSH
3405: LD_INT 3
3407: PUSH
3408: LD_INT 24
3410: PUSH
3411: LD_INT 700
3413: PUSH
3414: EMPTY
3415: LIST
3416: LIST
3417: PUSH
3418: EMPTY
3419: LIST
3420: LIST
3421: PUSH
3422: EMPTY
3423: LIST
3424: LIST
3425: LIST
3426: PUSH
3427: EMPTY
3428: LIST
3429: PPUSH
3430: CALL_OW 69
3434: ST_TO_ADDR
// for i = 1 to filter do
3435: LD_ADDR_VAR 0 1
3439: PUSH
3440: DOUBLE
3441: LD_INT 1
3443: DEC
3444: ST_TO_ADDR
3445: LD_VAR 0 4
3449: PUSH
3450: FOR_TO
3451: IFFALSE 3473
// SetLives ( filter [ i ] , 1 ) ;
3453: LD_VAR 0 4
3457: PUSH
3458: LD_VAR 0 1
3462: ARRAY
3463: PPUSH
3464: LD_INT 1
3466: PPUSH
3467: CALL_OW 234
3471: GO 3450
3473: POP
3474: POP
// end ; end ; end_of_file
3475: PPOPN 4
3477: END
// export function Start_Mission ; begin
3478: LD_INT 0
3480: PPUSH
// PrepareLegion ;
3481: CALL 3522 0 0
// PrepareMeeting ;
3485: CALL 4139 0 0
// case Query ( DS-text-beg ) of 1 :
3489: LD_STRING DS-text-beg
3491: PPUSH
3492: CALL_OW 97
3496: PUSH
3497: LD_INT 1
3499: DOUBLE
3500: EQUAL
3501: IFTRUE 3505
3503: GO 3508
3505: POP
// ; end ;
3506: GO 3509
3508: POP
// game_on := true ;
3509: LD_ADDR_EXP 1
3513: PUSH
3514: LD_INT 1
3516: ST_TO_ADDR
// end ;
3517: LD_VAR 0 1
3521: RET
// export l_cmndr , l_skill , l_units ; function PrepareLegion ; var i , p , filter , team ; begin
3522: LD_INT 0
3524: PPUSH
3525: PPUSH
3526: PPUSH
3527: PPUSH
3528: PPUSH
// uc_side := 8 ;
3529: LD_ADDR_OWVAR 20
3533: PUSH
3534: LD_INT 8
3536: ST_TO_ADDR
// uc_nation := 2 ;
3537: LD_ADDR_OWVAR 21
3541: PUSH
3542: LD_INT 2
3544: ST_TO_ADDR
// l_skill := [ 7 , 6 , 5 ] [ difficulty ] ;
3545: LD_ADDR_EXP 50
3549: PUSH
3550: LD_INT 7
3552: PUSH
3553: LD_INT 6
3555: PUSH
3556: LD_INT 5
3558: PUSH
3559: EMPTY
3560: LIST
3561: LIST
3562: LIST
3563: PUSH
3564: LD_OWVAR 67
3568: ARRAY
3569: ST_TO_ADDR
// l_units := [ 8 , 7 , 6 ] [ difficulty ] ;
3570: LD_ADDR_EXP 51
3574: PUSH
3575: LD_INT 8
3577: PUSH
3578: LD_INT 7
3580: PUSH
3581: LD_INT 6
3583: PUSH
3584: EMPTY
3585: LIST
3586: LIST
3587: LIST
3588: PUSH
3589: LD_OWVAR 67
3593: ARRAY
3594: ST_TO_ADDR
// filter := [ ] ;
3595: LD_ADDR_VAR 0 4
3599: PUSH
3600: EMPTY
3601: ST_TO_ADDR
// hc_gallery := desert ;
3602: LD_ADDR_OWVAR 33
3606: PUSH
3607: LD_STRING desert
3609: ST_TO_ADDR
// hc_face_number := 1 ;
3610: LD_ADDR_OWVAR 34
3614: PUSH
3615: LD_INT 1
3617: ST_TO_ADDR
// hc_skills := [ l_skill + 2 , l_skill - 1 , l_skill , l_skill + 1 ] ;
3618: LD_ADDR_OWVAR 31
3622: PUSH
3623: LD_EXP 50
3627: PUSH
3628: LD_INT 2
3630: PLUS
3631: PUSH
3632: LD_EXP 50
3636: PUSH
3637: LD_INT 1
3639: MINUS
3640: PUSH
3641: LD_EXP 50
3645: PUSH
3646: LD_EXP 50
3650: PUSH
3651: LD_INT 1
3653: PLUS
3654: PUSH
3655: EMPTY
3656: LIST
3657: LIST
3658: LIST
3659: LIST
3660: ST_TO_ADDR
// hc_sex := sex_male ;
3661: LD_ADDR_OWVAR 27
3665: PUSH
3666: LD_INT 1
3668: ST_TO_ADDR
// hc_name := Henri Ruotz ;
3669: LD_ADDR_OWVAR 26
3673: PUSH
3674: LD_STRING Henri Ruotz
3676: ST_TO_ADDR
// hc_attr := [ 10 , 10 ] ;
3677: LD_ADDR_OWVAR 29
3681: PUSH
3682: LD_INT 10
3684: PUSH
3685: LD_INT 10
3687: PUSH
3688: EMPTY
3689: LIST
3690: LIST
3691: ST_TO_ADDR
// hc_class := 1 ;
3692: LD_ADDR_OWVAR 28
3696: PUSH
3697: LD_INT 1
3699: ST_TO_ADDR
// hc_importance := 100 ;
3700: LD_ADDR_OWVAR 32
3704: PUSH
3705: LD_INT 100
3707: ST_TO_ADDR
// l_cmndr := CreateHuman ;
3708: LD_ADDR_EXP 49
3712: PUSH
3713: CALL_OW 44
3717: ST_TO_ADDR
// hc_importance := 0 ;
3718: LD_ADDR_OWVAR 32
3722: PUSH
3723: LD_INT 0
3725: ST_TO_ADDR
// scout := PrepareHuman ( sex_male , 1 , 0 ) ;
3726: LD_ADDR_EXP 12
3730: PUSH
3731: LD_INT 1
3733: PPUSH
3734: LD_INT 1
3736: PPUSH
3737: LD_INT 0
3739: PPUSH
3740: CALL_OW 380
3744: ST_TO_ADDR
// for i = 1 to 4 do
3745: LD_ADDR_VAR 0 2
3749: PUSH
3750: DOUBLE
3751: LD_INT 1
3753: DEC
3754: ST_TO_ADDR
3755: LD_INT 4
3757: PUSH
3758: FOR_TO
3759: IFFALSE 3809
// for p = 1 to 6 do
3761: LD_ADDR_VAR 0 3
3765: PUSH
3766: DOUBLE
3767: LD_INT 1
3769: DEC
3770: ST_TO_ADDR
3771: LD_INT 6
3773: PUSH
3774: FOR_TO
3775: IFFALSE 3805
// filter := filter ^ CreateHumanWithClass ( i , l_skill ) ;
3777: LD_ADDR_VAR 0 4
3781: PUSH
3782: LD_VAR 0 4
3786: PUSH
3787: LD_VAR 0 2
3791: PPUSH
3792: LD_EXP 50
3796: PPUSH
3797: CALL 7312 0 2
3801: ADD
3802: ST_TO_ADDR
3803: GO 3774
3805: POP
3806: POP
3807: GO 3758
3809: POP
3810: POP
// team := CharacterSelection ( text , l_units , l_units , [ sel_change_class , l_cmndr , sel_changeable , sel_not_hired ] ^ filter , [ class_soldier , class_mechanic , class_engineer , class_scientistic , class_mortar ] ) ;
3811: LD_ADDR_VAR 0 5
3815: PUSH
3816: LD_STRING text
3818: PPUSH
3819: LD_EXP 51
3823: PPUSH
3824: LD_EXP 51
3828: PPUSH
3829: LD_INT -5
3831: PUSH
3832: LD_EXP 49
3836: PUSH
3837: LD_INT -3
3839: PUSH
3840: LD_INT -2
3842: PUSH
3843: EMPTY
3844: LIST
3845: LIST
3846: LIST
3847: LIST
3848: PUSH
3849: LD_VAR 0 4
3853: ADD
3854: PPUSH
3855: LD_INT 1
3857: PUSH
3858: LD_INT 3
3860: PUSH
3861: LD_INT 2
3863: PUSH
3864: LD_INT 4
3866: PUSH
3867: LD_INT 8
3869: PUSH
3870: EMPTY
3871: LIST
3872: LIST
3873: LIST
3874: LIST
3875: LIST
3876: PPUSH
3877: CALL_OW 42
3881: ST_TO_ADDR
// for i = 1 to l_units do
3882: LD_ADDR_VAR 0 2
3886: PUSH
3887: DOUBLE
3888: LD_INT 1
3890: DEC
3891: ST_TO_ADDR
3892: LD_EXP 51
3896: PUSH
3897: FOR_TO
3898: IFFALSE 3923
// PlaceUnitArea ( team [ i ] , legion_spawn , false ) ;
3900: LD_VAR 0 5
3904: PUSH
3905: LD_VAR 0 2
3909: ARRAY
3910: PPUSH
3911: LD_INT 1
3913: PPUSH
3914: LD_INT 0
3916: PPUSH
3917: CALL_OW 49
3921: GO 3897
3923: POP
3924: POP
// PlaceUnitArea ( l_cmndr , legion_spawn , false ) ;
3925: LD_EXP 49
3929: PPUSH
3930: LD_INT 1
3932: PPUSH
3933: LD_INT 0
3935: PPUSH
3936: CALL_OW 49
// end ;
3940: LD_VAR 0 1
3944: RET
// export function PlaceCamera ; begin
3945: LD_INT 0
3947: PPUSH
// PlaceSeeing ( 46 , 48 , 8 , 10 ) ;
3948: LD_INT 46
3950: PPUSH
3951: LD_INT 48
3953: PPUSH
3954: LD_INT 8
3956: PPUSH
3957: LD_INT 10
3959: PPUSH
3960: CALL_OW 330
// PlaceSeeing ( 58 , 66 , 8 , 10 ) ;
3964: LD_INT 58
3966: PPUSH
3967: LD_INT 66
3969: PPUSH
3970: LD_INT 8
3972: PPUSH
3973: LD_INT 10
3975: PPUSH
3976: CALL_OW 330
// PlaceSeeing ( 82 , 82 , 8 , 10 ) ;
3980: LD_INT 82
3982: PPUSH
3983: LD_INT 82
3985: PPUSH
3986: LD_INT 8
3988: PPUSH
3989: LD_INT 10
3991: PPUSH
3992: CALL_OW 330
// PlaceSeeing ( 107 , 79 , 8 , 10 ) ;
3996: LD_INT 107
3998: PPUSH
3999: LD_INT 79
4001: PPUSH
4002: LD_INT 8
4004: PPUSH
4005: LD_INT 10
4007: PPUSH
4008: CALL_OW 330
// PlaceSeeing ( 101 , 57 , 8 , 10 ) ;
4012: LD_INT 101
4014: PPUSH
4015: LD_INT 57
4017: PPUSH
4018: LD_INT 8
4020: PPUSH
4021: LD_INT 10
4023: PPUSH
4024: CALL_OW 330
// PlaceSeeing ( 85 , 32 , 8 , 10 ) ;
4028: LD_INT 85
4030: PPUSH
4031: LD_INT 32
4033: PPUSH
4034: LD_INT 8
4036: PPUSH
4037: LD_INT 10
4039: PPUSH
4040: CALL_OW 330
// PlaceSeeing ( 108 , 72 , 8 , 10 ) ;
4044: LD_INT 108
4046: PPUSH
4047: LD_INT 72
4049: PPUSH
4050: LD_INT 8
4052: PPUSH
4053: LD_INT 10
4055: PPUSH
4056: CALL_OW 330
// PlaceSeeing ( 124 , 74 , 8 , 10 ) ;
4060: LD_INT 124
4062: PPUSH
4063: LD_INT 74
4065: PPUSH
4066: LD_INT 8
4068: PPUSH
4069: LD_INT 10
4071: PPUSH
4072: CALL_OW 330
// PlaceSeeing ( 67 , 33 , 8 , 20 ) ;
4076: LD_INT 67
4078: PPUSH
4079: LD_INT 33
4081: PPUSH
4082: LD_INT 8
4084: PPUSH
4085: LD_INT 20
4087: PPUSH
4088: CALL_OW 330
// RemoveSeeing ( 67 , 33 , 8 ) ;
4092: LD_INT 67
4094: PPUSH
4095: LD_INT 33
4097: PPUSH
4098: LD_INT 8
4100: PPUSH
4101: CALL_OW 331
// PlaceSeeing ( 94 , 84 , 8 , 20 ) ;
4105: LD_INT 94
4107: PPUSH
4108: LD_INT 84
4110: PPUSH
4111: LD_INT 8
4113: PPUSH
4114: LD_INT 20
4116: PPUSH
4117: CALL_OW 330
// RemoveSeeing ( 94 , 84 , 8 ) ;
4121: LD_INT 94
4123: PPUSH
4124: LD_INT 84
4126: PPUSH
4127: LD_INT 8
4129: PPUSH
4130: CALL_OW 331
// end ;
4134: LD_VAR 0 1
4138: RET
// export function PrepareMeeting ; begin
4139: LD_INT 0
4141: PPUSH
// uc_side := 6 ;
4142: LD_ADDR_OWVAR 20
4146: PUSH
4147: LD_INT 6
4149: ST_TO_ADDR
// hc_gallery := desert ;
4150: LD_ADDR_OWVAR 33
4154: PUSH
4155: LD_STRING desert
4157: ST_TO_ADDR
// hc_face_number := 2 ;
4158: LD_ADDR_OWVAR 34
4162: PUSH
4163: LD_INT 2
4165: ST_TO_ADDR
// hc_name := Leopold Drass ;
4166: LD_ADDR_OWVAR 26
4170: PUSH
4171: LD_STRING Leopold Drass
4173: ST_TO_ADDR
// hc_class := 1 ;
4174: LD_ADDR_OWVAR 28
4178: PUSH
4179: LD_INT 1
4181: ST_TO_ADDR
// hc_sex := sex_male ;
4182: LD_ADDR_OWVAR 27
4186: PUSH
4187: LD_INT 1
4189: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
4190: LD_ADDR_OWVAR 29
4194: PUSH
4195: LD_INT 12
4197: PUSH
4198: LD_INT 12
4200: PUSH
4201: EMPTY
4202: LIST
4203: LIST
4204: ST_TO_ADDR
// Leopold := CreateHuman ;
4205: LD_ADDR_EXP 7
4209: PUSH
4210: CALL_OW 44
4214: ST_TO_ADDR
// PlaceUnitArea ( Leopold , north_spawn , false ) ;
4215: LD_EXP 7
4219: PPUSH
4220: LD_INT 3
4222: PPUSH
4223: LD_INT 0
4225: PPUSH
4226: CALL_OW 49
// end ; end_of_file
4230: LD_VAR 0 1
4234: RET
// on SailEvent ( num ) do var i , filter , un , p , area ;
4235: LD_INT 0
4237: PPUSH
4238: PPUSH
4239: PPUSH
4240: PPUSH
4241: PPUSH
// begin case num of 1 :
4242: LD_VAR 0 1
4246: PUSH
4247: LD_INT 1
4249: DOUBLE
4250: EQUAL
4251: IFTRUE 4255
4253: GO 4287
4255: POP
// begin ComMoveXY ( leopold , GetX ( l_cmndr ) , GetY ( l_cmndr ) ) ;
4256: LD_EXP 7
4260: PPUSH
4261: LD_EXP 49
4265: PPUSH
4266: CALL_OW 250
4270: PPUSH
4271: LD_EXP 49
4275: PPUSH
4276: CALL_OW 251
4280: PPUSH
4281: CALL_OW 111
// end ; 2 :
4285: GO 6705
4287: LD_INT 2
4289: DOUBLE
4290: EQUAL
4291: IFTRUE 4295
4293: GO 4404
4295: POP
// begin InGameOn ;
4296: CALL_OW 8
// meeting_start := true ;
4300: LD_ADDR_EXP 26
4304: PUSH
4305: LD_INT 1
4307: ST_TO_ADDR
// ComTurnUnit ( leopold , l_cmndr ) ;
4308: LD_EXP 7
4312: PPUSH
4313: LD_EXP 49
4317: PPUSH
4318: CALL_OW 119
// ComTurnUnit ( l_cmndr , leopold ) ;
4322: LD_EXP 49
4326: PPUSH
4327: LD_EXP 7
4331: PPUSH
4332: CALL_OW 119
// Say ( leopold , DS-DL-1 ) ;
4336: LD_EXP 7
4340: PPUSH
4341: LD_STRING DS-DL-1
4343: PPUSH
4344: CALL_OW 88
// Say ( l_cmndr , DS-DC-1 ) ;
4348: LD_EXP 49
4352: PPUSH
4353: LD_STRING DS-DC-1
4355: PPUSH
4356: CALL_OW 88
// Say ( leopold , DS-DL-2 ) ;
4360: LD_EXP 7
4364: PPUSH
4365: LD_STRING DS-DL-2
4367: PPUSH
4368: CALL_OW 88
// ComEnterUnit ( leopold , fort ) ;
4372: LD_EXP 7
4376: PPUSH
4377: LD_INT 23
4379: PPUSH
4380: CALL_OW 120
// InGameOff ;
4384: CALL_OW 9
// Wait ( 0 0$01 ) ;
4388: LD_INT 35
4390: PPUSH
4391: CALL_OW 67
// ChangeMissionObjectives ( DS-T1 ) ;
4395: LD_STRING DS-T1
4397: PPUSH
4398: CALL_OW 337
// end ; 10 :
4402: GO 6705
4404: LD_INT 10
4406: DOUBLE
4407: EQUAL
4408: IFTRUE 4412
4410: GO 4624
4412: POP
// begin uc_side := 6 ;
4413: LD_ADDR_OWVAR 20
4417: PUSH
4418: LD_INT 6
4420: ST_TO_ADDR
// uc_nation := 2 ;
4421: LD_ADDR_OWVAR 21
4425: PUSH
4426: LD_INT 2
4428: ST_TO_ADDR
// hc_gallery :=  ;
4429: LD_ADDR_OWVAR 33
4433: PUSH
4434: LD_STRING 
4436: ST_TO_ADDR
// hc_skills := [ skill + 2 , skill - 1 , skill , skill + 1 ] ;
4437: LD_ADDR_OWVAR 31
4441: PUSH
4442: LD_EXP 16
4446: PUSH
4447: LD_INT 2
4449: PLUS
4450: PUSH
4451: LD_EXP 16
4455: PUSH
4456: LD_INT 1
4458: MINUS
4459: PUSH
4460: LD_EXP 16
4464: PUSH
4465: LD_EXP 16
4469: PUSH
4470: LD_INT 1
4472: PLUS
4473: PUSH
4474: EMPTY
4475: LIST
4476: LIST
4477: LIST
4478: LIST
4479: ST_TO_ADDR
// hc_sex := sex_male ;
4480: LD_ADDR_OWVAR 27
4484: PUSH
4485: LD_INT 1
4487: ST_TO_ADDR
// hc_name := Samuel van Horn ;
4488: LD_ADDR_OWVAR 26
4492: PUSH
4493: LD_STRING Samuel van Horn
4495: ST_TO_ADDR
// hc_attr := [ 11 , 10 ] ;
4496: LD_ADDR_OWVAR 29
4500: PUSH
4501: LD_INT 11
4503: PUSH
4504: LD_INT 10
4506: PUSH
4507: EMPTY
4508: LIST
4509: LIST
4510: ST_TO_ADDR
// hc_class := 1 ;
4511: LD_ADDR_OWVAR 28
4515: PUSH
4516: LD_INT 1
4518: ST_TO_ADDR
// samuel := CreateHuman ;
4519: LD_ADDR_EXP 9
4523: PUSH
4524: CALL_OW 44
4528: ST_TO_ADDR
// PlaceUnitArea ( samuel , south_spawn , false ) ;
4529: LD_EXP 9
4533: PPUSH
4534: LD_INT 4
4536: PPUSH
4537: LD_INT 0
4539: PPUSH
4540: CALL_OW 49
// for i = 1 to 3 do
4544: LD_ADDR_VAR 0 2
4548: PUSH
4549: DOUBLE
4550: LD_INT 1
4552: DEC
4553: ST_TO_ADDR
4554: LD_INT 3
4556: PUSH
4557: FOR_TO
4558: IFFALSE 4585
// PlaceUnitArea ( CreateHumanWithClass ( class_mortar , skill ) , south_spawn , false ) ;
4560: LD_INT 8
4562: PPUSH
4563: LD_EXP 16
4567: PPUSH
4568: CALL 7312 0 2
4572: PPUSH
4573: LD_INT 4
4575: PPUSH
4576: LD_INT 0
4578: PPUSH
4579: CALL_OW 49
4583: GO 4557
4585: POP
4586: POP
// ComEnterUnit ( FilterAllUnits ( [ f_side , 6 ] ) diff [ leopold , fort ] , fort ) ;
4587: LD_INT 22
4589: PUSH
4590: LD_INT 6
4592: PUSH
4593: EMPTY
4594: LIST
4595: LIST
4596: PPUSH
4597: CALL_OW 69
4601: PUSH
4602: LD_EXP 7
4606: PUSH
4607: LD_INT 23
4609: PUSH
4610: EMPTY
4611: LIST
4612: LIST
4613: DIFF
4614: PPUSH
4615: LD_INT 23
4617: PPUSH
4618: CALL_OW 120
// end ; 3 :
4622: GO 6705
4624: LD_INT 3
4626: DOUBLE
4627: EQUAL
4628: IFTRUE 4632
4630: GO 4643
4632: POP
// begin arabian_attack := true ;
4633: LD_ADDR_EXP 38
4637: PUSH
4638: LD_INT 1
4640: ST_TO_ADDR
// end ; 4 :
4641: GO 6705
4643: LD_INT 4
4645: DOUBLE
4646: EQUAL
4647: IFTRUE 4651
4649: GO 4662
4651: POP
// begin american_attack := true ;
4652: LD_ADDR_EXP 40
4656: PUSH
4657: LD_INT 1
4659: ST_TO_ADDR
// end ; 5 :
4660: GO 6705
4662: LD_INT 5
4664: DOUBLE
4665: EQUAL
4666: IFTRUE 4670
4668: GO 4681
4670: POP
// begin russian_attack := true ;
4671: LD_ADDR_EXP 39
4675: PUSH
4676: LD_INT 1
4678: ST_TO_ADDR
// end ; 31 :
4679: GO 6705
4681: LD_INT 31
4683: DOUBLE
4684: EQUAL
4685: IFTRUE 4689
4687: GO 4964
4689: POP
// begin area := areas [ Rand ( 1 , areas ) ] ;
4690: LD_ADDR_VAR 0 6
4694: PUSH
4695: LD_EXP 15
4699: PUSH
4700: LD_INT 1
4702: PPUSH
4703: LD_EXP 15
4707: PPUSH
4708: CALL_OW 12
4712: ARRAY
4713: ST_TO_ADDR
// uc_side := 2 ;
4714: LD_ADDR_OWVAR 20
4718: PUSH
4719: LD_INT 2
4721: ST_TO_ADDR
// uc_nation := 2 ;
4722: LD_ADDR_OWVAR 21
4726: PUSH
4727: LD_INT 2
4729: ST_TO_ADDR
// for i = 1 to arabian_force do
4730: LD_ADDR_VAR 0 2
4734: PUSH
4735: DOUBLE
4736: LD_INT 1
4738: DEC
4739: ST_TO_ADDR
4740: LD_EXP 20
4744: PUSH
4745: FOR_TO
4746: IFFALSE 4825
// begin vc_chassis := ar_half_tracked ;
4748: LD_ADDR_OWVAR 37
4752: PUSH
4753: LD_INT 14
4755: ST_TO_ADDR
// vc_engine := engine_siberite ;
4756: LD_ADDR_OWVAR 39
4760: PUSH
4761: LD_INT 3
4763: ST_TO_ADDR
// vc_control := control_remote ;
4764: LD_ADDR_OWVAR 38
4768: PUSH
4769: LD_INT 2
4771: ST_TO_ADDR
// vc_weapon := ar_weapons [ Rand ( 1 , ar_weapons ) ] ;
4772: LD_ADDR_OWVAR 40
4776: PUSH
4777: LD_EXP 17
4781: PUSH
4782: LD_INT 1
4784: PPUSH
4785: LD_EXP 17
4789: PPUSH
4790: CALL_OW 12
4794: ARRAY
4795: ST_TO_ADDR
// un := CreateVehicle ;
4796: LD_ADDR_VAR 0 4
4800: PUSH
4801: CALL_OW 45
4805: ST_TO_ADDR
// PlaceUnitArea ( un , area , false ) ;
4806: LD_VAR 0 4
4810: PPUSH
4811: LD_VAR 0 6
4815: PPUSH
4816: LD_INT 0
4818: PPUSH
4819: CALL_OW 49
// end ;
4823: GO 4745
4825: POP
4826: POP
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_control , control_manual ] ] ) < 2 then
4827: LD_INT 22
4829: PUSH
4830: LD_INT 2
4832: PUSH
4833: EMPTY
4834: LIST
4835: LIST
4836: PUSH
4837: LD_INT 33
4839: PUSH
4840: LD_INT 1
4842: PUSH
4843: EMPTY
4844: LIST
4845: LIST
4846: PUSH
4847: EMPTY
4848: LIST
4849: LIST
4850: PPUSH
4851: CALL_OW 69
4855: PUSH
4856: LD_INT 2
4858: LESS
4859: IFFALSE 4962
// for i = 1 to 2 do
4861: LD_ADDR_VAR 0 2
4865: PUSH
4866: DOUBLE
4867: LD_INT 1
4869: DEC
4870: ST_TO_ADDR
4871: LD_INT 2
4873: PUSH
4874: FOR_TO
4875: IFFALSE 4960
// begin vc_chassis := ar_half_tracked ;
4877: LD_ADDR_OWVAR 37
4881: PUSH
4882: LD_INT 14
4884: ST_TO_ADDR
// vc_engine := engine_siberite ;
4885: LD_ADDR_OWVAR 39
4889: PUSH
4890: LD_INT 3
4892: ST_TO_ADDR
// vc_control := control_manual ;
4893: LD_ADDR_OWVAR 38
4897: PUSH
4898: LD_INT 1
4900: ST_TO_ADDR
// vc_weapon := ar_control_tower ;
4901: LD_ADDR_OWVAR 40
4905: PUSH
4906: LD_INT 31
4908: ST_TO_ADDR
// un := CreateVehicle ;
4909: LD_ADDR_VAR 0 4
4913: PUSH
4914: CALL_OW 45
4918: ST_TO_ADDR
// PlaceUnitArea ( un , area , false ) ;
4919: LD_VAR 0 4
4923: PPUSH
4924: LD_VAR 0 6
4928: PPUSH
4929: LD_INT 0
4931: PPUSH
4932: CALL_OW 49
// PlaceHumanInUnit ( CreateHumanWithClass ( 3 , skill ) , un ) ;
4936: LD_INT 3
4938: PPUSH
4939: LD_EXP 16
4943: PPUSH
4944: CALL 7312 0 2
4948: PPUSH
4949: LD_VAR 0 4
4953: PPUSH
4954: CALL_OW 52
// end ;
4958: GO 4874
4960: POP
4961: POP
// end ; 32 :
4962: GO 6705
4964: LD_INT 32
4966: DOUBLE
4967: EQUAL
4968: IFTRUE 4972
4970: GO 5345
4972: POP
// begin area := areas [ Rand ( 1 , areas ) ] ;
4973: LD_ADDR_VAR 0 6
4977: PUSH
4978: LD_EXP 15
4982: PUSH
4983: LD_INT 1
4985: PPUSH
4986: LD_EXP 15
4990: PPUSH
4991: CALL_OW 12
4995: ARRAY
4996: ST_TO_ADDR
// uc_side := 2 ;
4997: LD_ADDR_OWVAR 20
5001: PUSH
5002: LD_INT 2
5004: ST_TO_ADDR
// uc_nation := 2 ;
5005: LD_ADDR_OWVAR 21
5009: PUSH
5010: LD_INT 2
5012: ST_TO_ADDR
// for i = 1 to ( arabian_force - 2 ) do
5013: LD_ADDR_VAR 0 2
5017: PUSH
5018: DOUBLE
5019: LD_INT 1
5021: DEC
5022: ST_TO_ADDR
5023: LD_EXP 20
5027: PUSH
5028: LD_INT 2
5030: MINUS
5031: PUSH
5032: FOR_TO
5033: IFFALSE 5116
// begin vc_chassis := ar_half_tracked ;
5035: LD_ADDR_OWVAR 37
5039: PUSH
5040: LD_INT 14
5042: ST_TO_ADDR
// vc_engine := engine_siberite ;
5043: LD_ADDR_OWVAR 39
5047: PUSH
5048: LD_INT 3
5050: ST_TO_ADDR
// vc_control := control_remote ;
5051: LD_ADDR_OWVAR 38
5055: PUSH
5056: LD_INT 2
5058: ST_TO_ADDR
// vc_weapon := ar_weapons [ Rand ( 1 , ar_weapons - 1 ) ] ;
5059: LD_ADDR_OWVAR 40
5063: PUSH
5064: LD_EXP 17
5068: PUSH
5069: LD_INT 1
5071: PPUSH
5072: LD_EXP 17
5076: PUSH
5077: LD_INT 1
5079: MINUS
5080: PPUSH
5081: CALL_OW 12
5085: ARRAY
5086: ST_TO_ADDR
// un := CreateVehicle ;
5087: LD_ADDR_VAR 0 4
5091: PUSH
5092: CALL_OW 45
5096: ST_TO_ADDR
// PlaceUnitArea ( un , area , false ) ;
5097: LD_VAR 0 4
5101: PPUSH
5102: LD_VAR 0 6
5106: PPUSH
5107: LD_INT 0
5109: PPUSH
5110: CALL_OW 49
// end ;
5114: GO 5032
5116: POP
5117: POP
// for i = 1 to Rand ( 0 , 1 ) + [ 3 , 4 , 5 ] [ game_difficulty ] do
5118: LD_ADDR_VAR 0 2
5122: PUSH
5123: DOUBLE
5124: LD_INT 1
5126: DEC
5127: ST_TO_ADDR
5128: LD_INT 0
5130: PPUSH
5131: LD_INT 1
5133: PPUSH
5134: CALL_OW 12
5138: PUSH
5139: LD_INT 3
5141: PUSH
5142: LD_INT 4
5144: PUSH
5145: LD_INT 5
5147: PUSH
5148: EMPTY
5149: LIST
5150: LIST
5151: LIST
5152: PUSH
5153: LD_EXP 2
5157: ARRAY
5158: PLUS
5159: PUSH
5160: FOR_TO
5161: IFFALSE 5198
// begin uc_nation := 0 ;
5163: LD_ADDR_OWVAR 21
5167: PUSH
5168: LD_INT 0
5170: ST_TO_ADDR
// PlaceUnitArea ( CreateHumanWithClass ( 17 , skill ) , area , false ) ;
5171: LD_INT 17
5173: PPUSH
5174: LD_EXP 16
5178: PPUSH
5179: CALL 7312 0 2
5183: PPUSH
5184: LD_VAR 0 6
5188: PPUSH
5189: LD_INT 0
5191: PPUSH
5192: CALL_OW 49
// end ;
5196: GO 5160
5198: POP
5199: POP
// uc_nation := 2 ;
5200: LD_ADDR_OWVAR 21
5204: PUSH
5205: LD_INT 2
5207: ST_TO_ADDR
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_control , control_manual ] ] ) < 2 then
5208: LD_INT 22
5210: PUSH
5211: LD_INT 2
5213: PUSH
5214: EMPTY
5215: LIST
5216: LIST
5217: PUSH
5218: LD_INT 33
5220: PUSH
5221: LD_INT 1
5223: PUSH
5224: EMPTY
5225: LIST
5226: LIST
5227: PUSH
5228: EMPTY
5229: LIST
5230: LIST
5231: PPUSH
5232: CALL_OW 69
5236: PUSH
5237: LD_INT 2
5239: LESS
5240: IFFALSE 5343
// for i = 1 to 2 do
5242: LD_ADDR_VAR 0 2
5246: PUSH
5247: DOUBLE
5248: LD_INT 1
5250: DEC
5251: ST_TO_ADDR
5252: LD_INT 2
5254: PUSH
5255: FOR_TO
5256: IFFALSE 5341
// begin vc_chassis := ar_half_tracked ;
5258: LD_ADDR_OWVAR 37
5262: PUSH
5263: LD_INT 14
5265: ST_TO_ADDR
// vc_engine := engine_siberite ;
5266: LD_ADDR_OWVAR 39
5270: PUSH
5271: LD_INT 3
5273: ST_TO_ADDR
// vc_control := control_manual ;
5274: LD_ADDR_OWVAR 38
5278: PUSH
5279: LD_INT 1
5281: ST_TO_ADDR
// vc_weapon := ar_control_tower ;
5282: LD_ADDR_OWVAR 40
5286: PUSH
5287: LD_INT 31
5289: ST_TO_ADDR
// un := CreateVehicle ;
5290: LD_ADDR_VAR 0 4
5294: PUSH
5295: CALL_OW 45
5299: ST_TO_ADDR
// PlaceUnitArea ( un , area , false ) ;
5300: LD_VAR 0 4
5304: PPUSH
5305: LD_VAR 0 6
5309: PPUSH
5310: LD_INT 0
5312: PPUSH
5313: CALL_OW 49
// PlaceHumanInUnit ( CreateHumanWithClass ( 3 , skill ) , un ) ;
5317: LD_INT 3
5319: PPUSH
5320: LD_EXP 16
5324: PPUSH
5325: CALL 7312 0 2
5329: PPUSH
5330: LD_VAR 0 4
5334: PPUSH
5335: CALL_OW 52
// end ;
5339: GO 5255
5341: POP
5342: POP
// end ; 33 :
5343: GO 6705
5345: LD_INT 33
5347: DOUBLE
5348: EQUAL
5349: IFTRUE 5353
5351: GO 5624
5353: POP
// begin area := areas [ Rand ( 1 , areas ) ] ;
5354: LD_ADDR_VAR 0 6
5358: PUSH
5359: LD_EXP 15
5363: PUSH
5364: LD_INT 1
5366: PPUSH
5367: LD_EXP 15
5371: PPUSH
5372: CALL_OW 12
5376: ARRAY
5377: ST_TO_ADDR
// uc_side := 2 ;
5378: LD_ADDR_OWVAR 20
5382: PUSH
5383: LD_INT 2
5385: ST_TO_ADDR
// uc_nation := 2 ;
5386: LD_ADDR_OWVAR 21
5390: PUSH
5391: LD_INT 2
5393: ST_TO_ADDR
// for i = 1 to ( arabian_force / 2 ) do
5394: LD_ADDR_VAR 0 2
5398: PUSH
5399: DOUBLE
5400: LD_INT 1
5402: DEC
5403: ST_TO_ADDR
5404: LD_EXP 20
5408: PUSH
5409: LD_INT 2
5411: DIVREAL
5412: PUSH
5413: FOR_TO
5414: IFFALSE 5519
// begin vc_chassis := ar_half_tracked ;
5416: LD_ADDR_OWVAR 37
5420: PUSH
5421: LD_INT 14
5423: ST_TO_ADDR
// vc_engine := engine_siberite ;
5424: LD_ADDR_OWVAR 39
5428: PUSH
5429: LD_INT 3
5431: ST_TO_ADDR
// vc_control := control_manual ;
5432: LD_ADDR_OWVAR 38
5436: PUSH
5437: LD_INT 1
5439: ST_TO_ADDR
// vc_weapon := ar_weapons [ Rand ( 1 , ar_weapons - 2 ) ] ;
5440: LD_ADDR_OWVAR 40
5444: PUSH
5445: LD_EXP 17
5449: PUSH
5450: LD_INT 1
5452: PPUSH
5453: LD_EXP 17
5457: PUSH
5458: LD_INT 2
5460: MINUS
5461: PPUSH
5462: CALL_OW 12
5466: ARRAY
5467: ST_TO_ADDR
// un := CreateVehicle ;
5468: LD_ADDR_VAR 0 4
5472: PUSH
5473: CALL_OW 45
5477: ST_TO_ADDR
// PlaceUnitArea ( un , area , false ) ;
5478: LD_VAR 0 4
5482: PPUSH
5483: LD_VAR 0 6
5487: PPUSH
5488: LD_INT 0
5490: PPUSH
5491: CALL_OW 49
// PlaceHumanInUnit ( CreateHumanWithClass ( 3 , skill ) , un ) ;
5495: LD_INT 3
5497: PPUSH
5498: LD_EXP 16
5502: PPUSH
5503: CALL 7312 0 2
5507: PPUSH
5508: LD_VAR 0 4
5512: PPUSH
5513: CALL_OW 52
// end ;
5517: GO 5413
5519: POP
5520: POP
// for i = 1 to ( arabian_force / 2 ) do
5521: LD_ADDR_VAR 0 2
5525: PUSH
5526: DOUBLE
5527: LD_INT 1
5529: DEC
5530: ST_TO_ADDR
5531: LD_EXP 20
5535: PUSH
5536: LD_INT 2
5538: DIVREAL
5539: PUSH
5540: FOR_TO
5541: IFFALSE 5620
// begin vc_chassis := ar_half_tracked ;
5543: LD_ADDR_OWVAR 37
5547: PUSH
5548: LD_INT 14
5550: ST_TO_ADDR
// vc_engine := engine_siberite ;
5551: LD_ADDR_OWVAR 39
5555: PUSH
5556: LD_INT 3
5558: ST_TO_ADDR
// vc_control := control_apeman ;
5559: LD_ADDR_OWVAR 38
5563: PUSH
5564: LD_INT 5
5566: ST_TO_ADDR
// vc_weapon := ar_weapons [ Rand ( 2 , ar_weapons ) ] ;
5567: LD_ADDR_OWVAR 40
5571: PUSH
5572: LD_EXP 17
5576: PUSH
5577: LD_INT 2
5579: PPUSH
5580: LD_EXP 17
5584: PPUSH
5585: CALL_OW 12
5589: ARRAY
5590: ST_TO_ADDR
// un := CreateVehicle ;
5591: LD_ADDR_VAR 0 4
5595: PUSH
5596: CALL_OW 45
5600: ST_TO_ADDR
// PlaceUnitArea ( un , area , false ) ;
5601: LD_VAR 0 4
5605: PPUSH
5606: LD_VAR 0 6
5610: PPUSH
5611: LD_INT 0
5613: PPUSH
5614: CALL_OW 49
// end ;
5618: GO 5540
5620: POP
5621: POP
// end ; 41 :
5622: GO 6705
5624: LD_INT 41
5626: DOUBLE
5627: EQUAL
5628: IFTRUE 5632
5630: GO 5776
5632: POP
// begin area := areas [ Rand ( 1 , areas ) ] ;
5633: LD_ADDR_VAR 0 6
5637: PUSH
5638: LD_EXP 15
5642: PUSH
5643: LD_INT 1
5645: PPUSH
5646: LD_EXP 15
5650: PPUSH
5651: CALL_OW 12
5655: ARRAY
5656: ST_TO_ADDR
// uc_side := 1 ;
5657: LD_ADDR_OWVAR 20
5661: PUSH
5662: LD_INT 1
5664: ST_TO_ADDR
// uc_nation := 1 ;
5665: LD_ADDR_OWVAR 21
5669: PUSH
5670: LD_INT 1
5672: ST_TO_ADDR
// for i = 1 to american_force do
5673: LD_ADDR_VAR 0 2
5677: PUSH
5678: DOUBLE
5679: LD_INT 1
5681: DEC
5682: ST_TO_ADDR
5683: LD_EXP 22
5687: PUSH
5688: FOR_TO
5689: IFFALSE 5772
// begin vc_chassis := us_morphling ;
5691: LD_ADDR_OWVAR 37
5695: PUSH
5696: LD_INT 5
5698: ST_TO_ADDR
// vc_engine := engine_siberite ;
5699: LD_ADDR_OWVAR 39
5703: PUSH
5704: LD_INT 3
5706: ST_TO_ADDR
// vc_control := control_computer ;
5707: LD_ADDR_OWVAR 38
5711: PUSH
5712: LD_INT 3
5714: ST_TO_ADDR
// vc_weapon := us_weapons [ Rand ( 1 , us_weapons - 1 ) ] ;
5715: LD_ADDR_OWVAR 40
5719: PUSH
5720: LD_EXP 19
5724: PUSH
5725: LD_INT 1
5727: PPUSH
5728: LD_EXP 19
5732: PUSH
5733: LD_INT 1
5735: MINUS
5736: PPUSH
5737: CALL_OW 12
5741: ARRAY
5742: ST_TO_ADDR
// un := CreateVehicle ;
5743: LD_ADDR_VAR 0 4
5747: PUSH
5748: CALL_OW 45
5752: ST_TO_ADDR
// PlaceUnitArea ( un , area , false ) ;
5753: LD_VAR 0 4
5757: PPUSH
5758: LD_VAR 0 6
5762: PPUSH
5763: LD_INT 0
5765: PPUSH
5766: CALL_OW 49
// end ;
5770: GO 5688
5772: POP
5773: POP
// end ; 42 :
5774: GO 6705
5776: LD_INT 42
5778: DOUBLE
5779: EQUAL
5780: IFTRUE 5784
5782: GO 5924
5784: POP
// begin area := areas [ Rand ( 1 , areas ) ] ;
5785: LD_ADDR_VAR 0 6
5789: PUSH
5790: LD_EXP 15
5794: PUSH
5795: LD_INT 1
5797: PPUSH
5798: LD_EXP 15
5802: PPUSH
5803: CALL_OW 12
5807: ARRAY
5808: ST_TO_ADDR
// uc_side := 1 ;
5809: LD_ADDR_OWVAR 20
5813: PUSH
5814: LD_INT 1
5816: ST_TO_ADDR
// uc_nation := 1 ;
5817: LD_ADDR_OWVAR 21
5821: PUSH
5822: LD_INT 1
5824: ST_TO_ADDR
// for i = 1 to american_force do
5825: LD_ADDR_VAR 0 2
5829: PUSH
5830: DOUBLE
5831: LD_INT 1
5833: DEC
5834: ST_TO_ADDR
5835: LD_EXP 22
5839: PUSH
5840: FOR_TO
5841: IFFALSE 5920
// begin vc_chassis := us_morphling ;
5843: LD_ADDR_OWVAR 37
5847: PUSH
5848: LD_INT 5
5850: ST_TO_ADDR
// vc_engine := engine_siberite ;
5851: LD_ADDR_OWVAR 39
5855: PUSH
5856: LD_INT 3
5858: ST_TO_ADDR
// vc_control := control_computer ;
5859: LD_ADDR_OWVAR 38
5863: PUSH
5864: LD_INT 3
5866: ST_TO_ADDR
// vc_weapon := us_weapons [ Rand ( 1 , us_weapons ) ] ;
5867: LD_ADDR_OWVAR 40
5871: PUSH
5872: LD_EXP 19
5876: PUSH
5877: LD_INT 1
5879: PPUSH
5880: LD_EXP 19
5884: PPUSH
5885: CALL_OW 12
5889: ARRAY
5890: ST_TO_ADDR
// un := CreateVehicle ;
5891: LD_ADDR_VAR 0 4
5895: PUSH
5896: CALL_OW 45
5900: ST_TO_ADDR
// PlaceUnitArea ( un , area , false ) ;
5901: LD_VAR 0 4
5905: PPUSH
5906: LD_VAR 0 6
5910: PPUSH
5911: LD_INT 0
5913: PPUSH
5914: CALL_OW 49
// end ;
5918: GO 5840
5920: POP
5921: POP
// end ; 51 :
5922: GO 6705
5924: LD_INT 51
5926: DOUBLE
5927: EQUAL
5928: IFTRUE 5932
5930: GO 6072
5932: POP
// begin area := areas [ Rand ( 1 , areas ) ] ;
5933: LD_ADDR_VAR 0 6
5937: PUSH
5938: LD_EXP 15
5942: PUSH
5943: LD_INT 1
5945: PPUSH
5946: LD_EXP 15
5950: PPUSH
5951: CALL_OW 12
5955: ARRAY
5956: ST_TO_ADDR
// uc_side := 3 ;
5957: LD_ADDR_OWVAR 20
5961: PUSH
5962: LD_INT 3
5964: ST_TO_ADDR
// uc_nation := 3 ;
5965: LD_ADDR_OWVAR 21
5969: PUSH
5970: LD_INT 3
5972: ST_TO_ADDR
// for i = 1 to russian_force do
5973: LD_ADDR_VAR 0 2
5977: PUSH
5978: DOUBLE
5979: LD_INT 1
5981: DEC
5982: ST_TO_ADDR
5983: LD_EXP 21
5987: PUSH
5988: FOR_TO
5989: IFFALSE 6068
// begin vc_chassis := ru_heavy_tracked ;
5991: LD_ADDR_OWVAR 37
5995: PUSH
5996: LD_INT 24
5998: ST_TO_ADDR
// vc_engine := engine_siberite ;
5999: LD_ADDR_OWVAR 39
6003: PUSH
6004: LD_INT 3
6006: ST_TO_ADDR
// vc_control := control_computer ;
6007: LD_ADDR_OWVAR 38
6011: PUSH
6012: LD_INT 3
6014: ST_TO_ADDR
// vc_weapon := ru_weapons [ Rand ( 1 , ru_weapons ) ] ;
6015: LD_ADDR_OWVAR 40
6019: PUSH
6020: LD_EXP 18
6024: PUSH
6025: LD_INT 1
6027: PPUSH
6028: LD_EXP 18
6032: PPUSH
6033: CALL_OW 12
6037: ARRAY
6038: ST_TO_ADDR
// un := CreateVehicle ;
6039: LD_ADDR_VAR 0 4
6043: PUSH
6044: CALL_OW 45
6048: ST_TO_ADDR
// PlaceUnitArea ( un , area , false ) ;
6049: LD_VAR 0 4
6053: PPUSH
6054: LD_VAR 0 6
6058: PPUSH
6059: LD_INT 0
6061: PPUSH
6062: CALL_OW 49
// end ;
6066: GO 5988
6068: POP
6069: POP
// end ; 91 :
6070: GO 6705
6072: LD_INT 91
6074: DOUBLE
6075: EQUAL
6076: IFTRUE 6080
6078: GO 6218
6080: POP
// begin uc_side := 8 ;
6081: LD_ADDR_OWVAR 20
6085: PUSH
6086: LD_INT 8
6088: ST_TO_ADDR
// uc_nation := 1 ;
6089: LD_ADDR_OWVAR 21
6093: PUSH
6094: LD_INT 1
6096: ST_TO_ADDR
// for i = 1 to [ 5 , 4 , 3 ] [ game_difficulty ] do
6097: LD_ADDR_VAR 0 2
6101: PUSH
6102: DOUBLE
6103: LD_INT 1
6105: DEC
6106: ST_TO_ADDR
6107: LD_INT 5
6109: PUSH
6110: LD_INT 4
6112: PUSH
6113: LD_INT 3
6115: PUSH
6116: EMPTY
6117: LIST
6118: LIST
6119: LIST
6120: PUSH
6121: LD_EXP 2
6125: ARRAY
6126: PUSH
6127: FOR_TO
6128: IFFALSE 6214
// begin vc_chassis := us_heavy_tracked ;
6130: LD_ADDR_OWVAR 37
6134: PUSH
6135: LD_INT 4
6137: ST_TO_ADDR
// vc_engine := engine_siberite ;
6138: LD_ADDR_OWVAR 39
6142: PUSH
6143: LD_INT 3
6145: ST_TO_ADDR
// vc_control := control_computer ;
6146: LD_ADDR_OWVAR 38
6150: PUSH
6151: LD_INT 3
6153: ST_TO_ADDR
// vc_weapon := [ us_double_gun , us_heavy_gun ] [ Rand ( 1 , 2 ) ] ;
6154: LD_ADDR_OWVAR 40
6158: PUSH
6159: LD_INT 5
6161: PUSH
6162: LD_INT 6
6164: PUSH
6165: EMPTY
6166: LIST
6167: LIST
6168: PUSH
6169: LD_INT 1
6171: PPUSH
6172: LD_INT 2
6174: PPUSH
6175: CALL_OW 12
6179: ARRAY
6180: ST_TO_ADDR
// un := CreateVehicle ;
6181: LD_ADDR_VAR 0 4
6185: PUSH
6186: CALL_OW 45
6190: ST_TO_ADDR
// PlaceUnitArea ( un , areas [ 1 ] , false ) ;
6191: LD_VAR 0 4
6195: PPUSH
6196: LD_EXP 15
6200: PUSH
6201: LD_INT 1
6203: ARRAY
6204: PPUSH
6205: LD_INT 0
6207: PPUSH
6208: CALL_OW 49
// end ;
6212: GO 6127
6214: POP
6215: POP
// end ; 92 :
6216: GO 6705
6218: LD_INT 92
6220: DOUBLE
6221: EQUAL
6222: IFTRUE 6226
6224: GO 6555
6226: POP
// begin uc_side := 5 ;
6227: LD_ADDR_OWVAR 20
6231: PUSH
6232: LD_INT 5
6234: ST_TO_ADDR
// uc_nation := 2 ;
6235: LD_ADDR_OWVAR 21
6239: PUSH
6240: LD_INT 2
6242: ST_TO_ADDR
// filter := [ ] ;
6243: LD_ADDR_VAR 0 3
6247: PUSH
6248: EMPTY
6249: ST_TO_ADDR
// InitHc ;
6250: CALL_OW 19
// PrepareHuman ( false , 1 , l_skill ) ;
6254: LD_INT 0
6256: PPUSH
6257: LD_INT 1
6259: PPUSH
6260: LD_EXP 50
6264: PPUSH
6265: CALL_OW 380
// un := CreateHuman ;
6269: LD_ADDR_VAR 0 4
6273: PUSH
6274: CALL_OW 44
6278: ST_TO_ADDR
// filter := filter ^ un ;
6279: LD_ADDR_VAR 0 3
6283: PUSH
6284: LD_VAR 0 3
6288: PUSH
6289: LD_VAR 0 4
6293: ADD
6294: ST_TO_ADDR
// for i = 1 to [ 4 , 3 , 2 ] [ game_difficulty ] do
6295: LD_ADDR_VAR 0 2
6299: PUSH
6300: DOUBLE
6301: LD_INT 1
6303: DEC
6304: ST_TO_ADDR
6305: LD_INT 4
6307: PUSH
6308: LD_INT 3
6310: PUSH
6311: LD_INT 2
6313: PUSH
6314: EMPTY
6315: LIST
6316: LIST
6317: LIST
6318: PUSH
6319: LD_EXP 2
6323: ARRAY
6324: PUSH
6325: FOR_TO
6326: IFFALSE 6364
// begin un := CreateHumanWithClass ( 1 , l_skill ) ;
6328: LD_ADDR_VAR 0 4
6332: PUSH
6333: LD_INT 1
6335: PPUSH
6336: LD_EXP 50
6340: PPUSH
6341: CALL 7312 0 2
6345: ST_TO_ADDR
// filter := filter ^ un ;
6346: LD_ADDR_VAR 0 3
6350: PUSH
6351: LD_VAR 0 3
6355: PUSH
6356: LD_VAR 0 4
6360: ADD
6361: ST_TO_ADDR
// end ;
6362: GO 6325
6364: POP
6365: POP
// DialogueOn ;
6366: CALL_OW 6
// if GetSex ( filter [ 1 ] ) = sex_male then
6370: LD_VAR 0 3
6374: PUSH
6375: LD_INT 1
6377: ARRAY
6378: PPUSH
6379: CALL_OW 258
6383: PUSH
6384: LD_INT 1
6386: EQUAL
6387: IFFALSE 6407
// SayRadio ( filter [ 1 ] , DS-DF-1 ) else
6389: LD_VAR 0 3
6393: PUSH
6394: LD_INT 1
6396: ARRAY
6397: PPUSH
6398: LD_STRING DS-DF-1
6400: PPUSH
6401: CALL_OW 94
6405: GO 6423
// SayRadio ( filter [ 1 ] , DS-DF-f1 ) ;
6407: LD_VAR 0 3
6411: PUSH
6412: LD_INT 1
6414: ARRAY
6415: PPUSH
6416: LD_STRING DS-DF-f1
6418: PPUSH
6419: CALL_OW 94
// case Query ( DS-dezert ) of 1 :
6423: LD_STRING DS-dezert
6425: PPUSH
6426: CALL_OW 97
6430: PUSH
6431: LD_INT 1
6433: DOUBLE
6434: EQUAL
6435: IFTRUE 6439
6437: GO 6454
6439: POP
// Say ( l_cmndr , DS-DC-dis ) ; 2 :
6440: LD_EXP 49
6444: PPUSH
6445: LD_STRING DS-DC-dis
6447: PPUSH
6448: CALL_OW 88
6452: GO 6549
6454: LD_INT 2
6456: DOUBLE
6457: EQUAL
6458: IFTRUE 6462
6460: GO 6548
6462: POP
// begin Say ( l_cmndr , DS-DC-acp ) ;
6463: LD_EXP 49
6467: PPUSH
6468: LD_STRING DS-DC-acp
6470: PPUSH
6471: CALL_OW 88
// for i = 1 to filter do
6475: LD_ADDR_VAR 0 2
6479: PUSH
6480: DOUBLE
6481: LD_INT 1
6483: DEC
6484: ST_TO_ADDR
6485: LD_VAR 0 3
6489: PUSH
6490: FOR_TO
6491: IFFALSE 6544
// begin SetSide ( filter [ i ] , 8 ) ;
6493: LD_VAR 0 3
6497: PUSH
6498: LD_VAR 0 2
6502: ARRAY
6503: PPUSH
6504: LD_INT 8
6506: PPUSH
6507: CALL_OW 235
// PlaceUnitArea ( filter [ i ] , south_spawn , false ) ;
6511: LD_VAR 0 3
6515: PUSH
6516: LD_VAR 0 2
6520: ARRAY
6521: PPUSH
6522: LD_INT 4
6524: PPUSH
6525: LD_INT 0
6527: PPUSH
6528: CALL_OW 49
// CenterNowOnXY ( 111 , 121 ) ;
6532: LD_INT 111
6534: PPUSH
6535: LD_INT 121
6537: PPUSH
6538: CALL_OW 86
// end ;
6542: GO 6490
6544: POP
6545: POP
// end ; end ;
6546: GO 6549
6548: POP
// DialogueOff ;
6549: CALL_OW 7
// end ; 101 :
6553: GO 6705
6555: LD_INT 101
6557: DOUBLE
6558: EQUAL
6559: IFTRUE 6563
6561: GO 6615
6563: POP
// begin CreateCratesArea ( Rand ( 3 , 5 ) , crates_area , true ) ;
6564: LD_INT 3
6566: PPUSH
6567: LD_INT 5
6569: PPUSH
6570: CALL_OW 12
6574: PPUSH
6575: LD_INT 9
6577: PPUSH
6578: LD_INT 1
6580: PPUSH
6581: CALL_OW 55
// Wait ( 0 0$11 ) ;
6585: LD_INT 385
6587: PPUSH
6588: CALL_OW 67
// CreateCratesArea ( Rand ( 3 , 5 ) , crates_area , true ) ;
6592: LD_INT 3
6594: PPUSH
6595: LD_INT 5
6597: PPUSH
6598: CALL_OW 12
6602: PPUSH
6603: LD_INT 9
6605: PPUSH
6606: LD_INT 1
6608: PPUSH
6609: CALL_OW 55
// end ; 200 :
6613: GO 6705
6615: LD_INT 200
6617: DOUBLE
6618: EQUAL
6619: IFTRUE 6623
6621: GO 6704
6623: POP
// begin Say ( Leopold , DS-end ) ;
6624: LD_EXP 7
6628: PPUSH
6629: LD_STRING DS-end
6631: PPUSH
6632: CALL_OW 88
// if Difficulty = 3 then
6636: LD_OWVAR 67
6640: PUSH
6641: LD_INT 3
6643: EQUAL
6644: IFFALSE 6653
// SetAchievement ( ACH_DESERT ) ;
6646: LD_STRING ACH_DESERT
6648: PPUSH
6649: CALL_OW 543
// music_nat := 5 ;
6653: LD_ADDR_OWVAR 71
6657: PUSH
6658: LD_INT 5
6660: ST_TO_ADDR
// AddMedal ( dsmed1 , 1 ) ;
6661: LD_STRING dsmed1
6663: PPUSH
6664: LD_INT 1
6666: PPUSH
6667: CALL_OW 101
// AddMedal ( dsmed1 , 1 ) ;
6671: LD_STRING dsmed1
6673: PPUSH
6674: LD_INT 1
6676: PPUSH
6677: CALL_OW 101
// AddMedal ( dsmed1 , 1 ) ;
6681: LD_STRING dsmed1
6683: PPUSH
6684: LD_INT 1
6686: PPUSH
6687: CALL_OW 101
// GiveMedals ( MAIN ) ;
6691: LD_STRING MAIN
6693: PPUSH
6694: CALL_OW 102
// YouWin ;
6698: CALL_OW 103
// end ; end ;
6702: GO 6705
6704: POP
// end ;
6705: PPOPN 6
6707: END
// on UnitGoesToRed ( un ) do begin if un in FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] ] ) then
6708: LD_VAR 0 1
6712: PUSH
6713: LD_INT 22
6715: PUSH
6716: LD_INT 2
6718: PUSH
6719: EMPTY
6720: LIST
6721: LIST
6722: PUSH
6723: LD_INT 21
6725: PUSH
6726: LD_INT 2
6728: PUSH
6729: EMPTY
6730: LIST
6731: LIST
6732: PUSH
6733: EMPTY
6734: LIST
6735: LIST
6736: PPUSH
6737: CALL_OW 69
6741: IN
6742: IFFALSE 6867
// begin Wait ( Rand ( 0 0$03 , 0 0$06 ) ) ;
6744: LD_INT 105
6746: PPUSH
6747: LD_INT 210
6749: PPUSH
6750: CALL_OW 12
6754: PPUSH
6755: CALL_OW 67
// MineExplosion ( GetX ( un ) , GetY ( un ) , 3 ) ;
6759: LD_VAR 0 1
6763: PPUSH
6764: CALL_OW 250
6768: PPUSH
6769: LD_VAR 0 1
6773: PPUSH
6774: CALL_OW 251
6778: PPUSH
6779: LD_INT 3
6781: PPUSH
6782: CALL_OW 453
// MineExplosion ( GetX ( un ) , GetY ( un ) , 3 ) ;
6786: LD_VAR 0 1
6790: PPUSH
6791: CALL_OW 250
6795: PPUSH
6796: LD_VAR 0 1
6800: PPUSH
6801: CALL_OW 251
6805: PPUSH
6806: LD_INT 3
6808: PPUSH
6809: CALL_OW 453
// MineExplosion ( GetX ( un ) , GetY ( un ) , 3 ) ;
6813: LD_VAR 0 1
6817: PPUSH
6818: CALL_OW 250
6822: PPUSH
6823: LD_VAR 0 1
6827: PPUSH
6828: CALL_OW 251
6832: PPUSH
6833: LD_INT 3
6835: PPUSH
6836: CALL_OW 453
// MineExplosion ( GetX ( un ) , GetY ( un ) , 3 ) ;
6840: LD_VAR 0 1
6844: PPUSH
6845: CALL_OW 250
6849: PPUSH
6850: LD_VAR 0 1
6854: PPUSH
6855: CALL_OW 251
6859: PPUSH
6860: LD_INT 3
6862: PPUSH
6863: CALL_OW 453
// end ; end ;
6867: PPOPN 1
6869: END
// on UnitDestroyed ( un ) do begin SOS_UnitDestroyed ( un ) ;
6870: LD_VAR 0 1
6874: PPUSH
6875: CALL 19488 0 1
// if un = fort then
6879: LD_VAR 0 1
6883: PUSH
6884: LD_INT 23
6886: EQUAL
6887: IFFALSE 6897
// fort_destroyed := true ;
6889: LD_ADDR_EXP 32
6893: PUSH
6894: LD_INT 1
6896: ST_TO_ADDR
// if un = l_cmndr then
6897: LD_VAR 0 1
6901: PUSH
6902: LD_EXP 49
6906: EQUAL
6907: IFFALSE 6917
// hero_died := true ;
6909: LD_ADDR_EXP 33
6913: PUSH
6914: LD_INT 1
6916: ST_TO_ADDR
// end ;
6917: PPOPN 1
6919: END
// on UnitDestroyed_Extra ( un , killerSide , killerUnit ) do begin debug_strings := un ;
6920: LD_ADDR_OWVAR 48
6924: PUSH
6925: LD_VAR 0 1
6929: ST_TO_ADDR
// SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ;
6930: LD_VAR 0 1
6934: PPUSH
6935: LD_VAR 0 2
6939: PPUSH
6940: LD_VAR 0 3
6944: PPUSH
6945: CALL 19586 0 3
// end ;
6949: PPOPN 3
6951: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
6952: LD_VAR 0 1
6956: PPUSH
6957: CALL 19594 0 1
// end ; end_of_file
6961: PPOPN 1
6963: END
// export function RefreshTime ( time , bool ) ; begin
6964: LD_INT 0
6966: PPUSH
// if bool then
6967: LD_VAR 0 2
6971: IFFALSE 6989
// time := time + 0 0$01 else
6973: LD_ADDR_VAR 0 1
6977: PUSH
6978: LD_VAR 0 1
6982: PUSH
6983: LD_INT 35
6985: PLUS
6986: ST_TO_ADDR
6987: GO 7003
// time := time - 0 0$01 ;
6989: LD_ADDR_VAR 0 1
6993: PUSH
6994: LD_VAR 0 1
6998: PUSH
6999: LD_INT 35
7001: MINUS
7002: ST_TO_ADDR
// result := time ;
7003: LD_ADDR_VAR 0 3
7007: PUSH
7008: LD_VAR 0 1
7012: ST_TO_ADDR
// end ;
7013: LD_VAR 0 3
7017: RET
// export function MineExist ( side ) ; begin
7018: LD_INT 0
7020: PPUSH
// if FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_siberite_mine ] ] ) > 0 then
7021: LD_INT 22
7023: PUSH
7024: LD_VAR 0 1
7028: PUSH
7029: EMPTY
7030: LIST
7031: LIST
7032: PUSH
7033: LD_INT 30
7035: PUSH
7036: LD_INT 30
7038: PUSH
7039: EMPTY
7040: LIST
7041: LIST
7042: PUSH
7043: EMPTY
7044: LIST
7045: LIST
7046: PPUSH
7047: CALL_OW 69
7051: PUSH
7052: LD_INT 0
7054: GREATER
7055: IFFALSE 7067
// result := true else
7057: LD_ADDR_VAR 0 2
7061: PUSH
7062: LD_INT 1
7064: ST_TO_ADDR
7065: GO 7075
// result := false ;
7067: LD_ADDR_VAR 0 2
7071: PUSH
7072: LD_INT 0
7074: ST_TO_ADDR
// end ;
7075: LD_VAR 0 2
7079: RET
// export function FacExist ( side ) ; begin
7080: LD_INT 0
7082: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_factory ] ] ) > 0 ;
7083: LD_ADDR_VAR 0 2
7087: PUSH
7088: LD_INT 22
7090: PUSH
7091: LD_VAR 0 1
7095: PUSH
7096: EMPTY
7097: LIST
7098: LIST
7099: PUSH
7100: LD_INT 30
7102: PUSH
7103: LD_INT 3
7105: PUSH
7106: EMPTY
7107: LIST
7108: LIST
7109: PUSH
7110: EMPTY
7111: LIST
7112: LIST
7113: PPUSH
7114: CALL_OW 69
7118: PUSH
7119: LD_INT 0
7121: GREATER
7122: ST_TO_ADDR
// end ;
7123: LD_VAR 0 2
7127: RET
// export function ConnectWithTower ( side ) ; var i , filter , tower ; begin
7128: LD_INT 0
7130: PPUSH
7131: PPUSH
7132: PPUSH
7133: PPUSH
// filter := FilterAllUnits ( [ [ f_side , side ] , [ f_control , control_remote ] , [ f_ok ] ] ) ;
7134: LD_ADDR_VAR 0 4
7138: PUSH
7139: LD_INT 22
7141: PUSH
7142: LD_VAR 0 1
7146: PUSH
7147: EMPTY
7148: LIST
7149: LIST
7150: PUSH
7151: LD_INT 33
7153: PUSH
7154: LD_INT 2
7156: PUSH
7157: EMPTY
7158: LIST
7159: LIST
7160: PUSH
7161: LD_INT 50
7163: PUSH
7164: EMPTY
7165: LIST
7166: PUSH
7167: EMPTY
7168: LIST
7169: LIST
7170: LIST
7171: PPUSH
7172: CALL_OW 69
7176: ST_TO_ADDR
// tower := FilterAllUnits ( [ [ f_side , side ] , [ f_weapon , ar_control_tower ] ] ) ;
7177: LD_ADDR_VAR 0 5
7181: PUSH
7182: LD_INT 22
7184: PUSH
7185: LD_VAR 0 1
7189: PUSH
7190: EMPTY
7191: LIST
7192: LIST
7193: PUSH
7194: LD_INT 34
7196: PUSH
7197: LD_INT 31
7199: PUSH
7200: EMPTY
7201: LIST
7202: LIST
7203: PUSH
7204: EMPTY
7205: LIST
7206: LIST
7207: PPUSH
7208: CALL_OW 69
7212: ST_TO_ADDR
// if tower > 0 and filter > 0 then
7213: LD_VAR 0 5
7217: PUSH
7218: LD_INT 0
7220: GREATER
7221: PUSH
7222: LD_VAR 0 4
7226: PUSH
7227: LD_INT 0
7229: GREATER
7230: AND
7231: IFFALSE 7307
// for i = 1 to filter do
7233: LD_ADDR_VAR 0 3
7237: PUSH
7238: DOUBLE
7239: LD_INT 1
7241: DEC
7242: ST_TO_ADDR
7243: LD_VAR 0 4
7247: PUSH
7248: FOR_TO
7249: IFFALSE 7305
// if not IsControledBy ( filter [ i ] ) then
7251: LD_VAR 0 4
7255: PUSH
7256: LD_VAR 0 3
7260: ARRAY
7261: PPUSH
7262: CALL_OW 312
7266: NOT
7267: IFFALSE 7303
// ComLinkTo ( filter [ i ] , tower [ Rand ( 1 , tower ) ] ) ;
7269: LD_VAR 0 4
7273: PUSH
7274: LD_VAR 0 3
7278: ARRAY
7279: PPUSH
7280: LD_VAR 0 5
7284: PUSH
7285: LD_INT 1
7287: PPUSH
7288: LD_VAR 0 5
7292: PPUSH
7293: CALL_OW 12
7297: ARRAY
7298: PPUSH
7299: CALL_OW 135
7303: GO 7248
7305: POP
7306: POP
// end ;
7307: LD_VAR 0 2
7311: RET
// export function CreateHumanWithClass ( clas , lvl ) ; var skill_com , skill_eng , skill_mech , skill_sci , bonus ; begin
7312: LD_INT 0
7314: PPUSH
7315: PPUSH
7316: PPUSH
7317: PPUSH
7318: PPUSH
7319: PPUSH
// hc_class := clas ;
7320: LD_ADDR_OWVAR 28
7324: PUSH
7325: LD_VAR 0 1
7329: ST_TO_ADDR
// skill_com := ( lvl + Rand ( - 1 , 1 ) ) ;
7330: LD_ADDR_VAR 0 4
7334: PUSH
7335: LD_VAR 0 2
7339: PUSH
7340: LD_INT 1
7342: NEG
7343: PPUSH
7344: LD_INT 1
7346: PPUSH
7347: CALL_OW 12
7351: PLUS
7352: ST_TO_ADDR
// skill_eng := ( lvl + Rand ( - 1 , 1 ) ) ;
7353: LD_ADDR_VAR 0 5
7357: PUSH
7358: LD_VAR 0 2
7362: PUSH
7363: LD_INT 1
7365: NEG
7366: PPUSH
7367: LD_INT 1
7369: PPUSH
7370: CALL_OW 12
7374: PLUS
7375: ST_TO_ADDR
// skill_mech := ( lvl + Rand ( - 1 , 1 ) ) ;
7376: LD_ADDR_VAR 0 6
7380: PUSH
7381: LD_VAR 0 2
7385: PUSH
7386: LD_INT 1
7388: NEG
7389: PPUSH
7390: LD_INT 1
7392: PPUSH
7393: CALL_OW 12
7397: PLUS
7398: ST_TO_ADDR
// skill_sci := ( lvl + Rand ( - 1 , 1 ) ) ;
7399: LD_ADDR_VAR 0 7
7403: PUSH
7404: LD_VAR 0 2
7408: PUSH
7409: LD_INT 1
7411: NEG
7412: PPUSH
7413: LD_INT 1
7415: PPUSH
7416: CALL_OW 12
7420: PLUS
7421: ST_TO_ADDR
// if clas = 1 or clas = 9 or clas = class_sniper or clas = class_mortar then
7422: LD_VAR 0 1
7426: PUSH
7427: LD_INT 1
7429: EQUAL
7430: PUSH
7431: LD_VAR 0 1
7435: PUSH
7436: LD_INT 9
7438: EQUAL
7439: OR
7440: PUSH
7441: LD_VAR 0 1
7445: PUSH
7446: LD_INT 5
7448: EQUAL
7449: OR
7450: PUSH
7451: LD_VAR 0 1
7455: PUSH
7456: LD_INT 8
7458: EQUAL
7459: OR
7460: IFFALSE 7485
// bonus := [ 2 , 0 , 0 , 0 ] ;
7462: LD_ADDR_VAR 0 8
7466: PUSH
7467: LD_INT 2
7469: PUSH
7470: LD_INT 0
7472: PUSH
7473: LD_INT 0
7475: PUSH
7476: LD_INT 0
7478: PUSH
7479: EMPTY
7480: LIST
7481: LIST
7482: LIST
7483: LIST
7484: ST_TO_ADDR
// if clas = 2 then
7485: LD_VAR 0 1
7489: PUSH
7490: LD_INT 2
7492: EQUAL
7493: IFFALSE 7518
// bonus := [ 0 , 2 , 0 , 0 ] ;
7495: LD_ADDR_VAR 0 8
7499: PUSH
7500: LD_INT 0
7502: PUSH
7503: LD_INT 2
7505: PUSH
7506: LD_INT 0
7508: PUSH
7509: LD_INT 0
7511: PUSH
7512: EMPTY
7513: LIST
7514: LIST
7515: LIST
7516: LIST
7517: ST_TO_ADDR
// if clas = 3 then
7518: LD_VAR 0 1
7522: PUSH
7523: LD_INT 3
7525: EQUAL
7526: IFFALSE 7551
// bonus := [ 0 , 0 , 2 , 0 ] ;
7528: LD_ADDR_VAR 0 8
7532: PUSH
7533: LD_INT 0
7535: PUSH
7536: LD_INT 0
7538: PUSH
7539: LD_INT 2
7541: PUSH
7542: LD_INT 0
7544: PUSH
7545: EMPTY
7546: LIST
7547: LIST
7548: LIST
7549: LIST
7550: ST_TO_ADDR
// if clas = 4 then
7551: LD_VAR 0 1
7555: PUSH
7556: LD_INT 4
7558: EQUAL
7559: IFFALSE 7584
// bonus := [ 0 , 0 , 0 , 2 ] ;
7561: LD_ADDR_VAR 0 8
7565: PUSH
7566: LD_INT 0
7568: PUSH
7569: LD_INT 0
7571: PUSH
7572: LD_INT 0
7574: PUSH
7575: LD_INT 2
7577: PUSH
7578: EMPTY
7579: LIST
7580: LIST
7581: LIST
7582: LIST
7583: ST_TO_ADDR
// if clas > 4 and clas <> 9 and clas <> class_sniper and clas <> class_mortar then
7584: LD_VAR 0 1
7588: PUSH
7589: LD_INT 4
7591: GREATER
7592: PUSH
7593: LD_VAR 0 1
7597: PUSH
7598: LD_INT 9
7600: NONEQUAL
7601: AND
7602: PUSH
7603: LD_VAR 0 1
7607: PUSH
7608: LD_INT 5
7610: NONEQUAL
7611: AND
7612: PUSH
7613: LD_VAR 0 1
7617: PUSH
7618: LD_INT 8
7620: NONEQUAL
7621: AND
7622: IFFALSE 7647
// bonus := [ 0 , 0 , 0 , 0 ] ;
7624: LD_ADDR_VAR 0 8
7628: PUSH
7629: LD_INT 0
7631: PUSH
7632: LD_INT 0
7634: PUSH
7635: LD_INT 0
7637: PUSH
7638: LD_INT 0
7640: PUSH
7641: EMPTY
7642: LIST
7643: LIST
7644: LIST
7645: LIST
7646: ST_TO_ADDR
// hc_basic_skills := [ Rand ( 0 , 2 ) , Rand ( 0 , 2 ) , Rand ( 0 , 2 ) , Rand ( 0 , 2 ) ] ;
7647: LD_ADDR_OWVAR 30
7651: PUSH
7652: LD_INT 0
7654: PPUSH
7655: LD_INT 2
7657: PPUSH
7658: CALL_OW 12
7662: PUSH
7663: LD_INT 0
7665: PPUSH
7666: LD_INT 2
7668: PPUSH
7669: CALL_OW 12
7673: PUSH
7674: LD_INT 0
7676: PPUSH
7677: LD_INT 2
7679: PPUSH
7680: CALL_OW 12
7684: PUSH
7685: LD_INT 0
7687: PPUSH
7688: LD_INT 2
7690: PPUSH
7691: CALL_OW 12
7695: PUSH
7696: EMPTY
7697: LIST
7698: LIST
7699: LIST
7700: LIST
7701: ST_TO_ADDR
// hc_skills := [ skill_com + bonus [ 1 ] , skill_eng + bonus [ 2 ] , skill_mech + bonus [ 3 ] , skill_sci + bonus [ 4 ] ] ;
7702: LD_ADDR_OWVAR 31
7706: PUSH
7707: LD_VAR 0 4
7711: PUSH
7712: LD_VAR 0 8
7716: PUSH
7717: LD_INT 1
7719: ARRAY
7720: PLUS
7721: PUSH
7722: LD_VAR 0 5
7726: PUSH
7727: LD_VAR 0 8
7731: PUSH
7732: LD_INT 2
7734: ARRAY
7735: PLUS
7736: PUSH
7737: LD_VAR 0 6
7741: PUSH
7742: LD_VAR 0 8
7746: PUSH
7747: LD_INT 3
7749: ARRAY
7750: PLUS
7751: PUSH
7752: LD_VAR 0 7
7756: PUSH
7757: LD_VAR 0 8
7761: PUSH
7762: LD_INT 4
7764: ARRAY
7765: PLUS
7766: PUSH
7767: EMPTY
7768: LIST
7769: LIST
7770: LIST
7771: LIST
7772: ST_TO_ADDR
// hc_sex := Rand ( sex_male , sex_female ) ;
7773: LD_ADDR_OWVAR 27
7777: PUSH
7778: LD_INT 1
7780: PPUSH
7781: LD_INT 2
7783: PPUSH
7784: CALL_OW 12
7788: ST_TO_ADDR
// hc_gallery :=  ;
7789: LD_ADDR_OWVAR 33
7793: PUSH
7794: LD_STRING 
7796: ST_TO_ADDR
// hc_attr := [ Rand ( 8 , 12 ) , Rand ( 9 , 11 ) ] ;
7797: LD_ADDR_OWVAR 29
7801: PUSH
7802: LD_INT 8
7804: PPUSH
7805: LD_INT 12
7807: PPUSH
7808: CALL_OW 12
7812: PUSH
7813: LD_INT 9
7815: PPUSH
7816: LD_INT 11
7818: PPUSH
7819: CALL_OW 12
7823: PUSH
7824: EMPTY
7825: LIST
7826: LIST
7827: ST_TO_ADDR
// hc_name :=  ;
7828: LD_ADDR_OWVAR 26
7832: PUSH
7833: LD_STRING 
7835: ST_TO_ADDR
// result := CreateHuman ;
7836: LD_ADDR_VAR 0 3
7840: PUSH
7841: CALL_OW 44
7845: ST_TO_ADDR
// end ;
7846: LD_VAR 0 3
7850: RET
// export function GetSpeed ( unit ) ; begin
7851: LD_INT 0
7853: PPUSH
// result := GetProperties ( unit ) [ 1 ] ;
7854: LD_ADDR_VAR 0 2
7858: PUSH
7859: LD_VAR 0 1
7863: PPUSH
7864: CALL_OW 464
7868: PUSH
7869: LD_INT 1
7871: ARRAY
7872: ST_TO_ADDR
// end ;
7873: LD_VAR 0 2
7877: RET
// export function PrepareNature ( area , num1 , num2 , num3 , num4 ) ; var l , apeman , tiger , bird , horse ; begin
7878: LD_INT 0
7880: PPUSH
7881: PPUSH
7882: PPUSH
7883: PPUSH
7884: PPUSH
7885: PPUSH
// uc_nation = nation_nature ;
7886: LD_ADDR_OWVAR 21
7890: PUSH
7891: LD_INT 0
7893: ST_TO_ADDR
// uc_side = 0 ;
7894: LD_ADDR_OWVAR 20
7898: PUSH
7899: LD_INT 0
7901: ST_TO_ADDR
// l = 0 ;
7902: LD_ADDR_VAR 0 7
7906: PUSH
7907: LD_INT 0
7909: ST_TO_ADDR
// repeat begin uc_direction = Rand ( 0 , 5 ) ;
7910: LD_ADDR_OWVAR 24
7914: PUSH
7915: LD_INT 0
7917: PPUSH
7918: LD_INT 5
7920: PPUSH
7921: CALL_OW 12
7925: ST_TO_ADDR
// hc_agressivity = Rand ( - 5 , 0 ) ;
7926: LD_ADDR_OWVAR 35
7930: PUSH
7931: LD_INT 5
7933: NEG
7934: PPUSH
7935: LD_INT 0
7937: PPUSH
7938: CALL_OW 12
7942: ST_TO_ADDR
// hc_gallery =  ;
7943: LD_ADDR_OWVAR 33
7947: PUSH
7948: LD_STRING 
7950: ST_TO_ADDR
// hc_class = class_apeman ;
7951: LD_ADDR_OWVAR 28
7955: PUSH
7956: LD_INT 12
7958: ST_TO_ADDR
// hc_attr = [ Rand ( 11 , 13 ) , Rand ( 10 , 11 ) ] ;
7959: LD_ADDR_OWVAR 29
7963: PUSH
7964: LD_INT 11
7966: PPUSH
7967: LD_INT 13
7969: PPUSH
7970: CALL_OW 12
7974: PUSH
7975: LD_INT 10
7977: PPUSH
7978: LD_INT 11
7980: PPUSH
7981: CALL_OW 12
7985: PUSH
7986: EMPTY
7987: LIST
7988: LIST
7989: ST_TO_ADDR
// hc_sex = sex_male ;
7990: LD_ADDR_OWVAR 27
7994: PUSH
7995: LD_INT 1
7997: ST_TO_ADDR
// hc_skills = [ Rand ( 0 , 2 ) , 0 , 0 , 0 ] ;
7998: LD_ADDR_OWVAR 31
8002: PUSH
8003: LD_INT 0
8005: PPUSH
8006: LD_INT 2
8008: PPUSH
8009: CALL_OW 12
8013: PUSH
8014: LD_INT 0
8016: PUSH
8017: LD_INT 0
8019: PUSH
8020: LD_INT 0
8022: PUSH
8023: EMPTY
8024: LIST
8025: LIST
8026: LIST
8027: LIST
8028: ST_TO_ADDR
// apeman = CreateHuman ;
8029: LD_ADDR_VAR 0 8
8033: PUSH
8034: CALL_OW 44
8038: ST_TO_ADDR
// PlaceUnitArea ( apeman , area , false ) ;
8039: LD_VAR 0 8
8043: PPUSH
8044: LD_VAR 0 1
8048: PPUSH
8049: LD_INT 0
8051: PPUSH
8052: CALL_OW 49
// l = l + 1 ;
8056: LD_ADDR_VAR 0 7
8060: PUSH
8061: LD_VAR 0 7
8065: PUSH
8066: LD_INT 1
8068: PLUS
8069: ST_TO_ADDR
// end until l = num1 ;
8070: LD_VAR 0 7
8074: PUSH
8075: LD_VAR 0 2
8079: EQUAL
8080: IFFALSE 7910
// l = 0 ;
8082: LD_ADDR_VAR 0 7
8086: PUSH
8087: LD_INT 0
8089: ST_TO_ADDR
// repeat begin hc_agressivity = Rand ( 0 , 25 ) ;
8090: LD_ADDR_OWVAR 35
8094: PUSH
8095: LD_INT 0
8097: PPUSH
8098: LD_INT 25
8100: PPUSH
8101: CALL_OW 12
8105: ST_TO_ADDR
// hc_class = class_tiger ;
8106: LD_ADDR_OWVAR 28
8110: PUSH
8111: LD_INT 14
8113: ST_TO_ADDR
// hc_sex = sex_male ;
8114: LD_ADDR_OWVAR 27
8118: PUSH
8119: LD_INT 1
8121: ST_TO_ADDR
// hc_gallery = sandnature ;
8122: LD_ADDR_OWVAR 33
8126: PUSH
8127: LD_STRING sandnature
8129: ST_TO_ADDR
// hc_face_number = 3 ;
8130: LD_ADDR_OWVAR 34
8134: PUSH
8135: LD_INT 3
8137: ST_TO_ADDR
// tiger = CreateHuman ;
8138: LD_ADDR_VAR 0 9
8142: PUSH
8143: CALL_OW 44
8147: ST_TO_ADDR
// PlaceUnitArea ( tiger , area , false ) ;
8148: LD_VAR 0 9
8152: PPUSH
8153: LD_VAR 0 1
8157: PPUSH
8158: LD_INT 0
8160: PPUSH
8161: CALL_OW 49
// l = l + 1 ;
8165: LD_ADDR_VAR 0 7
8169: PUSH
8170: LD_VAR 0 7
8174: PUSH
8175: LD_INT 1
8177: PLUS
8178: ST_TO_ADDR
// end until l = num2 ;
8179: LD_VAR 0 7
8183: PUSH
8184: LD_VAR 0 3
8188: EQUAL
8189: IFFALSE 8090
// l = 0 ;
8191: LD_ADDR_VAR 0 7
8195: PUSH
8196: LD_INT 0
8198: ST_TO_ADDR
// repeat begin hc_class = class_phororhacos ;
8199: LD_ADDR_OWVAR 28
8203: PUSH
8204: LD_INT 18
8206: ST_TO_ADDR
// hc_gallery = sandnature ;
8207: LD_ADDR_OWVAR 33
8211: PUSH
8212: LD_STRING sandnature
8214: ST_TO_ADDR
// hc_face_number = 1 ;
8215: LD_ADDR_OWVAR 34
8219: PUSH
8220: LD_INT 1
8222: ST_TO_ADDR
// bird = CreateHuman ;
8223: LD_ADDR_VAR 0 10
8227: PUSH
8228: CALL_OW 44
8232: ST_TO_ADDR
// PlaceUnitAnywhere ( bird , false ) ;
8233: LD_VAR 0 10
8237: PPUSH
8238: LD_INT 0
8240: PPUSH
8241: CALL_OW 51
// l = l + 1 ;
8245: LD_ADDR_VAR 0 7
8249: PUSH
8250: LD_VAR 0 7
8254: PUSH
8255: LD_INT 1
8257: PLUS
8258: ST_TO_ADDR
// end until l = num3 ;
8259: LD_VAR 0 7
8263: PUSH
8264: LD_VAR 0 4
8268: EQUAL
8269: IFFALSE 8199
// l = 0 ;
8271: LD_ADDR_VAR 0 7
8275: PUSH
8276: LD_INT 0
8278: ST_TO_ADDR
// repeat begin hc_class = 21 ;
8279: LD_ADDR_OWVAR 28
8283: PUSH
8284: LD_INT 21
8286: ST_TO_ADDR
// hc_gallery = sandnature ;
8287: LD_ADDR_OWVAR 33
8291: PUSH
8292: LD_STRING sandnature
8294: ST_TO_ADDR
// hc_face_number = 5 ;
8295: LD_ADDR_OWVAR 34
8299: PUSH
8300: LD_INT 5
8302: ST_TO_ADDR
// horse := CreateHuman ;
8303: LD_ADDR_VAR 0 11
8307: PUSH
8308: CALL_OW 44
8312: ST_TO_ADDR
// PlaceUnitArea ( horse , area , false ) ;
8313: LD_VAR 0 11
8317: PPUSH
8318: LD_VAR 0 1
8322: PPUSH
8323: LD_INT 0
8325: PPUSH
8326: CALL_OW 49
// l = l + 1 ;
8330: LD_ADDR_VAR 0 7
8334: PUSH
8335: LD_VAR 0 7
8339: PUSH
8340: LD_INT 1
8342: PLUS
8343: ST_TO_ADDR
// end until l = num4 ;
8344: LD_VAR 0 7
8348: PUSH
8349: LD_VAR 0 5
8353: EQUAL
8354: IFFALSE 8279
// end ;
8356: LD_VAR 0 6
8360: RET
// export function PrepareComm ; begin
8361: LD_INT 0
8363: PPUSH
// uc_side := 1 ;
8364: LD_ADDR_OWVAR 20
8368: PUSH
8369: LD_INT 1
8371: ST_TO_ADDR
// uc_nation := 1 ;
8372: LD_ADDR_OWVAR 21
8376: PUSH
8377: LD_INT 1
8379: ST_TO_ADDR
// hc_gallery :=  ;
8380: LD_ADDR_OWVAR 33
8384: PUSH
8385: LD_STRING 
8387: ST_TO_ADDR
// hc_name :=  ;
8388: LD_ADDR_OWVAR 26
8392: PUSH
8393: LD_STRING 
8395: ST_TO_ADDR
// hc_class := 1 ;
8396: LD_ADDR_OWVAR 28
8400: PUSH
8401: LD_INT 1
8403: ST_TO_ADDR
// hc_sex := sex_male ;
8404: LD_ADDR_OWVAR 27
8408: PUSH
8409: LD_INT 1
8411: ST_TO_ADDR
// am_comander := CreateHuman ;
8412: LD_ADDR_EXP 46
8416: PUSH
8417: CALL_OW 44
8421: ST_TO_ADDR
// uc_side := 3 ;
8422: LD_ADDR_OWVAR 20
8426: PUSH
8427: LD_INT 3
8429: ST_TO_ADDR
// uc_nation := 3 ;
8430: LD_ADDR_OWVAR 21
8434: PUSH
8435: LD_INT 3
8437: ST_TO_ADDR
// ru_comander := CreateHuman ;
8438: LD_ADDR_EXP 47
8442: PUSH
8443: CALL_OW 44
8447: ST_TO_ADDR
// uc_side := 2 ;
8448: LD_ADDR_OWVAR 20
8452: PUSH
8453: LD_INT 2
8455: ST_TO_ADDR
// uc_nation := 2 ;
8456: LD_ADDR_OWVAR 21
8460: PUSH
8461: LD_INT 2
8463: ST_TO_ADDR
// hc_name := Heike Steyer ;
8464: LD_ADDR_OWVAR 26
8468: PUSH
8469: LD_STRING Heike Steyer
8471: ST_TO_ADDR
// hc_sex := sex_female ;
8472: LD_ADDR_OWVAR 27
8476: PUSH
8477: LD_INT 2
8479: ST_TO_ADDR
// hc_gallery := sandar ;
8480: LD_ADDR_OWVAR 33
8484: PUSH
8485: LD_STRING sandar
8487: ST_TO_ADDR
// hc_face_number := 14 ;
8488: LD_ADDR_OWVAR 34
8492: PUSH
8493: LD_INT 14
8495: ST_TO_ADDR
// ar_comander := CreateHuman ;
8496: LD_ADDR_EXP 48
8500: PUSH
8501: CALL_OW 44
8505: ST_TO_ADDR
// end ;
8506: LD_VAR 0 1
8510: RET
// export function SpeedFilter ( filter , speed ) ; var list , i ; begin
8511: LD_INT 0
8513: PPUSH
8514: PPUSH
8515: PPUSH
// list := [ ] ;
8516: LD_ADDR_VAR 0 4
8520: PUSH
8521: EMPTY
8522: ST_TO_ADDR
// for i = 1 to filter do
8523: LD_ADDR_VAR 0 5
8527: PUSH
8528: DOUBLE
8529: LD_INT 1
8531: DEC
8532: ST_TO_ADDR
8533: LD_VAR 0 1
8537: PUSH
8538: FOR_TO
8539: IFFALSE 8588
// if GetSpeed ( filter [ i ] ) < speed then
8541: LD_VAR 0 1
8545: PUSH
8546: LD_VAR 0 5
8550: ARRAY
8551: PPUSH
8552: CALL 7851 0 1
8556: PUSH
8557: LD_VAR 0 2
8561: LESS
8562: IFFALSE 8586
// list := list ^ filter [ i ] ;
8564: LD_ADDR_VAR 0 4
8568: PUSH
8569: LD_VAR 0 4
8573: PUSH
8574: LD_VAR 0 1
8578: PUSH
8579: LD_VAR 0 5
8583: ARRAY
8584: ADD
8585: ST_TO_ADDR
8586: GO 8538
8588: POP
8589: POP
// result := list ;
8590: LD_ADDR_VAR 0 3
8594: PUSH
8595: LD_VAR 0 4
8599: ST_TO_ADDR
// end ; end_of_file
8600: LD_VAR 0 3
8604: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; every 1 do
8605: GO 8607
8607: DISABLE
// begin ru_radar := 98 ;
8608: LD_ADDR_EXP 52
8612: PUSH
8613: LD_INT 98
8615: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
8616: LD_ADDR_EXP 53
8620: PUSH
8621: LD_INT 89
8623: ST_TO_ADDR
// us_hack := 99 ;
8624: LD_ADDR_EXP 54
8628: PUSH
8629: LD_INT 99
8631: ST_TO_ADDR
// us_artillery := 97 ;
8632: LD_ADDR_EXP 55
8636: PUSH
8637: LD_INT 97
8639: ST_TO_ADDR
// ar_bio_bomb := 91 ;
8640: LD_ADDR_EXP 56
8644: PUSH
8645: LD_INT 91
8647: ST_TO_ADDR
// end ; end_of_file end_of_file
8648: END
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger ; every 0 0$1 do
8649: GO 8651
8651: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
8652: LD_STRING initStreamRollete();
8654: PPUSH
8655: CALL_OW 559
// InitStreamMode ;
8659: CALL 8668 0 0
// DefineStreamItems ( ) ;
8663: CALL 9108 0 0
// end ;
8667: END
// function InitStreamMode ; begin
8668: LD_INT 0
8670: PPUSH
// streamModeActive := false ;
8671: LD_ADDR_EXP 57
8675: PUSH
8676: LD_INT 0
8678: ST_TO_ADDR
// normalCounter := 36 ;
8679: LD_ADDR_EXP 58
8683: PUSH
8684: LD_INT 36
8686: ST_TO_ADDR
// hardcoreCounter := 16 ;
8687: LD_ADDR_EXP 59
8691: PUSH
8692: LD_INT 16
8694: ST_TO_ADDR
// sRocket := false ;
8695: LD_ADDR_EXP 62
8699: PUSH
8700: LD_INT 0
8702: ST_TO_ADDR
// sSpeed := false ;
8703: LD_ADDR_EXP 61
8707: PUSH
8708: LD_INT 0
8710: ST_TO_ADDR
// sEngine := false ;
8711: LD_ADDR_EXP 63
8715: PUSH
8716: LD_INT 0
8718: ST_TO_ADDR
// sSpec := false ;
8719: LD_ADDR_EXP 60
8723: PUSH
8724: LD_INT 0
8726: ST_TO_ADDR
// sLevel := false ;
8727: LD_ADDR_EXP 64
8731: PUSH
8732: LD_INT 0
8734: ST_TO_ADDR
// sArmoury := false ;
8735: LD_ADDR_EXP 65
8739: PUSH
8740: LD_INT 0
8742: ST_TO_ADDR
// sRadar := false ;
8743: LD_ADDR_EXP 66
8747: PUSH
8748: LD_INT 0
8750: ST_TO_ADDR
// sBunker := false ;
8751: LD_ADDR_EXP 67
8755: PUSH
8756: LD_INT 0
8758: ST_TO_ADDR
// sHack := false ;
8759: LD_ADDR_EXP 68
8763: PUSH
8764: LD_INT 0
8766: ST_TO_ADDR
// sFire := false ;
8767: LD_ADDR_EXP 69
8771: PUSH
8772: LD_INT 0
8774: ST_TO_ADDR
// sRefresh := false ;
8775: LD_ADDR_EXP 70
8779: PUSH
8780: LD_INT 0
8782: ST_TO_ADDR
// sExp := false ;
8783: LD_ADDR_EXP 71
8787: PUSH
8788: LD_INT 0
8790: ST_TO_ADDR
// sDepot := false ;
8791: LD_ADDR_EXP 72
8795: PUSH
8796: LD_INT 0
8798: ST_TO_ADDR
// sFlag := false ;
8799: LD_ADDR_EXP 73
8803: PUSH
8804: LD_INT 0
8806: ST_TO_ADDR
// sKamikadze := false ;
8807: LD_ADDR_EXP 81
8811: PUSH
8812: LD_INT 0
8814: ST_TO_ADDR
// sTroll := false ;
8815: LD_ADDR_EXP 82
8819: PUSH
8820: LD_INT 0
8822: ST_TO_ADDR
// sSlow := false ;
8823: LD_ADDR_EXP 83
8827: PUSH
8828: LD_INT 0
8830: ST_TO_ADDR
// sLack := false ;
8831: LD_ADDR_EXP 84
8835: PUSH
8836: LD_INT 0
8838: ST_TO_ADDR
// sTank := false ;
8839: LD_ADDR_EXP 86
8843: PUSH
8844: LD_INT 0
8846: ST_TO_ADDR
// sRemote := false ;
8847: LD_ADDR_EXP 87
8851: PUSH
8852: LD_INT 0
8854: ST_TO_ADDR
// sPowell := false ;
8855: LD_ADDR_EXP 88
8859: PUSH
8860: LD_INT 0
8862: ST_TO_ADDR
// sTeleport := false ;
8863: LD_ADDR_EXP 91
8867: PUSH
8868: LD_INT 0
8870: ST_TO_ADDR
// sOilTower := false ;
8871: LD_ADDR_EXP 93
8875: PUSH
8876: LD_INT 0
8878: ST_TO_ADDR
// sShovel := false ;
8879: LD_ADDR_EXP 94
8883: PUSH
8884: LD_INT 0
8886: ST_TO_ADDR
// sSheik := false ;
8887: LD_ADDR_EXP 95
8891: PUSH
8892: LD_INT 0
8894: ST_TO_ADDR
// sEarthquake := false ;
8895: LD_ADDR_EXP 97
8899: PUSH
8900: LD_INT 0
8902: ST_TO_ADDR
// sAI := false ;
8903: LD_ADDR_EXP 98
8907: PUSH
8908: LD_INT 0
8910: ST_TO_ADDR
// sCargo := false ;
8911: LD_ADDR_EXP 101
8915: PUSH
8916: LD_INT 0
8918: ST_TO_ADDR
// sDLaser := false ;
8919: LD_ADDR_EXP 102
8923: PUSH
8924: LD_INT 0
8926: ST_TO_ADDR
// sExchange := false ;
8927: LD_ADDR_EXP 103
8931: PUSH
8932: LD_INT 0
8934: ST_TO_ADDR
// sFac := false ;
8935: LD_ADDR_EXP 104
8939: PUSH
8940: LD_INT 0
8942: ST_TO_ADDR
// sPower := false ;
8943: LD_ADDR_EXP 105
8947: PUSH
8948: LD_INT 0
8950: ST_TO_ADDR
// sRandom := false ;
8951: LD_ADDR_EXP 106
8955: PUSH
8956: LD_INT 0
8958: ST_TO_ADDR
// sShield := false ;
8959: LD_ADDR_EXP 107
8963: PUSH
8964: LD_INT 0
8966: ST_TO_ADDR
// sTime := false ;
8967: LD_ADDR_EXP 108
8971: PUSH
8972: LD_INT 0
8974: ST_TO_ADDR
// sTools := false ;
8975: LD_ADDR_EXP 109
8979: PUSH
8980: LD_INT 0
8982: ST_TO_ADDR
// sSold := false ;
8983: LD_ADDR_EXP 74
8987: PUSH
8988: LD_INT 0
8990: ST_TO_ADDR
// sDiff := false ;
8991: LD_ADDR_EXP 75
8995: PUSH
8996: LD_INT 0
8998: ST_TO_ADDR
// sFog := false ;
8999: LD_ADDR_EXP 78
9003: PUSH
9004: LD_INT 0
9006: ST_TO_ADDR
// sReset := false ;
9007: LD_ADDR_EXP 79
9011: PUSH
9012: LD_INT 0
9014: ST_TO_ADDR
// sSun := false ;
9015: LD_ADDR_EXP 80
9019: PUSH
9020: LD_INT 0
9022: ST_TO_ADDR
// sTiger := false ;
9023: LD_ADDR_EXP 76
9027: PUSH
9028: LD_INT 0
9030: ST_TO_ADDR
// sBomb := false ;
9031: LD_ADDR_EXP 77
9035: PUSH
9036: LD_INT 0
9038: ST_TO_ADDR
// sWound := false ;
9039: LD_ADDR_EXP 85
9043: PUSH
9044: LD_INT 0
9046: ST_TO_ADDR
// sBetray := false ;
9047: LD_ADDR_EXP 89
9051: PUSH
9052: LD_INT 0
9054: ST_TO_ADDR
// sContamin := false ;
9055: LD_ADDR_EXP 90
9059: PUSH
9060: LD_INT 0
9062: ST_TO_ADDR
// sOil := false ;
9063: LD_ADDR_EXP 92
9067: PUSH
9068: LD_INT 0
9070: ST_TO_ADDR
// sStu := false ;
9071: LD_ADDR_EXP 96
9075: PUSH
9076: LD_INT 0
9078: ST_TO_ADDR
// sBazooka := false ;
9079: LD_ADDR_EXP 99
9083: PUSH
9084: LD_INT 0
9086: ST_TO_ADDR
// sMortar := false ;
9087: LD_ADDR_EXP 100
9091: PUSH
9092: LD_INT 0
9094: ST_TO_ADDR
// sRanger := false ;
9095: LD_ADDR_EXP 110
9099: PUSH
9100: LD_INT 0
9102: ST_TO_ADDR
// end ;
9103: LD_VAR 0 1
9107: RET
// function DefineStreamItems ( ) ; var tmp , normal , hardcore , i ; begin
9108: LD_INT 0
9110: PPUSH
9111: PPUSH
9112: PPUSH
9113: PPUSH
9114: PPUSH
// result := [ ] ;
9115: LD_ADDR_VAR 0 1
9119: PUSH
9120: EMPTY
9121: ST_TO_ADDR
// if campaign_id = 1 then
9122: LD_OWVAR 69
9126: PUSH
9127: LD_INT 1
9129: EQUAL
9130: IFFALSE 12068
// begin case mission_number of 1 :
9132: LD_OWVAR 70
9136: PUSH
9137: LD_INT 1
9139: DOUBLE
9140: EQUAL
9141: IFTRUE 9145
9143: GO 9209
9145: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 ] ] ; 2 :
9146: LD_ADDR_VAR 0 1
9150: PUSH
9151: LD_INT 2
9153: PUSH
9154: LD_INT 4
9156: PUSH
9157: LD_INT 11
9159: PUSH
9160: LD_INT 12
9162: PUSH
9163: LD_INT 15
9165: PUSH
9166: LD_INT 16
9168: PUSH
9169: LD_INT 22
9171: PUSH
9172: LD_INT 23
9174: PUSH
9175: LD_INT 26
9177: PUSH
9178: EMPTY
9179: LIST
9180: LIST
9181: LIST
9182: LIST
9183: LIST
9184: LIST
9185: LIST
9186: LIST
9187: LIST
9188: PUSH
9189: LD_INT 101
9191: PUSH
9192: LD_INT 102
9194: PUSH
9195: LD_INT 106
9197: PUSH
9198: EMPTY
9199: LIST
9200: LIST
9201: LIST
9202: PUSH
9203: EMPTY
9204: LIST
9205: LIST
9206: ST_TO_ADDR
9207: GO 12066
9209: LD_INT 2
9211: DOUBLE
9212: EQUAL
9213: IFTRUE 9217
9215: GO 9289
9217: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 3 :
9218: LD_ADDR_VAR 0 1
9222: PUSH
9223: LD_INT 2
9225: PUSH
9226: LD_INT 4
9228: PUSH
9229: LD_INT 11
9231: PUSH
9232: LD_INT 12
9234: PUSH
9235: LD_INT 15
9237: PUSH
9238: LD_INT 16
9240: PUSH
9241: LD_INT 22
9243: PUSH
9244: LD_INT 23
9246: PUSH
9247: LD_INT 26
9249: PUSH
9250: EMPTY
9251: LIST
9252: LIST
9253: LIST
9254: LIST
9255: LIST
9256: LIST
9257: LIST
9258: LIST
9259: LIST
9260: PUSH
9261: LD_INT 101
9263: PUSH
9264: LD_INT 102
9266: PUSH
9267: LD_INT 105
9269: PUSH
9270: LD_INT 106
9272: PUSH
9273: LD_INT 108
9275: PUSH
9276: EMPTY
9277: LIST
9278: LIST
9279: LIST
9280: LIST
9281: LIST
9282: PUSH
9283: EMPTY
9284: LIST
9285: LIST
9286: ST_TO_ADDR
9287: GO 12066
9289: LD_INT 3
9291: DOUBLE
9292: EQUAL
9293: IFTRUE 9297
9295: GO 9373
9297: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 4 :
9298: LD_ADDR_VAR 0 1
9302: PUSH
9303: LD_INT 2
9305: PUSH
9306: LD_INT 4
9308: PUSH
9309: LD_INT 5
9311: PUSH
9312: LD_INT 11
9314: PUSH
9315: LD_INT 12
9317: PUSH
9318: LD_INT 15
9320: PUSH
9321: LD_INT 16
9323: PUSH
9324: LD_INT 22
9326: PUSH
9327: LD_INT 26
9329: PUSH
9330: LD_INT 36
9332: PUSH
9333: EMPTY
9334: LIST
9335: LIST
9336: LIST
9337: LIST
9338: LIST
9339: LIST
9340: LIST
9341: LIST
9342: LIST
9343: LIST
9344: PUSH
9345: LD_INT 101
9347: PUSH
9348: LD_INT 102
9350: PUSH
9351: LD_INT 105
9353: PUSH
9354: LD_INT 106
9356: PUSH
9357: LD_INT 108
9359: PUSH
9360: EMPTY
9361: LIST
9362: LIST
9363: LIST
9364: LIST
9365: LIST
9366: PUSH
9367: EMPTY
9368: LIST
9369: LIST
9370: ST_TO_ADDR
9371: GO 12066
9373: LD_INT 4
9375: DOUBLE
9376: EQUAL
9377: IFTRUE 9381
9379: GO 9465
9381: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 5 :
9382: LD_ADDR_VAR 0 1
9386: PUSH
9387: LD_INT 2
9389: PUSH
9390: LD_INT 4
9392: PUSH
9393: LD_INT 5
9395: PUSH
9396: LD_INT 8
9398: PUSH
9399: LD_INT 11
9401: PUSH
9402: LD_INT 12
9404: PUSH
9405: LD_INT 15
9407: PUSH
9408: LD_INT 16
9410: PUSH
9411: LD_INT 22
9413: PUSH
9414: LD_INT 23
9416: PUSH
9417: LD_INT 26
9419: PUSH
9420: LD_INT 36
9422: PUSH
9423: EMPTY
9424: LIST
9425: LIST
9426: LIST
9427: LIST
9428: LIST
9429: LIST
9430: LIST
9431: LIST
9432: LIST
9433: LIST
9434: LIST
9435: LIST
9436: PUSH
9437: LD_INT 101
9439: PUSH
9440: LD_INT 102
9442: PUSH
9443: LD_INT 105
9445: PUSH
9446: LD_INT 106
9448: PUSH
9449: LD_INT 108
9451: PUSH
9452: EMPTY
9453: LIST
9454: LIST
9455: LIST
9456: LIST
9457: LIST
9458: PUSH
9459: EMPTY
9460: LIST
9461: LIST
9462: ST_TO_ADDR
9463: GO 12066
9465: LD_INT 5
9467: DOUBLE
9468: EQUAL
9469: IFTRUE 9473
9471: GO 9573
9473: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 6 :
9474: LD_ADDR_VAR 0 1
9478: PUSH
9479: LD_INT 2
9481: PUSH
9482: LD_INT 4
9484: PUSH
9485: LD_INT 5
9487: PUSH
9488: LD_INT 6
9490: PUSH
9491: LD_INT 8
9493: PUSH
9494: LD_INT 11
9496: PUSH
9497: LD_INT 12
9499: PUSH
9500: LD_INT 15
9502: PUSH
9503: LD_INT 16
9505: PUSH
9506: LD_INT 22
9508: PUSH
9509: LD_INT 23
9511: PUSH
9512: LD_INT 25
9514: PUSH
9515: LD_INT 26
9517: PUSH
9518: LD_INT 36
9520: PUSH
9521: EMPTY
9522: LIST
9523: LIST
9524: LIST
9525: LIST
9526: LIST
9527: LIST
9528: LIST
9529: LIST
9530: LIST
9531: LIST
9532: LIST
9533: LIST
9534: LIST
9535: LIST
9536: PUSH
9537: LD_INT 101
9539: PUSH
9540: LD_INT 102
9542: PUSH
9543: LD_INT 105
9545: PUSH
9546: LD_INT 106
9548: PUSH
9549: LD_INT 108
9551: PUSH
9552: LD_INT 109
9554: PUSH
9555: LD_INT 112
9557: PUSH
9558: EMPTY
9559: LIST
9560: LIST
9561: LIST
9562: LIST
9563: LIST
9564: LIST
9565: LIST
9566: PUSH
9567: EMPTY
9568: LIST
9569: LIST
9570: ST_TO_ADDR
9571: GO 12066
9573: LD_INT 6
9575: DOUBLE
9576: EQUAL
9577: IFTRUE 9581
9579: GO 9701
9581: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 7 :
9582: LD_ADDR_VAR 0 1
9586: PUSH
9587: LD_INT 2
9589: PUSH
9590: LD_INT 4
9592: PUSH
9593: LD_INT 5
9595: PUSH
9596: LD_INT 6
9598: PUSH
9599: LD_INT 8
9601: PUSH
9602: LD_INT 11
9604: PUSH
9605: LD_INT 12
9607: PUSH
9608: LD_INT 15
9610: PUSH
9611: LD_INT 16
9613: PUSH
9614: LD_INT 20
9616: PUSH
9617: LD_INT 21
9619: PUSH
9620: LD_INT 22
9622: PUSH
9623: LD_INT 23
9625: PUSH
9626: LD_INT 25
9628: PUSH
9629: LD_INT 26
9631: PUSH
9632: LD_INT 30
9634: PUSH
9635: LD_INT 31
9637: PUSH
9638: LD_INT 32
9640: PUSH
9641: LD_INT 36
9643: PUSH
9644: EMPTY
9645: LIST
9646: LIST
9647: LIST
9648: LIST
9649: LIST
9650: LIST
9651: LIST
9652: LIST
9653: LIST
9654: LIST
9655: LIST
9656: LIST
9657: LIST
9658: LIST
9659: LIST
9660: LIST
9661: LIST
9662: LIST
9663: LIST
9664: PUSH
9665: LD_INT 101
9667: PUSH
9668: LD_INT 102
9670: PUSH
9671: LD_INT 105
9673: PUSH
9674: LD_INT 106
9676: PUSH
9677: LD_INT 108
9679: PUSH
9680: LD_INT 109
9682: PUSH
9683: LD_INT 112
9685: PUSH
9686: EMPTY
9687: LIST
9688: LIST
9689: LIST
9690: LIST
9691: LIST
9692: LIST
9693: LIST
9694: PUSH
9695: EMPTY
9696: LIST
9697: LIST
9698: ST_TO_ADDR
9699: GO 12066
9701: LD_INT 7
9703: DOUBLE
9704: EQUAL
9705: IFTRUE 9709
9707: GO 9809
9709: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 ] ] ; 8 :
9710: LD_ADDR_VAR 0 1
9714: PUSH
9715: LD_INT 2
9717: PUSH
9718: LD_INT 4
9720: PUSH
9721: LD_INT 5
9723: PUSH
9724: LD_INT 7
9726: PUSH
9727: LD_INT 11
9729: PUSH
9730: LD_INT 12
9732: PUSH
9733: LD_INT 15
9735: PUSH
9736: LD_INT 16
9738: PUSH
9739: LD_INT 20
9741: PUSH
9742: LD_INT 21
9744: PUSH
9745: LD_INT 22
9747: PUSH
9748: LD_INT 23
9750: PUSH
9751: LD_INT 25
9753: PUSH
9754: LD_INT 26
9756: PUSH
9757: EMPTY
9758: LIST
9759: LIST
9760: LIST
9761: LIST
9762: LIST
9763: LIST
9764: LIST
9765: LIST
9766: LIST
9767: LIST
9768: LIST
9769: LIST
9770: LIST
9771: LIST
9772: PUSH
9773: LD_INT 101
9775: PUSH
9776: LD_INT 102
9778: PUSH
9779: LD_INT 103
9781: PUSH
9782: LD_INT 105
9784: PUSH
9785: LD_INT 106
9787: PUSH
9788: LD_INT 108
9790: PUSH
9791: LD_INT 112
9793: PUSH
9794: EMPTY
9795: LIST
9796: LIST
9797: LIST
9798: LIST
9799: LIST
9800: LIST
9801: LIST
9802: PUSH
9803: EMPTY
9804: LIST
9805: LIST
9806: ST_TO_ADDR
9807: GO 12066
9809: LD_INT 8
9811: DOUBLE
9812: EQUAL
9813: IFTRUE 9817
9815: GO 9945
9817: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 ] ] ; 9 :
9818: LD_ADDR_VAR 0 1
9822: PUSH
9823: LD_INT 2
9825: PUSH
9826: LD_INT 4
9828: PUSH
9829: LD_INT 5
9831: PUSH
9832: LD_INT 6
9834: PUSH
9835: LD_INT 7
9837: PUSH
9838: LD_INT 8
9840: PUSH
9841: LD_INT 11
9843: PUSH
9844: LD_INT 12
9846: PUSH
9847: LD_INT 15
9849: PUSH
9850: LD_INT 16
9852: PUSH
9853: LD_INT 20
9855: PUSH
9856: LD_INT 21
9858: PUSH
9859: LD_INT 22
9861: PUSH
9862: LD_INT 23
9864: PUSH
9865: LD_INT 25
9867: PUSH
9868: LD_INT 26
9870: PUSH
9871: LD_INT 30
9873: PUSH
9874: LD_INT 31
9876: PUSH
9877: LD_INT 32
9879: PUSH
9880: LD_INT 36
9882: PUSH
9883: EMPTY
9884: LIST
9885: LIST
9886: LIST
9887: LIST
9888: LIST
9889: LIST
9890: LIST
9891: LIST
9892: LIST
9893: LIST
9894: LIST
9895: LIST
9896: LIST
9897: LIST
9898: LIST
9899: LIST
9900: LIST
9901: LIST
9902: LIST
9903: LIST
9904: PUSH
9905: LD_INT 101
9907: PUSH
9908: LD_INT 102
9910: PUSH
9911: LD_INT 103
9913: PUSH
9914: LD_INT 105
9916: PUSH
9917: LD_INT 106
9919: PUSH
9920: LD_INT 108
9922: PUSH
9923: LD_INT 109
9925: PUSH
9926: LD_INT 112
9928: PUSH
9929: EMPTY
9930: LIST
9931: LIST
9932: LIST
9933: LIST
9934: LIST
9935: LIST
9936: LIST
9937: LIST
9938: PUSH
9939: EMPTY
9940: LIST
9941: LIST
9942: ST_TO_ADDR
9943: GO 12066
9945: LD_INT 9
9947: DOUBLE
9948: EQUAL
9949: IFTRUE 9953
9951: GO 10089
9953: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 ] ] ; 10 :
9954: LD_ADDR_VAR 0 1
9958: PUSH
9959: LD_INT 2
9961: PUSH
9962: LD_INT 4
9964: PUSH
9965: LD_INT 5
9967: PUSH
9968: LD_INT 6
9970: PUSH
9971: LD_INT 7
9973: PUSH
9974: LD_INT 8
9976: PUSH
9977: LD_INT 11
9979: PUSH
9980: LD_INT 12
9982: PUSH
9983: LD_INT 15
9985: PUSH
9986: LD_INT 16
9988: PUSH
9989: LD_INT 20
9991: PUSH
9992: LD_INT 21
9994: PUSH
9995: LD_INT 22
9997: PUSH
9998: LD_INT 23
10000: PUSH
10001: LD_INT 25
10003: PUSH
10004: LD_INT 26
10006: PUSH
10007: LD_INT 28
10009: PUSH
10010: LD_INT 30
10012: PUSH
10013: LD_INT 31
10015: PUSH
10016: LD_INT 32
10018: PUSH
10019: LD_INT 36
10021: PUSH
10022: EMPTY
10023: LIST
10024: LIST
10025: LIST
10026: LIST
10027: LIST
10028: LIST
10029: LIST
10030: LIST
10031: LIST
10032: LIST
10033: LIST
10034: LIST
10035: LIST
10036: LIST
10037: LIST
10038: LIST
10039: LIST
10040: LIST
10041: LIST
10042: LIST
10043: LIST
10044: PUSH
10045: LD_INT 101
10047: PUSH
10048: LD_INT 102
10050: PUSH
10051: LD_INT 103
10053: PUSH
10054: LD_INT 105
10056: PUSH
10057: LD_INT 106
10059: PUSH
10060: LD_INT 108
10062: PUSH
10063: LD_INT 109
10065: PUSH
10066: LD_INT 112
10068: PUSH
10069: LD_INT 114
10071: PUSH
10072: EMPTY
10073: LIST
10074: LIST
10075: LIST
10076: LIST
10077: LIST
10078: LIST
10079: LIST
10080: LIST
10081: LIST
10082: PUSH
10083: EMPTY
10084: LIST
10085: LIST
10086: ST_TO_ADDR
10087: GO 12066
10089: LD_INT 10
10091: DOUBLE
10092: EQUAL
10093: IFTRUE 10097
10095: GO 10281
10097: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 11 :
10098: LD_ADDR_VAR 0 1
10102: PUSH
10103: LD_INT 2
10105: PUSH
10106: LD_INT 4
10108: PUSH
10109: LD_INT 5
10111: PUSH
10112: LD_INT 6
10114: PUSH
10115: LD_INT 7
10117: PUSH
10118: LD_INT 8
10120: PUSH
10121: LD_INT 9
10123: PUSH
10124: LD_INT 10
10126: PUSH
10127: LD_INT 11
10129: PUSH
10130: LD_INT 12
10132: PUSH
10133: LD_INT 13
10135: PUSH
10136: LD_INT 14
10138: PUSH
10139: LD_INT 15
10141: PUSH
10142: LD_INT 16
10144: PUSH
10145: LD_INT 17
10147: PUSH
10148: LD_INT 18
10150: PUSH
10151: LD_INT 19
10153: PUSH
10154: LD_INT 20
10156: PUSH
10157: LD_INT 21
10159: PUSH
10160: LD_INT 22
10162: PUSH
10163: LD_INT 23
10165: PUSH
10166: LD_INT 24
10168: PUSH
10169: LD_INT 25
10171: PUSH
10172: LD_INT 26
10174: PUSH
10175: LD_INT 28
10177: PUSH
10178: LD_INT 30
10180: PUSH
10181: LD_INT 31
10183: PUSH
10184: LD_INT 32
10186: PUSH
10187: LD_INT 36
10189: PUSH
10190: EMPTY
10191: LIST
10192: LIST
10193: LIST
10194: LIST
10195: LIST
10196: LIST
10197: LIST
10198: LIST
10199: LIST
10200: LIST
10201: LIST
10202: LIST
10203: LIST
10204: LIST
10205: LIST
10206: LIST
10207: LIST
10208: LIST
10209: LIST
10210: LIST
10211: LIST
10212: LIST
10213: LIST
10214: LIST
10215: LIST
10216: LIST
10217: LIST
10218: LIST
10219: LIST
10220: PUSH
10221: LD_INT 101
10223: PUSH
10224: LD_INT 102
10226: PUSH
10227: LD_INT 103
10229: PUSH
10230: LD_INT 104
10232: PUSH
10233: LD_INT 105
10235: PUSH
10236: LD_INT 106
10238: PUSH
10239: LD_INT 107
10241: PUSH
10242: LD_INT 108
10244: PUSH
10245: LD_INT 109
10247: PUSH
10248: LD_INT 110
10250: PUSH
10251: LD_INT 111
10253: PUSH
10254: LD_INT 112
10256: PUSH
10257: LD_INT 114
10259: PUSH
10260: EMPTY
10261: LIST
10262: LIST
10263: LIST
10264: LIST
10265: LIST
10266: LIST
10267: LIST
10268: LIST
10269: LIST
10270: LIST
10271: LIST
10272: LIST
10273: LIST
10274: PUSH
10275: EMPTY
10276: LIST
10277: LIST
10278: ST_TO_ADDR
10279: GO 12066
10281: LD_INT 11
10283: DOUBLE
10284: EQUAL
10285: IFTRUE 10289
10287: GO 10481
10289: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 12 :
10290: LD_ADDR_VAR 0 1
10294: PUSH
10295: LD_INT 2
10297: PUSH
10298: LD_INT 3
10300: PUSH
10301: LD_INT 4
10303: PUSH
10304: LD_INT 5
10306: PUSH
10307: LD_INT 6
10309: PUSH
10310: LD_INT 7
10312: PUSH
10313: LD_INT 8
10315: PUSH
10316: LD_INT 9
10318: PUSH
10319: LD_INT 10
10321: PUSH
10322: LD_INT 11
10324: PUSH
10325: LD_INT 12
10327: PUSH
10328: LD_INT 13
10330: PUSH
10331: LD_INT 14
10333: PUSH
10334: LD_INT 15
10336: PUSH
10337: LD_INT 16
10339: PUSH
10340: LD_INT 17
10342: PUSH
10343: LD_INT 18
10345: PUSH
10346: LD_INT 19
10348: PUSH
10349: LD_INT 20
10351: PUSH
10352: LD_INT 21
10354: PUSH
10355: LD_INT 22
10357: PUSH
10358: LD_INT 23
10360: PUSH
10361: LD_INT 24
10363: PUSH
10364: LD_INT 25
10366: PUSH
10367: LD_INT 26
10369: PUSH
10370: LD_INT 28
10372: PUSH
10373: LD_INT 30
10375: PUSH
10376: LD_INT 31
10378: PUSH
10379: LD_INT 32
10381: PUSH
10382: LD_INT 34
10384: PUSH
10385: LD_INT 36
10387: PUSH
10388: EMPTY
10389: LIST
10390: LIST
10391: LIST
10392: LIST
10393: LIST
10394: LIST
10395: LIST
10396: LIST
10397: LIST
10398: LIST
10399: LIST
10400: LIST
10401: LIST
10402: LIST
10403: LIST
10404: LIST
10405: LIST
10406: LIST
10407: LIST
10408: LIST
10409: LIST
10410: LIST
10411: LIST
10412: LIST
10413: LIST
10414: LIST
10415: LIST
10416: LIST
10417: LIST
10418: LIST
10419: LIST
10420: PUSH
10421: LD_INT 101
10423: PUSH
10424: LD_INT 102
10426: PUSH
10427: LD_INT 103
10429: PUSH
10430: LD_INT 104
10432: PUSH
10433: LD_INT 105
10435: PUSH
10436: LD_INT 106
10438: PUSH
10439: LD_INT 107
10441: PUSH
10442: LD_INT 108
10444: PUSH
10445: LD_INT 109
10447: PUSH
10448: LD_INT 110
10450: PUSH
10451: LD_INT 111
10453: PUSH
10454: LD_INT 112
10456: PUSH
10457: LD_INT 114
10459: PUSH
10460: EMPTY
10461: LIST
10462: LIST
10463: LIST
10464: LIST
10465: LIST
10466: LIST
10467: LIST
10468: LIST
10469: LIST
10470: LIST
10471: LIST
10472: LIST
10473: LIST
10474: PUSH
10475: EMPTY
10476: LIST
10477: LIST
10478: ST_TO_ADDR
10479: GO 12066
10481: LD_INT 12
10483: DOUBLE
10484: EQUAL
10485: IFTRUE 10489
10487: GO 10697
10489: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 13 :
10490: LD_ADDR_VAR 0 1
10494: PUSH
10495: LD_INT 1
10497: PUSH
10498: LD_INT 2
10500: PUSH
10501: LD_INT 3
10503: PUSH
10504: LD_INT 4
10506: PUSH
10507: LD_INT 5
10509: PUSH
10510: LD_INT 6
10512: PUSH
10513: LD_INT 7
10515: PUSH
10516: LD_INT 8
10518: PUSH
10519: LD_INT 9
10521: PUSH
10522: LD_INT 10
10524: PUSH
10525: LD_INT 11
10527: PUSH
10528: LD_INT 12
10530: PUSH
10531: LD_INT 13
10533: PUSH
10534: LD_INT 14
10536: PUSH
10537: LD_INT 15
10539: PUSH
10540: LD_INT 16
10542: PUSH
10543: LD_INT 17
10545: PUSH
10546: LD_INT 18
10548: PUSH
10549: LD_INT 19
10551: PUSH
10552: LD_INT 20
10554: PUSH
10555: LD_INT 21
10557: PUSH
10558: LD_INT 22
10560: PUSH
10561: LD_INT 23
10563: PUSH
10564: LD_INT 24
10566: PUSH
10567: LD_INT 25
10569: PUSH
10570: LD_INT 26
10572: PUSH
10573: LD_INT 27
10575: PUSH
10576: LD_INT 28
10578: PUSH
10579: LD_INT 30
10581: PUSH
10582: LD_INT 31
10584: PUSH
10585: LD_INT 32
10587: PUSH
10588: LD_INT 33
10590: PUSH
10591: LD_INT 34
10593: PUSH
10594: LD_INT 36
10596: PUSH
10597: EMPTY
10598: LIST
10599: LIST
10600: LIST
10601: LIST
10602: LIST
10603: LIST
10604: LIST
10605: LIST
10606: LIST
10607: LIST
10608: LIST
10609: LIST
10610: LIST
10611: LIST
10612: LIST
10613: LIST
10614: LIST
10615: LIST
10616: LIST
10617: LIST
10618: LIST
10619: LIST
10620: LIST
10621: LIST
10622: LIST
10623: LIST
10624: LIST
10625: LIST
10626: LIST
10627: LIST
10628: LIST
10629: LIST
10630: LIST
10631: LIST
10632: PUSH
10633: LD_INT 101
10635: PUSH
10636: LD_INT 102
10638: PUSH
10639: LD_INT 103
10641: PUSH
10642: LD_INT 104
10644: PUSH
10645: LD_INT 105
10647: PUSH
10648: LD_INT 106
10650: PUSH
10651: LD_INT 107
10653: PUSH
10654: LD_INT 108
10656: PUSH
10657: LD_INT 109
10659: PUSH
10660: LD_INT 110
10662: PUSH
10663: LD_INT 111
10665: PUSH
10666: LD_INT 112
10668: PUSH
10669: LD_INT 113
10671: PUSH
10672: LD_INT 114
10674: PUSH
10675: EMPTY
10676: LIST
10677: LIST
10678: LIST
10679: LIST
10680: LIST
10681: LIST
10682: LIST
10683: LIST
10684: LIST
10685: LIST
10686: LIST
10687: LIST
10688: LIST
10689: LIST
10690: PUSH
10691: EMPTY
10692: LIST
10693: LIST
10694: ST_TO_ADDR
10695: GO 12066
10697: LD_INT 13
10699: DOUBLE
10700: EQUAL
10701: IFTRUE 10705
10703: GO 10901
10705: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 14 :
10706: LD_ADDR_VAR 0 1
10710: PUSH
10711: LD_INT 1
10713: PUSH
10714: LD_INT 2
10716: PUSH
10717: LD_INT 3
10719: PUSH
10720: LD_INT 4
10722: PUSH
10723: LD_INT 5
10725: PUSH
10726: LD_INT 8
10728: PUSH
10729: LD_INT 9
10731: PUSH
10732: LD_INT 10
10734: PUSH
10735: LD_INT 11
10737: PUSH
10738: LD_INT 12
10740: PUSH
10741: LD_INT 14
10743: PUSH
10744: LD_INT 15
10746: PUSH
10747: LD_INT 16
10749: PUSH
10750: LD_INT 17
10752: PUSH
10753: LD_INT 18
10755: PUSH
10756: LD_INT 19
10758: PUSH
10759: LD_INT 20
10761: PUSH
10762: LD_INT 21
10764: PUSH
10765: LD_INT 22
10767: PUSH
10768: LD_INT 23
10770: PUSH
10771: LD_INT 24
10773: PUSH
10774: LD_INT 25
10776: PUSH
10777: LD_INT 26
10779: PUSH
10780: LD_INT 27
10782: PUSH
10783: LD_INT 28
10785: PUSH
10786: LD_INT 30
10788: PUSH
10789: LD_INT 31
10791: PUSH
10792: LD_INT 32
10794: PUSH
10795: LD_INT 33
10797: PUSH
10798: LD_INT 34
10800: PUSH
10801: LD_INT 36
10803: PUSH
10804: EMPTY
10805: LIST
10806: LIST
10807: LIST
10808: LIST
10809: LIST
10810: LIST
10811: LIST
10812: LIST
10813: LIST
10814: LIST
10815: LIST
10816: LIST
10817: LIST
10818: LIST
10819: LIST
10820: LIST
10821: LIST
10822: LIST
10823: LIST
10824: LIST
10825: LIST
10826: LIST
10827: LIST
10828: LIST
10829: LIST
10830: LIST
10831: LIST
10832: LIST
10833: LIST
10834: LIST
10835: LIST
10836: PUSH
10837: LD_INT 101
10839: PUSH
10840: LD_INT 102
10842: PUSH
10843: LD_INT 103
10845: PUSH
10846: LD_INT 104
10848: PUSH
10849: LD_INT 105
10851: PUSH
10852: LD_INT 106
10854: PUSH
10855: LD_INT 107
10857: PUSH
10858: LD_INT 108
10860: PUSH
10861: LD_INT 109
10863: PUSH
10864: LD_INT 110
10866: PUSH
10867: LD_INT 111
10869: PUSH
10870: LD_INT 112
10872: PUSH
10873: LD_INT 113
10875: PUSH
10876: LD_INT 114
10878: PUSH
10879: EMPTY
10880: LIST
10881: LIST
10882: LIST
10883: LIST
10884: LIST
10885: LIST
10886: LIST
10887: LIST
10888: LIST
10889: LIST
10890: LIST
10891: LIST
10892: LIST
10893: LIST
10894: PUSH
10895: EMPTY
10896: LIST
10897: LIST
10898: ST_TO_ADDR
10899: GO 12066
10901: LD_INT 14
10903: DOUBLE
10904: EQUAL
10905: IFTRUE 10909
10907: GO 11121
10909: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 15 :
10910: LD_ADDR_VAR 0 1
10914: PUSH
10915: LD_INT 1
10917: PUSH
10918: LD_INT 2
10920: PUSH
10921: LD_INT 3
10923: PUSH
10924: LD_INT 4
10926: PUSH
10927: LD_INT 5
10929: PUSH
10930: LD_INT 6
10932: PUSH
10933: LD_INT 7
10935: PUSH
10936: LD_INT 8
10938: PUSH
10939: LD_INT 9
10941: PUSH
10942: LD_INT 10
10944: PUSH
10945: LD_INT 11
10947: PUSH
10948: LD_INT 12
10950: PUSH
10951: LD_INT 13
10953: PUSH
10954: LD_INT 14
10956: PUSH
10957: LD_INT 15
10959: PUSH
10960: LD_INT 16
10962: PUSH
10963: LD_INT 17
10965: PUSH
10966: LD_INT 18
10968: PUSH
10969: LD_INT 19
10971: PUSH
10972: LD_INT 20
10974: PUSH
10975: LD_INT 21
10977: PUSH
10978: LD_INT 22
10980: PUSH
10981: LD_INT 23
10983: PUSH
10984: LD_INT 24
10986: PUSH
10987: LD_INT 25
10989: PUSH
10990: LD_INT 26
10992: PUSH
10993: LD_INT 27
10995: PUSH
10996: LD_INT 28
10998: PUSH
10999: LD_INT 29
11001: PUSH
11002: LD_INT 30
11004: PUSH
11005: LD_INT 31
11007: PUSH
11008: LD_INT 32
11010: PUSH
11011: LD_INT 33
11013: PUSH
11014: LD_INT 34
11016: PUSH
11017: LD_INT 36
11019: PUSH
11020: EMPTY
11021: LIST
11022: LIST
11023: LIST
11024: LIST
11025: LIST
11026: LIST
11027: LIST
11028: LIST
11029: LIST
11030: LIST
11031: LIST
11032: LIST
11033: LIST
11034: LIST
11035: LIST
11036: LIST
11037: LIST
11038: LIST
11039: LIST
11040: LIST
11041: LIST
11042: LIST
11043: LIST
11044: LIST
11045: LIST
11046: LIST
11047: LIST
11048: LIST
11049: LIST
11050: LIST
11051: LIST
11052: LIST
11053: LIST
11054: LIST
11055: LIST
11056: PUSH
11057: LD_INT 101
11059: PUSH
11060: LD_INT 102
11062: PUSH
11063: LD_INT 103
11065: PUSH
11066: LD_INT 104
11068: PUSH
11069: LD_INT 105
11071: PUSH
11072: LD_INT 106
11074: PUSH
11075: LD_INT 107
11077: PUSH
11078: LD_INT 108
11080: PUSH
11081: LD_INT 109
11083: PUSH
11084: LD_INT 110
11086: PUSH
11087: LD_INT 111
11089: PUSH
11090: LD_INT 112
11092: PUSH
11093: LD_INT 113
11095: PUSH
11096: LD_INT 114
11098: PUSH
11099: EMPTY
11100: LIST
11101: LIST
11102: LIST
11103: LIST
11104: LIST
11105: LIST
11106: LIST
11107: LIST
11108: LIST
11109: LIST
11110: LIST
11111: LIST
11112: LIST
11113: LIST
11114: PUSH
11115: EMPTY
11116: LIST
11117: LIST
11118: ST_TO_ADDR
11119: GO 12066
11121: LD_INT 15
11123: DOUBLE
11124: EQUAL
11125: IFTRUE 11129
11127: GO 11341
11129: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 16 :
11130: LD_ADDR_VAR 0 1
11134: PUSH
11135: LD_INT 1
11137: PUSH
11138: LD_INT 2
11140: PUSH
11141: LD_INT 3
11143: PUSH
11144: LD_INT 4
11146: PUSH
11147: LD_INT 5
11149: PUSH
11150: LD_INT 6
11152: PUSH
11153: LD_INT 7
11155: PUSH
11156: LD_INT 8
11158: PUSH
11159: LD_INT 9
11161: PUSH
11162: LD_INT 10
11164: PUSH
11165: LD_INT 11
11167: PUSH
11168: LD_INT 12
11170: PUSH
11171: LD_INT 13
11173: PUSH
11174: LD_INT 14
11176: PUSH
11177: LD_INT 15
11179: PUSH
11180: LD_INT 16
11182: PUSH
11183: LD_INT 17
11185: PUSH
11186: LD_INT 18
11188: PUSH
11189: LD_INT 19
11191: PUSH
11192: LD_INT 20
11194: PUSH
11195: LD_INT 21
11197: PUSH
11198: LD_INT 22
11200: PUSH
11201: LD_INT 23
11203: PUSH
11204: LD_INT 24
11206: PUSH
11207: LD_INT 25
11209: PUSH
11210: LD_INT 26
11212: PUSH
11213: LD_INT 27
11215: PUSH
11216: LD_INT 28
11218: PUSH
11219: LD_INT 29
11221: PUSH
11222: LD_INT 30
11224: PUSH
11225: LD_INT 31
11227: PUSH
11228: LD_INT 32
11230: PUSH
11231: LD_INT 33
11233: PUSH
11234: LD_INT 34
11236: PUSH
11237: LD_INT 36
11239: PUSH
11240: EMPTY
11241: LIST
11242: LIST
11243: LIST
11244: LIST
11245: LIST
11246: LIST
11247: LIST
11248: LIST
11249: LIST
11250: LIST
11251: LIST
11252: LIST
11253: LIST
11254: LIST
11255: LIST
11256: LIST
11257: LIST
11258: LIST
11259: LIST
11260: LIST
11261: LIST
11262: LIST
11263: LIST
11264: LIST
11265: LIST
11266: LIST
11267: LIST
11268: LIST
11269: LIST
11270: LIST
11271: LIST
11272: LIST
11273: LIST
11274: LIST
11275: LIST
11276: PUSH
11277: LD_INT 101
11279: PUSH
11280: LD_INT 102
11282: PUSH
11283: LD_INT 103
11285: PUSH
11286: LD_INT 104
11288: PUSH
11289: LD_INT 105
11291: PUSH
11292: LD_INT 106
11294: PUSH
11295: LD_INT 107
11297: PUSH
11298: LD_INT 108
11300: PUSH
11301: LD_INT 109
11303: PUSH
11304: LD_INT 110
11306: PUSH
11307: LD_INT 111
11309: PUSH
11310: LD_INT 112
11312: PUSH
11313: LD_INT 113
11315: PUSH
11316: LD_INT 114
11318: PUSH
11319: EMPTY
11320: LIST
11321: LIST
11322: LIST
11323: LIST
11324: LIST
11325: LIST
11326: LIST
11327: LIST
11328: LIST
11329: LIST
11330: LIST
11331: LIST
11332: LIST
11333: LIST
11334: PUSH
11335: EMPTY
11336: LIST
11337: LIST
11338: ST_TO_ADDR
11339: GO 12066
11341: LD_INT 16
11343: DOUBLE
11344: EQUAL
11345: IFTRUE 11349
11347: GO 11473
11349: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 ] ] ; 17 :
11350: LD_ADDR_VAR 0 1
11354: PUSH
11355: LD_INT 2
11357: PUSH
11358: LD_INT 4
11360: PUSH
11361: LD_INT 5
11363: PUSH
11364: LD_INT 7
11366: PUSH
11367: LD_INT 11
11369: PUSH
11370: LD_INT 12
11372: PUSH
11373: LD_INT 15
11375: PUSH
11376: LD_INT 16
11378: PUSH
11379: LD_INT 20
11381: PUSH
11382: LD_INT 21
11384: PUSH
11385: LD_INT 22
11387: PUSH
11388: LD_INT 23
11390: PUSH
11391: LD_INT 25
11393: PUSH
11394: LD_INT 26
11396: PUSH
11397: LD_INT 30
11399: PUSH
11400: LD_INT 31
11402: PUSH
11403: LD_INT 32
11405: PUSH
11406: LD_INT 33
11408: PUSH
11409: LD_INT 34
11411: PUSH
11412: EMPTY
11413: LIST
11414: LIST
11415: LIST
11416: LIST
11417: LIST
11418: LIST
11419: LIST
11420: LIST
11421: LIST
11422: LIST
11423: LIST
11424: LIST
11425: LIST
11426: LIST
11427: LIST
11428: LIST
11429: LIST
11430: LIST
11431: LIST
11432: PUSH
11433: LD_INT 101
11435: PUSH
11436: LD_INT 102
11438: PUSH
11439: LD_INT 103
11441: PUSH
11442: LD_INT 106
11444: PUSH
11445: LD_INT 108
11447: PUSH
11448: LD_INT 112
11450: PUSH
11451: LD_INT 113
11453: PUSH
11454: LD_INT 114
11456: PUSH
11457: EMPTY
11458: LIST
11459: LIST
11460: LIST
11461: LIST
11462: LIST
11463: LIST
11464: LIST
11465: LIST
11466: PUSH
11467: EMPTY
11468: LIST
11469: LIST
11470: ST_TO_ADDR
11471: GO 12066
11473: LD_INT 17
11475: DOUBLE
11476: EQUAL
11477: IFTRUE 11481
11479: GO 11693
11481: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 18 :
11482: LD_ADDR_VAR 0 1
11486: PUSH
11487: LD_INT 1
11489: PUSH
11490: LD_INT 2
11492: PUSH
11493: LD_INT 3
11495: PUSH
11496: LD_INT 4
11498: PUSH
11499: LD_INT 5
11501: PUSH
11502: LD_INT 6
11504: PUSH
11505: LD_INT 7
11507: PUSH
11508: LD_INT 8
11510: PUSH
11511: LD_INT 9
11513: PUSH
11514: LD_INT 10
11516: PUSH
11517: LD_INT 11
11519: PUSH
11520: LD_INT 12
11522: PUSH
11523: LD_INT 13
11525: PUSH
11526: LD_INT 14
11528: PUSH
11529: LD_INT 15
11531: PUSH
11532: LD_INT 16
11534: PUSH
11535: LD_INT 17
11537: PUSH
11538: LD_INT 18
11540: PUSH
11541: LD_INT 19
11543: PUSH
11544: LD_INT 20
11546: PUSH
11547: LD_INT 21
11549: PUSH
11550: LD_INT 22
11552: PUSH
11553: LD_INT 23
11555: PUSH
11556: LD_INT 24
11558: PUSH
11559: LD_INT 25
11561: PUSH
11562: LD_INT 26
11564: PUSH
11565: LD_INT 27
11567: PUSH
11568: LD_INT 28
11570: PUSH
11571: LD_INT 29
11573: PUSH
11574: LD_INT 30
11576: PUSH
11577: LD_INT 31
11579: PUSH
11580: LD_INT 32
11582: PUSH
11583: LD_INT 33
11585: PUSH
11586: LD_INT 34
11588: PUSH
11589: LD_INT 36
11591: PUSH
11592: EMPTY
11593: LIST
11594: LIST
11595: LIST
11596: LIST
11597: LIST
11598: LIST
11599: LIST
11600: LIST
11601: LIST
11602: LIST
11603: LIST
11604: LIST
11605: LIST
11606: LIST
11607: LIST
11608: LIST
11609: LIST
11610: LIST
11611: LIST
11612: LIST
11613: LIST
11614: LIST
11615: LIST
11616: LIST
11617: LIST
11618: LIST
11619: LIST
11620: LIST
11621: LIST
11622: LIST
11623: LIST
11624: LIST
11625: LIST
11626: LIST
11627: LIST
11628: PUSH
11629: LD_INT 101
11631: PUSH
11632: LD_INT 102
11634: PUSH
11635: LD_INT 103
11637: PUSH
11638: LD_INT 104
11640: PUSH
11641: LD_INT 105
11643: PUSH
11644: LD_INT 106
11646: PUSH
11647: LD_INT 107
11649: PUSH
11650: LD_INT 108
11652: PUSH
11653: LD_INT 109
11655: PUSH
11656: LD_INT 110
11658: PUSH
11659: LD_INT 111
11661: PUSH
11662: LD_INT 112
11664: PUSH
11665: LD_INT 113
11667: PUSH
11668: LD_INT 114
11670: PUSH
11671: EMPTY
11672: LIST
11673: LIST
11674: LIST
11675: LIST
11676: LIST
11677: LIST
11678: LIST
11679: LIST
11680: LIST
11681: LIST
11682: LIST
11683: LIST
11684: LIST
11685: LIST
11686: PUSH
11687: EMPTY
11688: LIST
11689: LIST
11690: ST_TO_ADDR
11691: GO 12066
11693: LD_INT 18
11695: DOUBLE
11696: EQUAL
11697: IFTRUE 11701
11699: GO 11837
11701: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 ] ] ; 19 :
11702: LD_ADDR_VAR 0 1
11706: PUSH
11707: LD_INT 2
11709: PUSH
11710: LD_INT 4
11712: PUSH
11713: LD_INT 5
11715: PUSH
11716: LD_INT 7
11718: PUSH
11719: LD_INT 11
11721: PUSH
11722: LD_INT 12
11724: PUSH
11725: LD_INT 15
11727: PUSH
11728: LD_INT 16
11730: PUSH
11731: LD_INT 20
11733: PUSH
11734: LD_INT 21
11736: PUSH
11737: LD_INT 22
11739: PUSH
11740: LD_INT 23
11742: PUSH
11743: LD_INT 25
11745: PUSH
11746: LD_INT 26
11748: PUSH
11749: LD_INT 30
11751: PUSH
11752: LD_INT 31
11754: PUSH
11755: LD_INT 32
11757: PUSH
11758: LD_INT 33
11760: PUSH
11761: LD_INT 34
11763: PUSH
11764: LD_INT 35
11766: PUSH
11767: LD_INT 36
11769: PUSH
11770: EMPTY
11771: LIST
11772: LIST
11773: LIST
11774: LIST
11775: LIST
11776: LIST
11777: LIST
11778: LIST
11779: LIST
11780: LIST
11781: LIST
11782: LIST
11783: LIST
11784: LIST
11785: LIST
11786: LIST
11787: LIST
11788: LIST
11789: LIST
11790: LIST
11791: LIST
11792: PUSH
11793: LD_INT 101
11795: PUSH
11796: LD_INT 102
11798: PUSH
11799: LD_INT 103
11801: PUSH
11802: LD_INT 106
11804: PUSH
11805: LD_INT 108
11807: PUSH
11808: LD_INT 112
11810: PUSH
11811: LD_INT 113
11813: PUSH
11814: LD_INT 114
11816: PUSH
11817: LD_INT 115
11819: PUSH
11820: EMPTY
11821: LIST
11822: LIST
11823: LIST
11824: LIST
11825: LIST
11826: LIST
11827: LIST
11828: LIST
11829: LIST
11830: PUSH
11831: EMPTY
11832: LIST
11833: LIST
11834: ST_TO_ADDR
11835: GO 12066
11837: LD_INT 19
11839: DOUBLE
11840: EQUAL
11841: IFTRUE 11845
11843: GO 12065
11845: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ; end ;
11846: LD_ADDR_VAR 0 1
11850: PUSH
11851: LD_INT 1
11853: PUSH
11854: LD_INT 2
11856: PUSH
11857: LD_INT 3
11859: PUSH
11860: LD_INT 4
11862: PUSH
11863: LD_INT 5
11865: PUSH
11866: LD_INT 6
11868: PUSH
11869: LD_INT 7
11871: PUSH
11872: LD_INT 8
11874: PUSH
11875: LD_INT 9
11877: PUSH
11878: LD_INT 10
11880: PUSH
11881: LD_INT 11
11883: PUSH
11884: LD_INT 12
11886: PUSH
11887: LD_INT 13
11889: PUSH
11890: LD_INT 14
11892: PUSH
11893: LD_INT 15
11895: PUSH
11896: LD_INT 16
11898: PUSH
11899: LD_INT 17
11901: PUSH
11902: LD_INT 18
11904: PUSH
11905: LD_INT 19
11907: PUSH
11908: LD_INT 20
11910: PUSH
11911: LD_INT 21
11913: PUSH
11914: LD_INT 22
11916: PUSH
11917: LD_INT 23
11919: PUSH
11920: LD_INT 24
11922: PUSH
11923: LD_INT 25
11925: PUSH
11926: LD_INT 26
11928: PUSH
11929: LD_INT 27
11931: PUSH
11932: LD_INT 28
11934: PUSH
11935: LD_INT 29
11937: PUSH
11938: LD_INT 30
11940: PUSH
11941: LD_INT 31
11943: PUSH
11944: LD_INT 32
11946: PUSH
11947: LD_INT 33
11949: PUSH
11950: LD_INT 34
11952: PUSH
11953: LD_INT 35
11955: PUSH
11956: LD_INT 36
11958: PUSH
11959: EMPTY
11960: LIST
11961: LIST
11962: LIST
11963: LIST
11964: LIST
11965: LIST
11966: LIST
11967: LIST
11968: LIST
11969: LIST
11970: LIST
11971: LIST
11972: LIST
11973: LIST
11974: LIST
11975: LIST
11976: LIST
11977: LIST
11978: LIST
11979: LIST
11980: LIST
11981: LIST
11982: LIST
11983: LIST
11984: LIST
11985: LIST
11986: LIST
11987: LIST
11988: LIST
11989: LIST
11990: LIST
11991: LIST
11992: LIST
11993: LIST
11994: LIST
11995: LIST
11996: PUSH
11997: LD_INT 101
11999: PUSH
12000: LD_INT 102
12002: PUSH
12003: LD_INT 103
12005: PUSH
12006: LD_INT 104
12008: PUSH
12009: LD_INT 105
12011: PUSH
12012: LD_INT 106
12014: PUSH
12015: LD_INT 107
12017: PUSH
12018: LD_INT 108
12020: PUSH
12021: LD_INT 109
12023: PUSH
12024: LD_INT 110
12026: PUSH
12027: LD_INT 111
12029: PUSH
12030: LD_INT 112
12032: PUSH
12033: LD_INT 113
12035: PUSH
12036: LD_INT 114
12038: PUSH
12039: LD_INT 115
12041: PUSH
12042: EMPTY
12043: LIST
12044: LIST
12045: LIST
12046: LIST
12047: LIST
12048: LIST
12049: LIST
12050: LIST
12051: LIST
12052: LIST
12053: LIST
12054: LIST
12055: LIST
12056: LIST
12057: LIST
12058: PUSH
12059: EMPTY
12060: LIST
12061: LIST
12062: ST_TO_ADDR
12063: GO 12066
12065: POP
// end else
12066: GO 12103
// if campaign_id = 5 then
12068: LD_OWVAR 69
12072: PUSH
12073: LD_INT 5
12075: EQUAL
12076: IFFALSE 12103
// begin result := [ [ 1 , 2 ] , [ 100 ] ] ;
12078: LD_ADDR_VAR 0 1
12082: PUSH
12083: LD_INT 1
12085: PUSH
12086: LD_INT 2
12088: PUSH
12089: EMPTY
12090: LIST
12091: LIST
12092: PUSH
12093: LD_INT 100
12095: PUSH
12096: EMPTY
12097: LIST
12098: PUSH
12099: EMPTY
12100: LIST
12101: LIST
12102: ST_TO_ADDR
// end ; if result then
12103: LD_VAR 0 1
12107: IFFALSE 12396
// begin normal :=  ;
12109: LD_ADDR_VAR 0 3
12113: PUSH
12114: LD_STRING 
12116: ST_TO_ADDR
// hardcore :=  ;
12117: LD_ADDR_VAR 0 4
12121: PUSH
12122: LD_STRING 
12124: ST_TO_ADDR
// for i = 1 to normalCounter do
12125: LD_ADDR_VAR 0 5
12129: PUSH
12130: DOUBLE
12131: LD_INT 1
12133: DEC
12134: ST_TO_ADDR
12135: LD_EXP 58
12139: PUSH
12140: FOR_TO
12141: IFFALSE 12242
// begin tmp := 0 ;
12143: LD_ADDR_VAR 0 2
12147: PUSH
12148: LD_STRING 0
12150: ST_TO_ADDR
// if result [ 1 ] then
12151: LD_VAR 0 1
12155: PUSH
12156: LD_INT 1
12158: ARRAY
12159: IFFALSE 12224
// if result [ 1 ] [ 1 ] = i then
12161: LD_VAR 0 1
12165: PUSH
12166: LD_INT 1
12168: ARRAY
12169: PUSH
12170: LD_INT 1
12172: ARRAY
12173: PUSH
12174: LD_VAR 0 5
12178: EQUAL
12179: IFFALSE 12224
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
12181: LD_ADDR_VAR 0 1
12185: PUSH
12186: LD_VAR 0 1
12190: PPUSH
12191: LD_INT 1
12193: PPUSH
12194: LD_VAR 0 1
12198: PUSH
12199: LD_INT 1
12201: ARRAY
12202: PPUSH
12203: LD_INT 1
12205: PPUSH
12206: CALL_OW 3
12210: PPUSH
12211: CALL_OW 1
12215: ST_TO_ADDR
// tmp := 1 ;
12216: LD_ADDR_VAR 0 2
12220: PUSH
12221: LD_STRING 1
12223: ST_TO_ADDR
// end ; normal := normal & tmp ;
12224: LD_ADDR_VAR 0 3
12228: PUSH
12229: LD_VAR 0 3
12233: PUSH
12234: LD_VAR 0 2
12238: STR
12239: ST_TO_ADDR
// end ;
12240: GO 12140
12242: POP
12243: POP
// for i = 1 to hardcoreCounter do
12244: LD_ADDR_VAR 0 5
12248: PUSH
12249: DOUBLE
12250: LD_INT 1
12252: DEC
12253: ST_TO_ADDR
12254: LD_EXP 59
12258: PUSH
12259: FOR_TO
12260: IFFALSE 12365
// begin tmp := 0 ;
12262: LD_ADDR_VAR 0 2
12266: PUSH
12267: LD_STRING 0
12269: ST_TO_ADDR
// if result [ 2 ] then
12270: LD_VAR 0 1
12274: PUSH
12275: LD_INT 2
12277: ARRAY
12278: IFFALSE 12347
// if result [ 2 ] [ 1 ] = 100 + i then
12280: LD_VAR 0 1
12284: PUSH
12285: LD_INT 2
12287: ARRAY
12288: PUSH
12289: LD_INT 1
12291: ARRAY
12292: PUSH
12293: LD_INT 100
12295: PUSH
12296: LD_VAR 0 5
12300: PLUS
12301: EQUAL
12302: IFFALSE 12347
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
12304: LD_ADDR_VAR 0 1
12308: PUSH
12309: LD_VAR 0 1
12313: PPUSH
12314: LD_INT 2
12316: PPUSH
12317: LD_VAR 0 1
12321: PUSH
12322: LD_INT 2
12324: ARRAY
12325: PPUSH
12326: LD_INT 1
12328: PPUSH
12329: CALL_OW 3
12333: PPUSH
12334: CALL_OW 1
12338: ST_TO_ADDR
// tmp := 1 ;
12339: LD_ADDR_VAR 0 2
12343: PUSH
12344: LD_STRING 1
12346: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
12347: LD_ADDR_VAR 0 4
12351: PUSH
12352: LD_VAR 0 4
12356: PUSH
12357: LD_VAR 0 2
12361: STR
12362: ST_TO_ADDR
// end ;
12363: GO 12259
12365: POP
12366: POP
// ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & ") ) ;
12367: LD_STRING getStreamItemsFromMission("
12369: PUSH
12370: LD_VAR 0 3
12374: STR
12375: PUSH
12376: LD_STRING ","
12378: STR
12379: PUSH
12380: LD_VAR 0 4
12384: STR
12385: PUSH
12386: LD_STRING ")
12388: STR
12389: PPUSH
12390: CALL_OW 559
// end else
12394: GO 12403
// ToLua ( getStreamItemsFromMission("","") ) ;
12396: LD_STRING getStreamItemsFromMission("","")
12398: PPUSH
12399: CALL_OW 559
// end ;
12403: LD_VAR 0 1
12407: RET
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin if p2 = 100 then
12408: LD_VAR 0 2
12412: PUSH
12413: LD_INT 100
12415: EQUAL
12416: IFFALSE 13365
// begin if not StreamModeActive then
12418: LD_EXP 57
12422: NOT
12423: IFFALSE 12433
// StreamModeActive := true ;
12425: LD_ADDR_EXP 57
12429: PUSH
12430: LD_INT 1
12432: ST_TO_ADDR
// if p3 = 0 then
12433: LD_VAR 0 3
12437: PUSH
12438: LD_INT 0
12440: EQUAL
12441: IFFALSE 12447
// InitStreamMode ;
12443: CALL 8668 0 0
// if p3 = 1 then
12447: LD_VAR 0 3
12451: PUSH
12452: LD_INT 1
12454: EQUAL
12455: IFFALSE 12465
// sRocket := true ;
12457: LD_ADDR_EXP 62
12461: PUSH
12462: LD_INT 1
12464: ST_TO_ADDR
// if p3 = 2 then
12465: LD_VAR 0 3
12469: PUSH
12470: LD_INT 2
12472: EQUAL
12473: IFFALSE 12483
// sSpeed := true ;
12475: LD_ADDR_EXP 61
12479: PUSH
12480: LD_INT 1
12482: ST_TO_ADDR
// if p3 = 3 then
12483: LD_VAR 0 3
12487: PUSH
12488: LD_INT 3
12490: EQUAL
12491: IFFALSE 12501
// sEngine := true ;
12493: LD_ADDR_EXP 63
12497: PUSH
12498: LD_INT 1
12500: ST_TO_ADDR
// if p3 = 4 then
12501: LD_VAR 0 3
12505: PUSH
12506: LD_INT 4
12508: EQUAL
12509: IFFALSE 12519
// sSpec := true ;
12511: LD_ADDR_EXP 60
12515: PUSH
12516: LD_INT 1
12518: ST_TO_ADDR
// if p3 = 5 then
12519: LD_VAR 0 3
12523: PUSH
12524: LD_INT 5
12526: EQUAL
12527: IFFALSE 12537
// sLevel := true ;
12529: LD_ADDR_EXP 64
12533: PUSH
12534: LD_INT 1
12536: ST_TO_ADDR
// if p3 = 6 then
12537: LD_VAR 0 3
12541: PUSH
12542: LD_INT 6
12544: EQUAL
12545: IFFALSE 12555
// sArmoury := true ;
12547: LD_ADDR_EXP 65
12551: PUSH
12552: LD_INT 1
12554: ST_TO_ADDR
// if p3 = 7 then
12555: LD_VAR 0 3
12559: PUSH
12560: LD_INT 7
12562: EQUAL
12563: IFFALSE 12573
// sRadar := true ;
12565: LD_ADDR_EXP 66
12569: PUSH
12570: LD_INT 1
12572: ST_TO_ADDR
// if p3 = 8 then
12573: LD_VAR 0 3
12577: PUSH
12578: LD_INT 8
12580: EQUAL
12581: IFFALSE 12591
// sBunker := true ;
12583: LD_ADDR_EXP 67
12587: PUSH
12588: LD_INT 1
12590: ST_TO_ADDR
// if p3 = 9 then
12591: LD_VAR 0 3
12595: PUSH
12596: LD_INT 9
12598: EQUAL
12599: IFFALSE 12609
// sHack := true ;
12601: LD_ADDR_EXP 68
12605: PUSH
12606: LD_INT 1
12608: ST_TO_ADDR
// if p3 = 10 then
12609: LD_VAR 0 3
12613: PUSH
12614: LD_INT 10
12616: EQUAL
12617: IFFALSE 12627
// sFire := true ;
12619: LD_ADDR_EXP 69
12623: PUSH
12624: LD_INT 1
12626: ST_TO_ADDR
// if p3 = 11 then
12627: LD_VAR 0 3
12631: PUSH
12632: LD_INT 11
12634: EQUAL
12635: IFFALSE 12645
// sRefresh := true ;
12637: LD_ADDR_EXP 70
12641: PUSH
12642: LD_INT 1
12644: ST_TO_ADDR
// if p3 = 12 then
12645: LD_VAR 0 3
12649: PUSH
12650: LD_INT 12
12652: EQUAL
12653: IFFALSE 12663
// sExp := true ;
12655: LD_ADDR_EXP 71
12659: PUSH
12660: LD_INT 1
12662: ST_TO_ADDR
// if p3 = 13 then
12663: LD_VAR 0 3
12667: PUSH
12668: LD_INT 13
12670: EQUAL
12671: IFFALSE 12681
// sDepot := true ;
12673: LD_ADDR_EXP 72
12677: PUSH
12678: LD_INT 1
12680: ST_TO_ADDR
// if p3 = 14 then
12681: LD_VAR 0 3
12685: PUSH
12686: LD_INT 14
12688: EQUAL
12689: IFFALSE 12699
// sFlag := true ;
12691: LD_ADDR_EXP 73
12695: PUSH
12696: LD_INT 1
12698: ST_TO_ADDR
// if p3 = 15 then
12699: LD_VAR 0 3
12703: PUSH
12704: LD_INT 15
12706: EQUAL
12707: IFFALSE 12717
// sKamikadze := true ;
12709: LD_ADDR_EXP 81
12713: PUSH
12714: LD_INT 1
12716: ST_TO_ADDR
// if p3 = 16 then
12717: LD_VAR 0 3
12721: PUSH
12722: LD_INT 16
12724: EQUAL
12725: IFFALSE 12735
// sTroll := true ;
12727: LD_ADDR_EXP 82
12731: PUSH
12732: LD_INT 1
12734: ST_TO_ADDR
// if p3 = 17 then
12735: LD_VAR 0 3
12739: PUSH
12740: LD_INT 17
12742: EQUAL
12743: IFFALSE 12753
// sSlow := true ;
12745: LD_ADDR_EXP 83
12749: PUSH
12750: LD_INT 1
12752: ST_TO_ADDR
// if p3 = 18 then
12753: LD_VAR 0 3
12757: PUSH
12758: LD_INT 18
12760: EQUAL
12761: IFFALSE 12771
// sLack := true ;
12763: LD_ADDR_EXP 84
12767: PUSH
12768: LD_INT 1
12770: ST_TO_ADDR
// if p3 = 19 then
12771: LD_VAR 0 3
12775: PUSH
12776: LD_INT 19
12778: EQUAL
12779: IFFALSE 12789
// sTank := true ;
12781: LD_ADDR_EXP 86
12785: PUSH
12786: LD_INT 1
12788: ST_TO_ADDR
// if p3 = 20 then
12789: LD_VAR 0 3
12793: PUSH
12794: LD_INT 20
12796: EQUAL
12797: IFFALSE 12807
// sRemote := true ;
12799: LD_ADDR_EXP 87
12803: PUSH
12804: LD_INT 1
12806: ST_TO_ADDR
// if p3 = 21 then
12807: LD_VAR 0 3
12811: PUSH
12812: LD_INT 21
12814: EQUAL
12815: IFFALSE 12825
// sPowell := true ;
12817: LD_ADDR_EXP 88
12821: PUSH
12822: LD_INT 1
12824: ST_TO_ADDR
// if p3 = 22 then
12825: LD_VAR 0 3
12829: PUSH
12830: LD_INT 22
12832: EQUAL
12833: IFFALSE 12843
// sTeleport := true ;
12835: LD_ADDR_EXP 91
12839: PUSH
12840: LD_INT 1
12842: ST_TO_ADDR
// if p3 = 23 then
12843: LD_VAR 0 3
12847: PUSH
12848: LD_INT 23
12850: EQUAL
12851: IFFALSE 12861
// sOilTower := true ;
12853: LD_ADDR_EXP 93
12857: PUSH
12858: LD_INT 1
12860: ST_TO_ADDR
// if p3 = 24 then
12861: LD_VAR 0 3
12865: PUSH
12866: LD_INT 24
12868: EQUAL
12869: IFFALSE 12879
// sShovel := true ;
12871: LD_ADDR_EXP 94
12875: PUSH
12876: LD_INT 1
12878: ST_TO_ADDR
// if p3 = 25 then
12879: LD_VAR 0 3
12883: PUSH
12884: LD_INT 25
12886: EQUAL
12887: IFFALSE 12897
// sSheik := true ;
12889: LD_ADDR_EXP 95
12893: PUSH
12894: LD_INT 1
12896: ST_TO_ADDR
// if p3 = 26 then
12897: LD_VAR 0 3
12901: PUSH
12902: LD_INT 26
12904: EQUAL
12905: IFFALSE 12915
// sEarthquake := true ;
12907: LD_ADDR_EXP 97
12911: PUSH
12912: LD_INT 1
12914: ST_TO_ADDR
// if p3 = 27 then
12915: LD_VAR 0 3
12919: PUSH
12920: LD_INT 27
12922: EQUAL
12923: IFFALSE 12933
// sAI := true ;
12925: LD_ADDR_EXP 98
12929: PUSH
12930: LD_INT 1
12932: ST_TO_ADDR
// if p3 = 28 then
12933: LD_VAR 0 3
12937: PUSH
12938: LD_INT 28
12940: EQUAL
12941: IFFALSE 12951
// sCargo := true ;
12943: LD_ADDR_EXP 101
12947: PUSH
12948: LD_INT 1
12950: ST_TO_ADDR
// if p3 = 29 then
12951: LD_VAR 0 3
12955: PUSH
12956: LD_INT 29
12958: EQUAL
12959: IFFALSE 12969
// sDLaser := true ;
12961: LD_ADDR_EXP 102
12965: PUSH
12966: LD_INT 1
12968: ST_TO_ADDR
// if p3 = 30 then
12969: LD_VAR 0 3
12973: PUSH
12974: LD_INT 30
12976: EQUAL
12977: IFFALSE 12987
// sExchange := true ;
12979: LD_ADDR_EXP 103
12983: PUSH
12984: LD_INT 1
12986: ST_TO_ADDR
// if p3 = 31 then
12987: LD_VAR 0 3
12991: PUSH
12992: LD_INT 31
12994: EQUAL
12995: IFFALSE 13005
// sFac := true ;
12997: LD_ADDR_EXP 104
13001: PUSH
13002: LD_INT 1
13004: ST_TO_ADDR
// if p3 = 32 then
13005: LD_VAR 0 3
13009: PUSH
13010: LD_INT 32
13012: EQUAL
13013: IFFALSE 13023
// sPower := true ;
13015: LD_ADDR_EXP 105
13019: PUSH
13020: LD_INT 1
13022: ST_TO_ADDR
// if p3 = 33 then
13023: LD_VAR 0 3
13027: PUSH
13028: LD_INT 33
13030: EQUAL
13031: IFFALSE 13041
// sRandom := true ;
13033: LD_ADDR_EXP 106
13037: PUSH
13038: LD_INT 1
13040: ST_TO_ADDR
// if p3 = 34 then
13041: LD_VAR 0 3
13045: PUSH
13046: LD_INT 34
13048: EQUAL
13049: IFFALSE 13059
// sShield := true ;
13051: LD_ADDR_EXP 107
13055: PUSH
13056: LD_INT 1
13058: ST_TO_ADDR
// if p3 = 35 then
13059: LD_VAR 0 3
13063: PUSH
13064: LD_INT 35
13066: EQUAL
13067: IFFALSE 13077
// sTime := true ;
13069: LD_ADDR_EXP 108
13073: PUSH
13074: LD_INT 1
13076: ST_TO_ADDR
// if p3 = 36 then
13077: LD_VAR 0 3
13081: PUSH
13082: LD_INT 36
13084: EQUAL
13085: IFFALSE 13095
// sTools := true ;
13087: LD_ADDR_EXP 109
13091: PUSH
13092: LD_INT 1
13094: ST_TO_ADDR
// if p3 = 101 then
13095: LD_VAR 0 3
13099: PUSH
13100: LD_INT 101
13102: EQUAL
13103: IFFALSE 13113
// sSold := true ;
13105: LD_ADDR_EXP 74
13109: PUSH
13110: LD_INT 1
13112: ST_TO_ADDR
// if p3 = 102 then
13113: LD_VAR 0 3
13117: PUSH
13118: LD_INT 102
13120: EQUAL
13121: IFFALSE 13131
// sDiff := true ;
13123: LD_ADDR_EXP 75
13127: PUSH
13128: LD_INT 1
13130: ST_TO_ADDR
// if p3 = 103 then
13131: LD_VAR 0 3
13135: PUSH
13136: LD_INT 103
13138: EQUAL
13139: IFFALSE 13149
// sFog := true ;
13141: LD_ADDR_EXP 78
13145: PUSH
13146: LD_INT 1
13148: ST_TO_ADDR
// if p3 = 104 then
13149: LD_VAR 0 3
13153: PUSH
13154: LD_INT 104
13156: EQUAL
13157: IFFALSE 13167
// sReset := true ;
13159: LD_ADDR_EXP 79
13163: PUSH
13164: LD_INT 1
13166: ST_TO_ADDR
// if p3 = 105 then
13167: LD_VAR 0 3
13171: PUSH
13172: LD_INT 105
13174: EQUAL
13175: IFFALSE 13185
// sSun := true ;
13177: LD_ADDR_EXP 80
13181: PUSH
13182: LD_INT 1
13184: ST_TO_ADDR
// if p3 = 106 then
13185: LD_VAR 0 3
13189: PUSH
13190: LD_INT 106
13192: EQUAL
13193: IFFALSE 13203
// sTiger := true ;
13195: LD_ADDR_EXP 76
13199: PUSH
13200: LD_INT 1
13202: ST_TO_ADDR
// if p3 = 107 then
13203: LD_VAR 0 3
13207: PUSH
13208: LD_INT 107
13210: EQUAL
13211: IFFALSE 13221
// sBomb := true ;
13213: LD_ADDR_EXP 77
13217: PUSH
13218: LD_INT 1
13220: ST_TO_ADDR
// if p3 = 108 then
13221: LD_VAR 0 3
13225: PUSH
13226: LD_INT 108
13228: EQUAL
13229: IFFALSE 13239
// sWound := true ;
13231: LD_ADDR_EXP 85
13235: PUSH
13236: LD_INT 1
13238: ST_TO_ADDR
// if p3 = 109 then
13239: LD_VAR 0 3
13243: PUSH
13244: LD_INT 109
13246: EQUAL
13247: IFFALSE 13257
// sBetray := true ;
13249: LD_ADDR_EXP 89
13253: PUSH
13254: LD_INT 1
13256: ST_TO_ADDR
// if p3 = 110 then
13257: LD_VAR 0 3
13261: PUSH
13262: LD_INT 110
13264: EQUAL
13265: IFFALSE 13275
// sContamin := true ;
13267: LD_ADDR_EXP 90
13271: PUSH
13272: LD_INT 1
13274: ST_TO_ADDR
// if p3 = 111 then
13275: LD_VAR 0 3
13279: PUSH
13280: LD_INT 111
13282: EQUAL
13283: IFFALSE 13293
// sOil := true ;
13285: LD_ADDR_EXP 92
13289: PUSH
13290: LD_INT 1
13292: ST_TO_ADDR
// if p3 = 112 then
13293: LD_VAR 0 3
13297: PUSH
13298: LD_INT 112
13300: EQUAL
13301: IFFALSE 13311
// sStu := true ;
13303: LD_ADDR_EXP 96
13307: PUSH
13308: LD_INT 1
13310: ST_TO_ADDR
// if p3 = 113 then
13311: LD_VAR 0 3
13315: PUSH
13316: LD_INT 113
13318: EQUAL
13319: IFFALSE 13329
// sBazooka := true ;
13321: LD_ADDR_EXP 99
13325: PUSH
13326: LD_INT 1
13328: ST_TO_ADDR
// if p3 = 114 then
13329: LD_VAR 0 3
13333: PUSH
13334: LD_INT 114
13336: EQUAL
13337: IFFALSE 13347
// sMortar := true ;
13339: LD_ADDR_EXP 100
13343: PUSH
13344: LD_INT 1
13346: ST_TO_ADDR
// if p3 = 115 then
13347: LD_VAR 0 3
13351: PUSH
13352: LD_INT 115
13354: EQUAL
13355: IFFALSE 13365
// sRanger := true ;
13357: LD_ADDR_EXP 110
13361: PUSH
13362: LD_INT 1
13364: ST_TO_ADDR
// end ; end ;
13365: PPOPN 6
13367: END
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
13368: LD_EXP 57
13372: PUSH
13373: LD_EXP 62
13377: AND
13378: IFFALSE 13502
13380: GO 13382
13382: DISABLE
13383: LD_INT 0
13385: PPUSH
13386: PPUSH
// begin enable ;
13387: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
13388: LD_ADDR_VAR 0 2
13392: PUSH
13393: LD_INT 22
13395: PUSH
13396: LD_OWVAR 2
13400: PUSH
13401: EMPTY
13402: LIST
13403: LIST
13404: PUSH
13405: LD_INT 2
13407: PUSH
13408: LD_INT 34
13410: PUSH
13411: LD_INT 7
13413: PUSH
13414: EMPTY
13415: LIST
13416: LIST
13417: PUSH
13418: LD_INT 34
13420: PUSH
13421: LD_INT 45
13423: PUSH
13424: EMPTY
13425: LIST
13426: LIST
13427: PUSH
13428: LD_INT 34
13430: PUSH
13431: LD_INT 28
13433: PUSH
13434: EMPTY
13435: LIST
13436: LIST
13437: PUSH
13438: LD_INT 34
13440: PUSH
13441: LD_INT 47
13443: PUSH
13444: EMPTY
13445: LIST
13446: LIST
13447: PUSH
13448: EMPTY
13449: LIST
13450: LIST
13451: LIST
13452: LIST
13453: LIST
13454: PUSH
13455: EMPTY
13456: LIST
13457: LIST
13458: PPUSH
13459: CALL_OW 69
13463: ST_TO_ADDR
// if not tmp then
13464: LD_VAR 0 2
13468: NOT
13469: IFFALSE 13473
// exit ;
13471: GO 13502
// for i in tmp do
13473: LD_ADDR_VAR 0 1
13477: PUSH
13478: LD_VAR 0 2
13482: PUSH
13483: FOR_IN
13484: IFFALSE 13500
// begin SetLives ( i , 0 ) ;
13486: LD_VAR 0 1
13490: PPUSH
13491: LD_INT 0
13493: PPUSH
13494: CALL_OW 234
// end ;
13498: GO 13483
13500: POP
13501: POP
// end ;
13502: PPOPN 2
13504: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
13505: LD_EXP 57
13509: PUSH
13510: LD_EXP 63
13514: AND
13515: IFFALSE 13599
13517: GO 13519
13519: DISABLE
13520: LD_INT 0
13522: PPUSH
13523: PPUSH
// begin enable ;
13524: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
13525: LD_ADDR_VAR 0 2
13529: PUSH
13530: LD_INT 22
13532: PUSH
13533: LD_OWVAR 2
13537: PUSH
13538: EMPTY
13539: LIST
13540: LIST
13541: PUSH
13542: LD_INT 32
13544: PUSH
13545: LD_INT 3
13547: PUSH
13548: EMPTY
13549: LIST
13550: LIST
13551: PUSH
13552: EMPTY
13553: LIST
13554: LIST
13555: PPUSH
13556: CALL_OW 69
13560: ST_TO_ADDR
// if not tmp then
13561: LD_VAR 0 2
13565: NOT
13566: IFFALSE 13570
// exit ;
13568: GO 13599
// for i in tmp do
13570: LD_ADDR_VAR 0 1
13574: PUSH
13575: LD_VAR 0 2
13579: PUSH
13580: FOR_IN
13581: IFFALSE 13597
// begin SetLives ( i , 0 ) ;
13583: LD_VAR 0 1
13587: PPUSH
13588: LD_INT 0
13590: PPUSH
13591: CALL_OW 234
// end ;
13595: GO 13580
13597: POP
13598: POP
// end ;
13599: PPOPN 2
13601: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
13602: LD_EXP 57
13606: PUSH
13607: LD_EXP 60
13611: AND
13612: IFFALSE 13705
13614: GO 13616
13616: DISABLE
13617: LD_INT 0
13619: PPUSH
// begin enable ;
13620: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
13621: LD_ADDR_VAR 0 1
13625: PUSH
13626: LD_INT 22
13628: PUSH
13629: LD_OWVAR 2
13633: PUSH
13634: EMPTY
13635: LIST
13636: LIST
13637: PUSH
13638: LD_INT 2
13640: PUSH
13641: LD_INT 25
13643: PUSH
13644: LD_INT 5
13646: PUSH
13647: EMPTY
13648: LIST
13649: LIST
13650: PUSH
13651: LD_INT 25
13653: PUSH
13654: LD_INT 9
13656: PUSH
13657: EMPTY
13658: LIST
13659: LIST
13660: PUSH
13661: LD_INT 25
13663: PUSH
13664: LD_INT 8
13666: PUSH
13667: EMPTY
13668: LIST
13669: LIST
13670: PUSH
13671: EMPTY
13672: LIST
13673: LIST
13674: LIST
13675: LIST
13676: PUSH
13677: EMPTY
13678: LIST
13679: LIST
13680: PPUSH
13681: CALL_OW 69
13685: PUSH
13686: FOR_IN
13687: IFFALSE 13703
// begin SetClass ( i , 1 ) ;
13689: LD_VAR 0 1
13693: PPUSH
13694: LD_INT 1
13696: PPUSH
13697: CALL_OW 336
// end ;
13701: GO 13686
13703: POP
13704: POP
// end ;
13705: PPOPN 1
13707: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
13708: LD_EXP 57
13712: PUSH
13713: LD_EXP 61
13717: AND
13718: PUSH
13719: LD_OWVAR 65
13723: PUSH
13724: LD_INT 7
13726: LESS
13727: AND
13728: IFFALSE 13742
13730: GO 13732
13732: DISABLE
// begin enable ;
13733: ENABLE
// game_speed := 7 ;
13734: LD_ADDR_OWVAR 65
13738: PUSH
13739: LD_INT 7
13741: ST_TO_ADDR
// end ;
13742: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
13743: LD_EXP 57
13747: PUSH
13748: LD_EXP 64
13752: AND
13753: IFFALSE 13955
13755: GO 13757
13757: DISABLE
13758: LD_INT 0
13760: PPUSH
13761: PPUSH
13762: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
13763: LD_ADDR_VAR 0 3
13767: PUSH
13768: LD_INT 81
13770: PUSH
13771: LD_OWVAR 2
13775: PUSH
13776: EMPTY
13777: LIST
13778: LIST
13779: PUSH
13780: LD_INT 21
13782: PUSH
13783: LD_INT 1
13785: PUSH
13786: EMPTY
13787: LIST
13788: LIST
13789: PUSH
13790: EMPTY
13791: LIST
13792: LIST
13793: PPUSH
13794: CALL_OW 69
13798: ST_TO_ADDR
// if not tmp then
13799: LD_VAR 0 3
13803: NOT
13804: IFFALSE 13808
// exit ;
13806: GO 13955
// if tmp > 5 then
13808: LD_VAR 0 3
13812: PUSH
13813: LD_INT 5
13815: GREATER
13816: IFFALSE 13828
// k := 5 else
13818: LD_ADDR_VAR 0 2
13822: PUSH
13823: LD_INT 5
13825: ST_TO_ADDR
13826: GO 13838
// k := tmp ;
13828: LD_ADDR_VAR 0 2
13832: PUSH
13833: LD_VAR 0 3
13837: ST_TO_ADDR
// for i := 1 to k do
13838: LD_ADDR_VAR 0 1
13842: PUSH
13843: DOUBLE
13844: LD_INT 1
13846: DEC
13847: ST_TO_ADDR
13848: LD_VAR 0 2
13852: PUSH
13853: FOR_TO
13854: IFFALSE 13953
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
13856: LD_VAR 0 3
13860: PUSH
13861: LD_VAR 0 1
13865: ARRAY
13866: PPUSH
13867: LD_VAR 0 1
13871: PUSH
13872: LD_INT 4
13874: MOD
13875: PUSH
13876: LD_INT 1
13878: PLUS
13879: PPUSH
13880: CALL_OW 259
13884: PUSH
13885: LD_INT 10
13887: LESS
13888: IFFALSE 13951
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
13890: LD_VAR 0 3
13894: PUSH
13895: LD_VAR 0 1
13899: ARRAY
13900: PPUSH
13901: LD_VAR 0 1
13905: PUSH
13906: LD_INT 4
13908: MOD
13909: PUSH
13910: LD_INT 1
13912: PLUS
13913: PPUSH
13914: LD_VAR 0 3
13918: PUSH
13919: LD_VAR 0 1
13923: ARRAY
13924: PPUSH
13925: LD_VAR 0 1
13929: PUSH
13930: LD_INT 4
13932: MOD
13933: PUSH
13934: LD_INT 1
13936: PLUS
13937: PPUSH
13938: CALL_OW 259
13942: PUSH
13943: LD_INT 1
13945: PLUS
13946: PPUSH
13947: CALL_OW 237
13951: GO 13853
13953: POP
13954: POP
// end ;
13955: PPOPN 3
13957: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
13958: LD_EXP 57
13962: PUSH
13963: LD_EXP 65
13967: AND
13968: IFFALSE 13988
13970: GO 13972
13972: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
13973: LD_INT 4
13975: PPUSH
13976: LD_OWVAR 2
13980: PPUSH
13981: LD_INT 0
13983: PPUSH
13984: CALL_OW 324
13988: END
// every 0 0$1 trigger StreamModeActive and sShovel do
13989: LD_EXP 57
13993: PUSH
13994: LD_EXP 94
13998: AND
13999: IFFALSE 14019
14001: GO 14003
14003: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
14004: LD_INT 19
14006: PPUSH
14007: LD_OWVAR 2
14011: PPUSH
14012: LD_INT 0
14014: PPUSH
14015: CALL_OW 324
14019: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
14020: LD_EXP 57
14024: PUSH
14025: LD_EXP 66
14029: AND
14030: IFFALSE 14132
14032: GO 14034
14034: DISABLE
14035: LD_INT 0
14037: PPUSH
14038: PPUSH
// begin enable ;
14039: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
14040: LD_ADDR_VAR 0 2
14044: PUSH
14045: LD_INT 22
14047: PUSH
14048: LD_OWVAR 2
14052: PUSH
14053: EMPTY
14054: LIST
14055: LIST
14056: PUSH
14057: LD_INT 2
14059: PUSH
14060: LD_INT 34
14062: PUSH
14063: LD_INT 11
14065: PUSH
14066: EMPTY
14067: LIST
14068: LIST
14069: PUSH
14070: LD_INT 34
14072: PUSH
14073: LD_INT 30
14075: PUSH
14076: EMPTY
14077: LIST
14078: LIST
14079: PUSH
14080: EMPTY
14081: LIST
14082: LIST
14083: LIST
14084: PUSH
14085: EMPTY
14086: LIST
14087: LIST
14088: PPUSH
14089: CALL_OW 69
14093: ST_TO_ADDR
// if not tmp then
14094: LD_VAR 0 2
14098: NOT
14099: IFFALSE 14103
// exit ;
14101: GO 14132
// for i in tmp do
14103: LD_ADDR_VAR 0 1
14107: PUSH
14108: LD_VAR 0 2
14112: PUSH
14113: FOR_IN
14114: IFFALSE 14130
// begin SetLives ( i , 0 ) ;
14116: LD_VAR 0 1
14120: PPUSH
14121: LD_INT 0
14123: PPUSH
14124: CALL_OW 234
// end ;
14128: GO 14113
14130: POP
14131: POP
// end ;
14132: PPOPN 2
14134: END
// every 0 0$1 trigger StreamModeActive and sBunker do
14135: LD_EXP 57
14139: PUSH
14140: LD_EXP 67
14144: AND
14145: IFFALSE 14165
14147: GO 14149
14149: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
14150: LD_INT 32
14152: PPUSH
14153: LD_OWVAR 2
14157: PPUSH
14158: LD_INT 0
14160: PPUSH
14161: CALL_OW 324
14165: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
14166: LD_EXP 57
14170: PUSH
14171: LD_EXP 68
14175: AND
14176: IFFALSE 14357
14178: GO 14180
14180: DISABLE
14181: LD_INT 0
14183: PPUSH
14184: PPUSH
14185: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
14186: LD_ADDR_VAR 0 2
14190: PUSH
14191: LD_INT 22
14193: PUSH
14194: LD_OWVAR 2
14198: PUSH
14199: EMPTY
14200: LIST
14201: LIST
14202: PUSH
14203: LD_INT 33
14205: PUSH
14206: LD_INT 3
14208: PUSH
14209: EMPTY
14210: LIST
14211: LIST
14212: PUSH
14213: EMPTY
14214: LIST
14215: LIST
14216: PPUSH
14217: CALL_OW 69
14221: ST_TO_ADDR
// if not tmp then
14222: LD_VAR 0 2
14226: NOT
14227: IFFALSE 14231
// exit ;
14229: GO 14357
// side := 0 ;
14231: LD_ADDR_VAR 0 3
14235: PUSH
14236: LD_INT 0
14238: ST_TO_ADDR
// for i := 1 to 8 do
14239: LD_ADDR_VAR 0 1
14243: PUSH
14244: DOUBLE
14245: LD_INT 1
14247: DEC
14248: ST_TO_ADDR
14249: LD_INT 8
14251: PUSH
14252: FOR_TO
14253: IFFALSE 14301
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
14255: LD_OWVAR 2
14259: PUSH
14260: LD_VAR 0 1
14264: NONEQUAL
14265: PUSH
14266: LD_OWVAR 2
14270: PPUSH
14271: LD_VAR 0 1
14275: PPUSH
14276: CALL_OW 81
14280: PUSH
14281: LD_INT 2
14283: EQUAL
14284: AND
14285: IFFALSE 14299
// begin side := i ;
14287: LD_ADDR_VAR 0 3
14291: PUSH
14292: LD_VAR 0 1
14296: ST_TO_ADDR
// break ;
14297: GO 14301
// end ;
14299: GO 14252
14301: POP
14302: POP
// if not side then
14303: LD_VAR 0 3
14307: NOT
14308: IFFALSE 14312
// exit ;
14310: GO 14357
// for i := 1 to tmp do
14312: LD_ADDR_VAR 0 1
14316: PUSH
14317: DOUBLE
14318: LD_INT 1
14320: DEC
14321: ST_TO_ADDR
14322: LD_VAR 0 2
14326: PUSH
14327: FOR_TO
14328: IFFALSE 14355
// if Prob ( 60 ) then
14330: LD_INT 60
14332: PPUSH
14333: CALL_OW 13
14337: IFFALSE 14353
// SetSide ( i , side ) ;
14339: LD_VAR 0 1
14343: PPUSH
14344: LD_VAR 0 3
14348: PPUSH
14349: CALL_OW 235
14353: GO 14327
14355: POP
14356: POP
// end ;
14357: PPOPN 3
14359: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
14360: LD_EXP 57
14364: PUSH
14365: LD_EXP 70
14369: AND
14370: IFFALSE 14489
14372: GO 14374
14374: DISABLE
14375: LD_INT 0
14377: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
14378: LD_ADDR_VAR 0 1
14382: PUSH
14383: LD_INT 22
14385: PUSH
14386: LD_OWVAR 2
14390: PUSH
14391: EMPTY
14392: LIST
14393: LIST
14394: PUSH
14395: LD_INT 21
14397: PUSH
14398: LD_INT 1
14400: PUSH
14401: EMPTY
14402: LIST
14403: LIST
14404: PUSH
14405: LD_INT 3
14407: PUSH
14408: LD_INT 23
14410: PUSH
14411: LD_INT 0
14413: PUSH
14414: EMPTY
14415: LIST
14416: LIST
14417: PUSH
14418: EMPTY
14419: LIST
14420: LIST
14421: PUSH
14422: EMPTY
14423: LIST
14424: LIST
14425: LIST
14426: PPUSH
14427: CALL_OW 69
14431: PUSH
14432: FOR_IN
14433: IFFALSE 14487
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
14435: LD_VAR 0 1
14439: PPUSH
14440: CALL_OW 257
14444: PUSH
14445: LD_INT 1
14447: PUSH
14448: LD_INT 2
14450: PUSH
14451: LD_INT 3
14453: PUSH
14454: LD_INT 4
14456: PUSH
14457: EMPTY
14458: LIST
14459: LIST
14460: LIST
14461: LIST
14462: IN
14463: IFFALSE 14485
// SetClass ( un , rand ( 1 , 4 ) ) ;
14465: LD_VAR 0 1
14469: PPUSH
14470: LD_INT 1
14472: PPUSH
14473: LD_INT 4
14475: PPUSH
14476: CALL_OW 12
14480: PPUSH
14481: CALL_OW 336
14485: GO 14432
14487: POP
14488: POP
// end ;
14489: PPOPN 1
14491: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
14492: LD_EXP 57
14496: PUSH
14497: LD_EXP 69
14501: AND
14502: IFFALSE 14581
14504: GO 14506
14506: DISABLE
14507: LD_INT 0
14509: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
14510: LD_ADDR_VAR 0 1
14514: PUSH
14515: LD_INT 22
14517: PUSH
14518: LD_OWVAR 2
14522: PUSH
14523: EMPTY
14524: LIST
14525: LIST
14526: PUSH
14527: LD_INT 21
14529: PUSH
14530: LD_INT 3
14532: PUSH
14533: EMPTY
14534: LIST
14535: LIST
14536: PUSH
14537: EMPTY
14538: LIST
14539: LIST
14540: PPUSH
14541: CALL_OW 69
14545: ST_TO_ADDR
// if not tmp then
14546: LD_VAR 0 1
14550: NOT
14551: IFFALSE 14555
// exit ;
14553: GO 14581
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
14555: LD_VAR 0 1
14559: PUSH
14560: LD_INT 1
14562: PPUSH
14563: LD_VAR 0 1
14567: PPUSH
14568: CALL_OW 12
14572: ARRAY
14573: PPUSH
14574: LD_INT 100
14576: PPUSH
14577: CALL_OW 234
// end ;
14581: PPOPN 1
14583: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
14584: LD_EXP 57
14588: PUSH
14589: LD_EXP 71
14593: AND
14594: IFFALSE 14692
14596: GO 14598
14598: DISABLE
14599: LD_INT 0
14601: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
14602: LD_ADDR_VAR 0 1
14606: PUSH
14607: LD_INT 22
14609: PUSH
14610: LD_OWVAR 2
14614: PUSH
14615: EMPTY
14616: LIST
14617: LIST
14618: PUSH
14619: LD_INT 21
14621: PUSH
14622: LD_INT 1
14624: PUSH
14625: EMPTY
14626: LIST
14627: LIST
14628: PUSH
14629: EMPTY
14630: LIST
14631: LIST
14632: PPUSH
14633: CALL_OW 69
14637: ST_TO_ADDR
// if not tmp then
14638: LD_VAR 0 1
14642: NOT
14643: IFFALSE 14647
// exit ;
14645: GO 14692
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
14647: LD_VAR 0 1
14651: PUSH
14652: LD_INT 1
14654: PPUSH
14655: LD_VAR 0 1
14659: PPUSH
14660: CALL_OW 12
14664: ARRAY
14665: PPUSH
14666: LD_INT 1
14668: PPUSH
14669: LD_INT 4
14671: PPUSH
14672: CALL_OW 12
14676: PPUSH
14677: LD_INT 3000
14679: PPUSH
14680: LD_INT 9000
14682: PPUSH
14683: CALL_OW 12
14687: PPUSH
14688: CALL_OW 492
// end ;
14692: PPOPN 1
14694: END
// every 0 0$1 trigger StreamModeActive and sDepot do
14695: LD_EXP 57
14699: PUSH
14700: LD_EXP 72
14704: AND
14705: IFFALSE 14725
14707: GO 14709
14709: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
14710: LD_INT 1
14712: PPUSH
14713: LD_OWVAR 2
14717: PPUSH
14718: LD_INT 0
14720: PPUSH
14721: CALL_OW 324
14725: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
14726: LD_EXP 57
14730: PUSH
14731: LD_EXP 73
14735: AND
14736: IFFALSE 14819
14738: GO 14740
14740: DISABLE
14741: LD_INT 0
14743: PPUSH
14744: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
14745: LD_ADDR_VAR 0 2
14749: PUSH
14750: LD_INT 22
14752: PUSH
14753: LD_OWVAR 2
14757: PUSH
14758: EMPTY
14759: LIST
14760: LIST
14761: PUSH
14762: LD_INT 21
14764: PUSH
14765: LD_INT 3
14767: PUSH
14768: EMPTY
14769: LIST
14770: LIST
14771: PUSH
14772: EMPTY
14773: LIST
14774: LIST
14775: PPUSH
14776: CALL_OW 69
14780: ST_TO_ADDR
// if not tmp then
14781: LD_VAR 0 2
14785: NOT
14786: IFFALSE 14790
// exit ;
14788: GO 14819
// for i in tmp do
14790: LD_ADDR_VAR 0 1
14794: PUSH
14795: LD_VAR 0 2
14799: PUSH
14800: FOR_IN
14801: IFFALSE 14817
// SetBLevel ( i , 10 ) ;
14803: LD_VAR 0 1
14807: PPUSH
14808: LD_INT 10
14810: PPUSH
14811: CALL_OW 241
14815: GO 14800
14817: POP
14818: POP
// end ;
14819: PPOPN 2
14821: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
14822: LD_EXP 57
14826: PUSH
14827: LD_EXP 74
14831: AND
14832: IFFALSE 14943
14834: GO 14836
14836: DISABLE
14837: LD_INT 0
14839: PPUSH
14840: PPUSH
14841: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
14842: LD_ADDR_VAR 0 3
14846: PUSH
14847: LD_INT 22
14849: PUSH
14850: LD_OWVAR 2
14854: PUSH
14855: EMPTY
14856: LIST
14857: LIST
14858: PUSH
14859: LD_INT 25
14861: PUSH
14862: LD_INT 1
14864: PUSH
14865: EMPTY
14866: LIST
14867: LIST
14868: PUSH
14869: EMPTY
14870: LIST
14871: LIST
14872: PPUSH
14873: CALL_OW 69
14877: ST_TO_ADDR
// if not tmp then
14878: LD_VAR 0 3
14882: NOT
14883: IFFALSE 14887
// exit ;
14885: GO 14943
// un := tmp [ rand ( 1 , tmp ) ] ;
14887: LD_ADDR_VAR 0 2
14891: PUSH
14892: LD_VAR 0 3
14896: PUSH
14897: LD_INT 1
14899: PPUSH
14900: LD_VAR 0 3
14904: PPUSH
14905: CALL_OW 12
14909: ARRAY
14910: ST_TO_ADDR
// if Crawls ( un ) then
14911: LD_VAR 0 2
14915: PPUSH
14916: CALL_OW 318
14920: IFFALSE 14931
// ComWalk ( un ) ;
14922: LD_VAR 0 2
14926: PPUSH
14927: CALL_OW 138
// SetClass ( un , class_sniper ) ;
14931: LD_VAR 0 2
14935: PPUSH
14936: LD_INT 5
14938: PPUSH
14939: CALL_OW 336
// end ;
14943: PPOPN 3
14945: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
14946: LD_EXP 57
14950: PUSH
14951: LD_EXP 75
14955: AND
14956: PUSH
14957: LD_OWVAR 67
14961: PUSH
14962: LD_INT 3
14964: LESS
14965: AND
14966: IFFALSE 14985
14968: GO 14970
14970: DISABLE
// Difficulty := Difficulty + 1 ;
14971: LD_ADDR_OWVAR 67
14975: PUSH
14976: LD_OWVAR 67
14980: PUSH
14981: LD_INT 1
14983: PLUS
14984: ST_TO_ADDR
14985: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
14986: LD_EXP 57
14990: PUSH
14991: LD_EXP 76
14995: AND
14996: IFFALSE 15099
14998: GO 15000
15000: DISABLE
15001: LD_INT 0
15003: PPUSH
// begin for i := 1 to 5 do
15004: LD_ADDR_VAR 0 1
15008: PUSH
15009: DOUBLE
15010: LD_INT 1
15012: DEC
15013: ST_TO_ADDR
15014: LD_INT 5
15016: PUSH
15017: FOR_TO
15018: IFFALSE 15097
// begin uc_nation := nation_nature ;
15020: LD_ADDR_OWVAR 21
15024: PUSH
15025: LD_INT 0
15027: ST_TO_ADDR
// uc_side := 0 ;
15028: LD_ADDR_OWVAR 20
15032: PUSH
15033: LD_INT 0
15035: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
15036: LD_ADDR_OWVAR 29
15040: PUSH
15041: LD_INT 12
15043: PUSH
15044: LD_INT 12
15046: PUSH
15047: EMPTY
15048: LIST
15049: LIST
15050: ST_TO_ADDR
// hc_agressivity := 20 ;
15051: LD_ADDR_OWVAR 35
15055: PUSH
15056: LD_INT 20
15058: ST_TO_ADDR
// hc_class := class_tiger ;
15059: LD_ADDR_OWVAR 28
15063: PUSH
15064: LD_INT 14
15066: ST_TO_ADDR
// hc_gallery :=  ;
15067: LD_ADDR_OWVAR 33
15071: PUSH
15072: LD_STRING 
15074: ST_TO_ADDR
// hc_name :=  ;
15075: LD_ADDR_OWVAR 26
15079: PUSH
15080: LD_STRING 
15082: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
15083: CALL_OW 44
15087: PPUSH
15088: LD_INT 0
15090: PPUSH
15091: CALL_OW 51
// end ;
15095: GO 15017
15097: POP
15098: POP
// end ;
15099: PPOPN 1
15101: END
// every 0 0$1 trigger StreamModeActive and sBomb do
15102: LD_EXP 57
15106: PUSH
15107: LD_EXP 77
15111: AND
15112: IFFALSE 15121
15114: GO 15116
15116: DISABLE
// StreamSibBomb ;
15117: CALL 15122 0 0
15121: END
// export function StreamSibBomb ; var i , x , y ; begin
15122: LD_INT 0
15124: PPUSH
15125: PPUSH
15126: PPUSH
15127: PPUSH
// result := false ;
15128: LD_ADDR_VAR 0 1
15132: PUSH
15133: LD_INT 0
15135: ST_TO_ADDR
// for i := 1 to 16 do
15136: LD_ADDR_VAR 0 2
15140: PUSH
15141: DOUBLE
15142: LD_INT 1
15144: DEC
15145: ST_TO_ADDR
15146: LD_INT 16
15148: PUSH
15149: FOR_TO
15150: IFFALSE 15349
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
15152: LD_ADDR_VAR 0 3
15156: PUSH
15157: LD_INT 10
15159: PUSH
15160: LD_INT 20
15162: PUSH
15163: LD_INT 30
15165: PUSH
15166: LD_INT 40
15168: PUSH
15169: LD_INT 50
15171: PUSH
15172: LD_INT 60
15174: PUSH
15175: LD_INT 70
15177: PUSH
15178: LD_INT 80
15180: PUSH
15181: LD_INT 90
15183: PUSH
15184: LD_INT 100
15186: PUSH
15187: LD_INT 110
15189: PUSH
15190: LD_INT 120
15192: PUSH
15193: LD_INT 130
15195: PUSH
15196: LD_INT 140
15198: PUSH
15199: LD_INT 150
15201: PUSH
15202: EMPTY
15203: LIST
15204: LIST
15205: LIST
15206: LIST
15207: LIST
15208: LIST
15209: LIST
15210: LIST
15211: LIST
15212: LIST
15213: LIST
15214: LIST
15215: LIST
15216: LIST
15217: LIST
15218: PUSH
15219: LD_INT 1
15221: PPUSH
15222: LD_INT 15
15224: PPUSH
15225: CALL_OW 12
15229: ARRAY
15230: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
15231: LD_ADDR_VAR 0 4
15235: PUSH
15236: LD_INT 10
15238: PUSH
15239: LD_INT 20
15241: PUSH
15242: LD_INT 30
15244: PUSH
15245: LD_INT 40
15247: PUSH
15248: LD_INT 50
15250: PUSH
15251: LD_INT 60
15253: PUSH
15254: LD_INT 70
15256: PUSH
15257: LD_INT 80
15259: PUSH
15260: LD_INT 90
15262: PUSH
15263: LD_INT 100
15265: PUSH
15266: LD_INT 110
15268: PUSH
15269: LD_INT 120
15271: PUSH
15272: LD_INT 130
15274: PUSH
15275: LD_INT 140
15277: PUSH
15278: LD_INT 150
15280: PUSH
15281: EMPTY
15282: LIST
15283: LIST
15284: LIST
15285: LIST
15286: LIST
15287: LIST
15288: LIST
15289: LIST
15290: LIST
15291: LIST
15292: LIST
15293: LIST
15294: LIST
15295: LIST
15296: LIST
15297: PUSH
15298: LD_INT 1
15300: PPUSH
15301: LD_INT 15
15303: PPUSH
15304: CALL_OW 12
15308: ARRAY
15309: ST_TO_ADDR
// if ValidHex ( x , y ) then
15310: LD_VAR 0 3
15314: PPUSH
15315: LD_VAR 0 4
15319: PPUSH
15320: CALL_OW 488
15324: IFFALSE 15347
// begin result := [ x , y ] ;
15326: LD_ADDR_VAR 0 1
15330: PUSH
15331: LD_VAR 0 3
15335: PUSH
15336: LD_VAR 0 4
15340: PUSH
15341: EMPTY
15342: LIST
15343: LIST
15344: ST_TO_ADDR
// break ;
15345: GO 15349
// end ; end ;
15347: GO 15149
15349: POP
15350: POP
// if result then
15351: LD_VAR 0 1
15355: IFFALSE 15415
// begin ToLua ( playSibBomb() ) ;
15357: LD_STRING playSibBomb()
15359: PPUSH
15360: CALL_OW 559
// wait ( 0 0$14 ) ;
15364: LD_INT 490
15366: PPUSH
15367: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
15371: LD_VAR 0 1
15375: PUSH
15376: LD_INT 1
15378: ARRAY
15379: PPUSH
15380: LD_VAR 0 1
15384: PUSH
15385: LD_INT 2
15387: ARRAY
15388: PPUSH
15389: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
15393: LD_VAR 0 1
15397: PUSH
15398: LD_INT 1
15400: ARRAY
15401: PPUSH
15402: LD_VAR 0 1
15406: PUSH
15407: LD_INT 2
15409: ARRAY
15410: PPUSH
15411: CALL_OW 429
// end ; end ;
15415: LD_VAR 0 1
15419: RET
// every 0 0$1 trigger StreamModeActive and sReset do
15420: LD_EXP 57
15424: PUSH
15425: LD_EXP 79
15429: AND
15430: IFFALSE 15442
15432: GO 15434
15434: DISABLE
// YouLost (  ) ;
15435: LD_STRING 
15437: PPUSH
15438: CALL_OW 104
15442: END
// every 0 0$1 trigger StreamModeActive and sFog do
15443: LD_EXP 57
15447: PUSH
15448: LD_EXP 78
15452: AND
15453: IFFALSE 15467
15455: GO 15457
15457: DISABLE
// FogOff ( your_side ) ;
15458: LD_OWVAR 2
15462: PPUSH
15463: CALL_OW 344
15467: END
// every 0 0$1 trigger StreamModeActive and sSun do
15468: LD_EXP 57
15472: PUSH
15473: LD_EXP 80
15477: AND
15478: IFFALSE 15506
15480: GO 15482
15482: DISABLE
// begin solar_recharge_percent := 0 ;
15483: LD_ADDR_OWVAR 79
15487: PUSH
15488: LD_INT 0
15490: ST_TO_ADDR
// wait ( 5 5$00 ) ;
15491: LD_INT 10500
15493: PPUSH
15494: CALL_OW 67
// solar_recharge_percent := 100 ;
15498: LD_ADDR_OWVAR 79
15502: PUSH
15503: LD_INT 100
15505: ST_TO_ADDR
// end ;
15506: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
15507: LD_EXP 57
15511: PUSH
15512: LD_EXP 81
15516: AND
15517: IFFALSE 15756
15519: GO 15521
15521: DISABLE
15522: LD_INT 0
15524: PPUSH
15525: PPUSH
15526: PPUSH
// begin tmp := [ ] ;
15527: LD_ADDR_VAR 0 3
15531: PUSH
15532: EMPTY
15533: ST_TO_ADDR
// for i := 1 to 6 do
15534: LD_ADDR_VAR 0 1
15538: PUSH
15539: DOUBLE
15540: LD_INT 1
15542: DEC
15543: ST_TO_ADDR
15544: LD_INT 6
15546: PUSH
15547: FOR_TO
15548: IFFALSE 15653
// begin uc_nation := nation_nature ;
15550: LD_ADDR_OWVAR 21
15554: PUSH
15555: LD_INT 0
15557: ST_TO_ADDR
// uc_side := 0 ;
15558: LD_ADDR_OWVAR 20
15562: PUSH
15563: LD_INT 0
15565: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
15566: LD_ADDR_OWVAR 29
15570: PUSH
15571: LD_INT 12
15573: PUSH
15574: LD_INT 12
15576: PUSH
15577: EMPTY
15578: LIST
15579: LIST
15580: ST_TO_ADDR
// hc_agressivity := 20 ;
15581: LD_ADDR_OWVAR 35
15585: PUSH
15586: LD_INT 20
15588: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
15589: LD_ADDR_OWVAR 28
15593: PUSH
15594: LD_INT 17
15596: ST_TO_ADDR
// hc_gallery :=  ;
15597: LD_ADDR_OWVAR 33
15601: PUSH
15602: LD_STRING 
15604: ST_TO_ADDR
// hc_name :=  ;
15605: LD_ADDR_OWVAR 26
15609: PUSH
15610: LD_STRING 
15612: ST_TO_ADDR
// un := CreateHuman ;
15613: LD_ADDR_VAR 0 2
15617: PUSH
15618: CALL_OW 44
15622: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
15623: LD_VAR 0 2
15627: PPUSH
15628: LD_INT 1
15630: PPUSH
15631: CALL_OW 51
// tmp := tmp ^ un ;
15635: LD_ADDR_VAR 0 3
15639: PUSH
15640: LD_VAR 0 3
15644: PUSH
15645: LD_VAR 0 2
15649: ADD
15650: ST_TO_ADDR
// end ;
15651: GO 15547
15653: POP
15654: POP
// repeat wait ( 0 0$1 ) ;
15655: LD_INT 35
15657: PPUSH
15658: CALL_OW 67
// for un in tmp do
15662: LD_ADDR_VAR 0 2
15666: PUSH
15667: LD_VAR 0 3
15671: PUSH
15672: FOR_IN
15673: IFFALSE 15747
// begin if IsDead ( un ) then
15675: LD_VAR 0 2
15679: PPUSH
15680: CALL_OW 301
15684: IFFALSE 15704
// begin tmp := tmp diff un ;
15686: LD_ADDR_VAR 0 3
15690: PUSH
15691: LD_VAR 0 3
15695: PUSH
15696: LD_VAR 0 2
15700: DIFF
15701: ST_TO_ADDR
// continue ;
15702: GO 15672
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
15704: LD_VAR 0 2
15708: PPUSH
15709: LD_INT 3
15711: PUSH
15712: LD_INT 22
15714: PUSH
15715: LD_INT 0
15717: PUSH
15718: EMPTY
15719: LIST
15720: LIST
15721: PUSH
15722: EMPTY
15723: LIST
15724: LIST
15725: PPUSH
15726: CALL_OW 69
15730: PPUSH
15731: LD_VAR 0 2
15735: PPUSH
15736: CALL_OW 74
15740: PPUSH
15741: CALL_OW 115
// end ;
15745: GO 15672
15747: POP
15748: POP
// until not tmp ;
15749: LD_VAR 0 3
15753: NOT
15754: IFFALSE 15655
// end ;
15756: PPOPN 3
15758: END
// every 0 0$1 trigger StreamModeActive and sTroll do
15759: LD_EXP 57
15763: PUSH
15764: LD_EXP 82
15768: AND
15769: IFFALSE 15823
15771: GO 15773
15773: DISABLE
// begin ToLua ( displayTroll(); ) ;
15774: LD_STRING displayTroll();
15776: PPUSH
15777: CALL_OW 559
// wait ( 3 3$00 ) ;
15781: LD_INT 6300
15783: PPUSH
15784: CALL_OW 67
// ToLua ( hideTroll(); ) ;
15788: LD_STRING hideTroll();
15790: PPUSH
15791: CALL_OW 559
// wait ( 1 1$00 ) ;
15795: LD_INT 2100
15797: PPUSH
15798: CALL_OW 67
// ToLua ( displayTroll(); ) ;
15802: LD_STRING displayTroll();
15804: PPUSH
15805: CALL_OW 559
// wait ( 1 1$00 ) ;
15809: LD_INT 2100
15811: PPUSH
15812: CALL_OW 67
// ToLua ( hideTroll(); ) ;
15816: LD_STRING hideTroll();
15818: PPUSH
15819: CALL_OW 559
// end ;
15823: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
15824: LD_EXP 57
15828: PUSH
15829: LD_EXP 83
15833: AND
15834: IFFALSE 15897
15836: GO 15838
15838: DISABLE
15839: LD_INT 0
15841: PPUSH
// begin p := 0 ;
15842: LD_ADDR_VAR 0 1
15846: PUSH
15847: LD_INT 0
15849: ST_TO_ADDR
// repeat game_speed := 1 ;
15850: LD_ADDR_OWVAR 65
15854: PUSH
15855: LD_INT 1
15857: ST_TO_ADDR
// wait ( 0 0$1 ) ;
15858: LD_INT 35
15860: PPUSH
15861: CALL_OW 67
// p := p + 1 ;
15865: LD_ADDR_VAR 0 1
15869: PUSH
15870: LD_VAR 0 1
15874: PUSH
15875: LD_INT 1
15877: PLUS
15878: ST_TO_ADDR
// until p >= 60 ;
15879: LD_VAR 0 1
15883: PUSH
15884: LD_INT 60
15886: GREATEREQUAL
15887: IFFALSE 15850
// game_speed := 4 ;
15889: LD_ADDR_OWVAR 65
15893: PUSH
15894: LD_INT 4
15896: ST_TO_ADDR
// end ;
15897: PPOPN 1
15899: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
15900: LD_EXP 57
15904: PUSH
15905: LD_EXP 84
15909: AND
15910: IFFALSE 16056
15912: GO 15914
15914: DISABLE
15915: LD_INT 0
15917: PPUSH
15918: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
15919: LD_ADDR_VAR 0 1
15923: PUSH
15924: LD_INT 22
15926: PUSH
15927: LD_OWVAR 2
15931: PUSH
15932: EMPTY
15933: LIST
15934: LIST
15935: PUSH
15936: LD_INT 2
15938: PUSH
15939: LD_INT 30
15941: PUSH
15942: LD_INT 0
15944: PUSH
15945: EMPTY
15946: LIST
15947: LIST
15948: PUSH
15949: LD_INT 30
15951: PUSH
15952: LD_INT 1
15954: PUSH
15955: EMPTY
15956: LIST
15957: LIST
15958: PUSH
15959: EMPTY
15960: LIST
15961: LIST
15962: LIST
15963: PUSH
15964: EMPTY
15965: LIST
15966: LIST
15967: PPUSH
15968: CALL_OW 69
15972: ST_TO_ADDR
// if not depot then
15973: LD_VAR 0 1
15977: NOT
15978: IFFALSE 15982
// exit ;
15980: GO 16056
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
15982: LD_ADDR_VAR 0 2
15986: PUSH
15987: LD_VAR 0 1
15991: PUSH
15992: LD_INT 1
15994: PPUSH
15995: LD_VAR 0 1
15999: PPUSH
16000: CALL_OW 12
16004: ARRAY
16005: PPUSH
16006: CALL_OW 274
16010: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
16011: LD_VAR 0 2
16015: PPUSH
16016: LD_INT 1
16018: PPUSH
16019: LD_INT 0
16021: PPUSH
16022: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
16026: LD_VAR 0 2
16030: PPUSH
16031: LD_INT 2
16033: PPUSH
16034: LD_INT 0
16036: PPUSH
16037: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
16041: LD_VAR 0 2
16045: PPUSH
16046: LD_INT 3
16048: PPUSH
16049: LD_INT 0
16051: PPUSH
16052: CALL_OW 277
// end ;
16056: PPOPN 2
16058: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
16059: LD_EXP 57
16063: PUSH
16064: LD_EXP 85
16068: AND
16069: IFFALSE 16166
16071: GO 16073
16073: DISABLE
16074: LD_INT 0
16076: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
16077: LD_ADDR_VAR 0 1
16081: PUSH
16082: LD_INT 22
16084: PUSH
16085: LD_OWVAR 2
16089: PUSH
16090: EMPTY
16091: LIST
16092: LIST
16093: PUSH
16094: LD_INT 21
16096: PUSH
16097: LD_INT 1
16099: PUSH
16100: EMPTY
16101: LIST
16102: LIST
16103: PUSH
16104: LD_INT 3
16106: PUSH
16107: LD_INT 23
16109: PUSH
16110: LD_INT 0
16112: PUSH
16113: EMPTY
16114: LIST
16115: LIST
16116: PUSH
16117: EMPTY
16118: LIST
16119: LIST
16120: PUSH
16121: EMPTY
16122: LIST
16123: LIST
16124: LIST
16125: PPUSH
16126: CALL_OW 69
16130: ST_TO_ADDR
// if not tmp then
16131: LD_VAR 0 1
16135: NOT
16136: IFFALSE 16140
// exit ;
16138: GO 16166
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
16140: LD_VAR 0 1
16144: PUSH
16145: LD_INT 1
16147: PPUSH
16148: LD_VAR 0 1
16152: PPUSH
16153: CALL_OW 12
16157: ARRAY
16158: PPUSH
16159: LD_INT 200
16161: PPUSH
16162: CALL_OW 234
// end ;
16166: PPOPN 1
16168: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
16169: LD_EXP 57
16173: PUSH
16174: LD_EXP 86
16178: AND
16179: IFFALSE 16258
16181: GO 16183
16183: DISABLE
16184: LD_INT 0
16186: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
16187: LD_ADDR_VAR 0 1
16191: PUSH
16192: LD_INT 22
16194: PUSH
16195: LD_OWVAR 2
16199: PUSH
16200: EMPTY
16201: LIST
16202: LIST
16203: PUSH
16204: LD_INT 21
16206: PUSH
16207: LD_INT 2
16209: PUSH
16210: EMPTY
16211: LIST
16212: LIST
16213: PUSH
16214: EMPTY
16215: LIST
16216: LIST
16217: PPUSH
16218: CALL_OW 69
16222: ST_TO_ADDR
// if not tmp then
16223: LD_VAR 0 1
16227: NOT
16228: IFFALSE 16232
// exit ;
16230: GO 16258
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
16232: LD_VAR 0 1
16236: PUSH
16237: LD_INT 1
16239: PPUSH
16240: LD_VAR 0 1
16244: PPUSH
16245: CALL_OW 12
16249: ARRAY
16250: PPUSH
16251: LD_INT 60
16253: PPUSH
16254: CALL_OW 234
// end ;
16258: PPOPN 1
16260: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
16261: LD_EXP 57
16265: PUSH
16266: LD_EXP 87
16270: AND
16271: IFFALSE 16370
16273: GO 16275
16275: DISABLE
16276: LD_INT 0
16278: PPUSH
16279: PPUSH
// begin enable ;
16280: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
16281: LD_ADDR_VAR 0 1
16285: PUSH
16286: LD_INT 22
16288: PUSH
16289: LD_OWVAR 2
16293: PUSH
16294: EMPTY
16295: LIST
16296: LIST
16297: PUSH
16298: LD_INT 61
16300: PUSH
16301: EMPTY
16302: LIST
16303: PUSH
16304: LD_INT 33
16306: PUSH
16307: LD_INT 2
16309: PUSH
16310: EMPTY
16311: LIST
16312: LIST
16313: PUSH
16314: EMPTY
16315: LIST
16316: LIST
16317: LIST
16318: PPUSH
16319: CALL_OW 69
16323: ST_TO_ADDR
// if not tmp then
16324: LD_VAR 0 1
16328: NOT
16329: IFFALSE 16333
// exit ;
16331: GO 16370
// for i in tmp do
16333: LD_ADDR_VAR 0 2
16337: PUSH
16338: LD_VAR 0 1
16342: PUSH
16343: FOR_IN
16344: IFFALSE 16368
// if IsControledBy ( i ) then
16346: LD_VAR 0 2
16350: PPUSH
16351: CALL_OW 312
16355: IFFALSE 16366
// ComUnlink ( i ) ;
16357: LD_VAR 0 2
16361: PPUSH
16362: CALL_OW 136
16366: GO 16343
16368: POP
16369: POP
// end ;
16370: PPOPN 2
16372: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
16373: LD_EXP 57
16377: PUSH
16378: LD_EXP 88
16382: AND
16383: IFFALSE 16523
16385: GO 16387
16387: DISABLE
16388: LD_INT 0
16390: PPUSH
16391: PPUSH
// begin ToLua ( displayPowell(); ) ;
16392: LD_STRING displayPowell();
16394: PPUSH
16395: CALL_OW 559
// uc_side := 0 ;
16399: LD_ADDR_OWVAR 20
16403: PUSH
16404: LD_INT 0
16406: ST_TO_ADDR
// uc_nation := 2 ;
16407: LD_ADDR_OWVAR 21
16411: PUSH
16412: LD_INT 2
16414: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
16415: LD_ADDR_OWVAR 37
16419: PUSH
16420: LD_INT 14
16422: ST_TO_ADDR
// vc_engine := engine_siberite ;
16423: LD_ADDR_OWVAR 39
16427: PUSH
16428: LD_INT 3
16430: ST_TO_ADDR
// vc_control := control_apeman ;
16431: LD_ADDR_OWVAR 38
16435: PUSH
16436: LD_INT 5
16438: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
16439: LD_ADDR_OWVAR 40
16443: PUSH
16444: LD_INT 29
16446: ST_TO_ADDR
// un := CreateVehicle ;
16447: LD_ADDR_VAR 0 2
16451: PUSH
16452: CALL_OW 45
16456: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
16457: LD_VAR 0 2
16461: PPUSH
16462: LD_INT 1
16464: PPUSH
16465: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
16469: LD_INT 35
16471: PPUSH
16472: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
16476: LD_VAR 0 2
16480: PPUSH
16481: LD_INT 22
16483: PUSH
16484: LD_OWVAR 2
16488: PUSH
16489: EMPTY
16490: LIST
16491: LIST
16492: PPUSH
16493: CALL_OW 69
16497: PPUSH
16498: LD_VAR 0 2
16502: PPUSH
16503: CALL_OW 74
16507: PPUSH
16508: CALL_OW 115
// until IsDead ( un ) ;
16512: LD_VAR 0 2
16516: PPUSH
16517: CALL_OW 301
16521: IFFALSE 16469
// end ;
16523: PPOPN 2
16525: END
// every 0 0$1 trigger StreamModeActive and sStu do
16526: LD_EXP 57
16530: PUSH
16531: LD_EXP 96
16535: AND
16536: IFFALSE 16552
16538: GO 16540
16540: DISABLE
// begin ToLua ( displayStucuk(); ) ;
16541: LD_STRING displayStucuk();
16543: PPUSH
16544: CALL_OW 559
// ResetFog ;
16548: CALL_OW 335
// end ;
16552: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
16553: LD_EXP 57
16557: PUSH
16558: LD_EXP 89
16562: AND
16563: IFFALSE 16704
16565: GO 16567
16567: DISABLE
16568: LD_INT 0
16570: PPUSH
16571: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
16572: LD_ADDR_VAR 0 2
16576: PUSH
16577: LD_INT 22
16579: PUSH
16580: LD_OWVAR 2
16584: PUSH
16585: EMPTY
16586: LIST
16587: LIST
16588: PUSH
16589: LD_INT 21
16591: PUSH
16592: LD_INT 1
16594: PUSH
16595: EMPTY
16596: LIST
16597: LIST
16598: PUSH
16599: EMPTY
16600: LIST
16601: LIST
16602: PPUSH
16603: CALL_OW 69
16607: ST_TO_ADDR
// if not tmp then
16608: LD_VAR 0 2
16612: NOT
16613: IFFALSE 16617
// exit ;
16615: GO 16704
// un := tmp [ rand ( 1 , tmp ) ] ;
16617: LD_ADDR_VAR 0 1
16621: PUSH
16622: LD_VAR 0 2
16626: PUSH
16627: LD_INT 1
16629: PPUSH
16630: LD_VAR 0 2
16634: PPUSH
16635: CALL_OW 12
16639: ARRAY
16640: ST_TO_ADDR
// SetSide ( un , 0 ) ;
16641: LD_VAR 0 1
16645: PPUSH
16646: LD_INT 0
16648: PPUSH
16649: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
16653: LD_VAR 0 1
16657: PPUSH
16658: LD_OWVAR 3
16662: PUSH
16663: LD_VAR 0 1
16667: DIFF
16668: PPUSH
16669: LD_VAR 0 1
16673: PPUSH
16674: CALL_OW 74
16678: PPUSH
16679: CALL_OW 115
// wait ( 0 0$20 ) ;
16683: LD_INT 700
16685: PPUSH
16686: CALL_OW 67
// SetSide ( un , your_side ) ;
16690: LD_VAR 0 1
16694: PPUSH
16695: LD_OWVAR 2
16699: PPUSH
16700: CALL_OW 235
// end ;
16704: PPOPN 2
16706: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
16707: LD_EXP 57
16711: PUSH
16712: LD_EXP 90
16716: AND
16717: IFFALSE 16823
16719: GO 16721
16721: DISABLE
16722: LD_INT 0
16724: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
16725: LD_ADDR_VAR 0 1
16729: PUSH
16730: LD_INT 22
16732: PUSH
16733: LD_OWVAR 2
16737: PUSH
16738: EMPTY
16739: LIST
16740: LIST
16741: PUSH
16742: LD_INT 2
16744: PUSH
16745: LD_INT 30
16747: PUSH
16748: LD_INT 0
16750: PUSH
16751: EMPTY
16752: LIST
16753: LIST
16754: PUSH
16755: LD_INT 30
16757: PUSH
16758: LD_INT 1
16760: PUSH
16761: EMPTY
16762: LIST
16763: LIST
16764: PUSH
16765: EMPTY
16766: LIST
16767: LIST
16768: LIST
16769: PUSH
16770: EMPTY
16771: LIST
16772: LIST
16773: PPUSH
16774: CALL_OW 69
16778: ST_TO_ADDR
// if not depot then
16779: LD_VAR 0 1
16783: NOT
16784: IFFALSE 16788
// exit ;
16786: GO 16823
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
16788: LD_VAR 0 1
16792: PUSH
16793: LD_INT 1
16795: ARRAY
16796: PPUSH
16797: CALL_OW 250
16801: PPUSH
16802: LD_VAR 0 1
16806: PUSH
16807: LD_INT 1
16809: ARRAY
16810: PPUSH
16811: CALL_OW 251
16815: PPUSH
16816: LD_INT 70
16818: PPUSH
16819: CALL_OW 495
// end ;
16823: PPOPN 1
16825: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
16826: LD_EXP 57
16830: PUSH
16831: LD_EXP 91
16835: AND
16836: IFFALSE 17047
16838: GO 16840
16840: DISABLE
16841: LD_INT 0
16843: PPUSH
16844: PPUSH
16845: PPUSH
16846: PPUSH
16847: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
16848: LD_ADDR_VAR 0 5
16852: PUSH
16853: LD_INT 22
16855: PUSH
16856: LD_OWVAR 2
16860: PUSH
16861: EMPTY
16862: LIST
16863: LIST
16864: PUSH
16865: LD_INT 21
16867: PUSH
16868: LD_INT 1
16870: PUSH
16871: EMPTY
16872: LIST
16873: LIST
16874: PUSH
16875: EMPTY
16876: LIST
16877: LIST
16878: PPUSH
16879: CALL_OW 69
16883: ST_TO_ADDR
// if not tmp then
16884: LD_VAR 0 5
16888: NOT
16889: IFFALSE 16893
// exit ;
16891: GO 17047
// for i in tmp do
16893: LD_ADDR_VAR 0 1
16897: PUSH
16898: LD_VAR 0 5
16902: PUSH
16903: FOR_IN
16904: IFFALSE 17045
// begin d := rand ( 0 , 5 ) ;
16906: LD_ADDR_VAR 0 4
16910: PUSH
16911: LD_INT 0
16913: PPUSH
16914: LD_INT 5
16916: PPUSH
16917: CALL_OW 12
16921: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
16922: LD_ADDR_VAR 0 2
16926: PUSH
16927: LD_VAR 0 1
16931: PPUSH
16932: CALL_OW 250
16936: PPUSH
16937: LD_VAR 0 4
16941: PPUSH
16942: LD_INT 3
16944: PPUSH
16945: LD_INT 12
16947: PPUSH
16948: CALL_OW 12
16952: PPUSH
16953: CALL_OW 272
16957: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
16958: LD_ADDR_VAR 0 3
16962: PUSH
16963: LD_VAR 0 1
16967: PPUSH
16968: CALL_OW 251
16972: PPUSH
16973: LD_VAR 0 4
16977: PPUSH
16978: LD_INT 3
16980: PPUSH
16981: LD_INT 12
16983: PPUSH
16984: CALL_OW 12
16988: PPUSH
16989: CALL_OW 273
16993: ST_TO_ADDR
// if ValidHex ( x , y ) then
16994: LD_VAR 0 2
16998: PPUSH
16999: LD_VAR 0 3
17003: PPUSH
17004: CALL_OW 488
17008: IFFALSE 17043
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
17010: LD_VAR 0 1
17014: PPUSH
17015: LD_VAR 0 2
17019: PPUSH
17020: LD_VAR 0 3
17024: PPUSH
17025: LD_INT 3
17027: PPUSH
17028: LD_INT 6
17030: PPUSH
17031: CALL_OW 12
17035: PPUSH
17036: LD_INT 1
17038: PPUSH
17039: CALL_OW 483
// end ;
17043: GO 16903
17045: POP
17046: POP
// end ;
17047: PPOPN 5
17049: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
17050: LD_EXP 57
17054: PUSH
17055: LD_EXP 92
17059: AND
17060: IFFALSE 17154
17062: GO 17064
17064: DISABLE
17065: LD_INT 0
17067: PPUSH
17068: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
17069: LD_ADDR_VAR 0 2
17073: PUSH
17074: LD_INT 22
17076: PUSH
17077: LD_OWVAR 2
17081: PUSH
17082: EMPTY
17083: LIST
17084: LIST
17085: PUSH
17086: LD_INT 32
17088: PUSH
17089: LD_INT 1
17091: PUSH
17092: EMPTY
17093: LIST
17094: LIST
17095: PUSH
17096: LD_INT 21
17098: PUSH
17099: LD_INT 2
17101: PUSH
17102: EMPTY
17103: LIST
17104: LIST
17105: PUSH
17106: EMPTY
17107: LIST
17108: LIST
17109: LIST
17110: PPUSH
17111: CALL_OW 69
17115: ST_TO_ADDR
// if not tmp then
17116: LD_VAR 0 2
17120: NOT
17121: IFFALSE 17125
// exit ;
17123: GO 17154
// for i in tmp do
17125: LD_ADDR_VAR 0 1
17129: PUSH
17130: LD_VAR 0 2
17134: PUSH
17135: FOR_IN
17136: IFFALSE 17152
// SetFuel ( i , 0 ) ;
17138: LD_VAR 0 1
17142: PPUSH
17143: LD_INT 0
17145: PPUSH
17146: CALL_OW 240
17150: GO 17135
17152: POP
17153: POP
// end ;
17154: PPOPN 2
17156: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
17157: LD_EXP 57
17161: PUSH
17162: LD_EXP 93
17166: AND
17167: IFFALSE 17233
17169: GO 17171
17171: DISABLE
17172: LD_INT 0
17174: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
17175: LD_ADDR_VAR 0 1
17179: PUSH
17180: LD_INT 22
17182: PUSH
17183: LD_OWVAR 2
17187: PUSH
17188: EMPTY
17189: LIST
17190: LIST
17191: PUSH
17192: LD_INT 30
17194: PUSH
17195: LD_INT 29
17197: PUSH
17198: EMPTY
17199: LIST
17200: LIST
17201: PUSH
17202: EMPTY
17203: LIST
17204: LIST
17205: PPUSH
17206: CALL_OW 69
17210: ST_TO_ADDR
// if not tmp then
17211: LD_VAR 0 1
17215: NOT
17216: IFFALSE 17220
// exit ;
17218: GO 17233
// DestroyUnit ( tmp [ 1 ] ) ;
17220: LD_VAR 0 1
17224: PUSH
17225: LD_INT 1
17227: ARRAY
17228: PPUSH
17229: CALL_OW 65
// end ;
17233: PPOPN 1
17235: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
17236: LD_EXP 57
17240: PUSH
17241: LD_EXP 95
17245: AND
17246: IFFALSE 17375
17248: GO 17250
17250: DISABLE
17251: LD_INT 0
17253: PPUSH
// begin uc_side := 0 ;
17254: LD_ADDR_OWVAR 20
17258: PUSH
17259: LD_INT 0
17261: ST_TO_ADDR
// uc_nation := nation_arabian ;
17262: LD_ADDR_OWVAR 21
17266: PUSH
17267: LD_INT 2
17269: ST_TO_ADDR
// hc_gallery :=  ;
17270: LD_ADDR_OWVAR 33
17274: PUSH
17275: LD_STRING 
17277: ST_TO_ADDR
// hc_name :=  ;
17278: LD_ADDR_OWVAR 26
17282: PUSH
17283: LD_STRING 
17285: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
17286: LD_INT 1
17288: PPUSH
17289: LD_INT 11
17291: PPUSH
17292: LD_INT 10
17294: PPUSH
17295: CALL_OW 380
// un := CreateHuman ;
17299: LD_ADDR_VAR 0 1
17303: PUSH
17304: CALL_OW 44
17308: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
17309: LD_VAR 0 1
17313: PPUSH
17314: LD_INT 1
17316: PPUSH
17317: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
17321: LD_INT 35
17323: PPUSH
17324: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
17328: LD_VAR 0 1
17332: PPUSH
17333: LD_INT 22
17335: PUSH
17336: LD_OWVAR 2
17340: PUSH
17341: EMPTY
17342: LIST
17343: LIST
17344: PPUSH
17345: CALL_OW 69
17349: PPUSH
17350: LD_VAR 0 1
17354: PPUSH
17355: CALL_OW 74
17359: PPUSH
17360: CALL_OW 115
// until IsDead ( un ) ;
17364: LD_VAR 0 1
17368: PPUSH
17369: CALL_OW 301
17373: IFFALSE 17321
// end ;
17375: PPOPN 1
17377: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
17378: LD_EXP 57
17382: PUSH
17383: LD_EXP 97
17387: AND
17388: IFFALSE 17400
17390: GO 17392
17392: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
17393: LD_STRING earthquake(getX(game), 0, 32)
17395: PPUSH
17396: CALL_OW 559
17400: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
17401: LD_EXP 57
17405: PUSH
17406: LD_EXP 98
17410: AND
17411: IFFALSE 17502
17413: GO 17415
17415: DISABLE
17416: LD_INT 0
17418: PPUSH
// begin enable ;
17419: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
17420: LD_ADDR_VAR 0 1
17424: PUSH
17425: LD_INT 22
17427: PUSH
17428: LD_OWVAR 2
17432: PUSH
17433: EMPTY
17434: LIST
17435: LIST
17436: PUSH
17437: LD_INT 21
17439: PUSH
17440: LD_INT 2
17442: PUSH
17443: EMPTY
17444: LIST
17445: LIST
17446: PUSH
17447: LD_INT 33
17449: PUSH
17450: LD_INT 3
17452: PUSH
17453: EMPTY
17454: LIST
17455: LIST
17456: PUSH
17457: EMPTY
17458: LIST
17459: LIST
17460: LIST
17461: PPUSH
17462: CALL_OW 69
17466: ST_TO_ADDR
// if not tmp then
17467: LD_VAR 0 1
17471: NOT
17472: IFFALSE 17476
// exit ;
17474: GO 17502
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
17476: LD_VAR 0 1
17480: PUSH
17481: LD_INT 1
17483: PPUSH
17484: LD_VAR 0 1
17488: PPUSH
17489: CALL_OW 12
17493: ARRAY
17494: PPUSH
17495: LD_INT 1
17497: PPUSH
17498: CALL_OW 234
// end ;
17502: PPOPN 1
17504: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
17505: LD_EXP 57
17509: PUSH
17510: LD_EXP 99
17514: AND
17515: IFFALSE 17656
17517: GO 17519
17519: DISABLE
17520: LD_INT 0
17522: PPUSH
17523: PPUSH
17524: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
17525: LD_ADDR_VAR 0 3
17529: PUSH
17530: LD_INT 22
17532: PUSH
17533: LD_OWVAR 2
17537: PUSH
17538: EMPTY
17539: LIST
17540: LIST
17541: PUSH
17542: LD_INT 25
17544: PUSH
17545: LD_INT 1
17547: PUSH
17548: EMPTY
17549: LIST
17550: LIST
17551: PUSH
17552: EMPTY
17553: LIST
17554: LIST
17555: PPUSH
17556: CALL_OW 69
17560: ST_TO_ADDR
// if not tmp then
17561: LD_VAR 0 3
17565: NOT
17566: IFFALSE 17570
// exit ;
17568: GO 17656
// un := tmp [ rand ( 1 , tmp ) ] ;
17570: LD_ADDR_VAR 0 2
17574: PUSH
17575: LD_VAR 0 3
17579: PUSH
17580: LD_INT 1
17582: PPUSH
17583: LD_VAR 0 3
17587: PPUSH
17588: CALL_OW 12
17592: ARRAY
17593: ST_TO_ADDR
// if Crawls ( un ) then
17594: LD_VAR 0 2
17598: PPUSH
17599: CALL_OW 318
17603: IFFALSE 17614
// ComWalk ( un ) ;
17605: LD_VAR 0 2
17609: PPUSH
17610: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
17614: LD_VAR 0 2
17618: PPUSH
17619: LD_INT 9
17621: PPUSH
17622: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
17626: LD_INT 28
17628: PPUSH
17629: LD_OWVAR 2
17633: PPUSH
17634: LD_INT 2
17636: PPUSH
17637: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
17641: LD_INT 29
17643: PPUSH
17644: LD_OWVAR 2
17648: PPUSH
17649: LD_INT 2
17651: PPUSH
17652: CALL_OW 322
// end ;
17656: PPOPN 3
17658: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
17659: LD_EXP 57
17663: PUSH
17664: LD_EXP 100
17668: AND
17669: IFFALSE 17780
17671: GO 17673
17673: DISABLE
17674: LD_INT 0
17676: PPUSH
17677: PPUSH
17678: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
17679: LD_ADDR_VAR 0 3
17683: PUSH
17684: LD_INT 22
17686: PUSH
17687: LD_OWVAR 2
17691: PUSH
17692: EMPTY
17693: LIST
17694: LIST
17695: PUSH
17696: LD_INT 25
17698: PUSH
17699: LD_INT 1
17701: PUSH
17702: EMPTY
17703: LIST
17704: LIST
17705: PUSH
17706: EMPTY
17707: LIST
17708: LIST
17709: PPUSH
17710: CALL_OW 69
17714: ST_TO_ADDR
// if not tmp then
17715: LD_VAR 0 3
17719: NOT
17720: IFFALSE 17724
// exit ;
17722: GO 17780
// un := tmp [ rand ( 1 , tmp ) ] ;
17724: LD_ADDR_VAR 0 2
17728: PUSH
17729: LD_VAR 0 3
17733: PUSH
17734: LD_INT 1
17736: PPUSH
17737: LD_VAR 0 3
17741: PPUSH
17742: CALL_OW 12
17746: ARRAY
17747: ST_TO_ADDR
// if Crawls ( un ) then
17748: LD_VAR 0 2
17752: PPUSH
17753: CALL_OW 318
17757: IFFALSE 17768
// ComWalk ( un ) ;
17759: LD_VAR 0 2
17763: PPUSH
17764: CALL_OW 138
// SetClass ( un , class_mortar ) ;
17768: LD_VAR 0 2
17772: PPUSH
17773: LD_INT 8
17775: PPUSH
17776: CALL_OW 336
// end ;
17780: PPOPN 3
17782: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
17783: LD_EXP 57
17787: PUSH
17788: LD_EXP 101
17792: AND
17793: IFFALSE 17937
17795: GO 17797
17797: DISABLE
17798: LD_INT 0
17800: PPUSH
17801: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
17802: LD_ADDR_VAR 0 2
17806: PUSH
17807: LD_INT 22
17809: PUSH
17810: LD_OWVAR 2
17814: PUSH
17815: EMPTY
17816: LIST
17817: LIST
17818: PUSH
17819: LD_INT 21
17821: PUSH
17822: LD_INT 2
17824: PUSH
17825: EMPTY
17826: LIST
17827: LIST
17828: PUSH
17829: LD_INT 2
17831: PUSH
17832: LD_INT 34
17834: PUSH
17835: LD_INT 12
17837: PUSH
17838: EMPTY
17839: LIST
17840: LIST
17841: PUSH
17842: LD_INT 34
17844: PUSH
17845: LD_INT 51
17847: PUSH
17848: EMPTY
17849: LIST
17850: LIST
17851: PUSH
17852: LD_INT 34
17854: PUSH
17855: LD_INT 32
17857: PUSH
17858: EMPTY
17859: LIST
17860: LIST
17861: PUSH
17862: EMPTY
17863: LIST
17864: LIST
17865: LIST
17866: LIST
17867: PUSH
17868: EMPTY
17869: LIST
17870: LIST
17871: LIST
17872: PPUSH
17873: CALL_OW 69
17877: ST_TO_ADDR
// if not tmp then
17878: LD_VAR 0 2
17882: NOT
17883: IFFALSE 17887
// exit ;
17885: GO 17937
// for i in tmp do
17887: LD_ADDR_VAR 0 1
17891: PUSH
17892: LD_VAR 0 2
17896: PUSH
17897: FOR_IN
17898: IFFALSE 17935
// if GetCargo ( i , mat_artifact ) = 0 then
17900: LD_VAR 0 1
17904: PPUSH
17905: LD_INT 4
17907: PPUSH
17908: CALL_OW 289
17912: PUSH
17913: LD_INT 0
17915: EQUAL
17916: IFFALSE 17933
// SetCargo ( i , mat_siberit , 100 ) ;
17918: LD_VAR 0 1
17922: PPUSH
17923: LD_INT 3
17925: PPUSH
17926: LD_INT 100
17928: PPUSH
17929: CALL_OW 290
17933: GO 17897
17935: POP
17936: POP
// end ;
17937: PPOPN 2
17939: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
17940: LD_EXP 57
17944: PUSH
17945: LD_EXP 102
17949: AND
17950: IFFALSE 18103
17952: GO 17954
17954: DISABLE
17955: LD_INT 0
17957: PPUSH
17958: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
17959: LD_ADDR_VAR 0 2
17963: PUSH
17964: LD_INT 22
17966: PUSH
17967: LD_OWVAR 2
17971: PUSH
17972: EMPTY
17973: LIST
17974: LIST
17975: PPUSH
17976: CALL_OW 69
17980: ST_TO_ADDR
// if not tmp then
17981: LD_VAR 0 2
17985: NOT
17986: IFFALSE 17990
// exit ;
17988: GO 18103
// for i := 1 to 2 do
17990: LD_ADDR_VAR 0 1
17994: PUSH
17995: DOUBLE
17996: LD_INT 1
17998: DEC
17999: ST_TO_ADDR
18000: LD_INT 2
18002: PUSH
18003: FOR_TO
18004: IFFALSE 18101
// begin uc_side := your_side ;
18006: LD_ADDR_OWVAR 20
18010: PUSH
18011: LD_OWVAR 2
18015: ST_TO_ADDR
// uc_nation := nation_american ;
18016: LD_ADDR_OWVAR 21
18020: PUSH
18021: LD_INT 1
18023: ST_TO_ADDR
// vc_chassis := us_morphling ;
18024: LD_ADDR_OWVAR 37
18028: PUSH
18029: LD_INT 5
18031: ST_TO_ADDR
// vc_engine := engine_siberite ;
18032: LD_ADDR_OWVAR 39
18036: PUSH
18037: LD_INT 3
18039: ST_TO_ADDR
// vc_control := control_computer ;
18040: LD_ADDR_OWVAR 38
18044: PUSH
18045: LD_INT 3
18047: ST_TO_ADDR
// vc_weapon := us_double_laser ;
18048: LD_ADDR_OWVAR 40
18052: PUSH
18053: LD_INT 10
18055: ST_TO_ADDR
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) ;
18056: CALL_OW 45
18060: PPUSH
18061: LD_VAR 0 2
18065: PUSH
18066: LD_INT 1
18068: ARRAY
18069: PPUSH
18070: CALL_OW 250
18074: PPUSH
18075: LD_VAR 0 2
18079: PUSH
18080: LD_INT 1
18082: ARRAY
18083: PPUSH
18084: CALL_OW 251
18088: PPUSH
18089: LD_INT 12
18091: PPUSH
18092: LD_INT 1
18094: PPUSH
18095: CALL_OW 50
// end ;
18099: GO 18003
18101: POP
18102: POP
// end ;
18103: PPOPN 2
18105: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
18106: LD_EXP 57
18110: PUSH
18111: LD_EXP 103
18115: AND
18116: IFFALSE 18338
18118: GO 18120
18120: DISABLE
18121: LD_INT 0
18123: PPUSH
18124: PPUSH
18125: PPUSH
18126: PPUSH
18127: PPUSH
18128: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
18129: LD_ADDR_VAR 0 6
18133: PUSH
18134: LD_INT 22
18136: PUSH
18137: LD_OWVAR 2
18141: PUSH
18142: EMPTY
18143: LIST
18144: LIST
18145: PUSH
18146: LD_INT 21
18148: PUSH
18149: LD_INT 1
18151: PUSH
18152: EMPTY
18153: LIST
18154: LIST
18155: PUSH
18156: LD_INT 3
18158: PUSH
18159: LD_INT 23
18161: PUSH
18162: LD_INT 0
18164: PUSH
18165: EMPTY
18166: LIST
18167: LIST
18168: PUSH
18169: EMPTY
18170: LIST
18171: LIST
18172: PUSH
18173: EMPTY
18174: LIST
18175: LIST
18176: LIST
18177: PPUSH
18178: CALL_OW 69
18182: ST_TO_ADDR
// if not tmp then
18183: LD_VAR 0 6
18187: NOT
18188: IFFALSE 18192
// exit ;
18190: GO 18338
// s1 := rand ( 1 , 4 ) ;
18192: LD_ADDR_VAR 0 2
18196: PUSH
18197: LD_INT 1
18199: PPUSH
18200: LD_INT 4
18202: PPUSH
18203: CALL_OW 12
18207: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
18208: LD_ADDR_VAR 0 4
18212: PUSH
18213: LD_VAR 0 6
18217: PUSH
18218: LD_INT 1
18220: ARRAY
18221: PPUSH
18222: LD_VAR 0 2
18226: PPUSH
18227: CALL_OW 259
18231: ST_TO_ADDR
// if s1 = 1 then
18232: LD_VAR 0 2
18236: PUSH
18237: LD_INT 1
18239: EQUAL
18240: IFFALSE 18260
// s2 := rand ( 2 , 4 ) else
18242: LD_ADDR_VAR 0 3
18246: PUSH
18247: LD_INT 2
18249: PPUSH
18250: LD_INT 4
18252: PPUSH
18253: CALL_OW 12
18257: ST_TO_ADDR
18258: GO 18268
// s2 := 1 ;
18260: LD_ADDR_VAR 0 3
18264: PUSH
18265: LD_INT 1
18267: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
18268: LD_ADDR_VAR 0 5
18272: PUSH
18273: LD_VAR 0 6
18277: PUSH
18278: LD_INT 1
18280: ARRAY
18281: PPUSH
18282: LD_VAR 0 3
18286: PPUSH
18287: CALL_OW 259
18291: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
18292: LD_VAR 0 6
18296: PUSH
18297: LD_INT 1
18299: ARRAY
18300: PPUSH
18301: LD_VAR 0 2
18305: PPUSH
18306: LD_VAR 0 5
18310: PPUSH
18311: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
18315: LD_VAR 0 6
18319: PUSH
18320: LD_INT 1
18322: ARRAY
18323: PPUSH
18324: LD_VAR 0 3
18328: PPUSH
18329: LD_VAR 0 4
18333: PPUSH
18334: CALL_OW 237
// end ;
18338: PPOPN 6
18340: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
18341: LD_EXP 57
18345: PUSH
18346: LD_EXP 104
18350: AND
18351: IFFALSE 18430
18353: GO 18355
18355: DISABLE
18356: LD_INT 0
18358: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
18359: LD_ADDR_VAR 0 1
18363: PUSH
18364: LD_INT 22
18366: PUSH
18367: LD_OWVAR 2
18371: PUSH
18372: EMPTY
18373: LIST
18374: LIST
18375: PUSH
18376: LD_INT 30
18378: PUSH
18379: LD_INT 3
18381: PUSH
18382: EMPTY
18383: LIST
18384: LIST
18385: PUSH
18386: EMPTY
18387: LIST
18388: LIST
18389: PPUSH
18390: CALL_OW 69
18394: ST_TO_ADDR
// if not tmp then
18395: LD_VAR 0 1
18399: NOT
18400: IFFALSE 18404
// exit ;
18402: GO 18430
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
18404: LD_VAR 0 1
18408: PUSH
18409: LD_INT 1
18411: PPUSH
18412: LD_VAR 0 1
18416: PPUSH
18417: CALL_OW 12
18421: ARRAY
18422: PPUSH
18423: LD_INT 1
18425: PPUSH
18426: CALL_OW 234
// end ;
18430: PPOPN 1
18432: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
18433: LD_EXP 57
18437: PUSH
18438: LD_EXP 105
18442: AND
18443: IFFALSE 18555
18445: GO 18447
18447: DISABLE
18448: LD_INT 0
18450: PPUSH
18451: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
18452: LD_ADDR_VAR 0 2
18456: PUSH
18457: LD_INT 22
18459: PUSH
18460: LD_OWVAR 2
18464: PUSH
18465: EMPTY
18466: LIST
18467: LIST
18468: PUSH
18469: LD_INT 2
18471: PUSH
18472: LD_INT 30
18474: PUSH
18475: LD_INT 27
18477: PUSH
18478: EMPTY
18479: LIST
18480: LIST
18481: PUSH
18482: LD_INT 30
18484: PUSH
18485: LD_INT 26
18487: PUSH
18488: EMPTY
18489: LIST
18490: LIST
18491: PUSH
18492: LD_INT 30
18494: PUSH
18495: LD_INT 28
18497: PUSH
18498: EMPTY
18499: LIST
18500: LIST
18501: PUSH
18502: EMPTY
18503: LIST
18504: LIST
18505: LIST
18506: LIST
18507: PUSH
18508: EMPTY
18509: LIST
18510: LIST
18511: PPUSH
18512: CALL_OW 69
18516: ST_TO_ADDR
// if not tmp then
18517: LD_VAR 0 2
18521: NOT
18522: IFFALSE 18526
// exit ;
18524: GO 18555
// for i in tmp do
18526: LD_ADDR_VAR 0 1
18530: PUSH
18531: LD_VAR 0 2
18535: PUSH
18536: FOR_IN
18537: IFFALSE 18553
// SetLives ( i , 1 ) ;
18539: LD_VAR 0 1
18543: PPUSH
18544: LD_INT 1
18546: PPUSH
18547: CALL_OW 234
18551: GO 18536
18553: POP
18554: POP
// end ;
18555: PPOPN 2
18557: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
18558: LD_EXP 57
18562: PUSH
18563: LD_EXP 106
18567: AND
18568: IFFALSE 18842
18570: GO 18572
18572: DISABLE
18573: LD_INT 0
18575: PPUSH
18576: PPUSH
18577: PPUSH
// begin i := rand ( 1 , 7 ) ;
18578: LD_ADDR_VAR 0 1
18582: PUSH
18583: LD_INT 1
18585: PPUSH
18586: LD_INT 7
18588: PPUSH
18589: CALL_OW 12
18593: ST_TO_ADDR
// case i of 1 :
18594: LD_VAR 0 1
18598: PUSH
18599: LD_INT 1
18601: DOUBLE
18602: EQUAL
18603: IFTRUE 18607
18605: GO 18617
18607: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
18608: LD_STRING earthquake(getX(game), 0, 32)
18610: PPUSH
18611: CALL_OW 559
18615: GO 18842
18617: LD_INT 2
18619: DOUBLE
18620: EQUAL
18621: IFTRUE 18625
18623: GO 18639
18625: POP
// begin ToLua ( displayStucuk(); ) ;
18626: LD_STRING displayStucuk();
18628: PPUSH
18629: CALL_OW 559
// ResetFog ;
18633: CALL_OW 335
// end ; 3 :
18637: GO 18842
18639: LD_INT 3
18641: DOUBLE
18642: EQUAL
18643: IFTRUE 18647
18645: GO 18751
18647: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
18648: LD_ADDR_VAR 0 2
18652: PUSH
18653: LD_INT 22
18655: PUSH
18656: LD_OWVAR 2
18660: PUSH
18661: EMPTY
18662: LIST
18663: LIST
18664: PUSH
18665: LD_INT 25
18667: PUSH
18668: LD_INT 1
18670: PUSH
18671: EMPTY
18672: LIST
18673: LIST
18674: PUSH
18675: EMPTY
18676: LIST
18677: LIST
18678: PPUSH
18679: CALL_OW 69
18683: ST_TO_ADDR
// if not tmp then
18684: LD_VAR 0 2
18688: NOT
18689: IFFALSE 18693
// exit ;
18691: GO 18842
// un := tmp [ rand ( 1 , tmp ) ] ;
18693: LD_ADDR_VAR 0 3
18697: PUSH
18698: LD_VAR 0 2
18702: PUSH
18703: LD_INT 1
18705: PPUSH
18706: LD_VAR 0 2
18710: PPUSH
18711: CALL_OW 12
18715: ARRAY
18716: ST_TO_ADDR
// if Crawls ( un ) then
18717: LD_VAR 0 3
18721: PPUSH
18722: CALL_OW 318
18726: IFFALSE 18737
// ComWalk ( un ) ;
18728: LD_VAR 0 3
18732: PPUSH
18733: CALL_OW 138
// SetClass ( un , class_mortar ) ;
18737: LD_VAR 0 3
18741: PPUSH
18742: LD_INT 8
18744: PPUSH
18745: CALL_OW 336
// end ; 4 :
18749: GO 18842
18751: LD_INT 4
18753: DOUBLE
18754: EQUAL
18755: IFTRUE 18759
18757: GO 18820
18759: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
18760: LD_ADDR_VAR 0 2
18764: PUSH
18765: LD_INT 22
18767: PUSH
18768: LD_OWVAR 2
18772: PUSH
18773: EMPTY
18774: LIST
18775: LIST
18776: PUSH
18777: LD_INT 30
18779: PUSH
18780: LD_INT 29
18782: PUSH
18783: EMPTY
18784: LIST
18785: LIST
18786: PUSH
18787: EMPTY
18788: LIST
18789: LIST
18790: PPUSH
18791: CALL_OW 69
18795: ST_TO_ADDR
// if not tmp then
18796: LD_VAR 0 2
18800: NOT
18801: IFFALSE 18805
// exit ;
18803: GO 18842
// DestroyUnit ( tmp [ 1 ] ) ;
18805: LD_VAR 0 2
18809: PUSH
18810: LD_INT 1
18812: ARRAY
18813: PPUSH
18814: CALL_OW 65
// end ; 5 .. 7 :
18818: GO 18842
18820: LD_INT 5
18822: DOUBLE
18823: GREATEREQUAL
18824: IFFALSE 18832
18826: LD_INT 7
18828: DOUBLE
18829: LESSEQUAL
18830: IFTRUE 18834
18832: GO 18841
18834: POP
// StreamSibBomb ; end ;
18835: CALL 15122 0 0
18839: GO 18842
18841: POP
// end ;
18842: PPOPN 3
18844: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
18845: LD_EXP 57
18849: PUSH
18850: LD_EXP 107
18854: AND
18855: IFFALSE 19011
18857: GO 18859
18859: DISABLE
18860: LD_INT 0
18862: PPUSH
18863: PPUSH
18864: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
18865: LD_ADDR_VAR 0 2
18869: PUSH
18870: LD_INT 81
18872: PUSH
18873: LD_OWVAR 2
18877: PUSH
18878: EMPTY
18879: LIST
18880: LIST
18881: PUSH
18882: LD_INT 2
18884: PUSH
18885: LD_INT 21
18887: PUSH
18888: LD_INT 1
18890: PUSH
18891: EMPTY
18892: LIST
18893: LIST
18894: PUSH
18895: LD_INT 21
18897: PUSH
18898: LD_INT 2
18900: PUSH
18901: EMPTY
18902: LIST
18903: LIST
18904: PUSH
18905: EMPTY
18906: LIST
18907: LIST
18908: LIST
18909: PUSH
18910: EMPTY
18911: LIST
18912: LIST
18913: PPUSH
18914: CALL_OW 69
18918: ST_TO_ADDR
// if not tmp then
18919: LD_VAR 0 2
18923: NOT
18924: IFFALSE 18928
// exit ;
18926: GO 19011
// p := 0 ;
18928: LD_ADDR_VAR 0 3
18932: PUSH
18933: LD_INT 0
18935: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
18936: LD_INT 35
18938: PPUSH
18939: CALL_OW 67
// p := p + 1 ;
18943: LD_ADDR_VAR 0 3
18947: PUSH
18948: LD_VAR 0 3
18952: PUSH
18953: LD_INT 1
18955: PLUS
18956: ST_TO_ADDR
// for i in tmp do
18957: LD_ADDR_VAR 0 1
18961: PUSH
18962: LD_VAR 0 2
18966: PUSH
18967: FOR_IN
18968: IFFALSE 18999
// if GetLives ( i ) < 1000 then
18970: LD_VAR 0 1
18974: PPUSH
18975: CALL_OW 256
18979: PUSH
18980: LD_INT 1000
18982: LESS
18983: IFFALSE 18997
// SetLives ( i , 1000 ) ;
18985: LD_VAR 0 1
18989: PPUSH
18990: LD_INT 1000
18992: PPUSH
18993: CALL_OW 234
18997: GO 18967
18999: POP
19000: POP
// until p > 20 ;
19001: LD_VAR 0 3
19005: PUSH
19006: LD_INT 20
19008: GREATER
19009: IFFALSE 18936
// end ;
19011: PPOPN 3
19013: END
// every 0 0$1 trigger StreamModeActive and sTime do
19014: LD_EXP 57
19018: PUSH
19019: LD_EXP 108
19023: AND
19024: IFFALSE 19059
19026: GO 19028
19028: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
19029: LD_INT 28
19031: PPUSH
19032: LD_OWVAR 2
19036: PPUSH
19037: LD_INT 2
19039: PPUSH
19040: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
19044: LD_INT 30
19046: PPUSH
19047: LD_OWVAR 2
19051: PPUSH
19052: LD_INT 2
19054: PPUSH
19055: CALL_OW 322
// end ;
19059: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
19060: LD_EXP 57
19064: PUSH
19065: LD_EXP 109
19069: AND
19070: IFFALSE 19191
19072: GO 19074
19074: DISABLE
19075: LD_INT 0
19077: PPUSH
19078: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
19079: LD_ADDR_VAR 0 2
19083: PUSH
19084: LD_INT 22
19086: PUSH
19087: LD_OWVAR 2
19091: PUSH
19092: EMPTY
19093: LIST
19094: LIST
19095: PUSH
19096: LD_INT 21
19098: PUSH
19099: LD_INT 1
19101: PUSH
19102: EMPTY
19103: LIST
19104: LIST
19105: PUSH
19106: LD_INT 3
19108: PUSH
19109: LD_INT 23
19111: PUSH
19112: LD_INT 0
19114: PUSH
19115: EMPTY
19116: LIST
19117: LIST
19118: PUSH
19119: EMPTY
19120: LIST
19121: LIST
19122: PUSH
19123: EMPTY
19124: LIST
19125: LIST
19126: LIST
19127: PPUSH
19128: CALL_OW 69
19132: ST_TO_ADDR
// if not tmp then
19133: LD_VAR 0 2
19137: NOT
19138: IFFALSE 19142
// exit ;
19140: GO 19191
// for i in tmp do
19142: LD_ADDR_VAR 0 1
19146: PUSH
19147: LD_VAR 0 2
19151: PUSH
19152: FOR_IN
19153: IFFALSE 19189
// begin if Crawls ( i ) then
19155: LD_VAR 0 1
19159: PPUSH
19160: CALL_OW 318
19164: IFFALSE 19175
// ComWalk ( i ) ;
19166: LD_VAR 0 1
19170: PPUSH
19171: CALL_OW 138
// SetClass ( i , 2 ) ;
19175: LD_VAR 0 1
19179: PPUSH
19180: LD_INT 2
19182: PPUSH
19183: CALL_OW 336
// end ;
19187: GO 19152
19189: POP
19190: POP
// end ;
19191: PPOPN 2
19193: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
19194: LD_EXP 57
19198: PUSH
19199: LD_EXP 110
19203: AND
19204: IFFALSE 19485
19206: GO 19208
19208: DISABLE
19209: LD_INT 0
19211: PPUSH
19212: PPUSH
19213: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
19214: LD_OWVAR 2
19218: PPUSH
19219: LD_INT 9
19221: PPUSH
19222: LD_INT 1
19224: PPUSH
19225: LD_INT 1
19227: PPUSH
19228: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
19232: LD_INT 9
19234: PPUSH
19235: LD_OWVAR 2
19239: PPUSH
19240: CALL_OW 343
// uc_side := 9 ;
19244: LD_ADDR_OWVAR 20
19248: PUSH
19249: LD_INT 9
19251: ST_TO_ADDR
// uc_nation := 2 ;
19252: LD_ADDR_OWVAR 21
19256: PUSH
19257: LD_INT 2
19259: ST_TO_ADDR
// hc_name := Dark Warrior ;
19260: LD_ADDR_OWVAR 26
19264: PUSH
19265: LD_STRING Dark Warrior
19267: ST_TO_ADDR
// hc_gallery :=  ;
19268: LD_ADDR_OWVAR 33
19272: PUSH
19273: LD_STRING 
19275: ST_TO_ADDR
// hc_noskilllimit := true ;
19276: LD_ADDR_OWVAR 76
19280: PUSH
19281: LD_INT 1
19283: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
19284: LD_ADDR_OWVAR 31
19288: PUSH
19289: LD_INT 30
19291: PUSH
19292: LD_INT 30
19294: PUSH
19295: LD_INT 30
19297: PUSH
19298: LD_INT 30
19300: PUSH
19301: EMPTY
19302: LIST
19303: LIST
19304: LIST
19305: LIST
19306: ST_TO_ADDR
// un := CreateHuman ;
19307: LD_ADDR_VAR 0 3
19311: PUSH
19312: CALL_OW 44
19316: ST_TO_ADDR
// hc_noskilllimit := false ;
19317: LD_ADDR_OWVAR 76
19321: PUSH
19322: LD_INT 0
19324: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
19325: LD_VAR 0 3
19329: PPUSH
19330: LD_INT 1
19332: PPUSH
19333: CALL_OW 51
// p := 0 ;
19337: LD_ADDR_VAR 0 2
19341: PUSH
19342: LD_INT 0
19344: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
19345: LD_INT 35
19347: PPUSH
19348: CALL_OW 67
// p := p + 1 ;
19352: LD_ADDR_VAR 0 2
19356: PUSH
19357: LD_VAR 0 2
19361: PUSH
19362: LD_INT 1
19364: PLUS
19365: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
19366: LD_VAR 0 3
19370: PPUSH
19371: CALL_OW 256
19375: PUSH
19376: LD_INT 1000
19378: LESS
19379: IFFALSE 19393
// SetLives ( un , 1000 ) ;
19381: LD_VAR 0 3
19385: PPUSH
19386: LD_INT 1000
19388: PPUSH
19389: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
19393: LD_VAR 0 3
19397: PPUSH
19398: LD_INT 81
19400: PUSH
19401: LD_OWVAR 2
19405: PUSH
19406: EMPTY
19407: LIST
19408: LIST
19409: PUSH
19410: LD_INT 91
19412: PUSH
19413: LD_VAR 0 3
19417: PUSH
19418: LD_INT 30
19420: PUSH
19421: EMPTY
19422: LIST
19423: LIST
19424: LIST
19425: PUSH
19426: EMPTY
19427: LIST
19428: LIST
19429: PPUSH
19430: CALL_OW 69
19434: PPUSH
19435: LD_VAR 0 3
19439: PPUSH
19440: CALL_OW 74
19444: PPUSH
19445: CALL_OW 115
// until p > 60 or IsDead ( un ) ;
19449: LD_VAR 0 2
19453: PUSH
19454: LD_INT 60
19456: GREATER
19457: PUSH
19458: LD_VAR 0 3
19462: PPUSH
19463: CALL_OW 301
19467: OR
19468: IFFALSE 19345
// if un then
19470: LD_VAR 0 3
19474: IFFALSE 19485
// RemoveUnit ( un ) ;
19476: LD_VAR 0 3
19480: PPUSH
19481: CALL_OW 64
// end ; end_of_file
19485: PPOPN 3
19487: END
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
19488: LD_INT 0
19490: PPUSH
19491: PPUSH
19492: PPUSH
19493: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
19494: LD_VAR 0 1
19498: PPUSH
19499: CALL_OW 264
19503: PUSH
19504: LD_EXP 56
19508: EQUAL
19509: IFFALSE 19581
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
19511: LD_INT 68
19513: PPUSH
19514: LD_VAR 0 1
19518: PPUSH
19519: CALL_OW 255
19523: PPUSH
19524: CALL_OW 321
19528: PUSH
19529: LD_INT 2
19531: EQUAL
19532: IFFALSE 19544
// eff := 70 else
19534: LD_ADDR_VAR 0 4
19538: PUSH
19539: LD_INT 70
19541: ST_TO_ADDR
19542: GO 19552
// eff := 30 ;
19544: LD_ADDR_VAR 0 4
19548: PUSH
19549: LD_INT 30
19551: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
19552: LD_VAR 0 1
19556: PPUSH
19557: CALL_OW 250
19561: PPUSH
19562: LD_VAR 0 1
19566: PPUSH
19567: CALL_OW 251
19571: PPUSH
19572: LD_VAR 0 4
19576: PPUSH
19577: CALL_OW 495
// end ; end ;
19581: LD_VAR 0 2
19585: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
19586: LD_INT 0
19588: PPUSH
// end ;
19589: LD_VAR 0 4
19593: RET
// export function SOS_Command ( cmd ) ; begin
19594: LD_INT 0
19596: PPUSH
// end ;
19597: LD_VAR 0 2
19601: RET
// on TargetableSAIL ( cmd , unit , selectedunit , x , y ) do begin if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
19602: LD_VAR 0 1
19606: PUSH
19607: LD_INT 255
19609: EQUAL
19610: PUSH
19611: LD_VAR 0 2
19615: PPUSH
19616: CALL_OW 264
19620: PUSH
19621: LD_INT 14
19623: PUSH
19624: LD_INT 53
19626: PUSH
19627: EMPTY
19628: LIST
19629: LIST
19630: IN
19631: AND
19632: PUSH
19633: LD_VAR 0 4
19637: PPUSH
19638: LD_VAR 0 5
19642: PPUSH
19643: CALL_OW 488
19647: AND
19648: IFFALSE 19672
// CutTreeXYR ( unit , x , y , 12 ) ;
19650: LD_VAR 0 2
19654: PPUSH
19655: LD_VAR 0 4
19659: PPUSH
19660: LD_VAR 0 5
19664: PPUSH
19665: LD_INT 12
19667: PPUSH
19668: CALL 19675 0 4
// end ;
19672: PPOPN 5
19674: END
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
19675: LD_INT 0
19677: PPUSH
19678: PPUSH
19679: PPUSH
19680: PPUSH
19681: PPUSH
19682: PPUSH
19683: PPUSH
19684: PPUSH
19685: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
19686: LD_VAR 0 1
19690: NOT
19691: PUSH
19692: LD_VAR 0 2
19696: PPUSH
19697: LD_VAR 0 3
19701: PPUSH
19702: CALL_OW 488
19706: NOT
19707: OR
19708: PUSH
19709: LD_VAR 0 4
19713: NOT
19714: OR
19715: IFFALSE 19719
// exit ;
19717: GO 20059
// list := [ ] ;
19719: LD_ADDR_VAR 0 13
19723: PUSH
19724: EMPTY
19725: ST_TO_ADDR
// if x - r < 0 then
19726: LD_VAR 0 2
19730: PUSH
19731: LD_VAR 0 4
19735: MINUS
19736: PUSH
19737: LD_INT 0
19739: LESS
19740: IFFALSE 19752
// min_x := 0 else
19742: LD_ADDR_VAR 0 7
19746: PUSH
19747: LD_INT 0
19749: ST_TO_ADDR
19750: GO 19768
// min_x := x - r ;
19752: LD_ADDR_VAR 0 7
19756: PUSH
19757: LD_VAR 0 2
19761: PUSH
19762: LD_VAR 0 4
19766: MINUS
19767: ST_TO_ADDR
// if y - r < 0 then
19768: LD_VAR 0 3
19772: PUSH
19773: LD_VAR 0 4
19777: MINUS
19778: PUSH
19779: LD_INT 0
19781: LESS
19782: IFFALSE 19794
// min_y := 0 else
19784: LD_ADDR_VAR 0 8
19788: PUSH
19789: LD_INT 0
19791: ST_TO_ADDR
19792: GO 19810
// min_y := y - r ;
19794: LD_ADDR_VAR 0 8
19798: PUSH
19799: LD_VAR 0 3
19803: PUSH
19804: LD_VAR 0 4
19808: MINUS
19809: ST_TO_ADDR
// max_x := x + r ;
19810: LD_ADDR_VAR 0 9
19814: PUSH
19815: LD_VAR 0 2
19819: PUSH
19820: LD_VAR 0 4
19824: PLUS
19825: ST_TO_ADDR
// max_y := y + r ;
19826: LD_ADDR_VAR 0 10
19830: PUSH
19831: LD_VAR 0 3
19835: PUSH
19836: LD_VAR 0 4
19840: PLUS
19841: ST_TO_ADDR
// for _x = min_x to max_x do
19842: LD_ADDR_VAR 0 11
19846: PUSH
19847: DOUBLE
19848: LD_VAR 0 7
19852: DEC
19853: ST_TO_ADDR
19854: LD_VAR 0 9
19858: PUSH
19859: FOR_TO
19860: IFFALSE 19977
// for _y = min_y to max_y do
19862: LD_ADDR_VAR 0 12
19866: PUSH
19867: DOUBLE
19868: LD_VAR 0 8
19872: DEC
19873: ST_TO_ADDR
19874: LD_VAR 0 10
19878: PUSH
19879: FOR_TO
19880: IFFALSE 19973
// begin if not ValidHex ( _x , _y ) then
19882: LD_VAR 0 11
19886: PPUSH
19887: LD_VAR 0 12
19891: PPUSH
19892: CALL_OW 488
19896: NOT
19897: IFFALSE 19901
// continue ;
19899: GO 19879
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
19901: LD_VAR 0 11
19905: PPUSH
19906: LD_VAR 0 12
19910: PPUSH
19911: CALL_OW 351
19915: PUSH
19916: LD_VAR 0 11
19920: PPUSH
19921: LD_VAR 0 12
19925: PPUSH
19926: CALL_OW 554
19930: AND
19931: IFFALSE 19971
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
19933: LD_ADDR_VAR 0 13
19937: PUSH
19938: LD_VAR 0 13
19942: PPUSH
19943: LD_VAR 0 13
19947: PUSH
19948: LD_INT 1
19950: PLUS
19951: PPUSH
19952: LD_VAR 0 11
19956: PUSH
19957: LD_VAR 0 12
19961: PUSH
19962: EMPTY
19963: LIST
19964: LIST
19965: PPUSH
19966: CALL_OW 2
19970: ST_TO_ADDR
// end ;
19971: GO 19879
19973: POP
19974: POP
19975: GO 19859
19977: POP
19978: POP
// if not list then
19979: LD_VAR 0 13
19983: NOT
19984: IFFALSE 19988
// exit ;
19986: GO 20059
// for i in list do
19988: LD_ADDR_VAR 0 6
19992: PUSH
19993: LD_VAR 0 13
19997: PUSH
19998: FOR_IN
19999: IFFALSE 20057
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
20001: LD_VAR 0 1
20005: PPUSH
20006: LD_STRING M
20008: PUSH
20009: LD_VAR 0 6
20013: PUSH
20014: LD_INT 1
20016: ARRAY
20017: PUSH
20018: LD_VAR 0 6
20022: PUSH
20023: LD_INT 2
20025: ARRAY
20026: PUSH
20027: LD_INT 0
20029: PUSH
20030: LD_INT 0
20032: PUSH
20033: LD_INT 0
20035: PUSH
20036: LD_INT 0
20038: PUSH
20039: EMPTY
20040: LIST
20041: LIST
20042: LIST
20043: LIST
20044: LIST
20045: LIST
20046: LIST
20047: PUSH
20048: EMPTY
20049: LIST
20050: PPUSH
20051: CALL_OW 447
20055: GO 19998
20057: POP
20058: POP
// end ;
20059: LD_VAR 0 5
20063: RET
