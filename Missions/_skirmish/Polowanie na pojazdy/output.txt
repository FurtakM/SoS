// starting begin ResetFog ;
   0: CALL_OW 335
// PrepareGame ;
   4: CALL 13 0 0
// PrepareUnits ;
   8: CALL 463 0 0
// end ;
  12: END
// export mechanics , time_to_destroy , players , sib_bomb , time , veh_amount ; export p1 , p2 , p3 , p4 , p5 ; function PrepareGame ; var debug , i ; begin
  13: LD_INT 0
  15: PPUSH
  16: PPUSH
  17: PPUSH
// debug := false ;
  18: LD_ADDR_VAR 0 2
  22: PUSH
  23: LD_INT 0
  25: ST_TO_ADDR
// if debug then
  26: LD_VAR 0 2
  30: IFFALSE 81
// begin mechanics := 5 ;
  32: LD_ADDR_EXP 1
  36: PUSH
  37: LD_INT 5
  39: ST_TO_ADDR
// time_to_destroy := 45 ;
  40: LD_ADDR_EXP 2
  44: PUSH
  45: LD_INT 45
  47: ST_TO_ADDR
// players := 4 ;
  48: LD_ADDR_EXP 3
  52: PUSH
  53: LD_INT 4
  55: ST_TO_ADDR
// sib_bomb := true ;
  56: LD_ADDR_EXP 4
  60: PUSH
  61: LD_INT 1
  63: ST_TO_ADDR
// time := 3 3$00 ;
  64: LD_ADDR_EXP 5
  68: PUSH
  69: LD_INT 6300
  71: ST_TO_ADDR
// FogOff ( 1 ) ;
  72: LD_INT 1
  74: PPUSH
  75: CALL_OW 344
// end else
  79: GO 378
// begin time := 3 3$00 ;
  81: LD_ADDR_EXP 5
  85: PUSH
  86: LD_INT 6300
  88: ST_TO_ADDR
// players := 4 ;
  89: LD_ADDR_EXP 3
  93: PUSH
  94: LD_INT 4
  96: ST_TO_ADDR
// sib_bomb := true ;
  97: LD_ADDR_EXP 4
 101: PUSH
 102: LD_INT 1
 104: ST_TO_ADDR
// mechanics := 4 ;
 105: LD_ADDR_EXP 1
 109: PUSH
 110: LD_INT 4
 112: ST_TO_ADDR
// case Query ( QWel ) of 1 :
 113: LD_STRING QWel
 115: PPUSH
 116: CALL_OW 97
 120: PUSH
 121: LD_INT 1
 123: DOUBLE
 124: EQUAL
 125: IFTRUE 129
 127: GO 132
 129: POP
// ; end ;
 130: GO 133
 132: POP
// case Query ( QMechanis ) of 1 :
 133: LD_STRING QMechanis
 135: PPUSH
 136: CALL_OW 97
 140: PUSH
 141: LD_INT 1
 143: DOUBLE
 144: EQUAL
 145: IFTRUE 149
 147: GO 160
 149: POP
// mechanics := 3 ; 2 :
 150: LD_ADDR_EXP 1
 154: PUSH
 155: LD_INT 3
 157: ST_TO_ADDR
 158: GO 199
 160: LD_INT 2
 162: DOUBLE
 163: EQUAL
 164: IFTRUE 168
 166: GO 179
 168: POP
// mechanics := 4 ; 3 :
 169: LD_ADDR_EXP 1
 173: PUSH
 174: LD_INT 4
 176: ST_TO_ADDR
 177: GO 199
 179: LD_INT 3
 181: DOUBLE
 182: EQUAL
 183: IFTRUE 187
 185: GO 198
 187: POP
// mechanics := 5 ; end ;
 188: LD_ADDR_EXP 1
 192: PUSH
 193: LD_INT 5
 195: ST_TO_ADDR
 196: GO 199
 198: POP
// case Query ( QPlayers ) of 1 :
 199: LD_STRING QPlayers
 201: PPUSH
 202: CALL_OW 97
 206: PUSH
 207: LD_INT 1
 209: DOUBLE
 210: EQUAL
 211: IFTRUE 215
 213: GO 226
 215: POP
// players := 3 ; 2 :
 216: LD_ADDR_EXP 3
 220: PUSH
 221: LD_INT 3
 223: ST_TO_ADDR
 224: GO 265
 226: LD_INT 2
 228: DOUBLE
 229: EQUAL
 230: IFTRUE 234
 232: GO 245
 234: POP
// players := 4 ; 3 :
 235: LD_ADDR_EXP 3
 239: PUSH
 240: LD_INT 4
 242: ST_TO_ADDR
 243: GO 265
 245: LD_INT 3
 247: DOUBLE
 248: EQUAL
 249: IFTRUE 253
 251: GO 264
 253: POP
// players := 5 ; end ;
 254: LD_ADDR_EXP 3
 258: PUSH
 259: LD_INT 5
 261: ST_TO_ADDR
 262: GO 265
 264: POP
// case Query ( QTime ) of 1 :
 265: LD_STRING QTime
 267: PPUSH
 268: CALL_OW 97
 272: PUSH
 273: LD_INT 1
 275: DOUBLE
 276: EQUAL
 277: IFTRUE 281
 279: GO 292
 281: POP
// time := 3 3$00 ; 2 :
 282: LD_ADDR_EXP 5
 286: PUSH
 287: LD_INT 6300
 289: ST_TO_ADDR
 290: GO 331
 292: LD_INT 2
 294: DOUBLE
 295: EQUAL
 296: IFTRUE 300
 298: GO 311
 300: POP
// time := 5 5$00 ; 3 :
 301: LD_ADDR_EXP 5
 305: PUSH
 306: LD_INT 10500
 308: ST_TO_ADDR
 309: GO 331
 311: LD_INT 3
 313: DOUBLE
 314: EQUAL
 315: IFTRUE 319
 317: GO 330
 319: POP
// time := 10 10$00 ; end ;
 320: LD_ADDR_EXP 5
 324: PUSH
 325: LD_INT 21000
 327: ST_TO_ADDR
 328: GO 331
 330: POP
// case Query ( QBombSib ) of 1 :
 331: LD_STRING QBombSib
 333: PPUSH
 334: CALL_OW 97
 338: PUSH
 339: LD_INT 1
 341: DOUBLE
 342: EQUAL
 343: IFTRUE 347
 345: GO 358
 347: POP
// sib_bomb := true ; 2 :
 348: LD_ADDR_EXP 4
 352: PUSH
 353: LD_INT 1
 355: ST_TO_ADDR
 356: GO 378
 358: LD_INT 2
 360: DOUBLE
 361: EQUAL
 362: IFTRUE 366
 364: GO 377
 366: POP
// sib_bomb := false ; end ;
 367: LD_ADDR_EXP 4
 371: PUSH
 372: LD_INT 0
 374: ST_TO_ADDR
 375: GO 378
 377: POP
// end ; p1 := 0 ;
 378: LD_ADDR_EXP 7
 382: PUSH
 383: LD_INT 0
 385: ST_TO_ADDR
// p2 := 0 ;
 386: LD_ADDR_EXP 8
 390: PUSH
 391: LD_INT 0
 393: ST_TO_ADDR
// p3 := 0 ;
 394: LD_ADDR_EXP 9
 398: PUSH
 399: LD_INT 0
 401: ST_TO_ADDR
// p4 := 0 ;
 402: LD_ADDR_EXP 10
 406: PUSH
 407: LD_INT 0
 409: ST_TO_ADDR
// p5 := 0 ;
 410: LD_ADDR_EXP 11
 414: PUSH
 415: LD_INT 0
 417: ST_TO_ADDR
// veh_amount := 12 ;
 418: LD_ADDR_EXP 6
 422: PUSH
 423: LD_INT 12
 425: ST_TO_ADDR
// for i = 1 to 7 do
 426: LD_ADDR_VAR 0 3
 430: PUSH
 431: DOUBLE
 432: LD_INT 1
 434: DEC
 435: ST_TO_ADDR
 436: LD_INT 7
 438: PUSH
 439: FOR_TO
 440: IFFALSE 456
// ChangeSideFog ( i , 8 ) ;
 442: LD_VAR 0 3
 446: PPUSH
 447: LD_INT 8
 449: PPUSH
 450: CALL_OW 343
 454: GO 439
 456: POP
 457: POP
// end ; end_of_file
 458: LD_VAR 0 1
 462: RET
// export function PrepareUnits ; var i , side ; begin
 463: LD_INT 0
 465: PPUSH
 466: PPUSH
 467: PPUSH
// side := players ;
 468: LD_ADDR_VAR 0 3
 472: PUSH
 473: LD_EXP 3
 477: ST_TO_ADDR
// uc_nation := 1 ;
 478: LD_ADDR_OWVAR 21
 482: PUSH
 483: LD_INT 1
 485: ST_TO_ADDR
// for i = 1 to mechanics do
 486: LD_ADDR_VAR 0 2
 490: PUSH
 491: DOUBLE
 492: LD_INT 1
 494: DEC
 495: ST_TO_ADDR
 496: LD_EXP 1
 500: PUSH
 501: FOR_TO
 502: IFFALSE 566
// for side = 1 to players do
 504: LD_ADDR_VAR 0 3
 508: PUSH
 509: DOUBLE
 510: LD_INT 1
 512: DEC
 513: ST_TO_ADDR
 514: LD_EXP 3
 518: PUSH
 519: FOR_TO
 520: IFFALSE 562
// begin uc_side := side ;
 522: LD_ADDR_OWVAR 20
 526: PUSH
 527: LD_VAR 0 3
 531: ST_TO_ADDR
// PrepareHuman ( false , 3 , 10 ) ;
 532: LD_INT 0
 534: PPUSH
 535: LD_INT 3
 537: PPUSH
 538: LD_INT 10
 540: PPUSH
 541: CALL_OW 380
// PlaceUnitArea ( CreateHuman , mech_area , false ) ;
 545: CALL_OW 44
 549: PPUSH
 550: LD_INT 6
 552: PPUSH
 553: LD_INT 0
 555: PPUSH
 556: CALL_OW 49
// end ;
 560: GO 519
 562: POP
 563: POP
 564: GO 501
 566: POP
 567: POP
// end ;
 568: LD_VAR 0 1
 572: RET
// function ToSpawn ( side ) ; begin
 573: LD_INT 0
 575: PPUSH
// uc_side := side ;
 576: LD_ADDR_OWVAR 20
 580: PUSH
 581: LD_VAR 0 1
 585: ST_TO_ADDR
// PrepareHuman ( false , 3 , 10 ) ;
 586: LD_INT 0
 588: PPUSH
 589: LD_INT 3
 591: PPUSH
 592: LD_INT 10
 594: PPUSH
 595: CALL_OW 380
// PlaceUnitArea ( CreateHuman , mech_area , false ) ;
 599: CALL_OW 44
 603: PPUSH
 604: LD_INT 6
 606: PPUSH
 607: LD_INT 0
 609: PPUSH
 610: CALL_OW 49
// end ;
 614: LD_VAR 0 2
 618: RET
// every 0 0$13 trigger time do var i , filter ;
 619: LD_EXP 5
 623: IFFALSE 733
 625: GO 627
 627: DISABLE
 628: LD_INT 0
 630: PPUSH
 631: PPUSH
// begin enable ;
 632: ENABLE
// for i = 1 to players do
 633: LD_ADDR_VAR 0 1
 637: PUSH
 638: DOUBLE
 639: LD_INT 1
 641: DEC
 642: ST_TO_ADDR
 643: LD_EXP 3
 647: PUSH
 648: FOR_TO
 649: IFFALSE 731
// begin filter := FilterAllUnits ( [ [ [ f_side , i ] , [ f_class , 3 ] , [ f_type , unit_human ] ] ] ) ;
 651: LD_ADDR_VAR 0 2
 655: PUSH
 656: LD_INT 22
 658: PUSH
 659: LD_VAR 0 1
 663: PUSH
 664: EMPTY
 665: LIST
 666: LIST
 667: PUSH
 668: LD_INT 25
 670: PUSH
 671: LD_INT 3
 673: PUSH
 674: EMPTY
 675: LIST
 676: LIST
 677: PUSH
 678: LD_INT 21
 680: PUSH
 681: LD_INT 1
 683: PUSH
 684: EMPTY
 685: LIST
 686: LIST
 687: PUSH
 688: EMPTY
 689: LIST
 690: LIST
 691: LIST
 692: PUSH
 693: EMPTY
 694: LIST
 695: PPUSH
 696: CALL_OW 69
 700: ST_TO_ADDR
// if filter < mechanics then
 701: LD_VAR 0 2
 705: PUSH
 706: LD_EXP 1
 710: LESS
 711: IFFALSE 729
// begin Wait ( 0 0$03 ) ;
 713: LD_INT 105
 715: PPUSH
 716: CALL_OW 67
// ToSpawn ( i ) ;
 720: LD_VAR 0 1
 724: PPUSH
 725: CALL 573 0 1
// end ; end ;
 729: GO 648
 731: POP
 732: POP
// end ;
 733: PPOPN 2
 735: END
// every 0 0$01 trigger time do var i , filter , filter2 , vehicles ;
 736: LD_EXP 5
 740: IFFALSE 1107
 742: GO 744
 744: DISABLE
 745: LD_INT 0
 747: PPUSH
 748: PPUSH
 749: PPUSH
 750: PPUSH
// begin enable ;
 751: ENABLE
// filter2 := FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_not , [ f_side , 0 ] ] , [ f_not , [ f_side , 1 ] ] ] ) ;
 752: LD_ADDR_VAR 0 3
 756: PUSH
 757: LD_INT 21
 759: PUSH
 760: LD_INT 2
 762: PUSH
 763: EMPTY
 764: LIST
 765: LIST
 766: PUSH
 767: LD_INT 3
 769: PUSH
 770: LD_INT 22
 772: PUSH
 773: LD_INT 0
 775: PUSH
 776: EMPTY
 777: LIST
 778: LIST
 779: PUSH
 780: EMPTY
 781: LIST
 782: LIST
 783: PUSH
 784: LD_INT 3
 786: PUSH
 787: LD_INT 22
 789: PUSH
 790: LD_INT 1
 792: PUSH
 793: EMPTY
 794: LIST
 795: LIST
 796: PUSH
 797: EMPTY
 798: LIST
 799: LIST
 800: PUSH
 801: EMPTY
 802: LIST
 803: LIST
 804: LIST
 805: PPUSH
 806: CALL_OW 69
 810: ST_TO_ADDR
// filter := FilterAllUnits ( [ [ f_type , unit_human ] , [ f_not , [ f_inside ] ] , [ f_not , [ f_side , 1 ] ] ] ) ;
 811: LD_ADDR_VAR 0 2
 815: PUSH
 816: LD_INT 21
 818: PUSH
 819: LD_INT 1
 821: PUSH
 822: EMPTY
 823: LIST
 824: LIST
 825: PUSH
 826: LD_INT 3
 828: PUSH
 829: LD_INT 54
 831: PUSH
 832: EMPTY
 833: LIST
 834: PUSH
 835: EMPTY
 836: LIST
 837: LIST
 838: PUSH
 839: LD_INT 3
 841: PUSH
 842: LD_INT 22
 844: PUSH
 845: LD_INT 1
 847: PUSH
 848: EMPTY
 849: LIST
 850: LIST
 851: PUSH
 852: EMPTY
 853: LIST
 854: LIST
 855: PUSH
 856: EMPTY
 857: LIST
 858: LIST
 859: LIST
 860: PPUSH
 861: CALL_OW 69
 865: ST_TO_ADDR
// vehicles := FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) ;
 866: LD_ADDR_VAR 0 4
 870: PUSH
 871: LD_INT 21
 873: PUSH
 874: LD_INT 2
 876: PUSH
 877: EMPTY
 878: LIST
 879: LIST
 880: PUSH
 881: LD_INT 58
 883: PUSH
 884: EMPTY
 885: LIST
 886: PUSH
 887: EMPTY
 888: LIST
 889: LIST
 890: PPUSH
 891: CALL_OW 69
 895: ST_TO_ADDR
// if filter and vehicles then
 896: LD_VAR 0 2
 900: PUSH
 901: LD_VAR 0 4
 905: AND
 906: IFFALSE 1043
// for i = 1 to filter do
 908: LD_ADDR_VAR 0 1
 912: PUSH
 913: DOUBLE
 914: LD_INT 1
 916: DEC
 917: ST_TO_ADDR
 918: LD_VAR 0 2
 922: PUSH
 923: FOR_TO
 924: IFFALSE 1041
// if not HasTask ( filter [ i ] ) and IsOk ( filter [ i ] ) then
 926: LD_VAR 0 2
 930: PUSH
 931: LD_VAR 0 1
 935: ARRAY
 936: PPUSH
 937: CALL_OW 314
 941: NOT
 942: PUSH
 943: LD_VAR 0 2
 947: PUSH
 948: LD_VAR 0 1
 952: ARRAY
 953: PPUSH
 954: CALL_OW 302
 958: AND
 959: IFFALSE 1039
// if GetDistUnits ( filter [ i ] , NearestUnitToUnit ( vehicles , filter [ i ] ) ) < 45 then
 961: LD_VAR 0 2
 965: PUSH
 966: LD_VAR 0 1
 970: ARRAY
 971: PPUSH
 972: LD_VAR 0 4
 976: PPUSH
 977: LD_VAR 0 2
 981: PUSH
 982: LD_VAR 0 1
 986: ARRAY
 987: PPUSH
 988: CALL_OW 74
 992: PPUSH
 993: CALL_OW 296
 997: PUSH
 998: LD_INT 45
1000: LESS
1001: IFFALSE 1039
// ComEnterUnit ( filter [ i ] , NearestUnitToUnit ( vehicles , filter [ i ] ) ) ;
1003: LD_VAR 0 2
1007: PUSH
1008: LD_VAR 0 1
1012: ARRAY
1013: PPUSH
1014: LD_VAR 0 4
1018: PPUSH
1019: LD_VAR 0 2
1023: PUSH
1024: LD_VAR 0 1
1028: ARRAY
1029: PPUSH
1030: CALL_OW 74
1034: PPUSH
1035: CALL_OW 120
1039: GO 923
1041: POP
1042: POP
// if filter2 then
1043: LD_VAR 0 3
1047: IFFALSE 1107
// for i = 1 to filter2 do
1049: LD_ADDR_VAR 0 1
1053: PUSH
1054: DOUBLE
1055: LD_INT 1
1057: DEC
1058: ST_TO_ADDR
1059: LD_VAR 0 3
1063: PUSH
1064: FOR_TO
1065: IFFALSE 1105
// if not HasTask ( filter2 [ i ] ) then
1067: LD_VAR 0 3
1071: PUSH
1072: LD_VAR 0 1
1076: ARRAY
1077: PPUSH
1078: CALL_OW 314
1082: NOT
1083: IFFALSE 1103
// ComMoveToArea ( filter2 [ i ] , exit_area ) ;
1085: LD_VAR 0 3
1089: PUSH
1090: LD_VAR 0 1
1094: ARRAY
1095: PPUSH
1096: LD_INT 4
1098: PPUSH
1099: CALL_OW 113
1103: GO 1064
1105: POP
1106: POP
// end ; end_of_file
1107: PPOPN 4
1109: END
// export function SpawnCar ( chas , area ) ; var i , e , veh , ar_chassis , ru_chassis , us_chassis , ar_weapons , ru_weapons , us_weapons , chassis , engine , weapon ; begin
1110: LD_INT 0
1112: PPUSH
1113: PPUSH
1114: PPUSH
1115: PPUSH
1116: PPUSH
1117: PPUSH
1118: PPUSH
1119: PPUSH
1120: PPUSH
1121: PPUSH
1122: PPUSH
1123: PPUSH
1124: PPUSH
// uc_side := 0 ;
1125: LD_ADDR_OWVAR 20
1129: PUSH
1130: LD_INT 0
1132: ST_TO_ADDR
// uc_nation := Rand ( 1 , 3 ) ;
1133: LD_ADDR_OWVAR 21
1137: PUSH
1138: LD_INT 1
1140: PPUSH
1141: LD_INT 3
1143: PPUSH
1144: CALL_OW 12
1148: ST_TO_ADDR
// ar_chassis := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ;
1149: LD_ADDR_VAR 0 7
1153: PUSH
1154: LD_INT 11
1156: PUSH
1157: LD_INT 12
1159: PUSH
1160: LD_INT 13
1162: PUSH
1163: LD_INT 14
1165: PUSH
1166: EMPTY
1167: LIST
1168: LIST
1169: LIST
1170: LIST
1171: ST_TO_ADDR
// ru_chassis := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ;
1172: LD_ADDR_VAR 0 8
1176: PUSH
1177: LD_INT 21
1179: PUSH
1180: LD_INT 22
1182: PUSH
1183: LD_INT 23
1185: PUSH
1186: LD_INT 24
1188: PUSH
1189: EMPTY
1190: LIST
1191: LIST
1192: LIST
1193: LIST
1194: ST_TO_ADDR
// us_chassis := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ;
1195: LD_ADDR_VAR 0 9
1199: PUSH
1200: LD_INT 1
1202: PUSH
1203: LD_INT 2
1205: PUSH
1206: LD_INT 3
1208: PUSH
1209: LD_INT 4
1211: PUSH
1212: LD_INT 5
1214: PUSH
1215: EMPTY
1216: LIST
1217: LIST
1218: LIST
1219: LIST
1220: LIST
1221: ST_TO_ADDR
// if chas > 0 then
1222: LD_VAR 0 1
1226: PUSH
1227: LD_INT 0
1229: GREATER
1230: IFFALSE 1244
// vc_chassis := chas else
1232: LD_ADDR_OWVAR 37
1236: PUSH
1237: LD_VAR 0 1
1241: ST_TO_ADDR
1242: GO 1337
// begin case uc_nation of 1 :
1244: LD_OWVAR 21
1248: PUSH
1249: LD_INT 1
1251: DOUBLE
1252: EQUAL
1253: IFTRUE 1257
1255: GO 1270
1257: POP
// chassis := us_chassis ; 2 :
1258: LD_ADDR_VAR 0 13
1262: PUSH
1263: LD_VAR 0 9
1267: ST_TO_ADDR
1268: GO 1313
1270: LD_INT 2
1272: DOUBLE
1273: EQUAL
1274: IFTRUE 1278
1276: GO 1291
1278: POP
// chassis := ar_chassis ; 3 :
1279: LD_ADDR_VAR 0 13
1283: PUSH
1284: LD_VAR 0 7
1288: ST_TO_ADDR
1289: GO 1313
1291: LD_INT 3
1293: DOUBLE
1294: EQUAL
1295: IFTRUE 1299
1297: GO 1312
1299: POP
// chassis := ru_chassis ; end ;
1300: LD_ADDR_VAR 0 13
1304: PUSH
1305: LD_VAR 0 8
1309: ST_TO_ADDR
1310: GO 1313
1312: POP
// vc_chassis := chassis [ Rand ( 1 , chassis ) ] ;
1313: LD_ADDR_OWVAR 37
1317: PUSH
1318: LD_VAR 0 13
1322: PUSH
1323: LD_INT 1
1325: PPUSH
1326: LD_VAR 0 13
1330: PPUSH
1331: CALL_OW 12
1335: ARRAY
1336: ST_TO_ADDR
// end ; if vc_chassis in [ ar_hovercraft , ar_light_trike , us_light_wheeled ] then
1337: LD_OWVAR 37
1341: PUSH
1342: LD_INT 11
1344: PUSH
1345: LD_INT 12
1347: PUSH
1348: LD_INT 1
1350: PUSH
1351: EMPTY
1352: LIST
1353: LIST
1354: LIST
1355: IN
1356: IFFALSE 1376
// engine := Rand ( 1 , 2 ) else
1358: LD_ADDR_VAR 0 14
1362: PUSH
1363: LD_INT 1
1365: PPUSH
1366: LD_INT 2
1368: PPUSH
1369: CALL_OW 12
1373: ST_TO_ADDR
1374: GO 1488
// begin if not vc_chassis in [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked , us_heavy_tracked , us_morphling ] then
1376: LD_OWVAR 37
1380: PUSH
1381: LD_INT 21
1383: PUSH
1384: LD_INT 22
1386: PUSH
1387: LD_INT 23
1389: PUSH
1390: LD_INT 24
1392: PUSH
1393: LD_INT 4
1395: PUSH
1396: LD_INT 5
1398: PUSH
1399: EMPTY
1400: LIST
1401: LIST
1402: LIST
1403: LIST
1404: LIST
1405: LIST
1406: IN
1407: NOT
1408: IFFALSE 1428
// engine := Rand ( 1 , 3 ) else
1410: LD_ADDR_VAR 0 14
1414: PUSH
1415: LD_INT 1
1417: PPUSH
1418: LD_INT 3
1420: PPUSH
1421: CALL_OW 12
1425: ST_TO_ADDR
1426: GO 1444
// e := Rand ( 1 , 2 ) ;
1428: LD_ADDR_VAR 0 5
1432: PUSH
1433: LD_INT 1
1435: PPUSH
1436: LD_INT 2
1438: PPUSH
1439: CALL_OW 12
1443: ST_TO_ADDR
// case e of 1 :
1444: LD_VAR 0 5
1448: PUSH
1449: LD_INT 1
1451: DOUBLE
1452: EQUAL
1453: IFTRUE 1457
1455: GO 1468
1457: POP
// engine := engine_combustion ; 2 :
1458: LD_ADDR_VAR 0 14
1462: PUSH
1463: LD_INT 1
1465: ST_TO_ADDR
1466: GO 1488
1468: LD_INT 2
1470: DOUBLE
1471: EQUAL
1472: IFTRUE 1476
1474: GO 1487
1476: POP
// engine := engine_siberite ; end ;
1477: LD_ADDR_VAR 0 14
1481: PUSH
1482: LD_INT 3
1484: ST_TO_ADDR
1485: GO 1488
1487: POP
// end ; vc_engine := engine ;
1488: LD_ADDR_OWVAR 39
1492: PUSH
1493: LD_VAR 0 14
1497: ST_TO_ADDR
// vc_control := control_manual ;
1498: LD_ADDR_OWVAR 38
1502: PUSH
1503: LD_INT 1
1505: ST_TO_ADDR
// ar_weapons := [ ar_multimissile_ballista , ar_double_machine_gun , ar_light_gun , ar_radar , ar_gatling_gun , ar_gun , ar_rocket_launcher , ar_selfpropelled_bomb , ar_flame_thrower ] ;
1506: LD_ADDR_VAR 0 10
1510: PUSH
1511: LD_INT 22
1513: PUSH
1514: LD_INT 24
1516: PUSH
1517: LD_INT 23
1519: PUSH
1520: LD_INT 30
1522: PUSH
1523: LD_INT 25
1525: PUSH
1526: LD_INT 27
1528: PUSH
1529: LD_INT 28
1531: PUSH
1532: LD_INT 29
1534: PUSH
1535: LD_INT 26
1537: PUSH
1538: EMPTY
1539: LIST
1540: LIST
1541: LIST
1542: LIST
1543: LIST
1544: LIST
1545: LIST
1546: LIST
1547: LIST
1548: ST_TO_ADDR
// ru_weapons := [ ru_heavy_machine_gun , ru_gatling_gun , ru_gun , 98 , ru_rocket_launcher , ru_heavy_gun , ru_rocket , ru_bulldozer , ru_time_lapser ] ;
1549: LD_ADDR_VAR 0 11
1553: PUSH
1554: LD_INT 42
1556: PUSH
1557: LD_INT 43
1559: PUSH
1560: LD_INT 44
1562: PUSH
1563: LD_INT 98
1565: PUSH
1566: LD_INT 45
1568: PUSH
1569: LD_INT 46
1571: PUSH
1572: LD_INT 47
1574: PUSH
1575: LD_INT 53
1577: PUSH
1578: LD_INT 49
1580: PUSH
1581: EMPTY
1582: LIST
1583: LIST
1584: LIST
1585: LIST
1586: LIST
1587: LIST
1588: LIST
1589: LIST
1590: LIST
1591: ST_TO_ADDR
// us_weapons := [ us_machine_gun , us_light_gun , us_radar , us_gatling_gun , us_double_gun , us_rocket_launcher , us_laser , us_heavy_gun , us_bulldozer , us_double_laser ] ;
1592: LD_ADDR_VAR 0 12
1596: PUSH
1597: LD_INT 2
1599: PUSH
1600: LD_INT 3
1602: PUSH
1603: LD_INT 11
1605: PUSH
1606: LD_INT 4
1608: PUSH
1609: LD_INT 5
1611: PUSH
1612: LD_INT 7
1614: PUSH
1615: LD_INT 9
1617: PUSH
1618: LD_INT 6
1620: PUSH
1621: LD_INT 14
1623: PUSH
1624: LD_INT 10
1626: PUSH
1627: EMPTY
1628: LIST
1629: LIST
1630: LIST
1631: LIST
1632: LIST
1633: LIST
1634: LIST
1635: LIST
1636: LIST
1637: LIST
1638: ST_TO_ADDR
// if uc_nation = nation_arabian then
1639: LD_OWVAR 21
1643: PUSH
1644: LD_INT 2
1646: EQUAL
1647: IFFALSE 1714
// begin if vc_chassis in [ ar_hovercraft , ar_light_trike ] then
1649: LD_OWVAR 37
1653: PUSH
1654: LD_INT 11
1656: PUSH
1657: LD_INT 12
1659: PUSH
1660: EMPTY
1661: LIST
1662: LIST
1663: IN
1664: IFFALSE 1690
// weapon := ar_weapons [ Rand ( 1 , 3 ) ] else
1666: LD_ADDR_VAR 0 15
1670: PUSH
1671: LD_VAR 0 10
1675: PUSH
1676: LD_INT 1
1678: PPUSH
1679: LD_INT 3
1681: PPUSH
1682: CALL_OW 12
1686: ARRAY
1687: ST_TO_ADDR
1688: GO 1714
// weapon := ar_weapons [ Rand ( 1 , ar_weapons ) ] ;
1690: LD_ADDR_VAR 0 15
1694: PUSH
1695: LD_VAR 0 10
1699: PUSH
1700: LD_INT 1
1702: PPUSH
1703: LD_VAR 0 10
1707: PPUSH
1708: CALL_OW 12
1712: ARRAY
1713: ST_TO_ADDR
// end ; if uc_nation = nation_russian then
1714: LD_OWVAR 21
1718: PUSH
1719: LD_INT 3
1721: EQUAL
1722: IFFALSE 1789
// begin if vc_chassis in [ ru_medium_wheeled , ru_medium_tracked ] then
1724: LD_OWVAR 37
1728: PUSH
1729: LD_INT 21
1731: PUSH
1732: LD_INT 22
1734: PUSH
1735: EMPTY
1736: LIST
1737: LIST
1738: IN
1739: IFFALSE 1765
// weapon := ru_weapons [ Rand ( 1 , 5 ) ] else
1741: LD_ADDR_VAR 0 15
1745: PUSH
1746: LD_VAR 0 11
1750: PUSH
1751: LD_INT 1
1753: PPUSH
1754: LD_INT 5
1756: PPUSH
1757: CALL_OW 12
1761: ARRAY
1762: ST_TO_ADDR
1763: GO 1789
// weapon := ru_weapons [ Rand ( 1 , ru_weapons ) ] ;
1765: LD_ADDR_VAR 0 15
1769: PUSH
1770: LD_VAR 0 11
1774: PUSH
1775: LD_INT 1
1777: PPUSH
1778: LD_VAR 0 11
1782: PPUSH
1783: CALL_OW 12
1787: ARRAY
1788: ST_TO_ADDR
// end ; if uc_nation = nation_american then
1789: LD_OWVAR 21
1793: PUSH
1794: LD_INT 1
1796: EQUAL
1797: IFFALSE 1906
// begin if vc_chassis = us_light_wheeled then
1799: LD_OWVAR 37
1803: PUSH
1804: LD_INT 1
1806: EQUAL
1807: IFFALSE 1831
// weapon := us_weapons [ Rand ( 1 , 3 ) ] ;
1809: LD_ADDR_VAR 0 15
1813: PUSH
1814: LD_VAR 0 12
1818: PUSH
1819: LD_INT 1
1821: PPUSH
1822: LD_INT 3
1824: PPUSH
1825: CALL_OW 12
1829: ARRAY
1830: ST_TO_ADDR
// if vc_chassis in [ us_medium_tracked , us_medium_wheeled ] then
1831: LD_OWVAR 37
1835: PUSH
1836: LD_INT 3
1838: PUSH
1839: LD_INT 2
1841: PUSH
1842: EMPTY
1843: LIST
1844: LIST
1845: IN
1846: IFFALSE 1872
// weapon := us_weapons [ Rand ( 1 , 7 ) ] else
1848: LD_ADDR_VAR 0 15
1852: PUSH
1853: LD_VAR 0 12
1857: PUSH
1858: LD_INT 1
1860: PPUSH
1861: LD_INT 7
1863: PPUSH
1864: CALL_OW 12
1868: ARRAY
1869: ST_TO_ADDR
1870: GO 1906
// if vc_chassis <> us_light_wheeled then
1872: LD_OWVAR 37
1876: PUSH
1877: LD_INT 1
1879: NONEQUAL
1880: IFFALSE 1906
// weapon := us_weapons [ Rand ( 1 , us_weapons ) ] ;
1882: LD_ADDR_VAR 0 15
1886: PUSH
1887: LD_VAR 0 12
1891: PUSH
1892: LD_INT 1
1894: PPUSH
1895: LD_VAR 0 12
1899: PPUSH
1900: CALL_OW 12
1904: ARRAY
1905: ST_TO_ADDR
// end ; vc_weapon := weapon ;
1906: LD_ADDR_OWVAR 40
1910: PUSH
1911: LD_VAR 0 15
1915: ST_TO_ADDR
// veh := CreateVehicle ;
1916: LD_ADDR_VAR 0 6
1920: PUSH
1921: CALL_OW 45
1925: ST_TO_ADDR
// PlaceUnitArea ( veh , area , true ) ;
1926: LD_VAR 0 6
1930: PPUSH
1931: LD_VAR 0 2
1935: PPUSH
1936: LD_INT 1
1938: PPUSH
1939: CALL_OW 49
// end ;
1943: LD_VAR 0 3
1947: RET
// export function SpawnSibRocket ( area ) ; var veh , p ; begin
1948: LD_INT 0
1950: PPUSH
1951: PPUSH
1952: PPUSH
// uc_side := 0 ;
1953: LD_ADDR_OWVAR 20
1957: PUSH
1958: LD_INT 0
1960: ST_TO_ADDR
// p := Rand ( 1 , 2 ) ;
1961: LD_ADDR_VAR 0 4
1965: PUSH
1966: LD_INT 1
1968: PPUSH
1969: LD_INT 2
1971: PPUSH
1972: CALL_OW 12
1976: ST_TO_ADDR
// case p of 1 :
1977: LD_VAR 0 4
1981: PUSH
1982: LD_INT 1
1984: DOUBLE
1985: EQUAL
1986: IFTRUE 1990
1988: GO 2033
1990: POP
// begin uc_nation := nation_american ;
1991: LD_ADDR_OWVAR 21
1995: PUSH
1996: LD_INT 1
1998: ST_TO_ADDR
// vc_chassis := us_heavy_tracked ;
1999: LD_ADDR_OWVAR 37
2003: PUSH
2004: LD_INT 4
2006: ST_TO_ADDR
// vc_engine := engine_siberite ;
2007: LD_ADDR_OWVAR 39
2011: PUSH
2012: LD_INT 3
2014: ST_TO_ADDR
// vc_control := control_manual ;
2015: LD_ADDR_OWVAR 38
2019: PUSH
2020: LD_INT 1
2022: ST_TO_ADDR
// vc_weapon := us_siberium_rocket ;
2023: LD_ADDR_OWVAR 40
2027: PUSH
2028: LD_INT 8
2030: ST_TO_ADDR
// end ; 2 :
2031: GO 2085
2033: LD_INT 2
2035: DOUBLE
2036: EQUAL
2037: IFTRUE 2041
2039: GO 2084
2041: POP
// begin uc_nation := nation_russian ;
2042: LD_ADDR_OWVAR 21
2046: PUSH
2047: LD_INT 3
2049: ST_TO_ADDR
// vc_chassis := ru_heavy_tracked ;
2050: LD_ADDR_OWVAR 37
2054: PUSH
2055: LD_INT 24
2057: ST_TO_ADDR
// vc_engine := engine_siberite ;
2058: LD_ADDR_OWVAR 39
2062: PUSH
2063: LD_INT 3
2065: ST_TO_ADDR
// vc_control := control_manual ;
2066: LD_ADDR_OWVAR 38
2070: PUSH
2071: LD_INT 1
2073: ST_TO_ADDR
// vc_weapon := ru_siberium_rocket ;
2074: LD_ADDR_OWVAR 40
2078: PUSH
2079: LD_INT 48
2081: ST_TO_ADDR
// end ; end ;
2082: GO 2085
2084: POP
// veh := CreateVehicle ;
2085: LD_ADDR_VAR 0 3
2089: PUSH
2090: CALL_OW 45
2094: ST_TO_ADDR
// PlaceUnitArea ( veh , area , true ) ;
2095: LD_VAR 0 3
2099: PPUSH
2100: LD_VAR 0 1
2104: PPUSH
2105: LD_INT 1
2107: PPUSH
2108: CALL_OW 49
// end ;
2112: LD_VAR 0 2
2116: RET
// export function ScoreBoard ( veh ) ; var points ; begin
2117: LD_INT 0
2119: PPUSH
2120: PPUSH
// points := 0 ;
2121: LD_ADDR_VAR 0 3
2125: PUSH
2126: LD_INT 0
2128: ST_TO_ADDR
// if GetChassis ( veh ) in [ ar_light_trike , us_light_wheeled ] then
2129: LD_VAR 0 1
2133: PPUSH
2134: CALL_OW 265
2138: PUSH
2139: LD_INT 12
2141: PUSH
2142: LD_INT 1
2144: PUSH
2145: EMPTY
2146: LIST
2147: LIST
2148: IN
2149: IFFALSE 2165
// points := points + 10 ;
2151: LD_ADDR_VAR 0 3
2155: PUSH
2156: LD_VAR 0 3
2160: PUSH
2161: LD_INT 10
2163: PLUS
2164: ST_TO_ADDR
// if GetChassis ( veh ) in [ ar_medium_trike , ru_medium_wheeled , us_medium_wheeled ] then
2165: LD_VAR 0 1
2169: PPUSH
2170: CALL_OW 265
2174: PUSH
2175: LD_INT 13
2177: PUSH
2178: LD_INT 21
2180: PUSH
2181: LD_INT 2
2183: PUSH
2184: EMPTY
2185: LIST
2186: LIST
2187: LIST
2188: IN
2189: IFFALSE 2205
// points := points + 15 ;
2191: LD_ADDR_VAR 0 3
2195: PUSH
2196: LD_VAR 0 3
2200: PUSH
2201: LD_INT 15
2203: PLUS
2204: ST_TO_ADDR
// if GetChassis ( veh ) in [ ar_half_tracked , ru_medium_tracked , us_medium_tracked ] then
2205: LD_VAR 0 1
2209: PPUSH
2210: CALL_OW 265
2214: PUSH
2215: LD_INT 14
2217: PUSH
2218: LD_INT 22
2220: PUSH
2221: LD_INT 3
2223: PUSH
2224: EMPTY
2225: LIST
2226: LIST
2227: LIST
2228: IN
2229: IFFALSE 2245
// points := points + 20 ;
2231: LD_ADDR_VAR 0 3
2235: PUSH
2236: LD_VAR 0 3
2240: PUSH
2241: LD_INT 20
2243: PLUS
2244: ST_TO_ADDR
// if GetChassis ( veh ) in [ ru_heavy_wheeled , ru_heavy_tracked , us_heavy_tracked ] then
2245: LD_VAR 0 1
2249: PPUSH
2250: CALL_OW 265
2254: PUSH
2255: LD_INT 23
2257: PUSH
2258: LD_INT 24
2260: PUSH
2261: LD_INT 4
2263: PUSH
2264: EMPTY
2265: LIST
2266: LIST
2267: LIST
2268: IN
2269: IFFALSE 2285
// points := points + 25 ;
2271: LD_ADDR_VAR 0 3
2275: PUSH
2276: LD_VAR 0 3
2280: PUSH
2281: LD_INT 25
2283: PLUS
2284: ST_TO_ADDR
// if GetChassis ( veh ) in [ ar_hovercraft , us_morphling ] then
2285: LD_VAR 0 1
2289: PPUSH
2290: CALL_OW 265
2294: PUSH
2295: LD_INT 11
2297: PUSH
2298: LD_INT 5
2300: PUSH
2301: EMPTY
2302: LIST
2303: LIST
2304: IN
2305: IFFALSE 2321
// points := points + 30 ;
2307: LD_ADDR_VAR 0 3
2311: PUSH
2312: LD_VAR 0 3
2316: PUSH
2317: LD_INT 30
2319: PLUS
2320: ST_TO_ADDR
// if GetEngine ( veh ) = [ engine_combustion ] then
2321: LD_VAR 0 1
2325: PPUSH
2326: CALL_OW 262
2330: PUSH
2331: LD_INT 1
2333: PUSH
2334: EMPTY
2335: LIST
2336: EQUAL
2337: IFFALSE 2353
// points := points + 5 ;
2339: LD_ADDR_VAR 0 3
2343: PUSH
2344: LD_VAR 0 3
2348: PUSH
2349: LD_INT 5
2351: PLUS
2352: ST_TO_ADDR
// if GetEngine ( veh ) = [ engine_solar ] then
2353: LD_VAR 0 1
2357: PPUSH
2358: CALL_OW 262
2362: PUSH
2363: LD_INT 2
2365: PUSH
2366: EMPTY
2367: LIST
2368: EQUAL
2369: IFFALSE 2385
// points := points + 15 ;
2371: LD_ADDR_VAR 0 3
2375: PUSH
2376: LD_VAR 0 3
2380: PUSH
2381: LD_INT 15
2383: PLUS
2384: ST_TO_ADDR
// if GetEngine ( veh ) = [ engine_siberite ] then
2385: LD_VAR 0 1
2389: PPUSH
2390: CALL_OW 262
2394: PUSH
2395: LD_INT 3
2397: PUSH
2398: EMPTY
2399: LIST
2400: EQUAL
2401: IFFALSE 2417
// points := points + 25 ;
2403: LD_ADDR_VAR 0 3
2407: PUSH
2408: LD_VAR 0 3
2412: PUSH
2413: LD_INT 25
2415: PLUS
2416: ST_TO_ADDR
// if GetWeapon ( veh ) in [ ar_multimissile_ballista , ar_double_machine_gun , ar_light_gun , ru_heavy_machine_gun , us_machine_gun , us_light_gun ] then
2417: LD_VAR 0 1
2421: PPUSH
2422: CALL_OW 264
2426: PUSH
2427: LD_INT 22
2429: PUSH
2430: LD_INT 24
2432: PUSH
2433: LD_INT 23
2435: PUSH
2436: LD_INT 42
2438: PUSH
2439: LD_INT 2
2441: PUSH
2442: LD_INT 3
2444: PUSH
2445: EMPTY
2446: LIST
2447: LIST
2448: LIST
2449: LIST
2450: LIST
2451: LIST
2452: IN
2453: IFFALSE 2469
// points := points + 5 ;
2455: LD_ADDR_VAR 0 3
2459: PUSH
2460: LD_VAR 0 3
2464: PUSH
2465: LD_INT 5
2467: PLUS
2468: ST_TO_ADDR
// if GetWeapon ( veh ) in [ ar_gatling_gun , ar_gun , ru_gatling_gun , ru_gun , us_gatling_gun , us_double_gun ] then
2469: LD_VAR 0 1
2473: PPUSH
2474: CALL_OW 264
2478: PUSH
2479: LD_INT 25
2481: PUSH
2482: LD_INT 27
2484: PUSH
2485: LD_INT 43
2487: PUSH
2488: LD_INT 44
2490: PUSH
2491: LD_INT 4
2493: PUSH
2494: LD_INT 5
2496: PUSH
2497: EMPTY
2498: LIST
2499: LIST
2500: LIST
2501: LIST
2502: LIST
2503: LIST
2504: IN
2505: IFFALSE 2521
// points := points + 10 ;
2507: LD_ADDR_VAR 0 3
2511: PUSH
2512: LD_VAR 0 3
2516: PUSH
2517: LD_INT 10
2519: PLUS
2520: ST_TO_ADDR
// if GetWeapon ( veh ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher ] then
2521: LD_VAR 0 1
2525: PPUSH
2526: CALL_OW 264
2530: PUSH
2531: LD_INT 28
2533: PUSH
2534: LD_INT 45
2536: PUSH
2537: LD_INT 7
2539: PUSH
2540: EMPTY
2541: LIST
2542: LIST
2543: LIST
2544: IN
2545: IFFALSE 2561
// points := points + 20 ;
2547: LD_ADDR_VAR 0 3
2551: PUSH
2552: LD_VAR 0 3
2556: PUSH
2557: LD_INT 20
2559: PLUS
2560: ST_TO_ADDR
// if GetWeapon ( veh ) in [ ru_heavy_gun , us_heavy_gun ] then
2561: LD_VAR 0 1
2565: PPUSH
2566: CALL_OW 264
2570: PUSH
2571: LD_INT 46
2573: PUSH
2574: LD_INT 6
2576: PUSH
2577: EMPTY
2578: LIST
2579: LIST
2580: IN
2581: IFFALSE 2597
// points := points + 25 ;
2583: LD_ADDR_VAR 0 3
2587: PUSH
2588: LD_VAR 0 3
2592: PUSH
2593: LD_INT 25
2595: PLUS
2596: ST_TO_ADDR
// if GetWeapon ( veh ) in [ us_laser , us_radar , ar_radar ] then
2597: LD_VAR 0 1
2601: PPUSH
2602: CALL_OW 264
2606: PUSH
2607: LD_INT 9
2609: PUSH
2610: LD_INT 11
2612: PUSH
2613: LD_INT 30
2615: PUSH
2616: EMPTY
2617: LIST
2618: LIST
2619: LIST
2620: IN
2621: IFFALSE 2637
// points := points + 30 ;
2623: LD_ADDR_VAR 0 3
2627: PUSH
2628: LD_VAR 0 3
2632: PUSH
2633: LD_INT 30
2635: PLUS
2636: ST_TO_ADDR
// if GetWeapon ( veh ) in [ ar_selfpropelled_bomb , ru_time_lapser , ru_rocket , us_double_laser ] then
2637: LD_VAR 0 1
2641: PPUSH
2642: CALL_OW 264
2646: PUSH
2647: LD_INT 29
2649: PUSH
2650: LD_INT 49
2652: PUSH
2653: LD_INT 47
2655: PUSH
2656: LD_INT 10
2658: PUSH
2659: EMPTY
2660: LIST
2661: LIST
2662: LIST
2663: LIST
2664: IN
2665: IFFALSE 2681
// points := points + 50 ;
2667: LD_ADDR_VAR 0 3
2671: PUSH
2672: LD_VAR 0 3
2676: PUSH
2677: LD_INT 50
2679: PLUS
2680: ST_TO_ADDR
// if GetWeapon ( veh ) in [ ru_siberium_rocket , us_siberium_rocket ] then
2681: LD_VAR 0 1
2685: PPUSH
2686: CALL_OW 264
2690: PUSH
2691: LD_INT 48
2693: PUSH
2694: LD_INT 8
2696: PUSH
2697: EMPTY
2698: LIST
2699: LIST
2700: IN
2701: IFFALSE 2717
// points := points + 100 ;
2703: LD_ADDR_VAR 0 3
2707: PUSH
2708: LD_VAR 0 3
2712: PUSH
2713: LD_INT 100
2715: PLUS
2716: ST_TO_ADDR
// result := points ;
2717: LD_ADDR_VAR 0 2
2721: PUSH
2722: LD_VAR 0 3
2726: ST_TO_ADDR
// end ; end_of_file
2727: LD_VAR 0 2
2731: RET
// every 0 0$01 trigger time do var filter , i , side , driver , un ;
2732: LD_EXP 5
2736: IFFALSE 3381
2738: GO 2740
2740: DISABLE
2741: LD_INT 0
2743: PPUSH
2744: PPUSH
2745: PPUSH
2746: PPUSH
2747: PPUSH
// begin enable ;
2748: ENABLE
// if tick < 36 then
2749: LD_OWVAR 1
2753: PUSH
2754: LD_INT 36
2756: LESS
2757: IFFALSE 2769
// SetAreaMapShow ( exit_area , 1 ) ;
2759: LD_INT 4
2761: PPUSH
2762: LD_INT 1
2764: PPUSH
2765: CALL_OW 424
// time := time - 0 0$01 ;
2769: LD_ADDR_EXP 5
2773: PUSH
2774: LD_EXP 5
2778: PUSH
2779: LD_INT 35
2781: MINUS
2782: ST_TO_ADDR
// if time = 0 0$00 then
2783: LD_EXP 5
2787: PUSH
2788: LD_INT 0
2790: EQUAL
2791: IFFALSE 2854
// if p1 > p2 and p1 > p3 and p1 > p4 and p1 > p5 then
2793: LD_EXP 7
2797: PUSH
2798: LD_EXP 8
2802: GREATER
2803: PUSH
2804: LD_EXP 7
2808: PUSH
2809: LD_EXP 9
2813: GREATER
2814: AND
2815: PUSH
2816: LD_EXP 7
2820: PUSH
2821: LD_EXP 10
2825: GREATER
2826: AND
2827: PUSH
2828: LD_EXP 7
2832: PUSH
2833: LD_EXP 11
2837: GREATER
2838: AND
2839: IFFALSE 2847
// YouWin else
2841: CALL_OW 103
2845: GO 2854
// YouLost (  ) ;
2847: LD_STRING 
2849: PPUSH
2850: CALL_OW 104
// filter := FilterUnitsInArea ( exit_area , [ f_type , unit_vehicle ] ) ;
2854: LD_ADDR_VAR 0 1
2858: PUSH
2859: LD_INT 4
2861: PPUSH
2862: LD_INT 21
2864: PUSH
2865: LD_INT 2
2867: PUSH
2868: EMPTY
2869: LIST
2870: LIST
2871: PPUSH
2872: CALL_OW 70
2876: ST_TO_ADDR
// if filter then
2877: LD_VAR 0 1
2881: IFFALSE 3171
// for i = 1 to filter do
2883: LD_ADDR_VAR 0 2
2887: PUSH
2888: DOUBLE
2889: LD_INT 1
2891: DEC
2892: ST_TO_ADDR
2893: LD_VAR 0 1
2897: PUSH
2898: FOR_TO
2899: IFFALSE 3169
// begin side := GetSide ( filter [ i ] ) ;
2901: LD_ADDR_VAR 0 3
2905: PUSH
2906: LD_VAR 0 1
2910: PUSH
2911: LD_VAR 0 2
2915: ARRAY
2916: PPUSH
2917: CALL_OW 255
2921: ST_TO_ADDR
// driver := IsDrivenBy ( filter [ i ] ) ;
2922: LD_ADDR_VAR 0 4
2926: PUSH
2927: LD_VAR 0 1
2931: PUSH
2932: LD_VAR 0 2
2936: ARRAY
2937: PPUSH
2938: CALL_OW 311
2942: ST_TO_ADDR
// un := filter [ i ] ;
2943: LD_ADDR_VAR 0 5
2947: PUSH
2948: LD_VAR 0 1
2952: PUSH
2953: LD_VAR 0 2
2957: ARRAY
2958: ST_TO_ADDR
// if IsInUnit ( driver ) then
2959: LD_VAR 0 4
2963: PPUSH
2964: CALL_OW 310
2968: IFFALSE 2979
// ComExitVehicle ( driver ) ;
2970: LD_VAR 0 4
2974: PPUSH
2975: CALL_OW 121
// Wait ( 0 0$0.3 ) ;
2979: LD_INT 10
2981: PPUSH
2982: CALL_OW 67
// RemoveUnit ( filter [ i ] ) ;
2986: LD_VAR 0 1
2990: PUSH
2991: LD_VAR 0 2
2995: ARRAY
2996: PPUSH
2997: CALL_OW 64
// case side of 1 :
3001: LD_VAR 0 3
3005: PUSH
3006: LD_INT 1
3008: DOUBLE
3009: EQUAL
3010: IFTRUE 3014
3012: GO 3038
3014: POP
// p1 := p1 + ScoreBoard ( un ) ; 2 :
3015: LD_ADDR_EXP 7
3019: PUSH
3020: LD_EXP 7
3024: PUSH
3025: LD_VAR 0 5
3029: PPUSH
3030: CALL 2117 0 1
3034: PLUS
3035: ST_TO_ADDR
3036: GO 3167
3038: LD_INT 2
3040: DOUBLE
3041: EQUAL
3042: IFTRUE 3046
3044: GO 3070
3046: POP
// p2 := p2 + ScoreBoard ( un ) ; 3 :
3047: LD_ADDR_EXP 8
3051: PUSH
3052: LD_EXP 8
3056: PUSH
3057: LD_VAR 0 5
3061: PPUSH
3062: CALL 2117 0 1
3066: PLUS
3067: ST_TO_ADDR
3068: GO 3167
3070: LD_INT 3
3072: DOUBLE
3073: EQUAL
3074: IFTRUE 3078
3076: GO 3102
3078: POP
// p3 := p3 + ScoreBoard ( un ) ; 4 :
3079: LD_ADDR_EXP 9
3083: PUSH
3084: LD_EXP 9
3088: PUSH
3089: LD_VAR 0 5
3093: PPUSH
3094: CALL 2117 0 1
3098: PLUS
3099: ST_TO_ADDR
3100: GO 3167
3102: LD_INT 4
3104: DOUBLE
3105: EQUAL
3106: IFTRUE 3110
3108: GO 3134
3110: POP
// p4 := p4 + ScoreBoard ( un ) ; 5 :
3111: LD_ADDR_EXP 10
3115: PUSH
3116: LD_EXP 10
3120: PUSH
3121: LD_VAR 0 5
3125: PPUSH
3126: CALL 2117 0 1
3130: PLUS
3131: ST_TO_ADDR
3132: GO 3167
3134: LD_INT 5
3136: DOUBLE
3137: EQUAL
3138: IFTRUE 3142
3140: GO 3166
3142: POP
// p5 := p5 + ScoreBoard ( un ) ; end ;
3143: LD_ADDR_EXP 11
3147: PUSH
3148: LD_EXP 11
3152: PUSH
3153: LD_VAR 0 5
3157: PPUSH
3158: CALL 2117 0 1
3162: PLUS
3163: ST_TO_ADDR
3164: GO 3167
3166: POP
// end ;
3167: GO 2898
3169: POP
3170: POP
// case players of 3 :
3171: LD_EXP 3
3175: PUSH
3176: LD_INT 3
3178: DOUBLE
3179: EQUAL
3180: IFTRUE 3184
3182: GO 3234
3184: POP
// begin display_strings := [ #tick , time , #player1 , p1 , #player2 , p2 , #player3 , p3 ] ;
3185: LD_ADDR_OWVAR 47
3189: PUSH
3190: LD_STRING #tick
3192: PUSH
3193: LD_EXP 5
3197: PUSH
3198: LD_STRING #player1
3200: PUSH
3201: LD_EXP 7
3205: PUSH
3206: LD_STRING #player2
3208: PUSH
3209: LD_EXP 8
3213: PUSH
3214: LD_STRING #player3
3216: PUSH
3217: LD_EXP 9
3221: PUSH
3222: EMPTY
3223: LIST
3224: LIST
3225: LIST
3226: LIST
3227: LIST
3228: LIST
3229: LIST
3230: LIST
3231: ST_TO_ADDR
// end ; 4 :
3232: GO 3381
3234: LD_INT 4
3236: DOUBLE
3237: EQUAL
3238: IFTRUE 3242
3240: GO 3302
3242: POP
// begin display_strings := [ #tick , time , #player1 , p1 , #player2 , p2 , #player3 , p3 , #player4 , p4 ] ;
3243: LD_ADDR_OWVAR 47
3247: PUSH
3248: LD_STRING #tick
3250: PUSH
3251: LD_EXP 5
3255: PUSH
3256: LD_STRING #player1
3258: PUSH
3259: LD_EXP 7
3263: PUSH
3264: LD_STRING #player2
3266: PUSH
3267: LD_EXP 8
3271: PUSH
3272: LD_STRING #player3
3274: PUSH
3275: LD_EXP 9
3279: PUSH
3280: LD_STRING #player4
3282: PUSH
3283: LD_EXP 10
3287: PUSH
3288: EMPTY
3289: LIST
3290: LIST
3291: LIST
3292: LIST
3293: LIST
3294: LIST
3295: LIST
3296: LIST
3297: LIST
3298: LIST
3299: ST_TO_ADDR
// end ; 5 :
3300: GO 3381
3302: LD_INT 5
3304: DOUBLE
3305: EQUAL
3306: IFTRUE 3310
3308: GO 3380
3310: POP
// begin display_strings := [ #tick , time , #player1 , p1 , #player2 , p2 , #player3 , p3 , #player4 , p4 , #player5 , p5 ] ;
3311: LD_ADDR_OWVAR 47
3315: PUSH
3316: LD_STRING #tick
3318: PUSH
3319: LD_EXP 5
3323: PUSH
3324: LD_STRING #player1
3326: PUSH
3327: LD_EXP 7
3331: PUSH
3332: LD_STRING #player2
3334: PUSH
3335: LD_EXP 8
3339: PUSH
3340: LD_STRING #player3
3342: PUSH
3343: LD_EXP 9
3347: PUSH
3348: LD_STRING #player4
3350: PUSH
3351: LD_EXP 10
3355: PUSH
3356: LD_STRING #player5
3358: PUSH
3359: LD_EXP 11
3363: PUSH
3364: EMPTY
3365: LIST
3366: LIST
3367: LIST
3368: LIST
3369: LIST
3370: LIST
3371: LIST
3372: LIST
3373: LIST
3374: LIST
3375: LIST
3376: LIST
3377: ST_TO_ADDR
// end ; end ;
3378: GO 3381
3380: POP
// end ;
3381: PPOPN 5
3383: END
// every 0 0$05 trigger time do var chance , p ;
3384: LD_EXP 5
3388: IFFALSE 3535
3390: GO 3392
3392: DISABLE
3393: LD_INT 0
3395: PPUSH
3396: PPUSH
// begin enable ;
3397: ENABLE
// Wait ( Rand ( 0 0$01 , 0 0$06 ) ) ;
3398: LD_INT 35
3400: PPUSH
3401: LD_INT 210
3403: PPUSH
3404: CALL_OW 12
3408: PPUSH
3409: CALL_OW 67
// if FilterAllUnits ( [ f_type , unit_vehicle ] ) < veh_amount then
3413: LD_INT 21
3415: PUSH
3416: LD_INT 2
3418: PUSH
3419: EMPTY
3420: LIST
3421: LIST
3422: PPUSH
3423: CALL_OW 69
3427: PUSH
3428: LD_EXP 6
3432: LESS
3433: IFFALSE 3535
// begin SpawnCar ( false , veh_spawn ) ;
3435: LD_INT 0
3437: PPUSH
3438: LD_INT 5
3440: PPUSH
3441: CALL 1110 0 2
// if sib_bomb and FilterAllUnits ( [ f_or , [ [ f_weapon , us_siberium_rocket ] , [ f_weapon , ru_siberium_rocket ] ] ] ) = 0 then
3445: LD_EXP 4
3449: PUSH
3450: LD_INT 2
3452: PUSH
3453: LD_INT 34
3455: PUSH
3456: LD_INT 8
3458: PUSH
3459: EMPTY
3460: LIST
3461: LIST
3462: PUSH
3463: LD_INT 34
3465: PUSH
3466: LD_INT 48
3468: PUSH
3469: EMPTY
3470: LIST
3471: LIST
3472: PUSH
3473: EMPTY
3474: LIST
3475: LIST
3476: PUSH
3477: EMPTY
3478: LIST
3479: LIST
3480: PPUSH
3481: CALL_OW 69
3485: PUSH
3486: LD_INT 0
3488: EQUAL
3489: AND
3490: IFFALSE 3535
// begin chance := 23 ;
3492: LD_ADDR_VAR 0 1
3496: PUSH
3497: LD_INT 23
3499: ST_TO_ADDR
// p := Rand ( 0 , 100 ) ;
3500: LD_ADDR_VAR 0 2
3504: PUSH
3505: LD_INT 0
3507: PPUSH
3508: LD_INT 100
3510: PPUSH
3511: CALL_OW 12
3515: ST_TO_ADDR
// if p < chance then
3516: LD_VAR 0 2
3520: PUSH
3521: LD_VAR 0 1
3525: LESS
3526: IFFALSE 3535
// SpawnSibRocket ( veh_spawn ) ;
3528: LD_INT 5
3530: PPUSH
3531: CALL 1948 0 1
// end ; end ; end ;
3535: PPOPN 2
3537: END
