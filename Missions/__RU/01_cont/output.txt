// starting begin InitMission ;
   0: CALL 5 0 0
// end ;
   4: END
// export gladstoneStatus ; export johannaStatus ; export introEnd , apemansContact , attackedByApeman , attackedByApemanNearLake ; export spotWaterfall ; export apemanAttackedBurlak , apemanWithRadio , radioDropPosition , apeWithRadioKiller ; export gnyevkoSaved , gnyevkoWaitWithPokryshkin , meetPokryshkin , goToHill ; export belkovWaitForGorky , secondAttack ; export traitor ; export gladstoneEscape , JohannaEscape ; export jelenaSaved ; export evacuationAvailable ; export lostComradesCounter ; export amRetreat ; export jelenaSpawned ; export achievement_JelenaTimer ; function InitMission ; begin
   5: LD_INT 0
   7: PPUSH
// ResetFog ;
   8: CALL_OW 335
// RandomizeAll ;
  12: CALL_OW 11
// InGameOn ;
  16: CALL_OW 8
// InitMapConfig ;
  20: CALL 298 0 0
// PrepareRussian ;
  24: CALL 12582 0 0
// PrepareAmericans ;
  28: CALL 12155 0 0
// PrepareNature ;
  32: CALL 13286 0 0
// gladstoneStatus = 1 ;
  36: LD_ADDR_EXP 1
  40: PUSH
  41: LD_INT 1
  43: ST_TO_ADDR
// johannaStatus = 1 ;
  44: LD_ADDR_EXP 2
  48: PUSH
  49: LD_INT 1
  51: ST_TO_ADDR
// introEnd = false ;
  52: LD_ADDR_EXP 3
  56: PUSH
  57: LD_INT 0
  59: ST_TO_ADDR
// apemansContact = false ;
  60: LD_ADDR_EXP 4
  64: PUSH
  65: LD_INT 0
  67: ST_TO_ADDR
// attackedByApeman = false ;
  68: LD_ADDR_EXP 5
  72: PUSH
  73: LD_INT 0
  75: ST_TO_ADDR
// spotWaterfall = false ;
  76: LD_ADDR_EXP 7
  80: PUSH
  81: LD_INT 0
  83: ST_TO_ADDR
// gnyevkoSaved = false ;
  84: LD_ADDR_EXP 12
  88: PUSH
  89: LD_INT 0
  91: ST_TO_ADDR
// meetPokryshkin = false ;
  92: LD_ADDR_EXP 14
  96: PUSH
  97: LD_INT 0
  99: ST_TO_ADDR
// goToHill = false ;
 100: LD_ADDR_EXP 15
 104: PUSH
 105: LD_INT 0
 107: ST_TO_ADDR
// gnyevkoWaitWithPokryshkin = false ;
 108: LD_ADDR_EXP 13
 112: PUSH
 113: LD_INT 0
 115: ST_TO_ADDR
// traitor = false ;
 116: LD_ADDR_EXP 18
 120: PUSH
 121: LD_INT 0
 123: ST_TO_ADDR
// gladstoneEscape = false ;
 124: LD_ADDR_EXP 19
 128: PUSH
 129: LD_INT 0
 131: ST_TO_ADDR
// JohannaEscape = false ;
 132: LD_ADDR_EXP 20
 136: PUSH
 137: LD_INT 0
 139: ST_TO_ADDR
// jelenaSaved = false ;
 140: LD_ADDR_EXP 21
 144: PUSH
 145: LD_INT 0
 147: ST_TO_ADDR
// belkovWaitForGorky = false ;
 148: LD_ADDR_EXP 16
 152: PUSH
 153: LD_INT 0
 155: ST_TO_ADDR
// evacuationAvailable = false ;
 156: LD_ADDR_EXP 22
 160: PUSH
 161: LD_INT 0
 163: ST_TO_ADDR
// amRetreat = false ;
 164: LD_ADDR_EXP 24
 168: PUSH
 169: LD_INT 0
 171: ST_TO_ADDR
// lostComradesCounter = 0 ;
 172: LD_ADDR_EXP 23
 176: PUSH
 177: LD_INT 0
 179: ST_TO_ADDR
// radioDropPosition = [ 999 , 999 ] ;
 180: LD_ADDR_EXP 10
 184: PUSH
 185: LD_INT 999
 187: PUSH
 188: LD_INT 999
 190: PUSH
 191: EMPTY
 192: LIST
 193: LIST
 194: ST_TO_ADDR
// apemanWithRadio = FilterUnitsInArea ( ApeLakeArea , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) [ Rand ( 1 , FilterUnitsInArea ( ApeLakeArea , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) ) ] ;
 195: LD_ADDR_EXP 9
 199: PUSH
 200: LD_INT 24
 202: PPUSH
 203: LD_INT 22
 205: PUSH
 206: LD_INT 0
 208: PUSH
 209: EMPTY
 210: LIST
 211: LIST
 212: PUSH
 213: LD_INT 25
 215: PUSH
 216: LD_INT 12
 218: PUSH
 219: EMPTY
 220: LIST
 221: LIST
 222: PUSH
 223: EMPTY
 224: LIST
 225: LIST
 226: PPUSH
 227: CALL_OW 70
 231: PUSH
 232: LD_INT 1
 234: PPUSH
 235: LD_INT 24
 237: PPUSH
 238: LD_INT 22
 240: PUSH
 241: LD_INT 0
 243: PUSH
 244: EMPTY
 245: LIST
 246: LIST
 247: PUSH
 248: LD_INT 25
 250: PUSH
 251: LD_INT 12
 253: PUSH
 254: EMPTY
 255: LIST
 256: LIST
 257: PUSH
 258: EMPTY
 259: LIST
 260: LIST
 261: PPUSH
 262: CALL_OW 70
 266: PPUSH
 267: CALL_OW 12
 271: ARRAY
 272: ST_TO_ADDR
// apeWithRadioKiller = 0 ;
 273: LD_ADDR_EXP 11
 277: PUSH
 278: LD_INT 0
 280: ST_TO_ADDR
// achievement_JelenaTimer = 0 0$00 ;
 281: LD_ADDR_EXP 26
 285: PUSH
 286: LD_INT 0
 288: ST_TO_ADDR
// MissionIntro ;
 289: CALL 854 0 0
// end ; end_of_file
 293: LD_VAR 0 1
 297: RET
// export function InitMapConfig ; begin
 298: LD_INT 0
 300: PPUSH
// BaseMapConfig ;
 301: CALL 314 0 0
// MissionMapConfig ;
 305: CALL 400 0 0
// end ;
 309: LD_VAR 0 1
 313: RET
// export animalsAmount , animalsStats , animalsAgression , missionPrefix , previousMissionPrefix , debugMode ; function BaseMapConfig ; begin
 314: LD_INT 0
 316: PPUSH
// animalsAmount = [ 5 , 4 , 2 , 2 ] ;
 317: LD_ADDR_EXP 27
 321: PUSH
 322: LD_INT 5
 324: PUSH
 325: LD_INT 4
 327: PUSH
 328: LD_INT 2
 330: PUSH
 331: LD_INT 2
 333: PUSH
 334: EMPTY
 335: LIST
 336: LIST
 337: LIST
 338: LIST
 339: ST_TO_ADDR
// animalsStats = [ 2 , 2 , 2 , 2 ] ;
 340: LD_ADDR_EXP 28
 344: PUSH
 345: LD_INT 2
 347: PUSH
 348: LD_INT 2
 350: PUSH
 351: LD_INT 2
 353: PUSH
 354: LD_INT 2
 356: PUSH
 357: EMPTY
 358: LIST
 359: LIST
 360: LIST
 361: LIST
 362: ST_TO_ADDR
// animalsAgression = 0 ;
 363: LD_ADDR_EXP 29
 367: PUSH
 368: LD_INT 0
 370: ST_TO_ADDR
// debugMode = 0 ;
 371: LD_ADDR_EXP 32
 375: PUSH
 376: LD_INT 0
 378: ST_TO_ADDR
// missionPrefix = 01_ ;
 379: LD_ADDR_EXP 30
 383: PUSH
 384: LD_STRING 01_
 386: ST_TO_ADDR
// previousMissionPrefix =  ;
 387: LD_ADDR_EXP 31
 391: PUSH
 392: LD_STRING 
 394: ST_TO_ADDR
// end ;
 395: LD_VAR 0 1
 399: RET
// export americanBunkerHP , apeAgression , amApeAmount , JohannadSkillLevel , burlakSpawnPosition , gnyevkoSpawnPositions , gnyevkoStartHP , apeAttackGnyevkoTime , apeAttackJelenaTime ; function MissionMapConfig ; begin
 400: LD_INT 0
 402: PPUSH
// americanBunkerHP = [ 800 , 900 , 950 ] [ Difficulty ] ;
 403: LD_ADDR_EXP 33
 407: PUSH
 408: LD_INT 800
 410: PUSH
 411: LD_INT 900
 413: PUSH
 414: LD_INT 950
 416: PUSH
 417: EMPTY
 418: LIST
 419: LIST
 420: LIST
 421: PUSH
 422: LD_OWVAR 67
 426: ARRAY
 427: ST_TO_ADDR
// apeAgression = rand ( 3 , 5 ) * Difficulty ;
 428: LD_ADDR_EXP 34
 432: PUSH
 433: LD_INT 3
 435: PPUSH
 436: LD_INT 5
 438: PPUSH
 439: CALL_OW 12
 443: PUSH
 444: LD_OWVAR 67
 448: MUL
 449: ST_TO_ADDR
// amApeAmount = [ 5 , 6 , 6 ] [ Difficulty ] ;
 450: LD_ADDR_EXP 35
 454: PUSH
 455: LD_INT 5
 457: PUSH
 458: LD_INT 6
 460: PUSH
 461: LD_INT 6
 463: PUSH
 464: EMPTY
 465: LIST
 466: LIST
 467: LIST
 468: PUSH
 469: LD_OWVAR 67
 473: ARRAY
 474: ST_TO_ADDR
// JohannadSkillLevel = [ 0 , 1 , 2 ] [ Difficulty ] ;
 475: LD_ADDR_EXP 36
 479: PUSH
 480: LD_INT 0
 482: PUSH
 483: LD_INT 1
 485: PUSH
 486: LD_INT 2
 488: PUSH
 489: EMPTY
 490: LIST
 491: LIST
 492: LIST
 493: PUSH
 494: LD_OWVAR 67
 498: ARRAY
 499: ST_TO_ADDR
// burlakSpawnPosition = [ 78 , 87 ] ;
 500: LD_ADDR_EXP 37
 504: PUSH
 505: LD_INT 78
 507: PUSH
 508: LD_INT 87
 510: PUSH
 511: EMPTY
 512: LIST
 513: LIST
 514: ST_TO_ADDR
// gnyevkoSpawnPositions = [ [ 72 , 115 ] , [ 99 , 7 ] , [ 131 , 81 ] ] ;
 515: LD_ADDR_EXP 38
 519: PUSH
 520: LD_INT 72
 522: PUSH
 523: LD_INT 115
 525: PUSH
 526: EMPTY
 527: LIST
 528: LIST
 529: PUSH
 530: LD_INT 99
 532: PUSH
 533: LD_INT 7
 535: PUSH
 536: EMPTY
 537: LIST
 538: LIST
 539: PUSH
 540: LD_INT 131
 542: PUSH
 543: LD_INT 81
 545: PUSH
 546: EMPTY
 547: LIST
 548: LIST
 549: PUSH
 550: EMPTY
 551: LIST
 552: LIST
 553: LIST
 554: ST_TO_ADDR
// gnyevkoStartHP = [ 500 , 400 , 350 ] [ Difficulty ] ;
 555: LD_ADDR_EXP 39
 559: PUSH
 560: LD_INT 500
 562: PUSH
 563: LD_INT 400
 565: PUSH
 566: LD_INT 350
 568: PUSH
 569: EMPTY
 570: LIST
 571: LIST
 572: LIST
 573: PUSH
 574: LD_OWVAR 67
 578: ARRAY
 579: ST_TO_ADDR
// apeAttackGnyevkoTime = [ 10 10$0 , 8 8$0 , 6 6$0 ] [ Difficulty ] ;
 580: LD_ADDR_EXP 40
 584: PUSH
 585: LD_INT 21000
 587: PUSH
 588: LD_INT 16800
 590: PUSH
 591: LD_INT 12600
 593: PUSH
 594: EMPTY
 595: LIST
 596: LIST
 597: LIST
 598: PUSH
 599: LD_OWVAR 67
 603: ARRAY
 604: ST_TO_ADDR
// apeAttackJelenaTime = [ 3 3$00 , 2 2$30 , 2 2$00 ] [ Difficulty ] ;
 605: LD_ADDR_EXP 41
 609: PUSH
 610: LD_INT 6300
 612: PUSH
 613: LD_INT 5250
 615: PUSH
 616: LD_INT 4200
 618: PUSH
 619: EMPTY
 620: LIST
 621: LIST
 622: LIST
 623: PUSH
 624: LD_OWVAR 67
 628: ARRAY
 629: ST_TO_ADDR
// end ;
 630: LD_VAR 0 1
 634: RET
// every 0 0$1 trigger debugMode do var i ;
 635: LD_EXP 32
 639: IFFALSE 851
 641: GO 643
 643: DISABLE
 644: LD_INT 0
 646: PPUSH
// begin enable ;
 647: ENABLE
// FogOff ( your_side ) ;
 648: LD_OWVAR 2
 652: PPUSH
 653: CALL_OW 344
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) do
 657: LD_ADDR_VAR 0 1
 661: PUSH
 662: LD_INT 22
 664: PUSH
 665: LD_OWVAR 2
 669: PUSH
 670: EMPTY
 671: LIST
 672: LIST
 673: PUSH
 674: LD_INT 2
 676: PUSH
 677: LD_INT 21
 679: PUSH
 680: LD_INT 1
 682: PUSH
 683: EMPTY
 684: LIST
 685: LIST
 686: PUSH
 687: LD_INT 21
 689: PUSH
 690: LD_INT 2
 692: PUSH
 693: EMPTY
 694: LIST
 695: LIST
 696: PUSH
 697: EMPTY
 698: LIST
 699: LIST
 700: LIST
 701: PUSH
 702: EMPTY
 703: LIST
 704: LIST
 705: PPUSH
 706: CALL_OW 69
 710: PUSH
 711: FOR_IN
 712: IFFALSE 728
// SetLives ( i , 1000 ) ;
 714: LD_VAR 0 1
 718: PPUSH
 719: LD_INT 1000
 721: PPUSH
 722: CALL_OW 234
 726: GO 711
 728: POP
 729: POP
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) do
 730: LD_ADDR_VAR 0 1
 734: PUSH
 735: LD_INT 22
 737: PUSH
 738: LD_OWVAR 2
 742: PUSH
 743: EMPTY
 744: LIST
 745: LIST
 746: PUSH
 747: LD_INT 2
 749: PUSH
 750: LD_INT 30
 752: PUSH
 753: LD_INT 0
 755: PUSH
 756: EMPTY
 757: LIST
 758: LIST
 759: PUSH
 760: LD_INT 30
 762: PUSH
 763: LD_INT 1
 765: PUSH
 766: EMPTY
 767: LIST
 768: LIST
 769: PUSH
 770: EMPTY
 771: LIST
 772: LIST
 773: LIST
 774: PUSH
 775: EMPTY
 776: LIST
 777: LIST
 778: PPUSH
 779: CALL_OW 69
 783: PUSH
 784: FOR_IN
 785: IFFALSE 849
// begin SetResourceType ( GetBase ( i ) , mat_cans , 9999 ) ;
 787: LD_VAR 0 1
 791: PPUSH
 792: CALL_OW 274
 796: PPUSH
 797: LD_INT 1
 799: PPUSH
 800: LD_INT 9999
 802: PPUSH
 803: CALL_OW 277
// SetResourceType ( GetBase ( i ) , mat_oil , 9999 ) ;
 807: LD_VAR 0 1
 811: PPUSH
 812: CALL_OW 274
 816: PPUSH
 817: LD_INT 2
 819: PPUSH
 820: LD_INT 9999
 822: PPUSH
 823: CALL_OW 277
// SetResourceType ( GetBase ( i ) , mat_siberit , 9999 ) ;
 827: LD_VAR 0 1
 831: PPUSH
 832: CALL_OW 274
 836: PPUSH
 837: LD_INT 3
 839: PPUSH
 840: LD_INT 9999
 842: PPUSH
 843: CALL_OW 277
// end ;
 847: GO 784
 849: POP
 850: POP
// end ; end_of_file
 851: PPOPN 1
 853: END
// export function MissionIntro ; begin
 854: LD_INT 0
 856: PPUSH
// InGameOn ;
 857: CALL_OW 8
// CenterOnXY ( burlakSpawnPosition [ 1 ] - 8 , burlakSpawnPosition [ 2 ] - 8 ) ;
 861: LD_EXP 37
 865: PUSH
 866: LD_INT 1
 868: ARRAY
 869: PUSH
 870: LD_INT 8
 872: MINUS
 873: PPUSH
 874: LD_EXP 37
 878: PUSH
 879: LD_INT 2
 881: ARRAY
 882: PUSH
 883: LD_INT 8
 885: MINUS
 886: PPUSH
 887: CALL_OW 84
// wait ( 0 0$3 ) ;
 891: LD_INT 105
 893: PPUSH
 894: CALL_OW 67
// CenterNowOnUnits ( Burlak ) ;
 898: LD_EXP 46
 902: PPUSH
 903: CALL_OW 87
// Say ( Burlak , D1-Bur-1 ) ;
 907: LD_EXP 46
 911: PPUSH
 912: LD_STRING D1-Bur-1
 914: PPUSH
 915: CALL_OW 88
// ComMoveXY ( Burlak , 94 , 89 ) ;
 919: LD_EXP 46
 923: PPUSH
 924: LD_INT 94
 926: PPUSH
 927: LD_INT 89
 929: PPUSH
 930: CALL_OW 111
// CenterOnXY ( 94 , 89 ) ;
 934: LD_INT 94
 936: PPUSH
 937: LD_INT 89
 939: PPUSH
 940: CALL_OW 84
// Say ( Burlak , D1-Bur-1a ) ;
 944: LD_EXP 46
 948: PPUSH
 949: LD_STRING D1-Bur-1a
 951: PPUSH
 952: CALL_OW 88
// ComMoveXY ( Burlak , 102 , 88 ) ;
 956: LD_EXP 46
 960: PPUSH
 961: LD_INT 102
 963: PPUSH
 964: LD_INT 88
 966: PPUSH
 967: CALL_OW 111
// CenterOnXY ( 102 , 88 ) ;
 971: LD_INT 102
 973: PPUSH
 974: LD_INT 88
 976: PPUSH
 977: CALL_OW 84
// Say ( Burlak , D1-Bur-1b ) ;
 981: LD_EXP 46
 985: PPUSH
 986: LD_STRING D1-Bur-1b
 988: PPUSH
 989: CALL_OW 88
// InGameOff ;
 993: CALL_OW 9
// ChangeMissionObjectives ( M1 ) ;
 997: LD_STRING M1
 999: PPUSH
1000: CALL_OW 337
// SaveForQuickRestart ;
1004: CALL_OW 22
// introEnd = true ;
1008: LD_ADDR_EXP 3
1012: PUSH
1013: LD_INT 1
1015: ST_TO_ADDR
// end ;
1016: LD_VAR 0 1
1020: RET
// every 0 0$1 trigger GetDistUnitXY ( Burlak , 74 , 88 ) < 5 and introEnd do
1021: LD_EXP 46
1025: PPUSH
1026: LD_INT 74
1028: PPUSH
1029: LD_INT 88
1031: PPUSH
1032: CALL_OW 297
1036: PUSH
1037: LD_INT 5
1039: LESS
1040: PUSH
1041: LD_EXP 3
1045: AND
1046: IFFALSE 1071
1048: GO 1050
1050: DISABLE
// begin spotWaterfall = true ;
1051: LD_ADDR_EXP 7
1055: PUSH
1056: LD_INT 1
1058: ST_TO_ADDR
// Say ( Burlak , DWaterfall-Bur-1 ) ;
1059: LD_EXP 46
1063: PPUSH
1064: LD_STRING DWaterfall-Bur-1
1066: PPUSH
1067: CALL_OW 88
// end ;
1071: END
// every 0 0$1 trigger GetDistUnitXY ( Burlak , 130 , 96 ) < 5 and introEnd do
1072: LD_EXP 46
1076: PPUSH
1077: LD_INT 130
1079: PPUSH
1080: LD_INT 96
1082: PPUSH
1083: CALL_OW 297
1087: PUSH
1088: LD_INT 5
1090: LESS
1091: PUSH
1092: LD_EXP 3
1096: AND
1097: IFFALSE 1114
1099: GO 1101
1101: DISABLE
// Say ( Burlak , DCorpse-Bur-1 ) ;
1102: LD_EXP 46
1106: PPUSH
1107: LD_STRING DCorpse-Bur-1
1109: PPUSH
1110: CALL_OW 88
1114: END
// every 0 0$1 trigger not apemansContact do var apeman ;
1115: LD_EXP 4
1119: NOT
1120: IFFALSE 1214
1122: GO 1124
1124: DISABLE
1125: LD_INT 0
1127: PPUSH
// begin enable ;
1128: ENABLE
// for apeman in FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) do
1129: LD_ADDR_VAR 0 1
1133: PUSH
1134: LD_INT 22
1136: PUSH
1137: LD_INT 0
1139: PUSH
1140: EMPTY
1141: LIST
1142: LIST
1143: PUSH
1144: LD_INT 25
1146: PUSH
1147: LD_INT 12
1149: PUSH
1150: EMPTY
1151: LIST
1152: LIST
1153: PUSH
1154: EMPTY
1155: LIST
1156: LIST
1157: PPUSH
1158: CALL_OW 69
1162: PUSH
1163: FOR_IN
1164: IFFALSE 1212
// if GetDistUnits ( apeman , Burlak ) < 7 then
1166: LD_VAR 0 1
1170: PPUSH
1171: LD_EXP 46
1175: PPUSH
1176: CALL_OW 296
1180: PUSH
1181: LD_INT 7
1183: LESS
1184: IFFALSE 1210
// begin apemansContact = true ;
1186: LD_ADDR_EXP 4
1190: PUSH
1191: LD_INT 1
1193: ST_TO_ADDR
// Say ( Burlak , D2-Bur-1 ) ;
1194: LD_EXP 46
1198: PPUSH
1199: LD_STRING D2-Bur-1
1201: PPUSH
1202: CALL_OW 88
// exit ;
1206: POP
1207: POP
1208: GO 1214
// end ;
1210: GO 1163
1212: POP
1213: POP
// end ;
1214: PPOPN 1
1216: END
// every 0 0$1 trigger not attackedByApeman do var un , apeman ;
1217: LD_EXP 5
1221: NOT
1222: IFFALSE 1338
1224: GO 1226
1226: DISABLE
1227: LD_INT 0
1229: PPUSH
1230: PPUSH
// begin enable ;
1231: ENABLE
// for apeman in FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) do
1232: LD_ADDR_VAR 0 2
1236: PUSH
1237: LD_INT 22
1239: PUSH
1240: LD_INT 0
1242: PUSH
1243: EMPTY
1244: LIST
1245: LIST
1246: PUSH
1247: LD_INT 25
1249: PUSH
1250: LD_INT 12
1252: PUSH
1253: EMPTY
1254: LIST
1255: LIST
1256: PUSH
1257: EMPTY
1258: LIST
1259: LIST
1260: PPUSH
1261: CALL_OW 69
1265: PUSH
1266: FOR_IN
1267: IFFALSE 1336
// if Attacks ( apeman ) then
1269: LD_VAR 0 2
1273: PPUSH
1274: CALL_OW 320
1278: IFFALSE 1334
// if GetSide ( Attacks ( apeman ) ) = 3 then
1280: LD_VAR 0 2
1284: PPUSH
1285: CALL_OW 320
1289: PPUSH
1290: CALL_OW 255
1294: PUSH
1295: LD_INT 3
1297: EQUAL
1298: IFFALSE 1334
// begin attackedByApeman = true ;
1300: LD_ADDR_EXP 5
1304: PUSH
1305: LD_INT 1
1307: ST_TO_ADDR
// apemanAttackedBurlak = apeman ;
1308: LD_ADDR_EXP 8
1312: PUSH
1313: LD_VAR 0 2
1317: ST_TO_ADDR
// Say ( Burlak , D2-Bur-1a ) ;
1318: LD_EXP 46
1322: PPUSH
1323: LD_STRING D2-Bur-1a
1325: PPUSH
1326: CALL_OW 88
// exit ;
1330: POP
1331: POP
1332: GO 1338
// end ;
1334: GO 1266
1336: POP
1337: POP
// end ;
1338: PPOPN 2
1340: END
// every 0 0$1 trigger not attackedByApemanNearLake do var un , apeman ;
1341: LD_EXP 6
1345: NOT
1346: IFFALSE 1443
1348: GO 1350
1350: DISABLE
1351: LD_INT 0
1353: PPUSH
1354: PPUSH
// begin enable ;
1355: ENABLE
// for apeman in FilterUnitsInArea ( ApeLakeArea , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) do
1356: LD_ADDR_VAR 0 2
1360: PUSH
1361: LD_INT 24
1363: PPUSH
1364: LD_INT 22
1366: PUSH
1367: LD_INT 0
1369: PUSH
1370: EMPTY
1371: LIST
1372: LIST
1373: PUSH
1374: LD_INT 25
1376: PUSH
1377: LD_INT 12
1379: PUSH
1380: EMPTY
1381: LIST
1382: LIST
1383: PUSH
1384: EMPTY
1385: LIST
1386: LIST
1387: PPUSH
1388: CALL_OW 70
1392: PUSH
1393: FOR_IN
1394: IFFALSE 1441
// if Attacks ( apeman ) then
1396: LD_VAR 0 2
1400: PPUSH
1401: CALL_OW 320
1405: IFFALSE 1439
// if GetSide ( Attacks ( apeman ) ) = 3 then
1407: LD_VAR 0 2
1411: PPUSH
1412: CALL_OW 320
1416: PPUSH
1417: CALL_OW 255
1421: PUSH
1422: LD_INT 3
1424: EQUAL
1425: IFFALSE 1439
// begin attackedByApemanNearLake = true ;
1427: LD_ADDR_EXP 6
1431: PUSH
1432: LD_INT 1
1434: ST_TO_ADDR
// exit ;
1435: POP
1436: POP
1437: GO 1443
// end ;
1439: GO 1393
1441: POP
1442: POP
// end ;
1443: PPOPN 2
1445: END
// every 1 trigger IsDying ( apemanWithRadio ) do
1446: LD_EXP 9
1450: PPUSH
1451: CALL_OW 303
1455: IFFALSE 1489
1457: GO 1459
1459: DISABLE
// radioDropPosition = [ GetX ( apemanWithRadio ) , GetY ( apemanWithRadio ) ] ;
1460: LD_ADDR_EXP 10
1464: PUSH
1465: LD_EXP 9
1469: PPUSH
1470: CALL_OW 250
1474: PUSH
1475: LD_EXP 9
1479: PPUSH
1480: CALL_OW 251
1484: PUSH
1485: EMPTY
1486: LIST
1487: LIST
1488: ST_TO_ADDR
1489: END
// every 0 0$1 trigger IsDying ( apemanWithRadio ) and SeeXY ( 3 , radioDropPosition [ 1 ] , radioDropPosition [ 2 ] ) do var nearUnit ;
1490: LD_EXP 9
1494: PPUSH
1495: CALL_OW 303
1499: PUSH
1500: LD_INT 3
1502: PPUSH
1503: LD_EXP 10
1507: PUSH
1508: LD_INT 1
1510: ARRAY
1511: PPUSH
1512: LD_EXP 10
1516: PUSH
1517: LD_INT 2
1519: ARRAY
1520: PPUSH
1521: CALL_OW 293
1525: AND
1526: IFFALSE 1910
1528: GO 1530
1530: DISABLE
1531: LD_INT 0
1533: PPUSH
// begin wait ( 0 0$2 ) ;
1534: LD_INT 70
1536: PPUSH
1537: CALL_OW 67
// Say ( Burlak , D2a-Bur-1 ) ;
1541: LD_EXP 46
1545: PPUSH
1546: LD_STRING D2a-Bur-1
1548: PPUSH
1549: CALL_OW 88
// if FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) = 1 then
1553: LD_INT 22
1555: PUSH
1556: LD_INT 3
1558: PUSH
1559: EMPTY
1560: LIST
1561: LIST
1562: PUSH
1563: LD_INT 21
1565: PUSH
1566: LD_INT 1
1568: PUSH
1569: EMPTY
1570: LIST
1571: LIST
1572: PUSH
1573: EMPTY
1574: LIST
1575: LIST
1576: PPUSH
1577: CALL_OW 69
1581: PUSH
1582: LD_INT 1
1584: EQUAL
1585: IFFALSE 1601
// Say ( Burlak , D2a-Bur-2 ) else
1587: LD_EXP 46
1591: PPUSH
1592: LD_STRING D2a-Bur-2
1594: PPUSH
1595: CALL_OW 88
1599: GO 1910
// begin nearUnit = NearestUnitToXY ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) diff [ Burlak , Gnyevko ] , radioDropPosition [ 1 ] , radioDropPosition [ 2 ] ) ;
1601: LD_ADDR_VAR 0 1
1605: PUSH
1606: LD_INT 22
1608: PUSH
1609: LD_INT 3
1611: PUSH
1612: EMPTY
1613: LIST
1614: LIST
1615: PUSH
1616: LD_INT 21
1618: PUSH
1619: LD_INT 1
1621: PUSH
1622: EMPTY
1623: LIST
1624: LIST
1625: PUSH
1626: EMPTY
1627: LIST
1628: LIST
1629: PPUSH
1630: CALL_OW 69
1634: PUSH
1635: LD_EXP 46
1639: PUSH
1640: LD_EXP 54
1644: PUSH
1645: EMPTY
1646: LIST
1647: LIST
1648: DIFF
1649: PPUSH
1650: LD_EXP 10
1654: PUSH
1655: LD_INT 1
1657: ARRAY
1658: PPUSH
1659: LD_EXP 10
1663: PUSH
1664: LD_INT 2
1666: ARRAY
1667: PPUSH
1668: CALL_OW 73
1672: ST_TO_ADDR
// apeWithRadioKiller = nearUnit ;
1673: LD_ADDR_EXP 11
1677: PUSH
1678: LD_VAR 0 1
1682: ST_TO_ADDR
// ComMoveXY ( nearUnit , radioDropPosition [ 1 ] , radioDropPosition [ 2 ] ) ;
1683: LD_VAR 0 1
1687: PPUSH
1688: LD_EXP 10
1692: PUSH
1693: LD_INT 1
1695: ARRAY
1696: PPUSH
1697: LD_EXP 10
1701: PUSH
1702: LD_INT 2
1704: ARRAY
1705: PPUSH
1706: CALL_OW 111
// case nearUnit of Belkov :
1710: LD_VAR 0 1
1714: PUSH
1715: LD_EXP 51
1719: DOUBLE
1720: EQUAL
1721: IFTRUE 1725
1723: GO 1740
1725: POP
// Say ( Belkov , D2a-Bel-1 ) ; Kirilenkova :
1726: LD_EXP 51
1730: PPUSH
1731: LD_STRING D2a-Bel-1
1733: PPUSH
1734: CALL_OW 88
1738: GO 1807
1740: LD_EXP 53
1744: DOUBLE
1745: EQUAL
1746: IFTRUE 1750
1748: GO 1765
1750: POP
// Say ( Kirilenkova , D2a-Kir-1 ) ; else
1751: LD_EXP 53
1755: PPUSH
1756: LD_STRING D2a-Kir-1
1758: PPUSH
1759: CALL_OW 88
1763: GO 1807
1765: POP
// if GetSex ( nearUnit ) = sex_male then
1766: LD_VAR 0 1
1770: PPUSH
1771: CALL_OW 258
1775: PUSH
1776: LD_INT 1
1778: EQUAL
1779: IFFALSE 1795
// Say ( nearUnit , D2a-RSol1-1 ) else
1781: LD_VAR 0 1
1785: PPUSH
1786: LD_STRING D2a-RSol1-1
1788: PPUSH
1789: CALL_OW 88
1793: GO 1807
// Say ( nearUnit , D2a-RFSol1-1 ) ; end ;
1795: LD_VAR 0 1
1799: PPUSH
1800: LD_STRING D2a-RFSol1-1
1802: PPUSH
1803: CALL_OW 88
// if ( GetSide ( Gnyevko ) = 3 and IsOK ( Gnyevko ) ) then
1807: LD_EXP 54
1811: PPUSH
1812: CALL_OW 255
1816: PUSH
1817: LD_INT 3
1819: EQUAL
1820: PUSH
1821: LD_EXP 54
1825: PPUSH
1826: CALL_OW 302
1830: AND
1831: IFFALSE 1845
// Say ( Gnyevko , D2a-Gny-1 ) ;
1833: LD_EXP 54
1837: PPUSH
1838: LD_STRING D2a-Gny-1
1840: PPUSH
1841: CALL_OW 88
// if ( GetSide ( Gnyevko ) = 8 ) then
1845: LD_EXP 54
1849: PPUSH
1850: CALL_OW 255
1854: PUSH
1855: LD_INT 8
1857: EQUAL
1858: IFFALSE 1910
// begin Say ( Burlak , D12-Bur-1 ) ;
1860: LD_EXP 46
1864: PPUSH
1865: LD_STRING D12-Bur-1
1867: PPUSH
1868: CALL_OW 88
// if GetSide ( Belkov ) = 3 and IsOK ( Belkov ) then
1872: LD_EXP 51
1876: PPUSH
1877: CALL_OW 255
1881: PUSH
1882: LD_INT 3
1884: EQUAL
1885: PUSH
1886: LD_EXP 51
1890: PPUSH
1891: CALL_OW 302
1895: AND
1896: IFFALSE 1910
// Say ( Belkov , D12-Bel-2 ) ;
1898: LD_EXP 51
1902: PPUSH
1903: LD_STRING D12-Bel-2
1905: PPUSH
1906: CALL_OW 88
// end ; end ; end ;
1910: PPOPN 1
1912: END
// every 1 trigger not gnyevkoSaved and apeAttackGnyevkoTime > 0 0$02 do
1913: LD_EXP 12
1917: NOT
1918: PUSH
1919: LD_EXP 40
1923: PUSH
1924: LD_INT 70
1926: GREATER
1927: AND
1928: IFFALSE 1948
1930: GO 1932
1932: DISABLE
// begin enable ;
1933: ENABLE
// SetLives ( Gnyevko , gnyevkoStartHP ) ;
1934: LD_EXP 54
1938: PPUSH
1939: LD_EXP 39
1943: PPUSH
1944: CALL_OW 234
// end ;
1948: END
// every 0 0$1 trigger See ( 3 , Gnyevko ) do var nearUnit , randomUnit ;
1949: LD_INT 3
1951: PPUSH
1952: LD_EXP 54
1956: PPUSH
1957: CALL_OW 292
1961: IFFALSE 2573
1963: GO 1965
1965: DISABLE
1966: LD_INT 0
1968: PPUSH
1969: PPUSH
// begin CenterNowOnUnits ( Gnyevko ) ;
1970: LD_EXP 54
1974: PPUSH
1975: CALL_OW 87
// DialogueOn ;
1979: CALL_OW 6
// nearUnit = NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) , Gnyevko ) ;
1983: LD_ADDR_VAR 0 1
1987: PUSH
1988: LD_INT 22
1990: PUSH
1991: LD_INT 3
1993: PUSH
1994: EMPTY
1995: LIST
1996: LIST
1997: PUSH
1998: LD_INT 21
2000: PUSH
2001: LD_INT 1
2003: PUSH
2004: EMPTY
2005: LIST
2006: LIST
2007: PUSH
2008: EMPTY
2009: LIST
2010: LIST
2011: PPUSH
2012: CALL_OW 69
2016: PPUSH
2017: LD_EXP 54
2021: PPUSH
2022: CALL_OW 74
2026: ST_TO_ADDR
// if nearUnit = Burlak then
2027: LD_VAR 0 1
2031: PUSH
2032: LD_EXP 46
2036: EQUAL
2037: IFFALSE 2399
// begin Say ( Burlak , D3-Bur-1 ) ;
2039: LD_EXP 46
2043: PPUSH
2044: LD_STRING D3-Bur-1
2046: PPUSH
2047: CALL_OW 88
// Say ( Gnyevko , D3-Gny-1 ) ;
2051: LD_EXP 54
2055: PPUSH
2056: LD_STRING D3-Gny-1
2058: PPUSH
2059: CALL_OW 88
// if apeWithRadioKiller then
2063: LD_EXP 11
2067: IFFALSE 2107
// begin if apeWithRadioKiller = Burlak then
2069: LD_EXP 11
2073: PUSH
2074: LD_EXP 46
2078: EQUAL
2079: IFFALSE 2095
// Say ( Burlak , D3-Bur-2 ) else
2081: LD_EXP 46
2085: PPUSH
2086: LD_STRING D3-Bur-2
2088: PPUSH
2089: CALL_OW 88
2093: GO 2107
// Say ( Burlak , D3-Bur-2a ) ;
2095: LD_EXP 46
2099: PPUSH
2100: LD_STRING D3-Bur-2a
2102: PPUSH
2103: CALL_OW 88
// end ; Say ( Burlak , D3-Bur-2b ) ;
2107: LD_EXP 46
2111: PPUSH
2112: LD_STRING D3-Bur-2b
2114: PPUSH
2115: CALL_OW 88
// if FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) = 1 and not meetPokryshkin then
2119: LD_INT 22
2121: PUSH
2122: LD_INT 3
2124: PUSH
2125: EMPTY
2126: LIST
2127: LIST
2128: PUSH
2129: LD_INT 21
2131: PUSH
2132: LD_INT 1
2134: PUSH
2135: EMPTY
2136: LIST
2137: LIST
2138: PUSH
2139: EMPTY
2140: LIST
2141: LIST
2142: PPUSH
2143: CALL_OW 69
2147: PUSH
2148: LD_INT 1
2150: EQUAL
2151: PUSH
2152: LD_EXP 14
2156: NOT
2157: AND
2158: IFFALSE 2210
// begin Say ( Burlak , D3-Bur-2c ) ;
2160: LD_EXP 46
2164: PPUSH
2165: LD_STRING D3-Bur-2c
2167: PPUSH
2168: CALL_OW 88
// Say ( Gnyevko , D3-Gny-2 ) ;
2172: LD_EXP 54
2176: PPUSH
2177: LD_STRING D3-Gny-2
2179: PPUSH
2180: CALL_OW 88
// DialogueOff ;
2184: CALL_OW 7
// SetSide ( Gnyevko , 3 ) ;
2188: LD_EXP 54
2192: PPUSH
2193: LD_INT 3
2195: PPUSH
2196: CALL_OW 235
// gnyevkoSaved = true ;
2200: LD_ADDR_EXP 12
2204: PUSH
2205: LD_INT 1
2207: ST_TO_ADDR
// exit ;
2208: GO 2573
// end ; if ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) > 1 or meetPokryshkin ) and not evacuationAvailable then
2210: LD_INT 22
2212: PUSH
2213: LD_INT 3
2215: PUSH
2216: EMPTY
2217: LIST
2218: LIST
2219: PUSH
2220: LD_INT 21
2222: PUSH
2223: LD_INT 1
2225: PUSH
2226: EMPTY
2227: LIST
2228: LIST
2229: PUSH
2230: EMPTY
2231: LIST
2232: LIST
2233: PPUSH
2234: CALL_OW 69
2238: PUSH
2239: LD_INT 1
2241: GREATER
2242: PUSH
2243: LD_EXP 14
2247: OR
2248: PUSH
2249: LD_EXP 22
2253: NOT
2254: AND
2255: IFFALSE 2307
// begin Say ( Burlak , D3-Bur-2d ) ;
2257: LD_EXP 46
2261: PPUSH
2262: LD_STRING D3-Bur-2d
2264: PPUSH
2265: CALL_OW 88
// Say ( Gnyevko , D3-Gny-2 ) ;
2269: LD_EXP 54
2273: PPUSH
2274: LD_STRING D3-Gny-2
2276: PPUSH
2277: CALL_OW 88
// DialogueOff ;
2281: CALL_OW 7
// SetSide ( Gnyevko , 3 ) ;
2285: LD_EXP 54
2289: PPUSH
2290: LD_INT 3
2292: PPUSH
2293: CALL_OW 235
// gnyevkoSaved = true ;
2297: LD_ADDR_EXP 12
2301: PUSH
2302: LD_INT 1
2304: ST_TO_ADDR
// exit ;
2305: GO 2573
// end ; if FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) > 1 and evacuationAvailable then
2307: LD_INT 22
2309: PUSH
2310: LD_INT 3
2312: PUSH
2313: EMPTY
2314: LIST
2315: LIST
2316: PUSH
2317: LD_INT 21
2319: PUSH
2320: LD_INT 1
2322: PUSH
2323: EMPTY
2324: LIST
2325: LIST
2326: PUSH
2327: EMPTY
2328: LIST
2329: LIST
2330: PPUSH
2331: CALL_OW 69
2335: PUSH
2336: LD_INT 1
2338: GREATER
2339: PUSH
2340: LD_EXP 22
2344: AND
2345: IFFALSE 2397
// begin Say ( Burlak , D3-Bur-2e ) ;
2347: LD_EXP 46
2351: PPUSH
2352: LD_STRING D3-Bur-2e
2354: PPUSH
2355: CALL_OW 88
// Say ( Gnyevko , D3-Gny-2 ) ;
2359: LD_EXP 54
2363: PPUSH
2364: LD_STRING D3-Gny-2
2366: PPUSH
2367: CALL_OW 88
// DialogueOff ;
2371: CALL_OW 7
// SetSide ( Gnyevko , 3 ) ;
2375: LD_EXP 54
2379: PPUSH
2380: LD_INT 3
2382: PPUSH
2383: CALL_OW 235
// gnyevkoSaved = true ;
2387: LD_ADDR_EXP 12
2391: PUSH
2392: LD_INT 1
2394: ST_TO_ADDR
// exit ;
2395: GO 2573
// end ; end else
2397: GO 2573
// begin if GetSex ( nearUnit ) = sex_male then
2399: LD_VAR 0 1
2403: PPUSH
2404: CALL_OW 258
2408: PUSH
2409: LD_INT 1
2411: EQUAL
2412: IFFALSE 2428
// Say ( nearUnit , D3-RSol1-1 ) else
2414: LD_VAR 0 1
2418: PPUSH
2419: LD_STRING D3-RSol1-1
2421: PPUSH
2422: CALL_OW 88
2426: GO 2440
// Say ( nearUnit , D3-RFSol1-1 ) ;
2428: LD_VAR 0 1
2432: PPUSH
2433: LD_STRING D3-RFSol1-1
2435: PPUSH
2436: CALL_OW 88
// Say ( Gnyevko , D3-Gny-1 ) ;
2440: LD_EXP 54
2444: PPUSH
2445: LD_STRING D3-Gny-1
2447: PPUSH
2448: CALL_OW 88
// if apeWithRadioKiller then
2452: LD_EXP 11
2456: IFFALSE 2496
// begin if apeWithRadioKiller = Burlak then
2458: LD_EXP 11
2462: PUSH
2463: LD_EXP 46
2467: EQUAL
2468: IFFALSE 2484
// Say ( Burlak , D3-Bur-2 ) else
2470: LD_EXP 46
2474: PPUSH
2475: LD_STRING D3-Bur-2
2477: PPUSH
2478: CALL_OW 88
2482: GO 2496
// Say ( Burlak , D3-Bur-2a ) ;
2484: LD_EXP 46
2488: PPUSH
2489: LD_STRING D3-Bur-2a
2491: PPUSH
2492: CALL_OW 88
// end ; if GetSex ( nearUnit ) = sex_male then
2496: LD_VAR 0 1
2500: PPUSH
2501: CALL_OW 258
2505: PUSH
2506: LD_INT 1
2508: EQUAL
2509: IFFALSE 2525
// Say ( nearUnit , D3-RSol1-2 ) else
2511: LD_VAR 0 1
2515: PPUSH
2516: LD_STRING D3-RSol1-2
2518: PPUSH
2519: CALL_OW 88
2523: GO 2537
// Say ( nearUnit , D3-RFSol1-2 ) ;
2525: LD_VAR 0 1
2529: PPUSH
2530: LD_STRING D3-RFSol1-2
2532: PPUSH
2533: CALL_OW 88
// Say ( Gnyevko , D3-Gny-2a ) ;
2537: LD_EXP 54
2541: PPUSH
2542: LD_STRING D3-Gny-2a
2544: PPUSH
2545: CALL_OW 88
// DialogueOff ;
2549: CALL_OW 7
// SetSide ( Gnyevko , 3 ) ;
2553: LD_EXP 54
2557: PPUSH
2558: LD_INT 3
2560: PPUSH
2561: CALL_OW 235
// gnyevkoSaved = true ;
2565: LD_ADDR_EXP 12
2569: PUSH
2570: LD_INT 1
2572: ST_TO_ADDR
// end ; end ;
2573: PPOPN 2
2575: END
// every 1 trigger not gnyevkoSaved or not jelenaSaved do var ape ;
2576: LD_EXP 12
2580: NOT
2581: PUSH
2582: LD_EXP 21
2586: NOT
2587: OR
2588: IFFALSE 2783
2590: GO 2592
2592: DISABLE
2593: LD_INT 0
2595: PPUSH
// begin enable ;
2596: ENABLE
// if not gnyevkoSaved and apeAttackGnyevkoTime > 0 0$02 then
2597: LD_EXP 12
2601: NOT
2602: PUSH
2603: LD_EXP 40
2607: PUSH
2608: LD_INT 70
2610: GREATER
2611: AND
2612: IFFALSE 2690
// for ape in FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) do
2614: LD_ADDR_VAR 0 1
2618: PUSH
2619: LD_INT 22
2621: PUSH
2622: LD_INT 0
2624: PUSH
2625: EMPTY
2626: LIST
2627: LIST
2628: PUSH
2629: LD_INT 25
2631: PUSH
2632: LD_INT 12
2634: PUSH
2635: EMPTY
2636: LIST
2637: LIST
2638: PUSH
2639: EMPTY
2640: LIST
2641: LIST
2642: PPUSH
2643: CALL_OW 69
2647: PUSH
2648: FOR_IN
2649: IFFALSE 2688
// GetAwayFromXY ( ape , GetX ( Gnyevko ) , GetY ( Gnyevko ) , 10 , false ) ;
2651: LD_VAR 0 1
2655: PPUSH
2656: LD_EXP 54
2660: PPUSH
2661: CALL_OW 250
2665: PPUSH
2666: LD_EXP 54
2670: PPUSH
2671: CALL_OW 251
2675: PPUSH
2676: LD_INT 10
2678: PPUSH
2679: LD_INT 0
2681: PPUSH
2682: CALL 8446 0 5
2686: GO 2648
2688: POP
2689: POP
// if not jelenaSaved and apeAttackJelenaTime > 0 0$02 then
2690: LD_EXP 21
2694: NOT
2695: PUSH
2696: LD_EXP 41
2700: PUSH
2701: LD_INT 70
2703: GREATER
2704: AND
2705: IFFALSE 2783
// for ape in FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) do
2707: LD_ADDR_VAR 0 1
2711: PUSH
2712: LD_INT 22
2714: PUSH
2715: LD_INT 0
2717: PUSH
2718: EMPTY
2719: LIST
2720: LIST
2721: PUSH
2722: LD_INT 25
2724: PUSH
2725: LD_INT 12
2727: PUSH
2728: EMPTY
2729: LIST
2730: LIST
2731: PUSH
2732: EMPTY
2733: LIST
2734: LIST
2735: PPUSH
2736: CALL_OW 69
2740: PUSH
2741: FOR_IN
2742: IFFALSE 2781
// GetAwayFromXY ( ape , GetX ( Kirilenkova ) , GetY ( Kirilenkova ) , 10 , false ) ;
2744: LD_VAR 0 1
2748: PPUSH
2749: LD_EXP 53
2753: PPUSH
2754: CALL_OW 250
2758: PPUSH
2759: LD_EXP 53
2763: PPUSH
2764: CALL_OW 251
2768: PPUSH
2769: LD_INT 10
2771: PPUSH
2772: LD_INT 0
2774: PPUSH
2775: CALL 8446 0 5
2779: GO 2741
2781: POP
2782: POP
// end ;
2783: PPOPN 1
2785: END
// every 0 0$1 trigger not gnyevkoSaved or not jelenaSaved do
2786: LD_EXP 12
2790: NOT
2791: PUSH
2792: LD_EXP 21
2796: NOT
2797: OR
2798: IFFALSE 2909
2800: GO 2802
2802: DISABLE
// begin enable ;
2803: ENABLE
// if not gnyevkoSaved and apeAttackGnyevkoTime > 0 0$00 then
2804: LD_EXP 12
2808: NOT
2809: PUSH
2810: LD_EXP 40
2814: PUSH
2815: LD_INT 0
2817: GREATER
2818: AND
2819: IFFALSE 2835
// apeAttackGnyevkoTime = apeAttackGnyevkoTime - 0 0$01 ;
2821: LD_ADDR_EXP 40
2825: PUSH
2826: LD_EXP 40
2830: PUSH
2831: LD_INT 35
2833: MINUS
2834: ST_TO_ADDR
// if IsPlaced ( Kirilenkova ) and not jelenaSaved and apeAttackJelenaTime > 0 0$00 then
2835: LD_EXP 53
2839: PPUSH
2840: CALL_OW 305
2844: PUSH
2845: LD_EXP 21
2849: NOT
2850: AND
2851: PUSH
2852: LD_EXP 41
2856: PUSH
2857: LD_INT 0
2859: GREATER
2860: AND
2861: IFFALSE 2877
// apeAttackJelenaTime = apeAttackJelenaTime - 0 0$01 ;
2863: LD_ADDR_EXP 41
2867: PUSH
2868: LD_EXP 41
2872: PUSH
2873: LD_INT 35
2875: MINUS
2876: ST_TO_ADDR
// if IsPlaced ( Kirilenkova ) and not jelenaSaved then
2877: LD_EXP 53
2881: PPUSH
2882: CALL_OW 305
2886: PUSH
2887: LD_EXP 21
2891: NOT
2892: AND
2893: IFFALSE 2909
// achievement_JelenaTimer = achievement_JelenaTimer + 0 0$01 ;
2895: LD_ADDR_EXP 26
2899: PUSH
2900: LD_EXP 26
2904: PUSH
2905: LD_INT 35
2907: PLUS
2908: ST_TO_ADDR
// end ;
2909: END
// every 0 0$1 trigger ( See ( 3 , Pokryshkin ) or See ( 6 , Burlak ) or ( GetSide ( Gnyevko ) = 3 and See ( 6 , Gnyevko ) ) ) and not meetPokryshkin do
2910: LD_INT 3
2912: PPUSH
2913: LD_EXP 47
2917: PPUSH
2918: CALL_OW 292
2922: PUSH
2923: LD_INT 6
2925: PPUSH
2926: LD_EXP 46
2930: PPUSH
2931: CALL_OW 292
2935: OR
2936: PUSH
2937: LD_EXP 54
2941: PPUSH
2942: CALL_OW 255
2946: PUSH
2947: LD_INT 3
2949: EQUAL
2950: PUSH
2951: LD_INT 6
2953: PPUSH
2954: LD_EXP 54
2958: PPUSH
2959: CALL_OW 292
2963: AND
2964: OR
2965: PUSH
2966: LD_EXP 14
2970: NOT
2971: AND
2972: IFFALSE 3887
2974: GO 2976
2976: DISABLE
// begin enable ;
2977: ENABLE
// InGameOn ;
2978: CALL_OW 8
// CenterNowOnUnits ( Pokryshkin ) ;
2982: LD_EXP 47
2986: PPUSH
2987: CALL_OW 87
// ComWalk ( Gnyevko ) ;
2991: LD_EXP 54
2995: PPUSH
2996: CALL_OW 138
// AddComHold ( [ Burlak , Gnyevko ] ) ;
3000: LD_EXP 46
3004: PUSH
3005: LD_EXP 54
3009: PUSH
3010: EMPTY
3011: LIST
3012: LIST
3013: PPUSH
3014: CALL_OW 200
// DialogueOn ;
3018: CALL_OW 6
// if gnyevkoWaitWithPokryshkin then
3022: LD_EXP 13
3026: IFFALSE 3278
// begin meetPokryshkin = true ;
3028: LD_ADDR_EXP 14
3032: PUSH
3033: LD_INT 1
3035: ST_TO_ADDR
// ChangeSideFog ( 6 , 3 ) ;
3036: LD_INT 6
3038: PPUSH
3039: LD_INT 3
3041: PPUSH
3042: CALL_OW 343
// DialogueOff ;
3046: CALL_OW 7
// ComMoveXY ( Burlak , GetX ( Pokryshkin ) , GetY ( Pokryshkin ) ) ;
3050: LD_EXP 46
3054: PPUSH
3055: LD_EXP 47
3059: PPUSH
3060: CALL_OW 250
3064: PPUSH
3065: LD_EXP 47
3069: PPUSH
3070: CALL_OW 251
3074: PPUSH
3075: CALL_OW 111
// AddComTurnUnit ( Burlak , Pokryshkin ) ;
3079: LD_EXP 46
3083: PPUSH
3084: LD_EXP 47
3088: PPUSH
3089: CALL_OW 179
// ComTurnUnit ( Pokryshkin , Burlak ) ;
3093: LD_EXP 47
3097: PPUSH
3098: LD_EXP 46
3102: PPUSH
3103: CALL_OW 119
// Say ( Gnyevko , D4-Gny-3 ) ;
3107: LD_EXP 54
3111: PPUSH
3112: LD_STRING D4-Gny-3
3114: PPUSH
3115: CALL_OW 88
// Say ( Burlak , D4-Bur-3 ) ;
3119: LD_EXP 46
3123: PPUSH
3124: LD_STRING D4-Bur-3
3126: PPUSH
3127: CALL_OW 88
// Say ( Pokryshkin , D4-Pok-4 ) ;
3131: LD_EXP 47
3135: PPUSH
3136: LD_STRING D4-Pok-4
3138: PPUSH
3139: CALL_OW 88
// PlaceUnitArea ( Charles , CharlesSpawnArea , true ) ;
3143: LD_EXP 42
3147: PPUSH
3148: LD_INT 18
3150: PPUSH
3151: LD_INT 1
3153: PPUSH
3154: CALL_OW 49
// wait ( 0 0$2 ) ;
3158: LD_INT 70
3160: PPUSH
3161: CALL_OW 67
// Say ( Burlak , D4-Bur-4 ) ;
3165: LD_EXP 46
3169: PPUSH
3170: LD_STRING D4-Bur-4
3172: PPUSH
3173: CALL_OW 88
// Say ( Pokryshkin , D4-Pok-5 ) ;
3177: LD_EXP 47
3181: PPUSH
3182: LD_STRING D4-Pok-5
3184: PPUSH
3185: CALL_OW 88
// SayRadio ( Charles , D4-Sol1-5 ) ;
3189: LD_EXP 42
3193: PPUSH
3194: LD_STRING D4-Sol1-5
3196: PPUSH
3197: CALL_OW 94
// Say ( Pokryshkin , D4-Pok-6 ) ;
3201: LD_EXP 47
3205: PPUSH
3206: LD_STRING D4-Pok-6
3208: PPUSH
3209: CALL_OW 88
// SayRadio ( Pokryshkin , D4-Pok-6a ) ;
3213: LD_EXP 47
3217: PPUSH
3218: LD_STRING D4-Pok-6a
3220: PPUSH
3221: CALL_OW 94
// Say ( Burlak , D4-Bur-6 ) ;
3225: LD_EXP 46
3229: PPUSH
3230: LD_STRING D4-Bur-6
3232: PPUSH
3233: CALL_OW 88
// Say ( Pokryshkin , D4-Pok-7 ) ;
3237: LD_EXP 47
3241: PPUSH
3242: LD_STRING D4-Pok-7
3244: PPUSH
3245: CALL_OW 88
// DialogueOff ;
3249: CALL_OW 7
// InGameOff ;
3253: CALL_OW 9
// ChangeMissionObjectives ( M2 ) ;
3257: LD_STRING M2
3259: PPUSH
3260: CALL_OW 337
// goToHill = true ;
3264: LD_ADDR_EXP 15
3268: PUSH
3269: LD_INT 1
3271: ST_TO_ADDR
// MoveToHill ;
3272: CALL 10326 0 0
// exit ;
3276: GO 3887
// end ; ComStop ( [ Burlak , Gnyevko ] ) ;
3278: LD_EXP 46
3282: PUSH
3283: LD_EXP 54
3287: PUSH
3288: EMPTY
3289: LIST
3290: LIST
3291: PPUSH
3292: CALL_OW 141
// Say ( Pokryshkin , D4-Pok-1 ) ;
3296: LD_EXP 47
3300: PPUSH
3301: LD_STRING D4-Pok-1
3303: PPUSH
3304: CALL_OW 88
// if GetSide ( Gnyevko ) = 3 and IsOK ( Gnyevko ) then
3308: LD_EXP 54
3312: PPUSH
3313: CALL_OW 255
3317: PUSH
3318: LD_INT 3
3320: EQUAL
3321: PUSH
3322: LD_EXP 54
3326: PPUSH
3327: CALL_OW 302
3331: AND
3332: IFFALSE 3346
// Say ( Gnyevko , D4-Gny-1 ) ;
3334: LD_EXP 54
3338: PPUSH
3339: LD_STRING D4-Gny-1
3341: PPUSH
3342: CALL_OW 88
// if GetDistUnits ( Burlak , NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , 6 ] , [ f_type , unit_human ] ] ) , Burlak ) ) > 8 and GetDistUnits ( Burlak , Gnyevko ) > 8 and GetSide ( Gnyevko ) = 3 and IsOK ( Gnyevko ) then
3346: LD_EXP 46
3350: PPUSH
3351: LD_INT 22
3353: PUSH
3354: LD_INT 6
3356: PUSH
3357: EMPTY
3358: LIST
3359: LIST
3360: PUSH
3361: LD_INT 21
3363: PUSH
3364: LD_INT 1
3366: PUSH
3367: EMPTY
3368: LIST
3369: LIST
3370: PUSH
3371: EMPTY
3372: LIST
3373: LIST
3374: PPUSH
3375: CALL_OW 69
3379: PPUSH
3380: LD_EXP 46
3384: PPUSH
3385: CALL_OW 74
3389: PPUSH
3390: CALL_OW 296
3394: PUSH
3395: LD_INT 8
3397: GREATER
3398: PUSH
3399: LD_EXP 46
3403: PPUSH
3404: LD_EXP 54
3408: PPUSH
3409: CALL_OW 296
3413: PUSH
3414: LD_INT 8
3416: GREATER
3417: AND
3418: PUSH
3419: LD_EXP 54
3423: PPUSH
3424: CALL_OW 255
3428: PUSH
3429: LD_INT 3
3431: EQUAL
3432: AND
3433: PUSH
3434: LD_EXP 54
3438: PPUSH
3439: CALL_OW 302
3443: AND
3444: IFFALSE 3542
// begin ComWalk ( Gnyevko ) ;
3446: LD_EXP 54
3450: PPUSH
3451: CALL_OW 138
// Say ( Pokryshkin , D4-Pok-2 ) ;
3455: LD_EXP 47
3459: PPUSH
3460: LD_STRING D4-Pok-2
3462: PPUSH
3463: CALL_OW 88
// Say ( Gnyevko , D4-Gny-2 ) ;
3467: LD_EXP 54
3471: PPUSH
3472: LD_STRING D4-Gny-2
3474: PPUSH
3475: CALL_OW 88
// Say ( Pokryshkin , D4-Pok-3 ) ;
3479: LD_EXP 47
3483: PPUSH
3484: LD_STRING D4-Pok-3
3486: PPUSH
3487: CALL_OW 88
// gnyevkoWaitWithPokryshkin = true ;
3491: LD_ADDR_EXP 13
3495: PUSH
3496: LD_INT 1
3498: ST_TO_ADDR
// SetSide ( Gnyevko , 6 ) ;
3499: LD_EXP 54
3503: PPUSH
3504: LD_INT 6
3506: PPUSH
3507: CALL_OW 235
// AddComMoveXY ( Gnyevko , GetX ( Pokryshkin ) , GetY ( Pokryshkin ) ) ;
3511: LD_EXP 54
3515: PPUSH
3516: LD_EXP 47
3520: PPUSH
3521: CALL_OW 250
3525: PPUSH
3526: LD_EXP 47
3530: PPUSH
3531: CALL_OW 251
3535: PPUSH
3536: CALL_OW 171
// end else
3540: GO 3879
// begin meetPokryshkin = true ;
3542: LD_ADDR_EXP 14
3546: PUSH
3547: LD_INT 1
3549: ST_TO_ADDR
// ChangeSideFog ( 6 , 3 ) ;
3550: LD_INT 6
3552: PPUSH
3553: LD_INT 3
3555: PPUSH
3556: CALL_OW 343
// DialogueOff ;
3560: CALL_OW 7
// if GetSide ( Gnyevko ) = 3 and IsOK ( Gnyevko ) then
3564: LD_EXP 54
3568: PPUSH
3569: CALL_OW 255
3573: PUSH
3574: LD_INT 3
3576: EQUAL
3577: PUSH
3578: LD_EXP 54
3582: PPUSH
3583: CALL_OW 302
3587: AND
3588: IFFALSE 3665
// begin ComMoveXY ( [ Burlak , Gnyevko ] , GetX ( Pokryshkin ) , GetY ( Pokryshkin ) ) ;
3590: LD_EXP 46
3594: PUSH
3595: LD_EXP 54
3599: PUSH
3600: EMPTY
3601: LIST
3602: LIST
3603: PPUSH
3604: LD_EXP 47
3608: PPUSH
3609: CALL_OW 250
3613: PPUSH
3614: LD_EXP 47
3618: PPUSH
3619: CALL_OW 251
3623: PPUSH
3624: CALL_OW 111
// AddComTurnUnit ( [ Burlak , Gnyevko ] , Pokryshkin ) ;
3628: LD_EXP 46
3632: PUSH
3633: LD_EXP 54
3637: PUSH
3638: EMPTY
3639: LIST
3640: LIST
3641: PPUSH
3642: LD_EXP 47
3646: PPUSH
3647: CALL_OW 179
// SetSide ( Gnyevko , 6 ) ;
3651: LD_EXP 54
3655: PPUSH
3656: LD_INT 6
3658: PPUSH
3659: CALL_OW 235
// end else
3663: GO 3708
// begin ComMoveXY ( Burlak , GetX ( Pokryshkin ) , GetY ( Pokryshkin ) ) ;
3665: LD_EXP 46
3669: PPUSH
3670: LD_EXP 47
3674: PPUSH
3675: CALL_OW 250
3679: PPUSH
3680: LD_EXP 47
3684: PPUSH
3685: CALL_OW 251
3689: PPUSH
3690: CALL_OW 111
// AddComTurnUnit ( Burlak , Pokryshkin ) ;
3694: LD_EXP 46
3698: PPUSH
3699: LD_EXP 47
3703: PPUSH
3704: CALL_OW 179
// end ; ComTurnUnit ( Pokryshkin , Burlak ) ;
3708: LD_EXP 47
3712: PPUSH
3713: LD_EXP 46
3717: PPUSH
3718: CALL_OW 119
// Say ( Burlak , D4-Bur-3 ) ;
3722: LD_EXP 46
3726: PPUSH
3727: LD_STRING D4-Bur-3
3729: PPUSH
3730: CALL_OW 88
// Say ( Pokryshkin , D4-Pok-4 ) ;
3734: LD_EXP 47
3738: PPUSH
3739: LD_STRING D4-Pok-4
3741: PPUSH
3742: CALL_OW 88
// PlaceUnitArea ( Charles , CharlesSpawnArea , true ) ;
3746: LD_EXP 42
3750: PPUSH
3751: LD_INT 18
3753: PPUSH
3754: LD_INT 1
3756: PPUSH
3757: CALL_OW 49
// wait ( 0 0$2 ) ;
3761: LD_INT 70
3763: PPUSH
3764: CALL_OW 67
// Say ( Burlak , D4-Bur-4 ) ;
3768: LD_EXP 46
3772: PPUSH
3773: LD_STRING D4-Bur-4
3775: PPUSH
3776: CALL_OW 88
// Say ( Pokryshkin , D4-Pok-5 ) ;
3780: LD_EXP 47
3784: PPUSH
3785: LD_STRING D4-Pok-5
3787: PPUSH
3788: CALL_OW 88
// SayRadio ( Charles , D4-Sol1-5 ) ;
3792: LD_EXP 42
3796: PPUSH
3797: LD_STRING D4-Sol1-5
3799: PPUSH
3800: CALL_OW 94
// Say ( Pokryshkin , D4-Pok-6 ) ;
3804: LD_EXP 47
3808: PPUSH
3809: LD_STRING D4-Pok-6
3811: PPUSH
3812: CALL_OW 88
// SayRadio ( Pokryshkin , D4-Pok-6a ) ;
3816: LD_EXP 47
3820: PPUSH
3821: LD_STRING D4-Pok-6a
3823: PPUSH
3824: CALL_OW 94
// Say ( Burlak , D4-Bur-6 ) ;
3828: LD_EXP 46
3832: PPUSH
3833: LD_STRING D4-Bur-6
3835: PPUSH
3836: CALL_OW 88
// Say ( Pokryshkin , D4-Pok-7 ) ;
3840: LD_EXP 47
3844: PPUSH
3845: LD_STRING D4-Pok-7
3847: PPUSH
3848: CALL_OW 88
// ChangeMissionObjectives ( M2 ) ;
3852: LD_STRING M2
3854: PPUSH
3855: CALL_OW 337
// goToHill = true ;
3859: LD_ADDR_EXP 15
3863: PUSH
3864: LD_INT 1
3866: ST_TO_ADDR
// DialogueOff ;
3867: CALL_OW 7
// InGameOff ;
3871: CALL_OW 9
// MoveToHill ;
3875: CALL 10326 0 0
// end ; DialogueOff ;
3879: CALL_OW 7
// InGameOff ;
3883: CALL_OW 9
// end ;
3887: END
// every 0 0$1 trigger GetDistUnits ( Burlak , Pokryshkin ) > 10 and goToHill and not traitor do var ruSolds ;
3888: LD_EXP 46
3892: PPUSH
3893: LD_EXP 47
3897: PPUSH
3898: CALL_OW 296
3902: PUSH
3903: LD_INT 10
3905: GREATER
3906: PUSH
3907: LD_EXP 15
3911: AND
3912: PUSH
3913: LD_EXP 18
3917: NOT
3918: AND
3919: IFFALSE 4120
3921: GO 3923
3923: DISABLE
3924: LD_INT 0
3926: PPUSH
// begin enable ;
3927: ENABLE
// ruSolds = [ Pokryshkin , Saseda , Jaworska , Balei , Belkov ] ;
3928: LD_ADDR_VAR 0 1
3932: PUSH
3933: LD_EXP 47
3937: PUSH
3938: LD_EXP 48
3942: PUSH
3943: LD_EXP 49
3947: PUSH
3948: LD_EXP 50
3952: PUSH
3953: LD_EXP 51
3957: PUSH
3958: EMPTY
3959: LIST
3960: LIST
3961: LIST
3962: LIST
3963: LIST
3964: ST_TO_ADDR
// if ( GetSide ( Gnyevko ) = 6 and gnyevkoSaved ) then
3965: LD_EXP 54
3969: PPUSH
3970: CALL_OW 255
3974: PUSH
3975: LD_INT 6
3977: EQUAL
3978: PUSH
3979: LD_EXP 12
3983: AND
3984: IFFALSE 4002
// ruSolds = ruSolds ^ Gnyevko ;
3986: LD_ADDR_VAR 0 1
3990: PUSH
3991: LD_VAR 0 1
3995: PUSH
3996: LD_EXP 54
4000: ADD
4001: ST_TO_ADDR
// ComStop ( ruSolds ) ;
4002: LD_VAR 0 1
4006: PPUSH
4007: CALL_OW 141
// CenterNowOnUnits ( Burlak ) ;
4011: LD_EXP 46
4015: PPUSH
4016: CALL_OW 87
// DialogueOn ;
4020: CALL_OW 6
// Say ( Pokryshkin , DSplit-Pok-1 ) ;
4024: LD_EXP 47
4028: PPUSH
4029: LD_STRING DSplit-Pok-1
4031: PPUSH
4032: CALL_OW 88
// Say ( Burlak , DSplit-Bur-1 ) ;
4036: LD_EXP 46
4040: PPUSH
4041: LD_STRING DSplit-Bur-1
4043: PPUSH
4044: CALL_OW 88
// DialogueOff ;
4048: CALL_OW 7
// InGameOn ;
4052: CALL_OW 8
// repeat ComMoveXY ( Burlak , GetX ( Pokryshkin ) , GetY ( Pokryshkin ) ) ;
4056: LD_EXP 46
4060: PPUSH
4061: LD_EXP 47
4065: PPUSH
4066: CALL_OW 250
4070: PPUSH
4071: LD_EXP 47
4075: PPUSH
4076: CALL_OW 251
4080: PPUSH
4081: CALL_OW 111
// wait ( 0 0$1 ) ;
4085: LD_INT 35
4087: PPUSH
4088: CALL_OW 67
// until GetDistUnits ( Burlak , Pokryshkin ) < 6 ;
4092: LD_EXP 46
4096: PPUSH
4097: LD_EXP 47
4101: PPUSH
4102: CALL_OW 296
4106: PUSH
4107: LD_INT 6
4109: LESS
4110: IFFALSE 4056
// InGameOff ;
4112: CALL_OW 9
// MoveToHill ;
4116: CALL 10326 0 0
// end ;
4120: PPOPN 1
4122: END
// export function Dialogue_AttackComrade ; var ruSolds ; begin
4123: LD_INT 0
4125: PPUSH
4126: PPUSH
// traitor = true ;
4127: LD_ADDR_EXP 18
4131: PUSH
4132: LD_INT 1
4134: ST_TO_ADDR
// DialogueOn ;
4135: CALL_OW 6
// Say ( Pokryshkin , DAttack-Pok-1 ) ;
4139: LD_EXP 47
4143: PPUSH
4144: LD_STRING DAttack-Pok-1
4146: PPUSH
4147: CALL_OW 88
// DialogueOff ;
4151: CALL_OW 7
// SetAttitude ( 3 , 6 , att_enemy , true ) ;
4155: LD_INT 3
4157: PPUSH
4158: LD_INT 6
4160: PPUSH
4161: LD_INT 2
4163: PPUSH
4164: LD_INT 1
4166: PPUSH
4167: CALL_OW 80
// ComAttackUnit ( FilterAllUnits ( [ [ f_side , 6 ] , [ f_type , unit_human ] ] ) , Burlak ) ;
4171: LD_INT 22
4173: PUSH
4174: LD_INT 6
4176: PUSH
4177: EMPTY
4178: LIST
4179: LIST
4180: PUSH
4181: LD_INT 21
4183: PUSH
4184: LD_INT 1
4186: PUSH
4187: EMPTY
4188: LIST
4189: LIST
4190: PUSH
4191: EMPTY
4192: LIST
4193: LIST
4194: PPUSH
4195: CALL_OW 69
4199: PPUSH
4200: LD_EXP 46
4204: PPUSH
4205: CALL_OW 115
// end ;
4209: LD_VAR 0 1
4213: RET
// every 0 0$1 trigger GetDistUnitXY ( Pokryshkin , 65 , 59 ) < 4 and not traitor do
4214: LD_EXP 47
4218: PPUSH
4219: LD_INT 65
4221: PPUSH
4222: LD_INT 59
4224: PPUSH
4225: CALL_OW 297
4229: PUSH
4230: LD_INT 4
4232: LESS
4233: PUSH
4234: LD_EXP 18
4238: NOT
4239: AND
4240: IFFALSE 4437
4242: GO 4244
4244: DISABLE
// begin InGameOn ;
4245: CALL_OW 8
// CenterOnXY ( 55 , 50 ) ;
4249: LD_INT 55
4251: PPUSH
4252: LD_INT 50
4254: PPUSH
4255: CALL_OW 84
// ComMoveXY ( Burlak , 66 , 57 ) ;
4259: LD_EXP 46
4263: PPUSH
4264: LD_INT 66
4266: PPUSH
4267: LD_INT 57
4269: PPUSH
4270: CALL_OW 111
// AddComHold ( Burlak ) ;
4274: LD_EXP 46
4278: PPUSH
4279: CALL_OW 200
// ComMoveXY ( Charles , 59 , 55 ) ;
4283: LD_EXP 42
4287: PPUSH
4288: LD_INT 59
4290: PPUSH
4291: LD_INT 55
4293: PPUSH
4294: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
4298: LD_INT 35
4300: PPUSH
4301: CALL_OW 67
// until See ( 1 , Pokryshkin ) ;
4305: LD_INT 1
4307: PPUSH
4308: LD_EXP 47
4312: PPUSH
4313: CALL_OW 292
4317: IFFALSE 4298
// CenterNowOnUnits ( [ Charles , Pokryshkin ] ) ;
4319: LD_EXP 42
4323: PUSH
4324: LD_EXP 47
4328: PUSH
4329: EMPTY
4330: LIST
4331: LIST
4332: PPUSH
4333: CALL_OW 87
// ComStop ( Charles ) ;
4337: LD_EXP 42
4341: PPUSH
4342: CALL_OW 141
// AddComHold ( Charles ) ;
4346: LD_EXP 42
4350: PPUSH
4351: CALL_OW 200
// AddComTurnUnit ( Charles , Pokryshkin ) ;
4355: LD_EXP 42
4359: PPUSH
4360: LD_EXP 47
4364: PPUSH
4365: CALL_OW 179
// Say ( Charles , D5-Sol1-1 ) ;
4369: LD_EXP 42
4373: PPUSH
4374: LD_STRING D5-Sol1-1
4376: PPUSH
4377: CALL_OW 88
// Say ( Pokryshkin , D5-Pok-1 ) ;
4381: LD_EXP 47
4385: PPUSH
4386: LD_STRING D5-Pok-1
4388: PPUSH
4389: CALL_OW 88
// SetAttitude ( 1 , 6 , att_enemy , true ) ;
4393: LD_INT 1
4395: PPUSH
4396: LD_INT 6
4398: PPUSH
4399: LD_INT 2
4401: PPUSH
4402: LD_INT 1
4404: PPUSH
4405: CALL_OW 80
// SetAttitude ( 1 , 3 , att_enemy , true ) ;
4409: LD_INT 1
4411: PPUSH
4412: LD_INT 3
4414: PPUSH
4415: LD_INT 2
4417: PPUSH
4418: LD_INT 1
4420: PPUSH
4421: CALL_OW 80
// Say ( Charles , D5-Sol1-2 ) ;
4425: LD_EXP 42
4429: PPUSH
4430: LD_STRING D5-Sol1-2
4432: PPUSH
4433: CALL_OW 88
// end ;
4437: END
// every 0 0$1 trigger IsDead ( Charles ) and goToHill do var ruSolds ;
4438: LD_EXP 42
4442: PPUSH
4443: CALL_OW 301
4447: PUSH
4448: LD_EXP 15
4452: AND
4453: IFFALSE 5057
4455: GO 4457
4457: DISABLE
4458: LD_INT 0
4460: PPUSH
// begin InGameOn ;
4461: CALL_OW 8
// goToHill = false ;
4465: LD_ADDR_EXP 15
4469: PUSH
4470: LD_INT 0
4472: ST_TO_ADDR
// ComStop ( FilterAllUnits ( [ [ f_side , 6 ] , [ f_type , unit_human ] ] ) ) ;
4473: LD_INT 22
4475: PUSH
4476: LD_INT 6
4478: PUSH
4479: EMPTY
4480: LIST
4481: LIST
4482: PUSH
4483: LD_INT 21
4485: PUSH
4486: LD_INT 1
4488: PUSH
4489: EMPTY
4490: LIST
4491: LIST
4492: PUSH
4493: EMPTY
4494: LIST
4495: LIST
4496: PPUSH
4497: CALL_OW 69
4501: PPUSH
4502: CALL_OW 141
// wait ( 0 0$1 ) ;
4506: LD_INT 35
4508: PPUSH
4509: CALL_OW 67
// ComWalk ( FilterAllUnits ( [ [ f_side , 6 ] , [ f_type , unit_human ] ] ) ) ;
4513: LD_INT 22
4515: PUSH
4516: LD_INT 6
4518: PUSH
4519: EMPTY
4520: LIST
4521: LIST
4522: PUSH
4523: LD_INT 21
4525: PUSH
4526: LD_INT 1
4528: PUSH
4529: EMPTY
4530: LIST
4531: LIST
4532: PUSH
4533: EMPTY
4534: LIST
4535: LIST
4536: PPUSH
4537: CALL_OW 69
4541: PPUSH
4542: CALL_OW 138
// wait ( 0 0$1 ) ;
4546: LD_INT 35
4548: PPUSH
4549: CALL_OW 67
// CenterOnXY ( 55 , 50 ) ;
4553: LD_INT 55
4555: PPUSH
4556: LD_INT 50
4558: PPUSH
4559: CALL_OW 84
// ComMoveXY ( Burlak , 56 , 56 ) ;
4563: LD_EXP 46
4567: PPUSH
4568: LD_INT 56
4570: PPUSH
4571: LD_INT 56
4573: PPUSH
4574: CALL_OW 111
// ComMoveXY ( FilterAllUnits ( [ [ f_side , 6 ] , [ f_type , unit_human ] ] ) , 56 , 56 ) ;
4578: LD_INT 22
4580: PUSH
4581: LD_INT 6
4583: PUSH
4584: EMPTY
4585: LIST
4586: LIST
4587: PUSH
4588: LD_INT 21
4590: PUSH
4591: LD_INT 1
4593: PUSH
4594: EMPTY
4595: LIST
4596: LIST
4597: PUSH
4598: EMPTY
4599: LIST
4600: LIST
4601: PPUSH
4602: CALL_OW 69
4606: PPUSH
4607: LD_INT 56
4609: PPUSH
4610: LD_INT 56
4612: PPUSH
4613: CALL_OW 111
// Say ( Burlak , D5-Bur-2 ) ;
4617: LD_EXP 46
4621: PPUSH
4622: LD_STRING D5-Bur-2
4624: PPUSH
4625: CALL_OW 88
// Say ( Pokryshkin , D5-Pok-2 ) ;
4629: LD_EXP 47
4633: PPUSH
4634: LD_STRING D5-Pok-2
4636: PPUSH
4637: CALL_OW 88
// Say ( Belkov , D5-Bel-2 ) ;
4641: LD_EXP 51
4645: PPUSH
4646: LD_STRING D5-Bel-2
4648: PPUSH
4649: CALL_OW 88
// Say ( Pokryshkin , D5-Pok-3 ) ;
4653: LD_EXP 47
4657: PPUSH
4658: LD_STRING D5-Pok-3
4660: PPUSH
4661: CALL_OW 88
// if ( GetSide ( Gnyevko ) = 6 ) then
4665: LD_EXP 54
4669: PPUSH
4670: CALL_OW 255
4674: PUSH
4675: LD_INT 6
4677: EQUAL
4678: IFFALSE 4692
// Say ( Gnyevko , D5-Gny-3 ) ;
4680: LD_EXP 54
4684: PPUSH
4685: LD_STRING D5-Gny-3
4687: PPUSH
4688: CALL_OW 88
// Say ( Burlak , D5-Bur-3 ) ;
4692: LD_EXP 46
4696: PPUSH
4697: LD_STRING D5-Bur-3
4699: PPUSH
4700: CALL_OW 88
// interface_hidden = true ;
4704: LD_ADDR_OWVAR 54
4708: PUSH
4709: LD_INT 1
4711: ST_TO_ADDR
// IngameOff ;
4712: CALL_OW 9
// wait ( 0 0$2 ) ;
4716: LD_INT 70
4718: PPUSH
4719: CALL_OW 67
// ComMoveXY ( Burlak , 85 , 64 ) ;
4723: LD_EXP 46
4727: PPUSH
4728: LD_INT 85
4730: PPUSH
4731: LD_INT 64
4733: PPUSH
4734: CALL_OW 111
// ComMoveXY ( FilterAllUnits ( [ [ f_side , 6 ] , [ f_type , unit_human ] ] ) , 85 , 64 ) ;
4738: LD_INT 22
4740: PUSH
4741: LD_INT 6
4743: PUSH
4744: EMPTY
4745: LIST
4746: LIST
4747: PUSH
4748: LD_INT 21
4750: PUSH
4751: LD_INT 1
4753: PUSH
4754: EMPTY
4755: LIST
4756: LIST
4757: PUSH
4758: EMPTY
4759: LIST
4760: LIST
4761: PPUSH
4762: CALL_OW 69
4766: PPUSH
4767: LD_INT 85
4769: PPUSH
4770: LD_INT 64
4772: PPUSH
4773: CALL_OW 111
// interface_hidden = false ;
4777: LD_ADDR_OWVAR 54
4781: PUSH
4782: LD_INT 0
4784: ST_TO_ADDR
// InGameOn ;
4785: CALL_OW 8
// CenterNowOnUnits ( Burlak ) ;
4789: LD_EXP 46
4793: PPUSH
4794: CALL_OW 87
// Say ( Pokryshkin , D6-Pok-1 ) ;
4798: LD_EXP 47
4802: PPUSH
4803: LD_STRING D6-Pok-1
4805: PPUSH
4806: CALL_OW 88
// CenterNowOnUnits ( Burlak ) ;
4810: LD_EXP 46
4814: PPUSH
4815: CALL_OW 87
// Say ( Burlak , D6-Bur-1 ) ;
4819: LD_EXP 46
4823: PPUSH
4824: LD_STRING D6-Bur-1
4826: PPUSH
4827: CALL_OW 88
// CenterNowOnUnits ( Burlak ) ;
4831: LD_EXP 46
4835: PPUSH
4836: CALL_OW 87
// Say ( Pokryshkin , D6-Pok-2 ) ;
4840: LD_EXP 47
4844: PPUSH
4845: LD_STRING D6-Pok-2
4847: PPUSH
4848: CALL_OW 88
// CenterNowOnUnits ( Burlak ) ;
4852: LD_EXP 46
4856: PPUSH
4857: CALL_OW 87
// Say ( Belkov , D6-Bel-2 ) ;
4861: LD_EXP 51
4865: PPUSH
4866: LD_STRING D6-Bel-2
4868: PPUSH
4869: CALL_OW 88
// CenterNowOnUnits ( Burlak ) ;
4873: LD_EXP 46
4877: PPUSH
4878: CALL_OW 87
// Say ( Burlak , D6-Bur-2 ) ;
4882: LD_EXP 46
4886: PPUSH
4887: LD_STRING D6-Bur-2
4889: PPUSH
4890: CALL_OW 88
// CenterNowOnUnits ( Burlak ) ;
4894: LD_EXP 46
4898: PPUSH
4899: CALL_OW 87
// Say ( Pokryshkin , D6-Pok-3 ) ;
4903: LD_EXP 47
4907: PPUSH
4908: LD_STRING D6-Pok-3
4910: PPUSH
4911: CALL_OW 88
// CenterNowOnUnits ( Burlak ) ;
4915: LD_EXP 46
4919: PPUSH
4920: CALL_OW 87
// SayRadio ( Kurin , D6-Kur-3 ) ;
4924: LD_EXP 55
4928: PPUSH
4929: LD_STRING D6-Kur-3
4931: PPUSH
4932: CALL_OW 94
// CenterNowOnUnits ( Burlak ) ;
4936: LD_EXP 46
4940: PPUSH
4941: CALL_OW 87
// Say ( Pokryshkin , D6-Pok-4 ) ;
4945: LD_EXP 47
4949: PPUSH
4950: LD_STRING D6-Pok-4
4952: PPUSH
4953: CALL_OW 88
// CenterNowOnUnits ( Burlak ) ;
4957: LD_EXP 46
4961: PPUSH
4962: CALL_OW 87
// Say ( Belkov , D6-Bel-4 ) ;
4966: LD_EXP 51
4970: PPUSH
4971: LD_STRING D6-Bel-4
4973: PPUSH
4974: CALL_OW 88
// InGameOff ;
4978: CALL_OW 9
// interface_hidden = false ;
4982: LD_ADDR_OWVAR 54
4986: PUSH
4987: LD_INT 0
4989: ST_TO_ADDR
// ComAttackUnit ( Pokryshkin , am_bun ) ;
4990: LD_EXP 47
4994: PPUSH
4995: LD_INT 23
4997: PPUSH
4998: CALL_OW 115
// wait ( 0 0$5 ) ;
5002: LD_INT 175
5004: PPUSH
5005: CALL_OW 67
// ComAttackUnit ( FilterAllUnits ( [ [ f_side , 6 ] , [ f_type , unit_human ] ] ) , am_bun ) ;
5009: LD_INT 22
5011: PUSH
5012: LD_INT 6
5014: PUSH
5015: EMPTY
5016: LIST
5017: LIST
5018: PUSH
5019: LD_INT 21
5021: PUSH
5022: LD_INT 1
5024: PUSH
5025: EMPTY
5026: LIST
5027: LIST
5028: PUSH
5029: EMPTY
5030: LIST
5031: LIST
5032: PPUSH
5033: CALL_OW 69
5037: PPUSH
5038: LD_INT 23
5040: PPUSH
5041: CALL_OW 115
// DoNotAttack ( 1 , Gnyevko ) ;
5045: LD_INT 1
5047: PPUSH
5048: LD_EXP 54
5052: PPUSH
5053: CALL_OW 471
// end ;
5057: PPOPN 1
5059: END
// every 0 0$1 trigger See ( 1 , Pokryshkin ) and IsDead ( Charles ) do
5060: LD_INT 1
5062: PPUSH
5063: LD_EXP 47
5067: PPUSH
5068: CALL_OW 292
5072: PUSH
5073: LD_EXP 42
5077: PPUSH
5078: CALL_OW 301
5082: AND
5083: IFFALSE 5102
5085: GO 5087
5087: DISABLE
// ComAttackUnit ( Johanna , Pokryshkin ) ;
5088: LD_EXP 43
5092: PPUSH
5093: LD_EXP 47
5097: PPUSH
5098: CALL_OW 115
5102: END
// every 0 0$1 trigger See ( 3 , am_bun ) do
5103: LD_INT 3
5105: PPUSH
5106: LD_INT 23
5108: PPUSH
5109: CALL_OW 292
5113: IFFALSE 5142
5115: GO 5117
5117: DISABLE
// begin Say ( Pokryshkin , D7-Pok-1 ) ;
5118: LD_EXP 47
5122: PPUSH
5123: LD_STRING D7-Pok-1
5125: PPUSH
5126: CALL_OW 88
// Say ( Johanna , D7-FSol1-1 ) ;
5130: LD_EXP 43
5134: PPUSH
5135: LD_STRING D7-FSol1-1
5137: PPUSH
5138: CALL_OW 88
// end ;
5142: END
// every 0 0$1 trigger IsDying ( Pokryshkin ) do var i , unit , ruSolds ;
5143: LD_EXP 47
5147: PPUSH
5148: CALL_OW 303
5152: IFFALSE 5684
5154: GO 5156
5156: DISABLE
5157: LD_INT 0
5159: PPUSH
5160: PPUSH
5161: PPUSH
// begin ruSolds = FilterAllUnits ( [ [ f_side , 6 ] , [ f_type , unit_human ] , [ f_ok ] ] ) diff Belkov ;
5162: LD_ADDR_VAR 0 3
5166: PUSH
5167: LD_INT 22
5169: PUSH
5170: LD_INT 6
5172: PUSH
5173: EMPTY
5174: LIST
5175: LIST
5176: PUSH
5177: LD_INT 21
5179: PUSH
5180: LD_INT 1
5182: PUSH
5183: EMPTY
5184: LIST
5185: LIST
5186: PUSH
5187: LD_INT 50
5189: PUSH
5190: EMPTY
5191: LIST
5192: PUSH
5193: EMPTY
5194: LIST
5195: LIST
5196: LIST
5197: PPUSH
5198: CALL_OW 69
5202: PUSH
5203: LD_EXP 51
5207: DIFF
5208: ST_TO_ADDR
// DialogueOn ;
5209: CALL_OW 6
// Say ( Belkov , D7a-Bel-1 ) ;
5213: LD_EXP 51
5217: PPUSH
5218: LD_STRING D7a-Bel-1
5220: PPUSH
5221: CALL_OW 88
// DialogueOff ;
5225: CALL_OW 7
// for i := 1 to ruSolds do
5229: LD_ADDR_VAR 0 1
5233: PUSH
5234: DOUBLE
5235: LD_INT 1
5237: DEC
5238: ST_TO_ADDR
5239: LD_VAR 0 3
5243: PUSH
5244: FOR_TO
5245: IFFALSE 5303
// begin ComMoveXY ( ruSolds [ i ] , 87 + i , 63 + i ) ;
5247: LD_VAR 0 3
5251: PUSH
5252: LD_VAR 0 1
5256: ARRAY
5257: PPUSH
5258: LD_INT 87
5260: PUSH
5261: LD_VAR 0 1
5265: PLUS
5266: PPUSH
5267: LD_INT 63
5269: PUSH
5270: LD_VAR 0 1
5274: PLUS
5275: PPUSH
5276: CALL_OW 111
// AddComTurnXY ( ruSolds [ i ] , 89 , 67 ) ;
5280: LD_VAR 0 3
5284: PUSH
5285: LD_VAR 0 1
5289: ARRAY
5290: PPUSH
5291: LD_INT 89
5293: PPUSH
5294: LD_INT 67
5296: PPUSH
5297: CALL_OW 178
// end ;
5301: GO 5244
5303: POP
5304: POP
// ComMoveXY ( Belkov , 89 , 67 ) ;
5305: LD_EXP 51
5309: PPUSH
5310: LD_INT 89
5312: PPUSH
5313: LD_INT 67
5315: PPUSH
5316: CALL_OW 111
// AddComTurnXY ( Belkov , 88 , 66 ) ;
5320: LD_EXP 51
5324: PPUSH
5325: LD_INT 88
5327: PPUSH
5328: LD_INT 66
5330: PPUSH
5331: CALL_OW 178
// Say ( Saseda , D7a-RSol1-1 ) ;
5335: LD_EXP 48
5339: PPUSH
5340: LD_STRING D7a-RSol1-1
5342: PPUSH
5343: CALL_OW 88
// Say ( Johanna , D7a-FSol1-1 ) ;
5347: LD_EXP 43
5351: PPUSH
5352: LD_STRING D7a-FSol1-1
5354: PPUSH
5355: CALL_OW 88
// wait ( 0 0$12 ) ;
5359: LD_INT 420
5361: PPUSH
5362: CALL_OW 67
// Say ( Belkov , D7b-Bel-1 ) ;
5366: LD_EXP 51
5370: PPUSH
5371: LD_STRING D7b-Bel-1
5373: PPUSH
5374: CALL_OW 88
// Say ( Jaworska , D7b-FSol1-1 ) ;
5378: LD_EXP 49
5382: PPUSH
5383: LD_STRING D7b-FSol1-1
5385: PPUSH
5386: CALL_OW 88
// Say ( Belkov , D7b-Bel-2 ) ;
5390: LD_EXP 51
5394: PPUSH
5395: LD_STRING D7b-Bel-2
5397: PPUSH
5398: CALL_OW 88
// Say ( Saseda , D7b-RSol1-2 ) ;
5402: LD_EXP 48
5406: PPUSH
5407: LD_STRING D7b-RSol1-2
5409: PPUSH
5410: CALL_OW 88
// for unit in ruSolds do
5414: LD_ADDR_VAR 0 2
5418: PUSH
5419: LD_VAR 0 3
5423: PUSH
5424: FOR_IN
5425: IFFALSE 5658
// if ( GetDistUnits ( Burlak , unit ) ) < 7 then
5427: LD_EXP 46
5431: PPUSH
5432: LD_VAR 0 2
5436: PPUSH
5437: CALL_OW 296
5441: PUSH
5442: LD_INT 7
5444: LESS
5445: IFFALSE 5656
// begin InGameOn ;
5447: CALL_OW 8
// CenterNowOnUnits ( [ Belkov , Saseda ] ) ;
5451: LD_EXP 51
5455: PUSH
5456: LD_EXP 48
5460: PUSH
5461: EMPTY
5462: LIST
5463: LIST
5464: PPUSH
5465: CALL_OW 87
// ComMoveXY ( Burlak , 88 , 66 ) ;
5469: LD_EXP 46
5473: PPUSH
5474: LD_INT 88
5476: PPUSH
5477: LD_INT 66
5479: PPUSH
5480: CALL_OW 111
// ComTurnUnit ( Belkov , Burlak ) ;
5484: LD_EXP 51
5488: PPUSH
5489: LD_EXP 46
5493: PPUSH
5494: CALL_OW 119
// AddComTurnXY ( Burlak , 90 , 66 ) ;
5498: LD_EXP 46
5502: PPUSH
5503: LD_INT 90
5505: PPUSH
5506: LD_INT 66
5508: PPUSH
5509: CALL_OW 178
// Say ( Burlak , D7b-Bur-3 ) ;
5513: LD_EXP 46
5517: PPUSH
5518: LD_STRING D7b-Bur-3
5520: PPUSH
5521: CALL_OW 88
// Say ( Belkov , D7b-Bel-4 ) ;
5525: LD_EXP 51
5529: PPUSH
5530: LD_STRING D7b-Bel-4
5532: PPUSH
5533: CALL_OW 88
// Say ( Burlak , D7b-Bur-4 ) ;
5537: LD_EXP 46
5541: PPUSH
5542: LD_STRING D7b-Bur-4
5544: PPUSH
5545: CALL_OW 88
// Say ( Belkov , D7b-Bel-5 ) ;
5549: LD_EXP 51
5553: PPUSH
5554: LD_STRING D7b-Bel-5
5556: PPUSH
5557: CALL_OW 88
// Say ( Jaworska , D7b-FSol1-5 ) ;
5561: LD_EXP 49
5565: PPUSH
5566: LD_STRING D7b-FSol1-5
5568: PPUSH
5569: CALL_OW 88
// Say ( Belkov , D7b-Bel-6 ) ;
5573: LD_EXP 51
5577: PPUSH
5578: LD_STRING D7b-Bel-6
5580: PPUSH
5581: CALL_OW 88
// Say ( Burlak , D7b-Bur-6 ) ;
5585: LD_EXP 46
5589: PPUSH
5590: LD_STRING D7b-Bur-6
5592: PPUSH
5593: CALL_OW 88
// Say ( Saseda , D7b-RSol1-6 ) ;
5597: LD_EXP 48
5601: PPUSH
5602: LD_STRING D7b-RSol1-6
5604: PPUSH
5605: CALL_OW 88
// InGameOff ;
5609: CALL_OW 9
// SetSide ( ruSolds , 3 ) ;
5613: LD_VAR 0 3
5617: PPUSH
5618: LD_INT 3
5620: PPUSH
5621: CALL_OW 235
// SetSide ( Belkov , 3 ) ;
5625: LD_EXP 51
5629: PPUSH
5630: LD_INT 3
5632: PPUSH
5633: CALL_OW 235
// ChangeMissionObjectives ( M3 ) ;
5637: LD_STRING M3
5639: PPUSH
5640: CALL_OW 337
// secondAttack = true ;
5644: LD_ADDR_EXP 17
5648: PUSH
5649: LD_INT 1
5651: ST_TO_ADDR
// exit ;
5652: POP
5653: POP
5654: GO 5684
// end ;
5656: GO 5424
5658: POP
5659: POP
// Say ( Belkov , D7b-Bel-3 ) ;
5660: LD_EXP 51
5664: PPUSH
5665: LD_STRING D7b-Bel-3
5667: PPUSH
5668: CALL_OW 88
// InGameOff ;
5672: CALL_OW 9
// belkovWaitForGorky = true ;
5676: LD_ADDR_EXP 16
5680: PUSH
5681: LD_INT 1
5683: ST_TO_ADDR
// end ;
5684: PPOPN 3
5686: END
// every 0 0$1 trigger belkovWaitForGorky and not traitor do var unit , ruSolds ;
5687: LD_EXP 16
5691: PUSH
5692: LD_EXP 18
5696: NOT
5697: AND
5698: IFFALSE 6008
5700: GO 5702
5702: DISABLE
5703: LD_INT 0
5705: PPUSH
5706: PPUSH
// begin enable ;
5707: ENABLE
// ruSolds = FilterAllUnits ( [ [ f_side , 6 ] , [ f_type , unit_human ] ] ) ;
5708: LD_ADDR_VAR 0 2
5712: PUSH
5713: LD_INT 22
5715: PUSH
5716: LD_INT 6
5718: PUSH
5719: EMPTY
5720: LIST
5721: LIST
5722: PUSH
5723: LD_INT 21
5725: PUSH
5726: LD_INT 1
5728: PUSH
5729: EMPTY
5730: LIST
5731: LIST
5732: PUSH
5733: EMPTY
5734: LIST
5735: LIST
5736: PPUSH
5737: CALL_OW 69
5741: ST_TO_ADDR
// for unit in ruSolds do
5742: LD_ADDR_VAR 0 1
5746: PUSH
5747: LD_VAR 0 2
5751: PUSH
5752: FOR_IN
5753: IFFALSE 6006
// if ( GetDistUnits ( Burlak , unit ) ) < 7 then
5755: LD_EXP 46
5759: PPUSH
5760: LD_VAR 0 1
5764: PPUSH
5765: CALL_OW 296
5769: PUSH
5770: LD_INT 7
5772: LESS
5773: IFFALSE 6004
// begin belkovWaitForGorky = false ;
5775: LD_ADDR_EXP 16
5779: PUSH
5780: LD_INT 0
5782: ST_TO_ADDR
// InGameOn ;
5783: CALL_OW 8
// CenterNowOnUnits ( [ Belkov , Saseda ] ) ;
5787: LD_EXP 51
5791: PUSH
5792: LD_EXP 48
5796: PUSH
5797: EMPTY
5798: LIST
5799: LIST
5800: PPUSH
5801: CALL_OW 87
// ComMoveXY ( Burlak , 88 , 66 ) ;
5805: LD_EXP 46
5809: PPUSH
5810: LD_INT 88
5812: PPUSH
5813: LD_INT 66
5815: PPUSH
5816: CALL_OW 111
// ComTurnUnit ( Belkov , Burlak ) ;
5820: LD_EXP 51
5824: PPUSH
5825: LD_EXP 46
5829: PPUSH
5830: CALL_OW 119
// AddComTurnXY ( Burlak , 90 , 66 ) ;
5834: LD_EXP 46
5838: PPUSH
5839: LD_INT 90
5841: PPUSH
5842: LD_INT 66
5844: PPUSH
5845: CALL_OW 178
// Say ( Belkov , D7b-Bel-3a ) ;
5849: LD_EXP 51
5853: PPUSH
5854: LD_STRING D7b-Bel-3a
5856: PPUSH
5857: CALL_OW 88
// Say ( Burlak , D7b-Bur-3 ) ;
5861: LD_EXP 46
5865: PPUSH
5866: LD_STRING D7b-Bur-3
5868: PPUSH
5869: CALL_OW 88
// Say ( Belkov , D7b-Bel-4 ) ;
5873: LD_EXP 51
5877: PPUSH
5878: LD_STRING D7b-Bel-4
5880: PPUSH
5881: CALL_OW 88
// Say ( Burlak , D7b-Bur-4 ) ;
5885: LD_EXP 46
5889: PPUSH
5890: LD_STRING D7b-Bur-4
5892: PPUSH
5893: CALL_OW 88
// Say ( Belkov , D7b-Bel-5 ) ;
5897: LD_EXP 51
5901: PPUSH
5902: LD_STRING D7b-Bel-5
5904: PPUSH
5905: CALL_OW 88
// Say ( Jaworska , D7b-FSol1-5 ) ;
5909: LD_EXP 49
5913: PPUSH
5914: LD_STRING D7b-FSol1-5
5916: PPUSH
5917: CALL_OW 88
// Say ( Belkov , D7b-Bel-6 ) ;
5921: LD_EXP 51
5925: PPUSH
5926: LD_STRING D7b-Bel-6
5928: PPUSH
5929: CALL_OW 88
// Say ( Burlak , D7b-Bur-6 ) ;
5933: LD_EXP 46
5937: PPUSH
5938: LD_STRING D7b-Bur-6
5940: PPUSH
5941: CALL_OW 88
// Say ( Saseda , D7a-RSol1-6 ) ;
5945: LD_EXP 48
5949: PPUSH
5950: LD_STRING D7a-RSol1-6
5952: PPUSH
5953: CALL_OW 88
// InGameOff ;
5957: CALL_OW 9
// SetSide ( ruSolds , 3 ) ;
5961: LD_VAR 0 2
5965: PPUSH
5966: LD_INT 3
5968: PPUSH
5969: CALL_OW 235
// SetSide ( Belkov , 3 ) ;
5973: LD_EXP 51
5977: PPUSH
5978: LD_INT 3
5980: PPUSH
5981: CALL_OW 235
// ChangeMissionObjectives ( M3 ) ;
5985: LD_STRING M3
5987: PPUSH
5988: CALL_OW 337
// secondAttack = true ;
5992: LD_ADDR_EXP 17
5996: PUSH
5997: LD_INT 1
5999: ST_TO_ADDR
// exit ;
6000: POP
6001: POP
6002: GO 6008
// end ;
6004: GO 5752
6006: POP
6007: POP
// end ;
6008: PPOPN 2
6010: END
// export function Dial_SecondAttack ; var nearRuUnit ; begin
6011: LD_INT 0
6013: PPUSH
6014: PPUSH
// Say ( Johanna , D8-FSol1-1 ) ;
6015: LD_EXP 43
6019: PPUSH
6020: LD_STRING D8-FSol1-1
6022: PPUSH
6023: CALL_OW 88
// Say ( Gladstone , D8-Glad-1 ) ;
6027: LD_EXP 44
6031: PPUSH
6032: LD_STRING D8-Glad-1
6034: PPUSH
6035: CALL_OW 88
// Say ( Burlak , D8-Bur-1 ) ;
6039: LD_EXP 46
6043: PPUSH
6044: LD_STRING D8-Bur-1
6046: PPUSH
6047: CALL_OW 88
// secondAttack = false ;
6051: LD_ADDR_EXP 17
6055: PUSH
6056: LD_INT 0
6058: ST_TO_ADDR
// nearRuUnit = NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) , am_bun ) ;
6059: LD_ADDR_VAR 0 2
6063: PUSH
6064: LD_INT 22
6066: PUSH
6067: LD_INT 3
6069: PUSH
6070: EMPTY
6071: LIST
6072: LIST
6073: PUSH
6074: LD_INT 21
6076: PUSH
6077: LD_INT 1
6079: PUSH
6080: EMPTY
6081: LIST
6082: LIST
6083: PUSH
6084: EMPTY
6085: LIST
6086: LIST
6087: PPUSH
6088: CALL_OW 69
6092: PPUSH
6093: LD_INT 23
6095: PPUSH
6096: CALL_OW 74
6100: ST_TO_ADDR
// ComExitBuilding ( amApemans ) ;
6101: LD_EXP 45
6105: PPUSH
6106: CALL_OW 122
// wait ( 0 0$1 ) ;
6110: LD_INT 35
6112: PPUSH
6113: CALL_OW 67
// AddComAttackUnit ( amApemans , nearRuUnit ) ;
6117: LD_EXP 45
6121: PPUSH
6122: LD_VAR 0 2
6126: PPUSH
6127: CALL_OW 175
// end ;
6131: LD_VAR 0 1
6135: RET
// every 0 0$1 trigger GetLives ( am_bun ) < 350 and GetLives ( am_bun ) > 250 and FilterUnitsInArea ( TreeArea , [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) > 0 and not amRetreat do
6136: LD_INT 23
6138: PPUSH
6139: CALL_OW 256
6143: PUSH
6144: LD_INT 350
6146: LESS
6147: PUSH
6148: LD_INT 23
6150: PPUSH
6151: CALL_OW 256
6155: PUSH
6156: LD_INT 250
6158: GREATER
6159: AND
6160: PUSH
6161: LD_INT 20
6163: PPUSH
6164: LD_INT 22
6166: PUSH
6167: LD_INT 3
6169: PUSH
6170: EMPTY
6171: LIST
6172: LIST
6173: PUSH
6174: LD_INT 21
6176: PUSH
6177: LD_INT 1
6179: PUSH
6180: EMPTY
6181: LIST
6182: LIST
6183: PUSH
6184: EMPTY
6185: LIST
6186: LIST
6187: PPUSH
6188: CALL_OW 70
6192: PUSH
6193: LD_INT 0
6195: GREATER
6196: AND
6197: PUSH
6198: LD_EXP 24
6202: NOT
6203: AND
6204: IFFALSE 6221
6206: GO 6208
6208: DISABLE
// Say ( Johanna , D8-FSol1-2 ) ;
6209: LD_EXP 43
6213: PPUSH
6214: LD_STRING D8-FSol1-2
6216: PPUSH
6217: CALL_OW 88
6221: END
// every 0 0$1 trigger IsDying ( am_bun ) and IsOK ( am_lab ) and not amRetreat do
6222: LD_INT 23
6224: PPUSH
6225: CALL_OW 303
6229: PUSH
6230: LD_INT 22
6232: PPUSH
6233: CALL_OW 302
6237: AND
6238: PUSH
6239: LD_EXP 24
6243: NOT
6244: AND
6245: IFFALSE 6315
6247: GO 6249
6249: DISABLE
// begin amRetreat = true ;
6250: LD_ADDR_EXP 24
6254: PUSH
6255: LD_INT 1
6257: ST_TO_ADDR
// Say ( Johanna , D8-FSol1-2a ) ;
6258: LD_EXP 43
6262: PPUSH
6263: LD_STRING D8-FSol1-2a
6265: PPUSH
6266: CALL_OW 88
// ComMoveToArea ( [ Gladstone , Johanna ] , AmericanExitArea ) ;
6270: LD_EXP 44
6274: PUSH
6275: LD_EXP 43
6279: PUSH
6280: EMPTY
6281: LIST
6282: LIST
6283: PPUSH
6284: LD_INT 21
6286: PPUSH
6287: CALL_OW 113
// Say ( Gladstone , D8-Glad-2 ) ;
6291: LD_EXP 44
6295: PPUSH
6296: LD_STRING D8-Glad-2
6298: PPUSH
6299: CALL_OW 88
// Say ( Burlak , D8-Bur-2 ) ;
6303: LD_EXP 46
6307: PPUSH
6308: LD_STRING D8-Bur-2
6310: PPUSH
6311: CALL_OW 88
// end ;
6315: END
// every 0 0$1 trigger IsDying ( am_lab ) and IsOK ( am_bun ) and not amRetreat do
6316: LD_INT 22
6318: PPUSH
6319: CALL_OW 303
6323: PUSH
6324: LD_INT 23
6326: PPUSH
6327: CALL_OW 302
6331: AND
6332: PUSH
6333: LD_EXP 24
6337: NOT
6338: AND
6339: IFFALSE 6409
6341: GO 6343
6343: DISABLE
// begin amRetreat = true ;
6344: LD_ADDR_EXP 24
6348: PUSH
6349: LD_INT 1
6351: ST_TO_ADDR
// Say ( Johanna , D8-FSol1-2a ) ;
6352: LD_EXP 43
6356: PPUSH
6357: LD_STRING D8-FSol1-2a
6359: PPUSH
6360: CALL_OW 88
// ComMoveToArea ( [ Gladstone , Johanna ] , AmericanExitArea ) ;
6364: LD_EXP 44
6368: PUSH
6369: LD_EXP 43
6373: PUSH
6374: EMPTY
6375: LIST
6376: LIST
6377: PPUSH
6378: LD_INT 21
6380: PPUSH
6381: CALL_OW 113
// Say ( Gladstone , D8-Glad-2 ) ;
6385: LD_EXP 44
6389: PPUSH
6390: LD_STRING D8-Glad-2
6392: PPUSH
6393: CALL_OW 88
// Say ( Burlak , D8-Bur-2 ) ;
6397: LD_EXP 46
6401: PPUSH
6402: LD_STRING D8-Bur-2
6404: PPUSH
6405: CALL_OW 88
// end ;
6409: END
// every 0 0$1 trigger GetLives ( am_bun ) < 500 and Difficulty = 3 and not amRetreat do
6410: LD_INT 23
6412: PPUSH
6413: CALL_OW 256
6417: PUSH
6418: LD_INT 500
6420: LESS
6421: PUSH
6422: LD_OWVAR 67
6426: PUSH
6427: LD_INT 3
6429: EQUAL
6430: AND
6431: PUSH
6432: LD_EXP 24
6436: NOT
6437: AND
6438: IFFALSE 6508
6440: GO 6442
6442: DISABLE
// begin amRetreat = true ;
6443: LD_ADDR_EXP 24
6447: PUSH
6448: LD_INT 1
6450: ST_TO_ADDR
// Say ( Johanna , D8-FSol1-2a ) ;
6451: LD_EXP 43
6455: PPUSH
6456: LD_STRING D8-FSol1-2a
6458: PPUSH
6459: CALL_OW 88
// ComMoveToArea ( [ Gladstone , Johanna ] , AmericanExitArea ) ;
6463: LD_EXP 44
6467: PUSH
6468: LD_EXP 43
6472: PUSH
6473: EMPTY
6474: LIST
6475: LIST
6476: PPUSH
6477: LD_INT 21
6479: PPUSH
6480: CALL_OW 113
// Say ( Gladstone , D8-Glad-2 ) ;
6484: LD_EXP 44
6488: PPUSH
6489: LD_STRING D8-Glad-2
6491: PPUSH
6492: CALL_OW 88
// Say ( Burlak , D8-Bur-2 ) ;
6496: LD_EXP 46
6500: PPUSH
6501: LD_STRING D8-Bur-2
6503: PPUSH
6504: CALL_OW 88
// end ;
6508: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_ok ] ] ) > 0 do var unit ;
6509: LD_INT 22
6511: PUSH
6512: LD_INT 1
6514: PUSH
6515: EMPTY
6516: LIST
6517: LIST
6518: PUSH
6519: LD_INT 21
6521: PUSH
6522: LD_INT 1
6524: PUSH
6525: EMPTY
6526: LIST
6527: LIST
6528: PUSH
6529: LD_INT 50
6531: PUSH
6532: EMPTY
6533: LIST
6534: PUSH
6535: EMPTY
6536: LIST
6537: LIST
6538: LIST
6539: PPUSH
6540: CALL_OW 69
6544: PUSH
6545: LD_INT 0
6547: GREATER
6548: IFFALSE 6676
6550: GO 6552
6552: DISABLE
6553: LD_INT 0
6555: PPUSH
// begin enable ;
6556: ENABLE
// for unit in FilterUnitsInArea ( AmericanExitArea , [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) do
6557: LD_ADDR_VAR 0 1
6561: PUSH
6562: LD_INT 21
6564: PPUSH
6565: LD_INT 22
6567: PUSH
6568: LD_INT 1
6570: PUSH
6571: EMPTY
6572: LIST
6573: LIST
6574: PUSH
6575: LD_INT 21
6577: PUSH
6578: LD_INT 1
6580: PUSH
6581: EMPTY
6582: LIST
6583: LIST
6584: PUSH
6585: EMPTY
6586: LIST
6587: LIST
6588: PPUSH
6589: CALL_OW 70
6593: PUSH
6594: FOR_IN
6595: IFFALSE 6674
// begin if unit = Gladstone then
6597: LD_VAR 0 1
6601: PUSH
6602: LD_EXP 44
6606: EQUAL
6607: IFFALSE 6637
// begin gladstoneEscape = true ;
6609: LD_ADDR_EXP 19
6613: PUSH
6614: LD_INT 1
6616: ST_TO_ADDR
// SaveCharacters ( Gladstone , missionPrefix & Gladstone ) ;
6617: LD_EXP 44
6621: PPUSH
6622: LD_EXP 30
6626: PUSH
6627: LD_STRING Gladstone
6629: STR
6630: PPUSH
6631: CALL_OW 38
// end else
6635: GO 6663
// begin JohannaEscape = true ;
6637: LD_ADDR_EXP 20
6641: PUSH
6642: LD_INT 1
6644: ST_TO_ADDR
// SaveCharacters ( Johanna , missionPrefix & Johanna ) ;
6645: LD_EXP 43
6649: PPUSH
6650: LD_EXP 30
6654: PUSH
6655: LD_STRING Johanna
6657: STR
6658: PPUSH
6659: CALL_OW 38
// end ; RemoveUnit ( unit ) ;
6663: LD_VAR 0 1
6667: PPUSH
6668: CALL_OW 64
// end ;
6672: GO 6594
6674: POP
6675: POP
// end ;
6676: PPOPN 1
6678: END
// every 0 0$1 trigger IsDead ( Gladstone ) and IsDead ( Johanna ) do
6679: LD_EXP 44
6683: PPUSH
6684: CALL_OW 301
6688: PUSH
6689: LD_EXP 43
6693: PPUSH
6694: CALL_OW 301
6698: AND
6699: IFFALSE 6716
6701: GO 6703
6703: DISABLE
// Say ( Burlak , D9-Bur-1 ) ;
6704: LD_EXP 46
6708: PPUSH
6709: LD_STRING D9-Bur-1
6711: PPUSH
6712: CALL_OW 88
6716: END
// every 0 0$1 trigger IsDead ( Johanna ) and gladstoneEscape and not JohannaEscape do
6717: LD_EXP 43
6721: PPUSH
6722: CALL_OW 301
6726: PUSH
6727: LD_EXP 19
6731: AND
6732: PUSH
6733: LD_EXP 20
6737: NOT
6738: AND
6739: IFFALSE 6756
6741: GO 6743
6743: DISABLE
// Say ( Burlak , D9-Bur-1a ) ;
6744: LD_EXP 46
6748: PPUSH
6749: LD_STRING D9-Bur-1a
6751: PPUSH
6752: CALL_OW 88
6756: END
// every 0 0$1 trigger IsDead ( Gladstone ) and not gladstoneEscape and JohannaEscape do
6757: LD_EXP 44
6761: PPUSH
6762: CALL_OW 301
6766: PUSH
6767: LD_EXP 19
6771: NOT
6772: AND
6773: PUSH
6774: LD_EXP 20
6778: AND
6779: IFFALSE 6796
6781: GO 6783
6783: DISABLE
// Say ( Burlak , D9-Bur-1b ) ;
6784: LD_EXP 46
6788: PPUSH
6789: LD_STRING D9-Bur-1b
6791: PPUSH
6792: CALL_OW 88
6796: END
// every 0 0$1 trigger gladstoneEscape and JohannaEscape do
6797: LD_EXP 19
6801: PUSH
6802: LD_EXP 20
6806: AND
6807: IFFALSE 6824
6809: GO 6811
6811: DISABLE
// Say ( Burlak , D9-Bur-1c ) ;
6812: LD_EXP 46
6816: PPUSH
6817: LD_STRING D9-Bur-1c
6819: PPUSH
6820: CALL_OW 88
6824: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_building ] , [ f_ok ] ] ) = 0 do var ruKirovSolds , ruKirovSoldsMaleRandom ;
6825: LD_INT 22
6827: PUSH
6828: LD_INT 1
6830: PUSH
6831: EMPTY
6832: LIST
6833: LIST
6834: PUSH
6835: LD_INT 21
6837: PUSH
6838: LD_INT 3
6840: PUSH
6841: EMPTY
6842: LIST
6843: LIST
6844: PUSH
6845: LD_INT 50
6847: PUSH
6848: EMPTY
6849: LIST
6850: PUSH
6851: EMPTY
6852: LIST
6853: LIST
6854: LIST
6855: PPUSH
6856: CALL_OW 69
6860: PUSH
6861: LD_INT 0
6863: EQUAL
6864: IFFALSE 7112
6866: GO 6868
6868: DISABLE
6869: LD_INT 0
6871: PPUSH
6872: PPUSH
// begin ruKirovSolds = FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_ok ] ] ) diff [ Burlak , Gnyevko , Belkov ] ;
6873: LD_ADDR_VAR 0 1
6877: PUSH
6878: LD_INT 22
6880: PUSH
6881: LD_INT 3
6883: PUSH
6884: EMPTY
6885: LIST
6886: LIST
6887: PUSH
6888: LD_INT 21
6890: PUSH
6891: LD_INT 1
6893: PUSH
6894: EMPTY
6895: LIST
6896: LIST
6897: PUSH
6898: LD_INT 50
6900: PUSH
6901: EMPTY
6902: LIST
6903: PUSH
6904: EMPTY
6905: LIST
6906: LIST
6907: LIST
6908: PPUSH
6909: CALL_OW 69
6913: PUSH
6914: LD_EXP 46
6918: PUSH
6919: LD_EXP 54
6923: PUSH
6924: LD_EXP 51
6928: PUSH
6929: EMPTY
6930: LIST
6931: LIST
6932: LIST
6933: DIFF
6934: ST_TO_ADDR
// ruKirovSoldsMaleRandom = UnitFilter ( ruKirovSolds , [ f_sex , sex_male ] ) ;
6935: LD_ADDR_VAR 0 2
6939: PUSH
6940: LD_VAR 0 1
6944: PPUSH
6945: LD_INT 26
6947: PUSH
6948: LD_INT 1
6950: PUSH
6951: EMPTY
6952: LIST
6953: LIST
6954: PPUSH
6955: CALL_OW 72
6959: ST_TO_ADDR
// DialogueOn ;
6960: CALL_OW 6
// if IsOK ( Belkov ) then
6964: LD_EXP 51
6968: PPUSH
6969: CALL_OW 302
6973: IFFALSE 6987
// Say ( Belkov , D10-Bel-1 ) ;
6975: LD_EXP 51
6979: PPUSH
6980: LD_STRING D10-Bel-1
6982: PPUSH
6983: CALL_OW 88
// if ruKirovSolds > 0 and ( ruKirovSoldsMaleRandom > 0 or IsOk ( Belkov ) ) then
6987: LD_VAR 0 1
6991: PUSH
6992: LD_INT 0
6994: GREATER
6995: PUSH
6996: LD_VAR 0 2
7000: PUSH
7001: LD_INT 0
7003: GREATER
7004: PUSH
7005: LD_EXP 51
7009: PPUSH
7010: CALL_OW 302
7014: OR
7015: AND
7016: IFFALSE 7083
// begin Say ( Burlak , D10-Bur-1 ) ;
7018: LD_EXP 46
7022: PPUSH
7023: LD_STRING D10-Bur-1
7025: PPUSH
7026: CALL_OW 88
// if IsOK ( Belkov ) then
7030: LD_EXP 51
7034: PPUSH
7035: CALL_OW 302
7039: IFFALSE 7055
// Say ( Belkov , D10-Bel-1a ) else
7041: LD_EXP 51
7045: PPUSH
7046: LD_STRING D10-Bel-1a
7048: PPUSH
7049: CALL_OW 88
7053: GO 7071
// Say ( ruKirovSoldsMaleRandom [ 1 ] , D10-RSol1-1 ) ;
7055: LD_VAR 0 2
7059: PUSH
7060: LD_INT 1
7062: ARRAY
7063: PPUSH
7064: LD_STRING D10-RSol1-1
7066: PPUSH
7067: CALL_OW 88
// Say ( Burlak , D10-Bur-2 ) ;
7071: LD_EXP 46
7075: PPUSH
7076: LD_STRING D10-Bur-2
7078: PPUSH
7079: CALL_OW 88
// end ; DialogueOff ;
7083: CALL_OW 7
// ChangeMissionObjectives ( M4a ) ;
7087: LD_STRING M4a
7089: PPUSH
7090: CALL_OW 337
// evacuationAvailable = true ;
7094: LD_ADDR_EXP 22
7098: PUSH
7099: LD_INT 1
7101: ST_TO_ADDR
// SetAreaMapShow ( ExitArea , 1 ) ;
7102: LD_INT 1
7104: PPUSH
7105: LD_INT 1
7107: PPUSH
7108: CALL_OW 424
// end ;
7112: PPOPN 2
7114: END
// every 0 0$15 trigger evacuationAvailable and not jelenaSpawned do var randomSold ;
7115: LD_EXP 22
7119: PUSH
7120: LD_EXP 25
7124: NOT
7125: AND
7126: IFFALSE 7736
7128: GO 7130
7130: DISABLE
7131: LD_INT 0
7133: PPUSH
// begin PlaceUnitArea ( Kirilenkova , JelenaSpawnArea , true ) ;
7134: LD_EXP 53
7138: PPUSH
7139: LD_INT 22
7141: PPUSH
7142: LD_INT 1
7144: PPUSH
7145: CALL_OW 49
// wait ( 0 0$3 ) ;
7149: LD_INT 105
7151: PPUSH
7152: CALL_OW 67
// jelenaSpawned = true ;
7156: LD_ADDR_EXP 25
7160: PUSH
7161: LD_INT 1
7163: ST_TO_ADDR
// if GetDistUnits ( NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_ok ] ] ) , Kirilenkova ) , Kirilenkova ) < 9 then
7164: LD_INT 22
7166: PUSH
7167: LD_INT 3
7169: PUSH
7170: EMPTY
7171: LIST
7172: LIST
7173: PUSH
7174: LD_INT 21
7176: PUSH
7177: LD_INT 1
7179: PUSH
7180: EMPTY
7181: LIST
7182: LIST
7183: PUSH
7184: LD_INT 50
7186: PUSH
7187: EMPTY
7188: LIST
7189: PUSH
7190: EMPTY
7191: LIST
7192: LIST
7193: LIST
7194: PPUSH
7195: CALL_OW 69
7199: PPUSH
7200: LD_EXP 53
7204: PPUSH
7205: CALL_OW 74
7209: PPUSH
7210: LD_EXP 53
7214: PPUSH
7215: CALL_OW 296
7219: PUSH
7220: LD_INT 9
7222: LESS
7223: IFFALSE 7227
// exit ;
7225: GO 7736
// DialogueOn ;
7227: CALL_OW 6
// SayRadio ( Kirilenkova , D11b-Kir-1 ) ;
7231: LD_EXP 53
7235: PPUSH
7236: LD_STRING D11b-Kir-1
7238: PPUSH
7239: CALL_OW 94
// if IsOK ( Belkov ) then
7243: LD_EXP 51
7247: PPUSH
7248: CALL_OW 302
7252: IFFALSE 7280
// begin Say ( Belkov , D11b-Bel-1 ) ;
7254: LD_EXP 51
7258: PPUSH
7259: LD_STRING D11b-Bel-1
7261: PPUSH
7262: CALL_OW 88
// SayRadio ( Belkov , D11b-Bel-1a ) ;
7266: LD_EXP 51
7270: PPUSH
7271: LD_STRING D11b-Bel-1a
7273: PPUSH
7274: CALL_OW 94
// end else
7278: GO 7335
// begin randomSold = DialogRandom ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_ok ] ] ) , D11b-RSol1-1 , D11b-RFSol1-1 , false ) ;
7280: LD_ADDR_VAR 0 1
7284: PUSH
7285: LD_INT 22
7287: PUSH
7288: LD_INT 3
7290: PUSH
7291: EMPTY
7292: LIST
7293: LIST
7294: PUSH
7295: LD_INT 21
7297: PUSH
7298: LD_INT 1
7300: PUSH
7301: EMPTY
7302: LIST
7303: LIST
7304: PUSH
7305: LD_INT 50
7307: PUSH
7308: EMPTY
7309: LIST
7310: PUSH
7311: EMPTY
7312: LIST
7313: LIST
7314: LIST
7315: PPUSH
7316: CALL_OW 69
7320: PPUSH
7321: LD_STRING D11b-RSol1-1
7323: PPUSH
7324: LD_STRING D11b-RFSol1-1
7326: PPUSH
7327: LD_INT 0
7329: PPUSH
7330: CALL 8113 0 4
7334: ST_TO_ADDR
// end ; if FilterUnitsInArea ( ApeLakeArea , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) > 0 then
7335: LD_INT 24
7337: PPUSH
7338: LD_INT 22
7340: PUSH
7341: LD_INT 0
7343: PUSH
7344: EMPTY
7345: LIST
7346: LIST
7347: PUSH
7348: LD_INT 25
7350: PUSH
7351: LD_INT 12
7353: PUSH
7354: EMPTY
7355: LIST
7356: LIST
7357: PUSH
7358: EMPTY
7359: LIST
7360: LIST
7361: PPUSH
7362: CALL_OW 70
7366: PUSH
7367: LD_INT 0
7369: GREATER
7370: IFFALSE 7386
// SayRadio ( Kirilenkova , D11b1-Kir-1 ) else
7372: LD_EXP 53
7376: PPUSH
7377: LD_STRING D11b1-Kir-1
7379: PPUSH
7380: CALL_OW 94
7384: GO 7398
// SayRadio ( Kirilenkova , D11b2-Kir-1 ) ;
7386: LD_EXP 53
7390: PPUSH
7391: LD_STRING D11b2-Kir-1
7393: PPUSH
7394: CALL_OW 94
// if attackedByApemanNearLake and FilterUnitsInArea ( ApeLakeArea , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) > 0 then
7398: LD_EXP 6
7402: PUSH
7403: LD_INT 24
7405: PPUSH
7406: LD_INT 22
7408: PUSH
7409: LD_INT 0
7411: PUSH
7412: EMPTY
7413: LIST
7414: LIST
7415: PUSH
7416: LD_INT 25
7418: PUSH
7419: LD_INT 12
7421: PUSH
7422: EMPTY
7423: LIST
7424: LIST
7425: PUSH
7426: EMPTY
7427: LIST
7428: LIST
7429: PPUSH
7430: CALL_OW 70
7434: PUSH
7435: LD_INT 0
7437: GREATER
7438: AND
7439: IFFALSE 7574
// begin Say ( Burlak , D11b1-Bur-1 ) ;
7441: LD_EXP 46
7445: PPUSH
7446: LD_STRING D11b1-Bur-1
7448: PPUSH
7449: CALL_OW 88
// if IsOk ( Belkov ) then
7453: LD_EXP 51
7457: PPUSH
7458: CALL_OW 302
7462: IFFALSE 7478
// Say ( Belkov , D11b2-Bel-1 ) else
7464: LD_EXP 51
7468: PPUSH
7469: LD_STRING D11b2-Bel-1
7471: PPUSH
7472: CALL_OW 88
7476: GO 7519
// begin if GetSex ( randomSold ) = sex_male then
7478: LD_VAR 0 1
7482: PPUSH
7483: CALL_OW 258
7487: PUSH
7488: LD_INT 1
7490: EQUAL
7491: IFFALSE 7507
// Say ( randomSold , D11b1-RSol1-1 ) else
7493: LD_VAR 0 1
7497: PPUSH
7498: LD_STRING D11b1-RSol1-1
7500: PPUSH
7501: CALL_OW 88
7505: GO 7519
// Say ( randomSold , D11b1-RFSol1-1 ) ;
7507: LD_VAR 0 1
7511: PPUSH
7512: LD_STRING D11b1-RFSol1-1
7514: PPUSH
7515: CALL_OW 88
// end ; DialogRandom ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_ok ] ] ) , D11b1-RSol1-1 , D11b1-RFSol1-1 , false ) ;
7519: LD_INT 22
7521: PUSH
7522: LD_INT 1
7524: PUSH
7525: EMPTY
7526: LIST
7527: LIST
7528: PUSH
7529: LD_INT 21
7531: PUSH
7532: LD_INT 1
7534: PUSH
7535: EMPTY
7536: LIST
7537: LIST
7538: PUSH
7539: LD_INT 50
7541: PUSH
7542: EMPTY
7543: LIST
7544: PUSH
7545: EMPTY
7546: LIST
7547: LIST
7548: LIST
7549: PPUSH
7550: CALL_OW 69
7554: PPUSH
7555: LD_STRING D11b1-RSol1-1
7557: PPUSH
7558: LD_STRING D11b1-RFSol1-1
7560: PPUSH
7561: LD_INT 0
7563: PPUSH
7564: CALL 8113 0 4
// DialogueOff ;
7568: CALL_OW 7
// exit ;
7572: GO 7736
// end ; if spotWaterfall then
7574: LD_EXP 7
7578: IFFALSE 7664
// begin Say ( Burlak , D11b1-Bur-1a ) ;
7580: LD_EXP 46
7584: PPUSH
7585: LD_STRING D11b1-Bur-1a
7587: PPUSH
7588: CALL_OW 88
// if IsOk ( Belkov ) then
7592: LD_EXP 51
7596: PPUSH
7597: CALL_OW 302
7601: IFFALSE 7617
// Say ( Belkov , D11b2-Bel-1 ) else
7603: LD_EXP 51
7607: PPUSH
7608: LD_STRING D11b2-Bel-1
7610: PPUSH
7611: CALL_OW 88
7615: GO 7658
// begin if GetSex ( randomSold ) = sex_male then
7617: LD_VAR 0 1
7621: PPUSH
7622: CALL_OW 258
7626: PUSH
7627: LD_INT 1
7629: EQUAL
7630: IFFALSE 7646
// Say ( randomSold , D11b1-RSol1-1 ) else
7632: LD_VAR 0 1
7636: PPUSH
7637: LD_STRING D11b1-RSol1-1
7639: PPUSH
7640: CALL_OW 88
7644: GO 7658
// Say ( randomSold , D11b1-RFSol1-1 ) ;
7646: LD_VAR 0 1
7650: PPUSH
7651: LD_STRING D11b1-RFSol1-1
7653: PPUSH
7654: CALL_OW 88
// end ; DialogueOff ;
7658: CALL_OW 7
// exit ;
7662: GO 7736
// end ; if IsOk ( Belkov ) then
7664: LD_EXP 51
7668: PPUSH
7669: CALL_OW 302
7673: IFFALSE 7689
// Say ( Belkov , D11b1-Bel-1 ) else
7675: LD_EXP 51
7679: PPUSH
7680: LD_STRING D11b1-Bel-1
7682: PPUSH
7683: CALL_OW 88
7687: GO 7730
// begin if GetSex ( randomSold ) = sex_male then
7689: LD_VAR 0 1
7693: PPUSH
7694: CALL_OW 258
7698: PUSH
7699: LD_INT 1
7701: EQUAL
7702: IFFALSE 7718
// Say ( randomSold , D11b1-RSol1-1 ) else
7704: LD_VAR 0 1
7708: PPUSH
7709: LD_STRING D11b1-RSol1-1
7711: PPUSH
7712: CALL_OW 88
7716: GO 7730
// Say ( randomSold , D11b1-RFSol1-1 ) ;
7718: LD_VAR 0 1
7722: PPUSH
7723: LD_STRING D11b1-RFSol1-1
7725: PPUSH
7726: CALL_OW 88
// end ; DialogueOff ;
7730: CALL_OW 7
// exit ;
7734: GO 7736
// end ;
7736: PPOPN 1
7738: END
// every 0 0$1 trigger See ( 3 , Kirilenkova ) and jelenaSpawned do var nearUnit ;
7739: LD_INT 3
7741: PPUSH
7742: LD_EXP 53
7746: PPUSH
7747: CALL_OW 292
7751: PUSH
7752: LD_EXP 25
7756: AND
7757: IFFALSE 7993
7759: GO 7761
7761: DISABLE
7762: LD_INT 0
7764: PPUSH
// begin SetSide ( Kirilenkova , 3 ) ;
7765: LD_EXP 53
7769: PPUSH
7770: LD_INT 3
7772: PPUSH
7773: CALL_OW 235
// jelenaSaved = true ;
7777: LD_ADDR_EXP 21
7781: PUSH
7782: LD_INT 1
7784: ST_TO_ADDR
// CenterNowOnUnits ( Kirilenkova ) ;
7785: LD_EXP 53
7789: PPUSH
7790: CALL_OW 87
// nearUnit = NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_ok ] ] ) diff Kirilenkova , Kirilenkova ) ;
7794: LD_ADDR_VAR 0 1
7798: PUSH
7799: LD_INT 22
7801: PUSH
7802: LD_INT 3
7804: PUSH
7805: EMPTY
7806: LIST
7807: LIST
7808: PUSH
7809: LD_INT 21
7811: PUSH
7812: LD_INT 1
7814: PUSH
7815: EMPTY
7816: LIST
7817: LIST
7818: PUSH
7819: LD_INT 50
7821: PUSH
7822: EMPTY
7823: LIST
7824: PUSH
7825: EMPTY
7826: LIST
7827: LIST
7828: LIST
7829: PPUSH
7830: CALL_OW 69
7834: PUSH
7835: LD_EXP 53
7839: DIFF
7840: PPUSH
7841: LD_EXP 53
7845: PPUSH
7846: CALL_OW 74
7850: ST_TO_ADDR
// DialogueOn ;
7851: CALL_OW 6
// Say ( Kirilenkova , D11a-Kir-1 ) ;
7855: LD_EXP 53
7859: PPUSH
7860: LD_STRING D11a-Kir-1
7862: PPUSH
7863: CALL_OW 88
// if nearUnit = Belkov then
7867: LD_VAR 0 1
7871: PUSH
7872: LD_EXP 51
7876: EQUAL
7877: IFFALSE 7917
// begin Say ( Belkov , D11a-Bel-1 ) ;
7879: LD_EXP 51
7883: PPUSH
7884: LD_STRING D11a-Bel-1
7886: PPUSH
7887: CALL_OW 88
// Say ( Kirilenkova , D11a-Kir-2 ) ;
7891: LD_EXP 53
7895: PPUSH
7896: LD_STRING D11a-Kir-2
7898: PPUSH
7899: CALL_OW 88
// Say ( Belkov , D11a-Bel-2 ) ;
7903: LD_EXP 51
7907: PPUSH
7908: LD_STRING D11a-Bel-2
7910: PPUSH
7911: CALL_OW 88
// end else
7915: GO 7958
// begin if GetSex ( nearUnit ) = sex_male then
7917: LD_VAR 0 1
7921: PPUSH
7922: CALL_OW 258
7926: PUSH
7927: LD_INT 1
7929: EQUAL
7930: IFFALSE 7946
// Say ( nearUnit , D11a-RSol1-2 ) else
7932: LD_VAR 0 1
7936: PPUSH
7937: LD_STRING D11a-RSol1-2
7939: PPUSH
7940: CALL_OW 88
7944: GO 7958
// Say ( nearUnit , D11a-RFSol1-2 ) ;
7946: LD_VAR 0 1
7950: PPUSH
7951: LD_STRING D11a-RFSol1-2
7953: PPUSH
7954: CALL_OW 88
// end ; DialogueOff ;
7958: CALL_OW 7
// wait ( 0 0$5 ) ;
7962: LD_INT 175
7964: PPUSH
7965: CALL_OW 67
// Say ( Kirilenkova , D11c-Kir-1 ) ;
7969: LD_EXP 53
7973: PPUSH
7974: LD_STRING D11c-Kir-1
7976: PPUSH
7977: CALL_OW 88
// Say ( Burlak , D11c-Bur-1 ) ;
7981: LD_EXP 46
7985: PPUSH
7986: LD_STRING D11c-Bur-1
7988: PPUSH
7989: CALL_OW 88
// end ;
7993: PPOPN 1
7995: END
// every 0 0$1 trigger evacuationAvailable and FilterUnitsInArea ( ExitArea , [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) > 0 do
7996: LD_EXP 22
8000: PUSH
8001: LD_INT 1
8003: PPUSH
8004: LD_INT 22
8006: PUSH
8007: LD_INT 3
8009: PUSH
8010: EMPTY
8011: LIST
8012: LIST
8013: PUSH
8014: LD_INT 21
8016: PUSH
8017: LD_INT 1
8019: PUSH
8020: EMPTY
8021: LIST
8022: LIST
8023: PUSH
8024: EMPTY
8025: LIST
8026: LIST
8027: PPUSH
8028: CALL_OW 70
8032: PUSH
8033: LD_INT 0
8035: GREATER
8036: AND
8037: IFFALSE 8049
8039: GO 8041
8041: DISABLE
// begin Query ( QExit1 ) ;
8042: LD_STRING QExit1
8044: PPUSH
8045: CALL_OW 97
// end ; end_of_file
8049: END
// export function PrepareUnit ( ident , exist_mode ) ; var unit ; begin
8050: LD_INT 0
8052: PPUSH
8053: PPUSH
// if exist_mode then
8054: LD_VAR 0 2
8058: IFFALSE 8083
// unit := CreateCharacter ( previousMissionPrefix & ident ) else
8060: LD_ADDR_VAR 0 4
8064: PUSH
8065: LD_EXP 31
8069: PUSH
8070: LD_VAR 0 1
8074: STR
8075: PPUSH
8076: CALL_OW 34
8080: ST_TO_ADDR
8081: GO 8098
// unit := NewCharacter ( ident ) ;
8083: LD_ADDR_VAR 0 4
8087: PUSH
8088: LD_VAR 0 1
8092: PPUSH
8093: CALL_OW 25
8097: ST_TO_ADDR
// result := unit ;
8098: LD_ADDR_VAR 0 3
8102: PUSH
8103: LD_VAR 0 4
8107: ST_TO_ADDR
// end ;
8108: LD_VAR 0 3
8112: RET
// export function DialogRandom ( characters , dialogMID , dialogFID , radio ) ; var i , speaker ; begin
8113: LD_INT 0
8115: PPUSH
8116: PPUSH
8117: PPUSH
// characters := characters diff [ Burlak , Gnyevko , Belkov , Kirilenkova ] ;
8118: LD_ADDR_VAR 0 1
8122: PUSH
8123: LD_VAR 0 1
8127: PUSH
8128: LD_EXP 46
8132: PUSH
8133: LD_EXP 54
8137: PUSH
8138: LD_EXP 51
8142: PUSH
8143: LD_EXP 53
8147: PUSH
8148: EMPTY
8149: LIST
8150: LIST
8151: LIST
8152: LIST
8153: DIFF
8154: ST_TO_ADDR
// speaker := characters [ rand ( 1 , characters ) ] ;
8155: LD_ADDR_VAR 0 7
8159: PUSH
8160: LD_VAR 0 1
8164: PUSH
8165: LD_INT 1
8167: PPUSH
8168: LD_VAR 0 1
8172: PPUSH
8173: CALL_OW 12
8177: ARRAY
8178: ST_TO_ADDR
// if radio then
8179: LD_VAR 0 4
8183: IFFALSE 8232
// begin if GetSex ( speaker ) = sex_male then
8185: LD_VAR 0 7
8189: PPUSH
8190: CALL_OW 258
8194: PUSH
8195: LD_INT 1
8197: EQUAL
8198: IFFALSE 8216
// SayRadio ( speaker , dialogMID ) else
8200: LD_VAR 0 7
8204: PPUSH
8205: LD_VAR 0 2
8209: PPUSH
8210: CALL_OW 94
8214: GO 8230
// SayRadio ( speaker , dialogFID ) ;
8216: LD_VAR 0 7
8220: PPUSH
8221: LD_VAR 0 3
8225: PPUSH
8226: CALL_OW 94
// end else
8230: GO 8277
// begin if GetSex ( speaker ) = sex_male then
8232: LD_VAR 0 7
8236: PPUSH
8237: CALL_OW 258
8241: PUSH
8242: LD_INT 1
8244: EQUAL
8245: IFFALSE 8263
// Say ( speaker , dialogMID ) else
8247: LD_VAR 0 7
8251: PPUSH
8252: LD_VAR 0 2
8256: PPUSH
8257: CALL_OW 88
8261: GO 8277
// Say ( speaker , dialogFID ) ;
8263: LD_VAR 0 7
8267: PPUSH
8268: LD_VAR 0 3
8272: PPUSH
8273: CALL_OW 88
// end ; result := speaker ;
8277: LD_ADDR_VAR 0 5
8281: PUSH
8282: LD_VAR 0 7
8286: ST_TO_ADDR
// end ;
8287: LD_VAR 0 5
8291: RET
// export function ExtSaveCharacter ( character , characterStringID ) ; begin
8292: LD_INT 0
8294: PPUSH
// if GetSide ( character ) = your_side and IsOK ( character ) then
8295: LD_VAR 0 1
8299: PPUSH
8300: CALL_OW 255
8304: PUSH
8305: LD_OWVAR 2
8309: EQUAL
8310: PUSH
8311: LD_VAR 0 1
8315: PPUSH
8316: CALL_OW 302
8320: AND
8321: IFFALSE 8343
// SaveCharacters ( character , missionPrefix & characterStringID ) ;
8323: LD_VAR 0 1
8327: PPUSH
8328: LD_EXP 30
8332: PUSH
8333: LD_VAR 0 2
8337: STR
8338: PPUSH
8339: CALL_OW 38
// end ;
8343: LD_VAR 0 3
8347: RET
// export function ExtSaveCharacters ( characters , charactersStringID ) ; var unit , resultCharactersToSave ; begin
8348: LD_INT 0
8350: PPUSH
8351: PPUSH
8352: PPUSH
// resultCharactersToSave = [ ] ;
8353: LD_ADDR_VAR 0 5
8357: PUSH
8358: EMPTY
8359: ST_TO_ADDR
// for unit in characters do
8360: LD_ADDR_VAR 0 4
8364: PUSH
8365: LD_VAR 0 1
8369: PUSH
8370: FOR_IN
8371: IFFALSE 8419
// if GetSide ( unit ) = your_side and IsOK ( unit ) then
8373: LD_VAR 0 4
8377: PPUSH
8378: CALL_OW 255
8382: PUSH
8383: LD_OWVAR 2
8387: EQUAL
8388: PUSH
8389: LD_VAR 0 4
8393: PPUSH
8394: CALL_OW 302
8398: AND
8399: IFFALSE 8417
// resultCharactersToSave = resultCharactersToSave ^ unit ;
8401: LD_ADDR_VAR 0 5
8405: PUSH
8406: LD_VAR 0 5
8410: PUSH
8411: LD_VAR 0 4
8415: ADD
8416: ST_TO_ADDR
8417: GO 8370
8419: POP
8420: POP
// SaveCharacters ( resultCharactersToSave , missionPrefix & charactersStringID ) ;
8421: LD_VAR 0 5
8425: PPUSH
8426: LD_EXP 30
8430: PUSH
8431: LD_VAR 0 2
8435: STR
8436: PPUSH
8437: CALL_OW 38
// end ;
8441: LD_VAR 0 3
8445: RET
// export function GetAwayFromXY ( unit1 , x , y , dist , add ) ; var list_nearest , list_coords , temp_dir , dir_list , b , min_dist , temp_dist , c , rand_num , rand_near_hex , attempts ; begin
8446: LD_INT 0
8448: PPUSH
8449: PPUSH
8450: PPUSH
8451: PPUSH
8452: PPUSH
8453: PPUSH
8454: PPUSH
8455: PPUSH
8456: PPUSH
8457: PPUSH
8458: PPUSH
8459: PPUSH
// if not IsOk ( unit1 ) or dist = 1 or not ValidHex ( x , y ) or GetDistUnitXY ( unit1 , x , y ) >= dist or not add in [ true , false ] then
8460: LD_VAR 0 1
8464: PPUSH
8465: CALL_OW 302
8469: NOT
8470: PUSH
8471: LD_VAR 0 4
8475: PUSH
8476: LD_INT 1
8478: EQUAL
8479: OR
8480: PUSH
8481: LD_VAR 0 2
8485: PPUSH
8486: LD_VAR 0 3
8490: PPUSH
8491: CALL_OW 488
8495: NOT
8496: OR
8497: PUSH
8498: LD_VAR 0 1
8502: PPUSH
8503: LD_VAR 0 2
8507: PPUSH
8508: LD_VAR 0 3
8512: PPUSH
8513: CALL_OW 297
8517: PUSH
8518: LD_VAR 0 4
8522: GREATEREQUAL
8523: OR
8524: PUSH
8525: LD_VAR 0 5
8529: PUSH
8530: LD_INT 1
8532: PUSH
8533: LD_INT 0
8535: PUSH
8536: EMPTY
8537: LIST
8538: LIST
8539: IN
8540: NOT
8541: OR
8542: IFFALSE 8546
// exit ;
8544: GO 10103
// attempts = 0 ;
8546: LD_ADDR_VAR 0 17
8550: PUSH
8551: LD_INT 0
8553: ST_TO_ADDR
// repeat list_nearest = [ ] ;
8554: LD_ADDR_VAR 0 7
8558: PUSH
8559: EMPTY
8560: ST_TO_ADDR
// list_coords = [ ] ;
8561: LD_ADDR_VAR 0 8
8565: PUSH
8566: EMPTY
8567: ST_TO_ADDR
// temp_dir = GetTurnDirection ( x , y , GetX ( unit1 ) , GetY ( unit1 ) ) ;
8568: LD_ADDR_VAR 0 9
8572: PUSH
8573: LD_VAR 0 2
8577: PPUSH
8578: LD_VAR 0 3
8582: PPUSH
8583: LD_VAR 0 1
8587: PPUSH
8588: CALL_OW 250
8592: PPUSH
8593: LD_VAR 0 1
8597: PPUSH
8598: CALL_OW 251
8602: PPUSH
8603: CALL 10108 0 4
8607: ST_TO_ADDR
// if attempts = 0 then
8608: LD_VAR 0 17
8612: PUSH
8613: LD_INT 0
8615: EQUAL
8616: IFFALSE 8724
// begin dir_list = [ temp_dir , temp_dir + 1 , temp_dir - 1 ] ;
8618: LD_ADDR_VAR 0 10
8622: PUSH
8623: LD_VAR 0 9
8627: PUSH
8628: LD_VAR 0 9
8632: PUSH
8633: LD_INT 1
8635: PLUS
8636: PUSH
8637: LD_VAR 0 9
8641: PUSH
8642: LD_INT 1
8644: MINUS
8645: PUSH
8646: EMPTY
8647: LIST
8648: LIST
8649: LIST
8650: ST_TO_ADDR
// if dir_list [ 2 ] = 6 then
8651: LD_VAR 0 10
8655: PUSH
8656: LD_INT 2
8658: ARRAY
8659: PUSH
8660: LD_INT 6
8662: EQUAL
8663: IFFALSE 8686
// dir_list = Replace ( dir_list , 2 , 0 ) ;
8665: LD_ADDR_VAR 0 10
8669: PUSH
8670: LD_VAR 0 10
8674: PPUSH
8675: LD_INT 2
8677: PPUSH
8678: LD_INT 0
8680: PPUSH
8681: CALL_OW 1
8685: ST_TO_ADDR
// if dir_list [ 3 ] = - 1 then
8686: LD_VAR 0 10
8690: PUSH
8691: LD_INT 3
8693: ARRAY
8694: PUSH
8695: LD_INT 1
8697: NEG
8698: EQUAL
8699: IFFALSE 8722
// dir_list = Replace ( dir_list , 3 , 5 ) ;
8701: LD_ADDR_VAR 0 10
8705: PUSH
8706: LD_VAR 0 10
8710: PPUSH
8711: LD_INT 3
8713: PPUSH
8714: LD_INT 5
8716: PPUSH
8717: CALL_OW 1
8721: ST_TO_ADDR
// end else
8722: GO 8761
// dir_list = [ 0 , 1 , 2 , 3 , 4 , 5 ] diff temp_dir ;
8724: LD_ADDR_VAR 0 10
8728: PUSH
8729: LD_INT 0
8731: PUSH
8732: LD_INT 1
8734: PUSH
8735: LD_INT 2
8737: PUSH
8738: LD_INT 3
8740: PUSH
8741: LD_INT 4
8743: PUSH
8744: LD_INT 5
8746: PUSH
8747: EMPTY
8748: LIST
8749: LIST
8750: LIST
8751: LIST
8752: LIST
8753: LIST
8754: PUSH
8755: LD_VAR 0 9
8759: DIFF
8760: ST_TO_ADDR
// for c = 1 to ( dir_list + 0 ) do
8761: LD_ADDR_VAR 0 14
8765: PUSH
8766: DOUBLE
8767: LD_INT 1
8769: DEC
8770: ST_TO_ADDR
8771: LD_VAR 0 10
8775: PUSH
8776: LD_INT 0
8778: PLUS
8779: PUSH
8780: FOR_TO
8781: IFFALSE 9103
// case dir_list [ c ] of 0 :
8783: LD_VAR 0 10
8787: PUSH
8788: LD_VAR 0 14
8792: ARRAY
8793: PUSH
8794: LD_INT 0
8796: DOUBLE
8797: EQUAL
8798: IFTRUE 8802
8800: GO 8843
8802: POP
// list_coords = Insert ( list_coords , 1 , [ x , y - dist ] ) ; 1 :
8803: LD_ADDR_VAR 0 8
8807: PUSH
8808: LD_VAR 0 8
8812: PPUSH
8813: LD_INT 1
8815: PPUSH
8816: LD_VAR 0 2
8820: PUSH
8821: LD_VAR 0 3
8825: PUSH
8826: LD_VAR 0 4
8830: MINUS
8831: PUSH
8832: EMPTY
8833: LIST
8834: LIST
8835: PPUSH
8836: CALL_OW 2
8840: ST_TO_ADDR
8841: GO 9101
8843: LD_INT 1
8845: DOUBLE
8846: EQUAL
8847: IFTRUE 8851
8849: GO 8892
8851: POP
// list_coords = Insert ( list_coords , 1 , [ x + dist , y ] ) ; 2 :
8852: LD_ADDR_VAR 0 8
8856: PUSH
8857: LD_VAR 0 8
8861: PPUSH
8862: LD_INT 1
8864: PPUSH
8865: LD_VAR 0 2
8869: PUSH
8870: LD_VAR 0 4
8874: PLUS
8875: PUSH
8876: LD_VAR 0 3
8880: PUSH
8881: EMPTY
8882: LIST
8883: LIST
8884: PPUSH
8885: CALL_OW 2
8889: ST_TO_ADDR
8890: GO 9101
8892: LD_INT 2
8894: DOUBLE
8895: EQUAL
8896: IFTRUE 8900
8898: GO 8947
8900: POP
// list_coords = Insert ( list_coords , 1 , [ x + dist , y + dist ] ) ; 3 :
8901: LD_ADDR_VAR 0 8
8905: PUSH
8906: LD_VAR 0 8
8910: PPUSH
8911: LD_INT 1
8913: PPUSH
8914: LD_VAR 0 2
8918: PUSH
8919: LD_VAR 0 4
8923: PLUS
8924: PUSH
8925: LD_VAR 0 3
8929: PUSH
8930: LD_VAR 0 4
8934: PLUS
8935: PUSH
8936: EMPTY
8937: LIST
8938: LIST
8939: PPUSH
8940: CALL_OW 2
8944: ST_TO_ADDR
8945: GO 9101
8947: LD_INT 3
8949: DOUBLE
8950: EQUAL
8951: IFTRUE 8955
8953: GO 8996
8955: POP
// list_coords = Insert ( list_coords , 1 , [ x , y + dist ] ) ; 4 :
8956: LD_ADDR_VAR 0 8
8960: PUSH
8961: LD_VAR 0 8
8965: PPUSH
8966: LD_INT 1
8968: PPUSH
8969: LD_VAR 0 2
8973: PUSH
8974: LD_VAR 0 3
8978: PUSH
8979: LD_VAR 0 4
8983: PLUS
8984: PUSH
8985: EMPTY
8986: LIST
8987: LIST
8988: PPUSH
8989: CALL_OW 2
8993: ST_TO_ADDR
8994: GO 9101
8996: LD_INT 4
8998: DOUBLE
8999: EQUAL
9000: IFTRUE 9004
9002: GO 9045
9004: POP
// list_coords = Insert ( list_coords , 1 , [ x - dist , y ] ) ; 5 :
9005: LD_ADDR_VAR 0 8
9009: PUSH
9010: LD_VAR 0 8
9014: PPUSH
9015: LD_INT 1
9017: PPUSH
9018: LD_VAR 0 2
9022: PUSH
9023: LD_VAR 0 4
9027: MINUS
9028: PUSH
9029: LD_VAR 0 3
9033: PUSH
9034: EMPTY
9035: LIST
9036: LIST
9037: PPUSH
9038: CALL_OW 2
9042: ST_TO_ADDR
9043: GO 9101
9045: LD_INT 5
9047: DOUBLE
9048: EQUAL
9049: IFTRUE 9053
9051: GO 9100
9053: POP
// list_coords = Insert ( list_coords , 1 , [ x - dist , y - dist ] ) ; end ;
9054: LD_ADDR_VAR 0 8
9058: PUSH
9059: LD_VAR 0 8
9063: PPUSH
9064: LD_INT 1
9066: PPUSH
9067: LD_VAR 0 2
9071: PUSH
9072: LD_VAR 0 4
9076: MINUS
9077: PUSH
9078: LD_VAR 0 3
9082: PUSH
9083: LD_VAR 0 4
9087: MINUS
9088: PUSH
9089: EMPTY
9090: LIST
9091: LIST
9092: PPUSH
9093: CALL_OW 2
9097: ST_TO_ADDR
9098: GO 9101
9100: POP
9101: GO 8780
9103: POP
9104: POP
// if dist < 30 then
9105: LD_VAR 0 4
9109: PUSH
9110: LD_INT 30
9112: LESS
9113: IFFALSE 9125
// c = 1 else
9115: LD_ADDR_VAR 0 14
9119: PUSH
9120: LD_INT 1
9122: ST_TO_ADDR
9123: GO 9133
// c = 2 ;
9125: LD_ADDR_VAR 0 14
9129: PUSH
9130: LD_INT 2
9132: ST_TO_ADDR
// b = 1 ;
9133: LD_ADDR_VAR 0 11
9137: PUSH
9138: LD_INT 1
9140: ST_TO_ADDR
// while b <= ( dist - 1 ) do
9141: LD_VAR 0 11
9145: PUSH
9146: LD_VAR 0 4
9150: PUSH
9151: LD_INT 1
9153: MINUS
9154: LESSEQUAL
9155: IFFALSE 9583
// begin if 0 in dir_list and 1 in dir_list then
9157: LD_INT 0
9159: PUSH
9160: LD_VAR 0 10
9164: IN
9165: PUSH
9166: LD_INT 1
9168: PUSH
9169: LD_VAR 0 10
9173: IN
9174: AND
9175: IFFALSE 9227
// list_coords = Insert ( list_coords , 1 , [ x + b , y - dist + b ] ) ;
9177: LD_ADDR_VAR 0 8
9181: PUSH
9182: LD_VAR 0 8
9186: PPUSH
9187: LD_INT 1
9189: PPUSH
9190: LD_VAR 0 2
9194: PUSH
9195: LD_VAR 0 11
9199: PLUS
9200: PUSH
9201: LD_VAR 0 3
9205: PUSH
9206: LD_VAR 0 4
9210: MINUS
9211: PUSH
9212: LD_VAR 0 11
9216: PLUS
9217: PUSH
9218: EMPTY
9219: LIST
9220: LIST
9221: PPUSH
9222: CALL_OW 2
9226: ST_TO_ADDR
// if 1 in dir_list and 2 in dir_list then
9227: LD_INT 1
9229: PUSH
9230: LD_VAR 0 10
9234: IN
9235: PUSH
9236: LD_INT 2
9238: PUSH
9239: LD_VAR 0 10
9243: IN
9244: AND
9245: IFFALSE 9291
// list_coords = Insert ( list_coords , 1 , [ x + dist , y + b ] ) ;
9247: LD_ADDR_VAR 0 8
9251: PUSH
9252: LD_VAR 0 8
9256: PPUSH
9257: LD_INT 1
9259: PPUSH
9260: LD_VAR 0 2
9264: PUSH
9265: LD_VAR 0 4
9269: PLUS
9270: PUSH
9271: LD_VAR 0 3
9275: PUSH
9276: LD_VAR 0 11
9280: PLUS
9281: PUSH
9282: EMPTY
9283: LIST
9284: LIST
9285: PPUSH
9286: CALL_OW 2
9290: ST_TO_ADDR
// if 2 in dir_list and 3 in dir_list then
9291: LD_INT 2
9293: PUSH
9294: LD_VAR 0 10
9298: IN
9299: PUSH
9300: LD_INT 3
9302: PUSH
9303: LD_VAR 0 10
9307: IN
9308: AND
9309: IFFALSE 9361
// list_coords = Insert ( list_coords , 1 , [ x + dist - b , y + dist ] ) ;
9311: LD_ADDR_VAR 0 8
9315: PUSH
9316: LD_VAR 0 8
9320: PPUSH
9321: LD_INT 1
9323: PPUSH
9324: LD_VAR 0 2
9328: PUSH
9329: LD_VAR 0 4
9333: PLUS
9334: PUSH
9335: LD_VAR 0 11
9339: MINUS
9340: PUSH
9341: LD_VAR 0 3
9345: PUSH
9346: LD_VAR 0 4
9350: PLUS
9351: PUSH
9352: EMPTY
9353: LIST
9354: LIST
9355: PPUSH
9356: CALL_OW 2
9360: ST_TO_ADDR
// if 3 in dir_list and 4 in dir_list then
9361: LD_INT 3
9363: PUSH
9364: LD_VAR 0 10
9368: IN
9369: PUSH
9370: LD_INT 4
9372: PUSH
9373: LD_VAR 0 10
9377: IN
9378: AND
9379: IFFALSE 9431
// list_coords = Insert ( list_coords , 1 , [ x - b , y + dist - b ] ) ;
9381: LD_ADDR_VAR 0 8
9385: PUSH
9386: LD_VAR 0 8
9390: PPUSH
9391: LD_INT 1
9393: PPUSH
9394: LD_VAR 0 2
9398: PUSH
9399: LD_VAR 0 11
9403: MINUS
9404: PUSH
9405: LD_VAR 0 3
9409: PUSH
9410: LD_VAR 0 4
9414: PLUS
9415: PUSH
9416: LD_VAR 0 11
9420: MINUS
9421: PUSH
9422: EMPTY
9423: LIST
9424: LIST
9425: PPUSH
9426: CALL_OW 2
9430: ST_TO_ADDR
// if 4 in dir_list and 5 in dir_list then
9431: LD_INT 4
9433: PUSH
9434: LD_VAR 0 10
9438: IN
9439: PUSH
9440: LD_INT 5
9442: PUSH
9443: LD_VAR 0 10
9447: IN
9448: AND
9449: IFFALSE 9495
// list_coords = Insert ( list_coords , 1 , [ x - dist , y - b ] ) ;
9451: LD_ADDR_VAR 0 8
9455: PUSH
9456: LD_VAR 0 8
9460: PPUSH
9461: LD_INT 1
9463: PPUSH
9464: LD_VAR 0 2
9468: PUSH
9469: LD_VAR 0 4
9473: MINUS
9474: PUSH
9475: LD_VAR 0 3
9479: PUSH
9480: LD_VAR 0 11
9484: MINUS
9485: PUSH
9486: EMPTY
9487: LIST
9488: LIST
9489: PPUSH
9490: CALL_OW 2
9494: ST_TO_ADDR
// if 5 in dir_list and 0 in dir_list then
9495: LD_INT 5
9497: PUSH
9498: LD_VAR 0 10
9502: IN
9503: PUSH
9504: LD_INT 0
9506: PUSH
9507: LD_VAR 0 10
9511: IN
9512: AND
9513: IFFALSE 9565
// list_coords = Insert ( list_coords , 1 , [ x - dist + b , y - dist ] ) ;
9515: LD_ADDR_VAR 0 8
9519: PUSH
9520: LD_VAR 0 8
9524: PPUSH
9525: LD_INT 1
9527: PPUSH
9528: LD_VAR 0 2
9532: PUSH
9533: LD_VAR 0 4
9537: MINUS
9538: PUSH
9539: LD_VAR 0 11
9543: PLUS
9544: PUSH
9545: LD_VAR 0 3
9549: PUSH
9550: LD_VAR 0 4
9554: MINUS
9555: PUSH
9556: EMPTY
9557: LIST
9558: LIST
9559: PPUSH
9560: CALL_OW 2
9564: ST_TO_ADDR
// b = b + c end ;
9565: LD_ADDR_VAR 0 11
9569: PUSH
9570: LD_VAR 0 11
9574: PUSH
9575: LD_VAR 0 14
9579: PLUS
9580: ST_TO_ADDR
9581: GO 9141
// if list_coords = 0 then
9583: LD_VAR 0 8
9587: PUSH
9588: LD_INT 0
9590: EQUAL
9591: IFFALSE 9595
// exit ;
9593: GO 10103
// repeat min_dist = 5000 ;
9595: LD_ADDR_VAR 0 12
9599: PUSH
9600: LD_INT 5000
9602: ST_TO_ADDR
// for b in list_coords do
9603: LD_ADDR_VAR 0 11
9607: PUSH
9608: LD_VAR 0 8
9612: PUSH
9613: FOR_IN
9614: IFFALSE 9673
// begin temp_dist = GetDistUnitXY ( unit1 , b [ 1 ] , b [ 2 ] ) ;
9616: LD_ADDR_VAR 0 13
9620: PUSH
9621: LD_VAR 0 1
9625: PPUSH
9626: LD_VAR 0 11
9630: PUSH
9631: LD_INT 1
9633: ARRAY
9634: PPUSH
9635: LD_VAR 0 11
9639: PUSH
9640: LD_INT 2
9642: ARRAY
9643: PPUSH
9644: CALL_OW 297
9648: ST_TO_ADDR
// if temp_dist < min_dist then
9649: LD_VAR 0 13
9653: PUSH
9654: LD_VAR 0 12
9658: LESS
9659: IFFALSE 9671
// min_dist = temp_dist ;
9661: LD_ADDR_VAR 0 12
9665: PUSH
9666: LD_VAR 0 13
9670: ST_TO_ADDR
// end ;
9671: GO 9613
9673: POP
9674: POP
// c = 0 ;
9675: LD_ADDR_VAR 0 14
9679: PUSH
9680: LD_INT 0
9682: ST_TO_ADDR
// repeat c = c + 1 ;
9683: LD_ADDR_VAR 0 14
9687: PUSH
9688: LD_VAR 0 14
9692: PUSH
9693: LD_INT 1
9695: PLUS
9696: ST_TO_ADDR
// if GetDistUnitXY ( unit1 , list_coords [ c ] [ 1 ] , list_coords [ c ] [ 2 ] ) = min_dist then
9697: LD_VAR 0 1
9701: PPUSH
9702: LD_VAR 0 8
9706: PUSH
9707: LD_VAR 0 14
9711: ARRAY
9712: PUSH
9713: LD_INT 1
9715: ARRAY
9716: PPUSH
9717: LD_VAR 0 8
9721: PUSH
9722: LD_VAR 0 14
9726: ARRAY
9727: PUSH
9728: LD_INT 2
9730: ARRAY
9731: PPUSH
9732: CALL_OW 297
9736: PUSH
9737: LD_VAR 0 12
9741: EQUAL
9742: IFFALSE 9807
// begin list_nearest = Insert ( list_nearest , 1 , list_coords [ c ] ) ;
9744: LD_ADDR_VAR 0 7
9748: PUSH
9749: LD_VAR 0 7
9753: PPUSH
9754: LD_INT 1
9756: PPUSH
9757: LD_VAR 0 8
9761: PUSH
9762: LD_VAR 0 14
9766: ARRAY
9767: PPUSH
9768: CALL_OW 2
9772: ST_TO_ADDR
// list_coords = Delete ( list_coords , c ) ;
9773: LD_ADDR_VAR 0 8
9777: PUSH
9778: LD_VAR 0 8
9782: PPUSH
9783: LD_VAR 0 14
9787: PPUSH
9788: CALL_OW 3
9792: ST_TO_ADDR
// c = c - 1 ;
9793: LD_ADDR_VAR 0 14
9797: PUSH
9798: LD_VAR 0 14
9802: PUSH
9803: LD_INT 1
9805: MINUS
9806: ST_TO_ADDR
// end ; until c = list_coords ;
9807: LD_VAR 0 14
9811: PUSH
9812: LD_VAR 0 8
9816: EQUAL
9817: IFFALSE 9683
// c = 0 ;
9819: LD_ADDR_VAR 0 14
9823: PUSH
9824: LD_INT 0
9826: ST_TO_ADDR
// if list_nearest > 0 then
9827: LD_VAR 0 7
9831: PUSH
9832: LD_INT 0
9834: GREATER
9835: IFFALSE 9977
// begin repeat rand_num = Rand ( 1 , list_nearest ) ;
9837: LD_ADDR_VAR 0 15
9841: PUSH
9842: LD_INT 1
9844: PPUSH
9845: LD_VAR 0 7
9849: PPUSH
9850: CALL_OW 12
9854: ST_TO_ADDR
// rand_near_hex = list_nearest [ rand_num ] ;
9855: LD_ADDR_VAR 0 16
9859: PUSH
9860: LD_VAR 0 7
9864: PUSH
9865: LD_VAR 0 15
9869: ARRAY
9870: ST_TO_ADDR
// if ValidHex ( rand_near_hex [ 1 ] , rand_near_hex [ 2 ] ) > 0 and HexInfo ( rand_near_hex [ 1 ] , rand_near_hex [ 2 ] ) = 0 then
9871: LD_VAR 0 16
9875: PUSH
9876: LD_INT 1
9878: ARRAY
9879: PPUSH
9880: LD_VAR 0 16
9884: PUSH
9885: LD_INT 2
9887: ARRAY
9888: PPUSH
9889: CALL_OW 488
9893: PUSH
9894: LD_INT 0
9896: GREATER
9897: PUSH
9898: LD_VAR 0 16
9902: PUSH
9903: LD_INT 1
9905: ARRAY
9906: PPUSH
9907: LD_VAR 0 16
9911: PUSH
9912: LD_INT 2
9914: ARRAY
9915: PPUSH
9916: CALL_OW 428
9920: PUSH
9921: LD_INT 0
9923: EQUAL
9924: AND
9925: IFFALSE 9937
// c = 1 else
9927: LD_ADDR_VAR 0 14
9931: PUSH
9932: LD_INT 1
9934: ST_TO_ADDR
9935: GO 9957
// list_nearest = Delete ( list_nearest , rand_num ) ;
9937: LD_ADDR_VAR 0 7
9941: PUSH
9942: LD_VAR 0 7
9946: PPUSH
9947: LD_VAR 0 15
9951: PPUSH
9952: CALL_OW 3
9956: ST_TO_ADDR
// until c = 1 or list_nearest = 0 ;
9957: LD_VAR 0 14
9961: PUSH
9962: LD_INT 1
9964: EQUAL
9965: PUSH
9966: LD_VAR 0 7
9970: PUSH
9971: LD_INT 0
9973: EQUAL
9974: OR
9975: IFFALSE 9837
// end ; until c = 1 or list_coords = 0 ;
9977: LD_VAR 0 14
9981: PUSH
9982: LD_INT 1
9984: EQUAL
9985: PUSH
9986: LD_VAR 0 8
9990: PUSH
9991: LD_INT 0
9993: EQUAL
9994: OR
9995: IFFALSE 9595
// attempts = attempts + 1 ;
9997: LD_ADDR_VAR 0 17
10001: PUSH
10002: LD_VAR 0 17
10006: PUSH
10007: LD_INT 1
10009: PLUS
10010: ST_TO_ADDR
// until c = 1 or attempts > 1 ;
10011: LD_VAR 0 14
10015: PUSH
10016: LD_INT 1
10018: EQUAL
10019: PUSH
10020: LD_VAR 0 17
10024: PUSH
10025: LD_INT 1
10027: GREATER
10028: OR
10029: IFFALSE 8554
// if c = 1 then
10031: LD_VAR 0 14
10035: PUSH
10036: LD_INT 1
10038: EQUAL
10039: IFFALSE 10103
// if add then
10041: LD_VAR 0 5
10045: IFFALSE 10076
// AddComMoveXY ( unit1 , rand_near_hex [ 1 ] , rand_near_hex [ 2 ] ) else
10047: LD_VAR 0 1
10051: PPUSH
10052: LD_VAR 0 16
10056: PUSH
10057: LD_INT 1
10059: ARRAY
10060: PPUSH
10061: LD_VAR 0 16
10065: PUSH
10066: LD_INT 2
10068: ARRAY
10069: PPUSH
10070: CALL_OW 171
10074: GO 10103
// ComMoveXY ( unit1 , rand_near_hex [ 1 ] , rand_near_hex [ 2 ] ) ;
10076: LD_VAR 0 1
10080: PPUSH
10081: LD_VAR 0 16
10085: PUSH
10086: LD_INT 1
10088: ARRAY
10089: PPUSH
10090: LD_VAR 0 16
10094: PUSH
10095: LD_INT 2
10097: ARRAY
10098: PPUSH
10099: CALL_OW 111
// end ;
10103: LD_VAR 0 6
10107: RET
// export function GetTurnDirection ( x1 , y1 , x , y ) ; var dist_1 , dist_2 , b , temp_dist , dir ; begin
10108: LD_INT 0
10110: PPUSH
10111: PPUSH
10112: PPUSH
10113: PPUSH
10114: PPUSH
10115: PPUSH
// if not ValidHex ( x1 , y1 ) or not ValidHex ( x , y ) then
10116: LD_VAR 0 1
10120: PPUSH
10121: LD_VAR 0 2
10125: PPUSH
10126: CALL_OW 488
10130: NOT
10131: PUSH
10132: LD_VAR 0 3
10136: PPUSH
10137: LD_VAR 0 4
10141: PPUSH
10142: CALL_OW 488
10146: NOT
10147: OR
10148: IFFALSE 10161
// begin result = - 1 ;
10150: LD_ADDR_VAR 0 5
10154: PUSH
10155: LD_INT 1
10157: NEG
10158: ST_TO_ADDR
// exit ;
10159: GO 10321
// end ; dist_1 = GetDistXY ( x1 , y1 , x , y ) ;
10161: LD_ADDR_VAR 0 6
10165: PUSH
10166: LD_VAR 0 1
10170: PPUSH
10171: LD_VAR 0 2
10175: PPUSH
10176: LD_VAR 0 3
10180: PPUSH
10181: LD_VAR 0 4
10185: PPUSH
10186: CALL_OW 298
10190: ST_TO_ADDR
// dist_2 = 99999 ;
10191: LD_ADDR_VAR 0 7
10195: PUSH
10196: LD_INT 99999
10198: ST_TO_ADDR
// for b = 0 to 5 do
10199: LD_ADDR_VAR 0 8
10203: PUSH
10204: DOUBLE
10205: LD_INT 0
10207: DEC
10208: ST_TO_ADDR
10209: LD_INT 5
10211: PUSH
10212: FOR_TO
10213: IFFALSE 10309
// begin temp_dist = GetDistXY ( ShiftX ( x1 , b , dist_1 ) , ShiftY ( y1 , b , dist_1 ) , x , y ) ;
10215: LD_ADDR_VAR 0 9
10219: PUSH
10220: LD_VAR 0 1
10224: PPUSH
10225: LD_VAR 0 8
10229: PPUSH
10230: LD_VAR 0 6
10234: PPUSH
10235: CALL_OW 272
10239: PPUSH
10240: LD_VAR 0 2
10244: PPUSH
10245: LD_VAR 0 8
10249: PPUSH
10250: LD_VAR 0 6
10254: PPUSH
10255: CALL_OW 273
10259: PPUSH
10260: LD_VAR 0 3
10264: PPUSH
10265: LD_VAR 0 4
10269: PPUSH
10270: CALL_OW 298
10274: ST_TO_ADDR
// if temp_dist < dist_2 then
10275: LD_VAR 0 9
10279: PUSH
10280: LD_VAR 0 7
10284: LESS
10285: IFFALSE 10307
// begin dist_2 = temp_dist ;
10287: LD_ADDR_VAR 0 7
10291: PUSH
10292: LD_VAR 0 9
10296: ST_TO_ADDR
// dir = b ;
10297: LD_ADDR_VAR 0 10
10301: PUSH
10302: LD_VAR 0 8
10306: ST_TO_ADDR
// end ; end ;
10307: GO 10212
10309: POP
10310: POP
// result = dir ;
10311: LD_ADDR_VAR 0 5
10315: PUSH
10316: LD_VAR 0 10
10320: ST_TO_ADDR
// end ;
10321: LD_VAR 0 5
10325: RET
// export function MoveToHill ; begin
10326: LD_INT 0
10328: PPUSH
// ComMoveXY ( Pokryshkin , 65 , 59 ) ;
10329: LD_EXP 47
10333: PPUSH
10334: LD_INT 65
10336: PPUSH
10337: LD_INT 59
10339: PPUSH
10340: CALL_OW 111
// AddComCrawl ( Pokryshkin ) ;
10344: LD_EXP 47
10348: PPUSH
10349: CALL_OW 197
// ComMoveXY ( Saseda , 65 , 58 ) ;
10353: LD_EXP 48
10357: PPUSH
10358: LD_INT 65
10360: PPUSH
10361: LD_INT 58
10363: PPUSH
10364: CALL_OW 111
// AddComCrawl ( Saseda ) ;
10368: LD_EXP 48
10372: PPUSH
10373: CALL_OW 197
// ComMoveXY ( Jaworska , 64 , 57 ) ;
10377: LD_EXP 49
10381: PPUSH
10382: LD_INT 64
10384: PPUSH
10385: LD_INT 57
10387: PPUSH
10388: CALL_OW 111
// AddComCrawl ( Jaworska ) ;
10392: LD_EXP 49
10396: PPUSH
10397: CALL_OW 197
// ComMoveXY ( Balei , 64 , 56 ) ;
10401: LD_EXP 50
10405: PPUSH
10406: LD_INT 64
10408: PPUSH
10409: LD_INT 56
10411: PPUSH
10412: CALL_OW 111
// AddComCrawl ( Balei ) ;
10416: LD_EXP 50
10420: PPUSH
10421: CALL_OW 197
// ComMoveXY ( Belkov , 63 , 55 ) ;
10425: LD_EXP 51
10429: PPUSH
10430: LD_INT 63
10432: PPUSH
10433: LD_INT 55
10435: PPUSH
10436: CALL_OW 111
// AddComCrawl ( Belkov ) ;
10440: LD_EXP 51
10444: PPUSH
10445: CALL_OW 197
// ComMoveXY ( Jaunzeme , 66 , 58 ) ;
10449: LD_EXP 52
10453: PPUSH
10454: LD_INT 66
10456: PPUSH
10457: LD_INT 58
10459: PPUSH
10460: CALL_OW 111
// AddComCrawl ( Jaunzeme ) ;
10464: LD_EXP 52
10468: PPUSH
10469: CALL_OW 197
// if ( GetSide ( Gnyevko ) = 6 and gnyevkoSaved ) then
10473: LD_EXP 54
10477: PPUSH
10478: CALL_OW 255
10482: PUSH
10483: LD_INT 6
10485: EQUAL
10486: PUSH
10487: LD_EXP 12
10491: AND
10492: IFFALSE 10518
// begin ComMoveXY ( Gnyevko , 63 , 54 ) ;
10494: LD_EXP 54
10498: PPUSH
10499: LD_INT 63
10501: PPUSH
10502: LD_INT 54
10504: PPUSH
10505: CALL_OW 111
// AddComCrawl ( Gnyevko ) ;
10509: LD_EXP 54
10513: PPUSH
10514: CALL_OW 197
// end ; repeat if GetDistUnitXY ( Pokryshkin , 65 , 59 ) < 7 then
10518: LD_EXP 47
10522: PPUSH
10523: LD_INT 65
10525: PPUSH
10526: LD_INT 59
10528: PPUSH
10529: CALL_OW 297
10533: PUSH
10534: LD_INT 7
10536: LESS
10537: IFFALSE 10563
// begin ComCrawl ( Pokryshkin ) ;
10539: LD_EXP 47
10543: PPUSH
10544: CALL_OW 137
// AddComMoveXY ( Pokryshkin , 65 , 59 ) ;
10548: LD_EXP 47
10552: PPUSH
10553: LD_INT 65
10555: PPUSH
10556: LD_INT 59
10558: PPUSH
10559: CALL_OW 171
// end ; if GetDistUnitXY ( Saseda , 65 , 58 ) < 7 then
10563: LD_EXP 48
10567: PPUSH
10568: LD_INT 65
10570: PPUSH
10571: LD_INT 58
10573: PPUSH
10574: CALL_OW 297
10578: PUSH
10579: LD_INT 7
10581: LESS
10582: IFFALSE 10608
// begin ComCrawl ( Saseda ) ;
10584: LD_EXP 48
10588: PPUSH
10589: CALL_OW 137
// AddComMoveXY ( Saseda , 65 , 58 ) ;
10593: LD_EXP 48
10597: PPUSH
10598: LD_INT 65
10600: PPUSH
10601: LD_INT 58
10603: PPUSH
10604: CALL_OW 171
// end ; if GetDistUnitXY ( Jaworska , 64 , 57 ) < 7 then
10608: LD_EXP 49
10612: PPUSH
10613: LD_INT 64
10615: PPUSH
10616: LD_INT 57
10618: PPUSH
10619: CALL_OW 297
10623: PUSH
10624: LD_INT 7
10626: LESS
10627: IFFALSE 10653
// begin ComCrawl ( Jaworska ) ;
10629: LD_EXP 49
10633: PPUSH
10634: CALL_OW 137
// AddComMoveXY ( Jaworska , 64 , 57 ) ;
10638: LD_EXP 49
10642: PPUSH
10643: LD_INT 64
10645: PPUSH
10646: LD_INT 57
10648: PPUSH
10649: CALL_OW 171
// end ; if GetDistUnitXY ( Balei , 64 , 56 ) < 7 then
10653: LD_EXP 50
10657: PPUSH
10658: LD_INT 64
10660: PPUSH
10661: LD_INT 56
10663: PPUSH
10664: CALL_OW 297
10668: PUSH
10669: LD_INT 7
10671: LESS
10672: IFFALSE 10698
// begin ComCrawl ( Balei ) ;
10674: LD_EXP 50
10678: PPUSH
10679: CALL_OW 137
// AddComMoveXY ( Balei , 64 , 56 ) ;
10683: LD_EXP 50
10687: PPUSH
10688: LD_INT 64
10690: PPUSH
10691: LD_INT 56
10693: PPUSH
10694: CALL_OW 171
// end ; if GetDistUnitXY ( Belkov , 63 , 55 ) < 7 then
10698: LD_EXP 51
10702: PPUSH
10703: LD_INT 63
10705: PPUSH
10706: LD_INT 55
10708: PPUSH
10709: CALL_OW 297
10713: PUSH
10714: LD_INT 7
10716: LESS
10717: IFFALSE 10743
// begin ComCrawl ( Belkov ) ;
10719: LD_EXP 51
10723: PPUSH
10724: CALL_OW 137
// AddComMoveXY ( Belkov , 63 , 55 ) ;
10728: LD_EXP 51
10732: PPUSH
10733: LD_INT 63
10735: PPUSH
10736: LD_INT 55
10738: PPUSH
10739: CALL_OW 171
// end ; if GetDistUnitXY ( Jaunzeme , 66 , 58 ) < 7 then
10743: LD_EXP 52
10747: PPUSH
10748: LD_INT 66
10750: PPUSH
10751: LD_INT 58
10753: PPUSH
10754: CALL_OW 297
10758: PUSH
10759: LD_INT 7
10761: LESS
10762: IFFALSE 10788
// begin ComCrawl ( Jaunzeme ) ;
10764: LD_EXP 52
10768: PPUSH
10769: CALL_OW 137
// AddComMoveXY ( Jaunzeme , 66 , 58 ) ;
10773: LD_EXP 52
10777: PPUSH
10778: LD_INT 66
10780: PPUSH
10781: LD_INT 58
10783: PPUSH
10784: CALL_OW 171
// end ; if GetDistUnitXY ( Gnyevko , 63 , 54 ) < 7 and GetSide ( Gnyevko ) = 6 and gnyevkoSaved then
10788: LD_EXP 54
10792: PPUSH
10793: LD_INT 63
10795: PPUSH
10796: LD_INT 54
10798: PPUSH
10799: CALL_OW 297
10803: PUSH
10804: LD_INT 7
10806: LESS
10807: PUSH
10808: LD_EXP 54
10812: PPUSH
10813: CALL_OW 255
10817: PUSH
10818: LD_INT 6
10820: EQUAL
10821: AND
10822: PUSH
10823: LD_EXP 12
10827: AND
10828: IFFALSE 10854
// begin ComCrawl ( Gnyevko ) ;
10830: LD_EXP 54
10834: PPUSH
10835: CALL_OW 137
// AddComMoveXY ( Gnyevko , 63 , 54 ) ;
10839: LD_EXP 54
10843: PPUSH
10844: LD_INT 63
10846: PPUSH
10847: LD_INT 54
10849: PPUSH
10850: CALL_OW 171
// end ; wait ( 0 0$1 ) ;
10854: LD_INT 35
10856: PPUSH
10857: CALL_OW 67
// until IsDying ( Charles ) or IsDead ( Charles ) ;
10861: LD_EXP 42
10865: PPUSH
10866: CALL_OW 303
10870: PUSH
10871: LD_EXP 42
10875: PPUSH
10876: CALL_OW 301
10880: OR
10881: IFFALSE 10518
// end ;
10883: LD_VAR 0 1
10887: RET
// every 0 0$1 trigger ( not IsDying ( Charles ) or not IsDead ( Charles ) ) and goToHill do
10888: LD_EXP 42
10892: PPUSH
10893: CALL_OW 303
10897: NOT
10898: PUSH
10899: LD_EXP 42
10903: PPUSH
10904: CALL_OW 301
10908: NOT
10909: OR
10910: PUSH
10911: LD_EXP 15
10915: AND
10916: IFFALSE 11258
10918: GO 10920
10920: DISABLE
// begin enable ;
10921: ENABLE
// if GetDistUnitXY ( Pokryshkin , 65 , 59 ) < 7 then
10922: LD_EXP 47
10926: PPUSH
10927: LD_INT 65
10929: PPUSH
10930: LD_INT 59
10932: PPUSH
10933: CALL_OW 297
10937: PUSH
10938: LD_INT 7
10940: LESS
10941: IFFALSE 10967
// begin ComCrawl ( Pokryshkin ) ;
10943: LD_EXP 47
10947: PPUSH
10948: CALL_OW 137
// AddComMoveXY ( Pokryshkin , 65 , 59 ) ;
10952: LD_EXP 47
10956: PPUSH
10957: LD_INT 65
10959: PPUSH
10960: LD_INT 59
10962: PPUSH
10963: CALL_OW 171
// end ; if GetDistUnitXY ( Saseda , 65 , 58 ) < 7 then
10967: LD_EXP 48
10971: PPUSH
10972: LD_INT 65
10974: PPUSH
10975: LD_INT 58
10977: PPUSH
10978: CALL_OW 297
10982: PUSH
10983: LD_INT 7
10985: LESS
10986: IFFALSE 11012
// begin ComCrawl ( Saseda ) ;
10988: LD_EXP 48
10992: PPUSH
10993: CALL_OW 137
// AddComMoveXY ( Saseda , 65 , 58 ) ;
10997: LD_EXP 48
11001: PPUSH
11002: LD_INT 65
11004: PPUSH
11005: LD_INT 58
11007: PPUSH
11008: CALL_OW 171
// end ; if GetDistUnitXY ( Jaworska , 64 , 57 ) < 7 then
11012: LD_EXP 49
11016: PPUSH
11017: LD_INT 64
11019: PPUSH
11020: LD_INT 57
11022: PPUSH
11023: CALL_OW 297
11027: PUSH
11028: LD_INT 7
11030: LESS
11031: IFFALSE 11057
// begin ComCrawl ( Jaworska ) ;
11033: LD_EXP 49
11037: PPUSH
11038: CALL_OW 137
// AddComMoveXY ( Jaworska , 64 , 57 ) ;
11042: LD_EXP 49
11046: PPUSH
11047: LD_INT 64
11049: PPUSH
11050: LD_INT 57
11052: PPUSH
11053: CALL_OW 171
// end ; if GetDistUnitXY ( Balei , 64 , 56 ) < 7 then
11057: LD_EXP 50
11061: PPUSH
11062: LD_INT 64
11064: PPUSH
11065: LD_INT 56
11067: PPUSH
11068: CALL_OW 297
11072: PUSH
11073: LD_INT 7
11075: LESS
11076: IFFALSE 11102
// begin ComCrawl ( Balei ) ;
11078: LD_EXP 50
11082: PPUSH
11083: CALL_OW 137
// AddComMoveXY ( Balei , 64 , 56 ) ;
11087: LD_EXP 50
11091: PPUSH
11092: LD_INT 64
11094: PPUSH
11095: LD_INT 56
11097: PPUSH
11098: CALL_OW 171
// end ; if GetDistUnitXY ( Belkov , 63 , 55 ) < 7 then
11102: LD_EXP 51
11106: PPUSH
11107: LD_INT 63
11109: PPUSH
11110: LD_INT 55
11112: PPUSH
11113: CALL_OW 297
11117: PUSH
11118: LD_INT 7
11120: LESS
11121: IFFALSE 11147
// begin ComCrawl ( Belkov ) ;
11123: LD_EXP 51
11127: PPUSH
11128: CALL_OW 137
// AddComMoveXY ( Belkov , 63 , 55 ) ;
11132: LD_EXP 51
11136: PPUSH
11137: LD_INT 63
11139: PPUSH
11140: LD_INT 55
11142: PPUSH
11143: CALL_OW 171
// end ; if GetDistUnitXY ( Jaunzeme , 66 , 58 ) < 7 then
11147: LD_EXP 52
11151: PPUSH
11152: LD_INT 66
11154: PPUSH
11155: LD_INT 58
11157: PPUSH
11158: CALL_OW 297
11162: PUSH
11163: LD_INT 7
11165: LESS
11166: IFFALSE 11192
// begin ComCrawl ( Jaunzeme ) ;
11168: LD_EXP 52
11172: PPUSH
11173: CALL_OW 137
// AddComMoveXY ( Jaunzeme , 66 , 58 ) ;
11177: LD_EXP 52
11181: PPUSH
11182: LD_INT 66
11184: PPUSH
11185: LD_INT 58
11187: PPUSH
11188: CALL_OW 171
// end ; if GetDistUnitXY ( Gnyevko , 63 , 54 ) < 7 and GetSide ( Gnyevko ) = 6 and gnyevkoSaved then
11192: LD_EXP 54
11196: PPUSH
11197: LD_INT 63
11199: PPUSH
11200: LD_INT 54
11202: PPUSH
11203: CALL_OW 297
11207: PUSH
11208: LD_INT 7
11210: LESS
11211: PUSH
11212: LD_EXP 54
11216: PPUSH
11217: CALL_OW 255
11221: PUSH
11222: LD_INT 6
11224: EQUAL
11225: AND
11226: PUSH
11227: LD_EXP 12
11231: AND
11232: IFFALSE 11258
// begin ComCrawl ( Gnyevko ) ;
11234: LD_EXP 54
11238: PPUSH
11239: CALL_OW 137
// AddComMoveXY ( Gnyevko , 63 , 54 ) ;
11243: LD_EXP 54
11247: PPUSH
11248: LD_INT 63
11250: PPUSH
11251: LD_INT 54
11253: PPUSH
11254: CALL_OW 171
// end ; end ; end_of_file
11258: END
// export function BurlakDying ; begin
11259: LD_INT 0
11261: PPUSH
// YouLost ( Burlak ) ;
11262: LD_STRING Burlak
11264: PPUSH
11265: CALL_OW 104
// end ;
11269: LD_VAR 0 1
11273: RET
// every 0 0$1 trigger kirovSolds = 0 do
11274: LD_EXP 56
11278: PUSH
11279: LD_INT 0
11281: EQUAL
11282: IFFALSE 11294
11284: GO 11286
11286: DISABLE
// YouLost ( KirovSoldsDie ) ; end_of_file
11287: LD_STRING KirovSoldsDie
11289: PPUSH
11290: CALL_OW 104
11294: END
// every 0 0$1 trigger evacuationAvailable and FilterUnitsExceptArea ( ExitArea , [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) = 0 do var dec ;
11295: LD_EXP 22
11299: PUSH
11300: LD_INT 1
11302: PPUSH
11303: LD_INT 22
11305: PUSH
11306: LD_INT 3
11308: PUSH
11309: EMPTY
11310: LIST
11311: LIST
11312: PUSH
11313: LD_INT 21
11315: PUSH
11316: LD_INT 1
11318: PUSH
11319: EMPTY
11320: LIST
11321: LIST
11322: PUSH
11323: EMPTY
11324: LIST
11325: LIST
11326: PPUSH
11327: CALL_OW 71
11331: PUSH
11332: LD_INT 0
11334: EQUAL
11335: AND
11336: IFFALSE 11615
11338: GO 11340
11340: DISABLE
11341: LD_INT 0
11343: PPUSH
// begin if ( IsOK ( Kirilenkova ) and GetSide ( Kirilenkova ) = 8 ) or ( IsOK ( Gnyevko ) and GetSide ( Gnyevko ) = 8 ) then
11344: LD_EXP 53
11348: PPUSH
11349: CALL_OW 302
11353: PUSH
11354: LD_EXP 53
11358: PPUSH
11359: CALL_OW 255
11363: PUSH
11364: LD_INT 8
11366: EQUAL
11367: AND
11368: PUSH
11369: LD_EXP 54
11373: PPUSH
11374: CALL_OW 302
11378: PUSH
11379: LD_EXP 54
11383: PPUSH
11384: CALL_OW 255
11388: PUSH
11389: LD_INT 8
11391: EQUAL
11392: AND
11393: OR
11394: IFFALSE 11526
// begin case Query ( QExit2 ) of 1 :
11396: LD_STRING QExit2
11398: PPUSH
11399: CALL_OW 97
11403: PUSH
11404: LD_INT 1
11406: DOUBLE
11407: EQUAL
11408: IFTRUE 11412
11410: GO 11504
11412: POP
// begin if IsOk ( Belkov ) then
11413: LD_EXP 51
11417: PPUSH
11418: CALL_OW 302
11422: IFFALSE 11438
// Say ( Belkov , D12-Bel-1 ) else
11424: LD_EXP 51
11428: PPUSH
11429: LD_STRING D12-Bel-1
11431: PPUSH
11432: CALL_OW 88
11436: GO 11498
// DialogRandom ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_ok ] , [ f_sex , sex_male ] ] ) , D12-RSol1-1 ,  , false ) ;
11438: LD_INT 22
11440: PUSH
11441: LD_INT 3
11443: PUSH
11444: EMPTY
11445: LIST
11446: LIST
11447: PUSH
11448: LD_INT 21
11450: PUSH
11451: LD_INT 1
11453: PUSH
11454: EMPTY
11455: LIST
11456: LIST
11457: PUSH
11458: LD_INT 50
11460: PUSH
11461: EMPTY
11462: LIST
11463: PUSH
11464: LD_INT 26
11466: PUSH
11467: LD_INT 1
11469: PUSH
11470: EMPTY
11471: LIST
11472: LIST
11473: PUSH
11474: EMPTY
11475: LIST
11476: LIST
11477: LIST
11478: LIST
11479: PPUSH
11480: CALL_OW 69
11484: PPUSH
11485: LD_STRING D12-RSol1-1
11487: PPUSH
11488: LD_STRING 
11490: PPUSH
11491: LD_INT 0
11493: PPUSH
11494: CALL 8113 0 4
// FinishMission ;
11498: CALL 11618 0 0
// end ; 2 :
11502: GO 11524
11504: LD_INT 2
11506: DOUBLE
11507: EQUAL
11508: IFTRUE 11512
11510: GO 11523
11512: POP
// begin wait ( 0 0$5 ) ;
11513: LD_INT 175
11515: PPUSH
11516: CALL_OW 67
// enable ;
11520: ENABLE
// end ; end ;
11521: GO 11524
11523: POP
// end else
11524: GO 11615
// begin if IsOk ( Belkov ) then
11526: LD_EXP 51
11530: PPUSH
11531: CALL_OW 302
11535: IFFALSE 11551
// Say ( Belkov , D12-Bel-1 ) else
11537: LD_EXP 51
11541: PPUSH
11542: LD_STRING D12-Bel-1
11544: PPUSH
11545: CALL_OW 88
11549: GO 11611
// DialogRandom ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_ok ] , [ f_sex , sex_male ] ] ) , D12-RSol1-1 ,  , false ) ;
11551: LD_INT 22
11553: PUSH
11554: LD_INT 3
11556: PUSH
11557: EMPTY
11558: LIST
11559: LIST
11560: PUSH
11561: LD_INT 21
11563: PUSH
11564: LD_INT 1
11566: PUSH
11567: EMPTY
11568: LIST
11569: LIST
11570: PUSH
11571: LD_INT 50
11573: PUSH
11574: EMPTY
11575: LIST
11576: PUSH
11577: LD_INT 26
11579: PUSH
11580: LD_INT 1
11582: PUSH
11583: EMPTY
11584: LIST
11585: LIST
11586: PUSH
11587: EMPTY
11588: LIST
11589: LIST
11590: LIST
11591: LIST
11592: PPUSH
11593: CALL_OW 69
11597: PPUSH
11598: LD_STRING D12-RSol1-1
11600: PPUSH
11601: LD_STRING 
11603: PPUSH
11604: LD_INT 0
11606: PPUSH
11607: CALL 8113 0 4
// FinishMission ;
11611: CALL 11618 0 0
// end ; end ;
11615: PPOPN 1
11617: END
// function FinishMission ; begin
11618: LD_INT 0
11620: PPUSH
// SetRewards ;
11621: CALL 11642 0 0
// SavePlayerCharacters ;
11625: CALL 11993 0 0
// SaveGlobalVariables ;
11629: CALL 12123 0 0
// YouWin ;
11633: CALL_OW 103
// end ;
11637: LD_VAR 0 1
11641: RET
// function SetRewards ; begin
11642: LD_INT 0
11644: PPUSH
// if not gladstoneEscape and not JohannaEscape then
11645: LD_EXP 19
11649: NOT
11650: PUSH
11651: LD_EXP 20
11655: NOT
11656: AND
11657: IFFALSE 11669
// AddMedal ( NoEscape , 1 ) ;
11659: LD_STRING NoEscape
11661: PPUSH
11662: LD_INT 1
11664: PPUSH
11665: CALL_OW 101
// if gladstoneEscape and not JohannaEscape then
11669: LD_EXP 19
11673: PUSH
11674: LD_EXP 20
11678: NOT
11679: AND
11680: IFFALSE 11693
// AddMedal ( NoEscape , - 1 ) ;
11682: LD_STRING NoEscape
11684: PPUSH
11685: LD_INT 1
11687: NEG
11688: PPUSH
11689: CALL_OW 101
// if not gladstoneEscape and JohannaEscape then
11693: LD_EXP 19
11697: NOT
11698: PUSH
11699: LD_EXP 20
11703: AND
11704: IFFALSE 11717
// AddMedal ( NoEscape , - 2 ) ;
11706: LD_STRING NoEscape
11708: PPUSH
11709: LD_INT 2
11711: NEG
11712: PPUSH
11713: CALL_OW 101
// if gladstoneEscape and JohannaEscape then
11717: LD_EXP 19
11721: PUSH
11722: LD_EXP 20
11726: AND
11727: IFFALSE 11740
// AddMedal ( NoEscape , - 3 ) ;
11729: LD_STRING NoEscape
11731: PPUSH
11732: LD_INT 3
11734: NEG
11735: PPUSH
11736: CALL_OW 101
// if gnyevkoSaved and IsOK ( Gnyevko ) and jelenaSaved and IsOK ( Kirilenkova ) then
11740: LD_EXP 12
11744: PUSH
11745: LD_EXP 54
11749: PPUSH
11750: CALL_OW 302
11754: AND
11755: PUSH
11756: LD_EXP 21
11760: AND
11761: PUSH
11762: LD_EXP 53
11766: PPUSH
11767: CALL_OW 302
11771: AND
11772: IFFALSE 11784
// AddMedal ( Gnyevko , 1 ) ;
11774: LD_STRING Gnyevko
11776: PPUSH
11777: LD_INT 1
11779: PPUSH
11780: CALL_OW 101
// if not gnyevkoSaved and jelenaSaved and IsOK ( Kirilenkova ) then
11784: LD_EXP 12
11788: NOT
11789: PUSH
11790: LD_EXP 21
11794: AND
11795: PUSH
11796: LD_EXP 53
11800: PPUSH
11801: CALL_OW 302
11805: AND
11806: IFFALSE 11819
// AddMedal ( Gnyevko , - 1 ) ;
11808: LD_STRING Gnyevko
11810: PPUSH
11811: LD_INT 1
11813: NEG
11814: PPUSH
11815: CALL_OW 101
// if gnyevkoSaved and ( not jelenaSaved or not IsOK ( Gnyevko ) or not IsOK ( Kirilenkova ) ) then
11819: LD_EXP 12
11823: PUSH
11824: LD_EXP 21
11828: NOT
11829: PUSH
11830: LD_EXP 54
11834: PPUSH
11835: CALL_OW 302
11839: NOT
11840: OR
11841: PUSH
11842: LD_EXP 53
11846: PPUSH
11847: CALL_OW 302
11851: NOT
11852: OR
11853: AND
11854: IFFALSE 11867
// AddMedal ( Gnyevko , - 2 ) ;
11856: LD_STRING Gnyevko
11858: PPUSH
11859: LD_INT 2
11861: NEG
11862: PPUSH
11863: CALL_OW 101
// if ( not gnyevkoSaved and not jelenaSaved ) or ( not IsOK ( Gnyevko ) and not IsOK ( Kirilenkova ) ) then
11867: LD_EXP 12
11871: NOT
11872: PUSH
11873: LD_EXP 21
11877: NOT
11878: AND
11879: PUSH
11880: LD_EXP 54
11884: PPUSH
11885: CALL_OW 302
11889: NOT
11890: PUSH
11891: LD_EXP 53
11895: PPUSH
11896: CALL_OW 302
11900: NOT
11901: AND
11902: OR
11903: IFFALSE 11916
// AddMedal ( Gnyevko , - 3 ) ;
11905: LD_STRING Gnyevko
11907: PPUSH
11908: LD_INT 3
11910: NEG
11911: PPUSH
11912: CALL_OW 101
// if lostComradesCounter = 0 then
11916: LD_EXP 23
11920: PUSH
11921: LD_INT 0
11923: EQUAL
11924: IFFALSE 11938
// AddMedal ( NoLosses , 1 ) else
11926: LD_STRING NoLosses
11928: PPUSH
11929: LD_INT 1
11931: PPUSH
11932: CALL_OW 101
11936: GO 11948
// AddMedal ( NoLosses , 0 ) ;
11938: LD_STRING NoLosses
11940: PPUSH
11941: LD_INT 0
11943: PPUSH
11944: CALL_OW 101
// GiveMedals ( Main ) ;
11948: LD_STRING Main
11950: PPUSH
11951: CALL_OW 102
// RewardPeople ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) ) ;
11955: LD_INT 22
11957: PUSH
11958: LD_INT 3
11960: PUSH
11961: EMPTY
11962: LIST
11963: LIST
11964: PUSH
11965: LD_INT 21
11967: PUSH
11968: LD_INT 1
11970: PUSH
11971: EMPTY
11972: LIST
11973: LIST
11974: PUSH
11975: EMPTY
11976: LIST
11977: LIST
11978: PPUSH
11979: CALL_OW 69
11983: PPUSH
11984: CALL_OW 43
// end ;
11988: LD_VAR 0 1
11992: RET
// function SavePlayerCharacters ; var others ; begin
11993: LD_INT 0
11995: PPUSH
11996: PPUSH
// ExtSaveCharacter ( Burlak , Burlak ) ;
11997: LD_EXP 46
12001: PPUSH
12002: LD_STRING Burlak
12004: PPUSH
12005: CALL 8292 0 2
// ExtSaveCharacter ( Gnyevko , Gnyevko ) ;
12009: LD_EXP 54
12013: PPUSH
12014: LD_STRING Gnyevko
12016: PPUSH
12017: CALL 8292 0 2
// ExtSaveCharacter ( Belkov , Belkov ) ;
12021: LD_EXP 51
12025: PPUSH
12026: LD_STRING Belkov
12028: PPUSH
12029: CALL 8292 0 2
// ExtSaveCharacter ( Kirilenkova , Kirilenkova ) ;
12033: LD_EXP 53
12037: PPUSH
12038: LD_STRING Kirilenkova
12040: PPUSH
12041: CALL 8292 0 2
// others = FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) diff [ Burlak , Gnyevko , Belkov , Kirilenkova ] ;
12045: LD_ADDR_VAR 0 2
12049: PUSH
12050: LD_INT 22
12052: PUSH
12053: LD_INT 3
12055: PUSH
12056: EMPTY
12057: LIST
12058: LIST
12059: PUSH
12060: LD_INT 21
12062: PUSH
12063: LD_INT 1
12065: PUSH
12066: EMPTY
12067: LIST
12068: LIST
12069: PUSH
12070: EMPTY
12071: LIST
12072: LIST
12073: PPUSH
12074: CALL_OW 69
12078: PUSH
12079: LD_EXP 46
12083: PUSH
12084: LD_EXP 54
12088: PUSH
12089: LD_EXP 51
12093: PUSH
12094: LD_EXP 53
12098: PUSH
12099: EMPTY
12100: LIST
12101: LIST
12102: LIST
12103: LIST
12104: DIFF
12105: ST_TO_ADDR
// ExtSaveCharacters ( others , other_survivors ) ;
12106: LD_VAR 0 2
12110: PPUSH
12111: LD_STRING other_survivors
12113: PPUSH
12114: CALL 8348 0 2
// end ;
12118: LD_VAR 0 1
12122: RET
// function SaveGlobalVariables ; begin
12123: LD_INT 0
12125: PPUSH
// SaveVariable ( gladstoneStatus , 01_GladstoneStatus ) ;
12126: LD_EXP 1
12130: PPUSH
12131: LD_STRING 01_GladstoneStatus
12133: PPUSH
12134: CALL_OW 39
// SaveVariable ( johannaStatus , 01_JohannaStatus ) ;
12138: LD_EXP 2
12142: PPUSH
12143: LD_STRING 01_JohannaStatus
12145: PPUSH
12146: CALL_OW 39
// end ; end_of_file
12150: LD_VAR 0 1
12154: RET
// export Charles , Johanna , Gladstone ; export amApemans ; export function PrepareAmericans ; var i , ape ; begin
12155: LD_INT 0
12157: PPUSH
12158: PPUSH
12159: PPUSH
// uc_side = 1 ;
12160: LD_ADDR_OWVAR 20
12164: PUSH
12165: LD_INT 1
12167: ST_TO_ADDR
// hc_class := 1 ;
12168: LD_ADDR_OWVAR 28
12172: PUSH
12173: LD_INT 1
12175: ST_TO_ADDR
// hc_sex := sex_male ;
12176: LD_ADDR_OWVAR 27
12180: PUSH
12181: LD_INT 1
12183: ST_TO_ADDR
// hc_gallery := AmGalRemake ;
12184: LD_ADDR_OWVAR 33
12188: PUSH
12189: LD_STRING AmGalRemake
12191: ST_TO_ADDR
// hc_face_number := 1 ;
12192: LD_ADDR_OWVAR 34
12196: PUSH
12197: LD_INT 1
12199: ST_TO_ADDR
// hc_name := Charles Brown ;
12200: LD_ADDR_OWVAR 26
12204: PUSH
12205: LD_STRING Charles Brown
12207: ST_TO_ADDR
// hc_attr := [ 12 , 11 ] ;
12208: LD_ADDR_OWVAR 29
12212: PUSH
12213: LD_INT 12
12215: PUSH
12216: LD_INT 11
12218: PUSH
12219: EMPTY
12220: LIST
12221: LIST
12222: ST_TO_ADDR
// hc_skills := [ 1 , 0 , 1 , 1 ] ;
12223: LD_ADDR_OWVAR 31
12227: PUSH
12228: LD_INT 1
12230: PUSH
12231: LD_INT 0
12233: PUSH
12234: LD_INT 1
12236: PUSH
12237: LD_INT 1
12239: PUSH
12240: EMPTY
12241: LIST
12242: LIST
12243: LIST
12244: LIST
12245: ST_TO_ADDR
// Charles = CreateHuman ;
12246: LD_ADDR_EXP 42
12250: PUSH
12251: CALL_OW 44
12255: ST_TO_ADDR
// hc_class := 1 ;
12256: LD_ADDR_OWVAR 28
12260: PUSH
12261: LD_INT 1
12263: ST_TO_ADDR
// hc_sex := sex_female ;
12264: LD_ADDR_OWVAR 27
12268: PUSH
12269: LD_INT 2
12271: ST_TO_ADDR
// hc_gallery := AmGalRemake ;
12272: LD_ADDR_OWVAR 33
12276: PUSH
12277: LD_STRING AmGalRemake
12279: ST_TO_ADDR
// hc_face_number := 2 ;
12280: LD_ADDR_OWVAR 34
12284: PUSH
12285: LD_INT 2
12287: ST_TO_ADDR
// hc_name := Johanna Holland ;
12288: LD_ADDR_OWVAR 26
12292: PUSH
12293: LD_STRING Johanna Holland
12295: ST_TO_ADDR
// hc_attr := [ 12 , 11 ] ;
12296: LD_ADDR_OWVAR 29
12300: PUSH
12301: LD_INT 12
12303: PUSH
12304: LD_INT 11
12306: PUSH
12307: EMPTY
12308: LIST
12309: LIST
12310: ST_TO_ADDR
// hc_skills := [ JohannadSkillLevel , rand ( 0 , 2 ) , rand ( 0 , 2 ) , rand ( 0 , 2 ) ] ;
12311: LD_ADDR_OWVAR 31
12315: PUSH
12316: LD_EXP 36
12320: PUSH
12321: LD_INT 0
12323: PPUSH
12324: LD_INT 2
12326: PPUSH
12327: CALL_OW 12
12331: PUSH
12332: LD_INT 0
12334: PPUSH
12335: LD_INT 2
12337: PPUSH
12338: CALL_OW 12
12342: PUSH
12343: LD_INT 0
12345: PPUSH
12346: LD_INT 2
12348: PPUSH
12349: CALL_OW 12
12353: PUSH
12354: EMPTY
12355: LIST
12356: LIST
12357: LIST
12358: LIST
12359: ST_TO_ADDR
// Johanna = CreateHuman ;
12360: LD_ADDR_EXP 43
12364: PUSH
12365: CALL_OW 44
12369: ST_TO_ADDR
// PlaceUnitArea ( Johanna , JohannaSpawnArea , false ) ;
12370: LD_EXP 43
12374: PPUSH
12375: LD_INT 19
12377: PPUSH
12378: LD_INT 0
12380: PPUSH
12381: CALL_OW 49
// ComEnterUnit ( Johanna , am_bun ) ;
12385: LD_EXP 43
12389: PPUSH
12390: LD_INT 23
12392: PPUSH
12393: CALL_OW 120
// Gladstone := PrepareUnit ( Gladstone , false ) ;
12397: LD_ADDR_EXP 44
12401: PUSH
12402: LD_STRING Gladstone
12404: PPUSH
12405: LD_INT 0
12407: PPUSH
12408: CALL 8050 0 2
12412: ST_TO_ADDR
// PlaceHumanInUnit ( Gladstone , am_lab ) ;
12413: LD_EXP 44
12417: PPUSH
12418: LD_INT 22
12420: PPUSH
12421: CALL_OW 52
// amApemans = [ ] ;
12425: LD_ADDR_EXP 45
12429: PUSH
12430: EMPTY
12431: ST_TO_ADDR
// for i := 1 to amApeAmount do
12432: LD_ADDR_VAR 0 2
12436: PUSH
12437: DOUBLE
12438: LD_INT 1
12440: DEC
12441: ST_TO_ADDR
12442: LD_EXP 35
12446: PUSH
12447: FOR_TO
12448: IFFALSE 12563
// begin hc_class := class_apeman ;
12450: LD_ADDR_OWVAR 28
12454: PUSH
12455: LD_INT 12
12457: ST_TO_ADDR
// hc_gallery :=  ;
12458: LD_ADDR_OWVAR 33
12462: PUSH
12463: LD_STRING 
12465: ST_TO_ADDR
// hc_name :=  ;
12466: LD_ADDR_OWVAR 26
12470: PUSH
12471: LD_STRING 
12473: ST_TO_ADDR
// hc_skills := [ JohannadSkillLevel , rand ( 0 , 2 ) , rand ( 0 , 2 ) , rand ( 0 , 2 ) ] ;
12474: LD_ADDR_OWVAR 31
12478: PUSH
12479: LD_EXP 36
12483: PUSH
12484: LD_INT 0
12486: PPUSH
12487: LD_INT 2
12489: PPUSH
12490: CALL_OW 12
12494: PUSH
12495: LD_INT 0
12497: PPUSH
12498: LD_INT 2
12500: PPUSH
12501: CALL_OW 12
12505: PUSH
12506: LD_INT 0
12508: PPUSH
12509: LD_INT 2
12511: PPUSH
12512: CALL_OW 12
12516: PUSH
12517: EMPTY
12518: LIST
12519: LIST
12520: LIST
12521: LIST
12522: ST_TO_ADDR
// ape = CreateHuman ;
12523: LD_ADDR_VAR 0 3
12527: PUSH
12528: CALL_OW 44
12532: ST_TO_ADDR
// PlaceHumanInUnit ( ape , am_lab ) ;
12533: LD_VAR 0 3
12537: PPUSH
12538: LD_INT 22
12540: PPUSH
12541: CALL_OW 52
// amApemans = amApemans ^ ape ;
12545: LD_ADDR_EXP 45
12549: PUSH
12550: LD_EXP 45
12554: PUSH
12555: LD_VAR 0 3
12559: ADD
12560: ST_TO_ADDR
// end ;
12561: GO 12447
12563: POP
12564: POP
// SetLives ( am_bun , americanBunkerHP ) ;
12565: LD_INT 23
12567: PPUSH
12568: LD_EXP 33
12572: PPUSH
12573: CALL_OW 234
// end ; end_of_file
12577: LD_VAR 0 1
12581: RET
// export Burlak ; export Pokryshkin , Saseda , Jaworska , Balei , Belkov , Jaunzeme ; export Kirilenkova ; export Gnyevko ; export Kurin ; export kirovSolds ; export function PrepareRussian ; begin
12582: LD_INT 0
12584: PPUSH
// PrepareHero ;
12585: CALL 12610 0 0
// PreparePokryshkinTeams ;
12589: CALL 12704 0 0
// PrepareJelena ;
12593: CALL 12969 0 0
// PrepareGnyevko ;
12597: CALL 13001 0 0
// PrepareKurin ;
12601: CALL 12672 0 0
// end ;
12605: LD_VAR 0 1
12609: RET
// function PrepareHero ; begin
12610: LD_INT 0
12612: PPUSH
// uc_side = 3 ;
12613: LD_ADDR_OWVAR 20
12617: PUSH
12618: LD_INT 3
12620: ST_TO_ADDR
// Burlak := PrepareUnit ( Burlak , false ) ;
12621: LD_ADDR_EXP 46
12625: PUSH
12626: LD_STRING Burlak
12628: PPUSH
12629: LD_INT 0
12631: PPUSH
12632: CALL 8050 0 2
12636: ST_TO_ADDR
// PlaceUnitXY ( Burlak , burlakSpawnPosition [ 1 ] , burlakSpawnPosition [ 2 ] , true ) ;
12637: LD_EXP 46
12641: PPUSH
12642: LD_EXP 37
12646: PUSH
12647: LD_INT 1
12649: ARRAY
12650: PPUSH
12651: LD_EXP 37
12655: PUSH
12656: LD_INT 2
12658: ARRAY
12659: PPUSH
12660: LD_INT 1
12662: PPUSH
12663: CALL_OW 48
// end ;
12667: LD_VAR 0 1
12671: RET
// function PrepareKurin ; begin
12672: LD_INT 0
12674: PPUSH
// uc_side = 6 ;
12675: LD_ADDR_OWVAR 20
12679: PUSH
12680: LD_INT 6
12682: ST_TO_ADDR
// Kurin := PrepareUnit ( Kurin , false ) ;
12683: LD_ADDR_EXP 55
12687: PUSH
12688: LD_STRING Kurin
12690: PPUSH
12691: LD_INT 0
12693: PPUSH
12694: CALL 8050 0 2
12698: ST_TO_ADDR
// end ;
12699: LD_VAR 0 1
12703: RET
// function PreparePokryshkinTeams ; begin
12704: LD_INT 0
12706: PPUSH
// uc_side = 6 ;
12707: LD_ADDR_OWVAR 20
12711: PUSH
12712: LD_INT 6
12714: ST_TO_ADDR
// Pokryshkin := PrepareUnit ( Pokryshkin , false ) ;
12715: LD_ADDR_EXP 47
12719: PUSH
12720: LD_STRING Pokryshkin
12722: PPUSH
12723: LD_INT 0
12725: PPUSH
12726: CALL 8050 0 2
12730: ST_TO_ADDR
// Saseda := PrepareUnit ( Saseda , false ) ;
12731: LD_ADDR_EXP 48
12735: PUSH
12736: LD_STRING Saseda
12738: PPUSH
12739: LD_INT 0
12741: PPUSH
12742: CALL 8050 0 2
12746: ST_TO_ADDR
// Jaworska := PrepareUnit ( Jaworska , false ) ;
12747: LD_ADDR_EXP 49
12751: PUSH
12752: LD_STRING Jaworska
12754: PPUSH
12755: LD_INT 0
12757: PPUSH
12758: CALL 8050 0 2
12762: ST_TO_ADDR
// Balei := PrepareUnit ( Balei , false ) ;
12763: LD_ADDR_EXP 50
12767: PUSH
12768: LD_STRING Balei
12770: PPUSH
12771: LD_INT 0
12773: PPUSH
12774: CALL 8050 0 2
12778: ST_TO_ADDR
// Belkov := PrepareUnit ( Belkov , false ) ;
12779: LD_ADDR_EXP 51
12783: PUSH
12784: LD_STRING Belkov
12786: PPUSH
12787: LD_INT 0
12789: PPUSH
12790: CALL 8050 0 2
12794: ST_TO_ADDR
// PlaceUnitArea ( Pokryshkin , PokryshkinSpawnArea , false ) ;
12795: LD_EXP 47
12799: PPUSH
12800: LD_INT 25
12802: PPUSH
12803: LD_INT 0
12805: PPUSH
12806: CALL_OW 49
// PlaceUnitArea ( Saseda , Ru2SpawnArea , false ) ;
12810: LD_EXP 48
12814: PPUSH
12815: LD_INT 17
12817: PPUSH
12818: LD_INT 0
12820: PPUSH
12821: CALL_OW 49
// PlaceUnitArea ( Jaworska , Ru2SpawnArea , false ) ;
12825: LD_EXP 49
12829: PPUSH
12830: LD_INT 17
12832: PPUSH
12833: LD_INT 0
12835: PPUSH
12836: CALL_OW 49
// PlaceUnitArea ( Balei , Ru2SpawnArea , false ) ;
12840: LD_EXP 50
12844: PPUSH
12845: LD_INT 17
12847: PPUSH
12848: LD_INT 0
12850: PPUSH
12851: CALL_OW 49
// PlaceUnitArea ( Belkov , Ru2SpawnArea , false ) ;
12855: LD_EXP 51
12859: PPUSH
12860: LD_INT 17
12862: PPUSH
12863: LD_INT 0
12865: PPUSH
12866: CALL_OW 49
// kirovSolds = [ Pokryshkin , Saseda , Balei , Belkov , Jaworska ] ;
12870: LD_ADDR_EXP 56
12874: PUSH
12875: LD_EXP 47
12879: PUSH
12880: LD_EXP 48
12884: PUSH
12885: LD_EXP 50
12889: PUSH
12890: LD_EXP 51
12894: PUSH
12895: LD_EXP 49
12899: PUSH
12900: EMPTY
12901: LIST
12902: LIST
12903: LIST
12904: LIST
12905: LIST
12906: ST_TO_ADDR
// if Difficulty < 3 then
12907: LD_OWVAR 67
12911: PUSH
12912: LD_INT 3
12914: LESS
12915: IFFALSE 12964
// begin Jaunzeme := PrepareUnit ( Jaunzeme , false ) ;
12917: LD_ADDR_EXP 52
12921: PUSH
12922: LD_STRING Jaunzeme
12924: PPUSH
12925: LD_INT 0
12927: PPUSH
12928: CALL 8050 0 2
12932: ST_TO_ADDR
// PlaceUnitArea ( Jaunzeme , Ru2SpawnArea2 , false ) ;
12933: LD_EXP 52
12937: PPUSH
12938: LD_INT 26
12940: PPUSH
12941: LD_INT 0
12943: PPUSH
12944: CALL_OW 49
// kirovSolds = kirovSolds ^ Jaunzeme ;
12948: LD_ADDR_EXP 56
12952: PUSH
12953: LD_EXP 56
12957: PUSH
12958: LD_EXP 52
12962: ADD
12963: ST_TO_ADDR
// end ; end ;
12964: LD_VAR 0 1
12968: RET
// function PrepareJelena ; begin
12969: LD_INT 0
12971: PPUSH
// uc_side = 8 ;
12972: LD_ADDR_OWVAR 20
12976: PUSH
12977: LD_INT 8
12979: ST_TO_ADDR
// Kirilenkova := PrepareUnit ( Kirilenkova , false ) ;
12980: LD_ADDR_EXP 53
12984: PUSH
12985: LD_STRING Kirilenkova
12987: PPUSH
12988: LD_INT 0
12990: PPUSH
12991: CALL 8050 0 2
12995: ST_TO_ADDR
// end ;
12996: LD_VAR 0 1
13000: RET
// function PrepareGnyevko ; var un , i , randomPosition ; begin
13001: LD_INT 0
13003: PPUSH
13004: PPUSH
13005: PPUSH
13006: PPUSH
// uc_side = 8 ;
13007: LD_ADDR_OWVAR 20
13011: PUSH
13012: LD_INT 8
13014: ST_TO_ADDR
// Gnyevko := PrepareUnit ( Gnyevko , false ) ;
13015: LD_ADDR_EXP 54
13019: PUSH
13020: LD_STRING Gnyevko
13022: PPUSH
13023: LD_INT 0
13025: PPUSH
13026: CALL 8050 0 2
13030: ST_TO_ADDR
// randomPosition = gnyevkoSpawnPositions [ rand ( 1 , gnyevkoSpawnPositions ) ] ;
13031: LD_ADDR_VAR 0 4
13035: PUSH
13036: LD_EXP 38
13040: PUSH
13041: LD_INT 1
13043: PPUSH
13044: LD_EXP 38
13048: PPUSH
13049: CALL_OW 12
13053: ARRAY
13054: ST_TO_ADDR
// PlaceUnitXY ( Gnyevko , randomPosition [ 1 ] , randomPosition [ 2 ] , false ) ;
13055: LD_EXP 54
13059: PPUSH
13060: LD_VAR 0 4
13064: PUSH
13065: LD_INT 1
13067: ARRAY
13068: PPUSH
13069: LD_VAR 0 4
13073: PUSH
13074: LD_INT 2
13076: ARRAY
13077: PPUSH
13078: LD_INT 0
13080: PPUSH
13081: CALL_OW 48
// SetLives ( Gnyevko , gnyevkoStartHP ) ;
13085: LD_EXP 54
13089: PPUSH
13090: LD_EXP 39
13094: PPUSH
13095: CALL_OW 234
// ComHold ( Gnyevko ) ;
13099: LD_EXP 54
13103: PPUSH
13104: CALL_OW 140
// for i := 1 to animalsAmount [ 1 ] - [ 3 , 2 , 1 ] [ Difficulty ] do
13108: LD_ADDR_VAR 0 3
13112: PUSH
13113: DOUBLE
13114: LD_INT 1
13116: DEC
13117: ST_TO_ADDR
13118: LD_EXP 27
13122: PUSH
13123: LD_INT 1
13125: ARRAY
13126: PUSH
13127: LD_INT 3
13129: PUSH
13130: LD_INT 2
13132: PUSH
13133: LD_INT 1
13135: PUSH
13136: EMPTY
13137: LIST
13138: LIST
13139: LIST
13140: PUSH
13141: LD_OWVAR 67
13145: ARRAY
13146: MINUS
13147: PUSH
13148: FOR_TO
13149: IFFALSE 13279
// begin uc_side = 0 ;
13151: LD_ADDR_OWVAR 20
13155: PUSH
13156: LD_INT 0
13158: ST_TO_ADDR
// uc_nation = nation_nature ;
13159: LD_ADDR_OWVAR 21
13163: PUSH
13164: LD_INT 0
13166: ST_TO_ADDR
// hc_class = class_apeman ;
13167: LD_ADDR_OWVAR 28
13171: PUSH
13172: LD_INT 12
13174: ST_TO_ADDR
// hc_skills = [ animalsStats [ 1 ] , animalsStats [ 2 ] , animalsStats [ 3 ] , animalsStats [ 4 ] ] ;
13175: LD_ADDR_OWVAR 31
13179: PUSH
13180: LD_EXP 28
13184: PUSH
13185: LD_INT 1
13187: ARRAY
13188: PUSH
13189: LD_EXP 28
13193: PUSH
13194: LD_INT 2
13196: ARRAY
13197: PUSH
13198: LD_EXP 28
13202: PUSH
13203: LD_INT 3
13205: ARRAY
13206: PUSH
13207: LD_EXP 28
13211: PUSH
13212: LD_INT 4
13214: ARRAY
13215: PUSH
13216: EMPTY
13217: LIST
13218: LIST
13219: LIST
13220: LIST
13221: ST_TO_ADDR
// hc_agressivity = apeAgression ;
13222: LD_ADDR_OWVAR 35
13226: PUSH
13227: LD_EXP 34
13231: ST_TO_ADDR
// un = CreateHuman ;
13232: LD_ADDR_VAR 0 2
13236: PUSH
13237: CALL_OW 44
13241: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( Gnyevko ) , GetY ( Gnyevko ) , 8 , false ) ;
13242: LD_VAR 0 2
13246: PPUSH
13247: LD_EXP 54
13251: PPUSH
13252: CALL_OW 250
13256: PPUSH
13257: LD_EXP 54
13261: PPUSH
13262: CALL_OW 251
13266: PPUSH
13267: LD_INT 8
13269: PPUSH
13270: LD_INT 0
13272: PPUSH
13273: CALL_OW 50
// end ;
13277: GO 13148
13279: POP
13280: POP
// end ; end_of_file
13281: LD_VAR 0 1
13285: RET
// export function PrepareNature ; var i , un ; begin
13286: LD_INT 0
13288: PPUSH
13289: PPUSH
13290: PPUSH
// for i := 1 to animalsAmount [ 1 ] do
13291: LD_ADDR_VAR 0 2
13295: PUSH
13296: DOUBLE
13297: LD_INT 1
13299: DEC
13300: ST_TO_ADDR
13301: LD_EXP 27
13305: PUSH
13306: LD_INT 1
13308: ARRAY
13309: PUSH
13310: FOR_TO
13311: IFFALSE 13421
// begin uc_side = 0 ;
13313: LD_ADDR_OWVAR 20
13317: PUSH
13318: LD_INT 0
13320: ST_TO_ADDR
// uc_nation = nation_nature ;
13321: LD_ADDR_OWVAR 21
13325: PUSH
13326: LD_INT 0
13328: ST_TO_ADDR
// hc_class = class_apeman ;
13329: LD_ADDR_OWVAR 28
13333: PUSH
13334: LD_INT 12
13336: ST_TO_ADDR
// hc_skills = [ animalsStats [ 1 ] , animalsStats [ 2 ] , animalsStats [ 3 ] , animalsStats [ 4 ] ] ;
13337: LD_ADDR_OWVAR 31
13341: PUSH
13342: LD_EXP 28
13346: PUSH
13347: LD_INT 1
13349: ARRAY
13350: PUSH
13351: LD_EXP 28
13355: PUSH
13356: LD_INT 2
13358: ARRAY
13359: PUSH
13360: LD_EXP 28
13364: PUSH
13365: LD_INT 3
13367: ARRAY
13368: PUSH
13369: LD_EXP 28
13373: PUSH
13374: LD_INT 4
13376: ARRAY
13377: PUSH
13378: EMPTY
13379: LIST
13380: LIST
13381: LIST
13382: LIST
13383: ST_TO_ADDR
// hc_agressivity = apeAgression ;
13384: LD_ADDR_OWVAR 35
13388: PUSH
13389: LD_EXP 34
13393: ST_TO_ADDR
// un = CreateHuman ;
13394: LD_ADDR_VAR 0 3
13398: PUSH
13399: CALL_OW 44
13403: ST_TO_ADDR
// PlaceUnitArea ( un , ApemanSpawnArea , false ) ;
13404: LD_VAR 0 3
13408: PPUSH
13409: LD_INT 16
13411: PPUSH
13412: LD_INT 0
13414: PPUSH
13415: CALL_OW 49
// end ;
13419: GO 13310
13421: POP
13422: POP
// for i := 1 to animalsAmount [ 2 ] do
13423: LD_ADDR_VAR 0 2
13427: PUSH
13428: DOUBLE
13429: LD_INT 1
13431: DEC
13432: ST_TO_ADDR
13433: LD_EXP 27
13437: PUSH
13438: LD_INT 2
13440: ARRAY
13441: PUSH
13442: FOR_TO
13443: IFFALSE 13553
// begin uc_side = 0 ;
13445: LD_ADDR_OWVAR 20
13449: PUSH
13450: LD_INT 0
13452: ST_TO_ADDR
// uc_nation = nation_nature ;
13453: LD_ADDR_OWVAR 21
13457: PUSH
13458: LD_INT 0
13460: ST_TO_ADDR
// hc_class = class_phororhacos ;
13461: LD_ADDR_OWVAR 28
13465: PUSH
13466: LD_INT 18
13468: ST_TO_ADDR
// hc_skills = [ animalsStats [ 1 ] , animalsStats [ 2 ] , animalsStats [ 3 ] , animalsStats [ 4 ] ] ;
13469: LD_ADDR_OWVAR 31
13473: PUSH
13474: LD_EXP 28
13478: PUSH
13479: LD_INT 1
13481: ARRAY
13482: PUSH
13483: LD_EXP 28
13487: PUSH
13488: LD_INT 2
13490: ARRAY
13491: PUSH
13492: LD_EXP 28
13496: PUSH
13497: LD_INT 3
13499: ARRAY
13500: PUSH
13501: LD_EXP 28
13505: PUSH
13506: LD_INT 4
13508: ARRAY
13509: PUSH
13510: EMPTY
13511: LIST
13512: LIST
13513: LIST
13514: LIST
13515: ST_TO_ADDR
// hc_agressivity = animalsAgression ;
13516: LD_ADDR_OWVAR 35
13520: PUSH
13521: LD_EXP 29
13525: ST_TO_ADDR
// un = CreateHuman ;
13526: LD_ADDR_VAR 0 3
13530: PUSH
13531: CALL_OW 44
13535: ST_TO_ADDR
// PlaceUnitArea ( un , NatureArea , false ) ;
13536: LD_VAR 0 3
13540: PPUSH
13541: LD_INT 15
13543: PPUSH
13544: LD_INT 0
13546: PPUSH
13547: CALL_OW 49
// end ;
13551: GO 13442
13553: POP
13554: POP
// for i := 1 to animalsAmount [ 3 ] do
13555: LD_ADDR_VAR 0 2
13559: PUSH
13560: DOUBLE
13561: LD_INT 1
13563: DEC
13564: ST_TO_ADDR
13565: LD_EXP 27
13569: PUSH
13570: LD_INT 3
13572: ARRAY
13573: PUSH
13574: FOR_TO
13575: IFFALSE 13685
// begin uc_side = 0 ;
13577: LD_ADDR_OWVAR 20
13581: PUSH
13582: LD_INT 0
13584: ST_TO_ADDR
// uc_nation = nation_nature ;
13585: LD_ADDR_OWVAR 21
13589: PUSH
13590: LD_INT 0
13592: ST_TO_ADDR
// hc_class = class_tiger ;
13593: LD_ADDR_OWVAR 28
13597: PUSH
13598: LD_INT 14
13600: ST_TO_ADDR
// hc_skills = [ animalsStats [ 1 ] , animalsStats [ 2 ] , animalsStats [ 3 ] , animalsStats [ 4 ] ] ;
13601: LD_ADDR_OWVAR 31
13605: PUSH
13606: LD_EXP 28
13610: PUSH
13611: LD_INT 1
13613: ARRAY
13614: PUSH
13615: LD_EXP 28
13619: PUSH
13620: LD_INT 2
13622: ARRAY
13623: PUSH
13624: LD_EXP 28
13628: PUSH
13629: LD_INT 3
13631: ARRAY
13632: PUSH
13633: LD_EXP 28
13637: PUSH
13638: LD_INT 4
13640: ARRAY
13641: PUSH
13642: EMPTY
13643: LIST
13644: LIST
13645: LIST
13646: LIST
13647: ST_TO_ADDR
// hc_agressivity = animalsAgression ;
13648: LD_ADDR_OWVAR 35
13652: PUSH
13653: LD_EXP 29
13657: ST_TO_ADDR
// un = CreateHuman ;
13658: LD_ADDR_VAR 0 3
13662: PUSH
13663: CALL_OW 44
13667: ST_TO_ADDR
// PlaceUnitArea ( un , NatureArea , false ) ;
13668: LD_VAR 0 3
13672: PPUSH
13673: LD_INT 15
13675: PPUSH
13676: LD_INT 0
13678: PPUSH
13679: CALL_OW 49
// end ;
13683: GO 13574
13685: POP
13686: POP
// for i := 1 to animalsAmount [ 4 ] do
13687: LD_ADDR_VAR 0 2
13691: PUSH
13692: DOUBLE
13693: LD_INT 1
13695: DEC
13696: ST_TO_ADDR
13697: LD_EXP 27
13701: PUSH
13702: LD_INT 4
13704: ARRAY
13705: PUSH
13706: FOR_TO
13707: IFFALSE 13817
// begin uc_side = 0 ;
13709: LD_ADDR_OWVAR 20
13713: PUSH
13714: LD_INT 0
13716: ST_TO_ADDR
// uc_nation = nation_nature ;
13717: LD_ADDR_OWVAR 21
13721: PUSH
13722: LD_INT 0
13724: ST_TO_ADDR
// hc_class = 21 ;
13725: LD_ADDR_OWVAR 28
13729: PUSH
13730: LD_INT 21
13732: ST_TO_ADDR
// hc_skills = [ animalsStats [ 1 ] , animalsStats [ 2 ] , animalsStats [ 3 ] , animalsStats [ 4 ] ] ;
13733: LD_ADDR_OWVAR 31
13737: PUSH
13738: LD_EXP 28
13742: PUSH
13743: LD_INT 1
13745: ARRAY
13746: PUSH
13747: LD_EXP 28
13751: PUSH
13752: LD_INT 2
13754: ARRAY
13755: PUSH
13756: LD_EXP 28
13760: PUSH
13761: LD_INT 3
13763: ARRAY
13764: PUSH
13765: LD_EXP 28
13769: PUSH
13770: LD_INT 4
13772: ARRAY
13773: PUSH
13774: EMPTY
13775: LIST
13776: LIST
13777: LIST
13778: LIST
13779: ST_TO_ADDR
// hc_agressivity = animalsAgression ;
13780: LD_ADDR_OWVAR 35
13784: PUSH
13785: LD_EXP 29
13789: ST_TO_ADDR
// un = CreateHuman ;
13790: LD_ADDR_VAR 0 3
13794: PUSH
13795: CALL_OW 44
13799: ST_TO_ADDR
// PlaceUnitArea ( un , NatureArea , false ) ;
13800: LD_VAR 0 3
13804: PPUSH
13805: LD_INT 15
13807: PPUSH
13808: LD_INT 0
13810: PPUSH
13811: CALL_OW 49
// end ;
13815: GO 13706
13817: POP
13818: POP
// end ; end_of_file
13819: LD_VAR 0 1
13823: RET
// on UnitGoesToRed ( unit ) do begin if unit = Burlak and not GetSide ( Kirilenkova ) = 3 and not IsOK ( Kirilenkova ) then
13824: LD_VAR 0 1
13828: PUSH
13829: LD_EXP 46
13833: EQUAL
13834: PUSH
13835: LD_EXP 53
13839: PPUSH
13840: CALL_OW 255
13844: PUSH
13845: LD_INT 3
13847: EQUAL
13848: NOT
13849: AND
13850: PUSH
13851: LD_EXP 53
13855: PPUSH
13856: CALL_OW 302
13860: NOT
13861: AND
13862: IFFALSE 13868
// BurlakDying ;
13864: CALL 11259 0 0
// if unit = Gladstone then
13868: LD_VAR 0 1
13872: PUSH
13873: LD_EXP 44
13877: EQUAL
13878: IFFALSE 13888
// gladstoneStatus = 0 ;
13880: LD_ADDR_EXP 1
13884: PUSH
13885: LD_INT 0
13887: ST_TO_ADDR
// if unit = Johanna then
13888: LD_VAR 0 1
13892: PUSH
13893: LD_EXP 43
13897: EQUAL
13898: IFFALSE 13908
// johannaStatus = 0 ;
13900: LD_ADDR_EXP 2
13904: PUSH
13905: LD_INT 0
13907: ST_TO_ADDR
// end ;
13908: PPOPN 1
13910: END
// on UnitDestroyed ( unit ) do begin if unit = Burlak then
13911: LD_VAR 0 1
13915: PUSH
13916: LD_EXP 46
13920: EQUAL
13921: IFFALSE 13927
// BurlakDying ;
13923: CALL 11259 0 0
// if GetSide ( unit ) = 3 then
13927: LD_VAR 0 1
13931: PPUSH
13932: CALL_OW 255
13936: PUSH
13937: LD_INT 3
13939: EQUAL
13940: IFFALSE 13956
// lostComradesCounter = lostComradesCounter + 1 ;
13942: LD_ADDR_EXP 23
13946: PUSH
13947: LD_EXP 23
13951: PUSH
13952: LD_INT 1
13954: PLUS
13955: ST_TO_ADDR
// if unit in kirovSolds then
13956: LD_VAR 0 1
13960: PUSH
13961: LD_EXP 56
13965: IN
13966: IFFALSE 13984
// kirovSolds = kirovSolds diff unit ;
13968: LD_ADDR_EXP 56
13972: PUSH
13973: LD_EXP 56
13977: PUSH
13978: LD_VAR 0 1
13982: DIFF
13983: ST_TO_ADDR
// end ;
13984: PPOPN 1
13986: END
// on Contact ( side1 , side2 ) do begin if ( side1 = 3 and side2 = 1 ) or ( side1 = 1 and side2 = 3 ) and secondAttack = 1 then
13987: LD_VAR 0 1
13991: PUSH
13992: LD_INT 3
13994: EQUAL
13995: PUSH
13996: LD_VAR 0 2
14000: PUSH
14001: LD_INT 1
14003: EQUAL
14004: AND
14005: PUSH
14006: LD_VAR 0 1
14010: PUSH
14011: LD_INT 1
14013: EQUAL
14014: PUSH
14015: LD_VAR 0 2
14019: PUSH
14020: LD_INT 3
14022: EQUAL
14023: AND
14024: PUSH
14025: LD_EXP 17
14029: PUSH
14030: LD_INT 1
14032: EQUAL
14033: AND
14034: OR
14035: IFFALSE 14041
// Dial_SecondAttack ;
14037: CALL 6011 0 0
// if side1 = 3 and side2 = 6 and not traitor then
14041: LD_VAR 0 1
14045: PUSH
14046: LD_INT 3
14048: EQUAL
14049: PUSH
14050: LD_VAR 0 2
14054: PUSH
14055: LD_INT 6
14057: EQUAL
14058: AND
14059: PUSH
14060: LD_EXP 18
14064: NOT
14065: AND
14066: IFFALSE 14072
// Dialogue_AttackComrade ;
14068: CALL 4123 0 0
// end ; end_of_file
14072: PPOPN 2
14074: END
// every 1 trigger GetSide ( Kirilenkova ) = 3 and achievement_JelenaTimer < 0 0$15 do
14075: LD_EXP 53
14079: PPUSH
14080: CALL_OW 255
14084: PUSH
14085: LD_INT 3
14087: EQUAL
14088: PUSH
14089: LD_EXP 26
14093: PUSH
14094: LD_INT 525
14096: LESS
14097: AND
14098: IFFALSE 14110
14100: GO 14102
14102: DISABLE
// SetAchievement ( ACH_YELENA ) ;
14103: LD_STRING ACH_YELENA
14105: PPUSH
14106: CALL_OW 543
14110: END
// every 1 trigger not FilterAllUnits ( [ [ f_nation , nation_nature ] , [ f_or , [ f_class , class_tiger ] , [ f_class , class_phororhacos ] , [ f_class , class_apeman ] ] ] ) do
14111: LD_INT 23
14113: PUSH
14114: LD_INT 0
14116: PUSH
14117: EMPTY
14118: LIST
14119: LIST
14120: PUSH
14121: LD_INT 2
14123: PUSH
14124: LD_INT 25
14126: PUSH
14127: LD_INT 14
14129: PUSH
14130: EMPTY
14131: LIST
14132: LIST
14133: PUSH
14134: LD_INT 25
14136: PUSH
14137: LD_INT 18
14139: PUSH
14140: EMPTY
14141: LIST
14142: LIST
14143: PUSH
14144: LD_INT 25
14146: PUSH
14147: LD_INT 12
14149: PUSH
14150: EMPTY
14151: LIST
14152: LIST
14153: PUSH
14154: EMPTY
14155: LIST
14156: LIST
14157: LIST
14158: LIST
14159: PUSH
14160: EMPTY
14161: LIST
14162: LIST
14163: PPUSH
14164: CALL_OW 69
14168: NOT
14169: IFFALSE 14181
14171: GO 14173
14173: DISABLE
// SetAchievement ( ACH_NATURE ) ; end_of_file
14174: LD_STRING ACH_NATURE
14176: PPUSH
14177: CALL_OW 543
14181: END
// export function SA_EndMission ( campaignNumber , missionNumber , medal1 , medal2 , medal3 ) ; var achiv ; begin
14182: LD_INT 0
14184: PPUSH
14185: PPUSH
// if not missionNumber then
14186: LD_VAR 0 2
14190: NOT
14191: IFFALSE 14195
// exit ;
14193: GO 14325
// achiv := false ;
14195: LD_ADDR_VAR 0 7
14199: PUSH
14200: LD_INT 0
14202: ST_TO_ADDR
// case campaignNumber of 1 :
14203: LD_VAR 0 1
14207: PUSH
14208: LD_INT 1
14210: DOUBLE
14211: EQUAL
14212: IFTRUE 14216
14214: GO 14227
14216: POP
// achiv := ACH_GOTA ; 2 :
14217: LD_ADDR_VAR 0 7
14221: PUSH
14222: LD_STRING ACH_GOTA
14224: ST_TO_ADDR
14225: GO 14277
14227: LD_INT 2
14229: DOUBLE
14230: EQUAL
14231: IFTRUE 14235
14233: GO 14238
14235: POP
// ; 3 :
14236: GO 14277
14238: LD_INT 3
14240: DOUBLE
14241: EQUAL
14242: IFTRUE 14246
14244: GO 14257
14246: POP
// achiv := ACH_MOTSU ; 4 :
14247: LD_ADDR_VAR 0 7
14251: PUSH
14252: LD_STRING ACH_MOTSU
14254: ST_TO_ADDR
14255: GO 14277
14257: LD_INT 4
14259: DOUBLE
14260: EQUAL
14261: IFTRUE 14265
14263: GO 14276
14265: POP
// achiv := ACH_LOP ; end ;
14266: LD_ADDR_VAR 0 7
14270: PUSH
14271: LD_STRING ACH_LOP
14273: ST_TO_ADDR
14274: GO 14277
14276: POP
// if Difficulty = 3 and achiv and medal1 and medal2 and medal3 then
14277: LD_OWVAR 67
14281: PUSH
14282: LD_INT 3
14284: EQUAL
14285: PUSH
14286: LD_VAR 0 7
14290: AND
14291: PUSH
14292: LD_VAR 0 3
14296: AND
14297: PUSH
14298: LD_VAR 0 4
14302: AND
14303: PUSH
14304: LD_VAR 0 5
14308: AND
14309: IFFALSE 14325
// SetAchievementEX ( achiv , missionNumber ) ;
14311: LD_VAR 0 7
14315: PPUSH
14316: LD_VAR 0 2
14320: PPUSH
14321: CALL_OW 564
// end ;
14325: LD_VAR 0 6
14329: RET
// export function SA_BehemothConstructed ; begin
14330: LD_INT 0
14332: PPUSH
// SetAchievement ( ACH_SMC ) ;
14333: LD_STRING ACH_SMC
14335: PPUSH
14336: CALL_OW 543
// end ; end_of_file
14340: LD_VAR 0 1
14344: RET
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin if p2 = 100 then
14345: LD_VAR 0 2
14349: PUSH
14350: LD_INT 100
14352: EQUAL
14353: IFFALSE 15302
// begin if not StreamModeActive then
14355: LD_EXP 57
14359: NOT
14360: IFFALSE 14370
// StreamModeActive := true ;
14362: LD_ADDR_EXP 57
14366: PUSH
14367: LD_INT 1
14369: ST_TO_ADDR
// if p3 = 0 then
14370: LD_VAR 0 3
14374: PUSH
14375: LD_INT 0
14377: EQUAL
14378: IFFALSE 14384
// InitStreamMode ;
14380: CALL 15460 0 0
// if p3 = 1 then
14384: LD_VAR 0 3
14388: PUSH
14389: LD_INT 1
14391: EQUAL
14392: IFFALSE 14402
// sRocket := true ;
14394: LD_ADDR_EXP 62
14398: PUSH
14399: LD_INT 1
14401: ST_TO_ADDR
// if p3 = 2 then
14402: LD_VAR 0 3
14406: PUSH
14407: LD_INT 2
14409: EQUAL
14410: IFFALSE 14420
// sSpeed := true ;
14412: LD_ADDR_EXP 61
14416: PUSH
14417: LD_INT 1
14419: ST_TO_ADDR
// if p3 = 3 then
14420: LD_VAR 0 3
14424: PUSH
14425: LD_INT 3
14427: EQUAL
14428: IFFALSE 14438
// sEngine := true ;
14430: LD_ADDR_EXP 63
14434: PUSH
14435: LD_INT 1
14437: ST_TO_ADDR
// if p3 = 4 then
14438: LD_VAR 0 3
14442: PUSH
14443: LD_INT 4
14445: EQUAL
14446: IFFALSE 14456
// sSpec := true ;
14448: LD_ADDR_EXP 60
14452: PUSH
14453: LD_INT 1
14455: ST_TO_ADDR
// if p3 = 5 then
14456: LD_VAR 0 3
14460: PUSH
14461: LD_INT 5
14463: EQUAL
14464: IFFALSE 14474
// sLevel := true ;
14466: LD_ADDR_EXP 64
14470: PUSH
14471: LD_INT 1
14473: ST_TO_ADDR
// if p3 = 6 then
14474: LD_VAR 0 3
14478: PUSH
14479: LD_INT 6
14481: EQUAL
14482: IFFALSE 14492
// sArmoury := true ;
14484: LD_ADDR_EXP 65
14488: PUSH
14489: LD_INT 1
14491: ST_TO_ADDR
// if p3 = 7 then
14492: LD_VAR 0 3
14496: PUSH
14497: LD_INT 7
14499: EQUAL
14500: IFFALSE 14510
// sRadar := true ;
14502: LD_ADDR_EXP 66
14506: PUSH
14507: LD_INT 1
14509: ST_TO_ADDR
// if p3 = 8 then
14510: LD_VAR 0 3
14514: PUSH
14515: LD_INT 8
14517: EQUAL
14518: IFFALSE 14528
// sBunker := true ;
14520: LD_ADDR_EXP 67
14524: PUSH
14525: LD_INT 1
14527: ST_TO_ADDR
// if p3 = 9 then
14528: LD_VAR 0 3
14532: PUSH
14533: LD_INT 9
14535: EQUAL
14536: IFFALSE 14546
// sHack := true ;
14538: LD_ADDR_EXP 68
14542: PUSH
14543: LD_INT 1
14545: ST_TO_ADDR
// if p3 = 10 then
14546: LD_VAR 0 3
14550: PUSH
14551: LD_INT 10
14553: EQUAL
14554: IFFALSE 14564
// sFire := true ;
14556: LD_ADDR_EXP 69
14560: PUSH
14561: LD_INT 1
14563: ST_TO_ADDR
// if p3 = 11 then
14564: LD_VAR 0 3
14568: PUSH
14569: LD_INT 11
14571: EQUAL
14572: IFFALSE 14582
// sRefresh := true ;
14574: LD_ADDR_EXP 70
14578: PUSH
14579: LD_INT 1
14581: ST_TO_ADDR
// if p3 = 12 then
14582: LD_VAR 0 3
14586: PUSH
14587: LD_INT 12
14589: EQUAL
14590: IFFALSE 14600
// sExp := true ;
14592: LD_ADDR_EXP 71
14596: PUSH
14597: LD_INT 1
14599: ST_TO_ADDR
// if p3 = 13 then
14600: LD_VAR 0 3
14604: PUSH
14605: LD_INT 13
14607: EQUAL
14608: IFFALSE 14618
// sDepot := true ;
14610: LD_ADDR_EXP 72
14614: PUSH
14615: LD_INT 1
14617: ST_TO_ADDR
// if p3 = 14 then
14618: LD_VAR 0 3
14622: PUSH
14623: LD_INT 14
14625: EQUAL
14626: IFFALSE 14636
// sFlag := true ;
14628: LD_ADDR_EXP 73
14632: PUSH
14633: LD_INT 1
14635: ST_TO_ADDR
// if p3 = 15 then
14636: LD_VAR 0 3
14640: PUSH
14641: LD_INT 15
14643: EQUAL
14644: IFFALSE 14654
// sKamikadze := true ;
14646: LD_ADDR_EXP 81
14650: PUSH
14651: LD_INT 1
14653: ST_TO_ADDR
// if p3 = 16 then
14654: LD_VAR 0 3
14658: PUSH
14659: LD_INT 16
14661: EQUAL
14662: IFFALSE 14672
// sTroll := true ;
14664: LD_ADDR_EXP 82
14668: PUSH
14669: LD_INT 1
14671: ST_TO_ADDR
// if p3 = 17 then
14672: LD_VAR 0 3
14676: PUSH
14677: LD_INT 17
14679: EQUAL
14680: IFFALSE 14690
// sSlow := true ;
14682: LD_ADDR_EXP 83
14686: PUSH
14687: LD_INT 1
14689: ST_TO_ADDR
// if p3 = 18 then
14690: LD_VAR 0 3
14694: PUSH
14695: LD_INT 18
14697: EQUAL
14698: IFFALSE 14708
// sLack := true ;
14700: LD_ADDR_EXP 84
14704: PUSH
14705: LD_INT 1
14707: ST_TO_ADDR
// if p3 = 19 then
14708: LD_VAR 0 3
14712: PUSH
14713: LD_INT 19
14715: EQUAL
14716: IFFALSE 14726
// sTank := true ;
14718: LD_ADDR_EXP 86
14722: PUSH
14723: LD_INT 1
14725: ST_TO_ADDR
// if p3 = 20 then
14726: LD_VAR 0 3
14730: PUSH
14731: LD_INT 20
14733: EQUAL
14734: IFFALSE 14744
// sRemote := true ;
14736: LD_ADDR_EXP 87
14740: PUSH
14741: LD_INT 1
14743: ST_TO_ADDR
// if p3 = 21 then
14744: LD_VAR 0 3
14748: PUSH
14749: LD_INT 21
14751: EQUAL
14752: IFFALSE 14762
// sPowell := true ;
14754: LD_ADDR_EXP 88
14758: PUSH
14759: LD_INT 1
14761: ST_TO_ADDR
// if p3 = 22 then
14762: LD_VAR 0 3
14766: PUSH
14767: LD_INT 22
14769: EQUAL
14770: IFFALSE 14780
// sTeleport := true ;
14772: LD_ADDR_EXP 91
14776: PUSH
14777: LD_INT 1
14779: ST_TO_ADDR
// if p3 = 23 then
14780: LD_VAR 0 3
14784: PUSH
14785: LD_INT 23
14787: EQUAL
14788: IFFALSE 14798
// sOilTower := true ;
14790: LD_ADDR_EXP 93
14794: PUSH
14795: LD_INT 1
14797: ST_TO_ADDR
// if p3 = 24 then
14798: LD_VAR 0 3
14802: PUSH
14803: LD_INT 24
14805: EQUAL
14806: IFFALSE 14816
// sShovel := true ;
14808: LD_ADDR_EXP 94
14812: PUSH
14813: LD_INT 1
14815: ST_TO_ADDR
// if p3 = 25 then
14816: LD_VAR 0 3
14820: PUSH
14821: LD_INT 25
14823: EQUAL
14824: IFFALSE 14834
// sSheik := true ;
14826: LD_ADDR_EXP 95
14830: PUSH
14831: LD_INT 1
14833: ST_TO_ADDR
// if p3 = 26 then
14834: LD_VAR 0 3
14838: PUSH
14839: LD_INT 26
14841: EQUAL
14842: IFFALSE 14852
// sEarthquake := true ;
14844: LD_ADDR_EXP 97
14848: PUSH
14849: LD_INT 1
14851: ST_TO_ADDR
// if p3 = 27 then
14852: LD_VAR 0 3
14856: PUSH
14857: LD_INT 27
14859: EQUAL
14860: IFFALSE 14870
// sAI := true ;
14862: LD_ADDR_EXP 98
14866: PUSH
14867: LD_INT 1
14869: ST_TO_ADDR
// if p3 = 28 then
14870: LD_VAR 0 3
14874: PUSH
14875: LD_INT 28
14877: EQUAL
14878: IFFALSE 14888
// sCargo := true ;
14880: LD_ADDR_EXP 101
14884: PUSH
14885: LD_INT 1
14887: ST_TO_ADDR
// if p3 = 29 then
14888: LD_VAR 0 3
14892: PUSH
14893: LD_INT 29
14895: EQUAL
14896: IFFALSE 14906
// sDLaser := true ;
14898: LD_ADDR_EXP 102
14902: PUSH
14903: LD_INT 1
14905: ST_TO_ADDR
// if p3 = 30 then
14906: LD_VAR 0 3
14910: PUSH
14911: LD_INT 30
14913: EQUAL
14914: IFFALSE 14924
// sExchange := true ;
14916: LD_ADDR_EXP 103
14920: PUSH
14921: LD_INT 1
14923: ST_TO_ADDR
// if p3 = 31 then
14924: LD_VAR 0 3
14928: PUSH
14929: LD_INT 31
14931: EQUAL
14932: IFFALSE 14942
// sFac := true ;
14934: LD_ADDR_EXP 104
14938: PUSH
14939: LD_INT 1
14941: ST_TO_ADDR
// if p3 = 32 then
14942: LD_VAR 0 3
14946: PUSH
14947: LD_INT 32
14949: EQUAL
14950: IFFALSE 14960
// sPower := true ;
14952: LD_ADDR_EXP 105
14956: PUSH
14957: LD_INT 1
14959: ST_TO_ADDR
// if p3 = 33 then
14960: LD_VAR 0 3
14964: PUSH
14965: LD_INT 33
14967: EQUAL
14968: IFFALSE 14978
// sRandom := true ;
14970: LD_ADDR_EXP 106
14974: PUSH
14975: LD_INT 1
14977: ST_TO_ADDR
// if p3 = 34 then
14978: LD_VAR 0 3
14982: PUSH
14983: LD_INT 34
14985: EQUAL
14986: IFFALSE 14996
// sShield := true ;
14988: LD_ADDR_EXP 107
14992: PUSH
14993: LD_INT 1
14995: ST_TO_ADDR
// if p3 = 35 then
14996: LD_VAR 0 3
15000: PUSH
15001: LD_INT 35
15003: EQUAL
15004: IFFALSE 15014
// sTime := true ;
15006: LD_ADDR_EXP 108
15010: PUSH
15011: LD_INT 1
15013: ST_TO_ADDR
// if p3 = 36 then
15014: LD_VAR 0 3
15018: PUSH
15019: LD_INT 36
15021: EQUAL
15022: IFFALSE 15032
// sTools := true ;
15024: LD_ADDR_EXP 109
15028: PUSH
15029: LD_INT 1
15031: ST_TO_ADDR
// if p3 = 101 then
15032: LD_VAR 0 3
15036: PUSH
15037: LD_INT 101
15039: EQUAL
15040: IFFALSE 15050
// sSold := true ;
15042: LD_ADDR_EXP 74
15046: PUSH
15047: LD_INT 1
15049: ST_TO_ADDR
// if p3 = 102 then
15050: LD_VAR 0 3
15054: PUSH
15055: LD_INT 102
15057: EQUAL
15058: IFFALSE 15068
// sDiff := true ;
15060: LD_ADDR_EXP 75
15064: PUSH
15065: LD_INT 1
15067: ST_TO_ADDR
// if p3 = 103 then
15068: LD_VAR 0 3
15072: PUSH
15073: LD_INT 103
15075: EQUAL
15076: IFFALSE 15086
// sFog := true ;
15078: LD_ADDR_EXP 78
15082: PUSH
15083: LD_INT 1
15085: ST_TO_ADDR
// if p3 = 104 then
15086: LD_VAR 0 3
15090: PUSH
15091: LD_INT 104
15093: EQUAL
15094: IFFALSE 15104
// sReset := true ;
15096: LD_ADDR_EXP 79
15100: PUSH
15101: LD_INT 1
15103: ST_TO_ADDR
// if p3 = 105 then
15104: LD_VAR 0 3
15108: PUSH
15109: LD_INT 105
15111: EQUAL
15112: IFFALSE 15122
// sSun := true ;
15114: LD_ADDR_EXP 80
15118: PUSH
15119: LD_INT 1
15121: ST_TO_ADDR
// if p3 = 106 then
15122: LD_VAR 0 3
15126: PUSH
15127: LD_INT 106
15129: EQUAL
15130: IFFALSE 15140
// sTiger := true ;
15132: LD_ADDR_EXP 76
15136: PUSH
15137: LD_INT 1
15139: ST_TO_ADDR
// if p3 = 107 then
15140: LD_VAR 0 3
15144: PUSH
15145: LD_INT 107
15147: EQUAL
15148: IFFALSE 15158
// sBomb := true ;
15150: LD_ADDR_EXP 77
15154: PUSH
15155: LD_INT 1
15157: ST_TO_ADDR
// if p3 = 108 then
15158: LD_VAR 0 3
15162: PUSH
15163: LD_INT 108
15165: EQUAL
15166: IFFALSE 15176
// sWound := true ;
15168: LD_ADDR_EXP 85
15172: PUSH
15173: LD_INT 1
15175: ST_TO_ADDR
// if p3 = 109 then
15176: LD_VAR 0 3
15180: PUSH
15181: LD_INT 109
15183: EQUAL
15184: IFFALSE 15194
// sBetray := true ;
15186: LD_ADDR_EXP 89
15190: PUSH
15191: LD_INT 1
15193: ST_TO_ADDR
// if p3 = 110 then
15194: LD_VAR 0 3
15198: PUSH
15199: LD_INT 110
15201: EQUAL
15202: IFFALSE 15212
// sContamin := true ;
15204: LD_ADDR_EXP 90
15208: PUSH
15209: LD_INT 1
15211: ST_TO_ADDR
// if p3 = 111 then
15212: LD_VAR 0 3
15216: PUSH
15217: LD_INT 111
15219: EQUAL
15220: IFFALSE 15230
// sOil := true ;
15222: LD_ADDR_EXP 92
15226: PUSH
15227: LD_INT 1
15229: ST_TO_ADDR
// if p3 = 112 then
15230: LD_VAR 0 3
15234: PUSH
15235: LD_INT 112
15237: EQUAL
15238: IFFALSE 15248
// sStu := true ;
15240: LD_ADDR_EXP 96
15244: PUSH
15245: LD_INT 1
15247: ST_TO_ADDR
// if p3 = 113 then
15248: LD_VAR 0 3
15252: PUSH
15253: LD_INT 113
15255: EQUAL
15256: IFFALSE 15266
// sBazooka := true ;
15258: LD_ADDR_EXP 99
15262: PUSH
15263: LD_INT 1
15265: ST_TO_ADDR
// if p3 = 114 then
15266: LD_VAR 0 3
15270: PUSH
15271: LD_INT 114
15273: EQUAL
15274: IFFALSE 15284
// sMortar := true ;
15276: LD_ADDR_EXP 100
15280: PUSH
15281: LD_INT 1
15283: ST_TO_ADDR
// if p3 = 115 then
15284: LD_VAR 0 3
15288: PUSH
15289: LD_INT 115
15291: EQUAL
15292: IFFALSE 15302
// sRanger := true ;
15294: LD_ADDR_EXP 110
15298: PUSH
15299: LD_INT 1
15301: ST_TO_ADDR
// end ; if p2 = 101 then
15302: LD_VAR 0 2
15306: PUSH
15307: LD_INT 101
15309: EQUAL
15310: IFFALSE 15438
// begin case p3 of 1 :
15312: LD_VAR 0 3
15316: PUSH
15317: LD_INT 1
15319: DOUBLE
15320: EQUAL
15321: IFTRUE 15325
15323: GO 15332
15325: POP
// hHackUnlimitedResources ; 2 :
15326: CALL 26473 0 0
15330: GO 15438
15332: LD_INT 2
15334: DOUBLE
15335: EQUAL
15336: IFTRUE 15340
15338: GO 15347
15340: POP
// hHackSetLevel10 ; 3 :
15341: CALL 26606 0 0
15345: GO 15438
15347: LD_INT 3
15349: DOUBLE
15350: EQUAL
15351: IFTRUE 15355
15353: GO 15362
15355: POP
// hHackSetLevel10YourUnits ; 4 :
15356: CALL 26691 0 0
15360: GO 15438
15362: LD_INT 4
15364: DOUBLE
15365: EQUAL
15366: IFTRUE 15370
15368: GO 15377
15370: POP
// hHackInvincible ; 5 :
15371: CALL 27139 0 0
15375: GO 15438
15377: LD_INT 5
15379: DOUBLE
15380: EQUAL
15381: IFTRUE 15385
15383: GO 15392
15385: POP
// hHackInvisible ; 6 :
15386: CALL 27250 0 0
15390: GO 15438
15392: LD_INT 6
15394: DOUBLE
15395: EQUAL
15396: IFTRUE 15400
15398: GO 15407
15400: POP
// hHackChangeYourSide ; 7 :
15401: CALL 27307 0 0
15405: GO 15438
15407: LD_INT 7
15409: DOUBLE
15410: EQUAL
15411: IFTRUE 15415
15413: GO 15422
15415: POP
// hHackChangeUnitSide ; 8 :
15416: CALL 27349 0 0
15420: GO 15438
15422: LD_INT 8
15424: DOUBLE
15425: EQUAL
15426: IFTRUE 15430
15428: GO 15437
15430: POP
// hHackFog ; end ;
15431: CALL 27450 0 0
15435: GO 15438
15437: POP
// end ; end ;
15438: PPOPN 6
15440: END
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger ; every 0 0$1 do
15441: GO 15443
15443: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
15444: LD_STRING initStreamRollete();
15446: PPUSH
15447: CALL_OW 559
// InitStreamMode ;
15451: CALL 15460 0 0
// DefineStreamItems ( ) ;
15455: CALL 15900 0 0
// end ;
15459: END
// function InitStreamMode ; begin
15460: LD_INT 0
15462: PPUSH
// streamModeActive := false ;
15463: LD_ADDR_EXP 57
15467: PUSH
15468: LD_INT 0
15470: ST_TO_ADDR
// normalCounter := 36 ;
15471: LD_ADDR_EXP 58
15475: PUSH
15476: LD_INT 36
15478: ST_TO_ADDR
// hardcoreCounter := 16 ;
15479: LD_ADDR_EXP 59
15483: PUSH
15484: LD_INT 16
15486: ST_TO_ADDR
// sRocket := false ;
15487: LD_ADDR_EXP 62
15491: PUSH
15492: LD_INT 0
15494: ST_TO_ADDR
// sSpeed := false ;
15495: LD_ADDR_EXP 61
15499: PUSH
15500: LD_INT 0
15502: ST_TO_ADDR
// sEngine := false ;
15503: LD_ADDR_EXP 63
15507: PUSH
15508: LD_INT 0
15510: ST_TO_ADDR
// sSpec := false ;
15511: LD_ADDR_EXP 60
15515: PUSH
15516: LD_INT 0
15518: ST_TO_ADDR
// sLevel := false ;
15519: LD_ADDR_EXP 64
15523: PUSH
15524: LD_INT 0
15526: ST_TO_ADDR
// sArmoury := false ;
15527: LD_ADDR_EXP 65
15531: PUSH
15532: LD_INT 0
15534: ST_TO_ADDR
// sRadar := false ;
15535: LD_ADDR_EXP 66
15539: PUSH
15540: LD_INT 0
15542: ST_TO_ADDR
// sBunker := false ;
15543: LD_ADDR_EXP 67
15547: PUSH
15548: LD_INT 0
15550: ST_TO_ADDR
// sHack := false ;
15551: LD_ADDR_EXP 68
15555: PUSH
15556: LD_INT 0
15558: ST_TO_ADDR
// sFire := false ;
15559: LD_ADDR_EXP 69
15563: PUSH
15564: LD_INT 0
15566: ST_TO_ADDR
// sRefresh := false ;
15567: LD_ADDR_EXP 70
15571: PUSH
15572: LD_INT 0
15574: ST_TO_ADDR
// sExp := false ;
15575: LD_ADDR_EXP 71
15579: PUSH
15580: LD_INT 0
15582: ST_TO_ADDR
// sDepot := false ;
15583: LD_ADDR_EXP 72
15587: PUSH
15588: LD_INT 0
15590: ST_TO_ADDR
// sFlag := false ;
15591: LD_ADDR_EXP 73
15595: PUSH
15596: LD_INT 0
15598: ST_TO_ADDR
// sKamikadze := false ;
15599: LD_ADDR_EXP 81
15603: PUSH
15604: LD_INT 0
15606: ST_TO_ADDR
// sTroll := false ;
15607: LD_ADDR_EXP 82
15611: PUSH
15612: LD_INT 0
15614: ST_TO_ADDR
// sSlow := false ;
15615: LD_ADDR_EXP 83
15619: PUSH
15620: LD_INT 0
15622: ST_TO_ADDR
// sLack := false ;
15623: LD_ADDR_EXP 84
15627: PUSH
15628: LD_INT 0
15630: ST_TO_ADDR
// sTank := false ;
15631: LD_ADDR_EXP 86
15635: PUSH
15636: LD_INT 0
15638: ST_TO_ADDR
// sRemote := false ;
15639: LD_ADDR_EXP 87
15643: PUSH
15644: LD_INT 0
15646: ST_TO_ADDR
// sPowell := false ;
15647: LD_ADDR_EXP 88
15651: PUSH
15652: LD_INT 0
15654: ST_TO_ADDR
// sTeleport := false ;
15655: LD_ADDR_EXP 91
15659: PUSH
15660: LD_INT 0
15662: ST_TO_ADDR
// sOilTower := false ;
15663: LD_ADDR_EXP 93
15667: PUSH
15668: LD_INT 0
15670: ST_TO_ADDR
// sShovel := false ;
15671: LD_ADDR_EXP 94
15675: PUSH
15676: LD_INT 0
15678: ST_TO_ADDR
// sSheik := false ;
15679: LD_ADDR_EXP 95
15683: PUSH
15684: LD_INT 0
15686: ST_TO_ADDR
// sEarthquake := false ;
15687: LD_ADDR_EXP 97
15691: PUSH
15692: LD_INT 0
15694: ST_TO_ADDR
// sAI := false ;
15695: LD_ADDR_EXP 98
15699: PUSH
15700: LD_INT 0
15702: ST_TO_ADDR
// sCargo := false ;
15703: LD_ADDR_EXP 101
15707: PUSH
15708: LD_INT 0
15710: ST_TO_ADDR
// sDLaser := false ;
15711: LD_ADDR_EXP 102
15715: PUSH
15716: LD_INT 0
15718: ST_TO_ADDR
// sExchange := false ;
15719: LD_ADDR_EXP 103
15723: PUSH
15724: LD_INT 0
15726: ST_TO_ADDR
// sFac := false ;
15727: LD_ADDR_EXP 104
15731: PUSH
15732: LD_INT 0
15734: ST_TO_ADDR
// sPower := false ;
15735: LD_ADDR_EXP 105
15739: PUSH
15740: LD_INT 0
15742: ST_TO_ADDR
// sRandom := false ;
15743: LD_ADDR_EXP 106
15747: PUSH
15748: LD_INT 0
15750: ST_TO_ADDR
// sShield := false ;
15751: LD_ADDR_EXP 107
15755: PUSH
15756: LD_INT 0
15758: ST_TO_ADDR
// sTime := false ;
15759: LD_ADDR_EXP 108
15763: PUSH
15764: LD_INT 0
15766: ST_TO_ADDR
// sTools := false ;
15767: LD_ADDR_EXP 109
15771: PUSH
15772: LD_INT 0
15774: ST_TO_ADDR
// sSold := false ;
15775: LD_ADDR_EXP 74
15779: PUSH
15780: LD_INT 0
15782: ST_TO_ADDR
// sDiff := false ;
15783: LD_ADDR_EXP 75
15787: PUSH
15788: LD_INT 0
15790: ST_TO_ADDR
// sFog := false ;
15791: LD_ADDR_EXP 78
15795: PUSH
15796: LD_INT 0
15798: ST_TO_ADDR
// sReset := false ;
15799: LD_ADDR_EXP 79
15803: PUSH
15804: LD_INT 0
15806: ST_TO_ADDR
// sSun := false ;
15807: LD_ADDR_EXP 80
15811: PUSH
15812: LD_INT 0
15814: ST_TO_ADDR
// sTiger := false ;
15815: LD_ADDR_EXP 76
15819: PUSH
15820: LD_INT 0
15822: ST_TO_ADDR
// sBomb := false ;
15823: LD_ADDR_EXP 77
15827: PUSH
15828: LD_INT 0
15830: ST_TO_ADDR
// sWound := false ;
15831: LD_ADDR_EXP 85
15835: PUSH
15836: LD_INT 0
15838: ST_TO_ADDR
// sBetray := false ;
15839: LD_ADDR_EXP 89
15843: PUSH
15844: LD_INT 0
15846: ST_TO_ADDR
// sContamin := false ;
15847: LD_ADDR_EXP 90
15851: PUSH
15852: LD_INT 0
15854: ST_TO_ADDR
// sOil := false ;
15855: LD_ADDR_EXP 92
15859: PUSH
15860: LD_INT 0
15862: ST_TO_ADDR
// sStu := false ;
15863: LD_ADDR_EXP 96
15867: PUSH
15868: LD_INT 0
15870: ST_TO_ADDR
// sBazooka := false ;
15871: LD_ADDR_EXP 99
15875: PUSH
15876: LD_INT 0
15878: ST_TO_ADDR
// sMortar := false ;
15879: LD_ADDR_EXP 100
15883: PUSH
15884: LD_INT 0
15886: ST_TO_ADDR
// sRanger := false ;
15887: LD_ADDR_EXP 110
15891: PUSH
15892: LD_INT 0
15894: ST_TO_ADDR
// end ;
15895: LD_VAR 0 1
15899: RET
// function DefineStreamItems ( ) ; var tmp , normal , hardcore , i ; begin
15900: LD_INT 0
15902: PPUSH
15903: PPUSH
15904: PPUSH
15905: PPUSH
15906: PPUSH
// result := [ ] ;
15907: LD_ADDR_VAR 0 1
15911: PUSH
15912: EMPTY
15913: ST_TO_ADDR
// if campaign_id = 1 then
15914: LD_OWVAR 69
15918: PUSH
15919: LD_INT 1
15921: EQUAL
15922: IFFALSE 18860
// begin case mission_number of 1 :
15924: LD_OWVAR 70
15928: PUSH
15929: LD_INT 1
15931: DOUBLE
15932: EQUAL
15933: IFTRUE 15937
15935: GO 16001
15937: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 ] ] ; 2 :
15938: LD_ADDR_VAR 0 1
15942: PUSH
15943: LD_INT 2
15945: PUSH
15946: LD_INT 4
15948: PUSH
15949: LD_INT 11
15951: PUSH
15952: LD_INT 12
15954: PUSH
15955: LD_INT 15
15957: PUSH
15958: LD_INT 16
15960: PUSH
15961: LD_INT 22
15963: PUSH
15964: LD_INT 23
15966: PUSH
15967: LD_INT 26
15969: PUSH
15970: EMPTY
15971: LIST
15972: LIST
15973: LIST
15974: LIST
15975: LIST
15976: LIST
15977: LIST
15978: LIST
15979: LIST
15980: PUSH
15981: LD_INT 101
15983: PUSH
15984: LD_INT 102
15986: PUSH
15987: LD_INT 106
15989: PUSH
15990: EMPTY
15991: LIST
15992: LIST
15993: LIST
15994: PUSH
15995: EMPTY
15996: LIST
15997: LIST
15998: ST_TO_ADDR
15999: GO 18858
16001: LD_INT 2
16003: DOUBLE
16004: EQUAL
16005: IFTRUE 16009
16007: GO 16081
16009: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 3 :
16010: LD_ADDR_VAR 0 1
16014: PUSH
16015: LD_INT 2
16017: PUSH
16018: LD_INT 4
16020: PUSH
16021: LD_INT 11
16023: PUSH
16024: LD_INT 12
16026: PUSH
16027: LD_INT 15
16029: PUSH
16030: LD_INT 16
16032: PUSH
16033: LD_INT 22
16035: PUSH
16036: LD_INT 23
16038: PUSH
16039: LD_INT 26
16041: PUSH
16042: EMPTY
16043: LIST
16044: LIST
16045: LIST
16046: LIST
16047: LIST
16048: LIST
16049: LIST
16050: LIST
16051: LIST
16052: PUSH
16053: LD_INT 101
16055: PUSH
16056: LD_INT 102
16058: PUSH
16059: LD_INT 105
16061: PUSH
16062: LD_INT 106
16064: PUSH
16065: LD_INT 108
16067: PUSH
16068: EMPTY
16069: LIST
16070: LIST
16071: LIST
16072: LIST
16073: LIST
16074: PUSH
16075: EMPTY
16076: LIST
16077: LIST
16078: ST_TO_ADDR
16079: GO 18858
16081: LD_INT 3
16083: DOUBLE
16084: EQUAL
16085: IFTRUE 16089
16087: GO 16165
16089: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 4 :
16090: LD_ADDR_VAR 0 1
16094: PUSH
16095: LD_INT 2
16097: PUSH
16098: LD_INT 4
16100: PUSH
16101: LD_INT 5
16103: PUSH
16104: LD_INT 11
16106: PUSH
16107: LD_INT 12
16109: PUSH
16110: LD_INT 15
16112: PUSH
16113: LD_INT 16
16115: PUSH
16116: LD_INT 22
16118: PUSH
16119: LD_INT 26
16121: PUSH
16122: LD_INT 36
16124: PUSH
16125: EMPTY
16126: LIST
16127: LIST
16128: LIST
16129: LIST
16130: LIST
16131: LIST
16132: LIST
16133: LIST
16134: LIST
16135: LIST
16136: PUSH
16137: LD_INT 101
16139: PUSH
16140: LD_INT 102
16142: PUSH
16143: LD_INT 105
16145: PUSH
16146: LD_INT 106
16148: PUSH
16149: LD_INT 108
16151: PUSH
16152: EMPTY
16153: LIST
16154: LIST
16155: LIST
16156: LIST
16157: LIST
16158: PUSH
16159: EMPTY
16160: LIST
16161: LIST
16162: ST_TO_ADDR
16163: GO 18858
16165: LD_INT 4
16167: DOUBLE
16168: EQUAL
16169: IFTRUE 16173
16171: GO 16257
16173: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 5 :
16174: LD_ADDR_VAR 0 1
16178: PUSH
16179: LD_INT 2
16181: PUSH
16182: LD_INT 4
16184: PUSH
16185: LD_INT 5
16187: PUSH
16188: LD_INT 8
16190: PUSH
16191: LD_INT 11
16193: PUSH
16194: LD_INT 12
16196: PUSH
16197: LD_INT 15
16199: PUSH
16200: LD_INT 16
16202: PUSH
16203: LD_INT 22
16205: PUSH
16206: LD_INT 23
16208: PUSH
16209: LD_INT 26
16211: PUSH
16212: LD_INT 36
16214: PUSH
16215: EMPTY
16216: LIST
16217: LIST
16218: LIST
16219: LIST
16220: LIST
16221: LIST
16222: LIST
16223: LIST
16224: LIST
16225: LIST
16226: LIST
16227: LIST
16228: PUSH
16229: LD_INT 101
16231: PUSH
16232: LD_INT 102
16234: PUSH
16235: LD_INT 105
16237: PUSH
16238: LD_INT 106
16240: PUSH
16241: LD_INT 108
16243: PUSH
16244: EMPTY
16245: LIST
16246: LIST
16247: LIST
16248: LIST
16249: LIST
16250: PUSH
16251: EMPTY
16252: LIST
16253: LIST
16254: ST_TO_ADDR
16255: GO 18858
16257: LD_INT 5
16259: DOUBLE
16260: EQUAL
16261: IFTRUE 16265
16263: GO 16365
16265: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 6 :
16266: LD_ADDR_VAR 0 1
16270: PUSH
16271: LD_INT 2
16273: PUSH
16274: LD_INT 4
16276: PUSH
16277: LD_INT 5
16279: PUSH
16280: LD_INT 6
16282: PUSH
16283: LD_INT 8
16285: PUSH
16286: LD_INT 11
16288: PUSH
16289: LD_INT 12
16291: PUSH
16292: LD_INT 15
16294: PUSH
16295: LD_INT 16
16297: PUSH
16298: LD_INT 22
16300: PUSH
16301: LD_INT 23
16303: PUSH
16304: LD_INT 25
16306: PUSH
16307: LD_INT 26
16309: PUSH
16310: LD_INT 36
16312: PUSH
16313: EMPTY
16314: LIST
16315: LIST
16316: LIST
16317: LIST
16318: LIST
16319: LIST
16320: LIST
16321: LIST
16322: LIST
16323: LIST
16324: LIST
16325: LIST
16326: LIST
16327: LIST
16328: PUSH
16329: LD_INT 101
16331: PUSH
16332: LD_INT 102
16334: PUSH
16335: LD_INT 105
16337: PUSH
16338: LD_INT 106
16340: PUSH
16341: LD_INT 108
16343: PUSH
16344: LD_INT 109
16346: PUSH
16347: LD_INT 112
16349: PUSH
16350: EMPTY
16351: LIST
16352: LIST
16353: LIST
16354: LIST
16355: LIST
16356: LIST
16357: LIST
16358: PUSH
16359: EMPTY
16360: LIST
16361: LIST
16362: ST_TO_ADDR
16363: GO 18858
16365: LD_INT 6
16367: DOUBLE
16368: EQUAL
16369: IFTRUE 16373
16371: GO 16493
16373: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 7 :
16374: LD_ADDR_VAR 0 1
16378: PUSH
16379: LD_INT 2
16381: PUSH
16382: LD_INT 4
16384: PUSH
16385: LD_INT 5
16387: PUSH
16388: LD_INT 6
16390: PUSH
16391: LD_INT 8
16393: PUSH
16394: LD_INT 11
16396: PUSH
16397: LD_INT 12
16399: PUSH
16400: LD_INT 15
16402: PUSH
16403: LD_INT 16
16405: PUSH
16406: LD_INT 20
16408: PUSH
16409: LD_INT 21
16411: PUSH
16412: LD_INT 22
16414: PUSH
16415: LD_INT 23
16417: PUSH
16418: LD_INT 25
16420: PUSH
16421: LD_INT 26
16423: PUSH
16424: LD_INT 30
16426: PUSH
16427: LD_INT 31
16429: PUSH
16430: LD_INT 32
16432: PUSH
16433: LD_INT 36
16435: PUSH
16436: EMPTY
16437: LIST
16438: LIST
16439: LIST
16440: LIST
16441: LIST
16442: LIST
16443: LIST
16444: LIST
16445: LIST
16446: LIST
16447: LIST
16448: LIST
16449: LIST
16450: LIST
16451: LIST
16452: LIST
16453: LIST
16454: LIST
16455: LIST
16456: PUSH
16457: LD_INT 101
16459: PUSH
16460: LD_INT 102
16462: PUSH
16463: LD_INT 105
16465: PUSH
16466: LD_INT 106
16468: PUSH
16469: LD_INT 108
16471: PUSH
16472: LD_INT 109
16474: PUSH
16475: LD_INT 112
16477: PUSH
16478: EMPTY
16479: LIST
16480: LIST
16481: LIST
16482: LIST
16483: LIST
16484: LIST
16485: LIST
16486: PUSH
16487: EMPTY
16488: LIST
16489: LIST
16490: ST_TO_ADDR
16491: GO 18858
16493: LD_INT 7
16495: DOUBLE
16496: EQUAL
16497: IFTRUE 16501
16499: GO 16601
16501: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 ] ] ; 8 :
16502: LD_ADDR_VAR 0 1
16506: PUSH
16507: LD_INT 2
16509: PUSH
16510: LD_INT 4
16512: PUSH
16513: LD_INT 5
16515: PUSH
16516: LD_INT 7
16518: PUSH
16519: LD_INT 11
16521: PUSH
16522: LD_INT 12
16524: PUSH
16525: LD_INT 15
16527: PUSH
16528: LD_INT 16
16530: PUSH
16531: LD_INT 20
16533: PUSH
16534: LD_INT 21
16536: PUSH
16537: LD_INT 22
16539: PUSH
16540: LD_INT 23
16542: PUSH
16543: LD_INT 25
16545: PUSH
16546: LD_INT 26
16548: PUSH
16549: EMPTY
16550: LIST
16551: LIST
16552: LIST
16553: LIST
16554: LIST
16555: LIST
16556: LIST
16557: LIST
16558: LIST
16559: LIST
16560: LIST
16561: LIST
16562: LIST
16563: LIST
16564: PUSH
16565: LD_INT 101
16567: PUSH
16568: LD_INT 102
16570: PUSH
16571: LD_INT 103
16573: PUSH
16574: LD_INT 105
16576: PUSH
16577: LD_INT 106
16579: PUSH
16580: LD_INT 108
16582: PUSH
16583: LD_INT 112
16585: PUSH
16586: EMPTY
16587: LIST
16588: LIST
16589: LIST
16590: LIST
16591: LIST
16592: LIST
16593: LIST
16594: PUSH
16595: EMPTY
16596: LIST
16597: LIST
16598: ST_TO_ADDR
16599: GO 18858
16601: LD_INT 8
16603: DOUBLE
16604: EQUAL
16605: IFTRUE 16609
16607: GO 16737
16609: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 ] ] ; 9 :
16610: LD_ADDR_VAR 0 1
16614: PUSH
16615: LD_INT 2
16617: PUSH
16618: LD_INT 4
16620: PUSH
16621: LD_INT 5
16623: PUSH
16624: LD_INT 6
16626: PUSH
16627: LD_INT 7
16629: PUSH
16630: LD_INT 8
16632: PUSH
16633: LD_INT 11
16635: PUSH
16636: LD_INT 12
16638: PUSH
16639: LD_INT 15
16641: PUSH
16642: LD_INT 16
16644: PUSH
16645: LD_INT 20
16647: PUSH
16648: LD_INT 21
16650: PUSH
16651: LD_INT 22
16653: PUSH
16654: LD_INT 23
16656: PUSH
16657: LD_INT 25
16659: PUSH
16660: LD_INT 26
16662: PUSH
16663: LD_INT 30
16665: PUSH
16666: LD_INT 31
16668: PUSH
16669: LD_INT 32
16671: PUSH
16672: LD_INT 36
16674: PUSH
16675: EMPTY
16676: LIST
16677: LIST
16678: LIST
16679: LIST
16680: LIST
16681: LIST
16682: LIST
16683: LIST
16684: LIST
16685: LIST
16686: LIST
16687: LIST
16688: LIST
16689: LIST
16690: LIST
16691: LIST
16692: LIST
16693: LIST
16694: LIST
16695: LIST
16696: PUSH
16697: LD_INT 101
16699: PUSH
16700: LD_INT 102
16702: PUSH
16703: LD_INT 103
16705: PUSH
16706: LD_INT 105
16708: PUSH
16709: LD_INT 106
16711: PUSH
16712: LD_INT 108
16714: PUSH
16715: LD_INT 109
16717: PUSH
16718: LD_INT 112
16720: PUSH
16721: EMPTY
16722: LIST
16723: LIST
16724: LIST
16725: LIST
16726: LIST
16727: LIST
16728: LIST
16729: LIST
16730: PUSH
16731: EMPTY
16732: LIST
16733: LIST
16734: ST_TO_ADDR
16735: GO 18858
16737: LD_INT 9
16739: DOUBLE
16740: EQUAL
16741: IFTRUE 16745
16743: GO 16881
16745: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 ] ] ; 10 :
16746: LD_ADDR_VAR 0 1
16750: PUSH
16751: LD_INT 2
16753: PUSH
16754: LD_INT 4
16756: PUSH
16757: LD_INT 5
16759: PUSH
16760: LD_INT 6
16762: PUSH
16763: LD_INT 7
16765: PUSH
16766: LD_INT 8
16768: PUSH
16769: LD_INT 11
16771: PUSH
16772: LD_INT 12
16774: PUSH
16775: LD_INT 15
16777: PUSH
16778: LD_INT 16
16780: PUSH
16781: LD_INT 20
16783: PUSH
16784: LD_INT 21
16786: PUSH
16787: LD_INT 22
16789: PUSH
16790: LD_INT 23
16792: PUSH
16793: LD_INT 25
16795: PUSH
16796: LD_INT 26
16798: PUSH
16799: LD_INT 28
16801: PUSH
16802: LD_INT 30
16804: PUSH
16805: LD_INT 31
16807: PUSH
16808: LD_INT 32
16810: PUSH
16811: LD_INT 36
16813: PUSH
16814: EMPTY
16815: LIST
16816: LIST
16817: LIST
16818: LIST
16819: LIST
16820: LIST
16821: LIST
16822: LIST
16823: LIST
16824: LIST
16825: LIST
16826: LIST
16827: LIST
16828: LIST
16829: LIST
16830: LIST
16831: LIST
16832: LIST
16833: LIST
16834: LIST
16835: LIST
16836: PUSH
16837: LD_INT 101
16839: PUSH
16840: LD_INT 102
16842: PUSH
16843: LD_INT 103
16845: PUSH
16846: LD_INT 105
16848: PUSH
16849: LD_INT 106
16851: PUSH
16852: LD_INT 108
16854: PUSH
16855: LD_INT 109
16857: PUSH
16858: LD_INT 112
16860: PUSH
16861: LD_INT 114
16863: PUSH
16864: EMPTY
16865: LIST
16866: LIST
16867: LIST
16868: LIST
16869: LIST
16870: LIST
16871: LIST
16872: LIST
16873: LIST
16874: PUSH
16875: EMPTY
16876: LIST
16877: LIST
16878: ST_TO_ADDR
16879: GO 18858
16881: LD_INT 10
16883: DOUBLE
16884: EQUAL
16885: IFTRUE 16889
16887: GO 17073
16889: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 11 :
16890: LD_ADDR_VAR 0 1
16894: PUSH
16895: LD_INT 2
16897: PUSH
16898: LD_INT 4
16900: PUSH
16901: LD_INT 5
16903: PUSH
16904: LD_INT 6
16906: PUSH
16907: LD_INT 7
16909: PUSH
16910: LD_INT 8
16912: PUSH
16913: LD_INT 9
16915: PUSH
16916: LD_INT 10
16918: PUSH
16919: LD_INT 11
16921: PUSH
16922: LD_INT 12
16924: PUSH
16925: LD_INT 13
16927: PUSH
16928: LD_INT 14
16930: PUSH
16931: LD_INT 15
16933: PUSH
16934: LD_INT 16
16936: PUSH
16937: LD_INT 17
16939: PUSH
16940: LD_INT 18
16942: PUSH
16943: LD_INT 19
16945: PUSH
16946: LD_INT 20
16948: PUSH
16949: LD_INT 21
16951: PUSH
16952: LD_INT 22
16954: PUSH
16955: LD_INT 23
16957: PUSH
16958: LD_INT 24
16960: PUSH
16961: LD_INT 25
16963: PUSH
16964: LD_INT 26
16966: PUSH
16967: LD_INT 28
16969: PUSH
16970: LD_INT 30
16972: PUSH
16973: LD_INT 31
16975: PUSH
16976: LD_INT 32
16978: PUSH
16979: LD_INT 36
16981: PUSH
16982: EMPTY
16983: LIST
16984: LIST
16985: LIST
16986: LIST
16987: LIST
16988: LIST
16989: LIST
16990: LIST
16991: LIST
16992: LIST
16993: LIST
16994: LIST
16995: LIST
16996: LIST
16997: LIST
16998: LIST
16999: LIST
17000: LIST
17001: LIST
17002: LIST
17003: LIST
17004: LIST
17005: LIST
17006: LIST
17007: LIST
17008: LIST
17009: LIST
17010: LIST
17011: LIST
17012: PUSH
17013: LD_INT 101
17015: PUSH
17016: LD_INT 102
17018: PUSH
17019: LD_INT 103
17021: PUSH
17022: LD_INT 104
17024: PUSH
17025: LD_INT 105
17027: PUSH
17028: LD_INT 106
17030: PUSH
17031: LD_INT 107
17033: PUSH
17034: LD_INT 108
17036: PUSH
17037: LD_INT 109
17039: PUSH
17040: LD_INT 110
17042: PUSH
17043: LD_INT 111
17045: PUSH
17046: LD_INT 112
17048: PUSH
17049: LD_INT 114
17051: PUSH
17052: EMPTY
17053: LIST
17054: LIST
17055: LIST
17056: LIST
17057: LIST
17058: LIST
17059: LIST
17060: LIST
17061: LIST
17062: LIST
17063: LIST
17064: LIST
17065: LIST
17066: PUSH
17067: EMPTY
17068: LIST
17069: LIST
17070: ST_TO_ADDR
17071: GO 18858
17073: LD_INT 11
17075: DOUBLE
17076: EQUAL
17077: IFTRUE 17081
17079: GO 17273
17081: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 12 :
17082: LD_ADDR_VAR 0 1
17086: PUSH
17087: LD_INT 2
17089: PUSH
17090: LD_INT 3
17092: PUSH
17093: LD_INT 4
17095: PUSH
17096: LD_INT 5
17098: PUSH
17099: LD_INT 6
17101: PUSH
17102: LD_INT 7
17104: PUSH
17105: LD_INT 8
17107: PUSH
17108: LD_INT 9
17110: PUSH
17111: LD_INT 10
17113: PUSH
17114: LD_INT 11
17116: PUSH
17117: LD_INT 12
17119: PUSH
17120: LD_INT 13
17122: PUSH
17123: LD_INT 14
17125: PUSH
17126: LD_INT 15
17128: PUSH
17129: LD_INT 16
17131: PUSH
17132: LD_INT 17
17134: PUSH
17135: LD_INT 18
17137: PUSH
17138: LD_INT 19
17140: PUSH
17141: LD_INT 20
17143: PUSH
17144: LD_INT 21
17146: PUSH
17147: LD_INT 22
17149: PUSH
17150: LD_INT 23
17152: PUSH
17153: LD_INT 24
17155: PUSH
17156: LD_INT 25
17158: PUSH
17159: LD_INT 26
17161: PUSH
17162: LD_INT 28
17164: PUSH
17165: LD_INT 30
17167: PUSH
17168: LD_INT 31
17170: PUSH
17171: LD_INT 32
17173: PUSH
17174: LD_INT 34
17176: PUSH
17177: LD_INT 36
17179: PUSH
17180: EMPTY
17181: LIST
17182: LIST
17183: LIST
17184: LIST
17185: LIST
17186: LIST
17187: LIST
17188: LIST
17189: LIST
17190: LIST
17191: LIST
17192: LIST
17193: LIST
17194: LIST
17195: LIST
17196: LIST
17197: LIST
17198: LIST
17199: LIST
17200: LIST
17201: LIST
17202: LIST
17203: LIST
17204: LIST
17205: LIST
17206: LIST
17207: LIST
17208: LIST
17209: LIST
17210: LIST
17211: LIST
17212: PUSH
17213: LD_INT 101
17215: PUSH
17216: LD_INT 102
17218: PUSH
17219: LD_INT 103
17221: PUSH
17222: LD_INT 104
17224: PUSH
17225: LD_INT 105
17227: PUSH
17228: LD_INT 106
17230: PUSH
17231: LD_INT 107
17233: PUSH
17234: LD_INT 108
17236: PUSH
17237: LD_INT 109
17239: PUSH
17240: LD_INT 110
17242: PUSH
17243: LD_INT 111
17245: PUSH
17246: LD_INT 112
17248: PUSH
17249: LD_INT 114
17251: PUSH
17252: EMPTY
17253: LIST
17254: LIST
17255: LIST
17256: LIST
17257: LIST
17258: LIST
17259: LIST
17260: LIST
17261: LIST
17262: LIST
17263: LIST
17264: LIST
17265: LIST
17266: PUSH
17267: EMPTY
17268: LIST
17269: LIST
17270: ST_TO_ADDR
17271: GO 18858
17273: LD_INT 12
17275: DOUBLE
17276: EQUAL
17277: IFTRUE 17281
17279: GO 17489
17281: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 13 :
17282: LD_ADDR_VAR 0 1
17286: PUSH
17287: LD_INT 1
17289: PUSH
17290: LD_INT 2
17292: PUSH
17293: LD_INT 3
17295: PUSH
17296: LD_INT 4
17298: PUSH
17299: LD_INT 5
17301: PUSH
17302: LD_INT 6
17304: PUSH
17305: LD_INT 7
17307: PUSH
17308: LD_INT 8
17310: PUSH
17311: LD_INT 9
17313: PUSH
17314: LD_INT 10
17316: PUSH
17317: LD_INT 11
17319: PUSH
17320: LD_INT 12
17322: PUSH
17323: LD_INT 13
17325: PUSH
17326: LD_INT 14
17328: PUSH
17329: LD_INT 15
17331: PUSH
17332: LD_INT 16
17334: PUSH
17335: LD_INT 17
17337: PUSH
17338: LD_INT 18
17340: PUSH
17341: LD_INT 19
17343: PUSH
17344: LD_INT 20
17346: PUSH
17347: LD_INT 21
17349: PUSH
17350: LD_INT 22
17352: PUSH
17353: LD_INT 23
17355: PUSH
17356: LD_INT 24
17358: PUSH
17359: LD_INT 25
17361: PUSH
17362: LD_INT 26
17364: PUSH
17365: LD_INT 27
17367: PUSH
17368: LD_INT 28
17370: PUSH
17371: LD_INT 30
17373: PUSH
17374: LD_INT 31
17376: PUSH
17377: LD_INT 32
17379: PUSH
17380: LD_INT 33
17382: PUSH
17383: LD_INT 34
17385: PUSH
17386: LD_INT 36
17388: PUSH
17389: EMPTY
17390: LIST
17391: LIST
17392: LIST
17393: LIST
17394: LIST
17395: LIST
17396: LIST
17397: LIST
17398: LIST
17399: LIST
17400: LIST
17401: LIST
17402: LIST
17403: LIST
17404: LIST
17405: LIST
17406: LIST
17407: LIST
17408: LIST
17409: LIST
17410: LIST
17411: LIST
17412: LIST
17413: LIST
17414: LIST
17415: LIST
17416: LIST
17417: LIST
17418: LIST
17419: LIST
17420: LIST
17421: LIST
17422: LIST
17423: LIST
17424: PUSH
17425: LD_INT 101
17427: PUSH
17428: LD_INT 102
17430: PUSH
17431: LD_INT 103
17433: PUSH
17434: LD_INT 104
17436: PUSH
17437: LD_INT 105
17439: PUSH
17440: LD_INT 106
17442: PUSH
17443: LD_INT 107
17445: PUSH
17446: LD_INT 108
17448: PUSH
17449: LD_INT 109
17451: PUSH
17452: LD_INT 110
17454: PUSH
17455: LD_INT 111
17457: PUSH
17458: LD_INT 112
17460: PUSH
17461: LD_INT 113
17463: PUSH
17464: LD_INT 114
17466: PUSH
17467: EMPTY
17468: LIST
17469: LIST
17470: LIST
17471: LIST
17472: LIST
17473: LIST
17474: LIST
17475: LIST
17476: LIST
17477: LIST
17478: LIST
17479: LIST
17480: LIST
17481: LIST
17482: PUSH
17483: EMPTY
17484: LIST
17485: LIST
17486: ST_TO_ADDR
17487: GO 18858
17489: LD_INT 13
17491: DOUBLE
17492: EQUAL
17493: IFTRUE 17497
17495: GO 17693
17497: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 14 :
17498: LD_ADDR_VAR 0 1
17502: PUSH
17503: LD_INT 1
17505: PUSH
17506: LD_INT 2
17508: PUSH
17509: LD_INT 3
17511: PUSH
17512: LD_INT 4
17514: PUSH
17515: LD_INT 5
17517: PUSH
17518: LD_INT 8
17520: PUSH
17521: LD_INT 9
17523: PUSH
17524: LD_INT 10
17526: PUSH
17527: LD_INT 11
17529: PUSH
17530: LD_INT 12
17532: PUSH
17533: LD_INT 14
17535: PUSH
17536: LD_INT 15
17538: PUSH
17539: LD_INT 16
17541: PUSH
17542: LD_INT 17
17544: PUSH
17545: LD_INT 18
17547: PUSH
17548: LD_INT 19
17550: PUSH
17551: LD_INT 20
17553: PUSH
17554: LD_INT 21
17556: PUSH
17557: LD_INT 22
17559: PUSH
17560: LD_INT 23
17562: PUSH
17563: LD_INT 24
17565: PUSH
17566: LD_INT 25
17568: PUSH
17569: LD_INT 26
17571: PUSH
17572: LD_INT 27
17574: PUSH
17575: LD_INT 28
17577: PUSH
17578: LD_INT 30
17580: PUSH
17581: LD_INT 31
17583: PUSH
17584: LD_INT 32
17586: PUSH
17587: LD_INT 33
17589: PUSH
17590: LD_INT 34
17592: PUSH
17593: LD_INT 36
17595: PUSH
17596: EMPTY
17597: LIST
17598: LIST
17599: LIST
17600: LIST
17601: LIST
17602: LIST
17603: LIST
17604: LIST
17605: LIST
17606: LIST
17607: LIST
17608: LIST
17609: LIST
17610: LIST
17611: LIST
17612: LIST
17613: LIST
17614: LIST
17615: LIST
17616: LIST
17617: LIST
17618: LIST
17619: LIST
17620: LIST
17621: LIST
17622: LIST
17623: LIST
17624: LIST
17625: LIST
17626: LIST
17627: LIST
17628: PUSH
17629: LD_INT 101
17631: PUSH
17632: LD_INT 102
17634: PUSH
17635: LD_INT 103
17637: PUSH
17638: LD_INT 104
17640: PUSH
17641: LD_INT 105
17643: PUSH
17644: LD_INT 106
17646: PUSH
17647: LD_INT 107
17649: PUSH
17650: LD_INT 108
17652: PUSH
17653: LD_INT 109
17655: PUSH
17656: LD_INT 110
17658: PUSH
17659: LD_INT 111
17661: PUSH
17662: LD_INT 112
17664: PUSH
17665: LD_INT 113
17667: PUSH
17668: LD_INT 114
17670: PUSH
17671: EMPTY
17672: LIST
17673: LIST
17674: LIST
17675: LIST
17676: LIST
17677: LIST
17678: LIST
17679: LIST
17680: LIST
17681: LIST
17682: LIST
17683: LIST
17684: LIST
17685: LIST
17686: PUSH
17687: EMPTY
17688: LIST
17689: LIST
17690: ST_TO_ADDR
17691: GO 18858
17693: LD_INT 14
17695: DOUBLE
17696: EQUAL
17697: IFTRUE 17701
17699: GO 17913
17701: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 15 :
17702: LD_ADDR_VAR 0 1
17706: PUSH
17707: LD_INT 1
17709: PUSH
17710: LD_INT 2
17712: PUSH
17713: LD_INT 3
17715: PUSH
17716: LD_INT 4
17718: PUSH
17719: LD_INT 5
17721: PUSH
17722: LD_INT 6
17724: PUSH
17725: LD_INT 7
17727: PUSH
17728: LD_INT 8
17730: PUSH
17731: LD_INT 9
17733: PUSH
17734: LD_INT 10
17736: PUSH
17737: LD_INT 11
17739: PUSH
17740: LD_INT 12
17742: PUSH
17743: LD_INT 13
17745: PUSH
17746: LD_INT 14
17748: PUSH
17749: LD_INT 15
17751: PUSH
17752: LD_INT 16
17754: PUSH
17755: LD_INT 17
17757: PUSH
17758: LD_INT 18
17760: PUSH
17761: LD_INT 19
17763: PUSH
17764: LD_INT 20
17766: PUSH
17767: LD_INT 21
17769: PUSH
17770: LD_INT 22
17772: PUSH
17773: LD_INT 23
17775: PUSH
17776: LD_INT 24
17778: PUSH
17779: LD_INT 25
17781: PUSH
17782: LD_INT 26
17784: PUSH
17785: LD_INT 27
17787: PUSH
17788: LD_INT 28
17790: PUSH
17791: LD_INT 29
17793: PUSH
17794: LD_INT 30
17796: PUSH
17797: LD_INT 31
17799: PUSH
17800: LD_INT 32
17802: PUSH
17803: LD_INT 33
17805: PUSH
17806: LD_INT 34
17808: PUSH
17809: LD_INT 36
17811: PUSH
17812: EMPTY
17813: LIST
17814: LIST
17815: LIST
17816: LIST
17817: LIST
17818: LIST
17819: LIST
17820: LIST
17821: LIST
17822: LIST
17823: LIST
17824: LIST
17825: LIST
17826: LIST
17827: LIST
17828: LIST
17829: LIST
17830: LIST
17831: LIST
17832: LIST
17833: LIST
17834: LIST
17835: LIST
17836: LIST
17837: LIST
17838: LIST
17839: LIST
17840: LIST
17841: LIST
17842: LIST
17843: LIST
17844: LIST
17845: LIST
17846: LIST
17847: LIST
17848: PUSH
17849: LD_INT 101
17851: PUSH
17852: LD_INT 102
17854: PUSH
17855: LD_INT 103
17857: PUSH
17858: LD_INT 104
17860: PUSH
17861: LD_INT 105
17863: PUSH
17864: LD_INT 106
17866: PUSH
17867: LD_INT 107
17869: PUSH
17870: LD_INT 108
17872: PUSH
17873: LD_INT 109
17875: PUSH
17876: LD_INT 110
17878: PUSH
17879: LD_INT 111
17881: PUSH
17882: LD_INT 112
17884: PUSH
17885: LD_INT 113
17887: PUSH
17888: LD_INT 114
17890: PUSH
17891: EMPTY
17892: LIST
17893: LIST
17894: LIST
17895: LIST
17896: LIST
17897: LIST
17898: LIST
17899: LIST
17900: LIST
17901: LIST
17902: LIST
17903: LIST
17904: LIST
17905: LIST
17906: PUSH
17907: EMPTY
17908: LIST
17909: LIST
17910: ST_TO_ADDR
17911: GO 18858
17913: LD_INT 15
17915: DOUBLE
17916: EQUAL
17917: IFTRUE 17921
17919: GO 18133
17921: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 16 :
17922: LD_ADDR_VAR 0 1
17926: PUSH
17927: LD_INT 1
17929: PUSH
17930: LD_INT 2
17932: PUSH
17933: LD_INT 3
17935: PUSH
17936: LD_INT 4
17938: PUSH
17939: LD_INT 5
17941: PUSH
17942: LD_INT 6
17944: PUSH
17945: LD_INT 7
17947: PUSH
17948: LD_INT 8
17950: PUSH
17951: LD_INT 9
17953: PUSH
17954: LD_INT 10
17956: PUSH
17957: LD_INT 11
17959: PUSH
17960: LD_INT 12
17962: PUSH
17963: LD_INT 13
17965: PUSH
17966: LD_INT 14
17968: PUSH
17969: LD_INT 15
17971: PUSH
17972: LD_INT 16
17974: PUSH
17975: LD_INT 17
17977: PUSH
17978: LD_INT 18
17980: PUSH
17981: LD_INT 19
17983: PUSH
17984: LD_INT 20
17986: PUSH
17987: LD_INT 21
17989: PUSH
17990: LD_INT 22
17992: PUSH
17993: LD_INT 23
17995: PUSH
17996: LD_INT 24
17998: PUSH
17999: LD_INT 25
18001: PUSH
18002: LD_INT 26
18004: PUSH
18005: LD_INT 27
18007: PUSH
18008: LD_INT 28
18010: PUSH
18011: LD_INT 29
18013: PUSH
18014: LD_INT 30
18016: PUSH
18017: LD_INT 31
18019: PUSH
18020: LD_INT 32
18022: PUSH
18023: LD_INT 33
18025: PUSH
18026: LD_INT 34
18028: PUSH
18029: LD_INT 36
18031: PUSH
18032: EMPTY
18033: LIST
18034: LIST
18035: LIST
18036: LIST
18037: LIST
18038: LIST
18039: LIST
18040: LIST
18041: LIST
18042: LIST
18043: LIST
18044: LIST
18045: LIST
18046: LIST
18047: LIST
18048: LIST
18049: LIST
18050: LIST
18051: LIST
18052: LIST
18053: LIST
18054: LIST
18055: LIST
18056: LIST
18057: LIST
18058: LIST
18059: LIST
18060: LIST
18061: LIST
18062: LIST
18063: LIST
18064: LIST
18065: LIST
18066: LIST
18067: LIST
18068: PUSH
18069: LD_INT 101
18071: PUSH
18072: LD_INT 102
18074: PUSH
18075: LD_INT 103
18077: PUSH
18078: LD_INT 104
18080: PUSH
18081: LD_INT 105
18083: PUSH
18084: LD_INT 106
18086: PUSH
18087: LD_INT 107
18089: PUSH
18090: LD_INT 108
18092: PUSH
18093: LD_INT 109
18095: PUSH
18096: LD_INT 110
18098: PUSH
18099: LD_INT 111
18101: PUSH
18102: LD_INT 112
18104: PUSH
18105: LD_INT 113
18107: PUSH
18108: LD_INT 114
18110: PUSH
18111: EMPTY
18112: LIST
18113: LIST
18114: LIST
18115: LIST
18116: LIST
18117: LIST
18118: LIST
18119: LIST
18120: LIST
18121: LIST
18122: LIST
18123: LIST
18124: LIST
18125: LIST
18126: PUSH
18127: EMPTY
18128: LIST
18129: LIST
18130: ST_TO_ADDR
18131: GO 18858
18133: LD_INT 16
18135: DOUBLE
18136: EQUAL
18137: IFTRUE 18141
18139: GO 18265
18141: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 ] ] ; 17 :
18142: LD_ADDR_VAR 0 1
18146: PUSH
18147: LD_INT 2
18149: PUSH
18150: LD_INT 4
18152: PUSH
18153: LD_INT 5
18155: PUSH
18156: LD_INT 7
18158: PUSH
18159: LD_INT 11
18161: PUSH
18162: LD_INT 12
18164: PUSH
18165: LD_INT 15
18167: PUSH
18168: LD_INT 16
18170: PUSH
18171: LD_INT 20
18173: PUSH
18174: LD_INT 21
18176: PUSH
18177: LD_INT 22
18179: PUSH
18180: LD_INT 23
18182: PUSH
18183: LD_INT 25
18185: PUSH
18186: LD_INT 26
18188: PUSH
18189: LD_INT 30
18191: PUSH
18192: LD_INT 31
18194: PUSH
18195: LD_INT 32
18197: PUSH
18198: LD_INT 33
18200: PUSH
18201: LD_INT 34
18203: PUSH
18204: EMPTY
18205: LIST
18206: LIST
18207: LIST
18208: LIST
18209: LIST
18210: LIST
18211: LIST
18212: LIST
18213: LIST
18214: LIST
18215: LIST
18216: LIST
18217: LIST
18218: LIST
18219: LIST
18220: LIST
18221: LIST
18222: LIST
18223: LIST
18224: PUSH
18225: LD_INT 101
18227: PUSH
18228: LD_INT 102
18230: PUSH
18231: LD_INT 103
18233: PUSH
18234: LD_INT 106
18236: PUSH
18237: LD_INT 108
18239: PUSH
18240: LD_INT 112
18242: PUSH
18243: LD_INT 113
18245: PUSH
18246: LD_INT 114
18248: PUSH
18249: EMPTY
18250: LIST
18251: LIST
18252: LIST
18253: LIST
18254: LIST
18255: LIST
18256: LIST
18257: LIST
18258: PUSH
18259: EMPTY
18260: LIST
18261: LIST
18262: ST_TO_ADDR
18263: GO 18858
18265: LD_INT 17
18267: DOUBLE
18268: EQUAL
18269: IFTRUE 18273
18271: GO 18485
18273: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 18 :
18274: LD_ADDR_VAR 0 1
18278: PUSH
18279: LD_INT 1
18281: PUSH
18282: LD_INT 2
18284: PUSH
18285: LD_INT 3
18287: PUSH
18288: LD_INT 4
18290: PUSH
18291: LD_INT 5
18293: PUSH
18294: LD_INT 6
18296: PUSH
18297: LD_INT 7
18299: PUSH
18300: LD_INT 8
18302: PUSH
18303: LD_INT 9
18305: PUSH
18306: LD_INT 10
18308: PUSH
18309: LD_INT 11
18311: PUSH
18312: LD_INT 12
18314: PUSH
18315: LD_INT 13
18317: PUSH
18318: LD_INT 14
18320: PUSH
18321: LD_INT 15
18323: PUSH
18324: LD_INT 16
18326: PUSH
18327: LD_INT 17
18329: PUSH
18330: LD_INT 18
18332: PUSH
18333: LD_INT 19
18335: PUSH
18336: LD_INT 20
18338: PUSH
18339: LD_INT 21
18341: PUSH
18342: LD_INT 22
18344: PUSH
18345: LD_INT 23
18347: PUSH
18348: LD_INT 24
18350: PUSH
18351: LD_INT 25
18353: PUSH
18354: LD_INT 26
18356: PUSH
18357: LD_INT 27
18359: PUSH
18360: LD_INT 28
18362: PUSH
18363: LD_INT 29
18365: PUSH
18366: LD_INT 30
18368: PUSH
18369: LD_INT 31
18371: PUSH
18372: LD_INT 32
18374: PUSH
18375: LD_INT 33
18377: PUSH
18378: LD_INT 34
18380: PUSH
18381: LD_INT 36
18383: PUSH
18384: EMPTY
18385: LIST
18386: LIST
18387: LIST
18388: LIST
18389: LIST
18390: LIST
18391: LIST
18392: LIST
18393: LIST
18394: LIST
18395: LIST
18396: LIST
18397: LIST
18398: LIST
18399: LIST
18400: LIST
18401: LIST
18402: LIST
18403: LIST
18404: LIST
18405: LIST
18406: LIST
18407: LIST
18408: LIST
18409: LIST
18410: LIST
18411: LIST
18412: LIST
18413: LIST
18414: LIST
18415: LIST
18416: LIST
18417: LIST
18418: LIST
18419: LIST
18420: PUSH
18421: LD_INT 101
18423: PUSH
18424: LD_INT 102
18426: PUSH
18427: LD_INT 103
18429: PUSH
18430: LD_INT 104
18432: PUSH
18433: LD_INT 105
18435: PUSH
18436: LD_INT 106
18438: PUSH
18439: LD_INT 107
18441: PUSH
18442: LD_INT 108
18444: PUSH
18445: LD_INT 109
18447: PUSH
18448: LD_INT 110
18450: PUSH
18451: LD_INT 111
18453: PUSH
18454: LD_INT 112
18456: PUSH
18457: LD_INT 113
18459: PUSH
18460: LD_INT 114
18462: PUSH
18463: EMPTY
18464: LIST
18465: LIST
18466: LIST
18467: LIST
18468: LIST
18469: LIST
18470: LIST
18471: LIST
18472: LIST
18473: LIST
18474: LIST
18475: LIST
18476: LIST
18477: LIST
18478: PUSH
18479: EMPTY
18480: LIST
18481: LIST
18482: ST_TO_ADDR
18483: GO 18858
18485: LD_INT 18
18487: DOUBLE
18488: EQUAL
18489: IFTRUE 18493
18491: GO 18629
18493: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 ] ] ; 19 :
18494: LD_ADDR_VAR 0 1
18498: PUSH
18499: LD_INT 2
18501: PUSH
18502: LD_INT 4
18504: PUSH
18505: LD_INT 5
18507: PUSH
18508: LD_INT 7
18510: PUSH
18511: LD_INT 11
18513: PUSH
18514: LD_INT 12
18516: PUSH
18517: LD_INT 15
18519: PUSH
18520: LD_INT 16
18522: PUSH
18523: LD_INT 20
18525: PUSH
18526: LD_INT 21
18528: PUSH
18529: LD_INT 22
18531: PUSH
18532: LD_INT 23
18534: PUSH
18535: LD_INT 25
18537: PUSH
18538: LD_INT 26
18540: PUSH
18541: LD_INT 30
18543: PUSH
18544: LD_INT 31
18546: PUSH
18547: LD_INT 32
18549: PUSH
18550: LD_INT 33
18552: PUSH
18553: LD_INT 34
18555: PUSH
18556: LD_INT 35
18558: PUSH
18559: LD_INT 36
18561: PUSH
18562: EMPTY
18563: LIST
18564: LIST
18565: LIST
18566: LIST
18567: LIST
18568: LIST
18569: LIST
18570: LIST
18571: LIST
18572: LIST
18573: LIST
18574: LIST
18575: LIST
18576: LIST
18577: LIST
18578: LIST
18579: LIST
18580: LIST
18581: LIST
18582: LIST
18583: LIST
18584: PUSH
18585: LD_INT 101
18587: PUSH
18588: LD_INT 102
18590: PUSH
18591: LD_INT 103
18593: PUSH
18594: LD_INT 106
18596: PUSH
18597: LD_INT 108
18599: PUSH
18600: LD_INT 112
18602: PUSH
18603: LD_INT 113
18605: PUSH
18606: LD_INT 114
18608: PUSH
18609: LD_INT 115
18611: PUSH
18612: EMPTY
18613: LIST
18614: LIST
18615: LIST
18616: LIST
18617: LIST
18618: LIST
18619: LIST
18620: LIST
18621: LIST
18622: PUSH
18623: EMPTY
18624: LIST
18625: LIST
18626: ST_TO_ADDR
18627: GO 18858
18629: LD_INT 19
18631: DOUBLE
18632: EQUAL
18633: IFTRUE 18637
18635: GO 18857
18637: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ; end ;
18638: LD_ADDR_VAR 0 1
18642: PUSH
18643: LD_INT 1
18645: PUSH
18646: LD_INT 2
18648: PUSH
18649: LD_INT 3
18651: PUSH
18652: LD_INT 4
18654: PUSH
18655: LD_INT 5
18657: PUSH
18658: LD_INT 6
18660: PUSH
18661: LD_INT 7
18663: PUSH
18664: LD_INT 8
18666: PUSH
18667: LD_INT 9
18669: PUSH
18670: LD_INT 10
18672: PUSH
18673: LD_INT 11
18675: PUSH
18676: LD_INT 12
18678: PUSH
18679: LD_INT 13
18681: PUSH
18682: LD_INT 14
18684: PUSH
18685: LD_INT 15
18687: PUSH
18688: LD_INT 16
18690: PUSH
18691: LD_INT 17
18693: PUSH
18694: LD_INT 18
18696: PUSH
18697: LD_INT 19
18699: PUSH
18700: LD_INT 20
18702: PUSH
18703: LD_INT 21
18705: PUSH
18706: LD_INT 22
18708: PUSH
18709: LD_INT 23
18711: PUSH
18712: LD_INT 24
18714: PUSH
18715: LD_INT 25
18717: PUSH
18718: LD_INT 26
18720: PUSH
18721: LD_INT 27
18723: PUSH
18724: LD_INT 28
18726: PUSH
18727: LD_INT 29
18729: PUSH
18730: LD_INT 30
18732: PUSH
18733: LD_INT 31
18735: PUSH
18736: LD_INT 32
18738: PUSH
18739: LD_INT 33
18741: PUSH
18742: LD_INT 34
18744: PUSH
18745: LD_INT 35
18747: PUSH
18748: LD_INT 36
18750: PUSH
18751: EMPTY
18752: LIST
18753: LIST
18754: LIST
18755: LIST
18756: LIST
18757: LIST
18758: LIST
18759: LIST
18760: LIST
18761: LIST
18762: LIST
18763: LIST
18764: LIST
18765: LIST
18766: LIST
18767: LIST
18768: LIST
18769: LIST
18770: LIST
18771: LIST
18772: LIST
18773: LIST
18774: LIST
18775: LIST
18776: LIST
18777: LIST
18778: LIST
18779: LIST
18780: LIST
18781: LIST
18782: LIST
18783: LIST
18784: LIST
18785: LIST
18786: LIST
18787: LIST
18788: PUSH
18789: LD_INT 101
18791: PUSH
18792: LD_INT 102
18794: PUSH
18795: LD_INT 103
18797: PUSH
18798: LD_INT 104
18800: PUSH
18801: LD_INT 105
18803: PUSH
18804: LD_INT 106
18806: PUSH
18807: LD_INT 107
18809: PUSH
18810: LD_INT 108
18812: PUSH
18813: LD_INT 109
18815: PUSH
18816: LD_INT 110
18818: PUSH
18819: LD_INT 111
18821: PUSH
18822: LD_INT 112
18824: PUSH
18825: LD_INT 113
18827: PUSH
18828: LD_INT 114
18830: PUSH
18831: LD_INT 115
18833: PUSH
18834: EMPTY
18835: LIST
18836: LIST
18837: LIST
18838: LIST
18839: LIST
18840: LIST
18841: LIST
18842: LIST
18843: LIST
18844: LIST
18845: LIST
18846: LIST
18847: LIST
18848: LIST
18849: LIST
18850: PUSH
18851: EMPTY
18852: LIST
18853: LIST
18854: ST_TO_ADDR
18855: GO 18858
18857: POP
// end else
18858: GO 19077
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ;
18860: LD_ADDR_VAR 0 1
18864: PUSH
18865: LD_INT 1
18867: PUSH
18868: LD_INT 2
18870: PUSH
18871: LD_INT 3
18873: PUSH
18874: LD_INT 4
18876: PUSH
18877: LD_INT 5
18879: PUSH
18880: LD_INT 6
18882: PUSH
18883: LD_INT 7
18885: PUSH
18886: LD_INT 8
18888: PUSH
18889: LD_INT 9
18891: PUSH
18892: LD_INT 10
18894: PUSH
18895: LD_INT 11
18897: PUSH
18898: LD_INT 12
18900: PUSH
18901: LD_INT 13
18903: PUSH
18904: LD_INT 14
18906: PUSH
18907: LD_INT 15
18909: PUSH
18910: LD_INT 16
18912: PUSH
18913: LD_INT 17
18915: PUSH
18916: LD_INT 18
18918: PUSH
18919: LD_INT 19
18921: PUSH
18922: LD_INT 20
18924: PUSH
18925: LD_INT 21
18927: PUSH
18928: LD_INT 22
18930: PUSH
18931: LD_INT 23
18933: PUSH
18934: LD_INT 24
18936: PUSH
18937: LD_INT 25
18939: PUSH
18940: LD_INT 26
18942: PUSH
18943: LD_INT 27
18945: PUSH
18946: LD_INT 28
18948: PUSH
18949: LD_INT 29
18951: PUSH
18952: LD_INT 30
18954: PUSH
18955: LD_INT 31
18957: PUSH
18958: LD_INT 32
18960: PUSH
18961: LD_INT 33
18963: PUSH
18964: LD_INT 34
18966: PUSH
18967: LD_INT 35
18969: PUSH
18970: LD_INT 36
18972: PUSH
18973: EMPTY
18974: LIST
18975: LIST
18976: LIST
18977: LIST
18978: LIST
18979: LIST
18980: LIST
18981: LIST
18982: LIST
18983: LIST
18984: LIST
18985: LIST
18986: LIST
18987: LIST
18988: LIST
18989: LIST
18990: LIST
18991: LIST
18992: LIST
18993: LIST
18994: LIST
18995: LIST
18996: LIST
18997: LIST
18998: LIST
18999: LIST
19000: LIST
19001: LIST
19002: LIST
19003: LIST
19004: LIST
19005: LIST
19006: LIST
19007: LIST
19008: LIST
19009: LIST
19010: PUSH
19011: LD_INT 101
19013: PUSH
19014: LD_INT 102
19016: PUSH
19017: LD_INT 103
19019: PUSH
19020: LD_INT 104
19022: PUSH
19023: LD_INT 105
19025: PUSH
19026: LD_INT 106
19028: PUSH
19029: LD_INT 107
19031: PUSH
19032: LD_INT 108
19034: PUSH
19035: LD_INT 109
19037: PUSH
19038: LD_INT 110
19040: PUSH
19041: LD_INT 111
19043: PUSH
19044: LD_INT 112
19046: PUSH
19047: LD_INT 113
19049: PUSH
19050: LD_INT 114
19052: PUSH
19053: LD_INT 115
19055: PUSH
19056: EMPTY
19057: LIST
19058: LIST
19059: LIST
19060: LIST
19061: LIST
19062: LIST
19063: LIST
19064: LIST
19065: LIST
19066: LIST
19067: LIST
19068: LIST
19069: LIST
19070: LIST
19071: LIST
19072: PUSH
19073: EMPTY
19074: LIST
19075: LIST
19076: ST_TO_ADDR
// if result then
19077: LD_VAR 0 1
19081: IFFALSE 19370
// begin normal :=  ;
19083: LD_ADDR_VAR 0 3
19087: PUSH
19088: LD_STRING 
19090: ST_TO_ADDR
// hardcore :=  ;
19091: LD_ADDR_VAR 0 4
19095: PUSH
19096: LD_STRING 
19098: ST_TO_ADDR
// for i = 1 to normalCounter do
19099: LD_ADDR_VAR 0 5
19103: PUSH
19104: DOUBLE
19105: LD_INT 1
19107: DEC
19108: ST_TO_ADDR
19109: LD_EXP 58
19113: PUSH
19114: FOR_TO
19115: IFFALSE 19216
// begin tmp := 0 ;
19117: LD_ADDR_VAR 0 2
19121: PUSH
19122: LD_STRING 0
19124: ST_TO_ADDR
// if result [ 1 ] then
19125: LD_VAR 0 1
19129: PUSH
19130: LD_INT 1
19132: ARRAY
19133: IFFALSE 19198
// if result [ 1 ] [ 1 ] = i then
19135: LD_VAR 0 1
19139: PUSH
19140: LD_INT 1
19142: ARRAY
19143: PUSH
19144: LD_INT 1
19146: ARRAY
19147: PUSH
19148: LD_VAR 0 5
19152: EQUAL
19153: IFFALSE 19198
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
19155: LD_ADDR_VAR 0 1
19159: PUSH
19160: LD_VAR 0 1
19164: PPUSH
19165: LD_INT 1
19167: PPUSH
19168: LD_VAR 0 1
19172: PUSH
19173: LD_INT 1
19175: ARRAY
19176: PPUSH
19177: LD_INT 1
19179: PPUSH
19180: CALL_OW 3
19184: PPUSH
19185: CALL_OW 1
19189: ST_TO_ADDR
// tmp := 1 ;
19190: LD_ADDR_VAR 0 2
19194: PUSH
19195: LD_STRING 1
19197: ST_TO_ADDR
// end ; normal := normal & tmp ;
19198: LD_ADDR_VAR 0 3
19202: PUSH
19203: LD_VAR 0 3
19207: PUSH
19208: LD_VAR 0 2
19212: STR
19213: ST_TO_ADDR
// end ;
19214: GO 19114
19216: POP
19217: POP
// for i = 1 to hardcoreCounter do
19218: LD_ADDR_VAR 0 5
19222: PUSH
19223: DOUBLE
19224: LD_INT 1
19226: DEC
19227: ST_TO_ADDR
19228: LD_EXP 59
19232: PUSH
19233: FOR_TO
19234: IFFALSE 19339
// begin tmp := 0 ;
19236: LD_ADDR_VAR 0 2
19240: PUSH
19241: LD_STRING 0
19243: ST_TO_ADDR
// if result [ 2 ] then
19244: LD_VAR 0 1
19248: PUSH
19249: LD_INT 2
19251: ARRAY
19252: IFFALSE 19321
// if result [ 2 ] [ 1 ] = 100 + i then
19254: LD_VAR 0 1
19258: PUSH
19259: LD_INT 2
19261: ARRAY
19262: PUSH
19263: LD_INT 1
19265: ARRAY
19266: PUSH
19267: LD_INT 100
19269: PUSH
19270: LD_VAR 0 5
19274: PLUS
19275: EQUAL
19276: IFFALSE 19321
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
19278: LD_ADDR_VAR 0 1
19282: PUSH
19283: LD_VAR 0 1
19287: PPUSH
19288: LD_INT 2
19290: PPUSH
19291: LD_VAR 0 1
19295: PUSH
19296: LD_INT 2
19298: ARRAY
19299: PPUSH
19300: LD_INT 1
19302: PPUSH
19303: CALL_OW 3
19307: PPUSH
19308: CALL_OW 1
19312: ST_TO_ADDR
// tmp := 1 ;
19313: LD_ADDR_VAR 0 2
19317: PUSH
19318: LD_STRING 1
19320: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
19321: LD_ADDR_VAR 0 4
19325: PUSH
19326: LD_VAR 0 4
19330: PUSH
19331: LD_VAR 0 2
19335: STR
19336: ST_TO_ADDR
// end ;
19337: GO 19233
19339: POP
19340: POP
// ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & ") ) ;
19341: LD_STRING getStreamItemsFromMission("
19343: PUSH
19344: LD_VAR 0 3
19348: STR
19349: PUSH
19350: LD_STRING ","
19352: STR
19353: PUSH
19354: LD_VAR 0 4
19358: STR
19359: PUSH
19360: LD_STRING ")
19362: STR
19363: PPUSH
19364: CALL_OW 559
// end else
19368: GO 19377
// ToLua ( getStreamItemsFromMission("","") ) ;
19370: LD_STRING getStreamItemsFromMission("","")
19372: PPUSH
19373: CALL_OW 559
// end ;
19377: LD_VAR 0 1
19381: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
19382: LD_EXP 57
19386: PUSH
19387: LD_EXP 62
19391: AND
19392: IFFALSE 19516
19394: GO 19396
19396: DISABLE
19397: LD_INT 0
19399: PPUSH
19400: PPUSH
// begin enable ;
19401: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
19402: LD_ADDR_VAR 0 2
19406: PUSH
19407: LD_INT 22
19409: PUSH
19410: LD_OWVAR 2
19414: PUSH
19415: EMPTY
19416: LIST
19417: LIST
19418: PUSH
19419: LD_INT 2
19421: PUSH
19422: LD_INT 34
19424: PUSH
19425: LD_INT 7
19427: PUSH
19428: EMPTY
19429: LIST
19430: LIST
19431: PUSH
19432: LD_INT 34
19434: PUSH
19435: LD_INT 45
19437: PUSH
19438: EMPTY
19439: LIST
19440: LIST
19441: PUSH
19442: LD_INT 34
19444: PUSH
19445: LD_INT 28
19447: PUSH
19448: EMPTY
19449: LIST
19450: LIST
19451: PUSH
19452: LD_INT 34
19454: PUSH
19455: LD_INT 47
19457: PUSH
19458: EMPTY
19459: LIST
19460: LIST
19461: PUSH
19462: EMPTY
19463: LIST
19464: LIST
19465: LIST
19466: LIST
19467: LIST
19468: PUSH
19469: EMPTY
19470: LIST
19471: LIST
19472: PPUSH
19473: CALL_OW 69
19477: ST_TO_ADDR
// if not tmp then
19478: LD_VAR 0 2
19482: NOT
19483: IFFALSE 19487
// exit ;
19485: GO 19516
// for i in tmp do
19487: LD_ADDR_VAR 0 1
19491: PUSH
19492: LD_VAR 0 2
19496: PUSH
19497: FOR_IN
19498: IFFALSE 19514
// begin SetLives ( i , 0 ) ;
19500: LD_VAR 0 1
19504: PPUSH
19505: LD_INT 0
19507: PPUSH
19508: CALL_OW 234
// end ;
19512: GO 19497
19514: POP
19515: POP
// end ;
19516: PPOPN 2
19518: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
19519: LD_EXP 57
19523: PUSH
19524: LD_EXP 63
19528: AND
19529: IFFALSE 19613
19531: GO 19533
19533: DISABLE
19534: LD_INT 0
19536: PPUSH
19537: PPUSH
// begin enable ;
19538: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
19539: LD_ADDR_VAR 0 2
19543: PUSH
19544: LD_INT 22
19546: PUSH
19547: LD_OWVAR 2
19551: PUSH
19552: EMPTY
19553: LIST
19554: LIST
19555: PUSH
19556: LD_INT 32
19558: PUSH
19559: LD_INT 3
19561: PUSH
19562: EMPTY
19563: LIST
19564: LIST
19565: PUSH
19566: EMPTY
19567: LIST
19568: LIST
19569: PPUSH
19570: CALL_OW 69
19574: ST_TO_ADDR
// if not tmp then
19575: LD_VAR 0 2
19579: NOT
19580: IFFALSE 19584
// exit ;
19582: GO 19613
// for i in tmp do
19584: LD_ADDR_VAR 0 1
19588: PUSH
19589: LD_VAR 0 2
19593: PUSH
19594: FOR_IN
19595: IFFALSE 19611
// begin SetLives ( i , 0 ) ;
19597: LD_VAR 0 1
19601: PPUSH
19602: LD_INT 0
19604: PPUSH
19605: CALL_OW 234
// end ;
19609: GO 19594
19611: POP
19612: POP
// end ;
19613: PPOPN 2
19615: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
19616: LD_EXP 57
19620: PUSH
19621: LD_EXP 60
19625: AND
19626: IFFALSE 19719
19628: GO 19630
19630: DISABLE
19631: LD_INT 0
19633: PPUSH
// begin enable ;
19634: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
19635: LD_ADDR_VAR 0 1
19639: PUSH
19640: LD_INT 22
19642: PUSH
19643: LD_OWVAR 2
19647: PUSH
19648: EMPTY
19649: LIST
19650: LIST
19651: PUSH
19652: LD_INT 2
19654: PUSH
19655: LD_INT 25
19657: PUSH
19658: LD_INT 5
19660: PUSH
19661: EMPTY
19662: LIST
19663: LIST
19664: PUSH
19665: LD_INT 25
19667: PUSH
19668: LD_INT 9
19670: PUSH
19671: EMPTY
19672: LIST
19673: LIST
19674: PUSH
19675: LD_INT 25
19677: PUSH
19678: LD_INT 8
19680: PUSH
19681: EMPTY
19682: LIST
19683: LIST
19684: PUSH
19685: EMPTY
19686: LIST
19687: LIST
19688: LIST
19689: LIST
19690: PUSH
19691: EMPTY
19692: LIST
19693: LIST
19694: PPUSH
19695: CALL_OW 69
19699: PUSH
19700: FOR_IN
19701: IFFALSE 19717
// begin SetClass ( i , 1 ) ;
19703: LD_VAR 0 1
19707: PPUSH
19708: LD_INT 1
19710: PPUSH
19711: CALL_OW 336
// end ;
19715: GO 19700
19717: POP
19718: POP
// end ;
19719: PPOPN 1
19721: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
19722: LD_EXP 57
19726: PUSH
19727: LD_EXP 61
19731: AND
19732: PUSH
19733: LD_OWVAR 65
19737: PUSH
19738: LD_INT 7
19740: LESS
19741: AND
19742: IFFALSE 19756
19744: GO 19746
19746: DISABLE
// begin enable ;
19747: ENABLE
// game_speed := 7 ;
19748: LD_ADDR_OWVAR 65
19752: PUSH
19753: LD_INT 7
19755: ST_TO_ADDR
// end ;
19756: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
19757: LD_EXP 57
19761: PUSH
19762: LD_EXP 64
19766: AND
19767: IFFALSE 19969
19769: GO 19771
19771: DISABLE
19772: LD_INT 0
19774: PPUSH
19775: PPUSH
19776: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
19777: LD_ADDR_VAR 0 3
19781: PUSH
19782: LD_INT 81
19784: PUSH
19785: LD_OWVAR 2
19789: PUSH
19790: EMPTY
19791: LIST
19792: LIST
19793: PUSH
19794: LD_INT 21
19796: PUSH
19797: LD_INT 1
19799: PUSH
19800: EMPTY
19801: LIST
19802: LIST
19803: PUSH
19804: EMPTY
19805: LIST
19806: LIST
19807: PPUSH
19808: CALL_OW 69
19812: ST_TO_ADDR
// if not tmp then
19813: LD_VAR 0 3
19817: NOT
19818: IFFALSE 19822
// exit ;
19820: GO 19969
// if tmp > 5 then
19822: LD_VAR 0 3
19826: PUSH
19827: LD_INT 5
19829: GREATER
19830: IFFALSE 19842
// k := 5 else
19832: LD_ADDR_VAR 0 2
19836: PUSH
19837: LD_INT 5
19839: ST_TO_ADDR
19840: GO 19852
// k := tmp ;
19842: LD_ADDR_VAR 0 2
19846: PUSH
19847: LD_VAR 0 3
19851: ST_TO_ADDR
// for i := 1 to k do
19852: LD_ADDR_VAR 0 1
19856: PUSH
19857: DOUBLE
19858: LD_INT 1
19860: DEC
19861: ST_TO_ADDR
19862: LD_VAR 0 2
19866: PUSH
19867: FOR_TO
19868: IFFALSE 19967
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
19870: LD_VAR 0 3
19874: PUSH
19875: LD_VAR 0 1
19879: ARRAY
19880: PPUSH
19881: LD_VAR 0 1
19885: PUSH
19886: LD_INT 4
19888: MOD
19889: PUSH
19890: LD_INT 1
19892: PLUS
19893: PPUSH
19894: CALL_OW 259
19898: PUSH
19899: LD_INT 10
19901: LESS
19902: IFFALSE 19965
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
19904: LD_VAR 0 3
19908: PUSH
19909: LD_VAR 0 1
19913: ARRAY
19914: PPUSH
19915: LD_VAR 0 1
19919: PUSH
19920: LD_INT 4
19922: MOD
19923: PUSH
19924: LD_INT 1
19926: PLUS
19927: PPUSH
19928: LD_VAR 0 3
19932: PUSH
19933: LD_VAR 0 1
19937: ARRAY
19938: PPUSH
19939: LD_VAR 0 1
19943: PUSH
19944: LD_INT 4
19946: MOD
19947: PUSH
19948: LD_INT 1
19950: PLUS
19951: PPUSH
19952: CALL_OW 259
19956: PUSH
19957: LD_INT 1
19959: PLUS
19960: PPUSH
19961: CALL_OW 237
19965: GO 19867
19967: POP
19968: POP
// end ;
19969: PPOPN 3
19971: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
19972: LD_EXP 57
19976: PUSH
19977: LD_EXP 65
19981: AND
19982: IFFALSE 20002
19984: GO 19986
19986: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
19987: LD_INT 4
19989: PPUSH
19990: LD_OWVAR 2
19994: PPUSH
19995: LD_INT 0
19997: PPUSH
19998: CALL_OW 324
20002: END
// every 0 0$1 trigger StreamModeActive and sShovel do
20003: LD_EXP 57
20007: PUSH
20008: LD_EXP 94
20012: AND
20013: IFFALSE 20033
20015: GO 20017
20017: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
20018: LD_INT 19
20020: PPUSH
20021: LD_OWVAR 2
20025: PPUSH
20026: LD_INT 0
20028: PPUSH
20029: CALL_OW 324
20033: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
20034: LD_EXP 57
20038: PUSH
20039: LD_EXP 66
20043: AND
20044: IFFALSE 20146
20046: GO 20048
20048: DISABLE
20049: LD_INT 0
20051: PPUSH
20052: PPUSH
// begin enable ;
20053: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
20054: LD_ADDR_VAR 0 2
20058: PUSH
20059: LD_INT 22
20061: PUSH
20062: LD_OWVAR 2
20066: PUSH
20067: EMPTY
20068: LIST
20069: LIST
20070: PUSH
20071: LD_INT 2
20073: PUSH
20074: LD_INT 34
20076: PUSH
20077: LD_INT 11
20079: PUSH
20080: EMPTY
20081: LIST
20082: LIST
20083: PUSH
20084: LD_INT 34
20086: PUSH
20087: LD_INT 30
20089: PUSH
20090: EMPTY
20091: LIST
20092: LIST
20093: PUSH
20094: EMPTY
20095: LIST
20096: LIST
20097: LIST
20098: PUSH
20099: EMPTY
20100: LIST
20101: LIST
20102: PPUSH
20103: CALL_OW 69
20107: ST_TO_ADDR
// if not tmp then
20108: LD_VAR 0 2
20112: NOT
20113: IFFALSE 20117
// exit ;
20115: GO 20146
// for i in tmp do
20117: LD_ADDR_VAR 0 1
20121: PUSH
20122: LD_VAR 0 2
20126: PUSH
20127: FOR_IN
20128: IFFALSE 20144
// begin SetLives ( i , 0 ) ;
20130: LD_VAR 0 1
20134: PPUSH
20135: LD_INT 0
20137: PPUSH
20138: CALL_OW 234
// end ;
20142: GO 20127
20144: POP
20145: POP
// end ;
20146: PPOPN 2
20148: END
// every 0 0$1 trigger StreamModeActive and sBunker do
20149: LD_EXP 57
20153: PUSH
20154: LD_EXP 67
20158: AND
20159: IFFALSE 20179
20161: GO 20163
20163: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
20164: LD_INT 32
20166: PPUSH
20167: LD_OWVAR 2
20171: PPUSH
20172: LD_INT 0
20174: PPUSH
20175: CALL_OW 324
20179: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
20180: LD_EXP 57
20184: PUSH
20185: LD_EXP 68
20189: AND
20190: IFFALSE 20371
20192: GO 20194
20194: DISABLE
20195: LD_INT 0
20197: PPUSH
20198: PPUSH
20199: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
20200: LD_ADDR_VAR 0 2
20204: PUSH
20205: LD_INT 22
20207: PUSH
20208: LD_OWVAR 2
20212: PUSH
20213: EMPTY
20214: LIST
20215: LIST
20216: PUSH
20217: LD_INT 33
20219: PUSH
20220: LD_INT 3
20222: PUSH
20223: EMPTY
20224: LIST
20225: LIST
20226: PUSH
20227: EMPTY
20228: LIST
20229: LIST
20230: PPUSH
20231: CALL_OW 69
20235: ST_TO_ADDR
// if not tmp then
20236: LD_VAR 0 2
20240: NOT
20241: IFFALSE 20245
// exit ;
20243: GO 20371
// side := 0 ;
20245: LD_ADDR_VAR 0 3
20249: PUSH
20250: LD_INT 0
20252: ST_TO_ADDR
// for i := 1 to 8 do
20253: LD_ADDR_VAR 0 1
20257: PUSH
20258: DOUBLE
20259: LD_INT 1
20261: DEC
20262: ST_TO_ADDR
20263: LD_INT 8
20265: PUSH
20266: FOR_TO
20267: IFFALSE 20315
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
20269: LD_OWVAR 2
20273: PUSH
20274: LD_VAR 0 1
20278: NONEQUAL
20279: PUSH
20280: LD_OWVAR 2
20284: PPUSH
20285: LD_VAR 0 1
20289: PPUSH
20290: CALL_OW 81
20294: PUSH
20295: LD_INT 2
20297: EQUAL
20298: AND
20299: IFFALSE 20313
// begin side := i ;
20301: LD_ADDR_VAR 0 3
20305: PUSH
20306: LD_VAR 0 1
20310: ST_TO_ADDR
// break ;
20311: GO 20315
// end ;
20313: GO 20266
20315: POP
20316: POP
// if not side then
20317: LD_VAR 0 3
20321: NOT
20322: IFFALSE 20326
// exit ;
20324: GO 20371
// for i := 1 to tmp do
20326: LD_ADDR_VAR 0 1
20330: PUSH
20331: DOUBLE
20332: LD_INT 1
20334: DEC
20335: ST_TO_ADDR
20336: LD_VAR 0 2
20340: PUSH
20341: FOR_TO
20342: IFFALSE 20369
// if Prob ( 60 ) then
20344: LD_INT 60
20346: PPUSH
20347: CALL_OW 13
20351: IFFALSE 20367
// SetSide ( i , side ) ;
20353: LD_VAR 0 1
20357: PPUSH
20358: LD_VAR 0 3
20362: PPUSH
20363: CALL_OW 235
20367: GO 20341
20369: POP
20370: POP
// end ;
20371: PPOPN 3
20373: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
20374: LD_EXP 57
20378: PUSH
20379: LD_EXP 70
20383: AND
20384: IFFALSE 20503
20386: GO 20388
20388: DISABLE
20389: LD_INT 0
20391: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
20392: LD_ADDR_VAR 0 1
20396: PUSH
20397: LD_INT 22
20399: PUSH
20400: LD_OWVAR 2
20404: PUSH
20405: EMPTY
20406: LIST
20407: LIST
20408: PUSH
20409: LD_INT 21
20411: PUSH
20412: LD_INT 1
20414: PUSH
20415: EMPTY
20416: LIST
20417: LIST
20418: PUSH
20419: LD_INT 3
20421: PUSH
20422: LD_INT 23
20424: PUSH
20425: LD_INT 0
20427: PUSH
20428: EMPTY
20429: LIST
20430: LIST
20431: PUSH
20432: EMPTY
20433: LIST
20434: LIST
20435: PUSH
20436: EMPTY
20437: LIST
20438: LIST
20439: LIST
20440: PPUSH
20441: CALL_OW 69
20445: PUSH
20446: FOR_IN
20447: IFFALSE 20501
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
20449: LD_VAR 0 1
20453: PPUSH
20454: CALL_OW 257
20458: PUSH
20459: LD_INT 1
20461: PUSH
20462: LD_INT 2
20464: PUSH
20465: LD_INT 3
20467: PUSH
20468: LD_INT 4
20470: PUSH
20471: EMPTY
20472: LIST
20473: LIST
20474: LIST
20475: LIST
20476: IN
20477: IFFALSE 20499
// SetClass ( un , rand ( 1 , 4 ) ) ;
20479: LD_VAR 0 1
20483: PPUSH
20484: LD_INT 1
20486: PPUSH
20487: LD_INT 4
20489: PPUSH
20490: CALL_OW 12
20494: PPUSH
20495: CALL_OW 336
20499: GO 20446
20501: POP
20502: POP
// end ;
20503: PPOPN 1
20505: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
20506: LD_EXP 57
20510: PUSH
20511: LD_EXP 69
20515: AND
20516: IFFALSE 20595
20518: GO 20520
20520: DISABLE
20521: LD_INT 0
20523: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
20524: LD_ADDR_VAR 0 1
20528: PUSH
20529: LD_INT 22
20531: PUSH
20532: LD_OWVAR 2
20536: PUSH
20537: EMPTY
20538: LIST
20539: LIST
20540: PUSH
20541: LD_INT 21
20543: PUSH
20544: LD_INT 3
20546: PUSH
20547: EMPTY
20548: LIST
20549: LIST
20550: PUSH
20551: EMPTY
20552: LIST
20553: LIST
20554: PPUSH
20555: CALL_OW 69
20559: ST_TO_ADDR
// if not tmp then
20560: LD_VAR 0 1
20564: NOT
20565: IFFALSE 20569
// exit ;
20567: GO 20595
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
20569: LD_VAR 0 1
20573: PUSH
20574: LD_INT 1
20576: PPUSH
20577: LD_VAR 0 1
20581: PPUSH
20582: CALL_OW 12
20586: ARRAY
20587: PPUSH
20588: LD_INT 100
20590: PPUSH
20591: CALL_OW 234
// end ;
20595: PPOPN 1
20597: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
20598: LD_EXP 57
20602: PUSH
20603: LD_EXP 71
20607: AND
20608: IFFALSE 20706
20610: GO 20612
20612: DISABLE
20613: LD_INT 0
20615: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
20616: LD_ADDR_VAR 0 1
20620: PUSH
20621: LD_INT 22
20623: PUSH
20624: LD_OWVAR 2
20628: PUSH
20629: EMPTY
20630: LIST
20631: LIST
20632: PUSH
20633: LD_INT 21
20635: PUSH
20636: LD_INT 1
20638: PUSH
20639: EMPTY
20640: LIST
20641: LIST
20642: PUSH
20643: EMPTY
20644: LIST
20645: LIST
20646: PPUSH
20647: CALL_OW 69
20651: ST_TO_ADDR
// if not tmp then
20652: LD_VAR 0 1
20656: NOT
20657: IFFALSE 20661
// exit ;
20659: GO 20706
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
20661: LD_VAR 0 1
20665: PUSH
20666: LD_INT 1
20668: PPUSH
20669: LD_VAR 0 1
20673: PPUSH
20674: CALL_OW 12
20678: ARRAY
20679: PPUSH
20680: LD_INT 1
20682: PPUSH
20683: LD_INT 4
20685: PPUSH
20686: CALL_OW 12
20690: PPUSH
20691: LD_INT 3000
20693: PPUSH
20694: LD_INT 9000
20696: PPUSH
20697: CALL_OW 12
20701: PPUSH
20702: CALL_OW 492
// end ;
20706: PPOPN 1
20708: END
// every 0 0$1 trigger StreamModeActive and sDepot do
20709: LD_EXP 57
20713: PUSH
20714: LD_EXP 72
20718: AND
20719: IFFALSE 20739
20721: GO 20723
20723: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
20724: LD_INT 1
20726: PPUSH
20727: LD_OWVAR 2
20731: PPUSH
20732: LD_INT 0
20734: PPUSH
20735: CALL_OW 324
20739: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
20740: LD_EXP 57
20744: PUSH
20745: LD_EXP 73
20749: AND
20750: IFFALSE 20833
20752: GO 20754
20754: DISABLE
20755: LD_INT 0
20757: PPUSH
20758: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
20759: LD_ADDR_VAR 0 2
20763: PUSH
20764: LD_INT 22
20766: PUSH
20767: LD_OWVAR 2
20771: PUSH
20772: EMPTY
20773: LIST
20774: LIST
20775: PUSH
20776: LD_INT 21
20778: PUSH
20779: LD_INT 3
20781: PUSH
20782: EMPTY
20783: LIST
20784: LIST
20785: PUSH
20786: EMPTY
20787: LIST
20788: LIST
20789: PPUSH
20790: CALL_OW 69
20794: ST_TO_ADDR
// if not tmp then
20795: LD_VAR 0 2
20799: NOT
20800: IFFALSE 20804
// exit ;
20802: GO 20833
// for i in tmp do
20804: LD_ADDR_VAR 0 1
20808: PUSH
20809: LD_VAR 0 2
20813: PUSH
20814: FOR_IN
20815: IFFALSE 20831
// SetBLevel ( i , 10 ) ;
20817: LD_VAR 0 1
20821: PPUSH
20822: LD_INT 10
20824: PPUSH
20825: CALL_OW 241
20829: GO 20814
20831: POP
20832: POP
// end ;
20833: PPOPN 2
20835: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
20836: LD_EXP 57
20840: PUSH
20841: LD_EXP 74
20845: AND
20846: IFFALSE 20957
20848: GO 20850
20850: DISABLE
20851: LD_INT 0
20853: PPUSH
20854: PPUSH
20855: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
20856: LD_ADDR_VAR 0 3
20860: PUSH
20861: LD_INT 22
20863: PUSH
20864: LD_OWVAR 2
20868: PUSH
20869: EMPTY
20870: LIST
20871: LIST
20872: PUSH
20873: LD_INT 25
20875: PUSH
20876: LD_INT 1
20878: PUSH
20879: EMPTY
20880: LIST
20881: LIST
20882: PUSH
20883: EMPTY
20884: LIST
20885: LIST
20886: PPUSH
20887: CALL_OW 69
20891: ST_TO_ADDR
// if not tmp then
20892: LD_VAR 0 3
20896: NOT
20897: IFFALSE 20901
// exit ;
20899: GO 20957
// un := tmp [ rand ( 1 , tmp ) ] ;
20901: LD_ADDR_VAR 0 2
20905: PUSH
20906: LD_VAR 0 3
20910: PUSH
20911: LD_INT 1
20913: PPUSH
20914: LD_VAR 0 3
20918: PPUSH
20919: CALL_OW 12
20923: ARRAY
20924: ST_TO_ADDR
// if Crawls ( un ) then
20925: LD_VAR 0 2
20929: PPUSH
20930: CALL_OW 318
20934: IFFALSE 20945
// ComWalk ( un ) ;
20936: LD_VAR 0 2
20940: PPUSH
20941: CALL_OW 138
// SetClass ( un , class_sniper ) ;
20945: LD_VAR 0 2
20949: PPUSH
20950: LD_INT 5
20952: PPUSH
20953: CALL_OW 336
// end ;
20957: PPOPN 3
20959: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
20960: LD_EXP 57
20964: PUSH
20965: LD_EXP 75
20969: AND
20970: PUSH
20971: LD_OWVAR 67
20975: PUSH
20976: LD_INT 3
20978: LESS
20979: AND
20980: IFFALSE 20999
20982: GO 20984
20984: DISABLE
// Difficulty := Difficulty + 1 ;
20985: LD_ADDR_OWVAR 67
20989: PUSH
20990: LD_OWVAR 67
20994: PUSH
20995: LD_INT 1
20997: PLUS
20998: ST_TO_ADDR
20999: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
21000: LD_EXP 57
21004: PUSH
21005: LD_EXP 76
21009: AND
21010: IFFALSE 21113
21012: GO 21014
21014: DISABLE
21015: LD_INT 0
21017: PPUSH
// begin for i := 1 to 5 do
21018: LD_ADDR_VAR 0 1
21022: PUSH
21023: DOUBLE
21024: LD_INT 1
21026: DEC
21027: ST_TO_ADDR
21028: LD_INT 5
21030: PUSH
21031: FOR_TO
21032: IFFALSE 21111
// begin uc_nation := nation_nature ;
21034: LD_ADDR_OWVAR 21
21038: PUSH
21039: LD_INT 0
21041: ST_TO_ADDR
// uc_side := 0 ;
21042: LD_ADDR_OWVAR 20
21046: PUSH
21047: LD_INT 0
21049: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
21050: LD_ADDR_OWVAR 29
21054: PUSH
21055: LD_INT 12
21057: PUSH
21058: LD_INT 12
21060: PUSH
21061: EMPTY
21062: LIST
21063: LIST
21064: ST_TO_ADDR
// hc_agressivity := 20 ;
21065: LD_ADDR_OWVAR 35
21069: PUSH
21070: LD_INT 20
21072: ST_TO_ADDR
// hc_class := class_tiger ;
21073: LD_ADDR_OWVAR 28
21077: PUSH
21078: LD_INT 14
21080: ST_TO_ADDR
// hc_gallery :=  ;
21081: LD_ADDR_OWVAR 33
21085: PUSH
21086: LD_STRING 
21088: ST_TO_ADDR
// hc_name :=  ;
21089: LD_ADDR_OWVAR 26
21093: PUSH
21094: LD_STRING 
21096: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
21097: CALL_OW 44
21101: PPUSH
21102: LD_INT 0
21104: PPUSH
21105: CALL_OW 51
// end ;
21109: GO 21031
21111: POP
21112: POP
// end ;
21113: PPOPN 1
21115: END
// every 0 0$1 trigger StreamModeActive and sBomb do
21116: LD_EXP 57
21120: PUSH
21121: LD_EXP 77
21125: AND
21126: IFFALSE 21135
21128: GO 21130
21130: DISABLE
// StreamSibBomb ;
21131: CALL 21136 0 0
21135: END
// export function StreamSibBomb ; var i , x , y ; begin
21136: LD_INT 0
21138: PPUSH
21139: PPUSH
21140: PPUSH
21141: PPUSH
// result := false ;
21142: LD_ADDR_VAR 0 1
21146: PUSH
21147: LD_INT 0
21149: ST_TO_ADDR
// for i := 1 to 16 do
21150: LD_ADDR_VAR 0 2
21154: PUSH
21155: DOUBLE
21156: LD_INT 1
21158: DEC
21159: ST_TO_ADDR
21160: LD_INT 16
21162: PUSH
21163: FOR_TO
21164: IFFALSE 21363
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
21166: LD_ADDR_VAR 0 3
21170: PUSH
21171: LD_INT 10
21173: PUSH
21174: LD_INT 20
21176: PUSH
21177: LD_INT 30
21179: PUSH
21180: LD_INT 40
21182: PUSH
21183: LD_INT 50
21185: PUSH
21186: LD_INT 60
21188: PUSH
21189: LD_INT 70
21191: PUSH
21192: LD_INT 80
21194: PUSH
21195: LD_INT 90
21197: PUSH
21198: LD_INT 100
21200: PUSH
21201: LD_INT 110
21203: PUSH
21204: LD_INT 120
21206: PUSH
21207: LD_INT 130
21209: PUSH
21210: LD_INT 140
21212: PUSH
21213: LD_INT 150
21215: PUSH
21216: EMPTY
21217: LIST
21218: LIST
21219: LIST
21220: LIST
21221: LIST
21222: LIST
21223: LIST
21224: LIST
21225: LIST
21226: LIST
21227: LIST
21228: LIST
21229: LIST
21230: LIST
21231: LIST
21232: PUSH
21233: LD_INT 1
21235: PPUSH
21236: LD_INT 15
21238: PPUSH
21239: CALL_OW 12
21243: ARRAY
21244: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
21245: LD_ADDR_VAR 0 4
21249: PUSH
21250: LD_INT 10
21252: PUSH
21253: LD_INT 20
21255: PUSH
21256: LD_INT 30
21258: PUSH
21259: LD_INT 40
21261: PUSH
21262: LD_INT 50
21264: PUSH
21265: LD_INT 60
21267: PUSH
21268: LD_INT 70
21270: PUSH
21271: LD_INT 80
21273: PUSH
21274: LD_INT 90
21276: PUSH
21277: LD_INT 100
21279: PUSH
21280: LD_INT 110
21282: PUSH
21283: LD_INT 120
21285: PUSH
21286: LD_INT 130
21288: PUSH
21289: LD_INT 140
21291: PUSH
21292: LD_INT 150
21294: PUSH
21295: EMPTY
21296: LIST
21297: LIST
21298: LIST
21299: LIST
21300: LIST
21301: LIST
21302: LIST
21303: LIST
21304: LIST
21305: LIST
21306: LIST
21307: LIST
21308: LIST
21309: LIST
21310: LIST
21311: PUSH
21312: LD_INT 1
21314: PPUSH
21315: LD_INT 15
21317: PPUSH
21318: CALL_OW 12
21322: ARRAY
21323: ST_TO_ADDR
// if ValidHex ( x , y ) then
21324: LD_VAR 0 3
21328: PPUSH
21329: LD_VAR 0 4
21333: PPUSH
21334: CALL_OW 488
21338: IFFALSE 21361
// begin result := [ x , y ] ;
21340: LD_ADDR_VAR 0 1
21344: PUSH
21345: LD_VAR 0 3
21349: PUSH
21350: LD_VAR 0 4
21354: PUSH
21355: EMPTY
21356: LIST
21357: LIST
21358: ST_TO_ADDR
// break ;
21359: GO 21363
// end ; end ;
21361: GO 21163
21363: POP
21364: POP
// if result then
21365: LD_VAR 0 1
21369: IFFALSE 21429
// begin ToLua ( playSibBomb() ) ;
21371: LD_STRING playSibBomb()
21373: PPUSH
21374: CALL_OW 559
// wait ( 0 0$14 ) ;
21378: LD_INT 490
21380: PPUSH
21381: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
21385: LD_VAR 0 1
21389: PUSH
21390: LD_INT 1
21392: ARRAY
21393: PPUSH
21394: LD_VAR 0 1
21398: PUSH
21399: LD_INT 2
21401: ARRAY
21402: PPUSH
21403: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
21407: LD_VAR 0 1
21411: PUSH
21412: LD_INT 1
21414: ARRAY
21415: PPUSH
21416: LD_VAR 0 1
21420: PUSH
21421: LD_INT 2
21423: ARRAY
21424: PPUSH
21425: CALL_OW 429
// end ; end ;
21429: LD_VAR 0 1
21433: RET
// every 0 0$1 trigger StreamModeActive and sReset do
21434: LD_EXP 57
21438: PUSH
21439: LD_EXP 79
21443: AND
21444: IFFALSE 21456
21446: GO 21448
21448: DISABLE
// YouLost (  ) ;
21449: LD_STRING 
21451: PPUSH
21452: CALL_OW 104
21456: END
// every 0 0$1 trigger StreamModeActive and sFog do
21457: LD_EXP 57
21461: PUSH
21462: LD_EXP 78
21466: AND
21467: IFFALSE 21481
21469: GO 21471
21471: DISABLE
// FogOff ( your_side ) ;
21472: LD_OWVAR 2
21476: PPUSH
21477: CALL_OW 344
21481: END
// every 0 0$1 trigger StreamModeActive and sSun do
21482: LD_EXP 57
21486: PUSH
21487: LD_EXP 80
21491: AND
21492: IFFALSE 21520
21494: GO 21496
21496: DISABLE
// begin solar_recharge_percent := 0 ;
21497: LD_ADDR_OWVAR 79
21501: PUSH
21502: LD_INT 0
21504: ST_TO_ADDR
// wait ( 5 5$00 ) ;
21505: LD_INT 10500
21507: PPUSH
21508: CALL_OW 67
// solar_recharge_percent := 100 ;
21512: LD_ADDR_OWVAR 79
21516: PUSH
21517: LD_INT 100
21519: ST_TO_ADDR
// end ;
21520: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
21521: LD_EXP 57
21525: PUSH
21526: LD_EXP 81
21530: AND
21531: IFFALSE 21770
21533: GO 21535
21535: DISABLE
21536: LD_INT 0
21538: PPUSH
21539: PPUSH
21540: PPUSH
// begin tmp := [ ] ;
21541: LD_ADDR_VAR 0 3
21545: PUSH
21546: EMPTY
21547: ST_TO_ADDR
// for i := 1 to 6 do
21548: LD_ADDR_VAR 0 1
21552: PUSH
21553: DOUBLE
21554: LD_INT 1
21556: DEC
21557: ST_TO_ADDR
21558: LD_INT 6
21560: PUSH
21561: FOR_TO
21562: IFFALSE 21667
// begin uc_nation := nation_nature ;
21564: LD_ADDR_OWVAR 21
21568: PUSH
21569: LD_INT 0
21571: ST_TO_ADDR
// uc_side := 0 ;
21572: LD_ADDR_OWVAR 20
21576: PUSH
21577: LD_INT 0
21579: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
21580: LD_ADDR_OWVAR 29
21584: PUSH
21585: LD_INT 12
21587: PUSH
21588: LD_INT 12
21590: PUSH
21591: EMPTY
21592: LIST
21593: LIST
21594: ST_TO_ADDR
// hc_agressivity := 20 ;
21595: LD_ADDR_OWVAR 35
21599: PUSH
21600: LD_INT 20
21602: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
21603: LD_ADDR_OWVAR 28
21607: PUSH
21608: LD_INT 17
21610: ST_TO_ADDR
// hc_gallery :=  ;
21611: LD_ADDR_OWVAR 33
21615: PUSH
21616: LD_STRING 
21618: ST_TO_ADDR
// hc_name :=  ;
21619: LD_ADDR_OWVAR 26
21623: PUSH
21624: LD_STRING 
21626: ST_TO_ADDR
// un := CreateHuman ;
21627: LD_ADDR_VAR 0 2
21631: PUSH
21632: CALL_OW 44
21636: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
21637: LD_VAR 0 2
21641: PPUSH
21642: LD_INT 1
21644: PPUSH
21645: CALL_OW 51
// tmp := tmp ^ un ;
21649: LD_ADDR_VAR 0 3
21653: PUSH
21654: LD_VAR 0 3
21658: PUSH
21659: LD_VAR 0 2
21663: ADD
21664: ST_TO_ADDR
// end ;
21665: GO 21561
21667: POP
21668: POP
// repeat wait ( 0 0$1 ) ;
21669: LD_INT 35
21671: PPUSH
21672: CALL_OW 67
// for un in tmp do
21676: LD_ADDR_VAR 0 2
21680: PUSH
21681: LD_VAR 0 3
21685: PUSH
21686: FOR_IN
21687: IFFALSE 21761
// begin if IsDead ( un ) then
21689: LD_VAR 0 2
21693: PPUSH
21694: CALL_OW 301
21698: IFFALSE 21718
// begin tmp := tmp diff un ;
21700: LD_ADDR_VAR 0 3
21704: PUSH
21705: LD_VAR 0 3
21709: PUSH
21710: LD_VAR 0 2
21714: DIFF
21715: ST_TO_ADDR
// continue ;
21716: GO 21686
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
21718: LD_VAR 0 2
21722: PPUSH
21723: LD_INT 3
21725: PUSH
21726: LD_INT 22
21728: PUSH
21729: LD_INT 0
21731: PUSH
21732: EMPTY
21733: LIST
21734: LIST
21735: PUSH
21736: EMPTY
21737: LIST
21738: LIST
21739: PPUSH
21740: CALL_OW 69
21744: PPUSH
21745: LD_VAR 0 2
21749: PPUSH
21750: CALL_OW 74
21754: PPUSH
21755: CALL_OW 115
// end ;
21759: GO 21686
21761: POP
21762: POP
// until not tmp ;
21763: LD_VAR 0 3
21767: NOT
21768: IFFALSE 21669
// end ;
21770: PPOPN 3
21772: END
// every 0 0$1 trigger StreamModeActive and sTroll do
21773: LD_EXP 57
21777: PUSH
21778: LD_EXP 82
21782: AND
21783: IFFALSE 21837
21785: GO 21787
21787: DISABLE
// begin ToLua ( displayTroll(); ) ;
21788: LD_STRING displayTroll();
21790: PPUSH
21791: CALL_OW 559
// wait ( 3 3$00 ) ;
21795: LD_INT 6300
21797: PPUSH
21798: CALL_OW 67
// ToLua ( hideTroll(); ) ;
21802: LD_STRING hideTroll();
21804: PPUSH
21805: CALL_OW 559
// wait ( 1 1$00 ) ;
21809: LD_INT 2100
21811: PPUSH
21812: CALL_OW 67
// ToLua ( displayTroll(); ) ;
21816: LD_STRING displayTroll();
21818: PPUSH
21819: CALL_OW 559
// wait ( 1 1$00 ) ;
21823: LD_INT 2100
21825: PPUSH
21826: CALL_OW 67
// ToLua ( hideTroll(); ) ;
21830: LD_STRING hideTroll();
21832: PPUSH
21833: CALL_OW 559
// end ;
21837: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
21838: LD_EXP 57
21842: PUSH
21843: LD_EXP 83
21847: AND
21848: IFFALSE 21911
21850: GO 21852
21852: DISABLE
21853: LD_INT 0
21855: PPUSH
// begin p := 0 ;
21856: LD_ADDR_VAR 0 1
21860: PUSH
21861: LD_INT 0
21863: ST_TO_ADDR
// repeat game_speed := 1 ;
21864: LD_ADDR_OWVAR 65
21868: PUSH
21869: LD_INT 1
21871: ST_TO_ADDR
// wait ( 0 0$1 ) ;
21872: LD_INT 35
21874: PPUSH
21875: CALL_OW 67
// p := p + 1 ;
21879: LD_ADDR_VAR 0 1
21883: PUSH
21884: LD_VAR 0 1
21888: PUSH
21889: LD_INT 1
21891: PLUS
21892: ST_TO_ADDR
// until p >= 60 ;
21893: LD_VAR 0 1
21897: PUSH
21898: LD_INT 60
21900: GREATEREQUAL
21901: IFFALSE 21864
// game_speed := 4 ;
21903: LD_ADDR_OWVAR 65
21907: PUSH
21908: LD_INT 4
21910: ST_TO_ADDR
// end ;
21911: PPOPN 1
21913: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
21914: LD_EXP 57
21918: PUSH
21919: LD_EXP 84
21923: AND
21924: IFFALSE 22070
21926: GO 21928
21928: DISABLE
21929: LD_INT 0
21931: PPUSH
21932: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
21933: LD_ADDR_VAR 0 1
21937: PUSH
21938: LD_INT 22
21940: PUSH
21941: LD_OWVAR 2
21945: PUSH
21946: EMPTY
21947: LIST
21948: LIST
21949: PUSH
21950: LD_INT 2
21952: PUSH
21953: LD_INT 30
21955: PUSH
21956: LD_INT 0
21958: PUSH
21959: EMPTY
21960: LIST
21961: LIST
21962: PUSH
21963: LD_INT 30
21965: PUSH
21966: LD_INT 1
21968: PUSH
21969: EMPTY
21970: LIST
21971: LIST
21972: PUSH
21973: EMPTY
21974: LIST
21975: LIST
21976: LIST
21977: PUSH
21978: EMPTY
21979: LIST
21980: LIST
21981: PPUSH
21982: CALL_OW 69
21986: ST_TO_ADDR
// if not depot then
21987: LD_VAR 0 1
21991: NOT
21992: IFFALSE 21996
// exit ;
21994: GO 22070
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
21996: LD_ADDR_VAR 0 2
22000: PUSH
22001: LD_VAR 0 1
22005: PUSH
22006: LD_INT 1
22008: PPUSH
22009: LD_VAR 0 1
22013: PPUSH
22014: CALL_OW 12
22018: ARRAY
22019: PPUSH
22020: CALL_OW 274
22024: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
22025: LD_VAR 0 2
22029: PPUSH
22030: LD_INT 1
22032: PPUSH
22033: LD_INT 0
22035: PPUSH
22036: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
22040: LD_VAR 0 2
22044: PPUSH
22045: LD_INT 2
22047: PPUSH
22048: LD_INT 0
22050: PPUSH
22051: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
22055: LD_VAR 0 2
22059: PPUSH
22060: LD_INT 3
22062: PPUSH
22063: LD_INT 0
22065: PPUSH
22066: CALL_OW 277
// end ;
22070: PPOPN 2
22072: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
22073: LD_EXP 57
22077: PUSH
22078: LD_EXP 85
22082: AND
22083: IFFALSE 22180
22085: GO 22087
22087: DISABLE
22088: LD_INT 0
22090: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
22091: LD_ADDR_VAR 0 1
22095: PUSH
22096: LD_INT 22
22098: PUSH
22099: LD_OWVAR 2
22103: PUSH
22104: EMPTY
22105: LIST
22106: LIST
22107: PUSH
22108: LD_INT 21
22110: PUSH
22111: LD_INT 1
22113: PUSH
22114: EMPTY
22115: LIST
22116: LIST
22117: PUSH
22118: LD_INT 3
22120: PUSH
22121: LD_INT 23
22123: PUSH
22124: LD_INT 0
22126: PUSH
22127: EMPTY
22128: LIST
22129: LIST
22130: PUSH
22131: EMPTY
22132: LIST
22133: LIST
22134: PUSH
22135: EMPTY
22136: LIST
22137: LIST
22138: LIST
22139: PPUSH
22140: CALL_OW 69
22144: ST_TO_ADDR
// if not tmp then
22145: LD_VAR 0 1
22149: NOT
22150: IFFALSE 22154
// exit ;
22152: GO 22180
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
22154: LD_VAR 0 1
22158: PUSH
22159: LD_INT 1
22161: PPUSH
22162: LD_VAR 0 1
22166: PPUSH
22167: CALL_OW 12
22171: ARRAY
22172: PPUSH
22173: LD_INT 200
22175: PPUSH
22176: CALL_OW 234
// end ;
22180: PPOPN 1
22182: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
22183: LD_EXP 57
22187: PUSH
22188: LD_EXP 86
22192: AND
22193: IFFALSE 22272
22195: GO 22197
22197: DISABLE
22198: LD_INT 0
22200: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
22201: LD_ADDR_VAR 0 1
22205: PUSH
22206: LD_INT 22
22208: PUSH
22209: LD_OWVAR 2
22213: PUSH
22214: EMPTY
22215: LIST
22216: LIST
22217: PUSH
22218: LD_INT 21
22220: PUSH
22221: LD_INT 2
22223: PUSH
22224: EMPTY
22225: LIST
22226: LIST
22227: PUSH
22228: EMPTY
22229: LIST
22230: LIST
22231: PPUSH
22232: CALL_OW 69
22236: ST_TO_ADDR
// if not tmp then
22237: LD_VAR 0 1
22241: NOT
22242: IFFALSE 22246
// exit ;
22244: GO 22272
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
22246: LD_VAR 0 1
22250: PUSH
22251: LD_INT 1
22253: PPUSH
22254: LD_VAR 0 1
22258: PPUSH
22259: CALL_OW 12
22263: ARRAY
22264: PPUSH
22265: LD_INT 60
22267: PPUSH
22268: CALL_OW 234
// end ;
22272: PPOPN 1
22274: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
22275: LD_EXP 57
22279: PUSH
22280: LD_EXP 87
22284: AND
22285: IFFALSE 22384
22287: GO 22289
22289: DISABLE
22290: LD_INT 0
22292: PPUSH
22293: PPUSH
// begin enable ;
22294: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
22295: LD_ADDR_VAR 0 1
22299: PUSH
22300: LD_INT 22
22302: PUSH
22303: LD_OWVAR 2
22307: PUSH
22308: EMPTY
22309: LIST
22310: LIST
22311: PUSH
22312: LD_INT 61
22314: PUSH
22315: EMPTY
22316: LIST
22317: PUSH
22318: LD_INT 33
22320: PUSH
22321: LD_INT 2
22323: PUSH
22324: EMPTY
22325: LIST
22326: LIST
22327: PUSH
22328: EMPTY
22329: LIST
22330: LIST
22331: LIST
22332: PPUSH
22333: CALL_OW 69
22337: ST_TO_ADDR
// if not tmp then
22338: LD_VAR 0 1
22342: NOT
22343: IFFALSE 22347
// exit ;
22345: GO 22384
// for i in tmp do
22347: LD_ADDR_VAR 0 2
22351: PUSH
22352: LD_VAR 0 1
22356: PUSH
22357: FOR_IN
22358: IFFALSE 22382
// if IsControledBy ( i ) then
22360: LD_VAR 0 2
22364: PPUSH
22365: CALL_OW 312
22369: IFFALSE 22380
// ComUnlink ( i ) ;
22371: LD_VAR 0 2
22375: PPUSH
22376: CALL_OW 136
22380: GO 22357
22382: POP
22383: POP
// end ;
22384: PPOPN 2
22386: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
22387: LD_EXP 57
22391: PUSH
22392: LD_EXP 88
22396: AND
22397: IFFALSE 22537
22399: GO 22401
22401: DISABLE
22402: LD_INT 0
22404: PPUSH
22405: PPUSH
// begin ToLua ( displayPowell(); ) ;
22406: LD_STRING displayPowell();
22408: PPUSH
22409: CALL_OW 559
// uc_side := 0 ;
22413: LD_ADDR_OWVAR 20
22417: PUSH
22418: LD_INT 0
22420: ST_TO_ADDR
// uc_nation := 2 ;
22421: LD_ADDR_OWVAR 21
22425: PUSH
22426: LD_INT 2
22428: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
22429: LD_ADDR_OWVAR 37
22433: PUSH
22434: LD_INT 14
22436: ST_TO_ADDR
// vc_engine := engine_siberite ;
22437: LD_ADDR_OWVAR 39
22441: PUSH
22442: LD_INT 3
22444: ST_TO_ADDR
// vc_control := control_apeman ;
22445: LD_ADDR_OWVAR 38
22449: PUSH
22450: LD_INT 5
22452: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
22453: LD_ADDR_OWVAR 40
22457: PUSH
22458: LD_INT 29
22460: ST_TO_ADDR
// un := CreateVehicle ;
22461: LD_ADDR_VAR 0 2
22465: PUSH
22466: CALL_OW 45
22470: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
22471: LD_VAR 0 2
22475: PPUSH
22476: LD_INT 1
22478: PPUSH
22479: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
22483: LD_INT 35
22485: PPUSH
22486: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
22490: LD_VAR 0 2
22494: PPUSH
22495: LD_INT 22
22497: PUSH
22498: LD_OWVAR 2
22502: PUSH
22503: EMPTY
22504: LIST
22505: LIST
22506: PPUSH
22507: CALL_OW 69
22511: PPUSH
22512: LD_VAR 0 2
22516: PPUSH
22517: CALL_OW 74
22521: PPUSH
22522: CALL_OW 115
// until IsDead ( un ) ;
22526: LD_VAR 0 2
22530: PPUSH
22531: CALL_OW 301
22535: IFFALSE 22483
// end ;
22537: PPOPN 2
22539: END
// every 0 0$1 trigger StreamModeActive and sStu do
22540: LD_EXP 57
22544: PUSH
22545: LD_EXP 96
22549: AND
22550: IFFALSE 22566
22552: GO 22554
22554: DISABLE
// begin ToLua ( displayStucuk(); ) ;
22555: LD_STRING displayStucuk();
22557: PPUSH
22558: CALL_OW 559
// ResetFog ;
22562: CALL_OW 335
// end ;
22566: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
22567: LD_EXP 57
22571: PUSH
22572: LD_EXP 89
22576: AND
22577: IFFALSE 22718
22579: GO 22581
22581: DISABLE
22582: LD_INT 0
22584: PPUSH
22585: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
22586: LD_ADDR_VAR 0 2
22590: PUSH
22591: LD_INT 22
22593: PUSH
22594: LD_OWVAR 2
22598: PUSH
22599: EMPTY
22600: LIST
22601: LIST
22602: PUSH
22603: LD_INT 21
22605: PUSH
22606: LD_INT 1
22608: PUSH
22609: EMPTY
22610: LIST
22611: LIST
22612: PUSH
22613: EMPTY
22614: LIST
22615: LIST
22616: PPUSH
22617: CALL_OW 69
22621: ST_TO_ADDR
// if not tmp then
22622: LD_VAR 0 2
22626: NOT
22627: IFFALSE 22631
// exit ;
22629: GO 22718
// un := tmp [ rand ( 1 , tmp ) ] ;
22631: LD_ADDR_VAR 0 1
22635: PUSH
22636: LD_VAR 0 2
22640: PUSH
22641: LD_INT 1
22643: PPUSH
22644: LD_VAR 0 2
22648: PPUSH
22649: CALL_OW 12
22653: ARRAY
22654: ST_TO_ADDR
// SetSide ( un , 0 ) ;
22655: LD_VAR 0 1
22659: PPUSH
22660: LD_INT 0
22662: PPUSH
22663: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
22667: LD_VAR 0 1
22671: PPUSH
22672: LD_OWVAR 3
22676: PUSH
22677: LD_VAR 0 1
22681: DIFF
22682: PPUSH
22683: LD_VAR 0 1
22687: PPUSH
22688: CALL_OW 74
22692: PPUSH
22693: CALL_OW 115
// wait ( 0 0$20 ) ;
22697: LD_INT 700
22699: PPUSH
22700: CALL_OW 67
// SetSide ( un , your_side ) ;
22704: LD_VAR 0 1
22708: PPUSH
22709: LD_OWVAR 2
22713: PPUSH
22714: CALL_OW 235
// end ;
22718: PPOPN 2
22720: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
22721: LD_EXP 57
22725: PUSH
22726: LD_EXP 90
22730: AND
22731: IFFALSE 22837
22733: GO 22735
22735: DISABLE
22736: LD_INT 0
22738: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
22739: LD_ADDR_VAR 0 1
22743: PUSH
22744: LD_INT 22
22746: PUSH
22747: LD_OWVAR 2
22751: PUSH
22752: EMPTY
22753: LIST
22754: LIST
22755: PUSH
22756: LD_INT 2
22758: PUSH
22759: LD_INT 30
22761: PUSH
22762: LD_INT 0
22764: PUSH
22765: EMPTY
22766: LIST
22767: LIST
22768: PUSH
22769: LD_INT 30
22771: PUSH
22772: LD_INT 1
22774: PUSH
22775: EMPTY
22776: LIST
22777: LIST
22778: PUSH
22779: EMPTY
22780: LIST
22781: LIST
22782: LIST
22783: PUSH
22784: EMPTY
22785: LIST
22786: LIST
22787: PPUSH
22788: CALL_OW 69
22792: ST_TO_ADDR
// if not depot then
22793: LD_VAR 0 1
22797: NOT
22798: IFFALSE 22802
// exit ;
22800: GO 22837
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
22802: LD_VAR 0 1
22806: PUSH
22807: LD_INT 1
22809: ARRAY
22810: PPUSH
22811: CALL_OW 250
22815: PPUSH
22816: LD_VAR 0 1
22820: PUSH
22821: LD_INT 1
22823: ARRAY
22824: PPUSH
22825: CALL_OW 251
22829: PPUSH
22830: LD_INT 70
22832: PPUSH
22833: CALL_OW 495
// end ;
22837: PPOPN 1
22839: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
22840: LD_EXP 57
22844: PUSH
22845: LD_EXP 91
22849: AND
22850: IFFALSE 23061
22852: GO 22854
22854: DISABLE
22855: LD_INT 0
22857: PPUSH
22858: PPUSH
22859: PPUSH
22860: PPUSH
22861: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
22862: LD_ADDR_VAR 0 5
22866: PUSH
22867: LD_INT 22
22869: PUSH
22870: LD_OWVAR 2
22874: PUSH
22875: EMPTY
22876: LIST
22877: LIST
22878: PUSH
22879: LD_INT 21
22881: PUSH
22882: LD_INT 1
22884: PUSH
22885: EMPTY
22886: LIST
22887: LIST
22888: PUSH
22889: EMPTY
22890: LIST
22891: LIST
22892: PPUSH
22893: CALL_OW 69
22897: ST_TO_ADDR
// if not tmp then
22898: LD_VAR 0 5
22902: NOT
22903: IFFALSE 22907
// exit ;
22905: GO 23061
// for i in tmp do
22907: LD_ADDR_VAR 0 1
22911: PUSH
22912: LD_VAR 0 5
22916: PUSH
22917: FOR_IN
22918: IFFALSE 23059
// begin d := rand ( 0 , 5 ) ;
22920: LD_ADDR_VAR 0 4
22924: PUSH
22925: LD_INT 0
22927: PPUSH
22928: LD_INT 5
22930: PPUSH
22931: CALL_OW 12
22935: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
22936: LD_ADDR_VAR 0 2
22940: PUSH
22941: LD_VAR 0 1
22945: PPUSH
22946: CALL_OW 250
22950: PPUSH
22951: LD_VAR 0 4
22955: PPUSH
22956: LD_INT 3
22958: PPUSH
22959: LD_INT 12
22961: PPUSH
22962: CALL_OW 12
22966: PPUSH
22967: CALL_OW 272
22971: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
22972: LD_ADDR_VAR 0 3
22976: PUSH
22977: LD_VAR 0 1
22981: PPUSH
22982: CALL_OW 251
22986: PPUSH
22987: LD_VAR 0 4
22991: PPUSH
22992: LD_INT 3
22994: PPUSH
22995: LD_INT 12
22997: PPUSH
22998: CALL_OW 12
23002: PPUSH
23003: CALL_OW 273
23007: ST_TO_ADDR
// if ValidHex ( x , y ) then
23008: LD_VAR 0 2
23012: PPUSH
23013: LD_VAR 0 3
23017: PPUSH
23018: CALL_OW 488
23022: IFFALSE 23057
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
23024: LD_VAR 0 1
23028: PPUSH
23029: LD_VAR 0 2
23033: PPUSH
23034: LD_VAR 0 3
23038: PPUSH
23039: LD_INT 3
23041: PPUSH
23042: LD_INT 6
23044: PPUSH
23045: CALL_OW 12
23049: PPUSH
23050: LD_INT 1
23052: PPUSH
23053: CALL_OW 483
// end ;
23057: GO 22917
23059: POP
23060: POP
// end ;
23061: PPOPN 5
23063: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
23064: LD_EXP 57
23068: PUSH
23069: LD_EXP 92
23073: AND
23074: IFFALSE 23168
23076: GO 23078
23078: DISABLE
23079: LD_INT 0
23081: PPUSH
23082: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
23083: LD_ADDR_VAR 0 2
23087: PUSH
23088: LD_INT 22
23090: PUSH
23091: LD_OWVAR 2
23095: PUSH
23096: EMPTY
23097: LIST
23098: LIST
23099: PUSH
23100: LD_INT 32
23102: PUSH
23103: LD_INT 1
23105: PUSH
23106: EMPTY
23107: LIST
23108: LIST
23109: PUSH
23110: LD_INT 21
23112: PUSH
23113: LD_INT 2
23115: PUSH
23116: EMPTY
23117: LIST
23118: LIST
23119: PUSH
23120: EMPTY
23121: LIST
23122: LIST
23123: LIST
23124: PPUSH
23125: CALL_OW 69
23129: ST_TO_ADDR
// if not tmp then
23130: LD_VAR 0 2
23134: NOT
23135: IFFALSE 23139
// exit ;
23137: GO 23168
// for i in tmp do
23139: LD_ADDR_VAR 0 1
23143: PUSH
23144: LD_VAR 0 2
23148: PUSH
23149: FOR_IN
23150: IFFALSE 23166
// SetFuel ( i , 0 ) ;
23152: LD_VAR 0 1
23156: PPUSH
23157: LD_INT 0
23159: PPUSH
23160: CALL_OW 240
23164: GO 23149
23166: POP
23167: POP
// end ;
23168: PPOPN 2
23170: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
23171: LD_EXP 57
23175: PUSH
23176: LD_EXP 93
23180: AND
23181: IFFALSE 23247
23183: GO 23185
23185: DISABLE
23186: LD_INT 0
23188: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
23189: LD_ADDR_VAR 0 1
23193: PUSH
23194: LD_INT 22
23196: PUSH
23197: LD_OWVAR 2
23201: PUSH
23202: EMPTY
23203: LIST
23204: LIST
23205: PUSH
23206: LD_INT 30
23208: PUSH
23209: LD_INT 29
23211: PUSH
23212: EMPTY
23213: LIST
23214: LIST
23215: PUSH
23216: EMPTY
23217: LIST
23218: LIST
23219: PPUSH
23220: CALL_OW 69
23224: ST_TO_ADDR
// if not tmp then
23225: LD_VAR 0 1
23229: NOT
23230: IFFALSE 23234
// exit ;
23232: GO 23247
// DestroyUnit ( tmp [ 1 ] ) ;
23234: LD_VAR 0 1
23238: PUSH
23239: LD_INT 1
23241: ARRAY
23242: PPUSH
23243: CALL_OW 65
// end ;
23247: PPOPN 1
23249: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
23250: LD_EXP 57
23254: PUSH
23255: LD_EXP 95
23259: AND
23260: IFFALSE 23389
23262: GO 23264
23264: DISABLE
23265: LD_INT 0
23267: PPUSH
// begin uc_side := 0 ;
23268: LD_ADDR_OWVAR 20
23272: PUSH
23273: LD_INT 0
23275: ST_TO_ADDR
// uc_nation := nation_arabian ;
23276: LD_ADDR_OWVAR 21
23280: PUSH
23281: LD_INT 2
23283: ST_TO_ADDR
// hc_gallery :=  ;
23284: LD_ADDR_OWVAR 33
23288: PUSH
23289: LD_STRING 
23291: ST_TO_ADDR
// hc_name :=  ;
23292: LD_ADDR_OWVAR 26
23296: PUSH
23297: LD_STRING 
23299: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
23300: LD_INT 1
23302: PPUSH
23303: LD_INT 11
23305: PPUSH
23306: LD_INT 10
23308: PPUSH
23309: CALL_OW 380
// un := CreateHuman ;
23313: LD_ADDR_VAR 0 1
23317: PUSH
23318: CALL_OW 44
23322: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
23323: LD_VAR 0 1
23327: PPUSH
23328: LD_INT 1
23330: PPUSH
23331: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
23335: LD_INT 35
23337: PPUSH
23338: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
23342: LD_VAR 0 1
23346: PPUSH
23347: LD_INT 22
23349: PUSH
23350: LD_OWVAR 2
23354: PUSH
23355: EMPTY
23356: LIST
23357: LIST
23358: PPUSH
23359: CALL_OW 69
23363: PPUSH
23364: LD_VAR 0 1
23368: PPUSH
23369: CALL_OW 74
23373: PPUSH
23374: CALL_OW 115
// until IsDead ( un ) ;
23378: LD_VAR 0 1
23382: PPUSH
23383: CALL_OW 301
23387: IFFALSE 23335
// end ;
23389: PPOPN 1
23391: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
23392: LD_EXP 57
23396: PUSH
23397: LD_EXP 97
23401: AND
23402: IFFALSE 23414
23404: GO 23406
23406: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
23407: LD_STRING earthquake(getX(game), 0, 32)
23409: PPUSH
23410: CALL_OW 559
23414: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
23415: LD_EXP 57
23419: PUSH
23420: LD_EXP 98
23424: AND
23425: IFFALSE 23516
23427: GO 23429
23429: DISABLE
23430: LD_INT 0
23432: PPUSH
// begin enable ;
23433: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
23434: LD_ADDR_VAR 0 1
23438: PUSH
23439: LD_INT 22
23441: PUSH
23442: LD_OWVAR 2
23446: PUSH
23447: EMPTY
23448: LIST
23449: LIST
23450: PUSH
23451: LD_INT 21
23453: PUSH
23454: LD_INT 2
23456: PUSH
23457: EMPTY
23458: LIST
23459: LIST
23460: PUSH
23461: LD_INT 33
23463: PUSH
23464: LD_INT 3
23466: PUSH
23467: EMPTY
23468: LIST
23469: LIST
23470: PUSH
23471: EMPTY
23472: LIST
23473: LIST
23474: LIST
23475: PPUSH
23476: CALL_OW 69
23480: ST_TO_ADDR
// if not tmp then
23481: LD_VAR 0 1
23485: NOT
23486: IFFALSE 23490
// exit ;
23488: GO 23516
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
23490: LD_VAR 0 1
23494: PUSH
23495: LD_INT 1
23497: PPUSH
23498: LD_VAR 0 1
23502: PPUSH
23503: CALL_OW 12
23507: ARRAY
23508: PPUSH
23509: LD_INT 1
23511: PPUSH
23512: CALL_OW 234
// end ;
23516: PPOPN 1
23518: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
23519: LD_EXP 57
23523: PUSH
23524: LD_EXP 99
23528: AND
23529: IFFALSE 23670
23531: GO 23533
23533: DISABLE
23534: LD_INT 0
23536: PPUSH
23537: PPUSH
23538: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
23539: LD_ADDR_VAR 0 3
23543: PUSH
23544: LD_INT 22
23546: PUSH
23547: LD_OWVAR 2
23551: PUSH
23552: EMPTY
23553: LIST
23554: LIST
23555: PUSH
23556: LD_INT 25
23558: PUSH
23559: LD_INT 1
23561: PUSH
23562: EMPTY
23563: LIST
23564: LIST
23565: PUSH
23566: EMPTY
23567: LIST
23568: LIST
23569: PPUSH
23570: CALL_OW 69
23574: ST_TO_ADDR
// if not tmp then
23575: LD_VAR 0 3
23579: NOT
23580: IFFALSE 23584
// exit ;
23582: GO 23670
// un := tmp [ rand ( 1 , tmp ) ] ;
23584: LD_ADDR_VAR 0 2
23588: PUSH
23589: LD_VAR 0 3
23593: PUSH
23594: LD_INT 1
23596: PPUSH
23597: LD_VAR 0 3
23601: PPUSH
23602: CALL_OW 12
23606: ARRAY
23607: ST_TO_ADDR
// if Crawls ( un ) then
23608: LD_VAR 0 2
23612: PPUSH
23613: CALL_OW 318
23617: IFFALSE 23628
// ComWalk ( un ) ;
23619: LD_VAR 0 2
23623: PPUSH
23624: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
23628: LD_VAR 0 2
23632: PPUSH
23633: LD_INT 9
23635: PPUSH
23636: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
23640: LD_INT 28
23642: PPUSH
23643: LD_OWVAR 2
23647: PPUSH
23648: LD_INT 2
23650: PPUSH
23651: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
23655: LD_INT 29
23657: PPUSH
23658: LD_OWVAR 2
23662: PPUSH
23663: LD_INT 2
23665: PPUSH
23666: CALL_OW 322
// end ;
23670: PPOPN 3
23672: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
23673: LD_EXP 57
23677: PUSH
23678: LD_EXP 100
23682: AND
23683: IFFALSE 23794
23685: GO 23687
23687: DISABLE
23688: LD_INT 0
23690: PPUSH
23691: PPUSH
23692: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
23693: LD_ADDR_VAR 0 3
23697: PUSH
23698: LD_INT 22
23700: PUSH
23701: LD_OWVAR 2
23705: PUSH
23706: EMPTY
23707: LIST
23708: LIST
23709: PUSH
23710: LD_INT 25
23712: PUSH
23713: LD_INT 1
23715: PUSH
23716: EMPTY
23717: LIST
23718: LIST
23719: PUSH
23720: EMPTY
23721: LIST
23722: LIST
23723: PPUSH
23724: CALL_OW 69
23728: ST_TO_ADDR
// if not tmp then
23729: LD_VAR 0 3
23733: NOT
23734: IFFALSE 23738
// exit ;
23736: GO 23794
// un := tmp [ rand ( 1 , tmp ) ] ;
23738: LD_ADDR_VAR 0 2
23742: PUSH
23743: LD_VAR 0 3
23747: PUSH
23748: LD_INT 1
23750: PPUSH
23751: LD_VAR 0 3
23755: PPUSH
23756: CALL_OW 12
23760: ARRAY
23761: ST_TO_ADDR
// if Crawls ( un ) then
23762: LD_VAR 0 2
23766: PPUSH
23767: CALL_OW 318
23771: IFFALSE 23782
// ComWalk ( un ) ;
23773: LD_VAR 0 2
23777: PPUSH
23778: CALL_OW 138
// SetClass ( un , class_mortar ) ;
23782: LD_VAR 0 2
23786: PPUSH
23787: LD_INT 8
23789: PPUSH
23790: CALL_OW 336
// end ;
23794: PPOPN 3
23796: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
23797: LD_EXP 57
23801: PUSH
23802: LD_EXP 101
23806: AND
23807: IFFALSE 23951
23809: GO 23811
23811: DISABLE
23812: LD_INT 0
23814: PPUSH
23815: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
23816: LD_ADDR_VAR 0 2
23820: PUSH
23821: LD_INT 22
23823: PUSH
23824: LD_OWVAR 2
23828: PUSH
23829: EMPTY
23830: LIST
23831: LIST
23832: PUSH
23833: LD_INT 21
23835: PUSH
23836: LD_INT 2
23838: PUSH
23839: EMPTY
23840: LIST
23841: LIST
23842: PUSH
23843: LD_INT 2
23845: PUSH
23846: LD_INT 34
23848: PUSH
23849: LD_INT 12
23851: PUSH
23852: EMPTY
23853: LIST
23854: LIST
23855: PUSH
23856: LD_INT 34
23858: PUSH
23859: LD_INT 51
23861: PUSH
23862: EMPTY
23863: LIST
23864: LIST
23865: PUSH
23866: LD_INT 34
23868: PUSH
23869: LD_INT 32
23871: PUSH
23872: EMPTY
23873: LIST
23874: LIST
23875: PUSH
23876: EMPTY
23877: LIST
23878: LIST
23879: LIST
23880: LIST
23881: PUSH
23882: EMPTY
23883: LIST
23884: LIST
23885: LIST
23886: PPUSH
23887: CALL_OW 69
23891: ST_TO_ADDR
// if not tmp then
23892: LD_VAR 0 2
23896: NOT
23897: IFFALSE 23901
// exit ;
23899: GO 23951
// for i in tmp do
23901: LD_ADDR_VAR 0 1
23905: PUSH
23906: LD_VAR 0 2
23910: PUSH
23911: FOR_IN
23912: IFFALSE 23949
// if GetCargo ( i , mat_artifact ) = 0 then
23914: LD_VAR 0 1
23918: PPUSH
23919: LD_INT 4
23921: PPUSH
23922: CALL_OW 289
23926: PUSH
23927: LD_INT 0
23929: EQUAL
23930: IFFALSE 23947
// SetCargo ( i , mat_siberit , 100 ) ;
23932: LD_VAR 0 1
23936: PPUSH
23937: LD_INT 3
23939: PPUSH
23940: LD_INT 100
23942: PPUSH
23943: CALL_OW 290
23947: GO 23911
23949: POP
23950: POP
// end ;
23951: PPOPN 2
23953: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
23954: LD_EXP 57
23958: PUSH
23959: LD_EXP 102
23963: AND
23964: IFFALSE 24147
23966: GO 23968
23968: DISABLE
23969: LD_INT 0
23971: PPUSH
23972: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
23973: LD_ADDR_VAR 0 2
23977: PUSH
23978: LD_INT 22
23980: PUSH
23981: LD_OWVAR 2
23985: PUSH
23986: EMPTY
23987: LIST
23988: LIST
23989: PPUSH
23990: CALL_OW 69
23994: ST_TO_ADDR
// if not tmp then
23995: LD_VAR 0 2
23999: NOT
24000: IFFALSE 24004
// exit ;
24002: GO 24147
// for i := 1 to 2 do
24004: LD_ADDR_VAR 0 1
24008: PUSH
24009: DOUBLE
24010: LD_INT 1
24012: DEC
24013: ST_TO_ADDR
24014: LD_INT 2
24016: PUSH
24017: FOR_TO
24018: IFFALSE 24145
// begin uc_side := your_side ;
24020: LD_ADDR_OWVAR 20
24024: PUSH
24025: LD_OWVAR 2
24029: ST_TO_ADDR
// uc_nation := nation_american ;
24030: LD_ADDR_OWVAR 21
24034: PUSH
24035: LD_INT 1
24037: ST_TO_ADDR
// vc_chassis := us_morphling ;
24038: LD_ADDR_OWVAR 37
24042: PUSH
24043: LD_INT 5
24045: ST_TO_ADDR
// vc_engine := engine_siberite ;
24046: LD_ADDR_OWVAR 39
24050: PUSH
24051: LD_INT 3
24053: ST_TO_ADDR
// vc_control := control_computer ;
24054: LD_ADDR_OWVAR 38
24058: PUSH
24059: LD_INT 3
24061: ST_TO_ADDR
// vc_weapon := us_double_laser ;
24062: LD_ADDR_OWVAR 40
24066: PUSH
24067: LD_INT 10
24069: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
24070: LD_VAR 0 2
24074: PUSH
24075: LD_INT 1
24077: ARRAY
24078: PPUSH
24079: CALL_OW 310
24083: NOT
24084: IFFALSE 24131
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
24086: CALL_OW 45
24090: PPUSH
24091: LD_VAR 0 2
24095: PUSH
24096: LD_INT 1
24098: ARRAY
24099: PPUSH
24100: CALL_OW 250
24104: PPUSH
24105: LD_VAR 0 2
24109: PUSH
24110: LD_INT 1
24112: ARRAY
24113: PPUSH
24114: CALL_OW 251
24118: PPUSH
24119: LD_INT 12
24121: PPUSH
24122: LD_INT 1
24124: PPUSH
24125: CALL_OW 50
24129: GO 24143
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
24131: CALL_OW 45
24135: PPUSH
24136: LD_INT 1
24138: PPUSH
24139: CALL_OW 51
// end ;
24143: GO 24017
24145: POP
24146: POP
// end ;
24147: PPOPN 2
24149: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
24150: LD_EXP 57
24154: PUSH
24155: LD_EXP 103
24159: AND
24160: IFFALSE 24382
24162: GO 24164
24164: DISABLE
24165: LD_INT 0
24167: PPUSH
24168: PPUSH
24169: PPUSH
24170: PPUSH
24171: PPUSH
24172: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
24173: LD_ADDR_VAR 0 6
24177: PUSH
24178: LD_INT 22
24180: PUSH
24181: LD_OWVAR 2
24185: PUSH
24186: EMPTY
24187: LIST
24188: LIST
24189: PUSH
24190: LD_INT 21
24192: PUSH
24193: LD_INT 1
24195: PUSH
24196: EMPTY
24197: LIST
24198: LIST
24199: PUSH
24200: LD_INT 3
24202: PUSH
24203: LD_INT 23
24205: PUSH
24206: LD_INT 0
24208: PUSH
24209: EMPTY
24210: LIST
24211: LIST
24212: PUSH
24213: EMPTY
24214: LIST
24215: LIST
24216: PUSH
24217: EMPTY
24218: LIST
24219: LIST
24220: LIST
24221: PPUSH
24222: CALL_OW 69
24226: ST_TO_ADDR
// if not tmp then
24227: LD_VAR 0 6
24231: NOT
24232: IFFALSE 24236
// exit ;
24234: GO 24382
// s1 := rand ( 1 , 4 ) ;
24236: LD_ADDR_VAR 0 2
24240: PUSH
24241: LD_INT 1
24243: PPUSH
24244: LD_INT 4
24246: PPUSH
24247: CALL_OW 12
24251: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
24252: LD_ADDR_VAR 0 4
24256: PUSH
24257: LD_VAR 0 6
24261: PUSH
24262: LD_INT 1
24264: ARRAY
24265: PPUSH
24266: LD_VAR 0 2
24270: PPUSH
24271: CALL_OW 259
24275: ST_TO_ADDR
// if s1 = 1 then
24276: LD_VAR 0 2
24280: PUSH
24281: LD_INT 1
24283: EQUAL
24284: IFFALSE 24304
// s2 := rand ( 2 , 4 ) else
24286: LD_ADDR_VAR 0 3
24290: PUSH
24291: LD_INT 2
24293: PPUSH
24294: LD_INT 4
24296: PPUSH
24297: CALL_OW 12
24301: ST_TO_ADDR
24302: GO 24312
// s2 := 1 ;
24304: LD_ADDR_VAR 0 3
24308: PUSH
24309: LD_INT 1
24311: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
24312: LD_ADDR_VAR 0 5
24316: PUSH
24317: LD_VAR 0 6
24321: PUSH
24322: LD_INT 1
24324: ARRAY
24325: PPUSH
24326: LD_VAR 0 3
24330: PPUSH
24331: CALL_OW 259
24335: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
24336: LD_VAR 0 6
24340: PUSH
24341: LD_INT 1
24343: ARRAY
24344: PPUSH
24345: LD_VAR 0 2
24349: PPUSH
24350: LD_VAR 0 5
24354: PPUSH
24355: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
24359: LD_VAR 0 6
24363: PUSH
24364: LD_INT 1
24366: ARRAY
24367: PPUSH
24368: LD_VAR 0 3
24372: PPUSH
24373: LD_VAR 0 4
24377: PPUSH
24378: CALL_OW 237
// end ;
24382: PPOPN 6
24384: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
24385: LD_EXP 57
24389: PUSH
24390: LD_EXP 104
24394: AND
24395: IFFALSE 24474
24397: GO 24399
24399: DISABLE
24400: LD_INT 0
24402: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
24403: LD_ADDR_VAR 0 1
24407: PUSH
24408: LD_INT 22
24410: PUSH
24411: LD_OWVAR 2
24415: PUSH
24416: EMPTY
24417: LIST
24418: LIST
24419: PUSH
24420: LD_INT 30
24422: PUSH
24423: LD_INT 3
24425: PUSH
24426: EMPTY
24427: LIST
24428: LIST
24429: PUSH
24430: EMPTY
24431: LIST
24432: LIST
24433: PPUSH
24434: CALL_OW 69
24438: ST_TO_ADDR
// if not tmp then
24439: LD_VAR 0 1
24443: NOT
24444: IFFALSE 24448
// exit ;
24446: GO 24474
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
24448: LD_VAR 0 1
24452: PUSH
24453: LD_INT 1
24455: PPUSH
24456: LD_VAR 0 1
24460: PPUSH
24461: CALL_OW 12
24465: ARRAY
24466: PPUSH
24467: LD_INT 1
24469: PPUSH
24470: CALL_OW 234
// end ;
24474: PPOPN 1
24476: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
24477: LD_EXP 57
24481: PUSH
24482: LD_EXP 105
24486: AND
24487: IFFALSE 24599
24489: GO 24491
24491: DISABLE
24492: LD_INT 0
24494: PPUSH
24495: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
24496: LD_ADDR_VAR 0 2
24500: PUSH
24501: LD_INT 22
24503: PUSH
24504: LD_OWVAR 2
24508: PUSH
24509: EMPTY
24510: LIST
24511: LIST
24512: PUSH
24513: LD_INT 2
24515: PUSH
24516: LD_INT 30
24518: PUSH
24519: LD_INT 27
24521: PUSH
24522: EMPTY
24523: LIST
24524: LIST
24525: PUSH
24526: LD_INT 30
24528: PUSH
24529: LD_INT 26
24531: PUSH
24532: EMPTY
24533: LIST
24534: LIST
24535: PUSH
24536: LD_INT 30
24538: PUSH
24539: LD_INT 28
24541: PUSH
24542: EMPTY
24543: LIST
24544: LIST
24545: PUSH
24546: EMPTY
24547: LIST
24548: LIST
24549: LIST
24550: LIST
24551: PUSH
24552: EMPTY
24553: LIST
24554: LIST
24555: PPUSH
24556: CALL_OW 69
24560: ST_TO_ADDR
// if not tmp then
24561: LD_VAR 0 2
24565: NOT
24566: IFFALSE 24570
// exit ;
24568: GO 24599
// for i in tmp do
24570: LD_ADDR_VAR 0 1
24574: PUSH
24575: LD_VAR 0 2
24579: PUSH
24580: FOR_IN
24581: IFFALSE 24597
// SetLives ( i , 1 ) ;
24583: LD_VAR 0 1
24587: PPUSH
24588: LD_INT 1
24590: PPUSH
24591: CALL_OW 234
24595: GO 24580
24597: POP
24598: POP
// end ;
24599: PPOPN 2
24601: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
24602: LD_EXP 57
24606: PUSH
24607: LD_EXP 106
24611: AND
24612: IFFALSE 24886
24614: GO 24616
24616: DISABLE
24617: LD_INT 0
24619: PPUSH
24620: PPUSH
24621: PPUSH
// begin i := rand ( 1 , 7 ) ;
24622: LD_ADDR_VAR 0 1
24626: PUSH
24627: LD_INT 1
24629: PPUSH
24630: LD_INT 7
24632: PPUSH
24633: CALL_OW 12
24637: ST_TO_ADDR
// case i of 1 :
24638: LD_VAR 0 1
24642: PUSH
24643: LD_INT 1
24645: DOUBLE
24646: EQUAL
24647: IFTRUE 24651
24649: GO 24661
24651: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
24652: LD_STRING earthquake(getX(game), 0, 32)
24654: PPUSH
24655: CALL_OW 559
24659: GO 24886
24661: LD_INT 2
24663: DOUBLE
24664: EQUAL
24665: IFTRUE 24669
24667: GO 24683
24669: POP
// begin ToLua ( displayStucuk(); ) ;
24670: LD_STRING displayStucuk();
24672: PPUSH
24673: CALL_OW 559
// ResetFog ;
24677: CALL_OW 335
// end ; 3 :
24681: GO 24886
24683: LD_INT 3
24685: DOUBLE
24686: EQUAL
24687: IFTRUE 24691
24689: GO 24795
24691: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
24692: LD_ADDR_VAR 0 2
24696: PUSH
24697: LD_INT 22
24699: PUSH
24700: LD_OWVAR 2
24704: PUSH
24705: EMPTY
24706: LIST
24707: LIST
24708: PUSH
24709: LD_INT 25
24711: PUSH
24712: LD_INT 1
24714: PUSH
24715: EMPTY
24716: LIST
24717: LIST
24718: PUSH
24719: EMPTY
24720: LIST
24721: LIST
24722: PPUSH
24723: CALL_OW 69
24727: ST_TO_ADDR
// if not tmp then
24728: LD_VAR 0 2
24732: NOT
24733: IFFALSE 24737
// exit ;
24735: GO 24886
// un := tmp [ rand ( 1 , tmp ) ] ;
24737: LD_ADDR_VAR 0 3
24741: PUSH
24742: LD_VAR 0 2
24746: PUSH
24747: LD_INT 1
24749: PPUSH
24750: LD_VAR 0 2
24754: PPUSH
24755: CALL_OW 12
24759: ARRAY
24760: ST_TO_ADDR
// if Crawls ( un ) then
24761: LD_VAR 0 3
24765: PPUSH
24766: CALL_OW 318
24770: IFFALSE 24781
// ComWalk ( un ) ;
24772: LD_VAR 0 3
24776: PPUSH
24777: CALL_OW 138
// SetClass ( un , class_mortar ) ;
24781: LD_VAR 0 3
24785: PPUSH
24786: LD_INT 8
24788: PPUSH
24789: CALL_OW 336
// end ; 4 :
24793: GO 24886
24795: LD_INT 4
24797: DOUBLE
24798: EQUAL
24799: IFTRUE 24803
24801: GO 24864
24803: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
24804: LD_ADDR_VAR 0 2
24808: PUSH
24809: LD_INT 22
24811: PUSH
24812: LD_OWVAR 2
24816: PUSH
24817: EMPTY
24818: LIST
24819: LIST
24820: PUSH
24821: LD_INT 30
24823: PUSH
24824: LD_INT 29
24826: PUSH
24827: EMPTY
24828: LIST
24829: LIST
24830: PUSH
24831: EMPTY
24832: LIST
24833: LIST
24834: PPUSH
24835: CALL_OW 69
24839: ST_TO_ADDR
// if not tmp then
24840: LD_VAR 0 2
24844: NOT
24845: IFFALSE 24849
// exit ;
24847: GO 24886
// DestroyUnit ( tmp [ 1 ] ) ;
24849: LD_VAR 0 2
24853: PUSH
24854: LD_INT 1
24856: ARRAY
24857: PPUSH
24858: CALL_OW 65
// end ; 5 .. 7 :
24862: GO 24886
24864: LD_INT 5
24866: DOUBLE
24867: GREATEREQUAL
24868: IFFALSE 24876
24870: LD_INT 7
24872: DOUBLE
24873: LESSEQUAL
24874: IFTRUE 24878
24876: GO 24885
24878: POP
// StreamSibBomb ; end ;
24879: CALL 21136 0 0
24883: GO 24886
24885: POP
// end ;
24886: PPOPN 3
24888: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
24889: LD_EXP 57
24893: PUSH
24894: LD_EXP 107
24898: AND
24899: IFFALSE 25055
24901: GO 24903
24903: DISABLE
24904: LD_INT 0
24906: PPUSH
24907: PPUSH
24908: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
24909: LD_ADDR_VAR 0 2
24913: PUSH
24914: LD_INT 81
24916: PUSH
24917: LD_OWVAR 2
24921: PUSH
24922: EMPTY
24923: LIST
24924: LIST
24925: PUSH
24926: LD_INT 2
24928: PUSH
24929: LD_INT 21
24931: PUSH
24932: LD_INT 1
24934: PUSH
24935: EMPTY
24936: LIST
24937: LIST
24938: PUSH
24939: LD_INT 21
24941: PUSH
24942: LD_INT 2
24944: PUSH
24945: EMPTY
24946: LIST
24947: LIST
24948: PUSH
24949: EMPTY
24950: LIST
24951: LIST
24952: LIST
24953: PUSH
24954: EMPTY
24955: LIST
24956: LIST
24957: PPUSH
24958: CALL_OW 69
24962: ST_TO_ADDR
// if not tmp then
24963: LD_VAR 0 2
24967: NOT
24968: IFFALSE 24972
// exit ;
24970: GO 25055
// p := 0 ;
24972: LD_ADDR_VAR 0 3
24976: PUSH
24977: LD_INT 0
24979: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
24980: LD_INT 35
24982: PPUSH
24983: CALL_OW 67
// p := p + 1 ;
24987: LD_ADDR_VAR 0 3
24991: PUSH
24992: LD_VAR 0 3
24996: PUSH
24997: LD_INT 1
24999: PLUS
25000: ST_TO_ADDR
// for i in tmp do
25001: LD_ADDR_VAR 0 1
25005: PUSH
25006: LD_VAR 0 2
25010: PUSH
25011: FOR_IN
25012: IFFALSE 25043
// if GetLives ( i ) < 1000 then
25014: LD_VAR 0 1
25018: PPUSH
25019: CALL_OW 256
25023: PUSH
25024: LD_INT 1000
25026: LESS
25027: IFFALSE 25041
// SetLives ( i , 1000 ) ;
25029: LD_VAR 0 1
25033: PPUSH
25034: LD_INT 1000
25036: PPUSH
25037: CALL_OW 234
25041: GO 25011
25043: POP
25044: POP
// until p > 20 ;
25045: LD_VAR 0 3
25049: PUSH
25050: LD_INT 20
25052: GREATER
25053: IFFALSE 24980
// end ;
25055: PPOPN 3
25057: END
// every 0 0$1 trigger StreamModeActive and sTime do
25058: LD_EXP 57
25062: PUSH
25063: LD_EXP 108
25067: AND
25068: IFFALSE 25103
25070: GO 25072
25072: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
25073: LD_INT 28
25075: PPUSH
25076: LD_OWVAR 2
25080: PPUSH
25081: LD_INT 2
25083: PPUSH
25084: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
25088: LD_INT 30
25090: PPUSH
25091: LD_OWVAR 2
25095: PPUSH
25096: LD_INT 2
25098: PPUSH
25099: CALL_OW 322
// end ;
25103: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
25104: LD_EXP 57
25108: PUSH
25109: LD_EXP 109
25113: AND
25114: IFFALSE 25235
25116: GO 25118
25118: DISABLE
25119: LD_INT 0
25121: PPUSH
25122: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
25123: LD_ADDR_VAR 0 2
25127: PUSH
25128: LD_INT 22
25130: PUSH
25131: LD_OWVAR 2
25135: PUSH
25136: EMPTY
25137: LIST
25138: LIST
25139: PUSH
25140: LD_INT 21
25142: PUSH
25143: LD_INT 1
25145: PUSH
25146: EMPTY
25147: LIST
25148: LIST
25149: PUSH
25150: LD_INT 3
25152: PUSH
25153: LD_INT 23
25155: PUSH
25156: LD_INT 0
25158: PUSH
25159: EMPTY
25160: LIST
25161: LIST
25162: PUSH
25163: EMPTY
25164: LIST
25165: LIST
25166: PUSH
25167: EMPTY
25168: LIST
25169: LIST
25170: LIST
25171: PPUSH
25172: CALL_OW 69
25176: ST_TO_ADDR
// if not tmp then
25177: LD_VAR 0 2
25181: NOT
25182: IFFALSE 25186
// exit ;
25184: GO 25235
// for i in tmp do
25186: LD_ADDR_VAR 0 1
25190: PUSH
25191: LD_VAR 0 2
25195: PUSH
25196: FOR_IN
25197: IFFALSE 25233
// begin if Crawls ( i ) then
25199: LD_VAR 0 1
25203: PPUSH
25204: CALL_OW 318
25208: IFFALSE 25219
// ComWalk ( i ) ;
25210: LD_VAR 0 1
25214: PPUSH
25215: CALL_OW 138
// SetClass ( i , 2 ) ;
25219: LD_VAR 0 1
25223: PPUSH
25224: LD_INT 2
25226: PPUSH
25227: CALL_OW 336
// end ;
25231: GO 25196
25233: POP
25234: POP
// end ;
25235: PPOPN 2
25237: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
25238: LD_EXP 57
25242: PUSH
25243: LD_EXP 110
25247: AND
25248: IFFALSE 25529
25250: GO 25252
25252: DISABLE
25253: LD_INT 0
25255: PPUSH
25256: PPUSH
25257: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
25258: LD_OWVAR 2
25262: PPUSH
25263: LD_INT 9
25265: PPUSH
25266: LD_INT 1
25268: PPUSH
25269: LD_INT 1
25271: PPUSH
25272: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
25276: LD_INT 9
25278: PPUSH
25279: LD_OWVAR 2
25283: PPUSH
25284: CALL_OW 343
// uc_side := 9 ;
25288: LD_ADDR_OWVAR 20
25292: PUSH
25293: LD_INT 9
25295: ST_TO_ADDR
// uc_nation := 2 ;
25296: LD_ADDR_OWVAR 21
25300: PUSH
25301: LD_INT 2
25303: ST_TO_ADDR
// hc_name := Dark Warrior ;
25304: LD_ADDR_OWVAR 26
25308: PUSH
25309: LD_STRING Dark Warrior
25311: ST_TO_ADDR
// hc_gallery :=  ;
25312: LD_ADDR_OWVAR 33
25316: PUSH
25317: LD_STRING 
25319: ST_TO_ADDR
// hc_noskilllimit := true ;
25320: LD_ADDR_OWVAR 76
25324: PUSH
25325: LD_INT 1
25327: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
25328: LD_ADDR_OWVAR 31
25332: PUSH
25333: LD_INT 30
25335: PUSH
25336: LD_INT 30
25338: PUSH
25339: LD_INT 30
25341: PUSH
25342: LD_INT 30
25344: PUSH
25345: EMPTY
25346: LIST
25347: LIST
25348: LIST
25349: LIST
25350: ST_TO_ADDR
// un := CreateHuman ;
25351: LD_ADDR_VAR 0 3
25355: PUSH
25356: CALL_OW 44
25360: ST_TO_ADDR
// hc_noskilllimit := false ;
25361: LD_ADDR_OWVAR 76
25365: PUSH
25366: LD_INT 0
25368: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
25369: LD_VAR 0 3
25373: PPUSH
25374: LD_INT 1
25376: PPUSH
25377: CALL_OW 51
// p := 0 ;
25381: LD_ADDR_VAR 0 2
25385: PUSH
25386: LD_INT 0
25388: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
25389: LD_INT 35
25391: PPUSH
25392: CALL_OW 67
// p := p + 1 ;
25396: LD_ADDR_VAR 0 2
25400: PUSH
25401: LD_VAR 0 2
25405: PUSH
25406: LD_INT 1
25408: PLUS
25409: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
25410: LD_VAR 0 3
25414: PPUSH
25415: CALL_OW 256
25419: PUSH
25420: LD_INT 1000
25422: LESS
25423: IFFALSE 25437
// SetLives ( un , 1000 ) ;
25425: LD_VAR 0 3
25429: PPUSH
25430: LD_INT 1000
25432: PPUSH
25433: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
25437: LD_VAR 0 3
25441: PPUSH
25442: LD_INT 81
25444: PUSH
25445: LD_OWVAR 2
25449: PUSH
25450: EMPTY
25451: LIST
25452: LIST
25453: PUSH
25454: LD_INT 91
25456: PUSH
25457: LD_VAR 0 3
25461: PUSH
25462: LD_INT 30
25464: PUSH
25465: EMPTY
25466: LIST
25467: LIST
25468: LIST
25469: PUSH
25470: EMPTY
25471: LIST
25472: LIST
25473: PPUSH
25474: CALL_OW 69
25478: PPUSH
25479: LD_VAR 0 3
25483: PPUSH
25484: CALL_OW 74
25488: PPUSH
25489: CALL_OW 115
// until p > 60 or IsDead ( un ) ;
25493: LD_VAR 0 2
25497: PUSH
25498: LD_INT 60
25500: GREATER
25501: PUSH
25502: LD_VAR 0 3
25506: PPUSH
25507: CALL_OW 301
25511: OR
25512: IFFALSE 25389
// if un then
25514: LD_VAR 0 3
25518: IFFALSE 25529
// RemoveUnit ( un ) ;
25520: LD_VAR 0 3
25524: PPUSH
25525: CALL_OW 64
// end ;
25529: PPOPN 3
25531: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
25532: LD_INT 0
25534: PPUSH
// case cmd of 301 :
25535: LD_VAR 0 1
25539: PUSH
25540: LD_INT 301
25542: DOUBLE
25543: EQUAL
25544: IFTRUE 25548
25546: GO 25580
25548: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
25549: LD_VAR 0 6
25553: PPUSH
25554: LD_VAR 0 7
25558: PPUSH
25559: LD_VAR 0 8
25563: PPUSH
25564: LD_VAR 0 4
25568: PPUSH
25569: LD_VAR 0 5
25573: PPUSH
25574: CALL 26781 0 5
25578: GO 25701
25580: LD_INT 302
25582: DOUBLE
25583: EQUAL
25584: IFTRUE 25588
25586: GO 25625
25588: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
25589: LD_VAR 0 6
25593: PPUSH
25594: LD_VAR 0 7
25598: PPUSH
25599: LD_VAR 0 8
25603: PPUSH
25604: LD_VAR 0 9
25608: PPUSH
25609: LD_VAR 0 4
25613: PPUSH
25614: LD_VAR 0 5
25618: PPUSH
25619: CALL 26872 0 6
25623: GO 25701
25625: LD_INT 303
25627: DOUBLE
25628: EQUAL
25629: IFTRUE 25633
25631: GO 25670
25633: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
25634: LD_VAR 0 6
25638: PPUSH
25639: LD_VAR 0 7
25643: PPUSH
25644: LD_VAR 0 8
25648: PPUSH
25649: LD_VAR 0 9
25653: PPUSH
25654: LD_VAR 0 4
25658: PPUSH
25659: LD_VAR 0 5
25663: PPUSH
25664: CALL 25706 0 6
25668: GO 25701
25670: LD_INT 304
25672: DOUBLE
25673: EQUAL
25674: IFTRUE 25678
25676: GO 25700
25678: POP
// hHackTeleport ( unit , x , y ) ; end ;
25679: LD_VAR 0 2
25683: PPUSH
25684: LD_VAR 0 4
25688: PPUSH
25689: LD_VAR 0 5
25693: PPUSH
25694: CALL 27465 0 3
25698: GO 25701
25700: POP
// end ;
25701: LD_VAR 0 12
25705: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
25706: LD_INT 0
25708: PPUSH
25709: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
25710: LD_VAR 0 1
25714: PUSH
25715: LD_INT 1
25717: LESS
25718: PUSH
25719: LD_VAR 0 1
25723: PUSH
25724: LD_INT 3
25726: GREATER
25727: OR
25728: PUSH
25729: LD_VAR 0 5
25733: PPUSH
25734: LD_VAR 0 6
25738: PPUSH
25739: CALL_OW 428
25743: OR
25744: IFFALSE 25748
// exit ;
25746: GO 26468
// uc_side := your_side ;
25748: LD_ADDR_OWVAR 20
25752: PUSH
25753: LD_OWVAR 2
25757: ST_TO_ADDR
// uc_nation := nation ;
25758: LD_ADDR_OWVAR 21
25762: PUSH
25763: LD_VAR 0 1
25767: ST_TO_ADDR
// bc_level = 1 ;
25768: LD_ADDR_OWVAR 43
25772: PUSH
25773: LD_INT 1
25775: ST_TO_ADDR
// case btype of 1 :
25776: LD_VAR 0 2
25780: PUSH
25781: LD_INT 1
25783: DOUBLE
25784: EQUAL
25785: IFTRUE 25789
25787: GO 25800
25789: POP
// bc_type := b_depot ; 2 :
25790: LD_ADDR_OWVAR 42
25794: PUSH
25795: LD_INT 0
25797: ST_TO_ADDR
25798: GO 26412
25800: LD_INT 2
25802: DOUBLE
25803: EQUAL
25804: IFTRUE 25808
25806: GO 25819
25808: POP
// bc_type := b_warehouse ; 3 :
25809: LD_ADDR_OWVAR 42
25813: PUSH
25814: LD_INT 1
25816: ST_TO_ADDR
25817: GO 26412
25819: LD_INT 3
25821: DOUBLE
25822: EQUAL
25823: IFTRUE 25827
25825: GO 25838
25827: POP
// bc_type := b_lab ; 4 .. 9 :
25828: LD_ADDR_OWVAR 42
25832: PUSH
25833: LD_INT 6
25835: ST_TO_ADDR
25836: GO 26412
25838: LD_INT 4
25840: DOUBLE
25841: GREATEREQUAL
25842: IFFALSE 25850
25844: LD_INT 9
25846: DOUBLE
25847: LESSEQUAL
25848: IFTRUE 25852
25850: GO 25904
25852: POP
// begin bc_type := b_lab_half ;
25853: LD_ADDR_OWVAR 42
25857: PUSH
25858: LD_INT 7
25860: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
25861: LD_ADDR_OWVAR 44
25865: PUSH
25866: LD_INT 10
25868: PUSH
25869: LD_INT 11
25871: PUSH
25872: LD_INT 12
25874: PUSH
25875: LD_INT 15
25877: PUSH
25878: LD_INT 14
25880: PUSH
25881: LD_INT 13
25883: PUSH
25884: EMPTY
25885: LIST
25886: LIST
25887: LIST
25888: LIST
25889: LIST
25890: LIST
25891: PUSH
25892: LD_VAR 0 2
25896: PUSH
25897: LD_INT 3
25899: MINUS
25900: ARRAY
25901: ST_TO_ADDR
// end ; 10 .. 13 :
25902: GO 26412
25904: LD_INT 10
25906: DOUBLE
25907: GREATEREQUAL
25908: IFFALSE 25916
25910: LD_INT 13
25912: DOUBLE
25913: LESSEQUAL
25914: IFTRUE 25918
25916: GO 25995
25918: POP
// begin bc_type := b_lab_full ;
25919: LD_ADDR_OWVAR 42
25923: PUSH
25924: LD_INT 8
25926: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
25927: LD_ADDR_OWVAR 44
25931: PUSH
25932: LD_INT 10
25934: PUSH
25935: LD_INT 12
25937: PUSH
25938: LD_INT 14
25940: PUSH
25941: LD_INT 13
25943: PUSH
25944: EMPTY
25945: LIST
25946: LIST
25947: LIST
25948: LIST
25949: PUSH
25950: LD_VAR 0 2
25954: PUSH
25955: LD_INT 9
25957: MINUS
25958: ARRAY
25959: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
25960: LD_ADDR_OWVAR 45
25964: PUSH
25965: LD_INT 11
25967: PUSH
25968: LD_INT 15
25970: PUSH
25971: LD_INT 12
25973: PUSH
25974: LD_INT 15
25976: PUSH
25977: EMPTY
25978: LIST
25979: LIST
25980: LIST
25981: LIST
25982: PUSH
25983: LD_VAR 0 2
25987: PUSH
25988: LD_INT 9
25990: MINUS
25991: ARRAY
25992: ST_TO_ADDR
// end ; 14 :
25993: GO 26412
25995: LD_INT 14
25997: DOUBLE
25998: EQUAL
25999: IFTRUE 26003
26001: GO 26014
26003: POP
// bc_type := b_workshop ; 15 :
26004: LD_ADDR_OWVAR 42
26008: PUSH
26009: LD_INT 2
26011: ST_TO_ADDR
26012: GO 26412
26014: LD_INT 15
26016: DOUBLE
26017: EQUAL
26018: IFTRUE 26022
26020: GO 26033
26022: POP
// bc_type := b_factory ; 16 :
26023: LD_ADDR_OWVAR 42
26027: PUSH
26028: LD_INT 3
26030: ST_TO_ADDR
26031: GO 26412
26033: LD_INT 16
26035: DOUBLE
26036: EQUAL
26037: IFTRUE 26041
26039: GO 26052
26041: POP
// bc_type := b_ext_gun ; 17 :
26042: LD_ADDR_OWVAR 42
26046: PUSH
26047: LD_INT 17
26049: ST_TO_ADDR
26050: GO 26412
26052: LD_INT 17
26054: DOUBLE
26055: EQUAL
26056: IFTRUE 26060
26058: GO 26088
26060: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
26061: LD_ADDR_OWVAR 42
26065: PUSH
26066: LD_INT 19
26068: PUSH
26069: LD_INT 23
26071: PUSH
26072: LD_INT 19
26074: PUSH
26075: EMPTY
26076: LIST
26077: LIST
26078: LIST
26079: PUSH
26080: LD_VAR 0 1
26084: ARRAY
26085: ST_TO_ADDR
26086: GO 26412
26088: LD_INT 18
26090: DOUBLE
26091: EQUAL
26092: IFTRUE 26096
26094: GO 26107
26096: POP
// bc_type := b_ext_radar ; 19 :
26097: LD_ADDR_OWVAR 42
26101: PUSH
26102: LD_INT 20
26104: ST_TO_ADDR
26105: GO 26412
26107: LD_INT 19
26109: DOUBLE
26110: EQUAL
26111: IFTRUE 26115
26113: GO 26126
26115: POP
// bc_type := b_ext_radio ; 20 :
26116: LD_ADDR_OWVAR 42
26120: PUSH
26121: LD_INT 22
26123: ST_TO_ADDR
26124: GO 26412
26126: LD_INT 20
26128: DOUBLE
26129: EQUAL
26130: IFTRUE 26134
26132: GO 26145
26134: POP
// bc_type := b_ext_siberium ; 21 :
26135: LD_ADDR_OWVAR 42
26139: PUSH
26140: LD_INT 21
26142: ST_TO_ADDR
26143: GO 26412
26145: LD_INT 21
26147: DOUBLE
26148: EQUAL
26149: IFTRUE 26153
26151: GO 26164
26153: POP
// bc_type := b_ext_computer ; 22 :
26154: LD_ADDR_OWVAR 42
26158: PUSH
26159: LD_INT 24
26161: ST_TO_ADDR
26162: GO 26412
26164: LD_INT 22
26166: DOUBLE
26167: EQUAL
26168: IFTRUE 26172
26170: GO 26183
26172: POP
// bc_type := b_ext_track ; 23 :
26173: LD_ADDR_OWVAR 42
26177: PUSH
26178: LD_INT 16
26180: ST_TO_ADDR
26181: GO 26412
26183: LD_INT 23
26185: DOUBLE
26186: EQUAL
26187: IFTRUE 26191
26189: GO 26202
26191: POP
// bc_type := b_ext_laser ; 24 :
26192: LD_ADDR_OWVAR 42
26196: PUSH
26197: LD_INT 25
26199: ST_TO_ADDR
26200: GO 26412
26202: LD_INT 24
26204: DOUBLE
26205: EQUAL
26206: IFTRUE 26210
26208: GO 26221
26210: POP
// bc_type := b_control_tower ; 25 :
26211: LD_ADDR_OWVAR 42
26215: PUSH
26216: LD_INT 36
26218: ST_TO_ADDR
26219: GO 26412
26221: LD_INT 25
26223: DOUBLE
26224: EQUAL
26225: IFTRUE 26229
26227: GO 26240
26229: POP
// bc_type := b_breastwork ; 26 :
26230: LD_ADDR_OWVAR 42
26234: PUSH
26235: LD_INT 31
26237: ST_TO_ADDR
26238: GO 26412
26240: LD_INT 26
26242: DOUBLE
26243: EQUAL
26244: IFTRUE 26248
26246: GO 26259
26248: POP
// bc_type := b_bunker ; 27 :
26249: LD_ADDR_OWVAR 42
26253: PUSH
26254: LD_INT 32
26256: ST_TO_ADDR
26257: GO 26412
26259: LD_INT 27
26261: DOUBLE
26262: EQUAL
26263: IFTRUE 26267
26265: GO 26278
26267: POP
// bc_type := b_turret ; 28 :
26268: LD_ADDR_OWVAR 42
26272: PUSH
26273: LD_INT 33
26275: ST_TO_ADDR
26276: GO 26412
26278: LD_INT 28
26280: DOUBLE
26281: EQUAL
26282: IFTRUE 26286
26284: GO 26297
26286: POP
// bc_type := b_armoury ; 29 :
26287: LD_ADDR_OWVAR 42
26291: PUSH
26292: LD_INT 4
26294: ST_TO_ADDR
26295: GO 26412
26297: LD_INT 29
26299: DOUBLE
26300: EQUAL
26301: IFTRUE 26305
26303: GO 26316
26305: POP
// bc_type := b_barracks ; 30 :
26306: LD_ADDR_OWVAR 42
26310: PUSH
26311: LD_INT 5
26313: ST_TO_ADDR
26314: GO 26412
26316: LD_INT 30
26318: DOUBLE
26319: EQUAL
26320: IFTRUE 26324
26322: GO 26335
26324: POP
// bc_type := b_solar_power ; 31 :
26325: LD_ADDR_OWVAR 42
26329: PUSH
26330: LD_INT 27
26332: ST_TO_ADDR
26333: GO 26412
26335: LD_INT 31
26337: DOUBLE
26338: EQUAL
26339: IFTRUE 26343
26341: GO 26354
26343: POP
// bc_type := b_oil_power ; 32 :
26344: LD_ADDR_OWVAR 42
26348: PUSH
26349: LD_INT 26
26351: ST_TO_ADDR
26352: GO 26412
26354: LD_INT 32
26356: DOUBLE
26357: EQUAL
26358: IFTRUE 26362
26360: GO 26373
26362: POP
// bc_type := b_siberite_power ; 33 :
26363: LD_ADDR_OWVAR 42
26367: PUSH
26368: LD_INT 28
26370: ST_TO_ADDR
26371: GO 26412
26373: LD_INT 33
26375: DOUBLE
26376: EQUAL
26377: IFTRUE 26381
26379: GO 26392
26381: POP
// bc_type := b_oil_mine ; 34 :
26382: LD_ADDR_OWVAR 42
26386: PUSH
26387: LD_INT 29
26389: ST_TO_ADDR
26390: GO 26412
26392: LD_INT 34
26394: DOUBLE
26395: EQUAL
26396: IFTRUE 26400
26398: GO 26411
26400: POP
// bc_type := b_siberite_mine ; end ;
26401: LD_ADDR_OWVAR 42
26405: PUSH
26406: LD_INT 30
26408: ST_TO_ADDR
26409: GO 26412
26411: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
26412: LD_ADDR_VAR 0 8
26416: PUSH
26417: LD_VAR 0 5
26421: PPUSH
26422: LD_VAR 0 6
26426: PPUSH
26427: LD_VAR 0 3
26431: PPUSH
26432: CALL_OW 47
26436: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
26437: LD_OWVAR 42
26441: PUSH
26442: LD_INT 32
26444: PUSH
26445: LD_INT 33
26447: PUSH
26448: EMPTY
26449: LIST
26450: LIST
26451: IN
26452: IFFALSE 26468
// PlaceWeaponTurret ( b , weapon ) ;
26454: LD_VAR 0 8
26458: PPUSH
26459: LD_VAR 0 4
26463: PPUSH
26464: CALL_OW 431
// end ;
26468: LD_VAR 0 7
26472: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
26473: LD_INT 0
26475: PPUSH
26476: PPUSH
26477: PPUSH
26478: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
26479: LD_ADDR_VAR 0 4
26483: PUSH
26484: LD_INT 22
26486: PUSH
26487: LD_OWVAR 2
26491: PUSH
26492: EMPTY
26493: LIST
26494: LIST
26495: PUSH
26496: LD_INT 2
26498: PUSH
26499: LD_INT 30
26501: PUSH
26502: LD_INT 0
26504: PUSH
26505: EMPTY
26506: LIST
26507: LIST
26508: PUSH
26509: LD_INT 30
26511: PUSH
26512: LD_INT 1
26514: PUSH
26515: EMPTY
26516: LIST
26517: LIST
26518: PUSH
26519: EMPTY
26520: LIST
26521: LIST
26522: LIST
26523: PUSH
26524: EMPTY
26525: LIST
26526: LIST
26527: PPUSH
26528: CALL_OW 69
26532: ST_TO_ADDR
// if not tmp then
26533: LD_VAR 0 4
26537: NOT
26538: IFFALSE 26542
// exit ;
26540: GO 26601
// for i in tmp do
26542: LD_ADDR_VAR 0 2
26546: PUSH
26547: LD_VAR 0 4
26551: PUSH
26552: FOR_IN
26553: IFFALSE 26599
// for j = 1 to 3 do
26555: LD_ADDR_VAR 0 3
26559: PUSH
26560: DOUBLE
26561: LD_INT 1
26563: DEC
26564: ST_TO_ADDR
26565: LD_INT 3
26567: PUSH
26568: FOR_TO
26569: IFFALSE 26595
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
26571: LD_VAR 0 2
26575: PPUSH
26576: CALL_OW 274
26580: PPUSH
26581: LD_VAR 0 3
26585: PPUSH
26586: LD_INT 99999
26588: PPUSH
26589: CALL_OW 277
26593: GO 26568
26595: POP
26596: POP
26597: GO 26552
26599: POP
26600: POP
// end ;
26601: LD_VAR 0 1
26605: RET
// export function hHackSetLevel10 ; var i , j ; begin
26606: LD_INT 0
26608: PPUSH
26609: PPUSH
26610: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
26611: LD_ADDR_VAR 0 2
26615: PUSH
26616: LD_INT 21
26618: PUSH
26619: LD_INT 1
26621: PUSH
26622: EMPTY
26623: LIST
26624: LIST
26625: PPUSH
26626: CALL_OW 69
26630: PUSH
26631: FOR_IN
26632: IFFALSE 26684
// if IsSelected ( i ) then
26634: LD_VAR 0 2
26638: PPUSH
26639: CALL_OW 306
26643: IFFALSE 26682
// begin for j := 1 to 4 do
26645: LD_ADDR_VAR 0 3
26649: PUSH
26650: DOUBLE
26651: LD_INT 1
26653: DEC
26654: ST_TO_ADDR
26655: LD_INT 4
26657: PUSH
26658: FOR_TO
26659: IFFALSE 26680
// SetSkill ( i , j , 10 ) ;
26661: LD_VAR 0 2
26665: PPUSH
26666: LD_VAR 0 3
26670: PPUSH
26671: LD_INT 10
26673: PPUSH
26674: CALL_OW 237
26678: GO 26658
26680: POP
26681: POP
// end ;
26682: GO 26631
26684: POP
26685: POP
// end ;
26686: LD_VAR 0 1
26690: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
26691: LD_INT 0
26693: PPUSH
26694: PPUSH
26695: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
26696: LD_ADDR_VAR 0 2
26700: PUSH
26701: LD_INT 22
26703: PUSH
26704: LD_OWVAR 2
26708: PUSH
26709: EMPTY
26710: LIST
26711: LIST
26712: PUSH
26713: LD_INT 21
26715: PUSH
26716: LD_INT 1
26718: PUSH
26719: EMPTY
26720: LIST
26721: LIST
26722: PUSH
26723: EMPTY
26724: LIST
26725: LIST
26726: PPUSH
26727: CALL_OW 69
26731: PUSH
26732: FOR_IN
26733: IFFALSE 26774
// begin for j := 1 to 4 do
26735: LD_ADDR_VAR 0 3
26739: PUSH
26740: DOUBLE
26741: LD_INT 1
26743: DEC
26744: ST_TO_ADDR
26745: LD_INT 4
26747: PUSH
26748: FOR_TO
26749: IFFALSE 26770
// SetSkill ( i , j , 10 ) ;
26751: LD_VAR 0 2
26755: PPUSH
26756: LD_VAR 0 3
26760: PPUSH
26761: LD_INT 10
26763: PPUSH
26764: CALL_OW 237
26768: GO 26748
26770: POP
26771: POP
// end ;
26772: GO 26732
26774: POP
26775: POP
// end ;
26776: LD_VAR 0 1
26780: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
26781: LD_INT 0
26783: PPUSH
// uc_side := your_side ;
26784: LD_ADDR_OWVAR 20
26788: PUSH
26789: LD_OWVAR 2
26793: ST_TO_ADDR
// uc_nation := nation ;
26794: LD_ADDR_OWVAR 21
26798: PUSH
26799: LD_VAR 0 1
26803: ST_TO_ADDR
// InitHc ;
26804: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
26808: LD_INT 0
26810: PPUSH
26811: LD_VAR 0 2
26815: PPUSH
26816: LD_VAR 0 3
26820: PPUSH
26821: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
26825: LD_VAR 0 4
26829: PPUSH
26830: LD_VAR 0 5
26834: PPUSH
26835: CALL_OW 428
26839: PUSH
26840: LD_INT 0
26842: EQUAL
26843: IFFALSE 26867
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
26845: CALL_OW 44
26849: PPUSH
26850: LD_VAR 0 4
26854: PPUSH
26855: LD_VAR 0 5
26859: PPUSH
26860: LD_INT 1
26862: PPUSH
26863: CALL_OW 48
// end ;
26867: LD_VAR 0 6
26871: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
26872: LD_INT 0
26874: PPUSH
26875: PPUSH
// uc_side := your_side ;
26876: LD_ADDR_OWVAR 20
26880: PUSH
26881: LD_OWVAR 2
26885: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
26886: LD_VAR 0 1
26890: PUSH
26891: LD_INT 1
26893: PUSH
26894: LD_INT 2
26896: PUSH
26897: LD_INT 3
26899: PUSH
26900: LD_INT 4
26902: PUSH
26903: LD_INT 5
26905: PUSH
26906: EMPTY
26907: LIST
26908: LIST
26909: LIST
26910: LIST
26911: LIST
26912: IN
26913: IFFALSE 26925
// uc_nation := nation_american else
26915: LD_ADDR_OWVAR 21
26919: PUSH
26920: LD_INT 1
26922: ST_TO_ADDR
26923: GO 26968
// if chassis in [ 11 , 12 , 13 , 14 ] then
26925: LD_VAR 0 1
26929: PUSH
26930: LD_INT 11
26932: PUSH
26933: LD_INT 12
26935: PUSH
26936: LD_INT 13
26938: PUSH
26939: LD_INT 14
26941: PUSH
26942: EMPTY
26943: LIST
26944: LIST
26945: LIST
26946: LIST
26947: IN
26948: IFFALSE 26960
// uc_nation := nation_arabian else
26950: LD_ADDR_OWVAR 21
26954: PUSH
26955: LD_INT 2
26957: ST_TO_ADDR
26958: GO 26968
// uc_nation := nation_russian ;
26960: LD_ADDR_OWVAR 21
26964: PUSH
26965: LD_INT 3
26967: ST_TO_ADDR
// vc_chassis := chassis ;
26968: LD_ADDR_OWVAR 37
26972: PUSH
26973: LD_VAR 0 1
26977: ST_TO_ADDR
// vc_engine := engine ;
26978: LD_ADDR_OWVAR 39
26982: PUSH
26983: LD_VAR 0 2
26987: ST_TO_ADDR
// vc_control := control ;
26988: LD_ADDR_OWVAR 38
26992: PUSH
26993: LD_VAR 0 3
26997: ST_TO_ADDR
// vc_weapon := weapon ;
26998: LD_ADDR_OWVAR 40
27002: PUSH
27003: LD_VAR 0 4
27007: ST_TO_ADDR
// un := CreateVehicle ;
27008: LD_ADDR_VAR 0 8
27012: PUSH
27013: CALL_OW 45
27017: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
27018: LD_VAR 0 8
27022: PPUSH
27023: LD_INT 0
27025: PPUSH
27026: LD_INT 5
27028: PPUSH
27029: CALL_OW 12
27033: PPUSH
27034: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
27038: LD_VAR 0 8
27042: PPUSH
27043: LD_VAR 0 5
27047: PPUSH
27048: LD_VAR 0 6
27052: PPUSH
27053: LD_INT 1
27055: PPUSH
27056: CALL_OW 48
// end ;
27060: LD_VAR 0 7
27064: RET
// export hInvincible ; every 1 do
27065: GO 27067
27067: DISABLE
// hInvincible := [ ] ;
27068: LD_ADDR_EXP 111
27072: PUSH
27073: EMPTY
27074: ST_TO_ADDR
27075: END
// every 10 do var i ;
27076: GO 27078
27078: DISABLE
27079: LD_INT 0
27081: PPUSH
// begin enable ;
27082: ENABLE
// if not hInvincible then
27083: LD_EXP 111
27087: NOT
27088: IFFALSE 27092
// exit ;
27090: GO 27136
// for i in hInvincible do
27092: LD_ADDR_VAR 0 1
27096: PUSH
27097: LD_EXP 111
27101: PUSH
27102: FOR_IN
27103: IFFALSE 27134
// if GetLives ( i ) < 1000 then
27105: LD_VAR 0 1
27109: PPUSH
27110: CALL_OW 256
27114: PUSH
27115: LD_INT 1000
27117: LESS
27118: IFFALSE 27132
// SetLives ( i , 1000 ) ;
27120: LD_VAR 0 1
27124: PPUSH
27125: LD_INT 1000
27127: PPUSH
27128: CALL_OW 234
27132: GO 27102
27134: POP
27135: POP
// end ;
27136: PPOPN 1
27138: END
// export function hHackInvincible ; var i ; begin
27139: LD_INT 0
27141: PPUSH
27142: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
27143: LD_ADDR_VAR 0 2
27147: PUSH
27148: LD_INT 2
27150: PUSH
27151: LD_INT 21
27153: PUSH
27154: LD_INT 1
27156: PUSH
27157: EMPTY
27158: LIST
27159: LIST
27160: PUSH
27161: LD_INT 21
27163: PUSH
27164: LD_INT 2
27166: PUSH
27167: EMPTY
27168: LIST
27169: LIST
27170: PUSH
27171: EMPTY
27172: LIST
27173: LIST
27174: LIST
27175: PPUSH
27176: CALL_OW 69
27180: PUSH
27181: FOR_IN
27182: IFFALSE 27243
// if IsSelected ( i ) then
27184: LD_VAR 0 2
27188: PPUSH
27189: CALL_OW 306
27193: IFFALSE 27241
// begin if i in hInvincible then
27195: LD_VAR 0 2
27199: PUSH
27200: LD_EXP 111
27204: IN
27205: IFFALSE 27225
// hInvincible := hInvincible diff i else
27207: LD_ADDR_EXP 111
27211: PUSH
27212: LD_EXP 111
27216: PUSH
27217: LD_VAR 0 2
27221: DIFF
27222: ST_TO_ADDR
27223: GO 27241
// hInvincible := hInvincible union i ;
27225: LD_ADDR_EXP 111
27229: PUSH
27230: LD_EXP 111
27234: PUSH
27235: LD_VAR 0 2
27239: UNION
27240: ST_TO_ADDR
// end ;
27241: GO 27181
27243: POP
27244: POP
// end ;
27245: LD_VAR 0 1
27249: RET
// export function hHackInvisible ; var i , j ; begin
27250: LD_INT 0
27252: PPUSH
27253: PPUSH
27254: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
27255: LD_ADDR_VAR 0 2
27259: PUSH
27260: LD_INT 21
27262: PUSH
27263: LD_INT 1
27265: PUSH
27266: EMPTY
27267: LIST
27268: LIST
27269: PPUSH
27270: CALL_OW 69
27274: PUSH
27275: FOR_IN
27276: IFFALSE 27300
// if IsSelected ( i ) then
27278: LD_VAR 0 2
27282: PPUSH
27283: CALL_OW 306
27287: IFFALSE 27298
// ComForceInvisible ( i ) ;
27289: LD_VAR 0 2
27293: PPUSH
27294: CALL_OW 496
27298: GO 27275
27300: POP
27301: POP
// end ;
27302: LD_VAR 0 1
27306: RET
// export function hHackChangeYourSide ; begin
27307: LD_INT 0
27309: PPUSH
// if your_side = 8 then
27310: LD_OWVAR 2
27314: PUSH
27315: LD_INT 8
27317: EQUAL
27318: IFFALSE 27330
// your_side := 0 else
27320: LD_ADDR_OWVAR 2
27324: PUSH
27325: LD_INT 0
27327: ST_TO_ADDR
27328: GO 27344
// your_side := your_side + 1 ;
27330: LD_ADDR_OWVAR 2
27334: PUSH
27335: LD_OWVAR 2
27339: PUSH
27340: LD_INT 1
27342: PLUS
27343: ST_TO_ADDR
// end ;
27344: LD_VAR 0 1
27348: RET
// export function hHackChangeUnitSide ; var i , j ; begin
27349: LD_INT 0
27351: PPUSH
27352: PPUSH
27353: PPUSH
// for i in all_units do
27354: LD_ADDR_VAR 0 2
27358: PUSH
27359: LD_OWVAR 3
27363: PUSH
27364: FOR_IN
27365: IFFALSE 27443
// if IsSelected ( i ) then
27367: LD_VAR 0 2
27371: PPUSH
27372: CALL_OW 306
27376: IFFALSE 27441
// begin j := GetSide ( i ) ;
27378: LD_ADDR_VAR 0 3
27382: PUSH
27383: LD_VAR 0 2
27387: PPUSH
27388: CALL_OW 255
27392: ST_TO_ADDR
// if j = 8 then
27393: LD_VAR 0 3
27397: PUSH
27398: LD_INT 8
27400: EQUAL
27401: IFFALSE 27413
// j := 0 else
27403: LD_ADDR_VAR 0 3
27407: PUSH
27408: LD_INT 0
27410: ST_TO_ADDR
27411: GO 27427
// j := j + 1 ;
27413: LD_ADDR_VAR 0 3
27417: PUSH
27418: LD_VAR 0 3
27422: PUSH
27423: LD_INT 1
27425: PLUS
27426: ST_TO_ADDR
// SetSide ( i , j ) ;
27427: LD_VAR 0 2
27431: PPUSH
27432: LD_VAR 0 3
27436: PPUSH
27437: CALL_OW 235
// end ;
27441: GO 27364
27443: POP
27444: POP
// end ;
27445: LD_VAR 0 1
27449: RET
// export function hHackFog ; begin
27450: LD_INT 0
27452: PPUSH
// FogOff ( true ) ;
27453: LD_INT 1
27455: PPUSH
27456: CALL_OW 344
// end ;
27460: LD_VAR 0 1
27464: RET
// export function hHackTeleport ( unit , x , y ) ; begin
27465: LD_INT 0
27467: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
27468: LD_VAR 0 1
27472: PPUSH
27473: LD_VAR 0 2
27477: PPUSH
27478: LD_VAR 0 3
27482: PPUSH
27483: LD_INT 1
27485: PPUSH
27486: LD_INT 1
27488: PPUSH
27489: CALL_OW 483
// CenterOnXY ( x , y ) ;
27493: LD_VAR 0 2
27497: PPUSH
27498: LD_VAR 0 3
27502: PPUSH
27503: CALL_OW 84
// end ;
27507: LD_VAR 0 4
27511: RET
