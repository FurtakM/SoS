// export you , americans , arabians , neutral ; export rulive ; export savedTanks ; starting begin Resetfog ;
   0: CALL_OW 335
// InGameOn ;
   4: CALL_OW 8
// savedTanks = [ ] ;
   8: LD_ADDR_EXP 6
  12: PUSH
  13: EMPTY
  14: ST_TO_ADDR
// disable ( 10 ) ;
  15: LD_INT 10
  17: DISABLE_MARKED
// set_sides ;
  18: CALL 56 0 0
// load_chars ;
  22: CALL 96 0 0
// place_in_ru_cars ;
  26: CALL 760 0 0
// place_ru_cars ( ru_place ) ;
  30: LD_INT 1
  32: PPUSH
  33: CALL 1290 0 1
// DIntro ;
  37: CALL 1581 0 0
// Save ;
  41: CALL 1420 0 0
// ChangeMap ( %_cont , %_cont ) ;
  45: LD_STRING %_cont
  47: PPUSH
  48: LD_STRING %_cont
  50: PPUSH
  51: CALL_OW 340
// end ;
  55: END
// function set_sides ; begin
  56: LD_INT 0
  58: PPUSH
// you := 3 ;
  59: LD_ADDR_EXP 1
  63: PUSH
  64: LD_INT 3
  66: ST_TO_ADDR
// americans := 1 ;
  67: LD_ADDR_EXP 2
  71: PUSH
  72: LD_INT 1
  74: ST_TO_ADDR
// arabians := 2 ;
  75: LD_ADDR_EXP 3
  79: PUSH
  80: LD_INT 2
  82: ST_TO_ADDR
// neutral := 0 ;
  83: LD_ADDR_EXP 4
  87: PUSH
  88: LD_INT 0
  90: ST_TO_ADDR
// end ; end_of_file
  91: LD_VAR 0 1
  95: RET
// export Burlak , Platonov , Karamazov , Petrovova , Gleb , Petrosyan , Dolgov , Lipshchin , Titov ; export used , ru_cars , other_from6i ; export function load_chars ; var i , so , en , me , sc ; begin
  96: LD_INT 0
  98: PPUSH
  99: PPUSH
 100: PPUSH
 101: PPUSH
 102: PPUSH
 103: PPUSH
// InitUc ;
 104: CALL_OW 18
// InitHc ;
 108: CALL_OW 19
// uc_side := you ;
 112: LD_ADDR_OWVAR 20
 116: PUSH
 117: LD_EXP 1
 121: ST_TO_ADDR
// uc_nation := nation_russian ;
 122: LD_ADDR_OWVAR 21
 126: PUSH
 127: LD_INT 3
 129: ST_TO_ADDR
// Platonov := MyCreateCharacter ( Platonov , 0 , class_soldier , true ) ;
 130: LD_ADDR_EXP 8
 134: PUSH
 135: LD_STRING Platonov
 137: PPUSH
 138: LD_INT 0
 140: PPUSH
 141: LD_INT 1
 143: PPUSH
 144: LD_INT 1
 146: PPUSH
 147: CALL 1333 0 4
 151: ST_TO_ADDR
// Burlak := MyCreateCharacter ( 04_Burlak , 0 , class_mechanic , false ) ;
 152: LD_ADDR_EXP 7
 156: PUSH
 157: LD_STRING 04_Burlak
 159: PPUSH
 160: LD_INT 0
 162: PPUSH
 163: LD_INT 3
 165: PPUSH
 166: LD_INT 0
 168: PPUSH
 169: CALL 1333 0 4
 173: ST_TO_ADDR
// Karamazov := MyCreateCharacter ( Karamazov , 0 , class_engineer , true ) ;
 174: LD_ADDR_EXP 9
 178: PUSH
 179: LD_STRING Karamazov
 181: PPUSH
 182: LD_INT 0
 184: PPUSH
 185: LD_INT 2
 187: PPUSH
 188: LD_INT 1
 190: PPUSH
 191: CALL 1333 0 4
 195: ST_TO_ADDR
// Petrovova := MyCreateCharacter ( Petrovova , 0 , class_soldier , true ) ;
 196: LD_ADDR_EXP 10
 200: PUSH
 201: LD_STRING Petrovova
 203: PPUSH
 204: LD_INT 0
 206: PPUSH
 207: LD_INT 1
 209: PPUSH
 210: LD_INT 1
 212: PPUSH
 213: CALL 1333 0 4
 217: ST_TO_ADDR
// Gleb := MyCreateCharacter ( Gleb , 0 , class_soldier , true ) ;
 218: LD_ADDR_EXP 11
 222: PUSH
 223: LD_STRING Gleb
 225: PPUSH
 226: LD_INT 0
 228: PPUSH
 229: LD_INT 1
 231: PPUSH
 232: LD_INT 1
 234: PPUSH
 235: CALL 1333 0 4
 239: ST_TO_ADDR
// Petrosyan := MyCreateCharacter ( Petrosyan , 0 , class_scientistic , true ) ;
 240: LD_ADDR_EXP 12
 244: PUSH
 245: LD_STRING Petrosyan
 247: PPUSH
 248: LD_INT 0
 250: PPUSH
 251: LD_INT 4
 253: PPUSH
 254: LD_INT 1
 256: PPUSH
 257: CALL 1333 0 4
 261: ST_TO_ADDR
// Dolgov := MyCreateCharacter ( Dolgov , 0 , class_scientistic , true ) ;
 262: LD_ADDR_EXP 13
 266: PUSH
 267: LD_STRING Dolgov
 269: PPUSH
 270: LD_INT 0
 272: PPUSH
 273: LD_INT 4
 275: PPUSH
 276: LD_INT 1
 278: PPUSH
 279: CALL 1333 0 4
 283: ST_TO_ADDR
// Lipshchin := MyCreateCharacter ( Lipshchin , 0 , class_soldier , true ) ;
 284: LD_ADDR_EXP 14
 288: PUSH
 289: LD_STRING Lipshchin
 291: PPUSH
 292: LD_INT 0
 294: PPUSH
 295: LD_INT 1
 297: PPUSH
 298: LD_INT 1
 300: PPUSH
 301: CALL 1333 0 4
 305: ST_TO_ADDR
// Titov := MyCreateCharacter ( Titov , 0 , class_soldier , true ) ;
 306: LD_ADDR_EXP 15
 310: PUSH
 311: LD_STRING Titov
 313: PPUSH
 314: LD_INT 0
 316: PPUSH
 317: LD_INT 1
 319: PPUSH
 320: LD_INT 1
 322: PPUSH
 323: CALL 1333 0 4
 327: ST_TO_ADDR
// used := [ Burlak , Karamazov , Petrovova , Gleb , Petrosyan , Lipshchin , Dolgov , Titov ] diff 0 ;
 328: LD_ADDR_EXP 16
 332: PUSH
 333: LD_EXP 7
 337: PUSH
 338: LD_EXP 9
 342: PUSH
 343: LD_EXP 10
 347: PUSH
 348: LD_EXP 11
 352: PUSH
 353: LD_EXP 12
 357: PUSH
 358: LD_EXP 14
 362: PUSH
 363: LD_EXP 13
 367: PUSH
 368: LD_EXP 15
 372: PUSH
 373: EMPTY
 374: LIST
 375: LIST
 376: LIST
 377: LIST
 378: LIST
 379: LIST
 380: LIST
 381: LIST
 382: PUSH
 383: LD_INT 0
 385: DIFF
 386: ST_TO_ADDR
// so := ( UnitFilter ( used , [ [ f_class , class_soldier ] ] ) + 0 ) ;
 387: LD_ADDR_VAR 0 3
 391: PUSH
 392: LD_EXP 16
 396: PPUSH
 397: LD_INT 25
 399: PUSH
 400: LD_INT 1
 402: PUSH
 403: EMPTY
 404: LIST
 405: LIST
 406: PUSH
 407: EMPTY
 408: LIST
 409: PPUSH
 410: CALL_OW 72
 414: PUSH
 415: LD_INT 0
 417: PLUS
 418: ST_TO_ADDR
// en := ( UnitFilter ( used , [ [ f_class , class_engineer ] ] ) + 0 ) ;
 419: LD_ADDR_VAR 0 4
 423: PUSH
 424: LD_EXP 16
 428: PPUSH
 429: LD_INT 25
 431: PUSH
 432: LD_INT 2
 434: PUSH
 435: EMPTY
 436: LIST
 437: LIST
 438: PUSH
 439: EMPTY
 440: LIST
 441: PPUSH
 442: CALL_OW 72
 446: PUSH
 447: LD_INT 0
 449: PLUS
 450: ST_TO_ADDR
// me := ( UnitFilter ( used , [ [ f_class , class_mechanic ] ] ) + 0 ) ;
 451: LD_ADDR_VAR 0 5
 455: PUSH
 456: LD_EXP 16
 460: PPUSH
 461: LD_INT 25
 463: PUSH
 464: LD_INT 3
 466: PUSH
 467: EMPTY
 468: LIST
 469: LIST
 470: PUSH
 471: EMPTY
 472: LIST
 473: PPUSH
 474: CALL_OW 72
 478: PUSH
 479: LD_INT 0
 481: PLUS
 482: ST_TO_ADDR
// sc := ( UnitFilter ( used , [ [ f_class , class_scientistic ] ] ) + 0 ) ;
 483: LD_ADDR_VAR 0 6
 487: PUSH
 488: LD_EXP 16
 492: PPUSH
 493: LD_INT 25
 495: PUSH
 496: LD_INT 4
 498: PUSH
 499: EMPTY
 500: LIST
 501: LIST
 502: PUSH
 503: EMPTY
 504: LIST
 505: PPUSH
 506: CALL_OW 72
 510: PUSH
 511: LD_INT 0
 513: PLUS
 514: ST_TO_ADDR
// for i := so to 4 do
 515: LD_ADDR_VAR 0 2
 519: PUSH
 520: DOUBLE
 521: LD_VAR 0 3
 525: DEC
 526: ST_TO_ADDR
 527: LD_INT 4
 529: PUSH
 530: FOR_TO
 531: IFFALSE 573
// begin PrepareSoldier ( Rand ( 10 , 23 ) div 10 , 3 ) ;
 533: LD_INT 10
 535: PPUSH
 536: LD_INT 23
 538: PPUSH
 539: CALL_OW 12
 543: PUSH
 544: LD_INT 10
 546: DIV
 547: PPUSH
 548: LD_INT 3
 550: PPUSH
 551: CALL_OW 381
// used := used ^ CreateHuman ;
 555: LD_ADDR_EXP 16
 559: PUSH
 560: LD_EXP 16
 564: PUSH
 565: CALL_OW 44
 569: ADD
 570: ST_TO_ADDR
// end ;
 571: GO 530
 573: POP
 574: POP
// for i := en to 1 do
 575: LD_ADDR_VAR 0 2
 579: PUSH
 580: DOUBLE
 581: LD_VAR 0 4
 585: DEC
 586: ST_TO_ADDR
 587: LD_INT 1
 589: PUSH
 590: FOR_TO
 591: IFFALSE 633
// begin PrepareEngineer ( Rand ( 10 , 23 ) div 10 , 3 ) ;
 593: LD_INT 10
 595: PPUSH
 596: LD_INT 23
 598: PPUSH
 599: CALL_OW 12
 603: PUSH
 604: LD_INT 10
 606: DIV
 607: PPUSH
 608: LD_INT 3
 610: PPUSH
 611: CALL_OW 382
// used := used ^ CreateHuman ;
 615: LD_ADDR_EXP 16
 619: PUSH
 620: LD_EXP 16
 624: PUSH
 625: CALL_OW 44
 629: ADD
 630: ST_TO_ADDR
// end ;
 631: GO 590
 633: POP
 634: POP
// for i := me to 1 do
 635: LD_ADDR_VAR 0 2
 639: PUSH
 640: DOUBLE
 641: LD_VAR 0 5
 645: DEC
 646: ST_TO_ADDR
 647: LD_INT 1
 649: PUSH
 650: FOR_TO
 651: IFFALSE 693
// begin PrepareMechanic ( Rand ( 10 , 23 ) div 10 , 3 ) ;
 653: LD_INT 10
 655: PPUSH
 656: LD_INT 23
 658: PPUSH
 659: CALL_OW 12
 663: PUSH
 664: LD_INT 10
 666: DIV
 667: PPUSH
 668: LD_INT 3
 670: PPUSH
 671: CALL_OW 383
// used := used ^ CreateHuman ;
 675: LD_ADDR_EXP 16
 679: PUSH
 680: LD_EXP 16
 684: PUSH
 685: CALL_OW 44
 689: ADD
 690: ST_TO_ADDR
// end ;
 691: GO 650
 693: POP
 694: POP
// for i := sc to 2 do
 695: LD_ADDR_VAR 0 2
 699: PUSH
 700: DOUBLE
 701: LD_VAR 0 6
 705: DEC
 706: ST_TO_ADDR
 707: LD_INT 2
 709: PUSH
 710: FOR_TO
 711: IFFALSE 753
// begin PrepareScientist ( Rand ( 10 , 23 ) div 10 , 3 ) ;
 713: LD_INT 10
 715: PPUSH
 716: LD_INT 23
 718: PPUSH
 719: CALL_OW 12
 723: PUSH
 724: LD_INT 10
 726: DIV
 727: PPUSH
 728: LD_INT 3
 730: PPUSH
 731: CALL_OW 384
// used := used ^ CreateHuman ;
 735: LD_ADDR_EXP 16
 739: PUSH
 740: LD_EXP 16
 744: PUSH
 745: CALL_OW 44
 749: ADD
 750: ST_TO_ADDR
// end ;
 751: GO 710
 753: POP
 754: POP
// end ;
 755: LD_VAR 0 1
 759: RET
// export function place_in_ru_cars ; var cars , car , i , rnd ; begin
 760: LD_INT 0
 762: PPUSH
 763: PPUSH
 764: PPUSH
 765: PPUSH
 766: PPUSH
// cars := [ ] ;
 767: LD_ADDR_VAR 0 2
 771: PUSH
 772: EMPTY
 773: ST_TO_ADDR
// for i = 1 to 8 do
 774: LD_ADDR_VAR 0 4
 778: PUSH
 779: DOUBLE
 780: LD_INT 1
 782: DEC
 783: ST_TO_ADDR
 784: LD_INT 8
 786: PUSH
 787: FOR_TO
 788: IFFALSE 1100
// begin rnd = rand ( 1 , 100 ) ;
 790: LD_ADDR_VAR 0 5
 794: PUSH
 795: LD_INT 1
 797: PPUSH
 798: LD_INT 100
 800: PPUSH
 801: CALL_OW 12
 805: ST_TO_ADDR
// if Difficulty = 1 then
 806: LD_OWVAR 67
 810: PUSH
 811: LD_INT 1
 813: EQUAL
 814: IFFALSE 897
// begin case rnd of 1 .. 50 :
 816: LD_VAR 0 5
 820: PUSH
 821: LD_INT 1
 823: DOUBLE
 824: GREATEREQUAL
 825: IFFALSE 833
 827: LD_INT 50
 829: DOUBLE
 830: LESSEQUAL
 831: IFTRUE 835
 833: GO 846
 835: POP
// vc_weapon = ru_gun ; 51 .. 85 :
 836: LD_ADDR_OWVAR 40
 840: PUSH
 841: LD_INT 44
 843: ST_TO_ADDR
 844: GO 897
 846: LD_INT 51
 848: DOUBLE
 849: GREATEREQUAL
 850: IFFALSE 858
 852: LD_INT 85
 854: DOUBLE
 855: LESSEQUAL
 856: IFTRUE 860
 858: GO 871
 860: POP
// vc_weapon = ru_gatling_gun ; 86 .. 100 :
 861: LD_ADDR_OWVAR 40
 865: PUSH
 866: LD_INT 43
 868: ST_TO_ADDR
 869: GO 897
 871: LD_INT 86
 873: DOUBLE
 874: GREATEREQUAL
 875: IFFALSE 883
 877: LD_INT 100
 879: DOUBLE
 880: LESSEQUAL
 881: IFTRUE 885
 883: GO 896
 885: POP
// vc_weapon = ru_heavy_machine_gun ; end ;
 886: LD_ADDR_OWVAR 40
 890: PUSH
 891: LD_INT 42
 893: ST_TO_ADDR
 894: GO 897
 896: POP
// end ; if Difficulty = 2 then
 897: LD_OWVAR 67
 901: PUSH
 902: LD_INT 2
 904: EQUAL
 905: IFFALSE 988
// begin case rnd of 1 .. 30 :
 907: LD_VAR 0 5
 911: PUSH
 912: LD_INT 1
 914: DOUBLE
 915: GREATEREQUAL
 916: IFFALSE 924
 918: LD_INT 30
 920: DOUBLE
 921: LESSEQUAL
 922: IFTRUE 926
 924: GO 937
 926: POP
// vc_weapon = ru_gun ; 31 .. 75 :
 927: LD_ADDR_OWVAR 40
 931: PUSH
 932: LD_INT 44
 934: ST_TO_ADDR
 935: GO 988
 937: LD_INT 31
 939: DOUBLE
 940: GREATEREQUAL
 941: IFFALSE 949
 943: LD_INT 75
 945: DOUBLE
 946: LESSEQUAL
 947: IFTRUE 951
 949: GO 962
 951: POP
// vc_weapon = ru_gatling_gun ; 76 .. 100 :
 952: LD_ADDR_OWVAR 40
 956: PUSH
 957: LD_INT 43
 959: ST_TO_ADDR
 960: GO 988
 962: LD_INT 76
 964: DOUBLE
 965: GREATEREQUAL
 966: IFFALSE 974
 968: LD_INT 100
 970: DOUBLE
 971: LESSEQUAL
 972: IFTRUE 976
 974: GO 987
 976: POP
// vc_weapon = ru_heavy_machine_gun ; end ;
 977: LD_ADDR_OWVAR 40
 981: PUSH
 982: LD_INT 42
 984: ST_TO_ADDR
 985: GO 988
 987: POP
// end ; if Difficulty = 3 then
 988: LD_OWVAR 67
 992: PUSH
 993: LD_INT 3
 995: EQUAL
 996: IFFALSE 1079
// begin case rnd of 1 .. 20 :
 998: LD_VAR 0 5
1002: PUSH
1003: LD_INT 1
1005: DOUBLE
1006: GREATEREQUAL
1007: IFFALSE 1015
1009: LD_INT 20
1011: DOUBLE
1012: LESSEQUAL
1013: IFTRUE 1017
1015: GO 1028
1017: POP
// vc_weapon = ru_gun ; 21 .. 50 :
1018: LD_ADDR_OWVAR 40
1022: PUSH
1023: LD_INT 44
1025: ST_TO_ADDR
1026: GO 1079
1028: LD_INT 21
1030: DOUBLE
1031: GREATEREQUAL
1032: IFFALSE 1040
1034: LD_INT 50
1036: DOUBLE
1037: LESSEQUAL
1038: IFTRUE 1042
1040: GO 1053
1042: POP
// vc_weapon = ru_gatling_gun ; 51 .. 100 :
1043: LD_ADDR_OWVAR 40
1047: PUSH
1048: LD_INT 43
1050: ST_TO_ADDR
1051: GO 1079
1053: LD_INT 51
1055: DOUBLE
1056: GREATEREQUAL
1057: IFFALSE 1065
1059: LD_INT 100
1061: DOUBLE
1062: LESSEQUAL
1063: IFTRUE 1067
1065: GO 1078
1067: POP
// vc_weapon = ru_heavy_machine_gun ; end ;
1068: LD_ADDR_OWVAR 40
1072: PUSH
1073: LD_INT 42
1075: ST_TO_ADDR
1076: GO 1079
1078: POP
// end ; cars = cars ^ [ vc_weapon ] ;
1079: LD_ADDR_VAR 0 2
1083: PUSH
1084: LD_VAR 0 2
1088: PUSH
1089: LD_OWVAR 40
1093: PUSH
1094: EMPTY
1095: LIST
1096: ADD
1097: ST_TO_ADDR
// end ;
1098: GO 787
1100: POP
1101: POP
// InitUc ;
1102: CALL_OW 18
// InitVc ;
1106: CALL_OW 20
// vc_control := control_manual ;
1110: LD_ADDR_OWVAR 38
1114: PUSH
1115: LD_INT 1
1117: ST_TO_ADDR
// vc_engine := engine_combustion ;
1118: LD_ADDR_OWVAR 39
1122: PUSH
1123: LD_INT 1
1125: ST_TO_ADDR
// uc_side := you ;
1126: LD_ADDR_OWVAR 20
1130: PUSH
1131: LD_EXP 1
1135: ST_TO_ADDR
// uc_nation := nation_russian ;
1136: LD_ADDR_OWVAR 21
1140: PUSH
1141: LD_INT 3
1143: ST_TO_ADDR
// ru_cars := [ ] ;
1144: LD_ADDR_EXP 17
1148: PUSH
1149: EMPTY
1150: ST_TO_ADDR
// for i := 1 to 8 do
1151: LD_ADDR_VAR 0 4
1155: PUSH
1156: DOUBLE
1157: LD_INT 1
1159: DEC
1160: ST_TO_ADDR
1161: LD_INT 8
1163: PUSH
1164: FOR_TO
1165: IFFALSE 1283
// begin vc_chassis := ru_medium_tracked ;
1167: LD_ADDR_OWVAR 37
1171: PUSH
1172: LD_INT 22
1174: ST_TO_ADDR
// vc_weapon := cars [ i ] ;
1175: LD_ADDR_OWVAR 40
1179: PUSH
1180: LD_VAR 0 2
1184: PUSH
1185: LD_VAR 0 4
1189: ARRAY
1190: ST_TO_ADDR
// uc_direction := 5 ;
1191: LD_ADDR_OWVAR 24
1195: PUSH
1196: LD_INT 5
1198: ST_TO_ADDR
// vc_fuel_battery := Rand ( 70 , 90 ) ;
1199: LD_ADDR_OWVAR 41
1203: PUSH
1204: LD_INT 70
1206: PPUSH
1207: LD_INT 90
1209: PPUSH
1210: CALL_OW 12
1214: ST_TO_ADDR
// car := CreateVehicle ;
1215: LD_ADDR_VAR 0 3
1219: PUSH
1220: CALL_OW 45
1224: ST_TO_ADDR
// ru_cars := ru_cars ^ car ;
1225: LD_ADDR_EXP 17
1229: PUSH
1230: LD_EXP 17
1234: PUSH
1235: LD_VAR 0 3
1239: ADD
1240: ST_TO_ADDR
// PlaceHumanInUnit ( used [ i ] , car ) ;
1241: LD_EXP 16
1245: PUSH
1246: LD_VAR 0 4
1250: ARRAY
1251: PPUSH
1252: LD_VAR 0 3
1256: PPUSH
1257: CALL_OW 52
// SetLives ( car , Rand ( 750 , 1000 ) ) ;
1261: LD_VAR 0 3
1265: PPUSH
1266: LD_INT 750
1268: PPUSH
1269: LD_INT 1000
1271: PPUSH
1272: CALL_OW 12
1276: PPUSH
1277: CALL_OW 234
// end ;
1281: GO 1164
1283: POP
1284: POP
// end ;
1285: LD_VAR 0 1
1289: RET
// export function place_ru_cars ( area ) ; var i ; begin
1290: LD_INT 0
1292: PPUSH
1293: PPUSH
// for i in ru_cars do
1294: LD_ADDR_VAR 0 3
1298: PUSH
1299: LD_EXP 17
1303: PUSH
1304: FOR_IN
1305: IFFALSE 1326
// PlaceUnitArea ( i , area , false ) ;
1307: LD_VAR 0 3
1311: PPUSH
1312: LD_VAR 0 1
1316: PPUSH
1317: LD_INT 0
1319: PPUSH
1320: CALL_OW 49
1324: GO 1304
1326: POP
1327: POP
// end ;
1328: LD_VAR 0 2
1332: RET
// function MyCreateCharacter ( name , loc , unclass , new ) ; begin
1333: LD_INT 0
1335: PPUSH
// if new then
1336: LD_VAR 0 4
1340: IFFALSE 1359
// result := NewCharacter ( name ) else
1342: LD_ADDR_VAR 0 5
1346: PUSH
1347: LD_VAR 0 1
1351: PPUSH
1352: CALL_OW 25
1356: ST_TO_ADDR
1357: GO 1395
// begin if CheckCharacterSet ( name ) then
1359: LD_VAR 0 1
1363: PPUSH
1364: CALL_OW 29
1368: IFFALSE 1387
// result := CreateCharacter ( name ) else
1370: LD_ADDR_VAR 0 5
1374: PUSH
1375: LD_VAR 0 1
1379: PPUSH
1380: CALL_OW 34
1384: ST_TO_ADDR
1385: GO 1395
// result := 0 ;
1387: LD_ADDR_VAR 0 5
1391: PUSH
1392: LD_INT 0
1394: ST_TO_ADDR
// end ; if unclass then
1395: LD_VAR 0 3
1399: IFFALSE 1415
// SetClass ( result , unclass ) ;
1401: LD_VAR 0 5
1405: PPUSH
1406: LD_VAR 0 3
1410: PPUSH
1411: CALL_OW 336
// end ;
1415: LD_VAR 0 5
1419: RET
// export function Save ; begin
1420: LD_INT 0
1422: PPUSH
// SaveVariable ( savedTanks , 05_TanksIntro_1 ) ;
1423: LD_EXP 6
1427: PPUSH
1428: LD_STRING 05_TanksIntro_1
1430: PPUSH
1431: CALL_OW 39
// end ; end_of_file
1435: LD_VAR 0 1
1439: RET
// var Bur , Bel , Pla , Kar , Ptr , Glb , Pet , Stv , Dol , Lip , Tit ; var donttalk ; function set_shorts ; begin
1440: LD_INT 0
1442: PPUSH
// Bur := Burlak ;
1443: LD_ADDR_LOC 1
1447: PUSH
1448: LD_EXP 7
1452: ST_TO_ADDR
// Pla := Platonov ;
1453: LD_ADDR_LOC 3
1457: PUSH
1458: LD_EXP 8
1462: ST_TO_ADDR
// Kar := Karamazov ;
1463: LD_ADDR_LOC 4
1467: PUSH
1468: LD_EXP 9
1472: ST_TO_ADDR
// Ptr := Petrovova ;
1473: LD_ADDR_LOC 5
1477: PUSH
1478: LD_EXP 10
1482: ST_TO_ADDR
// Glb := Gleb ;
1483: LD_ADDR_LOC 6
1487: PUSH
1488: LD_EXP 11
1492: ST_TO_ADDR
// Pet := Petrosyan ;
1493: LD_ADDR_LOC 7
1497: PUSH
1498: LD_EXP 12
1502: ST_TO_ADDR
// Dol := Dolgov ;
1503: LD_ADDR_LOC 9
1507: PUSH
1508: LD_EXP 13
1512: ST_TO_ADDR
// Lip := Lipshchin ;
1513: LD_ADDR_LOC 10
1517: PUSH
1518: LD_EXP 14
1522: ST_TO_ADDR
// Tit := Titov ;
1523: LD_ADDR_LOC 11
1527: PUSH
1528: LD_EXP 15
1532: ST_TO_ADDR
// donttalk := used diff [ Burlak , Karamazov , Petrovova , Gleb , Petrosyan ] ;
1533: LD_ADDR_LOC 12
1537: PUSH
1538: LD_EXP 16
1542: PUSH
1543: LD_EXP 7
1547: PUSH
1548: LD_EXP 9
1552: PUSH
1553: LD_EXP 10
1557: PUSH
1558: LD_EXP 11
1562: PUSH
1563: LD_EXP 12
1567: PUSH
1568: EMPTY
1569: LIST
1570: LIST
1571: LIST
1572: LIST
1573: LIST
1574: DIFF
1575: ST_TO_ADDR
// end ;
1576: LD_VAR 0 1
1580: RET
// export function DIntro ; var pos , auta , i , hex , rcars , mt , vzdal , driver , driverShortName ; begin
1581: LD_INT 0
1583: PPUSH
1584: PPUSH
1585: PPUSH
1586: PPUSH
1587: PPUSH
1588: PPUSH
1589: PPUSH
1590: PPUSH
1591: PPUSH
1592: PPUSH
// set_shorts ;
1593: CALL 1440 0 0
// auta := FilterAllUnits ( [ [ f_side , you ] , [ f_type , unit_vehicle ] ] ) ;
1597: LD_ADDR_VAR 0 3
1601: PUSH
1602: LD_INT 22
1604: PUSH
1605: LD_EXP 1
1609: PUSH
1610: EMPTY
1611: LIST
1612: LIST
1613: PUSH
1614: LD_INT 21
1616: PUSH
1617: LD_INT 2
1619: PUSH
1620: EMPTY
1621: LIST
1622: LIST
1623: PUSH
1624: EMPTY
1625: LIST
1626: LIST
1627: PPUSH
1628: CALL_OW 69
1632: ST_TO_ADDR
// vzdal := [ ] ;
1633: LD_ADDR_VAR 0 8
1637: PUSH
1638: EMPTY
1639: ST_TO_ADDR
// for i in auta do
1640: LD_ADDR_VAR 0 4
1644: PUSH
1645: LD_VAR 0 3
1649: PUSH
1650: FOR_IN
1651: IFFALSE 1685
// begin vzdal := vzdal ^ [ GetDistUnitXY ( i , 20 , 2 ) ] ;
1653: LD_ADDR_VAR 0 8
1657: PUSH
1658: LD_VAR 0 8
1662: PUSH
1663: LD_VAR 0 4
1667: PPUSH
1668: LD_INT 20
1670: PPUSH
1671: LD_INT 2
1673: PPUSH
1674: CALL_OW 297
1678: PUSH
1679: EMPTY
1680: LIST
1681: ADD
1682: ST_TO_ADDR
// end ;
1683: GO 1650
1685: POP
1686: POP
// auta := SortListByListAsc ( auta , vzdal ) ;
1687: LD_ADDR_VAR 0 3
1691: PUSH
1692: LD_VAR 0 3
1696: PPUSH
1697: LD_VAR 0 8
1701: PPUSH
1702: CALL_OW 76
1706: ST_TO_ADDR
// CenterNowOnUnits ( auta ) ;
1707: LD_VAR 0 3
1711: PPUSH
1712: CALL_OW 87
// RevealFogArea ( you , co_vidi ) ;
1716: LD_EXP 1
1720: PPUSH
1721: LD_INT 3
1723: PPUSH
1724: CALL_OW 332
// enable ( 10 ) ;
1728: LD_INT 10
1730: ENABLE_MARKED
// wait ( 0 0$1 ) ;
1731: LD_INT 35
1733: PPUSH
1734: CALL_OW 67
// SayRadio ( Pla , DIntro-Pla-1 ) ;
1738: LD_LOC 3
1742: PPUSH
1743: LD_STRING DIntro-Pla-1
1745: PPUSH
1746: CALL_OW 94
// Say ( Bur , DIntro-Bur-1 ) ;
1750: LD_LOC 1
1754: PPUSH
1755: LD_STRING DIntro-Bur-1
1757: PPUSH
1758: CALL_OW 88
// SayRadio ( Pla , DIntro-Pla-2 ) ;
1762: LD_LOC 3
1766: PPUSH
1767: LD_STRING DIntro-Pla-2
1769: PPUSH
1770: CALL_OW 94
// Say ( Bur , DIntro-Bur-2 ) ;
1774: LD_LOC 1
1778: PPUSH
1779: LD_STRING DIntro-Bur-2
1781: PPUSH
1782: CALL_OW 88
// SayRadio ( Pla , DIntro-Pla-3 ) ;
1786: LD_LOC 3
1790: PPUSH
1791: LD_STRING DIntro-Pla-3
1793: PPUSH
1794: CALL_OW 94
// ComMoveToArea ( auta [ 1 ] , ru_exit ) ;
1798: LD_VAR 0 3
1802: PUSH
1803: LD_INT 1
1805: ARRAY
1806: PPUSH
1807: LD_INT 2
1809: PPUSH
1810: CALL_OW 113
// wait ( 0 0$1 ) ;
1814: LD_INT 35
1816: PPUSH
1817: CALL_OW 67
// for i := 1 to auta - 1 do
1821: LD_ADDR_VAR 0 4
1825: PUSH
1826: DOUBLE
1827: LD_INT 1
1829: DEC
1830: ST_TO_ADDR
1831: LD_VAR 0 3
1835: PUSH
1836: LD_INT 1
1838: MINUS
1839: PUSH
1840: FOR_TO
1841: IFFALSE 1882
// begin ComMoveUnit ( auta [ i + 1 ] , auta [ i ] ) ;
1843: LD_VAR 0 3
1847: PUSH
1848: LD_VAR 0 4
1852: PUSH
1853: LD_INT 1
1855: PLUS
1856: ARRAY
1857: PPUSH
1858: LD_VAR 0 3
1862: PUSH
1863: LD_VAR 0 4
1867: ARRAY
1868: PPUSH
1869: CALL_OW 112
// wait ( 0 0$1 ) ;
1873: LD_INT 35
1875: PPUSH
1876: CALL_OW 67
// end ;
1880: GO 1840
1882: POP
1883: POP
// AddComMoveToArea ( auta , ru_exit ) ;
1884: LD_VAR 0 3
1888: PPUSH
1889: LD_INT 2
1891: PPUSH
1892: CALL_OW 173
// mt := tick + 0 0$2 ;
1896: LD_ADDR_VAR 0 7
1900: PUSH
1901: LD_OWVAR 1
1905: PUSH
1906: LD_INT 70
1908: PLUS
1909: ST_TO_ADDR
// while FilterAllUnits ( [ [ f_side , you ] , [ f_placed ] ] ) do
1910: LD_INT 22
1912: PUSH
1913: LD_EXP 1
1917: PUSH
1918: EMPTY
1919: LIST
1920: LIST
1921: PUSH
1922: LD_INT 52
1924: PUSH
1925: EMPTY
1926: LIST
1927: PUSH
1928: EMPTY
1929: LIST
1930: LIST
1931: PPUSH
1932: CALL_OW 69
1936: IFFALSE 2374
// begin wait ( 0 0$0.2 ) ;
1938: LD_INT 7
1940: PPUSH
1941: CALL_OW 67
// CenterNowOnUnits ( IsInUnit ( Burlak ) ) ;
1945: LD_EXP 7
1949: PPUSH
1950: CALL_OW 310
1954: PPUSH
1955: CALL_OW 87
// for i in auta do
1959: LD_ADDR_VAR 0 4
1963: PUSH
1964: LD_VAR 0 3
1968: PUSH
1969: FOR_IN
1970: IFFALSE 2025
// begin if GetLives ( i ) < 500 then
1972: LD_VAR 0 4
1976: PPUSH
1977: CALL_OW 256
1981: PUSH
1982: LD_INT 500
1984: LESS
1985: IFFALSE 1999
// SetLives ( i , 500 ) ;
1987: LD_VAR 0 4
1991: PPUSH
1992: LD_INT 500
1994: PPUSH
1995: CALL_OW 234
// if not HasTask ( i ) then
1999: LD_VAR 0 4
2003: PPUSH
2004: CALL_OW 314
2008: NOT
2009: IFFALSE 2023
// ComMoveToArea ( i , ru_exit ) ;
2011: LD_VAR 0 4
2015: PPUSH
2016: LD_INT 2
2018: PPUSH
2019: CALL_OW 113
// end ;
2023: GO 1969
2025: POP
2026: POP
// for i in FilterUnitsInArea ( ru_exit , [ ] ) do
2027: LD_ADDR_VAR 0 4
2031: PUSH
2032: LD_INT 2
2034: PPUSH
2035: EMPTY
2036: PPUSH
2037: CALL_OW 70
2041: PUSH
2042: FOR_IN
2043: IFFALSE 2331
// begin if GetType ( i ) = unit_vehicle and GetSide ( i ) = 3 then
2045: LD_VAR 0 4
2049: PPUSH
2050: CALL_OW 247
2054: PUSH
2055: LD_INT 2
2057: EQUAL
2058: PUSH
2059: LD_VAR 0 4
2063: PPUSH
2064: CALL_OW 255
2068: PUSH
2069: LD_INT 3
2071: EQUAL
2072: AND
2073: IFFALSE 2320
// begin driver = UnitsInside ( i ) [ 1 ] ;
2075: LD_ADDR_VAR 0 9
2079: PUSH
2080: LD_VAR 0 4
2084: PPUSH
2085: CALL_OW 313
2089: PUSH
2090: LD_INT 1
2092: ARRAY
2093: ST_TO_ADDR
// if driver = Burlak then
2094: LD_VAR 0 9
2098: PUSH
2099: LD_EXP 7
2103: EQUAL
2104: IFFALSE 2114
// driverShortName = Bur ;
2106: LD_ADDR_VAR 0 10
2110: PUSH
2111: LD_STRING Bur
2113: ST_TO_ADDR
// if driver = Karamazov then
2114: LD_VAR 0 9
2118: PUSH
2119: LD_EXP 9
2123: EQUAL
2124: IFFALSE 2134
// driverShortName = Kar ;
2126: LD_ADDR_VAR 0 10
2130: PUSH
2131: LD_STRING Kar
2133: ST_TO_ADDR
// if driver = Petrovova then
2134: LD_VAR 0 9
2138: PUSH
2139: LD_EXP 10
2143: EQUAL
2144: IFFALSE 2154
// driverShortName = Ptr ;
2146: LD_ADDR_VAR 0 10
2150: PUSH
2151: LD_STRING Ptr
2153: ST_TO_ADDR
// if driver = Gleb then
2154: LD_VAR 0 9
2158: PUSH
2159: LD_EXP 11
2163: EQUAL
2164: IFFALSE 2174
// driverShortName = Glb ;
2166: LD_ADDR_VAR 0 10
2170: PUSH
2171: LD_STRING Glb
2173: ST_TO_ADDR
// if driver = Petrosyan then
2174: LD_VAR 0 9
2178: PUSH
2179: LD_EXP 12
2183: EQUAL
2184: IFFALSE 2194
// driverShortName = Pet ;
2186: LD_ADDR_VAR 0 10
2190: PUSH
2191: LD_STRING Pet
2193: ST_TO_ADDR
// if driver = Dolgov then
2194: LD_VAR 0 9
2198: PUSH
2199: LD_EXP 13
2203: EQUAL
2204: IFFALSE 2214
// driverShortName = Dol ;
2206: LD_ADDR_VAR 0 10
2210: PUSH
2211: LD_STRING Dol
2213: ST_TO_ADDR
// if driver = Lipshchin then
2214: LD_VAR 0 9
2218: PUSH
2219: LD_EXP 14
2223: EQUAL
2224: IFFALSE 2234
// driverShortName = Lip ;
2226: LD_ADDR_VAR 0 10
2230: PUSH
2231: LD_STRING Lip
2233: ST_TO_ADDR
// if driver = Titov then
2234: LD_VAR 0 9
2238: PUSH
2239: LD_EXP 15
2243: EQUAL
2244: IFFALSE 2254
// driverShortName = Tit ;
2246: LD_ADDR_VAR 0 10
2250: PUSH
2251: LD_STRING Tit
2253: ST_TO_ADDR
// savedTanks = savedTanks ^ [ [ GetChassis ( i ) , GetEngine ( i ) , GetControl ( i ) , GetWeapon ( i ) , driverShortName ] ] ;
2254: LD_ADDR_EXP 6
2258: PUSH
2259: LD_EXP 6
2263: PUSH
2264: LD_VAR 0 4
2268: PPUSH
2269: CALL_OW 265
2273: PUSH
2274: LD_VAR 0 4
2278: PPUSH
2279: CALL_OW 262
2283: PUSH
2284: LD_VAR 0 4
2288: PPUSH
2289: CALL_OW 263
2293: PUSH
2294: LD_VAR 0 4
2298: PPUSH
2299: CALL_OW 264
2303: PUSH
2304: LD_VAR 0 10
2308: PUSH
2309: EMPTY
2310: LIST
2311: LIST
2312: LIST
2313: LIST
2314: LIST
2315: PUSH
2316: EMPTY
2317: LIST
2318: ADD
2319: ST_TO_ADDR
// end ; RemoveUnit ( i ) ;
2320: LD_VAR 0 4
2324: PPUSH
2325: CALL_OW 64
// end ;
2329: GO 2042
2331: POP
2332: POP
// if tick > mt then
2333: LD_OWVAR 1
2337: PUSH
2338: LD_VAR 0 7
2342: GREATER
2343: IFFALSE 2372
// begin CenterOnUnits ( auta [ 3 ] ) ;
2345: LD_VAR 0 3
2349: PUSH
2350: LD_INT 3
2352: ARRAY
2353: PPUSH
2354: CALL_OW 85
// mt := tick + 0 0$2 ;
2358: LD_ADDR_VAR 0 7
2362: PUSH
2363: LD_OWVAR 1
2367: PUSH
2368: LD_INT 70
2370: PLUS
2371: ST_TO_ADDR
// end ; end ;
2372: GO 1910
// ingame_video := false ;
2374: LD_ADDR_OWVAR 52
2378: PUSH
2379: LD_INT 0
2381: ST_TO_ADDR
// interface_hidden := false ;
2382: LD_ADDR_OWVAR 54
2386: PUSH
2387: LD_INT 0
2389: ST_TO_ADDR
// end ;
2390: LD_VAR 0 1
2394: RET
// every 0 0$0.5 marked 10 do var arabsc , arabsp , i ;
2395: GO 2397
2397: DISABLE
2398: LD_INT 0
2400: PPUSH
2401: PPUSH
2402: PPUSH
// begin ComEnterUnit ( ar1 , b1 ) ;
2403: LD_INT 26
2405: PPUSH
2406: LD_INT 1
2408: PPUSH
2409: CALL_OW 120
// ComEnterUnit ( ar2 , b2 ) ;
2413: LD_INT 16
2415: PPUSH
2416: LD_INT 2
2418: PPUSH
2419: CALL_OW 120
// arabsc := FilterAllUnits ( [ [ f_side , arabians ] , [ f_type , unit_vehicle ] ] ) ;
2423: LD_ADDR_VAR 0 1
2427: PUSH
2428: LD_INT 22
2430: PUSH
2431: LD_EXP 3
2435: PUSH
2436: EMPTY
2437: LIST
2438: LIST
2439: PUSH
2440: LD_INT 21
2442: PUSH
2443: LD_INT 2
2445: PUSH
2446: EMPTY
2447: LIST
2448: LIST
2449: PUSH
2450: EMPTY
2451: LIST
2452: LIST
2453: PPUSH
2454: CALL_OW 69
2458: ST_TO_ADDR
// arabsp := FilterAllUnits ( [ [ f_side , arabians ] , [ f_type , unit_human ] ] ) diff [ ar1 , ar2 ] ;
2459: LD_ADDR_VAR 0 2
2463: PUSH
2464: LD_INT 22
2466: PUSH
2467: LD_EXP 3
2471: PUSH
2472: EMPTY
2473: LIST
2474: LIST
2475: PUSH
2476: LD_INT 21
2478: PUSH
2479: LD_INT 1
2481: PUSH
2482: EMPTY
2483: LIST
2484: LIST
2485: PUSH
2486: EMPTY
2487: LIST
2488: LIST
2489: PPUSH
2490: CALL_OW 69
2494: PUSH
2495: LD_INT 26
2497: PUSH
2498: LD_INT 16
2500: PUSH
2501: EMPTY
2502: LIST
2503: LIST
2504: DIFF
2505: ST_TO_ADDR
// for i := 1 to arabsc do
2506: LD_ADDR_VAR 0 3
2510: PUSH
2511: DOUBLE
2512: LD_INT 1
2514: DEC
2515: ST_TO_ADDR
2516: LD_VAR 0 1
2520: PUSH
2521: FOR_TO
2522: IFFALSE 2552
// begin ComEnterUnit ( arabsp [ i ] , arabsc [ i ] ) ;
2524: LD_VAR 0 2
2528: PUSH
2529: LD_VAR 0 3
2533: ARRAY
2534: PPUSH
2535: LD_VAR 0 1
2539: PUSH
2540: LD_VAR 0 3
2544: ARRAY
2545: PPUSH
2546: CALL_OW 120
// end ;
2550: GO 2521
2552: POP
2553: POP
// while not UnitFilter ( arabsc , [ [ f_occupied ] ] ) do
2554: LD_VAR 0 1
2558: PPUSH
2559: LD_INT 59
2561: PUSH
2562: EMPTY
2563: LIST
2564: PUSH
2565: EMPTY
2566: LIST
2567: PPUSH
2568: CALL_OW 72
2572: NOT
2573: IFFALSE 2584
// wait ( 0 0$1 ) ;
2575: LD_INT 35
2577: PPUSH
2578: CALL_OW 67
2582: GO 2554
// wait ( 0 0$3 ) ;
2584: LD_INT 105
2586: PPUSH
2587: CALL_OW 67
// ComMoveToArea ( arabsc , ru_exit ) ;
2591: LD_VAR 0 1
2595: PPUSH
2596: LD_INT 2
2598: PPUSH
2599: CALL_OW 113
// wait ( 0 0$2 ) ;
2603: LD_INT 70
2605: PPUSH
2606: CALL_OW 67
// ComStop ( arabsc ) ;
2610: LD_VAR 0 1
2614: PPUSH
2615: CALL_OW 141
// wait ( 0 0$1 ) ;
2619: LD_INT 35
2621: PPUSH
2622: CALL_OW 67
// ComMoveToArea ( arabsc , ru_exit ) ;
2626: LD_VAR 0 1
2630: PPUSH
2631: LD_INT 2
2633: PPUSH
2634: CALL_OW 113
// end ;
2638: PPOPN 3
2640: END
// on DestinationUnreachable ( un ) do begin ComStop ( un ) ;
2641: LD_VAR 0 1
2645: PPUSH
2646: CALL_OW 141
// wait ( 0 0$0.5 ) ;
2650: LD_INT 18
2652: PPUSH
2653: CALL_OW 67
// AddComMoveToArea ( un , ru_exit ) ;
2657: LD_VAR 0 1
2661: PPUSH
2662: LD_INT 2
2664: PPUSH
2665: CALL_OW 173
// end ;
2669: PPOPN 1
2671: END
// on Contact ( side1 , side2 ) do begin if ( ( side1 = you ) and ( side2 = arabians ) ) or ( ( side2 = you ) and ( side1 = arabians ) ) then
2672: LD_VAR 0 1
2676: PUSH
2677: LD_EXP 1
2681: EQUAL
2682: PUSH
2683: LD_VAR 0 2
2687: PUSH
2688: LD_EXP 3
2692: EQUAL
2693: AND
2694: PUSH
2695: LD_VAR 0 2
2699: PUSH
2700: LD_EXP 1
2704: EQUAL
2705: PUSH
2706: LD_VAR 0 1
2710: PUSH
2711: LD_EXP 3
2715: EQUAL
2716: AND
2717: OR
2718: IFFALSE 2736
// begin music_nat := nation_arabian_music ;
2720: LD_ADDR_OWVAR 71
2724: PUSH
2725: LD_INT 4
2727: ST_TO_ADDR
// music_class := music_combat ;
2728: LD_ADDR_OWVAR 72
2732: PUSH
2733: LD_INT 1
2735: ST_TO_ADDR
// end ; end ;
2736: PPOPN 2
2738: END
