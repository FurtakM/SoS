// export you , americans , arabians , neutral ; export rulive ; export savedTanks ; starting begin Resetfog ;
   0: CALL_OW 335
// InGameOn ;
   4: CALL_OW 8
// savedTanks = [ ] ;
   8: LD_ADDR_EXP 6
  12: PUSH
  13: EMPTY
  14: ST_TO_ADDR
// disable ( 10 ) ;
  15: LD_INT 10
  17: DISABLE_MARKED
// set_sides ;
  18: CALL 56 0 0
// load_chars ;
  22: CALL 96 0 0
// place_in_ru_cars ;
  26: CALL 760 0 0
// place_ru_cars ( ru_place ) ;
  30: LD_INT 1
  32: PPUSH
  33: CALL 1290 0 1
// DIntro ;
  37: CALL 1581 0 0
// Save ;
  41: CALL 1420 0 0
// ChangeMap ( %_cont , %_cont ) ;
  45: LD_STRING %_cont
  47: PPUSH
  48: LD_STRING %_cont
  50: PPUSH
  51: CALL_OW 340
// end ;
  55: END
// function set_sides ; begin
  56: LD_INT 0
  58: PPUSH
// you := 3 ;
  59: LD_ADDR_EXP 1
  63: PUSH
  64: LD_INT 3
  66: ST_TO_ADDR
// americans := 1 ;
  67: LD_ADDR_EXP 2
  71: PUSH
  72: LD_INT 1
  74: ST_TO_ADDR
// arabians := 2 ;
  75: LD_ADDR_EXP 3
  79: PUSH
  80: LD_INT 2
  82: ST_TO_ADDR
// neutral := 0 ;
  83: LD_ADDR_EXP 4
  87: PUSH
  88: LD_INT 0
  90: ST_TO_ADDR
// end ; end_of_file
  91: LD_VAR 0 1
  95: RET
// export Burlak , Platonov , Karamazov , Petrovova , Gleb , Petrosyan , Dolgov , Lipshchin , Titov ; export used , ru_cars , other_from6i ; export function load_chars ; var i , so , en , me , sc ; begin
  96: LD_INT 0
  98: PPUSH
  99: PPUSH
 100: PPUSH
 101: PPUSH
 102: PPUSH
 103: PPUSH
// InitUc ;
 104: CALL_OW 18
// InitHc ;
 108: CALL_OW 19
// uc_side := you ;
 112: LD_ADDR_OWVAR 20
 116: PUSH
 117: LD_EXP 1
 121: ST_TO_ADDR
// uc_nation := nation_russian ;
 122: LD_ADDR_OWVAR 21
 126: PUSH
 127: LD_INT 3
 129: ST_TO_ADDR
// Platonov := MyCreateCharacter ( Platonov , 0 , class_soldier , true ) ;
 130: LD_ADDR_EXP 8
 134: PUSH
 135: LD_STRING Platonov
 137: PPUSH
 138: LD_INT 0
 140: PPUSH
 141: LD_INT 1
 143: PPUSH
 144: LD_INT 1
 146: PPUSH
 147: CALL 1333 0 4
 151: ST_TO_ADDR
// Burlak := MyCreateCharacter ( 04_Burlak , 0 , class_mechanic , false ) ;
 152: LD_ADDR_EXP 7
 156: PUSH
 157: LD_STRING 04_Burlak
 159: PPUSH
 160: LD_INT 0
 162: PPUSH
 163: LD_INT 3
 165: PPUSH
 166: LD_INT 0
 168: PPUSH
 169: CALL 1333 0 4
 173: ST_TO_ADDR
// Karamazov := MyCreateCharacter ( Karamazov , 0 , class_engineer , true ) ;
 174: LD_ADDR_EXP 9
 178: PUSH
 179: LD_STRING Karamazov
 181: PPUSH
 182: LD_INT 0
 184: PPUSH
 185: LD_INT 2
 187: PPUSH
 188: LD_INT 1
 190: PPUSH
 191: CALL 1333 0 4
 195: ST_TO_ADDR
// Petrovova := MyCreateCharacter ( Petrovova , 0 , class_soldier , true ) ;
 196: LD_ADDR_EXP 10
 200: PUSH
 201: LD_STRING Petrovova
 203: PPUSH
 204: LD_INT 0
 206: PPUSH
 207: LD_INT 1
 209: PPUSH
 210: LD_INT 1
 212: PPUSH
 213: CALL 1333 0 4
 217: ST_TO_ADDR
// Gleb := MyCreateCharacter ( Gleb , 0 , class_soldier , true ) ;
 218: LD_ADDR_EXP 11
 222: PUSH
 223: LD_STRING Gleb
 225: PPUSH
 226: LD_INT 0
 228: PPUSH
 229: LD_INT 1
 231: PPUSH
 232: LD_INT 1
 234: PPUSH
 235: CALL 1333 0 4
 239: ST_TO_ADDR
// Petrosyan := MyCreateCharacter ( Petrosyan , 0 , class_scientistic , true ) ;
 240: LD_ADDR_EXP 12
 244: PUSH
 245: LD_STRING Petrosyan
 247: PPUSH
 248: LD_INT 0
 250: PPUSH
 251: LD_INT 4
 253: PPUSH
 254: LD_INT 1
 256: PPUSH
 257: CALL 1333 0 4
 261: ST_TO_ADDR
// Dolgov := MyCreateCharacter ( Dolgov , 0 , class_scientistic , true ) ;
 262: LD_ADDR_EXP 13
 266: PUSH
 267: LD_STRING Dolgov
 269: PPUSH
 270: LD_INT 0
 272: PPUSH
 273: LD_INT 4
 275: PPUSH
 276: LD_INT 1
 278: PPUSH
 279: CALL 1333 0 4
 283: ST_TO_ADDR
// Lipshchin := MyCreateCharacter ( Lipshchin , 0 , class_soldier , true ) ;
 284: LD_ADDR_EXP 14
 288: PUSH
 289: LD_STRING Lipshchin
 291: PPUSH
 292: LD_INT 0
 294: PPUSH
 295: LD_INT 1
 297: PPUSH
 298: LD_INT 1
 300: PPUSH
 301: CALL 1333 0 4
 305: ST_TO_ADDR
// Titov := MyCreateCharacter ( Titov , 0 , class_soldier , true ) ;
 306: LD_ADDR_EXP 15
 310: PUSH
 311: LD_STRING Titov
 313: PPUSH
 314: LD_INT 0
 316: PPUSH
 317: LD_INT 1
 319: PPUSH
 320: LD_INT 1
 322: PPUSH
 323: CALL 1333 0 4
 327: ST_TO_ADDR
// used := [ Burlak , Karamazov , Petrovova , Gleb , Petrosyan , Lipshchin , Dolgov , Titov ] diff 0 ;
 328: LD_ADDR_EXP 16
 332: PUSH
 333: LD_EXP 7
 337: PUSH
 338: LD_EXP 9
 342: PUSH
 343: LD_EXP 10
 347: PUSH
 348: LD_EXP 11
 352: PUSH
 353: LD_EXP 12
 357: PUSH
 358: LD_EXP 14
 362: PUSH
 363: LD_EXP 13
 367: PUSH
 368: LD_EXP 15
 372: PUSH
 373: EMPTY
 374: LIST
 375: LIST
 376: LIST
 377: LIST
 378: LIST
 379: LIST
 380: LIST
 381: LIST
 382: PUSH
 383: LD_INT 0
 385: DIFF
 386: ST_TO_ADDR
// so := ( UnitFilter ( used , [ [ f_class , class_soldier ] ] ) + 0 ) ;
 387: LD_ADDR_VAR 0 3
 391: PUSH
 392: LD_EXP 16
 396: PPUSH
 397: LD_INT 25
 399: PUSH
 400: LD_INT 1
 402: PUSH
 403: EMPTY
 404: LIST
 405: LIST
 406: PUSH
 407: EMPTY
 408: LIST
 409: PPUSH
 410: CALL_OW 72
 414: PUSH
 415: LD_INT 0
 417: PLUS
 418: ST_TO_ADDR
// en := ( UnitFilter ( used , [ [ f_class , class_engineer ] ] ) + 0 ) ;
 419: LD_ADDR_VAR 0 4
 423: PUSH
 424: LD_EXP 16
 428: PPUSH
 429: LD_INT 25
 431: PUSH
 432: LD_INT 2
 434: PUSH
 435: EMPTY
 436: LIST
 437: LIST
 438: PUSH
 439: EMPTY
 440: LIST
 441: PPUSH
 442: CALL_OW 72
 446: PUSH
 447: LD_INT 0
 449: PLUS
 450: ST_TO_ADDR
// me := ( UnitFilter ( used , [ [ f_class , class_mechanic ] ] ) + 0 ) ;
 451: LD_ADDR_VAR 0 5
 455: PUSH
 456: LD_EXP 16
 460: PPUSH
 461: LD_INT 25
 463: PUSH
 464: LD_INT 3
 466: PUSH
 467: EMPTY
 468: LIST
 469: LIST
 470: PUSH
 471: EMPTY
 472: LIST
 473: PPUSH
 474: CALL_OW 72
 478: PUSH
 479: LD_INT 0
 481: PLUS
 482: ST_TO_ADDR
// sc := ( UnitFilter ( used , [ [ f_class , class_scientistic ] ] ) + 0 ) ;
 483: LD_ADDR_VAR 0 6
 487: PUSH
 488: LD_EXP 16
 492: PPUSH
 493: LD_INT 25
 495: PUSH
 496: LD_INT 4
 498: PUSH
 499: EMPTY
 500: LIST
 501: LIST
 502: PUSH
 503: EMPTY
 504: LIST
 505: PPUSH
 506: CALL_OW 72
 510: PUSH
 511: LD_INT 0
 513: PLUS
 514: ST_TO_ADDR
// for i := so to 4 do
 515: LD_ADDR_VAR 0 2
 519: PUSH
 520: DOUBLE
 521: LD_VAR 0 3
 525: DEC
 526: ST_TO_ADDR
 527: LD_INT 4
 529: PUSH
 530: FOR_TO
 531: IFFALSE 573
// begin PrepareSoldier ( Rand ( 10 , 23 ) div 10 , 3 ) ;
 533: LD_INT 10
 535: PPUSH
 536: LD_INT 23
 538: PPUSH
 539: CALL_OW 12
 543: PUSH
 544: LD_INT 10
 546: DIV
 547: PPUSH
 548: LD_INT 3
 550: PPUSH
 551: CALL_OW 381
// used := used ^ CreateHuman ;
 555: LD_ADDR_EXP 16
 559: PUSH
 560: LD_EXP 16
 564: PUSH
 565: CALL_OW 44
 569: ADD
 570: ST_TO_ADDR
// end ;
 571: GO 530
 573: POP
 574: POP
// for i := en to 1 do
 575: LD_ADDR_VAR 0 2
 579: PUSH
 580: DOUBLE
 581: LD_VAR 0 4
 585: DEC
 586: ST_TO_ADDR
 587: LD_INT 1
 589: PUSH
 590: FOR_TO
 591: IFFALSE 633
// begin PrepareEngineer ( Rand ( 10 , 23 ) div 10 , 3 ) ;
 593: LD_INT 10
 595: PPUSH
 596: LD_INT 23
 598: PPUSH
 599: CALL_OW 12
 603: PUSH
 604: LD_INT 10
 606: DIV
 607: PPUSH
 608: LD_INT 3
 610: PPUSH
 611: CALL_OW 382
// used := used ^ CreateHuman ;
 615: LD_ADDR_EXP 16
 619: PUSH
 620: LD_EXP 16
 624: PUSH
 625: CALL_OW 44
 629: ADD
 630: ST_TO_ADDR
// end ;
 631: GO 590
 633: POP
 634: POP
// for i := me to 1 do
 635: LD_ADDR_VAR 0 2
 639: PUSH
 640: DOUBLE
 641: LD_VAR 0 5
 645: DEC
 646: ST_TO_ADDR
 647: LD_INT 1
 649: PUSH
 650: FOR_TO
 651: IFFALSE 693
// begin PrepareMechanic ( Rand ( 10 , 23 ) div 10 , 3 ) ;
 653: LD_INT 10
 655: PPUSH
 656: LD_INT 23
 658: PPUSH
 659: CALL_OW 12
 663: PUSH
 664: LD_INT 10
 666: DIV
 667: PPUSH
 668: LD_INT 3
 670: PPUSH
 671: CALL_OW 383
// used := used ^ CreateHuman ;
 675: LD_ADDR_EXP 16
 679: PUSH
 680: LD_EXP 16
 684: PUSH
 685: CALL_OW 44
 689: ADD
 690: ST_TO_ADDR
// end ;
 691: GO 650
 693: POP
 694: POP
// for i := sc to 2 do
 695: LD_ADDR_VAR 0 2
 699: PUSH
 700: DOUBLE
 701: LD_VAR 0 6
 705: DEC
 706: ST_TO_ADDR
 707: LD_INT 2
 709: PUSH
 710: FOR_TO
 711: IFFALSE 753
// begin PrepareScientist ( Rand ( 10 , 23 ) div 10 , 3 ) ;
 713: LD_INT 10
 715: PPUSH
 716: LD_INT 23
 718: PPUSH
 719: CALL_OW 12
 723: PUSH
 724: LD_INT 10
 726: DIV
 727: PPUSH
 728: LD_INT 3
 730: PPUSH
 731: CALL_OW 384
// used := used ^ CreateHuman ;
 735: LD_ADDR_EXP 16
 739: PUSH
 740: LD_EXP 16
 744: PUSH
 745: CALL_OW 44
 749: ADD
 750: ST_TO_ADDR
// end ;
 751: GO 710
 753: POP
 754: POP
// end ;
 755: LD_VAR 0 1
 759: RET
// export function place_in_ru_cars ; var cars , car , i , rnd ; begin
 760: LD_INT 0
 762: PPUSH
 763: PPUSH
 764: PPUSH
 765: PPUSH
 766: PPUSH
// cars := [ ] ;
 767: LD_ADDR_VAR 0 2
 771: PUSH
 772: EMPTY
 773: ST_TO_ADDR
// for i = 1 to 8 do
 774: LD_ADDR_VAR 0 4
 778: PUSH
 779: DOUBLE
 780: LD_INT 1
 782: DEC
 783: ST_TO_ADDR
 784: LD_INT 8
 786: PUSH
 787: FOR_TO
 788: IFFALSE 1100
// begin rnd = rand ( 1 , 100 ) ;
 790: LD_ADDR_VAR 0 5
 794: PUSH
 795: LD_INT 1
 797: PPUSH
 798: LD_INT 100
 800: PPUSH
 801: CALL_OW 12
 805: ST_TO_ADDR
// if Difficulty = 1 then
 806: LD_OWVAR 67
 810: PUSH
 811: LD_INT 1
 813: EQUAL
 814: IFFALSE 897
// begin case rnd of 1 .. 50 :
 816: LD_VAR 0 5
 820: PUSH
 821: LD_INT 1
 823: DOUBLE
 824: GREATEREQUAL
 825: IFFALSE 833
 827: LD_INT 50
 829: DOUBLE
 830: LESSEQUAL
 831: IFTRUE 835
 833: GO 846
 835: POP
// vc_weapon = ru_gun ; 51 .. 85 :
 836: LD_ADDR_OWVAR 40
 840: PUSH
 841: LD_INT 44
 843: ST_TO_ADDR
 844: GO 897
 846: LD_INT 51
 848: DOUBLE
 849: GREATEREQUAL
 850: IFFALSE 858
 852: LD_INT 85
 854: DOUBLE
 855: LESSEQUAL
 856: IFTRUE 860
 858: GO 871
 860: POP
// vc_weapon = ru_gatling_gun ; 86 .. 100 :
 861: LD_ADDR_OWVAR 40
 865: PUSH
 866: LD_INT 43
 868: ST_TO_ADDR
 869: GO 897
 871: LD_INT 86
 873: DOUBLE
 874: GREATEREQUAL
 875: IFFALSE 883
 877: LD_INT 100
 879: DOUBLE
 880: LESSEQUAL
 881: IFTRUE 885
 883: GO 896
 885: POP
// vc_weapon = ru_heavy_machine_gun ; end ;
 886: LD_ADDR_OWVAR 40
 890: PUSH
 891: LD_INT 42
 893: ST_TO_ADDR
 894: GO 897
 896: POP
// end ; if Difficulty = 2 then
 897: LD_OWVAR 67
 901: PUSH
 902: LD_INT 2
 904: EQUAL
 905: IFFALSE 988
// begin case rnd of 1 .. 30 :
 907: LD_VAR 0 5
 911: PUSH
 912: LD_INT 1
 914: DOUBLE
 915: GREATEREQUAL
 916: IFFALSE 924
 918: LD_INT 30
 920: DOUBLE
 921: LESSEQUAL
 922: IFTRUE 926
 924: GO 937
 926: POP
// vc_weapon = ru_gun ; 31 .. 75 :
 927: LD_ADDR_OWVAR 40
 931: PUSH
 932: LD_INT 44
 934: ST_TO_ADDR
 935: GO 988
 937: LD_INT 31
 939: DOUBLE
 940: GREATEREQUAL
 941: IFFALSE 949
 943: LD_INT 75
 945: DOUBLE
 946: LESSEQUAL
 947: IFTRUE 951
 949: GO 962
 951: POP
// vc_weapon = ru_gatling_gun ; 76 .. 100 :
 952: LD_ADDR_OWVAR 40
 956: PUSH
 957: LD_INT 43
 959: ST_TO_ADDR
 960: GO 988
 962: LD_INT 76
 964: DOUBLE
 965: GREATEREQUAL
 966: IFFALSE 974
 968: LD_INT 100
 970: DOUBLE
 971: LESSEQUAL
 972: IFTRUE 976
 974: GO 987
 976: POP
// vc_weapon = ru_heavy_machine_gun ; end ;
 977: LD_ADDR_OWVAR 40
 981: PUSH
 982: LD_INT 42
 984: ST_TO_ADDR
 985: GO 988
 987: POP
// end ; if Difficulty = 3 then
 988: LD_OWVAR 67
 992: PUSH
 993: LD_INT 3
 995: EQUAL
 996: IFFALSE 1079
// begin case rnd of 1 .. 20 :
 998: LD_VAR 0 5
1002: PUSH
1003: LD_INT 1
1005: DOUBLE
1006: GREATEREQUAL
1007: IFFALSE 1015
1009: LD_INT 20
1011: DOUBLE
1012: LESSEQUAL
1013: IFTRUE 1017
1015: GO 1028
1017: POP
// vc_weapon = ru_gun ; 21 .. 50 :
1018: LD_ADDR_OWVAR 40
1022: PUSH
1023: LD_INT 44
1025: ST_TO_ADDR
1026: GO 1079
1028: LD_INT 21
1030: DOUBLE
1031: GREATEREQUAL
1032: IFFALSE 1040
1034: LD_INT 50
1036: DOUBLE
1037: LESSEQUAL
1038: IFTRUE 1042
1040: GO 1053
1042: POP
// vc_weapon = ru_gatling_gun ; 51 .. 100 :
1043: LD_ADDR_OWVAR 40
1047: PUSH
1048: LD_INT 43
1050: ST_TO_ADDR
1051: GO 1079
1053: LD_INT 51
1055: DOUBLE
1056: GREATEREQUAL
1057: IFFALSE 1065
1059: LD_INT 100
1061: DOUBLE
1062: LESSEQUAL
1063: IFTRUE 1067
1065: GO 1078
1067: POP
// vc_weapon = ru_heavy_machine_gun ; end ;
1068: LD_ADDR_OWVAR 40
1072: PUSH
1073: LD_INT 42
1075: ST_TO_ADDR
1076: GO 1079
1078: POP
// end ; cars = cars ^ [ vc_weapon ] ;
1079: LD_ADDR_VAR 0 2
1083: PUSH
1084: LD_VAR 0 2
1088: PUSH
1089: LD_OWVAR 40
1093: PUSH
1094: EMPTY
1095: LIST
1096: ADD
1097: ST_TO_ADDR
// end ;
1098: GO 787
1100: POP
1101: POP
// InitUc ;
1102: CALL_OW 18
// InitVc ;
1106: CALL_OW 20
// vc_control := control_manual ;
1110: LD_ADDR_OWVAR 38
1114: PUSH
1115: LD_INT 1
1117: ST_TO_ADDR
// vc_engine := engine_combustion ;
1118: LD_ADDR_OWVAR 39
1122: PUSH
1123: LD_INT 1
1125: ST_TO_ADDR
// uc_side := you ;
1126: LD_ADDR_OWVAR 20
1130: PUSH
1131: LD_EXP 1
1135: ST_TO_ADDR
// uc_nation := nation_russian ;
1136: LD_ADDR_OWVAR 21
1140: PUSH
1141: LD_INT 3
1143: ST_TO_ADDR
// ru_cars := [ ] ;
1144: LD_ADDR_EXP 17
1148: PUSH
1149: EMPTY
1150: ST_TO_ADDR
// for i := 1 to 8 do
1151: LD_ADDR_VAR 0 4
1155: PUSH
1156: DOUBLE
1157: LD_INT 1
1159: DEC
1160: ST_TO_ADDR
1161: LD_INT 8
1163: PUSH
1164: FOR_TO
1165: IFFALSE 1283
// begin vc_chassis := ru_medium_tracked ;
1167: LD_ADDR_OWVAR 37
1171: PUSH
1172: LD_INT 22
1174: ST_TO_ADDR
// vc_weapon := cars [ i ] ;
1175: LD_ADDR_OWVAR 40
1179: PUSH
1180: LD_VAR 0 2
1184: PUSH
1185: LD_VAR 0 4
1189: ARRAY
1190: ST_TO_ADDR
// uc_direction := 5 ;
1191: LD_ADDR_OWVAR 24
1195: PUSH
1196: LD_INT 5
1198: ST_TO_ADDR
// vc_fuel_battery := Rand ( 70 , 90 ) ;
1199: LD_ADDR_OWVAR 41
1203: PUSH
1204: LD_INT 70
1206: PPUSH
1207: LD_INT 90
1209: PPUSH
1210: CALL_OW 12
1214: ST_TO_ADDR
// car := CreateVehicle ;
1215: LD_ADDR_VAR 0 3
1219: PUSH
1220: CALL_OW 45
1224: ST_TO_ADDR
// ru_cars := ru_cars ^ car ;
1225: LD_ADDR_EXP 17
1229: PUSH
1230: LD_EXP 17
1234: PUSH
1235: LD_VAR 0 3
1239: ADD
1240: ST_TO_ADDR
// PlaceHumanInUnit ( used [ i ] , car ) ;
1241: LD_EXP 16
1245: PUSH
1246: LD_VAR 0 4
1250: ARRAY
1251: PPUSH
1252: LD_VAR 0 3
1256: PPUSH
1257: CALL_OW 52
// SetLives ( car , Rand ( 750 , 1000 ) ) ;
1261: LD_VAR 0 3
1265: PPUSH
1266: LD_INT 750
1268: PPUSH
1269: LD_INT 1000
1271: PPUSH
1272: CALL_OW 12
1276: PPUSH
1277: CALL_OW 234
// end ;
1281: GO 1164
1283: POP
1284: POP
// end ;
1285: LD_VAR 0 1
1289: RET
// export function place_ru_cars ( area ) ; var i ; begin
1290: LD_INT 0
1292: PPUSH
1293: PPUSH
// for i in ru_cars do
1294: LD_ADDR_VAR 0 3
1298: PUSH
1299: LD_EXP 17
1303: PUSH
1304: FOR_IN
1305: IFFALSE 1326
// PlaceUnitArea ( i , area , false ) ;
1307: LD_VAR 0 3
1311: PPUSH
1312: LD_VAR 0 1
1316: PPUSH
1317: LD_INT 0
1319: PPUSH
1320: CALL_OW 49
1324: GO 1304
1326: POP
1327: POP
// end ;
1328: LD_VAR 0 2
1332: RET
// function MyCreateCharacter ( name , loc , unclass , new ) ; begin
1333: LD_INT 0
1335: PPUSH
// if new then
1336: LD_VAR 0 4
1340: IFFALSE 1359
// result := NewCharacter ( name ) else
1342: LD_ADDR_VAR 0 5
1346: PUSH
1347: LD_VAR 0 1
1351: PPUSH
1352: CALL_OW 25
1356: ST_TO_ADDR
1357: GO 1395
// begin if CheckCharacterSet ( name ) then
1359: LD_VAR 0 1
1363: PPUSH
1364: CALL_OW 29
1368: IFFALSE 1387
// result := CreateCharacter ( name ) else
1370: LD_ADDR_VAR 0 5
1374: PUSH
1375: LD_VAR 0 1
1379: PPUSH
1380: CALL_OW 34
1384: ST_TO_ADDR
1385: GO 1395
// result := 0 ;
1387: LD_ADDR_VAR 0 5
1391: PUSH
1392: LD_INT 0
1394: ST_TO_ADDR
// end ; if unclass then
1395: LD_VAR 0 3
1399: IFFALSE 1415
// SetClass ( result , unclass ) ;
1401: LD_VAR 0 5
1405: PPUSH
1406: LD_VAR 0 3
1410: PPUSH
1411: CALL_OW 336
// end ;
1415: LD_VAR 0 5
1419: RET
// export function Save ; begin
1420: LD_INT 0
1422: PPUSH
// SaveVariable ( savedTanks , 05_TanksIntro_1 ) ;
1423: LD_EXP 6
1427: PPUSH
1428: LD_STRING 05_TanksIntro_1
1430: PPUSH
1431: CALL_OW 39
// end ; end_of_file
1435: LD_VAR 0 1
1439: RET
// var Bur , Bel , Pla , Kar , Ptr , Glb , Pet , Stv , Dol , Lip , Tit ; var donttalk ; function set_shorts ; begin
1440: LD_INT 0
1442: PPUSH
// Bur := Burlak ;
1443: LD_ADDR_LOC 1
1447: PUSH
1448: LD_EXP 7
1452: ST_TO_ADDR
// Pla := Platonov ;
1453: LD_ADDR_LOC 3
1457: PUSH
1458: LD_EXP 8
1462: ST_TO_ADDR
// Kar := Karamazov ;
1463: LD_ADDR_LOC 4
1467: PUSH
1468: LD_EXP 9
1472: ST_TO_ADDR
// Ptr := Petrovova ;
1473: LD_ADDR_LOC 5
1477: PUSH
1478: LD_EXP 10
1482: ST_TO_ADDR
// Glb := Gleb ;
1483: LD_ADDR_LOC 6
1487: PUSH
1488: LD_EXP 11
1492: ST_TO_ADDR
// Pet := Petrosyan ;
1493: LD_ADDR_LOC 7
1497: PUSH
1498: LD_EXP 12
1502: ST_TO_ADDR
// Dol := Dolgov ;
1503: LD_ADDR_LOC 9
1507: PUSH
1508: LD_EXP 13
1512: ST_TO_ADDR
// Lip := Lipshchin ;
1513: LD_ADDR_LOC 10
1517: PUSH
1518: LD_EXP 14
1522: ST_TO_ADDR
// Tit := Titov ;
1523: LD_ADDR_LOC 11
1527: PUSH
1528: LD_EXP 15
1532: ST_TO_ADDR
// donttalk := used diff [ Burlak , Karamazov , Petrovova , Gleb , Petrosyan ] ;
1533: LD_ADDR_LOC 12
1537: PUSH
1538: LD_EXP 16
1542: PUSH
1543: LD_EXP 7
1547: PUSH
1548: LD_EXP 9
1552: PUSH
1553: LD_EXP 10
1557: PUSH
1558: LD_EXP 11
1562: PUSH
1563: LD_EXP 12
1567: PUSH
1568: EMPTY
1569: LIST
1570: LIST
1571: LIST
1572: LIST
1573: LIST
1574: DIFF
1575: ST_TO_ADDR
// end ;
1576: LD_VAR 0 1
1580: RET
// export function DIntro ; var pos , auta , i , hex , rcars , mt , vzdal , driver , driverShortName ; begin
1581: LD_INT 0
1583: PPUSH
1584: PPUSH
1585: PPUSH
1586: PPUSH
1587: PPUSH
1588: PPUSH
1589: PPUSH
1590: PPUSH
1591: PPUSH
1592: PPUSH
// set_shorts ;
1593: CALL 1440 0 0
// auta := FilterAllUnits ( [ [ f_side , you ] , [ f_type , unit_vehicle ] ] ) ;
1597: LD_ADDR_VAR 0 3
1601: PUSH
1602: LD_INT 22
1604: PUSH
1605: LD_EXP 1
1609: PUSH
1610: EMPTY
1611: LIST
1612: LIST
1613: PUSH
1614: LD_INT 21
1616: PUSH
1617: LD_INT 2
1619: PUSH
1620: EMPTY
1621: LIST
1622: LIST
1623: PUSH
1624: EMPTY
1625: LIST
1626: LIST
1627: PPUSH
1628: CALL_OW 69
1632: ST_TO_ADDR
// vzdal := [ ] ;
1633: LD_ADDR_VAR 0 8
1637: PUSH
1638: EMPTY
1639: ST_TO_ADDR
// for i in auta do
1640: LD_ADDR_VAR 0 4
1644: PUSH
1645: LD_VAR 0 3
1649: PUSH
1650: FOR_IN
1651: IFFALSE 1685
// begin vzdal := vzdal ^ [ GetDistUnitXY ( i , 20 , 2 ) ] ;
1653: LD_ADDR_VAR 0 8
1657: PUSH
1658: LD_VAR 0 8
1662: PUSH
1663: LD_VAR 0 4
1667: PPUSH
1668: LD_INT 20
1670: PPUSH
1671: LD_INT 2
1673: PPUSH
1674: CALL_OW 297
1678: PUSH
1679: EMPTY
1680: LIST
1681: ADD
1682: ST_TO_ADDR
// end ;
1683: GO 1650
1685: POP
1686: POP
// auta := SortListByListAsc ( auta , vzdal ) ;
1687: LD_ADDR_VAR 0 3
1691: PUSH
1692: LD_VAR 0 3
1696: PPUSH
1697: LD_VAR 0 8
1701: PPUSH
1702: CALL_OW 76
1706: ST_TO_ADDR
// CenterNowOnUnits ( auta ) ;
1707: LD_VAR 0 3
1711: PPUSH
1712: CALL_OW 87
// RevealFogArea ( you , co_vidi ) ;
1716: LD_EXP 1
1720: PPUSH
1721: LD_INT 3
1723: PPUSH
1724: CALL_OW 332
// enable ( 10 ) ;
1728: LD_INT 10
1730: ENABLE_MARKED
// wait ( 0 0$1 ) ;
1731: LD_INT 35
1733: PPUSH
1734: CALL_OW 67
// SayRadio ( Pla , DIntro-Pla-1 ) ;
1738: LD_LOC 3
1742: PPUSH
1743: LD_STRING DIntro-Pla-1
1745: PPUSH
1746: CALL_OW 94
// Say ( Bur , DIntro-Bur-1 ) ;
1750: LD_LOC 1
1754: PPUSH
1755: LD_STRING DIntro-Bur-1
1757: PPUSH
1758: CALL_OW 88
// SayRadio ( Pla , DIntro-Pla-2 ) ;
1762: LD_LOC 3
1766: PPUSH
1767: LD_STRING DIntro-Pla-2
1769: PPUSH
1770: CALL_OW 94
// Say ( Bur , DIntro-Bur-2 ) ;
1774: LD_LOC 1
1778: PPUSH
1779: LD_STRING DIntro-Bur-2
1781: PPUSH
1782: CALL_OW 88
// SayRadio ( Pla , DIntro-Pla-3 ) ;
1786: LD_LOC 3
1790: PPUSH
1791: LD_STRING DIntro-Pla-3
1793: PPUSH
1794: CALL_OW 94
// ComMoveToArea ( auta [ 1 ] , ru_exit ) ;
1798: LD_VAR 0 3
1802: PUSH
1803: LD_INT 1
1805: ARRAY
1806: PPUSH
1807: LD_INT 2
1809: PPUSH
1810: CALL_OW 113
// wait ( 0 0$1 ) ;
1814: LD_INT 35
1816: PPUSH
1817: CALL_OW 67
// for i := 1 to auta - 1 do
1821: LD_ADDR_VAR 0 4
1825: PUSH
1826: DOUBLE
1827: LD_INT 1
1829: DEC
1830: ST_TO_ADDR
1831: LD_VAR 0 3
1835: PUSH
1836: LD_INT 1
1838: MINUS
1839: PUSH
1840: FOR_TO
1841: IFFALSE 1882
// begin ComMoveUnit ( auta [ i + 1 ] , auta [ i ] ) ;
1843: LD_VAR 0 3
1847: PUSH
1848: LD_VAR 0 4
1852: PUSH
1853: LD_INT 1
1855: PLUS
1856: ARRAY
1857: PPUSH
1858: LD_VAR 0 3
1862: PUSH
1863: LD_VAR 0 4
1867: ARRAY
1868: PPUSH
1869: CALL_OW 112
// wait ( 0 0$1 ) ;
1873: LD_INT 35
1875: PPUSH
1876: CALL_OW 67
// end ;
1880: GO 1840
1882: POP
1883: POP
// AddComMoveToArea ( auta , ru_exit ) ;
1884: LD_VAR 0 3
1888: PPUSH
1889: LD_INT 2
1891: PPUSH
1892: CALL_OW 173
// mt := tick + 0 0$2 ;
1896: LD_ADDR_VAR 0 7
1900: PUSH
1901: LD_OWVAR 1
1905: PUSH
1906: LD_INT 70
1908: PLUS
1909: ST_TO_ADDR
// while FilterAllUnits ( [ [ f_side , you ] , [ f_placed ] ] ) do
1910: LD_INT 22
1912: PUSH
1913: LD_EXP 1
1917: PUSH
1918: EMPTY
1919: LIST
1920: LIST
1921: PUSH
1922: LD_INT 52
1924: PUSH
1925: EMPTY
1926: LIST
1927: PUSH
1928: EMPTY
1929: LIST
1930: LIST
1931: PPUSH
1932: CALL_OW 69
1936: IFFALSE 2376
// begin wait ( 0 0$0.2 ) ;
1938: LD_INT 7
1940: PPUSH
1941: CALL_OW 67
// CenterNowOnUnits ( IsInUnit ( Burlak ) ) ;
1945: LD_EXP 7
1949: PPUSH
1950: CALL_OW 310
1954: PPUSH
1955: CALL_OW 87
// for i in auta do
1959: LD_ADDR_VAR 0 4
1963: PUSH
1964: LD_VAR 0 3
1968: PUSH
1969: FOR_IN
1970: IFFALSE 2025
// begin if GetLives ( i ) < 500 then
1972: LD_VAR 0 4
1976: PPUSH
1977: CALL_OW 256
1981: PUSH
1982: LD_INT 500
1984: LESS
1985: IFFALSE 1999
// SetLives ( i , 500 ) ;
1987: LD_VAR 0 4
1991: PPUSH
1992: LD_INT 500
1994: PPUSH
1995: CALL_OW 234
// if not HasTask ( i ) then
1999: LD_VAR 0 4
2003: PPUSH
2004: CALL_OW 314
2008: NOT
2009: IFFALSE 2023
// ComMoveToArea ( i , ru_exit ) ;
2011: LD_VAR 0 4
2015: PPUSH
2016: LD_INT 2
2018: PPUSH
2019: CALL_OW 113
// end ;
2023: GO 1969
2025: POP
2026: POP
// for i in FilterUnitsInArea ( ru_exit , [ ] ) do
2027: LD_ADDR_VAR 0 4
2031: PUSH
2032: LD_INT 2
2034: PPUSH
2035: EMPTY
2036: PPUSH
2037: CALL_OW 70
2041: PUSH
2042: FOR_IN
2043: IFFALSE 2333
// begin if GetType ( i ) = unit_vehicle and GetSide ( i ) = 3 then
2045: LD_VAR 0 4
2049: PPUSH
2050: CALL_OW 247
2054: PUSH
2055: LD_INT 2
2057: EQUAL
2058: IFFALSE 2075
2060: PUSH
2061: LD_VAR 0 4
2065: PPUSH
2066: CALL_OW 255
2070: PUSH
2071: LD_INT 3
2073: EQUAL
2074: AND
2075: IFFALSE 2322
// begin driver = UnitsInside ( i ) [ 1 ] ;
2077: LD_ADDR_VAR 0 9
2081: PUSH
2082: LD_VAR 0 4
2086: PPUSH
2087: CALL_OW 313
2091: PUSH
2092: LD_INT 1
2094: ARRAY
2095: ST_TO_ADDR
// if driver = Burlak then
2096: LD_VAR 0 9
2100: PUSH
2101: LD_EXP 7
2105: EQUAL
2106: IFFALSE 2116
// driverShortName = Bur ;
2108: LD_ADDR_VAR 0 10
2112: PUSH
2113: LD_STRING Bur
2115: ST_TO_ADDR
// if driver = Karamazov then
2116: LD_VAR 0 9
2120: PUSH
2121: LD_EXP 9
2125: EQUAL
2126: IFFALSE 2136
// driverShortName = Kar ;
2128: LD_ADDR_VAR 0 10
2132: PUSH
2133: LD_STRING Kar
2135: ST_TO_ADDR
// if driver = Petrovova then
2136: LD_VAR 0 9
2140: PUSH
2141: LD_EXP 10
2145: EQUAL
2146: IFFALSE 2156
// driverShortName = Ptr ;
2148: LD_ADDR_VAR 0 10
2152: PUSH
2153: LD_STRING Ptr
2155: ST_TO_ADDR
// if driver = Gleb then
2156: LD_VAR 0 9
2160: PUSH
2161: LD_EXP 11
2165: EQUAL
2166: IFFALSE 2176
// driverShortName = Glb ;
2168: LD_ADDR_VAR 0 10
2172: PUSH
2173: LD_STRING Glb
2175: ST_TO_ADDR
// if driver = Petrosyan then
2176: LD_VAR 0 9
2180: PUSH
2181: LD_EXP 12
2185: EQUAL
2186: IFFALSE 2196
// driverShortName = Pet ;
2188: LD_ADDR_VAR 0 10
2192: PUSH
2193: LD_STRING Pet
2195: ST_TO_ADDR
// if driver = Dolgov then
2196: LD_VAR 0 9
2200: PUSH
2201: LD_EXP 13
2205: EQUAL
2206: IFFALSE 2216
// driverShortName = Dol ;
2208: LD_ADDR_VAR 0 10
2212: PUSH
2213: LD_STRING Dol
2215: ST_TO_ADDR
// if driver = Lipshchin then
2216: LD_VAR 0 9
2220: PUSH
2221: LD_EXP 14
2225: EQUAL
2226: IFFALSE 2236
// driverShortName = Lip ;
2228: LD_ADDR_VAR 0 10
2232: PUSH
2233: LD_STRING Lip
2235: ST_TO_ADDR
// if driver = Titov then
2236: LD_VAR 0 9
2240: PUSH
2241: LD_EXP 15
2245: EQUAL
2246: IFFALSE 2256
// driverShortName = Tit ;
2248: LD_ADDR_VAR 0 10
2252: PUSH
2253: LD_STRING Tit
2255: ST_TO_ADDR
// savedTanks = savedTanks ^ [ [ GetChassis ( i ) , GetEngine ( i ) , GetControl ( i ) , GetWeapon ( i ) , driverShortName ] ] ;
2256: LD_ADDR_EXP 6
2260: PUSH
2261: LD_EXP 6
2265: PUSH
2266: LD_VAR 0 4
2270: PPUSH
2271: CALL_OW 265
2275: PUSH
2276: LD_VAR 0 4
2280: PPUSH
2281: CALL_OW 262
2285: PUSH
2286: LD_VAR 0 4
2290: PPUSH
2291: CALL_OW 263
2295: PUSH
2296: LD_VAR 0 4
2300: PPUSH
2301: CALL_OW 264
2305: PUSH
2306: LD_VAR 0 10
2310: PUSH
2311: EMPTY
2312: LIST
2313: LIST
2314: LIST
2315: LIST
2316: LIST
2317: PUSH
2318: EMPTY
2319: LIST
2320: ADD
2321: ST_TO_ADDR
// end ; RemoveUnit ( i ) ;
2322: LD_VAR 0 4
2326: PPUSH
2327: CALL_OW 64
// end ;
2331: GO 2042
2333: POP
2334: POP
// if tick > mt then
2335: LD_OWVAR 1
2339: PUSH
2340: LD_VAR 0 7
2344: GREATER
2345: IFFALSE 2374
// begin CenterOnUnits ( auta [ 3 ] ) ;
2347: LD_VAR 0 3
2351: PUSH
2352: LD_INT 3
2354: ARRAY
2355: PPUSH
2356: CALL_OW 85
// mt := tick + 0 0$2 ;
2360: LD_ADDR_VAR 0 7
2364: PUSH
2365: LD_OWVAR 1
2369: PUSH
2370: LD_INT 70
2372: PLUS
2373: ST_TO_ADDR
// end ; end ;
2374: GO 1910
// ingame_video := false ;
2376: LD_ADDR_OWVAR 52
2380: PUSH
2381: LD_INT 0
2383: ST_TO_ADDR
// interface_hidden := false ;
2384: LD_ADDR_OWVAR 54
2388: PUSH
2389: LD_INT 0
2391: ST_TO_ADDR
// end ;
2392: LD_VAR 0 1
2396: RET
// every 0 0$0.5 marked 10 do var arabsc , arabsp , i ;
2397: GO 2399
2399: DISABLE
2400: LD_INT 0
2402: PPUSH
2403: PPUSH
2404: PPUSH
// begin ComEnterUnit ( ar1 , b1 ) ;
2405: LD_INT 26
2407: PPUSH
2408: LD_INT 1
2410: PPUSH
2411: CALL_OW 120
// ComEnterUnit ( ar2 , b2 ) ;
2415: LD_INT 16
2417: PPUSH
2418: LD_INT 2
2420: PPUSH
2421: CALL_OW 120
// arabsc := FilterAllUnits ( [ [ f_side , arabians ] , [ f_type , unit_vehicle ] ] ) ;
2425: LD_ADDR_VAR 0 1
2429: PUSH
2430: LD_INT 22
2432: PUSH
2433: LD_EXP 3
2437: PUSH
2438: EMPTY
2439: LIST
2440: LIST
2441: PUSH
2442: LD_INT 21
2444: PUSH
2445: LD_INT 2
2447: PUSH
2448: EMPTY
2449: LIST
2450: LIST
2451: PUSH
2452: EMPTY
2453: LIST
2454: LIST
2455: PPUSH
2456: CALL_OW 69
2460: ST_TO_ADDR
// arabsp := FilterAllUnits ( [ [ f_side , arabians ] , [ f_type , unit_human ] ] ) diff [ ar1 , ar2 ] ;
2461: LD_ADDR_VAR 0 2
2465: PUSH
2466: LD_INT 22
2468: PUSH
2469: LD_EXP 3
2473: PUSH
2474: EMPTY
2475: LIST
2476: LIST
2477: PUSH
2478: LD_INT 21
2480: PUSH
2481: LD_INT 1
2483: PUSH
2484: EMPTY
2485: LIST
2486: LIST
2487: PUSH
2488: EMPTY
2489: LIST
2490: LIST
2491: PPUSH
2492: CALL_OW 69
2496: PUSH
2497: LD_INT 26
2499: PUSH
2500: LD_INT 16
2502: PUSH
2503: EMPTY
2504: LIST
2505: LIST
2506: DIFF
2507: ST_TO_ADDR
// for i := 1 to arabsc do
2508: LD_ADDR_VAR 0 3
2512: PUSH
2513: DOUBLE
2514: LD_INT 1
2516: DEC
2517: ST_TO_ADDR
2518: LD_VAR 0 1
2522: PUSH
2523: FOR_TO
2524: IFFALSE 2554
// begin ComEnterUnit ( arabsp [ i ] , arabsc [ i ] ) ;
2526: LD_VAR 0 2
2530: PUSH
2531: LD_VAR 0 3
2535: ARRAY
2536: PPUSH
2537: LD_VAR 0 1
2541: PUSH
2542: LD_VAR 0 3
2546: ARRAY
2547: PPUSH
2548: CALL_OW 120
// end ;
2552: GO 2523
2554: POP
2555: POP
// while not UnitFilter ( arabsc , [ [ f_occupied ] ] ) do
2556: LD_VAR 0 1
2560: PPUSH
2561: LD_INT 59
2563: PUSH
2564: EMPTY
2565: LIST
2566: PUSH
2567: EMPTY
2568: LIST
2569: PPUSH
2570: CALL_OW 72
2574: NOT
2575: IFFALSE 2586
// wait ( 0 0$1 ) ;
2577: LD_INT 35
2579: PPUSH
2580: CALL_OW 67
2584: GO 2556
// wait ( 0 0$3 ) ;
2586: LD_INT 105
2588: PPUSH
2589: CALL_OW 67
// ComMoveToArea ( arabsc , ru_exit ) ;
2593: LD_VAR 0 1
2597: PPUSH
2598: LD_INT 2
2600: PPUSH
2601: CALL_OW 113
// wait ( 0 0$2 ) ;
2605: LD_INT 70
2607: PPUSH
2608: CALL_OW 67
// ComStop ( arabsc ) ;
2612: LD_VAR 0 1
2616: PPUSH
2617: CALL_OW 141
// wait ( 0 0$1 ) ;
2621: LD_INT 35
2623: PPUSH
2624: CALL_OW 67
// ComMoveToArea ( arabsc , ru_exit ) ;
2628: LD_VAR 0 1
2632: PPUSH
2633: LD_INT 2
2635: PPUSH
2636: CALL_OW 113
// end ;
2640: PPOPN 3
2642: END
// on DestinationUnreachable ( un ) do begin ComStop ( un ) ;
2643: LD_VAR 0 1
2647: PPUSH
2648: CALL_OW 141
// wait ( 0 0$0.5 ) ;
2652: LD_INT 18
2654: PPUSH
2655: CALL_OW 67
// AddComMoveToArea ( un , ru_exit ) ;
2659: LD_VAR 0 1
2663: PPUSH
2664: LD_INT 2
2666: PPUSH
2667: CALL_OW 173
// end ;
2671: PPOPN 1
2673: END
// on Contact ( side1 , side2 ) do begin if ( ( side1 = you ) and ( side2 = arabians ) ) or ( ( side2 = you ) and ( side1 = arabians ) ) then
2674: LD_VAR 0 1
2678: PUSH
2679: LD_EXP 1
2683: EQUAL
2684: IFFALSE 2698
2686: PUSH
2687: LD_VAR 0 2
2691: PUSH
2692: LD_EXP 3
2696: EQUAL
2697: AND
2698: IFTRUE 2726
2700: PUSH
2701: LD_VAR 0 2
2705: PUSH
2706: LD_EXP 1
2710: EQUAL
2711: IFFALSE 2725
2713: PUSH
2714: LD_VAR 0 1
2718: PUSH
2719: LD_EXP 3
2723: EQUAL
2724: AND
2725: OR
2726: IFFALSE 2744
// begin music_nat := nation_arabian_music ;
2728: LD_ADDR_OWVAR 71
2732: PUSH
2733: LD_INT 4
2735: ST_TO_ADDR
// music_class := music_combat ;
2736: LD_ADDR_OWVAR 72
2740: PUSH
2741: LD_INT 1
2743: ST_TO_ADDR
// end ; end ;
2744: PPOPN 2
2746: END
