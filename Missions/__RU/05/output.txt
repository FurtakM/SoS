// export you , americans , arabians , neutral ; export rulive ; export savedTanks ; starting begin Resetfog ;
   0: CALL_OW 335
// RandomizeAll ;
   4: CALL_OW 11
// YouLost ( Demo ) ;
   8: LD_STRING Demo
  10: PPUSH
  11: CALL_OW 104
// end ;
  15: END
// function set_sides ; begin
  16: LD_INT 0
  18: PPUSH
// you := 3 ;
  19: LD_ADDR_EXP 1
  23: PUSH
  24: LD_INT 3
  26: ST_TO_ADDR
// americans := 1 ;
  27: LD_ADDR_EXP 2
  31: PUSH
  32: LD_INT 1
  34: ST_TO_ADDR
// arabians := 2 ;
  35: LD_ADDR_EXP 3
  39: PUSH
  40: LD_INT 2
  42: ST_TO_ADDR
// neutral := 0 ;
  43: LD_ADDR_EXP 4
  47: PUSH
  48: LD_INT 0
  50: ST_TO_ADDR
// end ; end_of_file
  51: LD_VAR 0 1
  55: RET
// export Burlak , Platonov , Karamazov , Petrovova , Gleb , Petrosyan , Dolgov , Lipshchin , Titov ; export used , ru_cars , other_from6i ; export function load_chars ; var i , so , en , me , sc ; begin
  56: LD_INT 0
  58: PPUSH
  59: PPUSH
  60: PPUSH
  61: PPUSH
  62: PPUSH
  63: PPUSH
// InitUc ;
  64: CALL_OW 18
// InitHc ;
  68: CALL_OW 19
// uc_side := you ;
  72: LD_ADDR_OWVAR 20
  76: PUSH
  77: LD_EXP 1
  81: ST_TO_ADDR
// uc_nation := nation_russian ;
  82: LD_ADDR_OWVAR 21
  86: PUSH
  87: LD_INT 3
  89: ST_TO_ADDR
// Platonov := MyCreateCharacter ( Platonov , 0 , class_soldier , true ) ;
  90: LD_ADDR_EXP 8
  94: PUSH
  95: LD_STRING Platonov
  97: PPUSH
  98: LD_INT 0
 100: PPUSH
 101: LD_INT 1
 103: PPUSH
 104: LD_INT 1
 106: PPUSH
 107: CALL 1293 0 4
 111: ST_TO_ADDR
// Burlak := MyCreateCharacter ( 04_Burlak , 0 , class_mechanic , false ) ;
 112: LD_ADDR_EXP 7
 116: PUSH
 117: LD_STRING 04_Burlak
 119: PPUSH
 120: LD_INT 0
 122: PPUSH
 123: LD_INT 3
 125: PPUSH
 126: LD_INT 0
 128: PPUSH
 129: CALL 1293 0 4
 133: ST_TO_ADDR
// Karamazov := MyCreateCharacter ( Karamazov , 0 , class_engineer , true ) ;
 134: LD_ADDR_EXP 9
 138: PUSH
 139: LD_STRING Karamazov
 141: PPUSH
 142: LD_INT 0
 144: PPUSH
 145: LD_INT 2
 147: PPUSH
 148: LD_INT 1
 150: PPUSH
 151: CALL 1293 0 4
 155: ST_TO_ADDR
// Petrovova := MyCreateCharacter ( Petrovova , 0 , class_soldier , true ) ;
 156: LD_ADDR_EXP 10
 160: PUSH
 161: LD_STRING Petrovova
 163: PPUSH
 164: LD_INT 0
 166: PPUSH
 167: LD_INT 1
 169: PPUSH
 170: LD_INT 1
 172: PPUSH
 173: CALL 1293 0 4
 177: ST_TO_ADDR
// Gleb := MyCreateCharacter ( Gleb , 0 , class_soldier , true ) ;
 178: LD_ADDR_EXP 11
 182: PUSH
 183: LD_STRING Gleb
 185: PPUSH
 186: LD_INT 0
 188: PPUSH
 189: LD_INT 1
 191: PPUSH
 192: LD_INT 1
 194: PPUSH
 195: CALL 1293 0 4
 199: ST_TO_ADDR
// Petrosyan := MyCreateCharacter ( Petrosyan , 0 , class_scientistic , true ) ;
 200: LD_ADDR_EXP 12
 204: PUSH
 205: LD_STRING Petrosyan
 207: PPUSH
 208: LD_INT 0
 210: PPUSH
 211: LD_INT 4
 213: PPUSH
 214: LD_INT 1
 216: PPUSH
 217: CALL 1293 0 4
 221: ST_TO_ADDR
// Dolgov := MyCreateCharacter ( Dolgov , 0 , class_scientistic , true ) ;
 222: LD_ADDR_EXP 13
 226: PUSH
 227: LD_STRING Dolgov
 229: PPUSH
 230: LD_INT 0
 232: PPUSH
 233: LD_INT 4
 235: PPUSH
 236: LD_INT 1
 238: PPUSH
 239: CALL 1293 0 4
 243: ST_TO_ADDR
// Lipshchin := MyCreateCharacter ( Lipshchin , 0 , class_soldier , true ) ;
 244: LD_ADDR_EXP 14
 248: PUSH
 249: LD_STRING Lipshchin
 251: PPUSH
 252: LD_INT 0
 254: PPUSH
 255: LD_INT 1
 257: PPUSH
 258: LD_INT 1
 260: PPUSH
 261: CALL 1293 0 4
 265: ST_TO_ADDR
// Titov := MyCreateCharacter ( Titov , 0 , class_soldier , true ) ;
 266: LD_ADDR_EXP 15
 270: PUSH
 271: LD_STRING Titov
 273: PPUSH
 274: LD_INT 0
 276: PPUSH
 277: LD_INT 1
 279: PPUSH
 280: LD_INT 1
 282: PPUSH
 283: CALL 1293 0 4
 287: ST_TO_ADDR
// used := [ Burlak , Karamazov , Petrovova , Gleb , Petrosyan , Lipshchin , Dolgov , Titov ] diff 0 ;
 288: LD_ADDR_EXP 16
 292: PUSH
 293: LD_EXP 7
 297: PUSH
 298: LD_EXP 9
 302: PUSH
 303: LD_EXP 10
 307: PUSH
 308: LD_EXP 11
 312: PUSH
 313: LD_EXP 12
 317: PUSH
 318: LD_EXP 14
 322: PUSH
 323: LD_EXP 13
 327: PUSH
 328: LD_EXP 15
 332: PUSH
 333: EMPTY
 334: LIST
 335: LIST
 336: LIST
 337: LIST
 338: LIST
 339: LIST
 340: LIST
 341: LIST
 342: PUSH
 343: LD_INT 0
 345: DIFF
 346: ST_TO_ADDR
// so := ( UnitFilter ( used , [ [ f_class , class_soldier ] ] ) + 0 ) ;
 347: LD_ADDR_VAR 0 3
 351: PUSH
 352: LD_EXP 16
 356: PPUSH
 357: LD_INT 25
 359: PUSH
 360: LD_INT 1
 362: PUSH
 363: EMPTY
 364: LIST
 365: LIST
 366: PUSH
 367: EMPTY
 368: LIST
 369: PPUSH
 370: CALL_OW 72
 374: PUSH
 375: LD_INT 0
 377: PLUS
 378: ST_TO_ADDR
// en := ( UnitFilter ( used , [ [ f_class , class_engineer ] ] ) + 0 ) ;
 379: LD_ADDR_VAR 0 4
 383: PUSH
 384: LD_EXP 16
 388: PPUSH
 389: LD_INT 25
 391: PUSH
 392: LD_INT 2
 394: PUSH
 395: EMPTY
 396: LIST
 397: LIST
 398: PUSH
 399: EMPTY
 400: LIST
 401: PPUSH
 402: CALL_OW 72
 406: PUSH
 407: LD_INT 0
 409: PLUS
 410: ST_TO_ADDR
// me := ( UnitFilter ( used , [ [ f_class , class_mechanic ] ] ) + 0 ) ;
 411: LD_ADDR_VAR 0 5
 415: PUSH
 416: LD_EXP 16
 420: PPUSH
 421: LD_INT 25
 423: PUSH
 424: LD_INT 3
 426: PUSH
 427: EMPTY
 428: LIST
 429: LIST
 430: PUSH
 431: EMPTY
 432: LIST
 433: PPUSH
 434: CALL_OW 72
 438: PUSH
 439: LD_INT 0
 441: PLUS
 442: ST_TO_ADDR
// sc := ( UnitFilter ( used , [ [ f_class , class_scientistic ] ] ) + 0 ) ;
 443: LD_ADDR_VAR 0 6
 447: PUSH
 448: LD_EXP 16
 452: PPUSH
 453: LD_INT 25
 455: PUSH
 456: LD_INT 4
 458: PUSH
 459: EMPTY
 460: LIST
 461: LIST
 462: PUSH
 463: EMPTY
 464: LIST
 465: PPUSH
 466: CALL_OW 72
 470: PUSH
 471: LD_INT 0
 473: PLUS
 474: ST_TO_ADDR
// for i := so to 4 do
 475: LD_ADDR_VAR 0 2
 479: PUSH
 480: DOUBLE
 481: LD_VAR 0 3
 485: DEC
 486: ST_TO_ADDR
 487: LD_INT 4
 489: PUSH
 490: FOR_TO
 491: IFFALSE 533
// begin PrepareSoldier ( Rand ( 10 , 23 ) div 10 , 3 ) ;
 493: LD_INT 10
 495: PPUSH
 496: LD_INT 23
 498: PPUSH
 499: CALL_OW 12
 503: PUSH
 504: LD_INT 10
 506: DIV
 507: PPUSH
 508: LD_INT 3
 510: PPUSH
 511: CALL_OW 381
// used := used ^ CreateHuman ;
 515: LD_ADDR_EXP 16
 519: PUSH
 520: LD_EXP 16
 524: PUSH
 525: CALL_OW 44
 529: ADD
 530: ST_TO_ADDR
// end ;
 531: GO 490
 533: POP
 534: POP
// for i := en to 1 do
 535: LD_ADDR_VAR 0 2
 539: PUSH
 540: DOUBLE
 541: LD_VAR 0 4
 545: DEC
 546: ST_TO_ADDR
 547: LD_INT 1
 549: PUSH
 550: FOR_TO
 551: IFFALSE 593
// begin PrepareEngineer ( Rand ( 10 , 23 ) div 10 , 3 ) ;
 553: LD_INT 10
 555: PPUSH
 556: LD_INT 23
 558: PPUSH
 559: CALL_OW 12
 563: PUSH
 564: LD_INT 10
 566: DIV
 567: PPUSH
 568: LD_INT 3
 570: PPUSH
 571: CALL_OW 382
// used := used ^ CreateHuman ;
 575: LD_ADDR_EXP 16
 579: PUSH
 580: LD_EXP 16
 584: PUSH
 585: CALL_OW 44
 589: ADD
 590: ST_TO_ADDR
// end ;
 591: GO 550
 593: POP
 594: POP
// for i := me to 1 do
 595: LD_ADDR_VAR 0 2
 599: PUSH
 600: DOUBLE
 601: LD_VAR 0 5
 605: DEC
 606: ST_TO_ADDR
 607: LD_INT 1
 609: PUSH
 610: FOR_TO
 611: IFFALSE 653
// begin PrepareMechanic ( Rand ( 10 , 23 ) div 10 , 3 ) ;
 613: LD_INT 10
 615: PPUSH
 616: LD_INT 23
 618: PPUSH
 619: CALL_OW 12
 623: PUSH
 624: LD_INT 10
 626: DIV
 627: PPUSH
 628: LD_INT 3
 630: PPUSH
 631: CALL_OW 383
// used := used ^ CreateHuman ;
 635: LD_ADDR_EXP 16
 639: PUSH
 640: LD_EXP 16
 644: PUSH
 645: CALL_OW 44
 649: ADD
 650: ST_TO_ADDR
// end ;
 651: GO 610
 653: POP
 654: POP
// for i := sc to 2 do
 655: LD_ADDR_VAR 0 2
 659: PUSH
 660: DOUBLE
 661: LD_VAR 0 6
 665: DEC
 666: ST_TO_ADDR
 667: LD_INT 2
 669: PUSH
 670: FOR_TO
 671: IFFALSE 713
// begin PrepareScientist ( Rand ( 10 , 23 ) div 10 , 3 ) ;
 673: LD_INT 10
 675: PPUSH
 676: LD_INT 23
 678: PPUSH
 679: CALL_OW 12
 683: PUSH
 684: LD_INT 10
 686: DIV
 687: PPUSH
 688: LD_INT 3
 690: PPUSH
 691: CALL_OW 384
// used := used ^ CreateHuman ;
 695: LD_ADDR_EXP 16
 699: PUSH
 700: LD_EXP 16
 704: PUSH
 705: CALL_OW 44
 709: ADD
 710: ST_TO_ADDR
// end ;
 711: GO 670
 713: POP
 714: POP
// end ;
 715: LD_VAR 0 1
 719: RET
// export function place_in_ru_cars ; var cars , car , i , rnd ; begin
 720: LD_INT 0
 722: PPUSH
 723: PPUSH
 724: PPUSH
 725: PPUSH
 726: PPUSH
// cars := [ ] ;
 727: LD_ADDR_VAR 0 2
 731: PUSH
 732: EMPTY
 733: ST_TO_ADDR
// for i = 1 to 8 do
 734: LD_ADDR_VAR 0 4
 738: PUSH
 739: DOUBLE
 740: LD_INT 1
 742: DEC
 743: ST_TO_ADDR
 744: LD_INT 8
 746: PUSH
 747: FOR_TO
 748: IFFALSE 1060
// begin rnd = rand ( 1 , 100 ) ;
 750: LD_ADDR_VAR 0 5
 754: PUSH
 755: LD_INT 1
 757: PPUSH
 758: LD_INT 100
 760: PPUSH
 761: CALL_OW 12
 765: ST_TO_ADDR
// if Difficulty = 1 then
 766: LD_OWVAR 67
 770: PUSH
 771: LD_INT 1
 773: EQUAL
 774: IFFALSE 857
// begin case rnd of 1 .. 50 :
 776: LD_VAR 0 5
 780: PUSH
 781: LD_INT 1
 783: DOUBLE
 784: GREATEREQUAL
 785: IFFALSE 793
 787: LD_INT 50
 789: DOUBLE
 790: LESSEQUAL
 791: IFTRUE 795
 793: GO 806
 795: POP
// vc_weapon = ru_gun ; 51 .. 85 :
 796: LD_ADDR_OWVAR 40
 800: PUSH
 801: LD_INT 44
 803: ST_TO_ADDR
 804: GO 857
 806: LD_INT 51
 808: DOUBLE
 809: GREATEREQUAL
 810: IFFALSE 818
 812: LD_INT 85
 814: DOUBLE
 815: LESSEQUAL
 816: IFTRUE 820
 818: GO 831
 820: POP
// vc_weapon = ru_gatling_gun ; 86 .. 100 :
 821: LD_ADDR_OWVAR 40
 825: PUSH
 826: LD_INT 43
 828: ST_TO_ADDR
 829: GO 857
 831: LD_INT 86
 833: DOUBLE
 834: GREATEREQUAL
 835: IFFALSE 843
 837: LD_INT 100
 839: DOUBLE
 840: LESSEQUAL
 841: IFTRUE 845
 843: GO 856
 845: POP
// vc_weapon = ru_heavy_machine_gun ; end ;
 846: LD_ADDR_OWVAR 40
 850: PUSH
 851: LD_INT 42
 853: ST_TO_ADDR
 854: GO 857
 856: POP
// end ; if Difficulty = 2 then
 857: LD_OWVAR 67
 861: PUSH
 862: LD_INT 2
 864: EQUAL
 865: IFFALSE 948
// begin case rnd of 1 .. 30 :
 867: LD_VAR 0 5
 871: PUSH
 872: LD_INT 1
 874: DOUBLE
 875: GREATEREQUAL
 876: IFFALSE 884
 878: LD_INT 30
 880: DOUBLE
 881: LESSEQUAL
 882: IFTRUE 886
 884: GO 897
 886: POP
// vc_weapon = ru_gun ; 31 .. 75 :
 887: LD_ADDR_OWVAR 40
 891: PUSH
 892: LD_INT 44
 894: ST_TO_ADDR
 895: GO 948
 897: LD_INT 31
 899: DOUBLE
 900: GREATEREQUAL
 901: IFFALSE 909
 903: LD_INT 75
 905: DOUBLE
 906: LESSEQUAL
 907: IFTRUE 911
 909: GO 922
 911: POP
// vc_weapon = ru_gatling_gun ; 76 .. 100 :
 912: LD_ADDR_OWVAR 40
 916: PUSH
 917: LD_INT 43
 919: ST_TO_ADDR
 920: GO 948
 922: LD_INT 76
 924: DOUBLE
 925: GREATEREQUAL
 926: IFFALSE 934
 928: LD_INT 100
 930: DOUBLE
 931: LESSEQUAL
 932: IFTRUE 936
 934: GO 947
 936: POP
// vc_weapon = ru_heavy_machine_gun ; end ;
 937: LD_ADDR_OWVAR 40
 941: PUSH
 942: LD_INT 42
 944: ST_TO_ADDR
 945: GO 948
 947: POP
// end ; if Difficulty = 3 then
 948: LD_OWVAR 67
 952: PUSH
 953: LD_INT 3
 955: EQUAL
 956: IFFALSE 1039
// begin case rnd of 1 .. 20 :
 958: LD_VAR 0 5
 962: PUSH
 963: LD_INT 1
 965: DOUBLE
 966: GREATEREQUAL
 967: IFFALSE 975
 969: LD_INT 20
 971: DOUBLE
 972: LESSEQUAL
 973: IFTRUE 977
 975: GO 988
 977: POP
// vc_weapon = ru_gun ; 21 .. 50 :
 978: LD_ADDR_OWVAR 40
 982: PUSH
 983: LD_INT 44
 985: ST_TO_ADDR
 986: GO 1039
 988: LD_INT 21
 990: DOUBLE
 991: GREATEREQUAL
 992: IFFALSE 1000
 994: LD_INT 50
 996: DOUBLE
 997: LESSEQUAL
 998: IFTRUE 1002
1000: GO 1013
1002: POP
// vc_weapon = ru_gatling_gun ; 51 .. 100 :
1003: LD_ADDR_OWVAR 40
1007: PUSH
1008: LD_INT 43
1010: ST_TO_ADDR
1011: GO 1039
1013: LD_INT 51
1015: DOUBLE
1016: GREATEREQUAL
1017: IFFALSE 1025
1019: LD_INT 100
1021: DOUBLE
1022: LESSEQUAL
1023: IFTRUE 1027
1025: GO 1038
1027: POP
// vc_weapon = ru_heavy_machine_gun ; end ;
1028: LD_ADDR_OWVAR 40
1032: PUSH
1033: LD_INT 42
1035: ST_TO_ADDR
1036: GO 1039
1038: POP
// end ; cars = cars ^ [ vc_weapon ] ;
1039: LD_ADDR_VAR 0 2
1043: PUSH
1044: LD_VAR 0 2
1048: PUSH
1049: LD_OWVAR 40
1053: PUSH
1054: EMPTY
1055: LIST
1056: ADD
1057: ST_TO_ADDR
// end ;
1058: GO 747
1060: POP
1061: POP
// InitUc ;
1062: CALL_OW 18
// InitVc ;
1066: CALL_OW 20
// vc_control := control_manual ;
1070: LD_ADDR_OWVAR 38
1074: PUSH
1075: LD_INT 1
1077: ST_TO_ADDR
// vc_engine := engine_combustion ;
1078: LD_ADDR_OWVAR 39
1082: PUSH
1083: LD_INT 1
1085: ST_TO_ADDR
// uc_side := you ;
1086: LD_ADDR_OWVAR 20
1090: PUSH
1091: LD_EXP 1
1095: ST_TO_ADDR
// uc_nation := nation_russian ;
1096: LD_ADDR_OWVAR 21
1100: PUSH
1101: LD_INT 3
1103: ST_TO_ADDR
// ru_cars := [ ] ;
1104: LD_ADDR_EXP 17
1108: PUSH
1109: EMPTY
1110: ST_TO_ADDR
// for i := 1 to 8 do
1111: LD_ADDR_VAR 0 4
1115: PUSH
1116: DOUBLE
1117: LD_INT 1
1119: DEC
1120: ST_TO_ADDR
1121: LD_INT 8
1123: PUSH
1124: FOR_TO
1125: IFFALSE 1243
// begin vc_chassis := ru_medium_tracked ;
1127: LD_ADDR_OWVAR 37
1131: PUSH
1132: LD_INT 22
1134: ST_TO_ADDR
// vc_weapon := cars [ i ] ;
1135: LD_ADDR_OWVAR 40
1139: PUSH
1140: LD_VAR 0 2
1144: PUSH
1145: LD_VAR 0 4
1149: ARRAY
1150: ST_TO_ADDR
// uc_direction := 5 ;
1151: LD_ADDR_OWVAR 24
1155: PUSH
1156: LD_INT 5
1158: ST_TO_ADDR
// vc_fuel_battery := Rand ( 70 , 90 ) ;
1159: LD_ADDR_OWVAR 41
1163: PUSH
1164: LD_INT 70
1166: PPUSH
1167: LD_INT 90
1169: PPUSH
1170: CALL_OW 12
1174: ST_TO_ADDR
// car := CreateVehicle ;
1175: LD_ADDR_VAR 0 3
1179: PUSH
1180: CALL_OW 45
1184: ST_TO_ADDR
// ru_cars := ru_cars ^ car ;
1185: LD_ADDR_EXP 17
1189: PUSH
1190: LD_EXP 17
1194: PUSH
1195: LD_VAR 0 3
1199: ADD
1200: ST_TO_ADDR
// PlaceHumanInUnit ( used [ i ] , car ) ;
1201: LD_EXP 16
1205: PUSH
1206: LD_VAR 0 4
1210: ARRAY
1211: PPUSH
1212: LD_VAR 0 3
1216: PPUSH
1217: CALL_OW 52
// SetLives ( car , Rand ( 750 , 1000 ) ) ;
1221: LD_VAR 0 3
1225: PPUSH
1226: LD_INT 750
1228: PPUSH
1229: LD_INT 1000
1231: PPUSH
1232: CALL_OW 12
1236: PPUSH
1237: CALL_OW 234
// end ;
1241: GO 1124
1243: POP
1244: POP
// end ;
1245: LD_VAR 0 1
1249: RET
// export function place_ru_cars ( area ) ; var i ; begin
1250: LD_INT 0
1252: PPUSH
1253: PPUSH
// for i in ru_cars do
1254: LD_ADDR_VAR 0 3
1258: PUSH
1259: LD_EXP 17
1263: PUSH
1264: FOR_IN
1265: IFFALSE 1286
// PlaceUnitArea ( i , area , false ) ;
1267: LD_VAR 0 3
1271: PPUSH
1272: LD_VAR 0 1
1276: PPUSH
1277: LD_INT 0
1279: PPUSH
1280: CALL_OW 49
1284: GO 1264
1286: POP
1287: POP
// end ;
1288: LD_VAR 0 2
1292: RET
// function MyCreateCharacter ( name , loc , unclass , new ) ; begin
1293: LD_INT 0
1295: PPUSH
// if new then
1296: LD_VAR 0 4
1300: IFFALSE 1319
// result := NewCharacter ( name ) else
1302: LD_ADDR_VAR 0 5
1306: PUSH
1307: LD_VAR 0 1
1311: PPUSH
1312: CALL_OW 25
1316: ST_TO_ADDR
1317: GO 1355
// begin if CheckCharacterSet ( name ) then
1319: LD_VAR 0 1
1323: PPUSH
1324: CALL_OW 29
1328: IFFALSE 1347
// result := CreateCharacter ( name ) else
1330: LD_ADDR_VAR 0 5
1334: PUSH
1335: LD_VAR 0 1
1339: PPUSH
1340: CALL_OW 34
1344: ST_TO_ADDR
1345: GO 1355
// result := 0 ;
1347: LD_ADDR_VAR 0 5
1351: PUSH
1352: LD_INT 0
1354: ST_TO_ADDR
// end ; if unclass then
1355: LD_VAR 0 3
1359: IFFALSE 1375
// SetClass ( result , unclass ) ;
1361: LD_VAR 0 5
1365: PPUSH
1366: LD_VAR 0 3
1370: PPUSH
1371: CALL_OW 336
// end ;
1375: LD_VAR 0 5
1379: RET
// export function Save ; begin
1380: LD_INT 0
1382: PPUSH
// SaveVariable ( savedTanks , 05_TanksIntro_1 ) ;
1383: LD_EXP 6
1387: PPUSH
1388: LD_STRING 05_TanksIntro_1
1390: PPUSH
1391: CALL_OW 39
// end ; end_of_file
1395: LD_VAR 0 1
1399: RET
// var Bur , Bel , Pla , Kar , Ptr , Glb , Pet , Stv , Dol , Lip , Tit ; var donttalk ; function set_shorts ; begin
1400: LD_INT 0
1402: PPUSH
// Bur := Burlak ;
1403: LD_ADDR_LOC 1
1407: PUSH
1408: LD_EXP 7
1412: ST_TO_ADDR
// Pla := Platonov ;
1413: LD_ADDR_LOC 3
1417: PUSH
1418: LD_EXP 8
1422: ST_TO_ADDR
// Kar := Karamazov ;
1423: LD_ADDR_LOC 4
1427: PUSH
1428: LD_EXP 9
1432: ST_TO_ADDR
// Ptr := Petrovova ;
1433: LD_ADDR_LOC 5
1437: PUSH
1438: LD_EXP 10
1442: ST_TO_ADDR
// Glb := Gleb ;
1443: LD_ADDR_LOC 6
1447: PUSH
1448: LD_EXP 11
1452: ST_TO_ADDR
// Pet := Petrosyan ;
1453: LD_ADDR_LOC 7
1457: PUSH
1458: LD_EXP 12
1462: ST_TO_ADDR
// Dol := Dolgov ;
1463: LD_ADDR_LOC 9
1467: PUSH
1468: LD_EXP 13
1472: ST_TO_ADDR
// Lip := Lipshchin ;
1473: LD_ADDR_LOC 10
1477: PUSH
1478: LD_EXP 14
1482: ST_TO_ADDR
// Tit := Titov ;
1483: LD_ADDR_LOC 11
1487: PUSH
1488: LD_EXP 15
1492: ST_TO_ADDR
// donttalk := used diff [ Burlak , Karamazov , Petrovova , Gleb , Petrosyan ] ;
1493: LD_ADDR_LOC 12
1497: PUSH
1498: LD_EXP 16
1502: PUSH
1503: LD_EXP 7
1507: PUSH
1508: LD_EXP 9
1512: PUSH
1513: LD_EXP 10
1517: PUSH
1518: LD_EXP 11
1522: PUSH
1523: LD_EXP 12
1527: PUSH
1528: EMPTY
1529: LIST
1530: LIST
1531: LIST
1532: LIST
1533: LIST
1534: DIFF
1535: ST_TO_ADDR
// end ;
1536: LD_VAR 0 1
1540: RET
// export function DIntro ; var pos , auta , i , hex , rcars , mt , vzdal , driver , driverShortName ; begin
1541: LD_INT 0
1543: PPUSH
1544: PPUSH
1545: PPUSH
1546: PPUSH
1547: PPUSH
1548: PPUSH
1549: PPUSH
1550: PPUSH
1551: PPUSH
1552: PPUSH
// set_shorts ;
1553: CALL 1400 0 0
// auta := FilterAllUnits ( [ [ f_side , you ] , [ f_type , unit_vehicle ] ] ) ;
1557: LD_ADDR_VAR 0 3
1561: PUSH
1562: LD_INT 22
1564: PUSH
1565: LD_EXP 1
1569: PUSH
1570: EMPTY
1571: LIST
1572: LIST
1573: PUSH
1574: LD_INT 21
1576: PUSH
1577: LD_INT 2
1579: PUSH
1580: EMPTY
1581: LIST
1582: LIST
1583: PUSH
1584: EMPTY
1585: LIST
1586: LIST
1587: PPUSH
1588: CALL_OW 69
1592: ST_TO_ADDR
// vzdal := [ ] ;
1593: LD_ADDR_VAR 0 8
1597: PUSH
1598: EMPTY
1599: ST_TO_ADDR
// for i in auta do
1600: LD_ADDR_VAR 0 4
1604: PUSH
1605: LD_VAR 0 3
1609: PUSH
1610: FOR_IN
1611: IFFALSE 1645
// begin vzdal := vzdal ^ [ GetDistUnitXY ( i , 20 , 2 ) ] ;
1613: LD_ADDR_VAR 0 8
1617: PUSH
1618: LD_VAR 0 8
1622: PUSH
1623: LD_VAR 0 4
1627: PPUSH
1628: LD_INT 20
1630: PPUSH
1631: LD_INT 2
1633: PPUSH
1634: CALL_OW 297
1638: PUSH
1639: EMPTY
1640: LIST
1641: ADD
1642: ST_TO_ADDR
// end ;
1643: GO 1610
1645: POP
1646: POP
// auta := SortListByListAsc ( auta , vzdal ) ;
1647: LD_ADDR_VAR 0 3
1651: PUSH
1652: LD_VAR 0 3
1656: PPUSH
1657: LD_VAR 0 8
1661: PPUSH
1662: CALL_OW 76
1666: ST_TO_ADDR
// CenterNowOnUnits ( auta ) ;
1667: LD_VAR 0 3
1671: PPUSH
1672: CALL_OW 87
// RevealFogArea ( you , co_vidi ) ;
1676: LD_EXP 1
1680: PPUSH
1681: LD_INT 3
1683: PPUSH
1684: CALL_OW 332
// enable ( 10 ) ;
1688: LD_INT 10
1690: ENABLE_MARKED
// wait ( 0 0$1 ) ;
1691: LD_INT 35
1693: PPUSH
1694: CALL_OW 67
// SayRadio ( Pla , DIntro-Pla-1 ) ;
1698: LD_LOC 3
1702: PPUSH
1703: LD_STRING DIntro-Pla-1
1705: PPUSH
1706: CALL_OW 94
// Say ( Bur , DIntro-Bur-1 ) ;
1710: LD_LOC 1
1714: PPUSH
1715: LD_STRING DIntro-Bur-1
1717: PPUSH
1718: CALL_OW 88
// SayRadio ( Pla , DIntro-Pla-2 ) ;
1722: LD_LOC 3
1726: PPUSH
1727: LD_STRING DIntro-Pla-2
1729: PPUSH
1730: CALL_OW 94
// Say ( Bur , DIntro-Bur-2 ) ;
1734: LD_LOC 1
1738: PPUSH
1739: LD_STRING DIntro-Bur-2
1741: PPUSH
1742: CALL_OW 88
// SayRadio ( Pla , DIntro-Pla-3 ) ;
1746: LD_LOC 3
1750: PPUSH
1751: LD_STRING DIntro-Pla-3
1753: PPUSH
1754: CALL_OW 94
// ComMoveToArea ( auta [ 1 ] , ru_exit ) ;
1758: LD_VAR 0 3
1762: PUSH
1763: LD_INT 1
1765: ARRAY
1766: PPUSH
1767: LD_INT 2
1769: PPUSH
1770: CALL_OW 113
// wait ( 0 0$1 ) ;
1774: LD_INT 35
1776: PPUSH
1777: CALL_OW 67
// for i := 1 to auta - 1 do
1781: LD_ADDR_VAR 0 4
1785: PUSH
1786: DOUBLE
1787: LD_INT 1
1789: DEC
1790: ST_TO_ADDR
1791: LD_VAR 0 3
1795: PUSH
1796: LD_INT 1
1798: MINUS
1799: PUSH
1800: FOR_TO
1801: IFFALSE 1842
// begin ComMoveUnit ( auta [ i + 1 ] , auta [ i ] ) ;
1803: LD_VAR 0 3
1807: PUSH
1808: LD_VAR 0 4
1812: PUSH
1813: LD_INT 1
1815: PLUS
1816: ARRAY
1817: PPUSH
1818: LD_VAR 0 3
1822: PUSH
1823: LD_VAR 0 4
1827: ARRAY
1828: PPUSH
1829: CALL_OW 112
// wait ( 0 0$1 ) ;
1833: LD_INT 35
1835: PPUSH
1836: CALL_OW 67
// end ;
1840: GO 1800
1842: POP
1843: POP
// AddComMoveToArea ( auta , ru_exit ) ;
1844: LD_VAR 0 3
1848: PPUSH
1849: LD_INT 2
1851: PPUSH
1852: CALL_OW 173
// mt := tick + 0 0$2 ;
1856: LD_ADDR_VAR 0 7
1860: PUSH
1861: LD_OWVAR 1
1865: PUSH
1866: LD_INT 70
1868: PLUS
1869: ST_TO_ADDR
// while FilterAllUnits ( [ [ f_side , you ] , [ f_placed ] ] ) do
1870: LD_INT 22
1872: PUSH
1873: LD_EXP 1
1877: PUSH
1878: EMPTY
1879: LIST
1880: LIST
1881: PUSH
1882: LD_INT 52
1884: PUSH
1885: EMPTY
1886: LIST
1887: PUSH
1888: EMPTY
1889: LIST
1890: LIST
1891: PPUSH
1892: CALL_OW 69
1896: IFFALSE 2334
// begin wait ( 0 0$0.2 ) ;
1898: LD_INT 7
1900: PPUSH
1901: CALL_OW 67
// CenterNowOnUnits ( IsInUnit ( Burlak ) ) ;
1905: LD_EXP 7
1909: PPUSH
1910: CALL_OW 310
1914: PPUSH
1915: CALL_OW 87
// for i in auta do
1919: LD_ADDR_VAR 0 4
1923: PUSH
1924: LD_VAR 0 3
1928: PUSH
1929: FOR_IN
1930: IFFALSE 1985
// begin if GetLives ( i ) < 500 then
1932: LD_VAR 0 4
1936: PPUSH
1937: CALL_OW 256
1941: PUSH
1942: LD_INT 500
1944: LESS
1945: IFFALSE 1959
// SetLives ( i , 500 ) ;
1947: LD_VAR 0 4
1951: PPUSH
1952: LD_INT 500
1954: PPUSH
1955: CALL_OW 234
// if not HasTask ( i ) then
1959: LD_VAR 0 4
1963: PPUSH
1964: CALL_OW 314
1968: NOT
1969: IFFALSE 1983
// ComMoveToArea ( i , ru_exit ) ;
1971: LD_VAR 0 4
1975: PPUSH
1976: LD_INT 2
1978: PPUSH
1979: CALL_OW 113
// end ;
1983: GO 1929
1985: POP
1986: POP
// for i in FilterUnitsInArea ( ru_exit , [ ] ) do
1987: LD_ADDR_VAR 0 4
1991: PUSH
1992: LD_INT 2
1994: PPUSH
1995: EMPTY
1996: PPUSH
1997: CALL_OW 70
2001: PUSH
2002: FOR_IN
2003: IFFALSE 2291
// begin if GetType ( i ) = unit_vehicle and GetSide ( i ) = 3 then
2005: LD_VAR 0 4
2009: PPUSH
2010: CALL_OW 247
2014: PUSH
2015: LD_INT 2
2017: EQUAL
2018: PUSH
2019: LD_VAR 0 4
2023: PPUSH
2024: CALL_OW 255
2028: PUSH
2029: LD_INT 3
2031: EQUAL
2032: AND
2033: IFFALSE 2280
// begin driver = UnitsInside ( i ) [ 1 ] ;
2035: LD_ADDR_VAR 0 9
2039: PUSH
2040: LD_VAR 0 4
2044: PPUSH
2045: CALL_OW 313
2049: PUSH
2050: LD_INT 1
2052: ARRAY
2053: ST_TO_ADDR
// if driver = Burlak then
2054: LD_VAR 0 9
2058: PUSH
2059: LD_EXP 7
2063: EQUAL
2064: IFFALSE 2074
// driverShortName = Bur ;
2066: LD_ADDR_VAR 0 10
2070: PUSH
2071: LD_STRING Bur
2073: ST_TO_ADDR
// if driver = Karamazov then
2074: LD_VAR 0 9
2078: PUSH
2079: LD_EXP 9
2083: EQUAL
2084: IFFALSE 2094
// driverShortName = Kar ;
2086: LD_ADDR_VAR 0 10
2090: PUSH
2091: LD_STRING Kar
2093: ST_TO_ADDR
// if driver = Petrovova then
2094: LD_VAR 0 9
2098: PUSH
2099: LD_EXP 10
2103: EQUAL
2104: IFFALSE 2114
// driverShortName = Ptr ;
2106: LD_ADDR_VAR 0 10
2110: PUSH
2111: LD_STRING Ptr
2113: ST_TO_ADDR
// if driver = Gleb then
2114: LD_VAR 0 9
2118: PUSH
2119: LD_EXP 11
2123: EQUAL
2124: IFFALSE 2134
// driverShortName = Glb ;
2126: LD_ADDR_VAR 0 10
2130: PUSH
2131: LD_STRING Glb
2133: ST_TO_ADDR
// if driver = Petrosyan then
2134: LD_VAR 0 9
2138: PUSH
2139: LD_EXP 12
2143: EQUAL
2144: IFFALSE 2154
// driverShortName = Pet ;
2146: LD_ADDR_VAR 0 10
2150: PUSH
2151: LD_STRING Pet
2153: ST_TO_ADDR
// if driver = Dolgov then
2154: LD_VAR 0 9
2158: PUSH
2159: LD_EXP 13
2163: EQUAL
2164: IFFALSE 2174
// driverShortName = Dol ;
2166: LD_ADDR_VAR 0 10
2170: PUSH
2171: LD_STRING Dol
2173: ST_TO_ADDR
// if driver = Lipshchin then
2174: LD_VAR 0 9
2178: PUSH
2179: LD_EXP 14
2183: EQUAL
2184: IFFALSE 2194
// driverShortName = Lip ;
2186: LD_ADDR_VAR 0 10
2190: PUSH
2191: LD_STRING Lip
2193: ST_TO_ADDR
// if driver = Titov then
2194: LD_VAR 0 9
2198: PUSH
2199: LD_EXP 15
2203: EQUAL
2204: IFFALSE 2214
// driverShortName = Tit ;
2206: LD_ADDR_VAR 0 10
2210: PUSH
2211: LD_STRING Tit
2213: ST_TO_ADDR
// savedTanks = savedTanks ^ [ [ GetChassis ( i ) , GetEngine ( i ) , GetControl ( i ) , GetWeapon ( i ) , driverShortName ] ] ;
2214: LD_ADDR_EXP 6
2218: PUSH
2219: LD_EXP 6
2223: PUSH
2224: LD_VAR 0 4
2228: PPUSH
2229: CALL_OW 265
2233: PUSH
2234: LD_VAR 0 4
2238: PPUSH
2239: CALL_OW 262
2243: PUSH
2244: LD_VAR 0 4
2248: PPUSH
2249: CALL_OW 263
2253: PUSH
2254: LD_VAR 0 4
2258: PPUSH
2259: CALL_OW 264
2263: PUSH
2264: LD_VAR 0 10
2268: PUSH
2269: EMPTY
2270: LIST
2271: LIST
2272: LIST
2273: LIST
2274: LIST
2275: PUSH
2276: EMPTY
2277: LIST
2278: ADD
2279: ST_TO_ADDR
// end ; RemoveUnit ( i ) ;
2280: LD_VAR 0 4
2284: PPUSH
2285: CALL_OW 64
// end ;
2289: GO 2002
2291: POP
2292: POP
// if tick > mt then
2293: LD_OWVAR 1
2297: PUSH
2298: LD_VAR 0 7
2302: GREATER
2303: IFFALSE 2332
// begin CenterOnUnits ( auta [ 3 ] ) ;
2305: LD_VAR 0 3
2309: PUSH
2310: LD_INT 3
2312: ARRAY
2313: PPUSH
2314: CALL_OW 85
// mt := tick + 0 0$2 ;
2318: LD_ADDR_VAR 0 7
2322: PUSH
2323: LD_OWVAR 1
2327: PUSH
2328: LD_INT 70
2330: PLUS
2331: ST_TO_ADDR
// end ; end ;
2332: GO 1870
// ingame_video := false ;
2334: LD_ADDR_OWVAR 52
2338: PUSH
2339: LD_INT 0
2341: ST_TO_ADDR
// interface_hidden := false ;
2342: LD_ADDR_OWVAR 54
2346: PUSH
2347: LD_INT 0
2349: ST_TO_ADDR
// end ;
2350: LD_VAR 0 1
2354: RET
// every 0 0$0.5 marked 10 do var arabsc , arabsp , i ;
2355: GO 2357
2357: DISABLE
2358: LD_INT 0
2360: PPUSH
2361: PPUSH
2362: PPUSH
// begin ComEnterUnit ( ar1 , b1 ) ;
2363: LD_INT 26
2365: PPUSH
2366: LD_INT 1
2368: PPUSH
2369: CALL_OW 120
// ComEnterUnit ( ar2 , b2 ) ;
2373: LD_INT 16
2375: PPUSH
2376: LD_INT 2
2378: PPUSH
2379: CALL_OW 120
// arabsc := FilterAllUnits ( [ [ f_side , arabians ] , [ f_type , unit_vehicle ] ] ) ;
2383: LD_ADDR_VAR 0 1
2387: PUSH
2388: LD_INT 22
2390: PUSH
2391: LD_EXP 3
2395: PUSH
2396: EMPTY
2397: LIST
2398: LIST
2399: PUSH
2400: LD_INT 21
2402: PUSH
2403: LD_INT 2
2405: PUSH
2406: EMPTY
2407: LIST
2408: LIST
2409: PUSH
2410: EMPTY
2411: LIST
2412: LIST
2413: PPUSH
2414: CALL_OW 69
2418: ST_TO_ADDR
// arabsp := FilterAllUnits ( [ [ f_side , arabians ] , [ f_type , unit_human ] ] ) diff [ ar1 , ar2 ] ;
2419: LD_ADDR_VAR 0 2
2423: PUSH
2424: LD_INT 22
2426: PUSH
2427: LD_EXP 3
2431: PUSH
2432: EMPTY
2433: LIST
2434: LIST
2435: PUSH
2436: LD_INT 21
2438: PUSH
2439: LD_INT 1
2441: PUSH
2442: EMPTY
2443: LIST
2444: LIST
2445: PUSH
2446: EMPTY
2447: LIST
2448: LIST
2449: PPUSH
2450: CALL_OW 69
2454: PUSH
2455: LD_INT 26
2457: PUSH
2458: LD_INT 16
2460: PUSH
2461: EMPTY
2462: LIST
2463: LIST
2464: DIFF
2465: ST_TO_ADDR
// for i := 1 to arabsc do
2466: LD_ADDR_VAR 0 3
2470: PUSH
2471: DOUBLE
2472: LD_INT 1
2474: DEC
2475: ST_TO_ADDR
2476: LD_VAR 0 1
2480: PUSH
2481: FOR_TO
2482: IFFALSE 2512
// begin ComEnterUnit ( arabsp [ i ] , arabsc [ i ] ) ;
2484: LD_VAR 0 2
2488: PUSH
2489: LD_VAR 0 3
2493: ARRAY
2494: PPUSH
2495: LD_VAR 0 1
2499: PUSH
2500: LD_VAR 0 3
2504: ARRAY
2505: PPUSH
2506: CALL_OW 120
// end ;
2510: GO 2481
2512: POP
2513: POP
// while not UnitFilter ( arabsc , [ [ f_occupied ] ] ) do
2514: LD_VAR 0 1
2518: PPUSH
2519: LD_INT 59
2521: PUSH
2522: EMPTY
2523: LIST
2524: PUSH
2525: EMPTY
2526: LIST
2527: PPUSH
2528: CALL_OW 72
2532: NOT
2533: IFFALSE 2544
// wait ( 0 0$1 ) ;
2535: LD_INT 35
2537: PPUSH
2538: CALL_OW 67
2542: GO 2514
// wait ( 0 0$3 ) ;
2544: LD_INT 105
2546: PPUSH
2547: CALL_OW 67
// ComMoveToArea ( arabsc , ru_exit ) ;
2551: LD_VAR 0 1
2555: PPUSH
2556: LD_INT 2
2558: PPUSH
2559: CALL_OW 113
// wait ( 0 0$2 ) ;
2563: LD_INT 70
2565: PPUSH
2566: CALL_OW 67
// ComStop ( arabsc ) ;
2570: LD_VAR 0 1
2574: PPUSH
2575: CALL_OW 141
// wait ( 0 0$1 ) ;
2579: LD_INT 35
2581: PPUSH
2582: CALL_OW 67
// ComMoveToArea ( arabsc , ru_exit ) ;
2586: LD_VAR 0 1
2590: PPUSH
2591: LD_INT 2
2593: PPUSH
2594: CALL_OW 113
// end ;
2598: PPOPN 3
2600: END
// on DestinationUnreachable ( un ) do begin ComStop ( un ) ;
2601: LD_VAR 0 1
2605: PPUSH
2606: CALL_OW 141
// wait ( 0 0$0.5 ) ;
2610: LD_INT 18
2612: PPUSH
2613: CALL_OW 67
// AddComMoveToArea ( un , ru_exit ) ;
2617: LD_VAR 0 1
2621: PPUSH
2622: LD_INT 2
2624: PPUSH
2625: CALL_OW 173
// end ;
2629: PPOPN 1
2631: END
// on Contact ( side1 , side2 ) do begin if ( ( side1 = you ) and ( side2 = arabians ) ) or ( ( side2 = you ) and ( side1 = arabians ) ) then
2632: LD_VAR 0 1
2636: PUSH
2637: LD_EXP 1
2641: EQUAL
2642: PUSH
2643: LD_VAR 0 2
2647: PUSH
2648: LD_EXP 3
2652: EQUAL
2653: AND
2654: PUSH
2655: LD_VAR 0 2
2659: PUSH
2660: LD_EXP 1
2664: EQUAL
2665: PUSH
2666: LD_VAR 0 1
2670: PUSH
2671: LD_EXP 3
2675: EQUAL
2676: AND
2677: OR
2678: IFFALSE 2696
// begin music_nat := nation_arabian_music ;
2680: LD_ADDR_OWVAR 71
2684: PUSH
2685: LD_INT 4
2687: ST_TO_ADDR
// music_class := music_combat ;
2688: LD_ADDR_OWVAR 72
2692: PUSH
2693: LD_INT 1
2695: ST_TO_ADDR
// end ; end ;
2696: PPOPN 2
2698: END
