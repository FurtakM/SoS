// starting begin InitMission ;
   0: CALL 5 0 0
// end ;
   4: END
// export HeikeCaptured ; export coopWithGensher ; export HeikeStatus ; export Masha ; export dial_BuildDepotBlocker , dial_BuildArBarrackBlocker , dial_ArriveGensherUnitsBlocker ; export buildingsToBuild , techsToResearch , vehWeaponsToConstruct , availableWeapons , weaponsData , allBuildings ; export HeikeTargetX , HeikeTargetY , GensherTargetX , GensherTargetY ; export allowExitFromMap ; export acceptKurtOffert , askCommanders ; export KurtCanEscape , KurtStatus , KurtWaitingForFreeHeike , KurtWaitingForBuildBarrack ; export KurtAttack , americansAttack , forceStopKurtAttack ; export canSendHeike , canShootTrening ; export BurlakRespect ; export acceptLegionOffert , paidLegionOffert , legionOffertCountdown , legionOffertTime ; export firstMashaQuery , canChooseMashaVehicle ; export buildCompVehicle , buildArabBarrack , testedTeleport ; export lostUnits ; function InitMission ; begin
   5: LD_INT 0
   7: PPUSH
// ResetFog ;
   8: CALL_OW 335
// RandomizeAll ;
  12: CALL_OW 11
// InGameOn ;
  16: CALL_OW 8
// InitMapConfig ;
  20: CALL 358 0 0
// HeikeCaptured = LoadVariable ( 07_HeikeCaptured_1 , 0 ) ;
  24: LD_ADDR_EXP 1
  28: PUSH
  29: LD_STRING 07_HeikeCaptured_1
  31: PPUSH
  32: LD_INT 0
  34: PPUSH
  35: CALL_OW 30
  39: ST_TO_ADDR
// coopWithGensher = 0 ;
  40: LD_ADDR_EXP 2
  44: PUSH
  45: LD_INT 0
  47: ST_TO_ADDR
// HeikeStatus = 0 ;
  48: LD_ADDR_EXP 3
  52: PUSH
  53: LD_INT 0
  55: ST_TO_ADDR
// Masha = [ ] ;
  56: LD_ADDR_EXP 4
  60: PUSH
  61: EMPTY
  62: ST_TO_ADDR
// buildingsToBuild = [ ] ;
  63: LD_ADDR_EXP 8
  67: PUSH
  68: EMPTY
  69: ST_TO_ADDR
// techsToResearch = [ ] ;
  70: LD_ADDR_EXP 9
  74: PUSH
  75: EMPTY
  76: ST_TO_ADDR
// vehWeaponsToConstruct = [ ] ;
  77: LD_ADDR_EXP 10
  81: PUSH
  82: EMPTY
  83: ST_TO_ADDR
// availableWeapons = [ ] ;
  84: LD_ADDR_EXP 11
  88: PUSH
  89: EMPTY
  90: ST_TO_ADDR
// weaponsData = [ ] ;
  91: LD_ADDR_EXP 12
  95: PUSH
  96: EMPTY
  97: ST_TO_ADDR
// allBuildings = [ ] ;
  98: LD_ADDR_EXP 13
 102: PUSH
 103: EMPTY
 104: ST_TO_ADDR
// HeikeTargetX = 0 ;
 105: LD_ADDR_EXP 14
 109: PUSH
 110: LD_INT 0
 112: ST_TO_ADDR
// HeikeTargetY = 0 ;
 113: LD_ADDR_EXP 15
 117: PUSH
 118: LD_INT 0
 120: ST_TO_ADDR
// GensherTargetX = 0 ;
 121: LD_ADDR_EXP 16
 125: PUSH
 126: LD_INT 0
 128: ST_TO_ADDR
// GensherTargetY = 0 ;
 129: LD_ADDR_EXP 17
 133: PUSH
 134: LD_INT 0
 136: ST_TO_ADDR
// allowExitFromMap = 0 ;
 137: LD_ADDR_EXP 18
 141: PUSH
 142: LD_INT 0
 144: ST_TO_ADDR
// acceptKurtOffert = 0 ;
 145: LD_ADDR_EXP 19
 149: PUSH
 150: LD_INT 0
 152: ST_TO_ADDR
// askCommanders = 0 ;
 153: LD_ADDR_EXP 20
 157: PUSH
 158: LD_INT 0
 160: ST_TO_ADDR
// KurtCanEscape = true ;
 161: LD_ADDR_EXP 21
 165: PUSH
 166: LD_INT 1
 168: ST_TO_ADDR
// KurtAttack = false ;
 169: LD_ADDR_EXP 25
 173: PUSH
 174: LD_INT 0
 176: ST_TO_ADDR
// KurtWaitingForFreeHeike = false ;
 177: LD_ADDR_EXP 23
 181: PUSH
 182: LD_INT 0
 184: ST_TO_ADDR
// KurtWaitingForBuildBarrack = false ;
 185: LD_ADDR_EXP 24
 189: PUSH
 190: LD_INT 0
 192: ST_TO_ADDR
// KurtStatus = 0 ;
 193: LD_ADDR_EXP 22
 197: PUSH
 198: LD_INT 0
 200: ST_TO_ADDR
// americansAttack = false ;
 201: LD_ADDR_EXP 26
 205: PUSH
 206: LD_INT 0
 208: ST_TO_ADDR
// forceStopKurtAttack = false ;
 209: LD_ADDR_EXP 27
 213: PUSH
 214: LD_INT 0
 216: ST_TO_ADDR
// canSendHeike = false ;
 217: LD_ADDR_EXP 28
 221: PUSH
 222: LD_INT 0
 224: ST_TO_ADDR
// canShootTrening = false ;
 225: LD_ADDR_EXP 29
 229: PUSH
 230: LD_INT 0
 232: ST_TO_ADDR
// BurlakRespect = 0 ;
 233: LD_ADDR_EXP 30
 237: PUSH
 238: LD_INT 0
 240: ST_TO_ADDR
// acceptLegionOffert = false ;
 241: LD_ADDR_EXP 31
 245: PUSH
 246: LD_INT 0
 248: ST_TO_ADDR
// paidLegionOffert = false ;
 249: LD_ADDR_EXP 32
 253: PUSH
 254: LD_INT 0
 256: ST_TO_ADDR
// legionOffertCountdown = false ;
 257: LD_ADDR_EXP 33
 261: PUSH
 262: LD_INT 0
 264: ST_TO_ADDR
// legionOffertTime = 0 0$60 ;
 265: LD_ADDR_EXP 34
 269: PUSH
 270: LD_INT 2100
 272: ST_TO_ADDR
// canChooseMashaVehicle = false ;
 273: LD_ADDR_EXP 36
 277: PUSH
 278: LD_INT 0
 280: ST_TO_ADDR
// firstMashaQuery = true ;
 281: LD_ADDR_EXP 35
 285: PUSH
 286: LD_INT 1
 288: ST_TO_ADDR
// buildArabBarrack = false ;
 289: LD_ADDR_EXP 38
 293: PUSH
 294: LD_INT 0
 296: ST_TO_ADDR
// buildCompVehicle = false ;
 297: LD_ADDR_EXP 37
 301: PUSH
 302: LD_INT 0
 304: ST_TO_ADDR
// testedTeleport = false ;
 305: LD_ADDR_EXP 39
 309: PUSH
 310: LD_INT 0
 312: ST_TO_ADDR
// lostUnits = 0 ;
 313: LD_ADDR_EXP 40
 317: PUSH
 318: LD_INT 0
 320: ST_TO_ADDR
// PrepareRussians ;
 321: CALL 1292 0 0
// PrepareArabians ;
 325: CALL 3847 0 0
// PrepareAmericans ;
 329: CALL 2975 0 0
// Nef_PrepareNature ;
 333: CALL 4831 0 0
// SpawnTrees ;
 337: CALL 5452 0 0
// MissionIntro ;
 341: CALL 9085 0 0
// end ;
 345: LD_VAR 0 1
 349: RET
// export function CustomInitMacro ; begin
 350: LD_INT 0
 352: PPUSH
// end ; end_of_file
 353: LD_VAR 0 1
 357: RET
// export function InitMapConfig ; begin
 358: LD_INT 0
 360: PPUSH
// BaseMapConfig ;
 361: CALL 374 0 0
// MissionMapConfig ;
 365: CALL 464 0 0
// end ;
 369: LD_VAR 0 1
 373: RET
// export animalsAmount , animalsStats , animalsAgression , missionPrefix , previousMissionPrefix , debugMode ; function BaseMapConfig ; begin
 374: LD_INT 0
 376: PPUSH
// animalsAmount = [ 6 , 3 , 4 , 4 , 1 ] ;
 377: LD_ADDR_EXP 41
 381: PUSH
 382: LD_INT 6
 384: PUSH
 385: LD_INT 3
 387: PUSH
 388: LD_INT 4
 390: PUSH
 391: LD_INT 4
 393: PUSH
 394: LD_INT 1
 396: PUSH
 397: EMPTY
 398: LIST
 399: LIST
 400: LIST
 401: LIST
 402: LIST
 403: ST_TO_ADDR
// animalsStats = [ 2 , 2 , 2 , 2 ] ;
 404: LD_ADDR_EXP 42
 408: PUSH
 409: LD_INT 2
 411: PUSH
 412: LD_INT 2
 414: PUSH
 415: LD_INT 2
 417: PUSH
 418: LD_INT 2
 420: PUSH
 421: EMPTY
 422: LIST
 423: LIST
 424: LIST
 425: LIST
 426: ST_TO_ADDR
// animalsAgression = 3 ;
 427: LD_ADDR_EXP 43
 431: PUSH
 432: LD_INT 3
 434: ST_TO_ADDR
// debugMode = 0 ;
 435: LD_ADDR_EXP 46
 439: PUSH
 440: LD_INT 0
 442: ST_TO_ADDR
// missionPrefix = 08_ ;
 443: LD_ADDR_EXP 44
 447: PUSH
 448: LD_STRING 08_
 450: ST_TO_ADDR
// previousMissionPrefix = 07_ ;
 451: LD_ADDR_EXP 45
 455: PUSH
 456: LD_STRING 07_
 458: ST_TO_ADDR
// end ;
 459: LD_VAR 0 1
 463: RET
// export KurtAttackWaves , americansAttackWaves ; export firstAttackDelay ; export waveCooldown ; export legionReduceAmericansUnits ; export speedMedalTime ; export enemyAttackUnitsData ; export timeToFreeHeike , timeToBuildArBarrack ; export enemySkillLevel ; function MissionMapConfig ; begin
 464: LD_INT 0
 466: PPUSH
// KurtAttackWaves = [ 3 , 4 , 5 , 6 ] [ Difficulty ] ;
 467: LD_ADDR_EXP 47
 471: PUSH
 472: LD_INT 3
 474: PUSH
 475: LD_INT 4
 477: PUSH
 478: LD_INT 5
 480: PUSH
 481: LD_INT 6
 483: PUSH
 484: EMPTY
 485: LIST
 486: LIST
 487: LIST
 488: LIST
 489: PUSH
 490: LD_OWVAR 67
 494: ARRAY
 495: ST_TO_ADDR
// americansAttackWaves = [ 1 , 2 , 3 , 4 ] [ Difficulty ] ;
 496: LD_ADDR_EXP 48
 500: PUSH
 501: LD_INT 1
 503: PUSH
 504: LD_INT 2
 506: PUSH
 507: LD_INT 3
 509: PUSH
 510: LD_INT 4
 512: PUSH
 513: EMPTY
 514: LIST
 515: LIST
 516: LIST
 517: LIST
 518: PUSH
 519: LD_OWVAR 67
 523: ARRAY
 524: ST_TO_ADDR
// enemySkillLevel = [ 3 , 4 , 5 , 6 ] [ Difficulty ] ;
 525: LD_ADDR_EXP 56
 529: PUSH
 530: LD_INT 3
 532: PUSH
 533: LD_INT 4
 535: PUSH
 536: LD_INT 5
 538: PUSH
 539: LD_INT 6
 541: PUSH
 542: EMPTY
 543: LIST
 544: LIST
 545: LIST
 546: LIST
 547: PUSH
 548: LD_OWVAR 67
 552: ARRAY
 553: ST_TO_ADDR
// waveCooldown = 1 1$30 ;
 554: LD_ADDR_EXP 50
 558: PUSH
 559: LD_INT 3150
 561: ST_TO_ADDR
// firstAttackDelay = 1 1$00 ;
 562: LD_ADDR_EXP 49
 566: PUSH
 567: LD_INT 2100
 569: ST_TO_ADDR
// timeToFreeHeike = 2 2$00 ;
 570: LD_ADDR_EXP 54
 574: PUSH
 575: LD_INT 4200
 577: ST_TO_ADDR
// timeToBuildArBarrack = 5 5$00 ;
 578: LD_ADDR_EXP 55
 582: PUSH
 583: LD_INT 10500
 585: ST_TO_ADDR
// legionReduceAmericansUnits = [ 5 , 5 , 6 , 6 ] [ Difficulty ] ;
 586: LD_ADDR_EXP 51
 590: PUSH
 591: LD_INT 5
 593: PUSH
 594: LD_INT 5
 596: PUSH
 597: LD_INT 6
 599: PUSH
 600: LD_INT 6
 602: PUSH
 603: EMPTY
 604: LIST
 605: LIST
 606: LIST
 607: LIST
 608: PUSH
 609: LD_OWVAR 67
 613: ARRAY
 614: ST_TO_ADDR
// speedMedalTime = [ 80 80$0 , 70 70$0 , 60 60$0 , 50 50$0 ] [ Difficulty ] ;
 615: LD_ADDR_EXP 52
 619: PUSH
 620: LD_INT 168000
 622: PUSH
 623: LD_INT 147000
 625: PUSH
 626: LD_INT 126000
 628: PUSH
 629: LD_INT 105000
 631: PUSH
 632: EMPTY
 633: LIST
 634: LIST
 635: LIST
 636: LIST
 637: PUSH
 638: LD_OWVAR 67
 642: ARRAY
 643: ST_TO_ADDR
// enemyAttackUnitsData = [ [ 1 , [ 4 , 5 , 6 , 6 ] [ Difficulty ] , [ 7 , 8 , 9 , 9 ] [ Difficulty ] , [ 1 , 2 , 2 , 3 ] [ Difficulty ] , [ 3 , 3 , 4 , 4 ] [ Difficulty ] , [ 6 , 7 , 8 , 8 ] [ Difficulty ] , [ 10 , 12 , 15 , 15 ] [ Difficulty ] ] , [ 8 , [ 2 , 3 , 4 , 4 ] [ Difficulty ] , [ 6 , 6 , 7 , 7 ] [ Difficulty ] , [ 0 , 1 , 1 , 2 ] [ Difficulty ] , [ 1 , 2 , 3 , 3 ] [ Difficulty ] , [ 1 , 2 , 2 , 2 ] [ Difficulty ] , [ 2 , 3 , 5 , 5 ] [ Difficulty ] ] ] ;
 644: LD_ADDR_EXP 53
 648: PUSH
 649: LD_INT 1
 651: PUSH
 652: LD_INT 4
 654: PUSH
 655: LD_INT 5
 657: PUSH
 658: LD_INT 6
 660: PUSH
 661: LD_INT 6
 663: PUSH
 664: EMPTY
 665: LIST
 666: LIST
 667: LIST
 668: LIST
 669: PUSH
 670: LD_OWVAR 67
 674: ARRAY
 675: PUSH
 676: LD_INT 7
 678: PUSH
 679: LD_INT 8
 681: PUSH
 682: LD_INT 9
 684: PUSH
 685: LD_INT 9
 687: PUSH
 688: EMPTY
 689: LIST
 690: LIST
 691: LIST
 692: LIST
 693: PUSH
 694: LD_OWVAR 67
 698: ARRAY
 699: PUSH
 700: LD_INT 1
 702: PUSH
 703: LD_INT 2
 705: PUSH
 706: LD_INT 2
 708: PUSH
 709: LD_INT 3
 711: PUSH
 712: EMPTY
 713: LIST
 714: LIST
 715: LIST
 716: LIST
 717: PUSH
 718: LD_OWVAR 67
 722: ARRAY
 723: PUSH
 724: LD_INT 3
 726: PUSH
 727: LD_INT 3
 729: PUSH
 730: LD_INT 4
 732: PUSH
 733: LD_INT 4
 735: PUSH
 736: EMPTY
 737: LIST
 738: LIST
 739: LIST
 740: LIST
 741: PUSH
 742: LD_OWVAR 67
 746: ARRAY
 747: PUSH
 748: LD_INT 6
 750: PUSH
 751: LD_INT 7
 753: PUSH
 754: LD_INT 8
 756: PUSH
 757: LD_INT 8
 759: PUSH
 760: EMPTY
 761: LIST
 762: LIST
 763: LIST
 764: LIST
 765: PUSH
 766: LD_OWVAR 67
 770: ARRAY
 771: PUSH
 772: LD_INT 10
 774: PUSH
 775: LD_INT 12
 777: PUSH
 778: LD_INT 15
 780: PUSH
 781: LD_INT 15
 783: PUSH
 784: EMPTY
 785: LIST
 786: LIST
 787: LIST
 788: LIST
 789: PUSH
 790: LD_OWVAR 67
 794: ARRAY
 795: PUSH
 796: EMPTY
 797: LIST
 798: LIST
 799: LIST
 800: LIST
 801: LIST
 802: LIST
 803: LIST
 804: PUSH
 805: LD_INT 8
 807: PUSH
 808: LD_INT 2
 810: PUSH
 811: LD_INT 3
 813: PUSH
 814: LD_INT 4
 816: PUSH
 817: LD_INT 4
 819: PUSH
 820: EMPTY
 821: LIST
 822: LIST
 823: LIST
 824: LIST
 825: PUSH
 826: LD_OWVAR 67
 830: ARRAY
 831: PUSH
 832: LD_INT 6
 834: PUSH
 835: LD_INT 6
 837: PUSH
 838: LD_INT 7
 840: PUSH
 841: LD_INT 7
 843: PUSH
 844: EMPTY
 845: LIST
 846: LIST
 847: LIST
 848: LIST
 849: PUSH
 850: LD_OWVAR 67
 854: ARRAY
 855: PUSH
 856: LD_INT 0
 858: PUSH
 859: LD_INT 1
 861: PUSH
 862: LD_INT 1
 864: PUSH
 865: LD_INT 2
 867: PUSH
 868: EMPTY
 869: LIST
 870: LIST
 871: LIST
 872: LIST
 873: PUSH
 874: LD_OWVAR 67
 878: ARRAY
 879: PUSH
 880: LD_INT 1
 882: PUSH
 883: LD_INT 2
 885: PUSH
 886: LD_INT 3
 888: PUSH
 889: LD_INT 3
 891: PUSH
 892: EMPTY
 893: LIST
 894: LIST
 895: LIST
 896: LIST
 897: PUSH
 898: LD_OWVAR 67
 902: ARRAY
 903: PUSH
 904: LD_INT 1
 906: PUSH
 907: LD_INT 2
 909: PUSH
 910: LD_INT 2
 912: PUSH
 913: LD_INT 2
 915: PUSH
 916: EMPTY
 917: LIST
 918: LIST
 919: LIST
 920: LIST
 921: PUSH
 922: LD_OWVAR 67
 926: ARRAY
 927: PUSH
 928: LD_INT 2
 930: PUSH
 931: LD_INT 3
 933: PUSH
 934: LD_INT 5
 936: PUSH
 937: LD_INT 5
 939: PUSH
 940: EMPTY
 941: LIST
 942: LIST
 943: LIST
 944: LIST
 945: PUSH
 946: LD_OWVAR 67
 950: ARRAY
 951: PUSH
 952: EMPTY
 953: LIST
 954: LIST
 955: LIST
 956: LIST
 957: LIST
 958: LIST
 959: LIST
 960: PUSH
 961: EMPTY
 962: LIST
 963: LIST
 964: ST_TO_ADDR
// end ;
 965: LD_VAR 0 1
 969: RET
// every 0 0$1 trigger debugMode do var i ;
 970: LD_EXP 46
 974: IFFALSE 1289
 976: GO 978
 978: DISABLE
 979: LD_INT 0
 981: PPUSH
// begin enable ;
 982: ENABLE
// FogOff ( your_side ) ;
 983: LD_OWVAR 2
 987: PPUSH
 988: CALL_OW 344
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) do
 992: LD_ADDR_VAR 0 1
 996: PUSH
 997: LD_INT 22
 999: PUSH
1000: LD_OWVAR 2
1004: PUSH
1005: EMPTY
1006: LIST
1007: LIST
1008: PUSH
1009: LD_INT 2
1011: PUSH
1012: LD_INT 21
1014: PUSH
1015: LD_INT 1
1017: PUSH
1018: EMPTY
1019: LIST
1020: LIST
1021: PUSH
1022: LD_INT 21
1024: PUSH
1025: LD_INT 2
1027: PUSH
1028: EMPTY
1029: LIST
1030: LIST
1031: PUSH
1032: EMPTY
1033: LIST
1034: LIST
1035: LIST
1036: PUSH
1037: EMPTY
1038: LIST
1039: LIST
1040: PPUSH
1041: CALL_OW 69
1045: PUSH
1046: FOR_IN
1047: IFFALSE 1063
// SetLives ( i , 1000 ) ;
1049: LD_VAR 0 1
1053: PPUSH
1054: LD_INT 1000
1056: PPUSH
1057: CALL_OW 234
1061: GO 1046
1063: POP
1064: POP
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
1065: LD_ADDR_VAR 0 1
1069: PUSH
1070: LD_INT 22
1072: PUSH
1073: LD_OWVAR 2
1077: PUSH
1078: EMPTY
1079: LIST
1080: LIST
1081: PUSH
1082: LD_INT 21
1084: PUSH
1085: LD_INT 1
1087: PUSH
1088: EMPTY
1089: LIST
1090: LIST
1091: PUSH
1092: EMPTY
1093: LIST
1094: LIST
1095: PPUSH
1096: CALL_OW 69
1100: PUSH
1101: FOR_IN
1102: IFFALSE 1166
// begin SetSkill ( i , skill_combat , 10 ) ;
1104: LD_VAR 0 1
1108: PPUSH
1109: LD_INT 1
1111: PPUSH
1112: LD_INT 10
1114: PPUSH
1115: CALL_OW 237
// SetSkill ( i , skill_engineering , 10 ) ;
1119: LD_VAR 0 1
1123: PPUSH
1124: LD_INT 2
1126: PPUSH
1127: LD_INT 10
1129: PPUSH
1130: CALL_OW 237
// SetSkill ( i , skill_mechanical , 10 ) ;
1134: LD_VAR 0 1
1138: PPUSH
1139: LD_INT 3
1141: PPUSH
1142: LD_INT 10
1144: PPUSH
1145: CALL_OW 237
// SetSkill ( i , skill_scientistic , 10 ) ;
1149: LD_VAR 0 1
1153: PPUSH
1154: LD_INT 4
1156: PPUSH
1157: LD_INT 10
1159: PPUSH
1160: CALL_OW 237
// end ;
1164: GO 1101
1166: POP
1167: POP
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) do
1168: LD_ADDR_VAR 0 1
1172: PUSH
1173: LD_INT 22
1175: PUSH
1176: LD_OWVAR 2
1180: PUSH
1181: EMPTY
1182: LIST
1183: LIST
1184: PUSH
1185: LD_INT 2
1187: PUSH
1188: LD_INT 30
1190: PUSH
1191: LD_INT 0
1193: PUSH
1194: EMPTY
1195: LIST
1196: LIST
1197: PUSH
1198: LD_INT 30
1200: PUSH
1201: LD_INT 1
1203: PUSH
1204: EMPTY
1205: LIST
1206: LIST
1207: PUSH
1208: EMPTY
1209: LIST
1210: LIST
1211: LIST
1212: PUSH
1213: EMPTY
1214: LIST
1215: LIST
1216: PPUSH
1217: CALL_OW 69
1221: PUSH
1222: FOR_IN
1223: IFFALSE 1287
// begin SetResourceType ( GetBase ( i ) , mat_cans , 9999 ) ;
1225: LD_VAR 0 1
1229: PPUSH
1230: CALL_OW 274
1234: PPUSH
1235: LD_INT 1
1237: PPUSH
1238: LD_INT 9999
1240: PPUSH
1241: CALL_OW 277
// SetResourceType ( GetBase ( i ) , mat_oil , 9999 ) ;
1245: LD_VAR 0 1
1249: PPUSH
1250: CALL_OW 274
1254: PPUSH
1255: LD_INT 2
1257: PPUSH
1258: LD_INT 9999
1260: PPUSH
1261: CALL_OW 277
// SetResourceType ( GetBase ( i ) , mat_siberit , 9999 ) ;
1265: LD_VAR 0 1
1269: PPUSH
1270: CALL_OW 274
1274: PPUSH
1275: LD_INT 3
1277: PPUSH
1278: LD_INT 9999
1280: PPUSH
1281: CALL_OW 277
// end ;
1285: GO 1222
1287: POP
1288: POP
// end ; end_of_file
1289: PPOPN 1
1291: END
// export Burlak , Karamazov , Petrovova , Gleb , Petrosyan , Titov , Dolgov , Lipshchin , Kirilenkova , Belkov , Belkov2 , Xavier ; export Gnyevko , Kovalyuk , Scholtze , Kuzmov ; export Kozlov , Oblukov , Kapitsova ; export Popov ; export russianEscort ; export function PrepareRussians ; begin
1292: LD_INT 0
1294: PPUSH
// russianEscort = [ ] ;
1295: LD_ADDR_EXP 77
1299: PUSH
1300: EMPTY
1301: ST_TO_ADDR
// Masha = [ ] ;
1302: LD_ADDR_EXP 4
1306: PUSH
1307: EMPTY
1308: ST_TO_ADDR
// PrepareHeroes ;
1309: CALL 1322 0 0
// InitRussianRequiments ;
1313: CALL 2717 0 0
// end ;
1317: LD_VAR 0 1
1321: RET
// function PrepareHeroes ; var i , un , other_survivors , yourUnits , emptyVeh ; begin
1322: LD_INT 0
1324: PPUSH
1325: PPUSH
1326: PPUSH
1327: PPUSH
1328: PPUSH
1329: PPUSH
// uc_side = 3 ;
1330: LD_ADDR_OWVAR 20
1334: PUSH
1335: LD_INT 3
1337: ST_TO_ADDR
// uc_nation = 3 ;
1338: LD_ADDR_OWVAR 21
1342: PUSH
1343: LD_INT 3
1345: ST_TO_ADDR
// Burlak := PrepareUnitExt ( Burlak , true , class_mechanic ) ;
1346: LD_ADDR_EXP 57
1350: PUSH
1351: LD_STRING Burlak
1353: PPUSH
1354: LD_INT 1
1356: PPUSH
1357: LD_INT 3
1359: PPUSH
1360: CALL 5930 0 3
1364: ST_TO_ADDR
// Titov := PrepareUnitExt ( Titov , true , class_soldier ) ;
1365: LD_ADDR_EXP 62
1369: PUSH
1370: LD_STRING Titov
1372: PPUSH
1373: LD_INT 1
1375: PPUSH
1376: LD_INT 1
1378: PPUSH
1379: CALL 5930 0 3
1383: ST_TO_ADDR
// Dolgov := PrepareUnitExt ( Dolgov , true , class_scientistic ) ;
1384: LD_ADDR_EXP 63
1388: PUSH
1389: LD_STRING Dolgov
1391: PPUSH
1392: LD_INT 1
1394: PPUSH
1395: LD_INT 4
1397: PPUSH
1398: CALL 5930 0 3
1402: ST_TO_ADDR
// Lipshchin := PrepareUnitExt ( Lipshchin , true , class_soldier ) ;
1403: LD_ADDR_EXP 64
1407: PUSH
1408: LD_STRING Lipshchin
1410: PPUSH
1411: LD_INT 1
1413: PPUSH
1414: LD_INT 1
1416: PPUSH
1417: CALL 5930 0 3
1421: ST_TO_ADDR
// Karamazov := PrepareUnitExt ( Karamazov , true , class_engineer ) ;
1422: LD_ADDR_EXP 58
1426: PUSH
1427: LD_STRING Karamazov
1429: PPUSH
1430: LD_INT 1
1432: PPUSH
1433: LD_INT 2
1435: PPUSH
1436: CALL 5930 0 3
1440: ST_TO_ADDR
// Petrovova := PrepareUnitExt ( Petrovova , true , class_soldier ) ;
1441: LD_ADDR_EXP 59
1445: PUSH
1446: LD_STRING Petrovova
1448: PPUSH
1449: LD_INT 1
1451: PPUSH
1452: LD_INT 1
1454: PPUSH
1455: CALL 5930 0 3
1459: ST_TO_ADDR
// Gleb := PrepareUnitExt ( Gleb , true , class_soldier ) ;
1460: LD_ADDR_EXP 60
1464: PUSH
1465: LD_STRING Gleb
1467: PPUSH
1468: LD_INT 1
1470: PPUSH
1471: LD_INT 1
1473: PPUSH
1474: CALL 5930 0 3
1478: ST_TO_ADDR
// Petrosyan := PrepareUnitExt ( Petrosyan , true , class_scientistic ) ;
1479: LD_ADDR_EXP 61
1483: PUSH
1484: LD_STRING Petrosyan
1486: PPUSH
1487: LD_INT 1
1489: PPUSH
1490: LD_INT 4
1492: PPUSH
1493: CALL 5930 0 3
1497: ST_TO_ADDR
// Kirilenkova := PrepareUnitExt ( Kirilenkova , true , class_scientistic ) ;
1498: LD_ADDR_EXP 65
1502: PUSH
1503: LD_STRING Kirilenkova
1505: PPUSH
1506: LD_INT 1
1508: PPUSH
1509: LD_INT 4
1511: PPUSH
1512: CALL 5930 0 3
1516: ST_TO_ADDR
// Belkov := PrepareUnitExt ( Belkov , true , class_soldier ) ;
1517: LD_ADDR_EXP 66
1521: PUSH
1522: LD_STRING Belkov
1524: PPUSH
1525: LD_INT 1
1527: PPUSH
1528: LD_INT 1
1530: PPUSH
1531: CALL 5930 0 3
1535: ST_TO_ADDR
// Belkov2 := PrepareUnitExt ( Belkov2 , true , class_soldier ) ;
1536: LD_ADDR_EXP 67
1540: PUSH
1541: LD_STRING Belkov2
1543: PPUSH
1544: LD_INT 1
1546: PPUSH
1547: LD_INT 1
1549: PPUSH
1550: CALL 5930 0 3
1554: ST_TO_ADDR
// Xavier := PrepareUnitExt ( Xavier , true , class_soldier ) ;
1555: LD_ADDR_EXP 68
1559: PUSH
1560: LD_STRING Xavier
1562: PPUSH
1563: LD_INT 1
1565: PPUSH
1566: LD_INT 1
1568: PPUSH
1569: CALL 5930 0 3
1573: ST_TO_ADDR
// Gnyevko := CreateCharacter ( 04_Gnyevko ) ;
1574: LD_ADDR_EXP 69
1578: PUSH
1579: LD_STRING 04_Gnyevko
1581: PPUSH
1582: CALL_OW 34
1586: ST_TO_ADDR
// SetClass ( Gnyevko , class_soldier ) ;
1587: LD_EXP 69
1591: PPUSH
1592: LD_INT 1
1594: PPUSH
1595: CALL_OW 336
// Kovalyuk := CreateCharacter ( 04_Kovalyuk ) ;
1599: LD_ADDR_EXP 70
1603: PUSH
1604: LD_STRING 04_Kovalyuk
1606: PPUSH
1607: CALL_OW 34
1611: ST_TO_ADDR
// SetClass ( Kovalyuk , class_mechanic ) ;
1612: LD_EXP 70
1616: PPUSH
1617: LD_INT 3
1619: PPUSH
1620: CALL_OW 336
// Scholtze := CreateCharacter ( 04_Scholtze ) ;
1624: LD_ADDR_EXP 71
1628: PUSH
1629: LD_STRING 04_Scholtze
1631: PPUSH
1632: CALL_OW 34
1636: ST_TO_ADDR
// SetClass ( Scholtze , class_scientistic ) ;
1637: LD_EXP 71
1641: PPUSH
1642: LD_INT 4
1644: PPUSH
1645: CALL_OW 336
// Kuzmov := CreateCharacter ( 04_Kuzmov ) ;
1649: LD_ADDR_EXP 72
1653: PUSH
1654: LD_STRING 04_Kuzmov
1656: PPUSH
1657: CALL_OW 34
1661: ST_TO_ADDR
// SetClass ( Kuzmov , class_soldier ) ;
1662: LD_EXP 72
1666: PPUSH
1667: LD_INT 1
1669: PPUSH
1670: CALL_OW 336
// Kozlov := PrepareUnitExt ( Kozlov , false , class_engineer ) ;
1674: LD_ADDR_EXP 73
1678: PUSH
1679: LD_STRING Kozlov
1681: PPUSH
1682: LD_INT 0
1684: PPUSH
1685: LD_INT 2
1687: PPUSH
1688: CALL 5930 0 3
1692: ST_TO_ADDR
// Oblukov := PrepareUnitExt ( Oblukov , false , class_soldier ) ;
1693: LD_ADDR_EXP 74
1697: PUSH
1698: LD_STRING Oblukov
1700: PPUSH
1701: LD_INT 0
1703: PPUSH
1704: LD_INT 1
1706: PPUSH
1707: CALL 5930 0 3
1711: ST_TO_ADDR
// Kapitsova := PrepareUnitExt ( Kapitsova , false , class_scientistic ) ;
1712: LD_ADDR_EXP 75
1716: PUSH
1717: LD_STRING Kapitsova
1719: PPUSH
1720: LD_INT 0
1722: PPUSH
1723: LD_INT 4
1725: PPUSH
1726: CALL 5930 0 3
1730: ST_TO_ADDR
// Popov := PrepareUnitExt ( Popov , false , 0 ) ;
1731: LD_ADDR_EXP 76
1735: PUSH
1736: LD_STRING Popov
1738: PPUSH
1739: LD_INT 0
1741: PPUSH
1742: LD_INT 0
1744: PPUSH
1745: CALL 5930 0 3
1749: ST_TO_ADDR
// PlaceUnitsArea ( [ Burlak , Karamazov , Petrovova , Gleb , Petrosyan , Titov , Dolgov , Lipshchin , Kirilenkova , Belkov , Belkov2 , Xavier , Gnyevko , Kovalyuk , Scholtze , Kuzmov , Kozlov , Oblukov , Kapitsova ] , RussianSpawnArea , false ) ;
1750: LD_EXP 57
1754: PUSH
1755: LD_EXP 58
1759: PUSH
1760: LD_EXP 59
1764: PUSH
1765: LD_EXP 60
1769: PUSH
1770: LD_EXP 61
1774: PUSH
1775: LD_EXP 62
1779: PUSH
1780: LD_EXP 63
1784: PUSH
1785: LD_EXP 64
1789: PUSH
1790: LD_EXP 65
1794: PUSH
1795: LD_EXP 66
1799: PUSH
1800: LD_EXP 67
1804: PUSH
1805: LD_EXP 68
1809: PUSH
1810: LD_EXP 69
1814: PUSH
1815: LD_EXP 70
1819: PUSH
1820: LD_EXP 71
1824: PUSH
1825: LD_EXP 72
1829: PUSH
1830: LD_EXP 73
1834: PUSH
1835: LD_EXP 74
1839: PUSH
1840: LD_EXP 75
1844: PUSH
1845: EMPTY
1846: LIST
1847: LIST
1848: LIST
1849: LIST
1850: LIST
1851: LIST
1852: LIST
1853: LIST
1854: LIST
1855: LIST
1856: LIST
1857: LIST
1858: LIST
1859: LIST
1860: LIST
1861: LIST
1862: LIST
1863: LIST
1864: LIST
1865: PPUSH
1866: LD_INT 2
1868: PPUSH
1869: LD_INT 0
1871: PPUSH
1872: CALL 6204 0 3
// PrepareVehicles ;
1876: CALL 2417 0 0
// other_survivors = CreateCharacterSet ( 07_other_survivors ) ;
1880: LD_ADDR_VAR 0 4
1884: PUSH
1885: LD_STRING 07_other_survivors
1887: PPUSH
1888: CALL_OW 31
1892: ST_TO_ADDR
// other_survivors = other_survivors ^ CreateCharacterSet ( 04_other_survivors ) ;
1893: LD_ADDR_VAR 0 4
1897: PUSH
1898: LD_VAR 0 4
1902: PUSH
1903: LD_STRING 04_other_survivors
1905: PPUSH
1906: CALL_OW 31
1910: ADD
1911: ST_TO_ADDR
// other_survivors = other_survivors ^ CreateCharacterSet ( 04_other_survivors_with_popov ) ;
1912: LD_ADDR_VAR 0 4
1916: PUSH
1917: LD_VAR 0 4
1921: PUSH
1922: LD_STRING 04_other_survivors_with_popov
1924: PPUSH
1925: CALL_OW 31
1929: ADD
1930: ST_TO_ADDR
// for un in other_survivors do
1931: LD_ADDR_VAR 0 3
1935: PUSH
1936: LD_VAR 0 4
1940: PUSH
1941: FOR_IN
1942: IFFALSE 2028
// begin emptyVeh = FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] , [ f_empty ] ] ) ;
1944: LD_ADDR_VAR 0 6
1948: PUSH
1949: LD_INT 22
1951: PUSH
1952: LD_INT 3
1954: PUSH
1955: EMPTY
1956: LIST
1957: LIST
1958: PUSH
1959: LD_INT 21
1961: PUSH
1962: LD_INT 2
1964: PUSH
1965: EMPTY
1966: LIST
1967: LIST
1968: PUSH
1969: LD_INT 58
1971: PUSH
1972: EMPTY
1973: LIST
1974: PUSH
1975: EMPTY
1976: LIST
1977: LIST
1978: LIST
1979: PPUSH
1980: CALL_OW 69
1984: ST_TO_ADDR
// if emptyVeh then
1985: LD_VAR 0 6
1989: IFFALSE 2011
// PlaceHumanInUnit ( un , emptyVeh [ 1 ] ) else
1991: LD_VAR 0 3
1995: PPUSH
1996: LD_VAR 0 6
2000: PUSH
2001: LD_INT 1
2003: ARRAY
2004: PPUSH
2005: CALL_OW 52
2009: GO 2026
// PlaceUnitArea ( un , RussianSpawnArea , false ) ;
2011: LD_VAR 0 3
2015: PPUSH
2016: LD_INT 2
2018: PPUSH
2019: LD_INT 0
2021: PPUSH
2022: CALL_OW 49
// end ;
2026: GO 1941
2028: POP
2029: POP
// yourUnits = FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_nation , nation_russian ] ] ) ;
2030: LD_ADDR_VAR 0 5
2034: PUSH
2035: LD_INT 22
2037: PUSH
2038: LD_INT 3
2040: PUSH
2041: EMPTY
2042: LIST
2043: LIST
2044: PUSH
2045: LD_INT 21
2047: PUSH
2048: LD_INT 1
2050: PUSH
2051: EMPTY
2052: LIST
2053: LIST
2054: PUSH
2055: LD_INT 23
2057: PUSH
2058: LD_INT 3
2060: PUSH
2061: EMPTY
2062: LIST
2063: LIST
2064: PUSH
2065: EMPTY
2066: LIST
2067: LIST
2068: LIST
2069: PPUSH
2070: CALL_OW 69
2074: ST_TO_ADDR
// if yourUnits < 15 then
2075: LD_VAR 0 5
2079: PUSH
2080: LD_INT 15
2082: LESS
2083: IFFALSE 2232
// for i := 1 to 15 - yourUnits do
2085: LD_ADDR_VAR 0 2
2089: PUSH
2090: DOUBLE
2091: LD_INT 1
2093: DEC
2094: ST_TO_ADDR
2095: LD_INT 15
2097: PUSH
2098: LD_VAR 0 5
2102: MINUS
2103: PUSH
2104: FOR_TO
2105: IFFALSE 2230
// begin PrepareHuman ( false , rand ( 1 , 4 ) , rand ( 2 , 4 ) ) ;
2107: LD_INT 0
2109: PPUSH
2110: LD_INT 1
2112: PPUSH
2113: LD_INT 4
2115: PPUSH
2116: CALL_OW 12
2120: PPUSH
2121: LD_INT 2
2123: PPUSH
2124: LD_INT 4
2126: PPUSH
2127: CALL_OW 12
2131: PPUSH
2132: CALL_OW 380
// un = CreateHuman ;
2136: LD_ADDR_VAR 0 3
2140: PUSH
2141: CALL_OW 44
2145: ST_TO_ADDR
// emptyVeh = FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] , [ f_empty ] ] ) ;
2146: LD_ADDR_VAR 0 6
2150: PUSH
2151: LD_INT 22
2153: PUSH
2154: LD_INT 3
2156: PUSH
2157: EMPTY
2158: LIST
2159: LIST
2160: PUSH
2161: LD_INT 21
2163: PUSH
2164: LD_INT 2
2166: PUSH
2167: EMPTY
2168: LIST
2169: LIST
2170: PUSH
2171: LD_INT 58
2173: PUSH
2174: EMPTY
2175: LIST
2176: PUSH
2177: EMPTY
2178: LIST
2179: LIST
2180: LIST
2181: PPUSH
2182: CALL_OW 69
2186: ST_TO_ADDR
// if emptyVeh then
2187: LD_VAR 0 6
2191: IFFALSE 2213
// PlaceHumanInUnit ( un , emptyVeh [ 1 ] ) else
2193: LD_VAR 0 3
2197: PPUSH
2198: LD_VAR 0 6
2202: PUSH
2203: LD_INT 1
2205: ARRAY
2206: PPUSH
2207: CALL_OW 52
2211: GO 2228
// PlaceUnitArea ( un , RussianSpawnArea , false ) ;
2213: LD_VAR 0 3
2217: PPUSH
2218: LD_INT 2
2220: PPUSH
2221: LD_INT 0
2223: PPUSH
2224: CALL_OW 49
// end ;
2228: GO 2104
2230: POP
2231: POP
// yourUnits = FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_nation , nation_russian ] ] ) ;
2232: LD_ADDR_VAR 0 5
2236: PUSH
2237: LD_INT 22
2239: PUSH
2240: LD_INT 3
2242: PUSH
2243: EMPTY
2244: LIST
2245: LIST
2246: PUSH
2247: LD_INT 21
2249: PUSH
2250: LD_INT 1
2252: PUSH
2253: EMPTY
2254: LIST
2255: LIST
2256: PUSH
2257: LD_INT 23
2259: PUSH
2260: LD_INT 3
2262: PUSH
2263: EMPTY
2264: LIST
2265: LIST
2266: PUSH
2267: EMPTY
2268: LIST
2269: LIST
2270: LIST
2271: PPUSH
2272: CALL_OW 69
2276: ST_TO_ADDR
// if not UnitFilter ( yourUnits , [ f_class , class_engineer ] ) then
2277: LD_VAR 0 5
2281: PPUSH
2282: LD_INT 25
2284: PUSH
2285: LD_INT 2
2287: PUSH
2288: EMPTY
2289: LIST
2290: LIST
2291: PPUSH
2292: CALL_OW 72
2296: NOT
2297: IFFALSE 2315
// SetClass ( yourUnits [ 1 ] , 2 ) ;
2299: LD_VAR 0 5
2303: PUSH
2304: LD_INT 1
2306: ARRAY
2307: PPUSH
2308: LD_INT 2
2310: PPUSH
2311: CALL_OW 336
// end ;
2315: LD_VAR 0 1
2319: RET
// export function PrepareRussianEscort ; var i , unit ; begin
2320: LD_INT 0
2322: PPUSH
2323: PPUSH
2324: PPUSH
// uc_side = 6 ;
2325: LD_ADDR_OWVAR 20
2329: PUSH
2330: LD_INT 6
2332: ST_TO_ADDR
// uc_nation = 3 ;
2333: LD_ADDR_OWVAR 21
2337: PUSH
2338: LD_INT 3
2340: ST_TO_ADDR
// for i := 1 to 2 do
2341: LD_ADDR_VAR 0 2
2345: PUSH
2346: DOUBLE
2347: LD_INT 1
2349: DEC
2350: ST_TO_ADDR
2351: LD_INT 2
2353: PUSH
2354: FOR_TO
2355: IFFALSE 2410
// begin PrepareSoldier ( false , 4 ) ;
2357: LD_INT 0
2359: PPUSH
2360: LD_INT 4
2362: PPUSH
2363: CALL_OW 381
// unit = CreateHuman ;
2367: LD_ADDR_VAR 0 3
2371: PUSH
2372: CALL_OW 44
2376: ST_TO_ADDR
// russianEscort = russianEscort ^ unit ;
2377: LD_ADDR_EXP 77
2381: PUSH
2382: LD_EXP 77
2386: PUSH
2387: LD_VAR 0 3
2391: ADD
2392: ST_TO_ADDR
// PlaceUnitArea ( unit , RussianSpawn2Area , false ) ;
2393: LD_VAR 0 3
2397: PPUSH
2398: LD_INT 7
2400: PPUSH
2401: LD_INT 0
2403: PPUSH
2404: CALL_OW 49
// end ;
2408: GO 2354
2410: POP
2411: POP
// end ;
2412: LD_VAR 0 1
2416: RET
// function PrepareVehicles ; var i , veh ; begin
2417: LD_INT 0
2419: PPUSH
2420: PPUSH
2421: PPUSH
// uc_side = 3 ;
2422: LD_ADDR_OWVAR 20
2426: PUSH
2427: LD_INT 3
2429: ST_TO_ADDR
// uc_nation = 3 ;
2430: LD_ADDR_OWVAR 21
2434: PUSH
2435: LD_INT 3
2437: ST_TO_ADDR
// for i := 1 to 5 do
2438: LD_ADDR_VAR 0 2
2442: PUSH
2443: DOUBLE
2444: LD_INT 1
2446: DEC
2447: ST_TO_ADDR
2448: LD_INT 5
2450: PUSH
2451: FOR_TO
2452: IFFALSE 2562
// begin PrepareVehicle ( ru_medium_wheeled , engine_combustion , control_manual , ru_cargo_bay , rand ( 60 , 80 ) ) ;
2454: LD_INT 21
2456: PPUSH
2457: LD_INT 1
2459: PPUSH
2460: LD_INT 1
2462: PPUSH
2463: LD_INT 51
2465: PPUSH
2466: LD_INT 60
2468: PPUSH
2469: LD_INT 80
2471: PPUSH
2472: CALL_OW 12
2476: PPUSH
2477: CALL 24088 0 5
// veh = CreateVehicle ;
2481: LD_ADDR_VAR 0 3
2485: PUSH
2486: CALL_OW 45
2490: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
2491: LD_VAR 0 3
2495: PPUSH
2496: LD_INT 4
2498: PPUSH
2499: CALL_OW 233
// PlaceUnitArea ( veh , RussianSpawnArea , false ) ;
2503: LD_VAR 0 3
2507: PPUSH
2508: LD_INT 2
2510: PPUSH
2511: LD_INT 0
2513: PPUSH
2514: CALL_OW 49
// if ( i <> 5 ) then
2518: LD_VAR 0 2
2522: PUSH
2523: LD_INT 5
2525: NONEQUAL
2526: IFFALSE 2545
// AddCargo ( veh , mat_cans , 100 ) else
2528: LD_VAR 0 3
2532: PPUSH
2533: LD_INT 1
2535: PPUSH
2536: LD_INT 100
2538: PPUSH
2539: CALL_OW 291
2543: GO 2560
// AddCargo ( veh , mat_oil , 100 ) ;
2545: LD_VAR 0 3
2549: PPUSH
2550: LD_INT 2
2552: PPUSH
2553: LD_INT 100
2555: PPUSH
2556: CALL_OW 291
// end ;
2560: GO 2451
2562: POP
2563: POP
// PrepareVehicle ( ru_medium_wheeled , engine_combustion , control_manual , ru_crane , rand ( 60 , 80 ) ) ;
2564: LD_INT 21
2566: PPUSH
2567: LD_INT 1
2569: PPUSH
2570: LD_INT 1
2572: PPUSH
2573: LD_INT 52
2575: PPUSH
2576: LD_INT 60
2578: PPUSH
2579: LD_INT 80
2581: PPUSH
2582: CALL_OW 12
2586: PPUSH
2587: CALL 24088 0 5
// veh = CreateVehicle ;
2591: LD_ADDR_VAR 0 3
2595: PUSH
2596: CALL_OW 45
2600: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
2601: LD_VAR 0 3
2605: PPUSH
2606: LD_INT 4
2608: PPUSH
2609: CALL_OW 233
// PlaceUnitArea ( veh , RussianSpawnArea , false ) ;
2613: LD_VAR 0 3
2617: PPUSH
2618: LD_INT 2
2620: PPUSH
2621: LD_INT 0
2623: PPUSH
2624: CALL_OW 49
// for i := 1 to 3 do
2628: LD_ADDR_VAR 0 2
2632: PUSH
2633: DOUBLE
2634: LD_INT 1
2636: DEC
2637: ST_TO_ADDR
2638: LD_INT 3
2640: PUSH
2641: FOR_TO
2642: IFFALSE 2710
// begin PrepareVehicle ( ru_heavy_tracked , engine_combustion , control_manual , ru_bulldozer , rand ( 60 , 80 ) ) ;
2644: LD_INT 24
2646: PPUSH
2647: LD_INT 1
2649: PPUSH
2650: LD_INT 1
2652: PPUSH
2653: LD_INT 53
2655: PPUSH
2656: LD_INT 60
2658: PPUSH
2659: LD_INT 80
2661: PPUSH
2662: CALL_OW 12
2666: PPUSH
2667: CALL 24088 0 5
// veh = CreateVehicle ;
2671: LD_ADDR_VAR 0 3
2675: PUSH
2676: CALL_OW 45
2680: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
2681: LD_VAR 0 3
2685: PPUSH
2686: LD_INT 4
2688: PPUSH
2689: CALL_OW 233
// PlaceUnitArea ( veh , RussianSpawnArea , false ) ;
2693: LD_VAR 0 3
2697: PPUSH
2698: LD_INT 2
2700: PPUSH
2701: LD_INT 0
2703: PPUSH
2704: CALL_OW 49
// end ;
2708: GO 2641
2710: POP
2711: POP
// end ;
2712: LD_VAR 0 1
2716: RET
// function InitRussianRequiments ; var i ; begin
2717: LD_INT 0
2719: PPUSH
2720: PPUSH
// availableWeapons = [ ru_heavy_machine_gun , ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher ] ;
2721: LD_ADDR_EXP 11
2725: PUSH
2726: LD_INT 42
2728: PUSH
2729: LD_INT 43
2731: PUSH
2732: LD_INT 44
2734: PUSH
2735: LD_INT 46
2737: PUSH
2738: LD_INT 45
2740: PUSH
2741: EMPTY
2742: LIST
2743: LIST
2744: LIST
2745: LIST
2746: LIST
2747: ST_TO_ADDR
// for i := 1 to availableWeapons do
2748: LD_ADDR_VAR 0 2
2752: PUSH
2753: DOUBLE
2754: LD_INT 1
2756: DEC
2757: ST_TO_ADDR
2758: LD_EXP 11
2762: PUSH
2763: FOR_TO
2764: IFFALSE 2804
// weaponsData = weaponsData ^ [ [ availableWeapons [ i ] , false , false ] ] ;
2766: LD_ADDR_EXP 12
2770: PUSH
2771: LD_EXP 12
2775: PUSH
2776: LD_EXP 11
2780: PUSH
2781: LD_VAR 0 2
2785: ARRAY
2786: PUSH
2787: LD_INT 0
2789: PUSH
2790: LD_INT 0
2792: PUSH
2793: EMPTY
2794: LIST
2795: LIST
2796: LIST
2797: PUSH
2798: EMPTY
2799: LIST
2800: ADD
2801: ST_TO_ADDR
2802: GO 2763
2804: POP
2805: POP
// for i := 0 to 50 do
2806: LD_ADDR_VAR 0 2
2810: PUSH
2811: DOUBLE
2812: LD_INT 0
2814: DEC
2815: ST_TO_ADDR
2816: LD_INT 50
2818: PUSH
2819: FOR_TO
2820: IFFALSE 2858
// if GetRestrict ( i , 3 ) = state_enabled then
2822: LD_VAR 0 2
2826: PPUSH
2827: LD_INT 3
2829: PPUSH
2830: CALL_OW 323
2834: PUSH
2835: LD_INT 1
2837: EQUAL
2838: IFFALSE 2856
// buildingsToBuild = buildingsToBuild ^ i ;
2840: LD_ADDR_EXP 8
2844: PUSH
2845: LD_EXP 8
2849: PUSH
2850: LD_VAR 0 2
2854: ADD
2855: ST_TO_ADDR
2856: GO 2819
2858: POP
2859: POP
// buildingsToBuild = buildingsToBuild diff [ 0 , 2 , 4 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 14 , 22 , 31 , 32 , 33 , 39 , 40 ] ;
2860: LD_ADDR_EXP 8
2864: PUSH
2865: LD_EXP 8
2869: PUSH
2870: LD_INT 0
2872: PUSH
2873: LD_INT 2
2875: PUSH
2876: LD_INT 4
2878: PUSH
2879: LD_INT 6
2881: PUSH
2882: LD_INT 7
2884: PUSH
2885: LD_INT 8
2887: PUSH
2888: LD_INT 9
2890: PUSH
2891: LD_INT 10
2893: PUSH
2894: LD_INT 11
2896: PUSH
2897: LD_INT 12
2899: PUSH
2900: LD_INT 14
2902: PUSH
2903: LD_INT 22
2905: PUSH
2906: LD_INT 31
2908: PUSH
2909: LD_INT 32
2911: PUSH
2912: LD_INT 33
2914: PUSH
2915: LD_INT 39
2917: PUSH
2918: LD_INT 40
2920: PUSH
2921: EMPTY
2922: LIST
2923: LIST
2924: LIST
2925: LIST
2926: LIST
2927: LIST
2928: LIST
2929: LIST
2930: LIST
2931: LIST
2932: LIST
2933: LIST
2934: LIST
2935: LIST
2936: LIST
2937: LIST
2938: LIST
2939: DIFF
2940: ST_TO_ADDR
// allBuildings = buildingsToBuild ;
2941: LD_ADDR_EXP 13
2945: PUSH
2946: LD_EXP 8
2950: ST_TO_ADDR
// techsToResearch = GetTechNation ( 3 , nation_russian , state_enabled ) ;
2951: LD_ADDR_EXP 9
2955: PUSH
2956: LD_INT 3
2958: PPUSH
2959: LD_INT 3
2961: PPUSH
2962: LD_INT 1
2964: PPUSH
2965: CALL 19287 0 3
2969: ST_TO_ADDR
// end ; end_of_file
2970: LD_VAR 0 1
2974: RET
// export amAttackTeam ; export function PrepareAmericans ; begin
2975: LD_INT 0
2977: PPUSH
// amAttackTeam = [ ] ;
2978: LD_ADDR_EXP 78
2982: PUSH
2983: EMPTY
2984: ST_TO_ADDR
// SpawnAmericansSnipers ;
2985: CALL 3119 0 0
// case Difficulty of 2 :
2989: LD_OWVAR 67
2993: PUSH
2994: LD_INT 2
2996: DOUBLE
2997: EQUAL
2998: IFTRUE 3002
3000: GO 3031
3002: POP
// begin SetTech ( tech_comp1 , 1 , state_researched ) ;
3003: LD_INT 57
3005: PPUSH
3006: LD_INT 1
3008: PPUSH
3009: LD_INT 2
3011: PPUSH
3012: CALL_OW 322
// SetTech ( tech_opto1 , 1 , state_researched ) ;
3016: LD_INT 60
3018: PPUSH
3019: LD_INT 1
3021: PPUSH
3022: LD_INT 2
3024: PPUSH
3025: CALL_OW 322
// end ; 3 .. 4 :
3029: GO 3114
3031: LD_INT 3
3033: DOUBLE
3034: GREATEREQUAL
3035: IFFALSE 3043
3037: LD_INT 4
3039: DOUBLE
3040: LESSEQUAL
3041: IFTRUE 3045
3043: GO 3113
3045: POP
// begin SetTech ( tech_comp1 , 1 , state_researched ) ;
3046: LD_INT 57
3048: PPUSH
3049: LD_INT 1
3051: PPUSH
3052: LD_INT 2
3054: PPUSH
3055: CALL_OW 322
// SetTech ( tech_comp2 , 1 , state_researched ) ;
3059: LD_INT 58
3061: PPUSH
3062: LD_INT 1
3064: PPUSH
3065: LD_INT 2
3067: PPUSH
3068: CALL_OW 322
// SetTech ( tech_weap3 , 1 , state_researched ) ;
3072: LD_INT 53
3074: PPUSH
3075: LD_INT 1
3077: PPUSH
3078: LD_INT 2
3080: PPUSH
3081: CALL_OW 322
// SetTech ( tech_opto1 , 1 , state_researched ) ;
3085: LD_INT 60
3087: PPUSH
3088: LD_INT 1
3090: PPUSH
3091: LD_INT 2
3093: PPUSH
3094: CALL_OW 322
// SetTech ( tech_opto2 , 1 , state_researched ) ;
3098: LD_INT 61
3100: PPUSH
3101: LD_INT 1
3103: PPUSH
3104: LD_INT 2
3106: PPUSH
3107: CALL_OW 322
// end ; end ;
3111: GO 3114
3113: POP
// end ;
3114: LD_VAR 0 1
3118: RET
// export function SpawnAmericansSnipers ; var i , un ; begin
3119: LD_INT 0
3121: PPUSH
3122: PPUSH
3123: PPUSH
// uc_side = 1 ;
3124: LD_ADDR_OWVAR 20
3128: PUSH
3129: LD_INT 1
3131: ST_TO_ADDR
// uc_nation = 1 ;
3132: LD_ADDR_OWVAR 21
3136: PUSH
3137: LD_INT 1
3139: ST_TO_ADDR
// for i := 1 to 8 do
3140: LD_ADDR_VAR 0 2
3144: PUSH
3145: DOUBLE
3146: LD_INT 1
3148: DEC
3149: ST_TO_ADDR
3150: LD_INT 8
3152: PUSH
3153: FOR_TO
3154: IFFALSE 3207
// begin PrepareHuman ( false , class_sniper , enemySkillLevel ) ;
3156: LD_INT 0
3158: PPUSH
3159: LD_INT 5
3161: PPUSH
3162: LD_EXP 56
3166: PPUSH
3167: CALL_OW 380
// un = CreateHuman ;
3171: LD_ADDR_VAR 0 3
3175: PUSH
3176: CALL_OW 44
3180: ST_TO_ADDR
// PlaceUnitArea ( un , AmericansSnipersSpawnArea , false ) ;
3181: LD_VAR 0 3
3185: PPUSH
3186: LD_INT 14
3188: PPUSH
3189: LD_INT 0
3191: PPUSH
3192: CALL_OW 49
// ComHold ( un ) ;
3196: LD_VAR 0 3
3200: PPUSH
3201: CALL_OW 140
// end ;
3205: GO 3153
3207: POP
3208: POP
// end ;
3209: LD_VAR 0 1
3213: RET
// export function SpawnAmAttackTeam ; var i , unit , veh , randVehType , weapon , chassis , amSolds , amSnipers , amVehs ; begin
3214: LD_INT 0
3216: PPUSH
3217: PPUSH
3218: PPUSH
3219: PPUSH
3220: PPUSH
3221: PPUSH
3222: PPUSH
3223: PPUSH
3224: PPUSH
3225: PPUSH
// uc_side = 1 ;
3226: LD_ADDR_OWVAR 20
3230: PUSH
3231: LD_INT 1
3233: ST_TO_ADDR
// uc_nation = 1 ;
3234: LD_ADDR_OWVAR 21
3238: PUSH
3239: LD_INT 1
3241: ST_TO_ADDR
// amSolds = Rand ( enemyAttackUnitsData [ 1 ] [ 2 ] , enemyAttackUnitsData [ 1 ] [ 3 ] ) ;
3242: LD_ADDR_VAR 0 8
3246: PUSH
3247: LD_EXP 53
3251: PUSH
3252: LD_INT 1
3254: ARRAY
3255: PUSH
3256: LD_INT 2
3258: ARRAY
3259: PPUSH
3260: LD_EXP 53
3264: PUSH
3265: LD_INT 1
3267: ARRAY
3268: PUSH
3269: LD_INT 3
3271: ARRAY
3272: PPUSH
3273: CALL_OW 12
3277: ST_TO_ADDR
// amSnipers = Rand ( enemyAttackUnitsData [ 1 ] [ 4 ] , enemyAttackUnitsData [ 1 ] [ 5 ] ) ;
3278: LD_ADDR_VAR 0 9
3282: PUSH
3283: LD_EXP 53
3287: PUSH
3288: LD_INT 1
3290: ARRAY
3291: PUSH
3292: LD_INT 4
3294: ARRAY
3295: PPUSH
3296: LD_EXP 53
3300: PUSH
3301: LD_INT 1
3303: ARRAY
3304: PUSH
3305: LD_INT 5
3307: ARRAY
3308: PPUSH
3309: CALL_OW 12
3313: ST_TO_ADDR
// amVehs = Rand ( enemyAttackUnitsData [ 1 ] [ 6 ] , enemyAttackUnitsData [ 1 ] [ 7 ] ) ;
3314: LD_ADDR_VAR 0 10
3318: PUSH
3319: LD_EXP 53
3323: PUSH
3324: LD_INT 1
3326: ARRAY
3327: PUSH
3328: LD_INT 6
3330: ARRAY
3331: PPUSH
3332: LD_EXP 53
3336: PUSH
3337: LD_INT 1
3339: ARRAY
3340: PUSH
3341: LD_INT 7
3343: ARRAY
3344: PPUSH
3345: CALL_OW 12
3349: ST_TO_ADDR
// if paidLegionOffert then
3350: LD_EXP 32
3354: IFFALSE 3388
// begin amSolds = amSolds - legionReduceAmericansUnits ;
3356: LD_ADDR_VAR 0 8
3360: PUSH
3361: LD_VAR 0 8
3365: PUSH
3366: LD_EXP 51
3370: MINUS
3371: ST_TO_ADDR
// amVehs = amVehs - legionReduceAmericansUnits ;
3372: LD_ADDR_VAR 0 10
3376: PUSH
3377: LD_VAR 0 10
3381: PUSH
3382: LD_EXP 51
3386: MINUS
3387: ST_TO_ADDR
// end ; for i := 1 to amSolds do
3388: LD_ADDR_VAR 0 2
3392: PUSH
3393: DOUBLE
3394: LD_INT 1
3396: DEC
3397: ST_TO_ADDR
3398: LD_VAR 0 8
3402: PUSH
3403: FOR_TO
3404: IFFALSE 3461
// begin PrepareSoldier ( false , enemySkillLevel ) ;
3406: LD_INT 0
3408: PPUSH
3409: LD_EXP 56
3413: PPUSH
3414: CALL_OW 381
// unit = CreateHuman ;
3418: LD_ADDR_VAR 0 3
3422: PUSH
3423: CALL_OW 44
3427: ST_TO_ADDR
// PlaceUnitArea ( unit , AmericanSpawnArea , false ) ;
3428: LD_VAR 0 3
3432: PPUSH
3433: LD_INT 3
3435: PPUSH
3436: LD_INT 0
3438: PPUSH
3439: CALL_OW 49
// amAttackTeam = amAttackTeam ^ unit ;
3443: LD_ADDR_EXP 78
3447: PUSH
3448: LD_EXP 78
3452: PUSH
3453: LD_VAR 0 3
3457: ADD
3458: ST_TO_ADDR
// end ;
3459: GO 3403
3461: POP
3462: POP
// for i := 1 to amSnipers do
3463: LD_ADDR_VAR 0 2
3467: PUSH
3468: DOUBLE
3469: LD_INT 1
3471: DEC
3472: ST_TO_ADDR
3473: LD_VAR 0 9
3477: PUSH
3478: FOR_TO
3479: IFFALSE 3539
// begin PrepareHuman ( false , class_sniper , enemySkillLevel ) ;
3481: LD_INT 0
3483: PPUSH
3484: LD_INT 5
3486: PPUSH
3487: LD_EXP 56
3491: PPUSH
3492: CALL_OW 380
// unit = CreateHuman ;
3496: LD_ADDR_VAR 0 3
3500: PUSH
3501: CALL_OW 44
3505: ST_TO_ADDR
// PlaceUnitArea ( unit , AmericanSpawnArea , false ) ;
3506: LD_VAR 0 3
3510: PPUSH
3511: LD_INT 3
3513: PPUSH
3514: LD_INT 0
3516: PPUSH
3517: CALL_OW 49
// amAttackTeam = amAttackTeam ^ unit ;
3521: LD_ADDR_EXP 78
3525: PUSH
3526: LD_EXP 78
3530: PUSH
3531: LD_VAR 0 3
3535: ADD
3536: ST_TO_ADDR
// end ;
3537: GO 3478
3539: POP
3540: POP
// for i := 1 to amVehs do
3541: LD_ADDR_VAR 0 2
3545: PUSH
3546: DOUBLE
3547: LD_INT 1
3549: DEC
3550: ST_TO_ADDR
3551: LD_VAR 0 10
3555: PUSH
3556: FOR_TO
3557: IFFALSE 3840
// begin randVehType = Rand ( 1 , 4 ) ;
3559: LD_ADDR_VAR 0 5
3563: PUSH
3564: LD_INT 1
3566: PPUSH
3567: LD_INT 4
3569: PPUSH
3570: CALL_OW 12
3574: ST_TO_ADDR
// weapon = [ us_gatling_gun , us_double_gun , us_light_gun , us_rocket_launcher , us_heavy_gun ] [ Rand ( 1 , 5 ) ] ;
3575: LD_ADDR_VAR 0 6
3579: PUSH
3580: LD_INT 4
3582: PUSH
3583: LD_INT 5
3585: PUSH
3586: LD_INT 3
3588: PUSH
3589: LD_INT 7
3591: PUSH
3592: LD_INT 6
3594: PUSH
3595: EMPTY
3596: LIST
3597: LIST
3598: LIST
3599: LIST
3600: LIST
3601: PUSH
3602: LD_INT 1
3604: PPUSH
3605: LD_INT 5
3607: PPUSH
3608: CALL_OW 12
3612: ARRAY
3613: ST_TO_ADDR
// if weapon = us_heavy_gun then
3614: LD_VAR 0 6
3618: PUSH
3619: LD_INT 6
3621: EQUAL
3622: IFFALSE 3634
// chassis = us_heavy_tracked else
3624: LD_ADDR_VAR 0 7
3628: PUSH
3629: LD_INT 4
3631: ST_TO_ADDR
3632: GO 3661
// chassis = [ us_medium_tracked , us_heavy_tracked ] [ Rand ( 1 , 2 ) ] ;
3634: LD_ADDR_VAR 0 7
3638: PUSH
3639: LD_INT 3
3641: PUSH
3642: LD_INT 4
3644: PUSH
3645: EMPTY
3646: LIST
3647: LIST
3648: PUSH
3649: LD_INT 1
3651: PPUSH
3652: LD_INT 2
3654: PPUSH
3655: CALL_OW 12
3659: ARRAY
3660: ST_TO_ADDR
// if randVehType = 1 then
3661: LD_VAR 0 5
3665: PUSH
3666: LD_INT 1
3668: EQUAL
3669: IFFALSE 3704
// PrepareVehicle ( chassis , engine_combustion , control_manual , weapon , Rand ( 70 , 90 ) ) else
3671: LD_VAR 0 7
3675: PPUSH
3676: LD_INT 1
3678: PPUSH
3679: LD_INT 1
3681: PPUSH
3682: LD_VAR 0 6
3686: PPUSH
3687: LD_INT 70
3689: PPUSH
3690: LD_INT 90
3692: PPUSH
3693: CALL_OW 12
3697: PPUSH
3698: CALL 24088 0 5
3702: GO 3735
// PrepareVehicle ( chassis , engine_combustion , control_computer , weapon , Rand ( 70 , 90 ) ) ;
3704: LD_VAR 0 7
3708: PPUSH
3709: LD_INT 1
3711: PPUSH
3712: LD_INT 3
3714: PPUSH
3715: LD_VAR 0 6
3719: PPUSH
3720: LD_INT 70
3722: PPUSH
3723: LD_INT 90
3725: PPUSH
3726: CALL_OW 12
3730: PPUSH
3731: CALL 24088 0 5
// veh = CreateVehicle ;
3735: LD_ADDR_VAR 0 4
3739: PUSH
3740: CALL_OW 45
3744: ST_TO_ADDR
// PlaceUnitArea ( veh , AmericanSpawnArea , false ) ;
3745: LD_VAR 0 4
3749: PPUSH
3750: LD_INT 3
3752: PPUSH
3753: LD_INT 0
3755: PPUSH
3756: CALL_OW 49
// amAttackTeam = amAttackTeam ^ veh ;
3760: LD_ADDR_EXP 78
3764: PUSH
3765: LD_EXP 78
3769: PUSH
3770: LD_VAR 0 4
3774: ADD
3775: ST_TO_ADDR
// if randVehType = 1 then
3776: LD_VAR 0 5
3780: PUSH
3781: LD_INT 1
3783: EQUAL
3784: IFFALSE 3838
// begin PrepareMechanic ( false , enemySkillLevel ) ;
3786: LD_INT 0
3788: PPUSH
3789: LD_EXP 56
3793: PPUSH
3794: CALL_OW 383
// unit = CreateHuman ;
3798: LD_ADDR_VAR 0 3
3802: PUSH
3803: CALL_OW 44
3807: ST_TO_ADDR
// PlaceHumanInUnit ( unit , veh ) ;
3808: LD_VAR 0 3
3812: PPUSH
3813: LD_VAR 0 4
3817: PPUSH
3818: CALL_OW 52
// amAttackTeam = amAttackTeam ^ unit ;
3822: LD_ADDR_EXP 78
3826: PUSH
3827: LD_EXP 78
3831: PUSH
3832: LD_VAR 0 3
3836: ADD
3837: ST_TO_ADDR
// end ; end ;
3838: GO 3556
3840: POP
3841: POP
// end ; end_of_file
3842: LD_VAR 0 1
3846: RET
// export Heike , Kurt , Dietrich ; export KurtEng ; export GensherTeam ; export arAttackTeam ; export function PrepareArabians ; begin
3847: LD_INT 0
3849: PPUSH
// arAttackTeam = [ ] ;
3850: LD_ADDR_EXP 84
3854: PUSH
3855: EMPTY
3856: ST_TO_ADDR
// PrepareHeroes ;
3857: CALL 4262 0 0
// case Difficulty of 2 :
3861: LD_OWVAR 67
3865: PUSH
3866: LD_INT 2
3868: DOUBLE
3869: EQUAL
3870: IFTRUE 3874
3872: GO 3890
3874: POP
// begin SetTech ( tech_stimDrugs , 8 , state_researched ) ;
3875: LD_INT 5
3877: PPUSH
3878: LD_INT 8
3880: PPUSH
3881: LD_INT 2
3883: PPUSH
3884: CALL_OW 322
// end ; 3 :
3888: GO 3941
3890: LD_INT 3
3892: DOUBLE
3893: EQUAL
3894: IFTRUE 3898
3896: GO 3940
3898: POP
// begin SetTech ( tech_stimDrugs , 8 , state_researched ) ;
3899: LD_INT 5
3901: PPUSH
3902: LD_INT 8
3904: PPUSH
3905: LD_INT 2
3907: PPUSH
3908: CALL_OW 322
// SetTech ( tech_bio1 , 8 , state_researched ) ;
3912: LD_INT 66
3914: PPUSH
3915: LD_INT 8
3917: PPUSH
3918: LD_INT 2
3920: PPUSH
3921: CALL_OW 322
// SetTech ( tech_weap3 , 8 , state_researched ) ;
3925: LD_INT 53
3927: PPUSH
3928: LD_INT 8
3930: PPUSH
3931: LD_INT 2
3933: PPUSH
3934: CALL_OW 322
// end ; end ;
3938: GO 3941
3940: POP
// end ;
3941: LD_VAR 0 1
3945: RET
// export function SpawnGensherTeam ; var i , driver , veh ; begin
3946: LD_INT 0
3948: PPUSH
3949: PPUSH
3950: PPUSH
3951: PPUSH
// GensherTeam = [ ] ;
3952: LD_ADDR_EXP 83
3956: PUSH
3957: EMPTY
3958: ST_TO_ADDR
// uc_side = 2 ;
3959: LD_ADDR_OWVAR 20
3963: PUSH
3964: LD_INT 2
3966: ST_TO_ADDR
// uc_nation = 2 ;
3967: LD_ADDR_OWVAR 21
3971: PUSH
3972: LD_INT 2
3974: ST_TO_ADDR
// for i := 1 to 3 do
3975: LD_ADDR_VAR 0 2
3979: PUSH
3980: DOUBLE
3981: LD_INT 1
3983: DEC
3984: ST_TO_ADDR
3985: LD_INT 3
3987: PUSH
3988: FOR_TO
3989: IFFALSE 4148
// begin PrepareSoldier ( sex_male , rand ( 3 , 5 ) ) ;
3991: LD_INT 1
3993: PPUSH
3994: LD_INT 3
3996: PPUSH
3997: LD_INT 5
3999: PPUSH
4000: CALL_OW 12
4004: PPUSH
4005: CALL_OW 381
// driver = CreateHuman ;
4009: LD_ADDR_VAR 0 3
4013: PUSH
4014: CALL_OW 44
4018: ST_TO_ADDR
// PrepareVehicle ( ar_medium_trike , engine_combustion , control_manual , ar_cargo_bay , rand ( 50 , 70 ) ) ;
4019: LD_INT 13
4021: PPUSH
4022: LD_INT 1
4024: PPUSH
4025: LD_INT 1
4027: PPUSH
4028: LD_INT 32
4030: PPUSH
4031: LD_INT 50
4033: PPUSH
4034: LD_INT 70
4036: PPUSH
4037: CALL_OW 12
4041: PPUSH
4042: CALL 24088 0 5
// veh = CreateVehicle ;
4046: LD_ADDR_VAR 0 4
4050: PUSH
4051: CALL_OW 45
4055: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
4056: LD_VAR 0 4
4060: PPUSH
4061: LD_INT 4
4063: PPUSH
4064: CALL_OW 233
// PlaceUnitArea ( veh , GensherSpawnArea , false ) ;
4068: LD_VAR 0 4
4072: PPUSH
4073: LD_INT 4
4075: PPUSH
4076: LD_INT 0
4078: PPUSH
4079: CALL_OW 49
// PlaceHumanInUnit ( driver , veh ) ;
4083: LD_VAR 0 3
4087: PPUSH
4088: LD_VAR 0 4
4092: PPUSH
4093: CALL_OW 52
// AddCargo ( veh , i , 100 ) ;
4097: LD_VAR 0 4
4101: PPUSH
4102: LD_VAR 0 2
4106: PPUSH
4107: LD_INT 100
4109: PPUSH
4110: CALL_OW 291
// GensherTeam = GensherTeam ^ driver ;
4114: LD_ADDR_EXP 83
4118: PUSH
4119: LD_EXP 83
4123: PUSH
4124: LD_VAR 0 3
4128: ADD
4129: ST_TO_ADDR
// GensherTeam = GensherTeam ^ veh ;
4130: LD_ADDR_EXP 83
4134: PUSH
4135: LD_EXP 83
4139: PUSH
4140: LD_VAR 0 4
4144: ADD
4145: ST_TO_ADDR
// end ;
4146: GO 3988
4148: POP
4149: POP
// if IsOK ( KurtEng ) and GetSide ( KurtEng ) = 3 then
4150: LD_EXP 82
4154: PPUSH
4155: CALL_OW 302
4159: PUSH
4160: LD_EXP 82
4164: PPUSH
4165: CALL_OW 255
4169: PUSH
4170: LD_INT 3
4172: EQUAL
4173: AND
4174: IFFALSE 4208
// begin GensherTargetX = GetX ( Kurt ) ;
4176: LD_ADDR_EXP 16
4180: PUSH
4181: LD_EXP 80
4185: PPUSH
4186: CALL_OW 250
4190: ST_TO_ADDR
// GensherTargetY = GetY ( Kurt ) ;
4191: LD_ADDR_EXP 17
4195: PUSH
4196: LD_EXP 80
4200: PPUSH
4201: CALL_OW 251
4205: ST_TO_ADDR
// end else
4206: GO 4238
// begin GensherTargetX = GetX ( Burlak ) ;
4208: LD_ADDR_EXP 16
4212: PUSH
4213: LD_EXP 57
4217: PPUSH
4218: CALL_OW 250
4222: ST_TO_ADDR
// GensherTargetY = GetY ( Burlak ) ;
4223: LD_ADDR_EXP 17
4227: PUSH
4228: LD_EXP 57
4232: PPUSH
4233: CALL_OW 251
4237: ST_TO_ADDR
// end ; ComMoveXY ( GensherTeam , GensherTargetX , GensherTargetY ) ;
4238: LD_EXP 83
4242: PPUSH
4243: LD_EXP 16
4247: PPUSH
4248: LD_EXP 17
4252: PPUSH
4253: CALL_OW 111
// end ;
4257: LD_VAR 0 1
4261: RET
// function PrepareHeroes ; begin
4262: LD_INT 0
4264: PPUSH
// uc_side = 5 ;
4265: LD_ADDR_OWVAR 20
4269: PUSH
4270: LD_INT 5
4272: ST_TO_ADDR
// uc_nation = 2 ;
4273: LD_ADDR_OWVAR 21
4277: PUSH
4278: LD_INT 2
4280: ST_TO_ADDR
// Heike = PrepareUnitExt ( Heike , true , class_engineer ) ;
4281: LD_ADDR_EXP 79
4285: PUSH
4286: LD_STRING Heike
4288: PPUSH
4289: LD_INT 1
4291: PPUSH
4292: LD_INT 2
4294: PPUSH
4295: CALL 5930 0 3
4299: ST_TO_ADDR
// uc_side = 8 ;
4300: LD_ADDR_OWVAR 20
4304: PUSH
4305: LD_INT 8
4307: ST_TO_ADDR
// Kurt = PrepareUnitExt ( Kurt , false , 0 ) ;
4308: LD_ADDR_EXP 80
4312: PUSH
4313: LD_STRING Kurt
4315: PPUSH
4316: LD_INT 0
4318: PPUSH
4319: LD_INT 0
4321: PPUSH
4322: CALL 5930 0 3
4326: ST_TO_ADDR
// uc_side = 2 ;
4327: LD_ADDR_OWVAR 20
4331: PUSH
4332: LD_INT 2
4334: ST_TO_ADDR
// Dietrich = PrepareUnitExt ( Dietrich , false , 0 ) ;
4335: LD_ADDR_EXP 81
4339: PUSH
4340: LD_STRING Dietrich
4342: PPUSH
4343: LD_INT 0
4345: PPUSH
4346: LD_INT 0
4348: PPUSH
4349: CALL 5930 0 3
4353: ST_TO_ADDR
// end ;
4354: LD_VAR 0 1
4358: RET
// export function SpawnArAttackTeam ; var i , unit , veh , weapon , chassis ; begin
4359: LD_INT 0
4361: PPUSH
4362: PPUSH
4363: PPUSH
4364: PPUSH
4365: PPUSH
4366: PPUSH
// uc_side = 8 ;
4367: LD_ADDR_OWVAR 20
4371: PUSH
4372: LD_INT 8
4374: ST_TO_ADDR
// uc_nation = 2 ;
4375: LD_ADDR_OWVAR 21
4379: PUSH
4380: LD_INT 2
4382: ST_TO_ADDR
// for i := 1 to Rand ( enemyAttackUnitsData [ 1 ] [ 2 ] , enemyAttackUnitsData [ 1 ] [ 3 ] ) do
4383: LD_ADDR_VAR 0 2
4387: PUSH
4388: DOUBLE
4389: LD_INT 1
4391: DEC
4392: ST_TO_ADDR
4393: LD_EXP 53
4397: PUSH
4398: LD_INT 1
4400: ARRAY
4401: PUSH
4402: LD_INT 2
4404: ARRAY
4405: PPUSH
4406: LD_EXP 53
4410: PUSH
4411: LD_INT 1
4413: ARRAY
4414: PUSH
4415: LD_INT 3
4417: ARRAY
4418: PPUSH
4419: CALL_OW 12
4423: PUSH
4424: FOR_TO
4425: IFFALSE 4482
// begin PrepareSoldier ( false , enemySkillLevel ) ;
4427: LD_INT 0
4429: PPUSH
4430: LD_EXP 56
4434: PPUSH
4435: CALL_OW 381
// unit = CreateHuman ;
4439: LD_ADDR_VAR 0 3
4443: PUSH
4444: CALL_OW 44
4448: ST_TO_ADDR
// PlaceUnitArea ( unit , KurtUnitsSpawnArea , false ) ;
4449: LD_VAR 0 3
4453: PPUSH
4454: LD_INT 10
4456: PPUSH
4457: LD_INT 0
4459: PPUSH
4460: CALL_OW 49
// arAttackTeam = arAttackTeam ^ unit ;
4464: LD_ADDR_EXP 84
4468: PUSH
4469: LD_EXP 84
4473: PUSH
4474: LD_VAR 0 3
4478: ADD
4479: ST_TO_ADDR
// end ;
4480: GO 4424
4482: POP
4483: POP
// for i := 1 to Rand ( enemyAttackUnitsData [ 1 ] [ 4 ] , enemyAttackUnitsData [ 1 ] [ 5 ] ) do
4484: LD_ADDR_VAR 0 2
4488: PUSH
4489: DOUBLE
4490: LD_INT 1
4492: DEC
4493: ST_TO_ADDR
4494: LD_EXP 53
4498: PUSH
4499: LD_INT 1
4501: ARRAY
4502: PUSH
4503: LD_INT 4
4505: ARRAY
4506: PPUSH
4507: LD_EXP 53
4511: PUSH
4512: LD_INT 1
4514: ARRAY
4515: PUSH
4516: LD_INT 5
4518: ARRAY
4519: PPUSH
4520: CALL_OW 12
4524: PUSH
4525: FOR_TO
4526: IFFALSE 4586
// begin PrepareHuman ( false , class_mortar , enemySkillLevel ) ;
4528: LD_INT 0
4530: PPUSH
4531: LD_INT 8
4533: PPUSH
4534: LD_EXP 56
4538: PPUSH
4539: CALL_OW 380
// unit = CreateHuman ;
4543: LD_ADDR_VAR 0 3
4547: PUSH
4548: CALL_OW 44
4552: ST_TO_ADDR
// PlaceUnitArea ( unit , KurtUnitsSpawnArea , false ) ;
4553: LD_VAR 0 3
4557: PPUSH
4558: LD_INT 10
4560: PPUSH
4561: LD_INT 0
4563: PPUSH
4564: CALL_OW 49
// arAttackTeam = arAttackTeam ^ unit ;
4568: LD_ADDR_EXP 84
4572: PUSH
4573: LD_EXP 84
4577: PUSH
4578: LD_VAR 0 3
4582: ADD
4583: ST_TO_ADDR
// end ;
4584: GO 4525
4586: POP
4587: POP
// for i := 1 to Rand ( enemyAttackUnitsData [ 1 ] [ 6 ] , enemyAttackUnitsData [ 1 ] [ 7 ] ) do
4588: LD_ADDR_VAR 0 2
4592: PUSH
4593: DOUBLE
4594: LD_INT 1
4596: DEC
4597: ST_TO_ADDR
4598: LD_EXP 53
4602: PUSH
4603: LD_INT 1
4605: ARRAY
4606: PUSH
4607: LD_INT 6
4609: ARRAY
4610: PPUSH
4611: LD_EXP 53
4615: PUSH
4616: LD_INT 1
4618: ARRAY
4619: PUSH
4620: LD_INT 7
4622: ARRAY
4623: PPUSH
4624: CALL_OW 12
4628: PUSH
4629: FOR_TO
4630: IFFALSE 4824
// begin weapon = [ ar_gun , ar_flame_thrower , ar_rocket_launcher , ar_light_gun , ar_gatling_gun ] [ Rand ( 1 , 5 ) ] ;
4632: LD_ADDR_VAR 0 5
4636: PUSH
4637: LD_INT 27
4639: PUSH
4640: LD_INT 26
4642: PUSH
4643: LD_INT 28
4645: PUSH
4646: LD_INT 23
4648: PUSH
4649: LD_INT 25
4651: PUSH
4652: EMPTY
4653: LIST
4654: LIST
4655: LIST
4656: LIST
4657: LIST
4658: PUSH
4659: LD_INT 1
4661: PPUSH
4662: LD_INT 5
4664: PPUSH
4665: CALL_OW 12
4669: ARRAY
4670: ST_TO_ADDR
// chassis = [ ar_medium_trike , ar_half_tracked ] [ Rand ( 1 , 2 ) ] ;
4671: LD_ADDR_VAR 0 6
4675: PUSH
4676: LD_INT 13
4678: PUSH
4679: LD_INT 14
4681: PUSH
4682: EMPTY
4683: LIST
4684: LIST
4685: PUSH
4686: LD_INT 1
4688: PPUSH
4689: LD_INT 2
4691: PPUSH
4692: CALL_OW 12
4696: ARRAY
4697: ST_TO_ADDR
// PrepareVehicle ( chassis , engine_combustion , control_manual , weapon , Rand ( 70 , 90 ) ) ;
4698: LD_VAR 0 6
4702: PPUSH
4703: LD_INT 1
4705: PPUSH
4706: LD_INT 1
4708: PPUSH
4709: LD_VAR 0 5
4713: PPUSH
4714: LD_INT 70
4716: PPUSH
4717: LD_INT 90
4719: PPUSH
4720: CALL_OW 12
4724: PPUSH
4725: CALL 24088 0 5
// veh = CreateVehicle ;
4729: LD_ADDR_VAR 0 4
4733: PUSH
4734: CALL_OW 45
4738: ST_TO_ADDR
// PlaceUnitArea ( veh , KurtUnitsSpawnArea , false ) ;
4739: LD_VAR 0 4
4743: PPUSH
4744: LD_INT 10
4746: PPUSH
4747: LD_INT 0
4749: PPUSH
4750: CALL_OW 49
// arAttackTeam = arAttackTeam ^ veh ;
4754: LD_ADDR_EXP 84
4758: PUSH
4759: LD_EXP 84
4763: PUSH
4764: LD_VAR 0 4
4768: ADD
4769: ST_TO_ADDR
// PrepareMechanic ( false , enemySkillLevel ) ;
4770: LD_INT 0
4772: PPUSH
4773: LD_EXP 56
4777: PPUSH
4778: CALL_OW 383
// unit = CreateHuman ;
4782: LD_ADDR_VAR 0 3
4786: PUSH
4787: CALL_OW 44
4791: ST_TO_ADDR
// PlaceHumanInUnit ( unit , veh ) ;
4792: LD_VAR 0 3
4796: PPUSH
4797: LD_VAR 0 4
4801: PPUSH
4802: CALL_OW 52
// arAttackTeam = arAttackTeam ^ unit ;
4806: LD_ADDR_EXP 84
4810: PUSH
4811: LD_EXP 84
4815: PUSH
4816: LD_VAR 0 3
4820: ADD
4821: ST_TO_ADDR
// end ;
4822: GO 4629
4824: POP
4825: POP
// end ; end_of_file
4826: LD_VAR 0 1
4830: RET
// export function Nef_PrepareNature ; var i , un ; begin
4831: LD_INT 0
4833: PPUSH
4834: PPUSH
4835: PPUSH
// for i := 1 to animalsAmount [ 1 ] do
4836: LD_ADDR_VAR 0 2
4840: PUSH
4841: DOUBLE
4842: LD_INT 1
4844: DEC
4845: ST_TO_ADDR
4846: LD_EXP 41
4850: PUSH
4851: LD_INT 1
4853: ARRAY
4854: PUSH
4855: FOR_TO
4856: IFFALSE 4966
// begin uc_side = 0 ;
4858: LD_ADDR_OWVAR 20
4862: PUSH
4863: LD_INT 0
4865: ST_TO_ADDR
// uc_nation = nation_nature ;
4866: LD_ADDR_OWVAR 21
4870: PUSH
4871: LD_INT 0
4873: ST_TO_ADDR
// hc_class = class_apeman ;
4874: LD_ADDR_OWVAR 28
4878: PUSH
4879: LD_INT 12
4881: ST_TO_ADDR
// hc_skills = [ animalsStats [ 1 ] , animalsStats [ 2 ] , animalsStats [ 3 ] , animalsStats [ 4 ] ] ;
4882: LD_ADDR_OWVAR 31
4886: PUSH
4887: LD_EXP 42
4891: PUSH
4892: LD_INT 1
4894: ARRAY
4895: PUSH
4896: LD_EXP 42
4900: PUSH
4901: LD_INT 2
4903: ARRAY
4904: PUSH
4905: LD_EXP 42
4909: PUSH
4910: LD_INT 3
4912: ARRAY
4913: PUSH
4914: LD_EXP 42
4918: PUSH
4919: LD_INT 4
4921: ARRAY
4922: PUSH
4923: EMPTY
4924: LIST
4925: LIST
4926: LIST
4927: LIST
4928: ST_TO_ADDR
// hc_agressivity = animalsAgression ;
4929: LD_ADDR_OWVAR 35
4933: PUSH
4934: LD_EXP 43
4938: ST_TO_ADDR
// un = CreateHuman ;
4939: LD_ADDR_VAR 0 3
4943: PUSH
4944: CALL_OW 44
4948: ST_TO_ADDR
// PlaceUnitArea ( un , NatureArea , false ) ;
4949: LD_VAR 0 3
4953: PPUSH
4954: LD_INT 5
4956: PPUSH
4957: LD_INT 0
4959: PPUSH
4960: CALL_OW 49
// end ;
4964: GO 4855
4966: POP
4967: POP
// for i := 1 to animalsAmount [ 2 ] do
4968: LD_ADDR_VAR 0 2
4972: PUSH
4973: DOUBLE
4974: LD_INT 1
4976: DEC
4977: ST_TO_ADDR
4978: LD_EXP 41
4982: PUSH
4983: LD_INT 2
4985: ARRAY
4986: PUSH
4987: FOR_TO
4988: IFFALSE 5098
// begin uc_side = 0 ;
4990: LD_ADDR_OWVAR 20
4994: PUSH
4995: LD_INT 0
4997: ST_TO_ADDR
// uc_nation = nation_nature ;
4998: LD_ADDR_OWVAR 21
5002: PUSH
5003: LD_INT 0
5005: ST_TO_ADDR
// hc_class = class_phororhacos ;
5006: LD_ADDR_OWVAR 28
5010: PUSH
5011: LD_INT 18
5013: ST_TO_ADDR
// hc_skills = [ animalsStats [ 1 ] , animalsStats [ 2 ] , animalsStats [ 3 ] , animalsStats [ 4 ] ] ;
5014: LD_ADDR_OWVAR 31
5018: PUSH
5019: LD_EXP 42
5023: PUSH
5024: LD_INT 1
5026: ARRAY
5027: PUSH
5028: LD_EXP 42
5032: PUSH
5033: LD_INT 2
5035: ARRAY
5036: PUSH
5037: LD_EXP 42
5041: PUSH
5042: LD_INT 3
5044: ARRAY
5045: PUSH
5046: LD_EXP 42
5050: PUSH
5051: LD_INT 4
5053: ARRAY
5054: PUSH
5055: EMPTY
5056: LIST
5057: LIST
5058: LIST
5059: LIST
5060: ST_TO_ADDR
// hc_agressivity = animalsAgression ;
5061: LD_ADDR_OWVAR 35
5065: PUSH
5066: LD_EXP 43
5070: ST_TO_ADDR
// un = CreateHuman ;
5071: LD_ADDR_VAR 0 3
5075: PUSH
5076: CALL_OW 44
5080: ST_TO_ADDR
// PlaceUnitArea ( un , NatureArea , false ) ;
5081: LD_VAR 0 3
5085: PPUSH
5086: LD_INT 5
5088: PPUSH
5089: LD_INT 0
5091: PPUSH
5092: CALL_OW 49
// end ;
5096: GO 4987
5098: POP
5099: POP
// for i := 1 to animalsAmount [ 3 ] do
5100: LD_ADDR_VAR 0 2
5104: PUSH
5105: DOUBLE
5106: LD_INT 1
5108: DEC
5109: ST_TO_ADDR
5110: LD_EXP 41
5114: PUSH
5115: LD_INT 3
5117: ARRAY
5118: PUSH
5119: FOR_TO
5120: IFFALSE 5230
// begin uc_side = 0 ;
5122: LD_ADDR_OWVAR 20
5126: PUSH
5127: LD_INT 0
5129: ST_TO_ADDR
// uc_nation = nation_nature ;
5130: LD_ADDR_OWVAR 21
5134: PUSH
5135: LD_INT 0
5137: ST_TO_ADDR
// hc_class = class_tiger ;
5138: LD_ADDR_OWVAR 28
5142: PUSH
5143: LD_INT 14
5145: ST_TO_ADDR
// hc_skills = [ animalsStats [ 1 ] , animalsStats [ 2 ] , animalsStats [ 3 ] , animalsStats [ 4 ] ] ;
5146: LD_ADDR_OWVAR 31
5150: PUSH
5151: LD_EXP 42
5155: PUSH
5156: LD_INT 1
5158: ARRAY
5159: PUSH
5160: LD_EXP 42
5164: PUSH
5165: LD_INT 2
5167: ARRAY
5168: PUSH
5169: LD_EXP 42
5173: PUSH
5174: LD_INT 3
5176: ARRAY
5177: PUSH
5178: LD_EXP 42
5182: PUSH
5183: LD_INT 4
5185: ARRAY
5186: PUSH
5187: EMPTY
5188: LIST
5189: LIST
5190: LIST
5191: LIST
5192: ST_TO_ADDR
// hc_agressivity = animalsAgression ;
5193: LD_ADDR_OWVAR 35
5197: PUSH
5198: LD_EXP 43
5202: ST_TO_ADDR
// un = CreateHuman ;
5203: LD_ADDR_VAR 0 3
5207: PUSH
5208: CALL_OW 44
5212: ST_TO_ADDR
// PlaceUnitArea ( un , NatureArea , false ) ;
5213: LD_VAR 0 3
5217: PPUSH
5218: LD_INT 5
5220: PPUSH
5221: LD_INT 0
5223: PPUSH
5224: CALL_OW 49
// end ;
5228: GO 5119
5230: POP
5231: POP
// for i := 1 to animalsAmount [ 4 ] do
5232: LD_ADDR_VAR 0 2
5236: PUSH
5237: DOUBLE
5238: LD_INT 1
5240: DEC
5241: ST_TO_ADDR
5242: LD_EXP 41
5246: PUSH
5247: LD_INT 4
5249: ARRAY
5250: PUSH
5251: FOR_TO
5252: IFFALSE 5362
// begin uc_side = 0 ;
5254: LD_ADDR_OWVAR 20
5258: PUSH
5259: LD_INT 0
5261: ST_TO_ADDR
// uc_nation = nation_nature ;
5262: LD_ADDR_OWVAR 21
5266: PUSH
5267: LD_INT 0
5269: ST_TO_ADDR
// hc_class = 21 ;
5270: LD_ADDR_OWVAR 28
5274: PUSH
5275: LD_INT 21
5277: ST_TO_ADDR
// hc_skills = [ animalsStats [ 1 ] , animalsStats [ 2 ] , animalsStats [ 3 ] , animalsStats [ 4 ] ] ;
5278: LD_ADDR_OWVAR 31
5282: PUSH
5283: LD_EXP 42
5287: PUSH
5288: LD_INT 1
5290: ARRAY
5291: PUSH
5292: LD_EXP 42
5296: PUSH
5297: LD_INT 2
5299: ARRAY
5300: PUSH
5301: LD_EXP 42
5305: PUSH
5306: LD_INT 3
5308: ARRAY
5309: PUSH
5310: LD_EXP 42
5314: PUSH
5315: LD_INT 4
5317: ARRAY
5318: PUSH
5319: EMPTY
5320: LIST
5321: LIST
5322: LIST
5323: LIST
5324: ST_TO_ADDR
// hc_agressivity = animalsAgression ;
5325: LD_ADDR_OWVAR 35
5329: PUSH
5330: LD_EXP 43
5334: ST_TO_ADDR
// un = CreateHuman ;
5335: LD_ADDR_VAR 0 3
5339: PUSH
5340: CALL_OW 44
5344: ST_TO_ADDR
// PlaceUnitArea ( un , NatureArea , false ) ;
5345: LD_VAR 0 3
5349: PPUSH
5350: LD_INT 5
5352: PPUSH
5353: LD_INT 0
5355: PPUSH
5356: CALL_OW 49
// end ;
5360: GO 5251
5362: POP
5363: POP
// for i := 1 to animalsAmount [ 5 ] do
5364: LD_ADDR_VAR 0 2
5368: PUSH
5369: DOUBLE
5370: LD_INT 1
5372: DEC
5373: ST_TO_ADDR
5374: LD_EXP 41
5378: PUSH
5379: LD_INT 5
5381: ARRAY
5382: PUSH
5383: FOR_TO
5384: IFFALSE 5445
// begin uc_side = 0 ;
5386: LD_ADDR_OWVAR 20
5390: PUSH
5391: LD_INT 0
5393: ST_TO_ADDR
// uc_nation = nation_nature ;
5394: LD_ADDR_OWVAR 21
5398: PUSH
5399: LD_INT 0
5401: ST_TO_ADDR
// vc_chassis := 31 ;
5402: LD_ADDR_OWVAR 37
5406: PUSH
5407: LD_INT 31
5409: ST_TO_ADDR
// vc_control := control_rider ;
5410: LD_ADDR_OWVAR 38
5414: PUSH
5415: LD_INT 4
5417: ST_TO_ADDR
// un := CreateVehicle ;
5418: LD_ADDR_VAR 0 3
5422: PUSH
5423: CALL_OW 45
5427: ST_TO_ADDR
// PlaceUnitArea ( un , NatureArea , false ) ;
5428: LD_VAR 0 3
5432: PPUSH
5433: LD_INT 5
5435: PPUSH
5436: LD_INT 0
5438: PPUSH
5439: CALL_OW 49
// end ;
5443: GO 5383
5445: POP
5446: POP
// end ;
5447: LD_VAR 0 1
5451: RET
// export function SpawnTrees ; begin
5452: LD_INT 0
5454: PPUSH
// PlaceTreesToArea ( TreeArea , [ 2 , 10 , 11 , 27 , 35 ] , 40 , 10 , 4 ) ;
5455: LD_INT 1
5457: PPUSH
5458: LD_INT 2
5460: PUSH
5461: LD_INT 10
5463: PUSH
5464: LD_INT 11
5466: PUSH
5467: LD_INT 27
5469: PUSH
5470: LD_INT 35
5472: PUSH
5473: EMPTY
5474: LIST
5475: LIST
5476: LIST
5477: LIST
5478: LIST
5479: PPUSH
5480: LD_INT 40
5482: PPUSH
5483: LD_INT 10
5485: PPUSH
5486: LD_INT 4
5488: PPUSH
5489: CALL_OW 352
// PlaceTreesToArea ( TreeArea , [ 9 , 10 , 27 , 35 , 48 ] , 30 , 10 , 4 ) ;
5493: LD_INT 1
5495: PPUSH
5496: LD_INT 9
5498: PUSH
5499: LD_INT 10
5501: PUSH
5502: LD_INT 27
5504: PUSH
5505: LD_INT 35
5507: PUSH
5508: LD_INT 48
5510: PUSH
5511: EMPTY
5512: LIST
5513: LIST
5514: LIST
5515: LIST
5516: LIST
5517: PPUSH
5518: LD_INT 30
5520: PPUSH
5521: LD_INT 10
5523: PPUSH
5524: LD_INT 4
5526: PPUSH
5527: CALL_OW 352
// PlaceTreesToArea ( TreeArea , [ 2 , 9 , 10 , 11 , 27 ] , 60 , 10 , 4 ) ;
5531: LD_INT 1
5533: PPUSH
5534: LD_INT 2
5536: PUSH
5537: LD_INT 9
5539: PUSH
5540: LD_INT 10
5542: PUSH
5543: LD_INT 11
5545: PUSH
5546: LD_INT 27
5548: PUSH
5549: EMPTY
5550: LIST
5551: LIST
5552: LIST
5553: LIST
5554: LIST
5555: PPUSH
5556: LD_INT 60
5558: PPUSH
5559: LD_INT 10
5561: PPUSH
5562: LD_INT 4
5564: PPUSH
5565: CALL_OW 352
// PlaceTreesToArea ( TreeArea , [ 9 , 10 , 27 , 35 , 48 ] , 90 , 10 , 4 ) ;
5569: LD_INT 1
5571: PPUSH
5572: LD_INT 9
5574: PUSH
5575: LD_INT 10
5577: PUSH
5578: LD_INT 27
5580: PUSH
5581: LD_INT 35
5583: PUSH
5584: LD_INT 48
5586: PUSH
5587: EMPTY
5588: LIST
5589: LIST
5590: LIST
5591: LIST
5592: LIST
5593: PPUSH
5594: LD_INT 90
5596: PPUSH
5597: LD_INT 10
5599: PPUSH
5600: LD_INT 4
5602: PPUSH
5603: CALL_OW 352
// PlaceTreesToArea ( TreeArea , [ 2 , 9 , 10 , 11 , 48 ] , 120 , 10 , 4 ) ;
5607: LD_INT 1
5609: PPUSH
5610: LD_INT 2
5612: PUSH
5613: LD_INT 9
5615: PUSH
5616: LD_INT 10
5618: PUSH
5619: LD_INT 11
5621: PUSH
5622: LD_INT 48
5624: PUSH
5625: EMPTY
5626: LIST
5627: LIST
5628: LIST
5629: LIST
5630: LIST
5631: PPUSH
5632: LD_INT 120
5634: PPUSH
5635: LD_INT 10
5637: PPUSH
5638: LD_INT 4
5640: PPUSH
5641: CALL_OW 352
// PlaceTreesToArea ( TreeArea , [ 2 , 11 , 27 , 35 , 48 ] , 45 , 10 , 4 ) ;
5645: LD_INT 1
5647: PPUSH
5648: LD_INT 2
5650: PUSH
5651: LD_INT 11
5653: PUSH
5654: LD_INT 27
5656: PUSH
5657: LD_INT 35
5659: PUSH
5660: LD_INT 48
5662: PUSH
5663: EMPTY
5664: LIST
5665: LIST
5666: LIST
5667: LIST
5668: LIST
5669: PPUSH
5670: LD_INT 45
5672: PPUSH
5673: LD_INT 10
5675: PPUSH
5676: LD_INT 4
5678: PPUSH
5679: CALL_OW 352
// end ;
5683: LD_VAR 0 1
5687: RET
// every 0 0$1 do var i , un ;
5688: GO 5690
5690: DISABLE
5691: LD_INT 0
5693: PPUSH
5694: PPUSH
// begin if ( GetTech ( tech_apelang , 3 ) = state_enabled or GetTech ( tech_apepsych , 3 ) = state_enabled or GetTech ( tech_apeagres , 3 ) = state_enabled ) and not FilterAllUnits ( [ [ f_or , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman_soldier ] ] ] ) then
5695: LD_INT 1
5697: PPUSH
5698: LD_INT 3
5700: PPUSH
5701: CALL_OW 321
5705: PUSH
5706: LD_INT 1
5708: EQUAL
5709: PUSH
5710: LD_INT 2
5712: PPUSH
5713: LD_INT 3
5715: PPUSH
5716: CALL_OW 321
5720: PUSH
5721: LD_INT 1
5723: EQUAL
5724: OR
5725: PUSH
5726: LD_INT 11
5728: PPUSH
5729: LD_INT 3
5731: PPUSH
5732: CALL_OW 321
5736: PUSH
5737: LD_INT 1
5739: EQUAL
5740: OR
5741: PUSH
5742: LD_INT 2
5744: PUSH
5745: LD_INT 25
5747: PUSH
5748: LD_INT 12
5750: PUSH
5751: EMPTY
5752: LIST
5753: LIST
5754: PUSH
5755: LD_INT 25
5757: PUSH
5758: LD_INT 16
5760: PUSH
5761: EMPTY
5762: LIST
5763: LIST
5764: PUSH
5765: LD_INT 25
5767: PUSH
5768: LD_INT 15
5770: PUSH
5771: EMPTY
5772: LIST
5773: LIST
5774: PUSH
5775: EMPTY
5776: LIST
5777: LIST
5778: LIST
5779: LIST
5780: PUSH
5781: EMPTY
5782: LIST
5783: PPUSH
5784: CALL_OW 69
5788: NOT
5789: AND
5790: IFFALSE 5926
// begin for i := 1 to Rand ( 2 , 4 ) do
5792: LD_ADDR_VAR 0 1
5796: PUSH
5797: DOUBLE
5798: LD_INT 1
5800: DEC
5801: ST_TO_ADDR
5802: LD_INT 2
5804: PPUSH
5805: LD_INT 4
5807: PPUSH
5808: CALL_OW 12
5812: PUSH
5813: FOR_TO
5814: IFFALSE 5924
// begin uc_side = 0 ;
5816: LD_ADDR_OWVAR 20
5820: PUSH
5821: LD_INT 0
5823: ST_TO_ADDR
// uc_nation = nation_nature ;
5824: LD_ADDR_OWVAR 21
5828: PUSH
5829: LD_INT 0
5831: ST_TO_ADDR
// hc_class = class_apeman ;
5832: LD_ADDR_OWVAR 28
5836: PUSH
5837: LD_INT 12
5839: ST_TO_ADDR
// hc_skills = [ animalsStats [ 1 ] , animalsStats [ 2 ] , animalsStats [ 3 ] , animalsStats [ 4 ] ] ;
5840: LD_ADDR_OWVAR 31
5844: PUSH
5845: LD_EXP 42
5849: PUSH
5850: LD_INT 1
5852: ARRAY
5853: PUSH
5854: LD_EXP 42
5858: PUSH
5859: LD_INT 2
5861: ARRAY
5862: PUSH
5863: LD_EXP 42
5867: PUSH
5868: LD_INT 3
5870: ARRAY
5871: PUSH
5872: LD_EXP 42
5876: PUSH
5877: LD_INT 4
5879: ARRAY
5880: PUSH
5881: EMPTY
5882: LIST
5883: LIST
5884: LIST
5885: LIST
5886: ST_TO_ADDR
// hc_agressivity = animalsAgression ;
5887: LD_ADDR_OWVAR 35
5891: PUSH
5892: LD_EXP 43
5896: ST_TO_ADDR
// un = CreateHuman ;
5897: LD_ADDR_VAR 0 2
5901: PUSH
5902: CALL_OW 44
5906: ST_TO_ADDR
// PlaceUnitArea ( un , NatureArea , false ) ;
5907: LD_VAR 0 2
5911: PPUSH
5912: LD_INT 5
5914: PPUSH
5915: LD_INT 0
5917: PPUSH
5918: CALL_OW 49
// end ;
5922: GO 5813
5924: POP
5925: POP
// end ; enable ;
5926: ENABLE
// end ; end_of_file
5927: PPOPN 2
5929: END
// export function PrepareUnitExt ( ident , exist_mode , class ) ; var unit ; begin
5930: LD_INT 0
5932: PPUSH
5933: PPUSH
// if debugMode then
5934: LD_EXP 46
5938: IFFALSE 5955
// unit := NewCharacter ( ident ) ;
5940: LD_ADDR_VAR 0 5
5944: PUSH
5945: LD_VAR 0 1
5949: PPUSH
5950: CALL_OW 25
5954: ST_TO_ADDR
// if exist_mode and not debugMode then
5955: LD_VAR 0 2
5959: PUSH
5960: LD_EXP 46
5964: NOT
5965: AND
5966: IFFALSE 5991
// unit := CreateCharacter ( previousMissionPrefix & ident ) else
5968: LD_ADDR_VAR 0 5
5972: PUSH
5973: LD_EXP 45
5977: PUSH
5978: LD_VAR 0 1
5982: STR
5983: PPUSH
5984: CALL_OW 34
5988: ST_TO_ADDR
5989: GO 6013
// if not debugMode then
5991: LD_EXP 46
5995: NOT
5996: IFFALSE 6013
// unit := NewCharacter ( ident ) ;
5998: LD_ADDR_VAR 0 5
6002: PUSH
6003: LD_VAR 0 1
6007: PPUSH
6008: CALL_OW 25
6012: ST_TO_ADDR
// if class then
6013: LD_VAR 0 3
6017: IFFALSE 6033
// SetClass ( unit , class ) ;
6019: LD_VAR 0 5
6023: PPUSH
6024: LD_VAR 0 3
6028: PPUSH
6029: CALL_OW 336
// result := unit ;
6033: LD_ADDR_VAR 0 4
6037: PUSH
6038: LD_VAR 0 5
6042: ST_TO_ADDR
// end ;
6043: LD_VAR 0 4
6047: RET
// export function ExtSaveCharacter ( character , characterStringID , side ) ; begin
6048: LD_INT 0
6050: PPUSH
// if GetSide ( character ) = side and not IsDead ( character ) then
6051: LD_VAR 0 1
6055: PPUSH
6056: CALL_OW 255
6060: PUSH
6061: LD_VAR 0 3
6065: EQUAL
6066: PUSH
6067: LD_VAR 0 1
6071: PPUSH
6072: CALL_OW 301
6076: NOT
6077: AND
6078: IFFALSE 6100
// SaveCharacters ( character , missionPrefix & characterStringID ) ;
6080: LD_VAR 0 1
6084: PPUSH
6085: LD_EXP 44
6089: PUSH
6090: LD_VAR 0 2
6094: STR
6095: PPUSH
6096: CALL_OW 38
// end ;
6100: LD_VAR 0 4
6104: RET
// export function ExtSaveCharacters ( characters , charactersStringID , side ) ; var unit , resultCharactersToSave ; begin
6105: LD_INT 0
6107: PPUSH
6108: PPUSH
6109: PPUSH
// resultCharactersToSave = [ ] ;
6110: LD_ADDR_VAR 0 6
6114: PUSH
6115: EMPTY
6116: ST_TO_ADDR
// for unit in characters do
6117: LD_ADDR_VAR 0 5
6121: PUSH
6122: LD_VAR 0 1
6126: PUSH
6127: FOR_IN
6128: IFFALSE 6177
// if GetSide ( unit ) = side and not IsDead ( unit ) then
6130: LD_VAR 0 5
6134: PPUSH
6135: CALL_OW 255
6139: PUSH
6140: LD_VAR 0 3
6144: EQUAL
6145: PUSH
6146: LD_VAR 0 5
6150: PPUSH
6151: CALL_OW 301
6155: NOT
6156: AND
6157: IFFALSE 6175
// resultCharactersToSave = resultCharactersToSave ^ unit ;
6159: LD_ADDR_VAR 0 6
6163: PUSH
6164: LD_VAR 0 6
6168: PUSH
6169: LD_VAR 0 5
6173: ADD
6174: ST_TO_ADDR
6175: GO 6127
6177: POP
6178: POP
// SaveCharacters ( resultCharactersToSave , missionPrefix & charactersStringID ) ;
6179: LD_VAR 0 6
6183: PPUSH
6184: LD_EXP 44
6188: PUSH
6189: LD_VAR 0 2
6193: STR
6194: PPUSH
6195: CALL_OW 38
// end ;
6199: LD_VAR 0 4
6203: RET
// export function PlaceUnitsArea ( units , area , spawnMode ) ; var unit ; begin
6204: LD_INT 0
6206: PPUSH
6207: PPUSH
// for unit in units do
6208: LD_ADDR_VAR 0 5
6212: PUSH
6213: LD_VAR 0 1
6217: PUSH
6218: FOR_IN
6219: IFFALSE 6242
// PlaceUnitArea ( unit , area , spawnMode ) ;
6221: LD_VAR 0 5
6225: PPUSH
6226: LD_VAR 0 2
6230: PPUSH
6231: LD_VAR 0 3
6235: PPUSH
6236: CALL_OW 49
6240: GO 6218
6242: POP
6243: POP
// end ;
6244: LD_VAR 0 4
6248: RET
// export function DialogRandom ( characters , dialogMID , dialogFID , radio , canTalkHero ) ; var i , speaker , units ; begin
6249: LD_INT 0
6251: PPUSH
6252: PPUSH
6253: PPUSH
6254: PPUSH
// units = characters ;
6255: LD_ADDR_VAR 0 9
6259: PUSH
6260: LD_VAR 0 1
6264: ST_TO_ADDR
// units := units diff [ Burlak , Karamazov , Petrovova , Gleb , Petrosyan , Titov , Dolgov , Lipshchin , Kirilenkova ] ;
6265: LD_ADDR_VAR 0 9
6269: PUSH
6270: LD_VAR 0 9
6274: PUSH
6275: LD_EXP 57
6279: PUSH
6280: LD_EXP 58
6284: PUSH
6285: LD_EXP 59
6289: PUSH
6290: LD_EXP 60
6294: PUSH
6295: LD_EXP 61
6299: PUSH
6300: LD_EXP 62
6304: PUSH
6305: LD_EXP 63
6309: PUSH
6310: LD_EXP 64
6314: PUSH
6315: LD_EXP 65
6319: PUSH
6320: EMPTY
6321: LIST
6322: LIST
6323: LIST
6324: LIST
6325: LIST
6326: LIST
6327: LIST
6328: LIST
6329: LIST
6330: DIFF
6331: ST_TO_ADDR
// if not units and not canTalkHero then
6332: LD_VAR 0 9
6336: NOT
6337: PUSH
6338: LD_VAR 0 5
6342: NOT
6343: AND
6344: IFFALSE 6348
// exit ;
6346: GO 6521
// if not units then
6348: LD_VAR 0 9
6352: NOT
6353: IFFALSE 6374
// units = characters diff [ Burlak ] ;
6355: LD_ADDR_VAR 0 9
6359: PUSH
6360: LD_VAR 0 1
6364: PUSH
6365: LD_EXP 57
6369: PUSH
6370: EMPTY
6371: LIST
6372: DIFF
6373: ST_TO_ADDR
// if not units and canTalkHero then
6374: LD_VAR 0 9
6378: NOT
6379: PUSH
6380: LD_VAR 0 5
6384: AND
6385: IFFALSE 6389
// exit ;
6387: GO 6521
// speaker := units [ rand ( 1 , units ) ] ;
6389: LD_ADDR_VAR 0 8
6393: PUSH
6394: LD_VAR 0 9
6398: PUSH
6399: LD_INT 1
6401: PPUSH
6402: LD_VAR 0 9
6406: PPUSH
6407: CALL_OW 12
6411: ARRAY
6412: ST_TO_ADDR
// if radio then
6413: LD_VAR 0 4
6417: IFFALSE 6466
// begin if GetSex ( speaker ) = sex_male then
6419: LD_VAR 0 8
6423: PPUSH
6424: CALL_OW 258
6428: PUSH
6429: LD_INT 1
6431: EQUAL
6432: IFFALSE 6450
// SayRadio ( speaker , dialogMID ) else
6434: LD_VAR 0 8
6438: PPUSH
6439: LD_VAR 0 2
6443: PPUSH
6444: CALL_OW 94
6448: GO 6464
// SayRadio ( speaker , dialogFID ) ;
6450: LD_VAR 0 8
6454: PPUSH
6455: LD_VAR 0 3
6459: PPUSH
6460: CALL_OW 94
// end else
6464: GO 6511
// begin if GetSex ( speaker ) = sex_male then
6466: LD_VAR 0 8
6470: PPUSH
6471: CALL_OW 258
6475: PUSH
6476: LD_INT 1
6478: EQUAL
6479: IFFALSE 6497
// Say ( speaker , dialogMID ) else
6481: LD_VAR 0 8
6485: PPUSH
6486: LD_VAR 0 2
6490: PPUSH
6491: CALL_OW 88
6495: GO 6511
// Say ( speaker , dialogFID ) ;
6497: LD_VAR 0 8
6501: PPUSH
6502: LD_VAR 0 3
6506: PPUSH
6507: CALL_OW 88
// end ; result := speaker ;
6511: LD_ADDR_VAR 0 6
6515: PUSH
6516: LD_VAR 0 8
6520: ST_TO_ADDR
// end ;
6521: LD_VAR 0 6
6525: RET
// export function RemoveUnits ( units ) ; var unit ; begin
6526: LD_INT 0
6528: PPUSH
6529: PPUSH
// if not units then
6530: LD_VAR 0 1
6534: NOT
6535: IFFALSE 6539
// exit ;
6537: GO 6685
// if Heike in units then
6539: LD_EXP 79
6543: PUSH
6544: LD_VAR 0 1
6548: IN
6549: IFFALSE 6605
// begin if GetAttitude ( 3 , 8 ) = att_neutral then
6551: LD_INT 3
6553: PPUSH
6554: LD_INT 8
6556: PPUSH
6557: CALL_OW 81
6561: PUSH
6562: LD_INT 0
6564: EQUAL
6565: IFFALSE 6577
// HeikeStatus = 1 else
6567: LD_ADDR_EXP 3
6571: PUSH
6572: LD_INT 1
6574: ST_TO_ADDR
6575: GO 6585
// HeikeStatus = 2 ;
6577: LD_ADDR_EXP 3
6581: PUSH
6582: LD_INT 2
6584: ST_TO_ADDR
// forceStopKurtAttack = true ;
6585: LD_ADDR_EXP 27
6589: PUSH
6590: LD_INT 1
6592: ST_TO_ADDR
// SetClass ( Heike , 1 ) ;
6593: LD_EXP 79
6597: PPUSH
6598: LD_INT 1
6600: PPUSH
6601: CALL_OW 336
// end ; if Kurt in units then
6605: LD_EXP 80
6609: PUSH
6610: LD_VAR 0 1
6614: IN
6615: IFFALSE 6659
// begin if GetAttitude ( 3 , 8 ) = att_neutral then
6617: LD_INT 3
6619: PPUSH
6620: LD_INT 8
6622: PPUSH
6623: CALL_OW 81
6627: PUSH
6628: LD_INT 0
6630: EQUAL
6631: IFFALSE 6643
// KurtStatus = 1 else
6633: LD_ADDR_EXP 22
6637: PUSH
6638: LD_INT 1
6640: ST_TO_ADDR
6641: GO 6659
// begin KurtStatus = 2 ;
6643: LD_ADDR_EXP 22
6647: PUSH
6648: LD_INT 2
6650: ST_TO_ADDR
// KurtAttack = 1 ;
6651: LD_ADDR_EXP 25
6655: PUSH
6656: LD_INT 1
6658: ST_TO_ADDR
// end ; end ; for unit in units do
6659: LD_ADDR_VAR 0 3
6663: PUSH
6664: LD_VAR 0 1
6668: PUSH
6669: FOR_IN
6670: IFFALSE 6683
// RemoveUnit ( unit ) ;
6672: LD_VAR 0 3
6676: PPUSH
6677: CALL_OW 64
6681: GO 6669
6683: POP
6684: POP
// end ;
6685: LD_VAR 0 2
6689: RET
// export function GetAmountWeaponsDataBuildOnTurret ( isBuild ) ; var i , amount ; begin
6690: LD_INT 0
6692: PPUSH
6693: PPUSH
6694: PPUSH
// amount = 0 ;
6695: LD_ADDR_VAR 0 4
6699: PUSH
6700: LD_INT 0
6702: ST_TO_ADDR
// for i := 1 to weaponsData do
6703: LD_ADDR_VAR 0 3
6707: PUSH
6708: DOUBLE
6709: LD_INT 1
6711: DEC
6712: ST_TO_ADDR
6713: LD_EXP 12
6717: PUSH
6718: FOR_TO
6719: IFFALSE 6759
// if weaponsData [ i ] [ 2 ] = isBuild then
6721: LD_EXP 12
6725: PUSH
6726: LD_VAR 0 3
6730: ARRAY
6731: PUSH
6732: LD_INT 2
6734: ARRAY
6735: PUSH
6736: LD_VAR 0 1
6740: EQUAL
6741: IFFALSE 6757
// amount = amount + 1 ;
6743: LD_ADDR_VAR 0 4
6747: PUSH
6748: LD_VAR 0 4
6752: PUSH
6753: LD_INT 1
6755: PLUS
6756: ST_TO_ADDR
6757: GO 6718
6759: POP
6760: POP
// if isBuild then
6761: LD_VAR 0 1
6765: IFFALSE 6785
// if amount >= 3 then
6767: LD_VAR 0 4
6771: PUSH
6772: LD_INT 3
6774: GREATEREQUAL
6775: IFFALSE 6785
// amount = 3 ;
6777: LD_ADDR_VAR 0 4
6781: PUSH
6782: LD_INT 3
6784: ST_TO_ADDR
// result = amount ;
6785: LD_ADDR_VAR 0 2
6789: PUSH
6790: LD_VAR 0 4
6794: ST_TO_ADDR
// end ;
6795: LD_VAR 0 2
6799: RET
// export function GetAmountWeaponsDataBuildOnVehicle ( isBuild ) ; var i , amount ; begin
6800: LD_INT 0
6802: PPUSH
6803: PPUSH
6804: PPUSH
// amount = 0 ;
6805: LD_ADDR_VAR 0 4
6809: PUSH
6810: LD_INT 0
6812: ST_TO_ADDR
// for i := 1 to weaponsData do
6813: LD_ADDR_VAR 0 3
6817: PUSH
6818: DOUBLE
6819: LD_INT 1
6821: DEC
6822: ST_TO_ADDR
6823: LD_EXP 12
6827: PUSH
6828: FOR_TO
6829: IFFALSE 6869
// if weaponsData [ i ] [ 3 ] = isBuild then
6831: LD_EXP 12
6835: PUSH
6836: LD_VAR 0 3
6840: ARRAY
6841: PUSH
6842: LD_INT 3
6844: ARRAY
6845: PUSH
6846: LD_VAR 0 1
6850: EQUAL
6851: IFFALSE 6867
// amount = amount + 1 ;
6853: LD_ADDR_VAR 0 4
6857: PUSH
6858: LD_VAR 0 4
6862: PUSH
6863: LD_INT 1
6865: PLUS
6866: ST_TO_ADDR
6867: GO 6828
6869: POP
6870: POP
// result = amount ;
6871: LD_ADDR_VAR 0 2
6875: PUSH
6876: LD_VAR 0 4
6880: ST_TO_ADDR
// end ;
6881: LD_VAR 0 2
6885: RET
// export function SetWeaponDataBuild ( weapon , turret ) ; var i ; begin
6886: LD_INT 0
6888: PPUSH
6889: PPUSH
// if turret then
6890: LD_VAR 0 2
6894: IFFALSE 6992
// begin for i := 1 to weaponsData do
6896: LD_ADDR_VAR 0 4
6900: PUSH
6901: DOUBLE
6902: LD_INT 1
6904: DEC
6905: ST_TO_ADDR
6906: LD_EXP 12
6910: PUSH
6911: FOR_TO
6912: IFFALSE 6988
// if weaponsData [ i ] [ 1 ] = weapon and weaponsData [ i ] [ 2 ] = false then
6914: LD_EXP 12
6918: PUSH
6919: LD_VAR 0 4
6923: ARRAY
6924: PUSH
6925: LD_INT 1
6927: ARRAY
6928: PUSH
6929: LD_VAR 0 1
6933: EQUAL
6934: PUSH
6935: LD_EXP 12
6939: PUSH
6940: LD_VAR 0 4
6944: ARRAY
6945: PUSH
6946: LD_INT 2
6948: ARRAY
6949: PUSH
6950: LD_INT 0
6952: EQUAL
6953: AND
6954: IFFALSE 6986
// weaponsData = ReplaceIn ( weaponsData , [ i , 2 ] , true ) ;
6956: LD_ADDR_EXP 12
6960: PUSH
6961: LD_EXP 12
6965: PPUSH
6966: LD_VAR 0 4
6970: PUSH
6971: LD_INT 2
6973: PUSH
6974: EMPTY
6975: LIST
6976: LIST
6977: PPUSH
6978: LD_INT 1
6980: PPUSH
6981: CALL 24210 0 3
6985: ST_TO_ADDR
6986: GO 6911
6988: POP
6989: POP
// end else
6990: GO 7086
// begin for i := 1 to weaponsData do
6992: LD_ADDR_VAR 0 4
6996: PUSH
6997: DOUBLE
6998: LD_INT 1
7000: DEC
7001: ST_TO_ADDR
7002: LD_EXP 12
7006: PUSH
7007: FOR_TO
7008: IFFALSE 7084
// if weaponsData [ i ] [ 1 ] = weapon and weaponsData [ i ] [ 3 ] = false then
7010: LD_EXP 12
7014: PUSH
7015: LD_VAR 0 4
7019: ARRAY
7020: PUSH
7021: LD_INT 1
7023: ARRAY
7024: PUSH
7025: LD_VAR 0 1
7029: EQUAL
7030: PUSH
7031: LD_EXP 12
7035: PUSH
7036: LD_VAR 0 4
7040: ARRAY
7041: PUSH
7042: LD_INT 3
7044: ARRAY
7045: PUSH
7046: LD_INT 0
7048: EQUAL
7049: AND
7050: IFFALSE 7082
// weaponsData = ReplaceIn ( weaponsData , [ i , 3 ] , true ) ;
7052: LD_ADDR_EXP 12
7056: PUSH
7057: LD_EXP 12
7061: PPUSH
7062: LD_VAR 0 4
7066: PUSH
7067: LD_INT 3
7069: PUSH
7070: EMPTY
7071: LIST
7072: LIST
7073: PPUSH
7074: LD_INT 1
7076: PPUSH
7077: CALL 24210 0 3
7081: ST_TO_ADDR
7082: GO 7007
7084: POP
7085: POP
// end ; end ;
7086: LD_VAR 0 3
7090: RET
// export function ShootTreningController ; var i , unitsInArea , unit , depots , depot , barrelsAreaList , randIndex , randPosX , randPosY , barrelsInArea ; begin
7091: LD_INT 0
7093: PPUSH
7094: PPUSH
7095: PPUSH
7096: PPUSH
7097: PPUSH
7098: PPUSH
7099: PPUSH
7100: PPUSH
7101: PPUSH
7102: PPUSH
7103: PPUSH
// unitsInArea = FilterUnitsInArea ( ShootArea , [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) ;
7104: LD_ADDR_VAR 0 3
7108: PUSH
7109: LD_INT 12
7111: PPUSH
7112: LD_INT 22
7114: PUSH
7115: LD_INT 3
7117: PUSH
7118: EMPTY
7119: LIST
7120: LIST
7121: PUSH
7122: LD_INT 21
7124: PUSH
7125: LD_INT 1
7127: PUSH
7128: EMPTY
7129: LIST
7130: LIST
7131: PUSH
7132: LD_INT 50
7134: PUSH
7135: EMPTY
7136: LIST
7137: PUSH
7138: LD_INT 3
7140: PUSH
7141: LD_INT 60
7143: PUSH
7144: EMPTY
7145: LIST
7146: PUSH
7147: EMPTY
7148: LIST
7149: LIST
7150: PUSH
7151: EMPTY
7152: LIST
7153: LIST
7154: LIST
7155: LIST
7156: PPUSH
7157: CALL_OW 70
7161: ST_TO_ADDR
// depots = FilterAllUnits ( [ [ f_side , 3 ] , [ f_ok ] , [ f_type , unit_building ] , [ f_not , [ f_constructed ] ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
7162: LD_ADDR_VAR 0 5
7166: PUSH
7167: LD_INT 22
7169: PUSH
7170: LD_INT 3
7172: PUSH
7173: EMPTY
7174: LIST
7175: LIST
7176: PUSH
7177: LD_INT 50
7179: PUSH
7180: EMPTY
7181: LIST
7182: PUSH
7183: LD_INT 21
7185: PUSH
7186: LD_INT 3
7188: PUSH
7189: EMPTY
7190: LIST
7191: LIST
7192: PUSH
7193: LD_INT 3
7195: PUSH
7196: LD_INT 57
7198: PUSH
7199: EMPTY
7200: LIST
7201: PUSH
7202: EMPTY
7203: LIST
7204: LIST
7205: PUSH
7206: LD_INT 2
7208: PUSH
7209: LD_INT 30
7211: PUSH
7212: LD_INT 0
7214: PUSH
7215: EMPTY
7216: LIST
7217: LIST
7218: PUSH
7219: LD_INT 30
7221: PUSH
7222: LD_INT 1
7224: PUSH
7225: EMPTY
7226: LIST
7227: LIST
7228: PUSH
7229: EMPTY
7230: LIST
7231: LIST
7232: LIST
7233: PUSH
7234: EMPTY
7235: LIST
7236: LIST
7237: LIST
7238: LIST
7239: LIST
7240: PPUSH
7241: CALL_OW 69
7245: ST_TO_ADDR
// barrelsAreaList = AreaToList ( BarrelsArea , 0 ) ;
7246: LD_ADDR_VAR 0 7
7250: PUSH
7251: LD_INT 13
7253: PPUSH
7254: LD_INT 0
7256: PPUSH
7257: CALL_OW 517
7261: ST_TO_ADDR
// if not depots or not unitsInArea then
7262: LD_VAR 0 5
7266: NOT
7267: PUSH
7268: LD_VAR 0 3
7272: NOT
7273: OR
7274: IFFALSE 7278
// exit ;
7276: GO 7714
// depot = depots [ 1 ] ;
7278: LD_ADDR_VAR 0 6
7282: PUSH
7283: LD_VAR 0 5
7287: PUSH
7288: LD_INT 1
7290: ARRAY
7291: ST_TO_ADDR
// for unit in unitsInArea do
7292: LD_ADDR_VAR 0 4
7296: PUSH
7297: LD_VAR 0 3
7301: PUSH
7302: FOR_IN
7303: IFFALSE 7712
// begin if not GetClass ( unit ) = class_engineer then
7305: LD_VAR 0 4
7309: PPUSH
7310: CALL_OW 257
7314: PUSH
7315: LD_INT 2
7317: EQUAL
7318: NOT
7319: IFFALSE 7356
// begin ComEnterUnit ( unit , depot ) ;
7321: LD_VAR 0 4
7325: PPUSH
7326: LD_VAR 0 6
7330: PPUSH
7331: CALL_OW 120
// AddComChangeProfession ( unit , class_engineer ) ;
7335: LD_VAR 0 4
7339: PPUSH
7340: LD_INT 2
7342: PPUSH
7343: CALL_OW 183
// AddComExitBuilding ( unit ) ;
7347: LD_VAR 0 4
7351: PPUSH
7352: CALL_OW 182
// end ; if GetCargo ( unit , mat_oil ) = 0 then
7356: LD_VAR 0 4
7360: PPUSH
7361: LD_INT 2
7363: PPUSH
7364: CALL_OW 289
7368: PUSH
7369: LD_INT 0
7371: EQUAL
7372: IFFALSE 7391
// AddComTransport ( unit , depot , mat_oil ) ;
7374: LD_VAR 0 4
7378: PPUSH
7379: LD_VAR 0 6
7383: PPUSH
7384: LD_INT 2
7386: PPUSH
7387: CALL_OW 211
// repeat wait ( 0 0$1 ) ;
7391: LD_INT 35
7393: PPUSH
7394: CALL_OW 67
// until not HasTask ( unit ) ;
7398: LD_VAR 0 4
7402: PPUSH
7403: CALL_OW 314
7407: NOT
7408: IFFALSE 7391
// if GetCargo ( unit , mat_oil ) > 0 then
7410: LD_VAR 0 4
7414: PPUSH
7415: LD_INT 2
7417: PPUSH
7418: CALL_OW 289
7422: PUSH
7423: LD_INT 0
7425: GREATER
7426: IFFALSE 7710
// begin randIndex = Rand ( 1 , barrelsAreaList [ 1 ] ) ;
7428: LD_ADDR_VAR 0 8
7432: PUSH
7433: LD_INT 1
7435: PPUSH
7436: LD_VAR 0 7
7440: PUSH
7441: LD_INT 1
7443: ARRAY
7444: PPUSH
7445: CALL_OW 12
7449: ST_TO_ADDR
// randPosX = barrelsAreaList [ 1 ] [ randIndex ] ;
7450: LD_ADDR_VAR 0 9
7454: PUSH
7455: LD_VAR 0 7
7459: PUSH
7460: LD_INT 1
7462: ARRAY
7463: PUSH
7464: LD_VAR 0 8
7468: ARRAY
7469: ST_TO_ADDR
// randPosY = barrelsAreaList [ 2 ] [ RandIndex ] ;
7470: LD_ADDR_VAR 0 10
7474: PUSH
7475: LD_VAR 0 7
7479: PUSH
7480: LD_INT 2
7482: ARRAY
7483: PUSH
7484: LD_VAR 0 8
7488: ARRAY
7489: ST_TO_ADDR
// AddComMoveXY ( unit , randPosX , randPosY ) ;
7490: LD_VAR 0 4
7494: PPUSH
7495: LD_VAR 0 9
7499: PPUSH
7500: LD_VAR 0 10
7504: PPUSH
7505: CALL_OW 171
// AddComUnload ( unit ) ;
7509: LD_VAR 0 4
7513: PPUSH
7514: CALL_OW 219
// AddComMoveXY ( unit , randPosX + 2 , randPosY + 2 ) ;
7518: LD_VAR 0 4
7522: PPUSH
7523: LD_VAR 0 9
7527: PUSH
7528: LD_INT 2
7530: PLUS
7531: PPUSH
7532: LD_VAR 0 10
7536: PUSH
7537: LD_INT 2
7539: PLUS
7540: PPUSH
7541: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
7545: LD_INT 35
7547: PPUSH
7548: CALL_OW 67
// until not HasTask ( unit ) ;
7552: LD_VAR 0 4
7556: PPUSH
7557: CALL_OW 314
7561: NOT
7562: IFFALSE 7545
// barrelsInArea = GetListOfCratesInArea ( ShootArea ) ;
7564: LD_ADDR_VAR 0 11
7568: PUSH
7569: LD_INT 12
7571: PPUSH
7572: CALL_OW 435
7576: ST_TO_ADDR
// for i := 1 to barrelsInArea / 2 do
7577: LD_ADDR_VAR 0 2
7581: PUSH
7582: DOUBLE
7583: LD_INT 1
7585: DEC
7586: ST_TO_ADDR
7587: LD_VAR 0 11
7591: PUSH
7592: LD_INT 2
7594: DIVREAL
7595: PUSH
7596: FOR_TO
7597: IFFALSE 7708
// begin if GetDistUnitXY ( unit , barrelsInArea [ i ] , barrelsInArea [ i + 1 ] ) <= 6 then
7599: LD_VAR 0 4
7603: PPUSH
7604: LD_VAR 0 11
7608: PUSH
7609: LD_VAR 0 2
7613: ARRAY
7614: PPUSH
7615: LD_VAR 0 11
7619: PUSH
7620: LD_VAR 0 2
7624: PUSH
7625: LD_INT 1
7627: PLUS
7628: ARRAY
7629: PPUSH
7630: CALL_OW 297
7634: PUSH
7635: LD_INT 6
7637: LESSEQUAL
7638: IFFALSE 7692
// begin AddComAttackPlace ( unit , barrelsInArea [ i ] , barrelsInArea [ i + 1 ] ) ;
7640: LD_VAR 0 4
7644: PPUSH
7645: LD_VAR 0 11
7649: PUSH
7650: LD_VAR 0 2
7654: ARRAY
7655: PPUSH
7656: LD_VAR 0 11
7660: PUSH
7661: LD_VAR 0 2
7665: PUSH
7666: LD_INT 1
7668: PLUS
7669: ARRAY
7670: PPUSH
7671: CALL_OW 176
// AddExperience ( unit , skill_combat , 5 ) ;
7675: LD_VAR 0 4
7679: PPUSH
7680: LD_INT 1
7682: PPUSH
7683: LD_INT 5
7685: PPUSH
7686: CALL_OW 492
// break ;
7690: GO 7708
// end ; i = i + 2 ;
7692: LD_ADDR_VAR 0 2
7696: PUSH
7697: LD_VAR 0 2
7701: PUSH
7702: LD_INT 2
7704: PLUS
7705: ST_TO_ADDR
// end ;
7706: GO 7596
7708: POP
7709: POP
// end ; end ;
7710: GO 7302
7712: POP
7713: POP
// end ;
7714: LD_VAR 0 1
7718: RET
// export function GoToHunt ( hunter ) ; var i , barracks , barrackTarget , barrackTargetCurrentHP , animals , animal ; begin
7719: LD_INT 0
7721: PPUSH
7722: PPUSH
7723: PPUSH
7724: PPUSH
7725: PPUSH
7726: PPUSH
7727: PPUSH
// animals = [ ] ;
7728: LD_ADDR_VAR 0 7
7732: PUSH
7733: EMPTY
7734: ST_TO_ADDR
// barracks = FilterAllUnits ( [ [ f_ok ] , [ f_not , [ f_constructed ] ] , [ f_or , [ f_btype , b_barracks ] , [ f_btype , b_armoury ] ] ] ) ;
7735: LD_ADDR_VAR 0 4
7739: PUSH
7740: LD_INT 50
7742: PUSH
7743: EMPTY
7744: LIST
7745: PUSH
7746: LD_INT 3
7748: PUSH
7749: LD_INT 57
7751: PUSH
7752: EMPTY
7753: LIST
7754: PUSH
7755: EMPTY
7756: LIST
7757: LIST
7758: PUSH
7759: LD_INT 2
7761: PUSH
7762: LD_INT 30
7764: PUSH
7765: LD_INT 5
7767: PUSH
7768: EMPTY
7769: LIST
7770: LIST
7771: PUSH
7772: LD_INT 30
7774: PUSH
7775: LD_INT 4
7777: PUSH
7778: EMPTY
7779: LIST
7780: LIST
7781: PUSH
7782: EMPTY
7783: LIST
7784: LIST
7785: LIST
7786: PUSH
7787: EMPTY
7788: LIST
7789: LIST
7790: LIST
7791: PPUSH
7792: CALL_OW 69
7796: ST_TO_ADDR
// SetSide ( hunter , 6 ) ;
7797: LD_VAR 0 1
7801: PPUSH
7802: LD_INT 6
7804: PPUSH
7805: CALL_OW 235
// if IsInUnit ( hunter ) then
7809: LD_VAR 0 1
7813: PPUSH
7814: CALL_OW 310
7818: IFFALSE 7860
// begin if GetBType ( IsInUnit ( hunter ) = unit_vehicle ) then
7820: LD_VAR 0 1
7824: PPUSH
7825: CALL_OW 310
7829: PUSH
7830: LD_INT 2
7832: EQUAL
7833: PPUSH
7834: CALL_OW 266
7838: IFFALSE 7851
// ComExitVehicle ( hunter ) else
7840: LD_VAR 0 1
7844: PPUSH
7845: CALL_OW 121
7849: GO 7860
// ComExitBuilding ( hunter ) ;
7851: LD_VAR 0 1
7855: PPUSH
7856: CALL_OW 122
// end ; ComWalk ( hunter ) ;
7860: LD_VAR 0 1
7864: PPUSH
7865: CALL_OW 138
// wait ( 0 0$1 ) ;
7869: LD_INT 35
7871: PPUSH
7872: CALL_OW 67
// if not GetClass ( hunter ) = class_soldier and barracks then
7876: LD_VAR 0 1
7880: PPUSH
7881: CALL_OW 257
7885: PUSH
7886: LD_INT 1
7888: EQUAL
7889: NOT
7890: PUSH
7891: LD_VAR 0 4
7895: AND
7896: IFFALSE 8039
// begin barrackTarget = barracks [ 1 ] ;
7898: LD_ADDR_VAR 0 5
7902: PUSH
7903: LD_VAR 0 4
7907: PUSH
7908: LD_INT 1
7910: ARRAY
7911: ST_TO_ADDR
// barrackTargetCurrentHP = GetLives ( barrackTarget ) ;
7912: LD_ADDR_VAR 0 6
7916: PUSH
7917: LD_VAR 0 5
7921: PPUSH
7922: CALL_OW 256
7926: ST_TO_ADDR
// SetSide ( barrackTarget , 6 ) ;
7927: LD_VAR 0 5
7931: PPUSH
7932: LD_INT 6
7934: PPUSH
7935: CALL_OW 235
// ComEnterUnit ( hunter , barrackTarget ) ;
7939: LD_VAR 0 1
7943: PPUSH
7944: LD_VAR 0 5
7948: PPUSH
7949: CALL_OW 120
// repeat wait ( 0 0$1 ) ;
7953: LD_INT 35
7955: PPUSH
7956: CALL_OW 67
// ComEnterUnit ( hunter , barrackTarget ) ;
7960: LD_VAR 0 1
7964: PPUSH
7965: LD_VAR 0 5
7969: PPUSH
7970: CALL_OW 120
// SetLives ( barrackTarget , barrackTargetCurrentHP ) ;
7974: LD_VAR 0 5
7978: PPUSH
7979: LD_VAR 0 6
7983: PPUSH
7984: CALL_OW 234
// until IsInUnit ( hunter ) ;
7988: LD_VAR 0 1
7992: PPUSH
7993: CALL_OW 310
7997: IFFALSE 7953
// SetClass ( hunter , class_soldier ) ;
7999: LD_VAR 0 1
8003: PPUSH
8004: LD_INT 1
8006: PPUSH
8007: CALL_OW 336
// ComExitBuilding ( hunter ) ;
8011: LD_VAR 0 1
8015: PPUSH
8016: CALL_OW 122
// SetSide ( barrackTarget , 3 ) ;
8020: LD_VAR 0 5
8024: PPUSH
8025: LD_INT 3
8027: PPUSH
8028: CALL_OW 235
// wait ( 0 0$1 ) ;
8032: LD_INT 35
8034: PPUSH
8035: CALL_OW 67
// end ; for i := 1 to 3 do
8039: LD_ADDR_VAR 0 3
8043: PUSH
8044: DOUBLE
8045: LD_INT 1
8047: DEC
8048: ST_TO_ADDR
8049: LD_INT 3
8051: PUSH
8052: FOR_TO
8053: IFFALSE 8158
// begin uc_side = 0 ;
8055: LD_ADDR_OWVAR 20
8059: PUSH
8060: LD_INT 0
8062: ST_TO_ADDR
// uc_nation = nation_nature ;
8063: LD_ADDR_OWVAR 21
8067: PUSH
8068: LD_INT 0
8070: ST_TO_ADDR
// PrepareHuman ( false , [ class_phororhacos , class_tiger , 21 ] [ Rand ( 1 , 3 ) ] , 0 ) ;
8071: LD_INT 0
8073: PPUSH
8074: LD_INT 18
8076: PUSH
8077: LD_INT 14
8079: PUSH
8080: LD_INT 21
8082: PUSH
8083: EMPTY
8084: LIST
8085: LIST
8086: LIST
8087: PUSH
8088: LD_INT 1
8090: PPUSH
8091: LD_INT 3
8093: PPUSH
8094: CALL_OW 12
8098: ARRAY
8099: PPUSH
8100: LD_INT 0
8102: PPUSH
8103: CALL_OW 380
// hc_agressivity = 0 ;
8107: LD_ADDR_OWVAR 35
8111: PUSH
8112: LD_INT 0
8114: ST_TO_ADDR
// animal = CreateHuman ;
8115: LD_ADDR_VAR 0 8
8119: PUSH
8120: CALL_OW 44
8124: ST_TO_ADDR
// PlaceUnitArea ( animal , NatureArea , false ) ;
8125: LD_VAR 0 8
8129: PPUSH
8130: LD_INT 5
8132: PPUSH
8133: LD_INT 0
8135: PPUSH
8136: CALL_OW 49
// animals = animals ^ animal ;
8140: LD_ADDR_VAR 0 7
8144: PUSH
8145: LD_VAR 0 7
8149: PUSH
8150: LD_VAR 0 8
8154: ADD
8155: ST_TO_ADDR
// end ;
8156: GO 8052
8158: POP
8159: POP
// for i := 1 to animals do
8160: LD_ADDR_VAR 0 3
8164: PUSH
8165: DOUBLE
8166: LD_INT 1
8168: DEC
8169: ST_TO_ADDR
8170: LD_VAR 0 7
8174: PUSH
8175: FOR_TO
8176: IFFALSE 8200
// AddComAttackUnit ( hunter , animals [ i ] ) ;
8178: LD_VAR 0 1
8182: PPUSH
8183: LD_VAR 0 7
8187: PUSH
8188: LD_VAR 0 3
8192: ARRAY
8193: PPUSH
8194: CALL_OW 175
8198: GO 8175
8200: POP
8201: POP
// repeat wait ( 0 0$1 ) ;
8202: LD_INT 35
8204: PPUSH
8205: CALL_OW 67
// if GetClass ( hunter ) = class_soldier then
8209: LD_VAR 0 1
8213: PPUSH
8214: CALL_OW 257
8218: PUSH
8219: LD_INT 1
8221: EQUAL
8222: IFFALSE 8269
// begin if GetDistUnits ( hunter , WantsToAttack ( hunter ) ) < 13 then
8224: LD_VAR 0 1
8228: PPUSH
8229: LD_VAR 0 1
8233: PPUSH
8234: CALL_OW 319
8238: PPUSH
8239: CALL_OW 296
8243: PUSH
8244: LD_INT 13
8246: LESS
8247: IFFALSE 8260
// ComCrawl ( hunter ) else
8249: LD_VAR 0 1
8253: PPUSH
8254: CALL_OW 137
8258: GO 8269
// ComWalk ( hunter ) ;
8260: LD_VAR 0 1
8264: PPUSH
8265: CALL_OW 138
// end ; until not HasTask ( hunter ) ;
8269: LD_VAR 0 1
8273: PPUSH
8274: CALL_OW 314
8278: NOT
8279: IFFALSE 8202
// repeat wait ( 0 0$1 ) ;
8281: LD_INT 35
8283: PPUSH
8284: CALL_OW 67
// ComMoveXY ( hunter , GetX ( Burlak ) , GetY ( Burlak ) ) ;
8288: LD_VAR 0 1
8292: PPUSH
8293: LD_EXP 57
8297: PPUSH
8298: CALL_OW 250
8302: PPUSH
8303: LD_EXP 57
8307: PPUSH
8308: CALL_OW 251
8312: PPUSH
8313: CALL_OW 111
// until GetDistUnits ( hunter , Burlak ) <= 9 ;
8317: LD_VAR 0 1
8321: PPUSH
8322: LD_EXP 57
8326: PPUSH
8327: CALL_OW 296
8331: PUSH
8332: LD_INT 9
8334: LESSEQUAL
8335: IFFALSE 8281
// SetSide ( hunter , 3 ) ;
8337: LD_VAR 0 1
8341: PPUSH
8342: LD_INT 3
8344: PPUSH
8345: CALL_OW 235
// CenterOnUnits ( hunter ) ;
8349: LD_VAR 0 1
8353: PPUSH
8354: CALL_OW 85
// AddExperience ( hunter , skill_combat , 3000 ) ;
8358: LD_VAR 0 1
8362: PPUSH
8363: LD_INT 1
8365: PPUSH
8366: LD_INT 3000
8368: PPUSH
8369: CALL_OW 492
// end ;
8373: LD_VAR 0 2
8377: RET
// export function SetMashaData ( vehicle ) ; begin
8378: LD_INT 0
8380: PPUSH
// if Masha then
8381: LD_EXP 4
8385: IFFALSE 8403
// SetMark ( Masha [ 1 ] , 0 ) ;
8387: LD_EXP 4
8391: PUSH
8392: LD_INT 1
8394: ARRAY
8395: PPUSH
8396: LD_INT 0
8398: PPUSH
8399: CALL_OW 242
// Masha = [ vehicle , GetChassis ( vehicle ) , GetEngine ( vehicle ) , GetControl ( vehicle ) , GetWeapon ( vehicle ) ] ;
8403: LD_ADDR_EXP 4
8407: PUSH
8408: LD_VAR 0 1
8412: PUSH
8413: LD_VAR 0 1
8417: PPUSH
8418: CALL_OW 265
8422: PUSH
8423: LD_VAR 0 1
8427: PPUSH
8428: CALL_OW 262
8432: PUSH
8433: LD_VAR 0 1
8437: PPUSH
8438: CALL_OW 263
8442: PUSH
8443: LD_VAR 0 1
8447: PPUSH
8448: CALL_OW 264
8452: PUSH
8453: EMPTY
8454: LIST
8455: LIST
8456: LIST
8457: LIST
8458: LIST
8459: ST_TO_ADDR
// ChangeMissionObjectives ( MMashaDone ) ;
8460: LD_STRING MMashaDone
8462: PPUSH
8463: CALL_OW 337
// SetMark ( vehicle , 1 ) ;
8467: LD_VAR 0 1
8471: PPUSH
8472: LD_INT 1
8474: PPUSH
8475: CALL_OW 242
// end ;
8479: LD_VAR 0 2
8483: RET
// export function SaveBase ( buildings , ident ) ; var i , buildingsToSave ; begin
8484: LD_INT 0
8486: PPUSH
8487: PPUSH
8488: PPUSH
// buildingsToSave = [ ] ;
8489: LD_ADDR_VAR 0 5
8493: PUSH
8494: EMPTY
8495: ST_TO_ADDR
// if not buildings then
8496: LD_VAR 0 1
8500: NOT
8501: IFFALSE 8505
// exit ;
8503: GO 9080
// for i in buildings do
8505: LD_ADDR_VAR 0 4
8509: PUSH
8510: LD_VAR 0 1
8514: PUSH
8515: FOR_IN
8516: IFFALSE 9064
// begin if GetBType ( i ) in [ b_lab , b_lab_half , b_lab_full ] then
8518: LD_VAR 0 4
8522: PPUSH
8523: CALL_OW 266
8527: PUSH
8528: LD_INT 6
8530: PUSH
8531: LD_INT 7
8533: PUSH
8534: LD_INT 8
8536: PUSH
8537: EMPTY
8538: LIST
8539: LIST
8540: LIST
8541: IN
8542: IFFALSE 8667
// buildingsToSave = buildingsToSave ^ [ [ GetBType ( i ) , GetX ( i ) , GetY ( i ) , GetDir ( i ) , GetBLevel ( i ) , GetNation ( i ) , GetLives ( i ) , GetLabKind ( i , 1 ) , GetLabKind ( i , 2 ) ] ] else
8544: LD_ADDR_VAR 0 5
8548: PUSH
8549: LD_VAR 0 5
8553: PUSH
8554: LD_VAR 0 4
8558: PPUSH
8559: CALL_OW 266
8563: PUSH
8564: LD_VAR 0 4
8568: PPUSH
8569: CALL_OW 250
8573: PUSH
8574: LD_VAR 0 4
8578: PPUSH
8579: CALL_OW 251
8583: PUSH
8584: LD_VAR 0 4
8588: PPUSH
8589: CALL_OW 254
8593: PUSH
8594: LD_VAR 0 4
8598: PPUSH
8599: CALL_OW 267
8603: PUSH
8604: LD_VAR 0 4
8608: PPUSH
8609: CALL_OW 248
8613: PUSH
8614: LD_VAR 0 4
8618: PPUSH
8619: CALL_OW 256
8623: PUSH
8624: LD_VAR 0 4
8628: PPUSH
8629: LD_INT 1
8631: PPUSH
8632: CALL_OW 268
8636: PUSH
8637: LD_VAR 0 4
8641: PPUSH
8642: LD_INT 2
8644: PPUSH
8645: CALL_OW 268
8649: PUSH
8650: EMPTY
8651: LIST
8652: LIST
8653: LIST
8654: LIST
8655: LIST
8656: LIST
8657: LIST
8658: LIST
8659: LIST
8660: PUSH
8661: EMPTY
8662: LIST
8663: ADD
8664: ST_TO_ADDR
8665: GO 9062
// if GetBType ( i ) in [ b_bunker , b_turret ] then
8667: LD_VAR 0 4
8671: PPUSH
8672: CALL_OW 266
8676: PUSH
8677: LD_INT 32
8679: PUSH
8680: LD_INT 33
8682: PUSH
8683: EMPTY
8684: LIST
8685: LIST
8686: IN
8687: IFFALSE 8795
// buildingsToSave = buildingsToSave ^ [ [ GetBType ( i ) , GetX ( i ) , GetY ( i ) , GetDir ( i ) , GetBLevel ( i ) , GetNation ( i ) , GetLives ( i ) , GetBWeapon ( i ) ] ] else
8689: LD_ADDR_VAR 0 5
8693: PUSH
8694: LD_VAR 0 5
8698: PUSH
8699: LD_VAR 0 4
8703: PPUSH
8704: CALL_OW 266
8708: PUSH
8709: LD_VAR 0 4
8713: PPUSH
8714: CALL_OW 250
8718: PUSH
8719: LD_VAR 0 4
8723: PPUSH
8724: CALL_OW 251
8728: PUSH
8729: LD_VAR 0 4
8733: PPUSH
8734: CALL_OW 254
8738: PUSH
8739: LD_VAR 0 4
8743: PPUSH
8744: CALL_OW 267
8748: PUSH
8749: LD_VAR 0 4
8753: PPUSH
8754: CALL_OW 248
8758: PUSH
8759: LD_VAR 0 4
8763: PPUSH
8764: CALL_OW 256
8768: PUSH
8769: LD_VAR 0 4
8773: PPUSH
8774: CALL_OW 269
8778: PUSH
8779: EMPTY
8780: LIST
8781: LIST
8782: LIST
8783: LIST
8784: LIST
8785: LIST
8786: LIST
8787: LIST
8788: PUSH
8789: EMPTY
8790: LIST
8791: ADD
8792: ST_TO_ADDR
8793: GO 9062
// if GetBType ( i ) in [ b_depot , b_warehouse ] then
8795: LD_VAR 0 4
8799: PPUSH
8800: CALL_OW 266
8804: PUSH
8805: LD_INT 0
8807: PUSH
8808: LD_INT 1
8810: PUSH
8811: EMPTY
8812: LIST
8813: LIST
8814: IN
8815: IFFALSE 8969
// buildingsToSave = buildingsToSave ^ [ [ GetBType ( i ) , GetX ( i ) , GetY ( i ) , GetDir ( i ) , GetBLevel ( i ) , GetNation ( i ) , GetLives ( i ) , GetResourceType ( GetBase ( i ) , mat_cans ) , GetResourceType ( GetBase ( i ) , mat_oil ) , GetResourceType ( GetBase ( i ) , mat_siberit ) ] ] else
8817: LD_ADDR_VAR 0 5
8821: PUSH
8822: LD_VAR 0 5
8826: PUSH
8827: LD_VAR 0 4
8831: PPUSH
8832: CALL_OW 266
8836: PUSH
8837: LD_VAR 0 4
8841: PPUSH
8842: CALL_OW 250
8846: PUSH
8847: LD_VAR 0 4
8851: PPUSH
8852: CALL_OW 251
8856: PUSH
8857: LD_VAR 0 4
8861: PPUSH
8862: CALL_OW 254
8866: PUSH
8867: LD_VAR 0 4
8871: PPUSH
8872: CALL_OW 267
8876: PUSH
8877: LD_VAR 0 4
8881: PPUSH
8882: CALL_OW 248
8886: PUSH
8887: LD_VAR 0 4
8891: PPUSH
8892: CALL_OW 256
8896: PUSH
8897: LD_VAR 0 4
8901: PPUSH
8902: CALL_OW 274
8906: PPUSH
8907: LD_INT 1
8909: PPUSH
8910: CALL_OW 275
8914: PUSH
8915: LD_VAR 0 4
8919: PPUSH
8920: CALL_OW 274
8924: PPUSH
8925: LD_INT 2
8927: PPUSH
8928: CALL_OW 275
8932: PUSH
8933: LD_VAR 0 4
8937: PPUSH
8938: CALL_OW 274
8942: PPUSH
8943: LD_INT 3
8945: PPUSH
8946: CALL_OW 275
8950: PUSH
8951: EMPTY
8952: LIST
8953: LIST
8954: LIST
8955: LIST
8956: LIST
8957: LIST
8958: LIST
8959: LIST
8960: LIST
8961: LIST
8962: PUSH
8963: EMPTY
8964: LIST
8965: ADD
8966: ST_TO_ADDR
8967: GO 9062
// buildingsToSave = buildingsToSave ^ [ [ GetBType ( i ) , GetX ( i ) , GetY ( i ) , GetDir ( i ) , GetBLevel ( i ) , GetNation ( i ) , GetLives ( i ) ] ] ;
8969: LD_ADDR_VAR 0 5
8973: PUSH
8974: LD_VAR 0 5
8978: PUSH
8979: LD_VAR 0 4
8983: PPUSH
8984: CALL_OW 266
8988: PUSH
8989: LD_VAR 0 4
8993: PPUSH
8994: CALL_OW 250
8998: PUSH
8999: LD_VAR 0 4
9003: PPUSH
9004: CALL_OW 251
9008: PUSH
9009: LD_VAR 0 4
9013: PPUSH
9014: CALL_OW 254
9018: PUSH
9019: LD_VAR 0 4
9023: PPUSH
9024: CALL_OW 267
9028: PUSH
9029: LD_VAR 0 4
9033: PPUSH
9034: CALL_OW 248
9038: PUSH
9039: LD_VAR 0 4
9043: PPUSH
9044: CALL_OW 256
9048: PUSH
9049: EMPTY
9050: LIST
9051: LIST
9052: LIST
9053: LIST
9054: LIST
9055: LIST
9056: LIST
9057: PUSH
9058: EMPTY
9059: LIST
9060: ADD
9061: ST_TO_ADDR
// end ;
9062: GO 8515
9064: POP
9065: POP
// SaveVariable ( buildingsToSave , ident ) ;
9066: LD_VAR 0 5
9070: PPUSH
9071: LD_VAR 0 2
9075: PPUSH
9076: CALL_OW 39
// end ; end_of_file
9080: LD_VAR 0 3
9084: RET
// export function MissionIntro ; begin
9085: LD_INT 0
9087: PPUSH
// CenterNowOnUnits ( Burlak ) ;
9088: LD_EXP 57
9092: PPUSH
9093: CALL_OW 87
// DialogueOn ;
9097: CALL_OW 6
// SayRadio ( Popov , DStart-Pop-1 ) ;
9101: LD_EXP 76
9105: PPUSH
9106: LD_STRING DStart-Pop-1
9108: PPUSH
9109: CALL_OW 94
// Say ( Burlak , DStart-Bur-1 ) ;
9113: LD_EXP 57
9117: PPUSH
9118: LD_STRING DStart-Bur-1
9120: PPUSH
9121: CALL_OW 88
// DialogueOff ;
9125: CALL_OW 7
// IngameOff ;
9129: CALL_OW 9
// ChangeMissionObjectives ( MStart ) ;
9133: LD_STRING MStart
9135: PPUSH
9136: CALL_OW 337
// SaveForQuickRestart ;
9140: CALL_OW 22
// end ;
9144: LD_VAR 0 1
9148: RET
// export function Dial_EscortHeike ( x , y ) ; begin
9149: LD_INT 0
9151: PPUSH
// dial_BuildDepotBlocker = true ;
9152: LD_ADDR_EXP 5
9156: PUSH
9157: LD_INT 1
9159: ST_TO_ADDR
// HeikeTargetX = x ;
9160: LD_ADDR_EXP 14
9164: PUSH
9165: LD_VAR 0 1
9169: ST_TO_ADDR
// HeikeTargetY = y ;
9170: LD_ADDR_EXP 15
9174: PUSH
9175: LD_VAR 0 2
9179: ST_TO_ADDR
// SayRadio ( Popov , DHeike-Pop-1 ) ;
9180: LD_EXP 76
9184: PPUSH
9185: LD_STRING DHeike-Pop-1
9187: PPUSH
9188: CALL_OW 94
// wait ( 0 0$10 ) ;
9192: LD_INT 350
9194: PPUSH
9195: CALL_OW 67
// PrepareRussianEscort ;
9199: CALL 2320 0 0
// PlaceUnitArea ( Heike , RussianSpawn2Area , false ) ;
9203: LD_EXP 79
9207: PPUSH
9208: LD_INT 7
9210: PPUSH
9211: LD_INT 0
9213: PPUSH
9214: CALL_OW 49
// ComMoveXY ( russianEscort , HeikeTargetX , HeikeTargetY ) ;
9218: LD_EXP 77
9222: PPUSH
9223: LD_EXP 14
9227: PPUSH
9228: LD_EXP 15
9232: PPUSH
9233: CALL_OW 111
// AddComMoveToArea ( russianEscort , RussianSpawn2Area ) ;
9237: LD_EXP 77
9241: PPUSH
9242: LD_INT 7
9244: PPUSH
9245: CALL_OW 173
// ComMoveXY ( Heike , HeikeTargetX , HeikeTargetY ) ;
9249: LD_EXP 79
9253: PPUSH
9254: LD_EXP 14
9258: PPUSH
9259: LD_EXP 15
9263: PPUSH
9264: CALL_OW 111
// AddComHold ( Heike ) ;
9268: LD_EXP 79
9272: PPUSH
9273: CALL_OW 200
// end ;
9277: LD_VAR 0 3
9281: RET
// every 1 trigger GetDistUnitXY ( Heike , HeikeTargetX , HeikeTargetY ) <= 5 do
9282: LD_EXP 79
9286: PPUSH
9287: LD_EXP 14
9291: PPUSH
9292: LD_EXP 15
9296: PPUSH
9297: CALL_OW 297
9301: PUSH
9302: LD_INT 5
9304: LESSEQUAL
9305: IFFALSE 9318
9307: GO 9309
9309: DISABLE
// allowExitFromMap = 1 ;
9310: LD_ADDR_EXP 18
9314: PUSH
9315: LD_INT 1
9317: ST_TO_ADDR
9318: END
// every 7 7$0 trigger IsPlaced ( Heike ) and IsOk ( Heike ) and GetAttitude ( 3 , 5 ) = att_friend and HeikeCaptured do
9319: LD_EXP 79
9323: PPUSH
9324: CALL_OW 305
9328: PUSH
9329: LD_EXP 79
9333: PPUSH
9334: CALL_OW 302
9338: AND
9339: PUSH
9340: LD_INT 3
9342: PPUSH
9343: LD_INT 5
9345: PPUSH
9346: CALL_OW 81
9350: PUSH
9351: LD_INT 1
9353: EQUAL
9354: AND
9355: PUSH
9356: LD_EXP 1
9360: AND
9361: IFFALSE 9580
9363: GO 9365
9365: DISABLE
// begin DialogueOn ;
9366: CALL_OW 6
// SayRadio ( Kurt , DMercHelp-Kurt-1 ) ;
9370: LD_EXP 80
9374: PPUSH
9375: LD_STRING DMercHelp-Kurt-1
9377: PPUSH
9378: CALL_OW 94
// Say ( Burlak , DMercHelp-Bur-1 ) ;
9382: LD_EXP 57
9386: PPUSH
9387: LD_STRING DMercHelp-Bur-1
9389: PPUSH
9390: CALL_OW 88
// SayRadio ( Kurt , DMercHelp-Kurt-2 ) ;
9394: LD_EXP 80
9398: PPUSH
9399: LD_STRING DMercHelp-Kurt-2
9401: PPUSH
9402: CALL_OW 94
// Say ( Burlak , DMercHelp-Bur-2 ) ;
9406: LD_EXP 57
9410: PPUSH
9411: LD_STRING DMercHelp-Bur-2
9413: PPUSH
9414: CALL_OW 88
// SayRadio ( Kurt , DMercHelp-Kurt-3 ) ;
9418: LD_EXP 80
9422: PPUSH
9423: LD_STRING DMercHelp-Kurt-3
9425: PPUSH
9426: CALL_OW 94
// case Query ( QMerc ) of 1 :
9430: LD_STRING QMerc
9432: PPUSH
9433: CALL_OW 97
9437: PUSH
9438: LD_INT 1
9440: DOUBLE
9441: EQUAL
9442: IFTRUE 9446
9444: GO 9481
9446: POP
// begin Say ( Burlak , DQrMerc#1-Bur-1 ) ;
9447: LD_EXP 57
9451: PPUSH
9452: LD_STRING DQrMerc#1-Bur-1
9454: PPUSH
9455: CALL_OW 88
// SayRadio ( Kurt , DQrMerc#1-Kurt-1 ) ;
9459: LD_EXP 80
9463: PPUSH
9464: LD_STRING DQrMerc#1-Kurt-1
9466: PPUSH
9467: CALL_OW 94
// acceptKurtOffert = true ;
9471: LD_ADDR_EXP 19
9475: PUSH
9476: LD_INT 1
9478: ST_TO_ADDR
// end ; 2 :
9479: GO 9576
9481: LD_INT 2
9483: DOUBLE
9484: EQUAL
9485: IFTRUE 9489
9487: GO 9544
9489: POP
// begin askCommanders = true ;
9490: LD_ADDR_EXP 20
9494: PUSH
9495: LD_INT 1
9497: ST_TO_ADDR
// Say ( Burlak , DQrMerc#2-Bur-1 ) ;
9498: LD_EXP 57
9502: PPUSH
9503: LD_STRING DQrMerc#2-Bur-1
9505: PPUSH
9506: CALL_OW 88
// SayRadio ( Popov , DQrMerc#2-Pop-1 ) ;
9510: LD_EXP 76
9514: PPUSH
9515: LD_STRING DQrMerc#2-Pop-1
9517: PPUSH
9518: CALL_OW 94
// Say ( Burlak , DQrMerc#2-Bur-2 ) ;
9522: LD_EXP 57
9526: PPUSH
9527: LD_STRING DQrMerc#2-Bur-2
9529: PPUSH
9530: CALL_OW 88
// acceptKurtOffert = true ;
9534: LD_ADDR_EXP 19
9538: PUSH
9539: LD_INT 1
9541: ST_TO_ADDR
// end ; 3 :
9542: GO 9576
9544: LD_INT 3
9546: DOUBLE
9547: EQUAL
9548: IFTRUE 9552
9550: GO 9575
9552: POP
// begin Say ( Burlak , DQrMerc#3-Bur-1 ) ;
9553: LD_EXP 57
9557: PPUSH
9558: LD_STRING DQrMerc#3-Bur-1
9560: PPUSH
9561: CALL_OW 88
// KurtAttack = true ;
9565: LD_ADDR_EXP 25
9569: PUSH
9570: LD_INT 1
9572: ST_TO_ADDR
// end ; end ;
9573: GO 9576
9575: POP
// DialogueOff ;
9576: CALL_OW 7
// end ;
9580: END
// every 0 0$1 trigger acceptKurtOffert do
9581: LD_EXP 19
9585: IFFALSE 9741
9587: GO 9589
9589: DISABLE
// begin PlaceUnitArea ( Kurt , KurtSpawnArea , false ) ;
9590: LD_EXP 80
9594: PPUSH
9595: LD_INT 9
9597: PPUSH
9598: LD_INT 0
9600: PPUSH
9601: CALL_OW 49
// uc_side = 8 ;
9605: LD_ADDR_OWVAR 20
9609: PUSH
9610: LD_INT 8
9612: ST_TO_ADDR
// uc_nation = 2 ;
9613: LD_ADDR_OWVAR 21
9617: PUSH
9618: LD_INT 2
9620: ST_TO_ADDR
// PrepareEngineer ( false , 3 ) ;
9621: LD_INT 0
9623: PPUSH
9624: LD_INT 3
9626: PPUSH
9627: CALL_OW 382
// KurtEng = CreateHuman ;
9631: LD_ADDR_EXP 82
9635: PUSH
9636: CALL_OW 44
9640: ST_TO_ADDR
// PlaceUnitArea ( KurtEng , KurtSpawnArea , false ) ;
9641: LD_EXP 82
9645: PPUSH
9646: LD_INT 9
9648: PPUSH
9649: LD_INT 0
9651: PPUSH
9652: CALL_OW 49
// repeat wait ( 0 0$1 ) ;
9656: LD_INT 35
9658: PPUSH
9659: CALL_OW 67
// ComMoveXY ( [ Kurt , KurtEng ] , GetX ( Burlak ) , GetY ( Burlak ) ) ;
9663: LD_EXP 80
9667: PUSH
9668: LD_EXP 82
9672: PUSH
9673: EMPTY
9674: LIST
9675: LIST
9676: PPUSH
9677: LD_EXP 57
9681: PPUSH
9682: CALL_OW 250
9686: PPUSH
9687: LD_EXP 57
9691: PPUSH
9692: CALL_OW 251
9696: PPUSH
9697: CALL_OW 111
// until GetDistUnits ( Kurt , Burlak ) <= 5 or GetDistUnits ( KurtEng , Burlak ) <= 5 ;
9701: LD_EXP 80
9705: PPUSH
9706: LD_EXP 57
9710: PPUSH
9711: CALL_OW 296
9715: PUSH
9716: LD_INT 5
9718: LESSEQUAL
9719: PUSH
9720: LD_EXP 82
9724: PPUSH
9725: LD_EXP 57
9729: PPUSH
9730: CALL_OW 296
9734: PUSH
9735: LD_INT 5
9737: LESSEQUAL
9738: OR
9739: IFFALSE 9656
// end ;
9741: END
// every 0 0$1 trigger GetDistUnits ( Kurt , Burlak ) <= 5 or GetDistUnits ( KurtEng , Burlak ) <= 5 do
9742: LD_EXP 80
9746: PPUSH
9747: LD_EXP 57
9751: PPUSH
9752: CALL_OW 296
9756: PUSH
9757: LD_INT 5
9759: LESSEQUAL
9760: PUSH
9761: LD_EXP 82
9765: PPUSH
9766: LD_EXP 57
9770: PPUSH
9771: CALL_OW 296
9775: PUSH
9776: LD_INT 5
9778: LESSEQUAL
9779: OR
9780: IFFALSE 9959
9782: GO 9784
9784: DISABLE
// begin KurtWaitingForBuildBarrack = true ;
9785: LD_ADDR_EXP 24
9789: PUSH
9790: LD_INT 1
9792: ST_TO_ADDR
// SetSide ( KurtEng , 3 ) ;
9793: LD_EXP 82
9797: PPUSH
9798: LD_INT 3
9800: PPUSH
9801: CALL_OW 235
// wait ( 1 1$30 ) ;
9805: LD_INT 3150
9807: PPUSH
9808: CALL_OW 67
// DialogueOn ;
9812: CALL_OW 6
// SayRadio ( Dietrich , DArabianRequest-Diet-1 ) ;
9816: LD_EXP 81
9820: PPUSH
9821: LD_STRING DArabianRequest-Diet-1
9823: PPUSH
9824: CALL_OW 94
// Say ( Burlak , DArabianRequest-Bur-1 ) ;
9828: LD_EXP 57
9832: PPUSH
9833: LD_STRING DArabianRequest-Bur-1
9835: PPUSH
9836: CALL_OW 88
// SayRadio ( Dietrich , DArabianRequest-Diet-2 ) ;
9840: LD_EXP 81
9844: PPUSH
9845: LD_STRING DArabianRequest-Diet-2
9847: PPUSH
9848: CALL_OW 94
// DialogueOff ;
9852: CALL_OW 7
// case Query ( QHandOver ) of 1 :
9856: LD_STRING QHandOver
9858: PPUSH
9859: CALL_OW 97
9863: PUSH
9864: LD_INT 1
9866: DOUBLE
9867: EQUAL
9868: IFTRUE 9872
9870: GO 9911
9872: POP
// begin Say ( Burlak , DQrHandOver#1-Bur-1 ) ;
9873: LD_EXP 57
9877: PPUSH
9878: LD_STRING DQrHandOver#1-Bur-1
9880: PPUSH
9881: CALL_OW 88
// SayRadio ( Dietrich , DQrHandOver#1-Diet-1 ) ;
9885: LD_EXP 81
9889: PPUSH
9890: LD_STRING DQrHandOver#1-Diet-1
9892: PPUSH
9893: CALL_OW 94
// coopWithGensher = true ;
9897: LD_ADDR_EXP 2
9901: PUSH
9902: LD_INT 1
9904: ST_TO_ADDR
// SpawnGensherTeam ;
9905: CALL 3946 0 0
// end ; 2 :
9909: GO 9959
9911: LD_INT 2
9913: DOUBLE
9914: EQUAL
9915: IFTRUE 9919
9917: GO 9958
9919: POP
// begin Say ( Burlak , DQrHandOver#2-Bur-1 ) ;
9920: LD_EXP 57
9924: PPUSH
9925: LD_STRING DQrHandOver#2-Bur-1
9927: PPUSH
9928: CALL_OW 88
// SayRadio ( Dietrich , DQrHandOver#2-Diet-1 ) ;
9932: LD_EXP 81
9936: PPUSH
9937: LD_STRING DQrHandOver#2-Diet-1
9939: PPUSH
9940: CALL_OW 94
// Say ( Burlak , DQrHandOver#2-Bur-2 ) ;
9944: LD_EXP 57
9948: PPUSH
9949: LD_STRING DQrHandOver#2-Bur-2
9951: PPUSH
9952: CALL_OW 88
// end ; end ;
9956: GO 9959
9958: POP
// end ;
9959: END
// export function Dial_UpgradeArmoury ; begin
9960: LD_INT 0
9962: PPUSH
// dial_BuildArBarrackBlocker = true ;
9963: LD_ADDR_EXP 6
9967: PUSH
9968: LD_INT 1
9970: ST_TO_ADDR
// buildArabBarrack = true ;
9971: LD_ADDR_EXP 38
9975: PUSH
9976: LD_INT 1
9978: ST_TO_ADDR
// if GetSide ( Kurt ) = 2 or GetSide ( KurtEng ) = 8 then
9979: LD_EXP 80
9983: PPUSH
9984: CALL_OW 255
9988: PUSH
9989: LD_INT 2
9991: EQUAL
9992: PUSH
9993: LD_EXP 82
9997: PPUSH
9998: CALL_OW 255
10002: PUSH
10003: LD_INT 8
10005: EQUAL
10006: OR
10007: IFFALSE 10011
// exit ;
10009: GO 10111
// SetSide ( KurtEng , 8 ) ;
10011: LD_EXP 82
10015: PPUSH
10016: LD_INT 8
10018: PPUSH
10019: CALL_OW 235
// ComStop ( KurtEng ) ;
10023: LD_EXP 82
10027: PPUSH
10028: CALL_OW 141
// DialogueOn ;
10032: CALL_OW 6
// Say ( Kurt , DMercCompleted-Kurt-1 ) ;
10036: LD_EXP 80
10040: PPUSH
10041: LD_STRING DMercCompleted-Kurt-1
10043: PPUSH
10044: CALL_OW 88
// DialogueOff ;
10048: CALL_OW 7
// canSendHeike = true ;
10052: LD_ADDR_EXP 28
10056: PUSH
10057: LD_INT 1
10059: ST_TO_ADDR
// KurtWaitingForFreeHeike = true ;
10060: LD_ADDR_EXP 23
10064: PUSH
10065: LD_INT 1
10067: ST_TO_ADDR
// KurtWaitingForBuildBarrack = false ;
10068: LD_ADDR_EXP 24
10072: PUSH
10073: LD_INT 0
10075: ST_TO_ADDR
// allowExitFromMap = 3 ;
10076: LD_ADDR_EXP 18
10080: PUSH
10081: LD_INT 3
10083: ST_TO_ADDR
// if KurtCanEscape then
10084: LD_EXP 21
10088: IFFALSE 10111
// ComMoveToArea ( [ Kurt , KurtEng ] , KurtExitMapArea ) ;
10090: LD_EXP 80
10094: PUSH
10095: LD_EXP 82
10099: PUSH
10100: EMPTY
10101: LIST
10102: LIST
10103: PPUSH
10104: LD_INT 11
10106: PPUSH
10107: CALL_OW 113
// end ;
10111: LD_VAR 0 1
10115: RET
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 2 ] ] ) and not dial_ArriveGensherUnitsBlocker do var veh , nearGensherUnit , maleSold , waitForKurt ;
10116: LD_INT 22
10118: PUSH
10119: LD_INT 2
10121: PUSH
10122: EMPTY
10123: LIST
10124: LIST
10125: PUSH
10126: EMPTY
10127: LIST
10128: PPUSH
10129: CALL_OW 69
10133: PUSH
10134: LD_EXP 7
10138: NOT
10139: AND
10140: IFFALSE 10913
10142: GO 10144
10144: DISABLE
10145: LD_INT 0
10147: PPUSH
10148: PPUSH
10149: PPUSH
10150: PPUSH
// begin nearGensherUnit = NearestUnitToXY ( UnitFilter ( GensherTeam , [ [ f_type , unit_vehicle ] ] ) , GensherTargetX , GensherTargetY ) ;
10151: LD_ADDR_VAR 0 2
10155: PUSH
10156: LD_EXP 83
10160: PPUSH
10161: LD_INT 21
10163: PUSH
10164: LD_INT 2
10166: PUSH
10167: EMPTY
10168: LIST
10169: LIST
10170: PUSH
10171: EMPTY
10172: LIST
10173: PPUSH
10174: CALL_OW 72
10178: PPUSH
10179: LD_EXP 16
10183: PPUSH
10184: LD_EXP 17
10188: PPUSH
10189: CALL_OW 73
10193: ST_TO_ADDR
// maleSold = UnitsInside ( nearGensherUnit [ 1 ] ) ;
10194: LD_ADDR_VAR 0 3
10198: PUSH
10199: LD_VAR 0 2
10203: PUSH
10204: LD_INT 1
10206: ARRAY
10207: PPUSH
10208: CALL_OW 313
10212: ST_TO_ADDR
// if GetDistUnitXY ( nearGensherUnit , GensherTargetX , GensherTargetY ) <= 5 then
10213: LD_VAR 0 2
10217: PPUSH
10218: LD_EXP 16
10222: PPUSH
10223: LD_EXP 17
10227: PPUSH
10228: CALL_OW 297
10232: PUSH
10233: LD_INT 5
10235: LESSEQUAL
10236: IFFALSE 10912
// begin dial_ArriveGensherUnitsBlocker = true ;
10238: LD_ADDR_EXP 7
10242: PUSH
10243: LD_INT 1
10245: ST_TO_ADDR
// for veh in UnitFilter ( GensherTeam , [ [ f_type , unit_vehicle ] ] ) do
10246: LD_ADDR_VAR 0 1
10250: PUSH
10251: LD_EXP 83
10255: PPUSH
10256: LD_INT 21
10258: PUSH
10259: LD_INT 2
10261: PUSH
10262: EMPTY
10263: LIST
10264: LIST
10265: PUSH
10266: EMPTY
10267: LIST
10268: PPUSH
10269: CALL_OW 72
10273: PUSH
10274: FOR_IN
10275: IFFALSE 10297
// ComExitVehicle ( UnitsInside ( veh ) [ 1 ] ) ;
10277: LD_VAR 0 1
10281: PPUSH
10282: CALL_OW 313
10286: PUSH
10287: LD_INT 1
10289: ARRAY
10290: PPUSH
10291: CALL_OW 121
10295: GO 10274
10297: POP
10298: POP
// wait ( 0 0$1 ) ;
10299: LD_INT 35
10301: PPUSH
10302: CALL_OW 67
// SetSide ( UnitFilter ( GensherTeam , [ [ f_type , unit_vehicle ] ] ) , 3 ) ;
10306: LD_EXP 83
10310: PPUSH
10311: LD_INT 21
10313: PUSH
10314: LD_INT 2
10316: PUSH
10317: EMPTY
10318: LIST
10319: LIST
10320: PUSH
10321: EMPTY
10322: LIST
10323: PPUSH
10324: CALL_OW 72
10328: PPUSH
10329: LD_INT 3
10331: PPUSH
10332: CALL_OW 235
// CenterOnUnits ( maleSold ) ;
10336: LD_VAR 0 3
10340: PPUSH
10341: CALL_OW 85
// DialogueOn ;
10345: CALL_OW 6
// Say ( maleSold , DHandOverCome-ASol1-1 ) ;
10349: LD_VAR 0 3
10353: PPUSH
10354: LD_STRING DHandOverCome-ASol1-1
10356: PPUSH
10357: CALL_OW 88
// Say ( Kurt , DHandOverCome-Kurt-1 ) ;
10361: LD_EXP 80
10365: PPUSH
10366: LD_STRING DHandOverCome-Kurt-1
10368: PPUSH
10369: CALL_OW 88
// DialogueOff ;
10373: CALL_OW 7
// KurtWaitingForBuildBarrack = false ;
10377: LD_ADDR_EXP 24
10381: PUSH
10382: LD_INT 0
10384: ST_TO_ADDR
// if GetDistUnits ( Kurt , UnitFilter ( GensherTeam , [ f_type , unit_vehicle ] ) [ 1 ] ) <= 8 or GetSide ( KurtEng ) = 3 then
10385: LD_EXP 80
10389: PPUSH
10390: LD_EXP 83
10394: PPUSH
10395: LD_INT 21
10397: PUSH
10398: LD_INT 2
10400: PUSH
10401: EMPTY
10402: LIST
10403: LIST
10404: PPUSH
10405: CALL_OW 72
10409: PUSH
10410: LD_INT 1
10412: ARRAY
10413: PPUSH
10414: CALL_OW 296
10418: PUSH
10419: LD_INT 8
10421: LESSEQUAL
10422: PUSH
10423: LD_EXP 82
10427: PPUSH
10428: CALL_OW 255
10432: PUSH
10433: LD_INT 3
10435: EQUAL
10436: OR
10437: IFFALSE 10542
// begin KurtCanEscape = false ;
10439: LD_ADDR_EXP 21
10443: PUSH
10444: LD_INT 0
10446: ST_TO_ADDR
// SetSide ( [ Kurt , KurtEng ] , 2 ) ;
10447: LD_EXP 80
10451: PUSH
10452: LD_EXP 82
10456: PUSH
10457: EMPTY
10458: LIST
10459: LIST
10460: PPUSH
10461: LD_INT 2
10463: PPUSH
10464: CALL_OW 235
// ComStop ( [ Kurt , KurtEng ] ) ;
10468: LD_EXP 80
10472: PUSH
10473: LD_EXP 82
10477: PUSH
10478: EMPTY
10479: LIST
10480: LIST
10481: PPUSH
10482: CALL_OW 141
// ComMoveXY ( [ Kurt , KurtEng ] , GetX ( maleSold ) , GetY ( maleSold ) ) ;
10486: LD_EXP 80
10490: PUSH
10491: LD_EXP 82
10495: PUSH
10496: EMPTY
10497: LIST
10498: LIST
10499: PPUSH
10500: LD_VAR 0 3
10504: PPUSH
10505: CALL_OW 250
10509: PPUSH
10510: LD_VAR 0 3
10514: PPUSH
10515: CALL_OW 251
10519: PPUSH
10520: CALL_OW 111
// waitForKurt = true ;
10524: LD_ADDR_VAR 0 4
10528: PUSH
10529: LD_INT 1
10531: ST_TO_ADDR
// KurtStatus = 3 ;
10532: LD_ADDR_EXP 22
10536: PUSH
10537: LD_INT 3
10539: ST_TO_ADDR
// end else
10540: GO 10780
// if GetDistUnits ( Kurt , UnitFilter ( GensherTeam , [ f_type , unit_vehicle ] ) [ 1 ] ) > 8 then
10542: LD_EXP 80
10546: PPUSH
10547: LD_EXP 83
10551: PPUSH
10552: LD_INT 21
10554: PUSH
10555: LD_INT 2
10557: PUSH
10558: EMPTY
10559: LIST
10560: LIST
10561: PPUSH
10562: CALL_OW 72
10566: PUSH
10567: LD_INT 1
10569: ARRAY
10570: PPUSH
10571: CALL_OW 296
10575: PUSH
10576: LD_INT 8
10578: GREATER
10579: IFFALSE 10780
// begin allowExitFromMap = 4 ;
10581: LD_ADDR_EXP 18
10585: PUSH
10586: LD_INT 4
10588: ST_TO_ADDR
// KurtStatus = 2 ;
10589: LD_ADDR_EXP 22
10593: PUSH
10594: LD_INT 2
10596: ST_TO_ADDR
// ComMoveToArea ( [ Kurt , KurtEng ] , KurtExitMapArea ) ;
10597: LD_EXP 80
10601: PUSH
10602: LD_EXP 82
10606: PUSH
10607: EMPTY
10608: LIST
10609: LIST
10610: PPUSH
10611: LD_INT 11
10613: PPUSH
10614: CALL_OW 113
// repeat ComAttackUnit ( UnitFilter ( GensherTeam , [ [ f_type , unit_human ] ] ) , Kurt ) ;
10618: LD_EXP 83
10622: PPUSH
10623: LD_INT 21
10625: PUSH
10626: LD_INT 1
10628: PUSH
10629: EMPTY
10630: LIST
10631: LIST
10632: PUSH
10633: EMPTY
10634: LIST
10635: PPUSH
10636: CALL_OW 72
10640: PPUSH
10641: LD_EXP 80
10645: PPUSH
10646: CALL_OW 115
// wait ( 0 0$1 ) ;
10650: LD_INT 35
10652: PPUSH
10653: CALL_OW 67
// until GetDistUnits ( NearestUnitToUnit ( UnitFilter ( GensherTeam , [ [ f_type , unit_human ] ] ) , Kurt ) , Kurt ) <= 9 or ( not IsPlaced ( Kurt ) and not IsPlaced ( KurtEng ) ) ;
10657: LD_EXP 83
10661: PPUSH
10662: LD_INT 21
10664: PUSH
10665: LD_INT 1
10667: PUSH
10668: EMPTY
10669: LIST
10670: LIST
10671: PUSH
10672: EMPTY
10673: LIST
10674: PPUSH
10675: CALL_OW 72
10679: PPUSH
10680: LD_EXP 80
10684: PPUSH
10685: CALL_OW 74
10689: PPUSH
10690: LD_EXP 80
10694: PPUSH
10695: CALL_OW 296
10699: PUSH
10700: LD_INT 9
10702: LESSEQUAL
10703: PUSH
10704: LD_EXP 80
10708: PPUSH
10709: CALL_OW 305
10713: NOT
10714: PUSH
10715: LD_EXP 82
10719: PPUSH
10720: CALL_OW 305
10724: NOT
10725: AND
10726: OR
10727: IFFALSE 10618
// ComMoveToArea ( [ Kurt , KurtEng ] , ExitMapArea ) ;
10729: LD_EXP 80
10733: PUSH
10734: LD_EXP 82
10738: PUSH
10739: EMPTY
10740: LIST
10741: LIST
10742: PPUSH
10743: LD_INT 8
10745: PPUSH
10746: CALL_OW 113
// ComMoveToArea ( UnitFilter ( GensherTeam , [ [ f_type , unit_human ] ] ) , ExitMapArea ) ;
10750: LD_EXP 83
10754: PPUSH
10755: LD_INT 21
10757: PUSH
10758: LD_INT 1
10760: PUSH
10761: EMPTY
10762: LIST
10763: LIST
10764: PUSH
10765: EMPTY
10766: LIST
10767: PPUSH
10768: CALL_OW 72
10772: PPUSH
10773: LD_INT 8
10775: PPUSH
10776: CALL_OW 113
// end ; if waitForKurt then
10780: LD_VAR 0 4
10784: IFFALSE 10910
// begin repeat wait ( 0 0$1 ) ;
10786: LD_INT 35
10788: PPUSH
10789: CALL_OW 67
// ComMoveXY ( [ Kurt , KurtEng ] , GetX ( maleSold ) , GetY ( maleSold ) ) ;
10793: LD_EXP 80
10797: PUSH
10798: LD_EXP 82
10802: PUSH
10803: EMPTY
10804: LIST
10805: LIST
10806: PPUSH
10807: LD_VAR 0 3
10811: PPUSH
10812: CALL_OW 250
10816: PPUSH
10817: LD_VAR 0 3
10821: PPUSH
10822: CALL_OW 251
10826: PPUSH
10827: CALL_OW 111
// until GetDistUnits ( Kurt , maleSold ) <= 2 ;
10831: LD_EXP 80
10835: PPUSH
10836: LD_VAR 0 3
10840: PPUSH
10841: CALL_OW 296
10845: PUSH
10846: LD_INT 2
10848: LESSEQUAL
10849: IFFALSE 10786
// allowExitFromMap = 4 ;
10851: LD_ADDR_EXP 18
10855: PUSH
10856: LD_INT 4
10858: ST_TO_ADDR
// ComMoveToArea ( [ Kurt , KurtEng ] , ExitMapArea ) ;
10859: LD_EXP 80
10863: PUSH
10864: LD_EXP 82
10868: PUSH
10869: EMPTY
10870: LIST
10871: LIST
10872: PPUSH
10873: LD_INT 8
10875: PPUSH
10876: CALL_OW 113
// ComMoveToArea ( UnitFilter ( GensherTeam , [ [ f_type , unit_human ] ] ) , ExitMapArea ) ;
10880: LD_EXP 83
10884: PPUSH
10885: LD_INT 21
10887: PUSH
10888: LD_INT 1
10890: PUSH
10891: EMPTY
10892: LIST
10893: LIST
10894: PUSH
10895: EMPTY
10896: LIST
10897: PPUSH
10898: CALL_OW 72
10902: PPUSH
10903: LD_INT 8
10905: PPUSH
10906: CALL_OW 113
// end ; exit ;
10910: GO 10913
// end ; enable ;
10912: ENABLE
// end ;
10913: PPOPN 4
10915: END
// export function Dial_AttackGensher ; var unit ; begin
10916: LD_INT 0
10918: PPUSH
10919: PPUSH
// DialogueOn ;
10920: CALL_OW 6
// SayRadio ( Dietrich , DHandOverSpoiled-Diet-1 ) ;
10924: LD_EXP 81
10928: PPUSH
10929: LD_STRING DHandOverSpoiled-Diet-1
10931: PPUSH
10932: CALL_OW 94
// DialogueOff ;
10936: CALL_OW 7
// SetAttitude ( 3 , 2 , att_enemy , true ) ;
10940: LD_INT 3
10942: PPUSH
10943: LD_INT 2
10945: PPUSH
10946: LD_INT 2
10948: PPUSH
10949: LD_INT 1
10951: PPUSH
10952: CALL_OW 80
// for unit in UnitFilter ( GensherTeam , [ [ f_type , unit_human ] ] ) do
10956: LD_ADDR_VAR 0 2
10960: PUSH
10961: LD_EXP 83
10965: PPUSH
10966: LD_INT 21
10968: PUSH
10969: LD_INT 1
10971: PUSH
10972: EMPTY
10973: LIST
10974: LIST
10975: PUSH
10976: EMPTY
10977: LIST
10978: PPUSH
10979: CALL_OW 72
10983: PUSH
10984: FOR_IN
10985: IFFALSE 11045
// begin if IsInUnit ( unit ) then
10987: LD_VAR 0 2
10991: PPUSH
10992: CALL_OW 310
10996: IFFALSE 11007
// ComExitVehicle ( unit ) ;
10998: LD_VAR 0 2
11002: PPUSH
11003: CALL_OW 121
// wait ( 0 0$01 ) ;
11007: LD_INT 35
11009: PPUSH
11010: CALL_OW 67
// AddComAgressiveMove ( unit , GetX ( Burlak ) , GetY ( Burlak ) ) ;
11014: LD_VAR 0 2
11018: PPUSH
11019: LD_EXP 57
11023: PPUSH
11024: CALL_OW 250
11028: PPUSH
11029: LD_EXP 57
11033: PPUSH
11034: CALL_OW 251
11038: PPUSH
11039: CALL_OW 174
// end ;
11043: GO 10984
11045: POP
11046: POP
// coopWithGensher = 2 ;
11047: LD_ADDR_EXP 2
11051: PUSH
11052: LD_INT 2
11054: ST_TO_ADDR
// end ;
11055: LD_VAR 0 1
11059: RET
// every 0 0$1 trigger canSendHeike and IsOK ( Heike ) and GetSide ( Heike ) = 5 do var legionSold ;
11060: LD_EXP 28
11064: PUSH
11065: LD_EXP 79
11069: PPUSH
11070: CALL_OW 302
11074: AND
11075: PUSH
11076: LD_EXP 79
11080: PPUSH
11081: CALL_OW 255
11085: PUSH
11086: LD_INT 5
11088: EQUAL
11089: AND
11090: IFFALSE 11410
11092: GO 11094
11094: DISABLE
11095: LD_INT 0
11097: PPUSH
// begin if IsSelected ( Heike ) then
11098: LD_EXP 79
11102: PPUSH
11103: CALL_OW 306
11107: IFFALSE 11402
// begin if Query ( QSendHeike ) = 1 then
11109: LD_STRING QSendHeike
11111: PPUSH
11112: CALL_OW 97
11116: PUSH
11117: LD_INT 1
11119: EQUAL
11120: IFFALSE 11402
// begin KurtWaitingForFreeHeike = false ;
11122: LD_ADDR_EXP 23
11126: PUSH
11127: LD_INT 0
11129: ST_TO_ADDR
// ComMoveXY ( Heike , 82 , 46 ) ;
11130: LD_EXP 79
11134: PPUSH
11135: LD_INT 82
11137: PPUSH
11138: LD_INT 46
11140: PPUSH
11141: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
11145: LD_INT 35
11147: PPUSH
11148: CALL_OW 67
// until GetDistUnitXY ( Heike , 82 , 46 ) <= 5 or IsDead ( Heike ) ;
11152: LD_EXP 79
11156: PPUSH
11157: LD_INT 82
11159: PPUSH
11160: LD_INT 46
11162: PPUSH
11163: CALL_OW 297
11167: PUSH
11168: LD_INT 5
11170: LESSEQUAL
11171: PUSH
11172: LD_EXP 79
11176: PPUSH
11177: CALL_OW 301
11181: OR
11182: IFFALSE 11145
// if not askCommanders then
11184: LD_EXP 20
11188: NOT
11189: IFFALSE 11235
// begin DialogueOn ;
11191: CALL_OW 6
// SayRadio ( Popov , DMercPopov-Pop-1 ) ;
11195: LD_EXP 76
11199: PPUSH
11200: LD_STRING DMercPopov-Pop-1
11202: PPUSH
11203: CALL_OW 94
// Say ( Burlak , DMercPopov-Bur-1 ) ;
11207: LD_EXP 57
11211: PPUSH
11212: LD_STRING DMercPopov-Bur-1
11214: PPUSH
11215: CALL_OW 88
// SayRadio ( Popov , DMercPopov-Pop-2 ) ;
11219: LD_EXP 76
11223: PPUSH
11224: LD_STRING DMercPopov-Pop-2
11226: PPUSH
11227: CALL_OW 94
// DialogueOff ;
11231: CALL_OW 7
// end ; uc_side = 8 ;
11235: LD_ADDR_OWVAR 20
11239: PUSH
11240: LD_INT 8
11242: ST_TO_ADDR
// uc_nation = 2 ;
11243: LD_ADDR_OWVAR 21
11247: PUSH
11248: LD_INT 2
11250: ST_TO_ADDR
// PrepareSoldier ( false , 6 ) ;
11251: LD_INT 0
11253: PPUSH
11254: LD_INT 6
11256: PPUSH
11257: CALL_OW 381
// legionSold = CreateHuman ;
11261: LD_ADDR_VAR 0 1
11265: PUSH
11266: CALL_OW 44
11270: ST_TO_ADDR
// PlaceUnitXYR ( legionSold , 26 , 48 , 4 , false ) ;
11271: LD_VAR 0 1
11275: PPUSH
11276: LD_INT 26
11278: PPUSH
11279: LD_INT 48
11281: PPUSH
11282: LD_INT 4
11284: PPUSH
11285: LD_INT 0
11287: PPUSH
11288: CALL_OW 50
// repeat wait ( 0 0$1 ) ;
11292: LD_INT 35
11294: PPUSH
11295: CALL_OW 67
// ComMoveXY ( legionSold , GetX ( Heike ) , GetY ( Heike ) ) ;
11299: LD_VAR 0 1
11303: PPUSH
11304: LD_EXP 79
11308: PPUSH
11309: CALL_OW 250
11313: PPUSH
11314: LD_EXP 79
11318: PPUSH
11319: CALL_OW 251
11323: PPUSH
11324: CALL_OW 111
// until GetDistUnits ( legionSold , Heike ) <= 5 or IsDead ( Heike ) ;
11328: LD_VAR 0 1
11332: PPUSH
11333: LD_EXP 79
11337: PPUSH
11338: CALL_OW 296
11342: PUSH
11343: LD_INT 5
11345: LESSEQUAL
11346: PUSH
11347: LD_EXP 79
11351: PPUSH
11352: CALL_OW 301
11356: OR
11357: IFFALSE 11292
// SetSide ( Heike , 8 ) ;
11359: LD_EXP 79
11363: PPUSH
11364: LD_INT 8
11366: PPUSH
11367: CALL_OW 235
// allowExitFromMap = 3 ;
11371: LD_ADDR_EXP 18
11375: PUSH
11376: LD_INT 3
11378: ST_TO_ADDR
// ComMoveToArea ( [ legionSold , Heike ] , KurtExitMapArea ) ;
11379: LD_VAR 0 1
11383: PUSH
11384: LD_EXP 79
11388: PUSH
11389: EMPTY
11390: LIST
11391: LIST
11392: PPUSH
11393: LD_INT 11
11395: PPUSH
11396: CALL_OW 113
// exit ;
11400: GO 11410
// end ; end ; wait ( 0 0$3 ) ;
11402: LD_INT 105
11404: PPUSH
11405: CALL_OW 67
// enable ;
11409: ENABLE
// end ;
11410: PPOPN 1
11412: END
// export function Dial_PlayerDontSendHeike ; begin
11413: LD_INT 0
11415: PPUSH
// DialogueOn ;
11416: CALL_OW 6
// SayRadio ( Kurt , DMercDeceived-Kurt-1 ) ;
11420: LD_EXP 80
11424: PPUSH
11425: LD_STRING DMercDeceived-Kurt-1
11427: PPUSH
11428: CALL_OW 94
// DialogueOff ;
11432: CALL_OW 7
// SetAttitude ( 3 , 8 , att_enemy , true ) ;
11436: LD_INT 3
11438: PPUSH
11439: LD_INT 8
11441: PPUSH
11442: LD_INT 2
11444: PPUSH
11445: LD_INT 1
11447: PPUSH
11448: CALL_OW 80
// KurtAttack = true ;
11452: LD_ADDR_EXP 25
11456: PUSH
11457: LD_INT 1
11459: ST_TO_ADDR
// end ;
11460: LD_VAR 0 1
11464: RET
// export function Dial_BetrayedKurt1 ; begin
11465: LD_INT 0
11467: PPUSH
// DialogueOn ;
11468: CALL_OW 6
// Say ( Kurt , DMercDeceived-Kurt-1 ) ;
11472: LD_EXP 80
11476: PPUSH
11477: LD_STRING DMercDeceived-Kurt-1
11479: PPUSH
11480: CALL_OW 88
// DialogueOff ;
11484: CALL_OW 7
// if IsPlaced ( Kurt ) then
11488: LD_EXP 80
11492: PPUSH
11493: CALL_OW 305
11497: IFFALSE 11546
// begin SetSide ( KurtEng , 8 ) ;
11499: LD_EXP 82
11503: PPUSH
11504: LD_INT 8
11506: PPUSH
11507: CALL_OW 235
// allowExitFromMap = 3 ;
11511: LD_ADDR_EXP 18
11515: PUSH
11516: LD_INT 3
11518: ST_TO_ADDR
// if KurtCanEscape then
11519: LD_EXP 21
11523: IFFALSE 11546
// ComMoveToArea ( [ Kurt , KurtEng ] , KurtExitMapArea ) ;
11525: LD_EXP 80
11529: PUSH
11530: LD_EXP 82
11534: PUSH
11535: EMPTY
11536: LIST
11537: LIST
11538: PPUSH
11539: LD_INT 11
11541: PPUSH
11542: CALL_OW 113
// end ; end ;
11546: LD_VAR 0 1
11550: RET
// export function Dial_BetrayedKurt2 ; begin
11551: LD_INT 0
11553: PPUSH
// DialogueOn ;
11554: CALL_OW 6
// Say ( Kurt , DMercAmbush-Kurt-1 ) ;
11558: LD_EXP 80
11562: PPUSH
11563: LD_STRING DMercAmbush-Kurt-1
11565: PPUSH
11566: CALL_OW 88
// DialogueOff ;
11570: CALL_OW 7
// if IsPlaced ( Kurt ) then
11574: LD_EXP 80
11578: PPUSH
11579: CALL_OW 305
11583: IFFALSE 11632
// begin SetSide ( KurtEng , 8 ) ;
11585: LD_EXP 82
11589: PPUSH
11590: LD_INT 8
11592: PPUSH
11593: CALL_OW 235
// allowExitFromMap = 3 ;
11597: LD_ADDR_EXP 18
11601: PUSH
11602: LD_INT 3
11604: ST_TO_ADDR
// if KurtCanEscape then
11605: LD_EXP 21
11609: IFFALSE 11632
// ComMoveToArea ( [ Kurt , KurtEng ] , KurtExitMapArea ) ;
11611: LD_EXP 80
11615: PUSH
11616: LD_EXP 82
11620: PUSH
11621: EMPTY
11622: LIST
11623: LIST
11624: PPUSH
11625: LD_INT 11
11627: PPUSH
11628: CALL_OW 113
// end ; end ;
11632: LD_VAR 0 1
11636: RET
// every 0 0$1 trigger GetSide ( KurtEng ) = 3 do var playerUnits , unit ;
11637: LD_EXP 82
11641: PPUSH
11642: CALL_OW 255
11646: PUSH
11647: LD_INT 3
11649: EQUAL
11650: IFFALSE 11797
11652: GO 11654
11654: DISABLE
11655: LD_INT 0
11657: PPUSH
11658: PPUSH
// begin playerUnits = FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
11659: LD_ADDR_VAR 0 1
11663: PUSH
11664: LD_INT 22
11666: PUSH
11667: LD_INT 3
11669: PUSH
11670: EMPTY
11671: LIST
11672: LIST
11673: PUSH
11674: LD_INT 2
11676: PUSH
11677: LD_INT 21
11679: PUSH
11680: LD_INT 1
11682: PUSH
11683: EMPTY
11684: LIST
11685: LIST
11686: PUSH
11687: LD_INT 21
11689: PUSH
11690: LD_INT 2
11692: PUSH
11693: EMPTY
11694: LIST
11695: LIST
11696: PUSH
11697: EMPTY
11698: LIST
11699: LIST
11700: LIST
11701: PUSH
11702: EMPTY
11703: LIST
11704: LIST
11705: PPUSH
11706: CALL_OW 69
11710: ST_TO_ADDR
// for unit in playerUnits do
11711: LD_ADDR_VAR 0 2
11715: PUSH
11716: LD_VAR 0 1
11720: PUSH
11721: FOR_IN
11722: IFFALSE 11751
// begin if WantsToAttack ( unit ) = KurtEng then
11724: LD_VAR 0 2
11728: PPUSH
11729: CALL_OW 319
11733: PUSH
11734: LD_EXP 82
11738: EQUAL
11739: IFFALSE 11749
// begin Dial_BetrayedKurt2 ;
11741: CALL 11551 0 0
// exit ;
11745: POP
11746: POP
11747: GO 11797
// end ; end ;
11749: GO 11721
11751: POP
11752: POP
// if ( IsDying ( KurtEng ) or IsDead ( KurtEng ) ) and GetSide ( KurtEng ) = 3 then
11753: LD_EXP 82
11757: PPUSH
11758: CALL_OW 303
11762: PUSH
11763: LD_EXP 82
11767: PPUSH
11768: CALL_OW 301
11772: OR
11773: PUSH
11774: LD_EXP 82
11778: PPUSH
11779: CALL_OW 255
11783: PUSH
11784: LD_INT 3
11786: EQUAL
11787: AND
11788: IFFALSE 11796
// begin Dial_BetrayedKurt2 ;
11790: CALL 11551 0 0
// exit ;
11794: GO 11797
// end ; enable ;
11796: ENABLE
// end ;
11797: PPOPN 2
11799: END
// every 0 0$1 trigger GetAttitude ( 3 , 8 ) = att_neutral and GetLives ( Kurt ) <= 999 do
11800: LD_INT 3
11802: PPUSH
11803: LD_INT 8
11805: PPUSH
11806: CALL_OW 81
11810: PUSH
11811: LD_INT 0
11813: EQUAL
11814: PUSH
11815: LD_EXP 80
11819: PPUSH
11820: CALL_OW 256
11824: PUSH
11825: LD_INT 999
11827: LESSEQUAL
11828: AND
11829: IFFALSE 11854
11831: GO 11833
11833: DISABLE
// begin Dial_BetrayedKurt1 ;
11834: CALL 11465 0 0
// SetAttitude ( 3 , 8 , att_enemy , true ) ;
11838: LD_INT 3
11840: PPUSH
11841: LD_INT 8
11843: PPUSH
11844: LD_INT 2
11846: PPUSH
11847: LD_INT 1
11849: PPUSH
11850: CALL_OW 80
// end ;
11854: END
// every 0 0$1 trigger buildingsToBuild <= 11 do
11855: LD_EXP 8
11859: PUSH
11860: LD_INT 11
11862: LESSEQUAL
11863: IFFALSE 12112
11865: GO 11867
11867: DISABLE
// begin if not IsOK ( Kuzmov ) and not IsOK ( Oblukov ) then
11868: LD_EXP 72
11872: PPUSH
11873: CALL_OW 302
11877: NOT
11878: PUSH
11879: LD_EXP 74
11883: PPUSH
11884: CALL_OW 302
11888: NOT
11889: AND
11890: IFFALSE 11894
// exit ;
11892: GO 12112
// DialogueOn ;
11894: CALL_OW 6
// if IsOK ( Kuzmov ) then
11898: LD_EXP 72
11902: PPUSH
11903: CALL_OW 302
11907: IFFALSE 11923
// Say ( Kuzmov , DFiringRange-Kuz-1 ) else
11909: LD_EXP 72
11913: PPUSH
11914: LD_STRING DFiringRange-Kuz-1
11916: PPUSH
11917: CALL_OW 88
11921: GO 11935
// Say ( Oblukov , DFiringRange-Obl-1 ) ;
11923: LD_EXP 74
11927: PPUSH
11928: LD_STRING DFiringRange-Obl-1
11930: PPUSH
11931: CALL_OW 88
// Say ( Burlak , DFiringRange-Bur-1 ) ;
11935: LD_EXP 57
11939: PPUSH
11940: LD_STRING DFiringRange-Bur-1
11942: PPUSH
11943: CALL_OW 88
// CenterOnXY ( 99 , 30 ) ;
11947: LD_INT 99
11949: PPUSH
11950: LD_INT 30
11952: PPUSH
11953: CALL_OW 84
// Wait ( 0 0$0.5 ) ;
11957: LD_INT 18
11959: PPUSH
11960: CALL_OW 67
// RevealFogArea ( 3 , ShootArea ) ;
11964: LD_INT 3
11966: PPUSH
11967: LD_INT 12
11969: PPUSH
11970: CALL_OW 332
// SetAreaMapShow ( ShootArea , 1 ) ;
11974: LD_INT 12
11976: PPUSH
11977: LD_INT 1
11979: PPUSH
11980: CALL_OW 424
// if IsOK ( Kuzmov ) then
11984: LD_EXP 72
11988: PPUSH
11989: CALL_OW 302
11993: IFFALSE 12009
// Say ( Kuzmov , DFiringRange-Kuz-2 ) else
11995: LD_EXP 72
11999: PPUSH
12000: LD_STRING DFiringRange-Kuz-2
12002: PPUSH
12003: CALL_OW 88
12007: GO 12021
// Say ( Oblukov , DFiringRange-Obl-2 ) ;
12009: LD_EXP 74
12013: PPUSH
12014: LD_STRING DFiringRange-Obl-2
12016: PPUSH
12017: CALL_OW 88
// case Query ( QShootingGallery ) of 1 :
12021: LD_STRING QShootingGallery
12023: PPUSH
12024: CALL_OW 97
12028: PUSH
12029: LD_INT 1
12031: DOUBLE
12032: EQUAL
12033: IFTRUE 12037
12035: GO 12074
12037: POP
// begin Say ( Burlak , DQrShootingGallery#1-Bur-1 ) ;
12038: LD_EXP 57
12042: PPUSH
12043: LD_STRING DQrShootingGallery#1-Bur-1
12045: PPUSH
12046: CALL_OW 88
// BurlakRespect = BurlakRespect + 1 ;
12050: LD_ADDR_EXP 30
12054: PUSH
12055: LD_EXP 30
12059: PUSH
12060: LD_INT 1
12062: PLUS
12063: ST_TO_ADDR
// canShootTrening = true ;
12064: LD_ADDR_EXP 29
12068: PUSH
12069: LD_INT 1
12071: ST_TO_ADDR
// end ; 2 :
12072: GO 12108
12074: LD_INT 2
12076: DOUBLE
12077: EQUAL
12078: IFTRUE 12082
12080: GO 12107
12082: POP
// begin Say ( Burlak , DQrShootingGallery#2-Bur-1 ) ;
12083: LD_EXP 57
12087: PPUSH
12088: LD_STRING DQrShootingGallery#2-Bur-1
12090: PPUSH
12091: CALL_OW 88
// SetAreaMapShow ( ShootArea , 0 ) ;
12095: LD_INT 12
12097: PPUSH
12098: LD_INT 0
12100: PPUSH
12101: CALL_OW 424
// end ; end ;
12105: GO 12108
12107: POP
// DialogueOff ;
12108: CALL_OW 7
// end ;
12112: END
// every 0 0$1 trigger canShootTrening do
12113: LD_EXP 29
12117: IFFALSE 12127
12119: GO 12121
12121: DISABLE
// begin enable ;
12122: ENABLE
// ShootTreningController ;
12123: CALL 7091 0 0
// end ;
12127: END
// every 0 0$1 trigger buildingsToBuild <= 7 do var hunters , hunter ;
12128: LD_EXP 8
12132: PUSH
12133: LD_INT 7
12135: LESSEQUAL
12136: IFFALSE 12526
12138: GO 12140
12140: DISABLE
12141: LD_INT 0
12143: PPUSH
12144: PPUSH
// begin hunters = [ ] ;
12145: LD_ADDR_VAR 0 1
12149: PUSH
12150: EMPTY
12151: ST_TO_ADDR
// if IsOK ( Belkov ) then
12152: LD_EXP 66
12156: PPUSH
12157: CALL_OW 302
12161: IFFALSE 12179
// hunters = hunters ^ Belkov ;
12163: LD_ADDR_VAR 0 1
12167: PUSH
12168: LD_VAR 0 1
12172: PUSH
12173: LD_EXP 66
12177: ADD
12178: ST_TO_ADDR
// if IsOK ( Karamazov ) then
12179: LD_EXP 58
12183: PPUSH
12184: CALL_OW 302
12188: IFFALSE 12206
// hunters = hunters ^ Karamazov ;
12190: LD_ADDR_VAR 0 1
12194: PUSH
12195: LD_VAR 0 1
12199: PUSH
12200: LD_EXP 58
12204: ADD
12205: ST_TO_ADDR
// if IsOK ( Kozlov ) then
12206: LD_EXP 73
12210: PPUSH
12211: CALL_OW 302
12215: IFFALSE 12233
// hunters = hunters ^ Kozlov ;
12217: LD_ADDR_VAR 0 1
12221: PUSH
12222: LD_VAR 0 1
12226: PUSH
12227: LD_EXP 73
12231: ADD
12232: ST_TO_ADDR
// if not hunters then
12233: LD_VAR 0 1
12237: NOT
12238: IFFALSE 12242
// exit ;
12240: GO 12526
// hunter = hunters [ Rand ( 1 , hunters ) ] ;
12242: LD_ADDR_VAR 0 2
12246: PUSH
12247: LD_VAR 0 1
12251: PUSH
12252: LD_INT 1
12254: PPUSH
12255: LD_VAR 0 1
12259: PPUSH
12260: CALL_OW 12
12264: ARRAY
12265: ST_TO_ADDR
// DialogueOn ;
12266: CALL_OW 6
// case hunter of Belkov :
12270: LD_VAR 0 2
12274: PUSH
12275: LD_EXP 66
12279: DOUBLE
12280: EQUAL
12281: IFTRUE 12285
12283: GO 12300
12285: POP
// Say ( Belkov , DHunting-Bel-1 ) ; Karamazov :
12286: LD_EXP 66
12290: PPUSH
12291: LD_STRING DHunting-Bel-1
12293: PPUSH
12294: CALL_OW 88
12298: GO 12351
12300: LD_EXP 58
12304: DOUBLE
12305: EQUAL
12306: IFTRUE 12310
12308: GO 12325
12310: POP
// Say ( Karamazov , DHunting-Kar-1 ) ; Kozlov :
12311: LD_EXP 58
12315: PPUSH
12316: LD_STRING DHunting-Kar-1
12318: PPUSH
12319: CALL_OW 88
12323: GO 12351
12325: LD_EXP 73
12329: DOUBLE
12330: EQUAL
12331: IFTRUE 12335
12333: GO 12350
12335: POP
// Say ( Kozlov , DHunting-Koz-1 ) ; end ;
12336: LD_EXP 73
12340: PPUSH
12341: LD_STRING DHunting-Koz-1
12343: PPUSH
12344: CALL_OW 88
12348: GO 12351
12350: POP
// Say ( Burlak , DHunting-Bur-1 ) ;
12351: LD_EXP 57
12355: PPUSH
12356: LD_STRING DHunting-Bur-1
12358: PPUSH
12359: CALL_OW 88
// case hunter of Belkov :
12363: LD_VAR 0 2
12367: PUSH
12368: LD_EXP 66
12372: DOUBLE
12373: EQUAL
12374: IFTRUE 12378
12376: GO 12393
12378: POP
// Say ( Belkov , DHunting-Bel-2 ) ; Karamazov :
12379: LD_EXP 66
12383: PPUSH
12384: LD_STRING DHunting-Bel-2
12386: PPUSH
12387: CALL_OW 88
12391: GO 12444
12393: LD_EXP 58
12397: DOUBLE
12398: EQUAL
12399: IFTRUE 12403
12401: GO 12418
12403: POP
// Say ( Karamazov , DHunting-Kar-2 ) ; Kozlov :
12404: LD_EXP 58
12408: PPUSH
12409: LD_STRING DHunting-Kar-2
12411: PPUSH
12412: CALL_OW 88
12416: GO 12444
12418: LD_EXP 73
12422: DOUBLE
12423: EQUAL
12424: IFTRUE 12428
12426: GO 12443
12428: POP
// Say ( Kozlov , DHunting-Koz-2 ) ; end ;
12429: LD_EXP 73
12433: PPUSH
12434: LD_STRING DHunting-Koz-2
12436: PPUSH
12437: CALL_OW 88
12441: GO 12444
12443: POP
// DialogueOff ;
12444: CALL_OW 7
// case Query ( QHunting ) of 1 :
12448: LD_STRING QHunting
12450: PPUSH
12451: CALL_OW 97
12455: PUSH
12456: LD_INT 1
12458: DOUBLE
12459: EQUAL
12460: IFTRUE 12464
12462: GO 12502
12464: POP
// begin Say ( Burlak , DQrHunting#1-Bur-1 ) ;
12465: LD_EXP 57
12469: PPUSH
12470: LD_STRING DQrHunting#1-Bur-1
12472: PPUSH
12473: CALL_OW 88
// BurlakRespect = BurlakRespect + 1 ;
12477: LD_ADDR_EXP 30
12481: PUSH
12482: LD_EXP 30
12486: PUSH
12487: LD_INT 1
12489: PLUS
12490: ST_TO_ADDR
// GoToHunt ( hunter ) ;
12491: LD_VAR 0 2
12495: PPUSH
12496: CALL 7719 0 1
// end ; 2 :
12500: GO 12526
12502: LD_INT 2
12504: DOUBLE
12505: EQUAL
12506: IFTRUE 12510
12508: GO 12525
12510: POP
// Say ( Burlak , DQrHunting#2-Bur-1 ) ; end ;
12511: LD_EXP 57
12515: PPUSH
12516: LD_STRING DQrHunting#2-Bur-1
12518: PPUSH
12519: CALL_OW 88
12523: GO 12526
12525: POP
// end ;
12526: PPOPN 2
12528: END
// every 0 0$1 trigger buildingsToBuild <= 3 do var unit , womans , men , woman , man , depots ;
12529: LD_EXP 8
12533: PUSH
12534: LD_INT 3
12536: LESSEQUAL
12537: IFFALSE 13524
12539: GO 12541
12541: DISABLE
12542: LD_INT 0
12544: PPUSH
12545: PPUSH
12546: PPUSH
12547: PPUSH
12548: PPUSH
12549: PPUSH
// begin womans = [ ] ;
12550: LD_ADDR_VAR 0 2
12554: PUSH
12555: EMPTY
12556: ST_TO_ADDR
// men = [ ] ;
12557: LD_ADDR_VAR 0 3
12561: PUSH
12562: EMPTY
12563: ST_TO_ADDR
// if IsOK ( Petrovova ) then
12564: LD_EXP 59
12568: PPUSH
12569: CALL_OW 302
12573: IFFALSE 12591
// womans = womans ^ Petrovova ;
12575: LD_ADDR_VAR 0 2
12579: PUSH
12580: LD_VAR 0 2
12584: PUSH
12585: LD_EXP 59
12589: ADD
12590: ST_TO_ADDR
// if IsOK ( Kirilenkova ) then
12591: LD_EXP 65
12595: PPUSH
12596: CALL_OW 302
12600: IFFALSE 12618
// womans = womans ^ Kirilenkova ;
12602: LD_ADDR_VAR 0 2
12606: PUSH
12607: LD_VAR 0 2
12611: PUSH
12612: LD_EXP 65
12616: ADD
12617: ST_TO_ADDR
// if IsOK ( Kapitsova ) then
12618: LD_EXP 75
12622: PPUSH
12623: CALL_OW 302
12627: IFFALSE 12645
// womans = womans ^ Kapitsova ;
12629: LD_ADDR_VAR 0 2
12633: PUSH
12634: LD_VAR 0 2
12638: PUSH
12639: LD_EXP 75
12643: ADD
12644: ST_TO_ADDR
// DialogueOn ;
12645: CALL_OW 6
// if womans then
12649: LD_VAR 0 2
12653: IFFALSE 12780
// begin case womans [ Rand ( 1 , womans ) ] of Petrovova :
12655: LD_VAR 0 2
12659: PUSH
12660: LD_INT 1
12662: PPUSH
12663: LD_VAR 0 2
12667: PPUSH
12668: CALL_OW 12
12672: ARRAY
12673: PUSH
12674: LD_EXP 59
12678: DOUBLE
12679: EQUAL
12680: IFTRUE 12684
12682: GO 12709
12684: POP
// begin Say ( Petrovova , DFreeTime-Ptr-1 ) ;
12685: LD_EXP 59
12689: PPUSH
12690: LD_STRING DFreeTime-Ptr-1
12692: PPUSH
12693: CALL_OW 88
// woman = Petrovova ;
12697: LD_ADDR_VAR 0 4
12701: PUSH
12702: LD_EXP 59
12706: ST_TO_ADDR
// end ; Kirilenkova :
12707: GO 12780
12709: LD_EXP 65
12713: DOUBLE
12714: EQUAL
12715: IFTRUE 12719
12717: GO 12744
12719: POP
// begin Say ( Kirilenkova , DFreeTime-Kir-1 ) ;
12720: LD_EXP 65
12724: PPUSH
12725: LD_STRING DFreeTime-Kir-1
12727: PPUSH
12728: CALL_OW 88
// woman = Kirilenkova ;
12732: LD_ADDR_VAR 0 4
12736: PUSH
12737: LD_EXP 65
12741: ST_TO_ADDR
// end ; Kapitsova :
12742: GO 12780
12744: LD_EXP 75
12748: DOUBLE
12749: EQUAL
12750: IFTRUE 12754
12752: GO 12779
12754: POP
// begin Say ( Kapitsova , DFreeTime-Kap-1 ) ;
12755: LD_EXP 75
12759: PPUSH
12760: LD_STRING DFreeTime-Kap-1
12762: PPUSH
12763: CALL_OW 88
// woman = Kapitsova ;
12767: LD_ADDR_VAR 0 4
12771: PUSH
12772: LD_EXP 75
12776: ST_TO_ADDR
// end ; end ;
12777: GO 12780
12779: POP
// end ; if IsOK ( Kuzmov ) then
12780: LD_EXP 72
12784: PPUSH
12785: CALL_OW 302
12789: IFFALSE 12807
// men = men ^ Kuzmov ;
12791: LD_ADDR_VAR 0 3
12795: PUSH
12796: LD_VAR 0 3
12800: PUSH
12801: LD_EXP 72
12805: ADD
12806: ST_TO_ADDR
// if IsOK ( Titov ) then
12807: LD_EXP 62
12811: PPUSH
12812: CALL_OW 302
12816: IFFALSE 12834
// men = men ^ Titov ;
12818: LD_ADDR_VAR 0 3
12822: PUSH
12823: LD_VAR 0 3
12827: PUSH
12828: LD_EXP 62
12832: ADD
12833: ST_TO_ADDR
// if IsOK ( Gnyevko ) then
12834: LD_EXP 69
12838: PPUSH
12839: CALL_OW 302
12843: IFFALSE 12861
// men = men ^ Gnyevko ;
12845: LD_ADDR_VAR 0 3
12849: PUSH
12850: LD_VAR 0 3
12854: PUSH
12855: LD_EXP 69
12859: ADD
12860: ST_TO_ADDR
// if IsOK ( Oblukov ) then
12861: LD_EXP 74
12865: PPUSH
12866: CALL_OW 302
12870: IFFALSE 12888
// men = men ^ Oblukov ;
12872: LD_ADDR_VAR 0 3
12876: PUSH
12877: LD_VAR 0 3
12881: PUSH
12882: LD_EXP 74
12886: ADD
12887: ST_TO_ADDR
// if men then
12888: LD_VAR 0 3
12892: IFFALSE 13054
// begin case men [ Rand ( 1 , men ) ] of Kuzmov :
12894: LD_VAR 0 3
12898: PUSH
12899: LD_INT 1
12901: PPUSH
12902: LD_VAR 0 3
12906: PPUSH
12907: CALL_OW 12
12911: ARRAY
12912: PUSH
12913: LD_EXP 72
12917: DOUBLE
12918: EQUAL
12919: IFTRUE 12923
12921: GO 12948
12923: POP
// begin Say ( Kuzmov , DFreeTime-Kuz-1 ) ;
12924: LD_EXP 72
12928: PPUSH
12929: LD_STRING DFreeTime-Kuz-1
12931: PPUSH
12932: CALL_OW 88
// man = Kuzmov ;
12936: LD_ADDR_VAR 0 5
12940: PUSH
12941: LD_EXP 72
12945: ST_TO_ADDR
// end ; Titov :
12946: GO 13054
12948: LD_EXP 62
12952: DOUBLE
12953: EQUAL
12954: IFTRUE 12958
12956: GO 12983
12958: POP
// begin Say ( Titov , DFreeTime-Tit-1 ) ;
12959: LD_EXP 62
12963: PPUSH
12964: LD_STRING DFreeTime-Tit-1
12966: PPUSH
12967: CALL_OW 88
// man = Titov ;
12971: LD_ADDR_VAR 0 5
12975: PUSH
12976: LD_EXP 62
12980: ST_TO_ADDR
// end ; Gnyevko :
12981: GO 13054
12983: LD_EXP 69
12987: DOUBLE
12988: EQUAL
12989: IFTRUE 12993
12991: GO 13018
12993: POP
// begin Say ( Gnyevko , DFreeTime-Gny-1 ) ;
12994: LD_EXP 69
12998: PPUSH
12999: LD_STRING DFreeTime-Gny-1
13001: PPUSH
13002: CALL_OW 88
// man = Gnyevko ;
13006: LD_ADDR_VAR 0 5
13010: PUSH
13011: LD_EXP 69
13015: ST_TO_ADDR
// end ; Oblukov :
13016: GO 13054
13018: LD_EXP 74
13022: DOUBLE
13023: EQUAL
13024: IFTRUE 13028
13026: GO 13053
13028: POP
// begin Say ( Oblukov , DFreeTime-Obl-1 ) ;
13029: LD_EXP 74
13033: PPUSH
13034: LD_STRING DFreeTime-Obl-1
13036: PPUSH
13037: CALL_OW 88
// man = Oblukov ;
13041: LD_ADDR_VAR 0 5
13045: PUSH
13046: LD_EXP 74
13050: ST_TO_ADDR
// end ; end ;
13051: GO 13054
13053: POP
// end ; DialogueOff ;
13054: CALL_OW 7
// if not woman and not man then
13058: LD_VAR 0 4
13062: NOT
13063: PUSH
13064: LD_VAR 0 5
13068: NOT
13069: AND
13070: IFFALSE 13078
// begin DialogueOff ;
13072: CALL_OW 7
// exit ;
13076: GO 13524
// end ; case Query ( QFreeTime ) of 1 :
13078: LD_STRING QFreeTime
13080: PPUSH
13081: CALL_OW 97
13085: PUSH
13086: LD_INT 1
13088: DOUBLE
13089: EQUAL
13090: IFTRUE 13094
13092: GO 13496
13094: POP
// begin Say ( Burlak , DQrFreeTime#1-Bur-1 ) ;
13095: LD_EXP 57
13099: PPUSH
13100: LD_STRING DQrFreeTime#1-Bur-1
13102: PPUSH
13103: CALL_OW 88
// DialogueOff ;
13107: CALL_OW 7
// BurlakRespect = BurlakRespect + 1 ;
13111: LD_ADDR_EXP 30
13115: PUSH
13116: LD_EXP 30
13120: PUSH
13121: LD_INT 1
13123: PLUS
13124: ST_TO_ADDR
// SetSide ( [ woman , man ] , 6 ) ;
13125: LD_VAR 0 4
13129: PUSH
13130: LD_VAR 0 5
13134: PUSH
13135: EMPTY
13136: LIST
13137: LIST
13138: PPUSH
13139: LD_INT 6
13141: PPUSH
13142: CALL_OW 235
// for unit in [ woman , man ] do
13146: LD_ADDR_VAR 0 1
13150: PUSH
13151: LD_VAR 0 4
13155: PUSH
13156: LD_VAR 0 5
13160: PUSH
13161: EMPTY
13162: LIST
13163: LIST
13164: PUSH
13165: FOR_IN
13166: IFFALSE 13221
// if IsInUnit ( unit ) then
13168: LD_VAR 0 1
13172: PPUSH
13173: CALL_OW 310
13177: IFFALSE 13219
// begin if GetType ( IsInUnit ( unit ) ) = unit_vehicle then
13179: LD_VAR 0 1
13183: PPUSH
13184: CALL_OW 310
13188: PPUSH
13189: CALL_OW 247
13193: PUSH
13194: LD_INT 2
13196: EQUAL
13197: IFFALSE 13210
// ComExitVehicle ( unit ) else
13199: LD_VAR 0 1
13203: PPUSH
13204: CALL_OW 121
13208: GO 13219
// ComExitBuilding ( unit ) ;
13210: LD_VAR 0 1
13214: PPUSH
13215: CALL_OW 122
// end ;
13219: GO 13165
13221: POP
13222: POP
// wait ( 0 0$1 ) ;
13223: LD_INT 35
13225: PPUSH
13226: CALL_OW 67
// ComMoveToArea ( [ woman , man ] , ExitMapArea ) ;
13230: LD_VAR 0 4
13234: PUSH
13235: LD_VAR 0 5
13239: PUSH
13240: EMPTY
13241: LIST
13242: LIST
13243: PPUSH
13244: LD_INT 8
13246: PPUSH
13247: CALL_OW 113
// allowExitFromMap = 1 ;
13251: LD_ADDR_EXP 18
13255: PUSH
13256: LD_INT 1
13258: ST_TO_ADDR
// wait ( 3 3$0 ) ;
13259: LD_INT 6300
13261: PPUSH
13262: CALL_OW 67
// PlaceUnitXYR ( woman , 157 , 29 , 3 , false ) ;
13266: LD_VAR 0 4
13270: PPUSH
13271: LD_INT 157
13273: PPUSH
13274: LD_INT 29
13276: PPUSH
13277: LD_INT 3
13279: PPUSH
13280: LD_INT 0
13282: PPUSH
13283: CALL_OW 50
// PlaceUnitXYR ( man , 157 , 29 , 3 , false ) ;
13287: LD_VAR 0 5
13291: PPUSH
13292: LD_INT 157
13294: PPUSH
13295: LD_INT 29
13297: PPUSH
13298: LD_INT 3
13300: PPUSH
13301: LD_INT 0
13303: PPUSH
13304: CALL_OW 50
// SetSide ( [ woman , man ] , 3 ) ;
13308: LD_VAR 0 4
13312: PUSH
13313: LD_VAR 0 5
13317: PUSH
13318: EMPTY
13319: LIST
13320: LIST
13321: PPUSH
13322: LD_INT 3
13324: PPUSH
13325: CALL_OW 235
// depots = FilterAllUnits ( [ [ f_side , 3 ] , [ [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ] ) ;
13329: LD_ADDR_VAR 0 6
13333: PUSH
13334: LD_INT 22
13336: PUSH
13337: LD_INT 3
13339: PUSH
13340: EMPTY
13341: LIST
13342: LIST
13343: PUSH
13344: LD_INT 2
13346: PUSH
13347: LD_INT 30
13349: PUSH
13350: LD_INT 0
13352: PUSH
13353: EMPTY
13354: LIST
13355: LIST
13356: PUSH
13357: LD_INT 30
13359: PUSH
13360: LD_INT 1
13362: PUSH
13363: EMPTY
13364: LIST
13365: LIST
13366: PUSH
13367: EMPTY
13368: LIST
13369: LIST
13370: LIST
13371: PUSH
13372: EMPTY
13373: LIST
13374: PUSH
13375: EMPTY
13376: LIST
13377: LIST
13378: PPUSH
13379: CALL_OW 69
13383: ST_TO_ADDR
// if depots then
13384: LD_VAR 0 6
13388: IFFALSE 13438
// ComMoveXY ( [ woman , man ] , GetX ( depots [ 1 ] ) , GetY ( depots [ 1 ] ) ) else
13390: LD_VAR 0 4
13394: PUSH
13395: LD_VAR 0 5
13399: PUSH
13400: EMPTY
13401: LIST
13402: LIST
13403: PPUSH
13404: LD_VAR 0 6
13408: PUSH
13409: LD_INT 1
13411: ARRAY
13412: PPUSH
13413: CALL_OW 250
13417: PPUSH
13418: LD_VAR 0 6
13422: PUSH
13423: LD_INT 1
13425: ARRAY
13426: PPUSH
13427: CALL_OW 251
13431: PPUSH
13432: CALL_OW 111
13436: GO 13476
// ComMoveXY ( [ woman , man ] , GetX ( Burlak ) , GetY ( Burlak ) ) ;
13438: LD_VAR 0 4
13442: PUSH
13443: LD_VAR 0 5
13447: PUSH
13448: EMPTY
13449: LIST
13450: LIST
13451: PPUSH
13452: LD_EXP 57
13456: PPUSH
13457: CALL_OW 250
13461: PPUSH
13462: LD_EXP 57
13466: PPUSH
13467: CALL_OW 251
13471: PPUSH
13472: CALL_OW 111
// CenterOnUnits ( [ woman , man ] ) ;
13476: LD_VAR 0 4
13480: PUSH
13481: LD_VAR 0 5
13485: PUSH
13486: EMPTY
13487: LIST
13488: LIST
13489: PPUSH
13490: CALL_OW 85
// end ; 2 :
13494: GO 13520
13496: LD_INT 2
13498: DOUBLE
13499: EQUAL
13500: IFTRUE 13504
13502: GO 13519
13504: POP
// Say ( Burlak , DQrFreeTime#2-Bur-1 ) ; end ;
13505: LD_EXP 57
13509: PPUSH
13510: LD_STRING DQrFreeTime#2-Bur-1
13512: PPUSH
13513: CALL_OW 88
13517: GO 13520
13519: POP
// DialogueOff ;
13520: CALL_OW 7
// end ;
13524: PPOPN 6
13526: END
// every 0 0$1 trigger GetAmountWeaponsDataBuildOnVehicle ( false ) <= 2 do
13527: LD_INT 0
13529: PPUSH
13530: CALL 6800 0 1
13534: PUSH
13535: LD_INT 2
13537: LESSEQUAL
13538: IFFALSE 13673
13540: GO 13542
13542: DISABLE
// begin DialogueOn ;
13543: CALL_OW 6
// if IsOK ( Kozlov ) then
13547: LD_EXP 73
13551: PPUSH
13552: CALL_OW 302
13556: IFFALSE 13572
// Say ( Kozlov , DMasha-Koz-1 ) else
13558: LD_EXP 73
13562: PPUSH
13563: LD_STRING DMasha-Koz-1
13565: PPUSH
13566: CALL_OW 88
13570: GO 13635
// DialogRandom ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_ok ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) , DMasha-Koz-1 ,  , false , false ) ;
13572: LD_INT 22
13574: PUSH
13575: LD_INT 3
13577: PUSH
13578: EMPTY
13579: LIST
13580: LIST
13581: PUSH
13582: LD_INT 50
13584: PUSH
13585: EMPTY
13586: LIST
13587: PUSH
13588: LD_INT 21
13590: PUSH
13591: LD_INT 1
13593: PUSH
13594: EMPTY
13595: LIST
13596: LIST
13597: PUSH
13598: LD_INT 26
13600: PUSH
13601: LD_INT 1
13603: PUSH
13604: EMPTY
13605: LIST
13606: LIST
13607: PUSH
13608: EMPTY
13609: LIST
13610: LIST
13611: LIST
13612: LIST
13613: PPUSH
13614: CALL_OW 69
13618: PPUSH
13619: LD_STRING DMasha-Koz-1
13621: PPUSH
13622: LD_STRING 
13624: PPUSH
13625: LD_INT 0
13627: PPUSH
13628: LD_INT 0
13630: PPUSH
13631: CALL 6249 0 5
// Say ( Burlak , DMasha2-Bur-1 ) ;
13635: LD_EXP 57
13639: PPUSH
13640: LD_STRING DMasha2-Bur-1
13642: PPUSH
13643: CALL_OW 88
// DialogueOff ;
13647: CALL_OW 7
// Query ( QMasha ) ;
13651: LD_STRING QMasha
13653: PPUSH
13654: CALL_OW 97
// ChangeMissionObjectives ( MMasha ) ;
13658: LD_STRING MMasha
13660: PPUSH
13661: CALL_OW 337
// canChooseMashaVehicle = true ;
13665: LD_ADDR_EXP 36
13669: PUSH
13670: LD_INT 1
13672: ST_TO_ADDR
// end ;
13673: END
// export function Dial_ComputerTechResearched ; begin
13674: LD_INT 0
13676: PPUSH
// if IsOk ( Scholtze ) or IsOK ( Kapitsova ) then
13677: LD_EXP 71
13681: PPUSH
13682: CALL_OW 302
13686: PUSH
13687: LD_EXP 75
13691: PPUSH
13692: CALL_OW 302
13696: OR
13697: IFFALSE 13793
// begin DialogueOn ;
13699: CALL_OW 6
// if IsOK ( Scholtze ) then
13703: LD_EXP 71
13707: PPUSH
13708: CALL_OW 302
13712: IFFALSE 13728
// Say ( Scholtze , DAI-Sch-1 ) else
13714: LD_EXP 71
13718: PPUSH
13719: LD_STRING DAI-Sch-1
13721: PPUSH
13722: CALL_OW 88
13726: GO 13740
// Say ( Kapitsova , DAI-Kap-1 ) ;
13728: LD_EXP 75
13732: PPUSH
13733: LD_STRING DAI-Kap-1
13735: PPUSH
13736: CALL_OW 88
// Say ( Burlak , DAI-Bur-1 ) ;
13740: LD_EXP 57
13744: PPUSH
13745: LD_STRING DAI-Bur-1
13747: PPUSH
13748: CALL_OW 88
// if IsOK ( Scholtze ) then
13752: LD_EXP 71
13756: PPUSH
13757: CALL_OW 302
13761: IFFALSE 13777
// Say ( Scholtze , DAI-Sch-2 ) else
13763: LD_EXP 71
13767: PPUSH
13768: LD_STRING DAI-Sch-2
13770: PPUSH
13771: CALL_OW 88
13775: GO 13789
// Say ( Kapitsova , DAI-Kap-2 ) ;
13777: LD_EXP 75
13781: PPUSH
13782: LD_STRING DAI-Kap-2
13784: PPUSH
13785: CALL_OW 88
// DialogueOff ;
13789: CALL_OW 7
// end ; ChangeMissionObjectives ( MAI ) ;
13793: LD_STRING MAI
13795: PPUSH
13796: CALL_OW 337
// end ;
13800: LD_VAR 0 1
13804: RET
// export function Dial_TeleportTechResearched ; begin
13805: LD_INT 0
13807: PPUSH
// if IsOk ( Scholtze ) or IsOK ( Kapitsova ) then
13808: LD_EXP 71
13812: PPUSH
13813: CALL_OW 302
13817: PUSH
13818: LD_EXP 75
13822: PPUSH
13823: CALL_OW 302
13827: OR
13828: IFFALSE 13936
// begin DialogueOn ;
13830: CALL_OW 6
// if IsOK ( Scholtze ) then
13834: LD_EXP 71
13838: PPUSH
13839: CALL_OW 302
13843: IFFALSE 13859
// Say ( Scholtze , DSpontTelep-Sch-1 ) else
13845: LD_EXP 71
13849: PPUSH
13850: LD_STRING DSpontTelep-Sch-1
13852: PPUSH
13853: CALL_OW 88
13857: GO 13871
// Say ( Kapitsova , DSpontTelep-Kap-1 ) ;
13859: LD_EXP 75
13863: PPUSH
13864: LD_STRING DSpontTelep-Kap-1
13866: PPUSH
13867: CALL_OW 88
// Say ( Burlak , DSpontTelep-Bur-1 ) ;
13871: LD_EXP 57
13875: PPUSH
13876: LD_STRING DSpontTelep-Bur-1
13878: PPUSH
13879: CALL_OW 88
// if IsOK ( Scholtze ) then
13883: LD_EXP 71
13887: PPUSH
13888: CALL_OW 302
13892: IFFALSE 13908
// Say ( Scholtze , DSpontTelep-Sch-2 ) else
13894: LD_EXP 71
13898: PPUSH
13899: LD_STRING DSpontTelep-Sch-2
13901: PPUSH
13902: CALL_OW 88
13906: GO 13920
// Say ( Kapitsova , DSpontTelep-Kap-2 ) ;
13908: LD_EXP 75
13912: PPUSH
13913: LD_STRING DSpontTelep-Kap-2
13915: PPUSH
13916: CALL_OW 88
// Say ( Burlak , DSpontTelep-Bur-2 ) ;
13920: LD_EXP 57
13924: PPUSH
13925: LD_STRING DSpontTelep-Bur-2
13927: PPUSH
13928: CALL_OW 88
// DialogueOff ;
13932: CALL_OW 7
// end ; ChangeMissionObjectives ( MTele ) ;
13936: LD_STRING MTele
13938: PPUSH
13939: CALL_OW 337
// end ;
13943: LD_VAR 0 1
13947: RET
// every 0 0$1 trigger buildingsToBuild <= 3 and GetAmountWeaponsDataBuildOnVehicle ( false ) <= 1 and techsToResearch <= 4 do
13948: LD_EXP 8
13952: PUSH
13953: LD_INT 3
13955: LESSEQUAL
13956: PUSH
13957: LD_INT 0
13959: PPUSH
13960: CALL 6800 0 1
13964: PUSH
13965: LD_INT 1
13967: LESSEQUAL
13968: AND
13969: PUSH
13970: LD_EXP 9
13974: PUSH
13975: LD_INT 4
13977: LESSEQUAL
13978: AND
13979: IFFALSE 14180
13981: GO 13983
13983: DISABLE
// begin SayRadio ( Popov , DAmAttackStart-Pop-1 ) ;
13984: LD_EXP 76
13988: PPUSH
13989: LD_STRING DAmAttackStart-Pop-1
13991: PPUSH
13992: CALL_OW 94
// if KurtStatus = 1 and HeikeStatus = 1 then
13996: LD_EXP 22
14000: PUSH
14001: LD_INT 1
14003: EQUAL
14004: PUSH
14005: LD_EXP 3
14009: PUSH
14010: LD_INT 1
14012: EQUAL
14013: AND
14014: IFFALSE 14172
// begin wait ( 0 0$10 ) ;
14016: LD_INT 350
14018: PPUSH
14019: CALL_OW 67
// DialogueOn ;
14023: CALL_OW 6
// SayRadio ( Heike , DLegionFormed-Hke-1 ) ;
14027: LD_EXP 79
14031: PPUSH
14032: LD_STRING DLegionFormed-Hke-1
14034: PPUSH
14035: CALL_OW 94
// Say ( Burlak , DLegionFormed-Bur-1 ) ;
14039: LD_EXP 57
14043: PPUSH
14044: LD_STRING DLegionFormed-Bur-1
14046: PPUSH
14047: CALL_OW 88
// SayRadio ( Heike , DLegionFormed-Hke-2 ) ;
14051: LD_EXP 79
14055: PPUSH
14056: LD_STRING DLegionFormed-Hke-2
14058: PPUSH
14059: CALL_OW 94
// Say ( Burlak , DLegionFormed-Bur-2 ) ;
14063: LD_EXP 57
14067: PPUSH
14068: LD_STRING DLegionFormed-Bur-2
14070: PPUSH
14071: CALL_OW 88
// SayRadio ( Heike , DLegionFormed-Hke-3 ) ;
14075: LD_EXP 79
14079: PPUSH
14080: LD_STRING DLegionFormed-Hke-3
14082: PPUSH
14083: CALL_OW 94
// case Query ( QLegion ) of 1 :
14087: LD_STRING QLegion
14089: PPUSH
14090: CALL_OW 97
14094: PUSH
14095: LD_INT 1
14097: DOUBLE
14098: EQUAL
14099: IFTRUE 14103
14101: GO 14134
14103: POP
// begin acceptLegionOffert = true ;
14104: LD_ADDR_EXP 31
14108: PUSH
14109: LD_INT 1
14111: ST_TO_ADDR
// legionOffertCountdown = true ;
14112: LD_ADDR_EXP 33
14116: PUSH
14117: LD_INT 1
14119: ST_TO_ADDR
// Say ( Burlak , DQrLegion#1-Bur-1 ) ;
14120: LD_EXP 57
14124: PPUSH
14125: LD_STRING DQrLegion#1-Bur-1
14127: PPUSH
14128: CALL_OW 88
// end ; 2 :
14132: GO 14166
14134: LD_INT 2
14136: DOUBLE
14137: EQUAL
14138: IFTRUE 14142
14140: GO 14165
14142: POP
// begin Say ( Burlak , DQrLegion#2-Bur-1 ) ;
14143: LD_EXP 57
14147: PPUSH
14148: LD_STRING DQrLegion#2-Bur-1
14150: PPUSH
14151: CALL_OW 88
// americansAttack = true ;
14155: LD_ADDR_EXP 26
14159: PUSH
14160: LD_INT 1
14162: ST_TO_ADDR
// end ; end ;
14163: GO 14166
14165: POP
// DialogueOff ;
14166: CALL_OW 7
// end else
14170: GO 14180
// begin americansAttack = true ;
14172: LD_ADDR_EXP 26
14176: PUSH
14177: LD_INT 1
14179: ST_TO_ADDR
// end ; end ;
14180: END
// every 0 0$1 trigger legionOffertTime <= 0 0$00 do
14181: LD_EXP 34
14185: PUSH
14186: LD_INT 0
14188: LESSEQUAL
14189: IFFALSE 14210
14191: GO 14193
14193: DISABLE
// begin legionOffertCountdown = false ;
14194: LD_ADDR_EXP 33
14198: PUSH
14199: LD_INT 0
14201: ST_TO_ADDR
// americansAttack = true ;
14202: LD_ADDR_EXP 26
14206: PUSH
14207: LD_INT 1
14209: ST_TO_ADDR
// end ;
14210: END
// every 0 0$1 trigger legionOffertCountdown do var needCrates , depots , depot , crates ;
14211: LD_EXP 33
14215: IFFALSE 14401
14217: GO 14219
14219: DISABLE
14220: LD_INT 0
14222: PPUSH
14223: PPUSH
14224: PPUSH
14225: PPUSH
// begin needCrates = 50 ;
14226: LD_ADDR_VAR 0 1
14230: PUSH
14231: LD_INT 50
14233: ST_TO_ADDR
// crates = 0 ;
14234: LD_ADDR_VAR 0 4
14238: PUSH
14239: LD_INT 0
14241: ST_TO_ADDR
// depots = FilterAllUnits ( [ [ f_side , 3 ] , [ [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ] ) ;
14242: LD_ADDR_VAR 0 2
14246: PUSH
14247: LD_INT 22
14249: PUSH
14250: LD_INT 3
14252: PUSH
14253: EMPTY
14254: LIST
14255: LIST
14256: PUSH
14257: LD_INT 2
14259: PUSH
14260: LD_INT 30
14262: PUSH
14263: LD_INT 0
14265: PUSH
14266: EMPTY
14267: LIST
14268: LIST
14269: PUSH
14270: LD_INT 30
14272: PUSH
14273: LD_INT 1
14275: PUSH
14276: EMPTY
14277: LIST
14278: LIST
14279: PUSH
14280: EMPTY
14281: LIST
14282: LIST
14283: LIST
14284: PUSH
14285: EMPTY
14286: LIST
14287: PUSH
14288: EMPTY
14289: LIST
14290: LIST
14291: PPUSH
14292: CALL_OW 69
14296: ST_TO_ADDR
// for depot in depots do
14297: LD_ADDR_VAR 0 3
14301: PUSH
14302: LD_VAR 0 2
14306: PUSH
14307: FOR_IN
14308: IFFALSE 14399
// begin crates = GetResourceType ( GetBase ( depot ) , mat_cans ) ;
14310: LD_ADDR_VAR 0 4
14314: PUSH
14315: LD_VAR 0 3
14319: PPUSH
14320: CALL_OW 274
14324: PPUSH
14325: LD_INT 1
14327: PPUSH
14328: CALL_OW 275
14332: ST_TO_ADDR
// if crates >= needCrates then
14333: LD_VAR 0 4
14337: PUSH
14338: LD_VAR 0 1
14342: GREATEREQUAL
14343: IFFALSE 14397
// begin SetResourceType ( GetBase ( depot ) , mat_cans , crates - needCrates ) ;
14345: LD_VAR 0 3
14349: PPUSH
14350: CALL_OW 274
14354: PPUSH
14355: LD_INT 1
14357: PPUSH
14358: LD_VAR 0 4
14362: PUSH
14363: LD_VAR 0 1
14367: MINUS
14368: PPUSH
14369: CALL_OW 277
// legionOffertCountdown = false ;
14373: LD_ADDR_EXP 33
14377: PUSH
14378: LD_INT 0
14380: ST_TO_ADDR
// paidLegionOffert = true ;
14381: LD_ADDR_EXP 32
14385: PUSH
14386: LD_INT 1
14388: ST_TO_ADDR
// americansAttack = true ;
14389: LD_ADDR_EXP 26
14393: PUSH
14394: LD_INT 1
14396: ST_TO_ADDR
// end ; end ;
14397: GO 14307
14399: POP
14400: POP
// end ;
14401: PPOPN 4
14403: END
// every 0 0$1 trigger currentAmWave >= americansAttackWaves and FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_type , unit_human ] , [ f_and , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ] ] ) = 0 do
14404: LD_EXP 85
14408: PUSH
14409: LD_EXP 48
14413: GREATEREQUAL
14414: PUSH
14415: LD_INT 22
14417: PUSH
14418: LD_INT 1
14420: PUSH
14421: EMPTY
14422: LIST
14423: LIST
14424: PUSH
14425: LD_INT 2
14427: PUSH
14428: LD_INT 21
14430: PUSH
14431: LD_INT 1
14433: PUSH
14434: EMPTY
14435: LIST
14436: LIST
14437: PUSH
14438: LD_INT 1
14440: PUSH
14441: LD_INT 21
14443: PUSH
14444: LD_INT 2
14446: PUSH
14447: EMPTY
14448: LIST
14449: LIST
14450: PUSH
14451: LD_INT 33
14453: PUSH
14454: LD_INT 3
14456: PUSH
14457: EMPTY
14458: LIST
14459: LIST
14460: PUSH
14461: EMPTY
14462: LIST
14463: LIST
14464: LIST
14465: PUSH
14466: EMPTY
14467: LIST
14468: LIST
14469: LIST
14470: PUSH
14471: EMPTY
14472: LIST
14473: LIST
14474: PPUSH
14475: CALL_OW 69
14479: PUSH
14480: LD_INT 0
14482: EQUAL
14483: AND
14484: IFFALSE 14684
14486: GO 14488
14488: DISABLE
// begin DialogueOn ;
14489: CALL_OW 6
// if IsOK ( Belkov ) then
14493: LD_EXP 66
14497: PPUSH
14498: CALL_OW 302
14502: IFFALSE 14518
// Say ( Belkov , DAmAttackFin-Bel-1 ) else
14504: LD_EXP 66
14508: PPUSH
14509: LD_STRING DAmAttackFin-Bel-1
14511: PPUSH
14512: CALL_OW 88
14516: GO 14541
// if IsOK ( Belkov2 ) then
14518: LD_EXP 67
14522: PPUSH
14523: CALL_OW 302
14527: IFFALSE 14541
// Say ( Belkov2 , DAmAttackFin-Bel-1 ) ;
14529: LD_EXP 67
14533: PPUSH
14534: LD_STRING DAmAttackFin-Bel-1
14536: PPUSH
14537: CALL_OW 88
// if IsOK ( Gnyevko ) then
14541: LD_EXP 69
14545: PPUSH
14546: CALL_OW 302
14550: IFFALSE 14564
// Say ( Gnyevko , DAmAttackFin-Gny-1 ) ;
14552: LD_EXP 69
14556: PPUSH
14557: LD_STRING DAmAttackFin-Gny-1
14559: PPUSH
14560: CALL_OW 88
// if IsOK ( Titov ) then
14564: LD_EXP 62
14568: PPUSH
14569: CALL_OW 302
14573: IFFALSE 14587
// Say ( Titov , DAmAttackFin-Tit-1 ) ;
14575: LD_EXP 62
14579: PPUSH
14580: LD_STRING DAmAttackFin-Tit-1
14582: PPUSH
14583: CALL_OW 88
// if IsOK ( Lipshchin ) then
14587: LD_EXP 64
14591: PPUSH
14592: CALL_OW 302
14596: IFFALSE 14610
// Say ( Lipshchin , DAmAttackFin-Lip-1 ) ;
14598: LD_EXP 64
14602: PPUSH
14603: LD_STRING DAmAttackFin-Lip-1
14605: PPUSH
14606: CALL_OW 88
// if IsOK ( Karamazov ) then
14610: LD_EXP 58
14614: PPUSH
14615: CALL_OW 302
14619: IFFALSE 14633
// Say ( Karamazov , DAmAttackFin-Kar-1 ) ;
14621: LD_EXP 58
14625: PPUSH
14626: LD_STRING DAmAttackFin-Kar-1
14628: PPUSH
14629: CALL_OW 88
// if IsOK ( Oblukov ) then
14633: LD_EXP 74
14637: PPUSH
14638: CALL_OW 302
14642: IFFALSE 14656
// Say ( Oblukov , DAmAttackFin-Obl-1 ) ;
14644: LD_EXP 74
14648: PPUSH
14649: LD_STRING DAmAttackFin-Obl-1
14651: PPUSH
14652: CALL_OW 88
// Say ( Burlak , AmAttackFin-Bur-1 ) ;
14656: LD_EXP 57
14660: PPUSH
14661: LD_STRING AmAttackFin-Bur-1
14663: PPUSH
14664: CALL_OW 88
// SayRadio ( Popov , DAmAttackFin-Pop-1 ) ;
14668: LD_EXP 76
14672: PPUSH
14673: LD_STRING DAmAttackFin-Pop-1
14675: PPUSH
14676: CALL_OW 94
// DialogueOff ;
14680: CALL_OW 7
// end ;
14684: END
// every 0 0$1 trigger buildingsToBuild + ( 3 - GetAmountWeaponsDataBuildOnTurret ( true ) ) = 0 do
14685: LD_EXP 8
14689: PUSH
14690: LD_INT 3
14692: PUSH
14693: LD_INT 1
14695: PPUSH
14696: CALL 6690 0 1
14700: MINUS
14701: PLUS
14702: PUSH
14703: LD_INT 0
14705: EQUAL
14706: IFFALSE 14718
14708: GO 14710
14710: DISABLE
// ChangeMissionObjectives ( MBuildingsDone ) ;
14711: LD_STRING MBuildingsDone
14713: PPUSH
14714: CALL_OW 337
14718: END
// every 0 0$1 trigger GetAmountWeaponsDataBuildOnVehicle ( false ) = 0 do
14719: LD_INT 0
14721: PPUSH
14722: CALL 6800 0 1
14726: PUSH
14727: LD_INT 0
14729: EQUAL
14730: IFFALSE 14742
14732: GO 14734
14734: DISABLE
// ChangeMissionObjectives ( MWeaponsDone ) ;
14735: LD_STRING MWeaponsDone
14737: PPUSH
14738: CALL_OW 337
14742: END
// every 0 0$1 trigger techsToResearch = 0 do
14743: LD_EXP 9
14747: PUSH
14748: LD_INT 0
14750: EQUAL
14751: IFFALSE 14763
14753: GO 14755
14755: DISABLE
// ChangeMissionObjectives ( MTechnoDone ) ;
14756: LD_STRING MTechnoDone
14758: PPUSH
14759: CALL_OW 337
14763: END
// every 0 0$1 trigger americansAttack and not FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_type , unit_human ] , [ f_and , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ] ] ) do
14764: LD_EXP 26
14768: PUSH
14769: LD_INT 22
14771: PUSH
14772: LD_INT 1
14774: PUSH
14775: EMPTY
14776: LIST
14777: LIST
14778: PUSH
14779: LD_INT 2
14781: PUSH
14782: LD_INT 21
14784: PUSH
14785: LD_INT 1
14787: PUSH
14788: EMPTY
14789: LIST
14790: LIST
14791: PUSH
14792: LD_INT 1
14794: PUSH
14795: LD_INT 21
14797: PUSH
14798: LD_INT 2
14800: PUSH
14801: EMPTY
14802: LIST
14803: LIST
14804: PUSH
14805: LD_INT 33
14807: PUSH
14808: LD_INT 3
14810: PUSH
14811: EMPTY
14812: LIST
14813: LIST
14814: PUSH
14815: EMPTY
14816: LIST
14817: LIST
14818: LIST
14819: PUSH
14820: EMPTY
14821: LIST
14822: LIST
14823: LIST
14824: PUSH
14825: EMPTY
14826: LIST
14827: LIST
14828: PPUSH
14829: CALL_OW 69
14833: NOT
14834: AND
14835: IFFALSE 14847
14837: GO 14839
14839: DISABLE
// ChangeMissionObjectives ( MEnemyDone ) ;
14840: LD_STRING MEnemyDone
14842: PPUSH
14843: CALL_OW 337
14847: END
// every 0 0$1 trigger ( buildingsToBuild + ( 3 - GetAmountWeaponsDataBuildOnTurret ( true ) ) ) = 0 and GetAmountWeaponsDataBuildOnVehicle ( false ) = 0 and techsToResearch = 0 and FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_type , unit_human ] , [ f_and , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ] ] ) = 0 and Masha and IsOK ( Masha [ 1 ] ) and buildCompVehicle and testedTeleport do
14848: LD_EXP 8
14852: PUSH
14853: LD_INT 3
14855: PUSH
14856: LD_INT 1
14858: PPUSH
14859: CALL 6690 0 1
14863: MINUS
14864: PLUS
14865: PUSH
14866: LD_INT 0
14868: EQUAL
14869: PUSH
14870: LD_INT 0
14872: PPUSH
14873: CALL 6800 0 1
14877: PUSH
14878: LD_INT 0
14880: EQUAL
14881: AND
14882: PUSH
14883: LD_EXP 9
14887: PUSH
14888: LD_INT 0
14890: EQUAL
14891: AND
14892: PUSH
14893: LD_INT 22
14895: PUSH
14896: LD_INT 8
14898: PUSH
14899: EMPTY
14900: LIST
14901: LIST
14902: PUSH
14903: LD_INT 21
14905: PUSH
14906: LD_INT 1
14908: PUSH
14909: EMPTY
14910: LIST
14911: LIST
14912: PUSH
14913: EMPTY
14914: LIST
14915: LIST
14916: PPUSH
14917: CALL_OW 69
14921: PUSH
14922: LD_INT 0
14924: EQUAL
14925: AND
14926: PUSH
14927: LD_INT 22
14929: PUSH
14930: LD_INT 1
14932: PUSH
14933: EMPTY
14934: LIST
14935: LIST
14936: PUSH
14937: LD_INT 2
14939: PUSH
14940: LD_INT 21
14942: PUSH
14943: LD_INT 1
14945: PUSH
14946: EMPTY
14947: LIST
14948: LIST
14949: PUSH
14950: LD_INT 1
14952: PUSH
14953: LD_INT 21
14955: PUSH
14956: LD_INT 2
14958: PUSH
14959: EMPTY
14960: LIST
14961: LIST
14962: PUSH
14963: LD_INT 33
14965: PUSH
14966: LD_INT 3
14968: PUSH
14969: EMPTY
14970: LIST
14971: LIST
14972: PUSH
14973: EMPTY
14974: LIST
14975: LIST
14976: LIST
14977: PUSH
14978: EMPTY
14979: LIST
14980: LIST
14981: LIST
14982: PUSH
14983: EMPTY
14984: LIST
14985: LIST
14986: PPUSH
14987: CALL_OW 69
14991: PUSH
14992: LD_INT 0
14994: EQUAL
14995: AND
14996: PUSH
14997: LD_EXP 4
15001: AND
15002: PUSH
15003: LD_EXP 4
15007: PUSH
15008: LD_INT 1
15010: ARRAY
15011: PPUSH
15012: CALL_OW 302
15016: AND
15017: PUSH
15018: LD_EXP 37
15022: AND
15023: PUSH
15024: LD_EXP 39
15028: AND
15029: IFFALSE 15038
15031: GO 15033
15033: DISABLE
// begin FinishMission ;
15034: CALL 15243 0 0
// end ;
15038: END
// every 0 0$1 do var unit ;
15039: GO 15041
15041: DISABLE
15042: LD_INT 0
15044: PPUSH
// begin case allowExitFromMap of 1 :
15045: LD_EXP 18
15049: PUSH
15050: LD_INT 1
15052: DOUBLE
15053: EQUAL
15054: IFTRUE 15058
15056: GO 15086
15058: POP
// RemoveUnits ( FilterUnitsInArea ( ExitMapArea , [ [ f_side , 6 ] ] ) ) ; 3 :
15059: LD_INT 8
15061: PPUSH
15062: LD_INT 22
15064: PUSH
15065: LD_INT 6
15067: PUSH
15068: EMPTY
15069: LIST
15070: LIST
15071: PUSH
15072: EMPTY
15073: LIST
15074: PPUSH
15075: CALL_OW 70
15079: PPUSH
15080: CALL 6526 0 1
15084: GO 15209
15086: LD_INT 3
15088: DOUBLE
15089: EQUAL
15090: IFTRUE 15094
15092: GO 15122
15094: POP
// RemoveUnits ( FilterUnitsInArea ( KurtExitMapArea , [ [ f_side , 8 ] ] ) ) ; 4 :
15095: LD_INT 11
15097: PPUSH
15098: LD_INT 22
15100: PUSH
15101: LD_INT 8
15103: PUSH
15104: EMPTY
15105: LIST
15106: LIST
15107: PUSH
15108: EMPTY
15109: LIST
15110: PPUSH
15111: CALL_OW 70
15115: PPUSH
15116: CALL 6526 0 1
15120: GO 15209
15122: LD_INT 4
15124: DOUBLE
15125: EQUAL
15126: IFTRUE 15130
15128: GO 15208
15130: POP
// begin RemoveUnits ( FilterUnitsInArea ( ExitMapArea , [ [ f_side , 8 ] ] ) ) ;
15131: LD_INT 8
15133: PPUSH
15134: LD_INT 22
15136: PUSH
15137: LD_INT 8
15139: PUSH
15140: EMPTY
15141: LIST
15142: LIST
15143: PUSH
15144: EMPTY
15145: LIST
15146: PPUSH
15147: CALL_OW 70
15151: PPUSH
15152: CALL 6526 0 1
// RemoveUnits ( FilterUnitsInArea ( KurtExitMapArea , [ [ f_side , 8 ] ] ) ) ;
15156: LD_INT 11
15158: PPUSH
15159: LD_INT 22
15161: PUSH
15162: LD_INT 8
15164: PUSH
15165: EMPTY
15166: LIST
15167: LIST
15168: PUSH
15169: EMPTY
15170: LIST
15171: PPUSH
15172: CALL_OW 70
15176: PPUSH
15177: CALL 6526 0 1
// RemoveUnits ( FilterUnitsInArea ( ExitMapArea , [ [ f_side , 2 ] ] ) ) ;
15181: LD_INT 8
15183: PPUSH
15184: LD_INT 22
15186: PUSH
15187: LD_INT 2
15189: PUSH
15190: EMPTY
15191: LIST
15192: LIST
15193: PUSH
15194: EMPTY
15195: LIST
15196: PPUSH
15197: CALL_OW 70
15201: PPUSH
15202: CALL 6526 0 1
// end ; end ;
15206: GO 15209
15208: POP
// enable ;
15209: ENABLE
// end ; end_of_file
15210: PPOPN 1
15212: END
// export function Lose_Burlak ; begin
15213: LD_INT 0
15215: PPUSH
// YouLost ( Burlak ) ;
15216: LD_STRING Burlak
15218: PPUSH
15219: CALL_OW 104
// end ;
15223: LD_VAR 0 1
15227: RET
// export function Lost_AttackAlly ; begin
15228: LD_INT 0
15230: PPUSH
// YouLost ( SelfAttack ) ;
15231: LD_STRING SelfAttack
15233: PPUSH
15234: CALL_OW 104
// end ; end_of_file
15238: LD_VAR 0 1
15242: RET
// export function FinishMission ; begin
15243: LD_INT 0
15245: PPUSH
// SetRewards ;
15246: CALL 15267 0 0
// SavePlayerCharacters ;
15250: CALL 15528 0 0
// SaveGlobalVariables ;
15254: CALL 16078 0 0
// YouWin ;
15258: CALL_OW 103
// end ;
15262: LD_VAR 0 1
15266: RET
// function SetRewards ; begin
15267: LD_INT 0
15269: PPUSH
// AddMedal ( ArtisticImpression , 1 ) ;
15270: LD_STRING ArtisticImpression
15272: PPUSH
15273: LD_INT 1
15275: PPUSH
15276: CALL_OW 101
// if not HeikeCaptured then
15280: LD_EXP 1
15284: NOT
15285: IFFALSE 15319
// begin if speedMedalTime >= 0 0$00 then
15287: LD_EXP 52
15291: PUSH
15292: LD_INT 0
15294: GREATEREQUAL
15295: IFFALSE 15309
// AddMedal ( Speed , 1 ) else
15297: LD_STRING Speed
15299: PPUSH
15300: LD_INT 1
15302: PPUSH
15303: CALL_OW 101
15307: GO 15319
// AddMedal ( Speed , 1 ) ;
15309: LD_STRING Speed
15311: PPUSH
15312: LD_INT 1
15314: PPUSH
15315: CALL_OW 101
// end ; if lostUnits then
15319: LD_EXP 40
15323: IFFALSE 15338
// begin AddMedal ( FavouriteCommander , - 1 ) ;
15325: LD_STRING FavouriteCommander
15327: PPUSH
15328: LD_INT 1
15330: NEG
15331: PPUSH
15332: CALL_OW 101
// end else
15336: GO 15430
// begin case BurlakRespect of 0 :
15338: LD_EXP 30
15342: PUSH
15343: LD_INT 0
15345: DOUBLE
15346: EQUAL
15347: IFTRUE 15351
15349: GO 15365
15351: POP
// AddMedal ( FavouriteCommander , - 2 ) ; 1 :
15352: LD_STRING FavouriteCommander
15354: PPUSH
15355: LD_INT 2
15357: NEG
15358: PPUSH
15359: CALL_OW 101
15363: GO 15430
15365: LD_INT 1
15367: DOUBLE
15368: EQUAL
15369: IFTRUE 15373
15371: GO 15387
15373: POP
// AddMedal ( FavouriteCommander , - 3 ) ; 2 :
15374: LD_STRING FavouriteCommander
15376: PPUSH
15377: LD_INT 3
15379: NEG
15380: PPUSH
15381: CALL_OW 101
15385: GO 15430
15387: LD_INT 2
15389: DOUBLE
15390: EQUAL
15391: IFTRUE 15395
15393: GO 15408
15395: POP
// AddMedal ( FavouriteCommander , 1 ) ; 3 :
15396: LD_STRING FavouriteCommander
15398: PPUSH
15399: LD_INT 1
15401: PPUSH
15402: CALL_OW 101
15406: GO 15430
15408: LD_INT 3
15410: DOUBLE
15411: EQUAL
15412: IFTRUE 15416
15414: GO 15429
15416: POP
// AddMedal ( FavouriteCommander , 1 ) ; end ;
15417: LD_STRING FavouriteCommander
15419: PPUSH
15420: LD_INT 1
15422: PPUSH
15423: CALL_OW 101
15427: GO 15430
15429: POP
// end ; if HeikeCaptured then
15430: LD_EXP 1
15434: IFFALSE 15465
// begin if buildArabBarrack then
15436: LD_EXP 38
15440: IFFALSE 15454
// AddMedal ( ArabBarracks , 1 ) else
15442: LD_STRING ArabBarracks
15444: PPUSH
15445: LD_INT 1
15447: PPUSH
15448: CALL_OW 101
15452: GO 15465
// AddMedal ( ArabBarracks , - 1 ) ;
15454: LD_STRING ArabBarracks
15456: PPUSH
15457: LD_INT 1
15459: NEG
15460: PPUSH
15461: CALL_OW 101
// end ; GiveMedals ( Main1 ) ;
15465: LD_STRING Main1
15467: PPUSH
15468: CALL_OW 102
// RewardPeople ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_nation , nation_russian ] , [ f_ok ] ] ) ) ;
15472: LD_INT 22
15474: PUSH
15475: LD_INT 3
15477: PUSH
15478: EMPTY
15479: LIST
15480: LIST
15481: PUSH
15482: LD_INT 21
15484: PUSH
15485: LD_INT 1
15487: PUSH
15488: EMPTY
15489: LIST
15490: LIST
15491: PUSH
15492: LD_INT 23
15494: PUSH
15495: LD_INT 3
15497: PUSH
15498: EMPTY
15499: LIST
15500: LIST
15501: PUSH
15502: LD_INT 50
15504: PUSH
15505: EMPTY
15506: LIST
15507: PUSH
15508: EMPTY
15509: LIST
15510: LIST
15511: LIST
15512: LIST
15513: PPUSH
15514: CALL_OW 69
15518: PPUSH
15519: CALL_OW 43
// end ;
15523: LD_VAR 0 1
15527: RET
// function SavePlayerCharacters ; var randomsToSave ; begin
15528: LD_INT 0
15530: PPUSH
15531: PPUSH
// ExtSaveCharacter ( Burlak , Burlak , 3 ) ;
15532: LD_EXP 57
15536: PPUSH
15537: LD_STRING Burlak
15539: PPUSH
15540: LD_INT 3
15542: PPUSH
15543: CALL 6048 0 3
// ExtSaveCharacter ( Karamazov , Karamazov , 3 ) ;
15547: LD_EXP 58
15551: PPUSH
15552: LD_STRING Karamazov
15554: PPUSH
15555: LD_INT 3
15557: PPUSH
15558: CALL 6048 0 3
// ExtSaveCharacter ( Petrovova , Petrovova , 3 ) ;
15562: LD_EXP 59
15566: PPUSH
15567: LD_STRING Petrovova
15569: PPUSH
15570: LD_INT 3
15572: PPUSH
15573: CALL 6048 0 3
// ExtSaveCharacter ( Gleb , Gleb , 3 ) ;
15577: LD_EXP 60
15581: PPUSH
15582: LD_STRING Gleb
15584: PPUSH
15585: LD_INT 3
15587: PPUSH
15588: CALL 6048 0 3
// ExtSaveCharacter ( Petrosyan , Petrosyan , 3 ) ;
15592: LD_EXP 61
15596: PPUSH
15597: LD_STRING Petrosyan
15599: PPUSH
15600: LD_INT 3
15602: PPUSH
15603: CALL 6048 0 3
// ExtSaveCharacter ( Dolgov , Dolgov , 3 ) ;
15607: LD_EXP 63
15611: PPUSH
15612: LD_STRING Dolgov
15614: PPUSH
15615: LD_INT 3
15617: PPUSH
15618: CALL 6048 0 3
// ExtSaveCharacter ( Lipshchin , Lipshchin , 3 ) ;
15622: LD_EXP 64
15626: PPUSH
15627: LD_STRING Lipshchin
15629: PPUSH
15630: LD_INT 3
15632: PPUSH
15633: CALL 6048 0 3
// ExtSaveCharacter ( Titov , Titov , 3 ) ;
15637: LD_EXP 62
15641: PPUSH
15642: LD_STRING Titov
15644: PPUSH
15645: LD_INT 3
15647: PPUSH
15648: CALL 6048 0 3
// ExtSaveCharacter ( Kirilenkova , Kirilenkova , 3 ) ;
15652: LD_EXP 65
15656: PPUSH
15657: LD_STRING Kirilenkova
15659: PPUSH
15660: LD_INT 3
15662: PPUSH
15663: CALL 6048 0 3
// ExtSaveCharacter ( Belkov , Belkov , 3 ) ;
15667: LD_EXP 66
15671: PPUSH
15672: LD_STRING Belkov
15674: PPUSH
15675: LD_INT 3
15677: PPUSH
15678: CALL 6048 0 3
// ExtSaveCharacter ( Belkov2 , Belkov2 , 3 ) ;
15682: LD_EXP 67
15686: PPUSH
15687: LD_STRING Belkov2
15689: PPUSH
15690: LD_INT 3
15692: PPUSH
15693: CALL 6048 0 3
// ExtSaveCharacter ( Xavier , Xavier , 3 ) ;
15697: LD_EXP 68
15701: PPUSH
15702: LD_STRING Xavier
15704: PPUSH
15705: LD_INT 3
15707: PPUSH
15708: CALL 6048 0 3
// ExtSaveCharacter ( Kozlov , Kozlov , 3 ) ;
15712: LD_EXP 73
15716: PPUSH
15717: LD_STRING Kozlov
15719: PPUSH
15720: LD_INT 3
15722: PPUSH
15723: CALL 6048 0 3
// ExtSaveCharacter ( Oblukov , Oblukov , 3 ) ;
15727: LD_EXP 74
15731: PPUSH
15732: LD_STRING Oblukov
15734: PPUSH
15735: LD_INT 3
15737: PPUSH
15738: CALL 6048 0 3
// ExtSaveCharacter ( Kapitsova , Kapitsova , 3 ) ;
15742: LD_EXP 75
15746: PPUSH
15747: LD_STRING Kapitsova
15749: PPUSH
15750: LD_INT 3
15752: PPUSH
15753: CALL 6048 0 3
// ExtSaveCharacter ( Gnyevko , Gnyevko , 3 ) ;
15757: LD_EXP 69
15761: PPUSH
15762: LD_STRING Gnyevko
15764: PPUSH
15765: LD_INT 3
15767: PPUSH
15768: CALL 6048 0 3
// ExtSaveCharacter ( Kovalyuk , Kovalyuk , 3 ) ;
15772: LD_EXP 70
15776: PPUSH
15777: LD_STRING Kovalyuk
15779: PPUSH
15780: LD_INT 3
15782: PPUSH
15783: CALL 6048 0 3
// ExtSaveCharacter ( Scholtze , Scholtze , 3 ) ;
15787: LD_EXP 71
15791: PPUSH
15792: LD_STRING Scholtze
15794: PPUSH
15795: LD_INT 3
15797: PPUSH
15798: CALL 6048 0 3
// ExtSaveCharacter ( Kuzmov , Kuzmov , 3 ) ;
15802: LD_EXP 72
15806: PPUSH
15807: LD_STRING Kuzmov
15809: PPUSH
15810: LD_INT 3
15812: PPUSH
15813: CALL 6048 0 3
// ExtSaveCharacters ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_or , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman_soldier ] ] ] ) , other_apemans , 3 ) ;
15817: LD_INT 22
15819: PUSH
15820: LD_INT 3
15822: PUSH
15823: EMPTY
15824: LIST
15825: LIST
15826: PUSH
15827: LD_INT 21
15829: PUSH
15830: LD_INT 1
15832: PUSH
15833: EMPTY
15834: LIST
15835: LIST
15836: PUSH
15837: LD_INT 2
15839: PUSH
15840: LD_INT 25
15842: PUSH
15843: LD_INT 12
15845: PUSH
15846: EMPTY
15847: LIST
15848: LIST
15849: PUSH
15850: LD_INT 25
15852: PUSH
15853: LD_INT 16
15855: PUSH
15856: EMPTY
15857: LIST
15858: LIST
15859: PUSH
15860: LD_INT 25
15862: PUSH
15863: LD_INT 15
15865: PUSH
15866: EMPTY
15867: LIST
15868: LIST
15869: PUSH
15870: EMPTY
15871: LIST
15872: LIST
15873: LIST
15874: LIST
15875: PUSH
15876: EMPTY
15877: LIST
15878: LIST
15879: LIST
15880: PPUSH
15881: CALL_OW 69
15885: PPUSH
15886: LD_STRING other_apemans
15888: PPUSH
15889: LD_INT 3
15891: PPUSH
15892: CALL 6105 0 3
// randomsToSave = FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_nation , nation_russian ] ] ) diff [ Burlak , Karamazov , Petrovova , Gleb , Petrosyan , Titov , Dolgov , Lipshchin , Kirilenkova , Belkov , Belkov2 , Xavier , Gnyevko , Kovalyuk , Scholtze , Kuzmov , Kozlov , Oblukov , Kapitsova ] ;
15896: LD_ADDR_VAR 0 2
15900: PUSH
15901: LD_INT 22
15903: PUSH
15904: LD_INT 3
15906: PUSH
15907: EMPTY
15908: LIST
15909: LIST
15910: PUSH
15911: LD_INT 21
15913: PUSH
15914: LD_INT 1
15916: PUSH
15917: EMPTY
15918: LIST
15919: LIST
15920: PUSH
15921: LD_INT 23
15923: PUSH
15924: LD_INT 3
15926: PUSH
15927: EMPTY
15928: LIST
15929: LIST
15930: PUSH
15931: EMPTY
15932: LIST
15933: LIST
15934: LIST
15935: PPUSH
15936: CALL_OW 69
15940: PUSH
15941: LD_EXP 57
15945: PUSH
15946: LD_EXP 58
15950: PUSH
15951: LD_EXP 59
15955: PUSH
15956: LD_EXP 60
15960: PUSH
15961: LD_EXP 61
15965: PUSH
15966: LD_EXP 62
15970: PUSH
15971: LD_EXP 63
15975: PUSH
15976: LD_EXP 64
15980: PUSH
15981: LD_EXP 65
15985: PUSH
15986: LD_EXP 66
15990: PUSH
15991: LD_EXP 67
15995: PUSH
15996: LD_EXP 68
16000: PUSH
16001: LD_EXP 69
16005: PUSH
16006: LD_EXP 70
16010: PUSH
16011: LD_EXP 71
16015: PUSH
16016: LD_EXP 72
16020: PUSH
16021: LD_EXP 73
16025: PUSH
16026: LD_EXP 74
16030: PUSH
16031: LD_EXP 75
16035: PUSH
16036: EMPTY
16037: LIST
16038: LIST
16039: LIST
16040: LIST
16041: LIST
16042: LIST
16043: LIST
16044: LIST
16045: LIST
16046: LIST
16047: LIST
16048: LIST
16049: LIST
16050: LIST
16051: LIST
16052: LIST
16053: LIST
16054: LIST
16055: LIST
16056: DIFF
16057: ST_TO_ADDR
// ExtSaveCharacters ( randomsToSave , other_survivors , 3 ) ;
16058: LD_VAR 0 2
16062: PPUSH
16063: LD_STRING other_survivors
16065: PPUSH
16066: LD_INT 3
16068: PPUSH
16069: CALL 6105 0 3
// end ;
16073: LD_VAR 0 1
16077: RET
// function SaveGlobalVariables ; begin
16078: LD_INT 0
16080: PPUSH
// SaveBase ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] ] ) , 08_TrockyBase_1 ) ;
16081: LD_INT 22
16083: PUSH
16084: LD_INT 3
16086: PUSH
16087: EMPTY
16088: LIST
16089: LIST
16090: PUSH
16091: LD_INT 21
16093: PUSH
16094: LD_INT 3
16096: PUSH
16097: EMPTY
16098: LIST
16099: LIST
16100: PUSH
16101: EMPTY
16102: LIST
16103: LIST
16104: PPUSH
16105: CALL_OW 69
16109: PPUSH
16110: LD_STRING 08_TrockyBase_1
16112: PPUSH
16113: CALL 8484 0 2
// SaveVariable ( coopWithGensher , 08_CoopWithGensher_2 ) ;
16117: LD_EXP 2
16121: PPUSH
16122: LD_STRING 08_CoopWithGensher_2
16124: PPUSH
16125: CALL_OW 39
// SaveVariable ( HeikeStatus , 08_HeikeStatus_3 ) ;
16129: LD_EXP 3
16133: PPUSH
16134: LD_STRING 08_HeikeStatus_3
16136: PPUSH
16137: CALL_OW 39
// SaveVariable ( Masha , 08_Masha_4 ) ;
16141: LD_EXP 4
16145: PPUSH
16146: LD_STRING 08_Masha_4
16148: PPUSH
16149: CALL_OW 39
// end ; end_of_file
16153: LD_VAR 0 1
16157: RET
// export function CustomEvent ( event ) ; begin
16158: LD_INT 0
16160: PPUSH
// end ;
16161: LD_VAR 0 2
16165: RET
// on BuildingComplete ( building ) do begin if GetBType ( building ) in buildingsToBuild and GetNation ( building ) = nation_russian then
16166: LD_VAR 0 1
16170: PPUSH
16171: CALL_OW 266
16175: PUSH
16176: LD_EXP 8
16180: IN
16181: PUSH
16182: LD_VAR 0 1
16186: PPUSH
16187: CALL_OW 248
16191: PUSH
16192: LD_INT 3
16194: EQUAL
16195: AND
16196: IFFALSE 16219
// buildingsToBuild = buildingsToBuild diff GetBType ( building ) ;
16198: LD_ADDR_EXP 8
16202: PUSH
16203: LD_EXP 8
16207: PUSH
16208: LD_VAR 0 1
16212: PPUSH
16213: CALL_OW 266
16217: DIFF
16218: ST_TO_ADDR
// if GetBType ( building ) = b_depot then
16219: LD_VAR 0 1
16223: PPUSH
16224: CALL_OW 266
16228: PUSH
16229: LD_INT 0
16231: EQUAL
16232: IFFALSE 16283
// begin SetBName ( building , trockij ) ;
16234: LD_VAR 0 1
16238: PPUSH
16239: LD_STRING trockij
16241: PPUSH
16242: CALL_OW 500
// if not dial_BuildDepotBlocker and HeikeCaptured then
16246: LD_EXP 5
16250: NOT
16251: PUSH
16252: LD_EXP 1
16256: AND
16257: IFFALSE 16283
// Dial_EscortHeike ( GetX ( building ) , GetY ( building ) ) ;
16259: LD_VAR 0 1
16263: PPUSH
16264: CALL_OW 250
16268: PPUSH
16269: LD_VAR 0 1
16273: PPUSH
16274: CALL_OW 251
16278: PPUSH
16279: CALL 9149 0 2
// end ; end ;
16283: PPOPN 1
16285: END
// on UpgradeComplete ( building ) do begin if GetBType ( building ) in buildingsToBuild and GetNation ( building ) = nation_russian then
16286: LD_VAR 0 1
16290: PPUSH
16291: CALL_OW 266
16295: PUSH
16296: LD_EXP 8
16300: IN
16301: PUSH
16302: LD_VAR 0 1
16306: PPUSH
16307: CALL_OW 248
16311: PUSH
16312: LD_INT 3
16314: EQUAL
16315: AND
16316: IFFALSE 16339
// buildingsToBuild = buildingsToBuild diff GetBType ( building ) ;
16318: LD_ADDR_EXP 8
16322: PUSH
16323: LD_EXP 8
16327: PUSH
16328: LD_VAR 0 1
16332: PPUSH
16333: CALL_OW 266
16337: DIFF
16338: ST_TO_ADDR
// if GetBType ( building ) = b_barracks and GetNation ( building ) = 2 and not dial_BuildArBarrackBlocker then
16339: LD_VAR 0 1
16343: PPUSH
16344: CALL_OW 266
16348: PUSH
16349: LD_INT 5
16351: EQUAL
16352: PUSH
16353: LD_VAR 0 1
16357: PPUSH
16358: CALL_OW 248
16362: PUSH
16363: LD_INT 2
16365: EQUAL
16366: AND
16367: PUSH
16368: LD_EXP 6
16372: NOT
16373: AND
16374: IFFALSE 16380
// Dial_UpgradeArmoury ;
16376: CALL 9960 0 0
// end ;
16380: PPOPN 1
16382: END
// on ResearchComplete ( research , building ) do begin if research in techsToResearch then
16383: LD_VAR 0 1
16387: PUSH
16388: LD_EXP 9
16392: IN
16393: IFFALSE 16411
// techsToResearch = techsToResearch diff research ;
16395: LD_ADDR_EXP 9
16399: PUSH
16400: LD_EXP 9
16404: PUSH
16405: LD_VAR 0 1
16409: DIFF
16410: ST_TO_ADDR
// if research = tech_LimTeleport then
16411: LD_VAR 0 1
16415: PUSH
16416: LD_INT 37
16418: EQUAL
16419: IFFALSE 16425
// Dial_TeleportTechResearched ;
16421: CALL 13805 0 0
// if research = tech_AdvAI then
16425: LD_VAR 0 1
16429: PUSH
16430: LD_INT 27
16432: EQUAL
16433: IFFALSE 16439
// Dial_ComputerTechResearched ;
16435: CALL 13674 0 0
// end ;
16439: PPOPN 2
16441: END
// on EnterVehicle ( vehicle , human ) do begin if not canChooseMashaVehicle then
16442: LD_EXP 36
16446: NOT
16447: IFFALSE 16451
// exit ;
16449: GO 16618
// wait ( 0 0$1 ) ;
16451: LD_INT 35
16453: PPUSH
16454: CALL_OW 67
// if GetSide ( vehicle ) = 3 and human = Burlak and GetNation ( vehicle ) = nation_russian and GetWeapon ( vehicle ) in [ ru_heavy_machine_gun , ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher ] then
16458: LD_VAR 0 1
16462: PPUSH
16463: CALL_OW 255
16467: PUSH
16468: LD_INT 3
16470: EQUAL
16471: PUSH
16472: LD_VAR 0 2
16476: PUSH
16477: LD_EXP 57
16481: EQUAL
16482: AND
16483: PUSH
16484: LD_VAR 0 1
16488: PPUSH
16489: CALL_OW 248
16493: PUSH
16494: LD_INT 3
16496: EQUAL
16497: AND
16498: PUSH
16499: LD_VAR 0 1
16503: PPUSH
16504: CALL_OW 264
16508: PUSH
16509: LD_INT 42
16511: PUSH
16512: LD_INT 43
16514: PUSH
16515: LD_INT 44
16517: PUSH
16518: LD_INT 46
16520: PUSH
16521: LD_INT 45
16523: PUSH
16524: EMPTY
16525: LIST
16526: LIST
16527: LIST
16528: LIST
16529: LIST
16530: IN
16531: AND
16532: IFFALSE 16618
// begin if Masha then
16534: LD_EXP 4
16538: IFFALSE 16558
// if Masha [ 1 ] = vehicle then
16540: LD_EXP 4
16544: PUSH
16545: LD_INT 1
16547: ARRAY
16548: PUSH
16549: LD_VAR 0 1
16553: EQUAL
16554: IFFALSE 16558
// exit ;
16556: GO 16618
// if firstMashaQuery then
16558: LD_EXP 35
16562: IFFALSE 16596
// begin firstMashaQuery = false ;
16564: LD_ADDR_EXP 35
16568: PUSH
16569: LD_INT 0
16571: ST_TO_ADDR
// if Query ( QMashaQuery ) = 1 then
16572: LD_STRING QMashaQuery
16574: PPUSH
16575: CALL_OW 97
16579: PUSH
16580: LD_INT 1
16582: EQUAL
16583: IFFALSE 16594
// SetMashaData ( vehicle ) ;
16585: LD_VAR 0 1
16589: PPUSH
16590: CALL 8378 0 1
// end else
16594: GO 16618
// begin if Query ( QMashaQuery2 ) = 1 then
16596: LD_STRING QMashaQuery2
16598: PPUSH
16599: CALL_OW 97
16603: PUSH
16604: LD_INT 1
16606: EQUAL
16607: IFFALSE 16618
// SetMashaData ( vehicle ) ;
16609: LD_VAR 0 1
16613: PPUSH
16614: CALL 8378 0 1
// end ; end ; end ;
16618: PPOPN 2
16620: END
// on UnitDestroyed ( unit ) do begin if Masha then
16621: LD_EXP 4
16625: IFFALSE 16650
// if unit = Masha [ 1 ] then
16627: LD_VAR 0 1
16631: PUSH
16632: LD_EXP 4
16636: PUSH
16637: LD_INT 1
16639: ARRAY
16640: EQUAL
16641: IFFALSE 16650
// Masha = [ ] ;
16643: LD_ADDR_EXP 4
16647: PUSH
16648: EMPTY
16649: ST_TO_ADDR
// if unit = Burlak then
16650: LD_VAR 0 1
16654: PUSH
16655: LD_EXP 57
16659: EQUAL
16660: IFFALSE 16666
// Lose_Burlak ;
16662: CALL 15213 0 0
// if GetType ( unit ) = unit_human and GetNation ( unit ) = nation_russian then
16666: LD_VAR 0 1
16670: PPUSH
16671: CALL_OW 247
16675: PUSH
16676: LD_INT 1
16678: EQUAL
16679: PUSH
16680: LD_VAR 0 1
16684: PPUSH
16685: CALL_OW 248
16689: PUSH
16690: LD_INT 3
16692: EQUAL
16693: AND
16694: IFFALSE 16710
// lostUnits = lostUnits + 1 ;
16696: LD_ADDR_EXP 40
16700: PUSH
16701: LD_EXP 40
16705: PUSH
16706: LD_INT 1
16708: PLUS
16709: ST_TO_ADDR
// end ;
16710: PPOPN 1
16712: END
// on UnitGoesToRed ( unit ) do begin if GetType ( unit ) = unit_vehicle and GetNation ( unit ) = nation_russian and GetTech ( tech_LimTeleport , 3 ) = state_researched and not testedTeleport then
16713: LD_VAR 0 1
16717: PPUSH
16718: CALL_OW 247
16722: PUSH
16723: LD_INT 2
16725: EQUAL
16726: PUSH
16727: LD_VAR 0 1
16731: PPUSH
16732: CALL_OW 248
16736: PUSH
16737: LD_INT 3
16739: EQUAL
16740: AND
16741: PUSH
16742: LD_INT 37
16744: PPUSH
16745: LD_INT 3
16747: PPUSH
16748: CALL_OW 321
16752: PUSH
16753: LD_INT 2
16755: EQUAL
16756: AND
16757: PUSH
16758: LD_EXP 39
16762: NOT
16763: AND
16764: IFFALSE 16781
// begin testedTeleport = true ;
16766: LD_ADDR_EXP 39
16770: PUSH
16771: LD_INT 1
16773: ST_TO_ADDR
// ChangeMissionObjectives ( MTeleDone ) ;
16774: LD_STRING MTeleDone
16776: PPUSH
16777: CALL_OW 337
// end ; if unit = Heike then
16781: LD_VAR 0 1
16785: PUSH
16786: LD_EXP 79
16790: EQUAL
16791: IFFALSE 16834
// begin DialogueOn ;
16793: CALL_OW 6
// CenterNowOnUnits ( Heike ) ;
16797: LD_EXP 79
16801: PPUSH
16802: CALL_OW 87
// ForceSay ( Heike , DHeikeKilled-Hke-1 ) ;
16806: LD_EXP 79
16810: PPUSH
16811: LD_STRING DHeikeKilled-Hke-1
16813: PPUSH
16814: CALL_OW 91
// DialogueOff ;
16818: CALL_OW 7
// SetLives ( Heike , 0 ) ;
16822: LD_EXP 79
16826: PPUSH
16827: LD_INT 0
16829: PPUSH
16830: CALL_OW 234
// end ; end ;
16834: PPOPN 1
16836: END
// on Contact ( side1 , side2 ) do begin if side1 = 3 and side2 = 6 then
16837: LD_VAR 0 1
16841: PUSH
16842: LD_INT 3
16844: EQUAL
16845: PUSH
16846: LD_VAR 0 2
16850: PUSH
16851: LD_INT 6
16853: EQUAL
16854: AND
16855: IFFALSE 16861
// Lost_AttackAlly ;
16857: CALL 15228 0 0
// if side1 = 3 and side2 = 2 then
16861: LD_VAR 0 1
16865: PUSH
16866: LD_INT 3
16868: EQUAL
16869: PUSH
16870: LD_VAR 0 2
16874: PUSH
16875: LD_INT 2
16877: EQUAL
16878: AND
16879: IFFALSE 16885
// Dial_AttackGensher ;
16881: CALL 10916 0 0
// if side1 = 3 and side2 = 5 then
16885: LD_VAR 0 1
16889: PUSH
16890: LD_INT 3
16892: EQUAL
16893: PUSH
16894: LD_VAR 0 2
16898: PUSH
16899: LD_INT 5
16901: EQUAL
16902: AND
16903: IFFALSE 16947
// begin SetAttitude ( 3 , 5 , att_enemy , true ) ;
16905: LD_INT 3
16907: PPUSH
16908: LD_INT 5
16910: PPUSH
16911: LD_INT 2
16913: PPUSH
16914: LD_INT 1
16916: PPUSH
16917: CALL_OW 80
// if acceptKurtOffert and not GetSide ( Kurt ) = 2 then
16921: LD_EXP 19
16925: PUSH
16926: LD_EXP 80
16930: PPUSH
16931: CALL_OW 255
16935: PUSH
16936: LD_INT 2
16938: EQUAL
16939: NOT
16940: AND
16941: IFFALSE 16947
// Dial_BetrayedKurt1 ;
16943: CALL 11465 0 0
// end ; if side1 = 3 and side2 = 8 and GetAttitude ( 3 , 8 ) = att_neutral then
16947: LD_VAR 0 1
16951: PUSH
16952: LD_INT 3
16954: EQUAL
16955: PUSH
16956: LD_VAR 0 2
16960: PUSH
16961: LD_INT 8
16963: EQUAL
16964: AND
16965: PUSH
16966: LD_INT 3
16968: PPUSH
16969: LD_INT 8
16971: PPUSH
16972: CALL_OW 81
16976: PUSH
16977: LD_INT 0
16979: EQUAL
16980: AND
16981: IFFALSE 16993
// begin if acceptKurtOffert then
16983: LD_EXP 19
16987: IFFALSE 16993
// Dial_BetrayedKurt2 ;
16989: CALL 11551 0 0
// end ; end ;
16993: PPOPN 2
16995: END
// on VehicleConstructed ( vehicle , building ) do begin SetWeaponDataBuild ( GetWeapon ( vehicle ) , false ) ;
16996: LD_VAR 0 1
17000: PPUSH
17001: CALL_OW 264
17005: PPUSH
17006: LD_INT 0
17008: PPUSH
17009: CALL 6886 0 2
// if GetControl ( vehicle ) = control_computer and not buildCompVehicle then
17013: LD_VAR 0 1
17017: PPUSH
17018: CALL_OW 263
17022: PUSH
17023: LD_INT 3
17025: EQUAL
17026: PUSH
17027: LD_EXP 37
17031: NOT
17032: AND
17033: IFFALSE 17050
// begin buildCompVehicle = true ;
17035: LD_ADDR_EXP 37
17039: PUSH
17040: LD_INT 1
17042: ST_TO_ADDR
// ChangeMissionObjectives ( MAIDone ) ;
17043: LD_STRING MAIDone
17045: PPUSH
17046: CALL_OW 337
// end ; end ;
17050: PPOPN 2
17052: END
// on WeaponPlaced ( building , factory ) do begin SetWeaponDataBuild ( GetBWeapon ( building ) , true ) ;
17053: LD_VAR 0 1
17057: PPUSH
17058: CALL_OW 269
17062: PPUSH
17063: LD_INT 1
17065: PPUSH
17066: CALL 6886 0 2
// end ;
17070: PPOPN 2
17072: END
// on Command ( comandid ) do var i ;
17073: LD_INT 0
17075: PPUSH
// begin if IsOK ( KurtEng ) and GetSide ( KurtEng ) = 3 then
17076: LD_EXP 82
17080: PPUSH
17081: CALL_OW 302
17085: PUSH
17086: LD_EXP 82
17090: PPUSH
17091: CALL_OW 255
17095: PUSH
17096: LD_INT 3
17098: EQUAL
17099: AND
17100: IFFALSE 17309
// if GetTaskList ( KurtEng ) then
17102: LD_EXP 82
17106: PPUSH
17107: CALL_OW 437
17111: IFFALSE 17309
// begin for i := 1 to ( GetTaskList ( KurtEng ) ) do
17113: LD_ADDR_VAR 0 2
17117: PUSH
17118: DOUBLE
17119: LD_INT 1
17121: DEC
17122: ST_TO_ADDR
17123: LD_EXP 82
17127: PPUSH
17128: CALL_OW 437
17132: PUSH
17133: FOR_TO
17134: IFFALSE 17307
// begin if ( GetTaskList ( KurtEng ) [ i ] [ 1 ] in [ F , H , M , U , V , a , h , u , v , ~ , ^ , > , + , ; , 4 , { ] ) or ( GetTaskList ( KurtEng ) [ i ] [ 1 ] = B and GetTaskList ( KurtEng ) [ i ] [ 5 ] = 36 ) then
17136: LD_EXP 82
17140: PPUSH
17141: CALL_OW 437
17145: PUSH
17146: LD_VAR 0 2
17150: ARRAY
17151: PUSH
17152: LD_INT 1
17154: ARRAY
17155: PUSH
17156: LD_STRING F
17158: PUSH
17159: LD_STRING H
17161: PUSH
17162: LD_STRING M
17164: PUSH
17165: LD_STRING U
17167: PUSH
17168: LD_STRING V
17170: PUSH
17171: LD_STRING a
17173: PUSH
17174: LD_STRING h
17176: PUSH
17177: LD_STRING u
17179: PUSH
17180: LD_STRING v
17182: PUSH
17183: LD_STRING ~
17185: PUSH
17186: LD_STRING ^
17188: PUSH
17189: LD_STRING >
17191: PUSH
17192: LD_STRING +
17194: PUSH
17195: LD_STRING ;
17197: PUSH
17198: LD_STRING 4
17200: PUSH
17201: LD_STRING {
17203: PUSH
17204: EMPTY
17205: LIST
17206: LIST
17207: LIST
17208: LIST
17209: LIST
17210: LIST
17211: LIST
17212: LIST
17213: LIST
17214: LIST
17215: LIST
17216: LIST
17217: LIST
17218: LIST
17219: LIST
17220: LIST
17221: IN
17222: PUSH
17223: LD_EXP 82
17227: PPUSH
17228: CALL_OW 437
17232: PUSH
17233: LD_VAR 0 2
17237: ARRAY
17238: PUSH
17239: LD_INT 1
17241: ARRAY
17242: PUSH
17243: LD_STRING B
17245: EQUAL
17246: PUSH
17247: LD_EXP 82
17251: PPUSH
17252: CALL_OW 437
17256: PUSH
17257: LD_VAR 0 2
17261: ARRAY
17262: PUSH
17263: LD_INT 5
17265: ARRAY
17266: PUSH
17267: LD_INT 36
17269: EQUAL
17270: AND
17271: OR
17272: IFFALSE 17276
// else
17274: GO 17305
// begin RemoveTasks ( KurtEng ) ;
17276: LD_EXP 82
17280: PPUSH
17281: CALL_OW 493
// DialogueOn ;
17285: CALL_OW 6
// Say ( Kurt , DMercRefuseBuild-Kurt-1 ) ;
17289: LD_EXP 80
17293: PPUSH
17294: LD_STRING DMercRefuseBuild-Kurt-1
17296: PPUSH
17297: CALL_OW 88
// DialogueOff ;
17301: CALL_OW 7
// end ; end ;
17305: GO 17133
17307: POP
17308: POP
// end ; end ; end_of_file
17309: PPOPN 2
17311: END
// every 0 0$01 do var timer , cratesSpawned ;
17312: GO 17314
17314: DISABLE
17315: LD_INT 0
17317: PPUSH
17318: PPUSH
// begin timer := 1 1$30 ;
17319: LD_ADDR_VAR 0 1
17323: PUSH
17324: LD_INT 3150
17326: ST_TO_ADDR
// repeat wait ( timer ) ;
17327: LD_VAR 0 1
17331: PPUSH
17332: CALL_OW 67
// if cratesSpawned >= 6 and cratesSpawned < 18 then
17336: LD_VAR 0 2
17340: PUSH
17341: LD_INT 6
17343: GREATEREQUAL
17344: PUSH
17345: LD_VAR 0 2
17349: PUSH
17350: LD_INT 18
17352: LESS
17353: AND
17354: IFFALSE 17370
// timer := timer + 0 0$3 ;
17356: LD_ADDR_VAR 0 1
17360: PUSH
17361: LD_VAR 0 1
17365: PUSH
17366: LD_INT 105
17368: PLUS
17369: ST_TO_ADDR
// if cratesSpawned >= 18 then
17370: LD_VAR 0 2
17374: PUSH
17375: LD_INT 18
17377: GREATEREQUAL
17378: IFFALSE 17394
// timer := timer + 0 0$9 ;
17380: LD_ADDR_VAR 0 1
17384: PUSH
17385: LD_VAR 0 1
17389: PUSH
17390: LD_INT 315
17392: PLUS
17393: ST_TO_ADDR
// if timer > 3 3$00 then
17394: LD_VAR 0 1
17398: PUSH
17399: LD_INT 6300
17401: GREATER
17402: IFFALSE 17412
// timer := 0 0$50 ;
17404: LD_ADDR_VAR 0 1
17408: PUSH
17409: LD_INT 1750
17411: ST_TO_ADDR
// CreateCratesArea ( rand ( 3 , 5 ) , CratesSpawnArea , true ) ;
17412: LD_INT 3
17414: PPUSH
17415: LD_INT 5
17417: PPUSH
17418: CALL_OW 12
17422: PPUSH
17423: LD_INT 15
17425: PPUSH
17426: LD_INT 1
17428: PPUSH
17429: CALL_OW 55
// cratesSpawned = cratesSpawned + 1 ;
17433: LD_ADDR_VAR 0 2
17437: PUSH
17438: LD_VAR 0 2
17442: PUSH
17443: LD_INT 1
17445: PLUS
17446: ST_TO_ADDR
// until false ;
17447: LD_INT 0
17449: IFFALSE 17327
// end ; end_of_file
17451: PPOPN 2
17453: END
// every 0 0$1 do
17454: GO 17456
17456: DISABLE
// begin enable ;
17457: ENABLE
// end ;
17458: END
// every 0 0$1 do var building , playerBuildings , playerBuildingsBType ;
17459: GO 17461
17461: DISABLE
17462: LD_INT 0
17464: PPUSH
17465: PPUSH
17466: PPUSH
// begin playerBuildings = FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] , [ f_nation , nation_russian ] ] ) ;
17467: LD_ADDR_VAR 0 2
17471: PUSH
17472: LD_INT 22
17474: PUSH
17475: LD_INT 3
17477: PUSH
17478: EMPTY
17479: LIST
17480: LIST
17481: PUSH
17482: LD_INT 21
17484: PUSH
17485: LD_INT 3
17487: PUSH
17488: EMPTY
17489: LIST
17490: LIST
17491: PUSH
17492: LD_INT 23
17494: PUSH
17495: LD_INT 3
17497: PUSH
17498: EMPTY
17499: LIST
17500: LIST
17501: PUSH
17502: EMPTY
17503: LIST
17504: LIST
17505: LIST
17506: PPUSH
17507: CALL_OW 69
17511: ST_TO_ADDR
// playerBuildingsBType = [ ] ;
17512: LD_ADDR_VAR 0 3
17516: PUSH
17517: EMPTY
17518: ST_TO_ADDR
// for building in playerBuildings do
17519: LD_ADDR_VAR 0 1
17523: PUSH
17524: LD_VAR 0 2
17528: PUSH
17529: FOR_IN
17530: IFFALSE 17555
// playerBuildingsBType = playerBuildingsBType ^ GetBType ( building ) ;
17532: LD_ADDR_VAR 0 3
17536: PUSH
17537: LD_VAR 0 3
17541: PUSH
17542: LD_VAR 0 1
17546: PPUSH
17547: CALL_OW 266
17551: ADD
17552: ST_TO_ADDR
17553: GO 17529
17555: POP
17556: POP
// for building in allBuildings do
17557: LD_ADDR_VAR 0 1
17561: PUSH
17562: LD_EXP 13
17566: PUSH
17567: FOR_IN
17568: IFFALSE 17614
// if not building in playerBuildingsBType and not building in buildingsToBuild then
17570: LD_VAR 0 1
17574: PUSH
17575: LD_VAR 0 3
17579: IN
17580: NOT
17581: PUSH
17582: LD_VAR 0 1
17586: PUSH
17587: LD_EXP 8
17591: IN
17592: NOT
17593: AND
17594: IFFALSE 17612
// buildingsToBuild = buildingsToBuild ^ building ;
17596: LD_ADDR_EXP 8
17600: PUSH
17601: LD_EXP 8
17605: PUSH
17606: LD_VAR 0 1
17610: ADD
17611: ST_TO_ADDR
17612: GO 17567
17614: POP
17615: POP
// enable ;
17616: ENABLE
// end ;
17617: PPOPN 3
17619: END
// every 0 0$1 trigger legionOffertCountdown do
17620: LD_EXP 33
17624: IFFALSE 17644
17626: GO 17628
17628: DISABLE
// begin legionOffertTime = legionOffertTime - 0 0$01 ;
17629: LD_ADDR_EXP 34
17633: PUSH
17634: LD_EXP 34
17638: PUSH
17639: LD_INT 35
17641: MINUS
17642: ST_TO_ADDR
// enable ;
17643: ENABLE
// end ;
17644: END
// every 0 0$1 trigger KurtWaitingForFreeHeike do
17645: LD_EXP 23
17649: IFFALSE 17683
17651: GO 17653
17653: DISABLE
// begin timeToFreeHeike = timeToFreeHeike - 0 0$01 ;
17654: LD_ADDR_EXP 54
17658: PUSH
17659: LD_EXP 54
17663: PUSH
17664: LD_INT 35
17666: MINUS
17667: ST_TO_ADDR
// if timeToFreeHeike <= 0 0$00 then
17668: LD_EXP 54
17672: PUSH
17673: LD_INT 0
17675: LESSEQUAL
17676: IFFALSE 17682
// Dial_PlayerDontSendHeike ;
17678: CALL 11413 0 0
// enable ;
17682: ENABLE
// end ;
17683: END
// every 0 0$1 trigger KurtWaitingForBuildBarrack and GetSide ( KurtEng ) = 3 do
17684: LD_EXP 24
17688: PUSH
17689: LD_EXP 82
17693: PPUSH
17694: CALL_OW 255
17698: PUSH
17699: LD_INT 3
17701: EQUAL
17702: AND
17703: IFFALSE 17776
17705: GO 17707
17707: DISABLE
// begin timeToBuildArBarrack = timeToBuildArBarrack - 0 0$01 ;
17708: LD_ADDR_EXP 55
17712: PUSH
17713: LD_EXP 55
17717: PUSH
17718: LD_INT 35
17720: MINUS
17721: ST_TO_ADDR
// if timeToBuildArBarrack <= 0 0$00 then
17722: LD_EXP 55
17726: PUSH
17727: LD_INT 0
17729: LESSEQUAL
17730: IFFALSE 17775
// begin Dial_BetrayedKurt1 ;
17732: CALL 11465 0 0
// wait ( 2 2$0 ) ;
17736: LD_INT 4200
17738: PPUSH
17739: CALL_OW 67
// SetAttitude ( 3 , 8 , att_enemy , true ) ;
17743: LD_INT 3
17745: PPUSH
17746: LD_INT 8
17748: PPUSH
17749: LD_INT 2
17751: PPUSH
17752: LD_INT 1
17754: PPUSH
17755: CALL_OW 80
// KurtAttack = true ;
17759: LD_ADDR_EXP 25
17763: PUSH
17764: LD_INT 1
17766: ST_TO_ADDR
// KurtWaitingForBuildBarrack = false ;
17767: LD_ADDR_EXP 24
17771: PUSH
17772: LD_INT 0
17774: ST_TO_ADDR
// end ; enable ;
17775: ENABLE
// end ; end_of_file
17776: END
// export currentAmWave , currentArWave ; every 0 0$1 trigger americansAttack do var i ;
17777: LD_EXP 26
17781: IFFALSE 17927
17783: GO 17785
17785: DISABLE
17786: LD_INT 0
17788: PPUSH
// begin currentAmWave = 0 ;
17789: LD_ADDR_EXP 85
17793: PUSH
17794: LD_INT 0
17796: ST_TO_ADDR
// wait ( firstAttackDelay ) ;
17797: LD_EXP 49
17801: PPUSH
17802: CALL_OW 67
// for i := 1 to americansAttackWaves do
17806: LD_ADDR_VAR 0 1
17810: PUSH
17811: DOUBLE
17812: LD_INT 1
17814: DEC
17815: ST_TO_ADDR
17816: LD_EXP 48
17820: PUSH
17821: FOR_TO
17822: IFFALSE 17925
// begin SpawnAmAttackTeam ;
17824: CALL 3214 0 0
// currentAmWave = currentAmWave + 1 ;
17828: LD_ADDR_EXP 85
17832: PUSH
17833: LD_EXP 85
17837: PUSH
17838: LD_INT 1
17840: PLUS
17841: ST_TO_ADDR
// if currentAmWave = 1 then
17842: LD_EXP 85
17846: PUSH
17847: LD_INT 1
17849: EQUAL
17850: IFFALSE 17914
// begin if paidLegionOffert then
17852: LD_EXP 32
17856: IFFALSE 17895
// begin Say ( Burlak , DAmAttackStart-Bur-1 ) ;
17858: LD_EXP 57
17862: PPUSH
17863: LD_STRING DAmAttackStart-Bur-1
17865: PPUSH
17866: CALL_OW 88
// if IsOK ( Gleb ) then
17870: LD_EXP 60
17874: PPUSH
17875: CALL_OW 302
17879: IFFALSE 17893
// Say ( Gleb , DAmAttackStart-Glb-1 ) ;
17881: LD_EXP 60
17885: PPUSH
17886: LD_STRING DAmAttackStart-Glb-1
17888: PPUSH
17889: CALL_OW 88
// end else
17893: GO 17907
// Say ( Burlak , DAmAttackStart-Bur-2 ) ;
17895: LD_EXP 57
17899: PPUSH
17900: LD_STRING DAmAttackStart-Bur-2
17902: PPUSH
17903: CALL_OW 88
// ChangeMissionObjectives ( MEnemy ) ;
17907: LD_STRING MEnemy
17909: PPUSH
17910: CALL_OW 337
// end ; wait ( waveCooldown ) ;
17914: LD_EXP 50
17918: PPUSH
17919: CALL_OW 67
// end ;
17923: GO 17821
17925: POP
17926: POP
// end ;
17927: PPOPN 1
17929: END
// every 0 0$1 trigger currentAmWave = 1 do
17930: LD_EXP 85
17934: PUSH
17935: LD_INT 1
17937: EQUAL
17938: IFFALSE 18027
17940: GO 17942
17942: DISABLE
// Attack ( [ 0 , amAttackTeam , [ [ 115 , 42 ] , [ 51 , 67 ] ] , [ 0 , 0 , 0 , 1 , 1 , 1 , 0 , 0 , 1 , 0 ] ] ) ;
17943: LD_INT 0
17945: PUSH
17946: LD_EXP 78
17950: PUSH
17951: LD_INT 115
17953: PUSH
17954: LD_INT 42
17956: PUSH
17957: EMPTY
17958: LIST
17959: LIST
17960: PUSH
17961: LD_INT 51
17963: PUSH
17964: LD_INT 67
17966: PUSH
17967: EMPTY
17968: LIST
17969: LIST
17970: PUSH
17971: EMPTY
17972: LIST
17973: LIST
17974: PUSH
17975: LD_INT 0
17977: PUSH
17978: LD_INT 0
17980: PUSH
17981: LD_INT 0
17983: PUSH
17984: LD_INT 1
17986: PUSH
17987: LD_INT 1
17989: PUSH
17990: LD_INT 1
17992: PUSH
17993: LD_INT 0
17995: PUSH
17996: LD_INT 0
17998: PUSH
17999: LD_INT 1
18001: PUSH
18002: LD_INT 0
18004: PUSH
18005: EMPTY
18006: LIST
18007: LIST
18008: LIST
18009: LIST
18010: LIST
18011: LIST
18012: LIST
18013: LIST
18014: LIST
18015: LIST
18016: PUSH
18017: EMPTY
18018: LIST
18019: LIST
18020: LIST
18021: LIST
18022: PPUSH
18023: CALL 76297 0 1
18027: END
// every 0 0$1 trigger currentAmWave = 2 do
18028: LD_EXP 85
18032: PUSH
18033: LD_INT 2
18035: EQUAL
18036: IFFALSE 18125
18038: GO 18040
18040: DISABLE
// Attack ( [ 0 , amAttackTeam , [ [ 115 , 42 ] , [ 51 , 67 ] ] , [ 0 , 0 , 0 , 1 , 1 , 1 , 0 , 0 , 1 , 0 ] ] ) ;
18041: LD_INT 0
18043: PUSH
18044: LD_EXP 78
18048: PUSH
18049: LD_INT 115
18051: PUSH
18052: LD_INT 42
18054: PUSH
18055: EMPTY
18056: LIST
18057: LIST
18058: PUSH
18059: LD_INT 51
18061: PUSH
18062: LD_INT 67
18064: PUSH
18065: EMPTY
18066: LIST
18067: LIST
18068: PUSH
18069: EMPTY
18070: LIST
18071: LIST
18072: PUSH
18073: LD_INT 0
18075: PUSH
18076: LD_INT 0
18078: PUSH
18079: LD_INT 0
18081: PUSH
18082: LD_INT 1
18084: PUSH
18085: LD_INT 1
18087: PUSH
18088: LD_INT 1
18090: PUSH
18091: LD_INT 0
18093: PUSH
18094: LD_INT 0
18096: PUSH
18097: LD_INT 1
18099: PUSH
18100: LD_INT 0
18102: PUSH
18103: EMPTY
18104: LIST
18105: LIST
18106: LIST
18107: LIST
18108: LIST
18109: LIST
18110: LIST
18111: LIST
18112: LIST
18113: LIST
18114: PUSH
18115: EMPTY
18116: LIST
18117: LIST
18118: LIST
18119: LIST
18120: PPUSH
18121: CALL 76297 0 1
18125: END
// every 0 0$1 trigger currentAmWave = 3 do
18126: LD_EXP 85
18130: PUSH
18131: LD_INT 3
18133: EQUAL
18134: IFFALSE 18223
18136: GO 18138
18138: DISABLE
// Attack ( [ 0 , amAttackTeam , [ [ 115 , 42 ] , [ 51 , 67 ] ] , [ 0 , 0 , 0 , 1 , 1 , 1 , 0 , 0 , 1 , 0 ] ] ) ;
18139: LD_INT 0
18141: PUSH
18142: LD_EXP 78
18146: PUSH
18147: LD_INT 115
18149: PUSH
18150: LD_INT 42
18152: PUSH
18153: EMPTY
18154: LIST
18155: LIST
18156: PUSH
18157: LD_INT 51
18159: PUSH
18160: LD_INT 67
18162: PUSH
18163: EMPTY
18164: LIST
18165: LIST
18166: PUSH
18167: EMPTY
18168: LIST
18169: LIST
18170: PUSH
18171: LD_INT 0
18173: PUSH
18174: LD_INT 0
18176: PUSH
18177: LD_INT 0
18179: PUSH
18180: LD_INT 1
18182: PUSH
18183: LD_INT 1
18185: PUSH
18186: LD_INT 1
18188: PUSH
18189: LD_INT 0
18191: PUSH
18192: LD_INT 0
18194: PUSH
18195: LD_INT 1
18197: PUSH
18198: LD_INT 0
18200: PUSH
18201: EMPTY
18202: LIST
18203: LIST
18204: LIST
18205: LIST
18206: LIST
18207: LIST
18208: LIST
18209: LIST
18210: LIST
18211: LIST
18212: PUSH
18213: EMPTY
18214: LIST
18215: LIST
18216: LIST
18217: LIST
18218: PPUSH
18219: CALL 76297 0 1
18223: END
// every 0 0$1 trigger KurtAttack do var i ;
18224: LD_EXP 25
18228: IFFALSE 18349
18230: GO 18232
18232: DISABLE
18233: LD_INT 0
18235: PPUSH
// begin currentArWave = 0 ;
18236: LD_ADDR_EXP 86
18240: PUSH
18241: LD_INT 0
18243: ST_TO_ADDR
// wait ( firstAttackDelay ) ;
18244: LD_EXP 49
18248: PPUSH
18249: CALL_OW 67
// for i := 1 to KurtAttackWaves do
18253: LD_ADDR_VAR 0 1
18257: PUSH
18258: DOUBLE
18259: LD_INT 1
18261: DEC
18262: ST_TO_ADDR
18263: LD_EXP 47
18267: PUSH
18268: FOR_TO
18269: IFFALSE 18347
// begin if KurtAttack and IsOK ( Heike ) then
18271: LD_EXP 25
18275: PUSH
18276: LD_EXP 79
18280: PPUSH
18281: CALL_OW 302
18285: AND
18286: IFFALSE 18345
// begin SpawnArAttackTeam ;
18288: CALL 4359 0 0
// currentArWave = currentArWave + 1 ;
18292: LD_ADDR_EXP 86
18296: PUSH
18297: LD_EXP 86
18301: PUSH
18302: LD_INT 1
18304: PLUS
18305: ST_TO_ADDR
// if currentArWave = 2 then
18306: LD_EXP 86
18310: PUSH
18311: LD_INT 2
18313: EQUAL
18314: IFFALSE 18336
// begin SayRadio ( Kurt , DMercAttack-Kurt-1 ) ;
18316: LD_EXP 80
18320: PPUSH
18321: LD_STRING DMercAttack-Kurt-1
18323: PPUSH
18324: CALL_OW 94
// canSendHeike = true ;
18328: LD_ADDR_EXP 28
18332: PUSH
18333: LD_INT 1
18335: ST_TO_ADDR
// end ; wait ( waveCooldown ) ;
18336: LD_EXP 50
18340: PPUSH
18341: CALL_OW 67
// end ; end ;
18345: GO 18268
18347: POP
18348: POP
// end ;
18349: PPOPN 1
18351: END
// every 0 0$1 trigger currentArWave = 1 do
18352: LD_EXP 86
18356: PUSH
18357: LD_INT 1
18359: EQUAL
18360: IFFALSE 18449
18362: GO 18364
18364: DISABLE
// Attack ( [ 0 , arAttackTeam , [ [ 115 , 42 ] , [ 51 , 67 ] ] , [ 0 , 0 , 0 , 1 , 1 , 1 , 0 , 0 , 1 , 0 ] ] ) ;
18365: LD_INT 0
18367: PUSH
18368: LD_EXP 84
18372: PUSH
18373: LD_INT 115
18375: PUSH
18376: LD_INT 42
18378: PUSH
18379: EMPTY
18380: LIST
18381: LIST
18382: PUSH
18383: LD_INT 51
18385: PUSH
18386: LD_INT 67
18388: PUSH
18389: EMPTY
18390: LIST
18391: LIST
18392: PUSH
18393: EMPTY
18394: LIST
18395: LIST
18396: PUSH
18397: LD_INT 0
18399: PUSH
18400: LD_INT 0
18402: PUSH
18403: LD_INT 0
18405: PUSH
18406: LD_INT 1
18408: PUSH
18409: LD_INT 1
18411: PUSH
18412: LD_INT 1
18414: PUSH
18415: LD_INT 0
18417: PUSH
18418: LD_INT 0
18420: PUSH
18421: LD_INT 1
18423: PUSH
18424: LD_INT 0
18426: PUSH
18427: EMPTY
18428: LIST
18429: LIST
18430: LIST
18431: LIST
18432: LIST
18433: LIST
18434: LIST
18435: LIST
18436: LIST
18437: LIST
18438: PUSH
18439: EMPTY
18440: LIST
18441: LIST
18442: LIST
18443: LIST
18444: PPUSH
18445: CALL 76297 0 1
18449: END
// every 0 0$1 trigger currentArWave = 2 do
18450: LD_EXP 86
18454: PUSH
18455: LD_INT 2
18457: EQUAL
18458: IFFALSE 18547
18460: GO 18462
18462: DISABLE
// Attack ( [ 0 , arAttackTeam , [ [ 115 , 42 ] , [ 51 , 67 ] ] , [ 0 , 0 , 0 , 1 , 1 , 1 , 0 , 0 , 1 , 0 ] ] ) ;
18463: LD_INT 0
18465: PUSH
18466: LD_EXP 84
18470: PUSH
18471: LD_INT 115
18473: PUSH
18474: LD_INT 42
18476: PUSH
18477: EMPTY
18478: LIST
18479: LIST
18480: PUSH
18481: LD_INT 51
18483: PUSH
18484: LD_INT 67
18486: PUSH
18487: EMPTY
18488: LIST
18489: LIST
18490: PUSH
18491: EMPTY
18492: LIST
18493: LIST
18494: PUSH
18495: LD_INT 0
18497: PUSH
18498: LD_INT 0
18500: PUSH
18501: LD_INT 0
18503: PUSH
18504: LD_INT 1
18506: PUSH
18507: LD_INT 1
18509: PUSH
18510: LD_INT 1
18512: PUSH
18513: LD_INT 0
18515: PUSH
18516: LD_INT 0
18518: PUSH
18519: LD_INT 1
18521: PUSH
18522: LD_INT 0
18524: PUSH
18525: EMPTY
18526: LIST
18527: LIST
18528: LIST
18529: LIST
18530: LIST
18531: LIST
18532: LIST
18533: LIST
18534: LIST
18535: LIST
18536: PUSH
18537: EMPTY
18538: LIST
18539: LIST
18540: LIST
18541: LIST
18542: PPUSH
18543: CALL 76297 0 1
18547: END
// every 0 0$1 trigger currentArWave = 3 do
18548: LD_EXP 86
18552: PUSH
18553: LD_INT 3
18555: EQUAL
18556: IFFALSE 18645
18558: GO 18560
18560: DISABLE
// Attack ( [ 0 , arAttackTeam , [ [ 115 , 42 ] , [ 51 , 67 ] ] , [ 0 , 0 , 0 , 1 , 1 , 1 , 0 , 0 , 1 , 0 ] ] ) ;
18561: LD_INT 0
18563: PUSH
18564: LD_EXP 84
18568: PUSH
18569: LD_INT 115
18571: PUSH
18572: LD_INT 42
18574: PUSH
18575: EMPTY
18576: LIST
18577: LIST
18578: PUSH
18579: LD_INT 51
18581: PUSH
18582: LD_INT 67
18584: PUSH
18585: EMPTY
18586: LIST
18587: LIST
18588: PUSH
18589: EMPTY
18590: LIST
18591: LIST
18592: PUSH
18593: LD_INT 0
18595: PUSH
18596: LD_INT 0
18598: PUSH
18599: LD_INT 0
18601: PUSH
18602: LD_INT 1
18604: PUSH
18605: LD_INT 1
18607: PUSH
18608: LD_INT 1
18610: PUSH
18611: LD_INT 0
18613: PUSH
18614: LD_INT 0
18616: PUSH
18617: LD_INT 1
18619: PUSH
18620: LD_INT 0
18622: PUSH
18623: EMPTY
18624: LIST
18625: LIST
18626: LIST
18627: LIST
18628: LIST
18629: LIST
18630: LIST
18631: LIST
18632: LIST
18633: LIST
18634: PUSH
18635: EMPTY
18636: LIST
18637: LIST
18638: LIST
18639: LIST
18640: PPUSH
18641: CALL 76297 0 1
18645: END
// every 0 0$1 trigger currentArWave = 4 do
18646: LD_EXP 86
18650: PUSH
18651: LD_INT 4
18653: EQUAL
18654: IFFALSE 18743
18656: GO 18658
18658: DISABLE
// Attack ( [ 0 , arAttackTeam , [ [ 115 , 42 ] , [ 51 , 67 ] ] , [ 0 , 0 , 0 , 1 , 1 , 1 , 0 , 0 , 1 , 0 ] ] ) ;
18659: LD_INT 0
18661: PUSH
18662: LD_EXP 84
18666: PUSH
18667: LD_INT 115
18669: PUSH
18670: LD_INT 42
18672: PUSH
18673: EMPTY
18674: LIST
18675: LIST
18676: PUSH
18677: LD_INT 51
18679: PUSH
18680: LD_INT 67
18682: PUSH
18683: EMPTY
18684: LIST
18685: LIST
18686: PUSH
18687: EMPTY
18688: LIST
18689: LIST
18690: PUSH
18691: LD_INT 0
18693: PUSH
18694: LD_INT 0
18696: PUSH
18697: LD_INT 0
18699: PUSH
18700: LD_INT 1
18702: PUSH
18703: LD_INT 1
18705: PUSH
18706: LD_INT 1
18708: PUSH
18709: LD_INT 0
18711: PUSH
18712: LD_INT 0
18714: PUSH
18715: LD_INT 1
18717: PUSH
18718: LD_INT 0
18720: PUSH
18721: EMPTY
18722: LIST
18723: LIST
18724: LIST
18725: LIST
18726: LIST
18727: LIST
18728: LIST
18729: LIST
18730: LIST
18731: LIST
18732: PUSH
18733: EMPTY
18734: LIST
18735: LIST
18736: LIST
18737: LIST
18738: PPUSH
18739: CALL 76297 0 1
18743: END
// every 0 0$1 trigger currentArWave = 5 do
18744: LD_EXP 86
18748: PUSH
18749: LD_INT 5
18751: EQUAL
18752: IFFALSE 18841
18754: GO 18756
18756: DISABLE
// Attack ( [ 0 , arAttackTeam , [ [ 115 , 42 ] , [ 51 , 67 ] ] , [ 0 , 0 , 0 , 1 , 1 , 1 , 0 , 0 , 1 , 0 ] ] ) ; end_of_file
18757: LD_INT 0
18759: PUSH
18760: LD_EXP 84
18764: PUSH
18765: LD_INT 115
18767: PUSH
18768: LD_INT 42
18770: PUSH
18771: EMPTY
18772: LIST
18773: LIST
18774: PUSH
18775: LD_INT 51
18777: PUSH
18778: LD_INT 67
18780: PUSH
18781: EMPTY
18782: LIST
18783: LIST
18784: PUSH
18785: EMPTY
18786: LIST
18787: LIST
18788: PUSH
18789: LD_INT 0
18791: PUSH
18792: LD_INT 0
18794: PUSH
18795: LD_INT 0
18797: PUSH
18798: LD_INT 1
18800: PUSH
18801: LD_INT 1
18803: PUSH
18804: LD_INT 1
18806: PUSH
18807: LD_INT 0
18809: PUSH
18810: LD_INT 0
18812: PUSH
18813: LD_INT 1
18815: PUSH
18816: LD_INT 0
18818: PUSH
18819: EMPTY
18820: LIST
18821: LIST
18822: LIST
18823: LIST
18824: LIST
18825: LIST
18826: LIST
18827: LIST
18828: LIST
18829: LIST
18830: PUSH
18831: EMPTY
18832: LIST
18833: LIST
18834: LIST
18835: LIST
18836: PPUSH
18837: CALL 76297 0 1
18841: END
// every 0 0$1 do var arVehs , arVeh , nearPlayerUnit ;
18842: GO 18844
18844: DISABLE
18845: LD_INT 0
18847: PPUSH
18848: PPUSH
18849: PPUSH
// begin enable ;
18850: ENABLE
// arVehs = FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_vehicle ] , [ f_empty ] ] ) ;
18851: LD_ADDR_VAR 0 1
18855: PUSH
18856: LD_INT 22
18858: PUSH
18859: LD_INT 8
18861: PUSH
18862: EMPTY
18863: LIST
18864: LIST
18865: PUSH
18866: LD_INT 21
18868: PUSH
18869: LD_INT 2
18871: PUSH
18872: EMPTY
18873: LIST
18874: LIST
18875: PUSH
18876: LD_INT 58
18878: PUSH
18879: EMPTY
18880: LIST
18881: PUSH
18882: EMPTY
18883: LIST
18884: LIST
18885: LIST
18886: PPUSH
18887: CALL_OW 69
18891: ST_TO_ADDR
// if not arVehs or not GetAttitude ( 3 , 8 ) = att_enemy then
18892: LD_VAR 0 1
18896: NOT
18897: PUSH
18898: LD_INT 3
18900: PPUSH
18901: LD_INT 8
18903: PPUSH
18904: CALL_OW 81
18908: PUSH
18909: LD_INT 2
18911: EQUAL
18912: NOT
18913: OR
18914: IFFALSE 18918
// exit ;
18916: GO 19008
// for arVeh in arVehs do
18918: LD_ADDR_VAR 0 2
18922: PUSH
18923: LD_VAR 0 1
18927: PUSH
18928: FOR_IN
18929: IFFALSE 19006
// begin nearPlayerUnit = NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) , arVeh ) ;
18931: LD_ADDR_VAR 0 3
18935: PUSH
18936: LD_INT 22
18938: PUSH
18939: LD_INT 3
18941: PUSH
18942: EMPTY
18943: LIST
18944: LIST
18945: PUSH
18946: LD_INT 21
18948: PUSH
18949: LD_INT 1
18951: PUSH
18952: EMPTY
18953: LIST
18954: LIST
18955: PUSH
18956: EMPTY
18957: LIST
18958: LIST
18959: PPUSH
18960: CALL_OW 69
18964: PPUSH
18965: LD_VAR 0 2
18969: PPUSH
18970: CALL_OW 74
18974: ST_TO_ADDR
// if GetDistUnits ( nearPlayerUnit , arVeh ) <= 2 then
18975: LD_VAR 0 3
18979: PPUSH
18980: LD_VAR 0 2
18984: PPUSH
18985: CALL_OW 296
18989: PUSH
18990: LD_INT 2
18992: LESSEQUAL
18993: IFFALSE 19004
// ComSelfDestruction ( arVeh ) ;
18995: LD_VAR 0 2
18999: PPUSH
19000: CALL_OW 577
// end ;
19004: GO 18928
19006: POP
19007: POP
// end ;
19008: PPOPN 3
19010: END
// every 0 0$1 trigger forceStopKurtAttack do
19011: LD_EXP 27
19015: IFFALSE 19081
19017: GO 19019
19019: DISABLE
// begin KurtAttack = false ;
19020: LD_ADDR_EXP 25
19024: PUSH
19025: LD_INT 0
19027: ST_TO_ADDR
// allowExitFromMap = 4 ;
19028: LD_ADDR_EXP 18
19032: PUSH
19033: LD_INT 4
19035: ST_TO_ADDR
// SetAttitude ( 3 , 8 , att_friend , true ) ;
19036: LD_INT 3
19038: PPUSH
19039: LD_INT 8
19041: PPUSH
19042: LD_INT 1
19044: PPUSH
19045: LD_INT 1
19047: PPUSH
19048: CALL_OW 80
// arAttackTeam = [ ] ;
19052: LD_ADDR_EXP 84
19056: PUSH
19057: EMPTY
19058: ST_TO_ADDR
// ComMoveToArea ( FilterAllUnits ( [ f_side , 8 ] ) , KurtExitMapArea ) ;
19059: LD_INT 22
19061: PUSH
19062: LD_INT 8
19064: PUSH
19065: EMPTY
19066: LIST
19067: LIST
19068: PPUSH
19069: CALL_OW 69
19073: PPUSH
19074: LD_INT 11
19076: PPUSH
19077: CALL_OW 113
// end ; end_of_file end_of_file
19081: END
// every 0 0$01 do var timer , cratesSpawned ;
19082: GO 19084
19084: DISABLE
19085: LD_INT 0
19087: PPUSH
19088: PPUSH
// begin timer := 1 1$30 ;
19089: LD_ADDR_VAR 0 1
19093: PUSH
19094: LD_INT 3150
19096: ST_TO_ADDR
// repeat wait ( timer ) ;
19097: LD_VAR 0 1
19101: PPUSH
19102: CALL_OW 67
// if cratesSpawned >= 6 and cratesSpawned < 18 then
19106: LD_VAR 0 2
19110: PUSH
19111: LD_INT 6
19113: GREATEREQUAL
19114: PUSH
19115: LD_VAR 0 2
19119: PUSH
19120: LD_INT 18
19122: LESS
19123: AND
19124: IFFALSE 19140
// timer := timer + 0 0$3 ;
19126: LD_ADDR_VAR 0 1
19130: PUSH
19131: LD_VAR 0 1
19135: PUSH
19136: LD_INT 105
19138: PLUS
19139: ST_TO_ADDR
// if cratesSpawned >= 18 then
19140: LD_VAR 0 2
19144: PUSH
19145: LD_INT 18
19147: GREATEREQUAL
19148: IFFALSE 19164
// timer := timer + 0 0$9 ;
19150: LD_ADDR_VAR 0 1
19154: PUSH
19155: LD_VAR 0 1
19159: PUSH
19160: LD_INT 315
19162: PLUS
19163: ST_TO_ADDR
// if timer > 3 3$00 then
19164: LD_VAR 0 1
19168: PUSH
19169: LD_INT 6300
19171: GREATER
19172: IFFALSE 19182
// timer := 0 0$50 ;
19174: LD_ADDR_VAR 0 1
19178: PUSH
19179: LD_INT 1750
19181: ST_TO_ADDR
// CreateCratesArea ( rand ( 3 , 5 ) , CratesSpawnArea , true ) ;
19182: LD_INT 3
19184: PPUSH
19185: LD_INT 5
19187: PPUSH
19188: CALL_OW 12
19192: PPUSH
19193: LD_INT 15
19195: PPUSH
19196: LD_INT 1
19198: PPUSH
19199: CALL_OW 55
// cratesSpawned = cratesSpawned + 1 ;
19203: LD_ADDR_VAR 0 2
19207: PUSH
19208: LD_VAR 0 2
19212: PUSH
19213: LD_INT 1
19215: PLUS
19216: ST_TO_ADDR
// until false ;
19217: LD_INT 0
19219: IFFALSE 19097
// end ; end_of_file
19221: PPOPN 2
19223: END
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
19224: LD_INT 0
19226: PPUSH
19227: PPUSH
// if exist_mode then
19228: LD_VAR 0 2
19232: IFFALSE 19257
// unit := CreateCharacter ( prefix & ident ) else
19234: LD_ADDR_VAR 0 5
19238: PUSH
19239: LD_VAR 0 3
19243: PUSH
19244: LD_VAR 0 1
19248: STR
19249: PPUSH
19250: CALL_OW 34
19254: ST_TO_ADDR
19255: GO 19272
// unit := NewCharacter ( ident ) ;
19257: LD_ADDR_VAR 0 5
19261: PUSH
19262: LD_VAR 0 1
19266: PPUSH
19267: CALL_OW 25
19271: ST_TO_ADDR
// result := unit ;
19272: LD_ADDR_VAR 0 4
19276: PUSH
19277: LD_VAR 0 5
19281: ST_TO_ADDR
// end ;
19282: LD_VAR 0 4
19286: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
19287: LD_INT 0
19289: PPUSH
19290: PPUSH
// if not side or not nation then
19291: LD_VAR 0 1
19295: NOT
19296: PUSH
19297: LD_VAR 0 2
19301: NOT
19302: OR
19303: IFFALSE 19307
// exit ;
19305: GO 20075
// case nation of nation_american :
19307: LD_VAR 0 2
19311: PUSH
19312: LD_INT 1
19314: DOUBLE
19315: EQUAL
19316: IFTRUE 19320
19318: GO 19534
19320: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
19321: LD_ADDR_VAR 0 4
19325: PUSH
19326: LD_INT 35
19328: PUSH
19329: LD_INT 45
19331: PUSH
19332: LD_INT 46
19334: PUSH
19335: LD_INT 47
19337: PUSH
19338: LD_INT 82
19340: PUSH
19341: LD_INT 83
19343: PUSH
19344: LD_INT 84
19346: PUSH
19347: LD_INT 85
19349: PUSH
19350: LD_INT 86
19352: PUSH
19353: LD_INT 1
19355: PUSH
19356: LD_INT 2
19358: PUSH
19359: LD_INT 6
19361: PUSH
19362: LD_INT 15
19364: PUSH
19365: LD_INT 16
19367: PUSH
19368: LD_INT 7
19370: PUSH
19371: LD_INT 12
19373: PUSH
19374: LD_INT 13
19376: PUSH
19377: LD_INT 10
19379: PUSH
19380: LD_INT 14
19382: PUSH
19383: LD_INT 20
19385: PUSH
19386: LD_INT 21
19388: PUSH
19389: LD_INT 22
19391: PUSH
19392: LD_INT 25
19394: PUSH
19395: LD_INT 32
19397: PUSH
19398: LD_INT 27
19400: PUSH
19401: LD_INT 36
19403: PUSH
19404: LD_INT 69
19406: PUSH
19407: LD_INT 39
19409: PUSH
19410: LD_INT 34
19412: PUSH
19413: LD_INT 40
19415: PUSH
19416: LD_INT 48
19418: PUSH
19419: LD_INT 49
19421: PUSH
19422: LD_INT 50
19424: PUSH
19425: LD_INT 51
19427: PUSH
19428: LD_INT 52
19430: PUSH
19431: LD_INT 53
19433: PUSH
19434: LD_INT 54
19436: PUSH
19437: LD_INT 55
19439: PUSH
19440: LD_INT 56
19442: PUSH
19443: LD_INT 57
19445: PUSH
19446: LD_INT 58
19448: PUSH
19449: LD_INT 59
19451: PUSH
19452: LD_INT 60
19454: PUSH
19455: LD_INT 61
19457: PUSH
19458: LD_INT 62
19460: PUSH
19461: LD_INT 80
19463: PUSH
19464: LD_INT 82
19466: PUSH
19467: LD_INT 83
19469: PUSH
19470: LD_INT 84
19472: PUSH
19473: LD_INT 85
19475: PUSH
19476: LD_INT 86
19478: PUSH
19479: EMPTY
19480: LIST
19481: LIST
19482: LIST
19483: LIST
19484: LIST
19485: LIST
19486: LIST
19487: LIST
19488: LIST
19489: LIST
19490: LIST
19491: LIST
19492: LIST
19493: LIST
19494: LIST
19495: LIST
19496: LIST
19497: LIST
19498: LIST
19499: LIST
19500: LIST
19501: LIST
19502: LIST
19503: LIST
19504: LIST
19505: LIST
19506: LIST
19507: LIST
19508: LIST
19509: LIST
19510: LIST
19511: LIST
19512: LIST
19513: LIST
19514: LIST
19515: LIST
19516: LIST
19517: LIST
19518: LIST
19519: LIST
19520: LIST
19521: LIST
19522: LIST
19523: LIST
19524: LIST
19525: LIST
19526: LIST
19527: LIST
19528: LIST
19529: LIST
19530: LIST
19531: ST_TO_ADDR
19532: GO 19999
19534: LD_INT 2
19536: DOUBLE
19537: EQUAL
19538: IFTRUE 19542
19540: GO 19768
19542: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 ] ; nation_russian :
19543: LD_ADDR_VAR 0 4
19547: PUSH
19548: LD_INT 35
19550: PUSH
19551: LD_INT 45
19553: PUSH
19554: LD_INT 46
19556: PUSH
19557: LD_INT 47
19559: PUSH
19560: LD_INT 82
19562: PUSH
19563: LD_INT 83
19565: PUSH
19566: LD_INT 84
19568: PUSH
19569: LD_INT 85
19571: PUSH
19572: LD_INT 87
19574: PUSH
19575: LD_INT 70
19577: PUSH
19578: LD_INT 1
19580: PUSH
19581: LD_INT 11
19583: PUSH
19584: LD_INT 3
19586: PUSH
19587: LD_INT 4
19589: PUSH
19590: LD_INT 5
19592: PUSH
19593: LD_INT 6
19595: PUSH
19596: LD_INT 15
19598: PUSH
19599: LD_INT 18
19601: PUSH
19602: LD_INT 7
19604: PUSH
19605: LD_INT 17
19607: PUSH
19608: LD_INT 8
19610: PUSH
19611: LD_INT 20
19613: PUSH
19614: LD_INT 21
19616: PUSH
19617: LD_INT 22
19619: PUSH
19620: LD_INT 72
19622: PUSH
19623: LD_INT 26
19625: PUSH
19626: LD_INT 69
19628: PUSH
19629: LD_INT 39
19631: PUSH
19632: LD_INT 40
19634: PUSH
19635: LD_INT 41
19637: PUSH
19638: LD_INT 42
19640: PUSH
19641: LD_INT 43
19643: PUSH
19644: LD_INT 48
19646: PUSH
19647: LD_INT 49
19649: PUSH
19650: LD_INT 50
19652: PUSH
19653: LD_INT 51
19655: PUSH
19656: LD_INT 52
19658: PUSH
19659: LD_INT 53
19661: PUSH
19662: LD_INT 54
19664: PUSH
19665: LD_INT 55
19667: PUSH
19668: LD_INT 56
19670: PUSH
19671: LD_INT 60
19673: PUSH
19674: LD_INT 61
19676: PUSH
19677: LD_INT 62
19679: PUSH
19680: LD_INT 66
19682: PUSH
19683: LD_INT 67
19685: PUSH
19686: LD_INT 68
19688: PUSH
19689: LD_INT 81
19691: PUSH
19692: LD_INT 82
19694: PUSH
19695: LD_INT 83
19697: PUSH
19698: LD_INT 84
19700: PUSH
19701: LD_INT 85
19703: PUSH
19704: LD_INT 87
19706: PUSH
19707: LD_INT 88
19709: PUSH
19710: EMPTY
19711: LIST
19712: LIST
19713: LIST
19714: LIST
19715: LIST
19716: LIST
19717: LIST
19718: LIST
19719: LIST
19720: LIST
19721: LIST
19722: LIST
19723: LIST
19724: LIST
19725: LIST
19726: LIST
19727: LIST
19728: LIST
19729: LIST
19730: LIST
19731: LIST
19732: LIST
19733: LIST
19734: LIST
19735: LIST
19736: LIST
19737: LIST
19738: LIST
19739: LIST
19740: LIST
19741: LIST
19742: LIST
19743: LIST
19744: LIST
19745: LIST
19746: LIST
19747: LIST
19748: LIST
19749: LIST
19750: LIST
19751: LIST
19752: LIST
19753: LIST
19754: LIST
19755: LIST
19756: LIST
19757: LIST
19758: LIST
19759: LIST
19760: LIST
19761: LIST
19762: LIST
19763: LIST
19764: LIST
19765: ST_TO_ADDR
19766: GO 19999
19768: LD_INT 3
19770: DOUBLE
19771: EQUAL
19772: IFTRUE 19776
19774: GO 19998
19776: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
19777: LD_ADDR_VAR 0 4
19781: PUSH
19782: LD_INT 46
19784: PUSH
19785: LD_INT 47
19787: PUSH
19788: LD_INT 1
19790: PUSH
19791: LD_INT 2
19793: PUSH
19794: LD_INT 82
19796: PUSH
19797: LD_INT 83
19799: PUSH
19800: LD_INT 84
19802: PUSH
19803: LD_INT 85
19805: PUSH
19806: LD_INT 86
19808: PUSH
19809: LD_INT 11
19811: PUSH
19812: LD_INT 9
19814: PUSH
19815: LD_INT 20
19817: PUSH
19818: LD_INT 19
19820: PUSH
19821: LD_INT 21
19823: PUSH
19824: LD_INT 24
19826: PUSH
19827: LD_INT 22
19829: PUSH
19830: LD_INT 25
19832: PUSH
19833: LD_INT 28
19835: PUSH
19836: LD_INT 29
19838: PUSH
19839: LD_INT 30
19841: PUSH
19842: LD_INT 31
19844: PUSH
19845: LD_INT 37
19847: PUSH
19848: LD_INT 38
19850: PUSH
19851: LD_INT 32
19853: PUSH
19854: LD_INT 27
19856: PUSH
19857: LD_INT 33
19859: PUSH
19860: LD_INT 69
19862: PUSH
19863: LD_INT 39
19865: PUSH
19866: LD_INT 34
19868: PUSH
19869: LD_INT 40
19871: PUSH
19872: LD_INT 71
19874: PUSH
19875: LD_INT 23
19877: PUSH
19878: LD_INT 44
19880: PUSH
19881: LD_INT 48
19883: PUSH
19884: LD_INT 49
19886: PUSH
19887: LD_INT 50
19889: PUSH
19890: LD_INT 51
19892: PUSH
19893: LD_INT 52
19895: PUSH
19896: LD_INT 53
19898: PUSH
19899: LD_INT 54
19901: PUSH
19902: LD_INT 55
19904: PUSH
19905: LD_INT 56
19907: PUSH
19908: LD_INT 57
19910: PUSH
19911: LD_INT 58
19913: PUSH
19914: LD_INT 59
19916: PUSH
19917: LD_INT 63
19919: PUSH
19920: LD_INT 64
19922: PUSH
19923: LD_INT 65
19925: PUSH
19926: LD_INT 82
19928: PUSH
19929: LD_INT 83
19931: PUSH
19932: LD_INT 84
19934: PUSH
19935: LD_INT 85
19937: PUSH
19938: LD_INT 86
19940: PUSH
19941: EMPTY
19942: LIST
19943: LIST
19944: LIST
19945: LIST
19946: LIST
19947: LIST
19948: LIST
19949: LIST
19950: LIST
19951: LIST
19952: LIST
19953: LIST
19954: LIST
19955: LIST
19956: LIST
19957: LIST
19958: LIST
19959: LIST
19960: LIST
19961: LIST
19962: LIST
19963: LIST
19964: LIST
19965: LIST
19966: LIST
19967: LIST
19968: LIST
19969: LIST
19970: LIST
19971: LIST
19972: LIST
19973: LIST
19974: LIST
19975: LIST
19976: LIST
19977: LIST
19978: LIST
19979: LIST
19980: LIST
19981: LIST
19982: LIST
19983: LIST
19984: LIST
19985: LIST
19986: LIST
19987: LIST
19988: LIST
19989: LIST
19990: LIST
19991: LIST
19992: LIST
19993: LIST
19994: LIST
19995: ST_TO_ADDR
19996: GO 19999
19998: POP
// if state > - 1 and state < 3 then
19999: LD_VAR 0 3
20003: PUSH
20004: LD_INT 1
20006: NEG
20007: GREATER
20008: PUSH
20009: LD_VAR 0 3
20013: PUSH
20014: LD_INT 3
20016: LESS
20017: AND
20018: IFFALSE 20075
// for i in result do
20020: LD_ADDR_VAR 0 5
20024: PUSH
20025: LD_VAR 0 4
20029: PUSH
20030: FOR_IN
20031: IFFALSE 20073
// if GetTech ( i , side ) <> state then
20033: LD_VAR 0 5
20037: PPUSH
20038: LD_VAR 0 1
20042: PPUSH
20043: CALL_OW 321
20047: PUSH
20048: LD_VAR 0 3
20052: NONEQUAL
20053: IFFALSE 20071
// result := result diff i ;
20055: LD_ADDR_VAR 0 4
20059: PUSH
20060: LD_VAR 0 4
20064: PUSH
20065: LD_VAR 0 5
20069: DIFF
20070: ST_TO_ADDR
20071: GO 20030
20073: POP
20074: POP
// end ;
20075: LD_VAR 0 4
20079: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
20080: LD_INT 0
20082: PPUSH
20083: PPUSH
20084: PPUSH
// result := true ;
20085: LD_ADDR_VAR 0 3
20089: PUSH
20090: LD_INT 1
20092: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
20093: LD_ADDR_VAR 0 5
20097: PUSH
20098: LD_VAR 0 2
20102: PPUSH
20103: CALL_OW 480
20107: ST_TO_ADDR
// if not tmp then
20108: LD_VAR 0 5
20112: NOT
20113: IFFALSE 20117
// exit ;
20115: GO 20166
// for i in tmp do
20117: LD_ADDR_VAR 0 4
20121: PUSH
20122: LD_VAR 0 5
20126: PUSH
20127: FOR_IN
20128: IFFALSE 20164
// if GetTech ( i , side ) <> state_researched then
20130: LD_VAR 0 4
20134: PPUSH
20135: LD_VAR 0 1
20139: PPUSH
20140: CALL_OW 321
20144: PUSH
20145: LD_INT 2
20147: NONEQUAL
20148: IFFALSE 20162
// begin result := false ;
20150: LD_ADDR_VAR 0 3
20154: PUSH
20155: LD_INT 0
20157: ST_TO_ADDR
// exit ;
20158: POP
20159: POP
20160: GO 20166
// end ;
20162: GO 20127
20164: POP
20165: POP
// end ;
20166: LD_VAR 0 3
20170: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
20171: LD_INT 0
20173: PPUSH
20174: PPUSH
20175: PPUSH
20176: PPUSH
20177: PPUSH
20178: PPUSH
20179: PPUSH
20180: PPUSH
20181: PPUSH
20182: PPUSH
20183: PPUSH
20184: PPUSH
20185: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
20186: LD_VAR 0 1
20190: NOT
20191: PUSH
20192: LD_VAR 0 1
20196: PPUSH
20197: CALL_OW 257
20201: PUSH
20202: LD_INT 9
20204: NONEQUAL
20205: OR
20206: IFFALSE 20210
// exit ;
20208: GO 20783
// side := GetSide ( unit ) ;
20210: LD_ADDR_VAR 0 9
20214: PUSH
20215: LD_VAR 0 1
20219: PPUSH
20220: CALL_OW 255
20224: ST_TO_ADDR
// tech_space := tech_spacanom ;
20225: LD_ADDR_VAR 0 12
20229: PUSH
20230: LD_INT 29
20232: ST_TO_ADDR
// tech_time := tech_taurad ;
20233: LD_ADDR_VAR 0 13
20237: PUSH
20238: LD_INT 28
20240: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
20241: LD_ADDR_VAR 0 11
20245: PUSH
20246: LD_VAR 0 1
20250: PPUSH
20251: CALL_OW 310
20255: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
20256: LD_VAR 0 11
20260: PPUSH
20261: CALL_OW 247
20265: PUSH
20266: LD_INT 2
20268: EQUAL
20269: IFFALSE 20273
// exit ;
20271: GO 20783
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
20273: LD_ADDR_VAR 0 8
20277: PUSH
20278: LD_INT 81
20280: PUSH
20281: LD_VAR 0 9
20285: PUSH
20286: EMPTY
20287: LIST
20288: LIST
20289: PUSH
20290: LD_INT 3
20292: PUSH
20293: LD_INT 21
20295: PUSH
20296: LD_INT 3
20298: PUSH
20299: EMPTY
20300: LIST
20301: LIST
20302: PUSH
20303: EMPTY
20304: LIST
20305: LIST
20306: PUSH
20307: EMPTY
20308: LIST
20309: LIST
20310: PPUSH
20311: CALL_OW 69
20315: ST_TO_ADDR
// if not tmp then
20316: LD_VAR 0 8
20320: NOT
20321: IFFALSE 20325
// exit ;
20323: GO 20783
// if in_unit then
20325: LD_VAR 0 11
20329: IFFALSE 20353
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
20331: LD_ADDR_VAR 0 10
20335: PUSH
20336: LD_VAR 0 8
20340: PPUSH
20341: LD_VAR 0 11
20345: PPUSH
20346: CALL_OW 74
20350: ST_TO_ADDR
20351: GO 20373
// enemy := NearestUnitToUnit ( tmp , unit ) ;
20353: LD_ADDR_VAR 0 10
20357: PUSH
20358: LD_VAR 0 8
20362: PPUSH
20363: LD_VAR 0 1
20367: PPUSH
20368: CALL_OW 74
20372: ST_TO_ADDR
// if not enemy then
20373: LD_VAR 0 10
20377: NOT
20378: IFFALSE 20382
// exit ;
20380: GO 20783
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
20382: LD_VAR 0 11
20386: PUSH
20387: LD_VAR 0 11
20391: PPUSH
20392: LD_VAR 0 10
20396: PPUSH
20397: CALL_OW 296
20401: PUSH
20402: LD_INT 13
20404: GREATER
20405: AND
20406: PUSH
20407: LD_VAR 0 1
20411: PPUSH
20412: LD_VAR 0 10
20416: PPUSH
20417: CALL_OW 296
20421: PUSH
20422: LD_INT 12
20424: GREATER
20425: OR
20426: IFFALSE 20430
// exit ;
20428: GO 20783
// missile := [ 1 ] ;
20430: LD_ADDR_VAR 0 14
20434: PUSH
20435: LD_INT 1
20437: PUSH
20438: EMPTY
20439: LIST
20440: ST_TO_ADDR
// if Researched ( side , tech_space ) then
20441: LD_VAR 0 9
20445: PPUSH
20446: LD_VAR 0 12
20450: PPUSH
20451: CALL_OW 325
20455: IFFALSE 20484
// missile := Insert ( missile , missile + 1 , 2 ) ;
20457: LD_ADDR_VAR 0 14
20461: PUSH
20462: LD_VAR 0 14
20466: PPUSH
20467: LD_VAR 0 14
20471: PUSH
20472: LD_INT 1
20474: PLUS
20475: PPUSH
20476: LD_INT 2
20478: PPUSH
20479: CALL_OW 2
20483: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
20484: LD_VAR 0 9
20488: PPUSH
20489: LD_VAR 0 13
20493: PPUSH
20494: CALL_OW 325
20498: PUSH
20499: LD_VAR 0 10
20503: PPUSH
20504: CALL_OW 255
20508: PPUSH
20509: LD_VAR 0 13
20513: PPUSH
20514: CALL_OW 325
20518: NOT
20519: AND
20520: IFFALSE 20549
// missile := Insert ( missile , missile + 1 , 3 ) ;
20522: LD_ADDR_VAR 0 14
20526: PUSH
20527: LD_VAR 0 14
20531: PPUSH
20532: LD_VAR 0 14
20536: PUSH
20537: LD_INT 1
20539: PLUS
20540: PPUSH
20541: LD_INT 3
20543: PPUSH
20544: CALL_OW 2
20548: ST_TO_ADDR
// if missile < 2 then
20549: LD_VAR 0 14
20553: PUSH
20554: LD_INT 2
20556: LESS
20557: IFFALSE 20561
// exit ;
20559: GO 20783
// x := GetX ( enemy ) ;
20561: LD_ADDR_VAR 0 4
20565: PUSH
20566: LD_VAR 0 10
20570: PPUSH
20571: CALL_OW 250
20575: ST_TO_ADDR
// y := GetY ( enemy ) ;
20576: LD_ADDR_VAR 0 5
20580: PUSH
20581: LD_VAR 0 10
20585: PPUSH
20586: CALL_OW 251
20590: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
20591: LD_ADDR_VAR 0 6
20595: PUSH
20596: LD_VAR 0 4
20600: PUSH
20601: LD_INT 1
20603: NEG
20604: PPUSH
20605: LD_INT 1
20607: PPUSH
20608: CALL_OW 12
20612: PLUS
20613: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
20614: LD_ADDR_VAR 0 7
20618: PUSH
20619: LD_VAR 0 5
20623: PUSH
20624: LD_INT 1
20626: NEG
20627: PPUSH
20628: LD_INT 1
20630: PPUSH
20631: CALL_OW 12
20635: PLUS
20636: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
20637: LD_VAR 0 6
20641: PPUSH
20642: LD_VAR 0 7
20646: PPUSH
20647: CALL_OW 488
20651: NOT
20652: IFFALSE 20674
// begin _x := x ;
20654: LD_ADDR_VAR 0 6
20658: PUSH
20659: LD_VAR 0 4
20663: ST_TO_ADDR
// _y := y ;
20664: LD_ADDR_VAR 0 7
20668: PUSH
20669: LD_VAR 0 5
20673: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
20674: LD_ADDR_VAR 0 3
20678: PUSH
20679: LD_INT 1
20681: PPUSH
20682: LD_VAR 0 14
20686: PPUSH
20687: CALL_OW 12
20691: ST_TO_ADDR
// case i of 1 :
20692: LD_VAR 0 3
20696: PUSH
20697: LD_INT 1
20699: DOUBLE
20700: EQUAL
20701: IFTRUE 20705
20703: GO 20722
20705: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
20706: LD_VAR 0 1
20710: PPUSH
20711: LD_VAR 0 10
20715: PPUSH
20716: CALL_OW 115
20720: GO 20783
20722: LD_INT 2
20724: DOUBLE
20725: EQUAL
20726: IFTRUE 20730
20728: GO 20752
20730: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
20731: LD_VAR 0 1
20735: PPUSH
20736: LD_VAR 0 6
20740: PPUSH
20741: LD_VAR 0 7
20745: PPUSH
20746: CALL_OW 153
20750: GO 20783
20752: LD_INT 3
20754: DOUBLE
20755: EQUAL
20756: IFTRUE 20760
20758: GO 20782
20760: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
20761: LD_VAR 0 1
20765: PPUSH
20766: LD_VAR 0 6
20770: PPUSH
20771: LD_VAR 0 7
20775: PPUSH
20776: CALL_OW 154
20780: GO 20783
20782: POP
// end ;
20783: LD_VAR 0 2
20787: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
20788: LD_INT 0
20790: PPUSH
20791: PPUSH
20792: PPUSH
20793: PPUSH
20794: PPUSH
20795: PPUSH
// if not unit or not building then
20796: LD_VAR 0 1
20800: NOT
20801: PUSH
20802: LD_VAR 0 2
20806: NOT
20807: OR
20808: IFFALSE 20812
// exit ;
20810: GO 20970
// x := GetX ( building ) ;
20812: LD_ADDR_VAR 0 5
20816: PUSH
20817: LD_VAR 0 2
20821: PPUSH
20822: CALL_OW 250
20826: ST_TO_ADDR
// y := GetY ( building ) ;
20827: LD_ADDR_VAR 0 6
20831: PUSH
20832: LD_VAR 0 2
20836: PPUSH
20837: CALL_OW 251
20841: ST_TO_ADDR
// for i = 0 to 5 do
20842: LD_ADDR_VAR 0 4
20846: PUSH
20847: DOUBLE
20848: LD_INT 0
20850: DEC
20851: ST_TO_ADDR
20852: LD_INT 5
20854: PUSH
20855: FOR_TO
20856: IFFALSE 20968
// begin _x := ShiftX ( x , i , 3 ) ;
20858: LD_ADDR_VAR 0 7
20862: PUSH
20863: LD_VAR 0 5
20867: PPUSH
20868: LD_VAR 0 4
20872: PPUSH
20873: LD_INT 3
20875: PPUSH
20876: CALL_OW 272
20880: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
20881: LD_ADDR_VAR 0 8
20885: PUSH
20886: LD_VAR 0 6
20890: PPUSH
20891: LD_VAR 0 4
20895: PPUSH
20896: LD_INT 3
20898: PPUSH
20899: CALL_OW 273
20903: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
20904: LD_VAR 0 7
20908: PPUSH
20909: LD_VAR 0 8
20913: PPUSH
20914: CALL_OW 488
20918: NOT
20919: IFFALSE 20923
// continue ;
20921: GO 20855
// if HexInfo ( _x , _y ) = 0 then
20923: LD_VAR 0 7
20927: PPUSH
20928: LD_VAR 0 8
20932: PPUSH
20933: CALL_OW 428
20937: PUSH
20938: LD_INT 0
20940: EQUAL
20941: IFFALSE 20966
// begin ComMoveXY ( unit , _x , _y ) ;
20943: LD_VAR 0 1
20947: PPUSH
20948: LD_VAR 0 7
20952: PPUSH
20953: LD_VAR 0 8
20957: PPUSH
20958: CALL_OW 111
// exit ;
20962: POP
20963: POP
20964: GO 20970
// end ; end ;
20966: GO 20855
20968: POP
20969: POP
// end ;
20970: LD_VAR 0 3
20974: RET
// export function ScanBase ( side , base_area ) ; begin
20975: LD_INT 0
20977: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
20978: LD_ADDR_VAR 0 3
20982: PUSH
20983: LD_VAR 0 2
20987: PPUSH
20988: LD_INT 81
20990: PUSH
20991: LD_VAR 0 1
20995: PUSH
20996: EMPTY
20997: LIST
20998: LIST
20999: PPUSH
21000: CALL_OW 70
21004: ST_TO_ADDR
// end ;
21005: LD_VAR 0 3
21009: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
21010: LD_INT 0
21012: PPUSH
21013: PPUSH
21014: PPUSH
21015: PPUSH
// result := false ;
21016: LD_ADDR_VAR 0 2
21020: PUSH
21021: LD_INT 0
21023: ST_TO_ADDR
// side := GetSide ( unit ) ;
21024: LD_ADDR_VAR 0 3
21028: PUSH
21029: LD_VAR 0 1
21033: PPUSH
21034: CALL_OW 255
21038: ST_TO_ADDR
// nat := GetNation ( unit ) ;
21039: LD_ADDR_VAR 0 4
21043: PUSH
21044: LD_VAR 0 1
21048: PPUSH
21049: CALL_OW 248
21053: ST_TO_ADDR
// case nat of 1 :
21054: LD_VAR 0 4
21058: PUSH
21059: LD_INT 1
21061: DOUBLE
21062: EQUAL
21063: IFTRUE 21067
21065: GO 21078
21067: POP
// tech := tech_lassight ; 2 :
21068: LD_ADDR_VAR 0 5
21072: PUSH
21073: LD_INT 12
21075: ST_TO_ADDR
21076: GO 21117
21078: LD_INT 2
21080: DOUBLE
21081: EQUAL
21082: IFTRUE 21086
21084: GO 21097
21086: POP
// tech := tech_mortar ; 3 :
21087: LD_ADDR_VAR 0 5
21091: PUSH
21092: LD_INT 41
21094: ST_TO_ADDR
21095: GO 21117
21097: LD_INT 3
21099: DOUBLE
21100: EQUAL
21101: IFTRUE 21105
21103: GO 21116
21105: POP
// tech := tech_bazooka ; end ;
21106: LD_ADDR_VAR 0 5
21110: PUSH
21111: LD_INT 44
21113: ST_TO_ADDR
21114: GO 21117
21116: POP
// if Researched ( side , tech ) then
21117: LD_VAR 0 3
21121: PPUSH
21122: LD_VAR 0 5
21126: PPUSH
21127: CALL_OW 325
21131: IFFALSE 21158
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
21133: LD_ADDR_VAR 0 2
21137: PUSH
21138: LD_INT 5
21140: PUSH
21141: LD_INT 8
21143: PUSH
21144: LD_INT 9
21146: PUSH
21147: EMPTY
21148: LIST
21149: LIST
21150: LIST
21151: PUSH
21152: LD_VAR 0 4
21156: ARRAY
21157: ST_TO_ADDR
// end ;
21158: LD_VAR 0 2
21162: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
21163: LD_INT 0
21165: PPUSH
21166: PPUSH
21167: PPUSH
// if not mines then
21168: LD_VAR 0 2
21172: NOT
21173: IFFALSE 21177
// exit ;
21175: GO 21321
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
21177: LD_ADDR_VAR 0 5
21181: PUSH
21182: LD_INT 81
21184: PUSH
21185: LD_VAR 0 1
21189: PUSH
21190: EMPTY
21191: LIST
21192: LIST
21193: PUSH
21194: LD_INT 3
21196: PUSH
21197: LD_INT 21
21199: PUSH
21200: LD_INT 3
21202: PUSH
21203: EMPTY
21204: LIST
21205: LIST
21206: PUSH
21207: EMPTY
21208: LIST
21209: LIST
21210: PUSH
21211: EMPTY
21212: LIST
21213: LIST
21214: PPUSH
21215: CALL_OW 69
21219: ST_TO_ADDR
// for i in mines do
21220: LD_ADDR_VAR 0 4
21224: PUSH
21225: LD_VAR 0 2
21229: PUSH
21230: FOR_IN
21231: IFFALSE 21319
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
21233: LD_VAR 0 4
21237: PUSH
21238: LD_INT 1
21240: ARRAY
21241: PPUSH
21242: LD_VAR 0 4
21246: PUSH
21247: LD_INT 2
21249: ARRAY
21250: PPUSH
21251: CALL_OW 458
21255: NOT
21256: IFFALSE 21260
// continue ;
21258: GO 21230
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
21260: LD_VAR 0 4
21264: PUSH
21265: LD_INT 1
21267: ARRAY
21268: PPUSH
21269: LD_VAR 0 4
21273: PUSH
21274: LD_INT 2
21276: ARRAY
21277: PPUSH
21278: CALL_OW 428
21282: PUSH
21283: LD_VAR 0 5
21287: IN
21288: IFFALSE 21317
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
21290: LD_VAR 0 4
21294: PUSH
21295: LD_INT 1
21297: ARRAY
21298: PPUSH
21299: LD_VAR 0 4
21303: PUSH
21304: LD_INT 2
21306: ARRAY
21307: PPUSH
21308: LD_VAR 0 1
21312: PPUSH
21313: CALL_OW 456
// end ;
21317: GO 21230
21319: POP
21320: POP
// end ;
21321: LD_VAR 0 3
21325: RET
// export function Count ( array ) ; var i ; begin
21326: LD_INT 0
21328: PPUSH
21329: PPUSH
// result := 0 ;
21330: LD_ADDR_VAR 0 2
21334: PUSH
21335: LD_INT 0
21337: ST_TO_ADDR
// for i in array do
21338: LD_ADDR_VAR 0 3
21342: PUSH
21343: LD_VAR 0 1
21347: PUSH
21348: FOR_IN
21349: IFFALSE 21373
// if i then
21351: LD_VAR 0 3
21355: IFFALSE 21371
// result := result + 1 ;
21357: LD_ADDR_VAR 0 2
21361: PUSH
21362: LD_VAR 0 2
21366: PUSH
21367: LD_INT 1
21369: PLUS
21370: ST_TO_ADDR
21371: GO 21348
21373: POP
21374: POP
// end ;
21375: LD_VAR 0 2
21379: RET
// export function IsEmpty ( building ) ; begin
21380: LD_INT 0
21382: PPUSH
// if not building then
21383: LD_VAR 0 1
21387: NOT
21388: IFFALSE 21392
// exit ;
21390: GO 21435
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
21392: LD_ADDR_VAR 0 2
21396: PUSH
21397: LD_VAR 0 1
21401: PUSH
21402: LD_INT 22
21404: PUSH
21405: LD_VAR 0 1
21409: PPUSH
21410: CALL_OW 255
21414: PUSH
21415: EMPTY
21416: LIST
21417: LIST
21418: PUSH
21419: LD_INT 58
21421: PUSH
21422: EMPTY
21423: LIST
21424: PUSH
21425: EMPTY
21426: LIST
21427: LIST
21428: PPUSH
21429: CALL_OW 69
21433: IN
21434: ST_TO_ADDR
// end ;
21435: LD_VAR 0 2
21439: RET
// export function IsNotFull ( building ) ; begin
21440: LD_INT 0
21442: PPUSH
// if not building then
21443: LD_VAR 0 1
21447: NOT
21448: IFFALSE 21452
// exit ;
21450: GO 21471
// result := UnitsInside ( building ) < 6 ;
21452: LD_ADDR_VAR 0 2
21456: PUSH
21457: LD_VAR 0 1
21461: PPUSH
21462: CALL_OW 313
21466: PUSH
21467: LD_INT 6
21469: LESS
21470: ST_TO_ADDR
// end ;
21471: LD_VAR 0 2
21475: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
21476: LD_INT 0
21478: PPUSH
21479: PPUSH
21480: PPUSH
21481: PPUSH
// tmp := [ ] ;
21482: LD_ADDR_VAR 0 3
21486: PUSH
21487: EMPTY
21488: ST_TO_ADDR
// list := [ ] ;
21489: LD_ADDR_VAR 0 5
21493: PUSH
21494: EMPTY
21495: ST_TO_ADDR
// for i = 16 to 25 do
21496: LD_ADDR_VAR 0 4
21500: PUSH
21501: DOUBLE
21502: LD_INT 16
21504: DEC
21505: ST_TO_ADDR
21506: LD_INT 25
21508: PUSH
21509: FOR_TO
21510: IFFALSE 21583
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
21512: LD_ADDR_VAR 0 3
21516: PUSH
21517: LD_VAR 0 3
21521: PUSH
21522: LD_INT 22
21524: PUSH
21525: LD_VAR 0 1
21529: PPUSH
21530: CALL_OW 255
21534: PUSH
21535: EMPTY
21536: LIST
21537: LIST
21538: PUSH
21539: LD_INT 91
21541: PUSH
21542: LD_VAR 0 1
21546: PUSH
21547: LD_INT 6
21549: PUSH
21550: EMPTY
21551: LIST
21552: LIST
21553: LIST
21554: PUSH
21555: LD_INT 30
21557: PUSH
21558: LD_VAR 0 4
21562: PUSH
21563: EMPTY
21564: LIST
21565: LIST
21566: PUSH
21567: EMPTY
21568: LIST
21569: LIST
21570: LIST
21571: PUSH
21572: EMPTY
21573: LIST
21574: PPUSH
21575: CALL_OW 69
21579: ADD
21580: ST_TO_ADDR
21581: GO 21509
21583: POP
21584: POP
// for i = 1 to tmp do
21585: LD_ADDR_VAR 0 4
21589: PUSH
21590: DOUBLE
21591: LD_INT 1
21593: DEC
21594: ST_TO_ADDR
21595: LD_VAR 0 3
21599: PUSH
21600: FOR_TO
21601: IFFALSE 21689
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
21603: LD_ADDR_VAR 0 5
21607: PUSH
21608: LD_VAR 0 5
21612: PUSH
21613: LD_VAR 0 3
21617: PUSH
21618: LD_VAR 0 4
21622: ARRAY
21623: PPUSH
21624: CALL_OW 266
21628: PUSH
21629: LD_VAR 0 3
21633: PUSH
21634: LD_VAR 0 4
21638: ARRAY
21639: PPUSH
21640: CALL_OW 250
21644: PUSH
21645: LD_VAR 0 3
21649: PUSH
21650: LD_VAR 0 4
21654: ARRAY
21655: PPUSH
21656: CALL_OW 251
21660: PUSH
21661: LD_VAR 0 3
21665: PUSH
21666: LD_VAR 0 4
21670: ARRAY
21671: PPUSH
21672: CALL_OW 254
21676: PUSH
21677: EMPTY
21678: LIST
21679: LIST
21680: LIST
21681: LIST
21682: PUSH
21683: EMPTY
21684: LIST
21685: ADD
21686: ST_TO_ADDR
21687: GO 21600
21689: POP
21690: POP
// result := list ;
21691: LD_ADDR_VAR 0 2
21695: PUSH
21696: LD_VAR 0 5
21700: ST_TO_ADDR
// end ;
21701: LD_VAR 0 2
21705: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
21706: LD_INT 0
21708: PPUSH
21709: PPUSH
21710: PPUSH
21711: PPUSH
21712: PPUSH
21713: PPUSH
21714: PPUSH
// if not factory then
21715: LD_VAR 0 1
21719: NOT
21720: IFFALSE 21724
// exit ;
21722: GO 22317
// if control = control_apeman then
21724: LD_VAR 0 4
21728: PUSH
21729: LD_INT 5
21731: EQUAL
21732: IFFALSE 21841
// begin tmp := UnitsInside ( factory ) ;
21734: LD_ADDR_VAR 0 8
21738: PUSH
21739: LD_VAR 0 1
21743: PPUSH
21744: CALL_OW 313
21748: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
21749: LD_VAR 0 8
21753: PPUSH
21754: LD_INT 25
21756: PUSH
21757: LD_INT 12
21759: PUSH
21760: EMPTY
21761: LIST
21762: LIST
21763: PPUSH
21764: CALL_OW 72
21768: NOT
21769: IFFALSE 21779
// control := control_manual ;
21771: LD_ADDR_VAR 0 4
21775: PUSH
21776: LD_INT 1
21778: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
21779: LD_ADDR_VAR 0 8
21783: PUSH
21784: LD_VAR 0 1
21788: PPUSH
21789: CALL 21476 0 1
21793: ST_TO_ADDR
// if tmp then
21794: LD_VAR 0 8
21798: IFFALSE 21841
// begin for i in tmp do
21800: LD_ADDR_VAR 0 7
21804: PUSH
21805: LD_VAR 0 8
21809: PUSH
21810: FOR_IN
21811: IFFALSE 21839
// if i [ 1 ] = b_ext_radio then
21813: LD_VAR 0 7
21817: PUSH
21818: LD_INT 1
21820: ARRAY
21821: PUSH
21822: LD_INT 22
21824: EQUAL
21825: IFFALSE 21837
// begin control := control_remote ;
21827: LD_ADDR_VAR 0 4
21831: PUSH
21832: LD_INT 2
21834: ST_TO_ADDR
// break ;
21835: GO 21839
// end ;
21837: GO 21810
21839: POP
21840: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
21841: LD_VAR 0 1
21845: PPUSH
21846: LD_VAR 0 2
21850: PPUSH
21851: LD_VAR 0 3
21855: PPUSH
21856: LD_VAR 0 4
21860: PPUSH
21861: LD_VAR 0 5
21865: PPUSH
21866: CALL_OW 448
21870: IFFALSE 21905
// begin result := [ chassis , engine , control , weapon ] ;
21872: LD_ADDR_VAR 0 6
21876: PUSH
21877: LD_VAR 0 2
21881: PUSH
21882: LD_VAR 0 3
21886: PUSH
21887: LD_VAR 0 4
21891: PUSH
21892: LD_VAR 0 5
21896: PUSH
21897: EMPTY
21898: LIST
21899: LIST
21900: LIST
21901: LIST
21902: ST_TO_ADDR
// exit ;
21903: GO 22317
// end ; _chassis := AvailableChassisList ( factory ) ;
21905: LD_ADDR_VAR 0 9
21909: PUSH
21910: LD_VAR 0 1
21914: PPUSH
21915: CALL_OW 475
21919: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
21920: LD_ADDR_VAR 0 11
21924: PUSH
21925: LD_VAR 0 1
21929: PPUSH
21930: CALL_OW 476
21934: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
21935: LD_ADDR_VAR 0 12
21939: PUSH
21940: LD_VAR 0 1
21944: PPUSH
21945: CALL_OW 477
21949: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
21950: LD_ADDR_VAR 0 10
21954: PUSH
21955: LD_VAR 0 1
21959: PPUSH
21960: CALL_OW 478
21964: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
21965: LD_VAR 0 9
21969: NOT
21970: PUSH
21971: LD_VAR 0 11
21975: NOT
21976: OR
21977: PUSH
21978: LD_VAR 0 12
21982: NOT
21983: OR
21984: PUSH
21985: LD_VAR 0 10
21989: NOT
21990: OR
21991: IFFALSE 22026
// begin result := [ chassis , engine , control , weapon ] ;
21993: LD_ADDR_VAR 0 6
21997: PUSH
21998: LD_VAR 0 2
22002: PUSH
22003: LD_VAR 0 3
22007: PUSH
22008: LD_VAR 0 4
22012: PUSH
22013: LD_VAR 0 5
22017: PUSH
22018: EMPTY
22019: LIST
22020: LIST
22021: LIST
22022: LIST
22023: ST_TO_ADDR
// exit ;
22024: GO 22317
// end ; if not chassis in _chassis then
22026: LD_VAR 0 2
22030: PUSH
22031: LD_VAR 0 9
22035: IN
22036: NOT
22037: IFFALSE 22063
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
22039: LD_ADDR_VAR 0 2
22043: PUSH
22044: LD_VAR 0 9
22048: PUSH
22049: LD_INT 1
22051: PPUSH
22052: LD_VAR 0 9
22056: PPUSH
22057: CALL_OW 12
22061: ARRAY
22062: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
22063: LD_VAR 0 2
22067: PPUSH
22068: LD_VAR 0 3
22072: PPUSH
22073: CALL 22322 0 2
22077: NOT
22078: IFFALSE 22137
// repeat engine := _engine [ 1 ] ;
22080: LD_ADDR_VAR 0 3
22084: PUSH
22085: LD_VAR 0 11
22089: PUSH
22090: LD_INT 1
22092: ARRAY
22093: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
22094: LD_ADDR_VAR 0 11
22098: PUSH
22099: LD_VAR 0 11
22103: PPUSH
22104: LD_INT 1
22106: PPUSH
22107: CALL_OW 3
22111: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
22112: LD_VAR 0 2
22116: PPUSH
22117: LD_VAR 0 3
22121: PPUSH
22122: CALL 22322 0 2
22126: PUSH
22127: LD_VAR 0 11
22131: PUSH
22132: EMPTY
22133: EQUAL
22134: OR
22135: IFFALSE 22080
// if not control in _control then
22137: LD_VAR 0 4
22141: PUSH
22142: LD_VAR 0 12
22146: IN
22147: NOT
22148: IFFALSE 22174
// control := _control [ rand ( 1 , _control ) ] ;
22150: LD_ADDR_VAR 0 4
22154: PUSH
22155: LD_VAR 0 12
22159: PUSH
22160: LD_INT 1
22162: PPUSH
22163: LD_VAR 0 12
22167: PPUSH
22168: CALL_OW 12
22172: ARRAY
22173: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
22174: LD_VAR 0 2
22178: PPUSH
22179: LD_VAR 0 5
22183: PPUSH
22184: CALL 22542 0 2
22188: NOT
22189: IFFALSE 22248
// repeat weapon := _weapon [ 1 ] ;
22191: LD_ADDR_VAR 0 5
22195: PUSH
22196: LD_VAR 0 10
22200: PUSH
22201: LD_INT 1
22203: ARRAY
22204: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
22205: LD_ADDR_VAR 0 10
22209: PUSH
22210: LD_VAR 0 10
22214: PPUSH
22215: LD_INT 1
22217: PPUSH
22218: CALL_OW 3
22222: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
22223: LD_VAR 0 2
22227: PPUSH
22228: LD_VAR 0 5
22232: PPUSH
22233: CALL 22542 0 2
22237: PUSH
22238: LD_VAR 0 10
22242: PUSH
22243: EMPTY
22244: EQUAL
22245: OR
22246: IFFALSE 22191
// result := [ ] ;
22248: LD_ADDR_VAR 0 6
22252: PUSH
22253: EMPTY
22254: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
22255: LD_VAR 0 1
22259: PPUSH
22260: LD_VAR 0 2
22264: PPUSH
22265: LD_VAR 0 3
22269: PPUSH
22270: LD_VAR 0 4
22274: PPUSH
22275: LD_VAR 0 5
22279: PPUSH
22280: CALL_OW 448
22284: IFFALSE 22317
// result := [ chassis , engine , control , weapon ] ;
22286: LD_ADDR_VAR 0 6
22290: PUSH
22291: LD_VAR 0 2
22295: PUSH
22296: LD_VAR 0 3
22300: PUSH
22301: LD_VAR 0 4
22305: PUSH
22306: LD_VAR 0 5
22310: PUSH
22311: EMPTY
22312: LIST
22313: LIST
22314: LIST
22315: LIST
22316: ST_TO_ADDR
// end ;
22317: LD_VAR 0 6
22321: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
22322: LD_INT 0
22324: PPUSH
// if not chassis or not engine then
22325: LD_VAR 0 1
22329: NOT
22330: PUSH
22331: LD_VAR 0 2
22335: NOT
22336: OR
22337: IFFALSE 22341
// exit ;
22339: GO 22537
// case engine of engine_solar :
22341: LD_VAR 0 2
22345: PUSH
22346: LD_INT 2
22348: DOUBLE
22349: EQUAL
22350: IFTRUE 22354
22352: GO 22392
22354: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
22355: LD_ADDR_VAR 0 3
22359: PUSH
22360: LD_INT 11
22362: PUSH
22363: LD_INT 12
22365: PUSH
22366: LD_INT 13
22368: PUSH
22369: LD_INT 14
22371: PUSH
22372: LD_INT 1
22374: PUSH
22375: LD_INT 2
22377: PUSH
22378: LD_INT 3
22380: PUSH
22381: EMPTY
22382: LIST
22383: LIST
22384: LIST
22385: LIST
22386: LIST
22387: LIST
22388: LIST
22389: ST_TO_ADDR
22390: GO 22521
22392: LD_INT 1
22394: DOUBLE
22395: EQUAL
22396: IFTRUE 22400
22398: GO 22462
22400: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
22401: LD_ADDR_VAR 0 3
22405: PUSH
22406: LD_INT 11
22408: PUSH
22409: LD_INT 12
22411: PUSH
22412: LD_INT 13
22414: PUSH
22415: LD_INT 14
22417: PUSH
22418: LD_INT 1
22420: PUSH
22421: LD_INT 2
22423: PUSH
22424: LD_INT 3
22426: PUSH
22427: LD_INT 4
22429: PUSH
22430: LD_INT 5
22432: PUSH
22433: LD_INT 21
22435: PUSH
22436: LD_INT 23
22438: PUSH
22439: LD_INT 22
22441: PUSH
22442: LD_INT 24
22444: PUSH
22445: EMPTY
22446: LIST
22447: LIST
22448: LIST
22449: LIST
22450: LIST
22451: LIST
22452: LIST
22453: LIST
22454: LIST
22455: LIST
22456: LIST
22457: LIST
22458: LIST
22459: ST_TO_ADDR
22460: GO 22521
22462: LD_INT 3
22464: DOUBLE
22465: EQUAL
22466: IFTRUE 22470
22468: GO 22520
22470: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
22471: LD_ADDR_VAR 0 3
22475: PUSH
22476: LD_INT 13
22478: PUSH
22479: LD_INT 14
22481: PUSH
22482: LD_INT 2
22484: PUSH
22485: LD_INT 3
22487: PUSH
22488: LD_INT 4
22490: PUSH
22491: LD_INT 5
22493: PUSH
22494: LD_INT 21
22496: PUSH
22497: LD_INT 22
22499: PUSH
22500: LD_INT 23
22502: PUSH
22503: LD_INT 24
22505: PUSH
22506: EMPTY
22507: LIST
22508: LIST
22509: LIST
22510: LIST
22511: LIST
22512: LIST
22513: LIST
22514: LIST
22515: LIST
22516: LIST
22517: ST_TO_ADDR
22518: GO 22521
22520: POP
// result := ( chassis in result ) ;
22521: LD_ADDR_VAR 0 3
22525: PUSH
22526: LD_VAR 0 1
22530: PUSH
22531: LD_VAR 0 3
22535: IN
22536: ST_TO_ADDR
// end ;
22537: LD_VAR 0 3
22541: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
22542: LD_INT 0
22544: PPUSH
// if not chassis or not weapon then
22545: LD_VAR 0 1
22549: NOT
22550: PUSH
22551: LD_VAR 0 2
22555: NOT
22556: OR
22557: IFFALSE 22561
// exit ;
22559: GO 23623
// case weapon of us_machine_gun :
22561: LD_VAR 0 2
22565: PUSH
22566: LD_INT 2
22568: DOUBLE
22569: EQUAL
22570: IFTRUE 22574
22572: GO 22604
22574: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
22575: LD_ADDR_VAR 0 3
22579: PUSH
22580: LD_INT 1
22582: PUSH
22583: LD_INT 2
22585: PUSH
22586: LD_INT 3
22588: PUSH
22589: LD_INT 4
22591: PUSH
22592: LD_INT 5
22594: PUSH
22595: EMPTY
22596: LIST
22597: LIST
22598: LIST
22599: LIST
22600: LIST
22601: ST_TO_ADDR
22602: GO 23607
22604: LD_INT 3
22606: DOUBLE
22607: EQUAL
22608: IFTRUE 22612
22610: GO 22642
22612: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
22613: LD_ADDR_VAR 0 3
22617: PUSH
22618: LD_INT 1
22620: PUSH
22621: LD_INT 2
22623: PUSH
22624: LD_INT 3
22626: PUSH
22627: LD_INT 4
22629: PUSH
22630: LD_INT 5
22632: PUSH
22633: EMPTY
22634: LIST
22635: LIST
22636: LIST
22637: LIST
22638: LIST
22639: ST_TO_ADDR
22640: GO 23607
22642: LD_INT 11
22644: DOUBLE
22645: EQUAL
22646: IFTRUE 22650
22648: GO 22680
22650: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
22651: LD_ADDR_VAR 0 3
22655: PUSH
22656: LD_INT 1
22658: PUSH
22659: LD_INT 2
22661: PUSH
22662: LD_INT 3
22664: PUSH
22665: LD_INT 4
22667: PUSH
22668: LD_INT 5
22670: PUSH
22671: EMPTY
22672: LIST
22673: LIST
22674: LIST
22675: LIST
22676: LIST
22677: ST_TO_ADDR
22678: GO 23607
22680: LD_INT 4
22682: DOUBLE
22683: EQUAL
22684: IFTRUE 22688
22686: GO 22714
22688: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
22689: LD_ADDR_VAR 0 3
22693: PUSH
22694: LD_INT 2
22696: PUSH
22697: LD_INT 3
22699: PUSH
22700: LD_INT 4
22702: PUSH
22703: LD_INT 5
22705: PUSH
22706: EMPTY
22707: LIST
22708: LIST
22709: LIST
22710: LIST
22711: ST_TO_ADDR
22712: GO 23607
22714: LD_INT 5
22716: DOUBLE
22717: EQUAL
22718: IFTRUE 22722
22720: GO 22748
22722: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
22723: LD_ADDR_VAR 0 3
22727: PUSH
22728: LD_INT 2
22730: PUSH
22731: LD_INT 3
22733: PUSH
22734: LD_INT 4
22736: PUSH
22737: LD_INT 5
22739: PUSH
22740: EMPTY
22741: LIST
22742: LIST
22743: LIST
22744: LIST
22745: ST_TO_ADDR
22746: GO 23607
22748: LD_INT 9
22750: DOUBLE
22751: EQUAL
22752: IFTRUE 22756
22754: GO 22782
22756: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
22757: LD_ADDR_VAR 0 3
22761: PUSH
22762: LD_INT 2
22764: PUSH
22765: LD_INT 3
22767: PUSH
22768: LD_INT 4
22770: PUSH
22771: LD_INT 5
22773: PUSH
22774: EMPTY
22775: LIST
22776: LIST
22777: LIST
22778: LIST
22779: ST_TO_ADDR
22780: GO 23607
22782: LD_INT 7
22784: DOUBLE
22785: EQUAL
22786: IFTRUE 22790
22788: GO 22816
22790: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
22791: LD_ADDR_VAR 0 3
22795: PUSH
22796: LD_INT 2
22798: PUSH
22799: LD_INT 3
22801: PUSH
22802: LD_INT 4
22804: PUSH
22805: LD_INT 5
22807: PUSH
22808: EMPTY
22809: LIST
22810: LIST
22811: LIST
22812: LIST
22813: ST_TO_ADDR
22814: GO 23607
22816: LD_INT 12
22818: DOUBLE
22819: EQUAL
22820: IFTRUE 22824
22822: GO 22850
22824: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
22825: LD_ADDR_VAR 0 3
22829: PUSH
22830: LD_INT 2
22832: PUSH
22833: LD_INT 3
22835: PUSH
22836: LD_INT 4
22838: PUSH
22839: LD_INT 5
22841: PUSH
22842: EMPTY
22843: LIST
22844: LIST
22845: LIST
22846: LIST
22847: ST_TO_ADDR
22848: GO 23607
22850: LD_INT 13
22852: DOUBLE
22853: EQUAL
22854: IFTRUE 22858
22856: GO 22884
22858: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
22859: LD_ADDR_VAR 0 3
22863: PUSH
22864: LD_INT 2
22866: PUSH
22867: LD_INT 3
22869: PUSH
22870: LD_INT 4
22872: PUSH
22873: LD_INT 5
22875: PUSH
22876: EMPTY
22877: LIST
22878: LIST
22879: LIST
22880: LIST
22881: ST_TO_ADDR
22882: GO 23607
22884: LD_INT 14
22886: DOUBLE
22887: EQUAL
22888: IFTRUE 22892
22890: GO 22910
22892: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
22893: LD_ADDR_VAR 0 3
22897: PUSH
22898: LD_INT 4
22900: PUSH
22901: LD_INT 5
22903: PUSH
22904: EMPTY
22905: LIST
22906: LIST
22907: ST_TO_ADDR
22908: GO 23607
22910: LD_INT 6
22912: DOUBLE
22913: EQUAL
22914: IFTRUE 22918
22916: GO 22936
22918: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
22919: LD_ADDR_VAR 0 3
22923: PUSH
22924: LD_INT 4
22926: PUSH
22927: LD_INT 5
22929: PUSH
22930: EMPTY
22931: LIST
22932: LIST
22933: ST_TO_ADDR
22934: GO 23607
22936: LD_INT 10
22938: DOUBLE
22939: EQUAL
22940: IFTRUE 22944
22942: GO 22962
22944: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
22945: LD_ADDR_VAR 0 3
22949: PUSH
22950: LD_INT 4
22952: PUSH
22953: LD_INT 5
22955: PUSH
22956: EMPTY
22957: LIST
22958: LIST
22959: ST_TO_ADDR
22960: GO 23607
22962: LD_INT 22
22964: DOUBLE
22965: EQUAL
22966: IFTRUE 22970
22968: GO 22996
22970: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
22971: LD_ADDR_VAR 0 3
22975: PUSH
22976: LD_INT 11
22978: PUSH
22979: LD_INT 12
22981: PUSH
22982: LD_INT 13
22984: PUSH
22985: LD_INT 14
22987: PUSH
22988: EMPTY
22989: LIST
22990: LIST
22991: LIST
22992: LIST
22993: ST_TO_ADDR
22994: GO 23607
22996: LD_INT 23
22998: DOUBLE
22999: EQUAL
23000: IFTRUE 23004
23002: GO 23030
23004: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
23005: LD_ADDR_VAR 0 3
23009: PUSH
23010: LD_INT 11
23012: PUSH
23013: LD_INT 12
23015: PUSH
23016: LD_INT 13
23018: PUSH
23019: LD_INT 14
23021: PUSH
23022: EMPTY
23023: LIST
23024: LIST
23025: LIST
23026: LIST
23027: ST_TO_ADDR
23028: GO 23607
23030: LD_INT 24
23032: DOUBLE
23033: EQUAL
23034: IFTRUE 23038
23036: GO 23064
23038: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
23039: LD_ADDR_VAR 0 3
23043: PUSH
23044: LD_INT 11
23046: PUSH
23047: LD_INT 12
23049: PUSH
23050: LD_INT 13
23052: PUSH
23053: LD_INT 14
23055: PUSH
23056: EMPTY
23057: LIST
23058: LIST
23059: LIST
23060: LIST
23061: ST_TO_ADDR
23062: GO 23607
23064: LD_INT 30
23066: DOUBLE
23067: EQUAL
23068: IFTRUE 23072
23070: GO 23098
23072: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
23073: LD_ADDR_VAR 0 3
23077: PUSH
23078: LD_INT 11
23080: PUSH
23081: LD_INT 12
23083: PUSH
23084: LD_INT 13
23086: PUSH
23087: LD_INT 14
23089: PUSH
23090: EMPTY
23091: LIST
23092: LIST
23093: LIST
23094: LIST
23095: ST_TO_ADDR
23096: GO 23607
23098: LD_INT 25
23100: DOUBLE
23101: EQUAL
23102: IFTRUE 23106
23104: GO 23124
23106: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
23107: LD_ADDR_VAR 0 3
23111: PUSH
23112: LD_INT 13
23114: PUSH
23115: LD_INT 14
23117: PUSH
23118: EMPTY
23119: LIST
23120: LIST
23121: ST_TO_ADDR
23122: GO 23607
23124: LD_INT 27
23126: DOUBLE
23127: EQUAL
23128: IFTRUE 23132
23130: GO 23150
23132: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
23133: LD_ADDR_VAR 0 3
23137: PUSH
23138: LD_INT 13
23140: PUSH
23141: LD_INT 14
23143: PUSH
23144: EMPTY
23145: LIST
23146: LIST
23147: ST_TO_ADDR
23148: GO 23607
23150: LD_EXP 159
23154: DOUBLE
23155: EQUAL
23156: IFTRUE 23160
23158: GO 23186
23160: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
23161: LD_ADDR_VAR 0 3
23165: PUSH
23166: LD_INT 11
23168: PUSH
23169: LD_INT 12
23171: PUSH
23172: LD_INT 13
23174: PUSH
23175: LD_INT 14
23177: PUSH
23178: EMPTY
23179: LIST
23180: LIST
23181: LIST
23182: LIST
23183: ST_TO_ADDR
23184: GO 23607
23186: LD_INT 28
23188: DOUBLE
23189: EQUAL
23190: IFTRUE 23194
23192: GO 23212
23194: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
23195: LD_ADDR_VAR 0 3
23199: PUSH
23200: LD_INT 13
23202: PUSH
23203: LD_INT 14
23205: PUSH
23206: EMPTY
23207: LIST
23208: LIST
23209: ST_TO_ADDR
23210: GO 23607
23212: LD_INT 29
23214: DOUBLE
23215: EQUAL
23216: IFTRUE 23220
23218: GO 23238
23220: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
23221: LD_ADDR_VAR 0 3
23225: PUSH
23226: LD_INT 13
23228: PUSH
23229: LD_INT 14
23231: PUSH
23232: EMPTY
23233: LIST
23234: LIST
23235: ST_TO_ADDR
23236: GO 23607
23238: LD_INT 31
23240: DOUBLE
23241: EQUAL
23242: IFTRUE 23246
23244: GO 23264
23246: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
23247: LD_ADDR_VAR 0 3
23251: PUSH
23252: LD_INT 13
23254: PUSH
23255: LD_INT 14
23257: PUSH
23258: EMPTY
23259: LIST
23260: LIST
23261: ST_TO_ADDR
23262: GO 23607
23264: LD_INT 26
23266: DOUBLE
23267: EQUAL
23268: IFTRUE 23272
23270: GO 23290
23272: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
23273: LD_ADDR_VAR 0 3
23277: PUSH
23278: LD_INT 13
23280: PUSH
23281: LD_INT 14
23283: PUSH
23284: EMPTY
23285: LIST
23286: LIST
23287: ST_TO_ADDR
23288: GO 23607
23290: LD_INT 42
23292: DOUBLE
23293: EQUAL
23294: IFTRUE 23298
23296: GO 23324
23298: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
23299: LD_ADDR_VAR 0 3
23303: PUSH
23304: LD_INT 21
23306: PUSH
23307: LD_INT 22
23309: PUSH
23310: LD_INT 23
23312: PUSH
23313: LD_INT 24
23315: PUSH
23316: EMPTY
23317: LIST
23318: LIST
23319: LIST
23320: LIST
23321: ST_TO_ADDR
23322: GO 23607
23324: LD_INT 43
23326: DOUBLE
23327: EQUAL
23328: IFTRUE 23332
23330: GO 23358
23332: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
23333: LD_ADDR_VAR 0 3
23337: PUSH
23338: LD_INT 21
23340: PUSH
23341: LD_INT 22
23343: PUSH
23344: LD_INT 23
23346: PUSH
23347: LD_INT 24
23349: PUSH
23350: EMPTY
23351: LIST
23352: LIST
23353: LIST
23354: LIST
23355: ST_TO_ADDR
23356: GO 23607
23358: LD_INT 44
23360: DOUBLE
23361: EQUAL
23362: IFTRUE 23366
23364: GO 23392
23366: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
23367: LD_ADDR_VAR 0 3
23371: PUSH
23372: LD_INT 21
23374: PUSH
23375: LD_INT 22
23377: PUSH
23378: LD_INT 23
23380: PUSH
23381: LD_INT 24
23383: PUSH
23384: EMPTY
23385: LIST
23386: LIST
23387: LIST
23388: LIST
23389: ST_TO_ADDR
23390: GO 23607
23392: LD_INT 45
23394: DOUBLE
23395: EQUAL
23396: IFTRUE 23400
23398: GO 23426
23400: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
23401: LD_ADDR_VAR 0 3
23405: PUSH
23406: LD_INT 21
23408: PUSH
23409: LD_INT 22
23411: PUSH
23412: LD_INT 23
23414: PUSH
23415: LD_INT 24
23417: PUSH
23418: EMPTY
23419: LIST
23420: LIST
23421: LIST
23422: LIST
23423: ST_TO_ADDR
23424: GO 23607
23426: LD_INT 49
23428: DOUBLE
23429: EQUAL
23430: IFTRUE 23434
23432: GO 23460
23434: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
23435: LD_ADDR_VAR 0 3
23439: PUSH
23440: LD_INT 21
23442: PUSH
23443: LD_INT 22
23445: PUSH
23446: LD_INT 23
23448: PUSH
23449: LD_INT 24
23451: PUSH
23452: EMPTY
23453: LIST
23454: LIST
23455: LIST
23456: LIST
23457: ST_TO_ADDR
23458: GO 23607
23460: LD_INT 51
23462: DOUBLE
23463: EQUAL
23464: IFTRUE 23468
23466: GO 23494
23468: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
23469: LD_ADDR_VAR 0 3
23473: PUSH
23474: LD_INT 21
23476: PUSH
23477: LD_INT 22
23479: PUSH
23480: LD_INT 23
23482: PUSH
23483: LD_INT 24
23485: PUSH
23486: EMPTY
23487: LIST
23488: LIST
23489: LIST
23490: LIST
23491: ST_TO_ADDR
23492: GO 23607
23494: LD_INT 52
23496: DOUBLE
23497: EQUAL
23498: IFTRUE 23502
23500: GO 23528
23502: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
23503: LD_ADDR_VAR 0 3
23507: PUSH
23508: LD_INT 21
23510: PUSH
23511: LD_INT 22
23513: PUSH
23514: LD_INT 23
23516: PUSH
23517: LD_INT 24
23519: PUSH
23520: EMPTY
23521: LIST
23522: LIST
23523: LIST
23524: LIST
23525: ST_TO_ADDR
23526: GO 23607
23528: LD_INT 53
23530: DOUBLE
23531: EQUAL
23532: IFTRUE 23536
23534: GO 23554
23536: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
23537: LD_ADDR_VAR 0 3
23541: PUSH
23542: LD_INT 23
23544: PUSH
23545: LD_INT 24
23547: PUSH
23548: EMPTY
23549: LIST
23550: LIST
23551: ST_TO_ADDR
23552: GO 23607
23554: LD_INT 46
23556: DOUBLE
23557: EQUAL
23558: IFTRUE 23562
23560: GO 23580
23562: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
23563: LD_ADDR_VAR 0 3
23567: PUSH
23568: LD_INT 23
23570: PUSH
23571: LD_INT 24
23573: PUSH
23574: EMPTY
23575: LIST
23576: LIST
23577: ST_TO_ADDR
23578: GO 23607
23580: LD_INT 47
23582: DOUBLE
23583: EQUAL
23584: IFTRUE 23588
23586: GO 23606
23588: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
23589: LD_ADDR_VAR 0 3
23593: PUSH
23594: LD_INT 23
23596: PUSH
23597: LD_INT 24
23599: PUSH
23600: EMPTY
23601: LIST
23602: LIST
23603: ST_TO_ADDR
23604: GO 23607
23606: POP
// result := ( chassis in result ) ;
23607: LD_ADDR_VAR 0 3
23611: PUSH
23612: LD_VAR 0 1
23616: PUSH
23617: LD_VAR 0 3
23621: IN
23622: ST_TO_ADDR
// end ;
23623: LD_VAR 0 3
23627: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
23628: LD_INT 0
23630: PPUSH
23631: PPUSH
23632: PPUSH
23633: PPUSH
23634: PPUSH
23635: PPUSH
23636: PPUSH
// result := array ;
23637: LD_ADDR_VAR 0 5
23641: PUSH
23642: LD_VAR 0 1
23646: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
23647: LD_VAR 0 1
23651: NOT
23652: PUSH
23653: LD_VAR 0 2
23657: NOT
23658: OR
23659: PUSH
23660: LD_VAR 0 3
23664: NOT
23665: OR
23666: PUSH
23667: LD_VAR 0 2
23671: PUSH
23672: LD_VAR 0 1
23676: GREATER
23677: OR
23678: PUSH
23679: LD_VAR 0 3
23683: PUSH
23684: LD_VAR 0 1
23688: GREATER
23689: OR
23690: IFFALSE 23694
// exit ;
23692: GO 23990
// if direction then
23694: LD_VAR 0 4
23698: IFFALSE 23762
// begin d := 1 ;
23700: LD_ADDR_VAR 0 9
23704: PUSH
23705: LD_INT 1
23707: ST_TO_ADDR
// if i_from > i_to then
23708: LD_VAR 0 2
23712: PUSH
23713: LD_VAR 0 3
23717: GREATER
23718: IFFALSE 23744
// length := ( array - i_from ) + i_to else
23720: LD_ADDR_VAR 0 11
23724: PUSH
23725: LD_VAR 0 1
23729: PUSH
23730: LD_VAR 0 2
23734: MINUS
23735: PUSH
23736: LD_VAR 0 3
23740: PLUS
23741: ST_TO_ADDR
23742: GO 23760
// length := i_to - i_from ;
23744: LD_ADDR_VAR 0 11
23748: PUSH
23749: LD_VAR 0 3
23753: PUSH
23754: LD_VAR 0 2
23758: MINUS
23759: ST_TO_ADDR
// end else
23760: GO 23823
// begin d := - 1 ;
23762: LD_ADDR_VAR 0 9
23766: PUSH
23767: LD_INT 1
23769: NEG
23770: ST_TO_ADDR
// if i_from > i_to then
23771: LD_VAR 0 2
23775: PUSH
23776: LD_VAR 0 3
23780: GREATER
23781: IFFALSE 23801
// length := i_from - i_to else
23783: LD_ADDR_VAR 0 11
23787: PUSH
23788: LD_VAR 0 2
23792: PUSH
23793: LD_VAR 0 3
23797: MINUS
23798: ST_TO_ADDR
23799: GO 23823
// length := ( array - i_to ) + i_from ;
23801: LD_ADDR_VAR 0 11
23805: PUSH
23806: LD_VAR 0 1
23810: PUSH
23811: LD_VAR 0 3
23815: MINUS
23816: PUSH
23817: LD_VAR 0 2
23821: PLUS
23822: ST_TO_ADDR
// end ; if not length then
23823: LD_VAR 0 11
23827: NOT
23828: IFFALSE 23832
// exit ;
23830: GO 23990
// tmp := array ;
23832: LD_ADDR_VAR 0 10
23836: PUSH
23837: LD_VAR 0 1
23841: ST_TO_ADDR
// for i = 1 to length do
23842: LD_ADDR_VAR 0 6
23846: PUSH
23847: DOUBLE
23848: LD_INT 1
23850: DEC
23851: ST_TO_ADDR
23852: LD_VAR 0 11
23856: PUSH
23857: FOR_TO
23858: IFFALSE 23978
// begin for j = 1 to array do
23860: LD_ADDR_VAR 0 7
23864: PUSH
23865: DOUBLE
23866: LD_INT 1
23868: DEC
23869: ST_TO_ADDR
23870: LD_VAR 0 1
23874: PUSH
23875: FOR_TO
23876: IFFALSE 23964
// begin k := j + d ;
23878: LD_ADDR_VAR 0 8
23882: PUSH
23883: LD_VAR 0 7
23887: PUSH
23888: LD_VAR 0 9
23892: PLUS
23893: ST_TO_ADDR
// if k > array then
23894: LD_VAR 0 8
23898: PUSH
23899: LD_VAR 0 1
23903: GREATER
23904: IFFALSE 23914
// k := 1 ;
23906: LD_ADDR_VAR 0 8
23910: PUSH
23911: LD_INT 1
23913: ST_TO_ADDR
// if not k then
23914: LD_VAR 0 8
23918: NOT
23919: IFFALSE 23931
// k := array ;
23921: LD_ADDR_VAR 0 8
23925: PUSH
23926: LD_VAR 0 1
23930: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
23931: LD_ADDR_VAR 0 10
23935: PUSH
23936: LD_VAR 0 10
23940: PPUSH
23941: LD_VAR 0 8
23945: PPUSH
23946: LD_VAR 0 1
23950: PUSH
23951: LD_VAR 0 7
23955: ARRAY
23956: PPUSH
23957: CALL_OW 1
23961: ST_TO_ADDR
// end ;
23962: GO 23875
23964: POP
23965: POP
// array := tmp ;
23966: LD_ADDR_VAR 0 1
23970: PUSH
23971: LD_VAR 0 10
23975: ST_TO_ADDR
// end ;
23976: GO 23857
23978: POP
23979: POP
// result := array ;
23980: LD_ADDR_VAR 0 5
23984: PUSH
23985: LD_VAR 0 1
23989: ST_TO_ADDR
// end ;
23990: LD_VAR 0 5
23994: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
23995: LD_INT 0
23997: PPUSH
23998: PPUSH
// result := 0 ;
23999: LD_ADDR_VAR 0 3
24003: PUSH
24004: LD_INT 0
24006: ST_TO_ADDR
// if not array or not value in array then
24007: LD_VAR 0 1
24011: NOT
24012: PUSH
24013: LD_VAR 0 2
24017: PUSH
24018: LD_VAR 0 1
24022: IN
24023: NOT
24024: OR
24025: IFFALSE 24029
// exit ;
24027: GO 24083
// for i = 1 to array do
24029: LD_ADDR_VAR 0 4
24033: PUSH
24034: DOUBLE
24035: LD_INT 1
24037: DEC
24038: ST_TO_ADDR
24039: LD_VAR 0 1
24043: PUSH
24044: FOR_TO
24045: IFFALSE 24081
// if value = array [ i ] then
24047: LD_VAR 0 2
24051: PUSH
24052: LD_VAR 0 1
24056: PUSH
24057: LD_VAR 0 4
24061: ARRAY
24062: EQUAL
24063: IFFALSE 24079
// begin result := i ;
24065: LD_ADDR_VAR 0 3
24069: PUSH
24070: LD_VAR 0 4
24074: ST_TO_ADDR
// exit ;
24075: POP
24076: POP
24077: GO 24083
// end ;
24079: GO 24044
24081: POP
24082: POP
// end ;
24083: LD_VAR 0 3
24087: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
24088: LD_INT 0
24090: PPUSH
// vc_chassis := chassis ;
24091: LD_ADDR_OWVAR 37
24095: PUSH
24096: LD_VAR 0 1
24100: ST_TO_ADDR
// vc_engine := engine ;
24101: LD_ADDR_OWVAR 39
24105: PUSH
24106: LD_VAR 0 2
24110: ST_TO_ADDR
// vc_control := control ;
24111: LD_ADDR_OWVAR 38
24115: PUSH
24116: LD_VAR 0 3
24120: ST_TO_ADDR
// vc_weapon := weapon ;
24121: LD_ADDR_OWVAR 40
24125: PUSH
24126: LD_VAR 0 4
24130: ST_TO_ADDR
// vc_fuel_battery := fuel ;
24131: LD_ADDR_OWVAR 41
24135: PUSH
24136: LD_VAR 0 5
24140: ST_TO_ADDR
// end ;
24141: LD_VAR 0 6
24145: RET
// export function WantPlant ( unit ) ; var task ; begin
24146: LD_INT 0
24148: PPUSH
24149: PPUSH
// result := false ;
24150: LD_ADDR_VAR 0 2
24154: PUSH
24155: LD_INT 0
24157: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
24158: LD_ADDR_VAR 0 3
24162: PUSH
24163: LD_VAR 0 1
24167: PPUSH
24168: CALL_OW 437
24172: ST_TO_ADDR
// if task then
24173: LD_VAR 0 3
24177: IFFALSE 24205
// if task [ 1 ] [ 1 ] = p then
24179: LD_VAR 0 3
24183: PUSH
24184: LD_INT 1
24186: ARRAY
24187: PUSH
24188: LD_INT 1
24190: ARRAY
24191: PUSH
24192: LD_STRING p
24194: EQUAL
24195: IFFALSE 24205
// result := true ;
24197: LD_ADDR_VAR 0 2
24201: PUSH
24202: LD_INT 1
24204: ST_TO_ADDR
// end ;
24205: LD_VAR 0 2
24209: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
24210: LD_INT 0
24212: PPUSH
24213: PPUSH
24214: PPUSH
24215: PPUSH
// if pos < 1 then
24216: LD_VAR 0 2
24220: PUSH
24221: LD_INT 1
24223: LESS
24224: IFFALSE 24228
// exit ;
24226: GO 24531
// if pos = 1 then
24228: LD_VAR 0 2
24232: PUSH
24233: LD_INT 1
24235: EQUAL
24236: IFFALSE 24269
// result := Replace ( arr , pos [ 1 ] , value ) else
24238: LD_ADDR_VAR 0 4
24242: PUSH
24243: LD_VAR 0 1
24247: PPUSH
24248: LD_VAR 0 2
24252: PUSH
24253: LD_INT 1
24255: ARRAY
24256: PPUSH
24257: LD_VAR 0 3
24261: PPUSH
24262: CALL_OW 1
24266: ST_TO_ADDR
24267: GO 24531
// begin tmp := arr ;
24269: LD_ADDR_VAR 0 6
24273: PUSH
24274: LD_VAR 0 1
24278: ST_TO_ADDR
// s_arr := [ tmp ] ;
24279: LD_ADDR_VAR 0 7
24283: PUSH
24284: LD_VAR 0 6
24288: PUSH
24289: EMPTY
24290: LIST
24291: ST_TO_ADDR
// for i = 1 to pos - 1 do
24292: LD_ADDR_VAR 0 5
24296: PUSH
24297: DOUBLE
24298: LD_INT 1
24300: DEC
24301: ST_TO_ADDR
24302: LD_VAR 0 2
24306: PUSH
24307: LD_INT 1
24309: MINUS
24310: PUSH
24311: FOR_TO
24312: IFFALSE 24357
// begin tmp := tmp [ pos [ i ] ] ;
24314: LD_ADDR_VAR 0 6
24318: PUSH
24319: LD_VAR 0 6
24323: PUSH
24324: LD_VAR 0 2
24328: PUSH
24329: LD_VAR 0 5
24333: ARRAY
24334: ARRAY
24335: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
24336: LD_ADDR_VAR 0 7
24340: PUSH
24341: LD_VAR 0 7
24345: PUSH
24346: LD_VAR 0 6
24350: PUSH
24351: EMPTY
24352: LIST
24353: ADD
24354: ST_TO_ADDR
// end ;
24355: GO 24311
24357: POP
24358: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
24359: LD_ADDR_VAR 0 6
24363: PUSH
24364: LD_VAR 0 6
24368: PPUSH
24369: LD_VAR 0 2
24373: PUSH
24374: LD_VAR 0 2
24378: ARRAY
24379: PPUSH
24380: LD_VAR 0 3
24384: PPUSH
24385: CALL_OW 1
24389: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
24390: LD_ADDR_VAR 0 7
24394: PUSH
24395: LD_VAR 0 7
24399: PPUSH
24400: LD_VAR 0 7
24404: PPUSH
24405: LD_VAR 0 6
24409: PPUSH
24410: CALL_OW 1
24414: ST_TO_ADDR
// for i = s_arr downto 2 do
24415: LD_ADDR_VAR 0 5
24419: PUSH
24420: DOUBLE
24421: LD_VAR 0 7
24425: INC
24426: ST_TO_ADDR
24427: LD_INT 2
24429: PUSH
24430: FOR_DOWNTO
24431: IFFALSE 24515
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
24433: LD_ADDR_VAR 0 6
24437: PUSH
24438: LD_VAR 0 7
24442: PUSH
24443: LD_VAR 0 5
24447: PUSH
24448: LD_INT 1
24450: MINUS
24451: ARRAY
24452: PPUSH
24453: LD_VAR 0 2
24457: PUSH
24458: LD_VAR 0 5
24462: PUSH
24463: LD_INT 1
24465: MINUS
24466: ARRAY
24467: PPUSH
24468: LD_VAR 0 7
24472: PUSH
24473: LD_VAR 0 5
24477: ARRAY
24478: PPUSH
24479: CALL_OW 1
24483: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
24484: LD_ADDR_VAR 0 7
24488: PUSH
24489: LD_VAR 0 7
24493: PPUSH
24494: LD_VAR 0 5
24498: PUSH
24499: LD_INT 1
24501: MINUS
24502: PPUSH
24503: LD_VAR 0 6
24507: PPUSH
24508: CALL_OW 1
24512: ST_TO_ADDR
// end ;
24513: GO 24430
24515: POP
24516: POP
// result := s_arr [ 1 ] ;
24517: LD_ADDR_VAR 0 4
24521: PUSH
24522: LD_VAR 0 7
24526: PUSH
24527: LD_INT 1
24529: ARRAY
24530: ST_TO_ADDR
// end ; end ;
24531: LD_VAR 0 4
24535: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
24536: LD_INT 0
24538: PPUSH
24539: PPUSH
// if not list then
24540: LD_VAR 0 1
24544: NOT
24545: IFFALSE 24549
// exit ;
24547: GO 24640
// i := list [ pos1 ] ;
24549: LD_ADDR_VAR 0 5
24553: PUSH
24554: LD_VAR 0 1
24558: PUSH
24559: LD_VAR 0 2
24563: ARRAY
24564: ST_TO_ADDR
// if not i then
24565: LD_VAR 0 5
24569: NOT
24570: IFFALSE 24574
// exit ;
24572: GO 24640
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
24574: LD_ADDR_VAR 0 1
24578: PUSH
24579: LD_VAR 0 1
24583: PPUSH
24584: LD_VAR 0 2
24588: PPUSH
24589: LD_VAR 0 1
24593: PUSH
24594: LD_VAR 0 3
24598: ARRAY
24599: PPUSH
24600: CALL_OW 1
24604: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
24605: LD_ADDR_VAR 0 1
24609: PUSH
24610: LD_VAR 0 1
24614: PPUSH
24615: LD_VAR 0 3
24619: PPUSH
24620: LD_VAR 0 5
24624: PPUSH
24625: CALL_OW 1
24629: ST_TO_ADDR
// result := list ;
24630: LD_ADDR_VAR 0 4
24634: PUSH
24635: LD_VAR 0 1
24639: ST_TO_ADDR
// end ;
24640: LD_VAR 0 4
24644: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
24645: LD_INT 0
24647: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
24648: LD_ADDR_VAR 0 5
24652: PUSH
24653: LD_VAR 0 1
24657: PPUSH
24658: CALL_OW 250
24662: PPUSH
24663: LD_VAR 0 1
24667: PPUSH
24668: CALL_OW 251
24672: PPUSH
24673: LD_VAR 0 2
24677: PPUSH
24678: LD_VAR 0 3
24682: PPUSH
24683: LD_VAR 0 4
24687: PPUSH
24688: CALL 24698 0 5
24692: ST_TO_ADDR
// end ;
24693: LD_VAR 0 5
24697: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
24698: LD_INT 0
24700: PPUSH
24701: PPUSH
24702: PPUSH
24703: PPUSH
// if not list then
24704: LD_VAR 0 3
24708: NOT
24709: IFFALSE 24713
// exit ;
24711: GO 25101
// result := [ ] ;
24713: LD_ADDR_VAR 0 6
24717: PUSH
24718: EMPTY
24719: ST_TO_ADDR
// for i in list do
24720: LD_ADDR_VAR 0 7
24724: PUSH
24725: LD_VAR 0 3
24729: PUSH
24730: FOR_IN
24731: IFFALSE 24933
// begin tmp := GetDistUnitXY ( i , x , y ) ;
24733: LD_ADDR_VAR 0 9
24737: PUSH
24738: LD_VAR 0 7
24742: PPUSH
24743: LD_VAR 0 1
24747: PPUSH
24748: LD_VAR 0 2
24752: PPUSH
24753: CALL_OW 297
24757: ST_TO_ADDR
// if not result then
24758: LD_VAR 0 6
24762: NOT
24763: IFFALSE 24789
// result := [ [ i , tmp ] ] else
24765: LD_ADDR_VAR 0 6
24769: PUSH
24770: LD_VAR 0 7
24774: PUSH
24775: LD_VAR 0 9
24779: PUSH
24780: EMPTY
24781: LIST
24782: LIST
24783: PUSH
24784: EMPTY
24785: LIST
24786: ST_TO_ADDR
24787: GO 24931
// begin if result [ result ] [ 2 ] < tmp then
24789: LD_VAR 0 6
24793: PUSH
24794: LD_VAR 0 6
24798: ARRAY
24799: PUSH
24800: LD_INT 2
24802: ARRAY
24803: PUSH
24804: LD_VAR 0 9
24808: LESS
24809: IFFALSE 24851
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
24811: LD_ADDR_VAR 0 6
24815: PUSH
24816: LD_VAR 0 6
24820: PPUSH
24821: LD_VAR 0 6
24825: PUSH
24826: LD_INT 1
24828: PLUS
24829: PPUSH
24830: LD_VAR 0 7
24834: PUSH
24835: LD_VAR 0 9
24839: PUSH
24840: EMPTY
24841: LIST
24842: LIST
24843: PPUSH
24844: CALL_OW 2
24848: ST_TO_ADDR
24849: GO 24931
// for j = 1 to result do
24851: LD_ADDR_VAR 0 8
24855: PUSH
24856: DOUBLE
24857: LD_INT 1
24859: DEC
24860: ST_TO_ADDR
24861: LD_VAR 0 6
24865: PUSH
24866: FOR_TO
24867: IFFALSE 24929
// begin if tmp < result [ j ] [ 2 ] then
24869: LD_VAR 0 9
24873: PUSH
24874: LD_VAR 0 6
24878: PUSH
24879: LD_VAR 0 8
24883: ARRAY
24884: PUSH
24885: LD_INT 2
24887: ARRAY
24888: LESS
24889: IFFALSE 24927
// begin result := Insert ( result , j , [ i , tmp ] ) ;
24891: LD_ADDR_VAR 0 6
24895: PUSH
24896: LD_VAR 0 6
24900: PPUSH
24901: LD_VAR 0 8
24905: PPUSH
24906: LD_VAR 0 7
24910: PUSH
24911: LD_VAR 0 9
24915: PUSH
24916: EMPTY
24917: LIST
24918: LIST
24919: PPUSH
24920: CALL_OW 2
24924: ST_TO_ADDR
// break ;
24925: GO 24929
// end ; end ;
24927: GO 24866
24929: POP
24930: POP
// end ; end ;
24931: GO 24730
24933: POP
24934: POP
// if result and not asc then
24935: LD_VAR 0 6
24939: PUSH
24940: LD_VAR 0 4
24944: NOT
24945: AND
24946: IFFALSE 25021
// begin tmp := result ;
24948: LD_ADDR_VAR 0 9
24952: PUSH
24953: LD_VAR 0 6
24957: ST_TO_ADDR
// for i = tmp downto 1 do
24958: LD_ADDR_VAR 0 7
24962: PUSH
24963: DOUBLE
24964: LD_VAR 0 9
24968: INC
24969: ST_TO_ADDR
24970: LD_INT 1
24972: PUSH
24973: FOR_DOWNTO
24974: IFFALSE 25019
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
24976: LD_ADDR_VAR 0 6
24980: PUSH
24981: LD_VAR 0 6
24985: PPUSH
24986: LD_VAR 0 9
24990: PUSH
24991: LD_VAR 0 7
24995: MINUS
24996: PUSH
24997: LD_INT 1
24999: PLUS
25000: PPUSH
25001: LD_VAR 0 9
25005: PUSH
25006: LD_VAR 0 7
25010: ARRAY
25011: PPUSH
25012: CALL_OW 1
25016: ST_TO_ADDR
25017: GO 24973
25019: POP
25020: POP
// end ; tmp := [ ] ;
25021: LD_ADDR_VAR 0 9
25025: PUSH
25026: EMPTY
25027: ST_TO_ADDR
// if mode then
25028: LD_VAR 0 5
25032: IFFALSE 25101
// begin for i = 1 to result do
25034: LD_ADDR_VAR 0 7
25038: PUSH
25039: DOUBLE
25040: LD_INT 1
25042: DEC
25043: ST_TO_ADDR
25044: LD_VAR 0 6
25048: PUSH
25049: FOR_TO
25050: IFFALSE 25089
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
25052: LD_ADDR_VAR 0 9
25056: PUSH
25057: LD_VAR 0 9
25061: PPUSH
25062: LD_VAR 0 7
25066: PPUSH
25067: LD_VAR 0 6
25071: PUSH
25072: LD_VAR 0 7
25076: ARRAY
25077: PUSH
25078: LD_INT 1
25080: ARRAY
25081: PPUSH
25082: CALL_OW 1
25086: ST_TO_ADDR
25087: GO 25049
25089: POP
25090: POP
// result := tmp ;
25091: LD_ADDR_VAR 0 6
25095: PUSH
25096: LD_VAR 0 9
25100: ST_TO_ADDR
// end ; end ;
25101: LD_VAR 0 6
25105: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
25106: LD_INT 0
25108: PPUSH
25109: PPUSH
25110: PPUSH
25111: PPUSH
25112: PPUSH
25113: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
25114: LD_ADDR_VAR 0 5
25118: PUSH
25119: LD_INT 0
25121: PUSH
25122: LD_INT 0
25124: PUSH
25125: LD_INT 0
25127: PUSH
25128: EMPTY
25129: PUSH
25130: EMPTY
25131: LIST
25132: LIST
25133: LIST
25134: LIST
25135: ST_TO_ADDR
// if not x or not y then
25136: LD_VAR 0 2
25140: NOT
25141: PUSH
25142: LD_VAR 0 3
25146: NOT
25147: OR
25148: IFFALSE 25152
// exit ;
25150: GO 26804
// if not range then
25152: LD_VAR 0 4
25156: NOT
25157: IFFALSE 25167
// range := 10 ;
25159: LD_ADDR_VAR 0 4
25163: PUSH
25164: LD_INT 10
25166: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
25167: LD_ADDR_VAR 0 8
25171: PUSH
25172: LD_INT 81
25174: PUSH
25175: LD_VAR 0 1
25179: PUSH
25180: EMPTY
25181: LIST
25182: LIST
25183: PUSH
25184: LD_INT 92
25186: PUSH
25187: LD_VAR 0 2
25191: PUSH
25192: LD_VAR 0 3
25196: PUSH
25197: LD_VAR 0 4
25201: PUSH
25202: EMPTY
25203: LIST
25204: LIST
25205: LIST
25206: LIST
25207: PUSH
25208: LD_INT 3
25210: PUSH
25211: LD_INT 21
25213: PUSH
25214: LD_INT 3
25216: PUSH
25217: EMPTY
25218: LIST
25219: LIST
25220: PUSH
25221: EMPTY
25222: LIST
25223: LIST
25224: PUSH
25225: EMPTY
25226: LIST
25227: LIST
25228: LIST
25229: PPUSH
25230: CALL_OW 69
25234: ST_TO_ADDR
// if not tmp then
25235: LD_VAR 0 8
25239: NOT
25240: IFFALSE 25244
// exit ;
25242: GO 26804
// for i in tmp do
25244: LD_ADDR_VAR 0 6
25248: PUSH
25249: LD_VAR 0 8
25253: PUSH
25254: FOR_IN
25255: IFFALSE 26779
// begin points := [ 0 , 0 , 0 ] ;
25257: LD_ADDR_VAR 0 9
25261: PUSH
25262: LD_INT 0
25264: PUSH
25265: LD_INT 0
25267: PUSH
25268: LD_INT 0
25270: PUSH
25271: EMPTY
25272: LIST
25273: LIST
25274: LIST
25275: ST_TO_ADDR
// bpoints := 1 ;
25276: LD_ADDR_VAR 0 10
25280: PUSH
25281: LD_INT 1
25283: ST_TO_ADDR
// case GetType ( i ) of unit_human :
25284: LD_VAR 0 6
25288: PPUSH
25289: CALL_OW 247
25293: PUSH
25294: LD_INT 1
25296: DOUBLE
25297: EQUAL
25298: IFTRUE 25302
25300: GO 25880
25302: POP
// begin if GetClass ( i ) = 1 then
25303: LD_VAR 0 6
25307: PPUSH
25308: CALL_OW 257
25312: PUSH
25313: LD_INT 1
25315: EQUAL
25316: IFFALSE 25337
// points := [ 10 , 5 , 3 ] ;
25318: LD_ADDR_VAR 0 9
25322: PUSH
25323: LD_INT 10
25325: PUSH
25326: LD_INT 5
25328: PUSH
25329: LD_INT 3
25331: PUSH
25332: EMPTY
25333: LIST
25334: LIST
25335: LIST
25336: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
25337: LD_VAR 0 6
25341: PPUSH
25342: CALL_OW 257
25346: PUSH
25347: LD_INT 2
25349: PUSH
25350: LD_INT 3
25352: PUSH
25353: LD_INT 4
25355: PUSH
25356: EMPTY
25357: LIST
25358: LIST
25359: LIST
25360: IN
25361: IFFALSE 25382
// points := [ 3 , 2 , 1 ] ;
25363: LD_ADDR_VAR 0 9
25367: PUSH
25368: LD_INT 3
25370: PUSH
25371: LD_INT 2
25373: PUSH
25374: LD_INT 1
25376: PUSH
25377: EMPTY
25378: LIST
25379: LIST
25380: LIST
25381: ST_TO_ADDR
// if GetClass ( i ) = 5 then
25382: LD_VAR 0 6
25386: PPUSH
25387: CALL_OW 257
25391: PUSH
25392: LD_INT 5
25394: EQUAL
25395: IFFALSE 25416
// points := [ 130 , 5 , 2 ] ;
25397: LD_ADDR_VAR 0 9
25401: PUSH
25402: LD_INT 130
25404: PUSH
25405: LD_INT 5
25407: PUSH
25408: LD_INT 2
25410: PUSH
25411: EMPTY
25412: LIST
25413: LIST
25414: LIST
25415: ST_TO_ADDR
// if GetClass ( i ) = 8 then
25416: LD_VAR 0 6
25420: PPUSH
25421: CALL_OW 257
25425: PUSH
25426: LD_INT 8
25428: EQUAL
25429: IFFALSE 25450
// points := [ 35 , 35 , 30 ] ;
25431: LD_ADDR_VAR 0 9
25435: PUSH
25436: LD_INT 35
25438: PUSH
25439: LD_INT 35
25441: PUSH
25442: LD_INT 30
25444: PUSH
25445: EMPTY
25446: LIST
25447: LIST
25448: LIST
25449: ST_TO_ADDR
// if GetClass ( i ) = 9 then
25450: LD_VAR 0 6
25454: PPUSH
25455: CALL_OW 257
25459: PUSH
25460: LD_INT 9
25462: EQUAL
25463: IFFALSE 25484
// points := [ 20 , 55 , 40 ] ;
25465: LD_ADDR_VAR 0 9
25469: PUSH
25470: LD_INT 20
25472: PUSH
25473: LD_INT 55
25475: PUSH
25476: LD_INT 40
25478: PUSH
25479: EMPTY
25480: LIST
25481: LIST
25482: LIST
25483: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
25484: LD_VAR 0 6
25488: PPUSH
25489: CALL_OW 257
25493: PUSH
25494: LD_INT 12
25496: PUSH
25497: LD_INT 16
25499: PUSH
25500: EMPTY
25501: LIST
25502: LIST
25503: IN
25504: IFFALSE 25525
// points := [ 5 , 3 , 2 ] ;
25506: LD_ADDR_VAR 0 9
25510: PUSH
25511: LD_INT 5
25513: PUSH
25514: LD_INT 3
25516: PUSH
25517: LD_INT 2
25519: PUSH
25520: EMPTY
25521: LIST
25522: LIST
25523: LIST
25524: ST_TO_ADDR
// if GetClass ( i ) = 17 then
25525: LD_VAR 0 6
25529: PPUSH
25530: CALL_OW 257
25534: PUSH
25535: LD_INT 17
25537: EQUAL
25538: IFFALSE 25559
// points := [ 100 , 50 , 75 ] ;
25540: LD_ADDR_VAR 0 9
25544: PUSH
25545: LD_INT 100
25547: PUSH
25548: LD_INT 50
25550: PUSH
25551: LD_INT 75
25553: PUSH
25554: EMPTY
25555: LIST
25556: LIST
25557: LIST
25558: ST_TO_ADDR
// if GetClass ( i ) = 15 then
25559: LD_VAR 0 6
25563: PPUSH
25564: CALL_OW 257
25568: PUSH
25569: LD_INT 15
25571: EQUAL
25572: IFFALSE 25593
// points := [ 10 , 5 , 3 ] ;
25574: LD_ADDR_VAR 0 9
25578: PUSH
25579: LD_INT 10
25581: PUSH
25582: LD_INT 5
25584: PUSH
25585: LD_INT 3
25587: PUSH
25588: EMPTY
25589: LIST
25590: LIST
25591: LIST
25592: ST_TO_ADDR
// if GetClass ( i ) = 14 then
25593: LD_VAR 0 6
25597: PPUSH
25598: CALL_OW 257
25602: PUSH
25603: LD_INT 14
25605: EQUAL
25606: IFFALSE 25627
// points := [ 10 , 0 , 0 ] ;
25608: LD_ADDR_VAR 0 9
25612: PUSH
25613: LD_INT 10
25615: PUSH
25616: LD_INT 0
25618: PUSH
25619: LD_INT 0
25621: PUSH
25622: EMPTY
25623: LIST
25624: LIST
25625: LIST
25626: ST_TO_ADDR
// if GetClass ( i ) = 11 then
25627: LD_VAR 0 6
25631: PPUSH
25632: CALL_OW 257
25636: PUSH
25637: LD_INT 11
25639: EQUAL
25640: IFFALSE 25661
// points := [ 30 , 10 , 5 ] ;
25642: LD_ADDR_VAR 0 9
25646: PUSH
25647: LD_INT 30
25649: PUSH
25650: LD_INT 10
25652: PUSH
25653: LD_INT 5
25655: PUSH
25656: EMPTY
25657: LIST
25658: LIST
25659: LIST
25660: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
25661: LD_VAR 0 1
25665: PPUSH
25666: LD_INT 5
25668: PPUSH
25669: CALL_OW 321
25673: PUSH
25674: LD_INT 2
25676: EQUAL
25677: IFFALSE 25694
// bpoints := bpoints * 1.8 ;
25679: LD_ADDR_VAR 0 10
25683: PUSH
25684: LD_VAR 0 10
25688: PUSH
25689: LD_REAL  1.80000000000000E+0000
25692: MUL
25693: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
25694: LD_VAR 0 6
25698: PPUSH
25699: CALL_OW 257
25703: PUSH
25704: LD_INT 1
25706: PUSH
25707: LD_INT 2
25709: PUSH
25710: LD_INT 3
25712: PUSH
25713: LD_INT 4
25715: PUSH
25716: EMPTY
25717: LIST
25718: LIST
25719: LIST
25720: LIST
25721: IN
25722: PUSH
25723: LD_VAR 0 1
25727: PPUSH
25728: LD_INT 51
25730: PPUSH
25731: CALL_OW 321
25735: PUSH
25736: LD_INT 2
25738: EQUAL
25739: AND
25740: IFFALSE 25757
// bpoints := bpoints * 1.2 ;
25742: LD_ADDR_VAR 0 10
25746: PUSH
25747: LD_VAR 0 10
25751: PUSH
25752: LD_REAL  1.20000000000000E+0000
25755: MUL
25756: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
25757: LD_VAR 0 6
25761: PPUSH
25762: CALL_OW 257
25766: PUSH
25767: LD_INT 5
25769: PUSH
25770: LD_INT 7
25772: PUSH
25773: LD_INT 9
25775: PUSH
25776: EMPTY
25777: LIST
25778: LIST
25779: LIST
25780: IN
25781: PUSH
25782: LD_VAR 0 1
25786: PPUSH
25787: LD_INT 52
25789: PPUSH
25790: CALL_OW 321
25794: PUSH
25795: LD_INT 2
25797: EQUAL
25798: AND
25799: IFFALSE 25816
// bpoints := bpoints * 1.5 ;
25801: LD_ADDR_VAR 0 10
25805: PUSH
25806: LD_VAR 0 10
25810: PUSH
25811: LD_REAL  1.50000000000000E+0000
25814: MUL
25815: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
25816: LD_VAR 0 1
25820: PPUSH
25821: LD_INT 66
25823: PPUSH
25824: CALL_OW 321
25828: PUSH
25829: LD_INT 2
25831: EQUAL
25832: IFFALSE 25849
// bpoints := bpoints * 1.1 ;
25834: LD_ADDR_VAR 0 10
25838: PUSH
25839: LD_VAR 0 10
25843: PUSH
25844: LD_REAL  1.10000000000000E+0000
25847: MUL
25848: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
25849: LD_ADDR_VAR 0 10
25853: PUSH
25854: LD_VAR 0 10
25858: PUSH
25859: LD_VAR 0 6
25863: PPUSH
25864: LD_INT 1
25866: PPUSH
25867: CALL_OW 259
25871: PUSH
25872: LD_REAL  1.15000000000000E+0000
25875: MUL
25876: MUL
25877: ST_TO_ADDR
// end ; unit_vehicle :
25878: GO 26708
25880: LD_INT 2
25882: DOUBLE
25883: EQUAL
25884: IFTRUE 25888
25886: GO 26696
25888: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
25889: LD_VAR 0 6
25893: PPUSH
25894: CALL_OW 264
25898: PUSH
25899: LD_INT 2
25901: PUSH
25902: LD_INT 42
25904: PUSH
25905: LD_INT 24
25907: PUSH
25908: EMPTY
25909: LIST
25910: LIST
25911: LIST
25912: IN
25913: IFFALSE 25934
// points := [ 25 , 5 , 3 ] ;
25915: LD_ADDR_VAR 0 9
25919: PUSH
25920: LD_INT 25
25922: PUSH
25923: LD_INT 5
25925: PUSH
25926: LD_INT 3
25928: PUSH
25929: EMPTY
25930: LIST
25931: LIST
25932: LIST
25933: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
25934: LD_VAR 0 6
25938: PPUSH
25939: CALL_OW 264
25943: PUSH
25944: LD_INT 4
25946: PUSH
25947: LD_INT 43
25949: PUSH
25950: LD_INT 25
25952: PUSH
25953: EMPTY
25954: LIST
25955: LIST
25956: LIST
25957: IN
25958: IFFALSE 25979
// points := [ 40 , 15 , 5 ] ;
25960: LD_ADDR_VAR 0 9
25964: PUSH
25965: LD_INT 40
25967: PUSH
25968: LD_INT 15
25970: PUSH
25971: LD_INT 5
25973: PUSH
25974: EMPTY
25975: LIST
25976: LIST
25977: LIST
25978: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
25979: LD_VAR 0 6
25983: PPUSH
25984: CALL_OW 264
25988: PUSH
25989: LD_INT 3
25991: PUSH
25992: LD_INT 23
25994: PUSH
25995: EMPTY
25996: LIST
25997: LIST
25998: IN
25999: IFFALSE 26020
// points := [ 7 , 25 , 8 ] ;
26001: LD_ADDR_VAR 0 9
26005: PUSH
26006: LD_INT 7
26008: PUSH
26009: LD_INT 25
26011: PUSH
26012: LD_INT 8
26014: PUSH
26015: EMPTY
26016: LIST
26017: LIST
26018: LIST
26019: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
26020: LD_VAR 0 6
26024: PPUSH
26025: CALL_OW 264
26029: PUSH
26030: LD_INT 5
26032: PUSH
26033: LD_INT 27
26035: PUSH
26036: LD_INT 44
26038: PUSH
26039: EMPTY
26040: LIST
26041: LIST
26042: LIST
26043: IN
26044: IFFALSE 26065
// points := [ 14 , 50 , 16 ] ;
26046: LD_ADDR_VAR 0 9
26050: PUSH
26051: LD_INT 14
26053: PUSH
26054: LD_INT 50
26056: PUSH
26057: LD_INT 16
26059: PUSH
26060: EMPTY
26061: LIST
26062: LIST
26063: LIST
26064: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
26065: LD_VAR 0 6
26069: PPUSH
26070: CALL_OW 264
26074: PUSH
26075: LD_INT 6
26077: PUSH
26078: LD_INT 46
26080: PUSH
26081: EMPTY
26082: LIST
26083: LIST
26084: IN
26085: IFFALSE 26106
// points := [ 32 , 120 , 70 ] ;
26087: LD_ADDR_VAR 0 9
26091: PUSH
26092: LD_INT 32
26094: PUSH
26095: LD_INT 120
26097: PUSH
26098: LD_INT 70
26100: PUSH
26101: EMPTY
26102: LIST
26103: LIST
26104: LIST
26105: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
26106: LD_VAR 0 6
26110: PPUSH
26111: CALL_OW 264
26115: PUSH
26116: LD_INT 7
26118: PUSH
26119: LD_INT 28
26121: PUSH
26122: LD_INT 45
26124: PUSH
26125: LD_EXP 159
26129: PUSH
26130: EMPTY
26131: LIST
26132: LIST
26133: LIST
26134: LIST
26135: IN
26136: IFFALSE 26157
// points := [ 35 , 20 , 45 ] ;
26138: LD_ADDR_VAR 0 9
26142: PUSH
26143: LD_INT 35
26145: PUSH
26146: LD_INT 20
26148: PUSH
26149: LD_INT 45
26151: PUSH
26152: EMPTY
26153: LIST
26154: LIST
26155: LIST
26156: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
26157: LD_VAR 0 6
26161: PPUSH
26162: CALL_OW 264
26166: PUSH
26167: LD_INT 47
26169: PUSH
26170: EMPTY
26171: LIST
26172: IN
26173: IFFALSE 26194
// points := [ 67 , 45 , 75 ] ;
26175: LD_ADDR_VAR 0 9
26179: PUSH
26180: LD_INT 67
26182: PUSH
26183: LD_INT 45
26185: PUSH
26186: LD_INT 75
26188: PUSH
26189: EMPTY
26190: LIST
26191: LIST
26192: LIST
26193: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
26194: LD_VAR 0 6
26198: PPUSH
26199: CALL_OW 264
26203: PUSH
26204: LD_INT 26
26206: PUSH
26207: EMPTY
26208: LIST
26209: IN
26210: IFFALSE 26231
// points := [ 120 , 30 , 80 ] ;
26212: LD_ADDR_VAR 0 9
26216: PUSH
26217: LD_INT 120
26219: PUSH
26220: LD_INT 30
26222: PUSH
26223: LD_INT 80
26225: PUSH
26226: EMPTY
26227: LIST
26228: LIST
26229: LIST
26230: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
26231: LD_VAR 0 6
26235: PPUSH
26236: CALL_OW 264
26240: PUSH
26241: LD_INT 22
26243: PUSH
26244: EMPTY
26245: LIST
26246: IN
26247: IFFALSE 26268
// points := [ 40 , 1 , 1 ] ;
26249: LD_ADDR_VAR 0 9
26253: PUSH
26254: LD_INT 40
26256: PUSH
26257: LD_INT 1
26259: PUSH
26260: LD_INT 1
26262: PUSH
26263: EMPTY
26264: LIST
26265: LIST
26266: LIST
26267: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
26268: LD_VAR 0 6
26272: PPUSH
26273: CALL_OW 264
26277: PUSH
26278: LD_INT 29
26280: PUSH
26281: EMPTY
26282: LIST
26283: IN
26284: IFFALSE 26305
// points := [ 70 , 200 , 400 ] ;
26286: LD_ADDR_VAR 0 9
26290: PUSH
26291: LD_INT 70
26293: PUSH
26294: LD_INT 200
26296: PUSH
26297: LD_INT 400
26299: PUSH
26300: EMPTY
26301: LIST
26302: LIST
26303: LIST
26304: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
26305: LD_VAR 0 6
26309: PPUSH
26310: CALL_OW 264
26314: PUSH
26315: LD_INT 14
26317: PUSH
26318: LD_INT 53
26320: PUSH
26321: EMPTY
26322: LIST
26323: LIST
26324: IN
26325: IFFALSE 26346
// points := [ 40 , 10 , 20 ] ;
26327: LD_ADDR_VAR 0 9
26331: PUSH
26332: LD_INT 40
26334: PUSH
26335: LD_INT 10
26337: PUSH
26338: LD_INT 20
26340: PUSH
26341: EMPTY
26342: LIST
26343: LIST
26344: LIST
26345: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
26346: LD_VAR 0 6
26350: PPUSH
26351: CALL_OW 264
26355: PUSH
26356: LD_INT 9
26358: PUSH
26359: EMPTY
26360: LIST
26361: IN
26362: IFFALSE 26383
// points := [ 5 , 70 , 20 ] ;
26364: LD_ADDR_VAR 0 9
26368: PUSH
26369: LD_INT 5
26371: PUSH
26372: LD_INT 70
26374: PUSH
26375: LD_INT 20
26377: PUSH
26378: EMPTY
26379: LIST
26380: LIST
26381: LIST
26382: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
26383: LD_VAR 0 6
26387: PPUSH
26388: CALL_OW 264
26392: PUSH
26393: LD_INT 10
26395: PUSH
26396: EMPTY
26397: LIST
26398: IN
26399: IFFALSE 26420
// points := [ 35 , 110 , 70 ] ;
26401: LD_ADDR_VAR 0 9
26405: PUSH
26406: LD_INT 35
26408: PUSH
26409: LD_INT 110
26411: PUSH
26412: LD_INT 70
26414: PUSH
26415: EMPTY
26416: LIST
26417: LIST
26418: LIST
26419: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
26420: LD_VAR 0 6
26424: PPUSH
26425: CALL_OW 265
26429: PUSH
26430: LD_INT 25
26432: EQUAL
26433: IFFALSE 26454
// points := [ 80 , 65 , 100 ] ;
26435: LD_ADDR_VAR 0 9
26439: PUSH
26440: LD_INT 80
26442: PUSH
26443: LD_INT 65
26445: PUSH
26446: LD_INT 100
26448: PUSH
26449: EMPTY
26450: LIST
26451: LIST
26452: LIST
26453: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
26454: LD_VAR 0 6
26458: PPUSH
26459: CALL_OW 263
26463: PUSH
26464: LD_INT 1
26466: EQUAL
26467: IFFALSE 26502
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
26469: LD_ADDR_VAR 0 10
26473: PUSH
26474: LD_VAR 0 10
26478: PUSH
26479: LD_VAR 0 6
26483: PPUSH
26484: CALL_OW 311
26488: PPUSH
26489: LD_INT 3
26491: PPUSH
26492: CALL_OW 259
26496: PUSH
26497: LD_INT 4
26499: MUL
26500: MUL
26501: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
26502: LD_VAR 0 6
26506: PPUSH
26507: CALL_OW 263
26511: PUSH
26512: LD_INT 2
26514: EQUAL
26515: IFFALSE 26566
// begin j := IsControledBy ( i ) ;
26517: LD_ADDR_VAR 0 7
26521: PUSH
26522: LD_VAR 0 6
26526: PPUSH
26527: CALL_OW 312
26531: ST_TO_ADDR
// if j then
26532: LD_VAR 0 7
26536: IFFALSE 26566
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
26538: LD_ADDR_VAR 0 10
26542: PUSH
26543: LD_VAR 0 10
26547: PUSH
26548: LD_VAR 0 7
26552: PPUSH
26553: LD_INT 3
26555: PPUSH
26556: CALL_OW 259
26560: PUSH
26561: LD_INT 3
26563: MUL
26564: MUL
26565: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
26566: LD_VAR 0 6
26570: PPUSH
26571: CALL_OW 264
26575: PUSH
26576: LD_INT 5
26578: PUSH
26579: LD_INT 6
26581: PUSH
26582: LD_INT 46
26584: PUSH
26585: LD_INT 44
26587: PUSH
26588: LD_INT 47
26590: PUSH
26591: LD_INT 45
26593: PUSH
26594: LD_INT 28
26596: PUSH
26597: LD_INT 7
26599: PUSH
26600: LD_INT 27
26602: PUSH
26603: LD_INT 29
26605: PUSH
26606: EMPTY
26607: LIST
26608: LIST
26609: LIST
26610: LIST
26611: LIST
26612: LIST
26613: LIST
26614: LIST
26615: LIST
26616: LIST
26617: IN
26618: PUSH
26619: LD_VAR 0 1
26623: PPUSH
26624: LD_INT 52
26626: PPUSH
26627: CALL_OW 321
26631: PUSH
26632: LD_INT 2
26634: EQUAL
26635: AND
26636: IFFALSE 26653
// bpoints := bpoints * 1.2 ;
26638: LD_ADDR_VAR 0 10
26642: PUSH
26643: LD_VAR 0 10
26647: PUSH
26648: LD_REAL  1.20000000000000E+0000
26651: MUL
26652: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
26653: LD_VAR 0 6
26657: PPUSH
26658: CALL_OW 264
26662: PUSH
26663: LD_INT 6
26665: PUSH
26666: LD_INT 46
26668: PUSH
26669: LD_INT 47
26671: PUSH
26672: EMPTY
26673: LIST
26674: LIST
26675: LIST
26676: IN
26677: IFFALSE 26694
// bpoints := bpoints * 1.2 ;
26679: LD_ADDR_VAR 0 10
26683: PUSH
26684: LD_VAR 0 10
26688: PUSH
26689: LD_REAL  1.20000000000000E+0000
26692: MUL
26693: ST_TO_ADDR
// end ; unit_building :
26694: GO 26708
26696: LD_INT 3
26698: DOUBLE
26699: EQUAL
26700: IFTRUE 26704
26702: GO 26707
26704: POP
// ; end ;
26705: GO 26708
26707: POP
// for j = 1 to 3 do
26708: LD_ADDR_VAR 0 7
26712: PUSH
26713: DOUBLE
26714: LD_INT 1
26716: DEC
26717: ST_TO_ADDR
26718: LD_INT 3
26720: PUSH
26721: FOR_TO
26722: IFFALSE 26775
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
26724: LD_ADDR_VAR 0 5
26728: PUSH
26729: LD_VAR 0 5
26733: PPUSH
26734: LD_VAR 0 7
26738: PPUSH
26739: LD_VAR 0 5
26743: PUSH
26744: LD_VAR 0 7
26748: ARRAY
26749: PUSH
26750: LD_VAR 0 9
26754: PUSH
26755: LD_VAR 0 7
26759: ARRAY
26760: PUSH
26761: LD_VAR 0 10
26765: MUL
26766: PLUS
26767: PPUSH
26768: CALL_OW 1
26772: ST_TO_ADDR
26773: GO 26721
26775: POP
26776: POP
// end ;
26777: GO 25254
26779: POP
26780: POP
// result := Replace ( result , 4 , tmp ) ;
26781: LD_ADDR_VAR 0 5
26785: PUSH
26786: LD_VAR 0 5
26790: PPUSH
26791: LD_INT 4
26793: PPUSH
26794: LD_VAR 0 8
26798: PPUSH
26799: CALL_OW 1
26803: ST_TO_ADDR
// end ;
26804: LD_VAR 0 5
26808: RET
// export function DangerAtRange ( unit , range ) ; begin
26809: LD_INT 0
26811: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
26812: LD_ADDR_VAR 0 3
26816: PUSH
26817: LD_VAR 0 1
26821: PPUSH
26822: CALL_OW 255
26826: PPUSH
26827: LD_VAR 0 1
26831: PPUSH
26832: CALL_OW 250
26836: PPUSH
26837: LD_VAR 0 1
26841: PPUSH
26842: CALL_OW 251
26846: PPUSH
26847: LD_VAR 0 2
26851: PPUSH
26852: CALL 25106 0 4
26856: ST_TO_ADDR
// end ;
26857: LD_VAR 0 3
26861: RET
// export function DangerInArea ( side , area ) ; begin
26862: LD_INT 0
26864: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
26865: LD_ADDR_VAR 0 3
26869: PUSH
26870: LD_VAR 0 2
26874: PPUSH
26875: LD_INT 81
26877: PUSH
26878: LD_VAR 0 1
26882: PUSH
26883: EMPTY
26884: LIST
26885: LIST
26886: PPUSH
26887: CALL_OW 70
26891: ST_TO_ADDR
// end ;
26892: LD_VAR 0 3
26896: RET
// export function IsExtension ( b ) ; begin
26897: LD_INT 0
26899: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
26900: LD_ADDR_VAR 0 2
26904: PUSH
26905: LD_VAR 0 1
26909: PUSH
26910: LD_INT 23
26912: PUSH
26913: LD_INT 20
26915: PUSH
26916: LD_INT 22
26918: PUSH
26919: LD_INT 17
26921: PUSH
26922: LD_INT 24
26924: PUSH
26925: LD_INT 21
26927: PUSH
26928: LD_INT 19
26930: PUSH
26931: LD_INT 16
26933: PUSH
26934: LD_INT 25
26936: PUSH
26937: LD_INT 18
26939: PUSH
26940: EMPTY
26941: LIST
26942: LIST
26943: LIST
26944: LIST
26945: LIST
26946: LIST
26947: LIST
26948: LIST
26949: LIST
26950: LIST
26951: IN
26952: ST_TO_ADDR
// end ;
26953: LD_VAR 0 2
26957: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
26958: LD_INT 0
26960: PPUSH
26961: PPUSH
26962: PPUSH
// result := [ ] ;
26963: LD_ADDR_VAR 0 4
26967: PUSH
26968: EMPTY
26969: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
26970: LD_ADDR_VAR 0 5
26974: PUSH
26975: LD_VAR 0 2
26979: PPUSH
26980: LD_INT 21
26982: PUSH
26983: LD_INT 3
26985: PUSH
26986: EMPTY
26987: LIST
26988: LIST
26989: PPUSH
26990: CALL_OW 70
26994: ST_TO_ADDR
// if not tmp then
26995: LD_VAR 0 5
26999: NOT
27000: IFFALSE 27004
// exit ;
27002: GO 27068
// if checkLink then
27004: LD_VAR 0 3
27008: IFFALSE 27058
// begin for i in tmp do
27010: LD_ADDR_VAR 0 6
27014: PUSH
27015: LD_VAR 0 5
27019: PUSH
27020: FOR_IN
27021: IFFALSE 27056
// if GetBase ( i ) <> base then
27023: LD_VAR 0 6
27027: PPUSH
27028: CALL_OW 274
27032: PUSH
27033: LD_VAR 0 1
27037: NONEQUAL
27038: IFFALSE 27054
// ComLinkToBase ( base , i ) ;
27040: LD_VAR 0 1
27044: PPUSH
27045: LD_VAR 0 6
27049: PPUSH
27050: CALL_OW 169
27054: GO 27020
27056: POP
27057: POP
// end ; result := tmp ;
27058: LD_ADDR_VAR 0 4
27062: PUSH
27063: LD_VAR 0 5
27067: ST_TO_ADDR
// end ;
27068: LD_VAR 0 4
27072: RET
// export function ComComplete ( units , b ) ; var i ; begin
27073: LD_INT 0
27075: PPUSH
27076: PPUSH
// if not units then
27077: LD_VAR 0 1
27081: NOT
27082: IFFALSE 27086
// exit ;
27084: GO 27176
// for i in units do
27086: LD_ADDR_VAR 0 4
27090: PUSH
27091: LD_VAR 0 1
27095: PUSH
27096: FOR_IN
27097: IFFALSE 27174
// if BuildingStatus ( b ) = bs_build then
27099: LD_VAR 0 2
27103: PPUSH
27104: CALL_OW 461
27108: PUSH
27109: LD_INT 1
27111: EQUAL
27112: IFFALSE 27172
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
27114: LD_VAR 0 4
27118: PPUSH
27119: LD_STRING h
27121: PUSH
27122: LD_VAR 0 2
27126: PPUSH
27127: CALL_OW 250
27131: PUSH
27132: LD_VAR 0 2
27136: PPUSH
27137: CALL_OW 251
27141: PUSH
27142: LD_VAR 0 2
27146: PUSH
27147: LD_INT 0
27149: PUSH
27150: LD_INT 0
27152: PUSH
27153: LD_INT 0
27155: PUSH
27156: EMPTY
27157: LIST
27158: LIST
27159: LIST
27160: LIST
27161: LIST
27162: LIST
27163: LIST
27164: PUSH
27165: EMPTY
27166: LIST
27167: PPUSH
27168: CALL_OW 446
27172: GO 27096
27174: POP
27175: POP
// end ;
27176: LD_VAR 0 3
27180: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
27181: LD_INT 0
27183: PPUSH
27184: PPUSH
27185: PPUSH
27186: PPUSH
27187: PPUSH
27188: PPUSH
// if not vehicle or GetControl ( vehicle ) <> control_remote then
27189: LD_VAR 0 1
27193: NOT
27194: PUSH
27195: LD_VAR 0 1
27199: PPUSH
27200: CALL_OW 263
27204: PUSH
27205: LD_INT 2
27207: NONEQUAL
27208: OR
27209: IFFALSE 27213
// exit ;
27211: GO 27529
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
27213: LD_ADDR_VAR 0 6
27217: PUSH
27218: LD_INT 22
27220: PUSH
27221: LD_VAR 0 1
27225: PPUSH
27226: CALL_OW 255
27230: PUSH
27231: EMPTY
27232: LIST
27233: LIST
27234: PUSH
27235: LD_INT 2
27237: PUSH
27238: LD_INT 30
27240: PUSH
27241: LD_INT 36
27243: PUSH
27244: EMPTY
27245: LIST
27246: LIST
27247: PUSH
27248: LD_INT 34
27250: PUSH
27251: LD_INT 31
27253: PUSH
27254: EMPTY
27255: LIST
27256: LIST
27257: PUSH
27258: EMPTY
27259: LIST
27260: LIST
27261: LIST
27262: PUSH
27263: EMPTY
27264: LIST
27265: LIST
27266: PPUSH
27267: CALL_OW 69
27271: ST_TO_ADDR
// if not tmp then
27272: LD_VAR 0 6
27276: NOT
27277: IFFALSE 27281
// exit ;
27279: GO 27529
// result := [ ] ;
27281: LD_ADDR_VAR 0 2
27285: PUSH
27286: EMPTY
27287: ST_TO_ADDR
// for i in tmp do
27288: LD_ADDR_VAR 0 3
27292: PUSH
27293: LD_VAR 0 6
27297: PUSH
27298: FOR_IN
27299: IFFALSE 27370
// begin t := UnitsInside ( i ) ;
27301: LD_ADDR_VAR 0 4
27305: PUSH
27306: LD_VAR 0 3
27310: PPUSH
27311: CALL_OW 313
27315: ST_TO_ADDR
// if t then
27316: LD_VAR 0 4
27320: IFFALSE 27368
// for j in t do
27322: LD_ADDR_VAR 0 7
27326: PUSH
27327: LD_VAR 0 4
27331: PUSH
27332: FOR_IN
27333: IFFALSE 27366
// result := Replace ( result , result + 1 , j ) ;
27335: LD_ADDR_VAR 0 2
27339: PUSH
27340: LD_VAR 0 2
27344: PPUSH
27345: LD_VAR 0 2
27349: PUSH
27350: LD_INT 1
27352: PLUS
27353: PPUSH
27354: LD_VAR 0 7
27358: PPUSH
27359: CALL_OW 1
27363: ST_TO_ADDR
27364: GO 27332
27366: POP
27367: POP
// end ;
27368: GO 27298
27370: POP
27371: POP
// if not result then
27372: LD_VAR 0 2
27376: NOT
27377: IFFALSE 27381
// exit ;
27379: GO 27529
// mech := result [ 1 ] ;
27381: LD_ADDR_VAR 0 5
27385: PUSH
27386: LD_VAR 0 2
27390: PUSH
27391: LD_INT 1
27393: ARRAY
27394: ST_TO_ADDR
// if result > 1 then
27395: LD_VAR 0 2
27399: PUSH
27400: LD_INT 1
27402: GREATER
27403: IFFALSE 27515
// begin for i = 2 to result do
27405: LD_ADDR_VAR 0 3
27409: PUSH
27410: DOUBLE
27411: LD_INT 2
27413: DEC
27414: ST_TO_ADDR
27415: LD_VAR 0 2
27419: PUSH
27420: FOR_TO
27421: IFFALSE 27513
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
27423: LD_ADDR_VAR 0 4
27427: PUSH
27428: LD_VAR 0 2
27432: PUSH
27433: LD_VAR 0 3
27437: ARRAY
27438: PPUSH
27439: LD_INT 3
27441: PPUSH
27442: CALL_OW 259
27446: PUSH
27447: LD_VAR 0 2
27451: PUSH
27452: LD_VAR 0 3
27456: ARRAY
27457: PPUSH
27458: CALL_OW 432
27462: MINUS
27463: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
27464: LD_VAR 0 4
27468: PUSH
27469: LD_VAR 0 5
27473: PPUSH
27474: LD_INT 3
27476: PPUSH
27477: CALL_OW 259
27481: PUSH
27482: LD_VAR 0 5
27486: PPUSH
27487: CALL_OW 432
27491: MINUS
27492: GREATEREQUAL
27493: IFFALSE 27511
// mech := result [ i ] ;
27495: LD_ADDR_VAR 0 5
27499: PUSH
27500: LD_VAR 0 2
27504: PUSH
27505: LD_VAR 0 3
27509: ARRAY
27510: ST_TO_ADDR
// end ;
27511: GO 27420
27513: POP
27514: POP
// end ; ComLinkTo ( vehicle , mech ) ;
27515: LD_VAR 0 1
27519: PPUSH
27520: LD_VAR 0 5
27524: PPUSH
27525: CALL_OW 135
// end ;
27529: LD_VAR 0 2
27533: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
27534: LD_INT 0
27536: PPUSH
27537: PPUSH
27538: PPUSH
27539: PPUSH
27540: PPUSH
27541: PPUSH
27542: PPUSH
27543: PPUSH
27544: PPUSH
27545: PPUSH
27546: PPUSH
27547: PPUSH
27548: PPUSH
// result := [ ] ;
27549: LD_ADDR_VAR 0 7
27553: PUSH
27554: EMPTY
27555: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
27556: LD_VAR 0 1
27560: PPUSH
27561: CALL_OW 266
27565: PUSH
27566: LD_INT 0
27568: PUSH
27569: LD_INT 1
27571: PUSH
27572: EMPTY
27573: LIST
27574: LIST
27575: IN
27576: NOT
27577: IFFALSE 27581
// exit ;
27579: GO 29215
// if name then
27581: LD_VAR 0 3
27585: IFFALSE 27601
// SetBName ( base_dep , name ) ;
27587: LD_VAR 0 1
27591: PPUSH
27592: LD_VAR 0 3
27596: PPUSH
27597: CALL_OW 500
// base := GetBase ( base_dep ) ;
27601: LD_ADDR_VAR 0 15
27605: PUSH
27606: LD_VAR 0 1
27610: PPUSH
27611: CALL_OW 274
27615: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
27616: LD_ADDR_VAR 0 16
27620: PUSH
27621: LD_VAR 0 1
27625: PPUSH
27626: CALL_OW 255
27630: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
27631: LD_ADDR_VAR 0 17
27635: PUSH
27636: LD_VAR 0 1
27640: PPUSH
27641: CALL_OW 248
27645: ST_TO_ADDR
// if sources then
27646: LD_VAR 0 5
27650: IFFALSE 27697
// for i = 1 to 3 do
27652: LD_ADDR_VAR 0 8
27656: PUSH
27657: DOUBLE
27658: LD_INT 1
27660: DEC
27661: ST_TO_ADDR
27662: LD_INT 3
27664: PUSH
27665: FOR_TO
27666: IFFALSE 27695
// AddResourceType ( base , i , sources [ i ] ) ;
27668: LD_VAR 0 15
27672: PPUSH
27673: LD_VAR 0 8
27677: PPUSH
27678: LD_VAR 0 5
27682: PUSH
27683: LD_VAR 0 8
27687: ARRAY
27688: PPUSH
27689: CALL_OW 276
27693: GO 27665
27695: POP
27696: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
27697: LD_ADDR_VAR 0 18
27701: PUSH
27702: LD_VAR 0 15
27706: PPUSH
27707: LD_VAR 0 2
27711: PPUSH
27712: LD_INT 1
27714: PPUSH
27715: CALL 26958 0 3
27719: ST_TO_ADDR
// InitHc ;
27720: CALL_OW 19
// InitUc ;
27724: CALL_OW 18
// uc_side := side ;
27728: LD_ADDR_OWVAR 20
27732: PUSH
27733: LD_VAR 0 16
27737: ST_TO_ADDR
// uc_nation := nation ;
27738: LD_ADDR_OWVAR 21
27742: PUSH
27743: LD_VAR 0 17
27747: ST_TO_ADDR
// if buildings then
27748: LD_VAR 0 18
27752: IFFALSE 29074
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
27754: LD_ADDR_VAR 0 19
27758: PUSH
27759: LD_VAR 0 18
27763: PPUSH
27764: LD_INT 2
27766: PUSH
27767: LD_INT 30
27769: PUSH
27770: LD_INT 29
27772: PUSH
27773: EMPTY
27774: LIST
27775: LIST
27776: PUSH
27777: LD_INT 30
27779: PUSH
27780: LD_INT 30
27782: PUSH
27783: EMPTY
27784: LIST
27785: LIST
27786: PUSH
27787: EMPTY
27788: LIST
27789: LIST
27790: LIST
27791: PPUSH
27792: CALL_OW 72
27796: ST_TO_ADDR
// if tmp then
27797: LD_VAR 0 19
27801: IFFALSE 27849
// for i in tmp do
27803: LD_ADDR_VAR 0 8
27807: PUSH
27808: LD_VAR 0 19
27812: PUSH
27813: FOR_IN
27814: IFFALSE 27847
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
27816: LD_VAR 0 8
27820: PPUSH
27821: CALL_OW 250
27825: PPUSH
27826: LD_VAR 0 8
27830: PPUSH
27831: CALL_OW 251
27835: PPUSH
27836: LD_VAR 0 16
27840: PPUSH
27841: CALL_OW 441
27845: GO 27813
27847: POP
27848: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
27849: LD_VAR 0 18
27853: PPUSH
27854: LD_INT 2
27856: PUSH
27857: LD_INT 30
27859: PUSH
27860: LD_INT 32
27862: PUSH
27863: EMPTY
27864: LIST
27865: LIST
27866: PUSH
27867: LD_INT 30
27869: PUSH
27870: LD_INT 33
27872: PUSH
27873: EMPTY
27874: LIST
27875: LIST
27876: PUSH
27877: EMPTY
27878: LIST
27879: LIST
27880: LIST
27881: PPUSH
27882: CALL_OW 72
27886: IFFALSE 27974
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
27888: LD_ADDR_VAR 0 8
27892: PUSH
27893: LD_VAR 0 18
27897: PPUSH
27898: LD_INT 2
27900: PUSH
27901: LD_INT 30
27903: PUSH
27904: LD_INT 32
27906: PUSH
27907: EMPTY
27908: LIST
27909: LIST
27910: PUSH
27911: LD_INT 30
27913: PUSH
27914: LD_INT 33
27916: PUSH
27917: EMPTY
27918: LIST
27919: LIST
27920: PUSH
27921: EMPTY
27922: LIST
27923: LIST
27924: LIST
27925: PPUSH
27926: CALL_OW 72
27930: PUSH
27931: FOR_IN
27932: IFFALSE 27972
// begin if not GetBWeapon ( i ) then
27934: LD_VAR 0 8
27938: PPUSH
27939: CALL_OW 269
27943: NOT
27944: IFFALSE 27970
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
27946: LD_VAR 0 8
27950: PPUSH
27951: LD_VAR 0 8
27955: PPUSH
27956: LD_VAR 0 2
27960: PPUSH
27961: CALL 29220 0 2
27965: PPUSH
27966: CALL_OW 431
// end ;
27970: GO 27931
27972: POP
27973: POP
// end ; for i = 1 to personel do
27974: LD_ADDR_VAR 0 8
27978: PUSH
27979: DOUBLE
27980: LD_INT 1
27982: DEC
27983: ST_TO_ADDR
27984: LD_VAR 0 6
27988: PUSH
27989: FOR_TO
27990: IFFALSE 29054
// begin if i > 4 then
27992: LD_VAR 0 8
27996: PUSH
27997: LD_INT 4
27999: GREATER
28000: IFFALSE 28004
// break ;
28002: GO 29054
// case i of 1 :
28004: LD_VAR 0 8
28008: PUSH
28009: LD_INT 1
28011: DOUBLE
28012: EQUAL
28013: IFTRUE 28017
28015: GO 28097
28017: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
28018: LD_ADDR_VAR 0 12
28022: PUSH
28023: LD_VAR 0 18
28027: PPUSH
28028: LD_INT 22
28030: PUSH
28031: LD_VAR 0 16
28035: PUSH
28036: EMPTY
28037: LIST
28038: LIST
28039: PUSH
28040: LD_INT 58
28042: PUSH
28043: EMPTY
28044: LIST
28045: PUSH
28046: LD_INT 2
28048: PUSH
28049: LD_INT 30
28051: PUSH
28052: LD_INT 32
28054: PUSH
28055: EMPTY
28056: LIST
28057: LIST
28058: PUSH
28059: LD_INT 30
28061: PUSH
28062: LD_INT 4
28064: PUSH
28065: EMPTY
28066: LIST
28067: LIST
28068: PUSH
28069: LD_INT 30
28071: PUSH
28072: LD_INT 5
28074: PUSH
28075: EMPTY
28076: LIST
28077: LIST
28078: PUSH
28079: EMPTY
28080: LIST
28081: LIST
28082: LIST
28083: LIST
28084: PUSH
28085: EMPTY
28086: LIST
28087: LIST
28088: LIST
28089: PPUSH
28090: CALL_OW 72
28094: ST_TO_ADDR
28095: GO 28319
28097: LD_INT 2
28099: DOUBLE
28100: EQUAL
28101: IFTRUE 28105
28103: GO 28167
28105: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
28106: LD_ADDR_VAR 0 12
28110: PUSH
28111: LD_VAR 0 18
28115: PPUSH
28116: LD_INT 22
28118: PUSH
28119: LD_VAR 0 16
28123: PUSH
28124: EMPTY
28125: LIST
28126: LIST
28127: PUSH
28128: LD_INT 2
28130: PUSH
28131: LD_INT 30
28133: PUSH
28134: LD_INT 0
28136: PUSH
28137: EMPTY
28138: LIST
28139: LIST
28140: PUSH
28141: LD_INT 30
28143: PUSH
28144: LD_INT 1
28146: PUSH
28147: EMPTY
28148: LIST
28149: LIST
28150: PUSH
28151: EMPTY
28152: LIST
28153: LIST
28154: LIST
28155: PUSH
28156: EMPTY
28157: LIST
28158: LIST
28159: PPUSH
28160: CALL_OW 72
28164: ST_TO_ADDR
28165: GO 28319
28167: LD_INT 3
28169: DOUBLE
28170: EQUAL
28171: IFTRUE 28175
28173: GO 28237
28175: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
28176: LD_ADDR_VAR 0 12
28180: PUSH
28181: LD_VAR 0 18
28185: PPUSH
28186: LD_INT 22
28188: PUSH
28189: LD_VAR 0 16
28193: PUSH
28194: EMPTY
28195: LIST
28196: LIST
28197: PUSH
28198: LD_INT 2
28200: PUSH
28201: LD_INT 30
28203: PUSH
28204: LD_INT 2
28206: PUSH
28207: EMPTY
28208: LIST
28209: LIST
28210: PUSH
28211: LD_INT 30
28213: PUSH
28214: LD_INT 3
28216: PUSH
28217: EMPTY
28218: LIST
28219: LIST
28220: PUSH
28221: EMPTY
28222: LIST
28223: LIST
28224: LIST
28225: PUSH
28226: EMPTY
28227: LIST
28228: LIST
28229: PPUSH
28230: CALL_OW 72
28234: ST_TO_ADDR
28235: GO 28319
28237: LD_INT 4
28239: DOUBLE
28240: EQUAL
28241: IFTRUE 28245
28243: GO 28318
28245: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
28246: LD_ADDR_VAR 0 12
28250: PUSH
28251: LD_VAR 0 18
28255: PPUSH
28256: LD_INT 22
28258: PUSH
28259: LD_VAR 0 16
28263: PUSH
28264: EMPTY
28265: LIST
28266: LIST
28267: PUSH
28268: LD_INT 2
28270: PUSH
28271: LD_INT 30
28273: PUSH
28274: LD_INT 6
28276: PUSH
28277: EMPTY
28278: LIST
28279: LIST
28280: PUSH
28281: LD_INT 30
28283: PUSH
28284: LD_INT 7
28286: PUSH
28287: EMPTY
28288: LIST
28289: LIST
28290: PUSH
28291: LD_INT 30
28293: PUSH
28294: LD_INT 8
28296: PUSH
28297: EMPTY
28298: LIST
28299: LIST
28300: PUSH
28301: EMPTY
28302: LIST
28303: LIST
28304: LIST
28305: LIST
28306: PUSH
28307: EMPTY
28308: LIST
28309: LIST
28310: PPUSH
28311: CALL_OW 72
28315: ST_TO_ADDR
28316: GO 28319
28318: POP
// if i = 1 then
28319: LD_VAR 0 8
28323: PUSH
28324: LD_INT 1
28326: EQUAL
28327: IFFALSE 28438
// begin tmp := [ ] ;
28329: LD_ADDR_VAR 0 19
28333: PUSH
28334: EMPTY
28335: ST_TO_ADDR
// for j in f do
28336: LD_ADDR_VAR 0 9
28340: PUSH
28341: LD_VAR 0 12
28345: PUSH
28346: FOR_IN
28347: IFFALSE 28420
// if GetBType ( j ) = b_bunker then
28349: LD_VAR 0 9
28353: PPUSH
28354: CALL_OW 266
28358: PUSH
28359: LD_INT 32
28361: EQUAL
28362: IFFALSE 28389
// tmp := Insert ( tmp , 1 , j ) else
28364: LD_ADDR_VAR 0 19
28368: PUSH
28369: LD_VAR 0 19
28373: PPUSH
28374: LD_INT 1
28376: PPUSH
28377: LD_VAR 0 9
28381: PPUSH
28382: CALL_OW 2
28386: ST_TO_ADDR
28387: GO 28418
// tmp := Insert ( tmp , tmp + 1 , j ) ;
28389: LD_ADDR_VAR 0 19
28393: PUSH
28394: LD_VAR 0 19
28398: PPUSH
28399: LD_VAR 0 19
28403: PUSH
28404: LD_INT 1
28406: PLUS
28407: PPUSH
28408: LD_VAR 0 9
28412: PPUSH
28413: CALL_OW 2
28417: ST_TO_ADDR
28418: GO 28346
28420: POP
28421: POP
// if tmp then
28422: LD_VAR 0 19
28426: IFFALSE 28438
// f := tmp ;
28428: LD_ADDR_VAR 0 12
28432: PUSH
28433: LD_VAR 0 19
28437: ST_TO_ADDR
// end ; x := personel [ i ] ;
28438: LD_ADDR_VAR 0 13
28442: PUSH
28443: LD_VAR 0 6
28447: PUSH
28448: LD_VAR 0 8
28452: ARRAY
28453: ST_TO_ADDR
// if x = - 1 then
28454: LD_VAR 0 13
28458: PUSH
28459: LD_INT 1
28461: NEG
28462: EQUAL
28463: IFFALSE 28672
// begin for j in f do
28465: LD_ADDR_VAR 0 9
28469: PUSH
28470: LD_VAR 0 12
28474: PUSH
28475: FOR_IN
28476: IFFALSE 28668
// repeat InitHc ;
28478: CALL_OW 19
// if GetBType ( j ) = b_barracks then
28482: LD_VAR 0 9
28486: PPUSH
28487: CALL_OW 266
28491: PUSH
28492: LD_INT 5
28494: EQUAL
28495: IFFALSE 28565
// begin if UnitsInside ( j ) < 3 then
28497: LD_VAR 0 9
28501: PPUSH
28502: CALL_OW 313
28506: PUSH
28507: LD_INT 3
28509: LESS
28510: IFFALSE 28546
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
28512: LD_INT 0
28514: PPUSH
28515: LD_INT 5
28517: PUSH
28518: LD_INT 8
28520: PUSH
28521: LD_INT 9
28523: PUSH
28524: EMPTY
28525: LIST
28526: LIST
28527: LIST
28528: PUSH
28529: LD_VAR 0 17
28533: ARRAY
28534: PPUSH
28535: LD_VAR 0 4
28539: PPUSH
28540: CALL_OW 380
28544: GO 28563
// PrepareHuman ( false , i , skill ) ;
28546: LD_INT 0
28548: PPUSH
28549: LD_VAR 0 8
28553: PPUSH
28554: LD_VAR 0 4
28558: PPUSH
28559: CALL_OW 380
// end else
28563: GO 28582
// PrepareHuman ( false , i , skill ) ;
28565: LD_INT 0
28567: PPUSH
28568: LD_VAR 0 8
28572: PPUSH
28573: LD_VAR 0 4
28577: PPUSH
28578: CALL_OW 380
// un := CreateHuman ;
28582: LD_ADDR_VAR 0 14
28586: PUSH
28587: CALL_OW 44
28591: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
28592: LD_ADDR_VAR 0 7
28596: PUSH
28597: LD_VAR 0 7
28601: PPUSH
28602: LD_INT 1
28604: PPUSH
28605: LD_VAR 0 14
28609: PPUSH
28610: CALL_OW 2
28614: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
28615: LD_VAR 0 14
28619: PPUSH
28620: LD_VAR 0 9
28624: PPUSH
28625: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
28629: LD_VAR 0 9
28633: PPUSH
28634: CALL_OW 313
28638: PUSH
28639: LD_INT 6
28641: EQUAL
28642: PUSH
28643: LD_VAR 0 9
28647: PPUSH
28648: CALL_OW 266
28652: PUSH
28653: LD_INT 32
28655: PUSH
28656: LD_INT 31
28658: PUSH
28659: EMPTY
28660: LIST
28661: LIST
28662: IN
28663: OR
28664: IFFALSE 28478
28666: GO 28475
28668: POP
28669: POP
// end else
28670: GO 29052
// for j = 1 to x do
28672: LD_ADDR_VAR 0 9
28676: PUSH
28677: DOUBLE
28678: LD_INT 1
28680: DEC
28681: ST_TO_ADDR
28682: LD_VAR 0 13
28686: PUSH
28687: FOR_TO
28688: IFFALSE 29050
// begin InitHc ;
28690: CALL_OW 19
// if not f then
28694: LD_VAR 0 12
28698: NOT
28699: IFFALSE 28788
// begin PrepareHuman ( false , i , skill ) ;
28701: LD_INT 0
28703: PPUSH
28704: LD_VAR 0 8
28708: PPUSH
28709: LD_VAR 0 4
28713: PPUSH
28714: CALL_OW 380
// un := CreateHuman ;
28718: LD_ADDR_VAR 0 14
28722: PUSH
28723: CALL_OW 44
28727: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
28728: LD_ADDR_VAR 0 7
28732: PUSH
28733: LD_VAR 0 7
28737: PPUSH
28738: LD_INT 1
28740: PPUSH
28741: LD_VAR 0 14
28745: PPUSH
28746: CALL_OW 2
28750: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
28751: LD_VAR 0 14
28755: PPUSH
28756: LD_VAR 0 1
28760: PPUSH
28761: CALL_OW 250
28765: PPUSH
28766: LD_VAR 0 1
28770: PPUSH
28771: CALL_OW 251
28775: PPUSH
28776: LD_INT 10
28778: PPUSH
28779: LD_INT 0
28781: PPUSH
28782: CALL_OW 50
// continue ;
28786: GO 28687
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
28788: LD_VAR 0 12
28792: PUSH
28793: LD_INT 1
28795: ARRAY
28796: PPUSH
28797: CALL_OW 313
28801: PUSH
28802: LD_VAR 0 12
28806: PUSH
28807: LD_INT 1
28809: ARRAY
28810: PPUSH
28811: CALL_OW 266
28815: PUSH
28816: LD_INT 32
28818: PUSH
28819: LD_INT 31
28821: PUSH
28822: EMPTY
28823: LIST
28824: LIST
28825: IN
28826: AND
28827: PUSH
28828: LD_VAR 0 12
28832: PUSH
28833: LD_INT 1
28835: ARRAY
28836: PPUSH
28837: CALL_OW 313
28841: PUSH
28842: LD_INT 6
28844: EQUAL
28845: OR
28846: IFFALSE 28866
// f := Delete ( f , 1 ) ;
28848: LD_ADDR_VAR 0 12
28852: PUSH
28853: LD_VAR 0 12
28857: PPUSH
28858: LD_INT 1
28860: PPUSH
28861: CALL_OW 3
28865: ST_TO_ADDR
// if not f then
28866: LD_VAR 0 12
28870: NOT
28871: IFFALSE 28889
// begin x := x + 2 ;
28873: LD_ADDR_VAR 0 13
28877: PUSH
28878: LD_VAR 0 13
28882: PUSH
28883: LD_INT 2
28885: PLUS
28886: ST_TO_ADDR
// continue ;
28887: GO 28687
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
28889: LD_VAR 0 12
28893: PUSH
28894: LD_INT 1
28896: ARRAY
28897: PPUSH
28898: CALL_OW 266
28902: PUSH
28903: LD_INT 5
28905: EQUAL
28906: IFFALSE 28980
// begin if UnitsInside ( f [ 1 ] ) < 3 then
28908: LD_VAR 0 12
28912: PUSH
28913: LD_INT 1
28915: ARRAY
28916: PPUSH
28917: CALL_OW 313
28921: PUSH
28922: LD_INT 3
28924: LESS
28925: IFFALSE 28961
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
28927: LD_INT 0
28929: PPUSH
28930: LD_INT 5
28932: PUSH
28933: LD_INT 8
28935: PUSH
28936: LD_INT 9
28938: PUSH
28939: EMPTY
28940: LIST
28941: LIST
28942: LIST
28943: PUSH
28944: LD_VAR 0 17
28948: ARRAY
28949: PPUSH
28950: LD_VAR 0 4
28954: PPUSH
28955: CALL_OW 380
28959: GO 28978
// PrepareHuman ( false , i , skill ) ;
28961: LD_INT 0
28963: PPUSH
28964: LD_VAR 0 8
28968: PPUSH
28969: LD_VAR 0 4
28973: PPUSH
28974: CALL_OW 380
// end else
28978: GO 28997
// PrepareHuman ( false , i , skill ) ;
28980: LD_INT 0
28982: PPUSH
28983: LD_VAR 0 8
28987: PPUSH
28988: LD_VAR 0 4
28992: PPUSH
28993: CALL_OW 380
// un := CreateHuman ;
28997: LD_ADDR_VAR 0 14
29001: PUSH
29002: CALL_OW 44
29006: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
29007: LD_ADDR_VAR 0 7
29011: PUSH
29012: LD_VAR 0 7
29016: PPUSH
29017: LD_INT 1
29019: PPUSH
29020: LD_VAR 0 14
29024: PPUSH
29025: CALL_OW 2
29029: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
29030: LD_VAR 0 14
29034: PPUSH
29035: LD_VAR 0 12
29039: PUSH
29040: LD_INT 1
29042: ARRAY
29043: PPUSH
29044: CALL_OW 52
// end ;
29048: GO 28687
29050: POP
29051: POP
// end ;
29052: GO 27989
29054: POP
29055: POP
// result := result ^ buildings ;
29056: LD_ADDR_VAR 0 7
29060: PUSH
29061: LD_VAR 0 7
29065: PUSH
29066: LD_VAR 0 18
29070: ADD
29071: ST_TO_ADDR
// end else
29072: GO 29215
// begin for i = 1 to personel do
29074: LD_ADDR_VAR 0 8
29078: PUSH
29079: DOUBLE
29080: LD_INT 1
29082: DEC
29083: ST_TO_ADDR
29084: LD_VAR 0 6
29088: PUSH
29089: FOR_TO
29090: IFFALSE 29213
// begin if i > 4 then
29092: LD_VAR 0 8
29096: PUSH
29097: LD_INT 4
29099: GREATER
29100: IFFALSE 29104
// break ;
29102: GO 29213
// x := personel [ i ] ;
29104: LD_ADDR_VAR 0 13
29108: PUSH
29109: LD_VAR 0 6
29113: PUSH
29114: LD_VAR 0 8
29118: ARRAY
29119: ST_TO_ADDR
// if x = - 1 then
29120: LD_VAR 0 13
29124: PUSH
29125: LD_INT 1
29127: NEG
29128: EQUAL
29129: IFFALSE 29133
// continue ;
29131: GO 29089
// PrepareHuman ( false , i , skill ) ;
29133: LD_INT 0
29135: PPUSH
29136: LD_VAR 0 8
29140: PPUSH
29141: LD_VAR 0 4
29145: PPUSH
29146: CALL_OW 380
// un := CreateHuman ;
29150: LD_ADDR_VAR 0 14
29154: PUSH
29155: CALL_OW 44
29159: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
29160: LD_VAR 0 14
29164: PPUSH
29165: LD_VAR 0 1
29169: PPUSH
29170: CALL_OW 250
29174: PPUSH
29175: LD_VAR 0 1
29179: PPUSH
29180: CALL_OW 251
29184: PPUSH
29185: LD_INT 10
29187: PPUSH
29188: LD_INT 0
29190: PPUSH
29191: CALL_OW 50
// result := result ^ un ;
29195: LD_ADDR_VAR 0 7
29199: PUSH
29200: LD_VAR 0 7
29204: PUSH
29205: LD_VAR 0 14
29209: ADD
29210: ST_TO_ADDR
// end ;
29211: GO 29089
29213: POP
29214: POP
// end ; end ;
29215: LD_VAR 0 7
29219: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
29220: LD_INT 0
29222: PPUSH
29223: PPUSH
29224: PPUSH
29225: PPUSH
29226: PPUSH
29227: PPUSH
29228: PPUSH
29229: PPUSH
29230: PPUSH
29231: PPUSH
29232: PPUSH
29233: PPUSH
29234: PPUSH
29235: PPUSH
29236: PPUSH
29237: PPUSH
// result := false ;
29238: LD_ADDR_VAR 0 3
29242: PUSH
29243: LD_INT 0
29245: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
29246: LD_VAR 0 1
29250: NOT
29251: PUSH
29252: LD_VAR 0 1
29256: PPUSH
29257: CALL_OW 266
29261: PUSH
29262: LD_INT 32
29264: PUSH
29265: LD_INT 33
29267: PUSH
29268: EMPTY
29269: LIST
29270: LIST
29271: IN
29272: NOT
29273: OR
29274: IFFALSE 29278
// exit ;
29276: GO 30387
// nat := GetNation ( tower ) ;
29278: LD_ADDR_VAR 0 12
29282: PUSH
29283: LD_VAR 0 1
29287: PPUSH
29288: CALL_OW 248
29292: ST_TO_ADDR
// side := GetSide ( tower ) ;
29293: LD_ADDR_VAR 0 16
29297: PUSH
29298: LD_VAR 0 1
29302: PPUSH
29303: CALL_OW 255
29307: ST_TO_ADDR
// x := GetX ( tower ) ;
29308: LD_ADDR_VAR 0 10
29312: PUSH
29313: LD_VAR 0 1
29317: PPUSH
29318: CALL_OW 250
29322: ST_TO_ADDR
// y := GetY ( tower ) ;
29323: LD_ADDR_VAR 0 11
29327: PUSH
29328: LD_VAR 0 1
29332: PPUSH
29333: CALL_OW 251
29337: ST_TO_ADDR
// if not x or not y then
29338: LD_VAR 0 10
29342: NOT
29343: PUSH
29344: LD_VAR 0 11
29348: NOT
29349: OR
29350: IFFALSE 29354
// exit ;
29352: GO 30387
// weapon := 0 ;
29354: LD_ADDR_VAR 0 18
29358: PUSH
29359: LD_INT 0
29361: ST_TO_ADDR
// fac_list := [ ] ;
29362: LD_ADDR_VAR 0 17
29366: PUSH
29367: EMPTY
29368: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
29369: LD_ADDR_VAR 0 6
29373: PUSH
29374: LD_VAR 0 1
29378: PPUSH
29379: CALL_OW 274
29383: PPUSH
29384: LD_VAR 0 2
29388: PPUSH
29389: LD_INT 0
29391: PPUSH
29392: CALL 26958 0 3
29396: PPUSH
29397: LD_INT 30
29399: PUSH
29400: LD_INT 3
29402: PUSH
29403: EMPTY
29404: LIST
29405: LIST
29406: PPUSH
29407: CALL_OW 72
29411: ST_TO_ADDR
// if not factories then
29412: LD_VAR 0 6
29416: NOT
29417: IFFALSE 29421
// exit ;
29419: GO 30387
// for i in factories do
29421: LD_ADDR_VAR 0 8
29425: PUSH
29426: LD_VAR 0 6
29430: PUSH
29431: FOR_IN
29432: IFFALSE 29457
// fac_list := fac_list union AvailableWeaponList ( i ) ;
29434: LD_ADDR_VAR 0 17
29438: PUSH
29439: LD_VAR 0 17
29443: PUSH
29444: LD_VAR 0 8
29448: PPUSH
29449: CALL_OW 478
29453: UNION
29454: ST_TO_ADDR
29455: GO 29431
29457: POP
29458: POP
// if not fac_list then
29459: LD_VAR 0 17
29463: NOT
29464: IFFALSE 29468
// exit ;
29466: GO 30387
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
29468: LD_ADDR_VAR 0 5
29472: PUSH
29473: LD_INT 4
29475: PUSH
29476: LD_INT 5
29478: PUSH
29479: LD_INT 9
29481: PUSH
29482: LD_INT 10
29484: PUSH
29485: LD_INT 6
29487: PUSH
29488: LD_INT 7
29490: PUSH
29491: LD_INT 11
29493: PUSH
29494: EMPTY
29495: LIST
29496: LIST
29497: LIST
29498: LIST
29499: LIST
29500: LIST
29501: LIST
29502: PUSH
29503: LD_INT 27
29505: PUSH
29506: LD_INT 28
29508: PUSH
29509: LD_INT 26
29511: PUSH
29512: LD_INT 30
29514: PUSH
29515: EMPTY
29516: LIST
29517: LIST
29518: LIST
29519: LIST
29520: PUSH
29521: LD_INT 43
29523: PUSH
29524: LD_INT 44
29526: PUSH
29527: LD_INT 46
29529: PUSH
29530: LD_INT 45
29532: PUSH
29533: LD_INT 47
29535: PUSH
29536: LD_INT 49
29538: PUSH
29539: EMPTY
29540: LIST
29541: LIST
29542: LIST
29543: LIST
29544: LIST
29545: LIST
29546: PUSH
29547: EMPTY
29548: LIST
29549: LIST
29550: LIST
29551: PUSH
29552: LD_VAR 0 12
29556: ARRAY
29557: ST_TO_ADDR
// list := list isect fac_list ;
29558: LD_ADDR_VAR 0 5
29562: PUSH
29563: LD_VAR 0 5
29567: PUSH
29568: LD_VAR 0 17
29572: ISECT
29573: ST_TO_ADDR
// if not list then
29574: LD_VAR 0 5
29578: NOT
29579: IFFALSE 29583
// exit ;
29581: GO 30387
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
29583: LD_VAR 0 12
29587: PUSH
29588: LD_INT 3
29590: EQUAL
29591: PUSH
29592: LD_INT 49
29594: PUSH
29595: LD_VAR 0 5
29599: IN
29600: AND
29601: PUSH
29602: LD_INT 31
29604: PPUSH
29605: LD_VAR 0 16
29609: PPUSH
29610: CALL_OW 321
29614: PUSH
29615: LD_INT 2
29617: EQUAL
29618: AND
29619: IFFALSE 29679
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
29621: LD_INT 22
29623: PUSH
29624: LD_VAR 0 16
29628: PUSH
29629: EMPTY
29630: LIST
29631: LIST
29632: PUSH
29633: LD_INT 35
29635: PUSH
29636: LD_INT 49
29638: PUSH
29639: EMPTY
29640: LIST
29641: LIST
29642: PUSH
29643: LD_INT 91
29645: PUSH
29646: LD_VAR 0 1
29650: PUSH
29651: LD_INT 10
29653: PUSH
29654: EMPTY
29655: LIST
29656: LIST
29657: LIST
29658: PUSH
29659: EMPTY
29660: LIST
29661: LIST
29662: LIST
29663: PPUSH
29664: CALL_OW 69
29668: NOT
29669: IFFALSE 29679
// weapon := ru_time_lapser ;
29671: LD_ADDR_VAR 0 18
29675: PUSH
29676: LD_INT 49
29678: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
29679: LD_VAR 0 12
29683: PUSH
29684: LD_INT 1
29686: PUSH
29687: LD_INT 2
29689: PUSH
29690: EMPTY
29691: LIST
29692: LIST
29693: IN
29694: PUSH
29695: LD_INT 11
29697: PUSH
29698: LD_VAR 0 5
29702: IN
29703: PUSH
29704: LD_INT 30
29706: PUSH
29707: LD_VAR 0 5
29711: IN
29712: OR
29713: AND
29714: PUSH
29715: LD_INT 6
29717: PPUSH
29718: LD_VAR 0 16
29722: PPUSH
29723: CALL_OW 321
29727: PUSH
29728: LD_INT 2
29730: EQUAL
29731: AND
29732: IFFALSE 29897
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
29734: LD_INT 22
29736: PUSH
29737: LD_VAR 0 16
29741: PUSH
29742: EMPTY
29743: LIST
29744: LIST
29745: PUSH
29746: LD_INT 2
29748: PUSH
29749: LD_INT 35
29751: PUSH
29752: LD_INT 11
29754: PUSH
29755: EMPTY
29756: LIST
29757: LIST
29758: PUSH
29759: LD_INT 35
29761: PUSH
29762: LD_INT 30
29764: PUSH
29765: EMPTY
29766: LIST
29767: LIST
29768: PUSH
29769: EMPTY
29770: LIST
29771: LIST
29772: LIST
29773: PUSH
29774: LD_INT 91
29776: PUSH
29777: LD_VAR 0 1
29781: PUSH
29782: LD_INT 18
29784: PUSH
29785: EMPTY
29786: LIST
29787: LIST
29788: LIST
29789: PUSH
29790: EMPTY
29791: LIST
29792: LIST
29793: LIST
29794: PPUSH
29795: CALL_OW 69
29799: NOT
29800: PUSH
29801: LD_INT 22
29803: PUSH
29804: LD_VAR 0 16
29808: PUSH
29809: EMPTY
29810: LIST
29811: LIST
29812: PUSH
29813: LD_INT 2
29815: PUSH
29816: LD_INT 30
29818: PUSH
29819: LD_INT 32
29821: PUSH
29822: EMPTY
29823: LIST
29824: LIST
29825: PUSH
29826: LD_INT 30
29828: PUSH
29829: LD_INT 33
29831: PUSH
29832: EMPTY
29833: LIST
29834: LIST
29835: PUSH
29836: EMPTY
29837: LIST
29838: LIST
29839: LIST
29840: PUSH
29841: LD_INT 91
29843: PUSH
29844: LD_VAR 0 1
29848: PUSH
29849: LD_INT 12
29851: PUSH
29852: EMPTY
29853: LIST
29854: LIST
29855: LIST
29856: PUSH
29857: EMPTY
29858: LIST
29859: LIST
29860: LIST
29861: PUSH
29862: EMPTY
29863: LIST
29864: PPUSH
29865: CALL_OW 69
29869: PUSH
29870: LD_INT 2
29872: GREATER
29873: AND
29874: IFFALSE 29897
// weapon := [ us_radar , ar_radar ] [ nat ] ;
29876: LD_ADDR_VAR 0 18
29880: PUSH
29881: LD_INT 11
29883: PUSH
29884: LD_INT 30
29886: PUSH
29887: EMPTY
29888: LIST
29889: LIST
29890: PUSH
29891: LD_VAR 0 12
29895: ARRAY
29896: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
29897: LD_VAR 0 18
29901: NOT
29902: PUSH
29903: LD_INT 40
29905: PPUSH
29906: LD_VAR 0 16
29910: PPUSH
29911: CALL_OW 321
29915: PUSH
29916: LD_INT 2
29918: EQUAL
29919: AND
29920: PUSH
29921: LD_INT 7
29923: PUSH
29924: LD_VAR 0 5
29928: IN
29929: PUSH
29930: LD_INT 28
29932: PUSH
29933: LD_VAR 0 5
29937: IN
29938: OR
29939: PUSH
29940: LD_INT 45
29942: PUSH
29943: LD_VAR 0 5
29947: IN
29948: OR
29949: AND
29950: IFFALSE 30204
// begin hex := GetHexInfo ( x , y ) ;
29952: LD_ADDR_VAR 0 4
29956: PUSH
29957: LD_VAR 0 10
29961: PPUSH
29962: LD_VAR 0 11
29966: PPUSH
29967: CALL_OW 546
29971: ST_TO_ADDR
// if hex [ 1 ] then
29972: LD_VAR 0 4
29976: PUSH
29977: LD_INT 1
29979: ARRAY
29980: IFFALSE 29984
// exit ;
29982: GO 30387
// height := hex [ 2 ] ;
29984: LD_ADDR_VAR 0 15
29988: PUSH
29989: LD_VAR 0 4
29993: PUSH
29994: LD_INT 2
29996: ARRAY
29997: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
29998: LD_ADDR_VAR 0 14
30002: PUSH
30003: LD_INT 0
30005: PUSH
30006: LD_INT 2
30008: PUSH
30009: LD_INT 3
30011: PUSH
30012: LD_INT 5
30014: PUSH
30015: EMPTY
30016: LIST
30017: LIST
30018: LIST
30019: LIST
30020: ST_TO_ADDR
// for i in tmp do
30021: LD_ADDR_VAR 0 8
30025: PUSH
30026: LD_VAR 0 14
30030: PUSH
30031: FOR_IN
30032: IFFALSE 30202
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
30034: LD_ADDR_VAR 0 9
30038: PUSH
30039: LD_VAR 0 10
30043: PPUSH
30044: LD_VAR 0 8
30048: PPUSH
30049: LD_INT 5
30051: PPUSH
30052: CALL_OW 272
30056: PUSH
30057: LD_VAR 0 11
30061: PPUSH
30062: LD_VAR 0 8
30066: PPUSH
30067: LD_INT 5
30069: PPUSH
30070: CALL_OW 273
30074: PUSH
30075: EMPTY
30076: LIST
30077: LIST
30078: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
30079: LD_VAR 0 9
30083: PUSH
30084: LD_INT 1
30086: ARRAY
30087: PPUSH
30088: LD_VAR 0 9
30092: PUSH
30093: LD_INT 2
30095: ARRAY
30096: PPUSH
30097: CALL_OW 488
30101: IFFALSE 30200
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
30103: LD_ADDR_VAR 0 4
30107: PUSH
30108: LD_VAR 0 9
30112: PUSH
30113: LD_INT 1
30115: ARRAY
30116: PPUSH
30117: LD_VAR 0 9
30121: PUSH
30122: LD_INT 2
30124: ARRAY
30125: PPUSH
30126: CALL_OW 546
30130: ST_TO_ADDR
// if hex [ 1 ] then
30131: LD_VAR 0 4
30135: PUSH
30136: LD_INT 1
30138: ARRAY
30139: IFFALSE 30143
// continue ;
30141: GO 30031
// h := hex [ 2 ] ;
30143: LD_ADDR_VAR 0 13
30147: PUSH
30148: LD_VAR 0 4
30152: PUSH
30153: LD_INT 2
30155: ARRAY
30156: ST_TO_ADDR
// if h + 7 < height then
30157: LD_VAR 0 13
30161: PUSH
30162: LD_INT 7
30164: PLUS
30165: PUSH
30166: LD_VAR 0 15
30170: LESS
30171: IFFALSE 30200
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
30173: LD_ADDR_VAR 0 18
30177: PUSH
30178: LD_INT 7
30180: PUSH
30181: LD_INT 28
30183: PUSH
30184: LD_INT 45
30186: PUSH
30187: EMPTY
30188: LIST
30189: LIST
30190: LIST
30191: PUSH
30192: LD_VAR 0 12
30196: ARRAY
30197: ST_TO_ADDR
// break ;
30198: GO 30202
// end ; end ; end ;
30200: GO 30031
30202: POP
30203: POP
// end ; if not weapon then
30204: LD_VAR 0 18
30208: NOT
30209: IFFALSE 30269
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
30211: LD_ADDR_VAR 0 5
30215: PUSH
30216: LD_VAR 0 5
30220: PUSH
30221: LD_INT 11
30223: PUSH
30224: LD_INT 30
30226: PUSH
30227: LD_INT 49
30229: PUSH
30230: EMPTY
30231: LIST
30232: LIST
30233: LIST
30234: DIFF
30235: ST_TO_ADDR
// if not list then
30236: LD_VAR 0 5
30240: NOT
30241: IFFALSE 30245
// exit ;
30243: GO 30387
// weapon := list [ rand ( 1 , list ) ] ;
30245: LD_ADDR_VAR 0 18
30249: PUSH
30250: LD_VAR 0 5
30254: PUSH
30255: LD_INT 1
30257: PPUSH
30258: LD_VAR 0 5
30262: PPUSH
30263: CALL_OW 12
30267: ARRAY
30268: ST_TO_ADDR
// end ; if weapon then
30269: LD_VAR 0 18
30273: IFFALSE 30387
// begin tmp := CostOfWeapon ( weapon ) ;
30275: LD_ADDR_VAR 0 14
30279: PUSH
30280: LD_VAR 0 18
30284: PPUSH
30285: CALL_OW 451
30289: ST_TO_ADDR
// j := GetBase ( tower ) ;
30290: LD_ADDR_VAR 0 9
30294: PUSH
30295: LD_VAR 0 1
30299: PPUSH
30300: CALL_OW 274
30304: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
30305: LD_VAR 0 9
30309: PPUSH
30310: LD_INT 1
30312: PPUSH
30313: CALL_OW 275
30317: PUSH
30318: LD_VAR 0 14
30322: PUSH
30323: LD_INT 1
30325: ARRAY
30326: GREATEREQUAL
30327: PUSH
30328: LD_VAR 0 9
30332: PPUSH
30333: LD_INT 2
30335: PPUSH
30336: CALL_OW 275
30340: PUSH
30341: LD_VAR 0 14
30345: PUSH
30346: LD_INT 2
30348: ARRAY
30349: GREATEREQUAL
30350: AND
30351: PUSH
30352: LD_VAR 0 9
30356: PPUSH
30357: LD_INT 3
30359: PPUSH
30360: CALL_OW 275
30364: PUSH
30365: LD_VAR 0 14
30369: PUSH
30370: LD_INT 3
30372: ARRAY
30373: GREATEREQUAL
30374: AND
30375: IFFALSE 30387
// result := weapon ;
30377: LD_ADDR_VAR 0 3
30381: PUSH
30382: LD_VAR 0 18
30386: ST_TO_ADDR
// end ; end ;
30387: LD_VAR 0 3
30391: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
30392: LD_INT 0
30394: PPUSH
30395: PPUSH
// result := true ;
30396: LD_ADDR_VAR 0 3
30400: PUSH
30401: LD_INT 1
30403: ST_TO_ADDR
// if array1 = array2 then
30404: LD_VAR 0 1
30408: PUSH
30409: LD_VAR 0 2
30413: EQUAL
30414: IFFALSE 30474
// begin for i = 1 to array1 do
30416: LD_ADDR_VAR 0 4
30420: PUSH
30421: DOUBLE
30422: LD_INT 1
30424: DEC
30425: ST_TO_ADDR
30426: LD_VAR 0 1
30430: PUSH
30431: FOR_TO
30432: IFFALSE 30470
// if array1 [ i ] <> array2 [ i ] then
30434: LD_VAR 0 1
30438: PUSH
30439: LD_VAR 0 4
30443: ARRAY
30444: PUSH
30445: LD_VAR 0 2
30449: PUSH
30450: LD_VAR 0 4
30454: ARRAY
30455: NONEQUAL
30456: IFFALSE 30468
// begin result := false ;
30458: LD_ADDR_VAR 0 3
30462: PUSH
30463: LD_INT 0
30465: ST_TO_ADDR
// break ;
30466: GO 30470
// end ;
30468: GO 30431
30470: POP
30471: POP
// end else
30472: GO 30482
// result := false ;
30474: LD_ADDR_VAR 0 3
30478: PUSH
30479: LD_INT 0
30481: ST_TO_ADDR
// end ;
30482: LD_VAR 0 3
30486: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
30487: LD_INT 0
30489: PPUSH
30490: PPUSH
// if not array1 or not array2 then
30491: LD_VAR 0 1
30495: NOT
30496: PUSH
30497: LD_VAR 0 2
30501: NOT
30502: OR
30503: IFFALSE 30507
// exit ;
30505: GO 30571
// result := true ;
30507: LD_ADDR_VAR 0 3
30511: PUSH
30512: LD_INT 1
30514: ST_TO_ADDR
// for i = 1 to array1 do
30515: LD_ADDR_VAR 0 4
30519: PUSH
30520: DOUBLE
30521: LD_INT 1
30523: DEC
30524: ST_TO_ADDR
30525: LD_VAR 0 1
30529: PUSH
30530: FOR_TO
30531: IFFALSE 30569
// if array1 [ i ] <> array2 [ i ] then
30533: LD_VAR 0 1
30537: PUSH
30538: LD_VAR 0 4
30542: ARRAY
30543: PUSH
30544: LD_VAR 0 2
30548: PUSH
30549: LD_VAR 0 4
30553: ARRAY
30554: NONEQUAL
30555: IFFALSE 30567
// begin result := false ;
30557: LD_ADDR_VAR 0 3
30561: PUSH
30562: LD_INT 0
30564: ST_TO_ADDR
// break ;
30565: GO 30569
// end ;
30567: GO 30530
30569: POP
30570: POP
// end ;
30571: LD_VAR 0 3
30575: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
30576: LD_INT 0
30578: PPUSH
30579: PPUSH
30580: PPUSH
// pom := GetBase ( fac ) ;
30581: LD_ADDR_VAR 0 5
30585: PUSH
30586: LD_VAR 0 1
30590: PPUSH
30591: CALL_OW 274
30595: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
30596: LD_ADDR_VAR 0 4
30600: PUSH
30601: LD_VAR 0 2
30605: PUSH
30606: LD_INT 1
30608: ARRAY
30609: PPUSH
30610: LD_VAR 0 2
30614: PUSH
30615: LD_INT 2
30617: ARRAY
30618: PPUSH
30619: LD_VAR 0 2
30623: PUSH
30624: LD_INT 3
30626: ARRAY
30627: PPUSH
30628: LD_VAR 0 2
30632: PUSH
30633: LD_INT 4
30635: ARRAY
30636: PPUSH
30637: CALL_OW 449
30641: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
30642: LD_ADDR_VAR 0 3
30646: PUSH
30647: LD_VAR 0 5
30651: PPUSH
30652: LD_INT 1
30654: PPUSH
30655: CALL_OW 275
30659: PUSH
30660: LD_VAR 0 4
30664: PUSH
30665: LD_INT 1
30667: ARRAY
30668: GREATEREQUAL
30669: PUSH
30670: LD_VAR 0 5
30674: PPUSH
30675: LD_INT 2
30677: PPUSH
30678: CALL_OW 275
30682: PUSH
30683: LD_VAR 0 4
30687: PUSH
30688: LD_INT 2
30690: ARRAY
30691: GREATEREQUAL
30692: AND
30693: PUSH
30694: LD_VAR 0 5
30698: PPUSH
30699: LD_INT 3
30701: PPUSH
30702: CALL_OW 275
30706: PUSH
30707: LD_VAR 0 4
30711: PUSH
30712: LD_INT 3
30714: ARRAY
30715: GREATEREQUAL
30716: AND
30717: ST_TO_ADDR
// end ;
30718: LD_VAR 0 3
30722: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
30723: LD_INT 0
30725: PPUSH
30726: PPUSH
30727: PPUSH
30728: PPUSH
// pom := GetBase ( building ) ;
30729: LD_ADDR_VAR 0 3
30733: PUSH
30734: LD_VAR 0 1
30738: PPUSH
30739: CALL_OW 274
30743: ST_TO_ADDR
// if not pom then
30744: LD_VAR 0 3
30748: NOT
30749: IFFALSE 30753
// exit ;
30751: GO 30923
// btype := GetBType ( building ) ;
30753: LD_ADDR_VAR 0 5
30757: PUSH
30758: LD_VAR 0 1
30762: PPUSH
30763: CALL_OW 266
30767: ST_TO_ADDR
// if btype = b_armoury then
30768: LD_VAR 0 5
30772: PUSH
30773: LD_INT 4
30775: EQUAL
30776: IFFALSE 30786
// btype := b_barracks ;
30778: LD_ADDR_VAR 0 5
30782: PUSH
30783: LD_INT 5
30785: ST_TO_ADDR
// if btype = b_depot then
30786: LD_VAR 0 5
30790: PUSH
30791: LD_INT 0
30793: EQUAL
30794: IFFALSE 30804
// btype := b_warehouse ;
30796: LD_ADDR_VAR 0 5
30800: PUSH
30801: LD_INT 1
30803: ST_TO_ADDR
// if btype = b_workshop then
30804: LD_VAR 0 5
30808: PUSH
30809: LD_INT 2
30811: EQUAL
30812: IFFALSE 30822
// btype := b_factory ;
30814: LD_ADDR_VAR 0 5
30818: PUSH
30819: LD_INT 3
30821: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
30822: LD_ADDR_VAR 0 4
30826: PUSH
30827: LD_VAR 0 5
30831: PPUSH
30832: LD_VAR 0 1
30836: PPUSH
30837: CALL_OW 248
30841: PPUSH
30842: CALL_OW 450
30846: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
30847: LD_ADDR_VAR 0 2
30851: PUSH
30852: LD_VAR 0 3
30856: PPUSH
30857: LD_INT 1
30859: PPUSH
30860: CALL_OW 275
30864: PUSH
30865: LD_VAR 0 4
30869: PUSH
30870: LD_INT 1
30872: ARRAY
30873: GREATEREQUAL
30874: PUSH
30875: LD_VAR 0 3
30879: PPUSH
30880: LD_INT 2
30882: PPUSH
30883: CALL_OW 275
30887: PUSH
30888: LD_VAR 0 4
30892: PUSH
30893: LD_INT 2
30895: ARRAY
30896: GREATEREQUAL
30897: AND
30898: PUSH
30899: LD_VAR 0 3
30903: PPUSH
30904: LD_INT 3
30906: PPUSH
30907: CALL_OW 275
30911: PUSH
30912: LD_VAR 0 4
30916: PUSH
30917: LD_INT 3
30919: ARRAY
30920: GREATEREQUAL
30921: AND
30922: ST_TO_ADDR
// end ;
30923: LD_VAR 0 2
30927: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
30928: LD_INT 0
30930: PPUSH
30931: PPUSH
30932: PPUSH
// pom := GetBase ( building ) ;
30933: LD_ADDR_VAR 0 4
30937: PUSH
30938: LD_VAR 0 1
30942: PPUSH
30943: CALL_OW 274
30947: ST_TO_ADDR
// if not pom then
30948: LD_VAR 0 4
30952: NOT
30953: IFFALSE 30957
// exit ;
30955: GO 31058
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
30957: LD_ADDR_VAR 0 5
30961: PUSH
30962: LD_VAR 0 2
30966: PPUSH
30967: LD_VAR 0 1
30971: PPUSH
30972: CALL_OW 248
30976: PPUSH
30977: CALL_OW 450
30981: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
30982: LD_ADDR_VAR 0 3
30986: PUSH
30987: LD_VAR 0 4
30991: PPUSH
30992: LD_INT 1
30994: PPUSH
30995: CALL_OW 275
30999: PUSH
31000: LD_VAR 0 5
31004: PUSH
31005: LD_INT 1
31007: ARRAY
31008: GREATEREQUAL
31009: PUSH
31010: LD_VAR 0 4
31014: PPUSH
31015: LD_INT 2
31017: PPUSH
31018: CALL_OW 275
31022: PUSH
31023: LD_VAR 0 5
31027: PUSH
31028: LD_INT 2
31030: ARRAY
31031: GREATEREQUAL
31032: AND
31033: PUSH
31034: LD_VAR 0 4
31038: PPUSH
31039: LD_INT 3
31041: PPUSH
31042: CALL_OW 275
31046: PUSH
31047: LD_VAR 0 5
31051: PUSH
31052: LD_INT 3
31054: ARRAY
31055: GREATEREQUAL
31056: AND
31057: ST_TO_ADDR
// end ;
31058: LD_VAR 0 3
31062: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
31063: LD_INT 0
31065: PPUSH
31066: PPUSH
31067: PPUSH
31068: PPUSH
31069: PPUSH
31070: PPUSH
31071: PPUSH
31072: PPUSH
31073: PPUSH
31074: PPUSH
31075: PPUSH
// result := false ;
31076: LD_ADDR_VAR 0 8
31080: PUSH
31081: LD_INT 0
31083: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
31084: LD_VAR 0 5
31088: NOT
31089: PUSH
31090: LD_VAR 0 1
31094: NOT
31095: OR
31096: PUSH
31097: LD_VAR 0 2
31101: NOT
31102: OR
31103: PUSH
31104: LD_VAR 0 3
31108: NOT
31109: OR
31110: IFFALSE 31114
// exit ;
31112: GO 31928
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
31114: LD_ADDR_VAR 0 14
31118: PUSH
31119: LD_VAR 0 1
31123: PPUSH
31124: LD_VAR 0 2
31128: PPUSH
31129: LD_VAR 0 3
31133: PPUSH
31134: LD_VAR 0 4
31138: PPUSH
31139: LD_VAR 0 5
31143: PUSH
31144: LD_INT 1
31146: ARRAY
31147: PPUSH
31148: CALL_OW 248
31152: PPUSH
31153: LD_INT 0
31155: PPUSH
31156: CALL 33165 0 6
31160: ST_TO_ADDR
// if not hexes then
31161: LD_VAR 0 14
31165: NOT
31166: IFFALSE 31170
// exit ;
31168: GO 31928
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
31170: LD_ADDR_VAR 0 17
31174: PUSH
31175: LD_VAR 0 5
31179: PPUSH
31180: LD_INT 22
31182: PUSH
31183: LD_VAR 0 13
31187: PPUSH
31188: CALL_OW 255
31192: PUSH
31193: EMPTY
31194: LIST
31195: LIST
31196: PUSH
31197: LD_INT 2
31199: PUSH
31200: LD_INT 30
31202: PUSH
31203: LD_INT 0
31205: PUSH
31206: EMPTY
31207: LIST
31208: LIST
31209: PUSH
31210: LD_INT 30
31212: PUSH
31213: LD_INT 1
31215: PUSH
31216: EMPTY
31217: LIST
31218: LIST
31219: PUSH
31220: EMPTY
31221: LIST
31222: LIST
31223: LIST
31224: PUSH
31225: EMPTY
31226: LIST
31227: LIST
31228: PPUSH
31229: CALL_OW 72
31233: ST_TO_ADDR
// for i = 1 to hexes do
31234: LD_ADDR_VAR 0 9
31238: PUSH
31239: DOUBLE
31240: LD_INT 1
31242: DEC
31243: ST_TO_ADDR
31244: LD_VAR 0 14
31248: PUSH
31249: FOR_TO
31250: IFFALSE 31926
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
31252: LD_ADDR_VAR 0 13
31256: PUSH
31257: LD_VAR 0 14
31261: PUSH
31262: LD_VAR 0 9
31266: ARRAY
31267: PUSH
31268: LD_INT 1
31270: ARRAY
31271: PPUSH
31272: LD_VAR 0 14
31276: PUSH
31277: LD_VAR 0 9
31281: ARRAY
31282: PUSH
31283: LD_INT 2
31285: ARRAY
31286: PPUSH
31287: CALL_OW 428
31291: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
31292: LD_VAR 0 14
31296: PUSH
31297: LD_VAR 0 9
31301: ARRAY
31302: PUSH
31303: LD_INT 1
31305: ARRAY
31306: PPUSH
31307: LD_VAR 0 14
31311: PUSH
31312: LD_VAR 0 9
31316: ARRAY
31317: PUSH
31318: LD_INT 2
31320: ARRAY
31321: PPUSH
31322: CALL_OW 351
31326: PUSH
31327: LD_VAR 0 14
31331: PUSH
31332: LD_VAR 0 9
31336: ARRAY
31337: PUSH
31338: LD_INT 1
31340: ARRAY
31341: PPUSH
31342: LD_VAR 0 14
31346: PUSH
31347: LD_VAR 0 9
31351: ARRAY
31352: PUSH
31353: LD_INT 2
31355: ARRAY
31356: PPUSH
31357: CALL_OW 488
31361: NOT
31362: OR
31363: PUSH
31364: LD_VAR 0 13
31368: PPUSH
31369: CALL_OW 247
31373: PUSH
31374: LD_INT 3
31376: EQUAL
31377: OR
31378: IFFALSE 31384
// exit ;
31380: POP
31381: POP
31382: GO 31928
// if not tmp then
31384: LD_VAR 0 13
31388: NOT
31389: IFFALSE 31393
// continue ;
31391: GO 31249
// result := true ;
31393: LD_ADDR_VAR 0 8
31397: PUSH
31398: LD_INT 1
31400: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
31401: LD_VAR 0 6
31405: PUSH
31406: LD_VAR 0 13
31410: PPUSH
31411: CALL_OW 247
31415: PUSH
31416: LD_INT 2
31418: EQUAL
31419: AND
31420: PUSH
31421: LD_VAR 0 13
31425: PPUSH
31426: CALL_OW 263
31430: PUSH
31431: LD_INT 1
31433: EQUAL
31434: AND
31435: IFFALSE 31599
// begin if IsDrivenBy ( tmp ) then
31437: LD_VAR 0 13
31441: PPUSH
31442: CALL_OW 311
31446: IFFALSE 31450
// continue ;
31448: GO 31249
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
31450: LD_VAR 0 6
31454: PPUSH
31455: LD_INT 3
31457: PUSH
31458: LD_INT 60
31460: PUSH
31461: EMPTY
31462: LIST
31463: PUSH
31464: EMPTY
31465: LIST
31466: LIST
31467: PUSH
31468: LD_INT 3
31470: PUSH
31471: LD_INT 55
31473: PUSH
31474: EMPTY
31475: LIST
31476: PUSH
31477: EMPTY
31478: LIST
31479: LIST
31480: PUSH
31481: EMPTY
31482: LIST
31483: LIST
31484: PPUSH
31485: CALL_OW 72
31489: IFFALSE 31597
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
31491: LD_ADDR_VAR 0 18
31495: PUSH
31496: LD_VAR 0 6
31500: PPUSH
31501: LD_INT 3
31503: PUSH
31504: LD_INT 60
31506: PUSH
31507: EMPTY
31508: LIST
31509: PUSH
31510: EMPTY
31511: LIST
31512: LIST
31513: PUSH
31514: LD_INT 3
31516: PUSH
31517: LD_INT 55
31519: PUSH
31520: EMPTY
31521: LIST
31522: PUSH
31523: EMPTY
31524: LIST
31525: LIST
31526: PUSH
31527: EMPTY
31528: LIST
31529: LIST
31530: PPUSH
31531: CALL_OW 72
31535: PUSH
31536: LD_INT 1
31538: ARRAY
31539: ST_TO_ADDR
// if IsInUnit ( driver ) then
31540: LD_VAR 0 18
31544: PPUSH
31545: CALL_OW 310
31549: IFFALSE 31560
// ComExit ( driver ) ;
31551: LD_VAR 0 18
31555: PPUSH
31556: CALL 56349 0 1
// AddComEnterUnit ( driver , tmp ) ;
31560: LD_VAR 0 18
31564: PPUSH
31565: LD_VAR 0 13
31569: PPUSH
31570: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
31574: LD_VAR 0 18
31578: PPUSH
31579: LD_VAR 0 7
31583: PPUSH
31584: CALL_OW 173
// AddComExitVehicle ( driver ) ;
31588: LD_VAR 0 18
31592: PPUSH
31593: CALL_OW 181
// end ; continue ;
31597: GO 31249
// end ; if not cleaners or not tmp in cleaners then
31599: LD_VAR 0 6
31603: NOT
31604: PUSH
31605: LD_VAR 0 13
31609: PUSH
31610: LD_VAR 0 6
31614: IN
31615: NOT
31616: OR
31617: IFFALSE 31924
// begin if dep then
31619: LD_VAR 0 17
31623: IFFALSE 31759
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
31625: LD_ADDR_VAR 0 16
31629: PUSH
31630: LD_VAR 0 17
31634: PUSH
31635: LD_INT 1
31637: ARRAY
31638: PPUSH
31639: CALL_OW 250
31643: PPUSH
31644: LD_VAR 0 17
31648: PUSH
31649: LD_INT 1
31651: ARRAY
31652: PPUSH
31653: CALL_OW 254
31657: PPUSH
31658: LD_INT 5
31660: PPUSH
31661: CALL_OW 272
31665: PUSH
31666: LD_VAR 0 17
31670: PUSH
31671: LD_INT 1
31673: ARRAY
31674: PPUSH
31675: CALL_OW 251
31679: PPUSH
31680: LD_VAR 0 17
31684: PUSH
31685: LD_INT 1
31687: ARRAY
31688: PPUSH
31689: CALL_OW 254
31693: PPUSH
31694: LD_INT 5
31696: PPUSH
31697: CALL_OW 273
31701: PUSH
31702: EMPTY
31703: LIST
31704: LIST
31705: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
31706: LD_VAR 0 16
31710: PUSH
31711: LD_INT 1
31713: ARRAY
31714: PPUSH
31715: LD_VAR 0 16
31719: PUSH
31720: LD_INT 2
31722: ARRAY
31723: PPUSH
31724: CALL_OW 488
31728: IFFALSE 31759
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
31730: LD_VAR 0 13
31734: PPUSH
31735: LD_VAR 0 16
31739: PUSH
31740: LD_INT 1
31742: ARRAY
31743: PPUSH
31744: LD_VAR 0 16
31748: PUSH
31749: LD_INT 2
31751: ARRAY
31752: PPUSH
31753: CALL_OW 111
// continue ;
31757: GO 31249
// end ; end ; r := GetDir ( tmp ) ;
31759: LD_ADDR_VAR 0 15
31763: PUSH
31764: LD_VAR 0 13
31768: PPUSH
31769: CALL_OW 254
31773: ST_TO_ADDR
// if r = 5 then
31774: LD_VAR 0 15
31778: PUSH
31779: LD_INT 5
31781: EQUAL
31782: IFFALSE 31792
// r := 0 ;
31784: LD_ADDR_VAR 0 15
31788: PUSH
31789: LD_INT 0
31791: ST_TO_ADDR
// for j = r to 5 do
31792: LD_ADDR_VAR 0 10
31796: PUSH
31797: DOUBLE
31798: LD_VAR 0 15
31802: DEC
31803: ST_TO_ADDR
31804: LD_INT 5
31806: PUSH
31807: FOR_TO
31808: IFFALSE 31922
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
31810: LD_ADDR_VAR 0 11
31814: PUSH
31815: LD_VAR 0 13
31819: PPUSH
31820: CALL_OW 250
31824: PPUSH
31825: LD_VAR 0 10
31829: PPUSH
31830: LD_INT 2
31832: PPUSH
31833: CALL_OW 272
31837: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
31838: LD_ADDR_VAR 0 12
31842: PUSH
31843: LD_VAR 0 13
31847: PPUSH
31848: CALL_OW 251
31852: PPUSH
31853: LD_VAR 0 10
31857: PPUSH
31858: LD_INT 2
31860: PPUSH
31861: CALL_OW 273
31865: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
31866: LD_VAR 0 11
31870: PPUSH
31871: LD_VAR 0 12
31875: PPUSH
31876: CALL_OW 488
31880: PUSH
31881: LD_VAR 0 11
31885: PPUSH
31886: LD_VAR 0 12
31890: PPUSH
31891: CALL_OW 428
31895: NOT
31896: AND
31897: IFFALSE 31920
// begin ComMoveXY ( tmp , _x , _y ) ;
31899: LD_VAR 0 13
31903: PPUSH
31904: LD_VAR 0 11
31908: PPUSH
31909: LD_VAR 0 12
31913: PPUSH
31914: CALL_OW 111
// break ;
31918: GO 31922
// end ; end ;
31920: GO 31807
31922: POP
31923: POP
// end ; end ;
31924: GO 31249
31926: POP
31927: POP
// end ;
31928: LD_VAR 0 8
31932: RET
// export function BuildingTechInvented ( side , btype ) ; begin
31933: LD_INT 0
31935: PPUSH
// result := true ;
31936: LD_ADDR_VAR 0 3
31940: PUSH
31941: LD_INT 1
31943: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
31944: LD_VAR 0 2
31948: PUSH
31949: LD_INT 24
31951: DOUBLE
31952: EQUAL
31953: IFTRUE 31963
31955: LD_INT 33
31957: DOUBLE
31958: EQUAL
31959: IFTRUE 31963
31961: GO 31988
31963: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
31964: LD_ADDR_VAR 0 3
31968: PUSH
31969: LD_INT 32
31971: PPUSH
31972: LD_VAR 0 1
31976: PPUSH
31977: CALL_OW 321
31981: PUSH
31982: LD_INT 2
31984: EQUAL
31985: ST_TO_ADDR
31986: GO 32308
31988: LD_INT 20
31990: DOUBLE
31991: EQUAL
31992: IFTRUE 31996
31994: GO 32021
31996: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
31997: LD_ADDR_VAR 0 3
32001: PUSH
32002: LD_INT 6
32004: PPUSH
32005: LD_VAR 0 1
32009: PPUSH
32010: CALL_OW 321
32014: PUSH
32015: LD_INT 2
32017: EQUAL
32018: ST_TO_ADDR
32019: GO 32308
32021: LD_INT 22
32023: DOUBLE
32024: EQUAL
32025: IFTRUE 32035
32027: LD_INT 36
32029: DOUBLE
32030: EQUAL
32031: IFTRUE 32035
32033: GO 32060
32035: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
32036: LD_ADDR_VAR 0 3
32040: PUSH
32041: LD_INT 15
32043: PPUSH
32044: LD_VAR 0 1
32048: PPUSH
32049: CALL_OW 321
32053: PUSH
32054: LD_INT 2
32056: EQUAL
32057: ST_TO_ADDR
32058: GO 32308
32060: LD_INT 30
32062: DOUBLE
32063: EQUAL
32064: IFTRUE 32068
32066: GO 32093
32068: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
32069: LD_ADDR_VAR 0 3
32073: PUSH
32074: LD_INT 20
32076: PPUSH
32077: LD_VAR 0 1
32081: PPUSH
32082: CALL_OW 321
32086: PUSH
32087: LD_INT 2
32089: EQUAL
32090: ST_TO_ADDR
32091: GO 32308
32093: LD_INT 28
32095: DOUBLE
32096: EQUAL
32097: IFTRUE 32107
32099: LD_INT 21
32101: DOUBLE
32102: EQUAL
32103: IFTRUE 32107
32105: GO 32132
32107: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
32108: LD_ADDR_VAR 0 3
32112: PUSH
32113: LD_INT 21
32115: PPUSH
32116: LD_VAR 0 1
32120: PPUSH
32121: CALL_OW 321
32125: PUSH
32126: LD_INT 2
32128: EQUAL
32129: ST_TO_ADDR
32130: GO 32308
32132: LD_INT 16
32134: DOUBLE
32135: EQUAL
32136: IFTRUE 32140
32138: GO 32167
32140: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
32141: LD_ADDR_VAR 0 3
32145: PUSH
32146: LD_EXP 166
32150: PPUSH
32151: LD_VAR 0 1
32155: PPUSH
32156: CALL_OW 321
32160: PUSH
32161: LD_INT 2
32163: EQUAL
32164: ST_TO_ADDR
32165: GO 32308
32167: LD_INT 19
32169: DOUBLE
32170: EQUAL
32171: IFTRUE 32181
32173: LD_INT 23
32175: DOUBLE
32176: EQUAL
32177: IFTRUE 32181
32179: GO 32208
32181: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
32182: LD_ADDR_VAR 0 3
32186: PUSH
32187: LD_EXP 165
32191: PPUSH
32192: LD_VAR 0 1
32196: PPUSH
32197: CALL_OW 321
32201: PUSH
32202: LD_INT 2
32204: EQUAL
32205: ST_TO_ADDR
32206: GO 32308
32208: LD_INT 17
32210: DOUBLE
32211: EQUAL
32212: IFTRUE 32216
32214: GO 32241
32216: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
32217: LD_ADDR_VAR 0 3
32221: PUSH
32222: LD_INT 39
32224: PPUSH
32225: LD_VAR 0 1
32229: PPUSH
32230: CALL_OW 321
32234: PUSH
32235: LD_INT 2
32237: EQUAL
32238: ST_TO_ADDR
32239: GO 32308
32241: LD_INT 18
32243: DOUBLE
32244: EQUAL
32245: IFTRUE 32249
32247: GO 32274
32249: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
32250: LD_ADDR_VAR 0 3
32254: PUSH
32255: LD_INT 40
32257: PPUSH
32258: LD_VAR 0 1
32262: PPUSH
32263: CALL_OW 321
32267: PUSH
32268: LD_INT 2
32270: EQUAL
32271: ST_TO_ADDR
32272: GO 32308
32274: LD_INT 27
32276: DOUBLE
32277: EQUAL
32278: IFTRUE 32282
32280: GO 32307
32282: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
32283: LD_ADDR_VAR 0 3
32287: PUSH
32288: LD_INT 35
32290: PPUSH
32291: LD_VAR 0 1
32295: PPUSH
32296: CALL_OW 321
32300: PUSH
32301: LD_INT 2
32303: EQUAL
32304: ST_TO_ADDR
32305: GO 32308
32307: POP
// end ;
32308: LD_VAR 0 3
32312: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
32313: LD_INT 0
32315: PPUSH
32316: PPUSH
32317: PPUSH
32318: PPUSH
32319: PPUSH
32320: PPUSH
32321: PPUSH
32322: PPUSH
32323: PPUSH
32324: PPUSH
32325: PPUSH
// result := false ;
32326: LD_ADDR_VAR 0 6
32330: PUSH
32331: LD_INT 0
32333: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
32334: LD_VAR 0 1
32338: NOT
32339: PUSH
32340: LD_VAR 0 1
32344: PPUSH
32345: CALL_OW 266
32349: PUSH
32350: LD_INT 0
32352: PUSH
32353: LD_INT 1
32355: PUSH
32356: EMPTY
32357: LIST
32358: LIST
32359: IN
32360: NOT
32361: OR
32362: PUSH
32363: LD_VAR 0 2
32367: NOT
32368: OR
32369: PUSH
32370: LD_VAR 0 5
32374: PUSH
32375: LD_INT 0
32377: PUSH
32378: LD_INT 1
32380: PUSH
32381: LD_INT 2
32383: PUSH
32384: LD_INT 3
32386: PUSH
32387: LD_INT 4
32389: PUSH
32390: LD_INT 5
32392: PUSH
32393: EMPTY
32394: LIST
32395: LIST
32396: LIST
32397: LIST
32398: LIST
32399: LIST
32400: IN
32401: NOT
32402: OR
32403: PUSH
32404: LD_VAR 0 3
32408: PPUSH
32409: LD_VAR 0 4
32413: PPUSH
32414: CALL_OW 488
32418: NOT
32419: OR
32420: IFFALSE 32424
// exit ;
32422: GO 33160
// side := GetSide ( depot ) ;
32424: LD_ADDR_VAR 0 9
32428: PUSH
32429: LD_VAR 0 1
32433: PPUSH
32434: CALL_OW 255
32438: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
32439: LD_VAR 0 9
32443: PPUSH
32444: LD_VAR 0 2
32448: PPUSH
32449: CALL 31933 0 2
32453: NOT
32454: IFFALSE 32458
// exit ;
32456: GO 33160
// pom := GetBase ( depot ) ;
32458: LD_ADDR_VAR 0 10
32462: PUSH
32463: LD_VAR 0 1
32467: PPUSH
32468: CALL_OW 274
32472: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
32473: LD_ADDR_VAR 0 11
32477: PUSH
32478: LD_VAR 0 2
32482: PPUSH
32483: LD_VAR 0 1
32487: PPUSH
32488: CALL_OW 248
32492: PPUSH
32493: CALL_OW 450
32497: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
32498: LD_VAR 0 10
32502: PPUSH
32503: LD_INT 1
32505: PPUSH
32506: CALL_OW 275
32510: PUSH
32511: LD_VAR 0 11
32515: PUSH
32516: LD_INT 1
32518: ARRAY
32519: GREATEREQUAL
32520: PUSH
32521: LD_VAR 0 10
32525: PPUSH
32526: LD_INT 2
32528: PPUSH
32529: CALL_OW 275
32533: PUSH
32534: LD_VAR 0 11
32538: PUSH
32539: LD_INT 2
32541: ARRAY
32542: GREATEREQUAL
32543: AND
32544: PUSH
32545: LD_VAR 0 10
32549: PPUSH
32550: LD_INT 3
32552: PPUSH
32553: CALL_OW 275
32557: PUSH
32558: LD_VAR 0 11
32562: PUSH
32563: LD_INT 3
32565: ARRAY
32566: GREATEREQUAL
32567: AND
32568: NOT
32569: IFFALSE 32573
// exit ;
32571: GO 33160
// if GetBType ( depot ) = b_depot then
32573: LD_VAR 0 1
32577: PPUSH
32578: CALL_OW 266
32582: PUSH
32583: LD_INT 0
32585: EQUAL
32586: IFFALSE 32598
// dist := 28 else
32588: LD_ADDR_VAR 0 14
32592: PUSH
32593: LD_INT 28
32595: ST_TO_ADDR
32596: GO 32606
// dist := 36 ;
32598: LD_ADDR_VAR 0 14
32602: PUSH
32603: LD_INT 36
32605: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
32606: LD_VAR 0 1
32610: PPUSH
32611: LD_VAR 0 3
32615: PPUSH
32616: LD_VAR 0 4
32620: PPUSH
32621: CALL_OW 297
32625: PUSH
32626: LD_VAR 0 14
32630: GREATER
32631: IFFALSE 32635
// exit ;
32633: GO 33160
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
32635: LD_ADDR_VAR 0 12
32639: PUSH
32640: LD_VAR 0 2
32644: PPUSH
32645: LD_VAR 0 3
32649: PPUSH
32650: LD_VAR 0 4
32654: PPUSH
32655: LD_VAR 0 5
32659: PPUSH
32660: LD_VAR 0 1
32664: PPUSH
32665: CALL_OW 248
32669: PPUSH
32670: LD_INT 0
32672: PPUSH
32673: CALL 33165 0 6
32677: ST_TO_ADDR
// if not hexes then
32678: LD_VAR 0 12
32682: NOT
32683: IFFALSE 32687
// exit ;
32685: GO 33160
// hex := GetHexInfo ( x , y ) ;
32687: LD_ADDR_VAR 0 15
32691: PUSH
32692: LD_VAR 0 3
32696: PPUSH
32697: LD_VAR 0 4
32701: PPUSH
32702: CALL_OW 546
32706: ST_TO_ADDR
// if hex [ 1 ] then
32707: LD_VAR 0 15
32711: PUSH
32712: LD_INT 1
32714: ARRAY
32715: IFFALSE 32719
// exit ;
32717: GO 33160
// height := hex [ 2 ] ;
32719: LD_ADDR_VAR 0 13
32723: PUSH
32724: LD_VAR 0 15
32728: PUSH
32729: LD_INT 2
32731: ARRAY
32732: ST_TO_ADDR
// for i = 1 to hexes do
32733: LD_ADDR_VAR 0 7
32737: PUSH
32738: DOUBLE
32739: LD_INT 1
32741: DEC
32742: ST_TO_ADDR
32743: LD_VAR 0 12
32747: PUSH
32748: FOR_TO
32749: IFFALSE 33079
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
32751: LD_VAR 0 12
32755: PUSH
32756: LD_VAR 0 7
32760: ARRAY
32761: PUSH
32762: LD_INT 1
32764: ARRAY
32765: PPUSH
32766: LD_VAR 0 12
32770: PUSH
32771: LD_VAR 0 7
32775: ARRAY
32776: PUSH
32777: LD_INT 2
32779: ARRAY
32780: PPUSH
32781: CALL_OW 488
32785: NOT
32786: PUSH
32787: LD_VAR 0 12
32791: PUSH
32792: LD_VAR 0 7
32796: ARRAY
32797: PUSH
32798: LD_INT 1
32800: ARRAY
32801: PPUSH
32802: LD_VAR 0 12
32806: PUSH
32807: LD_VAR 0 7
32811: ARRAY
32812: PUSH
32813: LD_INT 2
32815: ARRAY
32816: PPUSH
32817: CALL_OW 428
32821: PUSH
32822: LD_INT 0
32824: GREATER
32825: OR
32826: PUSH
32827: LD_VAR 0 12
32831: PUSH
32832: LD_VAR 0 7
32836: ARRAY
32837: PUSH
32838: LD_INT 1
32840: ARRAY
32841: PPUSH
32842: LD_VAR 0 12
32846: PUSH
32847: LD_VAR 0 7
32851: ARRAY
32852: PUSH
32853: LD_INT 2
32855: ARRAY
32856: PPUSH
32857: CALL_OW 351
32861: OR
32862: IFFALSE 32868
// exit ;
32864: POP
32865: POP
32866: GO 33160
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
32868: LD_ADDR_VAR 0 8
32872: PUSH
32873: LD_VAR 0 12
32877: PUSH
32878: LD_VAR 0 7
32882: ARRAY
32883: PUSH
32884: LD_INT 1
32886: ARRAY
32887: PPUSH
32888: LD_VAR 0 12
32892: PUSH
32893: LD_VAR 0 7
32897: ARRAY
32898: PUSH
32899: LD_INT 2
32901: ARRAY
32902: PPUSH
32903: CALL_OW 546
32907: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
32908: LD_VAR 0 8
32912: PUSH
32913: LD_INT 1
32915: ARRAY
32916: PUSH
32917: LD_VAR 0 8
32921: PUSH
32922: LD_INT 2
32924: ARRAY
32925: PUSH
32926: LD_VAR 0 13
32930: PUSH
32931: LD_INT 2
32933: PLUS
32934: GREATER
32935: OR
32936: PUSH
32937: LD_VAR 0 8
32941: PUSH
32942: LD_INT 2
32944: ARRAY
32945: PUSH
32946: LD_VAR 0 13
32950: PUSH
32951: LD_INT 2
32953: MINUS
32954: LESS
32955: OR
32956: PUSH
32957: LD_VAR 0 8
32961: PUSH
32962: LD_INT 3
32964: ARRAY
32965: PUSH
32966: LD_INT 0
32968: PUSH
32969: LD_INT 8
32971: PUSH
32972: LD_INT 9
32974: PUSH
32975: LD_INT 10
32977: PUSH
32978: LD_INT 11
32980: PUSH
32981: LD_INT 12
32983: PUSH
32984: LD_INT 13
32986: PUSH
32987: LD_INT 16
32989: PUSH
32990: LD_INT 17
32992: PUSH
32993: LD_INT 18
32995: PUSH
32996: LD_INT 19
32998: PUSH
32999: LD_INT 20
33001: PUSH
33002: LD_INT 21
33004: PUSH
33005: EMPTY
33006: LIST
33007: LIST
33008: LIST
33009: LIST
33010: LIST
33011: LIST
33012: LIST
33013: LIST
33014: LIST
33015: LIST
33016: LIST
33017: LIST
33018: LIST
33019: IN
33020: NOT
33021: OR
33022: PUSH
33023: LD_VAR 0 8
33027: PUSH
33028: LD_INT 5
33030: ARRAY
33031: NOT
33032: OR
33033: PUSH
33034: LD_VAR 0 8
33038: PUSH
33039: LD_INT 6
33041: ARRAY
33042: PUSH
33043: LD_INT 1
33045: PUSH
33046: LD_INT 2
33048: PUSH
33049: LD_INT 7
33051: PUSH
33052: LD_INT 9
33054: PUSH
33055: LD_INT 10
33057: PUSH
33058: LD_INT 11
33060: PUSH
33061: EMPTY
33062: LIST
33063: LIST
33064: LIST
33065: LIST
33066: LIST
33067: LIST
33068: IN
33069: NOT
33070: OR
33071: IFFALSE 33077
// exit ;
33073: POP
33074: POP
33075: GO 33160
// end ;
33077: GO 32748
33079: POP
33080: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
33081: LD_VAR 0 9
33085: PPUSH
33086: LD_VAR 0 3
33090: PPUSH
33091: LD_VAR 0 4
33095: PPUSH
33096: LD_INT 20
33098: PPUSH
33099: CALL 25106 0 4
33103: PUSH
33104: LD_INT 4
33106: ARRAY
33107: IFFALSE 33111
// exit ;
33109: GO 33160
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
33111: LD_VAR 0 2
33115: PUSH
33116: LD_INT 29
33118: PUSH
33119: LD_INT 30
33121: PUSH
33122: EMPTY
33123: LIST
33124: LIST
33125: IN
33126: PUSH
33127: LD_VAR 0 3
33131: PPUSH
33132: LD_VAR 0 4
33136: PPUSH
33137: LD_VAR 0 9
33141: PPUSH
33142: CALL_OW 440
33146: NOT
33147: AND
33148: IFFALSE 33152
// exit ;
33150: GO 33160
// result := true ;
33152: LD_ADDR_VAR 0 6
33156: PUSH
33157: LD_INT 1
33159: ST_TO_ADDR
// end ;
33160: LD_VAR 0 6
33164: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
33165: LD_INT 0
33167: PPUSH
33168: PPUSH
33169: PPUSH
33170: PPUSH
33171: PPUSH
33172: PPUSH
33173: PPUSH
33174: PPUSH
33175: PPUSH
33176: PPUSH
33177: PPUSH
33178: PPUSH
33179: PPUSH
33180: PPUSH
33181: PPUSH
33182: PPUSH
33183: PPUSH
33184: PPUSH
33185: PPUSH
33186: PPUSH
33187: PPUSH
33188: PPUSH
33189: PPUSH
33190: PPUSH
33191: PPUSH
33192: PPUSH
33193: PPUSH
33194: PPUSH
33195: PPUSH
33196: PPUSH
33197: PPUSH
33198: PPUSH
33199: PPUSH
33200: PPUSH
33201: PPUSH
33202: PPUSH
33203: PPUSH
33204: PPUSH
33205: PPUSH
33206: PPUSH
33207: PPUSH
33208: PPUSH
33209: PPUSH
33210: PPUSH
33211: PPUSH
33212: PPUSH
33213: PPUSH
33214: PPUSH
33215: PPUSH
33216: PPUSH
33217: PPUSH
33218: PPUSH
33219: PPUSH
33220: PPUSH
33221: PPUSH
33222: PPUSH
33223: PPUSH
33224: PPUSH
// result = [ ] ;
33225: LD_ADDR_VAR 0 7
33229: PUSH
33230: EMPTY
33231: ST_TO_ADDR
// temp_list = [ ] ;
33232: LD_ADDR_VAR 0 9
33236: PUSH
33237: EMPTY
33238: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
33239: LD_VAR 0 4
33243: PUSH
33244: LD_INT 0
33246: PUSH
33247: LD_INT 1
33249: PUSH
33250: LD_INT 2
33252: PUSH
33253: LD_INT 3
33255: PUSH
33256: LD_INT 4
33258: PUSH
33259: LD_INT 5
33261: PUSH
33262: EMPTY
33263: LIST
33264: LIST
33265: LIST
33266: LIST
33267: LIST
33268: LIST
33269: IN
33270: NOT
33271: PUSH
33272: LD_VAR 0 1
33276: PUSH
33277: LD_INT 0
33279: PUSH
33280: LD_INT 1
33282: PUSH
33283: EMPTY
33284: LIST
33285: LIST
33286: IN
33287: PUSH
33288: LD_VAR 0 5
33292: PUSH
33293: LD_INT 1
33295: PUSH
33296: LD_INT 2
33298: PUSH
33299: LD_INT 3
33301: PUSH
33302: EMPTY
33303: LIST
33304: LIST
33305: LIST
33306: IN
33307: NOT
33308: AND
33309: OR
33310: IFFALSE 33314
// exit ;
33312: GO 51705
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
33314: LD_VAR 0 1
33318: PUSH
33319: LD_INT 6
33321: PUSH
33322: LD_INT 7
33324: PUSH
33325: LD_INT 8
33327: PUSH
33328: LD_INT 13
33330: PUSH
33331: LD_INT 12
33333: PUSH
33334: LD_INT 15
33336: PUSH
33337: LD_INT 11
33339: PUSH
33340: LD_INT 14
33342: PUSH
33343: LD_INT 10
33345: PUSH
33346: EMPTY
33347: LIST
33348: LIST
33349: LIST
33350: LIST
33351: LIST
33352: LIST
33353: LIST
33354: LIST
33355: LIST
33356: IN
33357: IFFALSE 33367
// btype = b_lab ;
33359: LD_ADDR_VAR 0 1
33363: PUSH
33364: LD_INT 6
33366: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
33367: LD_VAR 0 6
33371: PUSH
33372: LD_INT 0
33374: PUSH
33375: LD_INT 1
33377: PUSH
33378: LD_INT 2
33380: PUSH
33381: EMPTY
33382: LIST
33383: LIST
33384: LIST
33385: IN
33386: NOT
33387: PUSH
33388: LD_VAR 0 1
33392: PUSH
33393: LD_INT 0
33395: PUSH
33396: LD_INT 1
33398: PUSH
33399: LD_INT 2
33401: PUSH
33402: LD_INT 3
33404: PUSH
33405: LD_INT 6
33407: PUSH
33408: LD_INT 36
33410: PUSH
33411: LD_INT 4
33413: PUSH
33414: LD_INT 5
33416: PUSH
33417: LD_INT 31
33419: PUSH
33420: LD_INT 32
33422: PUSH
33423: LD_INT 33
33425: PUSH
33426: EMPTY
33427: LIST
33428: LIST
33429: LIST
33430: LIST
33431: LIST
33432: LIST
33433: LIST
33434: LIST
33435: LIST
33436: LIST
33437: LIST
33438: IN
33439: NOT
33440: PUSH
33441: LD_VAR 0 6
33445: PUSH
33446: LD_INT 1
33448: EQUAL
33449: AND
33450: OR
33451: PUSH
33452: LD_VAR 0 1
33456: PUSH
33457: LD_INT 2
33459: PUSH
33460: LD_INT 3
33462: PUSH
33463: EMPTY
33464: LIST
33465: LIST
33466: IN
33467: NOT
33468: PUSH
33469: LD_VAR 0 6
33473: PUSH
33474: LD_INT 2
33476: EQUAL
33477: AND
33478: OR
33479: IFFALSE 33489
// mode = 0 ;
33481: LD_ADDR_VAR 0 6
33485: PUSH
33486: LD_INT 0
33488: ST_TO_ADDR
// case mode of 0 :
33489: LD_VAR 0 6
33493: PUSH
33494: LD_INT 0
33496: DOUBLE
33497: EQUAL
33498: IFTRUE 33502
33500: GO 44955
33502: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
33503: LD_ADDR_VAR 0 11
33507: PUSH
33508: LD_INT 0
33510: PUSH
33511: LD_INT 0
33513: PUSH
33514: EMPTY
33515: LIST
33516: LIST
33517: PUSH
33518: LD_INT 0
33520: PUSH
33521: LD_INT 1
33523: NEG
33524: PUSH
33525: EMPTY
33526: LIST
33527: LIST
33528: PUSH
33529: LD_INT 1
33531: PUSH
33532: LD_INT 0
33534: PUSH
33535: EMPTY
33536: LIST
33537: LIST
33538: PUSH
33539: LD_INT 1
33541: PUSH
33542: LD_INT 1
33544: PUSH
33545: EMPTY
33546: LIST
33547: LIST
33548: PUSH
33549: LD_INT 0
33551: PUSH
33552: LD_INT 1
33554: PUSH
33555: EMPTY
33556: LIST
33557: LIST
33558: PUSH
33559: LD_INT 1
33561: NEG
33562: PUSH
33563: LD_INT 0
33565: PUSH
33566: EMPTY
33567: LIST
33568: LIST
33569: PUSH
33570: LD_INT 1
33572: NEG
33573: PUSH
33574: LD_INT 1
33576: NEG
33577: PUSH
33578: EMPTY
33579: LIST
33580: LIST
33581: PUSH
33582: LD_INT 1
33584: NEG
33585: PUSH
33586: LD_INT 2
33588: NEG
33589: PUSH
33590: EMPTY
33591: LIST
33592: LIST
33593: PUSH
33594: LD_INT 0
33596: PUSH
33597: LD_INT 2
33599: NEG
33600: PUSH
33601: EMPTY
33602: LIST
33603: LIST
33604: PUSH
33605: LD_INT 1
33607: PUSH
33608: LD_INT 1
33610: NEG
33611: PUSH
33612: EMPTY
33613: LIST
33614: LIST
33615: PUSH
33616: LD_INT 1
33618: PUSH
33619: LD_INT 2
33621: PUSH
33622: EMPTY
33623: LIST
33624: LIST
33625: PUSH
33626: LD_INT 0
33628: PUSH
33629: LD_INT 2
33631: PUSH
33632: EMPTY
33633: LIST
33634: LIST
33635: PUSH
33636: LD_INT 1
33638: NEG
33639: PUSH
33640: LD_INT 1
33642: PUSH
33643: EMPTY
33644: LIST
33645: LIST
33646: PUSH
33647: LD_INT 1
33649: PUSH
33650: LD_INT 3
33652: PUSH
33653: EMPTY
33654: LIST
33655: LIST
33656: PUSH
33657: LD_INT 0
33659: PUSH
33660: LD_INT 3
33662: PUSH
33663: EMPTY
33664: LIST
33665: LIST
33666: PUSH
33667: LD_INT 1
33669: NEG
33670: PUSH
33671: LD_INT 2
33673: PUSH
33674: EMPTY
33675: LIST
33676: LIST
33677: PUSH
33678: EMPTY
33679: LIST
33680: LIST
33681: LIST
33682: LIST
33683: LIST
33684: LIST
33685: LIST
33686: LIST
33687: LIST
33688: LIST
33689: LIST
33690: LIST
33691: LIST
33692: LIST
33693: LIST
33694: LIST
33695: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
33696: LD_ADDR_VAR 0 12
33700: PUSH
33701: LD_INT 0
33703: PUSH
33704: LD_INT 0
33706: PUSH
33707: EMPTY
33708: LIST
33709: LIST
33710: PUSH
33711: LD_INT 0
33713: PUSH
33714: LD_INT 1
33716: NEG
33717: PUSH
33718: EMPTY
33719: LIST
33720: LIST
33721: PUSH
33722: LD_INT 1
33724: PUSH
33725: LD_INT 0
33727: PUSH
33728: EMPTY
33729: LIST
33730: LIST
33731: PUSH
33732: LD_INT 1
33734: PUSH
33735: LD_INT 1
33737: PUSH
33738: EMPTY
33739: LIST
33740: LIST
33741: PUSH
33742: LD_INT 0
33744: PUSH
33745: LD_INT 1
33747: PUSH
33748: EMPTY
33749: LIST
33750: LIST
33751: PUSH
33752: LD_INT 1
33754: NEG
33755: PUSH
33756: LD_INT 0
33758: PUSH
33759: EMPTY
33760: LIST
33761: LIST
33762: PUSH
33763: LD_INT 1
33765: NEG
33766: PUSH
33767: LD_INT 1
33769: NEG
33770: PUSH
33771: EMPTY
33772: LIST
33773: LIST
33774: PUSH
33775: LD_INT 1
33777: PUSH
33778: LD_INT 1
33780: NEG
33781: PUSH
33782: EMPTY
33783: LIST
33784: LIST
33785: PUSH
33786: LD_INT 2
33788: PUSH
33789: LD_INT 0
33791: PUSH
33792: EMPTY
33793: LIST
33794: LIST
33795: PUSH
33796: LD_INT 2
33798: PUSH
33799: LD_INT 1
33801: PUSH
33802: EMPTY
33803: LIST
33804: LIST
33805: PUSH
33806: LD_INT 1
33808: NEG
33809: PUSH
33810: LD_INT 1
33812: PUSH
33813: EMPTY
33814: LIST
33815: LIST
33816: PUSH
33817: LD_INT 2
33819: NEG
33820: PUSH
33821: LD_INT 0
33823: PUSH
33824: EMPTY
33825: LIST
33826: LIST
33827: PUSH
33828: LD_INT 2
33830: NEG
33831: PUSH
33832: LD_INT 1
33834: NEG
33835: PUSH
33836: EMPTY
33837: LIST
33838: LIST
33839: PUSH
33840: LD_INT 2
33842: NEG
33843: PUSH
33844: LD_INT 1
33846: PUSH
33847: EMPTY
33848: LIST
33849: LIST
33850: PUSH
33851: LD_INT 3
33853: NEG
33854: PUSH
33855: LD_INT 0
33857: PUSH
33858: EMPTY
33859: LIST
33860: LIST
33861: PUSH
33862: LD_INT 3
33864: NEG
33865: PUSH
33866: LD_INT 1
33868: NEG
33869: PUSH
33870: EMPTY
33871: LIST
33872: LIST
33873: PUSH
33874: EMPTY
33875: LIST
33876: LIST
33877: LIST
33878: LIST
33879: LIST
33880: LIST
33881: LIST
33882: LIST
33883: LIST
33884: LIST
33885: LIST
33886: LIST
33887: LIST
33888: LIST
33889: LIST
33890: LIST
33891: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
33892: LD_ADDR_VAR 0 13
33896: PUSH
33897: LD_INT 0
33899: PUSH
33900: LD_INT 0
33902: PUSH
33903: EMPTY
33904: LIST
33905: LIST
33906: PUSH
33907: LD_INT 0
33909: PUSH
33910: LD_INT 1
33912: NEG
33913: PUSH
33914: EMPTY
33915: LIST
33916: LIST
33917: PUSH
33918: LD_INT 1
33920: PUSH
33921: LD_INT 0
33923: PUSH
33924: EMPTY
33925: LIST
33926: LIST
33927: PUSH
33928: LD_INT 1
33930: PUSH
33931: LD_INT 1
33933: PUSH
33934: EMPTY
33935: LIST
33936: LIST
33937: PUSH
33938: LD_INT 0
33940: PUSH
33941: LD_INT 1
33943: PUSH
33944: EMPTY
33945: LIST
33946: LIST
33947: PUSH
33948: LD_INT 1
33950: NEG
33951: PUSH
33952: LD_INT 0
33954: PUSH
33955: EMPTY
33956: LIST
33957: LIST
33958: PUSH
33959: LD_INT 1
33961: NEG
33962: PUSH
33963: LD_INT 1
33965: NEG
33966: PUSH
33967: EMPTY
33968: LIST
33969: LIST
33970: PUSH
33971: LD_INT 1
33973: NEG
33974: PUSH
33975: LD_INT 2
33977: NEG
33978: PUSH
33979: EMPTY
33980: LIST
33981: LIST
33982: PUSH
33983: LD_INT 2
33985: PUSH
33986: LD_INT 1
33988: PUSH
33989: EMPTY
33990: LIST
33991: LIST
33992: PUSH
33993: LD_INT 2
33995: PUSH
33996: LD_INT 2
33998: PUSH
33999: EMPTY
34000: LIST
34001: LIST
34002: PUSH
34003: LD_INT 1
34005: PUSH
34006: LD_INT 2
34008: PUSH
34009: EMPTY
34010: LIST
34011: LIST
34012: PUSH
34013: LD_INT 2
34015: NEG
34016: PUSH
34017: LD_INT 1
34019: NEG
34020: PUSH
34021: EMPTY
34022: LIST
34023: LIST
34024: PUSH
34025: LD_INT 2
34027: NEG
34028: PUSH
34029: LD_INT 2
34031: NEG
34032: PUSH
34033: EMPTY
34034: LIST
34035: LIST
34036: PUSH
34037: LD_INT 2
34039: NEG
34040: PUSH
34041: LD_INT 3
34043: NEG
34044: PUSH
34045: EMPTY
34046: LIST
34047: LIST
34048: PUSH
34049: LD_INT 3
34051: NEG
34052: PUSH
34053: LD_INT 2
34055: NEG
34056: PUSH
34057: EMPTY
34058: LIST
34059: LIST
34060: PUSH
34061: LD_INT 3
34063: NEG
34064: PUSH
34065: LD_INT 3
34067: NEG
34068: PUSH
34069: EMPTY
34070: LIST
34071: LIST
34072: PUSH
34073: EMPTY
34074: LIST
34075: LIST
34076: LIST
34077: LIST
34078: LIST
34079: LIST
34080: LIST
34081: LIST
34082: LIST
34083: LIST
34084: LIST
34085: LIST
34086: LIST
34087: LIST
34088: LIST
34089: LIST
34090: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
34091: LD_ADDR_VAR 0 14
34095: PUSH
34096: LD_INT 0
34098: PUSH
34099: LD_INT 0
34101: PUSH
34102: EMPTY
34103: LIST
34104: LIST
34105: PUSH
34106: LD_INT 0
34108: PUSH
34109: LD_INT 1
34111: NEG
34112: PUSH
34113: EMPTY
34114: LIST
34115: LIST
34116: PUSH
34117: LD_INT 1
34119: PUSH
34120: LD_INT 0
34122: PUSH
34123: EMPTY
34124: LIST
34125: LIST
34126: PUSH
34127: LD_INT 1
34129: PUSH
34130: LD_INT 1
34132: PUSH
34133: EMPTY
34134: LIST
34135: LIST
34136: PUSH
34137: LD_INT 0
34139: PUSH
34140: LD_INT 1
34142: PUSH
34143: EMPTY
34144: LIST
34145: LIST
34146: PUSH
34147: LD_INT 1
34149: NEG
34150: PUSH
34151: LD_INT 0
34153: PUSH
34154: EMPTY
34155: LIST
34156: LIST
34157: PUSH
34158: LD_INT 1
34160: NEG
34161: PUSH
34162: LD_INT 1
34164: NEG
34165: PUSH
34166: EMPTY
34167: LIST
34168: LIST
34169: PUSH
34170: LD_INT 1
34172: NEG
34173: PUSH
34174: LD_INT 2
34176: NEG
34177: PUSH
34178: EMPTY
34179: LIST
34180: LIST
34181: PUSH
34182: LD_INT 0
34184: PUSH
34185: LD_INT 2
34187: NEG
34188: PUSH
34189: EMPTY
34190: LIST
34191: LIST
34192: PUSH
34193: LD_INT 1
34195: PUSH
34196: LD_INT 1
34198: NEG
34199: PUSH
34200: EMPTY
34201: LIST
34202: LIST
34203: PUSH
34204: LD_INT 1
34206: PUSH
34207: LD_INT 2
34209: PUSH
34210: EMPTY
34211: LIST
34212: LIST
34213: PUSH
34214: LD_INT 0
34216: PUSH
34217: LD_INT 2
34219: PUSH
34220: EMPTY
34221: LIST
34222: LIST
34223: PUSH
34224: LD_INT 1
34226: NEG
34227: PUSH
34228: LD_INT 1
34230: PUSH
34231: EMPTY
34232: LIST
34233: LIST
34234: PUSH
34235: LD_INT 1
34237: NEG
34238: PUSH
34239: LD_INT 3
34241: NEG
34242: PUSH
34243: EMPTY
34244: LIST
34245: LIST
34246: PUSH
34247: LD_INT 0
34249: PUSH
34250: LD_INT 3
34252: NEG
34253: PUSH
34254: EMPTY
34255: LIST
34256: LIST
34257: PUSH
34258: LD_INT 1
34260: PUSH
34261: LD_INT 2
34263: NEG
34264: PUSH
34265: EMPTY
34266: LIST
34267: LIST
34268: PUSH
34269: EMPTY
34270: LIST
34271: LIST
34272: LIST
34273: LIST
34274: LIST
34275: LIST
34276: LIST
34277: LIST
34278: LIST
34279: LIST
34280: LIST
34281: LIST
34282: LIST
34283: LIST
34284: LIST
34285: LIST
34286: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
34287: LD_ADDR_VAR 0 15
34291: PUSH
34292: LD_INT 0
34294: PUSH
34295: LD_INT 0
34297: PUSH
34298: EMPTY
34299: LIST
34300: LIST
34301: PUSH
34302: LD_INT 0
34304: PUSH
34305: LD_INT 1
34307: NEG
34308: PUSH
34309: EMPTY
34310: LIST
34311: LIST
34312: PUSH
34313: LD_INT 1
34315: PUSH
34316: LD_INT 0
34318: PUSH
34319: EMPTY
34320: LIST
34321: LIST
34322: PUSH
34323: LD_INT 1
34325: PUSH
34326: LD_INT 1
34328: PUSH
34329: EMPTY
34330: LIST
34331: LIST
34332: PUSH
34333: LD_INT 0
34335: PUSH
34336: LD_INT 1
34338: PUSH
34339: EMPTY
34340: LIST
34341: LIST
34342: PUSH
34343: LD_INT 1
34345: NEG
34346: PUSH
34347: LD_INT 0
34349: PUSH
34350: EMPTY
34351: LIST
34352: LIST
34353: PUSH
34354: LD_INT 1
34356: NEG
34357: PUSH
34358: LD_INT 1
34360: NEG
34361: PUSH
34362: EMPTY
34363: LIST
34364: LIST
34365: PUSH
34366: LD_INT 1
34368: PUSH
34369: LD_INT 1
34371: NEG
34372: PUSH
34373: EMPTY
34374: LIST
34375: LIST
34376: PUSH
34377: LD_INT 2
34379: PUSH
34380: LD_INT 0
34382: PUSH
34383: EMPTY
34384: LIST
34385: LIST
34386: PUSH
34387: LD_INT 2
34389: PUSH
34390: LD_INT 1
34392: PUSH
34393: EMPTY
34394: LIST
34395: LIST
34396: PUSH
34397: LD_INT 1
34399: NEG
34400: PUSH
34401: LD_INT 1
34403: PUSH
34404: EMPTY
34405: LIST
34406: LIST
34407: PUSH
34408: LD_INT 2
34410: NEG
34411: PUSH
34412: LD_INT 0
34414: PUSH
34415: EMPTY
34416: LIST
34417: LIST
34418: PUSH
34419: LD_INT 2
34421: NEG
34422: PUSH
34423: LD_INT 1
34425: NEG
34426: PUSH
34427: EMPTY
34428: LIST
34429: LIST
34430: PUSH
34431: LD_INT 2
34433: PUSH
34434: LD_INT 1
34436: NEG
34437: PUSH
34438: EMPTY
34439: LIST
34440: LIST
34441: PUSH
34442: LD_INT 3
34444: PUSH
34445: LD_INT 0
34447: PUSH
34448: EMPTY
34449: LIST
34450: LIST
34451: PUSH
34452: LD_INT 3
34454: PUSH
34455: LD_INT 1
34457: PUSH
34458: EMPTY
34459: LIST
34460: LIST
34461: PUSH
34462: EMPTY
34463: LIST
34464: LIST
34465: LIST
34466: LIST
34467: LIST
34468: LIST
34469: LIST
34470: LIST
34471: LIST
34472: LIST
34473: LIST
34474: LIST
34475: LIST
34476: LIST
34477: LIST
34478: LIST
34479: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
34480: LD_ADDR_VAR 0 16
34484: PUSH
34485: LD_INT 0
34487: PUSH
34488: LD_INT 0
34490: PUSH
34491: EMPTY
34492: LIST
34493: LIST
34494: PUSH
34495: LD_INT 0
34497: PUSH
34498: LD_INT 1
34500: NEG
34501: PUSH
34502: EMPTY
34503: LIST
34504: LIST
34505: PUSH
34506: LD_INT 1
34508: PUSH
34509: LD_INT 0
34511: PUSH
34512: EMPTY
34513: LIST
34514: LIST
34515: PUSH
34516: LD_INT 1
34518: PUSH
34519: LD_INT 1
34521: PUSH
34522: EMPTY
34523: LIST
34524: LIST
34525: PUSH
34526: LD_INT 0
34528: PUSH
34529: LD_INT 1
34531: PUSH
34532: EMPTY
34533: LIST
34534: LIST
34535: PUSH
34536: LD_INT 1
34538: NEG
34539: PUSH
34540: LD_INT 0
34542: PUSH
34543: EMPTY
34544: LIST
34545: LIST
34546: PUSH
34547: LD_INT 1
34549: NEG
34550: PUSH
34551: LD_INT 1
34553: NEG
34554: PUSH
34555: EMPTY
34556: LIST
34557: LIST
34558: PUSH
34559: LD_INT 1
34561: NEG
34562: PUSH
34563: LD_INT 2
34565: NEG
34566: PUSH
34567: EMPTY
34568: LIST
34569: LIST
34570: PUSH
34571: LD_INT 2
34573: PUSH
34574: LD_INT 1
34576: PUSH
34577: EMPTY
34578: LIST
34579: LIST
34580: PUSH
34581: LD_INT 2
34583: PUSH
34584: LD_INT 2
34586: PUSH
34587: EMPTY
34588: LIST
34589: LIST
34590: PUSH
34591: LD_INT 1
34593: PUSH
34594: LD_INT 2
34596: PUSH
34597: EMPTY
34598: LIST
34599: LIST
34600: PUSH
34601: LD_INT 2
34603: NEG
34604: PUSH
34605: LD_INT 1
34607: NEG
34608: PUSH
34609: EMPTY
34610: LIST
34611: LIST
34612: PUSH
34613: LD_INT 2
34615: NEG
34616: PUSH
34617: LD_INT 2
34619: NEG
34620: PUSH
34621: EMPTY
34622: LIST
34623: LIST
34624: PUSH
34625: LD_INT 3
34627: PUSH
34628: LD_INT 2
34630: PUSH
34631: EMPTY
34632: LIST
34633: LIST
34634: PUSH
34635: LD_INT 3
34637: PUSH
34638: LD_INT 3
34640: PUSH
34641: EMPTY
34642: LIST
34643: LIST
34644: PUSH
34645: LD_INT 2
34647: PUSH
34648: LD_INT 3
34650: PUSH
34651: EMPTY
34652: LIST
34653: LIST
34654: PUSH
34655: EMPTY
34656: LIST
34657: LIST
34658: LIST
34659: LIST
34660: LIST
34661: LIST
34662: LIST
34663: LIST
34664: LIST
34665: LIST
34666: LIST
34667: LIST
34668: LIST
34669: LIST
34670: LIST
34671: LIST
34672: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
34673: LD_ADDR_VAR 0 17
34677: PUSH
34678: LD_INT 0
34680: PUSH
34681: LD_INT 0
34683: PUSH
34684: EMPTY
34685: LIST
34686: LIST
34687: PUSH
34688: LD_INT 0
34690: PUSH
34691: LD_INT 1
34693: NEG
34694: PUSH
34695: EMPTY
34696: LIST
34697: LIST
34698: PUSH
34699: LD_INT 1
34701: PUSH
34702: LD_INT 0
34704: PUSH
34705: EMPTY
34706: LIST
34707: LIST
34708: PUSH
34709: LD_INT 1
34711: PUSH
34712: LD_INT 1
34714: PUSH
34715: EMPTY
34716: LIST
34717: LIST
34718: PUSH
34719: LD_INT 0
34721: PUSH
34722: LD_INT 1
34724: PUSH
34725: EMPTY
34726: LIST
34727: LIST
34728: PUSH
34729: LD_INT 1
34731: NEG
34732: PUSH
34733: LD_INT 0
34735: PUSH
34736: EMPTY
34737: LIST
34738: LIST
34739: PUSH
34740: LD_INT 1
34742: NEG
34743: PUSH
34744: LD_INT 1
34746: NEG
34747: PUSH
34748: EMPTY
34749: LIST
34750: LIST
34751: PUSH
34752: LD_INT 1
34754: NEG
34755: PUSH
34756: LD_INT 2
34758: NEG
34759: PUSH
34760: EMPTY
34761: LIST
34762: LIST
34763: PUSH
34764: LD_INT 0
34766: PUSH
34767: LD_INT 2
34769: NEG
34770: PUSH
34771: EMPTY
34772: LIST
34773: LIST
34774: PUSH
34775: LD_INT 1
34777: PUSH
34778: LD_INT 1
34780: NEG
34781: PUSH
34782: EMPTY
34783: LIST
34784: LIST
34785: PUSH
34786: LD_INT 2
34788: PUSH
34789: LD_INT 0
34791: PUSH
34792: EMPTY
34793: LIST
34794: LIST
34795: PUSH
34796: LD_INT 2
34798: PUSH
34799: LD_INT 1
34801: PUSH
34802: EMPTY
34803: LIST
34804: LIST
34805: PUSH
34806: LD_INT 2
34808: PUSH
34809: LD_INT 2
34811: PUSH
34812: EMPTY
34813: LIST
34814: LIST
34815: PUSH
34816: LD_INT 1
34818: PUSH
34819: LD_INT 2
34821: PUSH
34822: EMPTY
34823: LIST
34824: LIST
34825: PUSH
34826: LD_INT 0
34828: PUSH
34829: LD_INT 2
34831: PUSH
34832: EMPTY
34833: LIST
34834: LIST
34835: PUSH
34836: LD_INT 1
34838: NEG
34839: PUSH
34840: LD_INT 1
34842: PUSH
34843: EMPTY
34844: LIST
34845: LIST
34846: PUSH
34847: LD_INT 2
34849: NEG
34850: PUSH
34851: LD_INT 0
34853: PUSH
34854: EMPTY
34855: LIST
34856: LIST
34857: PUSH
34858: LD_INT 2
34860: NEG
34861: PUSH
34862: LD_INT 1
34864: NEG
34865: PUSH
34866: EMPTY
34867: LIST
34868: LIST
34869: PUSH
34870: LD_INT 2
34872: NEG
34873: PUSH
34874: LD_INT 2
34876: NEG
34877: PUSH
34878: EMPTY
34879: LIST
34880: LIST
34881: PUSH
34882: EMPTY
34883: LIST
34884: LIST
34885: LIST
34886: LIST
34887: LIST
34888: LIST
34889: LIST
34890: LIST
34891: LIST
34892: LIST
34893: LIST
34894: LIST
34895: LIST
34896: LIST
34897: LIST
34898: LIST
34899: LIST
34900: LIST
34901: LIST
34902: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
34903: LD_ADDR_VAR 0 18
34907: PUSH
34908: LD_INT 0
34910: PUSH
34911: LD_INT 0
34913: PUSH
34914: EMPTY
34915: LIST
34916: LIST
34917: PUSH
34918: LD_INT 0
34920: PUSH
34921: LD_INT 1
34923: NEG
34924: PUSH
34925: EMPTY
34926: LIST
34927: LIST
34928: PUSH
34929: LD_INT 1
34931: PUSH
34932: LD_INT 0
34934: PUSH
34935: EMPTY
34936: LIST
34937: LIST
34938: PUSH
34939: LD_INT 1
34941: PUSH
34942: LD_INT 1
34944: PUSH
34945: EMPTY
34946: LIST
34947: LIST
34948: PUSH
34949: LD_INT 0
34951: PUSH
34952: LD_INT 1
34954: PUSH
34955: EMPTY
34956: LIST
34957: LIST
34958: PUSH
34959: LD_INT 1
34961: NEG
34962: PUSH
34963: LD_INT 0
34965: PUSH
34966: EMPTY
34967: LIST
34968: LIST
34969: PUSH
34970: LD_INT 1
34972: NEG
34973: PUSH
34974: LD_INT 1
34976: NEG
34977: PUSH
34978: EMPTY
34979: LIST
34980: LIST
34981: PUSH
34982: LD_INT 1
34984: NEG
34985: PUSH
34986: LD_INT 2
34988: NEG
34989: PUSH
34990: EMPTY
34991: LIST
34992: LIST
34993: PUSH
34994: LD_INT 0
34996: PUSH
34997: LD_INT 2
34999: NEG
35000: PUSH
35001: EMPTY
35002: LIST
35003: LIST
35004: PUSH
35005: LD_INT 1
35007: PUSH
35008: LD_INT 1
35010: NEG
35011: PUSH
35012: EMPTY
35013: LIST
35014: LIST
35015: PUSH
35016: LD_INT 2
35018: PUSH
35019: LD_INT 0
35021: PUSH
35022: EMPTY
35023: LIST
35024: LIST
35025: PUSH
35026: LD_INT 2
35028: PUSH
35029: LD_INT 1
35031: PUSH
35032: EMPTY
35033: LIST
35034: LIST
35035: PUSH
35036: LD_INT 2
35038: PUSH
35039: LD_INT 2
35041: PUSH
35042: EMPTY
35043: LIST
35044: LIST
35045: PUSH
35046: LD_INT 1
35048: PUSH
35049: LD_INT 2
35051: PUSH
35052: EMPTY
35053: LIST
35054: LIST
35055: PUSH
35056: LD_INT 0
35058: PUSH
35059: LD_INT 2
35061: PUSH
35062: EMPTY
35063: LIST
35064: LIST
35065: PUSH
35066: LD_INT 1
35068: NEG
35069: PUSH
35070: LD_INT 1
35072: PUSH
35073: EMPTY
35074: LIST
35075: LIST
35076: PUSH
35077: LD_INT 2
35079: NEG
35080: PUSH
35081: LD_INT 0
35083: PUSH
35084: EMPTY
35085: LIST
35086: LIST
35087: PUSH
35088: LD_INT 2
35090: NEG
35091: PUSH
35092: LD_INT 1
35094: NEG
35095: PUSH
35096: EMPTY
35097: LIST
35098: LIST
35099: PUSH
35100: LD_INT 2
35102: NEG
35103: PUSH
35104: LD_INT 2
35106: NEG
35107: PUSH
35108: EMPTY
35109: LIST
35110: LIST
35111: PUSH
35112: EMPTY
35113: LIST
35114: LIST
35115: LIST
35116: LIST
35117: LIST
35118: LIST
35119: LIST
35120: LIST
35121: LIST
35122: LIST
35123: LIST
35124: LIST
35125: LIST
35126: LIST
35127: LIST
35128: LIST
35129: LIST
35130: LIST
35131: LIST
35132: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
35133: LD_ADDR_VAR 0 19
35137: PUSH
35138: LD_INT 0
35140: PUSH
35141: LD_INT 0
35143: PUSH
35144: EMPTY
35145: LIST
35146: LIST
35147: PUSH
35148: LD_INT 0
35150: PUSH
35151: LD_INT 1
35153: NEG
35154: PUSH
35155: EMPTY
35156: LIST
35157: LIST
35158: PUSH
35159: LD_INT 1
35161: PUSH
35162: LD_INT 0
35164: PUSH
35165: EMPTY
35166: LIST
35167: LIST
35168: PUSH
35169: LD_INT 1
35171: PUSH
35172: LD_INT 1
35174: PUSH
35175: EMPTY
35176: LIST
35177: LIST
35178: PUSH
35179: LD_INT 0
35181: PUSH
35182: LD_INT 1
35184: PUSH
35185: EMPTY
35186: LIST
35187: LIST
35188: PUSH
35189: LD_INT 1
35191: NEG
35192: PUSH
35193: LD_INT 0
35195: PUSH
35196: EMPTY
35197: LIST
35198: LIST
35199: PUSH
35200: LD_INT 1
35202: NEG
35203: PUSH
35204: LD_INT 1
35206: NEG
35207: PUSH
35208: EMPTY
35209: LIST
35210: LIST
35211: PUSH
35212: LD_INT 1
35214: NEG
35215: PUSH
35216: LD_INT 2
35218: NEG
35219: PUSH
35220: EMPTY
35221: LIST
35222: LIST
35223: PUSH
35224: LD_INT 0
35226: PUSH
35227: LD_INT 2
35229: NEG
35230: PUSH
35231: EMPTY
35232: LIST
35233: LIST
35234: PUSH
35235: LD_INT 1
35237: PUSH
35238: LD_INT 1
35240: NEG
35241: PUSH
35242: EMPTY
35243: LIST
35244: LIST
35245: PUSH
35246: LD_INT 2
35248: PUSH
35249: LD_INT 0
35251: PUSH
35252: EMPTY
35253: LIST
35254: LIST
35255: PUSH
35256: LD_INT 2
35258: PUSH
35259: LD_INT 1
35261: PUSH
35262: EMPTY
35263: LIST
35264: LIST
35265: PUSH
35266: LD_INT 2
35268: PUSH
35269: LD_INT 2
35271: PUSH
35272: EMPTY
35273: LIST
35274: LIST
35275: PUSH
35276: LD_INT 1
35278: PUSH
35279: LD_INT 2
35281: PUSH
35282: EMPTY
35283: LIST
35284: LIST
35285: PUSH
35286: LD_INT 0
35288: PUSH
35289: LD_INT 2
35291: PUSH
35292: EMPTY
35293: LIST
35294: LIST
35295: PUSH
35296: LD_INT 1
35298: NEG
35299: PUSH
35300: LD_INT 1
35302: PUSH
35303: EMPTY
35304: LIST
35305: LIST
35306: PUSH
35307: LD_INT 2
35309: NEG
35310: PUSH
35311: LD_INT 0
35313: PUSH
35314: EMPTY
35315: LIST
35316: LIST
35317: PUSH
35318: LD_INT 2
35320: NEG
35321: PUSH
35322: LD_INT 1
35324: NEG
35325: PUSH
35326: EMPTY
35327: LIST
35328: LIST
35329: PUSH
35330: LD_INT 2
35332: NEG
35333: PUSH
35334: LD_INT 2
35336: NEG
35337: PUSH
35338: EMPTY
35339: LIST
35340: LIST
35341: PUSH
35342: EMPTY
35343: LIST
35344: LIST
35345: LIST
35346: LIST
35347: LIST
35348: LIST
35349: LIST
35350: LIST
35351: LIST
35352: LIST
35353: LIST
35354: LIST
35355: LIST
35356: LIST
35357: LIST
35358: LIST
35359: LIST
35360: LIST
35361: LIST
35362: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
35363: LD_ADDR_VAR 0 20
35367: PUSH
35368: LD_INT 0
35370: PUSH
35371: LD_INT 0
35373: PUSH
35374: EMPTY
35375: LIST
35376: LIST
35377: PUSH
35378: LD_INT 0
35380: PUSH
35381: LD_INT 1
35383: NEG
35384: PUSH
35385: EMPTY
35386: LIST
35387: LIST
35388: PUSH
35389: LD_INT 1
35391: PUSH
35392: LD_INT 0
35394: PUSH
35395: EMPTY
35396: LIST
35397: LIST
35398: PUSH
35399: LD_INT 1
35401: PUSH
35402: LD_INT 1
35404: PUSH
35405: EMPTY
35406: LIST
35407: LIST
35408: PUSH
35409: LD_INT 0
35411: PUSH
35412: LD_INT 1
35414: PUSH
35415: EMPTY
35416: LIST
35417: LIST
35418: PUSH
35419: LD_INT 1
35421: NEG
35422: PUSH
35423: LD_INT 0
35425: PUSH
35426: EMPTY
35427: LIST
35428: LIST
35429: PUSH
35430: LD_INT 1
35432: NEG
35433: PUSH
35434: LD_INT 1
35436: NEG
35437: PUSH
35438: EMPTY
35439: LIST
35440: LIST
35441: PUSH
35442: LD_INT 1
35444: NEG
35445: PUSH
35446: LD_INT 2
35448: NEG
35449: PUSH
35450: EMPTY
35451: LIST
35452: LIST
35453: PUSH
35454: LD_INT 0
35456: PUSH
35457: LD_INT 2
35459: NEG
35460: PUSH
35461: EMPTY
35462: LIST
35463: LIST
35464: PUSH
35465: LD_INT 1
35467: PUSH
35468: LD_INT 1
35470: NEG
35471: PUSH
35472: EMPTY
35473: LIST
35474: LIST
35475: PUSH
35476: LD_INT 2
35478: PUSH
35479: LD_INT 0
35481: PUSH
35482: EMPTY
35483: LIST
35484: LIST
35485: PUSH
35486: LD_INT 2
35488: PUSH
35489: LD_INT 1
35491: PUSH
35492: EMPTY
35493: LIST
35494: LIST
35495: PUSH
35496: LD_INT 2
35498: PUSH
35499: LD_INT 2
35501: PUSH
35502: EMPTY
35503: LIST
35504: LIST
35505: PUSH
35506: LD_INT 1
35508: PUSH
35509: LD_INT 2
35511: PUSH
35512: EMPTY
35513: LIST
35514: LIST
35515: PUSH
35516: LD_INT 0
35518: PUSH
35519: LD_INT 2
35521: PUSH
35522: EMPTY
35523: LIST
35524: LIST
35525: PUSH
35526: LD_INT 1
35528: NEG
35529: PUSH
35530: LD_INT 1
35532: PUSH
35533: EMPTY
35534: LIST
35535: LIST
35536: PUSH
35537: LD_INT 2
35539: NEG
35540: PUSH
35541: LD_INT 0
35543: PUSH
35544: EMPTY
35545: LIST
35546: LIST
35547: PUSH
35548: LD_INT 2
35550: NEG
35551: PUSH
35552: LD_INT 1
35554: NEG
35555: PUSH
35556: EMPTY
35557: LIST
35558: LIST
35559: PUSH
35560: LD_INT 2
35562: NEG
35563: PUSH
35564: LD_INT 2
35566: NEG
35567: PUSH
35568: EMPTY
35569: LIST
35570: LIST
35571: PUSH
35572: EMPTY
35573: LIST
35574: LIST
35575: LIST
35576: LIST
35577: LIST
35578: LIST
35579: LIST
35580: LIST
35581: LIST
35582: LIST
35583: LIST
35584: LIST
35585: LIST
35586: LIST
35587: LIST
35588: LIST
35589: LIST
35590: LIST
35591: LIST
35592: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
35593: LD_ADDR_VAR 0 21
35597: PUSH
35598: LD_INT 0
35600: PUSH
35601: LD_INT 0
35603: PUSH
35604: EMPTY
35605: LIST
35606: LIST
35607: PUSH
35608: LD_INT 0
35610: PUSH
35611: LD_INT 1
35613: NEG
35614: PUSH
35615: EMPTY
35616: LIST
35617: LIST
35618: PUSH
35619: LD_INT 1
35621: PUSH
35622: LD_INT 0
35624: PUSH
35625: EMPTY
35626: LIST
35627: LIST
35628: PUSH
35629: LD_INT 1
35631: PUSH
35632: LD_INT 1
35634: PUSH
35635: EMPTY
35636: LIST
35637: LIST
35638: PUSH
35639: LD_INT 0
35641: PUSH
35642: LD_INT 1
35644: PUSH
35645: EMPTY
35646: LIST
35647: LIST
35648: PUSH
35649: LD_INT 1
35651: NEG
35652: PUSH
35653: LD_INT 0
35655: PUSH
35656: EMPTY
35657: LIST
35658: LIST
35659: PUSH
35660: LD_INT 1
35662: NEG
35663: PUSH
35664: LD_INT 1
35666: NEG
35667: PUSH
35668: EMPTY
35669: LIST
35670: LIST
35671: PUSH
35672: LD_INT 1
35674: NEG
35675: PUSH
35676: LD_INT 2
35678: NEG
35679: PUSH
35680: EMPTY
35681: LIST
35682: LIST
35683: PUSH
35684: LD_INT 0
35686: PUSH
35687: LD_INT 2
35689: NEG
35690: PUSH
35691: EMPTY
35692: LIST
35693: LIST
35694: PUSH
35695: LD_INT 1
35697: PUSH
35698: LD_INT 1
35700: NEG
35701: PUSH
35702: EMPTY
35703: LIST
35704: LIST
35705: PUSH
35706: LD_INT 2
35708: PUSH
35709: LD_INT 0
35711: PUSH
35712: EMPTY
35713: LIST
35714: LIST
35715: PUSH
35716: LD_INT 2
35718: PUSH
35719: LD_INT 1
35721: PUSH
35722: EMPTY
35723: LIST
35724: LIST
35725: PUSH
35726: LD_INT 2
35728: PUSH
35729: LD_INT 2
35731: PUSH
35732: EMPTY
35733: LIST
35734: LIST
35735: PUSH
35736: LD_INT 1
35738: PUSH
35739: LD_INT 2
35741: PUSH
35742: EMPTY
35743: LIST
35744: LIST
35745: PUSH
35746: LD_INT 0
35748: PUSH
35749: LD_INT 2
35751: PUSH
35752: EMPTY
35753: LIST
35754: LIST
35755: PUSH
35756: LD_INT 1
35758: NEG
35759: PUSH
35760: LD_INT 1
35762: PUSH
35763: EMPTY
35764: LIST
35765: LIST
35766: PUSH
35767: LD_INT 2
35769: NEG
35770: PUSH
35771: LD_INT 0
35773: PUSH
35774: EMPTY
35775: LIST
35776: LIST
35777: PUSH
35778: LD_INT 2
35780: NEG
35781: PUSH
35782: LD_INT 1
35784: NEG
35785: PUSH
35786: EMPTY
35787: LIST
35788: LIST
35789: PUSH
35790: LD_INT 2
35792: NEG
35793: PUSH
35794: LD_INT 2
35796: NEG
35797: PUSH
35798: EMPTY
35799: LIST
35800: LIST
35801: PUSH
35802: EMPTY
35803: LIST
35804: LIST
35805: LIST
35806: LIST
35807: LIST
35808: LIST
35809: LIST
35810: LIST
35811: LIST
35812: LIST
35813: LIST
35814: LIST
35815: LIST
35816: LIST
35817: LIST
35818: LIST
35819: LIST
35820: LIST
35821: LIST
35822: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
35823: LD_ADDR_VAR 0 22
35827: PUSH
35828: LD_INT 0
35830: PUSH
35831: LD_INT 0
35833: PUSH
35834: EMPTY
35835: LIST
35836: LIST
35837: PUSH
35838: LD_INT 0
35840: PUSH
35841: LD_INT 1
35843: NEG
35844: PUSH
35845: EMPTY
35846: LIST
35847: LIST
35848: PUSH
35849: LD_INT 1
35851: PUSH
35852: LD_INT 0
35854: PUSH
35855: EMPTY
35856: LIST
35857: LIST
35858: PUSH
35859: LD_INT 1
35861: PUSH
35862: LD_INT 1
35864: PUSH
35865: EMPTY
35866: LIST
35867: LIST
35868: PUSH
35869: LD_INT 0
35871: PUSH
35872: LD_INT 1
35874: PUSH
35875: EMPTY
35876: LIST
35877: LIST
35878: PUSH
35879: LD_INT 1
35881: NEG
35882: PUSH
35883: LD_INT 0
35885: PUSH
35886: EMPTY
35887: LIST
35888: LIST
35889: PUSH
35890: LD_INT 1
35892: NEG
35893: PUSH
35894: LD_INT 1
35896: NEG
35897: PUSH
35898: EMPTY
35899: LIST
35900: LIST
35901: PUSH
35902: LD_INT 1
35904: NEG
35905: PUSH
35906: LD_INT 2
35908: NEG
35909: PUSH
35910: EMPTY
35911: LIST
35912: LIST
35913: PUSH
35914: LD_INT 0
35916: PUSH
35917: LD_INT 2
35919: NEG
35920: PUSH
35921: EMPTY
35922: LIST
35923: LIST
35924: PUSH
35925: LD_INT 1
35927: PUSH
35928: LD_INT 1
35930: NEG
35931: PUSH
35932: EMPTY
35933: LIST
35934: LIST
35935: PUSH
35936: LD_INT 2
35938: PUSH
35939: LD_INT 0
35941: PUSH
35942: EMPTY
35943: LIST
35944: LIST
35945: PUSH
35946: LD_INT 2
35948: PUSH
35949: LD_INT 1
35951: PUSH
35952: EMPTY
35953: LIST
35954: LIST
35955: PUSH
35956: LD_INT 2
35958: PUSH
35959: LD_INT 2
35961: PUSH
35962: EMPTY
35963: LIST
35964: LIST
35965: PUSH
35966: LD_INT 1
35968: PUSH
35969: LD_INT 2
35971: PUSH
35972: EMPTY
35973: LIST
35974: LIST
35975: PUSH
35976: LD_INT 0
35978: PUSH
35979: LD_INT 2
35981: PUSH
35982: EMPTY
35983: LIST
35984: LIST
35985: PUSH
35986: LD_INT 1
35988: NEG
35989: PUSH
35990: LD_INT 1
35992: PUSH
35993: EMPTY
35994: LIST
35995: LIST
35996: PUSH
35997: LD_INT 2
35999: NEG
36000: PUSH
36001: LD_INT 0
36003: PUSH
36004: EMPTY
36005: LIST
36006: LIST
36007: PUSH
36008: LD_INT 2
36010: NEG
36011: PUSH
36012: LD_INT 1
36014: NEG
36015: PUSH
36016: EMPTY
36017: LIST
36018: LIST
36019: PUSH
36020: LD_INT 2
36022: NEG
36023: PUSH
36024: LD_INT 2
36026: NEG
36027: PUSH
36028: EMPTY
36029: LIST
36030: LIST
36031: PUSH
36032: EMPTY
36033: LIST
36034: LIST
36035: LIST
36036: LIST
36037: LIST
36038: LIST
36039: LIST
36040: LIST
36041: LIST
36042: LIST
36043: LIST
36044: LIST
36045: LIST
36046: LIST
36047: LIST
36048: LIST
36049: LIST
36050: LIST
36051: LIST
36052: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
36053: LD_ADDR_VAR 0 23
36057: PUSH
36058: LD_INT 0
36060: PUSH
36061: LD_INT 0
36063: PUSH
36064: EMPTY
36065: LIST
36066: LIST
36067: PUSH
36068: LD_INT 0
36070: PUSH
36071: LD_INT 1
36073: NEG
36074: PUSH
36075: EMPTY
36076: LIST
36077: LIST
36078: PUSH
36079: LD_INT 1
36081: PUSH
36082: LD_INT 0
36084: PUSH
36085: EMPTY
36086: LIST
36087: LIST
36088: PUSH
36089: LD_INT 1
36091: PUSH
36092: LD_INT 1
36094: PUSH
36095: EMPTY
36096: LIST
36097: LIST
36098: PUSH
36099: LD_INT 0
36101: PUSH
36102: LD_INT 1
36104: PUSH
36105: EMPTY
36106: LIST
36107: LIST
36108: PUSH
36109: LD_INT 1
36111: NEG
36112: PUSH
36113: LD_INT 0
36115: PUSH
36116: EMPTY
36117: LIST
36118: LIST
36119: PUSH
36120: LD_INT 1
36122: NEG
36123: PUSH
36124: LD_INT 1
36126: NEG
36127: PUSH
36128: EMPTY
36129: LIST
36130: LIST
36131: PUSH
36132: LD_INT 1
36134: NEG
36135: PUSH
36136: LD_INT 2
36138: NEG
36139: PUSH
36140: EMPTY
36141: LIST
36142: LIST
36143: PUSH
36144: LD_INT 0
36146: PUSH
36147: LD_INT 2
36149: NEG
36150: PUSH
36151: EMPTY
36152: LIST
36153: LIST
36154: PUSH
36155: LD_INT 1
36157: PUSH
36158: LD_INT 1
36160: NEG
36161: PUSH
36162: EMPTY
36163: LIST
36164: LIST
36165: PUSH
36166: LD_INT 2
36168: PUSH
36169: LD_INT 0
36171: PUSH
36172: EMPTY
36173: LIST
36174: LIST
36175: PUSH
36176: LD_INT 2
36178: PUSH
36179: LD_INT 1
36181: PUSH
36182: EMPTY
36183: LIST
36184: LIST
36185: PUSH
36186: LD_INT 2
36188: PUSH
36189: LD_INT 2
36191: PUSH
36192: EMPTY
36193: LIST
36194: LIST
36195: PUSH
36196: LD_INT 1
36198: PUSH
36199: LD_INT 2
36201: PUSH
36202: EMPTY
36203: LIST
36204: LIST
36205: PUSH
36206: LD_INT 0
36208: PUSH
36209: LD_INT 2
36211: PUSH
36212: EMPTY
36213: LIST
36214: LIST
36215: PUSH
36216: LD_INT 1
36218: NEG
36219: PUSH
36220: LD_INT 1
36222: PUSH
36223: EMPTY
36224: LIST
36225: LIST
36226: PUSH
36227: LD_INT 2
36229: NEG
36230: PUSH
36231: LD_INT 0
36233: PUSH
36234: EMPTY
36235: LIST
36236: LIST
36237: PUSH
36238: LD_INT 2
36240: NEG
36241: PUSH
36242: LD_INT 1
36244: NEG
36245: PUSH
36246: EMPTY
36247: LIST
36248: LIST
36249: PUSH
36250: LD_INT 2
36252: NEG
36253: PUSH
36254: LD_INT 2
36256: NEG
36257: PUSH
36258: EMPTY
36259: LIST
36260: LIST
36261: PUSH
36262: LD_INT 2
36264: NEG
36265: PUSH
36266: LD_INT 3
36268: NEG
36269: PUSH
36270: EMPTY
36271: LIST
36272: LIST
36273: PUSH
36274: LD_INT 1
36276: NEG
36277: PUSH
36278: LD_INT 3
36280: NEG
36281: PUSH
36282: EMPTY
36283: LIST
36284: LIST
36285: PUSH
36286: LD_INT 1
36288: PUSH
36289: LD_INT 2
36291: NEG
36292: PUSH
36293: EMPTY
36294: LIST
36295: LIST
36296: PUSH
36297: LD_INT 2
36299: PUSH
36300: LD_INT 1
36302: NEG
36303: PUSH
36304: EMPTY
36305: LIST
36306: LIST
36307: PUSH
36308: EMPTY
36309: LIST
36310: LIST
36311: LIST
36312: LIST
36313: LIST
36314: LIST
36315: LIST
36316: LIST
36317: LIST
36318: LIST
36319: LIST
36320: LIST
36321: LIST
36322: LIST
36323: LIST
36324: LIST
36325: LIST
36326: LIST
36327: LIST
36328: LIST
36329: LIST
36330: LIST
36331: LIST
36332: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
36333: LD_ADDR_VAR 0 24
36337: PUSH
36338: LD_INT 0
36340: PUSH
36341: LD_INT 0
36343: PUSH
36344: EMPTY
36345: LIST
36346: LIST
36347: PUSH
36348: LD_INT 0
36350: PUSH
36351: LD_INT 1
36353: NEG
36354: PUSH
36355: EMPTY
36356: LIST
36357: LIST
36358: PUSH
36359: LD_INT 1
36361: PUSH
36362: LD_INT 0
36364: PUSH
36365: EMPTY
36366: LIST
36367: LIST
36368: PUSH
36369: LD_INT 1
36371: PUSH
36372: LD_INT 1
36374: PUSH
36375: EMPTY
36376: LIST
36377: LIST
36378: PUSH
36379: LD_INT 0
36381: PUSH
36382: LD_INT 1
36384: PUSH
36385: EMPTY
36386: LIST
36387: LIST
36388: PUSH
36389: LD_INT 1
36391: NEG
36392: PUSH
36393: LD_INT 0
36395: PUSH
36396: EMPTY
36397: LIST
36398: LIST
36399: PUSH
36400: LD_INT 1
36402: NEG
36403: PUSH
36404: LD_INT 1
36406: NEG
36407: PUSH
36408: EMPTY
36409: LIST
36410: LIST
36411: PUSH
36412: LD_INT 1
36414: NEG
36415: PUSH
36416: LD_INT 2
36418: NEG
36419: PUSH
36420: EMPTY
36421: LIST
36422: LIST
36423: PUSH
36424: LD_INT 0
36426: PUSH
36427: LD_INT 2
36429: NEG
36430: PUSH
36431: EMPTY
36432: LIST
36433: LIST
36434: PUSH
36435: LD_INT 1
36437: PUSH
36438: LD_INT 1
36440: NEG
36441: PUSH
36442: EMPTY
36443: LIST
36444: LIST
36445: PUSH
36446: LD_INT 2
36448: PUSH
36449: LD_INT 0
36451: PUSH
36452: EMPTY
36453: LIST
36454: LIST
36455: PUSH
36456: LD_INT 2
36458: PUSH
36459: LD_INT 1
36461: PUSH
36462: EMPTY
36463: LIST
36464: LIST
36465: PUSH
36466: LD_INT 2
36468: PUSH
36469: LD_INT 2
36471: PUSH
36472: EMPTY
36473: LIST
36474: LIST
36475: PUSH
36476: LD_INT 1
36478: PUSH
36479: LD_INT 2
36481: PUSH
36482: EMPTY
36483: LIST
36484: LIST
36485: PUSH
36486: LD_INT 0
36488: PUSH
36489: LD_INT 2
36491: PUSH
36492: EMPTY
36493: LIST
36494: LIST
36495: PUSH
36496: LD_INT 1
36498: NEG
36499: PUSH
36500: LD_INT 1
36502: PUSH
36503: EMPTY
36504: LIST
36505: LIST
36506: PUSH
36507: LD_INT 2
36509: NEG
36510: PUSH
36511: LD_INT 0
36513: PUSH
36514: EMPTY
36515: LIST
36516: LIST
36517: PUSH
36518: LD_INT 2
36520: NEG
36521: PUSH
36522: LD_INT 1
36524: NEG
36525: PUSH
36526: EMPTY
36527: LIST
36528: LIST
36529: PUSH
36530: LD_INT 2
36532: NEG
36533: PUSH
36534: LD_INT 2
36536: NEG
36537: PUSH
36538: EMPTY
36539: LIST
36540: LIST
36541: PUSH
36542: LD_INT 1
36544: PUSH
36545: LD_INT 2
36547: NEG
36548: PUSH
36549: EMPTY
36550: LIST
36551: LIST
36552: PUSH
36553: LD_INT 2
36555: PUSH
36556: LD_INT 1
36558: NEG
36559: PUSH
36560: EMPTY
36561: LIST
36562: LIST
36563: PUSH
36564: LD_INT 3
36566: PUSH
36567: LD_INT 1
36569: PUSH
36570: EMPTY
36571: LIST
36572: LIST
36573: PUSH
36574: LD_INT 3
36576: PUSH
36577: LD_INT 2
36579: PUSH
36580: EMPTY
36581: LIST
36582: LIST
36583: PUSH
36584: EMPTY
36585: LIST
36586: LIST
36587: LIST
36588: LIST
36589: LIST
36590: LIST
36591: LIST
36592: LIST
36593: LIST
36594: LIST
36595: LIST
36596: LIST
36597: LIST
36598: LIST
36599: LIST
36600: LIST
36601: LIST
36602: LIST
36603: LIST
36604: LIST
36605: LIST
36606: LIST
36607: LIST
36608: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
36609: LD_ADDR_VAR 0 25
36613: PUSH
36614: LD_INT 0
36616: PUSH
36617: LD_INT 0
36619: PUSH
36620: EMPTY
36621: LIST
36622: LIST
36623: PUSH
36624: LD_INT 0
36626: PUSH
36627: LD_INT 1
36629: NEG
36630: PUSH
36631: EMPTY
36632: LIST
36633: LIST
36634: PUSH
36635: LD_INT 1
36637: PUSH
36638: LD_INT 0
36640: PUSH
36641: EMPTY
36642: LIST
36643: LIST
36644: PUSH
36645: LD_INT 1
36647: PUSH
36648: LD_INT 1
36650: PUSH
36651: EMPTY
36652: LIST
36653: LIST
36654: PUSH
36655: LD_INT 0
36657: PUSH
36658: LD_INT 1
36660: PUSH
36661: EMPTY
36662: LIST
36663: LIST
36664: PUSH
36665: LD_INT 1
36667: NEG
36668: PUSH
36669: LD_INT 0
36671: PUSH
36672: EMPTY
36673: LIST
36674: LIST
36675: PUSH
36676: LD_INT 1
36678: NEG
36679: PUSH
36680: LD_INT 1
36682: NEG
36683: PUSH
36684: EMPTY
36685: LIST
36686: LIST
36687: PUSH
36688: LD_INT 1
36690: NEG
36691: PUSH
36692: LD_INT 2
36694: NEG
36695: PUSH
36696: EMPTY
36697: LIST
36698: LIST
36699: PUSH
36700: LD_INT 0
36702: PUSH
36703: LD_INT 2
36705: NEG
36706: PUSH
36707: EMPTY
36708: LIST
36709: LIST
36710: PUSH
36711: LD_INT 1
36713: PUSH
36714: LD_INT 1
36716: NEG
36717: PUSH
36718: EMPTY
36719: LIST
36720: LIST
36721: PUSH
36722: LD_INT 2
36724: PUSH
36725: LD_INT 0
36727: PUSH
36728: EMPTY
36729: LIST
36730: LIST
36731: PUSH
36732: LD_INT 2
36734: PUSH
36735: LD_INT 1
36737: PUSH
36738: EMPTY
36739: LIST
36740: LIST
36741: PUSH
36742: LD_INT 2
36744: PUSH
36745: LD_INT 2
36747: PUSH
36748: EMPTY
36749: LIST
36750: LIST
36751: PUSH
36752: LD_INT 1
36754: PUSH
36755: LD_INT 2
36757: PUSH
36758: EMPTY
36759: LIST
36760: LIST
36761: PUSH
36762: LD_INT 0
36764: PUSH
36765: LD_INT 2
36767: PUSH
36768: EMPTY
36769: LIST
36770: LIST
36771: PUSH
36772: LD_INT 1
36774: NEG
36775: PUSH
36776: LD_INT 1
36778: PUSH
36779: EMPTY
36780: LIST
36781: LIST
36782: PUSH
36783: LD_INT 2
36785: NEG
36786: PUSH
36787: LD_INT 0
36789: PUSH
36790: EMPTY
36791: LIST
36792: LIST
36793: PUSH
36794: LD_INT 2
36796: NEG
36797: PUSH
36798: LD_INT 1
36800: NEG
36801: PUSH
36802: EMPTY
36803: LIST
36804: LIST
36805: PUSH
36806: LD_INT 2
36808: NEG
36809: PUSH
36810: LD_INT 2
36812: NEG
36813: PUSH
36814: EMPTY
36815: LIST
36816: LIST
36817: PUSH
36818: LD_INT 3
36820: PUSH
36821: LD_INT 1
36823: PUSH
36824: EMPTY
36825: LIST
36826: LIST
36827: PUSH
36828: LD_INT 3
36830: PUSH
36831: LD_INT 2
36833: PUSH
36834: EMPTY
36835: LIST
36836: LIST
36837: PUSH
36838: LD_INT 2
36840: PUSH
36841: LD_INT 3
36843: PUSH
36844: EMPTY
36845: LIST
36846: LIST
36847: PUSH
36848: LD_INT 1
36850: PUSH
36851: LD_INT 3
36853: PUSH
36854: EMPTY
36855: LIST
36856: LIST
36857: PUSH
36858: EMPTY
36859: LIST
36860: LIST
36861: LIST
36862: LIST
36863: LIST
36864: LIST
36865: LIST
36866: LIST
36867: LIST
36868: LIST
36869: LIST
36870: LIST
36871: LIST
36872: LIST
36873: LIST
36874: LIST
36875: LIST
36876: LIST
36877: LIST
36878: LIST
36879: LIST
36880: LIST
36881: LIST
36882: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
36883: LD_ADDR_VAR 0 26
36887: PUSH
36888: LD_INT 0
36890: PUSH
36891: LD_INT 0
36893: PUSH
36894: EMPTY
36895: LIST
36896: LIST
36897: PUSH
36898: LD_INT 0
36900: PUSH
36901: LD_INT 1
36903: NEG
36904: PUSH
36905: EMPTY
36906: LIST
36907: LIST
36908: PUSH
36909: LD_INT 1
36911: PUSH
36912: LD_INT 0
36914: PUSH
36915: EMPTY
36916: LIST
36917: LIST
36918: PUSH
36919: LD_INT 1
36921: PUSH
36922: LD_INT 1
36924: PUSH
36925: EMPTY
36926: LIST
36927: LIST
36928: PUSH
36929: LD_INT 0
36931: PUSH
36932: LD_INT 1
36934: PUSH
36935: EMPTY
36936: LIST
36937: LIST
36938: PUSH
36939: LD_INT 1
36941: NEG
36942: PUSH
36943: LD_INT 0
36945: PUSH
36946: EMPTY
36947: LIST
36948: LIST
36949: PUSH
36950: LD_INT 1
36952: NEG
36953: PUSH
36954: LD_INT 1
36956: NEG
36957: PUSH
36958: EMPTY
36959: LIST
36960: LIST
36961: PUSH
36962: LD_INT 1
36964: NEG
36965: PUSH
36966: LD_INT 2
36968: NEG
36969: PUSH
36970: EMPTY
36971: LIST
36972: LIST
36973: PUSH
36974: LD_INT 0
36976: PUSH
36977: LD_INT 2
36979: NEG
36980: PUSH
36981: EMPTY
36982: LIST
36983: LIST
36984: PUSH
36985: LD_INT 1
36987: PUSH
36988: LD_INT 1
36990: NEG
36991: PUSH
36992: EMPTY
36993: LIST
36994: LIST
36995: PUSH
36996: LD_INT 2
36998: PUSH
36999: LD_INT 0
37001: PUSH
37002: EMPTY
37003: LIST
37004: LIST
37005: PUSH
37006: LD_INT 2
37008: PUSH
37009: LD_INT 1
37011: PUSH
37012: EMPTY
37013: LIST
37014: LIST
37015: PUSH
37016: LD_INT 2
37018: PUSH
37019: LD_INT 2
37021: PUSH
37022: EMPTY
37023: LIST
37024: LIST
37025: PUSH
37026: LD_INT 1
37028: PUSH
37029: LD_INT 2
37031: PUSH
37032: EMPTY
37033: LIST
37034: LIST
37035: PUSH
37036: LD_INT 0
37038: PUSH
37039: LD_INT 2
37041: PUSH
37042: EMPTY
37043: LIST
37044: LIST
37045: PUSH
37046: LD_INT 1
37048: NEG
37049: PUSH
37050: LD_INT 1
37052: PUSH
37053: EMPTY
37054: LIST
37055: LIST
37056: PUSH
37057: LD_INT 2
37059: NEG
37060: PUSH
37061: LD_INT 0
37063: PUSH
37064: EMPTY
37065: LIST
37066: LIST
37067: PUSH
37068: LD_INT 2
37070: NEG
37071: PUSH
37072: LD_INT 1
37074: NEG
37075: PUSH
37076: EMPTY
37077: LIST
37078: LIST
37079: PUSH
37080: LD_INT 2
37082: NEG
37083: PUSH
37084: LD_INT 2
37086: NEG
37087: PUSH
37088: EMPTY
37089: LIST
37090: LIST
37091: PUSH
37092: LD_INT 2
37094: PUSH
37095: LD_INT 3
37097: PUSH
37098: EMPTY
37099: LIST
37100: LIST
37101: PUSH
37102: LD_INT 1
37104: PUSH
37105: LD_INT 3
37107: PUSH
37108: EMPTY
37109: LIST
37110: LIST
37111: PUSH
37112: LD_INT 1
37114: NEG
37115: PUSH
37116: LD_INT 2
37118: PUSH
37119: EMPTY
37120: LIST
37121: LIST
37122: PUSH
37123: LD_INT 2
37125: NEG
37126: PUSH
37127: LD_INT 1
37129: PUSH
37130: EMPTY
37131: LIST
37132: LIST
37133: PUSH
37134: EMPTY
37135: LIST
37136: LIST
37137: LIST
37138: LIST
37139: LIST
37140: LIST
37141: LIST
37142: LIST
37143: LIST
37144: LIST
37145: LIST
37146: LIST
37147: LIST
37148: LIST
37149: LIST
37150: LIST
37151: LIST
37152: LIST
37153: LIST
37154: LIST
37155: LIST
37156: LIST
37157: LIST
37158: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
37159: LD_ADDR_VAR 0 27
37163: PUSH
37164: LD_INT 0
37166: PUSH
37167: LD_INT 0
37169: PUSH
37170: EMPTY
37171: LIST
37172: LIST
37173: PUSH
37174: LD_INT 0
37176: PUSH
37177: LD_INT 1
37179: NEG
37180: PUSH
37181: EMPTY
37182: LIST
37183: LIST
37184: PUSH
37185: LD_INT 1
37187: PUSH
37188: LD_INT 0
37190: PUSH
37191: EMPTY
37192: LIST
37193: LIST
37194: PUSH
37195: LD_INT 1
37197: PUSH
37198: LD_INT 1
37200: PUSH
37201: EMPTY
37202: LIST
37203: LIST
37204: PUSH
37205: LD_INT 0
37207: PUSH
37208: LD_INT 1
37210: PUSH
37211: EMPTY
37212: LIST
37213: LIST
37214: PUSH
37215: LD_INT 1
37217: NEG
37218: PUSH
37219: LD_INT 0
37221: PUSH
37222: EMPTY
37223: LIST
37224: LIST
37225: PUSH
37226: LD_INT 1
37228: NEG
37229: PUSH
37230: LD_INT 1
37232: NEG
37233: PUSH
37234: EMPTY
37235: LIST
37236: LIST
37237: PUSH
37238: LD_INT 1
37240: NEG
37241: PUSH
37242: LD_INT 2
37244: NEG
37245: PUSH
37246: EMPTY
37247: LIST
37248: LIST
37249: PUSH
37250: LD_INT 0
37252: PUSH
37253: LD_INT 2
37255: NEG
37256: PUSH
37257: EMPTY
37258: LIST
37259: LIST
37260: PUSH
37261: LD_INT 1
37263: PUSH
37264: LD_INT 1
37266: NEG
37267: PUSH
37268: EMPTY
37269: LIST
37270: LIST
37271: PUSH
37272: LD_INT 2
37274: PUSH
37275: LD_INT 0
37277: PUSH
37278: EMPTY
37279: LIST
37280: LIST
37281: PUSH
37282: LD_INT 2
37284: PUSH
37285: LD_INT 1
37287: PUSH
37288: EMPTY
37289: LIST
37290: LIST
37291: PUSH
37292: LD_INT 2
37294: PUSH
37295: LD_INT 2
37297: PUSH
37298: EMPTY
37299: LIST
37300: LIST
37301: PUSH
37302: LD_INT 1
37304: PUSH
37305: LD_INT 2
37307: PUSH
37308: EMPTY
37309: LIST
37310: LIST
37311: PUSH
37312: LD_INT 0
37314: PUSH
37315: LD_INT 2
37317: PUSH
37318: EMPTY
37319: LIST
37320: LIST
37321: PUSH
37322: LD_INT 1
37324: NEG
37325: PUSH
37326: LD_INT 1
37328: PUSH
37329: EMPTY
37330: LIST
37331: LIST
37332: PUSH
37333: LD_INT 2
37335: NEG
37336: PUSH
37337: LD_INT 0
37339: PUSH
37340: EMPTY
37341: LIST
37342: LIST
37343: PUSH
37344: LD_INT 2
37346: NEG
37347: PUSH
37348: LD_INT 1
37350: NEG
37351: PUSH
37352: EMPTY
37353: LIST
37354: LIST
37355: PUSH
37356: LD_INT 2
37358: NEG
37359: PUSH
37360: LD_INT 2
37362: NEG
37363: PUSH
37364: EMPTY
37365: LIST
37366: LIST
37367: PUSH
37368: LD_INT 1
37370: NEG
37371: PUSH
37372: LD_INT 2
37374: PUSH
37375: EMPTY
37376: LIST
37377: LIST
37378: PUSH
37379: LD_INT 2
37381: NEG
37382: PUSH
37383: LD_INT 1
37385: PUSH
37386: EMPTY
37387: LIST
37388: LIST
37389: PUSH
37390: LD_INT 3
37392: NEG
37393: PUSH
37394: LD_INT 1
37396: NEG
37397: PUSH
37398: EMPTY
37399: LIST
37400: LIST
37401: PUSH
37402: LD_INT 3
37404: NEG
37405: PUSH
37406: LD_INT 2
37408: NEG
37409: PUSH
37410: EMPTY
37411: LIST
37412: LIST
37413: PUSH
37414: EMPTY
37415: LIST
37416: LIST
37417: LIST
37418: LIST
37419: LIST
37420: LIST
37421: LIST
37422: LIST
37423: LIST
37424: LIST
37425: LIST
37426: LIST
37427: LIST
37428: LIST
37429: LIST
37430: LIST
37431: LIST
37432: LIST
37433: LIST
37434: LIST
37435: LIST
37436: LIST
37437: LIST
37438: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
37439: LD_ADDR_VAR 0 28
37443: PUSH
37444: LD_INT 0
37446: PUSH
37447: LD_INT 0
37449: PUSH
37450: EMPTY
37451: LIST
37452: LIST
37453: PUSH
37454: LD_INT 0
37456: PUSH
37457: LD_INT 1
37459: NEG
37460: PUSH
37461: EMPTY
37462: LIST
37463: LIST
37464: PUSH
37465: LD_INT 1
37467: PUSH
37468: LD_INT 0
37470: PUSH
37471: EMPTY
37472: LIST
37473: LIST
37474: PUSH
37475: LD_INT 1
37477: PUSH
37478: LD_INT 1
37480: PUSH
37481: EMPTY
37482: LIST
37483: LIST
37484: PUSH
37485: LD_INT 0
37487: PUSH
37488: LD_INT 1
37490: PUSH
37491: EMPTY
37492: LIST
37493: LIST
37494: PUSH
37495: LD_INT 1
37497: NEG
37498: PUSH
37499: LD_INT 0
37501: PUSH
37502: EMPTY
37503: LIST
37504: LIST
37505: PUSH
37506: LD_INT 1
37508: NEG
37509: PUSH
37510: LD_INT 1
37512: NEG
37513: PUSH
37514: EMPTY
37515: LIST
37516: LIST
37517: PUSH
37518: LD_INT 1
37520: NEG
37521: PUSH
37522: LD_INT 2
37524: NEG
37525: PUSH
37526: EMPTY
37527: LIST
37528: LIST
37529: PUSH
37530: LD_INT 0
37532: PUSH
37533: LD_INT 2
37535: NEG
37536: PUSH
37537: EMPTY
37538: LIST
37539: LIST
37540: PUSH
37541: LD_INT 1
37543: PUSH
37544: LD_INT 1
37546: NEG
37547: PUSH
37548: EMPTY
37549: LIST
37550: LIST
37551: PUSH
37552: LD_INT 2
37554: PUSH
37555: LD_INT 0
37557: PUSH
37558: EMPTY
37559: LIST
37560: LIST
37561: PUSH
37562: LD_INT 2
37564: PUSH
37565: LD_INT 1
37567: PUSH
37568: EMPTY
37569: LIST
37570: LIST
37571: PUSH
37572: LD_INT 2
37574: PUSH
37575: LD_INT 2
37577: PUSH
37578: EMPTY
37579: LIST
37580: LIST
37581: PUSH
37582: LD_INT 1
37584: PUSH
37585: LD_INT 2
37587: PUSH
37588: EMPTY
37589: LIST
37590: LIST
37591: PUSH
37592: LD_INT 0
37594: PUSH
37595: LD_INT 2
37597: PUSH
37598: EMPTY
37599: LIST
37600: LIST
37601: PUSH
37602: LD_INT 1
37604: NEG
37605: PUSH
37606: LD_INT 1
37608: PUSH
37609: EMPTY
37610: LIST
37611: LIST
37612: PUSH
37613: LD_INT 2
37615: NEG
37616: PUSH
37617: LD_INT 0
37619: PUSH
37620: EMPTY
37621: LIST
37622: LIST
37623: PUSH
37624: LD_INT 2
37626: NEG
37627: PUSH
37628: LD_INT 1
37630: NEG
37631: PUSH
37632: EMPTY
37633: LIST
37634: LIST
37635: PUSH
37636: LD_INT 2
37638: NEG
37639: PUSH
37640: LD_INT 2
37642: NEG
37643: PUSH
37644: EMPTY
37645: LIST
37646: LIST
37647: PUSH
37648: LD_INT 2
37650: NEG
37651: PUSH
37652: LD_INT 3
37654: NEG
37655: PUSH
37656: EMPTY
37657: LIST
37658: LIST
37659: PUSH
37660: LD_INT 1
37662: NEG
37663: PUSH
37664: LD_INT 3
37666: NEG
37667: PUSH
37668: EMPTY
37669: LIST
37670: LIST
37671: PUSH
37672: LD_INT 3
37674: NEG
37675: PUSH
37676: LD_INT 1
37678: NEG
37679: PUSH
37680: EMPTY
37681: LIST
37682: LIST
37683: PUSH
37684: LD_INT 3
37686: NEG
37687: PUSH
37688: LD_INT 2
37690: NEG
37691: PUSH
37692: EMPTY
37693: LIST
37694: LIST
37695: PUSH
37696: EMPTY
37697: LIST
37698: LIST
37699: LIST
37700: LIST
37701: LIST
37702: LIST
37703: LIST
37704: LIST
37705: LIST
37706: LIST
37707: LIST
37708: LIST
37709: LIST
37710: LIST
37711: LIST
37712: LIST
37713: LIST
37714: LIST
37715: LIST
37716: LIST
37717: LIST
37718: LIST
37719: LIST
37720: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
37721: LD_ADDR_VAR 0 29
37725: PUSH
37726: LD_INT 0
37728: PUSH
37729: LD_INT 0
37731: PUSH
37732: EMPTY
37733: LIST
37734: LIST
37735: PUSH
37736: LD_INT 0
37738: PUSH
37739: LD_INT 1
37741: NEG
37742: PUSH
37743: EMPTY
37744: LIST
37745: LIST
37746: PUSH
37747: LD_INT 1
37749: PUSH
37750: LD_INT 0
37752: PUSH
37753: EMPTY
37754: LIST
37755: LIST
37756: PUSH
37757: LD_INT 1
37759: PUSH
37760: LD_INT 1
37762: PUSH
37763: EMPTY
37764: LIST
37765: LIST
37766: PUSH
37767: LD_INT 0
37769: PUSH
37770: LD_INT 1
37772: PUSH
37773: EMPTY
37774: LIST
37775: LIST
37776: PUSH
37777: LD_INT 1
37779: NEG
37780: PUSH
37781: LD_INT 0
37783: PUSH
37784: EMPTY
37785: LIST
37786: LIST
37787: PUSH
37788: LD_INT 1
37790: NEG
37791: PUSH
37792: LD_INT 1
37794: NEG
37795: PUSH
37796: EMPTY
37797: LIST
37798: LIST
37799: PUSH
37800: LD_INT 1
37802: NEG
37803: PUSH
37804: LD_INT 2
37806: NEG
37807: PUSH
37808: EMPTY
37809: LIST
37810: LIST
37811: PUSH
37812: LD_INT 0
37814: PUSH
37815: LD_INT 2
37817: NEG
37818: PUSH
37819: EMPTY
37820: LIST
37821: LIST
37822: PUSH
37823: LD_INT 1
37825: PUSH
37826: LD_INT 1
37828: NEG
37829: PUSH
37830: EMPTY
37831: LIST
37832: LIST
37833: PUSH
37834: LD_INT 2
37836: PUSH
37837: LD_INT 0
37839: PUSH
37840: EMPTY
37841: LIST
37842: LIST
37843: PUSH
37844: LD_INT 2
37846: PUSH
37847: LD_INT 1
37849: PUSH
37850: EMPTY
37851: LIST
37852: LIST
37853: PUSH
37854: LD_INT 1
37856: PUSH
37857: LD_INT 2
37859: PUSH
37860: EMPTY
37861: LIST
37862: LIST
37863: PUSH
37864: LD_INT 0
37866: PUSH
37867: LD_INT 2
37869: PUSH
37870: EMPTY
37871: LIST
37872: LIST
37873: PUSH
37874: LD_INT 1
37876: NEG
37877: PUSH
37878: LD_INT 1
37880: PUSH
37881: EMPTY
37882: LIST
37883: LIST
37884: PUSH
37885: LD_INT 2
37887: NEG
37888: PUSH
37889: LD_INT 1
37891: NEG
37892: PUSH
37893: EMPTY
37894: LIST
37895: LIST
37896: PUSH
37897: LD_INT 2
37899: NEG
37900: PUSH
37901: LD_INT 2
37903: NEG
37904: PUSH
37905: EMPTY
37906: LIST
37907: LIST
37908: PUSH
37909: LD_INT 2
37911: NEG
37912: PUSH
37913: LD_INT 3
37915: NEG
37916: PUSH
37917: EMPTY
37918: LIST
37919: LIST
37920: PUSH
37921: LD_INT 2
37923: PUSH
37924: LD_INT 1
37926: NEG
37927: PUSH
37928: EMPTY
37929: LIST
37930: LIST
37931: PUSH
37932: LD_INT 3
37934: PUSH
37935: LD_INT 1
37937: PUSH
37938: EMPTY
37939: LIST
37940: LIST
37941: PUSH
37942: LD_INT 1
37944: PUSH
37945: LD_INT 3
37947: PUSH
37948: EMPTY
37949: LIST
37950: LIST
37951: PUSH
37952: LD_INT 1
37954: NEG
37955: PUSH
37956: LD_INT 2
37958: PUSH
37959: EMPTY
37960: LIST
37961: LIST
37962: PUSH
37963: LD_INT 3
37965: NEG
37966: PUSH
37967: LD_INT 2
37969: NEG
37970: PUSH
37971: EMPTY
37972: LIST
37973: LIST
37974: PUSH
37975: EMPTY
37976: LIST
37977: LIST
37978: LIST
37979: LIST
37980: LIST
37981: LIST
37982: LIST
37983: LIST
37984: LIST
37985: LIST
37986: LIST
37987: LIST
37988: LIST
37989: LIST
37990: LIST
37991: LIST
37992: LIST
37993: LIST
37994: LIST
37995: LIST
37996: LIST
37997: LIST
37998: LIST
37999: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
38000: LD_ADDR_VAR 0 30
38004: PUSH
38005: LD_INT 0
38007: PUSH
38008: LD_INT 0
38010: PUSH
38011: EMPTY
38012: LIST
38013: LIST
38014: PUSH
38015: LD_INT 0
38017: PUSH
38018: LD_INT 1
38020: NEG
38021: PUSH
38022: EMPTY
38023: LIST
38024: LIST
38025: PUSH
38026: LD_INT 1
38028: PUSH
38029: LD_INT 0
38031: PUSH
38032: EMPTY
38033: LIST
38034: LIST
38035: PUSH
38036: LD_INT 1
38038: PUSH
38039: LD_INT 1
38041: PUSH
38042: EMPTY
38043: LIST
38044: LIST
38045: PUSH
38046: LD_INT 0
38048: PUSH
38049: LD_INT 1
38051: PUSH
38052: EMPTY
38053: LIST
38054: LIST
38055: PUSH
38056: LD_INT 1
38058: NEG
38059: PUSH
38060: LD_INT 0
38062: PUSH
38063: EMPTY
38064: LIST
38065: LIST
38066: PUSH
38067: LD_INT 1
38069: NEG
38070: PUSH
38071: LD_INT 1
38073: NEG
38074: PUSH
38075: EMPTY
38076: LIST
38077: LIST
38078: PUSH
38079: LD_INT 1
38081: NEG
38082: PUSH
38083: LD_INT 2
38085: NEG
38086: PUSH
38087: EMPTY
38088: LIST
38089: LIST
38090: PUSH
38091: LD_INT 0
38093: PUSH
38094: LD_INT 2
38096: NEG
38097: PUSH
38098: EMPTY
38099: LIST
38100: LIST
38101: PUSH
38102: LD_INT 1
38104: PUSH
38105: LD_INT 1
38107: NEG
38108: PUSH
38109: EMPTY
38110: LIST
38111: LIST
38112: PUSH
38113: LD_INT 2
38115: PUSH
38116: LD_INT 0
38118: PUSH
38119: EMPTY
38120: LIST
38121: LIST
38122: PUSH
38123: LD_INT 2
38125: PUSH
38126: LD_INT 1
38128: PUSH
38129: EMPTY
38130: LIST
38131: LIST
38132: PUSH
38133: LD_INT 2
38135: PUSH
38136: LD_INT 2
38138: PUSH
38139: EMPTY
38140: LIST
38141: LIST
38142: PUSH
38143: LD_INT 1
38145: PUSH
38146: LD_INT 2
38148: PUSH
38149: EMPTY
38150: LIST
38151: LIST
38152: PUSH
38153: LD_INT 1
38155: NEG
38156: PUSH
38157: LD_INT 1
38159: PUSH
38160: EMPTY
38161: LIST
38162: LIST
38163: PUSH
38164: LD_INT 2
38166: NEG
38167: PUSH
38168: LD_INT 0
38170: PUSH
38171: EMPTY
38172: LIST
38173: LIST
38174: PUSH
38175: LD_INT 2
38177: NEG
38178: PUSH
38179: LD_INT 1
38181: NEG
38182: PUSH
38183: EMPTY
38184: LIST
38185: LIST
38186: PUSH
38187: LD_INT 1
38189: NEG
38190: PUSH
38191: LD_INT 3
38193: NEG
38194: PUSH
38195: EMPTY
38196: LIST
38197: LIST
38198: PUSH
38199: LD_INT 1
38201: PUSH
38202: LD_INT 2
38204: NEG
38205: PUSH
38206: EMPTY
38207: LIST
38208: LIST
38209: PUSH
38210: LD_INT 3
38212: PUSH
38213: LD_INT 2
38215: PUSH
38216: EMPTY
38217: LIST
38218: LIST
38219: PUSH
38220: LD_INT 2
38222: PUSH
38223: LD_INT 3
38225: PUSH
38226: EMPTY
38227: LIST
38228: LIST
38229: PUSH
38230: LD_INT 2
38232: NEG
38233: PUSH
38234: LD_INT 1
38236: PUSH
38237: EMPTY
38238: LIST
38239: LIST
38240: PUSH
38241: LD_INT 3
38243: NEG
38244: PUSH
38245: LD_INT 1
38247: NEG
38248: PUSH
38249: EMPTY
38250: LIST
38251: LIST
38252: PUSH
38253: EMPTY
38254: LIST
38255: LIST
38256: LIST
38257: LIST
38258: LIST
38259: LIST
38260: LIST
38261: LIST
38262: LIST
38263: LIST
38264: LIST
38265: LIST
38266: LIST
38267: LIST
38268: LIST
38269: LIST
38270: LIST
38271: LIST
38272: LIST
38273: LIST
38274: LIST
38275: LIST
38276: LIST
38277: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
38278: LD_ADDR_VAR 0 31
38282: PUSH
38283: LD_INT 0
38285: PUSH
38286: LD_INT 0
38288: PUSH
38289: EMPTY
38290: LIST
38291: LIST
38292: PUSH
38293: LD_INT 0
38295: PUSH
38296: LD_INT 1
38298: NEG
38299: PUSH
38300: EMPTY
38301: LIST
38302: LIST
38303: PUSH
38304: LD_INT 1
38306: PUSH
38307: LD_INT 0
38309: PUSH
38310: EMPTY
38311: LIST
38312: LIST
38313: PUSH
38314: LD_INT 1
38316: PUSH
38317: LD_INT 1
38319: PUSH
38320: EMPTY
38321: LIST
38322: LIST
38323: PUSH
38324: LD_INT 0
38326: PUSH
38327: LD_INT 1
38329: PUSH
38330: EMPTY
38331: LIST
38332: LIST
38333: PUSH
38334: LD_INT 1
38336: NEG
38337: PUSH
38338: LD_INT 0
38340: PUSH
38341: EMPTY
38342: LIST
38343: LIST
38344: PUSH
38345: LD_INT 1
38347: NEG
38348: PUSH
38349: LD_INT 1
38351: NEG
38352: PUSH
38353: EMPTY
38354: LIST
38355: LIST
38356: PUSH
38357: LD_INT 1
38359: NEG
38360: PUSH
38361: LD_INT 2
38363: NEG
38364: PUSH
38365: EMPTY
38366: LIST
38367: LIST
38368: PUSH
38369: LD_INT 1
38371: PUSH
38372: LD_INT 1
38374: NEG
38375: PUSH
38376: EMPTY
38377: LIST
38378: LIST
38379: PUSH
38380: LD_INT 2
38382: PUSH
38383: LD_INT 0
38385: PUSH
38386: EMPTY
38387: LIST
38388: LIST
38389: PUSH
38390: LD_INT 2
38392: PUSH
38393: LD_INT 1
38395: PUSH
38396: EMPTY
38397: LIST
38398: LIST
38399: PUSH
38400: LD_INT 2
38402: PUSH
38403: LD_INT 2
38405: PUSH
38406: EMPTY
38407: LIST
38408: LIST
38409: PUSH
38410: LD_INT 1
38412: PUSH
38413: LD_INT 2
38415: PUSH
38416: EMPTY
38417: LIST
38418: LIST
38419: PUSH
38420: LD_INT 0
38422: PUSH
38423: LD_INT 2
38425: PUSH
38426: EMPTY
38427: LIST
38428: LIST
38429: PUSH
38430: LD_INT 1
38432: NEG
38433: PUSH
38434: LD_INT 1
38436: PUSH
38437: EMPTY
38438: LIST
38439: LIST
38440: PUSH
38441: LD_INT 2
38443: NEG
38444: PUSH
38445: LD_INT 1
38447: NEG
38448: PUSH
38449: EMPTY
38450: LIST
38451: LIST
38452: PUSH
38453: LD_INT 2
38455: NEG
38456: PUSH
38457: LD_INT 2
38459: NEG
38460: PUSH
38461: EMPTY
38462: LIST
38463: LIST
38464: PUSH
38465: LD_INT 2
38467: NEG
38468: PUSH
38469: LD_INT 3
38471: NEG
38472: PUSH
38473: EMPTY
38474: LIST
38475: LIST
38476: PUSH
38477: LD_INT 2
38479: PUSH
38480: LD_INT 1
38482: NEG
38483: PUSH
38484: EMPTY
38485: LIST
38486: LIST
38487: PUSH
38488: LD_INT 3
38490: PUSH
38491: LD_INT 1
38493: PUSH
38494: EMPTY
38495: LIST
38496: LIST
38497: PUSH
38498: LD_INT 1
38500: PUSH
38501: LD_INT 3
38503: PUSH
38504: EMPTY
38505: LIST
38506: LIST
38507: PUSH
38508: LD_INT 1
38510: NEG
38511: PUSH
38512: LD_INT 2
38514: PUSH
38515: EMPTY
38516: LIST
38517: LIST
38518: PUSH
38519: LD_INT 3
38521: NEG
38522: PUSH
38523: LD_INT 2
38525: NEG
38526: PUSH
38527: EMPTY
38528: LIST
38529: LIST
38530: PUSH
38531: EMPTY
38532: LIST
38533: LIST
38534: LIST
38535: LIST
38536: LIST
38537: LIST
38538: LIST
38539: LIST
38540: LIST
38541: LIST
38542: LIST
38543: LIST
38544: LIST
38545: LIST
38546: LIST
38547: LIST
38548: LIST
38549: LIST
38550: LIST
38551: LIST
38552: LIST
38553: LIST
38554: LIST
38555: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
38556: LD_ADDR_VAR 0 32
38560: PUSH
38561: LD_INT 0
38563: PUSH
38564: LD_INT 0
38566: PUSH
38567: EMPTY
38568: LIST
38569: LIST
38570: PUSH
38571: LD_INT 0
38573: PUSH
38574: LD_INT 1
38576: NEG
38577: PUSH
38578: EMPTY
38579: LIST
38580: LIST
38581: PUSH
38582: LD_INT 1
38584: PUSH
38585: LD_INT 0
38587: PUSH
38588: EMPTY
38589: LIST
38590: LIST
38591: PUSH
38592: LD_INT 1
38594: PUSH
38595: LD_INT 1
38597: PUSH
38598: EMPTY
38599: LIST
38600: LIST
38601: PUSH
38602: LD_INT 0
38604: PUSH
38605: LD_INT 1
38607: PUSH
38608: EMPTY
38609: LIST
38610: LIST
38611: PUSH
38612: LD_INT 1
38614: NEG
38615: PUSH
38616: LD_INT 0
38618: PUSH
38619: EMPTY
38620: LIST
38621: LIST
38622: PUSH
38623: LD_INT 1
38625: NEG
38626: PUSH
38627: LD_INT 1
38629: NEG
38630: PUSH
38631: EMPTY
38632: LIST
38633: LIST
38634: PUSH
38635: LD_INT 1
38637: NEG
38638: PUSH
38639: LD_INT 2
38641: NEG
38642: PUSH
38643: EMPTY
38644: LIST
38645: LIST
38646: PUSH
38647: LD_INT 0
38649: PUSH
38650: LD_INT 2
38652: NEG
38653: PUSH
38654: EMPTY
38655: LIST
38656: LIST
38657: PUSH
38658: LD_INT 1
38660: PUSH
38661: LD_INT 1
38663: NEG
38664: PUSH
38665: EMPTY
38666: LIST
38667: LIST
38668: PUSH
38669: LD_INT 2
38671: PUSH
38672: LD_INT 1
38674: PUSH
38675: EMPTY
38676: LIST
38677: LIST
38678: PUSH
38679: LD_INT 2
38681: PUSH
38682: LD_INT 2
38684: PUSH
38685: EMPTY
38686: LIST
38687: LIST
38688: PUSH
38689: LD_INT 1
38691: PUSH
38692: LD_INT 2
38694: PUSH
38695: EMPTY
38696: LIST
38697: LIST
38698: PUSH
38699: LD_INT 0
38701: PUSH
38702: LD_INT 2
38704: PUSH
38705: EMPTY
38706: LIST
38707: LIST
38708: PUSH
38709: LD_INT 1
38711: NEG
38712: PUSH
38713: LD_INT 1
38715: PUSH
38716: EMPTY
38717: LIST
38718: LIST
38719: PUSH
38720: LD_INT 2
38722: NEG
38723: PUSH
38724: LD_INT 0
38726: PUSH
38727: EMPTY
38728: LIST
38729: LIST
38730: PUSH
38731: LD_INT 2
38733: NEG
38734: PUSH
38735: LD_INT 1
38737: NEG
38738: PUSH
38739: EMPTY
38740: LIST
38741: LIST
38742: PUSH
38743: LD_INT 1
38745: NEG
38746: PUSH
38747: LD_INT 3
38749: NEG
38750: PUSH
38751: EMPTY
38752: LIST
38753: LIST
38754: PUSH
38755: LD_INT 1
38757: PUSH
38758: LD_INT 2
38760: NEG
38761: PUSH
38762: EMPTY
38763: LIST
38764: LIST
38765: PUSH
38766: LD_INT 3
38768: PUSH
38769: LD_INT 2
38771: PUSH
38772: EMPTY
38773: LIST
38774: LIST
38775: PUSH
38776: LD_INT 2
38778: PUSH
38779: LD_INT 3
38781: PUSH
38782: EMPTY
38783: LIST
38784: LIST
38785: PUSH
38786: LD_INT 2
38788: NEG
38789: PUSH
38790: LD_INT 1
38792: PUSH
38793: EMPTY
38794: LIST
38795: LIST
38796: PUSH
38797: LD_INT 3
38799: NEG
38800: PUSH
38801: LD_INT 1
38803: NEG
38804: PUSH
38805: EMPTY
38806: LIST
38807: LIST
38808: PUSH
38809: EMPTY
38810: LIST
38811: LIST
38812: LIST
38813: LIST
38814: LIST
38815: LIST
38816: LIST
38817: LIST
38818: LIST
38819: LIST
38820: LIST
38821: LIST
38822: LIST
38823: LIST
38824: LIST
38825: LIST
38826: LIST
38827: LIST
38828: LIST
38829: LIST
38830: LIST
38831: LIST
38832: LIST
38833: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
38834: LD_ADDR_VAR 0 33
38838: PUSH
38839: LD_INT 0
38841: PUSH
38842: LD_INT 0
38844: PUSH
38845: EMPTY
38846: LIST
38847: LIST
38848: PUSH
38849: LD_INT 0
38851: PUSH
38852: LD_INT 1
38854: NEG
38855: PUSH
38856: EMPTY
38857: LIST
38858: LIST
38859: PUSH
38860: LD_INT 1
38862: PUSH
38863: LD_INT 0
38865: PUSH
38866: EMPTY
38867: LIST
38868: LIST
38869: PUSH
38870: LD_INT 1
38872: PUSH
38873: LD_INT 1
38875: PUSH
38876: EMPTY
38877: LIST
38878: LIST
38879: PUSH
38880: LD_INT 0
38882: PUSH
38883: LD_INT 1
38885: PUSH
38886: EMPTY
38887: LIST
38888: LIST
38889: PUSH
38890: LD_INT 1
38892: NEG
38893: PUSH
38894: LD_INT 0
38896: PUSH
38897: EMPTY
38898: LIST
38899: LIST
38900: PUSH
38901: LD_INT 1
38903: NEG
38904: PUSH
38905: LD_INT 1
38907: NEG
38908: PUSH
38909: EMPTY
38910: LIST
38911: LIST
38912: PUSH
38913: LD_INT 1
38915: NEG
38916: PUSH
38917: LD_INT 2
38919: NEG
38920: PUSH
38921: EMPTY
38922: LIST
38923: LIST
38924: PUSH
38925: LD_INT 1
38927: PUSH
38928: LD_INT 1
38930: NEG
38931: PUSH
38932: EMPTY
38933: LIST
38934: LIST
38935: PUSH
38936: LD_INT 2
38938: PUSH
38939: LD_INT 0
38941: PUSH
38942: EMPTY
38943: LIST
38944: LIST
38945: PUSH
38946: LD_INT 2
38948: PUSH
38949: LD_INT 1
38951: PUSH
38952: EMPTY
38953: LIST
38954: LIST
38955: PUSH
38956: LD_INT 1
38958: PUSH
38959: LD_INT 2
38961: PUSH
38962: EMPTY
38963: LIST
38964: LIST
38965: PUSH
38966: LD_INT 0
38968: PUSH
38969: LD_INT 2
38971: PUSH
38972: EMPTY
38973: LIST
38974: LIST
38975: PUSH
38976: LD_INT 1
38978: NEG
38979: PUSH
38980: LD_INT 1
38982: PUSH
38983: EMPTY
38984: LIST
38985: LIST
38986: PUSH
38987: LD_INT 2
38989: NEG
38990: PUSH
38991: LD_INT 0
38993: PUSH
38994: EMPTY
38995: LIST
38996: LIST
38997: PUSH
38998: LD_INT 2
39000: NEG
39001: PUSH
39002: LD_INT 1
39004: NEG
39005: PUSH
39006: EMPTY
39007: LIST
39008: LIST
39009: PUSH
39010: LD_INT 2
39012: NEG
39013: PUSH
39014: LD_INT 2
39016: NEG
39017: PUSH
39018: EMPTY
39019: LIST
39020: LIST
39021: PUSH
39022: LD_INT 2
39024: NEG
39025: PUSH
39026: LD_INT 3
39028: NEG
39029: PUSH
39030: EMPTY
39031: LIST
39032: LIST
39033: PUSH
39034: LD_INT 2
39036: PUSH
39037: LD_INT 1
39039: NEG
39040: PUSH
39041: EMPTY
39042: LIST
39043: LIST
39044: PUSH
39045: LD_INT 3
39047: PUSH
39048: LD_INT 1
39050: PUSH
39051: EMPTY
39052: LIST
39053: LIST
39054: PUSH
39055: LD_INT 1
39057: PUSH
39058: LD_INT 3
39060: PUSH
39061: EMPTY
39062: LIST
39063: LIST
39064: PUSH
39065: LD_INT 1
39067: NEG
39068: PUSH
39069: LD_INT 2
39071: PUSH
39072: EMPTY
39073: LIST
39074: LIST
39075: PUSH
39076: LD_INT 3
39078: NEG
39079: PUSH
39080: LD_INT 2
39082: NEG
39083: PUSH
39084: EMPTY
39085: LIST
39086: LIST
39087: PUSH
39088: EMPTY
39089: LIST
39090: LIST
39091: LIST
39092: LIST
39093: LIST
39094: LIST
39095: LIST
39096: LIST
39097: LIST
39098: LIST
39099: LIST
39100: LIST
39101: LIST
39102: LIST
39103: LIST
39104: LIST
39105: LIST
39106: LIST
39107: LIST
39108: LIST
39109: LIST
39110: LIST
39111: LIST
39112: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
39113: LD_ADDR_VAR 0 34
39117: PUSH
39118: LD_INT 0
39120: PUSH
39121: LD_INT 0
39123: PUSH
39124: EMPTY
39125: LIST
39126: LIST
39127: PUSH
39128: LD_INT 0
39130: PUSH
39131: LD_INT 1
39133: NEG
39134: PUSH
39135: EMPTY
39136: LIST
39137: LIST
39138: PUSH
39139: LD_INT 1
39141: PUSH
39142: LD_INT 0
39144: PUSH
39145: EMPTY
39146: LIST
39147: LIST
39148: PUSH
39149: LD_INT 1
39151: PUSH
39152: LD_INT 1
39154: PUSH
39155: EMPTY
39156: LIST
39157: LIST
39158: PUSH
39159: LD_INT 0
39161: PUSH
39162: LD_INT 1
39164: PUSH
39165: EMPTY
39166: LIST
39167: LIST
39168: PUSH
39169: LD_INT 1
39171: NEG
39172: PUSH
39173: LD_INT 0
39175: PUSH
39176: EMPTY
39177: LIST
39178: LIST
39179: PUSH
39180: LD_INT 1
39182: NEG
39183: PUSH
39184: LD_INT 1
39186: NEG
39187: PUSH
39188: EMPTY
39189: LIST
39190: LIST
39191: PUSH
39192: LD_INT 1
39194: NEG
39195: PUSH
39196: LD_INT 2
39198: NEG
39199: PUSH
39200: EMPTY
39201: LIST
39202: LIST
39203: PUSH
39204: LD_INT 0
39206: PUSH
39207: LD_INT 2
39209: NEG
39210: PUSH
39211: EMPTY
39212: LIST
39213: LIST
39214: PUSH
39215: LD_INT 1
39217: PUSH
39218: LD_INT 1
39220: NEG
39221: PUSH
39222: EMPTY
39223: LIST
39224: LIST
39225: PUSH
39226: LD_INT 2
39228: PUSH
39229: LD_INT 1
39231: PUSH
39232: EMPTY
39233: LIST
39234: LIST
39235: PUSH
39236: LD_INT 2
39238: PUSH
39239: LD_INT 2
39241: PUSH
39242: EMPTY
39243: LIST
39244: LIST
39245: PUSH
39246: LD_INT 1
39248: PUSH
39249: LD_INT 2
39251: PUSH
39252: EMPTY
39253: LIST
39254: LIST
39255: PUSH
39256: LD_INT 1
39258: NEG
39259: PUSH
39260: LD_INT 1
39262: PUSH
39263: EMPTY
39264: LIST
39265: LIST
39266: PUSH
39267: LD_INT 2
39269: NEG
39270: PUSH
39271: LD_INT 0
39273: PUSH
39274: EMPTY
39275: LIST
39276: LIST
39277: PUSH
39278: LD_INT 2
39280: NEG
39281: PUSH
39282: LD_INT 1
39284: NEG
39285: PUSH
39286: EMPTY
39287: LIST
39288: LIST
39289: PUSH
39290: LD_INT 2
39292: NEG
39293: PUSH
39294: LD_INT 2
39296: NEG
39297: PUSH
39298: EMPTY
39299: LIST
39300: LIST
39301: PUSH
39302: LD_INT 1
39304: NEG
39305: PUSH
39306: LD_INT 3
39308: NEG
39309: PUSH
39310: EMPTY
39311: LIST
39312: LIST
39313: PUSH
39314: LD_INT 1
39316: PUSH
39317: LD_INT 2
39319: NEG
39320: PUSH
39321: EMPTY
39322: LIST
39323: LIST
39324: PUSH
39325: LD_INT 3
39327: PUSH
39328: LD_INT 2
39330: PUSH
39331: EMPTY
39332: LIST
39333: LIST
39334: PUSH
39335: LD_INT 2
39337: PUSH
39338: LD_INT 3
39340: PUSH
39341: EMPTY
39342: LIST
39343: LIST
39344: PUSH
39345: LD_INT 2
39347: NEG
39348: PUSH
39349: LD_INT 1
39351: PUSH
39352: EMPTY
39353: LIST
39354: LIST
39355: PUSH
39356: LD_INT 3
39358: NEG
39359: PUSH
39360: LD_INT 1
39362: NEG
39363: PUSH
39364: EMPTY
39365: LIST
39366: LIST
39367: PUSH
39368: EMPTY
39369: LIST
39370: LIST
39371: LIST
39372: LIST
39373: LIST
39374: LIST
39375: LIST
39376: LIST
39377: LIST
39378: LIST
39379: LIST
39380: LIST
39381: LIST
39382: LIST
39383: LIST
39384: LIST
39385: LIST
39386: LIST
39387: LIST
39388: LIST
39389: LIST
39390: LIST
39391: LIST
39392: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
39393: LD_ADDR_VAR 0 35
39397: PUSH
39398: LD_INT 0
39400: PUSH
39401: LD_INT 0
39403: PUSH
39404: EMPTY
39405: LIST
39406: LIST
39407: PUSH
39408: LD_INT 0
39410: PUSH
39411: LD_INT 1
39413: NEG
39414: PUSH
39415: EMPTY
39416: LIST
39417: LIST
39418: PUSH
39419: LD_INT 1
39421: PUSH
39422: LD_INT 0
39424: PUSH
39425: EMPTY
39426: LIST
39427: LIST
39428: PUSH
39429: LD_INT 1
39431: PUSH
39432: LD_INT 1
39434: PUSH
39435: EMPTY
39436: LIST
39437: LIST
39438: PUSH
39439: LD_INT 0
39441: PUSH
39442: LD_INT 1
39444: PUSH
39445: EMPTY
39446: LIST
39447: LIST
39448: PUSH
39449: LD_INT 1
39451: NEG
39452: PUSH
39453: LD_INT 0
39455: PUSH
39456: EMPTY
39457: LIST
39458: LIST
39459: PUSH
39460: LD_INT 1
39462: NEG
39463: PUSH
39464: LD_INT 1
39466: NEG
39467: PUSH
39468: EMPTY
39469: LIST
39470: LIST
39471: PUSH
39472: LD_INT 2
39474: PUSH
39475: LD_INT 1
39477: PUSH
39478: EMPTY
39479: LIST
39480: LIST
39481: PUSH
39482: LD_INT 2
39484: NEG
39485: PUSH
39486: LD_INT 1
39488: NEG
39489: PUSH
39490: EMPTY
39491: LIST
39492: LIST
39493: PUSH
39494: EMPTY
39495: LIST
39496: LIST
39497: LIST
39498: LIST
39499: LIST
39500: LIST
39501: LIST
39502: LIST
39503: LIST
39504: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
39505: LD_ADDR_VAR 0 36
39509: PUSH
39510: LD_INT 0
39512: PUSH
39513: LD_INT 0
39515: PUSH
39516: EMPTY
39517: LIST
39518: LIST
39519: PUSH
39520: LD_INT 0
39522: PUSH
39523: LD_INT 1
39525: NEG
39526: PUSH
39527: EMPTY
39528: LIST
39529: LIST
39530: PUSH
39531: LD_INT 1
39533: PUSH
39534: LD_INT 0
39536: PUSH
39537: EMPTY
39538: LIST
39539: LIST
39540: PUSH
39541: LD_INT 1
39543: PUSH
39544: LD_INT 1
39546: PUSH
39547: EMPTY
39548: LIST
39549: LIST
39550: PUSH
39551: LD_INT 0
39553: PUSH
39554: LD_INT 1
39556: PUSH
39557: EMPTY
39558: LIST
39559: LIST
39560: PUSH
39561: LD_INT 1
39563: NEG
39564: PUSH
39565: LD_INT 0
39567: PUSH
39568: EMPTY
39569: LIST
39570: LIST
39571: PUSH
39572: LD_INT 1
39574: NEG
39575: PUSH
39576: LD_INT 1
39578: NEG
39579: PUSH
39580: EMPTY
39581: LIST
39582: LIST
39583: PUSH
39584: LD_INT 1
39586: NEG
39587: PUSH
39588: LD_INT 2
39590: NEG
39591: PUSH
39592: EMPTY
39593: LIST
39594: LIST
39595: PUSH
39596: LD_INT 1
39598: PUSH
39599: LD_INT 2
39601: PUSH
39602: EMPTY
39603: LIST
39604: LIST
39605: PUSH
39606: EMPTY
39607: LIST
39608: LIST
39609: LIST
39610: LIST
39611: LIST
39612: LIST
39613: LIST
39614: LIST
39615: LIST
39616: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
39617: LD_ADDR_VAR 0 37
39621: PUSH
39622: LD_INT 0
39624: PUSH
39625: LD_INT 0
39627: PUSH
39628: EMPTY
39629: LIST
39630: LIST
39631: PUSH
39632: LD_INT 0
39634: PUSH
39635: LD_INT 1
39637: NEG
39638: PUSH
39639: EMPTY
39640: LIST
39641: LIST
39642: PUSH
39643: LD_INT 1
39645: PUSH
39646: LD_INT 0
39648: PUSH
39649: EMPTY
39650: LIST
39651: LIST
39652: PUSH
39653: LD_INT 1
39655: PUSH
39656: LD_INT 1
39658: PUSH
39659: EMPTY
39660: LIST
39661: LIST
39662: PUSH
39663: LD_INT 0
39665: PUSH
39666: LD_INT 1
39668: PUSH
39669: EMPTY
39670: LIST
39671: LIST
39672: PUSH
39673: LD_INT 1
39675: NEG
39676: PUSH
39677: LD_INT 0
39679: PUSH
39680: EMPTY
39681: LIST
39682: LIST
39683: PUSH
39684: LD_INT 1
39686: NEG
39687: PUSH
39688: LD_INT 1
39690: NEG
39691: PUSH
39692: EMPTY
39693: LIST
39694: LIST
39695: PUSH
39696: LD_INT 1
39698: PUSH
39699: LD_INT 1
39701: NEG
39702: PUSH
39703: EMPTY
39704: LIST
39705: LIST
39706: PUSH
39707: LD_INT 1
39709: NEG
39710: PUSH
39711: LD_INT 1
39713: PUSH
39714: EMPTY
39715: LIST
39716: LIST
39717: PUSH
39718: EMPTY
39719: LIST
39720: LIST
39721: LIST
39722: LIST
39723: LIST
39724: LIST
39725: LIST
39726: LIST
39727: LIST
39728: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
39729: LD_ADDR_VAR 0 38
39733: PUSH
39734: LD_INT 0
39736: PUSH
39737: LD_INT 0
39739: PUSH
39740: EMPTY
39741: LIST
39742: LIST
39743: PUSH
39744: LD_INT 0
39746: PUSH
39747: LD_INT 1
39749: NEG
39750: PUSH
39751: EMPTY
39752: LIST
39753: LIST
39754: PUSH
39755: LD_INT 1
39757: PUSH
39758: LD_INT 0
39760: PUSH
39761: EMPTY
39762: LIST
39763: LIST
39764: PUSH
39765: LD_INT 1
39767: PUSH
39768: LD_INT 1
39770: PUSH
39771: EMPTY
39772: LIST
39773: LIST
39774: PUSH
39775: LD_INT 0
39777: PUSH
39778: LD_INT 1
39780: PUSH
39781: EMPTY
39782: LIST
39783: LIST
39784: PUSH
39785: LD_INT 1
39787: NEG
39788: PUSH
39789: LD_INT 0
39791: PUSH
39792: EMPTY
39793: LIST
39794: LIST
39795: PUSH
39796: LD_INT 1
39798: NEG
39799: PUSH
39800: LD_INT 1
39802: NEG
39803: PUSH
39804: EMPTY
39805: LIST
39806: LIST
39807: PUSH
39808: LD_INT 2
39810: PUSH
39811: LD_INT 1
39813: PUSH
39814: EMPTY
39815: LIST
39816: LIST
39817: PUSH
39818: LD_INT 2
39820: NEG
39821: PUSH
39822: LD_INT 1
39824: NEG
39825: PUSH
39826: EMPTY
39827: LIST
39828: LIST
39829: PUSH
39830: EMPTY
39831: LIST
39832: LIST
39833: LIST
39834: LIST
39835: LIST
39836: LIST
39837: LIST
39838: LIST
39839: LIST
39840: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
39841: LD_ADDR_VAR 0 39
39845: PUSH
39846: LD_INT 0
39848: PUSH
39849: LD_INT 0
39851: PUSH
39852: EMPTY
39853: LIST
39854: LIST
39855: PUSH
39856: LD_INT 0
39858: PUSH
39859: LD_INT 1
39861: NEG
39862: PUSH
39863: EMPTY
39864: LIST
39865: LIST
39866: PUSH
39867: LD_INT 1
39869: PUSH
39870: LD_INT 0
39872: PUSH
39873: EMPTY
39874: LIST
39875: LIST
39876: PUSH
39877: LD_INT 1
39879: PUSH
39880: LD_INT 1
39882: PUSH
39883: EMPTY
39884: LIST
39885: LIST
39886: PUSH
39887: LD_INT 0
39889: PUSH
39890: LD_INT 1
39892: PUSH
39893: EMPTY
39894: LIST
39895: LIST
39896: PUSH
39897: LD_INT 1
39899: NEG
39900: PUSH
39901: LD_INT 0
39903: PUSH
39904: EMPTY
39905: LIST
39906: LIST
39907: PUSH
39908: LD_INT 1
39910: NEG
39911: PUSH
39912: LD_INT 1
39914: NEG
39915: PUSH
39916: EMPTY
39917: LIST
39918: LIST
39919: PUSH
39920: LD_INT 1
39922: NEG
39923: PUSH
39924: LD_INT 2
39926: NEG
39927: PUSH
39928: EMPTY
39929: LIST
39930: LIST
39931: PUSH
39932: LD_INT 1
39934: PUSH
39935: LD_INT 2
39937: PUSH
39938: EMPTY
39939: LIST
39940: LIST
39941: PUSH
39942: EMPTY
39943: LIST
39944: LIST
39945: LIST
39946: LIST
39947: LIST
39948: LIST
39949: LIST
39950: LIST
39951: LIST
39952: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
39953: LD_ADDR_VAR 0 40
39957: PUSH
39958: LD_INT 0
39960: PUSH
39961: LD_INT 0
39963: PUSH
39964: EMPTY
39965: LIST
39966: LIST
39967: PUSH
39968: LD_INT 0
39970: PUSH
39971: LD_INT 1
39973: NEG
39974: PUSH
39975: EMPTY
39976: LIST
39977: LIST
39978: PUSH
39979: LD_INT 1
39981: PUSH
39982: LD_INT 0
39984: PUSH
39985: EMPTY
39986: LIST
39987: LIST
39988: PUSH
39989: LD_INT 1
39991: PUSH
39992: LD_INT 1
39994: PUSH
39995: EMPTY
39996: LIST
39997: LIST
39998: PUSH
39999: LD_INT 0
40001: PUSH
40002: LD_INT 1
40004: PUSH
40005: EMPTY
40006: LIST
40007: LIST
40008: PUSH
40009: LD_INT 1
40011: NEG
40012: PUSH
40013: LD_INT 0
40015: PUSH
40016: EMPTY
40017: LIST
40018: LIST
40019: PUSH
40020: LD_INT 1
40022: NEG
40023: PUSH
40024: LD_INT 1
40026: NEG
40027: PUSH
40028: EMPTY
40029: LIST
40030: LIST
40031: PUSH
40032: LD_INT 1
40034: PUSH
40035: LD_INT 1
40037: NEG
40038: PUSH
40039: EMPTY
40040: LIST
40041: LIST
40042: PUSH
40043: LD_INT 1
40045: NEG
40046: PUSH
40047: LD_INT 1
40049: PUSH
40050: EMPTY
40051: LIST
40052: LIST
40053: PUSH
40054: EMPTY
40055: LIST
40056: LIST
40057: LIST
40058: LIST
40059: LIST
40060: LIST
40061: LIST
40062: LIST
40063: LIST
40064: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
40065: LD_ADDR_VAR 0 41
40069: PUSH
40070: LD_INT 0
40072: PUSH
40073: LD_INT 0
40075: PUSH
40076: EMPTY
40077: LIST
40078: LIST
40079: PUSH
40080: LD_INT 0
40082: PUSH
40083: LD_INT 1
40085: NEG
40086: PUSH
40087: EMPTY
40088: LIST
40089: LIST
40090: PUSH
40091: LD_INT 1
40093: PUSH
40094: LD_INT 0
40096: PUSH
40097: EMPTY
40098: LIST
40099: LIST
40100: PUSH
40101: LD_INT 1
40103: PUSH
40104: LD_INT 1
40106: PUSH
40107: EMPTY
40108: LIST
40109: LIST
40110: PUSH
40111: LD_INT 0
40113: PUSH
40114: LD_INT 1
40116: PUSH
40117: EMPTY
40118: LIST
40119: LIST
40120: PUSH
40121: LD_INT 1
40123: NEG
40124: PUSH
40125: LD_INT 0
40127: PUSH
40128: EMPTY
40129: LIST
40130: LIST
40131: PUSH
40132: LD_INT 1
40134: NEG
40135: PUSH
40136: LD_INT 1
40138: NEG
40139: PUSH
40140: EMPTY
40141: LIST
40142: LIST
40143: PUSH
40144: LD_INT 1
40146: NEG
40147: PUSH
40148: LD_INT 2
40150: NEG
40151: PUSH
40152: EMPTY
40153: LIST
40154: LIST
40155: PUSH
40156: LD_INT 1
40158: PUSH
40159: LD_INT 1
40161: NEG
40162: PUSH
40163: EMPTY
40164: LIST
40165: LIST
40166: PUSH
40167: LD_INT 2
40169: PUSH
40170: LD_INT 0
40172: PUSH
40173: EMPTY
40174: LIST
40175: LIST
40176: PUSH
40177: LD_INT 2
40179: PUSH
40180: LD_INT 1
40182: PUSH
40183: EMPTY
40184: LIST
40185: LIST
40186: PUSH
40187: LD_INT 2
40189: PUSH
40190: LD_INT 2
40192: PUSH
40193: EMPTY
40194: LIST
40195: LIST
40196: PUSH
40197: LD_INT 1
40199: PUSH
40200: LD_INT 2
40202: PUSH
40203: EMPTY
40204: LIST
40205: LIST
40206: PUSH
40207: LD_INT 1
40209: NEG
40210: PUSH
40211: LD_INT 1
40213: PUSH
40214: EMPTY
40215: LIST
40216: LIST
40217: PUSH
40218: LD_INT 2
40220: NEG
40221: PUSH
40222: LD_INT 0
40224: PUSH
40225: EMPTY
40226: LIST
40227: LIST
40228: PUSH
40229: LD_INT 2
40231: NEG
40232: PUSH
40233: LD_INT 1
40235: NEG
40236: PUSH
40237: EMPTY
40238: LIST
40239: LIST
40240: PUSH
40241: LD_INT 2
40243: NEG
40244: PUSH
40245: LD_INT 2
40247: NEG
40248: PUSH
40249: EMPTY
40250: LIST
40251: LIST
40252: PUSH
40253: LD_INT 2
40255: NEG
40256: PUSH
40257: LD_INT 3
40259: NEG
40260: PUSH
40261: EMPTY
40262: LIST
40263: LIST
40264: PUSH
40265: LD_INT 2
40267: PUSH
40268: LD_INT 1
40270: NEG
40271: PUSH
40272: EMPTY
40273: LIST
40274: LIST
40275: PUSH
40276: LD_INT 3
40278: PUSH
40279: LD_INT 0
40281: PUSH
40282: EMPTY
40283: LIST
40284: LIST
40285: PUSH
40286: LD_INT 3
40288: PUSH
40289: LD_INT 1
40291: PUSH
40292: EMPTY
40293: LIST
40294: LIST
40295: PUSH
40296: LD_INT 3
40298: PUSH
40299: LD_INT 2
40301: PUSH
40302: EMPTY
40303: LIST
40304: LIST
40305: PUSH
40306: LD_INT 3
40308: PUSH
40309: LD_INT 3
40311: PUSH
40312: EMPTY
40313: LIST
40314: LIST
40315: PUSH
40316: LD_INT 2
40318: PUSH
40319: LD_INT 3
40321: PUSH
40322: EMPTY
40323: LIST
40324: LIST
40325: PUSH
40326: LD_INT 2
40328: NEG
40329: PUSH
40330: LD_INT 1
40332: PUSH
40333: EMPTY
40334: LIST
40335: LIST
40336: PUSH
40337: LD_INT 3
40339: NEG
40340: PUSH
40341: LD_INT 0
40343: PUSH
40344: EMPTY
40345: LIST
40346: LIST
40347: PUSH
40348: LD_INT 3
40350: NEG
40351: PUSH
40352: LD_INT 1
40354: NEG
40355: PUSH
40356: EMPTY
40357: LIST
40358: LIST
40359: PUSH
40360: LD_INT 3
40362: NEG
40363: PUSH
40364: LD_INT 2
40366: NEG
40367: PUSH
40368: EMPTY
40369: LIST
40370: LIST
40371: PUSH
40372: LD_INT 3
40374: NEG
40375: PUSH
40376: LD_INT 3
40378: NEG
40379: PUSH
40380: EMPTY
40381: LIST
40382: LIST
40383: PUSH
40384: EMPTY
40385: LIST
40386: LIST
40387: LIST
40388: LIST
40389: LIST
40390: LIST
40391: LIST
40392: LIST
40393: LIST
40394: LIST
40395: LIST
40396: LIST
40397: LIST
40398: LIST
40399: LIST
40400: LIST
40401: LIST
40402: LIST
40403: LIST
40404: LIST
40405: LIST
40406: LIST
40407: LIST
40408: LIST
40409: LIST
40410: LIST
40411: LIST
40412: LIST
40413: LIST
40414: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
40415: LD_ADDR_VAR 0 42
40419: PUSH
40420: LD_INT 0
40422: PUSH
40423: LD_INT 0
40425: PUSH
40426: EMPTY
40427: LIST
40428: LIST
40429: PUSH
40430: LD_INT 0
40432: PUSH
40433: LD_INT 1
40435: NEG
40436: PUSH
40437: EMPTY
40438: LIST
40439: LIST
40440: PUSH
40441: LD_INT 1
40443: PUSH
40444: LD_INT 0
40446: PUSH
40447: EMPTY
40448: LIST
40449: LIST
40450: PUSH
40451: LD_INT 1
40453: PUSH
40454: LD_INT 1
40456: PUSH
40457: EMPTY
40458: LIST
40459: LIST
40460: PUSH
40461: LD_INT 0
40463: PUSH
40464: LD_INT 1
40466: PUSH
40467: EMPTY
40468: LIST
40469: LIST
40470: PUSH
40471: LD_INT 1
40473: NEG
40474: PUSH
40475: LD_INT 0
40477: PUSH
40478: EMPTY
40479: LIST
40480: LIST
40481: PUSH
40482: LD_INT 1
40484: NEG
40485: PUSH
40486: LD_INT 1
40488: NEG
40489: PUSH
40490: EMPTY
40491: LIST
40492: LIST
40493: PUSH
40494: LD_INT 1
40496: NEG
40497: PUSH
40498: LD_INT 2
40500: NEG
40501: PUSH
40502: EMPTY
40503: LIST
40504: LIST
40505: PUSH
40506: LD_INT 0
40508: PUSH
40509: LD_INT 2
40511: NEG
40512: PUSH
40513: EMPTY
40514: LIST
40515: LIST
40516: PUSH
40517: LD_INT 1
40519: PUSH
40520: LD_INT 1
40522: NEG
40523: PUSH
40524: EMPTY
40525: LIST
40526: LIST
40527: PUSH
40528: LD_INT 2
40530: PUSH
40531: LD_INT 1
40533: PUSH
40534: EMPTY
40535: LIST
40536: LIST
40537: PUSH
40538: LD_INT 2
40540: PUSH
40541: LD_INT 2
40543: PUSH
40544: EMPTY
40545: LIST
40546: LIST
40547: PUSH
40548: LD_INT 1
40550: PUSH
40551: LD_INT 2
40553: PUSH
40554: EMPTY
40555: LIST
40556: LIST
40557: PUSH
40558: LD_INT 0
40560: PUSH
40561: LD_INT 2
40563: PUSH
40564: EMPTY
40565: LIST
40566: LIST
40567: PUSH
40568: LD_INT 1
40570: NEG
40571: PUSH
40572: LD_INT 1
40574: PUSH
40575: EMPTY
40576: LIST
40577: LIST
40578: PUSH
40579: LD_INT 2
40581: NEG
40582: PUSH
40583: LD_INT 1
40585: NEG
40586: PUSH
40587: EMPTY
40588: LIST
40589: LIST
40590: PUSH
40591: LD_INT 2
40593: NEG
40594: PUSH
40595: LD_INT 2
40597: NEG
40598: PUSH
40599: EMPTY
40600: LIST
40601: LIST
40602: PUSH
40603: LD_INT 2
40605: NEG
40606: PUSH
40607: LD_INT 3
40609: NEG
40610: PUSH
40611: EMPTY
40612: LIST
40613: LIST
40614: PUSH
40615: LD_INT 1
40617: NEG
40618: PUSH
40619: LD_INT 3
40621: NEG
40622: PUSH
40623: EMPTY
40624: LIST
40625: LIST
40626: PUSH
40627: LD_INT 0
40629: PUSH
40630: LD_INT 3
40632: NEG
40633: PUSH
40634: EMPTY
40635: LIST
40636: LIST
40637: PUSH
40638: LD_INT 1
40640: PUSH
40641: LD_INT 2
40643: NEG
40644: PUSH
40645: EMPTY
40646: LIST
40647: LIST
40648: PUSH
40649: LD_INT 3
40651: PUSH
40652: LD_INT 2
40654: PUSH
40655: EMPTY
40656: LIST
40657: LIST
40658: PUSH
40659: LD_INT 3
40661: PUSH
40662: LD_INT 3
40664: PUSH
40665: EMPTY
40666: LIST
40667: LIST
40668: PUSH
40669: LD_INT 2
40671: PUSH
40672: LD_INT 3
40674: PUSH
40675: EMPTY
40676: LIST
40677: LIST
40678: PUSH
40679: LD_INT 1
40681: PUSH
40682: LD_INT 3
40684: PUSH
40685: EMPTY
40686: LIST
40687: LIST
40688: PUSH
40689: LD_INT 0
40691: PUSH
40692: LD_INT 3
40694: PUSH
40695: EMPTY
40696: LIST
40697: LIST
40698: PUSH
40699: LD_INT 1
40701: NEG
40702: PUSH
40703: LD_INT 2
40705: PUSH
40706: EMPTY
40707: LIST
40708: LIST
40709: PUSH
40710: LD_INT 3
40712: NEG
40713: PUSH
40714: LD_INT 2
40716: NEG
40717: PUSH
40718: EMPTY
40719: LIST
40720: LIST
40721: PUSH
40722: LD_INT 3
40724: NEG
40725: PUSH
40726: LD_INT 3
40728: NEG
40729: PUSH
40730: EMPTY
40731: LIST
40732: LIST
40733: PUSH
40734: EMPTY
40735: LIST
40736: LIST
40737: LIST
40738: LIST
40739: LIST
40740: LIST
40741: LIST
40742: LIST
40743: LIST
40744: LIST
40745: LIST
40746: LIST
40747: LIST
40748: LIST
40749: LIST
40750: LIST
40751: LIST
40752: LIST
40753: LIST
40754: LIST
40755: LIST
40756: LIST
40757: LIST
40758: LIST
40759: LIST
40760: LIST
40761: LIST
40762: LIST
40763: LIST
40764: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
40765: LD_ADDR_VAR 0 43
40769: PUSH
40770: LD_INT 0
40772: PUSH
40773: LD_INT 0
40775: PUSH
40776: EMPTY
40777: LIST
40778: LIST
40779: PUSH
40780: LD_INT 0
40782: PUSH
40783: LD_INT 1
40785: NEG
40786: PUSH
40787: EMPTY
40788: LIST
40789: LIST
40790: PUSH
40791: LD_INT 1
40793: PUSH
40794: LD_INT 0
40796: PUSH
40797: EMPTY
40798: LIST
40799: LIST
40800: PUSH
40801: LD_INT 1
40803: PUSH
40804: LD_INT 1
40806: PUSH
40807: EMPTY
40808: LIST
40809: LIST
40810: PUSH
40811: LD_INT 0
40813: PUSH
40814: LD_INT 1
40816: PUSH
40817: EMPTY
40818: LIST
40819: LIST
40820: PUSH
40821: LD_INT 1
40823: NEG
40824: PUSH
40825: LD_INT 0
40827: PUSH
40828: EMPTY
40829: LIST
40830: LIST
40831: PUSH
40832: LD_INT 1
40834: NEG
40835: PUSH
40836: LD_INT 1
40838: NEG
40839: PUSH
40840: EMPTY
40841: LIST
40842: LIST
40843: PUSH
40844: LD_INT 1
40846: NEG
40847: PUSH
40848: LD_INT 2
40850: NEG
40851: PUSH
40852: EMPTY
40853: LIST
40854: LIST
40855: PUSH
40856: LD_INT 0
40858: PUSH
40859: LD_INT 2
40861: NEG
40862: PUSH
40863: EMPTY
40864: LIST
40865: LIST
40866: PUSH
40867: LD_INT 1
40869: PUSH
40870: LD_INT 1
40872: NEG
40873: PUSH
40874: EMPTY
40875: LIST
40876: LIST
40877: PUSH
40878: LD_INT 2
40880: PUSH
40881: LD_INT 0
40883: PUSH
40884: EMPTY
40885: LIST
40886: LIST
40887: PUSH
40888: LD_INT 2
40890: PUSH
40891: LD_INT 1
40893: PUSH
40894: EMPTY
40895: LIST
40896: LIST
40897: PUSH
40898: LD_INT 1
40900: PUSH
40901: LD_INT 2
40903: PUSH
40904: EMPTY
40905: LIST
40906: LIST
40907: PUSH
40908: LD_INT 0
40910: PUSH
40911: LD_INT 2
40913: PUSH
40914: EMPTY
40915: LIST
40916: LIST
40917: PUSH
40918: LD_INT 1
40920: NEG
40921: PUSH
40922: LD_INT 1
40924: PUSH
40925: EMPTY
40926: LIST
40927: LIST
40928: PUSH
40929: LD_INT 2
40931: NEG
40932: PUSH
40933: LD_INT 0
40935: PUSH
40936: EMPTY
40937: LIST
40938: LIST
40939: PUSH
40940: LD_INT 2
40942: NEG
40943: PUSH
40944: LD_INT 1
40946: NEG
40947: PUSH
40948: EMPTY
40949: LIST
40950: LIST
40951: PUSH
40952: LD_INT 1
40954: NEG
40955: PUSH
40956: LD_INT 3
40958: NEG
40959: PUSH
40960: EMPTY
40961: LIST
40962: LIST
40963: PUSH
40964: LD_INT 0
40966: PUSH
40967: LD_INT 3
40969: NEG
40970: PUSH
40971: EMPTY
40972: LIST
40973: LIST
40974: PUSH
40975: LD_INT 1
40977: PUSH
40978: LD_INT 2
40980: NEG
40981: PUSH
40982: EMPTY
40983: LIST
40984: LIST
40985: PUSH
40986: LD_INT 2
40988: PUSH
40989: LD_INT 1
40991: NEG
40992: PUSH
40993: EMPTY
40994: LIST
40995: LIST
40996: PUSH
40997: LD_INT 3
40999: PUSH
41000: LD_INT 0
41002: PUSH
41003: EMPTY
41004: LIST
41005: LIST
41006: PUSH
41007: LD_INT 3
41009: PUSH
41010: LD_INT 1
41012: PUSH
41013: EMPTY
41014: LIST
41015: LIST
41016: PUSH
41017: LD_INT 1
41019: PUSH
41020: LD_INT 3
41022: PUSH
41023: EMPTY
41024: LIST
41025: LIST
41026: PUSH
41027: LD_INT 0
41029: PUSH
41030: LD_INT 3
41032: PUSH
41033: EMPTY
41034: LIST
41035: LIST
41036: PUSH
41037: LD_INT 1
41039: NEG
41040: PUSH
41041: LD_INT 2
41043: PUSH
41044: EMPTY
41045: LIST
41046: LIST
41047: PUSH
41048: LD_INT 2
41050: NEG
41051: PUSH
41052: LD_INT 1
41054: PUSH
41055: EMPTY
41056: LIST
41057: LIST
41058: PUSH
41059: LD_INT 3
41061: NEG
41062: PUSH
41063: LD_INT 0
41065: PUSH
41066: EMPTY
41067: LIST
41068: LIST
41069: PUSH
41070: LD_INT 3
41072: NEG
41073: PUSH
41074: LD_INT 1
41076: NEG
41077: PUSH
41078: EMPTY
41079: LIST
41080: LIST
41081: PUSH
41082: EMPTY
41083: LIST
41084: LIST
41085: LIST
41086: LIST
41087: LIST
41088: LIST
41089: LIST
41090: LIST
41091: LIST
41092: LIST
41093: LIST
41094: LIST
41095: LIST
41096: LIST
41097: LIST
41098: LIST
41099: LIST
41100: LIST
41101: LIST
41102: LIST
41103: LIST
41104: LIST
41105: LIST
41106: LIST
41107: LIST
41108: LIST
41109: LIST
41110: LIST
41111: LIST
41112: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
41113: LD_ADDR_VAR 0 44
41117: PUSH
41118: LD_INT 0
41120: PUSH
41121: LD_INT 0
41123: PUSH
41124: EMPTY
41125: LIST
41126: LIST
41127: PUSH
41128: LD_INT 0
41130: PUSH
41131: LD_INT 1
41133: NEG
41134: PUSH
41135: EMPTY
41136: LIST
41137: LIST
41138: PUSH
41139: LD_INT 1
41141: PUSH
41142: LD_INT 0
41144: PUSH
41145: EMPTY
41146: LIST
41147: LIST
41148: PUSH
41149: LD_INT 1
41151: PUSH
41152: LD_INT 1
41154: PUSH
41155: EMPTY
41156: LIST
41157: LIST
41158: PUSH
41159: LD_INT 0
41161: PUSH
41162: LD_INT 1
41164: PUSH
41165: EMPTY
41166: LIST
41167: LIST
41168: PUSH
41169: LD_INT 1
41171: NEG
41172: PUSH
41173: LD_INT 0
41175: PUSH
41176: EMPTY
41177: LIST
41178: LIST
41179: PUSH
41180: LD_INT 1
41182: NEG
41183: PUSH
41184: LD_INT 1
41186: NEG
41187: PUSH
41188: EMPTY
41189: LIST
41190: LIST
41191: PUSH
41192: LD_INT 1
41194: NEG
41195: PUSH
41196: LD_INT 2
41198: NEG
41199: PUSH
41200: EMPTY
41201: LIST
41202: LIST
41203: PUSH
41204: LD_INT 1
41206: PUSH
41207: LD_INT 1
41209: NEG
41210: PUSH
41211: EMPTY
41212: LIST
41213: LIST
41214: PUSH
41215: LD_INT 2
41217: PUSH
41218: LD_INT 0
41220: PUSH
41221: EMPTY
41222: LIST
41223: LIST
41224: PUSH
41225: LD_INT 2
41227: PUSH
41228: LD_INT 1
41230: PUSH
41231: EMPTY
41232: LIST
41233: LIST
41234: PUSH
41235: LD_INT 2
41237: PUSH
41238: LD_INT 2
41240: PUSH
41241: EMPTY
41242: LIST
41243: LIST
41244: PUSH
41245: LD_INT 1
41247: PUSH
41248: LD_INT 2
41250: PUSH
41251: EMPTY
41252: LIST
41253: LIST
41254: PUSH
41255: LD_INT 1
41257: NEG
41258: PUSH
41259: LD_INT 1
41261: PUSH
41262: EMPTY
41263: LIST
41264: LIST
41265: PUSH
41266: LD_INT 2
41268: NEG
41269: PUSH
41270: LD_INT 0
41272: PUSH
41273: EMPTY
41274: LIST
41275: LIST
41276: PUSH
41277: LD_INT 2
41279: NEG
41280: PUSH
41281: LD_INT 1
41283: NEG
41284: PUSH
41285: EMPTY
41286: LIST
41287: LIST
41288: PUSH
41289: LD_INT 2
41291: NEG
41292: PUSH
41293: LD_INT 2
41295: NEG
41296: PUSH
41297: EMPTY
41298: LIST
41299: LIST
41300: PUSH
41301: LD_INT 2
41303: NEG
41304: PUSH
41305: LD_INT 3
41307: NEG
41308: PUSH
41309: EMPTY
41310: LIST
41311: LIST
41312: PUSH
41313: LD_INT 2
41315: PUSH
41316: LD_INT 1
41318: NEG
41319: PUSH
41320: EMPTY
41321: LIST
41322: LIST
41323: PUSH
41324: LD_INT 3
41326: PUSH
41327: LD_INT 0
41329: PUSH
41330: EMPTY
41331: LIST
41332: LIST
41333: PUSH
41334: LD_INT 3
41336: PUSH
41337: LD_INT 1
41339: PUSH
41340: EMPTY
41341: LIST
41342: LIST
41343: PUSH
41344: LD_INT 3
41346: PUSH
41347: LD_INT 2
41349: PUSH
41350: EMPTY
41351: LIST
41352: LIST
41353: PUSH
41354: LD_INT 3
41356: PUSH
41357: LD_INT 3
41359: PUSH
41360: EMPTY
41361: LIST
41362: LIST
41363: PUSH
41364: LD_INT 2
41366: PUSH
41367: LD_INT 3
41369: PUSH
41370: EMPTY
41371: LIST
41372: LIST
41373: PUSH
41374: LD_INT 2
41376: NEG
41377: PUSH
41378: LD_INT 1
41380: PUSH
41381: EMPTY
41382: LIST
41383: LIST
41384: PUSH
41385: LD_INT 3
41387: NEG
41388: PUSH
41389: LD_INT 0
41391: PUSH
41392: EMPTY
41393: LIST
41394: LIST
41395: PUSH
41396: LD_INT 3
41398: NEG
41399: PUSH
41400: LD_INT 1
41402: NEG
41403: PUSH
41404: EMPTY
41405: LIST
41406: LIST
41407: PUSH
41408: LD_INT 3
41410: NEG
41411: PUSH
41412: LD_INT 2
41414: NEG
41415: PUSH
41416: EMPTY
41417: LIST
41418: LIST
41419: PUSH
41420: LD_INT 3
41422: NEG
41423: PUSH
41424: LD_INT 3
41426: NEG
41427: PUSH
41428: EMPTY
41429: LIST
41430: LIST
41431: PUSH
41432: EMPTY
41433: LIST
41434: LIST
41435: LIST
41436: LIST
41437: LIST
41438: LIST
41439: LIST
41440: LIST
41441: LIST
41442: LIST
41443: LIST
41444: LIST
41445: LIST
41446: LIST
41447: LIST
41448: LIST
41449: LIST
41450: LIST
41451: LIST
41452: LIST
41453: LIST
41454: LIST
41455: LIST
41456: LIST
41457: LIST
41458: LIST
41459: LIST
41460: LIST
41461: LIST
41462: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
41463: LD_ADDR_VAR 0 45
41467: PUSH
41468: LD_INT 0
41470: PUSH
41471: LD_INT 0
41473: PUSH
41474: EMPTY
41475: LIST
41476: LIST
41477: PUSH
41478: LD_INT 0
41480: PUSH
41481: LD_INT 1
41483: NEG
41484: PUSH
41485: EMPTY
41486: LIST
41487: LIST
41488: PUSH
41489: LD_INT 1
41491: PUSH
41492: LD_INT 0
41494: PUSH
41495: EMPTY
41496: LIST
41497: LIST
41498: PUSH
41499: LD_INT 1
41501: PUSH
41502: LD_INT 1
41504: PUSH
41505: EMPTY
41506: LIST
41507: LIST
41508: PUSH
41509: LD_INT 0
41511: PUSH
41512: LD_INT 1
41514: PUSH
41515: EMPTY
41516: LIST
41517: LIST
41518: PUSH
41519: LD_INT 1
41521: NEG
41522: PUSH
41523: LD_INT 0
41525: PUSH
41526: EMPTY
41527: LIST
41528: LIST
41529: PUSH
41530: LD_INT 1
41532: NEG
41533: PUSH
41534: LD_INT 1
41536: NEG
41537: PUSH
41538: EMPTY
41539: LIST
41540: LIST
41541: PUSH
41542: LD_INT 1
41544: NEG
41545: PUSH
41546: LD_INT 2
41548: NEG
41549: PUSH
41550: EMPTY
41551: LIST
41552: LIST
41553: PUSH
41554: LD_INT 0
41556: PUSH
41557: LD_INT 2
41559: NEG
41560: PUSH
41561: EMPTY
41562: LIST
41563: LIST
41564: PUSH
41565: LD_INT 1
41567: PUSH
41568: LD_INT 1
41570: NEG
41571: PUSH
41572: EMPTY
41573: LIST
41574: LIST
41575: PUSH
41576: LD_INT 2
41578: PUSH
41579: LD_INT 1
41581: PUSH
41582: EMPTY
41583: LIST
41584: LIST
41585: PUSH
41586: LD_INT 2
41588: PUSH
41589: LD_INT 2
41591: PUSH
41592: EMPTY
41593: LIST
41594: LIST
41595: PUSH
41596: LD_INT 1
41598: PUSH
41599: LD_INT 2
41601: PUSH
41602: EMPTY
41603: LIST
41604: LIST
41605: PUSH
41606: LD_INT 0
41608: PUSH
41609: LD_INT 2
41611: PUSH
41612: EMPTY
41613: LIST
41614: LIST
41615: PUSH
41616: LD_INT 1
41618: NEG
41619: PUSH
41620: LD_INT 1
41622: PUSH
41623: EMPTY
41624: LIST
41625: LIST
41626: PUSH
41627: LD_INT 2
41629: NEG
41630: PUSH
41631: LD_INT 1
41633: NEG
41634: PUSH
41635: EMPTY
41636: LIST
41637: LIST
41638: PUSH
41639: LD_INT 2
41641: NEG
41642: PUSH
41643: LD_INT 2
41645: NEG
41646: PUSH
41647: EMPTY
41648: LIST
41649: LIST
41650: PUSH
41651: LD_INT 2
41653: NEG
41654: PUSH
41655: LD_INT 3
41657: NEG
41658: PUSH
41659: EMPTY
41660: LIST
41661: LIST
41662: PUSH
41663: LD_INT 1
41665: NEG
41666: PUSH
41667: LD_INT 3
41669: NEG
41670: PUSH
41671: EMPTY
41672: LIST
41673: LIST
41674: PUSH
41675: LD_INT 0
41677: PUSH
41678: LD_INT 3
41680: NEG
41681: PUSH
41682: EMPTY
41683: LIST
41684: LIST
41685: PUSH
41686: LD_INT 1
41688: PUSH
41689: LD_INT 2
41691: NEG
41692: PUSH
41693: EMPTY
41694: LIST
41695: LIST
41696: PUSH
41697: LD_INT 3
41699: PUSH
41700: LD_INT 2
41702: PUSH
41703: EMPTY
41704: LIST
41705: LIST
41706: PUSH
41707: LD_INT 3
41709: PUSH
41710: LD_INT 3
41712: PUSH
41713: EMPTY
41714: LIST
41715: LIST
41716: PUSH
41717: LD_INT 2
41719: PUSH
41720: LD_INT 3
41722: PUSH
41723: EMPTY
41724: LIST
41725: LIST
41726: PUSH
41727: LD_INT 1
41729: PUSH
41730: LD_INT 3
41732: PUSH
41733: EMPTY
41734: LIST
41735: LIST
41736: PUSH
41737: LD_INT 0
41739: PUSH
41740: LD_INT 3
41742: PUSH
41743: EMPTY
41744: LIST
41745: LIST
41746: PUSH
41747: LD_INT 1
41749: NEG
41750: PUSH
41751: LD_INT 2
41753: PUSH
41754: EMPTY
41755: LIST
41756: LIST
41757: PUSH
41758: LD_INT 3
41760: NEG
41761: PUSH
41762: LD_INT 2
41764: NEG
41765: PUSH
41766: EMPTY
41767: LIST
41768: LIST
41769: PUSH
41770: LD_INT 3
41772: NEG
41773: PUSH
41774: LD_INT 3
41776: NEG
41777: PUSH
41778: EMPTY
41779: LIST
41780: LIST
41781: PUSH
41782: EMPTY
41783: LIST
41784: LIST
41785: LIST
41786: LIST
41787: LIST
41788: LIST
41789: LIST
41790: LIST
41791: LIST
41792: LIST
41793: LIST
41794: LIST
41795: LIST
41796: LIST
41797: LIST
41798: LIST
41799: LIST
41800: LIST
41801: LIST
41802: LIST
41803: LIST
41804: LIST
41805: LIST
41806: LIST
41807: LIST
41808: LIST
41809: LIST
41810: LIST
41811: LIST
41812: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
41813: LD_ADDR_VAR 0 46
41817: PUSH
41818: LD_INT 0
41820: PUSH
41821: LD_INT 0
41823: PUSH
41824: EMPTY
41825: LIST
41826: LIST
41827: PUSH
41828: LD_INT 0
41830: PUSH
41831: LD_INT 1
41833: NEG
41834: PUSH
41835: EMPTY
41836: LIST
41837: LIST
41838: PUSH
41839: LD_INT 1
41841: PUSH
41842: LD_INT 0
41844: PUSH
41845: EMPTY
41846: LIST
41847: LIST
41848: PUSH
41849: LD_INT 1
41851: PUSH
41852: LD_INT 1
41854: PUSH
41855: EMPTY
41856: LIST
41857: LIST
41858: PUSH
41859: LD_INT 0
41861: PUSH
41862: LD_INT 1
41864: PUSH
41865: EMPTY
41866: LIST
41867: LIST
41868: PUSH
41869: LD_INT 1
41871: NEG
41872: PUSH
41873: LD_INT 0
41875: PUSH
41876: EMPTY
41877: LIST
41878: LIST
41879: PUSH
41880: LD_INT 1
41882: NEG
41883: PUSH
41884: LD_INT 1
41886: NEG
41887: PUSH
41888: EMPTY
41889: LIST
41890: LIST
41891: PUSH
41892: LD_INT 1
41894: NEG
41895: PUSH
41896: LD_INT 2
41898: NEG
41899: PUSH
41900: EMPTY
41901: LIST
41902: LIST
41903: PUSH
41904: LD_INT 0
41906: PUSH
41907: LD_INT 2
41909: NEG
41910: PUSH
41911: EMPTY
41912: LIST
41913: LIST
41914: PUSH
41915: LD_INT 1
41917: PUSH
41918: LD_INT 1
41920: NEG
41921: PUSH
41922: EMPTY
41923: LIST
41924: LIST
41925: PUSH
41926: LD_INT 2
41928: PUSH
41929: LD_INT 0
41931: PUSH
41932: EMPTY
41933: LIST
41934: LIST
41935: PUSH
41936: LD_INT 2
41938: PUSH
41939: LD_INT 1
41941: PUSH
41942: EMPTY
41943: LIST
41944: LIST
41945: PUSH
41946: LD_INT 1
41948: PUSH
41949: LD_INT 2
41951: PUSH
41952: EMPTY
41953: LIST
41954: LIST
41955: PUSH
41956: LD_INT 0
41958: PUSH
41959: LD_INT 2
41961: PUSH
41962: EMPTY
41963: LIST
41964: LIST
41965: PUSH
41966: LD_INT 1
41968: NEG
41969: PUSH
41970: LD_INT 1
41972: PUSH
41973: EMPTY
41974: LIST
41975: LIST
41976: PUSH
41977: LD_INT 2
41979: NEG
41980: PUSH
41981: LD_INT 0
41983: PUSH
41984: EMPTY
41985: LIST
41986: LIST
41987: PUSH
41988: LD_INT 2
41990: NEG
41991: PUSH
41992: LD_INT 1
41994: NEG
41995: PUSH
41996: EMPTY
41997: LIST
41998: LIST
41999: PUSH
42000: LD_INT 1
42002: NEG
42003: PUSH
42004: LD_INT 3
42006: NEG
42007: PUSH
42008: EMPTY
42009: LIST
42010: LIST
42011: PUSH
42012: LD_INT 0
42014: PUSH
42015: LD_INT 3
42017: NEG
42018: PUSH
42019: EMPTY
42020: LIST
42021: LIST
42022: PUSH
42023: LD_INT 1
42025: PUSH
42026: LD_INT 2
42028: NEG
42029: PUSH
42030: EMPTY
42031: LIST
42032: LIST
42033: PUSH
42034: LD_INT 2
42036: PUSH
42037: LD_INT 1
42039: NEG
42040: PUSH
42041: EMPTY
42042: LIST
42043: LIST
42044: PUSH
42045: LD_INT 3
42047: PUSH
42048: LD_INT 0
42050: PUSH
42051: EMPTY
42052: LIST
42053: LIST
42054: PUSH
42055: LD_INT 3
42057: PUSH
42058: LD_INT 1
42060: PUSH
42061: EMPTY
42062: LIST
42063: LIST
42064: PUSH
42065: LD_INT 1
42067: PUSH
42068: LD_INT 3
42070: PUSH
42071: EMPTY
42072: LIST
42073: LIST
42074: PUSH
42075: LD_INT 0
42077: PUSH
42078: LD_INT 3
42080: PUSH
42081: EMPTY
42082: LIST
42083: LIST
42084: PUSH
42085: LD_INT 1
42087: NEG
42088: PUSH
42089: LD_INT 2
42091: PUSH
42092: EMPTY
42093: LIST
42094: LIST
42095: PUSH
42096: LD_INT 2
42098: NEG
42099: PUSH
42100: LD_INT 1
42102: PUSH
42103: EMPTY
42104: LIST
42105: LIST
42106: PUSH
42107: LD_INT 3
42109: NEG
42110: PUSH
42111: LD_INT 0
42113: PUSH
42114: EMPTY
42115: LIST
42116: LIST
42117: PUSH
42118: LD_INT 3
42120: NEG
42121: PUSH
42122: LD_INT 1
42124: NEG
42125: PUSH
42126: EMPTY
42127: LIST
42128: LIST
42129: PUSH
42130: EMPTY
42131: LIST
42132: LIST
42133: LIST
42134: LIST
42135: LIST
42136: LIST
42137: LIST
42138: LIST
42139: LIST
42140: LIST
42141: LIST
42142: LIST
42143: LIST
42144: LIST
42145: LIST
42146: LIST
42147: LIST
42148: LIST
42149: LIST
42150: LIST
42151: LIST
42152: LIST
42153: LIST
42154: LIST
42155: LIST
42156: LIST
42157: LIST
42158: LIST
42159: LIST
42160: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
42161: LD_ADDR_VAR 0 47
42165: PUSH
42166: LD_INT 0
42168: PUSH
42169: LD_INT 0
42171: PUSH
42172: EMPTY
42173: LIST
42174: LIST
42175: PUSH
42176: LD_INT 0
42178: PUSH
42179: LD_INT 1
42181: NEG
42182: PUSH
42183: EMPTY
42184: LIST
42185: LIST
42186: PUSH
42187: LD_INT 1
42189: PUSH
42190: LD_INT 0
42192: PUSH
42193: EMPTY
42194: LIST
42195: LIST
42196: PUSH
42197: LD_INT 1
42199: PUSH
42200: LD_INT 1
42202: PUSH
42203: EMPTY
42204: LIST
42205: LIST
42206: PUSH
42207: LD_INT 0
42209: PUSH
42210: LD_INT 1
42212: PUSH
42213: EMPTY
42214: LIST
42215: LIST
42216: PUSH
42217: LD_INT 1
42219: NEG
42220: PUSH
42221: LD_INT 0
42223: PUSH
42224: EMPTY
42225: LIST
42226: LIST
42227: PUSH
42228: LD_INT 1
42230: NEG
42231: PUSH
42232: LD_INT 1
42234: NEG
42235: PUSH
42236: EMPTY
42237: LIST
42238: LIST
42239: PUSH
42240: LD_INT 1
42242: NEG
42243: PUSH
42244: LD_INT 2
42246: NEG
42247: PUSH
42248: EMPTY
42249: LIST
42250: LIST
42251: PUSH
42252: LD_INT 0
42254: PUSH
42255: LD_INT 2
42257: NEG
42258: PUSH
42259: EMPTY
42260: LIST
42261: LIST
42262: PUSH
42263: LD_INT 1
42265: PUSH
42266: LD_INT 1
42268: NEG
42269: PUSH
42270: EMPTY
42271: LIST
42272: LIST
42273: PUSH
42274: LD_INT 2
42276: NEG
42277: PUSH
42278: LD_INT 1
42280: NEG
42281: PUSH
42282: EMPTY
42283: LIST
42284: LIST
42285: PUSH
42286: LD_INT 2
42288: NEG
42289: PUSH
42290: LD_INT 2
42292: NEG
42293: PUSH
42294: EMPTY
42295: LIST
42296: LIST
42297: PUSH
42298: EMPTY
42299: LIST
42300: LIST
42301: LIST
42302: LIST
42303: LIST
42304: LIST
42305: LIST
42306: LIST
42307: LIST
42308: LIST
42309: LIST
42310: LIST
42311: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
42312: LD_ADDR_VAR 0 48
42316: PUSH
42317: LD_INT 0
42319: PUSH
42320: LD_INT 0
42322: PUSH
42323: EMPTY
42324: LIST
42325: LIST
42326: PUSH
42327: LD_INT 0
42329: PUSH
42330: LD_INT 1
42332: NEG
42333: PUSH
42334: EMPTY
42335: LIST
42336: LIST
42337: PUSH
42338: LD_INT 1
42340: PUSH
42341: LD_INT 0
42343: PUSH
42344: EMPTY
42345: LIST
42346: LIST
42347: PUSH
42348: LD_INT 1
42350: PUSH
42351: LD_INT 1
42353: PUSH
42354: EMPTY
42355: LIST
42356: LIST
42357: PUSH
42358: LD_INT 0
42360: PUSH
42361: LD_INT 1
42363: PUSH
42364: EMPTY
42365: LIST
42366: LIST
42367: PUSH
42368: LD_INT 1
42370: NEG
42371: PUSH
42372: LD_INT 0
42374: PUSH
42375: EMPTY
42376: LIST
42377: LIST
42378: PUSH
42379: LD_INT 1
42381: NEG
42382: PUSH
42383: LD_INT 1
42385: NEG
42386: PUSH
42387: EMPTY
42388: LIST
42389: LIST
42390: PUSH
42391: LD_INT 1
42393: NEG
42394: PUSH
42395: LD_INT 2
42397: NEG
42398: PUSH
42399: EMPTY
42400: LIST
42401: LIST
42402: PUSH
42403: LD_INT 0
42405: PUSH
42406: LD_INT 2
42408: NEG
42409: PUSH
42410: EMPTY
42411: LIST
42412: LIST
42413: PUSH
42414: LD_INT 1
42416: PUSH
42417: LD_INT 1
42419: NEG
42420: PUSH
42421: EMPTY
42422: LIST
42423: LIST
42424: PUSH
42425: LD_INT 2
42427: PUSH
42428: LD_INT 0
42430: PUSH
42431: EMPTY
42432: LIST
42433: LIST
42434: PUSH
42435: LD_INT 2
42437: PUSH
42438: LD_INT 1
42440: PUSH
42441: EMPTY
42442: LIST
42443: LIST
42444: PUSH
42445: EMPTY
42446: LIST
42447: LIST
42448: LIST
42449: LIST
42450: LIST
42451: LIST
42452: LIST
42453: LIST
42454: LIST
42455: LIST
42456: LIST
42457: LIST
42458: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
42459: LD_ADDR_VAR 0 49
42463: PUSH
42464: LD_INT 0
42466: PUSH
42467: LD_INT 0
42469: PUSH
42470: EMPTY
42471: LIST
42472: LIST
42473: PUSH
42474: LD_INT 0
42476: PUSH
42477: LD_INT 1
42479: NEG
42480: PUSH
42481: EMPTY
42482: LIST
42483: LIST
42484: PUSH
42485: LD_INT 1
42487: PUSH
42488: LD_INT 0
42490: PUSH
42491: EMPTY
42492: LIST
42493: LIST
42494: PUSH
42495: LD_INT 1
42497: PUSH
42498: LD_INT 1
42500: PUSH
42501: EMPTY
42502: LIST
42503: LIST
42504: PUSH
42505: LD_INT 0
42507: PUSH
42508: LD_INT 1
42510: PUSH
42511: EMPTY
42512: LIST
42513: LIST
42514: PUSH
42515: LD_INT 1
42517: NEG
42518: PUSH
42519: LD_INT 0
42521: PUSH
42522: EMPTY
42523: LIST
42524: LIST
42525: PUSH
42526: LD_INT 1
42528: NEG
42529: PUSH
42530: LD_INT 1
42532: NEG
42533: PUSH
42534: EMPTY
42535: LIST
42536: LIST
42537: PUSH
42538: LD_INT 1
42540: PUSH
42541: LD_INT 1
42543: NEG
42544: PUSH
42545: EMPTY
42546: LIST
42547: LIST
42548: PUSH
42549: LD_INT 2
42551: PUSH
42552: LD_INT 0
42554: PUSH
42555: EMPTY
42556: LIST
42557: LIST
42558: PUSH
42559: LD_INT 2
42561: PUSH
42562: LD_INT 1
42564: PUSH
42565: EMPTY
42566: LIST
42567: LIST
42568: PUSH
42569: LD_INT 2
42571: PUSH
42572: LD_INT 2
42574: PUSH
42575: EMPTY
42576: LIST
42577: LIST
42578: PUSH
42579: LD_INT 1
42581: PUSH
42582: LD_INT 2
42584: PUSH
42585: EMPTY
42586: LIST
42587: LIST
42588: PUSH
42589: EMPTY
42590: LIST
42591: LIST
42592: LIST
42593: LIST
42594: LIST
42595: LIST
42596: LIST
42597: LIST
42598: LIST
42599: LIST
42600: LIST
42601: LIST
42602: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
42603: LD_ADDR_VAR 0 50
42607: PUSH
42608: LD_INT 0
42610: PUSH
42611: LD_INT 0
42613: PUSH
42614: EMPTY
42615: LIST
42616: LIST
42617: PUSH
42618: LD_INT 0
42620: PUSH
42621: LD_INT 1
42623: NEG
42624: PUSH
42625: EMPTY
42626: LIST
42627: LIST
42628: PUSH
42629: LD_INT 1
42631: PUSH
42632: LD_INT 0
42634: PUSH
42635: EMPTY
42636: LIST
42637: LIST
42638: PUSH
42639: LD_INT 1
42641: PUSH
42642: LD_INT 1
42644: PUSH
42645: EMPTY
42646: LIST
42647: LIST
42648: PUSH
42649: LD_INT 0
42651: PUSH
42652: LD_INT 1
42654: PUSH
42655: EMPTY
42656: LIST
42657: LIST
42658: PUSH
42659: LD_INT 1
42661: NEG
42662: PUSH
42663: LD_INT 0
42665: PUSH
42666: EMPTY
42667: LIST
42668: LIST
42669: PUSH
42670: LD_INT 1
42672: NEG
42673: PUSH
42674: LD_INT 1
42676: NEG
42677: PUSH
42678: EMPTY
42679: LIST
42680: LIST
42681: PUSH
42682: LD_INT 2
42684: PUSH
42685: LD_INT 1
42687: PUSH
42688: EMPTY
42689: LIST
42690: LIST
42691: PUSH
42692: LD_INT 2
42694: PUSH
42695: LD_INT 2
42697: PUSH
42698: EMPTY
42699: LIST
42700: LIST
42701: PUSH
42702: LD_INT 1
42704: PUSH
42705: LD_INT 2
42707: PUSH
42708: EMPTY
42709: LIST
42710: LIST
42711: PUSH
42712: LD_INT 0
42714: PUSH
42715: LD_INT 2
42717: PUSH
42718: EMPTY
42719: LIST
42720: LIST
42721: PUSH
42722: LD_INT 1
42724: NEG
42725: PUSH
42726: LD_INT 1
42728: PUSH
42729: EMPTY
42730: LIST
42731: LIST
42732: PUSH
42733: EMPTY
42734: LIST
42735: LIST
42736: LIST
42737: LIST
42738: LIST
42739: LIST
42740: LIST
42741: LIST
42742: LIST
42743: LIST
42744: LIST
42745: LIST
42746: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
42747: LD_ADDR_VAR 0 51
42751: PUSH
42752: LD_INT 0
42754: PUSH
42755: LD_INT 0
42757: PUSH
42758: EMPTY
42759: LIST
42760: LIST
42761: PUSH
42762: LD_INT 0
42764: PUSH
42765: LD_INT 1
42767: NEG
42768: PUSH
42769: EMPTY
42770: LIST
42771: LIST
42772: PUSH
42773: LD_INT 1
42775: PUSH
42776: LD_INT 0
42778: PUSH
42779: EMPTY
42780: LIST
42781: LIST
42782: PUSH
42783: LD_INT 1
42785: PUSH
42786: LD_INT 1
42788: PUSH
42789: EMPTY
42790: LIST
42791: LIST
42792: PUSH
42793: LD_INT 0
42795: PUSH
42796: LD_INT 1
42798: PUSH
42799: EMPTY
42800: LIST
42801: LIST
42802: PUSH
42803: LD_INT 1
42805: NEG
42806: PUSH
42807: LD_INT 0
42809: PUSH
42810: EMPTY
42811: LIST
42812: LIST
42813: PUSH
42814: LD_INT 1
42816: NEG
42817: PUSH
42818: LD_INT 1
42820: NEG
42821: PUSH
42822: EMPTY
42823: LIST
42824: LIST
42825: PUSH
42826: LD_INT 1
42828: PUSH
42829: LD_INT 2
42831: PUSH
42832: EMPTY
42833: LIST
42834: LIST
42835: PUSH
42836: LD_INT 0
42838: PUSH
42839: LD_INT 2
42841: PUSH
42842: EMPTY
42843: LIST
42844: LIST
42845: PUSH
42846: LD_INT 1
42848: NEG
42849: PUSH
42850: LD_INT 1
42852: PUSH
42853: EMPTY
42854: LIST
42855: LIST
42856: PUSH
42857: LD_INT 2
42859: NEG
42860: PUSH
42861: LD_INT 0
42863: PUSH
42864: EMPTY
42865: LIST
42866: LIST
42867: PUSH
42868: LD_INT 2
42870: NEG
42871: PUSH
42872: LD_INT 1
42874: NEG
42875: PUSH
42876: EMPTY
42877: LIST
42878: LIST
42879: PUSH
42880: EMPTY
42881: LIST
42882: LIST
42883: LIST
42884: LIST
42885: LIST
42886: LIST
42887: LIST
42888: LIST
42889: LIST
42890: LIST
42891: LIST
42892: LIST
42893: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
42894: LD_ADDR_VAR 0 52
42898: PUSH
42899: LD_INT 0
42901: PUSH
42902: LD_INT 0
42904: PUSH
42905: EMPTY
42906: LIST
42907: LIST
42908: PUSH
42909: LD_INT 0
42911: PUSH
42912: LD_INT 1
42914: NEG
42915: PUSH
42916: EMPTY
42917: LIST
42918: LIST
42919: PUSH
42920: LD_INT 1
42922: PUSH
42923: LD_INT 0
42925: PUSH
42926: EMPTY
42927: LIST
42928: LIST
42929: PUSH
42930: LD_INT 1
42932: PUSH
42933: LD_INT 1
42935: PUSH
42936: EMPTY
42937: LIST
42938: LIST
42939: PUSH
42940: LD_INT 0
42942: PUSH
42943: LD_INT 1
42945: PUSH
42946: EMPTY
42947: LIST
42948: LIST
42949: PUSH
42950: LD_INT 1
42952: NEG
42953: PUSH
42954: LD_INT 0
42956: PUSH
42957: EMPTY
42958: LIST
42959: LIST
42960: PUSH
42961: LD_INT 1
42963: NEG
42964: PUSH
42965: LD_INT 1
42967: NEG
42968: PUSH
42969: EMPTY
42970: LIST
42971: LIST
42972: PUSH
42973: LD_INT 1
42975: NEG
42976: PUSH
42977: LD_INT 2
42979: NEG
42980: PUSH
42981: EMPTY
42982: LIST
42983: LIST
42984: PUSH
42985: LD_INT 1
42987: NEG
42988: PUSH
42989: LD_INT 1
42991: PUSH
42992: EMPTY
42993: LIST
42994: LIST
42995: PUSH
42996: LD_INT 2
42998: NEG
42999: PUSH
43000: LD_INT 0
43002: PUSH
43003: EMPTY
43004: LIST
43005: LIST
43006: PUSH
43007: LD_INT 2
43009: NEG
43010: PUSH
43011: LD_INT 1
43013: NEG
43014: PUSH
43015: EMPTY
43016: LIST
43017: LIST
43018: PUSH
43019: LD_INT 2
43021: NEG
43022: PUSH
43023: LD_INT 2
43025: NEG
43026: PUSH
43027: EMPTY
43028: LIST
43029: LIST
43030: PUSH
43031: EMPTY
43032: LIST
43033: LIST
43034: LIST
43035: LIST
43036: LIST
43037: LIST
43038: LIST
43039: LIST
43040: LIST
43041: LIST
43042: LIST
43043: LIST
43044: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
43045: LD_ADDR_VAR 0 53
43049: PUSH
43050: LD_INT 0
43052: PUSH
43053: LD_INT 0
43055: PUSH
43056: EMPTY
43057: LIST
43058: LIST
43059: PUSH
43060: LD_INT 0
43062: PUSH
43063: LD_INT 1
43065: NEG
43066: PUSH
43067: EMPTY
43068: LIST
43069: LIST
43070: PUSH
43071: LD_INT 1
43073: PUSH
43074: LD_INT 0
43076: PUSH
43077: EMPTY
43078: LIST
43079: LIST
43080: PUSH
43081: LD_INT 1
43083: PUSH
43084: LD_INT 1
43086: PUSH
43087: EMPTY
43088: LIST
43089: LIST
43090: PUSH
43091: LD_INT 0
43093: PUSH
43094: LD_INT 1
43096: PUSH
43097: EMPTY
43098: LIST
43099: LIST
43100: PUSH
43101: LD_INT 1
43103: NEG
43104: PUSH
43105: LD_INT 0
43107: PUSH
43108: EMPTY
43109: LIST
43110: LIST
43111: PUSH
43112: LD_INT 1
43114: NEG
43115: PUSH
43116: LD_INT 1
43118: NEG
43119: PUSH
43120: EMPTY
43121: LIST
43122: LIST
43123: PUSH
43124: LD_INT 1
43126: NEG
43127: PUSH
43128: LD_INT 2
43130: NEG
43131: PUSH
43132: EMPTY
43133: LIST
43134: LIST
43135: PUSH
43136: LD_INT 0
43138: PUSH
43139: LD_INT 2
43141: NEG
43142: PUSH
43143: EMPTY
43144: LIST
43145: LIST
43146: PUSH
43147: LD_INT 1
43149: PUSH
43150: LD_INT 1
43152: NEG
43153: PUSH
43154: EMPTY
43155: LIST
43156: LIST
43157: PUSH
43158: LD_INT 2
43160: PUSH
43161: LD_INT 0
43163: PUSH
43164: EMPTY
43165: LIST
43166: LIST
43167: PUSH
43168: LD_INT 2
43170: PUSH
43171: LD_INT 1
43173: PUSH
43174: EMPTY
43175: LIST
43176: LIST
43177: PUSH
43178: LD_INT 2
43180: PUSH
43181: LD_INT 2
43183: PUSH
43184: EMPTY
43185: LIST
43186: LIST
43187: PUSH
43188: LD_INT 1
43190: PUSH
43191: LD_INT 2
43193: PUSH
43194: EMPTY
43195: LIST
43196: LIST
43197: PUSH
43198: LD_INT 0
43200: PUSH
43201: LD_INT 2
43203: PUSH
43204: EMPTY
43205: LIST
43206: LIST
43207: PUSH
43208: LD_INT 1
43210: NEG
43211: PUSH
43212: LD_INT 1
43214: PUSH
43215: EMPTY
43216: LIST
43217: LIST
43218: PUSH
43219: LD_INT 2
43221: NEG
43222: PUSH
43223: LD_INT 0
43225: PUSH
43226: EMPTY
43227: LIST
43228: LIST
43229: PUSH
43230: LD_INT 2
43232: NEG
43233: PUSH
43234: LD_INT 1
43236: NEG
43237: PUSH
43238: EMPTY
43239: LIST
43240: LIST
43241: PUSH
43242: LD_INT 2
43244: NEG
43245: PUSH
43246: LD_INT 2
43248: NEG
43249: PUSH
43250: EMPTY
43251: LIST
43252: LIST
43253: PUSH
43254: EMPTY
43255: LIST
43256: LIST
43257: LIST
43258: LIST
43259: LIST
43260: LIST
43261: LIST
43262: LIST
43263: LIST
43264: LIST
43265: LIST
43266: LIST
43267: LIST
43268: LIST
43269: LIST
43270: LIST
43271: LIST
43272: LIST
43273: LIST
43274: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
43275: LD_ADDR_VAR 0 54
43279: PUSH
43280: LD_INT 0
43282: PUSH
43283: LD_INT 0
43285: PUSH
43286: EMPTY
43287: LIST
43288: LIST
43289: PUSH
43290: LD_INT 0
43292: PUSH
43293: LD_INT 1
43295: NEG
43296: PUSH
43297: EMPTY
43298: LIST
43299: LIST
43300: PUSH
43301: LD_INT 1
43303: PUSH
43304: LD_INT 0
43306: PUSH
43307: EMPTY
43308: LIST
43309: LIST
43310: PUSH
43311: LD_INT 1
43313: PUSH
43314: LD_INT 1
43316: PUSH
43317: EMPTY
43318: LIST
43319: LIST
43320: PUSH
43321: LD_INT 0
43323: PUSH
43324: LD_INT 1
43326: PUSH
43327: EMPTY
43328: LIST
43329: LIST
43330: PUSH
43331: LD_INT 1
43333: NEG
43334: PUSH
43335: LD_INT 0
43337: PUSH
43338: EMPTY
43339: LIST
43340: LIST
43341: PUSH
43342: LD_INT 1
43344: NEG
43345: PUSH
43346: LD_INT 1
43348: NEG
43349: PUSH
43350: EMPTY
43351: LIST
43352: LIST
43353: PUSH
43354: LD_INT 1
43356: NEG
43357: PUSH
43358: LD_INT 2
43360: NEG
43361: PUSH
43362: EMPTY
43363: LIST
43364: LIST
43365: PUSH
43366: LD_INT 0
43368: PUSH
43369: LD_INT 2
43371: NEG
43372: PUSH
43373: EMPTY
43374: LIST
43375: LIST
43376: PUSH
43377: LD_INT 1
43379: PUSH
43380: LD_INT 1
43382: NEG
43383: PUSH
43384: EMPTY
43385: LIST
43386: LIST
43387: PUSH
43388: LD_INT 2
43390: PUSH
43391: LD_INT 0
43393: PUSH
43394: EMPTY
43395: LIST
43396: LIST
43397: PUSH
43398: LD_INT 2
43400: PUSH
43401: LD_INT 1
43403: PUSH
43404: EMPTY
43405: LIST
43406: LIST
43407: PUSH
43408: LD_INT 2
43410: PUSH
43411: LD_INT 2
43413: PUSH
43414: EMPTY
43415: LIST
43416: LIST
43417: PUSH
43418: LD_INT 1
43420: PUSH
43421: LD_INT 2
43423: PUSH
43424: EMPTY
43425: LIST
43426: LIST
43427: PUSH
43428: LD_INT 0
43430: PUSH
43431: LD_INT 2
43433: PUSH
43434: EMPTY
43435: LIST
43436: LIST
43437: PUSH
43438: LD_INT 1
43440: NEG
43441: PUSH
43442: LD_INT 1
43444: PUSH
43445: EMPTY
43446: LIST
43447: LIST
43448: PUSH
43449: LD_INT 2
43451: NEG
43452: PUSH
43453: LD_INT 0
43455: PUSH
43456: EMPTY
43457: LIST
43458: LIST
43459: PUSH
43460: LD_INT 2
43462: NEG
43463: PUSH
43464: LD_INT 1
43466: NEG
43467: PUSH
43468: EMPTY
43469: LIST
43470: LIST
43471: PUSH
43472: LD_INT 2
43474: NEG
43475: PUSH
43476: LD_INT 2
43478: NEG
43479: PUSH
43480: EMPTY
43481: LIST
43482: LIST
43483: PUSH
43484: EMPTY
43485: LIST
43486: LIST
43487: LIST
43488: LIST
43489: LIST
43490: LIST
43491: LIST
43492: LIST
43493: LIST
43494: LIST
43495: LIST
43496: LIST
43497: LIST
43498: LIST
43499: LIST
43500: LIST
43501: LIST
43502: LIST
43503: LIST
43504: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
43505: LD_ADDR_VAR 0 55
43509: PUSH
43510: LD_INT 0
43512: PUSH
43513: LD_INT 0
43515: PUSH
43516: EMPTY
43517: LIST
43518: LIST
43519: PUSH
43520: LD_INT 0
43522: PUSH
43523: LD_INT 1
43525: NEG
43526: PUSH
43527: EMPTY
43528: LIST
43529: LIST
43530: PUSH
43531: LD_INT 1
43533: PUSH
43534: LD_INT 0
43536: PUSH
43537: EMPTY
43538: LIST
43539: LIST
43540: PUSH
43541: LD_INT 1
43543: PUSH
43544: LD_INT 1
43546: PUSH
43547: EMPTY
43548: LIST
43549: LIST
43550: PUSH
43551: LD_INT 0
43553: PUSH
43554: LD_INT 1
43556: PUSH
43557: EMPTY
43558: LIST
43559: LIST
43560: PUSH
43561: LD_INT 1
43563: NEG
43564: PUSH
43565: LD_INT 0
43567: PUSH
43568: EMPTY
43569: LIST
43570: LIST
43571: PUSH
43572: LD_INT 1
43574: NEG
43575: PUSH
43576: LD_INT 1
43578: NEG
43579: PUSH
43580: EMPTY
43581: LIST
43582: LIST
43583: PUSH
43584: LD_INT 1
43586: NEG
43587: PUSH
43588: LD_INT 2
43590: NEG
43591: PUSH
43592: EMPTY
43593: LIST
43594: LIST
43595: PUSH
43596: LD_INT 0
43598: PUSH
43599: LD_INT 2
43601: NEG
43602: PUSH
43603: EMPTY
43604: LIST
43605: LIST
43606: PUSH
43607: LD_INT 1
43609: PUSH
43610: LD_INT 1
43612: NEG
43613: PUSH
43614: EMPTY
43615: LIST
43616: LIST
43617: PUSH
43618: LD_INT 2
43620: PUSH
43621: LD_INT 0
43623: PUSH
43624: EMPTY
43625: LIST
43626: LIST
43627: PUSH
43628: LD_INT 2
43630: PUSH
43631: LD_INT 1
43633: PUSH
43634: EMPTY
43635: LIST
43636: LIST
43637: PUSH
43638: LD_INT 2
43640: PUSH
43641: LD_INT 2
43643: PUSH
43644: EMPTY
43645: LIST
43646: LIST
43647: PUSH
43648: LD_INT 1
43650: PUSH
43651: LD_INT 2
43653: PUSH
43654: EMPTY
43655: LIST
43656: LIST
43657: PUSH
43658: LD_INT 0
43660: PUSH
43661: LD_INT 2
43663: PUSH
43664: EMPTY
43665: LIST
43666: LIST
43667: PUSH
43668: LD_INT 1
43670: NEG
43671: PUSH
43672: LD_INT 1
43674: PUSH
43675: EMPTY
43676: LIST
43677: LIST
43678: PUSH
43679: LD_INT 2
43681: NEG
43682: PUSH
43683: LD_INT 0
43685: PUSH
43686: EMPTY
43687: LIST
43688: LIST
43689: PUSH
43690: LD_INT 2
43692: NEG
43693: PUSH
43694: LD_INT 1
43696: NEG
43697: PUSH
43698: EMPTY
43699: LIST
43700: LIST
43701: PUSH
43702: LD_INT 2
43704: NEG
43705: PUSH
43706: LD_INT 2
43708: NEG
43709: PUSH
43710: EMPTY
43711: LIST
43712: LIST
43713: PUSH
43714: EMPTY
43715: LIST
43716: LIST
43717: LIST
43718: LIST
43719: LIST
43720: LIST
43721: LIST
43722: LIST
43723: LIST
43724: LIST
43725: LIST
43726: LIST
43727: LIST
43728: LIST
43729: LIST
43730: LIST
43731: LIST
43732: LIST
43733: LIST
43734: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
43735: LD_ADDR_VAR 0 56
43739: PUSH
43740: LD_INT 0
43742: PUSH
43743: LD_INT 0
43745: PUSH
43746: EMPTY
43747: LIST
43748: LIST
43749: PUSH
43750: LD_INT 0
43752: PUSH
43753: LD_INT 1
43755: NEG
43756: PUSH
43757: EMPTY
43758: LIST
43759: LIST
43760: PUSH
43761: LD_INT 1
43763: PUSH
43764: LD_INT 0
43766: PUSH
43767: EMPTY
43768: LIST
43769: LIST
43770: PUSH
43771: LD_INT 1
43773: PUSH
43774: LD_INT 1
43776: PUSH
43777: EMPTY
43778: LIST
43779: LIST
43780: PUSH
43781: LD_INT 0
43783: PUSH
43784: LD_INT 1
43786: PUSH
43787: EMPTY
43788: LIST
43789: LIST
43790: PUSH
43791: LD_INT 1
43793: NEG
43794: PUSH
43795: LD_INT 0
43797: PUSH
43798: EMPTY
43799: LIST
43800: LIST
43801: PUSH
43802: LD_INT 1
43804: NEG
43805: PUSH
43806: LD_INT 1
43808: NEG
43809: PUSH
43810: EMPTY
43811: LIST
43812: LIST
43813: PUSH
43814: LD_INT 1
43816: NEG
43817: PUSH
43818: LD_INT 2
43820: NEG
43821: PUSH
43822: EMPTY
43823: LIST
43824: LIST
43825: PUSH
43826: LD_INT 0
43828: PUSH
43829: LD_INT 2
43831: NEG
43832: PUSH
43833: EMPTY
43834: LIST
43835: LIST
43836: PUSH
43837: LD_INT 1
43839: PUSH
43840: LD_INT 1
43842: NEG
43843: PUSH
43844: EMPTY
43845: LIST
43846: LIST
43847: PUSH
43848: LD_INT 2
43850: PUSH
43851: LD_INT 0
43853: PUSH
43854: EMPTY
43855: LIST
43856: LIST
43857: PUSH
43858: LD_INT 2
43860: PUSH
43861: LD_INT 1
43863: PUSH
43864: EMPTY
43865: LIST
43866: LIST
43867: PUSH
43868: LD_INT 2
43870: PUSH
43871: LD_INT 2
43873: PUSH
43874: EMPTY
43875: LIST
43876: LIST
43877: PUSH
43878: LD_INT 1
43880: PUSH
43881: LD_INT 2
43883: PUSH
43884: EMPTY
43885: LIST
43886: LIST
43887: PUSH
43888: LD_INT 0
43890: PUSH
43891: LD_INT 2
43893: PUSH
43894: EMPTY
43895: LIST
43896: LIST
43897: PUSH
43898: LD_INT 1
43900: NEG
43901: PUSH
43902: LD_INT 1
43904: PUSH
43905: EMPTY
43906: LIST
43907: LIST
43908: PUSH
43909: LD_INT 2
43911: NEG
43912: PUSH
43913: LD_INT 0
43915: PUSH
43916: EMPTY
43917: LIST
43918: LIST
43919: PUSH
43920: LD_INT 2
43922: NEG
43923: PUSH
43924: LD_INT 1
43926: NEG
43927: PUSH
43928: EMPTY
43929: LIST
43930: LIST
43931: PUSH
43932: LD_INT 2
43934: NEG
43935: PUSH
43936: LD_INT 2
43938: NEG
43939: PUSH
43940: EMPTY
43941: LIST
43942: LIST
43943: PUSH
43944: EMPTY
43945: LIST
43946: LIST
43947: LIST
43948: LIST
43949: LIST
43950: LIST
43951: LIST
43952: LIST
43953: LIST
43954: LIST
43955: LIST
43956: LIST
43957: LIST
43958: LIST
43959: LIST
43960: LIST
43961: LIST
43962: LIST
43963: LIST
43964: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
43965: LD_ADDR_VAR 0 57
43969: PUSH
43970: LD_INT 0
43972: PUSH
43973: LD_INT 0
43975: PUSH
43976: EMPTY
43977: LIST
43978: LIST
43979: PUSH
43980: LD_INT 0
43982: PUSH
43983: LD_INT 1
43985: NEG
43986: PUSH
43987: EMPTY
43988: LIST
43989: LIST
43990: PUSH
43991: LD_INT 1
43993: PUSH
43994: LD_INT 0
43996: PUSH
43997: EMPTY
43998: LIST
43999: LIST
44000: PUSH
44001: LD_INT 1
44003: PUSH
44004: LD_INT 1
44006: PUSH
44007: EMPTY
44008: LIST
44009: LIST
44010: PUSH
44011: LD_INT 0
44013: PUSH
44014: LD_INT 1
44016: PUSH
44017: EMPTY
44018: LIST
44019: LIST
44020: PUSH
44021: LD_INT 1
44023: NEG
44024: PUSH
44025: LD_INT 0
44027: PUSH
44028: EMPTY
44029: LIST
44030: LIST
44031: PUSH
44032: LD_INT 1
44034: NEG
44035: PUSH
44036: LD_INT 1
44038: NEG
44039: PUSH
44040: EMPTY
44041: LIST
44042: LIST
44043: PUSH
44044: LD_INT 1
44046: NEG
44047: PUSH
44048: LD_INT 2
44050: NEG
44051: PUSH
44052: EMPTY
44053: LIST
44054: LIST
44055: PUSH
44056: LD_INT 0
44058: PUSH
44059: LD_INT 2
44061: NEG
44062: PUSH
44063: EMPTY
44064: LIST
44065: LIST
44066: PUSH
44067: LD_INT 1
44069: PUSH
44070: LD_INT 1
44072: NEG
44073: PUSH
44074: EMPTY
44075: LIST
44076: LIST
44077: PUSH
44078: LD_INT 2
44080: PUSH
44081: LD_INT 0
44083: PUSH
44084: EMPTY
44085: LIST
44086: LIST
44087: PUSH
44088: LD_INT 2
44090: PUSH
44091: LD_INT 1
44093: PUSH
44094: EMPTY
44095: LIST
44096: LIST
44097: PUSH
44098: LD_INT 2
44100: PUSH
44101: LD_INT 2
44103: PUSH
44104: EMPTY
44105: LIST
44106: LIST
44107: PUSH
44108: LD_INT 1
44110: PUSH
44111: LD_INT 2
44113: PUSH
44114: EMPTY
44115: LIST
44116: LIST
44117: PUSH
44118: LD_INT 0
44120: PUSH
44121: LD_INT 2
44123: PUSH
44124: EMPTY
44125: LIST
44126: LIST
44127: PUSH
44128: LD_INT 1
44130: NEG
44131: PUSH
44132: LD_INT 1
44134: PUSH
44135: EMPTY
44136: LIST
44137: LIST
44138: PUSH
44139: LD_INT 2
44141: NEG
44142: PUSH
44143: LD_INT 0
44145: PUSH
44146: EMPTY
44147: LIST
44148: LIST
44149: PUSH
44150: LD_INT 2
44152: NEG
44153: PUSH
44154: LD_INT 1
44156: NEG
44157: PUSH
44158: EMPTY
44159: LIST
44160: LIST
44161: PUSH
44162: LD_INT 2
44164: NEG
44165: PUSH
44166: LD_INT 2
44168: NEG
44169: PUSH
44170: EMPTY
44171: LIST
44172: LIST
44173: PUSH
44174: EMPTY
44175: LIST
44176: LIST
44177: LIST
44178: LIST
44179: LIST
44180: LIST
44181: LIST
44182: LIST
44183: LIST
44184: LIST
44185: LIST
44186: LIST
44187: LIST
44188: LIST
44189: LIST
44190: LIST
44191: LIST
44192: LIST
44193: LIST
44194: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
44195: LD_ADDR_VAR 0 58
44199: PUSH
44200: LD_INT 0
44202: PUSH
44203: LD_INT 0
44205: PUSH
44206: EMPTY
44207: LIST
44208: LIST
44209: PUSH
44210: LD_INT 0
44212: PUSH
44213: LD_INT 1
44215: NEG
44216: PUSH
44217: EMPTY
44218: LIST
44219: LIST
44220: PUSH
44221: LD_INT 1
44223: PUSH
44224: LD_INT 0
44226: PUSH
44227: EMPTY
44228: LIST
44229: LIST
44230: PUSH
44231: LD_INT 1
44233: PUSH
44234: LD_INT 1
44236: PUSH
44237: EMPTY
44238: LIST
44239: LIST
44240: PUSH
44241: LD_INT 0
44243: PUSH
44244: LD_INT 1
44246: PUSH
44247: EMPTY
44248: LIST
44249: LIST
44250: PUSH
44251: LD_INT 1
44253: NEG
44254: PUSH
44255: LD_INT 0
44257: PUSH
44258: EMPTY
44259: LIST
44260: LIST
44261: PUSH
44262: LD_INT 1
44264: NEG
44265: PUSH
44266: LD_INT 1
44268: NEG
44269: PUSH
44270: EMPTY
44271: LIST
44272: LIST
44273: PUSH
44274: LD_INT 1
44276: NEG
44277: PUSH
44278: LD_INT 2
44280: NEG
44281: PUSH
44282: EMPTY
44283: LIST
44284: LIST
44285: PUSH
44286: LD_INT 0
44288: PUSH
44289: LD_INT 2
44291: NEG
44292: PUSH
44293: EMPTY
44294: LIST
44295: LIST
44296: PUSH
44297: LD_INT 1
44299: PUSH
44300: LD_INT 1
44302: NEG
44303: PUSH
44304: EMPTY
44305: LIST
44306: LIST
44307: PUSH
44308: LD_INT 2
44310: PUSH
44311: LD_INT 0
44313: PUSH
44314: EMPTY
44315: LIST
44316: LIST
44317: PUSH
44318: LD_INT 2
44320: PUSH
44321: LD_INT 1
44323: PUSH
44324: EMPTY
44325: LIST
44326: LIST
44327: PUSH
44328: LD_INT 2
44330: PUSH
44331: LD_INT 2
44333: PUSH
44334: EMPTY
44335: LIST
44336: LIST
44337: PUSH
44338: LD_INT 1
44340: PUSH
44341: LD_INT 2
44343: PUSH
44344: EMPTY
44345: LIST
44346: LIST
44347: PUSH
44348: LD_INT 0
44350: PUSH
44351: LD_INT 2
44353: PUSH
44354: EMPTY
44355: LIST
44356: LIST
44357: PUSH
44358: LD_INT 1
44360: NEG
44361: PUSH
44362: LD_INT 1
44364: PUSH
44365: EMPTY
44366: LIST
44367: LIST
44368: PUSH
44369: LD_INT 2
44371: NEG
44372: PUSH
44373: LD_INT 0
44375: PUSH
44376: EMPTY
44377: LIST
44378: LIST
44379: PUSH
44380: LD_INT 2
44382: NEG
44383: PUSH
44384: LD_INT 1
44386: NEG
44387: PUSH
44388: EMPTY
44389: LIST
44390: LIST
44391: PUSH
44392: LD_INT 2
44394: NEG
44395: PUSH
44396: LD_INT 2
44398: NEG
44399: PUSH
44400: EMPTY
44401: LIST
44402: LIST
44403: PUSH
44404: EMPTY
44405: LIST
44406: LIST
44407: LIST
44408: LIST
44409: LIST
44410: LIST
44411: LIST
44412: LIST
44413: LIST
44414: LIST
44415: LIST
44416: LIST
44417: LIST
44418: LIST
44419: LIST
44420: LIST
44421: LIST
44422: LIST
44423: LIST
44424: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
44425: LD_ADDR_VAR 0 59
44429: PUSH
44430: LD_INT 0
44432: PUSH
44433: LD_INT 0
44435: PUSH
44436: EMPTY
44437: LIST
44438: LIST
44439: PUSH
44440: LD_INT 0
44442: PUSH
44443: LD_INT 1
44445: NEG
44446: PUSH
44447: EMPTY
44448: LIST
44449: LIST
44450: PUSH
44451: LD_INT 1
44453: PUSH
44454: LD_INT 0
44456: PUSH
44457: EMPTY
44458: LIST
44459: LIST
44460: PUSH
44461: LD_INT 1
44463: PUSH
44464: LD_INT 1
44466: PUSH
44467: EMPTY
44468: LIST
44469: LIST
44470: PUSH
44471: LD_INT 0
44473: PUSH
44474: LD_INT 1
44476: PUSH
44477: EMPTY
44478: LIST
44479: LIST
44480: PUSH
44481: LD_INT 1
44483: NEG
44484: PUSH
44485: LD_INT 0
44487: PUSH
44488: EMPTY
44489: LIST
44490: LIST
44491: PUSH
44492: LD_INT 1
44494: NEG
44495: PUSH
44496: LD_INT 1
44498: NEG
44499: PUSH
44500: EMPTY
44501: LIST
44502: LIST
44503: PUSH
44504: EMPTY
44505: LIST
44506: LIST
44507: LIST
44508: LIST
44509: LIST
44510: LIST
44511: LIST
44512: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
44513: LD_ADDR_VAR 0 60
44517: PUSH
44518: LD_INT 0
44520: PUSH
44521: LD_INT 0
44523: PUSH
44524: EMPTY
44525: LIST
44526: LIST
44527: PUSH
44528: LD_INT 0
44530: PUSH
44531: LD_INT 1
44533: NEG
44534: PUSH
44535: EMPTY
44536: LIST
44537: LIST
44538: PUSH
44539: LD_INT 1
44541: PUSH
44542: LD_INT 0
44544: PUSH
44545: EMPTY
44546: LIST
44547: LIST
44548: PUSH
44549: LD_INT 1
44551: PUSH
44552: LD_INT 1
44554: PUSH
44555: EMPTY
44556: LIST
44557: LIST
44558: PUSH
44559: LD_INT 0
44561: PUSH
44562: LD_INT 1
44564: PUSH
44565: EMPTY
44566: LIST
44567: LIST
44568: PUSH
44569: LD_INT 1
44571: NEG
44572: PUSH
44573: LD_INT 0
44575: PUSH
44576: EMPTY
44577: LIST
44578: LIST
44579: PUSH
44580: LD_INT 1
44582: NEG
44583: PUSH
44584: LD_INT 1
44586: NEG
44587: PUSH
44588: EMPTY
44589: LIST
44590: LIST
44591: PUSH
44592: EMPTY
44593: LIST
44594: LIST
44595: LIST
44596: LIST
44597: LIST
44598: LIST
44599: LIST
44600: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
44601: LD_ADDR_VAR 0 61
44605: PUSH
44606: LD_INT 0
44608: PUSH
44609: LD_INT 0
44611: PUSH
44612: EMPTY
44613: LIST
44614: LIST
44615: PUSH
44616: LD_INT 0
44618: PUSH
44619: LD_INT 1
44621: NEG
44622: PUSH
44623: EMPTY
44624: LIST
44625: LIST
44626: PUSH
44627: LD_INT 1
44629: PUSH
44630: LD_INT 0
44632: PUSH
44633: EMPTY
44634: LIST
44635: LIST
44636: PUSH
44637: LD_INT 1
44639: PUSH
44640: LD_INT 1
44642: PUSH
44643: EMPTY
44644: LIST
44645: LIST
44646: PUSH
44647: LD_INT 0
44649: PUSH
44650: LD_INT 1
44652: PUSH
44653: EMPTY
44654: LIST
44655: LIST
44656: PUSH
44657: LD_INT 1
44659: NEG
44660: PUSH
44661: LD_INT 0
44663: PUSH
44664: EMPTY
44665: LIST
44666: LIST
44667: PUSH
44668: LD_INT 1
44670: NEG
44671: PUSH
44672: LD_INT 1
44674: NEG
44675: PUSH
44676: EMPTY
44677: LIST
44678: LIST
44679: PUSH
44680: EMPTY
44681: LIST
44682: LIST
44683: LIST
44684: LIST
44685: LIST
44686: LIST
44687: LIST
44688: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
44689: LD_ADDR_VAR 0 62
44693: PUSH
44694: LD_INT 0
44696: PUSH
44697: LD_INT 0
44699: PUSH
44700: EMPTY
44701: LIST
44702: LIST
44703: PUSH
44704: LD_INT 0
44706: PUSH
44707: LD_INT 1
44709: NEG
44710: PUSH
44711: EMPTY
44712: LIST
44713: LIST
44714: PUSH
44715: LD_INT 1
44717: PUSH
44718: LD_INT 0
44720: PUSH
44721: EMPTY
44722: LIST
44723: LIST
44724: PUSH
44725: LD_INT 1
44727: PUSH
44728: LD_INT 1
44730: PUSH
44731: EMPTY
44732: LIST
44733: LIST
44734: PUSH
44735: LD_INT 0
44737: PUSH
44738: LD_INT 1
44740: PUSH
44741: EMPTY
44742: LIST
44743: LIST
44744: PUSH
44745: LD_INT 1
44747: NEG
44748: PUSH
44749: LD_INT 0
44751: PUSH
44752: EMPTY
44753: LIST
44754: LIST
44755: PUSH
44756: LD_INT 1
44758: NEG
44759: PUSH
44760: LD_INT 1
44762: NEG
44763: PUSH
44764: EMPTY
44765: LIST
44766: LIST
44767: PUSH
44768: EMPTY
44769: LIST
44770: LIST
44771: LIST
44772: LIST
44773: LIST
44774: LIST
44775: LIST
44776: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
44777: LD_ADDR_VAR 0 63
44781: PUSH
44782: LD_INT 0
44784: PUSH
44785: LD_INT 0
44787: PUSH
44788: EMPTY
44789: LIST
44790: LIST
44791: PUSH
44792: LD_INT 0
44794: PUSH
44795: LD_INT 1
44797: NEG
44798: PUSH
44799: EMPTY
44800: LIST
44801: LIST
44802: PUSH
44803: LD_INT 1
44805: PUSH
44806: LD_INT 0
44808: PUSH
44809: EMPTY
44810: LIST
44811: LIST
44812: PUSH
44813: LD_INT 1
44815: PUSH
44816: LD_INT 1
44818: PUSH
44819: EMPTY
44820: LIST
44821: LIST
44822: PUSH
44823: LD_INT 0
44825: PUSH
44826: LD_INT 1
44828: PUSH
44829: EMPTY
44830: LIST
44831: LIST
44832: PUSH
44833: LD_INT 1
44835: NEG
44836: PUSH
44837: LD_INT 0
44839: PUSH
44840: EMPTY
44841: LIST
44842: LIST
44843: PUSH
44844: LD_INT 1
44846: NEG
44847: PUSH
44848: LD_INT 1
44850: NEG
44851: PUSH
44852: EMPTY
44853: LIST
44854: LIST
44855: PUSH
44856: EMPTY
44857: LIST
44858: LIST
44859: LIST
44860: LIST
44861: LIST
44862: LIST
44863: LIST
44864: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
44865: LD_ADDR_VAR 0 64
44869: PUSH
44870: LD_INT 0
44872: PUSH
44873: LD_INT 0
44875: PUSH
44876: EMPTY
44877: LIST
44878: LIST
44879: PUSH
44880: LD_INT 0
44882: PUSH
44883: LD_INT 1
44885: NEG
44886: PUSH
44887: EMPTY
44888: LIST
44889: LIST
44890: PUSH
44891: LD_INT 1
44893: PUSH
44894: LD_INT 0
44896: PUSH
44897: EMPTY
44898: LIST
44899: LIST
44900: PUSH
44901: LD_INT 1
44903: PUSH
44904: LD_INT 1
44906: PUSH
44907: EMPTY
44908: LIST
44909: LIST
44910: PUSH
44911: LD_INT 0
44913: PUSH
44914: LD_INT 1
44916: PUSH
44917: EMPTY
44918: LIST
44919: LIST
44920: PUSH
44921: LD_INT 1
44923: NEG
44924: PUSH
44925: LD_INT 0
44927: PUSH
44928: EMPTY
44929: LIST
44930: LIST
44931: PUSH
44932: LD_INT 1
44934: NEG
44935: PUSH
44936: LD_INT 1
44938: NEG
44939: PUSH
44940: EMPTY
44941: LIST
44942: LIST
44943: PUSH
44944: EMPTY
44945: LIST
44946: LIST
44947: LIST
44948: LIST
44949: LIST
44950: LIST
44951: LIST
44952: ST_TO_ADDR
// end ; 1 :
44953: GO 50850
44955: LD_INT 1
44957: DOUBLE
44958: EQUAL
44959: IFTRUE 44963
44961: GO 47586
44963: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
44964: LD_ADDR_VAR 0 11
44968: PUSH
44969: LD_INT 1
44971: NEG
44972: PUSH
44973: LD_INT 3
44975: NEG
44976: PUSH
44977: EMPTY
44978: LIST
44979: LIST
44980: PUSH
44981: LD_INT 0
44983: PUSH
44984: LD_INT 3
44986: NEG
44987: PUSH
44988: EMPTY
44989: LIST
44990: LIST
44991: PUSH
44992: LD_INT 1
44994: PUSH
44995: LD_INT 2
44997: NEG
44998: PUSH
44999: EMPTY
45000: LIST
45001: LIST
45002: PUSH
45003: EMPTY
45004: LIST
45005: LIST
45006: LIST
45007: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
45008: LD_ADDR_VAR 0 12
45012: PUSH
45013: LD_INT 2
45015: PUSH
45016: LD_INT 1
45018: NEG
45019: PUSH
45020: EMPTY
45021: LIST
45022: LIST
45023: PUSH
45024: LD_INT 3
45026: PUSH
45027: LD_INT 0
45029: PUSH
45030: EMPTY
45031: LIST
45032: LIST
45033: PUSH
45034: LD_INT 3
45036: PUSH
45037: LD_INT 1
45039: PUSH
45040: EMPTY
45041: LIST
45042: LIST
45043: PUSH
45044: EMPTY
45045: LIST
45046: LIST
45047: LIST
45048: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
45049: LD_ADDR_VAR 0 13
45053: PUSH
45054: LD_INT 3
45056: PUSH
45057: LD_INT 2
45059: PUSH
45060: EMPTY
45061: LIST
45062: LIST
45063: PUSH
45064: LD_INT 3
45066: PUSH
45067: LD_INT 3
45069: PUSH
45070: EMPTY
45071: LIST
45072: LIST
45073: PUSH
45074: LD_INT 2
45076: PUSH
45077: LD_INT 3
45079: PUSH
45080: EMPTY
45081: LIST
45082: LIST
45083: PUSH
45084: EMPTY
45085: LIST
45086: LIST
45087: LIST
45088: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
45089: LD_ADDR_VAR 0 14
45093: PUSH
45094: LD_INT 1
45096: PUSH
45097: LD_INT 3
45099: PUSH
45100: EMPTY
45101: LIST
45102: LIST
45103: PUSH
45104: LD_INT 0
45106: PUSH
45107: LD_INT 3
45109: PUSH
45110: EMPTY
45111: LIST
45112: LIST
45113: PUSH
45114: LD_INT 1
45116: NEG
45117: PUSH
45118: LD_INT 2
45120: PUSH
45121: EMPTY
45122: LIST
45123: LIST
45124: PUSH
45125: EMPTY
45126: LIST
45127: LIST
45128: LIST
45129: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
45130: LD_ADDR_VAR 0 15
45134: PUSH
45135: LD_INT 2
45137: NEG
45138: PUSH
45139: LD_INT 1
45141: PUSH
45142: EMPTY
45143: LIST
45144: LIST
45145: PUSH
45146: LD_INT 3
45148: NEG
45149: PUSH
45150: LD_INT 0
45152: PUSH
45153: EMPTY
45154: LIST
45155: LIST
45156: PUSH
45157: LD_INT 3
45159: NEG
45160: PUSH
45161: LD_INT 1
45163: NEG
45164: PUSH
45165: EMPTY
45166: LIST
45167: LIST
45168: PUSH
45169: EMPTY
45170: LIST
45171: LIST
45172: LIST
45173: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
45174: LD_ADDR_VAR 0 16
45178: PUSH
45179: LD_INT 2
45181: NEG
45182: PUSH
45183: LD_INT 3
45185: NEG
45186: PUSH
45187: EMPTY
45188: LIST
45189: LIST
45190: PUSH
45191: LD_INT 3
45193: NEG
45194: PUSH
45195: LD_INT 2
45197: NEG
45198: PUSH
45199: EMPTY
45200: LIST
45201: LIST
45202: PUSH
45203: LD_INT 3
45205: NEG
45206: PUSH
45207: LD_INT 3
45209: NEG
45210: PUSH
45211: EMPTY
45212: LIST
45213: LIST
45214: PUSH
45215: EMPTY
45216: LIST
45217: LIST
45218: LIST
45219: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
45220: LD_ADDR_VAR 0 17
45224: PUSH
45225: LD_INT 1
45227: NEG
45228: PUSH
45229: LD_INT 3
45231: NEG
45232: PUSH
45233: EMPTY
45234: LIST
45235: LIST
45236: PUSH
45237: LD_INT 0
45239: PUSH
45240: LD_INT 3
45242: NEG
45243: PUSH
45244: EMPTY
45245: LIST
45246: LIST
45247: PUSH
45248: LD_INT 1
45250: PUSH
45251: LD_INT 2
45253: NEG
45254: PUSH
45255: EMPTY
45256: LIST
45257: LIST
45258: PUSH
45259: EMPTY
45260: LIST
45261: LIST
45262: LIST
45263: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
45264: LD_ADDR_VAR 0 18
45268: PUSH
45269: LD_INT 2
45271: PUSH
45272: LD_INT 1
45274: NEG
45275: PUSH
45276: EMPTY
45277: LIST
45278: LIST
45279: PUSH
45280: LD_INT 3
45282: PUSH
45283: LD_INT 0
45285: PUSH
45286: EMPTY
45287: LIST
45288: LIST
45289: PUSH
45290: LD_INT 3
45292: PUSH
45293: LD_INT 1
45295: PUSH
45296: EMPTY
45297: LIST
45298: LIST
45299: PUSH
45300: EMPTY
45301: LIST
45302: LIST
45303: LIST
45304: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
45305: LD_ADDR_VAR 0 19
45309: PUSH
45310: LD_INT 3
45312: PUSH
45313: LD_INT 2
45315: PUSH
45316: EMPTY
45317: LIST
45318: LIST
45319: PUSH
45320: LD_INT 3
45322: PUSH
45323: LD_INT 3
45325: PUSH
45326: EMPTY
45327: LIST
45328: LIST
45329: PUSH
45330: LD_INT 2
45332: PUSH
45333: LD_INT 3
45335: PUSH
45336: EMPTY
45337: LIST
45338: LIST
45339: PUSH
45340: EMPTY
45341: LIST
45342: LIST
45343: LIST
45344: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
45345: LD_ADDR_VAR 0 20
45349: PUSH
45350: LD_INT 1
45352: PUSH
45353: LD_INT 3
45355: PUSH
45356: EMPTY
45357: LIST
45358: LIST
45359: PUSH
45360: LD_INT 0
45362: PUSH
45363: LD_INT 3
45365: PUSH
45366: EMPTY
45367: LIST
45368: LIST
45369: PUSH
45370: LD_INT 1
45372: NEG
45373: PUSH
45374: LD_INT 2
45376: PUSH
45377: EMPTY
45378: LIST
45379: LIST
45380: PUSH
45381: EMPTY
45382: LIST
45383: LIST
45384: LIST
45385: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
45386: LD_ADDR_VAR 0 21
45390: PUSH
45391: LD_INT 2
45393: NEG
45394: PUSH
45395: LD_INT 1
45397: PUSH
45398: EMPTY
45399: LIST
45400: LIST
45401: PUSH
45402: LD_INT 3
45404: NEG
45405: PUSH
45406: LD_INT 0
45408: PUSH
45409: EMPTY
45410: LIST
45411: LIST
45412: PUSH
45413: LD_INT 3
45415: NEG
45416: PUSH
45417: LD_INT 1
45419: NEG
45420: PUSH
45421: EMPTY
45422: LIST
45423: LIST
45424: PUSH
45425: EMPTY
45426: LIST
45427: LIST
45428: LIST
45429: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
45430: LD_ADDR_VAR 0 22
45434: PUSH
45435: LD_INT 2
45437: NEG
45438: PUSH
45439: LD_INT 3
45441: NEG
45442: PUSH
45443: EMPTY
45444: LIST
45445: LIST
45446: PUSH
45447: LD_INT 3
45449: NEG
45450: PUSH
45451: LD_INT 2
45453: NEG
45454: PUSH
45455: EMPTY
45456: LIST
45457: LIST
45458: PUSH
45459: LD_INT 3
45461: NEG
45462: PUSH
45463: LD_INT 3
45465: NEG
45466: PUSH
45467: EMPTY
45468: LIST
45469: LIST
45470: PUSH
45471: EMPTY
45472: LIST
45473: LIST
45474: LIST
45475: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
45476: LD_ADDR_VAR 0 23
45480: PUSH
45481: LD_INT 0
45483: PUSH
45484: LD_INT 3
45486: NEG
45487: PUSH
45488: EMPTY
45489: LIST
45490: LIST
45491: PUSH
45492: LD_INT 1
45494: NEG
45495: PUSH
45496: LD_INT 4
45498: NEG
45499: PUSH
45500: EMPTY
45501: LIST
45502: LIST
45503: PUSH
45504: LD_INT 1
45506: PUSH
45507: LD_INT 3
45509: NEG
45510: PUSH
45511: EMPTY
45512: LIST
45513: LIST
45514: PUSH
45515: EMPTY
45516: LIST
45517: LIST
45518: LIST
45519: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
45520: LD_ADDR_VAR 0 24
45524: PUSH
45525: LD_INT 3
45527: PUSH
45528: LD_INT 0
45530: PUSH
45531: EMPTY
45532: LIST
45533: LIST
45534: PUSH
45535: LD_INT 3
45537: PUSH
45538: LD_INT 1
45540: NEG
45541: PUSH
45542: EMPTY
45543: LIST
45544: LIST
45545: PUSH
45546: LD_INT 4
45548: PUSH
45549: LD_INT 1
45551: PUSH
45552: EMPTY
45553: LIST
45554: LIST
45555: PUSH
45556: EMPTY
45557: LIST
45558: LIST
45559: LIST
45560: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
45561: LD_ADDR_VAR 0 25
45565: PUSH
45566: LD_INT 3
45568: PUSH
45569: LD_INT 3
45571: PUSH
45572: EMPTY
45573: LIST
45574: LIST
45575: PUSH
45576: LD_INT 4
45578: PUSH
45579: LD_INT 3
45581: PUSH
45582: EMPTY
45583: LIST
45584: LIST
45585: PUSH
45586: LD_INT 3
45588: PUSH
45589: LD_INT 4
45591: PUSH
45592: EMPTY
45593: LIST
45594: LIST
45595: PUSH
45596: EMPTY
45597: LIST
45598: LIST
45599: LIST
45600: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
45601: LD_ADDR_VAR 0 26
45605: PUSH
45606: LD_INT 0
45608: PUSH
45609: LD_INT 3
45611: PUSH
45612: EMPTY
45613: LIST
45614: LIST
45615: PUSH
45616: LD_INT 1
45618: PUSH
45619: LD_INT 4
45621: PUSH
45622: EMPTY
45623: LIST
45624: LIST
45625: PUSH
45626: LD_INT 1
45628: NEG
45629: PUSH
45630: LD_INT 3
45632: PUSH
45633: EMPTY
45634: LIST
45635: LIST
45636: PUSH
45637: EMPTY
45638: LIST
45639: LIST
45640: LIST
45641: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
45642: LD_ADDR_VAR 0 27
45646: PUSH
45647: LD_INT 3
45649: NEG
45650: PUSH
45651: LD_INT 0
45653: PUSH
45654: EMPTY
45655: LIST
45656: LIST
45657: PUSH
45658: LD_INT 3
45660: NEG
45661: PUSH
45662: LD_INT 1
45664: PUSH
45665: EMPTY
45666: LIST
45667: LIST
45668: PUSH
45669: LD_INT 4
45671: NEG
45672: PUSH
45673: LD_INT 1
45675: NEG
45676: PUSH
45677: EMPTY
45678: LIST
45679: LIST
45680: PUSH
45681: EMPTY
45682: LIST
45683: LIST
45684: LIST
45685: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
45686: LD_ADDR_VAR 0 28
45690: PUSH
45691: LD_INT 3
45693: NEG
45694: PUSH
45695: LD_INT 3
45697: NEG
45698: PUSH
45699: EMPTY
45700: LIST
45701: LIST
45702: PUSH
45703: LD_INT 3
45705: NEG
45706: PUSH
45707: LD_INT 4
45709: NEG
45710: PUSH
45711: EMPTY
45712: LIST
45713: LIST
45714: PUSH
45715: LD_INT 4
45717: NEG
45718: PUSH
45719: LD_INT 3
45721: NEG
45722: PUSH
45723: EMPTY
45724: LIST
45725: LIST
45726: PUSH
45727: EMPTY
45728: LIST
45729: LIST
45730: LIST
45731: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
45732: LD_ADDR_VAR 0 29
45736: PUSH
45737: LD_INT 1
45739: NEG
45740: PUSH
45741: LD_INT 3
45743: NEG
45744: PUSH
45745: EMPTY
45746: LIST
45747: LIST
45748: PUSH
45749: LD_INT 0
45751: PUSH
45752: LD_INT 3
45754: NEG
45755: PUSH
45756: EMPTY
45757: LIST
45758: LIST
45759: PUSH
45760: LD_INT 1
45762: PUSH
45763: LD_INT 2
45765: NEG
45766: PUSH
45767: EMPTY
45768: LIST
45769: LIST
45770: PUSH
45771: LD_INT 1
45773: NEG
45774: PUSH
45775: LD_INT 4
45777: NEG
45778: PUSH
45779: EMPTY
45780: LIST
45781: LIST
45782: PUSH
45783: LD_INT 0
45785: PUSH
45786: LD_INT 4
45788: NEG
45789: PUSH
45790: EMPTY
45791: LIST
45792: LIST
45793: PUSH
45794: LD_INT 1
45796: PUSH
45797: LD_INT 3
45799: NEG
45800: PUSH
45801: EMPTY
45802: LIST
45803: LIST
45804: PUSH
45805: LD_INT 1
45807: NEG
45808: PUSH
45809: LD_INT 5
45811: NEG
45812: PUSH
45813: EMPTY
45814: LIST
45815: LIST
45816: PUSH
45817: LD_INT 0
45819: PUSH
45820: LD_INT 5
45822: NEG
45823: PUSH
45824: EMPTY
45825: LIST
45826: LIST
45827: PUSH
45828: LD_INT 1
45830: PUSH
45831: LD_INT 4
45833: NEG
45834: PUSH
45835: EMPTY
45836: LIST
45837: LIST
45838: PUSH
45839: LD_INT 1
45841: NEG
45842: PUSH
45843: LD_INT 6
45845: NEG
45846: PUSH
45847: EMPTY
45848: LIST
45849: LIST
45850: PUSH
45851: LD_INT 0
45853: PUSH
45854: LD_INT 6
45856: NEG
45857: PUSH
45858: EMPTY
45859: LIST
45860: LIST
45861: PUSH
45862: LD_INT 1
45864: PUSH
45865: LD_INT 5
45867: NEG
45868: PUSH
45869: EMPTY
45870: LIST
45871: LIST
45872: PUSH
45873: EMPTY
45874: LIST
45875: LIST
45876: LIST
45877: LIST
45878: LIST
45879: LIST
45880: LIST
45881: LIST
45882: LIST
45883: LIST
45884: LIST
45885: LIST
45886: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
45887: LD_ADDR_VAR 0 30
45891: PUSH
45892: LD_INT 2
45894: PUSH
45895: LD_INT 1
45897: NEG
45898: PUSH
45899: EMPTY
45900: LIST
45901: LIST
45902: PUSH
45903: LD_INT 3
45905: PUSH
45906: LD_INT 0
45908: PUSH
45909: EMPTY
45910: LIST
45911: LIST
45912: PUSH
45913: LD_INT 3
45915: PUSH
45916: LD_INT 1
45918: PUSH
45919: EMPTY
45920: LIST
45921: LIST
45922: PUSH
45923: LD_INT 3
45925: PUSH
45926: LD_INT 1
45928: NEG
45929: PUSH
45930: EMPTY
45931: LIST
45932: LIST
45933: PUSH
45934: LD_INT 4
45936: PUSH
45937: LD_INT 0
45939: PUSH
45940: EMPTY
45941: LIST
45942: LIST
45943: PUSH
45944: LD_INT 4
45946: PUSH
45947: LD_INT 1
45949: PUSH
45950: EMPTY
45951: LIST
45952: LIST
45953: PUSH
45954: LD_INT 4
45956: PUSH
45957: LD_INT 1
45959: NEG
45960: PUSH
45961: EMPTY
45962: LIST
45963: LIST
45964: PUSH
45965: LD_INT 5
45967: PUSH
45968: LD_INT 0
45970: PUSH
45971: EMPTY
45972: LIST
45973: LIST
45974: PUSH
45975: LD_INT 5
45977: PUSH
45978: LD_INT 1
45980: PUSH
45981: EMPTY
45982: LIST
45983: LIST
45984: PUSH
45985: LD_INT 5
45987: PUSH
45988: LD_INT 1
45990: NEG
45991: PUSH
45992: EMPTY
45993: LIST
45994: LIST
45995: PUSH
45996: LD_INT 6
45998: PUSH
45999: LD_INT 0
46001: PUSH
46002: EMPTY
46003: LIST
46004: LIST
46005: PUSH
46006: LD_INT 6
46008: PUSH
46009: LD_INT 1
46011: PUSH
46012: EMPTY
46013: LIST
46014: LIST
46015: PUSH
46016: EMPTY
46017: LIST
46018: LIST
46019: LIST
46020: LIST
46021: LIST
46022: LIST
46023: LIST
46024: LIST
46025: LIST
46026: LIST
46027: LIST
46028: LIST
46029: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
46030: LD_ADDR_VAR 0 31
46034: PUSH
46035: LD_INT 3
46037: PUSH
46038: LD_INT 2
46040: PUSH
46041: EMPTY
46042: LIST
46043: LIST
46044: PUSH
46045: LD_INT 3
46047: PUSH
46048: LD_INT 3
46050: PUSH
46051: EMPTY
46052: LIST
46053: LIST
46054: PUSH
46055: LD_INT 2
46057: PUSH
46058: LD_INT 3
46060: PUSH
46061: EMPTY
46062: LIST
46063: LIST
46064: PUSH
46065: LD_INT 4
46067: PUSH
46068: LD_INT 3
46070: PUSH
46071: EMPTY
46072: LIST
46073: LIST
46074: PUSH
46075: LD_INT 4
46077: PUSH
46078: LD_INT 4
46080: PUSH
46081: EMPTY
46082: LIST
46083: LIST
46084: PUSH
46085: LD_INT 3
46087: PUSH
46088: LD_INT 4
46090: PUSH
46091: EMPTY
46092: LIST
46093: LIST
46094: PUSH
46095: LD_INT 5
46097: PUSH
46098: LD_INT 4
46100: PUSH
46101: EMPTY
46102: LIST
46103: LIST
46104: PUSH
46105: LD_INT 5
46107: PUSH
46108: LD_INT 5
46110: PUSH
46111: EMPTY
46112: LIST
46113: LIST
46114: PUSH
46115: LD_INT 4
46117: PUSH
46118: LD_INT 5
46120: PUSH
46121: EMPTY
46122: LIST
46123: LIST
46124: PUSH
46125: LD_INT 6
46127: PUSH
46128: LD_INT 5
46130: PUSH
46131: EMPTY
46132: LIST
46133: LIST
46134: PUSH
46135: LD_INT 6
46137: PUSH
46138: LD_INT 6
46140: PUSH
46141: EMPTY
46142: LIST
46143: LIST
46144: PUSH
46145: LD_INT 5
46147: PUSH
46148: LD_INT 6
46150: PUSH
46151: EMPTY
46152: LIST
46153: LIST
46154: PUSH
46155: EMPTY
46156: LIST
46157: LIST
46158: LIST
46159: LIST
46160: LIST
46161: LIST
46162: LIST
46163: LIST
46164: LIST
46165: LIST
46166: LIST
46167: LIST
46168: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
46169: LD_ADDR_VAR 0 32
46173: PUSH
46174: LD_INT 1
46176: PUSH
46177: LD_INT 3
46179: PUSH
46180: EMPTY
46181: LIST
46182: LIST
46183: PUSH
46184: LD_INT 0
46186: PUSH
46187: LD_INT 3
46189: PUSH
46190: EMPTY
46191: LIST
46192: LIST
46193: PUSH
46194: LD_INT 1
46196: NEG
46197: PUSH
46198: LD_INT 2
46200: PUSH
46201: EMPTY
46202: LIST
46203: LIST
46204: PUSH
46205: LD_INT 1
46207: PUSH
46208: LD_INT 4
46210: PUSH
46211: EMPTY
46212: LIST
46213: LIST
46214: PUSH
46215: LD_INT 0
46217: PUSH
46218: LD_INT 4
46220: PUSH
46221: EMPTY
46222: LIST
46223: LIST
46224: PUSH
46225: LD_INT 1
46227: NEG
46228: PUSH
46229: LD_INT 3
46231: PUSH
46232: EMPTY
46233: LIST
46234: LIST
46235: PUSH
46236: LD_INT 1
46238: PUSH
46239: LD_INT 5
46241: PUSH
46242: EMPTY
46243: LIST
46244: LIST
46245: PUSH
46246: LD_INT 0
46248: PUSH
46249: LD_INT 5
46251: PUSH
46252: EMPTY
46253: LIST
46254: LIST
46255: PUSH
46256: LD_INT 1
46258: NEG
46259: PUSH
46260: LD_INT 4
46262: PUSH
46263: EMPTY
46264: LIST
46265: LIST
46266: PUSH
46267: LD_INT 1
46269: PUSH
46270: LD_INT 6
46272: PUSH
46273: EMPTY
46274: LIST
46275: LIST
46276: PUSH
46277: LD_INT 0
46279: PUSH
46280: LD_INT 6
46282: PUSH
46283: EMPTY
46284: LIST
46285: LIST
46286: PUSH
46287: LD_INT 1
46289: NEG
46290: PUSH
46291: LD_INT 5
46293: PUSH
46294: EMPTY
46295: LIST
46296: LIST
46297: PUSH
46298: EMPTY
46299: LIST
46300: LIST
46301: LIST
46302: LIST
46303: LIST
46304: LIST
46305: LIST
46306: LIST
46307: LIST
46308: LIST
46309: LIST
46310: LIST
46311: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
46312: LD_ADDR_VAR 0 33
46316: PUSH
46317: LD_INT 2
46319: NEG
46320: PUSH
46321: LD_INT 1
46323: PUSH
46324: EMPTY
46325: LIST
46326: LIST
46327: PUSH
46328: LD_INT 3
46330: NEG
46331: PUSH
46332: LD_INT 0
46334: PUSH
46335: EMPTY
46336: LIST
46337: LIST
46338: PUSH
46339: LD_INT 3
46341: NEG
46342: PUSH
46343: LD_INT 1
46345: NEG
46346: PUSH
46347: EMPTY
46348: LIST
46349: LIST
46350: PUSH
46351: LD_INT 3
46353: NEG
46354: PUSH
46355: LD_INT 1
46357: PUSH
46358: EMPTY
46359: LIST
46360: LIST
46361: PUSH
46362: LD_INT 4
46364: NEG
46365: PUSH
46366: LD_INT 0
46368: PUSH
46369: EMPTY
46370: LIST
46371: LIST
46372: PUSH
46373: LD_INT 4
46375: NEG
46376: PUSH
46377: LD_INT 1
46379: NEG
46380: PUSH
46381: EMPTY
46382: LIST
46383: LIST
46384: PUSH
46385: LD_INT 4
46387: NEG
46388: PUSH
46389: LD_INT 1
46391: PUSH
46392: EMPTY
46393: LIST
46394: LIST
46395: PUSH
46396: LD_INT 5
46398: NEG
46399: PUSH
46400: LD_INT 0
46402: PUSH
46403: EMPTY
46404: LIST
46405: LIST
46406: PUSH
46407: LD_INT 5
46409: NEG
46410: PUSH
46411: LD_INT 1
46413: NEG
46414: PUSH
46415: EMPTY
46416: LIST
46417: LIST
46418: PUSH
46419: LD_INT 5
46421: NEG
46422: PUSH
46423: LD_INT 1
46425: PUSH
46426: EMPTY
46427: LIST
46428: LIST
46429: PUSH
46430: LD_INT 6
46432: NEG
46433: PUSH
46434: LD_INT 0
46436: PUSH
46437: EMPTY
46438: LIST
46439: LIST
46440: PUSH
46441: LD_INT 6
46443: NEG
46444: PUSH
46445: LD_INT 1
46447: NEG
46448: PUSH
46449: EMPTY
46450: LIST
46451: LIST
46452: PUSH
46453: EMPTY
46454: LIST
46455: LIST
46456: LIST
46457: LIST
46458: LIST
46459: LIST
46460: LIST
46461: LIST
46462: LIST
46463: LIST
46464: LIST
46465: LIST
46466: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
46467: LD_ADDR_VAR 0 34
46471: PUSH
46472: LD_INT 2
46474: NEG
46475: PUSH
46476: LD_INT 3
46478: NEG
46479: PUSH
46480: EMPTY
46481: LIST
46482: LIST
46483: PUSH
46484: LD_INT 3
46486: NEG
46487: PUSH
46488: LD_INT 2
46490: NEG
46491: PUSH
46492: EMPTY
46493: LIST
46494: LIST
46495: PUSH
46496: LD_INT 3
46498: NEG
46499: PUSH
46500: LD_INT 3
46502: NEG
46503: PUSH
46504: EMPTY
46505: LIST
46506: LIST
46507: PUSH
46508: LD_INT 3
46510: NEG
46511: PUSH
46512: LD_INT 4
46514: NEG
46515: PUSH
46516: EMPTY
46517: LIST
46518: LIST
46519: PUSH
46520: LD_INT 4
46522: NEG
46523: PUSH
46524: LD_INT 3
46526: NEG
46527: PUSH
46528: EMPTY
46529: LIST
46530: LIST
46531: PUSH
46532: LD_INT 4
46534: NEG
46535: PUSH
46536: LD_INT 4
46538: NEG
46539: PUSH
46540: EMPTY
46541: LIST
46542: LIST
46543: PUSH
46544: LD_INT 4
46546: NEG
46547: PUSH
46548: LD_INT 5
46550: NEG
46551: PUSH
46552: EMPTY
46553: LIST
46554: LIST
46555: PUSH
46556: LD_INT 5
46558: NEG
46559: PUSH
46560: LD_INT 4
46562: NEG
46563: PUSH
46564: EMPTY
46565: LIST
46566: LIST
46567: PUSH
46568: LD_INT 5
46570: NEG
46571: PUSH
46572: LD_INT 5
46574: NEG
46575: PUSH
46576: EMPTY
46577: LIST
46578: LIST
46579: PUSH
46580: LD_INT 5
46582: NEG
46583: PUSH
46584: LD_INT 6
46586: NEG
46587: PUSH
46588: EMPTY
46589: LIST
46590: LIST
46591: PUSH
46592: LD_INT 6
46594: NEG
46595: PUSH
46596: LD_INT 5
46598: NEG
46599: PUSH
46600: EMPTY
46601: LIST
46602: LIST
46603: PUSH
46604: LD_INT 6
46606: NEG
46607: PUSH
46608: LD_INT 6
46610: NEG
46611: PUSH
46612: EMPTY
46613: LIST
46614: LIST
46615: PUSH
46616: EMPTY
46617: LIST
46618: LIST
46619: LIST
46620: LIST
46621: LIST
46622: LIST
46623: LIST
46624: LIST
46625: LIST
46626: LIST
46627: LIST
46628: LIST
46629: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
46630: LD_ADDR_VAR 0 41
46634: PUSH
46635: LD_INT 0
46637: PUSH
46638: LD_INT 2
46640: NEG
46641: PUSH
46642: EMPTY
46643: LIST
46644: LIST
46645: PUSH
46646: LD_INT 1
46648: NEG
46649: PUSH
46650: LD_INT 3
46652: NEG
46653: PUSH
46654: EMPTY
46655: LIST
46656: LIST
46657: PUSH
46658: LD_INT 1
46660: PUSH
46661: LD_INT 2
46663: NEG
46664: PUSH
46665: EMPTY
46666: LIST
46667: LIST
46668: PUSH
46669: EMPTY
46670: LIST
46671: LIST
46672: LIST
46673: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
46674: LD_ADDR_VAR 0 42
46678: PUSH
46679: LD_INT 2
46681: PUSH
46682: LD_INT 0
46684: PUSH
46685: EMPTY
46686: LIST
46687: LIST
46688: PUSH
46689: LD_INT 2
46691: PUSH
46692: LD_INT 1
46694: NEG
46695: PUSH
46696: EMPTY
46697: LIST
46698: LIST
46699: PUSH
46700: LD_INT 3
46702: PUSH
46703: LD_INT 1
46705: PUSH
46706: EMPTY
46707: LIST
46708: LIST
46709: PUSH
46710: EMPTY
46711: LIST
46712: LIST
46713: LIST
46714: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
46715: LD_ADDR_VAR 0 43
46719: PUSH
46720: LD_INT 2
46722: PUSH
46723: LD_INT 2
46725: PUSH
46726: EMPTY
46727: LIST
46728: LIST
46729: PUSH
46730: LD_INT 3
46732: PUSH
46733: LD_INT 2
46735: PUSH
46736: EMPTY
46737: LIST
46738: LIST
46739: PUSH
46740: LD_INT 2
46742: PUSH
46743: LD_INT 3
46745: PUSH
46746: EMPTY
46747: LIST
46748: LIST
46749: PUSH
46750: EMPTY
46751: LIST
46752: LIST
46753: LIST
46754: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
46755: LD_ADDR_VAR 0 44
46759: PUSH
46760: LD_INT 0
46762: PUSH
46763: LD_INT 2
46765: PUSH
46766: EMPTY
46767: LIST
46768: LIST
46769: PUSH
46770: LD_INT 1
46772: PUSH
46773: LD_INT 3
46775: PUSH
46776: EMPTY
46777: LIST
46778: LIST
46779: PUSH
46780: LD_INT 1
46782: NEG
46783: PUSH
46784: LD_INT 2
46786: PUSH
46787: EMPTY
46788: LIST
46789: LIST
46790: PUSH
46791: EMPTY
46792: LIST
46793: LIST
46794: LIST
46795: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
46796: LD_ADDR_VAR 0 45
46800: PUSH
46801: LD_INT 2
46803: NEG
46804: PUSH
46805: LD_INT 0
46807: PUSH
46808: EMPTY
46809: LIST
46810: LIST
46811: PUSH
46812: LD_INT 2
46814: NEG
46815: PUSH
46816: LD_INT 1
46818: PUSH
46819: EMPTY
46820: LIST
46821: LIST
46822: PUSH
46823: LD_INT 3
46825: NEG
46826: PUSH
46827: LD_INT 1
46829: NEG
46830: PUSH
46831: EMPTY
46832: LIST
46833: LIST
46834: PUSH
46835: EMPTY
46836: LIST
46837: LIST
46838: LIST
46839: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
46840: LD_ADDR_VAR 0 46
46844: PUSH
46845: LD_INT 2
46847: NEG
46848: PUSH
46849: LD_INT 2
46851: NEG
46852: PUSH
46853: EMPTY
46854: LIST
46855: LIST
46856: PUSH
46857: LD_INT 2
46859: NEG
46860: PUSH
46861: LD_INT 3
46863: NEG
46864: PUSH
46865: EMPTY
46866: LIST
46867: LIST
46868: PUSH
46869: LD_INT 3
46871: NEG
46872: PUSH
46873: LD_INT 2
46875: NEG
46876: PUSH
46877: EMPTY
46878: LIST
46879: LIST
46880: PUSH
46881: EMPTY
46882: LIST
46883: LIST
46884: LIST
46885: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
46886: LD_ADDR_VAR 0 47
46890: PUSH
46891: LD_INT 2
46893: NEG
46894: PUSH
46895: LD_INT 3
46897: NEG
46898: PUSH
46899: EMPTY
46900: LIST
46901: LIST
46902: PUSH
46903: LD_INT 1
46905: NEG
46906: PUSH
46907: LD_INT 3
46909: NEG
46910: PUSH
46911: EMPTY
46912: LIST
46913: LIST
46914: PUSH
46915: EMPTY
46916: LIST
46917: LIST
46918: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
46919: LD_ADDR_VAR 0 48
46923: PUSH
46924: LD_INT 1
46926: PUSH
46927: LD_INT 2
46929: NEG
46930: PUSH
46931: EMPTY
46932: LIST
46933: LIST
46934: PUSH
46935: LD_INT 2
46937: PUSH
46938: LD_INT 1
46940: NEG
46941: PUSH
46942: EMPTY
46943: LIST
46944: LIST
46945: PUSH
46946: EMPTY
46947: LIST
46948: LIST
46949: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
46950: LD_ADDR_VAR 0 49
46954: PUSH
46955: LD_INT 3
46957: PUSH
46958: LD_INT 1
46960: PUSH
46961: EMPTY
46962: LIST
46963: LIST
46964: PUSH
46965: LD_INT 3
46967: PUSH
46968: LD_INT 2
46970: PUSH
46971: EMPTY
46972: LIST
46973: LIST
46974: PUSH
46975: EMPTY
46976: LIST
46977: LIST
46978: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
46979: LD_ADDR_VAR 0 50
46983: PUSH
46984: LD_INT 2
46986: PUSH
46987: LD_INT 3
46989: PUSH
46990: EMPTY
46991: LIST
46992: LIST
46993: PUSH
46994: LD_INT 1
46996: PUSH
46997: LD_INT 3
46999: PUSH
47000: EMPTY
47001: LIST
47002: LIST
47003: PUSH
47004: EMPTY
47005: LIST
47006: LIST
47007: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
47008: LD_ADDR_VAR 0 51
47012: PUSH
47013: LD_INT 1
47015: NEG
47016: PUSH
47017: LD_INT 2
47019: PUSH
47020: EMPTY
47021: LIST
47022: LIST
47023: PUSH
47024: LD_INT 2
47026: NEG
47027: PUSH
47028: LD_INT 1
47030: PUSH
47031: EMPTY
47032: LIST
47033: LIST
47034: PUSH
47035: EMPTY
47036: LIST
47037: LIST
47038: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
47039: LD_ADDR_VAR 0 52
47043: PUSH
47044: LD_INT 3
47046: NEG
47047: PUSH
47048: LD_INT 1
47050: NEG
47051: PUSH
47052: EMPTY
47053: LIST
47054: LIST
47055: PUSH
47056: LD_INT 3
47058: NEG
47059: PUSH
47060: LD_INT 2
47062: NEG
47063: PUSH
47064: EMPTY
47065: LIST
47066: LIST
47067: PUSH
47068: EMPTY
47069: LIST
47070: LIST
47071: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
47072: LD_ADDR_VAR 0 53
47076: PUSH
47077: LD_INT 1
47079: NEG
47080: PUSH
47081: LD_INT 3
47083: NEG
47084: PUSH
47085: EMPTY
47086: LIST
47087: LIST
47088: PUSH
47089: LD_INT 0
47091: PUSH
47092: LD_INT 3
47094: NEG
47095: PUSH
47096: EMPTY
47097: LIST
47098: LIST
47099: PUSH
47100: LD_INT 1
47102: PUSH
47103: LD_INT 2
47105: NEG
47106: PUSH
47107: EMPTY
47108: LIST
47109: LIST
47110: PUSH
47111: EMPTY
47112: LIST
47113: LIST
47114: LIST
47115: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
47116: LD_ADDR_VAR 0 54
47120: PUSH
47121: LD_INT 2
47123: PUSH
47124: LD_INT 1
47126: NEG
47127: PUSH
47128: EMPTY
47129: LIST
47130: LIST
47131: PUSH
47132: LD_INT 3
47134: PUSH
47135: LD_INT 0
47137: PUSH
47138: EMPTY
47139: LIST
47140: LIST
47141: PUSH
47142: LD_INT 3
47144: PUSH
47145: LD_INT 1
47147: PUSH
47148: EMPTY
47149: LIST
47150: LIST
47151: PUSH
47152: EMPTY
47153: LIST
47154: LIST
47155: LIST
47156: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
47157: LD_ADDR_VAR 0 55
47161: PUSH
47162: LD_INT 3
47164: PUSH
47165: LD_INT 2
47167: PUSH
47168: EMPTY
47169: LIST
47170: LIST
47171: PUSH
47172: LD_INT 3
47174: PUSH
47175: LD_INT 3
47177: PUSH
47178: EMPTY
47179: LIST
47180: LIST
47181: PUSH
47182: LD_INT 2
47184: PUSH
47185: LD_INT 3
47187: PUSH
47188: EMPTY
47189: LIST
47190: LIST
47191: PUSH
47192: EMPTY
47193: LIST
47194: LIST
47195: LIST
47196: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
47197: LD_ADDR_VAR 0 56
47201: PUSH
47202: LD_INT 1
47204: PUSH
47205: LD_INT 3
47207: PUSH
47208: EMPTY
47209: LIST
47210: LIST
47211: PUSH
47212: LD_INT 0
47214: PUSH
47215: LD_INT 3
47217: PUSH
47218: EMPTY
47219: LIST
47220: LIST
47221: PUSH
47222: LD_INT 1
47224: NEG
47225: PUSH
47226: LD_INT 2
47228: PUSH
47229: EMPTY
47230: LIST
47231: LIST
47232: PUSH
47233: EMPTY
47234: LIST
47235: LIST
47236: LIST
47237: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
47238: LD_ADDR_VAR 0 57
47242: PUSH
47243: LD_INT 2
47245: NEG
47246: PUSH
47247: LD_INT 1
47249: PUSH
47250: EMPTY
47251: LIST
47252: LIST
47253: PUSH
47254: LD_INT 3
47256: NEG
47257: PUSH
47258: LD_INT 0
47260: PUSH
47261: EMPTY
47262: LIST
47263: LIST
47264: PUSH
47265: LD_INT 3
47267: NEG
47268: PUSH
47269: LD_INT 1
47271: NEG
47272: PUSH
47273: EMPTY
47274: LIST
47275: LIST
47276: PUSH
47277: EMPTY
47278: LIST
47279: LIST
47280: LIST
47281: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
47282: LD_ADDR_VAR 0 58
47286: PUSH
47287: LD_INT 2
47289: NEG
47290: PUSH
47291: LD_INT 3
47293: NEG
47294: PUSH
47295: EMPTY
47296: LIST
47297: LIST
47298: PUSH
47299: LD_INT 3
47301: NEG
47302: PUSH
47303: LD_INT 2
47305: NEG
47306: PUSH
47307: EMPTY
47308: LIST
47309: LIST
47310: PUSH
47311: LD_INT 3
47313: NEG
47314: PUSH
47315: LD_INT 3
47317: NEG
47318: PUSH
47319: EMPTY
47320: LIST
47321: LIST
47322: PUSH
47323: EMPTY
47324: LIST
47325: LIST
47326: LIST
47327: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
47328: LD_ADDR_VAR 0 59
47332: PUSH
47333: LD_INT 1
47335: NEG
47336: PUSH
47337: LD_INT 2
47339: NEG
47340: PUSH
47341: EMPTY
47342: LIST
47343: LIST
47344: PUSH
47345: LD_INT 0
47347: PUSH
47348: LD_INT 2
47350: NEG
47351: PUSH
47352: EMPTY
47353: LIST
47354: LIST
47355: PUSH
47356: LD_INT 1
47358: PUSH
47359: LD_INT 1
47361: NEG
47362: PUSH
47363: EMPTY
47364: LIST
47365: LIST
47366: PUSH
47367: EMPTY
47368: LIST
47369: LIST
47370: LIST
47371: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
47372: LD_ADDR_VAR 0 60
47376: PUSH
47377: LD_INT 1
47379: PUSH
47380: LD_INT 1
47382: NEG
47383: PUSH
47384: EMPTY
47385: LIST
47386: LIST
47387: PUSH
47388: LD_INT 2
47390: PUSH
47391: LD_INT 0
47393: PUSH
47394: EMPTY
47395: LIST
47396: LIST
47397: PUSH
47398: LD_INT 2
47400: PUSH
47401: LD_INT 1
47403: PUSH
47404: EMPTY
47405: LIST
47406: LIST
47407: PUSH
47408: EMPTY
47409: LIST
47410: LIST
47411: LIST
47412: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
47413: LD_ADDR_VAR 0 61
47417: PUSH
47418: LD_INT 2
47420: PUSH
47421: LD_INT 1
47423: PUSH
47424: EMPTY
47425: LIST
47426: LIST
47427: PUSH
47428: LD_INT 2
47430: PUSH
47431: LD_INT 2
47433: PUSH
47434: EMPTY
47435: LIST
47436: LIST
47437: PUSH
47438: LD_INT 1
47440: PUSH
47441: LD_INT 2
47443: PUSH
47444: EMPTY
47445: LIST
47446: LIST
47447: PUSH
47448: EMPTY
47449: LIST
47450: LIST
47451: LIST
47452: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
47453: LD_ADDR_VAR 0 62
47457: PUSH
47458: LD_INT 1
47460: PUSH
47461: LD_INT 2
47463: PUSH
47464: EMPTY
47465: LIST
47466: LIST
47467: PUSH
47468: LD_INT 0
47470: PUSH
47471: LD_INT 2
47473: PUSH
47474: EMPTY
47475: LIST
47476: LIST
47477: PUSH
47478: LD_INT 1
47480: NEG
47481: PUSH
47482: LD_INT 1
47484: PUSH
47485: EMPTY
47486: LIST
47487: LIST
47488: PUSH
47489: EMPTY
47490: LIST
47491: LIST
47492: LIST
47493: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
47494: LD_ADDR_VAR 0 63
47498: PUSH
47499: LD_INT 1
47501: NEG
47502: PUSH
47503: LD_INT 1
47505: PUSH
47506: EMPTY
47507: LIST
47508: LIST
47509: PUSH
47510: LD_INT 2
47512: NEG
47513: PUSH
47514: LD_INT 0
47516: PUSH
47517: EMPTY
47518: LIST
47519: LIST
47520: PUSH
47521: LD_INT 2
47523: NEG
47524: PUSH
47525: LD_INT 1
47527: NEG
47528: PUSH
47529: EMPTY
47530: LIST
47531: LIST
47532: PUSH
47533: EMPTY
47534: LIST
47535: LIST
47536: LIST
47537: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
47538: LD_ADDR_VAR 0 64
47542: PUSH
47543: LD_INT 1
47545: NEG
47546: PUSH
47547: LD_INT 2
47549: NEG
47550: PUSH
47551: EMPTY
47552: LIST
47553: LIST
47554: PUSH
47555: LD_INT 2
47557: NEG
47558: PUSH
47559: LD_INT 1
47561: NEG
47562: PUSH
47563: EMPTY
47564: LIST
47565: LIST
47566: PUSH
47567: LD_INT 2
47569: NEG
47570: PUSH
47571: LD_INT 2
47573: NEG
47574: PUSH
47575: EMPTY
47576: LIST
47577: LIST
47578: PUSH
47579: EMPTY
47580: LIST
47581: LIST
47582: LIST
47583: ST_TO_ADDR
// end ; 2 :
47584: GO 50850
47586: LD_INT 2
47588: DOUBLE
47589: EQUAL
47590: IFTRUE 47594
47592: GO 50849
47594: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
47595: LD_ADDR_VAR 0 29
47599: PUSH
47600: LD_INT 4
47602: PUSH
47603: LD_INT 0
47605: PUSH
47606: EMPTY
47607: LIST
47608: LIST
47609: PUSH
47610: LD_INT 4
47612: PUSH
47613: LD_INT 1
47615: NEG
47616: PUSH
47617: EMPTY
47618: LIST
47619: LIST
47620: PUSH
47621: LD_INT 5
47623: PUSH
47624: LD_INT 0
47626: PUSH
47627: EMPTY
47628: LIST
47629: LIST
47630: PUSH
47631: LD_INT 5
47633: PUSH
47634: LD_INT 1
47636: PUSH
47637: EMPTY
47638: LIST
47639: LIST
47640: PUSH
47641: LD_INT 4
47643: PUSH
47644: LD_INT 1
47646: PUSH
47647: EMPTY
47648: LIST
47649: LIST
47650: PUSH
47651: LD_INT 3
47653: PUSH
47654: LD_INT 0
47656: PUSH
47657: EMPTY
47658: LIST
47659: LIST
47660: PUSH
47661: LD_INT 3
47663: PUSH
47664: LD_INT 1
47666: NEG
47667: PUSH
47668: EMPTY
47669: LIST
47670: LIST
47671: PUSH
47672: LD_INT 3
47674: PUSH
47675: LD_INT 2
47677: NEG
47678: PUSH
47679: EMPTY
47680: LIST
47681: LIST
47682: PUSH
47683: LD_INT 5
47685: PUSH
47686: LD_INT 2
47688: PUSH
47689: EMPTY
47690: LIST
47691: LIST
47692: PUSH
47693: LD_INT 3
47695: PUSH
47696: LD_INT 3
47698: PUSH
47699: EMPTY
47700: LIST
47701: LIST
47702: PUSH
47703: LD_INT 3
47705: PUSH
47706: LD_INT 2
47708: PUSH
47709: EMPTY
47710: LIST
47711: LIST
47712: PUSH
47713: LD_INT 4
47715: PUSH
47716: LD_INT 3
47718: PUSH
47719: EMPTY
47720: LIST
47721: LIST
47722: PUSH
47723: LD_INT 4
47725: PUSH
47726: LD_INT 4
47728: PUSH
47729: EMPTY
47730: LIST
47731: LIST
47732: PUSH
47733: LD_INT 3
47735: PUSH
47736: LD_INT 4
47738: PUSH
47739: EMPTY
47740: LIST
47741: LIST
47742: PUSH
47743: LD_INT 2
47745: PUSH
47746: LD_INT 3
47748: PUSH
47749: EMPTY
47750: LIST
47751: LIST
47752: PUSH
47753: LD_INT 2
47755: PUSH
47756: LD_INT 2
47758: PUSH
47759: EMPTY
47760: LIST
47761: LIST
47762: PUSH
47763: LD_INT 4
47765: PUSH
47766: LD_INT 2
47768: PUSH
47769: EMPTY
47770: LIST
47771: LIST
47772: PUSH
47773: LD_INT 2
47775: PUSH
47776: LD_INT 4
47778: PUSH
47779: EMPTY
47780: LIST
47781: LIST
47782: PUSH
47783: LD_INT 0
47785: PUSH
47786: LD_INT 4
47788: PUSH
47789: EMPTY
47790: LIST
47791: LIST
47792: PUSH
47793: LD_INT 0
47795: PUSH
47796: LD_INT 3
47798: PUSH
47799: EMPTY
47800: LIST
47801: LIST
47802: PUSH
47803: LD_INT 1
47805: PUSH
47806: LD_INT 4
47808: PUSH
47809: EMPTY
47810: LIST
47811: LIST
47812: PUSH
47813: LD_INT 1
47815: PUSH
47816: LD_INT 5
47818: PUSH
47819: EMPTY
47820: LIST
47821: LIST
47822: PUSH
47823: LD_INT 0
47825: PUSH
47826: LD_INT 5
47828: PUSH
47829: EMPTY
47830: LIST
47831: LIST
47832: PUSH
47833: LD_INT 1
47835: NEG
47836: PUSH
47837: LD_INT 4
47839: PUSH
47840: EMPTY
47841: LIST
47842: LIST
47843: PUSH
47844: LD_INT 1
47846: NEG
47847: PUSH
47848: LD_INT 3
47850: PUSH
47851: EMPTY
47852: LIST
47853: LIST
47854: PUSH
47855: LD_INT 2
47857: PUSH
47858: LD_INT 5
47860: PUSH
47861: EMPTY
47862: LIST
47863: LIST
47864: PUSH
47865: LD_INT 2
47867: NEG
47868: PUSH
47869: LD_INT 3
47871: PUSH
47872: EMPTY
47873: LIST
47874: LIST
47875: PUSH
47876: LD_INT 3
47878: NEG
47879: PUSH
47880: LD_INT 0
47882: PUSH
47883: EMPTY
47884: LIST
47885: LIST
47886: PUSH
47887: LD_INT 3
47889: NEG
47890: PUSH
47891: LD_INT 1
47893: NEG
47894: PUSH
47895: EMPTY
47896: LIST
47897: LIST
47898: PUSH
47899: LD_INT 2
47901: NEG
47902: PUSH
47903: LD_INT 0
47905: PUSH
47906: EMPTY
47907: LIST
47908: LIST
47909: PUSH
47910: LD_INT 2
47912: NEG
47913: PUSH
47914: LD_INT 1
47916: PUSH
47917: EMPTY
47918: LIST
47919: LIST
47920: PUSH
47921: LD_INT 3
47923: NEG
47924: PUSH
47925: LD_INT 1
47927: PUSH
47928: EMPTY
47929: LIST
47930: LIST
47931: PUSH
47932: LD_INT 4
47934: NEG
47935: PUSH
47936: LD_INT 0
47938: PUSH
47939: EMPTY
47940: LIST
47941: LIST
47942: PUSH
47943: LD_INT 4
47945: NEG
47946: PUSH
47947: LD_INT 1
47949: NEG
47950: PUSH
47951: EMPTY
47952: LIST
47953: LIST
47954: PUSH
47955: LD_INT 4
47957: NEG
47958: PUSH
47959: LD_INT 2
47961: NEG
47962: PUSH
47963: EMPTY
47964: LIST
47965: LIST
47966: PUSH
47967: LD_INT 2
47969: NEG
47970: PUSH
47971: LD_INT 2
47973: PUSH
47974: EMPTY
47975: LIST
47976: LIST
47977: PUSH
47978: LD_INT 4
47980: NEG
47981: PUSH
47982: LD_INT 4
47984: NEG
47985: PUSH
47986: EMPTY
47987: LIST
47988: LIST
47989: PUSH
47990: LD_INT 4
47992: NEG
47993: PUSH
47994: LD_INT 5
47996: NEG
47997: PUSH
47998: EMPTY
47999: LIST
48000: LIST
48001: PUSH
48002: LD_INT 3
48004: NEG
48005: PUSH
48006: LD_INT 4
48008: NEG
48009: PUSH
48010: EMPTY
48011: LIST
48012: LIST
48013: PUSH
48014: LD_INT 3
48016: NEG
48017: PUSH
48018: LD_INT 3
48020: NEG
48021: PUSH
48022: EMPTY
48023: LIST
48024: LIST
48025: PUSH
48026: LD_INT 4
48028: NEG
48029: PUSH
48030: LD_INT 3
48032: NEG
48033: PUSH
48034: EMPTY
48035: LIST
48036: LIST
48037: PUSH
48038: LD_INT 5
48040: NEG
48041: PUSH
48042: LD_INT 4
48044: NEG
48045: PUSH
48046: EMPTY
48047: LIST
48048: LIST
48049: PUSH
48050: LD_INT 5
48052: NEG
48053: PUSH
48054: LD_INT 5
48056: NEG
48057: PUSH
48058: EMPTY
48059: LIST
48060: LIST
48061: PUSH
48062: LD_INT 3
48064: NEG
48065: PUSH
48066: LD_INT 5
48068: NEG
48069: PUSH
48070: EMPTY
48071: LIST
48072: LIST
48073: PUSH
48074: LD_INT 5
48076: NEG
48077: PUSH
48078: LD_INT 3
48080: NEG
48081: PUSH
48082: EMPTY
48083: LIST
48084: LIST
48085: PUSH
48086: EMPTY
48087: LIST
48088: LIST
48089: LIST
48090: LIST
48091: LIST
48092: LIST
48093: LIST
48094: LIST
48095: LIST
48096: LIST
48097: LIST
48098: LIST
48099: LIST
48100: LIST
48101: LIST
48102: LIST
48103: LIST
48104: LIST
48105: LIST
48106: LIST
48107: LIST
48108: LIST
48109: LIST
48110: LIST
48111: LIST
48112: LIST
48113: LIST
48114: LIST
48115: LIST
48116: LIST
48117: LIST
48118: LIST
48119: LIST
48120: LIST
48121: LIST
48122: LIST
48123: LIST
48124: LIST
48125: LIST
48126: LIST
48127: LIST
48128: LIST
48129: LIST
48130: LIST
48131: LIST
48132: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
48133: LD_ADDR_VAR 0 30
48137: PUSH
48138: LD_INT 4
48140: PUSH
48141: LD_INT 4
48143: PUSH
48144: EMPTY
48145: LIST
48146: LIST
48147: PUSH
48148: LD_INT 4
48150: PUSH
48151: LD_INT 3
48153: PUSH
48154: EMPTY
48155: LIST
48156: LIST
48157: PUSH
48158: LD_INT 5
48160: PUSH
48161: LD_INT 4
48163: PUSH
48164: EMPTY
48165: LIST
48166: LIST
48167: PUSH
48168: LD_INT 5
48170: PUSH
48171: LD_INT 5
48173: PUSH
48174: EMPTY
48175: LIST
48176: LIST
48177: PUSH
48178: LD_INT 4
48180: PUSH
48181: LD_INT 5
48183: PUSH
48184: EMPTY
48185: LIST
48186: LIST
48187: PUSH
48188: LD_INT 3
48190: PUSH
48191: LD_INT 4
48193: PUSH
48194: EMPTY
48195: LIST
48196: LIST
48197: PUSH
48198: LD_INT 3
48200: PUSH
48201: LD_INT 3
48203: PUSH
48204: EMPTY
48205: LIST
48206: LIST
48207: PUSH
48208: LD_INT 5
48210: PUSH
48211: LD_INT 3
48213: PUSH
48214: EMPTY
48215: LIST
48216: LIST
48217: PUSH
48218: LD_INT 3
48220: PUSH
48221: LD_INT 5
48223: PUSH
48224: EMPTY
48225: LIST
48226: LIST
48227: PUSH
48228: LD_INT 0
48230: PUSH
48231: LD_INT 3
48233: PUSH
48234: EMPTY
48235: LIST
48236: LIST
48237: PUSH
48238: LD_INT 0
48240: PUSH
48241: LD_INT 2
48243: PUSH
48244: EMPTY
48245: LIST
48246: LIST
48247: PUSH
48248: LD_INT 1
48250: PUSH
48251: LD_INT 3
48253: PUSH
48254: EMPTY
48255: LIST
48256: LIST
48257: PUSH
48258: LD_INT 1
48260: PUSH
48261: LD_INT 4
48263: PUSH
48264: EMPTY
48265: LIST
48266: LIST
48267: PUSH
48268: LD_INT 0
48270: PUSH
48271: LD_INT 4
48273: PUSH
48274: EMPTY
48275: LIST
48276: LIST
48277: PUSH
48278: LD_INT 1
48280: NEG
48281: PUSH
48282: LD_INT 3
48284: PUSH
48285: EMPTY
48286: LIST
48287: LIST
48288: PUSH
48289: LD_INT 1
48291: NEG
48292: PUSH
48293: LD_INT 2
48295: PUSH
48296: EMPTY
48297: LIST
48298: LIST
48299: PUSH
48300: LD_INT 2
48302: PUSH
48303: LD_INT 4
48305: PUSH
48306: EMPTY
48307: LIST
48308: LIST
48309: PUSH
48310: LD_INT 2
48312: NEG
48313: PUSH
48314: LD_INT 2
48316: PUSH
48317: EMPTY
48318: LIST
48319: LIST
48320: PUSH
48321: LD_INT 4
48323: NEG
48324: PUSH
48325: LD_INT 0
48327: PUSH
48328: EMPTY
48329: LIST
48330: LIST
48331: PUSH
48332: LD_INT 4
48334: NEG
48335: PUSH
48336: LD_INT 1
48338: NEG
48339: PUSH
48340: EMPTY
48341: LIST
48342: LIST
48343: PUSH
48344: LD_INT 3
48346: NEG
48347: PUSH
48348: LD_INT 0
48350: PUSH
48351: EMPTY
48352: LIST
48353: LIST
48354: PUSH
48355: LD_INT 3
48357: NEG
48358: PUSH
48359: LD_INT 1
48361: PUSH
48362: EMPTY
48363: LIST
48364: LIST
48365: PUSH
48366: LD_INT 4
48368: NEG
48369: PUSH
48370: LD_INT 1
48372: PUSH
48373: EMPTY
48374: LIST
48375: LIST
48376: PUSH
48377: LD_INT 5
48379: NEG
48380: PUSH
48381: LD_INT 0
48383: PUSH
48384: EMPTY
48385: LIST
48386: LIST
48387: PUSH
48388: LD_INT 5
48390: NEG
48391: PUSH
48392: LD_INT 1
48394: NEG
48395: PUSH
48396: EMPTY
48397: LIST
48398: LIST
48399: PUSH
48400: LD_INT 5
48402: NEG
48403: PUSH
48404: LD_INT 2
48406: NEG
48407: PUSH
48408: EMPTY
48409: LIST
48410: LIST
48411: PUSH
48412: LD_INT 3
48414: NEG
48415: PUSH
48416: LD_INT 2
48418: PUSH
48419: EMPTY
48420: LIST
48421: LIST
48422: PUSH
48423: LD_INT 3
48425: NEG
48426: PUSH
48427: LD_INT 3
48429: NEG
48430: PUSH
48431: EMPTY
48432: LIST
48433: LIST
48434: PUSH
48435: LD_INT 3
48437: NEG
48438: PUSH
48439: LD_INT 4
48441: NEG
48442: PUSH
48443: EMPTY
48444: LIST
48445: LIST
48446: PUSH
48447: LD_INT 2
48449: NEG
48450: PUSH
48451: LD_INT 3
48453: NEG
48454: PUSH
48455: EMPTY
48456: LIST
48457: LIST
48458: PUSH
48459: LD_INT 2
48461: NEG
48462: PUSH
48463: LD_INT 2
48465: NEG
48466: PUSH
48467: EMPTY
48468: LIST
48469: LIST
48470: PUSH
48471: LD_INT 3
48473: NEG
48474: PUSH
48475: LD_INT 2
48477: NEG
48478: PUSH
48479: EMPTY
48480: LIST
48481: LIST
48482: PUSH
48483: LD_INT 4
48485: NEG
48486: PUSH
48487: LD_INT 3
48489: NEG
48490: PUSH
48491: EMPTY
48492: LIST
48493: LIST
48494: PUSH
48495: LD_INT 4
48497: NEG
48498: PUSH
48499: LD_INT 4
48501: NEG
48502: PUSH
48503: EMPTY
48504: LIST
48505: LIST
48506: PUSH
48507: LD_INT 2
48509: NEG
48510: PUSH
48511: LD_INT 4
48513: NEG
48514: PUSH
48515: EMPTY
48516: LIST
48517: LIST
48518: PUSH
48519: LD_INT 4
48521: NEG
48522: PUSH
48523: LD_INT 2
48525: NEG
48526: PUSH
48527: EMPTY
48528: LIST
48529: LIST
48530: PUSH
48531: LD_INT 0
48533: PUSH
48534: LD_INT 4
48536: NEG
48537: PUSH
48538: EMPTY
48539: LIST
48540: LIST
48541: PUSH
48542: LD_INT 0
48544: PUSH
48545: LD_INT 5
48547: NEG
48548: PUSH
48549: EMPTY
48550: LIST
48551: LIST
48552: PUSH
48553: LD_INT 1
48555: PUSH
48556: LD_INT 4
48558: NEG
48559: PUSH
48560: EMPTY
48561: LIST
48562: LIST
48563: PUSH
48564: LD_INT 1
48566: PUSH
48567: LD_INT 3
48569: NEG
48570: PUSH
48571: EMPTY
48572: LIST
48573: LIST
48574: PUSH
48575: LD_INT 0
48577: PUSH
48578: LD_INT 3
48580: NEG
48581: PUSH
48582: EMPTY
48583: LIST
48584: LIST
48585: PUSH
48586: LD_INT 1
48588: NEG
48589: PUSH
48590: LD_INT 4
48592: NEG
48593: PUSH
48594: EMPTY
48595: LIST
48596: LIST
48597: PUSH
48598: LD_INT 1
48600: NEG
48601: PUSH
48602: LD_INT 5
48604: NEG
48605: PUSH
48606: EMPTY
48607: LIST
48608: LIST
48609: PUSH
48610: LD_INT 2
48612: PUSH
48613: LD_INT 3
48615: NEG
48616: PUSH
48617: EMPTY
48618: LIST
48619: LIST
48620: PUSH
48621: LD_INT 2
48623: NEG
48624: PUSH
48625: LD_INT 5
48627: NEG
48628: PUSH
48629: EMPTY
48630: LIST
48631: LIST
48632: PUSH
48633: EMPTY
48634: LIST
48635: LIST
48636: LIST
48637: LIST
48638: LIST
48639: LIST
48640: LIST
48641: LIST
48642: LIST
48643: LIST
48644: LIST
48645: LIST
48646: LIST
48647: LIST
48648: LIST
48649: LIST
48650: LIST
48651: LIST
48652: LIST
48653: LIST
48654: LIST
48655: LIST
48656: LIST
48657: LIST
48658: LIST
48659: LIST
48660: LIST
48661: LIST
48662: LIST
48663: LIST
48664: LIST
48665: LIST
48666: LIST
48667: LIST
48668: LIST
48669: LIST
48670: LIST
48671: LIST
48672: LIST
48673: LIST
48674: LIST
48675: LIST
48676: LIST
48677: LIST
48678: LIST
48679: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
48680: LD_ADDR_VAR 0 31
48684: PUSH
48685: LD_INT 0
48687: PUSH
48688: LD_INT 4
48690: PUSH
48691: EMPTY
48692: LIST
48693: LIST
48694: PUSH
48695: LD_INT 0
48697: PUSH
48698: LD_INT 3
48700: PUSH
48701: EMPTY
48702: LIST
48703: LIST
48704: PUSH
48705: LD_INT 1
48707: PUSH
48708: LD_INT 4
48710: PUSH
48711: EMPTY
48712: LIST
48713: LIST
48714: PUSH
48715: LD_INT 1
48717: PUSH
48718: LD_INT 5
48720: PUSH
48721: EMPTY
48722: LIST
48723: LIST
48724: PUSH
48725: LD_INT 0
48727: PUSH
48728: LD_INT 5
48730: PUSH
48731: EMPTY
48732: LIST
48733: LIST
48734: PUSH
48735: LD_INT 1
48737: NEG
48738: PUSH
48739: LD_INT 4
48741: PUSH
48742: EMPTY
48743: LIST
48744: LIST
48745: PUSH
48746: LD_INT 1
48748: NEG
48749: PUSH
48750: LD_INT 3
48752: PUSH
48753: EMPTY
48754: LIST
48755: LIST
48756: PUSH
48757: LD_INT 2
48759: PUSH
48760: LD_INT 5
48762: PUSH
48763: EMPTY
48764: LIST
48765: LIST
48766: PUSH
48767: LD_INT 2
48769: NEG
48770: PUSH
48771: LD_INT 3
48773: PUSH
48774: EMPTY
48775: LIST
48776: LIST
48777: PUSH
48778: LD_INT 3
48780: NEG
48781: PUSH
48782: LD_INT 0
48784: PUSH
48785: EMPTY
48786: LIST
48787: LIST
48788: PUSH
48789: LD_INT 3
48791: NEG
48792: PUSH
48793: LD_INT 1
48795: NEG
48796: PUSH
48797: EMPTY
48798: LIST
48799: LIST
48800: PUSH
48801: LD_INT 2
48803: NEG
48804: PUSH
48805: LD_INT 0
48807: PUSH
48808: EMPTY
48809: LIST
48810: LIST
48811: PUSH
48812: LD_INT 2
48814: NEG
48815: PUSH
48816: LD_INT 1
48818: PUSH
48819: EMPTY
48820: LIST
48821: LIST
48822: PUSH
48823: LD_INT 3
48825: NEG
48826: PUSH
48827: LD_INT 1
48829: PUSH
48830: EMPTY
48831: LIST
48832: LIST
48833: PUSH
48834: LD_INT 4
48836: NEG
48837: PUSH
48838: LD_INT 0
48840: PUSH
48841: EMPTY
48842: LIST
48843: LIST
48844: PUSH
48845: LD_INT 4
48847: NEG
48848: PUSH
48849: LD_INT 1
48851: NEG
48852: PUSH
48853: EMPTY
48854: LIST
48855: LIST
48856: PUSH
48857: LD_INT 4
48859: NEG
48860: PUSH
48861: LD_INT 2
48863: NEG
48864: PUSH
48865: EMPTY
48866: LIST
48867: LIST
48868: PUSH
48869: LD_INT 2
48871: NEG
48872: PUSH
48873: LD_INT 2
48875: PUSH
48876: EMPTY
48877: LIST
48878: LIST
48879: PUSH
48880: LD_INT 4
48882: NEG
48883: PUSH
48884: LD_INT 4
48886: NEG
48887: PUSH
48888: EMPTY
48889: LIST
48890: LIST
48891: PUSH
48892: LD_INT 4
48894: NEG
48895: PUSH
48896: LD_INT 5
48898: NEG
48899: PUSH
48900: EMPTY
48901: LIST
48902: LIST
48903: PUSH
48904: LD_INT 3
48906: NEG
48907: PUSH
48908: LD_INT 4
48910: NEG
48911: PUSH
48912: EMPTY
48913: LIST
48914: LIST
48915: PUSH
48916: LD_INT 3
48918: NEG
48919: PUSH
48920: LD_INT 3
48922: NEG
48923: PUSH
48924: EMPTY
48925: LIST
48926: LIST
48927: PUSH
48928: LD_INT 4
48930: NEG
48931: PUSH
48932: LD_INT 3
48934: NEG
48935: PUSH
48936: EMPTY
48937: LIST
48938: LIST
48939: PUSH
48940: LD_INT 5
48942: NEG
48943: PUSH
48944: LD_INT 4
48946: NEG
48947: PUSH
48948: EMPTY
48949: LIST
48950: LIST
48951: PUSH
48952: LD_INT 5
48954: NEG
48955: PUSH
48956: LD_INT 5
48958: NEG
48959: PUSH
48960: EMPTY
48961: LIST
48962: LIST
48963: PUSH
48964: LD_INT 3
48966: NEG
48967: PUSH
48968: LD_INT 5
48970: NEG
48971: PUSH
48972: EMPTY
48973: LIST
48974: LIST
48975: PUSH
48976: LD_INT 5
48978: NEG
48979: PUSH
48980: LD_INT 3
48982: NEG
48983: PUSH
48984: EMPTY
48985: LIST
48986: LIST
48987: PUSH
48988: LD_INT 0
48990: PUSH
48991: LD_INT 3
48993: NEG
48994: PUSH
48995: EMPTY
48996: LIST
48997: LIST
48998: PUSH
48999: LD_INT 0
49001: PUSH
49002: LD_INT 4
49004: NEG
49005: PUSH
49006: EMPTY
49007: LIST
49008: LIST
49009: PUSH
49010: LD_INT 1
49012: PUSH
49013: LD_INT 3
49015: NEG
49016: PUSH
49017: EMPTY
49018: LIST
49019: LIST
49020: PUSH
49021: LD_INT 1
49023: PUSH
49024: LD_INT 2
49026: NEG
49027: PUSH
49028: EMPTY
49029: LIST
49030: LIST
49031: PUSH
49032: LD_INT 0
49034: PUSH
49035: LD_INT 2
49037: NEG
49038: PUSH
49039: EMPTY
49040: LIST
49041: LIST
49042: PUSH
49043: LD_INT 1
49045: NEG
49046: PUSH
49047: LD_INT 3
49049: NEG
49050: PUSH
49051: EMPTY
49052: LIST
49053: LIST
49054: PUSH
49055: LD_INT 1
49057: NEG
49058: PUSH
49059: LD_INT 4
49061: NEG
49062: PUSH
49063: EMPTY
49064: LIST
49065: LIST
49066: PUSH
49067: LD_INT 2
49069: PUSH
49070: LD_INT 2
49072: NEG
49073: PUSH
49074: EMPTY
49075: LIST
49076: LIST
49077: PUSH
49078: LD_INT 2
49080: NEG
49081: PUSH
49082: LD_INT 4
49084: NEG
49085: PUSH
49086: EMPTY
49087: LIST
49088: LIST
49089: PUSH
49090: LD_INT 4
49092: PUSH
49093: LD_INT 0
49095: PUSH
49096: EMPTY
49097: LIST
49098: LIST
49099: PUSH
49100: LD_INT 4
49102: PUSH
49103: LD_INT 1
49105: NEG
49106: PUSH
49107: EMPTY
49108: LIST
49109: LIST
49110: PUSH
49111: LD_INT 5
49113: PUSH
49114: LD_INT 0
49116: PUSH
49117: EMPTY
49118: LIST
49119: LIST
49120: PUSH
49121: LD_INT 5
49123: PUSH
49124: LD_INT 1
49126: PUSH
49127: EMPTY
49128: LIST
49129: LIST
49130: PUSH
49131: LD_INT 4
49133: PUSH
49134: LD_INT 1
49136: PUSH
49137: EMPTY
49138: LIST
49139: LIST
49140: PUSH
49141: LD_INT 3
49143: PUSH
49144: LD_INT 0
49146: PUSH
49147: EMPTY
49148: LIST
49149: LIST
49150: PUSH
49151: LD_INT 3
49153: PUSH
49154: LD_INT 1
49156: NEG
49157: PUSH
49158: EMPTY
49159: LIST
49160: LIST
49161: PUSH
49162: LD_INT 3
49164: PUSH
49165: LD_INT 2
49167: NEG
49168: PUSH
49169: EMPTY
49170: LIST
49171: LIST
49172: PUSH
49173: LD_INT 5
49175: PUSH
49176: LD_INT 2
49178: PUSH
49179: EMPTY
49180: LIST
49181: LIST
49182: PUSH
49183: EMPTY
49184: LIST
49185: LIST
49186: LIST
49187: LIST
49188: LIST
49189: LIST
49190: LIST
49191: LIST
49192: LIST
49193: LIST
49194: LIST
49195: LIST
49196: LIST
49197: LIST
49198: LIST
49199: LIST
49200: LIST
49201: LIST
49202: LIST
49203: LIST
49204: LIST
49205: LIST
49206: LIST
49207: LIST
49208: LIST
49209: LIST
49210: LIST
49211: LIST
49212: LIST
49213: LIST
49214: LIST
49215: LIST
49216: LIST
49217: LIST
49218: LIST
49219: LIST
49220: LIST
49221: LIST
49222: LIST
49223: LIST
49224: LIST
49225: LIST
49226: LIST
49227: LIST
49228: LIST
49229: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
49230: LD_ADDR_VAR 0 32
49234: PUSH
49235: LD_INT 4
49237: NEG
49238: PUSH
49239: LD_INT 0
49241: PUSH
49242: EMPTY
49243: LIST
49244: LIST
49245: PUSH
49246: LD_INT 4
49248: NEG
49249: PUSH
49250: LD_INT 1
49252: NEG
49253: PUSH
49254: EMPTY
49255: LIST
49256: LIST
49257: PUSH
49258: LD_INT 3
49260: NEG
49261: PUSH
49262: LD_INT 0
49264: PUSH
49265: EMPTY
49266: LIST
49267: LIST
49268: PUSH
49269: LD_INT 3
49271: NEG
49272: PUSH
49273: LD_INT 1
49275: PUSH
49276: EMPTY
49277: LIST
49278: LIST
49279: PUSH
49280: LD_INT 4
49282: NEG
49283: PUSH
49284: LD_INT 1
49286: PUSH
49287: EMPTY
49288: LIST
49289: LIST
49290: PUSH
49291: LD_INT 5
49293: NEG
49294: PUSH
49295: LD_INT 0
49297: PUSH
49298: EMPTY
49299: LIST
49300: LIST
49301: PUSH
49302: LD_INT 5
49304: NEG
49305: PUSH
49306: LD_INT 1
49308: NEG
49309: PUSH
49310: EMPTY
49311: LIST
49312: LIST
49313: PUSH
49314: LD_INT 5
49316: NEG
49317: PUSH
49318: LD_INT 2
49320: NEG
49321: PUSH
49322: EMPTY
49323: LIST
49324: LIST
49325: PUSH
49326: LD_INT 3
49328: NEG
49329: PUSH
49330: LD_INT 2
49332: PUSH
49333: EMPTY
49334: LIST
49335: LIST
49336: PUSH
49337: LD_INT 3
49339: NEG
49340: PUSH
49341: LD_INT 3
49343: NEG
49344: PUSH
49345: EMPTY
49346: LIST
49347: LIST
49348: PUSH
49349: LD_INT 3
49351: NEG
49352: PUSH
49353: LD_INT 4
49355: NEG
49356: PUSH
49357: EMPTY
49358: LIST
49359: LIST
49360: PUSH
49361: LD_INT 2
49363: NEG
49364: PUSH
49365: LD_INT 3
49367: NEG
49368: PUSH
49369: EMPTY
49370: LIST
49371: LIST
49372: PUSH
49373: LD_INT 2
49375: NEG
49376: PUSH
49377: LD_INT 2
49379: NEG
49380: PUSH
49381: EMPTY
49382: LIST
49383: LIST
49384: PUSH
49385: LD_INT 3
49387: NEG
49388: PUSH
49389: LD_INT 2
49391: NEG
49392: PUSH
49393: EMPTY
49394: LIST
49395: LIST
49396: PUSH
49397: LD_INT 4
49399: NEG
49400: PUSH
49401: LD_INT 3
49403: NEG
49404: PUSH
49405: EMPTY
49406: LIST
49407: LIST
49408: PUSH
49409: LD_INT 4
49411: NEG
49412: PUSH
49413: LD_INT 4
49415: NEG
49416: PUSH
49417: EMPTY
49418: LIST
49419: LIST
49420: PUSH
49421: LD_INT 2
49423: NEG
49424: PUSH
49425: LD_INT 4
49427: NEG
49428: PUSH
49429: EMPTY
49430: LIST
49431: LIST
49432: PUSH
49433: LD_INT 4
49435: NEG
49436: PUSH
49437: LD_INT 2
49439: NEG
49440: PUSH
49441: EMPTY
49442: LIST
49443: LIST
49444: PUSH
49445: LD_INT 0
49447: PUSH
49448: LD_INT 4
49450: NEG
49451: PUSH
49452: EMPTY
49453: LIST
49454: LIST
49455: PUSH
49456: LD_INT 0
49458: PUSH
49459: LD_INT 5
49461: NEG
49462: PUSH
49463: EMPTY
49464: LIST
49465: LIST
49466: PUSH
49467: LD_INT 1
49469: PUSH
49470: LD_INT 4
49472: NEG
49473: PUSH
49474: EMPTY
49475: LIST
49476: LIST
49477: PUSH
49478: LD_INT 1
49480: PUSH
49481: LD_INT 3
49483: NEG
49484: PUSH
49485: EMPTY
49486: LIST
49487: LIST
49488: PUSH
49489: LD_INT 0
49491: PUSH
49492: LD_INT 3
49494: NEG
49495: PUSH
49496: EMPTY
49497: LIST
49498: LIST
49499: PUSH
49500: LD_INT 1
49502: NEG
49503: PUSH
49504: LD_INT 4
49506: NEG
49507: PUSH
49508: EMPTY
49509: LIST
49510: LIST
49511: PUSH
49512: LD_INT 1
49514: NEG
49515: PUSH
49516: LD_INT 5
49518: NEG
49519: PUSH
49520: EMPTY
49521: LIST
49522: LIST
49523: PUSH
49524: LD_INT 2
49526: PUSH
49527: LD_INT 3
49529: NEG
49530: PUSH
49531: EMPTY
49532: LIST
49533: LIST
49534: PUSH
49535: LD_INT 2
49537: NEG
49538: PUSH
49539: LD_INT 5
49541: NEG
49542: PUSH
49543: EMPTY
49544: LIST
49545: LIST
49546: PUSH
49547: LD_INT 3
49549: PUSH
49550: LD_INT 0
49552: PUSH
49553: EMPTY
49554: LIST
49555: LIST
49556: PUSH
49557: LD_INT 3
49559: PUSH
49560: LD_INT 1
49562: NEG
49563: PUSH
49564: EMPTY
49565: LIST
49566: LIST
49567: PUSH
49568: LD_INT 4
49570: PUSH
49571: LD_INT 0
49573: PUSH
49574: EMPTY
49575: LIST
49576: LIST
49577: PUSH
49578: LD_INT 4
49580: PUSH
49581: LD_INT 1
49583: PUSH
49584: EMPTY
49585: LIST
49586: LIST
49587: PUSH
49588: LD_INT 3
49590: PUSH
49591: LD_INT 1
49593: PUSH
49594: EMPTY
49595: LIST
49596: LIST
49597: PUSH
49598: LD_INT 2
49600: PUSH
49601: LD_INT 0
49603: PUSH
49604: EMPTY
49605: LIST
49606: LIST
49607: PUSH
49608: LD_INT 2
49610: PUSH
49611: LD_INT 1
49613: NEG
49614: PUSH
49615: EMPTY
49616: LIST
49617: LIST
49618: PUSH
49619: LD_INT 2
49621: PUSH
49622: LD_INT 2
49624: NEG
49625: PUSH
49626: EMPTY
49627: LIST
49628: LIST
49629: PUSH
49630: LD_INT 4
49632: PUSH
49633: LD_INT 2
49635: PUSH
49636: EMPTY
49637: LIST
49638: LIST
49639: PUSH
49640: LD_INT 4
49642: PUSH
49643: LD_INT 4
49645: PUSH
49646: EMPTY
49647: LIST
49648: LIST
49649: PUSH
49650: LD_INT 4
49652: PUSH
49653: LD_INT 3
49655: PUSH
49656: EMPTY
49657: LIST
49658: LIST
49659: PUSH
49660: LD_INT 5
49662: PUSH
49663: LD_INT 4
49665: PUSH
49666: EMPTY
49667: LIST
49668: LIST
49669: PUSH
49670: LD_INT 5
49672: PUSH
49673: LD_INT 5
49675: PUSH
49676: EMPTY
49677: LIST
49678: LIST
49679: PUSH
49680: LD_INT 4
49682: PUSH
49683: LD_INT 5
49685: PUSH
49686: EMPTY
49687: LIST
49688: LIST
49689: PUSH
49690: LD_INT 3
49692: PUSH
49693: LD_INT 4
49695: PUSH
49696: EMPTY
49697: LIST
49698: LIST
49699: PUSH
49700: LD_INT 3
49702: PUSH
49703: LD_INT 3
49705: PUSH
49706: EMPTY
49707: LIST
49708: LIST
49709: PUSH
49710: LD_INT 5
49712: PUSH
49713: LD_INT 3
49715: PUSH
49716: EMPTY
49717: LIST
49718: LIST
49719: PUSH
49720: LD_INT 3
49722: PUSH
49723: LD_INT 5
49725: PUSH
49726: EMPTY
49727: LIST
49728: LIST
49729: PUSH
49730: EMPTY
49731: LIST
49732: LIST
49733: LIST
49734: LIST
49735: LIST
49736: LIST
49737: LIST
49738: LIST
49739: LIST
49740: LIST
49741: LIST
49742: LIST
49743: LIST
49744: LIST
49745: LIST
49746: LIST
49747: LIST
49748: LIST
49749: LIST
49750: LIST
49751: LIST
49752: LIST
49753: LIST
49754: LIST
49755: LIST
49756: LIST
49757: LIST
49758: LIST
49759: LIST
49760: LIST
49761: LIST
49762: LIST
49763: LIST
49764: LIST
49765: LIST
49766: LIST
49767: LIST
49768: LIST
49769: LIST
49770: LIST
49771: LIST
49772: LIST
49773: LIST
49774: LIST
49775: LIST
49776: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
49777: LD_ADDR_VAR 0 33
49781: PUSH
49782: LD_INT 4
49784: NEG
49785: PUSH
49786: LD_INT 4
49788: NEG
49789: PUSH
49790: EMPTY
49791: LIST
49792: LIST
49793: PUSH
49794: LD_INT 4
49796: NEG
49797: PUSH
49798: LD_INT 5
49800: NEG
49801: PUSH
49802: EMPTY
49803: LIST
49804: LIST
49805: PUSH
49806: LD_INT 3
49808: NEG
49809: PUSH
49810: LD_INT 4
49812: NEG
49813: PUSH
49814: EMPTY
49815: LIST
49816: LIST
49817: PUSH
49818: LD_INT 3
49820: NEG
49821: PUSH
49822: LD_INT 3
49824: NEG
49825: PUSH
49826: EMPTY
49827: LIST
49828: LIST
49829: PUSH
49830: LD_INT 4
49832: NEG
49833: PUSH
49834: LD_INT 3
49836: NEG
49837: PUSH
49838: EMPTY
49839: LIST
49840: LIST
49841: PUSH
49842: LD_INT 5
49844: NEG
49845: PUSH
49846: LD_INT 4
49848: NEG
49849: PUSH
49850: EMPTY
49851: LIST
49852: LIST
49853: PUSH
49854: LD_INT 5
49856: NEG
49857: PUSH
49858: LD_INT 5
49860: NEG
49861: PUSH
49862: EMPTY
49863: LIST
49864: LIST
49865: PUSH
49866: LD_INT 3
49868: NEG
49869: PUSH
49870: LD_INT 5
49872: NEG
49873: PUSH
49874: EMPTY
49875: LIST
49876: LIST
49877: PUSH
49878: LD_INT 5
49880: NEG
49881: PUSH
49882: LD_INT 3
49884: NEG
49885: PUSH
49886: EMPTY
49887: LIST
49888: LIST
49889: PUSH
49890: LD_INT 0
49892: PUSH
49893: LD_INT 3
49895: NEG
49896: PUSH
49897: EMPTY
49898: LIST
49899: LIST
49900: PUSH
49901: LD_INT 0
49903: PUSH
49904: LD_INT 4
49906: NEG
49907: PUSH
49908: EMPTY
49909: LIST
49910: LIST
49911: PUSH
49912: LD_INT 1
49914: PUSH
49915: LD_INT 3
49917: NEG
49918: PUSH
49919: EMPTY
49920: LIST
49921: LIST
49922: PUSH
49923: LD_INT 1
49925: PUSH
49926: LD_INT 2
49928: NEG
49929: PUSH
49930: EMPTY
49931: LIST
49932: LIST
49933: PUSH
49934: LD_INT 0
49936: PUSH
49937: LD_INT 2
49939: NEG
49940: PUSH
49941: EMPTY
49942: LIST
49943: LIST
49944: PUSH
49945: LD_INT 1
49947: NEG
49948: PUSH
49949: LD_INT 3
49951: NEG
49952: PUSH
49953: EMPTY
49954: LIST
49955: LIST
49956: PUSH
49957: LD_INT 1
49959: NEG
49960: PUSH
49961: LD_INT 4
49963: NEG
49964: PUSH
49965: EMPTY
49966: LIST
49967: LIST
49968: PUSH
49969: LD_INT 2
49971: PUSH
49972: LD_INT 2
49974: NEG
49975: PUSH
49976: EMPTY
49977: LIST
49978: LIST
49979: PUSH
49980: LD_INT 2
49982: NEG
49983: PUSH
49984: LD_INT 4
49986: NEG
49987: PUSH
49988: EMPTY
49989: LIST
49990: LIST
49991: PUSH
49992: LD_INT 4
49994: PUSH
49995: LD_INT 0
49997: PUSH
49998: EMPTY
49999: LIST
50000: LIST
50001: PUSH
50002: LD_INT 4
50004: PUSH
50005: LD_INT 1
50007: NEG
50008: PUSH
50009: EMPTY
50010: LIST
50011: LIST
50012: PUSH
50013: LD_INT 5
50015: PUSH
50016: LD_INT 0
50018: PUSH
50019: EMPTY
50020: LIST
50021: LIST
50022: PUSH
50023: LD_INT 5
50025: PUSH
50026: LD_INT 1
50028: PUSH
50029: EMPTY
50030: LIST
50031: LIST
50032: PUSH
50033: LD_INT 4
50035: PUSH
50036: LD_INT 1
50038: PUSH
50039: EMPTY
50040: LIST
50041: LIST
50042: PUSH
50043: LD_INT 3
50045: PUSH
50046: LD_INT 0
50048: PUSH
50049: EMPTY
50050: LIST
50051: LIST
50052: PUSH
50053: LD_INT 3
50055: PUSH
50056: LD_INT 1
50058: NEG
50059: PUSH
50060: EMPTY
50061: LIST
50062: LIST
50063: PUSH
50064: LD_INT 3
50066: PUSH
50067: LD_INT 2
50069: NEG
50070: PUSH
50071: EMPTY
50072: LIST
50073: LIST
50074: PUSH
50075: LD_INT 5
50077: PUSH
50078: LD_INT 2
50080: PUSH
50081: EMPTY
50082: LIST
50083: LIST
50084: PUSH
50085: LD_INT 3
50087: PUSH
50088: LD_INT 3
50090: PUSH
50091: EMPTY
50092: LIST
50093: LIST
50094: PUSH
50095: LD_INT 3
50097: PUSH
50098: LD_INT 2
50100: PUSH
50101: EMPTY
50102: LIST
50103: LIST
50104: PUSH
50105: LD_INT 4
50107: PUSH
50108: LD_INT 3
50110: PUSH
50111: EMPTY
50112: LIST
50113: LIST
50114: PUSH
50115: LD_INT 4
50117: PUSH
50118: LD_INT 4
50120: PUSH
50121: EMPTY
50122: LIST
50123: LIST
50124: PUSH
50125: LD_INT 3
50127: PUSH
50128: LD_INT 4
50130: PUSH
50131: EMPTY
50132: LIST
50133: LIST
50134: PUSH
50135: LD_INT 2
50137: PUSH
50138: LD_INT 3
50140: PUSH
50141: EMPTY
50142: LIST
50143: LIST
50144: PUSH
50145: LD_INT 2
50147: PUSH
50148: LD_INT 2
50150: PUSH
50151: EMPTY
50152: LIST
50153: LIST
50154: PUSH
50155: LD_INT 4
50157: PUSH
50158: LD_INT 2
50160: PUSH
50161: EMPTY
50162: LIST
50163: LIST
50164: PUSH
50165: LD_INT 2
50167: PUSH
50168: LD_INT 4
50170: PUSH
50171: EMPTY
50172: LIST
50173: LIST
50174: PUSH
50175: LD_INT 0
50177: PUSH
50178: LD_INT 4
50180: PUSH
50181: EMPTY
50182: LIST
50183: LIST
50184: PUSH
50185: LD_INT 0
50187: PUSH
50188: LD_INT 3
50190: PUSH
50191: EMPTY
50192: LIST
50193: LIST
50194: PUSH
50195: LD_INT 1
50197: PUSH
50198: LD_INT 4
50200: PUSH
50201: EMPTY
50202: LIST
50203: LIST
50204: PUSH
50205: LD_INT 1
50207: PUSH
50208: LD_INT 5
50210: PUSH
50211: EMPTY
50212: LIST
50213: LIST
50214: PUSH
50215: LD_INT 0
50217: PUSH
50218: LD_INT 5
50220: PUSH
50221: EMPTY
50222: LIST
50223: LIST
50224: PUSH
50225: LD_INT 1
50227: NEG
50228: PUSH
50229: LD_INT 4
50231: PUSH
50232: EMPTY
50233: LIST
50234: LIST
50235: PUSH
50236: LD_INT 1
50238: NEG
50239: PUSH
50240: LD_INT 3
50242: PUSH
50243: EMPTY
50244: LIST
50245: LIST
50246: PUSH
50247: LD_INT 2
50249: PUSH
50250: LD_INT 5
50252: PUSH
50253: EMPTY
50254: LIST
50255: LIST
50256: PUSH
50257: LD_INT 2
50259: NEG
50260: PUSH
50261: LD_INT 3
50263: PUSH
50264: EMPTY
50265: LIST
50266: LIST
50267: PUSH
50268: EMPTY
50269: LIST
50270: LIST
50271: LIST
50272: LIST
50273: LIST
50274: LIST
50275: LIST
50276: LIST
50277: LIST
50278: LIST
50279: LIST
50280: LIST
50281: LIST
50282: LIST
50283: LIST
50284: LIST
50285: LIST
50286: LIST
50287: LIST
50288: LIST
50289: LIST
50290: LIST
50291: LIST
50292: LIST
50293: LIST
50294: LIST
50295: LIST
50296: LIST
50297: LIST
50298: LIST
50299: LIST
50300: LIST
50301: LIST
50302: LIST
50303: LIST
50304: LIST
50305: LIST
50306: LIST
50307: LIST
50308: LIST
50309: LIST
50310: LIST
50311: LIST
50312: LIST
50313: LIST
50314: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
50315: LD_ADDR_VAR 0 34
50319: PUSH
50320: LD_INT 0
50322: PUSH
50323: LD_INT 4
50325: NEG
50326: PUSH
50327: EMPTY
50328: LIST
50329: LIST
50330: PUSH
50331: LD_INT 0
50333: PUSH
50334: LD_INT 5
50336: NEG
50337: PUSH
50338: EMPTY
50339: LIST
50340: LIST
50341: PUSH
50342: LD_INT 1
50344: PUSH
50345: LD_INT 4
50347: NEG
50348: PUSH
50349: EMPTY
50350: LIST
50351: LIST
50352: PUSH
50353: LD_INT 1
50355: PUSH
50356: LD_INT 3
50358: NEG
50359: PUSH
50360: EMPTY
50361: LIST
50362: LIST
50363: PUSH
50364: LD_INT 0
50366: PUSH
50367: LD_INT 3
50369: NEG
50370: PUSH
50371: EMPTY
50372: LIST
50373: LIST
50374: PUSH
50375: LD_INT 1
50377: NEG
50378: PUSH
50379: LD_INT 4
50381: NEG
50382: PUSH
50383: EMPTY
50384: LIST
50385: LIST
50386: PUSH
50387: LD_INT 1
50389: NEG
50390: PUSH
50391: LD_INT 5
50393: NEG
50394: PUSH
50395: EMPTY
50396: LIST
50397: LIST
50398: PUSH
50399: LD_INT 2
50401: PUSH
50402: LD_INT 3
50404: NEG
50405: PUSH
50406: EMPTY
50407: LIST
50408: LIST
50409: PUSH
50410: LD_INT 2
50412: NEG
50413: PUSH
50414: LD_INT 5
50416: NEG
50417: PUSH
50418: EMPTY
50419: LIST
50420: LIST
50421: PUSH
50422: LD_INT 3
50424: PUSH
50425: LD_INT 0
50427: PUSH
50428: EMPTY
50429: LIST
50430: LIST
50431: PUSH
50432: LD_INT 3
50434: PUSH
50435: LD_INT 1
50437: NEG
50438: PUSH
50439: EMPTY
50440: LIST
50441: LIST
50442: PUSH
50443: LD_INT 4
50445: PUSH
50446: LD_INT 0
50448: PUSH
50449: EMPTY
50450: LIST
50451: LIST
50452: PUSH
50453: LD_INT 4
50455: PUSH
50456: LD_INT 1
50458: PUSH
50459: EMPTY
50460: LIST
50461: LIST
50462: PUSH
50463: LD_INT 3
50465: PUSH
50466: LD_INT 1
50468: PUSH
50469: EMPTY
50470: LIST
50471: LIST
50472: PUSH
50473: LD_INT 2
50475: PUSH
50476: LD_INT 0
50478: PUSH
50479: EMPTY
50480: LIST
50481: LIST
50482: PUSH
50483: LD_INT 2
50485: PUSH
50486: LD_INT 1
50488: NEG
50489: PUSH
50490: EMPTY
50491: LIST
50492: LIST
50493: PUSH
50494: LD_INT 2
50496: PUSH
50497: LD_INT 2
50499: NEG
50500: PUSH
50501: EMPTY
50502: LIST
50503: LIST
50504: PUSH
50505: LD_INT 4
50507: PUSH
50508: LD_INT 2
50510: PUSH
50511: EMPTY
50512: LIST
50513: LIST
50514: PUSH
50515: LD_INT 4
50517: PUSH
50518: LD_INT 4
50520: PUSH
50521: EMPTY
50522: LIST
50523: LIST
50524: PUSH
50525: LD_INT 4
50527: PUSH
50528: LD_INT 3
50530: PUSH
50531: EMPTY
50532: LIST
50533: LIST
50534: PUSH
50535: LD_INT 5
50537: PUSH
50538: LD_INT 4
50540: PUSH
50541: EMPTY
50542: LIST
50543: LIST
50544: PUSH
50545: LD_INT 5
50547: PUSH
50548: LD_INT 5
50550: PUSH
50551: EMPTY
50552: LIST
50553: LIST
50554: PUSH
50555: LD_INT 4
50557: PUSH
50558: LD_INT 5
50560: PUSH
50561: EMPTY
50562: LIST
50563: LIST
50564: PUSH
50565: LD_INT 3
50567: PUSH
50568: LD_INT 4
50570: PUSH
50571: EMPTY
50572: LIST
50573: LIST
50574: PUSH
50575: LD_INT 3
50577: PUSH
50578: LD_INT 3
50580: PUSH
50581: EMPTY
50582: LIST
50583: LIST
50584: PUSH
50585: LD_INT 5
50587: PUSH
50588: LD_INT 3
50590: PUSH
50591: EMPTY
50592: LIST
50593: LIST
50594: PUSH
50595: LD_INT 3
50597: PUSH
50598: LD_INT 5
50600: PUSH
50601: EMPTY
50602: LIST
50603: LIST
50604: PUSH
50605: LD_INT 0
50607: PUSH
50608: LD_INT 3
50610: PUSH
50611: EMPTY
50612: LIST
50613: LIST
50614: PUSH
50615: LD_INT 0
50617: PUSH
50618: LD_INT 2
50620: PUSH
50621: EMPTY
50622: LIST
50623: LIST
50624: PUSH
50625: LD_INT 1
50627: PUSH
50628: LD_INT 3
50630: PUSH
50631: EMPTY
50632: LIST
50633: LIST
50634: PUSH
50635: LD_INT 1
50637: PUSH
50638: LD_INT 4
50640: PUSH
50641: EMPTY
50642: LIST
50643: LIST
50644: PUSH
50645: LD_INT 0
50647: PUSH
50648: LD_INT 4
50650: PUSH
50651: EMPTY
50652: LIST
50653: LIST
50654: PUSH
50655: LD_INT 1
50657: NEG
50658: PUSH
50659: LD_INT 3
50661: PUSH
50662: EMPTY
50663: LIST
50664: LIST
50665: PUSH
50666: LD_INT 1
50668: NEG
50669: PUSH
50670: LD_INT 2
50672: PUSH
50673: EMPTY
50674: LIST
50675: LIST
50676: PUSH
50677: LD_INT 2
50679: PUSH
50680: LD_INT 4
50682: PUSH
50683: EMPTY
50684: LIST
50685: LIST
50686: PUSH
50687: LD_INT 2
50689: NEG
50690: PUSH
50691: LD_INT 2
50693: PUSH
50694: EMPTY
50695: LIST
50696: LIST
50697: PUSH
50698: LD_INT 4
50700: NEG
50701: PUSH
50702: LD_INT 0
50704: PUSH
50705: EMPTY
50706: LIST
50707: LIST
50708: PUSH
50709: LD_INT 4
50711: NEG
50712: PUSH
50713: LD_INT 1
50715: NEG
50716: PUSH
50717: EMPTY
50718: LIST
50719: LIST
50720: PUSH
50721: LD_INT 3
50723: NEG
50724: PUSH
50725: LD_INT 0
50727: PUSH
50728: EMPTY
50729: LIST
50730: LIST
50731: PUSH
50732: LD_INT 3
50734: NEG
50735: PUSH
50736: LD_INT 1
50738: PUSH
50739: EMPTY
50740: LIST
50741: LIST
50742: PUSH
50743: LD_INT 4
50745: NEG
50746: PUSH
50747: LD_INT 1
50749: PUSH
50750: EMPTY
50751: LIST
50752: LIST
50753: PUSH
50754: LD_INT 5
50756: NEG
50757: PUSH
50758: LD_INT 0
50760: PUSH
50761: EMPTY
50762: LIST
50763: LIST
50764: PUSH
50765: LD_INT 5
50767: NEG
50768: PUSH
50769: LD_INT 1
50771: NEG
50772: PUSH
50773: EMPTY
50774: LIST
50775: LIST
50776: PUSH
50777: LD_INT 5
50779: NEG
50780: PUSH
50781: LD_INT 2
50783: NEG
50784: PUSH
50785: EMPTY
50786: LIST
50787: LIST
50788: PUSH
50789: LD_INT 3
50791: NEG
50792: PUSH
50793: LD_INT 2
50795: PUSH
50796: EMPTY
50797: LIST
50798: LIST
50799: PUSH
50800: EMPTY
50801: LIST
50802: LIST
50803: LIST
50804: LIST
50805: LIST
50806: LIST
50807: LIST
50808: LIST
50809: LIST
50810: LIST
50811: LIST
50812: LIST
50813: LIST
50814: LIST
50815: LIST
50816: LIST
50817: LIST
50818: LIST
50819: LIST
50820: LIST
50821: LIST
50822: LIST
50823: LIST
50824: LIST
50825: LIST
50826: LIST
50827: LIST
50828: LIST
50829: LIST
50830: LIST
50831: LIST
50832: LIST
50833: LIST
50834: LIST
50835: LIST
50836: LIST
50837: LIST
50838: LIST
50839: LIST
50840: LIST
50841: LIST
50842: LIST
50843: LIST
50844: LIST
50845: LIST
50846: ST_TO_ADDR
// end ; end ;
50847: GO 50850
50849: POP
// case btype of b_depot , b_warehouse :
50850: LD_VAR 0 1
50854: PUSH
50855: LD_INT 0
50857: DOUBLE
50858: EQUAL
50859: IFTRUE 50869
50861: LD_INT 1
50863: DOUBLE
50864: EQUAL
50865: IFTRUE 50869
50867: GO 51070
50869: POP
// case nation of nation_american :
50870: LD_VAR 0 5
50874: PUSH
50875: LD_INT 1
50877: DOUBLE
50878: EQUAL
50879: IFTRUE 50883
50881: GO 50939
50883: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
50884: LD_ADDR_VAR 0 9
50888: PUSH
50889: LD_VAR 0 11
50893: PUSH
50894: LD_VAR 0 12
50898: PUSH
50899: LD_VAR 0 13
50903: PUSH
50904: LD_VAR 0 14
50908: PUSH
50909: LD_VAR 0 15
50913: PUSH
50914: LD_VAR 0 16
50918: PUSH
50919: EMPTY
50920: LIST
50921: LIST
50922: LIST
50923: LIST
50924: LIST
50925: LIST
50926: PUSH
50927: LD_VAR 0 4
50931: PUSH
50932: LD_INT 1
50934: PLUS
50935: ARRAY
50936: ST_TO_ADDR
50937: GO 51068
50939: LD_INT 2
50941: DOUBLE
50942: EQUAL
50943: IFTRUE 50947
50945: GO 51003
50947: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
50948: LD_ADDR_VAR 0 9
50952: PUSH
50953: LD_VAR 0 17
50957: PUSH
50958: LD_VAR 0 18
50962: PUSH
50963: LD_VAR 0 19
50967: PUSH
50968: LD_VAR 0 20
50972: PUSH
50973: LD_VAR 0 21
50977: PUSH
50978: LD_VAR 0 22
50982: PUSH
50983: EMPTY
50984: LIST
50985: LIST
50986: LIST
50987: LIST
50988: LIST
50989: LIST
50990: PUSH
50991: LD_VAR 0 4
50995: PUSH
50996: LD_INT 1
50998: PLUS
50999: ARRAY
51000: ST_TO_ADDR
51001: GO 51068
51003: LD_INT 3
51005: DOUBLE
51006: EQUAL
51007: IFTRUE 51011
51009: GO 51067
51011: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
51012: LD_ADDR_VAR 0 9
51016: PUSH
51017: LD_VAR 0 23
51021: PUSH
51022: LD_VAR 0 24
51026: PUSH
51027: LD_VAR 0 25
51031: PUSH
51032: LD_VAR 0 26
51036: PUSH
51037: LD_VAR 0 27
51041: PUSH
51042: LD_VAR 0 28
51046: PUSH
51047: EMPTY
51048: LIST
51049: LIST
51050: LIST
51051: LIST
51052: LIST
51053: LIST
51054: PUSH
51055: LD_VAR 0 4
51059: PUSH
51060: LD_INT 1
51062: PLUS
51063: ARRAY
51064: ST_TO_ADDR
51065: GO 51068
51067: POP
51068: GO 51623
51070: LD_INT 2
51072: DOUBLE
51073: EQUAL
51074: IFTRUE 51084
51076: LD_INT 3
51078: DOUBLE
51079: EQUAL
51080: IFTRUE 51084
51082: GO 51140
51084: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
51085: LD_ADDR_VAR 0 9
51089: PUSH
51090: LD_VAR 0 29
51094: PUSH
51095: LD_VAR 0 30
51099: PUSH
51100: LD_VAR 0 31
51104: PUSH
51105: LD_VAR 0 32
51109: PUSH
51110: LD_VAR 0 33
51114: PUSH
51115: LD_VAR 0 34
51119: PUSH
51120: EMPTY
51121: LIST
51122: LIST
51123: LIST
51124: LIST
51125: LIST
51126: LIST
51127: PUSH
51128: LD_VAR 0 4
51132: PUSH
51133: LD_INT 1
51135: PLUS
51136: ARRAY
51137: ST_TO_ADDR
51138: GO 51623
51140: LD_INT 16
51142: DOUBLE
51143: EQUAL
51144: IFTRUE 51202
51146: LD_INT 17
51148: DOUBLE
51149: EQUAL
51150: IFTRUE 51202
51152: LD_INT 18
51154: DOUBLE
51155: EQUAL
51156: IFTRUE 51202
51158: LD_INT 19
51160: DOUBLE
51161: EQUAL
51162: IFTRUE 51202
51164: LD_INT 22
51166: DOUBLE
51167: EQUAL
51168: IFTRUE 51202
51170: LD_INT 20
51172: DOUBLE
51173: EQUAL
51174: IFTRUE 51202
51176: LD_INT 21
51178: DOUBLE
51179: EQUAL
51180: IFTRUE 51202
51182: LD_INT 23
51184: DOUBLE
51185: EQUAL
51186: IFTRUE 51202
51188: LD_INT 24
51190: DOUBLE
51191: EQUAL
51192: IFTRUE 51202
51194: LD_INT 25
51196: DOUBLE
51197: EQUAL
51198: IFTRUE 51202
51200: GO 51258
51202: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
51203: LD_ADDR_VAR 0 9
51207: PUSH
51208: LD_VAR 0 35
51212: PUSH
51213: LD_VAR 0 36
51217: PUSH
51218: LD_VAR 0 37
51222: PUSH
51223: LD_VAR 0 38
51227: PUSH
51228: LD_VAR 0 39
51232: PUSH
51233: LD_VAR 0 40
51237: PUSH
51238: EMPTY
51239: LIST
51240: LIST
51241: LIST
51242: LIST
51243: LIST
51244: LIST
51245: PUSH
51246: LD_VAR 0 4
51250: PUSH
51251: LD_INT 1
51253: PLUS
51254: ARRAY
51255: ST_TO_ADDR
51256: GO 51623
51258: LD_INT 6
51260: DOUBLE
51261: EQUAL
51262: IFTRUE 51314
51264: LD_INT 7
51266: DOUBLE
51267: EQUAL
51268: IFTRUE 51314
51270: LD_INT 8
51272: DOUBLE
51273: EQUAL
51274: IFTRUE 51314
51276: LD_INT 13
51278: DOUBLE
51279: EQUAL
51280: IFTRUE 51314
51282: LD_INT 12
51284: DOUBLE
51285: EQUAL
51286: IFTRUE 51314
51288: LD_INT 15
51290: DOUBLE
51291: EQUAL
51292: IFTRUE 51314
51294: LD_INT 11
51296: DOUBLE
51297: EQUAL
51298: IFTRUE 51314
51300: LD_INT 14
51302: DOUBLE
51303: EQUAL
51304: IFTRUE 51314
51306: LD_INT 10
51308: DOUBLE
51309: EQUAL
51310: IFTRUE 51314
51312: GO 51370
51314: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
51315: LD_ADDR_VAR 0 9
51319: PUSH
51320: LD_VAR 0 41
51324: PUSH
51325: LD_VAR 0 42
51329: PUSH
51330: LD_VAR 0 43
51334: PUSH
51335: LD_VAR 0 44
51339: PUSH
51340: LD_VAR 0 45
51344: PUSH
51345: LD_VAR 0 46
51349: PUSH
51350: EMPTY
51351: LIST
51352: LIST
51353: LIST
51354: LIST
51355: LIST
51356: LIST
51357: PUSH
51358: LD_VAR 0 4
51362: PUSH
51363: LD_INT 1
51365: PLUS
51366: ARRAY
51367: ST_TO_ADDR
51368: GO 51623
51370: LD_INT 36
51372: DOUBLE
51373: EQUAL
51374: IFTRUE 51378
51376: GO 51434
51378: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
51379: LD_ADDR_VAR 0 9
51383: PUSH
51384: LD_VAR 0 47
51388: PUSH
51389: LD_VAR 0 48
51393: PUSH
51394: LD_VAR 0 49
51398: PUSH
51399: LD_VAR 0 50
51403: PUSH
51404: LD_VAR 0 51
51408: PUSH
51409: LD_VAR 0 52
51413: PUSH
51414: EMPTY
51415: LIST
51416: LIST
51417: LIST
51418: LIST
51419: LIST
51420: LIST
51421: PUSH
51422: LD_VAR 0 4
51426: PUSH
51427: LD_INT 1
51429: PLUS
51430: ARRAY
51431: ST_TO_ADDR
51432: GO 51623
51434: LD_INT 4
51436: DOUBLE
51437: EQUAL
51438: IFTRUE 51460
51440: LD_INT 5
51442: DOUBLE
51443: EQUAL
51444: IFTRUE 51460
51446: LD_INT 34
51448: DOUBLE
51449: EQUAL
51450: IFTRUE 51460
51452: LD_INT 37
51454: DOUBLE
51455: EQUAL
51456: IFTRUE 51460
51458: GO 51516
51460: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
51461: LD_ADDR_VAR 0 9
51465: PUSH
51466: LD_VAR 0 53
51470: PUSH
51471: LD_VAR 0 54
51475: PUSH
51476: LD_VAR 0 55
51480: PUSH
51481: LD_VAR 0 56
51485: PUSH
51486: LD_VAR 0 57
51490: PUSH
51491: LD_VAR 0 58
51495: PUSH
51496: EMPTY
51497: LIST
51498: LIST
51499: LIST
51500: LIST
51501: LIST
51502: LIST
51503: PUSH
51504: LD_VAR 0 4
51508: PUSH
51509: LD_INT 1
51511: PLUS
51512: ARRAY
51513: ST_TO_ADDR
51514: GO 51623
51516: LD_INT 31
51518: DOUBLE
51519: EQUAL
51520: IFTRUE 51566
51522: LD_INT 32
51524: DOUBLE
51525: EQUAL
51526: IFTRUE 51566
51528: LD_INT 33
51530: DOUBLE
51531: EQUAL
51532: IFTRUE 51566
51534: LD_INT 27
51536: DOUBLE
51537: EQUAL
51538: IFTRUE 51566
51540: LD_INT 26
51542: DOUBLE
51543: EQUAL
51544: IFTRUE 51566
51546: LD_INT 28
51548: DOUBLE
51549: EQUAL
51550: IFTRUE 51566
51552: LD_INT 29
51554: DOUBLE
51555: EQUAL
51556: IFTRUE 51566
51558: LD_INT 30
51560: DOUBLE
51561: EQUAL
51562: IFTRUE 51566
51564: GO 51622
51566: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
51567: LD_ADDR_VAR 0 9
51571: PUSH
51572: LD_VAR 0 59
51576: PUSH
51577: LD_VAR 0 60
51581: PUSH
51582: LD_VAR 0 61
51586: PUSH
51587: LD_VAR 0 62
51591: PUSH
51592: LD_VAR 0 63
51596: PUSH
51597: LD_VAR 0 64
51601: PUSH
51602: EMPTY
51603: LIST
51604: LIST
51605: LIST
51606: LIST
51607: LIST
51608: LIST
51609: PUSH
51610: LD_VAR 0 4
51614: PUSH
51615: LD_INT 1
51617: PLUS
51618: ARRAY
51619: ST_TO_ADDR
51620: GO 51623
51622: POP
// temp_list2 = [ ] ;
51623: LD_ADDR_VAR 0 10
51627: PUSH
51628: EMPTY
51629: ST_TO_ADDR
// for i in temp_list do
51630: LD_ADDR_VAR 0 8
51634: PUSH
51635: LD_VAR 0 9
51639: PUSH
51640: FOR_IN
51641: IFFALSE 51693
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
51643: LD_ADDR_VAR 0 10
51647: PUSH
51648: LD_VAR 0 10
51652: PUSH
51653: LD_VAR 0 8
51657: PUSH
51658: LD_INT 1
51660: ARRAY
51661: PUSH
51662: LD_VAR 0 2
51666: PLUS
51667: PUSH
51668: LD_VAR 0 8
51672: PUSH
51673: LD_INT 2
51675: ARRAY
51676: PUSH
51677: LD_VAR 0 3
51681: PLUS
51682: PUSH
51683: EMPTY
51684: LIST
51685: LIST
51686: PUSH
51687: EMPTY
51688: LIST
51689: ADD
51690: ST_TO_ADDR
51691: GO 51640
51693: POP
51694: POP
// result = temp_list2 ;
51695: LD_ADDR_VAR 0 7
51699: PUSH
51700: LD_VAR 0 10
51704: ST_TO_ADDR
// end ;
51705: LD_VAR 0 7
51709: RET
// export function EnemyInRange ( unit , dist ) ; begin
51710: LD_INT 0
51712: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
51713: LD_ADDR_VAR 0 3
51717: PUSH
51718: LD_VAR 0 1
51722: PPUSH
51723: CALL_OW 255
51727: PPUSH
51728: LD_VAR 0 1
51732: PPUSH
51733: CALL_OW 250
51737: PPUSH
51738: LD_VAR 0 1
51742: PPUSH
51743: CALL_OW 251
51747: PPUSH
51748: LD_VAR 0 2
51752: PPUSH
51753: CALL 25106 0 4
51757: PUSH
51758: LD_INT 4
51760: ARRAY
51761: ST_TO_ADDR
// end ;
51762: LD_VAR 0 3
51766: RET
// export function PlayerSeeMe ( unit ) ; begin
51767: LD_INT 0
51769: PPUSH
// result := See ( your_side , unit ) ;
51770: LD_ADDR_VAR 0 2
51774: PUSH
51775: LD_OWVAR 2
51779: PPUSH
51780: LD_VAR 0 1
51784: PPUSH
51785: CALL_OW 292
51789: ST_TO_ADDR
// end ;
51790: LD_VAR 0 2
51794: RET
// export function ReverseDir ( unit ) ; begin
51795: LD_INT 0
51797: PPUSH
// if not unit then
51798: LD_VAR 0 1
51802: NOT
51803: IFFALSE 51807
// exit ;
51805: GO 51830
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
51807: LD_ADDR_VAR 0 2
51811: PUSH
51812: LD_VAR 0 1
51816: PPUSH
51817: CALL_OW 254
51821: PUSH
51822: LD_INT 3
51824: PLUS
51825: PUSH
51826: LD_INT 6
51828: MOD
51829: ST_TO_ADDR
// end ;
51830: LD_VAR 0 2
51834: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
51835: LD_INT 0
51837: PPUSH
51838: PPUSH
51839: PPUSH
51840: PPUSH
51841: PPUSH
// if not hexes then
51842: LD_VAR 0 2
51846: NOT
51847: IFFALSE 51851
// exit ;
51849: GO 51999
// dist := 9999 ;
51851: LD_ADDR_VAR 0 5
51855: PUSH
51856: LD_INT 9999
51858: ST_TO_ADDR
// for i = 1 to hexes do
51859: LD_ADDR_VAR 0 4
51863: PUSH
51864: DOUBLE
51865: LD_INT 1
51867: DEC
51868: ST_TO_ADDR
51869: LD_VAR 0 2
51873: PUSH
51874: FOR_TO
51875: IFFALSE 51987
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
51877: LD_VAR 0 1
51881: PPUSH
51882: LD_VAR 0 2
51886: PUSH
51887: LD_VAR 0 4
51891: ARRAY
51892: PUSH
51893: LD_INT 1
51895: ARRAY
51896: PPUSH
51897: LD_VAR 0 2
51901: PUSH
51902: LD_VAR 0 4
51906: ARRAY
51907: PUSH
51908: LD_INT 2
51910: ARRAY
51911: PPUSH
51912: CALL_OW 297
51916: PUSH
51917: LD_VAR 0 5
51921: LESS
51922: IFFALSE 51985
// begin hex := hexes [ i ] ;
51924: LD_ADDR_VAR 0 7
51928: PUSH
51929: LD_VAR 0 2
51933: PUSH
51934: LD_VAR 0 4
51938: ARRAY
51939: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
51940: LD_ADDR_VAR 0 5
51944: PUSH
51945: LD_VAR 0 1
51949: PPUSH
51950: LD_VAR 0 2
51954: PUSH
51955: LD_VAR 0 4
51959: ARRAY
51960: PUSH
51961: LD_INT 1
51963: ARRAY
51964: PPUSH
51965: LD_VAR 0 2
51969: PUSH
51970: LD_VAR 0 4
51974: ARRAY
51975: PUSH
51976: LD_INT 2
51978: ARRAY
51979: PPUSH
51980: CALL_OW 297
51984: ST_TO_ADDR
// end ; end ;
51985: GO 51874
51987: POP
51988: POP
// result := hex ;
51989: LD_ADDR_VAR 0 3
51993: PUSH
51994: LD_VAR 0 7
51998: ST_TO_ADDR
// end ;
51999: LD_VAR 0 3
52003: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
52004: LD_INT 0
52006: PPUSH
52007: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
52008: LD_VAR 0 1
52012: NOT
52013: PUSH
52014: LD_VAR 0 1
52018: PUSH
52019: LD_INT 21
52021: PUSH
52022: LD_INT 2
52024: PUSH
52025: EMPTY
52026: LIST
52027: LIST
52028: PUSH
52029: LD_INT 23
52031: PUSH
52032: LD_INT 2
52034: PUSH
52035: EMPTY
52036: LIST
52037: LIST
52038: PUSH
52039: EMPTY
52040: LIST
52041: LIST
52042: PPUSH
52043: CALL_OW 69
52047: IN
52048: NOT
52049: OR
52050: IFFALSE 52054
// exit ;
52052: GO 52101
// for i = 1 to 3 do
52054: LD_ADDR_VAR 0 3
52058: PUSH
52059: DOUBLE
52060: LD_INT 1
52062: DEC
52063: ST_TO_ADDR
52064: LD_INT 3
52066: PUSH
52067: FOR_TO
52068: IFFALSE 52099
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
52070: LD_VAR 0 1
52074: PPUSH
52075: CALL_OW 250
52079: PPUSH
52080: LD_VAR 0 1
52084: PPUSH
52085: CALL_OW 251
52089: PPUSH
52090: LD_INT 1
52092: PPUSH
52093: CALL_OW 453
52097: GO 52067
52099: POP
52100: POP
// end ;
52101: LD_VAR 0 2
52105: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
52106: LD_INT 0
52108: PPUSH
52109: PPUSH
52110: PPUSH
52111: PPUSH
52112: PPUSH
52113: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
52114: LD_VAR 0 1
52118: NOT
52119: PUSH
52120: LD_VAR 0 2
52124: NOT
52125: OR
52126: PUSH
52127: LD_VAR 0 1
52131: PPUSH
52132: CALL_OW 314
52136: OR
52137: IFFALSE 52141
// exit ;
52139: GO 52582
// x := GetX ( enemy_unit ) ;
52141: LD_ADDR_VAR 0 7
52145: PUSH
52146: LD_VAR 0 2
52150: PPUSH
52151: CALL_OW 250
52155: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
52156: LD_ADDR_VAR 0 8
52160: PUSH
52161: LD_VAR 0 2
52165: PPUSH
52166: CALL_OW 251
52170: ST_TO_ADDR
// if not x or not y then
52171: LD_VAR 0 7
52175: NOT
52176: PUSH
52177: LD_VAR 0 8
52181: NOT
52182: OR
52183: IFFALSE 52187
// exit ;
52185: GO 52582
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
52187: LD_ADDR_VAR 0 6
52191: PUSH
52192: LD_VAR 0 7
52196: PPUSH
52197: LD_INT 0
52199: PPUSH
52200: LD_INT 4
52202: PPUSH
52203: CALL_OW 272
52207: PUSH
52208: LD_VAR 0 8
52212: PPUSH
52213: LD_INT 0
52215: PPUSH
52216: LD_INT 4
52218: PPUSH
52219: CALL_OW 273
52223: PUSH
52224: EMPTY
52225: LIST
52226: LIST
52227: PUSH
52228: LD_VAR 0 7
52232: PPUSH
52233: LD_INT 1
52235: PPUSH
52236: LD_INT 4
52238: PPUSH
52239: CALL_OW 272
52243: PUSH
52244: LD_VAR 0 8
52248: PPUSH
52249: LD_INT 1
52251: PPUSH
52252: LD_INT 4
52254: PPUSH
52255: CALL_OW 273
52259: PUSH
52260: EMPTY
52261: LIST
52262: LIST
52263: PUSH
52264: LD_VAR 0 7
52268: PPUSH
52269: LD_INT 2
52271: PPUSH
52272: LD_INT 4
52274: PPUSH
52275: CALL_OW 272
52279: PUSH
52280: LD_VAR 0 8
52284: PPUSH
52285: LD_INT 2
52287: PPUSH
52288: LD_INT 4
52290: PPUSH
52291: CALL_OW 273
52295: PUSH
52296: EMPTY
52297: LIST
52298: LIST
52299: PUSH
52300: LD_VAR 0 7
52304: PPUSH
52305: LD_INT 3
52307: PPUSH
52308: LD_INT 4
52310: PPUSH
52311: CALL_OW 272
52315: PUSH
52316: LD_VAR 0 8
52320: PPUSH
52321: LD_INT 3
52323: PPUSH
52324: LD_INT 4
52326: PPUSH
52327: CALL_OW 273
52331: PUSH
52332: EMPTY
52333: LIST
52334: LIST
52335: PUSH
52336: LD_VAR 0 7
52340: PPUSH
52341: LD_INT 4
52343: PPUSH
52344: LD_INT 4
52346: PPUSH
52347: CALL_OW 272
52351: PUSH
52352: LD_VAR 0 8
52356: PPUSH
52357: LD_INT 4
52359: PPUSH
52360: LD_INT 4
52362: PPUSH
52363: CALL_OW 273
52367: PUSH
52368: EMPTY
52369: LIST
52370: LIST
52371: PUSH
52372: LD_VAR 0 7
52376: PPUSH
52377: LD_INT 5
52379: PPUSH
52380: LD_INT 4
52382: PPUSH
52383: CALL_OW 272
52387: PUSH
52388: LD_VAR 0 8
52392: PPUSH
52393: LD_INT 5
52395: PPUSH
52396: LD_INT 4
52398: PPUSH
52399: CALL_OW 273
52403: PUSH
52404: EMPTY
52405: LIST
52406: LIST
52407: PUSH
52408: EMPTY
52409: LIST
52410: LIST
52411: LIST
52412: LIST
52413: LIST
52414: LIST
52415: ST_TO_ADDR
// for i = tmp downto 1 do
52416: LD_ADDR_VAR 0 4
52420: PUSH
52421: DOUBLE
52422: LD_VAR 0 6
52426: INC
52427: ST_TO_ADDR
52428: LD_INT 1
52430: PUSH
52431: FOR_DOWNTO
52432: IFFALSE 52533
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
52434: LD_VAR 0 6
52438: PUSH
52439: LD_VAR 0 4
52443: ARRAY
52444: PUSH
52445: LD_INT 1
52447: ARRAY
52448: PPUSH
52449: LD_VAR 0 6
52453: PUSH
52454: LD_VAR 0 4
52458: ARRAY
52459: PUSH
52460: LD_INT 2
52462: ARRAY
52463: PPUSH
52464: CALL_OW 488
52468: NOT
52469: PUSH
52470: LD_VAR 0 6
52474: PUSH
52475: LD_VAR 0 4
52479: ARRAY
52480: PUSH
52481: LD_INT 1
52483: ARRAY
52484: PPUSH
52485: LD_VAR 0 6
52489: PUSH
52490: LD_VAR 0 4
52494: ARRAY
52495: PUSH
52496: LD_INT 2
52498: ARRAY
52499: PPUSH
52500: CALL_OW 428
52504: PUSH
52505: LD_INT 0
52507: NONEQUAL
52508: OR
52509: IFFALSE 52531
// tmp := Delete ( tmp , i ) ;
52511: LD_ADDR_VAR 0 6
52515: PUSH
52516: LD_VAR 0 6
52520: PPUSH
52521: LD_VAR 0 4
52525: PPUSH
52526: CALL_OW 3
52530: ST_TO_ADDR
52531: GO 52431
52533: POP
52534: POP
// j := GetClosestHex ( unit , tmp ) ;
52535: LD_ADDR_VAR 0 5
52539: PUSH
52540: LD_VAR 0 1
52544: PPUSH
52545: LD_VAR 0 6
52549: PPUSH
52550: CALL 51835 0 2
52554: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
52555: LD_VAR 0 1
52559: PPUSH
52560: LD_VAR 0 5
52564: PUSH
52565: LD_INT 1
52567: ARRAY
52568: PPUSH
52569: LD_VAR 0 5
52573: PUSH
52574: LD_INT 2
52576: ARRAY
52577: PPUSH
52578: CALL_OW 111
// end ;
52582: LD_VAR 0 3
52586: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
52587: LD_INT 0
52589: PPUSH
52590: PPUSH
52591: PPUSH
// uc_side = 0 ;
52592: LD_ADDR_OWVAR 20
52596: PUSH
52597: LD_INT 0
52599: ST_TO_ADDR
// uc_nation = 0 ;
52600: LD_ADDR_OWVAR 21
52604: PUSH
52605: LD_INT 0
52607: ST_TO_ADDR
// InitHc_All ( ) ;
52608: CALL_OW 584
// InitVc ;
52612: CALL_OW 20
// if mastodonts then
52616: LD_VAR 0 6
52620: IFFALSE 52687
// for i = 1 to mastodonts do
52622: LD_ADDR_VAR 0 11
52626: PUSH
52627: DOUBLE
52628: LD_INT 1
52630: DEC
52631: ST_TO_ADDR
52632: LD_VAR 0 6
52636: PUSH
52637: FOR_TO
52638: IFFALSE 52685
// begin vc_chassis := 31 ;
52640: LD_ADDR_OWVAR 37
52644: PUSH
52645: LD_INT 31
52647: ST_TO_ADDR
// vc_control := control_rider ;
52648: LD_ADDR_OWVAR 38
52652: PUSH
52653: LD_INT 4
52655: ST_TO_ADDR
// animal := CreateVehicle ;
52656: LD_ADDR_VAR 0 12
52660: PUSH
52661: CALL_OW 45
52665: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
52666: LD_VAR 0 12
52670: PPUSH
52671: LD_VAR 0 8
52675: PPUSH
52676: LD_INT 0
52678: PPUSH
52679: CALL 54875 0 3
// end ;
52683: GO 52637
52685: POP
52686: POP
// if horses then
52687: LD_VAR 0 5
52691: IFFALSE 52758
// for i = 1 to horses do
52693: LD_ADDR_VAR 0 11
52697: PUSH
52698: DOUBLE
52699: LD_INT 1
52701: DEC
52702: ST_TO_ADDR
52703: LD_VAR 0 5
52707: PUSH
52708: FOR_TO
52709: IFFALSE 52756
// begin hc_class := 21 ;
52711: LD_ADDR_OWVAR 28
52715: PUSH
52716: LD_INT 21
52718: ST_TO_ADDR
// hc_gallery :=  ;
52719: LD_ADDR_OWVAR 33
52723: PUSH
52724: LD_STRING 
52726: ST_TO_ADDR
// animal := CreateHuman ;
52727: LD_ADDR_VAR 0 12
52731: PUSH
52732: CALL_OW 44
52736: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
52737: LD_VAR 0 12
52741: PPUSH
52742: LD_VAR 0 8
52746: PPUSH
52747: LD_INT 0
52749: PPUSH
52750: CALL 54875 0 3
// end ;
52754: GO 52708
52756: POP
52757: POP
// if birds then
52758: LD_VAR 0 1
52762: IFFALSE 52829
// for i = 1 to birds do
52764: LD_ADDR_VAR 0 11
52768: PUSH
52769: DOUBLE
52770: LD_INT 1
52772: DEC
52773: ST_TO_ADDR
52774: LD_VAR 0 1
52778: PUSH
52779: FOR_TO
52780: IFFALSE 52827
// begin hc_class = 18 ;
52782: LD_ADDR_OWVAR 28
52786: PUSH
52787: LD_INT 18
52789: ST_TO_ADDR
// hc_gallery =  ;
52790: LD_ADDR_OWVAR 33
52794: PUSH
52795: LD_STRING 
52797: ST_TO_ADDR
// animal := CreateHuman ;
52798: LD_ADDR_VAR 0 12
52802: PUSH
52803: CALL_OW 44
52807: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
52808: LD_VAR 0 12
52812: PPUSH
52813: LD_VAR 0 8
52817: PPUSH
52818: LD_INT 0
52820: PPUSH
52821: CALL 54875 0 3
// end ;
52825: GO 52779
52827: POP
52828: POP
// if tigers then
52829: LD_VAR 0 2
52833: IFFALSE 52917
// for i = 1 to tigers do
52835: LD_ADDR_VAR 0 11
52839: PUSH
52840: DOUBLE
52841: LD_INT 1
52843: DEC
52844: ST_TO_ADDR
52845: LD_VAR 0 2
52849: PUSH
52850: FOR_TO
52851: IFFALSE 52915
// begin hc_class = class_tiger ;
52853: LD_ADDR_OWVAR 28
52857: PUSH
52858: LD_INT 14
52860: ST_TO_ADDR
// hc_gallery =  ;
52861: LD_ADDR_OWVAR 33
52865: PUSH
52866: LD_STRING 
52868: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
52869: LD_ADDR_OWVAR 35
52873: PUSH
52874: LD_INT 7
52876: NEG
52877: PPUSH
52878: LD_INT 7
52880: PPUSH
52881: CALL_OW 12
52885: ST_TO_ADDR
// animal := CreateHuman ;
52886: LD_ADDR_VAR 0 12
52890: PUSH
52891: CALL_OW 44
52895: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
52896: LD_VAR 0 12
52900: PPUSH
52901: LD_VAR 0 8
52905: PPUSH
52906: LD_INT 0
52908: PPUSH
52909: CALL 54875 0 3
// end ;
52913: GO 52850
52915: POP
52916: POP
// if apemans then
52917: LD_VAR 0 3
52921: IFFALSE 53044
// for i = 1 to apemans do
52923: LD_ADDR_VAR 0 11
52927: PUSH
52928: DOUBLE
52929: LD_INT 1
52931: DEC
52932: ST_TO_ADDR
52933: LD_VAR 0 3
52937: PUSH
52938: FOR_TO
52939: IFFALSE 53042
// begin hc_class = class_apeman ;
52941: LD_ADDR_OWVAR 28
52945: PUSH
52946: LD_INT 12
52948: ST_TO_ADDR
// hc_gallery =  ;
52949: LD_ADDR_OWVAR 33
52953: PUSH
52954: LD_STRING 
52956: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
52957: LD_ADDR_OWVAR 35
52961: PUSH
52962: LD_INT 2
52964: NEG
52965: PPUSH
52966: LD_INT 2
52968: PPUSH
52969: CALL_OW 12
52973: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
52974: LD_ADDR_OWVAR 31
52978: PUSH
52979: LD_INT 1
52981: PPUSH
52982: LD_INT 3
52984: PPUSH
52985: CALL_OW 12
52989: PUSH
52990: LD_INT 1
52992: PPUSH
52993: LD_INT 3
52995: PPUSH
52996: CALL_OW 12
53000: PUSH
53001: LD_INT 0
53003: PUSH
53004: LD_INT 0
53006: PUSH
53007: EMPTY
53008: LIST
53009: LIST
53010: LIST
53011: LIST
53012: ST_TO_ADDR
// animal := CreateHuman ;
53013: LD_ADDR_VAR 0 12
53017: PUSH
53018: CALL_OW 44
53022: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
53023: LD_VAR 0 12
53027: PPUSH
53028: LD_VAR 0 8
53032: PPUSH
53033: LD_INT 0
53035: PPUSH
53036: CALL 54875 0 3
// end ;
53040: GO 52938
53042: POP
53043: POP
// if enchidnas then
53044: LD_VAR 0 4
53048: IFFALSE 53115
// for i = 1 to enchidnas do
53050: LD_ADDR_VAR 0 11
53054: PUSH
53055: DOUBLE
53056: LD_INT 1
53058: DEC
53059: ST_TO_ADDR
53060: LD_VAR 0 4
53064: PUSH
53065: FOR_TO
53066: IFFALSE 53113
// begin hc_class = 13 ;
53068: LD_ADDR_OWVAR 28
53072: PUSH
53073: LD_INT 13
53075: ST_TO_ADDR
// hc_gallery =  ;
53076: LD_ADDR_OWVAR 33
53080: PUSH
53081: LD_STRING 
53083: ST_TO_ADDR
// animal := CreateHuman ;
53084: LD_ADDR_VAR 0 12
53088: PUSH
53089: CALL_OW 44
53093: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
53094: LD_VAR 0 12
53098: PPUSH
53099: LD_VAR 0 8
53103: PPUSH
53104: LD_INT 0
53106: PPUSH
53107: CALL 54875 0 3
// end ;
53111: GO 53065
53113: POP
53114: POP
// if fishes then
53115: LD_VAR 0 7
53119: IFFALSE 53186
// for i = 1 to fishes do
53121: LD_ADDR_VAR 0 11
53125: PUSH
53126: DOUBLE
53127: LD_INT 1
53129: DEC
53130: ST_TO_ADDR
53131: LD_VAR 0 7
53135: PUSH
53136: FOR_TO
53137: IFFALSE 53184
// begin hc_class = 20 ;
53139: LD_ADDR_OWVAR 28
53143: PUSH
53144: LD_INT 20
53146: ST_TO_ADDR
// hc_gallery =  ;
53147: LD_ADDR_OWVAR 33
53151: PUSH
53152: LD_STRING 
53154: ST_TO_ADDR
// animal := CreateHuman ;
53155: LD_ADDR_VAR 0 12
53159: PUSH
53160: CALL_OW 44
53164: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
53165: LD_VAR 0 12
53169: PPUSH
53170: LD_VAR 0 9
53174: PPUSH
53175: LD_INT 0
53177: PPUSH
53178: CALL 54875 0 3
// end ;
53182: GO 53136
53184: POP
53185: POP
// end ;
53186: LD_VAR 0 10
53190: RET
// export function WantHeal ( sci , unit ) ; begin
53191: LD_INT 0
53193: PPUSH
// if GetTaskList ( sci ) > 0 then
53194: LD_VAR 0 1
53198: PPUSH
53199: CALL_OW 437
53203: PUSH
53204: LD_INT 0
53206: GREATER
53207: IFFALSE 53277
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
53209: LD_VAR 0 1
53213: PPUSH
53214: CALL_OW 437
53218: PUSH
53219: LD_INT 1
53221: ARRAY
53222: PUSH
53223: LD_INT 1
53225: ARRAY
53226: PUSH
53227: LD_STRING l
53229: EQUAL
53230: PUSH
53231: LD_VAR 0 1
53235: PPUSH
53236: CALL_OW 437
53240: PUSH
53241: LD_INT 1
53243: ARRAY
53244: PUSH
53245: LD_INT 4
53247: ARRAY
53248: PUSH
53249: LD_VAR 0 2
53253: EQUAL
53254: AND
53255: IFFALSE 53267
// result := true else
53257: LD_ADDR_VAR 0 3
53261: PUSH
53262: LD_INT 1
53264: ST_TO_ADDR
53265: GO 53275
// result := false ;
53267: LD_ADDR_VAR 0 3
53271: PUSH
53272: LD_INT 0
53274: ST_TO_ADDR
// end else
53275: GO 53285
// result := false ;
53277: LD_ADDR_VAR 0 3
53281: PUSH
53282: LD_INT 0
53284: ST_TO_ADDR
// end ;
53285: LD_VAR 0 3
53289: RET
// export function HealTarget ( sci ) ; begin
53290: LD_INT 0
53292: PPUSH
// if not sci then
53293: LD_VAR 0 1
53297: NOT
53298: IFFALSE 53302
// exit ;
53300: GO 53367
// result := 0 ;
53302: LD_ADDR_VAR 0 2
53306: PUSH
53307: LD_INT 0
53309: ST_TO_ADDR
// if GetTaskList ( sci ) then
53310: LD_VAR 0 1
53314: PPUSH
53315: CALL_OW 437
53319: IFFALSE 53367
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
53321: LD_VAR 0 1
53325: PPUSH
53326: CALL_OW 437
53330: PUSH
53331: LD_INT 1
53333: ARRAY
53334: PUSH
53335: LD_INT 1
53337: ARRAY
53338: PUSH
53339: LD_STRING l
53341: EQUAL
53342: IFFALSE 53367
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
53344: LD_ADDR_VAR 0 2
53348: PUSH
53349: LD_VAR 0 1
53353: PPUSH
53354: CALL_OW 437
53358: PUSH
53359: LD_INT 1
53361: ARRAY
53362: PUSH
53363: LD_INT 4
53365: ARRAY
53366: ST_TO_ADDR
// end ;
53367: LD_VAR 0 2
53371: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
53372: LD_INT 0
53374: PPUSH
53375: PPUSH
53376: PPUSH
53377: PPUSH
// if not base_units then
53378: LD_VAR 0 1
53382: NOT
53383: IFFALSE 53387
// exit ;
53385: GO 53474
// result := false ;
53387: LD_ADDR_VAR 0 2
53391: PUSH
53392: LD_INT 0
53394: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
53395: LD_ADDR_VAR 0 5
53399: PUSH
53400: LD_VAR 0 1
53404: PPUSH
53405: LD_INT 21
53407: PUSH
53408: LD_INT 3
53410: PUSH
53411: EMPTY
53412: LIST
53413: LIST
53414: PPUSH
53415: CALL_OW 72
53419: ST_TO_ADDR
// if not tmp then
53420: LD_VAR 0 5
53424: NOT
53425: IFFALSE 53429
// exit ;
53427: GO 53474
// for i in tmp do
53429: LD_ADDR_VAR 0 3
53433: PUSH
53434: LD_VAR 0 5
53438: PUSH
53439: FOR_IN
53440: IFFALSE 53472
// begin result := EnemyInRange ( i , 22 ) ;
53442: LD_ADDR_VAR 0 2
53446: PUSH
53447: LD_VAR 0 3
53451: PPUSH
53452: LD_INT 22
53454: PPUSH
53455: CALL 51710 0 2
53459: ST_TO_ADDR
// if result then
53460: LD_VAR 0 2
53464: IFFALSE 53470
// exit ;
53466: POP
53467: POP
53468: GO 53474
// end ;
53470: GO 53439
53472: POP
53473: POP
// end ;
53474: LD_VAR 0 2
53478: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
53479: LD_INT 0
53481: PPUSH
53482: PPUSH
// if not units then
53483: LD_VAR 0 1
53487: NOT
53488: IFFALSE 53492
// exit ;
53490: GO 53562
// result := [ ] ;
53492: LD_ADDR_VAR 0 3
53496: PUSH
53497: EMPTY
53498: ST_TO_ADDR
// for i in units do
53499: LD_ADDR_VAR 0 4
53503: PUSH
53504: LD_VAR 0 1
53508: PUSH
53509: FOR_IN
53510: IFFALSE 53560
// if GetTag ( i ) = tag then
53512: LD_VAR 0 4
53516: PPUSH
53517: CALL_OW 110
53521: PUSH
53522: LD_VAR 0 2
53526: EQUAL
53527: IFFALSE 53558
// result := Replace ( result , result + 1 , i ) ;
53529: LD_ADDR_VAR 0 3
53533: PUSH
53534: LD_VAR 0 3
53538: PPUSH
53539: LD_VAR 0 3
53543: PUSH
53544: LD_INT 1
53546: PLUS
53547: PPUSH
53548: LD_VAR 0 4
53552: PPUSH
53553: CALL_OW 1
53557: ST_TO_ADDR
53558: GO 53509
53560: POP
53561: POP
// end ;
53562: LD_VAR 0 3
53566: RET
// export function IsDriver ( un ) ; begin
53567: LD_INT 0
53569: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
53570: LD_ADDR_VAR 0 2
53574: PUSH
53575: LD_VAR 0 1
53579: PUSH
53580: LD_INT 55
53582: PUSH
53583: EMPTY
53584: LIST
53585: PPUSH
53586: CALL_OW 69
53590: IN
53591: ST_TO_ADDR
// end ;
53592: LD_VAR 0 2
53596: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
53597: LD_INT 0
53599: PPUSH
53600: PPUSH
// list := [ ] ;
53601: LD_ADDR_VAR 0 5
53605: PUSH
53606: EMPTY
53607: ST_TO_ADDR
// case d of 0 :
53608: LD_VAR 0 3
53612: PUSH
53613: LD_INT 0
53615: DOUBLE
53616: EQUAL
53617: IFTRUE 53621
53619: GO 53754
53621: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
53622: LD_ADDR_VAR 0 5
53626: PUSH
53627: LD_VAR 0 1
53631: PUSH
53632: LD_INT 4
53634: MINUS
53635: PUSH
53636: LD_VAR 0 2
53640: PUSH
53641: LD_INT 4
53643: MINUS
53644: PUSH
53645: LD_INT 2
53647: PUSH
53648: EMPTY
53649: LIST
53650: LIST
53651: LIST
53652: PUSH
53653: LD_VAR 0 1
53657: PUSH
53658: LD_INT 3
53660: MINUS
53661: PUSH
53662: LD_VAR 0 2
53666: PUSH
53667: LD_INT 1
53669: PUSH
53670: EMPTY
53671: LIST
53672: LIST
53673: LIST
53674: PUSH
53675: LD_VAR 0 1
53679: PUSH
53680: LD_INT 4
53682: PLUS
53683: PUSH
53684: LD_VAR 0 2
53688: PUSH
53689: LD_INT 4
53691: PUSH
53692: EMPTY
53693: LIST
53694: LIST
53695: LIST
53696: PUSH
53697: LD_VAR 0 1
53701: PUSH
53702: LD_INT 3
53704: PLUS
53705: PUSH
53706: LD_VAR 0 2
53710: PUSH
53711: LD_INT 3
53713: PLUS
53714: PUSH
53715: LD_INT 5
53717: PUSH
53718: EMPTY
53719: LIST
53720: LIST
53721: LIST
53722: PUSH
53723: LD_VAR 0 1
53727: PUSH
53728: LD_VAR 0 2
53732: PUSH
53733: LD_INT 4
53735: PLUS
53736: PUSH
53737: LD_INT 0
53739: PUSH
53740: EMPTY
53741: LIST
53742: LIST
53743: LIST
53744: PUSH
53745: EMPTY
53746: LIST
53747: LIST
53748: LIST
53749: LIST
53750: LIST
53751: ST_TO_ADDR
// end ; 1 :
53752: GO 54452
53754: LD_INT 1
53756: DOUBLE
53757: EQUAL
53758: IFTRUE 53762
53760: GO 53895
53762: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
53763: LD_ADDR_VAR 0 5
53767: PUSH
53768: LD_VAR 0 1
53772: PUSH
53773: LD_VAR 0 2
53777: PUSH
53778: LD_INT 4
53780: MINUS
53781: PUSH
53782: LD_INT 3
53784: PUSH
53785: EMPTY
53786: LIST
53787: LIST
53788: LIST
53789: PUSH
53790: LD_VAR 0 1
53794: PUSH
53795: LD_INT 3
53797: MINUS
53798: PUSH
53799: LD_VAR 0 2
53803: PUSH
53804: LD_INT 3
53806: MINUS
53807: PUSH
53808: LD_INT 2
53810: PUSH
53811: EMPTY
53812: LIST
53813: LIST
53814: LIST
53815: PUSH
53816: LD_VAR 0 1
53820: PUSH
53821: LD_INT 4
53823: MINUS
53824: PUSH
53825: LD_VAR 0 2
53829: PUSH
53830: LD_INT 1
53832: PUSH
53833: EMPTY
53834: LIST
53835: LIST
53836: LIST
53837: PUSH
53838: LD_VAR 0 1
53842: PUSH
53843: LD_VAR 0 2
53847: PUSH
53848: LD_INT 3
53850: PLUS
53851: PUSH
53852: LD_INT 0
53854: PUSH
53855: EMPTY
53856: LIST
53857: LIST
53858: LIST
53859: PUSH
53860: LD_VAR 0 1
53864: PUSH
53865: LD_INT 4
53867: PLUS
53868: PUSH
53869: LD_VAR 0 2
53873: PUSH
53874: LD_INT 4
53876: PLUS
53877: PUSH
53878: LD_INT 5
53880: PUSH
53881: EMPTY
53882: LIST
53883: LIST
53884: LIST
53885: PUSH
53886: EMPTY
53887: LIST
53888: LIST
53889: LIST
53890: LIST
53891: LIST
53892: ST_TO_ADDR
// end ; 2 :
53893: GO 54452
53895: LD_INT 2
53897: DOUBLE
53898: EQUAL
53899: IFTRUE 53903
53901: GO 54032
53903: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
53904: LD_ADDR_VAR 0 5
53908: PUSH
53909: LD_VAR 0 1
53913: PUSH
53914: LD_VAR 0 2
53918: PUSH
53919: LD_INT 3
53921: MINUS
53922: PUSH
53923: LD_INT 3
53925: PUSH
53926: EMPTY
53927: LIST
53928: LIST
53929: LIST
53930: PUSH
53931: LD_VAR 0 1
53935: PUSH
53936: LD_INT 4
53938: PLUS
53939: PUSH
53940: LD_VAR 0 2
53944: PUSH
53945: LD_INT 4
53947: PUSH
53948: EMPTY
53949: LIST
53950: LIST
53951: LIST
53952: PUSH
53953: LD_VAR 0 1
53957: PUSH
53958: LD_VAR 0 2
53962: PUSH
53963: LD_INT 4
53965: PLUS
53966: PUSH
53967: LD_INT 0
53969: PUSH
53970: EMPTY
53971: LIST
53972: LIST
53973: LIST
53974: PUSH
53975: LD_VAR 0 1
53979: PUSH
53980: LD_INT 3
53982: MINUS
53983: PUSH
53984: LD_VAR 0 2
53988: PUSH
53989: LD_INT 1
53991: PUSH
53992: EMPTY
53993: LIST
53994: LIST
53995: LIST
53996: PUSH
53997: LD_VAR 0 1
54001: PUSH
54002: LD_INT 4
54004: MINUS
54005: PUSH
54006: LD_VAR 0 2
54010: PUSH
54011: LD_INT 4
54013: MINUS
54014: PUSH
54015: LD_INT 2
54017: PUSH
54018: EMPTY
54019: LIST
54020: LIST
54021: LIST
54022: PUSH
54023: EMPTY
54024: LIST
54025: LIST
54026: LIST
54027: LIST
54028: LIST
54029: ST_TO_ADDR
// end ; 3 :
54030: GO 54452
54032: LD_INT 3
54034: DOUBLE
54035: EQUAL
54036: IFTRUE 54040
54038: GO 54173
54040: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
54041: LD_ADDR_VAR 0 5
54045: PUSH
54046: LD_VAR 0 1
54050: PUSH
54051: LD_INT 3
54053: PLUS
54054: PUSH
54055: LD_VAR 0 2
54059: PUSH
54060: LD_INT 4
54062: PUSH
54063: EMPTY
54064: LIST
54065: LIST
54066: LIST
54067: PUSH
54068: LD_VAR 0 1
54072: PUSH
54073: LD_INT 4
54075: PLUS
54076: PUSH
54077: LD_VAR 0 2
54081: PUSH
54082: LD_INT 4
54084: PLUS
54085: PUSH
54086: LD_INT 5
54088: PUSH
54089: EMPTY
54090: LIST
54091: LIST
54092: LIST
54093: PUSH
54094: LD_VAR 0 1
54098: PUSH
54099: LD_INT 4
54101: MINUS
54102: PUSH
54103: LD_VAR 0 2
54107: PUSH
54108: LD_INT 1
54110: PUSH
54111: EMPTY
54112: LIST
54113: LIST
54114: LIST
54115: PUSH
54116: LD_VAR 0 1
54120: PUSH
54121: LD_VAR 0 2
54125: PUSH
54126: LD_INT 4
54128: MINUS
54129: PUSH
54130: LD_INT 3
54132: PUSH
54133: EMPTY
54134: LIST
54135: LIST
54136: LIST
54137: PUSH
54138: LD_VAR 0 1
54142: PUSH
54143: LD_INT 3
54145: MINUS
54146: PUSH
54147: LD_VAR 0 2
54151: PUSH
54152: LD_INT 3
54154: MINUS
54155: PUSH
54156: LD_INT 2
54158: PUSH
54159: EMPTY
54160: LIST
54161: LIST
54162: LIST
54163: PUSH
54164: EMPTY
54165: LIST
54166: LIST
54167: LIST
54168: LIST
54169: LIST
54170: ST_TO_ADDR
// end ; 4 :
54171: GO 54452
54173: LD_INT 4
54175: DOUBLE
54176: EQUAL
54177: IFTRUE 54181
54179: GO 54314
54181: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
54182: LD_ADDR_VAR 0 5
54186: PUSH
54187: LD_VAR 0 1
54191: PUSH
54192: LD_VAR 0 2
54196: PUSH
54197: LD_INT 4
54199: PLUS
54200: PUSH
54201: LD_INT 0
54203: PUSH
54204: EMPTY
54205: LIST
54206: LIST
54207: LIST
54208: PUSH
54209: LD_VAR 0 1
54213: PUSH
54214: LD_INT 3
54216: PLUS
54217: PUSH
54218: LD_VAR 0 2
54222: PUSH
54223: LD_INT 3
54225: PLUS
54226: PUSH
54227: LD_INT 5
54229: PUSH
54230: EMPTY
54231: LIST
54232: LIST
54233: LIST
54234: PUSH
54235: LD_VAR 0 1
54239: PUSH
54240: LD_INT 4
54242: PLUS
54243: PUSH
54244: LD_VAR 0 2
54248: PUSH
54249: LD_INT 4
54251: PUSH
54252: EMPTY
54253: LIST
54254: LIST
54255: LIST
54256: PUSH
54257: LD_VAR 0 1
54261: PUSH
54262: LD_VAR 0 2
54266: PUSH
54267: LD_INT 3
54269: MINUS
54270: PUSH
54271: LD_INT 3
54273: PUSH
54274: EMPTY
54275: LIST
54276: LIST
54277: LIST
54278: PUSH
54279: LD_VAR 0 1
54283: PUSH
54284: LD_INT 4
54286: MINUS
54287: PUSH
54288: LD_VAR 0 2
54292: PUSH
54293: LD_INT 4
54295: MINUS
54296: PUSH
54297: LD_INT 2
54299: PUSH
54300: EMPTY
54301: LIST
54302: LIST
54303: LIST
54304: PUSH
54305: EMPTY
54306: LIST
54307: LIST
54308: LIST
54309: LIST
54310: LIST
54311: ST_TO_ADDR
// end ; 5 :
54312: GO 54452
54314: LD_INT 5
54316: DOUBLE
54317: EQUAL
54318: IFTRUE 54322
54320: GO 54451
54322: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
54323: LD_ADDR_VAR 0 5
54327: PUSH
54328: LD_VAR 0 1
54332: PUSH
54333: LD_INT 4
54335: MINUS
54336: PUSH
54337: LD_VAR 0 2
54341: PUSH
54342: LD_INT 1
54344: PUSH
54345: EMPTY
54346: LIST
54347: LIST
54348: LIST
54349: PUSH
54350: LD_VAR 0 1
54354: PUSH
54355: LD_VAR 0 2
54359: PUSH
54360: LD_INT 4
54362: MINUS
54363: PUSH
54364: LD_INT 3
54366: PUSH
54367: EMPTY
54368: LIST
54369: LIST
54370: LIST
54371: PUSH
54372: LD_VAR 0 1
54376: PUSH
54377: LD_INT 4
54379: PLUS
54380: PUSH
54381: LD_VAR 0 2
54385: PUSH
54386: LD_INT 4
54388: PLUS
54389: PUSH
54390: LD_INT 5
54392: PUSH
54393: EMPTY
54394: LIST
54395: LIST
54396: LIST
54397: PUSH
54398: LD_VAR 0 1
54402: PUSH
54403: LD_INT 3
54405: PLUS
54406: PUSH
54407: LD_VAR 0 2
54411: PUSH
54412: LD_INT 4
54414: PUSH
54415: EMPTY
54416: LIST
54417: LIST
54418: LIST
54419: PUSH
54420: LD_VAR 0 1
54424: PUSH
54425: LD_VAR 0 2
54429: PUSH
54430: LD_INT 3
54432: PLUS
54433: PUSH
54434: LD_INT 0
54436: PUSH
54437: EMPTY
54438: LIST
54439: LIST
54440: LIST
54441: PUSH
54442: EMPTY
54443: LIST
54444: LIST
54445: LIST
54446: LIST
54447: LIST
54448: ST_TO_ADDR
// end ; end ;
54449: GO 54452
54451: POP
// result := list ;
54452: LD_ADDR_VAR 0 4
54456: PUSH
54457: LD_VAR 0 5
54461: ST_TO_ADDR
// end ;
54462: LD_VAR 0 4
54466: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
54467: LD_INT 0
54469: PPUSH
54470: PPUSH
54471: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
54472: LD_VAR 0 1
54476: NOT
54477: PUSH
54478: LD_VAR 0 2
54482: PUSH
54483: LD_INT 1
54485: PUSH
54486: LD_INT 2
54488: PUSH
54489: LD_INT 3
54491: PUSH
54492: LD_INT 4
54494: PUSH
54495: EMPTY
54496: LIST
54497: LIST
54498: LIST
54499: LIST
54500: IN
54501: NOT
54502: OR
54503: IFFALSE 54507
// exit ;
54505: GO 54599
// tmp := [ ] ;
54507: LD_ADDR_VAR 0 5
54511: PUSH
54512: EMPTY
54513: ST_TO_ADDR
// for i in units do
54514: LD_ADDR_VAR 0 4
54518: PUSH
54519: LD_VAR 0 1
54523: PUSH
54524: FOR_IN
54525: IFFALSE 54568
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
54527: LD_ADDR_VAR 0 5
54531: PUSH
54532: LD_VAR 0 5
54536: PPUSH
54537: LD_VAR 0 5
54541: PUSH
54542: LD_INT 1
54544: PLUS
54545: PPUSH
54546: LD_VAR 0 4
54550: PPUSH
54551: LD_VAR 0 2
54555: PPUSH
54556: CALL_OW 259
54560: PPUSH
54561: CALL_OW 2
54565: ST_TO_ADDR
54566: GO 54524
54568: POP
54569: POP
// if not tmp then
54570: LD_VAR 0 5
54574: NOT
54575: IFFALSE 54579
// exit ;
54577: GO 54599
// result := SortListByListDesc ( units , tmp ) ;
54579: LD_ADDR_VAR 0 3
54583: PUSH
54584: LD_VAR 0 1
54588: PPUSH
54589: LD_VAR 0 5
54593: PPUSH
54594: CALL_OW 77
54598: ST_TO_ADDR
// end ;
54599: LD_VAR 0 3
54603: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
54604: LD_INT 0
54606: PPUSH
54607: PPUSH
54608: PPUSH
// result := false ;
54609: LD_ADDR_VAR 0 3
54613: PUSH
54614: LD_INT 0
54616: ST_TO_ADDR
// x := GetX ( building ) ;
54617: LD_ADDR_VAR 0 4
54621: PUSH
54622: LD_VAR 0 2
54626: PPUSH
54627: CALL_OW 250
54631: ST_TO_ADDR
// y := GetY ( building ) ;
54632: LD_ADDR_VAR 0 5
54636: PUSH
54637: LD_VAR 0 2
54641: PPUSH
54642: CALL_OW 251
54646: ST_TO_ADDR
// if not building or not x or not y then
54647: LD_VAR 0 2
54651: NOT
54652: PUSH
54653: LD_VAR 0 4
54657: NOT
54658: OR
54659: PUSH
54660: LD_VAR 0 5
54664: NOT
54665: OR
54666: IFFALSE 54670
// exit ;
54668: GO 54762
// if GetTaskList ( unit ) then
54670: LD_VAR 0 1
54674: PPUSH
54675: CALL_OW 437
54679: IFFALSE 54762
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
54681: LD_STRING e
54683: PUSH
54684: LD_VAR 0 1
54688: PPUSH
54689: CALL_OW 437
54693: PUSH
54694: LD_INT 1
54696: ARRAY
54697: PUSH
54698: LD_INT 1
54700: ARRAY
54701: EQUAL
54702: PUSH
54703: LD_VAR 0 4
54707: PUSH
54708: LD_VAR 0 1
54712: PPUSH
54713: CALL_OW 437
54717: PUSH
54718: LD_INT 1
54720: ARRAY
54721: PUSH
54722: LD_INT 2
54724: ARRAY
54725: EQUAL
54726: AND
54727: PUSH
54728: LD_VAR 0 5
54732: PUSH
54733: LD_VAR 0 1
54737: PPUSH
54738: CALL_OW 437
54742: PUSH
54743: LD_INT 1
54745: ARRAY
54746: PUSH
54747: LD_INT 3
54749: ARRAY
54750: EQUAL
54751: AND
54752: IFFALSE 54762
// result := true end ;
54754: LD_ADDR_VAR 0 3
54758: PUSH
54759: LD_INT 1
54761: ST_TO_ADDR
// end ;
54762: LD_VAR 0 3
54766: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
54767: LD_INT 0
54769: PPUSH
// result := false ;
54770: LD_ADDR_VAR 0 4
54774: PUSH
54775: LD_INT 0
54777: ST_TO_ADDR
// if GetTaskList ( unit ) then
54778: LD_VAR 0 1
54782: PPUSH
54783: CALL_OW 437
54787: IFFALSE 54870
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
54789: LD_STRING M
54791: PUSH
54792: LD_VAR 0 1
54796: PPUSH
54797: CALL_OW 437
54801: PUSH
54802: LD_INT 1
54804: ARRAY
54805: PUSH
54806: LD_INT 1
54808: ARRAY
54809: EQUAL
54810: PUSH
54811: LD_VAR 0 2
54815: PUSH
54816: LD_VAR 0 1
54820: PPUSH
54821: CALL_OW 437
54825: PUSH
54826: LD_INT 1
54828: ARRAY
54829: PUSH
54830: LD_INT 2
54832: ARRAY
54833: EQUAL
54834: AND
54835: PUSH
54836: LD_VAR 0 3
54840: PUSH
54841: LD_VAR 0 1
54845: PPUSH
54846: CALL_OW 437
54850: PUSH
54851: LD_INT 1
54853: ARRAY
54854: PUSH
54855: LD_INT 3
54857: ARRAY
54858: EQUAL
54859: AND
54860: IFFALSE 54870
// result := true ;
54862: LD_ADDR_VAR 0 4
54866: PUSH
54867: LD_INT 1
54869: ST_TO_ADDR
// end ; end ;
54870: LD_VAR 0 4
54874: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
54875: LD_INT 0
54877: PPUSH
54878: PPUSH
54879: PPUSH
54880: PPUSH
// if not unit or not area then
54881: LD_VAR 0 1
54885: NOT
54886: PUSH
54887: LD_VAR 0 2
54891: NOT
54892: OR
54893: IFFALSE 54897
// exit ;
54895: GO 55061
// tmp := AreaToList ( area , i ) ;
54897: LD_ADDR_VAR 0 6
54901: PUSH
54902: LD_VAR 0 2
54906: PPUSH
54907: LD_VAR 0 5
54911: PPUSH
54912: CALL_OW 517
54916: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
54917: LD_ADDR_VAR 0 5
54921: PUSH
54922: DOUBLE
54923: LD_INT 1
54925: DEC
54926: ST_TO_ADDR
54927: LD_VAR 0 6
54931: PUSH
54932: LD_INT 1
54934: ARRAY
54935: PUSH
54936: FOR_TO
54937: IFFALSE 55059
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
54939: LD_ADDR_VAR 0 7
54943: PUSH
54944: LD_VAR 0 6
54948: PUSH
54949: LD_INT 1
54951: ARRAY
54952: PUSH
54953: LD_VAR 0 5
54957: ARRAY
54958: PUSH
54959: LD_VAR 0 6
54963: PUSH
54964: LD_INT 2
54966: ARRAY
54967: PUSH
54968: LD_VAR 0 5
54972: ARRAY
54973: PUSH
54974: EMPTY
54975: LIST
54976: LIST
54977: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
54978: LD_VAR 0 7
54982: PUSH
54983: LD_INT 1
54985: ARRAY
54986: PPUSH
54987: LD_VAR 0 7
54991: PUSH
54992: LD_INT 2
54994: ARRAY
54995: PPUSH
54996: CALL_OW 428
55000: PUSH
55001: LD_INT 0
55003: EQUAL
55004: IFFALSE 55057
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
55006: LD_VAR 0 1
55010: PPUSH
55011: LD_VAR 0 7
55015: PUSH
55016: LD_INT 1
55018: ARRAY
55019: PPUSH
55020: LD_VAR 0 7
55024: PUSH
55025: LD_INT 2
55027: ARRAY
55028: PPUSH
55029: LD_VAR 0 3
55033: PPUSH
55034: CALL_OW 48
// result := IsPlaced ( unit ) ;
55038: LD_ADDR_VAR 0 4
55042: PUSH
55043: LD_VAR 0 1
55047: PPUSH
55048: CALL_OW 305
55052: ST_TO_ADDR
// exit ;
55053: POP
55054: POP
55055: GO 55061
// end ; end ;
55057: GO 54936
55059: POP
55060: POP
// end ;
55061: LD_VAR 0 4
55065: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
55066: LD_INT 0
55068: PPUSH
55069: PPUSH
55070: PPUSH
// if not side or side > 8 then
55071: LD_VAR 0 1
55075: NOT
55076: PUSH
55077: LD_VAR 0 1
55081: PUSH
55082: LD_INT 8
55084: GREATER
55085: OR
55086: IFFALSE 55090
// exit ;
55088: GO 55277
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
55090: LD_ADDR_VAR 0 4
55094: PUSH
55095: LD_INT 22
55097: PUSH
55098: LD_VAR 0 1
55102: PUSH
55103: EMPTY
55104: LIST
55105: LIST
55106: PUSH
55107: LD_INT 21
55109: PUSH
55110: LD_INT 3
55112: PUSH
55113: EMPTY
55114: LIST
55115: LIST
55116: PUSH
55117: EMPTY
55118: LIST
55119: LIST
55120: PPUSH
55121: CALL_OW 69
55125: ST_TO_ADDR
// if not tmp then
55126: LD_VAR 0 4
55130: NOT
55131: IFFALSE 55135
// exit ;
55133: GO 55277
// enable_addtolog := true ;
55135: LD_ADDR_OWVAR 81
55139: PUSH
55140: LD_INT 1
55142: ST_TO_ADDR
// AddToLog ( [ ) ;
55143: LD_STRING [
55145: PPUSH
55146: CALL_OW 561
// for i in tmp do
55150: LD_ADDR_VAR 0 3
55154: PUSH
55155: LD_VAR 0 4
55159: PUSH
55160: FOR_IN
55161: IFFALSE 55268
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
55163: LD_STRING [
55165: PUSH
55166: LD_VAR 0 3
55170: PPUSH
55171: CALL_OW 266
55175: STR
55176: PUSH
55177: LD_STRING , 
55179: STR
55180: PUSH
55181: LD_VAR 0 3
55185: PPUSH
55186: CALL_OW 250
55190: STR
55191: PUSH
55192: LD_STRING , 
55194: STR
55195: PUSH
55196: LD_VAR 0 3
55200: PPUSH
55201: CALL_OW 251
55205: STR
55206: PUSH
55207: LD_STRING , 
55209: STR
55210: PUSH
55211: LD_VAR 0 3
55215: PPUSH
55216: CALL_OW 254
55220: STR
55221: PUSH
55222: LD_STRING , 
55224: STR
55225: PUSH
55226: LD_VAR 0 3
55230: PPUSH
55231: LD_INT 1
55233: PPUSH
55234: CALL_OW 268
55238: STR
55239: PUSH
55240: LD_STRING , 
55242: STR
55243: PUSH
55244: LD_VAR 0 3
55248: PPUSH
55249: LD_INT 2
55251: PPUSH
55252: CALL_OW 268
55256: STR
55257: PUSH
55258: LD_STRING ],
55260: STR
55261: PPUSH
55262: CALL_OW 561
// end ;
55266: GO 55160
55268: POP
55269: POP
// AddToLog ( ]; ) ;
55270: LD_STRING ];
55272: PPUSH
55273: CALL_OW 561
// end ;
55277: LD_VAR 0 2
55281: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
55282: LD_INT 0
55284: PPUSH
55285: PPUSH
55286: PPUSH
55287: PPUSH
55288: PPUSH
// if not area or not rate or not max then
55289: LD_VAR 0 1
55293: NOT
55294: PUSH
55295: LD_VAR 0 2
55299: NOT
55300: OR
55301: PUSH
55302: LD_VAR 0 4
55306: NOT
55307: OR
55308: IFFALSE 55312
// exit ;
55310: GO 55504
// while 1 do
55312: LD_INT 1
55314: IFFALSE 55504
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
55316: LD_ADDR_VAR 0 9
55320: PUSH
55321: LD_VAR 0 1
55325: PPUSH
55326: LD_INT 1
55328: PPUSH
55329: CALL_OW 287
55333: PUSH
55334: LD_INT 10
55336: MUL
55337: ST_TO_ADDR
// r := rate / 10 ;
55338: LD_ADDR_VAR 0 7
55342: PUSH
55343: LD_VAR 0 2
55347: PUSH
55348: LD_INT 10
55350: DIVREAL
55351: ST_TO_ADDR
// time := 1 1$00 ;
55352: LD_ADDR_VAR 0 8
55356: PUSH
55357: LD_INT 2100
55359: ST_TO_ADDR
// if amount < min then
55360: LD_VAR 0 9
55364: PUSH
55365: LD_VAR 0 3
55369: LESS
55370: IFFALSE 55388
// r := r * 2 else
55372: LD_ADDR_VAR 0 7
55376: PUSH
55377: LD_VAR 0 7
55381: PUSH
55382: LD_INT 2
55384: MUL
55385: ST_TO_ADDR
55386: GO 55414
// if amount > max then
55388: LD_VAR 0 9
55392: PUSH
55393: LD_VAR 0 4
55397: GREATER
55398: IFFALSE 55414
// r := r / 2 ;
55400: LD_ADDR_VAR 0 7
55404: PUSH
55405: LD_VAR 0 7
55409: PUSH
55410: LD_INT 2
55412: DIVREAL
55413: ST_TO_ADDR
// time := time / r ;
55414: LD_ADDR_VAR 0 8
55418: PUSH
55419: LD_VAR 0 8
55423: PUSH
55424: LD_VAR 0 7
55428: DIVREAL
55429: ST_TO_ADDR
// if time < 0 then
55430: LD_VAR 0 8
55434: PUSH
55435: LD_INT 0
55437: LESS
55438: IFFALSE 55455
// time := time * - 1 ;
55440: LD_ADDR_VAR 0 8
55444: PUSH
55445: LD_VAR 0 8
55449: PUSH
55450: LD_INT 1
55452: NEG
55453: MUL
55454: ST_TO_ADDR
// wait ( time ) ;
55455: LD_VAR 0 8
55459: PPUSH
55460: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
55464: LD_INT 35
55466: PPUSH
55467: LD_INT 875
55469: PPUSH
55470: CALL_OW 12
55474: PPUSH
55475: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
55479: LD_INT 1
55481: PPUSH
55482: LD_INT 5
55484: PPUSH
55485: CALL_OW 12
55489: PPUSH
55490: LD_VAR 0 1
55494: PPUSH
55495: LD_INT 1
55497: PPUSH
55498: CALL_OW 55
// end ;
55502: GO 55312
// end ;
55504: LD_VAR 0 5
55508: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
55509: LD_INT 0
55511: PPUSH
55512: PPUSH
55513: PPUSH
55514: PPUSH
55515: PPUSH
55516: PPUSH
55517: PPUSH
55518: PPUSH
// if not turrets or not factories then
55519: LD_VAR 0 1
55523: NOT
55524: PUSH
55525: LD_VAR 0 2
55529: NOT
55530: OR
55531: IFFALSE 55535
// exit ;
55533: GO 55842
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
55535: LD_ADDR_VAR 0 10
55539: PUSH
55540: LD_INT 5
55542: PUSH
55543: LD_INT 6
55545: PUSH
55546: EMPTY
55547: LIST
55548: LIST
55549: PUSH
55550: LD_INT 2
55552: PUSH
55553: LD_INT 4
55555: PUSH
55556: EMPTY
55557: LIST
55558: LIST
55559: PUSH
55560: LD_INT 3
55562: PUSH
55563: LD_INT 5
55565: PUSH
55566: EMPTY
55567: LIST
55568: LIST
55569: PUSH
55570: EMPTY
55571: LIST
55572: LIST
55573: LIST
55574: PUSH
55575: LD_INT 24
55577: PUSH
55578: LD_INT 25
55580: PUSH
55581: EMPTY
55582: LIST
55583: LIST
55584: PUSH
55585: LD_INT 23
55587: PUSH
55588: LD_INT 27
55590: PUSH
55591: EMPTY
55592: LIST
55593: LIST
55594: PUSH
55595: EMPTY
55596: LIST
55597: LIST
55598: PUSH
55599: LD_INT 42
55601: PUSH
55602: LD_INT 43
55604: PUSH
55605: EMPTY
55606: LIST
55607: LIST
55608: PUSH
55609: LD_INT 44
55611: PUSH
55612: LD_INT 46
55614: PUSH
55615: EMPTY
55616: LIST
55617: LIST
55618: PUSH
55619: LD_INT 45
55621: PUSH
55622: LD_INT 47
55624: PUSH
55625: EMPTY
55626: LIST
55627: LIST
55628: PUSH
55629: EMPTY
55630: LIST
55631: LIST
55632: LIST
55633: PUSH
55634: EMPTY
55635: LIST
55636: LIST
55637: LIST
55638: ST_TO_ADDR
// result := [ ] ;
55639: LD_ADDR_VAR 0 3
55643: PUSH
55644: EMPTY
55645: ST_TO_ADDR
// for i in turrets do
55646: LD_ADDR_VAR 0 4
55650: PUSH
55651: LD_VAR 0 1
55655: PUSH
55656: FOR_IN
55657: IFFALSE 55840
// begin nat := GetNation ( i ) ;
55659: LD_ADDR_VAR 0 7
55663: PUSH
55664: LD_VAR 0 4
55668: PPUSH
55669: CALL_OW 248
55673: ST_TO_ADDR
// weapon := 0 ;
55674: LD_ADDR_VAR 0 8
55678: PUSH
55679: LD_INT 0
55681: ST_TO_ADDR
// if not nat then
55682: LD_VAR 0 7
55686: NOT
55687: IFFALSE 55691
// continue ;
55689: GO 55656
// for j in list [ nat ] do
55691: LD_ADDR_VAR 0 5
55695: PUSH
55696: LD_VAR 0 10
55700: PUSH
55701: LD_VAR 0 7
55705: ARRAY
55706: PUSH
55707: FOR_IN
55708: IFFALSE 55749
// if GetBWeapon ( i ) = j [ 1 ] then
55710: LD_VAR 0 4
55714: PPUSH
55715: CALL_OW 269
55719: PUSH
55720: LD_VAR 0 5
55724: PUSH
55725: LD_INT 1
55727: ARRAY
55728: EQUAL
55729: IFFALSE 55747
// begin weapon := j [ 2 ] ;
55731: LD_ADDR_VAR 0 8
55735: PUSH
55736: LD_VAR 0 5
55740: PUSH
55741: LD_INT 2
55743: ARRAY
55744: ST_TO_ADDR
// break ;
55745: GO 55749
// end ;
55747: GO 55707
55749: POP
55750: POP
// if not weapon then
55751: LD_VAR 0 8
55755: NOT
55756: IFFALSE 55760
// continue ;
55758: GO 55656
// for k in factories do
55760: LD_ADDR_VAR 0 6
55764: PUSH
55765: LD_VAR 0 2
55769: PUSH
55770: FOR_IN
55771: IFFALSE 55836
// begin weapons := AvailableWeaponList ( k ) ;
55773: LD_ADDR_VAR 0 9
55777: PUSH
55778: LD_VAR 0 6
55782: PPUSH
55783: CALL_OW 478
55787: ST_TO_ADDR
// if not weapons then
55788: LD_VAR 0 9
55792: NOT
55793: IFFALSE 55797
// continue ;
55795: GO 55770
// if weapon in weapons then
55797: LD_VAR 0 8
55801: PUSH
55802: LD_VAR 0 9
55806: IN
55807: IFFALSE 55834
// begin result := [ i , weapon ] ;
55809: LD_ADDR_VAR 0 3
55813: PUSH
55814: LD_VAR 0 4
55818: PUSH
55819: LD_VAR 0 8
55823: PUSH
55824: EMPTY
55825: LIST
55826: LIST
55827: ST_TO_ADDR
// exit ;
55828: POP
55829: POP
55830: POP
55831: POP
55832: GO 55842
// end ; end ;
55834: GO 55770
55836: POP
55837: POP
// end ;
55838: GO 55656
55840: POP
55841: POP
// end ;
55842: LD_VAR 0 3
55846: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
55847: LD_INT 0
55849: PPUSH
// if not side or side > 8 then
55850: LD_VAR 0 3
55854: NOT
55855: PUSH
55856: LD_VAR 0 3
55860: PUSH
55861: LD_INT 8
55863: GREATER
55864: OR
55865: IFFALSE 55869
// exit ;
55867: GO 55928
// if not range then
55869: LD_VAR 0 4
55873: NOT
55874: IFFALSE 55885
// range := - 12 ;
55876: LD_ADDR_VAR 0 4
55880: PUSH
55881: LD_INT 12
55883: NEG
55884: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
55885: LD_VAR 0 1
55889: PPUSH
55890: LD_VAR 0 2
55894: PPUSH
55895: LD_VAR 0 3
55899: PPUSH
55900: LD_VAR 0 4
55904: PPUSH
55905: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
55909: LD_VAR 0 1
55913: PPUSH
55914: LD_VAR 0 2
55918: PPUSH
55919: LD_VAR 0 3
55923: PPUSH
55924: CALL_OW 331
// end ;
55928: LD_VAR 0 5
55932: RET
// export function Video ( mode ) ; begin
55933: LD_INT 0
55935: PPUSH
// ingame_video = mode ;
55936: LD_ADDR_OWVAR 52
55940: PUSH
55941: LD_VAR 0 1
55945: ST_TO_ADDR
// interface_hidden = mode ;
55946: LD_ADDR_OWVAR 54
55950: PUSH
55951: LD_VAR 0 1
55955: ST_TO_ADDR
// end ;
55956: LD_VAR 0 2
55960: RET
// export function Join ( array , element ) ; begin
55961: LD_INT 0
55963: PPUSH
// result := Replace ( array , array + 1 , element ) ;
55964: LD_ADDR_VAR 0 3
55968: PUSH
55969: LD_VAR 0 1
55973: PPUSH
55974: LD_VAR 0 1
55978: PUSH
55979: LD_INT 1
55981: PLUS
55982: PPUSH
55983: LD_VAR 0 2
55987: PPUSH
55988: CALL_OW 1
55992: ST_TO_ADDR
// end ;
55993: LD_VAR 0 3
55997: RET
// export function JoinUnion ( array , element ) ; begin
55998: LD_INT 0
56000: PPUSH
// result := array union element ;
56001: LD_ADDR_VAR 0 3
56005: PUSH
56006: LD_VAR 0 1
56010: PUSH
56011: LD_VAR 0 2
56015: UNION
56016: ST_TO_ADDR
// end ;
56017: LD_VAR 0 3
56021: RET
// export function GetBehemoths ( side ) ; begin
56022: LD_INT 0
56024: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
56025: LD_ADDR_VAR 0 2
56029: PUSH
56030: LD_INT 22
56032: PUSH
56033: LD_VAR 0 1
56037: PUSH
56038: EMPTY
56039: LIST
56040: LIST
56041: PUSH
56042: LD_INT 31
56044: PUSH
56045: LD_INT 25
56047: PUSH
56048: EMPTY
56049: LIST
56050: LIST
56051: PUSH
56052: EMPTY
56053: LIST
56054: LIST
56055: PPUSH
56056: CALL_OW 69
56060: ST_TO_ADDR
// end ;
56061: LD_VAR 0 2
56065: RET
// export function Shuffle ( array ) ; var i , index ; begin
56066: LD_INT 0
56068: PPUSH
56069: PPUSH
56070: PPUSH
// result := [ ] ;
56071: LD_ADDR_VAR 0 2
56075: PUSH
56076: EMPTY
56077: ST_TO_ADDR
// if not array then
56078: LD_VAR 0 1
56082: NOT
56083: IFFALSE 56087
// exit ;
56085: GO 56186
// Randomize ;
56087: CALL_OW 10
// for i = array downto 1 do
56091: LD_ADDR_VAR 0 3
56095: PUSH
56096: DOUBLE
56097: LD_VAR 0 1
56101: INC
56102: ST_TO_ADDR
56103: LD_INT 1
56105: PUSH
56106: FOR_DOWNTO
56107: IFFALSE 56184
// begin index := rand ( 1 , array ) ;
56109: LD_ADDR_VAR 0 4
56113: PUSH
56114: LD_INT 1
56116: PPUSH
56117: LD_VAR 0 1
56121: PPUSH
56122: CALL_OW 12
56126: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
56127: LD_ADDR_VAR 0 2
56131: PUSH
56132: LD_VAR 0 2
56136: PPUSH
56137: LD_VAR 0 2
56141: PUSH
56142: LD_INT 1
56144: PLUS
56145: PPUSH
56146: LD_VAR 0 1
56150: PUSH
56151: LD_VAR 0 4
56155: ARRAY
56156: PPUSH
56157: CALL_OW 2
56161: ST_TO_ADDR
// array := Delete ( array , index ) ;
56162: LD_ADDR_VAR 0 1
56166: PUSH
56167: LD_VAR 0 1
56171: PPUSH
56172: LD_VAR 0 4
56176: PPUSH
56177: CALL_OW 3
56181: ST_TO_ADDR
// end ;
56182: GO 56106
56184: POP
56185: POP
// end ;
56186: LD_VAR 0 2
56190: RET
// export function GetBaseMaterials ( base ) ; begin
56191: LD_INT 0
56193: PPUSH
// result := [ 0 , 0 , 0 ] ;
56194: LD_ADDR_VAR 0 2
56198: PUSH
56199: LD_INT 0
56201: PUSH
56202: LD_INT 0
56204: PUSH
56205: LD_INT 0
56207: PUSH
56208: EMPTY
56209: LIST
56210: LIST
56211: LIST
56212: ST_TO_ADDR
// if not base then
56213: LD_VAR 0 1
56217: NOT
56218: IFFALSE 56222
// exit ;
56220: GO 56271
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
56222: LD_ADDR_VAR 0 2
56226: PUSH
56227: LD_VAR 0 1
56231: PPUSH
56232: LD_INT 1
56234: PPUSH
56235: CALL_OW 275
56239: PUSH
56240: LD_VAR 0 1
56244: PPUSH
56245: LD_INT 2
56247: PPUSH
56248: CALL_OW 275
56252: PUSH
56253: LD_VAR 0 1
56257: PPUSH
56258: LD_INT 3
56260: PPUSH
56261: CALL_OW 275
56265: PUSH
56266: EMPTY
56267: LIST
56268: LIST
56269: LIST
56270: ST_TO_ADDR
// end ;
56271: LD_VAR 0 2
56275: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
56276: LD_INT 0
56278: PPUSH
56279: PPUSH
// result := array ;
56280: LD_ADDR_VAR 0 3
56284: PUSH
56285: LD_VAR 0 1
56289: ST_TO_ADDR
// if size > 0 then
56290: LD_VAR 0 2
56294: PUSH
56295: LD_INT 0
56297: GREATER
56298: IFFALSE 56344
// for i := array downto size do
56300: LD_ADDR_VAR 0 4
56304: PUSH
56305: DOUBLE
56306: LD_VAR 0 1
56310: INC
56311: ST_TO_ADDR
56312: LD_VAR 0 2
56316: PUSH
56317: FOR_DOWNTO
56318: IFFALSE 56342
// result := Delete ( result , result ) ;
56320: LD_ADDR_VAR 0 3
56324: PUSH
56325: LD_VAR 0 3
56329: PPUSH
56330: LD_VAR 0 3
56334: PPUSH
56335: CALL_OW 3
56339: ST_TO_ADDR
56340: GO 56317
56342: POP
56343: POP
// end ;
56344: LD_VAR 0 3
56348: RET
// export function ComExit ( unit ) ; var tmp ; begin
56349: LD_INT 0
56351: PPUSH
56352: PPUSH
// if not IsInUnit ( unit ) then
56353: LD_VAR 0 1
56357: PPUSH
56358: CALL_OW 310
56362: NOT
56363: IFFALSE 56367
// exit ;
56365: GO 56427
// tmp := IsInUnit ( unit ) ;
56367: LD_ADDR_VAR 0 3
56371: PUSH
56372: LD_VAR 0 1
56376: PPUSH
56377: CALL_OW 310
56381: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
56382: LD_VAR 0 3
56386: PPUSH
56387: CALL_OW 247
56391: PUSH
56392: LD_INT 2
56394: EQUAL
56395: IFFALSE 56408
// ComExitVehicle ( unit ) else
56397: LD_VAR 0 1
56401: PPUSH
56402: CALL_OW 121
56406: GO 56417
// ComExitBuilding ( unit ) ;
56408: LD_VAR 0 1
56412: PPUSH
56413: CALL_OW 122
// result := tmp ;
56417: LD_ADDR_VAR 0 2
56421: PUSH
56422: LD_VAR 0 3
56426: ST_TO_ADDR
// end ;
56427: LD_VAR 0 2
56431: RET
// export function ComExitAll ( units ) ; var i ; begin
56432: LD_INT 0
56434: PPUSH
56435: PPUSH
// if not units then
56436: LD_VAR 0 1
56440: NOT
56441: IFFALSE 56445
// exit ;
56443: GO 56471
// for i in units do
56445: LD_ADDR_VAR 0 3
56449: PUSH
56450: LD_VAR 0 1
56454: PUSH
56455: FOR_IN
56456: IFFALSE 56469
// ComExit ( i ) ;
56458: LD_VAR 0 3
56462: PPUSH
56463: CALL 56349 0 1
56467: GO 56455
56469: POP
56470: POP
// end ;
56471: LD_VAR 0 2
56475: RET
// export function ResetHc ; begin
56476: LD_INT 0
56478: PPUSH
// InitHc ;
56479: CALL_OW 19
// hc_importance := 0 ;
56483: LD_ADDR_OWVAR 32
56487: PUSH
56488: LD_INT 0
56490: ST_TO_ADDR
// end ;
56491: LD_VAR 0 1
56495: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
56496: LD_INT 0
56498: PPUSH
56499: PPUSH
56500: PPUSH
// _x := ( x1 + x2 ) div 2 ;
56501: LD_ADDR_VAR 0 6
56505: PUSH
56506: LD_VAR 0 1
56510: PUSH
56511: LD_VAR 0 3
56515: PLUS
56516: PUSH
56517: LD_INT 2
56519: DIV
56520: ST_TO_ADDR
// if _x < 0 then
56521: LD_VAR 0 6
56525: PUSH
56526: LD_INT 0
56528: LESS
56529: IFFALSE 56546
// _x := _x * - 1 ;
56531: LD_ADDR_VAR 0 6
56535: PUSH
56536: LD_VAR 0 6
56540: PUSH
56541: LD_INT 1
56543: NEG
56544: MUL
56545: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
56546: LD_ADDR_VAR 0 7
56550: PUSH
56551: LD_VAR 0 2
56555: PUSH
56556: LD_VAR 0 4
56560: PLUS
56561: PUSH
56562: LD_INT 2
56564: DIV
56565: ST_TO_ADDR
// if _y < 0 then
56566: LD_VAR 0 7
56570: PUSH
56571: LD_INT 0
56573: LESS
56574: IFFALSE 56591
// _y := _y * - 1 ;
56576: LD_ADDR_VAR 0 7
56580: PUSH
56581: LD_VAR 0 7
56585: PUSH
56586: LD_INT 1
56588: NEG
56589: MUL
56590: ST_TO_ADDR
// result := [ _x , _y ] ;
56591: LD_ADDR_VAR 0 5
56595: PUSH
56596: LD_VAR 0 6
56600: PUSH
56601: LD_VAR 0 7
56605: PUSH
56606: EMPTY
56607: LIST
56608: LIST
56609: ST_TO_ADDR
// end ;
56610: LD_VAR 0 5
56614: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
56615: LD_INT 0
56617: PPUSH
56618: PPUSH
56619: PPUSH
56620: PPUSH
// task := GetTaskList ( unit ) ;
56621: LD_ADDR_VAR 0 7
56625: PUSH
56626: LD_VAR 0 1
56630: PPUSH
56631: CALL_OW 437
56635: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
56636: LD_VAR 0 7
56640: NOT
56641: PUSH
56642: LD_VAR 0 1
56646: PPUSH
56647: LD_VAR 0 2
56651: PPUSH
56652: CALL_OW 308
56656: NOT
56657: AND
56658: IFFALSE 56662
// exit ;
56660: GO 56780
// if IsInArea ( unit , area ) then
56662: LD_VAR 0 1
56666: PPUSH
56667: LD_VAR 0 2
56671: PPUSH
56672: CALL_OW 308
56676: IFFALSE 56694
// begin ComMoveToArea ( unit , goAway ) ;
56678: LD_VAR 0 1
56682: PPUSH
56683: LD_VAR 0 3
56687: PPUSH
56688: CALL_OW 113
// exit ;
56692: GO 56780
// end ; if task [ 1 ] [ 1 ] <> M then
56694: LD_VAR 0 7
56698: PUSH
56699: LD_INT 1
56701: ARRAY
56702: PUSH
56703: LD_INT 1
56705: ARRAY
56706: PUSH
56707: LD_STRING M
56709: NONEQUAL
56710: IFFALSE 56714
// exit ;
56712: GO 56780
// x := task [ 1 ] [ 2 ] ;
56714: LD_ADDR_VAR 0 5
56718: PUSH
56719: LD_VAR 0 7
56723: PUSH
56724: LD_INT 1
56726: ARRAY
56727: PUSH
56728: LD_INT 2
56730: ARRAY
56731: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
56732: LD_ADDR_VAR 0 6
56736: PUSH
56737: LD_VAR 0 7
56741: PUSH
56742: LD_INT 1
56744: ARRAY
56745: PUSH
56746: LD_INT 3
56748: ARRAY
56749: ST_TO_ADDR
// if InArea ( x , y , area ) then
56750: LD_VAR 0 5
56754: PPUSH
56755: LD_VAR 0 6
56759: PPUSH
56760: LD_VAR 0 2
56764: PPUSH
56765: CALL_OW 309
56769: IFFALSE 56780
// ComStop ( unit ) ;
56771: LD_VAR 0 1
56775: PPUSH
56776: CALL_OW 141
// end ;
56780: LD_VAR 0 4
56784: RET
// export function Abs ( value ) ; begin
56785: LD_INT 0
56787: PPUSH
// result := value ;
56788: LD_ADDR_VAR 0 2
56792: PUSH
56793: LD_VAR 0 1
56797: ST_TO_ADDR
// if value < 0 then
56798: LD_VAR 0 1
56802: PUSH
56803: LD_INT 0
56805: LESS
56806: IFFALSE 56823
// result := value * - 1 ;
56808: LD_ADDR_VAR 0 2
56812: PUSH
56813: LD_VAR 0 1
56817: PUSH
56818: LD_INT 1
56820: NEG
56821: MUL
56822: ST_TO_ADDR
// end ;
56823: LD_VAR 0 2
56827: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
56828: LD_INT 0
56830: PPUSH
56831: PPUSH
56832: PPUSH
56833: PPUSH
56834: PPUSH
56835: PPUSH
56836: PPUSH
56837: PPUSH
// if not unit or not building then
56838: LD_VAR 0 1
56842: NOT
56843: PUSH
56844: LD_VAR 0 2
56848: NOT
56849: OR
56850: IFFALSE 56854
// exit ;
56852: GO 57080
// x := GetX ( building ) ;
56854: LD_ADDR_VAR 0 4
56858: PUSH
56859: LD_VAR 0 2
56863: PPUSH
56864: CALL_OW 250
56868: ST_TO_ADDR
// y := GetY ( building ) ;
56869: LD_ADDR_VAR 0 6
56873: PUSH
56874: LD_VAR 0 2
56878: PPUSH
56879: CALL_OW 251
56883: ST_TO_ADDR
// d := GetDir ( building ) ;
56884: LD_ADDR_VAR 0 8
56888: PUSH
56889: LD_VAR 0 2
56893: PPUSH
56894: CALL_OW 254
56898: ST_TO_ADDR
// r := 4 ;
56899: LD_ADDR_VAR 0 9
56903: PUSH
56904: LD_INT 4
56906: ST_TO_ADDR
// for i := 1 to 5 do
56907: LD_ADDR_VAR 0 10
56911: PUSH
56912: DOUBLE
56913: LD_INT 1
56915: DEC
56916: ST_TO_ADDR
56917: LD_INT 5
56919: PUSH
56920: FOR_TO
56921: IFFALSE 57078
// begin _x := ShiftX ( x , d , r + i ) ;
56923: LD_ADDR_VAR 0 5
56927: PUSH
56928: LD_VAR 0 4
56932: PPUSH
56933: LD_VAR 0 8
56937: PPUSH
56938: LD_VAR 0 9
56942: PUSH
56943: LD_VAR 0 10
56947: PLUS
56948: PPUSH
56949: CALL_OW 272
56953: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
56954: LD_ADDR_VAR 0 7
56958: PUSH
56959: LD_VAR 0 6
56963: PPUSH
56964: LD_VAR 0 8
56968: PPUSH
56969: LD_VAR 0 9
56973: PUSH
56974: LD_VAR 0 10
56978: PLUS
56979: PPUSH
56980: CALL_OW 273
56984: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
56985: LD_VAR 0 5
56989: PPUSH
56990: LD_VAR 0 7
56994: PPUSH
56995: CALL_OW 488
56999: PUSH
57000: LD_VAR 0 5
57004: PPUSH
57005: LD_VAR 0 7
57009: PPUSH
57010: CALL_OW 428
57014: PPUSH
57015: CALL_OW 247
57019: PUSH
57020: LD_INT 3
57022: PUSH
57023: LD_INT 2
57025: PUSH
57026: EMPTY
57027: LIST
57028: LIST
57029: IN
57030: NOT
57031: AND
57032: IFFALSE 57076
// begin ComMoveXY ( unit , _x , _y ) ;
57034: LD_VAR 0 1
57038: PPUSH
57039: LD_VAR 0 5
57043: PPUSH
57044: LD_VAR 0 7
57048: PPUSH
57049: CALL_OW 111
// result := [ _x , _y ] ;
57053: LD_ADDR_VAR 0 3
57057: PUSH
57058: LD_VAR 0 5
57062: PUSH
57063: LD_VAR 0 7
57067: PUSH
57068: EMPTY
57069: LIST
57070: LIST
57071: ST_TO_ADDR
// exit ;
57072: POP
57073: POP
57074: GO 57080
// end ; end ;
57076: GO 56920
57078: POP
57079: POP
// end ;
57080: LD_VAR 0 3
57084: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
57085: LD_INT 0
57087: PPUSH
57088: PPUSH
57089: PPUSH
// result := 0 ;
57090: LD_ADDR_VAR 0 3
57094: PUSH
57095: LD_INT 0
57097: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
57098: LD_VAR 0 1
57102: PUSH
57103: LD_INT 0
57105: LESS
57106: PUSH
57107: LD_VAR 0 1
57111: PUSH
57112: LD_INT 8
57114: GREATER
57115: OR
57116: PUSH
57117: LD_VAR 0 2
57121: PUSH
57122: LD_INT 0
57124: LESS
57125: OR
57126: PUSH
57127: LD_VAR 0 2
57131: PUSH
57132: LD_INT 8
57134: GREATER
57135: OR
57136: IFFALSE 57140
// exit ;
57138: GO 57215
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
57140: LD_ADDR_VAR 0 4
57144: PUSH
57145: LD_INT 22
57147: PUSH
57148: LD_VAR 0 2
57152: PUSH
57153: EMPTY
57154: LIST
57155: LIST
57156: PPUSH
57157: CALL_OW 69
57161: PUSH
57162: FOR_IN
57163: IFFALSE 57213
// begin un := UnitShoot ( i ) ;
57165: LD_ADDR_VAR 0 5
57169: PUSH
57170: LD_VAR 0 4
57174: PPUSH
57175: CALL_OW 504
57179: ST_TO_ADDR
// if GetSide ( un ) = side1 then
57180: LD_VAR 0 5
57184: PPUSH
57185: CALL_OW 255
57189: PUSH
57190: LD_VAR 0 1
57194: EQUAL
57195: IFFALSE 57211
// begin result := un ;
57197: LD_ADDR_VAR 0 3
57201: PUSH
57202: LD_VAR 0 5
57206: ST_TO_ADDR
// exit ;
57207: POP
57208: POP
57209: GO 57215
// end ; end ;
57211: GO 57162
57213: POP
57214: POP
// end ;
57215: LD_VAR 0 3
57219: RET
// export function GetCargoBay ( units ) ; begin
57220: LD_INT 0
57222: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
57223: LD_ADDR_VAR 0 2
57227: PUSH
57228: LD_VAR 0 1
57232: PPUSH
57233: LD_INT 2
57235: PUSH
57236: LD_INT 34
57238: PUSH
57239: LD_INT 12
57241: PUSH
57242: EMPTY
57243: LIST
57244: LIST
57245: PUSH
57246: LD_INT 34
57248: PUSH
57249: LD_INT 51
57251: PUSH
57252: EMPTY
57253: LIST
57254: LIST
57255: PUSH
57256: LD_INT 34
57258: PUSH
57259: LD_INT 32
57261: PUSH
57262: EMPTY
57263: LIST
57264: LIST
57265: PUSH
57266: LD_INT 34
57268: PUSH
57269: LD_EXP 155
57273: PUSH
57274: EMPTY
57275: LIST
57276: LIST
57277: PUSH
57278: EMPTY
57279: LIST
57280: LIST
57281: LIST
57282: LIST
57283: LIST
57284: PPUSH
57285: CALL_OW 72
57289: ST_TO_ADDR
// end ;
57290: LD_VAR 0 2
57294: RET
// export function Negate ( value ) ; begin
57295: LD_INT 0
57297: PPUSH
// result := not value ;
57298: LD_ADDR_VAR 0 2
57302: PUSH
57303: LD_VAR 0 1
57307: NOT
57308: ST_TO_ADDR
// end ;
57309: LD_VAR 0 2
57313: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; begin
57314: LD_INT 0
57316: PPUSH
// if x1 = x2 then
57317: LD_VAR 0 1
57321: PUSH
57322: LD_VAR 0 3
57326: EQUAL
57327: IFFALSE 57361
// begin if y1 > y2 then
57329: LD_VAR 0 2
57333: PUSH
57334: LD_VAR 0 4
57338: GREATER
57339: IFFALSE 57351
// result := 0 else
57341: LD_ADDR_VAR 0 5
57345: PUSH
57346: LD_INT 0
57348: ST_TO_ADDR
57349: GO 57359
// result := 3 ;
57351: LD_ADDR_VAR 0 5
57355: PUSH
57356: LD_INT 3
57358: ST_TO_ADDR
// exit ;
57359: GO 57447
// end ; if y1 = y2 then
57361: LD_VAR 0 2
57365: PUSH
57366: LD_VAR 0 4
57370: EQUAL
57371: IFFALSE 57405
// begin if x1 > x2 then
57373: LD_VAR 0 1
57377: PUSH
57378: LD_VAR 0 3
57382: GREATER
57383: IFFALSE 57395
// result := 1 else
57385: LD_ADDR_VAR 0 5
57389: PUSH
57390: LD_INT 1
57392: ST_TO_ADDR
57393: GO 57403
// result := 4 ;
57395: LD_ADDR_VAR 0 5
57399: PUSH
57400: LD_INT 4
57402: ST_TO_ADDR
// exit ;
57403: GO 57447
// end ; if x1 > x2 and y1 > y2 then
57405: LD_VAR 0 1
57409: PUSH
57410: LD_VAR 0 3
57414: GREATER
57415: PUSH
57416: LD_VAR 0 2
57420: PUSH
57421: LD_VAR 0 4
57425: GREATER
57426: AND
57427: IFFALSE 57439
// result := 2 else
57429: LD_ADDR_VAR 0 5
57433: PUSH
57434: LD_INT 2
57436: ST_TO_ADDR
57437: GO 57447
// result := 5 ;
57439: LD_ADDR_VAR 0 5
57443: PUSH
57444: LD_INT 5
57446: ST_TO_ADDR
// end ;
57447: LD_VAR 0 5
57451: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
57452: LD_INT 0
57454: PPUSH
57455: PPUSH
// if not driver or not IsInUnit ( driver ) then
57456: LD_VAR 0 1
57460: NOT
57461: PUSH
57462: LD_VAR 0 1
57466: PPUSH
57467: CALL_OW 310
57471: NOT
57472: OR
57473: IFFALSE 57477
// exit ;
57475: GO 57567
// vehicle := IsInUnit ( driver ) ;
57477: LD_ADDR_VAR 0 3
57481: PUSH
57482: LD_VAR 0 1
57486: PPUSH
57487: CALL_OW 310
57491: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
57492: LD_VAR 0 1
57496: PPUSH
57497: LD_STRING \
57499: PUSH
57500: LD_INT 0
57502: PUSH
57503: LD_INT 0
57505: PUSH
57506: LD_INT 0
57508: PUSH
57509: LD_INT 0
57511: PUSH
57512: LD_INT 0
57514: PUSH
57515: LD_INT 0
57517: PUSH
57518: EMPTY
57519: LIST
57520: LIST
57521: LIST
57522: LIST
57523: LIST
57524: LIST
57525: LIST
57526: PUSH
57527: LD_STRING E
57529: PUSH
57530: LD_INT 0
57532: PUSH
57533: LD_INT 0
57535: PUSH
57536: LD_VAR 0 3
57540: PUSH
57541: LD_INT 0
57543: PUSH
57544: LD_INT 0
57546: PUSH
57547: LD_INT 0
57549: PUSH
57550: EMPTY
57551: LIST
57552: LIST
57553: LIST
57554: LIST
57555: LIST
57556: LIST
57557: LIST
57558: PUSH
57559: EMPTY
57560: LIST
57561: LIST
57562: PPUSH
57563: CALL_OW 446
// end ;
57567: LD_VAR 0 2
57571: RET
// export function AddComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
57572: LD_INT 0
57574: PPUSH
57575: PPUSH
// if not driver or not IsInUnit ( driver ) then
57576: LD_VAR 0 1
57580: NOT
57581: PUSH
57582: LD_VAR 0 1
57586: PPUSH
57587: CALL_OW 310
57591: NOT
57592: OR
57593: IFFALSE 57597
// exit ;
57595: GO 57687
// vehicle := IsInUnit ( driver ) ;
57597: LD_ADDR_VAR 0 3
57601: PUSH
57602: LD_VAR 0 1
57606: PPUSH
57607: CALL_OW 310
57611: ST_TO_ADDR
// AddTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
57612: LD_VAR 0 1
57616: PPUSH
57617: LD_STRING \
57619: PUSH
57620: LD_INT 0
57622: PUSH
57623: LD_INT 0
57625: PUSH
57626: LD_INT 0
57628: PUSH
57629: LD_INT 0
57631: PUSH
57632: LD_INT 0
57634: PUSH
57635: LD_INT 0
57637: PUSH
57638: EMPTY
57639: LIST
57640: LIST
57641: LIST
57642: LIST
57643: LIST
57644: LIST
57645: LIST
57646: PUSH
57647: LD_STRING E
57649: PUSH
57650: LD_INT 0
57652: PUSH
57653: LD_INT 0
57655: PUSH
57656: LD_VAR 0 3
57660: PUSH
57661: LD_INT 0
57663: PUSH
57664: LD_INT 0
57666: PUSH
57667: LD_INT 0
57669: PUSH
57670: EMPTY
57671: LIST
57672: LIST
57673: LIST
57674: LIST
57675: LIST
57676: LIST
57677: LIST
57678: PUSH
57679: EMPTY
57680: LIST
57681: LIST
57682: PPUSH
57683: CALL_OW 447
// end ;
57687: LD_VAR 0 2
57691: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
57692: LD_INT 0
57694: PPUSH
57695: PPUSH
57696: PPUSH
// tmp := [ ] ;
57697: LD_ADDR_VAR 0 5
57701: PUSH
57702: EMPTY
57703: ST_TO_ADDR
// for i in units do
57704: LD_ADDR_VAR 0 4
57708: PUSH
57709: LD_VAR 0 1
57713: PUSH
57714: FOR_IN
57715: IFFALSE 57753
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
57717: LD_ADDR_VAR 0 5
57721: PUSH
57722: LD_VAR 0 5
57726: PPUSH
57727: LD_VAR 0 5
57731: PUSH
57732: LD_INT 1
57734: PLUS
57735: PPUSH
57736: LD_VAR 0 4
57740: PPUSH
57741: CALL_OW 256
57745: PPUSH
57746: CALL_OW 2
57750: ST_TO_ADDR
57751: GO 57714
57753: POP
57754: POP
// if not tmp then
57755: LD_VAR 0 5
57759: NOT
57760: IFFALSE 57764
// exit ;
57762: GO 57812
// if asc then
57764: LD_VAR 0 2
57768: IFFALSE 57792
// result := SortListByListAsc ( units , tmp ) else
57770: LD_ADDR_VAR 0 3
57774: PUSH
57775: LD_VAR 0 1
57779: PPUSH
57780: LD_VAR 0 5
57784: PPUSH
57785: CALL_OW 76
57789: ST_TO_ADDR
57790: GO 57812
// result := SortListByListDesc ( units , tmp ) ;
57792: LD_ADDR_VAR 0 3
57796: PUSH
57797: LD_VAR 0 1
57801: PPUSH
57802: LD_VAR 0 5
57806: PPUSH
57807: CALL_OW 77
57811: ST_TO_ADDR
// end ;
57812: LD_VAR 0 3
57816: RET
// export function WantToRepairVehicle ( mech , vehicle ) ; var task ; begin
57817: LD_INT 0
57819: PPUSH
57820: PPUSH
// task := GetTaskList ( mech ) ;
57821: LD_ADDR_VAR 0 4
57825: PUSH
57826: LD_VAR 0 1
57830: PPUSH
57831: CALL_OW 437
57835: ST_TO_ADDR
// if not task then
57836: LD_VAR 0 4
57840: NOT
57841: IFFALSE 57845
// exit ;
57843: GO 57887
// result := task [ 1 ] [ 1 ] = r and task [ 1 ] [ 4 ] = vehicle ;
57845: LD_ADDR_VAR 0 3
57849: PUSH
57850: LD_VAR 0 4
57854: PUSH
57855: LD_INT 1
57857: ARRAY
57858: PUSH
57859: LD_INT 1
57861: ARRAY
57862: PUSH
57863: LD_STRING r
57865: EQUAL
57866: PUSH
57867: LD_VAR 0 4
57871: PUSH
57872: LD_INT 1
57874: ARRAY
57875: PUSH
57876: LD_INT 4
57878: ARRAY
57879: PUSH
57880: LD_VAR 0 2
57884: EQUAL
57885: AND
57886: ST_TO_ADDR
// end ;
57887: LD_VAR 0 3
57891: RET
// export function PlaceUnitXYD ( unit , x , y , d , mode ) ; begin
57892: LD_INT 0
57894: PPUSH
// SetDir ( unit , d ) ;
57895: LD_VAR 0 1
57899: PPUSH
57900: LD_VAR 0 4
57904: PPUSH
57905: CALL_OW 233
// PlaceUnitXY ( unit , x , y , mode ) ;
57909: LD_VAR 0 1
57913: PPUSH
57914: LD_VAR 0 2
57918: PPUSH
57919: LD_VAR 0 3
57923: PPUSH
57924: LD_VAR 0 5
57928: PPUSH
57929: CALL_OW 48
// end ;
57933: LD_VAR 0 6
57937: RET
// export function ToNaturalNumber ( number ) ; begin
57938: LD_INT 0
57940: PPUSH
// result := number div 1 ;
57941: LD_ADDR_VAR 0 2
57945: PUSH
57946: LD_VAR 0 1
57950: PUSH
57951: LD_INT 1
57953: DIV
57954: ST_TO_ADDR
// if number < 0 then
57955: LD_VAR 0 1
57959: PUSH
57960: LD_INT 0
57962: LESS
57963: IFFALSE 57973
// result := 0 ;
57965: LD_ADDR_VAR 0 2
57969: PUSH
57970: LD_INT 0
57972: ST_TO_ADDR
// end ;
57973: LD_VAR 0 2
57977: RET
// export function SortByClass ( units , class ) ; var un ; begin
57978: LD_INT 0
57980: PPUSH
57981: PPUSH
// if not units or not class then
57982: LD_VAR 0 1
57986: NOT
57987: PUSH
57988: LD_VAR 0 2
57992: NOT
57993: OR
57994: IFFALSE 57998
// exit ;
57996: GO 58093
// result := [ ] ;
57998: LD_ADDR_VAR 0 3
58002: PUSH
58003: EMPTY
58004: ST_TO_ADDR
// for un in units do
58005: LD_ADDR_VAR 0 4
58009: PUSH
58010: LD_VAR 0 1
58014: PUSH
58015: FOR_IN
58016: IFFALSE 58091
// if GetClass ( un ) = class then
58018: LD_VAR 0 4
58022: PPUSH
58023: CALL_OW 257
58027: PUSH
58028: LD_VAR 0 2
58032: EQUAL
58033: IFFALSE 58060
// result := Insert ( result , 1 , un ) else
58035: LD_ADDR_VAR 0 3
58039: PUSH
58040: LD_VAR 0 3
58044: PPUSH
58045: LD_INT 1
58047: PPUSH
58048: LD_VAR 0 4
58052: PPUSH
58053: CALL_OW 2
58057: ST_TO_ADDR
58058: GO 58089
// result := Replace ( result , result + 1 , un ) ;
58060: LD_ADDR_VAR 0 3
58064: PUSH
58065: LD_VAR 0 3
58069: PPUSH
58070: LD_VAR 0 3
58074: PUSH
58075: LD_INT 1
58077: PLUS
58078: PPUSH
58079: LD_VAR 0 4
58083: PPUSH
58084: CALL_OW 1
58088: ST_TO_ADDR
58089: GO 58015
58091: POP
58092: POP
// end ;
58093: LD_VAR 0 3
58097: RET
// export function GetCratesNearbyXY ( x , y , r ) ; var _x , _y , min_y , min_x , max_x , max_y ; begin
58098: LD_INT 0
58100: PPUSH
58101: PPUSH
58102: PPUSH
58103: PPUSH
58104: PPUSH
58105: PPUSH
58106: PPUSH
// result := [ ] ;
58107: LD_ADDR_VAR 0 4
58111: PUSH
58112: EMPTY
58113: ST_TO_ADDR
// if x - r < 0 then
58114: LD_VAR 0 1
58118: PUSH
58119: LD_VAR 0 3
58123: MINUS
58124: PUSH
58125: LD_INT 0
58127: LESS
58128: IFFALSE 58140
// min_x := 0 else
58130: LD_ADDR_VAR 0 8
58134: PUSH
58135: LD_INT 0
58137: ST_TO_ADDR
58138: GO 58156
// min_x := x - r ;
58140: LD_ADDR_VAR 0 8
58144: PUSH
58145: LD_VAR 0 1
58149: PUSH
58150: LD_VAR 0 3
58154: MINUS
58155: ST_TO_ADDR
// if y - r < 0 then
58156: LD_VAR 0 2
58160: PUSH
58161: LD_VAR 0 3
58165: MINUS
58166: PUSH
58167: LD_INT 0
58169: LESS
58170: IFFALSE 58182
// min_y := 0 else
58172: LD_ADDR_VAR 0 7
58176: PUSH
58177: LD_INT 0
58179: ST_TO_ADDR
58180: GO 58198
// min_y := y - r ;
58182: LD_ADDR_VAR 0 7
58186: PUSH
58187: LD_VAR 0 2
58191: PUSH
58192: LD_VAR 0 3
58196: MINUS
58197: ST_TO_ADDR
// max_x := x + r ;
58198: LD_ADDR_VAR 0 9
58202: PUSH
58203: LD_VAR 0 1
58207: PUSH
58208: LD_VAR 0 3
58212: PLUS
58213: ST_TO_ADDR
// max_y := y + r ;
58214: LD_ADDR_VAR 0 10
58218: PUSH
58219: LD_VAR 0 2
58223: PUSH
58224: LD_VAR 0 3
58228: PLUS
58229: ST_TO_ADDR
// for _x = min_x to max_x do
58230: LD_ADDR_VAR 0 5
58234: PUSH
58235: DOUBLE
58236: LD_VAR 0 8
58240: DEC
58241: ST_TO_ADDR
58242: LD_VAR 0 9
58246: PUSH
58247: FOR_TO
58248: IFFALSE 58349
// for _y = min_y to max_y do
58250: LD_ADDR_VAR 0 6
58254: PUSH
58255: DOUBLE
58256: LD_VAR 0 7
58260: DEC
58261: ST_TO_ADDR
58262: LD_VAR 0 10
58266: PUSH
58267: FOR_TO
58268: IFFALSE 58345
// begin if not ValidHex ( _x , _y ) then
58270: LD_VAR 0 5
58274: PPUSH
58275: LD_VAR 0 6
58279: PPUSH
58280: CALL_OW 488
58284: NOT
58285: IFFALSE 58289
// continue ;
58287: GO 58267
// if GetResourceTypeXY ( _x , _y ) then
58289: LD_VAR 0 5
58293: PPUSH
58294: LD_VAR 0 6
58298: PPUSH
58299: CALL_OW 283
58303: IFFALSE 58343
// result := Replace ( result , result + 1 , [ _x , _y ] ) ;
58305: LD_ADDR_VAR 0 4
58309: PUSH
58310: LD_VAR 0 4
58314: PPUSH
58315: LD_VAR 0 4
58319: PUSH
58320: LD_INT 1
58322: PLUS
58323: PPUSH
58324: LD_VAR 0 5
58328: PUSH
58329: LD_VAR 0 6
58333: PUSH
58334: EMPTY
58335: LIST
58336: LIST
58337: PPUSH
58338: CALL_OW 1
58342: ST_TO_ADDR
// end ;
58343: GO 58267
58345: POP
58346: POP
58347: GO 58247
58349: POP
58350: POP
// end ;
58351: LD_VAR 0 4
58355: RET
// export function AgressiveMove ( units , path ) ; var i , enemy , cr , side , tag ; begin
58356: LD_INT 0
58358: PPUSH
58359: PPUSH
58360: PPUSH
58361: PPUSH
58362: PPUSH
58363: PPUSH
// if not units then
58364: LD_VAR 0 1
58368: NOT
58369: IFFALSE 58373
// exit ;
58371: GO 58774
// result := UnitFilter ( units , [ f_ok ] ) ;
58373: LD_ADDR_VAR 0 3
58377: PUSH
58378: LD_VAR 0 1
58382: PPUSH
58383: LD_INT 50
58385: PUSH
58386: EMPTY
58387: LIST
58388: PPUSH
58389: CALL_OW 72
58393: ST_TO_ADDR
// side := GetSide ( units [ 1 ] ) ;
58394: LD_ADDR_VAR 0 7
58398: PUSH
58399: LD_VAR 0 1
58403: PUSH
58404: LD_INT 1
58406: ARRAY
58407: PPUSH
58408: CALL_OW 255
58412: ST_TO_ADDR
// if not result then
58413: LD_VAR 0 3
58417: NOT
58418: IFFALSE 58422
// exit ;
58420: GO 58774
// for i in result do
58422: LD_ADDR_VAR 0 4
58426: PUSH
58427: LD_VAR 0 3
58431: PUSH
58432: FOR_IN
58433: IFFALSE 58772
// begin tag := GetTag ( i ) + 1 ;
58435: LD_ADDR_VAR 0 8
58439: PUSH
58440: LD_VAR 0 4
58444: PPUSH
58445: CALL_OW 110
58449: PUSH
58450: LD_INT 1
58452: PLUS
58453: ST_TO_ADDR
// cr := GetCratesNearbyXY ( GetX ( i ) , GetY ( i ) , 6 ) ;
58454: LD_ADDR_VAR 0 6
58458: PUSH
58459: LD_VAR 0 4
58463: PPUSH
58464: CALL_OW 250
58468: PPUSH
58469: LD_VAR 0 4
58473: PPUSH
58474: CALL_OW 251
58478: PPUSH
58479: LD_INT 6
58481: PPUSH
58482: CALL 58098 0 3
58486: ST_TO_ADDR
// if cr then
58487: LD_VAR 0 6
58491: IFFALSE 58530
// ComAttackPlace ( i , cr [ 1 ] [ 1 ] , cr [ 1 ] [ 2 ] ) else
58493: LD_VAR 0 4
58497: PPUSH
58498: LD_VAR 0 6
58502: PUSH
58503: LD_INT 1
58505: ARRAY
58506: PUSH
58507: LD_INT 1
58509: ARRAY
58510: PPUSH
58511: LD_VAR 0 6
58515: PUSH
58516: LD_INT 1
58518: ARRAY
58519: PUSH
58520: LD_INT 2
58522: ARRAY
58523: PPUSH
58524: CALL_OW 116
58528: GO 58770
// if path > tag then
58530: LD_VAR 0 2
58534: PUSH
58535: LD_VAR 0 8
58539: GREATER
58540: IFFALSE 58718
// begin enemy := FilterAllUnits ( [ [ f_enemy , side ] , [ f_dist , i , 12 ] ] ) ;
58542: LD_ADDR_VAR 0 5
58546: PUSH
58547: LD_INT 81
58549: PUSH
58550: LD_VAR 0 7
58554: PUSH
58555: EMPTY
58556: LIST
58557: LIST
58558: PUSH
58559: LD_INT 91
58561: PUSH
58562: LD_VAR 0 4
58566: PUSH
58567: LD_INT 12
58569: PUSH
58570: EMPTY
58571: LIST
58572: LIST
58573: LIST
58574: PUSH
58575: EMPTY
58576: LIST
58577: LIST
58578: PPUSH
58579: CALL_OW 69
58583: ST_TO_ADDR
// if enemy then
58584: LD_VAR 0 5
58588: IFFALSE 58616
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
58590: LD_VAR 0 4
58594: PPUSH
58595: LD_VAR 0 5
58599: PPUSH
58600: LD_VAR 0 4
58604: PPUSH
58605: CALL_OW 74
58609: PPUSH
58610: CALL_OW 115
58614: GO 58716
// if GetDistUnitXY ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) > 6 then
58616: LD_VAR 0 4
58620: PPUSH
58621: LD_VAR 0 2
58625: PUSH
58626: LD_VAR 0 8
58630: ARRAY
58631: PUSH
58632: LD_INT 1
58634: ARRAY
58635: PPUSH
58636: LD_VAR 0 2
58640: PUSH
58641: LD_VAR 0 8
58645: ARRAY
58646: PUSH
58647: LD_INT 2
58649: ARRAY
58650: PPUSH
58651: CALL_OW 297
58655: PUSH
58656: LD_INT 6
58658: GREATER
58659: IFFALSE 58702
// ComAgressiveMove ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) else
58661: LD_VAR 0 4
58665: PPUSH
58666: LD_VAR 0 2
58670: PUSH
58671: LD_VAR 0 8
58675: ARRAY
58676: PUSH
58677: LD_INT 1
58679: ARRAY
58680: PPUSH
58681: LD_VAR 0 2
58685: PUSH
58686: LD_VAR 0 8
58690: ARRAY
58691: PUSH
58692: LD_INT 2
58694: ARRAY
58695: PPUSH
58696: CALL_OW 114
58700: GO 58716
// SetTag ( i , tag ) ;
58702: LD_VAR 0 4
58706: PPUSH
58707: LD_VAR 0 8
58711: PPUSH
58712: CALL_OW 109
// end else
58716: GO 58770
// begin enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
58718: LD_ADDR_VAR 0 5
58722: PUSH
58723: LD_INT 81
58725: PUSH
58726: LD_VAR 0 7
58730: PUSH
58731: EMPTY
58732: LIST
58733: LIST
58734: PPUSH
58735: CALL_OW 69
58739: ST_TO_ADDR
// if enemy then
58740: LD_VAR 0 5
58744: IFFALSE 58770
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
58746: LD_VAR 0 4
58750: PPUSH
58751: LD_VAR 0 5
58755: PPUSH
58756: LD_VAR 0 4
58760: PPUSH
58761: CALL_OW 74
58765: PPUSH
58766: CALL_OW 115
// end ; end ;
58770: GO 58432
58772: POP
58773: POP
// end ; end_of_file
58774: LD_VAR 0 3
58778: RET
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
58779: LD_INT 0
58781: PPUSH
58782: PPUSH
58783: PPUSH
58784: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
58785: LD_VAR 0 1
58789: PPUSH
58790: CALL_OW 264
58794: PUSH
58795: LD_EXP 158
58799: EQUAL
58800: IFFALSE 58872
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
58802: LD_INT 68
58804: PPUSH
58805: LD_VAR 0 1
58809: PPUSH
58810: CALL_OW 255
58814: PPUSH
58815: CALL_OW 321
58819: PUSH
58820: LD_INT 2
58822: EQUAL
58823: IFFALSE 58835
// eff := 70 else
58825: LD_ADDR_VAR 0 4
58829: PUSH
58830: LD_INT 70
58832: ST_TO_ADDR
58833: GO 58843
// eff := 30 ;
58835: LD_ADDR_VAR 0 4
58839: PUSH
58840: LD_INT 30
58842: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
58843: LD_VAR 0 1
58847: PPUSH
58848: CALL_OW 250
58852: PPUSH
58853: LD_VAR 0 1
58857: PPUSH
58858: CALL_OW 251
58862: PPUSH
58863: LD_VAR 0 4
58867: PPUSH
58868: CALL_OW 495
// end ; end ;
58872: LD_VAR 0 2
58876: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
58877: LD_INT 0
58879: PPUSH
// end ;
58880: LD_VAR 0 4
58884: RET
// export function SOS_Command ( cmd ) ; begin
58885: LD_INT 0
58887: PPUSH
// end ;
58888: LD_VAR 0 2
58892: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
58893: LD_INT 0
58895: PPUSH
// if cmd = 121 then
58896: LD_VAR 0 1
58900: PUSH
58901: LD_INT 121
58903: EQUAL
58904: IFFALSE 58906
// end ;
58906: LD_VAR 0 6
58910: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
58911: LD_INT 0
58913: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
58914: LD_VAR 0 1
58918: PUSH
58919: LD_INT 250
58921: EQUAL
58922: PUSH
58923: LD_VAR 0 2
58927: PPUSH
58928: CALL_OW 264
58932: PUSH
58933: LD_EXP 161
58937: EQUAL
58938: AND
58939: IFFALSE 58960
// MinerPlaceMine ( unit , x , y ) ;
58941: LD_VAR 0 2
58945: PPUSH
58946: LD_VAR 0 4
58950: PPUSH
58951: LD_VAR 0 5
58955: PPUSH
58956: CALL 61309 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
58960: LD_VAR 0 1
58964: PUSH
58965: LD_INT 251
58967: EQUAL
58968: PUSH
58969: LD_VAR 0 2
58973: PPUSH
58974: CALL_OW 264
58978: PUSH
58979: LD_EXP 161
58983: EQUAL
58984: AND
58985: IFFALSE 59006
// MinerDetonateMine ( unit , x , y ) ;
58987: LD_VAR 0 2
58991: PPUSH
58992: LD_VAR 0 4
58996: PPUSH
58997: LD_VAR 0 5
59001: PPUSH
59002: CALL 61586 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
59006: LD_VAR 0 1
59010: PUSH
59011: LD_INT 252
59013: EQUAL
59014: PUSH
59015: LD_VAR 0 2
59019: PPUSH
59020: CALL_OW 264
59024: PUSH
59025: LD_EXP 161
59029: EQUAL
59030: AND
59031: IFFALSE 59052
// MinerCreateMinefield ( unit , x , y ) ;
59033: LD_VAR 0 2
59037: PPUSH
59038: LD_VAR 0 4
59042: PPUSH
59043: LD_VAR 0 5
59047: PPUSH
59048: CALL 62003 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
59052: LD_VAR 0 1
59056: PUSH
59057: LD_INT 253
59059: EQUAL
59060: PUSH
59061: LD_VAR 0 2
59065: PPUSH
59066: CALL_OW 257
59070: PUSH
59071: LD_INT 5
59073: EQUAL
59074: AND
59075: IFFALSE 59096
// ComBinocular ( unit , x , y ) ;
59077: LD_VAR 0 2
59081: PPUSH
59082: LD_VAR 0 4
59086: PPUSH
59087: LD_VAR 0 5
59091: PPUSH
59092: CALL 62374 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
59096: LD_VAR 0 1
59100: PUSH
59101: LD_INT 254
59103: EQUAL
59104: PUSH
59105: LD_VAR 0 2
59109: PPUSH
59110: CALL_OW 264
59114: PUSH
59115: LD_EXP 156
59119: EQUAL
59120: AND
59121: PUSH
59122: LD_VAR 0 3
59126: PPUSH
59127: CALL_OW 263
59131: PUSH
59132: LD_INT 3
59134: EQUAL
59135: AND
59136: IFFALSE 59152
// HackDestroyVehicle ( unit , selectedUnit ) ;
59138: LD_VAR 0 2
59142: PPUSH
59143: LD_VAR 0 3
59147: PPUSH
59148: CALL 60669 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
59152: LD_VAR 0 1
59156: PUSH
59157: LD_INT 255
59159: EQUAL
59160: PUSH
59161: LD_VAR 0 2
59165: PPUSH
59166: CALL_OW 264
59170: PUSH
59171: LD_INT 14
59173: PUSH
59174: LD_INT 53
59176: PUSH
59177: EMPTY
59178: LIST
59179: LIST
59180: IN
59181: AND
59182: PUSH
59183: LD_VAR 0 4
59187: PPUSH
59188: LD_VAR 0 5
59192: PPUSH
59193: CALL_OW 488
59197: AND
59198: IFFALSE 59222
// CutTreeXYR ( unit , x , y , 12 ) ;
59200: LD_VAR 0 2
59204: PPUSH
59205: LD_VAR 0 4
59209: PPUSH
59210: LD_VAR 0 5
59214: PPUSH
59215: LD_INT 12
59217: PPUSH
59218: CALL 59235 0 4
// end ;
59222: LD_VAR 0 6
59226: RET
// export initPlantMineScript , plantMineList ; export function ComGroupPlantMineXY ( units , x , y ) ; begin
59227: LD_INT 0
59229: PPUSH
// end ;
59230: LD_VAR 0 4
59234: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
59235: LD_INT 0
59237: PPUSH
59238: PPUSH
59239: PPUSH
59240: PPUSH
59241: PPUSH
59242: PPUSH
59243: PPUSH
59244: PPUSH
59245: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
59246: LD_VAR 0 1
59250: NOT
59251: PUSH
59252: LD_VAR 0 2
59256: PPUSH
59257: LD_VAR 0 3
59261: PPUSH
59262: CALL_OW 488
59266: NOT
59267: OR
59268: PUSH
59269: LD_VAR 0 4
59273: NOT
59274: OR
59275: IFFALSE 59279
// exit ;
59277: GO 59619
// list := [ ] ;
59279: LD_ADDR_VAR 0 13
59283: PUSH
59284: EMPTY
59285: ST_TO_ADDR
// if x - r < 0 then
59286: LD_VAR 0 2
59290: PUSH
59291: LD_VAR 0 4
59295: MINUS
59296: PUSH
59297: LD_INT 0
59299: LESS
59300: IFFALSE 59312
// min_x := 0 else
59302: LD_ADDR_VAR 0 7
59306: PUSH
59307: LD_INT 0
59309: ST_TO_ADDR
59310: GO 59328
// min_x := x - r ;
59312: LD_ADDR_VAR 0 7
59316: PUSH
59317: LD_VAR 0 2
59321: PUSH
59322: LD_VAR 0 4
59326: MINUS
59327: ST_TO_ADDR
// if y - r < 0 then
59328: LD_VAR 0 3
59332: PUSH
59333: LD_VAR 0 4
59337: MINUS
59338: PUSH
59339: LD_INT 0
59341: LESS
59342: IFFALSE 59354
// min_y := 0 else
59344: LD_ADDR_VAR 0 8
59348: PUSH
59349: LD_INT 0
59351: ST_TO_ADDR
59352: GO 59370
// min_y := y - r ;
59354: LD_ADDR_VAR 0 8
59358: PUSH
59359: LD_VAR 0 3
59363: PUSH
59364: LD_VAR 0 4
59368: MINUS
59369: ST_TO_ADDR
// max_x := x + r ;
59370: LD_ADDR_VAR 0 9
59374: PUSH
59375: LD_VAR 0 2
59379: PUSH
59380: LD_VAR 0 4
59384: PLUS
59385: ST_TO_ADDR
// max_y := y + r ;
59386: LD_ADDR_VAR 0 10
59390: PUSH
59391: LD_VAR 0 3
59395: PUSH
59396: LD_VAR 0 4
59400: PLUS
59401: ST_TO_ADDR
// for _x = min_x to max_x do
59402: LD_ADDR_VAR 0 11
59406: PUSH
59407: DOUBLE
59408: LD_VAR 0 7
59412: DEC
59413: ST_TO_ADDR
59414: LD_VAR 0 9
59418: PUSH
59419: FOR_TO
59420: IFFALSE 59537
// for _y = min_y to max_y do
59422: LD_ADDR_VAR 0 12
59426: PUSH
59427: DOUBLE
59428: LD_VAR 0 8
59432: DEC
59433: ST_TO_ADDR
59434: LD_VAR 0 10
59438: PUSH
59439: FOR_TO
59440: IFFALSE 59533
// begin if not ValidHex ( _x , _y ) then
59442: LD_VAR 0 11
59446: PPUSH
59447: LD_VAR 0 12
59451: PPUSH
59452: CALL_OW 488
59456: NOT
59457: IFFALSE 59461
// continue ;
59459: GO 59439
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
59461: LD_VAR 0 11
59465: PPUSH
59466: LD_VAR 0 12
59470: PPUSH
59471: CALL_OW 351
59475: PUSH
59476: LD_VAR 0 11
59480: PPUSH
59481: LD_VAR 0 12
59485: PPUSH
59486: CALL_OW 554
59490: AND
59491: IFFALSE 59531
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
59493: LD_ADDR_VAR 0 13
59497: PUSH
59498: LD_VAR 0 13
59502: PPUSH
59503: LD_VAR 0 13
59507: PUSH
59508: LD_INT 1
59510: PLUS
59511: PPUSH
59512: LD_VAR 0 11
59516: PUSH
59517: LD_VAR 0 12
59521: PUSH
59522: EMPTY
59523: LIST
59524: LIST
59525: PPUSH
59526: CALL_OW 2
59530: ST_TO_ADDR
// end ;
59531: GO 59439
59533: POP
59534: POP
59535: GO 59419
59537: POP
59538: POP
// if not list then
59539: LD_VAR 0 13
59543: NOT
59544: IFFALSE 59548
// exit ;
59546: GO 59619
// for i in list do
59548: LD_ADDR_VAR 0 6
59552: PUSH
59553: LD_VAR 0 13
59557: PUSH
59558: FOR_IN
59559: IFFALSE 59617
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
59561: LD_VAR 0 1
59565: PPUSH
59566: LD_STRING M
59568: PUSH
59569: LD_VAR 0 6
59573: PUSH
59574: LD_INT 1
59576: ARRAY
59577: PUSH
59578: LD_VAR 0 6
59582: PUSH
59583: LD_INT 2
59585: ARRAY
59586: PUSH
59587: LD_INT 0
59589: PUSH
59590: LD_INT 0
59592: PUSH
59593: LD_INT 0
59595: PUSH
59596: LD_INT 0
59598: PUSH
59599: EMPTY
59600: LIST
59601: LIST
59602: LIST
59603: LIST
59604: LIST
59605: LIST
59606: LIST
59607: PUSH
59608: EMPTY
59609: LIST
59610: PPUSH
59611: CALL_OW 447
59615: GO 59558
59617: POP
59618: POP
// end ;
59619: LD_VAR 0 5
59623: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
59624: LD_EXP 89
59628: NOT
59629: IFFALSE 59679
59631: GO 59633
59633: DISABLE
// begin initHack := true ;
59634: LD_ADDR_EXP 89
59638: PUSH
59639: LD_INT 1
59641: ST_TO_ADDR
// hackTanks := [ ] ;
59642: LD_ADDR_EXP 90
59646: PUSH
59647: EMPTY
59648: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
59649: LD_ADDR_EXP 91
59653: PUSH
59654: EMPTY
59655: ST_TO_ADDR
// hackLimit := 3 ;
59656: LD_ADDR_EXP 92
59660: PUSH
59661: LD_INT 3
59663: ST_TO_ADDR
// hackDist := 12 ;
59664: LD_ADDR_EXP 93
59668: PUSH
59669: LD_INT 12
59671: ST_TO_ADDR
// hackCounter := [ ] ;
59672: LD_ADDR_EXP 94
59676: PUSH
59677: EMPTY
59678: ST_TO_ADDR
// end ;
59679: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
59680: LD_EXP 89
59684: PUSH
59685: LD_INT 34
59687: PUSH
59688: LD_EXP 156
59692: PUSH
59693: EMPTY
59694: LIST
59695: LIST
59696: PPUSH
59697: CALL_OW 69
59701: AND
59702: IFFALSE 59957
59704: GO 59706
59706: DISABLE
59707: LD_INT 0
59709: PPUSH
59710: PPUSH
// begin enable ;
59711: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
59712: LD_ADDR_VAR 0 1
59716: PUSH
59717: LD_INT 34
59719: PUSH
59720: LD_EXP 156
59724: PUSH
59725: EMPTY
59726: LIST
59727: LIST
59728: PPUSH
59729: CALL_OW 69
59733: PUSH
59734: FOR_IN
59735: IFFALSE 59955
// begin if not i in hackTanks then
59737: LD_VAR 0 1
59741: PUSH
59742: LD_EXP 90
59746: IN
59747: NOT
59748: IFFALSE 59831
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
59750: LD_ADDR_EXP 90
59754: PUSH
59755: LD_EXP 90
59759: PPUSH
59760: LD_EXP 90
59764: PUSH
59765: LD_INT 1
59767: PLUS
59768: PPUSH
59769: LD_VAR 0 1
59773: PPUSH
59774: CALL_OW 1
59778: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
59779: LD_ADDR_EXP 91
59783: PUSH
59784: LD_EXP 91
59788: PPUSH
59789: LD_EXP 91
59793: PUSH
59794: LD_INT 1
59796: PLUS
59797: PPUSH
59798: EMPTY
59799: PPUSH
59800: CALL_OW 1
59804: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
59805: LD_ADDR_EXP 94
59809: PUSH
59810: LD_EXP 94
59814: PPUSH
59815: LD_EXP 94
59819: PUSH
59820: LD_INT 1
59822: PLUS
59823: PPUSH
59824: EMPTY
59825: PPUSH
59826: CALL_OW 1
59830: ST_TO_ADDR
// end ; if not IsOk ( i ) then
59831: LD_VAR 0 1
59835: PPUSH
59836: CALL_OW 302
59840: NOT
59841: IFFALSE 59854
// begin HackUnlinkAll ( i ) ;
59843: LD_VAR 0 1
59847: PPUSH
59848: CALL 59960 0 1
// continue ;
59852: GO 59734
// end ; HackCheckCapturedStatus ( i ) ;
59854: LD_VAR 0 1
59858: PPUSH
59859: CALL 60403 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
59863: LD_ADDR_VAR 0 2
59867: PUSH
59868: LD_INT 81
59870: PUSH
59871: LD_VAR 0 1
59875: PPUSH
59876: CALL_OW 255
59880: PUSH
59881: EMPTY
59882: LIST
59883: LIST
59884: PUSH
59885: LD_INT 33
59887: PUSH
59888: LD_INT 3
59890: PUSH
59891: EMPTY
59892: LIST
59893: LIST
59894: PUSH
59895: LD_INT 91
59897: PUSH
59898: LD_VAR 0 1
59902: PUSH
59903: LD_EXP 93
59907: PUSH
59908: EMPTY
59909: LIST
59910: LIST
59911: LIST
59912: PUSH
59913: LD_INT 50
59915: PUSH
59916: EMPTY
59917: LIST
59918: PUSH
59919: EMPTY
59920: LIST
59921: LIST
59922: LIST
59923: LIST
59924: PPUSH
59925: CALL_OW 69
59929: ST_TO_ADDR
// if not tmp then
59930: LD_VAR 0 2
59934: NOT
59935: IFFALSE 59939
// continue ;
59937: GO 59734
// HackLink ( i , tmp ) ;
59939: LD_VAR 0 1
59943: PPUSH
59944: LD_VAR 0 2
59948: PPUSH
59949: CALL 60096 0 2
// end ;
59953: GO 59734
59955: POP
59956: POP
// end ;
59957: PPOPN 2
59959: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
59960: LD_INT 0
59962: PPUSH
59963: PPUSH
59964: PPUSH
// if not hack in hackTanks then
59965: LD_VAR 0 1
59969: PUSH
59970: LD_EXP 90
59974: IN
59975: NOT
59976: IFFALSE 59980
// exit ;
59978: GO 60091
// index := GetElementIndex ( hackTanks , hack ) ;
59980: LD_ADDR_VAR 0 4
59984: PUSH
59985: LD_EXP 90
59989: PPUSH
59990: LD_VAR 0 1
59994: PPUSH
59995: CALL 23995 0 2
59999: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
60000: LD_EXP 91
60004: PUSH
60005: LD_VAR 0 4
60009: ARRAY
60010: IFFALSE 60091
// begin for i in hackTanksCaptured [ index ] do
60012: LD_ADDR_VAR 0 3
60016: PUSH
60017: LD_EXP 91
60021: PUSH
60022: LD_VAR 0 4
60026: ARRAY
60027: PUSH
60028: FOR_IN
60029: IFFALSE 60055
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
60031: LD_VAR 0 3
60035: PUSH
60036: LD_INT 1
60038: ARRAY
60039: PPUSH
60040: LD_VAR 0 3
60044: PUSH
60045: LD_INT 2
60047: ARRAY
60048: PPUSH
60049: CALL_OW 235
60053: GO 60028
60055: POP
60056: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
60057: LD_ADDR_EXP 91
60061: PUSH
60062: LD_EXP 91
60066: PPUSH
60067: LD_VAR 0 4
60071: PPUSH
60072: EMPTY
60073: PPUSH
60074: CALL_OW 1
60078: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
60079: LD_VAR 0 1
60083: PPUSH
60084: LD_INT 0
60086: PPUSH
60087: CALL_OW 505
// end ; end ;
60091: LD_VAR 0 2
60095: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
60096: LD_INT 0
60098: PPUSH
60099: PPUSH
60100: PPUSH
// if not hack in hackTanks or not vehicles then
60101: LD_VAR 0 1
60105: PUSH
60106: LD_EXP 90
60110: IN
60111: NOT
60112: PUSH
60113: LD_VAR 0 2
60117: NOT
60118: OR
60119: IFFALSE 60123
// exit ;
60121: GO 60398
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
60123: LD_ADDR_VAR 0 2
60127: PUSH
60128: LD_VAR 0 1
60132: PPUSH
60133: LD_VAR 0 2
60137: PPUSH
60138: LD_INT 1
60140: PPUSH
60141: LD_INT 1
60143: PPUSH
60144: CALL 24645 0 4
60148: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
60149: LD_ADDR_VAR 0 5
60153: PUSH
60154: LD_EXP 90
60158: PPUSH
60159: LD_VAR 0 1
60163: PPUSH
60164: CALL 23995 0 2
60168: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
60169: LD_EXP 91
60173: PUSH
60174: LD_VAR 0 5
60178: ARRAY
60179: PUSH
60180: LD_EXP 92
60184: LESS
60185: IFFALSE 60374
// begin for i := 1 to vehicles do
60187: LD_ADDR_VAR 0 4
60191: PUSH
60192: DOUBLE
60193: LD_INT 1
60195: DEC
60196: ST_TO_ADDR
60197: LD_VAR 0 2
60201: PUSH
60202: FOR_TO
60203: IFFALSE 60372
// begin if hackTanksCaptured [ index ] = hackLimit then
60205: LD_EXP 91
60209: PUSH
60210: LD_VAR 0 5
60214: ARRAY
60215: PUSH
60216: LD_EXP 92
60220: EQUAL
60221: IFFALSE 60225
// break ;
60223: GO 60372
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
60225: LD_ADDR_EXP 94
60229: PUSH
60230: LD_EXP 94
60234: PPUSH
60235: LD_VAR 0 5
60239: PPUSH
60240: LD_EXP 94
60244: PUSH
60245: LD_VAR 0 5
60249: ARRAY
60250: PUSH
60251: LD_INT 1
60253: PLUS
60254: PPUSH
60255: CALL_OW 1
60259: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
60260: LD_ADDR_EXP 91
60264: PUSH
60265: LD_EXP 91
60269: PPUSH
60270: LD_VAR 0 5
60274: PUSH
60275: LD_EXP 91
60279: PUSH
60280: LD_VAR 0 5
60284: ARRAY
60285: PUSH
60286: LD_INT 1
60288: PLUS
60289: PUSH
60290: EMPTY
60291: LIST
60292: LIST
60293: PPUSH
60294: LD_VAR 0 2
60298: PUSH
60299: LD_VAR 0 4
60303: ARRAY
60304: PUSH
60305: LD_VAR 0 2
60309: PUSH
60310: LD_VAR 0 4
60314: ARRAY
60315: PPUSH
60316: CALL_OW 255
60320: PUSH
60321: EMPTY
60322: LIST
60323: LIST
60324: PPUSH
60325: CALL 24210 0 3
60329: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
60330: LD_VAR 0 2
60334: PUSH
60335: LD_VAR 0 4
60339: ARRAY
60340: PPUSH
60341: LD_VAR 0 1
60345: PPUSH
60346: CALL_OW 255
60350: PPUSH
60351: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
60355: LD_VAR 0 2
60359: PUSH
60360: LD_VAR 0 4
60364: ARRAY
60365: PPUSH
60366: CALL_OW 141
// end ;
60370: GO 60202
60372: POP
60373: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
60374: LD_VAR 0 1
60378: PPUSH
60379: LD_EXP 91
60383: PUSH
60384: LD_VAR 0 5
60388: ARRAY
60389: PUSH
60390: LD_INT 0
60392: PLUS
60393: PPUSH
60394: CALL_OW 505
// end ;
60398: LD_VAR 0 3
60402: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
60403: LD_INT 0
60405: PPUSH
60406: PPUSH
60407: PPUSH
60408: PPUSH
// if not hack in hackTanks then
60409: LD_VAR 0 1
60413: PUSH
60414: LD_EXP 90
60418: IN
60419: NOT
60420: IFFALSE 60424
// exit ;
60422: GO 60664
// index := GetElementIndex ( hackTanks , hack ) ;
60424: LD_ADDR_VAR 0 4
60428: PUSH
60429: LD_EXP 90
60433: PPUSH
60434: LD_VAR 0 1
60438: PPUSH
60439: CALL 23995 0 2
60443: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
60444: LD_ADDR_VAR 0 3
60448: PUSH
60449: DOUBLE
60450: LD_EXP 91
60454: PUSH
60455: LD_VAR 0 4
60459: ARRAY
60460: INC
60461: ST_TO_ADDR
60462: LD_INT 1
60464: PUSH
60465: FOR_DOWNTO
60466: IFFALSE 60638
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
60468: LD_ADDR_VAR 0 5
60472: PUSH
60473: LD_EXP 91
60477: PUSH
60478: LD_VAR 0 4
60482: ARRAY
60483: PUSH
60484: LD_VAR 0 3
60488: ARRAY
60489: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
60490: LD_VAR 0 5
60494: PUSH
60495: LD_INT 1
60497: ARRAY
60498: PPUSH
60499: CALL_OW 302
60503: NOT
60504: PUSH
60505: LD_VAR 0 5
60509: PUSH
60510: LD_INT 1
60512: ARRAY
60513: PPUSH
60514: CALL_OW 255
60518: PUSH
60519: LD_VAR 0 1
60523: PPUSH
60524: CALL_OW 255
60528: NONEQUAL
60529: OR
60530: IFFALSE 60636
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
60532: LD_VAR 0 5
60536: PUSH
60537: LD_INT 1
60539: ARRAY
60540: PPUSH
60541: CALL_OW 305
60545: PUSH
60546: LD_VAR 0 5
60550: PUSH
60551: LD_INT 1
60553: ARRAY
60554: PPUSH
60555: CALL_OW 255
60559: PUSH
60560: LD_VAR 0 1
60564: PPUSH
60565: CALL_OW 255
60569: EQUAL
60570: AND
60571: IFFALSE 60595
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
60573: LD_VAR 0 5
60577: PUSH
60578: LD_INT 1
60580: ARRAY
60581: PPUSH
60582: LD_VAR 0 5
60586: PUSH
60587: LD_INT 2
60589: ARRAY
60590: PPUSH
60591: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
60595: LD_ADDR_EXP 91
60599: PUSH
60600: LD_EXP 91
60604: PPUSH
60605: LD_VAR 0 4
60609: PPUSH
60610: LD_EXP 91
60614: PUSH
60615: LD_VAR 0 4
60619: ARRAY
60620: PPUSH
60621: LD_VAR 0 3
60625: PPUSH
60626: CALL_OW 3
60630: PPUSH
60631: CALL_OW 1
60635: ST_TO_ADDR
// end ; end ;
60636: GO 60465
60638: POP
60639: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
60640: LD_VAR 0 1
60644: PPUSH
60645: LD_EXP 91
60649: PUSH
60650: LD_VAR 0 4
60654: ARRAY
60655: PUSH
60656: LD_INT 0
60658: PLUS
60659: PPUSH
60660: CALL_OW 505
// end ;
60664: LD_VAR 0 2
60668: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
60669: LD_INT 0
60671: PPUSH
60672: PPUSH
60673: PPUSH
60674: PPUSH
// if not hack in hackTanks then
60675: LD_VAR 0 1
60679: PUSH
60680: LD_EXP 90
60684: IN
60685: NOT
60686: IFFALSE 60690
// exit ;
60688: GO 60775
// index := GetElementIndex ( hackTanks , hack ) ;
60690: LD_ADDR_VAR 0 5
60694: PUSH
60695: LD_EXP 90
60699: PPUSH
60700: LD_VAR 0 1
60704: PPUSH
60705: CALL 23995 0 2
60709: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
60710: LD_ADDR_VAR 0 4
60714: PUSH
60715: DOUBLE
60716: LD_INT 1
60718: DEC
60719: ST_TO_ADDR
60720: LD_EXP 91
60724: PUSH
60725: LD_VAR 0 5
60729: ARRAY
60730: PUSH
60731: FOR_TO
60732: IFFALSE 60773
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
60734: LD_EXP 91
60738: PUSH
60739: LD_VAR 0 5
60743: ARRAY
60744: PUSH
60745: LD_VAR 0 4
60749: ARRAY
60750: PUSH
60751: LD_INT 1
60753: ARRAY
60754: PUSH
60755: LD_VAR 0 2
60759: EQUAL
60760: IFFALSE 60771
// KillUnit ( vehicle ) ;
60762: LD_VAR 0 2
60766: PPUSH
60767: CALL_OW 66
60771: GO 60731
60773: POP
60774: POP
// end ;
60775: LD_VAR 0 3
60779: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
60780: LD_EXP 95
60784: NOT
60785: IFFALSE 60820
60787: GO 60789
60789: DISABLE
// begin initMiner := true ;
60790: LD_ADDR_EXP 95
60794: PUSH
60795: LD_INT 1
60797: ST_TO_ADDR
// minersList := [ ] ;
60798: LD_ADDR_EXP 96
60802: PUSH
60803: EMPTY
60804: ST_TO_ADDR
// minerMinesList := [ ] ;
60805: LD_ADDR_EXP 97
60809: PUSH
60810: EMPTY
60811: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
60812: LD_ADDR_EXP 98
60816: PUSH
60817: LD_INT 5
60819: ST_TO_ADDR
// end ;
60820: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
60821: LD_EXP 95
60825: PUSH
60826: LD_INT 34
60828: PUSH
60829: LD_EXP 161
60833: PUSH
60834: EMPTY
60835: LIST
60836: LIST
60837: PPUSH
60838: CALL_OW 69
60842: AND
60843: IFFALSE 61306
60845: GO 60847
60847: DISABLE
60848: LD_INT 0
60850: PPUSH
60851: PPUSH
60852: PPUSH
60853: PPUSH
// begin enable ;
60854: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
60855: LD_ADDR_VAR 0 1
60859: PUSH
60860: LD_INT 34
60862: PUSH
60863: LD_EXP 161
60867: PUSH
60868: EMPTY
60869: LIST
60870: LIST
60871: PPUSH
60872: CALL_OW 69
60876: PUSH
60877: FOR_IN
60878: IFFALSE 60950
// begin if not i in minersList then
60880: LD_VAR 0 1
60884: PUSH
60885: LD_EXP 96
60889: IN
60890: NOT
60891: IFFALSE 60948
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
60893: LD_ADDR_EXP 96
60897: PUSH
60898: LD_EXP 96
60902: PPUSH
60903: LD_EXP 96
60907: PUSH
60908: LD_INT 1
60910: PLUS
60911: PPUSH
60912: LD_VAR 0 1
60916: PPUSH
60917: CALL_OW 1
60921: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
60922: LD_ADDR_EXP 97
60926: PUSH
60927: LD_EXP 97
60931: PPUSH
60932: LD_EXP 97
60936: PUSH
60937: LD_INT 1
60939: PLUS
60940: PPUSH
60941: EMPTY
60942: PPUSH
60943: CALL_OW 1
60947: ST_TO_ADDR
// end end ;
60948: GO 60877
60950: POP
60951: POP
// for i := minerMinesList downto 1 do
60952: LD_ADDR_VAR 0 1
60956: PUSH
60957: DOUBLE
60958: LD_EXP 97
60962: INC
60963: ST_TO_ADDR
60964: LD_INT 1
60966: PUSH
60967: FOR_DOWNTO
60968: IFFALSE 61304
// begin if IsLive ( minersList [ i ] ) then
60970: LD_EXP 96
60974: PUSH
60975: LD_VAR 0 1
60979: ARRAY
60980: PPUSH
60981: CALL_OW 300
60985: IFFALSE 61013
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
60987: LD_EXP 96
60991: PUSH
60992: LD_VAR 0 1
60996: ARRAY
60997: PPUSH
60998: LD_EXP 97
61002: PUSH
61003: LD_VAR 0 1
61007: ARRAY
61008: PPUSH
61009: CALL_OW 505
// if not minerMinesList [ i ] then
61013: LD_EXP 97
61017: PUSH
61018: LD_VAR 0 1
61022: ARRAY
61023: NOT
61024: IFFALSE 61028
// continue ;
61026: GO 60967
// for j := minerMinesList [ i ] downto 1 do
61028: LD_ADDR_VAR 0 2
61032: PUSH
61033: DOUBLE
61034: LD_EXP 97
61038: PUSH
61039: LD_VAR 0 1
61043: ARRAY
61044: INC
61045: ST_TO_ADDR
61046: LD_INT 1
61048: PUSH
61049: FOR_DOWNTO
61050: IFFALSE 61300
// begin side := GetSide ( minersList [ i ] ) ;
61052: LD_ADDR_VAR 0 3
61056: PUSH
61057: LD_EXP 96
61061: PUSH
61062: LD_VAR 0 1
61066: ARRAY
61067: PPUSH
61068: CALL_OW 255
61072: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
61073: LD_ADDR_VAR 0 4
61077: PUSH
61078: LD_EXP 97
61082: PUSH
61083: LD_VAR 0 1
61087: ARRAY
61088: PUSH
61089: LD_VAR 0 2
61093: ARRAY
61094: PUSH
61095: LD_INT 1
61097: ARRAY
61098: PPUSH
61099: LD_EXP 97
61103: PUSH
61104: LD_VAR 0 1
61108: ARRAY
61109: PUSH
61110: LD_VAR 0 2
61114: ARRAY
61115: PUSH
61116: LD_INT 2
61118: ARRAY
61119: PPUSH
61120: CALL_OW 428
61124: ST_TO_ADDR
// if not tmp then
61125: LD_VAR 0 4
61129: NOT
61130: IFFALSE 61134
// continue ;
61132: GO 61049
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
61134: LD_VAR 0 4
61138: PUSH
61139: LD_INT 81
61141: PUSH
61142: LD_VAR 0 3
61146: PUSH
61147: EMPTY
61148: LIST
61149: LIST
61150: PPUSH
61151: CALL_OW 69
61155: IN
61156: PUSH
61157: LD_EXP 97
61161: PUSH
61162: LD_VAR 0 1
61166: ARRAY
61167: PUSH
61168: LD_VAR 0 2
61172: ARRAY
61173: PUSH
61174: LD_INT 1
61176: ARRAY
61177: PPUSH
61178: LD_EXP 97
61182: PUSH
61183: LD_VAR 0 1
61187: ARRAY
61188: PUSH
61189: LD_VAR 0 2
61193: ARRAY
61194: PUSH
61195: LD_INT 2
61197: ARRAY
61198: PPUSH
61199: CALL_OW 458
61203: AND
61204: IFFALSE 61298
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
61206: LD_EXP 97
61210: PUSH
61211: LD_VAR 0 1
61215: ARRAY
61216: PUSH
61217: LD_VAR 0 2
61221: ARRAY
61222: PUSH
61223: LD_INT 1
61225: ARRAY
61226: PPUSH
61227: LD_EXP 97
61231: PUSH
61232: LD_VAR 0 1
61236: ARRAY
61237: PUSH
61238: LD_VAR 0 2
61242: ARRAY
61243: PUSH
61244: LD_INT 2
61246: ARRAY
61247: PPUSH
61248: LD_VAR 0 3
61252: PPUSH
61253: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
61257: LD_ADDR_EXP 97
61261: PUSH
61262: LD_EXP 97
61266: PPUSH
61267: LD_VAR 0 1
61271: PPUSH
61272: LD_EXP 97
61276: PUSH
61277: LD_VAR 0 1
61281: ARRAY
61282: PPUSH
61283: LD_VAR 0 2
61287: PPUSH
61288: CALL_OW 3
61292: PPUSH
61293: CALL_OW 1
61297: ST_TO_ADDR
// end ; end ;
61298: GO 61049
61300: POP
61301: POP
// end ;
61302: GO 60967
61304: POP
61305: POP
// end ;
61306: PPOPN 4
61308: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
61309: LD_INT 0
61311: PPUSH
61312: PPUSH
// result := false ;
61313: LD_ADDR_VAR 0 4
61317: PUSH
61318: LD_INT 0
61320: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
61321: LD_VAR 0 1
61325: PPUSH
61326: CALL_OW 264
61330: PUSH
61331: LD_EXP 161
61335: EQUAL
61336: NOT
61337: IFFALSE 61341
// exit ;
61339: GO 61581
// index := GetElementIndex ( minersList , unit ) ;
61341: LD_ADDR_VAR 0 5
61345: PUSH
61346: LD_EXP 96
61350: PPUSH
61351: LD_VAR 0 1
61355: PPUSH
61356: CALL 23995 0 2
61360: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
61361: LD_EXP 97
61365: PUSH
61366: LD_VAR 0 5
61370: ARRAY
61371: PUSH
61372: LD_EXP 98
61376: GREATEREQUAL
61377: IFFALSE 61381
// exit ;
61379: GO 61581
// ComMoveXY ( unit , x , y ) ;
61381: LD_VAR 0 1
61385: PPUSH
61386: LD_VAR 0 2
61390: PPUSH
61391: LD_VAR 0 3
61395: PPUSH
61396: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
61400: LD_INT 35
61402: PPUSH
61403: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
61407: LD_VAR 0 1
61411: PPUSH
61412: LD_VAR 0 2
61416: PPUSH
61417: LD_VAR 0 3
61421: PPUSH
61422: CALL 54767 0 3
61426: NOT
61427: PUSH
61428: LD_VAR 0 1
61432: PPUSH
61433: CALL_OW 314
61437: AND
61438: IFFALSE 61442
// exit ;
61440: GO 61581
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
61442: LD_VAR 0 2
61446: PPUSH
61447: LD_VAR 0 3
61451: PPUSH
61452: CALL_OW 428
61456: PUSH
61457: LD_VAR 0 1
61461: EQUAL
61462: PUSH
61463: LD_VAR 0 1
61467: PPUSH
61468: CALL_OW 314
61472: NOT
61473: AND
61474: IFFALSE 61400
// PlaySoundXY ( x , y , PlantMine ) ;
61476: LD_VAR 0 2
61480: PPUSH
61481: LD_VAR 0 3
61485: PPUSH
61486: LD_STRING PlantMine
61488: PPUSH
61489: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
61493: LD_VAR 0 2
61497: PPUSH
61498: LD_VAR 0 3
61502: PPUSH
61503: LD_VAR 0 1
61507: PPUSH
61508: CALL_OW 255
61512: PPUSH
61513: LD_INT 0
61515: PPUSH
61516: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
61520: LD_ADDR_EXP 97
61524: PUSH
61525: LD_EXP 97
61529: PPUSH
61530: LD_VAR 0 5
61534: PUSH
61535: LD_EXP 97
61539: PUSH
61540: LD_VAR 0 5
61544: ARRAY
61545: PUSH
61546: LD_INT 1
61548: PLUS
61549: PUSH
61550: EMPTY
61551: LIST
61552: LIST
61553: PPUSH
61554: LD_VAR 0 2
61558: PUSH
61559: LD_VAR 0 3
61563: PUSH
61564: EMPTY
61565: LIST
61566: LIST
61567: PPUSH
61568: CALL 24210 0 3
61572: ST_TO_ADDR
// result := true ;
61573: LD_ADDR_VAR 0 4
61577: PUSH
61578: LD_INT 1
61580: ST_TO_ADDR
// end ;
61581: LD_VAR 0 4
61585: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
61586: LD_INT 0
61588: PPUSH
61589: PPUSH
61590: PPUSH
// if not unit in minersList then
61591: LD_VAR 0 1
61595: PUSH
61596: LD_EXP 96
61600: IN
61601: NOT
61602: IFFALSE 61606
// exit ;
61604: GO 61998
// index := GetElementIndex ( minersList , unit ) ;
61606: LD_ADDR_VAR 0 6
61610: PUSH
61611: LD_EXP 96
61615: PPUSH
61616: LD_VAR 0 1
61620: PPUSH
61621: CALL 23995 0 2
61625: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
61626: LD_ADDR_VAR 0 5
61630: PUSH
61631: DOUBLE
61632: LD_EXP 97
61636: PUSH
61637: LD_VAR 0 6
61641: ARRAY
61642: INC
61643: ST_TO_ADDR
61644: LD_INT 1
61646: PUSH
61647: FOR_DOWNTO
61648: IFFALSE 61809
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
61650: LD_EXP 97
61654: PUSH
61655: LD_VAR 0 6
61659: ARRAY
61660: PUSH
61661: LD_VAR 0 5
61665: ARRAY
61666: PUSH
61667: LD_INT 1
61669: ARRAY
61670: PUSH
61671: LD_VAR 0 2
61675: EQUAL
61676: PUSH
61677: LD_EXP 97
61681: PUSH
61682: LD_VAR 0 6
61686: ARRAY
61687: PUSH
61688: LD_VAR 0 5
61692: ARRAY
61693: PUSH
61694: LD_INT 2
61696: ARRAY
61697: PUSH
61698: LD_VAR 0 3
61702: EQUAL
61703: AND
61704: IFFALSE 61807
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
61706: LD_EXP 97
61710: PUSH
61711: LD_VAR 0 6
61715: ARRAY
61716: PUSH
61717: LD_VAR 0 5
61721: ARRAY
61722: PUSH
61723: LD_INT 1
61725: ARRAY
61726: PPUSH
61727: LD_EXP 97
61731: PUSH
61732: LD_VAR 0 6
61736: ARRAY
61737: PUSH
61738: LD_VAR 0 5
61742: ARRAY
61743: PUSH
61744: LD_INT 2
61746: ARRAY
61747: PPUSH
61748: LD_VAR 0 1
61752: PPUSH
61753: CALL_OW 255
61757: PPUSH
61758: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
61762: LD_ADDR_EXP 97
61766: PUSH
61767: LD_EXP 97
61771: PPUSH
61772: LD_VAR 0 6
61776: PPUSH
61777: LD_EXP 97
61781: PUSH
61782: LD_VAR 0 6
61786: ARRAY
61787: PPUSH
61788: LD_VAR 0 5
61792: PPUSH
61793: CALL_OW 3
61797: PPUSH
61798: CALL_OW 1
61802: ST_TO_ADDR
// exit ;
61803: POP
61804: POP
61805: GO 61998
// end ; end ;
61807: GO 61647
61809: POP
61810: POP
// for i := minerMinesList [ index ] downto 1 do
61811: LD_ADDR_VAR 0 5
61815: PUSH
61816: DOUBLE
61817: LD_EXP 97
61821: PUSH
61822: LD_VAR 0 6
61826: ARRAY
61827: INC
61828: ST_TO_ADDR
61829: LD_INT 1
61831: PUSH
61832: FOR_DOWNTO
61833: IFFALSE 61996
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
61835: LD_EXP 97
61839: PUSH
61840: LD_VAR 0 6
61844: ARRAY
61845: PUSH
61846: LD_VAR 0 5
61850: ARRAY
61851: PUSH
61852: LD_INT 1
61854: ARRAY
61855: PPUSH
61856: LD_EXP 97
61860: PUSH
61861: LD_VAR 0 6
61865: ARRAY
61866: PUSH
61867: LD_VAR 0 5
61871: ARRAY
61872: PUSH
61873: LD_INT 2
61875: ARRAY
61876: PPUSH
61877: LD_VAR 0 2
61881: PPUSH
61882: LD_VAR 0 3
61886: PPUSH
61887: CALL_OW 298
61891: PUSH
61892: LD_INT 6
61894: LESS
61895: IFFALSE 61994
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
61897: LD_EXP 97
61901: PUSH
61902: LD_VAR 0 6
61906: ARRAY
61907: PUSH
61908: LD_VAR 0 5
61912: ARRAY
61913: PUSH
61914: LD_INT 1
61916: ARRAY
61917: PPUSH
61918: LD_EXP 97
61922: PUSH
61923: LD_VAR 0 6
61927: ARRAY
61928: PUSH
61929: LD_VAR 0 5
61933: ARRAY
61934: PUSH
61935: LD_INT 2
61937: ARRAY
61938: PPUSH
61939: LD_VAR 0 1
61943: PPUSH
61944: CALL_OW 255
61948: PPUSH
61949: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
61953: LD_ADDR_EXP 97
61957: PUSH
61958: LD_EXP 97
61962: PPUSH
61963: LD_VAR 0 6
61967: PPUSH
61968: LD_EXP 97
61972: PUSH
61973: LD_VAR 0 6
61977: ARRAY
61978: PPUSH
61979: LD_VAR 0 5
61983: PPUSH
61984: CALL_OW 3
61988: PPUSH
61989: CALL_OW 1
61993: ST_TO_ADDR
// end ; end ;
61994: GO 61832
61996: POP
61997: POP
// end ;
61998: LD_VAR 0 4
62002: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
62003: LD_INT 0
62005: PPUSH
62006: PPUSH
62007: PPUSH
62008: PPUSH
62009: PPUSH
62010: PPUSH
62011: PPUSH
62012: PPUSH
62013: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
62014: LD_VAR 0 1
62018: PPUSH
62019: CALL_OW 264
62023: PUSH
62024: LD_EXP 161
62028: EQUAL
62029: NOT
62030: PUSH
62031: LD_VAR 0 1
62035: PUSH
62036: LD_EXP 96
62040: IN
62041: NOT
62042: OR
62043: IFFALSE 62047
// exit ;
62045: GO 62369
// index := GetElementIndex ( minersList , unit ) ;
62047: LD_ADDR_VAR 0 6
62051: PUSH
62052: LD_EXP 96
62056: PPUSH
62057: LD_VAR 0 1
62061: PPUSH
62062: CALL 23995 0 2
62066: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
62067: LD_ADDR_VAR 0 8
62071: PUSH
62072: LD_EXP 98
62076: PUSH
62077: LD_EXP 97
62081: PUSH
62082: LD_VAR 0 6
62086: ARRAY
62087: MINUS
62088: ST_TO_ADDR
// if not minesFreeAmount then
62089: LD_VAR 0 8
62093: NOT
62094: IFFALSE 62098
// exit ;
62096: GO 62369
// tmp := [ ] ;
62098: LD_ADDR_VAR 0 7
62102: PUSH
62103: EMPTY
62104: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
62105: LD_ADDR_VAR 0 5
62109: PUSH
62110: DOUBLE
62111: LD_INT 1
62113: DEC
62114: ST_TO_ADDR
62115: LD_VAR 0 8
62119: PUSH
62120: FOR_TO
62121: IFFALSE 62316
// begin _d := rand ( 0 , 5 ) ;
62123: LD_ADDR_VAR 0 11
62127: PUSH
62128: LD_INT 0
62130: PPUSH
62131: LD_INT 5
62133: PPUSH
62134: CALL_OW 12
62138: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
62139: LD_ADDR_VAR 0 12
62143: PUSH
62144: LD_INT 2
62146: PPUSH
62147: LD_INT 6
62149: PPUSH
62150: CALL_OW 12
62154: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
62155: LD_ADDR_VAR 0 9
62159: PUSH
62160: LD_VAR 0 2
62164: PPUSH
62165: LD_VAR 0 11
62169: PPUSH
62170: LD_VAR 0 12
62174: PPUSH
62175: CALL_OW 272
62179: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
62180: LD_ADDR_VAR 0 10
62184: PUSH
62185: LD_VAR 0 3
62189: PPUSH
62190: LD_VAR 0 11
62194: PPUSH
62195: LD_VAR 0 12
62199: PPUSH
62200: CALL_OW 273
62204: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
62205: LD_VAR 0 9
62209: PPUSH
62210: LD_VAR 0 10
62214: PPUSH
62215: CALL_OW 488
62219: PUSH
62220: LD_VAR 0 9
62224: PUSH
62225: LD_VAR 0 10
62229: PUSH
62230: EMPTY
62231: LIST
62232: LIST
62233: PUSH
62234: LD_VAR 0 7
62238: IN
62239: NOT
62240: AND
62241: PUSH
62242: LD_VAR 0 9
62246: PPUSH
62247: LD_VAR 0 10
62251: PPUSH
62252: CALL_OW 458
62256: NOT
62257: AND
62258: IFFALSE 62300
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
62260: LD_ADDR_VAR 0 7
62264: PUSH
62265: LD_VAR 0 7
62269: PPUSH
62270: LD_VAR 0 7
62274: PUSH
62275: LD_INT 1
62277: PLUS
62278: PPUSH
62279: LD_VAR 0 9
62283: PUSH
62284: LD_VAR 0 10
62288: PUSH
62289: EMPTY
62290: LIST
62291: LIST
62292: PPUSH
62293: CALL_OW 1
62297: ST_TO_ADDR
62298: GO 62314
// i := i - 1 ;
62300: LD_ADDR_VAR 0 5
62304: PUSH
62305: LD_VAR 0 5
62309: PUSH
62310: LD_INT 1
62312: MINUS
62313: ST_TO_ADDR
// end ;
62314: GO 62120
62316: POP
62317: POP
// for i in tmp do
62318: LD_ADDR_VAR 0 5
62322: PUSH
62323: LD_VAR 0 7
62327: PUSH
62328: FOR_IN
62329: IFFALSE 62367
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
62331: LD_VAR 0 1
62335: PPUSH
62336: LD_VAR 0 5
62340: PUSH
62341: LD_INT 1
62343: ARRAY
62344: PPUSH
62345: LD_VAR 0 5
62349: PUSH
62350: LD_INT 2
62352: ARRAY
62353: PPUSH
62354: CALL 61309 0 3
62358: NOT
62359: IFFALSE 62365
// exit ;
62361: POP
62362: POP
62363: GO 62369
62365: GO 62328
62367: POP
62368: POP
// end ;
62369: LD_VAR 0 4
62373: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
62374: LD_INT 0
62376: PPUSH
62377: PPUSH
62378: PPUSH
62379: PPUSH
62380: PPUSH
62381: PPUSH
62382: PPUSH
// if not GetClass ( unit ) = class_sniper then
62383: LD_VAR 0 1
62387: PPUSH
62388: CALL_OW 257
62392: PUSH
62393: LD_INT 5
62395: EQUAL
62396: NOT
62397: IFFALSE 62401
// exit ;
62399: GO 62789
// dist := 8 ;
62401: LD_ADDR_VAR 0 5
62405: PUSH
62406: LD_INT 8
62408: ST_TO_ADDR
// viewRange := 12 ;
62409: LD_ADDR_VAR 0 7
62413: PUSH
62414: LD_INT 12
62416: ST_TO_ADDR
// side := GetSide ( unit ) ;
62417: LD_ADDR_VAR 0 6
62421: PUSH
62422: LD_VAR 0 1
62426: PPUSH
62427: CALL_OW 255
62431: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
62432: LD_INT 61
62434: PPUSH
62435: LD_VAR 0 6
62439: PPUSH
62440: CALL_OW 321
62444: PUSH
62445: LD_INT 2
62447: EQUAL
62448: IFFALSE 62458
// viewRange := 16 ;
62450: LD_ADDR_VAR 0 7
62454: PUSH
62455: LD_INT 16
62457: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
62458: LD_VAR 0 1
62462: PPUSH
62463: LD_VAR 0 2
62467: PPUSH
62468: LD_VAR 0 3
62472: PPUSH
62473: CALL_OW 297
62477: PUSH
62478: LD_VAR 0 5
62482: GREATER
62483: IFFALSE 62562
// begin ComMoveXY ( unit , x , y ) ;
62485: LD_VAR 0 1
62489: PPUSH
62490: LD_VAR 0 2
62494: PPUSH
62495: LD_VAR 0 3
62499: PPUSH
62500: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
62504: LD_INT 35
62506: PPUSH
62507: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
62511: LD_VAR 0 1
62515: PPUSH
62516: LD_VAR 0 2
62520: PPUSH
62521: LD_VAR 0 3
62525: PPUSH
62526: CALL 54767 0 3
62530: NOT
62531: IFFALSE 62535
// exit ;
62533: GO 62789
// until GetDistUnitXY ( unit , x , y ) < dist ;
62535: LD_VAR 0 1
62539: PPUSH
62540: LD_VAR 0 2
62544: PPUSH
62545: LD_VAR 0 3
62549: PPUSH
62550: CALL_OW 297
62554: PUSH
62555: LD_VAR 0 5
62559: LESS
62560: IFFALSE 62504
// end ; ComTurnXY ( unit , x , y ) ;
62562: LD_VAR 0 1
62566: PPUSH
62567: LD_VAR 0 2
62571: PPUSH
62572: LD_VAR 0 3
62576: PPUSH
62577: CALL_OW 118
// wait ( 5 ) ;
62581: LD_INT 5
62583: PPUSH
62584: CALL_OW 67
// _d := GetDir ( unit ) ;
62588: LD_ADDR_VAR 0 10
62592: PUSH
62593: LD_VAR 0 1
62597: PPUSH
62598: CALL_OW 254
62602: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
62603: LD_ADDR_VAR 0 8
62607: PUSH
62608: LD_VAR 0 1
62612: PPUSH
62613: CALL_OW 250
62617: PPUSH
62618: LD_VAR 0 10
62622: PPUSH
62623: LD_VAR 0 5
62627: PPUSH
62628: CALL_OW 272
62632: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
62633: LD_ADDR_VAR 0 9
62637: PUSH
62638: LD_VAR 0 1
62642: PPUSH
62643: CALL_OW 251
62647: PPUSH
62648: LD_VAR 0 10
62652: PPUSH
62653: LD_VAR 0 5
62657: PPUSH
62658: CALL_OW 273
62662: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
62663: LD_VAR 0 8
62667: PPUSH
62668: LD_VAR 0 9
62672: PPUSH
62673: CALL_OW 488
62677: NOT
62678: IFFALSE 62682
// exit ;
62680: GO 62789
// ComAnimCustom ( unit , 1 ) ;
62682: LD_VAR 0 1
62686: PPUSH
62687: LD_INT 1
62689: PPUSH
62690: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
62694: LD_VAR 0 8
62698: PPUSH
62699: LD_VAR 0 9
62703: PPUSH
62704: LD_VAR 0 6
62708: PPUSH
62709: LD_VAR 0 7
62713: PPUSH
62714: CALL_OW 330
// repeat wait ( 1 ) ;
62718: LD_INT 1
62720: PPUSH
62721: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
62725: LD_VAR 0 1
62729: PPUSH
62730: CALL_OW 316
62734: PUSH
62735: LD_VAR 0 1
62739: PPUSH
62740: CALL_OW 314
62744: OR
62745: PUSH
62746: LD_VAR 0 1
62750: PPUSH
62751: CALL_OW 302
62755: NOT
62756: OR
62757: PUSH
62758: LD_VAR 0 1
62762: PPUSH
62763: CALL_OW 301
62767: OR
62768: IFFALSE 62718
// RemoveSeeing ( _x , _y , side ) ;
62770: LD_VAR 0 8
62774: PPUSH
62775: LD_VAR 0 9
62779: PPUSH
62780: LD_VAR 0 6
62784: PPUSH
62785: CALL_OW 331
// end ; end_of_file
62789: LD_VAR 0 4
62793: RET
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
62794: LD_INT 0
62796: PPUSH
// if p2 = 100 then
62797: LD_VAR 0 2
62801: PUSH
62802: LD_INT 100
62804: EQUAL
62805: IFFALSE 63754
// begin if not StreamModeActive then
62807: LD_EXP 99
62811: NOT
62812: IFFALSE 62822
// StreamModeActive := true ;
62814: LD_ADDR_EXP 99
62818: PUSH
62819: LD_INT 1
62821: ST_TO_ADDR
// if p3 = 0 then
62822: LD_VAR 0 3
62826: PUSH
62827: LD_INT 0
62829: EQUAL
62830: IFFALSE 62836
// InitStreamMode ;
62832: CALL 63914 0 0
// if p3 = 1 then
62836: LD_VAR 0 3
62840: PUSH
62841: LD_INT 1
62843: EQUAL
62844: IFFALSE 62854
// sRocket := true ;
62846: LD_ADDR_EXP 104
62850: PUSH
62851: LD_INT 1
62853: ST_TO_ADDR
// if p3 = 2 then
62854: LD_VAR 0 3
62858: PUSH
62859: LD_INT 2
62861: EQUAL
62862: IFFALSE 62872
// sSpeed := true ;
62864: LD_ADDR_EXP 103
62868: PUSH
62869: LD_INT 1
62871: ST_TO_ADDR
// if p3 = 3 then
62872: LD_VAR 0 3
62876: PUSH
62877: LD_INT 3
62879: EQUAL
62880: IFFALSE 62890
// sEngine := true ;
62882: LD_ADDR_EXP 105
62886: PUSH
62887: LD_INT 1
62889: ST_TO_ADDR
// if p3 = 4 then
62890: LD_VAR 0 3
62894: PUSH
62895: LD_INT 4
62897: EQUAL
62898: IFFALSE 62908
// sSpec := true ;
62900: LD_ADDR_EXP 102
62904: PUSH
62905: LD_INT 1
62907: ST_TO_ADDR
// if p3 = 5 then
62908: LD_VAR 0 3
62912: PUSH
62913: LD_INT 5
62915: EQUAL
62916: IFFALSE 62926
// sLevel := true ;
62918: LD_ADDR_EXP 106
62922: PUSH
62923: LD_INT 1
62925: ST_TO_ADDR
// if p3 = 6 then
62926: LD_VAR 0 3
62930: PUSH
62931: LD_INT 6
62933: EQUAL
62934: IFFALSE 62944
// sArmoury := true ;
62936: LD_ADDR_EXP 107
62940: PUSH
62941: LD_INT 1
62943: ST_TO_ADDR
// if p3 = 7 then
62944: LD_VAR 0 3
62948: PUSH
62949: LD_INT 7
62951: EQUAL
62952: IFFALSE 62962
// sRadar := true ;
62954: LD_ADDR_EXP 108
62958: PUSH
62959: LD_INT 1
62961: ST_TO_ADDR
// if p3 = 8 then
62962: LD_VAR 0 3
62966: PUSH
62967: LD_INT 8
62969: EQUAL
62970: IFFALSE 62980
// sBunker := true ;
62972: LD_ADDR_EXP 109
62976: PUSH
62977: LD_INT 1
62979: ST_TO_ADDR
// if p3 = 9 then
62980: LD_VAR 0 3
62984: PUSH
62985: LD_INT 9
62987: EQUAL
62988: IFFALSE 62998
// sHack := true ;
62990: LD_ADDR_EXP 110
62994: PUSH
62995: LD_INT 1
62997: ST_TO_ADDR
// if p3 = 10 then
62998: LD_VAR 0 3
63002: PUSH
63003: LD_INT 10
63005: EQUAL
63006: IFFALSE 63016
// sFire := true ;
63008: LD_ADDR_EXP 111
63012: PUSH
63013: LD_INT 1
63015: ST_TO_ADDR
// if p3 = 11 then
63016: LD_VAR 0 3
63020: PUSH
63021: LD_INT 11
63023: EQUAL
63024: IFFALSE 63034
// sRefresh := true ;
63026: LD_ADDR_EXP 112
63030: PUSH
63031: LD_INT 1
63033: ST_TO_ADDR
// if p3 = 12 then
63034: LD_VAR 0 3
63038: PUSH
63039: LD_INT 12
63041: EQUAL
63042: IFFALSE 63052
// sExp := true ;
63044: LD_ADDR_EXP 113
63048: PUSH
63049: LD_INT 1
63051: ST_TO_ADDR
// if p3 = 13 then
63052: LD_VAR 0 3
63056: PUSH
63057: LD_INT 13
63059: EQUAL
63060: IFFALSE 63070
// sDepot := true ;
63062: LD_ADDR_EXP 114
63066: PUSH
63067: LD_INT 1
63069: ST_TO_ADDR
// if p3 = 14 then
63070: LD_VAR 0 3
63074: PUSH
63075: LD_INT 14
63077: EQUAL
63078: IFFALSE 63088
// sFlag := true ;
63080: LD_ADDR_EXP 115
63084: PUSH
63085: LD_INT 1
63087: ST_TO_ADDR
// if p3 = 15 then
63088: LD_VAR 0 3
63092: PUSH
63093: LD_INT 15
63095: EQUAL
63096: IFFALSE 63106
// sKamikadze := true ;
63098: LD_ADDR_EXP 123
63102: PUSH
63103: LD_INT 1
63105: ST_TO_ADDR
// if p3 = 16 then
63106: LD_VAR 0 3
63110: PUSH
63111: LD_INT 16
63113: EQUAL
63114: IFFALSE 63124
// sTroll := true ;
63116: LD_ADDR_EXP 124
63120: PUSH
63121: LD_INT 1
63123: ST_TO_ADDR
// if p3 = 17 then
63124: LD_VAR 0 3
63128: PUSH
63129: LD_INT 17
63131: EQUAL
63132: IFFALSE 63142
// sSlow := true ;
63134: LD_ADDR_EXP 125
63138: PUSH
63139: LD_INT 1
63141: ST_TO_ADDR
// if p3 = 18 then
63142: LD_VAR 0 3
63146: PUSH
63147: LD_INT 18
63149: EQUAL
63150: IFFALSE 63160
// sLack := true ;
63152: LD_ADDR_EXP 126
63156: PUSH
63157: LD_INT 1
63159: ST_TO_ADDR
// if p3 = 19 then
63160: LD_VAR 0 3
63164: PUSH
63165: LD_INT 19
63167: EQUAL
63168: IFFALSE 63178
// sTank := true ;
63170: LD_ADDR_EXP 128
63174: PUSH
63175: LD_INT 1
63177: ST_TO_ADDR
// if p3 = 20 then
63178: LD_VAR 0 3
63182: PUSH
63183: LD_INT 20
63185: EQUAL
63186: IFFALSE 63196
// sRemote := true ;
63188: LD_ADDR_EXP 129
63192: PUSH
63193: LD_INT 1
63195: ST_TO_ADDR
// if p3 = 21 then
63196: LD_VAR 0 3
63200: PUSH
63201: LD_INT 21
63203: EQUAL
63204: IFFALSE 63214
// sPowell := true ;
63206: LD_ADDR_EXP 130
63210: PUSH
63211: LD_INT 1
63213: ST_TO_ADDR
// if p3 = 22 then
63214: LD_VAR 0 3
63218: PUSH
63219: LD_INT 22
63221: EQUAL
63222: IFFALSE 63232
// sTeleport := true ;
63224: LD_ADDR_EXP 133
63228: PUSH
63229: LD_INT 1
63231: ST_TO_ADDR
// if p3 = 23 then
63232: LD_VAR 0 3
63236: PUSH
63237: LD_INT 23
63239: EQUAL
63240: IFFALSE 63250
// sOilTower := true ;
63242: LD_ADDR_EXP 135
63246: PUSH
63247: LD_INT 1
63249: ST_TO_ADDR
// if p3 = 24 then
63250: LD_VAR 0 3
63254: PUSH
63255: LD_INT 24
63257: EQUAL
63258: IFFALSE 63268
// sShovel := true ;
63260: LD_ADDR_EXP 136
63264: PUSH
63265: LD_INT 1
63267: ST_TO_ADDR
// if p3 = 25 then
63268: LD_VAR 0 3
63272: PUSH
63273: LD_INT 25
63275: EQUAL
63276: IFFALSE 63286
// sSheik := true ;
63278: LD_ADDR_EXP 137
63282: PUSH
63283: LD_INT 1
63285: ST_TO_ADDR
// if p3 = 26 then
63286: LD_VAR 0 3
63290: PUSH
63291: LD_INT 26
63293: EQUAL
63294: IFFALSE 63304
// sEarthquake := true ;
63296: LD_ADDR_EXP 139
63300: PUSH
63301: LD_INT 1
63303: ST_TO_ADDR
// if p3 = 27 then
63304: LD_VAR 0 3
63308: PUSH
63309: LD_INT 27
63311: EQUAL
63312: IFFALSE 63322
// sAI := true ;
63314: LD_ADDR_EXP 140
63318: PUSH
63319: LD_INT 1
63321: ST_TO_ADDR
// if p3 = 28 then
63322: LD_VAR 0 3
63326: PUSH
63327: LD_INT 28
63329: EQUAL
63330: IFFALSE 63340
// sCargo := true ;
63332: LD_ADDR_EXP 143
63336: PUSH
63337: LD_INT 1
63339: ST_TO_ADDR
// if p3 = 29 then
63340: LD_VAR 0 3
63344: PUSH
63345: LD_INT 29
63347: EQUAL
63348: IFFALSE 63358
// sDLaser := true ;
63350: LD_ADDR_EXP 144
63354: PUSH
63355: LD_INT 1
63357: ST_TO_ADDR
// if p3 = 30 then
63358: LD_VAR 0 3
63362: PUSH
63363: LD_INT 30
63365: EQUAL
63366: IFFALSE 63376
// sExchange := true ;
63368: LD_ADDR_EXP 145
63372: PUSH
63373: LD_INT 1
63375: ST_TO_ADDR
// if p3 = 31 then
63376: LD_VAR 0 3
63380: PUSH
63381: LD_INT 31
63383: EQUAL
63384: IFFALSE 63394
// sFac := true ;
63386: LD_ADDR_EXP 146
63390: PUSH
63391: LD_INT 1
63393: ST_TO_ADDR
// if p3 = 32 then
63394: LD_VAR 0 3
63398: PUSH
63399: LD_INT 32
63401: EQUAL
63402: IFFALSE 63412
// sPower := true ;
63404: LD_ADDR_EXP 147
63408: PUSH
63409: LD_INT 1
63411: ST_TO_ADDR
// if p3 = 33 then
63412: LD_VAR 0 3
63416: PUSH
63417: LD_INT 33
63419: EQUAL
63420: IFFALSE 63430
// sRandom := true ;
63422: LD_ADDR_EXP 148
63426: PUSH
63427: LD_INT 1
63429: ST_TO_ADDR
// if p3 = 34 then
63430: LD_VAR 0 3
63434: PUSH
63435: LD_INT 34
63437: EQUAL
63438: IFFALSE 63448
// sShield := true ;
63440: LD_ADDR_EXP 149
63444: PUSH
63445: LD_INT 1
63447: ST_TO_ADDR
// if p3 = 35 then
63448: LD_VAR 0 3
63452: PUSH
63453: LD_INT 35
63455: EQUAL
63456: IFFALSE 63466
// sTime := true ;
63458: LD_ADDR_EXP 150
63462: PUSH
63463: LD_INT 1
63465: ST_TO_ADDR
// if p3 = 36 then
63466: LD_VAR 0 3
63470: PUSH
63471: LD_INT 36
63473: EQUAL
63474: IFFALSE 63484
// sTools := true ;
63476: LD_ADDR_EXP 151
63480: PUSH
63481: LD_INT 1
63483: ST_TO_ADDR
// if p3 = 101 then
63484: LD_VAR 0 3
63488: PUSH
63489: LD_INT 101
63491: EQUAL
63492: IFFALSE 63502
// sSold := true ;
63494: LD_ADDR_EXP 116
63498: PUSH
63499: LD_INT 1
63501: ST_TO_ADDR
// if p3 = 102 then
63502: LD_VAR 0 3
63506: PUSH
63507: LD_INT 102
63509: EQUAL
63510: IFFALSE 63520
// sDiff := true ;
63512: LD_ADDR_EXP 117
63516: PUSH
63517: LD_INT 1
63519: ST_TO_ADDR
// if p3 = 103 then
63520: LD_VAR 0 3
63524: PUSH
63525: LD_INT 103
63527: EQUAL
63528: IFFALSE 63538
// sFog := true ;
63530: LD_ADDR_EXP 120
63534: PUSH
63535: LD_INT 1
63537: ST_TO_ADDR
// if p3 = 104 then
63538: LD_VAR 0 3
63542: PUSH
63543: LD_INT 104
63545: EQUAL
63546: IFFALSE 63556
// sReset := true ;
63548: LD_ADDR_EXP 121
63552: PUSH
63553: LD_INT 1
63555: ST_TO_ADDR
// if p3 = 105 then
63556: LD_VAR 0 3
63560: PUSH
63561: LD_INT 105
63563: EQUAL
63564: IFFALSE 63574
// sSun := true ;
63566: LD_ADDR_EXP 122
63570: PUSH
63571: LD_INT 1
63573: ST_TO_ADDR
// if p3 = 106 then
63574: LD_VAR 0 3
63578: PUSH
63579: LD_INT 106
63581: EQUAL
63582: IFFALSE 63592
// sTiger := true ;
63584: LD_ADDR_EXP 118
63588: PUSH
63589: LD_INT 1
63591: ST_TO_ADDR
// if p3 = 107 then
63592: LD_VAR 0 3
63596: PUSH
63597: LD_INT 107
63599: EQUAL
63600: IFFALSE 63610
// sBomb := true ;
63602: LD_ADDR_EXP 119
63606: PUSH
63607: LD_INT 1
63609: ST_TO_ADDR
// if p3 = 108 then
63610: LD_VAR 0 3
63614: PUSH
63615: LD_INT 108
63617: EQUAL
63618: IFFALSE 63628
// sWound := true ;
63620: LD_ADDR_EXP 127
63624: PUSH
63625: LD_INT 1
63627: ST_TO_ADDR
// if p3 = 109 then
63628: LD_VAR 0 3
63632: PUSH
63633: LD_INT 109
63635: EQUAL
63636: IFFALSE 63646
// sBetray := true ;
63638: LD_ADDR_EXP 131
63642: PUSH
63643: LD_INT 1
63645: ST_TO_ADDR
// if p3 = 110 then
63646: LD_VAR 0 3
63650: PUSH
63651: LD_INT 110
63653: EQUAL
63654: IFFALSE 63664
// sContamin := true ;
63656: LD_ADDR_EXP 132
63660: PUSH
63661: LD_INT 1
63663: ST_TO_ADDR
// if p3 = 111 then
63664: LD_VAR 0 3
63668: PUSH
63669: LD_INT 111
63671: EQUAL
63672: IFFALSE 63682
// sOil := true ;
63674: LD_ADDR_EXP 134
63678: PUSH
63679: LD_INT 1
63681: ST_TO_ADDR
// if p3 = 112 then
63682: LD_VAR 0 3
63686: PUSH
63687: LD_INT 112
63689: EQUAL
63690: IFFALSE 63700
// sStu := true ;
63692: LD_ADDR_EXP 138
63696: PUSH
63697: LD_INT 1
63699: ST_TO_ADDR
// if p3 = 113 then
63700: LD_VAR 0 3
63704: PUSH
63705: LD_INT 113
63707: EQUAL
63708: IFFALSE 63718
// sBazooka := true ;
63710: LD_ADDR_EXP 141
63714: PUSH
63715: LD_INT 1
63717: ST_TO_ADDR
// if p3 = 114 then
63718: LD_VAR 0 3
63722: PUSH
63723: LD_INT 114
63725: EQUAL
63726: IFFALSE 63736
// sMortar := true ;
63728: LD_ADDR_EXP 142
63732: PUSH
63733: LD_INT 1
63735: ST_TO_ADDR
// if p3 = 115 then
63736: LD_VAR 0 3
63740: PUSH
63741: LD_INT 115
63743: EQUAL
63744: IFFALSE 63754
// sRanger := true ;
63746: LD_ADDR_EXP 152
63750: PUSH
63751: LD_INT 1
63753: ST_TO_ADDR
// end ; if p2 = 101 then
63754: LD_VAR 0 2
63758: PUSH
63759: LD_INT 101
63761: EQUAL
63762: IFFALSE 63890
// begin case p3 of 1 :
63764: LD_VAR 0 3
63768: PUSH
63769: LD_INT 1
63771: DOUBLE
63772: EQUAL
63773: IFTRUE 63777
63775: GO 63784
63777: POP
// hHackUnlimitedResources ; 2 :
63778: CALL 74927 0 0
63782: GO 63890
63784: LD_INT 2
63786: DOUBLE
63787: EQUAL
63788: IFTRUE 63792
63790: GO 63799
63792: POP
// hHackSetLevel10 ; 3 :
63793: CALL 75060 0 0
63797: GO 63890
63799: LD_INT 3
63801: DOUBLE
63802: EQUAL
63803: IFTRUE 63807
63805: GO 63814
63807: POP
// hHackSetLevel10YourUnits ; 4 :
63808: CALL 75145 0 0
63812: GO 63890
63814: LD_INT 4
63816: DOUBLE
63817: EQUAL
63818: IFTRUE 63822
63820: GO 63829
63822: POP
// hHackInvincible ; 5 :
63823: CALL 75593 0 0
63827: GO 63890
63829: LD_INT 5
63831: DOUBLE
63832: EQUAL
63833: IFTRUE 63837
63835: GO 63844
63837: POP
// hHackInvisible ; 6 :
63838: CALL 75704 0 0
63842: GO 63890
63844: LD_INT 6
63846: DOUBLE
63847: EQUAL
63848: IFTRUE 63852
63850: GO 63859
63852: POP
// hHackChangeYourSide ; 7 :
63853: CALL 75761 0 0
63857: GO 63890
63859: LD_INT 7
63861: DOUBLE
63862: EQUAL
63863: IFTRUE 63867
63865: GO 63874
63867: POP
// hHackChangeUnitSide ; 8 :
63868: CALL 75803 0 0
63872: GO 63890
63874: LD_INT 8
63876: DOUBLE
63877: EQUAL
63878: IFTRUE 63882
63880: GO 63889
63882: POP
// hHackFog ; end ;
63883: CALL 75904 0 0
63887: GO 63890
63889: POP
// end ; end ;
63890: LD_VAR 0 7
63894: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger ; every 0 0$1 do
63895: GO 63897
63897: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
63898: LD_STRING initStreamRollete();
63900: PPUSH
63901: CALL_OW 559
// InitStreamMode ;
63905: CALL 63914 0 0
// DefineStreamItems ( ) ;
63909: CALL 64354 0 0
// end ;
63913: END
// function InitStreamMode ; begin
63914: LD_INT 0
63916: PPUSH
// streamModeActive := false ;
63917: LD_ADDR_EXP 99
63921: PUSH
63922: LD_INT 0
63924: ST_TO_ADDR
// normalCounter := 36 ;
63925: LD_ADDR_EXP 100
63929: PUSH
63930: LD_INT 36
63932: ST_TO_ADDR
// hardcoreCounter := 16 ;
63933: LD_ADDR_EXP 101
63937: PUSH
63938: LD_INT 16
63940: ST_TO_ADDR
// sRocket := false ;
63941: LD_ADDR_EXP 104
63945: PUSH
63946: LD_INT 0
63948: ST_TO_ADDR
// sSpeed := false ;
63949: LD_ADDR_EXP 103
63953: PUSH
63954: LD_INT 0
63956: ST_TO_ADDR
// sEngine := false ;
63957: LD_ADDR_EXP 105
63961: PUSH
63962: LD_INT 0
63964: ST_TO_ADDR
// sSpec := false ;
63965: LD_ADDR_EXP 102
63969: PUSH
63970: LD_INT 0
63972: ST_TO_ADDR
// sLevel := false ;
63973: LD_ADDR_EXP 106
63977: PUSH
63978: LD_INT 0
63980: ST_TO_ADDR
// sArmoury := false ;
63981: LD_ADDR_EXP 107
63985: PUSH
63986: LD_INT 0
63988: ST_TO_ADDR
// sRadar := false ;
63989: LD_ADDR_EXP 108
63993: PUSH
63994: LD_INT 0
63996: ST_TO_ADDR
// sBunker := false ;
63997: LD_ADDR_EXP 109
64001: PUSH
64002: LD_INT 0
64004: ST_TO_ADDR
// sHack := false ;
64005: LD_ADDR_EXP 110
64009: PUSH
64010: LD_INT 0
64012: ST_TO_ADDR
// sFire := false ;
64013: LD_ADDR_EXP 111
64017: PUSH
64018: LD_INT 0
64020: ST_TO_ADDR
// sRefresh := false ;
64021: LD_ADDR_EXP 112
64025: PUSH
64026: LD_INT 0
64028: ST_TO_ADDR
// sExp := false ;
64029: LD_ADDR_EXP 113
64033: PUSH
64034: LD_INT 0
64036: ST_TO_ADDR
// sDepot := false ;
64037: LD_ADDR_EXP 114
64041: PUSH
64042: LD_INT 0
64044: ST_TO_ADDR
// sFlag := false ;
64045: LD_ADDR_EXP 115
64049: PUSH
64050: LD_INT 0
64052: ST_TO_ADDR
// sKamikadze := false ;
64053: LD_ADDR_EXP 123
64057: PUSH
64058: LD_INT 0
64060: ST_TO_ADDR
// sTroll := false ;
64061: LD_ADDR_EXP 124
64065: PUSH
64066: LD_INT 0
64068: ST_TO_ADDR
// sSlow := false ;
64069: LD_ADDR_EXP 125
64073: PUSH
64074: LD_INT 0
64076: ST_TO_ADDR
// sLack := false ;
64077: LD_ADDR_EXP 126
64081: PUSH
64082: LD_INT 0
64084: ST_TO_ADDR
// sTank := false ;
64085: LD_ADDR_EXP 128
64089: PUSH
64090: LD_INT 0
64092: ST_TO_ADDR
// sRemote := false ;
64093: LD_ADDR_EXP 129
64097: PUSH
64098: LD_INT 0
64100: ST_TO_ADDR
// sPowell := false ;
64101: LD_ADDR_EXP 130
64105: PUSH
64106: LD_INT 0
64108: ST_TO_ADDR
// sTeleport := false ;
64109: LD_ADDR_EXP 133
64113: PUSH
64114: LD_INT 0
64116: ST_TO_ADDR
// sOilTower := false ;
64117: LD_ADDR_EXP 135
64121: PUSH
64122: LD_INT 0
64124: ST_TO_ADDR
// sShovel := false ;
64125: LD_ADDR_EXP 136
64129: PUSH
64130: LD_INT 0
64132: ST_TO_ADDR
// sSheik := false ;
64133: LD_ADDR_EXP 137
64137: PUSH
64138: LD_INT 0
64140: ST_TO_ADDR
// sEarthquake := false ;
64141: LD_ADDR_EXP 139
64145: PUSH
64146: LD_INT 0
64148: ST_TO_ADDR
// sAI := false ;
64149: LD_ADDR_EXP 140
64153: PUSH
64154: LD_INT 0
64156: ST_TO_ADDR
// sCargo := false ;
64157: LD_ADDR_EXP 143
64161: PUSH
64162: LD_INT 0
64164: ST_TO_ADDR
// sDLaser := false ;
64165: LD_ADDR_EXP 144
64169: PUSH
64170: LD_INT 0
64172: ST_TO_ADDR
// sExchange := false ;
64173: LD_ADDR_EXP 145
64177: PUSH
64178: LD_INT 0
64180: ST_TO_ADDR
// sFac := false ;
64181: LD_ADDR_EXP 146
64185: PUSH
64186: LD_INT 0
64188: ST_TO_ADDR
// sPower := false ;
64189: LD_ADDR_EXP 147
64193: PUSH
64194: LD_INT 0
64196: ST_TO_ADDR
// sRandom := false ;
64197: LD_ADDR_EXP 148
64201: PUSH
64202: LD_INT 0
64204: ST_TO_ADDR
// sShield := false ;
64205: LD_ADDR_EXP 149
64209: PUSH
64210: LD_INT 0
64212: ST_TO_ADDR
// sTime := false ;
64213: LD_ADDR_EXP 150
64217: PUSH
64218: LD_INT 0
64220: ST_TO_ADDR
// sTools := false ;
64221: LD_ADDR_EXP 151
64225: PUSH
64226: LD_INT 0
64228: ST_TO_ADDR
// sSold := false ;
64229: LD_ADDR_EXP 116
64233: PUSH
64234: LD_INT 0
64236: ST_TO_ADDR
// sDiff := false ;
64237: LD_ADDR_EXP 117
64241: PUSH
64242: LD_INT 0
64244: ST_TO_ADDR
// sFog := false ;
64245: LD_ADDR_EXP 120
64249: PUSH
64250: LD_INT 0
64252: ST_TO_ADDR
// sReset := false ;
64253: LD_ADDR_EXP 121
64257: PUSH
64258: LD_INT 0
64260: ST_TO_ADDR
// sSun := false ;
64261: LD_ADDR_EXP 122
64265: PUSH
64266: LD_INT 0
64268: ST_TO_ADDR
// sTiger := false ;
64269: LD_ADDR_EXP 118
64273: PUSH
64274: LD_INT 0
64276: ST_TO_ADDR
// sBomb := false ;
64277: LD_ADDR_EXP 119
64281: PUSH
64282: LD_INT 0
64284: ST_TO_ADDR
// sWound := false ;
64285: LD_ADDR_EXP 127
64289: PUSH
64290: LD_INT 0
64292: ST_TO_ADDR
// sBetray := false ;
64293: LD_ADDR_EXP 131
64297: PUSH
64298: LD_INT 0
64300: ST_TO_ADDR
// sContamin := false ;
64301: LD_ADDR_EXP 132
64305: PUSH
64306: LD_INT 0
64308: ST_TO_ADDR
// sOil := false ;
64309: LD_ADDR_EXP 134
64313: PUSH
64314: LD_INT 0
64316: ST_TO_ADDR
// sStu := false ;
64317: LD_ADDR_EXP 138
64321: PUSH
64322: LD_INT 0
64324: ST_TO_ADDR
// sBazooka := false ;
64325: LD_ADDR_EXP 141
64329: PUSH
64330: LD_INT 0
64332: ST_TO_ADDR
// sMortar := false ;
64333: LD_ADDR_EXP 142
64337: PUSH
64338: LD_INT 0
64340: ST_TO_ADDR
// sRanger := false ;
64341: LD_ADDR_EXP 152
64345: PUSH
64346: LD_INT 0
64348: ST_TO_ADDR
// end ;
64349: LD_VAR 0 1
64353: RET
// function DefineStreamItems ( ) ; var tmp , normal , hardcore , i ; begin
64354: LD_INT 0
64356: PPUSH
64357: PPUSH
64358: PPUSH
64359: PPUSH
64360: PPUSH
// result := [ ] ;
64361: LD_ADDR_VAR 0 1
64365: PUSH
64366: EMPTY
64367: ST_TO_ADDR
// if campaign_id = 1 then
64368: LD_OWVAR 69
64372: PUSH
64373: LD_INT 1
64375: EQUAL
64376: IFFALSE 67314
// begin case mission_number of 1 :
64378: LD_OWVAR 70
64382: PUSH
64383: LD_INT 1
64385: DOUBLE
64386: EQUAL
64387: IFTRUE 64391
64389: GO 64455
64391: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 ] ] ; 2 :
64392: LD_ADDR_VAR 0 1
64396: PUSH
64397: LD_INT 2
64399: PUSH
64400: LD_INT 4
64402: PUSH
64403: LD_INT 11
64405: PUSH
64406: LD_INT 12
64408: PUSH
64409: LD_INT 15
64411: PUSH
64412: LD_INT 16
64414: PUSH
64415: LD_INT 22
64417: PUSH
64418: LD_INT 23
64420: PUSH
64421: LD_INT 26
64423: PUSH
64424: EMPTY
64425: LIST
64426: LIST
64427: LIST
64428: LIST
64429: LIST
64430: LIST
64431: LIST
64432: LIST
64433: LIST
64434: PUSH
64435: LD_INT 101
64437: PUSH
64438: LD_INT 102
64440: PUSH
64441: LD_INT 106
64443: PUSH
64444: EMPTY
64445: LIST
64446: LIST
64447: LIST
64448: PUSH
64449: EMPTY
64450: LIST
64451: LIST
64452: ST_TO_ADDR
64453: GO 67312
64455: LD_INT 2
64457: DOUBLE
64458: EQUAL
64459: IFTRUE 64463
64461: GO 64535
64463: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 3 :
64464: LD_ADDR_VAR 0 1
64468: PUSH
64469: LD_INT 2
64471: PUSH
64472: LD_INT 4
64474: PUSH
64475: LD_INT 11
64477: PUSH
64478: LD_INT 12
64480: PUSH
64481: LD_INT 15
64483: PUSH
64484: LD_INT 16
64486: PUSH
64487: LD_INT 22
64489: PUSH
64490: LD_INT 23
64492: PUSH
64493: LD_INT 26
64495: PUSH
64496: EMPTY
64497: LIST
64498: LIST
64499: LIST
64500: LIST
64501: LIST
64502: LIST
64503: LIST
64504: LIST
64505: LIST
64506: PUSH
64507: LD_INT 101
64509: PUSH
64510: LD_INT 102
64512: PUSH
64513: LD_INT 105
64515: PUSH
64516: LD_INT 106
64518: PUSH
64519: LD_INT 108
64521: PUSH
64522: EMPTY
64523: LIST
64524: LIST
64525: LIST
64526: LIST
64527: LIST
64528: PUSH
64529: EMPTY
64530: LIST
64531: LIST
64532: ST_TO_ADDR
64533: GO 67312
64535: LD_INT 3
64537: DOUBLE
64538: EQUAL
64539: IFTRUE 64543
64541: GO 64619
64543: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 4 :
64544: LD_ADDR_VAR 0 1
64548: PUSH
64549: LD_INT 2
64551: PUSH
64552: LD_INT 4
64554: PUSH
64555: LD_INT 5
64557: PUSH
64558: LD_INT 11
64560: PUSH
64561: LD_INT 12
64563: PUSH
64564: LD_INT 15
64566: PUSH
64567: LD_INT 16
64569: PUSH
64570: LD_INT 22
64572: PUSH
64573: LD_INT 26
64575: PUSH
64576: LD_INT 36
64578: PUSH
64579: EMPTY
64580: LIST
64581: LIST
64582: LIST
64583: LIST
64584: LIST
64585: LIST
64586: LIST
64587: LIST
64588: LIST
64589: LIST
64590: PUSH
64591: LD_INT 101
64593: PUSH
64594: LD_INT 102
64596: PUSH
64597: LD_INT 105
64599: PUSH
64600: LD_INT 106
64602: PUSH
64603: LD_INT 108
64605: PUSH
64606: EMPTY
64607: LIST
64608: LIST
64609: LIST
64610: LIST
64611: LIST
64612: PUSH
64613: EMPTY
64614: LIST
64615: LIST
64616: ST_TO_ADDR
64617: GO 67312
64619: LD_INT 4
64621: DOUBLE
64622: EQUAL
64623: IFTRUE 64627
64625: GO 64711
64627: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 5 :
64628: LD_ADDR_VAR 0 1
64632: PUSH
64633: LD_INT 2
64635: PUSH
64636: LD_INT 4
64638: PUSH
64639: LD_INT 5
64641: PUSH
64642: LD_INT 8
64644: PUSH
64645: LD_INT 11
64647: PUSH
64648: LD_INT 12
64650: PUSH
64651: LD_INT 15
64653: PUSH
64654: LD_INT 16
64656: PUSH
64657: LD_INT 22
64659: PUSH
64660: LD_INT 23
64662: PUSH
64663: LD_INT 26
64665: PUSH
64666: LD_INT 36
64668: PUSH
64669: EMPTY
64670: LIST
64671: LIST
64672: LIST
64673: LIST
64674: LIST
64675: LIST
64676: LIST
64677: LIST
64678: LIST
64679: LIST
64680: LIST
64681: LIST
64682: PUSH
64683: LD_INT 101
64685: PUSH
64686: LD_INT 102
64688: PUSH
64689: LD_INT 105
64691: PUSH
64692: LD_INT 106
64694: PUSH
64695: LD_INT 108
64697: PUSH
64698: EMPTY
64699: LIST
64700: LIST
64701: LIST
64702: LIST
64703: LIST
64704: PUSH
64705: EMPTY
64706: LIST
64707: LIST
64708: ST_TO_ADDR
64709: GO 67312
64711: LD_INT 5
64713: DOUBLE
64714: EQUAL
64715: IFTRUE 64719
64717: GO 64819
64719: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 6 :
64720: LD_ADDR_VAR 0 1
64724: PUSH
64725: LD_INT 2
64727: PUSH
64728: LD_INT 4
64730: PUSH
64731: LD_INT 5
64733: PUSH
64734: LD_INT 6
64736: PUSH
64737: LD_INT 8
64739: PUSH
64740: LD_INT 11
64742: PUSH
64743: LD_INT 12
64745: PUSH
64746: LD_INT 15
64748: PUSH
64749: LD_INT 16
64751: PUSH
64752: LD_INT 22
64754: PUSH
64755: LD_INT 23
64757: PUSH
64758: LD_INT 25
64760: PUSH
64761: LD_INT 26
64763: PUSH
64764: LD_INT 36
64766: PUSH
64767: EMPTY
64768: LIST
64769: LIST
64770: LIST
64771: LIST
64772: LIST
64773: LIST
64774: LIST
64775: LIST
64776: LIST
64777: LIST
64778: LIST
64779: LIST
64780: LIST
64781: LIST
64782: PUSH
64783: LD_INT 101
64785: PUSH
64786: LD_INT 102
64788: PUSH
64789: LD_INT 105
64791: PUSH
64792: LD_INT 106
64794: PUSH
64795: LD_INT 108
64797: PUSH
64798: LD_INT 109
64800: PUSH
64801: LD_INT 112
64803: PUSH
64804: EMPTY
64805: LIST
64806: LIST
64807: LIST
64808: LIST
64809: LIST
64810: LIST
64811: LIST
64812: PUSH
64813: EMPTY
64814: LIST
64815: LIST
64816: ST_TO_ADDR
64817: GO 67312
64819: LD_INT 6
64821: DOUBLE
64822: EQUAL
64823: IFTRUE 64827
64825: GO 64947
64827: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 7 :
64828: LD_ADDR_VAR 0 1
64832: PUSH
64833: LD_INT 2
64835: PUSH
64836: LD_INT 4
64838: PUSH
64839: LD_INT 5
64841: PUSH
64842: LD_INT 6
64844: PUSH
64845: LD_INT 8
64847: PUSH
64848: LD_INT 11
64850: PUSH
64851: LD_INT 12
64853: PUSH
64854: LD_INT 15
64856: PUSH
64857: LD_INT 16
64859: PUSH
64860: LD_INT 20
64862: PUSH
64863: LD_INT 21
64865: PUSH
64866: LD_INT 22
64868: PUSH
64869: LD_INT 23
64871: PUSH
64872: LD_INT 25
64874: PUSH
64875: LD_INT 26
64877: PUSH
64878: LD_INT 30
64880: PUSH
64881: LD_INT 31
64883: PUSH
64884: LD_INT 32
64886: PUSH
64887: LD_INT 36
64889: PUSH
64890: EMPTY
64891: LIST
64892: LIST
64893: LIST
64894: LIST
64895: LIST
64896: LIST
64897: LIST
64898: LIST
64899: LIST
64900: LIST
64901: LIST
64902: LIST
64903: LIST
64904: LIST
64905: LIST
64906: LIST
64907: LIST
64908: LIST
64909: LIST
64910: PUSH
64911: LD_INT 101
64913: PUSH
64914: LD_INT 102
64916: PUSH
64917: LD_INT 105
64919: PUSH
64920: LD_INT 106
64922: PUSH
64923: LD_INT 108
64925: PUSH
64926: LD_INT 109
64928: PUSH
64929: LD_INT 112
64931: PUSH
64932: EMPTY
64933: LIST
64934: LIST
64935: LIST
64936: LIST
64937: LIST
64938: LIST
64939: LIST
64940: PUSH
64941: EMPTY
64942: LIST
64943: LIST
64944: ST_TO_ADDR
64945: GO 67312
64947: LD_INT 7
64949: DOUBLE
64950: EQUAL
64951: IFTRUE 64955
64953: GO 65055
64955: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 ] ] ; 8 :
64956: LD_ADDR_VAR 0 1
64960: PUSH
64961: LD_INT 2
64963: PUSH
64964: LD_INT 4
64966: PUSH
64967: LD_INT 5
64969: PUSH
64970: LD_INT 7
64972: PUSH
64973: LD_INT 11
64975: PUSH
64976: LD_INT 12
64978: PUSH
64979: LD_INT 15
64981: PUSH
64982: LD_INT 16
64984: PUSH
64985: LD_INT 20
64987: PUSH
64988: LD_INT 21
64990: PUSH
64991: LD_INT 22
64993: PUSH
64994: LD_INT 23
64996: PUSH
64997: LD_INT 25
64999: PUSH
65000: LD_INT 26
65002: PUSH
65003: EMPTY
65004: LIST
65005: LIST
65006: LIST
65007: LIST
65008: LIST
65009: LIST
65010: LIST
65011: LIST
65012: LIST
65013: LIST
65014: LIST
65015: LIST
65016: LIST
65017: LIST
65018: PUSH
65019: LD_INT 101
65021: PUSH
65022: LD_INT 102
65024: PUSH
65025: LD_INT 103
65027: PUSH
65028: LD_INT 105
65030: PUSH
65031: LD_INT 106
65033: PUSH
65034: LD_INT 108
65036: PUSH
65037: LD_INT 112
65039: PUSH
65040: EMPTY
65041: LIST
65042: LIST
65043: LIST
65044: LIST
65045: LIST
65046: LIST
65047: LIST
65048: PUSH
65049: EMPTY
65050: LIST
65051: LIST
65052: ST_TO_ADDR
65053: GO 67312
65055: LD_INT 8
65057: DOUBLE
65058: EQUAL
65059: IFTRUE 65063
65061: GO 65191
65063: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 ] ] ; 9 :
65064: LD_ADDR_VAR 0 1
65068: PUSH
65069: LD_INT 2
65071: PUSH
65072: LD_INT 4
65074: PUSH
65075: LD_INT 5
65077: PUSH
65078: LD_INT 6
65080: PUSH
65081: LD_INT 7
65083: PUSH
65084: LD_INT 8
65086: PUSH
65087: LD_INT 11
65089: PUSH
65090: LD_INT 12
65092: PUSH
65093: LD_INT 15
65095: PUSH
65096: LD_INT 16
65098: PUSH
65099: LD_INT 20
65101: PUSH
65102: LD_INT 21
65104: PUSH
65105: LD_INT 22
65107: PUSH
65108: LD_INT 23
65110: PUSH
65111: LD_INT 25
65113: PUSH
65114: LD_INT 26
65116: PUSH
65117: LD_INT 30
65119: PUSH
65120: LD_INT 31
65122: PUSH
65123: LD_INT 32
65125: PUSH
65126: LD_INT 36
65128: PUSH
65129: EMPTY
65130: LIST
65131: LIST
65132: LIST
65133: LIST
65134: LIST
65135: LIST
65136: LIST
65137: LIST
65138: LIST
65139: LIST
65140: LIST
65141: LIST
65142: LIST
65143: LIST
65144: LIST
65145: LIST
65146: LIST
65147: LIST
65148: LIST
65149: LIST
65150: PUSH
65151: LD_INT 101
65153: PUSH
65154: LD_INT 102
65156: PUSH
65157: LD_INT 103
65159: PUSH
65160: LD_INT 105
65162: PUSH
65163: LD_INT 106
65165: PUSH
65166: LD_INT 108
65168: PUSH
65169: LD_INT 109
65171: PUSH
65172: LD_INT 112
65174: PUSH
65175: EMPTY
65176: LIST
65177: LIST
65178: LIST
65179: LIST
65180: LIST
65181: LIST
65182: LIST
65183: LIST
65184: PUSH
65185: EMPTY
65186: LIST
65187: LIST
65188: ST_TO_ADDR
65189: GO 67312
65191: LD_INT 9
65193: DOUBLE
65194: EQUAL
65195: IFTRUE 65199
65197: GO 65335
65199: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 ] ] ; 10 :
65200: LD_ADDR_VAR 0 1
65204: PUSH
65205: LD_INT 2
65207: PUSH
65208: LD_INT 4
65210: PUSH
65211: LD_INT 5
65213: PUSH
65214: LD_INT 6
65216: PUSH
65217: LD_INT 7
65219: PUSH
65220: LD_INT 8
65222: PUSH
65223: LD_INT 11
65225: PUSH
65226: LD_INT 12
65228: PUSH
65229: LD_INT 15
65231: PUSH
65232: LD_INT 16
65234: PUSH
65235: LD_INT 20
65237: PUSH
65238: LD_INT 21
65240: PUSH
65241: LD_INT 22
65243: PUSH
65244: LD_INT 23
65246: PUSH
65247: LD_INT 25
65249: PUSH
65250: LD_INT 26
65252: PUSH
65253: LD_INT 28
65255: PUSH
65256: LD_INT 30
65258: PUSH
65259: LD_INT 31
65261: PUSH
65262: LD_INT 32
65264: PUSH
65265: LD_INT 36
65267: PUSH
65268: EMPTY
65269: LIST
65270: LIST
65271: LIST
65272: LIST
65273: LIST
65274: LIST
65275: LIST
65276: LIST
65277: LIST
65278: LIST
65279: LIST
65280: LIST
65281: LIST
65282: LIST
65283: LIST
65284: LIST
65285: LIST
65286: LIST
65287: LIST
65288: LIST
65289: LIST
65290: PUSH
65291: LD_INT 101
65293: PUSH
65294: LD_INT 102
65296: PUSH
65297: LD_INT 103
65299: PUSH
65300: LD_INT 105
65302: PUSH
65303: LD_INT 106
65305: PUSH
65306: LD_INT 108
65308: PUSH
65309: LD_INT 109
65311: PUSH
65312: LD_INT 112
65314: PUSH
65315: LD_INT 114
65317: PUSH
65318: EMPTY
65319: LIST
65320: LIST
65321: LIST
65322: LIST
65323: LIST
65324: LIST
65325: LIST
65326: LIST
65327: LIST
65328: PUSH
65329: EMPTY
65330: LIST
65331: LIST
65332: ST_TO_ADDR
65333: GO 67312
65335: LD_INT 10
65337: DOUBLE
65338: EQUAL
65339: IFTRUE 65343
65341: GO 65527
65343: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 11 :
65344: LD_ADDR_VAR 0 1
65348: PUSH
65349: LD_INT 2
65351: PUSH
65352: LD_INT 4
65354: PUSH
65355: LD_INT 5
65357: PUSH
65358: LD_INT 6
65360: PUSH
65361: LD_INT 7
65363: PUSH
65364: LD_INT 8
65366: PUSH
65367: LD_INT 9
65369: PUSH
65370: LD_INT 10
65372: PUSH
65373: LD_INT 11
65375: PUSH
65376: LD_INT 12
65378: PUSH
65379: LD_INT 13
65381: PUSH
65382: LD_INT 14
65384: PUSH
65385: LD_INT 15
65387: PUSH
65388: LD_INT 16
65390: PUSH
65391: LD_INT 17
65393: PUSH
65394: LD_INT 18
65396: PUSH
65397: LD_INT 19
65399: PUSH
65400: LD_INT 20
65402: PUSH
65403: LD_INT 21
65405: PUSH
65406: LD_INT 22
65408: PUSH
65409: LD_INT 23
65411: PUSH
65412: LD_INT 24
65414: PUSH
65415: LD_INT 25
65417: PUSH
65418: LD_INT 26
65420: PUSH
65421: LD_INT 28
65423: PUSH
65424: LD_INT 30
65426: PUSH
65427: LD_INT 31
65429: PUSH
65430: LD_INT 32
65432: PUSH
65433: LD_INT 36
65435: PUSH
65436: EMPTY
65437: LIST
65438: LIST
65439: LIST
65440: LIST
65441: LIST
65442: LIST
65443: LIST
65444: LIST
65445: LIST
65446: LIST
65447: LIST
65448: LIST
65449: LIST
65450: LIST
65451: LIST
65452: LIST
65453: LIST
65454: LIST
65455: LIST
65456: LIST
65457: LIST
65458: LIST
65459: LIST
65460: LIST
65461: LIST
65462: LIST
65463: LIST
65464: LIST
65465: LIST
65466: PUSH
65467: LD_INT 101
65469: PUSH
65470: LD_INT 102
65472: PUSH
65473: LD_INT 103
65475: PUSH
65476: LD_INT 104
65478: PUSH
65479: LD_INT 105
65481: PUSH
65482: LD_INT 106
65484: PUSH
65485: LD_INT 107
65487: PUSH
65488: LD_INT 108
65490: PUSH
65491: LD_INT 109
65493: PUSH
65494: LD_INT 110
65496: PUSH
65497: LD_INT 111
65499: PUSH
65500: LD_INT 112
65502: PUSH
65503: LD_INT 114
65505: PUSH
65506: EMPTY
65507: LIST
65508: LIST
65509: LIST
65510: LIST
65511: LIST
65512: LIST
65513: LIST
65514: LIST
65515: LIST
65516: LIST
65517: LIST
65518: LIST
65519: LIST
65520: PUSH
65521: EMPTY
65522: LIST
65523: LIST
65524: ST_TO_ADDR
65525: GO 67312
65527: LD_INT 11
65529: DOUBLE
65530: EQUAL
65531: IFTRUE 65535
65533: GO 65727
65535: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 12 :
65536: LD_ADDR_VAR 0 1
65540: PUSH
65541: LD_INT 2
65543: PUSH
65544: LD_INT 3
65546: PUSH
65547: LD_INT 4
65549: PUSH
65550: LD_INT 5
65552: PUSH
65553: LD_INT 6
65555: PUSH
65556: LD_INT 7
65558: PUSH
65559: LD_INT 8
65561: PUSH
65562: LD_INT 9
65564: PUSH
65565: LD_INT 10
65567: PUSH
65568: LD_INT 11
65570: PUSH
65571: LD_INT 12
65573: PUSH
65574: LD_INT 13
65576: PUSH
65577: LD_INT 14
65579: PUSH
65580: LD_INT 15
65582: PUSH
65583: LD_INT 16
65585: PUSH
65586: LD_INT 17
65588: PUSH
65589: LD_INT 18
65591: PUSH
65592: LD_INT 19
65594: PUSH
65595: LD_INT 20
65597: PUSH
65598: LD_INT 21
65600: PUSH
65601: LD_INT 22
65603: PUSH
65604: LD_INT 23
65606: PUSH
65607: LD_INT 24
65609: PUSH
65610: LD_INT 25
65612: PUSH
65613: LD_INT 26
65615: PUSH
65616: LD_INT 28
65618: PUSH
65619: LD_INT 30
65621: PUSH
65622: LD_INT 31
65624: PUSH
65625: LD_INT 32
65627: PUSH
65628: LD_INT 34
65630: PUSH
65631: LD_INT 36
65633: PUSH
65634: EMPTY
65635: LIST
65636: LIST
65637: LIST
65638: LIST
65639: LIST
65640: LIST
65641: LIST
65642: LIST
65643: LIST
65644: LIST
65645: LIST
65646: LIST
65647: LIST
65648: LIST
65649: LIST
65650: LIST
65651: LIST
65652: LIST
65653: LIST
65654: LIST
65655: LIST
65656: LIST
65657: LIST
65658: LIST
65659: LIST
65660: LIST
65661: LIST
65662: LIST
65663: LIST
65664: LIST
65665: LIST
65666: PUSH
65667: LD_INT 101
65669: PUSH
65670: LD_INT 102
65672: PUSH
65673: LD_INT 103
65675: PUSH
65676: LD_INT 104
65678: PUSH
65679: LD_INT 105
65681: PUSH
65682: LD_INT 106
65684: PUSH
65685: LD_INT 107
65687: PUSH
65688: LD_INT 108
65690: PUSH
65691: LD_INT 109
65693: PUSH
65694: LD_INT 110
65696: PUSH
65697: LD_INT 111
65699: PUSH
65700: LD_INT 112
65702: PUSH
65703: LD_INT 114
65705: PUSH
65706: EMPTY
65707: LIST
65708: LIST
65709: LIST
65710: LIST
65711: LIST
65712: LIST
65713: LIST
65714: LIST
65715: LIST
65716: LIST
65717: LIST
65718: LIST
65719: LIST
65720: PUSH
65721: EMPTY
65722: LIST
65723: LIST
65724: ST_TO_ADDR
65725: GO 67312
65727: LD_INT 12
65729: DOUBLE
65730: EQUAL
65731: IFTRUE 65735
65733: GO 65943
65735: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 13 :
65736: LD_ADDR_VAR 0 1
65740: PUSH
65741: LD_INT 1
65743: PUSH
65744: LD_INT 2
65746: PUSH
65747: LD_INT 3
65749: PUSH
65750: LD_INT 4
65752: PUSH
65753: LD_INT 5
65755: PUSH
65756: LD_INT 6
65758: PUSH
65759: LD_INT 7
65761: PUSH
65762: LD_INT 8
65764: PUSH
65765: LD_INT 9
65767: PUSH
65768: LD_INT 10
65770: PUSH
65771: LD_INT 11
65773: PUSH
65774: LD_INT 12
65776: PUSH
65777: LD_INT 13
65779: PUSH
65780: LD_INT 14
65782: PUSH
65783: LD_INT 15
65785: PUSH
65786: LD_INT 16
65788: PUSH
65789: LD_INT 17
65791: PUSH
65792: LD_INT 18
65794: PUSH
65795: LD_INT 19
65797: PUSH
65798: LD_INT 20
65800: PUSH
65801: LD_INT 21
65803: PUSH
65804: LD_INT 22
65806: PUSH
65807: LD_INT 23
65809: PUSH
65810: LD_INT 24
65812: PUSH
65813: LD_INT 25
65815: PUSH
65816: LD_INT 26
65818: PUSH
65819: LD_INT 27
65821: PUSH
65822: LD_INT 28
65824: PUSH
65825: LD_INT 30
65827: PUSH
65828: LD_INT 31
65830: PUSH
65831: LD_INT 32
65833: PUSH
65834: LD_INT 33
65836: PUSH
65837: LD_INT 34
65839: PUSH
65840: LD_INT 36
65842: PUSH
65843: EMPTY
65844: LIST
65845: LIST
65846: LIST
65847: LIST
65848: LIST
65849: LIST
65850: LIST
65851: LIST
65852: LIST
65853: LIST
65854: LIST
65855: LIST
65856: LIST
65857: LIST
65858: LIST
65859: LIST
65860: LIST
65861: LIST
65862: LIST
65863: LIST
65864: LIST
65865: LIST
65866: LIST
65867: LIST
65868: LIST
65869: LIST
65870: LIST
65871: LIST
65872: LIST
65873: LIST
65874: LIST
65875: LIST
65876: LIST
65877: LIST
65878: PUSH
65879: LD_INT 101
65881: PUSH
65882: LD_INT 102
65884: PUSH
65885: LD_INT 103
65887: PUSH
65888: LD_INT 104
65890: PUSH
65891: LD_INT 105
65893: PUSH
65894: LD_INT 106
65896: PUSH
65897: LD_INT 107
65899: PUSH
65900: LD_INT 108
65902: PUSH
65903: LD_INT 109
65905: PUSH
65906: LD_INT 110
65908: PUSH
65909: LD_INT 111
65911: PUSH
65912: LD_INT 112
65914: PUSH
65915: LD_INT 113
65917: PUSH
65918: LD_INT 114
65920: PUSH
65921: EMPTY
65922: LIST
65923: LIST
65924: LIST
65925: LIST
65926: LIST
65927: LIST
65928: LIST
65929: LIST
65930: LIST
65931: LIST
65932: LIST
65933: LIST
65934: LIST
65935: LIST
65936: PUSH
65937: EMPTY
65938: LIST
65939: LIST
65940: ST_TO_ADDR
65941: GO 67312
65943: LD_INT 13
65945: DOUBLE
65946: EQUAL
65947: IFTRUE 65951
65949: GO 66147
65951: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 14 :
65952: LD_ADDR_VAR 0 1
65956: PUSH
65957: LD_INT 1
65959: PUSH
65960: LD_INT 2
65962: PUSH
65963: LD_INT 3
65965: PUSH
65966: LD_INT 4
65968: PUSH
65969: LD_INT 5
65971: PUSH
65972: LD_INT 8
65974: PUSH
65975: LD_INT 9
65977: PUSH
65978: LD_INT 10
65980: PUSH
65981: LD_INT 11
65983: PUSH
65984: LD_INT 12
65986: PUSH
65987: LD_INT 14
65989: PUSH
65990: LD_INT 15
65992: PUSH
65993: LD_INT 16
65995: PUSH
65996: LD_INT 17
65998: PUSH
65999: LD_INT 18
66001: PUSH
66002: LD_INT 19
66004: PUSH
66005: LD_INT 20
66007: PUSH
66008: LD_INT 21
66010: PUSH
66011: LD_INT 22
66013: PUSH
66014: LD_INT 23
66016: PUSH
66017: LD_INT 24
66019: PUSH
66020: LD_INT 25
66022: PUSH
66023: LD_INT 26
66025: PUSH
66026: LD_INT 27
66028: PUSH
66029: LD_INT 28
66031: PUSH
66032: LD_INT 30
66034: PUSH
66035: LD_INT 31
66037: PUSH
66038: LD_INT 32
66040: PUSH
66041: LD_INT 33
66043: PUSH
66044: LD_INT 34
66046: PUSH
66047: LD_INT 36
66049: PUSH
66050: EMPTY
66051: LIST
66052: LIST
66053: LIST
66054: LIST
66055: LIST
66056: LIST
66057: LIST
66058: LIST
66059: LIST
66060: LIST
66061: LIST
66062: LIST
66063: LIST
66064: LIST
66065: LIST
66066: LIST
66067: LIST
66068: LIST
66069: LIST
66070: LIST
66071: LIST
66072: LIST
66073: LIST
66074: LIST
66075: LIST
66076: LIST
66077: LIST
66078: LIST
66079: LIST
66080: LIST
66081: LIST
66082: PUSH
66083: LD_INT 101
66085: PUSH
66086: LD_INT 102
66088: PUSH
66089: LD_INT 103
66091: PUSH
66092: LD_INT 104
66094: PUSH
66095: LD_INT 105
66097: PUSH
66098: LD_INT 106
66100: PUSH
66101: LD_INT 107
66103: PUSH
66104: LD_INT 108
66106: PUSH
66107: LD_INT 109
66109: PUSH
66110: LD_INT 110
66112: PUSH
66113: LD_INT 111
66115: PUSH
66116: LD_INT 112
66118: PUSH
66119: LD_INT 113
66121: PUSH
66122: LD_INT 114
66124: PUSH
66125: EMPTY
66126: LIST
66127: LIST
66128: LIST
66129: LIST
66130: LIST
66131: LIST
66132: LIST
66133: LIST
66134: LIST
66135: LIST
66136: LIST
66137: LIST
66138: LIST
66139: LIST
66140: PUSH
66141: EMPTY
66142: LIST
66143: LIST
66144: ST_TO_ADDR
66145: GO 67312
66147: LD_INT 14
66149: DOUBLE
66150: EQUAL
66151: IFTRUE 66155
66153: GO 66367
66155: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 15 :
66156: LD_ADDR_VAR 0 1
66160: PUSH
66161: LD_INT 1
66163: PUSH
66164: LD_INT 2
66166: PUSH
66167: LD_INT 3
66169: PUSH
66170: LD_INT 4
66172: PUSH
66173: LD_INT 5
66175: PUSH
66176: LD_INT 6
66178: PUSH
66179: LD_INT 7
66181: PUSH
66182: LD_INT 8
66184: PUSH
66185: LD_INT 9
66187: PUSH
66188: LD_INT 10
66190: PUSH
66191: LD_INT 11
66193: PUSH
66194: LD_INT 12
66196: PUSH
66197: LD_INT 13
66199: PUSH
66200: LD_INT 14
66202: PUSH
66203: LD_INT 15
66205: PUSH
66206: LD_INT 16
66208: PUSH
66209: LD_INT 17
66211: PUSH
66212: LD_INT 18
66214: PUSH
66215: LD_INT 19
66217: PUSH
66218: LD_INT 20
66220: PUSH
66221: LD_INT 21
66223: PUSH
66224: LD_INT 22
66226: PUSH
66227: LD_INT 23
66229: PUSH
66230: LD_INT 24
66232: PUSH
66233: LD_INT 25
66235: PUSH
66236: LD_INT 26
66238: PUSH
66239: LD_INT 27
66241: PUSH
66242: LD_INT 28
66244: PUSH
66245: LD_INT 29
66247: PUSH
66248: LD_INT 30
66250: PUSH
66251: LD_INT 31
66253: PUSH
66254: LD_INT 32
66256: PUSH
66257: LD_INT 33
66259: PUSH
66260: LD_INT 34
66262: PUSH
66263: LD_INT 36
66265: PUSH
66266: EMPTY
66267: LIST
66268: LIST
66269: LIST
66270: LIST
66271: LIST
66272: LIST
66273: LIST
66274: LIST
66275: LIST
66276: LIST
66277: LIST
66278: LIST
66279: LIST
66280: LIST
66281: LIST
66282: LIST
66283: LIST
66284: LIST
66285: LIST
66286: LIST
66287: LIST
66288: LIST
66289: LIST
66290: LIST
66291: LIST
66292: LIST
66293: LIST
66294: LIST
66295: LIST
66296: LIST
66297: LIST
66298: LIST
66299: LIST
66300: LIST
66301: LIST
66302: PUSH
66303: LD_INT 101
66305: PUSH
66306: LD_INT 102
66308: PUSH
66309: LD_INT 103
66311: PUSH
66312: LD_INT 104
66314: PUSH
66315: LD_INT 105
66317: PUSH
66318: LD_INT 106
66320: PUSH
66321: LD_INT 107
66323: PUSH
66324: LD_INT 108
66326: PUSH
66327: LD_INT 109
66329: PUSH
66330: LD_INT 110
66332: PUSH
66333: LD_INT 111
66335: PUSH
66336: LD_INT 112
66338: PUSH
66339: LD_INT 113
66341: PUSH
66342: LD_INT 114
66344: PUSH
66345: EMPTY
66346: LIST
66347: LIST
66348: LIST
66349: LIST
66350: LIST
66351: LIST
66352: LIST
66353: LIST
66354: LIST
66355: LIST
66356: LIST
66357: LIST
66358: LIST
66359: LIST
66360: PUSH
66361: EMPTY
66362: LIST
66363: LIST
66364: ST_TO_ADDR
66365: GO 67312
66367: LD_INT 15
66369: DOUBLE
66370: EQUAL
66371: IFTRUE 66375
66373: GO 66587
66375: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 16 :
66376: LD_ADDR_VAR 0 1
66380: PUSH
66381: LD_INT 1
66383: PUSH
66384: LD_INT 2
66386: PUSH
66387: LD_INT 3
66389: PUSH
66390: LD_INT 4
66392: PUSH
66393: LD_INT 5
66395: PUSH
66396: LD_INT 6
66398: PUSH
66399: LD_INT 7
66401: PUSH
66402: LD_INT 8
66404: PUSH
66405: LD_INT 9
66407: PUSH
66408: LD_INT 10
66410: PUSH
66411: LD_INT 11
66413: PUSH
66414: LD_INT 12
66416: PUSH
66417: LD_INT 13
66419: PUSH
66420: LD_INT 14
66422: PUSH
66423: LD_INT 15
66425: PUSH
66426: LD_INT 16
66428: PUSH
66429: LD_INT 17
66431: PUSH
66432: LD_INT 18
66434: PUSH
66435: LD_INT 19
66437: PUSH
66438: LD_INT 20
66440: PUSH
66441: LD_INT 21
66443: PUSH
66444: LD_INT 22
66446: PUSH
66447: LD_INT 23
66449: PUSH
66450: LD_INT 24
66452: PUSH
66453: LD_INT 25
66455: PUSH
66456: LD_INT 26
66458: PUSH
66459: LD_INT 27
66461: PUSH
66462: LD_INT 28
66464: PUSH
66465: LD_INT 29
66467: PUSH
66468: LD_INT 30
66470: PUSH
66471: LD_INT 31
66473: PUSH
66474: LD_INT 32
66476: PUSH
66477: LD_INT 33
66479: PUSH
66480: LD_INT 34
66482: PUSH
66483: LD_INT 36
66485: PUSH
66486: EMPTY
66487: LIST
66488: LIST
66489: LIST
66490: LIST
66491: LIST
66492: LIST
66493: LIST
66494: LIST
66495: LIST
66496: LIST
66497: LIST
66498: LIST
66499: LIST
66500: LIST
66501: LIST
66502: LIST
66503: LIST
66504: LIST
66505: LIST
66506: LIST
66507: LIST
66508: LIST
66509: LIST
66510: LIST
66511: LIST
66512: LIST
66513: LIST
66514: LIST
66515: LIST
66516: LIST
66517: LIST
66518: LIST
66519: LIST
66520: LIST
66521: LIST
66522: PUSH
66523: LD_INT 101
66525: PUSH
66526: LD_INT 102
66528: PUSH
66529: LD_INT 103
66531: PUSH
66532: LD_INT 104
66534: PUSH
66535: LD_INT 105
66537: PUSH
66538: LD_INT 106
66540: PUSH
66541: LD_INT 107
66543: PUSH
66544: LD_INT 108
66546: PUSH
66547: LD_INT 109
66549: PUSH
66550: LD_INT 110
66552: PUSH
66553: LD_INT 111
66555: PUSH
66556: LD_INT 112
66558: PUSH
66559: LD_INT 113
66561: PUSH
66562: LD_INT 114
66564: PUSH
66565: EMPTY
66566: LIST
66567: LIST
66568: LIST
66569: LIST
66570: LIST
66571: LIST
66572: LIST
66573: LIST
66574: LIST
66575: LIST
66576: LIST
66577: LIST
66578: LIST
66579: LIST
66580: PUSH
66581: EMPTY
66582: LIST
66583: LIST
66584: ST_TO_ADDR
66585: GO 67312
66587: LD_INT 16
66589: DOUBLE
66590: EQUAL
66591: IFTRUE 66595
66593: GO 66719
66595: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 ] ] ; 17 :
66596: LD_ADDR_VAR 0 1
66600: PUSH
66601: LD_INT 2
66603: PUSH
66604: LD_INT 4
66606: PUSH
66607: LD_INT 5
66609: PUSH
66610: LD_INT 7
66612: PUSH
66613: LD_INT 11
66615: PUSH
66616: LD_INT 12
66618: PUSH
66619: LD_INT 15
66621: PUSH
66622: LD_INT 16
66624: PUSH
66625: LD_INT 20
66627: PUSH
66628: LD_INT 21
66630: PUSH
66631: LD_INT 22
66633: PUSH
66634: LD_INT 23
66636: PUSH
66637: LD_INT 25
66639: PUSH
66640: LD_INT 26
66642: PUSH
66643: LD_INT 30
66645: PUSH
66646: LD_INT 31
66648: PUSH
66649: LD_INT 32
66651: PUSH
66652: LD_INT 33
66654: PUSH
66655: LD_INT 34
66657: PUSH
66658: EMPTY
66659: LIST
66660: LIST
66661: LIST
66662: LIST
66663: LIST
66664: LIST
66665: LIST
66666: LIST
66667: LIST
66668: LIST
66669: LIST
66670: LIST
66671: LIST
66672: LIST
66673: LIST
66674: LIST
66675: LIST
66676: LIST
66677: LIST
66678: PUSH
66679: LD_INT 101
66681: PUSH
66682: LD_INT 102
66684: PUSH
66685: LD_INT 103
66687: PUSH
66688: LD_INT 106
66690: PUSH
66691: LD_INT 108
66693: PUSH
66694: LD_INT 112
66696: PUSH
66697: LD_INT 113
66699: PUSH
66700: LD_INT 114
66702: PUSH
66703: EMPTY
66704: LIST
66705: LIST
66706: LIST
66707: LIST
66708: LIST
66709: LIST
66710: LIST
66711: LIST
66712: PUSH
66713: EMPTY
66714: LIST
66715: LIST
66716: ST_TO_ADDR
66717: GO 67312
66719: LD_INT 17
66721: DOUBLE
66722: EQUAL
66723: IFTRUE 66727
66725: GO 66939
66727: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 18 :
66728: LD_ADDR_VAR 0 1
66732: PUSH
66733: LD_INT 1
66735: PUSH
66736: LD_INT 2
66738: PUSH
66739: LD_INT 3
66741: PUSH
66742: LD_INT 4
66744: PUSH
66745: LD_INT 5
66747: PUSH
66748: LD_INT 6
66750: PUSH
66751: LD_INT 7
66753: PUSH
66754: LD_INT 8
66756: PUSH
66757: LD_INT 9
66759: PUSH
66760: LD_INT 10
66762: PUSH
66763: LD_INT 11
66765: PUSH
66766: LD_INT 12
66768: PUSH
66769: LD_INT 13
66771: PUSH
66772: LD_INT 14
66774: PUSH
66775: LD_INT 15
66777: PUSH
66778: LD_INT 16
66780: PUSH
66781: LD_INT 17
66783: PUSH
66784: LD_INT 18
66786: PUSH
66787: LD_INT 19
66789: PUSH
66790: LD_INT 20
66792: PUSH
66793: LD_INT 21
66795: PUSH
66796: LD_INT 22
66798: PUSH
66799: LD_INT 23
66801: PUSH
66802: LD_INT 24
66804: PUSH
66805: LD_INT 25
66807: PUSH
66808: LD_INT 26
66810: PUSH
66811: LD_INT 27
66813: PUSH
66814: LD_INT 28
66816: PUSH
66817: LD_INT 29
66819: PUSH
66820: LD_INT 30
66822: PUSH
66823: LD_INT 31
66825: PUSH
66826: LD_INT 32
66828: PUSH
66829: LD_INT 33
66831: PUSH
66832: LD_INT 34
66834: PUSH
66835: LD_INT 36
66837: PUSH
66838: EMPTY
66839: LIST
66840: LIST
66841: LIST
66842: LIST
66843: LIST
66844: LIST
66845: LIST
66846: LIST
66847: LIST
66848: LIST
66849: LIST
66850: LIST
66851: LIST
66852: LIST
66853: LIST
66854: LIST
66855: LIST
66856: LIST
66857: LIST
66858: LIST
66859: LIST
66860: LIST
66861: LIST
66862: LIST
66863: LIST
66864: LIST
66865: LIST
66866: LIST
66867: LIST
66868: LIST
66869: LIST
66870: LIST
66871: LIST
66872: LIST
66873: LIST
66874: PUSH
66875: LD_INT 101
66877: PUSH
66878: LD_INT 102
66880: PUSH
66881: LD_INT 103
66883: PUSH
66884: LD_INT 104
66886: PUSH
66887: LD_INT 105
66889: PUSH
66890: LD_INT 106
66892: PUSH
66893: LD_INT 107
66895: PUSH
66896: LD_INT 108
66898: PUSH
66899: LD_INT 109
66901: PUSH
66902: LD_INT 110
66904: PUSH
66905: LD_INT 111
66907: PUSH
66908: LD_INT 112
66910: PUSH
66911: LD_INT 113
66913: PUSH
66914: LD_INT 114
66916: PUSH
66917: EMPTY
66918: LIST
66919: LIST
66920: LIST
66921: LIST
66922: LIST
66923: LIST
66924: LIST
66925: LIST
66926: LIST
66927: LIST
66928: LIST
66929: LIST
66930: LIST
66931: LIST
66932: PUSH
66933: EMPTY
66934: LIST
66935: LIST
66936: ST_TO_ADDR
66937: GO 67312
66939: LD_INT 18
66941: DOUBLE
66942: EQUAL
66943: IFTRUE 66947
66945: GO 67083
66947: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 ] ] ; 19 :
66948: LD_ADDR_VAR 0 1
66952: PUSH
66953: LD_INT 2
66955: PUSH
66956: LD_INT 4
66958: PUSH
66959: LD_INT 5
66961: PUSH
66962: LD_INT 7
66964: PUSH
66965: LD_INT 11
66967: PUSH
66968: LD_INT 12
66970: PUSH
66971: LD_INT 15
66973: PUSH
66974: LD_INT 16
66976: PUSH
66977: LD_INT 20
66979: PUSH
66980: LD_INT 21
66982: PUSH
66983: LD_INT 22
66985: PUSH
66986: LD_INT 23
66988: PUSH
66989: LD_INT 25
66991: PUSH
66992: LD_INT 26
66994: PUSH
66995: LD_INT 30
66997: PUSH
66998: LD_INT 31
67000: PUSH
67001: LD_INT 32
67003: PUSH
67004: LD_INT 33
67006: PUSH
67007: LD_INT 34
67009: PUSH
67010: LD_INT 35
67012: PUSH
67013: LD_INT 36
67015: PUSH
67016: EMPTY
67017: LIST
67018: LIST
67019: LIST
67020: LIST
67021: LIST
67022: LIST
67023: LIST
67024: LIST
67025: LIST
67026: LIST
67027: LIST
67028: LIST
67029: LIST
67030: LIST
67031: LIST
67032: LIST
67033: LIST
67034: LIST
67035: LIST
67036: LIST
67037: LIST
67038: PUSH
67039: LD_INT 101
67041: PUSH
67042: LD_INT 102
67044: PUSH
67045: LD_INT 103
67047: PUSH
67048: LD_INT 106
67050: PUSH
67051: LD_INT 108
67053: PUSH
67054: LD_INT 112
67056: PUSH
67057: LD_INT 113
67059: PUSH
67060: LD_INT 114
67062: PUSH
67063: LD_INT 115
67065: PUSH
67066: EMPTY
67067: LIST
67068: LIST
67069: LIST
67070: LIST
67071: LIST
67072: LIST
67073: LIST
67074: LIST
67075: LIST
67076: PUSH
67077: EMPTY
67078: LIST
67079: LIST
67080: ST_TO_ADDR
67081: GO 67312
67083: LD_INT 19
67085: DOUBLE
67086: EQUAL
67087: IFTRUE 67091
67089: GO 67311
67091: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ; end ;
67092: LD_ADDR_VAR 0 1
67096: PUSH
67097: LD_INT 1
67099: PUSH
67100: LD_INT 2
67102: PUSH
67103: LD_INT 3
67105: PUSH
67106: LD_INT 4
67108: PUSH
67109: LD_INT 5
67111: PUSH
67112: LD_INT 6
67114: PUSH
67115: LD_INT 7
67117: PUSH
67118: LD_INT 8
67120: PUSH
67121: LD_INT 9
67123: PUSH
67124: LD_INT 10
67126: PUSH
67127: LD_INT 11
67129: PUSH
67130: LD_INT 12
67132: PUSH
67133: LD_INT 13
67135: PUSH
67136: LD_INT 14
67138: PUSH
67139: LD_INT 15
67141: PUSH
67142: LD_INT 16
67144: PUSH
67145: LD_INT 17
67147: PUSH
67148: LD_INT 18
67150: PUSH
67151: LD_INT 19
67153: PUSH
67154: LD_INT 20
67156: PUSH
67157: LD_INT 21
67159: PUSH
67160: LD_INT 22
67162: PUSH
67163: LD_INT 23
67165: PUSH
67166: LD_INT 24
67168: PUSH
67169: LD_INT 25
67171: PUSH
67172: LD_INT 26
67174: PUSH
67175: LD_INT 27
67177: PUSH
67178: LD_INT 28
67180: PUSH
67181: LD_INT 29
67183: PUSH
67184: LD_INT 30
67186: PUSH
67187: LD_INT 31
67189: PUSH
67190: LD_INT 32
67192: PUSH
67193: LD_INT 33
67195: PUSH
67196: LD_INT 34
67198: PUSH
67199: LD_INT 35
67201: PUSH
67202: LD_INT 36
67204: PUSH
67205: EMPTY
67206: LIST
67207: LIST
67208: LIST
67209: LIST
67210: LIST
67211: LIST
67212: LIST
67213: LIST
67214: LIST
67215: LIST
67216: LIST
67217: LIST
67218: LIST
67219: LIST
67220: LIST
67221: LIST
67222: LIST
67223: LIST
67224: LIST
67225: LIST
67226: LIST
67227: LIST
67228: LIST
67229: LIST
67230: LIST
67231: LIST
67232: LIST
67233: LIST
67234: LIST
67235: LIST
67236: LIST
67237: LIST
67238: LIST
67239: LIST
67240: LIST
67241: LIST
67242: PUSH
67243: LD_INT 101
67245: PUSH
67246: LD_INT 102
67248: PUSH
67249: LD_INT 103
67251: PUSH
67252: LD_INT 104
67254: PUSH
67255: LD_INT 105
67257: PUSH
67258: LD_INT 106
67260: PUSH
67261: LD_INT 107
67263: PUSH
67264: LD_INT 108
67266: PUSH
67267: LD_INT 109
67269: PUSH
67270: LD_INT 110
67272: PUSH
67273: LD_INT 111
67275: PUSH
67276: LD_INT 112
67278: PUSH
67279: LD_INT 113
67281: PUSH
67282: LD_INT 114
67284: PUSH
67285: LD_INT 115
67287: PUSH
67288: EMPTY
67289: LIST
67290: LIST
67291: LIST
67292: LIST
67293: LIST
67294: LIST
67295: LIST
67296: LIST
67297: LIST
67298: LIST
67299: LIST
67300: LIST
67301: LIST
67302: LIST
67303: LIST
67304: PUSH
67305: EMPTY
67306: LIST
67307: LIST
67308: ST_TO_ADDR
67309: GO 67312
67311: POP
// end else
67312: GO 67531
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ;
67314: LD_ADDR_VAR 0 1
67318: PUSH
67319: LD_INT 1
67321: PUSH
67322: LD_INT 2
67324: PUSH
67325: LD_INT 3
67327: PUSH
67328: LD_INT 4
67330: PUSH
67331: LD_INT 5
67333: PUSH
67334: LD_INT 6
67336: PUSH
67337: LD_INT 7
67339: PUSH
67340: LD_INT 8
67342: PUSH
67343: LD_INT 9
67345: PUSH
67346: LD_INT 10
67348: PUSH
67349: LD_INT 11
67351: PUSH
67352: LD_INT 12
67354: PUSH
67355: LD_INT 13
67357: PUSH
67358: LD_INT 14
67360: PUSH
67361: LD_INT 15
67363: PUSH
67364: LD_INT 16
67366: PUSH
67367: LD_INT 17
67369: PUSH
67370: LD_INT 18
67372: PUSH
67373: LD_INT 19
67375: PUSH
67376: LD_INT 20
67378: PUSH
67379: LD_INT 21
67381: PUSH
67382: LD_INT 22
67384: PUSH
67385: LD_INT 23
67387: PUSH
67388: LD_INT 24
67390: PUSH
67391: LD_INT 25
67393: PUSH
67394: LD_INT 26
67396: PUSH
67397: LD_INT 27
67399: PUSH
67400: LD_INT 28
67402: PUSH
67403: LD_INT 29
67405: PUSH
67406: LD_INT 30
67408: PUSH
67409: LD_INT 31
67411: PUSH
67412: LD_INT 32
67414: PUSH
67415: LD_INT 33
67417: PUSH
67418: LD_INT 34
67420: PUSH
67421: LD_INT 35
67423: PUSH
67424: LD_INT 36
67426: PUSH
67427: EMPTY
67428: LIST
67429: LIST
67430: LIST
67431: LIST
67432: LIST
67433: LIST
67434: LIST
67435: LIST
67436: LIST
67437: LIST
67438: LIST
67439: LIST
67440: LIST
67441: LIST
67442: LIST
67443: LIST
67444: LIST
67445: LIST
67446: LIST
67447: LIST
67448: LIST
67449: LIST
67450: LIST
67451: LIST
67452: LIST
67453: LIST
67454: LIST
67455: LIST
67456: LIST
67457: LIST
67458: LIST
67459: LIST
67460: LIST
67461: LIST
67462: LIST
67463: LIST
67464: PUSH
67465: LD_INT 101
67467: PUSH
67468: LD_INT 102
67470: PUSH
67471: LD_INT 103
67473: PUSH
67474: LD_INT 104
67476: PUSH
67477: LD_INT 105
67479: PUSH
67480: LD_INT 106
67482: PUSH
67483: LD_INT 107
67485: PUSH
67486: LD_INT 108
67488: PUSH
67489: LD_INT 109
67491: PUSH
67492: LD_INT 110
67494: PUSH
67495: LD_INT 111
67497: PUSH
67498: LD_INT 112
67500: PUSH
67501: LD_INT 113
67503: PUSH
67504: LD_INT 114
67506: PUSH
67507: LD_INT 115
67509: PUSH
67510: EMPTY
67511: LIST
67512: LIST
67513: LIST
67514: LIST
67515: LIST
67516: LIST
67517: LIST
67518: LIST
67519: LIST
67520: LIST
67521: LIST
67522: LIST
67523: LIST
67524: LIST
67525: LIST
67526: PUSH
67527: EMPTY
67528: LIST
67529: LIST
67530: ST_TO_ADDR
// if result then
67531: LD_VAR 0 1
67535: IFFALSE 67824
// begin normal :=  ;
67537: LD_ADDR_VAR 0 3
67541: PUSH
67542: LD_STRING 
67544: ST_TO_ADDR
// hardcore :=  ;
67545: LD_ADDR_VAR 0 4
67549: PUSH
67550: LD_STRING 
67552: ST_TO_ADDR
// for i = 1 to normalCounter do
67553: LD_ADDR_VAR 0 5
67557: PUSH
67558: DOUBLE
67559: LD_INT 1
67561: DEC
67562: ST_TO_ADDR
67563: LD_EXP 100
67567: PUSH
67568: FOR_TO
67569: IFFALSE 67670
// begin tmp := 0 ;
67571: LD_ADDR_VAR 0 2
67575: PUSH
67576: LD_STRING 0
67578: ST_TO_ADDR
// if result [ 1 ] then
67579: LD_VAR 0 1
67583: PUSH
67584: LD_INT 1
67586: ARRAY
67587: IFFALSE 67652
// if result [ 1 ] [ 1 ] = i then
67589: LD_VAR 0 1
67593: PUSH
67594: LD_INT 1
67596: ARRAY
67597: PUSH
67598: LD_INT 1
67600: ARRAY
67601: PUSH
67602: LD_VAR 0 5
67606: EQUAL
67607: IFFALSE 67652
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
67609: LD_ADDR_VAR 0 1
67613: PUSH
67614: LD_VAR 0 1
67618: PPUSH
67619: LD_INT 1
67621: PPUSH
67622: LD_VAR 0 1
67626: PUSH
67627: LD_INT 1
67629: ARRAY
67630: PPUSH
67631: LD_INT 1
67633: PPUSH
67634: CALL_OW 3
67638: PPUSH
67639: CALL_OW 1
67643: ST_TO_ADDR
// tmp := 1 ;
67644: LD_ADDR_VAR 0 2
67648: PUSH
67649: LD_STRING 1
67651: ST_TO_ADDR
// end ; normal := normal & tmp ;
67652: LD_ADDR_VAR 0 3
67656: PUSH
67657: LD_VAR 0 3
67661: PUSH
67662: LD_VAR 0 2
67666: STR
67667: ST_TO_ADDR
// end ;
67668: GO 67568
67670: POP
67671: POP
// for i = 1 to hardcoreCounter do
67672: LD_ADDR_VAR 0 5
67676: PUSH
67677: DOUBLE
67678: LD_INT 1
67680: DEC
67681: ST_TO_ADDR
67682: LD_EXP 101
67686: PUSH
67687: FOR_TO
67688: IFFALSE 67793
// begin tmp := 0 ;
67690: LD_ADDR_VAR 0 2
67694: PUSH
67695: LD_STRING 0
67697: ST_TO_ADDR
// if result [ 2 ] then
67698: LD_VAR 0 1
67702: PUSH
67703: LD_INT 2
67705: ARRAY
67706: IFFALSE 67775
// if result [ 2 ] [ 1 ] = 100 + i then
67708: LD_VAR 0 1
67712: PUSH
67713: LD_INT 2
67715: ARRAY
67716: PUSH
67717: LD_INT 1
67719: ARRAY
67720: PUSH
67721: LD_INT 100
67723: PUSH
67724: LD_VAR 0 5
67728: PLUS
67729: EQUAL
67730: IFFALSE 67775
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
67732: LD_ADDR_VAR 0 1
67736: PUSH
67737: LD_VAR 0 1
67741: PPUSH
67742: LD_INT 2
67744: PPUSH
67745: LD_VAR 0 1
67749: PUSH
67750: LD_INT 2
67752: ARRAY
67753: PPUSH
67754: LD_INT 1
67756: PPUSH
67757: CALL_OW 3
67761: PPUSH
67762: CALL_OW 1
67766: ST_TO_ADDR
// tmp := 1 ;
67767: LD_ADDR_VAR 0 2
67771: PUSH
67772: LD_STRING 1
67774: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
67775: LD_ADDR_VAR 0 4
67779: PUSH
67780: LD_VAR 0 4
67784: PUSH
67785: LD_VAR 0 2
67789: STR
67790: ST_TO_ADDR
// end ;
67791: GO 67687
67793: POP
67794: POP
// ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & ") ) ;
67795: LD_STRING getStreamItemsFromMission("
67797: PUSH
67798: LD_VAR 0 3
67802: STR
67803: PUSH
67804: LD_STRING ","
67806: STR
67807: PUSH
67808: LD_VAR 0 4
67812: STR
67813: PUSH
67814: LD_STRING ")
67816: STR
67817: PPUSH
67818: CALL_OW 559
// end else
67822: GO 67831
// ToLua ( getStreamItemsFromMission("","") ) ;
67824: LD_STRING getStreamItemsFromMission("","")
67826: PPUSH
67827: CALL_OW 559
// end ;
67831: LD_VAR 0 1
67835: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
67836: LD_EXP 99
67840: PUSH
67841: LD_EXP 104
67845: AND
67846: IFFALSE 67970
67848: GO 67850
67850: DISABLE
67851: LD_INT 0
67853: PPUSH
67854: PPUSH
// begin enable ;
67855: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
67856: LD_ADDR_VAR 0 2
67860: PUSH
67861: LD_INT 22
67863: PUSH
67864: LD_OWVAR 2
67868: PUSH
67869: EMPTY
67870: LIST
67871: LIST
67872: PUSH
67873: LD_INT 2
67875: PUSH
67876: LD_INT 34
67878: PUSH
67879: LD_INT 7
67881: PUSH
67882: EMPTY
67883: LIST
67884: LIST
67885: PUSH
67886: LD_INT 34
67888: PUSH
67889: LD_INT 45
67891: PUSH
67892: EMPTY
67893: LIST
67894: LIST
67895: PUSH
67896: LD_INT 34
67898: PUSH
67899: LD_INT 28
67901: PUSH
67902: EMPTY
67903: LIST
67904: LIST
67905: PUSH
67906: LD_INT 34
67908: PUSH
67909: LD_INT 47
67911: PUSH
67912: EMPTY
67913: LIST
67914: LIST
67915: PUSH
67916: EMPTY
67917: LIST
67918: LIST
67919: LIST
67920: LIST
67921: LIST
67922: PUSH
67923: EMPTY
67924: LIST
67925: LIST
67926: PPUSH
67927: CALL_OW 69
67931: ST_TO_ADDR
// if not tmp then
67932: LD_VAR 0 2
67936: NOT
67937: IFFALSE 67941
// exit ;
67939: GO 67970
// for i in tmp do
67941: LD_ADDR_VAR 0 1
67945: PUSH
67946: LD_VAR 0 2
67950: PUSH
67951: FOR_IN
67952: IFFALSE 67968
// begin SetLives ( i , 0 ) ;
67954: LD_VAR 0 1
67958: PPUSH
67959: LD_INT 0
67961: PPUSH
67962: CALL_OW 234
// end ;
67966: GO 67951
67968: POP
67969: POP
// end ;
67970: PPOPN 2
67972: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
67973: LD_EXP 99
67977: PUSH
67978: LD_EXP 105
67982: AND
67983: IFFALSE 68067
67985: GO 67987
67987: DISABLE
67988: LD_INT 0
67990: PPUSH
67991: PPUSH
// begin enable ;
67992: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
67993: LD_ADDR_VAR 0 2
67997: PUSH
67998: LD_INT 22
68000: PUSH
68001: LD_OWVAR 2
68005: PUSH
68006: EMPTY
68007: LIST
68008: LIST
68009: PUSH
68010: LD_INT 32
68012: PUSH
68013: LD_INT 3
68015: PUSH
68016: EMPTY
68017: LIST
68018: LIST
68019: PUSH
68020: EMPTY
68021: LIST
68022: LIST
68023: PPUSH
68024: CALL_OW 69
68028: ST_TO_ADDR
// if not tmp then
68029: LD_VAR 0 2
68033: NOT
68034: IFFALSE 68038
// exit ;
68036: GO 68067
// for i in tmp do
68038: LD_ADDR_VAR 0 1
68042: PUSH
68043: LD_VAR 0 2
68047: PUSH
68048: FOR_IN
68049: IFFALSE 68065
// begin SetLives ( i , 0 ) ;
68051: LD_VAR 0 1
68055: PPUSH
68056: LD_INT 0
68058: PPUSH
68059: CALL_OW 234
// end ;
68063: GO 68048
68065: POP
68066: POP
// end ;
68067: PPOPN 2
68069: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
68070: LD_EXP 99
68074: PUSH
68075: LD_EXP 102
68079: AND
68080: IFFALSE 68173
68082: GO 68084
68084: DISABLE
68085: LD_INT 0
68087: PPUSH
// begin enable ;
68088: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
68089: LD_ADDR_VAR 0 1
68093: PUSH
68094: LD_INT 22
68096: PUSH
68097: LD_OWVAR 2
68101: PUSH
68102: EMPTY
68103: LIST
68104: LIST
68105: PUSH
68106: LD_INT 2
68108: PUSH
68109: LD_INT 25
68111: PUSH
68112: LD_INT 5
68114: PUSH
68115: EMPTY
68116: LIST
68117: LIST
68118: PUSH
68119: LD_INT 25
68121: PUSH
68122: LD_INT 9
68124: PUSH
68125: EMPTY
68126: LIST
68127: LIST
68128: PUSH
68129: LD_INT 25
68131: PUSH
68132: LD_INT 8
68134: PUSH
68135: EMPTY
68136: LIST
68137: LIST
68138: PUSH
68139: EMPTY
68140: LIST
68141: LIST
68142: LIST
68143: LIST
68144: PUSH
68145: EMPTY
68146: LIST
68147: LIST
68148: PPUSH
68149: CALL_OW 69
68153: PUSH
68154: FOR_IN
68155: IFFALSE 68171
// begin SetClass ( i , 1 ) ;
68157: LD_VAR 0 1
68161: PPUSH
68162: LD_INT 1
68164: PPUSH
68165: CALL_OW 336
// end ;
68169: GO 68154
68171: POP
68172: POP
// end ;
68173: PPOPN 1
68175: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
68176: LD_EXP 99
68180: PUSH
68181: LD_EXP 103
68185: AND
68186: PUSH
68187: LD_OWVAR 65
68191: PUSH
68192: LD_INT 7
68194: LESS
68195: AND
68196: IFFALSE 68210
68198: GO 68200
68200: DISABLE
// begin enable ;
68201: ENABLE
// game_speed := 7 ;
68202: LD_ADDR_OWVAR 65
68206: PUSH
68207: LD_INT 7
68209: ST_TO_ADDR
// end ;
68210: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
68211: LD_EXP 99
68215: PUSH
68216: LD_EXP 106
68220: AND
68221: IFFALSE 68423
68223: GO 68225
68225: DISABLE
68226: LD_INT 0
68228: PPUSH
68229: PPUSH
68230: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
68231: LD_ADDR_VAR 0 3
68235: PUSH
68236: LD_INT 81
68238: PUSH
68239: LD_OWVAR 2
68243: PUSH
68244: EMPTY
68245: LIST
68246: LIST
68247: PUSH
68248: LD_INT 21
68250: PUSH
68251: LD_INT 1
68253: PUSH
68254: EMPTY
68255: LIST
68256: LIST
68257: PUSH
68258: EMPTY
68259: LIST
68260: LIST
68261: PPUSH
68262: CALL_OW 69
68266: ST_TO_ADDR
// if not tmp then
68267: LD_VAR 0 3
68271: NOT
68272: IFFALSE 68276
// exit ;
68274: GO 68423
// if tmp > 5 then
68276: LD_VAR 0 3
68280: PUSH
68281: LD_INT 5
68283: GREATER
68284: IFFALSE 68296
// k := 5 else
68286: LD_ADDR_VAR 0 2
68290: PUSH
68291: LD_INT 5
68293: ST_TO_ADDR
68294: GO 68306
// k := tmp ;
68296: LD_ADDR_VAR 0 2
68300: PUSH
68301: LD_VAR 0 3
68305: ST_TO_ADDR
// for i := 1 to k do
68306: LD_ADDR_VAR 0 1
68310: PUSH
68311: DOUBLE
68312: LD_INT 1
68314: DEC
68315: ST_TO_ADDR
68316: LD_VAR 0 2
68320: PUSH
68321: FOR_TO
68322: IFFALSE 68421
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
68324: LD_VAR 0 3
68328: PUSH
68329: LD_VAR 0 1
68333: ARRAY
68334: PPUSH
68335: LD_VAR 0 1
68339: PUSH
68340: LD_INT 4
68342: MOD
68343: PUSH
68344: LD_INT 1
68346: PLUS
68347: PPUSH
68348: CALL_OW 259
68352: PUSH
68353: LD_INT 10
68355: LESS
68356: IFFALSE 68419
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
68358: LD_VAR 0 3
68362: PUSH
68363: LD_VAR 0 1
68367: ARRAY
68368: PPUSH
68369: LD_VAR 0 1
68373: PUSH
68374: LD_INT 4
68376: MOD
68377: PUSH
68378: LD_INT 1
68380: PLUS
68381: PPUSH
68382: LD_VAR 0 3
68386: PUSH
68387: LD_VAR 0 1
68391: ARRAY
68392: PPUSH
68393: LD_VAR 0 1
68397: PUSH
68398: LD_INT 4
68400: MOD
68401: PUSH
68402: LD_INT 1
68404: PLUS
68405: PPUSH
68406: CALL_OW 259
68410: PUSH
68411: LD_INT 1
68413: PLUS
68414: PPUSH
68415: CALL_OW 237
68419: GO 68321
68421: POP
68422: POP
// end ;
68423: PPOPN 3
68425: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
68426: LD_EXP 99
68430: PUSH
68431: LD_EXP 107
68435: AND
68436: IFFALSE 68456
68438: GO 68440
68440: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
68441: LD_INT 4
68443: PPUSH
68444: LD_OWVAR 2
68448: PPUSH
68449: LD_INT 0
68451: PPUSH
68452: CALL_OW 324
68456: END
// every 0 0$1 trigger StreamModeActive and sShovel do
68457: LD_EXP 99
68461: PUSH
68462: LD_EXP 136
68466: AND
68467: IFFALSE 68487
68469: GO 68471
68471: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
68472: LD_INT 19
68474: PPUSH
68475: LD_OWVAR 2
68479: PPUSH
68480: LD_INT 0
68482: PPUSH
68483: CALL_OW 324
68487: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
68488: LD_EXP 99
68492: PUSH
68493: LD_EXP 108
68497: AND
68498: IFFALSE 68600
68500: GO 68502
68502: DISABLE
68503: LD_INT 0
68505: PPUSH
68506: PPUSH
// begin enable ;
68507: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
68508: LD_ADDR_VAR 0 2
68512: PUSH
68513: LD_INT 22
68515: PUSH
68516: LD_OWVAR 2
68520: PUSH
68521: EMPTY
68522: LIST
68523: LIST
68524: PUSH
68525: LD_INT 2
68527: PUSH
68528: LD_INT 34
68530: PUSH
68531: LD_INT 11
68533: PUSH
68534: EMPTY
68535: LIST
68536: LIST
68537: PUSH
68538: LD_INT 34
68540: PUSH
68541: LD_INT 30
68543: PUSH
68544: EMPTY
68545: LIST
68546: LIST
68547: PUSH
68548: EMPTY
68549: LIST
68550: LIST
68551: LIST
68552: PUSH
68553: EMPTY
68554: LIST
68555: LIST
68556: PPUSH
68557: CALL_OW 69
68561: ST_TO_ADDR
// if not tmp then
68562: LD_VAR 0 2
68566: NOT
68567: IFFALSE 68571
// exit ;
68569: GO 68600
// for i in tmp do
68571: LD_ADDR_VAR 0 1
68575: PUSH
68576: LD_VAR 0 2
68580: PUSH
68581: FOR_IN
68582: IFFALSE 68598
// begin SetLives ( i , 0 ) ;
68584: LD_VAR 0 1
68588: PPUSH
68589: LD_INT 0
68591: PPUSH
68592: CALL_OW 234
// end ;
68596: GO 68581
68598: POP
68599: POP
// end ;
68600: PPOPN 2
68602: END
// every 0 0$1 trigger StreamModeActive and sBunker do
68603: LD_EXP 99
68607: PUSH
68608: LD_EXP 109
68612: AND
68613: IFFALSE 68633
68615: GO 68617
68617: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
68618: LD_INT 32
68620: PPUSH
68621: LD_OWVAR 2
68625: PPUSH
68626: LD_INT 0
68628: PPUSH
68629: CALL_OW 324
68633: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
68634: LD_EXP 99
68638: PUSH
68639: LD_EXP 110
68643: AND
68644: IFFALSE 68825
68646: GO 68648
68648: DISABLE
68649: LD_INT 0
68651: PPUSH
68652: PPUSH
68653: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
68654: LD_ADDR_VAR 0 2
68658: PUSH
68659: LD_INT 22
68661: PUSH
68662: LD_OWVAR 2
68666: PUSH
68667: EMPTY
68668: LIST
68669: LIST
68670: PUSH
68671: LD_INT 33
68673: PUSH
68674: LD_INT 3
68676: PUSH
68677: EMPTY
68678: LIST
68679: LIST
68680: PUSH
68681: EMPTY
68682: LIST
68683: LIST
68684: PPUSH
68685: CALL_OW 69
68689: ST_TO_ADDR
// if not tmp then
68690: LD_VAR 0 2
68694: NOT
68695: IFFALSE 68699
// exit ;
68697: GO 68825
// side := 0 ;
68699: LD_ADDR_VAR 0 3
68703: PUSH
68704: LD_INT 0
68706: ST_TO_ADDR
// for i := 1 to 8 do
68707: LD_ADDR_VAR 0 1
68711: PUSH
68712: DOUBLE
68713: LD_INT 1
68715: DEC
68716: ST_TO_ADDR
68717: LD_INT 8
68719: PUSH
68720: FOR_TO
68721: IFFALSE 68769
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
68723: LD_OWVAR 2
68727: PUSH
68728: LD_VAR 0 1
68732: NONEQUAL
68733: PUSH
68734: LD_OWVAR 2
68738: PPUSH
68739: LD_VAR 0 1
68743: PPUSH
68744: CALL_OW 81
68748: PUSH
68749: LD_INT 2
68751: EQUAL
68752: AND
68753: IFFALSE 68767
// begin side := i ;
68755: LD_ADDR_VAR 0 3
68759: PUSH
68760: LD_VAR 0 1
68764: ST_TO_ADDR
// break ;
68765: GO 68769
// end ;
68767: GO 68720
68769: POP
68770: POP
// if not side then
68771: LD_VAR 0 3
68775: NOT
68776: IFFALSE 68780
// exit ;
68778: GO 68825
// for i := 1 to tmp do
68780: LD_ADDR_VAR 0 1
68784: PUSH
68785: DOUBLE
68786: LD_INT 1
68788: DEC
68789: ST_TO_ADDR
68790: LD_VAR 0 2
68794: PUSH
68795: FOR_TO
68796: IFFALSE 68823
// if Prob ( 60 ) then
68798: LD_INT 60
68800: PPUSH
68801: CALL_OW 13
68805: IFFALSE 68821
// SetSide ( i , side ) ;
68807: LD_VAR 0 1
68811: PPUSH
68812: LD_VAR 0 3
68816: PPUSH
68817: CALL_OW 235
68821: GO 68795
68823: POP
68824: POP
// end ;
68825: PPOPN 3
68827: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
68828: LD_EXP 99
68832: PUSH
68833: LD_EXP 112
68837: AND
68838: IFFALSE 68957
68840: GO 68842
68842: DISABLE
68843: LD_INT 0
68845: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
68846: LD_ADDR_VAR 0 1
68850: PUSH
68851: LD_INT 22
68853: PUSH
68854: LD_OWVAR 2
68858: PUSH
68859: EMPTY
68860: LIST
68861: LIST
68862: PUSH
68863: LD_INT 21
68865: PUSH
68866: LD_INT 1
68868: PUSH
68869: EMPTY
68870: LIST
68871: LIST
68872: PUSH
68873: LD_INT 3
68875: PUSH
68876: LD_INT 23
68878: PUSH
68879: LD_INT 0
68881: PUSH
68882: EMPTY
68883: LIST
68884: LIST
68885: PUSH
68886: EMPTY
68887: LIST
68888: LIST
68889: PUSH
68890: EMPTY
68891: LIST
68892: LIST
68893: LIST
68894: PPUSH
68895: CALL_OW 69
68899: PUSH
68900: FOR_IN
68901: IFFALSE 68955
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
68903: LD_VAR 0 1
68907: PPUSH
68908: CALL_OW 257
68912: PUSH
68913: LD_INT 1
68915: PUSH
68916: LD_INT 2
68918: PUSH
68919: LD_INT 3
68921: PUSH
68922: LD_INT 4
68924: PUSH
68925: EMPTY
68926: LIST
68927: LIST
68928: LIST
68929: LIST
68930: IN
68931: IFFALSE 68953
// SetClass ( un , rand ( 1 , 4 ) ) ;
68933: LD_VAR 0 1
68937: PPUSH
68938: LD_INT 1
68940: PPUSH
68941: LD_INT 4
68943: PPUSH
68944: CALL_OW 12
68948: PPUSH
68949: CALL_OW 336
68953: GO 68900
68955: POP
68956: POP
// end ;
68957: PPOPN 1
68959: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
68960: LD_EXP 99
68964: PUSH
68965: LD_EXP 111
68969: AND
68970: IFFALSE 69049
68972: GO 68974
68974: DISABLE
68975: LD_INT 0
68977: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
68978: LD_ADDR_VAR 0 1
68982: PUSH
68983: LD_INT 22
68985: PUSH
68986: LD_OWVAR 2
68990: PUSH
68991: EMPTY
68992: LIST
68993: LIST
68994: PUSH
68995: LD_INT 21
68997: PUSH
68998: LD_INT 3
69000: PUSH
69001: EMPTY
69002: LIST
69003: LIST
69004: PUSH
69005: EMPTY
69006: LIST
69007: LIST
69008: PPUSH
69009: CALL_OW 69
69013: ST_TO_ADDR
// if not tmp then
69014: LD_VAR 0 1
69018: NOT
69019: IFFALSE 69023
// exit ;
69021: GO 69049
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
69023: LD_VAR 0 1
69027: PUSH
69028: LD_INT 1
69030: PPUSH
69031: LD_VAR 0 1
69035: PPUSH
69036: CALL_OW 12
69040: ARRAY
69041: PPUSH
69042: LD_INT 100
69044: PPUSH
69045: CALL_OW 234
// end ;
69049: PPOPN 1
69051: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
69052: LD_EXP 99
69056: PUSH
69057: LD_EXP 113
69061: AND
69062: IFFALSE 69160
69064: GO 69066
69066: DISABLE
69067: LD_INT 0
69069: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
69070: LD_ADDR_VAR 0 1
69074: PUSH
69075: LD_INT 22
69077: PUSH
69078: LD_OWVAR 2
69082: PUSH
69083: EMPTY
69084: LIST
69085: LIST
69086: PUSH
69087: LD_INT 21
69089: PUSH
69090: LD_INT 1
69092: PUSH
69093: EMPTY
69094: LIST
69095: LIST
69096: PUSH
69097: EMPTY
69098: LIST
69099: LIST
69100: PPUSH
69101: CALL_OW 69
69105: ST_TO_ADDR
// if not tmp then
69106: LD_VAR 0 1
69110: NOT
69111: IFFALSE 69115
// exit ;
69113: GO 69160
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
69115: LD_VAR 0 1
69119: PUSH
69120: LD_INT 1
69122: PPUSH
69123: LD_VAR 0 1
69127: PPUSH
69128: CALL_OW 12
69132: ARRAY
69133: PPUSH
69134: LD_INT 1
69136: PPUSH
69137: LD_INT 4
69139: PPUSH
69140: CALL_OW 12
69144: PPUSH
69145: LD_INT 3000
69147: PPUSH
69148: LD_INT 9000
69150: PPUSH
69151: CALL_OW 12
69155: PPUSH
69156: CALL_OW 492
// end ;
69160: PPOPN 1
69162: END
// every 0 0$1 trigger StreamModeActive and sDepot do
69163: LD_EXP 99
69167: PUSH
69168: LD_EXP 114
69172: AND
69173: IFFALSE 69193
69175: GO 69177
69177: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
69178: LD_INT 1
69180: PPUSH
69181: LD_OWVAR 2
69185: PPUSH
69186: LD_INT 0
69188: PPUSH
69189: CALL_OW 324
69193: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
69194: LD_EXP 99
69198: PUSH
69199: LD_EXP 115
69203: AND
69204: IFFALSE 69287
69206: GO 69208
69208: DISABLE
69209: LD_INT 0
69211: PPUSH
69212: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
69213: LD_ADDR_VAR 0 2
69217: PUSH
69218: LD_INT 22
69220: PUSH
69221: LD_OWVAR 2
69225: PUSH
69226: EMPTY
69227: LIST
69228: LIST
69229: PUSH
69230: LD_INT 21
69232: PUSH
69233: LD_INT 3
69235: PUSH
69236: EMPTY
69237: LIST
69238: LIST
69239: PUSH
69240: EMPTY
69241: LIST
69242: LIST
69243: PPUSH
69244: CALL_OW 69
69248: ST_TO_ADDR
// if not tmp then
69249: LD_VAR 0 2
69253: NOT
69254: IFFALSE 69258
// exit ;
69256: GO 69287
// for i in tmp do
69258: LD_ADDR_VAR 0 1
69262: PUSH
69263: LD_VAR 0 2
69267: PUSH
69268: FOR_IN
69269: IFFALSE 69285
// SetBLevel ( i , 10 ) ;
69271: LD_VAR 0 1
69275: PPUSH
69276: LD_INT 10
69278: PPUSH
69279: CALL_OW 241
69283: GO 69268
69285: POP
69286: POP
// end ;
69287: PPOPN 2
69289: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
69290: LD_EXP 99
69294: PUSH
69295: LD_EXP 116
69299: AND
69300: IFFALSE 69411
69302: GO 69304
69304: DISABLE
69305: LD_INT 0
69307: PPUSH
69308: PPUSH
69309: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
69310: LD_ADDR_VAR 0 3
69314: PUSH
69315: LD_INT 22
69317: PUSH
69318: LD_OWVAR 2
69322: PUSH
69323: EMPTY
69324: LIST
69325: LIST
69326: PUSH
69327: LD_INT 25
69329: PUSH
69330: LD_INT 1
69332: PUSH
69333: EMPTY
69334: LIST
69335: LIST
69336: PUSH
69337: EMPTY
69338: LIST
69339: LIST
69340: PPUSH
69341: CALL_OW 69
69345: ST_TO_ADDR
// if not tmp then
69346: LD_VAR 0 3
69350: NOT
69351: IFFALSE 69355
// exit ;
69353: GO 69411
// un := tmp [ rand ( 1 , tmp ) ] ;
69355: LD_ADDR_VAR 0 2
69359: PUSH
69360: LD_VAR 0 3
69364: PUSH
69365: LD_INT 1
69367: PPUSH
69368: LD_VAR 0 3
69372: PPUSH
69373: CALL_OW 12
69377: ARRAY
69378: ST_TO_ADDR
// if Crawls ( un ) then
69379: LD_VAR 0 2
69383: PPUSH
69384: CALL_OW 318
69388: IFFALSE 69399
// ComWalk ( un ) ;
69390: LD_VAR 0 2
69394: PPUSH
69395: CALL_OW 138
// SetClass ( un , class_sniper ) ;
69399: LD_VAR 0 2
69403: PPUSH
69404: LD_INT 5
69406: PPUSH
69407: CALL_OW 336
// end ;
69411: PPOPN 3
69413: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
69414: LD_EXP 99
69418: PUSH
69419: LD_EXP 117
69423: AND
69424: PUSH
69425: LD_OWVAR 67
69429: PUSH
69430: LD_INT 3
69432: LESS
69433: AND
69434: IFFALSE 69453
69436: GO 69438
69438: DISABLE
// Difficulty := Difficulty + 1 ;
69439: LD_ADDR_OWVAR 67
69443: PUSH
69444: LD_OWVAR 67
69448: PUSH
69449: LD_INT 1
69451: PLUS
69452: ST_TO_ADDR
69453: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
69454: LD_EXP 99
69458: PUSH
69459: LD_EXP 118
69463: AND
69464: IFFALSE 69567
69466: GO 69468
69468: DISABLE
69469: LD_INT 0
69471: PPUSH
// begin for i := 1 to 5 do
69472: LD_ADDR_VAR 0 1
69476: PUSH
69477: DOUBLE
69478: LD_INT 1
69480: DEC
69481: ST_TO_ADDR
69482: LD_INT 5
69484: PUSH
69485: FOR_TO
69486: IFFALSE 69565
// begin uc_nation := nation_nature ;
69488: LD_ADDR_OWVAR 21
69492: PUSH
69493: LD_INT 0
69495: ST_TO_ADDR
// uc_side := 0 ;
69496: LD_ADDR_OWVAR 20
69500: PUSH
69501: LD_INT 0
69503: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
69504: LD_ADDR_OWVAR 29
69508: PUSH
69509: LD_INT 12
69511: PUSH
69512: LD_INT 12
69514: PUSH
69515: EMPTY
69516: LIST
69517: LIST
69518: ST_TO_ADDR
// hc_agressivity := 20 ;
69519: LD_ADDR_OWVAR 35
69523: PUSH
69524: LD_INT 20
69526: ST_TO_ADDR
// hc_class := class_tiger ;
69527: LD_ADDR_OWVAR 28
69531: PUSH
69532: LD_INT 14
69534: ST_TO_ADDR
// hc_gallery :=  ;
69535: LD_ADDR_OWVAR 33
69539: PUSH
69540: LD_STRING 
69542: ST_TO_ADDR
// hc_name :=  ;
69543: LD_ADDR_OWVAR 26
69547: PUSH
69548: LD_STRING 
69550: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
69551: CALL_OW 44
69555: PPUSH
69556: LD_INT 0
69558: PPUSH
69559: CALL_OW 51
// end ;
69563: GO 69485
69565: POP
69566: POP
// end ;
69567: PPOPN 1
69569: END
// every 0 0$1 trigger StreamModeActive and sBomb do
69570: LD_EXP 99
69574: PUSH
69575: LD_EXP 119
69579: AND
69580: IFFALSE 69589
69582: GO 69584
69584: DISABLE
// StreamSibBomb ;
69585: CALL 69590 0 0
69589: END
// export function StreamSibBomb ; var i , x , y ; begin
69590: LD_INT 0
69592: PPUSH
69593: PPUSH
69594: PPUSH
69595: PPUSH
// result := false ;
69596: LD_ADDR_VAR 0 1
69600: PUSH
69601: LD_INT 0
69603: ST_TO_ADDR
// for i := 1 to 16 do
69604: LD_ADDR_VAR 0 2
69608: PUSH
69609: DOUBLE
69610: LD_INT 1
69612: DEC
69613: ST_TO_ADDR
69614: LD_INT 16
69616: PUSH
69617: FOR_TO
69618: IFFALSE 69817
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
69620: LD_ADDR_VAR 0 3
69624: PUSH
69625: LD_INT 10
69627: PUSH
69628: LD_INT 20
69630: PUSH
69631: LD_INT 30
69633: PUSH
69634: LD_INT 40
69636: PUSH
69637: LD_INT 50
69639: PUSH
69640: LD_INT 60
69642: PUSH
69643: LD_INT 70
69645: PUSH
69646: LD_INT 80
69648: PUSH
69649: LD_INT 90
69651: PUSH
69652: LD_INT 100
69654: PUSH
69655: LD_INT 110
69657: PUSH
69658: LD_INT 120
69660: PUSH
69661: LD_INT 130
69663: PUSH
69664: LD_INT 140
69666: PUSH
69667: LD_INT 150
69669: PUSH
69670: EMPTY
69671: LIST
69672: LIST
69673: LIST
69674: LIST
69675: LIST
69676: LIST
69677: LIST
69678: LIST
69679: LIST
69680: LIST
69681: LIST
69682: LIST
69683: LIST
69684: LIST
69685: LIST
69686: PUSH
69687: LD_INT 1
69689: PPUSH
69690: LD_INT 15
69692: PPUSH
69693: CALL_OW 12
69697: ARRAY
69698: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
69699: LD_ADDR_VAR 0 4
69703: PUSH
69704: LD_INT 10
69706: PUSH
69707: LD_INT 20
69709: PUSH
69710: LD_INT 30
69712: PUSH
69713: LD_INT 40
69715: PUSH
69716: LD_INT 50
69718: PUSH
69719: LD_INT 60
69721: PUSH
69722: LD_INT 70
69724: PUSH
69725: LD_INT 80
69727: PUSH
69728: LD_INT 90
69730: PUSH
69731: LD_INT 100
69733: PUSH
69734: LD_INT 110
69736: PUSH
69737: LD_INT 120
69739: PUSH
69740: LD_INT 130
69742: PUSH
69743: LD_INT 140
69745: PUSH
69746: LD_INT 150
69748: PUSH
69749: EMPTY
69750: LIST
69751: LIST
69752: LIST
69753: LIST
69754: LIST
69755: LIST
69756: LIST
69757: LIST
69758: LIST
69759: LIST
69760: LIST
69761: LIST
69762: LIST
69763: LIST
69764: LIST
69765: PUSH
69766: LD_INT 1
69768: PPUSH
69769: LD_INT 15
69771: PPUSH
69772: CALL_OW 12
69776: ARRAY
69777: ST_TO_ADDR
// if ValidHex ( x , y ) then
69778: LD_VAR 0 3
69782: PPUSH
69783: LD_VAR 0 4
69787: PPUSH
69788: CALL_OW 488
69792: IFFALSE 69815
// begin result := [ x , y ] ;
69794: LD_ADDR_VAR 0 1
69798: PUSH
69799: LD_VAR 0 3
69803: PUSH
69804: LD_VAR 0 4
69808: PUSH
69809: EMPTY
69810: LIST
69811: LIST
69812: ST_TO_ADDR
// break ;
69813: GO 69817
// end ; end ;
69815: GO 69617
69817: POP
69818: POP
// if result then
69819: LD_VAR 0 1
69823: IFFALSE 69883
// begin ToLua ( playSibBomb() ) ;
69825: LD_STRING playSibBomb()
69827: PPUSH
69828: CALL_OW 559
// wait ( 0 0$14 ) ;
69832: LD_INT 490
69834: PPUSH
69835: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
69839: LD_VAR 0 1
69843: PUSH
69844: LD_INT 1
69846: ARRAY
69847: PPUSH
69848: LD_VAR 0 1
69852: PUSH
69853: LD_INT 2
69855: ARRAY
69856: PPUSH
69857: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
69861: LD_VAR 0 1
69865: PUSH
69866: LD_INT 1
69868: ARRAY
69869: PPUSH
69870: LD_VAR 0 1
69874: PUSH
69875: LD_INT 2
69877: ARRAY
69878: PPUSH
69879: CALL_OW 429
// end ; end ;
69883: LD_VAR 0 1
69887: RET
// every 0 0$1 trigger StreamModeActive and sReset do
69888: LD_EXP 99
69892: PUSH
69893: LD_EXP 121
69897: AND
69898: IFFALSE 69910
69900: GO 69902
69902: DISABLE
// YouLost (  ) ;
69903: LD_STRING 
69905: PPUSH
69906: CALL_OW 104
69910: END
// every 0 0$1 trigger StreamModeActive and sFog do
69911: LD_EXP 99
69915: PUSH
69916: LD_EXP 120
69920: AND
69921: IFFALSE 69935
69923: GO 69925
69925: DISABLE
// FogOff ( your_side ) ;
69926: LD_OWVAR 2
69930: PPUSH
69931: CALL_OW 344
69935: END
// every 0 0$1 trigger StreamModeActive and sSun do
69936: LD_EXP 99
69940: PUSH
69941: LD_EXP 122
69945: AND
69946: IFFALSE 69974
69948: GO 69950
69950: DISABLE
// begin solar_recharge_percent := 0 ;
69951: LD_ADDR_OWVAR 79
69955: PUSH
69956: LD_INT 0
69958: ST_TO_ADDR
// wait ( 5 5$00 ) ;
69959: LD_INT 10500
69961: PPUSH
69962: CALL_OW 67
// solar_recharge_percent := 100 ;
69966: LD_ADDR_OWVAR 79
69970: PUSH
69971: LD_INT 100
69973: ST_TO_ADDR
// end ;
69974: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
69975: LD_EXP 99
69979: PUSH
69980: LD_EXP 123
69984: AND
69985: IFFALSE 70224
69987: GO 69989
69989: DISABLE
69990: LD_INT 0
69992: PPUSH
69993: PPUSH
69994: PPUSH
// begin tmp := [ ] ;
69995: LD_ADDR_VAR 0 3
69999: PUSH
70000: EMPTY
70001: ST_TO_ADDR
// for i := 1 to 6 do
70002: LD_ADDR_VAR 0 1
70006: PUSH
70007: DOUBLE
70008: LD_INT 1
70010: DEC
70011: ST_TO_ADDR
70012: LD_INT 6
70014: PUSH
70015: FOR_TO
70016: IFFALSE 70121
// begin uc_nation := nation_nature ;
70018: LD_ADDR_OWVAR 21
70022: PUSH
70023: LD_INT 0
70025: ST_TO_ADDR
// uc_side := 0 ;
70026: LD_ADDR_OWVAR 20
70030: PUSH
70031: LD_INT 0
70033: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
70034: LD_ADDR_OWVAR 29
70038: PUSH
70039: LD_INT 12
70041: PUSH
70042: LD_INT 12
70044: PUSH
70045: EMPTY
70046: LIST
70047: LIST
70048: ST_TO_ADDR
// hc_agressivity := 20 ;
70049: LD_ADDR_OWVAR 35
70053: PUSH
70054: LD_INT 20
70056: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
70057: LD_ADDR_OWVAR 28
70061: PUSH
70062: LD_INT 17
70064: ST_TO_ADDR
// hc_gallery :=  ;
70065: LD_ADDR_OWVAR 33
70069: PUSH
70070: LD_STRING 
70072: ST_TO_ADDR
// hc_name :=  ;
70073: LD_ADDR_OWVAR 26
70077: PUSH
70078: LD_STRING 
70080: ST_TO_ADDR
// un := CreateHuman ;
70081: LD_ADDR_VAR 0 2
70085: PUSH
70086: CALL_OW 44
70090: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
70091: LD_VAR 0 2
70095: PPUSH
70096: LD_INT 1
70098: PPUSH
70099: CALL_OW 51
// tmp := tmp ^ un ;
70103: LD_ADDR_VAR 0 3
70107: PUSH
70108: LD_VAR 0 3
70112: PUSH
70113: LD_VAR 0 2
70117: ADD
70118: ST_TO_ADDR
// end ;
70119: GO 70015
70121: POP
70122: POP
// repeat wait ( 0 0$1 ) ;
70123: LD_INT 35
70125: PPUSH
70126: CALL_OW 67
// for un in tmp do
70130: LD_ADDR_VAR 0 2
70134: PUSH
70135: LD_VAR 0 3
70139: PUSH
70140: FOR_IN
70141: IFFALSE 70215
// begin if IsDead ( un ) then
70143: LD_VAR 0 2
70147: PPUSH
70148: CALL_OW 301
70152: IFFALSE 70172
// begin tmp := tmp diff un ;
70154: LD_ADDR_VAR 0 3
70158: PUSH
70159: LD_VAR 0 3
70163: PUSH
70164: LD_VAR 0 2
70168: DIFF
70169: ST_TO_ADDR
// continue ;
70170: GO 70140
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
70172: LD_VAR 0 2
70176: PPUSH
70177: LD_INT 3
70179: PUSH
70180: LD_INT 22
70182: PUSH
70183: LD_INT 0
70185: PUSH
70186: EMPTY
70187: LIST
70188: LIST
70189: PUSH
70190: EMPTY
70191: LIST
70192: LIST
70193: PPUSH
70194: CALL_OW 69
70198: PPUSH
70199: LD_VAR 0 2
70203: PPUSH
70204: CALL_OW 74
70208: PPUSH
70209: CALL_OW 115
// end ;
70213: GO 70140
70215: POP
70216: POP
// until not tmp ;
70217: LD_VAR 0 3
70221: NOT
70222: IFFALSE 70123
// end ;
70224: PPOPN 3
70226: END
// every 0 0$1 trigger StreamModeActive and sTroll do
70227: LD_EXP 99
70231: PUSH
70232: LD_EXP 124
70236: AND
70237: IFFALSE 70291
70239: GO 70241
70241: DISABLE
// begin ToLua ( displayTroll(); ) ;
70242: LD_STRING displayTroll();
70244: PPUSH
70245: CALL_OW 559
// wait ( 3 3$00 ) ;
70249: LD_INT 6300
70251: PPUSH
70252: CALL_OW 67
// ToLua ( hideTroll(); ) ;
70256: LD_STRING hideTroll();
70258: PPUSH
70259: CALL_OW 559
// wait ( 1 1$00 ) ;
70263: LD_INT 2100
70265: PPUSH
70266: CALL_OW 67
// ToLua ( displayTroll(); ) ;
70270: LD_STRING displayTroll();
70272: PPUSH
70273: CALL_OW 559
// wait ( 1 1$00 ) ;
70277: LD_INT 2100
70279: PPUSH
70280: CALL_OW 67
// ToLua ( hideTroll(); ) ;
70284: LD_STRING hideTroll();
70286: PPUSH
70287: CALL_OW 559
// end ;
70291: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
70292: LD_EXP 99
70296: PUSH
70297: LD_EXP 125
70301: AND
70302: IFFALSE 70365
70304: GO 70306
70306: DISABLE
70307: LD_INT 0
70309: PPUSH
// begin p := 0 ;
70310: LD_ADDR_VAR 0 1
70314: PUSH
70315: LD_INT 0
70317: ST_TO_ADDR
// repeat game_speed := 1 ;
70318: LD_ADDR_OWVAR 65
70322: PUSH
70323: LD_INT 1
70325: ST_TO_ADDR
// wait ( 0 0$1 ) ;
70326: LD_INT 35
70328: PPUSH
70329: CALL_OW 67
// p := p + 1 ;
70333: LD_ADDR_VAR 0 1
70337: PUSH
70338: LD_VAR 0 1
70342: PUSH
70343: LD_INT 1
70345: PLUS
70346: ST_TO_ADDR
// until p >= 60 ;
70347: LD_VAR 0 1
70351: PUSH
70352: LD_INT 60
70354: GREATEREQUAL
70355: IFFALSE 70318
// game_speed := 4 ;
70357: LD_ADDR_OWVAR 65
70361: PUSH
70362: LD_INT 4
70364: ST_TO_ADDR
// end ;
70365: PPOPN 1
70367: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
70368: LD_EXP 99
70372: PUSH
70373: LD_EXP 126
70377: AND
70378: IFFALSE 70524
70380: GO 70382
70382: DISABLE
70383: LD_INT 0
70385: PPUSH
70386: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
70387: LD_ADDR_VAR 0 1
70391: PUSH
70392: LD_INT 22
70394: PUSH
70395: LD_OWVAR 2
70399: PUSH
70400: EMPTY
70401: LIST
70402: LIST
70403: PUSH
70404: LD_INT 2
70406: PUSH
70407: LD_INT 30
70409: PUSH
70410: LD_INT 0
70412: PUSH
70413: EMPTY
70414: LIST
70415: LIST
70416: PUSH
70417: LD_INT 30
70419: PUSH
70420: LD_INT 1
70422: PUSH
70423: EMPTY
70424: LIST
70425: LIST
70426: PUSH
70427: EMPTY
70428: LIST
70429: LIST
70430: LIST
70431: PUSH
70432: EMPTY
70433: LIST
70434: LIST
70435: PPUSH
70436: CALL_OW 69
70440: ST_TO_ADDR
// if not depot then
70441: LD_VAR 0 1
70445: NOT
70446: IFFALSE 70450
// exit ;
70448: GO 70524
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
70450: LD_ADDR_VAR 0 2
70454: PUSH
70455: LD_VAR 0 1
70459: PUSH
70460: LD_INT 1
70462: PPUSH
70463: LD_VAR 0 1
70467: PPUSH
70468: CALL_OW 12
70472: ARRAY
70473: PPUSH
70474: CALL_OW 274
70478: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
70479: LD_VAR 0 2
70483: PPUSH
70484: LD_INT 1
70486: PPUSH
70487: LD_INT 0
70489: PPUSH
70490: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
70494: LD_VAR 0 2
70498: PPUSH
70499: LD_INT 2
70501: PPUSH
70502: LD_INT 0
70504: PPUSH
70505: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
70509: LD_VAR 0 2
70513: PPUSH
70514: LD_INT 3
70516: PPUSH
70517: LD_INT 0
70519: PPUSH
70520: CALL_OW 277
// end ;
70524: PPOPN 2
70526: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
70527: LD_EXP 99
70531: PUSH
70532: LD_EXP 127
70536: AND
70537: IFFALSE 70634
70539: GO 70541
70541: DISABLE
70542: LD_INT 0
70544: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
70545: LD_ADDR_VAR 0 1
70549: PUSH
70550: LD_INT 22
70552: PUSH
70553: LD_OWVAR 2
70557: PUSH
70558: EMPTY
70559: LIST
70560: LIST
70561: PUSH
70562: LD_INT 21
70564: PUSH
70565: LD_INT 1
70567: PUSH
70568: EMPTY
70569: LIST
70570: LIST
70571: PUSH
70572: LD_INT 3
70574: PUSH
70575: LD_INT 23
70577: PUSH
70578: LD_INT 0
70580: PUSH
70581: EMPTY
70582: LIST
70583: LIST
70584: PUSH
70585: EMPTY
70586: LIST
70587: LIST
70588: PUSH
70589: EMPTY
70590: LIST
70591: LIST
70592: LIST
70593: PPUSH
70594: CALL_OW 69
70598: ST_TO_ADDR
// if not tmp then
70599: LD_VAR 0 1
70603: NOT
70604: IFFALSE 70608
// exit ;
70606: GO 70634
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
70608: LD_VAR 0 1
70612: PUSH
70613: LD_INT 1
70615: PPUSH
70616: LD_VAR 0 1
70620: PPUSH
70621: CALL_OW 12
70625: ARRAY
70626: PPUSH
70627: LD_INT 200
70629: PPUSH
70630: CALL_OW 234
// end ;
70634: PPOPN 1
70636: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
70637: LD_EXP 99
70641: PUSH
70642: LD_EXP 128
70646: AND
70647: IFFALSE 70726
70649: GO 70651
70651: DISABLE
70652: LD_INT 0
70654: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
70655: LD_ADDR_VAR 0 1
70659: PUSH
70660: LD_INT 22
70662: PUSH
70663: LD_OWVAR 2
70667: PUSH
70668: EMPTY
70669: LIST
70670: LIST
70671: PUSH
70672: LD_INT 21
70674: PUSH
70675: LD_INT 2
70677: PUSH
70678: EMPTY
70679: LIST
70680: LIST
70681: PUSH
70682: EMPTY
70683: LIST
70684: LIST
70685: PPUSH
70686: CALL_OW 69
70690: ST_TO_ADDR
// if not tmp then
70691: LD_VAR 0 1
70695: NOT
70696: IFFALSE 70700
// exit ;
70698: GO 70726
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
70700: LD_VAR 0 1
70704: PUSH
70705: LD_INT 1
70707: PPUSH
70708: LD_VAR 0 1
70712: PPUSH
70713: CALL_OW 12
70717: ARRAY
70718: PPUSH
70719: LD_INT 60
70721: PPUSH
70722: CALL_OW 234
// end ;
70726: PPOPN 1
70728: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
70729: LD_EXP 99
70733: PUSH
70734: LD_EXP 129
70738: AND
70739: IFFALSE 70838
70741: GO 70743
70743: DISABLE
70744: LD_INT 0
70746: PPUSH
70747: PPUSH
// begin enable ;
70748: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
70749: LD_ADDR_VAR 0 1
70753: PUSH
70754: LD_INT 22
70756: PUSH
70757: LD_OWVAR 2
70761: PUSH
70762: EMPTY
70763: LIST
70764: LIST
70765: PUSH
70766: LD_INT 61
70768: PUSH
70769: EMPTY
70770: LIST
70771: PUSH
70772: LD_INT 33
70774: PUSH
70775: LD_INT 2
70777: PUSH
70778: EMPTY
70779: LIST
70780: LIST
70781: PUSH
70782: EMPTY
70783: LIST
70784: LIST
70785: LIST
70786: PPUSH
70787: CALL_OW 69
70791: ST_TO_ADDR
// if not tmp then
70792: LD_VAR 0 1
70796: NOT
70797: IFFALSE 70801
// exit ;
70799: GO 70838
// for i in tmp do
70801: LD_ADDR_VAR 0 2
70805: PUSH
70806: LD_VAR 0 1
70810: PUSH
70811: FOR_IN
70812: IFFALSE 70836
// if IsControledBy ( i ) then
70814: LD_VAR 0 2
70818: PPUSH
70819: CALL_OW 312
70823: IFFALSE 70834
// ComUnlink ( i ) ;
70825: LD_VAR 0 2
70829: PPUSH
70830: CALL_OW 136
70834: GO 70811
70836: POP
70837: POP
// end ;
70838: PPOPN 2
70840: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
70841: LD_EXP 99
70845: PUSH
70846: LD_EXP 130
70850: AND
70851: IFFALSE 70991
70853: GO 70855
70855: DISABLE
70856: LD_INT 0
70858: PPUSH
70859: PPUSH
// begin ToLua ( displayPowell(); ) ;
70860: LD_STRING displayPowell();
70862: PPUSH
70863: CALL_OW 559
// uc_side := 0 ;
70867: LD_ADDR_OWVAR 20
70871: PUSH
70872: LD_INT 0
70874: ST_TO_ADDR
// uc_nation := 2 ;
70875: LD_ADDR_OWVAR 21
70879: PUSH
70880: LD_INT 2
70882: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
70883: LD_ADDR_OWVAR 37
70887: PUSH
70888: LD_INT 14
70890: ST_TO_ADDR
// vc_engine := engine_siberite ;
70891: LD_ADDR_OWVAR 39
70895: PUSH
70896: LD_INT 3
70898: ST_TO_ADDR
// vc_control := control_apeman ;
70899: LD_ADDR_OWVAR 38
70903: PUSH
70904: LD_INT 5
70906: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
70907: LD_ADDR_OWVAR 40
70911: PUSH
70912: LD_INT 29
70914: ST_TO_ADDR
// un := CreateVehicle ;
70915: LD_ADDR_VAR 0 2
70919: PUSH
70920: CALL_OW 45
70924: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
70925: LD_VAR 0 2
70929: PPUSH
70930: LD_INT 1
70932: PPUSH
70933: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
70937: LD_INT 35
70939: PPUSH
70940: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
70944: LD_VAR 0 2
70948: PPUSH
70949: LD_INT 22
70951: PUSH
70952: LD_OWVAR 2
70956: PUSH
70957: EMPTY
70958: LIST
70959: LIST
70960: PPUSH
70961: CALL_OW 69
70965: PPUSH
70966: LD_VAR 0 2
70970: PPUSH
70971: CALL_OW 74
70975: PPUSH
70976: CALL_OW 115
// until IsDead ( un ) ;
70980: LD_VAR 0 2
70984: PPUSH
70985: CALL_OW 301
70989: IFFALSE 70937
// end ;
70991: PPOPN 2
70993: END
// every 0 0$1 trigger StreamModeActive and sStu do
70994: LD_EXP 99
70998: PUSH
70999: LD_EXP 138
71003: AND
71004: IFFALSE 71020
71006: GO 71008
71008: DISABLE
// begin ToLua ( displayStucuk(); ) ;
71009: LD_STRING displayStucuk();
71011: PPUSH
71012: CALL_OW 559
// ResetFog ;
71016: CALL_OW 335
// end ;
71020: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
71021: LD_EXP 99
71025: PUSH
71026: LD_EXP 131
71030: AND
71031: IFFALSE 71172
71033: GO 71035
71035: DISABLE
71036: LD_INT 0
71038: PPUSH
71039: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
71040: LD_ADDR_VAR 0 2
71044: PUSH
71045: LD_INT 22
71047: PUSH
71048: LD_OWVAR 2
71052: PUSH
71053: EMPTY
71054: LIST
71055: LIST
71056: PUSH
71057: LD_INT 21
71059: PUSH
71060: LD_INT 1
71062: PUSH
71063: EMPTY
71064: LIST
71065: LIST
71066: PUSH
71067: EMPTY
71068: LIST
71069: LIST
71070: PPUSH
71071: CALL_OW 69
71075: ST_TO_ADDR
// if not tmp then
71076: LD_VAR 0 2
71080: NOT
71081: IFFALSE 71085
// exit ;
71083: GO 71172
// un := tmp [ rand ( 1 , tmp ) ] ;
71085: LD_ADDR_VAR 0 1
71089: PUSH
71090: LD_VAR 0 2
71094: PUSH
71095: LD_INT 1
71097: PPUSH
71098: LD_VAR 0 2
71102: PPUSH
71103: CALL_OW 12
71107: ARRAY
71108: ST_TO_ADDR
// SetSide ( un , 0 ) ;
71109: LD_VAR 0 1
71113: PPUSH
71114: LD_INT 0
71116: PPUSH
71117: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
71121: LD_VAR 0 1
71125: PPUSH
71126: LD_OWVAR 3
71130: PUSH
71131: LD_VAR 0 1
71135: DIFF
71136: PPUSH
71137: LD_VAR 0 1
71141: PPUSH
71142: CALL_OW 74
71146: PPUSH
71147: CALL_OW 115
// wait ( 0 0$20 ) ;
71151: LD_INT 700
71153: PPUSH
71154: CALL_OW 67
// SetSide ( un , your_side ) ;
71158: LD_VAR 0 1
71162: PPUSH
71163: LD_OWVAR 2
71167: PPUSH
71168: CALL_OW 235
// end ;
71172: PPOPN 2
71174: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
71175: LD_EXP 99
71179: PUSH
71180: LD_EXP 132
71184: AND
71185: IFFALSE 71291
71187: GO 71189
71189: DISABLE
71190: LD_INT 0
71192: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
71193: LD_ADDR_VAR 0 1
71197: PUSH
71198: LD_INT 22
71200: PUSH
71201: LD_OWVAR 2
71205: PUSH
71206: EMPTY
71207: LIST
71208: LIST
71209: PUSH
71210: LD_INT 2
71212: PUSH
71213: LD_INT 30
71215: PUSH
71216: LD_INT 0
71218: PUSH
71219: EMPTY
71220: LIST
71221: LIST
71222: PUSH
71223: LD_INT 30
71225: PUSH
71226: LD_INT 1
71228: PUSH
71229: EMPTY
71230: LIST
71231: LIST
71232: PUSH
71233: EMPTY
71234: LIST
71235: LIST
71236: LIST
71237: PUSH
71238: EMPTY
71239: LIST
71240: LIST
71241: PPUSH
71242: CALL_OW 69
71246: ST_TO_ADDR
// if not depot then
71247: LD_VAR 0 1
71251: NOT
71252: IFFALSE 71256
// exit ;
71254: GO 71291
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
71256: LD_VAR 0 1
71260: PUSH
71261: LD_INT 1
71263: ARRAY
71264: PPUSH
71265: CALL_OW 250
71269: PPUSH
71270: LD_VAR 0 1
71274: PUSH
71275: LD_INT 1
71277: ARRAY
71278: PPUSH
71279: CALL_OW 251
71283: PPUSH
71284: LD_INT 70
71286: PPUSH
71287: CALL_OW 495
// end ;
71291: PPOPN 1
71293: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
71294: LD_EXP 99
71298: PUSH
71299: LD_EXP 133
71303: AND
71304: IFFALSE 71515
71306: GO 71308
71308: DISABLE
71309: LD_INT 0
71311: PPUSH
71312: PPUSH
71313: PPUSH
71314: PPUSH
71315: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
71316: LD_ADDR_VAR 0 5
71320: PUSH
71321: LD_INT 22
71323: PUSH
71324: LD_OWVAR 2
71328: PUSH
71329: EMPTY
71330: LIST
71331: LIST
71332: PUSH
71333: LD_INT 21
71335: PUSH
71336: LD_INT 1
71338: PUSH
71339: EMPTY
71340: LIST
71341: LIST
71342: PUSH
71343: EMPTY
71344: LIST
71345: LIST
71346: PPUSH
71347: CALL_OW 69
71351: ST_TO_ADDR
// if not tmp then
71352: LD_VAR 0 5
71356: NOT
71357: IFFALSE 71361
// exit ;
71359: GO 71515
// for i in tmp do
71361: LD_ADDR_VAR 0 1
71365: PUSH
71366: LD_VAR 0 5
71370: PUSH
71371: FOR_IN
71372: IFFALSE 71513
// begin d := rand ( 0 , 5 ) ;
71374: LD_ADDR_VAR 0 4
71378: PUSH
71379: LD_INT 0
71381: PPUSH
71382: LD_INT 5
71384: PPUSH
71385: CALL_OW 12
71389: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
71390: LD_ADDR_VAR 0 2
71394: PUSH
71395: LD_VAR 0 1
71399: PPUSH
71400: CALL_OW 250
71404: PPUSH
71405: LD_VAR 0 4
71409: PPUSH
71410: LD_INT 3
71412: PPUSH
71413: LD_INT 12
71415: PPUSH
71416: CALL_OW 12
71420: PPUSH
71421: CALL_OW 272
71425: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
71426: LD_ADDR_VAR 0 3
71430: PUSH
71431: LD_VAR 0 1
71435: PPUSH
71436: CALL_OW 251
71440: PPUSH
71441: LD_VAR 0 4
71445: PPUSH
71446: LD_INT 3
71448: PPUSH
71449: LD_INT 12
71451: PPUSH
71452: CALL_OW 12
71456: PPUSH
71457: CALL_OW 273
71461: ST_TO_ADDR
// if ValidHex ( x , y ) then
71462: LD_VAR 0 2
71466: PPUSH
71467: LD_VAR 0 3
71471: PPUSH
71472: CALL_OW 488
71476: IFFALSE 71511
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
71478: LD_VAR 0 1
71482: PPUSH
71483: LD_VAR 0 2
71487: PPUSH
71488: LD_VAR 0 3
71492: PPUSH
71493: LD_INT 3
71495: PPUSH
71496: LD_INT 6
71498: PPUSH
71499: CALL_OW 12
71503: PPUSH
71504: LD_INT 1
71506: PPUSH
71507: CALL_OW 483
// end ;
71511: GO 71371
71513: POP
71514: POP
// end ;
71515: PPOPN 5
71517: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
71518: LD_EXP 99
71522: PUSH
71523: LD_EXP 134
71527: AND
71528: IFFALSE 71622
71530: GO 71532
71532: DISABLE
71533: LD_INT 0
71535: PPUSH
71536: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
71537: LD_ADDR_VAR 0 2
71541: PUSH
71542: LD_INT 22
71544: PUSH
71545: LD_OWVAR 2
71549: PUSH
71550: EMPTY
71551: LIST
71552: LIST
71553: PUSH
71554: LD_INT 32
71556: PUSH
71557: LD_INT 1
71559: PUSH
71560: EMPTY
71561: LIST
71562: LIST
71563: PUSH
71564: LD_INT 21
71566: PUSH
71567: LD_INT 2
71569: PUSH
71570: EMPTY
71571: LIST
71572: LIST
71573: PUSH
71574: EMPTY
71575: LIST
71576: LIST
71577: LIST
71578: PPUSH
71579: CALL_OW 69
71583: ST_TO_ADDR
// if not tmp then
71584: LD_VAR 0 2
71588: NOT
71589: IFFALSE 71593
// exit ;
71591: GO 71622
// for i in tmp do
71593: LD_ADDR_VAR 0 1
71597: PUSH
71598: LD_VAR 0 2
71602: PUSH
71603: FOR_IN
71604: IFFALSE 71620
// SetFuel ( i , 0 ) ;
71606: LD_VAR 0 1
71610: PPUSH
71611: LD_INT 0
71613: PPUSH
71614: CALL_OW 240
71618: GO 71603
71620: POP
71621: POP
// end ;
71622: PPOPN 2
71624: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
71625: LD_EXP 99
71629: PUSH
71630: LD_EXP 135
71634: AND
71635: IFFALSE 71701
71637: GO 71639
71639: DISABLE
71640: LD_INT 0
71642: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
71643: LD_ADDR_VAR 0 1
71647: PUSH
71648: LD_INT 22
71650: PUSH
71651: LD_OWVAR 2
71655: PUSH
71656: EMPTY
71657: LIST
71658: LIST
71659: PUSH
71660: LD_INT 30
71662: PUSH
71663: LD_INT 29
71665: PUSH
71666: EMPTY
71667: LIST
71668: LIST
71669: PUSH
71670: EMPTY
71671: LIST
71672: LIST
71673: PPUSH
71674: CALL_OW 69
71678: ST_TO_ADDR
// if not tmp then
71679: LD_VAR 0 1
71683: NOT
71684: IFFALSE 71688
// exit ;
71686: GO 71701
// DestroyUnit ( tmp [ 1 ] ) ;
71688: LD_VAR 0 1
71692: PUSH
71693: LD_INT 1
71695: ARRAY
71696: PPUSH
71697: CALL_OW 65
// end ;
71701: PPOPN 1
71703: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
71704: LD_EXP 99
71708: PUSH
71709: LD_EXP 137
71713: AND
71714: IFFALSE 71843
71716: GO 71718
71718: DISABLE
71719: LD_INT 0
71721: PPUSH
// begin uc_side := 0 ;
71722: LD_ADDR_OWVAR 20
71726: PUSH
71727: LD_INT 0
71729: ST_TO_ADDR
// uc_nation := nation_arabian ;
71730: LD_ADDR_OWVAR 21
71734: PUSH
71735: LD_INT 2
71737: ST_TO_ADDR
// hc_gallery :=  ;
71738: LD_ADDR_OWVAR 33
71742: PUSH
71743: LD_STRING 
71745: ST_TO_ADDR
// hc_name :=  ;
71746: LD_ADDR_OWVAR 26
71750: PUSH
71751: LD_STRING 
71753: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
71754: LD_INT 1
71756: PPUSH
71757: LD_INT 11
71759: PPUSH
71760: LD_INT 10
71762: PPUSH
71763: CALL_OW 380
// un := CreateHuman ;
71767: LD_ADDR_VAR 0 1
71771: PUSH
71772: CALL_OW 44
71776: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
71777: LD_VAR 0 1
71781: PPUSH
71782: LD_INT 1
71784: PPUSH
71785: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
71789: LD_INT 35
71791: PPUSH
71792: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
71796: LD_VAR 0 1
71800: PPUSH
71801: LD_INT 22
71803: PUSH
71804: LD_OWVAR 2
71808: PUSH
71809: EMPTY
71810: LIST
71811: LIST
71812: PPUSH
71813: CALL_OW 69
71817: PPUSH
71818: LD_VAR 0 1
71822: PPUSH
71823: CALL_OW 74
71827: PPUSH
71828: CALL_OW 115
// until IsDead ( un ) ;
71832: LD_VAR 0 1
71836: PPUSH
71837: CALL_OW 301
71841: IFFALSE 71789
// end ;
71843: PPOPN 1
71845: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
71846: LD_EXP 99
71850: PUSH
71851: LD_EXP 139
71855: AND
71856: IFFALSE 71868
71858: GO 71860
71860: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
71861: LD_STRING earthquake(getX(game), 0, 32)
71863: PPUSH
71864: CALL_OW 559
71868: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
71869: LD_EXP 99
71873: PUSH
71874: LD_EXP 140
71878: AND
71879: IFFALSE 71970
71881: GO 71883
71883: DISABLE
71884: LD_INT 0
71886: PPUSH
// begin enable ;
71887: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
71888: LD_ADDR_VAR 0 1
71892: PUSH
71893: LD_INT 22
71895: PUSH
71896: LD_OWVAR 2
71900: PUSH
71901: EMPTY
71902: LIST
71903: LIST
71904: PUSH
71905: LD_INT 21
71907: PUSH
71908: LD_INT 2
71910: PUSH
71911: EMPTY
71912: LIST
71913: LIST
71914: PUSH
71915: LD_INT 33
71917: PUSH
71918: LD_INT 3
71920: PUSH
71921: EMPTY
71922: LIST
71923: LIST
71924: PUSH
71925: EMPTY
71926: LIST
71927: LIST
71928: LIST
71929: PPUSH
71930: CALL_OW 69
71934: ST_TO_ADDR
// if not tmp then
71935: LD_VAR 0 1
71939: NOT
71940: IFFALSE 71944
// exit ;
71942: GO 71970
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
71944: LD_VAR 0 1
71948: PUSH
71949: LD_INT 1
71951: PPUSH
71952: LD_VAR 0 1
71956: PPUSH
71957: CALL_OW 12
71961: ARRAY
71962: PPUSH
71963: LD_INT 1
71965: PPUSH
71966: CALL_OW 234
// end ;
71970: PPOPN 1
71972: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
71973: LD_EXP 99
71977: PUSH
71978: LD_EXP 141
71982: AND
71983: IFFALSE 72124
71985: GO 71987
71987: DISABLE
71988: LD_INT 0
71990: PPUSH
71991: PPUSH
71992: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
71993: LD_ADDR_VAR 0 3
71997: PUSH
71998: LD_INT 22
72000: PUSH
72001: LD_OWVAR 2
72005: PUSH
72006: EMPTY
72007: LIST
72008: LIST
72009: PUSH
72010: LD_INT 25
72012: PUSH
72013: LD_INT 1
72015: PUSH
72016: EMPTY
72017: LIST
72018: LIST
72019: PUSH
72020: EMPTY
72021: LIST
72022: LIST
72023: PPUSH
72024: CALL_OW 69
72028: ST_TO_ADDR
// if not tmp then
72029: LD_VAR 0 3
72033: NOT
72034: IFFALSE 72038
// exit ;
72036: GO 72124
// un := tmp [ rand ( 1 , tmp ) ] ;
72038: LD_ADDR_VAR 0 2
72042: PUSH
72043: LD_VAR 0 3
72047: PUSH
72048: LD_INT 1
72050: PPUSH
72051: LD_VAR 0 3
72055: PPUSH
72056: CALL_OW 12
72060: ARRAY
72061: ST_TO_ADDR
// if Crawls ( un ) then
72062: LD_VAR 0 2
72066: PPUSH
72067: CALL_OW 318
72071: IFFALSE 72082
// ComWalk ( un ) ;
72073: LD_VAR 0 2
72077: PPUSH
72078: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
72082: LD_VAR 0 2
72086: PPUSH
72087: LD_INT 9
72089: PPUSH
72090: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
72094: LD_INT 28
72096: PPUSH
72097: LD_OWVAR 2
72101: PPUSH
72102: LD_INT 2
72104: PPUSH
72105: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
72109: LD_INT 29
72111: PPUSH
72112: LD_OWVAR 2
72116: PPUSH
72117: LD_INT 2
72119: PPUSH
72120: CALL_OW 322
// end ;
72124: PPOPN 3
72126: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
72127: LD_EXP 99
72131: PUSH
72132: LD_EXP 142
72136: AND
72137: IFFALSE 72248
72139: GO 72141
72141: DISABLE
72142: LD_INT 0
72144: PPUSH
72145: PPUSH
72146: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
72147: LD_ADDR_VAR 0 3
72151: PUSH
72152: LD_INT 22
72154: PUSH
72155: LD_OWVAR 2
72159: PUSH
72160: EMPTY
72161: LIST
72162: LIST
72163: PUSH
72164: LD_INT 25
72166: PUSH
72167: LD_INT 1
72169: PUSH
72170: EMPTY
72171: LIST
72172: LIST
72173: PUSH
72174: EMPTY
72175: LIST
72176: LIST
72177: PPUSH
72178: CALL_OW 69
72182: ST_TO_ADDR
// if not tmp then
72183: LD_VAR 0 3
72187: NOT
72188: IFFALSE 72192
// exit ;
72190: GO 72248
// un := tmp [ rand ( 1 , tmp ) ] ;
72192: LD_ADDR_VAR 0 2
72196: PUSH
72197: LD_VAR 0 3
72201: PUSH
72202: LD_INT 1
72204: PPUSH
72205: LD_VAR 0 3
72209: PPUSH
72210: CALL_OW 12
72214: ARRAY
72215: ST_TO_ADDR
// if Crawls ( un ) then
72216: LD_VAR 0 2
72220: PPUSH
72221: CALL_OW 318
72225: IFFALSE 72236
// ComWalk ( un ) ;
72227: LD_VAR 0 2
72231: PPUSH
72232: CALL_OW 138
// SetClass ( un , class_mortar ) ;
72236: LD_VAR 0 2
72240: PPUSH
72241: LD_INT 8
72243: PPUSH
72244: CALL_OW 336
// end ;
72248: PPOPN 3
72250: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
72251: LD_EXP 99
72255: PUSH
72256: LD_EXP 143
72260: AND
72261: IFFALSE 72405
72263: GO 72265
72265: DISABLE
72266: LD_INT 0
72268: PPUSH
72269: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
72270: LD_ADDR_VAR 0 2
72274: PUSH
72275: LD_INT 22
72277: PUSH
72278: LD_OWVAR 2
72282: PUSH
72283: EMPTY
72284: LIST
72285: LIST
72286: PUSH
72287: LD_INT 21
72289: PUSH
72290: LD_INT 2
72292: PUSH
72293: EMPTY
72294: LIST
72295: LIST
72296: PUSH
72297: LD_INT 2
72299: PUSH
72300: LD_INT 34
72302: PUSH
72303: LD_INT 12
72305: PUSH
72306: EMPTY
72307: LIST
72308: LIST
72309: PUSH
72310: LD_INT 34
72312: PUSH
72313: LD_INT 51
72315: PUSH
72316: EMPTY
72317: LIST
72318: LIST
72319: PUSH
72320: LD_INT 34
72322: PUSH
72323: LD_INT 32
72325: PUSH
72326: EMPTY
72327: LIST
72328: LIST
72329: PUSH
72330: EMPTY
72331: LIST
72332: LIST
72333: LIST
72334: LIST
72335: PUSH
72336: EMPTY
72337: LIST
72338: LIST
72339: LIST
72340: PPUSH
72341: CALL_OW 69
72345: ST_TO_ADDR
// if not tmp then
72346: LD_VAR 0 2
72350: NOT
72351: IFFALSE 72355
// exit ;
72353: GO 72405
// for i in tmp do
72355: LD_ADDR_VAR 0 1
72359: PUSH
72360: LD_VAR 0 2
72364: PUSH
72365: FOR_IN
72366: IFFALSE 72403
// if GetCargo ( i , mat_artifact ) = 0 then
72368: LD_VAR 0 1
72372: PPUSH
72373: LD_INT 4
72375: PPUSH
72376: CALL_OW 289
72380: PUSH
72381: LD_INT 0
72383: EQUAL
72384: IFFALSE 72401
// SetCargo ( i , mat_siberit , 100 ) ;
72386: LD_VAR 0 1
72390: PPUSH
72391: LD_INT 3
72393: PPUSH
72394: LD_INT 100
72396: PPUSH
72397: CALL_OW 290
72401: GO 72365
72403: POP
72404: POP
// end ;
72405: PPOPN 2
72407: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
72408: LD_EXP 99
72412: PUSH
72413: LD_EXP 144
72417: AND
72418: IFFALSE 72601
72420: GO 72422
72422: DISABLE
72423: LD_INT 0
72425: PPUSH
72426: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
72427: LD_ADDR_VAR 0 2
72431: PUSH
72432: LD_INT 22
72434: PUSH
72435: LD_OWVAR 2
72439: PUSH
72440: EMPTY
72441: LIST
72442: LIST
72443: PPUSH
72444: CALL_OW 69
72448: ST_TO_ADDR
// if not tmp then
72449: LD_VAR 0 2
72453: NOT
72454: IFFALSE 72458
// exit ;
72456: GO 72601
// for i := 1 to 2 do
72458: LD_ADDR_VAR 0 1
72462: PUSH
72463: DOUBLE
72464: LD_INT 1
72466: DEC
72467: ST_TO_ADDR
72468: LD_INT 2
72470: PUSH
72471: FOR_TO
72472: IFFALSE 72599
// begin uc_side := your_side ;
72474: LD_ADDR_OWVAR 20
72478: PUSH
72479: LD_OWVAR 2
72483: ST_TO_ADDR
// uc_nation := nation_american ;
72484: LD_ADDR_OWVAR 21
72488: PUSH
72489: LD_INT 1
72491: ST_TO_ADDR
// vc_chassis := us_morphling ;
72492: LD_ADDR_OWVAR 37
72496: PUSH
72497: LD_INT 5
72499: ST_TO_ADDR
// vc_engine := engine_siberite ;
72500: LD_ADDR_OWVAR 39
72504: PUSH
72505: LD_INT 3
72507: ST_TO_ADDR
// vc_control := control_computer ;
72508: LD_ADDR_OWVAR 38
72512: PUSH
72513: LD_INT 3
72515: ST_TO_ADDR
// vc_weapon := us_double_laser ;
72516: LD_ADDR_OWVAR 40
72520: PUSH
72521: LD_INT 10
72523: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
72524: LD_VAR 0 2
72528: PUSH
72529: LD_INT 1
72531: ARRAY
72532: PPUSH
72533: CALL_OW 310
72537: NOT
72538: IFFALSE 72585
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
72540: CALL_OW 45
72544: PPUSH
72545: LD_VAR 0 2
72549: PUSH
72550: LD_INT 1
72552: ARRAY
72553: PPUSH
72554: CALL_OW 250
72558: PPUSH
72559: LD_VAR 0 2
72563: PUSH
72564: LD_INT 1
72566: ARRAY
72567: PPUSH
72568: CALL_OW 251
72572: PPUSH
72573: LD_INT 12
72575: PPUSH
72576: LD_INT 1
72578: PPUSH
72579: CALL_OW 50
72583: GO 72597
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
72585: CALL_OW 45
72589: PPUSH
72590: LD_INT 1
72592: PPUSH
72593: CALL_OW 51
// end ;
72597: GO 72471
72599: POP
72600: POP
// end ;
72601: PPOPN 2
72603: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
72604: LD_EXP 99
72608: PUSH
72609: LD_EXP 145
72613: AND
72614: IFFALSE 72836
72616: GO 72618
72618: DISABLE
72619: LD_INT 0
72621: PPUSH
72622: PPUSH
72623: PPUSH
72624: PPUSH
72625: PPUSH
72626: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
72627: LD_ADDR_VAR 0 6
72631: PUSH
72632: LD_INT 22
72634: PUSH
72635: LD_OWVAR 2
72639: PUSH
72640: EMPTY
72641: LIST
72642: LIST
72643: PUSH
72644: LD_INT 21
72646: PUSH
72647: LD_INT 1
72649: PUSH
72650: EMPTY
72651: LIST
72652: LIST
72653: PUSH
72654: LD_INT 3
72656: PUSH
72657: LD_INT 23
72659: PUSH
72660: LD_INT 0
72662: PUSH
72663: EMPTY
72664: LIST
72665: LIST
72666: PUSH
72667: EMPTY
72668: LIST
72669: LIST
72670: PUSH
72671: EMPTY
72672: LIST
72673: LIST
72674: LIST
72675: PPUSH
72676: CALL_OW 69
72680: ST_TO_ADDR
// if not tmp then
72681: LD_VAR 0 6
72685: NOT
72686: IFFALSE 72690
// exit ;
72688: GO 72836
// s1 := rand ( 1 , 4 ) ;
72690: LD_ADDR_VAR 0 2
72694: PUSH
72695: LD_INT 1
72697: PPUSH
72698: LD_INT 4
72700: PPUSH
72701: CALL_OW 12
72705: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
72706: LD_ADDR_VAR 0 4
72710: PUSH
72711: LD_VAR 0 6
72715: PUSH
72716: LD_INT 1
72718: ARRAY
72719: PPUSH
72720: LD_VAR 0 2
72724: PPUSH
72725: CALL_OW 259
72729: ST_TO_ADDR
// if s1 = 1 then
72730: LD_VAR 0 2
72734: PUSH
72735: LD_INT 1
72737: EQUAL
72738: IFFALSE 72758
// s2 := rand ( 2 , 4 ) else
72740: LD_ADDR_VAR 0 3
72744: PUSH
72745: LD_INT 2
72747: PPUSH
72748: LD_INT 4
72750: PPUSH
72751: CALL_OW 12
72755: ST_TO_ADDR
72756: GO 72766
// s2 := 1 ;
72758: LD_ADDR_VAR 0 3
72762: PUSH
72763: LD_INT 1
72765: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
72766: LD_ADDR_VAR 0 5
72770: PUSH
72771: LD_VAR 0 6
72775: PUSH
72776: LD_INT 1
72778: ARRAY
72779: PPUSH
72780: LD_VAR 0 3
72784: PPUSH
72785: CALL_OW 259
72789: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
72790: LD_VAR 0 6
72794: PUSH
72795: LD_INT 1
72797: ARRAY
72798: PPUSH
72799: LD_VAR 0 2
72803: PPUSH
72804: LD_VAR 0 5
72808: PPUSH
72809: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
72813: LD_VAR 0 6
72817: PUSH
72818: LD_INT 1
72820: ARRAY
72821: PPUSH
72822: LD_VAR 0 3
72826: PPUSH
72827: LD_VAR 0 4
72831: PPUSH
72832: CALL_OW 237
// end ;
72836: PPOPN 6
72838: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
72839: LD_EXP 99
72843: PUSH
72844: LD_EXP 146
72848: AND
72849: IFFALSE 72928
72851: GO 72853
72853: DISABLE
72854: LD_INT 0
72856: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
72857: LD_ADDR_VAR 0 1
72861: PUSH
72862: LD_INT 22
72864: PUSH
72865: LD_OWVAR 2
72869: PUSH
72870: EMPTY
72871: LIST
72872: LIST
72873: PUSH
72874: LD_INT 30
72876: PUSH
72877: LD_INT 3
72879: PUSH
72880: EMPTY
72881: LIST
72882: LIST
72883: PUSH
72884: EMPTY
72885: LIST
72886: LIST
72887: PPUSH
72888: CALL_OW 69
72892: ST_TO_ADDR
// if not tmp then
72893: LD_VAR 0 1
72897: NOT
72898: IFFALSE 72902
// exit ;
72900: GO 72928
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
72902: LD_VAR 0 1
72906: PUSH
72907: LD_INT 1
72909: PPUSH
72910: LD_VAR 0 1
72914: PPUSH
72915: CALL_OW 12
72919: ARRAY
72920: PPUSH
72921: LD_INT 1
72923: PPUSH
72924: CALL_OW 234
// end ;
72928: PPOPN 1
72930: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
72931: LD_EXP 99
72935: PUSH
72936: LD_EXP 147
72940: AND
72941: IFFALSE 73053
72943: GO 72945
72945: DISABLE
72946: LD_INT 0
72948: PPUSH
72949: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
72950: LD_ADDR_VAR 0 2
72954: PUSH
72955: LD_INT 22
72957: PUSH
72958: LD_OWVAR 2
72962: PUSH
72963: EMPTY
72964: LIST
72965: LIST
72966: PUSH
72967: LD_INT 2
72969: PUSH
72970: LD_INT 30
72972: PUSH
72973: LD_INT 27
72975: PUSH
72976: EMPTY
72977: LIST
72978: LIST
72979: PUSH
72980: LD_INT 30
72982: PUSH
72983: LD_INT 26
72985: PUSH
72986: EMPTY
72987: LIST
72988: LIST
72989: PUSH
72990: LD_INT 30
72992: PUSH
72993: LD_INT 28
72995: PUSH
72996: EMPTY
72997: LIST
72998: LIST
72999: PUSH
73000: EMPTY
73001: LIST
73002: LIST
73003: LIST
73004: LIST
73005: PUSH
73006: EMPTY
73007: LIST
73008: LIST
73009: PPUSH
73010: CALL_OW 69
73014: ST_TO_ADDR
// if not tmp then
73015: LD_VAR 0 2
73019: NOT
73020: IFFALSE 73024
// exit ;
73022: GO 73053
// for i in tmp do
73024: LD_ADDR_VAR 0 1
73028: PUSH
73029: LD_VAR 0 2
73033: PUSH
73034: FOR_IN
73035: IFFALSE 73051
// SetLives ( i , 1 ) ;
73037: LD_VAR 0 1
73041: PPUSH
73042: LD_INT 1
73044: PPUSH
73045: CALL_OW 234
73049: GO 73034
73051: POP
73052: POP
// end ;
73053: PPOPN 2
73055: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
73056: LD_EXP 99
73060: PUSH
73061: LD_EXP 148
73065: AND
73066: IFFALSE 73340
73068: GO 73070
73070: DISABLE
73071: LD_INT 0
73073: PPUSH
73074: PPUSH
73075: PPUSH
// begin i := rand ( 1 , 7 ) ;
73076: LD_ADDR_VAR 0 1
73080: PUSH
73081: LD_INT 1
73083: PPUSH
73084: LD_INT 7
73086: PPUSH
73087: CALL_OW 12
73091: ST_TO_ADDR
// case i of 1 :
73092: LD_VAR 0 1
73096: PUSH
73097: LD_INT 1
73099: DOUBLE
73100: EQUAL
73101: IFTRUE 73105
73103: GO 73115
73105: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
73106: LD_STRING earthquake(getX(game), 0, 32)
73108: PPUSH
73109: CALL_OW 559
73113: GO 73340
73115: LD_INT 2
73117: DOUBLE
73118: EQUAL
73119: IFTRUE 73123
73121: GO 73137
73123: POP
// begin ToLua ( displayStucuk(); ) ;
73124: LD_STRING displayStucuk();
73126: PPUSH
73127: CALL_OW 559
// ResetFog ;
73131: CALL_OW 335
// end ; 3 :
73135: GO 73340
73137: LD_INT 3
73139: DOUBLE
73140: EQUAL
73141: IFTRUE 73145
73143: GO 73249
73145: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
73146: LD_ADDR_VAR 0 2
73150: PUSH
73151: LD_INT 22
73153: PUSH
73154: LD_OWVAR 2
73158: PUSH
73159: EMPTY
73160: LIST
73161: LIST
73162: PUSH
73163: LD_INT 25
73165: PUSH
73166: LD_INT 1
73168: PUSH
73169: EMPTY
73170: LIST
73171: LIST
73172: PUSH
73173: EMPTY
73174: LIST
73175: LIST
73176: PPUSH
73177: CALL_OW 69
73181: ST_TO_ADDR
// if not tmp then
73182: LD_VAR 0 2
73186: NOT
73187: IFFALSE 73191
// exit ;
73189: GO 73340
// un := tmp [ rand ( 1 , tmp ) ] ;
73191: LD_ADDR_VAR 0 3
73195: PUSH
73196: LD_VAR 0 2
73200: PUSH
73201: LD_INT 1
73203: PPUSH
73204: LD_VAR 0 2
73208: PPUSH
73209: CALL_OW 12
73213: ARRAY
73214: ST_TO_ADDR
// if Crawls ( un ) then
73215: LD_VAR 0 3
73219: PPUSH
73220: CALL_OW 318
73224: IFFALSE 73235
// ComWalk ( un ) ;
73226: LD_VAR 0 3
73230: PPUSH
73231: CALL_OW 138
// SetClass ( un , class_mortar ) ;
73235: LD_VAR 0 3
73239: PPUSH
73240: LD_INT 8
73242: PPUSH
73243: CALL_OW 336
// end ; 4 :
73247: GO 73340
73249: LD_INT 4
73251: DOUBLE
73252: EQUAL
73253: IFTRUE 73257
73255: GO 73318
73257: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
73258: LD_ADDR_VAR 0 2
73262: PUSH
73263: LD_INT 22
73265: PUSH
73266: LD_OWVAR 2
73270: PUSH
73271: EMPTY
73272: LIST
73273: LIST
73274: PUSH
73275: LD_INT 30
73277: PUSH
73278: LD_INT 29
73280: PUSH
73281: EMPTY
73282: LIST
73283: LIST
73284: PUSH
73285: EMPTY
73286: LIST
73287: LIST
73288: PPUSH
73289: CALL_OW 69
73293: ST_TO_ADDR
// if not tmp then
73294: LD_VAR 0 2
73298: NOT
73299: IFFALSE 73303
// exit ;
73301: GO 73340
// DestroyUnit ( tmp [ 1 ] ) ;
73303: LD_VAR 0 2
73307: PUSH
73308: LD_INT 1
73310: ARRAY
73311: PPUSH
73312: CALL_OW 65
// end ; 5 .. 7 :
73316: GO 73340
73318: LD_INT 5
73320: DOUBLE
73321: GREATEREQUAL
73322: IFFALSE 73330
73324: LD_INT 7
73326: DOUBLE
73327: LESSEQUAL
73328: IFTRUE 73332
73330: GO 73339
73332: POP
// StreamSibBomb ; end ;
73333: CALL 69590 0 0
73337: GO 73340
73339: POP
// end ;
73340: PPOPN 3
73342: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
73343: LD_EXP 99
73347: PUSH
73348: LD_EXP 149
73352: AND
73353: IFFALSE 73509
73355: GO 73357
73357: DISABLE
73358: LD_INT 0
73360: PPUSH
73361: PPUSH
73362: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
73363: LD_ADDR_VAR 0 2
73367: PUSH
73368: LD_INT 81
73370: PUSH
73371: LD_OWVAR 2
73375: PUSH
73376: EMPTY
73377: LIST
73378: LIST
73379: PUSH
73380: LD_INT 2
73382: PUSH
73383: LD_INT 21
73385: PUSH
73386: LD_INT 1
73388: PUSH
73389: EMPTY
73390: LIST
73391: LIST
73392: PUSH
73393: LD_INT 21
73395: PUSH
73396: LD_INT 2
73398: PUSH
73399: EMPTY
73400: LIST
73401: LIST
73402: PUSH
73403: EMPTY
73404: LIST
73405: LIST
73406: LIST
73407: PUSH
73408: EMPTY
73409: LIST
73410: LIST
73411: PPUSH
73412: CALL_OW 69
73416: ST_TO_ADDR
// if not tmp then
73417: LD_VAR 0 2
73421: NOT
73422: IFFALSE 73426
// exit ;
73424: GO 73509
// p := 0 ;
73426: LD_ADDR_VAR 0 3
73430: PUSH
73431: LD_INT 0
73433: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
73434: LD_INT 35
73436: PPUSH
73437: CALL_OW 67
// p := p + 1 ;
73441: LD_ADDR_VAR 0 3
73445: PUSH
73446: LD_VAR 0 3
73450: PUSH
73451: LD_INT 1
73453: PLUS
73454: ST_TO_ADDR
// for i in tmp do
73455: LD_ADDR_VAR 0 1
73459: PUSH
73460: LD_VAR 0 2
73464: PUSH
73465: FOR_IN
73466: IFFALSE 73497
// if GetLives ( i ) < 1000 then
73468: LD_VAR 0 1
73472: PPUSH
73473: CALL_OW 256
73477: PUSH
73478: LD_INT 1000
73480: LESS
73481: IFFALSE 73495
// SetLives ( i , 1000 ) ;
73483: LD_VAR 0 1
73487: PPUSH
73488: LD_INT 1000
73490: PPUSH
73491: CALL_OW 234
73495: GO 73465
73497: POP
73498: POP
// until p > 20 ;
73499: LD_VAR 0 3
73503: PUSH
73504: LD_INT 20
73506: GREATER
73507: IFFALSE 73434
// end ;
73509: PPOPN 3
73511: END
// every 0 0$1 trigger StreamModeActive and sTime do
73512: LD_EXP 99
73516: PUSH
73517: LD_EXP 150
73521: AND
73522: IFFALSE 73557
73524: GO 73526
73526: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
73527: LD_INT 28
73529: PPUSH
73530: LD_OWVAR 2
73534: PPUSH
73535: LD_INT 2
73537: PPUSH
73538: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
73542: LD_INT 30
73544: PPUSH
73545: LD_OWVAR 2
73549: PPUSH
73550: LD_INT 2
73552: PPUSH
73553: CALL_OW 322
// end ;
73557: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
73558: LD_EXP 99
73562: PUSH
73563: LD_EXP 151
73567: AND
73568: IFFALSE 73689
73570: GO 73572
73572: DISABLE
73573: LD_INT 0
73575: PPUSH
73576: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
73577: LD_ADDR_VAR 0 2
73581: PUSH
73582: LD_INT 22
73584: PUSH
73585: LD_OWVAR 2
73589: PUSH
73590: EMPTY
73591: LIST
73592: LIST
73593: PUSH
73594: LD_INT 21
73596: PUSH
73597: LD_INT 1
73599: PUSH
73600: EMPTY
73601: LIST
73602: LIST
73603: PUSH
73604: LD_INT 3
73606: PUSH
73607: LD_INT 23
73609: PUSH
73610: LD_INT 0
73612: PUSH
73613: EMPTY
73614: LIST
73615: LIST
73616: PUSH
73617: EMPTY
73618: LIST
73619: LIST
73620: PUSH
73621: EMPTY
73622: LIST
73623: LIST
73624: LIST
73625: PPUSH
73626: CALL_OW 69
73630: ST_TO_ADDR
// if not tmp then
73631: LD_VAR 0 2
73635: NOT
73636: IFFALSE 73640
// exit ;
73638: GO 73689
// for i in tmp do
73640: LD_ADDR_VAR 0 1
73644: PUSH
73645: LD_VAR 0 2
73649: PUSH
73650: FOR_IN
73651: IFFALSE 73687
// begin if Crawls ( i ) then
73653: LD_VAR 0 1
73657: PPUSH
73658: CALL_OW 318
73662: IFFALSE 73673
// ComWalk ( i ) ;
73664: LD_VAR 0 1
73668: PPUSH
73669: CALL_OW 138
// SetClass ( i , 2 ) ;
73673: LD_VAR 0 1
73677: PPUSH
73678: LD_INT 2
73680: PPUSH
73681: CALL_OW 336
// end ;
73685: GO 73650
73687: POP
73688: POP
// end ;
73689: PPOPN 2
73691: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
73692: LD_EXP 99
73696: PUSH
73697: LD_EXP 152
73701: AND
73702: IFFALSE 73983
73704: GO 73706
73706: DISABLE
73707: LD_INT 0
73709: PPUSH
73710: PPUSH
73711: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
73712: LD_OWVAR 2
73716: PPUSH
73717: LD_INT 9
73719: PPUSH
73720: LD_INT 1
73722: PPUSH
73723: LD_INT 1
73725: PPUSH
73726: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
73730: LD_INT 9
73732: PPUSH
73733: LD_OWVAR 2
73737: PPUSH
73738: CALL_OW 343
// uc_side := 9 ;
73742: LD_ADDR_OWVAR 20
73746: PUSH
73747: LD_INT 9
73749: ST_TO_ADDR
// uc_nation := 2 ;
73750: LD_ADDR_OWVAR 21
73754: PUSH
73755: LD_INT 2
73757: ST_TO_ADDR
// hc_name := Dark Warrior ;
73758: LD_ADDR_OWVAR 26
73762: PUSH
73763: LD_STRING Dark Warrior
73765: ST_TO_ADDR
// hc_gallery :=  ;
73766: LD_ADDR_OWVAR 33
73770: PUSH
73771: LD_STRING 
73773: ST_TO_ADDR
// hc_noskilllimit := true ;
73774: LD_ADDR_OWVAR 76
73778: PUSH
73779: LD_INT 1
73781: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
73782: LD_ADDR_OWVAR 31
73786: PUSH
73787: LD_INT 30
73789: PUSH
73790: LD_INT 30
73792: PUSH
73793: LD_INT 30
73795: PUSH
73796: LD_INT 30
73798: PUSH
73799: EMPTY
73800: LIST
73801: LIST
73802: LIST
73803: LIST
73804: ST_TO_ADDR
// un := CreateHuman ;
73805: LD_ADDR_VAR 0 3
73809: PUSH
73810: CALL_OW 44
73814: ST_TO_ADDR
// hc_noskilllimit := false ;
73815: LD_ADDR_OWVAR 76
73819: PUSH
73820: LD_INT 0
73822: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
73823: LD_VAR 0 3
73827: PPUSH
73828: LD_INT 1
73830: PPUSH
73831: CALL_OW 51
// p := 0 ;
73835: LD_ADDR_VAR 0 2
73839: PUSH
73840: LD_INT 0
73842: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
73843: LD_INT 35
73845: PPUSH
73846: CALL_OW 67
// p := p + 1 ;
73850: LD_ADDR_VAR 0 2
73854: PUSH
73855: LD_VAR 0 2
73859: PUSH
73860: LD_INT 1
73862: PLUS
73863: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
73864: LD_VAR 0 3
73868: PPUSH
73869: CALL_OW 256
73873: PUSH
73874: LD_INT 1000
73876: LESS
73877: IFFALSE 73891
// SetLives ( un , 1000 ) ;
73879: LD_VAR 0 3
73883: PPUSH
73884: LD_INT 1000
73886: PPUSH
73887: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
73891: LD_VAR 0 3
73895: PPUSH
73896: LD_INT 81
73898: PUSH
73899: LD_OWVAR 2
73903: PUSH
73904: EMPTY
73905: LIST
73906: LIST
73907: PUSH
73908: LD_INT 91
73910: PUSH
73911: LD_VAR 0 3
73915: PUSH
73916: LD_INT 30
73918: PUSH
73919: EMPTY
73920: LIST
73921: LIST
73922: LIST
73923: PUSH
73924: EMPTY
73925: LIST
73926: LIST
73927: PPUSH
73928: CALL_OW 69
73932: PPUSH
73933: LD_VAR 0 3
73937: PPUSH
73938: CALL_OW 74
73942: PPUSH
73943: CALL_OW 115
// until p > 60 or IsDead ( un ) ;
73947: LD_VAR 0 2
73951: PUSH
73952: LD_INT 60
73954: GREATER
73955: PUSH
73956: LD_VAR 0 3
73960: PPUSH
73961: CALL_OW 301
73965: OR
73966: IFFALSE 73843
// if un then
73968: LD_VAR 0 3
73972: IFFALSE 73983
// RemoveUnit ( un ) ;
73974: LD_VAR 0 3
73978: PPUSH
73979: CALL_OW 64
// end ;
73983: PPOPN 3
73985: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
73986: LD_INT 0
73988: PPUSH
// case cmd of 301 :
73989: LD_VAR 0 1
73993: PUSH
73994: LD_INT 301
73996: DOUBLE
73997: EQUAL
73998: IFTRUE 74002
74000: GO 74034
74002: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
74003: LD_VAR 0 6
74007: PPUSH
74008: LD_VAR 0 7
74012: PPUSH
74013: LD_VAR 0 8
74017: PPUSH
74018: LD_VAR 0 4
74022: PPUSH
74023: LD_VAR 0 5
74027: PPUSH
74028: CALL 75235 0 5
74032: GO 74155
74034: LD_INT 302
74036: DOUBLE
74037: EQUAL
74038: IFTRUE 74042
74040: GO 74079
74042: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
74043: LD_VAR 0 6
74047: PPUSH
74048: LD_VAR 0 7
74052: PPUSH
74053: LD_VAR 0 8
74057: PPUSH
74058: LD_VAR 0 9
74062: PPUSH
74063: LD_VAR 0 4
74067: PPUSH
74068: LD_VAR 0 5
74072: PPUSH
74073: CALL 75326 0 6
74077: GO 74155
74079: LD_INT 303
74081: DOUBLE
74082: EQUAL
74083: IFTRUE 74087
74085: GO 74124
74087: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
74088: LD_VAR 0 6
74092: PPUSH
74093: LD_VAR 0 7
74097: PPUSH
74098: LD_VAR 0 8
74102: PPUSH
74103: LD_VAR 0 9
74107: PPUSH
74108: LD_VAR 0 4
74112: PPUSH
74113: LD_VAR 0 5
74117: PPUSH
74118: CALL 74160 0 6
74122: GO 74155
74124: LD_INT 304
74126: DOUBLE
74127: EQUAL
74128: IFTRUE 74132
74130: GO 74154
74132: POP
// hHackTeleport ( unit , x , y ) ; end ;
74133: LD_VAR 0 2
74137: PPUSH
74138: LD_VAR 0 4
74142: PPUSH
74143: LD_VAR 0 5
74147: PPUSH
74148: CALL 75919 0 3
74152: GO 74155
74154: POP
// end ;
74155: LD_VAR 0 12
74159: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
74160: LD_INT 0
74162: PPUSH
74163: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
74164: LD_VAR 0 1
74168: PUSH
74169: LD_INT 1
74171: LESS
74172: PUSH
74173: LD_VAR 0 1
74177: PUSH
74178: LD_INT 3
74180: GREATER
74181: OR
74182: PUSH
74183: LD_VAR 0 5
74187: PPUSH
74188: LD_VAR 0 6
74192: PPUSH
74193: CALL_OW 428
74197: OR
74198: IFFALSE 74202
// exit ;
74200: GO 74922
// uc_side := your_side ;
74202: LD_ADDR_OWVAR 20
74206: PUSH
74207: LD_OWVAR 2
74211: ST_TO_ADDR
// uc_nation := nation ;
74212: LD_ADDR_OWVAR 21
74216: PUSH
74217: LD_VAR 0 1
74221: ST_TO_ADDR
// bc_level = 1 ;
74222: LD_ADDR_OWVAR 43
74226: PUSH
74227: LD_INT 1
74229: ST_TO_ADDR
// case btype of 1 :
74230: LD_VAR 0 2
74234: PUSH
74235: LD_INT 1
74237: DOUBLE
74238: EQUAL
74239: IFTRUE 74243
74241: GO 74254
74243: POP
// bc_type := b_depot ; 2 :
74244: LD_ADDR_OWVAR 42
74248: PUSH
74249: LD_INT 0
74251: ST_TO_ADDR
74252: GO 74866
74254: LD_INT 2
74256: DOUBLE
74257: EQUAL
74258: IFTRUE 74262
74260: GO 74273
74262: POP
// bc_type := b_warehouse ; 3 :
74263: LD_ADDR_OWVAR 42
74267: PUSH
74268: LD_INT 1
74270: ST_TO_ADDR
74271: GO 74866
74273: LD_INT 3
74275: DOUBLE
74276: EQUAL
74277: IFTRUE 74281
74279: GO 74292
74281: POP
// bc_type := b_lab ; 4 .. 9 :
74282: LD_ADDR_OWVAR 42
74286: PUSH
74287: LD_INT 6
74289: ST_TO_ADDR
74290: GO 74866
74292: LD_INT 4
74294: DOUBLE
74295: GREATEREQUAL
74296: IFFALSE 74304
74298: LD_INT 9
74300: DOUBLE
74301: LESSEQUAL
74302: IFTRUE 74306
74304: GO 74358
74306: POP
// begin bc_type := b_lab_half ;
74307: LD_ADDR_OWVAR 42
74311: PUSH
74312: LD_INT 7
74314: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
74315: LD_ADDR_OWVAR 44
74319: PUSH
74320: LD_INT 10
74322: PUSH
74323: LD_INT 11
74325: PUSH
74326: LD_INT 12
74328: PUSH
74329: LD_INT 15
74331: PUSH
74332: LD_INT 14
74334: PUSH
74335: LD_INT 13
74337: PUSH
74338: EMPTY
74339: LIST
74340: LIST
74341: LIST
74342: LIST
74343: LIST
74344: LIST
74345: PUSH
74346: LD_VAR 0 2
74350: PUSH
74351: LD_INT 3
74353: MINUS
74354: ARRAY
74355: ST_TO_ADDR
// end ; 10 .. 13 :
74356: GO 74866
74358: LD_INT 10
74360: DOUBLE
74361: GREATEREQUAL
74362: IFFALSE 74370
74364: LD_INT 13
74366: DOUBLE
74367: LESSEQUAL
74368: IFTRUE 74372
74370: GO 74449
74372: POP
// begin bc_type := b_lab_full ;
74373: LD_ADDR_OWVAR 42
74377: PUSH
74378: LD_INT 8
74380: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
74381: LD_ADDR_OWVAR 44
74385: PUSH
74386: LD_INT 10
74388: PUSH
74389: LD_INT 12
74391: PUSH
74392: LD_INT 14
74394: PUSH
74395: LD_INT 13
74397: PUSH
74398: EMPTY
74399: LIST
74400: LIST
74401: LIST
74402: LIST
74403: PUSH
74404: LD_VAR 0 2
74408: PUSH
74409: LD_INT 9
74411: MINUS
74412: ARRAY
74413: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
74414: LD_ADDR_OWVAR 45
74418: PUSH
74419: LD_INT 11
74421: PUSH
74422: LD_INT 15
74424: PUSH
74425: LD_INT 12
74427: PUSH
74428: LD_INT 15
74430: PUSH
74431: EMPTY
74432: LIST
74433: LIST
74434: LIST
74435: LIST
74436: PUSH
74437: LD_VAR 0 2
74441: PUSH
74442: LD_INT 9
74444: MINUS
74445: ARRAY
74446: ST_TO_ADDR
// end ; 14 :
74447: GO 74866
74449: LD_INT 14
74451: DOUBLE
74452: EQUAL
74453: IFTRUE 74457
74455: GO 74468
74457: POP
// bc_type := b_workshop ; 15 :
74458: LD_ADDR_OWVAR 42
74462: PUSH
74463: LD_INT 2
74465: ST_TO_ADDR
74466: GO 74866
74468: LD_INT 15
74470: DOUBLE
74471: EQUAL
74472: IFTRUE 74476
74474: GO 74487
74476: POP
// bc_type := b_factory ; 16 :
74477: LD_ADDR_OWVAR 42
74481: PUSH
74482: LD_INT 3
74484: ST_TO_ADDR
74485: GO 74866
74487: LD_INT 16
74489: DOUBLE
74490: EQUAL
74491: IFTRUE 74495
74493: GO 74506
74495: POP
// bc_type := b_ext_gun ; 17 :
74496: LD_ADDR_OWVAR 42
74500: PUSH
74501: LD_INT 17
74503: ST_TO_ADDR
74504: GO 74866
74506: LD_INT 17
74508: DOUBLE
74509: EQUAL
74510: IFTRUE 74514
74512: GO 74542
74514: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
74515: LD_ADDR_OWVAR 42
74519: PUSH
74520: LD_INT 19
74522: PUSH
74523: LD_INT 23
74525: PUSH
74526: LD_INT 19
74528: PUSH
74529: EMPTY
74530: LIST
74531: LIST
74532: LIST
74533: PUSH
74534: LD_VAR 0 1
74538: ARRAY
74539: ST_TO_ADDR
74540: GO 74866
74542: LD_INT 18
74544: DOUBLE
74545: EQUAL
74546: IFTRUE 74550
74548: GO 74561
74550: POP
// bc_type := b_ext_radar ; 19 :
74551: LD_ADDR_OWVAR 42
74555: PUSH
74556: LD_INT 20
74558: ST_TO_ADDR
74559: GO 74866
74561: LD_INT 19
74563: DOUBLE
74564: EQUAL
74565: IFTRUE 74569
74567: GO 74580
74569: POP
// bc_type := b_ext_radio ; 20 :
74570: LD_ADDR_OWVAR 42
74574: PUSH
74575: LD_INT 22
74577: ST_TO_ADDR
74578: GO 74866
74580: LD_INT 20
74582: DOUBLE
74583: EQUAL
74584: IFTRUE 74588
74586: GO 74599
74588: POP
// bc_type := b_ext_siberium ; 21 :
74589: LD_ADDR_OWVAR 42
74593: PUSH
74594: LD_INT 21
74596: ST_TO_ADDR
74597: GO 74866
74599: LD_INT 21
74601: DOUBLE
74602: EQUAL
74603: IFTRUE 74607
74605: GO 74618
74607: POP
// bc_type := b_ext_computer ; 22 :
74608: LD_ADDR_OWVAR 42
74612: PUSH
74613: LD_INT 24
74615: ST_TO_ADDR
74616: GO 74866
74618: LD_INT 22
74620: DOUBLE
74621: EQUAL
74622: IFTRUE 74626
74624: GO 74637
74626: POP
// bc_type := b_ext_track ; 23 :
74627: LD_ADDR_OWVAR 42
74631: PUSH
74632: LD_INT 16
74634: ST_TO_ADDR
74635: GO 74866
74637: LD_INT 23
74639: DOUBLE
74640: EQUAL
74641: IFTRUE 74645
74643: GO 74656
74645: POP
// bc_type := b_ext_laser ; 24 :
74646: LD_ADDR_OWVAR 42
74650: PUSH
74651: LD_INT 25
74653: ST_TO_ADDR
74654: GO 74866
74656: LD_INT 24
74658: DOUBLE
74659: EQUAL
74660: IFTRUE 74664
74662: GO 74675
74664: POP
// bc_type := b_control_tower ; 25 :
74665: LD_ADDR_OWVAR 42
74669: PUSH
74670: LD_INT 36
74672: ST_TO_ADDR
74673: GO 74866
74675: LD_INT 25
74677: DOUBLE
74678: EQUAL
74679: IFTRUE 74683
74681: GO 74694
74683: POP
// bc_type := b_breastwork ; 26 :
74684: LD_ADDR_OWVAR 42
74688: PUSH
74689: LD_INT 31
74691: ST_TO_ADDR
74692: GO 74866
74694: LD_INT 26
74696: DOUBLE
74697: EQUAL
74698: IFTRUE 74702
74700: GO 74713
74702: POP
// bc_type := b_bunker ; 27 :
74703: LD_ADDR_OWVAR 42
74707: PUSH
74708: LD_INT 32
74710: ST_TO_ADDR
74711: GO 74866
74713: LD_INT 27
74715: DOUBLE
74716: EQUAL
74717: IFTRUE 74721
74719: GO 74732
74721: POP
// bc_type := b_turret ; 28 :
74722: LD_ADDR_OWVAR 42
74726: PUSH
74727: LD_INT 33
74729: ST_TO_ADDR
74730: GO 74866
74732: LD_INT 28
74734: DOUBLE
74735: EQUAL
74736: IFTRUE 74740
74738: GO 74751
74740: POP
// bc_type := b_armoury ; 29 :
74741: LD_ADDR_OWVAR 42
74745: PUSH
74746: LD_INT 4
74748: ST_TO_ADDR
74749: GO 74866
74751: LD_INT 29
74753: DOUBLE
74754: EQUAL
74755: IFTRUE 74759
74757: GO 74770
74759: POP
// bc_type := b_barracks ; 30 :
74760: LD_ADDR_OWVAR 42
74764: PUSH
74765: LD_INT 5
74767: ST_TO_ADDR
74768: GO 74866
74770: LD_INT 30
74772: DOUBLE
74773: EQUAL
74774: IFTRUE 74778
74776: GO 74789
74778: POP
// bc_type := b_solar_power ; 31 :
74779: LD_ADDR_OWVAR 42
74783: PUSH
74784: LD_INT 27
74786: ST_TO_ADDR
74787: GO 74866
74789: LD_INT 31
74791: DOUBLE
74792: EQUAL
74793: IFTRUE 74797
74795: GO 74808
74797: POP
// bc_type := b_oil_power ; 32 :
74798: LD_ADDR_OWVAR 42
74802: PUSH
74803: LD_INT 26
74805: ST_TO_ADDR
74806: GO 74866
74808: LD_INT 32
74810: DOUBLE
74811: EQUAL
74812: IFTRUE 74816
74814: GO 74827
74816: POP
// bc_type := b_siberite_power ; 33 :
74817: LD_ADDR_OWVAR 42
74821: PUSH
74822: LD_INT 28
74824: ST_TO_ADDR
74825: GO 74866
74827: LD_INT 33
74829: DOUBLE
74830: EQUAL
74831: IFTRUE 74835
74833: GO 74846
74835: POP
// bc_type := b_oil_mine ; 34 :
74836: LD_ADDR_OWVAR 42
74840: PUSH
74841: LD_INT 29
74843: ST_TO_ADDR
74844: GO 74866
74846: LD_INT 34
74848: DOUBLE
74849: EQUAL
74850: IFTRUE 74854
74852: GO 74865
74854: POP
// bc_type := b_siberite_mine ; end ;
74855: LD_ADDR_OWVAR 42
74859: PUSH
74860: LD_INT 30
74862: ST_TO_ADDR
74863: GO 74866
74865: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
74866: LD_ADDR_VAR 0 8
74870: PUSH
74871: LD_VAR 0 5
74875: PPUSH
74876: LD_VAR 0 6
74880: PPUSH
74881: LD_VAR 0 3
74885: PPUSH
74886: CALL_OW 47
74890: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
74891: LD_OWVAR 42
74895: PUSH
74896: LD_INT 32
74898: PUSH
74899: LD_INT 33
74901: PUSH
74902: EMPTY
74903: LIST
74904: LIST
74905: IN
74906: IFFALSE 74922
// PlaceWeaponTurret ( b , weapon ) ;
74908: LD_VAR 0 8
74912: PPUSH
74913: LD_VAR 0 4
74917: PPUSH
74918: CALL_OW 431
// end ;
74922: LD_VAR 0 7
74926: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
74927: LD_INT 0
74929: PPUSH
74930: PPUSH
74931: PPUSH
74932: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
74933: LD_ADDR_VAR 0 4
74937: PUSH
74938: LD_INT 22
74940: PUSH
74941: LD_OWVAR 2
74945: PUSH
74946: EMPTY
74947: LIST
74948: LIST
74949: PUSH
74950: LD_INT 2
74952: PUSH
74953: LD_INT 30
74955: PUSH
74956: LD_INT 0
74958: PUSH
74959: EMPTY
74960: LIST
74961: LIST
74962: PUSH
74963: LD_INT 30
74965: PUSH
74966: LD_INT 1
74968: PUSH
74969: EMPTY
74970: LIST
74971: LIST
74972: PUSH
74973: EMPTY
74974: LIST
74975: LIST
74976: LIST
74977: PUSH
74978: EMPTY
74979: LIST
74980: LIST
74981: PPUSH
74982: CALL_OW 69
74986: ST_TO_ADDR
// if not tmp then
74987: LD_VAR 0 4
74991: NOT
74992: IFFALSE 74996
// exit ;
74994: GO 75055
// for i in tmp do
74996: LD_ADDR_VAR 0 2
75000: PUSH
75001: LD_VAR 0 4
75005: PUSH
75006: FOR_IN
75007: IFFALSE 75053
// for j = 1 to 3 do
75009: LD_ADDR_VAR 0 3
75013: PUSH
75014: DOUBLE
75015: LD_INT 1
75017: DEC
75018: ST_TO_ADDR
75019: LD_INT 3
75021: PUSH
75022: FOR_TO
75023: IFFALSE 75049
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
75025: LD_VAR 0 2
75029: PPUSH
75030: CALL_OW 274
75034: PPUSH
75035: LD_VAR 0 3
75039: PPUSH
75040: LD_INT 99999
75042: PPUSH
75043: CALL_OW 277
75047: GO 75022
75049: POP
75050: POP
75051: GO 75006
75053: POP
75054: POP
// end ;
75055: LD_VAR 0 1
75059: RET
// export function hHackSetLevel10 ; var i , j ; begin
75060: LD_INT 0
75062: PPUSH
75063: PPUSH
75064: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
75065: LD_ADDR_VAR 0 2
75069: PUSH
75070: LD_INT 21
75072: PUSH
75073: LD_INT 1
75075: PUSH
75076: EMPTY
75077: LIST
75078: LIST
75079: PPUSH
75080: CALL_OW 69
75084: PUSH
75085: FOR_IN
75086: IFFALSE 75138
// if IsSelected ( i ) then
75088: LD_VAR 0 2
75092: PPUSH
75093: CALL_OW 306
75097: IFFALSE 75136
// begin for j := 1 to 4 do
75099: LD_ADDR_VAR 0 3
75103: PUSH
75104: DOUBLE
75105: LD_INT 1
75107: DEC
75108: ST_TO_ADDR
75109: LD_INT 4
75111: PUSH
75112: FOR_TO
75113: IFFALSE 75134
// SetSkill ( i , j , 10 ) ;
75115: LD_VAR 0 2
75119: PPUSH
75120: LD_VAR 0 3
75124: PPUSH
75125: LD_INT 10
75127: PPUSH
75128: CALL_OW 237
75132: GO 75112
75134: POP
75135: POP
// end ;
75136: GO 75085
75138: POP
75139: POP
// end ;
75140: LD_VAR 0 1
75144: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
75145: LD_INT 0
75147: PPUSH
75148: PPUSH
75149: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
75150: LD_ADDR_VAR 0 2
75154: PUSH
75155: LD_INT 22
75157: PUSH
75158: LD_OWVAR 2
75162: PUSH
75163: EMPTY
75164: LIST
75165: LIST
75166: PUSH
75167: LD_INT 21
75169: PUSH
75170: LD_INT 1
75172: PUSH
75173: EMPTY
75174: LIST
75175: LIST
75176: PUSH
75177: EMPTY
75178: LIST
75179: LIST
75180: PPUSH
75181: CALL_OW 69
75185: PUSH
75186: FOR_IN
75187: IFFALSE 75228
// begin for j := 1 to 4 do
75189: LD_ADDR_VAR 0 3
75193: PUSH
75194: DOUBLE
75195: LD_INT 1
75197: DEC
75198: ST_TO_ADDR
75199: LD_INT 4
75201: PUSH
75202: FOR_TO
75203: IFFALSE 75224
// SetSkill ( i , j , 10 ) ;
75205: LD_VAR 0 2
75209: PPUSH
75210: LD_VAR 0 3
75214: PPUSH
75215: LD_INT 10
75217: PPUSH
75218: CALL_OW 237
75222: GO 75202
75224: POP
75225: POP
// end ;
75226: GO 75186
75228: POP
75229: POP
// end ;
75230: LD_VAR 0 1
75234: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
75235: LD_INT 0
75237: PPUSH
// uc_side := your_side ;
75238: LD_ADDR_OWVAR 20
75242: PUSH
75243: LD_OWVAR 2
75247: ST_TO_ADDR
// uc_nation := nation ;
75248: LD_ADDR_OWVAR 21
75252: PUSH
75253: LD_VAR 0 1
75257: ST_TO_ADDR
// InitHc ;
75258: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
75262: LD_INT 0
75264: PPUSH
75265: LD_VAR 0 2
75269: PPUSH
75270: LD_VAR 0 3
75274: PPUSH
75275: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
75279: LD_VAR 0 4
75283: PPUSH
75284: LD_VAR 0 5
75288: PPUSH
75289: CALL_OW 428
75293: PUSH
75294: LD_INT 0
75296: EQUAL
75297: IFFALSE 75321
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
75299: CALL_OW 44
75303: PPUSH
75304: LD_VAR 0 4
75308: PPUSH
75309: LD_VAR 0 5
75313: PPUSH
75314: LD_INT 1
75316: PPUSH
75317: CALL_OW 48
// end ;
75321: LD_VAR 0 6
75325: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
75326: LD_INT 0
75328: PPUSH
75329: PPUSH
// uc_side := your_side ;
75330: LD_ADDR_OWVAR 20
75334: PUSH
75335: LD_OWVAR 2
75339: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
75340: LD_VAR 0 1
75344: PUSH
75345: LD_INT 1
75347: PUSH
75348: LD_INT 2
75350: PUSH
75351: LD_INT 3
75353: PUSH
75354: LD_INT 4
75356: PUSH
75357: LD_INT 5
75359: PUSH
75360: EMPTY
75361: LIST
75362: LIST
75363: LIST
75364: LIST
75365: LIST
75366: IN
75367: IFFALSE 75379
// uc_nation := nation_american else
75369: LD_ADDR_OWVAR 21
75373: PUSH
75374: LD_INT 1
75376: ST_TO_ADDR
75377: GO 75422
// if chassis in [ 11 , 12 , 13 , 14 ] then
75379: LD_VAR 0 1
75383: PUSH
75384: LD_INT 11
75386: PUSH
75387: LD_INT 12
75389: PUSH
75390: LD_INT 13
75392: PUSH
75393: LD_INT 14
75395: PUSH
75396: EMPTY
75397: LIST
75398: LIST
75399: LIST
75400: LIST
75401: IN
75402: IFFALSE 75414
// uc_nation := nation_arabian else
75404: LD_ADDR_OWVAR 21
75408: PUSH
75409: LD_INT 2
75411: ST_TO_ADDR
75412: GO 75422
// uc_nation := nation_russian ;
75414: LD_ADDR_OWVAR 21
75418: PUSH
75419: LD_INT 3
75421: ST_TO_ADDR
// vc_chassis := chassis ;
75422: LD_ADDR_OWVAR 37
75426: PUSH
75427: LD_VAR 0 1
75431: ST_TO_ADDR
// vc_engine := engine ;
75432: LD_ADDR_OWVAR 39
75436: PUSH
75437: LD_VAR 0 2
75441: ST_TO_ADDR
// vc_control := control ;
75442: LD_ADDR_OWVAR 38
75446: PUSH
75447: LD_VAR 0 3
75451: ST_TO_ADDR
// vc_weapon := weapon ;
75452: LD_ADDR_OWVAR 40
75456: PUSH
75457: LD_VAR 0 4
75461: ST_TO_ADDR
// un := CreateVehicle ;
75462: LD_ADDR_VAR 0 8
75466: PUSH
75467: CALL_OW 45
75471: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
75472: LD_VAR 0 8
75476: PPUSH
75477: LD_INT 0
75479: PPUSH
75480: LD_INT 5
75482: PPUSH
75483: CALL_OW 12
75487: PPUSH
75488: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
75492: LD_VAR 0 8
75496: PPUSH
75497: LD_VAR 0 5
75501: PPUSH
75502: LD_VAR 0 6
75506: PPUSH
75507: LD_INT 1
75509: PPUSH
75510: CALL_OW 48
// end ;
75514: LD_VAR 0 7
75518: RET
// export hInvincible ; every 1 do
75519: GO 75521
75521: DISABLE
// hInvincible := [ ] ;
75522: LD_ADDR_EXP 153
75526: PUSH
75527: EMPTY
75528: ST_TO_ADDR
75529: END
// every 10 do var i ;
75530: GO 75532
75532: DISABLE
75533: LD_INT 0
75535: PPUSH
// begin enable ;
75536: ENABLE
// if not hInvincible then
75537: LD_EXP 153
75541: NOT
75542: IFFALSE 75546
// exit ;
75544: GO 75590
// for i in hInvincible do
75546: LD_ADDR_VAR 0 1
75550: PUSH
75551: LD_EXP 153
75555: PUSH
75556: FOR_IN
75557: IFFALSE 75588
// if GetLives ( i ) < 1000 then
75559: LD_VAR 0 1
75563: PPUSH
75564: CALL_OW 256
75568: PUSH
75569: LD_INT 1000
75571: LESS
75572: IFFALSE 75586
// SetLives ( i , 1000 ) ;
75574: LD_VAR 0 1
75578: PPUSH
75579: LD_INT 1000
75581: PPUSH
75582: CALL_OW 234
75586: GO 75556
75588: POP
75589: POP
// end ;
75590: PPOPN 1
75592: END
// export function hHackInvincible ; var i ; begin
75593: LD_INT 0
75595: PPUSH
75596: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
75597: LD_ADDR_VAR 0 2
75601: PUSH
75602: LD_INT 2
75604: PUSH
75605: LD_INT 21
75607: PUSH
75608: LD_INT 1
75610: PUSH
75611: EMPTY
75612: LIST
75613: LIST
75614: PUSH
75615: LD_INT 21
75617: PUSH
75618: LD_INT 2
75620: PUSH
75621: EMPTY
75622: LIST
75623: LIST
75624: PUSH
75625: EMPTY
75626: LIST
75627: LIST
75628: LIST
75629: PPUSH
75630: CALL_OW 69
75634: PUSH
75635: FOR_IN
75636: IFFALSE 75697
// if IsSelected ( i ) then
75638: LD_VAR 0 2
75642: PPUSH
75643: CALL_OW 306
75647: IFFALSE 75695
// begin if i in hInvincible then
75649: LD_VAR 0 2
75653: PUSH
75654: LD_EXP 153
75658: IN
75659: IFFALSE 75679
// hInvincible := hInvincible diff i else
75661: LD_ADDR_EXP 153
75665: PUSH
75666: LD_EXP 153
75670: PUSH
75671: LD_VAR 0 2
75675: DIFF
75676: ST_TO_ADDR
75677: GO 75695
// hInvincible := hInvincible union i ;
75679: LD_ADDR_EXP 153
75683: PUSH
75684: LD_EXP 153
75688: PUSH
75689: LD_VAR 0 2
75693: UNION
75694: ST_TO_ADDR
// end ;
75695: GO 75635
75697: POP
75698: POP
// end ;
75699: LD_VAR 0 1
75703: RET
// export function hHackInvisible ; var i , j ; begin
75704: LD_INT 0
75706: PPUSH
75707: PPUSH
75708: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
75709: LD_ADDR_VAR 0 2
75713: PUSH
75714: LD_INT 21
75716: PUSH
75717: LD_INT 1
75719: PUSH
75720: EMPTY
75721: LIST
75722: LIST
75723: PPUSH
75724: CALL_OW 69
75728: PUSH
75729: FOR_IN
75730: IFFALSE 75754
// if IsSelected ( i ) then
75732: LD_VAR 0 2
75736: PPUSH
75737: CALL_OW 306
75741: IFFALSE 75752
// ComForceInvisible ( i ) ;
75743: LD_VAR 0 2
75747: PPUSH
75748: CALL_OW 496
75752: GO 75729
75754: POP
75755: POP
// end ;
75756: LD_VAR 0 1
75760: RET
// export function hHackChangeYourSide ; begin
75761: LD_INT 0
75763: PPUSH
// if your_side = 8 then
75764: LD_OWVAR 2
75768: PUSH
75769: LD_INT 8
75771: EQUAL
75772: IFFALSE 75784
// your_side := 0 else
75774: LD_ADDR_OWVAR 2
75778: PUSH
75779: LD_INT 0
75781: ST_TO_ADDR
75782: GO 75798
// your_side := your_side + 1 ;
75784: LD_ADDR_OWVAR 2
75788: PUSH
75789: LD_OWVAR 2
75793: PUSH
75794: LD_INT 1
75796: PLUS
75797: ST_TO_ADDR
// end ;
75798: LD_VAR 0 1
75802: RET
// export function hHackChangeUnitSide ; var i , j ; begin
75803: LD_INT 0
75805: PPUSH
75806: PPUSH
75807: PPUSH
// for i in all_units do
75808: LD_ADDR_VAR 0 2
75812: PUSH
75813: LD_OWVAR 3
75817: PUSH
75818: FOR_IN
75819: IFFALSE 75897
// if IsSelected ( i ) then
75821: LD_VAR 0 2
75825: PPUSH
75826: CALL_OW 306
75830: IFFALSE 75895
// begin j := GetSide ( i ) ;
75832: LD_ADDR_VAR 0 3
75836: PUSH
75837: LD_VAR 0 2
75841: PPUSH
75842: CALL_OW 255
75846: ST_TO_ADDR
// if j = 8 then
75847: LD_VAR 0 3
75851: PUSH
75852: LD_INT 8
75854: EQUAL
75855: IFFALSE 75867
// j := 0 else
75857: LD_ADDR_VAR 0 3
75861: PUSH
75862: LD_INT 0
75864: ST_TO_ADDR
75865: GO 75881
// j := j + 1 ;
75867: LD_ADDR_VAR 0 3
75871: PUSH
75872: LD_VAR 0 3
75876: PUSH
75877: LD_INT 1
75879: PLUS
75880: ST_TO_ADDR
// SetSide ( i , j ) ;
75881: LD_VAR 0 2
75885: PPUSH
75886: LD_VAR 0 3
75890: PPUSH
75891: CALL_OW 235
// end ;
75895: GO 75818
75897: POP
75898: POP
// end ;
75899: LD_VAR 0 1
75903: RET
// export function hHackFog ; begin
75904: LD_INT 0
75906: PPUSH
// FogOff ( true ) ;
75907: LD_INT 1
75909: PPUSH
75910: CALL_OW 344
// end ;
75914: LD_VAR 0 1
75918: RET
// export function hHackTeleport ( unit , x , y ) ; begin
75919: LD_INT 0
75921: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
75922: LD_VAR 0 1
75926: PPUSH
75927: LD_VAR 0 2
75931: PPUSH
75932: LD_VAR 0 3
75936: PPUSH
75937: LD_INT 1
75939: PPUSH
75940: LD_INT 1
75942: PPUSH
75943: CALL_OW 483
// CenterOnXY ( x , y ) ;
75947: LD_VAR 0 2
75951: PPUSH
75952: LD_VAR 0 3
75956: PPUSH
75957: CALL_OW 84
// end ; end_of_file
75961: LD_VAR 0 4
75965: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb , ar_mortar , ar_crane , ar_miner ; export tech_Artillery , tech_RadMat , tech_BasicTools , tech_Cargo , tech_Track , tech_Crane , tech_Bulldozer , tech_Hovercraft , tech_MultiBarrels ; export class_mastodont , class_horse ; export function InitGlobalVariables ; begin
75966: LD_INT 0
75968: PPUSH
// ar_miner := 81 ;
75969: LD_ADDR_EXP 161
75973: PUSH
75974: LD_INT 81
75976: ST_TO_ADDR
// ar_crane := 88 ;
75977: LD_ADDR_EXP 160
75981: PUSH
75982: LD_INT 88
75984: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
75985: LD_ADDR_EXP 155
75989: PUSH
75990: LD_INT 89
75992: ST_TO_ADDR
// us_hack := 99 ;
75993: LD_ADDR_EXP 156
75997: PUSH
75998: LD_INT 99
76000: ST_TO_ADDR
// us_artillery := 97 ;
76001: LD_ADDR_EXP 157
76005: PUSH
76006: LD_INT 97
76008: ST_TO_ADDR
// ar_bio_bomb := 91 ;
76009: LD_ADDR_EXP 158
76013: PUSH
76014: LD_INT 91
76016: ST_TO_ADDR
// ar_mortar := 92 ;
76017: LD_ADDR_EXP 159
76021: PUSH
76022: LD_INT 92
76024: ST_TO_ADDR
// ru_radar := 98 ;
76025: LD_ADDR_EXP 154
76029: PUSH
76030: LD_INT 98
76032: ST_TO_ADDR
// tech_Artillery := 80 ;
76033: LD_ADDR_EXP 162
76037: PUSH
76038: LD_INT 80
76040: ST_TO_ADDR
// tech_RadMat := 81 ;
76041: LD_ADDR_EXP 163
76045: PUSH
76046: LD_INT 81
76048: ST_TO_ADDR
// tech_BasicTools := 82 ;
76049: LD_ADDR_EXP 164
76053: PUSH
76054: LD_INT 82
76056: ST_TO_ADDR
// tech_Cargo := 83 ;
76057: LD_ADDR_EXP 165
76061: PUSH
76062: LD_INT 83
76064: ST_TO_ADDR
// tech_Track := 84 ;
76065: LD_ADDR_EXP 166
76069: PUSH
76070: LD_INT 84
76072: ST_TO_ADDR
// tech_Crane := 85 ;
76073: LD_ADDR_EXP 167
76077: PUSH
76078: LD_INT 85
76080: ST_TO_ADDR
// tech_Bulldozer := 86 ;
76081: LD_ADDR_EXP 168
76085: PUSH
76086: LD_INT 86
76088: ST_TO_ADDR
// tech_Hovercraft := 87 ;
76089: LD_ADDR_EXP 169
76093: PUSH
76094: LD_INT 87
76096: ST_TO_ADDR
// tech_MultiBarrels := 88 ;
76097: LD_ADDR_EXP 170
76101: PUSH
76102: LD_INT 88
76104: ST_TO_ADDR
// class_mastodont := 31 ;
76105: LD_ADDR_EXP 171
76109: PUSH
76110: LD_INT 31
76112: ST_TO_ADDR
// class_horse := 21 ;
76113: LD_ADDR_EXP 172
76117: PUSH
76118: LD_INT 21
76120: ST_TO_ADDR
// end ;
76121: LD_VAR 0 1
76125: RET
// every 1 do
76126: GO 76128
76128: DISABLE
// InitGlobalVariables ; end_of_file
76129: CALL 75966 0 0
76133: END
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
76134: LD_VAR 0 1
76138: PUSH
76139: LD_INT 200
76141: DOUBLE
76142: GREATEREQUAL
76143: IFFALSE 76151
76145: LD_INT 299
76147: DOUBLE
76148: LESSEQUAL
76149: IFTRUE 76153
76151: GO 76185
76153: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
76154: LD_VAR 0 1
76158: PPUSH
76159: LD_VAR 0 2
76163: PPUSH
76164: LD_VAR 0 3
76168: PPUSH
76169: LD_VAR 0 4
76173: PPUSH
76174: LD_VAR 0 5
76178: PPUSH
76179: CALL 58911 0 5
76183: GO 76262
76185: LD_INT 300
76187: DOUBLE
76188: GREATEREQUAL
76189: IFFALSE 76197
76191: LD_INT 399
76193: DOUBLE
76194: LESSEQUAL
76195: IFTRUE 76199
76197: GO 76261
76199: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
76200: LD_VAR 0 1
76204: PPUSH
76205: LD_VAR 0 2
76209: PPUSH
76210: LD_VAR 0 3
76214: PPUSH
76215: LD_VAR 0 4
76219: PPUSH
76220: LD_VAR 0 5
76224: PPUSH
76225: LD_VAR 0 6
76229: PPUSH
76230: LD_VAR 0 7
76234: PPUSH
76235: LD_VAR 0 8
76239: PPUSH
76240: LD_VAR 0 9
76244: PPUSH
76245: LD_VAR 0 10
76249: PPUSH
76250: LD_VAR 0 11
76254: PPUSH
76255: CALL 73986 0 11
76259: GO 76262
76261: POP
// end ;
76262: PPOPN 11
76264: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
76265: LD_VAR 0 1
76269: PPUSH
76270: LD_VAR 0 2
76274: PPUSH
76275: LD_VAR 0 3
76279: PPUSH
76280: LD_VAR 0 4
76284: PPUSH
76285: LD_VAR 0 5
76289: PPUSH
76290: CALL 58893 0 5
// end ; end_of_file
76294: PPOPN 5
76296: END
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
76297: LD_INT 0
76299: PPUSH
76300: PPUSH
76301: PPUSH
76302: PPUSH
76303: PPUSH
76304: PPUSH
76305: PPUSH
76306: PPUSH
76307: PPUSH
76308: PPUSH
76309: PPUSH
76310: PPUSH
76311: PPUSH
76312: PPUSH
76313: PPUSH
76314: PPUSH
76315: PPUSH
76316: PPUSH
76317: PPUSH
76318: PPUSH
76319: PPUSH
76320: PPUSH
76321: PPUSH
76322: PPUSH
76323: PPUSH
76324: PPUSH
76325: PPUSH
76326: PPUSH
76327: PPUSH
76328: PPUSH
76329: PPUSH
76330: PPUSH
76331: PPUSH
76332: PPUSH
// if not list then
76333: LD_VAR 0 1
76337: NOT
76338: IFFALSE 76342
// exit ;
76340: GO 81001
// base := list [ 1 ] ;
76342: LD_ADDR_VAR 0 3
76346: PUSH
76347: LD_VAR 0 1
76351: PUSH
76352: LD_INT 1
76354: ARRAY
76355: ST_TO_ADDR
// group := list [ 2 ] ;
76356: LD_ADDR_VAR 0 4
76360: PUSH
76361: LD_VAR 0 1
76365: PUSH
76366: LD_INT 2
76368: ARRAY
76369: ST_TO_ADDR
// path := list [ 3 ] ;
76370: LD_ADDR_VAR 0 5
76374: PUSH
76375: LD_VAR 0 1
76379: PUSH
76380: LD_INT 3
76382: ARRAY
76383: ST_TO_ADDR
// flags := list [ 4 ] ;
76384: LD_ADDR_VAR 0 6
76388: PUSH
76389: LD_VAR 0 1
76393: PUSH
76394: LD_INT 4
76396: ARRAY
76397: ST_TO_ADDR
// mined := [ ] ;
76398: LD_ADDR_VAR 0 27
76402: PUSH
76403: EMPTY
76404: ST_TO_ADDR
// bombed := [ ] ;
76405: LD_ADDR_VAR 0 28
76409: PUSH
76410: EMPTY
76411: ST_TO_ADDR
// healers := [ ] ;
76412: LD_ADDR_VAR 0 31
76416: PUSH
76417: EMPTY
76418: ST_TO_ADDR
// to_heal := [ ] ;
76419: LD_ADDR_VAR 0 30
76423: PUSH
76424: EMPTY
76425: ST_TO_ADDR
// repairs := [ ] ;
76426: LD_ADDR_VAR 0 33
76430: PUSH
76431: EMPTY
76432: ST_TO_ADDR
// to_repair := [ ] ;
76433: LD_ADDR_VAR 0 32
76437: PUSH
76438: EMPTY
76439: ST_TO_ADDR
// if not group or not path then
76440: LD_VAR 0 4
76444: NOT
76445: PUSH
76446: LD_VAR 0 5
76450: NOT
76451: OR
76452: IFFALSE 76456
// exit ;
76454: GO 81001
// side := GetSide ( group [ 1 ] ) ;
76456: LD_ADDR_VAR 0 35
76460: PUSH
76461: LD_VAR 0 4
76465: PUSH
76466: LD_INT 1
76468: ARRAY
76469: PPUSH
76470: CALL_OW 255
76474: ST_TO_ADDR
// if flags then
76475: LD_VAR 0 6
76479: IFFALSE 76623
// begin f_ignore_area := flags [ 1 ] ;
76481: LD_ADDR_VAR 0 17
76485: PUSH
76486: LD_VAR 0 6
76490: PUSH
76491: LD_INT 1
76493: ARRAY
76494: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
76495: LD_ADDR_VAR 0 18
76499: PUSH
76500: LD_VAR 0 6
76504: PUSH
76505: LD_INT 2
76507: ARRAY
76508: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
76509: LD_ADDR_VAR 0 19
76513: PUSH
76514: LD_VAR 0 6
76518: PUSH
76519: LD_INT 3
76521: ARRAY
76522: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
76523: LD_ADDR_VAR 0 20
76527: PUSH
76528: LD_VAR 0 6
76532: PUSH
76533: LD_INT 4
76535: ARRAY
76536: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
76537: LD_ADDR_VAR 0 21
76541: PUSH
76542: LD_VAR 0 6
76546: PUSH
76547: LD_INT 5
76549: ARRAY
76550: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
76551: LD_ADDR_VAR 0 22
76555: PUSH
76556: LD_VAR 0 6
76560: PUSH
76561: LD_INT 6
76563: ARRAY
76564: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
76565: LD_ADDR_VAR 0 23
76569: PUSH
76570: LD_VAR 0 6
76574: PUSH
76575: LD_INT 7
76577: ARRAY
76578: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
76579: LD_ADDR_VAR 0 24
76583: PUSH
76584: LD_VAR 0 6
76588: PUSH
76589: LD_INT 8
76591: ARRAY
76592: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
76593: LD_ADDR_VAR 0 25
76597: PUSH
76598: LD_VAR 0 6
76602: PUSH
76603: LD_INT 9
76605: ARRAY
76606: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
76607: LD_ADDR_VAR 0 26
76611: PUSH
76612: LD_VAR 0 6
76616: PUSH
76617: LD_INT 10
76619: ARRAY
76620: ST_TO_ADDR
// end else
76621: GO 76703
// begin f_ignore_area := false ;
76623: LD_ADDR_VAR 0 17
76627: PUSH
76628: LD_INT 0
76630: ST_TO_ADDR
// f_capture := false ;
76631: LD_ADDR_VAR 0 18
76635: PUSH
76636: LD_INT 0
76638: ST_TO_ADDR
// f_ignore_civ := false ;
76639: LD_ADDR_VAR 0 19
76643: PUSH
76644: LD_INT 0
76646: ST_TO_ADDR
// f_murder := false ;
76647: LD_ADDR_VAR 0 20
76651: PUSH
76652: LD_INT 0
76654: ST_TO_ADDR
// f_mines := false ;
76655: LD_ADDR_VAR 0 21
76659: PUSH
76660: LD_INT 0
76662: ST_TO_ADDR
// f_repair := false ;
76663: LD_ADDR_VAR 0 22
76667: PUSH
76668: LD_INT 0
76670: ST_TO_ADDR
// f_heal := false ;
76671: LD_ADDR_VAR 0 23
76675: PUSH
76676: LD_INT 0
76678: ST_TO_ADDR
// f_spacetime := false ;
76679: LD_ADDR_VAR 0 24
76683: PUSH
76684: LD_INT 0
76686: ST_TO_ADDR
// f_attack_depot := false ;
76687: LD_ADDR_VAR 0 25
76691: PUSH
76692: LD_INT 0
76694: ST_TO_ADDR
// f_crawl := false ;
76695: LD_ADDR_VAR 0 26
76699: PUSH
76700: LD_INT 0
76702: ST_TO_ADDR
// end ; if f_heal then
76703: LD_VAR 0 23
76707: IFFALSE 76734
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
76709: LD_ADDR_VAR 0 31
76713: PUSH
76714: LD_VAR 0 4
76718: PPUSH
76719: LD_INT 25
76721: PUSH
76722: LD_INT 4
76724: PUSH
76725: EMPTY
76726: LIST
76727: LIST
76728: PPUSH
76729: CALL_OW 72
76733: ST_TO_ADDR
// if f_repair then
76734: LD_VAR 0 22
76738: IFFALSE 76765
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
76740: LD_ADDR_VAR 0 33
76744: PUSH
76745: LD_VAR 0 4
76749: PPUSH
76750: LD_INT 25
76752: PUSH
76753: LD_INT 3
76755: PUSH
76756: EMPTY
76757: LIST
76758: LIST
76759: PPUSH
76760: CALL_OW 72
76764: ST_TO_ADDR
// units_path := [ ] ;
76765: LD_ADDR_VAR 0 16
76769: PUSH
76770: EMPTY
76771: ST_TO_ADDR
// for i = 1 to group do
76772: LD_ADDR_VAR 0 7
76776: PUSH
76777: DOUBLE
76778: LD_INT 1
76780: DEC
76781: ST_TO_ADDR
76782: LD_VAR 0 4
76786: PUSH
76787: FOR_TO
76788: IFFALSE 76817
// units_path := Replace ( units_path , i , path ) ;
76790: LD_ADDR_VAR 0 16
76794: PUSH
76795: LD_VAR 0 16
76799: PPUSH
76800: LD_VAR 0 7
76804: PPUSH
76805: LD_VAR 0 5
76809: PPUSH
76810: CALL_OW 1
76814: ST_TO_ADDR
76815: GO 76787
76817: POP
76818: POP
// repeat for i = group downto 1 do
76819: LD_ADDR_VAR 0 7
76823: PUSH
76824: DOUBLE
76825: LD_VAR 0 4
76829: INC
76830: ST_TO_ADDR
76831: LD_INT 1
76833: PUSH
76834: FOR_DOWNTO
76835: IFFALSE 80957
// begin wait ( 5 ) ;
76837: LD_INT 5
76839: PPUSH
76840: CALL_OW 67
// tmp := [ ] ;
76844: LD_ADDR_VAR 0 14
76848: PUSH
76849: EMPTY
76850: ST_TO_ADDR
// attacking := false ;
76851: LD_ADDR_VAR 0 29
76855: PUSH
76856: LD_INT 0
76858: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
76859: LD_VAR 0 4
76863: PUSH
76864: LD_VAR 0 7
76868: ARRAY
76869: PPUSH
76870: CALL_OW 301
76874: PUSH
76875: LD_VAR 0 4
76879: PUSH
76880: LD_VAR 0 7
76884: ARRAY
76885: NOT
76886: OR
76887: IFFALSE 76996
// begin if GetType ( group [ i ] ) = unit_human then
76889: LD_VAR 0 4
76893: PUSH
76894: LD_VAR 0 7
76898: ARRAY
76899: PPUSH
76900: CALL_OW 247
76904: PUSH
76905: LD_INT 1
76907: EQUAL
76908: IFFALSE 76954
// begin to_heal := to_heal diff group [ i ] ;
76910: LD_ADDR_VAR 0 30
76914: PUSH
76915: LD_VAR 0 30
76919: PUSH
76920: LD_VAR 0 4
76924: PUSH
76925: LD_VAR 0 7
76929: ARRAY
76930: DIFF
76931: ST_TO_ADDR
// healers := healers diff group [ i ] ;
76932: LD_ADDR_VAR 0 31
76936: PUSH
76937: LD_VAR 0 31
76941: PUSH
76942: LD_VAR 0 4
76946: PUSH
76947: LD_VAR 0 7
76951: ARRAY
76952: DIFF
76953: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
76954: LD_ADDR_VAR 0 4
76958: PUSH
76959: LD_VAR 0 4
76963: PPUSH
76964: LD_VAR 0 7
76968: PPUSH
76969: CALL_OW 3
76973: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
76974: LD_ADDR_VAR 0 16
76978: PUSH
76979: LD_VAR 0 16
76983: PPUSH
76984: LD_VAR 0 7
76988: PPUSH
76989: CALL_OW 3
76993: ST_TO_ADDR
// continue ;
76994: GO 76834
// end ; if f_repair then
76996: LD_VAR 0 22
77000: IFFALSE 77489
// begin if GetType ( group [ i ] ) = unit_vehicle then
77002: LD_VAR 0 4
77006: PUSH
77007: LD_VAR 0 7
77011: ARRAY
77012: PPUSH
77013: CALL_OW 247
77017: PUSH
77018: LD_INT 2
77020: EQUAL
77021: IFFALSE 77211
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
77023: LD_VAR 0 4
77027: PUSH
77028: LD_VAR 0 7
77032: ARRAY
77033: PPUSH
77034: CALL_OW 256
77038: PUSH
77039: LD_INT 700
77041: LESS
77042: PUSH
77043: LD_VAR 0 4
77047: PUSH
77048: LD_VAR 0 7
77052: ARRAY
77053: PUSH
77054: LD_VAR 0 32
77058: IN
77059: NOT
77060: AND
77061: IFFALSE 77085
// to_repair := to_repair union group [ i ] ;
77063: LD_ADDR_VAR 0 32
77067: PUSH
77068: LD_VAR 0 32
77072: PUSH
77073: LD_VAR 0 4
77077: PUSH
77078: LD_VAR 0 7
77082: ARRAY
77083: UNION
77084: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
77085: LD_VAR 0 4
77089: PUSH
77090: LD_VAR 0 7
77094: ARRAY
77095: PPUSH
77096: CALL_OW 256
77100: PUSH
77101: LD_INT 1000
77103: EQUAL
77104: PUSH
77105: LD_VAR 0 4
77109: PUSH
77110: LD_VAR 0 7
77114: ARRAY
77115: PUSH
77116: LD_VAR 0 32
77120: IN
77121: AND
77122: IFFALSE 77146
// to_repair := to_repair diff group [ i ] ;
77124: LD_ADDR_VAR 0 32
77128: PUSH
77129: LD_VAR 0 32
77133: PUSH
77134: LD_VAR 0 4
77138: PUSH
77139: LD_VAR 0 7
77143: ARRAY
77144: DIFF
77145: ST_TO_ADDR
// if group [ i ] in to_repair then
77146: LD_VAR 0 4
77150: PUSH
77151: LD_VAR 0 7
77155: ARRAY
77156: PUSH
77157: LD_VAR 0 32
77161: IN
77162: IFFALSE 77209
// begin if not IsInArea ( group [ i ] , f_repair ) then
77164: LD_VAR 0 4
77168: PUSH
77169: LD_VAR 0 7
77173: ARRAY
77174: PPUSH
77175: LD_VAR 0 22
77179: PPUSH
77180: CALL_OW 308
77184: NOT
77185: IFFALSE 77207
// ComMoveToArea ( group [ i ] , f_repair ) ;
77187: LD_VAR 0 4
77191: PUSH
77192: LD_VAR 0 7
77196: ARRAY
77197: PPUSH
77198: LD_VAR 0 22
77202: PPUSH
77203: CALL_OW 113
// continue ;
77207: GO 76834
// end ; end else
77209: GO 77489
// if group [ i ] in repairs then
77211: LD_VAR 0 4
77215: PUSH
77216: LD_VAR 0 7
77220: ARRAY
77221: PUSH
77222: LD_VAR 0 33
77226: IN
77227: IFFALSE 77489
// begin if IsInUnit ( group [ i ] ) then
77229: LD_VAR 0 4
77233: PUSH
77234: LD_VAR 0 7
77238: ARRAY
77239: PPUSH
77240: CALL_OW 310
77244: IFFALSE 77312
// begin z := IsInUnit ( group [ i ] ) ;
77246: LD_ADDR_VAR 0 13
77250: PUSH
77251: LD_VAR 0 4
77255: PUSH
77256: LD_VAR 0 7
77260: ARRAY
77261: PPUSH
77262: CALL_OW 310
77266: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
77267: LD_VAR 0 13
77271: PUSH
77272: LD_VAR 0 32
77276: IN
77277: PUSH
77278: LD_VAR 0 13
77282: PPUSH
77283: LD_VAR 0 22
77287: PPUSH
77288: CALL_OW 308
77292: AND
77293: IFFALSE 77310
// ComExitVehicle ( group [ i ] ) ;
77295: LD_VAR 0 4
77299: PUSH
77300: LD_VAR 0 7
77304: ARRAY
77305: PPUSH
77306: CALL_OW 121
// end else
77310: GO 77489
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
77312: LD_ADDR_VAR 0 13
77316: PUSH
77317: LD_VAR 0 4
77321: PPUSH
77322: LD_INT 95
77324: PUSH
77325: LD_VAR 0 22
77329: PUSH
77330: EMPTY
77331: LIST
77332: LIST
77333: PUSH
77334: LD_INT 58
77336: PUSH
77337: EMPTY
77338: LIST
77339: PUSH
77340: EMPTY
77341: LIST
77342: LIST
77343: PPUSH
77344: CALL_OW 72
77348: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
77349: LD_VAR 0 4
77353: PUSH
77354: LD_VAR 0 7
77358: ARRAY
77359: PPUSH
77360: CALL_OW 314
77364: NOT
77365: IFFALSE 77487
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
77367: LD_ADDR_VAR 0 10
77371: PUSH
77372: LD_VAR 0 13
77376: PPUSH
77377: LD_VAR 0 4
77381: PUSH
77382: LD_VAR 0 7
77386: ARRAY
77387: PPUSH
77388: CALL_OW 74
77392: ST_TO_ADDR
// if not x then
77393: LD_VAR 0 10
77397: NOT
77398: IFFALSE 77402
// continue ;
77400: GO 76834
// if GetLives ( x ) < 1000 then
77402: LD_VAR 0 10
77406: PPUSH
77407: CALL_OW 256
77411: PUSH
77412: LD_INT 1000
77414: LESS
77415: IFFALSE 77439
// ComRepairVehicle ( group [ i ] , x ) else
77417: LD_VAR 0 4
77421: PUSH
77422: LD_VAR 0 7
77426: ARRAY
77427: PPUSH
77428: LD_VAR 0 10
77432: PPUSH
77433: CALL_OW 129
77437: GO 77487
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
77439: LD_VAR 0 23
77443: PUSH
77444: LD_VAR 0 4
77448: PUSH
77449: LD_VAR 0 7
77453: ARRAY
77454: PPUSH
77455: CALL_OW 256
77459: PUSH
77460: LD_INT 1000
77462: LESS
77463: AND
77464: NOT
77465: IFFALSE 77487
// ComEnterUnit ( group [ i ] , x ) ;
77467: LD_VAR 0 4
77471: PUSH
77472: LD_VAR 0 7
77476: ARRAY
77477: PPUSH
77478: LD_VAR 0 10
77482: PPUSH
77483: CALL_OW 120
// end ; continue ;
77487: GO 76834
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
77489: LD_VAR 0 23
77493: PUSH
77494: LD_VAR 0 4
77498: PUSH
77499: LD_VAR 0 7
77503: ARRAY
77504: PPUSH
77505: CALL_OW 247
77509: PUSH
77510: LD_INT 1
77512: EQUAL
77513: AND
77514: IFFALSE 77992
// begin if group [ i ] in healers then
77516: LD_VAR 0 4
77520: PUSH
77521: LD_VAR 0 7
77525: ARRAY
77526: PUSH
77527: LD_VAR 0 31
77531: IN
77532: IFFALSE 77805
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
77534: LD_VAR 0 4
77538: PUSH
77539: LD_VAR 0 7
77543: ARRAY
77544: PPUSH
77545: LD_VAR 0 23
77549: PPUSH
77550: CALL_OW 308
77554: NOT
77555: PUSH
77556: LD_VAR 0 4
77560: PUSH
77561: LD_VAR 0 7
77565: ARRAY
77566: PPUSH
77567: CALL_OW 314
77571: NOT
77572: AND
77573: IFFALSE 77597
// ComMoveToArea ( group [ i ] , f_heal ) else
77575: LD_VAR 0 4
77579: PUSH
77580: LD_VAR 0 7
77584: ARRAY
77585: PPUSH
77586: LD_VAR 0 23
77590: PPUSH
77591: CALL_OW 113
77595: GO 77803
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
77597: LD_VAR 0 4
77601: PUSH
77602: LD_VAR 0 7
77606: ARRAY
77607: PPUSH
77608: CALL 53290 0 1
77612: PPUSH
77613: CALL_OW 256
77617: PUSH
77618: LD_INT 1000
77620: EQUAL
77621: IFFALSE 77640
// ComStop ( group [ i ] ) else
77623: LD_VAR 0 4
77627: PUSH
77628: LD_VAR 0 7
77632: ARRAY
77633: PPUSH
77634: CALL_OW 141
77638: GO 77803
// if not HasTask ( group [ i ] ) and to_heal then
77640: LD_VAR 0 4
77644: PUSH
77645: LD_VAR 0 7
77649: ARRAY
77650: PPUSH
77651: CALL_OW 314
77655: NOT
77656: PUSH
77657: LD_VAR 0 30
77661: AND
77662: IFFALSE 77803
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
77664: LD_ADDR_VAR 0 13
77668: PUSH
77669: LD_VAR 0 30
77673: PPUSH
77674: LD_INT 3
77676: PUSH
77677: LD_INT 54
77679: PUSH
77680: EMPTY
77681: LIST
77682: PUSH
77683: EMPTY
77684: LIST
77685: LIST
77686: PPUSH
77687: CALL_OW 72
77691: PPUSH
77692: LD_VAR 0 4
77696: PUSH
77697: LD_VAR 0 7
77701: ARRAY
77702: PPUSH
77703: CALL_OW 74
77707: ST_TO_ADDR
// if z then
77708: LD_VAR 0 13
77712: IFFALSE 77803
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
77714: LD_INT 91
77716: PUSH
77717: LD_VAR 0 13
77721: PUSH
77722: LD_INT 10
77724: PUSH
77725: EMPTY
77726: LIST
77727: LIST
77728: LIST
77729: PUSH
77730: LD_INT 81
77732: PUSH
77733: LD_VAR 0 13
77737: PPUSH
77738: CALL_OW 255
77742: PUSH
77743: EMPTY
77744: LIST
77745: LIST
77746: PUSH
77747: EMPTY
77748: LIST
77749: LIST
77750: PPUSH
77751: CALL_OW 69
77755: PUSH
77756: LD_INT 0
77758: EQUAL
77759: IFFALSE 77783
// ComHeal ( group [ i ] , z ) else
77761: LD_VAR 0 4
77765: PUSH
77766: LD_VAR 0 7
77770: ARRAY
77771: PPUSH
77772: LD_VAR 0 13
77776: PPUSH
77777: CALL_OW 128
77781: GO 77803
// ComMoveToArea ( group [ i ] , f_heal ) ;
77783: LD_VAR 0 4
77787: PUSH
77788: LD_VAR 0 7
77792: ARRAY
77793: PPUSH
77794: LD_VAR 0 23
77798: PPUSH
77799: CALL_OW 113
// end ; continue ;
77803: GO 76834
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
77805: LD_VAR 0 4
77809: PUSH
77810: LD_VAR 0 7
77814: ARRAY
77815: PPUSH
77816: CALL_OW 256
77820: PUSH
77821: LD_INT 700
77823: LESS
77824: PUSH
77825: LD_VAR 0 4
77829: PUSH
77830: LD_VAR 0 7
77834: ARRAY
77835: PUSH
77836: LD_VAR 0 30
77840: IN
77841: NOT
77842: AND
77843: IFFALSE 77867
// to_heal := to_heal union group [ i ] ;
77845: LD_ADDR_VAR 0 30
77849: PUSH
77850: LD_VAR 0 30
77854: PUSH
77855: LD_VAR 0 4
77859: PUSH
77860: LD_VAR 0 7
77864: ARRAY
77865: UNION
77866: ST_TO_ADDR
// if group [ i ] in to_heal then
77867: LD_VAR 0 4
77871: PUSH
77872: LD_VAR 0 7
77876: ARRAY
77877: PUSH
77878: LD_VAR 0 30
77882: IN
77883: IFFALSE 77992
// begin if GetLives ( group [ i ] ) = 1000 then
77885: LD_VAR 0 4
77889: PUSH
77890: LD_VAR 0 7
77894: ARRAY
77895: PPUSH
77896: CALL_OW 256
77900: PUSH
77901: LD_INT 1000
77903: EQUAL
77904: IFFALSE 77930
// to_heal := to_heal diff group [ i ] else
77906: LD_ADDR_VAR 0 30
77910: PUSH
77911: LD_VAR 0 30
77915: PUSH
77916: LD_VAR 0 4
77920: PUSH
77921: LD_VAR 0 7
77925: ARRAY
77926: DIFF
77927: ST_TO_ADDR
77928: GO 77992
// begin if not IsInArea ( group [ i ] , to_heal ) then
77930: LD_VAR 0 4
77934: PUSH
77935: LD_VAR 0 7
77939: ARRAY
77940: PPUSH
77941: LD_VAR 0 30
77945: PPUSH
77946: CALL_OW 308
77950: NOT
77951: IFFALSE 77975
// ComMoveToArea ( group [ i ] , f_heal ) else
77953: LD_VAR 0 4
77957: PUSH
77958: LD_VAR 0 7
77962: ARRAY
77963: PPUSH
77964: LD_VAR 0 23
77968: PPUSH
77969: CALL_OW 113
77973: GO 77990
// ComHold ( group [ i ] ) ;
77975: LD_VAR 0 4
77979: PUSH
77980: LD_VAR 0 7
77984: ARRAY
77985: PPUSH
77986: CALL_OW 140
// continue ;
77990: GO 76834
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
77992: LD_VAR 0 4
77996: PUSH
77997: LD_VAR 0 7
78001: ARRAY
78002: PPUSH
78003: LD_INT 10
78005: PPUSH
78006: CALL 51710 0 2
78010: NOT
78011: PUSH
78012: LD_VAR 0 16
78016: PUSH
78017: LD_VAR 0 7
78021: ARRAY
78022: PUSH
78023: EMPTY
78024: EQUAL
78025: NOT
78026: AND
78027: IFFALSE 78293
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
78029: LD_VAR 0 4
78033: PUSH
78034: LD_VAR 0 7
78038: ARRAY
78039: PPUSH
78040: CALL_OW 262
78044: PUSH
78045: LD_INT 1
78047: PUSH
78048: LD_INT 2
78050: PUSH
78051: EMPTY
78052: LIST
78053: LIST
78054: IN
78055: IFFALSE 78096
// if GetFuel ( group [ i ] ) < 10 then
78057: LD_VAR 0 4
78061: PUSH
78062: LD_VAR 0 7
78066: ARRAY
78067: PPUSH
78068: CALL_OW 261
78072: PUSH
78073: LD_INT 10
78075: LESS
78076: IFFALSE 78096
// SetFuel ( group [ i ] , 12 ) ;
78078: LD_VAR 0 4
78082: PUSH
78083: LD_VAR 0 7
78087: ARRAY
78088: PPUSH
78089: LD_INT 12
78091: PPUSH
78092: CALL_OW 240
// if units_path [ i ] then
78096: LD_VAR 0 16
78100: PUSH
78101: LD_VAR 0 7
78105: ARRAY
78106: IFFALSE 78291
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
78108: LD_VAR 0 4
78112: PUSH
78113: LD_VAR 0 7
78117: ARRAY
78118: PPUSH
78119: LD_VAR 0 16
78123: PUSH
78124: LD_VAR 0 7
78128: ARRAY
78129: PUSH
78130: LD_INT 1
78132: ARRAY
78133: PUSH
78134: LD_INT 1
78136: ARRAY
78137: PPUSH
78138: LD_VAR 0 16
78142: PUSH
78143: LD_VAR 0 7
78147: ARRAY
78148: PUSH
78149: LD_INT 1
78151: ARRAY
78152: PUSH
78153: LD_INT 2
78155: ARRAY
78156: PPUSH
78157: CALL_OW 297
78161: PUSH
78162: LD_INT 6
78164: GREATER
78165: IFFALSE 78240
// begin if not HasTask ( group [ i ] ) then
78167: LD_VAR 0 4
78171: PUSH
78172: LD_VAR 0 7
78176: ARRAY
78177: PPUSH
78178: CALL_OW 314
78182: NOT
78183: IFFALSE 78238
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
78185: LD_VAR 0 4
78189: PUSH
78190: LD_VAR 0 7
78194: ARRAY
78195: PPUSH
78196: LD_VAR 0 16
78200: PUSH
78201: LD_VAR 0 7
78205: ARRAY
78206: PUSH
78207: LD_INT 1
78209: ARRAY
78210: PUSH
78211: LD_INT 1
78213: ARRAY
78214: PPUSH
78215: LD_VAR 0 16
78219: PUSH
78220: LD_VAR 0 7
78224: ARRAY
78225: PUSH
78226: LD_INT 1
78228: ARRAY
78229: PUSH
78230: LD_INT 2
78232: ARRAY
78233: PPUSH
78234: CALL_OW 114
// end else
78238: GO 78291
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
78240: LD_ADDR_VAR 0 15
78244: PUSH
78245: LD_VAR 0 16
78249: PUSH
78250: LD_VAR 0 7
78254: ARRAY
78255: PPUSH
78256: LD_INT 1
78258: PPUSH
78259: CALL_OW 3
78263: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
78264: LD_ADDR_VAR 0 16
78268: PUSH
78269: LD_VAR 0 16
78273: PPUSH
78274: LD_VAR 0 7
78278: PPUSH
78279: LD_VAR 0 15
78283: PPUSH
78284: CALL_OW 1
78288: ST_TO_ADDR
// continue ;
78289: GO 76834
// end ; end ; end else
78291: GO 80955
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
78293: LD_ADDR_VAR 0 14
78297: PUSH
78298: LD_INT 81
78300: PUSH
78301: LD_VAR 0 4
78305: PUSH
78306: LD_VAR 0 7
78310: ARRAY
78311: PPUSH
78312: CALL_OW 255
78316: PUSH
78317: EMPTY
78318: LIST
78319: LIST
78320: PPUSH
78321: CALL_OW 69
78325: ST_TO_ADDR
// if not tmp then
78326: LD_VAR 0 14
78330: NOT
78331: IFFALSE 78335
// continue ;
78333: GO 76834
// if f_ignore_area then
78335: LD_VAR 0 17
78339: IFFALSE 78427
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
78341: LD_ADDR_VAR 0 15
78345: PUSH
78346: LD_VAR 0 14
78350: PPUSH
78351: LD_INT 3
78353: PUSH
78354: LD_INT 92
78356: PUSH
78357: LD_VAR 0 17
78361: PUSH
78362: LD_INT 1
78364: ARRAY
78365: PUSH
78366: LD_VAR 0 17
78370: PUSH
78371: LD_INT 2
78373: ARRAY
78374: PUSH
78375: LD_VAR 0 17
78379: PUSH
78380: LD_INT 3
78382: ARRAY
78383: PUSH
78384: EMPTY
78385: LIST
78386: LIST
78387: LIST
78388: LIST
78389: PUSH
78390: EMPTY
78391: LIST
78392: LIST
78393: PPUSH
78394: CALL_OW 72
78398: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
78399: LD_VAR 0 14
78403: PUSH
78404: LD_VAR 0 15
78408: DIFF
78409: IFFALSE 78427
// tmp := tmp diff tmp2 ;
78411: LD_ADDR_VAR 0 14
78415: PUSH
78416: LD_VAR 0 14
78420: PUSH
78421: LD_VAR 0 15
78425: DIFF
78426: ST_TO_ADDR
// end ; if not f_murder then
78427: LD_VAR 0 20
78431: NOT
78432: IFFALSE 78490
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
78434: LD_ADDR_VAR 0 15
78438: PUSH
78439: LD_VAR 0 14
78443: PPUSH
78444: LD_INT 3
78446: PUSH
78447: LD_INT 50
78449: PUSH
78450: EMPTY
78451: LIST
78452: PUSH
78453: EMPTY
78454: LIST
78455: LIST
78456: PPUSH
78457: CALL_OW 72
78461: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
78462: LD_VAR 0 14
78466: PUSH
78467: LD_VAR 0 15
78471: DIFF
78472: IFFALSE 78490
// tmp := tmp diff tmp2 ;
78474: LD_ADDR_VAR 0 14
78478: PUSH
78479: LD_VAR 0 14
78483: PUSH
78484: LD_VAR 0 15
78488: DIFF
78489: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
78490: LD_ADDR_VAR 0 14
78494: PUSH
78495: LD_VAR 0 4
78499: PUSH
78500: LD_VAR 0 7
78504: ARRAY
78505: PPUSH
78506: LD_VAR 0 14
78510: PPUSH
78511: LD_INT 1
78513: PPUSH
78514: LD_INT 1
78516: PPUSH
78517: CALL 24645 0 4
78521: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
78522: LD_VAR 0 4
78526: PUSH
78527: LD_VAR 0 7
78531: ARRAY
78532: PPUSH
78533: CALL_OW 257
78537: PUSH
78538: LD_INT 1
78540: EQUAL
78541: IFFALSE 78989
// begin if WantPlant ( group [ i ] ) then
78543: LD_VAR 0 4
78547: PUSH
78548: LD_VAR 0 7
78552: ARRAY
78553: PPUSH
78554: CALL 24146 0 1
78558: IFFALSE 78562
// continue ;
78560: GO 76834
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
78562: LD_VAR 0 18
78566: PUSH
78567: LD_VAR 0 4
78571: PUSH
78572: LD_VAR 0 7
78576: ARRAY
78577: PPUSH
78578: CALL_OW 310
78582: NOT
78583: AND
78584: PUSH
78585: LD_VAR 0 14
78589: PUSH
78590: LD_INT 1
78592: ARRAY
78593: PUSH
78594: LD_VAR 0 14
78598: PPUSH
78599: LD_INT 21
78601: PUSH
78602: LD_INT 2
78604: PUSH
78605: EMPTY
78606: LIST
78607: LIST
78608: PUSH
78609: LD_INT 58
78611: PUSH
78612: EMPTY
78613: LIST
78614: PUSH
78615: EMPTY
78616: LIST
78617: LIST
78618: PPUSH
78619: CALL_OW 72
78623: IN
78624: AND
78625: IFFALSE 78661
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
78627: LD_VAR 0 4
78631: PUSH
78632: LD_VAR 0 7
78636: ARRAY
78637: PPUSH
78638: LD_VAR 0 14
78642: PUSH
78643: LD_INT 1
78645: ARRAY
78646: PPUSH
78647: CALL_OW 120
// attacking := true ;
78651: LD_ADDR_VAR 0 29
78655: PUSH
78656: LD_INT 1
78658: ST_TO_ADDR
// continue ;
78659: GO 76834
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
78661: LD_VAR 0 26
78665: PUSH
78666: LD_VAR 0 4
78670: PUSH
78671: LD_VAR 0 7
78675: ARRAY
78676: PPUSH
78677: CALL_OW 257
78681: PUSH
78682: LD_INT 1
78684: EQUAL
78685: AND
78686: PUSH
78687: LD_VAR 0 4
78691: PUSH
78692: LD_VAR 0 7
78696: ARRAY
78697: PPUSH
78698: CALL_OW 256
78702: PUSH
78703: LD_INT 800
78705: LESS
78706: AND
78707: PUSH
78708: LD_VAR 0 4
78712: PUSH
78713: LD_VAR 0 7
78717: ARRAY
78718: PPUSH
78719: CALL_OW 318
78723: NOT
78724: AND
78725: IFFALSE 78742
// ComCrawl ( group [ i ] ) ;
78727: LD_VAR 0 4
78731: PUSH
78732: LD_VAR 0 7
78736: ARRAY
78737: PPUSH
78738: CALL_OW 137
// if f_mines then
78742: LD_VAR 0 21
78746: IFFALSE 78989
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
78748: LD_VAR 0 14
78752: PUSH
78753: LD_INT 1
78755: ARRAY
78756: PPUSH
78757: CALL_OW 247
78761: PUSH
78762: LD_INT 3
78764: EQUAL
78765: PUSH
78766: LD_VAR 0 14
78770: PUSH
78771: LD_INT 1
78773: ARRAY
78774: PUSH
78775: LD_VAR 0 27
78779: IN
78780: NOT
78781: AND
78782: IFFALSE 78989
// begin x := GetX ( tmp [ 1 ] ) ;
78784: LD_ADDR_VAR 0 10
78788: PUSH
78789: LD_VAR 0 14
78793: PUSH
78794: LD_INT 1
78796: ARRAY
78797: PPUSH
78798: CALL_OW 250
78802: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
78803: LD_ADDR_VAR 0 11
78807: PUSH
78808: LD_VAR 0 14
78812: PUSH
78813: LD_INT 1
78815: ARRAY
78816: PPUSH
78817: CALL_OW 251
78821: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
78822: LD_ADDR_VAR 0 12
78826: PUSH
78827: LD_VAR 0 4
78831: PUSH
78832: LD_VAR 0 7
78836: ARRAY
78837: PPUSH
78838: CALL 51795 0 1
78842: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
78843: LD_VAR 0 4
78847: PUSH
78848: LD_VAR 0 7
78852: ARRAY
78853: PPUSH
78854: LD_VAR 0 10
78858: PPUSH
78859: LD_VAR 0 11
78863: PPUSH
78864: LD_VAR 0 14
78868: PUSH
78869: LD_INT 1
78871: ARRAY
78872: PPUSH
78873: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
78877: LD_VAR 0 4
78881: PUSH
78882: LD_VAR 0 7
78886: ARRAY
78887: PPUSH
78888: LD_VAR 0 10
78892: PPUSH
78893: LD_VAR 0 12
78897: PPUSH
78898: LD_INT 7
78900: PPUSH
78901: CALL_OW 272
78905: PPUSH
78906: LD_VAR 0 11
78910: PPUSH
78911: LD_VAR 0 12
78915: PPUSH
78916: LD_INT 7
78918: PPUSH
78919: CALL_OW 273
78923: PPUSH
78924: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
78928: LD_VAR 0 4
78932: PUSH
78933: LD_VAR 0 7
78937: ARRAY
78938: PPUSH
78939: LD_INT 71
78941: PPUSH
78942: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
78946: LD_ADDR_VAR 0 27
78950: PUSH
78951: LD_VAR 0 27
78955: PPUSH
78956: LD_VAR 0 27
78960: PUSH
78961: LD_INT 1
78963: PLUS
78964: PPUSH
78965: LD_VAR 0 14
78969: PUSH
78970: LD_INT 1
78972: ARRAY
78973: PPUSH
78974: CALL_OW 1
78978: ST_TO_ADDR
// attacking := true ;
78979: LD_ADDR_VAR 0 29
78983: PUSH
78984: LD_INT 1
78986: ST_TO_ADDR
// continue ;
78987: GO 76834
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
78989: LD_VAR 0 4
78993: PUSH
78994: LD_VAR 0 7
78998: ARRAY
78999: PPUSH
79000: CALL_OW 257
79004: PUSH
79005: LD_INT 17
79007: EQUAL
79008: PUSH
79009: LD_VAR 0 4
79013: PUSH
79014: LD_VAR 0 7
79018: ARRAY
79019: PPUSH
79020: CALL_OW 110
79024: PUSH
79025: LD_INT 71
79027: EQUAL
79028: NOT
79029: AND
79030: IFFALSE 79176
// begin attacking := false ;
79032: LD_ADDR_VAR 0 29
79036: PUSH
79037: LD_INT 0
79039: ST_TO_ADDR
// k := 5 ;
79040: LD_ADDR_VAR 0 9
79044: PUSH
79045: LD_INT 5
79047: ST_TO_ADDR
// if tmp < k then
79048: LD_VAR 0 14
79052: PUSH
79053: LD_VAR 0 9
79057: LESS
79058: IFFALSE 79070
// k := tmp ;
79060: LD_ADDR_VAR 0 9
79064: PUSH
79065: LD_VAR 0 14
79069: ST_TO_ADDR
// for j = 1 to k do
79070: LD_ADDR_VAR 0 8
79074: PUSH
79075: DOUBLE
79076: LD_INT 1
79078: DEC
79079: ST_TO_ADDR
79080: LD_VAR 0 9
79084: PUSH
79085: FOR_TO
79086: IFFALSE 79174
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
79088: LD_VAR 0 14
79092: PUSH
79093: LD_VAR 0 8
79097: ARRAY
79098: PUSH
79099: LD_VAR 0 14
79103: PPUSH
79104: LD_INT 58
79106: PUSH
79107: EMPTY
79108: LIST
79109: PPUSH
79110: CALL_OW 72
79114: IN
79115: NOT
79116: IFFALSE 79172
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
79118: LD_VAR 0 4
79122: PUSH
79123: LD_VAR 0 7
79127: ARRAY
79128: PPUSH
79129: LD_VAR 0 14
79133: PUSH
79134: LD_VAR 0 8
79138: ARRAY
79139: PPUSH
79140: CALL_OW 115
// attacking := true ;
79144: LD_ADDR_VAR 0 29
79148: PUSH
79149: LD_INT 1
79151: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
79152: LD_VAR 0 4
79156: PUSH
79157: LD_VAR 0 7
79161: ARRAY
79162: PPUSH
79163: LD_INT 71
79165: PPUSH
79166: CALL_OW 109
// continue ;
79170: GO 79085
// end ; end ;
79172: GO 79085
79174: POP
79175: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
79176: LD_VAR 0 4
79180: PUSH
79181: LD_VAR 0 7
79185: ARRAY
79186: PPUSH
79187: CALL_OW 257
79191: PUSH
79192: LD_INT 8
79194: EQUAL
79195: PUSH
79196: LD_VAR 0 4
79200: PUSH
79201: LD_VAR 0 7
79205: ARRAY
79206: PPUSH
79207: CALL_OW 264
79211: PUSH
79212: LD_INT 28
79214: PUSH
79215: LD_INT 45
79217: PUSH
79218: LD_INT 7
79220: PUSH
79221: LD_INT 47
79223: PUSH
79224: EMPTY
79225: LIST
79226: LIST
79227: LIST
79228: LIST
79229: IN
79230: OR
79231: IFFALSE 79487
// begin attacking := false ;
79233: LD_ADDR_VAR 0 29
79237: PUSH
79238: LD_INT 0
79240: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
79241: LD_VAR 0 14
79245: PUSH
79246: LD_INT 1
79248: ARRAY
79249: PPUSH
79250: CALL_OW 266
79254: PUSH
79255: LD_INT 32
79257: PUSH
79258: LD_INT 31
79260: PUSH
79261: LD_INT 33
79263: PUSH
79264: LD_INT 4
79266: PUSH
79267: LD_INT 5
79269: PUSH
79270: EMPTY
79271: LIST
79272: LIST
79273: LIST
79274: LIST
79275: LIST
79276: IN
79277: IFFALSE 79463
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
79279: LD_ADDR_VAR 0 9
79283: PUSH
79284: LD_VAR 0 14
79288: PUSH
79289: LD_INT 1
79291: ARRAY
79292: PPUSH
79293: CALL_OW 266
79297: PPUSH
79298: LD_VAR 0 14
79302: PUSH
79303: LD_INT 1
79305: ARRAY
79306: PPUSH
79307: CALL_OW 250
79311: PPUSH
79312: LD_VAR 0 14
79316: PUSH
79317: LD_INT 1
79319: ARRAY
79320: PPUSH
79321: CALL_OW 251
79325: PPUSH
79326: LD_VAR 0 14
79330: PUSH
79331: LD_INT 1
79333: ARRAY
79334: PPUSH
79335: CALL_OW 254
79339: PPUSH
79340: LD_VAR 0 14
79344: PUSH
79345: LD_INT 1
79347: ARRAY
79348: PPUSH
79349: CALL_OW 248
79353: PPUSH
79354: LD_INT 0
79356: PPUSH
79357: CALL 33165 0 6
79361: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
79362: LD_ADDR_VAR 0 8
79366: PUSH
79367: LD_VAR 0 4
79371: PUSH
79372: LD_VAR 0 7
79376: ARRAY
79377: PPUSH
79378: LD_VAR 0 9
79382: PPUSH
79383: CALL 51835 0 2
79387: ST_TO_ADDR
// if j then
79388: LD_VAR 0 8
79392: IFFALSE 79461
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
79394: LD_VAR 0 8
79398: PUSH
79399: LD_INT 1
79401: ARRAY
79402: PPUSH
79403: LD_VAR 0 8
79407: PUSH
79408: LD_INT 2
79410: ARRAY
79411: PPUSH
79412: CALL_OW 488
79416: IFFALSE 79461
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
79418: LD_VAR 0 4
79422: PUSH
79423: LD_VAR 0 7
79427: ARRAY
79428: PPUSH
79429: LD_VAR 0 8
79433: PUSH
79434: LD_INT 1
79436: ARRAY
79437: PPUSH
79438: LD_VAR 0 8
79442: PUSH
79443: LD_INT 2
79445: ARRAY
79446: PPUSH
79447: CALL_OW 116
// attacking := true ;
79451: LD_ADDR_VAR 0 29
79455: PUSH
79456: LD_INT 1
79458: ST_TO_ADDR
// continue ;
79459: GO 76834
// end ; end else
79461: GO 79487
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
79463: LD_VAR 0 4
79467: PUSH
79468: LD_VAR 0 7
79472: ARRAY
79473: PPUSH
79474: LD_VAR 0 14
79478: PUSH
79479: LD_INT 1
79481: ARRAY
79482: PPUSH
79483: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
79487: LD_VAR 0 4
79491: PUSH
79492: LD_VAR 0 7
79496: ARRAY
79497: PPUSH
79498: CALL_OW 265
79502: PUSH
79503: LD_INT 11
79505: EQUAL
79506: IFFALSE 79784
// begin k := 10 ;
79508: LD_ADDR_VAR 0 9
79512: PUSH
79513: LD_INT 10
79515: ST_TO_ADDR
// x := 0 ;
79516: LD_ADDR_VAR 0 10
79520: PUSH
79521: LD_INT 0
79523: ST_TO_ADDR
// if tmp < k then
79524: LD_VAR 0 14
79528: PUSH
79529: LD_VAR 0 9
79533: LESS
79534: IFFALSE 79546
// k := tmp ;
79536: LD_ADDR_VAR 0 9
79540: PUSH
79541: LD_VAR 0 14
79545: ST_TO_ADDR
// for j = k downto 1 do
79546: LD_ADDR_VAR 0 8
79550: PUSH
79551: DOUBLE
79552: LD_VAR 0 9
79556: INC
79557: ST_TO_ADDR
79558: LD_INT 1
79560: PUSH
79561: FOR_DOWNTO
79562: IFFALSE 79637
// begin if GetType ( tmp [ j ] ) = unit_human then
79564: LD_VAR 0 14
79568: PUSH
79569: LD_VAR 0 8
79573: ARRAY
79574: PPUSH
79575: CALL_OW 247
79579: PUSH
79580: LD_INT 1
79582: EQUAL
79583: IFFALSE 79635
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
79585: LD_VAR 0 4
79589: PUSH
79590: LD_VAR 0 7
79594: ARRAY
79595: PPUSH
79596: LD_VAR 0 14
79600: PUSH
79601: LD_VAR 0 8
79605: ARRAY
79606: PPUSH
79607: CALL 52106 0 2
// x := tmp [ j ] ;
79611: LD_ADDR_VAR 0 10
79615: PUSH
79616: LD_VAR 0 14
79620: PUSH
79621: LD_VAR 0 8
79625: ARRAY
79626: ST_TO_ADDR
// attacking := true ;
79627: LD_ADDR_VAR 0 29
79631: PUSH
79632: LD_INT 1
79634: ST_TO_ADDR
// end ; end ;
79635: GO 79561
79637: POP
79638: POP
// if not x then
79639: LD_VAR 0 10
79643: NOT
79644: IFFALSE 79784
// begin attacking := true ;
79646: LD_ADDR_VAR 0 29
79650: PUSH
79651: LD_INT 1
79653: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
79654: LD_VAR 0 4
79658: PUSH
79659: LD_VAR 0 7
79663: ARRAY
79664: PPUSH
79665: CALL_OW 250
79669: PPUSH
79670: LD_VAR 0 4
79674: PUSH
79675: LD_VAR 0 7
79679: ARRAY
79680: PPUSH
79681: CALL_OW 251
79685: PPUSH
79686: CALL_OW 546
79690: PUSH
79691: LD_INT 2
79693: ARRAY
79694: PUSH
79695: LD_VAR 0 14
79699: PUSH
79700: LD_INT 1
79702: ARRAY
79703: PPUSH
79704: CALL_OW 250
79708: PPUSH
79709: LD_VAR 0 14
79713: PUSH
79714: LD_INT 1
79716: ARRAY
79717: PPUSH
79718: CALL_OW 251
79722: PPUSH
79723: CALL_OW 546
79727: PUSH
79728: LD_INT 2
79730: ARRAY
79731: EQUAL
79732: IFFALSE 79760
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
79734: LD_VAR 0 4
79738: PUSH
79739: LD_VAR 0 7
79743: ARRAY
79744: PPUSH
79745: LD_VAR 0 14
79749: PUSH
79750: LD_INT 1
79752: ARRAY
79753: PPUSH
79754: CALL 52106 0 2
79758: GO 79784
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
79760: LD_VAR 0 4
79764: PUSH
79765: LD_VAR 0 7
79769: ARRAY
79770: PPUSH
79771: LD_VAR 0 14
79775: PUSH
79776: LD_INT 1
79778: ARRAY
79779: PPUSH
79780: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
79784: LD_VAR 0 4
79788: PUSH
79789: LD_VAR 0 7
79793: ARRAY
79794: PPUSH
79795: CALL_OW 264
79799: PUSH
79800: LD_INT 29
79802: EQUAL
79803: IFFALSE 80169
// begin if WantsToAttack ( group [ i ] ) in bombed then
79805: LD_VAR 0 4
79809: PUSH
79810: LD_VAR 0 7
79814: ARRAY
79815: PPUSH
79816: CALL_OW 319
79820: PUSH
79821: LD_VAR 0 28
79825: IN
79826: IFFALSE 79830
// continue ;
79828: GO 76834
// k := 8 ;
79830: LD_ADDR_VAR 0 9
79834: PUSH
79835: LD_INT 8
79837: ST_TO_ADDR
// x := 0 ;
79838: LD_ADDR_VAR 0 10
79842: PUSH
79843: LD_INT 0
79845: ST_TO_ADDR
// if tmp < k then
79846: LD_VAR 0 14
79850: PUSH
79851: LD_VAR 0 9
79855: LESS
79856: IFFALSE 79868
// k := tmp ;
79858: LD_ADDR_VAR 0 9
79862: PUSH
79863: LD_VAR 0 14
79867: ST_TO_ADDR
// for j = 1 to k do
79868: LD_ADDR_VAR 0 8
79872: PUSH
79873: DOUBLE
79874: LD_INT 1
79876: DEC
79877: ST_TO_ADDR
79878: LD_VAR 0 9
79882: PUSH
79883: FOR_TO
79884: IFFALSE 80016
// begin if GetType ( tmp [ j ] ) = unit_building then
79886: LD_VAR 0 14
79890: PUSH
79891: LD_VAR 0 8
79895: ARRAY
79896: PPUSH
79897: CALL_OW 247
79901: PUSH
79902: LD_INT 3
79904: EQUAL
79905: IFFALSE 80014
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
79907: LD_VAR 0 14
79911: PUSH
79912: LD_VAR 0 8
79916: ARRAY
79917: PUSH
79918: LD_VAR 0 28
79922: IN
79923: NOT
79924: PUSH
79925: LD_VAR 0 14
79929: PUSH
79930: LD_VAR 0 8
79934: ARRAY
79935: PPUSH
79936: CALL_OW 313
79940: AND
79941: IFFALSE 80014
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
79943: LD_VAR 0 4
79947: PUSH
79948: LD_VAR 0 7
79952: ARRAY
79953: PPUSH
79954: LD_VAR 0 14
79958: PUSH
79959: LD_VAR 0 8
79963: ARRAY
79964: PPUSH
79965: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
79969: LD_ADDR_VAR 0 28
79973: PUSH
79974: LD_VAR 0 28
79978: PPUSH
79979: LD_VAR 0 28
79983: PUSH
79984: LD_INT 1
79986: PLUS
79987: PPUSH
79988: LD_VAR 0 14
79992: PUSH
79993: LD_VAR 0 8
79997: ARRAY
79998: PPUSH
79999: CALL_OW 1
80003: ST_TO_ADDR
// attacking := true ;
80004: LD_ADDR_VAR 0 29
80008: PUSH
80009: LD_INT 1
80011: ST_TO_ADDR
// break ;
80012: GO 80016
// end ; end ;
80014: GO 79883
80016: POP
80017: POP
// if not attacking and f_attack_depot then
80018: LD_VAR 0 29
80022: NOT
80023: PUSH
80024: LD_VAR 0 25
80028: AND
80029: IFFALSE 80124
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
80031: LD_ADDR_VAR 0 13
80035: PUSH
80036: LD_VAR 0 14
80040: PPUSH
80041: LD_INT 2
80043: PUSH
80044: LD_INT 30
80046: PUSH
80047: LD_INT 0
80049: PUSH
80050: EMPTY
80051: LIST
80052: LIST
80053: PUSH
80054: LD_INT 30
80056: PUSH
80057: LD_INT 1
80059: PUSH
80060: EMPTY
80061: LIST
80062: LIST
80063: PUSH
80064: EMPTY
80065: LIST
80066: LIST
80067: LIST
80068: PPUSH
80069: CALL_OW 72
80073: ST_TO_ADDR
// if z then
80074: LD_VAR 0 13
80078: IFFALSE 80124
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
80080: LD_VAR 0 4
80084: PUSH
80085: LD_VAR 0 7
80089: ARRAY
80090: PPUSH
80091: LD_VAR 0 13
80095: PPUSH
80096: LD_VAR 0 4
80100: PUSH
80101: LD_VAR 0 7
80105: ARRAY
80106: PPUSH
80107: CALL_OW 74
80111: PPUSH
80112: CALL_OW 115
// attacking := true ;
80116: LD_ADDR_VAR 0 29
80120: PUSH
80121: LD_INT 1
80123: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
80124: LD_VAR 0 4
80128: PUSH
80129: LD_VAR 0 7
80133: ARRAY
80134: PPUSH
80135: CALL_OW 256
80139: PUSH
80140: LD_INT 500
80142: LESS
80143: IFFALSE 80169
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
80145: LD_VAR 0 4
80149: PUSH
80150: LD_VAR 0 7
80154: ARRAY
80155: PPUSH
80156: LD_VAR 0 14
80160: PUSH
80161: LD_INT 1
80163: ARRAY
80164: PPUSH
80165: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
80169: LD_VAR 0 4
80173: PUSH
80174: LD_VAR 0 7
80178: ARRAY
80179: PPUSH
80180: CALL_OW 264
80184: PUSH
80185: LD_INT 49
80187: EQUAL
80188: IFFALSE 80309
// begin if not HasTask ( group [ i ] ) then
80190: LD_VAR 0 4
80194: PUSH
80195: LD_VAR 0 7
80199: ARRAY
80200: PPUSH
80201: CALL_OW 314
80205: NOT
80206: IFFALSE 80309
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
80208: LD_ADDR_VAR 0 9
80212: PUSH
80213: LD_INT 81
80215: PUSH
80216: LD_VAR 0 4
80220: PUSH
80221: LD_VAR 0 7
80225: ARRAY
80226: PPUSH
80227: CALL_OW 255
80231: PUSH
80232: EMPTY
80233: LIST
80234: LIST
80235: PPUSH
80236: CALL_OW 69
80240: PPUSH
80241: LD_VAR 0 4
80245: PUSH
80246: LD_VAR 0 7
80250: ARRAY
80251: PPUSH
80252: CALL_OW 74
80256: ST_TO_ADDR
// if k then
80257: LD_VAR 0 9
80261: IFFALSE 80309
// if GetDistUnits ( group [ i ] , k ) > 10 then
80263: LD_VAR 0 4
80267: PUSH
80268: LD_VAR 0 7
80272: ARRAY
80273: PPUSH
80274: LD_VAR 0 9
80278: PPUSH
80279: CALL_OW 296
80283: PUSH
80284: LD_INT 10
80286: GREATER
80287: IFFALSE 80309
// ComMoveUnit ( group [ i ] , k ) ;
80289: LD_VAR 0 4
80293: PUSH
80294: LD_VAR 0 7
80298: ARRAY
80299: PPUSH
80300: LD_VAR 0 9
80304: PPUSH
80305: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
80309: LD_VAR 0 4
80313: PUSH
80314: LD_VAR 0 7
80318: ARRAY
80319: PPUSH
80320: CALL_OW 256
80324: PUSH
80325: LD_INT 250
80327: LESS
80328: PUSH
80329: LD_VAR 0 4
80333: PUSH
80334: LD_VAR 0 7
80338: ARRAY
80339: PUSH
80340: LD_INT 21
80342: PUSH
80343: LD_INT 2
80345: PUSH
80346: EMPTY
80347: LIST
80348: LIST
80349: PUSH
80350: LD_INT 23
80352: PUSH
80353: LD_INT 2
80355: PUSH
80356: EMPTY
80357: LIST
80358: LIST
80359: PUSH
80360: EMPTY
80361: LIST
80362: LIST
80363: PPUSH
80364: CALL_OW 69
80368: IN
80369: AND
80370: IFFALSE 80495
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
80372: LD_ADDR_VAR 0 9
80376: PUSH
80377: LD_OWVAR 3
80381: PUSH
80382: LD_VAR 0 4
80386: PUSH
80387: LD_VAR 0 7
80391: ARRAY
80392: DIFF
80393: PPUSH
80394: LD_VAR 0 4
80398: PUSH
80399: LD_VAR 0 7
80403: ARRAY
80404: PPUSH
80405: CALL_OW 74
80409: ST_TO_ADDR
// if not k then
80410: LD_VAR 0 9
80414: NOT
80415: IFFALSE 80419
// continue ;
80417: GO 76834
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
80419: LD_VAR 0 9
80423: PUSH
80424: LD_INT 81
80426: PUSH
80427: LD_VAR 0 4
80431: PUSH
80432: LD_VAR 0 7
80436: ARRAY
80437: PPUSH
80438: CALL_OW 255
80442: PUSH
80443: EMPTY
80444: LIST
80445: LIST
80446: PPUSH
80447: CALL_OW 69
80451: IN
80452: PUSH
80453: LD_VAR 0 9
80457: PPUSH
80458: LD_VAR 0 4
80462: PUSH
80463: LD_VAR 0 7
80467: ARRAY
80468: PPUSH
80469: CALL_OW 296
80473: PUSH
80474: LD_INT 5
80476: LESS
80477: AND
80478: IFFALSE 80495
// ComAutodestruct ( group [ i ] ) ;
80480: LD_VAR 0 4
80484: PUSH
80485: LD_VAR 0 7
80489: ARRAY
80490: PPUSH
80491: CALL 52004 0 1
// end ; if f_attack_depot then
80495: LD_VAR 0 25
80499: IFFALSE 80611
// begin k := 6 ;
80501: LD_ADDR_VAR 0 9
80505: PUSH
80506: LD_INT 6
80508: ST_TO_ADDR
// if tmp < k then
80509: LD_VAR 0 14
80513: PUSH
80514: LD_VAR 0 9
80518: LESS
80519: IFFALSE 80531
// k := tmp ;
80521: LD_ADDR_VAR 0 9
80525: PUSH
80526: LD_VAR 0 14
80530: ST_TO_ADDR
// for j = 1 to k do
80531: LD_ADDR_VAR 0 8
80535: PUSH
80536: DOUBLE
80537: LD_INT 1
80539: DEC
80540: ST_TO_ADDR
80541: LD_VAR 0 9
80545: PUSH
80546: FOR_TO
80547: IFFALSE 80609
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
80549: LD_VAR 0 8
80553: PPUSH
80554: CALL_OW 266
80558: PUSH
80559: LD_INT 0
80561: PUSH
80562: LD_INT 1
80564: PUSH
80565: EMPTY
80566: LIST
80567: LIST
80568: IN
80569: IFFALSE 80607
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
80571: LD_VAR 0 4
80575: PUSH
80576: LD_VAR 0 7
80580: ARRAY
80581: PPUSH
80582: LD_VAR 0 14
80586: PUSH
80587: LD_VAR 0 8
80591: ARRAY
80592: PPUSH
80593: CALL_OW 115
// attacking := true ;
80597: LD_ADDR_VAR 0 29
80601: PUSH
80602: LD_INT 1
80604: ST_TO_ADDR
// break ;
80605: GO 80609
// end ;
80607: GO 80546
80609: POP
80610: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
80611: LD_VAR 0 4
80615: PUSH
80616: LD_VAR 0 7
80620: ARRAY
80621: PPUSH
80622: CALL_OW 302
80626: PUSH
80627: LD_VAR 0 29
80631: NOT
80632: AND
80633: IFFALSE 80955
// begin if GetTag ( group [ i ] ) = 71 then
80635: LD_VAR 0 4
80639: PUSH
80640: LD_VAR 0 7
80644: ARRAY
80645: PPUSH
80646: CALL_OW 110
80650: PUSH
80651: LD_INT 71
80653: EQUAL
80654: IFFALSE 80695
// begin if HasTask ( group [ i ] ) then
80656: LD_VAR 0 4
80660: PUSH
80661: LD_VAR 0 7
80665: ARRAY
80666: PPUSH
80667: CALL_OW 314
80671: IFFALSE 80677
// continue else
80673: GO 76834
80675: GO 80695
// SetTag ( group [ i ] , 0 ) ;
80677: LD_VAR 0 4
80681: PUSH
80682: LD_VAR 0 7
80686: ARRAY
80687: PPUSH
80688: LD_INT 0
80690: PPUSH
80691: CALL_OW 109
// end ; k := 8 ;
80695: LD_ADDR_VAR 0 9
80699: PUSH
80700: LD_INT 8
80702: ST_TO_ADDR
// x := 0 ;
80703: LD_ADDR_VAR 0 10
80707: PUSH
80708: LD_INT 0
80710: ST_TO_ADDR
// if tmp < k then
80711: LD_VAR 0 14
80715: PUSH
80716: LD_VAR 0 9
80720: LESS
80721: IFFALSE 80733
// k := tmp ;
80723: LD_ADDR_VAR 0 9
80727: PUSH
80728: LD_VAR 0 14
80732: ST_TO_ADDR
// for j = 1 to k do
80733: LD_ADDR_VAR 0 8
80737: PUSH
80738: DOUBLE
80739: LD_INT 1
80741: DEC
80742: ST_TO_ADDR
80743: LD_VAR 0 9
80747: PUSH
80748: FOR_TO
80749: IFFALSE 80847
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
80751: LD_VAR 0 14
80755: PUSH
80756: LD_VAR 0 8
80760: ARRAY
80761: PPUSH
80762: CALL_OW 247
80766: PUSH
80767: LD_INT 1
80769: EQUAL
80770: PUSH
80771: LD_VAR 0 14
80775: PUSH
80776: LD_VAR 0 8
80780: ARRAY
80781: PPUSH
80782: CALL_OW 256
80786: PUSH
80787: LD_INT 250
80789: LESS
80790: PUSH
80791: LD_VAR 0 20
80795: AND
80796: PUSH
80797: LD_VAR 0 20
80801: NOT
80802: PUSH
80803: LD_VAR 0 14
80807: PUSH
80808: LD_VAR 0 8
80812: ARRAY
80813: PPUSH
80814: CALL_OW 256
80818: PUSH
80819: LD_INT 250
80821: GREATEREQUAL
80822: AND
80823: OR
80824: AND
80825: IFFALSE 80845
// begin x := tmp [ j ] ;
80827: LD_ADDR_VAR 0 10
80831: PUSH
80832: LD_VAR 0 14
80836: PUSH
80837: LD_VAR 0 8
80841: ARRAY
80842: ST_TO_ADDR
// break ;
80843: GO 80847
// end ;
80845: GO 80748
80847: POP
80848: POP
// if x then
80849: LD_VAR 0 10
80853: IFFALSE 80877
// ComAttackUnit ( group [ i ] , x ) else
80855: LD_VAR 0 4
80859: PUSH
80860: LD_VAR 0 7
80864: ARRAY
80865: PPUSH
80866: LD_VAR 0 10
80870: PPUSH
80871: CALL_OW 115
80875: GO 80901
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
80877: LD_VAR 0 4
80881: PUSH
80882: LD_VAR 0 7
80886: ARRAY
80887: PPUSH
80888: LD_VAR 0 14
80892: PUSH
80893: LD_INT 1
80895: ARRAY
80896: PPUSH
80897: CALL_OW 115
// if not HasTask ( group [ i ] ) then
80901: LD_VAR 0 4
80905: PUSH
80906: LD_VAR 0 7
80910: ARRAY
80911: PPUSH
80912: CALL_OW 314
80916: NOT
80917: IFFALSE 80955
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
80919: LD_VAR 0 4
80923: PUSH
80924: LD_VAR 0 7
80928: ARRAY
80929: PPUSH
80930: LD_VAR 0 14
80934: PPUSH
80935: LD_VAR 0 4
80939: PUSH
80940: LD_VAR 0 7
80944: ARRAY
80945: PPUSH
80946: CALL_OW 74
80950: PPUSH
80951: CALL_OW 115
// end ; end ; end ;
80955: GO 76834
80957: POP
80958: POP
// wait ( 0 0$2 ) ;
80959: LD_INT 70
80961: PPUSH
80962: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
80966: LD_VAR 0 4
80970: NOT
80971: PUSH
80972: LD_VAR 0 4
80976: PUSH
80977: EMPTY
80978: EQUAL
80979: OR
80980: PUSH
80981: LD_INT 81
80983: PUSH
80984: LD_VAR 0 35
80988: PUSH
80989: EMPTY
80990: LIST
80991: LIST
80992: PPUSH
80993: CALL_OW 69
80997: NOT
80998: OR
80999: IFFALSE 76819
// end ;
81001: LD_VAR 0 2
81005: RET
// export function BasicDefend ( base , solds ) ; var enemy , side , i , hex ; begin
81006: LD_INT 0
81008: PPUSH
81009: PPUSH
81010: PPUSH
81011: PPUSH
81012: PPUSH
// if not base or not mc_bases [ base ] or not solds then
81013: LD_VAR 0 1
81017: NOT
81018: PUSH
81019: LD_EXP 175
81023: PUSH
81024: LD_VAR 0 1
81028: ARRAY
81029: NOT
81030: OR
81031: PUSH
81032: LD_VAR 0 2
81036: NOT
81037: OR
81038: IFFALSE 81042
// exit ;
81040: GO 81571
// side := mc_sides [ base ] ;
81042: LD_ADDR_VAR 0 5
81046: PUSH
81047: LD_EXP 201
81051: PUSH
81052: LD_VAR 0 1
81056: ARRAY
81057: ST_TO_ADDR
// if not side then
81058: LD_VAR 0 5
81062: NOT
81063: IFFALSE 81067
// exit ;
81065: GO 81571
// for i in solds do
81067: LD_ADDR_VAR 0 6
81071: PUSH
81072: LD_VAR 0 2
81076: PUSH
81077: FOR_IN
81078: IFFALSE 81139
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
81080: LD_VAR 0 6
81084: PPUSH
81085: CALL_OW 310
81089: PPUSH
81090: CALL_OW 266
81094: PUSH
81095: LD_INT 32
81097: PUSH
81098: LD_INT 31
81100: PUSH
81101: EMPTY
81102: LIST
81103: LIST
81104: IN
81105: IFFALSE 81125
// solds := solds diff i else
81107: LD_ADDR_VAR 0 2
81111: PUSH
81112: LD_VAR 0 2
81116: PUSH
81117: LD_VAR 0 6
81121: DIFF
81122: ST_TO_ADDR
81123: GO 81137
// SetTag ( i , 18 ) ;
81125: LD_VAR 0 6
81129: PPUSH
81130: LD_INT 18
81132: PPUSH
81133: CALL_OW 109
81137: GO 81077
81139: POP
81140: POP
// if not solds then
81141: LD_VAR 0 2
81145: NOT
81146: IFFALSE 81150
// exit ;
81148: GO 81571
// repeat wait ( 0 0$2 ) ;
81150: LD_INT 70
81152: PPUSH
81153: CALL_OW 67
// enemy := mc_scan [ base ] ;
81157: LD_ADDR_VAR 0 4
81161: PUSH
81162: LD_EXP 198
81166: PUSH
81167: LD_VAR 0 1
81171: ARRAY
81172: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
81173: LD_EXP 175
81177: PUSH
81178: LD_VAR 0 1
81182: ARRAY
81183: NOT
81184: PUSH
81185: LD_EXP 175
81189: PUSH
81190: LD_VAR 0 1
81194: ARRAY
81195: PUSH
81196: EMPTY
81197: EQUAL
81198: OR
81199: IFFALSE 81236
// begin for i in solds do
81201: LD_ADDR_VAR 0 6
81205: PUSH
81206: LD_VAR 0 2
81210: PUSH
81211: FOR_IN
81212: IFFALSE 81225
// ComStop ( i ) ;
81214: LD_VAR 0 6
81218: PPUSH
81219: CALL_OW 141
81223: GO 81211
81225: POP
81226: POP
// solds := [ ] ;
81227: LD_ADDR_VAR 0 2
81231: PUSH
81232: EMPTY
81233: ST_TO_ADDR
// exit ;
81234: GO 81571
// end ; for i in solds do
81236: LD_ADDR_VAR 0 6
81240: PUSH
81241: LD_VAR 0 2
81245: PUSH
81246: FOR_IN
81247: IFFALSE 81543
// begin if IsInUnit ( i ) then
81249: LD_VAR 0 6
81253: PPUSH
81254: CALL_OW 310
81258: IFFALSE 81269
// ComExitBuilding ( i ) ;
81260: LD_VAR 0 6
81264: PPUSH
81265: CALL_OW 122
// if GetLives ( i ) > 333 then
81269: LD_VAR 0 6
81273: PPUSH
81274: CALL_OW 256
81278: PUSH
81279: LD_INT 333
81281: GREATER
81282: IFFALSE 81310
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
81284: LD_VAR 0 6
81288: PPUSH
81289: LD_VAR 0 4
81293: PPUSH
81294: LD_VAR 0 6
81298: PPUSH
81299: CALL_OW 74
81303: PPUSH
81304: CALL_OW 115
81308: GO 81541
// if GetDistUnits ( i , NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ) > 10 then
81310: LD_VAR 0 6
81314: PPUSH
81315: LD_EXP 175
81319: PUSH
81320: LD_VAR 0 1
81324: ARRAY
81325: PPUSH
81326: LD_INT 2
81328: PUSH
81329: LD_INT 30
81331: PUSH
81332: LD_INT 0
81334: PUSH
81335: EMPTY
81336: LIST
81337: LIST
81338: PUSH
81339: LD_INT 30
81341: PUSH
81342: LD_INT 1
81344: PUSH
81345: EMPTY
81346: LIST
81347: LIST
81348: PUSH
81349: LD_INT 30
81351: PUSH
81352: LD_INT 6
81354: PUSH
81355: EMPTY
81356: LIST
81357: LIST
81358: PUSH
81359: EMPTY
81360: LIST
81361: LIST
81362: LIST
81363: LIST
81364: PPUSH
81365: CALL_OW 72
81369: PPUSH
81370: LD_VAR 0 6
81374: PPUSH
81375: CALL_OW 74
81379: PPUSH
81380: CALL_OW 296
81384: PUSH
81385: LD_INT 10
81387: GREATER
81388: IFFALSE 81541
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
81390: LD_ADDR_VAR 0 7
81394: PUSH
81395: LD_EXP 175
81399: PUSH
81400: LD_VAR 0 1
81404: ARRAY
81405: PPUSH
81406: LD_INT 2
81408: PUSH
81409: LD_INT 30
81411: PUSH
81412: LD_INT 0
81414: PUSH
81415: EMPTY
81416: LIST
81417: LIST
81418: PUSH
81419: LD_INT 30
81421: PUSH
81422: LD_INT 1
81424: PUSH
81425: EMPTY
81426: LIST
81427: LIST
81428: PUSH
81429: LD_INT 30
81431: PUSH
81432: LD_INT 6
81434: PUSH
81435: EMPTY
81436: LIST
81437: LIST
81438: PUSH
81439: EMPTY
81440: LIST
81441: LIST
81442: LIST
81443: LIST
81444: PPUSH
81445: CALL_OW 72
81449: PPUSH
81450: LD_VAR 0 6
81454: PPUSH
81455: CALL_OW 74
81459: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
81460: LD_VAR 0 6
81464: PPUSH
81465: LD_VAR 0 7
81469: PPUSH
81470: CALL_OW 250
81474: PPUSH
81475: LD_INT 3
81477: PPUSH
81478: LD_INT 5
81480: PPUSH
81481: CALL_OW 272
81485: PPUSH
81486: LD_VAR 0 7
81490: PPUSH
81491: CALL_OW 251
81495: PPUSH
81496: LD_INT 3
81498: PPUSH
81499: LD_INT 5
81501: PPUSH
81502: CALL_OW 273
81506: PPUSH
81507: CALL_OW 111
// SetTag ( i , 0 ) ;
81511: LD_VAR 0 6
81515: PPUSH
81516: LD_INT 0
81518: PPUSH
81519: CALL_OW 109
// solds := solds diff i ;
81523: LD_ADDR_VAR 0 2
81527: PUSH
81528: LD_VAR 0 2
81532: PUSH
81533: LD_VAR 0 6
81537: DIFF
81538: ST_TO_ADDR
// continue ;
81539: GO 81246
// end ; end ;
81541: GO 81246
81543: POP
81544: POP
// until not solds or not enemy ;
81545: LD_VAR 0 2
81549: NOT
81550: PUSH
81551: LD_VAR 0 4
81555: NOT
81556: OR
81557: IFFALSE 81150
// MC_Reset ( base , 18 ) ;
81559: LD_VAR 0 1
81563: PPUSH
81564: LD_INT 18
81566: PPUSH
81567: CALL 87726 0 2
// end ;
81571: LD_VAR 0 3
81575: RET
// export function Defend ( base , defenders ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend , class , enemy ; begin
81576: LD_INT 0
81578: PPUSH
81579: PPUSH
81580: PPUSH
81581: PPUSH
81582: PPUSH
81583: PPUSH
81584: PPUSH
81585: PPUSH
81586: PPUSH
81587: PPUSH
81588: PPUSH
81589: PPUSH
81590: PPUSH
81591: PPUSH
81592: PPUSH
81593: PPUSH
81594: PPUSH
81595: PPUSH
81596: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
81597: LD_ADDR_VAR 0 12
81601: PUSH
81602: LD_EXP 175
81606: PUSH
81607: LD_VAR 0 1
81611: ARRAY
81612: PPUSH
81613: LD_INT 25
81615: PUSH
81616: LD_INT 3
81618: PUSH
81619: EMPTY
81620: LIST
81621: LIST
81622: PPUSH
81623: CALL_OW 72
81627: ST_TO_ADDR
// if mc_remote_driver [ base ] then
81628: LD_EXP 215
81632: PUSH
81633: LD_VAR 0 1
81637: ARRAY
81638: IFFALSE 81662
// mechs := mechs diff mc_remote_driver [ base ] ;
81640: LD_ADDR_VAR 0 12
81644: PUSH
81645: LD_VAR 0 12
81649: PUSH
81650: LD_EXP 215
81654: PUSH
81655: LD_VAR 0 1
81659: ARRAY
81660: DIFF
81661: ST_TO_ADDR
// for i in mechs do
81662: LD_ADDR_VAR 0 4
81666: PUSH
81667: LD_VAR 0 12
81671: PUSH
81672: FOR_IN
81673: IFFALSE 81708
// if GetTag ( i ) > 0 then
81675: LD_VAR 0 4
81679: PPUSH
81680: CALL_OW 110
81684: PUSH
81685: LD_INT 0
81687: GREATER
81688: IFFALSE 81706
// mechs := mechs diff i ;
81690: LD_ADDR_VAR 0 12
81694: PUSH
81695: LD_VAR 0 12
81699: PUSH
81700: LD_VAR 0 4
81704: DIFF
81705: ST_TO_ADDR
81706: GO 81672
81708: POP
81709: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
81710: LD_ADDR_VAR 0 8
81714: PUSH
81715: LD_EXP 175
81719: PUSH
81720: LD_VAR 0 1
81724: ARRAY
81725: PPUSH
81726: LD_INT 2
81728: PUSH
81729: LD_INT 25
81731: PUSH
81732: LD_INT 1
81734: PUSH
81735: EMPTY
81736: LIST
81737: LIST
81738: PUSH
81739: LD_INT 25
81741: PUSH
81742: LD_INT 5
81744: PUSH
81745: EMPTY
81746: LIST
81747: LIST
81748: PUSH
81749: LD_INT 25
81751: PUSH
81752: LD_INT 8
81754: PUSH
81755: EMPTY
81756: LIST
81757: LIST
81758: PUSH
81759: LD_INT 25
81761: PUSH
81762: LD_INT 9
81764: PUSH
81765: EMPTY
81766: LIST
81767: LIST
81768: PUSH
81769: EMPTY
81770: LIST
81771: LIST
81772: LIST
81773: LIST
81774: LIST
81775: PPUSH
81776: CALL_OW 72
81780: ST_TO_ADDR
// if not defenders and not solds then
81781: LD_VAR 0 2
81785: NOT
81786: PUSH
81787: LD_VAR 0 8
81791: NOT
81792: AND
81793: IFFALSE 81797
// exit ;
81795: GO 83567
// depot_under_attack := false ;
81797: LD_ADDR_VAR 0 16
81801: PUSH
81802: LD_INT 0
81804: ST_TO_ADDR
// sold_defenders := [ ] ;
81805: LD_ADDR_VAR 0 17
81809: PUSH
81810: EMPTY
81811: ST_TO_ADDR
// if mechs then
81812: LD_VAR 0 12
81816: IFFALSE 81969
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
81818: LD_ADDR_VAR 0 4
81822: PUSH
81823: LD_VAR 0 2
81827: PPUSH
81828: LD_INT 21
81830: PUSH
81831: LD_INT 2
81833: PUSH
81834: EMPTY
81835: LIST
81836: LIST
81837: PPUSH
81838: CALL_OW 72
81842: PUSH
81843: FOR_IN
81844: IFFALSE 81967
// begin if GetTag ( i ) <> 20 then
81846: LD_VAR 0 4
81850: PPUSH
81851: CALL_OW 110
81855: PUSH
81856: LD_INT 20
81858: NONEQUAL
81859: IFFALSE 81873
// SetTag ( i , 20 ) ;
81861: LD_VAR 0 4
81865: PPUSH
81866: LD_INT 20
81868: PPUSH
81869: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
81873: LD_VAR 0 4
81877: PPUSH
81878: CALL_OW 263
81882: PUSH
81883: LD_INT 1
81885: EQUAL
81886: PUSH
81887: LD_VAR 0 4
81891: PPUSH
81892: CALL_OW 311
81896: NOT
81897: AND
81898: IFFALSE 81965
// begin un := mechs [ 1 ] ;
81900: LD_ADDR_VAR 0 10
81904: PUSH
81905: LD_VAR 0 12
81909: PUSH
81910: LD_INT 1
81912: ARRAY
81913: ST_TO_ADDR
// ComExit ( un ) ;
81914: LD_VAR 0 10
81918: PPUSH
81919: CALL 56349 0 1
// AddComEnterUnit ( un , i ) ;
81923: LD_VAR 0 10
81927: PPUSH
81928: LD_VAR 0 4
81932: PPUSH
81933: CALL_OW 180
// SetTag ( un , 19 ) ;
81937: LD_VAR 0 10
81941: PPUSH
81942: LD_INT 19
81944: PPUSH
81945: CALL_OW 109
// mechs := mechs diff un ;
81949: LD_ADDR_VAR 0 12
81953: PUSH
81954: LD_VAR 0 12
81958: PUSH
81959: LD_VAR 0 10
81963: DIFF
81964: ST_TO_ADDR
// end ; end ;
81965: GO 81843
81967: POP
81968: POP
// if solds then
81969: LD_VAR 0 8
81973: IFFALSE 82032
// for i in solds do
81975: LD_ADDR_VAR 0 4
81979: PUSH
81980: LD_VAR 0 8
81984: PUSH
81985: FOR_IN
81986: IFFALSE 82030
// if not GetTag ( i ) then
81988: LD_VAR 0 4
81992: PPUSH
81993: CALL_OW 110
81997: NOT
81998: IFFALSE 82028
// begin defenders := defenders union i ;
82000: LD_ADDR_VAR 0 2
82004: PUSH
82005: LD_VAR 0 2
82009: PUSH
82010: LD_VAR 0 4
82014: UNION
82015: ST_TO_ADDR
// SetTag ( i , 18 ) ;
82016: LD_VAR 0 4
82020: PPUSH
82021: LD_INT 18
82023: PPUSH
82024: CALL_OW 109
// end ;
82028: GO 81985
82030: POP
82031: POP
// repeat wait ( 0 0$2 ) ;
82032: LD_INT 70
82034: PPUSH
82035: CALL_OW 67
// enemy := mc_scan [ base ] ;
82039: LD_ADDR_VAR 0 21
82043: PUSH
82044: LD_EXP 198
82048: PUSH
82049: LD_VAR 0 1
82053: ARRAY
82054: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
82055: LD_EXP 175
82059: PUSH
82060: LD_VAR 0 1
82064: ARRAY
82065: NOT
82066: PUSH
82067: LD_EXP 175
82071: PUSH
82072: LD_VAR 0 1
82076: ARRAY
82077: PUSH
82078: EMPTY
82079: EQUAL
82080: OR
82081: IFFALSE 82118
// begin for i in defenders do
82083: LD_ADDR_VAR 0 4
82087: PUSH
82088: LD_VAR 0 2
82092: PUSH
82093: FOR_IN
82094: IFFALSE 82107
// ComStop ( i ) ;
82096: LD_VAR 0 4
82100: PPUSH
82101: CALL_OW 141
82105: GO 82093
82107: POP
82108: POP
// defenders := [ ] ;
82109: LD_ADDR_VAR 0 2
82113: PUSH
82114: EMPTY
82115: ST_TO_ADDR
// exit ;
82116: GO 83567
// end ; for i in defenders do
82118: LD_ADDR_VAR 0 4
82122: PUSH
82123: LD_VAR 0 2
82127: PUSH
82128: FOR_IN
82129: IFFALSE 83027
// begin e := NearestUnitToUnit ( enemy , i ) ;
82131: LD_ADDR_VAR 0 13
82135: PUSH
82136: LD_VAR 0 21
82140: PPUSH
82141: LD_VAR 0 4
82145: PPUSH
82146: CALL_OW 74
82150: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
82151: LD_ADDR_VAR 0 7
82155: PUSH
82156: LD_EXP 175
82160: PUSH
82161: LD_VAR 0 1
82165: ARRAY
82166: PPUSH
82167: LD_INT 2
82169: PUSH
82170: LD_INT 30
82172: PUSH
82173: LD_INT 0
82175: PUSH
82176: EMPTY
82177: LIST
82178: LIST
82179: PUSH
82180: LD_INT 30
82182: PUSH
82183: LD_INT 1
82185: PUSH
82186: EMPTY
82187: LIST
82188: LIST
82189: PUSH
82190: EMPTY
82191: LIST
82192: LIST
82193: LIST
82194: PPUSH
82195: CALL_OW 72
82199: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
82200: LD_ADDR_VAR 0 16
82204: PUSH
82205: LD_VAR 0 7
82209: NOT
82210: PUSH
82211: LD_VAR 0 7
82215: PPUSH
82216: LD_INT 3
82218: PUSH
82219: LD_INT 24
82221: PUSH
82222: LD_INT 600
82224: PUSH
82225: EMPTY
82226: LIST
82227: LIST
82228: PUSH
82229: EMPTY
82230: LIST
82231: LIST
82232: PPUSH
82233: CALL_OW 72
82237: OR
82238: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
82239: LD_VAR 0 4
82243: PPUSH
82244: CALL_OW 247
82248: PUSH
82249: LD_INT 2
82251: DOUBLE
82252: EQUAL
82253: IFTRUE 82257
82255: GO 82653
82257: POP
// begin if GetLives ( i ) = 1000 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
82258: LD_VAR 0 4
82262: PPUSH
82263: CALL_OW 256
82267: PUSH
82268: LD_INT 1000
82270: EQUAL
82271: PUSH
82272: LD_VAR 0 4
82276: PPUSH
82277: LD_VAR 0 13
82281: PPUSH
82282: CALL_OW 296
82286: PUSH
82287: LD_INT 40
82289: LESS
82290: PUSH
82291: LD_VAR 0 13
82295: PPUSH
82296: LD_EXP 200
82300: PUSH
82301: LD_VAR 0 1
82305: ARRAY
82306: PPUSH
82307: CALL_OW 308
82311: OR
82312: AND
82313: IFFALSE 82435
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
82315: LD_VAR 0 4
82319: PPUSH
82320: CALL_OW 262
82324: PUSH
82325: LD_INT 1
82327: EQUAL
82328: PUSH
82329: LD_VAR 0 4
82333: PPUSH
82334: CALL_OW 261
82338: PUSH
82339: LD_INT 30
82341: LESS
82342: AND
82343: PUSH
82344: LD_VAR 0 7
82348: AND
82349: IFFALSE 82419
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
82351: LD_VAR 0 4
82355: PPUSH
82356: LD_VAR 0 7
82360: PPUSH
82361: LD_VAR 0 4
82365: PPUSH
82366: CALL_OW 74
82370: PPUSH
82371: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
82375: LD_VAR 0 4
82379: PPUSH
82380: LD_VAR 0 7
82384: PPUSH
82385: LD_VAR 0 4
82389: PPUSH
82390: CALL_OW 74
82394: PPUSH
82395: CALL_OW 296
82399: PUSH
82400: LD_INT 6
82402: LESS
82403: IFFALSE 82417
// SetFuel ( i , 100 ) ;
82405: LD_VAR 0 4
82409: PPUSH
82410: LD_INT 100
82412: PPUSH
82413: CALL_OW 240
// end else
82417: GO 82433
// ComAttackUnit ( i , e ) ;
82419: LD_VAR 0 4
82423: PPUSH
82424: LD_VAR 0 13
82428: PPUSH
82429: CALL_OW 115
// end else
82433: GO 82536
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
82435: LD_VAR 0 13
82439: PPUSH
82440: LD_EXP 200
82444: PUSH
82445: LD_VAR 0 1
82449: ARRAY
82450: PPUSH
82451: CALL_OW 308
82455: NOT
82456: PUSH
82457: LD_VAR 0 4
82461: PPUSH
82462: LD_VAR 0 13
82466: PPUSH
82467: CALL_OW 296
82471: PUSH
82472: LD_INT 40
82474: GREATEREQUAL
82475: AND
82476: PUSH
82477: LD_VAR 0 4
82481: PPUSH
82482: CALL_OW 256
82486: PUSH
82487: LD_INT 650
82489: LESSEQUAL
82490: OR
82491: PUSH
82492: LD_VAR 0 4
82496: PPUSH
82497: LD_EXP 199
82501: PUSH
82502: LD_VAR 0 1
82506: ARRAY
82507: PPUSH
82508: CALL_OW 308
82512: NOT
82513: AND
82514: IFFALSE 82536
// ComMoveToArea ( i , mc_parking [ base ] ) ;
82516: LD_VAR 0 4
82520: PPUSH
82521: LD_EXP 199
82525: PUSH
82526: LD_VAR 0 1
82530: ARRAY
82531: PPUSH
82532: CALL_OW 113
// if GetLives ( i ) < 1000 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
82536: LD_VAR 0 4
82540: PPUSH
82541: CALL_OW 256
82545: PUSH
82546: LD_INT 1000
82548: LESS
82549: PUSH
82550: LD_VAR 0 4
82554: PPUSH
82555: CALL_OW 263
82559: PUSH
82560: LD_INT 1
82562: EQUAL
82563: AND
82564: PUSH
82565: LD_VAR 0 4
82569: PPUSH
82570: CALL_OW 311
82574: AND
82575: PUSH
82576: LD_VAR 0 4
82580: PPUSH
82581: LD_EXP 199
82585: PUSH
82586: LD_VAR 0 1
82590: ARRAY
82591: PPUSH
82592: CALL_OW 308
82596: AND
82597: IFFALSE 82651
// begin mech := IsDrivenBy ( i ) ;
82599: LD_ADDR_VAR 0 9
82603: PUSH
82604: LD_VAR 0 4
82608: PPUSH
82609: CALL_OW 311
82613: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
82614: LD_VAR 0 9
82618: PPUSH
82619: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
82623: LD_VAR 0 9
82627: PPUSH
82628: LD_VAR 0 4
82632: PPUSH
82633: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
82637: LD_VAR 0 9
82641: PPUSH
82642: LD_VAR 0 4
82646: PPUSH
82647: CALL_OW 180
// end ; end ; unit_human :
82651: GO 82998
82653: LD_INT 1
82655: DOUBLE
82656: EQUAL
82657: IFTRUE 82661
82659: GO 82997
82661: POP
// begin b := IsInUnit ( i ) ;
82662: LD_ADDR_VAR 0 18
82666: PUSH
82667: LD_VAR 0 4
82671: PPUSH
82672: CALL_OW 310
82676: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
82677: LD_ADDR_VAR 0 19
82681: PUSH
82682: LD_VAR 0 18
82686: NOT
82687: PUSH
82688: LD_VAR 0 18
82692: PPUSH
82693: CALL_OW 266
82697: PUSH
82698: LD_INT 32
82700: PUSH
82701: LD_INT 31
82703: PUSH
82704: EMPTY
82705: LIST
82706: LIST
82707: IN
82708: OR
82709: ST_TO_ADDR
// if GetBType ( b ) = b_barracks and GetClass ( i ) in [ 1 , 2 , 3 , 4 ] then
82710: LD_VAR 0 18
82714: PPUSH
82715: CALL_OW 266
82719: PUSH
82720: LD_INT 5
82722: EQUAL
82723: PUSH
82724: LD_VAR 0 4
82728: PPUSH
82729: CALL_OW 257
82733: PUSH
82734: LD_INT 1
82736: PUSH
82737: LD_INT 2
82739: PUSH
82740: LD_INT 3
82742: PUSH
82743: LD_INT 4
82745: PUSH
82746: EMPTY
82747: LIST
82748: LIST
82749: LIST
82750: LIST
82751: IN
82752: AND
82753: IFFALSE 82790
// begin class := AllowSpecClass ( i ) ;
82755: LD_ADDR_VAR 0 20
82759: PUSH
82760: LD_VAR 0 4
82764: PPUSH
82765: CALL 21010 0 1
82769: ST_TO_ADDR
// if class then
82770: LD_VAR 0 20
82774: IFFALSE 82790
// ComChangeProfession ( i , class ) ;
82776: LD_VAR 0 4
82780: PPUSH
82781: LD_VAR 0 20
82785: PPUSH
82786: CALL_OW 123
// end ; if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
82790: LD_VAR 0 16
82794: PUSH
82795: LD_VAR 0 2
82799: PPUSH
82800: LD_INT 21
82802: PUSH
82803: LD_INT 2
82805: PUSH
82806: EMPTY
82807: LIST
82808: LIST
82809: PPUSH
82810: CALL_OW 72
82814: PUSH
82815: LD_INT 1
82817: LESSEQUAL
82818: OR
82819: PUSH
82820: LD_VAR 0 19
82824: AND
82825: PUSH
82826: LD_VAR 0 4
82830: PUSH
82831: LD_VAR 0 17
82835: IN
82836: NOT
82837: AND
82838: IFFALSE 82931
// begin if b then
82840: LD_VAR 0 18
82844: IFFALSE 82893
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
82846: LD_VAR 0 18
82850: PPUSH
82851: LD_VAR 0 21
82855: PPUSH
82856: LD_VAR 0 18
82860: PPUSH
82861: CALL_OW 74
82865: PPUSH
82866: CALL_OW 296
82870: PUSH
82871: LD_INT 10
82873: LESS
82874: PUSH
82875: LD_VAR 0 18
82879: PPUSH
82880: CALL_OW 461
82884: PUSH
82885: LD_INT 7
82887: NONEQUAL
82888: AND
82889: IFFALSE 82893
// continue ;
82891: GO 82128
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
82893: LD_ADDR_VAR 0 17
82897: PUSH
82898: LD_VAR 0 17
82902: PPUSH
82903: LD_VAR 0 17
82907: PUSH
82908: LD_INT 1
82910: PLUS
82911: PPUSH
82912: LD_VAR 0 4
82916: PPUSH
82917: CALL_OW 1
82921: ST_TO_ADDR
// ComExitBuilding ( i ) ;
82922: LD_VAR 0 4
82926: PPUSH
82927: CALL_OW 122
// end ; if sold_defenders then
82931: LD_VAR 0 17
82935: IFFALSE 82995
// if i in sold_defenders then
82937: LD_VAR 0 4
82941: PUSH
82942: LD_VAR 0 17
82946: IN
82947: IFFALSE 82995
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
82949: LD_VAR 0 4
82953: PPUSH
82954: CALL_OW 314
82958: NOT
82959: PUSH
82960: LD_VAR 0 4
82964: PPUSH
82965: LD_VAR 0 13
82969: PPUSH
82970: CALL_OW 296
82974: PUSH
82975: LD_INT 30
82977: LESS
82978: AND
82979: IFFALSE 82995
// ComAttackUnit ( i , e ) ;
82981: LD_VAR 0 4
82985: PPUSH
82986: LD_VAR 0 13
82990: PPUSH
82991: CALL_OW 115
// end ; end ; end ;
82995: GO 82998
82997: POP
// if IsDead ( i ) then
82998: LD_VAR 0 4
83002: PPUSH
83003: CALL_OW 301
83007: IFFALSE 83025
// defenders := defenders diff i ;
83009: LD_ADDR_VAR 0 2
83013: PUSH
83014: LD_VAR 0 2
83018: PUSH
83019: LD_VAR 0 4
83023: DIFF
83024: ST_TO_ADDR
// end ;
83025: GO 82128
83027: POP
83028: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
83029: LD_VAR 0 21
83033: NOT
83034: PUSH
83035: LD_VAR 0 2
83039: NOT
83040: OR
83041: PUSH
83042: LD_EXP 175
83046: PUSH
83047: LD_VAR 0 1
83051: ARRAY
83052: NOT
83053: OR
83054: IFFALSE 82032
// MC_Reset ( base , 18 ) ;
83056: LD_VAR 0 1
83060: PPUSH
83061: LD_INT 18
83063: PPUSH
83064: CALL 87726 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
83068: LD_ADDR_VAR 0 2
83072: PUSH
83073: LD_VAR 0 2
83077: PUSH
83078: LD_VAR 0 2
83082: PPUSH
83083: LD_INT 2
83085: PUSH
83086: LD_INT 25
83088: PUSH
83089: LD_INT 1
83091: PUSH
83092: EMPTY
83093: LIST
83094: LIST
83095: PUSH
83096: LD_INT 25
83098: PUSH
83099: LD_INT 5
83101: PUSH
83102: EMPTY
83103: LIST
83104: LIST
83105: PUSH
83106: LD_INT 25
83108: PUSH
83109: LD_INT 8
83111: PUSH
83112: EMPTY
83113: LIST
83114: LIST
83115: PUSH
83116: LD_INT 25
83118: PUSH
83119: LD_INT 9
83121: PUSH
83122: EMPTY
83123: LIST
83124: LIST
83125: PUSH
83126: EMPTY
83127: LIST
83128: LIST
83129: LIST
83130: LIST
83131: LIST
83132: PPUSH
83133: CALL_OW 72
83137: DIFF
83138: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
83139: LD_VAR 0 21
83143: NOT
83144: PUSH
83145: LD_VAR 0 2
83149: PPUSH
83150: LD_INT 21
83152: PUSH
83153: LD_INT 2
83155: PUSH
83156: EMPTY
83157: LIST
83158: LIST
83159: PPUSH
83160: CALL_OW 72
83164: AND
83165: IFFALSE 83503
// begin tmp := FilterByTag ( defenders , 19 ) ;
83167: LD_ADDR_VAR 0 11
83171: PUSH
83172: LD_VAR 0 2
83176: PPUSH
83177: LD_INT 19
83179: PPUSH
83180: CALL 53479 0 2
83184: ST_TO_ADDR
// if tmp then
83185: LD_VAR 0 11
83189: IFFALSE 83259
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
83191: LD_ADDR_VAR 0 11
83195: PUSH
83196: LD_VAR 0 11
83200: PPUSH
83201: LD_INT 25
83203: PUSH
83204: LD_INT 3
83206: PUSH
83207: EMPTY
83208: LIST
83209: LIST
83210: PPUSH
83211: CALL_OW 72
83215: ST_TO_ADDR
// if tmp then
83216: LD_VAR 0 11
83220: IFFALSE 83259
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
83222: LD_ADDR_EXP 187
83226: PUSH
83227: LD_EXP 187
83231: PPUSH
83232: LD_VAR 0 1
83236: PPUSH
83237: LD_EXP 187
83241: PUSH
83242: LD_VAR 0 1
83246: ARRAY
83247: PUSH
83248: LD_VAR 0 11
83252: UNION
83253: PPUSH
83254: CALL_OW 1
83258: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
83259: LD_VAR 0 1
83263: PPUSH
83264: LD_INT 19
83266: PPUSH
83267: CALL 87726 0 2
// repeat wait ( 0 0$1 ) ;
83271: LD_INT 35
83273: PPUSH
83274: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
83278: LD_EXP 175
83282: PUSH
83283: LD_VAR 0 1
83287: ARRAY
83288: NOT
83289: PUSH
83290: LD_EXP 175
83294: PUSH
83295: LD_VAR 0 1
83299: ARRAY
83300: PUSH
83301: EMPTY
83302: EQUAL
83303: OR
83304: IFFALSE 83341
// begin for i in defenders do
83306: LD_ADDR_VAR 0 4
83310: PUSH
83311: LD_VAR 0 2
83315: PUSH
83316: FOR_IN
83317: IFFALSE 83330
// ComStop ( i ) ;
83319: LD_VAR 0 4
83323: PPUSH
83324: CALL_OW 141
83328: GO 83316
83330: POP
83331: POP
// defenders := [ ] ;
83332: LD_ADDR_VAR 0 2
83336: PUSH
83337: EMPTY
83338: ST_TO_ADDR
// exit ;
83339: GO 83567
// end ; for i in defenders do
83341: LD_ADDR_VAR 0 4
83345: PUSH
83346: LD_VAR 0 2
83350: PUSH
83351: FOR_IN
83352: IFFALSE 83441
// begin if not IsInArea ( i , mc_parking [ base ] ) then
83354: LD_VAR 0 4
83358: PPUSH
83359: LD_EXP 199
83363: PUSH
83364: LD_VAR 0 1
83368: ARRAY
83369: PPUSH
83370: CALL_OW 308
83374: NOT
83375: IFFALSE 83399
// ComMoveToArea ( i , mc_parking [ base ] ) else
83377: LD_VAR 0 4
83381: PPUSH
83382: LD_EXP 199
83386: PUSH
83387: LD_VAR 0 1
83391: ARRAY
83392: PPUSH
83393: CALL_OW 113
83397: GO 83439
// if GetControl ( i ) = control_manual then
83399: LD_VAR 0 4
83403: PPUSH
83404: CALL_OW 263
83408: PUSH
83409: LD_INT 1
83411: EQUAL
83412: IFFALSE 83439
// if IsDrivenBy ( i ) then
83414: LD_VAR 0 4
83418: PPUSH
83419: CALL_OW 311
83423: IFFALSE 83439
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
83425: LD_VAR 0 4
83429: PPUSH
83430: CALL_OW 311
83434: PPUSH
83435: CALL_OW 121
// end ;
83439: GO 83351
83441: POP
83442: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
83443: LD_VAR 0 2
83447: PPUSH
83448: LD_INT 95
83450: PUSH
83451: LD_EXP 199
83455: PUSH
83456: LD_VAR 0 1
83460: ARRAY
83461: PUSH
83462: EMPTY
83463: LIST
83464: LIST
83465: PPUSH
83466: CALL_OW 72
83470: PUSH
83471: LD_VAR 0 2
83475: EQUAL
83476: PUSH
83477: LD_EXP 198
83481: PUSH
83482: LD_VAR 0 1
83486: ARRAY
83487: OR
83488: PUSH
83489: LD_EXP 175
83493: PUSH
83494: LD_VAR 0 1
83498: ARRAY
83499: NOT
83500: OR
83501: IFFALSE 83271
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
83503: LD_ADDR_EXP 197
83507: PUSH
83508: LD_EXP 197
83512: PPUSH
83513: LD_VAR 0 1
83517: PPUSH
83518: LD_VAR 0 2
83522: PPUSH
83523: LD_INT 21
83525: PUSH
83526: LD_INT 2
83528: PUSH
83529: EMPTY
83530: LIST
83531: LIST
83532: PPUSH
83533: CALL_OW 72
83537: PPUSH
83538: CALL_OW 1
83542: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
83543: LD_VAR 0 1
83547: PPUSH
83548: LD_INT 19
83550: PPUSH
83551: CALL 87726 0 2
// MC_Reset ( base , 20 ) ;
83555: LD_VAR 0 1
83559: PPUSH
83560: LD_INT 20
83562: PPUSH
83563: CALL 87726 0 2
// end ; end_of_file
83567: LD_VAR 0 3
83571: RET
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use , mc_is_defending ; export function InitMacro ; var i ; begin
83572: LD_INT 0
83574: PPUSH
83575: PPUSH
// skirmish := false ;
83576: LD_ADDR_EXP 173
83580: PUSH
83581: LD_INT 0
83583: ST_TO_ADDR
// debug_mc := false ;
83584: LD_ADDR_EXP 174
83588: PUSH
83589: LD_INT 0
83591: ST_TO_ADDR
// mc_bases := [ ] ;
83592: LD_ADDR_EXP 175
83596: PUSH
83597: EMPTY
83598: ST_TO_ADDR
// mc_sides := [ ] ;
83599: LD_ADDR_EXP 201
83603: PUSH
83604: EMPTY
83605: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
83606: LD_ADDR_EXP 176
83610: PUSH
83611: EMPTY
83612: ST_TO_ADDR
// mc_building_repairs := [ ] ;
83613: LD_ADDR_EXP 177
83617: PUSH
83618: EMPTY
83619: ST_TO_ADDR
// mc_need_heal := [ ] ;
83620: LD_ADDR_EXP 178
83624: PUSH
83625: EMPTY
83626: ST_TO_ADDR
// mc_healers := [ ] ;
83627: LD_ADDR_EXP 179
83631: PUSH
83632: EMPTY
83633: ST_TO_ADDR
// mc_build_list := [ ] ;
83634: LD_ADDR_EXP 180
83638: PUSH
83639: EMPTY
83640: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
83641: LD_ADDR_EXP 207
83645: PUSH
83646: EMPTY
83647: ST_TO_ADDR
// mc_builders := [ ] ;
83648: LD_ADDR_EXP 181
83652: PUSH
83653: EMPTY
83654: ST_TO_ADDR
// mc_construct_list := [ ] ;
83655: LD_ADDR_EXP 182
83659: PUSH
83660: EMPTY
83661: ST_TO_ADDR
// mc_turret_list := [ ] ;
83662: LD_ADDR_EXP 183
83666: PUSH
83667: EMPTY
83668: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
83669: LD_ADDR_EXP 184
83673: PUSH
83674: EMPTY
83675: ST_TO_ADDR
// mc_miners := [ ] ;
83676: LD_ADDR_EXP 189
83680: PUSH
83681: EMPTY
83682: ST_TO_ADDR
// mc_mines := [ ] ;
83683: LD_ADDR_EXP 188
83687: PUSH
83688: EMPTY
83689: ST_TO_ADDR
// mc_minefields := [ ] ;
83690: LD_ADDR_EXP 190
83694: PUSH
83695: EMPTY
83696: ST_TO_ADDR
// mc_crates := [ ] ;
83697: LD_ADDR_EXP 191
83701: PUSH
83702: EMPTY
83703: ST_TO_ADDR
// mc_crates_collector := [ ] ;
83704: LD_ADDR_EXP 192
83708: PUSH
83709: EMPTY
83710: ST_TO_ADDR
// mc_crates_area := [ ] ;
83711: LD_ADDR_EXP 193
83715: PUSH
83716: EMPTY
83717: ST_TO_ADDR
// mc_vehicles := [ ] ;
83718: LD_ADDR_EXP 194
83722: PUSH
83723: EMPTY
83724: ST_TO_ADDR
// mc_attack := [ ] ;
83725: LD_ADDR_EXP 195
83729: PUSH
83730: EMPTY
83731: ST_TO_ADDR
// mc_produce := [ ] ;
83732: LD_ADDR_EXP 196
83736: PUSH
83737: EMPTY
83738: ST_TO_ADDR
// mc_defender := [ ] ;
83739: LD_ADDR_EXP 197
83743: PUSH
83744: EMPTY
83745: ST_TO_ADDR
// mc_parking := [ ] ;
83746: LD_ADDR_EXP 199
83750: PUSH
83751: EMPTY
83752: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
83753: LD_ADDR_EXP 185
83757: PUSH
83758: EMPTY
83759: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
83760: LD_ADDR_EXP 187
83764: PUSH
83765: EMPTY
83766: ST_TO_ADDR
// mc_scan := [ ] ;
83767: LD_ADDR_EXP 198
83771: PUSH
83772: EMPTY
83773: ST_TO_ADDR
// mc_scan_area := [ ] ;
83774: LD_ADDR_EXP 200
83778: PUSH
83779: EMPTY
83780: ST_TO_ADDR
// mc_tech := [ ] ;
83781: LD_ADDR_EXP 202
83785: PUSH
83786: EMPTY
83787: ST_TO_ADDR
// mc_class := [ ] ;
83788: LD_ADDR_EXP 216
83792: PUSH
83793: EMPTY
83794: ST_TO_ADDR
// mc_class_case_use := [ ] ;
83795: LD_ADDR_EXP 217
83799: PUSH
83800: EMPTY
83801: ST_TO_ADDR
// mc_is_defending := [ ] ;
83802: LD_ADDR_EXP 218
83806: PUSH
83807: EMPTY
83808: ST_TO_ADDR
// end ;
83809: LD_VAR 0 1
83813: RET
// export function MC_Kill ( base ) ; begin
83814: LD_INT 0
83816: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
83817: LD_ADDR_EXP 175
83821: PUSH
83822: LD_EXP 175
83826: PPUSH
83827: LD_VAR 0 1
83831: PPUSH
83832: EMPTY
83833: PPUSH
83834: CALL_OW 1
83838: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
83839: LD_ADDR_EXP 176
83843: PUSH
83844: LD_EXP 176
83848: PPUSH
83849: LD_VAR 0 1
83853: PPUSH
83854: EMPTY
83855: PPUSH
83856: CALL_OW 1
83860: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
83861: LD_ADDR_EXP 177
83865: PUSH
83866: LD_EXP 177
83870: PPUSH
83871: LD_VAR 0 1
83875: PPUSH
83876: EMPTY
83877: PPUSH
83878: CALL_OW 1
83882: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
83883: LD_ADDR_EXP 178
83887: PUSH
83888: LD_EXP 178
83892: PPUSH
83893: LD_VAR 0 1
83897: PPUSH
83898: EMPTY
83899: PPUSH
83900: CALL_OW 1
83904: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
83905: LD_ADDR_EXP 179
83909: PUSH
83910: LD_EXP 179
83914: PPUSH
83915: LD_VAR 0 1
83919: PPUSH
83920: EMPTY
83921: PPUSH
83922: CALL_OW 1
83926: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
83927: LD_ADDR_EXP 180
83931: PUSH
83932: LD_EXP 180
83936: PPUSH
83937: LD_VAR 0 1
83941: PPUSH
83942: EMPTY
83943: PPUSH
83944: CALL_OW 1
83948: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
83949: LD_ADDR_EXP 181
83953: PUSH
83954: LD_EXP 181
83958: PPUSH
83959: LD_VAR 0 1
83963: PPUSH
83964: EMPTY
83965: PPUSH
83966: CALL_OW 1
83970: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
83971: LD_ADDR_EXP 182
83975: PUSH
83976: LD_EXP 182
83980: PPUSH
83981: LD_VAR 0 1
83985: PPUSH
83986: EMPTY
83987: PPUSH
83988: CALL_OW 1
83992: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
83993: LD_ADDR_EXP 183
83997: PUSH
83998: LD_EXP 183
84002: PPUSH
84003: LD_VAR 0 1
84007: PPUSH
84008: EMPTY
84009: PPUSH
84010: CALL_OW 1
84014: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
84015: LD_ADDR_EXP 184
84019: PUSH
84020: LD_EXP 184
84024: PPUSH
84025: LD_VAR 0 1
84029: PPUSH
84030: EMPTY
84031: PPUSH
84032: CALL_OW 1
84036: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
84037: LD_ADDR_EXP 185
84041: PUSH
84042: LD_EXP 185
84046: PPUSH
84047: LD_VAR 0 1
84051: PPUSH
84052: EMPTY
84053: PPUSH
84054: CALL_OW 1
84058: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
84059: LD_ADDR_EXP 186
84063: PUSH
84064: LD_EXP 186
84068: PPUSH
84069: LD_VAR 0 1
84073: PPUSH
84074: LD_INT 0
84076: PPUSH
84077: CALL_OW 1
84081: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
84082: LD_ADDR_EXP 187
84086: PUSH
84087: LD_EXP 187
84091: PPUSH
84092: LD_VAR 0 1
84096: PPUSH
84097: EMPTY
84098: PPUSH
84099: CALL_OW 1
84103: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
84104: LD_ADDR_EXP 188
84108: PUSH
84109: LD_EXP 188
84113: PPUSH
84114: LD_VAR 0 1
84118: PPUSH
84119: EMPTY
84120: PPUSH
84121: CALL_OW 1
84125: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
84126: LD_ADDR_EXP 189
84130: PUSH
84131: LD_EXP 189
84135: PPUSH
84136: LD_VAR 0 1
84140: PPUSH
84141: EMPTY
84142: PPUSH
84143: CALL_OW 1
84147: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
84148: LD_ADDR_EXP 190
84152: PUSH
84153: LD_EXP 190
84157: PPUSH
84158: LD_VAR 0 1
84162: PPUSH
84163: EMPTY
84164: PPUSH
84165: CALL_OW 1
84169: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
84170: LD_ADDR_EXP 191
84174: PUSH
84175: LD_EXP 191
84179: PPUSH
84180: LD_VAR 0 1
84184: PPUSH
84185: EMPTY
84186: PPUSH
84187: CALL_OW 1
84191: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
84192: LD_ADDR_EXP 192
84196: PUSH
84197: LD_EXP 192
84201: PPUSH
84202: LD_VAR 0 1
84206: PPUSH
84207: EMPTY
84208: PPUSH
84209: CALL_OW 1
84213: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
84214: LD_ADDR_EXP 193
84218: PUSH
84219: LD_EXP 193
84223: PPUSH
84224: LD_VAR 0 1
84228: PPUSH
84229: EMPTY
84230: PPUSH
84231: CALL_OW 1
84235: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
84236: LD_ADDR_EXP 194
84240: PUSH
84241: LD_EXP 194
84245: PPUSH
84246: LD_VAR 0 1
84250: PPUSH
84251: EMPTY
84252: PPUSH
84253: CALL_OW 1
84257: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
84258: LD_ADDR_EXP 195
84262: PUSH
84263: LD_EXP 195
84267: PPUSH
84268: LD_VAR 0 1
84272: PPUSH
84273: EMPTY
84274: PPUSH
84275: CALL_OW 1
84279: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
84280: LD_ADDR_EXP 196
84284: PUSH
84285: LD_EXP 196
84289: PPUSH
84290: LD_VAR 0 1
84294: PPUSH
84295: EMPTY
84296: PPUSH
84297: CALL_OW 1
84301: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
84302: LD_ADDR_EXP 197
84306: PUSH
84307: LD_EXP 197
84311: PPUSH
84312: LD_VAR 0 1
84316: PPUSH
84317: EMPTY
84318: PPUSH
84319: CALL_OW 1
84323: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
84324: LD_ADDR_EXP 198
84328: PUSH
84329: LD_EXP 198
84333: PPUSH
84334: LD_VAR 0 1
84338: PPUSH
84339: EMPTY
84340: PPUSH
84341: CALL_OW 1
84345: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
84346: LD_ADDR_EXP 199
84350: PUSH
84351: LD_EXP 199
84355: PPUSH
84356: LD_VAR 0 1
84360: PPUSH
84361: EMPTY
84362: PPUSH
84363: CALL_OW 1
84367: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
84368: LD_ADDR_EXP 200
84372: PUSH
84373: LD_EXP 200
84377: PPUSH
84378: LD_VAR 0 1
84382: PPUSH
84383: EMPTY
84384: PPUSH
84385: CALL_OW 1
84389: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
84390: LD_ADDR_EXP 202
84394: PUSH
84395: LD_EXP 202
84399: PPUSH
84400: LD_VAR 0 1
84404: PPUSH
84405: EMPTY
84406: PPUSH
84407: CALL_OW 1
84411: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
84412: LD_ADDR_EXP 204
84416: PUSH
84417: LD_EXP 204
84421: PPUSH
84422: LD_VAR 0 1
84426: PPUSH
84427: EMPTY
84428: PPUSH
84429: CALL_OW 1
84433: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
84434: LD_ADDR_EXP 205
84438: PUSH
84439: LD_EXP 205
84443: PPUSH
84444: LD_VAR 0 1
84448: PPUSH
84449: EMPTY
84450: PPUSH
84451: CALL_OW 1
84455: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
84456: LD_ADDR_EXP 206
84460: PUSH
84461: LD_EXP 206
84465: PPUSH
84466: LD_VAR 0 1
84470: PPUSH
84471: EMPTY
84472: PPUSH
84473: CALL_OW 1
84477: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
84478: LD_ADDR_EXP 207
84482: PUSH
84483: LD_EXP 207
84487: PPUSH
84488: LD_VAR 0 1
84492: PPUSH
84493: EMPTY
84494: PPUSH
84495: CALL_OW 1
84499: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
84500: LD_ADDR_EXP 208
84504: PUSH
84505: LD_EXP 208
84509: PPUSH
84510: LD_VAR 0 1
84514: PPUSH
84515: EMPTY
84516: PPUSH
84517: CALL_OW 1
84521: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
84522: LD_ADDR_EXP 209
84526: PUSH
84527: LD_EXP 209
84531: PPUSH
84532: LD_VAR 0 1
84536: PPUSH
84537: EMPTY
84538: PPUSH
84539: CALL_OW 1
84543: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
84544: LD_ADDR_EXP 210
84548: PUSH
84549: LD_EXP 210
84553: PPUSH
84554: LD_VAR 0 1
84558: PPUSH
84559: EMPTY
84560: PPUSH
84561: CALL_OW 1
84565: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
84566: LD_ADDR_EXP 211
84570: PUSH
84571: LD_EXP 211
84575: PPUSH
84576: LD_VAR 0 1
84580: PPUSH
84581: EMPTY
84582: PPUSH
84583: CALL_OW 1
84587: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
84588: LD_ADDR_EXP 212
84592: PUSH
84593: LD_EXP 212
84597: PPUSH
84598: LD_VAR 0 1
84602: PPUSH
84603: EMPTY
84604: PPUSH
84605: CALL_OW 1
84609: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
84610: LD_ADDR_EXP 213
84614: PUSH
84615: LD_EXP 213
84619: PPUSH
84620: LD_VAR 0 1
84624: PPUSH
84625: EMPTY
84626: PPUSH
84627: CALL_OW 1
84631: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
84632: LD_ADDR_EXP 214
84636: PUSH
84637: LD_EXP 214
84641: PPUSH
84642: LD_VAR 0 1
84646: PPUSH
84647: EMPTY
84648: PPUSH
84649: CALL_OW 1
84653: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
84654: LD_ADDR_EXP 215
84658: PUSH
84659: LD_EXP 215
84663: PPUSH
84664: LD_VAR 0 1
84668: PPUSH
84669: EMPTY
84670: PPUSH
84671: CALL_OW 1
84675: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
84676: LD_ADDR_EXP 216
84680: PUSH
84681: LD_EXP 216
84685: PPUSH
84686: LD_VAR 0 1
84690: PPUSH
84691: EMPTY
84692: PPUSH
84693: CALL_OW 1
84697: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
84698: LD_ADDR_EXP 217
84702: PUSH
84703: LD_EXP 217
84707: PPUSH
84708: LD_VAR 0 1
84712: PPUSH
84713: LD_INT 0
84715: PPUSH
84716: CALL_OW 1
84720: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
84721: LD_ADDR_EXP 218
84725: PUSH
84726: LD_EXP 218
84730: PPUSH
84731: LD_VAR 0 1
84735: PPUSH
84736: LD_INT 0
84738: PPUSH
84739: CALL_OW 1
84743: ST_TO_ADDR
// end ;
84744: LD_VAR 0 2
84748: RET
// export function MC_Add ( side , units ) ; var base ; begin
84749: LD_INT 0
84751: PPUSH
84752: PPUSH
// base := mc_bases + 1 ;
84753: LD_ADDR_VAR 0 4
84757: PUSH
84758: LD_EXP 175
84762: PUSH
84763: LD_INT 1
84765: PLUS
84766: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
84767: LD_ADDR_EXP 201
84771: PUSH
84772: LD_EXP 201
84776: PPUSH
84777: LD_VAR 0 4
84781: PPUSH
84782: LD_VAR 0 1
84786: PPUSH
84787: CALL_OW 1
84791: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
84792: LD_ADDR_EXP 175
84796: PUSH
84797: LD_EXP 175
84801: PPUSH
84802: LD_VAR 0 4
84806: PPUSH
84807: LD_VAR 0 2
84811: PPUSH
84812: CALL_OW 1
84816: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
84817: LD_ADDR_EXP 176
84821: PUSH
84822: LD_EXP 176
84826: PPUSH
84827: LD_VAR 0 4
84831: PPUSH
84832: EMPTY
84833: PPUSH
84834: CALL_OW 1
84838: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
84839: LD_ADDR_EXP 177
84843: PUSH
84844: LD_EXP 177
84848: PPUSH
84849: LD_VAR 0 4
84853: PPUSH
84854: EMPTY
84855: PPUSH
84856: CALL_OW 1
84860: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
84861: LD_ADDR_EXP 178
84865: PUSH
84866: LD_EXP 178
84870: PPUSH
84871: LD_VAR 0 4
84875: PPUSH
84876: EMPTY
84877: PPUSH
84878: CALL_OW 1
84882: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
84883: LD_ADDR_EXP 179
84887: PUSH
84888: LD_EXP 179
84892: PPUSH
84893: LD_VAR 0 4
84897: PPUSH
84898: EMPTY
84899: PPUSH
84900: CALL_OW 1
84904: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
84905: LD_ADDR_EXP 180
84909: PUSH
84910: LD_EXP 180
84914: PPUSH
84915: LD_VAR 0 4
84919: PPUSH
84920: EMPTY
84921: PPUSH
84922: CALL_OW 1
84926: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
84927: LD_ADDR_EXP 181
84931: PUSH
84932: LD_EXP 181
84936: PPUSH
84937: LD_VAR 0 4
84941: PPUSH
84942: EMPTY
84943: PPUSH
84944: CALL_OW 1
84948: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
84949: LD_ADDR_EXP 182
84953: PUSH
84954: LD_EXP 182
84958: PPUSH
84959: LD_VAR 0 4
84963: PPUSH
84964: EMPTY
84965: PPUSH
84966: CALL_OW 1
84970: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
84971: LD_ADDR_EXP 183
84975: PUSH
84976: LD_EXP 183
84980: PPUSH
84981: LD_VAR 0 4
84985: PPUSH
84986: EMPTY
84987: PPUSH
84988: CALL_OW 1
84992: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
84993: LD_ADDR_EXP 184
84997: PUSH
84998: LD_EXP 184
85002: PPUSH
85003: LD_VAR 0 4
85007: PPUSH
85008: EMPTY
85009: PPUSH
85010: CALL_OW 1
85014: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
85015: LD_ADDR_EXP 185
85019: PUSH
85020: LD_EXP 185
85024: PPUSH
85025: LD_VAR 0 4
85029: PPUSH
85030: EMPTY
85031: PPUSH
85032: CALL_OW 1
85036: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
85037: LD_ADDR_EXP 186
85041: PUSH
85042: LD_EXP 186
85046: PPUSH
85047: LD_VAR 0 4
85051: PPUSH
85052: LD_INT 0
85054: PPUSH
85055: CALL_OW 1
85059: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
85060: LD_ADDR_EXP 187
85064: PUSH
85065: LD_EXP 187
85069: PPUSH
85070: LD_VAR 0 4
85074: PPUSH
85075: EMPTY
85076: PPUSH
85077: CALL_OW 1
85081: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
85082: LD_ADDR_EXP 188
85086: PUSH
85087: LD_EXP 188
85091: PPUSH
85092: LD_VAR 0 4
85096: PPUSH
85097: EMPTY
85098: PPUSH
85099: CALL_OW 1
85103: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
85104: LD_ADDR_EXP 189
85108: PUSH
85109: LD_EXP 189
85113: PPUSH
85114: LD_VAR 0 4
85118: PPUSH
85119: EMPTY
85120: PPUSH
85121: CALL_OW 1
85125: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
85126: LD_ADDR_EXP 190
85130: PUSH
85131: LD_EXP 190
85135: PPUSH
85136: LD_VAR 0 4
85140: PPUSH
85141: EMPTY
85142: PPUSH
85143: CALL_OW 1
85147: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
85148: LD_ADDR_EXP 191
85152: PUSH
85153: LD_EXP 191
85157: PPUSH
85158: LD_VAR 0 4
85162: PPUSH
85163: EMPTY
85164: PPUSH
85165: CALL_OW 1
85169: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
85170: LD_ADDR_EXP 192
85174: PUSH
85175: LD_EXP 192
85179: PPUSH
85180: LD_VAR 0 4
85184: PPUSH
85185: EMPTY
85186: PPUSH
85187: CALL_OW 1
85191: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
85192: LD_ADDR_EXP 193
85196: PUSH
85197: LD_EXP 193
85201: PPUSH
85202: LD_VAR 0 4
85206: PPUSH
85207: EMPTY
85208: PPUSH
85209: CALL_OW 1
85213: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
85214: LD_ADDR_EXP 194
85218: PUSH
85219: LD_EXP 194
85223: PPUSH
85224: LD_VAR 0 4
85228: PPUSH
85229: EMPTY
85230: PPUSH
85231: CALL_OW 1
85235: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
85236: LD_ADDR_EXP 195
85240: PUSH
85241: LD_EXP 195
85245: PPUSH
85246: LD_VAR 0 4
85250: PPUSH
85251: EMPTY
85252: PPUSH
85253: CALL_OW 1
85257: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
85258: LD_ADDR_EXP 196
85262: PUSH
85263: LD_EXP 196
85267: PPUSH
85268: LD_VAR 0 4
85272: PPUSH
85273: EMPTY
85274: PPUSH
85275: CALL_OW 1
85279: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
85280: LD_ADDR_EXP 197
85284: PUSH
85285: LD_EXP 197
85289: PPUSH
85290: LD_VAR 0 4
85294: PPUSH
85295: EMPTY
85296: PPUSH
85297: CALL_OW 1
85301: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
85302: LD_ADDR_EXP 198
85306: PUSH
85307: LD_EXP 198
85311: PPUSH
85312: LD_VAR 0 4
85316: PPUSH
85317: EMPTY
85318: PPUSH
85319: CALL_OW 1
85323: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
85324: LD_ADDR_EXP 199
85328: PUSH
85329: LD_EXP 199
85333: PPUSH
85334: LD_VAR 0 4
85338: PPUSH
85339: EMPTY
85340: PPUSH
85341: CALL_OW 1
85345: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
85346: LD_ADDR_EXP 200
85350: PUSH
85351: LD_EXP 200
85355: PPUSH
85356: LD_VAR 0 4
85360: PPUSH
85361: EMPTY
85362: PPUSH
85363: CALL_OW 1
85367: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
85368: LD_ADDR_EXP 202
85372: PUSH
85373: LD_EXP 202
85377: PPUSH
85378: LD_VAR 0 4
85382: PPUSH
85383: EMPTY
85384: PPUSH
85385: CALL_OW 1
85389: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
85390: LD_ADDR_EXP 204
85394: PUSH
85395: LD_EXP 204
85399: PPUSH
85400: LD_VAR 0 4
85404: PPUSH
85405: EMPTY
85406: PPUSH
85407: CALL_OW 1
85411: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
85412: LD_ADDR_EXP 205
85416: PUSH
85417: LD_EXP 205
85421: PPUSH
85422: LD_VAR 0 4
85426: PPUSH
85427: EMPTY
85428: PPUSH
85429: CALL_OW 1
85433: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
85434: LD_ADDR_EXP 206
85438: PUSH
85439: LD_EXP 206
85443: PPUSH
85444: LD_VAR 0 4
85448: PPUSH
85449: EMPTY
85450: PPUSH
85451: CALL_OW 1
85455: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
85456: LD_ADDR_EXP 207
85460: PUSH
85461: LD_EXP 207
85465: PPUSH
85466: LD_VAR 0 4
85470: PPUSH
85471: EMPTY
85472: PPUSH
85473: CALL_OW 1
85477: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
85478: LD_ADDR_EXP 208
85482: PUSH
85483: LD_EXP 208
85487: PPUSH
85488: LD_VAR 0 4
85492: PPUSH
85493: EMPTY
85494: PPUSH
85495: CALL_OW 1
85499: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
85500: LD_ADDR_EXP 209
85504: PUSH
85505: LD_EXP 209
85509: PPUSH
85510: LD_VAR 0 4
85514: PPUSH
85515: EMPTY
85516: PPUSH
85517: CALL_OW 1
85521: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
85522: LD_ADDR_EXP 210
85526: PUSH
85527: LD_EXP 210
85531: PPUSH
85532: LD_VAR 0 4
85536: PPUSH
85537: EMPTY
85538: PPUSH
85539: CALL_OW 1
85543: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
85544: LD_ADDR_EXP 211
85548: PUSH
85549: LD_EXP 211
85553: PPUSH
85554: LD_VAR 0 4
85558: PPUSH
85559: EMPTY
85560: PPUSH
85561: CALL_OW 1
85565: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
85566: LD_ADDR_EXP 212
85570: PUSH
85571: LD_EXP 212
85575: PPUSH
85576: LD_VAR 0 4
85580: PPUSH
85581: EMPTY
85582: PPUSH
85583: CALL_OW 1
85587: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
85588: LD_ADDR_EXP 213
85592: PUSH
85593: LD_EXP 213
85597: PPUSH
85598: LD_VAR 0 4
85602: PPUSH
85603: EMPTY
85604: PPUSH
85605: CALL_OW 1
85609: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
85610: LD_ADDR_EXP 214
85614: PUSH
85615: LD_EXP 214
85619: PPUSH
85620: LD_VAR 0 4
85624: PPUSH
85625: EMPTY
85626: PPUSH
85627: CALL_OW 1
85631: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
85632: LD_ADDR_EXP 215
85636: PUSH
85637: LD_EXP 215
85641: PPUSH
85642: LD_VAR 0 4
85646: PPUSH
85647: EMPTY
85648: PPUSH
85649: CALL_OW 1
85653: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
85654: LD_ADDR_EXP 216
85658: PUSH
85659: LD_EXP 216
85663: PPUSH
85664: LD_VAR 0 4
85668: PPUSH
85669: EMPTY
85670: PPUSH
85671: CALL_OW 1
85675: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
85676: LD_ADDR_EXP 217
85680: PUSH
85681: LD_EXP 217
85685: PPUSH
85686: LD_VAR 0 4
85690: PPUSH
85691: LD_INT 0
85693: PPUSH
85694: CALL_OW 1
85698: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
85699: LD_ADDR_EXP 218
85703: PUSH
85704: LD_EXP 218
85708: PPUSH
85709: LD_VAR 0 4
85713: PPUSH
85714: LD_INT 0
85716: PPUSH
85717: CALL_OW 1
85721: ST_TO_ADDR
// result := base ;
85722: LD_ADDR_VAR 0 3
85726: PUSH
85727: LD_VAR 0 4
85731: ST_TO_ADDR
// end ;
85732: LD_VAR 0 3
85736: RET
// export function MC_Start ( ) ; var i ; begin
85737: LD_INT 0
85739: PPUSH
85740: PPUSH
// for i = 1 to mc_bases do
85741: LD_ADDR_VAR 0 2
85745: PUSH
85746: DOUBLE
85747: LD_INT 1
85749: DEC
85750: ST_TO_ADDR
85751: LD_EXP 175
85755: PUSH
85756: FOR_TO
85757: IFFALSE 86857
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
85759: LD_ADDR_EXP 175
85763: PUSH
85764: LD_EXP 175
85768: PPUSH
85769: LD_VAR 0 2
85773: PPUSH
85774: LD_EXP 175
85778: PUSH
85779: LD_VAR 0 2
85783: ARRAY
85784: PUSH
85785: LD_INT 0
85787: DIFF
85788: PPUSH
85789: CALL_OW 1
85793: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
85794: LD_ADDR_EXP 176
85798: PUSH
85799: LD_EXP 176
85803: PPUSH
85804: LD_VAR 0 2
85808: PPUSH
85809: EMPTY
85810: PPUSH
85811: CALL_OW 1
85815: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
85816: LD_ADDR_EXP 177
85820: PUSH
85821: LD_EXP 177
85825: PPUSH
85826: LD_VAR 0 2
85830: PPUSH
85831: EMPTY
85832: PPUSH
85833: CALL_OW 1
85837: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
85838: LD_ADDR_EXP 178
85842: PUSH
85843: LD_EXP 178
85847: PPUSH
85848: LD_VAR 0 2
85852: PPUSH
85853: EMPTY
85854: PPUSH
85855: CALL_OW 1
85859: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
85860: LD_ADDR_EXP 179
85864: PUSH
85865: LD_EXP 179
85869: PPUSH
85870: LD_VAR 0 2
85874: PPUSH
85875: EMPTY
85876: PUSH
85877: EMPTY
85878: PUSH
85879: EMPTY
85880: LIST
85881: LIST
85882: PPUSH
85883: CALL_OW 1
85887: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
85888: LD_ADDR_EXP 180
85892: PUSH
85893: LD_EXP 180
85897: PPUSH
85898: LD_VAR 0 2
85902: PPUSH
85903: EMPTY
85904: PPUSH
85905: CALL_OW 1
85909: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
85910: LD_ADDR_EXP 207
85914: PUSH
85915: LD_EXP 207
85919: PPUSH
85920: LD_VAR 0 2
85924: PPUSH
85925: EMPTY
85926: PPUSH
85927: CALL_OW 1
85931: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
85932: LD_ADDR_EXP 181
85936: PUSH
85937: LD_EXP 181
85941: PPUSH
85942: LD_VAR 0 2
85946: PPUSH
85947: EMPTY
85948: PPUSH
85949: CALL_OW 1
85953: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
85954: LD_ADDR_EXP 182
85958: PUSH
85959: LD_EXP 182
85963: PPUSH
85964: LD_VAR 0 2
85968: PPUSH
85969: EMPTY
85970: PPUSH
85971: CALL_OW 1
85975: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
85976: LD_ADDR_EXP 183
85980: PUSH
85981: LD_EXP 183
85985: PPUSH
85986: LD_VAR 0 2
85990: PPUSH
85991: LD_EXP 175
85995: PUSH
85996: LD_VAR 0 2
86000: ARRAY
86001: PPUSH
86002: LD_INT 2
86004: PUSH
86005: LD_INT 30
86007: PUSH
86008: LD_INT 32
86010: PUSH
86011: EMPTY
86012: LIST
86013: LIST
86014: PUSH
86015: LD_INT 30
86017: PUSH
86018: LD_INT 33
86020: PUSH
86021: EMPTY
86022: LIST
86023: LIST
86024: PUSH
86025: EMPTY
86026: LIST
86027: LIST
86028: LIST
86029: PPUSH
86030: CALL_OW 72
86034: PPUSH
86035: CALL_OW 1
86039: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
86040: LD_ADDR_EXP 184
86044: PUSH
86045: LD_EXP 184
86049: PPUSH
86050: LD_VAR 0 2
86054: PPUSH
86055: LD_EXP 175
86059: PUSH
86060: LD_VAR 0 2
86064: ARRAY
86065: PPUSH
86066: LD_INT 2
86068: PUSH
86069: LD_INT 30
86071: PUSH
86072: LD_INT 32
86074: PUSH
86075: EMPTY
86076: LIST
86077: LIST
86078: PUSH
86079: LD_INT 30
86081: PUSH
86082: LD_INT 31
86084: PUSH
86085: EMPTY
86086: LIST
86087: LIST
86088: PUSH
86089: EMPTY
86090: LIST
86091: LIST
86092: LIST
86093: PUSH
86094: LD_INT 58
86096: PUSH
86097: EMPTY
86098: LIST
86099: PUSH
86100: EMPTY
86101: LIST
86102: LIST
86103: PPUSH
86104: CALL_OW 72
86108: PPUSH
86109: CALL_OW 1
86113: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
86114: LD_ADDR_EXP 185
86118: PUSH
86119: LD_EXP 185
86123: PPUSH
86124: LD_VAR 0 2
86128: PPUSH
86129: EMPTY
86130: PPUSH
86131: CALL_OW 1
86135: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
86136: LD_ADDR_EXP 189
86140: PUSH
86141: LD_EXP 189
86145: PPUSH
86146: LD_VAR 0 2
86150: PPUSH
86151: EMPTY
86152: PPUSH
86153: CALL_OW 1
86157: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
86158: LD_ADDR_EXP 188
86162: PUSH
86163: LD_EXP 188
86167: PPUSH
86168: LD_VAR 0 2
86172: PPUSH
86173: EMPTY
86174: PPUSH
86175: CALL_OW 1
86179: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
86180: LD_ADDR_EXP 190
86184: PUSH
86185: LD_EXP 190
86189: PPUSH
86190: LD_VAR 0 2
86194: PPUSH
86195: EMPTY
86196: PPUSH
86197: CALL_OW 1
86201: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
86202: LD_ADDR_EXP 191
86206: PUSH
86207: LD_EXP 191
86211: PPUSH
86212: LD_VAR 0 2
86216: PPUSH
86217: EMPTY
86218: PPUSH
86219: CALL_OW 1
86223: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
86224: LD_ADDR_EXP 192
86228: PUSH
86229: LD_EXP 192
86233: PPUSH
86234: LD_VAR 0 2
86238: PPUSH
86239: EMPTY
86240: PPUSH
86241: CALL_OW 1
86245: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
86246: LD_ADDR_EXP 193
86250: PUSH
86251: LD_EXP 193
86255: PPUSH
86256: LD_VAR 0 2
86260: PPUSH
86261: EMPTY
86262: PPUSH
86263: CALL_OW 1
86267: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
86268: LD_ADDR_EXP 194
86272: PUSH
86273: LD_EXP 194
86277: PPUSH
86278: LD_VAR 0 2
86282: PPUSH
86283: EMPTY
86284: PPUSH
86285: CALL_OW 1
86289: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
86290: LD_ADDR_EXP 195
86294: PUSH
86295: LD_EXP 195
86299: PPUSH
86300: LD_VAR 0 2
86304: PPUSH
86305: EMPTY
86306: PPUSH
86307: CALL_OW 1
86311: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
86312: LD_ADDR_EXP 196
86316: PUSH
86317: LD_EXP 196
86321: PPUSH
86322: LD_VAR 0 2
86326: PPUSH
86327: EMPTY
86328: PPUSH
86329: CALL_OW 1
86333: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
86334: LD_ADDR_EXP 197
86338: PUSH
86339: LD_EXP 197
86343: PPUSH
86344: LD_VAR 0 2
86348: PPUSH
86349: EMPTY
86350: PPUSH
86351: CALL_OW 1
86355: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
86356: LD_ADDR_EXP 186
86360: PUSH
86361: LD_EXP 186
86365: PPUSH
86366: LD_VAR 0 2
86370: PPUSH
86371: LD_INT 0
86373: PPUSH
86374: CALL_OW 1
86378: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
86379: LD_ADDR_EXP 199
86383: PUSH
86384: LD_EXP 199
86388: PPUSH
86389: LD_VAR 0 2
86393: PPUSH
86394: LD_INT 0
86396: PPUSH
86397: CALL_OW 1
86401: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
86402: LD_ADDR_EXP 187
86406: PUSH
86407: LD_EXP 187
86411: PPUSH
86412: LD_VAR 0 2
86416: PPUSH
86417: EMPTY
86418: PPUSH
86419: CALL_OW 1
86423: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
86424: LD_ADDR_EXP 198
86428: PUSH
86429: LD_EXP 198
86433: PPUSH
86434: LD_VAR 0 2
86438: PPUSH
86439: LD_INT 0
86441: PPUSH
86442: CALL_OW 1
86446: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
86447: LD_ADDR_EXP 200
86451: PUSH
86452: LD_EXP 200
86456: PPUSH
86457: LD_VAR 0 2
86461: PPUSH
86462: EMPTY
86463: PPUSH
86464: CALL_OW 1
86468: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
86469: LD_ADDR_EXP 203
86473: PUSH
86474: LD_EXP 203
86478: PPUSH
86479: LD_VAR 0 2
86483: PPUSH
86484: LD_INT 0
86486: PPUSH
86487: CALL_OW 1
86491: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
86492: LD_ADDR_EXP 204
86496: PUSH
86497: LD_EXP 204
86501: PPUSH
86502: LD_VAR 0 2
86506: PPUSH
86507: EMPTY
86508: PPUSH
86509: CALL_OW 1
86513: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
86514: LD_ADDR_EXP 205
86518: PUSH
86519: LD_EXP 205
86523: PPUSH
86524: LD_VAR 0 2
86528: PPUSH
86529: EMPTY
86530: PPUSH
86531: CALL_OW 1
86535: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
86536: LD_ADDR_EXP 206
86540: PUSH
86541: LD_EXP 206
86545: PPUSH
86546: LD_VAR 0 2
86550: PPUSH
86551: EMPTY
86552: PPUSH
86553: CALL_OW 1
86557: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
86558: LD_ADDR_EXP 208
86562: PUSH
86563: LD_EXP 208
86567: PPUSH
86568: LD_VAR 0 2
86572: PPUSH
86573: LD_EXP 175
86577: PUSH
86578: LD_VAR 0 2
86582: ARRAY
86583: PPUSH
86584: LD_INT 2
86586: PUSH
86587: LD_INT 30
86589: PUSH
86590: LD_INT 6
86592: PUSH
86593: EMPTY
86594: LIST
86595: LIST
86596: PUSH
86597: LD_INT 30
86599: PUSH
86600: LD_INT 7
86602: PUSH
86603: EMPTY
86604: LIST
86605: LIST
86606: PUSH
86607: LD_INT 30
86609: PUSH
86610: LD_INT 8
86612: PUSH
86613: EMPTY
86614: LIST
86615: LIST
86616: PUSH
86617: EMPTY
86618: LIST
86619: LIST
86620: LIST
86621: LIST
86622: PPUSH
86623: CALL_OW 72
86627: PPUSH
86628: CALL_OW 1
86632: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
86633: LD_ADDR_EXP 209
86637: PUSH
86638: LD_EXP 209
86642: PPUSH
86643: LD_VAR 0 2
86647: PPUSH
86648: EMPTY
86649: PPUSH
86650: CALL_OW 1
86654: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
86655: LD_ADDR_EXP 210
86659: PUSH
86660: LD_EXP 210
86664: PPUSH
86665: LD_VAR 0 2
86669: PPUSH
86670: EMPTY
86671: PPUSH
86672: CALL_OW 1
86676: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
86677: LD_ADDR_EXP 211
86681: PUSH
86682: LD_EXP 211
86686: PPUSH
86687: LD_VAR 0 2
86691: PPUSH
86692: EMPTY
86693: PPUSH
86694: CALL_OW 1
86698: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
86699: LD_ADDR_EXP 212
86703: PUSH
86704: LD_EXP 212
86708: PPUSH
86709: LD_VAR 0 2
86713: PPUSH
86714: EMPTY
86715: PPUSH
86716: CALL_OW 1
86720: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
86721: LD_ADDR_EXP 213
86725: PUSH
86726: LD_EXP 213
86730: PPUSH
86731: LD_VAR 0 2
86735: PPUSH
86736: EMPTY
86737: PPUSH
86738: CALL_OW 1
86742: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
86743: LD_ADDR_EXP 214
86747: PUSH
86748: LD_EXP 214
86752: PPUSH
86753: LD_VAR 0 2
86757: PPUSH
86758: EMPTY
86759: PPUSH
86760: CALL_OW 1
86764: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
86765: LD_ADDR_EXP 215
86769: PUSH
86770: LD_EXP 215
86774: PPUSH
86775: LD_VAR 0 2
86779: PPUSH
86780: EMPTY
86781: PPUSH
86782: CALL_OW 1
86786: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
86787: LD_ADDR_EXP 216
86791: PUSH
86792: LD_EXP 216
86796: PPUSH
86797: LD_VAR 0 2
86801: PPUSH
86802: EMPTY
86803: PPUSH
86804: CALL_OW 1
86808: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
86809: LD_ADDR_EXP 217
86813: PUSH
86814: LD_EXP 217
86818: PPUSH
86819: LD_VAR 0 2
86823: PPUSH
86824: LD_INT 0
86826: PPUSH
86827: CALL_OW 1
86831: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
86832: LD_ADDR_EXP 218
86836: PUSH
86837: LD_EXP 218
86841: PPUSH
86842: LD_VAR 0 2
86846: PPUSH
86847: LD_INT 0
86849: PPUSH
86850: CALL_OW 1
86854: ST_TO_ADDR
// end ;
86855: GO 85756
86857: POP
86858: POP
// MC_InitSides ( ) ;
86859: CALL 87145 0 0
// MC_InitResearch ( ) ;
86863: CALL 86884 0 0
// CustomInitMacro ( ) ;
86867: CALL 350 0 0
// skirmish := true ;
86871: LD_ADDR_EXP 173
86875: PUSH
86876: LD_INT 1
86878: ST_TO_ADDR
// end ;
86879: LD_VAR 0 1
86883: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
86884: LD_INT 0
86886: PPUSH
86887: PPUSH
86888: PPUSH
86889: PPUSH
86890: PPUSH
86891: PPUSH
// if not mc_bases then
86892: LD_EXP 175
86896: NOT
86897: IFFALSE 86901
// exit ;
86899: GO 87140
// for i = 1 to 8 do
86901: LD_ADDR_VAR 0 2
86905: PUSH
86906: DOUBLE
86907: LD_INT 1
86909: DEC
86910: ST_TO_ADDR
86911: LD_INT 8
86913: PUSH
86914: FOR_TO
86915: IFFALSE 86941
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
86917: LD_ADDR_EXP 202
86921: PUSH
86922: LD_EXP 202
86926: PPUSH
86927: LD_VAR 0 2
86931: PPUSH
86932: EMPTY
86933: PPUSH
86934: CALL_OW 1
86938: ST_TO_ADDR
86939: GO 86914
86941: POP
86942: POP
// tmp := [ ] ;
86943: LD_ADDR_VAR 0 5
86947: PUSH
86948: EMPTY
86949: ST_TO_ADDR
// for i = 1 to mc_sides do
86950: LD_ADDR_VAR 0 2
86954: PUSH
86955: DOUBLE
86956: LD_INT 1
86958: DEC
86959: ST_TO_ADDR
86960: LD_EXP 201
86964: PUSH
86965: FOR_TO
86966: IFFALSE 87024
// if not mc_sides [ i ] in tmp then
86968: LD_EXP 201
86972: PUSH
86973: LD_VAR 0 2
86977: ARRAY
86978: PUSH
86979: LD_VAR 0 5
86983: IN
86984: NOT
86985: IFFALSE 87022
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
86987: LD_ADDR_VAR 0 5
86991: PUSH
86992: LD_VAR 0 5
86996: PPUSH
86997: LD_VAR 0 5
87001: PUSH
87002: LD_INT 1
87004: PLUS
87005: PPUSH
87006: LD_EXP 201
87010: PUSH
87011: LD_VAR 0 2
87015: ARRAY
87016: PPUSH
87017: CALL_OW 2
87021: ST_TO_ADDR
87022: GO 86965
87024: POP
87025: POP
// if not tmp then
87026: LD_VAR 0 5
87030: NOT
87031: IFFALSE 87035
// exit ;
87033: GO 87140
// for j in tmp do
87035: LD_ADDR_VAR 0 3
87039: PUSH
87040: LD_VAR 0 5
87044: PUSH
87045: FOR_IN
87046: IFFALSE 87138
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
87048: LD_ADDR_VAR 0 6
87052: PUSH
87053: LD_INT 22
87055: PUSH
87056: LD_VAR 0 3
87060: PUSH
87061: EMPTY
87062: LIST
87063: LIST
87064: PPUSH
87065: CALL_OW 69
87069: ST_TO_ADDR
// if not un then
87070: LD_VAR 0 6
87074: NOT
87075: IFFALSE 87079
// continue ;
87077: GO 87045
// nation := GetNation ( un [ 1 ] ) ;
87079: LD_ADDR_VAR 0 4
87083: PUSH
87084: LD_VAR 0 6
87088: PUSH
87089: LD_INT 1
87091: ARRAY
87092: PPUSH
87093: CALL_OW 248
87097: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
87098: LD_ADDR_EXP 202
87102: PUSH
87103: LD_EXP 202
87107: PPUSH
87108: LD_VAR 0 3
87112: PPUSH
87113: LD_VAR 0 3
87117: PPUSH
87118: LD_VAR 0 4
87122: PPUSH
87123: LD_INT 1
87125: PPUSH
87126: CALL 19287 0 3
87130: PPUSH
87131: CALL_OW 1
87135: ST_TO_ADDR
// end ;
87136: GO 87045
87138: POP
87139: POP
// end ;
87140: LD_VAR 0 1
87144: RET
// export function MC_InitSides ( ) ; var i ; begin
87145: LD_INT 0
87147: PPUSH
87148: PPUSH
// if not mc_bases then
87149: LD_EXP 175
87153: NOT
87154: IFFALSE 87158
// exit ;
87156: GO 87232
// for i = 1 to mc_bases do
87158: LD_ADDR_VAR 0 2
87162: PUSH
87163: DOUBLE
87164: LD_INT 1
87166: DEC
87167: ST_TO_ADDR
87168: LD_EXP 175
87172: PUSH
87173: FOR_TO
87174: IFFALSE 87230
// if mc_bases [ i ] then
87176: LD_EXP 175
87180: PUSH
87181: LD_VAR 0 2
87185: ARRAY
87186: IFFALSE 87228
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
87188: LD_ADDR_EXP 201
87192: PUSH
87193: LD_EXP 201
87197: PPUSH
87198: LD_VAR 0 2
87202: PPUSH
87203: LD_EXP 175
87207: PUSH
87208: LD_VAR 0 2
87212: ARRAY
87213: PUSH
87214: LD_INT 1
87216: ARRAY
87217: PPUSH
87218: CALL_OW 255
87222: PPUSH
87223: CALL_OW 1
87227: ST_TO_ADDR
87228: GO 87173
87230: POP
87231: POP
// end ;
87232: LD_VAR 0 1
87236: RET
// every 0 0$03 trigger skirmish do
87237: LD_EXP 173
87241: IFFALSE 87395
87243: GO 87245
87245: DISABLE
// begin enable ;
87246: ENABLE
// MC_CheckBuildings ( ) ;
87247: CALL 91893 0 0
// MC_CheckPeopleLife ( ) ;
87251: CALL 92054 0 0
// RaiseSailEvent ( 100 ) ;
87255: LD_INT 100
87257: PPUSH
87258: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
87262: LD_INT 103
87264: PPUSH
87265: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
87269: LD_INT 104
87271: PPUSH
87272: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
87276: LD_INT 105
87278: PPUSH
87279: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
87283: LD_INT 106
87285: PPUSH
87286: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
87290: LD_INT 107
87292: PPUSH
87293: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
87297: LD_INT 108
87299: PPUSH
87300: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
87304: LD_INT 109
87306: PPUSH
87307: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
87311: LD_INT 110
87313: PPUSH
87314: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
87318: LD_INT 111
87320: PPUSH
87321: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
87325: LD_INT 112
87327: PPUSH
87328: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
87332: LD_INT 113
87334: PPUSH
87335: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
87339: LD_INT 120
87341: PPUSH
87342: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
87346: LD_INT 121
87348: PPUSH
87349: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
87353: LD_INT 122
87355: PPUSH
87356: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
87360: LD_INT 123
87362: PPUSH
87363: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
87367: LD_INT 124
87369: PPUSH
87370: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
87374: LD_INT 125
87376: PPUSH
87377: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
87381: LD_INT 126
87383: PPUSH
87384: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
87388: LD_INT 200
87390: PPUSH
87391: CALL_OW 427
// end ;
87395: END
// on SailEvent ( event ) do begin if event < 100 then
87396: LD_VAR 0 1
87400: PUSH
87401: LD_INT 100
87403: LESS
87404: IFFALSE 87415
// CustomEvent ( event ) ;
87406: LD_VAR 0 1
87410: PPUSH
87411: CALL 16158 0 1
// if event = 100 then
87415: LD_VAR 0 1
87419: PUSH
87420: LD_INT 100
87422: EQUAL
87423: IFFALSE 87429
// MC_ClassManager ( ) ;
87425: CALL 87821 0 0
// if event = 101 then
87429: LD_VAR 0 1
87433: PUSH
87434: LD_INT 101
87436: EQUAL
87437: IFFALSE 87443
// MC_RepairBuildings ( ) ;
87439: CALL 92639 0 0
// if event = 102 then
87443: LD_VAR 0 1
87447: PUSH
87448: LD_INT 102
87450: EQUAL
87451: IFFALSE 87457
// MC_Heal ( ) ;
87453: CALL 93546 0 0
// if event = 103 then
87457: LD_VAR 0 1
87461: PUSH
87462: LD_INT 103
87464: EQUAL
87465: IFFALSE 87471
// MC_Build ( ) ;
87467: CALL 93968 0 0
// if event = 104 then
87471: LD_VAR 0 1
87475: PUSH
87476: LD_INT 104
87478: EQUAL
87479: IFFALSE 87485
// MC_TurretWeapon ( ) ;
87481: CALL 95609 0 0
// if event = 105 then
87485: LD_VAR 0 1
87489: PUSH
87490: LD_INT 105
87492: EQUAL
87493: IFFALSE 87499
// MC_BuildUpgrade ( ) ;
87495: CALL 95160 0 0
// if event = 106 then
87499: LD_VAR 0 1
87503: PUSH
87504: LD_INT 106
87506: EQUAL
87507: IFFALSE 87513
// MC_PlantMines ( ) ;
87509: CALL 96039 0 0
// if event = 107 then
87513: LD_VAR 0 1
87517: PUSH
87518: LD_INT 107
87520: EQUAL
87521: IFFALSE 87527
// MC_CollectCrates ( ) ;
87523: CALL 96830 0 0
// if event = 108 then
87527: LD_VAR 0 1
87531: PUSH
87532: LD_INT 108
87534: EQUAL
87535: IFFALSE 87541
// MC_LinkRemoteControl ( ) ;
87537: CALL 98680 0 0
// if event = 109 then
87541: LD_VAR 0 1
87545: PUSH
87546: LD_INT 109
87548: EQUAL
87549: IFFALSE 87555
// MC_ProduceVehicle ( ) ;
87551: CALL 98861 0 0
// if event = 110 then
87555: LD_VAR 0 1
87559: PUSH
87560: LD_INT 110
87562: EQUAL
87563: IFFALSE 87569
// MC_SendAttack ( ) ;
87565: CALL 99327 0 0
// if event = 111 then
87569: LD_VAR 0 1
87573: PUSH
87574: LD_INT 111
87576: EQUAL
87577: IFFALSE 87583
// MC_Defend ( ) ;
87579: CALL 99435 0 0
// if event = 112 then
87583: LD_VAR 0 1
87587: PUSH
87588: LD_INT 112
87590: EQUAL
87591: IFFALSE 87597
// MC_Research ( ) ;
87593: CALL 100168 0 0
// if event = 113 then
87597: LD_VAR 0 1
87601: PUSH
87602: LD_INT 113
87604: EQUAL
87605: IFFALSE 87611
// MC_MinesTrigger ( ) ;
87607: CALL 101282 0 0
// if event = 120 then
87611: LD_VAR 0 1
87615: PUSH
87616: LD_INT 120
87618: EQUAL
87619: IFFALSE 87625
// MC_RepairVehicle ( ) ;
87621: CALL 101381 0 0
// if event = 121 then
87625: LD_VAR 0 1
87629: PUSH
87630: LD_INT 121
87632: EQUAL
87633: IFFALSE 87639
// MC_TameApe ( ) ;
87635: CALL 102122 0 0
// if event = 122 then
87639: LD_VAR 0 1
87643: PUSH
87644: LD_INT 122
87646: EQUAL
87647: IFFALSE 87653
// MC_ChangeApeClass ( ) ;
87649: CALL 102951 0 0
// if event = 123 then
87653: LD_VAR 0 1
87657: PUSH
87658: LD_INT 123
87660: EQUAL
87661: IFFALSE 87667
// MC_Bazooka ( ) ;
87663: CALL 103601 0 0
// if event = 124 then
87667: LD_VAR 0 1
87671: PUSH
87672: LD_INT 124
87674: EQUAL
87675: IFFALSE 87681
// MC_TeleportExit ( ) ;
87677: CALL 103799 0 0
// if event = 125 then
87681: LD_VAR 0 1
87685: PUSH
87686: LD_INT 125
87688: EQUAL
87689: IFFALSE 87695
// MC_Deposits ( ) ;
87691: CALL 104446 0 0
// if event = 126 then
87695: LD_VAR 0 1
87699: PUSH
87700: LD_INT 126
87702: EQUAL
87703: IFFALSE 87709
// MC_RemoteDriver ( ) ;
87705: CALL 105071 0 0
// if event = 200 then
87709: LD_VAR 0 1
87713: PUSH
87714: LD_INT 200
87716: EQUAL
87717: IFFALSE 87723
// MC_Idle ( ) ;
87719: CALL 107020 0 0
// end ;
87723: PPOPN 1
87725: END
// export function MC_Reset ( base , tag ) ; var i ; begin
87726: LD_INT 0
87728: PPUSH
87729: PPUSH
// if not mc_bases [ base ] or not tag then
87730: LD_EXP 175
87734: PUSH
87735: LD_VAR 0 1
87739: ARRAY
87740: NOT
87741: PUSH
87742: LD_VAR 0 2
87746: NOT
87747: OR
87748: IFFALSE 87752
// exit ;
87750: GO 87816
// for i in mc_bases [ base ] union mc_ape [ base ] do
87752: LD_ADDR_VAR 0 4
87756: PUSH
87757: LD_EXP 175
87761: PUSH
87762: LD_VAR 0 1
87766: ARRAY
87767: PUSH
87768: LD_EXP 204
87772: PUSH
87773: LD_VAR 0 1
87777: ARRAY
87778: UNION
87779: PUSH
87780: FOR_IN
87781: IFFALSE 87814
// if GetTag ( i ) = tag then
87783: LD_VAR 0 4
87787: PPUSH
87788: CALL_OW 110
87792: PUSH
87793: LD_VAR 0 2
87797: EQUAL
87798: IFFALSE 87812
// SetTag ( i , 0 ) ;
87800: LD_VAR 0 4
87804: PPUSH
87805: LD_INT 0
87807: PPUSH
87808: CALL_OW 109
87812: GO 87780
87814: POP
87815: POP
// end ;
87816: LD_VAR 0 3
87820: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
87821: LD_INT 0
87823: PPUSH
87824: PPUSH
87825: PPUSH
87826: PPUSH
87827: PPUSH
87828: PPUSH
87829: PPUSH
87830: PPUSH
// if not mc_bases then
87831: LD_EXP 175
87835: NOT
87836: IFFALSE 87840
// exit ;
87838: GO 88298
// for i = 1 to mc_bases do
87840: LD_ADDR_VAR 0 2
87844: PUSH
87845: DOUBLE
87846: LD_INT 1
87848: DEC
87849: ST_TO_ADDR
87850: LD_EXP 175
87854: PUSH
87855: FOR_TO
87856: IFFALSE 88296
// begin tmp := MC_ClassCheckReq ( i ) ;
87858: LD_ADDR_VAR 0 4
87862: PUSH
87863: LD_VAR 0 2
87867: PPUSH
87868: CALL 88303 0 1
87872: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
87873: LD_ADDR_EXP 216
87877: PUSH
87878: LD_EXP 216
87882: PPUSH
87883: LD_VAR 0 2
87887: PPUSH
87888: LD_VAR 0 4
87892: PPUSH
87893: CALL_OW 1
87897: ST_TO_ADDR
// if not tmp then
87898: LD_VAR 0 4
87902: NOT
87903: IFFALSE 87907
// continue ;
87905: GO 87855
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
87907: LD_ADDR_VAR 0 6
87911: PUSH
87912: LD_EXP 175
87916: PUSH
87917: LD_VAR 0 2
87921: ARRAY
87922: PPUSH
87923: LD_INT 2
87925: PUSH
87926: LD_INT 30
87928: PUSH
87929: LD_INT 4
87931: PUSH
87932: EMPTY
87933: LIST
87934: LIST
87935: PUSH
87936: LD_INT 30
87938: PUSH
87939: LD_INT 5
87941: PUSH
87942: EMPTY
87943: LIST
87944: LIST
87945: PUSH
87946: EMPTY
87947: LIST
87948: LIST
87949: LIST
87950: PPUSH
87951: CALL_OW 72
87955: PUSH
87956: LD_EXP 175
87960: PUSH
87961: LD_VAR 0 2
87965: ARRAY
87966: PPUSH
87967: LD_INT 2
87969: PUSH
87970: LD_INT 30
87972: PUSH
87973: LD_INT 0
87975: PUSH
87976: EMPTY
87977: LIST
87978: LIST
87979: PUSH
87980: LD_INT 30
87982: PUSH
87983: LD_INT 1
87985: PUSH
87986: EMPTY
87987: LIST
87988: LIST
87989: PUSH
87990: EMPTY
87991: LIST
87992: LIST
87993: LIST
87994: PPUSH
87995: CALL_OW 72
87999: PUSH
88000: LD_EXP 175
88004: PUSH
88005: LD_VAR 0 2
88009: ARRAY
88010: PPUSH
88011: LD_INT 30
88013: PUSH
88014: LD_INT 3
88016: PUSH
88017: EMPTY
88018: LIST
88019: LIST
88020: PPUSH
88021: CALL_OW 72
88025: PUSH
88026: LD_EXP 175
88030: PUSH
88031: LD_VAR 0 2
88035: ARRAY
88036: PPUSH
88037: LD_INT 2
88039: PUSH
88040: LD_INT 30
88042: PUSH
88043: LD_INT 6
88045: PUSH
88046: EMPTY
88047: LIST
88048: LIST
88049: PUSH
88050: LD_INT 30
88052: PUSH
88053: LD_INT 7
88055: PUSH
88056: EMPTY
88057: LIST
88058: LIST
88059: PUSH
88060: LD_INT 30
88062: PUSH
88063: LD_INT 8
88065: PUSH
88066: EMPTY
88067: LIST
88068: LIST
88069: PUSH
88070: EMPTY
88071: LIST
88072: LIST
88073: LIST
88074: LIST
88075: PPUSH
88076: CALL_OW 72
88080: PUSH
88081: EMPTY
88082: LIST
88083: LIST
88084: LIST
88085: LIST
88086: ST_TO_ADDR
// for j = 1 to 4 do
88087: LD_ADDR_VAR 0 3
88091: PUSH
88092: DOUBLE
88093: LD_INT 1
88095: DEC
88096: ST_TO_ADDR
88097: LD_INT 4
88099: PUSH
88100: FOR_TO
88101: IFFALSE 88292
// begin if not tmp [ j ] then
88103: LD_VAR 0 4
88107: PUSH
88108: LD_VAR 0 3
88112: ARRAY
88113: NOT
88114: IFFALSE 88118
// continue ;
88116: GO 88100
// for p in tmp [ j ] do
88118: LD_ADDR_VAR 0 5
88122: PUSH
88123: LD_VAR 0 4
88127: PUSH
88128: LD_VAR 0 3
88132: ARRAY
88133: PUSH
88134: FOR_IN
88135: IFFALSE 88288
// begin if not b [ j ] then
88137: LD_VAR 0 6
88141: PUSH
88142: LD_VAR 0 3
88146: ARRAY
88147: NOT
88148: IFFALSE 88152
// break ;
88150: GO 88288
// e := 0 ;
88152: LD_ADDR_VAR 0 7
88156: PUSH
88157: LD_INT 0
88159: ST_TO_ADDR
// for k in b [ j ] do
88160: LD_ADDR_VAR 0 8
88164: PUSH
88165: LD_VAR 0 6
88169: PUSH
88170: LD_VAR 0 3
88174: ARRAY
88175: PUSH
88176: FOR_IN
88177: IFFALSE 88204
// if IsNotFull ( k ) then
88179: LD_VAR 0 8
88183: PPUSH
88184: CALL 21440 0 1
88188: IFFALSE 88202
// begin e := k ;
88190: LD_ADDR_VAR 0 7
88194: PUSH
88195: LD_VAR 0 8
88199: ST_TO_ADDR
// break ;
88200: GO 88204
// end ;
88202: GO 88176
88204: POP
88205: POP
// if e and not UnitGoingToBuilding ( p , e ) then
88206: LD_VAR 0 7
88210: PUSH
88211: LD_VAR 0 5
88215: PPUSH
88216: LD_VAR 0 7
88220: PPUSH
88221: CALL 54604 0 2
88225: NOT
88226: AND
88227: IFFALSE 88286
// begin if IsInUnit ( p ) then
88229: LD_VAR 0 5
88233: PPUSH
88234: CALL_OW 310
88238: IFFALSE 88249
// ComExitBuilding ( p ) ;
88240: LD_VAR 0 5
88244: PPUSH
88245: CALL_OW 122
// ComEnterUnit ( p , e ) ;
88249: LD_VAR 0 5
88253: PPUSH
88254: LD_VAR 0 7
88258: PPUSH
88259: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
88263: LD_VAR 0 5
88267: PPUSH
88268: LD_VAR 0 3
88272: PPUSH
88273: CALL_OW 183
// AddComExitBuilding ( p ) ;
88277: LD_VAR 0 5
88281: PPUSH
88282: CALL_OW 182
// end ; end ;
88286: GO 88134
88288: POP
88289: POP
// end ;
88290: GO 88100
88292: POP
88293: POP
// end ;
88294: GO 87855
88296: POP
88297: POP
// end ;
88298: LD_VAR 0 1
88302: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
88303: LD_INT 0
88305: PPUSH
88306: PPUSH
88307: PPUSH
88308: PPUSH
88309: PPUSH
88310: PPUSH
88311: PPUSH
88312: PPUSH
88313: PPUSH
88314: PPUSH
88315: PPUSH
88316: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
88317: LD_VAR 0 1
88321: NOT
88322: PUSH
88323: LD_EXP 175
88327: PUSH
88328: LD_VAR 0 1
88332: ARRAY
88333: NOT
88334: OR
88335: PUSH
88336: LD_EXP 175
88340: PUSH
88341: LD_VAR 0 1
88345: ARRAY
88346: PPUSH
88347: LD_INT 2
88349: PUSH
88350: LD_INT 30
88352: PUSH
88353: LD_INT 0
88355: PUSH
88356: EMPTY
88357: LIST
88358: LIST
88359: PUSH
88360: LD_INT 30
88362: PUSH
88363: LD_INT 1
88365: PUSH
88366: EMPTY
88367: LIST
88368: LIST
88369: PUSH
88370: EMPTY
88371: LIST
88372: LIST
88373: LIST
88374: PPUSH
88375: CALL_OW 72
88379: NOT
88380: OR
88381: IFFALSE 88385
// exit ;
88383: GO 91888
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
88385: LD_ADDR_VAR 0 4
88389: PUSH
88390: LD_EXP 175
88394: PUSH
88395: LD_VAR 0 1
88399: ARRAY
88400: PPUSH
88401: LD_INT 2
88403: PUSH
88404: LD_INT 25
88406: PUSH
88407: LD_INT 1
88409: PUSH
88410: EMPTY
88411: LIST
88412: LIST
88413: PUSH
88414: LD_INT 25
88416: PUSH
88417: LD_INT 2
88419: PUSH
88420: EMPTY
88421: LIST
88422: LIST
88423: PUSH
88424: LD_INT 25
88426: PUSH
88427: LD_INT 3
88429: PUSH
88430: EMPTY
88431: LIST
88432: LIST
88433: PUSH
88434: LD_INT 25
88436: PUSH
88437: LD_INT 4
88439: PUSH
88440: EMPTY
88441: LIST
88442: LIST
88443: PUSH
88444: LD_INT 25
88446: PUSH
88447: LD_INT 5
88449: PUSH
88450: EMPTY
88451: LIST
88452: LIST
88453: PUSH
88454: LD_INT 25
88456: PUSH
88457: LD_INT 8
88459: PUSH
88460: EMPTY
88461: LIST
88462: LIST
88463: PUSH
88464: LD_INT 25
88466: PUSH
88467: LD_INT 9
88469: PUSH
88470: EMPTY
88471: LIST
88472: LIST
88473: PUSH
88474: EMPTY
88475: LIST
88476: LIST
88477: LIST
88478: LIST
88479: LIST
88480: LIST
88481: LIST
88482: LIST
88483: PPUSH
88484: CALL_OW 72
88488: ST_TO_ADDR
// if not tmp then
88489: LD_VAR 0 4
88493: NOT
88494: IFFALSE 88498
// exit ;
88496: GO 91888
// for i in tmp do
88498: LD_ADDR_VAR 0 3
88502: PUSH
88503: LD_VAR 0 4
88507: PUSH
88508: FOR_IN
88509: IFFALSE 88540
// if GetTag ( i ) then
88511: LD_VAR 0 3
88515: PPUSH
88516: CALL_OW 110
88520: IFFALSE 88538
// tmp := tmp diff i ;
88522: LD_ADDR_VAR 0 4
88526: PUSH
88527: LD_VAR 0 4
88531: PUSH
88532: LD_VAR 0 3
88536: DIFF
88537: ST_TO_ADDR
88538: GO 88508
88540: POP
88541: POP
// if not tmp then
88542: LD_VAR 0 4
88546: NOT
88547: IFFALSE 88551
// exit ;
88549: GO 91888
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
88551: LD_ADDR_VAR 0 5
88555: PUSH
88556: LD_EXP 175
88560: PUSH
88561: LD_VAR 0 1
88565: ARRAY
88566: PPUSH
88567: LD_INT 2
88569: PUSH
88570: LD_INT 25
88572: PUSH
88573: LD_INT 1
88575: PUSH
88576: EMPTY
88577: LIST
88578: LIST
88579: PUSH
88580: LD_INT 25
88582: PUSH
88583: LD_INT 5
88585: PUSH
88586: EMPTY
88587: LIST
88588: LIST
88589: PUSH
88590: LD_INT 25
88592: PUSH
88593: LD_INT 8
88595: PUSH
88596: EMPTY
88597: LIST
88598: LIST
88599: PUSH
88600: LD_INT 25
88602: PUSH
88603: LD_INT 9
88605: PUSH
88606: EMPTY
88607: LIST
88608: LIST
88609: PUSH
88610: EMPTY
88611: LIST
88612: LIST
88613: LIST
88614: LIST
88615: LIST
88616: PPUSH
88617: CALL_OW 72
88621: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
88622: LD_ADDR_VAR 0 6
88626: PUSH
88627: LD_EXP 175
88631: PUSH
88632: LD_VAR 0 1
88636: ARRAY
88637: PPUSH
88638: LD_INT 25
88640: PUSH
88641: LD_INT 2
88643: PUSH
88644: EMPTY
88645: LIST
88646: LIST
88647: PPUSH
88648: CALL_OW 72
88652: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
88653: LD_ADDR_VAR 0 7
88657: PUSH
88658: LD_EXP 175
88662: PUSH
88663: LD_VAR 0 1
88667: ARRAY
88668: PPUSH
88669: LD_INT 25
88671: PUSH
88672: LD_INT 3
88674: PUSH
88675: EMPTY
88676: LIST
88677: LIST
88678: PPUSH
88679: CALL_OW 72
88683: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
88684: LD_ADDR_VAR 0 8
88688: PUSH
88689: LD_EXP 175
88693: PUSH
88694: LD_VAR 0 1
88698: ARRAY
88699: PPUSH
88700: LD_INT 25
88702: PUSH
88703: LD_INT 4
88705: PUSH
88706: EMPTY
88707: LIST
88708: LIST
88709: PUSH
88710: LD_INT 24
88712: PUSH
88713: LD_INT 251
88715: PUSH
88716: EMPTY
88717: LIST
88718: LIST
88719: PUSH
88720: EMPTY
88721: LIST
88722: LIST
88723: PPUSH
88724: CALL_OW 72
88728: ST_TO_ADDR
// if mc_is_defending [ base ] then
88729: LD_EXP 218
88733: PUSH
88734: LD_VAR 0 1
88738: ARRAY
88739: IFFALSE 89200
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
88741: LD_ADDR_EXP 217
88745: PUSH
88746: LD_EXP 217
88750: PPUSH
88751: LD_VAR 0 1
88755: PPUSH
88756: LD_INT 4
88758: PPUSH
88759: CALL_OW 1
88763: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
88764: LD_ADDR_VAR 0 12
88768: PUSH
88769: LD_EXP 175
88773: PUSH
88774: LD_VAR 0 1
88778: ARRAY
88779: PPUSH
88780: LD_INT 2
88782: PUSH
88783: LD_INT 30
88785: PUSH
88786: LD_INT 4
88788: PUSH
88789: EMPTY
88790: LIST
88791: LIST
88792: PUSH
88793: LD_INT 30
88795: PUSH
88796: LD_INT 5
88798: PUSH
88799: EMPTY
88800: LIST
88801: LIST
88802: PUSH
88803: EMPTY
88804: LIST
88805: LIST
88806: LIST
88807: PPUSH
88808: CALL_OW 72
88812: ST_TO_ADDR
// if not b then
88813: LD_VAR 0 12
88817: NOT
88818: IFFALSE 88822
// exit ;
88820: GO 91888
// p := [ ] ;
88822: LD_ADDR_VAR 0 11
88826: PUSH
88827: EMPTY
88828: ST_TO_ADDR
// if sci >= 2 then
88829: LD_VAR 0 8
88833: PUSH
88834: LD_INT 2
88836: GREATEREQUAL
88837: IFFALSE 88868
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
88839: LD_ADDR_VAR 0 8
88843: PUSH
88844: LD_VAR 0 8
88848: PUSH
88849: LD_INT 1
88851: ARRAY
88852: PUSH
88853: LD_VAR 0 8
88857: PUSH
88858: LD_INT 2
88860: ARRAY
88861: PUSH
88862: EMPTY
88863: LIST
88864: LIST
88865: ST_TO_ADDR
88866: GO 88929
// if sci = 1 then
88868: LD_VAR 0 8
88872: PUSH
88873: LD_INT 1
88875: EQUAL
88876: IFFALSE 88897
// sci := [ sci [ 1 ] ] else
88878: LD_ADDR_VAR 0 8
88882: PUSH
88883: LD_VAR 0 8
88887: PUSH
88888: LD_INT 1
88890: ARRAY
88891: PUSH
88892: EMPTY
88893: LIST
88894: ST_TO_ADDR
88895: GO 88929
// if sci = 0 then
88897: LD_VAR 0 8
88901: PUSH
88902: LD_INT 0
88904: EQUAL
88905: IFFALSE 88929
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
88907: LD_ADDR_VAR 0 11
88911: PUSH
88912: LD_VAR 0 4
88916: PPUSH
88917: LD_INT 4
88919: PPUSH
88920: CALL 54467 0 2
88924: PUSH
88925: LD_INT 1
88927: ARRAY
88928: ST_TO_ADDR
// if eng > 4 then
88929: LD_VAR 0 6
88933: PUSH
88934: LD_INT 4
88936: GREATER
88937: IFFALSE 88983
// for i = eng downto 4 do
88939: LD_ADDR_VAR 0 3
88943: PUSH
88944: DOUBLE
88945: LD_VAR 0 6
88949: INC
88950: ST_TO_ADDR
88951: LD_INT 4
88953: PUSH
88954: FOR_DOWNTO
88955: IFFALSE 88981
// eng := eng diff eng [ i ] ;
88957: LD_ADDR_VAR 0 6
88961: PUSH
88962: LD_VAR 0 6
88966: PUSH
88967: LD_VAR 0 6
88971: PUSH
88972: LD_VAR 0 3
88976: ARRAY
88977: DIFF
88978: ST_TO_ADDR
88979: GO 88954
88981: POP
88982: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
88983: LD_ADDR_VAR 0 4
88987: PUSH
88988: LD_VAR 0 4
88992: PUSH
88993: LD_VAR 0 5
88997: PUSH
88998: LD_VAR 0 6
89002: UNION
89003: PUSH
89004: LD_VAR 0 7
89008: UNION
89009: PUSH
89010: LD_VAR 0 8
89014: UNION
89015: DIFF
89016: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
89017: LD_ADDR_VAR 0 13
89021: PUSH
89022: LD_EXP 175
89026: PUSH
89027: LD_VAR 0 1
89031: ARRAY
89032: PPUSH
89033: LD_INT 2
89035: PUSH
89036: LD_INT 30
89038: PUSH
89039: LD_INT 32
89041: PUSH
89042: EMPTY
89043: LIST
89044: LIST
89045: PUSH
89046: LD_INT 30
89048: PUSH
89049: LD_INT 31
89051: PUSH
89052: EMPTY
89053: LIST
89054: LIST
89055: PUSH
89056: EMPTY
89057: LIST
89058: LIST
89059: LIST
89060: PPUSH
89061: CALL_OW 72
89065: PUSH
89066: LD_EXP 175
89070: PUSH
89071: LD_VAR 0 1
89075: ARRAY
89076: PPUSH
89077: LD_INT 2
89079: PUSH
89080: LD_INT 30
89082: PUSH
89083: LD_INT 4
89085: PUSH
89086: EMPTY
89087: LIST
89088: LIST
89089: PUSH
89090: LD_INT 30
89092: PUSH
89093: LD_INT 5
89095: PUSH
89096: EMPTY
89097: LIST
89098: LIST
89099: PUSH
89100: EMPTY
89101: LIST
89102: LIST
89103: LIST
89104: PPUSH
89105: CALL_OW 72
89109: PUSH
89110: LD_INT 6
89112: MUL
89113: PLUS
89114: ST_TO_ADDR
// if bcount < tmp then
89115: LD_VAR 0 13
89119: PUSH
89120: LD_VAR 0 4
89124: LESS
89125: IFFALSE 89171
// for i = tmp downto bcount do
89127: LD_ADDR_VAR 0 3
89131: PUSH
89132: DOUBLE
89133: LD_VAR 0 4
89137: INC
89138: ST_TO_ADDR
89139: LD_VAR 0 13
89143: PUSH
89144: FOR_DOWNTO
89145: IFFALSE 89169
// tmp := Delete ( tmp , tmp ) ;
89147: LD_ADDR_VAR 0 4
89151: PUSH
89152: LD_VAR 0 4
89156: PPUSH
89157: LD_VAR 0 4
89161: PPUSH
89162: CALL_OW 3
89166: ST_TO_ADDR
89167: GO 89144
89169: POP
89170: POP
// result := [ tmp , 0 , 0 , p ] ;
89171: LD_ADDR_VAR 0 2
89175: PUSH
89176: LD_VAR 0 4
89180: PUSH
89181: LD_INT 0
89183: PUSH
89184: LD_INT 0
89186: PUSH
89187: LD_VAR 0 11
89191: PUSH
89192: EMPTY
89193: LIST
89194: LIST
89195: LIST
89196: LIST
89197: ST_TO_ADDR
// exit ;
89198: GO 91888
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
89200: LD_EXP 175
89204: PUSH
89205: LD_VAR 0 1
89209: ARRAY
89210: PPUSH
89211: LD_INT 2
89213: PUSH
89214: LD_INT 30
89216: PUSH
89217: LD_INT 6
89219: PUSH
89220: EMPTY
89221: LIST
89222: LIST
89223: PUSH
89224: LD_INT 30
89226: PUSH
89227: LD_INT 7
89229: PUSH
89230: EMPTY
89231: LIST
89232: LIST
89233: PUSH
89234: LD_INT 30
89236: PUSH
89237: LD_INT 8
89239: PUSH
89240: EMPTY
89241: LIST
89242: LIST
89243: PUSH
89244: EMPTY
89245: LIST
89246: LIST
89247: LIST
89248: LIST
89249: PPUSH
89250: CALL_OW 72
89254: NOT
89255: PUSH
89256: LD_EXP 175
89260: PUSH
89261: LD_VAR 0 1
89265: ARRAY
89266: PPUSH
89267: LD_INT 30
89269: PUSH
89270: LD_INT 3
89272: PUSH
89273: EMPTY
89274: LIST
89275: LIST
89276: PPUSH
89277: CALL_OW 72
89281: NOT
89282: AND
89283: IFFALSE 89355
// begin if eng = tmp then
89285: LD_VAR 0 6
89289: PUSH
89290: LD_VAR 0 4
89294: EQUAL
89295: IFFALSE 89299
// exit ;
89297: GO 91888
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
89299: LD_ADDR_EXP 217
89303: PUSH
89304: LD_EXP 217
89308: PPUSH
89309: LD_VAR 0 1
89313: PPUSH
89314: LD_INT 1
89316: PPUSH
89317: CALL_OW 1
89321: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
89322: LD_ADDR_VAR 0 2
89326: PUSH
89327: LD_INT 0
89329: PUSH
89330: LD_VAR 0 4
89334: PUSH
89335: LD_VAR 0 6
89339: DIFF
89340: PUSH
89341: LD_INT 0
89343: PUSH
89344: LD_INT 0
89346: PUSH
89347: EMPTY
89348: LIST
89349: LIST
89350: LIST
89351: LIST
89352: ST_TO_ADDR
// exit ;
89353: GO 91888
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
89355: LD_EXP 202
89359: PUSH
89360: LD_EXP 201
89364: PUSH
89365: LD_VAR 0 1
89369: ARRAY
89370: ARRAY
89371: PUSH
89372: LD_EXP 175
89376: PUSH
89377: LD_VAR 0 1
89381: ARRAY
89382: PPUSH
89383: LD_INT 2
89385: PUSH
89386: LD_INT 30
89388: PUSH
89389: LD_INT 6
89391: PUSH
89392: EMPTY
89393: LIST
89394: LIST
89395: PUSH
89396: LD_INT 30
89398: PUSH
89399: LD_INT 7
89401: PUSH
89402: EMPTY
89403: LIST
89404: LIST
89405: PUSH
89406: LD_INT 30
89408: PUSH
89409: LD_INT 8
89411: PUSH
89412: EMPTY
89413: LIST
89414: LIST
89415: PUSH
89416: EMPTY
89417: LIST
89418: LIST
89419: LIST
89420: LIST
89421: PPUSH
89422: CALL_OW 72
89426: AND
89427: PUSH
89428: LD_EXP 175
89432: PUSH
89433: LD_VAR 0 1
89437: ARRAY
89438: PPUSH
89439: LD_INT 30
89441: PUSH
89442: LD_INT 3
89444: PUSH
89445: EMPTY
89446: LIST
89447: LIST
89448: PPUSH
89449: CALL_OW 72
89453: NOT
89454: AND
89455: IFFALSE 89669
// begin if sci >= 6 then
89457: LD_VAR 0 8
89461: PUSH
89462: LD_INT 6
89464: GREATEREQUAL
89465: IFFALSE 89469
// exit ;
89467: GO 91888
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
89469: LD_ADDR_EXP 217
89473: PUSH
89474: LD_EXP 217
89478: PPUSH
89479: LD_VAR 0 1
89483: PPUSH
89484: LD_INT 2
89486: PPUSH
89487: CALL_OW 1
89491: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
89492: LD_ADDR_VAR 0 9
89496: PUSH
89497: LD_VAR 0 4
89501: PUSH
89502: LD_VAR 0 8
89506: DIFF
89507: PPUSH
89508: LD_INT 4
89510: PPUSH
89511: CALL 54467 0 2
89515: ST_TO_ADDR
// p := [ ] ;
89516: LD_ADDR_VAR 0 11
89520: PUSH
89521: EMPTY
89522: ST_TO_ADDR
// if sci < 6 and sort > 6 then
89523: LD_VAR 0 8
89527: PUSH
89528: LD_INT 6
89530: LESS
89531: PUSH
89532: LD_VAR 0 9
89536: PUSH
89537: LD_INT 6
89539: GREATER
89540: AND
89541: IFFALSE 89622
// begin for i = 1 to 6 - sci do
89543: LD_ADDR_VAR 0 3
89547: PUSH
89548: DOUBLE
89549: LD_INT 1
89551: DEC
89552: ST_TO_ADDR
89553: LD_INT 6
89555: PUSH
89556: LD_VAR 0 8
89560: MINUS
89561: PUSH
89562: FOR_TO
89563: IFFALSE 89618
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
89565: LD_ADDR_VAR 0 11
89569: PUSH
89570: LD_VAR 0 11
89574: PPUSH
89575: LD_VAR 0 11
89579: PUSH
89580: LD_INT 1
89582: PLUS
89583: PPUSH
89584: LD_VAR 0 9
89588: PUSH
89589: LD_INT 1
89591: ARRAY
89592: PPUSH
89593: CALL_OW 2
89597: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
89598: LD_ADDR_VAR 0 9
89602: PUSH
89603: LD_VAR 0 9
89607: PPUSH
89608: LD_INT 1
89610: PPUSH
89611: CALL_OW 3
89615: ST_TO_ADDR
// end ;
89616: GO 89562
89618: POP
89619: POP
// end else
89620: GO 89642
// if sort then
89622: LD_VAR 0 9
89626: IFFALSE 89642
// p := sort [ 1 ] ;
89628: LD_ADDR_VAR 0 11
89632: PUSH
89633: LD_VAR 0 9
89637: PUSH
89638: LD_INT 1
89640: ARRAY
89641: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
89642: LD_ADDR_VAR 0 2
89646: PUSH
89647: LD_INT 0
89649: PUSH
89650: LD_INT 0
89652: PUSH
89653: LD_INT 0
89655: PUSH
89656: LD_VAR 0 11
89660: PUSH
89661: EMPTY
89662: LIST
89663: LIST
89664: LIST
89665: LIST
89666: ST_TO_ADDR
// exit ;
89667: GO 91888
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
89669: LD_EXP 202
89673: PUSH
89674: LD_EXP 201
89678: PUSH
89679: LD_VAR 0 1
89683: ARRAY
89684: ARRAY
89685: PUSH
89686: LD_EXP 175
89690: PUSH
89691: LD_VAR 0 1
89695: ARRAY
89696: PPUSH
89697: LD_INT 2
89699: PUSH
89700: LD_INT 30
89702: PUSH
89703: LD_INT 6
89705: PUSH
89706: EMPTY
89707: LIST
89708: LIST
89709: PUSH
89710: LD_INT 30
89712: PUSH
89713: LD_INT 7
89715: PUSH
89716: EMPTY
89717: LIST
89718: LIST
89719: PUSH
89720: LD_INT 30
89722: PUSH
89723: LD_INT 8
89725: PUSH
89726: EMPTY
89727: LIST
89728: LIST
89729: PUSH
89730: EMPTY
89731: LIST
89732: LIST
89733: LIST
89734: LIST
89735: PPUSH
89736: CALL_OW 72
89740: AND
89741: PUSH
89742: LD_EXP 175
89746: PUSH
89747: LD_VAR 0 1
89751: ARRAY
89752: PPUSH
89753: LD_INT 30
89755: PUSH
89756: LD_INT 3
89758: PUSH
89759: EMPTY
89760: LIST
89761: LIST
89762: PPUSH
89763: CALL_OW 72
89767: AND
89768: IFFALSE 90502
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
89770: LD_ADDR_EXP 217
89774: PUSH
89775: LD_EXP 217
89779: PPUSH
89780: LD_VAR 0 1
89784: PPUSH
89785: LD_INT 3
89787: PPUSH
89788: CALL_OW 1
89792: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
89793: LD_ADDR_VAR 0 2
89797: PUSH
89798: LD_INT 0
89800: PUSH
89801: LD_INT 0
89803: PUSH
89804: LD_INT 0
89806: PUSH
89807: LD_INT 0
89809: PUSH
89810: EMPTY
89811: LIST
89812: LIST
89813: LIST
89814: LIST
89815: ST_TO_ADDR
// if not eng then
89816: LD_VAR 0 6
89820: NOT
89821: IFFALSE 89884
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
89823: LD_ADDR_VAR 0 11
89827: PUSH
89828: LD_VAR 0 4
89832: PPUSH
89833: LD_INT 2
89835: PPUSH
89836: CALL 54467 0 2
89840: PUSH
89841: LD_INT 1
89843: ARRAY
89844: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
89845: LD_ADDR_VAR 0 2
89849: PUSH
89850: LD_VAR 0 2
89854: PPUSH
89855: LD_INT 2
89857: PPUSH
89858: LD_VAR 0 11
89862: PPUSH
89863: CALL_OW 1
89867: ST_TO_ADDR
// tmp := tmp diff p ;
89868: LD_ADDR_VAR 0 4
89872: PUSH
89873: LD_VAR 0 4
89877: PUSH
89878: LD_VAR 0 11
89882: DIFF
89883: ST_TO_ADDR
// end ; if tmp and sci < 6 then
89884: LD_VAR 0 4
89888: PUSH
89889: LD_VAR 0 8
89893: PUSH
89894: LD_INT 6
89896: LESS
89897: AND
89898: IFFALSE 90086
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
89900: LD_ADDR_VAR 0 9
89904: PUSH
89905: LD_VAR 0 4
89909: PUSH
89910: LD_VAR 0 8
89914: PUSH
89915: LD_VAR 0 7
89919: UNION
89920: DIFF
89921: PPUSH
89922: LD_INT 4
89924: PPUSH
89925: CALL 54467 0 2
89929: ST_TO_ADDR
// p := [ ] ;
89930: LD_ADDR_VAR 0 11
89934: PUSH
89935: EMPTY
89936: ST_TO_ADDR
// if sort then
89937: LD_VAR 0 9
89941: IFFALSE 90057
// for i = 1 to 6 - sci do
89943: LD_ADDR_VAR 0 3
89947: PUSH
89948: DOUBLE
89949: LD_INT 1
89951: DEC
89952: ST_TO_ADDR
89953: LD_INT 6
89955: PUSH
89956: LD_VAR 0 8
89960: MINUS
89961: PUSH
89962: FOR_TO
89963: IFFALSE 90055
// begin if i = sort then
89965: LD_VAR 0 3
89969: PUSH
89970: LD_VAR 0 9
89974: EQUAL
89975: IFFALSE 89979
// break ;
89977: GO 90055
// if GetClass ( i ) = 4 then
89979: LD_VAR 0 3
89983: PPUSH
89984: CALL_OW 257
89988: PUSH
89989: LD_INT 4
89991: EQUAL
89992: IFFALSE 89996
// continue ;
89994: GO 89962
// p := Insert ( p , p + 1 , sort [ i ] ) ;
89996: LD_ADDR_VAR 0 11
90000: PUSH
90001: LD_VAR 0 11
90005: PPUSH
90006: LD_VAR 0 11
90010: PUSH
90011: LD_INT 1
90013: PLUS
90014: PPUSH
90015: LD_VAR 0 9
90019: PUSH
90020: LD_VAR 0 3
90024: ARRAY
90025: PPUSH
90026: CALL_OW 2
90030: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
90031: LD_ADDR_VAR 0 4
90035: PUSH
90036: LD_VAR 0 4
90040: PUSH
90041: LD_VAR 0 9
90045: PUSH
90046: LD_VAR 0 3
90050: ARRAY
90051: DIFF
90052: ST_TO_ADDR
// end ;
90053: GO 89962
90055: POP
90056: POP
// if p then
90057: LD_VAR 0 11
90061: IFFALSE 90086
// result := Replace ( result , 4 , p ) ;
90063: LD_ADDR_VAR 0 2
90067: PUSH
90068: LD_VAR 0 2
90072: PPUSH
90073: LD_INT 4
90075: PPUSH
90076: LD_VAR 0 11
90080: PPUSH
90081: CALL_OW 1
90085: ST_TO_ADDR
// end ; if tmp and mech < 6 then
90086: LD_VAR 0 4
90090: PUSH
90091: LD_VAR 0 7
90095: PUSH
90096: LD_INT 6
90098: LESS
90099: AND
90100: IFFALSE 90288
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
90102: LD_ADDR_VAR 0 9
90106: PUSH
90107: LD_VAR 0 4
90111: PUSH
90112: LD_VAR 0 8
90116: PUSH
90117: LD_VAR 0 7
90121: UNION
90122: DIFF
90123: PPUSH
90124: LD_INT 3
90126: PPUSH
90127: CALL 54467 0 2
90131: ST_TO_ADDR
// p := [ ] ;
90132: LD_ADDR_VAR 0 11
90136: PUSH
90137: EMPTY
90138: ST_TO_ADDR
// if sort then
90139: LD_VAR 0 9
90143: IFFALSE 90259
// for i = 1 to 6 - mech do
90145: LD_ADDR_VAR 0 3
90149: PUSH
90150: DOUBLE
90151: LD_INT 1
90153: DEC
90154: ST_TO_ADDR
90155: LD_INT 6
90157: PUSH
90158: LD_VAR 0 7
90162: MINUS
90163: PUSH
90164: FOR_TO
90165: IFFALSE 90257
// begin if i = sort then
90167: LD_VAR 0 3
90171: PUSH
90172: LD_VAR 0 9
90176: EQUAL
90177: IFFALSE 90181
// break ;
90179: GO 90257
// if GetClass ( i ) = 3 then
90181: LD_VAR 0 3
90185: PPUSH
90186: CALL_OW 257
90190: PUSH
90191: LD_INT 3
90193: EQUAL
90194: IFFALSE 90198
// continue ;
90196: GO 90164
// p := Insert ( p , p + 1 , sort [ i ] ) ;
90198: LD_ADDR_VAR 0 11
90202: PUSH
90203: LD_VAR 0 11
90207: PPUSH
90208: LD_VAR 0 11
90212: PUSH
90213: LD_INT 1
90215: PLUS
90216: PPUSH
90217: LD_VAR 0 9
90221: PUSH
90222: LD_VAR 0 3
90226: ARRAY
90227: PPUSH
90228: CALL_OW 2
90232: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
90233: LD_ADDR_VAR 0 4
90237: PUSH
90238: LD_VAR 0 4
90242: PUSH
90243: LD_VAR 0 9
90247: PUSH
90248: LD_VAR 0 3
90252: ARRAY
90253: DIFF
90254: ST_TO_ADDR
// end ;
90255: GO 90164
90257: POP
90258: POP
// if p then
90259: LD_VAR 0 11
90263: IFFALSE 90288
// result := Replace ( result , 3 , p ) ;
90265: LD_ADDR_VAR 0 2
90269: PUSH
90270: LD_VAR 0 2
90274: PPUSH
90275: LD_INT 3
90277: PPUSH
90278: LD_VAR 0 11
90282: PPUSH
90283: CALL_OW 1
90287: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
90288: LD_VAR 0 4
90292: PUSH
90293: LD_INT 6
90295: GREATER
90296: PUSH
90297: LD_VAR 0 6
90301: PUSH
90302: LD_INT 6
90304: LESS
90305: AND
90306: IFFALSE 90500
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
90308: LD_ADDR_VAR 0 9
90312: PUSH
90313: LD_VAR 0 4
90317: PUSH
90318: LD_VAR 0 8
90322: PUSH
90323: LD_VAR 0 7
90327: UNION
90328: PUSH
90329: LD_VAR 0 6
90333: UNION
90334: DIFF
90335: PPUSH
90336: LD_INT 2
90338: PPUSH
90339: CALL 54467 0 2
90343: ST_TO_ADDR
// p := [ ] ;
90344: LD_ADDR_VAR 0 11
90348: PUSH
90349: EMPTY
90350: ST_TO_ADDR
// if sort then
90351: LD_VAR 0 9
90355: IFFALSE 90471
// for i = 1 to 6 - eng do
90357: LD_ADDR_VAR 0 3
90361: PUSH
90362: DOUBLE
90363: LD_INT 1
90365: DEC
90366: ST_TO_ADDR
90367: LD_INT 6
90369: PUSH
90370: LD_VAR 0 6
90374: MINUS
90375: PUSH
90376: FOR_TO
90377: IFFALSE 90469
// begin if i = sort then
90379: LD_VAR 0 3
90383: PUSH
90384: LD_VAR 0 9
90388: EQUAL
90389: IFFALSE 90393
// break ;
90391: GO 90469
// if GetClass ( i ) = 2 then
90393: LD_VAR 0 3
90397: PPUSH
90398: CALL_OW 257
90402: PUSH
90403: LD_INT 2
90405: EQUAL
90406: IFFALSE 90410
// continue ;
90408: GO 90376
// p := Insert ( p , p + 1 , sort [ i ] ) ;
90410: LD_ADDR_VAR 0 11
90414: PUSH
90415: LD_VAR 0 11
90419: PPUSH
90420: LD_VAR 0 11
90424: PUSH
90425: LD_INT 1
90427: PLUS
90428: PPUSH
90429: LD_VAR 0 9
90433: PUSH
90434: LD_VAR 0 3
90438: ARRAY
90439: PPUSH
90440: CALL_OW 2
90444: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
90445: LD_ADDR_VAR 0 4
90449: PUSH
90450: LD_VAR 0 4
90454: PUSH
90455: LD_VAR 0 9
90459: PUSH
90460: LD_VAR 0 3
90464: ARRAY
90465: DIFF
90466: ST_TO_ADDR
// end ;
90467: GO 90376
90469: POP
90470: POP
// if p then
90471: LD_VAR 0 11
90475: IFFALSE 90500
// result := Replace ( result , 2 , p ) ;
90477: LD_ADDR_VAR 0 2
90481: PUSH
90482: LD_VAR 0 2
90486: PPUSH
90487: LD_INT 2
90489: PPUSH
90490: LD_VAR 0 11
90494: PPUSH
90495: CALL_OW 1
90499: ST_TO_ADDR
// end ; exit ;
90500: GO 91888
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
90502: LD_EXP 202
90506: PUSH
90507: LD_EXP 201
90511: PUSH
90512: LD_VAR 0 1
90516: ARRAY
90517: ARRAY
90518: NOT
90519: PUSH
90520: LD_EXP 175
90524: PUSH
90525: LD_VAR 0 1
90529: ARRAY
90530: PPUSH
90531: LD_INT 30
90533: PUSH
90534: LD_INT 3
90536: PUSH
90537: EMPTY
90538: LIST
90539: LIST
90540: PPUSH
90541: CALL_OW 72
90545: AND
90546: PUSH
90547: LD_EXP 180
90551: PUSH
90552: LD_VAR 0 1
90556: ARRAY
90557: AND
90558: IFFALSE 91166
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
90560: LD_ADDR_EXP 217
90564: PUSH
90565: LD_EXP 217
90569: PPUSH
90570: LD_VAR 0 1
90574: PPUSH
90575: LD_INT 5
90577: PPUSH
90578: CALL_OW 1
90582: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
90583: LD_ADDR_VAR 0 2
90587: PUSH
90588: LD_INT 0
90590: PUSH
90591: LD_INT 0
90593: PUSH
90594: LD_INT 0
90596: PUSH
90597: LD_INT 0
90599: PUSH
90600: EMPTY
90601: LIST
90602: LIST
90603: LIST
90604: LIST
90605: ST_TO_ADDR
// if sci > 1 then
90606: LD_VAR 0 8
90610: PUSH
90611: LD_INT 1
90613: GREATER
90614: IFFALSE 90642
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
90616: LD_ADDR_VAR 0 4
90620: PUSH
90621: LD_VAR 0 4
90625: PUSH
90626: LD_VAR 0 8
90630: PUSH
90631: LD_VAR 0 8
90635: PUSH
90636: LD_INT 1
90638: ARRAY
90639: DIFF
90640: DIFF
90641: ST_TO_ADDR
// if tmp and not sci then
90642: LD_VAR 0 4
90646: PUSH
90647: LD_VAR 0 8
90651: NOT
90652: AND
90653: IFFALSE 90722
// begin sort := SortBySkill ( tmp , 4 ) ;
90655: LD_ADDR_VAR 0 9
90659: PUSH
90660: LD_VAR 0 4
90664: PPUSH
90665: LD_INT 4
90667: PPUSH
90668: CALL 54467 0 2
90672: ST_TO_ADDR
// if sort then
90673: LD_VAR 0 9
90677: IFFALSE 90693
// p := sort [ 1 ] ;
90679: LD_ADDR_VAR 0 11
90683: PUSH
90684: LD_VAR 0 9
90688: PUSH
90689: LD_INT 1
90691: ARRAY
90692: ST_TO_ADDR
// if p then
90693: LD_VAR 0 11
90697: IFFALSE 90722
// result := Replace ( result , 4 , p ) ;
90699: LD_ADDR_VAR 0 2
90703: PUSH
90704: LD_VAR 0 2
90708: PPUSH
90709: LD_INT 4
90711: PPUSH
90712: LD_VAR 0 11
90716: PPUSH
90717: CALL_OW 1
90721: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
90722: LD_ADDR_VAR 0 4
90726: PUSH
90727: LD_VAR 0 4
90731: PUSH
90732: LD_VAR 0 7
90736: DIFF
90737: ST_TO_ADDR
// if tmp and mech < 6 then
90738: LD_VAR 0 4
90742: PUSH
90743: LD_VAR 0 7
90747: PUSH
90748: LD_INT 6
90750: LESS
90751: AND
90752: IFFALSE 90940
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
90754: LD_ADDR_VAR 0 9
90758: PUSH
90759: LD_VAR 0 4
90763: PUSH
90764: LD_VAR 0 8
90768: PUSH
90769: LD_VAR 0 7
90773: UNION
90774: DIFF
90775: PPUSH
90776: LD_INT 3
90778: PPUSH
90779: CALL 54467 0 2
90783: ST_TO_ADDR
// p := [ ] ;
90784: LD_ADDR_VAR 0 11
90788: PUSH
90789: EMPTY
90790: ST_TO_ADDR
// if sort then
90791: LD_VAR 0 9
90795: IFFALSE 90911
// for i = 1 to 6 - mech do
90797: LD_ADDR_VAR 0 3
90801: PUSH
90802: DOUBLE
90803: LD_INT 1
90805: DEC
90806: ST_TO_ADDR
90807: LD_INT 6
90809: PUSH
90810: LD_VAR 0 7
90814: MINUS
90815: PUSH
90816: FOR_TO
90817: IFFALSE 90909
// begin if i = sort then
90819: LD_VAR 0 3
90823: PUSH
90824: LD_VAR 0 9
90828: EQUAL
90829: IFFALSE 90833
// break ;
90831: GO 90909
// if GetClass ( i ) = 3 then
90833: LD_VAR 0 3
90837: PPUSH
90838: CALL_OW 257
90842: PUSH
90843: LD_INT 3
90845: EQUAL
90846: IFFALSE 90850
// continue ;
90848: GO 90816
// p := Insert ( p , p + 1 , sort [ i ] ) ;
90850: LD_ADDR_VAR 0 11
90854: PUSH
90855: LD_VAR 0 11
90859: PPUSH
90860: LD_VAR 0 11
90864: PUSH
90865: LD_INT 1
90867: PLUS
90868: PPUSH
90869: LD_VAR 0 9
90873: PUSH
90874: LD_VAR 0 3
90878: ARRAY
90879: PPUSH
90880: CALL_OW 2
90884: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
90885: LD_ADDR_VAR 0 4
90889: PUSH
90890: LD_VAR 0 4
90894: PUSH
90895: LD_VAR 0 9
90899: PUSH
90900: LD_VAR 0 3
90904: ARRAY
90905: DIFF
90906: ST_TO_ADDR
// end ;
90907: GO 90816
90909: POP
90910: POP
// if p then
90911: LD_VAR 0 11
90915: IFFALSE 90940
// result := Replace ( result , 3 , p ) ;
90917: LD_ADDR_VAR 0 2
90921: PUSH
90922: LD_VAR 0 2
90926: PPUSH
90927: LD_INT 3
90929: PPUSH
90930: LD_VAR 0 11
90934: PPUSH
90935: CALL_OW 1
90939: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
90940: LD_ADDR_VAR 0 4
90944: PUSH
90945: LD_VAR 0 4
90949: PUSH
90950: LD_VAR 0 6
90954: DIFF
90955: ST_TO_ADDR
// if tmp and eng < 6 then
90956: LD_VAR 0 4
90960: PUSH
90961: LD_VAR 0 6
90965: PUSH
90966: LD_INT 6
90968: LESS
90969: AND
90970: IFFALSE 91164
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
90972: LD_ADDR_VAR 0 9
90976: PUSH
90977: LD_VAR 0 4
90981: PUSH
90982: LD_VAR 0 8
90986: PUSH
90987: LD_VAR 0 7
90991: UNION
90992: PUSH
90993: LD_VAR 0 6
90997: UNION
90998: DIFF
90999: PPUSH
91000: LD_INT 2
91002: PPUSH
91003: CALL 54467 0 2
91007: ST_TO_ADDR
// p := [ ] ;
91008: LD_ADDR_VAR 0 11
91012: PUSH
91013: EMPTY
91014: ST_TO_ADDR
// if sort then
91015: LD_VAR 0 9
91019: IFFALSE 91135
// for i = 1 to 6 - eng do
91021: LD_ADDR_VAR 0 3
91025: PUSH
91026: DOUBLE
91027: LD_INT 1
91029: DEC
91030: ST_TO_ADDR
91031: LD_INT 6
91033: PUSH
91034: LD_VAR 0 6
91038: MINUS
91039: PUSH
91040: FOR_TO
91041: IFFALSE 91133
// begin if i = sort then
91043: LD_VAR 0 3
91047: PUSH
91048: LD_VAR 0 9
91052: EQUAL
91053: IFFALSE 91057
// break ;
91055: GO 91133
// if GetClass ( i ) = 2 then
91057: LD_VAR 0 3
91061: PPUSH
91062: CALL_OW 257
91066: PUSH
91067: LD_INT 2
91069: EQUAL
91070: IFFALSE 91074
// continue ;
91072: GO 91040
// p := Insert ( p , p + 1 , sort [ i ] ) ;
91074: LD_ADDR_VAR 0 11
91078: PUSH
91079: LD_VAR 0 11
91083: PPUSH
91084: LD_VAR 0 11
91088: PUSH
91089: LD_INT 1
91091: PLUS
91092: PPUSH
91093: LD_VAR 0 9
91097: PUSH
91098: LD_VAR 0 3
91102: ARRAY
91103: PPUSH
91104: CALL_OW 2
91108: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
91109: LD_ADDR_VAR 0 4
91113: PUSH
91114: LD_VAR 0 4
91118: PUSH
91119: LD_VAR 0 9
91123: PUSH
91124: LD_VAR 0 3
91128: ARRAY
91129: DIFF
91130: ST_TO_ADDR
// end ;
91131: GO 91040
91133: POP
91134: POP
// if p then
91135: LD_VAR 0 11
91139: IFFALSE 91164
// result := Replace ( result , 2 , p ) ;
91141: LD_ADDR_VAR 0 2
91145: PUSH
91146: LD_VAR 0 2
91150: PPUSH
91151: LD_INT 2
91153: PPUSH
91154: LD_VAR 0 11
91158: PPUSH
91159: CALL_OW 1
91163: ST_TO_ADDR
// end ; exit ;
91164: GO 91888
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
91166: LD_EXP 202
91170: PUSH
91171: LD_EXP 201
91175: PUSH
91176: LD_VAR 0 1
91180: ARRAY
91181: ARRAY
91182: NOT
91183: PUSH
91184: LD_EXP 175
91188: PUSH
91189: LD_VAR 0 1
91193: ARRAY
91194: PPUSH
91195: LD_INT 30
91197: PUSH
91198: LD_INT 3
91200: PUSH
91201: EMPTY
91202: LIST
91203: LIST
91204: PPUSH
91205: CALL_OW 72
91209: AND
91210: PUSH
91211: LD_EXP 180
91215: PUSH
91216: LD_VAR 0 1
91220: ARRAY
91221: NOT
91222: AND
91223: IFFALSE 91888
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
91225: LD_ADDR_EXP 217
91229: PUSH
91230: LD_EXP 217
91234: PPUSH
91235: LD_VAR 0 1
91239: PPUSH
91240: LD_INT 6
91242: PPUSH
91243: CALL_OW 1
91247: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
91248: LD_ADDR_VAR 0 2
91252: PUSH
91253: LD_INT 0
91255: PUSH
91256: LD_INT 0
91258: PUSH
91259: LD_INT 0
91261: PUSH
91262: LD_INT 0
91264: PUSH
91265: EMPTY
91266: LIST
91267: LIST
91268: LIST
91269: LIST
91270: ST_TO_ADDR
// if sci >= 1 then
91271: LD_VAR 0 8
91275: PUSH
91276: LD_INT 1
91278: GREATEREQUAL
91279: IFFALSE 91301
// tmp := tmp diff sci [ 1 ] ;
91281: LD_ADDR_VAR 0 4
91285: PUSH
91286: LD_VAR 0 4
91290: PUSH
91291: LD_VAR 0 8
91295: PUSH
91296: LD_INT 1
91298: ARRAY
91299: DIFF
91300: ST_TO_ADDR
// if tmp and not sci then
91301: LD_VAR 0 4
91305: PUSH
91306: LD_VAR 0 8
91310: NOT
91311: AND
91312: IFFALSE 91381
// begin sort := SortBySkill ( tmp , 4 ) ;
91314: LD_ADDR_VAR 0 9
91318: PUSH
91319: LD_VAR 0 4
91323: PPUSH
91324: LD_INT 4
91326: PPUSH
91327: CALL 54467 0 2
91331: ST_TO_ADDR
// if sort then
91332: LD_VAR 0 9
91336: IFFALSE 91352
// p := sort [ 1 ] ;
91338: LD_ADDR_VAR 0 11
91342: PUSH
91343: LD_VAR 0 9
91347: PUSH
91348: LD_INT 1
91350: ARRAY
91351: ST_TO_ADDR
// if p then
91352: LD_VAR 0 11
91356: IFFALSE 91381
// result := Replace ( result , 4 , p ) ;
91358: LD_ADDR_VAR 0 2
91362: PUSH
91363: LD_VAR 0 2
91367: PPUSH
91368: LD_INT 4
91370: PPUSH
91371: LD_VAR 0 11
91375: PPUSH
91376: CALL_OW 1
91380: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
91381: LD_ADDR_VAR 0 4
91385: PUSH
91386: LD_VAR 0 4
91390: PUSH
91391: LD_VAR 0 7
91395: DIFF
91396: ST_TO_ADDR
// if tmp and mech < 6 then
91397: LD_VAR 0 4
91401: PUSH
91402: LD_VAR 0 7
91406: PUSH
91407: LD_INT 6
91409: LESS
91410: AND
91411: IFFALSE 91593
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
91413: LD_ADDR_VAR 0 9
91417: PUSH
91418: LD_VAR 0 4
91422: PUSH
91423: LD_VAR 0 7
91427: DIFF
91428: PPUSH
91429: LD_INT 3
91431: PPUSH
91432: CALL 54467 0 2
91436: ST_TO_ADDR
// p := [ ] ;
91437: LD_ADDR_VAR 0 11
91441: PUSH
91442: EMPTY
91443: ST_TO_ADDR
// if sort then
91444: LD_VAR 0 9
91448: IFFALSE 91564
// for i = 1 to 6 - mech do
91450: LD_ADDR_VAR 0 3
91454: PUSH
91455: DOUBLE
91456: LD_INT 1
91458: DEC
91459: ST_TO_ADDR
91460: LD_INT 6
91462: PUSH
91463: LD_VAR 0 7
91467: MINUS
91468: PUSH
91469: FOR_TO
91470: IFFALSE 91562
// begin if i = sort then
91472: LD_VAR 0 3
91476: PUSH
91477: LD_VAR 0 9
91481: EQUAL
91482: IFFALSE 91486
// break ;
91484: GO 91562
// if GetClass ( i ) = 3 then
91486: LD_VAR 0 3
91490: PPUSH
91491: CALL_OW 257
91495: PUSH
91496: LD_INT 3
91498: EQUAL
91499: IFFALSE 91503
// continue ;
91501: GO 91469
// p := Insert ( p , p + 1 , sort [ i ] ) ;
91503: LD_ADDR_VAR 0 11
91507: PUSH
91508: LD_VAR 0 11
91512: PPUSH
91513: LD_VAR 0 11
91517: PUSH
91518: LD_INT 1
91520: PLUS
91521: PPUSH
91522: LD_VAR 0 9
91526: PUSH
91527: LD_VAR 0 3
91531: ARRAY
91532: PPUSH
91533: CALL_OW 2
91537: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
91538: LD_ADDR_VAR 0 4
91542: PUSH
91543: LD_VAR 0 4
91547: PUSH
91548: LD_VAR 0 9
91552: PUSH
91553: LD_VAR 0 3
91557: ARRAY
91558: DIFF
91559: ST_TO_ADDR
// end ;
91560: GO 91469
91562: POP
91563: POP
// if p then
91564: LD_VAR 0 11
91568: IFFALSE 91593
// result := Replace ( result , 3 , p ) ;
91570: LD_ADDR_VAR 0 2
91574: PUSH
91575: LD_VAR 0 2
91579: PPUSH
91580: LD_INT 3
91582: PPUSH
91583: LD_VAR 0 11
91587: PPUSH
91588: CALL_OW 1
91592: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
91593: LD_ADDR_VAR 0 4
91597: PUSH
91598: LD_VAR 0 4
91602: PUSH
91603: LD_VAR 0 6
91607: DIFF
91608: ST_TO_ADDR
// if tmp and eng < 4 then
91609: LD_VAR 0 4
91613: PUSH
91614: LD_VAR 0 6
91618: PUSH
91619: LD_INT 4
91621: LESS
91622: AND
91623: IFFALSE 91813
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
91625: LD_ADDR_VAR 0 9
91629: PUSH
91630: LD_VAR 0 4
91634: PUSH
91635: LD_VAR 0 7
91639: PUSH
91640: LD_VAR 0 6
91644: UNION
91645: DIFF
91646: PPUSH
91647: LD_INT 2
91649: PPUSH
91650: CALL 54467 0 2
91654: ST_TO_ADDR
// p := [ ] ;
91655: LD_ADDR_VAR 0 11
91659: PUSH
91660: EMPTY
91661: ST_TO_ADDR
// if sort then
91662: LD_VAR 0 9
91666: IFFALSE 91782
// for i = 1 to 4 - eng do
91668: LD_ADDR_VAR 0 3
91672: PUSH
91673: DOUBLE
91674: LD_INT 1
91676: DEC
91677: ST_TO_ADDR
91678: LD_INT 4
91680: PUSH
91681: LD_VAR 0 6
91685: MINUS
91686: PUSH
91687: FOR_TO
91688: IFFALSE 91780
// begin if i = sort then
91690: LD_VAR 0 3
91694: PUSH
91695: LD_VAR 0 9
91699: EQUAL
91700: IFFALSE 91704
// break ;
91702: GO 91780
// if GetClass ( i ) = 2 then
91704: LD_VAR 0 3
91708: PPUSH
91709: CALL_OW 257
91713: PUSH
91714: LD_INT 2
91716: EQUAL
91717: IFFALSE 91721
// continue ;
91719: GO 91687
// p := Insert ( p , p + 1 , sort [ i ] ) ;
91721: LD_ADDR_VAR 0 11
91725: PUSH
91726: LD_VAR 0 11
91730: PPUSH
91731: LD_VAR 0 11
91735: PUSH
91736: LD_INT 1
91738: PLUS
91739: PPUSH
91740: LD_VAR 0 9
91744: PUSH
91745: LD_VAR 0 3
91749: ARRAY
91750: PPUSH
91751: CALL_OW 2
91755: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
91756: LD_ADDR_VAR 0 4
91760: PUSH
91761: LD_VAR 0 4
91765: PUSH
91766: LD_VAR 0 9
91770: PUSH
91771: LD_VAR 0 3
91775: ARRAY
91776: DIFF
91777: ST_TO_ADDR
// end ;
91778: GO 91687
91780: POP
91781: POP
// if p then
91782: LD_VAR 0 11
91786: IFFALSE 91811
// result := Replace ( result , 2 , p ) ;
91788: LD_ADDR_VAR 0 2
91792: PUSH
91793: LD_VAR 0 2
91797: PPUSH
91798: LD_INT 2
91800: PPUSH
91801: LD_VAR 0 11
91805: PPUSH
91806: CALL_OW 1
91810: ST_TO_ADDR
// end else
91811: GO 91857
// for i = eng downto 5 do
91813: LD_ADDR_VAR 0 3
91817: PUSH
91818: DOUBLE
91819: LD_VAR 0 6
91823: INC
91824: ST_TO_ADDR
91825: LD_INT 5
91827: PUSH
91828: FOR_DOWNTO
91829: IFFALSE 91855
// tmp := tmp union eng [ i ] ;
91831: LD_ADDR_VAR 0 4
91835: PUSH
91836: LD_VAR 0 4
91840: PUSH
91841: LD_VAR 0 6
91845: PUSH
91846: LD_VAR 0 3
91850: ARRAY
91851: UNION
91852: ST_TO_ADDR
91853: GO 91828
91855: POP
91856: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
91857: LD_ADDR_VAR 0 2
91861: PUSH
91862: LD_VAR 0 2
91866: PPUSH
91867: LD_INT 1
91869: PPUSH
91870: LD_VAR 0 4
91874: PUSH
91875: LD_VAR 0 5
91879: DIFF
91880: PPUSH
91881: CALL_OW 1
91885: ST_TO_ADDR
// exit ;
91886: GO 91888
// end ; end ;
91888: LD_VAR 0 2
91892: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
91893: LD_INT 0
91895: PPUSH
91896: PPUSH
91897: PPUSH
// if not mc_bases then
91898: LD_EXP 175
91902: NOT
91903: IFFALSE 91907
// exit ;
91905: GO 92049
// for i = 1 to mc_bases do
91907: LD_ADDR_VAR 0 2
91911: PUSH
91912: DOUBLE
91913: LD_INT 1
91915: DEC
91916: ST_TO_ADDR
91917: LD_EXP 175
91921: PUSH
91922: FOR_TO
91923: IFFALSE 92040
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
91925: LD_ADDR_VAR 0 3
91929: PUSH
91930: LD_EXP 175
91934: PUSH
91935: LD_VAR 0 2
91939: ARRAY
91940: PPUSH
91941: LD_INT 21
91943: PUSH
91944: LD_INT 3
91946: PUSH
91947: EMPTY
91948: LIST
91949: LIST
91950: PUSH
91951: LD_INT 3
91953: PUSH
91954: LD_INT 2
91956: PUSH
91957: LD_INT 30
91959: PUSH
91960: LD_INT 29
91962: PUSH
91963: EMPTY
91964: LIST
91965: LIST
91966: PUSH
91967: LD_INT 30
91969: PUSH
91970: LD_INT 30
91972: PUSH
91973: EMPTY
91974: LIST
91975: LIST
91976: PUSH
91977: EMPTY
91978: LIST
91979: LIST
91980: LIST
91981: PUSH
91982: EMPTY
91983: LIST
91984: LIST
91985: PUSH
91986: LD_INT 3
91988: PUSH
91989: LD_INT 24
91991: PUSH
91992: LD_INT 1000
91994: PUSH
91995: EMPTY
91996: LIST
91997: LIST
91998: PUSH
91999: EMPTY
92000: LIST
92001: LIST
92002: PUSH
92003: EMPTY
92004: LIST
92005: LIST
92006: LIST
92007: PPUSH
92008: CALL_OW 72
92012: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
92013: LD_ADDR_EXP 176
92017: PUSH
92018: LD_EXP 176
92022: PPUSH
92023: LD_VAR 0 2
92027: PPUSH
92028: LD_VAR 0 3
92032: PPUSH
92033: CALL_OW 1
92037: ST_TO_ADDR
// end ;
92038: GO 91922
92040: POP
92041: POP
// RaiseSailEvent ( 101 ) ;
92042: LD_INT 101
92044: PPUSH
92045: CALL_OW 427
// end ;
92049: LD_VAR 0 1
92053: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
92054: LD_INT 0
92056: PPUSH
92057: PPUSH
92058: PPUSH
92059: PPUSH
92060: PPUSH
92061: PPUSH
92062: PPUSH
// if not mc_bases then
92063: LD_EXP 175
92067: NOT
92068: IFFALSE 92072
// exit ;
92070: GO 92634
// for i = 1 to mc_bases do
92072: LD_ADDR_VAR 0 2
92076: PUSH
92077: DOUBLE
92078: LD_INT 1
92080: DEC
92081: ST_TO_ADDR
92082: LD_EXP 175
92086: PUSH
92087: FOR_TO
92088: IFFALSE 92625
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
92090: LD_ADDR_VAR 0 5
92094: PUSH
92095: LD_EXP 175
92099: PUSH
92100: LD_VAR 0 2
92104: ARRAY
92105: PUSH
92106: LD_EXP 204
92110: PUSH
92111: LD_VAR 0 2
92115: ARRAY
92116: UNION
92117: PPUSH
92118: LD_INT 21
92120: PUSH
92121: LD_INT 1
92123: PUSH
92124: EMPTY
92125: LIST
92126: LIST
92127: PUSH
92128: LD_INT 1
92130: PUSH
92131: LD_INT 3
92133: PUSH
92134: LD_INT 54
92136: PUSH
92137: EMPTY
92138: LIST
92139: PUSH
92140: EMPTY
92141: LIST
92142: LIST
92143: PUSH
92144: LD_INT 3
92146: PUSH
92147: LD_INT 24
92149: PUSH
92150: LD_INT 1000
92152: PUSH
92153: EMPTY
92154: LIST
92155: LIST
92156: PUSH
92157: EMPTY
92158: LIST
92159: LIST
92160: PUSH
92161: EMPTY
92162: LIST
92163: LIST
92164: LIST
92165: PUSH
92166: EMPTY
92167: LIST
92168: LIST
92169: PPUSH
92170: CALL_OW 72
92174: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
92175: LD_ADDR_VAR 0 6
92179: PUSH
92180: LD_EXP 175
92184: PUSH
92185: LD_VAR 0 2
92189: ARRAY
92190: PPUSH
92191: LD_INT 21
92193: PUSH
92194: LD_INT 1
92196: PUSH
92197: EMPTY
92198: LIST
92199: LIST
92200: PUSH
92201: LD_INT 1
92203: PUSH
92204: LD_INT 3
92206: PUSH
92207: LD_INT 54
92209: PUSH
92210: EMPTY
92211: LIST
92212: PUSH
92213: EMPTY
92214: LIST
92215: LIST
92216: PUSH
92217: LD_INT 3
92219: PUSH
92220: LD_INT 24
92222: PUSH
92223: LD_INT 250
92225: PUSH
92226: EMPTY
92227: LIST
92228: LIST
92229: PUSH
92230: EMPTY
92231: LIST
92232: LIST
92233: PUSH
92234: EMPTY
92235: LIST
92236: LIST
92237: LIST
92238: PUSH
92239: EMPTY
92240: LIST
92241: LIST
92242: PPUSH
92243: CALL_OW 72
92247: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
92248: LD_ADDR_VAR 0 7
92252: PUSH
92253: LD_VAR 0 5
92257: PUSH
92258: LD_VAR 0 6
92262: DIFF
92263: ST_TO_ADDR
// if not need_heal_1 then
92264: LD_VAR 0 6
92268: NOT
92269: IFFALSE 92302
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
92271: LD_ADDR_EXP 178
92275: PUSH
92276: LD_EXP 178
92280: PPUSH
92281: LD_VAR 0 2
92285: PUSH
92286: LD_INT 1
92288: PUSH
92289: EMPTY
92290: LIST
92291: LIST
92292: PPUSH
92293: EMPTY
92294: PPUSH
92295: CALL 24210 0 3
92299: ST_TO_ADDR
92300: GO 92372
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
92302: LD_ADDR_EXP 178
92306: PUSH
92307: LD_EXP 178
92311: PPUSH
92312: LD_VAR 0 2
92316: PUSH
92317: LD_INT 1
92319: PUSH
92320: EMPTY
92321: LIST
92322: LIST
92323: PPUSH
92324: LD_EXP 178
92328: PUSH
92329: LD_VAR 0 2
92333: ARRAY
92334: PUSH
92335: LD_INT 1
92337: ARRAY
92338: PPUSH
92339: LD_INT 3
92341: PUSH
92342: LD_INT 24
92344: PUSH
92345: LD_INT 1000
92347: PUSH
92348: EMPTY
92349: LIST
92350: LIST
92351: PUSH
92352: EMPTY
92353: LIST
92354: LIST
92355: PPUSH
92356: CALL_OW 72
92360: PUSH
92361: LD_VAR 0 6
92365: UNION
92366: PPUSH
92367: CALL 24210 0 3
92371: ST_TO_ADDR
// if not need_heal_2 then
92372: LD_VAR 0 7
92376: NOT
92377: IFFALSE 92410
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
92379: LD_ADDR_EXP 178
92383: PUSH
92384: LD_EXP 178
92388: PPUSH
92389: LD_VAR 0 2
92393: PUSH
92394: LD_INT 2
92396: PUSH
92397: EMPTY
92398: LIST
92399: LIST
92400: PPUSH
92401: EMPTY
92402: PPUSH
92403: CALL 24210 0 3
92407: ST_TO_ADDR
92408: GO 92442
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
92410: LD_ADDR_EXP 178
92414: PUSH
92415: LD_EXP 178
92419: PPUSH
92420: LD_VAR 0 2
92424: PUSH
92425: LD_INT 2
92427: PUSH
92428: EMPTY
92429: LIST
92430: LIST
92431: PPUSH
92432: LD_VAR 0 7
92436: PPUSH
92437: CALL 24210 0 3
92441: ST_TO_ADDR
// if need_heal_2 then
92442: LD_VAR 0 7
92446: IFFALSE 92607
// for j in need_heal_2 do
92448: LD_ADDR_VAR 0 3
92452: PUSH
92453: LD_VAR 0 7
92457: PUSH
92458: FOR_IN
92459: IFFALSE 92605
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
92461: LD_ADDR_VAR 0 5
92465: PUSH
92466: LD_EXP 175
92470: PUSH
92471: LD_VAR 0 2
92475: ARRAY
92476: PPUSH
92477: LD_INT 2
92479: PUSH
92480: LD_INT 30
92482: PUSH
92483: LD_INT 6
92485: PUSH
92486: EMPTY
92487: LIST
92488: LIST
92489: PUSH
92490: LD_INT 30
92492: PUSH
92493: LD_INT 7
92495: PUSH
92496: EMPTY
92497: LIST
92498: LIST
92499: PUSH
92500: LD_INT 30
92502: PUSH
92503: LD_INT 8
92505: PUSH
92506: EMPTY
92507: LIST
92508: LIST
92509: PUSH
92510: LD_INT 30
92512: PUSH
92513: LD_INT 0
92515: PUSH
92516: EMPTY
92517: LIST
92518: LIST
92519: PUSH
92520: LD_INT 30
92522: PUSH
92523: LD_INT 1
92525: PUSH
92526: EMPTY
92527: LIST
92528: LIST
92529: PUSH
92530: EMPTY
92531: LIST
92532: LIST
92533: LIST
92534: LIST
92535: LIST
92536: LIST
92537: PPUSH
92538: CALL_OW 72
92542: ST_TO_ADDR
// if tmp then
92543: LD_VAR 0 5
92547: IFFALSE 92603
// begin k := NearestUnitToUnit ( tmp , j ) ;
92549: LD_ADDR_VAR 0 4
92553: PUSH
92554: LD_VAR 0 5
92558: PPUSH
92559: LD_VAR 0 3
92563: PPUSH
92564: CALL_OW 74
92568: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
92569: LD_VAR 0 3
92573: PPUSH
92574: LD_VAR 0 4
92578: PPUSH
92579: CALL_OW 296
92583: PUSH
92584: LD_INT 5
92586: GREATER
92587: IFFALSE 92603
// ComMoveToNearbyEntrance ( j , k ) ;
92589: LD_VAR 0 3
92593: PPUSH
92594: LD_VAR 0 4
92598: PPUSH
92599: CALL 56828 0 2
// end ; end ;
92603: GO 92458
92605: POP
92606: POP
// if not need_heal_1 and not need_heal_2 then
92607: LD_VAR 0 6
92611: NOT
92612: PUSH
92613: LD_VAR 0 7
92617: NOT
92618: AND
92619: IFFALSE 92623
// continue ;
92621: GO 92087
// end ;
92623: GO 92087
92625: POP
92626: POP
// RaiseSailEvent ( 102 ) ;
92627: LD_INT 102
92629: PPUSH
92630: CALL_OW 427
// end ;
92634: LD_VAR 0 1
92638: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
92639: LD_INT 0
92641: PPUSH
92642: PPUSH
92643: PPUSH
92644: PPUSH
92645: PPUSH
92646: PPUSH
92647: PPUSH
92648: PPUSH
// if not mc_bases then
92649: LD_EXP 175
92653: NOT
92654: IFFALSE 92658
// exit ;
92656: GO 93541
// for i = 1 to mc_bases do
92658: LD_ADDR_VAR 0 2
92662: PUSH
92663: DOUBLE
92664: LD_INT 1
92666: DEC
92667: ST_TO_ADDR
92668: LD_EXP 175
92672: PUSH
92673: FOR_TO
92674: IFFALSE 93539
// begin if not mc_building_need_repair [ i ] then
92676: LD_EXP 176
92680: PUSH
92681: LD_VAR 0 2
92685: ARRAY
92686: NOT
92687: IFFALSE 92874
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
92689: LD_ADDR_VAR 0 6
92693: PUSH
92694: LD_EXP 194
92698: PUSH
92699: LD_VAR 0 2
92703: ARRAY
92704: PPUSH
92705: LD_INT 3
92707: PUSH
92708: LD_INT 24
92710: PUSH
92711: LD_INT 1000
92713: PUSH
92714: EMPTY
92715: LIST
92716: LIST
92717: PUSH
92718: EMPTY
92719: LIST
92720: LIST
92721: PUSH
92722: LD_INT 2
92724: PUSH
92725: LD_INT 34
92727: PUSH
92728: LD_INT 13
92730: PUSH
92731: EMPTY
92732: LIST
92733: LIST
92734: PUSH
92735: LD_INT 34
92737: PUSH
92738: LD_INT 52
92740: PUSH
92741: EMPTY
92742: LIST
92743: LIST
92744: PUSH
92745: LD_INT 34
92747: PUSH
92748: LD_EXP 160
92752: PUSH
92753: EMPTY
92754: LIST
92755: LIST
92756: PUSH
92757: EMPTY
92758: LIST
92759: LIST
92760: LIST
92761: LIST
92762: PUSH
92763: EMPTY
92764: LIST
92765: LIST
92766: PPUSH
92767: CALL_OW 72
92771: ST_TO_ADDR
// if cranes then
92772: LD_VAR 0 6
92776: IFFALSE 92838
// for j in cranes do
92778: LD_ADDR_VAR 0 3
92782: PUSH
92783: LD_VAR 0 6
92787: PUSH
92788: FOR_IN
92789: IFFALSE 92836
// if not IsInArea ( j , mc_parking [ i ] ) then
92791: LD_VAR 0 3
92795: PPUSH
92796: LD_EXP 199
92800: PUSH
92801: LD_VAR 0 2
92805: ARRAY
92806: PPUSH
92807: CALL_OW 308
92811: NOT
92812: IFFALSE 92834
// ComMoveToArea ( j , mc_parking [ i ] ) ;
92814: LD_VAR 0 3
92818: PPUSH
92819: LD_EXP 199
92823: PUSH
92824: LD_VAR 0 2
92828: ARRAY
92829: PPUSH
92830: CALL_OW 113
92834: GO 92788
92836: POP
92837: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
92838: LD_ADDR_EXP 177
92842: PUSH
92843: LD_EXP 177
92847: PPUSH
92848: LD_VAR 0 2
92852: PPUSH
92853: EMPTY
92854: PPUSH
92855: CALL_OW 1
92859: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
92860: LD_VAR 0 2
92864: PPUSH
92865: LD_INT 101
92867: PPUSH
92868: CALL 87726 0 2
// continue ;
92872: GO 92673
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
92874: LD_ADDR_EXP 181
92878: PUSH
92879: LD_EXP 181
92883: PPUSH
92884: LD_VAR 0 2
92888: PPUSH
92889: EMPTY
92890: PPUSH
92891: CALL_OW 1
92895: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
92896: LD_VAR 0 2
92900: PPUSH
92901: LD_INT 103
92903: PPUSH
92904: CALL 87726 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
92908: LD_ADDR_VAR 0 5
92912: PUSH
92913: LD_EXP 175
92917: PUSH
92918: LD_VAR 0 2
92922: ARRAY
92923: PUSH
92924: LD_EXP 204
92928: PUSH
92929: LD_VAR 0 2
92933: ARRAY
92934: UNION
92935: PPUSH
92936: LD_INT 2
92938: PUSH
92939: LD_INT 25
92941: PUSH
92942: LD_INT 2
92944: PUSH
92945: EMPTY
92946: LIST
92947: LIST
92948: PUSH
92949: LD_INT 25
92951: PUSH
92952: LD_INT 16
92954: PUSH
92955: EMPTY
92956: LIST
92957: LIST
92958: PUSH
92959: EMPTY
92960: LIST
92961: LIST
92962: LIST
92963: PUSH
92964: EMPTY
92965: LIST
92966: PPUSH
92967: CALL_OW 72
92971: ST_TO_ADDR
// if mc_need_heal [ i ] then
92972: LD_EXP 178
92976: PUSH
92977: LD_VAR 0 2
92981: ARRAY
92982: IFFALSE 93026
// tmp := tmp diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
92984: LD_ADDR_VAR 0 5
92988: PUSH
92989: LD_VAR 0 5
92993: PUSH
92994: LD_EXP 178
92998: PUSH
92999: LD_VAR 0 2
93003: ARRAY
93004: PUSH
93005: LD_INT 1
93007: ARRAY
93008: PUSH
93009: LD_EXP 178
93013: PUSH
93014: LD_VAR 0 2
93018: ARRAY
93019: PUSH
93020: LD_INT 2
93022: ARRAY
93023: UNION
93024: DIFF
93025: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
93026: LD_ADDR_VAR 0 6
93030: PUSH
93031: LD_EXP 194
93035: PUSH
93036: LD_VAR 0 2
93040: ARRAY
93041: PPUSH
93042: LD_INT 2
93044: PUSH
93045: LD_INT 34
93047: PUSH
93048: LD_INT 13
93050: PUSH
93051: EMPTY
93052: LIST
93053: LIST
93054: PUSH
93055: LD_INT 34
93057: PUSH
93058: LD_INT 52
93060: PUSH
93061: EMPTY
93062: LIST
93063: LIST
93064: PUSH
93065: LD_INT 34
93067: PUSH
93068: LD_EXP 160
93072: PUSH
93073: EMPTY
93074: LIST
93075: LIST
93076: PUSH
93077: EMPTY
93078: LIST
93079: LIST
93080: LIST
93081: LIST
93082: PPUSH
93083: CALL_OW 72
93087: ST_TO_ADDR
// if cranes then
93088: LD_VAR 0 6
93092: IFFALSE 93228
// begin for j in cranes do
93094: LD_ADDR_VAR 0 3
93098: PUSH
93099: LD_VAR 0 6
93103: PUSH
93104: FOR_IN
93105: IFFALSE 93226
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
93107: LD_VAR 0 3
93111: PPUSH
93112: CALL_OW 256
93116: PUSH
93117: LD_INT 1000
93119: EQUAL
93120: PUSH
93121: LD_VAR 0 3
93125: PPUSH
93126: CALL_OW 314
93130: NOT
93131: AND
93132: IFFALSE 93166
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) else
93134: LD_VAR 0 3
93138: PPUSH
93139: LD_EXP 176
93143: PUSH
93144: LD_VAR 0 2
93148: ARRAY
93149: PPUSH
93150: LD_VAR 0 3
93154: PPUSH
93155: CALL_OW 74
93159: PPUSH
93160: CALL_OW 130
93164: GO 93224
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
93166: LD_VAR 0 3
93170: PPUSH
93171: CALL_OW 256
93175: PUSH
93176: LD_INT 500
93178: LESS
93179: PUSH
93180: LD_VAR 0 3
93184: PPUSH
93185: LD_EXP 199
93189: PUSH
93190: LD_VAR 0 2
93194: ARRAY
93195: PPUSH
93196: CALL_OW 308
93200: NOT
93201: AND
93202: IFFALSE 93224
// ComMoveToArea ( j , mc_parking [ i ] ) ;
93204: LD_VAR 0 3
93208: PPUSH
93209: LD_EXP 199
93213: PUSH
93214: LD_VAR 0 2
93218: ARRAY
93219: PPUSH
93220: CALL_OW 113
// end ;
93224: GO 93104
93226: POP
93227: POP
// end ; if tmp > 3 then
93228: LD_VAR 0 5
93232: PUSH
93233: LD_INT 3
93235: GREATER
93236: IFFALSE 93256
// tmp := ShrinkArray ( tmp , 4 ) ;
93238: LD_ADDR_VAR 0 5
93242: PUSH
93243: LD_VAR 0 5
93247: PPUSH
93248: LD_INT 4
93250: PPUSH
93251: CALL 56276 0 2
93255: ST_TO_ADDR
// if not tmp then
93256: LD_VAR 0 5
93260: NOT
93261: IFFALSE 93265
// continue ;
93263: GO 92673
// for j in tmp do
93265: LD_ADDR_VAR 0 3
93269: PUSH
93270: LD_VAR 0 5
93274: PUSH
93275: FOR_IN
93276: IFFALSE 93535
// begin if IsInUnit ( j ) then
93278: LD_VAR 0 3
93282: PPUSH
93283: CALL_OW 310
93287: IFFALSE 93298
// ComExitBuilding ( j ) ;
93289: LD_VAR 0 3
93293: PPUSH
93294: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
93298: LD_VAR 0 3
93302: PUSH
93303: LD_EXP 177
93307: PUSH
93308: LD_VAR 0 2
93312: ARRAY
93313: IN
93314: NOT
93315: IFFALSE 93373
// begin SetTag ( j , 101 ) ;
93317: LD_VAR 0 3
93321: PPUSH
93322: LD_INT 101
93324: PPUSH
93325: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
93329: LD_ADDR_EXP 177
93333: PUSH
93334: LD_EXP 177
93338: PPUSH
93339: LD_VAR 0 2
93343: PUSH
93344: LD_EXP 177
93348: PUSH
93349: LD_VAR 0 2
93353: ARRAY
93354: PUSH
93355: LD_INT 1
93357: PLUS
93358: PUSH
93359: EMPTY
93360: LIST
93361: LIST
93362: PPUSH
93363: LD_VAR 0 3
93367: PPUSH
93368: CALL 24210 0 3
93372: ST_TO_ADDR
// end ; wait ( 1 ) ;
93373: LD_INT 1
93375: PPUSH
93376: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
93380: LD_ADDR_VAR 0 7
93384: PUSH
93385: LD_EXP 176
93389: PUSH
93390: LD_VAR 0 2
93394: ARRAY
93395: ST_TO_ADDR
// if mc_scan [ i ] then
93396: LD_EXP 198
93400: PUSH
93401: LD_VAR 0 2
93405: ARRAY
93406: IFFALSE 93468
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
93408: LD_ADDR_VAR 0 7
93412: PUSH
93413: LD_EXP 176
93417: PUSH
93418: LD_VAR 0 2
93422: ARRAY
93423: PPUSH
93424: LD_INT 3
93426: PUSH
93427: LD_INT 30
93429: PUSH
93430: LD_INT 32
93432: PUSH
93433: EMPTY
93434: LIST
93435: LIST
93436: PUSH
93437: LD_INT 30
93439: PUSH
93440: LD_INT 33
93442: PUSH
93443: EMPTY
93444: LIST
93445: LIST
93446: PUSH
93447: LD_INT 30
93449: PUSH
93450: LD_INT 31
93452: PUSH
93453: EMPTY
93454: LIST
93455: LIST
93456: PUSH
93457: EMPTY
93458: LIST
93459: LIST
93460: LIST
93461: LIST
93462: PPUSH
93463: CALL_OW 72
93467: ST_TO_ADDR
// if not to_repair_tmp then
93468: LD_VAR 0 7
93472: NOT
93473: IFFALSE 93477
// continue ;
93475: GO 93275
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
93477: LD_ADDR_VAR 0 8
93481: PUSH
93482: LD_VAR 0 7
93486: PPUSH
93487: LD_VAR 0 3
93491: PPUSH
93492: CALL_OW 74
93496: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
93497: LD_VAR 0 8
93501: PPUSH
93502: LD_INT 16
93504: PPUSH
93505: CALL 26809 0 2
93509: PUSH
93510: LD_INT 4
93512: ARRAY
93513: PUSH
93514: LD_INT 10
93516: LESS
93517: IFFALSE 93533
// ComRepairBuilding ( j , to_repair ) ;
93519: LD_VAR 0 3
93523: PPUSH
93524: LD_VAR 0 8
93528: PPUSH
93529: CALL_OW 130
// end ;
93533: GO 93275
93535: POP
93536: POP
// end ;
93537: GO 92673
93539: POP
93540: POP
// end ;
93541: LD_VAR 0 1
93545: RET
// export function MC_Heal ; var i , j , tmp ; begin
93546: LD_INT 0
93548: PPUSH
93549: PPUSH
93550: PPUSH
93551: PPUSH
// if not mc_bases then
93552: LD_EXP 175
93556: NOT
93557: IFFALSE 93561
// exit ;
93559: GO 93963
// for i = 1 to mc_bases do
93561: LD_ADDR_VAR 0 2
93565: PUSH
93566: DOUBLE
93567: LD_INT 1
93569: DEC
93570: ST_TO_ADDR
93571: LD_EXP 175
93575: PUSH
93576: FOR_TO
93577: IFFALSE 93961
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
93579: LD_EXP 178
93583: PUSH
93584: LD_VAR 0 2
93588: ARRAY
93589: PUSH
93590: LD_INT 1
93592: ARRAY
93593: NOT
93594: PUSH
93595: LD_EXP 178
93599: PUSH
93600: LD_VAR 0 2
93604: ARRAY
93605: PUSH
93606: LD_INT 2
93608: ARRAY
93609: NOT
93610: AND
93611: IFFALSE 93649
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
93613: LD_ADDR_EXP 179
93617: PUSH
93618: LD_EXP 179
93622: PPUSH
93623: LD_VAR 0 2
93627: PPUSH
93628: EMPTY
93629: PPUSH
93630: CALL_OW 1
93634: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
93635: LD_VAR 0 2
93639: PPUSH
93640: LD_INT 102
93642: PPUSH
93643: CALL 87726 0 2
// continue ;
93647: GO 93576
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
93649: LD_ADDR_VAR 0 4
93653: PUSH
93654: LD_EXP 175
93658: PUSH
93659: LD_VAR 0 2
93663: ARRAY
93664: PPUSH
93665: LD_INT 25
93667: PUSH
93668: LD_INT 4
93670: PUSH
93671: EMPTY
93672: LIST
93673: LIST
93674: PPUSH
93675: CALL_OW 72
93679: ST_TO_ADDR
// if not tmp then
93680: LD_VAR 0 4
93684: NOT
93685: IFFALSE 93689
// continue ;
93687: GO 93576
// if mc_taming [ i ] then
93689: LD_EXP 206
93693: PUSH
93694: LD_VAR 0 2
93698: ARRAY
93699: IFFALSE 93723
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
93701: LD_ADDR_EXP 206
93705: PUSH
93706: LD_EXP 206
93710: PPUSH
93711: LD_VAR 0 2
93715: PPUSH
93716: EMPTY
93717: PPUSH
93718: CALL_OW 1
93722: ST_TO_ADDR
// for j in tmp do
93723: LD_ADDR_VAR 0 3
93727: PUSH
93728: LD_VAR 0 4
93732: PUSH
93733: FOR_IN
93734: IFFALSE 93957
// begin if IsInUnit ( j ) then
93736: LD_VAR 0 3
93740: PPUSH
93741: CALL_OW 310
93745: IFFALSE 93756
// ComExitBuilding ( j ) ;
93747: LD_VAR 0 3
93751: PPUSH
93752: CALL_OW 122
// if not j in mc_healers [ i ] then
93756: LD_VAR 0 3
93760: PUSH
93761: LD_EXP 179
93765: PUSH
93766: LD_VAR 0 2
93770: ARRAY
93771: IN
93772: NOT
93773: IFFALSE 93819
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
93775: LD_ADDR_EXP 179
93779: PUSH
93780: LD_EXP 179
93784: PPUSH
93785: LD_VAR 0 2
93789: PUSH
93790: LD_EXP 179
93794: PUSH
93795: LD_VAR 0 2
93799: ARRAY
93800: PUSH
93801: LD_INT 1
93803: PLUS
93804: PUSH
93805: EMPTY
93806: LIST
93807: LIST
93808: PPUSH
93809: LD_VAR 0 3
93813: PPUSH
93814: CALL 24210 0 3
93818: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
93819: LD_VAR 0 3
93823: PPUSH
93824: CALL_OW 110
93828: PUSH
93829: LD_INT 102
93831: NONEQUAL
93832: IFFALSE 93846
// SetTag ( j , 102 ) ;
93834: LD_VAR 0 3
93838: PPUSH
93839: LD_INT 102
93841: PPUSH
93842: CALL_OW 109
// Wait ( 3 ) ;
93846: LD_INT 3
93848: PPUSH
93849: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
93853: LD_EXP 178
93857: PUSH
93858: LD_VAR 0 2
93862: ARRAY
93863: PUSH
93864: LD_INT 1
93866: ARRAY
93867: IFFALSE 93899
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
93869: LD_VAR 0 3
93873: PPUSH
93874: LD_EXP 178
93878: PUSH
93879: LD_VAR 0 2
93883: ARRAY
93884: PUSH
93885: LD_INT 1
93887: ARRAY
93888: PUSH
93889: LD_INT 1
93891: ARRAY
93892: PPUSH
93893: CALL_OW 128
93897: GO 93955
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
93899: LD_VAR 0 3
93903: PPUSH
93904: CALL_OW 314
93908: NOT
93909: PUSH
93910: LD_EXP 178
93914: PUSH
93915: LD_VAR 0 2
93919: ARRAY
93920: PUSH
93921: LD_INT 2
93923: ARRAY
93924: AND
93925: IFFALSE 93955
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
93927: LD_VAR 0 3
93931: PPUSH
93932: LD_EXP 178
93936: PUSH
93937: LD_VAR 0 2
93941: ARRAY
93942: PUSH
93943: LD_INT 2
93945: ARRAY
93946: PUSH
93947: LD_INT 1
93949: ARRAY
93950: PPUSH
93951: CALL_OW 128
// end ;
93955: GO 93733
93957: POP
93958: POP
// end ;
93959: GO 93576
93961: POP
93962: POP
// end ;
93963: LD_VAR 0 1
93967: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
93968: LD_INT 0
93970: PPUSH
93971: PPUSH
93972: PPUSH
93973: PPUSH
93974: PPUSH
// if not mc_bases then
93975: LD_EXP 175
93979: NOT
93980: IFFALSE 93984
// exit ;
93982: GO 95155
// for i = 1 to mc_bases do
93984: LD_ADDR_VAR 0 2
93988: PUSH
93989: DOUBLE
93990: LD_INT 1
93992: DEC
93993: ST_TO_ADDR
93994: LD_EXP 175
93998: PUSH
93999: FOR_TO
94000: IFFALSE 95153
// begin if mc_scan [ i ] then
94002: LD_EXP 198
94006: PUSH
94007: LD_VAR 0 2
94011: ARRAY
94012: IFFALSE 94016
// continue ;
94014: GO 93999
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
94016: LD_EXP 180
94020: PUSH
94021: LD_VAR 0 2
94025: ARRAY
94026: NOT
94027: PUSH
94028: LD_EXP 182
94032: PUSH
94033: LD_VAR 0 2
94037: ARRAY
94038: NOT
94039: AND
94040: PUSH
94041: LD_EXP 181
94045: PUSH
94046: LD_VAR 0 2
94050: ARRAY
94051: AND
94052: IFFALSE 94090
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
94054: LD_ADDR_EXP 181
94058: PUSH
94059: LD_EXP 181
94063: PPUSH
94064: LD_VAR 0 2
94068: PPUSH
94069: EMPTY
94070: PPUSH
94071: CALL_OW 1
94075: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
94076: LD_VAR 0 2
94080: PPUSH
94081: LD_INT 103
94083: PPUSH
94084: CALL 87726 0 2
// continue ;
94088: GO 93999
// end ; if mc_construct_list [ i ] then
94090: LD_EXP 182
94094: PUSH
94095: LD_VAR 0 2
94099: ARRAY
94100: IFFALSE 94320
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
94102: LD_ADDR_VAR 0 4
94106: PUSH
94107: LD_EXP 175
94111: PUSH
94112: LD_VAR 0 2
94116: ARRAY
94117: PPUSH
94118: LD_INT 25
94120: PUSH
94121: LD_INT 2
94123: PUSH
94124: EMPTY
94125: LIST
94126: LIST
94127: PPUSH
94128: CALL_OW 72
94132: PUSH
94133: LD_EXP 177
94137: PUSH
94138: LD_VAR 0 2
94142: ARRAY
94143: DIFF
94144: ST_TO_ADDR
// if not tmp then
94145: LD_VAR 0 4
94149: NOT
94150: IFFALSE 94154
// continue ;
94152: GO 93999
// for j in tmp do
94154: LD_ADDR_VAR 0 3
94158: PUSH
94159: LD_VAR 0 4
94163: PUSH
94164: FOR_IN
94165: IFFALSE 94316
// begin if not mc_builders [ i ] then
94167: LD_EXP 181
94171: PUSH
94172: LD_VAR 0 2
94176: ARRAY
94177: NOT
94178: IFFALSE 94236
// begin SetTag ( j , 103 ) ;
94180: LD_VAR 0 3
94184: PPUSH
94185: LD_INT 103
94187: PPUSH
94188: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
94192: LD_ADDR_EXP 181
94196: PUSH
94197: LD_EXP 181
94201: PPUSH
94202: LD_VAR 0 2
94206: PUSH
94207: LD_EXP 181
94211: PUSH
94212: LD_VAR 0 2
94216: ARRAY
94217: PUSH
94218: LD_INT 1
94220: PLUS
94221: PUSH
94222: EMPTY
94223: LIST
94224: LIST
94225: PPUSH
94226: LD_VAR 0 3
94230: PPUSH
94231: CALL 24210 0 3
94235: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
94236: LD_VAR 0 3
94240: PPUSH
94241: CALL_OW 310
94245: IFFALSE 94256
// ComExitBuilding ( j ) ;
94247: LD_VAR 0 3
94251: PPUSH
94252: CALL_OW 122
// wait ( 3 ) ;
94256: LD_INT 3
94258: PPUSH
94259: CALL_OW 67
// if not mc_construct_list [ i ] then
94263: LD_EXP 182
94267: PUSH
94268: LD_VAR 0 2
94272: ARRAY
94273: NOT
94274: IFFALSE 94278
// break ;
94276: GO 94316
// if not HasTask ( j ) then
94278: LD_VAR 0 3
94282: PPUSH
94283: CALL_OW 314
94287: NOT
94288: IFFALSE 94314
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
94290: LD_VAR 0 3
94294: PPUSH
94295: LD_EXP 182
94299: PUSH
94300: LD_VAR 0 2
94304: ARRAY
94305: PUSH
94306: LD_INT 1
94308: ARRAY
94309: PPUSH
94310: CALL 27073 0 2
// end ;
94314: GO 94164
94316: POP
94317: POP
// end else
94318: GO 95151
// if mc_build_list [ i ] then
94320: LD_EXP 180
94324: PUSH
94325: LD_VAR 0 2
94329: ARRAY
94330: IFFALSE 95151
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
94332: LD_ADDR_VAR 0 5
94336: PUSH
94337: LD_EXP 175
94341: PUSH
94342: LD_VAR 0 2
94346: ARRAY
94347: PPUSH
94348: LD_INT 2
94350: PUSH
94351: LD_INT 30
94353: PUSH
94354: LD_INT 0
94356: PUSH
94357: EMPTY
94358: LIST
94359: LIST
94360: PUSH
94361: LD_INT 30
94363: PUSH
94364: LD_INT 1
94366: PUSH
94367: EMPTY
94368: LIST
94369: LIST
94370: PUSH
94371: EMPTY
94372: LIST
94373: LIST
94374: LIST
94375: PPUSH
94376: CALL_OW 72
94380: ST_TO_ADDR
// if depot then
94381: LD_VAR 0 5
94385: IFFALSE 94403
// depot := depot [ 1 ] else
94387: LD_ADDR_VAR 0 5
94391: PUSH
94392: LD_VAR 0 5
94396: PUSH
94397: LD_INT 1
94399: ARRAY
94400: ST_TO_ADDR
94401: GO 94411
// depot := 0 ;
94403: LD_ADDR_VAR 0 5
94407: PUSH
94408: LD_INT 0
94410: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
94411: LD_EXP 180
94415: PUSH
94416: LD_VAR 0 2
94420: ARRAY
94421: PUSH
94422: LD_INT 1
94424: ARRAY
94425: PUSH
94426: LD_INT 1
94428: ARRAY
94429: PPUSH
94430: CALL 26897 0 1
94434: PUSH
94435: LD_EXP 175
94439: PUSH
94440: LD_VAR 0 2
94444: ARRAY
94445: PPUSH
94446: LD_INT 2
94448: PUSH
94449: LD_INT 30
94451: PUSH
94452: LD_INT 2
94454: PUSH
94455: EMPTY
94456: LIST
94457: LIST
94458: PUSH
94459: LD_INT 30
94461: PUSH
94462: LD_INT 3
94464: PUSH
94465: EMPTY
94466: LIST
94467: LIST
94468: PUSH
94469: EMPTY
94470: LIST
94471: LIST
94472: LIST
94473: PPUSH
94474: CALL_OW 72
94478: NOT
94479: AND
94480: IFFALSE 94585
// begin for j = 1 to mc_build_list [ i ] do
94482: LD_ADDR_VAR 0 3
94486: PUSH
94487: DOUBLE
94488: LD_INT 1
94490: DEC
94491: ST_TO_ADDR
94492: LD_EXP 180
94496: PUSH
94497: LD_VAR 0 2
94501: ARRAY
94502: PUSH
94503: FOR_TO
94504: IFFALSE 94583
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
94506: LD_EXP 180
94510: PUSH
94511: LD_VAR 0 2
94515: ARRAY
94516: PUSH
94517: LD_VAR 0 3
94521: ARRAY
94522: PUSH
94523: LD_INT 1
94525: ARRAY
94526: PUSH
94527: LD_INT 2
94529: EQUAL
94530: IFFALSE 94581
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
94532: LD_ADDR_EXP 180
94536: PUSH
94537: LD_EXP 180
94541: PPUSH
94542: LD_VAR 0 2
94546: PPUSH
94547: LD_EXP 180
94551: PUSH
94552: LD_VAR 0 2
94556: ARRAY
94557: PPUSH
94558: LD_VAR 0 3
94562: PPUSH
94563: LD_INT 1
94565: PPUSH
94566: LD_INT 0
94568: PPUSH
94569: CALL 23628 0 4
94573: PPUSH
94574: CALL_OW 1
94578: ST_TO_ADDR
// break ;
94579: GO 94583
// end ;
94581: GO 94503
94583: POP
94584: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
94585: LD_EXP 180
94589: PUSH
94590: LD_VAR 0 2
94594: ARRAY
94595: PUSH
94596: LD_INT 1
94598: ARRAY
94599: PUSH
94600: LD_INT 1
94602: ARRAY
94603: PUSH
94604: LD_INT 0
94606: EQUAL
94607: PUSH
94608: LD_VAR 0 5
94612: PUSH
94613: LD_VAR 0 5
94617: PPUSH
94618: LD_EXP 180
94622: PUSH
94623: LD_VAR 0 2
94627: ARRAY
94628: PUSH
94629: LD_INT 1
94631: ARRAY
94632: PUSH
94633: LD_INT 1
94635: ARRAY
94636: PPUSH
94637: LD_EXP 180
94641: PUSH
94642: LD_VAR 0 2
94646: ARRAY
94647: PUSH
94648: LD_INT 1
94650: ARRAY
94651: PUSH
94652: LD_INT 2
94654: ARRAY
94655: PPUSH
94656: LD_EXP 180
94660: PUSH
94661: LD_VAR 0 2
94665: ARRAY
94666: PUSH
94667: LD_INT 1
94669: ARRAY
94670: PUSH
94671: LD_INT 3
94673: ARRAY
94674: PPUSH
94675: LD_EXP 180
94679: PUSH
94680: LD_VAR 0 2
94684: ARRAY
94685: PUSH
94686: LD_INT 1
94688: ARRAY
94689: PUSH
94690: LD_INT 4
94692: ARRAY
94693: PPUSH
94694: CALL 32313 0 5
94698: AND
94699: OR
94700: IFFALSE 94981
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
94702: LD_ADDR_VAR 0 4
94706: PUSH
94707: LD_EXP 175
94711: PUSH
94712: LD_VAR 0 2
94716: ARRAY
94717: PPUSH
94718: LD_INT 25
94720: PUSH
94721: LD_INT 2
94723: PUSH
94724: EMPTY
94725: LIST
94726: LIST
94727: PPUSH
94728: CALL_OW 72
94732: PUSH
94733: LD_EXP 177
94737: PUSH
94738: LD_VAR 0 2
94742: ARRAY
94743: DIFF
94744: ST_TO_ADDR
// if not tmp then
94745: LD_VAR 0 4
94749: NOT
94750: IFFALSE 94754
// continue ;
94752: GO 93999
// for j in tmp do
94754: LD_ADDR_VAR 0 3
94758: PUSH
94759: LD_VAR 0 4
94763: PUSH
94764: FOR_IN
94765: IFFALSE 94977
// begin if not mc_builders [ i ] then
94767: LD_EXP 181
94771: PUSH
94772: LD_VAR 0 2
94776: ARRAY
94777: NOT
94778: IFFALSE 94836
// begin SetTag ( j , 103 ) ;
94780: LD_VAR 0 3
94784: PPUSH
94785: LD_INT 103
94787: PPUSH
94788: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
94792: LD_ADDR_EXP 181
94796: PUSH
94797: LD_EXP 181
94801: PPUSH
94802: LD_VAR 0 2
94806: PUSH
94807: LD_EXP 181
94811: PUSH
94812: LD_VAR 0 2
94816: ARRAY
94817: PUSH
94818: LD_INT 1
94820: PLUS
94821: PUSH
94822: EMPTY
94823: LIST
94824: LIST
94825: PPUSH
94826: LD_VAR 0 3
94830: PPUSH
94831: CALL 24210 0 3
94835: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
94836: LD_VAR 0 3
94840: PPUSH
94841: CALL_OW 310
94845: IFFALSE 94856
// ComExitBuilding ( j ) ;
94847: LD_VAR 0 3
94851: PPUSH
94852: CALL_OW 122
// wait ( 3 ) ;
94856: LD_INT 3
94858: PPUSH
94859: CALL_OW 67
// if not mc_build_list [ i ] then
94863: LD_EXP 180
94867: PUSH
94868: LD_VAR 0 2
94872: ARRAY
94873: NOT
94874: IFFALSE 94878
// break ;
94876: GO 94977
// if not HasTask ( j ) then
94878: LD_VAR 0 3
94882: PPUSH
94883: CALL_OW 314
94887: NOT
94888: IFFALSE 94975
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
94890: LD_VAR 0 3
94894: PPUSH
94895: LD_EXP 180
94899: PUSH
94900: LD_VAR 0 2
94904: ARRAY
94905: PUSH
94906: LD_INT 1
94908: ARRAY
94909: PUSH
94910: LD_INT 1
94912: ARRAY
94913: PPUSH
94914: LD_EXP 180
94918: PUSH
94919: LD_VAR 0 2
94923: ARRAY
94924: PUSH
94925: LD_INT 1
94927: ARRAY
94928: PUSH
94929: LD_INT 2
94931: ARRAY
94932: PPUSH
94933: LD_EXP 180
94937: PUSH
94938: LD_VAR 0 2
94942: ARRAY
94943: PUSH
94944: LD_INT 1
94946: ARRAY
94947: PUSH
94948: LD_INT 3
94950: ARRAY
94951: PPUSH
94952: LD_EXP 180
94956: PUSH
94957: LD_VAR 0 2
94961: ARRAY
94962: PUSH
94963: LD_INT 1
94965: ARRAY
94966: PUSH
94967: LD_INT 4
94969: ARRAY
94970: PPUSH
94971: CALL_OW 145
// end ;
94975: GO 94764
94977: POP
94978: POP
// end else
94979: GO 95151
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
94981: LD_EXP 175
94985: PUSH
94986: LD_VAR 0 2
94990: ARRAY
94991: PPUSH
94992: LD_EXP 180
94996: PUSH
94997: LD_VAR 0 2
95001: ARRAY
95002: PUSH
95003: LD_INT 1
95005: ARRAY
95006: PUSH
95007: LD_INT 1
95009: ARRAY
95010: PPUSH
95011: LD_EXP 180
95015: PUSH
95016: LD_VAR 0 2
95020: ARRAY
95021: PUSH
95022: LD_INT 1
95024: ARRAY
95025: PUSH
95026: LD_INT 2
95028: ARRAY
95029: PPUSH
95030: LD_EXP 180
95034: PUSH
95035: LD_VAR 0 2
95039: ARRAY
95040: PUSH
95041: LD_INT 1
95043: ARRAY
95044: PUSH
95045: LD_INT 3
95047: ARRAY
95048: PPUSH
95049: LD_EXP 180
95053: PUSH
95054: LD_VAR 0 2
95058: ARRAY
95059: PUSH
95060: LD_INT 1
95062: ARRAY
95063: PUSH
95064: LD_INT 4
95066: ARRAY
95067: PPUSH
95068: LD_EXP 175
95072: PUSH
95073: LD_VAR 0 2
95077: ARRAY
95078: PPUSH
95079: LD_INT 21
95081: PUSH
95082: LD_INT 3
95084: PUSH
95085: EMPTY
95086: LIST
95087: LIST
95088: PPUSH
95089: CALL_OW 72
95093: PPUSH
95094: EMPTY
95095: PPUSH
95096: CALL 31063 0 7
95100: NOT
95101: IFFALSE 95151
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
95103: LD_ADDR_EXP 180
95107: PUSH
95108: LD_EXP 180
95112: PPUSH
95113: LD_VAR 0 2
95117: PPUSH
95118: LD_EXP 180
95122: PUSH
95123: LD_VAR 0 2
95127: ARRAY
95128: PPUSH
95129: LD_INT 1
95131: PPUSH
95132: LD_INT 1
95134: NEG
95135: PPUSH
95136: LD_INT 0
95138: PPUSH
95139: CALL 23628 0 4
95143: PPUSH
95144: CALL_OW 1
95148: ST_TO_ADDR
// continue ;
95149: GO 93999
// end ; end ; end ;
95151: GO 93999
95153: POP
95154: POP
// end ;
95155: LD_VAR 0 1
95159: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
95160: LD_INT 0
95162: PPUSH
95163: PPUSH
95164: PPUSH
95165: PPUSH
95166: PPUSH
95167: PPUSH
// if not mc_bases then
95168: LD_EXP 175
95172: NOT
95173: IFFALSE 95177
// exit ;
95175: GO 95604
// for i = 1 to mc_bases do
95177: LD_ADDR_VAR 0 2
95181: PUSH
95182: DOUBLE
95183: LD_INT 1
95185: DEC
95186: ST_TO_ADDR
95187: LD_EXP 175
95191: PUSH
95192: FOR_TO
95193: IFFALSE 95602
// begin tmp := mc_build_upgrade [ i ] ;
95195: LD_ADDR_VAR 0 4
95199: PUSH
95200: LD_EXP 207
95204: PUSH
95205: LD_VAR 0 2
95209: ARRAY
95210: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
95211: LD_ADDR_VAR 0 6
95215: PUSH
95216: LD_EXP 208
95220: PUSH
95221: LD_VAR 0 2
95225: ARRAY
95226: PPUSH
95227: LD_INT 2
95229: PUSH
95230: LD_INT 30
95232: PUSH
95233: LD_INT 6
95235: PUSH
95236: EMPTY
95237: LIST
95238: LIST
95239: PUSH
95240: LD_INT 30
95242: PUSH
95243: LD_INT 7
95245: PUSH
95246: EMPTY
95247: LIST
95248: LIST
95249: PUSH
95250: EMPTY
95251: LIST
95252: LIST
95253: LIST
95254: PPUSH
95255: CALL_OW 72
95259: ST_TO_ADDR
// if not tmp and not lab then
95260: LD_VAR 0 4
95264: NOT
95265: PUSH
95266: LD_VAR 0 6
95270: NOT
95271: AND
95272: IFFALSE 95276
// continue ;
95274: GO 95192
// if tmp then
95276: LD_VAR 0 4
95280: IFFALSE 95400
// for j in tmp do
95282: LD_ADDR_VAR 0 3
95286: PUSH
95287: LD_VAR 0 4
95291: PUSH
95292: FOR_IN
95293: IFFALSE 95398
// begin if UpgradeCost ( j ) then
95295: LD_VAR 0 3
95299: PPUSH
95300: CALL 30723 0 1
95304: IFFALSE 95396
// begin ComUpgrade ( j ) ;
95306: LD_VAR 0 3
95310: PPUSH
95311: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
95315: LD_ADDR_EXP 207
95319: PUSH
95320: LD_EXP 207
95324: PPUSH
95325: LD_VAR 0 2
95329: PPUSH
95330: LD_EXP 207
95334: PUSH
95335: LD_VAR 0 2
95339: ARRAY
95340: PUSH
95341: LD_VAR 0 3
95345: DIFF
95346: PPUSH
95347: CALL_OW 1
95351: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
95352: LD_ADDR_EXP 182
95356: PUSH
95357: LD_EXP 182
95361: PPUSH
95362: LD_VAR 0 2
95366: PUSH
95367: LD_EXP 182
95371: PUSH
95372: LD_VAR 0 2
95376: ARRAY
95377: PUSH
95378: LD_INT 1
95380: PLUS
95381: PUSH
95382: EMPTY
95383: LIST
95384: LIST
95385: PPUSH
95386: LD_VAR 0 3
95390: PPUSH
95391: CALL 24210 0 3
95395: ST_TO_ADDR
// end ; end ;
95396: GO 95292
95398: POP
95399: POP
// if not lab or not mc_lab_upgrade [ i ] then
95400: LD_VAR 0 6
95404: NOT
95405: PUSH
95406: LD_EXP 209
95410: PUSH
95411: LD_VAR 0 2
95415: ARRAY
95416: NOT
95417: OR
95418: IFFALSE 95422
// continue ;
95420: GO 95192
// for j in lab do
95422: LD_ADDR_VAR 0 3
95426: PUSH
95427: LD_VAR 0 6
95431: PUSH
95432: FOR_IN
95433: IFFALSE 95598
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
95435: LD_VAR 0 3
95439: PPUSH
95440: CALL_OW 266
95444: PUSH
95445: LD_INT 6
95447: PUSH
95448: LD_INT 7
95450: PUSH
95451: EMPTY
95452: LIST
95453: LIST
95454: IN
95455: PUSH
95456: LD_VAR 0 3
95460: PPUSH
95461: CALL_OW 461
95465: PUSH
95466: LD_INT 1
95468: NONEQUAL
95469: AND
95470: IFFALSE 95596
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
95472: LD_VAR 0 3
95476: PPUSH
95477: LD_EXP 209
95481: PUSH
95482: LD_VAR 0 2
95486: ARRAY
95487: PUSH
95488: LD_INT 1
95490: ARRAY
95491: PPUSH
95492: CALL 30928 0 2
95496: IFFALSE 95596
// begin ComCancel ( j ) ;
95498: LD_VAR 0 3
95502: PPUSH
95503: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
95507: LD_VAR 0 3
95511: PPUSH
95512: LD_EXP 209
95516: PUSH
95517: LD_VAR 0 2
95521: ARRAY
95522: PUSH
95523: LD_INT 1
95525: ARRAY
95526: PPUSH
95527: CALL_OW 207
// if not j in mc_construct_list [ i ] then
95531: LD_VAR 0 3
95535: PUSH
95536: LD_EXP 182
95540: PUSH
95541: LD_VAR 0 2
95545: ARRAY
95546: IN
95547: NOT
95548: IFFALSE 95594
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
95550: LD_ADDR_EXP 182
95554: PUSH
95555: LD_EXP 182
95559: PPUSH
95560: LD_VAR 0 2
95564: PUSH
95565: LD_EXP 182
95569: PUSH
95570: LD_VAR 0 2
95574: ARRAY
95575: PUSH
95576: LD_INT 1
95578: PLUS
95579: PUSH
95580: EMPTY
95581: LIST
95582: LIST
95583: PPUSH
95584: LD_VAR 0 3
95588: PPUSH
95589: CALL 24210 0 3
95593: ST_TO_ADDR
// break ;
95594: GO 95598
// end ; end ; end ;
95596: GO 95432
95598: POP
95599: POP
// end ;
95600: GO 95192
95602: POP
95603: POP
// end ;
95604: LD_VAR 0 1
95608: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
95609: LD_INT 0
95611: PPUSH
95612: PPUSH
95613: PPUSH
95614: PPUSH
95615: PPUSH
95616: PPUSH
95617: PPUSH
95618: PPUSH
95619: PPUSH
// if not mc_bases then
95620: LD_EXP 175
95624: NOT
95625: IFFALSE 95629
// exit ;
95627: GO 96034
// for i = 1 to mc_bases do
95629: LD_ADDR_VAR 0 2
95633: PUSH
95634: DOUBLE
95635: LD_INT 1
95637: DEC
95638: ST_TO_ADDR
95639: LD_EXP 175
95643: PUSH
95644: FOR_TO
95645: IFFALSE 96032
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
95647: LD_EXP 183
95651: PUSH
95652: LD_VAR 0 2
95656: ARRAY
95657: NOT
95658: PUSH
95659: LD_EXP 175
95663: PUSH
95664: LD_VAR 0 2
95668: ARRAY
95669: PPUSH
95670: LD_INT 30
95672: PUSH
95673: LD_INT 3
95675: PUSH
95676: EMPTY
95677: LIST
95678: LIST
95679: PPUSH
95680: CALL_OW 72
95684: NOT
95685: OR
95686: IFFALSE 95690
// continue ;
95688: GO 95644
// busy := false ;
95690: LD_ADDR_VAR 0 8
95694: PUSH
95695: LD_INT 0
95697: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
95698: LD_ADDR_VAR 0 4
95702: PUSH
95703: LD_EXP 175
95707: PUSH
95708: LD_VAR 0 2
95712: ARRAY
95713: PPUSH
95714: LD_INT 30
95716: PUSH
95717: LD_INT 3
95719: PUSH
95720: EMPTY
95721: LIST
95722: LIST
95723: PPUSH
95724: CALL_OW 72
95728: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
95729: LD_ADDR_VAR 0 6
95733: PUSH
95734: LD_EXP 183
95738: PUSH
95739: LD_VAR 0 2
95743: ARRAY
95744: PPUSH
95745: LD_INT 2
95747: PUSH
95748: LD_INT 30
95750: PUSH
95751: LD_INT 32
95753: PUSH
95754: EMPTY
95755: LIST
95756: LIST
95757: PUSH
95758: LD_INT 30
95760: PUSH
95761: LD_INT 33
95763: PUSH
95764: EMPTY
95765: LIST
95766: LIST
95767: PUSH
95768: EMPTY
95769: LIST
95770: LIST
95771: LIST
95772: PPUSH
95773: CALL_OW 72
95777: ST_TO_ADDR
// if not t then
95778: LD_VAR 0 6
95782: NOT
95783: IFFALSE 95787
// continue ;
95785: GO 95644
// for j in tmp do
95787: LD_ADDR_VAR 0 3
95791: PUSH
95792: LD_VAR 0 4
95796: PUSH
95797: FOR_IN
95798: IFFALSE 95828
// if not BuildingStatus ( j ) = bs_idle then
95800: LD_VAR 0 3
95804: PPUSH
95805: CALL_OW 461
95809: PUSH
95810: LD_INT 2
95812: EQUAL
95813: NOT
95814: IFFALSE 95826
// begin busy := true ;
95816: LD_ADDR_VAR 0 8
95820: PUSH
95821: LD_INT 1
95823: ST_TO_ADDR
// break ;
95824: GO 95828
// end ;
95826: GO 95797
95828: POP
95829: POP
// if busy then
95830: LD_VAR 0 8
95834: IFFALSE 95838
// continue ;
95836: GO 95644
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
95838: LD_ADDR_VAR 0 7
95842: PUSH
95843: LD_VAR 0 6
95847: PPUSH
95848: LD_INT 35
95850: PUSH
95851: LD_INT 0
95853: PUSH
95854: EMPTY
95855: LIST
95856: LIST
95857: PPUSH
95858: CALL_OW 72
95862: ST_TO_ADDR
// if tw then
95863: LD_VAR 0 7
95867: IFFALSE 95944
// begin tw := tw [ 1 ] ;
95869: LD_ADDR_VAR 0 7
95873: PUSH
95874: LD_VAR 0 7
95878: PUSH
95879: LD_INT 1
95881: ARRAY
95882: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
95883: LD_ADDR_VAR 0 9
95887: PUSH
95888: LD_VAR 0 7
95892: PPUSH
95893: LD_EXP 200
95897: PUSH
95898: LD_VAR 0 2
95902: ARRAY
95903: PPUSH
95904: CALL 29220 0 2
95908: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
95909: LD_EXP 214
95913: PUSH
95914: LD_VAR 0 2
95918: ARRAY
95919: IFFALSE 95942
// if not weapon in mc_allowed_tower_weapons [ i ] then
95921: LD_VAR 0 9
95925: PUSH
95926: LD_EXP 214
95930: PUSH
95931: LD_VAR 0 2
95935: ARRAY
95936: IN
95937: NOT
95938: IFFALSE 95942
// continue ;
95940: GO 95644
// end else
95942: GO 96007
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
95944: LD_ADDR_VAR 0 5
95948: PUSH
95949: LD_EXP 183
95953: PUSH
95954: LD_VAR 0 2
95958: ARRAY
95959: PPUSH
95960: LD_VAR 0 4
95964: PPUSH
95965: CALL 55509 0 2
95969: ST_TO_ADDR
// if not tmp2 then
95970: LD_VAR 0 5
95974: NOT
95975: IFFALSE 95979
// continue ;
95977: GO 95644
// tw := tmp2 [ 1 ] ;
95979: LD_ADDR_VAR 0 7
95983: PUSH
95984: LD_VAR 0 5
95988: PUSH
95989: LD_INT 1
95991: ARRAY
95992: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
95993: LD_ADDR_VAR 0 9
95997: PUSH
95998: LD_VAR 0 5
96002: PUSH
96003: LD_INT 2
96005: ARRAY
96006: ST_TO_ADDR
// end ; if not weapon then
96007: LD_VAR 0 9
96011: NOT
96012: IFFALSE 96016
// continue ;
96014: GO 95644
// ComPlaceWeapon ( tw , weapon ) ;
96016: LD_VAR 0 7
96020: PPUSH
96021: LD_VAR 0 9
96025: PPUSH
96026: CALL_OW 148
// end ;
96030: GO 95644
96032: POP
96033: POP
// end ;
96034: LD_VAR 0 1
96038: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
96039: LD_INT 0
96041: PPUSH
96042: PPUSH
96043: PPUSH
96044: PPUSH
96045: PPUSH
96046: PPUSH
96047: PPUSH
// if not mc_bases then
96048: LD_EXP 175
96052: NOT
96053: IFFALSE 96057
// exit ;
96055: GO 96825
// for i = 1 to mc_bases do
96057: LD_ADDR_VAR 0 2
96061: PUSH
96062: DOUBLE
96063: LD_INT 1
96065: DEC
96066: ST_TO_ADDR
96067: LD_EXP 175
96071: PUSH
96072: FOR_TO
96073: IFFALSE 96823
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
96075: LD_EXP 188
96079: PUSH
96080: LD_VAR 0 2
96084: ARRAY
96085: NOT
96086: PUSH
96087: LD_EXP 188
96091: PUSH
96092: LD_VAR 0 2
96096: ARRAY
96097: PUSH
96098: LD_EXP 189
96102: PUSH
96103: LD_VAR 0 2
96107: ARRAY
96108: EQUAL
96109: OR
96110: PUSH
96111: LD_EXP 198
96115: PUSH
96116: LD_VAR 0 2
96120: ARRAY
96121: OR
96122: IFFALSE 96126
// continue ;
96124: GO 96072
// if mc_miners [ i ] then
96126: LD_EXP 189
96130: PUSH
96131: LD_VAR 0 2
96135: ARRAY
96136: IFFALSE 96510
// begin for j = mc_miners [ i ] downto 1 do
96138: LD_ADDR_VAR 0 3
96142: PUSH
96143: DOUBLE
96144: LD_EXP 189
96148: PUSH
96149: LD_VAR 0 2
96153: ARRAY
96154: INC
96155: ST_TO_ADDR
96156: LD_INT 1
96158: PUSH
96159: FOR_DOWNTO
96160: IFFALSE 96508
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
96162: LD_EXP 189
96166: PUSH
96167: LD_VAR 0 2
96171: ARRAY
96172: PUSH
96173: LD_VAR 0 3
96177: ARRAY
96178: PPUSH
96179: CALL_OW 301
96183: PUSH
96184: LD_EXP 189
96188: PUSH
96189: LD_VAR 0 2
96193: ARRAY
96194: PUSH
96195: LD_VAR 0 3
96199: ARRAY
96200: PPUSH
96201: CALL_OW 257
96205: PUSH
96206: LD_INT 1
96208: NONEQUAL
96209: OR
96210: IFFALSE 96273
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
96212: LD_ADDR_VAR 0 5
96216: PUSH
96217: LD_EXP 189
96221: PUSH
96222: LD_VAR 0 2
96226: ARRAY
96227: PUSH
96228: LD_EXP 189
96232: PUSH
96233: LD_VAR 0 2
96237: ARRAY
96238: PUSH
96239: LD_VAR 0 3
96243: ARRAY
96244: DIFF
96245: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
96246: LD_ADDR_EXP 189
96250: PUSH
96251: LD_EXP 189
96255: PPUSH
96256: LD_VAR 0 2
96260: PPUSH
96261: LD_VAR 0 5
96265: PPUSH
96266: CALL_OW 1
96270: ST_TO_ADDR
// continue ;
96271: GO 96159
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
96273: LD_EXP 189
96277: PUSH
96278: LD_VAR 0 2
96282: ARRAY
96283: PUSH
96284: LD_VAR 0 3
96288: ARRAY
96289: PPUSH
96290: CALL_OW 257
96294: PUSH
96295: LD_INT 1
96297: EQUAL
96298: PUSH
96299: LD_EXP 189
96303: PUSH
96304: LD_VAR 0 2
96308: ARRAY
96309: PUSH
96310: LD_VAR 0 3
96314: ARRAY
96315: PPUSH
96316: CALL_OW 459
96320: NOT
96321: AND
96322: PUSH
96323: LD_EXP 189
96327: PUSH
96328: LD_VAR 0 2
96332: ARRAY
96333: PUSH
96334: LD_VAR 0 3
96338: ARRAY
96339: PPUSH
96340: CALL_OW 314
96344: NOT
96345: AND
96346: IFFALSE 96506
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
96348: LD_EXP 189
96352: PUSH
96353: LD_VAR 0 2
96357: ARRAY
96358: PUSH
96359: LD_VAR 0 3
96363: ARRAY
96364: PPUSH
96365: CALL_OW 310
96369: IFFALSE 96392
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
96371: LD_EXP 189
96375: PUSH
96376: LD_VAR 0 2
96380: ARRAY
96381: PUSH
96382: LD_VAR 0 3
96386: ARRAY
96387: PPUSH
96388: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
96392: LD_EXP 189
96396: PUSH
96397: LD_VAR 0 2
96401: ARRAY
96402: PUSH
96403: LD_VAR 0 3
96407: ARRAY
96408: PPUSH
96409: CALL_OW 314
96413: NOT
96414: IFFALSE 96506
// begin r := rand ( 1 , mc_mines [ i ] ) ;
96416: LD_ADDR_VAR 0 7
96420: PUSH
96421: LD_INT 1
96423: PPUSH
96424: LD_EXP 188
96428: PUSH
96429: LD_VAR 0 2
96433: ARRAY
96434: PPUSH
96435: CALL_OW 12
96439: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
96440: LD_EXP 189
96444: PUSH
96445: LD_VAR 0 2
96449: ARRAY
96450: PUSH
96451: LD_VAR 0 3
96455: ARRAY
96456: PPUSH
96457: LD_EXP 188
96461: PUSH
96462: LD_VAR 0 2
96466: ARRAY
96467: PUSH
96468: LD_VAR 0 7
96472: ARRAY
96473: PUSH
96474: LD_INT 1
96476: ARRAY
96477: PPUSH
96478: LD_EXP 188
96482: PUSH
96483: LD_VAR 0 2
96487: ARRAY
96488: PUSH
96489: LD_VAR 0 7
96493: ARRAY
96494: PUSH
96495: LD_INT 2
96497: ARRAY
96498: PPUSH
96499: LD_INT 0
96501: PPUSH
96502: CALL_OW 193
// end ; end ; end ;
96506: GO 96159
96508: POP
96509: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
96510: LD_ADDR_VAR 0 5
96514: PUSH
96515: LD_EXP 175
96519: PUSH
96520: LD_VAR 0 2
96524: ARRAY
96525: PPUSH
96526: LD_INT 2
96528: PUSH
96529: LD_INT 30
96531: PUSH
96532: LD_INT 4
96534: PUSH
96535: EMPTY
96536: LIST
96537: LIST
96538: PUSH
96539: LD_INT 30
96541: PUSH
96542: LD_INT 5
96544: PUSH
96545: EMPTY
96546: LIST
96547: LIST
96548: PUSH
96549: LD_INT 30
96551: PUSH
96552: LD_INT 32
96554: PUSH
96555: EMPTY
96556: LIST
96557: LIST
96558: PUSH
96559: EMPTY
96560: LIST
96561: LIST
96562: LIST
96563: LIST
96564: PPUSH
96565: CALL_OW 72
96569: ST_TO_ADDR
// if not tmp then
96570: LD_VAR 0 5
96574: NOT
96575: IFFALSE 96579
// continue ;
96577: GO 96072
// list := [ ] ;
96579: LD_ADDR_VAR 0 6
96583: PUSH
96584: EMPTY
96585: ST_TO_ADDR
// for j in tmp do
96586: LD_ADDR_VAR 0 3
96590: PUSH
96591: LD_VAR 0 5
96595: PUSH
96596: FOR_IN
96597: IFFALSE 96666
// begin for k in UnitsInside ( j ) do
96599: LD_ADDR_VAR 0 4
96603: PUSH
96604: LD_VAR 0 3
96608: PPUSH
96609: CALL_OW 313
96613: PUSH
96614: FOR_IN
96615: IFFALSE 96662
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
96617: LD_VAR 0 4
96621: PPUSH
96622: CALL_OW 257
96626: PUSH
96627: LD_INT 1
96629: EQUAL
96630: PUSH
96631: LD_VAR 0 4
96635: PPUSH
96636: CALL_OW 459
96640: NOT
96641: AND
96642: IFFALSE 96660
// list := list ^ k ;
96644: LD_ADDR_VAR 0 6
96648: PUSH
96649: LD_VAR 0 6
96653: PUSH
96654: LD_VAR 0 4
96658: ADD
96659: ST_TO_ADDR
96660: GO 96614
96662: POP
96663: POP
// end ;
96664: GO 96596
96666: POP
96667: POP
// list := list diff mc_miners [ i ] ;
96668: LD_ADDR_VAR 0 6
96672: PUSH
96673: LD_VAR 0 6
96677: PUSH
96678: LD_EXP 189
96682: PUSH
96683: LD_VAR 0 2
96687: ARRAY
96688: DIFF
96689: ST_TO_ADDR
// if not list then
96690: LD_VAR 0 6
96694: NOT
96695: IFFALSE 96699
// continue ;
96697: GO 96072
// k := mc_mines [ i ] - mc_miners [ i ] ;
96699: LD_ADDR_VAR 0 4
96703: PUSH
96704: LD_EXP 188
96708: PUSH
96709: LD_VAR 0 2
96713: ARRAY
96714: PUSH
96715: LD_EXP 189
96719: PUSH
96720: LD_VAR 0 2
96724: ARRAY
96725: MINUS
96726: ST_TO_ADDR
// if k > list then
96727: LD_VAR 0 4
96731: PUSH
96732: LD_VAR 0 6
96736: GREATER
96737: IFFALSE 96749
// k := list ;
96739: LD_ADDR_VAR 0 4
96743: PUSH
96744: LD_VAR 0 6
96748: ST_TO_ADDR
// for j = 1 to k do
96749: LD_ADDR_VAR 0 3
96753: PUSH
96754: DOUBLE
96755: LD_INT 1
96757: DEC
96758: ST_TO_ADDR
96759: LD_VAR 0 4
96763: PUSH
96764: FOR_TO
96765: IFFALSE 96819
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
96767: LD_ADDR_EXP 189
96771: PUSH
96772: LD_EXP 189
96776: PPUSH
96777: LD_VAR 0 2
96781: PUSH
96782: LD_EXP 189
96786: PUSH
96787: LD_VAR 0 2
96791: ARRAY
96792: PUSH
96793: LD_INT 1
96795: PLUS
96796: PUSH
96797: EMPTY
96798: LIST
96799: LIST
96800: PPUSH
96801: LD_VAR 0 6
96805: PUSH
96806: LD_VAR 0 3
96810: ARRAY
96811: PPUSH
96812: CALL 24210 0 3
96816: ST_TO_ADDR
96817: GO 96764
96819: POP
96820: POP
// end ;
96821: GO 96072
96823: POP
96824: POP
// end ;
96825: LD_VAR 0 1
96829: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , side , target , cargo , depot , fac , components ; begin
96830: LD_INT 0
96832: PPUSH
96833: PPUSH
96834: PPUSH
96835: PPUSH
96836: PPUSH
96837: PPUSH
96838: PPUSH
96839: PPUSH
96840: PPUSH
96841: PPUSH
96842: PPUSH
// if not mc_bases then
96843: LD_EXP 175
96847: NOT
96848: IFFALSE 96852
// exit ;
96850: GO 98675
// for i = 1 to mc_bases do
96852: LD_ADDR_VAR 0 2
96856: PUSH
96857: DOUBLE
96858: LD_INT 1
96860: DEC
96861: ST_TO_ADDR
96862: LD_EXP 175
96866: PUSH
96867: FOR_TO
96868: IFFALSE 98673
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
96870: LD_EXP 175
96874: PUSH
96875: LD_VAR 0 2
96879: ARRAY
96880: NOT
96881: PUSH
96882: LD_EXP 182
96886: PUSH
96887: LD_VAR 0 2
96891: ARRAY
96892: OR
96893: IFFALSE 96897
// continue ;
96895: GO 96867
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
96897: LD_EXP 191
96901: PUSH
96902: LD_VAR 0 2
96906: ARRAY
96907: NOT
96908: PUSH
96909: LD_EXP 192
96913: PUSH
96914: LD_VAR 0 2
96918: ARRAY
96919: AND
96920: IFFALSE 96958
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
96922: LD_ADDR_EXP 192
96926: PUSH
96927: LD_EXP 192
96931: PPUSH
96932: LD_VAR 0 2
96936: PPUSH
96937: EMPTY
96938: PPUSH
96939: CALL_OW 1
96943: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
96944: LD_VAR 0 2
96948: PPUSH
96949: LD_INT 107
96951: PPUSH
96952: CALL 87726 0 2
// continue ;
96956: GO 96867
// end ; target := [ ] ;
96958: LD_ADDR_VAR 0 7
96962: PUSH
96963: EMPTY
96964: ST_TO_ADDR
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
96965: LD_ADDR_VAR 0 6
96969: PUSH
96970: LD_EXP 175
96974: PUSH
96975: LD_VAR 0 2
96979: ARRAY
96980: PUSH
96981: LD_INT 1
96983: ARRAY
96984: PPUSH
96985: CALL_OW 255
96989: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
96990: LD_ADDR_VAR 0 9
96994: PUSH
96995: LD_EXP 175
96999: PUSH
97000: LD_VAR 0 2
97004: ARRAY
97005: PPUSH
97006: LD_INT 2
97008: PUSH
97009: LD_INT 30
97011: PUSH
97012: LD_INT 0
97014: PUSH
97015: EMPTY
97016: LIST
97017: LIST
97018: PUSH
97019: LD_INT 30
97021: PUSH
97022: LD_INT 1
97024: PUSH
97025: EMPTY
97026: LIST
97027: LIST
97028: PUSH
97029: EMPTY
97030: LIST
97031: LIST
97032: LIST
97033: PPUSH
97034: CALL_OW 72
97038: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
97039: LD_ADDR_VAR 0 3
97043: PUSH
97044: DOUBLE
97045: LD_EXP 191
97049: PUSH
97050: LD_VAR 0 2
97054: ARRAY
97055: INC
97056: ST_TO_ADDR
97057: LD_INT 1
97059: PUSH
97060: FOR_DOWNTO
97061: IFFALSE 97306
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
97063: LD_EXP 191
97067: PUSH
97068: LD_VAR 0 2
97072: ARRAY
97073: PUSH
97074: LD_VAR 0 3
97078: ARRAY
97079: PUSH
97080: LD_INT 2
97082: ARRAY
97083: PPUSH
97084: LD_EXP 191
97088: PUSH
97089: LD_VAR 0 2
97093: ARRAY
97094: PUSH
97095: LD_VAR 0 3
97099: ARRAY
97100: PUSH
97101: LD_INT 3
97103: ARRAY
97104: PPUSH
97105: CALL_OW 488
97109: PUSH
97110: LD_EXP 191
97114: PUSH
97115: LD_VAR 0 2
97119: ARRAY
97120: PUSH
97121: LD_VAR 0 3
97125: ARRAY
97126: PUSH
97127: LD_INT 2
97129: ARRAY
97130: PPUSH
97131: LD_EXP 191
97135: PUSH
97136: LD_VAR 0 2
97140: ARRAY
97141: PUSH
97142: LD_VAR 0 3
97146: ARRAY
97147: PUSH
97148: LD_INT 3
97150: ARRAY
97151: PPUSH
97152: CALL_OW 284
97156: PUSH
97157: LD_INT 0
97159: EQUAL
97160: AND
97161: IFFALSE 97216
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
97163: LD_ADDR_VAR 0 5
97167: PUSH
97168: LD_EXP 191
97172: PUSH
97173: LD_VAR 0 2
97177: ARRAY
97178: PPUSH
97179: LD_VAR 0 3
97183: PPUSH
97184: CALL_OW 3
97188: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
97189: LD_ADDR_EXP 191
97193: PUSH
97194: LD_EXP 191
97198: PPUSH
97199: LD_VAR 0 2
97203: PPUSH
97204: LD_VAR 0 5
97208: PPUSH
97209: CALL_OW 1
97213: ST_TO_ADDR
// continue ;
97214: GO 97060
// end ; if DangerAtRangeXY ( side , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
97216: LD_VAR 0 6
97220: PPUSH
97221: LD_EXP 191
97225: PUSH
97226: LD_VAR 0 2
97230: ARRAY
97231: PUSH
97232: LD_VAR 0 3
97236: ARRAY
97237: PUSH
97238: LD_INT 2
97240: ARRAY
97241: PPUSH
97242: LD_EXP 191
97246: PUSH
97247: LD_VAR 0 2
97251: ARRAY
97252: PUSH
97253: LD_VAR 0 3
97257: ARRAY
97258: PUSH
97259: LD_INT 3
97261: ARRAY
97262: PPUSH
97263: LD_INT 30
97265: PPUSH
97266: CALL 25106 0 4
97270: PUSH
97271: LD_INT 4
97273: ARRAY
97274: PUSH
97275: LD_INT 0
97277: EQUAL
97278: IFFALSE 97304
// begin target := mc_crates [ i ] [ j ] ;
97280: LD_ADDR_VAR 0 7
97284: PUSH
97285: LD_EXP 191
97289: PUSH
97290: LD_VAR 0 2
97294: ARRAY
97295: PUSH
97296: LD_VAR 0 3
97300: ARRAY
97301: ST_TO_ADDR
// break ;
97302: GO 97306
// end ; end ;
97304: GO 97060
97306: POP
97307: POP
// if not target then
97308: LD_VAR 0 7
97312: NOT
97313: IFFALSE 97317
// continue ;
97315: GO 96867
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
97317: LD_ADDR_VAR 0 8
97321: PUSH
97322: LD_EXP 194
97326: PUSH
97327: LD_VAR 0 2
97331: ARRAY
97332: PPUSH
97333: LD_INT 2
97335: PUSH
97336: LD_INT 3
97338: PUSH
97339: LD_INT 58
97341: PUSH
97342: EMPTY
97343: LIST
97344: PUSH
97345: EMPTY
97346: LIST
97347: LIST
97348: PUSH
97349: LD_INT 61
97351: PUSH
97352: EMPTY
97353: LIST
97354: PUSH
97355: LD_INT 33
97357: PUSH
97358: LD_INT 5
97360: PUSH
97361: EMPTY
97362: LIST
97363: LIST
97364: PUSH
97365: LD_INT 33
97367: PUSH
97368: LD_INT 3
97370: PUSH
97371: EMPTY
97372: LIST
97373: LIST
97374: PUSH
97375: EMPTY
97376: LIST
97377: LIST
97378: LIST
97379: LIST
97380: LIST
97381: PUSH
97382: LD_INT 2
97384: PUSH
97385: LD_INT 34
97387: PUSH
97388: LD_INT 32
97390: PUSH
97391: EMPTY
97392: LIST
97393: LIST
97394: PUSH
97395: LD_INT 34
97397: PUSH
97398: LD_INT 51
97400: PUSH
97401: EMPTY
97402: LIST
97403: LIST
97404: PUSH
97405: LD_INT 34
97407: PUSH
97408: LD_INT 12
97410: PUSH
97411: EMPTY
97412: LIST
97413: LIST
97414: PUSH
97415: EMPTY
97416: LIST
97417: LIST
97418: LIST
97419: LIST
97420: PUSH
97421: EMPTY
97422: LIST
97423: LIST
97424: PPUSH
97425: CALL_OW 72
97429: ST_TO_ADDR
// if not cargo then
97430: LD_VAR 0 8
97434: NOT
97435: IFFALSE 98141
// begin if mc_crates_collector [ i ] < 5 then
97437: LD_EXP 192
97441: PUSH
97442: LD_VAR 0 2
97446: ARRAY
97447: PUSH
97448: LD_INT 5
97450: LESS
97451: IFFALSE 97817
// begin if mc_ape [ i ] then
97453: LD_EXP 204
97457: PUSH
97458: LD_VAR 0 2
97462: ARRAY
97463: IFFALSE 97510
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
97465: LD_ADDR_VAR 0 5
97469: PUSH
97470: LD_EXP 204
97474: PUSH
97475: LD_VAR 0 2
97479: ARRAY
97480: PPUSH
97481: LD_INT 25
97483: PUSH
97484: LD_INT 16
97486: PUSH
97487: EMPTY
97488: LIST
97489: LIST
97490: PUSH
97491: LD_INT 24
97493: PUSH
97494: LD_INT 750
97496: PUSH
97497: EMPTY
97498: LIST
97499: LIST
97500: PUSH
97501: EMPTY
97502: LIST
97503: LIST
97504: PPUSH
97505: CALL_OW 72
97509: ST_TO_ADDR
// if not tmp then
97510: LD_VAR 0 5
97514: NOT
97515: IFFALSE 97562
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
97517: LD_ADDR_VAR 0 5
97521: PUSH
97522: LD_EXP 175
97526: PUSH
97527: LD_VAR 0 2
97531: ARRAY
97532: PPUSH
97533: LD_INT 25
97535: PUSH
97536: LD_INT 2
97538: PUSH
97539: EMPTY
97540: LIST
97541: LIST
97542: PUSH
97543: LD_INT 24
97545: PUSH
97546: LD_INT 750
97548: PUSH
97549: EMPTY
97550: LIST
97551: LIST
97552: PUSH
97553: EMPTY
97554: LIST
97555: LIST
97556: PPUSH
97557: CALL_OW 72
97561: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
97562: LD_EXP 204
97566: PUSH
97567: LD_VAR 0 2
97571: ARRAY
97572: PUSH
97573: LD_EXP 175
97577: PUSH
97578: LD_VAR 0 2
97582: ARRAY
97583: PPUSH
97584: LD_INT 25
97586: PUSH
97587: LD_INT 2
97589: PUSH
97590: EMPTY
97591: LIST
97592: LIST
97593: PUSH
97594: LD_INT 24
97596: PUSH
97597: LD_INT 750
97599: PUSH
97600: EMPTY
97601: LIST
97602: LIST
97603: PUSH
97604: EMPTY
97605: LIST
97606: LIST
97607: PPUSH
97608: CALL_OW 72
97612: AND
97613: PUSH
97614: LD_VAR 0 5
97618: PUSH
97619: LD_INT 5
97621: LESS
97622: AND
97623: IFFALSE 97705
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
97625: LD_ADDR_VAR 0 3
97629: PUSH
97630: LD_EXP 175
97634: PUSH
97635: LD_VAR 0 2
97639: ARRAY
97640: PPUSH
97641: LD_INT 25
97643: PUSH
97644: LD_INT 2
97646: PUSH
97647: EMPTY
97648: LIST
97649: LIST
97650: PUSH
97651: LD_INT 24
97653: PUSH
97654: LD_INT 750
97656: PUSH
97657: EMPTY
97658: LIST
97659: LIST
97660: PUSH
97661: EMPTY
97662: LIST
97663: LIST
97664: PPUSH
97665: CALL_OW 72
97669: PUSH
97670: FOR_IN
97671: IFFALSE 97703
// begin tmp := tmp union j ;
97673: LD_ADDR_VAR 0 5
97677: PUSH
97678: LD_VAR 0 5
97682: PUSH
97683: LD_VAR 0 3
97687: UNION
97688: ST_TO_ADDR
// if tmp >= 5 then
97689: LD_VAR 0 5
97693: PUSH
97694: LD_INT 5
97696: GREATEREQUAL
97697: IFFALSE 97701
// break ;
97699: GO 97703
// end ;
97701: GO 97670
97703: POP
97704: POP
// end ; if not tmp then
97705: LD_VAR 0 5
97709: NOT
97710: IFFALSE 97714
// continue ;
97712: GO 96867
// for j in tmp do
97714: LD_ADDR_VAR 0 3
97718: PUSH
97719: LD_VAR 0 5
97723: PUSH
97724: FOR_IN
97725: IFFALSE 97815
// if not GetTag ( j ) then
97727: LD_VAR 0 3
97731: PPUSH
97732: CALL_OW 110
97736: NOT
97737: IFFALSE 97813
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
97739: LD_ADDR_EXP 192
97743: PUSH
97744: LD_EXP 192
97748: PPUSH
97749: LD_VAR 0 2
97753: PUSH
97754: LD_EXP 192
97758: PUSH
97759: LD_VAR 0 2
97763: ARRAY
97764: PUSH
97765: LD_INT 1
97767: PLUS
97768: PUSH
97769: EMPTY
97770: LIST
97771: LIST
97772: PPUSH
97773: LD_VAR 0 3
97777: PPUSH
97778: CALL 24210 0 3
97782: ST_TO_ADDR
// SetTag ( j , 107 ) ;
97783: LD_VAR 0 3
97787: PPUSH
97788: LD_INT 107
97790: PPUSH
97791: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
97795: LD_EXP 192
97799: PUSH
97800: LD_VAR 0 2
97804: ARRAY
97805: PUSH
97806: LD_INT 5
97808: GREATEREQUAL
97809: IFFALSE 97813
// break ;
97811: GO 97815
// end ;
97813: GO 97724
97815: POP
97816: POP
// end ; if mc_crates_collector [ i ] and target then
97817: LD_EXP 192
97821: PUSH
97822: LD_VAR 0 2
97826: ARRAY
97827: PUSH
97828: LD_VAR 0 7
97832: AND
97833: IFFALSE 98139
// begin if mc_crates_collector [ i ] < target [ 1 ] then
97835: LD_EXP 192
97839: PUSH
97840: LD_VAR 0 2
97844: ARRAY
97845: PUSH
97846: LD_VAR 0 7
97850: PUSH
97851: LD_INT 1
97853: ARRAY
97854: LESS
97855: IFFALSE 97875
// tmp := mc_crates_collector [ i ] else
97857: LD_ADDR_VAR 0 5
97861: PUSH
97862: LD_EXP 192
97866: PUSH
97867: LD_VAR 0 2
97871: ARRAY
97872: ST_TO_ADDR
97873: GO 97889
// tmp := target [ 1 ] ;
97875: LD_ADDR_VAR 0 5
97879: PUSH
97880: LD_VAR 0 7
97884: PUSH
97885: LD_INT 1
97887: ARRAY
97888: ST_TO_ADDR
// k := 0 ;
97889: LD_ADDR_VAR 0 4
97893: PUSH
97894: LD_INT 0
97896: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
97897: LD_ADDR_VAR 0 3
97901: PUSH
97902: LD_EXP 192
97906: PUSH
97907: LD_VAR 0 2
97911: ARRAY
97912: PUSH
97913: FOR_IN
97914: IFFALSE 98137
// begin k := k + 1 ;
97916: LD_ADDR_VAR 0 4
97920: PUSH
97921: LD_VAR 0 4
97925: PUSH
97926: LD_INT 1
97928: PLUS
97929: ST_TO_ADDR
// if k > tmp then
97930: LD_VAR 0 4
97934: PUSH
97935: LD_VAR 0 5
97939: GREATER
97940: IFFALSE 97944
// break ;
97942: GO 98137
// if not GetClass ( j ) in [ 2 , 16 ] then
97944: LD_VAR 0 3
97948: PPUSH
97949: CALL_OW 257
97953: PUSH
97954: LD_INT 2
97956: PUSH
97957: LD_INT 16
97959: PUSH
97960: EMPTY
97961: LIST
97962: LIST
97963: IN
97964: NOT
97965: IFFALSE 98018
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
97967: LD_ADDR_EXP 192
97971: PUSH
97972: LD_EXP 192
97976: PPUSH
97977: LD_VAR 0 2
97981: PPUSH
97982: LD_EXP 192
97986: PUSH
97987: LD_VAR 0 2
97991: ARRAY
97992: PUSH
97993: LD_VAR 0 3
97997: DIFF
97998: PPUSH
97999: CALL_OW 1
98003: ST_TO_ADDR
// SetTag ( j , 0 ) ;
98004: LD_VAR 0 3
98008: PPUSH
98009: LD_INT 0
98011: PPUSH
98012: CALL_OW 109
// continue ;
98016: GO 97913
// end ; if IsInUnit ( j ) then
98018: LD_VAR 0 3
98022: PPUSH
98023: CALL_OW 310
98027: IFFALSE 98038
// ComExitBuilding ( j ) ;
98029: LD_VAR 0 3
98033: PPUSH
98034: CALL_OW 122
// wait ( 3 ) ;
98038: LD_INT 3
98040: PPUSH
98041: CALL_OW 67
// if HasTask ( j ) and DangerAtRangeXY ( side , target [ 2 ] , target [ 3 ] , 30 ) [ 4 ] then
98045: LD_VAR 0 3
98049: PPUSH
98050: CALL_OW 314
98054: PUSH
98055: LD_VAR 0 6
98059: PPUSH
98060: LD_VAR 0 7
98064: PUSH
98065: LD_INT 2
98067: ARRAY
98068: PPUSH
98069: LD_VAR 0 7
98073: PUSH
98074: LD_INT 3
98076: ARRAY
98077: PPUSH
98078: LD_INT 30
98080: PPUSH
98081: CALL 25106 0 4
98085: PUSH
98086: LD_INT 4
98088: ARRAY
98089: AND
98090: IFFALSE 98108
// ComStandNearbyBuilding ( j , depot ) else
98092: LD_VAR 0 3
98096: PPUSH
98097: LD_VAR 0 9
98101: PPUSH
98102: CALL 20788 0 2
98106: GO 98135
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
98108: LD_VAR 0 3
98112: PPUSH
98113: LD_VAR 0 7
98117: PUSH
98118: LD_INT 2
98120: ARRAY
98121: PPUSH
98122: LD_VAR 0 7
98126: PUSH
98127: LD_INT 3
98129: ARRAY
98130: PPUSH
98131: CALL_OW 117
// end ;
98135: GO 97913
98137: POP
98138: POP
// end ; end else
98139: GO 98671
// begin for j in cargo do
98141: LD_ADDR_VAR 0 3
98145: PUSH
98146: LD_VAR 0 8
98150: PUSH
98151: FOR_IN
98152: IFFALSE 98669
// begin if GetTag ( j ) <> 0 then
98154: LD_VAR 0 3
98158: PPUSH
98159: CALL_OW 110
98163: PUSH
98164: LD_INT 0
98166: NONEQUAL
98167: IFFALSE 98171
// continue ;
98169: GO 98151
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
98171: LD_VAR 0 3
98175: PPUSH
98176: CALL_OW 256
98180: PUSH
98181: LD_INT 1000
98183: LESS
98184: PUSH
98185: LD_VAR 0 3
98189: PPUSH
98190: LD_EXP 199
98194: PUSH
98195: LD_VAR 0 2
98199: ARRAY
98200: PPUSH
98201: CALL_OW 308
98205: NOT
98206: AND
98207: IFFALSE 98229
// ComMoveToArea ( j , mc_parking [ i ] ) ;
98209: LD_VAR 0 3
98213: PPUSH
98214: LD_EXP 199
98218: PUSH
98219: LD_VAR 0 2
98223: ARRAY
98224: PPUSH
98225: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
98229: LD_VAR 0 3
98233: PPUSH
98234: CALL_OW 256
98238: PUSH
98239: LD_INT 1000
98241: LESS
98242: PUSH
98243: LD_VAR 0 3
98247: PPUSH
98248: LD_EXP 199
98252: PUSH
98253: LD_VAR 0 2
98257: ARRAY
98258: PPUSH
98259: CALL_OW 308
98263: AND
98264: IFFALSE 98268
// continue ;
98266: GO 98151
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
98268: LD_VAR 0 3
98272: PPUSH
98273: CALL_OW 262
98277: PUSH
98278: LD_INT 2
98280: EQUAL
98281: PUSH
98282: LD_VAR 0 3
98286: PPUSH
98287: CALL_OW 261
98291: PUSH
98292: LD_INT 15
98294: LESS
98295: AND
98296: IFFALSE 98300
// continue ;
98298: GO 98151
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
98300: LD_VAR 0 3
98304: PPUSH
98305: CALL_OW 262
98309: PUSH
98310: LD_INT 1
98312: EQUAL
98313: PUSH
98314: LD_VAR 0 3
98318: PPUSH
98319: CALL_OW 261
98323: PUSH
98324: LD_INT 10
98326: LESS
98327: AND
98328: IFFALSE 98608
// begin if not depot then
98330: LD_VAR 0 9
98334: NOT
98335: IFFALSE 98339
// continue ;
98337: GO 98151
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
98339: LD_VAR 0 3
98343: PPUSH
98344: LD_VAR 0 9
98348: PPUSH
98349: LD_VAR 0 3
98353: PPUSH
98354: CALL_OW 74
98358: PPUSH
98359: CALL_OW 296
98363: PUSH
98364: LD_INT 6
98366: LESS
98367: IFFALSE 98383
// SetFuel ( j , 100 ) else
98369: LD_VAR 0 3
98373: PPUSH
98374: LD_INT 100
98376: PPUSH
98377: CALL_OW 240
98381: GO 98608
// if GetFuel ( j ) = 0 then
98383: LD_VAR 0 3
98387: PPUSH
98388: CALL_OW 261
98392: PUSH
98393: LD_INT 0
98395: EQUAL
98396: IFFALSE 98608
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
98398: LD_ADDR_EXP 194
98402: PUSH
98403: LD_EXP 194
98407: PPUSH
98408: LD_VAR 0 2
98412: PPUSH
98413: LD_EXP 194
98417: PUSH
98418: LD_VAR 0 2
98422: ARRAY
98423: PUSH
98424: LD_VAR 0 3
98428: DIFF
98429: PPUSH
98430: CALL_OW 1
98434: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
98435: LD_VAR 0 3
98439: PPUSH
98440: CALL_OW 263
98444: PUSH
98445: LD_INT 1
98447: EQUAL
98448: IFFALSE 98464
// ComExitVehicle ( IsInUnit ( j ) ) ;
98450: LD_VAR 0 3
98454: PPUSH
98455: CALL_OW 310
98459: PPUSH
98460: CALL_OW 121
// if GetControl ( j ) = control_remote then
98464: LD_VAR 0 3
98468: PPUSH
98469: CALL_OW 263
98473: PUSH
98474: LD_INT 2
98476: EQUAL
98477: IFFALSE 98488
// ComUnlink ( j ) ;
98479: LD_VAR 0 3
98483: PPUSH
98484: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
98488: LD_ADDR_VAR 0 10
98492: PUSH
98493: LD_VAR 0 2
98497: PPUSH
98498: LD_INT 3
98500: PPUSH
98501: CALL 108100 0 2
98505: ST_TO_ADDR
// if fac then
98506: LD_VAR 0 10
98510: IFFALSE 98606
// begin for k in fac do
98512: LD_ADDR_VAR 0 4
98516: PUSH
98517: LD_VAR 0 10
98521: PUSH
98522: FOR_IN
98523: IFFALSE 98604
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
98525: LD_ADDR_VAR 0 11
98529: PUSH
98530: LD_VAR 0 10
98534: PPUSH
98535: LD_VAR 0 3
98539: PPUSH
98540: CALL_OW 265
98544: PPUSH
98545: LD_VAR 0 3
98549: PPUSH
98550: CALL_OW 262
98554: PPUSH
98555: LD_VAR 0 3
98559: PPUSH
98560: CALL_OW 263
98564: PPUSH
98565: LD_VAR 0 3
98569: PPUSH
98570: CALL_OW 264
98574: PPUSH
98575: CALL 21706 0 5
98579: ST_TO_ADDR
// if components then
98580: LD_VAR 0 11
98584: IFFALSE 98602
// begin MC_InsertProduceList ( i , components ) ;
98586: LD_VAR 0 2
98590: PPUSH
98591: LD_VAR 0 11
98595: PPUSH
98596: CALL 107645 0 2
// break ;
98600: GO 98604
// end ; end ;
98602: GO 98522
98604: POP
98605: POP
// end ; continue ;
98606: GO 98151
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
98608: LD_VAR 0 3
98612: PPUSH
98613: LD_INT 1
98615: PPUSH
98616: CALL_OW 289
98620: PUSH
98621: LD_INT 100
98623: LESS
98624: PUSH
98625: LD_VAR 0 3
98629: PPUSH
98630: CALL_OW 314
98634: NOT
98635: AND
98636: IFFALSE 98665
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
98638: LD_VAR 0 3
98642: PPUSH
98643: LD_VAR 0 7
98647: PUSH
98648: LD_INT 2
98650: ARRAY
98651: PPUSH
98652: LD_VAR 0 7
98656: PUSH
98657: LD_INT 3
98659: ARRAY
98660: PPUSH
98661: CALL_OW 117
// break ;
98665: GO 98669
// end ;
98667: GO 98151
98669: POP
98670: POP
// end ; end ;
98671: GO 96867
98673: POP
98674: POP
// end ;
98675: LD_VAR 0 1
98679: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
98680: LD_INT 0
98682: PPUSH
98683: PPUSH
98684: PPUSH
98685: PPUSH
// if not mc_bases then
98686: LD_EXP 175
98690: NOT
98691: IFFALSE 98695
// exit ;
98693: GO 98856
// for i = 1 to mc_bases do
98695: LD_ADDR_VAR 0 2
98699: PUSH
98700: DOUBLE
98701: LD_INT 1
98703: DEC
98704: ST_TO_ADDR
98705: LD_EXP 175
98709: PUSH
98710: FOR_TO
98711: IFFALSE 98854
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
98713: LD_ADDR_VAR 0 4
98717: PUSH
98718: LD_EXP 194
98722: PUSH
98723: LD_VAR 0 2
98727: ARRAY
98728: PUSH
98729: LD_EXP 197
98733: PUSH
98734: LD_VAR 0 2
98738: ARRAY
98739: UNION
98740: PPUSH
98741: LD_INT 33
98743: PUSH
98744: LD_INT 2
98746: PUSH
98747: EMPTY
98748: LIST
98749: LIST
98750: PPUSH
98751: CALL_OW 72
98755: ST_TO_ADDR
// if tmp then
98756: LD_VAR 0 4
98760: IFFALSE 98852
// for j in tmp do
98762: LD_ADDR_VAR 0 3
98766: PUSH
98767: LD_VAR 0 4
98771: PUSH
98772: FOR_IN
98773: IFFALSE 98850
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
98775: LD_VAR 0 3
98779: PPUSH
98780: CALL_OW 312
98784: NOT
98785: PUSH
98786: LD_VAR 0 3
98790: PPUSH
98791: CALL_OW 256
98795: PUSH
98796: LD_INT 250
98798: GREATEREQUAL
98799: AND
98800: IFFALSE 98813
// Connect ( j ) else
98802: LD_VAR 0 3
98806: PPUSH
98807: CALL 27181 0 1
98811: GO 98848
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
98813: LD_VAR 0 3
98817: PPUSH
98818: CALL_OW 256
98822: PUSH
98823: LD_INT 250
98825: LESS
98826: PUSH
98827: LD_VAR 0 3
98831: PPUSH
98832: CALL_OW 312
98836: AND
98837: IFFALSE 98848
// ComUnlink ( j ) ;
98839: LD_VAR 0 3
98843: PPUSH
98844: CALL_OW 136
98848: GO 98772
98850: POP
98851: POP
// end ;
98852: GO 98710
98854: POP
98855: POP
// end ;
98856: LD_VAR 0 1
98860: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
98861: LD_INT 0
98863: PPUSH
98864: PPUSH
98865: PPUSH
98866: PPUSH
98867: PPUSH
// if not mc_bases then
98868: LD_EXP 175
98872: NOT
98873: IFFALSE 98877
// exit ;
98875: GO 99322
// for i = 1 to mc_bases do
98877: LD_ADDR_VAR 0 2
98881: PUSH
98882: DOUBLE
98883: LD_INT 1
98885: DEC
98886: ST_TO_ADDR
98887: LD_EXP 175
98891: PUSH
98892: FOR_TO
98893: IFFALSE 99320
// begin if not mc_produce [ i ] then
98895: LD_EXP 196
98899: PUSH
98900: LD_VAR 0 2
98904: ARRAY
98905: NOT
98906: IFFALSE 98910
// continue ;
98908: GO 98892
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
98910: LD_ADDR_VAR 0 5
98914: PUSH
98915: LD_EXP 175
98919: PUSH
98920: LD_VAR 0 2
98924: ARRAY
98925: PPUSH
98926: LD_INT 30
98928: PUSH
98929: LD_INT 3
98931: PUSH
98932: EMPTY
98933: LIST
98934: LIST
98935: PPUSH
98936: CALL_OW 72
98940: ST_TO_ADDR
// if not fac then
98941: LD_VAR 0 5
98945: NOT
98946: IFFALSE 98950
// continue ;
98948: GO 98892
// for j in fac do
98950: LD_ADDR_VAR 0 3
98954: PUSH
98955: LD_VAR 0 5
98959: PUSH
98960: FOR_IN
98961: IFFALSE 99316
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
98963: LD_VAR 0 3
98967: PPUSH
98968: CALL_OW 461
98972: PUSH
98973: LD_INT 2
98975: NONEQUAL
98976: PUSH
98977: LD_VAR 0 3
98981: PPUSH
98982: LD_INT 15
98984: PPUSH
98985: CALL 26809 0 2
98989: PUSH
98990: LD_INT 4
98992: ARRAY
98993: OR
98994: IFFALSE 98998
// continue ;
98996: GO 98960
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
98998: LD_VAR 0 3
99002: PPUSH
99003: LD_EXP 196
99007: PUSH
99008: LD_VAR 0 2
99012: ARRAY
99013: PUSH
99014: LD_INT 1
99016: ARRAY
99017: PUSH
99018: LD_INT 1
99020: ARRAY
99021: PPUSH
99022: LD_EXP 196
99026: PUSH
99027: LD_VAR 0 2
99031: ARRAY
99032: PUSH
99033: LD_INT 1
99035: ARRAY
99036: PUSH
99037: LD_INT 2
99039: ARRAY
99040: PPUSH
99041: LD_EXP 196
99045: PUSH
99046: LD_VAR 0 2
99050: ARRAY
99051: PUSH
99052: LD_INT 1
99054: ARRAY
99055: PUSH
99056: LD_INT 3
99058: ARRAY
99059: PPUSH
99060: LD_EXP 196
99064: PUSH
99065: LD_VAR 0 2
99069: ARRAY
99070: PUSH
99071: LD_INT 1
99073: ARRAY
99074: PUSH
99075: LD_INT 4
99077: ARRAY
99078: PPUSH
99079: CALL_OW 448
99083: PUSH
99084: LD_VAR 0 3
99088: PPUSH
99089: LD_EXP 196
99093: PUSH
99094: LD_VAR 0 2
99098: ARRAY
99099: PUSH
99100: LD_INT 1
99102: ARRAY
99103: PUSH
99104: LD_INT 1
99106: ARRAY
99107: PUSH
99108: LD_EXP 196
99112: PUSH
99113: LD_VAR 0 2
99117: ARRAY
99118: PUSH
99119: LD_INT 1
99121: ARRAY
99122: PUSH
99123: LD_INT 2
99125: ARRAY
99126: PUSH
99127: LD_EXP 196
99131: PUSH
99132: LD_VAR 0 2
99136: ARRAY
99137: PUSH
99138: LD_INT 1
99140: ARRAY
99141: PUSH
99142: LD_INT 3
99144: ARRAY
99145: PUSH
99146: LD_EXP 196
99150: PUSH
99151: LD_VAR 0 2
99155: ARRAY
99156: PUSH
99157: LD_INT 1
99159: ARRAY
99160: PUSH
99161: LD_INT 4
99163: ARRAY
99164: PUSH
99165: EMPTY
99166: LIST
99167: LIST
99168: LIST
99169: LIST
99170: PPUSH
99171: CALL 30576 0 2
99175: AND
99176: IFFALSE 99314
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
99178: LD_VAR 0 3
99182: PPUSH
99183: LD_EXP 196
99187: PUSH
99188: LD_VAR 0 2
99192: ARRAY
99193: PUSH
99194: LD_INT 1
99196: ARRAY
99197: PUSH
99198: LD_INT 1
99200: ARRAY
99201: PPUSH
99202: LD_EXP 196
99206: PUSH
99207: LD_VAR 0 2
99211: ARRAY
99212: PUSH
99213: LD_INT 1
99215: ARRAY
99216: PUSH
99217: LD_INT 2
99219: ARRAY
99220: PPUSH
99221: LD_EXP 196
99225: PUSH
99226: LD_VAR 0 2
99230: ARRAY
99231: PUSH
99232: LD_INT 1
99234: ARRAY
99235: PUSH
99236: LD_INT 3
99238: ARRAY
99239: PPUSH
99240: LD_EXP 196
99244: PUSH
99245: LD_VAR 0 2
99249: ARRAY
99250: PUSH
99251: LD_INT 1
99253: ARRAY
99254: PUSH
99255: LD_INT 4
99257: ARRAY
99258: PPUSH
99259: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
99263: LD_ADDR_VAR 0 4
99267: PUSH
99268: LD_EXP 196
99272: PUSH
99273: LD_VAR 0 2
99277: ARRAY
99278: PPUSH
99279: LD_INT 1
99281: PPUSH
99282: CALL_OW 3
99286: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
99287: LD_ADDR_EXP 196
99291: PUSH
99292: LD_EXP 196
99296: PPUSH
99297: LD_VAR 0 2
99301: PPUSH
99302: LD_VAR 0 4
99306: PPUSH
99307: CALL_OW 1
99311: ST_TO_ADDR
// break ;
99312: GO 99316
// end ; end ;
99314: GO 98960
99316: POP
99317: POP
// end ;
99318: GO 98892
99320: POP
99321: POP
// end ;
99322: LD_VAR 0 1
99326: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
99327: LD_INT 0
99329: PPUSH
99330: PPUSH
99331: PPUSH
// if not mc_bases then
99332: LD_EXP 175
99336: NOT
99337: IFFALSE 99341
// exit ;
99339: GO 99430
// for i = 1 to mc_bases do
99341: LD_ADDR_VAR 0 2
99345: PUSH
99346: DOUBLE
99347: LD_INT 1
99349: DEC
99350: ST_TO_ADDR
99351: LD_EXP 175
99355: PUSH
99356: FOR_TO
99357: IFFALSE 99428
// begin if mc_attack [ i ] then
99359: LD_EXP 195
99363: PUSH
99364: LD_VAR 0 2
99368: ARRAY
99369: IFFALSE 99426
// begin tmp := mc_attack [ i ] [ 1 ] ;
99371: LD_ADDR_VAR 0 3
99375: PUSH
99376: LD_EXP 195
99380: PUSH
99381: LD_VAR 0 2
99385: ARRAY
99386: PUSH
99387: LD_INT 1
99389: ARRAY
99390: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
99391: LD_ADDR_EXP 195
99395: PUSH
99396: LD_EXP 195
99400: PPUSH
99401: LD_VAR 0 2
99405: PPUSH
99406: EMPTY
99407: PPUSH
99408: CALL_OW 1
99412: ST_TO_ADDR
// Attack ( tmp ) ;
99413: LD_VAR 0 3
99417: PPUSH
99418: CALL 76297 0 1
// exit ;
99422: POP
99423: POP
99424: GO 99430
// end ; end ;
99426: GO 99356
99428: POP
99429: POP
// end ;
99430: LD_VAR 0 1
99434: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
99435: LD_INT 0
99437: PPUSH
99438: PPUSH
99439: PPUSH
99440: PPUSH
99441: PPUSH
99442: PPUSH
99443: PPUSH
// if not mc_bases then
99444: LD_EXP 175
99448: NOT
99449: IFFALSE 99453
// exit ;
99451: GO 100163
// for i = 1 to mc_bases do
99453: LD_ADDR_VAR 0 2
99457: PUSH
99458: DOUBLE
99459: LD_INT 1
99461: DEC
99462: ST_TO_ADDR
99463: LD_EXP 175
99467: PUSH
99468: FOR_TO
99469: IFFALSE 100161
// begin if not mc_bases [ i ] then
99471: LD_EXP 175
99475: PUSH
99476: LD_VAR 0 2
99480: ARRAY
99481: NOT
99482: IFFALSE 99486
// continue ;
99484: GO 99468
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
99486: LD_ADDR_VAR 0 7
99490: PUSH
99491: LD_EXP 175
99495: PUSH
99496: LD_VAR 0 2
99500: ARRAY
99501: PUSH
99502: LD_INT 1
99504: ARRAY
99505: PPUSH
99506: CALL 21010 0 1
99510: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
99511: LD_ADDR_EXP 198
99515: PUSH
99516: LD_EXP 198
99520: PPUSH
99521: LD_VAR 0 2
99525: PPUSH
99526: LD_EXP 175
99530: PUSH
99531: LD_VAR 0 2
99535: ARRAY
99536: PUSH
99537: LD_INT 1
99539: ARRAY
99540: PPUSH
99541: CALL_OW 255
99545: PPUSH
99546: LD_EXP 200
99550: PUSH
99551: LD_VAR 0 2
99555: ARRAY
99556: PPUSH
99557: CALL 20975 0 2
99561: PPUSH
99562: CALL_OW 1
99566: ST_TO_ADDR
// if not mc_scan [ i ] then
99567: LD_EXP 198
99571: PUSH
99572: LD_VAR 0 2
99576: ARRAY
99577: NOT
99578: IFFALSE 99756
// begin mc_is_defending := Replace ( mc_is_defending , i , false ) ;
99580: LD_ADDR_EXP 218
99584: PUSH
99585: LD_EXP 218
99589: PPUSH
99590: LD_VAR 0 2
99594: PPUSH
99595: LD_INT 0
99597: PPUSH
99598: CALL_OW 1
99602: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
99603: LD_ADDR_VAR 0 4
99607: PUSH
99608: LD_EXP 175
99612: PUSH
99613: LD_VAR 0 2
99617: ARRAY
99618: PPUSH
99619: LD_INT 2
99621: PUSH
99622: LD_INT 25
99624: PUSH
99625: LD_INT 5
99627: PUSH
99628: EMPTY
99629: LIST
99630: LIST
99631: PUSH
99632: LD_INT 25
99634: PUSH
99635: LD_INT 8
99637: PUSH
99638: EMPTY
99639: LIST
99640: LIST
99641: PUSH
99642: LD_INT 25
99644: PUSH
99645: LD_INT 9
99647: PUSH
99648: EMPTY
99649: LIST
99650: LIST
99651: PUSH
99652: EMPTY
99653: LIST
99654: LIST
99655: LIST
99656: LIST
99657: PPUSH
99658: CALL_OW 72
99662: ST_TO_ADDR
// if not tmp then
99663: LD_VAR 0 4
99667: NOT
99668: IFFALSE 99672
// continue ;
99670: GO 99468
// for j in tmp do
99672: LD_ADDR_VAR 0 3
99676: PUSH
99677: LD_VAR 0 4
99681: PUSH
99682: FOR_IN
99683: IFFALSE 99754
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
99685: LD_VAR 0 3
99689: PPUSH
99690: CALL_OW 310
99694: PPUSH
99695: CALL_OW 266
99699: PUSH
99700: LD_INT 5
99702: EQUAL
99703: PUSH
99704: LD_VAR 0 3
99708: PPUSH
99709: CALL_OW 257
99713: PUSH
99714: LD_INT 1
99716: EQUAL
99717: AND
99718: PUSH
99719: LD_VAR 0 3
99723: PPUSH
99724: CALL_OW 459
99728: NOT
99729: AND
99730: PUSH
99731: LD_VAR 0 7
99735: AND
99736: IFFALSE 99752
// ComChangeProfession ( j , class ) ;
99738: LD_VAR 0 3
99742: PPUSH
99743: LD_VAR 0 7
99747: PPUSH
99748: CALL_OW 123
99752: GO 99682
99754: POP
99755: POP
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and not mc_defender [ i ] then
99756: LD_EXP 198
99760: PUSH
99761: LD_VAR 0 2
99765: ARRAY
99766: PUSH
99767: LD_EXP 218
99771: PUSH
99772: LD_VAR 0 2
99776: ARRAY
99777: NOT
99778: AND
99779: PUSH
99780: LD_EXP 197
99784: PUSH
99785: LD_VAR 0 2
99789: ARRAY
99790: NOT
99791: AND
99792: IFFALSE 100043
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
99794: LD_ADDR_EXP 218
99798: PUSH
99799: LD_EXP 218
99803: PPUSH
99804: LD_VAR 0 2
99808: PPUSH
99809: LD_INT 1
99811: PPUSH
99812: CALL_OW 1
99816: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
99817: LD_ADDR_VAR 0 4
99821: PUSH
99822: LD_EXP 175
99826: PUSH
99827: LD_VAR 0 2
99831: ARRAY
99832: PPUSH
99833: LD_INT 2
99835: PUSH
99836: LD_INT 25
99838: PUSH
99839: LD_INT 1
99841: PUSH
99842: EMPTY
99843: LIST
99844: LIST
99845: PUSH
99846: LD_INT 25
99848: PUSH
99849: LD_INT 5
99851: PUSH
99852: EMPTY
99853: LIST
99854: LIST
99855: PUSH
99856: LD_INT 25
99858: PUSH
99859: LD_INT 8
99861: PUSH
99862: EMPTY
99863: LIST
99864: LIST
99865: PUSH
99866: LD_INT 25
99868: PUSH
99869: LD_INT 9
99871: PUSH
99872: EMPTY
99873: LIST
99874: LIST
99875: PUSH
99876: EMPTY
99877: LIST
99878: LIST
99879: LIST
99880: LIST
99881: LIST
99882: PPUSH
99883: CALL_OW 72
99887: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
99888: LD_ADDR_VAR 0 4
99892: PUSH
99893: LD_VAR 0 4
99897: PUSH
99898: LD_VAR 0 4
99902: PPUSH
99903: LD_INT 18
99905: PPUSH
99906: CALL 53479 0 2
99910: DIFF
99911: ST_TO_ADDR
// if not tmp and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
99912: LD_VAR 0 4
99916: NOT
99917: PUSH
99918: LD_EXP 175
99922: PUSH
99923: LD_VAR 0 2
99927: ARRAY
99928: PPUSH
99929: LD_INT 2
99931: PUSH
99932: LD_INT 30
99934: PUSH
99935: LD_INT 4
99937: PUSH
99938: EMPTY
99939: LIST
99940: LIST
99941: PUSH
99942: LD_INT 30
99944: PUSH
99945: LD_INT 5
99947: PUSH
99948: EMPTY
99949: LIST
99950: LIST
99951: PUSH
99952: EMPTY
99953: LIST
99954: LIST
99955: LIST
99956: PPUSH
99957: CALL_OW 72
99961: NOT
99962: AND
99963: IFFALSE 100025
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
99965: LD_ADDR_VAR 0 4
99969: PUSH
99970: LD_EXP 175
99974: PUSH
99975: LD_VAR 0 2
99979: ARRAY
99980: PPUSH
99981: LD_INT 2
99983: PUSH
99984: LD_INT 25
99986: PUSH
99987: LD_INT 2
99989: PUSH
99990: EMPTY
99991: LIST
99992: LIST
99993: PUSH
99994: LD_INT 25
99996: PUSH
99997: LD_INT 3
99999: PUSH
100000: EMPTY
100001: LIST
100002: LIST
100003: PUSH
100004: LD_INT 25
100006: PUSH
100007: LD_INT 4
100009: PUSH
100010: EMPTY
100011: LIST
100012: LIST
100013: PUSH
100014: EMPTY
100015: LIST
100016: LIST
100017: LIST
100018: LIST
100019: PPUSH
100020: CALL_OW 72
100024: ST_TO_ADDR
// BasicDefend ( i , tmp ) ;
100025: LD_VAR 0 2
100029: PPUSH
100030: LD_VAR 0 4
100034: PPUSH
100035: CALL 81006 0 2
// exit ;
100039: POP
100040: POP
100041: GO 100163
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and mc_defender [ i ] then
100043: LD_EXP 198
100047: PUSH
100048: LD_VAR 0 2
100052: ARRAY
100053: PUSH
100054: LD_EXP 218
100058: PUSH
100059: LD_VAR 0 2
100063: ARRAY
100064: NOT
100065: AND
100066: PUSH
100067: LD_EXP 197
100071: PUSH
100072: LD_VAR 0 2
100076: ARRAY
100077: AND
100078: IFFALSE 100159
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
100080: LD_ADDR_EXP 218
100084: PUSH
100085: LD_EXP 218
100089: PPUSH
100090: LD_VAR 0 2
100094: PPUSH
100095: LD_INT 1
100097: PPUSH
100098: CALL_OW 1
100102: ST_TO_ADDR
// tmp := mc_defender [ i ] ;
100103: LD_ADDR_VAR 0 4
100107: PUSH
100108: LD_EXP 197
100112: PUSH
100113: LD_VAR 0 2
100117: ARRAY
100118: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
100119: LD_ADDR_EXP 197
100123: PUSH
100124: LD_EXP 197
100128: PPUSH
100129: LD_VAR 0 2
100133: PPUSH
100134: EMPTY
100135: PPUSH
100136: CALL_OW 1
100140: ST_TO_ADDR
// Defend ( i , tmp ) ;
100141: LD_VAR 0 2
100145: PPUSH
100146: LD_VAR 0 4
100150: PPUSH
100151: CALL 81576 0 2
// exit ;
100155: POP
100156: POP
100157: GO 100163
// end ; end ;
100159: GO 99468
100161: POP
100162: POP
// end ;
100163: LD_VAR 0 1
100167: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
100168: LD_INT 0
100170: PPUSH
100171: PPUSH
100172: PPUSH
100173: PPUSH
100174: PPUSH
100175: PPUSH
100176: PPUSH
100177: PPUSH
100178: PPUSH
100179: PPUSH
100180: PPUSH
// if not mc_bases then
100181: LD_EXP 175
100185: NOT
100186: IFFALSE 100190
// exit ;
100188: GO 101277
// for i = 1 to mc_bases do
100190: LD_ADDR_VAR 0 2
100194: PUSH
100195: DOUBLE
100196: LD_INT 1
100198: DEC
100199: ST_TO_ADDR
100200: LD_EXP 175
100204: PUSH
100205: FOR_TO
100206: IFFALSE 101275
// begin tmp := mc_lab [ i ] ;
100208: LD_ADDR_VAR 0 6
100212: PUSH
100213: LD_EXP 208
100217: PUSH
100218: LD_VAR 0 2
100222: ARRAY
100223: ST_TO_ADDR
// if not tmp then
100224: LD_VAR 0 6
100228: NOT
100229: IFFALSE 100233
// continue ;
100231: GO 100205
// idle_lab := 0 ;
100233: LD_ADDR_VAR 0 11
100237: PUSH
100238: LD_INT 0
100240: ST_TO_ADDR
// for j in tmp do
100241: LD_ADDR_VAR 0 3
100245: PUSH
100246: LD_VAR 0 6
100250: PUSH
100251: FOR_IN
100252: IFFALSE 101271
// begin researching := false ;
100254: LD_ADDR_VAR 0 10
100258: PUSH
100259: LD_INT 0
100261: ST_TO_ADDR
// side := GetSide ( j ) ;
100262: LD_ADDR_VAR 0 4
100266: PUSH
100267: LD_VAR 0 3
100271: PPUSH
100272: CALL_OW 255
100276: ST_TO_ADDR
// if not mc_tech [ side ] then
100277: LD_EXP 202
100281: PUSH
100282: LD_VAR 0 4
100286: ARRAY
100287: NOT
100288: IFFALSE 100292
// continue ;
100290: GO 100251
// if BuildingStatus ( j ) = bs_idle then
100292: LD_VAR 0 3
100296: PPUSH
100297: CALL_OW 461
100301: PUSH
100302: LD_INT 2
100304: EQUAL
100305: IFFALSE 100493
// begin if idle_lab and UnitsInside ( j ) < 6 then
100307: LD_VAR 0 11
100311: PUSH
100312: LD_VAR 0 3
100316: PPUSH
100317: CALL_OW 313
100321: PUSH
100322: LD_INT 6
100324: LESS
100325: AND
100326: IFFALSE 100397
// begin tmp2 := UnitsInside ( idle_lab ) ;
100328: LD_ADDR_VAR 0 9
100332: PUSH
100333: LD_VAR 0 11
100337: PPUSH
100338: CALL_OW 313
100342: ST_TO_ADDR
// if tmp2 then
100343: LD_VAR 0 9
100347: IFFALSE 100389
// for x in tmp2 do
100349: LD_ADDR_VAR 0 7
100353: PUSH
100354: LD_VAR 0 9
100358: PUSH
100359: FOR_IN
100360: IFFALSE 100387
// begin ComExitBuilding ( x ) ;
100362: LD_VAR 0 7
100366: PPUSH
100367: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
100371: LD_VAR 0 7
100375: PPUSH
100376: LD_VAR 0 3
100380: PPUSH
100381: CALL_OW 180
// end ;
100385: GO 100359
100387: POP
100388: POP
// idle_lab := 0 ;
100389: LD_ADDR_VAR 0 11
100393: PUSH
100394: LD_INT 0
100396: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
100397: LD_ADDR_VAR 0 5
100401: PUSH
100402: LD_EXP 202
100406: PUSH
100407: LD_VAR 0 4
100411: ARRAY
100412: PUSH
100413: FOR_IN
100414: IFFALSE 100474
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
100416: LD_VAR 0 3
100420: PPUSH
100421: LD_VAR 0 5
100425: PPUSH
100426: CALL_OW 430
100430: PUSH
100431: LD_VAR 0 4
100435: PPUSH
100436: LD_VAR 0 5
100440: PPUSH
100441: CALL 20080 0 2
100445: AND
100446: IFFALSE 100472
// begin researching := true ;
100448: LD_ADDR_VAR 0 10
100452: PUSH
100453: LD_INT 1
100455: ST_TO_ADDR
// ComResearch ( j , t ) ;
100456: LD_VAR 0 3
100460: PPUSH
100461: LD_VAR 0 5
100465: PPUSH
100466: CALL_OW 124
// break ;
100470: GO 100474
// end ;
100472: GO 100413
100474: POP
100475: POP
// if not researching then
100476: LD_VAR 0 10
100480: NOT
100481: IFFALSE 100493
// idle_lab := j ;
100483: LD_ADDR_VAR 0 11
100487: PUSH
100488: LD_VAR 0 3
100492: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
100493: LD_VAR 0 3
100497: PPUSH
100498: CALL_OW 461
100502: PUSH
100503: LD_INT 10
100505: EQUAL
100506: IFFALSE 101094
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
100508: LD_EXP 204
100512: PUSH
100513: LD_VAR 0 2
100517: ARRAY
100518: NOT
100519: PUSH
100520: LD_EXP 205
100524: PUSH
100525: LD_VAR 0 2
100529: ARRAY
100530: NOT
100531: AND
100532: PUSH
100533: LD_EXP 202
100537: PUSH
100538: LD_VAR 0 4
100542: ARRAY
100543: PUSH
100544: LD_INT 1
100546: GREATER
100547: AND
100548: IFFALSE 100679
// begin ComCancel ( j ) ;
100550: LD_VAR 0 3
100554: PPUSH
100555: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
100559: LD_ADDR_EXP 202
100563: PUSH
100564: LD_EXP 202
100568: PPUSH
100569: LD_VAR 0 4
100573: PPUSH
100574: LD_EXP 202
100578: PUSH
100579: LD_VAR 0 4
100583: ARRAY
100584: PPUSH
100585: LD_EXP 202
100589: PUSH
100590: LD_VAR 0 4
100594: ARRAY
100595: PUSH
100596: LD_INT 1
100598: MINUS
100599: PPUSH
100600: LD_EXP 202
100604: PUSH
100605: LD_VAR 0 4
100609: ARRAY
100610: PPUSH
100611: LD_INT 0
100613: PPUSH
100614: CALL 23628 0 4
100618: PPUSH
100619: CALL_OW 1
100623: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
100624: LD_ADDR_EXP 202
100628: PUSH
100629: LD_EXP 202
100633: PPUSH
100634: LD_VAR 0 4
100638: PPUSH
100639: LD_EXP 202
100643: PUSH
100644: LD_VAR 0 4
100648: ARRAY
100649: PPUSH
100650: LD_EXP 202
100654: PUSH
100655: LD_VAR 0 4
100659: ARRAY
100660: PPUSH
100661: LD_INT 1
100663: PPUSH
100664: LD_INT 0
100666: PPUSH
100667: CALL 23628 0 4
100671: PPUSH
100672: CALL_OW 1
100676: ST_TO_ADDR
// continue ;
100677: GO 100251
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
100679: LD_EXP 204
100683: PUSH
100684: LD_VAR 0 2
100688: ARRAY
100689: PUSH
100690: LD_EXP 205
100694: PUSH
100695: LD_VAR 0 2
100699: ARRAY
100700: NOT
100701: AND
100702: IFFALSE 100829
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
100704: LD_ADDR_EXP 205
100708: PUSH
100709: LD_EXP 205
100713: PPUSH
100714: LD_VAR 0 2
100718: PUSH
100719: LD_EXP 205
100723: PUSH
100724: LD_VAR 0 2
100728: ARRAY
100729: PUSH
100730: LD_INT 1
100732: PLUS
100733: PUSH
100734: EMPTY
100735: LIST
100736: LIST
100737: PPUSH
100738: LD_EXP 204
100742: PUSH
100743: LD_VAR 0 2
100747: ARRAY
100748: PUSH
100749: LD_INT 1
100751: ARRAY
100752: PPUSH
100753: CALL 24210 0 3
100757: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
100758: LD_EXP 204
100762: PUSH
100763: LD_VAR 0 2
100767: ARRAY
100768: PUSH
100769: LD_INT 1
100771: ARRAY
100772: PPUSH
100773: LD_INT 112
100775: PPUSH
100776: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
100780: LD_ADDR_VAR 0 9
100784: PUSH
100785: LD_EXP 204
100789: PUSH
100790: LD_VAR 0 2
100794: ARRAY
100795: PPUSH
100796: LD_INT 1
100798: PPUSH
100799: CALL_OW 3
100803: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
100804: LD_ADDR_EXP 204
100808: PUSH
100809: LD_EXP 204
100813: PPUSH
100814: LD_VAR 0 2
100818: PPUSH
100819: LD_VAR 0 9
100823: PPUSH
100824: CALL_OW 1
100828: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
100829: LD_EXP 204
100833: PUSH
100834: LD_VAR 0 2
100838: ARRAY
100839: PUSH
100840: LD_EXP 205
100844: PUSH
100845: LD_VAR 0 2
100849: ARRAY
100850: AND
100851: PUSH
100852: LD_EXP 205
100856: PUSH
100857: LD_VAR 0 2
100861: ARRAY
100862: PUSH
100863: LD_INT 1
100865: ARRAY
100866: PPUSH
100867: CALL_OW 310
100871: NOT
100872: AND
100873: PUSH
100874: LD_VAR 0 3
100878: PPUSH
100879: CALL_OW 313
100883: PUSH
100884: LD_INT 6
100886: EQUAL
100887: AND
100888: IFFALSE 100944
// begin tmp2 := UnitsInside ( j ) ;
100890: LD_ADDR_VAR 0 9
100894: PUSH
100895: LD_VAR 0 3
100899: PPUSH
100900: CALL_OW 313
100904: ST_TO_ADDR
// if tmp2 = 6 then
100905: LD_VAR 0 9
100909: PUSH
100910: LD_INT 6
100912: EQUAL
100913: IFFALSE 100944
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
100915: LD_VAR 0 9
100919: PUSH
100920: LD_INT 1
100922: ARRAY
100923: PPUSH
100924: LD_INT 112
100926: PPUSH
100927: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
100931: LD_VAR 0 9
100935: PUSH
100936: LD_INT 1
100938: ARRAY
100939: PPUSH
100940: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
100944: LD_EXP 205
100948: PUSH
100949: LD_VAR 0 2
100953: ARRAY
100954: PUSH
100955: LD_EXP 205
100959: PUSH
100960: LD_VAR 0 2
100964: ARRAY
100965: PUSH
100966: LD_INT 1
100968: ARRAY
100969: PPUSH
100970: CALL_OW 314
100974: NOT
100975: AND
100976: PUSH
100977: LD_EXP 205
100981: PUSH
100982: LD_VAR 0 2
100986: ARRAY
100987: PUSH
100988: LD_INT 1
100990: ARRAY
100991: PPUSH
100992: CALL_OW 310
100996: NOT
100997: AND
100998: IFFALSE 101024
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
101000: LD_EXP 205
101004: PUSH
101005: LD_VAR 0 2
101009: ARRAY
101010: PUSH
101011: LD_INT 1
101013: ARRAY
101014: PPUSH
101015: LD_VAR 0 3
101019: PPUSH
101020: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
101024: LD_EXP 205
101028: PUSH
101029: LD_VAR 0 2
101033: ARRAY
101034: PUSH
101035: LD_INT 1
101037: ARRAY
101038: PPUSH
101039: CALL_OW 310
101043: PUSH
101044: LD_EXP 205
101048: PUSH
101049: LD_VAR 0 2
101053: ARRAY
101054: PUSH
101055: LD_INT 1
101057: ARRAY
101058: PPUSH
101059: CALL_OW 310
101063: PPUSH
101064: CALL_OW 461
101068: PUSH
101069: LD_INT 3
101071: NONEQUAL
101072: AND
101073: IFFALSE 101094
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
101075: LD_EXP 205
101079: PUSH
101080: LD_VAR 0 2
101084: ARRAY
101085: PUSH
101086: LD_INT 1
101088: ARRAY
101089: PPUSH
101090: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
101094: LD_VAR 0 3
101098: PPUSH
101099: CALL_OW 461
101103: PUSH
101104: LD_INT 6
101106: EQUAL
101107: PUSH
101108: LD_VAR 0 6
101112: PUSH
101113: LD_INT 1
101115: GREATER
101116: AND
101117: IFFALSE 101269
// begin sci := [ ] ;
101119: LD_ADDR_VAR 0 8
101123: PUSH
101124: EMPTY
101125: ST_TO_ADDR
// for x in ( tmp diff j ) do
101126: LD_ADDR_VAR 0 7
101130: PUSH
101131: LD_VAR 0 6
101135: PUSH
101136: LD_VAR 0 3
101140: DIFF
101141: PUSH
101142: FOR_IN
101143: IFFALSE 101195
// begin if sci = 6 then
101145: LD_VAR 0 8
101149: PUSH
101150: LD_INT 6
101152: EQUAL
101153: IFFALSE 101157
// break ;
101155: GO 101195
// if BuildingStatus ( x ) = bs_idle then
101157: LD_VAR 0 7
101161: PPUSH
101162: CALL_OW 461
101166: PUSH
101167: LD_INT 2
101169: EQUAL
101170: IFFALSE 101193
// sci := sci ^ UnitsInside ( x ) ;
101172: LD_ADDR_VAR 0 8
101176: PUSH
101177: LD_VAR 0 8
101181: PUSH
101182: LD_VAR 0 7
101186: PPUSH
101187: CALL_OW 313
101191: ADD
101192: ST_TO_ADDR
// end ;
101193: GO 101142
101195: POP
101196: POP
// if not sci then
101197: LD_VAR 0 8
101201: NOT
101202: IFFALSE 101206
// continue ;
101204: GO 100251
// for x in sci do
101206: LD_ADDR_VAR 0 7
101210: PUSH
101211: LD_VAR 0 8
101215: PUSH
101216: FOR_IN
101217: IFFALSE 101267
// if IsInUnit ( x ) and not HasTask ( x ) then
101219: LD_VAR 0 7
101223: PPUSH
101224: CALL_OW 310
101228: PUSH
101229: LD_VAR 0 7
101233: PPUSH
101234: CALL_OW 314
101238: NOT
101239: AND
101240: IFFALSE 101265
// begin ComExitBuilding ( x ) ;
101242: LD_VAR 0 7
101246: PPUSH
101247: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
101251: LD_VAR 0 7
101255: PPUSH
101256: LD_VAR 0 3
101260: PPUSH
101261: CALL_OW 180
// end ;
101265: GO 101216
101267: POP
101268: POP
// end ; end ;
101269: GO 100251
101271: POP
101272: POP
// end ;
101273: GO 100205
101275: POP
101276: POP
// end ;
101277: LD_VAR 0 1
101281: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
101282: LD_INT 0
101284: PPUSH
101285: PPUSH
// if not mc_bases then
101286: LD_EXP 175
101290: NOT
101291: IFFALSE 101295
// exit ;
101293: GO 101376
// for i = 1 to mc_bases do
101295: LD_ADDR_VAR 0 2
101299: PUSH
101300: DOUBLE
101301: LD_INT 1
101303: DEC
101304: ST_TO_ADDR
101305: LD_EXP 175
101309: PUSH
101310: FOR_TO
101311: IFFALSE 101374
// if mc_mines [ i ] and mc_miners [ i ] then
101313: LD_EXP 188
101317: PUSH
101318: LD_VAR 0 2
101322: ARRAY
101323: PUSH
101324: LD_EXP 189
101328: PUSH
101329: LD_VAR 0 2
101333: ARRAY
101334: AND
101335: IFFALSE 101372
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
101337: LD_EXP 189
101341: PUSH
101342: LD_VAR 0 2
101346: ARRAY
101347: PUSH
101348: LD_INT 1
101350: ARRAY
101351: PPUSH
101352: CALL_OW 255
101356: PPUSH
101357: LD_EXP 188
101361: PUSH
101362: LD_VAR 0 2
101366: ARRAY
101367: PPUSH
101368: CALL 21163 0 2
101372: GO 101310
101374: POP
101375: POP
// end ;
101376: LD_VAR 0 1
101380: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
101381: LD_INT 0
101383: PPUSH
101384: PPUSH
101385: PPUSH
101386: PPUSH
101387: PPUSH
101388: PPUSH
101389: PPUSH
101390: PPUSH
// if not mc_bases or not mc_parking then
101391: LD_EXP 175
101395: NOT
101396: PUSH
101397: LD_EXP 199
101401: NOT
101402: OR
101403: IFFALSE 101407
// exit ;
101405: GO 102117
// for i = 1 to mc_bases do
101407: LD_ADDR_VAR 0 2
101411: PUSH
101412: DOUBLE
101413: LD_INT 1
101415: DEC
101416: ST_TO_ADDR
101417: LD_EXP 175
101421: PUSH
101422: FOR_TO
101423: IFFALSE 102115
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
101425: LD_EXP 175
101429: PUSH
101430: LD_VAR 0 2
101434: ARRAY
101435: NOT
101436: PUSH
101437: LD_EXP 199
101441: PUSH
101442: LD_VAR 0 2
101446: ARRAY
101447: NOT
101448: OR
101449: IFFALSE 101453
// continue ;
101451: GO 101422
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
101453: LD_ADDR_VAR 0 5
101457: PUSH
101458: LD_EXP 175
101462: PUSH
101463: LD_VAR 0 2
101467: ARRAY
101468: PUSH
101469: LD_INT 1
101471: ARRAY
101472: PPUSH
101473: CALL_OW 255
101477: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
101478: LD_ADDR_VAR 0 6
101482: PUSH
101483: LD_EXP 175
101487: PUSH
101488: LD_VAR 0 2
101492: ARRAY
101493: PPUSH
101494: LD_INT 30
101496: PUSH
101497: LD_INT 3
101499: PUSH
101500: EMPTY
101501: LIST
101502: LIST
101503: PPUSH
101504: CALL_OW 72
101508: ST_TO_ADDR
// if not fac then
101509: LD_VAR 0 6
101513: NOT
101514: IFFALSE 101565
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
101516: LD_ADDR_VAR 0 6
101520: PUSH
101521: LD_EXP 175
101525: PUSH
101526: LD_VAR 0 2
101530: ARRAY
101531: PPUSH
101532: LD_INT 2
101534: PUSH
101535: LD_INT 30
101537: PUSH
101538: LD_INT 0
101540: PUSH
101541: EMPTY
101542: LIST
101543: LIST
101544: PUSH
101545: LD_INT 30
101547: PUSH
101548: LD_INT 1
101550: PUSH
101551: EMPTY
101552: LIST
101553: LIST
101554: PUSH
101555: EMPTY
101556: LIST
101557: LIST
101558: LIST
101559: PPUSH
101560: CALL_OW 72
101564: ST_TO_ADDR
// if not fac then
101565: LD_VAR 0 6
101569: NOT
101570: IFFALSE 101574
// continue ;
101572: GO 101422
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
101574: LD_ADDR_VAR 0 7
101578: PUSH
101579: LD_EXP 199
101583: PUSH
101584: LD_VAR 0 2
101588: ARRAY
101589: PPUSH
101590: LD_INT 22
101592: PUSH
101593: LD_VAR 0 5
101597: PUSH
101598: EMPTY
101599: LIST
101600: LIST
101601: PUSH
101602: LD_INT 21
101604: PUSH
101605: LD_INT 2
101607: PUSH
101608: EMPTY
101609: LIST
101610: LIST
101611: PUSH
101612: LD_INT 3
101614: PUSH
101615: LD_INT 24
101617: PUSH
101618: LD_INT 1000
101620: PUSH
101621: EMPTY
101622: LIST
101623: LIST
101624: PUSH
101625: EMPTY
101626: LIST
101627: LIST
101628: PUSH
101629: EMPTY
101630: LIST
101631: LIST
101632: LIST
101633: PPUSH
101634: CALL_OW 70
101638: ST_TO_ADDR
// for j in fac do
101639: LD_ADDR_VAR 0 3
101643: PUSH
101644: LD_VAR 0 6
101648: PUSH
101649: FOR_IN
101650: IFFALSE 101731
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
101652: LD_ADDR_VAR 0 7
101656: PUSH
101657: LD_VAR 0 7
101661: PUSH
101662: LD_INT 22
101664: PUSH
101665: LD_VAR 0 5
101669: PUSH
101670: EMPTY
101671: LIST
101672: LIST
101673: PUSH
101674: LD_INT 91
101676: PUSH
101677: LD_VAR 0 3
101681: PUSH
101682: LD_INT 15
101684: PUSH
101685: EMPTY
101686: LIST
101687: LIST
101688: LIST
101689: PUSH
101690: LD_INT 21
101692: PUSH
101693: LD_INT 2
101695: PUSH
101696: EMPTY
101697: LIST
101698: LIST
101699: PUSH
101700: LD_INT 3
101702: PUSH
101703: LD_INT 24
101705: PUSH
101706: LD_INT 1000
101708: PUSH
101709: EMPTY
101710: LIST
101711: LIST
101712: PUSH
101713: EMPTY
101714: LIST
101715: LIST
101716: PUSH
101717: EMPTY
101718: LIST
101719: LIST
101720: LIST
101721: LIST
101722: PPUSH
101723: CALL_OW 69
101727: UNION
101728: ST_TO_ADDR
101729: GO 101649
101731: POP
101732: POP
// if not vehs then
101733: LD_VAR 0 7
101737: NOT
101738: IFFALSE 101764
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
101740: LD_ADDR_EXP 187
101744: PUSH
101745: LD_EXP 187
101749: PPUSH
101750: LD_VAR 0 2
101754: PPUSH
101755: EMPTY
101756: PPUSH
101757: CALL_OW 1
101761: ST_TO_ADDR
// continue ;
101762: GO 101422
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
101764: LD_ADDR_VAR 0 8
101768: PUSH
101769: LD_EXP 175
101773: PUSH
101774: LD_VAR 0 2
101778: ARRAY
101779: PPUSH
101780: LD_INT 30
101782: PUSH
101783: LD_INT 3
101785: PUSH
101786: EMPTY
101787: LIST
101788: LIST
101789: PPUSH
101790: CALL_OW 72
101794: ST_TO_ADDR
// if tmp then
101795: LD_VAR 0 8
101799: IFFALSE 101902
// begin for j in tmp do
101801: LD_ADDR_VAR 0 3
101805: PUSH
101806: LD_VAR 0 8
101810: PUSH
101811: FOR_IN
101812: IFFALSE 101900
// for k in UnitsInside ( j ) do
101814: LD_ADDR_VAR 0 4
101818: PUSH
101819: LD_VAR 0 3
101823: PPUSH
101824: CALL_OW 313
101828: PUSH
101829: FOR_IN
101830: IFFALSE 101896
// if k then
101832: LD_VAR 0 4
101836: IFFALSE 101894
// if not k in mc_repair_vehicle [ i ] then
101838: LD_VAR 0 4
101842: PUSH
101843: LD_EXP 187
101847: PUSH
101848: LD_VAR 0 2
101852: ARRAY
101853: IN
101854: NOT
101855: IFFALSE 101894
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
101857: LD_ADDR_EXP 187
101861: PUSH
101862: LD_EXP 187
101866: PPUSH
101867: LD_VAR 0 2
101871: PPUSH
101872: LD_EXP 187
101876: PUSH
101877: LD_VAR 0 2
101881: ARRAY
101882: PUSH
101883: LD_VAR 0 4
101887: UNION
101888: PPUSH
101889: CALL_OW 1
101893: ST_TO_ADDR
101894: GO 101829
101896: POP
101897: POP
101898: GO 101811
101900: POP
101901: POP
// end ; if not mc_repair_vehicle [ i ] then
101902: LD_EXP 187
101906: PUSH
101907: LD_VAR 0 2
101911: ARRAY
101912: NOT
101913: IFFALSE 101917
// continue ;
101915: GO 101422
// for j in mc_repair_vehicle [ i ] do
101917: LD_ADDR_VAR 0 3
101921: PUSH
101922: LD_EXP 187
101926: PUSH
101927: LD_VAR 0 2
101931: ARRAY
101932: PUSH
101933: FOR_IN
101934: IFFALSE 102111
// begin if GetClass ( j ) <> 3 then
101936: LD_VAR 0 3
101940: PPUSH
101941: CALL_OW 257
101945: PUSH
101946: LD_INT 3
101948: NONEQUAL
101949: IFFALSE 101990
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
101951: LD_ADDR_EXP 187
101955: PUSH
101956: LD_EXP 187
101960: PPUSH
101961: LD_VAR 0 2
101965: PPUSH
101966: LD_EXP 187
101970: PUSH
101971: LD_VAR 0 2
101975: ARRAY
101976: PUSH
101977: LD_VAR 0 3
101981: DIFF
101982: PPUSH
101983: CALL_OW 1
101987: ST_TO_ADDR
// continue ;
101988: GO 101933
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
101990: LD_VAR 0 3
101994: PPUSH
101995: CALL_OW 311
101999: NOT
102000: PUSH
102001: LD_VAR 0 3
102005: PUSH
102006: LD_EXP 178
102010: PUSH
102011: LD_VAR 0 2
102015: ARRAY
102016: PUSH
102017: LD_INT 1
102019: ARRAY
102020: IN
102021: NOT
102022: AND
102023: PUSH
102024: LD_VAR 0 3
102028: PUSH
102029: LD_EXP 178
102033: PUSH
102034: LD_VAR 0 2
102038: ARRAY
102039: PUSH
102040: LD_INT 2
102042: ARRAY
102043: IN
102044: NOT
102045: AND
102046: IFFALSE 102109
// begin if IsInUnit ( j ) then
102048: LD_VAR 0 3
102052: PPUSH
102053: CALL_OW 310
102057: IFFALSE 102070
// ComExitBuilding ( j ) else
102059: LD_VAR 0 3
102063: PPUSH
102064: CALL_OW 122
102068: GO 102109
// if not WantToRepairVehicle ( j , vehs [ 1 ] ) then
102070: LD_VAR 0 3
102074: PPUSH
102075: LD_VAR 0 7
102079: PUSH
102080: LD_INT 1
102082: ARRAY
102083: PPUSH
102084: CALL 57817 0 2
102088: NOT
102089: IFFALSE 102109
// ComRepairVehicle ( j , vehs [ 1 ] ) ;
102091: LD_VAR 0 3
102095: PPUSH
102096: LD_VAR 0 7
102100: PUSH
102101: LD_INT 1
102103: ARRAY
102104: PPUSH
102105: CALL_OW 129
// end ; end ;
102109: GO 101933
102111: POP
102112: POP
// end ;
102113: GO 101422
102115: POP
102116: POP
// end ;
102117: LD_VAR 0 1
102121: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
102122: LD_INT 0
102124: PPUSH
102125: PPUSH
102126: PPUSH
102127: PPUSH
102128: PPUSH
102129: PPUSH
102130: PPUSH
102131: PPUSH
102132: PPUSH
102133: PPUSH
102134: PPUSH
// if not mc_bases then
102135: LD_EXP 175
102139: NOT
102140: IFFALSE 102144
// exit ;
102142: GO 102946
// for i = 1 to mc_bases do
102144: LD_ADDR_VAR 0 2
102148: PUSH
102149: DOUBLE
102150: LD_INT 1
102152: DEC
102153: ST_TO_ADDR
102154: LD_EXP 175
102158: PUSH
102159: FOR_TO
102160: IFFALSE 102944
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
102162: LD_EXP 203
102166: PUSH
102167: LD_VAR 0 2
102171: ARRAY
102172: NOT
102173: PUSH
102174: LD_EXP 178
102178: PUSH
102179: LD_VAR 0 2
102183: ARRAY
102184: PUSH
102185: LD_INT 1
102187: ARRAY
102188: OR
102189: PUSH
102190: LD_EXP 178
102194: PUSH
102195: LD_VAR 0 2
102199: ARRAY
102200: PUSH
102201: LD_INT 2
102203: ARRAY
102204: OR
102205: PUSH
102206: LD_EXP 201
102210: PUSH
102211: LD_VAR 0 2
102215: ARRAY
102216: PPUSH
102217: LD_INT 1
102219: PPUSH
102220: CALL_OW 325
102224: NOT
102225: OR
102226: PUSH
102227: LD_EXP 198
102231: PUSH
102232: LD_VAR 0 2
102236: ARRAY
102237: OR
102238: IFFALSE 102242
// continue ;
102240: GO 102159
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
102242: LD_ADDR_VAR 0 8
102246: PUSH
102247: LD_EXP 175
102251: PUSH
102252: LD_VAR 0 2
102256: ARRAY
102257: PPUSH
102258: LD_INT 25
102260: PUSH
102261: LD_INT 4
102263: PUSH
102264: EMPTY
102265: LIST
102266: LIST
102267: PUSH
102268: LD_INT 50
102270: PUSH
102271: EMPTY
102272: LIST
102273: PUSH
102274: LD_INT 3
102276: PUSH
102277: LD_INT 60
102279: PUSH
102280: EMPTY
102281: LIST
102282: PUSH
102283: EMPTY
102284: LIST
102285: LIST
102286: PUSH
102287: EMPTY
102288: LIST
102289: LIST
102290: LIST
102291: PPUSH
102292: CALL_OW 72
102296: PUSH
102297: LD_EXP 179
102301: PUSH
102302: LD_VAR 0 2
102306: ARRAY
102307: DIFF
102308: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
102309: LD_ADDR_VAR 0 9
102313: PUSH
102314: LD_EXP 175
102318: PUSH
102319: LD_VAR 0 2
102323: ARRAY
102324: PPUSH
102325: LD_INT 2
102327: PUSH
102328: LD_INT 30
102330: PUSH
102331: LD_INT 0
102333: PUSH
102334: EMPTY
102335: LIST
102336: LIST
102337: PUSH
102338: LD_INT 30
102340: PUSH
102341: LD_INT 1
102343: PUSH
102344: EMPTY
102345: LIST
102346: LIST
102347: PUSH
102348: EMPTY
102349: LIST
102350: LIST
102351: LIST
102352: PPUSH
102353: CALL_OW 72
102357: ST_TO_ADDR
// if not tmp or not dep then
102358: LD_VAR 0 8
102362: NOT
102363: PUSH
102364: LD_VAR 0 9
102368: NOT
102369: OR
102370: IFFALSE 102374
// continue ;
102372: GO 102159
// side := GetSide ( tmp [ 1 ] ) ;
102374: LD_ADDR_VAR 0 11
102378: PUSH
102379: LD_VAR 0 8
102383: PUSH
102384: LD_INT 1
102386: ARRAY
102387: PPUSH
102388: CALL_OW 255
102392: ST_TO_ADDR
// dep := dep [ 1 ] ;
102393: LD_ADDR_VAR 0 9
102397: PUSH
102398: LD_VAR 0 9
102402: PUSH
102403: LD_INT 1
102405: ARRAY
102406: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
102407: LD_ADDR_VAR 0 7
102411: PUSH
102412: LD_EXP 203
102416: PUSH
102417: LD_VAR 0 2
102421: ARRAY
102422: PPUSH
102423: LD_INT 22
102425: PUSH
102426: LD_INT 0
102428: PUSH
102429: EMPTY
102430: LIST
102431: LIST
102432: PUSH
102433: LD_INT 25
102435: PUSH
102436: LD_INT 12
102438: PUSH
102439: EMPTY
102440: LIST
102441: LIST
102442: PUSH
102443: EMPTY
102444: LIST
102445: LIST
102446: PPUSH
102447: CALL_OW 70
102451: PUSH
102452: LD_INT 22
102454: PUSH
102455: LD_INT 0
102457: PUSH
102458: EMPTY
102459: LIST
102460: LIST
102461: PUSH
102462: LD_INT 25
102464: PUSH
102465: LD_INT 12
102467: PUSH
102468: EMPTY
102469: LIST
102470: LIST
102471: PUSH
102472: LD_INT 91
102474: PUSH
102475: LD_VAR 0 9
102479: PUSH
102480: LD_INT 20
102482: PUSH
102483: EMPTY
102484: LIST
102485: LIST
102486: LIST
102487: PUSH
102488: EMPTY
102489: LIST
102490: LIST
102491: LIST
102492: PPUSH
102493: CALL_OW 69
102497: UNION
102498: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
102499: LD_ADDR_VAR 0 10
102503: PUSH
102504: LD_EXP 203
102508: PUSH
102509: LD_VAR 0 2
102513: ARRAY
102514: PPUSH
102515: LD_INT 81
102517: PUSH
102518: LD_VAR 0 11
102522: PUSH
102523: EMPTY
102524: LIST
102525: LIST
102526: PPUSH
102527: CALL_OW 70
102531: ST_TO_ADDR
// if not apes or danger_at_area then
102532: LD_VAR 0 7
102536: NOT
102537: PUSH
102538: LD_VAR 0 10
102542: OR
102543: IFFALSE 102593
// begin if mc_taming [ i ] then
102545: LD_EXP 206
102549: PUSH
102550: LD_VAR 0 2
102554: ARRAY
102555: IFFALSE 102591
// begin MC_Reset ( i , 121 ) ;
102557: LD_VAR 0 2
102561: PPUSH
102562: LD_INT 121
102564: PPUSH
102565: CALL 87726 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
102569: LD_ADDR_EXP 206
102573: PUSH
102574: LD_EXP 206
102578: PPUSH
102579: LD_VAR 0 2
102583: PPUSH
102584: EMPTY
102585: PPUSH
102586: CALL_OW 1
102590: ST_TO_ADDR
// end ; continue ;
102591: GO 102159
// end ; for j in tmp do
102593: LD_ADDR_VAR 0 3
102597: PUSH
102598: LD_VAR 0 8
102602: PUSH
102603: FOR_IN
102604: IFFALSE 102940
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
102606: LD_VAR 0 3
102610: PUSH
102611: LD_EXP 206
102615: PUSH
102616: LD_VAR 0 2
102620: ARRAY
102621: IN
102622: NOT
102623: PUSH
102624: LD_EXP 206
102628: PUSH
102629: LD_VAR 0 2
102633: ARRAY
102634: PUSH
102635: LD_INT 3
102637: LESS
102638: AND
102639: IFFALSE 102697
// begin SetTag ( j , 121 ) ;
102641: LD_VAR 0 3
102645: PPUSH
102646: LD_INT 121
102648: PPUSH
102649: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
102653: LD_ADDR_EXP 206
102657: PUSH
102658: LD_EXP 206
102662: PPUSH
102663: LD_VAR 0 2
102667: PUSH
102668: LD_EXP 206
102672: PUSH
102673: LD_VAR 0 2
102677: ARRAY
102678: PUSH
102679: LD_INT 1
102681: PLUS
102682: PUSH
102683: EMPTY
102684: LIST
102685: LIST
102686: PPUSH
102687: LD_VAR 0 3
102691: PPUSH
102692: CALL 24210 0 3
102696: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
102697: LD_VAR 0 3
102701: PUSH
102702: LD_EXP 206
102706: PUSH
102707: LD_VAR 0 2
102711: ARRAY
102712: IN
102713: IFFALSE 102938
// begin if GetClass ( j ) <> 4 then
102715: LD_VAR 0 3
102719: PPUSH
102720: CALL_OW 257
102724: PUSH
102725: LD_INT 4
102727: NONEQUAL
102728: IFFALSE 102781
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
102730: LD_ADDR_EXP 206
102734: PUSH
102735: LD_EXP 206
102739: PPUSH
102740: LD_VAR 0 2
102744: PPUSH
102745: LD_EXP 206
102749: PUSH
102750: LD_VAR 0 2
102754: ARRAY
102755: PUSH
102756: LD_VAR 0 3
102760: DIFF
102761: PPUSH
102762: CALL_OW 1
102766: ST_TO_ADDR
// SetTag ( j , 0 ) ;
102767: LD_VAR 0 3
102771: PPUSH
102772: LD_INT 0
102774: PPUSH
102775: CALL_OW 109
// continue ;
102779: GO 102603
// end ; if IsInUnit ( j ) then
102781: LD_VAR 0 3
102785: PPUSH
102786: CALL_OW 310
102790: IFFALSE 102801
// ComExitBuilding ( j ) ;
102792: LD_VAR 0 3
102796: PPUSH
102797: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
102801: LD_ADDR_VAR 0 6
102805: PUSH
102806: LD_VAR 0 7
102810: PPUSH
102811: LD_VAR 0 3
102815: PPUSH
102816: CALL_OW 74
102820: ST_TO_ADDR
// if not ape then
102821: LD_VAR 0 6
102825: NOT
102826: IFFALSE 102830
// break ;
102828: GO 102940
// x := GetX ( ape ) ;
102830: LD_ADDR_VAR 0 4
102834: PUSH
102835: LD_VAR 0 6
102839: PPUSH
102840: CALL_OW 250
102844: ST_TO_ADDR
// y := GetY ( ape ) ;
102845: LD_ADDR_VAR 0 5
102849: PUSH
102850: LD_VAR 0 6
102854: PPUSH
102855: CALL_OW 251
102859: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
102860: LD_VAR 0 4
102864: PPUSH
102865: LD_VAR 0 5
102869: PPUSH
102870: CALL_OW 488
102874: NOT
102875: PUSH
102876: LD_VAR 0 11
102880: PPUSH
102881: LD_VAR 0 4
102885: PPUSH
102886: LD_VAR 0 5
102890: PPUSH
102891: LD_INT 20
102893: PPUSH
102894: CALL 25106 0 4
102898: PUSH
102899: LD_INT 4
102901: ARRAY
102902: OR
102903: IFFALSE 102907
// break ;
102905: GO 102940
// if not HasTask ( j ) then
102907: LD_VAR 0 3
102911: PPUSH
102912: CALL_OW 314
102916: NOT
102917: IFFALSE 102938
// ComTameXY ( j , x , y ) ;
102919: LD_VAR 0 3
102923: PPUSH
102924: LD_VAR 0 4
102928: PPUSH
102929: LD_VAR 0 5
102933: PPUSH
102934: CALL_OW 131
// end ; end ;
102938: GO 102603
102940: POP
102941: POP
// end ;
102942: GO 102159
102944: POP
102945: POP
// end ;
102946: LD_VAR 0 1
102950: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
102951: LD_INT 0
102953: PPUSH
102954: PPUSH
102955: PPUSH
102956: PPUSH
102957: PPUSH
102958: PPUSH
102959: PPUSH
102960: PPUSH
// if not mc_bases then
102961: LD_EXP 175
102965: NOT
102966: IFFALSE 102970
// exit ;
102968: GO 103596
// for i = 1 to mc_bases do
102970: LD_ADDR_VAR 0 2
102974: PUSH
102975: DOUBLE
102976: LD_INT 1
102978: DEC
102979: ST_TO_ADDR
102980: LD_EXP 175
102984: PUSH
102985: FOR_TO
102986: IFFALSE 103594
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
102988: LD_EXP 204
102992: PUSH
102993: LD_VAR 0 2
102997: ARRAY
102998: NOT
102999: PUSH
103000: LD_EXP 204
103004: PUSH
103005: LD_VAR 0 2
103009: ARRAY
103010: PPUSH
103011: LD_INT 25
103013: PUSH
103014: LD_INT 12
103016: PUSH
103017: EMPTY
103018: LIST
103019: LIST
103020: PPUSH
103021: CALL_OW 72
103025: NOT
103026: OR
103027: IFFALSE 103031
// continue ;
103029: GO 102985
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
103031: LD_ADDR_VAR 0 5
103035: PUSH
103036: LD_EXP 204
103040: PUSH
103041: LD_VAR 0 2
103045: ARRAY
103046: PUSH
103047: LD_INT 1
103049: ARRAY
103050: PPUSH
103051: CALL_OW 255
103055: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
103056: LD_VAR 0 5
103060: PPUSH
103061: LD_INT 2
103063: PPUSH
103064: CALL_OW 325
103068: IFFALSE 103321
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
103070: LD_ADDR_VAR 0 4
103074: PUSH
103075: LD_EXP 204
103079: PUSH
103080: LD_VAR 0 2
103084: ARRAY
103085: PPUSH
103086: LD_INT 25
103088: PUSH
103089: LD_INT 16
103091: PUSH
103092: EMPTY
103093: LIST
103094: LIST
103095: PPUSH
103096: CALL_OW 72
103100: ST_TO_ADDR
// if tmp < 6 then
103101: LD_VAR 0 4
103105: PUSH
103106: LD_INT 6
103108: LESS
103109: IFFALSE 103321
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
103111: LD_ADDR_VAR 0 6
103115: PUSH
103116: LD_EXP 175
103120: PUSH
103121: LD_VAR 0 2
103125: ARRAY
103126: PPUSH
103127: LD_INT 2
103129: PUSH
103130: LD_INT 30
103132: PUSH
103133: LD_INT 0
103135: PUSH
103136: EMPTY
103137: LIST
103138: LIST
103139: PUSH
103140: LD_INT 30
103142: PUSH
103143: LD_INT 1
103145: PUSH
103146: EMPTY
103147: LIST
103148: LIST
103149: PUSH
103150: EMPTY
103151: LIST
103152: LIST
103153: LIST
103154: PPUSH
103155: CALL_OW 72
103159: ST_TO_ADDR
// if depot then
103160: LD_VAR 0 6
103164: IFFALSE 103321
// begin selected := 0 ;
103166: LD_ADDR_VAR 0 7
103170: PUSH
103171: LD_INT 0
103173: ST_TO_ADDR
// for j in depot do
103174: LD_ADDR_VAR 0 3
103178: PUSH
103179: LD_VAR 0 6
103183: PUSH
103184: FOR_IN
103185: IFFALSE 103216
// begin if UnitsInside ( j ) < 6 then
103187: LD_VAR 0 3
103191: PPUSH
103192: CALL_OW 313
103196: PUSH
103197: LD_INT 6
103199: LESS
103200: IFFALSE 103214
// begin selected := j ;
103202: LD_ADDR_VAR 0 7
103206: PUSH
103207: LD_VAR 0 3
103211: ST_TO_ADDR
// break ;
103212: GO 103216
// end ; end ;
103214: GO 103184
103216: POP
103217: POP
// if selected then
103218: LD_VAR 0 7
103222: IFFALSE 103321
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
103224: LD_ADDR_VAR 0 3
103228: PUSH
103229: LD_EXP 204
103233: PUSH
103234: LD_VAR 0 2
103238: ARRAY
103239: PPUSH
103240: LD_INT 25
103242: PUSH
103243: LD_INT 12
103245: PUSH
103246: EMPTY
103247: LIST
103248: LIST
103249: PPUSH
103250: CALL_OW 72
103254: PUSH
103255: FOR_IN
103256: IFFALSE 103319
// if not HasTask ( j ) then
103258: LD_VAR 0 3
103262: PPUSH
103263: CALL_OW 314
103267: NOT
103268: IFFALSE 103317
// begin if not IsInUnit ( j ) then
103270: LD_VAR 0 3
103274: PPUSH
103275: CALL_OW 310
103279: NOT
103280: IFFALSE 103296
// ComEnterUnit ( j , selected ) ;
103282: LD_VAR 0 3
103286: PPUSH
103287: LD_VAR 0 7
103291: PPUSH
103292: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
103296: LD_VAR 0 3
103300: PPUSH
103301: LD_INT 16
103303: PPUSH
103304: CALL_OW 183
// AddComExitBuilding ( j ) ;
103308: LD_VAR 0 3
103312: PPUSH
103313: CALL_OW 182
// end ;
103317: GO 103255
103319: POP
103320: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
103321: LD_VAR 0 5
103325: PPUSH
103326: LD_INT 11
103328: PPUSH
103329: CALL_OW 325
103333: IFFALSE 103592
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
103335: LD_ADDR_VAR 0 4
103339: PUSH
103340: LD_EXP 204
103344: PUSH
103345: LD_VAR 0 2
103349: ARRAY
103350: PPUSH
103351: LD_INT 25
103353: PUSH
103354: LD_INT 16
103356: PUSH
103357: EMPTY
103358: LIST
103359: LIST
103360: PPUSH
103361: CALL_OW 72
103365: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
103366: LD_VAR 0 4
103370: PUSH
103371: LD_INT 6
103373: GREATEREQUAL
103374: PUSH
103375: LD_VAR 0 5
103379: PPUSH
103380: LD_INT 2
103382: PPUSH
103383: CALL_OW 325
103387: NOT
103388: OR
103389: IFFALSE 103592
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
103391: LD_ADDR_VAR 0 8
103395: PUSH
103396: LD_EXP 175
103400: PUSH
103401: LD_VAR 0 2
103405: ARRAY
103406: PPUSH
103407: LD_INT 2
103409: PUSH
103410: LD_INT 30
103412: PUSH
103413: LD_INT 4
103415: PUSH
103416: EMPTY
103417: LIST
103418: LIST
103419: PUSH
103420: LD_INT 30
103422: PUSH
103423: LD_INT 5
103425: PUSH
103426: EMPTY
103427: LIST
103428: LIST
103429: PUSH
103430: EMPTY
103431: LIST
103432: LIST
103433: LIST
103434: PPUSH
103435: CALL_OW 72
103439: ST_TO_ADDR
// if barracks then
103440: LD_VAR 0 8
103444: IFFALSE 103592
// begin selected := 0 ;
103446: LD_ADDR_VAR 0 7
103450: PUSH
103451: LD_INT 0
103453: ST_TO_ADDR
// for j in barracks do
103454: LD_ADDR_VAR 0 3
103458: PUSH
103459: LD_VAR 0 8
103463: PUSH
103464: FOR_IN
103465: IFFALSE 103496
// begin if UnitsInside ( j ) < 6 then
103467: LD_VAR 0 3
103471: PPUSH
103472: CALL_OW 313
103476: PUSH
103477: LD_INT 6
103479: LESS
103480: IFFALSE 103494
// begin selected := j ;
103482: LD_ADDR_VAR 0 7
103486: PUSH
103487: LD_VAR 0 3
103491: ST_TO_ADDR
// break ;
103492: GO 103496
// end ; end ;
103494: GO 103464
103496: POP
103497: POP
// if selected then
103498: LD_VAR 0 7
103502: IFFALSE 103592
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
103504: LD_ADDR_VAR 0 3
103508: PUSH
103509: LD_EXP 204
103513: PUSH
103514: LD_VAR 0 2
103518: ARRAY
103519: PPUSH
103520: LD_INT 25
103522: PUSH
103523: LD_INT 12
103525: PUSH
103526: EMPTY
103527: LIST
103528: LIST
103529: PPUSH
103530: CALL_OW 72
103534: PUSH
103535: FOR_IN
103536: IFFALSE 103590
// if not IsInUnit ( j ) and not HasTask ( j ) then
103538: LD_VAR 0 3
103542: PPUSH
103543: CALL_OW 310
103547: NOT
103548: PUSH
103549: LD_VAR 0 3
103553: PPUSH
103554: CALL_OW 314
103558: NOT
103559: AND
103560: IFFALSE 103588
// begin ComEnterUnit ( j , selected ) ;
103562: LD_VAR 0 3
103566: PPUSH
103567: LD_VAR 0 7
103571: PPUSH
103572: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
103576: LD_VAR 0 3
103580: PPUSH
103581: LD_INT 15
103583: PPUSH
103584: CALL_OW 183
// end ;
103588: GO 103535
103590: POP
103591: POP
// end ; end ; end ; end ; end ;
103592: GO 102985
103594: POP
103595: POP
// end ;
103596: LD_VAR 0 1
103600: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
103601: LD_INT 0
103603: PPUSH
103604: PPUSH
103605: PPUSH
103606: PPUSH
// if not mc_bases then
103607: LD_EXP 175
103611: NOT
103612: IFFALSE 103616
// exit ;
103614: GO 103794
// for i = 1 to mc_bases do
103616: LD_ADDR_VAR 0 2
103620: PUSH
103621: DOUBLE
103622: LD_INT 1
103624: DEC
103625: ST_TO_ADDR
103626: LD_EXP 175
103630: PUSH
103631: FOR_TO
103632: IFFALSE 103792
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
103634: LD_ADDR_VAR 0 4
103638: PUSH
103639: LD_EXP 175
103643: PUSH
103644: LD_VAR 0 2
103648: ARRAY
103649: PPUSH
103650: LD_INT 25
103652: PUSH
103653: LD_INT 9
103655: PUSH
103656: EMPTY
103657: LIST
103658: LIST
103659: PPUSH
103660: CALL_OW 72
103664: ST_TO_ADDR
// if not tmp then
103665: LD_VAR 0 4
103669: NOT
103670: IFFALSE 103674
// continue ;
103672: GO 103631
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
103674: LD_EXP 201
103678: PUSH
103679: LD_VAR 0 2
103683: ARRAY
103684: PPUSH
103685: LD_INT 29
103687: PPUSH
103688: CALL_OW 325
103692: NOT
103693: PUSH
103694: LD_EXP 201
103698: PUSH
103699: LD_VAR 0 2
103703: ARRAY
103704: PPUSH
103705: LD_INT 28
103707: PPUSH
103708: CALL_OW 325
103712: NOT
103713: AND
103714: IFFALSE 103718
// continue ;
103716: GO 103631
// for j in tmp do
103718: LD_ADDR_VAR 0 3
103722: PUSH
103723: LD_VAR 0 4
103727: PUSH
103728: FOR_IN
103729: IFFALSE 103788
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
103731: LD_VAR 0 3
103735: PUSH
103736: LD_EXP 178
103740: PUSH
103741: LD_VAR 0 2
103745: ARRAY
103746: PUSH
103747: LD_INT 1
103749: ARRAY
103750: IN
103751: NOT
103752: PUSH
103753: LD_VAR 0 3
103757: PUSH
103758: LD_EXP 178
103762: PUSH
103763: LD_VAR 0 2
103767: ARRAY
103768: PUSH
103769: LD_INT 2
103771: ARRAY
103772: IN
103773: NOT
103774: AND
103775: IFFALSE 103786
// ComSpaceTimeShoot ( j ) ;
103777: LD_VAR 0 3
103781: PPUSH
103782: CALL 20171 0 1
103786: GO 103728
103788: POP
103789: POP
// end ;
103790: GO 103631
103792: POP
103793: POP
// end ;
103794: LD_VAR 0 1
103798: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
103799: LD_INT 0
103801: PPUSH
103802: PPUSH
103803: PPUSH
103804: PPUSH
103805: PPUSH
103806: PPUSH
103807: PPUSH
103808: PPUSH
103809: PPUSH
// if not mc_bases then
103810: LD_EXP 175
103814: NOT
103815: IFFALSE 103819
// exit ;
103817: GO 104441
// for i = 1 to mc_bases do
103819: LD_ADDR_VAR 0 2
103823: PUSH
103824: DOUBLE
103825: LD_INT 1
103827: DEC
103828: ST_TO_ADDR
103829: LD_EXP 175
103833: PUSH
103834: FOR_TO
103835: IFFALSE 104439
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
103837: LD_EXP 210
103841: PUSH
103842: LD_VAR 0 2
103846: ARRAY
103847: NOT
103848: PUSH
103849: LD_INT 38
103851: PPUSH
103852: LD_EXP 201
103856: PUSH
103857: LD_VAR 0 2
103861: ARRAY
103862: PPUSH
103863: CALL_OW 321
103867: PUSH
103868: LD_INT 2
103870: NONEQUAL
103871: OR
103872: IFFALSE 103876
// continue ;
103874: GO 103834
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
103876: LD_ADDR_VAR 0 8
103880: PUSH
103881: LD_EXP 175
103885: PUSH
103886: LD_VAR 0 2
103890: ARRAY
103891: PPUSH
103892: LD_INT 30
103894: PUSH
103895: LD_INT 34
103897: PUSH
103898: EMPTY
103899: LIST
103900: LIST
103901: PPUSH
103902: CALL_OW 72
103906: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
103907: LD_ADDR_VAR 0 9
103911: PUSH
103912: LD_EXP 175
103916: PUSH
103917: LD_VAR 0 2
103921: ARRAY
103922: PPUSH
103923: LD_INT 25
103925: PUSH
103926: LD_INT 4
103928: PUSH
103929: EMPTY
103930: LIST
103931: LIST
103932: PPUSH
103933: CALL_OW 72
103937: PPUSH
103938: LD_INT 0
103940: PPUSH
103941: CALL 53479 0 2
103945: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
103946: LD_VAR 0 9
103950: NOT
103951: PUSH
103952: LD_VAR 0 8
103956: NOT
103957: OR
103958: PUSH
103959: LD_EXP 175
103963: PUSH
103964: LD_VAR 0 2
103968: ARRAY
103969: PPUSH
103970: LD_INT 124
103972: PPUSH
103973: CALL 53479 0 2
103977: OR
103978: IFFALSE 103982
// continue ;
103980: GO 103834
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
103982: LD_EXP 211
103986: PUSH
103987: LD_VAR 0 2
103991: ARRAY
103992: PUSH
103993: LD_EXP 210
103997: PUSH
103998: LD_VAR 0 2
104002: ARRAY
104003: LESS
104004: PUSH
104005: LD_EXP 211
104009: PUSH
104010: LD_VAR 0 2
104014: ARRAY
104015: PUSH
104016: LD_VAR 0 8
104020: LESS
104021: AND
104022: IFFALSE 104437
// begin tmp := sci [ 1 ] ;
104024: LD_ADDR_VAR 0 7
104028: PUSH
104029: LD_VAR 0 9
104033: PUSH
104034: LD_INT 1
104036: ARRAY
104037: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
104038: LD_VAR 0 7
104042: PPUSH
104043: LD_INT 124
104045: PPUSH
104046: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
104050: LD_ADDR_VAR 0 3
104054: PUSH
104055: DOUBLE
104056: LD_EXP 210
104060: PUSH
104061: LD_VAR 0 2
104065: ARRAY
104066: INC
104067: ST_TO_ADDR
104068: LD_EXP 210
104072: PUSH
104073: LD_VAR 0 2
104077: ARRAY
104078: PUSH
104079: FOR_DOWNTO
104080: IFFALSE 104423
// begin if IsInUnit ( tmp ) then
104082: LD_VAR 0 7
104086: PPUSH
104087: CALL_OW 310
104091: IFFALSE 104102
// ComExitBuilding ( tmp ) ;
104093: LD_VAR 0 7
104097: PPUSH
104098: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
104102: LD_INT 35
104104: PPUSH
104105: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
104109: LD_VAR 0 7
104113: PPUSH
104114: CALL_OW 310
104118: NOT
104119: PUSH
104120: LD_VAR 0 7
104124: PPUSH
104125: CALL_OW 314
104129: NOT
104130: AND
104131: IFFALSE 104102
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
104133: LD_ADDR_VAR 0 6
104137: PUSH
104138: LD_VAR 0 7
104142: PPUSH
104143: CALL_OW 250
104147: PUSH
104148: LD_VAR 0 7
104152: PPUSH
104153: CALL_OW 251
104157: PUSH
104158: EMPTY
104159: LIST
104160: LIST
104161: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
104162: LD_INT 35
104164: PPUSH
104165: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
104169: LD_ADDR_VAR 0 4
104173: PUSH
104174: LD_EXP 210
104178: PUSH
104179: LD_VAR 0 2
104183: ARRAY
104184: PUSH
104185: LD_VAR 0 3
104189: ARRAY
104190: PUSH
104191: LD_INT 1
104193: ARRAY
104194: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
104195: LD_ADDR_VAR 0 5
104199: PUSH
104200: LD_EXP 210
104204: PUSH
104205: LD_VAR 0 2
104209: ARRAY
104210: PUSH
104211: LD_VAR 0 3
104215: ARRAY
104216: PUSH
104217: LD_INT 2
104219: ARRAY
104220: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
104221: LD_VAR 0 7
104225: PPUSH
104226: LD_INT 10
104228: PPUSH
104229: CALL 26809 0 2
104233: PUSH
104234: LD_INT 4
104236: ARRAY
104237: IFFALSE 104275
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
104239: LD_VAR 0 7
104243: PPUSH
104244: LD_VAR 0 6
104248: PUSH
104249: LD_INT 1
104251: ARRAY
104252: PPUSH
104253: LD_VAR 0 6
104257: PUSH
104258: LD_INT 2
104260: ARRAY
104261: PPUSH
104262: CALL_OW 111
// wait ( 0 0$10 ) ;
104266: LD_INT 350
104268: PPUSH
104269: CALL_OW 67
// end else
104273: GO 104301
// begin ComMoveXY ( tmp , x , y ) ;
104275: LD_VAR 0 7
104279: PPUSH
104280: LD_VAR 0 4
104284: PPUSH
104285: LD_VAR 0 5
104289: PPUSH
104290: CALL_OW 111
// wait ( 0 0$3 ) ;
104294: LD_INT 105
104296: PPUSH
104297: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
104301: LD_VAR 0 7
104305: PPUSH
104306: LD_VAR 0 4
104310: PPUSH
104311: LD_VAR 0 5
104315: PPUSH
104316: CALL_OW 307
104320: IFFALSE 104162
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
104322: LD_VAR 0 7
104326: PPUSH
104327: LD_VAR 0 4
104331: PPUSH
104332: LD_VAR 0 5
104336: PPUSH
104337: LD_VAR 0 8
104341: PUSH
104342: LD_VAR 0 3
104346: ARRAY
104347: PPUSH
104348: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
104352: LD_INT 35
104354: PPUSH
104355: CALL_OW 67
// until not HasTask ( tmp ) ;
104359: LD_VAR 0 7
104363: PPUSH
104364: CALL_OW 314
104368: NOT
104369: IFFALSE 104352
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
104371: LD_ADDR_EXP 211
104375: PUSH
104376: LD_EXP 211
104380: PPUSH
104381: LD_VAR 0 2
104385: PUSH
104386: LD_EXP 211
104390: PUSH
104391: LD_VAR 0 2
104395: ARRAY
104396: PUSH
104397: LD_INT 1
104399: PLUS
104400: PUSH
104401: EMPTY
104402: LIST
104403: LIST
104404: PPUSH
104405: LD_VAR 0 8
104409: PUSH
104410: LD_VAR 0 3
104414: ARRAY
104415: PPUSH
104416: CALL 24210 0 3
104420: ST_TO_ADDR
// end ;
104421: GO 104079
104423: POP
104424: POP
// MC_Reset ( i , 124 ) ;
104425: LD_VAR 0 2
104429: PPUSH
104430: LD_INT 124
104432: PPUSH
104433: CALL 87726 0 2
// end ; end ;
104437: GO 103834
104439: POP
104440: POP
// end ;
104441: LD_VAR 0 1
104445: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
104446: LD_INT 0
104448: PPUSH
104449: PPUSH
104450: PPUSH
// if not mc_bases then
104451: LD_EXP 175
104455: NOT
104456: IFFALSE 104460
// exit ;
104458: GO 105066
// for i = 1 to mc_bases do
104460: LD_ADDR_VAR 0 2
104464: PUSH
104465: DOUBLE
104466: LD_INT 1
104468: DEC
104469: ST_TO_ADDR
104470: LD_EXP 175
104474: PUSH
104475: FOR_TO
104476: IFFALSE 105064
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
104478: LD_ADDR_VAR 0 3
104482: PUSH
104483: LD_EXP 175
104487: PUSH
104488: LD_VAR 0 2
104492: ARRAY
104493: PPUSH
104494: LD_INT 25
104496: PUSH
104497: LD_INT 4
104499: PUSH
104500: EMPTY
104501: LIST
104502: LIST
104503: PPUSH
104504: CALL_OW 72
104508: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
104509: LD_VAR 0 3
104513: NOT
104514: PUSH
104515: LD_EXP 212
104519: PUSH
104520: LD_VAR 0 2
104524: ARRAY
104525: NOT
104526: OR
104527: PUSH
104528: LD_EXP 175
104532: PUSH
104533: LD_VAR 0 2
104537: ARRAY
104538: PPUSH
104539: LD_INT 2
104541: PUSH
104542: LD_INT 30
104544: PUSH
104545: LD_INT 0
104547: PUSH
104548: EMPTY
104549: LIST
104550: LIST
104551: PUSH
104552: LD_INT 30
104554: PUSH
104555: LD_INT 1
104557: PUSH
104558: EMPTY
104559: LIST
104560: LIST
104561: PUSH
104562: EMPTY
104563: LIST
104564: LIST
104565: LIST
104566: PPUSH
104567: CALL_OW 72
104571: NOT
104572: OR
104573: IFFALSE 104623
// begin if mc_deposits_finder [ i ] then
104575: LD_EXP 213
104579: PUSH
104580: LD_VAR 0 2
104584: ARRAY
104585: IFFALSE 104621
// begin MC_Reset ( i , 125 ) ;
104587: LD_VAR 0 2
104591: PPUSH
104592: LD_INT 125
104594: PPUSH
104595: CALL 87726 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
104599: LD_ADDR_EXP 213
104603: PUSH
104604: LD_EXP 213
104608: PPUSH
104609: LD_VAR 0 2
104613: PPUSH
104614: EMPTY
104615: PPUSH
104616: CALL_OW 1
104620: ST_TO_ADDR
// end ; continue ;
104621: GO 104475
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
104623: LD_EXP 212
104627: PUSH
104628: LD_VAR 0 2
104632: ARRAY
104633: PUSH
104634: LD_INT 1
104636: ARRAY
104637: PUSH
104638: LD_INT 3
104640: ARRAY
104641: PUSH
104642: LD_INT 1
104644: EQUAL
104645: PUSH
104646: LD_INT 20
104648: PPUSH
104649: LD_EXP 201
104653: PUSH
104654: LD_VAR 0 2
104658: ARRAY
104659: PPUSH
104660: CALL_OW 321
104664: PUSH
104665: LD_INT 2
104667: NONEQUAL
104668: AND
104669: IFFALSE 104719
// begin if mc_deposits_finder [ i ] then
104671: LD_EXP 213
104675: PUSH
104676: LD_VAR 0 2
104680: ARRAY
104681: IFFALSE 104717
// begin MC_Reset ( i , 125 ) ;
104683: LD_VAR 0 2
104687: PPUSH
104688: LD_INT 125
104690: PPUSH
104691: CALL 87726 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
104695: LD_ADDR_EXP 213
104699: PUSH
104700: LD_EXP 213
104704: PPUSH
104705: LD_VAR 0 2
104709: PPUSH
104710: EMPTY
104711: PPUSH
104712: CALL_OW 1
104716: ST_TO_ADDR
// end ; continue ;
104717: GO 104475
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
104719: LD_EXP 212
104723: PUSH
104724: LD_VAR 0 2
104728: ARRAY
104729: PUSH
104730: LD_INT 1
104732: ARRAY
104733: PUSH
104734: LD_INT 1
104736: ARRAY
104737: PPUSH
104738: LD_EXP 212
104742: PUSH
104743: LD_VAR 0 2
104747: ARRAY
104748: PUSH
104749: LD_INT 1
104751: ARRAY
104752: PUSH
104753: LD_INT 2
104755: ARRAY
104756: PPUSH
104757: LD_EXP 201
104761: PUSH
104762: LD_VAR 0 2
104766: ARRAY
104767: PPUSH
104768: CALL_OW 440
104772: IFFALSE 104815
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
104774: LD_ADDR_EXP 212
104778: PUSH
104779: LD_EXP 212
104783: PPUSH
104784: LD_VAR 0 2
104788: PPUSH
104789: LD_EXP 212
104793: PUSH
104794: LD_VAR 0 2
104798: ARRAY
104799: PPUSH
104800: LD_INT 1
104802: PPUSH
104803: CALL_OW 3
104807: PPUSH
104808: CALL_OW 1
104812: ST_TO_ADDR
104813: GO 105062
// begin if not mc_deposits_finder [ i ] then
104815: LD_EXP 213
104819: PUSH
104820: LD_VAR 0 2
104824: ARRAY
104825: NOT
104826: IFFALSE 104878
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
104828: LD_ADDR_EXP 213
104832: PUSH
104833: LD_EXP 213
104837: PPUSH
104838: LD_VAR 0 2
104842: PPUSH
104843: LD_VAR 0 3
104847: PUSH
104848: LD_INT 1
104850: ARRAY
104851: PUSH
104852: EMPTY
104853: LIST
104854: PPUSH
104855: CALL_OW 1
104859: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
104860: LD_VAR 0 3
104864: PUSH
104865: LD_INT 1
104867: ARRAY
104868: PPUSH
104869: LD_INT 125
104871: PPUSH
104872: CALL_OW 109
// end else
104876: GO 105062
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
104878: LD_EXP 213
104882: PUSH
104883: LD_VAR 0 2
104887: ARRAY
104888: PUSH
104889: LD_INT 1
104891: ARRAY
104892: PPUSH
104893: CALL_OW 310
104897: IFFALSE 104920
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
104899: LD_EXP 213
104903: PUSH
104904: LD_VAR 0 2
104908: ARRAY
104909: PUSH
104910: LD_INT 1
104912: ARRAY
104913: PPUSH
104914: CALL_OW 122
104918: GO 105062
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
104920: LD_EXP 213
104924: PUSH
104925: LD_VAR 0 2
104929: ARRAY
104930: PUSH
104931: LD_INT 1
104933: ARRAY
104934: PPUSH
104935: CALL_OW 314
104939: NOT
104940: PUSH
104941: LD_EXP 213
104945: PUSH
104946: LD_VAR 0 2
104950: ARRAY
104951: PUSH
104952: LD_INT 1
104954: ARRAY
104955: PPUSH
104956: LD_EXP 212
104960: PUSH
104961: LD_VAR 0 2
104965: ARRAY
104966: PUSH
104967: LD_INT 1
104969: ARRAY
104970: PUSH
104971: LD_INT 1
104973: ARRAY
104974: PPUSH
104975: LD_EXP 212
104979: PUSH
104980: LD_VAR 0 2
104984: ARRAY
104985: PUSH
104986: LD_INT 1
104988: ARRAY
104989: PUSH
104990: LD_INT 2
104992: ARRAY
104993: PPUSH
104994: CALL_OW 297
104998: PUSH
104999: LD_INT 6
105001: GREATER
105002: AND
105003: IFFALSE 105062
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
105005: LD_EXP 213
105009: PUSH
105010: LD_VAR 0 2
105014: ARRAY
105015: PUSH
105016: LD_INT 1
105018: ARRAY
105019: PPUSH
105020: LD_EXP 212
105024: PUSH
105025: LD_VAR 0 2
105029: ARRAY
105030: PUSH
105031: LD_INT 1
105033: ARRAY
105034: PUSH
105035: LD_INT 1
105037: ARRAY
105038: PPUSH
105039: LD_EXP 212
105043: PUSH
105044: LD_VAR 0 2
105048: ARRAY
105049: PUSH
105050: LD_INT 1
105052: ARRAY
105053: PUSH
105054: LD_INT 2
105056: ARRAY
105057: PPUSH
105058: CALL_OW 111
// end ; end ; end ;
105062: GO 104475
105064: POP
105065: POP
// end ;
105066: LD_VAR 0 1
105070: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
105071: LD_INT 0
105073: PPUSH
105074: PPUSH
105075: PPUSH
105076: PPUSH
105077: PPUSH
105078: PPUSH
105079: PPUSH
105080: PPUSH
105081: PPUSH
105082: PPUSH
105083: PPUSH
// if not mc_bases then
105084: LD_EXP 175
105088: NOT
105089: IFFALSE 105093
// exit ;
105091: GO 106033
// for i = 1 to mc_bases do
105093: LD_ADDR_VAR 0 2
105097: PUSH
105098: DOUBLE
105099: LD_INT 1
105101: DEC
105102: ST_TO_ADDR
105103: LD_EXP 175
105107: PUSH
105108: FOR_TO
105109: IFFALSE 106031
// begin if not mc_bases [ i ] or mc_scan [ i ] then
105111: LD_EXP 175
105115: PUSH
105116: LD_VAR 0 2
105120: ARRAY
105121: NOT
105122: PUSH
105123: LD_EXP 198
105127: PUSH
105128: LD_VAR 0 2
105132: ARRAY
105133: OR
105134: IFFALSE 105138
// continue ;
105136: GO 105108
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
105138: LD_ADDR_VAR 0 7
105142: PUSH
105143: LD_EXP 175
105147: PUSH
105148: LD_VAR 0 2
105152: ARRAY
105153: PUSH
105154: LD_INT 1
105156: ARRAY
105157: PPUSH
105158: CALL_OW 248
105162: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
105163: LD_VAR 0 7
105167: PUSH
105168: LD_INT 3
105170: EQUAL
105171: PUSH
105172: LD_EXP 194
105176: PUSH
105177: LD_VAR 0 2
105181: ARRAY
105182: PUSH
105183: LD_EXP 197
105187: PUSH
105188: LD_VAR 0 2
105192: ARRAY
105193: UNION
105194: PPUSH
105195: LD_INT 33
105197: PUSH
105198: LD_INT 2
105200: PUSH
105201: EMPTY
105202: LIST
105203: LIST
105204: PPUSH
105205: CALL_OW 72
105209: NOT
105210: OR
105211: IFFALSE 105215
// continue ;
105213: GO 105108
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
105215: LD_ADDR_VAR 0 9
105219: PUSH
105220: LD_EXP 175
105224: PUSH
105225: LD_VAR 0 2
105229: ARRAY
105230: PPUSH
105231: LD_INT 30
105233: PUSH
105234: LD_INT 36
105236: PUSH
105237: EMPTY
105238: LIST
105239: LIST
105240: PPUSH
105241: CALL_OW 72
105245: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
105246: LD_ADDR_VAR 0 10
105250: PUSH
105251: LD_EXP 194
105255: PUSH
105256: LD_VAR 0 2
105260: ARRAY
105261: PPUSH
105262: LD_INT 34
105264: PUSH
105265: LD_INT 31
105267: PUSH
105268: EMPTY
105269: LIST
105270: LIST
105271: PPUSH
105272: CALL_OW 72
105276: ST_TO_ADDR
// if not cts and not mcts then
105277: LD_VAR 0 9
105281: NOT
105282: PUSH
105283: LD_VAR 0 10
105287: NOT
105288: AND
105289: IFFALSE 105293
// continue ;
105291: GO 105108
// x := cts ;
105293: LD_ADDR_VAR 0 11
105297: PUSH
105298: LD_VAR 0 9
105302: ST_TO_ADDR
// if not x then
105303: LD_VAR 0 11
105307: NOT
105308: IFFALSE 105320
// x := mcts ;
105310: LD_ADDR_VAR 0 11
105314: PUSH
105315: LD_VAR 0 10
105319: ST_TO_ADDR
// if not x then
105320: LD_VAR 0 11
105324: NOT
105325: IFFALSE 105329
// continue ;
105327: GO 105108
// if mc_remote_driver [ i ] then
105329: LD_EXP 215
105333: PUSH
105334: LD_VAR 0 2
105338: ARRAY
105339: IFFALSE 105726
// for j in mc_remote_driver [ i ] do
105341: LD_ADDR_VAR 0 3
105345: PUSH
105346: LD_EXP 215
105350: PUSH
105351: LD_VAR 0 2
105355: ARRAY
105356: PUSH
105357: FOR_IN
105358: IFFALSE 105724
// begin if GetClass ( j ) <> 3 then
105360: LD_VAR 0 3
105364: PPUSH
105365: CALL_OW 257
105369: PUSH
105370: LD_INT 3
105372: NONEQUAL
105373: IFFALSE 105426
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
105375: LD_ADDR_EXP 215
105379: PUSH
105380: LD_EXP 215
105384: PPUSH
105385: LD_VAR 0 2
105389: PPUSH
105390: LD_EXP 215
105394: PUSH
105395: LD_VAR 0 2
105399: ARRAY
105400: PUSH
105401: LD_VAR 0 3
105405: DIFF
105406: PPUSH
105407: CALL_OW 1
105411: ST_TO_ADDR
// SetTag ( j , 0 ) ;
105412: LD_VAR 0 3
105416: PPUSH
105417: LD_INT 0
105419: PPUSH
105420: CALL_OW 109
// continue ;
105424: GO 105357
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
105426: LD_EXP 194
105430: PUSH
105431: LD_VAR 0 2
105435: ARRAY
105436: PPUSH
105437: LD_INT 34
105439: PUSH
105440: LD_INT 31
105442: PUSH
105443: EMPTY
105444: LIST
105445: LIST
105446: PUSH
105447: LD_INT 58
105449: PUSH
105450: EMPTY
105451: LIST
105452: PUSH
105453: EMPTY
105454: LIST
105455: LIST
105456: PPUSH
105457: CALL_OW 72
105461: PUSH
105462: LD_VAR 0 3
105466: PPUSH
105467: CALL 53567 0 1
105471: NOT
105472: AND
105473: IFFALSE 105544
// begin if IsInUnit ( j ) then
105475: LD_VAR 0 3
105479: PPUSH
105480: CALL_OW 310
105484: IFFALSE 105495
// ComExitBuilding ( j ) ;
105486: LD_VAR 0 3
105490: PPUSH
105491: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
105495: LD_VAR 0 3
105499: PPUSH
105500: LD_EXP 194
105504: PUSH
105505: LD_VAR 0 2
105509: ARRAY
105510: PPUSH
105511: LD_INT 34
105513: PUSH
105514: LD_INT 31
105516: PUSH
105517: EMPTY
105518: LIST
105519: LIST
105520: PUSH
105521: LD_INT 58
105523: PUSH
105524: EMPTY
105525: LIST
105526: PUSH
105527: EMPTY
105528: LIST
105529: LIST
105530: PPUSH
105531: CALL_OW 72
105535: PUSH
105536: LD_INT 1
105538: ARRAY
105539: PPUSH
105540: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
105544: LD_VAR 0 3
105548: PPUSH
105549: CALL_OW 310
105553: NOT
105554: PUSH
105555: LD_VAR 0 3
105559: PPUSH
105560: CALL_OW 310
105564: PPUSH
105565: CALL_OW 266
105569: PUSH
105570: LD_INT 36
105572: NONEQUAL
105573: PUSH
105574: LD_VAR 0 3
105578: PPUSH
105579: CALL 53567 0 1
105583: NOT
105584: AND
105585: OR
105586: IFFALSE 105722
// begin if IsInUnit ( j ) then
105588: LD_VAR 0 3
105592: PPUSH
105593: CALL_OW 310
105597: IFFALSE 105608
// ComExitBuilding ( j ) ;
105599: LD_VAR 0 3
105603: PPUSH
105604: CALL_OW 122
// ct := 0 ;
105608: LD_ADDR_VAR 0 8
105612: PUSH
105613: LD_INT 0
105615: ST_TO_ADDR
// for k in x do
105616: LD_ADDR_VAR 0 4
105620: PUSH
105621: LD_VAR 0 11
105625: PUSH
105626: FOR_IN
105627: IFFALSE 105700
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
105629: LD_VAR 0 4
105633: PPUSH
105634: CALL_OW 264
105638: PUSH
105639: LD_INT 31
105641: EQUAL
105642: PUSH
105643: LD_VAR 0 4
105647: PPUSH
105648: CALL_OW 311
105652: NOT
105653: AND
105654: PUSH
105655: LD_VAR 0 4
105659: PPUSH
105660: CALL_OW 266
105664: PUSH
105665: LD_INT 36
105667: EQUAL
105668: PUSH
105669: LD_VAR 0 4
105673: PPUSH
105674: CALL_OW 313
105678: PUSH
105679: LD_INT 3
105681: LESS
105682: AND
105683: OR
105684: IFFALSE 105698
// begin ct := k ;
105686: LD_ADDR_VAR 0 8
105690: PUSH
105691: LD_VAR 0 4
105695: ST_TO_ADDR
// break ;
105696: GO 105700
// end ;
105698: GO 105626
105700: POP
105701: POP
// if ct then
105702: LD_VAR 0 8
105706: IFFALSE 105722
// ComEnterUnit ( j , ct ) ;
105708: LD_VAR 0 3
105712: PPUSH
105713: LD_VAR 0 8
105717: PPUSH
105718: CALL_OW 120
// end ; end ;
105722: GO 105357
105724: POP
105725: POP
// places := 0 ;
105726: LD_ADDR_VAR 0 5
105730: PUSH
105731: LD_INT 0
105733: ST_TO_ADDR
// for j = 1 to x do
105734: LD_ADDR_VAR 0 3
105738: PUSH
105739: DOUBLE
105740: LD_INT 1
105742: DEC
105743: ST_TO_ADDR
105744: LD_VAR 0 11
105748: PUSH
105749: FOR_TO
105750: IFFALSE 105826
// if GetWeapon ( x [ j ] ) = ar_control_tower then
105752: LD_VAR 0 11
105756: PUSH
105757: LD_VAR 0 3
105761: ARRAY
105762: PPUSH
105763: CALL_OW 264
105767: PUSH
105768: LD_INT 31
105770: EQUAL
105771: IFFALSE 105789
// places := places + 1 else
105773: LD_ADDR_VAR 0 5
105777: PUSH
105778: LD_VAR 0 5
105782: PUSH
105783: LD_INT 1
105785: PLUS
105786: ST_TO_ADDR
105787: GO 105824
// if GetBType ( x [ j ] ) = b_control_tower then
105789: LD_VAR 0 11
105793: PUSH
105794: LD_VAR 0 3
105798: ARRAY
105799: PPUSH
105800: CALL_OW 266
105804: PUSH
105805: LD_INT 36
105807: EQUAL
105808: IFFALSE 105824
// places := places + 3 ;
105810: LD_ADDR_VAR 0 5
105814: PUSH
105815: LD_VAR 0 5
105819: PUSH
105820: LD_INT 3
105822: PLUS
105823: ST_TO_ADDR
105824: GO 105749
105826: POP
105827: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
105828: LD_VAR 0 5
105832: PUSH
105833: LD_INT 0
105835: EQUAL
105836: PUSH
105837: LD_VAR 0 5
105841: PUSH
105842: LD_EXP 215
105846: PUSH
105847: LD_VAR 0 2
105851: ARRAY
105852: LESSEQUAL
105853: OR
105854: IFFALSE 105858
// continue ;
105856: GO 105108
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
105858: LD_ADDR_VAR 0 6
105862: PUSH
105863: LD_EXP 175
105867: PUSH
105868: LD_VAR 0 2
105872: ARRAY
105873: PPUSH
105874: LD_INT 25
105876: PUSH
105877: LD_INT 3
105879: PUSH
105880: EMPTY
105881: LIST
105882: LIST
105883: PPUSH
105884: CALL_OW 72
105888: PUSH
105889: LD_EXP 215
105893: PUSH
105894: LD_VAR 0 2
105898: ARRAY
105899: DIFF
105900: PPUSH
105901: LD_INT 3
105903: PPUSH
105904: CALL 54467 0 2
105908: ST_TO_ADDR
// for j in tmp do
105909: LD_ADDR_VAR 0 3
105913: PUSH
105914: LD_VAR 0 6
105918: PUSH
105919: FOR_IN
105920: IFFALSE 105955
// if GetTag ( j ) > 0 then
105922: LD_VAR 0 3
105926: PPUSH
105927: CALL_OW 110
105931: PUSH
105932: LD_INT 0
105934: GREATER
105935: IFFALSE 105953
// tmp := tmp diff j ;
105937: LD_ADDR_VAR 0 6
105941: PUSH
105942: LD_VAR 0 6
105946: PUSH
105947: LD_VAR 0 3
105951: DIFF
105952: ST_TO_ADDR
105953: GO 105919
105955: POP
105956: POP
// if not tmp then
105957: LD_VAR 0 6
105961: NOT
105962: IFFALSE 105966
// continue ;
105964: GO 105108
// if places then
105966: LD_VAR 0 5
105970: IFFALSE 106029
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
105972: LD_ADDR_EXP 215
105976: PUSH
105977: LD_EXP 215
105981: PPUSH
105982: LD_VAR 0 2
105986: PPUSH
105987: LD_EXP 215
105991: PUSH
105992: LD_VAR 0 2
105996: ARRAY
105997: PUSH
105998: LD_VAR 0 6
106002: PUSH
106003: LD_INT 1
106005: ARRAY
106006: UNION
106007: PPUSH
106008: CALL_OW 1
106012: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
106013: LD_VAR 0 6
106017: PUSH
106018: LD_INT 1
106020: ARRAY
106021: PPUSH
106022: LD_INT 126
106024: PPUSH
106025: CALL_OW 109
// end ; end ;
106029: GO 105108
106031: POP
106032: POP
// end ;
106033: LD_VAR 0 1
106037: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
106038: LD_INT 0
106040: PPUSH
106041: PPUSH
106042: PPUSH
106043: PPUSH
106044: PPUSH
106045: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
106046: LD_VAR 0 1
106050: NOT
106051: PUSH
106052: LD_VAR 0 2
106056: NOT
106057: OR
106058: PUSH
106059: LD_VAR 0 3
106063: NOT
106064: OR
106065: PUSH
106066: LD_VAR 0 4
106070: PUSH
106071: LD_INT 1
106073: PUSH
106074: LD_INT 2
106076: PUSH
106077: LD_INT 3
106079: PUSH
106080: LD_INT 4
106082: PUSH
106083: LD_INT 5
106085: PUSH
106086: LD_INT 8
106088: PUSH
106089: LD_INT 9
106091: PUSH
106092: LD_INT 15
106094: PUSH
106095: LD_INT 16
106097: PUSH
106098: EMPTY
106099: LIST
106100: LIST
106101: LIST
106102: LIST
106103: LIST
106104: LIST
106105: LIST
106106: LIST
106107: LIST
106108: IN
106109: NOT
106110: OR
106111: IFFALSE 106115
// exit ;
106113: GO 107015
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
106115: LD_ADDR_VAR 0 2
106119: PUSH
106120: LD_VAR 0 2
106124: PPUSH
106125: LD_INT 21
106127: PUSH
106128: LD_INT 3
106130: PUSH
106131: EMPTY
106132: LIST
106133: LIST
106134: PUSH
106135: LD_INT 24
106137: PUSH
106138: LD_INT 250
106140: PUSH
106141: EMPTY
106142: LIST
106143: LIST
106144: PUSH
106145: EMPTY
106146: LIST
106147: LIST
106148: PPUSH
106149: CALL_OW 72
106153: ST_TO_ADDR
// case class of 1 , 15 :
106154: LD_VAR 0 4
106158: PUSH
106159: LD_INT 1
106161: DOUBLE
106162: EQUAL
106163: IFTRUE 106173
106165: LD_INT 15
106167: DOUBLE
106168: EQUAL
106169: IFTRUE 106173
106171: GO 106258
106173: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
106174: LD_ADDR_VAR 0 8
106178: PUSH
106179: LD_VAR 0 2
106183: PPUSH
106184: LD_INT 2
106186: PUSH
106187: LD_INT 30
106189: PUSH
106190: LD_INT 32
106192: PUSH
106193: EMPTY
106194: LIST
106195: LIST
106196: PUSH
106197: LD_INT 30
106199: PUSH
106200: LD_INT 31
106202: PUSH
106203: EMPTY
106204: LIST
106205: LIST
106206: PUSH
106207: EMPTY
106208: LIST
106209: LIST
106210: LIST
106211: PPUSH
106212: CALL_OW 72
106216: PUSH
106217: LD_VAR 0 2
106221: PPUSH
106222: LD_INT 2
106224: PUSH
106225: LD_INT 30
106227: PUSH
106228: LD_INT 4
106230: PUSH
106231: EMPTY
106232: LIST
106233: LIST
106234: PUSH
106235: LD_INT 30
106237: PUSH
106238: LD_INT 5
106240: PUSH
106241: EMPTY
106242: LIST
106243: LIST
106244: PUSH
106245: EMPTY
106246: LIST
106247: LIST
106248: LIST
106249: PPUSH
106250: CALL_OW 72
106254: ADD
106255: ST_TO_ADDR
106256: GO 106504
106258: LD_INT 2
106260: DOUBLE
106261: EQUAL
106262: IFTRUE 106272
106264: LD_INT 16
106266: DOUBLE
106267: EQUAL
106268: IFTRUE 106272
106270: GO 106318
106272: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
106273: LD_ADDR_VAR 0 8
106277: PUSH
106278: LD_VAR 0 2
106282: PPUSH
106283: LD_INT 2
106285: PUSH
106286: LD_INT 30
106288: PUSH
106289: LD_INT 0
106291: PUSH
106292: EMPTY
106293: LIST
106294: LIST
106295: PUSH
106296: LD_INT 30
106298: PUSH
106299: LD_INT 1
106301: PUSH
106302: EMPTY
106303: LIST
106304: LIST
106305: PUSH
106306: EMPTY
106307: LIST
106308: LIST
106309: LIST
106310: PPUSH
106311: CALL_OW 72
106315: ST_TO_ADDR
106316: GO 106504
106318: LD_INT 3
106320: DOUBLE
106321: EQUAL
106322: IFTRUE 106326
106324: GO 106372
106326: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
106327: LD_ADDR_VAR 0 8
106331: PUSH
106332: LD_VAR 0 2
106336: PPUSH
106337: LD_INT 2
106339: PUSH
106340: LD_INT 30
106342: PUSH
106343: LD_INT 2
106345: PUSH
106346: EMPTY
106347: LIST
106348: LIST
106349: PUSH
106350: LD_INT 30
106352: PUSH
106353: LD_INT 3
106355: PUSH
106356: EMPTY
106357: LIST
106358: LIST
106359: PUSH
106360: EMPTY
106361: LIST
106362: LIST
106363: LIST
106364: PPUSH
106365: CALL_OW 72
106369: ST_TO_ADDR
106370: GO 106504
106372: LD_INT 4
106374: DOUBLE
106375: EQUAL
106376: IFTRUE 106380
106378: GO 106437
106380: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
106381: LD_ADDR_VAR 0 8
106385: PUSH
106386: LD_VAR 0 2
106390: PPUSH
106391: LD_INT 2
106393: PUSH
106394: LD_INT 30
106396: PUSH
106397: LD_INT 6
106399: PUSH
106400: EMPTY
106401: LIST
106402: LIST
106403: PUSH
106404: LD_INT 30
106406: PUSH
106407: LD_INT 7
106409: PUSH
106410: EMPTY
106411: LIST
106412: LIST
106413: PUSH
106414: LD_INT 30
106416: PUSH
106417: LD_INT 8
106419: PUSH
106420: EMPTY
106421: LIST
106422: LIST
106423: PUSH
106424: EMPTY
106425: LIST
106426: LIST
106427: LIST
106428: LIST
106429: PPUSH
106430: CALL_OW 72
106434: ST_TO_ADDR
106435: GO 106504
106437: LD_INT 5
106439: DOUBLE
106440: EQUAL
106441: IFTRUE 106457
106443: LD_INT 8
106445: DOUBLE
106446: EQUAL
106447: IFTRUE 106457
106449: LD_INT 9
106451: DOUBLE
106452: EQUAL
106453: IFTRUE 106457
106455: GO 106503
106457: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
106458: LD_ADDR_VAR 0 8
106462: PUSH
106463: LD_VAR 0 2
106467: PPUSH
106468: LD_INT 2
106470: PUSH
106471: LD_INT 30
106473: PUSH
106474: LD_INT 4
106476: PUSH
106477: EMPTY
106478: LIST
106479: LIST
106480: PUSH
106481: LD_INT 30
106483: PUSH
106484: LD_INT 5
106486: PUSH
106487: EMPTY
106488: LIST
106489: LIST
106490: PUSH
106491: EMPTY
106492: LIST
106493: LIST
106494: LIST
106495: PPUSH
106496: CALL_OW 72
106500: ST_TO_ADDR
106501: GO 106504
106503: POP
// if not tmp then
106504: LD_VAR 0 8
106508: NOT
106509: IFFALSE 106513
// exit ;
106511: GO 107015
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
106513: LD_VAR 0 4
106517: PUSH
106518: LD_INT 1
106520: PUSH
106521: LD_INT 15
106523: PUSH
106524: EMPTY
106525: LIST
106526: LIST
106527: IN
106528: PUSH
106529: LD_EXP 184
106533: PUSH
106534: LD_VAR 0 1
106538: ARRAY
106539: AND
106540: IFFALSE 106696
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
106542: LD_ADDR_VAR 0 9
106546: PUSH
106547: LD_EXP 184
106551: PUSH
106552: LD_VAR 0 1
106556: ARRAY
106557: PUSH
106558: LD_INT 1
106560: ARRAY
106561: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
106562: LD_VAR 0 9
106566: PUSH
106567: LD_EXP 185
106571: PUSH
106572: LD_VAR 0 1
106576: ARRAY
106577: IN
106578: NOT
106579: IFFALSE 106694
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
106581: LD_ADDR_EXP 185
106585: PUSH
106586: LD_EXP 185
106590: PPUSH
106591: LD_VAR 0 1
106595: PUSH
106596: LD_EXP 185
106600: PUSH
106601: LD_VAR 0 1
106605: ARRAY
106606: PUSH
106607: LD_INT 1
106609: PLUS
106610: PUSH
106611: EMPTY
106612: LIST
106613: LIST
106614: PPUSH
106615: LD_VAR 0 9
106619: PPUSH
106620: CALL 24210 0 3
106624: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
106625: LD_ADDR_EXP 184
106629: PUSH
106630: LD_EXP 184
106634: PPUSH
106635: LD_VAR 0 1
106639: PPUSH
106640: LD_EXP 184
106644: PUSH
106645: LD_VAR 0 1
106649: ARRAY
106650: PUSH
106651: LD_VAR 0 9
106655: DIFF
106656: PPUSH
106657: CALL_OW 1
106661: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
106662: LD_VAR 0 3
106666: PPUSH
106667: LD_EXP 185
106671: PUSH
106672: LD_VAR 0 1
106676: ARRAY
106677: PUSH
106678: LD_EXP 185
106682: PUSH
106683: LD_VAR 0 1
106687: ARRAY
106688: ARRAY
106689: PPUSH
106690: CALL_OW 120
// end ; exit ;
106694: GO 107015
// end ; if tmp > 1 then
106696: LD_VAR 0 8
106700: PUSH
106701: LD_INT 1
106703: GREATER
106704: IFFALSE 106808
// for i = 2 to tmp do
106706: LD_ADDR_VAR 0 6
106710: PUSH
106711: DOUBLE
106712: LD_INT 2
106714: DEC
106715: ST_TO_ADDR
106716: LD_VAR 0 8
106720: PUSH
106721: FOR_TO
106722: IFFALSE 106806
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
106724: LD_VAR 0 8
106728: PUSH
106729: LD_VAR 0 6
106733: ARRAY
106734: PPUSH
106735: CALL_OW 461
106739: PUSH
106740: LD_INT 6
106742: EQUAL
106743: IFFALSE 106804
// begin x := tmp [ i ] ;
106745: LD_ADDR_VAR 0 9
106749: PUSH
106750: LD_VAR 0 8
106754: PUSH
106755: LD_VAR 0 6
106759: ARRAY
106760: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
106761: LD_ADDR_VAR 0 8
106765: PUSH
106766: LD_VAR 0 8
106770: PPUSH
106771: LD_VAR 0 6
106775: PPUSH
106776: CALL_OW 3
106780: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
106781: LD_ADDR_VAR 0 8
106785: PUSH
106786: LD_VAR 0 8
106790: PPUSH
106791: LD_INT 1
106793: PPUSH
106794: LD_VAR 0 9
106798: PPUSH
106799: CALL_OW 2
106803: ST_TO_ADDR
// end ;
106804: GO 106721
106806: POP
106807: POP
// for i in tmp do
106808: LD_ADDR_VAR 0 6
106812: PUSH
106813: LD_VAR 0 8
106817: PUSH
106818: FOR_IN
106819: IFFALSE 106888
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
106821: LD_VAR 0 6
106825: PPUSH
106826: CALL_OW 313
106830: PUSH
106831: LD_INT 6
106833: LESS
106834: PUSH
106835: LD_VAR 0 6
106839: PPUSH
106840: CALL_OW 266
106844: PUSH
106845: LD_INT 31
106847: PUSH
106848: LD_INT 32
106850: PUSH
106851: EMPTY
106852: LIST
106853: LIST
106854: IN
106855: NOT
106856: AND
106857: PUSH
106858: LD_VAR 0 6
106862: PPUSH
106863: CALL_OW 313
106867: PUSH
106868: LD_INT 0
106870: EQUAL
106871: OR
106872: IFFALSE 106886
// begin j := i ;
106874: LD_ADDR_VAR 0 7
106878: PUSH
106879: LD_VAR 0 6
106883: ST_TO_ADDR
// break ;
106884: GO 106888
// end ; end ;
106886: GO 106818
106888: POP
106889: POP
// if j then
106890: LD_VAR 0 7
106894: IFFALSE 106912
// ComEnterUnit ( unit , j ) else
106896: LD_VAR 0 3
106900: PPUSH
106901: LD_VAR 0 7
106905: PPUSH
106906: CALL_OW 120
106910: GO 107015
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
106912: LD_ADDR_VAR 0 10
106916: PUSH
106917: LD_VAR 0 2
106921: PPUSH
106922: LD_INT 2
106924: PUSH
106925: LD_INT 30
106927: PUSH
106928: LD_INT 0
106930: PUSH
106931: EMPTY
106932: LIST
106933: LIST
106934: PUSH
106935: LD_INT 30
106937: PUSH
106938: LD_INT 1
106940: PUSH
106941: EMPTY
106942: LIST
106943: LIST
106944: PUSH
106945: EMPTY
106946: LIST
106947: LIST
106948: LIST
106949: PPUSH
106950: CALL_OW 72
106954: ST_TO_ADDR
// if depot then
106955: LD_VAR 0 10
106959: IFFALSE 107015
// begin depot := NearestUnitToUnit ( depot , unit ) ;
106961: LD_ADDR_VAR 0 10
106965: PUSH
106966: LD_VAR 0 10
106970: PPUSH
106971: LD_VAR 0 3
106975: PPUSH
106976: CALL_OW 74
106980: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
106981: LD_VAR 0 3
106985: PPUSH
106986: LD_VAR 0 10
106990: PPUSH
106991: CALL_OW 296
106995: PUSH
106996: LD_INT 10
106998: GREATER
106999: IFFALSE 107015
// ComStandNearbyBuilding ( unit , depot ) ;
107001: LD_VAR 0 3
107005: PPUSH
107006: LD_VAR 0 10
107010: PPUSH
107011: CALL 20788 0 2
// end ; end ; end ;
107015: LD_VAR 0 5
107019: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
107020: LD_INT 0
107022: PPUSH
107023: PPUSH
107024: PPUSH
107025: PPUSH
// if not mc_bases then
107026: LD_EXP 175
107030: NOT
107031: IFFALSE 107035
// exit ;
107033: GO 107274
// for i = 1 to mc_bases do
107035: LD_ADDR_VAR 0 2
107039: PUSH
107040: DOUBLE
107041: LD_INT 1
107043: DEC
107044: ST_TO_ADDR
107045: LD_EXP 175
107049: PUSH
107050: FOR_TO
107051: IFFALSE 107272
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
107053: LD_ADDR_VAR 0 4
107057: PUSH
107058: LD_EXP 175
107062: PUSH
107063: LD_VAR 0 2
107067: ARRAY
107068: PPUSH
107069: LD_INT 21
107071: PUSH
107072: LD_INT 1
107074: PUSH
107075: EMPTY
107076: LIST
107077: LIST
107078: PPUSH
107079: CALL_OW 72
107083: PUSH
107084: LD_EXP 204
107088: PUSH
107089: LD_VAR 0 2
107093: ARRAY
107094: UNION
107095: ST_TO_ADDR
// if not tmp then
107096: LD_VAR 0 4
107100: NOT
107101: IFFALSE 107105
// continue ;
107103: GO 107050
// for j in tmp do
107105: LD_ADDR_VAR 0 3
107109: PUSH
107110: LD_VAR 0 4
107114: PUSH
107115: FOR_IN
107116: IFFALSE 107268
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
107118: LD_VAR 0 3
107122: PPUSH
107123: CALL_OW 110
107127: NOT
107128: PUSH
107129: LD_VAR 0 3
107133: PPUSH
107134: CALL_OW 314
107138: NOT
107139: AND
107140: PUSH
107141: LD_VAR 0 3
107145: PPUSH
107146: CALL_OW 311
107150: NOT
107151: AND
107152: PUSH
107153: LD_VAR 0 3
107157: PPUSH
107158: CALL_OW 310
107162: NOT
107163: AND
107164: PUSH
107165: LD_VAR 0 3
107169: PUSH
107170: LD_EXP 178
107174: PUSH
107175: LD_VAR 0 2
107179: ARRAY
107180: PUSH
107181: LD_INT 1
107183: ARRAY
107184: IN
107185: NOT
107186: AND
107187: PUSH
107188: LD_VAR 0 3
107192: PUSH
107193: LD_EXP 178
107197: PUSH
107198: LD_VAR 0 2
107202: ARRAY
107203: PUSH
107204: LD_INT 2
107206: ARRAY
107207: IN
107208: NOT
107209: AND
107210: PUSH
107211: LD_VAR 0 3
107215: PUSH
107216: LD_EXP 187
107220: PUSH
107221: LD_VAR 0 2
107225: ARRAY
107226: IN
107227: NOT
107228: AND
107229: IFFALSE 107266
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
107231: LD_VAR 0 2
107235: PPUSH
107236: LD_EXP 175
107240: PUSH
107241: LD_VAR 0 2
107245: ARRAY
107246: PPUSH
107247: LD_VAR 0 3
107251: PPUSH
107252: LD_VAR 0 3
107256: PPUSH
107257: CALL_OW 257
107261: PPUSH
107262: CALL 106038 0 4
// end ;
107266: GO 107115
107268: POP
107269: POP
// end ;
107270: GO 107050
107272: POP
107273: POP
// end ;
107274: LD_VAR 0 1
107278: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
107279: LD_INT 0
107281: PPUSH
107282: PPUSH
107283: PPUSH
107284: PPUSH
107285: PPUSH
107286: PPUSH
// if not mc_bases [ base ] then
107287: LD_EXP 175
107291: PUSH
107292: LD_VAR 0 1
107296: ARRAY
107297: NOT
107298: IFFALSE 107302
// exit ;
107300: GO 107484
// tmp := [ ] ;
107302: LD_ADDR_VAR 0 6
107306: PUSH
107307: EMPTY
107308: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
107309: LD_ADDR_VAR 0 7
107313: PUSH
107314: LD_VAR 0 3
107318: PPUSH
107319: LD_INT 0
107321: PPUSH
107322: CALL_OW 517
107326: ST_TO_ADDR
// if not list then
107327: LD_VAR 0 7
107331: NOT
107332: IFFALSE 107336
// exit ;
107334: GO 107484
// for i = 1 to amount do
107336: LD_ADDR_VAR 0 5
107340: PUSH
107341: DOUBLE
107342: LD_INT 1
107344: DEC
107345: ST_TO_ADDR
107346: LD_VAR 0 2
107350: PUSH
107351: FOR_TO
107352: IFFALSE 107432
// begin x := rand ( 1 , list [ 1 ] ) ;
107354: LD_ADDR_VAR 0 8
107358: PUSH
107359: LD_INT 1
107361: PPUSH
107362: LD_VAR 0 7
107366: PUSH
107367: LD_INT 1
107369: ARRAY
107370: PPUSH
107371: CALL_OW 12
107375: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
107376: LD_ADDR_VAR 0 6
107380: PUSH
107381: LD_VAR 0 6
107385: PPUSH
107386: LD_VAR 0 5
107390: PPUSH
107391: LD_VAR 0 7
107395: PUSH
107396: LD_INT 1
107398: ARRAY
107399: PUSH
107400: LD_VAR 0 8
107404: ARRAY
107405: PUSH
107406: LD_VAR 0 7
107410: PUSH
107411: LD_INT 2
107413: ARRAY
107414: PUSH
107415: LD_VAR 0 8
107419: ARRAY
107420: PUSH
107421: EMPTY
107422: LIST
107423: LIST
107424: PPUSH
107425: CALL_OW 1
107429: ST_TO_ADDR
// end ;
107430: GO 107351
107432: POP
107433: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
107434: LD_ADDR_EXP 188
107438: PUSH
107439: LD_EXP 188
107443: PPUSH
107444: LD_VAR 0 1
107448: PPUSH
107449: LD_VAR 0 6
107453: PPUSH
107454: CALL_OW 1
107458: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
107459: LD_ADDR_EXP 190
107463: PUSH
107464: LD_EXP 190
107468: PPUSH
107469: LD_VAR 0 1
107473: PPUSH
107474: LD_VAR 0 3
107478: PPUSH
107479: CALL_OW 1
107483: ST_TO_ADDR
// end ;
107484: LD_VAR 0 4
107488: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
107489: LD_INT 0
107491: PPUSH
// if not mc_bases [ base ] then
107492: LD_EXP 175
107496: PUSH
107497: LD_VAR 0 1
107501: ARRAY
107502: NOT
107503: IFFALSE 107507
// exit ;
107505: GO 107532
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
107507: LD_ADDR_EXP 180
107511: PUSH
107512: LD_EXP 180
107516: PPUSH
107517: LD_VAR 0 1
107521: PPUSH
107522: LD_VAR 0 2
107526: PPUSH
107527: CALL_OW 1
107531: ST_TO_ADDR
// end ;
107532: LD_VAR 0 3
107536: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
107537: LD_INT 0
107539: PPUSH
// if not mc_bases [ base ] then
107540: LD_EXP 175
107544: PUSH
107545: LD_VAR 0 1
107549: ARRAY
107550: NOT
107551: IFFALSE 107555
// exit ;
107553: GO 107592
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
107555: LD_ADDR_EXP 180
107559: PUSH
107560: LD_EXP 180
107564: PPUSH
107565: LD_VAR 0 1
107569: PPUSH
107570: LD_EXP 180
107574: PUSH
107575: LD_VAR 0 1
107579: ARRAY
107580: PUSH
107581: LD_VAR 0 2
107585: UNION
107586: PPUSH
107587: CALL_OW 1
107591: ST_TO_ADDR
// end ;
107592: LD_VAR 0 3
107596: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
107597: LD_INT 0
107599: PPUSH
// if not mc_bases [ base ] then
107600: LD_EXP 175
107604: PUSH
107605: LD_VAR 0 1
107609: ARRAY
107610: NOT
107611: IFFALSE 107615
// exit ;
107613: GO 107640
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
107615: LD_ADDR_EXP 196
107619: PUSH
107620: LD_EXP 196
107624: PPUSH
107625: LD_VAR 0 1
107629: PPUSH
107630: LD_VAR 0 2
107634: PPUSH
107635: CALL_OW 1
107639: ST_TO_ADDR
// end ;
107640: LD_VAR 0 3
107644: RET
// export function MC_InsertProduceList ( base , components ) ; begin
107645: LD_INT 0
107647: PPUSH
// if not mc_bases [ base ] then
107648: LD_EXP 175
107652: PUSH
107653: LD_VAR 0 1
107657: ARRAY
107658: NOT
107659: IFFALSE 107663
// exit ;
107661: GO 107700
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
107663: LD_ADDR_EXP 196
107667: PUSH
107668: LD_EXP 196
107672: PPUSH
107673: LD_VAR 0 1
107677: PPUSH
107678: LD_EXP 196
107682: PUSH
107683: LD_VAR 0 1
107687: ARRAY
107688: PUSH
107689: LD_VAR 0 2
107693: ADD
107694: PPUSH
107695: CALL_OW 1
107699: ST_TO_ADDR
// end ;
107700: LD_VAR 0 3
107704: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
107705: LD_INT 0
107707: PPUSH
// if not mc_bases [ base ] then
107708: LD_EXP 175
107712: PUSH
107713: LD_VAR 0 1
107717: ARRAY
107718: NOT
107719: IFFALSE 107723
// exit ;
107721: GO 107777
// mc_defender := Replace ( mc_defender , base , deflist ) ;
107723: LD_ADDR_EXP 197
107727: PUSH
107728: LD_EXP 197
107732: PPUSH
107733: LD_VAR 0 1
107737: PPUSH
107738: LD_VAR 0 2
107742: PPUSH
107743: CALL_OW 1
107747: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
107748: LD_ADDR_EXP 186
107752: PUSH
107753: LD_EXP 186
107757: PPUSH
107758: LD_VAR 0 1
107762: PPUSH
107763: LD_VAR 0 2
107767: PUSH
107768: LD_INT 0
107770: PLUS
107771: PPUSH
107772: CALL_OW 1
107776: ST_TO_ADDR
// end ;
107777: LD_VAR 0 3
107781: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
107782: LD_INT 0
107784: PPUSH
// if not mc_bases [ base ] then
107785: LD_EXP 175
107789: PUSH
107790: LD_VAR 0 1
107794: ARRAY
107795: NOT
107796: IFFALSE 107800
// exit ;
107798: GO 107825
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
107800: LD_ADDR_EXP 186
107804: PUSH
107805: LD_EXP 186
107809: PPUSH
107810: LD_VAR 0 1
107814: PPUSH
107815: LD_VAR 0 2
107819: PPUSH
107820: CALL_OW 1
107824: ST_TO_ADDR
// end ;
107825: LD_VAR 0 3
107829: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
107830: LD_INT 0
107832: PPUSH
107833: PPUSH
107834: PPUSH
107835: PPUSH
// if not mc_bases [ base ] then
107836: LD_EXP 175
107840: PUSH
107841: LD_VAR 0 1
107845: ARRAY
107846: NOT
107847: IFFALSE 107851
// exit ;
107849: GO 107916
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
107851: LD_ADDR_EXP 195
107855: PUSH
107856: LD_EXP 195
107860: PPUSH
107861: LD_VAR 0 1
107865: PUSH
107866: LD_EXP 195
107870: PUSH
107871: LD_VAR 0 1
107875: ARRAY
107876: PUSH
107877: LD_INT 1
107879: PLUS
107880: PUSH
107881: EMPTY
107882: LIST
107883: LIST
107884: PPUSH
107885: LD_VAR 0 1
107889: PUSH
107890: LD_VAR 0 2
107894: PUSH
107895: LD_VAR 0 3
107899: PUSH
107900: LD_VAR 0 4
107904: PUSH
107905: EMPTY
107906: LIST
107907: LIST
107908: LIST
107909: LIST
107910: PPUSH
107911: CALL 24210 0 3
107915: ST_TO_ADDR
// end ;
107916: LD_VAR 0 5
107920: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
107921: LD_INT 0
107923: PPUSH
// if not mc_bases [ base ] then
107924: LD_EXP 175
107928: PUSH
107929: LD_VAR 0 1
107933: ARRAY
107934: NOT
107935: IFFALSE 107939
// exit ;
107937: GO 107964
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
107939: LD_ADDR_EXP 212
107943: PUSH
107944: LD_EXP 212
107948: PPUSH
107949: LD_VAR 0 1
107953: PPUSH
107954: LD_VAR 0 2
107958: PPUSH
107959: CALL_OW 1
107963: ST_TO_ADDR
// end ;
107964: LD_VAR 0 3
107968: RET
// export function MC_GetMinesField ( base ) ; begin
107969: LD_INT 0
107971: PPUSH
// result := mc_mines [ base ] ;
107972: LD_ADDR_VAR 0 2
107976: PUSH
107977: LD_EXP 188
107981: PUSH
107982: LD_VAR 0 1
107986: ARRAY
107987: ST_TO_ADDR
// end ;
107988: LD_VAR 0 2
107992: RET
// export function MC_GetProduceList ( base ) ; begin
107993: LD_INT 0
107995: PPUSH
// result := mc_produce [ base ] ;
107996: LD_ADDR_VAR 0 2
108000: PUSH
108001: LD_EXP 196
108005: PUSH
108006: LD_VAR 0 1
108010: ARRAY
108011: ST_TO_ADDR
// end ;
108012: LD_VAR 0 2
108016: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
108017: LD_INT 0
108019: PPUSH
108020: PPUSH
// if not mc_bases then
108021: LD_EXP 175
108025: NOT
108026: IFFALSE 108030
// exit ;
108028: GO 108095
// if mc_bases [ base ] then
108030: LD_EXP 175
108034: PUSH
108035: LD_VAR 0 1
108039: ARRAY
108040: IFFALSE 108095
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
108042: LD_ADDR_VAR 0 3
108046: PUSH
108047: LD_EXP 175
108051: PUSH
108052: LD_VAR 0 1
108056: ARRAY
108057: PPUSH
108058: LD_INT 30
108060: PUSH
108061: LD_VAR 0 2
108065: PUSH
108066: EMPTY
108067: LIST
108068: LIST
108069: PPUSH
108070: CALL_OW 72
108074: ST_TO_ADDR
// if result then
108075: LD_VAR 0 3
108079: IFFALSE 108095
// result := result [ 1 ] ;
108081: LD_ADDR_VAR 0 3
108085: PUSH
108086: LD_VAR 0 3
108090: PUSH
108091: LD_INT 1
108093: ARRAY
108094: ST_TO_ADDR
// end ; end ;
108095: LD_VAR 0 3
108099: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
108100: LD_INT 0
108102: PPUSH
108103: PPUSH
// if not mc_bases then
108104: LD_EXP 175
108108: NOT
108109: IFFALSE 108113
// exit ;
108111: GO 108158
// if mc_bases [ base ] then
108113: LD_EXP 175
108117: PUSH
108118: LD_VAR 0 1
108122: ARRAY
108123: IFFALSE 108158
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
108125: LD_ADDR_VAR 0 3
108129: PUSH
108130: LD_EXP 175
108134: PUSH
108135: LD_VAR 0 1
108139: ARRAY
108140: PPUSH
108141: LD_INT 30
108143: PUSH
108144: LD_VAR 0 2
108148: PUSH
108149: EMPTY
108150: LIST
108151: LIST
108152: PPUSH
108153: CALL_OW 72
108157: ST_TO_ADDR
// end ;
108158: LD_VAR 0 3
108162: RET
// export function MC_SetTame ( base , area ) ; begin
108163: LD_INT 0
108165: PPUSH
// if not mc_bases or not base then
108166: LD_EXP 175
108170: NOT
108171: PUSH
108172: LD_VAR 0 1
108176: NOT
108177: OR
108178: IFFALSE 108182
// exit ;
108180: GO 108207
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
108182: LD_ADDR_EXP 203
108186: PUSH
108187: LD_EXP 203
108191: PPUSH
108192: LD_VAR 0 1
108196: PPUSH
108197: LD_VAR 0 2
108201: PPUSH
108202: CALL_OW 1
108206: ST_TO_ADDR
// end ;
108207: LD_VAR 0 3
108211: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
108212: LD_INT 0
108214: PPUSH
108215: PPUSH
// if not mc_bases or not base then
108216: LD_EXP 175
108220: NOT
108221: PUSH
108222: LD_VAR 0 1
108226: NOT
108227: OR
108228: IFFALSE 108232
// exit ;
108230: GO 108334
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
108232: LD_ADDR_VAR 0 4
108236: PUSH
108237: LD_EXP 175
108241: PUSH
108242: LD_VAR 0 1
108246: ARRAY
108247: PPUSH
108248: LD_INT 30
108250: PUSH
108251: LD_VAR 0 2
108255: PUSH
108256: EMPTY
108257: LIST
108258: LIST
108259: PPUSH
108260: CALL_OW 72
108264: ST_TO_ADDR
// if not tmp then
108265: LD_VAR 0 4
108269: NOT
108270: IFFALSE 108274
// exit ;
108272: GO 108334
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
108274: LD_ADDR_EXP 207
108278: PUSH
108279: LD_EXP 207
108283: PPUSH
108284: LD_VAR 0 1
108288: PPUSH
108289: LD_EXP 207
108293: PUSH
108294: LD_VAR 0 1
108298: ARRAY
108299: PPUSH
108300: LD_EXP 207
108304: PUSH
108305: LD_VAR 0 1
108309: ARRAY
108310: PUSH
108311: LD_INT 1
108313: PLUS
108314: PPUSH
108315: LD_VAR 0 4
108319: PUSH
108320: LD_INT 1
108322: ARRAY
108323: PPUSH
108324: CALL_OW 2
108328: PPUSH
108329: CALL_OW 1
108333: ST_TO_ADDR
// end ;
108334: LD_VAR 0 3
108338: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
108339: LD_INT 0
108341: PPUSH
108342: PPUSH
// if not mc_bases or not base or not kinds then
108343: LD_EXP 175
108347: NOT
108348: PUSH
108349: LD_VAR 0 1
108353: NOT
108354: OR
108355: PUSH
108356: LD_VAR 0 2
108360: NOT
108361: OR
108362: IFFALSE 108366
// exit ;
108364: GO 108427
// for i in kinds do
108366: LD_ADDR_VAR 0 4
108370: PUSH
108371: LD_VAR 0 2
108375: PUSH
108376: FOR_IN
108377: IFFALSE 108425
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
108379: LD_ADDR_EXP 209
108383: PUSH
108384: LD_EXP 209
108388: PPUSH
108389: LD_VAR 0 1
108393: PUSH
108394: LD_EXP 209
108398: PUSH
108399: LD_VAR 0 1
108403: ARRAY
108404: PUSH
108405: LD_INT 1
108407: PLUS
108408: PUSH
108409: EMPTY
108410: LIST
108411: LIST
108412: PPUSH
108413: LD_VAR 0 4
108417: PPUSH
108418: CALL 24210 0 3
108422: ST_TO_ADDR
108423: GO 108376
108425: POP
108426: POP
// end ;
108427: LD_VAR 0 3
108431: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
108432: LD_INT 0
108434: PPUSH
// if not mc_bases or not base or not areas then
108435: LD_EXP 175
108439: NOT
108440: PUSH
108441: LD_VAR 0 1
108445: NOT
108446: OR
108447: PUSH
108448: LD_VAR 0 2
108452: NOT
108453: OR
108454: IFFALSE 108458
// exit ;
108456: GO 108483
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
108458: LD_ADDR_EXP 193
108462: PUSH
108463: LD_EXP 193
108467: PPUSH
108468: LD_VAR 0 1
108472: PPUSH
108473: LD_VAR 0 2
108477: PPUSH
108478: CALL_OW 1
108482: ST_TO_ADDR
// end ;
108483: LD_VAR 0 3
108487: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
108488: LD_INT 0
108490: PPUSH
// if not mc_bases or not base or not teleports_exit then
108491: LD_EXP 175
108495: NOT
108496: PUSH
108497: LD_VAR 0 1
108501: NOT
108502: OR
108503: PUSH
108504: LD_VAR 0 2
108508: NOT
108509: OR
108510: IFFALSE 108514
// exit ;
108512: GO 108539
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
108514: LD_ADDR_EXP 210
108518: PUSH
108519: LD_EXP 210
108523: PPUSH
108524: LD_VAR 0 1
108528: PPUSH
108529: LD_VAR 0 2
108533: PPUSH
108534: CALL_OW 1
108538: ST_TO_ADDR
// end ;
108539: LD_VAR 0 3
108543: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
108544: LD_INT 0
108546: PPUSH
108547: PPUSH
108548: PPUSH
// if not mc_bases or not base or not ext_list then
108549: LD_EXP 175
108553: NOT
108554: PUSH
108555: LD_VAR 0 1
108559: NOT
108560: OR
108561: PUSH
108562: LD_VAR 0 5
108566: NOT
108567: OR
108568: IFFALSE 108572
// exit ;
108570: GO 108745
// tmp := GetFacExtXYD ( x , y , d ) ;
108572: LD_ADDR_VAR 0 8
108576: PUSH
108577: LD_VAR 0 2
108581: PPUSH
108582: LD_VAR 0 3
108586: PPUSH
108587: LD_VAR 0 4
108591: PPUSH
108592: CALL 53597 0 3
108596: ST_TO_ADDR
// if not tmp then
108597: LD_VAR 0 8
108601: NOT
108602: IFFALSE 108606
// exit ;
108604: GO 108745
// for i in tmp do
108606: LD_ADDR_VAR 0 7
108610: PUSH
108611: LD_VAR 0 8
108615: PUSH
108616: FOR_IN
108617: IFFALSE 108743
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
108619: LD_ADDR_EXP 180
108623: PUSH
108624: LD_EXP 180
108628: PPUSH
108629: LD_VAR 0 1
108633: PPUSH
108634: LD_EXP 180
108638: PUSH
108639: LD_VAR 0 1
108643: ARRAY
108644: PPUSH
108645: LD_EXP 180
108649: PUSH
108650: LD_VAR 0 1
108654: ARRAY
108655: PUSH
108656: LD_INT 1
108658: PLUS
108659: PPUSH
108660: LD_VAR 0 5
108664: PUSH
108665: LD_INT 1
108667: ARRAY
108668: PUSH
108669: LD_VAR 0 7
108673: PUSH
108674: LD_INT 1
108676: ARRAY
108677: PUSH
108678: LD_VAR 0 7
108682: PUSH
108683: LD_INT 2
108685: ARRAY
108686: PUSH
108687: LD_VAR 0 7
108691: PUSH
108692: LD_INT 3
108694: ARRAY
108695: PUSH
108696: EMPTY
108697: LIST
108698: LIST
108699: LIST
108700: LIST
108701: PPUSH
108702: CALL_OW 2
108706: PPUSH
108707: CALL_OW 1
108711: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
108712: LD_ADDR_VAR 0 5
108716: PUSH
108717: LD_VAR 0 5
108721: PPUSH
108722: LD_INT 1
108724: PPUSH
108725: CALL_OW 3
108729: ST_TO_ADDR
// if not ext_list then
108730: LD_VAR 0 5
108734: NOT
108735: IFFALSE 108741
// exit ;
108737: POP
108738: POP
108739: GO 108745
// end ;
108741: GO 108616
108743: POP
108744: POP
// end ;
108745: LD_VAR 0 6
108749: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
108750: LD_INT 0
108752: PPUSH
// if not mc_bases or not base or not weapon_list then
108753: LD_EXP 175
108757: NOT
108758: PUSH
108759: LD_VAR 0 1
108763: NOT
108764: OR
108765: PUSH
108766: LD_VAR 0 2
108770: NOT
108771: OR
108772: IFFALSE 108776
// exit ;
108774: GO 108801
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
108776: LD_ADDR_EXP 214
108780: PUSH
108781: LD_EXP 214
108785: PPUSH
108786: LD_VAR 0 1
108790: PPUSH
108791: LD_VAR 0 2
108795: PPUSH
108796: CALL_OW 1
108800: ST_TO_ADDR
// end ;
108801: LD_VAR 0 3
108805: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
108806: LD_INT 0
108808: PPUSH
// if not mc_bases or not base or not tech_list then
108809: LD_EXP 175
108813: NOT
108814: PUSH
108815: LD_VAR 0 1
108819: NOT
108820: OR
108821: PUSH
108822: LD_VAR 0 2
108826: NOT
108827: OR
108828: IFFALSE 108832
// exit ;
108830: GO 108857
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
108832: LD_ADDR_EXP 202
108836: PUSH
108837: LD_EXP 202
108841: PPUSH
108842: LD_VAR 0 1
108846: PPUSH
108847: LD_VAR 0 2
108851: PPUSH
108852: CALL_OW 1
108856: ST_TO_ADDR
// end ;
108857: LD_VAR 0 3
108861: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
108862: LD_INT 0
108864: PPUSH
// if not mc_bases or not parking_area or not base then
108865: LD_EXP 175
108869: NOT
108870: PUSH
108871: LD_VAR 0 2
108875: NOT
108876: OR
108877: PUSH
108878: LD_VAR 0 1
108882: NOT
108883: OR
108884: IFFALSE 108888
// exit ;
108886: GO 108913
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
108888: LD_ADDR_EXP 199
108892: PUSH
108893: LD_EXP 199
108897: PPUSH
108898: LD_VAR 0 1
108902: PPUSH
108903: LD_VAR 0 2
108907: PPUSH
108908: CALL_OW 1
108912: ST_TO_ADDR
// end ;
108913: LD_VAR 0 3
108917: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
108918: LD_INT 0
108920: PPUSH
// if not mc_bases or not base or not scan_area then
108921: LD_EXP 175
108925: NOT
108926: PUSH
108927: LD_VAR 0 1
108931: NOT
108932: OR
108933: PUSH
108934: LD_VAR 0 2
108938: NOT
108939: OR
108940: IFFALSE 108944
// exit ;
108942: GO 108969
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
108944: LD_ADDR_EXP 200
108948: PUSH
108949: LD_EXP 200
108953: PPUSH
108954: LD_VAR 0 1
108958: PPUSH
108959: LD_VAR 0 2
108963: PPUSH
108964: CALL_OW 1
108968: ST_TO_ADDR
// end ;
108969: LD_VAR 0 3
108973: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
108974: LD_INT 0
108976: PPUSH
108977: PPUSH
// if not mc_bases or not base then
108978: LD_EXP 175
108982: NOT
108983: PUSH
108984: LD_VAR 0 1
108988: NOT
108989: OR
108990: IFFALSE 108994
// exit ;
108992: GO 109058
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
108994: LD_ADDR_VAR 0 3
108998: PUSH
108999: LD_INT 1
109001: PUSH
109002: LD_INT 2
109004: PUSH
109005: LD_INT 3
109007: PUSH
109008: LD_INT 4
109010: PUSH
109011: LD_INT 11
109013: PUSH
109014: EMPTY
109015: LIST
109016: LIST
109017: LIST
109018: LIST
109019: LIST
109020: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
109021: LD_ADDR_EXP 202
109025: PUSH
109026: LD_EXP 202
109030: PPUSH
109031: LD_VAR 0 1
109035: PPUSH
109036: LD_EXP 202
109040: PUSH
109041: LD_VAR 0 1
109045: ARRAY
109046: PUSH
109047: LD_VAR 0 3
109051: DIFF
109052: PPUSH
109053: CALL_OW 1
109057: ST_TO_ADDR
// end ;
109058: LD_VAR 0 2
109062: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
109063: LD_INT 0
109065: PPUSH
// result := mc_vehicles [ base ] ;
109066: LD_ADDR_VAR 0 3
109070: PUSH
109071: LD_EXP 194
109075: PUSH
109076: LD_VAR 0 1
109080: ARRAY
109081: ST_TO_ADDR
// if onlyCombat then
109082: LD_VAR 0 2
109086: IFFALSE 109264
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
109088: LD_ADDR_VAR 0 3
109092: PUSH
109093: LD_VAR 0 3
109097: PUSH
109098: LD_VAR 0 3
109102: PPUSH
109103: LD_INT 2
109105: PUSH
109106: LD_INT 34
109108: PUSH
109109: LD_INT 12
109111: PUSH
109112: EMPTY
109113: LIST
109114: LIST
109115: PUSH
109116: LD_INT 34
109118: PUSH
109119: LD_INT 51
109121: PUSH
109122: EMPTY
109123: LIST
109124: LIST
109125: PUSH
109126: LD_INT 34
109128: PUSH
109129: LD_EXP 155
109133: PUSH
109134: EMPTY
109135: LIST
109136: LIST
109137: PUSH
109138: LD_INT 34
109140: PUSH
109141: LD_INT 32
109143: PUSH
109144: EMPTY
109145: LIST
109146: LIST
109147: PUSH
109148: LD_INT 34
109150: PUSH
109151: LD_INT 13
109153: PUSH
109154: EMPTY
109155: LIST
109156: LIST
109157: PUSH
109158: LD_INT 34
109160: PUSH
109161: LD_INT 52
109163: PUSH
109164: EMPTY
109165: LIST
109166: LIST
109167: PUSH
109168: LD_INT 34
109170: PUSH
109171: LD_EXP 160
109175: PUSH
109176: EMPTY
109177: LIST
109178: LIST
109179: PUSH
109180: LD_INT 34
109182: PUSH
109183: LD_INT 14
109185: PUSH
109186: EMPTY
109187: LIST
109188: LIST
109189: PUSH
109190: LD_INT 34
109192: PUSH
109193: LD_INT 53
109195: PUSH
109196: EMPTY
109197: LIST
109198: LIST
109199: PUSH
109200: LD_INT 34
109202: PUSH
109203: LD_EXP 154
109207: PUSH
109208: EMPTY
109209: LIST
109210: LIST
109211: PUSH
109212: LD_INT 34
109214: PUSH
109215: LD_INT 31
109217: PUSH
109218: EMPTY
109219: LIST
109220: LIST
109221: PUSH
109222: LD_INT 34
109224: PUSH
109225: LD_INT 48
109227: PUSH
109228: EMPTY
109229: LIST
109230: LIST
109231: PUSH
109232: LD_INT 34
109234: PUSH
109235: LD_INT 8
109237: PUSH
109238: EMPTY
109239: LIST
109240: LIST
109241: PUSH
109242: EMPTY
109243: LIST
109244: LIST
109245: LIST
109246: LIST
109247: LIST
109248: LIST
109249: LIST
109250: LIST
109251: LIST
109252: LIST
109253: LIST
109254: LIST
109255: LIST
109256: LIST
109257: PPUSH
109258: CALL_OW 72
109262: DIFF
109263: ST_TO_ADDR
// end ; end_of_file
109264: LD_VAR 0 3
109268: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
109269: LD_INT 0
109271: PPUSH
109272: PPUSH
109273: PPUSH
// if not mc_bases or not skirmish then
109274: LD_EXP 175
109278: NOT
109279: PUSH
109280: LD_EXP 173
109284: NOT
109285: OR
109286: IFFALSE 109290
// exit ;
109288: GO 109455
// for i = 1 to mc_bases do
109290: LD_ADDR_VAR 0 4
109294: PUSH
109295: DOUBLE
109296: LD_INT 1
109298: DEC
109299: ST_TO_ADDR
109300: LD_EXP 175
109304: PUSH
109305: FOR_TO
109306: IFFALSE 109453
// begin if sci in mc_bases [ i ] then
109308: LD_VAR 0 2
109312: PUSH
109313: LD_EXP 175
109317: PUSH
109318: LD_VAR 0 4
109322: ARRAY
109323: IN
109324: IFFALSE 109451
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
109326: LD_ADDR_EXP 204
109330: PUSH
109331: LD_EXP 204
109335: PPUSH
109336: LD_VAR 0 4
109340: PUSH
109341: LD_EXP 204
109345: PUSH
109346: LD_VAR 0 4
109350: ARRAY
109351: PUSH
109352: LD_INT 1
109354: PLUS
109355: PUSH
109356: EMPTY
109357: LIST
109358: LIST
109359: PPUSH
109360: LD_VAR 0 1
109364: PPUSH
109365: CALL 24210 0 3
109369: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
109370: LD_ADDR_VAR 0 5
109374: PUSH
109375: LD_EXP 175
109379: PUSH
109380: LD_VAR 0 4
109384: ARRAY
109385: PPUSH
109386: LD_INT 2
109388: PUSH
109389: LD_INT 30
109391: PUSH
109392: LD_INT 0
109394: PUSH
109395: EMPTY
109396: LIST
109397: LIST
109398: PUSH
109399: LD_INT 30
109401: PUSH
109402: LD_INT 1
109404: PUSH
109405: EMPTY
109406: LIST
109407: LIST
109408: PUSH
109409: EMPTY
109410: LIST
109411: LIST
109412: LIST
109413: PPUSH
109414: CALL_OW 72
109418: PPUSH
109419: LD_VAR 0 1
109423: PPUSH
109424: CALL_OW 74
109428: ST_TO_ADDR
// if tmp then
109429: LD_VAR 0 5
109433: IFFALSE 109449
// ComStandNearbyBuilding ( ape , tmp ) ;
109435: LD_VAR 0 1
109439: PPUSH
109440: LD_VAR 0 5
109444: PPUSH
109445: CALL 20788 0 2
// break ;
109449: GO 109453
// end ; end ;
109451: GO 109305
109453: POP
109454: POP
// end ;
109455: LD_VAR 0 3
109459: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
109460: LD_INT 0
109462: PPUSH
109463: PPUSH
109464: PPUSH
// if not mc_bases or not skirmish then
109465: LD_EXP 175
109469: NOT
109470: PUSH
109471: LD_EXP 173
109475: NOT
109476: OR
109477: IFFALSE 109481
// exit ;
109479: GO 109570
// for i = 1 to mc_bases do
109481: LD_ADDR_VAR 0 4
109485: PUSH
109486: DOUBLE
109487: LD_INT 1
109489: DEC
109490: ST_TO_ADDR
109491: LD_EXP 175
109495: PUSH
109496: FOR_TO
109497: IFFALSE 109568
// begin if building in mc_busy_turret_list [ i ] then
109499: LD_VAR 0 1
109503: PUSH
109504: LD_EXP 185
109508: PUSH
109509: LD_VAR 0 4
109513: ARRAY
109514: IN
109515: IFFALSE 109566
// begin tmp := mc_busy_turret_list [ i ] diff building ;
109517: LD_ADDR_VAR 0 5
109521: PUSH
109522: LD_EXP 185
109526: PUSH
109527: LD_VAR 0 4
109531: ARRAY
109532: PUSH
109533: LD_VAR 0 1
109537: DIFF
109538: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
109539: LD_ADDR_EXP 185
109543: PUSH
109544: LD_EXP 185
109548: PPUSH
109549: LD_VAR 0 4
109553: PPUSH
109554: LD_VAR 0 5
109558: PPUSH
109559: CALL_OW 1
109563: ST_TO_ADDR
// break ;
109564: GO 109568
// end ; end ;
109566: GO 109496
109568: POP
109569: POP
// end ;
109570: LD_VAR 0 3
109574: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
109575: LD_INT 0
109577: PPUSH
109578: PPUSH
109579: PPUSH
// if not mc_bases or not skirmish then
109580: LD_EXP 175
109584: NOT
109585: PUSH
109586: LD_EXP 173
109590: NOT
109591: OR
109592: IFFALSE 109596
// exit ;
109594: GO 109795
// for i = 1 to mc_bases do
109596: LD_ADDR_VAR 0 5
109600: PUSH
109601: DOUBLE
109602: LD_INT 1
109604: DEC
109605: ST_TO_ADDR
109606: LD_EXP 175
109610: PUSH
109611: FOR_TO
109612: IFFALSE 109793
// if building in mc_bases [ i ] then
109614: LD_VAR 0 1
109618: PUSH
109619: LD_EXP 175
109623: PUSH
109624: LD_VAR 0 5
109628: ARRAY
109629: IN
109630: IFFALSE 109791
// begin tmp := mc_bases [ i ] diff building ;
109632: LD_ADDR_VAR 0 6
109636: PUSH
109637: LD_EXP 175
109641: PUSH
109642: LD_VAR 0 5
109646: ARRAY
109647: PUSH
109648: LD_VAR 0 1
109652: DIFF
109653: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
109654: LD_ADDR_EXP 175
109658: PUSH
109659: LD_EXP 175
109663: PPUSH
109664: LD_VAR 0 5
109668: PPUSH
109669: LD_VAR 0 6
109673: PPUSH
109674: CALL_OW 1
109678: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
109679: LD_VAR 0 1
109683: PUSH
109684: LD_EXP 183
109688: PUSH
109689: LD_VAR 0 5
109693: ARRAY
109694: IN
109695: IFFALSE 109734
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
109697: LD_ADDR_EXP 183
109701: PUSH
109702: LD_EXP 183
109706: PPUSH
109707: LD_VAR 0 5
109711: PPUSH
109712: LD_EXP 183
109716: PUSH
109717: LD_VAR 0 5
109721: ARRAY
109722: PUSH
109723: LD_VAR 0 1
109727: DIFF
109728: PPUSH
109729: CALL_OW 1
109733: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
109734: LD_VAR 0 1
109738: PUSH
109739: LD_EXP 184
109743: PUSH
109744: LD_VAR 0 5
109748: ARRAY
109749: IN
109750: IFFALSE 109789
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
109752: LD_ADDR_EXP 184
109756: PUSH
109757: LD_EXP 184
109761: PPUSH
109762: LD_VAR 0 5
109766: PPUSH
109767: LD_EXP 184
109771: PUSH
109772: LD_VAR 0 5
109776: ARRAY
109777: PUSH
109778: LD_VAR 0 1
109782: DIFF
109783: PPUSH
109784: CALL_OW 1
109788: ST_TO_ADDR
// break ;
109789: GO 109793
// end ;
109791: GO 109611
109793: POP
109794: POP
// end ;
109795: LD_VAR 0 4
109799: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
109800: LD_INT 0
109802: PPUSH
109803: PPUSH
109804: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
109805: LD_EXP 175
109809: NOT
109810: PUSH
109811: LD_EXP 173
109815: NOT
109816: OR
109817: PUSH
109818: LD_VAR 0 3
109822: PUSH
109823: LD_EXP 201
109827: IN
109828: NOT
109829: OR
109830: IFFALSE 109834
// exit ;
109832: GO 109957
// for i = 1 to mc_vehicles do
109834: LD_ADDR_VAR 0 6
109838: PUSH
109839: DOUBLE
109840: LD_INT 1
109842: DEC
109843: ST_TO_ADDR
109844: LD_EXP 194
109848: PUSH
109849: FOR_TO
109850: IFFALSE 109955
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
109852: LD_VAR 0 2
109856: PUSH
109857: LD_EXP 194
109861: PUSH
109862: LD_VAR 0 6
109866: ARRAY
109867: IN
109868: PUSH
109869: LD_VAR 0 1
109873: PUSH
109874: LD_EXP 194
109878: PUSH
109879: LD_VAR 0 6
109883: ARRAY
109884: IN
109885: OR
109886: IFFALSE 109953
// begin tmp := mc_vehicles [ i ] diff old ;
109888: LD_ADDR_VAR 0 7
109892: PUSH
109893: LD_EXP 194
109897: PUSH
109898: LD_VAR 0 6
109902: ARRAY
109903: PUSH
109904: LD_VAR 0 2
109908: DIFF
109909: ST_TO_ADDR
// tmp := tmp diff new ;
109910: LD_ADDR_VAR 0 7
109914: PUSH
109915: LD_VAR 0 7
109919: PUSH
109920: LD_VAR 0 1
109924: DIFF
109925: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
109926: LD_ADDR_EXP 194
109930: PUSH
109931: LD_EXP 194
109935: PPUSH
109936: LD_VAR 0 6
109940: PPUSH
109941: LD_VAR 0 7
109945: PPUSH
109946: CALL_OW 1
109950: ST_TO_ADDR
// break ;
109951: GO 109955
// end ;
109953: GO 109849
109955: POP
109956: POP
// end ;
109957: LD_VAR 0 5
109961: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
109962: LD_INT 0
109964: PPUSH
109965: PPUSH
109966: PPUSH
109967: PPUSH
// if not mc_bases or not skirmish then
109968: LD_EXP 175
109972: NOT
109973: PUSH
109974: LD_EXP 173
109978: NOT
109979: OR
109980: IFFALSE 109984
// exit ;
109982: GO 110376
// side := GetSide ( vehicle ) ;
109984: LD_ADDR_VAR 0 5
109988: PUSH
109989: LD_VAR 0 1
109993: PPUSH
109994: CALL_OW 255
109998: ST_TO_ADDR
// for i = 1 to mc_bases do
109999: LD_ADDR_VAR 0 4
110003: PUSH
110004: DOUBLE
110005: LD_INT 1
110007: DEC
110008: ST_TO_ADDR
110009: LD_EXP 175
110013: PUSH
110014: FOR_TO
110015: IFFALSE 110374
// begin if factory in mc_bases [ i ] then
110017: LD_VAR 0 2
110021: PUSH
110022: LD_EXP 175
110026: PUSH
110027: LD_VAR 0 4
110031: ARRAY
110032: IN
110033: IFFALSE 110372
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
110035: LD_EXP 197
110039: PUSH
110040: LD_VAR 0 4
110044: ARRAY
110045: PUSH
110046: LD_EXP 186
110050: PUSH
110051: LD_VAR 0 4
110055: ARRAY
110056: LESS
110057: PUSH
110058: LD_VAR 0 1
110062: PPUSH
110063: CALL_OW 264
110067: PUSH
110068: LD_INT 31
110070: PUSH
110071: LD_INT 32
110073: PUSH
110074: LD_INT 51
110076: PUSH
110077: LD_EXP 155
110081: PUSH
110082: LD_INT 12
110084: PUSH
110085: LD_INT 30
110087: PUSH
110088: LD_EXP 154
110092: PUSH
110093: LD_INT 11
110095: PUSH
110096: LD_INT 53
110098: PUSH
110099: LD_INT 14
110101: PUSH
110102: LD_EXP 158
110106: PUSH
110107: LD_INT 29
110109: PUSH
110110: LD_EXP 156
110114: PUSH
110115: LD_INT 13
110117: PUSH
110118: LD_INT 52
110120: PUSH
110121: LD_EXP 160
110125: PUSH
110126: LD_INT 48
110128: PUSH
110129: LD_INT 8
110131: PUSH
110132: EMPTY
110133: LIST
110134: LIST
110135: LIST
110136: LIST
110137: LIST
110138: LIST
110139: LIST
110140: LIST
110141: LIST
110142: LIST
110143: LIST
110144: LIST
110145: LIST
110146: LIST
110147: LIST
110148: LIST
110149: LIST
110150: LIST
110151: IN
110152: NOT
110153: AND
110154: IFFALSE 110202
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
110156: LD_ADDR_EXP 197
110160: PUSH
110161: LD_EXP 197
110165: PPUSH
110166: LD_VAR 0 4
110170: PUSH
110171: LD_EXP 197
110175: PUSH
110176: LD_VAR 0 4
110180: ARRAY
110181: PUSH
110182: LD_INT 1
110184: PLUS
110185: PUSH
110186: EMPTY
110187: LIST
110188: LIST
110189: PPUSH
110190: LD_VAR 0 1
110194: PPUSH
110195: CALL 24210 0 3
110199: ST_TO_ADDR
110200: GO 110246
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
110202: LD_ADDR_EXP 194
110206: PUSH
110207: LD_EXP 194
110211: PPUSH
110212: LD_VAR 0 4
110216: PUSH
110217: LD_EXP 194
110221: PUSH
110222: LD_VAR 0 4
110226: ARRAY
110227: PUSH
110228: LD_INT 1
110230: PLUS
110231: PUSH
110232: EMPTY
110233: LIST
110234: LIST
110235: PPUSH
110236: LD_VAR 0 1
110240: PPUSH
110241: CALL 24210 0 3
110245: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
110246: LD_VAR 0 1
110250: PPUSH
110251: CALL_OW 263
110255: PUSH
110256: LD_INT 2
110258: EQUAL
110259: IFFALSE 110288
// begin repeat wait ( 0 0$3 ) ;
110261: LD_INT 105
110263: PPUSH
110264: CALL_OW 67
// Connect ( vehicle ) ;
110268: LD_VAR 0 1
110272: PPUSH
110273: CALL 27181 0 1
// until IsControledBy ( vehicle ) ;
110277: LD_VAR 0 1
110281: PPUSH
110282: CALL_OW 312
110286: IFFALSE 110261
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
110288: LD_VAR 0 1
110292: PPUSH
110293: LD_EXP 199
110297: PUSH
110298: LD_VAR 0 4
110302: ARRAY
110303: PPUSH
110304: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
110308: LD_VAR 0 1
110312: PPUSH
110313: CALL_OW 263
110317: PUSH
110318: LD_INT 1
110320: NONEQUAL
110321: IFFALSE 110325
// break ;
110323: GO 110374
// repeat wait ( 0 0$1 ) ;
110325: LD_INT 35
110327: PPUSH
110328: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
110332: LD_VAR 0 1
110336: PPUSH
110337: LD_EXP 199
110341: PUSH
110342: LD_VAR 0 4
110346: ARRAY
110347: PPUSH
110348: CALL_OW 308
110352: IFFALSE 110325
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
110354: LD_VAR 0 1
110358: PPUSH
110359: CALL_OW 311
110363: PPUSH
110364: CALL_OW 121
// exit ;
110368: POP
110369: POP
110370: GO 110376
// end ; end ;
110372: GO 110014
110374: POP
110375: POP
// end ;
110376: LD_VAR 0 3
110380: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
110381: LD_INT 0
110383: PPUSH
110384: PPUSH
110385: PPUSH
110386: PPUSH
// if not mc_bases or not skirmish then
110387: LD_EXP 175
110391: NOT
110392: PUSH
110393: LD_EXP 173
110397: NOT
110398: OR
110399: IFFALSE 110403
// exit ;
110401: GO 110756
// repeat wait ( 0 0$1 ) ;
110403: LD_INT 35
110405: PPUSH
110406: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
110410: LD_VAR 0 2
110414: PPUSH
110415: LD_VAR 0 3
110419: PPUSH
110420: CALL_OW 284
110424: IFFALSE 110403
// if GetResourceTypeXY ( x , y ) = mat_artefact then
110426: LD_VAR 0 2
110430: PPUSH
110431: LD_VAR 0 3
110435: PPUSH
110436: CALL_OW 283
110440: PUSH
110441: LD_INT 4
110443: EQUAL
110444: IFFALSE 110448
// exit ;
110446: GO 110756
// for i = 1 to mc_bases do
110448: LD_ADDR_VAR 0 7
110452: PUSH
110453: DOUBLE
110454: LD_INT 1
110456: DEC
110457: ST_TO_ADDR
110458: LD_EXP 175
110462: PUSH
110463: FOR_TO
110464: IFFALSE 110754
// begin if mc_crates_area [ i ] then
110466: LD_EXP 193
110470: PUSH
110471: LD_VAR 0 7
110475: ARRAY
110476: IFFALSE 110587
// for j in mc_crates_area [ i ] do
110478: LD_ADDR_VAR 0 8
110482: PUSH
110483: LD_EXP 193
110487: PUSH
110488: LD_VAR 0 7
110492: ARRAY
110493: PUSH
110494: FOR_IN
110495: IFFALSE 110585
// if InArea ( x , y , j ) then
110497: LD_VAR 0 2
110501: PPUSH
110502: LD_VAR 0 3
110506: PPUSH
110507: LD_VAR 0 8
110511: PPUSH
110512: CALL_OW 309
110516: IFFALSE 110583
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
110518: LD_ADDR_EXP 191
110522: PUSH
110523: LD_EXP 191
110527: PPUSH
110528: LD_VAR 0 7
110532: PUSH
110533: LD_EXP 191
110537: PUSH
110538: LD_VAR 0 7
110542: ARRAY
110543: PUSH
110544: LD_INT 1
110546: PLUS
110547: PUSH
110548: EMPTY
110549: LIST
110550: LIST
110551: PPUSH
110552: LD_VAR 0 4
110556: PUSH
110557: LD_VAR 0 2
110561: PUSH
110562: LD_VAR 0 3
110566: PUSH
110567: EMPTY
110568: LIST
110569: LIST
110570: LIST
110571: PPUSH
110572: CALL 24210 0 3
110576: ST_TO_ADDR
// exit ;
110577: POP
110578: POP
110579: POP
110580: POP
110581: GO 110756
// end ;
110583: GO 110494
110585: POP
110586: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
110587: LD_ADDR_VAR 0 9
110591: PUSH
110592: LD_EXP 175
110596: PUSH
110597: LD_VAR 0 7
110601: ARRAY
110602: PPUSH
110603: LD_INT 2
110605: PUSH
110606: LD_INT 30
110608: PUSH
110609: LD_INT 0
110611: PUSH
110612: EMPTY
110613: LIST
110614: LIST
110615: PUSH
110616: LD_INT 30
110618: PUSH
110619: LD_INT 1
110621: PUSH
110622: EMPTY
110623: LIST
110624: LIST
110625: PUSH
110626: EMPTY
110627: LIST
110628: LIST
110629: LIST
110630: PPUSH
110631: CALL_OW 72
110635: ST_TO_ADDR
// if not depot then
110636: LD_VAR 0 9
110640: NOT
110641: IFFALSE 110645
// continue ;
110643: GO 110463
// for j in depot do
110645: LD_ADDR_VAR 0 8
110649: PUSH
110650: LD_VAR 0 9
110654: PUSH
110655: FOR_IN
110656: IFFALSE 110750
// if GetDistUnitXY ( j , x , y ) < 30 then
110658: LD_VAR 0 8
110662: PPUSH
110663: LD_VAR 0 2
110667: PPUSH
110668: LD_VAR 0 3
110672: PPUSH
110673: CALL_OW 297
110677: PUSH
110678: LD_INT 30
110680: LESS
110681: IFFALSE 110748
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
110683: LD_ADDR_EXP 191
110687: PUSH
110688: LD_EXP 191
110692: PPUSH
110693: LD_VAR 0 7
110697: PUSH
110698: LD_EXP 191
110702: PUSH
110703: LD_VAR 0 7
110707: ARRAY
110708: PUSH
110709: LD_INT 1
110711: PLUS
110712: PUSH
110713: EMPTY
110714: LIST
110715: LIST
110716: PPUSH
110717: LD_VAR 0 4
110721: PUSH
110722: LD_VAR 0 2
110726: PUSH
110727: LD_VAR 0 3
110731: PUSH
110732: EMPTY
110733: LIST
110734: LIST
110735: LIST
110736: PPUSH
110737: CALL 24210 0 3
110741: ST_TO_ADDR
// exit ;
110742: POP
110743: POP
110744: POP
110745: POP
110746: GO 110756
// end ;
110748: GO 110655
110750: POP
110751: POP
// end ;
110752: GO 110463
110754: POP
110755: POP
// end ;
110756: LD_VAR 0 6
110760: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
110761: LD_INT 0
110763: PPUSH
110764: PPUSH
110765: PPUSH
110766: PPUSH
// if not mc_bases or not skirmish then
110767: LD_EXP 175
110771: NOT
110772: PUSH
110773: LD_EXP 173
110777: NOT
110778: OR
110779: IFFALSE 110783
// exit ;
110781: GO 111060
// side := GetSide ( lab ) ;
110783: LD_ADDR_VAR 0 4
110787: PUSH
110788: LD_VAR 0 2
110792: PPUSH
110793: CALL_OW 255
110797: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
110798: LD_VAR 0 4
110802: PUSH
110803: LD_EXP 201
110807: IN
110808: NOT
110809: PUSH
110810: LD_EXP 202
110814: NOT
110815: OR
110816: PUSH
110817: LD_EXP 175
110821: NOT
110822: OR
110823: IFFALSE 110827
// exit ;
110825: GO 111060
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
110827: LD_ADDR_EXP 202
110831: PUSH
110832: LD_EXP 202
110836: PPUSH
110837: LD_VAR 0 4
110841: PPUSH
110842: LD_EXP 202
110846: PUSH
110847: LD_VAR 0 4
110851: ARRAY
110852: PUSH
110853: LD_VAR 0 1
110857: DIFF
110858: PPUSH
110859: CALL_OW 1
110863: ST_TO_ADDR
// for i = 1 to mc_bases do
110864: LD_ADDR_VAR 0 5
110868: PUSH
110869: DOUBLE
110870: LD_INT 1
110872: DEC
110873: ST_TO_ADDR
110874: LD_EXP 175
110878: PUSH
110879: FOR_TO
110880: IFFALSE 111058
// begin if lab in mc_bases [ i ] then
110882: LD_VAR 0 2
110886: PUSH
110887: LD_EXP 175
110891: PUSH
110892: LD_VAR 0 5
110896: ARRAY
110897: IN
110898: IFFALSE 111056
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
110900: LD_VAR 0 1
110904: PUSH
110905: LD_INT 11
110907: PUSH
110908: LD_INT 4
110910: PUSH
110911: LD_INT 3
110913: PUSH
110914: LD_INT 2
110916: PUSH
110917: EMPTY
110918: LIST
110919: LIST
110920: LIST
110921: LIST
110922: IN
110923: PUSH
110924: LD_EXP 205
110928: PUSH
110929: LD_VAR 0 5
110933: ARRAY
110934: AND
110935: IFFALSE 111056
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
110937: LD_ADDR_VAR 0 6
110941: PUSH
110942: LD_EXP 205
110946: PUSH
110947: LD_VAR 0 5
110951: ARRAY
110952: PUSH
110953: LD_INT 1
110955: ARRAY
110956: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
110957: LD_ADDR_EXP 205
110961: PUSH
110962: LD_EXP 205
110966: PPUSH
110967: LD_VAR 0 5
110971: PPUSH
110972: EMPTY
110973: PPUSH
110974: CALL_OW 1
110978: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
110979: LD_VAR 0 6
110983: PPUSH
110984: LD_INT 0
110986: PPUSH
110987: CALL_OW 109
// ComExitBuilding ( tmp ) ;
110991: LD_VAR 0 6
110995: PPUSH
110996: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
111000: LD_ADDR_EXP 204
111004: PUSH
111005: LD_EXP 204
111009: PPUSH
111010: LD_VAR 0 5
111014: PPUSH
111015: LD_EXP 204
111019: PUSH
111020: LD_VAR 0 5
111024: ARRAY
111025: PPUSH
111026: LD_INT 1
111028: PPUSH
111029: LD_VAR 0 6
111033: PPUSH
111034: CALL_OW 2
111038: PPUSH
111039: CALL_OW 1
111043: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
111044: LD_VAR 0 5
111048: PPUSH
111049: LD_INT 112
111051: PPUSH
111052: CALL 87726 0 2
// end ; end ; end ;
111056: GO 110879
111058: POP
111059: POP
// end ;
111060: LD_VAR 0 3
111064: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
111065: LD_INT 0
111067: PPUSH
111068: PPUSH
111069: PPUSH
111070: PPUSH
111071: PPUSH
111072: PPUSH
111073: PPUSH
111074: PPUSH
// if not mc_bases or not skirmish then
111075: LD_EXP 175
111079: NOT
111080: PUSH
111081: LD_EXP 173
111085: NOT
111086: OR
111087: IFFALSE 111091
// exit ;
111089: GO 112462
// for i = 1 to mc_bases do
111091: LD_ADDR_VAR 0 3
111095: PUSH
111096: DOUBLE
111097: LD_INT 1
111099: DEC
111100: ST_TO_ADDR
111101: LD_EXP 175
111105: PUSH
111106: FOR_TO
111107: IFFALSE 112460
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
111109: LD_VAR 0 1
111113: PUSH
111114: LD_EXP 175
111118: PUSH
111119: LD_VAR 0 3
111123: ARRAY
111124: IN
111125: PUSH
111126: LD_VAR 0 1
111130: PUSH
111131: LD_EXP 182
111135: PUSH
111136: LD_VAR 0 3
111140: ARRAY
111141: IN
111142: OR
111143: PUSH
111144: LD_VAR 0 1
111148: PUSH
111149: LD_EXP 197
111153: PUSH
111154: LD_VAR 0 3
111158: ARRAY
111159: IN
111160: OR
111161: PUSH
111162: LD_VAR 0 1
111166: PUSH
111167: LD_EXP 194
111171: PUSH
111172: LD_VAR 0 3
111176: ARRAY
111177: IN
111178: OR
111179: PUSH
111180: LD_VAR 0 1
111184: PUSH
111185: LD_EXP 204
111189: PUSH
111190: LD_VAR 0 3
111194: ARRAY
111195: IN
111196: OR
111197: PUSH
111198: LD_VAR 0 1
111202: PUSH
111203: LD_EXP 205
111207: PUSH
111208: LD_VAR 0 3
111212: ARRAY
111213: IN
111214: OR
111215: IFFALSE 112458
// begin if un in mc_ape [ i ] then
111217: LD_VAR 0 1
111221: PUSH
111222: LD_EXP 204
111226: PUSH
111227: LD_VAR 0 3
111231: ARRAY
111232: IN
111233: IFFALSE 111272
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
111235: LD_ADDR_EXP 204
111239: PUSH
111240: LD_EXP 204
111244: PPUSH
111245: LD_VAR 0 3
111249: PPUSH
111250: LD_EXP 204
111254: PUSH
111255: LD_VAR 0 3
111259: ARRAY
111260: PUSH
111261: LD_VAR 0 1
111265: DIFF
111266: PPUSH
111267: CALL_OW 1
111271: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
111272: LD_VAR 0 1
111276: PUSH
111277: LD_EXP 205
111281: PUSH
111282: LD_VAR 0 3
111286: ARRAY
111287: IN
111288: IFFALSE 111312
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
111290: LD_ADDR_EXP 205
111294: PUSH
111295: LD_EXP 205
111299: PPUSH
111300: LD_VAR 0 3
111304: PPUSH
111305: EMPTY
111306: PPUSH
111307: CALL_OW 1
111311: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
111312: LD_VAR 0 1
111316: PPUSH
111317: CALL_OW 247
111321: PUSH
111322: LD_INT 2
111324: EQUAL
111325: PUSH
111326: LD_VAR 0 1
111330: PPUSH
111331: CALL_OW 110
111335: PUSH
111336: LD_INT 20
111338: EQUAL
111339: PUSH
111340: LD_VAR 0 1
111344: PUSH
111345: LD_EXP 197
111349: PUSH
111350: LD_VAR 0 3
111354: ARRAY
111355: IN
111356: OR
111357: PUSH
111358: LD_VAR 0 1
111362: PPUSH
111363: CALL_OW 264
111367: PUSH
111368: LD_INT 12
111370: PUSH
111371: LD_INT 51
111373: PUSH
111374: LD_EXP 155
111378: PUSH
111379: LD_INT 32
111381: PUSH
111382: LD_INT 13
111384: PUSH
111385: LD_INT 52
111387: PUSH
111388: LD_INT 31
111390: PUSH
111391: EMPTY
111392: LIST
111393: LIST
111394: LIST
111395: LIST
111396: LIST
111397: LIST
111398: LIST
111399: IN
111400: OR
111401: AND
111402: IFFALSE 111710
// begin if un in mc_defender [ i ] then
111404: LD_VAR 0 1
111408: PUSH
111409: LD_EXP 197
111413: PUSH
111414: LD_VAR 0 3
111418: ARRAY
111419: IN
111420: IFFALSE 111459
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
111422: LD_ADDR_EXP 197
111426: PUSH
111427: LD_EXP 197
111431: PPUSH
111432: LD_VAR 0 3
111436: PPUSH
111437: LD_EXP 197
111441: PUSH
111442: LD_VAR 0 3
111446: ARRAY
111447: PUSH
111448: LD_VAR 0 1
111452: DIFF
111453: PPUSH
111454: CALL_OW 1
111458: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
111459: LD_ADDR_VAR 0 8
111463: PUSH
111464: LD_VAR 0 3
111468: PPUSH
111469: LD_INT 3
111471: PPUSH
111472: CALL 108100 0 2
111476: ST_TO_ADDR
// if fac then
111477: LD_VAR 0 8
111481: IFFALSE 111710
// begin for j in fac do
111483: LD_ADDR_VAR 0 4
111487: PUSH
111488: LD_VAR 0 8
111492: PUSH
111493: FOR_IN
111494: IFFALSE 111708
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
111496: LD_ADDR_VAR 0 9
111500: PUSH
111501: LD_VAR 0 8
111505: PPUSH
111506: LD_VAR 0 1
111510: PPUSH
111511: CALL_OW 265
111515: PPUSH
111516: LD_VAR 0 1
111520: PPUSH
111521: CALL_OW 262
111525: PPUSH
111526: LD_VAR 0 1
111530: PPUSH
111531: CALL_OW 263
111535: PPUSH
111536: LD_VAR 0 1
111540: PPUSH
111541: CALL_OW 264
111545: PPUSH
111546: CALL 21706 0 5
111550: ST_TO_ADDR
// if components then
111551: LD_VAR 0 9
111555: IFFALSE 111706
// begin if GetWeapon ( un ) = ar_control_tower then
111557: LD_VAR 0 1
111561: PPUSH
111562: CALL_OW 264
111566: PUSH
111567: LD_INT 31
111569: EQUAL
111570: IFFALSE 111687
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
111572: LD_VAR 0 1
111576: PPUSH
111577: CALL_OW 311
111581: PPUSH
111582: LD_INT 0
111584: PPUSH
111585: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
111589: LD_ADDR_EXP 215
111593: PUSH
111594: LD_EXP 215
111598: PPUSH
111599: LD_VAR 0 3
111603: PPUSH
111604: LD_EXP 215
111608: PUSH
111609: LD_VAR 0 3
111613: ARRAY
111614: PUSH
111615: LD_VAR 0 1
111619: PPUSH
111620: CALL_OW 311
111624: DIFF
111625: PPUSH
111626: CALL_OW 1
111630: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
111631: LD_ADDR_VAR 0 7
111635: PUSH
111636: LD_EXP 196
111640: PUSH
111641: LD_VAR 0 3
111645: ARRAY
111646: PPUSH
111647: LD_INT 1
111649: PPUSH
111650: LD_VAR 0 9
111654: PPUSH
111655: CALL_OW 2
111659: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
111660: LD_ADDR_EXP 196
111664: PUSH
111665: LD_EXP 196
111669: PPUSH
111670: LD_VAR 0 3
111674: PPUSH
111675: LD_VAR 0 7
111679: PPUSH
111680: CALL_OW 1
111684: ST_TO_ADDR
// end else
111685: GO 111704
// MC_InsertProduceList ( i , [ components ] ) ;
111687: LD_VAR 0 3
111691: PPUSH
111692: LD_VAR 0 9
111696: PUSH
111697: EMPTY
111698: LIST
111699: PPUSH
111700: CALL 107645 0 2
// break ;
111704: GO 111708
// end ; end ;
111706: GO 111493
111708: POP
111709: POP
// end ; end ; if GetType ( un ) = unit_building then
111710: LD_VAR 0 1
111714: PPUSH
111715: CALL_OW 247
111719: PUSH
111720: LD_INT 3
111722: EQUAL
111723: IFFALSE 112126
// begin btype := GetBType ( un ) ;
111725: LD_ADDR_VAR 0 5
111729: PUSH
111730: LD_VAR 0 1
111734: PPUSH
111735: CALL_OW 266
111739: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
111740: LD_VAR 0 5
111744: PUSH
111745: LD_INT 29
111747: PUSH
111748: LD_INT 30
111750: PUSH
111751: EMPTY
111752: LIST
111753: LIST
111754: IN
111755: IFFALSE 111828
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
111757: LD_VAR 0 1
111761: PPUSH
111762: CALL_OW 250
111766: PPUSH
111767: LD_VAR 0 1
111771: PPUSH
111772: CALL_OW 251
111776: PPUSH
111777: LD_VAR 0 1
111781: PPUSH
111782: CALL_OW 255
111786: PPUSH
111787: CALL_OW 440
111791: NOT
111792: IFFALSE 111828
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
111794: LD_VAR 0 1
111798: PPUSH
111799: CALL_OW 250
111803: PPUSH
111804: LD_VAR 0 1
111808: PPUSH
111809: CALL_OW 251
111813: PPUSH
111814: LD_VAR 0 1
111818: PPUSH
111819: CALL_OW 255
111823: PPUSH
111824: CALL_OW 441
// end ; if btype = b_warehouse then
111828: LD_VAR 0 5
111832: PUSH
111833: LD_INT 1
111835: EQUAL
111836: IFFALSE 111854
// begin btype := b_depot ;
111838: LD_ADDR_VAR 0 5
111842: PUSH
111843: LD_INT 0
111845: ST_TO_ADDR
// pos := 1 ;
111846: LD_ADDR_VAR 0 6
111850: PUSH
111851: LD_INT 1
111853: ST_TO_ADDR
// end ; if btype = b_factory then
111854: LD_VAR 0 5
111858: PUSH
111859: LD_INT 3
111861: EQUAL
111862: IFFALSE 111880
// begin btype := b_workshop ;
111864: LD_ADDR_VAR 0 5
111868: PUSH
111869: LD_INT 2
111871: ST_TO_ADDR
// pos := 1 ;
111872: LD_ADDR_VAR 0 6
111876: PUSH
111877: LD_INT 1
111879: ST_TO_ADDR
// end ; if btype = b_barracks then
111880: LD_VAR 0 5
111884: PUSH
111885: LD_INT 5
111887: EQUAL
111888: IFFALSE 111898
// btype := b_armoury ;
111890: LD_ADDR_VAR 0 5
111894: PUSH
111895: LD_INT 4
111897: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
111898: LD_VAR 0 5
111902: PUSH
111903: LD_INT 7
111905: PUSH
111906: LD_INT 8
111908: PUSH
111909: EMPTY
111910: LIST
111911: LIST
111912: IN
111913: IFFALSE 111923
// btype := b_lab ;
111915: LD_ADDR_VAR 0 5
111919: PUSH
111920: LD_INT 6
111922: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
111923: LD_ADDR_EXP 180
111927: PUSH
111928: LD_EXP 180
111932: PPUSH
111933: LD_VAR 0 3
111937: PUSH
111938: LD_EXP 180
111942: PUSH
111943: LD_VAR 0 3
111947: ARRAY
111948: PUSH
111949: LD_INT 1
111951: PLUS
111952: PUSH
111953: EMPTY
111954: LIST
111955: LIST
111956: PPUSH
111957: LD_VAR 0 5
111961: PUSH
111962: LD_VAR 0 1
111966: PPUSH
111967: CALL_OW 250
111971: PUSH
111972: LD_VAR 0 1
111976: PPUSH
111977: CALL_OW 251
111981: PUSH
111982: LD_VAR 0 1
111986: PPUSH
111987: CALL_OW 254
111991: PUSH
111992: EMPTY
111993: LIST
111994: LIST
111995: LIST
111996: LIST
111997: PPUSH
111998: CALL 24210 0 3
112002: ST_TO_ADDR
// if pos = 1 then
112003: LD_VAR 0 6
112007: PUSH
112008: LD_INT 1
112010: EQUAL
112011: IFFALSE 112126
// begin tmp := mc_build_list [ i ] ;
112013: LD_ADDR_VAR 0 7
112017: PUSH
112018: LD_EXP 180
112022: PUSH
112023: LD_VAR 0 3
112027: ARRAY
112028: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
112029: LD_VAR 0 7
112033: PPUSH
112034: LD_INT 2
112036: PUSH
112037: LD_INT 30
112039: PUSH
112040: LD_INT 0
112042: PUSH
112043: EMPTY
112044: LIST
112045: LIST
112046: PUSH
112047: LD_INT 30
112049: PUSH
112050: LD_INT 1
112052: PUSH
112053: EMPTY
112054: LIST
112055: LIST
112056: PUSH
112057: EMPTY
112058: LIST
112059: LIST
112060: LIST
112061: PPUSH
112062: CALL_OW 72
112066: IFFALSE 112076
// pos := 2 ;
112068: LD_ADDR_VAR 0 6
112072: PUSH
112073: LD_INT 2
112075: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
112076: LD_ADDR_VAR 0 7
112080: PUSH
112081: LD_VAR 0 7
112085: PPUSH
112086: LD_VAR 0 6
112090: PPUSH
112091: LD_VAR 0 7
112095: PPUSH
112096: CALL 24536 0 3
112100: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
112101: LD_ADDR_EXP 180
112105: PUSH
112106: LD_EXP 180
112110: PPUSH
112111: LD_VAR 0 3
112115: PPUSH
112116: LD_VAR 0 7
112120: PPUSH
112121: CALL_OW 1
112125: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
112126: LD_VAR 0 1
112130: PUSH
112131: LD_EXP 175
112135: PUSH
112136: LD_VAR 0 3
112140: ARRAY
112141: IN
112142: IFFALSE 112181
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
112144: LD_ADDR_EXP 175
112148: PUSH
112149: LD_EXP 175
112153: PPUSH
112154: LD_VAR 0 3
112158: PPUSH
112159: LD_EXP 175
112163: PUSH
112164: LD_VAR 0 3
112168: ARRAY
112169: PUSH
112170: LD_VAR 0 1
112174: DIFF
112175: PPUSH
112176: CALL_OW 1
112180: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
112181: LD_VAR 0 1
112185: PUSH
112186: LD_EXP 182
112190: PUSH
112191: LD_VAR 0 3
112195: ARRAY
112196: IN
112197: IFFALSE 112236
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
112199: LD_ADDR_EXP 182
112203: PUSH
112204: LD_EXP 182
112208: PPUSH
112209: LD_VAR 0 3
112213: PPUSH
112214: LD_EXP 182
112218: PUSH
112219: LD_VAR 0 3
112223: ARRAY
112224: PUSH
112225: LD_VAR 0 1
112229: DIFF
112230: PPUSH
112231: CALL_OW 1
112235: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
112236: LD_VAR 0 1
112240: PUSH
112241: LD_EXP 194
112245: PUSH
112246: LD_VAR 0 3
112250: ARRAY
112251: IN
112252: IFFALSE 112291
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
112254: LD_ADDR_EXP 194
112258: PUSH
112259: LD_EXP 194
112263: PPUSH
112264: LD_VAR 0 3
112268: PPUSH
112269: LD_EXP 194
112273: PUSH
112274: LD_VAR 0 3
112278: ARRAY
112279: PUSH
112280: LD_VAR 0 1
112284: DIFF
112285: PPUSH
112286: CALL_OW 1
112290: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
112291: LD_VAR 0 1
112295: PUSH
112296: LD_EXP 197
112300: PUSH
112301: LD_VAR 0 3
112305: ARRAY
112306: IN
112307: IFFALSE 112346
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
112309: LD_ADDR_EXP 197
112313: PUSH
112314: LD_EXP 197
112318: PPUSH
112319: LD_VAR 0 3
112323: PPUSH
112324: LD_EXP 197
112328: PUSH
112329: LD_VAR 0 3
112333: ARRAY
112334: PUSH
112335: LD_VAR 0 1
112339: DIFF
112340: PPUSH
112341: CALL_OW 1
112345: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
112346: LD_VAR 0 1
112350: PUSH
112351: LD_EXP 184
112355: PUSH
112356: LD_VAR 0 3
112360: ARRAY
112361: IN
112362: IFFALSE 112401
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
112364: LD_ADDR_EXP 184
112368: PUSH
112369: LD_EXP 184
112373: PPUSH
112374: LD_VAR 0 3
112378: PPUSH
112379: LD_EXP 184
112383: PUSH
112384: LD_VAR 0 3
112388: ARRAY
112389: PUSH
112390: LD_VAR 0 1
112394: DIFF
112395: PPUSH
112396: CALL_OW 1
112400: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
112401: LD_VAR 0 1
112405: PUSH
112406: LD_EXP 183
112410: PUSH
112411: LD_VAR 0 3
112415: ARRAY
112416: IN
112417: IFFALSE 112456
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
112419: LD_ADDR_EXP 183
112423: PUSH
112424: LD_EXP 183
112428: PPUSH
112429: LD_VAR 0 3
112433: PPUSH
112434: LD_EXP 183
112438: PUSH
112439: LD_VAR 0 3
112443: ARRAY
112444: PUSH
112445: LD_VAR 0 1
112449: DIFF
112450: PPUSH
112451: CALL_OW 1
112455: ST_TO_ADDR
// end ; break ;
112456: GO 112460
// end ;
112458: GO 111106
112460: POP
112461: POP
// end ;
112462: LD_VAR 0 2
112466: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
112467: LD_INT 0
112469: PPUSH
112470: PPUSH
112471: PPUSH
// if not mc_bases or not skirmish then
112472: LD_EXP 175
112476: NOT
112477: PUSH
112478: LD_EXP 173
112482: NOT
112483: OR
112484: IFFALSE 112488
// exit ;
112486: GO 112703
// for i = 1 to mc_bases do
112488: LD_ADDR_VAR 0 3
112492: PUSH
112493: DOUBLE
112494: LD_INT 1
112496: DEC
112497: ST_TO_ADDR
112498: LD_EXP 175
112502: PUSH
112503: FOR_TO
112504: IFFALSE 112701
// begin if building in mc_construct_list [ i ] then
112506: LD_VAR 0 1
112510: PUSH
112511: LD_EXP 182
112515: PUSH
112516: LD_VAR 0 3
112520: ARRAY
112521: IN
112522: IFFALSE 112699
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
112524: LD_ADDR_EXP 182
112528: PUSH
112529: LD_EXP 182
112533: PPUSH
112534: LD_VAR 0 3
112538: PPUSH
112539: LD_EXP 182
112543: PUSH
112544: LD_VAR 0 3
112548: ARRAY
112549: PUSH
112550: LD_VAR 0 1
112554: DIFF
112555: PPUSH
112556: CALL_OW 1
112560: ST_TO_ADDR
// if building in mc_lab [ i ] then
112561: LD_VAR 0 1
112565: PUSH
112566: LD_EXP 208
112570: PUSH
112571: LD_VAR 0 3
112575: ARRAY
112576: IN
112577: IFFALSE 112632
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
112579: LD_ADDR_EXP 209
112583: PUSH
112584: LD_EXP 209
112588: PPUSH
112589: LD_VAR 0 3
112593: PPUSH
112594: LD_EXP 209
112598: PUSH
112599: LD_VAR 0 3
112603: ARRAY
112604: PPUSH
112605: LD_INT 1
112607: PPUSH
112608: LD_EXP 209
112612: PUSH
112613: LD_VAR 0 3
112617: ARRAY
112618: PPUSH
112619: LD_INT 0
112621: PPUSH
112622: CALL 23628 0 4
112626: PPUSH
112627: CALL_OW 1
112631: ST_TO_ADDR
// if not building in mc_bases [ i ] then
112632: LD_VAR 0 1
112636: PUSH
112637: LD_EXP 175
112641: PUSH
112642: LD_VAR 0 3
112646: ARRAY
112647: IN
112648: NOT
112649: IFFALSE 112695
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
112651: LD_ADDR_EXP 175
112655: PUSH
112656: LD_EXP 175
112660: PPUSH
112661: LD_VAR 0 3
112665: PUSH
112666: LD_EXP 175
112670: PUSH
112671: LD_VAR 0 3
112675: ARRAY
112676: PUSH
112677: LD_INT 1
112679: PLUS
112680: PUSH
112681: EMPTY
112682: LIST
112683: LIST
112684: PPUSH
112685: LD_VAR 0 1
112689: PPUSH
112690: CALL 24210 0 3
112694: ST_TO_ADDR
// exit ;
112695: POP
112696: POP
112697: GO 112703
// end ; end ;
112699: GO 112503
112701: POP
112702: POP
// end ;
112703: LD_VAR 0 2
112707: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
112708: LD_INT 0
112710: PPUSH
112711: PPUSH
112712: PPUSH
112713: PPUSH
112714: PPUSH
112715: PPUSH
112716: PPUSH
// if not mc_bases or not skirmish then
112717: LD_EXP 175
112721: NOT
112722: PUSH
112723: LD_EXP 173
112727: NOT
112728: OR
112729: IFFALSE 112733
// exit ;
112731: GO 113394
// for i = 1 to mc_bases do
112733: LD_ADDR_VAR 0 3
112737: PUSH
112738: DOUBLE
112739: LD_INT 1
112741: DEC
112742: ST_TO_ADDR
112743: LD_EXP 175
112747: PUSH
112748: FOR_TO
112749: IFFALSE 113392
// begin if building in mc_construct_list [ i ] then
112751: LD_VAR 0 1
112755: PUSH
112756: LD_EXP 182
112760: PUSH
112761: LD_VAR 0 3
112765: ARRAY
112766: IN
112767: IFFALSE 113390
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
112769: LD_ADDR_EXP 182
112773: PUSH
112774: LD_EXP 182
112778: PPUSH
112779: LD_VAR 0 3
112783: PPUSH
112784: LD_EXP 182
112788: PUSH
112789: LD_VAR 0 3
112793: ARRAY
112794: PUSH
112795: LD_VAR 0 1
112799: DIFF
112800: PPUSH
112801: CALL_OW 1
112805: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
112806: LD_ADDR_EXP 175
112810: PUSH
112811: LD_EXP 175
112815: PPUSH
112816: LD_VAR 0 3
112820: PUSH
112821: LD_EXP 175
112825: PUSH
112826: LD_VAR 0 3
112830: ARRAY
112831: PUSH
112832: LD_INT 1
112834: PLUS
112835: PUSH
112836: EMPTY
112837: LIST
112838: LIST
112839: PPUSH
112840: LD_VAR 0 1
112844: PPUSH
112845: CALL 24210 0 3
112849: ST_TO_ADDR
// btype := GetBType ( building ) ;
112850: LD_ADDR_VAR 0 5
112854: PUSH
112855: LD_VAR 0 1
112859: PPUSH
112860: CALL_OW 266
112864: ST_TO_ADDR
// side := GetSide ( building ) ;
112865: LD_ADDR_VAR 0 8
112869: PUSH
112870: LD_VAR 0 1
112874: PPUSH
112875: CALL_OW 255
112879: ST_TO_ADDR
// if btype = b_lab then
112880: LD_VAR 0 5
112884: PUSH
112885: LD_INT 6
112887: EQUAL
112888: IFFALSE 112938
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
112890: LD_ADDR_EXP 208
112894: PUSH
112895: LD_EXP 208
112899: PPUSH
112900: LD_VAR 0 3
112904: PUSH
112905: LD_EXP 208
112909: PUSH
112910: LD_VAR 0 3
112914: ARRAY
112915: PUSH
112916: LD_INT 1
112918: PLUS
112919: PUSH
112920: EMPTY
112921: LIST
112922: LIST
112923: PPUSH
112924: LD_VAR 0 1
112928: PPUSH
112929: CALL 24210 0 3
112933: ST_TO_ADDR
// exit ;
112934: POP
112935: POP
112936: GO 113394
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
112938: LD_VAR 0 5
112942: PUSH
112943: LD_INT 0
112945: PUSH
112946: LD_INT 2
112948: PUSH
112949: LD_INT 4
112951: PUSH
112952: EMPTY
112953: LIST
112954: LIST
112955: LIST
112956: IN
112957: IFFALSE 113081
// begin if btype = b_armoury then
112959: LD_VAR 0 5
112963: PUSH
112964: LD_INT 4
112966: EQUAL
112967: IFFALSE 112977
// btype := b_barracks ;
112969: LD_ADDR_VAR 0 5
112973: PUSH
112974: LD_INT 5
112976: ST_TO_ADDR
// if btype = b_depot then
112977: LD_VAR 0 5
112981: PUSH
112982: LD_INT 0
112984: EQUAL
112985: IFFALSE 112995
// btype := b_warehouse ;
112987: LD_ADDR_VAR 0 5
112991: PUSH
112992: LD_INT 1
112994: ST_TO_ADDR
// if btype = b_workshop then
112995: LD_VAR 0 5
112999: PUSH
113000: LD_INT 2
113002: EQUAL
113003: IFFALSE 113013
// btype := b_factory ;
113005: LD_ADDR_VAR 0 5
113009: PUSH
113010: LD_INT 3
113012: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
113013: LD_VAR 0 5
113017: PPUSH
113018: LD_VAR 0 8
113022: PPUSH
113023: CALL_OW 323
113027: PUSH
113028: LD_INT 1
113030: EQUAL
113031: IFFALSE 113077
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
113033: LD_ADDR_EXP 207
113037: PUSH
113038: LD_EXP 207
113042: PPUSH
113043: LD_VAR 0 3
113047: PUSH
113048: LD_EXP 207
113052: PUSH
113053: LD_VAR 0 3
113057: ARRAY
113058: PUSH
113059: LD_INT 1
113061: PLUS
113062: PUSH
113063: EMPTY
113064: LIST
113065: LIST
113066: PPUSH
113067: LD_VAR 0 1
113071: PPUSH
113072: CALL 24210 0 3
113076: ST_TO_ADDR
// exit ;
113077: POP
113078: POP
113079: GO 113394
// end ; if btype in [ b_bunker , b_turret ] then
113081: LD_VAR 0 5
113085: PUSH
113086: LD_INT 32
113088: PUSH
113089: LD_INT 33
113091: PUSH
113092: EMPTY
113093: LIST
113094: LIST
113095: IN
113096: IFFALSE 113386
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
113098: LD_ADDR_EXP 183
113102: PUSH
113103: LD_EXP 183
113107: PPUSH
113108: LD_VAR 0 3
113112: PUSH
113113: LD_EXP 183
113117: PUSH
113118: LD_VAR 0 3
113122: ARRAY
113123: PUSH
113124: LD_INT 1
113126: PLUS
113127: PUSH
113128: EMPTY
113129: LIST
113130: LIST
113131: PPUSH
113132: LD_VAR 0 1
113136: PPUSH
113137: CALL 24210 0 3
113141: ST_TO_ADDR
// if btype = b_bunker then
113142: LD_VAR 0 5
113146: PUSH
113147: LD_INT 32
113149: EQUAL
113150: IFFALSE 113386
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
113152: LD_ADDR_EXP 184
113156: PUSH
113157: LD_EXP 184
113161: PPUSH
113162: LD_VAR 0 3
113166: PUSH
113167: LD_EXP 184
113171: PUSH
113172: LD_VAR 0 3
113176: ARRAY
113177: PUSH
113178: LD_INT 1
113180: PLUS
113181: PUSH
113182: EMPTY
113183: LIST
113184: LIST
113185: PPUSH
113186: LD_VAR 0 1
113190: PPUSH
113191: CALL 24210 0 3
113195: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
113196: LD_ADDR_VAR 0 6
113200: PUSH
113201: LD_EXP 175
113205: PUSH
113206: LD_VAR 0 3
113210: ARRAY
113211: PPUSH
113212: LD_INT 25
113214: PUSH
113215: LD_INT 1
113217: PUSH
113218: EMPTY
113219: LIST
113220: LIST
113221: PUSH
113222: LD_INT 3
113224: PUSH
113225: LD_INT 54
113227: PUSH
113228: EMPTY
113229: LIST
113230: PUSH
113231: EMPTY
113232: LIST
113233: LIST
113234: PUSH
113235: EMPTY
113236: LIST
113237: LIST
113238: PPUSH
113239: CALL_OW 72
113243: ST_TO_ADDR
// if tmp then
113244: LD_VAR 0 6
113248: IFFALSE 113254
// exit ;
113250: POP
113251: POP
113252: GO 113394
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
113254: LD_ADDR_VAR 0 6
113258: PUSH
113259: LD_EXP 175
113263: PUSH
113264: LD_VAR 0 3
113268: ARRAY
113269: PPUSH
113270: LD_INT 2
113272: PUSH
113273: LD_INT 30
113275: PUSH
113276: LD_INT 4
113278: PUSH
113279: EMPTY
113280: LIST
113281: LIST
113282: PUSH
113283: LD_INT 30
113285: PUSH
113286: LD_INT 5
113288: PUSH
113289: EMPTY
113290: LIST
113291: LIST
113292: PUSH
113293: EMPTY
113294: LIST
113295: LIST
113296: LIST
113297: PPUSH
113298: CALL_OW 72
113302: ST_TO_ADDR
// if not tmp then
113303: LD_VAR 0 6
113307: NOT
113308: IFFALSE 113314
// exit ;
113310: POP
113311: POP
113312: GO 113394
// for j in tmp do
113314: LD_ADDR_VAR 0 4
113318: PUSH
113319: LD_VAR 0 6
113323: PUSH
113324: FOR_IN
113325: IFFALSE 113384
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
113327: LD_ADDR_VAR 0 7
113331: PUSH
113332: LD_VAR 0 4
113336: PPUSH
113337: CALL_OW 313
113341: PPUSH
113342: LD_INT 25
113344: PUSH
113345: LD_INT 1
113347: PUSH
113348: EMPTY
113349: LIST
113350: LIST
113351: PPUSH
113352: CALL_OW 72
113356: ST_TO_ADDR
// if units then
113357: LD_VAR 0 7
113361: IFFALSE 113382
// begin ComExitBuilding ( units [ 1 ] ) ;
113363: LD_VAR 0 7
113367: PUSH
113368: LD_INT 1
113370: ARRAY
113371: PPUSH
113372: CALL_OW 122
// exit ;
113376: POP
113377: POP
113378: POP
113379: POP
113380: GO 113394
// end ; end ;
113382: GO 113324
113384: POP
113385: POP
// end ; end ; exit ;
113386: POP
113387: POP
113388: GO 113394
// end ; end ;
113390: GO 112748
113392: POP
113393: POP
// end ;
113394: LD_VAR 0 2
113398: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
113399: LD_INT 0
113401: PPUSH
113402: PPUSH
113403: PPUSH
113404: PPUSH
113405: PPUSH
113406: PPUSH
113407: PPUSH
// if not mc_bases or not skirmish then
113408: LD_EXP 175
113412: NOT
113413: PUSH
113414: LD_EXP 173
113418: NOT
113419: OR
113420: IFFALSE 113424
// exit ;
113422: GO 113689
// btype := GetBType ( building ) ;
113424: LD_ADDR_VAR 0 6
113428: PUSH
113429: LD_VAR 0 1
113433: PPUSH
113434: CALL_OW 266
113438: ST_TO_ADDR
// x := GetX ( building ) ;
113439: LD_ADDR_VAR 0 7
113443: PUSH
113444: LD_VAR 0 1
113448: PPUSH
113449: CALL_OW 250
113453: ST_TO_ADDR
// y := GetY ( building ) ;
113454: LD_ADDR_VAR 0 8
113458: PUSH
113459: LD_VAR 0 1
113463: PPUSH
113464: CALL_OW 251
113468: ST_TO_ADDR
// d := GetDir ( building ) ;
113469: LD_ADDR_VAR 0 9
113473: PUSH
113474: LD_VAR 0 1
113478: PPUSH
113479: CALL_OW 254
113483: ST_TO_ADDR
// for i = 1 to mc_bases do
113484: LD_ADDR_VAR 0 4
113488: PUSH
113489: DOUBLE
113490: LD_INT 1
113492: DEC
113493: ST_TO_ADDR
113494: LD_EXP 175
113498: PUSH
113499: FOR_TO
113500: IFFALSE 113687
// begin if not mc_build_list [ i ] then
113502: LD_EXP 180
113506: PUSH
113507: LD_VAR 0 4
113511: ARRAY
113512: NOT
113513: IFFALSE 113517
// continue ;
113515: GO 113499
// for j := 1 to mc_build_list [ i ] do
113517: LD_ADDR_VAR 0 5
113521: PUSH
113522: DOUBLE
113523: LD_INT 1
113525: DEC
113526: ST_TO_ADDR
113527: LD_EXP 180
113531: PUSH
113532: LD_VAR 0 4
113536: ARRAY
113537: PUSH
113538: FOR_TO
113539: IFFALSE 113683
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ j ] ) then
113541: LD_VAR 0 6
113545: PUSH
113546: LD_VAR 0 7
113550: PUSH
113551: LD_VAR 0 8
113555: PUSH
113556: LD_VAR 0 9
113560: PUSH
113561: EMPTY
113562: LIST
113563: LIST
113564: LIST
113565: LIST
113566: PPUSH
113567: LD_EXP 180
113571: PUSH
113572: LD_VAR 0 4
113576: ARRAY
113577: PUSH
113578: LD_VAR 0 5
113582: ARRAY
113583: PPUSH
113584: CALL 30392 0 2
113588: IFFALSE 113681
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , j ) ) ;
113590: LD_ADDR_EXP 180
113594: PUSH
113595: LD_EXP 180
113599: PPUSH
113600: LD_VAR 0 4
113604: PPUSH
113605: LD_EXP 180
113609: PUSH
113610: LD_VAR 0 4
113614: ARRAY
113615: PPUSH
113616: LD_VAR 0 5
113620: PPUSH
113621: CALL_OW 3
113625: PPUSH
113626: CALL_OW 1
113630: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
113631: LD_ADDR_EXP 182
113635: PUSH
113636: LD_EXP 182
113640: PPUSH
113641: LD_VAR 0 4
113645: PUSH
113646: LD_EXP 182
113650: PUSH
113651: LD_VAR 0 4
113655: ARRAY
113656: PUSH
113657: LD_INT 1
113659: PLUS
113660: PUSH
113661: EMPTY
113662: LIST
113663: LIST
113664: PPUSH
113665: LD_VAR 0 1
113669: PPUSH
113670: CALL 24210 0 3
113674: ST_TO_ADDR
// exit ;
113675: POP
113676: POP
113677: POP
113678: POP
113679: GO 113689
// end ;
113681: GO 113538
113683: POP
113684: POP
// end ;
113685: GO 113499
113687: POP
113688: POP
// end ;
113689: LD_VAR 0 3
113693: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
113694: LD_INT 0
113696: PPUSH
113697: PPUSH
113698: PPUSH
// if not mc_bases or not skirmish then
113699: LD_EXP 175
113703: NOT
113704: PUSH
113705: LD_EXP 173
113709: NOT
113710: OR
113711: IFFALSE 113715
// exit ;
113713: GO 113905
// for i = 1 to mc_bases do
113715: LD_ADDR_VAR 0 4
113719: PUSH
113720: DOUBLE
113721: LD_INT 1
113723: DEC
113724: ST_TO_ADDR
113725: LD_EXP 175
113729: PUSH
113730: FOR_TO
113731: IFFALSE 113818
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
113733: LD_VAR 0 1
113737: PUSH
113738: LD_EXP 183
113742: PUSH
113743: LD_VAR 0 4
113747: ARRAY
113748: IN
113749: PUSH
113750: LD_VAR 0 1
113754: PUSH
113755: LD_EXP 184
113759: PUSH
113760: LD_VAR 0 4
113764: ARRAY
113765: IN
113766: NOT
113767: AND
113768: IFFALSE 113816
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
113770: LD_ADDR_EXP 184
113774: PUSH
113775: LD_EXP 184
113779: PPUSH
113780: LD_VAR 0 4
113784: PUSH
113785: LD_EXP 184
113789: PUSH
113790: LD_VAR 0 4
113794: ARRAY
113795: PUSH
113796: LD_INT 1
113798: PLUS
113799: PUSH
113800: EMPTY
113801: LIST
113802: LIST
113803: PPUSH
113804: LD_VAR 0 1
113808: PPUSH
113809: CALL 24210 0 3
113813: ST_TO_ADDR
// break ;
113814: GO 113818
// end ; end ;
113816: GO 113730
113818: POP
113819: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
113820: LD_VAR 0 1
113824: PPUSH
113825: CALL_OW 257
113829: PUSH
113830: LD_EXP 201
113834: IN
113835: PUSH
113836: LD_VAR 0 1
113840: PPUSH
113841: CALL_OW 266
113845: PUSH
113846: LD_INT 5
113848: EQUAL
113849: AND
113850: PUSH
113851: LD_VAR 0 2
113855: PPUSH
113856: CALL_OW 110
113860: PUSH
113861: LD_INT 18
113863: NONEQUAL
113864: AND
113865: IFFALSE 113905
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
113867: LD_VAR 0 2
113871: PPUSH
113872: CALL_OW 257
113876: PUSH
113877: LD_INT 5
113879: PUSH
113880: LD_INT 8
113882: PUSH
113883: LD_INT 9
113885: PUSH
113886: EMPTY
113887: LIST
113888: LIST
113889: LIST
113890: IN
113891: IFFALSE 113905
// SetClass ( unit , 1 ) ;
113893: LD_VAR 0 2
113897: PPUSH
113898: LD_INT 1
113900: PPUSH
113901: CALL_OW 336
// end ;
113905: LD_VAR 0 3
113909: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
113910: LD_INT 0
113912: PPUSH
113913: PPUSH
// if not mc_bases or not skirmish then
113914: LD_EXP 175
113918: NOT
113919: PUSH
113920: LD_EXP 173
113924: NOT
113925: OR
113926: IFFALSE 113930
// exit ;
113928: GO 114046
// if GetLives ( abandoned_vehicle ) > 250 then
113930: LD_VAR 0 2
113934: PPUSH
113935: CALL_OW 256
113939: PUSH
113940: LD_INT 250
113942: GREATER
113943: IFFALSE 113947
// exit ;
113945: GO 114046
// for i = 1 to mc_bases do
113947: LD_ADDR_VAR 0 6
113951: PUSH
113952: DOUBLE
113953: LD_INT 1
113955: DEC
113956: ST_TO_ADDR
113957: LD_EXP 175
113961: PUSH
113962: FOR_TO
113963: IFFALSE 114044
// begin if driver in mc_bases [ i ] then
113965: LD_VAR 0 1
113969: PUSH
113970: LD_EXP 175
113974: PUSH
113975: LD_VAR 0 6
113979: ARRAY
113980: IN
113981: IFFALSE 114042
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
113983: LD_VAR 0 1
113987: PPUSH
113988: LD_EXP 175
113992: PUSH
113993: LD_VAR 0 6
113997: ARRAY
113998: PPUSH
113999: LD_INT 2
114001: PUSH
114002: LD_INT 30
114004: PUSH
114005: LD_INT 0
114007: PUSH
114008: EMPTY
114009: LIST
114010: LIST
114011: PUSH
114012: LD_INT 30
114014: PUSH
114015: LD_INT 1
114017: PUSH
114018: EMPTY
114019: LIST
114020: LIST
114021: PUSH
114022: EMPTY
114023: LIST
114024: LIST
114025: LIST
114026: PPUSH
114027: CALL_OW 72
114031: PUSH
114032: LD_INT 1
114034: ARRAY
114035: PPUSH
114036: CALL 56828 0 2
// break ;
114040: GO 114044
// end ; end ;
114042: GO 113962
114044: POP
114045: POP
// end ;
114046: LD_VAR 0 5
114050: RET
