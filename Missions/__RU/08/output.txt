// starting begin InitMission ;
   0: CALL 5 0 0
// end ;
   4: END
// export HeikeCaptured ; export coopWithGensher ; export HeikeStatus ; export Masha ; export dial_BuildDepotBlocker , dial_BuildArBarrackBlocker , dial_ArriveGensherUnitsBlocker ; export buildingsToBuild , techsToResearch , vehWeaponsToConstruct , availableWeapons , weaponsData , allBuildings ; export HeikeTargetX , HeikeTargetY , GensherTargetX , GensherTargetY ; export allowExitFromMap ; export acceptKurtOffert , askCommanders ; export KurtCanEscape , KurtStatus , KurtWaitingForFreeHeike , KurtWaitingForBuildBarrack ; export KurtAttack , americansAttack , forceStopKurtAttack ; export canSendHeike , canShootTrening ; export BurlakRespect ; export acceptLegionOffert , paidLegionOffert , legionOffertCountdown , legionOffertTime ; export firstMashaQuery , canChooseMashaVehicle ; export buildCompVehicle , buildArabBarrack , testedTeleport ; export lostUnits ; function InitMission ; begin
   5: LD_INT 0
   7: PPUSH
// ResetFog ;
   8: CALL_OW 335
// RandomizeAll ;
  12: CALL_OW 11
// InGameOn ;
  16: CALL_OW 8
// InitMapConfig ;
  20: CALL 358 0 0
// HeikeCaptured = LoadVariable ( 07_HeikeCaptured_1 , 0 ) ;
  24: LD_ADDR_EXP 1
  28: PUSH
  29: LD_STRING 07_HeikeCaptured_1
  31: PPUSH
  32: LD_INT 0
  34: PPUSH
  35: CALL_OW 30
  39: ST_TO_ADDR
// coopWithGensher = 0 ;
  40: LD_ADDR_EXP 2
  44: PUSH
  45: LD_INT 0
  47: ST_TO_ADDR
// HeikeStatus = 0 ;
  48: LD_ADDR_EXP 3
  52: PUSH
  53: LD_INT 0
  55: ST_TO_ADDR
// Masha = [ ] ;
  56: LD_ADDR_EXP 4
  60: PUSH
  61: EMPTY
  62: ST_TO_ADDR
// buildingsToBuild = [ ] ;
  63: LD_ADDR_EXP 8
  67: PUSH
  68: EMPTY
  69: ST_TO_ADDR
// techsToResearch = [ ] ;
  70: LD_ADDR_EXP 9
  74: PUSH
  75: EMPTY
  76: ST_TO_ADDR
// vehWeaponsToConstruct = [ ] ;
  77: LD_ADDR_EXP 10
  81: PUSH
  82: EMPTY
  83: ST_TO_ADDR
// availableWeapons = [ ] ;
  84: LD_ADDR_EXP 11
  88: PUSH
  89: EMPTY
  90: ST_TO_ADDR
// weaponsData = [ ] ;
  91: LD_ADDR_EXP 12
  95: PUSH
  96: EMPTY
  97: ST_TO_ADDR
// allBuildings = [ ] ;
  98: LD_ADDR_EXP 13
 102: PUSH
 103: EMPTY
 104: ST_TO_ADDR
// HeikeTargetX = 0 ;
 105: LD_ADDR_EXP 14
 109: PUSH
 110: LD_INT 0
 112: ST_TO_ADDR
// HeikeTargetY = 0 ;
 113: LD_ADDR_EXP 15
 117: PUSH
 118: LD_INT 0
 120: ST_TO_ADDR
// GensherTargetX = 0 ;
 121: LD_ADDR_EXP 16
 125: PUSH
 126: LD_INT 0
 128: ST_TO_ADDR
// GensherTargetY = 0 ;
 129: LD_ADDR_EXP 17
 133: PUSH
 134: LD_INT 0
 136: ST_TO_ADDR
// allowExitFromMap = 0 ;
 137: LD_ADDR_EXP 18
 141: PUSH
 142: LD_INT 0
 144: ST_TO_ADDR
// acceptKurtOffert = 0 ;
 145: LD_ADDR_EXP 19
 149: PUSH
 150: LD_INT 0
 152: ST_TO_ADDR
// askCommanders = 0 ;
 153: LD_ADDR_EXP 20
 157: PUSH
 158: LD_INT 0
 160: ST_TO_ADDR
// KurtCanEscape = true ;
 161: LD_ADDR_EXP 21
 165: PUSH
 166: LD_INT 1
 168: ST_TO_ADDR
// KurtAttack = false ;
 169: LD_ADDR_EXP 25
 173: PUSH
 174: LD_INT 0
 176: ST_TO_ADDR
// KurtWaitingForFreeHeike = false ;
 177: LD_ADDR_EXP 23
 181: PUSH
 182: LD_INT 0
 184: ST_TO_ADDR
// KurtWaitingForBuildBarrack = false ;
 185: LD_ADDR_EXP 24
 189: PUSH
 190: LD_INT 0
 192: ST_TO_ADDR
// KurtStatus = 0 ;
 193: LD_ADDR_EXP 22
 197: PUSH
 198: LD_INT 0
 200: ST_TO_ADDR
// americansAttack = false ;
 201: LD_ADDR_EXP 26
 205: PUSH
 206: LD_INT 0
 208: ST_TO_ADDR
// forceStopKurtAttack = false ;
 209: LD_ADDR_EXP 27
 213: PUSH
 214: LD_INT 0
 216: ST_TO_ADDR
// canSendHeike = false ;
 217: LD_ADDR_EXP 28
 221: PUSH
 222: LD_INT 0
 224: ST_TO_ADDR
// canShootTrening = false ;
 225: LD_ADDR_EXP 29
 229: PUSH
 230: LD_INT 0
 232: ST_TO_ADDR
// BurlakRespect = 0 ;
 233: LD_ADDR_EXP 30
 237: PUSH
 238: LD_INT 0
 240: ST_TO_ADDR
// acceptLegionOffert = false ;
 241: LD_ADDR_EXP 31
 245: PUSH
 246: LD_INT 0
 248: ST_TO_ADDR
// paidLegionOffert = false ;
 249: LD_ADDR_EXP 32
 253: PUSH
 254: LD_INT 0
 256: ST_TO_ADDR
// legionOffertCountdown = false ;
 257: LD_ADDR_EXP 33
 261: PUSH
 262: LD_INT 0
 264: ST_TO_ADDR
// legionOffertTime = 0 0$60 ;
 265: LD_ADDR_EXP 34
 269: PUSH
 270: LD_INT 2100
 272: ST_TO_ADDR
// canChooseMashaVehicle = false ;
 273: LD_ADDR_EXP 36
 277: PUSH
 278: LD_INT 0
 280: ST_TO_ADDR
// firstMashaQuery = true ;
 281: LD_ADDR_EXP 35
 285: PUSH
 286: LD_INT 1
 288: ST_TO_ADDR
// buildArabBarrack = false ;
 289: LD_ADDR_EXP 38
 293: PUSH
 294: LD_INT 0
 296: ST_TO_ADDR
// buildCompVehicle = false ;
 297: LD_ADDR_EXP 37
 301: PUSH
 302: LD_INT 0
 304: ST_TO_ADDR
// testedTeleport = false ;
 305: LD_ADDR_EXP 39
 309: PUSH
 310: LD_INT 0
 312: ST_TO_ADDR
// lostUnits = 0 ;
 313: LD_ADDR_EXP 40
 317: PUSH
 318: LD_INT 0
 320: ST_TO_ADDR
// PrepareRussians ;
 321: CALL 1292 0 0
// PrepareArabians ;
 325: CALL 3847 0 0
// PrepareAmericans ;
 329: CALL 2975 0 0
// Nef_PrepareNature ;
 333: CALL 4831 0 0
// SpawnTrees ;
 337: CALL 5452 0 0
// MissionIntro ;
 341: CALL 9085 0 0
// end ;
 345: LD_VAR 0 1
 349: RET
// export function CustomInitMacro ; begin
 350: LD_INT 0
 352: PPUSH
// end ; end_of_file
 353: LD_VAR 0 1
 357: RET
// export function InitMapConfig ; begin
 358: LD_INT 0
 360: PPUSH
// BaseMapConfig ;
 361: CALL 374 0 0
// MissionMapConfig ;
 365: CALL 464 0 0
// end ;
 369: LD_VAR 0 1
 373: RET
// export animalsAmount , animalsStats , animalsAgression , missionPrefix , previousMissionPrefix , debugMode ; function BaseMapConfig ; begin
 374: LD_INT 0
 376: PPUSH
// animalsAmount = [ 6 , 3 , 4 , 4 , 1 ] ;
 377: LD_ADDR_EXP 41
 381: PUSH
 382: LD_INT 6
 384: PUSH
 385: LD_INT 3
 387: PUSH
 388: LD_INT 4
 390: PUSH
 391: LD_INT 4
 393: PUSH
 394: LD_INT 1
 396: PUSH
 397: EMPTY
 398: LIST
 399: LIST
 400: LIST
 401: LIST
 402: LIST
 403: ST_TO_ADDR
// animalsStats = [ 2 , 2 , 2 , 2 ] ;
 404: LD_ADDR_EXP 42
 408: PUSH
 409: LD_INT 2
 411: PUSH
 412: LD_INT 2
 414: PUSH
 415: LD_INT 2
 417: PUSH
 418: LD_INT 2
 420: PUSH
 421: EMPTY
 422: LIST
 423: LIST
 424: LIST
 425: LIST
 426: ST_TO_ADDR
// animalsAgression = 3 ;
 427: LD_ADDR_EXP 43
 431: PUSH
 432: LD_INT 3
 434: ST_TO_ADDR
// debugMode = 0 ;
 435: LD_ADDR_EXP 46
 439: PUSH
 440: LD_INT 0
 442: ST_TO_ADDR
// missionPrefix = 08_ ;
 443: LD_ADDR_EXP 44
 447: PUSH
 448: LD_STRING 08_
 450: ST_TO_ADDR
// previousMissionPrefix = 07_ ;
 451: LD_ADDR_EXP 45
 455: PUSH
 456: LD_STRING 07_
 458: ST_TO_ADDR
// end ;
 459: LD_VAR 0 1
 463: RET
// export KurtAttackWaves , americansAttackWaves ; export firstAttackDelay ; export waveCooldown ; export legionReduceAmericansUnits ; export speedMedalTime ; export enemyAttackUnitsData ; export timeToFreeHeike , timeToBuildArBarrack ; export enemySkillLevel ; function MissionMapConfig ; begin
 464: LD_INT 0
 466: PPUSH
// KurtAttackWaves = [ 3 , 4 , 5 , 6 ] [ Difficulty ] ;
 467: LD_ADDR_EXP 47
 471: PUSH
 472: LD_INT 3
 474: PUSH
 475: LD_INT 4
 477: PUSH
 478: LD_INT 5
 480: PUSH
 481: LD_INT 6
 483: PUSH
 484: EMPTY
 485: LIST
 486: LIST
 487: LIST
 488: LIST
 489: PUSH
 490: LD_OWVAR 67
 494: ARRAY
 495: ST_TO_ADDR
// americansAttackWaves = [ 1 , 2 , 3 , 4 ] [ Difficulty ] ;
 496: LD_ADDR_EXP 48
 500: PUSH
 501: LD_INT 1
 503: PUSH
 504: LD_INT 2
 506: PUSH
 507: LD_INT 3
 509: PUSH
 510: LD_INT 4
 512: PUSH
 513: EMPTY
 514: LIST
 515: LIST
 516: LIST
 517: LIST
 518: PUSH
 519: LD_OWVAR 67
 523: ARRAY
 524: ST_TO_ADDR
// enemySkillLevel = [ 3 , 4 , 5 , 6 ] [ Difficulty ] ;
 525: LD_ADDR_EXP 56
 529: PUSH
 530: LD_INT 3
 532: PUSH
 533: LD_INT 4
 535: PUSH
 536: LD_INT 5
 538: PUSH
 539: LD_INT 6
 541: PUSH
 542: EMPTY
 543: LIST
 544: LIST
 545: LIST
 546: LIST
 547: PUSH
 548: LD_OWVAR 67
 552: ARRAY
 553: ST_TO_ADDR
// waveCooldown = 1 1$30 ;
 554: LD_ADDR_EXP 50
 558: PUSH
 559: LD_INT 3150
 561: ST_TO_ADDR
// firstAttackDelay = 1 1$00 ;
 562: LD_ADDR_EXP 49
 566: PUSH
 567: LD_INT 2100
 569: ST_TO_ADDR
// timeToFreeHeike = 2 2$00 ;
 570: LD_ADDR_EXP 54
 574: PUSH
 575: LD_INT 4200
 577: ST_TO_ADDR
// timeToBuildArBarrack = 5 5$00 ;
 578: LD_ADDR_EXP 55
 582: PUSH
 583: LD_INT 10500
 585: ST_TO_ADDR
// legionReduceAmericansUnits = [ 5 , 5 , 6 , 6 ] [ Difficulty ] ;
 586: LD_ADDR_EXP 51
 590: PUSH
 591: LD_INT 5
 593: PUSH
 594: LD_INT 5
 596: PUSH
 597: LD_INT 6
 599: PUSH
 600: LD_INT 6
 602: PUSH
 603: EMPTY
 604: LIST
 605: LIST
 606: LIST
 607: LIST
 608: PUSH
 609: LD_OWVAR 67
 613: ARRAY
 614: ST_TO_ADDR
// speedMedalTime = [ 80 80$0 , 70 70$0 , 60 60$0 , 50 50$0 ] [ Difficulty ] ;
 615: LD_ADDR_EXP 52
 619: PUSH
 620: LD_INT 168000
 622: PUSH
 623: LD_INT 147000
 625: PUSH
 626: LD_INT 126000
 628: PUSH
 629: LD_INT 105000
 631: PUSH
 632: EMPTY
 633: LIST
 634: LIST
 635: LIST
 636: LIST
 637: PUSH
 638: LD_OWVAR 67
 642: ARRAY
 643: ST_TO_ADDR
// enemyAttackUnitsData = [ [ 1 , [ 4 , 5 , 6 , 6 ] [ Difficulty ] , [ 7 , 8 , 9 , 9 ] [ Difficulty ] , [ 1 , 2 , 2 , 3 ] [ Difficulty ] , [ 3 , 3 , 4 , 4 ] [ Difficulty ] , [ 6 , 7 , 8 , 8 ] [ Difficulty ] , [ 10 , 12 , 15 , 15 ] [ Difficulty ] ] , [ 8 , [ 2 , 3 , 4 , 4 ] [ Difficulty ] , [ 6 , 6 , 7 , 7 ] [ Difficulty ] , [ 0 , 1 , 1 , 2 ] [ Difficulty ] , [ 1 , 2 , 3 , 3 ] [ Difficulty ] , [ 1 , 2 , 2 , 2 ] [ Difficulty ] , [ 2 , 3 , 5 , 5 ] [ Difficulty ] ] ] ;
 644: LD_ADDR_EXP 53
 648: PUSH
 649: LD_INT 1
 651: PUSH
 652: LD_INT 4
 654: PUSH
 655: LD_INT 5
 657: PUSH
 658: LD_INT 6
 660: PUSH
 661: LD_INT 6
 663: PUSH
 664: EMPTY
 665: LIST
 666: LIST
 667: LIST
 668: LIST
 669: PUSH
 670: LD_OWVAR 67
 674: ARRAY
 675: PUSH
 676: LD_INT 7
 678: PUSH
 679: LD_INT 8
 681: PUSH
 682: LD_INT 9
 684: PUSH
 685: LD_INT 9
 687: PUSH
 688: EMPTY
 689: LIST
 690: LIST
 691: LIST
 692: LIST
 693: PUSH
 694: LD_OWVAR 67
 698: ARRAY
 699: PUSH
 700: LD_INT 1
 702: PUSH
 703: LD_INT 2
 705: PUSH
 706: LD_INT 2
 708: PUSH
 709: LD_INT 3
 711: PUSH
 712: EMPTY
 713: LIST
 714: LIST
 715: LIST
 716: LIST
 717: PUSH
 718: LD_OWVAR 67
 722: ARRAY
 723: PUSH
 724: LD_INT 3
 726: PUSH
 727: LD_INT 3
 729: PUSH
 730: LD_INT 4
 732: PUSH
 733: LD_INT 4
 735: PUSH
 736: EMPTY
 737: LIST
 738: LIST
 739: LIST
 740: LIST
 741: PUSH
 742: LD_OWVAR 67
 746: ARRAY
 747: PUSH
 748: LD_INT 6
 750: PUSH
 751: LD_INT 7
 753: PUSH
 754: LD_INT 8
 756: PUSH
 757: LD_INT 8
 759: PUSH
 760: EMPTY
 761: LIST
 762: LIST
 763: LIST
 764: LIST
 765: PUSH
 766: LD_OWVAR 67
 770: ARRAY
 771: PUSH
 772: LD_INT 10
 774: PUSH
 775: LD_INT 12
 777: PUSH
 778: LD_INT 15
 780: PUSH
 781: LD_INT 15
 783: PUSH
 784: EMPTY
 785: LIST
 786: LIST
 787: LIST
 788: LIST
 789: PUSH
 790: LD_OWVAR 67
 794: ARRAY
 795: PUSH
 796: EMPTY
 797: LIST
 798: LIST
 799: LIST
 800: LIST
 801: LIST
 802: LIST
 803: LIST
 804: PUSH
 805: LD_INT 8
 807: PUSH
 808: LD_INT 2
 810: PUSH
 811: LD_INT 3
 813: PUSH
 814: LD_INT 4
 816: PUSH
 817: LD_INT 4
 819: PUSH
 820: EMPTY
 821: LIST
 822: LIST
 823: LIST
 824: LIST
 825: PUSH
 826: LD_OWVAR 67
 830: ARRAY
 831: PUSH
 832: LD_INT 6
 834: PUSH
 835: LD_INT 6
 837: PUSH
 838: LD_INT 7
 840: PUSH
 841: LD_INT 7
 843: PUSH
 844: EMPTY
 845: LIST
 846: LIST
 847: LIST
 848: LIST
 849: PUSH
 850: LD_OWVAR 67
 854: ARRAY
 855: PUSH
 856: LD_INT 0
 858: PUSH
 859: LD_INT 1
 861: PUSH
 862: LD_INT 1
 864: PUSH
 865: LD_INT 2
 867: PUSH
 868: EMPTY
 869: LIST
 870: LIST
 871: LIST
 872: LIST
 873: PUSH
 874: LD_OWVAR 67
 878: ARRAY
 879: PUSH
 880: LD_INT 1
 882: PUSH
 883: LD_INT 2
 885: PUSH
 886: LD_INT 3
 888: PUSH
 889: LD_INT 3
 891: PUSH
 892: EMPTY
 893: LIST
 894: LIST
 895: LIST
 896: LIST
 897: PUSH
 898: LD_OWVAR 67
 902: ARRAY
 903: PUSH
 904: LD_INT 1
 906: PUSH
 907: LD_INT 2
 909: PUSH
 910: LD_INT 2
 912: PUSH
 913: LD_INT 2
 915: PUSH
 916: EMPTY
 917: LIST
 918: LIST
 919: LIST
 920: LIST
 921: PUSH
 922: LD_OWVAR 67
 926: ARRAY
 927: PUSH
 928: LD_INT 2
 930: PUSH
 931: LD_INT 3
 933: PUSH
 934: LD_INT 5
 936: PUSH
 937: LD_INT 5
 939: PUSH
 940: EMPTY
 941: LIST
 942: LIST
 943: LIST
 944: LIST
 945: PUSH
 946: LD_OWVAR 67
 950: ARRAY
 951: PUSH
 952: EMPTY
 953: LIST
 954: LIST
 955: LIST
 956: LIST
 957: LIST
 958: LIST
 959: LIST
 960: PUSH
 961: EMPTY
 962: LIST
 963: LIST
 964: ST_TO_ADDR
// end ;
 965: LD_VAR 0 1
 969: RET
// every 0 0$1 trigger debugMode do var i ;
 970: LD_EXP 46
 974: IFFALSE 1289
 976: GO 978
 978: DISABLE
 979: LD_INT 0
 981: PPUSH
// begin enable ;
 982: ENABLE
// FogOff ( your_side ) ;
 983: LD_OWVAR 2
 987: PPUSH
 988: CALL_OW 344
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) do
 992: LD_ADDR_VAR 0 1
 996: PUSH
 997: LD_INT 22
 999: PUSH
1000: LD_OWVAR 2
1004: PUSH
1005: EMPTY
1006: LIST
1007: LIST
1008: PUSH
1009: LD_INT 2
1011: PUSH
1012: LD_INT 21
1014: PUSH
1015: LD_INT 1
1017: PUSH
1018: EMPTY
1019: LIST
1020: LIST
1021: PUSH
1022: LD_INT 21
1024: PUSH
1025: LD_INT 2
1027: PUSH
1028: EMPTY
1029: LIST
1030: LIST
1031: PUSH
1032: EMPTY
1033: LIST
1034: LIST
1035: LIST
1036: PUSH
1037: EMPTY
1038: LIST
1039: LIST
1040: PPUSH
1041: CALL_OW 69
1045: PUSH
1046: FOR_IN
1047: IFFALSE 1063
// SetLives ( i , 1000 ) ;
1049: LD_VAR 0 1
1053: PPUSH
1054: LD_INT 1000
1056: PPUSH
1057: CALL_OW 234
1061: GO 1046
1063: POP
1064: POP
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
1065: LD_ADDR_VAR 0 1
1069: PUSH
1070: LD_INT 22
1072: PUSH
1073: LD_OWVAR 2
1077: PUSH
1078: EMPTY
1079: LIST
1080: LIST
1081: PUSH
1082: LD_INT 21
1084: PUSH
1085: LD_INT 1
1087: PUSH
1088: EMPTY
1089: LIST
1090: LIST
1091: PUSH
1092: EMPTY
1093: LIST
1094: LIST
1095: PPUSH
1096: CALL_OW 69
1100: PUSH
1101: FOR_IN
1102: IFFALSE 1166
// begin SetSkill ( i , skill_combat , 10 ) ;
1104: LD_VAR 0 1
1108: PPUSH
1109: LD_INT 1
1111: PPUSH
1112: LD_INT 10
1114: PPUSH
1115: CALL_OW 237
// SetSkill ( i , skill_engineering , 10 ) ;
1119: LD_VAR 0 1
1123: PPUSH
1124: LD_INT 2
1126: PPUSH
1127: LD_INT 10
1129: PPUSH
1130: CALL_OW 237
// SetSkill ( i , skill_mechanical , 10 ) ;
1134: LD_VAR 0 1
1138: PPUSH
1139: LD_INT 3
1141: PPUSH
1142: LD_INT 10
1144: PPUSH
1145: CALL_OW 237
// SetSkill ( i , skill_scientistic , 10 ) ;
1149: LD_VAR 0 1
1153: PPUSH
1154: LD_INT 4
1156: PPUSH
1157: LD_INT 10
1159: PPUSH
1160: CALL_OW 237
// end ;
1164: GO 1101
1166: POP
1167: POP
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) do
1168: LD_ADDR_VAR 0 1
1172: PUSH
1173: LD_INT 22
1175: PUSH
1176: LD_OWVAR 2
1180: PUSH
1181: EMPTY
1182: LIST
1183: LIST
1184: PUSH
1185: LD_INT 2
1187: PUSH
1188: LD_INT 30
1190: PUSH
1191: LD_INT 0
1193: PUSH
1194: EMPTY
1195: LIST
1196: LIST
1197: PUSH
1198: LD_INT 30
1200: PUSH
1201: LD_INT 1
1203: PUSH
1204: EMPTY
1205: LIST
1206: LIST
1207: PUSH
1208: EMPTY
1209: LIST
1210: LIST
1211: LIST
1212: PUSH
1213: EMPTY
1214: LIST
1215: LIST
1216: PPUSH
1217: CALL_OW 69
1221: PUSH
1222: FOR_IN
1223: IFFALSE 1287
// begin SetResourceType ( GetBase ( i ) , mat_cans , 9999 ) ;
1225: LD_VAR 0 1
1229: PPUSH
1230: CALL_OW 274
1234: PPUSH
1235: LD_INT 1
1237: PPUSH
1238: LD_INT 9999
1240: PPUSH
1241: CALL_OW 277
// SetResourceType ( GetBase ( i ) , mat_oil , 9999 ) ;
1245: LD_VAR 0 1
1249: PPUSH
1250: CALL_OW 274
1254: PPUSH
1255: LD_INT 2
1257: PPUSH
1258: LD_INT 9999
1260: PPUSH
1261: CALL_OW 277
// SetResourceType ( GetBase ( i ) , mat_siberit , 9999 ) ;
1265: LD_VAR 0 1
1269: PPUSH
1270: CALL_OW 274
1274: PPUSH
1275: LD_INT 3
1277: PPUSH
1278: LD_INT 9999
1280: PPUSH
1281: CALL_OW 277
// end ;
1285: GO 1222
1287: POP
1288: POP
// end ; end_of_file
1289: PPOPN 1
1291: END
// export Burlak , Karamazov , Petrovova , Gleb , Petrosyan , Titov , Dolgov , Lipshchin , Kirilenkova , Belkov , Belkov2 , Xavier ; export Gnyevko , Kovalyuk , Scholtze , Kuzmov ; export Kozlov , Oblukov , Kapitsova ; export Popov ; export russianEscort ; export function PrepareRussians ; begin
1292: LD_INT 0
1294: PPUSH
// russianEscort = [ ] ;
1295: LD_ADDR_EXP 77
1299: PUSH
1300: EMPTY
1301: ST_TO_ADDR
// Masha = [ ] ;
1302: LD_ADDR_EXP 4
1306: PUSH
1307: EMPTY
1308: ST_TO_ADDR
// PrepareHeroes ;
1309: CALL 1322 0 0
// InitRussianRequiments ;
1313: CALL 2717 0 0
// end ;
1317: LD_VAR 0 1
1321: RET
// function PrepareHeroes ; var i , un , other_survivors , yourUnits , emptyVeh ; begin
1322: LD_INT 0
1324: PPUSH
1325: PPUSH
1326: PPUSH
1327: PPUSH
1328: PPUSH
1329: PPUSH
// uc_side = 3 ;
1330: LD_ADDR_OWVAR 20
1334: PUSH
1335: LD_INT 3
1337: ST_TO_ADDR
// uc_nation = 3 ;
1338: LD_ADDR_OWVAR 21
1342: PUSH
1343: LD_INT 3
1345: ST_TO_ADDR
// Burlak := PrepareUnitExt ( Burlak , true , class_mechanic ) ;
1346: LD_ADDR_EXP 57
1350: PUSH
1351: LD_STRING Burlak
1353: PPUSH
1354: LD_INT 1
1356: PPUSH
1357: LD_INT 3
1359: PPUSH
1360: CALL 5930 0 3
1364: ST_TO_ADDR
// Titov := PrepareUnitExt ( Titov , true , class_soldier ) ;
1365: LD_ADDR_EXP 62
1369: PUSH
1370: LD_STRING Titov
1372: PPUSH
1373: LD_INT 1
1375: PPUSH
1376: LD_INT 1
1378: PPUSH
1379: CALL 5930 0 3
1383: ST_TO_ADDR
// Dolgov := PrepareUnitExt ( Dolgov , true , class_scientistic ) ;
1384: LD_ADDR_EXP 63
1388: PUSH
1389: LD_STRING Dolgov
1391: PPUSH
1392: LD_INT 1
1394: PPUSH
1395: LD_INT 4
1397: PPUSH
1398: CALL 5930 0 3
1402: ST_TO_ADDR
// Lipshchin := PrepareUnitExt ( Lipshchin , true , class_soldier ) ;
1403: LD_ADDR_EXP 64
1407: PUSH
1408: LD_STRING Lipshchin
1410: PPUSH
1411: LD_INT 1
1413: PPUSH
1414: LD_INT 1
1416: PPUSH
1417: CALL 5930 0 3
1421: ST_TO_ADDR
// Karamazov := PrepareUnitExt ( Karamazov , true , class_engineer ) ;
1422: LD_ADDR_EXP 58
1426: PUSH
1427: LD_STRING Karamazov
1429: PPUSH
1430: LD_INT 1
1432: PPUSH
1433: LD_INT 2
1435: PPUSH
1436: CALL 5930 0 3
1440: ST_TO_ADDR
// Petrovova := PrepareUnitExt ( Petrovova , true , class_soldier ) ;
1441: LD_ADDR_EXP 59
1445: PUSH
1446: LD_STRING Petrovova
1448: PPUSH
1449: LD_INT 1
1451: PPUSH
1452: LD_INT 1
1454: PPUSH
1455: CALL 5930 0 3
1459: ST_TO_ADDR
// Gleb := PrepareUnitExt ( Gleb , true , class_soldier ) ;
1460: LD_ADDR_EXP 60
1464: PUSH
1465: LD_STRING Gleb
1467: PPUSH
1468: LD_INT 1
1470: PPUSH
1471: LD_INT 1
1473: PPUSH
1474: CALL 5930 0 3
1478: ST_TO_ADDR
// Petrosyan := PrepareUnitExt ( Petrosyan , true , class_scientistic ) ;
1479: LD_ADDR_EXP 61
1483: PUSH
1484: LD_STRING Petrosyan
1486: PPUSH
1487: LD_INT 1
1489: PPUSH
1490: LD_INT 4
1492: PPUSH
1493: CALL 5930 0 3
1497: ST_TO_ADDR
// Kirilenkova := PrepareUnitExt ( Kirilenkova , true , class_scientistic ) ;
1498: LD_ADDR_EXP 65
1502: PUSH
1503: LD_STRING Kirilenkova
1505: PPUSH
1506: LD_INT 1
1508: PPUSH
1509: LD_INT 4
1511: PPUSH
1512: CALL 5930 0 3
1516: ST_TO_ADDR
// Belkov := PrepareUnitExt ( Belkov , true , class_soldier ) ;
1517: LD_ADDR_EXP 66
1521: PUSH
1522: LD_STRING Belkov
1524: PPUSH
1525: LD_INT 1
1527: PPUSH
1528: LD_INT 1
1530: PPUSH
1531: CALL 5930 0 3
1535: ST_TO_ADDR
// Belkov2 := PrepareUnitExt ( Belkov2 , true , class_soldier ) ;
1536: LD_ADDR_EXP 67
1540: PUSH
1541: LD_STRING Belkov2
1543: PPUSH
1544: LD_INT 1
1546: PPUSH
1547: LD_INT 1
1549: PPUSH
1550: CALL 5930 0 3
1554: ST_TO_ADDR
// Xavier := PrepareUnitExt ( Xavier , true , class_soldier ) ;
1555: LD_ADDR_EXP 68
1559: PUSH
1560: LD_STRING Xavier
1562: PPUSH
1563: LD_INT 1
1565: PPUSH
1566: LD_INT 1
1568: PPUSH
1569: CALL 5930 0 3
1573: ST_TO_ADDR
// Gnyevko := CreateCharacter ( 04_Gnyevko ) ;
1574: LD_ADDR_EXP 69
1578: PUSH
1579: LD_STRING 04_Gnyevko
1581: PPUSH
1582: CALL_OW 34
1586: ST_TO_ADDR
// SetClass ( Gnyevko , class_soldier ) ;
1587: LD_EXP 69
1591: PPUSH
1592: LD_INT 1
1594: PPUSH
1595: CALL_OW 336
// Kovalyuk := CreateCharacter ( 04_Kovalyuk ) ;
1599: LD_ADDR_EXP 70
1603: PUSH
1604: LD_STRING 04_Kovalyuk
1606: PPUSH
1607: CALL_OW 34
1611: ST_TO_ADDR
// SetClass ( Kovalyuk , class_mechanic ) ;
1612: LD_EXP 70
1616: PPUSH
1617: LD_INT 3
1619: PPUSH
1620: CALL_OW 336
// Scholtze := CreateCharacter ( 04_Scholtze ) ;
1624: LD_ADDR_EXP 71
1628: PUSH
1629: LD_STRING 04_Scholtze
1631: PPUSH
1632: CALL_OW 34
1636: ST_TO_ADDR
// SetClass ( Scholtze , class_scientistic ) ;
1637: LD_EXP 71
1641: PPUSH
1642: LD_INT 4
1644: PPUSH
1645: CALL_OW 336
// Kuzmov := CreateCharacter ( 04_Kuzmov ) ;
1649: LD_ADDR_EXP 72
1653: PUSH
1654: LD_STRING 04_Kuzmov
1656: PPUSH
1657: CALL_OW 34
1661: ST_TO_ADDR
// SetClass ( Kuzmov , class_soldier ) ;
1662: LD_EXP 72
1666: PPUSH
1667: LD_INT 1
1669: PPUSH
1670: CALL_OW 336
// Kozlov := PrepareUnitExt ( Kozlov , false , class_engineer ) ;
1674: LD_ADDR_EXP 73
1678: PUSH
1679: LD_STRING Kozlov
1681: PPUSH
1682: LD_INT 0
1684: PPUSH
1685: LD_INT 2
1687: PPUSH
1688: CALL 5930 0 3
1692: ST_TO_ADDR
// Oblukov := PrepareUnitExt ( Oblukov , false , class_soldier ) ;
1693: LD_ADDR_EXP 74
1697: PUSH
1698: LD_STRING Oblukov
1700: PPUSH
1701: LD_INT 0
1703: PPUSH
1704: LD_INT 1
1706: PPUSH
1707: CALL 5930 0 3
1711: ST_TO_ADDR
// Kapitsova := PrepareUnitExt ( Kapitsova , false , class_scientistic ) ;
1712: LD_ADDR_EXP 75
1716: PUSH
1717: LD_STRING Kapitsova
1719: PPUSH
1720: LD_INT 0
1722: PPUSH
1723: LD_INT 4
1725: PPUSH
1726: CALL 5930 0 3
1730: ST_TO_ADDR
// Popov := PrepareUnitExt ( Popov , false , 0 ) ;
1731: LD_ADDR_EXP 76
1735: PUSH
1736: LD_STRING Popov
1738: PPUSH
1739: LD_INT 0
1741: PPUSH
1742: LD_INT 0
1744: PPUSH
1745: CALL 5930 0 3
1749: ST_TO_ADDR
// PlaceUnitsArea ( [ Burlak , Karamazov , Petrovova , Gleb , Petrosyan , Titov , Dolgov , Lipshchin , Kirilenkova , Belkov , Belkov2 , Xavier , Gnyevko , Kovalyuk , Scholtze , Kuzmov , Kozlov , Oblukov , Kapitsova ] , RussianSpawnArea , false ) ;
1750: LD_EXP 57
1754: PUSH
1755: LD_EXP 58
1759: PUSH
1760: LD_EXP 59
1764: PUSH
1765: LD_EXP 60
1769: PUSH
1770: LD_EXP 61
1774: PUSH
1775: LD_EXP 62
1779: PUSH
1780: LD_EXP 63
1784: PUSH
1785: LD_EXP 64
1789: PUSH
1790: LD_EXP 65
1794: PUSH
1795: LD_EXP 66
1799: PUSH
1800: LD_EXP 67
1804: PUSH
1805: LD_EXP 68
1809: PUSH
1810: LD_EXP 69
1814: PUSH
1815: LD_EXP 70
1819: PUSH
1820: LD_EXP 71
1824: PUSH
1825: LD_EXP 72
1829: PUSH
1830: LD_EXP 73
1834: PUSH
1835: LD_EXP 74
1839: PUSH
1840: LD_EXP 75
1844: PUSH
1845: EMPTY
1846: LIST
1847: LIST
1848: LIST
1849: LIST
1850: LIST
1851: LIST
1852: LIST
1853: LIST
1854: LIST
1855: LIST
1856: LIST
1857: LIST
1858: LIST
1859: LIST
1860: LIST
1861: LIST
1862: LIST
1863: LIST
1864: LIST
1865: PPUSH
1866: LD_INT 2
1868: PPUSH
1869: LD_INT 0
1871: PPUSH
1872: CALL 6204 0 3
// PrepareVehicles ;
1876: CALL 2417 0 0
// other_survivors = CreateCharacterSet ( 07_other_survivors ) ;
1880: LD_ADDR_VAR 0 4
1884: PUSH
1885: LD_STRING 07_other_survivors
1887: PPUSH
1888: CALL_OW 31
1892: ST_TO_ADDR
// other_survivors = other_survivors ^ CreateCharacterSet ( 04_other_survivors ) ;
1893: LD_ADDR_VAR 0 4
1897: PUSH
1898: LD_VAR 0 4
1902: PUSH
1903: LD_STRING 04_other_survivors
1905: PPUSH
1906: CALL_OW 31
1910: ADD
1911: ST_TO_ADDR
// other_survivors = other_survivors ^ CreateCharacterSet ( 04_other_survivors_with_popov ) ;
1912: LD_ADDR_VAR 0 4
1916: PUSH
1917: LD_VAR 0 4
1921: PUSH
1922: LD_STRING 04_other_survivors_with_popov
1924: PPUSH
1925: CALL_OW 31
1929: ADD
1930: ST_TO_ADDR
// for un in other_survivors do
1931: LD_ADDR_VAR 0 3
1935: PUSH
1936: LD_VAR 0 4
1940: PUSH
1941: FOR_IN
1942: IFFALSE 2028
// begin emptyVeh = FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] , [ f_empty ] ] ) ;
1944: LD_ADDR_VAR 0 6
1948: PUSH
1949: LD_INT 22
1951: PUSH
1952: LD_INT 3
1954: PUSH
1955: EMPTY
1956: LIST
1957: LIST
1958: PUSH
1959: LD_INT 21
1961: PUSH
1962: LD_INT 2
1964: PUSH
1965: EMPTY
1966: LIST
1967: LIST
1968: PUSH
1969: LD_INT 58
1971: PUSH
1972: EMPTY
1973: LIST
1974: PUSH
1975: EMPTY
1976: LIST
1977: LIST
1978: LIST
1979: PPUSH
1980: CALL_OW 69
1984: ST_TO_ADDR
// if emptyVeh then
1985: LD_VAR 0 6
1989: IFFALSE 2011
// PlaceHumanInUnit ( un , emptyVeh [ 1 ] ) else
1991: LD_VAR 0 3
1995: PPUSH
1996: LD_VAR 0 6
2000: PUSH
2001: LD_INT 1
2003: ARRAY
2004: PPUSH
2005: CALL_OW 52
2009: GO 2026
// PlaceUnitArea ( un , RussianSpawnArea , false ) ;
2011: LD_VAR 0 3
2015: PPUSH
2016: LD_INT 2
2018: PPUSH
2019: LD_INT 0
2021: PPUSH
2022: CALL_OW 49
// end ;
2026: GO 1941
2028: POP
2029: POP
// yourUnits = FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_nation , nation_russian ] ] ) ;
2030: LD_ADDR_VAR 0 5
2034: PUSH
2035: LD_INT 22
2037: PUSH
2038: LD_INT 3
2040: PUSH
2041: EMPTY
2042: LIST
2043: LIST
2044: PUSH
2045: LD_INT 21
2047: PUSH
2048: LD_INT 1
2050: PUSH
2051: EMPTY
2052: LIST
2053: LIST
2054: PUSH
2055: LD_INT 23
2057: PUSH
2058: LD_INT 3
2060: PUSH
2061: EMPTY
2062: LIST
2063: LIST
2064: PUSH
2065: EMPTY
2066: LIST
2067: LIST
2068: LIST
2069: PPUSH
2070: CALL_OW 69
2074: ST_TO_ADDR
// if yourUnits < 15 then
2075: LD_VAR 0 5
2079: PUSH
2080: LD_INT 15
2082: LESS
2083: IFFALSE 2232
// for i := 1 to 15 - yourUnits do
2085: LD_ADDR_VAR 0 2
2089: PUSH
2090: DOUBLE
2091: LD_INT 1
2093: DEC
2094: ST_TO_ADDR
2095: LD_INT 15
2097: PUSH
2098: LD_VAR 0 5
2102: MINUS
2103: PUSH
2104: FOR_TO
2105: IFFALSE 2230
// begin PrepareHuman ( false , rand ( 1 , 4 ) , rand ( 2 , 4 ) ) ;
2107: LD_INT 0
2109: PPUSH
2110: LD_INT 1
2112: PPUSH
2113: LD_INT 4
2115: PPUSH
2116: CALL_OW 12
2120: PPUSH
2121: LD_INT 2
2123: PPUSH
2124: LD_INT 4
2126: PPUSH
2127: CALL_OW 12
2131: PPUSH
2132: CALL_OW 380
// un = CreateHuman ;
2136: LD_ADDR_VAR 0 3
2140: PUSH
2141: CALL_OW 44
2145: ST_TO_ADDR
// emptyVeh = FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] , [ f_empty ] ] ) ;
2146: LD_ADDR_VAR 0 6
2150: PUSH
2151: LD_INT 22
2153: PUSH
2154: LD_INT 3
2156: PUSH
2157: EMPTY
2158: LIST
2159: LIST
2160: PUSH
2161: LD_INT 21
2163: PUSH
2164: LD_INT 2
2166: PUSH
2167: EMPTY
2168: LIST
2169: LIST
2170: PUSH
2171: LD_INT 58
2173: PUSH
2174: EMPTY
2175: LIST
2176: PUSH
2177: EMPTY
2178: LIST
2179: LIST
2180: LIST
2181: PPUSH
2182: CALL_OW 69
2186: ST_TO_ADDR
// if emptyVeh then
2187: LD_VAR 0 6
2191: IFFALSE 2213
// PlaceHumanInUnit ( un , emptyVeh [ 1 ] ) else
2193: LD_VAR 0 3
2197: PPUSH
2198: LD_VAR 0 6
2202: PUSH
2203: LD_INT 1
2205: ARRAY
2206: PPUSH
2207: CALL_OW 52
2211: GO 2228
// PlaceUnitArea ( un , RussianSpawnArea , false ) ;
2213: LD_VAR 0 3
2217: PPUSH
2218: LD_INT 2
2220: PPUSH
2221: LD_INT 0
2223: PPUSH
2224: CALL_OW 49
// end ;
2228: GO 2104
2230: POP
2231: POP
// yourUnits = FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_nation , nation_russian ] ] ) ;
2232: LD_ADDR_VAR 0 5
2236: PUSH
2237: LD_INT 22
2239: PUSH
2240: LD_INT 3
2242: PUSH
2243: EMPTY
2244: LIST
2245: LIST
2246: PUSH
2247: LD_INT 21
2249: PUSH
2250: LD_INT 1
2252: PUSH
2253: EMPTY
2254: LIST
2255: LIST
2256: PUSH
2257: LD_INT 23
2259: PUSH
2260: LD_INT 3
2262: PUSH
2263: EMPTY
2264: LIST
2265: LIST
2266: PUSH
2267: EMPTY
2268: LIST
2269: LIST
2270: LIST
2271: PPUSH
2272: CALL_OW 69
2276: ST_TO_ADDR
// if not UnitFilter ( yourUnits , [ f_class , class_engineer ] ) then
2277: LD_VAR 0 5
2281: PPUSH
2282: LD_INT 25
2284: PUSH
2285: LD_INT 2
2287: PUSH
2288: EMPTY
2289: LIST
2290: LIST
2291: PPUSH
2292: CALL_OW 72
2296: NOT
2297: IFFALSE 2315
// SetClass ( yourUnits [ 1 ] , 2 ) ;
2299: LD_VAR 0 5
2303: PUSH
2304: LD_INT 1
2306: ARRAY
2307: PPUSH
2308: LD_INT 2
2310: PPUSH
2311: CALL_OW 336
// end ;
2315: LD_VAR 0 1
2319: RET
// export function PrepareRussianEscort ; var i , unit ; begin
2320: LD_INT 0
2322: PPUSH
2323: PPUSH
2324: PPUSH
// uc_side = 6 ;
2325: LD_ADDR_OWVAR 20
2329: PUSH
2330: LD_INT 6
2332: ST_TO_ADDR
// uc_nation = 3 ;
2333: LD_ADDR_OWVAR 21
2337: PUSH
2338: LD_INT 3
2340: ST_TO_ADDR
// for i := 1 to 2 do
2341: LD_ADDR_VAR 0 2
2345: PUSH
2346: DOUBLE
2347: LD_INT 1
2349: DEC
2350: ST_TO_ADDR
2351: LD_INT 2
2353: PUSH
2354: FOR_TO
2355: IFFALSE 2410
// begin PrepareSoldier ( false , 4 ) ;
2357: LD_INT 0
2359: PPUSH
2360: LD_INT 4
2362: PPUSH
2363: CALL_OW 381
// unit = CreateHuman ;
2367: LD_ADDR_VAR 0 3
2371: PUSH
2372: CALL_OW 44
2376: ST_TO_ADDR
// russianEscort = russianEscort ^ unit ;
2377: LD_ADDR_EXP 77
2381: PUSH
2382: LD_EXP 77
2386: PUSH
2387: LD_VAR 0 3
2391: ADD
2392: ST_TO_ADDR
// PlaceUnitArea ( unit , RussianSpawn2Area , false ) ;
2393: LD_VAR 0 3
2397: PPUSH
2398: LD_INT 7
2400: PPUSH
2401: LD_INT 0
2403: PPUSH
2404: CALL_OW 49
// end ;
2408: GO 2354
2410: POP
2411: POP
// end ;
2412: LD_VAR 0 1
2416: RET
// function PrepareVehicles ; var i , veh ; begin
2417: LD_INT 0
2419: PPUSH
2420: PPUSH
2421: PPUSH
// uc_side = 3 ;
2422: LD_ADDR_OWVAR 20
2426: PUSH
2427: LD_INT 3
2429: ST_TO_ADDR
// uc_nation = 3 ;
2430: LD_ADDR_OWVAR 21
2434: PUSH
2435: LD_INT 3
2437: ST_TO_ADDR
// for i := 1 to 5 do
2438: LD_ADDR_VAR 0 2
2442: PUSH
2443: DOUBLE
2444: LD_INT 1
2446: DEC
2447: ST_TO_ADDR
2448: LD_INT 5
2450: PUSH
2451: FOR_TO
2452: IFFALSE 2562
// begin PrepareVehicle ( ru_medium_wheeled , engine_combustion , control_manual , ru_cargo_bay , rand ( 60 , 80 ) ) ;
2454: LD_INT 21
2456: PPUSH
2457: LD_INT 1
2459: PPUSH
2460: LD_INT 1
2462: PPUSH
2463: LD_INT 51
2465: PPUSH
2466: LD_INT 60
2468: PPUSH
2469: LD_INT 80
2471: PPUSH
2472: CALL_OW 12
2476: PPUSH
2477: CALL 24239 0 5
// veh = CreateVehicle ;
2481: LD_ADDR_VAR 0 3
2485: PUSH
2486: CALL_OW 45
2490: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
2491: LD_VAR 0 3
2495: PPUSH
2496: LD_INT 4
2498: PPUSH
2499: CALL_OW 233
// PlaceUnitArea ( veh , RussianSpawnArea , false ) ;
2503: LD_VAR 0 3
2507: PPUSH
2508: LD_INT 2
2510: PPUSH
2511: LD_INT 0
2513: PPUSH
2514: CALL_OW 49
// if ( i <> 5 ) then
2518: LD_VAR 0 2
2522: PUSH
2523: LD_INT 5
2525: NONEQUAL
2526: IFFALSE 2545
// AddCargo ( veh , mat_cans , 100 ) else
2528: LD_VAR 0 3
2532: PPUSH
2533: LD_INT 1
2535: PPUSH
2536: LD_INT 100
2538: PPUSH
2539: CALL_OW 291
2543: GO 2560
// AddCargo ( veh , mat_oil , 100 ) ;
2545: LD_VAR 0 3
2549: PPUSH
2550: LD_INT 2
2552: PPUSH
2553: LD_INT 100
2555: PPUSH
2556: CALL_OW 291
// end ;
2560: GO 2451
2562: POP
2563: POP
// PrepareVehicle ( ru_medium_wheeled , engine_combustion , control_manual , ru_crane , rand ( 60 , 80 ) ) ;
2564: LD_INT 21
2566: PPUSH
2567: LD_INT 1
2569: PPUSH
2570: LD_INT 1
2572: PPUSH
2573: LD_INT 52
2575: PPUSH
2576: LD_INT 60
2578: PPUSH
2579: LD_INT 80
2581: PPUSH
2582: CALL_OW 12
2586: PPUSH
2587: CALL 24239 0 5
// veh = CreateVehicle ;
2591: LD_ADDR_VAR 0 3
2595: PUSH
2596: CALL_OW 45
2600: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
2601: LD_VAR 0 3
2605: PPUSH
2606: LD_INT 4
2608: PPUSH
2609: CALL_OW 233
// PlaceUnitArea ( veh , RussianSpawnArea , false ) ;
2613: LD_VAR 0 3
2617: PPUSH
2618: LD_INT 2
2620: PPUSH
2621: LD_INT 0
2623: PPUSH
2624: CALL_OW 49
// for i := 1 to 3 do
2628: LD_ADDR_VAR 0 2
2632: PUSH
2633: DOUBLE
2634: LD_INT 1
2636: DEC
2637: ST_TO_ADDR
2638: LD_INT 3
2640: PUSH
2641: FOR_TO
2642: IFFALSE 2710
// begin PrepareVehicle ( ru_heavy_tracked , engine_combustion , control_manual , ru_bulldozer , rand ( 60 , 80 ) ) ;
2644: LD_INT 24
2646: PPUSH
2647: LD_INT 1
2649: PPUSH
2650: LD_INT 1
2652: PPUSH
2653: LD_INT 53
2655: PPUSH
2656: LD_INT 60
2658: PPUSH
2659: LD_INT 80
2661: PPUSH
2662: CALL_OW 12
2666: PPUSH
2667: CALL 24239 0 5
// veh = CreateVehicle ;
2671: LD_ADDR_VAR 0 3
2675: PUSH
2676: CALL_OW 45
2680: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
2681: LD_VAR 0 3
2685: PPUSH
2686: LD_INT 4
2688: PPUSH
2689: CALL_OW 233
// PlaceUnitArea ( veh , RussianSpawnArea , false ) ;
2693: LD_VAR 0 3
2697: PPUSH
2698: LD_INT 2
2700: PPUSH
2701: LD_INT 0
2703: PPUSH
2704: CALL_OW 49
// end ;
2708: GO 2641
2710: POP
2711: POP
// end ;
2712: LD_VAR 0 1
2716: RET
// function InitRussianRequiments ; var i ; begin
2717: LD_INT 0
2719: PPUSH
2720: PPUSH
// availableWeapons = [ ru_heavy_machine_gun , ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher ] ;
2721: LD_ADDR_EXP 11
2725: PUSH
2726: LD_INT 42
2728: PUSH
2729: LD_INT 43
2731: PUSH
2732: LD_INT 44
2734: PUSH
2735: LD_INT 46
2737: PUSH
2738: LD_INT 45
2740: PUSH
2741: EMPTY
2742: LIST
2743: LIST
2744: LIST
2745: LIST
2746: LIST
2747: ST_TO_ADDR
// for i := 1 to availableWeapons do
2748: LD_ADDR_VAR 0 2
2752: PUSH
2753: DOUBLE
2754: LD_INT 1
2756: DEC
2757: ST_TO_ADDR
2758: LD_EXP 11
2762: PUSH
2763: FOR_TO
2764: IFFALSE 2804
// weaponsData = weaponsData ^ [ [ availableWeapons [ i ] , false , false ] ] ;
2766: LD_ADDR_EXP 12
2770: PUSH
2771: LD_EXP 12
2775: PUSH
2776: LD_EXP 11
2780: PUSH
2781: LD_VAR 0 2
2785: ARRAY
2786: PUSH
2787: LD_INT 0
2789: PUSH
2790: LD_INT 0
2792: PUSH
2793: EMPTY
2794: LIST
2795: LIST
2796: LIST
2797: PUSH
2798: EMPTY
2799: LIST
2800: ADD
2801: ST_TO_ADDR
2802: GO 2763
2804: POP
2805: POP
// for i := 0 to 50 do
2806: LD_ADDR_VAR 0 2
2810: PUSH
2811: DOUBLE
2812: LD_INT 0
2814: DEC
2815: ST_TO_ADDR
2816: LD_INT 50
2818: PUSH
2819: FOR_TO
2820: IFFALSE 2858
// if GetRestrict ( i , 3 ) = state_enabled then
2822: LD_VAR 0 2
2826: PPUSH
2827: LD_INT 3
2829: PPUSH
2830: CALL_OW 323
2834: PUSH
2835: LD_INT 1
2837: EQUAL
2838: IFFALSE 2856
// buildingsToBuild = buildingsToBuild ^ i ;
2840: LD_ADDR_EXP 8
2844: PUSH
2845: LD_EXP 8
2849: PUSH
2850: LD_VAR 0 2
2854: ADD
2855: ST_TO_ADDR
2856: GO 2819
2858: POP
2859: POP
// buildingsToBuild = buildingsToBuild diff [ 0 , 2 , 4 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 14 , 22 , 31 , 32 , 33 , 39 , 40 ] ;
2860: LD_ADDR_EXP 8
2864: PUSH
2865: LD_EXP 8
2869: PUSH
2870: LD_INT 0
2872: PUSH
2873: LD_INT 2
2875: PUSH
2876: LD_INT 4
2878: PUSH
2879: LD_INT 6
2881: PUSH
2882: LD_INT 7
2884: PUSH
2885: LD_INT 8
2887: PUSH
2888: LD_INT 9
2890: PUSH
2891: LD_INT 10
2893: PUSH
2894: LD_INT 11
2896: PUSH
2897: LD_INT 12
2899: PUSH
2900: LD_INT 14
2902: PUSH
2903: LD_INT 22
2905: PUSH
2906: LD_INT 31
2908: PUSH
2909: LD_INT 32
2911: PUSH
2912: LD_INT 33
2914: PUSH
2915: LD_INT 39
2917: PUSH
2918: LD_INT 40
2920: PUSH
2921: EMPTY
2922: LIST
2923: LIST
2924: LIST
2925: LIST
2926: LIST
2927: LIST
2928: LIST
2929: LIST
2930: LIST
2931: LIST
2932: LIST
2933: LIST
2934: LIST
2935: LIST
2936: LIST
2937: LIST
2938: LIST
2939: DIFF
2940: ST_TO_ADDR
// allBuildings = buildingsToBuild ;
2941: LD_ADDR_EXP 13
2945: PUSH
2946: LD_EXP 8
2950: ST_TO_ADDR
// techsToResearch = GetTechNation ( 3 , nation_russian , state_enabled ) ;
2951: LD_ADDR_EXP 9
2955: PUSH
2956: LD_INT 3
2958: PPUSH
2959: LD_INT 3
2961: PPUSH
2962: LD_INT 1
2964: PPUSH
2965: CALL 19287 0 3
2969: ST_TO_ADDR
// end ; end_of_file
2970: LD_VAR 0 1
2974: RET
// export amAttackTeam ; export function PrepareAmericans ; begin
2975: LD_INT 0
2977: PPUSH
// amAttackTeam = [ ] ;
2978: LD_ADDR_EXP 78
2982: PUSH
2983: EMPTY
2984: ST_TO_ADDR
// SpawnAmericansSnipers ;
2985: CALL 3119 0 0
// case Difficulty of 2 :
2989: LD_OWVAR 67
2993: PUSH
2994: LD_INT 2
2996: DOUBLE
2997: EQUAL
2998: IFTRUE 3002
3000: GO 3031
3002: POP
// begin SetTech ( tech_comp1 , 1 , state_researched ) ;
3003: LD_INT 57
3005: PPUSH
3006: LD_INT 1
3008: PPUSH
3009: LD_INT 2
3011: PPUSH
3012: CALL_OW 322
// SetTech ( tech_opto1 , 1 , state_researched ) ;
3016: LD_INT 60
3018: PPUSH
3019: LD_INT 1
3021: PPUSH
3022: LD_INT 2
3024: PPUSH
3025: CALL_OW 322
// end ; 3 .. 4 :
3029: GO 3114
3031: LD_INT 3
3033: DOUBLE
3034: GREATEREQUAL
3035: IFFALSE 3043
3037: LD_INT 4
3039: DOUBLE
3040: LESSEQUAL
3041: IFTRUE 3045
3043: GO 3113
3045: POP
// begin SetTech ( tech_comp1 , 1 , state_researched ) ;
3046: LD_INT 57
3048: PPUSH
3049: LD_INT 1
3051: PPUSH
3052: LD_INT 2
3054: PPUSH
3055: CALL_OW 322
// SetTech ( tech_comp2 , 1 , state_researched ) ;
3059: LD_INT 58
3061: PPUSH
3062: LD_INT 1
3064: PPUSH
3065: LD_INT 2
3067: PPUSH
3068: CALL_OW 322
// SetTech ( tech_weap3 , 1 , state_researched ) ;
3072: LD_INT 53
3074: PPUSH
3075: LD_INT 1
3077: PPUSH
3078: LD_INT 2
3080: PPUSH
3081: CALL_OW 322
// SetTech ( tech_opto1 , 1 , state_researched ) ;
3085: LD_INT 60
3087: PPUSH
3088: LD_INT 1
3090: PPUSH
3091: LD_INT 2
3093: PPUSH
3094: CALL_OW 322
// SetTech ( tech_opto2 , 1 , state_researched ) ;
3098: LD_INT 61
3100: PPUSH
3101: LD_INT 1
3103: PPUSH
3104: LD_INT 2
3106: PPUSH
3107: CALL_OW 322
// end ; end ;
3111: GO 3114
3113: POP
// end ;
3114: LD_VAR 0 1
3118: RET
// export function SpawnAmericansSnipers ; var i , un ; begin
3119: LD_INT 0
3121: PPUSH
3122: PPUSH
3123: PPUSH
// uc_side = 1 ;
3124: LD_ADDR_OWVAR 20
3128: PUSH
3129: LD_INT 1
3131: ST_TO_ADDR
// uc_nation = 1 ;
3132: LD_ADDR_OWVAR 21
3136: PUSH
3137: LD_INT 1
3139: ST_TO_ADDR
// for i := 1 to 8 do
3140: LD_ADDR_VAR 0 2
3144: PUSH
3145: DOUBLE
3146: LD_INT 1
3148: DEC
3149: ST_TO_ADDR
3150: LD_INT 8
3152: PUSH
3153: FOR_TO
3154: IFFALSE 3207
// begin PrepareHuman ( false , class_sniper , enemySkillLevel ) ;
3156: LD_INT 0
3158: PPUSH
3159: LD_INT 5
3161: PPUSH
3162: LD_EXP 56
3166: PPUSH
3167: CALL_OW 380
// un = CreateHuman ;
3171: LD_ADDR_VAR 0 3
3175: PUSH
3176: CALL_OW 44
3180: ST_TO_ADDR
// PlaceUnitArea ( un , AmericansSnipersSpawnArea , false ) ;
3181: LD_VAR 0 3
3185: PPUSH
3186: LD_INT 14
3188: PPUSH
3189: LD_INT 0
3191: PPUSH
3192: CALL_OW 49
// ComHold ( un ) ;
3196: LD_VAR 0 3
3200: PPUSH
3201: CALL_OW 140
// end ;
3205: GO 3153
3207: POP
3208: POP
// end ;
3209: LD_VAR 0 1
3213: RET
// export function SpawnAmAttackTeam ; var i , unit , veh , randVehType , weapon , chassis , amSolds , amSnipers , amVehs ; begin
3214: LD_INT 0
3216: PPUSH
3217: PPUSH
3218: PPUSH
3219: PPUSH
3220: PPUSH
3221: PPUSH
3222: PPUSH
3223: PPUSH
3224: PPUSH
3225: PPUSH
// uc_side = 1 ;
3226: LD_ADDR_OWVAR 20
3230: PUSH
3231: LD_INT 1
3233: ST_TO_ADDR
// uc_nation = 1 ;
3234: LD_ADDR_OWVAR 21
3238: PUSH
3239: LD_INT 1
3241: ST_TO_ADDR
// amSolds = Rand ( enemyAttackUnitsData [ 1 ] [ 2 ] , enemyAttackUnitsData [ 1 ] [ 3 ] ) ;
3242: LD_ADDR_VAR 0 8
3246: PUSH
3247: LD_EXP 53
3251: PUSH
3252: LD_INT 1
3254: ARRAY
3255: PUSH
3256: LD_INT 2
3258: ARRAY
3259: PPUSH
3260: LD_EXP 53
3264: PUSH
3265: LD_INT 1
3267: ARRAY
3268: PUSH
3269: LD_INT 3
3271: ARRAY
3272: PPUSH
3273: CALL_OW 12
3277: ST_TO_ADDR
// amSnipers = Rand ( enemyAttackUnitsData [ 1 ] [ 4 ] , enemyAttackUnitsData [ 1 ] [ 5 ] ) ;
3278: LD_ADDR_VAR 0 9
3282: PUSH
3283: LD_EXP 53
3287: PUSH
3288: LD_INT 1
3290: ARRAY
3291: PUSH
3292: LD_INT 4
3294: ARRAY
3295: PPUSH
3296: LD_EXP 53
3300: PUSH
3301: LD_INT 1
3303: ARRAY
3304: PUSH
3305: LD_INT 5
3307: ARRAY
3308: PPUSH
3309: CALL_OW 12
3313: ST_TO_ADDR
// amVehs = Rand ( enemyAttackUnitsData [ 1 ] [ 6 ] , enemyAttackUnitsData [ 1 ] [ 7 ] ) ;
3314: LD_ADDR_VAR 0 10
3318: PUSH
3319: LD_EXP 53
3323: PUSH
3324: LD_INT 1
3326: ARRAY
3327: PUSH
3328: LD_INT 6
3330: ARRAY
3331: PPUSH
3332: LD_EXP 53
3336: PUSH
3337: LD_INT 1
3339: ARRAY
3340: PUSH
3341: LD_INT 7
3343: ARRAY
3344: PPUSH
3345: CALL_OW 12
3349: ST_TO_ADDR
// if paidLegionOffert then
3350: LD_EXP 32
3354: IFFALSE 3388
// begin amSolds = amSolds - legionReduceAmericansUnits ;
3356: LD_ADDR_VAR 0 8
3360: PUSH
3361: LD_VAR 0 8
3365: PUSH
3366: LD_EXP 51
3370: MINUS
3371: ST_TO_ADDR
// amVehs = amVehs - legionReduceAmericansUnits ;
3372: LD_ADDR_VAR 0 10
3376: PUSH
3377: LD_VAR 0 10
3381: PUSH
3382: LD_EXP 51
3386: MINUS
3387: ST_TO_ADDR
// end ; for i := 1 to amSolds do
3388: LD_ADDR_VAR 0 2
3392: PUSH
3393: DOUBLE
3394: LD_INT 1
3396: DEC
3397: ST_TO_ADDR
3398: LD_VAR 0 8
3402: PUSH
3403: FOR_TO
3404: IFFALSE 3461
// begin PrepareSoldier ( false , enemySkillLevel ) ;
3406: LD_INT 0
3408: PPUSH
3409: LD_EXP 56
3413: PPUSH
3414: CALL_OW 381
// unit = CreateHuman ;
3418: LD_ADDR_VAR 0 3
3422: PUSH
3423: CALL_OW 44
3427: ST_TO_ADDR
// PlaceUnitArea ( unit , AmericanSpawnArea , false ) ;
3428: LD_VAR 0 3
3432: PPUSH
3433: LD_INT 3
3435: PPUSH
3436: LD_INT 0
3438: PPUSH
3439: CALL_OW 49
// amAttackTeam = amAttackTeam ^ unit ;
3443: LD_ADDR_EXP 78
3447: PUSH
3448: LD_EXP 78
3452: PUSH
3453: LD_VAR 0 3
3457: ADD
3458: ST_TO_ADDR
// end ;
3459: GO 3403
3461: POP
3462: POP
// for i := 1 to amSnipers do
3463: LD_ADDR_VAR 0 2
3467: PUSH
3468: DOUBLE
3469: LD_INT 1
3471: DEC
3472: ST_TO_ADDR
3473: LD_VAR 0 9
3477: PUSH
3478: FOR_TO
3479: IFFALSE 3539
// begin PrepareHuman ( false , class_sniper , enemySkillLevel ) ;
3481: LD_INT 0
3483: PPUSH
3484: LD_INT 5
3486: PPUSH
3487: LD_EXP 56
3491: PPUSH
3492: CALL_OW 380
// unit = CreateHuman ;
3496: LD_ADDR_VAR 0 3
3500: PUSH
3501: CALL_OW 44
3505: ST_TO_ADDR
// PlaceUnitArea ( unit , AmericanSpawnArea , false ) ;
3506: LD_VAR 0 3
3510: PPUSH
3511: LD_INT 3
3513: PPUSH
3514: LD_INT 0
3516: PPUSH
3517: CALL_OW 49
// amAttackTeam = amAttackTeam ^ unit ;
3521: LD_ADDR_EXP 78
3525: PUSH
3526: LD_EXP 78
3530: PUSH
3531: LD_VAR 0 3
3535: ADD
3536: ST_TO_ADDR
// end ;
3537: GO 3478
3539: POP
3540: POP
// for i := 1 to amVehs do
3541: LD_ADDR_VAR 0 2
3545: PUSH
3546: DOUBLE
3547: LD_INT 1
3549: DEC
3550: ST_TO_ADDR
3551: LD_VAR 0 10
3555: PUSH
3556: FOR_TO
3557: IFFALSE 3840
// begin randVehType = Rand ( 1 , 4 ) ;
3559: LD_ADDR_VAR 0 5
3563: PUSH
3564: LD_INT 1
3566: PPUSH
3567: LD_INT 4
3569: PPUSH
3570: CALL_OW 12
3574: ST_TO_ADDR
// weapon = [ us_gatling_gun , us_double_gun , us_light_gun , us_rocket_launcher , us_heavy_gun ] [ Rand ( 1 , 5 ) ] ;
3575: LD_ADDR_VAR 0 6
3579: PUSH
3580: LD_INT 4
3582: PUSH
3583: LD_INT 5
3585: PUSH
3586: LD_INT 3
3588: PUSH
3589: LD_INT 7
3591: PUSH
3592: LD_INT 6
3594: PUSH
3595: EMPTY
3596: LIST
3597: LIST
3598: LIST
3599: LIST
3600: LIST
3601: PUSH
3602: LD_INT 1
3604: PPUSH
3605: LD_INT 5
3607: PPUSH
3608: CALL_OW 12
3612: ARRAY
3613: ST_TO_ADDR
// if weapon = us_heavy_gun then
3614: LD_VAR 0 6
3618: PUSH
3619: LD_INT 6
3621: EQUAL
3622: IFFALSE 3634
// chassis = us_heavy_tracked else
3624: LD_ADDR_VAR 0 7
3628: PUSH
3629: LD_INT 4
3631: ST_TO_ADDR
3632: GO 3661
// chassis = [ us_medium_tracked , us_heavy_tracked ] [ Rand ( 1 , 2 ) ] ;
3634: LD_ADDR_VAR 0 7
3638: PUSH
3639: LD_INT 3
3641: PUSH
3642: LD_INT 4
3644: PUSH
3645: EMPTY
3646: LIST
3647: LIST
3648: PUSH
3649: LD_INT 1
3651: PPUSH
3652: LD_INT 2
3654: PPUSH
3655: CALL_OW 12
3659: ARRAY
3660: ST_TO_ADDR
// if randVehType = 1 then
3661: LD_VAR 0 5
3665: PUSH
3666: LD_INT 1
3668: EQUAL
3669: IFFALSE 3704
// PrepareVehicle ( chassis , engine_combustion , control_manual , weapon , Rand ( 70 , 90 ) ) else
3671: LD_VAR 0 7
3675: PPUSH
3676: LD_INT 1
3678: PPUSH
3679: LD_INT 1
3681: PPUSH
3682: LD_VAR 0 6
3686: PPUSH
3687: LD_INT 70
3689: PPUSH
3690: LD_INT 90
3692: PPUSH
3693: CALL_OW 12
3697: PPUSH
3698: CALL 24239 0 5
3702: GO 3735
// PrepareVehicle ( chassis , engine_combustion , control_computer , weapon , Rand ( 70 , 90 ) ) ;
3704: LD_VAR 0 7
3708: PPUSH
3709: LD_INT 1
3711: PPUSH
3712: LD_INT 3
3714: PPUSH
3715: LD_VAR 0 6
3719: PPUSH
3720: LD_INT 70
3722: PPUSH
3723: LD_INT 90
3725: PPUSH
3726: CALL_OW 12
3730: PPUSH
3731: CALL 24239 0 5
// veh = CreateVehicle ;
3735: LD_ADDR_VAR 0 4
3739: PUSH
3740: CALL_OW 45
3744: ST_TO_ADDR
// PlaceUnitArea ( veh , AmericanSpawnArea , false ) ;
3745: LD_VAR 0 4
3749: PPUSH
3750: LD_INT 3
3752: PPUSH
3753: LD_INT 0
3755: PPUSH
3756: CALL_OW 49
// amAttackTeam = amAttackTeam ^ veh ;
3760: LD_ADDR_EXP 78
3764: PUSH
3765: LD_EXP 78
3769: PUSH
3770: LD_VAR 0 4
3774: ADD
3775: ST_TO_ADDR
// if randVehType = 1 then
3776: LD_VAR 0 5
3780: PUSH
3781: LD_INT 1
3783: EQUAL
3784: IFFALSE 3838
// begin PrepareMechanic ( false , enemySkillLevel ) ;
3786: LD_INT 0
3788: PPUSH
3789: LD_EXP 56
3793: PPUSH
3794: CALL_OW 383
// unit = CreateHuman ;
3798: LD_ADDR_VAR 0 3
3802: PUSH
3803: CALL_OW 44
3807: ST_TO_ADDR
// PlaceHumanInUnit ( unit , veh ) ;
3808: LD_VAR 0 3
3812: PPUSH
3813: LD_VAR 0 4
3817: PPUSH
3818: CALL_OW 52
// amAttackTeam = amAttackTeam ^ unit ;
3822: LD_ADDR_EXP 78
3826: PUSH
3827: LD_EXP 78
3831: PUSH
3832: LD_VAR 0 3
3836: ADD
3837: ST_TO_ADDR
// end ; end ;
3838: GO 3556
3840: POP
3841: POP
// end ; end_of_file
3842: LD_VAR 0 1
3846: RET
// export Heike , Kurt , Dietrich ; export KurtEng ; export GensherTeam ; export arAttackTeam ; export function PrepareArabians ; begin
3847: LD_INT 0
3849: PPUSH
// arAttackTeam = [ ] ;
3850: LD_ADDR_EXP 84
3854: PUSH
3855: EMPTY
3856: ST_TO_ADDR
// PrepareHeroes ;
3857: CALL 4262 0 0
// case Difficulty of 2 :
3861: LD_OWVAR 67
3865: PUSH
3866: LD_INT 2
3868: DOUBLE
3869: EQUAL
3870: IFTRUE 3874
3872: GO 3890
3874: POP
// begin SetTech ( tech_stimDrugs , 8 , state_researched ) ;
3875: LD_INT 5
3877: PPUSH
3878: LD_INT 8
3880: PPUSH
3881: LD_INT 2
3883: PPUSH
3884: CALL_OW 322
// end ; 3 :
3888: GO 3941
3890: LD_INT 3
3892: DOUBLE
3893: EQUAL
3894: IFTRUE 3898
3896: GO 3940
3898: POP
// begin SetTech ( tech_stimDrugs , 8 , state_researched ) ;
3899: LD_INT 5
3901: PPUSH
3902: LD_INT 8
3904: PPUSH
3905: LD_INT 2
3907: PPUSH
3908: CALL_OW 322
// SetTech ( tech_bio1 , 8 , state_researched ) ;
3912: LD_INT 66
3914: PPUSH
3915: LD_INT 8
3917: PPUSH
3918: LD_INT 2
3920: PPUSH
3921: CALL_OW 322
// SetTech ( tech_weap3 , 8 , state_researched ) ;
3925: LD_INT 53
3927: PPUSH
3928: LD_INT 8
3930: PPUSH
3931: LD_INT 2
3933: PPUSH
3934: CALL_OW 322
// end ; end ;
3938: GO 3941
3940: POP
// end ;
3941: LD_VAR 0 1
3945: RET
// export function SpawnGensherTeam ; var i , driver , veh ; begin
3946: LD_INT 0
3948: PPUSH
3949: PPUSH
3950: PPUSH
3951: PPUSH
// GensherTeam = [ ] ;
3952: LD_ADDR_EXP 83
3956: PUSH
3957: EMPTY
3958: ST_TO_ADDR
// uc_side = 2 ;
3959: LD_ADDR_OWVAR 20
3963: PUSH
3964: LD_INT 2
3966: ST_TO_ADDR
// uc_nation = 2 ;
3967: LD_ADDR_OWVAR 21
3971: PUSH
3972: LD_INT 2
3974: ST_TO_ADDR
// for i := 1 to 3 do
3975: LD_ADDR_VAR 0 2
3979: PUSH
3980: DOUBLE
3981: LD_INT 1
3983: DEC
3984: ST_TO_ADDR
3985: LD_INT 3
3987: PUSH
3988: FOR_TO
3989: IFFALSE 4148
// begin PrepareSoldier ( sex_male , rand ( 3 , 5 ) ) ;
3991: LD_INT 1
3993: PPUSH
3994: LD_INT 3
3996: PPUSH
3997: LD_INT 5
3999: PPUSH
4000: CALL_OW 12
4004: PPUSH
4005: CALL_OW 381
// driver = CreateHuman ;
4009: LD_ADDR_VAR 0 3
4013: PUSH
4014: CALL_OW 44
4018: ST_TO_ADDR
// PrepareVehicle ( ar_medium_trike , engine_combustion , control_manual , ar_cargo_bay , rand ( 50 , 70 ) ) ;
4019: LD_INT 13
4021: PPUSH
4022: LD_INT 1
4024: PPUSH
4025: LD_INT 1
4027: PPUSH
4028: LD_INT 32
4030: PPUSH
4031: LD_INT 50
4033: PPUSH
4034: LD_INT 70
4036: PPUSH
4037: CALL_OW 12
4041: PPUSH
4042: CALL 24239 0 5
// veh = CreateVehicle ;
4046: LD_ADDR_VAR 0 4
4050: PUSH
4051: CALL_OW 45
4055: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
4056: LD_VAR 0 4
4060: PPUSH
4061: LD_INT 4
4063: PPUSH
4064: CALL_OW 233
// PlaceUnitArea ( veh , GensherSpawnArea , false ) ;
4068: LD_VAR 0 4
4072: PPUSH
4073: LD_INT 4
4075: PPUSH
4076: LD_INT 0
4078: PPUSH
4079: CALL_OW 49
// PlaceHumanInUnit ( driver , veh ) ;
4083: LD_VAR 0 3
4087: PPUSH
4088: LD_VAR 0 4
4092: PPUSH
4093: CALL_OW 52
// AddCargo ( veh , i , 100 ) ;
4097: LD_VAR 0 4
4101: PPUSH
4102: LD_VAR 0 2
4106: PPUSH
4107: LD_INT 100
4109: PPUSH
4110: CALL_OW 291
// GensherTeam = GensherTeam ^ driver ;
4114: LD_ADDR_EXP 83
4118: PUSH
4119: LD_EXP 83
4123: PUSH
4124: LD_VAR 0 3
4128: ADD
4129: ST_TO_ADDR
// GensherTeam = GensherTeam ^ veh ;
4130: LD_ADDR_EXP 83
4134: PUSH
4135: LD_EXP 83
4139: PUSH
4140: LD_VAR 0 4
4144: ADD
4145: ST_TO_ADDR
// end ;
4146: GO 3988
4148: POP
4149: POP
// if IsOK ( KurtEng ) and GetSide ( KurtEng ) = 3 then
4150: LD_EXP 82
4154: PPUSH
4155: CALL_OW 302
4159: PUSH
4160: LD_EXP 82
4164: PPUSH
4165: CALL_OW 255
4169: PUSH
4170: LD_INT 3
4172: EQUAL
4173: AND
4174: IFFALSE 4208
// begin GensherTargetX = GetX ( Kurt ) ;
4176: LD_ADDR_EXP 16
4180: PUSH
4181: LD_EXP 80
4185: PPUSH
4186: CALL_OW 250
4190: ST_TO_ADDR
// GensherTargetY = GetY ( Kurt ) ;
4191: LD_ADDR_EXP 17
4195: PUSH
4196: LD_EXP 80
4200: PPUSH
4201: CALL_OW 251
4205: ST_TO_ADDR
// end else
4206: GO 4238
// begin GensherTargetX = GetX ( Burlak ) ;
4208: LD_ADDR_EXP 16
4212: PUSH
4213: LD_EXP 57
4217: PPUSH
4218: CALL_OW 250
4222: ST_TO_ADDR
// GensherTargetY = GetY ( Burlak ) ;
4223: LD_ADDR_EXP 17
4227: PUSH
4228: LD_EXP 57
4232: PPUSH
4233: CALL_OW 251
4237: ST_TO_ADDR
// end ; ComMoveXY ( GensherTeam , GensherTargetX , GensherTargetY ) ;
4238: LD_EXP 83
4242: PPUSH
4243: LD_EXP 16
4247: PPUSH
4248: LD_EXP 17
4252: PPUSH
4253: CALL_OW 111
// end ;
4257: LD_VAR 0 1
4261: RET
// function PrepareHeroes ; begin
4262: LD_INT 0
4264: PPUSH
// uc_side = 5 ;
4265: LD_ADDR_OWVAR 20
4269: PUSH
4270: LD_INT 5
4272: ST_TO_ADDR
// uc_nation = 2 ;
4273: LD_ADDR_OWVAR 21
4277: PUSH
4278: LD_INT 2
4280: ST_TO_ADDR
// Heike = PrepareUnitExt ( Heike , true , class_engineer ) ;
4281: LD_ADDR_EXP 79
4285: PUSH
4286: LD_STRING Heike
4288: PPUSH
4289: LD_INT 1
4291: PPUSH
4292: LD_INT 2
4294: PPUSH
4295: CALL 5930 0 3
4299: ST_TO_ADDR
// uc_side = 8 ;
4300: LD_ADDR_OWVAR 20
4304: PUSH
4305: LD_INT 8
4307: ST_TO_ADDR
// Kurt = PrepareUnitExt ( Kurt , false , 0 ) ;
4308: LD_ADDR_EXP 80
4312: PUSH
4313: LD_STRING Kurt
4315: PPUSH
4316: LD_INT 0
4318: PPUSH
4319: LD_INT 0
4321: PPUSH
4322: CALL 5930 0 3
4326: ST_TO_ADDR
// uc_side = 2 ;
4327: LD_ADDR_OWVAR 20
4331: PUSH
4332: LD_INT 2
4334: ST_TO_ADDR
// Dietrich = PrepareUnitExt ( Dietrich , false , 0 ) ;
4335: LD_ADDR_EXP 81
4339: PUSH
4340: LD_STRING Dietrich
4342: PPUSH
4343: LD_INT 0
4345: PPUSH
4346: LD_INT 0
4348: PPUSH
4349: CALL 5930 0 3
4353: ST_TO_ADDR
// end ;
4354: LD_VAR 0 1
4358: RET
// export function SpawnArAttackTeam ; var i , unit , veh , weapon , chassis ; begin
4359: LD_INT 0
4361: PPUSH
4362: PPUSH
4363: PPUSH
4364: PPUSH
4365: PPUSH
4366: PPUSH
// uc_side = 8 ;
4367: LD_ADDR_OWVAR 20
4371: PUSH
4372: LD_INT 8
4374: ST_TO_ADDR
// uc_nation = 2 ;
4375: LD_ADDR_OWVAR 21
4379: PUSH
4380: LD_INT 2
4382: ST_TO_ADDR
// for i := 1 to Rand ( enemyAttackUnitsData [ 1 ] [ 2 ] , enemyAttackUnitsData [ 1 ] [ 3 ] ) do
4383: LD_ADDR_VAR 0 2
4387: PUSH
4388: DOUBLE
4389: LD_INT 1
4391: DEC
4392: ST_TO_ADDR
4393: LD_EXP 53
4397: PUSH
4398: LD_INT 1
4400: ARRAY
4401: PUSH
4402: LD_INT 2
4404: ARRAY
4405: PPUSH
4406: LD_EXP 53
4410: PUSH
4411: LD_INT 1
4413: ARRAY
4414: PUSH
4415: LD_INT 3
4417: ARRAY
4418: PPUSH
4419: CALL_OW 12
4423: PUSH
4424: FOR_TO
4425: IFFALSE 4482
// begin PrepareSoldier ( false , enemySkillLevel ) ;
4427: LD_INT 0
4429: PPUSH
4430: LD_EXP 56
4434: PPUSH
4435: CALL_OW 381
// unit = CreateHuman ;
4439: LD_ADDR_VAR 0 3
4443: PUSH
4444: CALL_OW 44
4448: ST_TO_ADDR
// PlaceUnitArea ( unit , KurtUnitsSpawnArea , false ) ;
4449: LD_VAR 0 3
4453: PPUSH
4454: LD_INT 10
4456: PPUSH
4457: LD_INT 0
4459: PPUSH
4460: CALL_OW 49
// arAttackTeam = arAttackTeam ^ unit ;
4464: LD_ADDR_EXP 84
4468: PUSH
4469: LD_EXP 84
4473: PUSH
4474: LD_VAR 0 3
4478: ADD
4479: ST_TO_ADDR
// end ;
4480: GO 4424
4482: POP
4483: POP
// for i := 1 to Rand ( enemyAttackUnitsData [ 1 ] [ 4 ] , enemyAttackUnitsData [ 1 ] [ 5 ] ) do
4484: LD_ADDR_VAR 0 2
4488: PUSH
4489: DOUBLE
4490: LD_INT 1
4492: DEC
4493: ST_TO_ADDR
4494: LD_EXP 53
4498: PUSH
4499: LD_INT 1
4501: ARRAY
4502: PUSH
4503: LD_INT 4
4505: ARRAY
4506: PPUSH
4507: LD_EXP 53
4511: PUSH
4512: LD_INT 1
4514: ARRAY
4515: PUSH
4516: LD_INT 5
4518: ARRAY
4519: PPUSH
4520: CALL_OW 12
4524: PUSH
4525: FOR_TO
4526: IFFALSE 4586
// begin PrepareHuman ( false , class_mortar , enemySkillLevel ) ;
4528: LD_INT 0
4530: PPUSH
4531: LD_INT 8
4533: PPUSH
4534: LD_EXP 56
4538: PPUSH
4539: CALL_OW 380
// unit = CreateHuman ;
4543: LD_ADDR_VAR 0 3
4547: PUSH
4548: CALL_OW 44
4552: ST_TO_ADDR
// PlaceUnitArea ( unit , KurtUnitsSpawnArea , false ) ;
4553: LD_VAR 0 3
4557: PPUSH
4558: LD_INT 10
4560: PPUSH
4561: LD_INT 0
4563: PPUSH
4564: CALL_OW 49
// arAttackTeam = arAttackTeam ^ unit ;
4568: LD_ADDR_EXP 84
4572: PUSH
4573: LD_EXP 84
4577: PUSH
4578: LD_VAR 0 3
4582: ADD
4583: ST_TO_ADDR
// end ;
4584: GO 4525
4586: POP
4587: POP
// for i := 1 to Rand ( enemyAttackUnitsData [ 1 ] [ 6 ] , enemyAttackUnitsData [ 1 ] [ 7 ] ) do
4588: LD_ADDR_VAR 0 2
4592: PUSH
4593: DOUBLE
4594: LD_INT 1
4596: DEC
4597: ST_TO_ADDR
4598: LD_EXP 53
4602: PUSH
4603: LD_INT 1
4605: ARRAY
4606: PUSH
4607: LD_INT 6
4609: ARRAY
4610: PPUSH
4611: LD_EXP 53
4615: PUSH
4616: LD_INT 1
4618: ARRAY
4619: PUSH
4620: LD_INT 7
4622: ARRAY
4623: PPUSH
4624: CALL_OW 12
4628: PUSH
4629: FOR_TO
4630: IFFALSE 4824
// begin weapon = [ ar_gun , ar_flame_thrower , ar_rocket_launcher , ar_light_gun , ar_gatling_gun ] [ Rand ( 1 , 5 ) ] ;
4632: LD_ADDR_VAR 0 5
4636: PUSH
4637: LD_INT 27
4639: PUSH
4640: LD_INT 26
4642: PUSH
4643: LD_INT 28
4645: PUSH
4646: LD_INT 23
4648: PUSH
4649: LD_INT 25
4651: PUSH
4652: EMPTY
4653: LIST
4654: LIST
4655: LIST
4656: LIST
4657: LIST
4658: PUSH
4659: LD_INT 1
4661: PPUSH
4662: LD_INT 5
4664: PPUSH
4665: CALL_OW 12
4669: ARRAY
4670: ST_TO_ADDR
// chassis = [ ar_medium_trike , ar_half_tracked ] [ Rand ( 1 , 2 ) ] ;
4671: LD_ADDR_VAR 0 6
4675: PUSH
4676: LD_INT 13
4678: PUSH
4679: LD_INT 14
4681: PUSH
4682: EMPTY
4683: LIST
4684: LIST
4685: PUSH
4686: LD_INT 1
4688: PPUSH
4689: LD_INT 2
4691: PPUSH
4692: CALL_OW 12
4696: ARRAY
4697: ST_TO_ADDR
// PrepareVehicle ( chassis , engine_combustion , control_manual , weapon , Rand ( 70 , 90 ) ) ;
4698: LD_VAR 0 6
4702: PPUSH
4703: LD_INT 1
4705: PPUSH
4706: LD_INT 1
4708: PPUSH
4709: LD_VAR 0 5
4713: PPUSH
4714: LD_INT 70
4716: PPUSH
4717: LD_INT 90
4719: PPUSH
4720: CALL_OW 12
4724: PPUSH
4725: CALL 24239 0 5
// veh = CreateVehicle ;
4729: LD_ADDR_VAR 0 4
4733: PUSH
4734: CALL_OW 45
4738: ST_TO_ADDR
// PlaceUnitArea ( veh , KurtUnitsSpawnArea , false ) ;
4739: LD_VAR 0 4
4743: PPUSH
4744: LD_INT 10
4746: PPUSH
4747: LD_INT 0
4749: PPUSH
4750: CALL_OW 49
// arAttackTeam = arAttackTeam ^ veh ;
4754: LD_ADDR_EXP 84
4758: PUSH
4759: LD_EXP 84
4763: PUSH
4764: LD_VAR 0 4
4768: ADD
4769: ST_TO_ADDR
// PrepareMechanic ( false , enemySkillLevel ) ;
4770: LD_INT 0
4772: PPUSH
4773: LD_EXP 56
4777: PPUSH
4778: CALL_OW 383
// unit = CreateHuman ;
4782: LD_ADDR_VAR 0 3
4786: PUSH
4787: CALL_OW 44
4791: ST_TO_ADDR
// PlaceHumanInUnit ( unit , veh ) ;
4792: LD_VAR 0 3
4796: PPUSH
4797: LD_VAR 0 4
4801: PPUSH
4802: CALL_OW 52
// arAttackTeam = arAttackTeam ^ unit ;
4806: LD_ADDR_EXP 84
4810: PUSH
4811: LD_EXP 84
4815: PUSH
4816: LD_VAR 0 3
4820: ADD
4821: ST_TO_ADDR
// end ;
4822: GO 4629
4824: POP
4825: POP
// end ; end_of_file
4826: LD_VAR 0 1
4830: RET
// export function Nef_PrepareNature ; var i , un ; begin
4831: LD_INT 0
4833: PPUSH
4834: PPUSH
4835: PPUSH
// for i := 1 to animalsAmount [ 1 ] do
4836: LD_ADDR_VAR 0 2
4840: PUSH
4841: DOUBLE
4842: LD_INT 1
4844: DEC
4845: ST_TO_ADDR
4846: LD_EXP 41
4850: PUSH
4851: LD_INT 1
4853: ARRAY
4854: PUSH
4855: FOR_TO
4856: IFFALSE 4966
// begin uc_side = 0 ;
4858: LD_ADDR_OWVAR 20
4862: PUSH
4863: LD_INT 0
4865: ST_TO_ADDR
// uc_nation = nation_nature ;
4866: LD_ADDR_OWVAR 21
4870: PUSH
4871: LD_INT 0
4873: ST_TO_ADDR
// hc_class = class_apeman ;
4874: LD_ADDR_OWVAR 28
4878: PUSH
4879: LD_INT 12
4881: ST_TO_ADDR
// hc_skills = [ animalsStats [ 1 ] , animalsStats [ 2 ] , animalsStats [ 3 ] , animalsStats [ 4 ] ] ;
4882: LD_ADDR_OWVAR 31
4886: PUSH
4887: LD_EXP 42
4891: PUSH
4892: LD_INT 1
4894: ARRAY
4895: PUSH
4896: LD_EXP 42
4900: PUSH
4901: LD_INT 2
4903: ARRAY
4904: PUSH
4905: LD_EXP 42
4909: PUSH
4910: LD_INT 3
4912: ARRAY
4913: PUSH
4914: LD_EXP 42
4918: PUSH
4919: LD_INT 4
4921: ARRAY
4922: PUSH
4923: EMPTY
4924: LIST
4925: LIST
4926: LIST
4927: LIST
4928: ST_TO_ADDR
// hc_agressivity = animalsAgression ;
4929: LD_ADDR_OWVAR 35
4933: PUSH
4934: LD_EXP 43
4938: ST_TO_ADDR
// un = CreateHuman ;
4939: LD_ADDR_VAR 0 3
4943: PUSH
4944: CALL_OW 44
4948: ST_TO_ADDR
// PlaceUnitArea ( un , NatureArea , false ) ;
4949: LD_VAR 0 3
4953: PPUSH
4954: LD_INT 5
4956: PPUSH
4957: LD_INT 0
4959: PPUSH
4960: CALL_OW 49
// end ;
4964: GO 4855
4966: POP
4967: POP
// for i := 1 to animalsAmount [ 2 ] do
4968: LD_ADDR_VAR 0 2
4972: PUSH
4973: DOUBLE
4974: LD_INT 1
4976: DEC
4977: ST_TO_ADDR
4978: LD_EXP 41
4982: PUSH
4983: LD_INT 2
4985: ARRAY
4986: PUSH
4987: FOR_TO
4988: IFFALSE 5098
// begin uc_side = 0 ;
4990: LD_ADDR_OWVAR 20
4994: PUSH
4995: LD_INT 0
4997: ST_TO_ADDR
// uc_nation = nation_nature ;
4998: LD_ADDR_OWVAR 21
5002: PUSH
5003: LD_INT 0
5005: ST_TO_ADDR
// hc_class = class_phororhacos ;
5006: LD_ADDR_OWVAR 28
5010: PUSH
5011: LD_INT 18
5013: ST_TO_ADDR
// hc_skills = [ animalsStats [ 1 ] , animalsStats [ 2 ] , animalsStats [ 3 ] , animalsStats [ 4 ] ] ;
5014: LD_ADDR_OWVAR 31
5018: PUSH
5019: LD_EXP 42
5023: PUSH
5024: LD_INT 1
5026: ARRAY
5027: PUSH
5028: LD_EXP 42
5032: PUSH
5033: LD_INT 2
5035: ARRAY
5036: PUSH
5037: LD_EXP 42
5041: PUSH
5042: LD_INT 3
5044: ARRAY
5045: PUSH
5046: LD_EXP 42
5050: PUSH
5051: LD_INT 4
5053: ARRAY
5054: PUSH
5055: EMPTY
5056: LIST
5057: LIST
5058: LIST
5059: LIST
5060: ST_TO_ADDR
// hc_agressivity = animalsAgression ;
5061: LD_ADDR_OWVAR 35
5065: PUSH
5066: LD_EXP 43
5070: ST_TO_ADDR
// un = CreateHuman ;
5071: LD_ADDR_VAR 0 3
5075: PUSH
5076: CALL_OW 44
5080: ST_TO_ADDR
// PlaceUnitArea ( un , NatureArea , false ) ;
5081: LD_VAR 0 3
5085: PPUSH
5086: LD_INT 5
5088: PPUSH
5089: LD_INT 0
5091: PPUSH
5092: CALL_OW 49
// end ;
5096: GO 4987
5098: POP
5099: POP
// for i := 1 to animalsAmount [ 3 ] do
5100: LD_ADDR_VAR 0 2
5104: PUSH
5105: DOUBLE
5106: LD_INT 1
5108: DEC
5109: ST_TO_ADDR
5110: LD_EXP 41
5114: PUSH
5115: LD_INT 3
5117: ARRAY
5118: PUSH
5119: FOR_TO
5120: IFFALSE 5230
// begin uc_side = 0 ;
5122: LD_ADDR_OWVAR 20
5126: PUSH
5127: LD_INT 0
5129: ST_TO_ADDR
// uc_nation = nation_nature ;
5130: LD_ADDR_OWVAR 21
5134: PUSH
5135: LD_INT 0
5137: ST_TO_ADDR
// hc_class = class_tiger ;
5138: LD_ADDR_OWVAR 28
5142: PUSH
5143: LD_INT 14
5145: ST_TO_ADDR
// hc_skills = [ animalsStats [ 1 ] , animalsStats [ 2 ] , animalsStats [ 3 ] , animalsStats [ 4 ] ] ;
5146: LD_ADDR_OWVAR 31
5150: PUSH
5151: LD_EXP 42
5155: PUSH
5156: LD_INT 1
5158: ARRAY
5159: PUSH
5160: LD_EXP 42
5164: PUSH
5165: LD_INT 2
5167: ARRAY
5168: PUSH
5169: LD_EXP 42
5173: PUSH
5174: LD_INT 3
5176: ARRAY
5177: PUSH
5178: LD_EXP 42
5182: PUSH
5183: LD_INT 4
5185: ARRAY
5186: PUSH
5187: EMPTY
5188: LIST
5189: LIST
5190: LIST
5191: LIST
5192: ST_TO_ADDR
// hc_agressivity = animalsAgression ;
5193: LD_ADDR_OWVAR 35
5197: PUSH
5198: LD_EXP 43
5202: ST_TO_ADDR
// un = CreateHuman ;
5203: LD_ADDR_VAR 0 3
5207: PUSH
5208: CALL_OW 44
5212: ST_TO_ADDR
// PlaceUnitArea ( un , NatureArea , false ) ;
5213: LD_VAR 0 3
5217: PPUSH
5218: LD_INT 5
5220: PPUSH
5221: LD_INT 0
5223: PPUSH
5224: CALL_OW 49
// end ;
5228: GO 5119
5230: POP
5231: POP
// for i := 1 to animalsAmount [ 4 ] do
5232: LD_ADDR_VAR 0 2
5236: PUSH
5237: DOUBLE
5238: LD_INT 1
5240: DEC
5241: ST_TO_ADDR
5242: LD_EXP 41
5246: PUSH
5247: LD_INT 4
5249: ARRAY
5250: PUSH
5251: FOR_TO
5252: IFFALSE 5362
// begin uc_side = 0 ;
5254: LD_ADDR_OWVAR 20
5258: PUSH
5259: LD_INT 0
5261: ST_TO_ADDR
// uc_nation = nation_nature ;
5262: LD_ADDR_OWVAR 21
5266: PUSH
5267: LD_INT 0
5269: ST_TO_ADDR
// hc_class = 21 ;
5270: LD_ADDR_OWVAR 28
5274: PUSH
5275: LD_INT 21
5277: ST_TO_ADDR
// hc_skills = [ animalsStats [ 1 ] , animalsStats [ 2 ] , animalsStats [ 3 ] , animalsStats [ 4 ] ] ;
5278: LD_ADDR_OWVAR 31
5282: PUSH
5283: LD_EXP 42
5287: PUSH
5288: LD_INT 1
5290: ARRAY
5291: PUSH
5292: LD_EXP 42
5296: PUSH
5297: LD_INT 2
5299: ARRAY
5300: PUSH
5301: LD_EXP 42
5305: PUSH
5306: LD_INT 3
5308: ARRAY
5309: PUSH
5310: LD_EXP 42
5314: PUSH
5315: LD_INT 4
5317: ARRAY
5318: PUSH
5319: EMPTY
5320: LIST
5321: LIST
5322: LIST
5323: LIST
5324: ST_TO_ADDR
// hc_agressivity = animalsAgression ;
5325: LD_ADDR_OWVAR 35
5329: PUSH
5330: LD_EXP 43
5334: ST_TO_ADDR
// un = CreateHuman ;
5335: LD_ADDR_VAR 0 3
5339: PUSH
5340: CALL_OW 44
5344: ST_TO_ADDR
// PlaceUnitArea ( un , NatureArea , false ) ;
5345: LD_VAR 0 3
5349: PPUSH
5350: LD_INT 5
5352: PPUSH
5353: LD_INT 0
5355: PPUSH
5356: CALL_OW 49
// end ;
5360: GO 5251
5362: POP
5363: POP
// for i := 1 to animalsAmount [ 5 ] do
5364: LD_ADDR_VAR 0 2
5368: PUSH
5369: DOUBLE
5370: LD_INT 1
5372: DEC
5373: ST_TO_ADDR
5374: LD_EXP 41
5378: PUSH
5379: LD_INT 5
5381: ARRAY
5382: PUSH
5383: FOR_TO
5384: IFFALSE 5445
// begin uc_side = 0 ;
5386: LD_ADDR_OWVAR 20
5390: PUSH
5391: LD_INT 0
5393: ST_TO_ADDR
// uc_nation = nation_nature ;
5394: LD_ADDR_OWVAR 21
5398: PUSH
5399: LD_INT 0
5401: ST_TO_ADDR
// vc_chassis := 31 ;
5402: LD_ADDR_OWVAR 37
5406: PUSH
5407: LD_INT 31
5409: ST_TO_ADDR
// vc_control := control_rider ;
5410: LD_ADDR_OWVAR 38
5414: PUSH
5415: LD_INT 4
5417: ST_TO_ADDR
// un := CreateVehicle ;
5418: LD_ADDR_VAR 0 3
5422: PUSH
5423: CALL_OW 45
5427: ST_TO_ADDR
// PlaceUnitArea ( un , NatureArea , false ) ;
5428: LD_VAR 0 3
5432: PPUSH
5433: LD_INT 5
5435: PPUSH
5436: LD_INT 0
5438: PPUSH
5439: CALL_OW 49
// end ;
5443: GO 5383
5445: POP
5446: POP
// end ;
5447: LD_VAR 0 1
5451: RET
// export function SpawnTrees ; begin
5452: LD_INT 0
5454: PPUSH
// PlaceTreesToArea ( TreeArea , [ 2 , 10 , 11 , 27 , 35 ] , 40 , 10 , 4 ) ;
5455: LD_INT 1
5457: PPUSH
5458: LD_INT 2
5460: PUSH
5461: LD_INT 10
5463: PUSH
5464: LD_INT 11
5466: PUSH
5467: LD_INT 27
5469: PUSH
5470: LD_INT 35
5472: PUSH
5473: EMPTY
5474: LIST
5475: LIST
5476: LIST
5477: LIST
5478: LIST
5479: PPUSH
5480: LD_INT 40
5482: PPUSH
5483: LD_INT 10
5485: PPUSH
5486: LD_INT 4
5488: PPUSH
5489: CALL_OW 352
// PlaceTreesToArea ( TreeArea , [ 9 , 10 , 27 , 35 , 48 ] , 30 , 10 , 4 ) ;
5493: LD_INT 1
5495: PPUSH
5496: LD_INT 9
5498: PUSH
5499: LD_INT 10
5501: PUSH
5502: LD_INT 27
5504: PUSH
5505: LD_INT 35
5507: PUSH
5508: LD_INT 48
5510: PUSH
5511: EMPTY
5512: LIST
5513: LIST
5514: LIST
5515: LIST
5516: LIST
5517: PPUSH
5518: LD_INT 30
5520: PPUSH
5521: LD_INT 10
5523: PPUSH
5524: LD_INT 4
5526: PPUSH
5527: CALL_OW 352
// PlaceTreesToArea ( TreeArea , [ 2 , 9 , 10 , 11 , 27 ] , 60 , 10 , 4 ) ;
5531: LD_INT 1
5533: PPUSH
5534: LD_INT 2
5536: PUSH
5537: LD_INT 9
5539: PUSH
5540: LD_INT 10
5542: PUSH
5543: LD_INT 11
5545: PUSH
5546: LD_INT 27
5548: PUSH
5549: EMPTY
5550: LIST
5551: LIST
5552: LIST
5553: LIST
5554: LIST
5555: PPUSH
5556: LD_INT 60
5558: PPUSH
5559: LD_INT 10
5561: PPUSH
5562: LD_INT 4
5564: PPUSH
5565: CALL_OW 352
// PlaceTreesToArea ( TreeArea , [ 9 , 10 , 27 , 35 , 48 ] , 90 , 10 , 4 ) ;
5569: LD_INT 1
5571: PPUSH
5572: LD_INT 9
5574: PUSH
5575: LD_INT 10
5577: PUSH
5578: LD_INT 27
5580: PUSH
5581: LD_INT 35
5583: PUSH
5584: LD_INT 48
5586: PUSH
5587: EMPTY
5588: LIST
5589: LIST
5590: LIST
5591: LIST
5592: LIST
5593: PPUSH
5594: LD_INT 90
5596: PPUSH
5597: LD_INT 10
5599: PPUSH
5600: LD_INT 4
5602: PPUSH
5603: CALL_OW 352
// PlaceTreesToArea ( TreeArea , [ 2 , 9 , 10 , 11 , 48 ] , 120 , 10 , 4 ) ;
5607: LD_INT 1
5609: PPUSH
5610: LD_INT 2
5612: PUSH
5613: LD_INT 9
5615: PUSH
5616: LD_INT 10
5618: PUSH
5619: LD_INT 11
5621: PUSH
5622: LD_INT 48
5624: PUSH
5625: EMPTY
5626: LIST
5627: LIST
5628: LIST
5629: LIST
5630: LIST
5631: PPUSH
5632: LD_INT 120
5634: PPUSH
5635: LD_INT 10
5637: PPUSH
5638: LD_INT 4
5640: PPUSH
5641: CALL_OW 352
// PlaceTreesToArea ( TreeArea , [ 2 , 11 , 27 , 35 , 48 ] , 45 , 10 , 4 ) ;
5645: LD_INT 1
5647: PPUSH
5648: LD_INT 2
5650: PUSH
5651: LD_INT 11
5653: PUSH
5654: LD_INT 27
5656: PUSH
5657: LD_INT 35
5659: PUSH
5660: LD_INT 48
5662: PUSH
5663: EMPTY
5664: LIST
5665: LIST
5666: LIST
5667: LIST
5668: LIST
5669: PPUSH
5670: LD_INT 45
5672: PPUSH
5673: LD_INT 10
5675: PPUSH
5676: LD_INT 4
5678: PPUSH
5679: CALL_OW 352
// end ;
5683: LD_VAR 0 1
5687: RET
// every 0 0$1 do var i , un ;
5688: GO 5690
5690: DISABLE
5691: LD_INT 0
5693: PPUSH
5694: PPUSH
// begin if ( GetTech ( tech_apelang , 3 ) = state_enabled or GetTech ( tech_apepsych , 3 ) = state_enabled or GetTech ( tech_apeagres , 3 ) = state_enabled ) and not FilterAllUnits ( [ [ f_or , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman_soldier ] ] ] ) then
5695: LD_INT 1
5697: PPUSH
5698: LD_INT 3
5700: PPUSH
5701: CALL_OW 321
5705: PUSH
5706: LD_INT 1
5708: EQUAL
5709: PUSH
5710: LD_INT 2
5712: PPUSH
5713: LD_INT 3
5715: PPUSH
5716: CALL_OW 321
5720: PUSH
5721: LD_INT 1
5723: EQUAL
5724: OR
5725: PUSH
5726: LD_INT 11
5728: PPUSH
5729: LD_INT 3
5731: PPUSH
5732: CALL_OW 321
5736: PUSH
5737: LD_INT 1
5739: EQUAL
5740: OR
5741: PUSH
5742: LD_INT 2
5744: PUSH
5745: LD_INT 25
5747: PUSH
5748: LD_INT 12
5750: PUSH
5751: EMPTY
5752: LIST
5753: LIST
5754: PUSH
5755: LD_INT 25
5757: PUSH
5758: LD_INT 16
5760: PUSH
5761: EMPTY
5762: LIST
5763: LIST
5764: PUSH
5765: LD_INT 25
5767: PUSH
5768: LD_INT 15
5770: PUSH
5771: EMPTY
5772: LIST
5773: LIST
5774: PUSH
5775: EMPTY
5776: LIST
5777: LIST
5778: LIST
5779: LIST
5780: PUSH
5781: EMPTY
5782: LIST
5783: PPUSH
5784: CALL_OW 69
5788: NOT
5789: AND
5790: IFFALSE 5926
// begin for i := 1 to Rand ( 2 , 4 ) do
5792: LD_ADDR_VAR 0 1
5796: PUSH
5797: DOUBLE
5798: LD_INT 1
5800: DEC
5801: ST_TO_ADDR
5802: LD_INT 2
5804: PPUSH
5805: LD_INT 4
5807: PPUSH
5808: CALL_OW 12
5812: PUSH
5813: FOR_TO
5814: IFFALSE 5924
// begin uc_side = 0 ;
5816: LD_ADDR_OWVAR 20
5820: PUSH
5821: LD_INT 0
5823: ST_TO_ADDR
// uc_nation = nation_nature ;
5824: LD_ADDR_OWVAR 21
5828: PUSH
5829: LD_INT 0
5831: ST_TO_ADDR
// hc_class = class_apeman ;
5832: LD_ADDR_OWVAR 28
5836: PUSH
5837: LD_INT 12
5839: ST_TO_ADDR
// hc_skills = [ animalsStats [ 1 ] , animalsStats [ 2 ] , animalsStats [ 3 ] , animalsStats [ 4 ] ] ;
5840: LD_ADDR_OWVAR 31
5844: PUSH
5845: LD_EXP 42
5849: PUSH
5850: LD_INT 1
5852: ARRAY
5853: PUSH
5854: LD_EXP 42
5858: PUSH
5859: LD_INT 2
5861: ARRAY
5862: PUSH
5863: LD_EXP 42
5867: PUSH
5868: LD_INT 3
5870: ARRAY
5871: PUSH
5872: LD_EXP 42
5876: PUSH
5877: LD_INT 4
5879: ARRAY
5880: PUSH
5881: EMPTY
5882: LIST
5883: LIST
5884: LIST
5885: LIST
5886: ST_TO_ADDR
// hc_agressivity = animalsAgression ;
5887: LD_ADDR_OWVAR 35
5891: PUSH
5892: LD_EXP 43
5896: ST_TO_ADDR
// un = CreateHuman ;
5897: LD_ADDR_VAR 0 2
5901: PUSH
5902: CALL_OW 44
5906: ST_TO_ADDR
// PlaceUnitArea ( un , NatureArea , false ) ;
5907: LD_VAR 0 2
5911: PPUSH
5912: LD_INT 5
5914: PPUSH
5915: LD_INT 0
5917: PPUSH
5918: CALL_OW 49
// end ;
5922: GO 5813
5924: POP
5925: POP
// end ; enable ;
5926: ENABLE
// end ; end_of_file
5927: PPOPN 2
5929: END
// export function PrepareUnitExt ( ident , exist_mode , class ) ; var unit ; begin
5930: LD_INT 0
5932: PPUSH
5933: PPUSH
// if debugMode then
5934: LD_EXP 46
5938: IFFALSE 5955
// unit := NewCharacter ( ident ) ;
5940: LD_ADDR_VAR 0 5
5944: PUSH
5945: LD_VAR 0 1
5949: PPUSH
5950: CALL_OW 25
5954: ST_TO_ADDR
// if exist_mode and not debugMode then
5955: LD_VAR 0 2
5959: PUSH
5960: LD_EXP 46
5964: NOT
5965: AND
5966: IFFALSE 5991
// unit := CreateCharacter ( previousMissionPrefix & ident ) else
5968: LD_ADDR_VAR 0 5
5972: PUSH
5973: LD_EXP 45
5977: PUSH
5978: LD_VAR 0 1
5982: STR
5983: PPUSH
5984: CALL_OW 34
5988: ST_TO_ADDR
5989: GO 6013
// if not debugMode then
5991: LD_EXP 46
5995: NOT
5996: IFFALSE 6013
// unit := NewCharacter ( ident ) ;
5998: LD_ADDR_VAR 0 5
6002: PUSH
6003: LD_VAR 0 1
6007: PPUSH
6008: CALL_OW 25
6012: ST_TO_ADDR
// if class then
6013: LD_VAR 0 3
6017: IFFALSE 6033
// SetClass ( unit , class ) ;
6019: LD_VAR 0 5
6023: PPUSH
6024: LD_VAR 0 3
6028: PPUSH
6029: CALL_OW 336
// result := unit ;
6033: LD_ADDR_VAR 0 4
6037: PUSH
6038: LD_VAR 0 5
6042: ST_TO_ADDR
// end ;
6043: LD_VAR 0 4
6047: RET
// export function ExtSaveCharacter ( character , characterStringID , side ) ; begin
6048: LD_INT 0
6050: PPUSH
// if GetSide ( character ) = side and not IsDead ( character ) then
6051: LD_VAR 0 1
6055: PPUSH
6056: CALL_OW 255
6060: PUSH
6061: LD_VAR 0 3
6065: EQUAL
6066: PUSH
6067: LD_VAR 0 1
6071: PPUSH
6072: CALL_OW 301
6076: NOT
6077: AND
6078: IFFALSE 6100
// SaveCharacters ( character , missionPrefix & characterStringID ) ;
6080: LD_VAR 0 1
6084: PPUSH
6085: LD_EXP 44
6089: PUSH
6090: LD_VAR 0 2
6094: STR
6095: PPUSH
6096: CALL_OW 38
// end ;
6100: LD_VAR 0 4
6104: RET
// export function ExtSaveCharacters ( characters , charactersStringID , side ) ; var unit , resultCharactersToSave ; begin
6105: LD_INT 0
6107: PPUSH
6108: PPUSH
6109: PPUSH
// resultCharactersToSave = [ ] ;
6110: LD_ADDR_VAR 0 6
6114: PUSH
6115: EMPTY
6116: ST_TO_ADDR
// for unit in characters do
6117: LD_ADDR_VAR 0 5
6121: PUSH
6122: LD_VAR 0 1
6126: PUSH
6127: FOR_IN
6128: IFFALSE 6177
// if GetSide ( unit ) = side and not IsDead ( unit ) then
6130: LD_VAR 0 5
6134: PPUSH
6135: CALL_OW 255
6139: PUSH
6140: LD_VAR 0 3
6144: EQUAL
6145: PUSH
6146: LD_VAR 0 5
6150: PPUSH
6151: CALL_OW 301
6155: NOT
6156: AND
6157: IFFALSE 6175
// resultCharactersToSave = resultCharactersToSave ^ unit ;
6159: LD_ADDR_VAR 0 6
6163: PUSH
6164: LD_VAR 0 6
6168: PUSH
6169: LD_VAR 0 5
6173: ADD
6174: ST_TO_ADDR
6175: GO 6127
6177: POP
6178: POP
// SaveCharacters ( resultCharactersToSave , missionPrefix & charactersStringID ) ;
6179: LD_VAR 0 6
6183: PPUSH
6184: LD_EXP 44
6188: PUSH
6189: LD_VAR 0 2
6193: STR
6194: PPUSH
6195: CALL_OW 38
// end ;
6199: LD_VAR 0 4
6203: RET
// export function PlaceUnitsArea ( units , area , spawnMode ) ; var unit ; begin
6204: LD_INT 0
6206: PPUSH
6207: PPUSH
// for unit in units do
6208: LD_ADDR_VAR 0 5
6212: PUSH
6213: LD_VAR 0 1
6217: PUSH
6218: FOR_IN
6219: IFFALSE 6242
// PlaceUnitArea ( unit , area , spawnMode ) ;
6221: LD_VAR 0 5
6225: PPUSH
6226: LD_VAR 0 2
6230: PPUSH
6231: LD_VAR 0 3
6235: PPUSH
6236: CALL_OW 49
6240: GO 6218
6242: POP
6243: POP
// end ;
6244: LD_VAR 0 4
6248: RET
// export function DialogRandom ( characters , dialogMID , dialogFID , radio , canTalkHero ) ; var i , speaker , units ; begin
6249: LD_INT 0
6251: PPUSH
6252: PPUSH
6253: PPUSH
6254: PPUSH
// units = characters ;
6255: LD_ADDR_VAR 0 9
6259: PUSH
6260: LD_VAR 0 1
6264: ST_TO_ADDR
// units := units diff [ Burlak , Karamazov , Petrovova , Gleb , Petrosyan , Titov , Dolgov , Lipshchin , Kirilenkova ] ;
6265: LD_ADDR_VAR 0 9
6269: PUSH
6270: LD_VAR 0 9
6274: PUSH
6275: LD_EXP 57
6279: PUSH
6280: LD_EXP 58
6284: PUSH
6285: LD_EXP 59
6289: PUSH
6290: LD_EXP 60
6294: PUSH
6295: LD_EXP 61
6299: PUSH
6300: LD_EXP 62
6304: PUSH
6305: LD_EXP 63
6309: PUSH
6310: LD_EXP 64
6314: PUSH
6315: LD_EXP 65
6319: PUSH
6320: EMPTY
6321: LIST
6322: LIST
6323: LIST
6324: LIST
6325: LIST
6326: LIST
6327: LIST
6328: LIST
6329: LIST
6330: DIFF
6331: ST_TO_ADDR
// if not units and not canTalkHero then
6332: LD_VAR 0 9
6336: NOT
6337: PUSH
6338: LD_VAR 0 5
6342: NOT
6343: AND
6344: IFFALSE 6348
// exit ;
6346: GO 6521
// if not units then
6348: LD_VAR 0 9
6352: NOT
6353: IFFALSE 6374
// units = characters diff [ Burlak ] ;
6355: LD_ADDR_VAR 0 9
6359: PUSH
6360: LD_VAR 0 1
6364: PUSH
6365: LD_EXP 57
6369: PUSH
6370: EMPTY
6371: LIST
6372: DIFF
6373: ST_TO_ADDR
// if not units and canTalkHero then
6374: LD_VAR 0 9
6378: NOT
6379: PUSH
6380: LD_VAR 0 5
6384: AND
6385: IFFALSE 6389
// exit ;
6387: GO 6521
// speaker := units [ rand ( 1 , units ) ] ;
6389: LD_ADDR_VAR 0 8
6393: PUSH
6394: LD_VAR 0 9
6398: PUSH
6399: LD_INT 1
6401: PPUSH
6402: LD_VAR 0 9
6406: PPUSH
6407: CALL_OW 12
6411: ARRAY
6412: ST_TO_ADDR
// if radio then
6413: LD_VAR 0 4
6417: IFFALSE 6466
// begin if GetSex ( speaker ) = sex_male then
6419: LD_VAR 0 8
6423: PPUSH
6424: CALL_OW 258
6428: PUSH
6429: LD_INT 1
6431: EQUAL
6432: IFFALSE 6450
// SayRadio ( speaker , dialogMID ) else
6434: LD_VAR 0 8
6438: PPUSH
6439: LD_VAR 0 2
6443: PPUSH
6444: CALL_OW 94
6448: GO 6464
// SayRadio ( speaker , dialogFID ) ;
6450: LD_VAR 0 8
6454: PPUSH
6455: LD_VAR 0 3
6459: PPUSH
6460: CALL_OW 94
// end else
6464: GO 6511
// begin if GetSex ( speaker ) = sex_male then
6466: LD_VAR 0 8
6470: PPUSH
6471: CALL_OW 258
6475: PUSH
6476: LD_INT 1
6478: EQUAL
6479: IFFALSE 6497
// Say ( speaker , dialogMID ) else
6481: LD_VAR 0 8
6485: PPUSH
6486: LD_VAR 0 2
6490: PPUSH
6491: CALL_OW 88
6495: GO 6511
// Say ( speaker , dialogFID ) ;
6497: LD_VAR 0 8
6501: PPUSH
6502: LD_VAR 0 3
6506: PPUSH
6507: CALL_OW 88
// end ; result := speaker ;
6511: LD_ADDR_VAR 0 6
6515: PUSH
6516: LD_VAR 0 8
6520: ST_TO_ADDR
// end ;
6521: LD_VAR 0 6
6525: RET
// export function RemoveUnits ( units ) ; var unit ; begin
6526: LD_INT 0
6528: PPUSH
6529: PPUSH
// if not units then
6530: LD_VAR 0 1
6534: NOT
6535: IFFALSE 6539
// exit ;
6537: GO 6685
// if Heike in units then
6539: LD_EXP 79
6543: PUSH
6544: LD_VAR 0 1
6548: IN
6549: IFFALSE 6605
// begin if GetAttitude ( 3 , 8 ) = att_neutral then
6551: LD_INT 3
6553: PPUSH
6554: LD_INT 8
6556: PPUSH
6557: CALL_OW 81
6561: PUSH
6562: LD_INT 0
6564: EQUAL
6565: IFFALSE 6577
// HeikeStatus = 1 else
6567: LD_ADDR_EXP 3
6571: PUSH
6572: LD_INT 1
6574: ST_TO_ADDR
6575: GO 6585
// HeikeStatus = 2 ;
6577: LD_ADDR_EXP 3
6581: PUSH
6582: LD_INT 2
6584: ST_TO_ADDR
// forceStopKurtAttack = true ;
6585: LD_ADDR_EXP 27
6589: PUSH
6590: LD_INT 1
6592: ST_TO_ADDR
// SetClass ( Heike , 1 ) ;
6593: LD_EXP 79
6597: PPUSH
6598: LD_INT 1
6600: PPUSH
6601: CALL_OW 336
// end ; if Kurt in units then
6605: LD_EXP 80
6609: PUSH
6610: LD_VAR 0 1
6614: IN
6615: IFFALSE 6659
// begin if GetAttitude ( 3 , 8 ) = att_neutral then
6617: LD_INT 3
6619: PPUSH
6620: LD_INT 8
6622: PPUSH
6623: CALL_OW 81
6627: PUSH
6628: LD_INT 0
6630: EQUAL
6631: IFFALSE 6643
// KurtStatus = 1 else
6633: LD_ADDR_EXP 22
6637: PUSH
6638: LD_INT 1
6640: ST_TO_ADDR
6641: GO 6659
// begin KurtStatus = 2 ;
6643: LD_ADDR_EXP 22
6647: PUSH
6648: LD_INT 2
6650: ST_TO_ADDR
// KurtAttack = 1 ;
6651: LD_ADDR_EXP 25
6655: PUSH
6656: LD_INT 1
6658: ST_TO_ADDR
// end ; end ; for unit in units do
6659: LD_ADDR_VAR 0 3
6663: PUSH
6664: LD_VAR 0 1
6668: PUSH
6669: FOR_IN
6670: IFFALSE 6683
// RemoveUnit ( unit ) ;
6672: LD_VAR 0 3
6676: PPUSH
6677: CALL_OW 64
6681: GO 6669
6683: POP
6684: POP
// end ;
6685: LD_VAR 0 2
6689: RET
// export function GetAmountWeaponsDataBuildOnTurret ( isBuild ) ; var i , amount ; begin
6690: LD_INT 0
6692: PPUSH
6693: PPUSH
6694: PPUSH
// amount = 0 ;
6695: LD_ADDR_VAR 0 4
6699: PUSH
6700: LD_INT 0
6702: ST_TO_ADDR
// for i := 1 to weaponsData do
6703: LD_ADDR_VAR 0 3
6707: PUSH
6708: DOUBLE
6709: LD_INT 1
6711: DEC
6712: ST_TO_ADDR
6713: LD_EXP 12
6717: PUSH
6718: FOR_TO
6719: IFFALSE 6759
// if weaponsData [ i ] [ 2 ] = isBuild then
6721: LD_EXP 12
6725: PUSH
6726: LD_VAR 0 3
6730: ARRAY
6731: PUSH
6732: LD_INT 2
6734: ARRAY
6735: PUSH
6736: LD_VAR 0 1
6740: EQUAL
6741: IFFALSE 6757
// amount = amount + 1 ;
6743: LD_ADDR_VAR 0 4
6747: PUSH
6748: LD_VAR 0 4
6752: PUSH
6753: LD_INT 1
6755: PLUS
6756: ST_TO_ADDR
6757: GO 6718
6759: POP
6760: POP
// if isBuild then
6761: LD_VAR 0 1
6765: IFFALSE 6785
// if amount >= 3 then
6767: LD_VAR 0 4
6771: PUSH
6772: LD_INT 3
6774: GREATEREQUAL
6775: IFFALSE 6785
// amount = 3 ;
6777: LD_ADDR_VAR 0 4
6781: PUSH
6782: LD_INT 3
6784: ST_TO_ADDR
// result = amount ;
6785: LD_ADDR_VAR 0 2
6789: PUSH
6790: LD_VAR 0 4
6794: ST_TO_ADDR
// end ;
6795: LD_VAR 0 2
6799: RET
// export function GetAmountWeaponsDataBuildOnVehicle ( isBuild ) ; var i , amount ; begin
6800: LD_INT 0
6802: PPUSH
6803: PPUSH
6804: PPUSH
// amount = 0 ;
6805: LD_ADDR_VAR 0 4
6809: PUSH
6810: LD_INT 0
6812: ST_TO_ADDR
// for i := 1 to weaponsData do
6813: LD_ADDR_VAR 0 3
6817: PUSH
6818: DOUBLE
6819: LD_INT 1
6821: DEC
6822: ST_TO_ADDR
6823: LD_EXP 12
6827: PUSH
6828: FOR_TO
6829: IFFALSE 6869
// if weaponsData [ i ] [ 3 ] = isBuild then
6831: LD_EXP 12
6835: PUSH
6836: LD_VAR 0 3
6840: ARRAY
6841: PUSH
6842: LD_INT 3
6844: ARRAY
6845: PUSH
6846: LD_VAR 0 1
6850: EQUAL
6851: IFFALSE 6867
// amount = amount + 1 ;
6853: LD_ADDR_VAR 0 4
6857: PUSH
6858: LD_VAR 0 4
6862: PUSH
6863: LD_INT 1
6865: PLUS
6866: ST_TO_ADDR
6867: GO 6828
6869: POP
6870: POP
// result = amount ;
6871: LD_ADDR_VAR 0 2
6875: PUSH
6876: LD_VAR 0 4
6880: ST_TO_ADDR
// end ;
6881: LD_VAR 0 2
6885: RET
// export function SetWeaponDataBuild ( weapon , turret ) ; var i ; begin
6886: LD_INT 0
6888: PPUSH
6889: PPUSH
// if turret then
6890: LD_VAR 0 2
6894: IFFALSE 6992
// begin for i := 1 to weaponsData do
6896: LD_ADDR_VAR 0 4
6900: PUSH
6901: DOUBLE
6902: LD_INT 1
6904: DEC
6905: ST_TO_ADDR
6906: LD_EXP 12
6910: PUSH
6911: FOR_TO
6912: IFFALSE 6988
// if weaponsData [ i ] [ 1 ] = weapon and weaponsData [ i ] [ 2 ] = false then
6914: LD_EXP 12
6918: PUSH
6919: LD_VAR 0 4
6923: ARRAY
6924: PUSH
6925: LD_INT 1
6927: ARRAY
6928: PUSH
6929: LD_VAR 0 1
6933: EQUAL
6934: PUSH
6935: LD_EXP 12
6939: PUSH
6940: LD_VAR 0 4
6944: ARRAY
6945: PUSH
6946: LD_INT 2
6948: ARRAY
6949: PUSH
6950: LD_INT 0
6952: EQUAL
6953: AND
6954: IFFALSE 6986
// weaponsData = ReplaceIn ( weaponsData , [ i , 2 ] , true ) ;
6956: LD_ADDR_EXP 12
6960: PUSH
6961: LD_EXP 12
6965: PPUSH
6966: LD_VAR 0 4
6970: PUSH
6971: LD_INT 2
6973: PUSH
6974: EMPTY
6975: LIST
6976: LIST
6977: PPUSH
6978: LD_INT 1
6980: PPUSH
6981: CALL 24361 0 3
6985: ST_TO_ADDR
6986: GO 6911
6988: POP
6989: POP
// end else
6990: GO 7086
// begin for i := 1 to weaponsData do
6992: LD_ADDR_VAR 0 4
6996: PUSH
6997: DOUBLE
6998: LD_INT 1
7000: DEC
7001: ST_TO_ADDR
7002: LD_EXP 12
7006: PUSH
7007: FOR_TO
7008: IFFALSE 7084
// if weaponsData [ i ] [ 1 ] = weapon and weaponsData [ i ] [ 3 ] = false then
7010: LD_EXP 12
7014: PUSH
7015: LD_VAR 0 4
7019: ARRAY
7020: PUSH
7021: LD_INT 1
7023: ARRAY
7024: PUSH
7025: LD_VAR 0 1
7029: EQUAL
7030: PUSH
7031: LD_EXP 12
7035: PUSH
7036: LD_VAR 0 4
7040: ARRAY
7041: PUSH
7042: LD_INT 3
7044: ARRAY
7045: PUSH
7046: LD_INT 0
7048: EQUAL
7049: AND
7050: IFFALSE 7082
// weaponsData = ReplaceIn ( weaponsData , [ i , 3 ] , true ) ;
7052: LD_ADDR_EXP 12
7056: PUSH
7057: LD_EXP 12
7061: PPUSH
7062: LD_VAR 0 4
7066: PUSH
7067: LD_INT 3
7069: PUSH
7070: EMPTY
7071: LIST
7072: LIST
7073: PPUSH
7074: LD_INT 1
7076: PPUSH
7077: CALL 24361 0 3
7081: ST_TO_ADDR
7082: GO 7007
7084: POP
7085: POP
// end ; end ;
7086: LD_VAR 0 3
7090: RET
// export function ShootTreningController ; var i , unitsInArea , unit , depots , depot , barrelsAreaList , randIndex , randPosX , randPosY , barrelsInArea ; begin
7091: LD_INT 0
7093: PPUSH
7094: PPUSH
7095: PPUSH
7096: PPUSH
7097: PPUSH
7098: PPUSH
7099: PPUSH
7100: PPUSH
7101: PPUSH
7102: PPUSH
7103: PPUSH
// unitsInArea = FilterUnitsInArea ( ShootArea , [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) ;
7104: LD_ADDR_VAR 0 3
7108: PUSH
7109: LD_INT 12
7111: PPUSH
7112: LD_INT 22
7114: PUSH
7115: LD_INT 3
7117: PUSH
7118: EMPTY
7119: LIST
7120: LIST
7121: PUSH
7122: LD_INT 21
7124: PUSH
7125: LD_INT 1
7127: PUSH
7128: EMPTY
7129: LIST
7130: LIST
7131: PUSH
7132: LD_INT 50
7134: PUSH
7135: EMPTY
7136: LIST
7137: PUSH
7138: LD_INT 3
7140: PUSH
7141: LD_INT 60
7143: PUSH
7144: EMPTY
7145: LIST
7146: PUSH
7147: EMPTY
7148: LIST
7149: LIST
7150: PUSH
7151: EMPTY
7152: LIST
7153: LIST
7154: LIST
7155: LIST
7156: PPUSH
7157: CALL_OW 70
7161: ST_TO_ADDR
// depots = FilterAllUnits ( [ [ f_side , 3 ] , [ f_ok ] , [ f_type , unit_building ] , [ f_not , [ f_constructed ] ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
7162: LD_ADDR_VAR 0 5
7166: PUSH
7167: LD_INT 22
7169: PUSH
7170: LD_INT 3
7172: PUSH
7173: EMPTY
7174: LIST
7175: LIST
7176: PUSH
7177: LD_INT 50
7179: PUSH
7180: EMPTY
7181: LIST
7182: PUSH
7183: LD_INT 21
7185: PUSH
7186: LD_INT 3
7188: PUSH
7189: EMPTY
7190: LIST
7191: LIST
7192: PUSH
7193: LD_INT 3
7195: PUSH
7196: LD_INT 57
7198: PUSH
7199: EMPTY
7200: LIST
7201: PUSH
7202: EMPTY
7203: LIST
7204: LIST
7205: PUSH
7206: LD_INT 2
7208: PUSH
7209: LD_INT 30
7211: PUSH
7212: LD_INT 0
7214: PUSH
7215: EMPTY
7216: LIST
7217: LIST
7218: PUSH
7219: LD_INT 30
7221: PUSH
7222: LD_INT 1
7224: PUSH
7225: EMPTY
7226: LIST
7227: LIST
7228: PUSH
7229: EMPTY
7230: LIST
7231: LIST
7232: LIST
7233: PUSH
7234: EMPTY
7235: LIST
7236: LIST
7237: LIST
7238: LIST
7239: LIST
7240: PPUSH
7241: CALL_OW 69
7245: ST_TO_ADDR
// barrelsAreaList = AreaToList ( BarrelsArea , 0 ) ;
7246: LD_ADDR_VAR 0 7
7250: PUSH
7251: LD_INT 13
7253: PPUSH
7254: LD_INT 0
7256: PPUSH
7257: CALL_OW 517
7261: ST_TO_ADDR
// if not depots or not unitsInArea then
7262: LD_VAR 0 5
7266: NOT
7267: PUSH
7268: LD_VAR 0 3
7272: NOT
7273: OR
7274: IFFALSE 7278
// exit ;
7276: GO 7714
// depot = depots [ 1 ] ;
7278: LD_ADDR_VAR 0 6
7282: PUSH
7283: LD_VAR 0 5
7287: PUSH
7288: LD_INT 1
7290: ARRAY
7291: ST_TO_ADDR
// for unit in unitsInArea do
7292: LD_ADDR_VAR 0 4
7296: PUSH
7297: LD_VAR 0 3
7301: PUSH
7302: FOR_IN
7303: IFFALSE 7712
// begin if not GetClass ( unit ) = class_engineer then
7305: LD_VAR 0 4
7309: PPUSH
7310: CALL_OW 257
7314: PUSH
7315: LD_INT 2
7317: EQUAL
7318: NOT
7319: IFFALSE 7356
// begin ComEnterUnit ( unit , depot ) ;
7321: LD_VAR 0 4
7325: PPUSH
7326: LD_VAR 0 6
7330: PPUSH
7331: CALL_OW 120
// AddComChangeProfession ( unit , class_engineer ) ;
7335: LD_VAR 0 4
7339: PPUSH
7340: LD_INT 2
7342: PPUSH
7343: CALL_OW 183
// AddComExitBuilding ( unit ) ;
7347: LD_VAR 0 4
7351: PPUSH
7352: CALL_OW 182
// end ; if GetCargo ( unit , mat_oil ) = 0 then
7356: LD_VAR 0 4
7360: PPUSH
7361: LD_INT 2
7363: PPUSH
7364: CALL_OW 289
7368: PUSH
7369: LD_INT 0
7371: EQUAL
7372: IFFALSE 7391
// AddComTransport ( unit , depot , mat_oil ) ;
7374: LD_VAR 0 4
7378: PPUSH
7379: LD_VAR 0 6
7383: PPUSH
7384: LD_INT 2
7386: PPUSH
7387: CALL_OW 211
// repeat wait ( 0 0$1 ) ;
7391: LD_INT 35
7393: PPUSH
7394: CALL_OW 67
// until not HasTask ( unit ) ;
7398: LD_VAR 0 4
7402: PPUSH
7403: CALL_OW 314
7407: NOT
7408: IFFALSE 7391
// if GetCargo ( unit , mat_oil ) > 0 then
7410: LD_VAR 0 4
7414: PPUSH
7415: LD_INT 2
7417: PPUSH
7418: CALL_OW 289
7422: PUSH
7423: LD_INT 0
7425: GREATER
7426: IFFALSE 7710
// begin randIndex = Rand ( 1 , barrelsAreaList [ 1 ] ) ;
7428: LD_ADDR_VAR 0 8
7432: PUSH
7433: LD_INT 1
7435: PPUSH
7436: LD_VAR 0 7
7440: PUSH
7441: LD_INT 1
7443: ARRAY
7444: PPUSH
7445: CALL_OW 12
7449: ST_TO_ADDR
// randPosX = barrelsAreaList [ 1 ] [ randIndex ] ;
7450: LD_ADDR_VAR 0 9
7454: PUSH
7455: LD_VAR 0 7
7459: PUSH
7460: LD_INT 1
7462: ARRAY
7463: PUSH
7464: LD_VAR 0 8
7468: ARRAY
7469: ST_TO_ADDR
// randPosY = barrelsAreaList [ 2 ] [ RandIndex ] ;
7470: LD_ADDR_VAR 0 10
7474: PUSH
7475: LD_VAR 0 7
7479: PUSH
7480: LD_INT 2
7482: ARRAY
7483: PUSH
7484: LD_VAR 0 8
7488: ARRAY
7489: ST_TO_ADDR
// AddComMoveXY ( unit , randPosX , randPosY ) ;
7490: LD_VAR 0 4
7494: PPUSH
7495: LD_VAR 0 9
7499: PPUSH
7500: LD_VAR 0 10
7504: PPUSH
7505: CALL_OW 171
// AddComUnload ( unit ) ;
7509: LD_VAR 0 4
7513: PPUSH
7514: CALL_OW 219
// AddComMoveXY ( unit , randPosX + 2 , randPosY + 2 ) ;
7518: LD_VAR 0 4
7522: PPUSH
7523: LD_VAR 0 9
7527: PUSH
7528: LD_INT 2
7530: PLUS
7531: PPUSH
7532: LD_VAR 0 10
7536: PUSH
7537: LD_INT 2
7539: PLUS
7540: PPUSH
7541: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
7545: LD_INT 35
7547: PPUSH
7548: CALL_OW 67
// until not HasTask ( unit ) ;
7552: LD_VAR 0 4
7556: PPUSH
7557: CALL_OW 314
7561: NOT
7562: IFFALSE 7545
// barrelsInArea = GetListOfCratesInArea ( ShootArea ) ;
7564: LD_ADDR_VAR 0 11
7568: PUSH
7569: LD_INT 12
7571: PPUSH
7572: CALL_OW 435
7576: ST_TO_ADDR
// for i := 1 to barrelsInArea / 2 do
7577: LD_ADDR_VAR 0 2
7581: PUSH
7582: DOUBLE
7583: LD_INT 1
7585: DEC
7586: ST_TO_ADDR
7587: LD_VAR 0 11
7591: PUSH
7592: LD_INT 2
7594: DIVREAL
7595: PUSH
7596: FOR_TO
7597: IFFALSE 7708
// begin if GetDistUnitXY ( unit , barrelsInArea [ i ] , barrelsInArea [ i + 1 ] ) <= 6 then
7599: LD_VAR 0 4
7603: PPUSH
7604: LD_VAR 0 11
7608: PUSH
7609: LD_VAR 0 2
7613: ARRAY
7614: PPUSH
7615: LD_VAR 0 11
7619: PUSH
7620: LD_VAR 0 2
7624: PUSH
7625: LD_INT 1
7627: PLUS
7628: ARRAY
7629: PPUSH
7630: CALL_OW 297
7634: PUSH
7635: LD_INT 6
7637: LESSEQUAL
7638: IFFALSE 7692
// begin AddComAttackPlace ( unit , barrelsInArea [ i ] , barrelsInArea [ i + 1 ] ) ;
7640: LD_VAR 0 4
7644: PPUSH
7645: LD_VAR 0 11
7649: PUSH
7650: LD_VAR 0 2
7654: ARRAY
7655: PPUSH
7656: LD_VAR 0 11
7660: PUSH
7661: LD_VAR 0 2
7665: PUSH
7666: LD_INT 1
7668: PLUS
7669: ARRAY
7670: PPUSH
7671: CALL_OW 176
// AddExperience ( unit , skill_combat , 5 ) ;
7675: LD_VAR 0 4
7679: PPUSH
7680: LD_INT 1
7682: PPUSH
7683: LD_INT 5
7685: PPUSH
7686: CALL_OW 492
// break ;
7690: GO 7708
// end ; i = i + 2 ;
7692: LD_ADDR_VAR 0 2
7696: PUSH
7697: LD_VAR 0 2
7701: PUSH
7702: LD_INT 2
7704: PLUS
7705: ST_TO_ADDR
// end ;
7706: GO 7596
7708: POP
7709: POP
// end ; end ;
7710: GO 7302
7712: POP
7713: POP
// end ;
7714: LD_VAR 0 1
7718: RET
// export function GoToHunt ( hunter ) ; var i , barracks , barrackTarget , barrackTargetCurrentHP , animals , animal ; begin
7719: LD_INT 0
7721: PPUSH
7722: PPUSH
7723: PPUSH
7724: PPUSH
7725: PPUSH
7726: PPUSH
7727: PPUSH
// animals = [ ] ;
7728: LD_ADDR_VAR 0 7
7732: PUSH
7733: EMPTY
7734: ST_TO_ADDR
// barracks = FilterAllUnits ( [ [ f_ok ] , [ f_not , [ f_constructed ] ] , [ f_or , [ f_btype , b_barracks ] , [ f_btype , b_armoury ] ] ] ) ;
7735: LD_ADDR_VAR 0 4
7739: PUSH
7740: LD_INT 50
7742: PUSH
7743: EMPTY
7744: LIST
7745: PUSH
7746: LD_INT 3
7748: PUSH
7749: LD_INT 57
7751: PUSH
7752: EMPTY
7753: LIST
7754: PUSH
7755: EMPTY
7756: LIST
7757: LIST
7758: PUSH
7759: LD_INT 2
7761: PUSH
7762: LD_INT 30
7764: PUSH
7765: LD_INT 5
7767: PUSH
7768: EMPTY
7769: LIST
7770: LIST
7771: PUSH
7772: LD_INT 30
7774: PUSH
7775: LD_INT 4
7777: PUSH
7778: EMPTY
7779: LIST
7780: LIST
7781: PUSH
7782: EMPTY
7783: LIST
7784: LIST
7785: LIST
7786: PUSH
7787: EMPTY
7788: LIST
7789: LIST
7790: LIST
7791: PPUSH
7792: CALL_OW 69
7796: ST_TO_ADDR
// SetSide ( hunter , 6 ) ;
7797: LD_VAR 0 1
7801: PPUSH
7802: LD_INT 6
7804: PPUSH
7805: CALL_OW 235
// if IsInUnit ( hunter ) then
7809: LD_VAR 0 1
7813: PPUSH
7814: CALL_OW 310
7818: IFFALSE 7860
// begin if GetBType ( IsInUnit ( hunter ) = unit_vehicle ) then
7820: LD_VAR 0 1
7824: PPUSH
7825: CALL_OW 310
7829: PUSH
7830: LD_INT 2
7832: EQUAL
7833: PPUSH
7834: CALL_OW 266
7838: IFFALSE 7851
// ComExitVehicle ( hunter ) else
7840: LD_VAR 0 1
7844: PPUSH
7845: CALL_OW 121
7849: GO 7860
// ComExitBuilding ( hunter ) ;
7851: LD_VAR 0 1
7855: PPUSH
7856: CALL_OW 122
// end ; ComWalk ( hunter ) ;
7860: LD_VAR 0 1
7864: PPUSH
7865: CALL_OW 138
// wait ( 0 0$1 ) ;
7869: LD_INT 35
7871: PPUSH
7872: CALL_OW 67
// if not GetClass ( hunter ) = class_soldier and barracks then
7876: LD_VAR 0 1
7880: PPUSH
7881: CALL_OW 257
7885: PUSH
7886: LD_INT 1
7888: EQUAL
7889: NOT
7890: PUSH
7891: LD_VAR 0 4
7895: AND
7896: IFFALSE 8039
// begin barrackTarget = barracks [ 1 ] ;
7898: LD_ADDR_VAR 0 5
7902: PUSH
7903: LD_VAR 0 4
7907: PUSH
7908: LD_INT 1
7910: ARRAY
7911: ST_TO_ADDR
// barrackTargetCurrentHP = GetLives ( barrackTarget ) ;
7912: LD_ADDR_VAR 0 6
7916: PUSH
7917: LD_VAR 0 5
7921: PPUSH
7922: CALL_OW 256
7926: ST_TO_ADDR
// SetSide ( barrackTarget , 6 ) ;
7927: LD_VAR 0 5
7931: PPUSH
7932: LD_INT 6
7934: PPUSH
7935: CALL_OW 235
// ComEnterUnit ( hunter , barrackTarget ) ;
7939: LD_VAR 0 1
7943: PPUSH
7944: LD_VAR 0 5
7948: PPUSH
7949: CALL_OW 120
// repeat wait ( 0 0$1 ) ;
7953: LD_INT 35
7955: PPUSH
7956: CALL_OW 67
// ComEnterUnit ( hunter , barrackTarget ) ;
7960: LD_VAR 0 1
7964: PPUSH
7965: LD_VAR 0 5
7969: PPUSH
7970: CALL_OW 120
// SetLives ( barrackTarget , barrackTargetCurrentHP ) ;
7974: LD_VAR 0 5
7978: PPUSH
7979: LD_VAR 0 6
7983: PPUSH
7984: CALL_OW 234
// until IsInUnit ( hunter ) ;
7988: LD_VAR 0 1
7992: PPUSH
7993: CALL_OW 310
7997: IFFALSE 7953
// SetClass ( hunter , class_soldier ) ;
7999: LD_VAR 0 1
8003: PPUSH
8004: LD_INT 1
8006: PPUSH
8007: CALL_OW 336
// ComExitBuilding ( hunter ) ;
8011: LD_VAR 0 1
8015: PPUSH
8016: CALL_OW 122
// SetSide ( barrackTarget , 3 ) ;
8020: LD_VAR 0 5
8024: PPUSH
8025: LD_INT 3
8027: PPUSH
8028: CALL_OW 235
// wait ( 0 0$1 ) ;
8032: LD_INT 35
8034: PPUSH
8035: CALL_OW 67
// end ; for i := 1 to 3 do
8039: LD_ADDR_VAR 0 3
8043: PUSH
8044: DOUBLE
8045: LD_INT 1
8047: DEC
8048: ST_TO_ADDR
8049: LD_INT 3
8051: PUSH
8052: FOR_TO
8053: IFFALSE 8158
// begin uc_side = 0 ;
8055: LD_ADDR_OWVAR 20
8059: PUSH
8060: LD_INT 0
8062: ST_TO_ADDR
// uc_nation = nation_nature ;
8063: LD_ADDR_OWVAR 21
8067: PUSH
8068: LD_INT 0
8070: ST_TO_ADDR
// PrepareHuman ( false , [ class_phororhacos , class_tiger , 21 ] [ Rand ( 1 , 3 ) ] , 0 ) ;
8071: LD_INT 0
8073: PPUSH
8074: LD_INT 18
8076: PUSH
8077: LD_INT 14
8079: PUSH
8080: LD_INT 21
8082: PUSH
8083: EMPTY
8084: LIST
8085: LIST
8086: LIST
8087: PUSH
8088: LD_INT 1
8090: PPUSH
8091: LD_INT 3
8093: PPUSH
8094: CALL_OW 12
8098: ARRAY
8099: PPUSH
8100: LD_INT 0
8102: PPUSH
8103: CALL_OW 380
// hc_agressivity = 0 ;
8107: LD_ADDR_OWVAR 35
8111: PUSH
8112: LD_INT 0
8114: ST_TO_ADDR
// animal = CreateHuman ;
8115: LD_ADDR_VAR 0 8
8119: PUSH
8120: CALL_OW 44
8124: ST_TO_ADDR
// PlaceUnitArea ( animal , NatureArea , false ) ;
8125: LD_VAR 0 8
8129: PPUSH
8130: LD_INT 5
8132: PPUSH
8133: LD_INT 0
8135: PPUSH
8136: CALL_OW 49
// animals = animals ^ animal ;
8140: LD_ADDR_VAR 0 7
8144: PUSH
8145: LD_VAR 0 7
8149: PUSH
8150: LD_VAR 0 8
8154: ADD
8155: ST_TO_ADDR
// end ;
8156: GO 8052
8158: POP
8159: POP
// for i := 1 to animals do
8160: LD_ADDR_VAR 0 3
8164: PUSH
8165: DOUBLE
8166: LD_INT 1
8168: DEC
8169: ST_TO_ADDR
8170: LD_VAR 0 7
8174: PUSH
8175: FOR_TO
8176: IFFALSE 8200
// AddComAttackUnit ( hunter , animals [ i ] ) ;
8178: LD_VAR 0 1
8182: PPUSH
8183: LD_VAR 0 7
8187: PUSH
8188: LD_VAR 0 3
8192: ARRAY
8193: PPUSH
8194: CALL_OW 175
8198: GO 8175
8200: POP
8201: POP
// repeat wait ( 0 0$1 ) ;
8202: LD_INT 35
8204: PPUSH
8205: CALL_OW 67
// if GetClass ( hunter ) = class_soldier then
8209: LD_VAR 0 1
8213: PPUSH
8214: CALL_OW 257
8218: PUSH
8219: LD_INT 1
8221: EQUAL
8222: IFFALSE 8269
// begin if GetDistUnits ( hunter , WantsToAttack ( hunter ) ) < 13 then
8224: LD_VAR 0 1
8228: PPUSH
8229: LD_VAR 0 1
8233: PPUSH
8234: CALL_OW 319
8238: PPUSH
8239: CALL_OW 296
8243: PUSH
8244: LD_INT 13
8246: LESS
8247: IFFALSE 8260
// ComCrawl ( hunter ) else
8249: LD_VAR 0 1
8253: PPUSH
8254: CALL_OW 137
8258: GO 8269
// ComWalk ( hunter ) ;
8260: LD_VAR 0 1
8264: PPUSH
8265: CALL_OW 138
// end ; until not HasTask ( hunter ) ;
8269: LD_VAR 0 1
8273: PPUSH
8274: CALL_OW 314
8278: NOT
8279: IFFALSE 8202
// repeat wait ( 0 0$1 ) ;
8281: LD_INT 35
8283: PPUSH
8284: CALL_OW 67
// ComMoveXY ( hunter , GetX ( Burlak ) , GetY ( Burlak ) ) ;
8288: LD_VAR 0 1
8292: PPUSH
8293: LD_EXP 57
8297: PPUSH
8298: CALL_OW 250
8302: PPUSH
8303: LD_EXP 57
8307: PPUSH
8308: CALL_OW 251
8312: PPUSH
8313: CALL_OW 111
// until GetDistUnits ( hunter , Burlak ) <= 9 ;
8317: LD_VAR 0 1
8321: PPUSH
8322: LD_EXP 57
8326: PPUSH
8327: CALL_OW 296
8331: PUSH
8332: LD_INT 9
8334: LESSEQUAL
8335: IFFALSE 8281
// SetSide ( hunter , 3 ) ;
8337: LD_VAR 0 1
8341: PPUSH
8342: LD_INT 3
8344: PPUSH
8345: CALL_OW 235
// CenterOnUnits ( hunter ) ;
8349: LD_VAR 0 1
8353: PPUSH
8354: CALL_OW 85
// AddExperience ( hunter , skill_combat , 3000 ) ;
8358: LD_VAR 0 1
8362: PPUSH
8363: LD_INT 1
8365: PPUSH
8366: LD_INT 3000
8368: PPUSH
8369: CALL_OW 492
// end ;
8373: LD_VAR 0 2
8377: RET
// export function SetMashaData ( vehicle ) ; begin
8378: LD_INT 0
8380: PPUSH
// if Masha then
8381: LD_EXP 4
8385: IFFALSE 8403
// SetMark ( Masha [ 1 ] , 0 ) ;
8387: LD_EXP 4
8391: PUSH
8392: LD_INT 1
8394: ARRAY
8395: PPUSH
8396: LD_INT 0
8398: PPUSH
8399: CALL_OW 242
// Masha = [ vehicle , GetChassis ( vehicle ) , GetEngine ( vehicle ) , GetControl ( vehicle ) , GetWeapon ( vehicle ) ] ;
8403: LD_ADDR_EXP 4
8407: PUSH
8408: LD_VAR 0 1
8412: PUSH
8413: LD_VAR 0 1
8417: PPUSH
8418: CALL_OW 265
8422: PUSH
8423: LD_VAR 0 1
8427: PPUSH
8428: CALL_OW 262
8432: PUSH
8433: LD_VAR 0 1
8437: PPUSH
8438: CALL_OW 263
8442: PUSH
8443: LD_VAR 0 1
8447: PPUSH
8448: CALL_OW 264
8452: PUSH
8453: EMPTY
8454: LIST
8455: LIST
8456: LIST
8457: LIST
8458: LIST
8459: ST_TO_ADDR
// ChangeMissionObjectives ( MMashaDone ) ;
8460: LD_STRING MMashaDone
8462: PPUSH
8463: CALL_OW 337
// SetMark ( vehicle , 1 ) ;
8467: LD_VAR 0 1
8471: PPUSH
8472: LD_INT 1
8474: PPUSH
8475: CALL_OW 242
// end ;
8479: LD_VAR 0 2
8483: RET
// export function SaveBase ( buildings , ident ) ; var i , buildingsToSave ; begin
8484: LD_INT 0
8486: PPUSH
8487: PPUSH
8488: PPUSH
// buildingsToSave = [ ] ;
8489: LD_ADDR_VAR 0 5
8493: PUSH
8494: EMPTY
8495: ST_TO_ADDR
// if not buildings then
8496: LD_VAR 0 1
8500: NOT
8501: IFFALSE 8505
// exit ;
8503: GO 9080
// for i in buildings do
8505: LD_ADDR_VAR 0 4
8509: PUSH
8510: LD_VAR 0 1
8514: PUSH
8515: FOR_IN
8516: IFFALSE 9064
// begin if GetBType ( i ) in [ b_lab , b_lab_half , b_lab_full ] then
8518: LD_VAR 0 4
8522: PPUSH
8523: CALL_OW 266
8527: PUSH
8528: LD_INT 6
8530: PUSH
8531: LD_INT 7
8533: PUSH
8534: LD_INT 8
8536: PUSH
8537: EMPTY
8538: LIST
8539: LIST
8540: LIST
8541: IN
8542: IFFALSE 8667
// buildingsToSave = buildingsToSave ^ [ [ GetBType ( i ) , GetX ( i ) , GetY ( i ) , GetDir ( i ) , GetBLevel ( i ) , GetNation ( i ) , GetLives ( i ) , GetLabKind ( i , 1 ) , GetLabKind ( i , 2 ) ] ] else
8544: LD_ADDR_VAR 0 5
8548: PUSH
8549: LD_VAR 0 5
8553: PUSH
8554: LD_VAR 0 4
8558: PPUSH
8559: CALL_OW 266
8563: PUSH
8564: LD_VAR 0 4
8568: PPUSH
8569: CALL_OW 250
8573: PUSH
8574: LD_VAR 0 4
8578: PPUSH
8579: CALL_OW 251
8583: PUSH
8584: LD_VAR 0 4
8588: PPUSH
8589: CALL_OW 254
8593: PUSH
8594: LD_VAR 0 4
8598: PPUSH
8599: CALL_OW 267
8603: PUSH
8604: LD_VAR 0 4
8608: PPUSH
8609: CALL_OW 248
8613: PUSH
8614: LD_VAR 0 4
8618: PPUSH
8619: CALL_OW 256
8623: PUSH
8624: LD_VAR 0 4
8628: PPUSH
8629: LD_INT 1
8631: PPUSH
8632: CALL_OW 268
8636: PUSH
8637: LD_VAR 0 4
8641: PPUSH
8642: LD_INT 2
8644: PPUSH
8645: CALL_OW 268
8649: PUSH
8650: EMPTY
8651: LIST
8652: LIST
8653: LIST
8654: LIST
8655: LIST
8656: LIST
8657: LIST
8658: LIST
8659: LIST
8660: PUSH
8661: EMPTY
8662: LIST
8663: ADD
8664: ST_TO_ADDR
8665: GO 9062
// if GetBType ( i ) in [ b_bunker , b_turret ] then
8667: LD_VAR 0 4
8671: PPUSH
8672: CALL_OW 266
8676: PUSH
8677: LD_INT 32
8679: PUSH
8680: LD_INT 33
8682: PUSH
8683: EMPTY
8684: LIST
8685: LIST
8686: IN
8687: IFFALSE 8795
// buildingsToSave = buildingsToSave ^ [ [ GetBType ( i ) , GetX ( i ) , GetY ( i ) , GetDir ( i ) , GetBLevel ( i ) , GetNation ( i ) , GetLives ( i ) , GetBWeapon ( i ) ] ] else
8689: LD_ADDR_VAR 0 5
8693: PUSH
8694: LD_VAR 0 5
8698: PUSH
8699: LD_VAR 0 4
8703: PPUSH
8704: CALL_OW 266
8708: PUSH
8709: LD_VAR 0 4
8713: PPUSH
8714: CALL_OW 250
8718: PUSH
8719: LD_VAR 0 4
8723: PPUSH
8724: CALL_OW 251
8728: PUSH
8729: LD_VAR 0 4
8733: PPUSH
8734: CALL_OW 254
8738: PUSH
8739: LD_VAR 0 4
8743: PPUSH
8744: CALL_OW 267
8748: PUSH
8749: LD_VAR 0 4
8753: PPUSH
8754: CALL_OW 248
8758: PUSH
8759: LD_VAR 0 4
8763: PPUSH
8764: CALL_OW 256
8768: PUSH
8769: LD_VAR 0 4
8773: PPUSH
8774: CALL_OW 269
8778: PUSH
8779: EMPTY
8780: LIST
8781: LIST
8782: LIST
8783: LIST
8784: LIST
8785: LIST
8786: LIST
8787: LIST
8788: PUSH
8789: EMPTY
8790: LIST
8791: ADD
8792: ST_TO_ADDR
8793: GO 9062
// if GetBType ( i ) in [ b_depot , b_warehouse ] then
8795: LD_VAR 0 4
8799: PPUSH
8800: CALL_OW 266
8804: PUSH
8805: LD_INT 0
8807: PUSH
8808: LD_INT 1
8810: PUSH
8811: EMPTY
8812: LIST
8813: LIST
8814: IN
8815: IFFALSE 8969
// buildingsToSave = buildingsToSave ^ [ [ GetBType ( i ) , GetX ( i ) , GetY ( i ) , GetDir ( i ) , GetBLevel ( i ) , GetNation ( i ) , GetLives ( i ) , GetResourceType ( GetBase ( i ) , mat_cans ) , GetResourceType ( GetBase ( i ) , mat_oil ) , GetResourceType ( GetBase ( i ) , mat_siberit ) ] ] else
8817: LD_ADDR_VAR 0 5
8821: PUSH
8822: LD_VAR 0 5
8826: PUSH
8827: LD_VAR 0 4
8831: PPUSH
8832: CALL_OW 266
8836: PUSH
8837: LD_VAR 0 4
8841: PPUSH
8842: CALL_OW 250
8846: PUSH
8847: LD_VAR 0 4
8851: PPUSH
8852: CALL_OW 251
8856: PUSH
8857: LD_VAR 0 4
8861: PPUSH
8862: CALL_OW 254
8866: PUSH
8867: LD_VAR 0 4
8871: PPUSH
8872: CALL_OW 267
8876: PUSH
8877: LD_VAR 0 4
8881: PPUSH
8882: CALL_OW 248
8886: PUSH
8887: LD_VAR 0 4
8891: PPUSH
8892: CALL_OW 256
8896: PUSH
8897: LD_VAR 0 4
8901: PPUSH
8902: CALL_OW 274
8906: PPUSH
8907: LD_INT 1
8909: PPUSH
8910: CALL_OW 275
8914: PUSH
8915: LD_VAR 0 4
8919: PPUSH
8920: CALL_OW 274
8924: PPUSH
8925: LD_INT 2
8927: PPUSH
8928: CALL_OW 275
8932: PUSH
8933: LD_VAR 0 4
8937: PPUSH
8938: CALL_OW 274
8942: PPUSH
8943: LD_INT 3
8945: PPUSH
8946: CALL_OW 275
8950: PUSH
8951: EMPTY
8952: LIST
8953: LIST
8954: LIST
8955: LIST
8956: LIST
8957: LIST
8958: LIST
8959: LIST
8960: LIST
8961: LIST
8962: PUSH
8963: EMPTY
8964: LIST
8965: ADD
8966: ST_TO_ADDR
8967: GO 9062
// buildingsToSave = buildingsToSave ^ [ [ GetBType ( i ) , GetX ( i ) , GetY ( i ) , GetDir ( i ) , GetBLevel ( i ) , GetNation ( i ) , GetLives ( i ) ] ] ;
8969: LD_ADDR_VAR 0 5
8973: PUSH
8974: LD_VAR 0 5
8978: PUSH
8979: LD_VAR 0 4
8983: PPUSH
8984: CALL_OW 266
8988: PUSH
8989: LD_VAR 0 4
8993: PPUSH
8994: CALL_OW 250
8998: PUSH
8999: LD_VAR 0 4
9003: PPUSH
9004: CALL_OW 251
9008: PUSH
9009: LD_VAR 0 4
9013: PPUSH
9014: CALL_OW 254
9018: PUSH
9019: LD_VAR 0 4
9023: PPUSH
9024: CALL_OW 267
9028: PUSH
9029: LD_VAR 0 4
9033: PPUSH
9034: CALL_OW 248
9038: PUSH
9039: LD_VAR 0 4
9043: PPUSH
9044: CALL_OW 256
9048: PUSH
9049: EMPTY
9050: LIST
9051: LIST
9052: LIST
9053: LIST
9054: LIST
9055: LIST
9056: LIST
9057: PUSH
9058: EMPTY
9059: LIST
9060: ADD
9061: ST_TO_ADDR
// end ;
9062: GO 8515
9064: POP
9065: POP
// SaveVariable ( buildingsToSave , ident ) ;
9066: LD_VAR 0 5
9070: PPUSH
9071: LD_VAR 0 2
9075: PPUSH
9076: CALL_OW 39
// end ; end_of_file
9080: LD_VAR 0 3
9084: RET
// export function MissionIntro ; begin
9085: LD_INT 0
9087: PPUSH
// CenterNowOnUnits ( Burlak ) ;
9088: LD_EXP 57
9092: PPUSH
9093: CALL_OW 87
// DialogueOn ;
9097: CALL_OW 6
// SayRadio ( Popov , DStart-Pop-1 ) ;
9101: LD_EXP 76
9105: PPUSH
9106: LD_STRING DStart-Pop-1
9108: PPUSH
9109: CALL_OW 94
// Say ( Burlak , DStart-Bur-1 ) ;
9113: LD_EXP 57
9117: PPUSH
9118: LD_STRING DStart-Bur-1
9120: PPUSH
9121: CALL_OW 88
// DialogueOff ;
9125: CALL_OW 7
// IngameOff ;
9129: CALL_OW 9
// ChangeMissionObjectives ( MStart ) ;
9133: LD_STRING MStart
9135: PPUSH
9136: CALL_OW 337
// SaveForQuickRestart ;
9140: CALL_OW 22
// end ;
9144: LD_VAR 0 1
9148: RET
// export function Dial_EscortHeike ( x , y ) ; begin
9149: LD_INT 0
9151: PPUSH
// dial_BuildDepotBlocker = true ;
9152: LD_ADDR_EXP 5
9156: PUSH
9157: LD_INT 1
9159: ST_TO_ADDR
// HeikeTargetX = x ;
9160: LD_ADDR_EXP 14
9164: PUSH
9165: LD_VAR 0 1
9169: ST_TO_ADDR
// HeikeTargetY = y ;
9170: LD_ADDR_EXP 15
9174: PUSH
9175: LD_VAR 0 2
9179: ST_TO_ADDR
// SayRadio ( Popov , DHeike-Pop-1 ) ;
9180: LD_EXP 76
9184: PPUSH
9185: LD_STRING DHeike-Pop-1
9187: PPUSH
9188: CALL_OW 94
// wait ( 0 0$10 ) ;
9192: LD_INT 350
9194: PPUSH
9195: CALL_OW 67
// PrepareRussianEscort ;
9199: CALL 2320 0 0
// PlaceUnitArea ( Heike , RussianSpawn2Area , false ) ;
9203: LD_EXP 79
9207: PPUSH
9208: LD_INT 7
9210: PPUSH
9211: LD_INT 0
9213: PPUSH
9214: CALL_OW 49
// ComMoveXY ( russianEscort , HeikeTargetX , HeikeTargetY ) ;
9218: LD_EXP 77
9222: PPUSH
9223: LD_EXP 14
9227: PPUSH
9228: LD_EXP 15
9232: PPUSH
9233: CALL_OW 111
// AddComMoveToArea ( russianEscort , RussianSpawn2Area ) ;
9237: LD_EXP 77
9241: PPUSH
9242: LD_INT 7
9244: PPUSH
9245: CALL_OW 173
// ComMoveXY ( Heike , HeikeTargetX , HeikeTargetY ) ;
9249: LD_EXP 79
9253: PPUSH
9254: LD_EXP 14
9258: PPUSH
9259: LD_EXP 15
9263: PPUSH
9264: CALL_OW 111
// AddComHold ( Heike ) ;
9268: LD_EXP 79
9272: PPUSH
9273: CALL_OW 200
// end ;
9277: LD_VAR 0 3
9281: RET
// every 1 trigger GetDistUnitXY ( Heike , HeikeTargetX , HeikeTargetY ) <= 5 do
9282: LD_EXP 79
9286: PPUSH
9287: LD_EXP 14
9291: PPUSH
9292: LD_EXP 15
9296: PPUSH
9297: CALL_OW 297
9301: PUSH
9302: LD_INT 5
9304: LESSEQUAL
9305: IFFALSE 9318
9307: GO 9309
9309: DISABLE
// allowExitFromMap = 1 ;
9310: LD_ADDR_EXP 18
9314: PUSH
9315: LD_INT 1
9317: ST_TO_ADDR
9318: END
// every 7 7$0 trigger IsPlaced ( Heike ) and IsOk ( Heike ) and GetAttitude ( 3 , 5 ) = att_friend and HeikeCaptured do
9319: LD_EXP 79
9323: PPUSH
9324: CALL_OW 305
9328: PUSH
9329: LD_EXP 79
9333: PPUSH
9334: CALL_OW 302
9338: AND
9339: PUSH
9340: LD_INT 3
9342: PPUSH
9343: LD_INT 5
9345: PPUSH
9346: CALL_OW 81
9350: PUSH
9351: LD_INT 1
9353: EQUAL
9354: AND
9355: PUSH
9356: LD_EXP 1
9360: AND
9361: IFFALSE 9580
9363: GO 9365
9365: DISABLE
// begin DialogueOn ;
9366: CALL_OW 6
// SayRadio ( Kurt , DMercHelp-Kurt-1 ) ;
9370: LD_EXP 80
9374: PPUSH
9375: LD_STRING DMercHelp-Kurt-1
9377: PPUSH
9378: CALL_OW 94
// Say ( Burlak , DMercHelp-Bur-1 ) ;
9382: LD_EXP 57
9386: PPUSH
9387: LD_STRING DMercHelp-Bur-1
9389: PPUSH
9390: CALL_OW 88
// SayRadio ( Kurt , DMercHelp-Kurt-2 ) ;
9394: LD_EXP 80
9398: PPUSH
9399: LD_STRING DMercHelp-Kurt-2
9401: PPUSH
9402: CALL_OW 94
// Say ( Burlak , DMercHelp-Bur-2 ) ;
9406: LD_EXP 57
9410: PPUSH
9411: LD_STRING DMercHelp-Bur-2
9413: PPUSH
9414: CALL_OW 88
// SayRadio ( Kurt , DMercHelp-Kurt-3 ) ;
9418: LD_EXP 80
9422: PPUSH
9423: LD_STRING DMercHelp-Kurt-3
9425: PPUSH
9426: CALL_OW 94
// case Query ( QMerc ) of 1 :
9430: LD_STRING QMerc
9432: PPUSH
9433: CALL_OW 97
9437: PUSH
9438: LD_INT 1
9440: DOUBLE
9441: EQUAL
9442: IFTRUE 9446
9444: GO 9481
9446: POP
// begin Say ( Burlak , DQrMerc#1-Bur-1 ) ;
9447: LD_EXP 57
9451: PPUSH
9452: LD_STRING DQrMerc#1-Bur-1
9454: PPUSH
9455: CALL_OW 88
// SayRadio ( Kurt , DQrMerc#1-Kurt-1 ) ;
9459: LD_EXP 80
9463: PPUSH
9464: LD_STRING DQrMerc#1-Kurt-1
9466: PPUSH
9467: CALL_OW 94
// acceptKurtOffert = true ;
9471: LD_ADDR_EXP 19
9475: PUSH
9476: LD_INT 1
9478: ST_TO_ADDR
// end ; 2 :
9479: GO 9576
9481: LD_INT 2
9483: DOUBLE
9484: EQUAL
9485: IFTRUE 9489
9487: GO 9544
9489: POP
// begin askCommanders = true ;
9490: LD_ADDR_EXP 20
9494: PUSH
9495: LD_INT 1
9497: ST_TO_ADDR
// Say ( Burlak , DQrMerc#2-Bur-1 ) ;
9498: LD_EXP 57
9502: PPUSH
9503: LD_STRING DQrMerc#2-Bur-1
9505: PPUSH
9506: CALL_OW 88
// SayRadio ( Popov , DQrMerc#2-Pop-1 ) ;
9510: LD_EXP 76
9514: PPUSH
9515: LD_STRING DQrMerc#2-Pop-1
9517: PPUSH
9518: CALL_OW 94
// Say ( Burlak , DQrMerc#2-Bur-2 ) ;
9522: LD_EXP 57
9526: PPUSH
9527: LD_STRING DQrMerc#2-Bur-2
9529: PPUSH
9530: CALL_OW 88
// acceptKurtOffert = true ;
9534: LD_ADDR_EXP 19
9538: PUSH
9539: LD_INT 1
9541: ST_TO_ADDR
// end ; 3 :
9542: GO 9576
9544: LD_INT 3
9546: DOUBLE
9547: EQUAL
9548: IFTRUE 9552
9550: GO 9575
9552: POP
// begin Say ( Burlak , DQrMerc#3-Bur-1 ) ;
9553: LD_EXP 57
9557: PPUSH
9558: LD_STRING DQrMerc#3-Bur-1
9560: PPUSH
9561: CALL_OW 88
// KurtAttack = true ;
9565: LD_ADDR_EXP 25
9569: PUSH
9570: LD_INT 1
9572: ST_TO_ADDR
// end ; end ;
9573: GO 9576
9575: POP
// DialogueOff ;
9576: CALL_OW 7
// end ;
9580: END
// every 0 0$1 trigger acceptKurtOffert do
9581: LD_EXP 19
9585: IFFALSE 9741
9587: GO 9589
9589: DISABLE
// begin PlaceUnitArea ( Kurt , KurtSpawnArea , false ) ;
9590: LD_EXP 80
9594: PPUSH
9595: LD_INT 9
9597: PPUSH
9598: LD_INT 0
9600: PPUSH
9601: CALL_OW 49
// uc_side = 8 ;
9605: LD_ADDR_OWVAR 20
9609: PUSH
9610: LD_INT 8
9612: ST_TO_ADDR
// uc_nation = 2 ;
9613: LD_ADDR_OWVAR 21
9617: PUSH
9618: LD_INT 2
9620: ST_TO_ADDR
// PrepareEngineer ( false , 3 ) ;
9621: LD_INT 0
9623: PPUSH
9624: LD_INT 3
9626: PPUSH
9627: CALL_OW 382
// KurtEng = CreateHuman ;
9631: LD_ADDR_EXP 82
9635: PUSH
9636: CALL_OW 44
9640: ST_TO_ADDR
// PlaceUnitArea ( KurtEng , KurtSpawnArea , false ) ;
9641: LD_EXP 82
9645: PPUSH
9646: LD_INT 9
9648: PPUSH
9649: LD_INT 0
9651: PPUSH
9652: CALL_OW 49
// repeat wait ( 0 0$1 ) ;
9656: LD_INT 35
9658: PPUSH
9659: CALL_OW 67
// ComMoveXY ( [ Kurt , KurtEng ] , GetX ( Burlak ) , GetY ( Burlak ) ) ;
9663: LD_EXP 80
9667: PUSH
9668: LD_EXP 82
9672: PUSH
9673: EMPTY
9674: LIST
9675: LIST
9676: PPUSH
9677: LD_EXP 57
9681: PPUSH
9682: CALL_OW 250
9686: PPUSH
9687: LD_EXP 57
9691: PPUSH
9692: CALL_OW 251
9696: PPUSH
9697: CALL_OW 111
// until GetDistUnits ( Kurt , Burlak ) <= 5 or GetDistUnits ( KurtEng , Burlak ) <= 5 ;
9701: LD_EXP 80
9705: PPUSH
9706: LD_EXP 57
9710: PPUSH
9711: CALL_OW 296
9715: PUSH
9716: LD_INT 5
9718: LESSEQUAL
9719: PUSH
9720: LD_EXP 82
9724: PPUSH
9725: LD_EXP 57
9729: PPUSH
9730: CALL_OW 296
9734: PUSH
9735: LD_INT 5
9737: LESSEQUAL
9738: OR
9739: IFFALSE 9656
// end ;
9741: END
// every 0 0$1 trigger GetDistUnits ( Kurt , Burlak ) <= 5 or GetDistUnits ( KurtEng , Burlak ) <= 5 do
9742: LD_EXP 80
9746: PPUSH
9747: LD_EXP 57
9751: PPUSH
9752: CALL_OW 296
9756: PUSH
9757: LD_INT 5
9759: LESSEQUAL
9760: PUSH
9761: LD_EXP 82
9765: PPUSH
9766: LD_EXP 57
9770: PPUSH
9771: CALL_OW 296
9775: PUSH
9776: LD_INT 5
9778: LESSEQUAL
9779: OR
9780: IFFALSE 9959
9782: GO 9784
9784: DISABLE
// begin KurtWaitingForBuildBarrack = true ;
9785: LD_ADDR_EXP 24
9789: PUSH
9790: LD_INT 1
9792: ST_TO_ADDR
// SetSide ( KurtEng , 3 ) ;
9793: LD_EXP 82
9797: PPUSH
9798: LD_INT 3
9800: PPUSH
9801: CALL_OW 235
// wait ( 1 1$30 ) ;
9805: LD_INT 3150
9807: PPUSH
9808: CALL_OW 67
// DialogueOn ;
9812: CALL_OW 6
// SayRadio ( Dietrich , DArabianRequest-Diet-1 ) ;
9816: LD_EXP 81
9820: PPUSH
9821: LD_STRING DArabianRequest-Diet-1
9823: PPUSH
9824: CALL_OW 94
// Say ( Burlak , DArabianRequest-Bur-1 ) ;
9828: LD_EXP 57
9832: PPUSH
9833: LD_STRING DArabianRequest-Bur-1
9835: PPUSH
9836: CALL_OW 88
// SayRadio ( Dietrich , DArabianRequest-Diet-2 ) ;
9840: LD_EXP 81
9844: PPUSH
9845: LD_STRING DArabianRequest-Diet-2
9847: PPUSH
9848: CALL_OW 94
// DialogueOff ;
9852: CALL_OW 7
// case Query ( QHandOver ) of 1 :
9856: LD_STRING QHandOver
9858: PPUSH
9859: CALL_OW 97
9863: PUSH
9864: LD_INT 1
9866: DOUBLE
9867: EQUAL
9868: IFTRUE 9872
9870: GO 9911
9872: POP
// begin Say ( Burlak , DQrHandOver#1-Bur-1 ) ;
9873: LD_EXP 57
9877: PPUSH
9878: LD_STRING DQrHandOver#1-Bur-1
9880: PPUSH
9881: CALL_OW 88
// SayRadio ( Dietrich , DQrHandOver#1-Diet-1 ) ;
9885: LD_EXP 81
9889: PPUSH
9890: LD_STRING DQrHandOver#1-Diet-1
9892: PPUSH
9893: CALL_OW 94
// coopWithGensher = true ;
9897: LD_ADDR_EXP 2
9901: PUSH
9902: LD_INT 1
9904: ST_TO_ADDR
// SpawnGensherTeam ;
9905: CALL 3946 0 0
// end ; 2 :
9909: GO 9959
9911: LD_INT 2
9913: DOUBLE
9914: EQUAL
9915: IFTRUE 9919
9917: GO 9958
9919: POP
// begin Say ( Burlak , DQrHandOver#2-Bur-1 ) ;
9920: LD_EXP 57
9924: PPUSH
9925: LD_STRING DQrHandOver#2-Bur-1
9927: PPUSH
9928: CALL_OW 88
// SayRadio ( Dietrich , DQrHandOver#2-Diet-1 ) ;
9932: LD_EXP 81
9936: PPUSH
9937: LD_STRING DQrHandOver#2-Diet-1
9939: PPUSH
9940: CALL_OW 94
// Say ( Burlak , DQrHandOver#2-Bur-2 ) ;
9944: LD_EXP 57
9948: PPUSH
9949: LD_STRING DQrHandOver#2-Bur-2
9951: PPUSH
9952: CALL_OW 88
// end ; end ;
9956: GO 9959
9958: POP
// end ;
9959: END
// export function Dial_UpgradeArmoury ; begin
9960: LD_INT 0
9962: PPUSH
// dial_BuildArBarrackBlocker = true ;
9963: LD_ADDR_EXP 6
9967: PUSH
9968: LD_INT 1
9970: ST_TO_ADDR
// buildArabBarrack = true ;
9971: LD_ADDR_EXP 38
9975: PUSH
9976: LD_INT 1
9978: ST_TO_ADDR
// if GetSide ( Kurt ) = 2 or GetSide ( KurtEng ) = 8 then
9979: LD_EXP 80
9983: PPUSH
9984: CALL_OW 255
9988: PUSH
9989: LD_INT 2
9991: EQUAL
9992: PUSH
9993: LD_EXP 82
9997: PPUSH
9998: CALL_OW 255
10002: PUSH
10003: LD_INT 8
10005: EQUAL
10006: OR
10007: IFFALSE 10011
// exit ;
10009: GO 10111
// SetSide ( KurtEng , 8 ) ;
10011: LD_EXP 82
10015: PPUSH
10016: LD_INT 8
10018: PPUSH
10019: CALL_OW 235
// ComStop ( KurtEng ) ;
10023: LD_EXP 82
10027: PPUSH
10028: CALL_OW 141
// DialogueOn ;
10032: CALL_OW 6
// Say ( Kurt , DMercCompleted-Kurt-1 ) ;
10036: LD_EXP 80
10040: PPUSH
10041: LD_STRING DMercCompleted-Kurt-1
10043: PPUSH
10044: CALL_OW 88
// DialogueOff ;
10048: CALL_OW 7
// canSendHeike = true ;
10052: LD_ADDR_EXP 28
10056: PUSH
10057: LD_INT 1
10059: ST_TO_ADDR
// KurtWaitingForFreeHeike = true ;
10060: LD_ADDR_EXP 23
10064: PUSH
10065: LD_INT 1
10067: ST_TO_ADDR
// KurtWaitingForBuildBarrack = false ;
10068: LD_ADDR_EXP 24
10072: PUSH
10073: LD_INT 0
10075: ST_TO_ADDR
// allowExitFromMap = 3 ;
10076: LD_ADDR_EXP 18
10080: PUSH
10081: LD_INT 3
10083: ST_TO_ADDR
// if KurtCanEscape then
10084: LD_EXP 21
10088: IFFALSE 10111
// ComMoveToArea ( [ Kurt , KurtEng ] , KurtExitMapArea ) ;
10090: LD_EXP 80
10094: PUSH
10095: LD_EXP 82
10099: PUSH
10100: EMPTY
10101: LIST
10102: LIST
10103: PPUSH
10104: LD_INT 11
10106: PPUSH
10107: CALL_OW 113
// end ;
10111: LD_VAR 0 1
10115: RET
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 2 ] ] ) and not dial_ArriveGensherUnitsBlocker do var veh , nearGensherUnit , maleSold , waitForKurt ;
10116: LD_INT 22
10118: PUSH
10119: LD_INT 2
10121: PUSH
10122: EMPTY
10123: LIST
10124: LIST
10125: PUSH
10126: EMPTY
10127: LIST
10128: PPUSH
10129: CALL_OW 69
10133: PUSH
10134: LD_EXP 7
10138: NOT
10139: AND
10140: IFFALSE 10913
10142: GO 10144
10144: DISABLE
10145: LD_INT 0
10147: PPUSH
10148: PPUSH
10149: PPUSH
10150: PPUSH
// begin nearGensherUnit = NearestUnitToXY ( UnitFilter ( GensherTeam , [ [ f_type , unit_vehicle ] ] ) , GensherTargetX , GensherTargetY ) ;
10151: LD_ADDR_VAR 0 2
10155: PUSH
10156: LD_EXP 83
10160: PPUSH
10161: LD_INT 21
10163: PUSH
10164: LD_INT 2
10166: PUSH
10167: EMPTY
10168: LIST
10169: LIST
10170: PUSH
10171: EMPTY
10172: LIST
10173: PPUSH
10174: CALL_OW 72
10178: PPUSH
10179: LD_EXP 16
10183: PPUSH
10184: LD_EXP 17
10188: PPUSH
10189: CALL_OW 73
10193: ST_TO_ADDR
// maleSold = UnitsInside ( nearGensherUnit [ 1 ] ) ;
10194: LD_ADDR_VAR 0 3
10198: PUSH
10199: LD_VAR 0 2
10203: PUSH
10204: LD_INT 1
10206: ARRAY
10207: PPUSH
10208: CALL_OW 313
10212: ST_TO_ADDR
// if GetDistUnitXY ( nearGensherUnit , GensherTargetX , GensherTargetY ) <= 5 then
10213: LD_VAR 0 2
10217: PPUSH
10218: LD_EXP 16
10222: PPUSH
10223: LD_EXP 17
10227: PPUSH
10228: CALL_OW 297
10232: PUSH
10233: LD_INT 5
10235: LESSEQUAL
10236: IFFALSE 10912
// begin dial_ArriveGensherUnitsBlocker = true ;
10238: LD_ADDR_EXP 7
10242: PUSH
10243: LD_INT 1
10245: ST_TO_ADDR
// for veh in UnitFilter ( GensherTeam , [ [ f_type , unit_vehicle ] ] ) do
10246: LD_ADDR_VAR 0 1
10250: PUSH
10251: LD_EXP 83
10255: PPUSH
10256: LD_INT 21
10258: PUSH
10259: LD_INT 2
10261: PUSH
10262: EMPTY
10263: LIST
10264: LIST
10265: PUSH
10266: EMPTY
10267: LIST
10268: PPUSH
10269: CALL_OW 72
10273: PUSH
10274: FOR_IN
10275: IFFALSE 10297
// ComExitVehicle ( UnitsInside ( veh ) [ 1 ] ) ;
10277: LD_VAR 0 1
10281: PPUSH
10282: CALL_OW 313
10286: PUSH
10287: LD_INT 1
10289: ARRAY
10290: PPUSH
10291: CALL_OW 121
10295: GO 10274
10297: POP
10298: POP
// wait ( 0 0$1 ) ;
10299: LD_INT 35
10301: PPUSH
10302: CALL_OW 67
// SetSide ( UnitFilter ( GensherTeam , [ [ f_type , unit_vehicle ] ] ) , 3 ) ;
10306: LD_EXP 83
10310: PPUSH
10311: LD_INT 21
10313: PUSH
10314: LD_INT 2
10316: PUSH
10317: EMPTY
10318: LIST
10319: LIST
10320: PUSH
10321: EMPTY
10322: LIST
10323: PPUSH
10324: CALL_OW 72
10328: PPUSH
10329: LD_INT 3
10331: PPUSH
10332: CALL_OW 235
// CenterOnUnits ( maleSold ) ;
10336: LD_VAR 0 3
10340: PPUSH
10341: CALL_OW 85
// DialogueOn ;
10345: CALL_OW 6
// Say ( maleSold , DHandOverCome-ASol1-1 ) ;
10349: LD_VAR 0 3
10353: PPUSH
10354: LD_STRING DHandOverCome-ASol1-1
10356: PPUSH
10357: CALL_OW 88
// Say ( Kurt , DHandOverCome-Kurt-1 ) ;
10361: LD_EXP 80
10365: PPUSH
10366: LD_STRING DHandOverCome-Kurt-1
10368: PPUSH
10369: CALL_OW 88
// DialogueOff ;
10373: CALL_OW 7
// KurtWaitingForBuildBarrack = false ;
10377: LD_ADDR_EXP 24
10381: PUSH
10382: LD_INT 0
10384: ST_TO_ADDR
// if GetDistUnits ( Kurt , UnitFilter ( GensherTeam , [ f_type , unit_vehicle ] ) [ 1 ] ) <= 8 or GetSide ( KurtEng ) = 3 then
10385: LD_EXP 80
10389: PPUSH
10390: LD_EXP 83
10394: PPUSH
10395: LD_INT 21
10397: PUSH
10398: LD_INT 2
10400: PUSH
10401: EMPTY
10402: LIST
10403: LIST
10404: PPUSH
10405: CALL_OW 72
10409: PUSH
10410: LD_INT 1
10412: ARRAY
10413: PPUSH
10414: CALL_OW 296
10418: PUSH
10419: LD_INT 8
10421: LESSEQUAL
10422: PUSH
10423: LD_EXP 82
10427: PPUSH
10428: CALL_OW 255
10432: PUSH
10433: LD_INT 3
10435: EQUAL
10436: OR
10437: IFFALSE 10542
// begin KurtCanEscape = false ;
10439: LD_ADDR_EXP 21
10443: PUSH
10444: LD_INT 0
10446: ST_TO_ADDR
// SetSide ( [ Kurt , KurtEng ] , 2 ) ;
10447: LD_EXP 80
10451: PUSH
10452: LD_EXP 82
10456: PUSH
10457: EMPTY
10458: LIST
10459: LIST
10460: PPUSH
10461: LD_INT 2
10463: PPUSH
10464: CALL_OW 235
// ComStop ( [ Kurt , KurtEng ] ) ;
10468: LD_EXP 80
10472: PUSH
10473: LD_EXP 82
10477: PUSH
10478: EMPTY
10479: LIST
10480: LIST
10481: PPUSH
10482: CALL_OW 141
// ComMoveXY ( [ Kurt , KurtEng ] , GetX ( maleSold ) , GetY ( maleSold ) ) ;
10486: LD_EXP 80
10490: PUSH
10491: LD_EXP 82
10495: PUSH
10496: EMPTY
10497: LIST
10498: LIST
10499: PPUSH
10500: LD_VAR 0 3
10504: PPUSH
10505: CALL_OW 250
10509: PPUSH
10510: LD_VAR 0 3
10514: PPUSH
10515: CALL_OW 251
10519: PPUSH
10520: CALL_OW 111
// waitForKurt = true ;
10524: LD_ADDR_VAR 0 4
10528: PUSH
10529: LD_INT 1
10531: ST_TO_ADDR
// KurtStatus = 3 ;
10532: LD_ADDR_EXP 22
10536: PUSH
10537: LD_INT 3
10539: ST_TO_ADDR
// end else
10540: GO 10780
// if GetDistUnits ( Kurt , UnitFilter ( GensherTeam , [ f_type , unit_vehicle ] ) [ 1 ] ) > 8 then
10542: LD_EXP 80
10546: PPUSH
10547: LD_EXP 83
10551: PPUSH
10552: LD_INT 21
10554: PUSH
10555: LD_INT 2
10557: PUSH
10558: EMPTY
10559: LIST
10560: LIST
10561: PPUSH
10562: CALL_OW 72
10566: PUSH
10567: LD_INT 1
10569: ARRAY
10570: PPUSH
10571: CALL_OW 296
10575: PUSH
10576: LD_INT 8
10578: GREATER
10579: IFFALSE 10780
// begin allowExitFromMap = 4 ;
10581: LD_ADDR_EXP 18
10585: PUSH
10586: LD_INT 4
10588: ST_TO_ADDR
// KurtStatus = 2 ;
10589: LD_ADDR_EXP 22
10593: PUSH
10594: LD_INT 2
10596: ST_TO_ADDR
// ComMoveToArea ( [ Kurt , KurtEng ] , KurtExitMapArea ) ;
10597: LD_EXP 80
10601: PUSH
10602: LD_EXP 82
10606: PUSH
10607: EMPTY
10608: LIST
10609: LIST
10610: PPUSH
10611: LD_INT 11
10613: PPUSH
10614: CALL_OW 113
// repeat ComAttackUnit ( UnitFilter ( GensherTeam , [ [ f_type , unit_human ] ] ) , Kurt ) ;
10618: LD_EXP 83
10622: PPUSH
10623: LD_INT 21
10625: PUSH
10626: LD_INT 1
10628: PUSH
10629: EMPTY
10630: LIST
10631: LIST
10632: PUSH
10633: EMPTY
10634: LIST
10635: PPUSH
10636: CALL_OW 72
10640: PPUSH
10641: LD_EXP 80
10645: PPUSH
10646: CALL_OW 115
// wait ( 0 0$1 ) ;
10650: LD_INT 35
10652: PPUSH
10653: CALL_OW 67
// until GetDistUnits ( NearestUnitToUnit ( UnitFilter ( GensherTeam , [ [ f_type , unit_human ] ] ) , Kurt ) , Kurt ) <= 9 or ( not IsPlaced ( Kurt ) and not IsPlaced ( KurtEng ) ) ;
10657: LD_EXP 83
10661: PPUSH
10662: LD_INT 21
10664: PUSH
10665: LD_INT 1
10667: PUSH
10668: EMPTY
10669: LIST
10670: LIST
10671: PUSH
10672: EMPTY
10673: LIST
10674: PPUSH
10675: CALL_OW 72
10679: PPUSH
10680: LD_EXP 80
10684: PPUSH
10685: CALL_OW 74
10689: PPUSH
10690: LD_EXP 80
10694: PPUSH
10695: CALL_OW 296
10699: PUSH
10700: LD_INT 9
10702: LESSEQUAL
10703: PUSH
10704: LD_EXP 80
10708: PPUSH
10709: CALL_OW 305
10713: NOT
10714: PUSH
10715: LD_EXP 82
10719: PPUSH
10720: CALL_OW 305
10724: NOT
10725: AND
10726: OR
10727: IFFALSE 10618
// ComMoveToArea ( [ Kurt , KurtEng ] , ExitMapArea ) ;
10729: LD_EXP 80
10733: PUSH
10734: LD_EXP 82
10738: PUSH
10739: EMPTY
10740: LIST
10741: LIST
10742: PPUSH
10743: LD_INT 8
10745: PPUSH
10746: CALL_OW 113
// ComMoveToArea ( UnitFilter ( GensherTeam , [ [ f_type , unit_human ] ] ) , ExitMapArea ) ;
10750: LD_EXP 83
10754: PPUSH
10755: LD_INT 21
10757: PUSH
10758: LD_INT 1
10760: PUSH
10761: EMPTY
10762: LIST
10763: LIST
10764: PUSH
10765: EMPTY
10766: LIST
10767: PPUSH
10768: CALL_OW 72
10772: PPUSH
10773: LD_INT 8
10775: PPUSH
10776: CALL_OW 113
// end ; if waitForKurt then
10780: LD_VAR 0 4
10784: IFFALSE 10910
// begin repeat wait ( 0 0$1 ) ;
10786: LD_INT 35
10788: PPUSH
10789: CALL_OW 67
// ComMoveXY ( [ Kurt , KurtEng ] , GetX ( maleSold ) , GetY ( maleSold ) ) ;
10793: LD_EXP 80
10797: PUSH
10798: LD_EXP 82
10802: PUSH
10803: EMPTY
10804: LIST
10805: LIST
10806: PPUSH
10807: LD_VAR 0 3
10811: PPUSH
10812: CALL_OW 250
10816: PPUSH
10817: LD_VAR 0 3
10821: PPUSH
10822: CALL_OW 251
10826: PPUSH
10827: CALL_OW 111
// until GetDistUnits ( Kurt , maleSold ) <= 2 ;
10831: LD_EXP 80
10835: PPUSH
10836: LD_VAR 0 3
10840: PPUSH
10841: CALL_OW 296
10845: PUSH
10846: LD_INT 2
10848: LESSEQUAL
10849: IFFALSE 10786
// allowExitFromMap = 4 ;
10851: LD_ADDR_EXP 18
10855: PUSH
10856: LD_INT 4
10858: ST_TO_ADDR
// ComMoveToArea ( [ Kurt , KurtEng ] , ExitMapArea ) ;
10859: LD_EXP 80
10863: PUSH
10864: LD_EXP 82
10868: PUSH
10869: EMPTY
10870: LIST
10871: LIST
10872: PPUSH
10873: LD_INT 8
10875: PPUSH
10876: CALL_OW 113
// ComMoveToArea ( UnitFilter ( GensherTeam , [ [ f_type , unit_human ] ] ) , ExitMapArea ) ;
10880: LD_EXP 83
10884: PPUSH
10885: LD_INT 21
10887: PUSH
10888: LD_INT 1
10890: PUSH
10891: EMPTY
10892: LIST
10893: LIST
10894: PUSH
10895: EMPTY
10896: LIST
10897: PPUSH
10898: CALL_OW 72
10902: PPUSH
10903: LD_INT 8
10905: PPUSH
10906: CALL_OW 113
// end ; exit ;
10910: GO 10913
// end ; enable ;
10912: ENABLE
// end ;
10913: PPOPN 4
10915: END
// export function Dial_AttackGensher ; var unit ; begin
10916: LD_INT 0
10918: PPUSH
10919: PPUSH
// DialogueOn ;
10920: CALL_OW 6
// SayRadio ( Dietrich , DHandOverSpoiled-Diet-1 ) ;
10924: LD_EXP 81
10928: PPUSH
10929: LD_STRING DHandOverSpoiled-Diet-1
10931: PPUSH
10932: CALL_OW 94
// DialogueOff ;
10936: CALL_OW 7
// SetAttitude ( 3 , 2 , att_enemy , true ) ;
10940: LD_INT 3
10942: PPUSH
10943: LD_INT 2
10945: PPUSH
10946: LD_INT 2
10948: PPUSH
10949: LD_INT 1
10951: PPUSH
10952: CALL_OW 80
// for unit in UnitFilter ( GensherTeam , [ [ f_type , unit_human ] ] ) do
10956: LD_ADDR_VAR 0 2
10960: PUSH
10961: LD_EXP 83
10965: PPUSH
10966: LD_INT 21
10968: PUSH
10969: LD_INT 1
10971: PUSH
10972: EMPTY
10973: LIST
10974: LIST
10975: PUSH
10976: EMPTY
10977: LIST
10978: PPUSH
10979: CALL_OW 72
10983: PUSH
10984: FOR_IN
10985: IFFALSE 11045
// begin if IsInUnit ( unit ) then
10987: LD_VAR 0 2
10991: PPUSH
10992: CALL_OW 310
10996: IFFALSE 11007
// ComExitVehicle ( unit ) ;
10998: LD_VAR 0 2
11002: PPUSH
11003: CALL_OW 121
// wait ( 0 0$01 ) ;
11007: LD_INT 35
11009: PPUSH
11010: CALL_OW 67
// AddComAgressiveMove ( unit , GetX ( Burlak ) , GetY ( Burlak ) ) ;
11014: LD_VAR 0 2
11018: PPUSH
11019: LD_EXP 57
11023: PPUSH
11024: CALL_OW 250
11028: PPUSH
11029: LD_EXP 57
11033: PPUSH
11034: CALL_OW 251
11038: PPUSH
11039: CALL_OW 174
// end ;
11043: GO 10984
11045: POP
11046: POP
// coopWithGensher = 2 ;
11047: LD_ADDR_EXP 2
11051: PUSH
11052: LD_INT 2
11054: ST_TO_ADDR
// end ;
11055: LD_VAR 0 1
11059: RET
// every 0 0$1 trigger canSendHeike and IsOK ( Heike ) and GetSide ( Heike ) = 5 do var legionSold ;
11060: LD_EXP 28
11064: PUSH
11065: LD_EXP 79
11069: PPUSH
11070: CALL_OW 302
11074: AND
11075: PUSH
11076: LD_EXP 79
11080: PPUSH
11081: CALL_OW 255
11085: PUSH
11086: LD_INT 5
11088: EQUAL
11089: AND
11090: IFFALSE 11410
11092: GO 11094
11094: DISABLE
11095: LD_INT 0
11097: PPUSH
// begin if IsSelected ( Heike ) then
11098: LD_EXP 79
11102: PPUSH
11103: CALL_OW 306
11107: IFFALSE 11402
// begin if Query ( QSendHeike ) = 1 then
11109: LD_STRING QSendHeike
11111: PPUSH
11112: CALL_OW 97
11116: PUSH
11117: LD_INT 1
11119: EQUAL
11120: IFFALSE 11402
// begin KurtWaitingForFreeHeike = false ;
11122: LD_ADDR_EXP 23
11126: PUSH
11127: LD_INT 0
11129: ST_TO_ADDR
// ComMoveXY ( Heike , 82 , 46 ) ;
11130: LD_EXP 79
11134: PPUSH
11135: LD_INT 82
11137: PPUSH
11138: LD_INT 46
11140: PPUSH
11141: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
11145: LD_INT 35
11147: PPUSH
11148: CALL_OW 67
// until GetDistUnitXY ( Heike , 82 , 46 ) <= 5 or IsDead ( Heike ) ;
11152: LD_EXP 79
11156: PPUSH
11157: LD_INT 82
11159: PPUSH
11160: LD_INT 46
11162: PPUSH
11163: CALL_OW 297
11167: PUSH
11168: LD_INT 5
11170: LESSEQUAL
11171: PUSH
11172: LD_EXP 79
11176: PPUSH
11177: CALL_OW 301
11181: OR
11182: IFFALSE 11145
// if not askCommanders then
11184: LD_EXP 20
11188: NOT
11189: IFFALSE 11235
// begin DialogueOn ;
11191: CALL_OW 6
// SayRadio ( Popov , DMercPopov-Pop-1 ) ;
11195: LD_EXP 76
11199: PPUSH
11200: LD_STRING DMercPopov-Pop-1
11202: PPUSH
11203: CALL_OW 94
// Say ( Burlak , DMercPopov-Bur-1 ) ;
11207: LD_EXP 57
11211: PPUSH
11212: LD_STRING DMercPopov-Bur-1
11214: PPUSH
11215: CALL_OW 88
// SayRadio ( Popov , DMercPopov-Pop-2 ) ;
11219: LD_EXP 76
11223: PPUSH
11224: LD_STRING DMercPopov-Pop-2
11226: PPUSH
11227: CALL_OW 94
// DialogueOff ;
11231: CALL_OW 7
// end ; uc_side = 8 ;
11235: LD_ADDR_OWVAR 20
11239: PUSH
11240: LD_INT 8
11242: ST_TO_ADDR
// uc_nation = 2 ;
11243: LD_ADDR_OWVAR 21
11247: PUSH
11248: LD_INT 2
11250: ST_TO_ADDR
// PrepareSoldier ( false , 6 ) ;
11251: LD_INT 0
11253: PPUSH
11254: LD_INT 6
11256: PPUSH
11257: CALL_OW 381
// legionSold = CreateHuman ;
11261: LD_ADDR_VAR 0 1
11265: PUSH
11266: CALL_OW 44
11270: ST_TO_ADDR
// PlaceUnitXYR ( legionSold , 26 , 48 , 4 , false ) ;
11271: LD_VAR 0 1
11275: PPUSH
11276: LD_INT 26
11278: PPUSH
11279: LD_INT 48
11281: PPUSH
11282: LD_INT 4
11284: PPUSH
11285: LD_INT 0
11287: PPUSH
11288: CALL_OW 50
// repeat wait ( 0 0$1 ) ;
11292: LD_INT 35
11294: PPUSH
11295: CALL_OW 67
// ComMoveXY ( legionSold , GetX ( Heike ) , GetY ( Heike ) ) ;
11299: LD_VAR 0 1
11303: PPUSH
11304: LD_EXP 79
11308: PPUSH
11309: CALL_OW 250
11313: PPUSH
11314: LD_EXP 79
11318: PPUSH
11319: CALL_OW 251
11323: PPUSH
11324: CALL_OW 111
// until GetDistUnits ( legionSold , Heike ) <= 5 or IsDead ( Heike ) ;
11328: LD_VAR 0 1
11332: PPUSH
11333: LD_EXP 79
11337: PPUSH
11338: CALL_OW 296
11342: PUSH
11343: LD_INT 5
11345: LESSEQUAL
11346: PUSH
11347: LD_EXP 79
11351: PPUSH
11352: CALL_OW 301
11356: OR
11357: IFFALSE 11292
// SetSide ( Heike , 8 ) ;
11359: LD_EXP 79
11363: PPUSH
11364: LD_INT 8
11366: PPUSH
11367: CALL_OW 235
// allowExitFromMap = 3 ;
11371: LD_ADDR_EXP 18
11375: PUSH
11376: LD_INT 3
11378: ST_TO_ADDR
// ComMoveToArea ( [ legionSold , Heike ] , KurtExitMapArea ) ;
11379: LD_VAR 0 1
11383: PUSH
11384: LD_EXP 79
11388: PUSH
11389: EMPTY
11390: LIST
11391: LIST
11392: PPUSH
11393: LD_INT 11
11395: PPUSH
11396: CALL_OW 113
// exit ;
11400: GO 11410
// end ; end ; wait ( 0 0$3 ) ;
11402: LD_INT 105
11404: PPUSH
11405: CALL_OW 67
// enable ;
11409: ENABLE
// end ;
11410: PPOPN 1
11412: END
// export function Dial_PlayerDontSendHeike ; begin
11413: LD_INT 0
11415: PPUSH
// DialogueOn ;
11416: CALL_OW 6
// SayRadio ( Kurt , DMercDeceived-Kurt-1 ) ;
11420: LD_EXP 80
11424: PPUSH
11425: LD_STRING DMercDeceived-Kurt-1
11427: PPUSH
11428: CALL_OW 94
// DialogueOff ;
11432: CALL_OW 7
// SetAttitude ( 3 , 8 , att_enemy , true ) ;
11436: LD_INT 3
11438: PPUSH
11439: LD_INT 8
11441: PPUSH
11442: LD_INT 2
11444: PPUSH
11445: LD_INT 1
11447: PPUSH
11448: CALL_OW 80
// KurtAttack = true ;
11452: LD_ADDR_EXP 25
11456: PUSH
11457: LD_INT 1
11459: ST_TO_ADDR
// end ;
11460: LD_VAR 0 1
11464: RET
// export function Dial_BetrayedKurt1 ; begin
11465: LD_INT 0
11467: PPUSH
// DialogueOn ;
11468: CALL_OW 6
// Say ( Kurt , DMercDeceived-Kurt-1 ) ;
11472: LD_EXP 80
11476: PPUSH
11477: LD_STRING DMercDeceived-Kurt-1
11479: PPUSH
11480: CALL_OW 88
// DialogueOff ;
11484: CALL_OW 7
// if IsPlaced ( Kurt ) then
11488: LD_EXP 80
11492: PPUSH
11493: CALL_OW 305
11497: IFFALSE 11546
// begin SetSide ( KurtEng , 8 ) ;
11499: LD_EXP 82
11503: PPUSH
11504: LD_INT 8
11506: PPUSH
11507: CALL_OW 235
// allowExitFromMap = 3 ;
11511: LD_ADDR_EXP 18
11515: PUSH
11516: LD_INT 3
11518: ST_TO_ADDR
// if KurtCanEscape then
11519: LD_EXP 21
11523: IFFALSE 11546
// ComMoveToArea ( [ Kurt , KurtEng ] , KurtExitMapArea ) ;
11525: LD_EXP 80
11529: PUSH
11530: LD_EXP 82
11534: PUSH
11535: EMPTY
11536: LIST
11537: LIST
11538: PPUSH
11539: LD_INT 11
11541: PPUSH
11542: CALL_OW 113
// end ; end ;
11546: LD_VAR 0 1
11550: RET
// export function Dial_BetrayedKurt2 ; begin
11551: LD_INT 0
11553: PPUSH
// DialogueOn ;
11554: CALL_OW 6
// Say ( Kurt , DMercAmbush-Kurt-1 ) ;
11558: LD_EXP 80
11562: PPUSH
11563: LD_STRING DMercAmbush-Kurt-1
11565: PPUSH
11566: CALL_OW 88
// DialogueOff ;
11570: CALL_OW 7
// if IsPlaced ( Kurt ) then
11574: LD_EXP 80
11578: PPUSH
11579: CALL_OW 305
11583: IFFALSE 11632
// begin SetSide ( KurtEng , 8 ) ;
11585: LD_EXP 82
11589: PPUSH
11590: LD_INT 8
11592: PPUSH
11593: CALL_OW 235
// allowExitFromMap = 3 ;
11597: LD_ADDR_EXP 18
11601: PUSH
11602: LD_INT 3
11604: ST_TO_ADDR
// if KurtCanEscape then
11605: LD_EXP 21
11609: IFFALSE 11632
// ComMoveToArea ( [ Kurt , KurtEng ] , KurtExitMapArea ) ;
11611: LD_EXP 80
11615: PUSH
11616: LD_EXP 82
11620: PUSH
11621: EMPTY
11622: LIST
11623: LIST
11624: PPUSH
11625: LD_INT 11
11627: PPUSH
11628: CALL_OW 113
// end ; end ;
11632: LD_VAR 0 1
11636: RET
// every 0 0$1 trigger GetSide ( KurtEng ) = 3 do var playerUnits , unit ;
11637: LD_EXP 82
11641: PPUSH
11642: CALL_OW 255
11646: PUSH
11647: LD_INT 3
11649: EQUAL
11650: IFFALSE 11797
11652: GO 11654
11654: DISABLE
11655: LD_INT 0
11657: PPUSH
11658: PPUSH
// begin playerUnits = FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
11659: LD_ADDR_VAR 0 1
11663: PUSH
11664: LD_INT 22
11666: PUSH
11667: LD_INT 3
11669: PUSH
11670: EMPTY
11671: LIST
11672: LIST
11673: PUSH
11674: LD_INT 2
11676: PUSH
11677: LD_INT 21
11679: PUSH
11680: LD_INT 1
11682: PUSH
11683: EMPTY
11684: LIST
11685: LIST
11686: PUSH
11687: LD_INT 21
11689: PUSH
11690: LD_INT 2
11692: PUSH
11693: EMPTY
11694: LIST
11695: LIST
11696: PUSH
11697: EMPTY
11698: LIST
11699: LIST
11700: LIST
11701: PUSH
11702: EMPTY
11703: LIST
11704: LIST
11705: PPUSH
11706: CALL_OW 69
11710: ST_TO_ADDR
// for unit in playerUnits do
11711: LD_ADDR_VAR 0 2
11715: PUSH
11716: LD_VAR 0 1
11720: PUSH
11721: FOR_IN
11722: IFFALSE 11751
// begin if WantsToAttack ( unit ) = KurtEng then
11724: LD_VAR 0 2
11728: PPUSH
11729: CALL_OW 319
11733: PUSH
11734: LD_EXP 82
11738: EQUAL
11739: IFFALSE 11749
// begin Dial_BetrayedKurt2 ;
11741: CALL 11551 0 0
// exit ;
11745: POP
11746: POP
11747: GO 11797
// end ; end ;
11749: GO 11721
11751: POP
11752: POP
// if ( IsDying ( KurtEng ) or IsDead ( KurtEng ) ) and GetSide ( KurtEng ) = 3 then
11753: LD_EXP 82
11757: PPUSH
11758: CALL_OW 303
11762: PUSH
11763: LD_EXP 82
11767: PPUSH
11768: CALL_OW 301
11772: OR
11773: PUSH
11774: LD_EXP 82
11778: PPUSH
11779: CALL_OW 255
11783: PUSH
11784: LD_INT 3
11786: EQUAL
11787: AND
11788: IFFALSE 11796
// begin Dial_BetrayedKurt2 ;
11790: CALL 11551 0 0
// exit ;
11794: GO 11797
// end ; enable ;
11796: ENABLE
// end ;
11797: PPOPN 2
11799: END
// every 0 0$1 trigger GetAttitude ( 3 , 8 ) = att_neutral and GetLives ( Kurt ) <= 999 do
11800: LD_INT 3
11802: PPUSH
11803: LD_INT 8
11805: PPUSH
11806: CALL_OW 81
11810: PUSH
11811: LD_INT 0
11813: EQUAL
11814: PUSH
11815: LD_EXP 80
11819: PPUSH
11820: CALL_OW 256
11824: PUSH
11825: LD_INT 999
11827: LESSEQUAL
11828: AND
11829: IFFALSE 11854
11831: GO 11833
11833: DISABLE
// begin Dial_BetrayedKurt1 ;
11834: CALL 11465 0 0
// SetAttitude ( 3 , 8 , att_enemy , true ) ;
11838: LD_INT 3
11840: PPUSH
11841: LD_INT 8
11843: PPUSH
11844: LD_INT 2
11846: PPUSH
11847: LD_INT 1
11849: PPUSH
11850: CALL_OW 80
// end ;
11854: END
// every 0 0$1 trigger buildingsToBuild <= 11 do
11855: LD_EXP 8
11859: PUSH
11860: LD_INT 11
11862: LESSEQUAL
11863: IFFALSE 12112
11865: GO 11867
11867: DISABLE
// begin if not IsOK ( Kuzmov ) and not IsOK ( Oblukov ) then
11868: LD_EXP 72
11872: PPUSH
11873: CALL_OW 302
11877: NOT
11878: PUSH
11879: LD_EXP 74
11883: PPUSH
11884: CALL_OW 302
11888: NOT
11889: AND
11890: IFFALSE 11894
// exit ;
11892: GO 12112
// DialogueOn ;
11894: CALL_OW 6
// if IsOK ( Kuzmov ) then
11898: LD_EXP 72
11902: PPUSH
11903: CALL_OW 302
11907: IFFALSE 11923
// Say ( Kuzmov , DFiringRange-Kuz-1 ) else
11909: LD_EXP 72
11913: PPUSH
11914: LD_STRING DFiringRange-Kuz-1
11916: PPUSH
11917: CALL_OW 88
11921: GO 11935
// Say ( Oblukov , DFiringRange-Obl-1 ) ;
11923: LD_EXP 74
11927: PPUSH
11928: LD_STRING DFiringRange-Obl-1
11930: PPUSH
11931: CALL_OW 88
// Say ( Burlak , DFiringRange-Bur-1 ) ;
11935: LD_EXP 57
11939: PPUSH
11940: LD_STRING DFiringRange-Bur-1
11942: PPUSH
11943: CALL_OW 88
// CenterOnXY ( 99 , 30 ) ;
11947: LD_INT 99
11949: PPUSH
11950: LD_INT 30
11952: PPUSH
11953: CALL_OW 84
// Wait ( 0 0$0.5 ) ;
11957: LD_INT 18
11959: PPUSH
11960: CALL_OW 67
// RevealFogArea ( 3 , ShootArea ) ;
11964: LD_INT 3
11966: PPUSH
11967: LD_INT 12
11969: PPUSH
11970: CALL_OW 332
// SetAreaMapShow ( ShootArea , 1 ) ;
11974: LD_INT 12
11976: PPUSH
11977: LD_INT 1
11979: PPUSH
11980: CALL_OW 424
// if IsOK ( Kuzmov ) then
11984: LD_EXP 72
11988: PPUSH
11989: CALL_OW 302
11993: IFFALSE 12009
// Say ( Kuzmov , DFiringRange-Kuz-2 ) else
11995: LD_EXP 72
11999: PPUSH
12000: LD_STRING DFiringRange-Kuz-2
12002: PPUSH
12003: CALL_OW 88
12007: GO 12021
// Say ( Oblukov , DFiringRange-Obl-2 ) ;
12009: LD_EXP 74
12013: PPUSH
12014: LD_STRING DFiringRange-Obl-2
12016: PPUSH
12017: CALL_OW 88
// case Query ( QShootingGallery ) of 1 :
12021: LD_STRING QShootingGallery
12023: PPUSH
12024: CALL_OW 97
12028: PUSH
12029: LD_INT 1
12031: DOUBLE
12032: EQUAL
12033: IFTRUE 12037
12035: GO 12074
12037: POP
// begin Say ( Burlak , DQrShootingGallery#1-Bur-1 ) ;
12038: LD_EXP 57
12042: PPUSH
12043: LD_STRING DQrShootingGallery#1-Bur-1
12045: PPUSH
12046: CALL_OW 88
// BurlakRespect = BurlakRespect + 1 ;
12050: LD_ADDR_EXP 30
12054: PUSH
12055: LD_EXP 30
12059: PUSH
12060: LD_INT 1
12062: PLUS
12063: ST_TO_ADDR
// canShootTrening = true ;
12064: LD_ADDR_EXP 29
12068: PUSH
12069: LD_INT 1
12071: ST_TO_ADDR
// end ; 2 :
12072: GO 12108
12074: LD_INT 2
12076: DOUBLE
12077: EQUAL
12078: IFTRUE 12082
12080: GO 12107
12082: POP
// begin Say ( Burlak , DQrShootingGallery#2-Bur-1 ) ;
12083: LD_EXP 57
12087: PPUSH
12088: LD_STRING DQrShootingGallery#2-Bur-1
12090: PPUSH
12091: CALL_OW 88
// SetAreaMapShow ( ShootArea , 0 ) ;
12095: LD_INT 12
12097: PPUSH
12098: LD_INT 0
12100: PPUSH
12101: CALL_OW 424
// end ; end ;
12105: GO 12108
12107: POP
// DialogueOff ;
12108: CALL_OW 7
// end ;
12112: END
// every 0 0$1 trigger canShootTrening do
12113: LD_EXP 29
12117: IFFALSE 12127
12119: GO 12121
12121: DISABLE
// begin enable ;
12122: ENABLE
// ShootTreningController ;
12123: CALL 7091 0 0
// end ;
12127: END
// every 0 0$1 trigger buildingsToBuild <= 7 do var hunters , hunter ;
12128: LD_EXP 8
12132: PUSH
12133: LD_INT 7
12135: LESSEQUAL
12136: IFFALSE 12526
12138: GO 12140
12140: DISABLE
12141: LD_INT 0
12143: PPUSH
12144: PPUSH
// begin hunters = [ ] ;
12145: LD_ADDR_VAR 0 1
12149: PUSH
12150: EMPTY
12151: ST_TO_ADDR
// if IsOK ( Belkov ) then
12152: LD_EXP 66
12156: PPUSH
12157: CALL_OW 302
12161: IFFALSE 12179
// hunters = hunters ^ Belkov ;
12163: LD_ADDR_VAR 0 1
12167: PUSH
12168: LD_VAR 0 1
12172: PUSH
12173: LD_EXP 66
12177: ADD
12178: ST_TO_ADDR
// if IsOK ( Karamazov ) then
12179: LD_EXP 58
12183: PPUSH
12184: CALL_OW 302
12188: IFFALSE 12206
// hunters = hunters ^ Karamazov ;
12190: LD_ADDR_VAR 0 1
12194: PUSH
12195: LD_VAR 0 1
12199: PUSH
12200: LD_EXP 58
12204: ADD
12205: ST_TO_ADDR
// if IsOK ( Kozlov ) then
12206: LD_EXP 73
12210: PPUSH
12211: CALL_OW 302
12215: IFFALSE 12233
// hunters = hunters ^ Kozlov ;
12217: LD_ADDR_VAR 0 1
12221: PUSH
12222: LD_VAR 0 1
12226: PUSH
12227: LD_EXP 73
12231: ADD
12232: ST_TO_ADDR
// if not hunters then
12233: LD_VAR 0 1
12237: NOT
12238: IFFALSE 12242
// exit ;
12240: GO 12526
// hunter = hunters [ Rand ( 1 , hunters ) ] ;
12242: LD_ADDR_VAR 0 2
12246: PUSH
12247: LD_VAR 0 1
12251: PUSH
12252: LD_INT 1
12254: PPUSH
12255: LD_VAR 0 1
12259: PPUSH
12260: CALL_OW 12
12264: ARRAY
12265: ST_TO_ADDR
// DialogueOn ;
12266: CALL_OW 6
// case hunter of Belkov :
12270: LD_VAR 0 2
12274: PUSH
12275: LD_EXP 66
12279: DOUBLE
12280: EQUAL
12281: IFTRUE 12285
12283: GO 12300
12285: POP
// Say ( Belkov , DHunting-Bel-1 ) ; Karamazov :
12286: LD_EXP 66
12290: PPUSH
12291: LD_STRING DHunting-Bel-1
12293: PPUSH
12294: CALL_OW 88
12298: GO 12351
12300: LD_EXP 58
12304: DOUBLE
12305: EQUAL
12306: IFTRUE 12310
12308: GO 12325
12310: POP
// Say ( Karamazov , DHunting-Kar-1 ) ; Kozlov :
12311: LD_EXP 58
12315: PPUSH
12316: LD_STRING DHunting-Kar-1
12318: PPUSH
12319: CALL_OW 88
12323: GO 12351
12325: LD_EXP 73
12329: DOUBLE
12330: EQUAL
12331: IFTRUE 12335
12333: GO 12350
12335: POP
// Say ( Kozlov , DHunting-Koz-1 ) ; end ;
12336: LD_EXP 73
12340: PPUSH
12341: LD_STRING DHunting-Koz-1
12343: PPUSH
12344: CALL_OW 88
12348: GO 12351
12350: POP
// Say ( Burlak , DHunting-Bur-1 ) ;
12351: LD_EXP 57
12355: PPUSH
12356: LD_STRING DHunting-Bur-1
12358: PPUSH
12359: CALL_OW 88
// case hunter of Belkov :
12363: LD_VAR 0 2
12367: PUSH
12368: LD_EXP 66
12372: DOUBLE
12373: EQUAL
12374: IFTRUE 12378
12376: GO 12393
12378: POP
// Say ( Belkov , DHunting-Bel-2 ) ; Karamazov :
12379: LD_EXP 66
12383: PPUSH
12384: LD_STRING DHunting-Bel-2
12386: PPUSH
12387: CALL_OW 88
12391: GO 12444
12393: LD_EXP 58
12397: DOUBLE
12398: EQUAL
12399: IFTRUE 12403
12401: GO 12418
12403: POP
// Say ( Karamazov , DHunting-Kar-2 ) ; Kozlov :
12404: LD_EXP 58
12408: PPUSH
12409: LD_STRING DHunting-Kar-2
12411: PPUSH
12412: CALL_OW 88
12416: GO 12444
12418: LD_EXP 73
12422: DOUBLE
12423: EQUAL
12424: IFTRUE 12428
12426: GO 12443
12428: POP
// Say ( Kozlov , DHunting-Koz-2 ) ; end ;
12429: LD_EXP 73
12433: PPUSH
12434: LD_STRING DHunting-Koz-2
12436: PPUSH
12437: CALL_OW 88
12441: GO 12444
12443: POP
// DialogueOff ;
12444: CALL_OW 7
// case Query ( QHunting ) of 1 :
12448: LD_STRING QHunting
12450: PPUSH
12451: CALL_OW 97
12455: PUSH
12456: LD_INT 1
12458: DOUBLE
12459: EQUAL
12460: IFTRUE 12464
12462: GO 12502
12464: POP
// begin Say ( Burlak , DQrHunting#1-Bur-1 ) ;
12465: LD_EXP 57
12469: PPUSH
12470: LD_STRING DQrHunting#1-Bur-1
12472: PPUSH
12473: CALL_OW 88
// BurlakRespect = BurlakRespect + 1 ;
12477: LD_ADDR_EXP 30
12481: PUSH
12482: LD_EXP 30
12486: PUSH
12487: LD_INT 1
12489: PLUS
12490: ST_TO_ADDR
// GoToHunt ( hunter ) ;
12491: LD_VAR 0 2
12495: PPUSH
12496: CALL 7719 0 1
// end ; 2 :
12500: GO 12526
12502: LD_INT 2
12504: DOUBLE
12505: EQUAL
12506: IFTRUE 12510
12508: GO 12525
12510: POP
// Say ( Burlak , DQrHunting#2-Bur-1 ) ; end ;
12511: LD_EXP 57
12515: PPUSH
12516: LD_STRING DQrHunting#2-Bur-1
12518: PPUSH
12519: CALL_OW 88
12523: GO 12526
12525: POP
// end ;
12526: PPOPN 2
12528: END
// every 0 0$1 trigger buildingsToBuild <= 3 do var unit , womans , men , woman , man , depots ;
12529: LD_EXP 8
12533: PUSH
12534: LD_INT 3
12536: LESSEQUAL
12537: IFFALSE 13524
12539: GO 12541
12541: DISABLE
12542: LD_INT 0
12544: PPUSH
12545: PPUSH
12546: PPUSH
12547: PPUSH
12548: PPUSH
12549: PPUSH
// begin womans = [ ] ;
12550: LD_ADDR_VAR 0 2
12554: PUSH
12555: EMPTY
12556: ST_TO_ADDR
// men = [ ] ;
12557: LD_ADDR_VAR 0 3
12561: PUSH
12562: EMPTY
12563: ST_TO_ADDR
// if IsOK ( Petrovova ) then
12564: LD_EXP 59
12568: PPUSH
12569: CALL_OW 302
12573: IFFALSE 12591
// womans = womans ^ Petrovova ;
12575: LD_ADDR_VAR 0 2
12579: PUSH
12580: LD_VAR 0 2
12584: PUSH
12585: LD_EXP 59
12589: ADD
12590: ST_TO_ADDR
// if IsOK ( Kirilenkova ) then
12591: LD_EXP 65
12595: PPUSH
12596: CALL_OW 302
12600: IFFALSE 12618
// womans = womans ^ Kirilenkova ;
12602: LD_ADDR_VAR 0 2
12606: PUSH
12607: LD_VAR 0 2
12611: PUSH
12612: LD_EXP 65
12616: ADD
12617: ST_TO_ADDR
// if IsOK ( Kapitsova ) then
12618: LD_EXP 75
12622: PPUSH
12623: CALL_OW 302
12627: IFFALSE 12645
// womans = womans ^ Kapitsova ;
12629: LD_ADDR_VAR 0 2
12633: PUSH
12634: LD_VAR 0 2
12638: PUSH
12639: LD_EXP 75
12643: ADD
12644: ST_TO_ADDR
// DialogueOn ;
12645: CALL_OW 6
// if womans then
12649: LD_VAR 0 2
12653: IFFALSE 12780
// begin case womans [ Rand ( 1 , womans ) ] of Petrovova :
12655: LD_VAR 0 2
12659: PUSH
12660: LD_INT 1
12662: PPUSH
12663: LD_VAR 0 2
12667: PPUSH
12668: CALL_OW 12
12672: ARRAY
12673: PUSH
12674: LD_EXP 59
12678: DOUBLE
12679: EQUAL
12680: IFTRUE 12684
12682: GO 12709
12684: POP
// begin Say ( Petrovova , DFreeTime-Ptr-1 ) ;
12685: LD_EXP 59
12689: PPUSH
12690: LD_STRING DFreeTime-Ptr-1
12692: PPUSH
12693: CALL_OW 88
// woman = Petrovova ;
12697: LD_ADDR_VAR 0 4
12701: PUSH
12702: LD_EXP 59
12706: ST_TO_ADDR
// end ; Kirilenkova :
12707: GO 12780
12709: LD_EXP 65
12713: DOUBLE
12714: EQUAL
12715: IFTRUE 12719
12717: GO 12744
12719: POP
// begin Say ( Kirilenkova , DFreeTime-Kir-1 ) ;
12720: LD_EXP 65
12724: PPUSH
12725: LD_STRING DFreeTime-Kir-1
12727: PPUSH
12728: CALL_OW 88
// woman = Kirilenkova ;
12732: LD_ADDR_VAR 0 4
12736: PUSH
12737: LD_EXP 65
12741: ST_TO_ADDR
// end ; Kapitsova :
12742: GO 12780
12744: LD_EXP 75
12748: DOUBLE
12749: EQUAL
12750: IFTRUE 12754
12752: GO 12779
12754: POP
// begin Say ( Kapitsova , DFreeTime-Kap-1 ) ;
12755: LD_EXP 75
12759: PPUSH
12760: LD_STRING DFreeTime-Kap-1
12762: PPUSH
12763: CALL_OW 88
// woman = Kapitsova ;
12767: LD_ADDR_VAR 0 4
12771: PUSH
12772: LD_EXP 75
12776: ST_TO_ADDR
// end ; end ;
12777: GO 12780
12779: POP
// end ; if IsOK ( Kuzmov ) then
12780: LD_EXP 72
12784: PPUSH
12785: CALL_OW 302
12789: IFFALSE 12807
// men = men ^ Kuzmov ;
12791: LD_ADDR_VAR 0 3
12795: PUSH
12796: LD_VAR 0 3
12800: PUSH
12801: LD_EXP 72
12805: ADD
12806: ST_TO_ADDR
// if IsOK ( Titov ) then
12807: LD_EXP 62
12811: PPUSH
12812: CALL_OW 302
12816: IFFALSE 12834
// men = men ^ Titov ;
12818: LD_ADDR_VAR 0 3
12822: PUSH
12823: LD_VAR 0 3
12827: PUSH
12828: LD_EXP 62
12832: ADD
12833: ST_TO_ADDR
// if IsOK ( Gnyevko ) then
12834: LD_EXP 69
12838: PPUSH
12839: CALL_OW 302
12843: IFFALSE 12861
// men = men ^ Gnyevko ;
12845: LD_ADDR_VAR 0 3
12849: PUSH
12850: LD_VAR 0 3
12854: PUSH
12855: LD_EXP 69
12859: ADD
12860: ST_TO_ADDR
// if IsOK ( Oblukov ) then
12861: LD_EXP 74
12865: PPUSH
12866: CALL_OW 302
12870: IFFALSE 12888
// men = men ^ Oblukov ;
12872: LD_ADDR_VAR 0 3
12876: PUSH
12877: LD_VAR 0 3
12881: PUSH
12882: LD_EXP 74
12886: ADD
12887: ST_TO_ADDR
// if men then
12888: LD_VAR 0 3
12892: IFFALSE 13054
// begin case men [ Rand ( 1 , men ) ] of Kuzmov :
12894: LD_VAR 0 3
12898: PUSH
12899: LD_INT 1
12901: PPUSH
12902: LD_VAR 0 3
12906: PPUSH
12907: CALL_OW 12
12911: ARRAY
12912: PUSH
12913: LD_EXP 72
12917: DOUBLE
12918: EQUAL
12919: IFTRUE 12923
12921: GO 12948
12923: POP
// begin Say ( Kuzmov , DFreeTime-Kuz-1 ) ;
12924: LD_EXP 72
12928: PPUSH
12929: LD_STRING DFreeTime-Kuz-1
12931: PPUSH
12932: CALL_OW 88
// man = Kuzmov ;
12936: LD_ADDR_VAR 0 5
12940: PUSH
12941: LD_EXP 72
12945: ST_TO_ADDR
// end ; Titov :
12946: GO 13054
12948: LD_EXP 62
12952: DOUBLE
12953: EQUAL
12954: IFTRUE 12958
12956: GO 12983
12958: POP
// begin Say ( Titov , DFreeTime-Tit-1 ) ;
12959: LD_EXP 62
12963: PPUSH
12964: LD_STRING DFreeTime-Tit-1
12966: PPUSH
12967: CALL_OW 88
// man = Titov ;
12971: LD_ADDR_VAR 0 5
12975: PUSH
12976: LD_EXP 62
12980: ST_TO_ADDR
// end ; Gnyevko :
12981: GO 13054
12983: LD_EXP 69
12987: DOUBLE
12988: EQUAL
12989: IFTRUE 12993
12991: GO 13018
12993: POP
// begin Say ( Gnyevko , DFreeTime-Gny-1 ) ;
12994: LD_EXP 69
12998: PPUSH
12999: LD_STRING DFreeTime-Gny-1
13001: PPUSH
13002: CALL_OW 88
// man = Gnyevko ;
13006: LD_ADDR_VAR 0 5
13010: PUSH
13011: LD_EXP 69
13015: ST_TO_ADDR
// end ; Oblukov :
13016: GO 13054
13018: LD_EXP 74
13022: DOUBLE
13023: EQUAL
13024: IFTRUE 13028
13026: GO 13053
13028: POP
// begin Say ( Oblukov , DFreeTime-Obl-1 ) ;
13029: LD_EXP 74
13033: PPUSH
13034: LD_STRING DFreeTime-Obl-1
13036: PPUSH
13037: CALL_OW 88
// man = Oblukov ;
13041: LD_ADDR_VAR 0 5
13045: PUSH
13046: LD_EXP 74
13050: ST_TO_ADDR
// end ; end ;
13051: GO 13054
13053: POP
// end ; DialogueOff ;
13054: CALL_OW 7
// if not woman and not man then
13058: LD_VAR 0 4
13062: NOT
13063: PUSH
13064: LD_VAR 0 5
13068: NOT
13069: AND
13070: IFFALSE 13078
// begin DialogueOff ;
13072: CALL_OW 7
// exit ;
13076: GO 13524
// end ; case Query ( QFreeTime ) of 1 :
13078: LD_STRING QFreeTime
13080: PPUSH
13081: CALL_OW 97
13085: PUSH
13086: LD_INT 1
13088: DOUBLE
13089: EQUAL
13090: IFTRUE 13094
13092: GO 13496
13094: POP
// begin Say ( Burlak , DQrFreeTime#1-Bur-1 ) ;
13095: LD_EXP 57
13099: PPUSH
13100: LD_STRING DQrFreeTime#1-Bur-1
13102: PPUSH
13103: CALL_OW 88
// DialogueOff ;
13107: CALL_OW 7
// BurlakRespect = BurlakRespect + 1 ;
13111: LD_ADDR_EXP 30
13115: PUSH
13116: LD_EXP 30
13120: PUSH
13121: LD_INT 1
13123: PLUS
13124: ST_TO_ADDR
// SetSide ( [ woman , man ] , 6 ) ;
13125: LD_VAR 0 4
13129: PUSH
13130: LD_VAR 0 5
13134: PUSH
13135: EMPTY
13136: LIST
13137: LIST
13138: PPUSH
13139: LD_INT 6
13141: PPUSH
13142: CALL_OW 235
// for unit in [ woman , man ] do
13146: LD_ADDR_VAR 0 1
13150: PUSH
13151: LD_VAR 0 4
13155: PUSH
13156: LD_VAR 0 5
13160: PUSH
13161: EMPTY
13162: LIST
13163: LIST
13164: PUSH
13165: FOR_IN
13166: IFFALSE 13221
// if IsInUnit ( unit ) then
13168: LD_VAR 0 1
13172: PPUSH
13173: CALL_OW 310
13177: IFFALSE 13219
// begin if GetType ( IsInUnit ( unit ) ) = unit_vehicle then
13179: LD_VAR 0 1
13183: PPUSH
13184: CALL_OW 310
13188: PPUSH
13189: CALL_OW 247
13193: PUSH
13194: LD_INT 2
13196: EQUAL
13197: IFFALSE 13210
// ComExitVehicle ( unit ) else
13199: LD_VAR 0 1
13203: PPUSH
13204: CALL_OW 121
13208: GO 13219
// ComExitBuilding ( unit ) ;
13210: LD_VAR 0 1
13214: PPUSH
13215: CALL_OW 122
// end ;
13219: GO 13165
13221: POP
13222: POP
// wait ( 0 0$1 ) ;
13223: LD_INT 35
13225: PPUSH
13226: CALL_OW 67
// ComMoveToArea ( [ woman , man ] , ExitMapArea ) ;
13230: LD_VAR 0 4
13234: PUSH
13235: LD_VAR 0 5
13239: PUSH
13240: EMPTY
13241: LIST
13242: LIST
13243: PPUSH
13244: LD_INT 8
13246: PPUSH
13247: CALL_OW 113
// allowExitFromMap = 1 ;
13251: LD_ADDR_EXP 18
13255: PUSH
13256: LD_INT 1
13258: ST_TO_ADDR
// wait ( 3 3$0 ) ;
13259: LD_INT 6300
13261: PPUSH
13262: CALL_OW 67
// PlaceUnitXYR ( woman , 157 , 29 , 3 , false ) ;
13266: LD_VAR 0 4
13270: PPUSH
13271: LD_INT 157
13273: PPUSH
13274: LD_INT 29
13276: PPUSH
13277: LD_INT 3
13279: PPUSH
13280: LD_INT 0
13282: PPUSH
13283: CALL_OW 50
// PlaceUnitXYR ( man , 157 , 29 , 3 , false ) ;
13287: LD_VAR 0 5
13291: PPUSH
13292: LD_INT 157
13294: PPUSH
13295: LD_INT 29
13297: PPUSH
13298: LD_INT 3
13300: PPUSH
13301: LD_INT 0
13303: PPUSH
13304: CALL_OW 50
// SetSide ( [ woman , man ] , 3 ) ;
13308: LD_VAR 0 4
13312: PUSH
13313: LD_VAR 0 5
13317: PUSH
13318: EMPTY
13319: LIST
13320: LIST
13321: PPUSH
13322: LD_INT 3
13324: PPUSH
13325: CALL_OW 235
// depots = FilterAllUnits ( [ [ f_side , 3 ] , [ [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ] ) ;
13329: LD_ADDR_VAR 0 6
13333: PUSH
13334: LD_INT 22
13336: PUSH
13337: LD_INT 3
13339: PUSH
13340: EMPTY
13341: LIST
13342: LIST
13343: PUSH
13344: LD_INT 2
13346: PUSH
13347: LD_INT 30
13349: PUSH
13350: LD_INT 0
13352: PUSH
13353: EMPTY
13354: LIST
13355: LIST
13356: PUSH
13357: LD_INT 30
13359: PUSH
13360: LD_INT 1
13362: PUSH
13363: EMPTY
13364: LIST
13365: LIST
13366: PUSH
13367: EMPTY
13368: LIST
13369: LIST
13370: LIST
13371: PUSH
13372: EMPTY
13373: LIST
13374: PUSH
13375: EMPTY
13376: LIST
13377: LIST
13378: PPUSH
13379: CALL_OW 69
13383: ST_TO_ADDR
// if depots then
13384: LD_VAR 0 6
13388: IFFALSE 13438
// ComMoveXY ( [ woman , man ] , GetX ( depots [ 1 ] ) , GetY ( depots [ 1 ] ) ) else
13390: LD_VAR 0 4
13394: PUSH
13395: LD_VAR 0 5
13399: PUSH
13400: EMPTY
13401: LIST
13402: LIST
13403: PPUSH
13404: LD_VAR 0 6
13408: PUSH
13409: LD_INT 1
13411: ARRAY
13412: PPUSH
13413: CALL_OW 250
13417: PPUSH
13418: LD_VAR 0 6
13422: PUSH
13423: LD_INT 1
13425: ARRAY
13426: PPUSH
13427: CALL_OW 251
13431: PPUSH
13432: CALL_OW 111
13436: GO 13476
// ComMoveXY ( [ woman , man ] , GetX ( Burlak ) , GetY ( Burlak ) ) ;
13438: LD_VAR 0 4
13442: PUSH
13443: LD_VAR 0 5
13447: PUSH
13448: EMPTY
13449: LIST
13450: LIST
13451: PPUSH
13452: LD_EXP 57
13456: PPUSH
13457: CALL_OW 250
13461: PPUSH
13462: LD_EXP 57
13466: PPUSH
13467: CALL_OW 251
13471: PPUSH
13472: CALL_OW 111
// CenterOnUnits ( [ woman , man ] ) ;
13476: LD_VAR 0 4
13480: PUSH
13481: LD_VAR 0 5
13485: PUSH
13486: EMPTY
13487: LIST
13488: LIST
13489: PPUSH
13490: CALL_OW 85
// end ; 2 :
13494: GO 13520
13496: LD_INT 2
13498: DOUBLE
13499: EQUAL
13500: IFTRUE 13504
13502: GO 13519
13504: POP
// Say ( Burlak , DQrFreeTime#2-Bur-1 ) ; end ;
13505: LD_EXP 57
13509: PPUSH
13510: LD_STRING DQrFreeTime#2-Bur-1
13512: PPUSH
13513: CALL_OW 88
13517: GO 13520
13519: POP
// DialogueOff ;
13520: CALL_OW 7
// end ;
13524: PPOPN 6
13526: END
// every 0 0$1 trigger GetAmountWeaponsDataBuildOnVehicle ( false ) <= 2 do
13527: LD_INT 0
13529: PPUSH
13530: CALL 6800 0 1
13534: PUSH
13535: LD_INT 2
13537: LESSEQUAL
13538: IFFALSE 13673
13540: GO 13542
13542: DISABLE
// begin DialogueOn ;
13543: CALL_OW 6
// if IsOK ( Kozlov ) then
13547: LD_EXP 73
13551: PPUSH
13552: CALL_OW 302
13556: IFFALSE 13572
// Say ( Kozlov , DMasha-Koz-1 ) else
13558: LD_EXP 73
13562: PPUSH
13563: LD_STRING DMasha-Koz-1
13565: PPUSH
13566: CALL_OW 88
13570: GO 13635
// DialogRandom ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_ok ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) , DMasha-Koz-1 ,  , false , false ) ;
13572: LD_INT 22
13574: PUSH
13575: LD_INT 3
13577: PUSH
13578: EMPTY
13579: LIST
13580: LIST
13581: PUSH
13582: LD_INT 50
13584: PUSH
13585: EMPTY
13586: LIST
13587: PUSH
13588: LD_INT 21
13590: PUSH
13591: LD_INT 1
13593: PUSH
13594: EMPTY
13595: LIST
13596: LIST
13597: PUSH
13598: LD_INT 26
13600: PUSH
13601: LD_INT 1
13603: PUSH
13604: EMPTY
13605: LIST
13606: LIST
13607: PUSH
13608: EMPTY
13609: LIST
13610: LIST
13611: LIST
13612: LIST
13613: PPUSH
13614: CALL_OW 69
13618: PPUSH
13619: LD_STRING DMasha-Koz-1
13621: PPUSH
13622: LD_STRING 
13624: PPUSH
13625: LD_INT 0
13627: PPUSH
13628: LD_INT 0
13630: PPUSH
13631: CALL 6249 0 5
// Say ( Burlak , DMasha2-Bur-1 ) ;
13635: LD_EXP 57
13639: PPUSH
13640: LD_STRING DMasha2-Bur-1
13642: PPUSH
13643: CALL_OW 88
// DialogueOff ;
13647: CALL_OW 7
// Query ( QMasha ) ;
13651: LD_STRING QMasha
13653: PPUSH
13654: CALL_OW 97
// ChangeMissionObjectives ( MMasha ) ;
13658: LD_STRING MMasha
13660: PPUSH
13661: CALL_OW 337
// canChooseMashaVehicle = true ;
13665: LD_ADDR_EXP 36
13669: PUSH
13670: LD_INT 1
13672: ST_TO_ADDR
// end ;
13673: END
// export function Dial_ComputerTechResearched ; begin
13674: LD_INT 0
13676: PPUSH
// if IsOk ( Scholtze ) or IsOK ( Kapitsova ) then
13677: LD_EXP 71
13681: PPUSH
13682: CALL_OW 302
13686: PUSH
13687: LD_EXP 75
13691: PPUSH
13692: CALL_OW 302
13696: OR
13697: IFFALSE 13793
// begin DialogueOn ;
13699: CALL_OW 6
// if IsOK ( Scholtze ) then
13703: LD_EXP 71
13707: PPUSH
13708: CALL_OW 302
13712: IFFALSE 13728
// Say ( Scholtze , DAI-Sch-1 ) else
13714: LD_EXP 71
13718: PPUSH
13719: LD_STRING DAI-Sch-1
13721: PPUSH
13722: CALL_OW 88
13726: GO 13740
// Say ( Kapitsova , DAI-Kap-1 ) ;
13728: LD_EXP 75
13732: PPUSH
13733: LD_STRING DAI-Kap-1
13735: PPUSH
13736: CALL_OW 88
// Say ( Burlak , DAI-Bur-1 ) ;
13740: LD_EXP 57
13744: PPUSH
13745: LD_STRING DAI-Bur-1
13747: PPUSH
13748: CALL_OW 88
// if IsOK ( Scholtze ) then
13752: LD_EXP 71
13756: PPUSH
13757: CALL_OW 302
13761: IFFALSE 13777
// Say ( Scholtze , DAI-Sch-2 ) else
13763: LD_EXP 71
13767: PPUSH
13768: LD_STRING DAI-Sch-2
13770: PPUSH
13771: CALL_OW 88
13775: GO 13789
// Say ( Kapitsova , DAI-Kap-2 ) ;
13777: LD_EXP 75
13781: PPUSH
13782: LD_STRING DAI-Kap-2
13784: PPUSH
13785: CALL_OW 88
// DialogueOff ;
13789: CALL_OW 7
// end ; ChangeMissionObjectives ( MAI ) ;
13793: LD_STRING MAI
13795: PPUSH
13796: CALL_OW 337
// end ;
13800: LD_VAR 0 1
13804: RET
// export function Dial_TeleportTechResearched ; begin
13805: LD_INT 0
13807: PPUSH
// if IsOk ( Scholtze ) or IsOK ( Kapitsova ) then
13808: LD_EXP 71
13812: PPUSH
13813: CALL_OW 302
13817: PUSH
13818: LD_EXP 75
13822: PPUSH
13823: CALL_OW 302
13827: OR
13828: IFFALSE 13936
// begin DialogueOn ;
13830: CALL_OW 6
// if IsOK ( Scholtze ) then
13834: LD_EXP 71
13838: PPUSH
13839: CALL_OW 302
13843: IFFALSE 13859
// Say ( Scholtze , DSpontTelep-Sch-1 ) else
13845: LD_EXP 71
13849: PPUSH
13850: LD_STRING DSpontTelep-Sch-1
13852: PPUSH
13853: CALL_OW 88
13857: GO 13871
// Say ( Kapitsova , DSpontTelep-Kap-1 ) ;
13859: LD_EXP 75
13863: PPUSH
13864: LD_STRING DSpontTelep-Kap-1
13866: PPUSH
13867: CALL_OW 88
// Say ( Burlak , DSpontTelep-Bur-1 ) ;
13871: LD_EXP 57
13875: PPUSH
13876: LD_STRING DSpontTelep-Bur-1
13878: PPUSH
13879: CALL_OW 88
// if IsOK ( Scholtze ) then
13883: LD_EXP 71
13887: PPUSH
13888: CALL_OW 302
13892: IFFALSE 13908
// Say ( Scholtze , DSpontTelep-Sch-2 ) else
13894: LD_EXP 71
13898: PPUSH
13899: LD_STRING DSpontTelep-Sch-2
13901: PPUSH
13902: CALL_OW 88
13906: GO 13920
// Say ( Kapitsova , DSpontTelep-Kap-2 ) ;
13908: LD_EXP 75
13912: PPUSH
13913: LD_STRING DSpontTelep-Kap-2
13915: PPUSH
13916: CALL_OW 88
// Say ( Burlak , DSpontTelep-Bur-2 ) ;
13920: LD_EXP 57
13924: PPUSH
13925: LD_STRING DSpontTelep-Bur-2
13927: PPUSH
13928: CALL_OW 88
// DialogueOff ;
13932: CALL_OW 7
// end ; ChangeMissionObjectives ( MTele ) ;
13936: LD_STRING MTele
13938: PPUSH
13939: CALL_OW 337
// end ;
13943: LD_VAR 0 1
13947: RET
// every 0 0$1 trigger buildingsToBuild <= 3 and GetAmountWeaponsDataBuildOnVehicle ( false ) <= 1 and techsToResearch <= 4 do
13948: LD_EXP 8
13952: PUSH
13953: LD_INT 3
13955: LESSEQUAL
13956: PUSH
13957: LD_INT 0
13959: PPUSH
13960: CALL 6800 0 1
13964: PUSH
13965: LD_INT 1
13967: LESSEQUAL
13968: AND
13969: PUSH
13970: LD_EXP 9
13974: PUSH
13975: LD_INT 4
13977: LESSEQUAL
13978: AND
13979: IFFALSE 14180
13981: GO 13983
13983: DISABLE
// begin SayRadio ( Popov , DAmAttackStart-Pop-1 ) ;
13984: LD_EXP 76
13988: PPUSH
13989: LD_STRING DAmAttackStart-Pop-1
13991: PPUSH
13992: CALL_OW 94
// if KurtStatus = 1 and HeikeStatus = 1 then
13996: LD_EXP 22
14000: PUSH
14001: LD_INT 1
14003: EQUAL
14004: PUSH
14005: LD_EXP 3
14009: PUSH
14010: LD_INT 1
14012: EQUAL
14013: AND
14014: IFFALSE 14172
// begin wait ( 0 0$10 ) ;
14016: LD_INT 350
14018: PPUSH
14019: CALL_OW 67
// DialogueOn ;
14023: CALL_OW 6
// SayRadio ( Heike , DLegionFormed-Hke-1 ) ;
14027: LD_EXP 79
14031: PPUSH
14032: LD_STRING DLegionFormed-Hke-1
14034: PPUSH
14035: CALL_OW 94
// Say ( Burlak , DLegionFormed-Bur-1 ) ;
14039: LD_EXP 57
14043: PPUSH
14044: LD_STRING DLegionFormed-Bur-1
14046: PPUSH
14047: CALL_OW 88
// SayRadio ( Heike , DLegionFormed-Hke-2 ) ;
14051: LD_EXP 79
14055: PPUSH
14056: LD_STRING DLegionFormed-Hke-2
14058: PPUSH
14059: CALL_OW 94
// Say ( Burlak , DLegionFormed-Bur-2 ) ;
14063: LD_EXP 57
14067: PPUSH
14068: LD_STRING DLegionFormed-Bur-2
14070: PPUSH
14071: CALL_OW 88
// SayRadio ( Heike , DLegionFormed-Hke-3 ) ;
14075: LD_EXP 79
14079: PPUSH
14080: LD_STRING DLegionFormed-Hke-3
14082: PPUSH
14083: CALL_OW 94
// case Query ( QLegion ) of 1 :
14087: LD_STRING QLegion
14089: PPUSH
14090: CALL_OW 97
14094: PUSH
14095: LD_INT 1
14097: DOUBLE
14098: EQUAL
14099: IFTRUE 14103
14101: GO 14134
14103: POP
// begin acceptLegionOffert = true ;
14104: LD_ADDR_EXP 31
14108: PUSH
14109: LD_INT 1
14111: ST_TO_ADDR
// legionOffertCountdown = true ;
14112: LD_ADDR_EXP 33
14116: PUSH
14117: LD_INT 1
14119: ST_TO_ADDR
// Say ( Burlak , DQrLegion#1-Bur-1 ) ;
14120: LD_EXP 57
14124: PPUSH
14125: LD_STRING DQrLegion#1-Bur-1
14127: PPUSH
14128: CALL_OW 88
// end ; 2 :
14132: GO 14166
14134: LD_INT 2
14136: DOUBLE
14137: EQUAL
14138: IFTRUE 14142
14140: GO 14165
14142: POP
// begin Say ( Burlak , DQrLegion#2-Bur-1 ) ;
14143: LD_EXP 57
14147: PPUSH
14148: LD_STRING DQrLegion#2-Bur-1
14150: PPUSH
14151: CALL_OW 88
// americansAttack = true ;
14155: LD_ADDR_EXP 26
14159: PUSH
14160: LD_INT 1
14162: ST_TO_ADDR
// end ; end ;
14163: GO 14166
14165: POP
// DialogueOff ;
14166: CALL_OW 7
// end else
14170: GO 14180
// begin americansAttack = true ;
14172: LD_ADDR_EXP 26
14176: PUSH
14177: LD_INT 1
14179: ST_TO_ADDR
// end ; end ;
14180: END
// every 0 0$1 trigger legionOffertTime <= 0 0$00 do
14181: LD_EXP 34
14185: PUSH
14186: LD_INT 0
14188: LESSEQUAL
14189: IFFALSE 14210
14191: GO 14193
14193: DISABLE
// begin legionOffertCountdown = false ;
14194: LD_ADDR_EXP 33
14198: PUSH
14199: LD_INT 0
14201: ST_TO_ADDR
// americansAttack = true ;
14202: LD_ADDR_EXP 26
14206: PUSH
14207: LD_INT 1
14209: ST_TO_ADDR
// end ;
14210: END
// every 0 0$1 trigger legionOffertCountdown do var needCrates , depots , depot , crates ;
14211: LD_EXP 33
14215: IFFALSE 14401
14217: GO 14219
14219: DISABLE
14220: LD_INT 0
14222: PPUSH
14223: PPUSH
14224: PPUSH
14225: PPUSH
// begin needCrates = 50 ;
14226: LD_ADDR_VAR 0 1
14230: PUSH
14231: LD_INT 50
14233: ST_TO_ADDR
// crates = 0 ;
14234: LD_ADDR_VAR 0 4
14238: PUSH
14239: LD_INT 0
14241: ST_TO_ADDR
// depots = FilterAllUnits ( [ [ f_side , 3 ] , [ [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ] ) ;
14242: LD_ADDR_VAR 0 2
14246: PUSH
14247: LD_INT 22
14249: PUSH
14250: LD_INT 3
14252: PUSH
14253: EMPTY
14254: LIST
14255: LIST
14256: PUSH
14257: LD_INT 2
14259: PUSH
14260: LD_INT 30
14262: PUSH
14263: LD_INT 0
14265: PUSH
14266: EMPTY
14267: LIST
14268: LIST
14269: PUSH
14270: LD_INT 30
14272: PUSH
14273: LD_INT 1
14275: PUSH
14276: EMPTY
14277: LIST
14278: LIST
14279: PUSH
14280: EMPTY
14281: LIST
14282: LIST
14283: LIST
14284: PUSH
14285: EMPTY
14286: LIST
14287: PUSH
14288: EMPTY
14289: LIST
14290: LIST
14291: PPUSH
14292: CALL_OW 69
14296: ST_TO_ADDR
// for depot in depots do
14297: LD_ADDR_VAR 0 3
14301: PUSH
14302: LD_VAR 0 2
14306: PUSH
14307: FOR_IN
14308: IFFALSE 14399
// begin crates = GetResourceType ( GetBase ( depot ) , mat_cans ) ;
14310: LD_ADDR_VAR 0 4
14314: PUSH
14315: LD_VAR 0 3
14319: PPUSH
14320: CALL_OW 274
14324: PPUSH
14325: LD_INT 1
14327: PPUSH
14328: CALL_OW 275
14332: ST_TO_ADDR
// if crates >= needCrates then
14333: LD_VAR 0 4
14337: PUSH
14338: LD_VAR 0 1
14342: GREATEREQUAL
14343: IFFALSE 14397
// begin SetResourceType ( GetBase ( depot ) , mat_cans , crates - needCrates ) ;
14345: LD_VAR 0 3
14349: PPUSH
14350: CALL_OW 274
14354: PPUSH
14355: LD_INT 1
14357: PPUSH
14358: LD_VAR 0 4
14362: PUSH
14363: LD_VAR 0 1
14367: MINUS
14368: PPUSH
14369: CALL_OW 277
// legionOffertCountdown = false ;
14373: LD_ADDR_EXP 33
14377: PUSH
14378: LD_INT 0
14380: ST_TO_ADDR
// paidLegionOffert = true ;
14381: LD_ADDR_EXP 32
14385: PUSH
14386: LD_INT 1
14388: ST_TO_ADDR
// americansAttack = true ;
14389: LD_ADDR_EXP 26
14393: PUSH
14394: LD_INT 1
14396: ST_TO_ADDR
// end ; end ;
14397: GO 14307
14399: POP
14400: POP
// end ;
14401: PPOPN 4
14403: END
// every 0 0$1 trigger currentAmWave >= americansAttackWaves and FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_type , unit_human ] , [ f_and , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ] ] ) = 0 do
14404: LD_EXP 85
14408: PUSH
14409: LD_EXP 48
14413: GREATEREQUAL
14414: PUSH
14415: LD_INT 22
14417: PUSH
14418: LD_INT 1
14420: PUSH
14421: EMPTY
14422: LIST
14423: LIST
14424: PUSH
14425: LD_INT 2
14427: PUSH
14428: LD_INT 21
14430: PUSH
14431: LD_INT 1
14433: PUSH
14434: EMPTY
14435: LIST
14436: LIST
14437: PUSH
14438: LD_INT 1
14440: PUSH
14441: LD_INT 21
14443: PUSH
14444: LD_INT 2
14446: PUSH
14447: EMPTY
14448: LIST
14449: LIST
14450: PUSH
14451: LD_INT 33
14453: PUSH
14454: LD_INT 3
14456: PUSH
14457: EMPTY
14458: LIST
14459: LIST
14460: PUSH
14461: EMPTY
14462: LIST
14463: LIST
14464: LIST
14465: PUSH
14466: EMPTY
14467: LIST
14468: LIST
14469: LIST
14470: PUSH
14471: EMPTY
14472: LIST
14473: LIST
14474: PPUSH
14475: CALL_OW 69
14479: PUSH
14480: LD_INT 0
14482: EQUAL
14483: AND
14484: IFFALSE 14684
14486: GO 14488
14488: DISABLE
// begin DialogueOn ;
14489: CALL_OW 6
// if IsOK ( Belkov ) then
14493: LD_EXP 66
14497: PPUSH
14498: CALL_OW 302
14502: IFFALSE 14518
// Say ( Belkov , DAmAttackFin-Bel-1 ) else
14504: LD_EXP 66
14508: PPUSH
14509: LD_STRING DAmAttackFin-Bel-1
14511: PPUSH
14512: CALL_OW 88
14516: GO 14541
// if IsOK ( Belkov2 ) then
14518: LD_EXP 67
14522: PPUSH
14523: CALL_OW 302
14527: IFFALSE 14541
// Say ( Belkov2 , DAmAttackFin-Bel-1 ) ;
14529: LD_EXP 67
14533: PPUSH
14534: LD_STRING DAmAttackFin-Bel-1
14536: PPUSH
14537: CALL_OW 88
// if IsOK ( Gnyevko ) then
14541: LD_EXP 69
14545: PPUSH
14546: CALL_OW 302
14550: IFFALSE 14564
// Say ( Gnyevko , DAmAttackFin-Gny-1 ) ;
14552: LD_EXP 69
14556: PPUSH
14557: LD_STRING DAmAttackFin-Gny-1
14559: PPUSH
14560: CALL_OW 88
// if IsOK ( Titov ) then
14564: LD_EXP 62
14568: PPUSH
14569: CALL_OW 302
14573: IFFALSE 14587
// Say ( Titov , DAmAttackFin-Tit-1 ) ;
14575: LD_EXP 62
14579: PPUSH
14580: LD_STRING DAmAttackFin-Tit-1
14582: PPUSH
14583: CALL_OW 88
// if IsOK ( Lipshchin ) then
14587: LD_EXP 64
14591: PPUSH
14592: CALL_OW 302
14596: IFFALSE 14610
// Say ( Lipshchin , DAmAttackFin-Lip-1 ) ;
14598: LD_EXP 64
14602: PPUSH
14603: LD_STRING DAmAttackFin-Lip-1
14605: PPUSH
14606: CALL_OW 88
// if IsOK ( Karamazov ) then
14610: LD_EXP 58
14614: PPUSH
14615: CALL_OW 302
14619: IFFALSE 14633
// Say ( Karamazov , DAmAttackFin-Kar-1 ) ;
14621: LD_EXP 58
14625: PPUSH
14626: LD_STRING DAmAttackFin-Kar-1
14628: PPUSH
14629: CALL_OW 88
// if IsOK ( Oblukov ) then
14633: LD_EXP 74
14637: PPUSH
14638: CALL_OW 302
14642: IFFALSE 14656
// Say ( Oblukov , DAmAttackFin-Obl-1 ) ;
14644: LD_EXP 74
14648: PPUSH
14649: LD_STRING DAmAttackFin-Obl-1
14651: PPUSH
14652: CALL_OW 88
// Say ( Burlak , AmAttackFin-Bur-1 ) ;
14656: LD_EXP 57
14660: PPUSH
14661: LD_STRING AmAttackFin-Bur-1
14663: PPUSH
14664: CALL_OW 88
// SayRadio ( Popov , DAmAttackFin-Pop-1 ) ;
14668: LD_EXP 76
14672: PPUSH
14673: LD_STRING DAmAttackFin-Pop-1
14675: PPUSH
14676: CALL_OW 94
// DialogueOff ;
14680: CALL_OW 7
// end ;
14684: END
// every 0 0$1 trigger buildingsToBuild + ( 3 - GetAmountWeaponsDataBuildOnTurret ( true ) ) = 0 do
14685: LD_EXP 8
14689: PUSH
14690: LD_INT 3
14692: PUSH
14693: LD_INT 1
14695: PPUSH
14696: CALL 6690 0 1
14700: MINUS
14701: PLUS
14702: PUSH
14703: LD_INT 0
14705: EQUAL
14706: IFFALSE 14718
14708: GO 14710
14710: DISABLE
// ChangeMissionObjectives ( MBuildingsDone ) ;
14711: LD_STRING MBuildingsDone
14713: PPUSH
14714: CALL_OW 337
14718: END
// every 0 0$1 trigger GetAmountWeaponsDataBuildOnVehicle ( false ) = 0 do
14719: LD_INT 0
14721: PPUSH
14722: CALL 6800 0 1
14726: PUSH
14727: LD_INT 0
14729: EQUAL
14730: IFFALSE 14742
14732: GO 14734
14734: DISABLE
// ChangeMissionObjectives ( MWeaponsDone ) ;
14735: LD_STRING MWeaponsDone
14737: PPUSH
14738: CALL_OW 337
14742: END
// every 0 0$1 trigger techsToResearch = 0 do
14743: LD_EXP 9
14747: PUSH
14748: LD_INT 0
14750: EQUAL
14751: IFFALSE 14763
14753: GO 14755
14755: DISABLE
// ChangeMissionObjectives ( MTechnoDone ) ;
14756: LD_STRING MTechnoDone
14758: PPUSH
14759: CALL_OW 337
14763: END
// every 0 0$1 trigger americansAttack and not FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_type , unit_human ] , [ f_and , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ] ] ) do
14764: LD_EXP 26
14768: PUSH
14769: LD_INT 22
14771: PUSH
14772: LD_INT 1
14774: PUSH
14775: EMPTY
14776: LIST
14777: LIST
14778: PUSH
14779: LD_INT 2
14781: PUSH
14782: LD_INT 21
14784: PUSH
14785: LD_INT 1
14787: PUSH
14788: EMPTY
14789: LIST
14790: LIST
14791: PUSH
14792: LD_INT 1
14794: PUSH
14795: LD_INT 21
14797: PUSH
14798: LD_INT 2
14800: PUSH
14801: EMPTY
14802: LIST
14803: LIST
14804: PUSH
14805: LD_INT 33
14807: PUSH
14808: LD_INT 3
14810: PUSH
14811: EMPTY
14812: LIST
14813: LIST
14814: PUSH
14815: EMPTY
14816: LIST
14817: LIST
14818: LIST
14819: PUSH
14820: EMPTY
14821: LIST
14822: LIST
14823: LIST
14824: PUSH
14825: EMPTY
14826: LIST
14827: LIST
14828: PPUSH
14829: CALL_OW 69
14833: NOT
14834: AND
14835: IFFALSE 14847
14837: GO 14839
14839: DISABLE
// ChangeMissionObjectives ( MEnemyDone ) ;
14840: LD_STRING MEnemyDone
14842: PPUSH
14843: CALL_OW 337
14847: END
// every 0 0$1 trigger ( buildingsToBuild + ( 3 - GetAmountWeaponsDataBuildOnTurret ( true ) ) ) = 0 and GetAmountWeaponsDataBuildOnVehicle ( false ) = 0 and techsToResearch = 0 and FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_type , unit_human ] , [ f_and , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ] ] ) = 0 and Masha and IsOK ( Masha [ 1 ] ) and buildCompVehicle and testedTeleport do
14848: LD_EXP 8
14852: PUSH
14853: LD_INT 3
14855: PUSH
14856: LD_INT 1
14858: PPUSH
14859: CALL 6690 0 1
14863: MINUS
14864: PLUS
14865: PUSH
14866: LD_INT 0
14868: EQUAL
14869: PUSH
14870: LD_INT 0
14872: PPUSH
14873: CALL 6800 0 1
14877: PUSH
14878: LD_INT 0
14880: EQUAL
14881: AND
14882: PUSH
14883: LD_EXP 9
14887: PUSH
14888: LD_INT 0
14890: EQUAL
14891: AND
14892: PUSH
14893: LD_INT 22
14895: PUSH
14896: LD_INT 8
14898: PUSH
14899: EMPTY
14900: LIST
14901: LIST
14902: PUSH
14903: LD_INT 21
14905: PUSH
14906: LD_INT 1
14908: PUSH
14909: EMPTY
14910: LIST
14911: LIST
14912: PUSH
14913: EMPTY
14914: LIST
14915: LIST
14916: PPUSH
14917: CALL_OW 69
14921: PUSH
14922: LD_INT 0
14924: EQUAL
14925: AND
14926: PUSH
14927: LD_INT 22
14929: PUSH
14930: LD_INT 1
14932: PUSH
14933: EMPTY
14934: LIST
14935: LIST
14936: PUSH
14937: LD_INT 2
14939: PUSH
14940: LD_INT 21
14942: PUSH
14943: LD_INT 1
14945: PUSH
14946: EMPTY
14947: LIST
14948: LIST
14949: PUSH
14950: LD_INT 1
14952: PUSH
14953: LD_INT 21
14955: PUSH
14956: LD_INT 2
14958: PUSH
14959: EMPTY
14960: LIST
14961: LIST
14962: PUSH
14963: LD_INT 33
14965: PUSH
14966: LD_INT 3
14968: PUSH
14969: EMPTY
14970: LIST
14971: LIST
14972: PUSH
14973: EMPTY
14974: LIST
14975: LIST
14976: LIST
14977: PUSH
14978: EMPTY
14979: LIST
14980: LIST
14981: LIST
14982: PUSH
14983: EMPTY
14984: LIST
14985: LIST
14986: PPUSH
14987: CALL_OW 69
14991: PUSH
14992: LD_INT 0
14994: EQUAL
14995: AND
14996: PUSH
14997: LD_EXP 4
15001: AND
15002: PUSH
15003: LD_EXP 4
15007: PUSH
15008: LD_INT 1
15010: ARRAY
15011: PPUSH
15012: CALL_OW 302
15016: AND
15017: PUSH
15018: LD_EXP 37
15022: AND
15023: PUSH
15024: LD_EXP 39
15028: AND
15029: IFFALSE 15038
15031: GO 15033
15033: DISABLE
// begin FinishMission ;
15034: CALL 15243 0 0
// end ;
15038: END
// every 0 0$1 do var unit ;
15039: GO 15041
15041: DISABLE
15042: LD_INT 0
15044: PPUSH
// begin case allowExitFromMap of 1 :
15045: LD_EXP 18
15049: PUSH
15050: LD_INT 1
15052: DOUBLE
15053: EQUAL
15054: IFTRUE 15058
15056: GO 15086
15058: POP
// RemoveUnits ( FilterUnitsInArea ( ExitMapArea , [ [ f_side , 6 ] ] ) ) ; 3 :
15059: LD_INT 8
15061: PPUSH
15062: LD_INT 22
15064: PUSH
15065: LD_INT 6
15067: PUSH
15068: EMPTY
15069: LIST
15070: LIST
15071: PUSH
15072: EMPTY
15073: LIST
15074: PPUSH
15075: CALL_OW 70
15079: PPUSH
15080: CALL 6526 0 1
15084: GO 15209
15086: LD_INT 3
15088: DOUBLE
15089: EQUAL
15090: IFTRUE 15094
15092: GO 15122
15094: POP
// RemoveUnits ( FilterUnitsInArea ( KurtExitMapArea , [ [ f_side , 8 ] ] ) ) ; 4 :
15095: LD_INT 11
15097: PPUSH
15098: LD_INT 22
15100: PUSH
15101: LD_INT 8
15103: PUSH
15104: EMPTY
15105: LIST
15106: LIST
15107: PUSH
15108: EMPTY
15109: LIST
15110: PPUSH
15111: CALL_OW 70
15115: PPUSH
15116: CALL 6526 0 1
15120: GO 15209
15122: LD_INT 4
15124: DOUBLE
15125: EQUAL
15126: IFTRUE 15130
15128: GO 15208
15130: POP
// begin RemoveUnits ( FilterUnitsInArea ( ExitMapArea , [ [ f_side , 8 ] ] ) ) ;
15131: LD_INT 8
15133: PPUSH
15134: LD_INT 22
15136: PUSH
15137: LD_INT 8
15139: PUSH
15140: EMPTY
15141: LIST
15142: LIST
15143: PUSH
15144: EMPTY
15145: LIST
15146: PPUSH
15147: CALL_OW 70
15151: PPUSH
15152: CALL 6526 0 1
// RemoveUnits ( FilterUnitsInArea ( KurtExitMapArea , [ [ f_side , 8 ] ] ) ) ;
15156: LD_INT 11
15158: PPUSH
15159: LD_INT 22
15161: PUSH
15162: LD_INT 8
15164: PUSH
15165: EMPTY
15166: LIST
15167: LIST
15168: PUSH
15169: EMPTY
15170: LIST
15171: PPUSH
15172: CALL_OW 70
15176: PPUSH
15177: CALL 6526 0 1
// RemoveUnits ( FilterUnitsInArea ( ExitMapArea , [ [ f_side , 2 ] ] ) ) ;
15181: LD_INT 8
15183: PPUSH
15184: LD_INT 22
15186: PUSH
15187: LD_INT 2
15189: PUSH
15190: EMPTY
15191: LIST
15192: LIST
15193: PUSH
15194: EMPTY
15195: LIST
15196: PPUSH
15197: CALL_OW 70
15201: PPUSH
15202: CALL 6526 0 1
// end ; end ;
15206: GO 15209
15208: POP
// enable ;
15209: ENABLE
// end ; end_of_file
15210: PPOPN 1
15212: END
// export function Lose_Burlak ; begin
15213: LD_INT 0
15215: PPUSH
// YouLost ( Burlak ) ;
15216: LD_STRING Burlak
15218: PPUSH
15219: CALL_OW 104
// end ;
15223: LD_VAR 0 1
15227: RET
// export function Lost_AttackAlly ; begin
15228: LD_INT 0
15230: PPUSH
// YouLost ( SelfAttack ) ;
15231: LD_STRING SelfAttack
15233: PPUSH
15234: CALL_OW 104
// end ; end_of_file
15238: LD_VAR 0 1
15242: RET
// export function FinishMission ; begin
15243: LD_INT 0
15245: PPUSH
// SetRewards ;
15246: CALL 15267 0 0
// SavePlayerCharacters ;
15250: CALL 15528 0 0
// SaveGlobalVariables ;
15254: CALL 16078 0 0
// YouWin ;
15258: CALL_OW 103
// end ;
15262: LD_VAR 0 1
15266: RET
// function SetRewards ; begin
15267: LD_INT 0
15269: PPUSH
// AddMedal ( ArtisticImpression , 1 ) ;
15270: LD_STRING ArtisticImpression
15272: PPUSH
15273: LD_INT 1
15275: PPUSH
15276: CALL_OW 101
// if not HeikeCaptured then
15280: LD_EXP 1
15284: NOT
15285: IFFALSE 15319
// begin if speedMedalTime >= 0 0$00 then
15287: LD_EXP 52
15291: PUSH
15292: LD_INT 0
15294: GREATEREQUAL
15295: IFFALSE 15309
// AddMedal ( Speed , 1 ) else
15297: LD_STRING Speed
15299: PPUSH
15300: LD_INT 1
15302: PPUSH
15303: CALL_OW 101
15307: GO 15319
// AddMedal ( Speed , 1 ) ;
15309: LD_STRING Speed
15311: PPUSH
15312: LD_INT 1
15314: PPUSH
15315: CALL_OW 101
// end ; if lostUnits then
15319: LD_EXP 40
15323: IFFALSE 15338
// begin AddMedal ( FavouriteCommander , - 1 ) ;
15325: LD_STRING FavouriteCommander
15327: PPUSH
15328: LD_INT 1
15330: NEG
15331: PPUSH
15332: CALL_OW 101
// end else
15336: GO 15430
// begin case BurlakRespect of 0 :
15338: LD_EXP 30
15342: PUSH
15343: LD_INT 0
15345: DOUBLE
15346: EQUAL
15347: IFTRUE 15351
15349: GO 15365
15351: POP
// AddMedal ( FavouriteCommander , - 2 ) ; 1 :
15352: LD_STRING FavouriteCommander
15354: PPUSH
15355: LD_INT 2
15357: NEG
15358: PPUSH
15359: CALL_OW 101
15363: GO 15430
15365: LD_INT 1
15367: DOUBLE
15368: EQUAL
15369: IFTRUE 15373
15371: GO 15387
15373: POP
// AddMedal ( FavouriteCommander , - 3 ) ; 2 :
15374: LD_STRING FavouriteCommander
15376: PPUSH
15377: LD_INT 3
15379: NEG
15380: PPUSH
15381: CALL_OW 101
15385: GO 15430
15387: LD_INT 2
15389: DOUBLE
15390: EQUAL
15391: IFTRUE 15395
15393: GO 15408
15395: POP
// AddMedal ( FavouriteCommander , 1 ) ; 3 :
15396: LD_STRING FavouriteCommander
15398: PPUSH
15399: LD_INT 1
15401: PPUSH
15402: CALL_OW 101
15406: GO 15430
15408: LD_INT 3
15410: DOUBLE
15411: EQUAL
15412: IFTRUE 15416
15414: GO 15429
15416: POP
// AddMedal ( FavouriteCommander , 1 ) ; end ;
15417: LD_STRING FavouriteCommander
15419: PPUSH
15420: LD_INT 1
15422: PPUSH
15423: CALL_OW 101
15427: GO 15430
15429: POP
// end ; if HeikeCaptured then
15430: LD_EXP 1
15434: IFFALSE 15465
// begin if buildArabBarrack then
15436: LD_EXP 38
15440: IFFALSE 15454
// AddMedal ( ArabBarracks , 1 ) else
15442: LD_STRING ArabBarracks
15444: PPUSH
15445: LD_INT 1
15447: PPUSH
15448: CALL_OW 101
15452: GO 15465
// AddMedal ( ArabBarracks , - 1 ) ;
15454: LD_STRING ArabBarracks
15456: PPUSH
15457: LD_INT 1
15459: NEG
15460: PPUSH
15461: CALL_OW 101
// end ; GiveMedals ( Main1 ) ;
15465: LD_STRING Main1
15467: PPUSH
15468: CALL_OW 102
// RewardPeople ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_nation , nation_russian ] , [ f_ok ] ] ) ) ;
15472: LD_INT 22
15474: PUSH
15475: LD_INT 3
15477: PUSH
15478: EMPTY
15479: LIST
15480: LIST
15481: PUSH
15482: LD_INT 21
15484: PUSH
15485: LD_INT 1
15487: PUSH
15488: EMPTY
15489: LIST
15490: LIST
15491: PUSH
15492: LD_INT 23
15494: PUSH
15495: LD_INT 3
15497: PUSH
15498: EMPTY
15499: LIST
15500: LIST
15501: PUSH
15502: LD_INT 50
15504: PUSH
15505: EMPTY
15506: LIST
15507: PUSH
15508: EMPTY
15509: LIST
15510: LIST
15511: LIST
15512: LIST
15513: PPUSH
15514: CALL_OW 69
15518: PPUSH
15519: CALL_OW 43
// end ;
15523: LD_VAR 0 1
15527: RET
// function SavePlayerCharacters ; var randomsToSave ; begin
15528: LD_INT 0
15530: PPUSH
15531: PPUSH
// ExtSaveCharacter ( Burlak , Burlak , 3 ) ;
15532: LD_EXP 57
15536: PPUSH
15537: LD_STRING Burlak
15539: PPUSH
15540: LD_INT 3
15542: PPUSH
15543: CALL 6048 0 3
// ExtSaveCharacter ( Karamazov , Karamazov , 3 ) ;
15547: LD_EXP 58
15551: PPUSH
15552: LD_STRING Karamazov
15554: PPUSH
15555: LD_INT 3
15557: PPUSH
15558: CALL 6048 0 3
// ExtSaveCharacter ( Petrovova , Petrovova , 3 ) ;
15562: LD_EXP 59
15566: PPUSH
15567: LD_STRING Petrovova
15569: PPUSH
15570: LD_INT 3
15572: PPUSH
15573: CALL 6048 0 3
// ExtSaveCharacter ( Gleb , Gleb , 3 ) ;
15577: LD_EXP 60
15581: PPUSH
15582: LD_STRING Gleb
15584: PPUSH
15585: LD_INT 3
15587: PPUSH
15588: CALL 6048 0 3
// ExtSaveCharacter ( Petrosyan , Petrosyan , 3 ) ;
15592: LD_EXP 61
15596: PPUSH
15597: LD_STRING Petrosyan
15599: PPUSH
15600: LD_INT 3
15602: PPUSH
15603: CALL 6048 0 3
// ExtSaveCharacter ( Dolgov , Dolgov , 3 ) ;
15607: LD_EXP 63
15611: PPUSH
15612: LD_STRING Dolgov
15614: PPUSH
15615: LD_INT 3
15617: PPUSH
15618: CALL 6048 0 3
// ExtSaveCharacter ( Lipshchin , Lipshchin , 3 ) ;
15622: LD_EXP 64
15626: PPUSH
15627: LD_STRING Lipshchin
15629: PPUSH
15630: LD_INT 3
15632: PPUSH
15633: CALL 6048 0 3
// ExtSaveCharacter ( Titov , Titov , 3 ) ;
15637: LD_EXP 62
15641: PPUSH
15642: LD_STRING Titov
15644: PPUSH
15645: LD_INT 3
15647: PPUSH
15648: CALL 6048 0 3
// ExtSaveCharacter ( Kirilenkova , Kirilenkova , 3 ) ;
15652: LD_EXP 65
15656: PPUSH
15657: LD_STRING Kirilenkova
15659: PPUSH
15660: LD_INT 3
15662: PPUSH
15663: CALL 6048 0 3
// ExtSaveCharacter ( Belkov , Belkov , 3 ) ;
15667: LD_EXP 66
15671: PPUSH
15672: LD_STRING Belkov
15674: PPUSH
15675: LD_INT 3
15677: PPUSH
15678: CALL 6048 0 3
// ExtSaveCharacter ( Belkov2 , Belkov2 , 3 ) ;
15682: LD_EXP 67
15686: PPUSH
15687: LD_STRING Belkov2
15689: PPUSH
15690: LD_INT 3
15692: PPUSH
15693: CALL 6048 0 3
// ExtSaveCharacter ( Xavier , Xavier , 3 ) ;
15697: LD_EXP 68
15701: PPUSH
15702: LD_STRING Xavier
15704: PPUSH
15705: LD_INT 3
15707: PPUSH
15708: CALL 6048 0 3
// ExtSaveCharacter ( Kozlov , Kozlov , 3 ) ;
15712: LD_EXP 73
15716: PPUSH
15717: LD_STRING Kozlov
15719: PPUSH
15720: LD_INT 3
15722: PPUSH
15723: CALL 6048 0 3
// ExtSaveCharacter ( Oblukov , Oblukov , 3 ) ;
15727: LD_EXP 74
15731: PPUSH
15732: LD_STRING Oblukov
15734: PPUSH
15735: LD_INT 3
15737: PPUSH
15738: CALL 6048 0 3
// ExtSaveCharacter ( Kapitsova , Kapitsova , 3 ) ;
15742: LD_EXP 75
15746: PPUSH
15747: LD_STRING Kapitsova
15749: PPUSH
15750: LD_INT 3
15752: PPUSH
15753: CALL 6048 0 3
// ExtSaveCharacter ( Gnyevko , Gnyevko , 3 ) ;
15757: LD_EXP 69
15761: PPUSH
15762: LD_STRING Gnyevko
15764: PPUSH
15765: LD_INT 3
15767: PPUSH
15768: CALL 6048 0 3
// ExtSaveCharacter ( Kovalyuk , Kovalyuk , 3 ) ;
15772: LD_EXP 70
15776: PPUSH
15777: LD_STRING Kovalyuk
15779: PPUSH
15780: LD_INT 3
15782: PPUSH
15783: CALL 6048 0 3
// ExtSaveCharacter ( Scholtze , Scholtze , 3 ) ;
15787: LD_EXP 71
15791: PPUSH
15792: LD_STRING Scholtze
15794: PPUSH
15795: LD_INT 3
15797: PPUSH
15798: CALL 6048 0 3
// ExtSaveCharacter ( Kuzmov , Kuzmov , 3 ) ;
15802: LD_EXP 72
15806: PPUSH
15807: LD_STRING Kuzmov
15809: PPUSH
15810: LD_INT 3
15812: PPUSH
15813: CALL 6048 0 3
// ExtSaveCharacters ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_or , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman_soldier ] ] ] ) , other_apemans , 3 ) ;
15817: LD_INT 22
15819: PUSH
15820: LD_INT 3
15822: PUSH
15823: EMPTY
15824: LIST
15825: LIST
15826: PUSH
15827: LD_INT 21
15829: PUSH
15830: LD_INT 1
15832: PUSH
15833: EMPTY
15834: LIST
15835: LIST
15836: PUSH
15837: LD_INT 2
15839: PUSH
15840: LD_INT 25
15842: PUSH
15843: LD_INT 12
15845: PUSH
15846: EMPTY
15847: LIST
15848: LIST
15849: PUSH
15850: LD_INT 25
15852: PUSH
15853: LD_INT 16
15855: PUSH
15856: EMPTY
15857: LIST
15858: LIST
15859: PUSH
15860: LD_INT 25
15862: PUSH
15863: LD_INT 15
15865: PUSH
15866: EMPTY
15867: LIST
15868: LIST
15869: PUSH
15870: EMPTY
15871: LIST
15872: LIST
15873: LIST
15874: LIST
15875: PUSH
15876: EMPTY
15877: LIST
15878: LIST
15879: LIST
15880: PPUSH
15881: CALL_OW 69
15885: PPUSH
15886: LD_STRING other_apemans
15888: PPUSH
15889: LD_INT 3
15891: PPUSH
15892: CALL 6105 0 3
// randomsToSave = FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_nation , nation_russian ] ] ) diff [ Burlak , Karamazov , Petrovova , Gleb , Petrosyan , Titov , Dolgov , Lipshchin , Kirilenkova , Belkov , Belkov2 , Xavier , Gnyevko , Kovalyuk , Scholtze , Kuzmov , Kozlov , Oblukov , Kapitsova ] ;
15896: LD_ADDR_VAR 0 2
15900: PUSH
15901: LD_INT 22
15903: PUSH
15904: LD_INT 3
15906: PUSH
15907: EMPTY
15908: LIST
15909: LIST
15910: PUSH
15911: LD_INT 21
15913: PUSH
15914: LD_INT 1
15916: PUSH
15917: EMPTY
15918: LIST
15919: LIST
15920: PUSH
15921: LD_INT 23
15923: PUSH
15924: LD_INT 3
15926: PUSH
15927: EMPTY
15928: LIST
15929: LIST
15930: PUSH
15931: EMPTY
15932: LIST
15933: LIST
15934: LIST
15935: PPUSH
15936: CALL_OW 69
15940: PUSH
15941: LD_EXP 57
15945: PUSH
15946: LD_EXP 58
15950: PUSH
15951: LD_EXP 59
15955: PUSH
15956: LD_EXP 60
15960: PUSH
15961: LD_EXP 61
15965: PUSH
15966: LD_EXP 62
15970: PUSH
15971: LD_EXP 63
15975: PUSH
15976: LD_EXP 64
15980: PUSH
15981: LD_EXP 65
15985: PUSH
15986: LD_EXP 66
15990: PUSH
15991: LD_EXP 67
15995: PUSH
15996: LD_EXP 68
16000: PUSH
16001: LD_EXP 69
16005: PUSH
16006: LD_EXP 70
16010: PUSH
16011: LD_EXP 71
16015: PUSH
16016: LD_EXP 72
16020: PUSH
16021: LD_EXP 73
16025: PUSH
16026: LD_EXP 74
16030: PUSH
16031: LD_EXP 75
16035: PUSH
16036: EMPTY
16037: LIST
16038: LIST
16039: LIST
16040: LIST
16041: LIST
16042: LIST
16043: LIST
16044: LIST
16045: LIST
16046: LIST
16047: LIST
16048: LIST
16049: LIST
16050: LIST
16051: LIST
16052: LIST
16053: LIST
16054: LIST
16055: LIST
16056: DIFF
16057: ST_TO_ADDR
// ExtSaveCharacters ( randomsToSave , other_survivors , 3 ) ;
16058: LD_VAR 0 2
16062: PPUSH
16063: LD_STRING other_survivors
16065: PPUSH
16066: LD_INT 3
16068: PPUSH
16069: CALL 6105 0 3
// end ;
16073: LD_VAR 0 1
16077: RET
// function SaveGlobalVariables ; begin
16078: LD_INT 0
16080: PPUSH
// SaveBase ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] ] ) , 08_TrockyBase_1 ) ;
16081: LD_INT 22
16083: PUSH
16084: LD_INT 3
16086: PUSH
16087: EMPTY
16088: LIST
16089: LIST
16090: PUSH
16091: LD_INT 21
16093: PUSH
16094: LD_INT 3
16096: PUSH
16097: EMPTY
16098: LIST
16099: LIST
16100: PUSH
16101: EMPTY
16102: LIST
16103: LIST
16104: PPUSH
16105: CALL_OW 69
16109: PPUSH
16110: LD_STRING 08_TrockyBase_1
16112: PPUSH
16113: CALL 8484 0 2
// SaveVariable ( coopWithGensher , 08_CoopWithGensher_2 ) ;
16117: LD_EXP 2
16121: PPUSH
16122: LD_STRING 08_CoopWithGensher_2
16124: PPUSH
16125: CALL_OW 39
// SaveVariable ( HeikeStatus , 08_HeikeStatus_3 ) ;
16129: LD_EXP 3
16133: PPUSH
16134: LD_STRING 08_HeikeStatus_3
16136: PPUSH
16137: CALL_OW 39
// SaveVariable ( Masha , 08_Masha_4 ) ;
16141: LD_EXP 4
16145: PPUSH
16146: LD_STRING 08_Masha_4
16148: PPUSH
16149: CALL_OW 39
// end ; end_of_file
16153: LD_VAR 0 1
16157: RET
// export function CustomEvent ( event ) ; begin
16158: LD_INT 0
16160: PPUSH
// end ;
16161: LD_VAR 0 2
16165: RET
// on BuildingComplete ( building ) do begin if GetBType ( building ) in buildingsToBuild and GetNation ( building ) = nation_russian then
16166: LD_VAR 0 1
16170: PPUSH
16171: CALL_OW 266
16175: PUSH
16176: LD_EXP 8
16180: IN
16181: PUSH
16182: LD_VAR 0 1
16186: PPUSH
16187: CALL_OW 248
16191: PUSH
16192: LD_INT 3
16194: EQUAL
16195: AND
16196: IFFALSE 16219
// buildingsToBuild = buildingsToBuild diff GetBType ( building ) ;
16198: LD_ADDR_EXP 8
16202: PUSH
16203: LD_EXP 8
16207: PUSH
16208: LD_VAR 0 1
16212: PPUSH
16213: CALL_OW 266
16217: DIFF
16218: ST_TO_ADDR
// if GetBType ( building ) = b_depot then
16219: LD_VAR 0 1
16223: PPUSH
16224: CALL_OW 266
16228: PUSH
16229: LD_INT 0
16231: EQUAL
16232: IFFALSE 16283
// begin SetBName ( building , trockij ) ;
16234: LD_VAR 0 1
16238: PPUSH
16239: LD_STRING trockij
16241: PPUSH
16242: CALL_OW 500
// if not dial_BuildDepotBlocker and HeikeCaptured then
16246: LD_EXP 5
16250: NOT
16251: PUSH
16252: LD_EXP 1
16256: AND
16257: IFFALSE 16283
// Dial_EscortHeike ( GetX ( building ) , GetY ( building ) ) ;
16259: LD_VAR 0 1
16263: PPUSH
16264: CALL_OW 250
16268: PPUSH
16269: LD_VAR 0 1
16273: PPUSH
16274: CALL_OW 251
16278: PPUSH
16279: CALL 9149 0 2
// end ; end ;
16283: PPOPN 1
16285: END
// on UpgradeComplete ( building ) do begin if GetBType ( building ) in buildingsToBuild and GetNation ( building ) = nation_russian then
16286: LD_VAR 0 1
16290: PPUSH
16291: CALL_OW 266
16295: PUSH
16296: LD_EXP 8
16300: IN
16301: PUSH
16302: LD_VAR 0 1
16306: PPUSH
16307: CALL_OW 248
16311: PUSH
16312: LD_INT 3
16314: EQUAL
16315: AND
16316: IFFALSE 16339
// buildingsToBuild = buildingsToBuild diff GetBType ( building ) ;
16318: LD_ADDR_EXP 8
16322: PUSH
16323: LD_EXP 8
16327: PUSH
16328: LD_VAR 0 1
16332: PPUSH
16333: CALL_OW 266
16337: DIFF
16338: ST_TO_ADDR
// if GetBType ( building ) = b_barracks and GetNation ( building ) = 2 and not dial_BuildArBarrackBlocker then
16339: LD_VAR 0 1
16343: PPUSH
16344: CALL_OW 266
16348: PUSH
16349: LD_INT 5
16351: EQUAL
16352: PUSH
16353: LD_VAR 0 1
16357: PPUSH
16358: CALL_OW 248
16362: PUSH
16363: LD_INT 2
16365: EQUAL
16366: AND
16367: PUSH
16368: LD_EXP 6
16372: NOT
16373: AND
16374: IFFALSE 16380
// Dial_UpgradeArmoury ;
16376: CALL 9960 0 0
// end ;
16380: PPOPN 1
16382: END
// on ResearchComplete ( research , building ) do begin if research in techsToResearch then
16383: LD_VAR 0 1
16387: PUSH
16388: LD_EXP 9
16392: IN
16393: IFFALSE 16411
// techsToResearch = techsToResearch diff research ;
16395: LD_ADDR_EXP 9
16399: PUSH
16400: LD_EXP 9
16404: PUSH
16405: LD_VAR 0 1
16409: DIFF
16410: ST_TO_ADDR
// if research = tech_LimTeleport then
16411: LD_VAR 0 1
16415: PUSH
16416: LD_INT 37
16418: EQUAL
16419: IFFALSE 16425
// Dial_TeleportTechResearched ;
16421: CALL 13805 0 0
// if research = tech_AdvAI then
16425: LD_VAR 0 1
16429: PUSH
16430: LD_INT 27
16432: EQUAL
16433: IFFALSE 16439
// Dial_ComputerTechResearched ;
16435: CALL 13674 0 0
// end ;
16439: PPOPN 2
16441: END
// on EnterVehicle ( vehicle , human ) do begin if not canChooseMashaVehicle then
16442: LD_EXP 36
16446: NOT
16447: IFFALSE 16451
// exit ;
16449: GO 16618
// wait ( 0 0$1 ) ;
16451: LD_INT 35
16453: PPUSH
16454: CALL_OW 67
// if GetSide ( vehicle ) = 3 and human = Burlak and GetNation ( vehicle ) = nation_russian and GetWeapon ( vehicle ) in [ ru_heavy_machine_gun , ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher ] then
16458: LD_VAR 0 1
16462: PPUSH
16463: CALL_OW 255
16467: PUSH
16468: LD_INT 3
16470: EQUAL
16471: PUSH
16472: LD_VAR 0 2
16476: PUSH
16477: LD_EXP 57
16481: EQUAL
16482: AND
16483: PUSH
16484: LD_VAR 0 1
16488: PPUSH
16489: CALL_OW 248
16493: PUSH
16494: LD_INT 3
16496: EQUAL
16497: AND
16498: PUSH
16499: LD_VAR 0 1
16503: PPUSH
16504: CALL_OW 264
16508: PUSH
16509: LD_INT 42
16511: PUSH
16512: LD_INT 43
16514: PUSH
16515: LD_INT 44
16517: PUSH
16518: LD_INT 46
16520: PUSH
16521: LD_INT 45
16523: PUSH
16524: EMPTY
16525: LIST
16526: LIST
16527: LIST
16528: LIST
16529: LIST
16530: IN
16531: AND
16532: IFFALSE 16618
// begin if Masha then
16534: LD_EXP 4
16538: IFFALSE 16558
// if Masha [ 1 ] = vehicle then
16540: LD_EXP 4
16544: PUSH
16545: LD_INT 1
16547: ARRAY
16548: PUSH
16549: LD_VAR 0 1
16553: EQUAL
16554: IFFALSE 16558
// exit ;
16556: GO 16618
// if firstMashaQuery then
16558: LD_EXP 35
16562: IFFALSE 16596
// begin firstMashaQuery = false ;
16564: LD_ADDR_EXP 35
16568: PUSH
16569: LD_INT 0
16571: ST_TO_ADDR
// if Query ( QMashaQuery ) = 1 then
16572: LD_STRING QMashaQuery
16574: PPUSH
16575: CALL_OW 97
16579: PUSH
16580: LD_INT 1
16582: EQUAL
16583: IFFALSE 16594
// SetMashaData ( vehicle ) ;
16585: LD_VAR 0 1
16589: PPUSH
16590: CALL 8378 0 1
// end else
16594: GO 16618
// begin if Query ( QMashaQuery2 ) = 1 then
16596: LD_STRING QMashaQuery2
16598: PPUSH
16599: CALL_OW 97
16603: PUSH
16604: LD_INT 1
16606: EQUAL
16607: IFFALSE 16618
// SetMashaData ( vehicle ) ;
16609: LD_VAR 0 1
16613: PPUSH
16614: CALL 8378 0 1
// end ; end ; end ;
16618: PPOPN 2
16620: END
// on UnitDestroyed ( unit ) do begin if Masha then
16621: LD_EXP 4
16625: IFFALSE 16650
// if unit = Masha [ 1 ] then
16627: LD_VAR 0 1
16631: PUSH
16632: LD_EXP 4
16636: PUSH
16637: LD_INT 1
16639: ARRAY
16640: EQUAL
16641: IFFALSE 16650
// Masha = [ ] ;
16643: LD_ADDR_EXP 4
16647: PUSH
16648: EMPTY
16649: ST_TO_ADDR
// if unit = Burlak then
16650: LD_VAR 0 1
16654: PUSH
16655: LD_EXP 57
16659: EQUAL
16660: IFFALSE 16666
// Lose_Burlak ;
16662: CALL 15213 0 0
// if GetType ( unit ) = unit_human and GetNation ( unit ) = nation_russian then
16666: LD_VAR 0 1
16670: PPUSH
16671: CALL_OW 247
16675: PUSH
16676: LD_INT 1
16678: EQUAL
16679: PUSH
16680: LD_VAR 0 1
16684: PPUSH
16685: CALL_OW 248
16689: PUSH
16690: LD_INT 3
16692: EQUAL
16693: AND
16694: IFFALSE 16710
// lostUnits = lostUnits + 1 ;
16696: LD_ADDR_EXP 40
16700: PUSH
16701: LD_EXP 40
16705: PUSH
16706: LD_INT 1
16708: PLUS
16709: ST_TO_ADDR
// end ;
16710: PPOPN 1
16712: END
// on UnitGoesToRed ( unit ) do begin if GetType ( unit ) = unit_vehicle and GetNation ( unit ) = nation_russian and GetTech ( tech_LimTeleport , 3 ) = state_researched and not testedTeleport then
16713: LD_VAR 0 1
16717: PPUSH
16718: CALL_OW 247
16722: PUSH
16723: LD_INT 2
16725: EQUAL
16726: PUSH
16727: LD_VAR 0 1
16731: PPUSH
16732: CALL_OW 248
16736: PUSH
16737: LD_INT 3
16739: EQUAL
16740: AND
16741: PUSH
16742: LD_INT 37
16744: PPUSH
16745: LD_INT 3
16747: PPUSH
16748: CALL_OW 321
16752: PUSH
16753: LD_INT 2
16755: EQUAL
16756: AND
16757: PUSH
16758: LD_EXP 39
16762: NOT
16763: AND
16764: IFFALSE 16781
// begin testedTeleport = true ;
16766: LD_ADDR_EXP 39
16770: PUSH
16771: LD_INT 1
16773: ST_TO_ADDR
// ChangeMissionObjectives ( MTeleDone ) ;
16774: LD_STRING MTeleDone
16776: PPUSH
16777: CALL_OW 337
// end ; if unit = Heike then
16781: LD_VAR 0 1
16785: PUSH
16786: LD_EXP 79
16790: EQUAL
16791: IFFALSE 16834
// begin DialogueOn ;
16793: CALL_OW 6
// CenterNowOnUnits ( Heike ) ;
16797: LD_EXP 79
16801: PPUSH
16802: CALL_OW 87
// ForceSay ( Heike , DHeikeKilled-Hke-1 ) ;
16806: LD_EXP 79
16810: PPUSH
16811: LD_STRING DHeikeKilled-Hke-1
16813: PPUSH
16814: CALL_OW 91
// DialogueOff ;
16818: CALL_OW 7
// SetLives ( Heike , 0 ) ;
16822: LD_EXP 79
16826: PPUSH
16827: LD_INT 0
16829: PPUSH
16830: CALL_OW 234
// end ; end ;
16834: PPOPN 1
16836: END
// on Contact ( side1 , side2 ) do begin if side1 = 3 and side2 = 6 then
16837: LD_VAR 0 1
16841: PUSH
16842: LD_INT 3
16844: EQUAL
16845: PUSH
16846: LD_VAR 0 2
16850: PUSH
16851: LD_INT 6
16853: EQUAL
16854: AND
16855: IFFALSE 16861
// Lost_AttackAlly ;
16857: CALL 15228 0 0
// if side1 = 3 and side2 = 2 then
16861: LD_VAR 0 1
16865: PUSH
16866: LD_INT 3
16868: EQUAL
16869: PUSH
16870: LD_VAR 0 2
16874: PUSH
16875: LD_INT 2
16877: EQUAL
16878: AND
16879: IFFALSE 16885
// Dial_AttackGensher ;
16881: CALL 10916 0 0
// if side1 = 3 and side2 = 5 then
16885: LD_VAR 0 1
16889: PUSH
16890: LD_INT 3
16892: EQUAL
16893: PUSH
16894: LD_VAR 0 2
16898: PUSH
16899: LD_INT 5
16901: EQUAL
16902: AND
16903: IFFALSE 16947
// begin SetAttitude ( 3 , 5 , att_enemy , true ) ;
16905: LD_INT 3
16907: PPUSH
16908: LD_INT 5
16910: PPUSH
16911: LD_INT 2
16913: PPUSH
16914: LD_INT 1
16916: PPUSH
16917: CALL_OW 80
// if acceptKurtOffert and not GetSide ( Kurt ) = 2 then
16921: LD_EXP 19
16925: PUSH
16926: LD_EXP 80
16930: PPUSH
16931: CALL_OW 255
16935: PUSH
16936: LD_INT 2
16938: EQUAL
16939: NOT
16940: AND
16941: IFFALSE 16947
// Dial_BetrayedKurt1 ;
16943: CALL 11465 0 0
// end ; if side1 = 3 and side2 = 8 and GetAttitude ( 3 , 8 ) = att_neutral then
16947: LD_VAR 0 1
16951: PUSH
16952: LD_INT 3
16954: EQUAL
16955: PUSH
16956: LD_VAR 0 2
16960: PUSH
16961: LD_INT 8
16963: EQUAL
16964: AND
16965: PUSH
16966: LD_INT 3
16968: PPUSH
16969: LD_INT 8
16971: PPUSH
16972: CALL_OW 81
16976: PUSH
16977: LD_INT 0
16979: EQUAL
16980: AND
16981: IFFALSE 16993
// begin if acceptKurtOffert then
16983: LD_EXP 19
16987: IFFALSE 16993
// Dial_BetrayedKurt2 ;
16989: CALL 11551 0 0
// end ; end ;
16993: PPOPN 2
16995: END
// on VehicleConstructed ( vehicle , building ) do begin SetWeaponDataBuild ( GetWeapon ( vehicle ) , false ) ;
16996: LD_VAR 0 1
17000: PPUSH
17001: CALL_OW 264
17005: PPUSH
17006: LD_INT 0
17008: PPUSH
17009: CALL 6886 0 2
// if GetControl ( vehicle ) = control_computer and not buildCompVehicle then
17013: LD_VAR 0 1
17017: PPUSH
17018: CALL_OW 263
17022: PUSH
17023: LD_INT 3
17025: EQUAL
17026: PUSH
17027: LD_EXP 37
17031: NOT
17032: AND
17033: IFFALSE 17050
// begin buildCompVehicle = true ;
17035: LD_ADDR_EXP 37
17039: PUSH
17040: LD_INT 1
17042: ST_TO_ADDR
// ChangeMissionObjectives ( MAIDone ) ;
17043: LD_STRING MAIDone
17045: PPUSH
17046: CALL_OW 337
// end ; end ;
17050: PPOPN 2
17052: END
// on WeaponPlaced ( building , factory ) do begin SetWeaponDataBuild ( GetBWeapon ( building ) , true ) ;
17053: LD_VAR 0 1
17057: PPUSH
17058: CALL_OW 269
17062: PPUSH
17063: LD_INT 1
17065: PPUSH
17066: CALL 6886 0 2
// end ;
17070: PPOPN 2
17072: END
// on Command ( comandid ) do var i ;
17073: LD_INT 0
17075: PPUSH
// begin if IsOK ( KurtEng ) and GetSide ( KurtEng ) = 3 then
17076: LD_EXP 82
17080: PPUSH
17081: CALL_OW 302
17085: PUSH
17086: LD_EXP 82
17090: PPUSH
17091: CALL_OW 255
17095: PUSH
17096: LD_INT 3
17098: EQUAL
17099: AND
17100: IFFALSE 17309
// if GetTaskList ( KurtEng ) then
17102: LD_EXP 82
17106: PPUSH
17107: CALL_OW 437
17111: IFFALSE 17309
// begin for i := 1 to ( GetTaskList ( KurtEng ) ) do
17113: LD_ADDR_VAR 0 2
17117: PUSH
17118: DOUBLE
17119: LD_INT 1
17121: DEC
17122: ST_TO_ADDR
17123: LD_EXP 82
17127: PPUSH
17128: CALL_OW 437
17132: PUSH
17133: FOR_TO
17134: IFFALSE 17307
// begin if ( GetTaskList ( KurtEng ) [ i ] [ 1 ] in [ F , H , M , U , V , a , h , u , v , ~ , ^ , > , + , ; , 4 , { ] ) or ( GetTaskList ( KurtEng ) [ i ] [ 1 ] = B and GetTaskList ( KurtEng ) [ i ] [ 5 ] = 36 ) then
17136: LD_EXP 82
17140: PPUSH
17141: CALL_OW 437
17145: PUSH
17146: LD_VAR 0 2
17150: ARRAY
17151: PUSH
17152: LD_INT 1
17154: ARRAY
17155: PUSH
17156: LD_STRING F
17158: PUSH
17159: LD_STRING H
17161: PUSH
17162: LD_STRING M
17164: PUSH
17165: LD_STRING U
17167: PUSH
17168: LD_STRING V
17170: PUSH
17171: LD_STRING a
17173: PUSH
17174: LD_STRING h
17176: PUSH
17177: LD_STRING u
17179: PUSH
17180: LD_STRING v
17182: PUSH
17183: LD_STRING ~
17185: PUSH
17186: LD_STRING ^
17188: PUSH
17189: LD_STRING >
17191: PUSH
17192: LD_STRING +
17194: PUSH
17195: LD_STRING ;
17197: PUSH
17198: LD_STRING 4
17200: PUSH
17201: LD_STRING {
17203: PUSH
17204: EMPTY
17205: LIST
17206: LIST
17207: LIST
17208: LIST
17209: LIST
17210: LIST
17211: LIST
17212: LIST
17213: LIST
17214: LIST
17215: LIST
17216: LIST
17217: LIST
17218: LIST
17219: LIST
17220: LIST
17221: IN
17222: PUSH
17223: LD_EXP 82
17227: PPUSH
17228: CALL_OW 437
17232: PUSH
17233: LD_VAR 0 2
17237: ARRAY
17238: PUSH
17239: LD_INT 1
17241: ARRAY
17242: PUSH
17243: LD_STRING B
17245: EQUAL
17246: PUSH
17247: LD_EXP 82
17251: PPUSH
17252: CALL_OW 437
17256: PUSH
17257: LD_VAR 0 2
17261: ARRAY
17262: PUSH
17263: LD_INT 5
17265: ARRAY
17266: PUSH
17267: LD_INT 36
17269: EQUAL
17270: AND
17271: OR
17272: IFFALSE 17276
// else
17274: GO 17305
// begin RemoveTasks ( KurtEng ) ;
17276: LD_EXP 82
17280: PPUSH
17281: CALL_OW 493
// DialogueOn ;
17285: CALL_OW 6
// Say ( Kurt , DMercRefuseBuild-Kurt-1 ) ;
17289: LD_EXP 80
17293: PPUSH
17294: LD_STRING DMercRefuseBuild-Kurt-1
17296: PPUSH
17297: CALL_OW 88
// DialogueOff ;
17301: CALL_OW 7
// end ; end ;
17305: GO 17133
17307: POP
17308: POP
// end ; end ; end_of_file
17309: PPOPN 2
17311: END
// every 0 0$01 do var timer , cratesSpawned ;
17312: GO 17314
17314: DISABLE
17315: LD_INT 0
17317: PPUSH
17318: PPUSH
// begin timer := 1 1$30 ;
17319: LD_ADDR_VAR 0 1
17323: PUSH
17324: LD_INT 3150
17326: ST_TO_ADDR
// repeat wait ( timer ) ;
17327: LD_VAR 0 1
17331: PPUSH
17332: CALL_OW 67
// if cratesSpawned >= 6 and cratesSpawned < 18 then
17336: LD_VAR 0 2
17340: PUSH
17341: LD_INT 6
17343: GREATEREQUAL
17344: PUSH
17345: LD_VAR 0 2
17349: PUSH
17350: LD_INT 18
17352: LESS
17353: AND
17354: IFFALSE 17370
// timer := timer + 0 0$3 ;
17356: LD_ADDR_VAR 0 1
17360: PUSH
17361: LD_VAR 0 1
17365: PUSH
17366: LD_INT 105
17368: PLUS
17369: ST_TO_ADDR
// if cratesSpawned >= 18 then
17370: LD_VAR 0 2
17374: PUSH
17375: LD_INT 18
17377: GREATEREQUAL
17378: IFFALSE 17394
// timer := timer + 0 0$9 ;
17380: LD_ADDR_VAR 0 1
17384: PUSH
17385: LD_VAR 0 1
17389: PUSH
17390: LD_INT 315
17392: PLUS
17393: ST_TO_ADDR
// if timer > 3 3$00 then
17394: LD_VAR 0 1
17398: PUSH
17399: LD_INT 6300
17401: GREATER
17402: IFFALSE 17412
// timer := 0 0$50 ;
17404: LD_ADDR_VAR 0 1
17408: PUSH
17409: LD_INT 1750
17411: ST_TO_ADDR
// CreateCratesArea ( rand ( 3 , 5 ) , CratesSpawnArea , true ) ;
17412: LD_INT 3
17414: PPUSH
17415: LD_INT 5
17417: PPUSH
17418: CALL_OW 12
17422: PPUSH
17423: LD_INT 15
17425: PPUSH
17426: LD_INT 1
17428: PPUSH
17429: CALL_OW 55
// cratesSpawned = cratesSpawned + 1 ;
17433: LD_ADDR_VAR 0 2
17437: PUSH
17438: LD_VAR 0 2
17442: PUSH
17443: LD_INT 1
17445: PLUS
17446: ST_TO_ADDR
// until false ;
17447: LD_INT 0
17449: IFFALSE 17327
// end ; end_of_file
17451: PPOPN 2
17453: END
// every 0 0$1 do
17454: GO 17456
17456: DISABLE
// begin enable ;
17457: ENABLE
// end ;
17458: END
// every 0 0$1 do var building , playerBuildings , playerBuildingsBType ;
17459: GO 17461
17461: DISABLE
17462: LD_INT 0
17464: PPUSH
17465: PPUSH
17466: PPUSH
// begin playerBuildings = FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] , [ f_nation , nation_russian ] ] ) ;
17467: LD_ADDR_VAR 0 2
17471: PUSH
17472: LD_INT 22
17474: PUSH
17475: LD_INT 3
17477: PUSH
17478: EMPTY
17479: LIST
17480: LIST
17481: PUSH
17482: LD_INT 21
17484: PUSH
17485: LD_INT 3
17487: PUSH
17488: EMPTY
17489: LIST
17490: LIST
17491: PUSH
17492: LD_INT 23
17494: PUSH
17495: LD_INT 3
17497: PUSH
17498: EMPTY
17499: LIST
17500: LIST
17501: PUSH
17502: EMPTY
17503: LIST
17504: LIST
17505: LIST
17506: PPUSH
17507: CALL_OW 69
17511: ST_TO_ADDR
// playerBuildingsBType = [ ] ;
17512: LD_ADDR_VAR 0 3
17516: PUSH
17517: EMPTY
17518: ST_TO_ADDR
// for building in playerBuildings do
17519: LD_ADDR_VAR 0 1
17523: PUSH
17524: LD_VAR 0 2
17528: PUSH
17529: FOR_IN
17530: IFFALSE 17555
// playerBuildingsBType = playerBuildingsBType ^ GetBType ( building ) ;
17532: LD_ADDR_VAR 0 3
17536: PUSH
17537: LD_VAR 0 3
17541: PUSH
17542: LD_VAR 0 1
17546: PPUSH
17547: CALL_OW 266
17551: ADD
17552: ST_TO_ADDR
17553: GO 17529
17555: POP
17556: POP
// for building in allBuildings do
17557: LD_ADDR_VAR 0 1
17561: PUSH
17562: LD_EXP 13
17566: PUSH
17567: FOR_IN
17568: IFFALSE 17614
// if not building in playerBuildingsBType and not building in buildingsToBuild then
17570: LD_VAR 0 1
17574: PUSH
17575: LD_VAR 0 3
17579: IN
17580: NOT
17581: PUSH
17582: LD_VAR 0 1
17586: PUSH
17587: LD_EXP 8
17591: IN
17592: NOT
17593: AND
17594: IFFALSE 17612
// buildingsToBuild = buildingsToBuild ^ building ;
17596: LD_ADDR_EXP 8
17600: PUSH
17601: LD_EXP 8
17605: PUSH
17606: LD_VAR 0 1
17610: ADD
17611: ST_TO_ADDR
17612: GO 17567
17614: POP
17615: POP
// enable ;
17616: ENABLE
// end ;
17617: PPOPN 3
17619: END
// every 0 0$1 trigger legionOffertCountdown do
17620: LD_EXP 33
17624: IFFALSE 17644
17626: GO 17628
17628: DISABLE
// begin legionOffertTime = legionOffertTime - 0 0$01 ;
17629: LD_ADDR_EXP 34
17633: PUSH
17634: LD_EXP 34
17638: PUSH
17639: LD_INT 35
17641: MINUS
17642: ST_TO_ADDR
// enable ;
17643: ENABLE
// end ;
17644: END
// every 0 0$1 trigger KurtWaitingForFreeHeike do
17645: LD_EXP 23
17649: IFFALSE 17683
17651: GO 17653
17653: DISABLE
// begin timeToFreeHeike = timeToFreeHeike - 0 0$01 ;
17654: LD_ADDR_EXP 54
17658: PUSH
17659: LD_EXP 54
17663: PUSH
17664: LD_INT 35
17666: MINUS
17667: ST_TO_ADDR
// if timeToFreeHeike <= 0 0$00 then
17668: LD_EXP 54
17672: PUSH
17673: LD_INT 0
17675: LESSEQUAL
17676: IFFALSE 17682
// Dial_PlayerDontSendHeike ;
17678: CALL 11413 0 0
// enable ;
17682: ENABLE
// end ;
17683: END
// every 0 0$1 trigger KurtWaitingForBuildBarrack and GetSide ( KurtEng ) = 3 do
17684: LD_EXP 24
17688: PUSH
17689: LD_EXP 82
17693: PPUSH
17694: CALL_OW 255
17698: PUSH
17699: LD_INT 3
17701: EQUAL
17702: AND
17703: IFFALSE 17776
17705: GO 17707
17707: DISABLE
// begin timeToBuildArBarrack = timeToBuildArBarrack - 0 0$01 ;
17708: LD_ADDR_EXP 55
17712: PUSH
17713: LD_EXP 55
17717: PUSH
17718: LD_INT 35
17720: MINUS
17721: ST_TO_ADDR
// if timeToBuildArBarrack <= 0 0$00 then
17722: LD_EXP 55
17726: PUSH
17727: LD_INT 0
17729: LESSEQUAL
17730: IFFALSE 17775
// begin Dial_BetrayedKurt1 ;
17732: CALL 11465 0 0
// wait ( 2 2$0 ) ;
17736: LD_INT 4200
17738: PPUSH
17739: CALL_OW 67
// SetAttitude ( 3 , 8 , att_enemy , true ) ;
17743: LD_INT 3
17745: PPUSH
17746: LD_INT 8
17748: PPUSH
17749: LD_INT 2
17751: PPUSH
17752: LD_INT 1
17754: PPUSH
17755: CALL_OW 80
// KurtAttack = true ;
17759: LD_ADDR_EXP 25
17763: PUSH
17764: LD_INT 1
17766: ST_TO_ADDR
// KurtWaitingForBuildBarrack = false ;
17767: LD_ADDR_EXP 24
17771: PUSH
17772: LD_INT 0
17774: ST_TO_ADDR
// end ; enable ;
17775: ENABLE
// end ; end_of_file
17776: END
// export currentAmWave , currentArWave ; every 0 0$1 trigger americansAttack do var i ;
17777: LD_EXP 26
17781: IFFALSE 17927
17783: GO 17785
17785: DISABLE
17786: LD_INT 0
17788: PPUSH
// begin currentAmWave = 0 ;
17789: LD_ADDR_EXP 85
17793: PUSH
17794: LD_INT 0
17796: ST_TO_ADDR
// wait ( firstAttackDelay ) ;
17797: LD_EXP 49
17801: PPUSH
17802: CALL_OW 67
// for i := 1 to americansAttackWaves do
17806: LD_ADDR_VAR 0 1
17810: PUSH
17811: DOUBLE
17812: LD_INT 1
17814: DEC
17815: ST_TO_ADDR
17816: LD_EXP 48
17820: PUSH
17821: FOR_TO
17822: IFFALSE 17925
// begin SpawnAmAttackTeam ;
17824: CALL 3214 0 0
// currentAmWave = currentAmWave + 1 ;
17828: LD_ADDR_EXP 85
17832: PUSH
17833: LD_EXP 85
17837: PUSH
17838: LD_INT 1
17840: PLUS
17841: ST_TO_ADDR
// if currentAmWave = 1 then
17842: LD_EXP 85
17846: PUSH
17847: LD_INT 1
17849: EQUAL
17850: IFFALSE 17914
// begin if paidLegionOffert then
17852: LD_EXP 32
17856: IFFALSE 17895
// begin Say ( Burlak , DAmAttackStart-Bur-1 ) ;
17858: LD_EXP 57
17862: PPUSH
17863: LD_STRING DAmAttackStart-Bur-1
17865: PPUSH
17866: CALL_OW 88
// if IsOK ( Gleb ) then
17870: LD_EXP 60
17874: PPUSH
17875: CALL_OW 302
17879: IFFALSE 17893
// Say ( Gleb , DAmAttackStart-Glb-1 ) ;
17881: LD_EXP 60
17885: PPUSH
17886: LD_STRING DAmAttackStart-Glb-1
17888: PPUSH
17889: CALL_OW 88
// end else
17893: GO 17907
// Say ( Burlak , DAmAttackStart-Bur-2 ) ;
17895: LD_EXP 57
17899: PPUSH
17900: LD_STRING DAmAttackStart-Bur-2
17902: PPUSH
17903: CALL_OW 88
// ChangeMissionObjectives ( MEnemy ) ;
17907: LD_STRING MEnemy
17909: PPUSH
17910: CALL_OW 337
// end ; wait ( waveCooldown ) ;
17914: LD_EXP 50
17918: PPUSH
17919: CALL_OW 67
// end ;
17923: GO 17821
17925: POP
17926: POP
// end ;
17927: PPOPN 1
17929: END
// every 0 0$1 trigger currentAmWave = 1 do
17930: LD_EXP 85
17934: PUSH
17935: LD_INT 1
17937: EQUAL
17938: IFFALSE 18027
17940: GO 17942
17942: DISABLE
// Attack ( [ 0 , amAttackTeam , [ [ 115 , 42 ] , [ 51 , 67 ] ] , [ 0 , 0 , 0 , 1 , 1 , 1 , 0 , 0 , 1 , 0 ] ] ) ;
17943: LD_INT 0
17945: PUSH
17946: LD_EXP 78
17950: PUSH
17951: LD_INT 115
17953: PUSH
17954: LD_INT 42
17956: PUSH
17957: EMPTY
17958: LIST
17959: LIST
17960: PUSH
17961: LD_INT 51
17963: PUSH
17964: LD_INT 67
17966: PUSH
17967: EMPTY
17968: LIST
17969: LIST
17970: PUSH
17971: EMPTY
17972: LIST
17973: LIST
17974: PUSH
17975: LD_INT 0
17977: PUSH
17978: LD_INT 0
17980: PUSH
17981: LD_INT 0
17983: PUSH
17984: LD_INT 1
17986: PUSH
17987: LD_INT 1
17989: PUSH
17990: LD_INT 1
17992: PUSH
17993: LD_INT 0
17995: PUSH
17996: LD_INT 0
17998: PUSH
17999: LD_INT 1
18001: PUSH
18002: LD_INT 0
18004: PUSH
18005: EMPTY
18006: LIST
18007: LIST
18008: LIST
18009: LIST
18010: LIST
18011: LIST
18012: LIST
18013: LIST
18014: LIST
18015: LIST
18016: PUSH
18017: EMPTY
18018: LIST
18019: LIST
18020: LIST
18021: LIST
18022: PPUSH
18023: CALL 80896 0 1
18027: END
// every 0 0$1 trigger currentAmWave = 2 do
18028: LD_EXP 85
18032: PUSH
18033: LD_INT 2
18035: EQUAL
18036: IFFALSE 18125
18038: GO 18040
18040: DISABLE
// Attack ( [ 0 , amAttackTeam , [ [ 115 , 42 ] , [ 51 , 67 ] ] , [ 0 , 0 , 0 , 1 , 1 , 1 , 0 , 0 , 1 , 0 ] ] ) ;
18041: LD_INT 0
18043: PUSH
18044: LD_EXP 78
18048: PUSH
18049: LD_INT 115
18051: PUSH
18052: LD_INT 42
18054: PUSH
18055: EMPTY
18056: LIST
18057: LIST
18058: PUSH
18059: LD_INT 51
18061: PUSH
18062: LD_INT 67
18064: PUSH
18065: EMPTY
18066: LIST
18067: LIST
18068: PUSH
18069: EMPTY
18070: LIST
18071: LIST
18072: PUSH
18073: LD_INT 0
18075: PUSH
18076: LD_INT 0
18078: PUSH
18079: LD_INT 0
18081: PUSH
18082: LD_INT 1
18084: PUSH
18085: LD_INT 1
18087: PUSH
18088: LD_INT 1
18090: PUSH
18091: LD_INT 0
18093: PUSH
18094: LD_INT 0
18096: PUSH
18097: LD_INT 1
18099: PUSH
18100: LD_INT 0
18102: PUSH
18103: EMPTY
18104: LIST
18105: LIST
18106: LIST
18107: LIST
18108: LIST
18109: LIST
18110: LIST
18111: LIST
18112: LIST
18113: LIST
18114: PUSH
18115: EMPTY
18116: LIST
18117: LIST
18118: LIST
18119: LIST
18120: PPUSH
18121: CALL 80896 0 1
18125: END
// every 0 0$1 trigger currentAmWave = 3 do
18126: LD_EXP 85
18130: PUSH
18131: LD_INT 3
18133: EQUAL
18134: IFFALSE 18223
18136: GO 18138
18138: DISABLE
// Attack ( [ 0 , amAttackTeam , [ [ 115 , 42 ] , [ 51 , 67 ] ] , [ 0 , 0 , 0 , 1 , 1 , 1 , 0 , 0 , 1 , 0 ] ] ) ;
18139: LD_INT 0
18141: PUSH
18142: LD_EXP 78
18146: PUSH
18147: LD_INT 115
18149: PUSH
18150: LD_INT 42
18152: PUSH
18153: EMPTY
18154: LIST
18155: LIST
18156: PUSH
18157: LD_INT 51
18159: PUSH
18160: LD_INT 67
18162: PUSH
18163: EMPTY
18164: LIST
18165: LIST
18166: PUSH
18167: EMPTY
18168: LIST
18169: LIST
18170: PUSH
18171: LD_INT 0
18173: PUSH
18174: LD_INT 0
18176: PUSH
18177: LD_INT 0
18179: PUSH
18180: LD_INT 1
18182: PUSH
18183: LD_INT 1
18185: PUSH
18186: LD_INT 1
18188: PUSH
18189: LD_INT 0
18191: PUSH
18192: LD_INT 0
18194: PUSH
18195: LD_INT 1
18197: PUSH
18198: LD_INT 0
18200: PUSH
18201: EMPTY
18202: LIST
18203: LIST
18204: LIST
18205: LIST
18206: LIST
18207: LIST
18208: LIST
18209: LIST
18210: LIST
18211: LIST
18212: PUSH
18213: EMPTY
18214: LIST
18215: LIST
18216: LIST
18217: LIST
18218: PPUSH
18219: CALL 80896 0 1
18223: END
// every 0 0$1 trigger KurtAttack do var i ;
18224: LD_EXP 25
18228: IFFALSE 18349
18230: GO 18232
18232: DISABLE
18233: LD_INT 0
18235: PPUSH
// begin currentArWave = 0 ;
18236: LD_ADDR_EXP 86
18240: PUSH
18241: LD_INT 0
18243: ST_TO_ADDR
// wait ( firstAttackDelay ) ;
18244: LD_EXP 49
18248: PPUSH
18249: CALL_OW 67
// for i := 1 to KurtAttackWaves do
18253: LD_ADDR_VAR 0 1
18257: PUSH
18258: DOUBLE
18259: LD_INT 1
18261: DEC
18262: ST_TO_ADDR
18263: LD_EXP 47
18267: PUSH
18268: FOR_TO
18269: IFFALSE 18347
// begin if KurtAttack and IsOK ( Heike ) then
18271: LD_EXP 25
18275: PUSH
18276: LD_EXP 79
18280: PPUSH
18281: CALL_OW 302
18285: AND
18286: IFFALSE 18345
// begin SpawnArAttackTeam ;
18288: CALL 4359 0 0
// currentArWave = currentArWave + 1 ;
18292: LD_ADDR_EXP 86
18296: PUSH
18297: LD_EXP 86
18301: PUSH
18302: LD_INT 1
18304: PLUS
18305: ST_TO_ADDR
// if currentArWave = 2 then
18306: LD_EXP 86
18310: PUSH
18311: LD_INT 2
18313: EQUAL
18314: IFFALSE 18336
// begin SayRadio ( Kurt , DMercAttack-Kurt-1 ) ;
18316: LD_EXP 80
18320: PPUSH
18321: LD_STRING DMercAttack-Kurt-1
18323: PPUSH
18324: CALL_OW 94
// canSendHeike = true ;
18328: LD_ADDR_EXP 28
18332: PUSH
18333: LD_INT 1
18335: ST_TO_ADDR
// end ; wait ( waveCooldown ) ;
18336: LD_EXP 50
18340: PPUSH
18341: CALL_OW 67
// end ; end ;
18345: GO 18268
18347: POP
18348: POP
// end ;
18349: PPOPN 1
18351: END
// every 0 0$1 trigger currentArWave = 1 do
18352: LD_EXP 86
18356: PUSH
18357: LD_INT 1
18359: EQUAL
18360: IFFALSE 18449
18362: GO 18364
18364: DISABLE
// Attack ( [ 0 , arAttackTeam , [ [ 115 , 42 ] , [ 51 , 67 ] ] , [ 0 , 0 , 0 , 1 , 1 , 1 , 0 , 0 , 1 , 0 ] ] ) ;
18365: LD_INT 0
18367: PUSH
18368: LD_EXP 84
18372: PUSH
18373: LD_INT 115
18375: PUSH
18376: LD_INT 42
18378: PUSH
18379: EMPTY
18380: LIST
18381: LIST
18382: PUSH
18383: LD_INT 51
18385: PUSH
18386: LD_INT 67
18388: PUSH
18389: EMPTY
18390: LIST
18391: LIST
18392: PUSH
18393: EMPTY
18394: LIST
18395: LIST
18396: PUSH
18397: LD_INT 0
18399: PUSH
18400: LD_INT 0
18402: PUSH
18403: LD_INT 0
18405: PUSH
18406: LD_INT 1
18408: PUSH
18409: LD_INT 1
18411: PUSH
18412: LD_INT 1
18414: PUSH
18415: LD_INT 0
18417: PUSH
18418: LD_INT 0
18420: PUSH
18421: LD_INT 1
18423: PUSH
18424: LD_INT 0
18426: PUSH
18427: EMPTY
18428: LIST
18429: LIST
18430: LIST
18431: LIST
18432: LIST
18433: LIST
18434: LIST
18435: LIST
18436: LIST
18437: LIST
18438: PUSH
18439: EMPTY
18440: LIST
18441: LIST
18442: LIST
18443: LIST
18444: PPUSH
18445: CALL 80896 0 1
18449: END
// every 0 0$1 trigger currentArWave = 2 do
18450: LD_EXP 86
18454: PUSH
18455: LD_INT 2
18457: EQUAL
18458: IFFALSE 18547
18460: GO 18462
18462: DISABLE
// Attack ( [ 0 , arAttackTeam , [ [ 115 , 42 ] , [ 51 , 67 ] ] , [ 0 , 0 , 0 , 1 , 1 , 1 , 0 , 0 , 1 , 0 ] ] ) ;
18463: LD_INT 0
18465: PUSH
18466: LD_EXP 84
18470: PUSH
18471: LD_INT 115
18473: PUSH
18474: LD_INT 42
18476: PUSH
18477: EMPTY
18478: LIST
18479: LIST
18480: PUSH
18481: LD_INT 51
18483: PUSH
18484: LD_INT 67
18486: PUSH
18487: EMPTY
18488: LIST
18489: LIST
18490: PUSH
18491: EMPTY
18492: LIST
18493: LIST
18494: PUSH
18495: LD_INT 0
18497: PUSH
18498: LD_INT 0
18500: PUSH
18501: LD_INT 0
18503: PUSH
18504: LD_INT 1
18506: PUSH
18507: LD_INT 1
18509: PUSH
18510: LD_INT 1
18512: PUSH
18513: LD_INT 0
18515: PUSH
18516: LD_INT 0
18518: PUSH
18519: LD_INT 1
18521: PUSH
18522: LD_INT 0
18524: PUSH
18525: EMPTY
18526: LIST
18527: LIST
18528: LIST
18529: LIST
18530: LIST
18531: LIST
18532: LIST
18533: LIST
18534: LIST
18535: LIST
18536: PUSH
18537: EMPTY
18538: LIST
18539: LIST
18540: LIST
18541: LIST
18542: PPUSH
18543: CALL 80896 0 1
18547: END
// every 0 0$1 trigger currentArWave = 3 do
18548: LD_EXP 86
18552: PUSH
18553: LD_INT 3
18555: EQUAL
18556: IFFALSE 18645
18558: GO 18560
18560: DISABLE
// Attack ( [ 0 , arAttackTeam , [ [ 115 , 42 ] , [ 51 , 67 ] ] , [ 0 , 0 , 0 , 1 , 1 , 1 , 0 , 0 , 1 , 0 ] ] ) ;
18561: LD_INT 0
18563: PUSH
18564: LD_EXP 84
18568: PUSH
18569: LD_INT 115
18571: PUSH
18572: LD_INT 42
18574: PUSH
18575: EMPTY
18576: LIST
18577: LIST
18578: PUSH
18579: LD_INT 51
18581: PUSH
18582: LD_INT 67
18584: PUSH
18585: EMPTY
18586: LIST
18587: LIST
18588: PUSH
18589: EMPTY
18590: LIST
18591: LIST
18592: PUSH
18593: LD_INT 0
18595: PUSH
18596: LD_INT 0
18598: PUSH
18599: LD_INT 0
18601: PUSH
18602: LD_INT 1
18604: PUSH
18605: LD_INT 1
18607: PUSH
18608: LD_INT 1
18610: PUSH
18611: LD_INT 0
18613: PUSH
18614: LD_INT 0
18616: PUSH
18617: LD_INT 1
18619: PUSH
18620: LD_INT 0
18622: PUSH
18623: EMPTY
18624: LIST
18625: LIST
18626: LIST
18627: LIST
18628: LIST
18629: LIST
18630: LIST
18631: LIST
18632: LIST
18633: LIST
18634: PUSH
18635: EMPTY
18636: LIST
18637: LIST
18638: LIST
18639: LIST
18640: PPUSH
18641: CALL 80896 0 1
18645: END
// every 0 0$1 trigger currentArWave = 4 do
18646: LD_EXP 86
18650: PUSH
18651: LD_INT 4
18653: EQUAL
18654: IFFALSE 18743
18656: GO 18658
18658: DISABLE
// Attack ( [ 0 , arAttackTeam , [ [ 115 , 42 ] , [ 51 , 67 ] ] , [ 0 , 0 , 0 , 1 , 1 , 1 , 0 , 0 , 1 , 0 ] ] ) ;
18659: LD_INT 0
18661: PUSH
18662: LD_EXP 84
18666: PUSH
18667: LD_INT 115
18669: PUSH
18670: LD_INT 42
18672: PUSH
18673: EMPTY
18674: LIST
18675: LIST
18676: PUSH
18677: LD_INT 51
18679: PUSH
18680: LD_INT 67
18682: PUSH
18683: EMPTY
18684: LIST
18685: LIST
18686: PUSH
18687: EMPTY
18688: LIST
18689: LIST
18690: PUSH
18691: LD_INT 0
18693: PUSH
18694: LD_INT 0
18696: PUSH
18697: LD_INT 0
18699: PUSH
18700: LD_INT 1
18702: PUSH
18703: LD_INT 1
18705: PUSH
18706: LD_INT 1
18708: PUSH
18709: LD_INT 0
18711: PUSH
18712: LD_INT 0
18714: PUSH
18715: LD_INT 1
18717: PUSH
18718: LD_INT 0
18720: PUSH
18721: EMPTY
18722: LIST
18723: LIST
18724: LIST
18725: LIST
18726: LIST
18727: LIST
18728: LIST
18729: LIST
18730: LIST
18731: LIST
18732: PUSH
18733: EMPTY
18734: LIST
18735: LIST
18736: LIST
18737: LIST
18738: PPUSH
18739: CALL 80896 0 1
18743: END
// every 0 0$1 trigger currentArWave = 5 do
18744: LD_EXP 86
18748: PUSH
18749: LD_INT 5
18751: EQUAL
18752: IFFALSE 18841
18754: GO 18756
18756: DISABLE
// Attack ( [ 0 , arAttackTeam , [ [ 115 , 42 ] , [ 51 , 67 ] ] , [ 0 , 0 , 0 , 1 , 1 , 1 , 0 , 0 , 1 , 0 ] ] ) ; end_of_file
18757: LD_INT 0
18759: PUSH
18760: LD_EXP 84
18764: PUSH
18765: LD_INT 115
18767: PUSH
18768: LD_INT 42
18770: PUSH
18771: EMPTY
18772: LIST
18773: LIST
18774: PUSH
18775: LD_INT 51
18777: PUSH
18778: LD_INT 67
18780: PUSH
18781: EMPTY
18782: LIST
18783: LIST
18784: PUSH
18785: EMPTY
18786: LIST
18787: LIST
18788: PUSH
18789: LD_INT 0
18791: PUSH
18792: LD_INT 0
18794: PUSH
18795: LD_INT 0
18797: PUSH
18798: LD_INT 1
18800: PUSH
18801: LD_INT 1
18803: PUSH
18804: LD_INT 1
18806: PUSH
18807: LD_INT 0
18809: PUSH
18810: LD_INT 0
18812: PUSH
18813: LD_INT 1
18815: PUSH
18816: LD_INT 0
18818: PUSH
18819: EMPTY
18820: LIST
18821: LIST
18822: LIST
18823: LIST
18824: LIST
18825: LIST
18826: LIST
18827: LIST
18828: LIST
18829: LIST
18830: PUSH
18831: EMPTY
18832: LIST
18833: LIST
18834: LIST
18835: LIST
18836: PPUSH
18837: CALL 80896 0 1
18841: END
// every 0 0$1 do var arVehs , arVeh , nearPlayerUnit ;
18842: GO 18844
18844: DISABLE
18845: LD_INT 0
18847: PPUSH
18848: PPUSH
18849: PPUSH
// begin enable ;
18850: ENABLE
// arVehs = FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_vehicle ] , [ f_empty ] ] ) ;
18851: LD_ADDR_VAR 0 1
18855: PUSH
18856: LD_INT 22
18858: PUSH
18859: LD_INT 8
18861: PUSH
18862: EMPTY
18863: LIST
18864: LIST
18865: PUSH
18866: LD_INT 21
18868: PUSH
18869: LD_INT 2
18871: PUSH
18872: EMPTY
18873: LIST
18874: LIST
18875: PUSH
18876: LD_INT 58
18878: PUSH
18879: EMPTY
18880: LIST
18881: PUSH
18882: EMPTY
18883: LIST
18884: LIST
18885: LIST
18886: PPUSH
18887: CALL_OW 69
18891: ST_TO_ADDR
// if not arVehs or not GetAttitude ( 3 , 8 ) = att_enemy then
18892: LD_VAR 0 1
18896: NOT
18897: PUSH
18898: LD_INT 3
18900: PPUSH
18901: LD_INT 8
18903: PPUSH
18904: CALL_OW 81
18908: PUSH
18909: LD_INT 2
18911: EQUAL
18912: NOT
18913: OR
18914: IFFALSE 18918
// exit ;
18916: GO 19008
// for arVeh in arVehs do
18918: LD_ADDR_VAR 0 2
18922: PUSH
18923: LD_VAR 0 1
18927: PUSH
18928: FOR_IN
18929: IFFALSE 19006
// begin nearPlayerUnit = NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) , arVeh ) ;
18931: LD_ADDR_VAR 0 3
18935: PUSH
18936: LD_INT 22
18938: PUSH
18939: LD_INT 3
18941: PUSH
18942: EMPTY
18943: LIST
18944: LIST
18945: PUSH
18946: LD_INT 21
18948: PUSH
18949: LD_INT 1
18951: PUSH
18952: EMPTY
18953: LIST
18954: LIST
18955: PUSH
18956: EMPTY
18957: LIST
18958: LIST
18959: PPUSH
18960: CALL_OW 69
18964: PPUSH
18965: LD_VAR 0 2
18969: PPUSH
18970: CALL_OW 74
18974: ST_TO_ADDR
// if GetDistUnits ( nearPlayerUnit , arVeh ) <= 2 then
18975: LD_VAR 0 3
18979: PPUSH
18980: LD_VAR 0 2
18984: PPUSH
18985: CALL_OW 296
18989: PUSH
18990: LD_INT 2
18992: LESSEQUAL
18993: IFFALSE 19004
// ComSelfDestruction ( arVeh ) ;
18995: LD_VAR 0 2
18999: PPUSH
19000: CALL_OW 577
// end ;
19004: GO 18928
19006: POP
19007: POP
// end ;
19008: PPOPN 3
19010: END
// every 0 0$1 trigger forceStopKurtAttack do
19011: LD_EXP 27
19015: IFFALSE 19081
19017: GO 19019
19019: DISABLE
// begin KurtAttack = false ;
19020: LD_ADDR_EXP 25
19024: PUSH
19025: LD_INT 0
19027: ST_TO_ADDR
// allowExitFromMap = 4 ;
19028: LD_ADDR_EXP 18
19032: PUSH
19033: LD_INT 4
19035: ST_TO_ADDR
// SetAttitude ( 3 , 8 , att_friend , true ) ;
19036: LD_INT 3
19038: PPUSH
19039: LD_INT 8
19041: PPUSH
19042: LD_INT 1
19044: PPUSH
19045: LD_INT 1
19047: PPUSH
19048: CALL_OW 80
// arAttackTeam = [ ] ;
19052: LD_ADDR_EXP 84
19056: PUSH
19057: EMPTY
19058: ST_TO_ADDR
// ComMoveToArea ( FilterAllUnits ( [ f_side , 8 ] ) , KurtExitMapArea ) ;
19059: LD_INT 22
19061: PUSH
19062: LD_INT 8
19064: PUSH
19065: EMPTY
19066: LIST
19067: LIST
19068: PPUSH
19069: CALL_OW 69
19073: PPUSH
19074: LD_INT 11
19076: PPUSH
19077: CALL_OW 113
// end ; end_of_file end_of_file
19081: END
// every 0 0$01 do var timer , cratesSpawned ;
19082: GO 19084
19084: DISABLE
19085: LD_INT 0
19087: PPUSH
19088: PPUSH
// begin timer := 1 1$30 ;
19089: LD_ADDR_VAR 0 1
19093: PUSH
19094: LD_INT 3150
19096: ST_TO_ADDR
// repeat wait ( timer ) ;
19097: LD_VAR 0 1
19101: PPUSH
19102: CALL_OW 67
// if cratesSpawned >= 6 and cratesSpawned < 18 then
19106: LD_VAR 0 2
19110: PUSH
19111: LD_INT 6
19113: GREATEREQUAL
19114: PUSH
19115: LD_VAR 0 2
19119: PUSH
19120: LD_INT 18
19122: LESS
19123: AND
19124: IFFALSE 19140
// timer := timer + 0 0$3 ;
19126: LD_ADDR_VAR 0 1
19130: PUSH
19131: LD_VAR 0 1
19135: PUSH
19136: LD_INT 105
19138: PLUS
19139: ST_TO_ADDR
// if cratesSpawned >= 18 then
19140: LD_VAR 0 2
19144: PUSH
19145: LD_INT 18
19147: GREATEREQUAL
19148: IFFALSE 19164
// timer := timer + 0 0$9 ;
19150: LD_ADDR_VAR 0 1
19154: PUSH
19155: LD_VAR 0 1
19159: PUSH
19160: LD_INT 315
19162: PLUS
19163: ST_TO_ADDR
// if timer > 3 3$00 then
19164: LD_VAR 0 1
19168: PUSH
19169: LD_INT 6300
19171: GREATER
19172: IFFALSE 19182
// timer := 0 0$50 ;
19174: LD_ADDR_VAR 0 1
19178: PUSH
19179: LD_INT 1750
19181: ST_TO_ADDR
// CreateCratesArea ( rand ( 3 , 5 ) , CratesSpawnArea , true ) ;
19182: LD_INT 3
19184: PPUSH
19185: LD_INT 5
19187: PPUSH
19188: CALL_OW 12
19192: PPUSH
19193: LD_INT 15
19195: PPUSH
19196: LD_INT 1
19198: PPUSH
19199: CALL_OW 55
// cratesSpawned = cratesSpawned + 1 ;
19203: LD_ADDR_VAR 0 2
19207: PUSH
19208: LD_VAR 0 2
19212: PUSH
19213: LD_INT 1
19215: PLUS
19216: ST_TO_ADDR
// until false ;
19217: LD_INT 0
19219: IFFALSE 19097
// end ; end_of_file
19221: PPOPN 2
19223: END
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
19224: LD_INT 0
19226: PPUSH
19227: PPUSH
// if exist_mode then
19228: LD_VAR 0 2
19232: IFFALSE 19257
// unit := CreateCharacter ( prefix & ident ) else
19234: LD_ADDR_VAR 0 5
19238: PUSH
19239: LD_VAR 0 3
19243: PUSH
19244: LD_VAR 0 1
19248: STR
19249: PPUSH
19250: CALL_OW 34
19254: ST_TO_ADDR
19255: GO 19272
// unit := NewCharacter ( ident ) ;
19257: LD_ADDR_VAR 0 5
19261: PUSH
19262: LD_VAR 0 1
19266: PPUSH
19267: CALL_OW 25
19271: ST_TO_ADDR
// result := unit ;
19272: LD_ADDR_VAR 0 4
19276: PUSH
19277: LD_VAR 0 5
19281: ST_TO_ADDR
// end ;
19282: LD_VAR 0 4
19286: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
19287: LD_INT 0
19289: PPUSH
19290: PPUSH
// if not side or not nation then
19291: LD_VAR 0 1
19295: NOT
19296: PUSH
19297: LD_VAR 0 2
19301: NOT
19302: OR
19303: IFFALSE 19307
// exit ;
19305: GO 20075
// case nation of nation_american :
19307: LD_VAR 0 2
19311: PUSH
19312: LD_INT 1
19314: DOUBLE
19315: EQUAL
19316: IFTRUE 19320
19318: GO 19534
19320: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
19321: LD_ADDR_VAR 0 4
19325: PUSH
19326: LD_INT 35
19328: PUSH
19329: LD_INT 45
19331: PUSH
19332: LD_INT 46
19334: PUSH
19335: LD_INT 47
19337: PUSH
19338: LD_INT 82
19340: PUSH
19341: LD_INT 83
19343: PUSH
19344: LD_INT 84
19346: PUSH
19347: LD_INT 85
19349: PUSH
19350: LD_INT 86
19352: PUSH
19353: LD_INT 1
19355: PUSH
19356: LD_INT 2
19358: PUSH
19359: LD_INT 6
19361: PUSH
19362: LD_INT 15
19364: PUSH
19365: LD_INT 16
19367: PUSH
19368: LD_INT 7
19370: PUSH
19371: LD_INT 12
19373: PUSH
19374: LD_INT 13
19376: PUSH
19377: LD_INT 10
19379: PUSH
19380: LD_INT 14
19382: PUSH
19383: LD_INT 20
19385: PUSH
19386: LD_INT 21
19388: PUSH
19389: LD_INT 22
19391: PUSH
19392: LD_INT 25
19394: PUSH
19395: LD_INT 32
19397: PUSH
19398: LD_INT 27
19400: PUSH
19401: LD_INT 36
19403: PUSH
19404: LD_INT 69
19406: PUSH
19407: LD_INT 39
19409: PUSH
19410: LD_INT 34
19412: PUSH
19413: LD_INT 40
19415: PUSH
19416: LD_INT 48
19418: PUSH
19419: LD_INT 49
19421: PUSH
19422: LD_INT 50
19424: PUSH
19425: LD_INT 51
19427: PUSH
19428: LD_INT 52
19430: PUSH
19431: LD_INT 53
19433: PUSH
19434: LD_INT 54
19436: PUSH
19437: LD_INT 55
19439: PUSH
19440: LD_INT 56
19442: PUSH
19443: LD_INT 57
19445: PUSH
19446: LD_INT 58
19448: PUSH
19449: LD_INT 59
19451: PUSH
19452: LD_INT 60
19454: PUSH
19455: LD_INT 61
19457: PUSH
19458: LD_INT 62
19460: PUSH
19461: LD_INT 80
19463: PUSH
19464: LD_INT 82
19466: PUSH
19467: LD_INT 83
19469: PUSH
19470: LD_INT 84
19472: PUSH
19473: LD_INT 85
19475: PUSH
19476: LD_INT 86
19478: PUSH
19479: EMPTY
19480: LIST
19481: LIST
19482: LIST
19483: LIST
19484: LIST
19485: LIST
19486: LIST
19487: LIST
19488: LIST
19489: LIST
19490: LIST
19491: LIST
19492: LIST
19493: LIST
19494: LIST
19495: LIST
19496: LIST
19497: LIST
19498: LIST
19499: LIST
19500: LIST
19501: LIST
19502: LIST
19503: LIST
19504: LIST
19505: LIST
19506: LIST
19507: LIST
19508: LIST
19509: LIST
19510: LIST
19511: LIST
19512: LIST
19513: LIST
19514: LIST
19515: LIST
19516: LIST
19517: LIST
19518: LIST
19519: LIST
19520: LIST
19521: LIST
19522: LIST
19523: LIST
19524: LIST
19525: LIST
19526: LIST
19527: LIST
19528: LIST
19529: LIST
19530: LIST
19531: ST_TO_ADDR
19532: GO 19999
19534: LD_INT 2
19536: DOUBLE
19537: EQUAL
19538: IFTRUE 19542
19540: GO 19768
19542: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 ] ; nation_russian :
19543: LD_ADDR_VAR 0 4
19547: PUSH
19548: LD_INT 35
19550: PUSH
19551: LD_INT 45
19553: PUSH
19554: LD_INT 46
19556: PUSH
19557: LD_INT 47
19559: PUSH
19560: LD_INT 82
19562: PUSH
19563: LD_INT 83
19565: PUSH
19566: LD_INT 84
19568: PUSH
19569: LD_INT 85
19571: PUSH
19572: LD_INT 87
19574: PUSH
19575: LD_INT 70
19577: PUSH
19578: LD_INT 1
19580: PUSH
19581: LD_INT 11
19583: PUSH
19584: LD_INT 3
19586: PUSH
19587: LD_INT 4
19589: PUSH
19590: LD_INT 5
19592: PUSH
19593: LD_INT 6
19595: PUSH
19596: LD_INT 15
19598: PUSH
19599: LD_INT 18
19601: PUSH
19602: LD_INT 7
19604: PUSH
19605: LD_INT 17
19607: PUSH
19608: LD_INT 8
19610: PUSH
19611: LD_INT 20
19613: PUSH
19614: LD_INT 21
19616: PUSH
19617: LD_INT 22
19619: PUSH
19620: LD_INT 72
19622: PUSH
19623: LD_INT 26
19625: PUSH
19626: LD_INT 69
19628: PUSH
19629: LD_INT 39
19631: PUSH
19632: LD_INT 40
19634: PUSH
19635: LD_INT 41
19637: PUSH
19638: LD_INT 42
19640: PUSH
19641: LD_INT 43
19643: PUSH
19644: LD_INT 48
19646: PUSH
19647: LD_INT 49
19649: PUSH
19650: LD_INT 50
19652: PUSH
19653: LD_INT 51
19655: PUSH
19656: LD_INT 52
19658: PUSH
19659: LD_INT 53
19661: PUSH
19662: LD_INT 54
19664: PUSH
19665: LD_INT 55
19667: PUSH
19668: LD_INT 56
19670: PUSH
19671: LD_INT 60
19673: PUSH
19674: LD_INT 61
19676: PUSH
19677: LD_INT 62
19679: PUSH
19680: LD_INT 66
19682: PUSH
19683: LD_INT 67
19685: PUSH
19686: LD_INT 68
19688: PUSH
19689: LD_INT 81
19691: PUSH
19692: LD_INT 82
19694: PUSH
19695: LD_INT 83
19697: PUSH
19698: LD_INT 84
19700: PUSH
19701: LD_INT 85
19703: PUSH
19704: LD_INT 87
19706: PUSH
19707: LD_INT 88
19709: PUSH
19710: EMPTY
19711: LIST
19712: LIST
19713: LIST
19714: LIST
19715: LIST
19716: LIST
19717: LIST
19718: LIST
19719: LIST
19720: LIST
19721: LIST
19722: LIST
19723: LIST
19724: LIST
19725: LIST
19726: LIST
19727: LIST
19728: LIST
19729: LIST
19730: LIST
19731: LIST
19732: LIST
19733: LIST
19734: LIST
19735: LIST
19736: LIST
19737: LIST
19738: LIST
19739: LIST
19740: LIST
19741: LIST
19742: LIST
19743: LIST
19744: LIST
19745: LIST
19746: LIST
19747: LIST
19748: LIST
19749: LIST
19750: LIST
19751: LIST
19752: LIST
19753: LIST
19754: LIST
19755: LIST
19756: LIST
19757: LIST
19758: LIST
19759: LIST
19760: LIST
19761: LIST
19762: LIST
19763: LIST
19764: LIST
19765: ST_TO_ADDR
19766: GO 19999
19768: LD_INT 3
19770: DOUBLE
19771: EQUAL
19772: IFTRUE 19776
19774: GO 19998
19776: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
19777: LD_ADDR_VAR 0 4
19781: PUSH
19782: LD_INT 46
19784: PUSH
19785: LD_INT 47
19787: PUSH
19788: LD_INT 1
19790: PUSH
19791: LD_INT 2
19793: PUSH
19794: LD_INT 82
19796: PUSH
19797: LD_INT 83
19799: PUSH
19800: LD_INT 84
19802: PUSH
19803: LD_INT 85
19805: PUSH
19806: LD_INT 86
19808: PUSH
19809: LD_INT 11
19811: PUSH
19812: LD_INT 9
19814: PUSH
19815: LD_INT 20
19817: PUSH
19818: LD_INT 19
19820: PUSH
19821: LD_INT 21
19823: PUSH
19824: LD_INT 24
19826: PUSH
19827: LD_INT 22
19829: PUSH
19830: LD_INT 25
19832: PUSH
19833: LD_INT 28
19835: PUSH
19836: LD_INT 29
19838: PUSH
19839: LD_INT 30
19841: PUSH
19842: LD_INT 31
19844: PUSH
19845: LD_INT 37
19847: PUSH
19848: LD_INT 38
19850: PUSH
19851: LD_INT 32
19853: PUSH
19854: LD_INT 27
19856: PUSH
19857: LD_INT 33
19859: PUSH
19860: LD_INT 69
19862: PUSH
19863: LD_INT 39
19865: PUSH
19866: LD_INT 34
19868: PUSH
19869: LD_INT 40
19871: PUSH
19872: LD_INT 71
19874: PUSH
19875: LD_INT 23
19877: PUSH
19878: LD_INT 44
19880: PUSH
19881: LD_INT 48
19883: PUSH
19884: LD_INT 49
19886: PUSH
19887: LD_INT 50
19889: PUSH
19890: LD_INT 51
19892: PUSH
19893: LD_INT 52
19895: PUSH
19896: LD_INT 53
19898: PUSH
19899: LD_INT 54
19901: PUSH
19902: LD_INT 55
19904: PUSH
19905: LD_INT 56
19907: PUSH
19908: LD_INT 57
19910: PUSH
19911: LD_INT 58
19913: PUSH
19914: LD_INT 59
19916: PUSH
19917: LD_INT 63
19919: PUSH
19920: LD_INT 64
19922: PUSH
19923: LD_INT 65
19925: PUSH
19926: LD_INT 82
19928: PUSH
19929: LD_INT 83
19931: PUSH
19932: LD_INT 84
19934: PUSH
19935: LD_INT 85
19937: PUSH
19938: LD_INT 86
19940: PUSH
19941: EMPTY
19942: LIST
19943: LIST
19944: LIST
19945: LIST
19946: LIST
19947: LIST
19948: LIST
19949: LIST
19950: LIST
19951: LIST
19952: LIST
19953: LIST
19954: LIST
19955: LIST
19956: LIST
19957: LIST
19958: LIST
19959: LIST
19960: LIST
19961: LIST
19962: LIST
19963: LIST
19964: LIST
19965: LIST
19966: LIST
19967: LIST
19968: LIST
19969: LIST
19970: LIST
19971: LIST
19972: LIST
19973: LIST
19974: LIST
19975: LIST
19976: LIST
19977: LIST
19978: LIST
19979: LIST
19980: LIST
19981: LIST
19982: LIST
19983: LIST
19984: LIST
19985: LIST
19986: LIST
19987: LIST
19988: LIST
19989: LIST
19990: LIST
19991: LIST
19992: LIST
19993: LIST
19994: LIST
19995: ST_TO_ADDR
19996: GO 19999
19998: POP
// if state > - 1 and state < 3 then
19999: LD_VAR 0 3
20003: PUSH
20004: LD_INT 1
20006: NEG
20007: GREATER
20008: PUSH
20009: LD_VAR 0 3
20013: PUSH
20014: LD_INT 3
20016: LESS
20017: AND
20018: IFFALSE 20075
// for i in result do
20020: LD_ADDR_VAR 0 5
20024: PUSH
20025: LD_VAR 0 4
20029: PUSH
20030: FOR_IN
20031: IFFALSE 20073
// if GetTech ( i , side ) <> state then
20033: LD_VAR 0 5
20037: PPUSH
20038: LD_VAR 0 1
20042: PPUSH
20043: CALL_OW 321
20047: PUSH
20048: LD_VAR 0 3
20052: NONEQUAL
20053: IFFALSE 20071
// result := result diff i ;
20055: LD_ADDR_VAR 0 4
20059: PUSH
20060: LD_VAR 0 4
20064: PUSH
20065: LD_VAR 0 5
20069: DIFF
20070: ST_TO_ADDR
20071: GO 20030
20073: POP
20074: POP
// end ;
20075: LD_VAR 0 4
20079: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
20080: LD_INT 0
20082: PPUSH
20083: PPUSH
20084: PPUSH
// result := true ;
20085: LD_ADDR_VAR 0 3
20089: PUSH
20090: LD_INT 1
20092: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
20093: LD_ADDR_VAR 0 5
20097: PUSH
20098: LD_VAR 0 2
20102: PPUSH
20103: CALL_OW 480
20107: ST_TO_ADDR
// if not tmp then
20108: LD_VAR 0 5
20112: NOT
20113: IFFALSE 20117
// exit ;
20115: GO 20166
// for i in tmp do
20117: LD_ADDR_VAR 0 4
20121: PUSH
20122: LD_VAR 0 5
20126: PUSH
20127: FOR_IN
20128: IFFALSE 20164
// if GetTech ( i , side ) <> state_researched then
20130: LD_VAR 0 4
20134: PPUSH
20135: LD_VAR 0 1
20139: PPUSH
20140: CALL_OW 321
20144: PUSH
20145: LD_INT 2
20147: NONEQUAL
20148: IFFALSE 20162
// begin result := false ;
20150: LD_ADDR_VAR 0 3
20154: PUSH
20155: LD_INT 0
20157: ST_TO_ADDR
// exit ;
20158: POP
20159: POP
20160: GO 20166
// end ;
20162: GO 20127
20164: POP
20165: POP
// end ;
20166: LD_VAR 0 3
20170: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
20171: LD_INT 0
20173: PPUSH
20174: PPUSH
20175: PPUSH
20176: PPUSH
20177: PPUSH
20178: PPUSH
20179: PPUSH
20180: PPUSH
20181: PPUSH
20182: PPUSH
20183: PPUSH
20184: PPUSH
20185: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
20186: LD_VAR 0 1
20190: NOT
20191: PUSH
20192: LD_VAR 0 1
20196: PPUSH
20197: CALL_OW 257
20201: PUSH
20202: LD_INT 9
20204: NONEQUAL
20205: OR
20206: IFFALSE 20210
// exit ;
20208: GO 20783
// side := GetSide ( unit ) ;
20210: LD_ADDR_VAR 0 9
20214: PUSH
20215: LD_VAR 0 1
20219: PPUSH
20220: CALL_OW 255
20224: ST_TO_ADDR
// tech_space := tech_spacanom ;
20225: LD_ADDR_VAR 0 12
20229: PUSH
20230: LD_INT 29
20232: ST_TO_ADDR
// tech_time := tech_taurad ;
20233: LD_ADDR_VAR 0 13
20237: PUSH
20238: LD_INT 28
20240: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
20241: LD_ADDR_VAR 0 11
20245: PUSH
20246: LD_VAR 0 1
20250: PPUSH
20251: CALL_OW 310
20255: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
20256: LD_VAR 0 11
20260: PPUSH
20261: CALL_OW 247
20265: PUSH
20266: LD_INT 2
20268: EQUAL
20269: IFFALSE 20273
// exit ;
20271: GO 20783
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
20273: LD_ADDR_VAR 0 8
20277: PUSH
20278: LD_INT 81
20280: PUSH
20281: LD_VAR 0 9
20285: PUSH
20286: EMPTY
20287: LIST
20288: LIST
20289: PUSH
20290: LD_INT 3
20292: PUSH
20293: LD_INT 21
20295: PUSH
20296: LD_INT 3
20298: PUSH
20299: EMPTY
20300: LIST
20301: LIST
20302: PUSH
20303: EMPTY
20304: LIST
20305: LIST
20306: PUSH
20307: EMPTY
20308: LIST
20309: LIST
20310: PPUSH
20311: CALL_OW 69
20315: ST_TO_ADDR
// if not tmp then
20316: LD_VAR 0 8
20320: NOT
20321: IFFALSE 20325
// exit ;
20323: GO 20783
// if in_unit then
20325: LD_VAR 0 11
20329: IFFALSE 20353
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
20331: LD_ADDR_VAR 0 10
20335: PUSH
20336: LD_VAR 0 8
20340: PPUSH
20341: LD_VAR 0 11
20345: PPUSH
20346: CALL_OW 74
20350: ST_TO_ADDR
20351: GO 20373
// enemy := NearestUnitToUnit ( tmp , unit ) ;
20353: LD_ADDR_VAR 0 10
20357: PUSH
20358: LD_VAR 0 8
20362: PPUSH
20363: LD_VAR 0 1
20367: PPUSH
20368: CALL_OW 74
20372: ST_TO_ADDR
// if not enemy then
20373: LD_VAR 0 10
20377: NOT
20378: IFFALSE 20382
// exit ;
20380: GO 20783
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
20382: LD_VAR 0 11
20386: PUSH
20387: LD_VAR 0 11
20391: PPUSH
20392: LD_VAR 0 10
20396: PPUSH
20397: CALL_OW 296
20401: PUSH
20402: LD_INT 13
20404: GREATER
20405: AND
20406: PUSH
20407: LD_VAR 0 1
20411: PPUSH
20412: LD_VAR 0 10
20416: PPUSH
20417: CALL_OW 296
20421: PUSH
20422: LD_INT 12
20424: GREATER
20425: OR
20426: IFFALSE 20430
// exit ;
20428: GO 20783
// missile := [ 1 ] ;
20430: LD_ADDR_VAR 0 14
20434: PUSH
20435: LD_INT 1
20437: PUSH
20438: EMPTY
20439: LIST
20440: ST_TO_ADDR
// if Researched ( side , tech_space ) then
20441: LD_VAR 0 9
20445: PPUSH
20446: LD_VAR 0 12
20450: PPUSH
20451: CALL_OW 325
20455: IFFALSE 20484
// missile := Replace ( missile , missile + 1 , 2 ) ;
20457: LD_ADDR_VAR 0 14
20461: PUSH
20462: LD_VAR 0 14
20466: PPUSH
20467: LD_VAR 0 14
20471: PUSH
20472: LD_INT 1
20474: PLUS
20475: PPUSH
20476: LD_INT 2
20478: PPUSH
20479: CALL_OW 1
20483: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
20484: LD_VAR 0 9
20488: PPUSH
20489: LD_VAR 0 13
20493: PPUSH
20494: CALL_OW 325
20498: PUSH
20499: LD_VAR 0 10
20503: PPUSH
20504: CALL_OW 255
20508: PPUSH
20509: LD_VAR 0 13
20513: PPUSH
20514: CALL_OW 325
20518: NOT
20519: AND
20520: IFFALSE 20549
// missile := Replace ( missile , missile + 1 , 3 ) ;
20522: LD_ADDR_VAR 0 14
20526: PUSH
20527: LD_VAR 0 14
20531: PPUSH
20532: LD_VAR 0 14
20536: PUSH
20537: LD_INT 1
20539: PLUS
20540: PPUSH
20541: LD_INT 3
20543: PPUSH
20544: CALL_OW 1
20548: ST_TO_ADDR
// if missile < 2 then
20549: LD_VAR 0 14
20553: PUSH
20554: LD_INT 2
20556: LESS
20557: IFFALSE 20561
// exit ;
20559: GO 20783
// x := GetX ( enemy ) ;
20561: LD_ADDR_VAR 0 4
20565: PUSH
20566: LD_VAR 0 10
20570: PPUSH
20571: CALL_OW 250
20575: ST_TO_ADDR
// y := GetY ( enemy ) ;
20576: LD_ADDR_VAR 0 5
20580: PUSH
20581: LD_VAR 0 10
20585: PPUSH
20586: CALL_OW 251
20590: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
20591: LD_ADDR_VAR 0 6
20595: PUSH
20596: LD_VAR 0 4
20600: PUSH
20601: LD_INT 1
20603: NEG
20604: PPUSH
20605: LD_INT 1
20607: PPUSH
20608: CALL_OW 12
20612: PLUS
20613: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
20614: LD_ADDR_VAR 0 7
20618: PUSH
20619: LD_VAR 0 5
20623: PUSH
20624: LD_INT 1
20626: NEG
20627: PPUSH
20628: LD_INT 1
20630: PPUSH
20631: CALL_OW 12
20635: PLUS
20636: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
20637: LD_VAR 0 6
20641: PPUSH
20642: LD_VAR 0 7
20646: PPUSH
20647: CALL_OW 488
20651: NOT
20652: IFFALSE 20674
// begin _x := x ;
20654: LD_ADDR_VAR 0 6
20658: PUSH
20659: LD_VAR 0 4
20663: ST_TO_ADDR
// _y := y ;
20664: LD_ADDR_VAR 0 7
20668: PUSH
20669: LD_VAR 0 5
20673: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
20674: LD_ADDR_VAR 0 3
20678: PUSH
20679: LD_INT 1
20681: PPUSH
20682: LD_VAR 0 14
20686: PPUSH
20687: CALL_OW 12
20691: ST_TO_ADDR
// case i of 1 :
20692: LD_VAR 0 3
20696: PUSH
20697: LD_INT 1
20699: DOUBLE
20700: EQUAL
20701: IFTRUE 20705
20703: GO 20722
20705: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
20706: LD_VAR 0 1
20710: PPUSH
20711: LD_VAR 0 10
20715: PPUSH
20716: CALL_OW 115
20720: GO 20783
20722: LD_INT 2
20724: DOUBLE
20725: EQUAL
20726: IFTRUE 20730
20728: GO 20752
20730: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
20731: LD_VAR 0 1
20735: PPUSH
20736: LD_VAR 0 6
20740: PPUSH
20741: LD_VAR 0 7
20745: PPUSH
20746: CALL_OW 153
20750: GO 20783
20752: LD_INT 3
20754: DOUBLE
20755: EQUAL
20756: IFTRUE 20760
20758: GO 20782
20760: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
20761: LD_VAR 0 1
20765: PPUSH
20766: LD_VAR 0 6
20770: PPUSH
20771: LD_VAR 0 7
20775: PPUSH
20776: CALL_OW 154
20780: GO 20783
20782: POP
// end ;
20783: LD_VAR 0 2
20787: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
20788: LD_INT 0
20790: PPUSH
20791: PPUSH
20792: PPUSH
20793: PPUSH
20794: PPUSH
20795: PPUSH
// if not unit or not building then
20796: LD_VAR 0 1
20800: NOT
20801: PUSH
20802: LD_VAR 0 2
20806: NOT
20807: OR
20808: IFFALSE 20812
// exit ;
20810: GO 20970
// x := GetX ( building ) ;
20812: LD_ADDR_VAR 0 5
20816: PUSH
20817: LD_VAR 0 2
20821: PPUSH
20822: CALL_OW 250
20826: ST_TO_ADDR
// y := GetY ( building ) ;
20827: LD_ADDR_VAR 0 6
20831: PUSH
20832: LD_VAR 0 2
20836: PPUSH
20837: CALL_OW 251
20841: ST_TO_ADDR
// for i = 0 to 5 do
20842: LD_ADDR_VAR 0 4
20846: PUSH
20847: DOUBLE
20848: LD_INT 0
20850: DEC
20851: ST_TO_ADDR
20852: LD_INT 5
20854: PUSH
20855: FOR_TO
20856: IFFALSE 20968
// begin _x := ShiftX ( x , i , 3 ) ;
20858: LD_ADDR_VAR 0 7
20862: PUSH
20863: LD_VAR 0 5
20867: PPUSH
20868: LD_VAR 0 4
20872: PPUSH
20873: LD_INT 3
20875: PPUSH
20876: CALL_OW 272
20880: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
20881: LD_ADDR_VAR 0 8
20885: PUSH
20886: LD_VAR 0 6
20890: PPUSH
20891: LD_VAR 0 4
20895: PPUSH
20896: LD_INT 3
20898: PPUSH
20899: CALL_OW 273
20903: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
20904: LD_VAR 0 7
20908: PPUSH
20909: LD_VAR 0 8
20913: PPUSH
20914: CALL_OW 488
20918: NOT
20919: IFFALSE 20923
// continue ;
20921: GO 20855
// if HexInfo ( _x , _y ) = 0 then
20923: LD_VAR 0 7
20927: PPUSH
20928: LD_VAR 0 8
20932: PPUSH
20933: CALL_OW 428
20937: PUSH
20938: LD_INT 0
20940: EQUAL
20941: IFFALSE 20966
// begin ComMoveXY ( unit , _x , _y ) ;
20943: LD_VAR 0 1
20947: PPUSH
20948: LD_VAR 0 7
20952: PPUSH
20953: LD_VAR 0 8
20957: PPUSH
20958: CALL_OW 111
// exit ;
20962: POP
20963: POP
20964: GO 20970
// end ; end ;
20966: GO 20855
20968: POP
20969: POP
// end ;
20970: LD_VAR 0 3
20974: RET
// export function ScanBase ( side , base_area ) ; begin
20975: LD_INT 0
20977: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
20978: LD_ADDR_VAR 0 3
20982: PUSH
20983: LD_VAR 0 2
20987: PPUSH
20988: LD_INT 81
20990: PUSH
20991: LD_VAR 0 1
20995: PUSH
20996: EMPTY
20997: LIST
20998: LIST
20999: PPUSH
21000: CALL_OW 70
21004: ST_TO_ADDR
// end ;
21005: LD_VAR 0 3
21009: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
21010: LD_INT 0
21012: PPUSH
21013: PPUSH
21014: PPUSH
21015: PPUSH
// result := false ;
21016: LD_ADDR_VAR 0 2
21020: PUSH
21021: LD_INT 0
21023: ST_TO_ADDR
// side := GetSide ( unit ) ;
21024: LD_ADDR_VAR 0 3
21028: PUSH
21029: LD_VAR 0 1
21033: PPUSH
21034: CALL_OW 255
21038: ST_TO_ADDR
// nat := GetNation ( unit ) ;
21039: LD_ADDR_VAR 0 4
21043: PUSH
21044: LD_VAR 0 1
21048: PPUSH
21049: CALL_OW 248
21053: ST_TO_ADDR
// case nat of 1 :
21054: LD_VAR 0 4
21058: PUSH
21059: LD_INT 1
21061: DOUBLE
21062: EQUAL
21063: IFTRUE 21067
21065: GO 21078
21067: POP
// tech := tech_lassight ; 2 :
21068: LD_ADDR_VAR 0 5
21072: PUSH
21073: LD_INT 12
21075: ST_TO_ADDR
21076: GO 21117
21078: LD_INT 2
21080: DOUBLE
21081: EQUAL
21082: IFTRUE 21086
21084: GO 21097
21086: POP
// tech := tech_mortar ; 3 :
21087: LD_ADDR_VAR 0 5
21091: PUSH
21092: LD_INT 41
21094: ST_TO_ADDR
21095: GO 21117
21097: LD_INT 3
21099: DOUBLE
21100: EQUAL
21101: IFTRUE 21105
21103: GO 21116
21105: POP
// tech := tech_bazooka ; end ;
21106: LD_ADDR_VAR 0 5
21110: PUSH
21111: LD_INT 44
21113: ST_TO_ADDR
21114: GO 21117
21116: POP
// if Researched ( side , tech ) then
21117: LD_VAR 0 3
21121: PPUSH
21122: LD_VAR 0 5
21126: PPUSH
21127: CALL_OW 325
21131: IFFALSE 21158
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
21133: LD_ADDR_VAR 0 2
21137: PUSH
21138: LD_INT 5
21140: PUSH
21141: LD_INT 8
21143: PUSH
21144: LD_INT 9
21146: PUSH
21147: EMPTY
21148: LIST
21149: LIST
21150: LIST
21151: PUSH
21152: LD_VAR 0 4
21156: ARRAY
21157: ST_TO_ADDR
// end ;
21158: LD_VAR 0 2
21162: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
21163: LD_INT 0
21165: PPUSH
21166: PPUSH
21167: PPUSH
// if not mines then
21168: LD_VAR 0 2
21172: NOT
21173: IFFALSE 21177
// exit ;
21175: GO 21321
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
21177: LD_ADDR_VAR 0 5
21181: PUSH
21182: LD_INT 81
21184: PUSH
21185: LD_VAR 0 1
21189: PUSH
21190: EMPTY
21191: LIST
21192: LIST
21193: PUSH
21194: LD_INT 3
21196: PUSH
21197: LD_INT 21
21199: PUSH
21200: LD_INT 3
21202: PUSH
21203: EMPTY
21204: LIST
21205: LIST
21206: PUSH
21207: EMPTY
21208: LIST
21209: LIST
21210: PUSH
21211: EMPTY
21212: LIST
21213: LIST
21214: PPUSH
21215: CALL_OW 69
21219: ST_TO_ADDR
// for i in mines do
21220: LD_ADDR_VAR 0 4
21224: PUSH
21225: LD_VAR 0 2
21229: PUSH
21230: FOR_IN
21231: IFFALSE 21319
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
21233: LD_VAR 0 4
21237: PUSH
21238: LD_INT 1
21240: ARRAY
21241: PPUSH
21242: LD_VAR 0 4
21246: PUSH
21247: LD_INT 2
21249: ARRAY
21250: PPUSH
21251: CALL_OW 458
21255: NOT
21256: IFFALSE 21260
// continue ;
21258: GO 21230
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
21260: LD_VAR 0 4
21264: PUSH
21265: LD_INT 1
21267: ARRAY
21268: PPUSH
21269: LD_VAR 0 4
21273: PUSH
21274: LD_INT 2
21276: ARRAY
21277: PPUSH
21278: CALL_OW 428
21282: PUSH
21283: LD_VAR 0 5
21287: IN
21288: IFFALSE 21317
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
21290: LD_VAR 0 4
21294: PUSH
21295: LD_INT 1
21297: ARRAY
21298: PPUSH
21299: LD_VAR 0 4
21303: PUSH
21304: LD_INT 2
21306: ARRAY
21307: PPUSH
21308: LD_VAR 0 1
21312: PPUSH
21313: CALL_OW 456
// end ;
21317: GO 21230
21319: POP
21320: POP
// end ;
21321: LD_VAR 0 3
21325: RET
// export function Count ( array ) ; var i ; begin
21326: LD_INT 0
21328: PPUSH
21329: PPUSH
// result := 0 ;
21330: LD_ADDR_VAR 0 2
21334: PUSH
21335: LD_INT 0
21337: ST_TO_ADDR
// for i in array do
21338: LD_ADDR_VAR 0 3
21342: PUSH
21343: LD_VAR 0 1
21347: PUSH
21348: FOR_IN
21349: IFFALSE 21373
// if i then
21351: LD_VAR 0 3
21355: IFFALSE 21371
// result := result + 1 ;
21357: LD_ADDR_VAR 0 2
21361: PUSH
21362: LD_VAR 0 2
21366: PUSH
21367: LD_INT 1
21369: PLUS
21370: ST_TO_ADDR
21371: GO 21348
21373: POP
21374: POP
// end ;
21375: LD_VAR 0 2
21379: RET
// export function IsEmpty ( building ) ; begin
21380: LD_INT 0
21382: PPUSH
// if not building then
21383: LD_VAR 0 1
21387: NOT
21388: IFFALSE 21392
// exit ;
21390: GO 21435
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
21392: LD_ADDR_VAR 0 2
21396: PUSH
21397: LD_VAR 0 1
21401: PUSH
21402: LD_INT 22
21404: PUSH
21405: LD_VAR 0 1
21409: PPUSH
21410: CALL_OW 255
21414: PUSH
21415: EMPTY
21416: LIST
21417: LIST
21418: PUSH
21419: LD_INT 58
21421: PUSH
21422: EMPTY
21423: LIST
21424: PUSH
21425: EMPTY
21426: LIST
21427: LIST
21428: PPUSH
21429: CALL_OW 69
21433: IN
21434: ST_TO_ADDR
// end ;
21435: LD_VAR 0 2
21439: RET
// export function IsNotFull ( building ) ; var places ; begin
21440: LD_INT 0
21442: PPUSH
21443: PPUSH
// if not building then
21444: LD_VAR 0 1
21448: NOT
21449: IFFALSE 21453
// exit ;
21451: GO 21624
// result := false ;
21453: LD_ADDR_VAR 0 2
21457: PUSH
21458: LD_INT 0
21460: ST_TO_ADDR
// places := 0 ;
21461: LD_ADDR_VAR 0 3
21465: PUSH
21466: LD_INT 0
21468: ST_TO_ADDR
// case GetBType ( building ) of b_depot , b_warehouse , b_lab , b_lab_half , b_lab_full , b_armoury , b_barracks , b_workshop , b_factory , b_fort :
21469: LD_VAR 0 1
21473: PPUSH
21474: CALL_OW 266
21478: PUSH
21479: LD_INT 0
21481: DOUBLE
21482: EQUAL
21483: IFTRUE 21541
21485: LD_INT 1
21487: DOUBLE
21488: EQUAL
21489: IFTRUE 21541
21491: LD_INT 6
21493: DOUBLE
21494: EQUAL
21495: IFTRUE 21541
21497: LD_INT 7
21499: DOUBLE
21500: EQUAL
21501: IFTRUE 21541
21503: LD_INT 8
21505: DOUBLE
21506: EQUAL
21507: IFTRUE 21541
21509: LD_INT 4
21511: DOUBLE
21512: EQUAL
21513: IFTRUE 21541
21515: LD_INT 5
21517: DOUBLE
21518: EQUAL
21519: IFTRUE 21541
21521: LD_INT 2
21523: DOUBLE
21524: EQUAL
21525: IFTRUE 21541
21527: LD_INT 3
21529: DOUBLE
21530: EQUAL
21531: IFTRUE 21541
21533: LD_INT 35
21535: DOUBLE
21536: EQUAL
21537: IFTRUE 21541
21539: GO 21552
21541: POP
// places := 6 ; b_bunker , b_breastwork :
21542: LD_ADDR_VAR 0 3
21546: PUSH
21547: LD_INT 6
21549: ST_TO_ADDR
21550: GO 21597
21552: LD_INT 32
21554: DOUBLE
21555: EQUAL
21556: IFTRUE 21566
21558: LD_INT 31
21560: DOUBLE
21561: EQUAL
21562: IFTRUE 21566
21564: GO 21577
21566: POP
// places := 1 ; b_control_tower :
21567: LD_ADDR_VAR 0 3
21571: PUSH
21572: LD_INT 1
21574: ST_TO_ADDR
21575: GO 21597
21577: LD_INT 36
21579: DOUBLE
21580: EQUAL
21581: IFTRUE 21585
21583: GO 21596
21585: POP
// places := 3 ; end ;
21586: LD_ADDR_VAR 0 3
21590: PUSH
21591: LD_INT 3
21593: ST_TO_ADDR
21594: GO 21597
21596: POP
// if places then
21597: LD_VAR 0 3
21601: IFFALSE 21624
// result := UnitsInside ( building ) < places ;
21603: LD_ADDR_VAR 0 2
21607: PUSH
21608: LD_VAR 0 1
21612: PPUSH
21613: CALL_OW 313
21617: PUSH
21618: LD_VAR 0 3
21622: LESS
21623: ST_TO_ADDR
// end ;
21624: LD_VAR 0 2
21628: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
21629: LD_INT 0
21631: PPUSH
21632: PPUSH
21633: PPUSH
21634: PPUSH
// tmp := [ ] ;
21635: LD_ADDR_VAR 0 3
21639: PUSH
21640: EMPTY
21641: ST_TO_ADDR
// list := [ ] ;
21642: LD_ADDR_VAR 0 5
21646: PUSH
21647: EMPTY
21648: ST_TO_ADDR
// for i = 16 to 25 do
21649: LD_ADDR_VAR 0 4
21653: PUSH
21654: DOUBLE
21655: LD_INT 16
21657: DEC
21658: ST_TO_ADDR
21659: LD_INT 25
21661: PUSH
21662: FOR_TO
21663: IFFALSE 21736
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
21665: LD_ADDR_VAR 0 3
21669: PUSH
21670: LD_VAR 0 3
21674: PUSH
21675: LD_INT 22
21677: PUSH
21678: LD_VAR 0 1
21682: PPUSH
21683: CALL_OW 255
21687: PUSH
21688: EMPTY
21689: LIST
21690: LIST
21691: PUSH
21692: LD_INT 91
21694: PUSH
21695: LD_VAR 0 1
21699: PUSH
21700: LD_INT 6
21702: PUSH
21703: EMPTY
21704: LIST
21705: LIST
21706: LIST
21707: PUSH
21708: LD_INT 30
21710: PUSH
21711: LD_VAR 0 4
21715: PUSH
21716: EMPTY
21717: LIST
21718: LIST
21719: PUSH
21720: EMPTY
21721: LIST
21722: LIST
21723: LIST
21724: PUSH
21725: EMPTY
21726: LIST
21727: PPUSH
21728: CALL_OW 69
21732: ADD
21733: ST_TO_ADDR
21734: GO 21662
21736: POP
21737: POP
// for i = 1 to tmp do
21738: LD_ADDR_VAR 0 4
21742: PUSH
21743: DOUBLE
21744: LD_INT 1
21746: DEC
21747: ST_TO_ADDR
21748: LD_VAR 0 3
21752: PUSH
21753: FOR_TO
21754: IFFALSE 21842
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
21756: LD_ADDR_VAR 0 5
21760: PUSH
21761: LD_VAR 0 5
21765: PUSH
21766: LD_VAR 0 3
21770: PUSH
21771: LD_VAR 0 4
21775: ARRAY
21776: PPUSH
21777: CALL_OW 266
21781: PUSH
21782: LD_VAR 0 3
21786: PUSH
21787: LD_VAR 0 4
21791: ARRAY
21792: PPUSH
21793: CALL_OW 250
21797: PUSH
21798: LD_VAR 0 3
21802: PUSH
21803: LD_VAR 0 4
21807: ARRAY
21808: PPUSH
21809: CALL_OW 251
21813: PUSH
21814: LD_VAR 0 3
21818: PUSH
21819: LD_VAR 0 4
21823: ARRAY
21824: PPUSH
21825: CALL_OW 254
21829: PUSH
21830: EMPTY
21831: LIST
21832: LIST
21833: LIST
21834: LIST
21835: PUSH
21836: EMPTY
21837: LIST
21838: ADD
21839: ST_TO_ADDR
21840: GO 21753
21842: POP
21843: POP
// result := list ;
21844: LD_ADDR_VAR 0 2
21848: PUSH
21849: LD_VAR 0 5
21853: ST_TO_ADDR
// end ;
21854: LD_VAR 0 2
21858: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
21859: LD_INT 0
21861: PPUSH
21862: PPUSH
21863: PPUSH
21864: PPUSH
21865: PPUSH
21866: PPUSH
21867: PPUSH
// if not factory then
21868: LD_VAR 0 1
21872: NOT
21873: IFFALSE 21877
// exit ;
21875: GO 22470
// if control = control_apeman then
21877: LD_VAR 0 4
21881: PUSH
21882: LD_INT 5
21884: EQUAL
21885: IFFALSE 21994
// begin tmp := UnitsInside ( factory ) ;
21887: LD_ADDR_VAR 0 8
21891: PUSH
21892: LD_VAR 0 1
21896: PPUSH
21897: CALL_OW 313
21901: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
21902: LD_VAR 0 8
21906: PPUSH
21907: LD_INT 25
21909: PUSH
21910: LD_INT 12
21912: PUSH
21913: EMPTY
21914: LIST
21915: LIST
21916: PPUSH
21917: CALL_OW 72
21921: NOT
21922: IFFALSE 21932
// control := control_manual ;
21924: LD_ADDR_VAR 0 4
21928: PUSH
21929: LD_INT 1
21931: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
21932: LD_ADDR_VAR 0 8
21936: PUSH
21937: LD_VAR 0 1
21941: PPUSH
21942: CALL 21629 0 1
21946: ST_TO_ADDR
// if tmp then
21947: LD_VAR 0 8
21951: IFFALSE 21994
// begin for i in tmp do
21953: LD_ADDR_VAR 0 7
21957: PUSH
21958: LD_VAR 0 8
21962: PUSH
21963: FOR_IN
21964: IFFALSE 21992
// if i [ 1 ] = b_ext_radio then
21966: LD_VAR 0 7
21970: PUSH
21971: LD_INT 1
21973: ARRAY
21974: PUSH
21975: LD_INT 22
21977: EQUAL
21978: IFFALSE 21990
// begin control := control_remote ;
21980: LD_ADDR_VAR 0 4
21984: PUSH
21985: LD_INT 2
21987: ST_TO_ADDR
// break ;
21988: GO 21992
// end ;
21990: GO 21963
21992: POP
21993: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
21994: LD_VAR 0 1
21998: PPUSH
21999: LD_VAR 0 2
22003: PPUSH
22004: LD_VAR 0 3
22008: PPUSH
22009: LD_VAR 0 4
22013: PPUSH
22014: LD_VAR 0 5
22018: PPUSH
22019: CALL_OW 448
22023: IFFALSE 22058
// begin result := [ chassis , engine , control , weapon ] ;
22025: LD_ADDR_VAR 0 6
22029: PUSH
22030: LD_VAR 0 2
22034: PUSH
22035: LD_VAR 0 3
22039: PUSH
22040: LD_VAR 0 4
22044: PUSH
22045: LD_VAR 0 5
22049: PUSH
22050: EMPTY
22051: LIST
22052: LIST
22053: LIST
22054: LIST
22055: ST_TO_ADDR
// exit ;
22056: GO 22470
// end ; _chassis := AvailableChassisList ( factory ) ;
22058: LD_ADDR_VAR 0 9
22062: PUSH
22063: LD_VAR 0 1
22067: PPUSH
22068: CALL_OW 475
22072: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
22073: LD_ADDR_VAR 0 11
22077: PUSH
22078: LD_VAR 0 1
22082: PPUSH
22083: CALL_OW 476
22087: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
22088: LD_ADDR_VAR 0 12
22092: PUSH
22093: LD_VAR 0 1
22097: PPUSH
22098: CALL_OW 477
22102: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
22103: LD_ADDR_VAR 0 10
22107: PUSH
22108: LD_VAR 0 1
22112: PPUSH
22113: CALL_OW 478
22117: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
22118: LD_VAR 0 9
22122: NOT
22123: PUSH
22124: LD_VAR 0 11
22128: NOT
22129: OR
22130: PUSH
22131: LD_VAR 0 12
22135: NOT
22136: OR
22137: PUSH
22138: LD_VAR 0 10
22142: NOT
22143: OR
22144: IFFALSE 22179
// begin result := [ chassis , engine , control , weapon ] ;
22146: LD_ADDR_VAR 0 6
22150: PUSH
22151: LD_VAR 0 2
22155: PUSH
22156: LD_VAR 0 3
22160: PUSH
22161: LD_VAR 0 4
22165: PUSH
22166: LD_VAR 0 5
22170: PUSH
22171: EMPTY
22172: LIST
22173: LIST
22174: LIST
22175: LIST
22176: ST_TO_ADDR
// exit ;
22177: GO 22470
// end ; if not chassis in _chassis then
22179: LD_VAR 0 2
22183: PUSH
22184: LD_VAR 0 9
22188: IN
22189: NOT
22190: IFFALSE 22216
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
22192: LD_ADDR_VAR 0 2
22196: PUSH
22197: LD_VAR 0 9
22201: PUSH
22202: LD_INT 1
22204: PPUSH
22205: LD_VAR 0 9
22209: PPUSH
22210: CALL_OW 12
22214: ARRAY
22215: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
22216: LD_VAR 0 2
22220: PPUSH
22221: LD_VAR 0 3
22225: PPUSH
22226: CALL 22475 0 2
22230: NOT
22231: IFFALSE 22290
// repeat engine := _engine [ 1 ] ;
22233: LD_ADDR_VAR 0 3
22237: PUSH
22238: LD_VAR 0 11
22242: PUSH
22243: LD_INT 1
22245: ARRAY
22246: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
22247: LD_ADDR_VAR 0 11
22251: PUSH
22252: LD_VAR 0 11
22256: PPUSH
22257: LD_INT 1
22259: PPUSH
22260: CALL_OW 3
22264: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
22265: LD_VAR 0 2
22269: PPUSH
22270: LD_VAR 0 3
22274: PPUSH
22275: CALL 22475 0 2
22279: PUSH
22280: LD_VAR 0 11
22284: PUSH
22285: EMPTY
22286: EQUAL
22287: OR
22288: IFFALSE 22233
// if not control in _control then
22290: LD_VAR 0 4
22294: PUSH
22295: LD_VAR 0 12
22299: IN
22300: NOT
22301: IFFALSE 22327
// control := _control [ rand ( 1 , _control ) ] ;
22303: LD_ADDR_VAR 0 4
22307: PUSH
22308: LD_VAR 0 12
22312: PUSH
22313: LD_INT 1
22315: PPUSH
22316: LD_VAR 0 12
22320: PPUSH
22321: CALL_OW 12
22325: ARRAY
22326: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
22327: LD_VAR 0 2
22331: PPUSH
22332: LD_VAR 0 5
22336: PPUSH
22337: CALL 22695 0 2
22341: NOT
22342: IFFALSE 22401
// repeat weapon := _weapon [ 1 ] ;
22344: LD_ADDR_VAR 0 5
22348: PUSH
22349: LD_VAR 0 10
22353: PUSH
22354: LD_INT 1
22356: ARRAY
22357: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
22358: LD_ADDR_VAR 0 10
22362: PUSH
22363: LD_VAR 0 10
22367: PPUSH
22368: LD_INT 1
22370: PPUSH
22371: CALL_OW 3
22375: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
22376: LD_VAR 0 2
22380: PPUSH
22381: LD_VAR 0 5
22385: PPUSH
22386: CALL 22695 0 2
22390: PUSH
22391: LD_VAR 0 10
22395: PUSH
22396: EMPTY
22397: EQUAL
22398: OR
22399: IFFALSE 22344
// result := [ ] ;
22401: LD_ADDR_VAR 0 6
22405: PUSH
22406: EMPTY
22407: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
22408: LD_VAR 0 1
22412: PPUSH
22413: LD_VAR 0 2
22417: PPUSH
22418: LD_VAR 0 3
22422: PPUSH
22423: LD_VAR 0 4
22427: PPUSH
22428: LD_VAR 0 5
22432: PPUSH
22433: CALL_OW 448
22437: IFFALSE 22470
// result := [ chassis , engine , control , weapon ] ;
22439: LD_ADDR_VAR 0 6
22443: PUSH
22444: LD_VAR 0 2
22448: PUSH
22449: LD_VAR 0 3
22453: PUSH
22454: LD_VAR 0 4
22458: PUSH
22459: LD_VAR 0 5
22463: PUSH
22464: EMPTY
22465: LIST
22466: LIST
22467: LIST
22468: LIST
22469: ST_TO_ADDR
// end ;
22470: LD_VAR 0 6
22474: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
22475: LD_INT 0
22477: PPUSH
// if not chassis or not engine then
22478: LD_VAR 0 1
22482: NOT
22483: PUSH
22484: LD_VAR 0 2
22488: NOT
22489: OR
22490: IFFALSE 22494
// exit ;
22492: GO 22690
// case engine of engine_solar :
22494: LD_VAR 0 2
22498: PUSH
22499: LD_INT 2
22501: DOUBLE
22502: EQUAL
22503: IFTRUE 22507
22505: GO 22545
22507: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
22508: LD_ADDR_VAR 0 3
22512: PUSH
22513: LD_INT 11
22515: PUSH
22516: LD_INT 12
22518: PUSH
22519: LD_INT 13
22521: PUSH
22522: LD_INT 14
22524: PUSH
22525: LD_INT 1
22527: PUSH
22528: LD_INT 2
22530: PUSH
22531: LD_INT 3
22533: PUSH
22534: EMPTY
22535: LIST
22536: LIST
22537: LIST
22538: LIST
22539: LIST
22540: LIST
22541: LIST
22542: ST_TO_ADDR
22543: GO 22674
22545: LD_INT 1
22547: DOUBLE
22548: EQUAL
22549: IFTRUE 22553
22551: GO 22615
22553: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
22554: LD_ADDR_VAR 0 3
22558: PUSH
22559: LD_INT 11
22561: PUSH
22562: LD_INT 12
22564: PUSH
22565: LD_INT 13
22567: PUSH
22568: LD_INT 14
22570: PUSH
22571: LD_INT 1
22573: PUSH
22574: LD_INT 2
22576: PUSH
22577: LD_INT 3
22579: PUSH
22580: LD_INT 4
22582: PUSH
22583: LD_INT 5
22585: PUSH
22586: LD_INT 21
22588: PUSH
22589: LD_INT 23
22591: PUSH
22592: LD_INT 22
22594: PUSH
22595: LD_INT 24
22597: PUSH
22598: EMPTY
22599: LIST
22600: LIST
22601: LIST
22602: LIST
22603: LIST
22604: LIST
22605: LIST
22606: LIST
22607: LIST
22608: LIST
22609: LIST
22610: LIST
22611: LIST
22612: ST_TO_ADDR
22613: GO 22674
22615: LD_INT 3
22617: DOUBLE
22618: EQUAL
22619: IFTRUE 22623
22621: GO 22673
22623: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
22624: LD_ADDR_VAR 0 3
22628: PUSH
22629: LD_INT 13
22631: PUSH
22632: LD_INT 14
22634: PUSH
22635: LD_INT 2
22637: PUSH
22638: LD_INT 3
22640: PUSH
22641: LD_INT 4
22643: PUSH
22644: LD_INT 5
22646: PUSH
22647: LD_INT 21
22649: PUSH
22650: LD_INT 22
22652: PUSH
22653: LD_INT 23
22655: PUSH
22656: LD_INT 24
22658: PUSH
22659: EMPTY
22660: LIST
22661: LIST
22662: LIST
22663: LIST
22664: LIST
22665: LIST
22666: LIST
22667: LIST
22668: LIST
22669: LIST
22670: ST_TO_ADDR
22671: GO 22674
22673: POP
// result := ( chassis in result ) ;
22674: LD_ADDR_VAR 0 3
22678: PUSH
22679: LD_VAR 0 1
22683: PUSH
22684: LD_VAR 0 3
22688: IN
22689: ST_TO_ADDR
// end ;
22690: LD_VAR 0 3
22694: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
22695: LD_INT 0
22697: PPUSH
// if not chassis or not weapon then
22698: LD_VAR 0 1
22702: NOT
22703: PUSH
22704: LD_VAR 0 2
22708: NOT
22709: OR
22710: IFFALSE 22714
// exit ;
22712: GO 23774
// case weapon of us_machine_gun :
22714: LD_VAR 0 2
22718: PUSH
22719: LD_INT 2
22721: DOUBLE
22722: EQUAL
22723: IFTRUE 22727
22725: GO 22757
22727: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
22728: LD_ADDR_VAR 0 3
22732: PUSH
22733: LD_INT 1
22735: PUSH
22736: LD_INT 2
22738: PUSH
22739: LD_INT 3
22741: PUSH
22742: LD_INT 4
22744: PUSH
22745: LD_INT 5
22747: PUSH
22748: EMPTY
22749: LIST
22750: LIST
22751: LIST
22752: LIST
22753: LIST
22754: ST_TO_ADDR
22755: GO 23758
22757: LD_INT 3
22759: DOUBLE
22760: EQUAL
22761: IFTRUE 22765
22763: GO 22795
22765: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
22766: LD_ADDR_VAR 0 3
22770: PUSH
22771: LD_INT 1
22773: PUSH
22774: LD_INT 2
22776: PUSH
22777: LD_INT 3
22779: PUSH
22780: LD_INT 4
22782: PUSH
22783: LD_INT 5
22785: PUSH
22786: EMPTY
22787: LIST
22788: LIST
22789: LIST
22790: LIST
22791: LIST
22792: ST_TO_ADDR
22793: GO 23758
22795: LD_INT 11
22797: DOUBLE
22798: EQUAL
22799: IFTRUE 22803
22801: GO 22833
22803: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
22804: LD_ADDR_VAR 0 3
22808: PUSH
22809: LD_INT 1
22811: PUSH
22812: LD_INT 2
22814: PUSH
22815: LD_INT 3
22817: PUSH
22818: LD_INT 4
22820: PUSH
22821: LD_INT 5
22823: PUSH
22824: EMPTY
22825: LIST
22826: LIST
22827: LIST
22828: LIST
22829: LIST
22830: ST_TO_ADDR
22831: GO 23758
22833: LD_INT 4
22835: DOUBLE
22836: EQUAL
22837: IFTRUE 22841
22839: GO 22867
22841: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
22842: LD_ADDR_VAR 0 3
22846: PUSH
22847: LD_INT 2
22849: PUSH
22850: LD_INT 3
22852: PUSH
22853: LD_INT 4
22855: PUSH
22856: LD_INT 5
22858: PUSH
22859: EMPTY
22860: LIST
22861: LIST
22862: LIST
22863: LIST
22864: ST_TO_ADDR
22865: GO 23758
22867: LD_INT 5
22869: DOUBLE
22870: EQUAL
22871: IFTRUE 22875
22873: GO 22901
22875: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
22876: LD_ADDR_VAR 0 3
22880: PUSH
22881: LD_INT 2
22883: PUSH
22884: LD_INT 3
22886: PUSH
22887: LD_INT 4
22889: PUSH
22890: LD_INT 5
22892: PUSH
22893: EMPTY
22894: LIST
22895: LIST
22896: LIST
22897: LIST
22898: ST_TO_ADDR
22899: GO 23758
22901: LD_INT 9
22903: DOUBLE
22904: EQUAL
22905: IFTRUE 22909
22907: GO 22935
22909: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
22910: LD_ADDR_VAR 0 3
22914: PUSH
22915: LD_INT 2
22917: PUSH
22918: LD_INT 3
22920: PUSH
22921: LD_INT 4
22923: PUSH
22924: LD_INT 5
22926: PUSH
22927: EMPTY
22928: LIST
22929: LIST
22930: LIST
22931: LIST
22932: ST_TO_ADDR
22933: GO 23758
22935: LD_INT 7
22937: DOUBLE
22938: EQUAL
22939: IFTRUE 22943
22941: GO 22969
22943: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
22944: LD_ADDR_VAR 0 3
22948: PUSH
22949: LD_INT 2
22951: PUSH
22952: LD_INT 3
22954: PUSH
22955: LD_INT 4
22957: PUSH
22958: LD_INT 5
22960: PUSH
22961: EMPTY
22962: LIST
22963: LIST
22964: LIST
22965: LIST
22966: ST_TO_ADDR
22967: GO 23758
22969: LD_INT 12
22971: DOUBLE
22972: EQUAL
22973: IFTRUE 22977
22975: GO 23003
22977: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
22978: LD_ADDR_VAR 0 3
22982: PUSH
22983: LD_INT 2
22985: PUSH
22986: LD_INT 3
22988: PUSH
22989: LD_INT 4
22991: PUSH
22992: LD_INT 5
22994: PUSH
22995: EMPTY
22996: LIST
22997: LIST
22998: LIST
22999: LIST
23000: ST_TO_ADDR
23001: GO 23758
23003: LD_INT 13
23005: DOUBLE
23006: EQUAL
23007: IFTRUE 23011
23009: GO 23037
23011: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
23012: LD_ADDR_VAR 0 3
23016: PUSH
23017: LD_INT 2
23019: PUSH
23020: LD_INT 3
23022: PUSH
23023: LD_INT 4
23025: PUSH
23026: LD_INT 5
23028: PUSH
23029: EMPTY
23030: LIST
23031: LIST
23032: LIST
23033: LIST
23034: ST_TO_ADDR
23035: GO 23758
23037: LD_INT 14
23039: DOUBLE
23040: EQUAL
23041: IFTRUE 23045
23043: GO 23063
23045: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
23046: LD_ADDR_VAR 0 3
23050: PUSH
23051: LD_INT 4
23053: PUSH
23054: LD_INT 5
23056: PUSH
23057: EMPTY
23058: LIST
23059: LIST
23060: ST_TO_ADDR
23061: GO 23758
23063: LD_INT 6
23065: DOUBLE
23066: EQUAL
23067: IFTRUE 23071
23069: GO 23089
23071: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
23072: LD_ADDR_VAR 0 3
23076: PUSH
23077: LD_INT 4
23079: PUSH
23080: LD_INT 5
23082: PUSH
23083: EMPTY
23084: LIST
23085: LIST
23086: ST_TO_ADDR
23087: GO 23758
23089: LD_INT 10
23091: DOUBLE
23092: EQUAL
23093: IFTRUE 23097
23095: GO 23115
23097: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
23098: LD_ADDR_VAR 0 3
23102: PUSH
23103: LD_INT 4
23105: PUSH
23106: LD_INT 5
23108: PUSH
23109: EMPTY
23110: LIST
23111: LIST
23112: ST_TO_ADDR
23113: GO 23758
23115: LD_INT 22
23117: DOUBLE
23118: EQUAL
23119: IFTRUE 23123
23121: GO 23149
23123: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
23124: LD_ADDR_VAR 0 3
23128: PUSH
23129: LD_INT 11
23131: PUSH
23132: LD_INT 12
23134: PUSH
23135: LD_INT 13
23137: PUSH
23138: LD_INT 14
23140: PUSH
23141: EMPTY
23142: LIST
23143: LIST
23144: LIST
23145: LIST
23146: ST_TO_ADDR
23147: GO 23758
23149: LD_INT 23
23151: DOUBLE
23152: EQUAL
23153: IFTRUE 23157
23155: GO 23183
23157: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
23158: LD_ADDR_VAR 0 3
23162: PUSH
23163: LD_INT 11
23165: PUSH
23166: LD_INT 12
23168: PUSH
23169: LD_INT 13
23171: PUSH
23172: LD_INT 14
23174: PUSH
23175: EMPTY
23176: LIST
23177: LIST
23178: LIST
23179: LIST
23180: ST_TO_ADDR
23181: GO 23758
23183: LD_INT 24
23185: DOUBLE
23186: EQUAL
23187: IFTRUE 23191
23189: GO 23217
23191: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
23192: LD_ADDR_VAR 0 3
23196: PUSH
23197: LD_INT 11
23199: PUSH
23200: LD_INT 12
23202: PUSH
23203: LD_INT 13
23205: PUSH
23206: LD_INT 14
23208: PUSH
23209: EMPTY
23210: LIST
23211: LIST
23212: LIST
23213: LIST
23214: ST_TO_ADDR
23215: GO 23758
23217: LD_INT 30
23219: DOUBLE
23220: EQUAL
23221: IFTRUE 23225
23223: GO 23251
23225: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
23226: LD_ADDR_VAR 0 3
23230: PUSH
23231: LD_INT 11
23233: PUSH
23234: LD_INT 12
23236: PUSH
23237: LD_INT 13
23239: PUSH
23240: LD_INT 14
23242: PUSH
23243: EMPTY
23244: LIST
23245: LIST
23246: LIST
23247: LIST
23248: ST_TO_ADDR
23249: GO 23758
23251: LD_INT 25
23253: DOUBLE
23254: EQUAL
23255: IFTRUE 23259
23257: GO 23277
23259: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
23260: LD_ADDR_VAR 0 3
23264: PUSH
23265: LD_INT 13
23267: PUSH
23268: LD_INT 14
23270: PUSH
23271: EMPTY
23272: LIST
23273: LIST
23274: ST_TO_ADDR
23275: GO 23758
23277: LD_INT 27
23279: DOUBLE
23280: EQUAL
23281: IFTRUE 23285
23283: GO 23303
23285: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
23286: LD_ADDR_VAR 0 3
23290: PUSH
23291: LD_INT 13
23293: PUSH
23294: LD_INT 14
23296: PUSH
23297: EMPTY
23298: LIST
23299: LIST
23300: ST_TO_ADDR
23301: GO 23758
23303: LD_INT 92
23305: DOUBLE
23306: EQUAL
23307: IFTRUE 23311
23309: GO 23337
23311: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
23312: LD_ADDR_VAR 0 3
23316: PUSH
23317: LD_INT 11
23319: PUSH
23320: LD_INT 12
23322: PUSH
23323: LD_INT 13
23325: PUSH
23326: LD_INT 14
23328: PUSH
23329: EMPTY
23330: LIST
23331: LIST
23332: LIST
23333: LIST
23334: ST_TO_ADDR
23335: GO 23758
23337: LD_INT 28
23339: DOUBLE
23340: EQUAL
23341: IFTRUE 23345
23343: GO 23363
23345: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
23346: LD_ADDR_VAR 0 3
23350: PUSH
23351: LD_INT 13
23353: PUSH
23354: LD_INT 14
23356: PUSH
23357: EMPTY
23358: LIST
23359: LIST
23360: ST_TO_ADDR
23361: GO 23758
23363: LD_INT 29
23365: DOUBLE
23366: EQUAL
23367: IFTRUE 23371
23369: GO 23389
23371: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
23372: LD_ADDR_VAR 0 3
23376: PUSH
23377: LD_INT 13
23379: PUSH
23380: LD_INT 14
23382: PUSH
23383: EMPTY
23384: LIST
23385: LIST
23386: ST_TO_ADDR
23387: GO 23758
23389: LD_INT 31
23391: DOUBLE
23392: EQUAL
23393: IFTRUE 23397
23395: GO 23415
23397: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
23398: LD_ADDR_VAR 0 3
23402: PUSH
23403: LD_INT 13
23405: PUSH
23406: LD_INT 14
23408: PUSH
23409: EMPTY
23410: LIST
23411: LIST
23412: ST_TO_ADDR
23413: GO 23758
23415: LD_INT 26
23417: DOUBLE
23418: EQUAL
23419: IFTRUE 23423
23421: GO 23441
23423: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
23424: LD_ADDR_VAR 0 3
23428: PUSH
23429: LD_INT 13
23431: PUSH
23432: LD_INT 14
23434: PUSH
23435: EMPTY
23436: LIST
23437: LIST
23438: ST_TO_ADDR
23439: GO 23758
23441: LD_INT 42
23443: DOUBLE
23444: EQUAL
23445: IFTRUE 23449
23447: GO 23475
23449: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
23450: LD_ADDR_VAR 0 3
23454: PUSH
23455: LD_INT 21
23457: PUSH
23458: LD_INT 22
23460: PUSH
23461: LD_INT 23
23463: PUSH
23464: LD_INT 24
23466: PUSH
23467: EMPTY
23468: LIST
23469: LIST
23470: LIST
23471: LIST
23472: ST_TO_ADDR
23473: GO 23758
23475: LD_INT 43
23477: DOUBLE
23478: EQUAL
23479: IFTRUE 23483
23481: GO 23509
23483: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
23484: LD_ADDR_VAR 0 3
23488: PUSH
23489: LD_INT 21
23491: PUSH
23492: LD_INT 22
23494: PUSH
23495: LD_INT 23
23497: PUSH
23498: LD_INT 24
23500: PUSH
23501: EMPTY
23502: LIST
23503: LIST
23504: LIST
23505: LIST
23506: ST_TO_ADDR
23507: GO 23758
23509: LD_INT 44
23511: DOUBLE
23512: EQUAL
23513: IFTRUE 23517
23515: GO 23543
23517: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
23518: LD_ADDR_VAR 0 3
23522: PUSH
23523: LD_INT 21
23525: PUSH
23526: LD_INT 22
23528: PUSH
23529: LD_INT 23
23531: PUSH
23532: LD_INT 24
23534: PUSH
23535: EMPTY
23536: LIST
23537: LIST
23538: LIST
23539: LIST
23540: ST_TO_ADDR
23541: GO 23758
23543: LD_INT 45
23545: DOUBLE
23546: EQUAL
23547: IFTRUE 23551
23549: GO 23577
23551: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
23552: LD_ADDR_VAR 0 3
23556: PUSH
23557: LD_INT 21
23559: PUSH
23560: LD_INT 22
23562: PUSH
23563: LD_INT 23
23565: PUSH
23566: LD_INT 24
23568: PUSH
23569: EMPTY
23570: LIST
23571: LIST
23572: LIST
23573: LIST
23574: ST_TO_ADDR
23575: GO 23758
23577: LD_INT 49
23579: DOUBLE
23580: EQUAL
23581: IFTRUE 23585
23583: GO 23611
23585: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
23586: LD_ADDR_VAR 0 3
23590: PUSH
23591: LD_INT 21
23593: PUSH
23594: LD_INT 22
23596: PUSH
23597: LD_INT 23
23599: PUSH
23600: LD_INT 24
23602: PUSH
23603: EMPTY
23604: LIST
23605: LIST
23606: LIST
23607: LIST
23608: ST_TO_ADDR
23609: GO 23758
23611: LD_INT 51
23613: DOUBLE
23614: EQUAL
23615: IFTRUE 23619
23617: GO 23645
23619: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
23620: LD_ADDR_VAR 0 3
23624: PUSH
23625: LD_INT 21
23627: PUSH
23628: LD_INT 22
23630: PUSH
23631: LD_INT 23
23633: PUSH
23634: LD_INT 24
23636: PUSH
23637: EMPTY
23638: LIST
23639: LIST
23640: LIST
23641: LIST
23642: ST_TO_ADDR
23643: GO 23758
23645: LD_INT 52
23647: DOUBLE
23648: EQUAL
23649: IFTRUE 23653
23651: GO 23679
23653: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
23654: LD_ADDR_VAR 0 3
23658: PUSH
23659: LD_INT 21
23661: PUSH
23662: LD_INT 22
23664: PUSH
23665: LD_INT 23
23667: PUSH
23668: LD_INT 24
23670: PUSH
23671: EMPTY
23672: LIST
23673: LIST
23674: LIST
23675: LIST
23676: ST_TO_ADDR
23677: GO 23758
23679: LD_INT 53
23681: DOUBLE
23682: EQUAL
23683: IFTRUE 23687
23685: GO 23705
23687: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
23688: LD_ADDR_VAR 0 3
23692: PUSH
23693: LD_INT 23
23695: PUSH
23696: LD_INT 24
23698: PUSH
23699: EMPTY
23700: LIST
23701: LIST
23702: ST_TO_ADDR
23703: GO 23758
23705: LD_INT 46
23707: DOUBLE
23708: EQUAL
23709: IFTRUE 23713
23711: GO 23731
23713: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
23714: LD_ADDR_VAR 0 3
23718: PUSH
23719: LD_INT 23
23721: PUSH
23722: LD_INT 24
23724: PUSH
23725: EMPTY
23726: LIST
23727: LIST
23728: ST_TO_ADDR
23729: GO 23758
23731: LD_INT 47
23733: DOUBLE
23734: EQUAL
23735: IFTRUE 23739
23737: GO 23757
23739: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
23740: LD_ADDR_VAR 0 3
23744: PUSH
23745: LD_INT 23
23747: PUSH
23748: LD_INT 24
23750: PUSH
23751: EMPTY
23752: LIST
23753: LIST
23754: ST_TO_ADDR
23755: GO 23758
23757: POP
// result := ( chassis in result ) ;
23758: LD_ADDR_VAR 0 3
23762: PUSH
23763: LD_VAR 0 1
23767: PUSH
23768: LD_VAR 0 3
23772: IN
23773: ST_TO_ADDR
// end ;
23774: LD_VAR 0 3
23778: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
23779: LD_INT 0
23781: PPUSH
23782: PPUSH
23783: PPUSH
23784: PPUSH
23785: PPUSH
23786: PPUSH
23787: PPUSH
// result := array ;
23788: LD_ADDR_VAR 0 5
23792: PUSH
23793: LD_VAR 0 1
23797: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
23798: LD_VAR 0 1
23802: NOT
23803: PUSH
23804: LD_VAR 0 2
23808: NOT
23809: OR
23810: PUSH
23811: LD_VAR 0 3
23815: NOT
23816: OR
23817: PUSH
23818: LD_VAR 0 2
23822: PUSH
23823: LD_VAR 0 1
23827: GREATER
23828: OR
23829: PUSH
23830: LD_VAR 0 3
23834: PUSH
23835: LD_VAR 0 1
23839: GREATER
23840: OR
23841: IFFALSE 23845
// exit ;
23843: GO 24141
// if direction then
23845: LD_VAR 0 4
23849: IFFALSE 23913
// begin d := 1 ;
23851: LD_ADDR_VAR 0 9
23855: PUSH
23856: LD_INT 1
23858: ST_TO_ADDR
// if i_from > i_to then
23859: LD_VAR 0 2
23863: PUSH
23864: LD_VAR 0 3
23868: GREATER
23869: IFFALSE 23895
// length := ( array - i_from ) + i_to else
23871: LD_ADDR_VAR 0 11
23875: PUSH
23876: LD_VAR 0 1
23880: PUSH
23881: LD_VAR 0 2
23885: MINUS
23886: PUSH
23887: LD_VAR 0 3
23891: PLUS
23892: ST_TO_ADDR
23893: GO 23911
// length := i_to - i_from ;
23895: LD_ADDR_VAR 0 11
23899: PUSH
23900: LD_VAR 0 3
23904: PUSH
23905: LD_VAR 0 2
23909: MINUS
23910: ST_TO_ADDR
// end else
23911: GO 23974
// begin d := - 1 ;
23913: LD_ADDR_VAR 0 9
23917: PUSH
23918: LD_INT 1
23920: NEG
23921: ST_TO_ADDR
// if i_from > i_to then
23922: LD_VAR 0 2
23926: PUSH
23927: LD_VAR 0 3
23931: GREATER
23932: IFFALSE 23952
// length := i_from - i_to else
23934: LD_ADDR_VAR 0 11
23938: PUSH
23939: LD_VAR 0 2
23943: PUSH
23944: LD_VAR 0 3
23948: MINUS
23949: ST_TO_ADDR
23950: GO 23974
// length := ( array - i_to ) + i_from ;
23952: LD_ADDR_VAR 0 11
23956: PUSH
23957: LD_VAR 0 1
23961: PUSH
23962: LD_VAR 0 3
23966: MINUS
23967: PUSH
23968: LD_VAR 0 2
23972: PLUS
23973: ST_TO_ADDR
// end ; if not length then
23974: LD_VAR 0 11
23978: NOT
23979: IFFALSE 23983
// exit ;
23981: GO 24141
// tmp := array ;
23983: LD_ADDR_VAR 0 10
23987: PUSH
23988: LD_VAR 0 1
23992: ST_TO_ADDR
// for i = 1 to length do
23993: LD_ADDR_VAR 0 6
23997: PUSH
23998: DOUBLE
23999: LD_INT 1
24001: DEC
24002: ST_TO_ADDR
24003: LD_VAR 0 11
24007: PUSH
24008: FOR_TO
24009: IFFALSE 24129
// begin for j = 1 to array do
24011: LD_ADDR_VAR 0 7
24015: PUSH
24016: DOUBLE
24017: LD_INT 1
24019: DEC
24020: ST_TO_ADDR
24021: LD_VAR 0 1
24025: PUSH
24026: FOR_TO
24027: IFFALSE 24115
// begin k := j + d ;
24029: LD_ADDR_VAR 0 8
24033: PUSH
24034: LD_VAR 0 7
24038: PUSH
24039: LD_VAR 0 9
24043: PLUS
24044: ST_TO_ADDR
// if k > array then
24045: LD_VAR 0 8
24049: PUSH
24050: LD_VAR 0 1
24054: GREATER
24055: IFFALSE 24065
// k := 1 ;
24057: LD_ADDR_VAR 0 8
24061: PUSH
24062: LD_INT 1
24064: ST_TO_ADDR
// if not k then
24065: LD_VAR 0 8
24069: NOT
24070: IFFALSE 24082
// k := array ;
24072: LD_ADDR_VAR 0 8
24076: PUSH
24077: LD_VAR 0 1
24081: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
24082: LD_ADDR_VAR 0 10
24086: PUSH
24087: LD_VAR 0 10
24091: PPUSH
24092: LD_VAR 0 8
24096: PPUSH
24097: LD_VAR 0 1
24101: PUSH
24102: LD_VAR 0 7
24106: ARRAY
24107: PPUSH
24108: CALL_OW 1
24112: ST_TO_ADDR
// end ;
24113: GO 24026
24115: POP
24116: POP
// array := tmp ;
24117: LD_ADDR_VAR 0 1
24121: PUSH
24122: LD_VAR 0 10
24126: ST_TO_ADDR
// end ;
24127: GO 24008
24129: POP
24130: POP
// result := array ;
24131: LD_ADDR_VAR 0 5
24135: PUSH
24136: LD_VAR 0 1
24140: ST_TO_ADDR
// end ;
24141: LD_VAR 0 5
24145: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
24146: LD_INT 0
24148: PPUSH
24149: PPUSH
// result := 0 ;
24150: LD_ADDR_VAR 0 3
24154: PUSH
24155: LD_INT 0
24157: ST_TO_ADDR
// if not array or not value in array then
24158: LD_VAR 0 1
24162: NOT
24163: PUSH
24164: LD_VAR 0 2
24168: PUSH
24169: LD_VAR 0 1
24173: IN
24174: NOT
24175: OR
24176: IFFALSE 24180
// exit ;
24178: GO 24234
// for i = 1 to array do
24180: LD_ADDR_VAR 0 4
24184: PUSH
24185: DOUBLE
24186: LD_INT 1
24188: DEC
24189: ST_TO_ADDR
24190: LD_VAR 0 1
24194: PUSH
24195: FOR_TO
24196: IFFALSE 24232
// if value = array [ i ] then
24198: LD_VAR 0 2
24202: PUSH
24203: LD_VAR 0 1
24207: PUSH
24208: LD_VAR 0 4
24212: ARRAY
24213: EQUAL
24214: IFFALSE 24230
// begin result := i ;
24216: LD_ADDR_VAR 0 3
24220: PUSH
24221: LD_VAR 0 4
24225: ST_TO_ADDR
// exit ;
24226: POP
24227: POP
24228: GO 24234
// end ;
24230: GO 24195
24232: POP
24233: POP
// end ;
24234: LD_VAR 0 3
24238: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
24239: LD_INT 0
24241: PPUSH
// vc_chassis := chassis ;
24242: LD_ADDR_OWVAR 37
24246: PUSH
24247: LD_VAR 0 1
24251: ST_TO_ADDR
// vc_engine := engine ;
24252: LD_ADDR_OWVAR 39
24256: PUSH
24257: LD_VAR 0 2
24261: ST_TO_ADDR
// vc_control := control ;
24262: LD_ADDR_OWVAR 38
24266: PUSH
24267: LD_VAR 0 3
24271: ST_TO_ADDR
// vc_weapon := weapon ;
24272: LD_ADDR_OWVAR 40
24276: PUSH
24277: LD_VAR 0 4
24281: ST_TO_ADDR
// vc_fuel_battery := fuel ;
24282: LD_ADDR_OWVAR 41
24286: PUSH
24287: LD_VAR 0 5
24291: ST_TO_ADDR
// end ;
24292: LD_VAR 0 6
24296: RET
// export function WantPlant ( unit ) ; var task ; begin
24297: LD_INT 0
24299: PPUSH
24300: PPUSH
// result := false ;
24301: LD_ADDR_VAR 0 2
24305: PUSH
24306: LD_INT 0
24308: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
24309: LD_ADDR_VAR 0 3
24313: PUSH
24314: LD_VAR 0 1
24318: PPUSH
24319: CALL_OW 437
24323: ST_TO_ADDR
// if task then
24324: LD_VAR 0 3
24328: IFFALSE 24356
// if task [ 1 ] [ 1 ] = p then
24330: LD_VAR 0 3
24334: PUSH
24335: LD_INT 1
24337: ARRAY
24338: PUSH
24339: LD_INT 1
24341: ARRAY
24342: PUSH
24343: LD_STRING p
24345: EQUAL
24346: IFFALSE 24356
// result := true ;
24348: LD_ADDR_VAR 0 2
24352: PUSH
24353: LD_INT 1
24355: ST_TO_ADDR
// end ;
24356: LD_VAR 0 2
24360: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
24361: LD_INT 0
24363: PPUSH
24364: PPUSH
24365: PPUSH
24366: PPUSH
// if pos < 1 then
24367: LD_VAR 0 2
24371: PUSH
24372: LD_INT 1
24374: LESS
24375: IFFALSE 24379
// exit ;
24377: GO 24682
// if pos = 1 then
24379: LD_VAR 0 2
24383: PUSH
24384: LD_INT 1
24386: EQUAL
24387: IFFALSE 24420
// result := Replace ( arr , pos [ 1 ] , value ) else
24389: LD_ADDR_VAR 0 4
24393: PUSH
24394: LD_VAR 0 1
24398: PPUSH
24399: LD_VAR 0 2
24403: PUSH
24404: LD_INT 1
24406: ARRAY
24407: PPUSH
24408: LD_VAR 0 3
24412: PPUSH
24413: CALL_OW 1
24417: ST_TO_ADDR
24418: GO 24682
// begin tmp := arr ;
24420: LD_ADDR_VAR 0 6
24424: PUSH
24425: LD_VAR 0 1
24429: ST_TO_ADDR
// s_arr := [ tmp ] ;
24430: LD_ADDR_VAR 0 7
24434: PUSH
24435: LD_VAR 0 6
24439: PUSH
24440: EMPTY
24441: LIST
24442: ST_TO_ADDR
// for i = 1 to pos - 1 do
24443: LD_ADDR_VAR 0 5
24447: PUSH
24448: DOUBLE
24449: LD_INT 1
24451: DEC
24452: ST_TO_ADDR
24453: LD_VAR 0 2
24457: PUSH
24458: LD_INT 1
24460: MINUS
24461: PUSH
24462: FOR_TO
24463: IFFALSE 24508
// begin tmp := tmp [ pos [ i ] ] ;
24465: LD_ADDR_VAR 0 6
24469: PUSH
24470: LD_VAR 0 6
24474: PUSH
24475: LD_VAR 0 2
24479: PUSH
24480: LD_VAR 0 5
24484: ARRAY
24485: ARRAY
24486: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
24487: LD_ADDR_VAR 0 7
24491: PUSH
24492: LD_VAR 0 7
24496: PUSH
24497: LD_VAR 0 6
24501: PUSH
24502: EMPTY
24503: LIST
24504: ADD
24505: ST_TO_ADDR
// end ;
24506: GO 24462
24508: POP
24509: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
24510: LD_ADDR_VAR 0 6
24514: PUSH
24515: LD_VAR 0 6
24519: PPUSH
24520: LD_VAR 0 2
24524: PUSH
24525: LD_VAR 0 2
24529: ARRAY
24530: PPUSH
24531: LD_VAR 0 3
24535: PPUSH
24536: CALL_OW 1
24540: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
24541: LD_ADDR_VAR 0 7
24545: PUSH
24546: LD_VAR 0 7
24550: PPUSH
24551: LD_VAR 0 7
24555: PPUSH
24556: LD_VAR 0 6
24560: PPUSH
24561: CALL_OW 1
24565: ST_TO_ADDR
// for i = s_arr downto 2 do
24566: LD_ADDR_VAR 0 5
24570: PUSH
24571: DOUBLE
24572: LD_VAR 0 7
24576: INC
24577: ST_TO_ADDR
24578: LD_INT 2
24580: PUSH
24581: FOR_DOWNTO
24582: IFFALSE 24666
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
24584: LD_ADDR_VAR 0 6
24588: PUSH
24589: LD_VAR 0 7
24593: PUSH
24594: LD_VAR 0 5
24598: PUSH
24599: LD_INT 1
24601: MINUS
24602: ARRAY
24603: PPUSH
24604: LD_VAR 0 2
24608: PUSH
24609: LD_VAR 0 5
24613: PUSH
24614: LD_INT 1
24616: MINUS
24617: ARRAY
24618: PPUSH
24619: LD_VAR 0 7
24623: PUSH
24624: LD_VAR 0 5
24628: ARRAY
24629: PPUSH
24630: CALL_OW 1
24634: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
24635: LD_ADDR_VAR 0 7
24639: PUSH
24640: LD_VAR 0 7
24644: PPUSH
24645: LD_VAR 0 5
24649: PUSH
24650: LD_INT 1
24652: MINUS
24653: PPUSH
24654: LD_VAR 0 6
24658: PPUSH
24659: CALL_OW 1
24663: ST_TO_ADDR
// end ;
24664: GO 24581
24666: POP
24667: POP
// result := s_arr [ 1 ] ;
24668: LD_ADDR_VAR 0 4
24672: PUSH
24673: LD_VAR 0 7
24677: PUSH
24678: LD_INT 1
24680: ARRAY
24681: ST_TO_ADDR
// end ; end ;
24682: LD_VAR 0 4
24686: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
24687: LD_INT 0
24689: PPUSH
24690: PPUSH
// if not list then
24691: LD_VAR 0 1
24695: NOT
24696: IFFALSE 24700
// exit ;
24698: GO 24791
// i := list [ pos1 ] ;
24700: LD_ADDR_VAR 0 5
24704: PUSH
24705: LD_VAR 0 1
24709: PUSH
24710: LD_VAR 0 2
24714: ARRAY
24715: ST_TO_ADDR
// if not i then
24716: LD_VAR 0 5
24720: NOT
24721: IFFALSE 24725
// exit ;
24723: GO 24791
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
24725: LD_ADDR_VAR 0 1
24729: PUSH
24730: LD_VAR 0 1
24734: PPUSH
24735: LD_VAR 0 2
24739: PPUSH
24740: LD_VAR 0 1
24744: PUSH
24745: LD_VAR 0 3
24749: ARRAY
24750: PPUSH
24751: CALL_OW 1
24755: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
24756: LD_ADDR_VAR 0 1
24760: PUSH
24761: LD_VAR 0 1
24765: PPUSH
24766: LD_VAR 0 3
24770: PPUSH
24771: LD_VAR 0 5
24775: PPUSH
24776: CALL_OW 1
24780: ST_TO_ADDR
// result := list ;
24781: LD_ADDR_VAR 0 4
24785: PUSH
24786: LD_VAR 0 1
24790: ST_TO_ADDR
// end ;
24791: LD_VAR 0 4
24795: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
24796: LD_INT 0
24798: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
24799: LD_ADDR_VAR 0 5
24803: PUSH
24804: LD_VAR 0 1
24808: PPUSH
24809: CALL_OW 250
24813: PPUSH
24814: LD_VAR 0 1
24818: PPUSH
24819: CALL_OW 251
24823: PPUSH
24824: LD_VAR 0 2
24828: PPUSH
24829: LD_VAR 0 3
24833: PPUSH
24834: LD_VAR 0 4
24838: PPUSH
24839: CALL 24849 0 5
24843: ST_TO_ADDR
// end ;
24844: LD_VAR 0 5
24848: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
24849: LD_INT 0
24851: PPUSH
24852: PPUSH
24853: PPUSH
24854: PPUSH
// if not list then
24855: LD_VAR 0 3
24859: NOT
24860: IFFALSE 24864
// exit ;
24862: GO 25252
// result := [ ] ;
24864: LD_ADDR_VAR 0 6
24868: PUSH
24869: EMPTY
24870: ST_TO_ADDR
// for i in list do
24871: LD_ADDR_VAR 0 7
24875: PUSH
24876: LD_VAR 0 3
24880: PUSH
24881: FOR_IN
24882: IFFALSE 25084
// begin tmp := GetDistUnitXY ( i , x , y ) ;
24884: LD_ADDR_VAR 0 9
24888: PUSH
24889: LD_VAR 0 7
24893: PPUSH
24894: LD_VAR 0 1
24898: PPUSH
24899: LD_VAR 0 2
24903: PPUSH
24904: CALL_OW 297
24908: ST_TO_ADDR
// if not result then
24909: LD_VAR 0 6
24913: NOT
24914: IFFALSE 24940
// result := [ [ i , tmp ] ] else
24916: LD_ADDR_VAR 0 6
24920: PUSH
24921: LD_VAR 0 7
24925: PUSH
24926: LD_VAR 0 9
24930: PUSH
24931: EMPTY
24932: LIST
24933: LIST
24934: PUSH
24935: EMPTY
24936: LIST
24937: ST_TO_ADDR
24938: GO 25082
// begin if result [ result ] [ 2 ] < tmp then
24940: LD_VAR 0 6
24944: PUSH
24945: LD_VAR 0 6
24949: ARRAY
24950: PUSH
24951: LD_INT 2
24953: ARRAY
24954: PUSH
24955: LD_VAR 0 9
24959: LESS
24960: IFFALSE 25002
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
24962: LD_ADDR_VAR 0 6
24966: PUSH
24967: LD_VAR 0 6
24971: PPUSH
24972: LD_VAR 0 6
24976: PUSH
24977: LD_INT 1
24979: PLUS
24980: PPUSH
24981: LD_VAR 0 7
24985: PUSH
24986: LD_VAR 0 9
24990: PUSH
24991: EMPTY
24992: LIST
24993: LIST
24994: PPUSH
24995: CALL_OW 2
24999: ST_TO_ADDR
25000: GO 25082
// for j = 1 to result do
25002: LD_ADDR_VAR 0 8
25006: PUSH
25007: DOUBLE
25008: LD_INT 1
25010: DEC
25011: ST_TO_ADDR
25012: LD_VAR 0 6
25016: PUSH
25017: FOR_TO
25018: IFFALSE 25080
// begin if tmp < result [ j ] [ 2 ] then
25020: LD_VAR 0 9
25024: PUSH
25025: LD_VAR 0 6
25029: PUSH
25030: LD_VAR 0 8
25034: ARRAY
25035: PUSH
25036: LD_INT 2
25038: ARRAY
25039: LESS
25040: IFFALSE 25078
// begin result := Insert ( result , j , [ i , tmp ] ) ;
25042: LD_ADDR_VAR 0 6
25046: PUSH
25047: LD_VAR 0 6
25051: PPUSH
25052: LD_VAR 0 8
25056: PPUSH
25057: LD_VAR 0 7
25061: PUSH
25062: LD_VAR 0 9
25066: PUSH
25067: EMPTY
25068: LIST
25069: LIST
25070: PPUSH
25071: CALL_OW 2
25075: ST_TO_ADDR
// break ;
25076: GO 25080
// end ; end ;
25078: GO 25017
25080: POP
25081: POP
// end ; end ;
25082: GO 24881
25084: POP
25085: POP
// if result and not asc then
25086: LD_VAR 0 6
25090: PUSH
25091: LD_VAR 0 4
25095: NOT
25096: AND
25097: IFFALSE 25172
// begin tmp := result ;
25099: LD_ADDR_VAR 0 9
25103: PUSH
25104: LD_VAR 0 6
25108: ST_TO_ADDR
// for i = tmp downto 1 do
25109: LD_ADDR_VAR 0 7
25113: PUSH
25114: DOUBLE
25115: LD_VAR 0 9
25119: INC
25120: ST_TO_ADDR
25121: LD_INT 1
25123: PUSH
25124: FOR_DOWNTO
25125: IFFALSE 25170
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
25127: LD_ADDR_VAR 0 6
25131: PUSH
25132: LD_VAR 0 6
25136: PPUSH
25137: LD_VAR 0 9
25141: PUSH
25142: LD_VAR 0 7
25146: MINUS
25147: PUSH
25148: LD_INT 1
25150: PLUS
25151: PPUSH
25152: LD_VAR 0 9
25156: PUSH
25157: LD_VAR 0 7
25161: ARRAY
25162: PPUSH
25163: CALL_OW 1
25167: ST_TO_ADDR
25168: GO 25124
25170: POP
25171: POP
// end ; tmp := [ ] ;
25172: LD_ADDR_VAR 0 9
25176: PUSH
25177: EMPTY
25178: ST_TO_ADDR
// if mode then
25179: LD_VAR 0 5
25183: IFFALSE 25252
// begin for i = 1 to result do
25185: LD_ADDR_VAR 0 7
25189: PUSH
25190: DOUBLE
25191: LD_INT 1
25193: DEC
25194: ST_TO_ADDR
25195: LD_VAR 0 6
25199: PUSH
25200: FOR_TO
25201: IFFALSE 25240
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
25203: LD_ADDR_VAR 0 9
25207: PUSH
25208: LD_VAR 0 9
25212: PPUSH
25213: LD_VAR 0 7
25217: PPUSH
25218: LD_VAR 0 6
25222: PUSH
25223: LD_VAR 0 7
25227: ARRAY
25228: PUSH
25229: LD_INT 1
25231: ARRAY
25232: PPUSH
25233: CALL_OW 1
25237: ST_TO_ADDR
25238: GO 25200
25240: POP
25241: POP
// result := tmp ;
25242: LD_ADDR_VAR 0 6
25246: PUSH
25247: LD_VAR 0 9
25251: ST_TO_ADDR
// end ; end ;
25252: LD_VAR 0 6
25256: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
25257: LD_INT 0
25259: PPUSH
25260: PPUSH
25261: PPUSH
25262: PPUSH
25263: PPUSH
25264: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
25265: LD_ADDR_VAR 0 5
25269: PUSH
25270: LD_INT 0
25272: PUSH
25273: LD_INT 0
25275: PUSH
25276: LD_INT 0
25278: PUSH
25279: EMPTY
25280: PUSH
25281: EMPTY
25282: LIST
25283: LIST
25284: LIST
25285: LIST
25286: ST_TO_ADDR
// if not x or not y then
25287: LD_VAR 0 2
25291: NOT
25292: PUSH
25293: LD_VAR 0 3
25297: NOT
25298: OR
25299: IFFALSE 25303
// exit ;
25301: GO 26953
// if not range then
25303: LD_VAR 0 4
25307: NOT
25308: IFFALSE 25318
// range := 10 ;
25310: LD_ADDR_VAR 0 4
25314: PUSH
25315: LD_INT 10
25317: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
25318: LD_ADDR_VAR 0 8
25322: PUSH
25323: LD_INT 81
25325: PUSH
25326: LD_VAR 0 1
25330: PUSH
25331: EMPTY
25332: LIST
25333: LIST
25334: PUSH
25335: LD_INT 92
25337: PUSH
25338: LD_VAR 0 2
25342: PUSH
25343: LD_VAR 0 3
25347: PUSH
25348: LD_VAR 0 4
25352: PUSH
25353: EMPTY
25354: LIST
25355: LIST
25356: LIST
25357: LIST
25358: PUSH
25359: LD_INT 3
25361: PUSH
25362: LD_INT 21
25364: PUSH
25365: LD_INT 3
25367: PUSH
25368: EMPTY
25369: LIST
25370: LIST
25371: PUSH
25372: EMPTY
25373: LIST
25374: LIST
25375: PUSH
25376: EMPTY
25377: LIST
25378: LIST
25379: LIST
25380: PPUSH
25381: CALL_OW 69
25385: ST_TO_ADDR
// if not tmp then
25386: LD_VAR 0 8
25390: NOT
25391: IFFALSE 25395
// exit ;
25393: GO 26953
// for i in tmp do
25395: LD_ADDR_VAR 0 6
25399: PUSH
25400: LD_VAR 0 8
25404: PUSH
25405: FOR_IN
25406: IFFALSE 26928
// begin points := [ 0 , 0 , 0 ] ;
25408: LD_ADDR_VAR 0 9
25412: PUSH
25413: LD_INT 0
25415: PUSH
25416: LD_INT 0
25418: PUSH
25419: LD_INT 0
25421: PUSH
25422: EMPTY
25423: LIST
25424: LIST
25425: LIST
25426: ST_TO_ADDR
// bpoints := 1 ;
25427: LD_ADDR_VAR 0 10
25431: PUSH
25432: LD_INT 1
25434: ST_TO_ADDR
// case GetType ( i ) of unit_human :
25435: LD_VAR 0 6
25439: PPUSH
25440: CALL_OW 247
25444: PUSH
25445: LD_INT 1
25447: DOUBLE
25448: EQUAL
25449: IFTRUE 25453
25451: GO 26031
25453: POP
// begin if GetClass ( i ) = 1 then
25454: LD_VAR 0 6
25458: PPUSH
25459: CALL_OW 257
25463: PUSH
25464: LD_INT 1
25466: EQUAL
25467: IFFALSE 25488
// points := [ 10 , 5 , 3 ] ;
25469: LD_ADDR_VAR 0 9
25473: PUSH
25474: LD_INT 10
25476: PUSH
25477: LD_INT 5
25479: PUSH
25480: LD_INT 3
25482: PUSH
25483: EMPTY
25484: LIST
25485: LIST
25486: LIST
25487: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
25488: LD_VAR 0 6
25492: PPUSH
25493: CALL_OW 257
25497: PUSH
25498: LD_INT 2
25500: PUSH
25501: LD_INT 3
25503: PUSH
25504: LD_INT 4
25506: PUSH
25507: EMPTY
25508: LIST
25509: LIST
25510: LIST
25511: IN
25512: IFFALSE 25533
// points := [ 3 , 2 , 1 ] ;
25514: LD_ADDR_VAR 0 9
25518: PUSH
25519: LD_INT 3
25521: PUSH
25522: LD_INT 2
25524: PUSH
25525: LD_INT 1
25527: PUSH
25528: EMPTY
25529: LIST
25530: LIST
25531: LIST
25532: ST_TO_ADDR
// if GetClass ( i ) = 5 then
25533: LD_VAR 0 6
25537: PPUSH
25538: CALL_OW 257
25542: PUSH
25543: LD_INT 5
25545: EQUAL
25546: IFFALSE 25567
// points := [ 130 , 5 , 2 ] ;
25548: LD_ADDR_VAR 0 9
25552: PUSH
25553: LD_INT 130
25555: PUSH
25556: LD_INT 5
25558: PUSH
25559: LD_INT 2
25561: PUSH
25562: EMPTY
25563: LIST
25564: LIST
25565: LIST
25566: ST_TO_ADDR
// if GetClass ( i ) = 8 then
25567: LD_VAR 0 6
25571: PPUSH
25572: CALL_OW 257
25576: PUSH
25577: LD_INT 8
25579: EQUAL
25580: IFFALSE 25601
// points := [ 35 , 35 , 30 ] ;
25582: LD_ADDR_VAR 0 9
25586: PUSH
25587: LD_INT 35
25589: PUSH
25590: LD_INT 35
25592: PUSH
25593: LD_INT 30
25595: PUSH
25596: EMPTY
25597: LIST
25598: LIST
25599: LIST
25600: ST_TO_ADDR
// if GetClass ( i ) = 9 then
25601: LD_VAR 0 6
25605: PPUSH
25606: CALL_OW 257
25610: PUSH
25611: LD_INT 9
25613: EQUAL
25614: IFFALSE 25635
// points := [ 20 , 55 , 40 ] ;
25616: LD_ADDR_VAR 0 9
25620: PUSH
25621: LD_INT 20
25623: PUSH
25624: LD_INT 55
25626: PUSH
25627: LD_INT 40
25629: PUSH
25630: EMPTY
25631: LIST
25632: LIST
25633: LIST
25634: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
25635: LD_VAR 0 6
25639: PPUSH
25640: CALL_OW 257
25644: PUSH
25645: LD_INT 12
25647: PUSH
25648: LD_INT 16
25650: PUSH
25651: EMPTY
25652: LIST
25653: LIST
25654: IN
25655: IFFALSE 25676
// points := [ 5 , 3 , 2 ] ;
25657: LD_ADDR_VAR 0 9
25661: PUSH
25662: LD_INT 5
25664: PUSH
25665: LD_INT 3
25667: PUSH
25668: LD_INT 2
25670: PUSH
25671: EMPTY
25672: LIST
25673: LIST
25674: LIST
25675: ST_TO_ADDR
// if GetClass ( i ) = 17 then
25676: LD_VAR 0 6
25680: PPUSH
25681: CALL_OW 257
25685: PUSH
25686: LD_INT 17
25688: EQUAL
25689: IFFALSE 25710
// points := [ 100 , 50 , 75 ] ;
25691: LD_ADDR_VAR 0 9
25695: PUSH
25696: LD_INT 100
25698: PUSH
25699: LD_INT 50
25701: PUSH
25702: LD_INT 75
25704: PUSH
25705: EMPTY
25706: LIST
25707: LIST
25708: LIST
25709: ST_TO_ADDR
// if GetClass ( i ) = 15 then
25710: LD_VAR 0 6
25714: PPUSH
25715: CALL_OW 257
25719: PUSH
25720: LD_INT 15
25722: EQUAL
25723: IFFALSE 25744
// points := [ 10 , 5 , 3 ] ;
25725: LD_ADDR_VAR 0 9
25729: PUSH
25730: LD_INT 10
25732: PUSH
25733: LD_INT 5
25735: PUSH
25736: LD_INT 3
25738: PUSH
25739: EMPTY
25740: LIST
25741: LIST
25742: LIST
25743: ST_TO_ADDR
// if GetClass ( i ) = 14 then
25744: LD_VAR 0 6
25748: PPUSH
25749: CALL_OW 257
25753: PUSH
25754: LD_INT 14
25756: EQUAL
25757: IFFALSE 25778
// points := [ 10 , 0 , 0 ] ;
25759: LD_ADDR_VAR 0 9
25763: PUSH
25764: LD_INT 10
25766: PUSH
25767: LD_INT 0
25769: PUSH
25770: LD_INT 0
25772: PUSH
25773: EMPTY
25774: LIST
25775: LIST
25776: LIST
25777: ST_TO_ADDR
// if GetClass ( i ) = 11 then
25778: LD_VAR 0 6
25782: PPUSH
25783: CALL_OW 257
25787: PUSH
25788: LD_INT 11
25790: EQUAL
25791: IFFALSE 25812
// points := [ 30 , 10 , 5 ] ;
25793: LD_ADDR_VAR 0 9
25797: PUSH
25798: LD_INT 30
25800: PUSH
25801: LD_INT 10
25803: PUSH
25804: LD_INT 5
25806: PUSH
25807: EMPTY
25808: LIST
25809: LIST
25810: LIST
25811: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
25812: LD_VAR 0 1
25816: PPUSH
25817: LD_INT 5
25819: PPUSH
25820: CALL_OW 321
25824: PUSH
25825: LD_INT 2
25827: EQUAL
25828: IFFALSE 25845
// bpoints := bpoints * 1.8 ;
25830: LD_ADDR_VAR 0 10
25834: PUSH
25835: LD_VAR 0 10
25839: PUSH
25840: LD_REAL  1.80000000000000E+0000
25843: MUL
25844: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
25845: LD_VAR 0 6
25849: PPUSH
25850: CALL_OW 257
25854: PUSH
25855: LD_INT 1
25857: PUSH
25858: LD_INT 2
25860: PUSH
25861: LD_INT 3
25863: PUSH
25864: LD_INT 4
25866: PUSH
25867: EMPTY
25868: LIST
25869: LIST
25870: LIST
25871: LIST
25872: IN
25873: PUSH
25874: LD_VAR 0 1
25878: PPUSH
25879: LD_INT 51
25881: PPUSH
25882: CALL_OW 321
25886: PUSH
25887: LD_INT 2
25889: EQUAL
25890: AND
25891: IFFALSE 25908
// bpoints := bpoints * 1.2 ;
25893: LD_ADDR_VAR 0 10
25897: PUSH
25898: LD_VAR 0 10
25902: PUSH
25903: LD_REAL  1.20000000000000E+0000
25906: MUL
25907: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
25908: LD_VAR 0 6
25912: PPUSH
25913: CALL_OW 257
25917: PUSH
25918: LD_INT 5
25920: PUSH
25921: LD_INT 7
25923: PUSH
25924: LD_INT 9
25926: PUSH
25927: EMPTY
25928: LIST
25929: LIST
25930: LIST
25931: IN
25932: PUSH
25933: LD_VAR 0 1
25937: PPUSH
25938: LD_INT 52
25940: PPUSH
25941: CALL_OW 321
25945: PUSH
25946: LD_INT 2
25948: EQUAL
25949: AND
25950: IFFALSE 25967
// bpoints := bpoints * 1.5 ;
25952: LD_ADDR_VAR 0 10
25956: PUSH
25957: LD_VAR 0 10
25961: PUSH
25962: LD_REAL  1.50000000000000E+0000
25965: MUL
25966: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
25967: LD_VAR 0 1
25971: PPUSH
25972: LD_INT 66
25974: PPUSH
25975: CALL_OW 321
25979: PUSH
25980: LD_INT 2
25982: EQUAL
25983: IFFALSE 26000
// bpoints := bpoints * 1.1 ;
25985: LD_ADDR_VAR 0 10
25989: PUSH
25990: LD_VAR 0 10
25994: PUSH
25995: LD_REAL  1.10000000000000E+0000
25998: MUL
25999: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
26000: LD_ADDR_VAR 0 10
26004: PUSH
26005: LD_VAR 0 10
26009: PUSH
26010: LD_VAR 0 6
26014: PPUSH
26015: LD_INT 1
26017: PPUSH
26018: CALL_OW 259
26022: PUSH
26023: LD_REAL  1.15000000000000E+0000
26026: MUL
26027: MUL
26028: ST_TO_ADDR
// end ; unit_vehicle :
26029: GO 26857
26031: LD_INT 2
26033: DOUBLE
26034: EQUAL
26035: IFTRUE 26039
26037: GO 26845
26039: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
26040: LD_VAR 0 6
26044: PPUSH
26045: CALL_OW 264
26049: PUSH
26050: LD_INT 2
26052: PUSH
26053: LD_INT 42
26055: PUSH
26056: LD_INT 24
26058: PUSH
26059: EMPTY
26060: LIST
26061: LIST
26062: LIST
26063: IN
26064: IFFALSE 26085
// points := [ 25 , 5 , 3 ] ;
26066: LD_ADDR_VAR 0 9
26070: PUSH
26071: LD_INT 25
26073: PUSH
26074: LD_INT 5
26076: PUSH
26077: LD_INT 3
26079: PUSH
26080: EMPTY
26081: LIST
26082: LIST
26083: LIST
26084: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
26085: LD_VAR 0 6
26089: PPUSH
26090: CALL_OW 264
26094: PUSH
26095: LD_INT 4
26097: PUSH
26098: LD_INT 43
26100: PUSH
26101: LD_INT 25
26103: PUSH
26104: EMPTY
26105: LIST
26106: LIST
26107: LIST
26108: IN
26109: IFFALSE 26130
// points := [ 40 , 15 , 5 ] ;
26111: LD_ADDR_VAR 0 9
26115: PUSH
26116: LD_INT 40
26118: PUSH
26119: LD_INT 15
26121: PUSH
26122: LD_INT 5
26124: PUSH
26125: EMPTY
26126: LIST
26127: LIST
26128: LIST
26129: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
26130: LD_VAR 0 6
26134: PPUSH
26135: CALL_OW 264
26139: PUSH
26140: LD_INT 3
26142: PUSH
26143: LD_INT 23
26145: PUSH
26146: EMPTY
26147: LIST
26148: LIST
26149: IN
26150: IFFALSE 26171
// points := [ 7 , 25 , 8 ] ;
26152: LD_ADDR_VAR 0 9
26156: PUSH
26157: LD_INT 7
26159: PUSH
26160: LD_INT 25
26162: PUSH
26163: LD_INT 8
26165: PUSH
26166: EMPTY
26167: LIST
26168: LIST
26169: LIST
26170: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
26171: LD_VAR 0 6
26175: PPUSH
26176: CALL_OW 264
26180: PUSH
26181: LD_INT 5
26183: PUSH
26184: LD_INT 27
26186: PUSH
26187: LD_INT 44
26189: PUSH
26190: EMPTY
26191: LIST
26192: LIST
26193: LIST
26194: IN
26195: IFFALSE 26216
// points := [ 14 , 50 , 16 ] ;
26197: LD_ADDR_VAR 0 9
26201: PUSH
26202: LD_INT 14
26204: PUSH
26205: LD_INT 50
26207: PUSH
26208: LD_INT 16
26210: PUSH
26211: EMPTY
26212: LIST
26213: LIST
26214: LIST
26215: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
26216: LD_VAR 0 6
26220: PPUSH
26221: CALL_OW 264
26225: PUSH
26226: LD_INT 6
26228: PUSH
26229: LD_INT 46
26231: PUSH
26232: EMPTY
26233: LIST
26234: LIST
26235: IN
26236: IFFALSE 26257
// points := [ 32 , 120 , 70 ] ;
26238: LD_ADDR_VAR 0 9
26242: PUSH
26243: LD_INT 32
26245: PUSH
26246: LD_INT 120
26248: PUSH
26249: LD_INT 70
26251: PUSH
26252: EMPTY
26253: LIST
26254: LIST
26255: LIST
26256: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
26257: LD_VAR 0 6
26261: PPUSH
26262: CALL_OW 264
26266: PUSH
26267: LD_INT 7
26269: PUSH
26270: LD_INT 28
26272: PUSH
26273: LD_INT 45
26275: PUSH
26276: LD_INT 92
26278: PUSH
26279: EMPTY
26280: LIST
26281: LIST
26282: LIST
26283: LIST
26284: IN
26285: IFFALSE 26306
// points := [ 35 , 20 , 45 ] ;
26287: LD_ADDR_VAR 0 9
26291: PUSH
26292: LD_INT 35
26294: PUSH
26295: LD_INT 20
26297: PUSH
26298: LD_INT 45
26300: PUSH
26301: EMPTY
26302: LIST
26303: LIST
26304: LIST
26305: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
26306: LD_VAR 0 6
26310: PPUSH
26311: CALL_OW 264
26315: PUSH
26316: LD_INT 47
26318: PUSH
26319: EMPTY
26320: LIST
26321: IN
26322: IFFALSE 26343
// points := [ 67 , 45 , 75 ] ;
26324: LD_ADDR_VAR 0 9
26328: PUSH
26329: LD_INT 67
26331: PUSH
26332: LD_INT 45
26334: PUSH
26335: LD_INT 75
26337: PUSH
26338: EMPTY
26339: LIST
26340: LIST
26341: LIST
26342: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
26343: LD_VAR 0 6
26347: PPUSH
26348: CALL_OW 264
26352: PUSH
26353: LD_INT 26
26355: PUSH
26356: EMPTY
26357: LIST
26358: IN
26359: IFFALSE 26380
// points := [ 120 , 30 , 80 ] ;
26361: LD_ADDR_VAR 0 9
26365: PUSH
26366: LD_INT 120
26368: PUSH
26369: LD_INT 30
26371: PUSH
26372: LD_INT 80
26374: PUSH
26375: EMPTY
26376: LIST
26377: LIST
26378: LIST
26379: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
26380: LD_VAR 0 6
26384: PPUSH
26385: CALL_OW 264
26389: PUSH
26390: LD_INT 22
26392: PUSH
26393: EMPTY
26394: LIST
26395: IN
26396: IFFALSE 26417
// points := [ 40 , 1 , 1 ] ;
26398: LD_ADDR_VAR 0 9
26402: PUSH
26403: LD_INT 40
26405: PUSH
26406: LD_INT 1
26408: PUSH
26409: LD_INT 1
26411: PUSH
26412: EMPTY
26413: LIST
26414: LIST
26415: LIST
26416: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
26417: LD_VAR 0 6
26421: PPUSH
26422: CALL_OW 264
26426: PUSH
26427: LD_INT 29
26429: PUSH
26430: EMPTY
26431: LIST
26432: IN
26433: IFFALSE 26454
// points := [ 70 , 200 , 400 ] ;
26435: LD_ADDR_VAR 0 9
26439: PUSH
26440: LD_INT 70
26442: PUSH
26443: LD_INT 200
26445: PUSH
26446: LD_INT 400
26448: PUSH
26449: EMPTY
26450: LIST
26451: LIST
26452: LIST
26453: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
26454: LD_VAR 0 6
26458: PPUSH
26459: CALL_OW 264
26463: PUSH
26464: LD_INT 14
26466: PUSH
26467: LD_INT 53
26469: PUSH
26470: EMPTY
26471: LIST
26472: LIST
26473: IN
26474: IFFALSE 26495
// points := [ 40 , 10 , 20 ] ;
26476: LD_ADDR_VAR 0 9
26480: PUSH
26481: LD_INT 40
26483: PUSH
26484: LD_INT 10
26486: PUSH
26487: LD_INT 20
26489: PUSH
26490: EMPTY
26491: LIST
26492: LIST
26493: LIST
26494: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
26495: LD_VAR 0 6
26499: PPUSH
26500: CALL_OW 264
26504: PUSH
26505: LD_INT 9
26507: PUSH
26508: EMPTY
26509: LIST
26510: IN
26511: IFFALSE 26532
// points := [ 5 , 70 , 20 ] ;
26513: LD_ADDR_VAR 0 9
26517: PUSH
26518: LD_INT 5
26520: PUSH
26521: LD_INT 70
26523: PUSH
26524: LD_INT 20
26526: PUSH
26527: EMPTY
26528: LIST
26529: LIST
26530: LIST
26531: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
26532: LD_VAR 0 6
26536: PPUSH
26537: CALL_OW 264
26541: PUSH
26542: LD_INT 10
26544: PUSH
26545: EMPTY
26546: LIST
26547: IN
26548: IFFALSE 26569
// points := [ 35 , 110 , 70 ] ;
26550: LD_ADDR_VAR 0 9
26554: PUSH
26555: LD_INT 35
26557: PUSH
26558: LD_INT 110
26560: PUSH
26561: LD_INT 70
26563: PUSH
26564: EMPTY
26565: LIST
26566: LIST
26567: LIST
26568: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
26569: LD_VAR 0 6
26573: PPUSH
26574: CALL_OW 265
26578: PUSH
26579: LD_INT 25
26581: EQUAL
26582: IFFALSE 26603
// points := [ 80 , 65 , 100 ] ;
26584: LD_ADDR_VAR 0 9
26588: PUSH
26589: LD_INT 80
26591: PUSH
26592: LD_INT 65
26594: PUSH
26595: LD_INT 100
26597: PUSH
26598: EMPTY
26599: LIST
26600: LIST
26601: LIST
26602: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
26603: LD_VAR 0 6
26607: PPUSH
26608: CALL_OW 263
26612: PUSH
26613: LD_INT 1
26615: EQUAL
26616: IFFALSE 26651
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
26618: LD_ADDR_VAR 0 10
26622: PUSH
26623: LD_VAR 0 10
26627: PUSH
26628: LD_VAR 0 6
26632: PPUSH
26633: CALL_OW 311
26637: PPUSH
26638: LD_INT 3
26640: PPUSH
26641: CALL_OW 259
26645: PUSH
26646: LD_INT 4
26648: MUL
26649: MUL
26650: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
26651: LD_VAR 0 6
26655: PPUSH
26656: CALL_OW 263
26660: PUSH
26661: LD_INT 2
26663: EQUAL
26664: IFFALSE 26715
// begin j := IsControledBy ( i ) ;
26666: LD_ADDR_VAR 0 7
26670: PUSH
26671: LD_VAR 0 6
26675: PPUSH
26676: CALL_OW 312
26680: ST_TO_ADDR
// if j then
26681: LD_VAR 0 7
26685: IFFALSE 26715
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
26687: LD_ADDR_VAR 0 10
26691: PUSH
26692: LD_VAR 0 10
26696: PUSH
26697: LD_VAR 0 7
26701: PPUSH
26702: LD_INT 3
26704: PPUSH
26705: CALL_OW 259
26709: PUSH
26710: LD_INT 3
26712: MUL
26713: MUL
26714: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
26715: LD_VAR 0 6
26719: PPUSH
26720: CALL_OW 264
26724: PUSH
26725: LD_INT 5
26727: PUSH
26728: LD_INT 6
26730: PUSH
26731: LD_INT 46
26733: PUSH
26734: LD_INT 44
26736: PUSH
26737: LD_INT 47
26739: PUSH
26740: LD_INT 45
26742: PUSH
26743: LD_INT 28
26745: PUSH
26746: LD_INT 7
26748: PUSH
26749: LD_INT 27
26751: PUSH
26752: LD_INT 29
26754: PUSH
26755: EMPTY
26756: LIST
26757: LIST
26758: LIST
26759: LIST
26760: LIST
26761: LIST
26762: LIST
26763: LIST
26764: LIST
26765: LIST
26766: IN
26767: PUSH
26768: LD_VAR 0 1
26772: PPUSH
26773: LD_INT 52
26775: PPUSH
26776: CALL_OW 321
26780: PUSH
26781: LD_INT 2
26783: EQUAL
26784: AND
26785: IFFALSE 26802
// bpoints := bpoints * 1.2 ;
26787: LD_ADDR_VAR 0 10
26791: PUSH
26792: LD_VAR 0 10
26796: PUSH
26797: LD_REAL  1.20000000000000E+0000
26800: MUL
26801: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
26802: LD_VAR 0 6
26806: PPUSH
26807: CALL_OW 264
26811: PUSH
26812: LD_INT 6
26814: PUSH
26815: LD_INT 46
26817: PUSH
26818: LD_INT 47
26820: PUSH
26821: EMPTY
26822: LIST
26823: LIST
26824: LIST
26825: IN
26826: IFFALSE 26843
// bpoints := bpoints * 1.2 ;
26828: LD_ADDR_VAR 0 10
26832: PUSH
26833: LD_VAR 0 10
26837: PUSH
26838: LD_REAL  1.20000000000000E+0000
26841: MUL
26842: ST_TO_ADDR
// end ; unit_building :
26843: GO 26857
26845: LD_INT 3
26847: DOUBLE
26848: EQUAL
26849: IFTRUE 26853
26851: GO 26856
26853: POP
// ; end ;
26854: GO 26857
26856: POP
// for j = 1 to 3 do
26857: LD_ADDR_VAR 0 7
26861: PUSH
26862: DOUBLE
26863: LD_INT 1
26865: DEC
26866: ST_TO_ADDR
26867: LD_INT 3
26869: PUSH
26870: FOR_TO
26871: IFFALSE 26924
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
26873: LD_ADDR_VAR 0 5
26877: PUSH
26878: LD_VAR 0 5
26882: PPUSH
26883: LD_VAR 0 7
26887: PPUSH
26888: LD_VAR 0 5
26892: PUSH
26893: LD_VAR 0 7
26897: ARRAY
26898: PUSH
26899: LD_VAR 0 9
26903: PUSH
26904: LD_VAR 0 7
26908: ARRAY
26909: PUSH
26910: LD_VAR 0 10
26914: MUL
26915: PLUS
26916: PPUSH
26917: CALL_OW 1
26921: ST_TO_ADDR
26922: GO 26870
26924: POP
26925: POP
// end ;
26926: GO 25405
26928: POP
26929: POP
// result := Replace ( result , 4 , tmp ) ;
26930: LD_ADDR_VAR 0 5
26934: PUSH
26935: LD_VAR 0 5
26939: PPUSH
26940: LD_INT 4
26942: PPUSH
26943: LD_VAR 0 8
26947: PPUSH
26948: CALL_OW 1
26952: ST_TO_ADDR
// end ;
26953: LD_VAR 0 5
26957: RET
// export function DangerAtRange ( unit , range ) ; begin
26958: LD_INT 0
26960: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
26961: LD_ADDR_VAR 0 3
26965: PUSH
26966: LD_VAR 0 1
26970: PPUSH
26971: CALL_OW 255
26975: PPUSH
26976: LD_VAR 0 1
26980: PPUSH
26981: CALL_OW 250
26985: PPUSH
26986: LD_VAR 0 1
26990: PPUSH
26991: CALL_OW 251
26995: PPUSH
26996: LD_VAR 0 2
27000: PPUSH
27001: CALL 25257 0 4
27005: ST_TO_ADDR
// end ;
27006: LD_VAR 0 3
27010: RET
// export function DangerInArea ( side , area ) ; begin
27011: LD_INT 0
27013: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
27014: LD_ADDR_VAR 0 3
27018: PUSH
27019: LD_VAR 0 2
27023: PPUSH
27024: LD_INT 81
27026: PUSH
27027: LD_VAR 0 1
27031: PUSH
27032: EMPTY
27033: LIST
27034: LIST
27035: PPUSH
27036: CALL_OW 70
27040: ST_TO_ADDR
// end ;
27041: LD_VAR 0 3
27045: RET
// export function IsExtension ( b ) ; begin
27046: LD_INT 0
27048: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
27049: LD_ADDR_VAR 0 2
27053: PUSH
27054: LD_VAR 0 1
27058: PUSH
27059: LD_INT 23
27061: PUSH
27062: LD_INT 20
27064: PUSH
27065: LD_INT 22
27067: PUSH
27068: LD_INT 17
27070: PUSH
27071: LD_INT 24
27073: PUSH
27074: LD_INT 21
27076: PUSH
27077: LD_INT 19
27079: PUSH
27080: LD_INT 16
27082: PUSH
27083: LD_INT 25
27085: PUSH
27086: LD_INT 18
27088: PUSH
27089: EMPTY
27090: LIST
27091: LIST
27092: LIST
27093: LIST
27094: LIST
27095: LIST
27096: LIST
27097: LIST
27098: LIST
27099: LIST
27100: IN
27101: ST_TO_ADDR
// end ;
27102: LD_VAR 0 2
27106: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
27107: LD_INT 0
27109: PPUSH
27110: PPUSH
27111: PPUSH
// result := [ ] ;
27112: LD_ADDR_VAR 0 4
27116: PUSH
27117: EMPTY
27118: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
27119: LD_ADDR_VAR 0 5
27123: PUSH
27124: LD_VAR 0 2
27128: PPUSH
27129: LD_INT 21
27131: PUSH
27132: LD_INT 3
27134: PUSH
27135: EMPTY
27136: LIST
27137: LIST
27138: PPUSH
27139: CALL_OW 70
27143: ST_TO_ADDR
// if not tmp then
27144: LD_VAR 0 5
27148: NOT
27149: IFFALSE 27153
// exit ;
27151: GO 27217
// if checkLink then
27153: LD_VAR 0 3
27157: IFFALSE 27207
// begin for i in tmp do
27159: LD_ADDR_VAR 0 6
27163: PUSH
27164: LD_VAR 0 5
27168: PUSH
27169: FOR_IN
27170: IFFALSE 27205
// if GetBase ( i ) <> base then
27172: LD_VAR 0 6
27176: PPUSH
27177: CALL_OW 274
27181: PUSH
27182: LD_VAR 0 1
27186: NONEQUAL
27187: IFFALSE 27203
// ComLinkToBase ( base , i ) ;
27189: LD_VAR 0 1
27193: PPUSH
27194: LD_VAR 0 6
27198: PPUSH
27199: CALL_OW 169
27203: GO 27169
27205: POP
27206: POP
// end ; result := tmp ;
27207: LD_ADDR_VAR 0 4
27211: PUSH
27212: LD_VAR 0 5
27216: ST_TO_ADDR
// end ;
27217: LD_VAR 0 4
27221: RET
// export function ComComplete ( units , b ) ; var i ; begin
27222: LD_INT 0
27224: PPUSH
27225: PPUSH
// if not units then
27226: LD_VAR 0 1
27230: NOT
27231: IFFALSE 27235
// exit ;
27233: GO 27325
// for i in units do
27235: LD_ADDR_VAR 0 4
27239: PUSH
27240: LD_VAR 0 1
27244: PUSH
27245: FOR_IN
27246: IFFALSE 27323
// if BuildingStatus ( b ) = bs_build then
27248: LD_VAR 0 2
27252: PPUSH
27253: CALL_OW 461
27257: PUSH
27258: LD_INT 1
27260: EQUAL
27261: IFFALSE 27321
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
27263: LD_VAR 0 4
27267: PPUSH
27268: LD_STRING h
27270: PUSH
27271: LD_VAR 0 2
27275: PPUSH
27276: CALL_OW 250
27280: PUSH
27281: LD_VAR 0 2
27285: PPUSH
27286: CALL_OW 251
27290: PUSH
27291: LD_VAR 0 2
27295: PUSH
27296: LD_INT 0
27298: PUSH
27299: LD_INT 0
27301: PUSH
27302: LD_INT 0
27304: PUSH
27305: EMPTY
27306: LIST
27307: LIST
27308: LIST
27309: LIST
27310: LIST
27311: LIST
27312: LIST
27313: PUSH
27314: EMPTY
27315: LIST
27316: PPUSH
27317: CALL_OW 446
27321: GO 27245
27323: POP
27324: POP
// end ;
27325: LD_VAR 0 3
27329: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
27330: LD_INT 0
27332: PPUSH
27333: PPUSH
27334: PPUSH
27335: PPUSH
27336: PPUSH
27337: PPUSH
// if not vehicle or GetControl ( vehicle ) <> control_remote then
27338: LD_VAR 0 1
27342: NOT
27343: PUSH
27344: LD_VAR 0 1
27348: PPUSH
27349: CALL_OW 263
27353: PUSH
27354: LD_INT 2
27356: NONEQUAL
27357: OR
27358: IFFALSE 27362
// exit ;
27360: GO 27678
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
27362: LD_ADDR_VAR 0 6
27366: PUSH
27367: LD_INT 22
27369: PUSH
27370: LD_VAR 0 1
27374: PPUSH
27375: CALL_OW 255
27379: PUSH
27380: EMPTY
27381: LIST
27382: LIST
27383: PUSH
27384: LD_INT 2
27386: PUSH
27387: LD_INT 30
27389: PUSH
27390: LD_INT 36
27392: PUSH
27393: EMPTY
27394: LIST
27395: LIST
27396: PUSH
27397: LD_INT 34
27399: PUSH
27400: LD_INT 31
27402: PUSH
27403: EMPTY
27404: LIST
27405: LIST
27406: PUSH
27407: EMPTY
27408: LIST
27409: LIST
27410: LIST
27411: PUSH
27412: EMPTY
27413: LIST
27414: LIST
27415: PPUSH
27416: CALL_OW 69
27420: ST_TO_ADDR
// if not tmp then
27421: LD_VAR 0 6
27425: NOT
27426: IFFALSE 27430
// exit ;
27428: GO 27678
// result := [ ] ;
27430: LD_ADDR_VAR 0 2
27434: PUSH
27435: EMPTY
27436: ST_TO_ADDR
// for i in tmp do
27437: LD_ADDR_VAR 0 3
27441: PUSH
27442: LD_VAR 0 6
27446: PUSH
27447: FOR_IN
27448: IFFALSE 27519
// begin t := UnitsInside ( i ) ;
27450: LD_ADDR_VAR 0 4
27454: PUSH
27455: LD_VAR 0 3
27459: PPUSH
27460: CALL_OW 313
27464: ST_TO_ADDR
// if t then
27465: LD_VAR 0 4
27469: IFFALSE 27517
// for j in t do
27471: LD_ADDR_VAR 0 7
27475: PUSH
27476: LD_VAR 0 4
27480: PUSH
27481: FOR_IN
27482: IFFALSE 27515
// result := Replace ( result , result + 1 , j ) ;
27484: LD_ADDR_VAR 0 2
27488: PUSH
27489: LD_VAR 0 2
27493: PPUSH
27494: LD_VAR 0 2
27498: PUSH
27499: LD_INT 1
27501: PLUS
27502: PPUSH
27503: LD_VAR 0 7
27507: PPUSH
27508: CALL_OW 1
27512: ST_TO_ADDR
27513: GO 27481
27515: POP
27516: POP
// end ;
27517: GO 27447
27519: POP
27520: POP
// if not result then
27521: LD_VAR 0 2
27525: NOT
27526: IFFALSE 27530
// exit ;
27528: GO 27678
// mech := result [ 1 ] ;
27530: LD_ADDR_VAR 0 5
27534: PUSH
27535: LD_VAR 0 2
27539: PUSH
27540: LD_INT 1
27542: ARRAY
27543: ST_TO_ADDR
// if result > 1 then
27544: LD_VAR 0 2
27548: PUSH
27549: LD_INT 1
27551: GREATER
27552: IFFALSE 27664
// begin for i = 2 to result do
27554: LD_ADDR_VAR 0 3
27558: PUSH
27559: DOUBLE
27560: LD_INT 2
27562: DEC
27563: ST_TO_ADDR
27564: LD_VAR 0 2
27568: PUSH
27569: FOR_TO
27570: IFFALSE 27662
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
27572: LD_ADDR_VAR 0 4
27576: PUSH
27577: LD_VAR 0 2
27581: PUSH
27582: LD_VAR 0 3
27586: ARRAY
27587: PPUSH
27588: LD_INT 3
27590: PPUSH
27591: CALL_OW 259
27595: PUSH
27596: LD_VAR 0 2
27600: PUSH
27601: LD_VAR 0 3
27605: ARRAY
27606: PPUSH
27607: CALL_OW 432
27611: MINUS
27612: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
27613: LD_VAR 0 4
27617: PUSH
27618: LD_VAR 0 5
27622: PPUSH
27623: LD_INT 3
27625: PPUSH
27626: CALL_OW 259
27630: PUSH
27631: LD_VAR 0 5
27635: PPUSH
27636: CALL_OW 432
27640: MINUS
27641: GREATEREQUAL
27642: IFFALSE 27660
// mech := result [ i ] ;
27644: LD_ADDR_VAR 0 5
27648: PUSH
27649: LD_VAR 0 2
27653: PUSH
27654: LD_VAR 0 3
27658: ARRAY
27659: ST_TO_ADDR
// end ;
27660: GO 27569
27662: POP
27663: POP
// end ; ComLinkTo ( vehicle , mech ) ;
27664: LD_VAR 0 1
27668: PPUSH
27669: LD_VAR 0 5
27673: PPUSH
27674: CALL_OW 135
// end ;
27678: LD_VAR 0 2
27682: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
27683: LD_INT 0
27685: PPUSH
27686: PPUSH
27687: PPUSH
27688: PPUSH
27689: PPUSH
27690: PPUSH
27691: PPUSH
27692: PPUSH
27693: PPUSH
27694: PPUSH
27695: PPUSH
27696: PPUSH
27697: PPUSH
// result := [ ] ;
27698: LD_ADDR_VAR 0 7
27702: PUSH
27703: EMPTY
27704: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
27705: LD_VAR 0 1
27709: PPUSH
27710: CALL_OW 266
27714: PUSH
27715: LD_INT 0
27717: PUSH
27718: LD_INT 1
27720: PUSH
27721: EMPTY
27722: LIST
27723: LIST
27724: IN
27725: NOT
27726: IFFALSE 27730
// exit ;
27728: GO 29364
// if name then
27730: LD_VAR 0 3
27734: IFFALSE 27750
// SetBName ( base_dep , name ) ;
27736: LD_VAR 0 1
27740: PPUSH
27741: LD_VAR 0 3
27745: PPUSH
27746: CALL_OW 500
// base := GetBase ( base_dep ) ;
27750: LD_ADDR_VAR 0 15
27754: PUSH
27755: LD_VAR 0 1
27759: PPUSH
27760: CALL_OW 274
27764: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
27765: LD_ADDR_VAR 0 16
27769: PUSH
27770: LD_VAR 0 1
27774: PPUSH
27775: CALL_OW 255
27779: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
27780: LD_ADDR_VAR 0 17
27784: PUSH
27785: LD_VAR 0 1
27789: PPUSH
27790: CALL_OW 248
27794: ST_TO_ADDR
// if sources then
27795: LD_VAR 0 5
27799: IFFALSE 27846
// for i = 1 to 3 do
27801: LD_ADDR_VAR 0 8
27805: PUSH
27806: DOUBLE
27807: LD_INT 1
27809: DEC
27810: ST_TO_ADDR
27811: LD_INT 3
27813: PUSH
27814: FOR_TO
27815: IFFALSE 27844
// AddResourceType ( base , i , sources [ i ] ) ;
27817: LD_VAR 0 15
27821: PPUSH
27822: LD_VAR 0 8
27826: PPUSH
27827: LD_VAR 0 5
27831: PUSH
27832: LD_VAR 0 8
27836: ARRAY
27837: PPUSH
27838: CALL_OW 276
27842: GO 27814
27844: POP
27845: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
27846: LD_ADDR_VAR 0 18
27850: PUSH
27851: LD_VAR 0 15
27855: PPUSH
27856: LD_VAR 0 2
27860: PPUSH
27861: LD_INT 1
27863: PPUSH
27864: CALL 27107 0 3
27868: ST_TO_ADDR
// InitHc ;
27869: CALL_OW 19
// InitUc ;
27873: CALL_OW 18
// uc_side := side ;
27877: LD_ADDR_OWVAR 20
27881: PUSH
27882: LD_VAR 0 16
27886: ST_TO_ADDR
// uc_nation := nation ;
27887: LD_ADDR_OWVAR 21
27891: PUSH
27892: LD_VAR 0 17
27896: ST_TO_ADDR
// if buildings then
27897: LD_VAR 0 18
27901: IFFALSE 29223
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
27903: LD_ADDR_VAR 0 19
27907: PUSH
27908: LD_VAR 0 18
27912: PPUSH
27913: LD_INT 2
27915: PUSH
27916: LD_INT 30
27918: PUSH
27919: LD_INT 29
27921: PUSH
27922: EMPTY
27923: LIST
27924: LIST
27925: PUSH
27926: LD_INT 30
27928: PUSH
27929: LD_INT 30
27931: PUSH
27932: EMPTY
27933: LIST
27934: LIST
27935: PUSH
27936: EMPTY
27937: LIST
27938: LIST
27939: LIST
27940: PPUSH
27941: CALL_OW 72
27945: ST_TO_ADDR
// if tmp then
27946: LD_VAR 0 19
27950: IFFALSE 27998
// for i in tmp do
27952: LD_ADDR_VAR 0 8
27956: PUSH
27957: LD_VAR 0 19
27961: PUSH
27962: FOR_IN
27963: IFFALSE 27996
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
27965: LD_VAR 0 8
27969: PPUSH
27970: CALL_OW 250
27974: PPUSH
27975: LD_VAR 0 8
27979: PPUSH
27980: CALL_OW 251
27984: PPUSH
27985: LD_VAR 0 16
27989: PPUSH
27990: CALL_OW 441
27994: GO 27962
27996: POP
27997: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
27998: LD_VAR 0 18
28002: PPUSH
28003: LD_INT 2
28005: PUSH
28006: LD_INT 30
28008: PUSH
28009: LD_INT 32
28011: PUSH
28012: EMPTY
28013: LIST
28014: LIST
28015: PUSH
28016: LD_INT 30
28018: PUSH
28019: LD_INT 33
28021: PUSH
28022: EMPTY
28023: LIST
28024: LIST
28025: PUSH
28026: EMPTY
28027: LIST
28028: LIST
28029: LIST
28030: PPUSH
28031: CALL_OW 72
28035: IFFALSE 28123
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
28037: LD_ADDR_VAR 0 8
28041: PUSH
28042: LD_VAR 0 18
28046: PPUSH
28047: LD_INT 2
28049: PUSH
28050: LD_INT 30
28052: PUSH
28053: LD_INT 32
28055: PUSH
28056: EMPTY
28057: LIST
28058: LIST
28059: PUSH
28060: LD_INT 30
28062: PUSH
28063: LD_INT 33
28065: PUSH
28066: EMPTY
28067: LIST
28068: LIST
28069: PUSH
28070: EMPTY
28071: LIST
28072: LIST
28073: LIST
28074: PPUSH
28075: CALL_OW 72
28079: PUSH
28080: FOR_IN
28081: IFFALSE 28121
// begin if not GetBWeapon ( i ) then
28083: LD_VAR 0 8
28087: PPUSH
28088: CALL_OW 269
28092: NOT
28093: IFFALSE 28119
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
28095: LD_VAR 0 8
28099: PPUSH
28100: LD_VAR 0 8
28104: PPUSH
28105: LD_VAR 0 2
28109: PPUSH
28110: CALL 29369 0 2
28114: PPUSH
28115: CALL_OW 431
// end ;
28119: GO 28080
28121: POP
28122: POP
// end ; for i = 1 to personel do
28123: LD_ADDR_VAR 0 8
28127: PUSH
28128: DOUBLE
28129: LD_INT 1
28131: DEC
28132: ST_TO_ADDR
28133: LD_VAR 0 6
28137: PUSH
28138: FOR_TO
28139: IFFALSE 29203
// begin if i > 4 then
28141: LD_VAR 0 8
28145: PUSH
28146: LD_INT 4
28148: GREATER
28149: IFFALSE 28153
// break ;
28151: GO 29203
// case i of 1 :
28153: LD_VAR 0 8
28157: PUSH
28158: LD_INT 1
28160: DOUBLE
28161: EQUAL
28162: IFTRUE 28166
28164: GO 28246
28166: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
28167: LD_ADDR_VAR 0 12
28171: PUSH
28172: LD_VAR 0 18
28176: PPUSH
28177: LD_INT 22
28179: PUSH
28180: LD_VAR 0 16
28184: PUSH
28185: EMPTY
28186: LIST
28187: LIST
28188: PUSH
28189: LD_INT 58
28191: PUSH
28192: EMPTY
28193: LIST
28194: PUSH
28195: LD_INT 2
28197: PUSH
28198: LD_INT 30
28200: PUSH
28201: LD_INT 32
28203: PUSH
28204: EMPTY
28205: LIST
28206: LIST
28207: PUSH
28208: LD_INT 30
28210: PUSH
28211: LD_INT 4
28213: PUSH
28214: EMPTY
28215: LIST
28216: LIST
28217: PUSH
28218: LD_INT 30
28220: PUSH
28221: LD_INT 5
28223: PUSH
28224: EMPTY
28225: LIST
28226: LIST
28227: PUSH
28228: EMPTY
28229: LIST
28230: LIST
28231: LIST
28232: LIST
28233: PUSH
28234: EMPTY
28235: LIST
28236: LIST
28237: LIST
28238: PPUSH
28239: CALL_OW 72
28243: ST_TO_ADDR
28244: GO 28468
28246: LD_INT 2
28248: DOUBLE
28249: EQUAL
28250: IFTRUE 28254
28252: GO 28316
28254: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
28255: LD_ADDR_VAR 0 12
28259: PUSH
28260: LD_VAR 0 18
28264: PPUSH
28265: LD_INT 22
28267: PUSH
28268: LD_VAR 0 16
28272: PUSH
28273: EMPTY
28274: LIST
28275: LIST
28276: PUSH
28277: LD_INT 2
28279: PUSH
28280: LD_INT 30
28282: PUSH
28283: LD_INT 0
28285: PUSH
28286: EMPTY
28287: LIST
28288: LIST
28289: PUSH
28290: LD_INT 30
28292: PUSH
28293: LD_INT 1
28295: PUSH
28296: EMPTY
28297: LIST
28298: LIST
28299: PUSH
28300: EMPTY
28301: LIST
28302: LIST
28303: LIST
28304: PUSH
28305: EMPTY
28306: LIST
28307: LIST
28308: PPUSH
28309: CALL_OW 72
28313: ST_TO_ADDR
28314: GO 28468
28316: LD_INT 3
28318: DOUBLE
28319: EQUAL
28320: IFTRUE 28324
28322: GO 28386
28324: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
28325: LD_ADDR_VAR 0 12
28329: PUSH
28330: LD_VAR 0 18
28334: PPUSH
28335: LD_INT 22
28337: PUSH
28338: LD_VAR 0 16
28342: PUSH
28343: EMPTY
28344: LIST
28345: LIST
28346: PUSH
28347: LD_INT 2
28349: PUSH
28350: LD_INT 30
28352: PUSH
28353: LD_INT 2
28355: PUSH
28356: EMPTY
28357: LIST
28358: LIST
28359: PUSH
28360: LD_INT 30
28362: PUSH
28363: LD_INT 3
28365: PUSH
28366: EMPTY
28367: LIST
28368: LIST
28369: PUSH
28370: EMPTY
28371: LIST
28372: LIST
28373: LIST
28374: PUSH
28375: EMPTY
28376: LIST
28377: LIST
28378: PPUSH
28379: CALL_OW 72
28383: ST_TO_ADDR
28384: GO 28468
28386: LD_INT 4
28388: DOUBLE
28389: EQUAL
28390: IFTRUE 28394
28392: GO 28467
28394: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
28395: LD_ADDR_VAR 0 12
28399: PUSH
28400: LD_VAR 0 18
28404: PPUSH
28405: LD_INT 22
28407: PUSH
28408: LD_VAR 0 16
28412: PUSH
28413: EMPTY
28414: LIST
28415: LIST
28416: PUSH
28417: LD_INT 2
28419: PUSH
28420: LD_INT 30
28422: PUSH
28423: LD_INT 6
28425: PUSH
28426: EMPTY
28427: LIST
28428: LIST
28429: PUSH
28430: LD_INT 30
28432: PUSH
28433: LD_INT 7
28435: PUSH
28436: EMPTY
28437: LIST
28438: LIST
28439: PUSH
28440: LD_INT 30
28442: PUSH
28443: LD_INT 8
28445: PUSH
28446: EMPTY
28447: LIST
28448: LIST
28449: PUSH
28450: EMPTY
28451: LIST
28452: LIST
28453: LIST
28454: LIST
28455: PUSH
28456: EMPTY
28457: LIST
28458: LIST
28459: PPUSH
28460: CALL_OW 72
28464: ST_TO_ADDR
28465: GO 28468
28467: POP
// if i = 1 then
28468: LD_VAR 0 8
28472: PUSH
28473: LD_INT 1
28475: EQUAL
28476: IFFALSE 28587
// begin tmp := [ ] ;
28478: LD_ADDR_VAR 0 19
28482: PUSH
28483: EMPTY
28484: ST_TO_ADDR
// for j in f do
28485: LD_ADDR_VAR 0 9
28489: PUSH
28490: LD_VAR 0 12
28494: PUSH
28495: FOR_IN
28496: IFFALSE 28569
// if GetBType ( j ) = b_bunker then
28498: LD_VAR 0 9
28502: PPUSH
28503: CALL_OW 266
28507: PUSH
28508: LD_INT 32
28510: EQUAL
28511: IFFALSE 28538
// tmp := Insert ( tmp , 1 , j ) else
28513: LD_ADDR_VAR 0 19
28517: PUSH
28518: LD_VAR 0 19
28522: PPUSH
28523: LD_INT 1
28525: PPUSH
28526: LD_VAR 0 9
28530: PPUSH
28531: CALL_OW 2
28535: ST_TO_ADDR
28536: GO 28567
// tmp := Insert ( tmp , tmp + 1 , j ) ;
28538: LD_ADDR_VAR 0 19
28542: PUSH
28543: LD_VAR 0 19
28547: PPUSH
28548: LD_VAR 0 19
28552: PUSH
28553: LD_INT 1
28555: PLUS
28556: PPUSH
28557: LD_VAR 0 9
28561: PPUSH
28562: CALL_OW 2
28566: ST_TO_ADDR
28567: GO 28495
28569: POP
28570: POP
// if tmp then
28571: LD_VAR 0 19
28575: IFFALSE 28587
// f := tmp ;
28577: LD_ADDR_VAR 0 12
28581: PUSH
28582: LD_VAR 0 19
28586: ST_TO_ADDR
// end ; x := personel [ i ] ;
28587: LD_ADDR_VAR 0 13
28591: PUSH
28592: LD_VAR 0 6
28596: PUSH
28597: LD_VAR 0 8
28601: ARRAY
28602: ST_TO_ADDR
// if x = - 1 then
28603: LD_VAR 0 13
28607: PUSH
28608: LD_INT 1
28610: NEG
28611: EQUAL
28612: IFFALSE 28821
// begin for j in f do
28614: LD_ADDR_VAR 0 9
28618: PUSH
28619: LD_VAR 0 12
28623: PUSH
28624: FOR_IN
28625: IFFALSE 28817
// repeat InitHc ;
28627: CALL_OW 19
// if GetBType ( j ) = b_barracks then
28631: LD_VAR 0 9
28635: PPUSH
28636: CALL_OW 266
28640: PUSH
28641: LD_INT 5
28643: EQUAL
28644: IFFALSE 28714
// begin if UnitsInside ( j ) < 3 then
28646: LD_VAR 0 9
28650: PPUSH
28651: CALL_OW 313
28655: PUSH
28656: LD_INT 3
28658: LESS
28659: IFFALSE 28695
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
28661: LD_INT 0
28663: PPUSH
28664: LD_INT 5
28666: PUSH
28667: LD_INT 8
28669: PUSH
28670: LD_INT 9
28672: PUSH
28673: EMPTY
28674: LIST
28675: LIST
28676: LIST
28677: PUSH
28678: LD_VAR 0 17
28682: ARRAY
28683: PPUSH
28684: LD_VAR 0 4
28688: PPUSH
28689: CALL_OW 380
28693: GO 28712
// PrepareHuman ( false , i , skill ) ;
28695: LD_INT 0
28697: PPUSH
28698: LD_VAR 0 8
28702: PPUSH
28703: LD_VAR 0 4
28707: PPUSH
28708: CALL_OW 380
// end else
28712: GO 28731
// PrepareHuman ( false , i , skill ) ;
28714: LD_INT 0
28716: PPUSH
28717: LD_VAR 0 8
28721: PPUSH
28722: LD_VAR 0 4
28726: PPUSH
28727: CALL_OW 380
// un := CreateHuman ;
28731: LD_ADDR_VAR 0 14
28735: PUSH
28736: CALL_OW 44
28740: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
28741: LD_ADDR_VAR 0 7
28745: PUSH
28746: LD_VAR 0 7
28750: PPUSH
28751: LD_INT 1
28753: PPUSH
28754: LD_VAR 0 14
28758: PPUSH
28759: CALL_OW 2
28763: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
28764: LD_VAR 0 14
28768: PPUSH
28769: LD_VAR 0 9
28773: PPUSH
28774: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
28778: LD_VAR 0 9
28782: PPUSH
28783: CALL_OW 313
28787: PUSH
28788: LD_INT 6
28790: EQUAL
28791: PUSH
28792: LD_VAR 0 9
28796: PPUSH
28797: CALL_OW 266
28801: PUSH
28802: LD_INT 32
28804: PUSH
28805: LD_INT 31
28807: PUSH
28808: EMPTY
28809: LIST
28810: LIST
28811: IN
28812: OR
28813: IFFALSE 28627
28815: GO 28624
28817: POP
28818: POP
// end else
28819: GO 29201
// for j = 1 to x do
28821: LD_ADDR_VAR 0 9
28825: PUSH
28826: DOUBLE
28827: LD_INT 1
28829: DEC
28830: ST_TO_ADDR
28831: LD_VAR 0 13
28835: PUSH
28836: FOR_TO
28837: IFFALSE 29199
// begin InitHc ;
28839: CALL_OW 19
// if not f then
28843: LD_VAR 0 12
28847: NOT
28848: IFFALSE 28937
// begin PrepareHuman ( false , i , skill ) ;
28850: LD_INT 0
28852: PPUSH
28853: LD_VAR 0 8
28857: PPUSH
28858: LD_VAR 0 4
28862: PPUSH
28863: CALL_OW 380
// un := CreateHuman ;
28867: LD_ADDR_VAR 0 14
28871: PUSH
28872: CALL_OW 44
28876: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
28877: LD_ADDR_VAR 0 7
28881: PUSH
28882: LD_VAR 0 7
28886: PPUSH
28887: LD_INT 1
28889: PPUSH
28890: LD_VAR 0 14
28894: PPUSH
28895: CALL_OW 2
28899: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
28900: LD_VAR 0 14
28904: PPUSH
28905: LD_VAR 0 1
28909: PPUSH
28910: CALL_OW 250
28914: PPUSH
28915: LD_VAR 0 1
28919: PPUSH
28920: CALL_OW 251
28924: PPUSH
28925: LD_INT 10
28927: PPUSH
28928: LD_INT 0
28930: PPUSH
28931: CALL_OW 50
// continue ;
28935: GO 28836
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
28937: LD_VAR 0 12
28941: PUSH
28942: LD_INT 1
28944: ARRAY
28945: PPUSH
28946: CALL_OW 313
28950: PUSH
28951: LD_VAR 0 12
28955: PUSH
28956: LD_INT 1
28958: ARRAY
28959: PPUSH
28960: CALL_OW 266
28964: PUSH
28965: LD_INT 32
28967: PUSH
28968: LD_INT 31
28970: PUSH
28971: EMPTY
28972: LIST
28973: LIST
28974: IN
28975: AND
28976: PUSH
28977: LD_VAR 0 12
28981: PUSH
28982: LD_INT 1
28984: ARRAY
28985: PPUSH
28986: CALL_OW 313
28990: PUSH
28991: LD_INT 6
28993: EQUAL
28994: OR
28995: IFFALSE 29015
// f := Delete ( f , 1 ) ;
28997: LD_ADDR_VAR 0 12
29001: PUSH
29002: LD_VAR 0 12
29006: PPUSH
29007: LD_INT 1
29009: PPUSH
29010: CALL_OW 3
29014: ST_TO_ADDR
// if not f then
29015: LD_VAR 0 12
29019: NOT
29020: IFFALSE 29038
// begin x := x + 2 ;
29022: LD_ADDR_VAR 0 13
29026: PUSH
29027: LD_VAR 0 13
29031: PUSH
29032: LD_INT 2
29034: PLUS
29035: ST_TO_ADDR
// continue ;
29036: GO 28836
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
29038: LD_VAR 0 12
29042: PUSH
29043: LD_INT 1
29045: ARRAY
29046: PPUSH
29047: CALL_OW 266
29051: PUSH
29052: LD_INT 5
29054: EQUAL
29055: IFFALSE 29129
// begin if UnitsInside ( f [ 1 ] ) < 3 then
29057: LD_VAR 0 12
29061: PUSH
29062: LD_INT 1
29064: ARRAY
29065: PPUSH
29066: CALL_OW 313
29070: PUSH
29071: LD_INT 3
29073: LESS
29074: IFFALSE 29110
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
29076: LD_INT 0
29078: PPUSH
29079: LD_INT 5
29081: PUSH
29082: LD_INT 8
29084: PUSH
29085: LD_INT 9
29087: PUSH
29088: EMPTY
29089: LIST
29090: LIST
29091: LIST
29092: PUSH
29093: LD_VAR 0 17
29097: ARRAY
29098: PPUSH
29099: LD_VAR 0 4
29103: PPUSH
29104: CALL_OW 380
29108: GO 29127
// PrepareHuman ( false , i , skill ) ;
29110: LD_INT 0
29112: PPUSH
29113: LD_VAR 0 8
29117: PPUSH
29118: LD_VAR 0 4
29122: PPUSH
29123: CALL_OW 380
// end else
29127: GO 29146
// PrepareHuman ( false , i , skill ) ;
29129: LD_INT 0
29131: PPUSH
29132: LD_VAR 0 8
29136: PPUSH
29137: LD_VAR 0 4
29141: PPUSH
29142: CALL_OW 380
// un := CreateHuman ;
29146: LD_ADDR_VAR 0 14
29150: PUSH
29151: CALL_OW 44
29155: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
29156: LD_ADDR_VAR 0 7
29160: PUSH
29161: LD_VAR 0 7
29165: PPUSH
29166: LD_INT 1
29168: PPUSH
29169: LD_VAR 0 14
29173: PPUSH
29174: CALL_OW 2
29178: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
29179: LD_VAR 0 14
29183: PPUSH
29184: LD_VAR 0 12
29188: PUSH
29189: LD_INT 1
29191: ARRAY
29192: PPUSH
29193: CALL_OW 52
// end ;
29197: GO 28836
29199: POP
29200: POP
// end ;
29201: GO 28138
29203: POP
29204: POP
// result := result ^ buildings ;
29205: LD_ADDR_VAR 0 7
29209: PUSH
29210: LD_VAR 0 7
29214: PUSH
29215: LD_VAR 0 18
29219: ADD
29220: ST_TO_ADDR
// end else
29221: GO 29364
// begin for i = 1 to personel do
29223: LD_ADDR_VAR 0 8
29227: PUSH
29228: DOUBLE
29229: LD_INT 1
29231: DEC
29232: ST_TO_ADDR
29233: LD_VAR 0 6
29237: PUSH
29238: FOR_TO
29239: IFFALSE 29362
// begin if i > 4 then
29241: LD_VAR 0 8
29245: PUSH
29246: LD_INT 4
29248: GREATER
29249: IFFALSE 29253
// break ;
29251: GO 29362
// x := personel [ i ] ;
29253: LD_ADDR_VAR 0 13
29257: PUSH
29258: LD_VAR 0 6
29262: PUSH
29263: LD_VAR 0 8
29267: ARRAY
29268: ST_TO_ADDR
// if x = - 1 then
29269: LD_VAR 0 13
29273: PUSH
29274: LD_INT 1
29276: NEG
29277: EQUAL
29278: IFFALSE 29282
// continue ;
29280: GO 29238
// PrepareHuman ( false , i , skill ) ;
29282: LD_INT 0
29284: PPUSH
29285: LD_VAR 0 8
29289: PPUSH
29290: LD_VAR 0 4
29294: PPUSH
29295: CALL_OW 380
// un := CreateHuman ;
29299: LD_ADDR_VAR 0 14
29303: PUSH
29304: CALL_OW 44
29308: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
29309: LD_VAR 0 14
29313: PPUSH
29314: LD_VAR 0 1
29318: PPUSH
29319: CALL_OW 250
29323: PPUSH
29324: LD_VAR 0 1
29328: PPUSH
29329: CALL_OW 251
29333: PPUSH
29334: LD_INT 10
29336: PPUSH
29337: LD_INT 0
29339: PPUSH
29340: CALL_OW 50
// result := result ^ un ;
29344: LD_ADDR_VAR 0 7
29348: PUSH
29349: LD_VAR 0 7
29353: PUSH
29354: LD_VAR 0 14
29358: ADD
29359: ST_TO_ADDR
// end ;
29360: GO 29238
29362: POP
29363: POP
// end ; end ;
29364: LD_VAR 0 7
29368: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
29369: LD_INT 0
29371: PPUSH
29372: PPUSH
29373: PPUSH
29374: PPUSH
29375: PPUSH
29376: PPUSH
29377: PPUSH
29378: PPUSH
29379: PPUSH
29380: PPUSH
29381: PPUSH
29382: PPUSH
29383: PPUSH
29384: PPUSH
29385: PPUSH
29386: PPUSH
// result := false ;
29387: LD_ADDR_VAR 0 3
29391: PUSH
29392: LD_INT 0
29394: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
29395: LD_VAR 0 1
29399: NOT
29400: PUSH
29401: LD_VAR 0 1
29405: PPUSH
29406: CALL_OW 266
29410: PUSH
29411: LD_INT 32
29413: PUSH
29414: LD_INT 33
29416: PUSH
29417: EMPTY
29418: LIST
29419: LIST
29420: IN
29421: NOT
29422: OR
29423: IFFALSE 29427
// exit ;
29425: GO 30536
// nat := GetNation ( tower ) ;
29427: LD_ADDR_VAR 0 12
29431: PUSH
29432: LD_VAR 0 1
29436: PPUSH
29437: CALL_OW 248
29441: ST_TO_ADDR
// side := GetSide ( tower ) ;
29442: LD_ADDR_VAR 0 16
29446: PUSH
29447: LD_VAR 0 1
29451: PPUSH
29452: CALL_OW 255
29456: ST_TO_ADDR
// x := GetX ( tower ) ;
29457: LD_ADDR_VAR 0 10
29461: PUSH
29462: LD_VAR 0 1
29466: PPUSH
29467: CALL_OW 250
29471: ST_TO_ADDR
// y := GetY ( tower ) ;
29472: LD_ADDR_VAR 0 11
29476: PUSH
29477: LD_VAR 0 1
29481: PPUSH
29482: CALL_OW 251
29486: ST_TO_ADDR
// if not x or not y then
29487: LD_VAR 0 10
29491: NOT
29492: PUSH
29493: LD_VAR 0 11
29497: NOT
29498: OR
29499: IFFALSE 29503
// exit ;
29501: GO 30536
// weapon := 0 ;
29503: LD_ADDR_VAR 0 18
29507: PUSH
29508: LD_INT 0
29510: ST_TO_ADDR
// fac_list := [ ] ;
29511: LD_ADDR_VAR 0 17
29515: PUSH
29516: EMPTY
29517: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
29518: LD_ADDR_VAR 0 6
29522: PUSH
29523: LD_VAR 0 1
29527: PPUSH
29528: CALL_OW 274
29532: PPUSH
29533: LD_VAR 0 2
29537: PPUSH
29538: LD_INT 0
29540: PPUSH
29541: CALL 27107 0 3
29545: PPUSH
29546: LD_INT 30
29548: PUSH
29549: LD_INT 3
29551: PUSH
29552: EMPTY
29553: LIST
29554: LIST
29555: PPUSH
29556: CALL_OW 72
29560: ST_TO_ADDR
// if not factories then
29561: LD_VAR 0 6
29565: NOT
29566: IFFALSE 29570
// exit ;
29568: GO 30536
// for i in factories do
29570: LD_ADDR_VAR 0 8
29574: PUSH
29575: LD_VAR 0 6
29579: PUSH
29580: FOR_IN
29581: IFFALSE 29606
// fac_list := fac_list union AvailableWeaponList ( i ) ;
29583: LD_ADDR_VAR 0 17
29587: PUSH
29588: LD_VAR 0 17
29592: PUSH
29593: LD_VAR 0 8
29597: PPUSH
29598: CALL_OW 478
29602: UNION
29603: ST_TO_ADDR
29604: GO 29580
29606: POP
29607: POP
// if not fac_list then
29608: LD_VAR 0 17
29612: NOT
29613: IFFALSE 29617
// exit ;
29615: GO 30536
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
29617: LD_ADDR_VAR 0 5
29621: PUSH
29622: LD_INT 4
29624: PUSH
29625: LD_INT 5
29627: PUSH
29628: LD_INT 9
29630: PUSH
29631: LD_INT 10
29633: PUSH
29634: LD_INT 6
29636: PUSH
29637: LD_INT 7
29639: PUSH
29640: LD_INT 11
29642: PUSH
29643: EMPTY
29644: LIST
29645: LIST
29646: LIST
29647: LIST
29648: LIST
29649: LIST
29650: LIST
29651: PUSH
29652: LD_INT 27
29654: PUSH
29655: LD_INT 28
29657: PUSH
29658: LD_INT 26
29660: PUSH
29661: LD_INT 30
29663: PUSH
29664: EMPTY
29665: LIST
29666: LIST
29667: LIST
29668: LIST
29669: PUSH
29670: LD_INT 43
29672: PUSH
29673: LD_INT 44
29675: PUSH
29676: LD_INT 46
29678: PUSH
29679: LD_INT 45
29681: PUSH
29682: LD_INT 47
29684: PUSH
29685: LD_INT 49
29687: PUSH
29688: EMPTY
29689: LIST
29690: LIST
29691: LIST
29692: LIST
29693: LIST
29694: LIST
29695: PUSH
29696: EMPTY
29697: LIST
29698: LIST
29699: LIST
29700: PUSH
29701: LD_VAR 0 12
29705: ARRAY
29706: ST_TO_ADDR
// list := list isect fac_list ;
29707: LD_ADDR_VAR 0 5
29711: PUSH
29712: LD_VAR 0 5
29716: PUSH
29717: LD_VAR 0 17
29721: ISECT
29722: ST_TO_ADDR
// if not list then
29723: LD_VAR 0 5
29727: NOT
29728: IFFALSE 29732
// exit ;
29730: GO 30536
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
29732: LD_VAR 0 12
29736: PUSH
29737: LD_INT 3
29739: EQUAL
29740: PUSH
29741: LD_INT 49
29743: PUSH
29744: LD_VAR 0 5
29748: IN
29749: AND
29750: PUSH
29751: LD_INT 31
29753: PPUSH
29754: LD_VAR 0 16
29758: PPUSH
29759: CALL_OW 321
29763: PUSH
29764: LD_INT 2
29766: EQUAL
29767: AND
29768: IFFALSE 29828
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
29770: LD_INT 22
29772: PUSH
29773: LD_VAR 0 16
29777: PUSH
29778: EMPTY
29779: LIST
29780: LIST
29781: PUSH
29782: LD_INT 35
29784: PUSH
29785: LD_INT 49
29787: PUSH
29788: EMPTY
29789: LIST
29790: LIST
29791: PUSH
29792: LD_INT 91
29794: PUSH
29795: LD_VAR 0 1
29799: PUSH
29800: LD_INT 10
29802: PUSH
29803: EMPTY
29804: LIST
29805: LIST
29806: LIST
29807: PUSH
29808: EMPTY
29809: LIST
29810: LIST
29811: LIST
29812: PPUSH
29813: CALL_OW 69
29817: NOT
29818: IFFALSE 29828
// weapon := ru_time_lapser ;
29820: LD_ADDR_VAR 0 18
29824: PUSH
29825: LD_INT 49
29827: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
29828: LD_VAR 0 12
29832: PUSH
29833: LD_INT 1
29835: PUSH
29836: LD_INT 2
29838: PUSH
29839: EMPTY
29840: LIST
29841: LIST
29842: IN
29843: PUSH
29844: LD_INT 11
29846: PUSH
29847: LD_VAR 0 5
29851: IN
29852: PUSH
29853: LD_INT 30
29855: PUSH
29856: LD_VAR 0 5
29860: IN
29861: OR
29862: AND
29863: PUSH
29864: LD_INT 6
29866: PPUSH
29867: LD_VAR 0 16
29871: PPUSH
29872: CALL_OW 321
29876: PUSH
29877: LD_INT 2
29879: EQUAL
29880: AND
29881: IFFALSE 30046
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
29883: LD_INT 22
29885: PUSH
29886: LD_VAR 0 16
29890: PUSH
29891: EMPTY
29892: LIST
29893: LIST
29894: PUSH
29895: LD_INT 2
29897: PUSH
29898: LD_INT 35
29900: PUSH
29901: LD_INT 11
29903: PUSH
29904: EMPTY
29905: LIST
29906: LIST
29907: PUSH
29908: LD_INT 35
29910: PUSH
29911: LD_INT 30
29913: PUSH
29914: EMPTY
29915: LIST
29916: LIST
29917: PUSH
29918: EMPTY
29919: LIST
29920: LIST
29921: LIST
29922: PUSH
29923: LD_INT 91
29925: PUSH
29926: LD_VAR 0 1
29930: PUSH
29931: LD_INT 18
29933: PUSH
29934: EMPTY
29935: LIST
29936: LIST
29937: LIST
29938: PUSH
29939: EMPTY
29940: LIST
29941: LIST
29942: LIST
29943: PPUSH
29944: CALL_OW 69
29948: NOT
29949: PUSH
29950: LD_INT 22
29952: PUSH
29953: LD_VAR 0 16
29957: PUSH
29958: EMPTY
29959: LIST
29960: LIST
29961: PUSH
29962: LD_INT 2
29964: PUSH
29965: LD_INT 30
29967: PUSH
29968: LD_INT 32
29970: PUSH
29971: EMPTY
29972: LIST
29973: LIST
29974: PUSH
29975: LD_INT 30
29977: PUSH
29978: LD_INT 33
29980: PUSH
29981: EMPTY
29982: LIST
29983: LIST
29984: PUSH
29985: EMPTY
29986: LIST
29987: LIST
29988: LIST
29989: PUSH
29990: LD_INT 91
29992: PUSH
29993: LD_VAR 0 1
29997: PUSH
29998: LD_INT 12
30000: PUSH
30001: EMPTY
30002: LIST
30003: LIST
30004: LIST
30005: PUSH
30006: EMPTY
30007: LIST
30008: LIST
30009: LIST
30010: PUSH
30011: EMPTY
30012: LIST
30013: PPUSH
30014: CALL_OW 69
30018: PUSH
30019: LD_INT 2
30021: GREATER
30022: AND
30023: IFFALSE 30046
// weapon := [ us_radar , ar_radar ] [ nat ] ;
30025: LD_ADDR_VAR 0 18
30029: PUSH
30030: LD_INT 11
30032: PUSH
30033: LD_INT 30
30035: PUSH
30036: EMPTY
30037: LIST
30038: LIST
30039: PUSH
30040: LD_VAR 0 12
30044: ARRAY
30045: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
30046: LD_VAR 0 18
30050: NOT
30051: PUSH
30052: LD_INT 40
30054: PPUSH
30055: LD_VAR 0 16
30059: PPUSH
30060: CALL_OW 321
30064: PUSH
30065: LD_INT 2
30067: EQUAL
30068: AND
30069: PUSH
30070: LD_INT 7
30072: PUSH
30073: LD_VAR 0 5
30077: IN
30078: PUSH
30079: LD_INT 28
30081: PUSH
30082: LD_VAR 0 5
30086: IN
30087: OR
30088: PUSH
30089: LD_INT 45
30091: PUSH
30092: LD_VAR 0 5
30096: IN
30097: OR
30098: AND
30099: IFFALSE 30353
// begin hex := GetHexInfo ( x , y ) ;
30101: LD_ADDR_VAR 0 4
30105: PUSH
30106: LD_VAR 0 10
30110: PPUSH
30111: LD_VAR 0 11
30115: PPUSH
30116: CALL_OW 546
30120: ST_TO_ADDR
// if hex [ 1 ] then
30121: LD_VAR 0 4
30125: PUSH
30126: LD_INT 1
30128: ARRAY
30129: IFFALSE 30133
// exit ;
30131: GO 30536
// height := hex [ 2 ] ;
30133: LD_ADDR_VAR 0 15
30137: PUSH
30138: LD_VAR 0 4
30142: PUSH
30143: LD_INT 2
30145: ARRAY
30146: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
30147: LD_ADDR_VAR 0 14
30151: PUSH
30152: LD_INT 0
30154: PUSH
30155: LD_INT 2
30157: PUSH
30158: LD_INT 3
30160: PUSH
30161: LD_INT 5
30163: PUSH
30164: EMPTY
30165: LIST
30166: LIST
30167: LIST
30168: LIST
30169: ST_TO_ADDR
// for i in tmp do
30170: LD_ADDR_VAR 0 8
30174: PUSH
30175: LD_VAR 0 14
30179: PUSH
30180: FOR_IN
30181: IFFALSE 30351
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
30183: LD_ADDR_VAR 0 9
30187: PUSH
30188: LD_VAR 0 10
30192: PPUSH
30193: LD_VAR 0 8
30197: PPUSH
30198: LD_INT 5
30200: PPUSH
30201: CALL_OW 272
30205: PUSH
30206: LD_VAR 0 11
30210: PPUSH
30211: LD_VAR 0 8
30215: PPUSH
30216: LD_INT 5
30218: PPUSH
30219: CALL_OW 273
30223: PUSH
30224: EMPTY
30225: LIST
30226: LIST
30227: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
30228: LD_VAR 0 9
30232: PUSH
30233: LD_INT 1
30235: ARRAY
30236: PPUSH
30237: LD_VAR 0 9
30241: PUSH
30242: LD_INT 2
30244: ARRAY
30245: PPUSH
30246: CALL_OW 488
30250: IFFALSE 30349
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
30252: LD_ADDR_VAR 0 4
30256: PUSH
30257: LD_VAR 0 9
30261: PUSH
30262: LD_INT 1
30264: ARRAY
30265: PPUSH
30266: LD_VAR 0 9
30270: PUSH
30271: LD_INT 2
30273: ARRAY
30274: PPUSH
30275: CALL_OW 546
30279: ST_TO_ADDR
// if hex [ 1 ] then
30280: LD_VAR 0 4
30284: PUSH
30285: LD_INT 1
30287: ARRAY
30288: IFFALSE 30292
// continue ;
30290: GO 30180
// h := hex [ 2 ] ;
30292: LD_ADDR_VAR 0 13
30296: PUSH
30297: LD_VAR 0 4
30301: PUSH
30302: LD_INT 2
30304: ARRAY
30305: ST_TO_ADDR
// if h + 7 < height then
30306: LD_VAR 0 13
30310: PUSH
30311: LD_INT 7
30313: PLUS
30314: PUSH
30315: LD_VAR 0 15
30319: LESS
30320: IFFALSE 30349
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
30322: LD_ADDR_VAR 0 18
30326: PUSH
30327: LD_INT 7
30329: PUSH
30330: LD_INT 28
30332: PUSH
30333: LD_INT 45
30335: PUSH
30336: EMPTY
30337: LIST
30338: LIST
30339: LIST
30340: PUSH
30341: LD_VAR 0 12
30345: ARRAY
30346: ST_TO_ADDR
// break ;
30347: GO 30351
// end ; end ; end ;
30349: GO 30180
30351: POP
30352: POP
// end ; if not weapon then
30353: LD_VAR 0 18
30357: NOT
30358: IFFALSE 30418
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
30360: LD_ADDR_VAR 0 5
30364: PUSH
30365: LD_VAR 0 5
30369: PUSH
30370: LD_INT 11
30372: PUSH
30373: LD_INT 30
30375: PUSH
30376: LD_INT 49
30378: PUSH
30379: EMPTY
30380: LIST
30381: LIST
30382: LIST
30383: DIFF
30384: ST_TO_ADDR
// if not list then
30385: LD_VAR 0 5
30389: NOT
30390: IFFALSE 30394
// exit ;
30392: GO 30536
// weapon := list [ rand ( 1 , list ) ] ;
30394: LD_ADDR_VAR 0 18
30398: PUSH
30399: LD_VAR 0 5
30403: PUSH
30404: LD_INT 1
30406: PPUSH
30407: LD_VAR 0 5
30411: PPUSH
30412: CALL_OW 12
30416: ARRAY
30417: ST_TO_ADDR
// end ; if weapon then
30418: LD_VAR 0 18
30422: IFFALSE 30536
// begin tmp := CostOfWeapon ( weapon ) ;
30424: LD_ADDR_VAR 0 14
30428: PUSH
30429: LD_VAR 0 18
30433: PPUSH
30434: CALL_OW 451
30438: ST_TO_ADDR
// j := GetBase ( tower ) ;
30439: LD_ADDR_VAR 0 9
30443: PUSH
30444: LD_VAR 0 1
30448: PPUSH
30449: CALL_OW 274
30453: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
30454: LD_VAR 0 9
30458: PPUSH
30459: LD_INT 1
30461: PPUSH
30462: CALL_OW 275
30466: PUSH
30467: LD_VAR 0 14
30471: PUSH
30472: LD_INT 1
30474: ARRAY
30475: GREATEREQUAL
30476: PUSH
30477: LD_VAR 0 9
30481: PPUSH
30482: LD_INT 2
30484: PPUSH
30485: CALL_OW 275
30489: PUSH
30490: LD_VAR 0 14
30494: PUSH
30495: LD_INT 2
30497: ARRAY
30498: GREATEREQUAL
30499: AND
30500: PUSH
30501: LD_VAR 0 9
30505: PPUSH
30506: LD_INT 3
30508: PPUSH
30509: CALL_OW 275
30513: PUSH
30514: LD_VAR 0 14
30518: PUSH
30519: LD_INT 3
30521: ARRAY
30522: GREATEREQUAL
30523: AND
30524: IFFALSE 30536
// result := weapon ;
30526: LD_ADDR_VAR 0 3
30530: PUSH
30531: LD_VAR 0 18
30535: ST_TO_ADDR
// end ; end ;
30536: LD_VAR 0 3
30540: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
30541: LD_INT 0
30543: PPUSH
30544: PPUSH
// result := true ;
30545: LD_ADDR_VAR 0 3
30549: PUSH
30550: LD_INT 1
30552: ST_TO_ADDR
// if array1 = array2 then
30553: LD_VAR 0 1
30557: PUSH
30558: LD_VAR 0 2
30562: EQUAL
30563: IFFALSE 30623
// begin for i = 1 to array1 do
30565: LD_ADDR_VAR 0 4
30569: PUSH
30570: DOUBLE
30571: LD_INT 1
30573: DEC
30574: ST_TO_ADDR
30575: LD_VAR 0 1
30579: PUSH
30580: FOR_TO
30581: IFFALSE 30619
// if array1 [ i ] <> array2 [ i ] then
30583: LD_VAR 0 1
30587: PUSH
30588: LD_VAR 0 4
30592: ARRAY
30593: PUSH
30594: LD_VAR 0 2
30598: PUSH
30599: LD_VAR 0 4
30603: ARRAY
30604: NONEQUAL
30605: IFFALSE 30617
// begin result := false ;
30607: LD_ADDR_VAR 0 3
30611: PUSH
30612: LD_INT 0
30614: ST_TO_ADDR
// break ;
30615: GO 30619
// end ;
30617: GO 30580
30619: POP
30620: POP
// end else
30621: GO 30631
// result := false ;
30623: LD_ADDR_VAR 0 3
30627: PUSH
30628: LD_INT 0
30630: ST_TO_ADDR
// end ;
30631: LD_VAR 0 3
30635: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
30636: LD_INT 0
30638: PPUSH
30639: PPUSH
// if not array1 or not array2 then
30640: LD_VAR 0 1
30644: NOT
30645: PUSH
30646: LD_VAR 0 2
30650: NOT
30651: OR
30652: IFFALSE 30656
// exit ;
30654: GO 30720
// result := true ;
30656: LD_ADDR_VAR 0 3
30660: PUSH
30661: LD_INT 1
30663: ST_TO_ADDR
// for i = 1 to array1 do
30664: LD_ADDR_VAR 0 4
30668: PUSH
30669: DOUBLE
30670: LD_INT 1
30672: DEC
30673: ST_TO_ADDR
30674: LD_VAR 0 1
30678: PUSH
30679: FOR_TO
30680: IFFALSE 30718
// if array1 [ i ] <> array2 [ i ] then
30682: LD_VAR 0 1
30686: PUSH
30687: LD_VAR 0 4
30691: ARRAY
30692: PUSH
30693: LD_VAR 0 2
30697: PUSH
30698: LD_VAR 0 4
30702: ARRAY
30703: NONEQUAL
30704: IFFALSE 30716
// begin result := false ;
30706: LD_ADDR_VAR 0 3
30710: PUSH
30711: LD_INT 0
30713: ST_TO_ADDR
// break ;
30714: GO 30718
// end ;
30716: GO 30679
30718: POP
30719: POP
// end ;
30720: LD_VAR 0 3
30724: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
30725: LD_INT 0
30727: PPUSH
30728: PPUSH
30729: PPUSH
// pom := GetBase ( fac ) ;
30730: LD_ADDR_VAR 0 5
30734: PUSH
30735: LD_VAR 0 1
30739: PPUSH
30740: CALL_OW 274
30744: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
30745: LD_ADDR_VAR 0 4
30749: PUSH
30750: LD_VAR 0 2
30754: PUSH
30755: LD_INT 1
30757: ARRAY
30758: PPUSH
30759: LD_VAR 0 2
30763: PUSH
30764: LD_INT 2
30766: ARRAY
30767: PPUSH
30768: LD_VAR 0 2
30772: PUSH
30773: LD_INT 3
30775: ARRAY
30776: PPUSH
30777: LD_VAR 0 2
30781: PUSH
30782: LD_INT 4
30784: ARRAY
30785: PPUSH
30786: CALL_OW 449
30790: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
30791: LD_ADDR_VAR 0 3
30795: PUSH
30796: LD_VAR 0 5
30800: PPUSH
30801: LD_INT 1
30803: PPUSH
30804: CALL_OW 275
30808: PUSH
30809: LD_VAR 0 4
30813: PUSH
30814: LD_INT 1
30816: ARRAY
30817: GREATEREQUAL
30818: PUSH
30819: LD_VAR 0 5
30823: PPUSH
30824: LD_INT 2
30826: PPUSH
30827: CALL_OW 275
30831: PUSH
30832: LD_VAR 0 4
30836: PUSH
30837: LD_INT 2
30839: ARRAY
30840: GREATEREQUAL
30841: AND
30842: PUSH
30843: LD_VAR 0 5
30847: PPUSH
30848: LD_INT 3
30850: PPUSH
30851: CALL_OW 275
30855: PUSH
30856: LD_VAR 0 4
30860: PUSH
30861: LD_INT 3
30863: ARRAY
30864: GREATEREQUAL
30865: AND
30866: ST_TO_ADDR
// end ;
30867: LD_VAR 0 3
30871: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
30872: LD_INT 0
30874: PPUSH
30875: PPUSH
30876: PPUSH
30877: PPUSH
// pom := GetBase ( building ) ;
30878: LD_ADDR_VAR 0 3
30882: PUSH
30883: LD_VAR 0 1
30887: PPUSH
30888: CALL_OW 274
30892: ST_TO_ADDR
// if not pom then
30893: LD_VAR 0 3
30897: NOT
30898: IFFALSE 30902
// exit ;
30900: GO 31072
// btype := GetBType ( building ) ;
30902: LD_ADDR_VAR 0 5
30906: PUSH
30907: LD_VAR 0 1
30911: PPUSH
30912: CALL_OW 266
30916: ST_TO_ADDR
// if btype = b_armoury then
30917: LD_VAR 0 5
30921: PUSH
30922: LD_INT 4
30924: EQUAL
30925: IFFALSE 30935
// btype := b_barracks ;
30927: LD_ADDR_VAR 0 5
30931: PUSH
30932: LD_INT 5
30934: ST_TO_ADDR
// if btype = b_depot then
30935: LD_VAR 0 5
30939: PUSH
30940: LD_INT 0
30942: EQUAL
30943: IFFALSE 30953
// btype := b_warehouse ;
30945: LD_ADDR_VAR 0 5
30949: PUSH
30950: LD_INT 1
30952: ST_TO_ADDR
// if btype = b_workshop then
30953: LD_VAR 0 5
30957: PUSH
30958: LD_INT 2
30960: EQUAL
30961: IFFALSE 30971
// btype := b_factory ;
30963: LD_ADDR_VAR 0 5
30967: PUSH
30968: LD_INT 3
30970: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
30971: LD_ADDR_VAR 0 4
30975: PUSH
30976: LD_VAR 0 5
30980: PPUSH
30981: LD_VAR 0 1
30985: PPUSH
30986: CALL_OW 248
30990: PPUSH
30991: CALL_OW 450
30995: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
30996: LD_ADDR_VAR 0 2
31000: PUSH
31001: LD_VAR 0 3
31005: PPUSH
31006: LD_INT 1
31008: PPUSH
31009: CALL_OW 275
31013: PUSH
31014: LD_VAR 0 4
31018: PUSH
31019: LD_INT 1
31021: ARRAY
31022: GREATEREQUAL
31023: PUSH
31024: LD_VAR 0 3
31028: PPUSH
31029: LD_INT 2
31031: PPUSH
31032: CALL_OW 275
31036: PUSH
31037: LD_VAR 0 4
31041: PUSH
31042: LD_INT 2
31044: ARRAY
31045: GREATEREQUAL
31046: AND
31047: PUSH
31048: LD_VAR 0 3
31052: PPUSH
31053: LD_INT 3
31055: PPUSH
31056: CALL_OW 275
31060: PUSH
31061: LD_VAR 0 4
31065: PUSH
31066: LD_INT 3
31068: ARRAY
31069: GREATEREQUAL
31070: AND
31071: ST_TO_ADDR
// end ;
31072: LD_VAR 0 2
31076: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
31077: LD_INT 0
31079: PPUSH
31080: PPUSH
31081: PPUSH
// pom := GetBase ( building ) ;
31082: LD_ADDR_VAR 0 4
31086: PUSH
31087: LD_VAR 0 1
31091: PPUSH
31092: CALL_OW 274
31096: ST_TO_ADDR
// if not pom then
31097: LD_VAR 0 4
31101: NOT
31102: IFFALSE 31106
// exit ;
31104: GO 31207
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
31106: LD_ADDR_VAR 0 5
31110: PUSH
31111: LD_VAR 0 2
31115: PPUSH
31116: LD_VAR 0 1
31120: PPUSH
31121: CALL_OW 248
31125: PPUSH
31126: CALL_OW 450
31130: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
31131: LD_ADDR_VAR 0 3
31135: PUSH
31136: LD_VAR 0 4
31140: PPUSH
31141: LD_INT 1
31143: PPUSH
31144: CALL_OW 275
31148: PUSH
31149: LD_VAR 0 5
31153: PUSH
31154: LD_INT 1
31156: ARRAY
31157: GREATEREQUAL
31158: PUSH
31159: LD_VAR 0 4
31163: PPUSH
31164: LD_INT 2
31166: PPUSH
31167: CALL_OW 275
31171: PUSH
31172: LD_VAR 0 5
31176: PUSH
31177: LD_INT 2
31179: ARRAY
31180: GREATEREQUAL
31181: AND
31182: PUSH
31183: LD_VAR 0 4
31187: PPUSH
31188: LD_INT 3
31190: PPUSH
31191: CALL_OW 275
31195: PUSH
31196: LD_VAR 0 5
31200: PUSH
31201: LD_INT 3
31203: ARRAY
31204: GREATEREQUAL
31205: AND
31206: ST_TO_ADDR
// end ;
31207: LD_VAR 0 3
31211: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
31212: LD_INT 0
31214: PPUSH
31215: PPUSH
31216: PPUSH
31217: PPUSH
31218: PPUSH
31219: PPUSH
31220: PPUSH
31221: PPUSH
31222: PPUSH
31223: PPUSH
31224: PPUSH
// result := false ;
31225: LD_ADDR_VAR 0 8
31229: PUSH
31230: LD_INT 0
31232: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
31233: LD_VAR 0 5
31237: NOT
31238: PUSH
31239: LD_VAR 0 1
31243: NOT
31244: OR
31245: PUSH
31246: LD_VAR 0 2
31250: NOT
31251: OR
31252: PUSH
31253: LD_VAR 0 3
31257: NOT
31258: OR
31259: IFFALSE 31263
// exit ;
31261: GO 32077
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
31263: LD_ADDR_VAR 0 14
31267: PUSH
31268: LD_VAR 0 1
31272: PPUSH
31273: LD_VAR 0 2
31277: PPUSH
31278: LD_VAR 0 3
31282: PPUSH
31283: LD_VAR 0 4
31287: PPUSH
31288: LD_VAR 0 5
31292: PUSH
31293: LD_INT 1
31295: ARRAY
31296: PPUSH
31297: CALL_OW 248
31301: PPUSH
31302: LD_INT 0
31304: PPUSH
31305: CALL 33310 0 6
31309: ST_TO_ADDR
// if not hexes then
31310: LD_VAR 0 14
31314: NOT
31315: IFFALSE 31319
// exit ;
31317: GO 32077
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
31319: LD_ADDR_VAR 0 17
31323: PUSH
31324: LD_VAR 0 5
31328: PPUSH
31329: LD_INT 22
31331: PUSH
31332: LD_VAR 0 13
31336: PPUSH
31337: CALL_OW 255
31341: PUSH
31342: EMPTY
31343: LIST
31344: LIST
31345: PUSH
31346: LD_INT 2
31348: PUSH
31349: LD_INT 30
31351: PUSH
31352: LD_INT 0
31354: PUSH
31355: EMPTY
31356: LIST
31357: LIST
31358: PUSH
31359: LD_INT 30
31361: PUSH
31362: LD_INT 1
31364: PUSH
31365: EMPTY
31366: LIST
31367: LIST
31368: PUSH
31369: EMPTY
31370: LIST
31371: LIST
31372: LIST
31373: PUSH
31374: EMPTY
31375: LIST
31376: LIST
31377: PPUSH
31378: CALL_OW 72
31382: ST_TO_ADDR
// for i = 1 to hexes do
31383: LD_ADDR_VAR 0 9
31387: PUSH
31388: DOUBLE
31389: LD_INT 1
31391: DEC
31392: ST_TO_ADDR
31393: LD_VAR 0 14
31397: PUSH
31398: FOR_TO
31399: IFFALSE 32075
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
31401: LD_ADDR_VAR 0 13
31405: PUSH
31406: LD_VAR 0 14
31410: PUSH
31411: LD_VAR 0 9
31415: ARRAY
31416: PUSH
31417: LD_INT 1
31419: ARRAY
31420: PPUSH
31421: LD_VAR 0 14
31425: PUSH
31426: LD_VAR 0 9
31430: ARRAY
31431: PUSH
31432: LD_INT 2
31434: ARRAY
31435: PPUSH
31436: CALL_OW 428
31440: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
31441: LD_VAR 0 14
31445: PUSH
31446: LD_VAR 0 9
31450: ARRAY
31451: PUSH
31452: LD_INT 1
31454: ARRAY
31455: PPUSH
31456: LD_VAR 0 14
31460: PUSH
31461: LD_VAR 0 9
31465: ARRAY
31466: PUSH
31467: LD_INT 2
31469: ARRAY
31470: PPUSH
31471: CALL_OW 351
31475: PUSH
31476: LD_VAR 0 14
31480: PUSH
31481: LD_VAR 0 9
31485: ARRAY
31486: PUSH
31487: LD_INT 1
31489: ARRAY
31490: PPUSH
31491: LD_VAR 0 14
31495: PUSH
31496: LD_VAR 0 9
31500: ARRAY
31501: PUSH
31502: LD_INT 2
31504: ARRAY
31505: PPUSH
31506: CALL_OW 488
31510: NOT
31511: OR
31512: PUSH
31513: LD_VAR 0 13
31517: PPUSH
31518: CALL_OW 247
31522: PUSH
31523: LD_INT 3
31525: EQUAL
31526: OR
31527: IFFALSE 31533
// exit ;
31529: POP
31530: POP
31531: GO 32077
// if not tmp then
31533: LD_VAR 0 13
31537: NOT
31538: IFFALSE 31542
// continue ;
31540: GO 31398
// result := true ;
31542: LD_ADDR_VAR 0 8
31546: PUSH
31547: LD_INT 1
31549: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
31550: LD_VAR 0 6
31554: PUSH
31555: LD_VAR 0 13
31559: PPUSH
31560: CALL_OW 247
31564: PUSH
31565: LD_INT 2
31567: EQUAL
31568: AND
31569: PUSH
31570: LD_VAR 0 13
31574: PPUSH
31575: CALL_OW 263
31579: PUSH
31580: LD_INT 1
31582: EQUAL
31583: AND
31584: IFFALSE 31748
// begin if IsDrivenBy ( tmp ) then
31586: LD_VAR 0 13
31590: PPUSH
31591: CALL_OW 311
31595: IFFALSE 31599
// continue ;
31597: GO 31398
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
31599: LD_VAR 0 6
31603: PPUSH
31604: LD_INT 3
31606: PUSH
31607: LD_INT 60
31609: PUSH
31610: EMPTY
31611: LIST
31612: PUSH
31613: EMPTY
31614: LIST
31615: LIST
31616: PUSH
31617: LD_INT 3
31619: PUSH
31620: LD_INT 55
31622: PUSH
31623: EMPTY
31624: LIST
31625: PUSH
31626: EMPTY
31627: LIST
31628: LIST
31629: PUSH
31630: EMPTY
31631: LIST
31632: LIST
31633: PPUSH
31634: CALL_OW 72
31638: IFFALSE 31746
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
31640: LD_ADDR_VAR 0 18
31644: PUSH
31645: LD_VAR 0 6
31649: PPUSH
31650: LD_INT 3
31652: PUSH
31653: LD_INT 60
31655: PUSH
31656: EMPTY
31657: LIST
31658: PUSH
31659: EMPTY
31660: LIST
31661: LIST
31662: PUSH
31663: LD_INT 3
31665: PUSH
31666: LD_INT 55
31668: PUSH
31669: EMPTY
31670: LIST
31671: PUSH
31672: EMPTY
31673: LIST
31674: LIST
31675: PUSH
31676: EMPTY
31677: LIST
31678: LIST
31679: PPUSH
31680: CALL_OW 72
31684: PUSH
31685: LD_INT 1
31687: ARRAY
31688: ST_TO_ADDR
// if IsInUnit ( driver ) then
31689: LD_VAR 0 18
31693: PPUSH
31694: CALL_OW 310
31698: IFFALSE 31709
// ComExit ( driver ) ;
31700: LD_VAR 0 18
31704: PPUSH
31705: CALL 57090 0 1
// AddComEnterUnit ( driver , tmp ) ;
31709: LD_VAR 0 18
31713: PPUSH
31714: LD_VAR 0 13
31718: PPUSH
31719: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
31723: LD_VAR 0 18
31727: PPUSH
31728: LD_VAR 0 7
31732: PPUSH
31733: CALL_OW 173
// AddComExitVehicle ( driver ) ;
31737: LD_VAR 0 18
31741: PPUSH
31742: CALL_OW 181
// end ; continue ;
31746: GO 31398
// end ; if not cleaners or not tmp in cleaners then
31748: LD_VAR 0 6
31752: NOT
31753: PUSH
31754: LD_VAR 0 13
31758: PUSH
31759: LD_VAR 0 6
31763: IN
31764: NOT
31765: OR
31766: IFFALSE 32073
// begin if dep then
31768: LD_VAR 0 17
31772: IFFALSE 31908
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
31774: LD_ADDR_VAR 0 16
31778: PUSH
31779: LD_VAR 0 17
31783: PUSH
31784: LD_INT 1
31786: ARRAY
31787: PPUSH
31788: CALL_OW 250
31792: PPUSH
31793: LD_VAR 0 17
31797: PUSH
31798: LD_INT 1
31800: ARRAY
31801: PPUSH
31802: CALL_OW 254
31806: PPUSH
31807: LD_INT 5
31809: PPUSH
31810: CALL_OW 272
31814: PUSH
31815: LD_VAR 0 17
31819: PUSH
31820: LD_INT 1
31822: ARRAY
31823: PPUSH
31824: CALL_OW 251
31828: PPUSH
31829: LD_VAR 0 17
31833: PUSH
31834: LD_INT 1
31836: ARRAY
31837: PPUSH
31838: CALL_OW 254
31842: PPUSH
31843: LD_INT 5
31845: PPUSH
31846: CALL_OW 273
31850: PUSH
31851: EMPTY
31852: LIST
31853: LIST
31854: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
31855: LD_VAR 0 16
31859: PUSH
31860: LD_INT 1
31862: ARRAY
31863: PPUSH
31864: LD_VAR 0 16
31868: PUSH
31869: LD_INT 2
31871: ARRAY
31872: PPUSH
31873: CALL_OW 488
31877: IFFALSE 31908
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
31879: LD_VAR 0 13
31883: PPUSH
31884: LD_VAR 0 16
31888: PUSH
31889: LD_INT 1
31891: ARRAY
31892: PPUSH
31893: LD_VAR 0 16
31897: PUSH
31898: LD_INT 2
31900: ARRAY
31901: PPUSH
31902: CALL_OW 111
// continue ;
31906: GO 31398
// end ; end ; r := GetDir ( tmp ) ;
31908: LD_ADDR_VAR 0 15
31912: PUSH
31913: LD_VAR 0 13
31917: PPUSH
31918: CALL_OW 254
31922: ST_TO_ADDR
// if r = 5 then
31923: LD_VAR 0 15
31927: PUSH
31928: LD_INT 5
31930: EQUAL
31931: IFFALSE 31941
// r := 0 ;
31933: LD_ADDR_VAR 0 15
31937: PUSH
31938: LD_INT 0
31940: ST_TO_ADDR
// for j = r to 5 do
31941: LD_ADDR_VAR 0 10
31945: PUSH
31946: DOUBLE
31947: LD_VAR 0 15
31951: DEC
31952: ST_TO_ADDR
31953: LD_INT 5
31955: PUSH
31956: FOR_TO
31957: IFFALSE 32071
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
31959: LD_ADDR_VAR 0 11
31963: PUSH
31964: LD_VAR 0 13
31968: PPUSH
31969: CALL_OW 250
31973: PPUSH
31974: LD_VAR 0 10
31978: PPUSH
31979: LD_INT 2
31981: PPUSH
31982: CALL_OW 272
31986: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
31987: LD_ADDR_VAR 0 12
31991: PUSH
31992: LD_VAR 0 13
31996: PPUSH
31997: CALL_OW 251
32001: PPUSH
32002: LD_VAR 0 10
32006: PPUSH
32007: LD_INT 2
32009: PPUSH
32010: CALL_OW 273
32014: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
32015: LD_VAR 0 11
32019: PPUSH
32020: LD_VAR 0 12
32024: PPUSH
32025: CALL_OW 488
32029: PUSH
32030: LD_VAR 0 11
32034: PPUSH
32035: LD_VAR 0 12
32039: PPUSH
32040: CALL_OW 428
32044: NOT
32045: AND
32046: IFFALSE 32069
// begin ComMoveXY ( tmp , _x , _y ) ;
32048: LD_VAR 0 13
32052: PPUSH
32053: LD_VAR 0 11
32057: PPUSH
32058: LD_VAR 0 12
32062: PPUSH
32063: CALL_OW 111
// break ;
32067: GO 32071
// end ; end ;
32069: GO 31956
32071: POP
32072: POP
// end ; end ;
32073: GO 31398
32075: POP
32076: POP
// end ;
32077: LD_VAR 0 8
32081: RET
// export function BuildingTechInvented ( side , btype ) ; begin
32082: LD_INT 0
32084: PPUSH
// result := true ;
32085: LD_ADDR_VAR 0 3
32089: PUSH
32090: LD_INT 1
32092: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
32093: LD_VAR 0 2
32097: PUSH
32098: LD_INT 24
32100: DOUBLE
32101: EQUAL
32102: IFTRUE 32112
32104: LD_INT 33
32106: DOUBLE
32107: EQUAL
32108: IFTRUE 32112
32110: GO 32137
32112: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
32113: LD_ADDR_VAR 0 3
32117: PUSH
32118: LD_INT 32
32120: PPUSH
32121: LD_VAR 0 1
32125: PPUSH
32126: CALL_OW 321
32130: PUSH
32131: LD_INT 2
32133: EQUAL
32134: ST_TO_ADDR
32135: GO 32453
32137: LD_INT 20
32139: DOUBLE
32140: EQUAL
32141: IFTRUE 32145
32143: GO 32170
32145: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
32146: LD_ADDR_VAR 0 3
32150: PUSH
32151: LD_INT 6
32153: PPUSH
32154: LD_VAR 0 1
32158: PPUSH
32159: CALL_OW 321
32163: PUSH
32164: LD_INT 2
32166: EQUAL
32167: ST_TO_ADDR
32168: GO 32453
32170: LD_INT 22
32172: DOUBLE
32173: EQUAL
32174: IFTRUE 32184
32176: LD_INT 36
32178: DOUBLE
32179: EQUAL
32180: IFTRUE 32184
32182: GO 32209
32184: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
32185: LD_ADDR_VAR 0 3
32189: PUSH
32190: LD_INT 15
32192: PPUSH
32193: LD_VAR 0 1
32197: PPUSH
32198: CALL_OW 321
32202: PUSH
32203: LD_INT 2
32205: EQUAL
32206: ST_TO_ADDR
32207: GO 32453
32209: LD_INT 30
32211: DOUBLE
32212: EQUAL
32213: IFTRUE 32217
32215: GO 32242
32217: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
32218: LD_ADDR_VAR 0 3
32222: PUSH
32223: LD_INT 20
32225: PPUSH
32226: LD_VAR 0 1
32230: PPUSH
32231: CALL_OW 321
32235: PUSH
32236: LD_INT 2
32238: EQUAL
32239: ST_TO_ADDR
32240: GO 32453
32242: LD_INT 28
32244: DOUBLE
32245: EQUAL
32246: IFTRUE 32256
32248: LD_INT 21
32250: DOUBLE
32251: EQUAL
32252: IFTRUE 32256
32254: GO 32281
32256: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
32257: LD_ADDR_VAR 0 3
32261: PUSH
32262: LD_INT 21
32264: PPUSH
32265: LD_VAR 0 1
32269: PPUSH
32270: CALL_OW 321
32274: PUSH
32275: LD_INT 2
32277: EQUAL
32278: ST_TO_ADDR
32279: GO 32453
32281: LD_INT 16
32283: DOUBLE
32284: EQUAL
32285: IFTRUE 32289
32287: GO 32314
32289: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
32290: LD_ADDR_VAR 0 3
32294: PUSH
32295: LD_INT 84
32297: PPUSH
32298: LD_VAR 0 1
32302: PPUSH
32303: CALL_OW 321
32307: PUSH
32308: LD_INT 2
32310: EQUAL
32311: ST_TO_ADDR
32312: GO 32453
32314: LD_INT 19
32316: DOUBLE
32317: EQUAL
32318: IFTRUE 32328
32320: LD_INT 23
32322: DOUBLE
32323: EQUAL
32324: IFTRUE 32328
32326: GO 32353
32328: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
32329: LD_ADDR_VAR 0 3
32333: PUSH
32334: LD_INT 83
32336: PPUSH
32337: LD_VAR 0 1
32341: PPUSH
32342: CALL_OW 321
32346: PUSH
32347: LD_INT 2
32349: EQUAL
32350: ST_TO_ADDR
32351: GO 32453
32353: LD_INT 17
32355: DOUBLE
32356: EQUAL
32357: IFTRUE 32361
32359: GO 32386
32361: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
32362: LD_ADDR_VAR 0 3
32366: PUSH
32367: LD_INT 39
32369: PPUSH
32370: LD_VAR 0 1
32374: PPUSH
32375: CALL_OW 321
32379: PUSH
32380: LD_INT 2
32382: EQUAL
32383: ST_TO_ADDR
32384: GO 32453
32386: LD_INT 18
32388: DOUBLE
32389: EQUAL
32390: IFTRUE 32394
32392: GO 32419
32394: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
32395: LD_ADDR_VAR 0 3
32399: PUSH
32400: LD_INT 40
32402: PPUSH
32403: LD_VAR 0 1
32407: PPUSH
32408: CALL_OW 321
32412: PUSH
32413: LD_INT 2
32415: EQUAL
32416: ST_TO_ADDR
32417: GO 32453
32419: LD_INT 27
32421: DOUBLE
32422: EQUAL
32423: IFTRUE 32427
32425: GO 32452
32427: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
32428: LD_ADDR_VAR 0 3
32432: PUSH
32433: LD_INT 35
32435: PPUSH
32436: LD_VAR 0 1
32440: PPUSH
32441: CALL_OW 321
32445: PUSH
32446: LD_INT 2
32448: EQUAL
32449: ST_TO_ADDR
32450: GO 32453
32452: POP
// end ;
32453: LD_VAR 0 3
32457: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
32458: LD_INT 0
32460: PPUSH
32461: PPUSH
32462: PPUSH
32463: PPUSH
32464: PPUSH
32465: PPUSH
32466: PPUSH
32467: PPUSH
32468: PPUSH
32469: PPUSH
32470: PPUSH
// result := false ;
32471: LD_ADDR_VAR 0 6
32475: PUSH
32476: LD_INT 0
32478: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
32479: LD_VAR 0 1
32483: NOT
32484: PUSH
32485: LD_VAR 0 1
32489: PPUSH
32490: CALL_OW 266
32494: PUSH
32495: LD_INT 0
32497: PUSH
32498: LD_INT 1
32500: PUSH
32501: EMPTY
32502: LIST
32503: LIST
32504: IN
32505: NOT
32506: OR
32507: PUSH
32508: LD_VAR 0 2
32512: NOT
32513: OR
32514: PUSH
32515: LD_VAR 0 5
32519: PUSH
32520: LD_INT 0
32522: PUSH
32523: LD_INT 1
32525: PUSH
32526: LD_INT 2
32528: PUSH
32529: LD_INT 3
32531: PUSH
32532: LD_INT 4
32534: PUSH
32535: LD_INT 5
32537: PUSH
32538: EMPTY
32539: LIST
32540: LIST
32541: LIST
32542: LIST
32543: LIST
32544: LIST
32545: IN
32546: NOT
32547: OR
32548: PUSH
32549: LD_VAR 0 3
32553: PPUSH
32554: LD_VAR 0 4
32558: PPUSH
32559: CALL_OW 488
32563: NOT
32564: OR
32565: IFFALSE 32569
// exit ;
32567: GO 33305
// side := GetSide ( depot ) ;
32569: LD_ADDR_VAR 0 9
32573: PUSH
32574: LD_VAR 0 1
32578: PPUSH
32579: CALL_OW 255
32583: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
32584: LD_VAR 0 9
32588: PPUSH
32589: LD_VAR 0 2
32593: PPUSH
32594: CALL 32082 0 2
32598: NOT
32599: IFFALSE 32603
// exit ;
32601: GO 33305
// pom := GetBase ( depot ) ;
32603: LD_ADDR_VAR 0 10
32607: PUSH
32608: LD_VAR 0 1
32612: PPUSH
32613: CALL_OW 274
32617: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
32618: LD_ADDR_VAR 0 11
32622: PUSH
32623: LD_VAR 0 2
32627: PPUSH
32628: LD_VAR 0 1
32632: PPUSH
32633: CALL_OW 248
32637: PPUSH
32638: CALL_OW 450
32642: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
32643: LD_VAR 0 10
32647: PPUSH
32648: LD_INT 1
32650: PPUSH
32651: CALL_OW 275
32655: PUSH
32656: LD_VAR 0 11
32660: PUSH
32661: LD_INT 1
32663: ARRAY
32664: GREATEREQUAL
32665: PUSH
32666: LD_VAR 0 10
32670: PPUSH
32671: LD_INT 2
32673: PPUSH
32674: CALL_OW 275
32678: PUSH
32679: LD_VAR 0 11
32683: PUSH
32684: LD_INT 2
32686: ARRAY
32687: GREATEREQUAL
32688: AND
32689: PUSH
32690: LD_VAR 0 10
32694: PPUSH
32695: LD_INT 3
32697: PPUSH
32698: CALL_OW 275
32702: PUSH
32703: LD_VAR 0 11
32707: PUSH
32708: LD_INT 3
32710: ARRAY
32711: GREATEREQUAL
32712: AND
32713: NOT
32714: IFFALSE 32718
// exit ;
32716: GO 33305
// if GetBType ( depot ) = b_depot then
32718: LD_VAR 0 1
32722: PPUSH
32723: CALL_OW 266
32727: PUSH
32728: LD_INT 0
32730: EQUAL
32731: IFFALSE 32743
// dist := 28 else
32733: LD_ADDR_VAR 0 14
32737: PUSH
32738: LD_INT 28
32740: ST_TO_ADDR
32741: GO 32751
// dist := 36 ;
32743: LD_ADDR_VAR 0 14
32747: PUSH
32748: LD_INT 36
32750: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
32751: LD_VAR 0 1
32755: PPUSH
32756: LD_VAR 0 3
32760: PPUSH
32761: LD_VAR 0 4
32765: PPUSH
32766: CALL_OW 297
32770: PUSH
32771: LD_VAR 0 14
32775: GREATER
32776: IFFALSE 32780
// exit ;
32778: GO 33305
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
32780: LD_ADDR_VAR 0 12
32784: PUSH
32785: LD_VAR 0 2
32789: PPUSH
32790: LD_VAR 0 3
32794: PPUSH
32795: LD_VAR 0 4
32799: PPUSH
32800: LD_VAR 0 5
32804: PPUSH
32805: LD_VAR 0 1
32809: PPUSH
32810: CALL_OW 248
32814: PPUSH
32815: LD_INT 0
32817: PPUSH
32818: CALL 33310 0 6
32822: ST_TO_ADDR
// if not hexes then
32823: LD_VAR 0 12
32827: NOT
32828: IFFALSE 32832
// exit ;
32830: GO 33305
// hex := GetHexInfo ( x , y ) ;
32832: LD_ADDR_VAR 0 15
32836: PUSH
32837: LD_VAR 0 3
32841: PPUSH
32842: LD_VAR 0 4
32846: PPUSH
32847: CALL_OW 546
32851: ST_TO_ADDR
// if hex [ 1 ] then
32852: LD_VAR 0 15
32856: PUSH
32857: LD_INT 1
32859: ARRAY
32860: IFFALSE 32864
// exit ;
32862: GO 33305
// height := hex [ 2 ] ;
32864: LD_ADDR_VAR 0 13
32868: PUSH
32869: LD_VAR 0 15
32873: PUSH
32874: LD_INT 2
32876: ARRAY
32877: ST_TO_ADDR
// for i = 1 to hexes do
32878: LD_ADDR_VAR 0 7
32882: PUSH
32883: DOUBLE
32884: LD_INT 1
32886: DEC
32887: ST_TO_ADDR
32888: LD_VAR 0 12
32892: PUSH
32893: FOR_TO
32894: IFFALSE 33224
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
32896: LD_VAR 0 12
32900: PUSH
32901: LD_VAR 0 7
32905: ARRAY
32906: PUSH
32907: LD_INT 1
32909: ARRAY
32910: PPUSH
32911: LD_VAR 0 12
32915: PUSH
32916: LD_VAR 0 7
32920: ARRAY
32921: PUSH
32922: LD_INT 2
32924: ARRAY
32925: PPUSH
32926: CALL_OW 488
32930: NOT
32931: PUSH
32932: LD_VAR 0 12
32936: PUSH
32937: LD_VAR 0 7
32941: ARRAY
32942: PUSH
32943: LD_INT 1
32945: ARRAY
32946: PPUSH
32947: LD_VAR 0 12
32951: PUSH
32952: LD_VAR 0 7
32956: ARRAY
32957: PUSH
32958: LD_INT 2
32960: ARRAY
32961: PPUSH
32962: CALL_OW 428
32966: PUSH
32967: LD_INT 0
32969: GREATER
32970: OR
32971: PUSH
32972: LD_VAR 0 12
32976: PUSH
32977: LD_VAR 0 7
32981: ARRAY
32982: PUSH
32983: LD_INT 1
32985: ARRAY
32986: PPUSH
32987: LD_VAR 0 12
32991: PUSH
32992: LD_VAR 0 7
32996: ARRAY
32997: PUSH
32998: LD_INT 2
33000: ARRAY
33001: PPUSH
33002: CALL_OW 351
33006: OR
33007: IFFALSE 33013
// exit ;
33009: POP
33010: POP
33011: GO 33305
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
33013: LD_ADDR_VAR 0 8
33017: PUSH
33018: LD_VAR 0 12
33022: PUSH
33023: LD_VAR 0 7
33027: ARRAY
33028: PUSH
33029: LD_INT 1
33031: ARRAY
33032: PPUSH
33033: LD_VAR 0 12
33037: PUSH
33038: LD_VAR 0 7
33042: ARRAY
33043: PUSH
33044: LD_INT 2
33046: ARRAY
33047: PPUSH
33048: CALL_OW 546
33052: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
33053: LD_VAR 0 8
33057: PUSH
33058: LD_INT 1
33060: ARRAY
33061: PUSH
33062: LD_VAR 0 8
33066: PUSH
33067: LD_INT 2
33069: ARRAY
33070: PUSH
33071: LD_VAR 0 13
33075: PUSH
33076: LD_INT 2
33078: PLUS
33079: GREATER
33080: OR
33081: PUSH
33082: LD_VAR 0 8
33086: PUSH
33087: LD_INT 2
33089: ARRAY
33090: PUSH
33091: LD_VAR 0 13
33095: PUSH
33096: LD_INT 2
33098: MINUS
33099: LESS
33100: OR
33101: PUSH
33102: LD_VAR 0 8
33106: PUSH
33107: LD_INT 3
33109: ARRAY
33110: PUSH
33111: LD_INT 0
33113: PUSH
33114: LD_INT 8
33116: PUSH
33117: LD_INT 9
33119: PUSH
33120: LD_INT 10
33122: PUSH
33123: LD_INT 11
33125: PUSH
33126: LD_INT 12
33128: PUSH
33129: LD_INT 13
33131: PUSH
33132: LD_INT 16
33134: PUSH
33135: LD_INT 17
33137: PUSH
33138: LD_INT 18
33140: PUSH
33141: LD_INT 19
33143: PUSH
33144: LD_INT 20
33146: PUSH
33147: LD_INT 21
33149: PUSH
33150: EMPTY
33151: LIST
33152: LIST
33153: LIST
33154: LIST
33155: LIST
33156: LIST
33157: LIST
33158: LIST
33159: LIST
33160: LIST
33161: LIST
33162: LIST
33163: LIST
33164: IN
33165: NOT
33166: OR
33167: PUSH
33168: LD_VAR 0 8
33172: PUSH
33173: LD_INT 5
33175: ARRAY
33176: NOT
33177: OR
33178: PUSH
33179: LD_VAR 0 8
33183: PUSH
33184: LD_INT 6
33186: ARRAY
33187: PUSH
33188: LD_INT 1
33190: PUSH
33191: LD_INT 2
33193: PUSH
33194: LD_INT 7
33196: PUSH
33197: LD_INT 9
33199: PUSH
33200: LD_INT 10
33202: PUSH
33203: LD_INT 11
33205: PUSH
33206: EMPTY
33207: LIST
33208: LIST
33209: LIST
33210: LIST
33211: LIST
33212: LIST
33213: IN
33214: NOT
33215: OR
33216: IFFALSE 33222
// exit ;
33218: POP
33219: POP
33220: GO 33305
// end ;
33222: GO 32893
33224: POP
33225: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
33226: LD_VAR 0 9
33230: PPUSH
33231: LD_VAR 0 3
33235: PPUSH
33236: LD_VAR 0 4
33240: PPUSH
33241: LD_INT 20
33243: PPUSH
33244: CALL 25257 0 4
33248: PUSH
33249: LD_INT 4
33251: ARRAY
33252: IFFALSE 33256
// exit ;
33254: GO 33305
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
33256: LD_VAR 0 2
33260: PUSH
33261: LD_INT 29
33263: PUSH
33264: LD_INT 30
33266: PUSH
33267: EMPTY
33268: LIST
33269: LIST
33270: IN
33271: PUSH
33272: LD_VAR 0 3
33276: PPUSH
33277: LD_VAR 0 4
33281: PPUSH
33282: LD_VAR 0 9
33286: PPUSH
33287: CALL_OW 440
33291: NOT
33292: AND
33293: IFFALSE 33297
// exit ;
33295: GO 33305
// result := true ;
33297: LD_ADDR_VAR 0 6
33301: PUSH
33302: LD_INT 1
33304: ST_TO_ADDR
// end ;
33305: LD_VAR 0 6
33309: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
33310: LD_INT 0
33312: PPUSH
33313: PPUSH
33314: PPUSH
33315: PPUSH
33316: PPUSH
33317: PPUSH
33318: PPUSH
33319: PPUSH
33320: PPUSH
33321: PPUSH
33322: PPUSH
33323: PPUSH
33324: PPUSH
33325: PPUSH
33326: PPUSH
33327: PPUSH
33328: PPUSH
33329: PPUSH
33330: PPUSH
33331: PPUSH
33332: PPUSH
33333: PPUSH
33334: PPUSH
33335: PPUSH
33336: PPUSH
33337: PPUSH
33338: PPUSH
33339: PPUSH
33340: PPUSH
33341: PPUSH
33342: PPUSH
33343: PPUSH
33344: PPUSH
33345: PPUSH
33346: PPUSH
33347: PPUSH
33348: PPUSH
33349: PPUSH
33350: PPUSH
33351: PPUSH
33352: PPUSH
33353: PPUSH
33354: PPUSH
33355: PPUSH
33356: PPUSH
33357: PPUSH
33358: PPUSH
33359: PPUSH
33360: PPUSH
33361: PPUSH
33362: PPUSH
33363: PPUSH
33364: PPUSH
33365: PPUSH
33366: PPUSH
33367: PPUSH
33368: PPUSH
33369: PPUSH
// result = [ ] ;
33370: LD_ADDR_VAR 0 7
33374: PUSH
33375: EMPTY
33376: ST_TO_ADDR
// temp_list = [ ] ;
33377: LD_ADDR_VAR 0 9
33381: PUSH
33382: EMPTY
33383: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
33384: LD_VAR 0 4
33388: PUSH
33389: LD_INT 0
33391: PUSH
33392: LD_INT 1
33394: PUSH
33395: LD_INT 2
33397: PUSH
33398: LD_INT 3
33400: PUSH
33401: LD_INT 4
33403: PUSH
33404: LD_INT 5
33406: PUSH
33407: EMPTY
33408: LIST
33409: LIST
33410: LIST
33411: LIST
33412: LIST
33413: LIST
33414: IN
33415: NOT
33416: PUSH
33417: LD_VAR 0 1
33421: PUSH
33422: LD_INT 0
33424: PUSH
33425: LD_INT 1
33427: PUSH
33428: EMPTY
33429: LIST
33430: LIST
33431: IN
33432: PUSH
33433: LD_VAR 0 5
33437: PUSH
33438: LD_INT 1
33440: PUSH
33441: LD_INT 2
33443: PUSH
33444: LD_INT 3
33446: PUSH
33447: EMPTY
33448: LIST
33449: LIST
33450: LIST
33451: IN
33452: NOT
33453: AND
33454: OR
33455: IFFALSE 33459
// exit ;
33457: GO 51850
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
33459: LD_VAR 0 1
33463: PUSH
33464: LD_INT 6
33466: PUSH
33467: LD_INT 7
33469: PUSH
33470: LD_INT 8
33472: PUSH
33473: LD_INT 13
33475: PUSH
33476: LD_INT 12
33478: PUSH
33479: LD_INT 15
33481: PUSH
33482: LD_INT 11
33484: PUSH
33485: LD_INT 14
33487: PUSH
33488: LD_INT 10
33490: PUSH
33491: EMPTY
33492: LIST
33493: LIST
33494: LIST
33495: LIST
33496: LIST
33497: LIST
33498: LIST
33499: LIST
33500: LIST
33501: IN
33502: IFFALSE 33512
// btype = b_lab ;
33504: LD_ADDR_VAR 0 1
33508: PUSH
33509: LD_INT 6
33511: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
33512: LD_VAR 0 6
33516: PUSH
33517: LD_INT 0
33519: PUSH
33520: LD_INT 1
33522: PUSH
33523: LD_INT 2
33525: PUSH
33526: EMPTY
33527: LIST
33528: LIST
33529: LIST
33530: IN
33531: NOT
33532: PUSH
33533: LD_VAR 0 1
33537: PUSH
33538: LD_INT 0
33540: PUSH
33541: LD_INT 1
33543: PUSH
33544: LD_INT 2
33546: PUSH
33547: LD_INT 3
33549: PUSH
33550: LD_INT 6
33552: PUSH
33553: LD_INT 36
33555: PUSH
33556: LD_INT 4
33558: PUSH
33559: LD_INT 5
33561: PUSH
33562: LD_INT 31
33564: PUSH
33565: LD_INT 32
33567: PUSH
33568: LD_INT 33
33570: PUSH
33571: EMPTY
33572: LIST
33573: LIST
33574: LIST
33575: LIST
33576: LIST
33577: LIST
33578: LIST
33579: LIST
33580: LIST
33581: LIST
33582: LIST
33583: IN
33584: NOT
33585: PUSH
33586: LD_VAR 0 6
33590: PUSH
33591: LD_INT 1
33593: EQUAL
33594: AND
33595: OR
33596: PUSH
33597: LD_VAR 0 1
33601: PUSH
33602: LD_INT 2
33604: PUSH
33605: LD_INT 3
33607: PUSH
33608: EMPTY
33609: LIST
33610: LIST
33611: IN
33612: NOT
33613: PUSH
33614: LD_VAR 0 6
33618: PUSH
33619: LD_INT 2
33621: EQUAL
33622: AND
33623: OR
33624: IFFALSE 33634
// mode = 0 ;
33626: LD_ADDR_VAR 0 6
33630: PUSH
33631: LD_INT 0
33633: ST_TO_ADDR
// case mode of 0 :
33634: LD_VAR 0 6
33638: PUSH
33639: LD_INT 0
33641: DOUBLE
33642: EQUAL
33643: IFTRUE 33647
33645: GO 45100
33647: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
33648: LD_ADDR_VAR 0 11
33652: PUSH
33653: LD_INT 0
33655: PUSH
33656: LD_INT 0
33658: PUSH
33659: EMPTY
33660: LIST
33661: LIST
33662: PUSH
33663: LD_INT 0
33665: PUSH
33666: LD_INT 1
33668: NEG
33669: PUSH
33670: EMPTY
33671: LIST
33672: LIST
33673: PUSH
33674: LD_INT 1
33676: PUSH
33677: LD_INT 0
33679: PUSH
33680: EMPTY
33681: LIST
33682: LIST
33683: PUSH
33684: LD_INT 1
33686: PUSH
33687: LD_INT 1
33689: PUSH
33690: EMPTY
33691: LIST
33692: LIST
33693: PUSH
33694: LD_INT 0
33696: PUSH
33697: LD_INT 1
33699: PUSH
33700: EMPTY
33701: LIST
33702: LIST
33703: PUSH
33704: LD_INT 1
33706: NEG
33707: PUSH
33708: LD_INT 0
33710: PUSH
33711: EMPTY
33712: LIST
33713: LIST
33714: PUSH
33715: LD_INT 1
33717: NEG
33718: PUSH
33719: LD_INT 1
33721: NEG
33722: PUSH
33723: EMPTY
33724: LIST
33725: LIST
33726: PUSH
33727: LD_INT 1
33729: NEG
33730: PUSH
33731: LD_INT 2
33733: NEG
33734: PUSH
33735: EMPTY
33736: LIST
33737: LIST
33738: PUSH
33739: LD_INT 0
33741: PUSH
33742: LD_INT 2
33744: NEG
33745: PUSH
33746: EMPTY
33747: LIST
33748: LIST
33749: PUSH
33750: LD_INT 1
33752: PUSH
33753: LD_INT 1
33755: NEG
33756: PUSH
33757: EMPTY
33758: LIST
33759: LIST
33760: PUSH
33761: LD_INT 1
33763: PUSH
33764: LD_INT 2
33766: PUSH
33767: EMPTY
33768: LIST
33769: LIST
33770: PUSH
33771: LD_INT 0
33773: PUSH
33774: LD_INT 2
33776: PUSH
33777: EMPTY
33778: LIST
33779: LIST
33780: PUSH
33781: LD_INT 1
33783: NEG
33784: PUSH
33785: LD_INT 1
33787: PUSH
33788: EMPTY
33789: LIST
33790: LIST
33791: PUSH
33792: LD_INT 1
33794: PUSH
33795: LD_INT 3
33797: PUSH
33798: EMPTY
33799: LIST
33800: LIST
33801: PUSH
33802: LD_INT 0
33804: PUSH
33805: LD_INT 3
33807: PUSH
33808: EMPTY
33809: LIST
33810: LIST
33811: PUSH
33812: LD_INT 1
33814: NEG
33815: PUSH
33816: LD_INT 2
33818: PUSH
33819: EMPTY
33820: LIST
33821: LIST
33822: PUSH
33823: EMPTY
33824: LIST
33825: LIST
33826: LIST
33827: LIST
33828: LIST
33829: LIST
33830: LIST
33831: LIST
33832: LIST
33833: LIST
33834: LIST
33835: LIST
33836: LIST
33837: LIST
33838: LIST
33839: LIST
33840: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
33841: LD_ADDR_VAR 0 12
33845: PUSH
33846: LD_INT 0
33848: PUSH
33849: LD_INT 0
33851: PUSH
33852: EMPTY
33853: LIST
33854: LIST
33855: PUSH
33856: LD_INT 0
33858: PUSH
33859: LD_INT 1
33861: NEG
33862: PUSH
33863: EMPTY
33864: LIST
33865: LIST
33866: PUSH
33867: LD_INT 1
33869: PUSH
33870: LD_INT 0
33872: PUSH
33873: EMPTY
33874: LIST
33875: LIST
33876: PUSH
33877: LD_INT 1
33879: PUSH
33880: LD_INT 1
33882: PUSH
33883: EMPTY
33884: LIST
33885: LIST
33886: PUSH
33887: LD_INT 0
33889: PUSH
33890: LD_INT 1
33892: PUSH
33893: EMPTY
33894: LIST
33895: LIST
33896: PUSH
33897: LD_INT 1
33899: NEG
33900: PUSH
33901: LD_INT 0
33903: PUSH
33904: EMPTY
33905: LIST
33906: LIST
33907: PUSH
33908: LD_INT 1
33910: NEG
33911: PUSH
33912: LD_INT 1
33914: NEG
33915: PUSH
33916: EMPTY
33917: LIST
33918: LIST
33919: PUSH
33920: LD_INT 1
33922: PUSH
33923: LD_INT 1
33925: NEG
33926: PUSH
33927: EMPTY
33928: LIST
33929: LIST
33930: PUSH
33931: LD_INT 2
33933: PUSH
33934: LD_INT 0
33936: PUSH
33937: EMPTY
33938: LIST
33939: LIST
33940: PUSH
33941: LD_INT 2
33943: PUSH
33944: LD_INT 1
33946: PUSH
33947: EMPTY
33948: LIST
33949: LIST
33950: PUSH
33951: LD_INT 1
33953: NEG
33954: PUSH
33955: LD_INT 1
33957: PUSH
33958: EMPTY
33959: LIST
33960: LIST
33961: PUSH
33962: LD_INT 2
33964: NEG
33965: PUSH
33966: LD_INT 0
33968: PUSH
33969: EMPTY
33970: LIST
33971: LIST
33972: PUSH
33973: LD_INT 2
33975: NEG
33976: PUSH
33977: LD_INT 1
33979: NEG
33980: PUSH
33981: EMPTY
33982: LIST
33983: LIST
33984: PUSH
33985: LD_INT 2
33987: NEG
33988: PUSH
33989: LD_INT 1
33991: PUSH
33992: EMPTY
33993: LIST
33994: LIST
33995: PUSH
33996: LD_INT 3
33998: NEG
33999: PUSH
34000: LD_INT 0
34002: PUSH
34003: EMPTY
34004: LIST
34005: LIST
34006: PUSH
34007: LD_INT 3
34009: NEG
34010: PUSH
34011: LD_INT 1
34013: NEG
34014: PUSH
34015: EMPTY
34016: LIST
34017: LIST
34018: PUSH
34019: EMPTY
34020: LIST
34021: LIST
34022: LIST
34023: LIST
34024: LIST
34025: LIST
34026: LIST
34027: LIST
34028: LIST
34029: LIST
34030: LIST
34031: LIST
34032: LIST
34033: LIST
34034: LIST
34035: LIST
34036: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
34037: LD_ADDR_VAR 0 13
34041: PUSH
34042: LD_INT 0
34044: PUSH
34045: LD_INT 0
34047: PUSH
34048: EMPTY
34049: LIST
34050: LIST
34051: PUSH
34052: LD_INT 0
34054: PUSH
34055: LD_INT 1
34057: NEG
34058: PUSH
34059: EMPTY
34060: LIST
34061: LIST
34062: PUSH
34063: LD_INT 1
34065: PUSH
34066: LD_INT 0
34068: PUSH
34069: EMPTY
34070: LIST
34071: LIST
34072: PUSH
34073: LD_INT 1
34075: PUSH
34076: LD_INT 1
34078: PUSH
34079: EMPTY
34080: LIST
34081: LIST
34082: PUSH
34083: LD_INT 0
34085: PUSH
34086: LD_INT 1
34088: PUSH
34089: EMPTY
34090: LIST
34091: LIST
34092: PUSH
34093: LD_INT 1
34095: NEG
34096: PUSH
34097: LD_INT 0
34099: PUSH
34100: EMPTY
34101: LIST
34102: LIST
34103: PUSH
34104: LD_INT 1
34106: NEG
34107: PUSH
34108: LD_INT 1
34110: NEG
34111: PUSH
34112: EMPTY
34113: LIST
34114: LIST
34115: PUSH
34116: LD_INT 1
34118: NEG
34119: PUSH
34120: LD_INT 2
34122: NEG
34123: PUSH
34124: EMPTY
34125: LIST
34126: LIST
34127: PUSH
34128: LD_INT 2
34130: PUSH
34131: LD_INT 1
34133: PUSH
34134: EMPTY
34135: LIST
34136: LIST
34137: PUSH
34138: LD_INT 2
34140: PUSH
34141: LD_INT 2
34143: PUSH
34144: EMPTY
34145: LIST
34146: LIST
34147: PUSH
34148: LD_INT 1
34150: PUSH
34151: LD_INT 2
34153: PUSH
34154: EMPTY
34155: LIST
34156: LIST
34157: PUSH
34158: LD_INT 2
34160: NEG
34161: PUSH
34162: LD_INT 1
34164: NEG
34165: PUSH
34166: EMPTY
34167: LIST
34168: LIST
34169: PUSH
34170: LD_INT 2
34172: NEG
34173: PUSH
34174: LD_INT 2
34176: NEG
34177: PUSH
34178: EMPTY
34179: LIST
34180: LIST
34181: PUSH
34182: LD_INT 2
34184: NEG
34185: PUSH
34186: LD_INT 3
34188: NEG
34189: PUSH
34190: EMPTY
34191: LIST
34192: LIST
34193: PUSH
34194: LD_INT 3
34196: NEG
34197: PUSH
34198: LD_INT 2
34200: NEG
34201: PUSH
34202: EMPTY
34203: LIST
34204: LIST
34205: PUSH
34206: LD_INT 3
34208: NEG
34209: PUSH
34210: LD_INT 3
34212: NEG
34213: PUSH
34214: EMPTY
34215: LIST
34216: LIST
34217: PUSH
34218: EMPTY
34219: LIST
34220: LIST
34221: LIST
34222: LIST
34223: LIST
34224: LIST
34225: LIST
34226: LIST
34227: LIST
34228: LIST
34229: LIST
34230: LIST
34231: LIST
34232: LIST
34233: LIST
34234: LIST
34235: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
34236: LD_ADDR_VAR 0 14
34240: PUSH
34241: LD_INT 0
34243: PUSH
34244: LD_INT 0
34246: PUSH
34247: EMPTY
34248: LIST
34249: LIST
34250: PUSH
34251: LD_INT 0
34253: PUSH
34254: LD_INT 1
34256: NEG
34257: PUSH
34258: EMPTY
34259: LIST
34260: LIST
34261: PUSH
34262: LD_INT 1
34264: PUSH
34265: LD_INT 0
34267: PUSH
34268: EMPTY
34269: LIST
34270: LIST
34271: PUSH
34272: LD_INT 1
34274: PUSH
34275: LD_INT 1
34277: PUSH
34278: EMPTY
34279: LIST
34280: LIST
34281: PUSH
34282: LD_INT 0
34284: PUSH
34285: LD_INT 1
34287: PUSH
34288: EMPTY
34289: LIST
34290: LIST
34291: PUSH
34292: LD_INT 1
34294: NEG
34295: PUSH
34296: LD_INT 0
34298: PUSH
34299: EMPTY
34300: LIST
34301: LIST
34302: PUSH
34303: LD_INT 1
34305: NEG
34306: PUSH
34307: LD_INT 1
34309: NEG
34310: PUSH
34311: EMPTY
34312: LIST
34313: LIST
34314: PUSH
34315: LD_INT 1
34317: NEG
34318: PUSH
34319: LD_INT 2
34321: NEG
34322: PUSH
34323: EMPTY
34324: LIST
34325: LIST
34326: PUSH
34327: LD_INT 0
34329: PUSH
34330: LD_INT 2
34332: NEG
34333: PUSH
34334: EMPTY
34335: LIST
34336: LIST
34337: PUSH
34338: LD_INT 1
34340: PUSH
34341: LD_INT 1
34343: NEG
34344: PUSH
34345: EMPTY
34346: LIST
34347: LIST
34348: PUSH
34349: LD_INT 1
34351: PUSH
34352: LD_INT 2
34354: PUSH
34355: EMPTY
34356: LIST
34357: LIST
34358: PUSH
34359: LD_INT 0
34361: PUSH
34362: LD_INT 2
34364: PUSH
34365: EMPTY
34366: LIST
34367: LIST
34368: PUSH
34369: LD_INT 1
34371: NEG
34372: PUSH
34373: LD_INT 1
34375: PUSH
34376: EMPTY
34377: LIST
34378: LIST
34379: PUSH
34380: LD_INT 1
34382: NEG
34383: PUSH
34384: LD_INT 3
34386: NEG
34387: PUSH
34388: EMPTY
34389: LIST
34390: LIST
34391: PUSH
34392: LD_INT 0
34394: PUSH
34395: LD_INT 3
34397: NEG
34398: PUSH
34399: EMPTY
34400: LIST
34401: LIST
34402: PUSH
34403: LD_INT 1
34405: PUSH
34406: LD_INT 2
34408: NEG
34409: PUSH
34410: EMPTY
34411: LIST
34412: LIST
34413: PUSH
34414: EMPTY
34415: LIST
34416: LIST
34417: LIST
34418: LIST
34419: LIST
34420: LIST
34421: LIST
34422: LIST
34423: LIST
34424: LIST
34425: LIST
34426: LIST
34427: LIST
34428: LIST
34429: LIST
34430: LIST
34431: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
34432: LD_ADDR_VAR 0 15
34436: PUSH
34437: LD_INT 0
34439: PUSH
34440: LD_INT 0
34442: PUSH
34443: EMPTY
34444: LIST
34445: LIST
34446: PUSH
34447: LD_INT 0
34449: PUSH
34450: LD_INT 1
34452: NEG
34453: PUSH
34454: EMPTY
34455: LIST
34456: LIST
34457: PUSH
34458: LD_INT 1
34460: PUSH
34461: LD_INT 0
34463: PUSH
34464: EMPTY
34465: LIST
34466: LIST
34467: PUSH
34468: LD_INT 1
34470: PUSH
34471: LD_INT 1
34473: PUSH
34474: EMPTY
34475: LIST
34476: LIST
34477: PUSH
34478: LD_INT 0
34480: PUSH
34481: LD_INT 1
34483: PUSH
34484: EMPTY
34485: LIST
34486: LIST
34487: PUSH
34488: LD_INT 1
34490: NEG
34491: PUSH
34492: LD_INT 0
34494: PUSH
34495: EMPTY
34496: LIST
34497: LIST
34498: PUSH
34499: LD_INT 1
34501: NEG
34502: PUSH
34503: LD_INT 1
34505: NEG
34506: PUSH
34507: EMPTY
34508: LIST
34509: LIST
34510: PUSH
34511: LD_INT 1
34513: PUSH
34514: LD_INT 1
34516: NEG
34517: PUSH
34518: EMPTY
34519: LIST
34520: LIST
34521: PUSH
34522: LD_INT 2
34524: PUSH
34525: LD_INT 0
34527: PUSH
34528: EMPTY
34529: LIST
34530: LIST
34531: PUSH
34532: LD_INT 2
34534: PUSH
34535: LD_INT 1
34537: PUSH
34538: EMPTY
34539: LIST
34540: LIST
34541: PUSH
34542: LD_INT 1
34544: NEG
34545: PUSH
34546: LD_INT 1
34548: PUSH
34549: EMPTY
34550: LIST
34551: LIST
34552: PUSH
34553: LD_INT 2
34555: NEG
34556: PUSH
34557: LD_INT 0
34559: PUSH
34560: EMPTY
34561: LIST
34562: LIST
34563: PUSH
34564: LD_INT 2
34566: NEG
34567: PUSH
34568: LD_INT 1
34570: NEG
34571: PUSH
34572: EMPTY
34573: LIST
34574: LIST
34575: PUSH
34576: LD_INT 2
34578: PUSH
34579: LD_INT 1
34581: NEG
34582: PUSH
34583: EMPTY
34584: LIST
34585: LIST
34586: PUSH
34587: LD_INT 3
34589: PUSH
34590: LD_INT 0
34592: PUSH
34593: EMPTY
34594: LIST
34595: LIST
34596: PUSH
34597: LD_INT 3
34599: PUSH
34600: LD_INT 1
34602: PUSH
34603: EMPTY
34604: LIST
34605: LIST
34606: PUSH
34607: EMPTY
34608: LIST
34609: LIST
34610: LIST
34611: LIST
34612: LIST
34613: LIST
34614: LIST
34615: LIST
34616: LIST
34617: LIST
34618: LIST
34619: LIST
34620: LIST
34621: LIST
34622: LIST
34623: LIST
34624: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
34625: LD_ADDR_VAR 0 16
34629: PUSH
34630: LD_INT 0
34632: PUSH
34633: LD_INT 0
34635: PUSH
34636: EMPTY
34637: LIST
34638: LIST
34639: PUSH
34640: LD_INT 0
34642: PUSH
34643: LD_INT 1
34645: NEG
34646: PUSH
34647: EMPTY
34648: LIST
34649: LIST
34650: PUSH
34651: LD_INT 1
34653: PUSH
34654: LD_INT 0
34656: PUSH
34657: EMPTY
34658: LIST
34659: LIST
34660: PUSH
34661: LD_INT 1
34663: PUSH
34664: LD_INT 1
34666: PUSH
34667: EMPTY
34668: LIST
34669: LIST
34670: PUSH
34671: LD_INT 0
34673: PUSH
34674: LD_INT 1
34676: PUSH
34677: EMPTY
34678: LIST
34679: LIST
34680: PUSH
34681: LD_INT 1
34683: NEG
34684: PUSH
34685: LD_INT 0
34687: PUSH
34688: EMPTY
34689: LIST
34690: LIST
34691: PUSH
34692: LD_INT 1
34694: NEG
34695: PUSH
34696: LD_INT 1
34698: NEG
34699: PUSH
34700: EMPTY
34701: LIST
34702: LIST
34703: PUSH
34704: LD_INT 1
34706: NEG
34707: PUSH
34708: LD_INT 2
34710: NEG
34711: PUSH
34712: EMPTY
34713: LIST
34714: LIST
34715: PUSH
34716: LD_INT 2
34718: PUSH
34719: LD_INT 1
34721: PUSH
34722: EMPTY
34723: LIST
34724: LIST
34725: PUSH
34726: LD_INT 2
34728: PUSH
34729: LD_INT 2
34731: PUSH
34732: EMPTY
34733: LIST
34734: LIST
34735: PUSH
34736: LD_INT 1
34738: PUSH
34739: LD_INT 2
34741: PUSH
34742: EMPTY
34743: LIST
34744: LIST
34745: PUSH
34746: LD_INT 2
34748: NEG
34749: PUSH
34750: LD_INT 1
34752: NEG
34753: PUSH
34754: EMPTY
34755: LIST
34756: LIST
34757: PUSH
34758: LD_INT 2
34760: NEG
34761: PUSH
34762: LD_INT 2
34764: NEG
34765: PUSH
34766: EMPTY
34767: LIST
34768: LIST
34769: PUSH
34770: LD_INT 3
34772: PUSH
34773: LD_INT 2
34775: PUSH
34776: EMPTY
34777: LIST
34778: LIST
34779: PUSH
34780: LD_INT 3
34782: PUSH
34783: LD_INT 3
34785: PUSH
34786: EMPTY
34787: LIST
34788: LIST
34789: PUSH
34790: LD_INT 2
34792: PUSH
34793: LD_INT 3
34795: PUSH
34796: EMPTY
34797: LIST
34798: LIST
34799: PUSH
34800: EMPTY
34801: LIST
34802: LIST
34803: LIST
34804: LIST
34805: LIST
34806: LIST
34807: LIST
34808: LIST
34809: LIST
34810: LIST
34811: LIST
34812: LIST
34813: LIST
34814: LIST
34815: LIST
34816: LIST
34817: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
34818: LD_ADDR_VAR 0 17
34822: PUSH
34823: LD_INT 0
34825: PUSH
34826: LD_INT 0
34828: PUSH
34829: EMPTY
34830: LIST
34831: LIST
34832: PUSH
34833: LD_INT 0
34835: PUSH
34836: LD_INT 1
34838: NEG
34839: PUSH
34840: EMPTY
34841: LIST
34842: LIST
34843: PUSH
34844: LD_INT 1
34846: PUSH
34847: LD_INT 0
34849: PUSH
34850: EMPTY
34851: LIST
34852: LIST
34853: PUSH
34854: LD_INT 1
34856: PUSH
34857: LD_INT 1
34859: PUSH
34860: EMPTY
34861: LIST
34862: LIST
34863: PUSH
34864: LD_INT 0
34866: PUSH
34867: LD_INT 1
34869: PUSH
34870: EMPTY
34871: LIST
34872: LIST
34873: PUSH
34874: LD_INT 1
34876: NEG
34877: PUSH
34878: LD_INT 0
34880: PUSH
34881: EMPTY
34882: LIST
34883: LIST
34884: PUSH
34885: LD_INT 1
34887: NEG
34888: PUSH
34889: LD_INT 1
34891: NEG
34892: PUSH
34893: EMPTY
34894: LIST
34895: LIST
34896: PUSH
34897: LD_INT 1
34899: NEG
34900: PUSH
34901: LD_INT 2
34903: NEG
34904: PUSH
34905: EMPTY
34906: LIST
34907: LIST
34908: PUSH
34909: LD_INT 0
34911: PUSH
34912: LD_INT 2
34914: NEG
34915: PUSH
34916: EMPTY
34917: LIST
34918: LIST
34919: PUSH
34920: LD_INT 1
34922: PUSH
34923: LD_INT 1
34925: NEG
34926: PUSH
34927: EMPTY
34928: LIST
34929: LIST
34930: PUSH
34931: LD_INT 2
34933: PUSH
34934: LD_INT 0
34936: PUSH
34937: EMPTY
34938: LIST
34939: LIST
34940: PUSH
34941: LD_INT 2
34943: PUSH
34944: LD_INT 1
34946: PUSH
34947: EMPTY
34948: LIST
34949: LIST
34950: PUSH
34951: LD_INT 2
34953: PUSH
34954: LD_INT 2
34956: PUSH
34957: EMPTY
34958: LIST
34959: LIST
34960: PUSH
34961: LD_INT 1
34963: PUSH
34964: LD_INT 2
34966: PUSH
34967: EMPTY
34968: LIST
34969: LIST
34970: PUSH
34971: LD_INT 0
34973: PUSH
34974: LD_INT 2
34976: PUSH
34977: EMPTY
34978: LIST
34979: LIST
34980: PUSH
34981: LD_INT 1
34983: NEG
34984: PUSH
34985: LD_INT 1
34987: PUSH
34988: EMPTY
34989: LIST
34990: LIST
34991: PUSH
34992: LD_INT 2
34994: NEG
34995: PUSH
34996: LD_INT 0
34998: PUSH
34999: EMPTY
35000: LIST
35001: LIST
35002: PUSH
35003: LD_INT 2
35005: NEG
35006: PUSH
35007: LD_INT 1
35009: NEG
35010: PUSH
35011: EMPTY
35012: LIST
35013: LIST
35014: PUSH
35015: LD_INT 2
35017: NEG
35018: PUSH
35019: LD_INT 2
35021: NEG
35022: PUSH
35023: EMPTY
35024: LIST
35025: LIST
35026: PUSH
35027: EMPTY
35028: LIST
35029: LIST
35030: LIST
35031: LIST
35032: LIST
35033: LIST
35034: LIST
35035: LIST
35036: LIST
35037: LIST
35038: LIST
35039: LIST
35040: LIST
35041: LIST
35042: LIST
35043: LIST
35044: LIST
35045: LIST
35046: LIST
35047: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
35048: LD_ADDR_VAR 0 18
35052: PUSH
35053: LD_INT 0
35055: PUSH
35056: LD_INT 0
35058: PUSH
35059: EMPTY
35060: LIST
35061: LIST
35062: PUSH
35063: LD_INT 0
35065: PUSH
35066: LD_INT 1
35068: NEG
35069: PUSH
35070: EMPTY
35071: LIST
35072: LIST
35073: PUSH
35074: LD_INT 1
35076: PUSH
35077: LD_INT 0
35079: PUSH
35080: EMPTY
35081: LIST
35082: LIST
35083: PUSH
35084: LD_INT 1
35086: PUSH
35087: LD_INT 1
35089: PUSH
35090: EMPTY
35091: LIST
35092: LIST
35093: PUSH
35094: LD_INT 0
35096: PUSH
35097: LD_INT 1
35099: PUSH
35100: EMPTY
35101: LIST
35102: LIST
35103: PUSH
35104: LD_INT 1
35106: NEG
35107: PUSH
35108: LD_INT 0
35110: PUSH
35111: EMPTY
35112: LIST
35113: LIST
35114: PUSH
35115: LD_INT 1
35117: NEG
35118: PUSH
35119: LD_INT 1
35121: NEG
35122: PUSH
35123: EMPTY
35124: LIST
35125: LIST
35126: PUSH
35127: LD_INT 1
35129: NEG
35130: PUSH
35131: LD_INT 2
35133: NEG
35134: PUSH
35135: EMPTY
35136: LIST
35137: LIST
35138: PUSH
35139: LD_INT 0
35141: PUSH
35142: LD_INT 2
35144: NEG
35145: PUSH
35146: EMPTY
35147: LIST
35148: LIST
35149: PUSH
35150: LD_INT 1
35152: PUSH
35153: LD_INT 1
35155: NEG
35156: PUSH
35157: EMPTY
35158: LIST
35159: LIST
35160: PUSH
35161: LD_INT 2
35163: PUSH
35164: LD_INT 0
35166: PUSH
35167: EMPTY
35168: LIST
35169: LIST
35170: PUSH
35171: LD_INT 2
35173: PUSH
35174: LD_INT 1
35176: PUSH
35177: EMPTY
35178: LIST
35179: LIST
35180: PUSH
35181: LD_INT 2
35183: PUSH
35184: LD_INT 2
35186: PUSH
35187: EMPTY
35188: LIST
35189: LIST
35190: PUSH
35191: LD_INT 1
35193: PUSH
35194: LD_INT 2
35196: PUSH
35197: EMPTY
35198: LIST
35199: LIST
35200: PUSH
35201: LD_INT 0
35203: PUSH
35204: LD_INT 2
35206: PUSH
35207: EMPTY
35208: LIST
35209: LIST
35210: PUSH
35211: LD_INT 1
35213: NEG
35214: PUSH
35215: LD_INT 1
35217: PUSH
35218: EMPTY
35219: LIST
35220: LIST
35221: PUSH
35222: LD_INT 2
35224: NEG
35225: PUSH
35226: LD_INT 0
35228: PUSH
35229: EMPTY
35230: LIST
35231: LIST
35232: PUSH
35233: LD_INT 2
35235: NEG
35236: PUSH
35237: LD_INT 1
35239: NEG
35240: PUSH
35241: EMPTY
35242: LIST
35243: LIST
35244: PUSH
35245: LD_INT 2
35247: NEG
35248: PUSH
35249: LD_INT 2
35251: NEG
35252: PUSH
35253: EMPTY
35254: LIST
35255: LIST
35256: PUSH
35257: EMPTY
35258: LIST
35259: LIST
35260: LIST
35261: LIST
35262: LIST
35263: LIST
35264: LIST
35265: LIST
35266: LIST
35267: LIST
35268: LIST
35269: LIST
35270: LIST
35271: LIST
35272: LIST
35273: LIST
35274: LIST
35275: LIST
35276: LIST
35277: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
35278: LD_ADDR_VAR 0 19
35282: PUSH
35283: LD_INT 0
35285: PUSH
35286: LD_INT 0
35288: PUSH
35289: EMPTY
35290: LIST
35291: LIST
35292: PUSH
35293: LD_INT 0
35295: PUSH
35296: LD_INT 1
35298: NEG
35299: PUSH
35300: EMPTY
35301: LIST
35302: LIST
35303: PUSH
35304: LD_INT 1
35306: PUSH
35307: LD_INT 0
35309: PUSH
35310: EMPTY
35311: LIST
35312: LIST
35313: PUSH
35314: LD_INT 1
35316: PUSH
35317: LD_INT 1
35319: PUSH
35320: EMPTY
35321: LIST
35322: LIST
35323: PUSH
35324: LD_INT 0
35326: PUSH
35327: LD_INT 1
35329: PUSH
35330: EMPTY
35331: LIST
35332: LIST
35333: PUSH
35334: LD_INT 1
35336: NEG
35337: PUSH
35338: LD_INT 0
35340: PUSH
35341: EMPTY
35342: LIST
35343: LIST
35344: PUSH
35345: LD_INT 1
35347: NEG
35348: PUSH
35349: LD_INT 1
35351: NEG
35352: PUSH
35353: EMPTY
35354: LIST
35355: LIST
35356: PUSH
35357: LD_INT 1
35359: NEG
35360: PUSH
35361: LD_INT 2
35363: NEG
35364: PUSH
35365: EMPTY
35366: LIST
35367: LIST
35368: PUSH
35369: LD_INT 0
35371: PUSH
35372: LD_INT 2
35374: NEG
35375: PUSH
35376: EMPTY
35377: LIST
35378: LIST
35379: PUSH
35380: LD_INT 1
35382: PUSH
35383: LD_INT 1
35385: NEG
35386: PUSH
35387: EMPTY
35388: LIST
35389: LIST
35390: PUSH
35391: LD_INT 2
35393: PUSH
35394: LD_INT 0
35396: PUSH
35397: EMPTY
35398: LIST
35399: LIST
35400: PUSH
35401: LD_INT 2
35403: PUSH
35404: LD_INT 1
35406: PUSH
35407: EMPTY
35408: LIST
35409: LIST
35410: PUSH
35411: LD_INT 2
35413: PUSH
35414: LD_INT 2
35416: PUSH
35417: EMPTY
35418: LIST
35419: LIST
35420: PUSH
35421: LD_INT 1
35423: PUSH
35424: LD_INT 2
35426: PUSH
35427: EMPTY
35428: LIST
35429: LIST
35430: PUSH
35431: LD_INT 0
35433: PUSH
35434: LD_INT 2
35436: PUSH
35437: EMPTY
35438: LIST
35439: LIST
35440: PUSH
35441: LD_INT 1
35443: NEG
35444: PUSH
35445: LD_INT 1
35447: PUSH
35448: EMPTY
35449: LIST
35450: LIST
35451: PUSH
35452: LD_INT 2
35454: NEG
35455: PUSH
35456: LD_INT 0
35458: PUSH
35459: EMPTY
35460: LIST
35461: LIST
35462: PUSH
35463: LD_INT 2
35465: NEG
35466: PUSH
35467: LD_INT 1
35469: NEG
35470: PUSH
35471: EMPTY
35472: LIST
35473: LIST
35474: PUSH
35475: LD_INT 2
35477: NEG
35478: PUSH
35479: LD_INT 2
35481: NEG
35482: PUSH
35483: EMPTY
35484: LIST
35485: LIST
35486: PUSH
35487: EMPTY
35488: LIST
35489: LIST
35490: LIST
35491: LIST
35492: LIST
35493: LIST
35494: LIST
35495: LIST
35496: LIST
35497: LIST
35498: LIST
35499: LIST
35500: LIST
35501: LIST
35502: LIST
35503: LIST
35504: LIST
35505: LIST
35506: LIST
35507: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
35508: LD_ADDR_VAR 0 20
35512: PUSH
35513: LD_INT 0
35515: PUSH
35516: LD_INT 0
35518: PUSH
35519: EMPTY
35520: LIST
35521: LIST
35522: PUSH
35523: LD_INT 0
35525: PUSH
35526: LD_INT 1
35528: NEG
35529: PUSH
35530: EMPTY
35531: LIST
35532: LIST
35533: PUSH
35534: LD_INT 1
35536: PUSH
35537: LD_INT 0
35539: PUSH
35540: EMPTY
35541: LIST
35542: LIST
35543: PUSH
35544: LD_INT 1
35546: PUSH
35547: LD_INT 1
35549: PUSH
35550: EMPTY
35551: LIST
35552: LIST
35553: PUSH
35554: LD_INT 0
35556: PUSH
35557: LD_INT 1
35559: PUSH
35560: EMPTY
35561: LIST
35562: LIST
35563: PUSH
35564: LD_INT 1
35566: NEG
35567: PUSH
35568: LD_INT 0
35570: PUSH
35571: EMPTY
35572: LIST
35573: LIST
35574: PUSH
35575: LD_INT 1
35577: NEG
35578: PUSH
35579: LD_INT 1
35581: NEG
35582: PUSH
35583: EMPTY
35584: LIST
35585: LIST
35586: PUSH
35587: LD_INT 1
35589: NEG
35590: PUSH
35591: LD_INT 2
35593: NEG
35594: PUSH
35595: EMPTY
35596: LIST
35597: LIST
35598: PUSH
35599: LD_INT 0
35601: PUSH
35602: LD_INT 2
35604: NEG
35605: PUSH
35606: EMPTY
35607: LIST
35608: LIST
35609: PUSH
35610: LD_INT 1
35612: PUSH
35613: LD_INT 1
35615: NEG
35616: PUSH
35617: EMPTY
35618: LIST
35619: LIST
35620: PUSH
35621: LD_INT 2
35623: PUSH
35624: LD_INT 0
35626: PUSH
35627: EMPTY
35628: LIST
35629: LIST
35630: PUSH
35631: LD_INT 2
35633: PUSH
35634: LD_INT 1
35636: PUSH
35637: EMPTY
35638: LIST
35639: LIST
35640: PUSH
35641: LD_INT 2
35643: PUSH
35644: LD_INT 2
35646: PUSH
35647: EMPTY
35648: LIST
35649: LIST
35650: PUSH
35651: LD_INT 1
35653: PUSH
35654: LD_INT 2
35656: PUSH
35657: EMPTY
35658: LIST
35659: LIST
35660: PUSH
35661: LD_INT 0
35663: PUSH
35664: LD_INT 2
35666: PUSH
35667: EMPTY
35668: LIST
35669: LIST
35670: PUSH
35671: LD_INT 1
35673: NEG
35674: PUSH
35675: LD_INT 1
35677: PUSH
35678: EMPTY
35679: LIST
35680: LIST
35681: PUSH
35682: LD_INT 2
35684: NEG
35685: PUSH
35686: LD_INT 0
35688: PUSH
35689: EMPTY
35690: LIST
35691: LIST
35692: PUSH
35693: LD_INT 2
35695: NEG
35696: PUSH
35697: LD_INT 1
35699: NEG
35700: PUSH
35701: EMPTY
35702: LIST
35703: LIST
35704: PUSH
35705: LD_INT 2
35707: NEG
35708: PUSH
35709: LD_INT 2
35711: NEG
35712: PUSH
35713: EMPTY
35714: LIST
35715: LIST
35716: PUSH
35717: EMPTY
35718: LIST
35719: LIST
35720: LIST
35721: LIST
35722: LIST
35723: LIST
35724: LIST
35725: LIST
35726: LIST
35727: LIST
35728: LIST
35729: LIST
35730: LIST
35731: LIST
35732: LIST
35733: LIST
35734: LIST
35735: LIST
35736: LIST
35737: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
35738: LD_ADDR_VAR 0 21
35742: PUSH
35743: LD_INT 0
35745: PUSH
35746: LD_INT 0
35748: PUSH
35749: EMPTY
35750: LIST
35751: LIST
35752: PUSH
35753: LD_INT 0
35755: PUSH
35756: LD_INT 1
35758: NEG
35759: PUSH
35760: EMPTY
35761: LIST
35762: LIST
35763: PUSH
35764: LD_INT 1
35766: PUSH
35767: LD_INT 0
35769: PUSH
35770: EMPTY
35771: LIST
35772: LIST
35773: PUSH
35774: LD_INT 1
35776: PUSH
35777: LD_INT 1
35779: PUSH
35780: EMPTY
35781: LIST
35782: LIST
35783: PUSH
35784: LD_INT 0
35786: PUSH
35787: LD_INT 1
35789: PUSH
35790: EMPTY
35791: LIST
35792: LIST
35793: PUSH
35794: LD_INT 1
35796: NEG
35797: PUSH
35798: LD_INT 0
35800: PUSH
35801: EMPTY
35802: LIST
35803: LIST
35804: PUSH
35805: LD_INT 1
35807: NEG
35808: PUSH
35809: LD_INT 1
35811: NEG
35812: PUSH
35813: EMPTY
35814: LIST
35815: LIST
35816: PUSH
35817: LD_INT 1
35819: NEG
35820: PUSH
35821: LD_INT 2
35823: NEG
35824: PUSH
35825: EMPTY
35826: LIST
35827: LIST
35828: PUSH
35829: LD_INT 0
35831: PUSH
35832: LD_INT 2
35834: NEG
35835: PUSH
35836: EMPTY
35837: LIST
35838: LIST
35839: PUSH
35840: LD_INT 1
35842: PUSH
35843: LD_INT 1
35845: NEG
35846: PUSH
35847: EMPTY
35848: LIST
35849: LIST
35850: PUSH
35851: LD_INT 2
35853: PUSH
35854: LD_INT 0
35856: PUSH
35857: EMPTY
35858: LIST
35859: LIST
35860: PUSH
35861: LD_INT 2
35863: PUSH
35864: LD_INT 1
35866: PUSH
35867: EMPTY
35868: LIST
35869: LIST
35870: PUSH
35871: LD_INT 2
35873: PUSH
35874: LD_INT 2
35876: PUSH
35877: EMPTY
35878: LIST
35879: LIST
35880: PUSH
35881: LD_INT 1
35883: PUSH
35884: LD_INT 2
35886: PUSH
35887: EMPTY
35888: LIST
35889: LIST
35890: PUSH
35891: LD_INT 0
35893: PUSH
35894: LD_INT 2
35896: PUSH
35897: EMPTY
35898: LIST
35899: LIST
35900: PUSH
35901: LD_INT 1
35903: NEG
35904: PUSH
35905: LD_INT 1
35907: PUSH
35908: EMPTY
35909: LIST
35910: LIST
35911: PUSH
35912: LD_INT 2
35914: NEG
35915: PUSH
35916: LD_INT 0
35918: PUSH
35919: EMPTY
35920: LIST
35921: LIST
35922: PUSH
35923: LD_INT 2
35925: NEG
35926: PUSH
35927: LD_INT 1
35929: NEG
35930: PUSH
35931: EMPTY
35932: LIST
35933: LIST
35934: PUSH
35935: LD_INT 2
35937: NEG
35938: PUSH
35939: LD_INT 2
35941: NEG
35942: PUSH
35943: EMPTY
35944: LIST
35945: LIST
35946: PUSH
35947: EMPTY
35948: LIST
35949: LIST
35950: LIST
35951: LIST
35952: LIST
35953: LIST
35954: LIST
35955: LIST
35956: LIST
35957: LIST
35958: LIST
35959: LIST
35960: LIST
35961: LIST
35962: LIST
35963: LIST
35964: LIST
35965: LIST
35966: LIST
35967: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
35968: LD_ADDR_VAR 0 22
35972: PUSH
35973: LD_INT 0
35975: PUSH
35976: LD_INT 0
35978: PUSH
35979: EMPTY
35980: LIST
35981: LIST
35982: PUSH
35983: LD_INT 0
35985: PUSH
35986: LD_INT 1
35988: NEG
35989: PUSH
35990: EMPTY
35991: LIST
35992: LIST
35993: PUSH
35994: LD_INT 1
35996: PUSH
35997: LD_INT 0
35999: PUSH
36000: EMPTY
36001: LIST
36002: LIST
36003: PUSH
36004: LD_INT 1
36006: PUSH
36007: LD_INT 1
36009: PUSH
36010: EMPTY
36011: LIST
36012: LIST
36013: PUSH
36014: LD_INT 0
36016: PUSH
36017: LD_INT 1
36019: PUSH
36020: EMPTY
36021: LIST
36022: LIST
36023: PUSH
36024: LD_INT 1
36026: NEG
36027: PUSH
36028: LD_INT 0
36030: PUSH
36031: EMPTY
36032: LIST
36033: LIST
36034: PUSH
36035: LD_INT 1
36037: NEG
36038: PUSH
36039: LD_INT 1
36041: NEG
36042: PUSH
36043: EMPTY
36044: LIST
36045: LIST
36046: PUSH
36047: LD_INT 1
36049: NEG
36050: PUSH
36051: LD_INT 2
36053: NEG
36054: PUSH
36055: EMPTY
36056: LIST
36057: LIST
36058: PUSH
36059: LD_INT 0
36061: PUSH
36062: LD_INT 2
36064: NEG
36065: PUSH
36066: EMPTY
36067: LIST
36068: LIST
36069: PUSH
36070: LD_INT 1
36072: PUSH
36073: LD_INT 1
36075: NEG
36076: PUSH
36077: EMPTY
36078: LIST
36079: LIST
36080: PUSH
36081: LD_INT 2
36083: PUSH
36084: LD_INT 0
36086: PUSH
36087: EMPTY
36088: LIST
36089: LIST
36090: PUSH
36091: LD_INT 2
36093: PUSH
36094: LD_INT 1
36096: PUSH
36097: EMPTY
36098: LIST
36099: LIST
36100: PUSH
36101: LD_INT 2
36103: PUSH
36104: LD_INT 2
36106: PUSH
36107: EMPTY
36108: LIST
36109: LIST
36110: PUSH
36111: LD_INT 1
36113: PUSH
36114: LD_INT 2
36116: PUSH
36117: EMPTY
36118: LIST
36119: LIST
36120: PUSH
36121: LD_INT 0
36123: PUSH
36124: LD_INT 2
36126: PUSH
36127: EMPTY
36128: LIST
36129: LIST
36130: PUSH
36131: LD_INT 1
36133: NEG
36134: PUSH
36135: LD_INT 1
36137: PUSH
36138: EMPTY
36139: LIST
36140: LIST
36141: PUSH
36142: LD_INT 2
36144: NEG
36145: PUSH
36146: LD_INT 0
36148: PUSH
36149: EMPTY
36150: LIST
36151: LIST
36152: PUSH
36153: LD_INT 2
36155: NEG
36156: PUSH
36157: LD_INT 1
36159: NEG
36160: PUSH
36161: EMPTY
36162: LIST
36163: LIST
36164: PUSH
36165: LD_INT 2
36167: NEG
36168: PUSH
36169: LD_INT 2
36171: NEG
36172: PUSH
36173: EMPTY
36174: LIST
36175: LIST
36176: PUSH
36177: EMPTY
36178: LIST
36179: LIST
36180: LIST
36181: LIST
36182: LIST
36183: LIST
36184: LIST
36185: LIST
36186: LIST
36187: LIST
36188: LIST
36189: LIST
36190: LIST
36191: LIST
36192: LIST
36193: LIST
36194: LIST
36195: LIST
36196: LIST
36197: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
36198: LD_ADDR_VAR 0 23
36202: PUSH
36203: LD_INT 0
36205: PUSH
36206: LD_INT 0
36208: PUSH
36209: EMPTY
36210: LIST
36211: LIST
36212: PUSH
36213: LD_INT 0
36215: PUSH
36216: LD_INT 1
36218: NEG
36219: PUSH
36220: EMPTY
36221: LIST
36222: LIST
36223: PUSH
36224: LD_INT 1
36226: PUSH
36227: LD_INT 0
36229: PUSH
36230: EMPTY
36231: LIST
36232: LIST
36233: PUSH
36234: LD_INT 1
36236: PUSH
36237: LD_INT 1
36239: PUSH
36240: EMPTY
36241: LIST
36242: LIST
36243: PUSH
36244: LD_INT 0
36246: PUSH
36247: LD_INT 1
36249: PUSH
36250: EMPTY
36251: LIST
36252: LIST
36253: PUSH
36254: LD_INT 1
36256: NEG
36257: PUSH
36258: LD_INT 0
36260: PUSH
36261: EMPTY
36262: LIST
36263: LIST
36264: PUSH
36265: LD_INT 1
36267: NEG
36268: PUSH
36269: LD_INT 1
36271: NEG
36272: PUSH
36273: EMPTY
36274: LIST
36275: LIST
36276: PUSH
36277: LD_INT 1
36279: NEG
36280: PUSH
36281: LD_INT 2
36283: NEG
36284: PUSH
36285: EMPTY
36286: LIST
36287: LIST
36288: PUSH
36289: LD_INT 0
36291: PUSH
36292: LD_INT 2
36294: NEG
36295: PUSH
36296: EMPTY
36297: LIST
36298: LIST
36299: PUSH
36300: LD_INT 1
36302: PUSH
36303: LD_INT 1
36305: NEG
36306: PUSH
36307: EMPTY
36308: LIST
36309: LIST
36310: PUSH
36311: LD_INT 2
36313: PUSH
36314: LD_INT 0
36316: PUSH
36317: EMPTY
36318: LIST
36319: LIST
36320: PUSH
36321: LD_INT 2
36323: PUSH
36324: LD_INT 1
36326: PUSH
36327: EMPTY
36328: LIST
36329: LIST
36330: PUSH
36331: LD_INT 2
36333: PUSH
36334: LD_INT 2
36336: PUSH
36337: EMPTY
36338: LIST
36339: LIST
36340: PUSH
36341: LD_INT 1
36343: PUSH
36344: LD_INT 2
36346: PUSH
36347: EMPTY
36348: LIST
36349: LIST
36350: PUSH
36351: LD_INT 0
36353: PUSH
36354: LD_INT 2
36356: PUSH
36357: EMPTY
36358: LIST
36359: LIST
36360: PUSH
36361: LD_INT 1
36363: NEG
36364: PUSH
36365: LD_INT 1
36367: PUSH
36368: EMPTY
36369: LIST
36370: LIST
36371: PUSH
36372: LD_INT 2
36374: NEG
36375: PUSH
36376: LD_INT 0
36378: PUSH
36379: EMPTY
36380: LIST
36381: LIST
36382: PUSH
36383: LD_INT 2
36385: NEG
36386: PUSH
36387: LD_INT 1
36389: NEG
36390: PUSH
36391: EMPTY
36392: LIST
36393: LIST
36394: PUSH
36395: LD_INT 2
36397: NEG
36398: PUSH
36399: LD_INT 2
36401: NEG
36402: PUSH
36403: EMPTY
36404: LIST
36405: LIST
36406: PUSH
36407: LD_INT 2
36409: NEG
36410: PUSH
36411: LD_INT 3
36413: NEG
36414: PUSH
36415: EMPTY
36416: LIST
36417: LIST
36418: PUSH
36419: LD_INT 1
36421: NEG
36422: PUSH
36423: LD_INT 3
36425: NEG
36426: PUSH
36427: EMPTY
36428: LIST
36429: LIST
36430: PUSH
36431: LD_INT 1
36433: PUSH
36434: LD_INT 2
36436: NEG
36437: PUSH
36438: EMPTY
36439: LIST
36440: LIST
36441: PUSH
36442: LD_INT 2
36444: PUSH
36445: LD_INT 1
36447: NEG
36448: PUSH
36449: EMPTY
36450: LIST
36451: LIST
36452: PUSH
36453: EMPTY
36454: LIST
36455: LIST
36456: LIST
36457: LIST
36458: LIST
36459: LIST
36460: LIST
36461: LIST
36462: LIST
36463: LIST
36464: LIST
36465: LIST
36466: LIST
36467: LIST
36468: LIST
36469: LIST
36470: LIST
36471: LIST
36472: LIST
36473: LIST
36474: LIST
36475: LIST
36476: LIST
36477: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
36478: LD_ADDR_VAR 0 24
36482: PUSH
36483: LD_INT 0
36485: PUSH
36486: LD_INT 0
36488: PUSH
36489: EMPTY
36490: LIST
36491: LIST
36492: PUSH
36493: LD_INT 0
36495: PUSH
36496: LD_INT 1
36498: NEG
36499: PUSH
36500: EMPTY
36501: LIST
36502: LIST
36503: PUSH
36504: LD_INT 1
36506: PUSH
36507: LD_INT 0
36509: PUSH
36510: EMPTY
36511: LIST
36512: LIST
36513: PUSH
36514: LD_INT 1
36516: PUSH
36517: LD_INT 1
36519: PUSH
36520: EMPTY
36521: LIST
36522: LIST
36523: PUSH
36524: LD_INT 0
36526: PUSH
36527: LD_INT 1
36529: PUSH
36530: EMPTY
36531: LIST
36532: LIST
36533: PUSH
36534: LD_INT 1
36536: NEG
36537: PUSH
36538: LD_INT 0
36540: PUSH
36541: EMPTY
36542: LIST
36543: LIST
36544: PUSH
36545: LD_INT 1
36547: NEG
36548: PUSH
36549: LD_INT 1
36551: NEG
36552: PUSH
36553: EMPTY
36554: LIST
36555: LIST
36556: PUSH
36557: LD_INT 1
36559: NEG
36560: PUSH
36561: LD_INT 2
36563: NEG
36564: PUSH
36565: EMPTY
36566: LIST
36567: LIST
36568: PUSH
36569: LD_INT 0
36571: PUSH
36572: LD_INT 2
36574: NEG
36575: PUSH
36576: EMPTY
36577: LIST
36578: LIST
36579: PUSH
36580: LD_INT 1
36582: PUSH
36583: LD_INT 1
36585: NEG
36586: PUSH
36587: EMPTY
36588: LIST
36589: LIST
36590: PUSH
36591: LD_INT 2
36593: PUSH
36594: LD_INT 0
36596: PUSH
36597: EMPTY
36598: LIST
36599: LIST
36600: PUSH
36601: LD_INT 2
36603: PUSH
36604: LD_INT 1
36606: PUSH
36607: EMPTY
36608: LIST
36609: LIST
36610: PUSH
36611: LD_INT 2
36613: PUSH
36614: LD_INT 2
36616: PUSH
36617: EMPTY
36618: LIST
36619: LIST
36620: PUSH
36621: LD_INT 1
36623: PUSH
36624: LD_INT 2
36626: PUSH
36627: EMPTY
36628: LIST
36629: LIST
36630: PUSH
36631: LD_INT 0
36633: PUSH
36634: LD_INT 2
36636: PUSH
36637: EMPTY
36638: LIST
36639: LIST
36640: PUSH
36641: LD_INT 1
36643: NEG
36644: PUSH
36645: LD_INT 1
36647: PUSH
36648: EMPTY
36649: LIST
36650: LIST
36651: PUSH
36652: LD_INT 2
36654: NEG
36655: PUSH
36656: LD_INT 0
36658: PUSH
36659: EMPTY
36660: LIST
36661: LIST
36662: PUSH
36663: LD_INT 2
36665: NEG
36666: PUSH
36667: LD_INT 1
36669: NEG
36670: PUSH
36671: EMPTY
36672: LIST
36673: LIST
36674: PUSH
36675: LD_INT 2
36677: NEG
36678: PUSH
36679: LD_INT 2
36681: NEG
36682: PUSH
36683: EMPTY
36684: LIST
36685: LIST
36686: PUSH
36687: LD_INT 1
36689: PUSH
36690: LD_INT 2
36692: NEG
36693: PUSH
36694: EMPTY
36695: LIST
36696: LIST
36697: PUSH
36698: LD_INT 2
36700: PUSH
36701: LD_INT 1
36703: NEG
36704: PUSH
36705: EMPTY
36706: LIST
36707: LIST
36708: PUSH
36709: LD_INT 3
36711: PUSH
36712: LD_INT 1
36714: PUSH
36715: EMPTY
36716: LIST
36717: LIST
36718: PUSH
36719: LD_INT 3
36721: PUSH
36722: LD_INT 2
36724: PUSH
36725: EMPTY
36726: LIST
36727: LIST
36728: PUSH
36729: EMPTY
36730: LIST
36731: LIST
36732: LIST
36733: LIST
36734: LIST
36735: LIST
36736: LIST
36737: LIST
36738: LIST
36739: LIST
36740: LIST
36741: LIST
36742: LIST
36743: LIST
36744: LIST
36745: LIST
36746: LIST
36747: LIST
36748: LIST
36749: LIST
36750: LIST
36751: LIST
36752: LIST
36753: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
36754: LD_ADDR_VAR 0 25
36758: PUSH
36759: LD_INT 0
36761: PUSH
36762: LD_INT 0
36764: PUSH
36765: EMPTY
36766: LIST
36767: LIST
36768: PUSH
36769: LD_INT 0
36771: PUSH
36772: LD_INT 1
36774: NEG
36775: PUSH
36776: EMPTY
36777: LIST
36778: LIST
36779: PUSH
36780: LD_INT 1
36782: PUSH
36783: LD_INT 0
36785: PUSH
36786: EMPTY
36787: LIST
36788: LIST
36789: PUSH
36790: LD_INT 1
36792: PUSH
36793: LD_INT 1
36795: PUSH
36796: EMPTY
36797: LIST
36798: LIST
36799: PUSH
36800: LD_INT 0
36802: PUSH
36803: LD_INT 1
36805: PUSH
36806: EMPTY
36807: LIST
36808: LIST
36809: PUSH
36810: LD_INT 1
36812: NEG
36813: PUSH
36814: LD_INT 0
36816: PUSH
36817: EMPTY
36818: LIST
36819: LIST
36820: PUSH
36821: LD_INT 1
36823: NEG
36824: PUSH
36825: LD_INT 1
36827: NEG
36828: PUSH
36829: EMPTY
36830: LIST
36831: LIST
36832: PUSH
36833: LD_INT 1
36835: NEG
36836: PUSH
36837: LD_INT 2
36839: NEG
36840: PUSH
36841: EMPTY
36842: LIST
36843: LIST
36844: PUSH
36845: LD_INT 0
36847: PUSH
36848: LD_INT 2
36850: NEG
36851: PUSH
36852: EMPTY
36853: LIST
36854: LIST
36855: PUSH
36856: LD_INT 1
36858: PUSH
36859: LD_INT 1
36861: NEG
36862: PUSH
36863: EMPTY
36864: LIST
36865: LIST
36866: PUSH
36867: LD_INT 2
36869: PUSH
36870: LD_INT 0
36872: PUSH
36873: EMPTY
36874: LIST
36875: LIST
36876: PUSH
36877: LD_INT 2
36879: PUSH
36880: LD_INT 1
36882: PUSH
36883: EMPTY
36884: LIST
36885: LIST
36886: PUSH
36887: LD_INT 2
36889: PUSH
36890: LD_INT 2
36892: PUSH
36893: EMPTY
36894: LIST
36895: LIST
36896: PUSH
36897: LD_INT 1
36899: PUSH
36900: LD_INT 2
36902: PUSH
36903: EMPTY
36904: LIST
36905: LIST
36906: PUSH
36907: LD_INT 0
36909: PUSH
36910: LD_INT 2
36912: PUSH
36913: EMPTY
36914: LIST
36915: LIST
36916: PUSH
36917: LD_INT 1
36919: NEG
36920: PUSH
36921: LD_INT 1
36923: PUSH
36924: EMPTY
36925: LIST
36926: LIST
36927: PUSH
36928: LD_INT 2
36930: NEG
36931: PUSH
36932: LD_INT 0
36934: PUSH
36935: EMPTY
36936: LIST
36937: LIST
36938: PUSH
36939: LD_INT 2
36941: NEG
36942: PUSH
36943: LD_INT 1
36945: NEG
36946: PUSH
36947: EMPTY
36948: LIST
36949: LIST
36950: PUSH
36951: LD_INT 2
36953: NEG
36954: PUSH
36955: LD_INT 2
36957: NEG
36958: PUSH
36959: EMPTY
36960: LIST
36961: LIST
36962: PUSH
36963: LD_INT 3
36965: PUSH
36966: LD_INT 1
36968: PUSH
36969: EMPTY
36970: LIST
36971: LIST
36972: PUSH
36973: LD_INT 3
36975: PUSH
36976: LD_INT 2
36978: PUSH
36979: EMPTY
36980: LIST
36981: LIST
36982: PUSH
36983: LD_INT 2
36985: PUSH
36986: LD_INT 3
36988: PUSH
36989: EMPTY
36990: LIST
36991: LIST
36992: PUSH
36993: LD_INT 1
36995: PUSH
36996: LD_INT 3
36998: PUSH
36999: EMPTY
37000: LIST
37001: LIST
37002: PUSH
37003: EMPTY
37004: LIST
37005: LIST
37006: LIST
37007: LIST
37008: LIST
37009: LIST
37010: LIST
37011: LIST
37012: LIST
37013: LIST
37014: LIST
37015: LIST
37016: LIST
37017: LIST
37018: LIST
37019: LIST
37020: LIST
37021: LIST
37022: LIST
37023: LIST
37024: LIST
37025: LIST
37026: LIST
37027: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
37028: LD_ADDR_VAR 0 26
37032: PUSH
37033: LD_INT 0
37035: PUSH
37036: LD_INT 0
37038: PUSH
37039: EMPTY
37040: LIST
37041: LIST
37042: PUSH
37043: LD_INT 0
37045: PUSH
37046: LD_INT 1
37048: NEG
37049: PUSH
37050: EMPTY
37051: LIST
37052: LIST
37053: PUSH
37054: LD_INT 1
37056: PUSH
37057: LD_INT 0
37059: PUSH
37060: EMPTY
37061: LIST
37062: LIST
37063: PUSH
37064: LD_INT 1
37066: PUSH
37067: LD_INT 1
37069: PUSH
37070: EMPTY
37071: LIST
37072: LIST
37073: PUSH
37074: LD_INT 0
37076: PUSH
37077: LD_INT 1
37079: PUSH
37080: EMPTY
37081: LIST
37082: LIST
37083: PUSH
37084: LD_INT 1
37086: NEG
37087: PUSH
37088: LD_INT 0
37090: PUSH
37091: EMPTY
37092: LIST
37093: LIST
37094: PUSH
37095: LD_INT 1
37097: NEG
37098: PUSH
37099: LD_INT 1
37101: NEG
37102: PUSH
37103: EMPTY
37104: LIST
37105: LIST
37106: PUSH
37107: LD_INT 1
37109: NEG
37110: PUSH
37111: LD_INT 2
37113: NEG
37114: PUSH
37115: EMPTY
37116: LIST
37117: LIST
37118: PUSH
37119: LD_INT 0
37121: PUSH
37122: LD_INT 2
37124: NEG
37125: PUSH
37126: EMPTY
37127: LIST
37128: LIST
37129: PUSH
37130: LD_INT 1
37132: PUSH
37133: LD_INT 1
37135: NEG
37136: PUSH
37137: EMPTY
37138: LIST
37139: LIST
37140: PUSH
37141: LD_INT 2
37143: PUSH
37144: LD_INT 0
37146: PUSH
37147: EMPTY
37148: LIST
37149: LIST
37150: PUSH
37151: LD_INT 2
37153: PUSH
37154: LD_INT 1
37156: PUSH
37157: EMPTY
37158: LIST
37159: LIST
37160: PUSH
37161: LD_INT 2
37163: PUSH
37164: LD_INT 2
37166: PUSH
37167: EMPTY
37168: LIST
37169: LIST
37170: PUSH
37171: LD_INT 1
37173: PUSH
37174: LD_INT 2
37176: PUSH
37177: EMPTY
37178: LIST
37179: LIST
37180: PUSH
37181: LD_INT 0
37183: PUSH
37184: LD_INT 2
37186: PUSH
37187: EMPTY
37188: LIST
37189: LIST
37190: PUSH
37191: LD_INT 1
37193: NEG
37194: PUSH
37195: LD_INT 1
37197: PUSH
37198: EMPTY
37199: LIST
37200: LIST
37201: PUSH
37202: LD_INT 2
37204: NEG
37205: PUSH
37206: LD_INT 0
37208: PUSH
37209: EMPTY
37210: LIST
37211: LIST
37212: PUSH
37213: LD_INT 2
37215: NEG
37216: PUSH
37217: LD_INT 1
37219: NEG
37220: PUSH
37221: EMPTY
37222: LIST
37223: LIST
37224: PUSH
37225: LD_INT 2
37227: NEG
37228: PUSH
37229: LD_INT 2
37231: NEG
37232: PUSH
37233: EMPTY
37234: LIST
37235: LIST
37236: PUSH
37237: LD_INT 2
37239: PUSH
37240: LD_INT 3
37242: PUSH
37243: EMPTY
37244: LIST
37245: LIST
37246: PUSH
37247: LD_INT 1
37249: PUSH
37250: LD_INT 3
37252: PUSH
37253: EMPTY
37254: LIST
37255: LIST
37256: PUSH
37257: LD_INT 1
37259: NEG
37260: PUSH
37261: LD_INT 2
37263: PUSH
37264: EMPTY
37265: LIST
37266: LIST
37267: PUSH
37268: LD_INT 2
37270: NEG
37271: PUSH
37272: LD_INT 1
37274: PUSH
37275: EMPTY
37276: LIST
37277: LIST
37278: PUSH
37279: EMPTY
37280: LIST
37281: LIST
37282: LIST
37283: LIST
37284: LIST
37285: LIST
37286: LIST
37287: LIST
37288: LIST
37289: LIST
37290: LIST
37291: LIST
37292: LIST
37293: LIST
37294: LIST
37295: LIST
37296: LIST
37297: LIST
37298: LIST
37299: LIST
37300: LIST
37301: LIST
37302: LIST
37303: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
37304: LD_ADDR_VAR 0 27
37308: PUSH
37309: LD_INT 0
37311: PUSH
37312: LD_INT 0
37314: PUSH
37315: EMPTY
37316: LIST
37317: LIST
37318: PUSH
37319: LD_INT 0
37321: PUSH
37322: LD_INT 1
37324: NEG
37325: PUSH
37326: EMPTY
37327: LIST
37328: LIST
37329: PUSH
37330: LD_INT 1
37332: PUSH
37333: LD_INT 0
37335: PUSH
37336: EMPTY
37337: LIST
37338: LIST
37339: PUSH
37340: LD_INT 1
37342: PUSH
37343: LD_INT 1
37345: PUSH
37346: EMPTY
37347: LIST
37348: LIST
37349: PUSH
37350: LD_INT 0
37352: PUSH
37353: LD_INT 1
37355: PUSH
37356: EMPTY
37357: LIST
37358: LIST
37359: PUSH
37360: LD_INT 1
37362: NEG
37363: PUSH
37364: LD_INT 0
37366: PUSH
37367: EMPTY
37368: LIST
37369: LIST
37370: PUSH
37371: LD_INT 1
37373: NEG
37374: PUSH
37375: LD_INT 1
37377: NEG
37378: PUSH
37379: EMPTY
37380: LIST
37381: LIST
37382: PUSH
37383: LD_INT 1
37385: NEG
37386: PUSH
37387: LD_INT 2
37389: NEG
37390: PUSH
37391: EMPTY
37392: LIST
37393: LIST
37394: PUSH
37395: LD_INT 0
37397: PUSH
37398: LD_INT 2
37400: NEG
37401: PUSH
37402: EMPTY
37403: LIST
37404: LIST
37405: PUSH
37406: LD_INT 1
37408: PUSH
37409: LD_INT 1
37411: NEG
37412: PUSH
37413: EMPTY
37414: LIST
37415: LIST
37416: PUSH
37417: LD_INT 2
37419: PUSH
37420: LD_INT 0
37422: PUSH
37423: EMPTY
37424: LIST
37425: LIST
37426: PUSH
37427: LD_INT 2
37429: PUSH
37430: LD_INT 1
37432: PUSH
37433: EMPTY
37434: LIST
37435: LIST
37436: PUSH
37437: LD_INT 2
37439: PUSH
37440: LD_INT 2
37442: PUSH
37443: EMPTY
37444: LIST
37445: LIST
37446: PUSH
37447: LD_INT 1
37449: PUSH
37450: LD_INT 2
37452: PUSH
37453: EMPTY
37454: LIST
37455: LIST
37456: PUSH
37457: LD_INT 0
37459: PUSH
37460: LD_INT 2
37462: PUSH
37463: EMPTY
37464: LIST
37465: LIST
37466: PUSH
37467: LD_INT 1
37469: NEG
37470: PUSH
37471: LD_INT 1
37473: PUSH
37474: EMPTY
37475: LIST
37476: LIST
37477: PUSH
37478: LD_INT 2
37480: NEG
37481: PUSH
37482: LD_INT 0
37484: PUSH
37485: EMPTY
37486: LIST
37487: LIST
37488: PUSH
37489: LD_INT 2
37491: NEG
37492: PUSH
37493: LD_INT 1
37495: NEG
37496: PUSH
37497: EMPTY
37498: LIST
37499: LIST
37500: PUSH
37501: LD_INT 2
37503: NEG
37504: PUSH
37505: LD_INT 2
37507: NEG
37508: PUSH
37509: EMPTY
37510: LIST
37511: LIST
37512: PUSH
37513: LD_INT 1
37515: NEG
37516: PUSH
37517: LD_INT 2
37519: PUSH
37520: EMPTY
37521: LIST
37522: LIST
37523: PUSH
37524: LD_INT 2
37526: NEG
37527: PUSH
37528: LD_INT 1
37530: PUSH
37531: EMPTY
37532: LIST
37533: LIST
37534: PUSH
37535: LD_INT 3
37537: NEG
37538: PUSH
37539: LD_INT 1
37541: NEG
37542: PUSH
37543: EMPTY
37544: LIST
37545: LIST
37546: PUSH
37547: LD_INT 3
37549: NEG
37550: PUSH
37551: LD_INT 2
37553: NEG
37554: PUSH
37555: EMPTY
37556: LIST
37557: LIST
37558: PUSH
37559: EMPTY
37560: LIST
37561: LIST
37562: LIST
37563: LIST
37564: LIST
37565: LIST
37566: LIST
37567: LIST
37568: LIST
37569: LIST
37570: LIST
37571: LIST
37572: LIST
37573: LIST
37574: LIST
37575: LIST
37576: LIST
37577: LIST
37578: LIST
37579: LIST
37580: LIST
37581: LIST
37582: LIST
37583: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
37584: LD_ADDR_VAR 0 28
37588: PUSH
37589: LD_INT 0
37591: PUSH
37592: LD_INT 0
37594: PUSH
37595: EMPTY
37596: LIST
37597: LIST
37598: PUSH
37599: LD_INT 0
37601: PUSH
37602: LD_INT 1
37604: NEG
37605: PUSH
37606: EMPTY
37607: LIST
37608: LIST
37609: PUSH
37610: LD_INT 1
37612: PUSH
37613: LD_INT 0
37615: PUSH
37616: EMPTY
37617: LIST
37618: LIST
37619: PUSH
37620: LD_INT 1
37622: PUSH
37623: LD_INT 1
37625: PUSH
37626: EMPTY
37627: LIST
37628: LIST
37629: PUSH
37630: LD_INT 0
37632: PUSH
37633: LD_INT 1
37635: PUSH
37636: EMPTY
37637: LIST
37638: LIST
37639: PUSH
37640: LD_INT 1
37642: NEG
37643: PUSH
37644: LD_INT 0
37646: PUSH
37647: EMPTY
37648: LIST
37649: LIST
37650: PUSH
37651: LD_INT 1
37653: NEG
37654: PUSH
37655: LD_INT 1
37657: NEG
37658: PUSH
37659: EMPTY
37660: LIST
37661: LIST
37662: PUSH
37663: LD_INT 1
37665: NEG
37666: PUSH
37667: LD_INT 2
37669: NEG
37670: PUSH
37671: EMPTY
37672: LIST
37673: LIST
37674: PUSH
37675: LD_INT 0
37677: PUSH
37678: LD_INT 2
37680: NEG
37681: PUSH
37682: EMPTY
37683: LIST
37684: LIST
37685: PUSH
37686: LD_INT 1
37688: PUSH
37689: LD_INT 1
37691: NEG
37692: PUSH
37693: EMPTY
37694: LIST
37695: LIST
37696: PUSH
37697: LD_INT 2
37699: PUSH
37700: LD_INT 0
37702: PUSH
37703: EMPTY
37704: LIST
37705: LIST
37706: PUSH
37707: LD_INT 2
37709: PUSH
37710: LD_INT 1
37712: PUSH
37713: EMPTY
37714: LIST
37715: LIST
37716: PUSH
37717: LD_INT 2
37719: PUSH
37720: LD_INT 2
37722: PUSH
37723: EMPTY
37724: LIST
37725: LIST
37726: PUSH
37727: LD_INT 1
37729: PUSH
37730: LD_INT 2
37732: PUSH
37733: EMPTY
37734: LIST
37735: LIST
37736: PUSH
37737: LD_INT 0
37739: PUSH
37740: LD_INT 2
37742: PUSH
37743: EMPTY
37744: LIST
37745: LIST
37746: PUSH
37747: LD_INT 1
37749: NEG
37750: PUSH
37751: LD_INT 1
37753: PUSH
37754: EMPTY
37755: LIST
37756: LIST
37757: PUSH
37758: LD_INT 2
37760: NEG
37761: PUSH
37762: LD_INT 0
37764: PUSH
37765: EMPTY
37766: LIST
37767: LIST
37768: PUSH
37769: LD_INT 2
37771: NEG
37772: PUSH
37773: LD_INT 1
37775: NEG
37776: PUSH
37777: EMPTY
37778: LIST
37779: LIST
37780: PUSH
37781: LD_INT 2
37783: NEG
37784: PUSH
37785: LD_INT 2
37787: NEG
37788: PUSH
37789: EMPTY
37790: LIST
37791: LIST
37792: PUSH
37793: LD_INT 2
37795: NEG
37796: PUSH
37797: LD_INT 3
37799: NEG
37800: PUSH
37801: EMPTY
37802: LIST
37803: LIST
37804: PUSH
37805: LD_INT 1
37807: NEG
37808: PUSH
37809: LD_INT 3
37811: NEG
37812: PUSH
37813: EMPTY
37814: LIST
37815: LIST
37816: PUSH
37817: LD_INT 3
37819: NEG
37820: PUSH
37821: LD_INT 1
37823: NEG
37824: PUSH
37825: EMPTY
37826: LIST
37827: LIST
37828: PUSH
37829: LD_INT 3
37831: NEG
37832: PUSH
37833: LD_INT 2
37835: NEG
37836: PUSH
37837: EMPTY
37838: LIST
37839: LIST
37840: PUSH
37841: EMPTY
37842: LIST
37843: LIST
37844: LIST
37845: LIST
37846: LIST
37847: LIST
37848: LIST
37849: LIST
37850: LIST
37851: LIST
37852: LIST
37853: LIST
37854: LIST
37855: LIST
37856: LIST
37857: LIST
37858: LIST
37859: LIST
37860: LIST
37861: LIST
37862: LIST
37863: LIST
37864: LIST
37865: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
37866: LD_ADDR_VAR 0 29
37870: PUSH
37871: LD_INT 0
37873: PUSH
37874: LD_INT 0
37876: PUSH
37877: EMPTY
37878: LIST
37879: LIST
37880: PUSH
37881: LD_INT 0
37883: PUSH
37884: LD_INT 1
37886: NEG
37887: PUSH
37888: EMPTY
37889: LIST
37890: LIST
37891: PUSH
37892: LD_INT 1
37894: PUSH
37895: LD_INT 0
37897: PUSH
37898: EMPTY
37899: LIST
37900: LIST
37901: PUSH
37902: LD_INT 1
37904: PUSH
37905: LD_INT 1
37907: PUSH
37908: EMPTY
37909: LIST
37910: LIST
37911: PUSH
37912: LD_INT 0
37914: PUSH
37915: LD_INT 1
37917: PUSH
37918: EMPTY
37919: LIST
37920: LIST
37921: PUSH
37922: LD_INT 1
37924: NEG
37925: PUSH
37926: LD_INT 0
37928: PUSH
37929: EMPTY
37930: LIST
37931: LIST
37932: PUSH
37933: LD_INT 1
37935: NEG
37936: PUSH
37937: LD_INT 1
37939: NEG
37940: PUSH
37941: EMPTY
37942: LIST
37943: LIST
37944: PUSH
37945: LD_INT 1
37947: NEG
37948: PUSH
37949: LD_INT 2
37951: NEG
37952: PUSH
37953: EMPTY
37954: LIST
37955: LIST
37956: PUSH
37957: LD_INT 0
37959: PUSH
37960: LD_INT 2
37962: NEG
37963: PUSH
37964: EMPTY
37965: LIST
37966: LIST
37967: PUSH
37968: LD_INT 1
37970: PUSH
37971: LD_INT 1
37973: NEG
37974: PUSH
37975: EMPTY
37976: LIST
37977: LIST
37978: PUSH
37979: LD_INT 2
37981: PUSH
37982: LD_INT 0
37984: PUSH
37985: EMPTY
37986: LIST
37987: LIST
37988: PUSH
37989: LD_INT 2
37991: PUSH
37992: LD_INT 1
37994: PUSH
37995: EMPTY
37996: LIST
37997: LIST
37998: PUSH
37999: LD_INT 1
38001: PUSH
38002: LD_INT 2
38004: PUSH
38005: EMPTY
38006: LIST
38007: LIST
38008: PUSH
38009: LD_INT 0
38011: PUSH
38012: LD_INT 2
38014: PUSH
38015: EMPTY
38016: LIST
38017: LIST
38018: PUSH
38019: LD_INT 1
38021: NEG
38022: PUSH
38023: LD_INT 1
38025: PUSH
38026: EMPTY
38027: LIST
38028: LIST
38029: PUSH
38030: LD_INT 2
38032: NEG
38033: PUSH
38034: LD_INT 1
38036: NEG
38037: PUSH
38038: EMPTY
38039: LIST
38040: LIST
38041: PUSH
38042: LD_INT 2
38044: NEG
38045: PUSH
38046: LD_INT 2
38048: NEG
38049: PUSH
38050: EMPTY
38051: LIST
38052: LIST
38053: PUSH
38054: LD_INT 2
38056: NEG
38057: PUSH
38058: LD_INT 3
38060: NEG
38061: PUSH
38062: EMPTY
38063: LIST
38064: LIST
38065: PUSH
38066: LD_INT 2
38068: PUSH
38069: LD_INT 1
38071: NEG
38072: PUSH
38073: EMPTY
38074: LIST
38075: LIST
38076: PUSH
38077: LD_INT 3
38079: PUSH
38080: LD_INT 1
38082: PUSH
38083: EMPTY
38084: LIST
38085: LIST
38086: PUSH
38087: LD_INT 1
38089: PUSH
38090: LD_INT 3
38092: PUSH
38093: EMPTY
38094: LIST
38095: LIST
38096: PUSH
38097: LD_INT 1
38099: NEG
38100: PUSH
38101: LD_INT 2
38103: PUSH
38104: EMPTY
38105: LIST
38106: LIST
38107: PUSH
38108: LD_INT 3
38110: NEG
38111: PUSH
38112: LD_INT 2
38114: NEG
38115: PUSH
38116: EMPTY
38117: LIST
38118: LIST
38119: PUSH
38120: EMPTY
38121: LIST
38122: LIST
38123: LIST
38124: LIST
38125: LIST
38126: LIST
38127: LIST
38128: LIST
38129: LIST
38130: LIST
38131: LIST
38132: LIST
38133: LIST
38134: LIST
38135: LIST
38136: LIST
38137: LIST
38138: LIST
38139: LIST
38140: LIST
38141: LIST
38142: LIST
38143: LIST
38144: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
38145: LD_ADDR_VAR 0 30
38149: PUSH
38150: LD_INT 0
38152: PUSH
38153: LD_INT 0
38155: PUSH
38156: EMPTY
38157: LIST
38158: LIST
38159: PUSH
38160: LD_INT 0
38162: PUSH
38163: LD_INT 1
38165: NEG
38166: PUSH
38167: EMPTY
38168: LIST
38169: LIST
38170: PUSH
38171: LD_INT 1
38173: PUSH
38174: LD_INT 0
38176: PUSH
38177: EMPTY
38178: LIST
38179: LIST
38180: PUSH
38181: LD_INT 1
38183: PUSH
38184: LD_INT 1
38186: PUSH
38187: EMPTY
38188: LIST
38189: LIST
38190: PUSH
38191: LD_INT 0
38193: PUSH
38194: LD_INT 1
38196: PUSH
38197: EMPTY
38198: LIST
38199: LIST
38200: PUSH
38201: LD_INT 1
38203: NEG
38204: PUSH
38205: LD_INT 0
38207: PUSH
38208: EMPTY
38209: LIST
38210: LIST
38211: PUSH
38212: LD_INT 1
38214: NEG
38215: PUSH
38216: LD_INT 1
38218: NEG
38219: PUSH
38220: EMPTY
38221: LIST
38222: LIST
38223: PUSH
38224: LD_INT 1
38226: NEG
38227: PUSH
38228: LD_INT 2
38230: NEG
38231: PUSH
38232: EMPTY
38233: LIST
38234: LIST
38235: PUSH
38236: LD_INT 0
38238: PUSH
38239: LD_INT 2
38241: NEG
38242: PUSH
38243: EMPTY
38244: LIST
38245: LIST
38246: PUSH
38247: LD_INT 1
38249: PUSH
38250: LD_INT 1
38252: NEG
38253: PUSH
38254: EMPTY
38255: LIST
38256: LIST
38257: PUSH
38258: LD_INT 2
38260: PUSH
38261: LD_INT 0
38263: PUSH
38264: EMPTY
38265: LIST
38266: LIST
38267: PUSH
38268: LD_INT 2
38270: PUSH
38271: LD_INT 1
38273: PUSH
38274: EMPTY
38275: LIST
38276: LIST
38277: PUSH
38278: LD_INT 2
38280: PUSH
38281: LD_INT 2
38283: PUSH
38284: EMPTY
38285: LIST
38286: LIST
38287: PUSH
38288: LD_INT 1
38290: PUSH
38291: LD_INT 2
38293: PUSH
38294: EMPTY
38295: LIST
38296: LIST
38297: PUSH
38298: LD_INT 1
38300: NEG
38301: PUSH
38302: LD_INT 1
38304: PUSH
38305: EMPTY
38306: LIST
38307: LIST
38308: PUSH
38309: LD_INT 2
38311: NEG
38312: PUSH
38313: LD_INT 0
38315: PUSH
38316: EMPTY
38317: LIST
38318: LIST
38319: PUSH
38320: LD_INT 2
38322: NEG
38323: PUSH
38324: LD_INT 1
38326: NEG
38327: PUSH
38328: EMPTY
38329: LIST
38330: LIST
38331: PUSH
38332: LD_INT 1
38334: NEG
38335: PUSH
38336: LD_INT 3
38338: NEG
38339: PUSH
38340: EMPTY
38341: LIST
38342: LIST
38343: PUSH
38344: LD_INT 1
38346: PUSH
38347: LD_INT 2
38349: NEG
38350: PUSH
38351: EMPTY
38352: LIST
38353: LIST
38354: PUSH
38355: LD_INT 3
38357: PUSH
38358: LD_INT 2
38360: PUSH
38361: EMPTY
38362: LIST
38363: LIST
38364: PUSH
38365: LD_INT 2
38367: PUSH
38368: LD_INT 3
38370: PUSH
38371: EMPTY
38372: LIST
38373: LIST
38374: PUSH
38375: LD_INT 2
38377: NEG
38378: PUSH
38379: LD_INT 1
38381: PUSH
38382: EMPTY
38383: LIST
38384: LIST
38385: PUSH
38386: LD_INT 3
38388: NEG
38389: PUSH
38390: LD_INT 1
38392: NEG
38393: PUSH
38394: EMPTY
38395: LIST
38396: LIST
38397: PUSH
38398: EMPTY
38399: LIST
38400: LIST
38401: LIST
38402: LIST
38403: LIST
38404: LIST
38405: LIST
38406: LIST
38407: LIST
38408: LIST
38409: LIST
38410: LIST
38411: LIST
38412: LIST
38413: LIST
38414: LIST
38415: LIST
38416: LIST
38417: LIST
38418: LIST
38419: LIST
38420: LIST
38421: LIST
38422: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
38423: LD_ADDR_VAR 0 31
38427: PUSH
38428: LD_INT 0
38430: PUSH
38431: LD_INT 0
38433: PUSH
38434: EMPTY
38435: LIST
38436: LIST
38437: PUSH
38438: LD_INT 0
38440: PUSH
38441: LD_INT 1
38443: NEG
38444: PUSH
38445: EMPTY
38446: LIST
38447: LIST
38448: PUSH
38449: LD_INT 1
38451: PUSH
38452: LD_INT 0
38454: PUSH
38455: EMPTY
38456: LIST
38457: LIST
38458: PUSH
38459: LD_INT 1
38461: PUSH
38462: LD_INT 1
38464: PUSH
38465: EMPTY
38466: LIST
38467: LIST
38468: PUSH
38469: LD_INT 0
38471: PUSH
38472: LD_INT 1
38474: PUSH
38475: EMPTY
38476: LIST
38477: LIST
38478: PUSH
38479: LD_INT 1
38481: NEG
38482: PUSH
38483: LD_INT 0
38485: PUSH
38486: EMPTY
38487: LIST
38488: LIST
38489: PUSH
38490: LD_INT 1
38492: NEG
38493: PUSH
38494: LD_INT 1
38496: NEG
38497: PUSH
38498: EMPTY
38499: LIST
38500: LIST
38501: PUSH
38502: LD_INT 1
38504: NEG
38505: PUSH
38506: LD_INT 2
38508: NEG
38509: PUSH
38510: EMPTY
38511: LIST
38512: LIST
38513: PUSH
38514: LD_INT 1
38516: PUSH
38517: LD_INT 1
38519: NEG
38520: PUSH
38521: EMPTY
38522: LIST
38523: LIST
38524: PUSH
38525: LD_INT 2
38527: PUSH
38528: LD_INT 0
38530: PUSH
38531: EMPTY
38532: LIST
38533: LIST
38534: PUSH
38535: LD_INT 2
38537: PUSH
38538: LD_INT 1
38540: PUSH
38541: EMPTY
38542: LIST
38543: LIST
38544: PUSH
38545: LD_INT 2
38547: PUSH
38548: LD_INT 2
38550: PUSH
38551: EMPTY
38552: LIST
38553: LIST
38554: PUSH
38555: LD_INT 1
38557: PUSH
38558: LD_INT 2
38560: PUSH
38561: EMPTY
38562: LIST
38563: LIST
38564: PUSH
38565: LD_INT 0
38567: PUSH
38568: LD_INT 2
38570: PUSH
38571: EMPTY
38572: LIST
38573: LIST
38574: PUSH
38575: LD_INT 1
38577: NEG
38578: PUSH
38579: LD_INT 1
38581: PUSH
38582: EMPTY
38583: LIST
38584: LIST
38585: PUSH
38586: LD_INT 2
38588: NEG
38589: PUSH
38590: LD_INT 1
38592: NEG
38593: PUSH
38594: EMPTY
38595: LIST
38596: LIST
38597: PUSH
38598: LD_INT 2
38600: NEG
38601: PUSH
38602: LD_INT 2
38604: NEG
38605: PUSH
38606: EMPTY
38607: LIST
38608: LIST
38609: PUSH
38610: LD_INT 2
38612: NEG
38613: PUSH
38614: LD_INT 3
38616: NEG
38617: PUSH
38618: EMPTY
38619: LIST
38620: LIST
38621: PUSH
38622: LD_INT 2
38624: PUSH
38625: LD_INT 1
38627: NEG
38628: PUSH
38629: EMPTY
38630: LIST
38631: LIST
38632: PUSH
38633: LD_INT 3
38635: PUSH
38636: LD_INT 1
38638: PUSH
38639: EMPTY
38640: LIST
38641: LIST
38642: PUSH
38643: LD_INT 1
38645: PUSH
38646: LD_INT 3
38648: PUSH
38649: EMPTY
38650: LIST
38651: LIST
38652: PUSH
38653: LD_INT 1
38655: NEG
38656: PUSH
38657: LD_INT 2
38659: PUSH
38660: EMPTY
38661: LIST
38662: LIST
38663: PUSH
38664: LD_INT 3
38666: NEG
38667: PUSH
38668: LD_INT 2
38670: NEG
38671: PUSH
38672: EMPTY
38673: LIST
38674: LIST
38675: PUSH
38676: EMPTY
38677: LIST
38678: LIST
38679: LIST
38680: LIST
38681: LIST
38682: LIST
38683: LIST
38684: LIST
38685: LIST
38686: LIST
38687: LIST
38688: LIST
38689: LIST
38690: LIST
38691: LIST
38692: LIST
38693: LIST
38694: LIST
38695: LIST
38696: LIST
38697: LIST
38698: LIST
38699: LIST
38700: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
38701: LD_ADDR_VAR 0 32
38705: PUSH
38706: LD_INT 0
38708: PUSH
38709: LD_INT 0
38711: PUSH
38712: EMPTY
38713: LIST
38714: LIST
38715: PUSH
38716: LD_INT 0
38718: PUSH
38719: LD_INT 1
38721: NEG
38722: PUSH
38723: EMPTY
38724: LIST
38725: LIST
38726: PUSH
38727: LD_INT 1
38729: PUSH
38730: LD_INT 0
38732: PUSH
38733: EMPTY
38734: LIST
38735: LIST
38736: PUSH
38737: LD_INT 1
38739: PUSH
38740: LD_INT 1
38742: PUSH
38743: EMPTY
38744: LIST
38745: LIST
38746: PUSH
38747: LD_INT 0
38749: PUSH
38750: LD_INT 1
38752: PUSH
38753: EMPTY
38754: LIST
38755: LIST
38756: PUSH
38757: LD_INT 1
38759: NEG
38760: PUSH
38761: LD_INT 0
38763: PUSH
38764: EMPTY
38765: LIST
38766: LIST
38767: PUSH
38768: LD_INT 1
38770: NEG
38771: PUSH
38772: LD_INT 1
38774: NEG
38775: PUSH
38776: EMPTY
38777: LIST
38778: LIST
38779: PUSH
38780: LD_INT 1
38782: NEG
38783: PUSH
38784: LD_INT 2
38786: NEG
38787: PUSH
38788: EMPTY
38789: LIST
38790: LIST
38791: PUSH
38792: LD_INT 0
38794: PUSH
38795: LD_INT 2
38797: NEG
38798: PUSH
38799: EMPTY
38800: LIST
38801: LIST
38802: PUSH
38803: LD_INT 1
38805: PUSH
38806: LD_INT 1
38808: NEG
38809: PUSH
38810: EMPTY
38811: LIST
38812: LIST
38813: PUSH
38814: LD_INT 2
38816: PUSH
38817: LD_INT 1
38819: PUSH
38820: EMPTY
38821: LIST
38822: LIST
38823: PUSH
38824: LD_INT 2
38826: PUSH
38827: LD_INT 2
38829: PUSH
38830: EMPTY
38831: LIST
38832: LIST
38833: PUSH
38834: LD_INT 1
38836: PUSH
38837: LD_INT 2
38839: PUSH
38840: EMPTY
38841: LIST
38842: LIST
38843: PUSH
38844: LD_INT 0
38846: PUSH
38847: LD_INT 2
38849: PUSH
38850: EMPTY
38851: LIST
38852: LIST
38853: PUSH
38854: LD_INT 1
38856: NEG
38857: PUSH
38858: LD_INT 1
38860: PUSH
38861: EMPTY
38862: LIST
38863: LIST
38864: PUSH
38865: LD_INT 2
38867: NEG
38868: PUSH
38869: LD_INT 0
38871: PUSH
38872: EMPTY
38873: LIST
38874: LIST
38875: PUSH
38876: LD_INT 2
38878: NEG
38879: PUSH
38880: LD_INT 1
38882: NEG
38883: PUSH
38884: EMPTY
38885: LIST
38886: LIST
38887: PUSH
38888: LD_INT 1
38890: NEG
38891: PUSH
38892: LD_INT 3
38894: NEG
38895: PUSH
38896: EMPTY
38897: LIST
38898: LIST
38899: PUSH
38900: LD_INT 1
38902: PUSH
38903: LD_INT 2
38905: NEG
38906: PUSH
38907: EMPTY
38908: LIST
38909: LIST
38910: PUSH
38911: LD_INT 3
38913: PUSH
38914: LD_INT 2
38916: PUSH
38917: EMPTY
38918: LIST
38919: LIST
38920: PUSH
38921: LD_INT 2
38923: PUSH
38924: LD_INT 3
38926: PUSH
38927: EMPTY
38928: LIST
38929: LIST
38930: PUSH
38931: LD_INT 2
38933: NEG
38934: PUSH
38935: LD_INT 1
38937: PUSH
38938: EMPTY
38939: LIST
38940: LIST
38941: PUSH
38942: LD_INT 3
38944: NEG
38945: PUSH
38946: LD_INT 1
38948: NEG
38949: PUSH
38950: EMPTY
38951: LIST
38952: LIST
38953: PUSH
38954: EMPTY
38955: LIST
38956: LIST
38957: LIST
38958: LIST
38959: LIST
38960: LIST
38961: LIST
38962: LIST
38963: LIST
38964: LIST
38965: LIST
38966: LIST
38967: LIST
38968: LIST
38969: LIST
38970: LIST
38971: LIST
38972: LIST
38973: LIST
38974: LIST
38975: LIST
38976: LIST
38977: LIST
38978: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
38979: LD_ADDR_VAR 0 33
38983: PUSH
38984: LD_INT 0
38986: PUSH
38987: LD_INT 0
38989: PUSH
38990: EMPTY
38991: LIST
38992: LIST
38993: PUSH
38994: LD_INT 0
38996: PUSH
38997: LD_INT 1
38999: NEG
39000: PUSH
39001: EMPTY
39002: LIST
39003: LIST
39004: PUSH
39005: LD_INT 1
39007: PUSH
39008: LD_INT 0
39010: PUSH
39011: EMPTY
39012: LIST
39013: LIST
39014: PUSH
39015: LD_INT 1
39017: PUSH
39018: LD_INT 1
39020: PUSH
39021: EMPTY
39022: LIST
39023: LIST
39024: PUSH
39025: LD_INT 0
39027: PUSH
39028: LD_INT 1
39030: PUSH
39031: EMPTY
39032: LIST
39033: LIST
39034: PUSH
39035: LD_INT 1
39037: NEG
39038: PUSH
39039: LD_INT 0
39041: PUSH
39042: EMPTY
39043: LIST
39044: LIST
39045: PUSH
39046: LD_INT 1
39048: NEG
39049: PUSH
39050: LD_INT 1
39052: NEG
39053: PUSH
39054: EMPTY
39055: LIST
39056: LIST
39057: PUSH
39058: LD_INT 1
39060: NEG
39061: PUSH
39062: LD_INT 2
39064: NEG
39065: PUSH
39066: EMPTY
39067: LIST
39068: LIST
39069: PUSH
39070: LD_INT 1
39072: PUSH
39073: LD_INT 1
39075: NEG
39076: PUSH
39077: EMPTY
39078: LIST
39079: LIST
39080: PUSH
39081: LD_INT 2
39083: PUSH
39084: LD_INT 0
39086: PUSH
39087: EMPTY
39088: LIST
39089: LIST
39090: PUSH
39091: LD_INT 2
39093: PUSH
39094: LD_INT 1
39096: PUSH
39097: EMPTY
39098: LIST
39099: LIST
39100: PUSH
39101: LD_INT 1
39103: PUSH
39104: LD_INT 2
39106: PUSH
39107: EMPTY
39108: LIST
39109: LIST
39110: PUSH
39111: LD_INT 0
39113: PUSH
39114: LD_INT 2
39116: PUSH
39117: EMPTY
39118: LIST
39119: LIST
39120: PUSH
39121: LD_INT 1
39123: NEG
39124: PUSH
39125: LD_INT 1
39127: PUSH
39128: EMPTY
39129: LIST
39130: LIST
39131: PUSH
39132: LD_INT 2
39134: NEG
39135: PUSH
39136: LD_INT 0
39138: PUSH
39139: EMPTY
39140: LIST
39141: LIST
39142: PUSH
39143: LD_INT 2
39145: NEG
39146: PUSH
39147: LD_INT 1
39149: NEG
39150: PUSH
39151: EMPTY
39152: LIST
39153: LIST
39154: PUSH
39155: LD_INT 2
39157: NEG
39158: PUSH
39159: LD_INT 2
39161: NEG
39162: PUSH
39163: EMPTY
39164: LIST
39165: LIST
39166: PUSH
39167: LD_INT 2
39169: NEG
39170: PUSH
39171: LD_INT 3
39173: NEG
39174: PUSH
39175: EMPTY
39176: LIST
39177: LIST
39178: PUSH
39179: LD_INT 2
39181: PUSH
39182: LD_INT 1
39184: NEG
39185: PUSH
39186: EMPTY
39187: LIST
39188: LIST
39189: PUSH
39190: LD_INT 3
39192: PUSH
39193: LD_INT 1
39195: PUSH
39196: EMPTY
39197: LIST
39198: LIST
39199: PUSH
39200: LD_INT 1
39202: PUSH
39203: LD_INT 3
39205: PUSH
39206: EMPTY
39207: LIST
39208: LIST
39209: PUSH
39210: LD_INT 1
39212: NEG
39213: PUSH
39214: LD_INT 2
39216: PUSH
39217: EMPTY
39218: LIST
39219: LIST
39220: PUSH
39221: LD_INT 3
39223: NEG
39224: PUSH
39225: LD_INT 2
39227: NEG
39228: PUSH
39229: EMPTY
39230: LIST
39231: LIST
39232: PUSH
39233: EMPTY
39234: LIST
39235: LIST
39236: LIST
39237: LIST
39238: LIST
39239: LIST
39240: LIST
39241: LIST
39242: LIST
39243: LIST
39244: LIST
39245: LIST
39246: LIST
39247: LIST
39248: LIST
39249: LIST
39250: LIST
39251: LIST
39252: LIST
39253: LIST
39254: LIST
39255: LIST
39256: LIST
39257: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
39258: LD_ADDR_VAR 0 34
39262: PUSH
39263: LD_INT 0
39265: PUSH
39266: LD_INT 0
39268: PUSH
39269: EMPTY
39270: LIST
39271: LIST
39272: PUSH
39273: LD_INT 0
39275: PUSH
39276: LD_INT 1
39278: NEG
39279: PUSH
39280: EMPTY
39281: LIST
39282: LIST
39283: PUSH
39284: LD_INT 1
39286: PUSH
39287: LD_INT 0
39289: PUSH
39290: EMPTY
39291: LIST
39292: LIST
39293: PUSH
39294: LD_INT 1
39296: PUSH
39297: LD_INT 1
39299: PUSH
39300: EMPTY
39301: LIST
39302: LIST
39303: PUSH
39304: LD_INT 0
39306: PUSH
39307: LD_INT 1
39309: PUSH
39310: EMPTY
39311: LIST
39312: LIST
39313: PUSH
39314: LD_INT 1
39316: NEG
39317: PUSH
39318: LD_INT 0
39320: PUSH
39321: EMPTY
39322: LIST
39323: LIST
39324: PUSH
39325: LD_INT 1
39327: NEG
39328: PUSH
39329: LD_INT 1
39331: NEG
39332: PUSH
39333: EMPTY
39334: LIST
39335: LIST
39336: PUSH
39337: LD_INT 1
39339: NEG
39340: PUSH
39341: LD_INT 2
39343: NEG
39344: PUSH
39345: EMPTY
39346: LIST
39347: LIST
39348: PUSH
39349: LD_INT 0
39351: PUSH
39352: LD_INT 2
39354: NEG
39355: PUSH
39356: EMPTY
39357: LIST
39358: LIST
39359: PUSH
39360: LD_INT 1
39362: PUSH
39363: LD_INT 1
39365: NEG
39366: PUSH
39367: EMPTY
39368: LIST
39369: LIST
39370: PUSH
39371: LD_INT 2
39373: PUSH
39374: LD_INT 1
39376: PUSH
39377: EMPTY
39378: LIST
39379: LIST
39380: PUSH
39381: LD_INT 2
39383: PUSH
39384: LD_INT 2
39386: PUSH
39387: EMPTY
39388: LIST
39389: LIST
39390: PUSH
39391: LD_INT 1
39393: PUSH
39394: LD_INT 2
39396: PUSH
39397: EMPTY
39398: LIST
39399: LIST
39400: PUSH
39401: LD_INT 1
39403: NEG
39404: PUSH
39405: LD_INT 1
39407: PUSH
39408: EMPTY
39409: LIST
39410: LIST
39411: PUSH
39412: LD_INT 2
39414: NEG
39415: PUSH
39416: LD_INT 0
39418: PUSH
39419: EMPTY
39420: LIST
39421: LIST
39422: PUSH
39423: LD_INT 2
39425: NEG
39426: PUSH
39427: LD_INT 1
39429: NEG
39430: PUSH
39431: EMPTY
39432: LIST
39433: LIST
39434: PUSH
39435: LD_INT 2
39437: NEG
39438: PUSH
39439: LD_INT 2
39441: NEG
39442: PUSH
39443: EMPTY
39444: LIST
39445: LIST
39446: PUSH
39447: LD_INT 1
39449: NEG
39450: PUSH
39451: LD_INT 3
39453: NEG
39454: PUSH
39455: EMPTY
39456: LIST
39457: LIST
39458: PUSH
39459: LD_INT 1
39461: PUSH
39462: LD_INT 2
39464: NEG
39465: PUSH
39466: EMPTY
39467: LIST
39468: LIST
39469: PUSH
39470: LD_INT 3
39472: PUSH
39473: LD_INT 2
39475: PUSH
39476: EMPTY
39477: LIST
39478: LIST
39479: PUSH
39480: LD_INT 2
39482: PUSH
39483: LD_INT 3
39485: PUSH
39486: EMPTY
39487: LIST
39488: LIST
39489: PUSH
39490: LD_INT 2
39492: NEG
39493: PUSH
39494: LD_INT 1
39496: PUSH
39497: EMPTY
39498: LIST
39499: LIST
39500: PUSH
39501: LD_INT 3
39503: NEG
39504: PUSH
39505: LD_INT 1
39507: NEG
39508: PUSH
39509: EMPTY
39510: LIST
39511: LIST
39512: PUSH
39513: EMPTY
39514: LIST
39515: LIST
39516: LIST
39517: LIST
39518: LIST
39519: LIST
39520: LIST
39521: LIST
39522: LIST
39523: LIST
39524: LIST
39525: LIST
39526: LIST
39527: LIST
39528: LIST
39529: LIST
39530: LIST
39531: LIST
39532: LIST
39533: LIST
39534: LIST
39535: LIST
39536: LIST
39537: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
39538: LD_ADDR_VAR 0 35
39542: PUSH
39543: LD_INT 0
39545: PUSH
39546: LD_INT 0
39548: PUSH
39549: EMPTY
39550: LIST
39551: LIST
39552: PUSH
39553: LD_INT 0
39555: PUSH
39556: LD_INT 1
39558: NEG
39559: PUSH
39560: EMPTY
39561: LIST
39562: LIST
39563: PUSH
39564: LD_INT 1
39566: PUSH
39567: LD_INT 0
39569: PUSH
39570: EMPTY
39571: LIST
39572: LIST
39573: PUSH
39574: LD_INT 1
39576: PUSH
39577: LD_INT 1
39579: PUSH
39580: EMPTY
39581: LIST
39582: LIST
39583: PUSH
39584: LD_INT 0
39586: PUSH
39587: LD_INT 1
39589: PUSH
39590: EMPTY
39591: LIST
39592: LIST
39593: PUSH
39594: LD_INT 1
39596: NEG
39597: PUSH
39598: LD_INT 0
39600: PUSH
39601: EMPTY
39602: LIST
39603: LIST
39604: PUSH
39605: LD_INT 1
39607: NEG
39608: PUSH
39609: LD_INT 1
39611: NEG
39612: PUSH
39613: EMPTY
39614: LIST
39615: LIST
39616: PUSH
39617: LD_INT 2
39619: PUSH
39620: LD_INT 1
39622: PUSH
39623: EMPTY
39624: LIST
39625: LIST
39626: PUSH
39627: LD_INT 2
39629: NEG
39630: PUSH
39631: LD_INT 1
39633: NEG
39634: PUSH
39635: EMPTY
39636: LIST
39637: LIST
39638: PUSH
39639: EMPTY
39640: LIST
39641: LIST
39642: LIST
39643: LIST
39644: LIST
39645: LIST
39646: LIST
39647: LIST
39648: LIST
39649: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
39650: LD_ADDR_VAR 0 36
39654: PUSH
39655: LD_INT 0
39657: PUSH
39658: LD_INT 0
39660: PUSH
39661: EMPTY
39662: LIST
39663: LIST
39664: PUSH
39665: LD_INT 0
39667: PUSH
39668: LD_INT 1
39670: NEG
39671: PUSH
39672: EMPTY
39673: LIST
39674: LIST
39675: PUSH
39676: LD_INT 1
39678: PUSH
39679: LD_INT 0
39681: PUSH
39682: EMPTY
39683: LIST
39684: LIST
39685: PUSH
39686: LD_INT 1
39688: PUSH
39689: LD_INT 1
39691: PUSH
39692: EMPTY
39693: LIST
39694: LIST
39695: PUSH
39696: LD_INT 0
39698: PUSH
39699: LD_INT 1
39701: PUSH
39702: EMPTY
39703: LIST
39704: LIST
39705: PUSH
39706: LD_INT 1
39708: NEG
39709: PUSH
39710: LD_INT 0
39712: PUSH
39713: EMPTY
39714: LIST
39715: LIST
39716: PUSH
39717: LD_INT 1
39719: NEG
39720: PUSH
39721: LD_INT 1
39723: NEG
39724: PUSH
39725: EMPTY
39726: LIST
39727: LIST
39728: PUSH
39729: LD_INT 1
39731: NEG
39732: PUSH
39733: LD_INT 2
39735: NEG
39736: PUSH
39737: EMPTY
39738: LIST
39739: LIST
39740: PUSH
39741: LD_INT 1
39743: PUSH
39744: LD_INT 2
39746: PUSH
39747: EMPTY
39748: LIST
39749: LIST
39750: PUSH
39751: EMPTY
39752: LIST
39753: LIST
39754: LIST
39755: LIST
39756: LIST
39757: LIST
39758: LIST
39759: LIST
39760: LIST
39761: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
39762: LD_ADDR_VAR 0 37
39766: PUSH
39767: LD_INT 0
39769: PUSH
39770: LD_INT 0
39772: PUSH
39773: EMPTY
39774: LIST
39775: LIST
39776: PUSH
39777: LD_INT 0
39779: PUSH
39780: LD_INT 1
39782: NEG
39783: PUSH
39784: EMPTY
39785: LIST
39786: LIST
39787: PUSH
39788: LD_INT 1
39790: PUSH
39791: LD_INT 0
39793: PUSH
39794: EMPTY
39795: LIST
39796: LIST
39797: PUSH
39798: LD_INT 1
39800: PUSH
39801: LD_INT 1
39803: PUSH
39804: EMPTY
39805: LIST
39806: LIST
39807: PUSH
39808: LD_INT 0
39810: PUSH
39811: LD_INT 1
39813: PUSH
39814: EMPTY
39815: LIST
39816: LIST
39817: PUSH
39818: LD_INT 1
39820: NEG
39821: PUSH
39822: LD_INT 0
39824: PUSH
39825: EMPTY
39826: LIST
39827: LIST
39828: PUSH
39829: LD_INT 1
39831: NEG
39832: PUSH
39833: LD_INT 1
39835: NEG
39836: PUSH
39837: EMPTY
39838: LIST
39839: LIST
39840: PUSH
39841: LD_INT 1
39843: PUSH
39844: LD_INT 1
39846: NEG
39847: PUSH
39848: EMPTY
39849: LIST
39850: LIST
39851: PUSH
39852: LD_INT 1
39854: NEG
39855: PUSH
39856: LD_INT 1
39858: PUSH
39859: EMPTY
39860: LIST
39861: LIST
39862: PUSH
39863: EMPTY
39864: LIST
39865: LIST
39866: LIST
39867: LIST
39868: LIST
39869: LIST
39870: LIST
39871: LIST
39872: LIST
39873: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
39874: LD_ADDR_VAR 0 38
39878: PUSH
39879: LD_INT 0
39881: PUSH
39882: LD_INT 0
39884: PUSH
39885: EMPTY
39886: LIST
39887: LIST
39888: PUSH
39889: LD_INT 0
39891: PUSH
39892: LD_INT 1
39894: NEG
39895: PUSH
39896: EMPTY
39897: LIST
39898: LIST
39899: PUSH
39900: LD_INT 1
39902: PUSH
39903: LD_INT 0
39905: PUSH
39906: EMPTY
39907: LIST
39908: LIST
39909: PUSH
39910: LD_INT 1
39912: PUSH
39913: LD_INT 1
39915: PUSH
39916: EMPTY
39917: LIST
39918: LIST
39919: PUSH
39920: LD_INT 0
39922: PUSH
39923: LD_INT 1
39925: PUSH
39926: EMPTY
39927: LIST
39928: LIST
39929: PUSH
39930: LD_INT 1
39932: NEG
39933: PUSH
39934: LD_INT 0
39936: PUSH
39937: EMPTY
39938: LIST
39939: LIST
39940: PUSH
39941: LD_INT 1
39943: NEG
39944: PUSH
39945: LD_INT 1
39947: NEG
39948: PUSH
39949: EMPTY
39950: LIST
39951: LIST
39952: PUSH
39953: LD_INT 2
39955: PUSH
39956: LD_INT 1
39958: PUSH
39959: EMPTY
39960: LIST
39961: LIST
39962: PUSH
39963: LD_INT 2
39965: NEG
39966: PUSH
39967: LD_INT 1
39969: NEG
39970: PUSH
39971: EMPTY
39972: LIST
39973: LIST
39974: PUSH
39975: EMPTY
39976: LIST
39977: LIST
39978: LIST
39979: LIST
39980: LIST
39981: LIST
39982: LIST
39983: LIST
39984: LIST
39985: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
39986: LD_ADDR_VAR 0 39
39990: PUSH
39991: LD_INT 0
39993: PUSH
39994: LD_INT 0
39996: PUSH
39997: EMPTY
39998: LIST
39999: LIST
40000: PUSH
40001: LD_INT 0
40003: PUSH
40004: LD_INT 1
40006: NEG
40007: PUSH
40008: EMPTY
40009: LIST
40010: LIST
40011: PUSH
40012: LD_INT 1
40014: PUSH
40015: LD_INT 0
40017: PUSH
40018: EMPTY
40019: LIST
40020: LIST
40021: PUSH
40022: LD_INT 1
40024: PUSH
40025: LD_INT 1
40027: PUSH
40028: EMPTY
40029: LIST
40030: LIST
40031: PUSH
40032: LD_INT 0
40034: PUSH
40035: LD_INT 1
40037: PUSH
40038: EMPTY
40039: LIST
40040: LIST
40041: PUSH
40042: LD_INT 1
40044: NEG
40045: PUSH
40046: LD_INT 0
40048: PUSH
40049: EMPTY
40050: LIST
40051: LIST
40052: PUSH
40053: LD_INT 1
40055: NEG
40056: PUSH
40057: LD_INT 1
40059: NEG
40060: PUSH
40061: EMPTY
40062: LIST
40063: LIST
40064: PUSH
40065: LD_INT 1
40067: NEG
40068: PUSH
40069: LD_INT 2
40071: NEG
40072: PUSH
40073: EMPTY
40074: LIST
40075: LIST
40076: PUSH
40077: LD_INT 1
40079: PUSH
40080: LD_INT 2
40082: PUSH
40083: EMPTY
40084: LIST
40085: LIST
40086: PUSH
40087: EMPTY
40088: LIST
40089: LIST
40090: LIST
40091: LIST
40092: LIST
40093: LIST
40094: LIST
40095: LIST
40096: LIST
40097: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
40098: LD_ADDR_VAR 0 40
40102: PUSH
40103: LD_INT 0
40105: PUSH
40106: LD_INT 0
40108: PUSH
40109: EMPTY
40110: LIST
40111: LIST
40112: PUSH
40113: LD_INT 0
40115: PUSH
40116: LD_INT 1
40118: NEG
40119: PUSH
40120: EMPTY
40121: LIST
40122: LIST
40123: PUSH
40124: LD_INT 1
40126: PUSH
40127: LD_INT 0
40129: PUSH
40130: EMPTY
40131: LIST
40132: LIST
40133: PUSH
40134: LD_INT 1
40136: PUSH
40137: LD_INT 1
40139: PUSH
40140: EMPTY
40141: LIST
40142: LIST
40143: PUSH
40144: LD_INT 0
40146: PUSH
40147: LD_INT 1
40149: PUSH
40150: EMPTY
40151: LIST
40152: LIST
40153: PUSH
40154: LD_INT 1
40156: NEG
40157: PUSH
40158: LD_INT 0
40160: PUSH
40161: EMPTY
40162: LIST
40163: LIST
40164: PUSH
40165: LD_INT 1
40167: NEG
40168: PUSH
40169: LD_INT 1
40171: NEG
40172: PUSH
40173: EMPTY
40174: LIST
40175: LIST
40176: PUSH
40177: LD_INT 1
40179: PUSH
40180: LD_INT 1
40182: NEG
40183: PUSH
40184: EMPTY
40185: LIST
40186: LIST
40187: PUSH
40188: LD_INT 1
40190: NEG
40191: PUSH
40192: LD_INT 1
40194: PUSH
40195: EMPTY
40196: LIST
40197: LIST
40198: PUSH
40199: EMPTY
40200: LIST
40201: LIST
40202: LIST
40203: LIST
40204: LIST
40205: LIST
40206: LIST
40207: LIST
40208: LIST
40209: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
40210: LD_ADDR_VAR 0 41
40214: PUSH
40215: LD_INT 0
40217: PUSH
40218: LD_INT 0
40220: PUSH
40221: EMPTY
40222: LIST
40223: LIST
40224: PUSH
40225: LD_INT 0
40227: PUSH
40228: LD_INT 1
40230: NEG
40231: PUSH
40232: EMPTY
40233: LIST
40234: LIST
40235: PUSH
40236: LD_INT 1
40238: PUSH
40239: LD_INT 0
40241: PUSH
40242: EMPTY
40243: LIST
40244: LIST
40245: PUSH
40246: LD_INT 1
40248: PUSH
40249: LD_INT 1
40251: PUSH
40252: EMPTY
40253: LIST
40254: LIST
40255: PUSH
40256: LD_INT 0
40258: PUSH
40259: LD_INT 1
40261: PUSH
40262: EMPTY
40263: LIST
40264: LIST
40265: PUSH
40266: LD_INT 1
40268: NEG
40269: PUSH
40270: LD_INT 0
40272: PUSH
40273: EMPTY
40274: LIST
40275: LIST
40276: PUSH
40277: LD_INT 1
40279: NEG
40280: PUSH
40281: LD_INT 1
40283: NEG
40284: PUSH
40285: EMPTY
40286: LIST
40287: LIST
40288: PUSH
40289: LD_INT 1
40291: NEG
40292: PUSH
40293: LD_INT 2
40295: NEG
40296: PUSH
40297: EMPTY
40298: LIST
40299: LIST
40300: PUSH
40301: LD_INT 1
40303: PUSH
40304: LD_INT 1
40306: NEG
40307: PUSH
40308: EMPTY
40309: LIST
40310: LIST
40311: PUSH
40312: LD_INT 2
40314: PUSH
40315: LD_INT 0
40317: PUSH
40318: EMPTY
40319: LIST
40320: LIST
40321: PUSH
40322: LD_INT 2
40324: PUSH
40325: LD_INT 1
40327: PUSH
40328: EMPTY
40329: LIST
40330: LIST
40331: PUSH
40332: LD_INT 2
40334: PUSH
40335: LD_INT 2
40337: PUSH
40338: EMPTY
40339: LIST
40340: LIST
40341: PUSH
40342: LD_INT 1
40344: PUSH
40345: LD_INT 2
40347: PUSH
40348: EMPTY
40349: LIST
40350: LIST
40351: PUSH
40352: LD_INT 1
40354: NEG
40355: PUSH
40356: LD_INT 1
40358: PUSH
40359: EMPTY
40360: LIST
40361: LIST
40362: PUSH
40363: LD_INT 2
40365: NEG
40366: PUSH
40367: LD_INT 0
40369: PUSH
40370: EMPTY
40371: LIST
40372: LIST
40373: PUSH
40374: LD_INT 2
40376: NEG
40377: PUSH
40378: LD_INT 1
40380: NEG
40381: PUSH
40382: EMPTY
40383: LIST
40384: LIST
40385: PUSH
40386: LD_INT 2
40388: NEG
40389: PUSH
40390: LD_INT 2
40392: NEG
40393: PUSH
40394: EMPTY
40395: LIST
40396: LIST
40397: PUSH
40398: LD_INT 2
40400: NEG
40401: PUSH
40402: LD_INT 3
40404: NEG
40405: PUSH
40406: EMPTY
40407: LIST
40408: LIST
40409: PUSH
40410: LD_INT 2
40412: PUSH
40413: LD_INT 1
40415: NEG
40416: PUSH
40417: EMPTY
40418: LIST
40419: LIST
40420: PUSH
40421: LD_INT 3
40423: PUSH
40424: LD_INT 0
40426: PUSH
40427: EMPTY
40428: LIST
40429: LIST
40430: PUSH
40431: LD_INT 3
40433: PUSH
40434: LD_INT 1
40436: PUSH
40437: EMPTY
40438: LIST
40439: LIST
40440: PUSH
40441: LD_INT 3
40443: PUSH
40444: LD_INT 2
40446: PUSH
40447: EMPTY
40448: LIST
40449: LIST
40450: PUSH
40451: LD_INT 3
40453: PUSH
40454: LD_INT 3
40456: PUSH
40457: EMPTY
40458: LIST
40459: LIST
40460: PUSH
40461: LD_INT 2
40463: PUSH
40464: LD_INT 3
40466: PUSH
40467: EMPTY
40468: LIST
40469: LIST
40470: PUSH
40471: LD_INT 2
40473: NEG
40474: PUSH
40475: LD_INT 1
40477: PUSH
40478: EMPTY
40479: LIST
40480: LIST
40481: PUSH
40482: LD_INT 3
40484: NEG
40485: PUSH
40486: LD_INT 0
40488: PUSH
40489: EMPTY
40490: LIST
40491: LIST
40492: PUSH
40493: LD_INT 3
40495: NEG
40496: PUSH
40497: LD_INT 1
40499: NEG
40500: PUSH
40501: EMPTY
40502: LIST
40503: LIST
40504: PUSH
40505: LD_INT 3
40507: NEG
40508: PUSH
40509: LD_INT 2
40511: NEG
40512: PUSH
40513: EMPTY
40514: LIST
40515: LIST
40516: PUSH
40517: LD_INT 3
40519: NEG
40520: PUSH
40521: LD_INT 3
40523: NEG
40524: PUSH
40525: EMPTY
40526: LIST
40527: LIST
40528: PUSH
40529: EMPTY
40530: LIST
40531: LIST
40532: LIST
40533: LIST
40534: LIST
40535: LIST
40536: LIST
40537: LIST
40538: LIST
40539: LIST
40540: LIST
40541: LIST
40542: LIST
40543: LIST
40544: LIST
40545: LIST
40546: LIST
40547: LIST
40548: LIST
40549: LIST
40550: LIST
40551: LIST
40552: LIST
40553: LIST
40554: LIST
40555: LIST
40556: LIST
40557: LIST
40558: LIST
40559: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
40560: LD_ADDR_VAR 0 42
40564: PUSH
40565: LD_INT 0
40567: PUSH
40568: LD_INT 0
40570: PUSH
40571: EMPTY
40572: LIST
40573: LIST
40574: PUSH
40575: LD_INT 0
40577: PUSH
40578: LD_INT 1
40580: NEG
40581: PUSH
40582: EMPTY
40583: LIST
40584: LIST
40585: PUSH
40586: LD_INT 1
40588: PUSH
40589: LD_INT 0
40591: PUSH
40592: EMPTY
40593: LIST
40594: LIST
40595: PUSH
40596: LD_INT 1
40598: PUSH
40599: LD_INT 1
40601: PUSH
40602: EMPTY
40603: LIST
40604: LIST
40605: PUSH
40606: LD_INT 0
40608: PUSH
40609: LD_INT 1
40611: PUSH
40612: EMPTY
40613: LIST
40614: LIST
40615: PUSH
40616: LD_INT 1
40618: NEG
40619: PUSH
40620: LD_INT 0
40622: PUSH
40623: EMPTY
40624: LIST
40625: LIST
40626: PUSH
40627: LD_INT 1
40629: NEG
40630: PUSH
40631: LD_INT 1
40633: NEG
40634: PUSH
40635: EMPTY
40636: LIST
40637: LIST
40638: PUSH
40639: LD_INT 1
40641: NEG
40642: PUSH
40643: LD_INT 2
40645: NEG
40646: PUSH
40647: EMPTY
40648: LIST
40649: LIST
40650: PUSH
40651: LD_INT 0
40653: PUSH
40654: LD_INT 2
40656: NEG
40657: PUSH
40658: EMPTY
40659: LIST
40660: LIST
40661: PUSH
40662: LD_INT 1
40664: PUSH
40665: LD_INT 1
40667: NEG
40668: PUSH
40669: EMPTY
40670: LIST
40671: LIST
40672: PUSH
40673: LD_INT 2
40675: PUSH
40676: LD_INT 1
40678: PUSH
40679: EMPTY
40680: LIST
40681: LIST
40682: PUSH
40683: LD_INT 2
40685: PUSH
40686: LD_INT 2
40688: PUSH
40689: EMPTY
40690: LIST
40691: LIST
40692: PUSH
40693: LD_INT 1
40695: PUSH
40696: LD_INT 2
40698: PUSH
40699: EMPTY
40700: LIST
40701: LIST
40702: PUSH
40703: LD_INT 0
40705: PUSH
40706: LD_INT 2
40708: PUSH
40709: EMPTY
40710: LIST
40711: LIST
40712: PUSH
40713: LD_INT 1
40715: NEG
40716: PUSH
40717: LD_INT 1
40719: PUSH
40720: EMPTY
40721: LIST
40722: LIST
40723: PUSH
40724: LD_INT 2
40726: NEG
40727: PUSH
40728: LD_INT 1
40730: NEG
40731: PUSH
40732: EMPTY
40733: LIST
40734: LIST
40735: PUSH
40736: LD_INT 2
40738: NEG
40739: PUSH
40740: LD_INT 2
40742: NEG
40743: PUSH
40744: EMPTY
40745: LIST
40746: LIST
40747: PUSH
40748: LD_INT 2
40750: NEG
40751: PUSH
40752: LD_INT 3
40754: NEG
40755: PUSH
40756: EMPTY
40757: LIST
40758: LIST
40759: PUSH
40760: LD_INT 1
40762: NEG
40763: PUSH
40764: LD_INT 3
40766: NEG
40767: PUSH
40768: EMPTY
40769: LIST
40770: LIST
40771: PUSH
40772: LD_INT 0
40774: PUSH
40775: LD_INT 3
40777: NEG
40778: PUSH
40779: EMPTY
40780: LIST
40781: LIST
40782: PUSH
40783: LD_INT 1
40785: PUSH
40786: LD_INT 2
40788: NEG
40789: PUSH
40790: EMPTY
40791: LIST
40792: LIST
40793: PUSH
40794: LD_INT 3
40796: PUSH
40797: LD_INT 2
40799: PUSH
40800: EMPTY
40801: LIST
40802: LIST
40803: PUSH
40804: LD_INT 3
40806: PUSH
40807: LD_INT 3
40809: PUSH
40810: EMPTY
40811: LIST
40812: LIST
40813: PUSH
40814: LD_INT 2
40816: PUSH
40817: LD_INT 3
40819: PUSH
40820: EMPTY
40821: LIST
40822: LIST
40823: PUSH
40824: LD_INT 1
40826: PUSH
40827: LD_INT 3
40829: PUSH
40830: EMPTY
40831: LIST
40832: LIST
40833: PUSH
40834: LD_INT 0
40836: PUSH
40837: LD_INT 3
40839: PUSH
40840: EMPTY
40841: LIST
40842: LIST
40843: PUSH
40844: LD_INT 1
40846: NEG
40847: PUSH
40848: LD_INT 2
40850: PUSH
40851: EMPTY
40852: LIST
40853: LIST
40854: PUSH
40855: LD_INT 3
40857: NEG
40858: PUSH
40859: LD_INT 2
40861: NEG
40862: PUSH
40863: EMPTY
40864: LIST
40865: LIST
40866: PUSH
40867: LD_INT 3
40869: NEG
40870: PUSH
40871: LD_INT 3
40873: NEG
40874: PUSH
40875: EMPTY
40876: LIST
40877: LIST
40878: PUSH
40879: EMPTY
40880: LIST
40881: LIST
40882: LIST
40883: LIST
40884: LIST
40885: LIST
40886: LIST
40887: LIST
40888: LIST
40889: LIST
40890: LIST
40891: LIST
40892: LIST
40893: LIST
40894: LIST
40895: LIST
40896: LIST
40897: LIST
40898: LIST
40899: LIST
40900: LIST
40901: LIST
40902: LIST
40903: LIST
40904: LIST
40905: LIST
40906: LIST
40907: LIST
40908: LIST
40909: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
40910: LD_ADDR_VAR 0 43
40914: PUSH
40915: LD_INT 0
40917: PUSH
40918: LD_INT 0
40920: PUSH
40921: EMPTY
40922: LIST
40923: LIST
40924: PUSH
40925: LD_INT 0
40927: PUSH
40928: LD_INT 1
40930: NEG
40931: PUSH
40932: EMPTY
40933: LIST
40934: LIST
40935: PUSH
40936: LD_INT 1
40938: PUSH
40939: LD_INT 0
40941: PUSH
40942: EMPTY
40943: LIST
40944: LIST
40945: PUSH
40946: LD_INT 1
40948: PUSH
40949: LD_INT 1
40951: PUSH
40952: EMPTY
40953: LIST
40954: LIST
40955: PUSH
40956: LD_INT 0
40958: PUSH
40959: LD_INT 1
40961: PUSH
40962: EMPTY
40963: LIST
40964: LIST
40965: PUSH
40966: LD_INT 1
40968: NEG
40969: PUSH
40970: LD_INT 0
40972: PUSH
40973: EMPTY
40974: LIST
40975: LIST
40976: PUSH
40977: LD_INT 1
40979: NEG
40980: PUSH
40981: LD_INT 1
40983: NEG
40984: PUSH
40985: EMPTY
40986: LIST
40987: LIST
40988: PUSH
40989: LD_INT 1
40991: NEG
40992: PUSH
40993: LD_INT 2
40995: NEG
40996: PUSH
40997: EMPTY
40998: LIST
40999: LIST
41000: PUSH
41001: LD_INT 0
41003: PUSH
41004: LD_INT 2
41006: NEG
41007: PUSH
41008: EMPTY
41009: LIST
41010: LIST
41011: PUSH
41012: LD_INT 1
41014: PUSH
41015: LD_INT 1
41017: NEG
41018: PUSH
41019: EMPTY
41020: LIST
41021: LIST
41022: PUSH
41023: LD_INT 2
41025: PUSH
41026: LD_INT 0
41028: PUSH
41029: EMPTY
41030: LIST
41031: LIST
41032: PUSH
41033: LD_INT 2
41035: PUSH
41036: LD_INT 1
41038: PUSH
41039: EMPTY
41040: LIST
41041: LIST
41042: PUSH
41043: LD_INT 1
41045: PUSH
41046: LD_INT 2
41048: PUSH
41049: EMPTY
41050: LIST
41051: LIST
41052: PUSH
41053: LD_INT 0
41055: PUSH
41056: LD_INT 2
41058: PUSH
41059: EMPTY
41060: LIST
41061: LIST
41062: PUSH
41063: LD_INT 1
41065: NEG
41066: PUSH
41067: LD_INT 1
41069: PUSH
41070: EMPTY
41071: LIST
41072: LIST
41073: PUSH
41074: LD_INT 2
41076: NEG
41077: PUSH
41078: LD_INT 0
41080: PUSH
41081: EMPTY
41082: LIST
41083: LIST
41084: PUSH
41085: LD_INT 2
41087: NEG
41088: PUSH
41089: LD_INT 1
41091: NEG
41092: PUSH
41093: EMPTY
41094: LIST
41095: LIST
41096: PUSH
41097: LD_INT 1
41099: NEG
41100: PUSH
41101: LD_INT 3
41103: NEG
41104: PUSH
41105: EMPTY
41106: LIST
41107: LIST
41108: PUSH
41109: LD_INT 0
41111: PUSH
41112: LD_INT 3
41114: NEG
41115: PUSH
41116: EMPTY
41117: LIST
41118: LIST
41119: PUSH
41120: LD_INT 1
41122: PUSH
41123: LD_INT 2
41125: NEG
41126: PUSH
41127: EMPTY
41128: LIST
41129: LIST
41130: PUSH
41131: LD_INT 2
41133: PUSH
41134: LD_INT 1
41136: NEG
41137: PUSH
41138: EMPTY
41139: LIST
41140: LIST
41141: PUSH
41142: LD_INT 3
41144: PUSH
41145: LD_INT 0
41147: PUSH
41148: EMPTY
41149: LIST
41150: LIST
41151: PUSH
41152: LD_INT 3
41154: PUSH
41155: LD_INT 1
41157: PUSH
41158: EMPTY
41159: LIST
41160: LIST
41161: PUSH
41162: LD_INT 1
41164: PUSH
41165: LD_INT 3
41167: PUSH
41168: EMPTY
41169: LIST
41170: LIST
41171: PUSH
41172: LD_INT 0
41174: PUSH
41175: LD_INT 3
41177: PUSH
41178: EMPTY
41179: LIST
41180: LIST
41181: PUSH
41182: LD_INT 1
41184: NEG
41185: PUSH
41186: LD_INT 2
41188: PUSH
41189: EMPTY
41190: LIST
41191: LIST
41192: PUSH
41193: LD_INT 2
41195: NEG
41196: PUSH
41197: LD_INT 1
41199: PUSH
41200: EMPTY
41201: LIST
41202: LIST
41203: PUSH
41204: LD_INT 3
41206: NEG
41207: PUSH
41208: LD_INT 0
41210: PUSH
41211: EMPTY
41212: LIST
41213: LIST
41214: PUSH
41215: LD_INT 3
41217: NEG
41218: PUSH
41219: LD_INT 1
41221: NEG
41222: PUSH
41223: EMPTY
41224: LIST
41225: LIST
41226: PUSH
41227: EMPTY
41228: LIST
41229: LIST
41230: LIST
41231: LIST
41232: LIST
41233: LIST
41234: LIST
41235: LIST
41236: LIST
41237: LIST
41238: LIST
41239: LIST
41240: LIST
41241: LIST
41242: LIST
41243: LIST
41244: LIST
41245: LIST
41246: LIST
41247: LIST
41248: LIST
41249: LIST
41250: LIST
41251: LIST
41252: LIST
41253: LIST
41254: LIST
41255: LIST
41256: LIST
41257: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
41258: LD_ADDR_VAR 0 44
41262: PUSH
41263: LD_INT 0
41265: PUSH
41266: LD_INT 0
41268: PUSH
41269: EMPTY
41270: LIST
41271: LIST
41272: PUSH
41273: LD_INT 0
41275: PUSH
41276: LD_INT 1
41278: NEG
41279: PUSH
41280: EMPTY
41281: LIST
41282: LIST
41283: PUSH
41284: LD_INT 1
41286: PUSH
41287: LD_INT 0
41289: PUSH
41290: EMPTY
41291: LIST
41292: LIST
41293: PUSH
41294: LD_INT 1
41296: PUSH
41297: LD_INT 1
41299: PUSH
41300: EMPTY
41301: LIST
41302: LIST
41303: PUSH
41304: LD_INT 0
41306: PUSH
41307: LD_INT 1
41309: PUSH
41310: EMPTY
41311: LIST
41312: LIST
41313: PUSH
41314: LD_INT 1
41316: NEG
41317: PUSH
41318: LD_INT 0
41320: PUSH
41321: EMPTY
41322: LIST
41323: LIST
41324: PUSH
41325: LD_INT 1
41327: NEG
41328: PUSH
41329: LD_INT 1
41331: NEG
41332: PUSH
41333: EMPTY
41334: LIST
41335: LIST
41336: PUSH
41337: LD_INT 1
41339: NEG
41340: PUSH
41341: LD_INT 2
41343: NEG
41344: PUSH
41345: EMPTY
41346: LIST
41347: LIST
41348: PUSH
41349: LD_INT 1
41351: PUSH
41352: LD_INT 1
41354: NEG
41355: PUSH
41356: EMPTY
41357: LIST
41358: LIST
41359: PUSH
41360: LD_INT 2
41362: PUSH
41363: LD_INT 0
41365: PUSH
41366: EMPTY
41367: LIST
41368: LIST
41369: PUSH
41370: LD_INT 2
41372: PUSH
41373: LD_INT 1
41375: PUSH
41376: EMPTY
41377: LIST
41378: LIST
41379: PUSH
41380: LD_INT 2
41382: PUSH
41383: LD_INT 2
41385: PUSH
41386: EMPTY
41387: LIST
41388: LIST
41389: PUSH
41390: LD_INT 1
41392: PUSH
41393: LD_INT 2
41395: PUSH
41396: EMPTY
41397: LIST
41398: LIST
41399: PUSH
41400: LD_INT 1
41402: NEG
41403: PUSH
41404: LD_INT 1
41406: PUSH
41407: EMPTY
41408: LIST
41409: LIST
41410: PUSH
41411: LD_INT 2
41413: NEG
41414: PUSH
41415: LD_INT 0
41417: PUSH
41418: EMPTY
41419: LIST
41420: LIST
41421: PUSH
41422: LD_INT 2
41424: NEG
41425: PUSH
41426: LD_INT 1
41428: NEG
41429: PUSH
41430: EMPTY
41431: LIST
41432: LIST
41433: PUSH
41434: LD_INT 2
41436: NEG
41437: PUSH
41438: LD_INT 2
41440: NEG
41441: PUSH
41442: EMPTY
41443: LIST
41444: LIST
41445: PUSH
41446: LD_INT 2
41448: NEG
41449: PUSH
41450: LD_INT 3
41452: NEG
41453: PUSH
41454: EMPTY
41455: LIST
41456: LIST
41457: PUSH
41458: LD_INT 2
41460: PUSH
41461: LD_INT 1
41463: NEG
41464: PUSH
41465: EMPTY
41466: LIST
41467: LIST
41468: PUSH
41469: LD_INT 3
41471: PUSH
41472: LD_INT 0
41474: PUSH
41475: EMPTY
41476: LIST
41477: LIST
41478: PUSH
41479: LD_INT 3
41481: PUSH
41482: LD_INT 1
41484: PUSH
41485: EMPTY
41486: LIST
41487: LIST
41488: PUSH
41489: LD_INT 3
41491: PUSH
41492: LD_INT 2
41494: PUSH
41495: EMPTY
41496: LIST
41497: LIST
41498: PUSH
41499: LD_INT 3
41501: PUSH
41502: LD_INT 3
41504: PUSH
41505: EMPTY
41506: LIST
41507: LIST
41508: PUSH
41509: LD_INT 2
41511: PUSH
41512: LD_INT 3
41514: PUSH
41515: EMPTY
41516: LIST
41517: LIST
41518: PUSH
41519: LD_INT 2
41521: NEG
41522: PUSH
41523: LD_INT 1
41525: PUSH
41526: EMPTY
41527: LIST
41528: LIST
41529: PUSH
41530: LD_INT 3
41532: NEG
41533: PUSH
41534: LD_INT 0
41536: PUSH
41537: EMPTY
41538: LIST
41539: LIST
41540: PUSH
41541: LD_INT 3
41543: NEG
41544: PUSH
41545: LD_INT 1
41547: NEG
41548: PUSH
41549: EMPTY
41550: LIST
41551: LIST
41552: PUSH
41553: LD_INT 3
41555: NEG
41556: PUSH
41557: LD_INT 2
41559: NEG
41560: PUSH
41561: EMPTY
41562: LIST
41563: LIST
41564: PUSH
41565: LD_INT 3
41567: NEG
41568: PUSH
41569: LD_INT 3
41571: NEG
41572: PUSH
41573: EMPTY
41574: LIST
41575: LIST
41576: PUSH
41577: EMPTY
41578: LIST
41579: LIST
41580: LIST
41581: LIST
41582: LIST
41583: LIST
41584: LIST
41585: LIST
41586: LIST
41587: LIST
41588: LIST
41589: LIST
41590: LIST
41591: LIST
41592: LIST
41593: LIST
41594: LIST
41595: LIST
41596: LIST
41597: LIST
41598: LIST
41599: LIST
41600: LIST
41601: LIST
41602: LIST
41603: LIST
41604: LIST
41605: LIST
41606: LIST
41607: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
41608: LD_ADDR_VAR 0 45
41612: PUSH
41613: LD_INT 0
41615: PUSH
41616: LD_INT 0
41618: PUSH
41619: EMPTY
41620: LIST
41621: LIST
41622: PUSH
41623: LD_INT 0
41625: PUSH
41626: LD_INT 1
41628: NEG
41629: PUSH
41630: EMPTY
41631: LIST
41632: LIST
41633: PUSH
41634: LD_INT 1
41636: PUSH
41637: LD_INT 0
41639: PUSH
41640: EMPTY
41641: LIST
41642: LIST
41643: PUSH
41644: LD_INT 1
41646: PUSH
41647: LD_INT 1
41649: PUSH
41650: EMPTY
41651: LIST
41652: LIST
41653: PUSH
41654: LD_INT 0
41656: PUSH
41657: LD_INT 1
41659: PUSH
41660: EMPTY
41661: LIST
41662: LIST
41663: PUSH
41664: LD_INT 1
41666: NEG
41667: PUSH
41668: LD_INT 0
41670: PUSH
41671: EMPTY
41672: LIST
41673: LIST
41674: PUSH
41675: LD_INT 1
41677: NEG
41678: PUSH
41679: LD_INT 1
41681: NEG
41682: PUSH
41683: EMPTY
41684: LIST
41685: LIST
41686: PUSH
41687: LD_INT 1
41689: NEG
41690: PUSH
41691: LD_INT 2
41693: NEG
41694: PUSH
41695: EMPTY
41696: LIST
41697: LIST
41698: PUSH
41699: LD_INT 0
41701: PUSH
41702: LD_INT 2
41704: NEG
41705: PUSH
41706: EMPTY
41707: LIST
41708: LIST
41709: PUSH
41710: LD_INT 1
41712: PUSH
41713: LD_INT 1
41715: NEG
41716: PUSH
41717: EMPTY
41718: LIST
41719: LIST
41720: PUSH
41721: LD_INT 2
41723: PUSH
41724: LD_INT 1
41726: PUSH
41727: EMPTY
41728: LIST
41729: LIST
41730: PUSH
41731: LD_INT 2
41733: PUSH
41734: LD_INT 2
41736: PUSH
41737: EMPTY
41738: LIST
41739: LIST
41740: PUSH
41741: LD_INT 1
41743: PUSH
41744: LD_INT 2
41746: PUSH
41747: EMPTY
41748: LIST
41749: LIST
41750: PUSH
41751: LD_INT 0
41753: PUSH
41754: LD_INT 2
41756: PUSH
41757: EMPTY
41758: LIST
41759: LIST
41760: PUSH
41761: LD_INT 1
41763: NEG
41764: PUSH
41765: LD_INT 1
41767: PUSH
41768: EMPTY
41769: LIST
41770: LIST
41771: PUSH
41772: LD_INT 2
41774: NEG
41775: PUSH
41776: LD_INT 1
41778: NEG
41779: PUSH
41780: EMPTY
41781: LIST
41782: LIST
41783: PUSH
41784: LD_INT 2
41786: NEG
41787: PUSH
41788: LD_INT 2
41790: NEG
41791: PUSH
41792: EMPTY
41793: LIST
41794: LIST
41795: PUSH
41796: LD_INT 2
41798: NEG
41799: PUSH
41800: LD_INT 3
41802: NEG
41803: PUSH
41804: EMPTY
41805: LIST
41806: LIST
41807: PUSH
41808: LD_INT 1
41810: NEG
41811: PUSH
41812: LD_INT 3
41814: NEG
41815: PUSH
41816: EMPTY
41817: LIST
41818: LIST
41819: PUSH
41820: LD_INT 0
41822: PUSH
41823: LD_INT 3
41825: NEG
41826: PUSH
41827: EMPTY
41828: LIST
41829: LIST
41830: PUSH
41831: LD_INT 1
41833: PUSH
41834: LD_INT 2
41836: NEG
41837: PUSH
41838: EMPTY
41839: LIST
41840: LIST
41841: PUSH
41842: LD_INT 3
41844: PUSH
41845: LD_INT 2
41847: PUSH
41848: EMPTY
41849: LIST
41850: LIST
41851: PUSH
41852: LD_INT 3
41854: PUSH
41855: LD_INT 3
41857: PUSH
41858: EMPTY
41859: LIST
41860: LIST
41861: PUSH
41862: LD_INT 2
41864: PUSH
41865: LD_INT 3
41867: PUSH
41868: EMPTY
41869: LIST
41870: LIST
41871: PUSH
41872: LD_INT 1
41874: PUSH
41875: LD_INT 3
41877: PUSH
41878: EMPTY
41879: LIST
41880: LIST
41881: PUSH
41882: LD_INT 0
41884: PUSH
41885: LD_INT 3
41887: PUSH
41888: EMPTY
41889: LIST
41890: LIST
41891: PUSH
41892: LD_INT 1
41894: NEG
41895: PUSH
41896: LD_INT 2
41898: PUSH
41899: EMPTY
41900: LIST
41901: LIST
41902: PUSH
41903: LD_INT 3
41905: NEG
41906: PUSH
41907: LD_INT 2
41909: NEG
41910: PUSH
41911: EMPTY
41912: LIST
41913: LIST
41914: PUSH
41915: LD_INT 3
41917: NEG
41918: PUSH
41919: LD_INT 3
41921: NEG
41922: PUSH
41923: EMPTY
41924: LIST
41925: LIST
41926: PUSH
41927: EMPTY
41928: LIST
41929: LIST
41930: LIST
41931: LIST
41932: LIST
41933: LIST
41934: LIST
41935: LIST
41936: LIST
41937: LIST
41938: LIST
41939: LIST
41940: LIST
41941: LIST
41942: LIST
41943: LIST
41944: LIST
41945: LIST
41946: LIST
41947: LIST
41948: LIST
41949: LIST
41950: LIST
41951: LIST
41952: LIST
41953: LIST
41954: LIST
41955: LIST
41956: LIST
41957: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
41958: LD_ADDR_VAR 0 46
41962: PUSH
41963: LD_INT 0
41965: PUSH
41966: LD_INT 0
41968: PUSH
41969: EMPTY
41970: LIST
41971: LIST
41972: PUSH
41973: LD_INT 0
41975: PUSH
41976: LD_INT 1
41978: NEG
41979: PUSH
41980: EMPTY
41981: LIST
41982: LIST
41983: PUSH
41984: LD_INT 1
41986: PUSH
41987: LD_INT 0
41989: PUSH
41990: EMPTY
41991: LIST
41992: LIST
41993: PUSH
41994: LD_INT 1
41996: PUSH
41997: LD_INT 1
41999: PUSH
42000: EMPTY
42001: LIST
42002: LIST
42003: PUSH
42004: LD_INT 0
42006: PUSH
42007: LD_INT 1
42009: PUSH
42010: EMPTY
42011: LIST
42012: LIST
42013: PUSH
42014: LD_INT 1
42016: NEG
42017: PUSH
42018: LD_INT 0
42020: PUSH
42021: EMPTY
42022: LIST
42023: LIST
42024: PUSH
42025: LD_INT 1
42027: NEG
42028: PUSH
42029: LD_INT 1
42031: NEG
42032: PUSH
42033: EMPTY
42034: LIST
42035: LIST
42036: PUSH
42037: LD_INT 1
42039: NEG
42040: PUSH
42041: LD_INT 2
42043: NEG
42044: PUSH
42045: EMPTY
42046: LIST
42047: LIST
42048: PUSH
42049: LD_INT 0
42051: PUSH
42052: LD_INT 2
42054: NEG
42055: PUSH
42056: EMPTY
42057: LIST
42058: LIST
42059: PUSH
42060: LD_INT 1
42062: PUSH
42063: LD_INT 1
42065: NEG
42066: PUSH
42067: EMPTY
42068: LIST
42069: LIST
42070: PUSH
42071: LD_INT 2
42073: PUSH
42074: LD_INT 0
42076: PUSH
42077: EMPTY
42078: LIST
42079: LIST
42080: PUSH
42081: LD_INT 2
42083: PUSH
42084: LD_INT 1
42086: PUSH
42087: EMPTY
42088: LIST
42089: LIST
42090: PUSH
42091: LD_INT 1
42093: PUSH
42094: LD_INT 2
42096: PUSH
42097: EMPTY
42098: LIST
42099: LIST
42100: PUSH
42101: LD_INT 0
42103: PUSH
42104: LD_INT 2
42106: PUSH
42107: EMPTY
42108: LIST
42109: LIST
42110: PUSH
42111: LD_INT 1
42113: NEG
42114: PUSH
42115: LD_INT 1
42117: PUSH
42118: EMPTY
42119: LIST
42120: LIST
42121: PUSH
42122: LD_INT 2
42124: NEG
42125: PUSH
42126: LD_INT 0
42128: PUSH
42129: EMPTY
42130: LIST
42131: LIST
42132: PUSH
42133: LD_INT 2
42135: NEG
42136: PUSH
42137: LD_INT 1
42139: NEG
42140: PUSH
42141: EMPTY
42142: LIST
42143: LIST
42144: PUSH
42145: LD_INT 1
42147: NEG
42148: PUSH
42149: LD_INT 3
42151: NEG
42152: PUSH
42153: EMPTY
42154: LIST
42155: LIST
42156: PUSH
42157: LD_INT 0
42159: PUSH
42160: LD_INT 3
42162: NEG
42163: PUSH
42164: EMPTY
42165: LIST
42166: LIST
42167: PUSH
42168: LD_INT 1
42170: PUSH
42171: LD_INT 2
42173: NEG
42174: PUSH
42175: EMPTY
42176: LIST
42177: LIST
42178: PUSH
42179: LD_INT 2
42181: PUSH
42182: LD_INT 1
42184: NEG
42185: PUSH
42186: EMPTY
42187: LIST
42188: LIST
42189: PUSH
42190: LD_INT 3
42192: PUSH
42193: LD_INT 0
42195: PUSH
42196: EMPTY
42197: LIST
42198: LIST
42199: PUSH
42200: LD_INT 3
42202: PUSH
42203: LD_INT 1
42205: PUSH
42206: EMPTY
42207: LIST
42208: LIST
42209: PUSH
42210: LD_INT 1
42212: PUSH
42213: LD_INT 3
42215: PUSH
42216: EMPTY
42217: LIST
42218: LIST
42219: PUSH
42220: LD_INT 0
42222: PUSH
42223: LD_INT 3
42225: PUSH
42226: EMPTY
42227: LIST
42228: LIST
42229: PUSH
42230: LD_INT 1
42232: NEG
42233: PUSH
42234: LD_INT 2
42236: PUSH
42237: EMPTY
42238: LIST
42239: LIST
42240: PUSH
42241: LD_INT 2
42243: NEG
42244: PUSH
42245: LD_INT 1
42247: PUSH
42248: EMPTY
42249: LIST
42250: LIST
42251: PUSH
42252: LD_INT 3
42254: NEG
42255: PUSH
42256: LD_INT 0
42258: PUSH
42259: EMPTY
42260: LIST
42261: LIST
42262: PUSH
42263: LD_INT 3
42265: NEG
42266: PUSH
42267: LD_INT 1
42269: NEG
42270: PUSH
42271: EMPTY
42272: LIST
42273: LIST
42274: PUSH
42275: EMPTY
42276: LIST
42277: LIST
42278: LIST
42279: LIST
42280: LIST
42281: LIST
42282: LIST
42283: LIST
42284: LIST
42285: LIST
42286: LIST
42287: LIST
42288: LIST
42289: LIST
42290: LIST
42291: LIST
42292: LIST
42293: LIST
42294: LIST
42295: LIST
42296: LIST
42297: LIST
42298: LIST
42299: LIST
42300: LIST
42301: LIST
42302: LIST
42303: LIST
42304: LIST
42305: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
42306: LD_ADDR_VAR 0 47
42310: PUSH
42311: LD_INT 0
42313: PUSH
42314: LD_INT 0
42316: PUSH
42317: EMPTY
42318: LIST
42319: LIST
42320: PUSH
42321: LD_INT 0
42323: PUSH
42324: LD_INT 1
42326: NEG
42327: PUSH
42328: EMPTY
42329: LIST
42330: LIST
42331: PUSH
42332: LD_INT 1
42334: PUSH
42335: LD_INT 0
42337: PUSH
42338: EMPTY
42339: LIST
42340: LIST
42341: PUSH
42342: LD_INT 1
42344: PUSH
42345: LD_INT 1
42347: PUSH
42348: EMPTY
42349: LIST
42350: LIST
42351: PUSH
42352: LD_INT 0
42354: PUSH
42355: LD_INT 1
42357: PUSH
42358: EMPTY
42359: LIST
42360: LIST
42361: PUSH
42362: LD_INT 1
42364: NEG
42365: PUSH
42366: LD_INT 0
42368: PUSH
42369: EMPTY
42370: LIST
42371: LIST
42372: PUSH
42373: LD_INT 1
42375: NEG
42376: PUSH
42377: LD_INT 1
42379: NEG
42380: PUSH
42381: EMPTY
42382: LIST
42383: LIST
42384: PUSH
42385: LD_INT 1
42387: NEG
42388: PUSH
42389: LD_INT 2
42391: NEG
42392: PUSH
42393: EMPTY
42394: LIST
42395: LIST
42396: PUSH
42397: LD_INT 0
42399: PUSH
42400: LD_INT 2
42402: NEG
42403: PUSH
42404: EMPTY
42405: LIST
42406: LIST
42407: PUSH
42408: LD_INT 1
42410: PUSH
42411: LD_INT 1
42413: NEG
42414: PUSH
42415: EMPTY
42416: LIST
42417: LIST
42418: PUSH
42419: LD_INT 2
42421: NEG
42422: PUSH
42423: LD_INT 1
42425: NEG
42426: PUSH
42427: EMPTY
42428: LIST
42429: LIST
42430: PUSH
42431: LD_INT 2
42433: NEG
42434: PUSH
42435: LD_INT 2
42437: NEG
42438: PUSH
42439: EMPTY
42440: LIST
42441: LIST
42442: PUSH
42443: EMPTY
42444: LIST
42445: LIST
42446: LIST
42447: LIST
42448: LIST
42449: LIST
42450: LIST
42451: LIST
42452: LIST
42453: LIST
42454: LIST
42455: LIST
42456: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
42457: LD_ADDR_VAR 0 48
42461: PUSH
42462: LD_INT 0
42464: PUSH
42465: LD_INT 0
42467: PUSH
42468: EMPTY
42469: LIST
42470: LIST
42471: PUSH
42472: LD_INT 0
42474: PUSH
42475: LD_INT 1
42477: NEG
42478: PUSH
42479: EMPTY
42480: LIST
42481: LIST
42482: PUSH
42483: LD_INT 1
42485: PUSH
42486: LD_INT 0
42488: PUSH
42489: EMPTY
42490: LIST
42491: LIST
42492: PUSH
42493: LD_INT 1
42495: PUSH
42496: LD_INT 1
42498: PUSH
42499: EMPTY
42500: LIST
42501: LIST
42502: PUSH
42503: LD_INT 0
42505: PUSH
42506: LD_INT 1
42508: PUSH
42509: EMPTY
42510: LIST
42511: LIST
42512: PUSH
42513: LD_INT 1
42515: NEG
42516: PUSH
42517: LD_INT 0
42519: PUSH
42520: EMPTY
42521: LIST
42522: LIST
42523: PUSH
42524: LD_INT 1
42526: NEG
42527: PUSH
42528: LD_INT 1
42530: NEG
42531: PUSH
42532: EMPTY
42533: LIST
42534: LIST
42535: PUSH
42536: LD_INT 1
42538: NEG
42539: PUSH
42540: LD_INT 2
42542: NEG
42543: PUSH
42544: EMPTY
42545: LIST
42546: LIST
42547: PUSH
42548: LD_INT 0
42550: PUSH
42551: LD_INT 2
42553: NEG
42554: PUSH
42555: EMPTY
42556: LIST
42557: LIST
42558: PUSH
42559: LD_INT 1
42561: PUSH
42562: LD_INT 1
42564: NEG
42565: PUSH
42566: EMPTY
42567: LIST
42568: LIST
42569: PUSH
42570: LD_INT 2
42572: PUSH
42573: LD_INT 0
42575: PUSH
42576: EMPTY
42577: LIST
42578: LIST
42579: PUSH
42580: LD_INT 2
42582: PUSH
42583: LD_INT 1
42585: PUSH
42586: EMPTY
42587: LIST
42588: LIST
42589: PUSH
42590: EMPTY
42591: LIST
42592: LIST
42593: LIST
42594: LIST
42595: LIST
42596: LIST
42597: LIST
42598: LIST
42599: LIST
42600: LIST
42601: LIST
42602: LIST
42603: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
42604: LD_ADDR_VAR 0 49
42608: PUSH
42609: LD_INT 0
42611: PUSH
42612: LD_INT 0
42614: PUSH
42615: EMPTY
42616: LIST
42617: LIST
42618: PUSH
42619: LD_INT 0
42621: PUSH
42622: LD_INT 1
42624: NEG
42625: PUSH
42626: EMPTY
42627: LIST
42628: LIST
42629: PUSH
42630: LD_INT 1
42632: PUSH
42633: LD_INT 0
42635: PUSH
42636: EMPTY
42637: LIST
42638: LIST
42639: PUSH
42640: LD_INT 1
42642: PUSH
42643: LD_INT 1
42645: PUSH
42646: EMPTY
42647: LIST
42648: LIST
42649: PUSH
42650: LD_INT 0
42652: PUSH
42653: LD_INT 1
42655: PUSH
42656: EMPTY
42657: LIST
42658: LIST
42659: PUSH
42660: LD_INT 1
42662: NEG
42663: PUSH
42664: LD_INT 0
42666: PUSH
42667: EMPTY
42668: LIST
42669: LIST
42670: PUSH
42671: LD_INT 1
42673: NEG
42674: PUSH
42675: LD_INT 1
42677: NEG
42678: PUSH
42679: EMPTY
42680: LIST
42681: LIST
42682: PUSH
42683: LD_INT 1
42685: PUSH
42686: LD_INT 1
42688: NEG
42689: PUSH
42690: EMPTY
42691: LIST
42692: LIST
42693: PUSH
42694: LD_INT 2
42696: PUSH
42697: LD_INT 0
42699: PUSH
42700: EMPTY
42701: LIST
42702: LIST
42703: PUSH
42704: LD_INT 2
42706: PUSH
42707: LD_INT 1
42709: PUSH
42710: EMPTY
42711: LIST
42712: LIST
42713: PUSH
42714: LD_INT 2
42716: PUSH
42717: LD_INT 2
42719: PUSH
42720: EMPTY
42721: LIST
42722: LIST
42723: PUSH
42724: LD_INT 1
42726: PUSH
42727: LD_INT 2
42729: PUSH
42730: EMPTY
42731: LIST
42732: LIST
42733: PUSH
42734: EMPTY
42735: LIST
42736: LIST
42737: LIST
42738: LIST
42739: LIST
42740: LIST
42741: LIST
42742: LIST
42743: LIST
42744: LIST
42745: LIST
42746: LIST
42747: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
42748: LD_ADDR_VAR 0 50
42752: PUSH
42753: LD_INT 0
42755: PUSH
42756: LD_INT 0
42758: PUSH
42759: EMPTY
42760: LIST
42761: LIST
42762: PUSH
42763: LD_INT 0
42765: PUSH
42766: LD_INT 1
42768: NEG
42769: PUSH
42770: EMPTY
42771: LIST
42772: LIST
42773: PUSH
42774: LD_INT 1
42776: PUSH
42777: LD_INT 0
42779: PUSH
42780: EMPTY
42781: LIST
42782: LIST
42783: PUSH
42784: LD_INT 1
42786: PUSH
42787: LD_INT 1
42789: PUSH
42790: EMPTY
42791: LIST
42792: LIST
42793: PUSH
42794: LD_INT 0
42796: PUSH
42797: LD_INT 1
42799: PUSH
42800: EMPTY
42801: LIST
42802: LIST
42803: PUSH
42804: LD_INT 1
42806: NEG
42807: PUSH
42808: LD_INT 0
42810: PUSH
42811: EMPTY
42812: LIST
42813: LIST
42814: PUSH
42815: LD_INT 1
42817: NEG
42818: PUSH
42819: LD_INT 1
42821: NEG
42822: PUSH
42823: EMPTY
42824: LIST
42825: LIST
42826: PUSH
42827: LD_INT 2
42829: PUSH
42830: LD_INT 1
42832: PUSH
42833: EMPTY
42834: LIST
42835: LIST
42836: PUSH
42837: LD_INT 2
42839: PUSH
42840: LD_INT 2
42842: PUSH
42843: EMPTY
42844: LIST
42845: LIST
42846: PUSH
42847: LD_INT 1
42849: PUSH
42850: LD_INT 2
42852: PUSH
42853: EMPTY
42854: LIST
42855: LIST
42856: PUSH
42857: LD_INT 0
42859: PUSH
42860: LD_INT 2
42862: PUSH
42863: EMPTY
42864: LIST
42865: LIST
42866: PUSH
42867: LD_INT 1
42869: NEG
42870: PUSH
42871: LD_INT 1
42873: PUSH
42874: EMPTY
42875: LIST
42876: LIST
42877: PUSH
42878: EMPTY
42879: LIST
42880: LIST
42881: LIST
42882: LIST
42883: LIST
42884: LIST
42885: LIST
42886: LIST
42887: LIST
42888: LIST
42889: LIST
42890: LIST
42891: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
42892: LD_ADDR_VAR 0 51
42896: PUSH
42897: LD_INT 0
42899: PUSH
42900: LD_INT 0
42902: PUSH
42903: EMPTY
42904: LIST
42905: LIST
42906: PUSH
42907: LD_INT 0
42909: PUSH
42910: LD_INT 1
42912: NEG
42913: PUSH
42914: EMPTY
42915: LIST
42916: LIST
42917: PUSH
42918: LD_INT 1
42920: PUSH
42921: LD_INT 0
42923: PUSH
42924: EMPTY
42925: LIST
42926: LIST
42927: PUSH
42928: LD_INT 1
42930: PUSH
42931: LD_INT 1
42933: PUSH
42934: EMPTY
42935: LIST
42936: LIST
42937: PUSH
42938: LD_INT 0
42940: PUSH
42941: LD_INT 1
42943: PUSH
42944: EMPTY
42945: LIST
42946: LIST
42947: PUSH
42948: LD_INT 1
42950: NEG
42951: PUSH
42952: LD_INT 0
42954: PUSH
42955: EMPTY
42956: LIST
42957: LIST
42958: PUSH
42959: LD_INT 1
42961: NEG
42962: PUSH
42963: LD_INT 1
42965: NEG
42966: PUSH
42967: EMPTY
42968: LIST
42969: LIST
42970: PUSH
42971: LD_INT 1
42973: PUSH
42974: LD_INT 2
42976: PUSH
42977: EMPTY
42978: LIST
42979: LIST
42980: PUSH
42981: LD_INT 0
42983: PUSH
42984: LD_INT 2
42986: PUSH
42987: EMPTY
42988: LIST
42989: LIST
42990: PUSH
42991: LD_INT 1
42993: NEG
42994: PUSH
42995: LD_INT 1
42997: PUSH
42998: EMPTY
42999: LIST
43000: LIST
43001: PUSH
43002: LD_INT 2
43004: NEG
43005: PUSH
43006: LD_INT 0
43008: PUSH
43009: EMPTY
43010: LIST
43011: LIST
43012: PUSH
43013: LD_INT 2
43015: NEG
43016: PUSH
43017: LD_INT 1
43019: NEG
43020: PUSH
43021: EMPTY
43022: LIST
43023: LIST
43024: PUSH
43025: EMPTY
43026: LIST
43027: LIST
43028: LIST
43029: LIST
43030: LIST
43031: LIST
43032: LIST
43033: LIST
43034: LIST
43035: LIST
43036: LIST
43037: LIST
43038: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
43039: LD_ADDR_VAR 0 52
43043: PUSH
43044: LD_INT 0
43046: PUSH
43047: LD_INT 0
43049: PUSH
43050: EMPTY
43051: LIST
43052: LIST
43053: PUSH
43054: LD_INT 0
43056: PUSH
43057: LD_INT 1
43059: NEG
43060: PUSH
43061: EMPTY
43062: LIST
43063: LIST
43064: PUSH
43065: LD_INT 1
43067: PUSH
43068: LD_INT 0
43070: PUSH
43071: EMPTY
43072: LIST
43073: LIST
43074: PUSH
43075: LD_INT 1
43077: PUSH
43078: LD_INT 1
43080: PUSH
43081: EMPTY
43082: LIST
43083: LIST
43084: PUSH
43085: LD_INT 0
43087: PUSH
43088: LD_INT 1
43090: PUSH
43091: EMPTY
43092: LIST
43093: LIST
43094: PUSH
43095: LD_INT 1
43097: NEG
43098: PUSH
43099: LD_INT 0
43101: PUSH
43102: EMPTY
43103: LIST
43104: LIST
43105: PUSH
43106: LD_INT 1
43108: NEG
43109: PUSH
43110: LD_INT 1
43112: NEG
43113: PUSH
43114: EMPTY
43115: LIST
43116: LIST
43117: PUSH
43118: LD_INT 1
43120: NEG
43121: PUSH
43122: LD_INT 2
43124: NEG
43125: PUSH
43126: EMPTY
43127: LIST
43128: LIST
43129: PUSH
43130: LD_INT 1
43132: NEG
43133: PUSH
43134: LD_INT 1
43136: PUSH
43137: EMPTY
43138: LIST
43139: LIST
43140: PUSH
43141: LD_INT 2
43143: NEG
43144: PUSH
43145: LD_INT 0
43147: PUSH
43148: EMPTY
43149: LIST
43150: LIST
43151: PUSH
43152: LD_INT 2
43154: NEG
43155: PUSH
43156: LD_INT 1
43158: NEG
43159: PUSH
43160: EMPTY
43161: LIST
43162: LIST
43163: PUSH
43164: LD_INT 2
43166: NEG
43167: PUSH
43168: LD_INT 2
43170: NEG
43171: PUSH
43172: EMPTY
43173: LIST
43174: LIST
43175: PUSH
43176: EMPTY
43177: LIST
43178: LIST
43179: LIST
43180: LIST
43181: LIST
43182: LIST
43183: LIST
43184: LIST
43185: LIST
43186: LIST
43187: LIST
43188: LIST
43189: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
43190: LD_ADDR_VAR 0 53
43194: PUSH
43195: LD_INT 0
43197: PUSH
43198: LD_INT 0
43200: PUSH
43201: EMPTY
43202: LIST
43203: LIST
43204: PUSH
43205: LD_INT 0
43207: PUSH
43208: LD_INT 1
43210: NEG
43211: PUSH
43212: EMPTY
43213: LIST
43214: LIST
43215: PUSH
43216: LD_INT 1
43218: PUSH
43219: LD_INT 0
43221: PUSH
43222: EMPTY
43223: LIST
43224: LIST
43225: PUSH
43226: LD_INT 1
43228: PUSH
43229: LD_INT 1
43231: PUSH
43232: EMPTY
43233: LIST
43234: LIST
43235: PUSH
43236: LD_INT 0
43238: PUSH
43239: LD_INT 1
43241: PUSH
43242: EMPTY
43243: LIST
43244: LIST
43245: PUSH
43246: LD_INT 1
43248: NEG
43249: PUSH
43250: LD_INT 0
43252: PUSH
43253: EMPTY
43254: LIST
43255: LIST
43256: PUSH
43257: LD_INT 1
43259: NEG
43260: PUSH
43261: LD_INT 1
43263: NEG
43264: PUSH
43265: EMPTY
43266: LIST
43267: LIST
43268: PUSH
43269: LD_INT 1
43271: NEG
43272: PUSH
43273: LD_INT 2
43275: NEG
43276: PUSH
43277: EMPTY
43278: LIST
43279: LIST
43280: PUSH
43281: LD_INT 0
43283: PUSH
43284: LD_INT 2
43286: NEG
43287: PUSH
43288: EMPTY
43289: LIST
43290: LIST
43291: PUSH
43292: LD_INT 1
43294: PUSH
43295: LD_INT 1
43297: NEG
43298: PUSH
43299: EMPTY
43300: LIST
43301: LIST
43302: PUSH
43303: LD_INT 2
43305: PUSH
43306: LD_INT 0
43308: PUSH
43309: EMPTY
43310: LIST
43311: LIST
43312: PUSH
43313: LD_INT 2
43315: PUSH
43316: LD_INT 1
43318: PUSH
43319: EMPTY
43320: LIST
43321: LIST
43322: PUSH
43323: LD_INT 2
43325: PUSH
43326: LD_INT 2
43328: PUSH
43329: EMPTY
43330: LIST
43331: LIST
43332: PUSH
43333: LD_INT 1
43335: PUSH
43336: LD_INT 2
43338: PUSH
43339: EMPTY
43340: LIST
43341: LIST
43342: PUSH
43343: LD_INT 0
43345: PUSH
43346: LD_INT 2
43348: PUSH
43349: EMPTY
43350: LIST
43351: LIST
43352: PUSH
43353: LD_INT 1
43355: NEG
43356: PUSH
43357: LD_INT 1
43359: PUSH
43360: EMPTY
43361: LIST
43362: LIST
43363: PUSH
43364: LD_INT 2
43366: NEG
43367: PUSH
43368: LD_INT 0
43370: PUSH
43371: EMPTY
43372: LIST
43373: LIST
43374: PUSH
43375: LD_INT 2
43377: NEG
43378: PUSH
43379: LD_INT 1
43381: NEG
43382: PUSH
43383: EMPTY
43384: LIST
43385: LIST
43386: PUSH
43387: LD_INT 2
43389: NEG
43390: PUSH
43391: LD_INT 2
43393: NEG
43394: PUSH
43395: EMPTY
43396: LIST
43397: LIST
43398: PUSH
43399: EMPTY
43400: LIST
43401: LIST
43402: LIST
43403: LIST
43404: LIST
43405: LIST
43406: LIST
43407: LIST
43408: LIST
43409: LIST
43410: LIST
43411: LIST
43412: LIST
43413: LIST
43414: LIST
43415: LIST
43416: LIST
43417: LIST
43418: LIST
43419: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
43420: LD_ADDR_VAR 0 54
43424: PUSH
43425: LD_INT 0
43427: PUSH
43428: LD_INT 0
43430: PUSH
43431: EMPTY
43432: LIST
43433: LIST
43434: PUSH
43435: LD_INT 0
43437: PUSH
43438: LD_INT 1
43440: NEG
43441: PUSH
43442: EMPTY
43443: LIST
43444: LIST
43445: PUSH
43446: LD_INT 1
43448: PUSH
43449: LD_INT 0
43451: PUSH
43452: EMPTY
43453: LIST
43454: LIST
43455: PUSH
43456: LD_INT 1
43458: PUSH
43459: LD_INT 1
43461: PUSH
43462: EMPTY
43463: LIST
43464: LIST
43465: PUSH
43466: LD_INT 0
43468: PUSH
43469: LD_INT 1
43471: PUSH
43472: EMPTY
43473: LIST
43474: LIST
43475: PUSH
43476: LD_INT 1
43478: NEG
43479: PUSH
43480: LD_INT 0
43482: PUSH
43483: EMPTY
43484: LIST
43485: LIST
43486: PUSH
43487: LD_INT 1
43489: NEG
43490: PUSH
43491: LD_INT 1
43493: NEG
43494: PUSH
43495: EMPTY
43496: LIST
43497: LIST
43498: PUSH
43499: LD_INT 1
43501: NEG
43502: PUSH
43503: LD_INT 2
43505: NEG
43506: PUSH
43507: EMPTY
43508: LIST
43509: LIST
43510: PUSH
43511: LD_INT 0
43513: PUSH
43514: LD_INT 2
43516: NEG
43517: PUSH
43518: EMPTY
43519: LIST
43520: LIST
43521: PUSH
43522: LD_INT 1
43524: PUSH
43525: LD_INT 1
43527: NEG
43528: PUSH
43529: EMPTY
43530: LIST
43531: LIST
43532: PUSH
43533: LD_INT 2
43535: PUSH
43536: LD_INT 0
43538: PUSH
43539: EMPTY
43540: LIST
43541: LIST
43542: PUSH
43543: LD_INT 2
43545: PUSH
43546: LD_INT 1
43548: PUSH
43549: EMPTY
43550: LIST
43551: LIST
43552: PUSH
43553: LD_INT 2
43555: PUSH
43556: LD_INT 2
43558: PUSH
43559: EMPTY
43560: LIST
43561: LIST
43562: PUSH
43563: LD_INT 1
43565: PUSH
43566: LD_INT 2
43568: PUSH
43569: EMPTY
43570: LIST
43571: LIST
43572: PUSH
43573: LD_INT 0
43575: PUSH
43576: LD_INT 2
43578: PUSH
43579: EMPTY
43580: LIST
43581: LIST
43582: PUSH
43583: LD_INT 1
43585: NEG
43586: PUSH
43587: LD_INT 1
43589: PUSH
43590: EMPTY
43591: LIST
43592: LIST
43593: PUSH
43594: LD_INT 2
43596: NEG
43597: PUSH
43598: LD_INT 0
43600: PUSH
43601: EMPTY
43602: LIST
43603: LIST
43604: PUSH
43605: LD_INT 2
43607: NEG
43608: PUSH
43609: LD_INT 1
43611: NEG
43612: PUSH
43613: EMPTY
43614: LIST
43615: LIST
43616: PUSH
43617: LD_INT 2
43619: NEG
43620: PUSH
43621: LD_INT 2
43623: NEG
43624: PUSH
43625: EMPTY
43626: LIST
43627: LIST
43628: PUSH
43629: EMPTY
43630: LIST
43631: LIST
43632: LIST
43633: LIST
43634: LIST
43635: LIST
43636: LIST
43637: LIST
43638: LIST
43639: LIST
43640: LIST
43641: LIST
43642: LIST
43643: LIST
43644: LIST
43645: LIST
43646: LIST
43647: LIST
43648: LIST
43649: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
43650: LD_ADDR_VAR 0 55
43654: PUSH
43655: LD_INT 0
43657: PUSH
43658: LD_INT 0
43660: PUSH
43661: EMPTY
43662: LIST
43663: LIST
43664: PUSH
43665: LD_INT 0
43667: PUSH
43668: LD_INT 1
43670: NEG
43671: PUSH
43672: EMPTY
43673: LIST
43674: LIST
43675: PUSH
43676: LD_INT 1
43678: PUSH
43679: LD_INT 0
43681: PUSH
43682: EMPTY
43683: LIST
43684: LIST
43685: PUSH
43686: LD_INT 1
43688: PUSH
43689: LD_INT 1
43691: PUSH
43692: EMPTY
43693: LIST
43694: LIST
43695: PUSH
43696: LD_INT 0
43698: PUSH
43699: LD_INT 1
43701: PUSH
43702: EMPTY
43703: LIST
43704: LIST
43705: PUSH
43706: LD_INT 1
43708: NEG
43709: PUSH
43710: LD_INT 0
43712: PUSH
43713: EMPTY
43714: LIST
43715: LIST
43716: PUSH
43717: LD_INT 1
43719: NEG
43720: PUSH
43721: LD_INT 1
43723: NEG
43724: PUSH
43725: EMPTY
43726: LIST
43727: LIST
43728: PUSH
43729: LD_INT 1
43731: NEG
43732: PUSH
43733: LD_INT 2
43735: NEG
43736: PUSH
43737: EMPTY
43738: LIST
43739: LIST
43740: PUSH
43741: LD_INT 0
43743: PUSH
43744: LD_INT 2
43746: NEG
43747: PUSH
43748: EMPTY
43749: LIST
43750: LIST
43751: PUSH
43752: LD_INT 1
43754: PUSH
43755: LD_INT 1
43757: NEG
43758: PUSH
43759: EMPTY
43760: LIST
43761: LIST
43762: PUSH
43763: LD_INT 2
43765: PUSH
43766: LD_INT 0
43768: PUSH
43769: EMPTY
43770: LIST
43771: LIST
43772: PUSH
43773: LD_INT 2
43775: PUSH
43776: LD_INT 1
43778: PUSH
43779: EMPTY
43780: LIST
43781: LIST
43782: PUSH
43783: LD_INT 2
43785: PUSH
43786: LD_INT 2
43788: PUSH
43789: EMPTY
43790: LIST
43791: LIST
43792: PUSH
43793: LD_INT 1
43795: PUSH
43796: LD_INT 2
43798: PUSH
43799: EMPTY
43800: LIST
43801: LIST
43802: PUSH
43803: LD_INT 0
43805: PUSH
43806: LD_INT 2
43808: PUSH
43809: EMPTY
43810: LIST
43811: LIST
43812: PUSH
43813: LD_INT 1
43815: NEG
43816: PUSH
43817: LD_INT 1
43819: PUSH
43820: EMPTY
43821: LIST
43822: LIST
43823: PUSH
43824: LD_INT 2
43826: NEG
43827: PUSH
43828: LD_INT 0
43830: PUSH
43831: EMPTY
43832: LIST
43833: LIST
43834: PUSH
43835: LD_INT 2
43837: NEG
43838: PUSH
43839: LD_INT 1
43841: NEG
43842: PUSH
43843: EMPTY
43844: LIST
43845: LIST
43846: PUSH
43847: LD_INT 2
43849: NEG
43850: PUSH
43851: LD_INT 2
43853: NEG
43854: PUSH
43855: EMPTY
43856: LIST
43857: LIST
43858: PUSH
43859: EMPTY
43860: LIST
43861: LIST
43862: LIST
43863: LIST
43864: LIST
43865: LIST
43866: LIST
43867: LIST
43868: LIST
43869: LIST
43870: LIST
43871: LIST
43872: LIST
43873: LIST
43874: LIST
43875: LIST
43876: LIST
43877: LIST
43878: LIST
43879: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
43880: LD_ADDR_VAR 0 56
43884: PUSH
43885: LD_INT 0
43887: PUSH
43888: LD_INT 0
43890: PUSH
43891: EMPTY
43892: LIST
43893: LIST
43894: PUSH
43895: LD_INT 0
43897: PUSH
43898: LD_INT 1
43900: NEG
43901: PUSH
43902: EMPTY
43903: LIST
43904: LIST
43905: PUSH
43906: LD_INT 1
43908: PUSH
43909: LD_INT 0
43911: PUSH
43912: EMPTY
43913: LIST
43914: LIST
43915: PUSH
43916: LD_INT 1
43918: PUSH
43919: LD_INT 1
43921: PUSH
43922: EMPTY
43923: LIST
43924: LIST
43925: PUSH
43926: LD_INT 0
43928: PUSH
43929: LD_INT 1
43931: PUSH
43932: EMPTY
43933: LIST
43934: LIST
43935: PUSH
43936: LD_INT 1
43938: NEG
43939: PUSH
43940: LD_INT 0
43942: PUSH
43943: EMPTY
43944: LIST
43945: LIST
43946: PUSH
43947: LD_INT 1
43949: NEG
43950: PUSH
43951: LD_INT 1
43953: NEG
43954: PUSH
43955: EMPTY
43956: LIST
43957: LIST
43958: PUSH
43959: LD_INT 1
43961: NEG
43962: PUSH
43963: LD_INT 2
43965: NEG
43966: PUSH
43967: EMPTY
43968: LIST
43969: LIST
43970: PUSH
43971: LD_INT 0
43973: PUSH
43974: LD_INT 2
43976: NEG
43977: PUSH
43978: EMPTY
43979: LIST
43980: LIST
43981: PUSH
43982: LD_INT 1
43984: PUSH
43985: LD_INT 1
43987: NEG
43988: PUSH
43989: EMPTY
43990: LIST
43991: LIST
43992: PUSH
43993: LD_INT 2
43995: PUSH
43996: LD_INT 0
43998: PUSH
43999: EMPTY
44000: LIST
44001: LIST
44002: PUSH
44003: LD_INT 2
44005: PUSH
44006: LD_INT 1
44008: PUSH
44009: EMPTY
44010: LIST
44011: LIST
44012: PUSH
44013: LD_INT 2
44015: PUSH
44016: LD_INT 2
44018: PUSH
44019: EMPTY
44020: LIST
44021: LIST
44022: PUSH
44023: LD_INT 1
44025: PUSH
44026: LD_INT 2
44028: PUSH
44029: EMPTY
44030: LIST
44031: LIST
44032: PUSH
44033: LD_INT 0
44035: PUSH
44036: LD_INT 2
44038: PUSH
44039: EMPTY
44040: LIST
44041: LIST
44042: PUSH
44043: LD_INT 1
44045: NEG
44046: PUSH
44047: LD_INT 1
44049: PUSH
44050: EMPTY
44051: LIST
44052: LIST
44053: PUSH
44054: LD_INT 2
44056: NEG
44057: PUSH
44058: LD_INT 0
44060: PUSH
44061: EMPTY
44062: LIST
44063: LIST
44064: PUSH
44065: LD_INT 2
44067: NEG
44068: PUSH
44069: LD_INT 1
44071: NEG
44072: PUSH
44073: EMPTY
44074: LIST
44075: LIST
44076: PUSH
44077: LD_INT 2
44079: NEG
44080: PUSH
44081: LD_INT 2
44083: NEG
44084: PUSH
44085: EMPTY
44086: LIST
44087: LIST
44088: PUSH
44089: EMPTY
44090: LIST
44091: LIST
44092: LIST
44093: LIST
44094: LIST
44095: LIST
44096: LIST
44097: LIST
44098: LIST
44099: LIST
44100: LIST
44101: LIST
44102: LIST
44103: LIST
44104: LIST
44105: LIST
44106: LIST
44107: LIST
44108: LIST
44109: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
44110: LD_ADDR_VAR 0 57
44114: PUSH
44115: LD_INT 0
44117: PUSH
44118: LD_INT 0
44120: PUSH
44121: EMPTY
44122: LIST
44123: LIST
44124: PUSH
44125: LD_INT 0
44127: PUSH
44128: LD_INT 1
44130: NEG
44131: PUSH
44132: EMPTY
44133: LIST
44134: LIST
44135: PUSH
44136: LD_INT 1
44138: PUSH
44139: LD_INT 0
44141: PUSH
44142: EMPTY
44143: LIST
44144: LIST
44145: PUSH
44146: LD_INT 1
44148: PUSH
44149: LD_INT 1
44151: PUSH
44152: EMPTY
44153: LIST
44154: LIST
44155: PUSH
44156: LD_INT 0
44158: PUSH
44159: LD_INT 1
44161: PUSH
44162: EMPTY
44163: LIST
44164: LIST
44165: PUSH
44166: LD_INT 1
44168: NEG
44169: PUSH
44170: LD_INT 0
44172: PUSH
44173: EMPTY
44174: LIST
44175: LIST
44176: PUSH
44177: LD_INT 1
44179: NEG
44180: PUSH
44181: LD_INT 1
44183: NEG
44184: PUSH
44185: EMPTY
44186: LIST
44187: LIST
44188: PUSH
44189: LD_INT 1
44191: NEG
44192: PUSH
44193: LD_INT 2
44195: NEG
44196: PUSH
44197: EMPTY
44198: LIST
44199: LIST
44200: PUSH
44201: LD_INT 0
44203: PUSH
44204: LD_INT 2
44206: NEG
44207: PUSH
44208: EMPTY
44209: LIST
44210: LIST
44211: PUSH
44212: LD_INT 1
44214: PUSH
44215: LD_INT 1
44217: NEG
44218: PUSH
44219: EMPTY
44220: LIST
44221: LIST
44222: PUSH
44223: LD_INT 2
44225: PUSH
44226: LD_INT 0
44228: PUSH
44229: EMPTY
44230: LIST
44231: LIST
44232: PUSH
44233: LD_INT 2
44235: PUSH
44236: LD_INT 1
44238: PUSH
44239: EMPTY
44240: LIST
44241: LIST
44242: PUSH
44243: LD_INT 2
44245: PUSH
44246: LD_INT 2
44248: PUSH
44249: EMPTY
44250: LIST
44251: LIST
44252: PUSH
44253: LD_INT 1
44255: PUSH
44256: LD_INT 2
44258: PUSH
44259: EMPTY
44260: LIST
44261: LIST
44262: PUSH
44263: LD_INT 0
44265: PUSH
44266: LD_INT 2
44268: PUSH
44269: EMPTY
44270: LIST
44271: LIST
44272: PUSH
44273: LD_INT 1
44275: NEG
44276: PUSH
44277: LD_INT 1
44279: PUSH
44280: EMPTY
44281: LIST
44282: LIST
44283: PUSH
44284: LD_INT 2
44286: NEG
44287: PUSH
44288: LD_INT 0
44290: PUSH
44291: EMPTY
44292: LIST
44293: LIST
44294: PUSH
44295: LD_INT 2
44297: NEG
44298: PUSH
44299: LD_INT 1
44301: NEG
44302: PUSH
44303: EMPTY
44304: LIST
44305: LIST
44306: PUSH
44307: LD_INT 2
44309: NEG
44310: PUSH
44311: LD_INT 2
44313: NEG
44314: PUSH
44315: EMPTY
44316: LIST
44317: LIST
44318: PUSH
44319: EMPTY
44320: LIST
44321: LIST
44322: LIST
44323: LIST
44324: LIST
44325: LIST
44326: LIST
44327: LIST
44328: LIST
44329: LIST
44330: LIST
44331: LIST
44332: LIST
44333: LIST
44334: LIST
44335: LIST
44336: LIST
44337: LIST
44338: LIST
44339: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
44340: LD_ADDR_VAR 0 58
44344: PUSH
44345: LD_INT 0
44347: PUSH
44348: LD_INT 0
44350: PUSH
44351: EMPTY
44352: LIST
44353: LIST
44354: PUSH
44355: LD_INT 0
44357: PUSH
44358: LD_INT 1
44360: NEG
44361: PUSH
44362: EMPTY
44363: LIST
44364: LIST
44365: PUSH
44366: LD_INT 1
44368: PUSH
44369: LD_INT 0
44371: PUSH
44372: EMPTY
44373: LIST
44374: LIST
44375: PUSH
44376: LD_INT 1
44378: PUSH
44379: LD_INT 1
44381: PUSH
44382: EMPTY
44383: LIST
44384: LIST
44385: PUSH
44386: LD_INT 0
44388: PUSH
44389: LD_INT 1
44391: PUSH
44392: EMPTY
44393: LIST
44394: LIST
44395: PUSH
44396: LD_INT 1
44398: NEG
44399: PUSH
44400: LD_INT 0
44402: PUSH
44403: EMPTY
44404: LIST
44405: LIST
44406: PUSH
44407: LD_INT 1
44409: NEG
44410: PUSH
44411: LD_INT 1
44413: NEG
44414: PUSH
44415: EMPTY
44416: LIST
44417: LIST
44418: PUSH
44419: LD_INT 1
44421: NEG
44422: PUSH
44423: LD_INT 2
44425: NEG
44426: PUSH
44427: EMPTY
44428: LIST
44429: LIST
44430: PUSH
44431: LD_INT 0
44433: PUSH
44434: LD_INT 2
44436: NEG
44437: PUSH
44438: EMPTY
44439: LIST
44440: LIST
44441: PUSH
44442: LD_INT 1
44444: PUSH
44445: LD_INT 1
44447: NEG
44448: PUSH
44449: EMPTY
44450: LIST
44451: LIST
44452: PUSH
44453: LD_INT 2
44455: PUSH
44456: LD_INT 0
44458: PUSH
44459: EMPTY
44460: LIST
44461: LIST
44462: PUSH
44463: LD_INT 2
44465: PUSH
44466: LD_INT 1
44468: PUSH
44469: EMPTY
44470: LIST
44471: LIST
44472: PUSH
44473: LD_INT 2
44475: PUSH
44476: LD_INT 2
44478: PUSH
44479: EMPTY
44480: LIST
44481: LIST
44482: PUSH
44483: LD_INT 1
44485: PUSH
44486: LD_INT 2
44488: PUSH
44489: EMPTY
44490: LIST
44491: LIST
44492: PUSH
44493: LD_INT 0
44495: PUSH
44496: LD_INT 2
44498: PUSH
44499: EMPTY
44500: LIST
44501: LIST
44502: PUSH
44503: LD_INT 1
44505: NEG
44506: PUSH
44507: LD_INT 1
44509: PUSH
44510: EMPTY
44511: LIST
44512: LIST
44513: PUSH
44514: LD_INT 2
44516: NEG
44517: PUSH
44518: LD_INT 0
44520: PUSH
44521: EMPTY
44522: LIST
44523: LIST
44524: PUSH
44525: LD_INT 2
44527: NEG
44528: PUSH
44529: LD_INT 1
44531: NEG
44532: PUSH
44533: EMPTY
44534: LIST
44535: LIST
44536: PUSH
44537: LD_INT 2
44539: NEG
44540: PUSH
44541: LD_INT 2
44543: NEG
44544: PUSH
44545: EMPTY
44546: LIST
44547: LIST
44548: PUSH
44549: EMPTY
44550: LIST
44551: LIST
44552: LIST
44553: LIST
44554: LIST
44555: LIST
44556: LIST
44557: LIST
44558: LIST
44559: LIST
44560: LIST
44561: LIST
44562: LIST
44563: LIST
44564: LIST
44565: LIST
44566: LIST
44567: LIST
44568: LIST
44569: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
44570: LD_ADDR_VAR 0 59
44574: PUSH
44575: LD_INT 0
44577: PUSH
44578: LD_INT 0
44580: PUSH
44581: EMPTY
44582: LIST
44583: LIST
44584: PUSH
44585: LD_INT 0
44587: PUSH
44588: LD_INT 1
44590: NEG
44591: PUSH
44592: EMPTY
44593: LIST
44594: LIST
44595: PUSH
44596: LD_INT 1
44598: PUSH
44599: LD_INT 0
44601: PUSH
44602: EMPTY
44603: LIST
44604: LIST
44605: PUSH
44606: LD_INT 1
44608: PUSH
44609: LD_INT 1
44611: PUSH
44612: EMPTY
44613: LIST
44614: LIST
44615: PUSH
44616: LD_INT 0
44618: PUSH
44619: LD_INT 1
44621: PUSH
44622: EMPTY
44623: LIST
44624: LIST
44625: PUSH
44626: LD_INT 1
44628: NEG
44629: PUSH
44630: LD_INT 0
44632: PUSH
44633: EMPTY
44634: LIST
44635: LIST
44636: PUSH
44637: LD_INT 1
44639: NEG
44640: PUSH
44641: LD_INT 1
44643: NEG
44644: PUSH
44645: EMPTY
44646: LIST
44647: LIST
44648: PUSH
44649: EMPTY
44650: LIST
44651: LIST
44652: LIST
44653: LIST
44654: LIST
44655: LIST
44656: LIST
44657: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
44658: LD_ADDR_VAR 0 60
44662: PUSH
44663: LD_INT 0
44665: PUSH
44666: LD_INT 0
44668: PUSH
44669: EMPTY
44670: LIST
44671: LIST
44672: PUSH
44673: LD_INT 0
44675: PUSH
44676: LD_INT 1
44678: NEG
44679: PUSH
44680: EMPTY
44681: LIST
44682: LIST
44683: PUSH
44684: LD_INT 1
44686: PUSH
44687: LD_INT 0
44689: PUSH
44690: EMPTY
44691: LIST
44692: LIST
44693: PUSH
44694: LD_INT 1
44696: PUSH
44697: LD_INT 1
44699: PUSH
44700: EMPTY
44701: LIST
44702: LIST
44703: PUSH
44704: LD_INT 0
44706: PUSH
44707: LD_INT 1
44709: PUSH
44710: EMPTY
44711: LIST
44712: LIST
44713: PUSH
44714: LD_INT 1
44716: NEG
44717: PUSH
44718: LD_INT 0
44720: PUSH
44721: EMPTY
44722: LIST
44723: LIST
44724: PUSH
44725: LD_INT 1
44727: NEG
44728: PUSH
44729: LD_INT 1
44731: NEG
44732: PUSH
44733: EMPTY
44734: LIST
44735: LIST
44736: PUSH
44737: EMPTY
44738: LIST
44739: LIST
44740: LIST
44741: LIST
44742: LIST
44743: LIST
44744: LIST
44745: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
44746: LD_ADDR_VAR 0 61
44750: PUSH
44751: LD_INT 0
44753: PUSH
44754: LD_INT 0
44756: PUSH
44757: EMPTY
44758: LIST
44759: LIST
44760: PUSH
44761: LD_INT 0
44763: PUSH
44764: LD_INT 1
44766: NEG
44767: PUSH
44768: EMPTY
44769: LIST
44770: LIST
44771: PUSH
44772: LD_INT 1
44774: PUSH
44775: LD_INT 0
44777: PUSH
44778: EMPTY
44779: LIST
44780: LIST
44781: PUSH
44782: LD_INT 1
44784: PUSH
44785: LD_INT 1
44787: PUSH
44788: EMPTY
44789: LIST
44790: LIST
44791: PUSH
44792: LD_INT 0
44794: PUSH
44795: LD_INT 1
44797: PUSH
44798: EMPTY
44799: LIST
44800: LIST
44801: PUSH
44802: LD_INT 1
44804: NEG
44805: PUSH
44806: LD_INT 0
44808: PUSH
44809: EMPTY
44810: LIST
44811: LIST
44812: PUSH
44813: LD_INT 1
44815: NEG
44816: PUSH
44817: LD_INT 1
44819: NEG
44820: PUSH
44821: EMPTY
44822: LIST
44823: LIST
44824: PUSH
44825: EMPTY
44826: LIST
44827: LIST
44828: LIST
44829: LIST
44830: LIST
44831: LIST
44832: LIST
44833: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
44834: LD_ADDR_VAR 0 62
44838: PUSH
44839: LD_INT 0
44841: PUSH
44842: LD_INT 0
44844: PUSH
44845: EMPTY
44846: LIST
44847: LIST
44848: PUSH
44849: LD_INT 0
44851: PUSH
44852: LD_INT 1
44854: NEG
44855: PUSH
44856: EMPTY
44857: LIST
44858: LIST
44859: PUSH
44860: LD_INT 1
44862: PUSH
44863: LD_INT 0
44865: PUSH
44866: EMPTY
44867: LIST
44868: LIST
44869: PUSH
44870: LD_INT 1
44872: PUSH
44873: LD_INT 1
44875: PUSH
44876: EMPTY
44877: LIST
44878: LIST
44879: PUSH
44880: LD_INT 0
44882: PUSH
44883: LD_INT 1
44885: PUSH
44886: EMPTY
44887: LIST
44888: LIST
44889: PUSH
44890: LD_INT 1
44892: NEG
44893: PUSH
44894: LD_INT 0
44896: PUSH
44897: EMPTY
44898: LIST
44899: LIST
44900: PUSH
44901: LD_INT 1
44903: NEG
44904: PUSH
44905: LD_INT 1
44907: NEG
44908: PUSH
44909: EMPTY
44910: LIST
44911: LIST
44912: PUSH
44913: EMPTY
44914: LIST
44915: LIST
44916: LIST
44917: LIST
44918: LIST
44919: LIST
44920: LIST
44921: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
44922: LD_ADDR_VAR 0 63
44926: PUSH
44927: LD_INT 0
44929: PUSH
44930: LD_INT 0
44932: PUSH
44933: EMPTY
44934: LIST
44935: LIST
44936: PUSH
44937: LD_INT 0
44939: PUSH
44940: LD_INT 1
44942: NEG
44943: PUSH
44944: EMPTY
44945: LIST
44946: LIST
44947: PUSH
44948: LD_INT 1
44950: PUSH
44951: LD_INT 0
44953: PUSH
44954: EMPTY
44955: LIST
44956: LIST
44957: PUSH
44958: LD_INT 1
44960: PUSH
44961: LD_INT 1
44963: PUSH
44964: EMPTY
44965: LIST
44966: LIST
44967: PUSH
44968: LD_INT 0
44970: PUSH
44971: LD_INT 1
44973: PUSH
44974: EMPTY
44975: LIST
44976: LIST
44977: PUSH
44978: LD_INT 1
44980: NEG
44981: PUSH
44982: LD_INT 0
44984: PUSH
44985: EMPTY
44986: LIST
44987: LIST
44988: PUSH
44989: LD_INT 1
44991: NEG
44992: PUSH
44993: LD_INT 1
44995: NEG
44996: PUSH
44997: EMPTY
44998: LIST
44999: LIST
45000: PUSH
45001: EMPTY
45002: LIST
45003: LIST
45004: LIST
45005: LIST
45006: LIST
45007: LIST
45008: LIST
45009: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
45010: LD_ADDR_VAR 0 64
45014: PUSH
45015: LD_INT 0
45017: PUSH
45018: LD_INT 0
45020: PUSH
45021: EMPTY
45022: LIST
45023: LIST
45024: PUSH
45025: LD_INT 0
45027: PUSH
45028: LD_INT 1
45030: NEG
45031: PUSH
45032: EMPTY
45033: LIST
45034: LIST
45035: PUSH
45036: LD_INT 1
45038: PUSH
45039: LD_INT 0
45041: PUSH
45042: EMPTY
45043: LIST
45044: LIST
45045: PUSH
45046: LD_INT 1
45048: PUSH
45049: LD_INT 1
45051: PUSH
45052: EMPTY
45053: LIST
45054: LIST
45055: PUSH
45056: LD_INT 0
45058: PUSH
45059: LD_INT 1
45061: PUSH
45062: EMPTY
45063: LIST
45064: LIST
45065: PUSH
45066: LD_INT 1
45068: NEG
45069: PUSH
45070: LD_INT 0
45072: PUSH
45073: EMPTY
45074: LIST
45075: LIST
45076: PUSH
45077: LD_INT 1
45079: NEG
45080: PUSH
45081: LD_INT 1
45083: NEG
45084: PUSH
45085: EMPTY
45086: LIST
45087: LIST
45088: PUSH
45089: EMPTY
45090: LIST
45091: LIST
45092: LIST
45093: LIST
45094: LIST
45095: LIST
45096: LIST
45097: ST_TO_ADDR
// end ; 1 :
45098: GO 50995
45100: LD_INT 1
45102: DOUBLE
45103: EQUAL
45104: IFTRUE 45108
45106: GO 47731
45108: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
45109: LD_ADDR_VAR 0 11
45113: PUSH
45114: LD_INT 1
45116: NEG
45117: PUSH
45118: LD_INT 3
45120: NEG
45121: PUSH
45122: EMPTY
45123: LIST
45124: LIST
45125: PUSH
45126: LD_INT 0
45128: PUSH
45129: LD_INT 3
45131: NEG
45132: PUSH
45133: EMPTY
45134: LIST
45135: LIST
45136: PUSH
45137: LD_INT 1
45139: PUSH
45140: LD_INT 2
45142: NEG
45143: PUSH
45144: EMPTY
45145: LIST
45146: LIST
45147: PUSH
45148: EMPTY
45149: LIST
45150: LIST
45151: LIST
45152: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
45153: LD_ADDR_VAR 0 12
45157: PUSH
45158: LD_INT 2
45160: PUSH
45161: LD_INT 1
45163: NEG
45164: PUSH
45165: EMPTY
45166: LIST
45167: LIST
45168: PUSH
45169: LD_INT 3
45171: PUSH
45172: LD_INT 0
45174: PUSH
45175: EMPTY
45176: LIST
45177: LIST
45178: PUSH
45179: LD_INT 3
45181: PUSH
45182: LD_INT 1
45184: PUSH
45185: EMPTY
45186: LIST
45187: LIST
45188: PUSH
45189: EMPTY
45190: LIST
45191: LIST
45192: LIST
45193: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
45194: LD_ADDR_VAR 0 13
45198: PUSH
45199: LD_INT 3
45201: PUSH
45202: LD_INT 2
45204: PUSH
45205: EMPTY
45206: LIST
45207: LIST
45208: PUSH
45209: LD_INT 3
45211: PUSH
45212: LD_INT 3
45214: PUSH
45215: EMPTY
45216: LIST
45217: LIST
45218: PUSH
45219: LD_INT 2
45221: PUSH
45222: LD_INT 3
45224: PUSH
45225: EMPTY
45226: LIST
45227: LIST
45228: PUSH
45229: EMPTY
45230: LIST
45231: LIST
45232: LIST
45233: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
45234: LD_ADDR_VAR 0 14
45238: PUSH
45239: LD_INT 1
45241: PUSH
45242: LD_INT 3
45244: PUSH
45245: EMPTY
45246: LIST
45247: LIST
45248: PUSH
45249: LD_INT 0
45251: PUSH
45252: LD_INT 3
45254: PUSH
45255: EMPTY
45256: LIST
45257: LIST
45258: PUSH
45259: LD_INT 1
45261: NEG
45262: PUSH
45263: LD_INT 2
45265: PUSH
45266: EMPTY
45267: LIST
45268: LIST
45269: PUSH
45270: EMPTY
45271: LIST
45272: LIST
45273: LIST
45274: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
45275: LD_ADDR_VAR 0 15
45279: PUSH
45280: LD_INT 2
45282: NEG
45283: PUSH
45284: LD_INT 1
45286: PUSH
45287: EMPTY
45288: LIST
45289: LIST
45290: PUSH
45291: LD_INT 3
45293: NEG
45294: PUSH
45295: LD_INT 0
45297: PUSH
45298: EMPTY
45299: LIST
45300: LIST
45301: PUSH
45302: LD_INT 3
45304: NEG
45305: PUSH
45306: LD_INT 1
45308: NEG
45309: PUSH
45310: EMPTY
45311: LIST
45312: LIST
45313: PUSH
45314: EMPTY
45315: LIST
45316: LIST
45317: LIST
45318: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
45319: LD_ADDR_VAR 0 16
45323: PUSH
45324: LD_INT 2
45326: NEG
45327: PUSH
45328: LD_INT 3
45330: NEG
45331: PUSH
45332: EMPTY
45333: LIST
45334: LIST
45335: PUSH
45336: LD_INT 3
45338: NEG
45339: PUSH
45340: LD_INT 2
45342: NEG
45343: PUSH
45344: EMPTY
45345: LIST
45346: LIST
45347: PUSH
45348: LD_INT 3
45350: NEG
45351: PUSH
45352: LD_INT 3
45354: NEG
45355: PUSH
45356: EMPTY
45357: LIST
45358: LIST
45359: PUSH
45360: EMPTY
45361: LIST
45362: LIST
45363: LIST
45364: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
45365: LD_ADDR_VAR 0 17
45369: PUSH
45370: LD_INT 1
45372: NEG
45373: PUSH
45374: LD_INT 3
45376: NEG
45377: PUSH
45378: EMPTY
45379: LIST
45380: LIST
45381: PUSH
45382: LD_INT 0
45384: PUSH
45385: LD_INT 3
45387: NEG
45388: PUSH
45389: EMPTY
45390: LIST
45391: LIST
45392: PUSH
45393: LD_INT 1
45395: PUSH
45396: LD_INT 2
45398: NEG
45399: PUSH
45400: EMPTY
45401: LIST
45402: LIST
45403: PUSH
45404: EMPTY
45405: LIST
45406: LIST
45407: LIST
45408: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
45409: LD_ADDR_VAR 0 18
45413: PUSH
45414: LD_INT 2
45416: PUSH
45417: LD_INT 1
45419: NEG
45420: PUSH
45421: EMPTY
45422: LIST
45423: LIST
45424: PUSH
45425: LD_INT 3
45427: PUSH
45428: LD_INT 0
45430: PUSH
45431: EMPTY
45432: LIST
45433: LIST
45434: PUSH
45435: LD_INT 3
45437: PUSH
45438: LD_INT 1
45440: PUSH
45441: EMPTY
45442: LIST
45443: LIST
45444: PUSH
45445: EMPTY
45446: LIST
45447: LIST
45448: LIST
45449: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
45450: LD_ADDR_VAR 0 19
45454: PUSH
45455: LD_INT 3
45457: PUSH
45458: LD_INT 2
45460: PUSH
45461: EMPTY
45462: LIST
45463: LIST
45464: PUSH
45465: LD_INT 3
45467: PUSH
45468: LD_INT 3
45470: PUSH
45471: EMPTY
45472: LIST
45473: LIST
45474: PUSH
45475: LD_INT 2
45477: PUSH
45478: LD_INT 3
45480: PUSH
45481: EMPTY
45482: LIST
45483: LIST
45484: PUSH
45485: EMPTY
45486: LIST
45487: LIST
45488: LIST
45489: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
45490: LD_ADDR_VAR 0 20
45494: PUSH
45495: LD_INT 1
45497: PUSH
45498: LD_INT 3
45500: PUSH
45501: EMPTY
45502: LIST
45503: LIST
45504: PUSH
45505: LD_INT 0
45507: PUSH
45508: LD_INT 3
45510: PUSH
45511: EMPTY
45512: LIST
45513: LIST
45514: PUSH
45515: LD_INT 1
45517: NEG
45518: PUSH
45519: LD_INT 2
45521: PUSH
45522: EMPTY
45523: LIST
45524: LIST
45525: PUSH
45526: EMPTY
45527: LIST
45528: LIST
45529: LIST
45530: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
45531: LD_ADDR_VAR 0 21
45535: PUSH
45536: LD_INT 2
45538: NEG
45539: PUSH
45540: LD_INT 1
45542: PUSH
45543: EMPTY
45544: LIST
45545: LIST
45546: PUSH
45547: LD_INT 3
45549: NEG
45550: PUSH
45551: LD_INT 0
45553: PUSH
45554: EMPTY
45555: LIST
45556: LIST
45557: PUSH
45558: LD_INT 3
45560: NEG
45561: PUSH
45562: LD_INT 1
45564: NEG
45565: PUSH
45566: EMPTY
45567: LIST
45568: LIST
45569: PUSH
45570: EMPTY
45571: LIST
45572: LIST
45573: LIST
45574: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
45575: LD_ADDR_VAR 0 22
45579: PUSH
45580: LD_INT 2
45582: NEG
45583: PUSH
45584: LD_INT 3
45586: NEG
45587: PUSH
45588: EMPTY
45589: LIST
45590: LIST
45591: PUSH
45592: LD_INT 3
45594: NEG
45595: PUSH
45596: LD_INT 2
45598: NEG
45599: PUSH
45600: EMPTY
45601: LIST
45602: LIST
45603: PUSH
45604: LD_INT 3
45606: NEG
45607: PUSH
45608: LD_INT 3
45610: NEG
45611: PUSH
45612: EMPTY
45613: LIST
45614: LIST
45615: PUSH
45616: EMPTY
45617: LIST
45618: LIST
45619: LIST
45620: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
45621: LD_ADDR_VAR 0 23
45625: PUSH
45626: LD_INT 0
45628: PUSH
45629: LD_INT 3
45631: NEG
45632: PUSH
45633: EMPTY
45634: LIST
45635: LIST
45636: PUSH
45637: LD_INT 1
45639: NEG
45640: PUSH
45641: LD_INT 4
45643: NEG
45644: PUSH
45645: EMPTY
45646: LIST
45647: LIST
45648: PUSH
45649: LD_INT 1
45651: PUSH
45652: LD_INT 3
45654: NEG
45655: PUSH
45656: EMPTY
45657: LIST
45658: LIST
45659: PUSH
45660: EMPTY
45661: LIST
45662: LIST
45663: LIST
45664: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
45665: LD_ADDR_VAR 0 24
45669: PUSH
45670: LD_INT 3
45672: PUSH
45673: LD_INT 0
45675: PUSH
45676: EMPTY
45677: LIST
45678: LIST
45679: PUSH
45680: LD_INT 3
45682: PUSH
45683: LD_INT 1
45685: NEG
45686: PUSH
45687: EMPTY
45688: LIST
45689: LIST
45690: PUSH
45691: LD_INT 4
45693: PUSH
45694: LD_INT 1
45696: PUSH
45697: EMPTY
45698: LIST
45699: LIST
45700: PUSH
45701: EMPTY
45702: LIST
45703: LIST
45704: LIST
45705: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
45706: LD_ADDR_VAR 0 25
45710: PUSH
45711: LD_INT 3
45713: PUSH
45714: LD_INT 3
45716: PUSH
45717: EMPTY
45718: LIST
45719: LIST
45720: PUSH
45721: LD_INT 4
45723: PUSH
45724: LD_INT 3
45726: PUSH
45727: EMPTY
45728: LIST
45729: LIST
45730: PUSH
45731: LD_INT 3
45733: PUSH
45734: LD_INT 4
45736: PUSH
45737: EMPTY
45738: LIST
45739: LIST
45740: PUSH
45741: EMPTY
45742: LIST
45743: LIST
45744: LIST
45745: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
45746: LD_ADDR_VAR 0 26
45750: PUSH
45751: LD_INT 0
45753: PUSH
45754: LD_INT 3
45756: PUSH
45757: EMPTY
45758: LIST
45759: LIST
45760: PUSH
45761: LD_INT 1
45763: PUSH
45764: LD_INT 4
45766: PUSH
45767: EMPTY
45768: LIST
45769: LIST
45770: PUSH
45771: LD_INT 1
45773: NEG
45774: PUSH
45775: LD_INT 3
45777: PUSH
45778: EMPTY
45779: LIST
45780: LIST
45781: PUSH
45782: EMPTY
45783: LIST
45784: LIST
45785: LIST
45786: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
45787: LD_ADDR_VAR 0 27
45791: PUSH
45792: LD_INT 3
45794: NEG
45795: PUSH
45796: LD_INT 0
45798: PUSH
45799: EMPTY
45800: LIST
45801: LIST
45802: PUSH
45803: LD_INT 3
45805: NEG
45806: PUSH
45807: LD_INT 1
45809: PUSH
45810: EMPTY
45811: LIST
45812: LIST
45813: PUSH
45814: LD_INT 4
45816: NEG
45817: PUSH
45818: LD_INT 1
45820: NEG
45821: PUSH
45822: EMPTY
45823: LIST
45824: LIST
45825: PUSH
45826: EMPTY
45827: LIST
45828: LIST
45829: LIST
45830: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
45831: LD_ADDR_VAR 0 28
45835: PUSH
45836: LD_INT 3
45838: NEG
45839: PUSH
45840: LD_INT 3
45842: NEG
45843: PUSH
45844: EMPTY
45845: LIST
45846: LIST
45847: PUSH
45848: LD_INT 3
45850: NEG
45851: PUSH
45852: LD_INT 4
45854: NEG
45855: PUSH
45856: EMPTY
45857: LIST
45858: LIST
45859: PUSH
45860: LD_INT 4
45862: NEG
45863: PUSH
45864: LD_INT 3
45866: NEG
45867: PUSH
45868: EMPTY
45869: LIST
45870: LIST
45871: PUSH
45872: EMPTY
45873: LIST
45874: LIST
45875: LIST
45876: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
45877: LD_ADDR_VAR 0 29
45881: PUSH
45882: LD_INT 1
45884: NEG
45885: PUSH
45886: LD_INT 3
45888: NEG
45889: PUSH
45890: EMPTY
45891: LIST
45892: LIST
45893: PUSH
45894: LD_INT 0
45896: PUSH
45897: LD_INT 3
45899: NEG
45900: PUSH
45901: EMPTY
45902: LIST
45903: LIST
45904: PUSH
45905: LD_INT 1
45907: PUSH
45908: LD_INT 2
45910: NEG
45911: PUSH
45912: EMPTY
45913: LIST
45914: LIST
45915: PUSH
45916: LD_INT 1
45918: NEG
45919: PUSH
45920: LD_INT 4
45922: NEG
45923: PUSH
45924: EMPTY
45925: LIST
45926: LIST
45927: PUSH
45928: LD_INT 0
45930: PUSH
45931: LD_INT 4
45933: NEG
45934: PUSH
45935: EMPTY
45936: LIST
45937: LIST
45938: PUSH
45939: LD_INT 1
45941: PUSH
45942: LD_INT 3
45944: NEG
45945: PUSH
45946: EMPTY
45947: LIST
45948: LIST
45949: PUSH
45950: LD_INT 1
45952: NEG
45953: PUSH
45954: LD_INT 5
45956: NEG
45957: PUSH
45958: EMPTY
45959: LIST
45960: LIST
45961: PUSH
45962: LD_INT 0
45964: PUSH
45965: LD_INT 5
45967: NEG
45968: PUSH
45969: EMPTY
45970: LIST
45971: LIST
45972: PUSH
45973: LD_INT 1
45975: PUSH
45976: LD_INT 4
45978: NEG
45979: PUSH
45980: EMPTY
45981: LIST
45982: LIST
45983: PUSH
45984: LD_INT 1
45986: NEG
45987: PUSH
45988: LD_INT 6
45990: NEG
45991: PUSH
45992: EMPTY
45993: LIST
45994: LIST
45995: PUSH
45996: LD_INT 0
45998: PUSH
45999: LD_INT 6
46001: NEG
46002: PUSH
46003: EMPTY
46004: LIST
46005: LIST
46006: PUSH
46007: LD_INT 1
46009: PUSH
46010: LD_INT 5
46012: NEG
46013: PUSH
46014: EMPTY
46015: LIST
46016: LIST
46017: PUSH
46018: EMPTY
46019: LIST
46020: LIST
46021: LIST
46022: LIST
46023: LIST
46024: LIST
46025: LIST
46026: LIST
46027: LIST
46028: LIST
46029: LIST
46030: LIST
46031: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
46032: LD_ADDR_VAR 0 30
46036: PUSH
46037: LD_INT 2
46039: PUSH
46040: LD_INT 1
46042: NEG
46043: PUSH
46044: EMPTY
46045: LIST
46046: LIST
46047: PUSH
46048: LD_INT 3
46050: PUSH
46051: LD_INT 0
46053: PUSH
46054: EMPTY
46055: LIST
46056: LIST
46057: PUSH
46058: LD_INT 3
46060: PUSH
46061: LD_INT 1
46063: PUSH
46064: EMPTY
46065: LIST
46066: LIST
46067: PUSH
46068: LD_INT 3
46070: PUSH
46071: LD_INT 1
46073: NEG
46074: PUSH
46075: EMPTY
46076: LIST
46077: LIST
46078: PUSH
46079: LD_INT 4
46081: PUSH
46082: LD_INT 0
46084: PUSH
46085: EMPTY
46086: LIST
46087: LIST
46088: PUSH
46089: LD_INT 4
46091: PUSH
46092: LD_INT 1
46094: PUSH
46095: EMPTY
46096: LIST
46097: LIST
46098: PUSH
46099: LD_INT 4
46101: PUSH
46102: LD_INT 1
46104: NEG
46105: PUSH
46106: EMPTY
46107: LIST
46108: LIST
46109: PUSH
46110: LD_INT 5
46112: PUSH
46113: LD_INT 0
46115: PUSH
46116: EMPTY
46117: LIST
46118: LIST
46119: PUSH
46120: LD_INT 5
46122: PUSH
46123: LD_INT 1
46125: PUSH
46126: EMPTY
46127: LIST
46128: LIST
46129: PUSH
46130: LD_INT 5
46132: PUSH
46133: LD_INT 1
46135: NEG
46136: PUSH
46137: EMPTY
46138: LIST
46139: LIST
46140: PUSH
46141: LD_INT 6
46143: PUSH
46144: LD_INT 0
46146: PUSH
46147: EMPTY
46148: LIST
46149: LIST
46150: PUSH
46151: LD_INT 6
46153: PUSH
46154: LD_INT 1
46156: PUSH
46157: EMPTY
46158: LIST
46159: LIST
46160: PUSH
46161: EMPTY
46162: LIST
46163: LIST
46164: LIST
46165: LIST
46166: LIST
46167: LIST
46168: LIST
46169: LIST
46170: LIST
46171: LIST
46172: LIST
46173: LIST
46174: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
46175: LD_ADDR_VAR 0 31
46179: PUSH
46180: LD_INT 3
46182: PUSH
46183: LD_INT 2
46185: PUSH
46186: EMPTY
46187: LIST
46188: LIST
46189: PUSH
46190: LD_INT 3
46192: PUSH
46193: LD_INT 3
46195: PUSH
46196: EMPTY
46197: LIST
46198: LIST
46199: PUSH
46200: LD_INT 2
46202: PUSH
46203: LD_INT 3
46205: PUSH
46206: EMPTY
46207: LIST
46208: LIST
46209: PUSH
46210: LD_INT 4
46212: PUSH
46213: LD_INT 3
46215: PUSH
46216: EMPTY
46217: LIST
46218: LIST
46219: PUSH
46220: LD_INT 4
46222: PUSH
46223: LD_INT 4
46225: PUSH
46226: EMPTY
46227: LIST
46228: LIST
46229: PUSH
46230: LD_INT 3
46232: PUSH
46233: LD_INT 4
46235: PUSH
46236: EMPTY
46237: LIST
46238: LIST
46239: PUSH
46240: LD_INT 5
46242: PUSH
46243: LD_INT 4
46245: PUSH
46246: EMPTY
46247: LIST
46248: LIST
46249: PUSH
46250: LD_INT 5
46252: PUSH
46253: LD_INT 5
46255: PUSH
46256: EMPTY
46257: LIST
46258: LIST
46259: PUSH
46260: LD_INT 4
46262: PUSH
46263: LD_INT 5
46265: PUSH
46266: EMPTY
46267: LIST
46268: LIST
46269: PUSH
46270: LD_INT 6
46272: PUSH
46273: LD_INT 5
46275: PUSH
46276: EMPTY
46277: LIST
46278: LIST
46279: PUSH
46280: LD_INT 6
46282: PUSH
46283: LD_INT 6
46285: PUSH
46286: EMPTY
46287: LIST
46288: LIST
46289: PUSH
46290: LD_INT 5
46292: PUSH
46293: LD_INT 6
46295: PUSH
46296: EMPTY
46297: LIST
46298: LIST
46299: PUSH
46300: EMPTY
46301: LIST
46302: LIST
46303: LIST
46304: LIST
46305: LIST
46306: LIST
46307: LIST
46308: LIST
46309: LIST
46310: LIST
46311: LIST
46312: LIST
46313: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
46314: LD_ADDR_VAR 0 32
46318: PUSH
46319: LD_INT 1
46321: PUSH
46322: LD_INT 3
46324: PUSH
46325: EMPTY
46326: LIST
46327: LIST
46328: PUSH
46329: LD_INT 0
46331: PUSH
46332: LD_INT 3
46334: PUSH
46335: EMPTY
46336: LIST
46337: LIST
46338: PUSH
46339: LD_INT 1
46341: NEG
46342: PUSH
46343: LD_INT 2
46345: PUSH
46346: EMPTY
46347: LIST
46348: LIST
46349: PUSH
46350: LD_INT 1
46352: PUSH
46353: LD_INT 4
46355: PUSH
46356: EMPTY
46357: LIST
46358: LIST
46359: PUSH
46360: LD_INT 0
46362: PUSH
46363: LD_INT 4
46365: PUSH
46366: EMPTY
46367: LIST
46368: LIST
46369: PUSH
46370: LD_INT 1
46372: NEG
46373: PUSH
46374: LD_INT 3
46376: PUSH
46377: EMPTY
46378: LIST
46379: LIST
46380: PUSH
46381: LD_INT 1
46383: PUSH
46384: LD_INT 5
46386: PUSH
46387: EMPTY
46388: LIST
46389: LIST
46390: PUSH
46391: LD_INT 0
46393: PUSH
46394: LD_INT 5
46396: PUSH
46397: EMPTY
46398: LIST
46399: LIST
46400: PUSH
46401: LD_INT 1
46403: NEG
46404: PUSH
46405: LD_INT 4
46407: PUSH
46408: EMPTY
46409: LIST
46410: LIST
46411: PUSH
46412: LD_INT 1
46414: PUSH
46415: LD_INT 6
46417: PUSH
46418: EMPTY
46419: LIST
46420: LIST
46421: PUSH
46422: LD_INT 0
46424: PUSH
46425: LD_INT 6
46427: PUSH
46428: EMPTY
46429: LIST
46430: LIST
46431: PUSH
46432: LD_INT 1
46434: NEG
46435: PUSH
46436: LD_INT 5
46438: PUSH
46439: EMPTY
46440: LIST
46441: LIST
46442: PUSH
46443: EMPTY
46444: LIST
46445: LIST
46446: LIST
46447: LIST
46448: LIST
46449: LIST
46450: LIST
46451: LIST
46452: LIST
46453: LIST
46454: LIST
46455: LIST
46456: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
46457: LD_ADDR_VAR 0 33
46461: PUSH
46462: LD_INT 2
46464: NEG
46465: PUSH
46466: LD_INT 1
46468: PUSH
46469: EMPTY
46470: LIST
46471: LIST
46472: PUSH
46473: LD_INT 3
46475: NEG
46476: PUSH
46477: LD_INT 0
46479: PUSH
46480: EMPTY
46481: LIST
46482: LIST
46483: PUSH
46484: LD_INT 3
46486: NEG
46487: PUSH
46488: LD_INT 1
46490: NEG
46491: PUSH
46492: EMPTY
46493: LIST
46494: LIST
46495: PUSH
46496: LD_INT 3
46498: NEG
46499: PUSH
46500: LD_INT 1
46502: PUSH
46503: EMPTY
46504: LIST
46505: LIST
46506: PUSH
46507: LD_INT 4
46509: NEG
46510: PUSH
46511: LD_INT 0
46513: PUSH
46514: EMPTY
46515: LIST
46516: LIST
46517: PUSH
46518: LD_INT 4
46520: NEG
46521: PUSH
46522: LD_INT 1
46524: NEG
46525: PUSH
46526: EMPTY
46527: LIST
46528: LIST
46529: PUSH
46530: LD_INT 4
46532: NEG
46533: PUSH
46534: LD_INT 1
46536: PUSH
46537: EMPTY
46538: LIST
46539: LIST
46540: PUSH
46541: LD_INT 5
46543: NEG
46544: PUSH
46545: LD_INT 0
46547: PUSH
46548: EMPTY
46549: LIST
46550: LIST
46551: PUSH
46552: LD_INT 5
46554: NEG
46555: PUSH
46556: LD_INT 1
46558: NEG
46559: PUSH
46560: EMPTY
46561: LIST
46562: LIST
46563: PUSH
46564: LD_INT 5
46566: NEG
46567: PUSH
46568: LD_INT 1
46570: PUSH
46571: EMPTY
46572: LIST
46573: LIST
46574: PUSH
46575: LD_INT 6
46577: NEG
46578: PUSH
46579: LD_INT 0
46581: PUSH
46582: EMPTY
46583: LIST
46584: LIST
46585: PUSH
46586: LD_INT 6
46588: NEG
46589: PUSH
46590: LD_INT 1
46592: NEG
46593: PUSH
46594: EMPTY
46595: LIST
46596: LIST
46597: PUSH
46598: EMPTY
46599: LIST
46600: LIST
46601: LIST
46602: LIST
46603: LIST
46604: LIST
46605: LIST
46606: LIST
46607: LIST
46608: LIST
46609: LIST
46610: LIST
46611: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
46612: LD_ADDR_VAR 0 34
46616: PUSH
46617: LD_INT 2
46619: NEG
46620: PUSH
46621: LD_INT 3
46623: NEG
46624: PUSH
46625: EMPTY
46626: LIST
46627: LIST
46628: PUSH
46629: LD_INT 3
46631: NEG
46632: PUSH
46633: LD_INT 2
46635: NEG
46636: PUSH
46637: EMPTY
46638: LIST
46639: LIST
46640: PUSH
46641: LD_INT 3
46643: NEG
46644: PUSH
46645: LD_INT 3
46647: NEG
46648: PUSH
46649: EMPTY
46650: LIST
46651: LIST
46652: PUSH
46653: LD_INT 3
46655: NEG
46656: PUSH
46657: LD_INT 4
46659: NEG
46660: PUSH
46661: EMPTY
46662: LIST
46663: LIST
46664: PUSH
46665: LD_INT 4
46667: NEG
46668: PUSH
46669: LD_INT 3
46671: NEG
46672: PUSH
46673: EMPTY
46674: LIST
46675: LIST
46676: PUSH
46677: LD_INT 4
46679: NEG
46680: PUSH
46681: LD_INT 4
46683: NEG
46684: PUSH
46685: EMPTY
46686: LIST
46687: LIST
46688: PUSH
46689: LD_INT 4
46691: NEG
46692: PUSH
46693: LD_INT 5
46695: NEG
46696: PUSH
46697: EMPTY
46698: LIST
46699: LIST
46700: PUSH
46701: LD_INT 5
46703: NEG
46704: PUSH
46705: LD_INT 4
46707: NEG
46708: PUSH
46709: EMPTY
46710: LIST
46711: LIST
46712: PUSH
46713: LD_INT 5
46715: NEG
46716: PUSH
46717: LD_INT 5
46719: NEG
46720: PUSH
46721: EMPTY
46722: LIST
46723: LIST
46724: PUSH
46725: LD_INT 5
46727: NEG
46728: PUSH
46729: LD_INT 6
46731: NEG
46732: PUSH
46733: EMPTY
46734: LIST
46735: LIST
46736: PUSH
46737: LD_INT 6
46739: NEG
46740: PUSH
46741: LD_INT 5
46743: NEG
46744: PUSH
46745: EMPTY
46746: LIST
46747: LIST
46748: PUSH
46749: LD_INT 6
46751: NEG
46752: PUSH
46753: LD_INT 6
46755: NEG
46756: PUSH
46757: EMPTY
46758: LIST
46759: LIST
46760: PUSH
46761: EMPTY
46762: LIST
46763: LIST
46764: LIST
46765: LIST
46766: LIST
46767: LIST
46768: LIST
46769: LIST
46770: LIST
46771: LIST
46772: LIST
46773: LIST
46774: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
46775: LD_ADDR_VAR 0 41
46779: PUSH
46780: LD_INT 0
46782: PUSH
46783: LD_INT 2
46785: NEG
46786: PUSH
46787: EMPTY
46788: LIST
46789: LIST
46790: PUSH
46791: LD_INT 1
46793: NEG
46794: PUSH
46795: LD_INT 3
46797: NEG
46798: PUSH
46799: EMPTY
46800: LIST
46801: LIST
46802: PUSH
46803: LD_INT 1
46805: PUSH
46806: LD_INT 2
46808: NEG
46809: PUSH
46810: EMPTY
46811: LIST
46812: LIST
46813: PUSH
46814: EMPTY
46815: LIST
46816: LIST
46817: LIST
46818: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
46819: LD_ADDR_VAR 0 42
46823: PUSH
46824: LD_INT 2
46826: PUSH
46827: LD_INT 0
46829: PUSH
46830: EMPTY
46831: LIST
46832: LIST
46833: PUSH
46834: LD_INT 2
46836: PUSH
46837: LD_INT 1
46839: NEG
46840: PUSH
46841: EMPTY
46842: LIST
46843: LIST
46844: PUSH
46845: LD_INT 3
46847: PUSH
46848: LD_INT 1
46850: PUSH
46851: EMPTY
46852: LIST
46853: LIST
46854: PUSH
46855: EMPTY
46856: LIST
46857: LIST
46858: LIST
46859: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
46860: LD_ADDR_VAR 0 43
46864: PUSH
46865: LD_INT 2
46867: PUSH
46868: LD_INT 2
46870: PUSH
46871: EMPTY
46872: LIST
46873: LIST
46874: PUSH
46875: LD_INT 3
46877: PUSH
46878: LD_INT 2
46880: PUSH
46881: EMPTY
46882: LIST
46883: LIST
46884: PUSH
46885: LD_INT 2
46887: PUSH
46888: LD_INT 3
46890: PUSH
46891: EMPTY
46892: LIST
46893: LIST
46894: PUSH
46895: EMPTY
46896: LIST
46897: LIST
46898: LIST
46899: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
46900: LD_ADDR_VAR 0 44
46904: PUSH
46905: LD_INT 0
46907: PUSH
46908: LD_INT 2
46910: PUSH
46911: EMPTY
46912: LIST
46913: LIST
46914: PUSH
46915: LD_INT 1
46917: PUSH
46918: LD_INT 3
46920: PUSH
46921: EMPTY
46922: LIST
46923: LIST
46924: PUSH
46925: LD_INT 1
46927: NEG
46928: PUSH
46929: LD_INT 2
46931: PUSH
46932: EMPTY
46933: LIST
46934: LIST
46935: PUSH
46936: EMPTY
46937: LIST
46938: LIST
46939: LIST
46940: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
46941: LD_ADDR_VAR 0 45
46945: PUSH
46946: LD_INT 2
46948: NEG
46949: PUSH
46950: LD_INT 0
46952: PUSH
46953: EMPTY
46954: LIST
46955: LIST
46956: PUSH
46957: LD_INT 2
46959: NEG
46960: PUSH
46961: LD_INT 1
46963: PUSH
46964: EMPTY
46965: LIST
46966: LIST
46967: PUSH
46968: LD_INT 3
46970: NEG
46971: PUSH
46972: LD_INT 1
46974: NEG
46975: PUSH
46976: EMPTY
46977: LIST
46978: LIST
46979: PUSH
46980: EMPTY
46981: LIST
46982: LIST
46983: LIST
46984: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
46985: LD_ADDR_VAR 0 46
46989: PUSH
46990: LD_INT 2
46992: NEG
46993: PUSH
46994: LD_INT 2
46996: NEG
46997: PUSH
46998: EMPTY
46999: LIST
47000: LIST
47001: PUSH
47002: LD_INT 2
47004: NEG
47005: PUSH
47006: LD_INT 3
47008: NEG
47009: PUSH
47010: EMPTY
47011: LIST
47012: LIST
47013: PUSH
47014: LD_INT 3
47016: NEG
47017: PUSH
47018: LD_INT 2
47020: NEG
47021: PUSH
47022: EMPTY
47023: LIST
47024: LIST
47025: PUSH
47026: EMPTY
47027: LIST
47028: LIST
47029: LIST
47030: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
47031: LD_ADDR_VAR 0 47
47035: PUSH
47036: LD_INT 2
47038: NEG
47039: PUSH
47040: LD_INT 3
47042: NEG
47043: PUSH
47044: EMPTY
47045: LIST
47046: LIST
47047: PUSH
47048: LD_INT 1
47050: NEG
47051: PUSH
47052: LD_INT 3
47054: NEG
47055: PUSH
47056: EMPTY
47057: LIST
47058: LIST
47059: PUSH
47060: EMPTY
47061: LIST
47062: LIST
47063: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
47064: LD_ADDR_VAR 0 48
47068: PUSH
47069: LD_INT 1
47071: PUSH
47072: LD_INT 2
47074: NEG
47075: PUSH
47076: EMPTY
47077: LIST
47078: LIST
47079: PUSH
47080: LD_INT 2
47082: PUSH
47083: LD_INT 1
47085: NEG
47086: PUSH
47087: EMPTY
47088: LIST
47089: LIST
47090: PUSH
47091: EMPTY
47092: LIST
47093: LIST
47094: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
47095: LD_ADDR_VAR 0 49
47099: PUSH
47100: LD_INT 3
47102: PUSH
47103: LD_INT 1
47105: PUSH
47106: EMPTY
47107: LIST
47108: LIST
47109: PUSH
47110: LD_INT 3
47112: PUSH
47113: LD_INT 2
47115: PUSH
47116: EMPTY
47117: LIST
47118: LIST
47119: PUSH
47120: EMPTY
47121: LIST
47122: LIST
47123: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
47124: LD_ADDR_VAR 0 50
47128: PUSH
47129: LD_INT 2
47131: PUSH
47132: LD_INT 3
47134: PUSH
47135: EMPTY
47136: LIST
47137: LIST
47138: PUSH
47139: LD_INT 1
47141: PUSH
47142: LD_INT 3
47144: PUSH
47145: EMPTY
47146: LIST
47147: LIST
47148: PUSH
47149: EMPTY
47150: LIST
47151: LIST
47152: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
47153: LD_ADDR_VAR 0 51
47157: PUSH
47158: LD_INT 1
47160: NEG
47161: PUSH
47162: LD_INT 2
47164: PUSH
47165: EMPTY
47166: LIST
47167: LIST
47168: PUSH
47169: LD_INT 2
47171: NEG
47172: PUSH
47173: LD_INT 1
47175: PUSH
47176: EMPTY
47177: LIST
47178: LIST
47179: PUSH
47180: EMPTY
47181: LIST
47182: LIST
47183: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
47184: LD_ADDR_VAR 0 52
47188: PUSH
47189: LD_INT 3
47191: NEG
47192: PUSH
47193: LD_INT 1
47195: NEG
47196: PUSH
47197: EMPTY
47198: LIST
47199: LIST
47200: PUSH
47201: LD_INT 3
47203: NEG
47204: PUSH
47205: LD_INT 2
47207: NEG
47208: PUSH
47209: EMPTY
47210: LIST
47211: LIST
47212: PUSH
47213: EMPTY
47214: LIST
47215: LIST
47216: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
47217: LD_ADDR_VAR 0 53
47221: PUSH
47222: LD_INT 1
47224: NEG
47225: PUSH
47226: LD_INT 3
47228: NEG
47229: PUSH
47230: EMPTY
47231: LIST
47232: LIST
47233: PUSH
47234: LD_INT 0
47236: PUSH
47237: LD_INT 3
47239: NEG
47240: PUSH
47241: EMPTY
47242: LIST
47243: LIST
47244: PUSH
47245: LD_INT 1
47247: PUSH
47248: LD_INT 2
47250: NEG
47251: PUSH
47252: EMPTY
47253: LIST
47254: LIST
47255: PUSH
47256: EMPTY
47257: LIST
47258: LIST
47259: LIST
47260: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
47261: LD_ADDR_VAR 0 54
47265: PUSH
47266: LD_INT 2
47268: PUSH
47269: LD_INT 1
47271: NEG
47272: PUSH
47273: EMPTY
47274: LIST
47275: LIST
47276: PUSH
47277: LD_INT 3
47279: PUSH
47280: LD_INT 0
47282: PUSH
47283: EMPTY
47284: LIST
47285: LIST
47286: PUSH
47287: LD_INT 3
47289: PUSH
47290: LD_INT 1
47292: PUSH
47293: EMPTY
47294: LIST
47295: LIST
47296: PUSH
47297: EMPTY
47298: LIST
47299: LIST
47300: LIST
47301: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
47302: LD_ADDR_VAR 0 55
47306: PUSH
47307: LD_INT 3
47309: PUSH
47310: LD_INT 2
47312: PUSH
47313: EMPTY
47314: LIST
47315: LIST
47316: PUSH
47317: LD_INT 3
47319: PUSH
47320: LD_INT 3
47322: PUSH
47323: EMPTY
47324: LIST
47325: LIST
47326: PUSH
47327: LD_INT 2
47329: PUSH
47330: LD_INT 3
47332: PUSH
47333: EMPTY
47334: LIST
47335: LIST
47336: PUSH
47337: EMPTY
47338: LIST
47339: LIST
47340: LIST
47341: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
47342: LD_ADDR_VAR 0 56
47346: PUSH
47347: LD_INT 1
47349: PUSH
47350: LD_INT 3
47352: PUSH
47353: EMPTY
47354: LIST
47355: LIST
47356: PUSH
47357: LD_INT 0
47359: PUSH
47360: LD_INT 3
47362: PUSH
47363: EMPTY
47364: LIST
47365: LIST
47366: PUSH
47367: LD_INT 1
47369: NEG
47370: PUSH
47371: LD_INT 2
47373: PUSH
47374: EMPTY
47375: LIST
47376: LIST
47377: PUSH
47378: EMPTY
47379: LIST
47380: LIST
47381: LIST
47382: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
47383: LD_ADDR_VAR 0 57
47387: PUSH
47388: LD_INT 2
47390: NEG
47391: PUSH
47392: LD_INT 1
47394: PUSH
47395: EMPTY
47396: LIST
47397: LIST
47398: PUSH
47399: LD_INT 3
47401: NEG
47402: PUSH
47403: LD_INT 0
47405: PUSH
47406: EMPTY
47407: LIST
47408: LIST
47409: PUSH
47410: LD_INT 3
47412: NEG
47413: PUSH
47414: LD_INT 1
47416: NEG
47417: PUSH
47418: EMPTY
47419: LIST
47420: LIST
47421: PUSH
47422: EMPTY
47423: LIST
47424: LIST
47425: LIST
47426: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
47427: LD_ADDR_VAR 0 58
47431: PUSH
47432: LD_INT 2
47434: NEG
47435: PUSH
47436: LD_INT 3
47438: NEG
47439: PUSH
47440: EMPTY
47441: LIST
47442: LIST
47443: PUSH
47444: LD_INT 3
47446: NEG
47447: PUSH
47448: LD_INT 2
47450: NEG
47451: PUSH
47452: EMPTY
47453: LIST
47454: LIST
47455: PUSH
47456: LD_INT 3
47458: NEG
47459: PUSH
47460: LD_INT 3
47462: NEG
47463: PUSH
47464: EMPTY
47465: LIST
47466: LIST
47467: PUSH
47468: EMPTY
47469: LIST
47470: LIST
47471: LIST
47472: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
47473: LD_ADDR_VAR 0 59
47477: PUSH
47478: LD_INT 1
47480: NEG
47481: PUSH
47482: LD_INT 2
47484: NEG
47485: PUSH
47486: EMPTY
47487: LIST
47488: LIST
47489: PUSH
47490: LD_INT 0
47492: PUSH
47493: LD_INT 2
47495: NEG
47496: PUSH
47497: EMPTY
47498: LIST
47499: LIST
47500: PUSH
47501: LD_INT 1
47503: PUSH
47504: LD_INT 1
47506: NEG
47507: PUSH
47508: EMPTY
47509: LIST
47510: LIST
47511: PUSH
47512: EMPTY
47513: LIST
47514: LIST
47515: LIST
47516: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
47517: LD_ADDR_VAR 0 60
47521: PUSH
47522: LD_INT 1
47524: PUSH
47525: LD_INT 1
47527: NEG
47528: PUSH
47529: EMPTY
47530: LIST
47531: LIST
47532: PUSH
47533: LD_INT 2
47535: PUSH
47536: LD_INT 0
47538: PUSH
47539: EMPTY
47540: LIST
47541: LIST
47542: PUSH
47543: LD_INT 2
47545: PUSH
47546: LD_INT 1
47548: PUSH
47549: EMPTY
47550: LIST
47551: LIST
47552: PUSH
47553: EMPTY
47554: LIST
47555: LIST
47556: LIST
47557: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
47558: LD_ADDR_VAR 0 61
47562: PUSH
47563: LD_INT 2
47565: PUSH
47566: LD_INT 1
47568: PUSH
47569: EMPTY
47570: LIST
47571: LIST
47572: PUSH
47573: LD_INT 2
47575: PUSH
47576: LD_INT 2
47578: PUSH
47579: EMPTY
47580: LIST
47581: LIST
47582: PUSH
47583: LD_INT 1
47585: PUSH
47586: LD_INT 2
47588: PUSH
47589: EMPTY
47590: LIST
47591: LIST
47592: PUSH
47593: EMPTY
47594: LIST
47595: LIST
47596: LIST
47597: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
47598: LD_ADDR_VAR 0 62
47602: PUSH
47603: LD_INT 1
47605: PUSH
47606: LD_INT 2
47608: PUSH
47609: EMPTY
47610: LIST
47611: LIST
47612: PUSH
47613: LD_INT 0
47615: PUSH
47616: LD_INT 2
47618: PUSH
47619: EMPTY
47620: LIST
47621: LIST
47622: PUSH
47623: LD_INT 1
47625: NEG
47626: PUSH
47627: LD_INT 1
47629: PUSH
47630: EMPTY
47631: LIST
47632: LIST
47633: PUSH
47634: EMPTY
47635: LIST
47636: LIST
47637: LIST
47638: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
47639: LD_ADDR_VAR 0 63
47643: PUSH
47644: LD_INT 1
47646: NEG
47647: PUSH
47648: LD_INT 1
47650: PUSH
47651: EMPTY
47652: LIST
47653: LIST
47654: PUSH
47655: LD_INT 2
47657: NEG
47658: PUSH
47659: LD_INT 0
47661: PUSH
47662: EMPTY
47663: LIST
47664: LIST
47665: PUSH
47666: LD_INT 2
47668: NEG
47669: PUSH
47670: LD_INT 1
47672: NEG
47673: PUSH
47674: EMPTY
47675: LIST
47676: LIST
47677: PUSH
47678: EMPTY
47679: LIST
47680: LIST
47681: LIST
47682: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
47683: LD_ADDR_VAR 0 64
47687: PUSH
47688: LD_INT 1
47690: NEG
47691: PUSH
47692: LD_INT 2
47694: NEG
47695: PUSH
47696: EMPTY
47697: LIST
47698: LIST
47699: PUSH
47700: LD_INT 2
47702: NEG
47703: PUSH
47704: LD_INT 1
47706: NEG
47707: PUSH
47708: EMPTY
47709: LIST
47710: LIST
47711: PUSH
47712: LD_INT 2
47714: NEG
47715: PUSH
47716: LD_INT 2
47718: NEG
47719: PUSH
47720: EMPTY
47721: LIST
47722: LIST
47723: PUSH
47724: EMPTY
47725: LIST
47726: LIST
47727: LIST
47728: ST_TO_ADDR
// end ; 2 :
47729: GO 50995
47731: LD_INT 2
47733: DOUBLE
47734: EQUAL
47735: IFTRUE 47739
47737: GO 50994
47739: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
47740: LD_ADDR_VAR 0 29
47744: PUSH
47745: LD_INT 4
47747: PUSH
47748: LD_INT 0
47750: PUSH
47751: EMPTY
47752: LIST
47753: LIST
47754: PUSH
47755: LD_INT 4
47757: PUSH
47758: LD_INT 1
47760: NEG
47761: PUSH
47762: EMPTY
47763: LIST
47764: LIST
47765: PUSH
47766: LD_INT 5
47768: PUSH
47769: LD_INT 0
47771: PUSH
47772: EMPTY
47773: LIST
47774: LIST
47775: PUSH
47776: LD_INT 5
47778: PUSH
47779: LD_INT 1
47781: PUSH
47782: EMPTY
47783: LIST
47784: LIST
47785: PUSH
47786: LD_INT 4
47788: PUSH
47789: LD_INT 1
47791: PUSH
47792: EMPTY
47793: LIST
47794: LIST
47795: PUSH
47796: LD_INT 3
47798: PUSH
47799: LD_INT 0
47801: PUSH
47802: EMPTY
47803: LIST
47804: LIST
47805: PUSH
47806: LD_INT 3
47808: PUSH
47809: LD_INT 1
47811: NEG
47812: PUSH
47813: EMPTY
47814: LIST
47815: LIST
47816: PUSH
47817: LD_INT 3
47819: PUSH
47820: LD_INT 2
47822: NEG
47823: PUSH
47824: EMPTY
47825: LIST
47826: LIST
47827: PUSH
47828: LD_INT 5
47830: PUSH
47831: LD_INT 2
47833: PUSH
47834: EMPTY
47835: LIST
47836: LIST
47837: PUSH
47838: LD_INT 3
47840: PUSH
47841: LD_INT 3
47843: PUSH
47844: EMPTY
47845: LIST
47846: LIST
47847: PUSH
47848: LD_INT 3
47850: PUSH
47851: LD_INT 2
47853: PUSH
47854: EMPTY
47855: LIST
47856: LIST
47857: PUSH
47858: LD_INT 4
47860: PUSH
47861: LD_INT 3
47863: PUSH
47864: EMPTY
47865: LIST
47866: LIST
47867: PUSH
47868: LD_INT 4
47870: PUSH
47871: LD_INT 4
47873: PUSH
47874: EMPTY
47875: LIST
47876: LIST
47877: PUSH
47878: LD_INT 3
47880: PUSH
47881: LD_INT 4
47883: PUSH
47884: EMPTY
47885: LIST
47886: LIST
47887: PUSH
47888: LD_INT 2
47890: PUSH
47891: LD_INT 3
47893: PUSH
47894: EMPTY
47895: LIST
47896: LIST
47897: PUSH
47898: LD_INT 2
47900: PUSH
47901: LD_INT 2
47903: PUSH
47904: EMPTY
47905: LIST
47906: LIST
47907: PUSH
47908: LD_INT 4
47910: PUSH
47911: LD_INT 2
47913: PUSH
47914: EMPTY
47915: LIST
47916: LIST
47917: PUSH
47918: LD_INT 2
47920: PUSH
47921: LD_INT 4
47923: PUSH
47924: EMPTY
47925: LIST
47926: LIST
47927: PUSH
47928: LD_INT 0
47930: PUSH
47931: LD_INT 4
47933: PUSH
47934: EMPTY
47935: LIST
47936: LIST
47937: PUSH
47938: LD_INT 0
47940: PUSH
47941: LD_INT 3
47943: PUSH
47944: EMPTY
47945: LIST
47946: LIST
47947: PUSH
47948: LD_INT 1
47950: PUSH
47951: LD_INT 4
47953: PUSH
47954: EMPTY
47955: LIST
47956: LIST
47957: PUSH
47958: LD_INT 1
47960: PUSH
47961: LD_INT 5
47963: PUSH
47964: EMPTY
47965: LIST
47966: LIST
47967: PUSH
47968: LD_INT 0
47970: PUSH
47971: LD_INT 5
47973: PUSH
47974: EMPTY
47975: LIST
47976: LIST
47977: PUSH
47978: LD_INT 1
47980: NEG
47981: PUSH
47982: LD_INT 4
47984: PUSH
47985: EMPTY
47986: LIST
47987: LIST
47988: PUSH
47989: LD_INT 1
47991: NEG
47992: PUSH
47993: LD_INT 3
47995: PUSH
47996: EMPTY
47997: LIST
47998: LIST
47999: PUSH
48000: LD_INT 2
48002: PUSH
48003: LD_INT 5
48005: PUSH
48006: EMPTY
48007: LIST
48008: LIST
48009: PUSH
48010: LD_INT 2
48012: NEG
48013: PUSH
48014: LD_INT 3
48016: PUSH
48017: EMPTY
48018: LIST
48019: LIST
48020: PUSH
48021: LD_INT 3
48023: NEG
48024: PUSH
48025: LD_INT 0
48027: PUSH
48028: EMPTY
48029: LIST
48030: LIST
48031: PUSH
48032: LD_INT 3
48034: NEG
48035: PUSH
48036: LD_INT 1
48038: NEG
48039: PUSH
48040: EMPTY
48041: LIST
48042: LIST
48043: PUSH
48044: LD_INT 2
48046: NEG
48047: PUSH
48048: LD_INT 0
48050: PUSH
48051: EMPTY
48052: LIST
48053: LIST
48054: PUSH
48055: LD_INT 2
48057: NEG
48058: PUSH
48059: LD_INT 1
48061: PUSH
48062: EMPTY
48063: LIST
48064: LIST
48065: PUSH
48066: LD_INT 3
48068: NEG
48069: PUSH
48070: LD_INT 1
48072: PUSH
48073: EMPTY
48074: LIST
48075: LIST
48076: PUSH
48077: LD_INT 4
48079: NEG
48080: PUSH
48081: LD_INT 0
48083: PUSH
48084: EMPTY
48085: LIST
48086: LIST
48087: PUSH
48088: LD_INT 4
48090: NEG
48091: PUSH
48092: LD_INT 1
48094: NEG
48095: PUSH
48096: EMPTY
48097: LIST
48098: LIST
48099: PUSH
48100: LD_INT 4
48102: NEG
48103: PUSH
48104: LD_INT 2
48106: NEG
48107: PUSH
48108: EMPTY
48109: LIST
48110: LIST
48111: PUSH
48112: LD_INT 2
48114: NEG
48115: PUSH
48116: LD_INT 2
48118: PUSH
48119: EMPTY
48120: LIST
48121: LIST
48122: PUSH
48123: LD_INT 4
48125: NEG
48126: PUSH
48127: LD_INT 4
48129: NEG
48130: PUSH
48131: EMPTY
48132: LIST
48133: LIST
48134: PUSH
48135: LD_INT 4
48137: NEG
48138: PUSH
48139: LD_INT 5
48141: NEG
48142: PUSH
48143: EMPTY
48144: LIST
48145: LIST
48146: PUSH
48147: LD_INT 3
48149: NEG
48150: PUSH
48151: LD_INT 4
48153: NEG
48154: PUSH
48155: EMPTY
48156: LIST
48157: LIST
48158: PUSH
48159: LD_INT 3
48161: NEG
48162: PUSH
48163: LD_INT 3
48165: NEG
48166: PUSH
48167: EMPTY
48168: LIST
48169: LIST
48170: PUSH
48171: LD_INT 4
48173: NEG
48174: PUSH
48175: LD_INT 3
48177: NEG
48178: PUSH
48179: EMPTY
48180: LIST
48181: LIST
48182: PUSH
48183: LD_INT 5
48185: NEG
48186: PUSH
48187: LD_INT 4
48189: NEG
48190: PUSH
48191: EMPTY
48192: LIST
48193: LIST
48194: PUSH
48195: LD_INT 5
48197: NEG
48198: PUSH
48199: LD_INT 5
48201: NEG
48202: PUSH
48203: EMPTY
48204: LIST
48205: LIST
48206: PUSH
48207: LD_INT 3
48209: NEG
48210: PUSH
48211: LD_INT 5
48213: NEG
48214: PUSH
48215: EMPTY
48216: LIST
48217: LIST
48218: PUSH
48219: LD_INT 5
48221: NEG
48222: PUSH
48223: LD_INT 3
48225: NEG
48226: PUSH
48227: EMPTY
48228: LIST
48229: LIST
48230: PUSH
48231: EMPTY
48232: LIST
48233: LIST
48234: LIST
48235: LIST
48236: LIST
48237: LIST
48238: LIST
48239: LIST
48240: LIST
48241: LIST
48242: LIST
48243: LIST
48244: LIST
48245: LIST
48246: LIST
48247: LIST
48248: LIST
48249: LIST
48250: LIST
48251: LIST
48252: LIST
48253: LIST
48254: LIST
48255: LIST
48256: LIST
48257: LIST
48258: LIST
48259: LIST
48260: LIST
48261: LIST
48262: LIST
48263: LIST
48264: LIST
48265: LIST
48266: LIST
48267: LIST
48268: LIST
48269: LIST
48270: LIST
48271: LIST
48272: LIST
48273: LIST
48274: LIST
48275: LIST
48276: LIST
48277: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
48278: LD_ADDR_VAR 0 30
48282: PUSH
48283: LD_INT 4
48285: PUSH
48286: LD_INT 4
48288: PUSH
48289: EMPTY
48290: LIST
48291: LIST
48292: PUSH
48293: LD_INT 4
48295: PUSH
48296: LD_INT 3
48298: PUSH
48299: EMPTY
48300: LIST
48301: LIST
48302: PUSH
48303: LD_INT 5
48305: PUSH
48306: LD_INT 4
48308: PUSH
48309: EMPTY
48310: LIST
48311: LIST
48312: PUSH
48313: LD_INT 5
48315: PUSH
48316: LD_INT 5
48318: PUSH
48319: EMPTY
48320: LIST
48321: LIST
48322: PUSH
48323: LD_INT 4
48325: PUSH
48326: LD_INT 5
48328: PUSH
48329: EMPTY
48330: LIST
48331: LIST
48332: PUSH
48333: LD_INT 3
48335: PUSH
48336: LD_INT 4
48338: PUSH
48339: EMPTY
48340: LIST
48341: LIST
48342: PUSH
48343: LD_INT 3
48345: PUSH
48346: LD_INT 3
48348: PUSH
48349: EMPTY
48350: LIST
48351: LIST
48352: PUSH
48353: LD_INT 5
48355: PUSH
48356: LD_INT 3
48358: PUSH
48359: EMPTY
48360: LIST
48361: LIST
48362: PUSH
48363: LD_INT 3
48365: PUSH
48366: LD_INT 5
48368: PUSH
48369: EMPTY
48370: LIST
48371: LIST
48372: PUSH
48373: LD_INT 0
48375: PUSH
48376: LD_INT 3
48378: PUSH
48379: EMPTY
48380: LIST
48381: LIST
48382: PUSH
48383: LD_INT 0
48385: PUSH
48386: LD_INT 2
48388: PUSH
48389: EMPTY
48390: LIST
48391: LIST
48392: PUSH
48393: LD_INT 1
48395: PUSH
48396: LD_INT 3
48398: PUSH
48399: EMPTY
48400: LIST
48401: LIST
48402: PUSH
48403: LD_INT 1
48405: PUSH
48406: LD_INT 4
48408: PUSH
48409: EMPTY
48410: LIST
48411: LIST
48412: PUSH
48413: LD_INT 0
48415: PUSH
48416: LD_INT 4
48418: PUSH
48419: EMPTY
48420: LIST
48421: LIST
48422: PUSH
48423: LD_INT 1
48425: NEG
48426: PUSH
48427: LD_INT 3
48429: PUSH
48430: EMPTY
48431: LIST
48432: LIST
48433: PUSH
48434: LD_INT 1
48436: NEG
48437: PUSH
48438: LD_INT 2
48440: PUSH
48441: EMPTY
48442: LIST
48443: LIST
48444: PUSH
48445: LD_INT 2
48447: PUSH
48448: LD_INT 4
48450: PUSH
48451: EMPTY
48452: LIST
48453: LIST
48454: PUSH
48455: LD_INT 2
48457: NEG
48458: PUSH
48459: LD_INT 2
48461: PUSH
48462: EMPTY
48463: LIST
48464: LIST
48465: PUSH
48466: LD_INT 4
48468: NEG
48469: PUSH
48470: LD_INT 0
48472: PUSH
48473: EMPTY
48474: LIST
48475: LIST
48476: PUSH
48477: LD_INT 4
48479: NEG
48480: PUSH
48481: LD_INT 1
48483: NEG
48484: PUSH
48485: EMPTY
48486: LIST
48487: LIST
48488: PUSH
48489: LD_INT 3
48491: NEG
48492: PUSH
48493: LD_INT 0
48495: PUSH
48496: EMPTY
48497: LIST
48498: LIST
48499: PUSH
48500: LD_INT 3
48502: NEG
48503: PUSH
48504: LD_INT 1
48506: PUSH
48507: EMPTY
48508: LIST
48509: LIST
48510: PUSH
48511: LD_INT 4
48513: NEG
48514: PUSH
48515: LD_INT 1
48517: PUSH
48518: EMPTY
48519: LIST
48520: LIST
48521: PUSH
48522: LD_INT 5
48524: NEG
48525: PUSH
48526: LD_INT 0
48528: PUSH
48529: EMPTY
48530: LIST
48531: LIST
48532: PUSH
48533: LD_INT 5
48535: NEG
48536: PUSH
48537: LD_INT 1
48539: NEG
48540: PUSH
48541: EMPTY
48542: LIST
48543: LIST
48544: PUSH
48545: LD_INT 5
48547: NEG
48548: PUSH
48549: LD_INT 2
48551: NEG
48552: PUSH
48553: EMPTY
48554: LIST
48555: LIST
48556: PUSH
48557: LD_INT 3
48559: NEG
48560: PUSH
48561: LD_INT 2
48563: PUSH
48564: EMPTY
48565: LIST
48566: LIST
48567: PUSH
48568: LD_INT 3
48570: NEG
48571: PUSH
48572: LD_INT 3
48574: NEG
48575: PUSH
48576: EMPTY
48577: LIST
48578: LIST
48579: PUSH
48580: LD_INT 3
48582: NEG
48583: PUSH
48584: LD_INT 4
48586: NEG
48587: PUSH
48588: EMPTY
48589: LIST
48590: LIST
48591: PUSH
48592: LD_INT 2
48594: NEG
48595: PUSH
48596: LD_INT 3
48598: NEG
48599: PUSH
48600: EMPTY
48601: LIST
48602: LIST
48603: PUSH
48604: LD_INT 2
48606: NEG
48607: PUSH
48608: LD_INT 2
48610: NEG
48611: PUSH
48612: EMPTY
48613: LIST
48614: LIST
48615: PUSH
48616: LD_INT 3
48618: NEG
48619: PUSH
48620: LD_INT 2
48622: NEG
48623: PUSH
48624: EMPTY
48625: LIST
48626: LIST
48627: PUSH
48628: LD_INT 4
48630: NEG
48631: PUSH
48632: LD_INT 3
48634: NEG
48635: PUSH
48636: EMPTY
48637: LIST
48638: LIST
48639: PUSH
48640: LD_INT 4
48642: NEG
48643: PUSH
48644: LD_INT 4
48646: NEG
48647: PUSH
48648: EMPTY
48649: LIST
48650: LIST
48651: PUSH
48652: LD_INT 2
48654: NEG
48655: PUSH
48656: LD_INT 4
48658: NEG
48659: PUSH
48660: EMPTY
48661: LIST
48662: LIST
48663: PUSH
48664: LD_INT 4
48666: NEG
48667: PUSH
48668: LD_INT 2
48670: NEG
48671: PUSH
48672: EMPTY
48673: LIST
48674: LIST
48675: PUSH
48676: LD_INT 0
48678: PUSH
48679: LD_INT 4
48681: NEG
48682: PUSH
48683: EMPTY
48684: LIST
48685: LIST
48686: PUSH
48687: LD_INT 0
48689: PUSH
48690: LD_INT 5
48692: NEG
48693: PUSH
48694: EMPTY
48695: LIST
48696: LIST
48697: PUSH
48698: LD_INT 1
48700: PUSH
48701: LD_INT 4
48703: NEG
48704: PUSH
48705: EMPTY
48706: LIST
48707: LIST
48708: PUSH
48709: LD_INT 1
48711: PUSH
48712: LD_INT 3
48714: NEG
48715: PUSH
48716: EMPTY
48717: LIST
48718: LIST
48719: PUSH
48720: LD_INT 0
48722: PUSH
48723: LD_INT 3
48725: NEG
48726: PUSH
48727: EMPTY
48728: LIST
48729: LIST
48730: PUSH
48731: LD_INT 1
48733: NEG
48734: PUSH
48735: LD_INT 4
48737: NEG
48738: PUSH
48739: EMPTY
48740: LIST
48741: LIST
48742: PUSH
48743: LD_INT 1
48745: NEG
48746: PUSH
48747: LD_INT 5
48749: NEG
48750: PUSH
48751: EMPTY
48752: LIST
48753: LIST
48754: PUSH
48755: LD_INT 2
48757: PUSH
48758: LD_INT 3
48760: NEG
48761: PUSH
48762: EMPTY
48763: LIST
48764: LIST
48765: PUSH
48766: LD_INT 2
48768: NEG
48769: PUSH
48770: LD_INT 5
48772: NEG
48773: PUSH
48774: EMPTY
48775: LIST
48776: LIST
48777: PUSH
48778: EMPTY
48779: LIST
48780: LIST
48781: LIST
48782: LIST
48783: LIST
48784: LIST
48785: LIST
48786: LIST
48787: LIST
48788: LIST
48789: LIST
48790: LIST
48791: LIST
48792: LIST
48793: LIST
48794: LIST
48795: LIST
48796: LIST
48797: LIST
48798: LIST
48799: LIST
48800: LIST
48801: LIST
48802: LIST
48803: LIST
48804: LIST
48805: LIST
48806: LIST
48807: LIST
48808: LIST
48809: LIST
48810: LIST
48811: LIST
48812: LIST
48813: LIST
48814: LIST
48815: LIST
48816: LIST
48817: LIST
48818: LIST
48819: LIST
48820: LIST
48821: LIST
48822: LIST
48823: LIST
48824: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
48825: LD_ADDR_VAR 0 31
48829: PUSH
48830: LD_INT 0
48832: PUSH
48833: LD_INT 4
48835: PUSH
48836: EMPTY
48837: LIST
48838: LIST
48839: PUSH
48840: LD_INT 0
48842: PUSH
48843: LD_INT 3
48845: PUSH
48846: EMPTY
48847: LIST
48848: LIST
48849: PUSH
48850: LD_INT 1
48852: PUSH
48853: LD_INT 4
48855: PUSH
48856: EMPTY
48857: LIST
48858: LIST
48859: PUSH
48860: LD_INT 1
48862: PUSH
48863: LD_INT 5
48865: PUSH
48866: EMPTY
48867: LIST
48868: LIST
48869: PUSH
48870: LD_INT 0
48872: PUSH
48873: LD_INT 5
48875: PUSH
48876: EMPTY
48877: LIST
48878: LIST
48879: PUSH
48880: LD_INT 1
48882: NEG
48883: PUSH
48884: LD_INT 4
48886: PUSH
48887: EMPTY
48888: LIST
48889: LIST
48890: PUSH
48891: LD_INT 1
48893: NEG
48894: PUSH
48895: LD_INT 3
48897: PUSH
48898: EMPTY
48899: LIST
48900: LIST
48901: PUSH
48902: LD_INT 2
48904: PUSH
48905: LD_INT 5
48907: PUSH
48908: EMPTY
48909: LIST
48910: LIST
48911: PUSH
48912: LD_INT 2
48914: NEG
48915: PUSH
48916: LD_INT 3
48918: PUSH
48919: EMPTY
48920: LIST
48921: LIST
48922: PUSH
48923: LD_INT 3
48925: NEG
48926: PUSH
48927: LD_INT 0
48929: PUSH
48930: EMPTY
48931: LIST
48932: LIST
48933: PUSH
48934: LD_INT 3
48936: NEG
48937: PUSH
48938: LD_INT 1
48940: NEG
48941: PUSH
48942: EMPTY
48943: LIST
48944: LIST
48945: PUSH
48946: LD_INT 2
48948: NEG
48949: PUSH
48950: LD_INT 0
48952: PUSH
48953: EMPTY
48954: LIST
48955: LIST
48956: PUSH
48957: LD_INT 2
48959: NEG
48960: PUSH
48961: LD_INT 1
48963: PUSH
48964: EMPTY
48965: LIST
48966: LIST
48967: PUSH
48968: LD_INT 3
48970: NEG
48971: PUSH
48972: LD_INT 1
48974: PUSH
48975: EMPTY
48976: LIST
48977: LIST
48978: PUSH
48979: LD_INT 4
48981: NEG
48982: PUSH
48983: LD_INT 0
48985: PUSH
48986: EMPTY
48987: LIST
48988: LIST
48989: PUSH
48990: LD_INT 4
48992: NEG
48993: PUSH
48994: LD_INT 1
48996: NEG
48997: PUSH
48998: EMPTY
48999: LIST
49000: LIST
49001: PUSH
49002: LD_INT 4
49004: NEG
49005: PUSH
49006: LD_INT 2
49008: NEG
49009: PUSH
49010: EMPTY
49011: LIST
49012: LIST
49013: PUSH
49014: LD_INT 2
49016: NEG
49017: PUSH
49018: LD_INT 2
49020: PUSH
49021: EMPTY
49022: LIST
49023: LIST
49024: PUSH
49025: LD_INT 4
49027: NEG
49028: PUSH
49029: LD_INT 4
49031: NEG
49032: PUSH
49033: EMPTY
49034: LIST
49035: LIST
49036: PUSH
49037: LD_INT 4
49039: NEG
49040: PUSH
49041: LD_INT 5
49043: NEG
49044: PUSH
49045: EMPTY
49046: LIST
49047: LIST
49048: PUSH
49049: LD_INT 3
49051: NEG
49052: PUSH
49053: LD_INT 4
49055: NEG
49056: PUSH
49057: EMPTY
49058: LIST
49059: LIST
49060: PUSH
49061: LD_INT 3
49063: NEG
49064: PUSH
49065: LD_INT 3
49067: NEG
49068: PUSH
49069: EMPTY
49070: LIST
49071: LIST
49072: PUSH
49073: LD_INT 4
49075: NEG
49076: PUSH
49077: LD_INT 3
49079: NEG
49080: PUSH
49081: EMPTY
49082: LIST
49083: LIST
49084: PUSH
49085: LD_INT 5
49087: NEG
49088: PUSH
49089: LD_INT 4
49091: NEG
49092: PUSH
49093: EMPTY
49094: LIST
49095: LIST
49096: PUSH
49097: LD_INT 5
49099: NEG
49100: PUSH
49101: LD_INT 5
49103: NEG
49104: PUSH
49105: EMPTY
49106: LIST
49107: LIST
49108: PUSH
49109: LD_INT 3
49111: NEG
49112: PUSH
49113: LD_INT 5
49115: NEG
49116: PUSH
49117: EMPTY
49118: LIST
49119: LIST
49120: PUSH
49121: LD_INT 5
49123: NEG
49124: PUSH
49125: LD_INT 3
49127: NEG
49128: PUSH
49129: EMPTY
49130: LIST
49131: LIST
49132: PUSH
49133: LD_INT 0
49135: PUSH
49136: LD_INT 3
49138: NEG
49139: PUSH
49140: EMPTY
49141: LIST
49142: LIST
49143: PUSH
49144: LD_INT 0
49146: PUSH
49147: LD_INT 4
49149: NEG
49150: PUSH
49151: EMPTY
49152: LIST
49153: LIST
49154: PUSH
49155: LD_INT 1
49157: PUSH
49158: LD_INT 3
49160: NEG
49161: PUSH
49162: EMPTY
49163: LIST
49164: LIST
49165: PUSH
49166: LD_INT 1
49168: PUSH
49169: LD_INT 2
49171: NEG
49172: PUSH
49173: EMPTY
49174: LIST
49175: LIST
49176: PUSH
49177: LD_INT 0
49179: PUSH
49180: LD_INT 2
49182: NEG
49183: PUSH
49184: EMPTY
49185: LIST
49186: LIST
49187: PUSH
49188: LD_INT 1
49190: NEG
49191: PUSH
49192: LD_INT 3
49194: NEG
49195: PUSH
49196: EMPTY
49197: LIST
49198: LIST
49199: PUSH
49200: LD_INT 1
49202: NEG
49203: PUSH
49204: LD_INT 4
49206: NEG
49207: PUSH
49208: EMPTY
49209: LIST
49210: LIST
49211: PUSH
49212: LD_INT 2
49214: PUSH
49215: LD_INT 2
49217: NEG
49218: PUSH
49219: EMPTY
49220: LIST
49221: LIST
49222: PUSH
49223: LD_INT 2
49225: NEG
49226: PUSH
49227: LD_INT 4
49229: NEG
49230: PUSH
49231: EMPTY
49232: LIST
49233: LIST
49234: PUSH
49235: LD_INT 4
49237: PUSH
49238: LD_INT 0
49240: PUSH
49241: EMPTY
49242: LIST
49243: LIST
49244: PUSH
49245: LD_INT 4
49247: PUSH
49248: LD_INT 1
49250: NEG
49251: PUSH
49252: EMPTY
49253: LIST
49254: LIST
49255: PUSH
49256: LD_INT 5
49258: PUSH
49259: LD_INT 0
49261: PUSH
49262: EMPTY
49263: LIST
49264: LIST
49265: PUSH
49266: LD_INT 5
49268: PUSH
49269: LD_INT 1
49271: PUSH
49272: EMPTY
49273: LIST
49274: LIST
49275: PUSH
49276: LD_INT 4
49278: PUSH
49279: LD_INT 1
49281: PUSH
49282: EMPTY
49283: LIST
49284: LIST
49285: PUSH
49286: LD_INT 3
49288: PUSH
49289: LD_INT 0
49291: PUSH
49292: EMPTY
49293: LIST
49294: LIST
49295: PUSH
49296: LD_INT 3
49298: PUSH
49299: LD_INT 1
49301: NEG
49302: PUSH
49303: EMPTY
49304: LIST
49305: LIST
49306: PUSH
49307: LD_INT 3
49309: PUSH
49310: LD_INT 2
49312: NEG
49313: PUSH
49314: EMPTY
49315: LIST
49316: LIST
49317: PUSH
49318: LD_INT 5
49320: PUSH
49321: LD_INT 2
49323: PUSH
49324: EMPTY
49325: LIST
49326: LIST
49327: PUSH
49328: EMPTY
49329: LIST
49330: LIST
49331: LIST
49332: LIST
49333: LIST
49334: LIST
49335: LIST
49336: LIST
49337: LIST
49338: LIST
49339: LIST
49340: LIST
49341: LIST
49342: LIST
49343: LIST
49344: LIST
49345: LIST
49346: LIST
49347: LIST
49348: LIST
49349: LIST
49350: LIST
49351: LIST
49352: LIST
49353: LIST
49354: LIST
49355: LIST
49356: LIST
49357: LIST
49358: LIST
49359: LIST
49360: LIST
49361: LIST
49362: LIST
49363: LIST
49364: LIST
49365: LIST
49366: LIST
49367: LIST
49368: LIST
49369: LIST
49370: LIST
49371: LIST
49372: LIST
49373: LIST
49374: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
49375: LD_ADDR_VAR 0 32
49379: PUSH
49380: LD_INT 4
49382: NEG
49383: PUSH
49384: LD_INT 0
49386: PUSH
49387: EMPTY
49388: LIST
49389: LIST
49390: PUSH
49391: LD_INT 4
49393: NEG
49394: PUSH
49395: LD_INT 1
49397: NEG
49398: PUSH
49399: EMPTY
49400: LIST
49401: LIST
49402: PUSH
49403: LD_INT 3
49405: NEG
49406: PUSH
49407: LD_INT 0
49409: PUSH
49410: EMPTY
49411: LIST
49412: LIST
49413: PUSH
49414: LD_INT 3
49416: NEG
49417: PUSH
49418: LD_INT 1
49420: PUSH
49421: EMPTY
49422: LIST
49423: LIST
49424: PUSH
49425: LD_INT 4
49427: NEG
49428: PUSH
49429: LD_INT 1
49431: PUSH
49432: EMPTY
49433: LIST
49434: LIST
49435: PUSH
49436: LD_INT 5
49438: NEG
49439: PUSH
49440: LD_INT 0
49442: PUSH
49443: EMPTY
49444: LIST
49445: LIST
49446: PUSH
49447: LD_INT 5
49449: NEG
49450: PUSH
49451: LD_INT 1
49453: NEG
49454: PUSH
49455: EMPTY
49456: LIST
49457: LIST
49458: PUSH
49459: LD_INT 5
49461: NEG
49462: PUSH
49463: LD_INT 2
49465: NEG
49466: PUSH
49467: EMPTY
49468: LIST
49469: LIST
49470: PUSH
49471: LD_INT 3
49473: NEG
49474: PUSH
49475: LD_INT 2
49477: PUSH
49478: EMPTY
49479: LIST
49480: LIST
49481: PUSH
49482: LD_INT 3
49484: NEG
49485: PUSH
49486: LD_INT 3
49488: NEG
49489: PUSH
49490: EMPTY
49491: LIST
49492: LIST
49493: PUSH
49494: LD_INT 3
49496: NEG
49497: PUSH
49498: LD_INT 4
49500: NEG
49501: PUSH
49502: EMPTY
49503: LIST
49504: LIST
49505: PUSH
49506: LD_INT 2
49508: NEG
49509: PUSH
49510: LD_INT 3
49512: NEG
49513: PUSH
49514: EMPTY
49515: LIST
49516: LIST
49517: PUSH
49518: LD_INT 2
49520: NEG
49521: PUSH
49522: LD_INT 2
49524: NEG
49525: PUSH
49526: EMPTY
49527: LIST
49528: LIST
49529: PUSH
49530: LD_INT 3
49532: NEG
49533: PUSH
49534: LD_INT 2
49536: NEG
49537: PUSH
49538: EMPTY
49539: LIST
49540: LIST
49541: PUSH
49542: LD_INT 4
49544: NEG
49545: PUSH
49546: LD_INT 3
49548: NEG
49549: PUSH
49550: EMPTY
49551: LIST
49552: LIST
49553: PUSH
49554: LD_INT 4
49556: NEG
49557: PUSH
49558: LD_INT 4
49560: NEG
49561: PUSH
49562: EMPTY
49563: LIST
49564: LIST
49565: PUSH
49566: LD_INT 2
49568: NEG
49569: PUSH
49570: LD_INT 4
49572: NEG
49573: PUSH
49574: EMPTY
49575: LIST
49576: LIST
49577: PUSH
49578: LD_INT 4
49580: NEG
49581: PUSH
49582: LD_INT 2
49584: NEG
49585: PUSH
49586: EMPTY
49587: LIST
49588: LIST
49589: PUSH
49590: LD_INT 0
49592: PUSH
49593: LD_INT 4
49595: NEG
49596: PUSH
49597: EMPTY
49598: LIST
49599: LIST
49600: PUSH
49601: LD_INT 0
49603: PUSH
49604: LD_INT 5
49606: NEG
49607: PUSH
49608: EMPTY
49609: LIST
49610: LIST
49611: PUSH
49612: LD_INT 1
49614: PUSH
49615: LD_INT 4
49617: NEG
49618: PUSH
49619: EMPTY
49620: LIST
49621: LIST
49622: PUSH
49623: LD_INT 1
49625: PUSH
49626: LD_INT 3
49628: NEG
49629: PUSH
49630: EMPTY
49631: LIST
49632: LIST
49633: PUSH
49634: LD_INT 0
49636: PUSH
49637: LD_INT 3
49639: NEG
49640: PUSH
49641: EMPTY
49642: LIST
49643: LIST
49644: PUSH
49645: LD_INT 1
49647: NEG
49648: PUSH
49649: LD_INT 4
49651: NEG
49652: PUSH
49653: EMPTY
49654: LIST
49655: LIST
49656: PUSH
49657: LD_INT 1
49659: NEG
49660: PUSH
49661: LD_INT 5
49663: NEG
49664: PUSH
49665: EMPTY
49666: LIST
49667: LIST
49668: PUSH
49669: LD_INT 2
49671: PUSH
49672: LD_INT 3
49674: NEG
49675: PUSH
49676: EMPTY
49677: LIST
49678: LIST
49679: PUSH
49680: LD_INT 2
49682: NEG
49683: PUSH
49684: LD_INT 5
49686: NEG
49687: PUSH
49688: EMPTY
49689: LIST
49690: LIST
49691: PUSH
49692: LD_INT 3
49694: PUSH
49695: LD_INT 0
49697: PUSH
49698: EMPTY
49699: LIST
49700: LIST
49701: PUSH
49702: LD_INT 3
49704: PUSH
49705: LD_INT 1
49707: NEG
49708: PUSH
49709: EMPTY
49710: LIST
49711: LIST
49712: PUSH
49713: LD_INT 4
49715: PUSH
49716: LD_INT 0
49718: PUSH
49719: EMPTY
49720: LIST
49721: LIST
49722: PUSH
49723: LD_INT 4
49725: PUSH
49726: LD_INT 1
49728: PUSH
49729: EMPTY
49730: LIST
49731: LIST
49732: PUSH
49733: LD_INT 3
49735: PUSH
49736: LD_INT 1
49738: PUSH
49739: EMPTY
49740: LIST
49741: LIST
49742: PUSH
49743: LD_INT 2
49745: PUSH
49746: LD_INT 0
49748: PUSH
49749: EMPTY
49750: LIST
49751: LIST
49752: PUSH
49753: LD_INT 2
49755: PUSH
49756: LD_INT 1
49758: NEG
49759: PUSH
49760: EMPTY
49761: LIST
49762: LIST
49763: PUSH
49764: LD_INT 2
49766: PUSH
49767: LD_INT 2
49769: NEG
49770: PUSH
49771: EMPTY
49772: LIST
49773: LIST
49774: PUSH
49775: LD_INT 4
49777: PUSH
49778: LD_INT 2
49780: PUSH
49781: EMPTY
49782: LIST
49783: LIST
49784: PUSH
49785: LD_INT 4
49787: PUSH
49788: LD_INT 4
49790: PUSH
49791: EMPTY
49792: LIST
49793: LIST
49794: PUSH
49795: LD_INT 4
49797: PUSH
49798: LD_INT 3
49800: PUSH
49801: EMPTY
49802: LIST
49803: LIST
49804: PUSH
49805: LD_INT 5
49807: PUSH
49808: LD_INT 4
49810: PUSH
49811: EMPTY
49812: LIST
49813: LIST
49814: PUSH
49815: LD_INT 5
49817: PUSH
49818: LD_INT 5
49820: PUSH
49821: EMPTY
49822: LIST
49823: LIST
49824: PUSH
49825: LD_INT 4
49827: PUSH
49828: LD_INT 5
49830: PUSH
49831: EMPTY
49832: LIST
49833: LIST
49834: PUSH
49835: LD_INT 3
49837: PUSH
49838: LD_INT 4
49840: PUSH
49841: EMPTY
49842: LIST
49843: LIST
49844: PUSH
49845: LD_INT 3
49847: PUSH
49848: LD_INT 3
49850: PUSH
49851: EMPTY
49852: LIST
49853: LIST
49854: PUSH
49855: LD_INT 5
49857: PUSH
49858: LD_INT 3
49860: PUSH
49861: EMPTY
49862: LIST
49863: LIST
49864: PUSH
49865: LD_INT 3
49867: PUSH
49868: LD_INT 5
49870: PUSH
49871: EMPTY
49872: LIST
49873: LIST
49874: PUSH
49875: EMPTY
49876: LIST
49877: LIST
49878: LIST
49879: LIST
49880: LIST
49881: LIST
49882: LIST
49883: LIST
49884: LIST
49885: LIST
49886: LIST
49887: LIST
49888: LIST
49889: LIST
49890: LIST
49891: LIST
49892: LIST
49893: LIST
49894: LIST
49895: LIST
49896: LIST
49897: LIST
49898: LIST
49899: LIST
49900: LIST
49901: LIST
49902: LIST
49903: LIST
49904: LIST
49905: LIST
49906: LIST
49907: LIST
49908: LIST
49909: LIST
49910: LIST
49911: LIST
49912: LIST
49913: LIST
49914: LIST
49915: LIST
49916: LIST
49917: LIST
49918: LIST
49919: LIST
49920: LIST
49921: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
49922: LD_ADDR_VAR 0 33
49926: PUSH
49927: LD_INT 4
49929: NEG
49930: PUSH
49931: LD_INT 4
49933: NEG
49934: PUSH
49935: EMPTY
49936: LIST
49937: LIST
49938: PUSH
49939: LD_INT 4
49941: NEG
49942: PUSH
49943: LD_INT 5
49945: NEG
49946: PUSH
49947: EMPTY
49948: LIST
49949: LIST
49950: PUSH
49951: LD_INT 3
49953: NEG
49954: PUSH
49955: LD_INT 4
49957: NEG
49958: PUSH
49959: EMPTY
49960: LIST
49961: LIST
49962: PUSH
49963: LD_INT 3
49965: NEG
49966: PUSH
49967: LD_INT 3
49969: NEG
49970: PUSH
49971: EMPTY
49972: LIST
49973: LIST
49974: PUSH
49975: LD_INT 4
49977: NEG
49978: PUSH
49979: LD_INT 3
49981: NEG
49982: PUSH
49983: EMPTY
49984: LIST
49985: LIST
49986: PUSH
49987: LD_INT 5
49989: NEG
49990: PUSH
49991: LD_INT 4
49993: NEG
49994: PUSH
49995: EMPTY
49996: LIST
49997: LIST
49998: PUSH
49999: LD_INT 5
50001: NEG
50002: PUSH
50003: LD_INT 5
50005: NEG
50006: PUSH
50007: EMPTY
50008: LIST
50009: LIST
50010: PUSH
50011: LD_INT 3
50013: NEG
50014: PUSH
50015: LD_INT 5
50017: NEG
50018: PUSH
50019: EMPTY
50020: LIST
50021: LIST
50022: PUSH
50023: LD_INT 5
50025: NEG
50026: PUSH
50027: LD_INT 3
50029: NEG
50030: PUSH
50031: EMPTY
50032: LIST
50033: LIST
50034: PUSH
50035: LD_INT 0
50037: PUSH
50038: LD_INT 3
50040: NEG
50041: PUSH
50042: EMPTY
50043: LIST
50044: LIST
50045: PUSH
50046: LD_INT 0
50048: PUSH
50049: LD_INT 4
50051: NEG
50052: PUSH
50053: EMPTY
50054: LIST
50055: LIST
50056: PUSH
50057: LD_INT 1
50059: PUSH
50060: LD_INT 3
50062: NEG
50063: PUSH
50064: EMPTY
50065: LIST
50066: LIST
50067: PUSH
50068: LD_INT 1
50070: PUSH
50071: LD_INT 2
50073: NEG
50074: PUSH
50075: EMPTY
50076: LIST
50077: LIST
50078: PUSH
50079: LD_INT 0
50081: PUSH
50082: LD_INT 2
50084: NEG
50085: PUSH
50086: EMPTY
50087: LIST
50088: LIST
50089: PUSH
50090: LD_INT 1
50092: NEG
50093: PUSH
50094: LD_INT 3
50096: NEG
50097: PUSH
50098: EMPTY
50099: LIST
50100: LIST
50101: PUSH
50102: LD_INT 1
50104: NEG
50105: PUSH
50106: LD_INT 4
50108: NEG
50109: PUSH
50110: EMPTY
50111: LIST
50112: LIST
50113: PUSH
50114: LD_INT 2
50116: PUSH
50117: LD_INT 2
50119: NEG
50120: PUSH
50121: EMPTY
50122: LIST
50123: LIST
50124: PUSH
50125: LD_INT 2
50127: NEG
50128: PUSH
50129: LD_INT 4
50131: NEG
50132: PUSH
50133: EMPTY
50134: LIST
50135: LIST
50136: PUSH
50137: LD_INT 4
50139: PUSH
50140: LD_INT 0
50142: PUSH
50143: EMPTY
50144: LIST
50145: LIST
50146: PUSH
50147: LD_INT 4
50149: PUSH
50150: LD_INT 1
50152: NEG
50153: PUSH
50154: EMPTY
50155: LIST
50156: LIST
50157: PUSH
50158: LD_INT 5
50160: PUSH
50161: LD_INT 0
50163: PUSH
50164: EMPTY
50165: LIST
50166: LIST
50167: PUSH
50168: LD_INT 5
50170: PUSH
50171: LD_INT 1
50173: PUSH
50174: EMPTY
50175: LIST
50176: LIST
50177: PUSH
50178: LD_INT 4
50180: PUSH
50181: LD_INT 1
50183: PUSH
50184: EMPTY
50185: LIST
50186: LIST
50187: PUSH
50188: LD_INT 3
50190: PUSH
50191: LD_INT 0
50193: PUSH
50194: EMPTY
50195: LIST
50196: LIST
50197: PUSH
50198: LD_INT 3
50200: PUSH
50201: LD_INT 1
50203: NEG
50204: PUSH
50205: EMPTY
50206: LIST
50207: LIST
50208: PUSH
50209: LD_INT 3
50211: PUSH
50212: LD_INT 2
50214: NEG
50215: PUSH
50216: EMPTY
50217: LIST
50218: LIST
50219: PUSH
50220: LD_INT 5
50222: PUSH
50223: LD_INT 2
50225: PUSH
50226: EMPTY
50227: LIST
50228: LIST
50229: PUSH
50230: LD_INT 3
50232: PUSH
50233: LD_INT 3
50235: PUSH
50236: EMPTY
50237: LIST
50238: LIST
50239: PUSH
50240: LD_INT 3
50242: PUSH
50243: LD_INT 2
50245: PUSH
50246: EMPTY
50247: LIST
50248: LIST
50249: PUSH
50250: LD_INT 4
50252: PUSH
50253: LD_INT 3
50255: PUSH
50256: EMPTY
50257: LIST
50258: LIST
50259: PUSH
50260: LD_INT 4
50262: PUSH
50263: LD_INT 4
50265: PUSH
50266: EMPTY
50267: LIST
50268: LIST
50269: PUSH
50270: LD_INT 3
50272: PUSH
50273: LD_INT 4
50275: PUSH
50276: EMPTY
50277: LIST
50278: LIST
50279: PUSH
50280: LD_INT 2
50282: PUSH
50283: LD_INT 3
50285: PUSH
50286: EMPTY
50287: LIST
50288: LIST
50289: PUSH
50290: LD_INT 2
50292: PUSH
50293: LD_INT 2
50295: PUSH
50296: EMPTY
50297: LIST
50298: LIST
50299: PUSH
50300: LD_INT 4
50302: PUSH
50303: LD_INT 2
50305: PUSH
50306: EMPTY
50307: LIST
50308: LIST
50309: PUSH
50310: LD_INT 2
50312: PUSH
50313: LD_INT 4
50315: PUSH
50316: EMPTY
50317: LIST
50318: LIST
50319: PUSH
50320: LD_INT 0
50322: PUSH
50323: LD_INT 4
50325: PUSH
50326: EMPTY
50327: LIST
50328: LIST
50329: PUSH
50330: LD_INT 0
50332: PUSH
50333: LD_INT 3
50335: PUSH
50336: EMPTY
50337: LIST
50338: LIST
50339: PUSH
50340: LD_INT 1
50342: PUSH
50343: LD_INT 4
50345: PUSH
50346: EMPTY
50347: LIST
50348: LIST
50349: PUSH
50350: LD_INT 1
50352: PUSH
50353: LD_INT 5
50355: PUSH
50356: EMPTY
50357: LIST
50358: LIST
50359: PUSH
50360: LD_INT 0
50362: PUSH
50363: LD_INT 5
50365: PUSH
50366: EMPTY
50367: LIST
50368: LIST
50369: PUSH
50370: LD_INT 1
50372: NEG
50373: PUSH
50374: LD_INT 4
50376: PUSH
50377: EMPTY
50378: LIST
50379: LIST
50380: PUSH
50381: LD_INT 1
50383: NEG
50384: PUSH
50385: LD_INT 3
50387: PUSH
50388: EMPTY
50389: LIST
50390: LIST
50391: PUSH
50392: LD_INT 2
50394: PUSH
50395: LD_INT 5
50397: PUSH
50398: EMPTY
50399: LIST
50400: LIST
50401: PUSH
50402: LD_INT 2
50404: NEG
50405: PUSH
50406: LD_INT 3
50408: PUSH
50409: EMPTY
50410: LIST
50411: LIST
50412: PUSH
50413: EMPTY
50414: LIST
50415: LIST
50416: LIST
50417: LIST
50418: LIST
50419: LIST
50420: LIST
50421: LIST
50422: LIST
50423: LIST
50424: LIST
50425: LIST
50426: LIST
50427: LIST
50428: LIST
50429: LIST
50430: LIST
50431: LIST
50432: LIST
50433: LIST
50434: LIST
50435: LIST
50436: LIST
50437: LIST
50438: LIST
50439: LIST
50440: LIST
50441: LIST
50442: LIST
50443: LIST
50444: LIST
50445: LIST
50446: LIST
50447: LIST
50448: LIST
50449: LIST
50450: LIST
50451: LIST
50452: LIST
50453: LIST
50454: LIST
50455: LIST
50456: LIST
50457: LIST
50458: LIST
50459: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
50460: LD_ADDR_VAR 0 34
50464: PUSH
50465: LD_INT 0
50467: PUSH
50468: LD_INT 4
50470: NEG
50471: PUSH
50472: EMPTY
50473: LIST
50474: LIST
50475: PUSH
50476: LD_INT 0
50478: PUSH
50479: LD_INT 5
50481: NEG
50482: PUSH
50483: EMPTY
50484: LIST
50485: LIST
50486: PUSH
50487: LD_INT 1
50489: PUSH
50490: LD_INT 4
50492: NEG
50493: PUSH
50494: EMPTY
50495: LIST
50496: LIST
50497: PUSH
50498: LD_INT 1
50500: PUSH
50501: LD_INT 3
50503: NEG
50504: PUSH
50505: EMPTY
50506: LIST
50507: LIST
50508: PUSH
50509: LD_INT 0
50511: PUSH
50512: LD_INT 3
50514: NEG
50515: PUSH
50516: EMPTY
50517: LIST
50518: LIST
50519: PUSH
50520: LD_INT 1
50522: NEG
50523: PUSH
50524: LD_INT 4
50526: NEG
50527: PUSH
50528: EMPTY
50529: LIST
50530: LIST
50531: PUSH
50532: LD_INT 1
50534: NEG
50535: PUSH
50536: LD_INT 5
50538: NEG
50539: PUSH
50540: EMPTY
50541: LIST
50542: LIST
50543: PUSH
50544: LD_INT 2
50546: PUSH
50547: LD_INT 3
50549: NEG
50550: PUSH
50551: EMPTY
50552: LIST
50553: LIST
50554: PUSH
50555: LD_INT 2
50557: NEG
50558: PUSH
50559: LD_INT 5
50561: NEG
50562: PUSH
50563: EMPTY
50564: LIST
50565: LIST
50566: PUSH
50567: LD_INT 3
50569: PUSH
50570: LD_INT 0
50572: PUSH
50573: EMPTY
50574: LIST
50575: LIST
50576: PUSH
50577: LD_INT 3
50579: PUSH
50580: LD_INT 1
50582: NEG
50583: PUSH
50584: EMPTY
50585: LIST
50586: LIST
50587: PUSH
50588: LD_INT 4
50590: PUSH
50591: LD_INT 0
50593: PUSH
50594: EMPTY
50595: LIST
50596: LIST
50597: PUSH
50598: LD_INT 4
50600: PUSH
50601: LD_INT 1
50603: PUSH
50604: EMPTY
50605: LIST
50606: LIST
50607: PUSH
50608: LD_INT 3
50610: PUSH
50611: LD_INT 1
50613: PUSH
50614: EMPTY
50615: LIST
50616: LIST
50617: PUSH
50618: LD_INT 2
50620: PUSH
50621: LD_INT 0
50623: PUSH
50624: EMPTY
50625: LIST
50626: LIST
50627: PUSH
50628: LD_INT 2
50630: PUSH
50631: LD_INT 1
50633: NEG
50634: PUSH
50635: EMPTY
50636: LIST
50637: LIST
50638: PUSH
50639: LD_INT 2
50641: PUSH
50642: LD_INT 2
50644: NEG
50645: PUSH
50646: EMPTY
50647: LIST
50648: LIST
50649: PUSH
50650: LD_INT 4
50652: PUSH
50653: LD_INT 2
50655: PUSH
50656: EMPTY
50657: LIST
50658: LIST
50659: PUSH
50660: LD_INT 4
50662: PUSH
50663: LD_INT 4
50665: PUSH
50666: EMPTY
50667: LIST
50668: LIST
50669: PUSH
50670: LD_INT 4
50672: PUSH
50673: LD_INT 3
50675: PUSH
50676: EMPTY
50677: LIST
50678: LIST
50679: PUSH
50680: LD_INT 5
50682: PUSH
50683: LD_INT 4
50685: PUSH
50686: EMPTY
50687: LIST
50688: LIST
50689: PUSH
50690: LD_INT 5
50692: PUSH
50693: LD_INT 5
50695: PUSH
50696: EMPTY
50697: LIST
50698: LIST
50699: PUSH
50700: LD_INT 4
50702: PUSH
50703: LD_INT 5
50705: PUSH
50706: EMPTY
50707: LIST
50708: LIST
50709: PUSH
50710: LD_INT 3
50712: PUSH
50713: LD_INT 4
50715: PUSH
50716: EMPTY
50717: LIST
50718: LIST
50719: PUSH
50720: LD_INT 3
50722: PUSH
50723: LD_INT 3
50725: PUSH
50726: EMPTY
50727: LIST
50728: LIST
50729: PUSH
50730: LD_INT 5
50732: PUSH
50733: LD_INT 3
50735: PUSH
50736: EMPTY
50737: LIST
50738: LIST
50739: PUSH
50740: LD_INT 3
50742: PUSH
50743: LD_INT 5
50745: PUSH
50746: EMPTY
50747: LIST
50748: LIST
50749: PUSH
50750: LD_INT 0
50752: PUSH
50753: LD_INT 3
50755: PUSH
50756: EMPTY
50757: LIST
50758: LIST
50759: PUSH
50760: LD_INT 0
50762: PUSH
50763: LD_INT 2
50765: PUSH
50766: EMPTY
50767: LIST
50768: LIST
50769: PUSH
50770: LD_INT 1
50772: PUSH
50773: LD_INT 3
50775: PUSH
50776: EMPTY
50777: LIST
50778: LIST
50779: PUSH
50780: LD_INT 1
50782: PUSH
50783: LD_INT 4
50785: PUSH
50786: EMPTY
50787: LIST
50788: LIST
50789: PUSH
50790: LD_INT 0
50792: PUSH
50793: LD_INT 4
50795: PUSH
50796: EMPTY
50797: LIST
50798: LIST
50799: PUSH
50800: LD_INT 1
50802: NEG
50803: PUSH
50804: LD_INT 3
50806: PUSH
50807: EMPTY
50808: LIST
50809: LIST
50810: PUSH
50811: LD_INT 1
50813: NEG
50814: PUSH
50815: LD_INT 2
50817: PUSH
50818: EMPTY
50819: LIST
50820: LIST
50821: PUSH
50822: LD_INT 2
50824: PUSH
50825: LD_INT 4
50827: PUSH
50828: EMPTY
50829: LIST
50830: LIST
50831: PUSH
50832: LD_INT 2
50834: NEG
50835: PUSH
50836: LD_INT 2
50838: PUSH
50839: EMPTY
50840: LIST
50841: LIST
50842: PUSH
50843: LD_INT 4
50845: NEG
50846: PUSH
50847: LD_INT 0
50849: PUSH
50850: EMPTY
50851: LIST
50852: LIST
50853: PUSH
50854: LD_INT 4
50856: NEG
50857: PUSH
50858: LD_INT 1
50860: NEG
50861: PUSH
50862: EMPTY
50863: LIST
50864: LIST
50865: PUSH
50866: LD_INT 3
50868: NEG
50869: PUSH
50870: LD_INT 0
50872: PUSH
50873: EMPTY
50874: LIST
50875: LIST
50876: PUSH
50877: LD_INT 3
50879: NEG
50880: PUSH
50881: LD_INT 1
50883: PUSH
50884: EMPTY
50885: LIST
50886: LIST
50887: PUSH
50888: LD_INT 4
50890: NEG
50891: PUSH
50892: LD_INT 1
50894: PUSH
50895: EMPTY
50896: LIST
50897: LIST
50898: PUSH
50899: LD_INT 5
50901: NEG
50902: PUSH
50903: LD_INT 0
50905: PUSH
50906: EMPTY
50907: LIST
50908: LIST
50909: PUSH
50910: LD_INT 5
50912: NEG
50913: PUSH
50914: LD_INT 1
50916: NEG
50917: PUSH
50918: EMPTY
50919: LIST
50920: LIST
50921: PUSH
50922: LD_INT 5
50924: NEG
50925: PUSH
50926: LD_INT 2
50928: NEG
50929: PUSH
50930: EMPTY
50931: LIST
50932: LIST
50933: PUSH
50934: LD_INT 3
50936: NEG
50937: PUSH
50938: LD_INT 2
50940: PUSH
50941: EMPTY
50942: LIST
50943: LIST
50944: PUSH
50945: EMPTY
50946: LIST
50947: LIST
50948: LIST
50949: LIST
50950: LIST
50951: LIST
50952: LIST
50953: LIST
50954: LIST
50955: LIST
50956: LIST
50957: LIST
50958: LIST
50959: LIST
50960: LIST
50961: LIST
50962: LIST
50963: LIST
50964: LIST
50965: LIST
50966: LIST
50967: LIST
50968: LIST
50969: LIST
50970: LIST
50971: LIST
50972: LIST
50973: LIST
50974: LIST
50975: LIST
50976: LIST
50977: LIST
50978: LIST
50979: LIST
50980: LIST
50981: LIST
50982: LIST
50983: LIST
50984: LIST
50985: LIST
50986: LIST
50987: LIST
50988: LIST
50989: LIST
50990: LIST
50991: ST_TO_ADDR
// end ; end ;
50992: GO 50995
50994: POP
// case btype of b_depot , b_warehouse :
50995: LD_VAR 0 1
50999: PUSH
51000: LD_INT 0
51002: DOUBLE
51003: EQUAL
51004: IFTRUE 51014
51006: LD_INT 1
51008: DOUBLE
51009: EQUAL
51010: IFTRUE 51014
51012: GO 51215
51014: POP
// case nation of nation_american :
51015: LD_VAR 0 5
51019: PUSH
51020: LD_INT 1
51022: DOUBLE
51023: EQUAL
51024: IFTRUE 51028
51026: GO 51084
51028: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
51029: LD_ADDR_VAR 0 9
51033: PUSH
51034: LD_VAR 0 11
51038: PUSH
51039: LD_VAR 0 12
51043: PUSH
51044: LD_VAR 0 13
51048: PUSH
51049: LD_VAR 0 14
51053: PUSH
51054: LD_VAR 0 15
51058: PUSH
51059: LD_VAR 0 16
51063: PUSH
51064: EMPTY
51065: LIST
51066: LIST
51067: LIST
51068: LIST
51069: LIST
51070: LIST
51071: PUSH
51072: LD_VAR 0 4
51076: PUSH
51077: LD_INT 1
51079: PLUS
51080: ARRAY
51081: ST_TO_ADDR
51082: GO 51213
51084: LD_INT 2
51086: DOUBLE
51087: EQUAL
51088: IFTRUE 51092
51090: GO 51148
51092: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
51093: LD_ADDR_VAR 0 9
51097: PUSH
51098: LD_VAR 0 17
51102: PUSH
51103: LD_VAR 0 18
51107: PUSH
51108: LD_VAR 0 19
51112: PUSH
51113: LD_VAR 0 20
51117: PUSH
51118: LD_VAR 0 21
51122: PUSH
51123: LD_VAR 0 22
51127: PUSH
51128: EMPTY
51129: LIST
51130: LIST
51131: LIST
51132: LIST
51133: LIST
51134: LIST
51135: PUSH
51136: LD_VAR 0 4
51140: PUSH
51141: LD_INT 1
51143: PLUS
51144: ARRAY
51145: ST_TO_ADDR
51146: GO 51213
51148: LD_INT 3
51150: DOUBLE
51151: EQUAL
51152: IFTRUE 51156
51154: GO 51212
51156: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
51157: LD_ADDR_VAR 0 9
51161: PUSH
51162: LD_VAR 0 23
51166: PUSH
51167: LD_VAR 0 24
51171: PUSH
51172: LD_VAR 0 25
51176: PUSH
51177: LD_VAR 0 26
51181: PUSH
51182: LD_VAR 0 27
51186: PUSH
51187: LD_VAR 0 28
51191: PUSH
51192: EMPTY
51193: LIST
51194: LIST
51195: LIST
51196: LIST
51197: LIST
51198: LIST
51199: PUSH
51200: LD_VAR 0 4
51204: PUSH
51205: LD_INT 1
51207: PLUS
51208: ARRAY
51209: ST_TO_ADDR
51210: GO 51213
51212: POP
51213: GO 51768
51215: LD_INT 2
51217: DOUBLE
51218: EQUAL
51219: IFTRUE 51229
51221: LD_INT 3
51223: DOUBLE
51224: EQUAL
51225: IFTRUE 51229
51227: GO 51285
51229: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
51230: LD_ADDR_VAR 0 9
51234: PUSH
51235: LD_VAR 0 29
51239: PUSH
51240: LD_VAR 0 30
51244: PUSH
51245: LD_VAR 0 31
51249: PUSH
51250: LD_VAR 0 32
51254: PUSH
51255: LD_VAR 0 33
51259: PUSH
51260: LD_VAR 0 34
51264: PUSH
51265: EMPTY
51266: LIST
51267: LIST
51268: LIST
51269: LIST
51270: LIST
51271: LIST
51272: PUSH
51273: LD_VAR 0 4
51277: PUSH
51278: LD_INT 1
51280: PLUS
51281: ARRAY
51282: ST_TO_ADDR
51283: GO 51768
51285: LD_INT 16
51287: DOUBLE
51288: EQUAL
51289: IFTRUE 51347
51291: LD_INT 17
51293: DOUBLE
51294: EQUAL
51295: IFTRUE 51347
51297: LD_INT 18
51299: DOUBLE
51300: EQUAL
51301: IFTRUE 51347
51303: LD_INT 19
51305: DOUBLE
51306: EQUAL
51307: IFTRUE 51347
51309: LD_INT 22
51311: DOUBLE
51312: EQUAL
51313: IFTRUE 51347
51315: LD_INT 20
51317: DOUBLE
51318: EQUAL
51319: IFTRUE 51347
51321: LD_INT 21
51323: DOUBLE
51324: EQUAL
51325: IFTRUE 51347
51327: LD_INT 23
51329: DOUBLE
51330: EQUAL
51331: IFTRUE 51347
51333: LD_INT 24
51335: DOUBLE
51336: EQUAL
51337: IFTRUE 51347
51339: LD_INT 25
51341: DOUBLE
51342: EQUAL
51343: IFTRUE 51347
51345: GO 51403
51347: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
51348: LD_ADDR_VAR 0 9
51352: PUSH
51353: LD_VAR 0 35
51357: PUSH
51358: LD_VAR 0 36
51362: PUSH
51363: LD_VAR 0 37
51367: PUSH
51368: LD_VAR 0 38
51372: PUSH
51373: LD_VAR 0 39
51377: PUSH
51378: LD_VAR 0 40
51382: PUSH
51383: EMPTY
51384: LIST
51385: LIST
51386: LIST
51387: LIST
51388: LIST
51389: LIST
51390: PUSH
51391: LD_VAR 0 4
51395: PUSH
51396: LD_INT 1
51398: PLUS
51399: ARRAY
51400: ST_TO_ADDR
51401: GO 51768
51403: LD_INT 6
51405: DOUBLE
51406: EQUAL
51407: IFTRUE 51459
51409: LD_INT 7
51411: DOUBLE
51412: EQUAL
51413: IFTRUE 51459
51415: LD_INT 8
51417: DOUBLE
51418: EQUAL
51419: IFTRUE 51459
51421: LD_INT 13
51423: DOUBLE
51424: EQUAL
51425: IFTRUE 51459
51427: LD_INT 12
51429: DOUBLE
51430: EQUAL
51431: IFTRUE 51459
51433: LD_INT 15
51435: DOUBLE
51436: EQUAL
51437: IFTRUE 51459
51439: LD_INT 11
51441: DOUBLE
51442: EQUAL
51443: IFTRUE 51459
51445: LD_INT 14
51447: DOUBLE
51448: EQUAL
51449: IFTRUE 51459
51451: LD_INT 10
51453: DOUBLE
51454: EQUAL
51455: IFTRUE 51459
51457: GO 51515
51459: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
51460: LD_ADDR_VAR 0 9
51464: PUSH
51465: LD_VAR 0 41
51469: PUSH
51470: LD_VAR 0 42
51474: PUSH
51475: LD_VAR 0 43
51479: PUSH
51480: LD_VAR 0 44
51484: PUSH
51485: LD_VAR 0 45
51489: PUSH
51490: LD_VAR 0 46
51494: PUSH
51495: EMPTY
51496: LIST
51497: LIST
51498: LIST
51499: LIST
51500: LIST
51501: LIST
51502: PUSH
51503: LD_VAR 0 4
51507: PUSH
51508: LD_INT 1
51510: PLUS
51511: ARRAY
51512: ST_TO_ADDR
51513: GO 51768
51515: LD_INT 36
51517: DOUBLE
51518: EQUAL
51519: IFTRUE 51523
51521: GO 51579
51523: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
51524: LD_ADDR_VAR 0 9
51528: PUSH
51529: LD_VAR 0 47
51533: PUSH
51534: LD_VAR 0 48
51538: PUSH
51539: LD_VAR 0 49
51543: PUSH
51544: LD_VAR 0 50
51548: PUSH
51549: LD_VAR 0 51
51553: PUSH
51554: LD_VAR 0 52
51558: PUSH
51559: EMPTY
51560: LIST
51561: LIST
51562: LIST
51563: LIST
51564: LIST
51565: LIST
51566: PUSH
51567: LD_VAR 0 4
51571: PUSH
51572: LD_INT 1
51574: PLUS
51575: ARRAY
51576: ST_TO_ADDR
51577: GO 51768
51579: LD_INT 4
51581: DOUBLE
51582: EQUAL
51583: IFTRUE 51605
51585: LD_INT 5
51587: DOUBLE
51588: EQUAL
51589: IFTRUE 51605
51591: LD_INT 34
51593: DOUBLE
51594: EQUAL
51595: IFTRUE 51605
51597: LD_INT 37
51599: DOUBLE
51600: EQUAL
51601: IFTRUE 51605
51603: GO 51661
51605: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
51606: LD_ADDR_VAR 0 9
51610: PUSH
51611: LD_VAR 0 53
51615: PUSH
51616: LD_VAR 0 54
51620: PUSH
51621: LD_VAR 0 55
51625: PUSH
51626: LD_VAR 0 56
51630: PUSH
51631: LD_VAR 0 57
51635: PUSH
51636: LD_VAR 0 58
51640: PUSH
51641: EMPTY
51642: LIST
51643: LIST
51644: LIST
51645: LIST
51646: LIST
51647: LIST
51648: PUSH
51649: LD_VAR 0 4
51653: PUSH
51654: LD_INT 1
51656: PLUS
51657: ARRAY
51658: ST_TO_ADDR
51659: GO 51768
51661: LD_INT 31
51663: DOUBLE
51664: EQUAL
51665: IFTRUE 51711
51667: LD_INT 32
51669: DOUBLE
51670: EQUAL
51671: IFTRUE 51711
51673: LD_INT 33
51675: DOUBLE
51676: EQUAL
51677: IFTRUE 51711
51679: LD_INT 27
51681: DOUBLE
51682: EQUAL
51683: IFTRUE 51711
51685: LD_INT 26
51687: DOUBLE
51688: EQUAL
51689: IFTRUE 51711
51691: LD_INT 28
51693: DOUBLE
51694: EQUAL
51695: IFTRUE 51711
51697: LD_INT 29
51699: DOUBLE
51700: EQUAL
51701: IFTRUE 51711
51703: LD_INT 30
51705: DOUBLE
51706: EQUAL
51707: IFTRUE 51711
51709: GO 51767
51711: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
51712: LD_ADDR_VAR 0 9
51716: PUSH
51717: LD_VAR 0 59
51721: PUSH
51722: LD_VAR 0 60
51726: PUSH
51727: LD_VAR 0 61
51731: PUSH
51732: LD_VAR 0 62
51736: PUSH
51737: LD_VAR 0 63
51741: PUSH
51742: LD_VAR 0 64
51746: PUSH
51747: EMPTY
51748: LIST
51749: LIST
51750: LIST
51751: LIST
51752: LIST
51753: LIST
51754: PUSH
51755: LD_VAR 0 4
51759: PUSH
51760: LD_INT 1
51762: PLUS
51763: ARRAY
51764: ST_TO_ADDR
51765: GO 51768
51767: POP
// temp_list2 = [ ] ;
51768: LD_ADDR_VAR 0 10
51772: PUSH
51773: EMPTY
51774: ST_TO_ADDR
// for i in temp_list do
51775: LD_ADDR_VAR 0 8
51779: PUSH
51780: LD_VAR 0 9
51784: PUSH
51785: FOR_IN
51786: IFFALSE 51838
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
51788: LD_ADDR_VAR 0 10
51792: PUSH
51793: LD_VAR 0 10
51797: PUSH
51798: LD_VAR 0 8
51802: PUSH
51803: LD_INT 1
51805: ARRAY
51806: PUSH
51807: LD_VAR 0 2
51811: PLUS
51812: PUSH
51813: LD_VAR 0 8
51817: PUSH
51818: LD_INT 2
51820: ARRAY
51821: PUSH
51822: LD_VAR 0 3
51826: PLUS
51827: PUSH
51828: EMPTY
51829: LIST
51830: LIST
51831: PUSH
51832: EMPTY
51833: LIST
51834: ADD
51835: ST_TO_ADDR
51836: GO 51785
51838: POP
51839: POP
// result = temp_list2 ;
51840: LD_ADDR_VAR 0 7
51844: PUSH
51845: LD_VAR 0 10
51849: ST_TO_ADDR
// end ;
51850: LD_VAR 0 7
51854: RET
// export function EnemyInRange ( unit , dist ) ; begin
51855: LD_INT 0
51857: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
51858: LD_ADDR_VAR 0 3
51862: PUSH
51863: LD_VAR 0 1
51867: PPUSH
51868: CALL_OW 255
51872: PPUSH
51873: LD_VAR 0 1
51877: PPUSH
51878: CALL_OW 250
51882: PPUSH
51883: LD_VAR 0 1
51887: PPUSH
51888: CALL_OW 251
51892: PPUSH
51893: LD_VAR 0 2
51897: PPUSH
51898: CALL 25257 0 4
51902: PUSH
51903: LD_INT 4
51905: ARRAY
51906: ST_TO_ADDR
// end ;
51907: LD_VAR 0 3
51911: RET
// export function PlayerSeeMe ( unit ) ; begin
51912: LD_INT 0
51914: PPUSH
// result := See ( your_side , unit ) ;
51915: LD_ADDR_VAR 0 2
51919: PUSH
51920: LD_OWVAR 2
51924: PPUSH
51925: LD_VAR 0 1
51929: PPUSH
51930: CALL_OW 292
51934: ST_TO_ADDR
// end ;
51935: LD_VAR 0 2
51939: RET
// export function ReverseDir ( unit ) ; begin
51940: LD_INT 0
51942: PPUSH
// if not unit then
51943: LD_VAR 0 1
51947: NOT
51948: IFFALSE 51952
// exit ;
51950: GO 51975
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
51952: LD_ADDR_VAR 0 2
51956: PUSH
51957: LD_VAR 0 1
51961: PPUSH
51962: CALL_OW 254
51966: PUSH
51967: LD_INT 3
51969: PLUS
51970: PUSH
51971: LD_INT 6
51973: MOD
51974: ST_TO_ADDR
// end ;
51975: LD_VAR 0 2
51979: RET
// export function ReverseArray ( array ) ; var i ; begin
51980: LD_INT 0
51982: PPUSH
51983: PPUSH
// if not array then
51984: LD_VAR 0 1
51988: NOT
51989: IFFALSE 51993
// exit ;
51991: GO 52048
// result := [ ] ;
51993: LD_ADDR_VAR 0 2
51997: PUSH
51998: EMPTY
51999: ST_TO_ADDR
// for i := array downto 1 do
52000: LD_ADDR_VAR 0 3
52004: PUSH
52005: DOUBLE
52006: LD_VAR 0 1
52010: INC
52011: ST_TO_ADDR
52012: LD_INT 1
52014: PUSH
52015: FOR_DOWNTO
52016: IFFALSE 52046
// result := Join ( result , array [ i ] ) ;
52018: LD_ADDR_VAR 0 2
52022: PUSH
52023: LD_VAR 0 2
52027: PPUSH
52028: LD_VAR 0 1
52032: PUSH
52033: LD_VAR 0 3
52037: ARRAY
52038: PPUSH
52039: CALL 56692 0 2
52043: ST_TO_ADDR
52044: GO 52015
52046: POP
52047: POP
// end ;
52048: LD_VAR 0 2
52052: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tdist , tmp , hex ; begin
52053: LD_INT 0
52055: PPUSH
52056: PPUSH
52057: PPUSH
52058: PPUSH
52059: PPUSH
52060: PPUSH
// if not unit or not hexes then
52061: LD_VAR 0 1
52065: NOT
52066: PUSH
52067: LD_VAR 0 2
52071: NOT
52072: OR
52073: IFFALSE 52077
// exit ;
52075: GO 52200
// dist := 9999 ;
52077: LD_ADDR_VAR 0 5
52081: PUSH
52082: LD_INT 9999
52084: ST_TO_ADDR
// for i = 1 to hexes do
52085: LD_ADDR_VAR 0 4
52089: PUSH
52090: DOUBLE
52091: LD_INT 1
52093: DEC
52094: ST_TO_ADDR
52095: LD_VAR 0 2
52099: PUSH
52100: FOR_TO
52101: IFFALSE 52188
// begin tdist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
52103: LD_ADDR_VAR 0 6
52107: PUSH
52108: LD_VAR 0 1
52112: PPUSH
52113: LD_VAR 0 2
52117: PUSH
52118: LD_VAR 0 4
52122: ARRAY
52123: PUSH
52124: LD_INT 1
52126: ARRAY
52127: PPUSH
52128: LD_VAR 0 2
52132: PUSH
52133: LD_VAR 0 4
52137: ARRAY
52138: PUSH
52139: LD_INT 2
52141: ARRAY
52142: PPUSH
52143: CALL_OW 297
52147: ST_TO_ADDR
// if tdist < dist then
52148: LD_VAR 0 6
52152: PUSH
52153: LD_VAR 0 5
52157: LESS
52158: IFFALSE 52186
// begin hex := hexes [ i ] ;
52160: LD_ADDR_VAR 0 8
52164: PUSH
52165: LD_VAR 0 2
52169: PUSH
52170: LD_VAR 0 4
52174: ARRAY
52175: ST_TO_ADDR
// dist := tdist ;
52176: LD_ADDR_VAR 0 5
52180: PUSH
52181: LD_VAR 0 6
52185: ST_TO_ADDR
// end ; end ;
52186: GO 52100
52188: POP
52189: POP
// result := hex ;
52190: LD_ADDR_VAR 0 3
52194: PUSH
52195: LD_VAR 0 8
52199: ST_TO_ADDR
// end ;
52200: LD_VAR 0 3
52204: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
52205: LD_INT 0
52207: PPUSH
52208: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
52209: LD_VAR 0 1
52213: NOT
52214: PUSH
52215: LD_VAR 0 1
52219: PUSH
52220: LD_INT 21
52222: PUSH
52223: LD_INT 2
52225: PUSH
52226: EMPTY
52227: LIST
52228: LIST
52229: PUSH
52230: LD_INT 23
52232: PUSH
52233: LD_INT 2
52235: PUSH
52236: EMPTY
52237: LIST
52238: LIST
52239: PUSH
52240: EMPTY
52241: LIST
52242: LIST
52243: PPUSH
52244: CALL_OW 69
52248: IN
52249: NOT
52250: OR
52251: IFFALSE 52255
// exit ;
52253: GO 52302
// for i = 1 to 3 do
52255: LD_ADDR_VAR 0 3
52259: PUSH
52260: DOUBLE
52261: LD_INT 1
52263: DEC
52264: ST_TO_ADDR
52265: LD_INT 3
52267: PUSH
52268: FOR_TO
52269: IFFALSE 52300
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
52271: LD_VAR 0 1
52275: PPUSH
52276: CALL_OW 250
52280: PPUSH
52281: LD_VAR 0 1
52285: PPUSH
52286: CALL_OW 251
52290: PPUSH
52291: LD_INT 1
52293: PPUSH
52294: CALL_OW 453
52298: GO 52268
52300: POP
52301: POP
// end ;
52302: LD_VAR 0 2
52306: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
52307: LD_INT 0
52309: PPUSH
52310: PPUSH
52311: PPUSH
52312: PPUSH
52313: PPUSH
52314: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
52315: LD_VAR 0 1
52319: NOT
52320: PUSH
52321: LD_VAR 0 2
52325: NOT
52326: OR
52327: PUSH
52328: LD_VAR 0 1
52332: PPUSH
52333: CALL_OW 314
52337: OR
52338: IFFALSE 52342
// exit ;
52340: GO 52809
// if GetLives ( i ) < 250 then
52342: LD_VAR 0 4
52346: PPUSH
52347: CALL_OW 256
52351: PUSH
52352: LD_INT 250
52354: LESS
52355: IFFALSE 52368
// begin ComAutodestruct ( i ) ;
52357: LD_VAR 0 4
52361: PPUSH
52362: CALL 52205 0 1
// exit ;
52366: GO 52809
// end ; x := GetX ( enemy_unit ) ;
52368: LD_ADDR_VAR 0 7
52372: PUSH
52373: LD_VAR 0 2
52377: PPUSH
52378: CALL_OW 250
52382: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
52383: LD_ADDR_VAR 0 8
52387: PUSH
52388: LD_VAR 0 2
52392: PPUSH
52393: CALL_OW 251
52397: ST_TO_ADDR
// if not x or not y then
52398: LD_VAR 0 7
52402: NOT
52403: PUSH
52404: LD_VAR 0 8
52408: NOT
52409: OR
52410: IFFALSE 52414
// exit ;
52412: GO 52809
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
52414: LD_ADDR_VAR 0 6
52418: PUSH
52419: LD_VAR 0 7
52423: PPUSH
52424: LD_INT 0
52426: PPUSH
52427: LD_INT 4
52429: PPUSH
52430: CALL_OW 272
52434: PUSH
52435: LD_VAR 0 8
52439: PPUSH
52440: LD_INT 0
52442: PPUSH
52443: LD_INT 4
52445: PPUSH
52446: CALL_OW 273
52450: PUSH
52451: EMPTY
52452: LIST
52453: LIST
52454: PUSH
52455: LD_VAR 0 7
52459: PPUSH
52460: LD_INT 1
52462: PPUSH
52463: LD_INT 4
52465: PPUSH
52466: CALL_OW 272
52470: PUSH
52471: LD_VAR 0 8
52475: PPUSH
52476: LD_INT 1
52478: PPUSH
52479: LD_INT 4
52481: PPUSH
52482: CALL_OW 273
52486: PUSH
52487: EMPTY
52488: LIST
52489: LIST
52490: PUSH
52491: LD_VAR 0 7
52495: PPUSH
52496: LD_INT 2
52498: PPUSH
52499: LD_INT 4
52501: PPUSH
52502: CALL_OW 272
52506: PUSH
52507: LD_VAR 0 8
52511: PPUSH
52512: LD_INT 2
52514: PPUSH
52515: LD_INT 4
52517: PPUSH
52518: CALL_OW 273
52522: PUSH
52523: EMPTY
52524: LIST
52525: LIST
52526: PUSH
52527: LD_VAR 0 7
52531: PPUSH
52532: LD_INT 3
52534: PPUSH
52535: LD_INT 4
52537: PPUSH
52538: CALL_OW 272
52542: PUSH
52543: LD_VAR 0 8
52547: PPUSH
52548: LD_INT 3
52550: PPUSH
52551: LD_INT 4
52553: PPUSH
52554: CALL_OW 273
52558: PUSH
52559: EMPTY
52560: LIST
52561: LIST
52562: PUSH
52563: LD_VAR 0 7
52567: PPUSH
52568: LD_INT 4
52570: PPUSH
52571: LD_INT 4
52573: PPUSH
52574: CALL_OW 272
52578: PUSH
52579: LD_VAR 0 8
52583: PPUSH
52584: LD_INT 4
52586: PPUSH
52587: LD_INT 4
52589: PPUSH
52590: CALL_OW 273
52594: PUSH
52595: EMPTY
52596: LIST
52597: LIST
52598: PUSH
52599: LD_VAR 0 7
52603: PPUSH
52604: LD_INT 5
52606: PPUSH
52607: LD_INT 4
52609: PPUSH
52610: CALL_OW 272
52614: PUSH
52615: LD_VAR 0 8
52619: PPUSH
52620: LD_INT 5
52622: PPUSH
52623: LD_INT 4
52625: PPUSH
52626: CALL_OW 273
52630: PUSH
52631: EMPTY
52632: LIST
52633: LIST
52634: PUSH
52635: EMPTY
52636: LIST
52637: LIST
52638: LIST
52639: LIST
52640: LIST
52641: LIST
52642: ST_TO_ADDR
// for i = tmp downto 1 do
52643: LD_ADDR_VAR 0 4
52647: PUSH
52648: DOUBLE
52649: LD_VAR 0 6
52653: INC
52654: ST_TO_ADDR
52655: LD_INT 1
52657: PUSH
52658: FOR_DOWNTO
52659: IFFALSE 52760
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
52661: LD_VAR 0 6
52665: PUSH
52666: LD_VAR 0 4
52670: ARRAY
52671: PUSH
52672: LD_INT 1
52674: ARRAY
52675: PPUSH
52676: LD_VAR 0 6
52680: PUSH
52681: LD_VAR 0 4
52685: ARRAY
52686: PUSH
52687: LD_INT 2
52689: ARRAY
52690: PPUSH
52691: CALL_OW 488
52695: NOT
52696: PUSH
52697: LD_VAR 0 6
52701: PUSH
52702: LD_VAR 0 4
52706: ARRAY
52707: PUSH
52708: LD_INT 1
52710: ARRAY
52711: PPUSH
52712: LD_VAR 0 6
52716: PUSH
52717: LD_VAR 0 4
52721: ARRAY
52722: PUSH
52723: LD_INT 2
52725: ARRAY
52726: PPUSH
52727: CALL_OW 428
52731: PUSH
52732: LD_INT 0
52734: NONEQUAL
52735: OR
52736: IFFALSE 52758
// tmp := Delete ( tmp , i ) ;
52738: LD_ADDR_VAR 0 6
52742: PUSH
52743: LD_VAR 0 6
52747: PPUSH
52748: LD_VAR 0 4
52752: PPUSH
52753: CALL_OW 3
52757: ST_TO_ADDR
52758: GO 52658
52760: POP
52761: POP
// j := GetClosestHex ( unit , tmp ) ;
52762: LD_ADDR_VAR 0 5
52766: PUSH
52767: LD_VAR 0 1
52771: PPUSH
52772: LD_VAR 0 6
52776: PPUSH
52777: CALL 52053 0 2
52781: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
52782: LD_VAR 0 1
52786: PPUSH
52787: LD_VAR 0 5
52791: PUSH
52792: LD_INT 1
52794: ARRAY
52795: PPUSH
52796: LD_VAR 0 5
52800: PUSH
52801: LD_INT 2
52803: ARRAY
52804: PPUSH
52805: CALL_OW 111
// end ;
52809: LD_VAR 0 3
52813: RET
// export function PrepareApemanSoldier ( ) ; begin
52814: LD_INT 0
52816: PPUSH
// uc_nation := 0 ;
52817: LD_ADDR_OWVAR 21
52821: PUSH
52822: LD_INT 0
52824: ST_TO_ADDR
// hc_sex := sex_male ;
52825: LD_ADDR_OWVAR 27
52829: PUSH
52830: LD_INT 1
52832: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
52833: LD_ADDR_OWVAR 28
52837: PUSH
52838: LD_INT 15
52840: ST_TO_ADDR
// hc_gallery :=  ;
52841: LD_ADDR_OWVAR 33
52845: PUSH
52846: LD_STRING 
52848: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
52849: LD_ADDR_OWVAR 31
52853: PUSH
52854: LD_INT 0
52856: PPUSH
52857: LD_INT 3
52859: PPUSH
52860: CALL_OW 12
52864: PUSH
52865: LD_INT 0
52867: PPUSH
52868: LD_INT 3
52870: PPUSH
52871: CALL_OW 12
52875: PUSH
52876: LD_INT 0
52878: PUSH
52879: LD_INT 0
52881: PUSH
52882: EMPTY
52883: LIST
52884: LIST
52885: LIST
52886: LIST
52887: ST_TO_ADDR
// end ;
52888: LD_VAR 0 1
52892: RET
// export function PrepareApemanEngineer ( ) ; begin
52893: LD_INT 0
52895: PPUSH
// uc_nation := 0 ;
52896: LD_ADDR_OWVAR 21
52900: PUSH
52901: LD_INT 0
52903: ST_TO_ADDR
// hc_sex := sex_male ;
52904: LD_ADDR_OWVAR 27
52908: PUSH
52909: LD_INT 1
52911: ST_TO_ADDR
// hc_class := class_apeman_engineer ;
52912: LD_ADDR_OWVAR 28
52916: PUSH
52917: LD_INT 16
52919: ST_TO_ADDR
// hc_gallery :=  ;
52920: LD_ADDR_OWVAR 33
52924: PUSH
52925: LD_STRING 
52927: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
52928: LD_ADDR_OWVAR 31
52932: PUSH
52933: LD_INT 0
52935: PPUSH
52936: LD_INT 3
52938: PPUSH
52939: CALL_OW 12
52943: PUSH
52944: LD_INT 0
52946: PPUSH
52947: LD_INT 3
52949: PPUSH
52950: CALL_OW 12
52954: PUSH
52955: LD_INT 0
52957: PUSH
52958: LD_INT 0
52960: PUSH
52961: EMPTY
52962: LIST
52963: LIST
52964: LIST
52965: LIST
52966: ST_TO_ADDR
// end ;
52967: LD_VAR 0 1
52971: RET
// export function PrepareApeman ( agressivity ) ; begin
52972: LD_INT 0
52974: PPUSH
// uc_side := 0 ;
52975: LD_ADDR_OWVAR 20
52979: PUSH
52980: LD_INT 0
52982: ST_TO_ADDR
// uc_nation := 0 ;
52983: LD_ADDR_OWVAR 21
52987: PUSH
52988: LD_INT 0
52990: ST_TO_ADDR
// hc_sex := sex_male ;
52991: LD_ADDR_OWVAR 27
52995: PUSH
52996: LD_INT 1
52998: ST_TO_ADDR
// hc_class := class_apeman ;
52999: LD_ADDR_OWVAR 28
53003: PUSH
53004: LD_INT 12
53006: ST_TO_ADDR
// hc_gallery :=  ;
53007: LD_ADDR_OWVAR 33
53011: PUSH
53012: LD_STRING 
53014: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
53015: LD_ADDR_OWVAR 35
53019: PUSH
53020: LD_VAR 0 1
53024: NEG
53025: PPUSH
53026: LD_VAR 0 1
53030: PPUSH
53031: CALL_OW 12
53035: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
53036: LD_ADDR_OWVAR 31
53040: PUSH
53041: LD_INT 0
53043: PPUSH
53044: LD_INT 3
53046: PPUSH
53047: CALL_OW 12
53051: PUSH
53052: LD_INT 0
53054: PPUSH
53055: LD_INT 3
53057: PPUSH
53058: CALL_OW 12
53062: PUSH
53063: LD_INT 0
53065: PUSH
53066: LD_INT 0
53068: PUSH
53069: EMPTY
53070: LIST
53071: LIST
53072: LIST
53073: LIST
53074: ST_TO_ADDR
// end ;
53075: LD_VAR 0 2
53079: RET
// export function PrepareTiger ( agressivity ) ; begin
53080: LD_INT 0
53082: PPUSH
// uc_side := 0 ;
53083: LD_ADDR_OWVAR 20
53087: PUSH
53088: LD_INT 0
53090: ST_TO_ADDR
// uc_nation := 0 ;
53091: LD_ADDR_OWVAR 21
53095: PUSH
53096: LD_INT 0
53098: ST_TO_ADDR
// hc_class := class_tiger ;
53099: LD_ADDR_OWVAR 28
53103: PUSH
53104: LD_INT 14
53106: ST_TO_ADDR
// hc_gallery :=  ;
53107: LD_ADDR_OWVAR 33
53111: PUSH
53112: LD_STRING 
53114: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
53115: LD_ADDR_OWVAR 35
53119: PUSH
53120: LD_VAR 0 1
53124: NEG
53125: PPUSH
53126: LD_VAR 0 1
53130: PPUSH
53131: CALL_OW 12
53135: ST_TO_ADDR
// end ;
53136: LD_VAR 0 2
53140: RET
// export function PrepareEnchidna ( ) ; begin
53141: LD_INT 0
53143: PPUSH
// uc_side := 0 ;
53144: LD_ADDR_OWVAR 20
53148: PUSH
53149: LD_INT 0
53151: ST_TO_ADDR
// uc_nation := 0 ;
53152: LD_ADDR_OWVAR 21
53156: PUSH
53157: LD_INT 0
53159: ST_TO_ADDR
// hc_class := class_baggie ;
53160: LD_ADDR_OWVAR 28
53164: PUSH
53165: LD_INT 13
53167: ST_TO_ADDR
// hc_gallery :=  ;
53168: LD_ADDR_OWVAR 33
53172: PUSH
53173: LD_STRING 
53175: ST_TO_ADDR
// end ;
53176: LD_VAR 0 1
53180: RET
// export function PrepareFrog ( ) ; begin
53181: LD_INT 0
53183: PPUSH
// uc_side := 0 ;
53184: LD_ADDR_OWVAR 20
53188: PUSH
53189: LD_INT 0
53191: ST_TO_ADDR
// uc_nation := 0 ;
53192: LD_ADDR_OWVAR 21
53196: PUSH
53197: LD_INT 0
53199: ST_TO_ADDR
// hc_class := class_frog ;
53200: LD_ADDR_OWVAR 28
53204: PUSH
53205: LD_INT 19
53207: ST_TO_ADDR
// hc_gallery :=  ;
53208: LD_ADDR_OWVAR 33
53212: PUSH
53213: LD_STRING 
53215: ST_TO_ADDR
// end ;
53216: LD_VAR 0 1
53220: RET
// export function PrepareFish ( ) ; begin
53221: LD_INT 0
53223: PPUSH
// uc_side := 0 ;
53224: LD_ADDR_OWVAR 20
53228: PUSH
53229: LD_INT 0
53231: ST_TO_ADDR
// uc_nation := 0 ;
53232: LD_ADDR_OWVAR 21
53236: PUSH
53237: LD_INT 0
53239: ST_TO_ADDR
// hc_class := class_fish ;
53240: LD_ADDR_OWVAR 28
53244: PUSH
53245: LD_INT 20
53247: ST_TO_ADDR
// hc_gallery :=  ;
53248: LD_ADDR_OWVAR 33
53252: PUSH
53253: LD_STRING 
53255: ST_TO_ADDR
// end ;
53256: LD_VAR 0 1
53260: RET
// export function PrepareBird ( ) ; begin
53261: LD_INT 0
53263: PPUSH
// uc_side := 0 ;
53264: LD_ADDR_OWVAR 20
53268: PUSH
53269: LD_INT 0
53271: ST_TO_ADDR
// uc_nation := 0 ;
53272: LD_ADDR_OWVAR 21
53276: PUSH
53277: LD_INT 0
53279: ST_TO_ADDR
// hc_class := class_phororhacos ;
53280: LD_ADDR_OWVAR 28
53284: PUSH
53285: LD_INT 18
53287: ST_TO_ADDR
// hc_gallery :=  ;
53288: LD_ADDR_OWVAR 33
53292: PUSH
53293: LD_STRING 
53295: ST_TO_ADDR
// end ;
53296: LD_VAR 0 1
53300: RET
// export function PrepareHorse ( ) ; begin
53301: LD_INT 0
53303: PPUSH
// uc_side := 0 ;
53304: LD_ADDR_OWVAR 20
53308: PUSH
53309: LD_INT 0
53311: ST_TO_ADDR
// uc_nation := 0 ;
53312: LD_ADDR_OWVAR 21
53316: PUSH
53317: LD_INT 0
53319: ST_TO_ADDR
// hc_class := class_horse ;
53320: LD_ADDR_OWVAR 28
53324: PUSH
53325: LD_INT 21
53327: ST_TO_ADDR
// hc_gallery :=  ;
53328: LD_ADDR_OWVAR 33
53332: PUSH
53333: LD_STRING 
53335: ST_TO_ADDR
// end ;
53336: LD_VAR 0 1
53340: RET
// export function PrepareMastodont ( ) ; begin
53341: LD_INT 0
53343: PPUSH
// uc_side := 0 ;
53344: LD_ADDR_OWVAR 20
53348: PUSH
53349: LD_INT 0
53351: ST_TO_ADDR
// uc_nation := 0 ;
53352: LD_ADDR_OWVAR 21
53356: PUSH
53357: LD_INT 0
53359: ST_TO_ADDR
// vc_chassis := class_mastodont ;
53360: LD_ADDR_OWVAR 37
53364: PUSH
53365: LD_INT 31
53367: ST_TO_ADDR
// vc_control := control_rider ;
53368: LD_ADDR_OWVAR 38
53372: PUSH
53373: LD_INT 4
53375: ST_TO_ADDR
// end ;
53376: LD_VAR 0 1
53380: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
53381: LD_INT 0
53383: PPUSH
53384: PPUSH
53385: PPUSH
// uc_side = 0 ;
53386: LD_ADDR_OWVAR 20
53390: PUSH
53391: LD_INT 0
53393: ST_TO_ADDR
// uc_nation = 0 ;
53394: LD_ADDR_OWVAR 21
53398: PUSH
53399: LD_INT 0
53401: ST_TO_ADDR
// InitHc_All ( ) ;
53402: CALL_OW 584
// InitVc ;
53406: CALL_OW 20
// if mastodonts then
53410: LD_VAR 0 6
53414: IFFALSE 53481
// for i = 1 to mastodonts do
53416: LD_ADDR_VAR 0 11
53420: PUSH
53421: DOUBLE
53422: LD_INT 1
53424: DEC
53425: ST_TO_ADDR
53426: LD_VAR 0 6
53430: PUSH
53431: FOR_TO
53432: IFFALSE 53479
// begin vc_chassis := 31 ;
53434: LD_ADDR_OWVAR 37
53438: PUSH
53439: LD_INT 31
53441: ST_TO_ADDR
// vc_control := control_rider ;
53442: LD_ADDR_OWVAR 38
53446: PUSH
53447: LD_INT 4
53449: ST_TO_ADDR
// animal := CreateVehicle ;
53450: LD_ADDR_VAR 0 12
53454: PUSH
53455: CALL_OW 45
53459: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
53460: LD_VAR 0 12
53464: PPUSH
53465: LD_VAR 0 8
53469: PPUSH
53470: LD_INT 0
53472: PPUSH
53473: CALL 55609 0 3
// end ;
53477: GO 53431
53479: POP
53480: POP
// if horses then
53481: LD_VAR 0 5
53485: IFFALSE 53552
// for i = 1 to horses do
53487: LD_ADDR_VAR 0 11
53491: PUSH
53492: DOUBLE
53493: LD_INT 1
53495: DEC
53496: ST_TO_ADDR
53497: LD_VAR 0 5
53501: PUSH
53502: FOR_TO
53503: IFFALSE 53550
// begin hc_class := 21 ;
53505: LD_ADDR_OWVAR 28
53509: PUSH
53510: LD_INT 21
53512: ST_TO_ADDR
// hc_gallery :=  ;
53513: LD_ADDR_OWVAR 33
53517: PUSH
53518: LD_STRING 
53520: ST_TO_ADDR
// animal := CreateHuman ;
53521: LD_ADDR_VAR 0 12
53525: PUSH
53526: CALL_OW 44
53530: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
53531: LD_VAR 0 12
53535: PPUSH
53536: LD_VAR 0 8
53540: PPUSH
53541: LD_INT 0
53543: PPUSH
53544: CALL 55609 0 3
// end ;
53548: GO 53502
53550: POP
53551: POP
// if birds then
53552: LD_VAR 0 1
53556: IFFALSE 53623
// for i = 1 to birds do
53558: LD_ADDR_VAR 0 11
53562: PUSH
53563: DOUBLE
53564: LD_INT 1
53566: DEC
53567: ST_TO_ADDR
53568: LD_VAR 0 1
53572: PUSH
53573: FOR_TO
53574: IFFALSE 53621
// begin hc_class = 18 ;
53576: LD_ADDR_OWVAR 28
53580: PUSH
53581: LD_INT 18
53583: ST_TO_ADDR
// hc_gallery =  ;
53584: LD_ADDR_OWVAR 33
53588: PUSH
53589: LD_STRING 
53591: ST_TO_ADDR
// animal := CreateHuman ;
53592: LD_ADDR_VAR 0 12
53596: PUSH
53597: CALL_OW 44
53601: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
53602: LD_VAR 0 12
53606: PPUSH
53607: LD_VAR 0 8
53611: PPUSH
53612: LD_INT 0
53614: PPUSH
53615: CALL 55609 0 3
// end ;
53619: GO 53573
53621: POP
53622: POP
// if tigers then
53623: LD_VAR 0 2
53627: IFFALSE 53711
// for i = 1 to tigers do
53629: LD_ADDR_VAR 0 11
53633: PUSH
53634: DOUBLE
53635: LD_INT 1
53637: DEC
53638: ST_TO_ADDR
53639: LD_VAR 0 2
53643: PUSH
53644: FOR_TO
53645: IFFALSE 53709
// begin hc_class = class_tiger ;
53647: LD_ADDR_OWVAR 28
53651: PUSH
53652: LD_INT 14
53654: ST_TO_ADDR
// hc_gallery =  ;
53655: LD_ADDR_OWVAR 33
53659: PUSH
53660: LD_STRING 
53662: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
53663: LD_ADDR_OWVAR 35
53667: PUSH
53668: LD_INT 7
53670: NEG
53671: PPUSH
53672: LD_INT 7
53674: PPUSH
53675: CALL_OW 12
53679: ST_TO_ADDR
// animal := CreateHuman ;
53680: LD_ADDR_VAR 0 12
53684: PUSH
53685: CALL_OW 44
53689: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
53690: LD_VAR 0 12
53694: PPUSH
53695: LD_VAR 0 8
53699: PPUSH
53700: LD_INT 0
53702: PPUSH
53703: CALL 55609 0 3
// end ;
53707: GO 53644
53709: POP
53710: POP
// if apemans then
53711: LD_VAR 0 3
53715: IFFALSE 53838
// for i = 1 to apemans do
53717: LD_ADDR_VAR 0 11
53721: PUSH
53722: DOUBLE
53723: LD_INT 1
53725: DEC
53726: ST_TO_ADDR
53727: LD_VAR 0 3
53731: PUSH
53732: FOR_TO
53733: IFFALSE 53836
// begin hc_class = class_apeman ;
53735: LD_ADDR_OWVAR 28
53739: PUSH
53740: LD_INT 12
53742: ST_TO_ADDR
// hc_gallery =  ;
53743: LD_ADDR_OWVAR 33
53747: PUSH
53748: LD_STRING 
53750: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
53751: LD_ADDR_OWVAR 35
53755: PUSH
53756: LD_INT 2
53758: NEG
53759: PPUSH
53760: LD_INT 2
53762: PPUSH
53763: CALL_OW 12
53767: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
53768: LD_ADDR_OWVAR 31
53772: PUSH
53773: LD_INT 1
53775: PPUSH
53776: LD_INT 3
53778: PPUSH
53779: CALL_OW 12
53783: PUSH
53784: LD_INT 1
53786: PPUSH
53787: LD_INT 3
53789: PPUSH
53790: CALL_OW 12
53794: PUSH
53795: LD_INT 0
53797: PUSH
53798: LD_INT 0
53800: PUSH
53801: EMPTY
53802: LIST
53803: LIST
53804: LIST
53805: LIST
53806: ST_TO_ADDR
// animal := CreateHuman ;
53807: LD_ADDR_VAR 0 12
53811: PUSH
53812: CALL_OW 44
53816: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
53817: LD_VAR 0 12
53821: PPUSH
53822: LD_VAR 0 8
53826: PPUSH
53827: LD_INT 0
53829: PPUSH
53830: CALL 55609 0 3
// end ;
53834: GO 53732
53836: POP
53837: POP
// if enchidnas then
53838: LD_VAR 0 4
53842: IFFALSE 53909
// for i = 1 to enchidnas do
53844: LD_ADDR_VAR 0 11
53848: PUSH
53849: DOUBLE
53850: LD_INT 1
53852: DEC
53853: ST_TO_ADDR
53854: LD_VAR 0 4
53858: PUSH
53859: FOR_TO
53860: IFFALSE 53907
// begin hc_class = 13 ;
53862: LD_ADDR_OWVAR 28
53866: PUSH
53867: LD_INT 13
53869: ST_TO_ADDR
// hc_gallery =  ;
53870: LD_ADDR_OWVAR 33
53874: PUSH
53875: LD_STRING 
53877: ST_TO_ADDR
// animal := CreateHuman ;
53878: LD_ADDR_VAR 0 12
53882: PUSH
53883: CALL_OW 44
53887: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
53888: LD_VAR 0 12
53892: PPUSH
53893: LD_VAR 0 8
53897: PPUSH
53898: LD_INT 0
53900: PPUSH
53901: CALL 55609 0 3
// end ;
53905: GO 53859
53907: POP
53908: POP
// if fishes then
53909: LD_VAR 0 7
53913: IFFALSE 53980
// for i = 1 to fishes do
53915: LD_ADDR_VAR 0 11
53919: PUSH
53920: DOUBLE
53921: LD_INT 1
53923: DEC
53924: ST_TO_ADDR
53925: LD_VAR 0 7
53929: PUSH
53930: FOR_TO
53931: IFFALSE 53978
// begin hc_class = 20 ;
53933: LD_ADDR_OWVAR 28
53937: PUSH
53938: LD_INT 20
53940: ST_TO_ADDR
// hc_gallery =  ;
53941: LD_ADDR_OWVAR 33
53945: PUSH
53946: LD_STRING 
53948: ST_TO_ADDR
// animal := CreateHuman ;
53949: LD_ADDR_VAR 0 12
53953: PUSH
53954: CALL_OW 44
53958: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
53959: LD_VAR 0 12
53963: PPUSH
53964: LD_VAR 0 9
53968: PPUSH
53969: LD_INT 0
53971: PPUSH
53972: CALL 55609 0 3
// end ;
53976: GO 53930
53978: POP
53979: POP
// end ;
53980: LD_VAR 0 10
53984: RET
// export function WantHeal ( sci , unit ) ; begin
53985: LD_INT 0
53987: PPUSH
// if GetTaskList ( sci ) > 0 then
53988: LD_VAR 0 1
53992: PPUSH
53993: CALL_OW 437
53997: PUSH
53998: LD_INT 0
54000: GREATER
54001: IFFALSE 54071
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
54003: LD_VAR 0 1
54007: PPUSH
54008: CALL_OW 437
54012: PUSH
54013: LD_INT 1
54015: ARRAY
54016: PUSH
54017: LD_INT 1
54019: ARRAY
54020: PUSH
54021: LD_STRING l
54023: EQUAL
54024: PUSH
54025: LD_VAR 0 1
54029: PPUSH
54030: CALL_OW 437
54034: PUSH
54035: LD_INT 1
54037: ARRAY
54038: PUSH
54039: LD_INT 4
54041: ARRAY
54042: PUSH
54043: LD_VAR 0 2
54047: EQUAL
54048: AND
54049: IFFALSE 54061
// result := true else
54051: LD_ADDR_VAR 0 3
54055: PUSH
54056: LD_INT 1
54058: ST_TO_ADDR
54059: GO 54069
// result := false ;
54061: LD_ADDR_VAR 0 3
54065: PUSH
54066: LD_INT 0
54068: ST_TO_ADDR
// end else
54069: GO 54079
// result := false ;
54071: LD_ADDR_VAR 0 3
54075: PUSH
54076: LD_INT 0
54078: ST_TO_ADDR
// end ;
54079: LD_VAR 0 3
54083: RET
// export function HealTarget ( sci ) ; begin
54084: LD_INT 0
54086: PPUSH
// if not sci then
54087: LD_VAR 0 1
54091: NOT
54092: IFFALSE 54096
// exit ;
54094: GO 54161
// result := 0 ;
54096: LD_ADDR_VAR 0 2
54100: PUSH
54101: LD_INT 0
54103: ST_TO_ADDR
// if GetTaskList ( sci ) then
54104: LD_VAR 0 1
54108: PPUSH
54109: CALL_OW 437
54113: IFFALSE 54161
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
54115: LD_VAR 0 1
54119: PPUSH
54120: CALL_OW 437
54124: PUSH
54125: LD_INT 1
54127: ARRAY
54128: PUSH
54129: LD_INT 1
54131: ARRAY
54132: PUSH
54133: LD_STRING l
54135: EQUAL
54136: IFFALSE 54161
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
54138: LD_ADDR_VAR 0 2
54142: PUSH
54143: LD_VAR 0 1
54147: PPUSH
54148: CALL_OW 437
54152: PUSH
54153: LD_INT 1
54155: ARRAY
54156: PUSH
54157: LD_INT 4
54159: ARRAY
54160: ST_TO_ADDR
// end ;
54161: LD_VAR 0 2
54165: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
54166: LD_INT 0
54168: PPUSH
54169: PPUSH
54170: PPUSH
54171: PPUSH
// if not base_units then
54172: LD_VAR 0 1
54176: NOT
54177: IFFALSE 54181
// exit ;
54179: GO 54268
// result := false ;
54181: LD_ADDR_VAR 0 2
54185: PUSH
54186: LD_INT 0
54188: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
54189: LD_ADDR_VAR 0 5
54193: PUSH
54194: LD_VAR 0 1
54198: PPUSH
54199: LD_INT 21
54201: PUSH
54202: LD_INT 3
54204: PUSH
54205: EMPTY
54206: LIST
54207: LIST
54208: PPUSH
54209: CALL_OW 72
54213: ST_TO_ADDR
// if not tmp then
54214: LD_VAR 0 5
54218: NOT
54219: IFFALSE 54223
// exit ;
54221: GO 54268
// for i in tmp do
54223: LD_ADDR_VAR 0 3
54227: PUSH
54228: LD_VAR 0 5
54232: PUSH
54233: FOR_IN
54234: IFFALSE 54266
// begin result := EnemyInRange ( i , 22 ) ;
54236: LD_ADDR_VAR 0 2
54240: PUSH
54241: LD_VAR 0 3
54245: PPUSH
54246: LD_INT 22
54248: PPUSH
54249: CALL 51855 0 2
54253: ST_TO_ADDR
// if result then
54254: LD_VAR 0 2
54258: IFFALSE 54264
// exit ;
54260: POP
54261: POP
54262: GO 54268
// end ;
54264: GO 54233
54266: POP
54267: POP
// end ;
54268: LD_VAR 0 2
54272: RET
// export function FilterByTag ( units , tag ) ; begin
54273: LD_INT 0
54275: PPUSH
// result := UnitFilter ( units , [ f_tag , tag ] ) ;
54276: LD_ADDR_VAR 0 3
54280: PUSH
54281: LD_VAR 0 1
54285: PPUSH
54286: LD_INT 120
54288: PUSH
54289: LD_VAR 0 2
54293: PUSH
54294: EMPTY
54295: LIST
54296: LIST
54297: PPUSH
54298: CALL_OW 72
54302: ST_TO_ADDR
// end ;
54303: LD_VAR 0 3
54307: RET
// export function IsDriver ( un ) ; begin
54308: LD_INT 0
54310: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
54311: LD_ADDR_VAR 0 2
54315: PUSH
54316: LD_VAR 0 1
54320: PUSH
54321: LD_INT 55
54323: PUSH
54324: EMPTY
54325: LIST
54326: PPUSH
54327: CALL_OW 69
54331: IN
54332: ST_TO_ADDR
// end ;
54333: LD_VAR 0 2
54337: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
54338: LD_INT 0
54340: PPUSH
54341: PPUSH
// list := [ ] ;
54342: LD_ADDR_VAR 0 5
54346: PUSH
54347: EMPTY
54348: ST_TO_ADDR
// case d of 0 :
54349: LD_VAR 0 3
54353: PUSH
54354: LD_INT 0
54356: DOUBLE
54357: EQUAL
54358: IFTRUE 54362
54360: GO 54495
54362: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
54363: LD_ADDR_VAR 0 5
54367: PUSH
54368: LD_VAR 0 1
54372: PUSH
54373: LD_INT 4
54375: MINUS
54376: PUSH
54377: LD_VAR 0 2
54381: PUSH
54382: LD_INT 4
54384: MINUS
54385: PUSH
54386: LD_INT 2
54388: PUSH
54389: EMPTY
54390: LIST
54391: LIST
54392: LIST
54393: PUSH
54394: LD_VAR 0 1
54398: PUSH
54399: LD_INT 3
54401: MINUS
54402: PUSH
54403: LD_VAR 0 2
54407: PUSH
54408: LD_INT 1
54410: PUSH
54411: EMPTY
54412: LIST
54413: LIST
54414: LIST
54415: PUSH
54416: LD_VAR 0 1
54420: PUSH
54421: LD_INT 4
54423: PLUS
54424: PUSH
54425: LD_VAR 0 2
54429: PUSH
54430: LD_INT 4
54432: PUSH
54433: EMPTY
54434: LIST
54435: LIST
54436: LIST
54437: PUSH
54438: LD_VAR 0 1
54442: PUSH
54443: LD_INT 3
54445: PLUS
54446: PUSH
54447: LD_VAR 0 2
54451: PUSH
54452: LD_INT 3
54454: PLUS
54455: PUSH
54456: LD_INT 5
54458: PUSH
54459: EMPTY
54460: LIST
54461: LIST
54462: LIST
54463: PUSH
54464: LD_VAR 0 1
54468: PUSH
54469: LD_VAR 0 2
54473: PUSH
54474: LD_INT 4
54476: PLUS
54477: PUSH
54478: LD_INT 0
54480: PUSH
54481: EMPTY
54482: LIST
54483: LIST
54484: LIST
54485: PUSH
54486: EMPTY
54487: LIST
54488: LIST
54489: LIST
54490: LIST
54491: LIST
54492: ST_TO_ADDR
// end ; 1 :
54493: GO 55193
54495: LD_INT 1
54497: DOUBLE
54498: EQUAL
54499: IFTRUE 54503
54501: GO 54636
54503: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
54504: LD_ADDR_VAR 0 5
54508: PUSH
54509: LD_VAR 0 1
54513: PUSH
54514: LD_VAR 0 2
54518: PUSH
54519: LD_INT 4
54521: MINUS
54522: PUSH
54523: LD_INT 3
54525: PUSH
54526: EMPTY
54527: LIST
54528: LIST
54529: LIST
54530: PUSH
54531: LD_VAR 0 1
54535: PUSH
54536: LD_INT 3
54538: MINUS
54539: PUSH
54540: LD_VAR 0 2
54544: PUSH
54545: LD_INT 3
54547: MINUS
54548: PUSH
54549: LD_INT 2
54551: PUSH
54552: EMPTY
54553: LIST
54554: LIST
54555: LIST
54556: PUSH
54557: LD_VAR 0 1
54561: PUSH
54562: LD_INT 4
54564: MINUS
54565: PUSH
54566: LD_VAR 0 2
54570: PUSH
54571: LD_INT 1
54573: PUSH
54574: EMPTY
54575: LIST
54576: LIST
54577: LIST
54578: PUSH
54579: LD_VAR 0 1
54583: PUSH
54584: LD_VAR 0 2
54588: PUSH
54589: LD_INT 3
54591: PLUS
54592: PUSH
54593: LD_INT 0
54595: PUSH
54596: EMPTY
54597: LIST
54598: LIST
54599: LIST
54600: PUSH
54601: LD_VAR 0 1
54605: PUSH
54606: LD_INT 4
54608: PLUS
54609: PUSH
54610: LD_VAR 0 2
54614: PUSH
54615: LD_INT 4
54617: PLUS
54618: PUSH
54619: LD_INT 5
54621: PUSH
54622: EMPTY
54623: LIST
54624: LIST
54625: LIST
54626: PUSH
54627: EMPTY
54628: LIST
54629: LIST
54630: LIST
54631: LIST
54632: LIST
54633: ST_TO_ADDR
// end ; 2 :
54634: GO 55193
54636: LD_INT 2
54638: DOUBLE
54639: EQUAL
54640: IFTRUE 54644
54642: GO 54773
54644: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
54645: LD_ADDR_VAR 0 5
54649: PUSH
54650: LD_VAR 0 1
54654: PUSH
54655: LD_VAR 0 2
54659: PUSH
54660: LD_INT 3
54662: MINUS
54663: PUSH
54664: LD_INT 3
54666: PUSH
54667: EMPTY
54668: LIST
54669: LIST
54670: LIST
54671: PUSH
54672: LD_VAR 0 1
54676: PUSH
54677: LD_INT 4
54679: PLUS
54680: PUSH
54681: LD_VAR 0 2
54685: PUSH
54686: LD_INT 4
54688: PUSH
54689: EMPTY
54690: LIST
54691: LIST
54692: LIST
54693: PUSH
54694: LD_VAR 0 1
54698: PUSH
54699: LD_VAR 0 2
54703: PUSH
54704: LD_INT 4
54706: PLUS
54707: PUSH
54708: LD_INT 0
54710: PUSH
54711: EMPTY
54712: LIST
54713: LIST
54714: LIST
54715: PUSH
54716: LD_VAR 0 1
54720: PUSH
54721: LD_INT 3
54723: MINUS
54724: PUSH
54725: LD_VAR 0 2
54729: PUSH
54730: LD_INT 1
54732: PUSH
54733: EMPTY
54734: LIST
54735: LIST
54736: LIST
54737: PUSH
54738: LD_VAR 0 1
54742: PUSH
54743: LD_INT 4
54745: MINUS
54746: PUSH
54747: LD_VAR 0 2
54751: PUSH
54752: LD_INT 4
54754: MINUS
54755: PUSH
54756: LD_INT 2
54758: PUSH
54759: EMPTY
54760: LIST
54761: LIST
54762: LIST
54763: PUSH
54764: EMPTY
54765: LIST
54766: LIST
54767: LIST
54768: LIST
54769: LIST
54770: ST_TO_ADDR
// end ; 3 :
54771: GO 55193
54773: LD_INT 3
54775: DOUBLE
54776: EQUAL
54777: IFTRUE 54781
54779: GO 54914
54781: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
54782: LD_ADDR_VAR 0 5
54786: PUSH
54787: LD_VAR 0 1
54791: PUSH
54792: LD_INT 3
54794: PLUS
54795: PUSH
54796: LD_VAR 0 2
54800: PUSH
54801: LD_INT 4
54803: PUSH
54804: EMPTY
54805: LIST
54806: LIST
54807: LIST
54808: PUSH
54809: LD_VAR 0 1
54813: PUSH
54814: LD_INT 4
54816: PLUS
54817: PUSH
54818: LD_VAR 0 2
54822: PUSH
54823: LD_INT 4
54825: PLUS
54826: PUSH
54827: LD_INT 5
54829: PUSH
54830: EMPTY
54831: LIST
54832: LIST
54833: LIST
54834: PUSH
54835: LD_VAR 0 1
54839: PUSH
54840: LD_INT 4
54842: MINUS
54843: PUSH
54844: LD_VAR 0 2
54848: PUSH
54849: LD_INT 1
54851: PUSH
54852: EMPTY
54853: LIST
54854: LIST
54855: LIST
54856: PUSH
54857: LD_VAR 0 1
54861: PUSH
54862: LD_VAR 0 2
54866: PUSH
54867: LD_INT 4
54869: MINUS
54870: PUSH
54871: LD_INT 3
54873: PUSH
54874: EMPTY
54875: LIST
54876: LIST
54877: LIST
54878: PUSH
54879: LD_VAR 0 1
54883: PUSH
54884: LD_INT 3
54886: MINUS
54887: PUSH
54888: LD_VAR 0 2
54892: PUSH
54893: LD_INT 3
54895: MINUS
54896: PUSH
54897: LD_INT 2
54899: PUSH
54900: EMPTY
54901: LIST
54902: LIST
54903: LIST
54904: PUSH
54905: EMPTY
54906: LIST
54907: LIST
54908: LIST
54909: LIST
54910: LIST
54911: ST_TO_ADDR
// end ; 4 :
54912: GO 55193
54914: LD_INT 4
54916: DOUBLE
54917: EQUAL
54918: IFTRUE 54922
54920: GO 55055
54922: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
54923: LD_ADDR_VAR 0 5
54927: PUSH
54928: LD_VAR 0 1
54932: PUSH
54933: LD_VAR 0 2
54937: PUSH
54938: LD_INT 4
54940: PLUS
54941: PUSH
54942: LD_INT 0
54944: PUSH
54945: EMPTY
54946: LIST
54947: LIST
54948: LIST
54949: PUSH
54950: LD_VAR 0 1
54954: PUSH
54955: LD_INT 3
54957: PLUS
54958: PUSH
54959: LD_VAR 0 2
54963: PUSH
54964: LD_INT 3
54966: PLUS
54967: PUSH
54968: LD_INT 5
54970: PUSH
54971: EMPTY
54972: LIST
54973: LIST
54974: LIST
54975: PUSH
54976: LD_VAR 0 1
54980: PUSH
54981: LD_INT 4
54983: PLUS
54984: PUSH
54985: LD_VAR 0 2
54989: PUSH
54990: LD_INT 4
54992: PUSH
54993: EMPTY
54994: LIST
54995: LIST
54996: LIST
54997: PUSH
54998: LD_VAR 0 1
55002: PUSH
55003: LD_VAR 0 2
55007: PUSH
55008: LD_INT 3
55010: MINUS
55011: PUSH
55012: LD_INT 3
55014: PUSH
55015: EMPTY
55016: LIST
55017: LIST
55018: LIST
55019: PUSH
55020: LD_VAR 0 1
55024: PUSH
55025: LD_INT 4
55027: MINUS
55028: PUSH
55029: LD_VAR 0 2
55033: PUSH
55034: LD_INT 4
55036: MINUS
55037: PUSH
55038: LD_INT 2
55040: PUSH
55041: EMPTY
55042: LIST
55043: LIST
55044: LIST
55045: PUSH
55046: EMPTY
55047: LIST
55048: LIST
55049: LIST
55050: LIST
55051: LIST
55052: ST_TO_ADDR
// end ; 5 :
55053: GO 55193
55055: LD_INT 5
55057: DOUBLE
55058: EQUAL
55059: IFTRUE 55063
55061: GO 55192
55063: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
55064: LD_ADDR_VAR 0 5
55068: PUSH
55069: LD_VAR 0 1
55073: PUSH
55074: LD_INT 4
55076: MINUS
55077: PUSH
55078: LD_VAR 0 2
55082: PUSH
55083: LD_INT 1
55085: PUSH
55086: EMPTY
55087: LIST
55088: LIST
55089: LIST
55090: PUSH
55091: LD_VAR 0 1
55095: PUSH
55096: LD_VAR 0 2
55100: PUSH
55101: LD_INT 4
55103: MINUS
55104: PUSH
55105: LD_INT 3
55107: PUSH
55108: EMPTY
55109: LIST
55110: LIST
55111: LIST
55112: PUSH
55113: LD_VAR 0 1
55117: PUSH
55118: LD_INT 4
55120: PLUS
55121: PUSH
55122: LD_VAR 0 2
55126: PUSH
55127: LD_INT 4
55129: PLUS
55130: PUSH
55131: LD_INT 5
55133: PUSH
55134: EMPTY
55135: LIST
55136: LIST
55137: LIST
55138: PUSH
55139: LD_VAR 0 1
55143: PUSH
55144: LD_INT 3
55146: PLUS
55147: PUSH
55148: LD_VAR 0 2
55152: PUSH
55153: LD_INT 4
55155: PUSH
55156: EMPTY
55157: LIST
55158: LIST
55159: LIST
55160: PUSH
55161: LD_VAR 0 1
55165: PUSH
55166: LD_VAR 0 2
55170: PUSH
55171: LD_INT 3
55173: PLUS
55174: PUSH
55175: LD_INT 0
55177: PUSH
55178: EMPTY
55179: LIST
55180: LIST
55181: LIST
55182: PUSH
55183: EMPTY
55184: LIST
55185: LIST
55186: LIST
55187: LIST
55188: LIST
55189: ST_TO_ADDR
// end ; end ;
55190: GO 55193
55192: POP
// result := list ;
55193: LD_ADDR_VAR 0 4
55197: PUSH
55198: LD_VAR 0 5
55202: ST_TO_ADDR
// end ;
55203: LD_VAR 0 4
55207: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
55208: LD_INT 0
55210: PPUSH
55211: PPUSH
55212: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
55213: LD_VAR 0 1
55217: NOT
55218: PUSH
55219: LD_VAR 0 2
55223: PUSH
55224: LD_INT 1
55226: PUSH
55227: LD_INT 2
55229: PUSH
55230: LD_INT 3
55232: PUSH
55233: LD_INT 4
55235: PUSH
55236: EMPTY
55237: LIST
55238: LIST
55239: LIST
55240: LIST
55241: IN
55242: NOT
55243: OR
55244: IFFALSE 55248
// exit ;
55246: GO 55331
// tmp := [ ] ;
55248: LD_ADDR_VAR 0 5
55252: PUSH
55253: EMPTY
55254: ST_TO_ADDR
// for i in units do
55255: LD_ADDR_VAR 0 4
55259: PUSH
55260: LD_VAR 0 1
55264: PUSH
55265: FOR_IN
55266: IFFALSE 55300
// tmp := Join ( tmp , GetSkill ( i , class ) ) ;
55268: LD_ADDR_VAR 0 5
55272: PUSH
55273: LD_VAR 0 5
55277: PPUSH
55278: LD_VAR 0 4
55282: PPUSH
55283: LD_VAR 0 2
55287: PPUSH
55288: CALL_OW 259
55292: PPUSH
55293: CALL 56692 0 2
55297: ST_TO_ADDR
55298: GO 55265
55300: POP
55301: POP
// if not tmp then
55302: LD_VAR 0 5
55306: NOT
55307: IFFALSE 55311
// exit ;
55309: GO 55331
// result := SortListByListDesc ( units , tmp ) ;
55311: LD_ADDR_VAR 0 3
55315: PUSH
55316: LD_VAR 0 1
55320: PPUSH
55321: LD_VAR 0 5
55325: PPUSH
55326: CALL_OW 77
55330: ST_TO_ADDR
// end ;
55331: LD_VAR 0 3
55335: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
55336: LD_INT 0
55338: PPUSH
55339: PPUSH
55340: PPUSH
// result := false ;
55341: LD_ADDR_VAR 0 3
55345: PUSH
55346: LD_INT 0
55348: ST_TO_ADDR
// if not building then
55349: LD_VAR 0 2
55353: NOT
55354: IFFALSE 55358
// exit ;
55356: GO 55496
// x := GetX ( building ) ;
55358: LD_ADDR_VAR 0 4
55362: PUSH
55363: LD_VAR 0 2
55367: PPUSH
55368: CALL_OW 250
55372: ST_TO_ADDR
// y := GetY ( building ) ;
55373: LD_ADDR_VAR 0 5
55377: PUSH
55378: LD_VAR 0 2
55382: PPUSH
55383: CALL_OW 251
55387: ST_TO_ADDR
// if not x or not y then
55388: LD_VAR 0 4
55392: NOT
55393: PUSH
55394: LD_VAR 0 5
55398: NOT
55399: OR
55400: IFFALSE 55404
// exit ;
55402: GO 55496
// if GetTaskList ( unit ) then
55404: LD_VAR 0 1
55408: PPUSH
55409: CALL_OW 437
55413: IFFALSE 55496
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
55415: LD_STRING e
55417: PUSH
55418: LD_VAR 0 1
55422: PPUSH
55423: CALL_OW 437
55427: PUSH
55428: LD_INT 1
55430: ARRAY
55431: PUSH
55432: LD_INT 1
55434: ARRAY
55435: EQUAL
55436: PUSH
55437: LD_VAR 0 4
55441: PUSH
55442: LD_VAR 0 1
55446: PPUSH
55447: CALL_OW 437
55451: PUSH
55452: LD_INT 1
55454: ARRAY
55455: PUSH
55456: LD_INT 2
55458: ARRAY
55459: EQUAL
55460: AND
55461: PUSH
55462: LD_VAR 0 5
55466: PUSH
55467: LD_VAR 0 1
55471: PPUSH
55472: CALL_OW 437
55476: PUSH
55477: LD_INT 1
55479: ARRAY
55480: PUSH
55481: LD_INT 3
55483: ARRAY
55484: EQUAL
55485: AND
55486: IFFALSE 55496
// result := true end ;
55488: LD_ADDR_VAR 0 3
55492: PUSH
55493: LD_INT 1
55495: ST_TO_ADDR
// end ;
55496: LD_VAR 0 3
55500: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
55501: LD_INT 0
55503: PPUSH
// result := false ;
55504: LD_ADDR_VAR 0 4
55508: PUSH
55509: LD_INT 0
55511: ST_TO_ADDR
// if GetTaskList ( unit ) then
55512: LD_VAR 0 1
55516: PPUSH
55517: CALL_OW 437
55521: IFFALSE 55604
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
55523: LD_STRING M
55525: PUSH
55526: LD_VAR 0 1
55530: PPUSH
55531: CALL_OW 437
55535: PUSH
55536: LD_INT 1
55538: ARRAY
55539: PUSH
55540: LD_INT 1
55542: ARRAY
55543: EQUAL
55544: PUSH
55545: LD_VAR 0 2
55549: PUSH
55550: LD_VAR 0 1
55554: PPUSH
55555: CALL_OW 437
55559: PUSH
55560: LD_INT 1
55562: ARRAY
55563: PUSH
55564: LD_INT 2
55566: ARRAY
55567: EQUAL
55568: AND
55569: PUSH
55570: LD_VAR 0 3
55574: PUSH
55575: LD_VAR 0 1
55579: PPUSH
55580: CALL_OW 437
55584: PUSH
55585: LD_INT 1
55587: ARRAY
55588: PUSH
55589: LD_INT 3
55591: ARRAY
55592: EQUAL
55593: AND
55594: IFFALSE 55604
// result := true ;
55596: LD_ADDR_VAR 0 4
55600: PUSH
55601: LD_INT 1
55603: ST_TO_ADDR
// end ; end ;
55604: LD_VAR 0 4
55608: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
55609: LD_INT 0
55611: PPUSH
55612: PPUSH
55613: PPUSH
55614: PPUSH
// if not unit or not area then
55615: LD_VAR 0 1
55619: NOT
55620: PUSH
55621: LD_VAR 0 2
55625: NOT
55626: OR
55627: IFFALSE 55631
// exit ;
55629: GO 55795
// tmp := AreaToList ( area , i ) ;
55631: LD_ADDR_VAR 0 6
55635: PUSH
55636: LD_VAR 0 2
55640: PPUSH
55641: LD_VAR 0 5
55645: PPUSH
55646: CALL_OW 517
55650: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
55651: LD_ADDR_VAR 0 5
55655: PUSH
55656: DOUBLE
55657: LD_INT 1
55659: DEC
55660: ST_TO_ADDR
55661: LD_VAR 0 6
55665: PUSH
55666: LD_INT 1
55668: ARRAY
55669: PUSH
55670: FOR_TO
55671: IFFALSE 55793
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
55673: LD_ADDR_VAR 0 7
55677: PUSH
55678: LD_VAR 0 6
55682: PUSH
55683: LD_INT 1
55685: ARRAY
55686: PUSH
55687: LD_VAR 0 5
55691: ARRAY
55692: PUSH
55693: LD_VAR 0 6
55697: PUSH
55698: LD_INT 2
55700: ARRAY
55701: PUSH
55702: LD_VAR 0 5
55706: ARRAY
55707: PUSH
55708: EMPTY
55709: LIST
55710: LIST
55711: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
55712: LD_VAR 0 7
55716: PUSH
55717: LD_INT 1
55719: ARRAY
55720: PPUSH
55721: LD_VAR 0 7
55725: PUSH
55726: LD_INT 2
55728: ARRAY
55729: PPUSH
55730: CALL_OW 428
55734: PUSH
55735: LD_INT 0
55737: EQUAL
55738: IFFALSE 55791
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
55740: LD_VAR 0 1
55744: PPUSH
55745: LD_VAR 0 7
55749: PUSH
55750: LD_INT 1
55752: ARRAY
55753: PPUSH
55754: LD_VAR 0 7
55758: PUSH
55759: LD_INT 2
55761: ARRAY
55762: PPUSH
55763: LD_VAR 0 3
55767: PPUSH
55768: CALL_OW 48
// result := IsPlaced ( unit ) ;
55772: LD_ADDR_VAR 0 4
55776: PUSH
55777: LD_VAR 0 1
55781: PPUSH
55782: CALL_OW 305
55786: ST_TO_ADDR
// exit ;
55787: POP
55788: POP
55789: GO 55795
// end ; end ;
55791: GO 55670
55793: POP
55794: POP
// end ;
55795: LD_VAR 0 4
55799: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
55800: LD_INT 0
55802: PPUSH
55803: PPUSH
55804: PPUSH
// if not side or side > 8 then
55805: LD_VAR 0 1
55809: NOT
55810: PUSH
55811: LD_VAR 0 1
55815: PUSH
55816: LD_INT 8
55818: GREATER
55819: OR
55820: IFFALSE 55824
// exit ;
55822: GO 56011
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
55824: LD_ADDR_VAR 0 4
55828: PUSH
55829: LD_INT 22
55831: PUSH
55832: LD_VAR 0 1
55836: PUSH
55837: EMPTY
55838: LIST
55839: LIST
55840: PUSH
55841: LD_INT 21
55843: PUSH
55844: LD_INT 3
55846: PUSH
55847: EMPTY
55848: LIST
55849: LIST
55850: PUSH
55851: EMPTY
55852: LIST
55853: LIST
55854: PPUSH
55855: CALL_OW 69
55859: ST_TO_ADDR
// if not tmp then
55860: LD_VAR 0 4
55864: NOT
55865: IFFALSE 55869
// exit ;
55867: GO 56011
// enable_addtolog := true ;
55869: LD_ADDR_OWVAR 81
55873: PUSH
55874: LD_INT 1
55876: ST_TO_ADDR
// AddToLog ( [ ) ;
55877: LD_STRING [
55879: PPUSH
55880: CALL_OW 561
// for i in tmp do
55884: LD_ADDR_VAR 0 3
55888: PUSH
55889: LD_VAR 0 4
55893: PUSH
55894: FOR_IN
55895: IFFALSE 56002
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
55897: LD_STRING [
55899: PUSH
55900: LD_VAR 0 3
55904: PPUSH
55905: CALL_OW 266
55909: STR
55910: PUSH
55911: LD_STRING , 
55913: STR
55914: PUSH
55915: LD_VAR 0 3
55919: PPUSH
55920: CALL_OW 250
55924: STR
55925: PUSH
55926: LD_STRING , 
55928: STR
55929: PUSH
55930: LD_VAR 0 3
55934: PPUSH
55935: CALL_OW 251
55939: STR
55940: PUSH
55941: LD_STRING , 
55943: STR
55944: PUSH
55945: LD_VAR 0 3
55949: PPUSH
55950: CALL_OW 254
55954: STR
55955: PUSH
55956: LD_STRING , 
55958: STR
55959: PUSH
55960: LD_VAR 0 3
55964: PPUSH
55965: LD_INT 1
55967: PPUSH
55968: CALL_OW 268
55972: STR
55973: PUSH
55974: LD_STRING , 
55976: STR
55977: PUSH
55978: LD_VAR 0 3
55982: PPUSH
55983: LD_INT 2
55985: PPUSH
55986: CALL_OW 268
55990: STR
55991: PUSH
55992: LD_STRING ],
55994: STR
55995: PPUSH
55996: CALL_OW 561
// end ;
56000: GO 55894
56002: POP
56003: POP
// AddToLog ( ]; ) ;
56004: LD_STRING ];
56006: PPUSH
56007: CALL_OW 561
// end ;
56011: LD_VAR 0 2
56015: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
56016: LD_INT 0
56018: PPUSH
56019: PPUSH
56020: PPUSH
56021: PPUSH
56022: PPUSH
// if not area or not rate or not max then
56023: LD_VAR 0 1
56027: NOT
56028: PUSH
56029: LD_VAR 0 2
56033: NOT
56034: OR
56035: PUSH
56036: LD_VAR 0 4
56040: NOT
56041: OR
56042: IFFALSE 56046
// exit ;
56044: GO 56235
// while 1 do
56046: LD_INT 1
56048: IFFALSE 56235
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
56050: LD_ADDR_VAR 0 9
56054: PUSH
56055: LD_VAR 0 1
56059: PPUSH
56060: LD_INT 1
56062: PPUSH
56063: CALL_OW 287
56067: PUSH
56068: LD_INT 10
56070: MUL
56071: ST_TO_ADDR
// r := rate / 10 ;
56072: LD_ADDR_VAR 0 7
56076: PUSH
56077: LD_VAR 0 2
56081: PUSH
56082: LD_INT 10
56084: DIVREAL
56085: ST_TO_ADDR
// time := 1 1$00 ;
56086: LD_ADDR_VAR 0 8
56090: PUSH
56091: LD_INT 2100
56093: ST_TO_ADDR
// if amount < min then
56094: LD_VAR 0 9
56098: PUSH
56099: LD_VAR 0 3
56103: LESS
56104: IFFALSE 56122
// r := r * 2 else
56106: LD_ADDR_VAR 0 7
56110: PUSH
56111: LD_VAR 0 7
56115: PUSH
56116: LD_INT 2
56118: MUL
56119: ST_TO_ADDR
56120: GO 56148
// if amount > max then
56122: LD_VAR 0 9
56126: PUSH
56127: LD_VAR 0 4
56131: GREATER
56132: IFFALSE 56148
// r := r / 2 ;
56134: LD_ADDR_VAR 0 7
56138: PUSH
56139: LD_VAR 0 7
56143: PUSH
56144: LD_INT 2
56146: DIVREAL
56147: ST_TO_ADDR
// time := time / r ;
56148: LD_ADDR_VAR 0 8
56152: PUSH
56153: LD_VAR 0 8
56157: PUSH
56158: LD_VAR 0 7
56162: DIVREAL
56163: ST_TO_ADDR
// if time < 0 then
56164: LD_VAR 0 8
56168: PUSH
56169: LD_INT 0
56171: LESS
56172: IFFALSE 56189
// time := time * - 1 ;
56174: LD_ADDR_VAR 0 8
56178: PUSH
56179: LD_VAR 0 8
56183: PUSH
56184: LD_INT 1
56186: NEG
56187: MUL
56188: ST_TO_ADDR
// wait ( time + rand ( 0 0$01 , 0 0$25 ) ) ;
56189: LD_VAR 0 8
56193: PUSH
56194: LD_INT 35
56196: PPUSH
56197: LD_INT 875
56199: PPUSH
56200: CALL_OW 12
56204: PLUS
56205: PPUSH
56206: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
56210: LD_INT 1
56212: PPUSH
56213: LD_INT 5
56215: PPUSH
56216: CALL_OW 12
56220: PPUSH
56221: LD_VAR 0 1
56225: PPUSH
56226: LD_INT 1
56228: PPUSH
56229: CALL_OW 55
// end ;
56233: GO 56046
// end ;
56235: LD_VAR 0 5
56239: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
56240: LD_INT 0
56242: PPUSH
56243: PPUSH
56244: PPUSH
56245: PPUSH
56246: PPUSH
56247: PPUSH
56248: PPUSH
56249: PPUSH
// if not turrets or not factories then
56250: LD_VAR 0 1
56254: NOT
56255: PUSH
56256: LD_VAR 0 2
56260: NOT
56261: OR
56262: IFFALSE 56266
// exit ;
56264: GO 56573
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
56266: LD_ADDR_VAR 0 10
56270: PUSH
56271: LD_INT 5
56273: PUSH
56274: LD_INT 6
56276: PUSH
56277: EMPTY
56278: LIST
56279: LIST
56280: PUSH
56281: LD_INT 2
56283: PUSH
56284: LD_INT 4
56286: PUSH
56287: EMPTY
56288: LIST
56289: LIST
56290: PUSH
56291: LD_INT 3
56293: PUSH
56294: LD_INT 5
56296: PUSH
56297: EMPTY
56298: LIST
56299: LIST
56300: PUSH
56301: EMPTY
56302: LIST
56303: LIST
56304: LIST
56305: PUSH
56306: LD_INT 24
56308: PUSH
56309: LD_INT 25
56311: PUSH
56312: EMPTY
56313: LIST
56314: LIST
56315: PUSH
56316: LD_INT 23
56318: PUSH
56319: LD_INT 27
56321: PUSH
56322: EMPTY
56323: LIST
56324: LIST
56325: PUSH
56326: EMPTY
56327: LIST
56328: LIST
56329: PUSH
56330: LD_INT 42
56332: PUSH
56333: LD_INT 43
56335: PUSH
56336: EMPTY
56337: LIST
56338: LIST
56339: PUSH
56340: LD_INT 44
56342: PUSH
56343: LD_INT 46
56345: PUSH
56346: EMPTY
56347: LIST
56348: LIST
56349: PUSH
56350: LD_INT 45
56352: PUSH
56353: LD_INT 47
56355: PUSH
56356: EMPTY
56357: LIST
56358: LIST
56359: PUSH
56360: EMPTY
56361: LIST
56362: LIST
56363: LIST
56364: PUSH
56365: EMPTY
56366: LIST
56367: LIST
56368: LIST
56369: ST_TO_ADDR
// result := [ ] ;
56370: LD_ADDR_VAR 0 3
56374: PUSH
56375: EMPTY
56376: ST_TO_ADDR
// for i in turrets do
56377: LD_ADDR_VAR 0 4
56381: PUSH
56382: LD_VAR 0 1
56386: PUSH
56387: FOR_IN
56388: IFFALSE 56571
// begin nat := GetNation ( i ) ;
56390: LD_ADDR_VAR 0 7
56394: PUSH
56395: LD_VAR 0 4
56399: PPUSH
56400: CALL_OW 248
56404: ST_TO_ADDR
// weapon := 0 ;
56405: LD_ADDR_VAR 0 8
56409: PUSH
56410: LD_INT 0
56412: ST_TO_ADDR
// if not nat then
56413: LD_VAR 0 7
56417: NOT
56418: IFFALSE 56422
// continue ;
56420: GO 56387
// for j in list [ nat ] do
56422: LD_ADDR_VAR 0 5
56426: PUSH
56427: LD_VAR 0 10
56431: PUSH
56432: LD_VAR 0 7
56436: ARRAY
56437: PUSH
56438: FOR_IN
56439: IFFALSE 56480
// if GetBWeapon ( i ) = j [ 1 ] then
56441: LD_VAR 0 4
56445: PPUSH
56446: CALL_OW 269
56450: PUSH
56451: LD_VAR 0 5
56455: PUSH
56456: LD_INT 1
56458: ARRAY
56459: EQUAL
56460: IFFALSE 56478
// begin weapon := j [ 2 ] ;
56462: LD_ADDR_VAR 0 8
56466: PUSH
56467: LD_VAR 0 5
56471: PUSH
56472: LD_INT 2
56474: ARRAY
56475: ST_TO_ADDR
// break ;
56476: GO 56480
// end ;
56478: GO 56438
56480: POP
56481: POP
// if not weapon then
56482: LD_VAR 0 8
56486: NOT
56487: IFFALSE 56491
// continue ;
56489: GO 56387
// for k in factories do
56491: LD_ADDR_VAR 0 6
56495: PUSH
56496: LD_VAR 0 2
56500: PUSH
56501: FOR_IN
56502: IFFALSE 56567
// begin weapons := AvailableWeaponList ( k ) ;
56504: LD_ADDR_VAR 0 9
56508: PUSH
56509: LD_VAR 0 6
56513: PPUSH
56514: CALL_OW 478
56518: ST_TO_ADDR
// if not weapons then
56519: LD_VAR 0 9
56523: NOT
56524: IFFALSE 56528
// continue ;
56526: GO 56501
// if weapon in weapons then
56528: LD_VAR 0 8
56532: PUSH
56533: LD_VAR 0 9
56537: IN
56538: IFFALSE 56565
// begin result := [ i , weapon ] ;
56540: LD_ADDR_VAR 0 3
56544: PUSH
56545: LD_VAR 0 4
56549: PUSH
56550: LD_VAR 0 8
56554: PUSH
56555: EMPTY
56556: LIST
56557: LIST
56558: ST_TO_ADDR
// exit ;
56559: POP
56560: POP
56561: POP
56562: POP
56563: GO 56573
// end ; end ;
56565: GO 56501
56567: POP
56568: POP
// end ;
56569: GO 56387
56571: POP
56572: POP
// end ;
56573: LD_VAR 0 3
56577: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
56578: LD_INT 0
56580: PPUSH
// if not side or side > 8 then
56581: LD_VAR 0 3
56585: NOT
56586: PUSH
56587: LD_VAR 0 3
56591: PUSH
56592: LD_INT 8
56594: GREATER
56595: OR
56596: IFFALSE 56600
// exit ;
56598: GO 56659
// if not range then
56600: LD_VAR 0 4
56604: NOT
56605: IFFALSE 56616
// range := - 12 ;
56607: LD_ADDR_VAR 0 4
56611: PUSH
56612: LD_INT 12
56614: NEG
56615: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
56616: LD_VAR 0 1
56620: PPUSH
56621: LD_VAR 0 2
56625: PPUSH
56626: LD_VAR 0 3
56630: PPUSH
56631: LD_VAR 0 4
56635: PPUSH
56636: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
56640: LD_VAR 0 1
56644: PPUSH
56645: LD_VAR 0 2
56649: PPUSH
56650: LD_VAR 0 3
56654: PPUSH
56655: CALL_OW 331
// end ;
56659: LD_VAR 0 5
56663: RET
// export function Video ( mode ) ; begin
56664: LD_INT 0
56666: PPUSH
// ingame_video = mode ;
56667: LD_ADDR_OWVAR 52
56671: PUSH
56672: LD_VAR 0 1
56676: ST_TO_ADDR
// interface_hidden = mode ;
56677: LD_ADDR_OWVAR 54
56681: PUSH
56682: LD_VAR 0 1
56686: ST_TO_ADDR
// end ;
56687: LD_VAR 0 2
56691: RET
// export function Join ( array , element ) ; begin
56692: LD_INT 0
56694: PPUSH
// result := Replace ( array , array + 1 , element ) ;
56695: LD_ADDR_VAR 0 3
56699: PUSH
56700: LD_VAR 0 1
56704: PPUSH
56705: LD_VAR 0 1
56709: PUSH
56710: LD_INT 1
56712: PLUS
56713: PPUSH
56714: LD_VAR 0 2
56718: PPUSH
56719: CALL_OW 1
56723: ST_TO_ADDR
// end ;
56724: LD_VAR 0 3
56728: RET
// export function JoinUnion ( array , element ) ; begin
56729: LD_INT 0
56731: PPUSH
// result := array union element ;
56732: LD_ADDR_VAR 0 3
56736: PUSH
56737: LD_VAR 0 1
56741: PUSH
56742: LD_VAR 0 2
56746: UNION
56747: ST_TO_ADDR
// end ;
56748: LD_VAR 0 3
56752: RET
// export function GetBehemoths ( side ) ; begin
56753: LD_INT 0
56755: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , ru_behemoth ] ] ) ;
56756: LD_ADDR_VAR 0 2
56760: PUSH
56761: LD_INT 22
56763: PUSH
56764: LD_VAR 0 1
56768: PUSH
56769: EMPTY
56770: LIST
56771: LIST
56772: PUSH
56773: LD_INT 31
56775: PUSH
56776: LD_INT 25
56778: PUSH
56779: EMPTY
56780: LIST
56781: LIST
56782: PUSH
56783: EMPTY
56784: LIST
56785: LIST
56786: PPUSH
56787: CALL_OW 69
56791: ST_TO_ADDR
// end ;
56792: LD_VAR 0 2
56796: RET
// export function Shuffle ( array ) ; var i , index ; begin
56797: LD_INT 0
56799: PPUSH
56800: PPUSH
56801: PPUSH
// result := [ ] ;
56802: LD_ADDR_VAR 0 2
56806: PUSH
56807: EMPTY
56808: ST_TO_ADDR
// if not array then
56809: LD_VAR 0 1
56813: NOT
56814: IFFALSE 56818
// exit ;
56816: GO 56917
// Randomize ;
56818: CALL_OW 10
// for i = array downto 1 do
56822: LD_ADDR_VAR 0 3
56826: PUSH
56827: DOUBLE
56828: LD_VAR 0 1
56832: INC
56833: ST_TO_ADDR
56834: LD_INT 1
56836: PUSH
56837: FOR_DOWNTO
56838: IFFALSE 56915
// begin index := rand ( 1 , array ) ;
56840: LD_ADDR_VAR 0 4
56844: PUSH
56845: LD_INT 1
56847: PPUSH
56848: LD_VAR 0 1
56852: PPUSH
56853: CALL_OW 12
56857: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
56858: LD_ADDR_VAR 0 2
56862: PUSH
56863: LD_VAR 0 2
56867: PPUSH
56868: LD_VAR 0 2
56872: PUSH
56873: LD_INT 1
56875: PLUS
56876: PPUSH
56877: LD_VAR 0 1
56881: PUSH
56882: LD_VAR 0 4
56886: ARRAY
56887: PPUSH
56888: CALL_OW 2
56892: ST_TO_ADDR
// array := Delete ( array , index ) ;
56893: LD_ADDR_VAR 0 1
56897: PUSH
56898: LD_VAR 0 1
56902: PPUSH
56903: LD_VAR 0 4
56907: PPUSH
56908: CALL_OW 3
56912: ST_TO_ADDR
// end ;
56913: GO 56837
56915: POP
56916: POP
// end ;
56917: LD_VAR 0 2
56921: RET
// export function GetBaseMaterials ( base ) ; begin
56922: LD_INT 0
56924: PPUSH
// result := [ 0 , 0 , 0 ] ;
56925: LD_ADDR_VAR 0 2
56929: PUSH
56930: LD_INT 0
56932: PUSH
56933: LD_INT 0
56935: PUSH
56936: LD_INT 0
56938: PUSH
56939: EMPTY
56940: LIST
56941: LIST
56942: LIST
56943: ST_TO_ADDR
// if not base then
56944: LD_VAR 0 1
56948: NOT
56949: IFFALSE 56953
// exit ;
56951: GO 57002
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
56953: LD_ADDR_VAR 0 2
56957: PUSH
56958: LD_VAR 0 1
56962: PPUSH
56963: LD_INT 1
56965: PPUSH
56966: CALL_OW 275
56970: PUSH
56971: LD_VAR 0 1
56975: PPUSH
56976: LD_INT 2
56978: PPUSH
56979: CALL_OW 275
56983: PUSH
56984: LD_VAR 0 1
56988: PPUSH
56989: LD_INT 3
56991: PPUSH
56992: CALL_OW 275
56996: PUSH
56997: EMPTY
56998: LIST
56999: LIST
57000: LIST
57001: ST_TO_ADDR
// end ;
57002: LD_VAR 0 2
57006: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
57007: LD_INT 0
57009: PPUSH
57010: PPUSH
// result := array ;
57011: LD_ADDR_VAR 0 3
57015: PUSH
57016: LD_VAR 0 1
57020: ST_TO_ADDR
// if size >= result then
57021: LD_VAR 0 2
57025: PUSH
57026: LD_VAR 0 3
57030: GREATEREQUAL
57031: IFFALSE 57035
// exit ;
57033: GO 57085
// if size then
57035: LD_VAR 0 2
57039: IFFALSE 57085
// for i := array downto size do
57041: LD_ADDR_VAR 0 4
57045: PUSH
57046: DOUBLE
57047: LD_VAR 0 1
57051: INC
57052: ST_TO_ADDR
57053: LD_VAR 0 2
57057: PUSH
57058: FOR_DOWNTO
57059: IFFALSE 57083
// result := Delete ( result , result ) ;
57061: LD_ADDR_VAR 0 3
57065: PUSH
57066: LD_VAR 0 3
57070: PPUSH
57071: LD_VAR 0 3
57075: PPUSH
57076: CALL_OW 3
57080: ST_TO_ADDR
57081: GO 57058
57083: POP
57084: POP
// end ;
57085: LD_VAR 0 3
57089: RET
// export function ComExit ( unit ) ; var tmp ; begin
57090: LD_INT 0
57092: PPUSH
57093: PPUSH
// if not IsInUnit ( unit ) then
57094: LD_VAR 0 1
57098: PPUSH
57099: CALL_OW 310
57103: NOT
57104: IFFALSE 57108
// exit ;
57106: GO 57168
// tmp := IsInUnit ( unit ) ;
57108: LD_ADDR_VAR 0 3
57112: PUSH
57113: LD_VAR 0 1
57117: PPUSH
57118: CALL_OW 310
57122: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
57123: LD_VAR 0 3
57127: PPUSH
57128: CALL_OW 247
57132: PUSH
57133: LD_INT 2
57135: EQUAL
57136: IFFALSE 57149
// ComExitVehicle ( unit ) else
57138: LD_VAR 0 1
57142: PPUSH
57143: CALL_OW 121
57147: GO 57158
// ComExitBuilding ( unit ) ;
57149: LD_VAR 0 1
57153: PPUSH
57154: CALL_OW 122
// result := tmp ;
57158: LD_ADDR_VAR 0 2
57162: PUSH
57163: LD_VAR 0 3
57167: ST_TO_ADDR
// end ;
57168: LD_VAR 0 2
57172: RET
// export function ComExitAll ( units ) ; var i ; begin
57173: LD_INT 0
57175: PPUSH
57176: PPUSH
// if not units then
57177: LD_VAR 0 1
57181: NOT
57182: IFFALSE 57186
// exit ;
57184: GO 57212
// for i in units do
57186: LD_ADDR_VAR 0 3
57190: PUSH
57191: LD_VAR 0 1
57195: PUSH
57196: FOR_IN
57197: IFFALSE 57210
// ComExit ( i ) ;
57199: LD_VAR 0 3
57203: PPUSH
57204: CALL 57090 0 1
57208: GO 57196
57210: POP
57211: POP
// end ;
57212: LD_VAR 0 2
57216: RET
// export function ResetHc ; begin
57217: LD_INT 0
57219: PPUSH
// InitHc ;
57220: CALL_OW 19
// hc_importance := 0 ;
57224: LD_ADDR_OWVAR 32
57228: PUSH
57229: LD_INT 0
57231: ST_TO_ADDR
// end ;
57232: LD_VAR 0 1
57236: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
57237: LD_INT 0
57239: PPUSH
57240: PPUSH
57241: PPUSH
// _x := ( x1 + x2 ) div 2 ;
57242: LD_ADDR_VAR 0 6
57246: PUSH
57247: LD_VAR 0 1
57251: PUSH
57252: LD_VAR 0 3
57256: PLUS
57257: PUSH
57258: LD_INT 2
57260: DIV
57261: ST_TO_ADDR
// if _x < 0 then
57262: LD_VAR 0 6
57266: PUSH
57267: LD_INT 0
57269: LESS
57270: IFFALSE 57287
// _x := _x * - 1 ;
57272: LD_ADDR_VAR 0 6
57276: PUSH
57277: LD_VAR 0 6
57281: PUSH
57282: LD_INT 1
57284: NEG
57285: MUL
57286: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
57287: LD_ADDR_VAR 0 7
57291: PUSH
57292: LD_VAR 0 2
57296: PUSH
57297: LD_VAR 0 4
57301: PLUS
57302: PUSH
57303: LD_INT 2
57305: DIV
57306: ST_TO_ADDR
// if _y < 0 then
57307: LD_VAR 0 7
57311: PUSH
57312: LD_INT 0
57314: LESS
57315: IFFALSE 57332
// _y := _y * - 1 ;
57317: LD_ADDR_VAR 0 7
57321: PUSH
57322: LD_VAR 0 7
57326: PUSH
57327: LD_INT 1
57329: NEG
57330: MUL
57331: ST_TO_ADDR
// result := [ _x , _y ] ;
57332: LD_ADDR_VAR 0 5
57336: PUSH
57337: LD_VAR 0 6
57341: PUSH
57342: LD_VAR 0 7
57346: PUSH
57347: EMPTY
57348: LIST
57349: LIST
57350: ST_TO_ADDR
// end ;
57351: LD_VAR 0 5
57355: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
57356: LD_INT 0
57358: PPUSH
57359: PPUSH
57360: PPUSH
57361: PPUSH
// task := GetTaskList ( unit ) ;
57362: LD_ADDR_VAR 0 7
57366: PUSH
57367: LD_VAR 0 1
57371: PPUSH
57372: CALL_OW 437
57376: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
57377: LD_VAR 0 7
57381: NOT
57382: PUSH
57383: LD_VAR 0 1
57387: PPUSH
57388: LD_VAR 0 2
57392: PPUSH
57393: CALL_OW 308
57397: NOT
57398: AND
57399: IFFALSE 57403
// exit ;
57401: GO 57521
// if IsInArea ( unit , area ) then
57403: LD_VAR 0 1
57407: PPUSH
57408: LD_VAR 0 2
57412: PPUSH
57413: CALL_OW 308
57417: IFFALSE 57435
// begin ComMoveToArea ( unit , goAway ) ;
57419: LD_VAR 0 1
57423: PPUSH
57424: LD_VAR 0 3
57428: PPUSH
57429: CALL_OW 113
// exit ;
57433: GO 57521
// end ; if task [ 1 ] [ 1 ] <> M then
57435: LD_VAR 0 7
57439: PUSH
57440: LD_INT 1
57442: ARRAY
57443: PUSH
57444: LD_INT 1
57446: ARRAY
57447: PUSH
57448: LD_STRING M
57450: NONEQUAL
57451: IFFALSE 57455
// exit ;
57453: GO 57521
// x := task [ 1 ] [ 2 ] ;
57455: LD_ADDR_VAR 0 5
57459: PUSH
57460: LD_VAR 0 7
57464: PUSH
57465: LD_INT 1
57467: ARRAY
57468: PUSH
57469: LD_INT 2
57471: ARRAY
57472: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
57473: LD_ADDR_VAR 0 6
57477: PUSH
57478: LD_VAR 0 7
57482: PUSH
57483: LD_INT 1
57485: ARRAY
57486: PUSH
57487: LD_INT 3
57489: ARRAY
57490: ST_TO_ADDR
// if InArea ( x , y , area ) then
57491: LD_VAR 0 5
57495: PPUSH
57496: LD_VAR 0 6
57500: PPUSH
57501: LD_VAR 0 2
57505: PPUSH
57506: CALL_OW 309
57510: IFFALSE 57521
// ComStop ( unit ) ;
57512: LD_VAR 0 1
57516: PPUSH
57517: CALL_OW 141
// end ;
57521: LD_VAR 0 4
57525: RET
// export function Abs ( value ) ; begin
57526: LD_INT 0
57528: PPUSH
// result := value ;
57529: LD_ADDR_VAR 0 2
57533: PUSH
57534: LD_VAR 0 1
57538: ST_TO_ADDR
// if value < 0 then
57539: LD_VAR 0 1
57543: PUSH
57544: LD_INT 0
57546: LESS
57547: IFFALSE 57564
// result := value * - 1 ;
57549: LD_ADDR_VAR 0 2
57553: PUSH
57554: LD_VAR 0 1
57558: PUSH
57559: LD_INT 1
57561: NEG
57562: MUL
57563: ST_TO_ADDR
// end ;
57564: LD_VAR 0 2
57568: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
57569: LD_INT 0
57571: PPUSH
57572: PPUSH
57573: PPUSH
57574: PPUSH
57575: PPUSH
57576: PPUSH
57577: PPUSH
57578: PPUSH
// if not unit or not building then
57579: LD_VAR 0 1
57583: NOT
57584: PUSH
57585: LD_VAR 0 2
57589: NOT
57590: OR
57591: IFFALSE 57595
// exit ;
57593: GO 57821
// x := GetX ( building ) ;
57595: LD_ADDR_VAR 0 4
57599: PUSH
57600: LD_VAR 0 2
57604: PPUSH
57605: CALL_OW 250
57609: ST_TO_ADDR
// y := GetY ( building ) ;
57610: LD_ADDR_VAR 0 6
57614: PUSH
57615: LD_VAR 0 2
57619: PPUSH
57620: CALL_OW 251
57624: ST_TO_ADDR
// d := GetDir ( building ) ;
57625: LD_ADDR_VAR 0 8
57629: PUSH
57630: LD_VAR 0 2
57634: PPUSH
57635: CALL_OW 254
57639: ST_TO_ADDR
// r := 4 ;
57640: LD_ADDR_VAR 0 9
57644: PUSH
57645: LD_INT 4
57647: ST_TO_ADDR
// for i := 1 to 5 do
57648: LD_ADDR_VAR 0 10
57652: PUSH
57653: DOUBLE
57654: LD_INT 1
57656: DEC
57657: ST_TO_ADDR
57658: LD_INT 5
57660: PUSH
57661: FOR_TO
57662: IFFALSE 57819
// begin _x := ShiftX ( x , d , r + i ) ;
57664: LD_ADDR_VAR 0 5
57668: PUSH
57669: LD_VAR 0 4
57673: PPUSH
57674: LD_VAR 0 8
57678: PPUSH
57679: LD_VAR 0 9
57683: PUSH
57684: LD_VAR 0 10
57688: PLUS
57689: PPUSH
57690: CALL_OW 272
57694: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
57695: LD_ADDR_VAR 0 7
57699: PUSH
57700: LD_VAR 0 6
57704: PPUSH
57705: LD_VAR 0 8
57709: PPUSH
57710: LD_VAR 0 9
57714: PUSH
57715: LD_VAR 0 10
57719: PLUS
57720: PPUSH
57721: CALL_OW 273
57725: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
57726: LD_VAR 0 5
57730: PPUSH
57731: LD_VAR 0 7
57735: PPUSH
57736: CALL_OW 488
57740: PUSH
57741: LD_VAR 0 5
57745: PPUSH
57746: LD_VAR 0 7
57750: PPUSH
57751: CALL_OW 428
57755: PPUSH
57756: CALL_OW 247
57760: PUSH
57761: LD_INT 3
57763: PUSH
57764: LD_INT 2
57766: PUSH
57767: EMPTY
57768: LIST
57769: LIST
57770: IN
57771: NOT
57772: AND
57773: IFFALSE 57817
// begin ComMoveXY ( unit , _x , _y ) ;
57775: LD_VAR 0 1
57779: PPUSH
57780: LD_VAR 0 5
57784: PPUSH
57785: LD_VAR 0 7
57789: PPUSH
57790: CALL_OW 111
// result := [ _x , _y ] ;
57794: LD_ADDR_VAR 0 3
57798: PUSH
57799: LD_VAR 0 5
57803: PUSH
57804: LD_VAR 0 7
57808: PUSH
57809: EMPTY
57810: LIST
57811: LIST
57812: ST_TO_ADDR
// exit ;
57813: POP
57814: POP
57815: GO 57821
// end ; end ;
57817: GO 57661
57819: POP
57820: POP
// end ;
57821: LD_VAR 0 3
57825: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
57826: LD_INT 0
57828: PPUSH
57829: PPUSH
57830: PPUSH
// result := 0 ;
57831: LD_ADDR_VAR 0 3
57835: PUSH
57836: LD_INT 0
57838: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
57839: LD_VAR 0 1
57843: PUSH
57844: LD_INT 0
57846: LESS
57847: PUSH
57848: LD_VAR 0 1
57852: PUSH
57853: LD_INT 8
57855: GREATER
57856: OR
57857: PUSH
57858: LD_VAR 0 2
57862: PUSH
57863: LD_INT 0
57865: LESS
57866: OR
57867: PUSH
57868: LD_VAR 0 2
57872: PUSH
57873: LD_INT 8
57875: GREATER
57876: OR
57877: IFFALSE 57881
// exit ;
57879: GO 57956
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
57881: LD_ADDR_VAR 0 4
57885: PUSH
57886: LD_INT 22
57888: PUSH
57889: LD_VAR 0 2
57893: PUSH
57894: EMPTY
57895: LIST
57896: LIST
57897: PPUSH
57898: CALL_OW 69
57902: PUSH
57903: FOR_IN
57904: IFFALSE 57954
// begin un := UnitShoot ( i ) ;
57906: LD_ADDR_VAR 0 5
57910: PUSH
57911: LD_VAR 0 4
57915: PPUSH
57916: CALL_OW 504
57920: ST_TO_ADDR
// if GetSide ( un ) = side1 then
57921: LD_VAR 0 5
57925: PPUSH
57926: CALL_OW 255
57930: PUSH
57931: LD_VAR 0 1
57935: EQUAL
57936: IFFALSE 57952
// begin result := un ;
57938: LD_ADDR_VAR 0 3
57942: PUSH
57943: LD_VAR 0 5
57947: ST_TO_ADDR
// exit ;
57948: POP
57949: POP
57950: GO 57956
// end ; end ;
57952: GO 57903
57954: POP
57955: POP
// end ;
57956: LD_VAR 0 3
57960: RET
// export function GetCargoBay ( units ) ; begin
57961: LD_INT 0
57963: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
57964: LD_ADDR_VAR 0 2
57968: PUSH
57969: LD_VAR 0 1
57973: PPUSH
57974: LD_INT 2
57976: PUSH
57977: LD_INT 34
57979: PUSH
57980: LD_INT 12
57982: PUSH
57983: EMPTY
57984: LIST
57985: LIST
57986: PUSH
57987: LD_INT 34
57989: PUSH
57990: LD_INT 51
57992: PUSH
57993: EMPTY
57994: LIST
57995: LIST
57996: PUSH
57997: LD_INT 34
57999: PUSH
58000: LD_INT 32
58002: PUSH
58003: EMPTY
58004: LIST
58005: LIST
58006: PUSH
58007: LD_INT 34
58009: PUSH
58010: LD_INT 89
58012: PUSH
58013: EMPTY
58014: LIST
58015: LIST
58016: PUSH
58017: EMPTY
58018: LIST
58019: LIST
58020: LIST
58021: LIST
58022: LIST
58023: PPUSH
58024: CALL_OW 72
58028: ST_TO_ADDR
// end ;
58029: LD_VAR 0 2
58033: RET
// export function Negate ( value ) ; begin
58034: LD_INT 0
58036: PPUSH
// result := not value ;
58037: LD_ADDR_VAR 0 2
58041: PUSH
58042: LD_VAR 0 1
58046: NOT
58047: ST_TO_ADDR
// end ;
58048: LD_VAR 0 2
58052: RET
// export function Inc ( value ) ; begin
58053: LD_INT 0
58055: PPUSH
// result := value + 1 ;
58056: LD_ADDR_VAR 0 2
58060: PUSH
58061: LD_VAR 0 1
58065: PUSH
58066: LD_INT 1
58068: PLUS
58069: ST_TO_ADDR
// end ;
58070: LD_VAR 0 2
58074: RET
// export function Dec ( value ) ; begin
58075: LD_INT 0
58077: PPUSH
// result := value - 1 ;
58078: LD_ADDR_VAR 0 2
58082: PUSH
58083: LD_VAR 0 1
58087: PUSH
58088: LD_INT 1
58090: MINUS
58091: ST_TO_ADDR
// end ;
58092: LD_VAR 0 2
58096: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; var i , _x , _y , tmp , distance , centerDist , centerPoint ; begin
58097: LD_INT 0
58099: PPUSH
58100: PPUSH
58101: PPUSH
58102: PPUSH
58103: PPUSH
58104: PPUSH
58105: PPUSH
58106: PPUSH
// if not ValidHex ( x1 , y1 ) or not ValidHex ( x2 , y2 ) then
58107: LD_VAR 0 1
58111: PPUSH
58112: LD_VAR 0 2
58116: PPUSH
58117: CALL_OW 488
58121: NOT
58122: PUSH
58123: LD_VAR 0 3
58127: PPUSH
58128: LD_VAR 0 4
58132: PPUSH
58133: CALL_OW 488
58137: NOT
58138: OR
58139: IFFALSE 58152
// begin result := - 1 ;
58141: LD_ADDR_VAR 0 5
58145: PUSH
58146: LD_INT 1
58148: NEG
58149: ST_TO_ADDR
// exit ;
58150: GO 58387
// end ; centerPoint := PointBetweenXY ( x1 , y1 , x2 , y2 ) ;
58152: LD_ADDR_VAR 0 12
58156: PUSH
58157: LD_VAR 0 1
58161: PPUSH
58162: LD_VAR 0 2
58166: PPUSH
58167: LD_VAR 0 3
58171: PPUSH
58172: LD_VAR 0 4
58176: PPUSH
58177: CALL 57237 0 4
58181: ST_TO_ADDR
// centerDist := GetDistXY ( x1 , y1 , centerPoint [ 1 ] , centerPoint [ 2 ] ) ;
58182: LD_ADDR_VAR 0 11
58186: PUSH
58187: LD_VAR 0 1
58191: PPUSH
58192: LD_VAR 0 2
58196: PPUSH
58197: LD_VAR 0 12
58201: PUSH
58202: LD_INT 1
58204: ARRAY
58205: PPUSH
58206: LD_VAR 0 12
58210: PUSH
58211: LD_INT 2
58213: ARRAY
58214: PPUSH
58215: CALL_OW 298
58219: ST_TO_ADDR
// distance := 9999 ;
58220: LD_ADDR_VAR 0 10
58224: PUSH
58225: LD_INT 9999
58227: ST_TO_ADDR
// for i := 0 to 5 do
58228: LD_ADDR_VAR 0 6
58232: PUSH
58233: DOUBLE
58234: LD_INT 0
58236: DEC
58237: ST_TO_ADDR
58238: LD_INT 5
58240: PUSH
58241: FOR_TO
58242: IFFALSE 58385
// begin _x := ShiftX ( x1 , i , centerDist ) ;
58244: LD_ADDR_VAR 0 7
58248: PUSH
58249: LD_VAR 0 1
58253: PPUSH
58254: LD_VAR 0 6
58258: PPUSH
58259: LD_VAR 0 11
58263: PPUSH
58264: CALL_OW 272
58268: ST_TO_ADDR
// _y := ShiftY ( y1 , i , centerDist ) ;
58269: LD_ADDR_VAR 0 8
58273: PUSH
58274: LD_VAR 0 2
58278: PPUSH
58279: LD_VAR 0 6
58283: PPUSH
58284: LD_VAR 0 11
58288: PPUSH
58289: CALL_OW 273
58293: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
58294: LD_VAR 0 7
58298: PPUSH
58299: LD_VAR 0 8
58303: PPUSH
58304: CALL_OW 488
58308: NOT
58309: IFFALSE 58313
// continue ;
58311: GO 58241
// tmp := GetDistXY ( centerPoint [ 1 ] , centerPoint [ 2 ] , _x , _y ) ;
58313: LD_ADDR_VAR 0 9
58317: PUSH
58318: LD_VAR 0 12
58322: PUSH
58323: LD_INT 1
58325: ARRAY
58326: PPUSH
58327: LD_VAR 0 12
58331: PUSH
58332: LD_INT 2
58334: ARRAY
58335: PPUSH
58336: LD_VAR 0 7
58340: PPUSH
58341: LD_VAR 0 8
58345: PPUSH
58346: CALL_OW 298
58350: ST_TO_ADDR
// if tmp < distance then
58351: LD_VAR 0 9
58355: PUSH
58356: LD_VAR 0 10
58360: LESS
58361: IFFALSE 58383
// begin result := i ;
58363: LD_ADDR_VAR 0 5
58367: PUSH
58368: LD_VAR 0 6
58372: ST_TO_ADDR
// distance := tmp ;
58373: LD_ADDR_VAR 0 10
58377: PUSH
58378: LD_VAR 0 9
58382: ST_TO_ADDR
// end ; end ;
58383: GO 58241
58385: POP
58386: POP
// end ;
58387: LD_VAR 0 5
58391: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
58392: LD_INT 0
58394: PPUSH
58395: PPUSH
// if not driver or not IsInUnit ( driver ) then
58396: LD_VAR 0 1
58400: NOT
58401: PUSH
58402: LD_VAR 0 1
58406: PPUSH
58407: CALL_OW 310
58411: NOT
58412: OR
58413: IFFALSE 58417
// exit ;
58415: GO 58507
// vehicle := IsInUnit ( driver ) ;
58417: LD_ADDR_VAR 0 3
58421: PUSH
58422: LD_VAR 0 1
58426: PPUSH
58427: CALL_OW 310
58431: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
58432: LD_VAR 0 1
58436: PPUSH
58437: LD_STRING \
58439: PUSH
58440: LD_INT 0
58442: PUSH
58443: LD_INT 0
58445: PUSH
58446: LD_INT 0
58448: PUSH
58449: LD_INT 0
58451: PUSH
58452: LD_INT 0
58454: PUSH
58455: LD_INT 0
58457: PUSH
58458: EMPTY
58459: LIST
58460: LIST
58461: LIST
58462: LIST
58463: LIST
58464: LIST
58465: LIST
58466: PUSH
58467: LD_STRING E
58469: PUSH
58470: LD_INT 0
58472: PUSH
58473: LD_INT 0
58475: PUSH
58476: LD_VAR 0 3
58480: PUSH
58481: LD_INT 0
58483: PUSH
58484: LD_INT 0
58486: PUSH
58487: LD_INT 0
58489: PUSH
58490: EMPTY
58491: LIST
58492: LIST
58493: LIST
58494: LIST
58495: LIST
58496: LIST
58497: LIST
58498: PUSH
58499: EMPTY
58500: LIST
58501: LIST
58502: PPUSH
58503: CALL_OW 446
// end ;
58507: LD_VAR 0 2
58511: RET
// export function AddComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
58512: LD_INT 0
58514: PPUSH
58515: PPUSH
// if not driver or not IsInUnit ( driver ) then
58516: LD_VAR 0 1
58520: NOT
58521: PUSH
58522: LD_VAR 0 1
58526: PPUSH
58527: CALL_OW 310
58531: NOT
58532: OR
58533: IFFALSE 58537
// exit ;
58535: GO 58627
// vehicle := IsInUnit ( driver ) ;
58537: LD_ADDR_VAR 0 3
58541: PUSH
58542: LD_VAR 0 1
58546: PPUSH
58547: CALL_OW 310
58551: ST_TO_ADDR
// AddTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
58552: LD_VAR 0 1
58556: PPUSH
58557: LD_STRING \
58559: PUSH
58560: LD_INT 0
58562: PUSH
58563: LD_INT 0
58565: PUSH
58566: LD_INT 0
58568: PUSH
58569: LD_INT 0
58571: PUSH
58572: LD_INT 0
58574: PUSH
58575: LD_INT 0
58577: PUSH
58578: EMPTY
58579: LIST
58580: LIST
58581: LIST
58582: LIST
58583: LIST
58584: LIST
58585: LIST
58586: PUSH
58587: LD_STRING E
58589: PUSH
58590: LD_INT 0
58592: PUSH
58593: LD_INT 0
58595: PUSH
58596: LD_VAR 0 3
58600: PUSH
58601: LD_INT 0
58603: PUSH
58604: LD_INT 0
58606: PUSH
58607: LD_INT 0
58609: PUSH
58610: EMPTY
58611: LIST
58612: LIST
58613: LIST
58614: LIST
58615: LIST
58616: LIST
58617: LIST
58618: PUSH
58619: EMPTY
58620: LIST
58621: LIST
58622: PPUSH
58623: CALL_OW 447
// end ;
58627: LD_VAR 0 2
58631: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
58632: LD_INT 0
58634: PPUSH
58635: PPUSH
58636: PPUSH
// tmp := [ ] ;
58637: LD_ADDR_VAR 0 5
58641: PUSH
58642: EMPTY
58643: ST_TO_ADDR
// for i in units do
58644: LD_ADDR_VAR 0 4
58648: PUSH
58649: LD_VAR 0 1
58653: PUSH
58654: FOR_IN
58655: IFFALSE 58693
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
58657: LD_ADDR_VAR 0 5
58661: PUSH
58662: LD_VAR 0 5
58666: PPUSH
58667: LD_VAR 0 5
58671: PUSH
58672: LD_INT 1
58674: PLUS
58675: PPUSH
58676: LD_VAR 0 4
58680: PPUSH
58681: CALL_OW 256
58685: PPUSH
58686: CALL_OW 2
58690: ST_TO_ADDR
58691: GO 58654
58693: POP
58694: POP
// if not tmp then
58695: LD_VAR 0 5
58699: NOT
58700: IFFALSE 58704
// exit ;
58702: GO 58752
// if asc then
58704: LD_VAR 0 2
58708: IFFALSE 58732
// result := SortListByListAsc ( units , tmp ) else
58710: LD_ADDR_VAR 0 3
58714: PUSH
58715: LD_VAR 0 1
58719: PPUSH
58720: LD_VAR 0 5
58724: PPUSH
58725: CALL_OW 76
58729: ST_TO_ADDR
58730: GO 58752
// result := SortListByListDesc ( units , tmp ) ;
58732: LD_ADDR_VAR 0 3
58736: PUSH
58737: LD_VAR 0 1
58741: PPUSH
58742: LD_VAR 0 5
58746: PPUSH
58747: CALL_OW 77
58751: ST_TO_ADDR
// end ;
58752: LD_VAR 0 3
58756: RET
// export function WantToRepairVehicle ( mech , vehicle ) ; var task ; begin
58757: LD_INT 0
58759: PPUSH
58760: PPUSH
// task := GetTaskList ( mech ) ;
58761: LD_ADDR_VAR 0 4
58765: PUSH
58766: LD_VAR 0 1
58770: PPUSH
58771: CALL_OW 437
58775: ST_TO_ADDR
// if not task then
58776: LD_VAR 0 4
58780: NOT
58781: IFFALSE 58785
// exit ;
58783: GO 58827
// result := task [ 1 ] [ 1 ] = r and task [ 1 ] [ 4 ] = vehicle ;
58785: LD_ADDR_VAR 0 3
58789: PUSH
58790: LD_VAR 0 4
58794: PUSH
58795: LD_INT 1
58797: ARRAY
58798: PUSH
58799: LD_INT 1
58801: ARRAY
58802: PUSH
58803: LD_STRING r
58805: EQUAL
58806: PUSH
58807: LD_VAR 0 4
58811: PUSH
58812: LD_INT 1
58814: ARRAY
58815: PUSH
58816: LD_INT 4
58818: ARRAY
58819: PUSH
58820: LD_VAR 0 2
58824: EQUAL
58825: AND
58826: ST_TO_ADDR
// end ;
58827: LD_VAR 0 3
58831: RET
// export function PlaceUnitXYD ( unit , x , y , d , mode ) ; begin
58832: LD_INT 0
58834: PPUSH
// SetDir ( unit , d ) ;
58835: LD_VAR 0 1
58839: PPUSH
58840: LD_VAR 0 4
58844: PPUSH
58845: CALL_OW 233
// PlaceUnitXY ( unit , x , y , mode ) ;
58849: LD_VAR 0 1
58853: PPUSH
58854: LD_VAR 0 2
58858: PPUSH
58859: LD_VAR 0 3
58863: PPUSH
58864: LD_VAR 0 5
58868: PPUSH
58869: CALL_OW 48
// end ;
58873: LD_VAR 0 6
58877: RET
// export function ToNaturalNumber ( number ) ; begin
58878: LD_INT 0
58880: PPUSH
// result := number div 1 ;
58881: LD_ADDR_VAR 0 2
58885: PUSH
58886: LD_VAR 0 1
58890: PUSH
58891: LD_INT 1
58893: DIV
58894: ST_TO_ADDR
// if number < 0 then
58895: LD_VAR 0 1
58899: PUSH
58900: LD_INT 0
58902: LESS
58903: IFFALSE 58913
// result := 0 ;
58905: LD_ADDR_VAR 0 2
58909: PUSH
58910: LD_INT 0
58912: ST_TO_ADDR
// end ;
58913: LD_VAR 0 2
58917: RET
// export function SortByClass ( units , class ) ; var un ; begin
58918: LD_INT 0
58920: PPUSH
58921: PPUSH
// if not units or not class then
58922: LD_VAR 0 1
58926: NOT
58927: PUSH
58928: LD_VAR 0 2
58932: NOT
58933: OR
58934: IFFALSE 58938
// exit ;
58936: GO 59033
// result := [ ] ;
58938: LD_ADDR_VAR 0 3
58942: PUSH
58943: EMPTY
58944: ST_TO_ADDR
// for un in units do
58945: LD_ADDR_VAR 0 4
58949: PUSH
58950: LD_VAR 0 1
58954: PUSH
58955: FOR_IN
58956: IFFALSE 59031
// if GetClass ( un ) = class then
58958: LD_VAR 0 4
58962: PPUSH
58963: CALL_OW 257
58967: PUSH
58968: LD_VAR 0 2
58972: EQUAL
58973: IFFALSE 59000
// result := Insert ( result , 1 , un ) else
58975: LD_ADDR_VAR 0 3
58979: PUSH
58980: LD_VAR 0 3
58984: PPUSH
58985: LD_INT 1
58987: PPUSH
58988: LD_VAR 0 4
58992: PPUSH
58993: CALL_OW 2
58997: ST_TO_ADDR
58998: GO 59029
// result := Replace ( result , result + 1 , un ) ;
59000: LD_ADDR_VAR 0 3
59004: PUSH
59005: LD_VAR 0 3
59009: PPUSH
59010: LD_VAR 0 3
59014: PUSH
59015: LD_INT 1
59017: PLUS
59018: PPUSH
59019: LD_VAR 0 4
59023: PPUSH
59024: CALL_OW 1
59028: ST_TO_ADDR
59029: GO 58955
59031: POP
59032: POP
// end ;
59033: LD_VAR 0 3
59037: RET
// export function GetCratesNearbyXY ( x , y , r ) ; var _x , _y , min_y , min_x , max_x , max_y ; begin
59038: LD_INT 0
59040: PPUSH
59041: PPUSH
59042: PPUSH
59043: PPUSH
59044: PPUSH
59045: PPUSH
59046: PPUSH
// result := [ ] ;
59047: LD_ADDR_VAR 0 4
59051: PUSH
59052: EMPTY
59053: ST_TO_ADDR
// if x - r < 0 then
59054: LD_VAR 0 1
59058: PUSH
59059: LD_VAR 0 3
59063: MINUS
59064: PUSH
59065: LD_INT 0
59067: LESS
59068: IFFALSE 59080
// min_x := 0 else
59070: LD_ADDR_VAR 0 8
59074: PUSH
59075: LD_INT 0
59077: ST_TO_ADDR
59078: GO 59096
// min_x := x - r ;
59080: LD_ADDR_VAR 0 8
59084: PUSH
59085: LD_VAR 0 1
59089: PUSH
59090: LD_VAR 0 3
59094: MINUS
59095: ST_TO_ADDR
// if y - r < 0 then
59096: LD_VAR 0 2
59100: PUSH
59101: LD_VAR 0 3
59105: MINUS
59106: PUSH
59107: LD_INT 0
59109: LESS
59110: IFFALSE 59122
// min_y := 0 else
59112: LD_ADDR_VAR 0 7
59116: PUSH
59117: LD_INT 0
59119: ST_TO_ADDR
59120: GO 59138
// min_y := y - r ;
59122: LD_ADDR_VAR 0 7
59126: PUSH
59127: LD_VAR 0 2
59131: PUSH
59132: LD_VAR 0 3
59136: MINUS
59137: ST_TO_ADDR
// max_x := x + r ;
59138: LD_ADDR_VAR 0 9
59142: PUSH
59143: LD_VAR 0 1
59147: PUSH
59148: LD_VAR 0 3
59152: PLUS
59153: ST_TO_ADDR
// max_y := y + r ;
59154: LD_ADDR_VAR 0 10
59158: PUSH
59159: LD_VAR 0 2
59163: PUSH
59164: LD_VAR 0 3
59168: PLUS
59169: ST_TO_ADDR
// for _x = min_x to max_x do
59170: LD_ADDR_VAR 0 5
59174: PUSH
59175: DOUBLE
59176: LD_VAR 0 8
59180: DEC
59181: ST_TO_ADDR
59182: LD_VAR 0 9
59186: PUSH
59187: FOR_TO
59188: IFFALSE 59289
// for _y = min_y to max_y do
59190: LD_ADDR_VAR 0 6
59194: PUSH
59195: DOUBLE
59196: LD_VAR 0 7
59200: DEC
59201: ST_TO_ADDR
59202: LD_VAR 0 10
59206: PUSH
59207: FOR_TO
59208: IFFALSE 59285
// begin if not ValidHex ( _x , _y ) then
59210: LD_VAR 0 5
59214: PPUSH
59215: LD_VAR 0 6
59219: PPUSH
59220: CALL_OW 488
59224: NOT
59225: IFFALSE 59229
// continue ;
59227: GO 59207
// if GetResourceTypeXY ( _x , _y ) then
59229: LD_VAR 0 5
59233: PPUSH
59234: LD_VAR 0 6
59238: PPUSH
59239: CALL_OW 283
59243: IFFALSE 59283
// result := Replace ( result , result + 1 , [ _x , _y ] ) ;
59245: LD_ADDR_VAR 0 4
59249: PUSH
59250: LD_VAR 0 4
59254: PPUSH
59255: LD_VAR 0 4
59259: PUSH
59260: LD_INT 1
59262: PLUS
59263: PPUSH
59264: LD_VAR 0 5
59268: PUSH
59269: LD_VAR 0 6
59273: PUSH
59274: EMPTY
59275: LIST
59276: LIST
59277: PPUSH
59278: CALL_OW 1
59282: ST_TO_ADDR
// end ;
59283: GO 59207
59285: POP
59286: POP
59287: GO 59187
59289: POP
59290: POP
// end ;
59291: LD_VAR 0 4
59295: RET
// export function AgressiveMove ( units , path ) ; var i , enemy , nearEnemy , cr , side , tag , ignoreCratesWeapon ; begin
59296: LD_INT 0
59298: PPUSH
59299: PPUSH
59300: PPUSH
59301: PPUSH
59302: PPUSH
59303: PPUSH
59304: PPUSH
59305: PPUSH
// if not units then
59306: LD_VAR 0 1
59310: NOT
59311: IFFALSE 59315
// exit ;
59313: GO 59839
// result := UnitFilter ( units , [ f_ok ] ) ;
59315: LD_ADDR_VAR 0 3
59319: PUSH
59320: LD_VAR 0 1
59324: PPUSH
59325: LD_INT 50
59327: PUSH
59328: EMPTY
59329: LIST
59330: PPUSH
59331: CALL_OW 72
59335: ST_TO_ADDR
// side := GetSide ( units [ 1 ] ) ;
59336: LD_ADDR_VAR 0 8
59340: PUSH
59341: LD_VAR 0 1
59345: PUSH
59346: LD_INT 1
59348: ARRAY
59349: PPUSH
59350: CALL_OW 255
59354: ST_TO_ADDR
// ignoreCratesWeapon := [ ar_selfpropelled_bomb , ar_bio_bomb , ru_time_lapser ] ;
59355: LD_ADDR_VAR 0 10
59359: PUSH
59360: LD_INT 29
59362: PUSH
59363: LD_INT 91
59365: PUSH
59366: LD_INT 49
59368: PUSH
59369: EMPTY
59370: LIST
59371: LIST
59372: LIST
59373: ST_TO_ADDR
// if not result then
59374: LD_VAR 0 3
59378: NOT
59379: IFFALSE 59383
// exit ;
59381: GO 59839
// enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
59383: LD_ADDR_VAR 0 5
59387: PUSH
59388: LD_INT 81
59390: PUSH
59391: LD_VAR 0 8
59395: PUSH
59396: EMPTY
59397: LIST
59398: LIST
59399: PPUSH
59400: CALL_OW 69
59404: ST_TO_ADDR
// for i in result do
59405: LD_ADDR_VAR 0 4
59409: PUSH
59410: LD_VAR 0 3
59414: PUSH
59415: FOR_IN
59416: IFFALSE 59837
// begin tag := GetTag ( i ) + 1 ;
59418: LD_ADDR_VAR 0 9
59422: PUSH
59423: LD_VAR 0 4
59427: PPUSH
59428: CALL_OW 110
59432: PUSH
59433: LD_INT 1
59435: PLUS
59436: ST_TO_ADDR
// cr := GetCratesNearbyXY ( GetX ( i ) , GetY ( i ) , 6 ) ;
59437: LD_ADDR_VAR 0 7
59441: PUSH
59442: LD_VAR 0 4
59446: PPUSH
59447: CALL_OW 250
59451: PPUSH
59452: LD_VAR 0 4
59456: PPUSH
59457: CALL_OW 251
59461: PPUSH
59462: LD_INT 6
59464: PPUSH
59465: CALL 59038 0 3
59469: ST_TO_ADDR
// if GetType ( i ) = unit_vehicle and cr and not GetWeapon ( i ) in ignoreCratesWeapon then
59470: LD_VAR 0 4
59474: PPUSH
59475: CALL_OW 247
59479: PUSH
59480: LD_INT 2
59482: EQUAL
59483: PUSH
59484: LD_VAR 0 7
59488: AND
59489: PUSH
59490: LD_VAR 0 4
59494: PPUSH
59495: CALL_OW 264
59499: PUSH
59500: LD_VAR 0 10
59504: IN
59505: NOT
59506: AND
59507: IFFALSE 59546
// ComAttackPlace ( i , cr [ 1 ] [ 1 ] , cr [ 1 ] [ 2 ] ) else
59509: LD_VAR 0 4
59513: PPUSH
59514: LD_VAR 0 7
59518: PUSH
59519: LD_INT 1
59521: ARRAY
59522: PUSH
59523: LD_INT 1
59525: ARRAY
59526: PPUSH
59527: LD_VAR 0 7
59531: PUSH
59532: LD_INT 1
59534: ARRAY
59535: PUSH
59536: LD_INT 2
59538: ARRAY
59539: PPUSH
59540: CALL_OW 116
59544: GO 59835
// if path > tag then
59546: LD_VAR 0 2
59550: PUSH
59551: LD_VAR 0 9
59555: GREATER
59556: IFFALSE 59764
// begin nearEnemy := UnitFilter ( enemy , [ f_dist , i , 8 ] ) ;
59558: LD_ADDR_VAR 0 6
59562: PUSH
59563: LD_VAR 0 5
59567: PPUSH
59568: LD_INT 91
59570: PUSH
59571: LD_VAR 0 4
59575: PUSH
59576: LD_INT 8
59578: PUSH
59579: EMPTY
59580: LIST
59581: LIST
59582: LIST
59583: PPUSH
59584: CALL_OW 72
59588: ST_TO_ADDR
// if nearEnemy then
59589: LD_VAR 0 6
59593: IFFALSE 59662
// begin if GetWeapon ( i ) = ru_time_lapser then
59595: LD_VAR 0 4
59599: PPUSH
59600: CALL_OW 264
59604: PUSH
59605: LD_INT 49
59607: EQUAL
59608: IFFALSE 59636
// ComMoveUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) else
59610: LD_VAR 0 4
59614: PPUSH
59615: LD_VAR 0 6
59619: PPUSH
59620: LD_VAR 0 4
59624: PPUSH
59625: CALL_OW 74
59629: PPUSH
59630: CALL_OW 112
59634: GO 59660
// ComAttackUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) ;
59636: LD_VAR 0 4
59640: PPUSH
59641: LD_VAR 0 6
59645: PPUSH
59646: LD_VAR 0 4
59650: PPUSH
59651: CALL_OW 74
59655: PPUSH
59656: CALL_OW 115
// end else
59660: GO 59762
// if GetDistUnitXY ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) > 6 then
59662: LD_VAR 0 4
59666: PPUSH
59667: LD_VAR 0 2
59671: PUSH
59672: LD_VAR 0 9
59676: ARRAY
59677: PUSH
59678: LD_INT 1
59680: ARRAY
59681: PPUSH
59682: LD_VAR 0 2
59686: PUSH
59687: LD_VAR 0 9
59691: ARRAY
59692: PUSH
59693: LD_INT 2
59695: ARRAY
59696: PPUSH
59697: CALL_OW 297
59701: PUSH
59702: LD_INT 6
59704: GREATER
59705: IFFALSE 59748
// ComAgressiveMove ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) else
59707: LD_VAR 0 4
59711: PPUSH
59712: LD_VAR 0 2
59716: PUSH
59717: LD_VAR 0 9
59721: ARRAY
59722: PUSH
59723: LD_INT 1
59725: ARRAY
59726: PPUSH
59727: LD_VAR 0 2
59731: PUSH
59732: LD_VAR 0 9
59736: ARRAY
59737: PUSH
59738: LD_INT 2
59740: ARRAY
59741: PPUSH
59742: CALL_OW 114
59746: GO 59762
// SetTag ( i , tag ) ;
59748: LD_VAR 0 4
59752: PPUSH
59753: LD_VAR 0 9
59757: PPUSH
59758: CALL_OW 109
// end else
59762: GO 59835
// if enemy then
59764: LD_VAR 0 5
59768: IFFALSE 59835
// begin if GetWeapon ( i ) = ru_time_lapser then
59770: LD_VAR 0 4
59774: PPUSH
59775: CALL_OW 264
59779: PUSH
59780: LD_INT 49
59782: EQUAL
59783: IFFALSE 59811
// ComMoveUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
59785: LD_VAR 0 4
59789: PPUSH
59790: LD_VAR 0 5
59794: PPUSH
59795: LD_VAR 0 4
59799: PPUSH
59800: CALL_OW 74
59804: PPUSH
59805: CALL_OW 112
59809: GO 59835
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
59811: LD_VAR 0 4
59815: PPUSH
59816: LD_VAR 0 5
59820: PPUSH
59821: LD_VAR 0 4
59825: PPUSH
59826: CALL_OW 74
59830: PPUSH
59831: CALL_OW 115
// end ; end ;
59835: GO 59415
59837: POP
59838: POP
// end ;
59839: LD_VAR 0 3
59843: RET
// export function ComLookAtDir ( unit , direction ) ; var x , y ; begin
59844: LD_INT 0
59846: PPUSH
59847: PPUSH
59848: PPUSH
// if not unit or IsInUnit ( unit ) then
59849: LD_VAR 0 1
59853: NOT
59854: PUSH
59855: LD_VAR 0 1
59859: PPUSH
59860: CALL_OW 310
59864: OR
59865: IFFALSE 59869
// exit ;
59867: GO 59960
// x := ShiftX ( GetX ( unit ) , direction , 1 ) ;
59869: LD_ADDR_VAR 0 4
59873: PUSH
59874: LD_VAR 0 1
59878: PPUSH
59879: CALL_OW 250
59883: PPUSH
59884: LD_VAR 0 2
59888: PPUSH
59889: LD_INT 1
59891: PPUSH
59892: CALL_OW 272
59896: ST_TO_ADDR
// y := ShiftY ( GetY ( unit ) , direction , 1 ) ;
59897: LD_ADDR_VAR 0 5
59901: PUSH
59902: LD_VAR 0 1
59906: PPUSH
59907: CALL_OW 251
59911: PPUSH
59912: LD_VAR 0 2
59916: PPUSH
59917: LD_INT 1
59919: PPUSH
59920: CALL_OW 273
59924: ST_TO_ADDR
// if ValidHex ( x , y ) then
59925: LD_VAR 0 4
59929: PPUSH
59930: LD_VAR 0 5
59934: PPUSH
59935: CALL_OW 488
59939: IFFALSE 59960
// ComTurnXY ( unit , x , y ) ;
59941: LD_VAR 0 1
59945: PPUSH
59946: LD_VAR 0 4
59950: PPUSH
59951: LD_VAR 0 5
59955: PPUSH
59956: CALL_OW 118
// end ;
59960: LD_VAR 0 3
59964: RET
// export function SeeUnits ( side , units ) ; var i ; begin
59965: LD_INT 0
59967: PPUSH
59968: PPUSH
// result := false ;
59969: LD_ADDR_VAR 0 3
59973: PUSH
59974: LD_INT 0
59976: ST_TO_ADDR
// if not units then
59977: LD_VAR 0 2
59981: NOT
59982: IFFALSE 59986
// exit ;
59984: GO 60031
// for i in units do
59986: LD_ADDR_VAR 0 4
59990: PUSH
59991: LD_VAR 0 2
59995: PUSH
59996: FOR_IN
59997: IFFALSE 60029
// if See ( side , i ) then
59999: LD_VAR 0 1
60003: PPUSH
60004: LD_VAR 0 4
60008: PPUSH
60009: CALL_OW 292
60013: IFFALSE 60027
// begin result := true ;
60015: LD_ADDR_VAR 0 3
60019: PUSH
60020: LD_INT 1
60022: ST_TO_ADDR
// exit ;
60023: POP
60024: POP
60025: GO 60031
// end ;
60027: GO 59996
60029: POP
60030: POP
// end ;
60031: LD_VAR 0 3
60035: RET
// export function GetNearestPoint ( unit , points ) ; var i , dist , tmpDist ; begin
60036: LD_INT 0
60038: PPUSH
60039: PPUSH
60040: PPUSH
60041: PPUSH
// if not unit or not points then
60042: LD_VAR 0 1
60046: NOT
60047: PUSH
60048: LD_VAR 0 2
60052: NOT
60053: OR
60054: IFFALSE 60058
// exit ;
60056: GO 60148
// dist := 99999 ;
60058: LD_ADDR_VAR 0 5
60062: PUSH
60063: LD_INT 99999
60065: ST_TO_ADDR
// for i in points do
60066: LD_ADDR_VAR 0 4
60070: PUSH
60071: LD_VAR 0 2
60075: PUSH
60076: FOR_IN
60077: IFFALSE 60146
// begin tmpDist := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
60079: LD_ADDR_VAR 0 6
60083: PUSH
60084: LD_VAR 0 1
60088: PPUSH
60089: LD_VAR 0 4
60093: PUSH
60094: LD_INT 1
60096: ARRAY
60097: PPUSH
60098: LD_VAR 0 4
60102: PUSH
60103: LD_INT 2
60105: ARRAY
60106: PPUSH
60107: CALL_OW 297
60111: ST_TO_ADDR
// if tmpDist < dist then
60112: LD_VAR 0 6
60116: PUSH
60117: LD_VAR 0 5
60121: LESS
60122: IFFALSE 60144
// begin result := i ;
60124: LD_ADDR_VAR 0 3
60128: PUSH
60129: LD_VAR 0 4
60133: ST_TO_ADDR
// dist := tmpDist ;
60134: LD_ADDR_VAR 0 5
60138: PUSH
60139: LD_VAR 0 6
60143: ST_TO_ADDR
// end ; end ;
60144: GO 60076
60146: POP
60147: POP
// end ;
60148: LD_VAR 0 3
60152: RET
// export function CreateBehemoth ( side , x , y , d ) ; begin
60153: LD_INT 0
60155: PPUSH
// uc_side := side ;
60156: LD_ADDR_OWVAR 20
60160: PUSH
60161: LD_VAR 0 1
60165: ST_TO_ADDR
// uc_nation := 3 ;
60166: LD_ADDR_OWVAR 21
60170: PUSH
60171: LD_INT 3
60173: ST_TO_ADDR
// vc_chassis := 25 ;
60174: LD_ADDR_OWVAR 37
60178: PUSH
60179: LD_INT 25
60181: ST_TO_ADDR
// vc_engine := engine_siberite ;
60182: LD_ADDR_OWVAR 39
60186: PUSH
60187: LD_INT 3
60189: ST_TO_ADDR
// vc_control := control_computer ;
60190: LD_ADDR_OWVAR 38
60194: PUSH
60195: LD_INT 3
60197: ST_TO_ADDR
// vc_weapon := 59 ;
60198: LD_ADDR_OWVAR 40
60202: PUSH
60203: LD_INT 59
60205: ST_TO_ADDR
// result := CreateVehicle ;
60206: LD_ADDR_VAR 0 5
60210: PUSH
60211: CALL_OW 45
60215: ST_TO_ADDR
// SetDir ( result , d ) ;
60216: LD_VAR 0 5
60220: PPUSH
60221: LD_VAR 0 4
60225: PPUSH
60226: CALL_OW 233
// PlaceUnitXY ( result , x , y , false ) ;
60230: LD_VAR 0 5
60234: PPUSH
60235: LD_VAR 0 2
60239: PPUSH
60240: LD_VAR 0 3
60244: PPUSH
60245: LD_INT 0
60247: PPUSH
60248: CALL_OW 48
// end ;
60252: LD_VAR 0 5
60256: RET
// export function GetMultiCargo ( cargo ) ; var i , tmp ; begin
60257: LD_INT 0
60259: PPUSH
60260: PPUSH
60261: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
60262: LD_ADDR_VAR 0 2
60266: PUSH
60267: LD_INT 0
60269: PUSH
60270: LD_INT 0
60272: PUSH
60273: LD_INT 0
60275: PUSH
60276: LD_INT 0
60278: PUSH
60279: EMPTY
60280: LIST
60281: LIST
60282: LIST
60283: LIST
60284: ST_TO_ADDR
// if not cargo or not GetWeapon ( cargo ) in [ us_cargo_bay , ru_cargo_bay , ar_cargo_bay , ru_big_cargo_bay ] then
60285: LD_VAR 0 1
60289: NOT
60290: PUSH
60291: LD_VAR 0 1
60295: PPUSH
60296: CALL_OW 264
60300: PUSH
60301: LD_INT 12
60303: PUSH
60304: LD_INT 51
60306: PUSH
60307: LD_INT 32
60309: PUSH
60310: LD_INT 89
60312: PUSH
60313: EMPTY
60314: LIST
60315: LIST
60316: LIST
60317: LIST
60318: IN
60319: NOT
60320: OR
60321: IFFALSE 60325
// exit ;
60323: GO 60423
// for i := 1 to 3 do
60325: LD_ADDR_VAR 0 3
60329: PUSH
60330: DOUBLE
60331: LD_INT 1
60333: DEC
60334: ST_TO_ADDR
60335: LD_INT 3
60337: PUSH
60338: FOR_TO
60339: IFFALSE 60421
// begin tmp := GetCargo ( cargo , i ) ;
60341: LD_ADDR_VAR 0 4
60345: PUSH
60346: LD_VAR 0 1
60350: PPUSH
60351: LD_VAR 0 3
60355: PPUSH
60356: CALL_OW 289
60360: ST_TO_ADDR
// result := Replace ( result , i , tmp ) ;
60361: LD_ADDR_VAR 0 2
60365: PUSH
60366: LD_VAR 0 2
60370: PPUSH
60371: LD_VAR 0 3
60375: PPUSH
60376: LD_VAR 0 4
60380: PPUSH
60381: CALL_OW 1
60385: ST_TO_ADDR
// result := Replace ( result , 4 , result [ 4 ] + tmp ) ;
60386: LD_ADDR_VAR 0 2
60390: PUSH
60391: LD_VAR 0 2
60395: PPUSH
60396: LD_INT 4
60398: PPUSH
60399: LD_VAR 0 2
60403: PUSH
60404: LD_INT 4
60406: ARRAY
60407: PUSH
60408: LD_VAR 0 4
60412: PLUS
60413: PPUSH
60414: CALL_OW 1
60418: ST_TO_ADDR
// end ;
60419: GO 60338
60421: POP
60422: POP
// end ;
60423: LD_VAR 0 2
60427: RET
// export function Length ( array ) ; begin
60428: LD_INT 0
60430: PPUSH
// result := array + 0 ;
60431: LD_ADDR_VAR 0 2
60435: PUSH
60436: LD_VAR 0 1
60440: PUSH
60441: LD_INT 0
60443: PLUS
60444: ST_TO_ADDR
// end ;
60445: LD_VAR 0 2
60449: RET
// export function PrepareArray ( array ) ; begin
60450: LD_INT 0
60452: PPUSH
// result := array diff 0 ;
60453: LD_ADDR_VAR 0 2
60457: PUSH
60458: LD_VAR 0 1
60462: PUSH
60463: LD_INT 0
60465: DIFF
60466: ST_TO_ADDR
// if not result [ 1 ] then
60467: LD_VAR 0 2
60471: PUSH
60472: LD_INT 1
60474: ARRAY
60475: NOT
60476: IFFALSE 60496
// result := Delete ( result , 1 ) ;
60478: LD_ADDR_VAR 0 2
60482: PUSH
60483: LD_VAR 0 2
60487: PPUSH
60488: LD_INT 1
60490: PPUSH
60491: CALL_OW 3
60495: ST_TO_ADDR
// end ;
60496: LD_VAR 0 2
60500: RET
// export function IsInSibRocketRange ( x , y , area ) ; var i , sibRocketRange , tmp ; begin
60501: LD_INT 0
60503: PPUSH
60504: PPUSH
60505: PPUSH
60506: PPUSH
// sibRocketRange := 25 ;
60507: LD_ADDR_VAR 0 6
60511: PUSH
60512: LD_INT 25
60514: ST_TO_ADDR
// result := false ;
60515: LD_ADDR_VAR 0 4
60519: PUSH
60520: LD_INT 0
60522: ST_TO_ADDR
// for i := 0 to 5 do
60523: LD_ADDR_VAR 0 5
60527: PUSH
60528: DOUBLE
60529: LD_INT 0
60531: DEC
60532: ST_TO_ADDR
60533: LD_INT 5
60535: PUSH
60536: FOR_TO
60537: IFFALSE 60604
// if InArea ( ShiftX ( x , i , sibRocketRange ) , ShiftY ( y , i , sibRocketRange ) , area ) then
60539: LD_VAR 0 1
60543: PPUSH
60544: LD_VAR 0 5
60548: PPUSH
60549: LD_VAR 0 6
60553: PPUSH
60554: CALL_OW 272
60558: PPUSH
60559: LD_VAR 0 2
60563: PPUSH
60564: LD_VAR 0 5
60568: PPUSH
60569: LD_VAR 0 6
60573: PPUSH
60574: CALL_OW 273
60578: PPUSH
60579: LD_VAR 0 3
60583: PPUSH
60584: CALL_OW 309
60588: IFFALSE 60602
// begin result := true ;
60590: LD_ADDR_VAR 0 4
60594: PUSH
60595: LD_INT 1
60597: ST_TO_ADDR
// exit ;
60598: POP
60599: POP
60600: GO 60606
// end ;
60602: GO 60536
60604: POP
60605: POP
// end ;
60606: LD_VAR 0 4
60610: RET
// export function SayRadioNoFaceNoName ( unit , dialog ) ; begin
60611: LD_INT 0
60613: PPUSH
// SayEX ( unit , dialog , false , false , true , false ) ;
60614: LD_VAR 0 1
60618: PPUSH
60619: LD_VAR 0 2
60623: PPUSH
60624: LD_INT 0
60626: PPUSH
60627: LD_INT 0
60629: PPUSH
60630: LD_INT 1
60632: PPUSH
60633: LD_INT 0
60635: PPUSH
60636: CALL_OW 587
// end ; end_of_file
60640: LD_VAR 0 3
60644: RET
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
60645: LD_INT 0
60647: PPUSH
60648: PPUSH
60649: PPUSH
60650: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
60651: LD_VAR 0 1
60655: PPUSH
60656: CALL_OW 264
60660: PUSH
60661: LD_INT 91
60663: EQUAL
60664: IFFALSE 60736
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
60666: LD_INT 68
60668: PPUSH
60669: LD_VAR 0 1
60673: PPUSH
60674: CALL_OW 255
60678: PPUSH
60679: CALL_OW 321
60683: PUSH
60684: LD_INT 2
60686: EQUAL
60687: IFFALSE 60699
// eff := 70 else
60689: LD_ADDR_VAR 0 4
60693: PUSH
60694: LD_INT 70
60696: ST_TO_ADDR
60697: GO 60707
// eff := 30 ;
60699: LD_ADDR_VAR 0 4
60703: PUSH
60704: LD_INT 30
60706: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
60707: LD_VAR 0 1
60711: PPUSH
60712: CALL_OW 250
60716: PPUSH
60717: LD_VAR 0 1
60721: PPUSH
60722: CALL_OW 251
60726: PPUSH
60727: LD_VAR 0 4
60731: PPUSH
60732: CALL_OW 495
// end ; end ;
60736: LD_VAR 0 2
60740: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
60741: LD_INT 0
60743: PPUSH
// end ;
60744: LD_VAR 0 4
60748: RET
// export function SOS_Command ( cmd ) ; begin
60749: LD_INT 0
60751: PPUSH
// end ;
60752: LD_VAR 0 2
60756: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
60757: LD_INT 0
60759: PPUSH
// end ;
60760: LD_VAR 0 6
60764: RET
// export function SOS_VehicleConstructed ( vehicle , factory ) ; var driver ; begin
60765: LD_INT 0
60767: PPUSH
60768: PPUSH
// if not vehicle or not factory then
60769: LD_VAR 0 1
60773: NOT
60774: PUSH
60775: LD_VAR 0 2
60779: NOT
60780: OR
60781: IFFALSE 60785
// exit ;
60783: GO 61016
// if factoryWaypoints >= factory then
60785: LD_EXP 156
60789: PUSH
60790: LD_VAR 0 2
60794: GREATEREQUAL
60795: IFFALSE 61016
// if factoryWaypoints [ factory ] then
60797: LD_EXP 156
60801: PUSH
60802: LD_VAR 0 2
60806: ARRAY
60807: IFFALSE 61016
// begin if GetControl ( vehicle ) = control_manual then
60809: LD_VAR 0 1
60813: PPUSH
60814: CALL_OW 263
60818: PUSH
60819: LD_INT 1
60821: EQUAL
60822: IFFALSE 60903
// begin driver := IsDrivenBy ( vehicle ) ;
60824: LD_ADDR_VAR 0 4
60828: PUSH
60829: LD_VAR 0 1
60833: PPUSH
60834: CALL_OW 311
60838: ST_TO_ADDR
// AddComMoveXY ( driver , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
60839: LD_VAR 0 4
60843: PPUSH
60844: LD_EXP 156
60848: PUSH
60849: LD_VAR 0 2
60853: ARRAY
60854: PUSH
60855: LD_INT 3
60857: ARRAY
60858: PPUSH
60859: LD_EXP 156
60863: PUSH
60864: LD_VAR 0 2
60868: ARRAY
60869: PUSH
60870: LD_INT 4
60872: ARRAY
60873: PPUSH
60874: CALL_OW 171
// AddComExitVehicle ( driver ) ;
60878: LD_VAR 0 4
60882: PPUSH
60883: CALL_OW 181
// AddComEnterUnit ( driver , factory ) ;
60887: LD_VAR 0 4
60891: PPUSH
60892: LD_VAR 0 2
60896: PPUSH
60897: CALL_OW 180
// end else
60901: GO 61016
// if GetControl ( vehicle ) = control_remote then
60903: LD_VAR 0 1
60907: PPUSH
60908: CALL_OW 263
60912: PUSH
60913: LD_INT 2
60915: EQUAL
60916: IFFALSE 60977
// begin wait ( 0 0$2 ) ;
60918: LD_INT 70
60920: PPUSH
60921: CALL_OW 67
// if Connect ( vehicle ) then
60925: LD_VAR 0 1
60929: PPUSH
60930: CALL 27330 0 1
60934: IFFALSE 60975
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
60936: LD_VAR 0 1
60940: PPUSH
60941: LD_EXP 156
60945: PUSH
60946: LD_VAR 0 2
60950: ARRAY
60951: PUSH
60952: LD_INT 3
60954: ARRAY
60955: PPUSH
60956: LD_EXP 156
60960: PUSH
60961: LD_VAR 0 2
60965: ARRAY
60966: PUSH
60967: LD_INT 4
60969: ARRAY
60970: PPUSH
60971: CALL_OW 171
// end else
60975: GO 61016
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
60977: LD_VAR 0 1
60981: PPUSH
60982: LD_EXP 156
60986: PUSH
60987: LD_VAR 0 2
60991: ARRAY
60992: PUSH
60993: LD_INT 3
60995: ARRAY
60996: PPUSH
60997: LD_EXP 156
61001: PUSH
61002: LD_VAR 0 2
61006: ARRAY
61007: PUSH
61008: LD_INT 4
61010: ARRAY
61011: PPUSH
61012: CALL_OW 171
// end ; end ;
61016: LD_VAR 0 3
61020: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
61021: LD_INT 0
61023: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
61024: LD_VAR 0 1
61028: PUSH
61029: LD_INT 250
61031: EQUAL
61032: PUSH
61033: LD_VAR 0 2
61037: PPUSH
61038: CALL_OW 264
61042: PUSH
61043: LD_INT 81
61045: EQUAL
61046: AND
61047: IFFALSE 61068
// MinerPlaceMine ( unit , x , y ) ;
61049: LD_VAR 0 2
61053: PPUSH
61054: LD_VAR 0 4
61058: PPUSH
61059: LD_VAR 0 5
61063: PPUSH
61064: CALL 63453 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
61068: LD_VAR 0 1
61072: PUSH
61073: LD_INT 251
61075: EQUAL
61076: PUSH
61077: LD_VAR 0 2
61081: PPUSH
61082: CALL_OW 264
61086: PUSH
61087: LD_INT 81
61089: EQUAL
61090: AND
61091: IFFALSE 61112
// MinerDetonateMine ( unit , x , y ) ;
61093: LD_VAR 0 2
61097: PPUSH
61098: LD_VAR 0 4
61102: PPUSH
61103: LD_VAR 0 5
61107: PPUSH
61108: CALL 63728 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
61112: LD_VAR 0 1
61116: PUSH
61117: LD_INT 252
61119: EQUAL
61120: PUSH
61121: LD_VAR 0 2
61125: PPUSH
61126: CALL_OW 264
61130: PUSH
61131: LD_INT 81
61133: EQUAL
61134: AND
61135: IFFALSE 61156
// MinerCreateMinefield ( unit , x , y ) ;
61137: LD_VAR 0 2
61141: PPUSH
61142: LD_VAR 0 4
61146: PPUSH
61147: LD_VAR 0 5
61151: PPUSH
61152: CALL 64145 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
61156: LD_VAR 0 1
61160: PUSH
61161: LD_INT 253
61163: EQUAL
61164: PUSH
61165: LD_VAR 0 2
61169: PPUSH
61170: CALL_OW 257
61174: PUSH
61175: LD_INT 5
61177: EQUAL
61178: AND
61179: IFFALSE 61200
// ComBinocular ( unit , x , y ) ;
61181: LD_VAR 0 2
61185: PPUSH
61186: LD_VAR 0 4
61190: PPUSH
61191: LD_VAR 0 5
61195: PPUSH
61196: CALL 64514 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
61200: LD_VAR 0 1
61204: PUSH
61205: LD_INT 254
61207: EQUAL
61208: PUSH
61209: LD_VAR 0 2
61213: PPUSH
61214: CALL_OW 264
61218: PUSH
61219: LD_INT 99
61221: EQUAL
61222: AND
61223: PUSH
61224: LD_VAR 0 3
61228: PPUSH
61229: CALL_OW 263
61233: PUSH
61234: LD_INT 3
61236: EQUAL
61237: AND
61238: IFFALSE 61254
// HackDestroyVehicle ( unit , selectedUnit ) ;
61240: LD_VAR 0 2
61244: PPUSH
61245: LD_VAR 0 3
61249: PPUSH
61250: CALL 62817 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
61254: LD_VAR 0 1
61258: PUSH
61259: LD_INT 255
61261: EQUAL
61262: PUSH
61263: LD_VAR 0 2
61267: PPUSH
61268: CALL_OW 264
61272: PUSH
61273: LD_INT 14
61275: PUSH
61276: LD_INT 53
61278: PUSH
61279: EMPTY
61280: LIST
61281: LIST
61282: IN
61283: AND
61284: PUSH
61285: LD_VAR 0 4
61289: PPUSH
61290: LD_VAR 0 5
61294: PPUSH
61295: CALL_OW 488
61299: AND
61300: IFFALSE 61324
// CutTreeXYR ( unit , x , y , 12 ) ;
61302: LD_VAR 0 2
61306: PPUSH
61307: LD_VAR 0 4
61311: PPUSH
61312: LD_VAR 0 5
61316: PPUSH
61317: LD_INT 12
61319: PPUSH
61320: CALL 61387 0 4
// if cmd = 256 then
61324: LD_VAR 0 1
61328: PUSH
61329: LD_INT 256
61331: EQUAL
61332: IFFALSE 61353
// SetFactoryWaypoint ( unit , x , y ) ;
61334: LD_VAR 0 2
61338: PPUSH
61339: LD_VAR 0 4
61343: PPUSH
61344: LD_VAR 0 5
61348: PPUSH
61349: CALL 79422 0 3
// if cmd = 257 then
61353: LD_VAR 0 1
61357: PUSH
61358: LD_INT 257
61360: EQUAL
61361: IFFALSE 61382
// SetWarehouseGatheringPoint ( unit , x , y ) ;
61363: LD_VAR 0 2
61367: PPUSH
61368: LD_VAR 0 4
61372: PPUSH
61373: LD_VAR 0 5
61377: PPUSH
61378: CALL 79784 0 3
// end ;
61382: LD_VAR 0 6
61386: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
61387: LD_INT 0
61389: PPUSH
61390: PPUSH
61391: PPUSH
61392: PPUSH
61393: PPUSH
61394: PPUSH
61395: PPUSH
61396: PPUSH
61397: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
61398: LD_VAR 0 1
61402: NOT
61403: PUSH
61404: LD_VAR 0 2
61408: PPUSH
61409: LD_VAR 0 3
61413: PPUSH
61414: CALL_OW 488
61418: NOT
61419: OR
61420: PUSH
61421: LD_VAR 0 4
61425: NOT
61426: OR
61427: IFFALSE 61431
// exit ;
61429: GO 61771
// list := [ ] ;
61431: LD_ADDR_VAR 0 13
61435: PUSH
61436: EMPTY
61437: ST_TO_ADDR
// if x - r < 0 then
61438: LD_VAR 0 2
61442: PUSH
61443: LD_VAR 0 4
61447: MINUS
61448: PUSH
61449: LD_INT 0
61451: LESS
61452: IFFALSE 61464
// min_x := 0 else
61454: LD_ADDR_VAR 0 7
61458: PUSH
61459: LD_INT 0
61461: ST_TO_ADDR
61462: GO 61480
// min_x := x - r ;
61464: LD_ADDR_VAR 0 7
61468: PUSH
61469: LD_VAR 0 2
61473: PUSH
61474: LD_VAR 0 4
61478: MINUS
61479: ST_TO_ADDR
// if y - r < 0 then
61480: LD_VAR 0 3
61484: PUSH
61485: LD_VAR 0 4
61489: MINUS
61490: PUSH
61491: LD_INT 0
61493: LESS
61494: IFFALSE 61506
// min_y := 0 else
61496: LD_ADDR_VAR 0 8
61500: PUSH
61501: LD_INT 0
61503: ST_TO_ADDR
61504: GO 61522
// min_y := y - r ;
61506: LD_ADDR_VAR 0 8
61510: PUSH
61511: LD_VAR 0 3
61515: PUSH
61516: LD_VAR 0 4
61520: MINUS
61521: ST_TO_ADDR
// max_x := x + r ;
61522: LD_ADDR_VAR 0 9
61526: PUSH
61527: LD_VAR 0 2
61531: PUSH
61532: LD_VAR 0 4
61536: PLUS
61537: ST_TO_ADDR
// max_y := y + r ;
61538: LD_ADDR_VAR 0 10
61542: PUSH
61543: LD_VAR 0 3
61547: PUSH
61548: LD_VAR 0 4
61552: PLUS
61553: ST_TO_ADDR
// for _x = min_x to max_x do
61554: LD_ADDR_VAR 0 11
61558: PUSH
61559: DOUBLE
61560: LD_VAR 0 7
61564: DEC
61565: ST_TO_ADDR
61566: LD_VAR 0 9
61570: PUSH
61571: FOR_TO
61572: IFFALSE 61689
// for _y = min_y to max_y do
61574: LD_ADDR_VAR 0 12
61578: PUSH
61579: DOUBLE
61580: LD_VAR 0 8
61584: DEC
61585: ST_TO_ADDR
61586: LD_VAR 0 10
61590: PUSH
61591: FOR_TO
61592: IFFALSE 61685
// begin if not ValidHex ( _x , _y ) then
61594: LD_VAR 0 11
61598: PPUSH
61599: LD_VAR 0 12
61603: PPUSH
61604: CALL_OW 488
61608: NOT
61609: IFFALSE 61613
// continue ;
61611: GO 61591
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
61613: LD_VAR 0 11
61617: PPUSH
61618: LD_VAR 0 12
61622: PPUSH
61623: CALL_OW 351
61627: PUSH
61628: LD_VAR 0 11
61632: PPUSH
61633: LD_VAR 0 12
61637: PPUSH
61638: CALL_OW 554
61642: AND
61643: IFFALSE 61683
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
61645: LD_ADDR_VAR 0 13
61649: PUSH
61650: LD_VAR 0 13
61654: PPUSH
61655: LD_VAR 0 13
61659: PUSH
61660: LD_INT 1
61662: PLUS
61663: PPUSH
61664: LD_VAR 0 11
61668: PUSH
61669: LD_VAR 0 12
61673: PUSH
61674: EMPTY
61675: LIST
61676: LIST
61677: PPUSH
61678: CALL_OW 2
61682: ST_TO_ADDR
// end ;
61683: GO 61591
61685: POP
61686: POP
61687: GO 61571
61689: POP
61690: POP
// if not list then
61691: LD_VAR 0 13
61695: NOT
61696: IFFALSE 61700
// exit ;
61698: GO 61771
// for i in list do
61700: LD_ADDR_VAR 0 6
61704: PUSH
61705: LD_VAR 0 13
61709: PUSH
61710: FOR_IN
61711: IFFALSE 61769
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
61713: LD_VAR 0 1
61717: PPUSH
61718: LD_STRING M
61720: PUSH
61721: LD_VAR 0 6
61725: PUSH
61726: LD_INT 1
61728: ARRAY
61729: PUSH
61730: LD_VAR 0 6
61734: PUSH
61735: LD_INT 2
61737: ARRAY
61738: PUSH
61739: LD_INT 0
61741: PUSH
61742: LD_INT 0
61744: PUSH
61745: LD_INT 0
61747: PUSH
61748: LD_INT 0
61750: PUSH
61751: EMPTY
61752: LIST
61753: LIST
61754: LIST
61755: LIST
61756: LIST
61757: LIST
61758: LIST
61759: PUSH
61760: EMPTY
61761: LIST
61762: PPUSH
61763: CALL_OW 447
61767: GO 61710
61769: POP
61770: POP
// end ;
61771: LD_VAR 0 5
61775: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
61776: LD_EXP 87
61780: NOT
61781: IFFALSE 61831
61783: GO 61785
61785: DISABLE
// begin initHack := true ;
61786: LD_ADDR_EXP 87
61790: PUSH
61791: LD_INT 1
61793: ST_TO_ADDR
// hackTanks := [ ] ;
61794: LD_ADDR_EXP 88
61798: PUSH
61799: EMPTY
61800: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
61801: LD_ADDR_EXP 89
61805: PUSH
61806: EMPTY
61807: ST_TO_ADDR
// hackLimit := 3 ;
61808: LD_ADDR_EXP 90
61812: PUSH
61813: LD_INT 3
61815: ST_TO_ADDR
// hackDist := 12 ;
61816: LD_ADDR_EXP 91
61820: PUSH
61821: LD_INT 12
61823: ST_TO_ADDR
// hackCounter := [ ] ;
61824: LD_ADDR_EXP 92
61828: PUSH
61829: EMPTY
61830: ST_TO_ADDR
// end ;
61831: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
61832: LD_EXP 87
61836: PUSH
61837: LD_INT 34
61839: PUSH
61840: LD_INT 99
61842: PUSH
61843: EMPTY
61844: LIST
61845: LIST
61846: PPUSH
61847: CALL_OW 69
61851: AND
61852: IFFALSE 62105
61854: GO 61856
61856: DISABLE
61857: LD_INT 0
61859: PPUSH
61860: PPUSH
// begin enable ;
61861: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
61862: LD_ADDR_VAR 0 1
61866: PUSH
61867: LD_INT 34
61869: PUSH
61870: LD_INT 99
61872: PUSH
61873: EMPTY
61874: LIST
61875: LIST
61876: PPUSH
61877: CALL_OW 69
61881: PUSH
61882: FOR_IN
61883: IFFALSE 62103
// begin if not i in hackTanks then
61885: LD_VAR 0 1
61889: PUSH
61890: LD_EXP 88
61894: IN
61895: NOT
61896: IFFALSE 61979
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
61898: LD_ADDR_EXP 88
61902: PUSH
61903: LD_EXP 88
61907: PPUSH
61908: LD_EXP 88
61912: PUSH
61913: LD_INT 1
61915: PLUS
61916: PPUSH
61917: LD_VAR 0 1
61921: PPUSH
61922: CALL_OW 1
61926: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
61927: LD_ADDR_EXP 89
61931: PUSH
61932: LD_EXP 89
61936: PPUSH
61937: LD_EXP 89
61941: PUSH
61942: LD_INT 1
61944: PLUS
61945: PPUSH
61946: EMPTY
61947: PPUSH
61948: CALL_OW 1
61952: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
61953: LD_ADDR_EXP 92
61957: PUSH
61958: LD_EXP 92
61962: PPUSH
61963: LD_EXP 92
61967: PUSH
61968: LD_INT 1
61970: PLUS
61971: PPUSH
61972: EMPTY
61973: PPUSH
61974: CALL_OW 1
61978: ST_TO_ADDR
// end ; if not IsOk ( i ) then
61979: LD_VAR 0 1
61983: PPUSH
61984: CALL_OW 302
61988: NOT
61989: IFFALSE 62002
// begin HackUnlinkAll ( i ) ;
61991: LD_VAR 0 1
61995: PPUSH
61996: CALL 62108 0 1
// continue ;
62000: GO 61882
// end ; HackCheckCapturedStatus ( i ) ;
62002: LD_VAR 0 1
62006: PPUSH
62007: CALL 62551 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
62011: LD_ADDR_VAR 0 2
62015: PUSH
62016: LD_INT 81
62018: PUSH
62019: LD_VAR 0 1
62023: PPUSH
62024: CALL_OW 255
62028: PUSH
62029: EMPTY
62030: LIST
62031: LIST
62032: PUSH
62033: LD_INT 33
62035: PUSH
62036: LD_INT 3
62038: PUSH
62039: EMPTY
62040: LIST
62041: LIST
62042: PUSH
62043: LD_INT 91
62045: PUSH
62046: LD_VAR 0 1
62050: PUSH
62051: LD_EXP 91
62055: PUSH
62056: EMPTY
62057: LIST
62058: LIST
62059: LIST
62060: PUSH
62061: LD_INT 50
62063: PUSH
62064: EMPTY
62065: LIST
62066: PUSH
62067: EMPTY
62068: LIST
62069: LIST
62070: LIST
62071: LIST
62072: PPUSH
62073: CALL_OW 69
62077: ST_TO_ADDR
// if not tmp then
62078: LD_VAR 0 2
62082: NOT
62083: IFFALSE 62087
// continue ;
62085: GO 61882
// HackLink ( i , tmp ) ;
62087: LD_VAR 0 1
62091: PPUSH
62092: LD_VAR 0 2
62096: PPUSH
62097: CALL 62244 0 2
// end ;
62101: GO 61882
62103: POP
62104: POP
// end ;
62105: PPOPN 2
62107: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
62108: LD_INT 0
62110: PPUSH
62111: PPUSH
62112: PPUSH
// if not hack in hackTanks then
62113: LD_VAR 0 1
62117: PUSH
62118: LD_EXP 88
62122: IN
62123: NOT
62124: IFFALSE 62128
// exit ;
62126: GO 62239
// index := GetElementIndex ( hackTanks , hack ) ;
62128: LD_ADDR_VAR 0 4
62132: PUSH
62133: LD_EXP 88
62137: PPUSH
62138: LD_VAR 0 1
62142: PPUSH
62143: CALL 24146 0 2
62147: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
62148: LD_EXP 89
62152: PUSH
62153: LD_VAR 0 4
62157: ARRAY
62158: IFFALSE 62239
// begin for i in hackTanksCaptured [ index ] do
62160: LD_ADDR_VAR 0 3
62164: PUSH
62165: LD_EXP 89
62169: PUSH
62170: LD_VAR 0 4
62174: ARRAY
62175: PUSH
62176: FOR_IN
62177: IFFALSE 62203
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
62179: LD_VAR 0 3
62183: PUSH
62184: LD_INT 1
62186: ARRAY
62187: PPUSH
62188: LD_VAR 0 3
62192: PUSH
62193: LD_INT 2
62195: ARRAY
62196: PPUSH
62197: CALL_OW 235
62201: GO 62176
62203: POP
62204: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
62205: LD_ADDR_EXP 89
62209: PUSH
62210: LD_EXP 89
62214: PPUSH
62215: LD_VAR 0 4
62219: PPUSH
62220: EMPTY
62221: PPUSH
62222: CALL_OW 1
62226: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
62227: LD_VAR 0 1
62231: PPUSH
62232: LD_INT 0
62234: PPUSH
62235: CALL_OW 505
// end ; end ;
62239: LD_VAR 0 2
62243: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
62244: LD_INT 0
62246: PPUSH
62247: PPUSH
62248: PPUSH
// if not hack in hackTanks or not vehicles then
62249: LD_VAR 0 1
62253: PUSH
62254: LD_EXP 88
62258: IN
62259: NOT
62260: PUSH
62261: LD_VAR 0 2
62265: NOT
62266: OR
62267: IFFALSE 62271
// exit ;
62269: GO 62546
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
62271: LD_ADDR_VAR 0 2
62275: PUSH
62276: LD_VAR 0 1
62280: PPUSH
62281: LD_VAR 0 2
62285: PPUSH
62286: LD_INT 1
62288: PPUSH
62289: LD_INT 1
62291: PPUSH
62292: CALL 24796 0 4
62296: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
62297: LD_ADDR_VAR 0 5
62301: PUSH
62302: LD_EXP 88
62306: PPUSH
62307: LD_VAR 0 1
62311: PPUSH
62312: CALL 24146 0 2
62316: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
62317: LD_EXP 89
62321: PUSH
62322: LD_VAR 0 5
62326: ARRAY
62327: PUSH
62328: LD_EXP 90
62332: LESS
62333: IFFALSE 62522
// begin for i := 1 to vehicles do
62335: LD_ADDR_VAR 0 4
62339: PUSH
62340: DOUBLE
62341: LD_INT 1
62343: DEC
62344: ST_TO_ADDR
62345: LD_VAR 0 2
62349: PUSH
62350: FOR_TO
62351: IFFALSE 62520
// begin if hackTanksCaptured [ index ] = hackLimit then
62353: LD_EXP 89
62357: PUSH
62358: LD_VAR 0 5
62362: ARRAY
62363: PUSH
62364: LD_EXP 90
62368: EQUAL
62369: IFFALSE 62373
// break ;
62371: GO 62520
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
62373: LD_ADDR_EXP 92
62377: PUSH
62378: LD_EXP 92
62382: PPUSH
62383: LD_VAR 0 5
62387: PPUSH
62388: LD_EXP 92
62392: PUSH
62393: LD_VAR 0 5
62397: ARRAY
62398: PUSH
62399: LD_INT 1
62401: PLUS
62402: PPUSH
62403: CALL_OW 1
62407: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
62408: LD_ADDR_EXP 89
62412: PUSH
62413: LD_EXP 89
62417: PPUSH
62418: LD_VAR 0 5
62422: PUSH
62423: LD_EXP 89
62427: PUSH
62428: LD_VAR 0 5
62432: ARRAY
62433: PUSH
62434: LD_INT 1
62436: PLUS
62437: PUSH
62438: EMPTY
62439: LIST
62440: LIST
62441: PPUSH
62442: LD_VAR 0 2
62446: PUSH
62447: LD_VAR 0 4
62451: ARRAY
62452: PUSH
62453: LD_VAR 0 2
62457: PUSH
62458: LD_VAR 0 4
62462: ARRAY
62463: PPUSH
62464: CALL_OW 255
62468: PUSH
62469: EMPTY
62470: LIST
62471: LIST
62472: PPUSH
62473: CALL 24361 0 3
62477: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
62478: LD_VAR 0 2
62482: PUSH
62483: LD_VAR 0 4
62487: ARRAY
62488: PPUSH
62489: LD_VAR 0 1
62493: PPUSH
62494: CALL_OW 255
62498: PPUSH
62499: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
62503: LD_VAR 0 2
62507: PUSH
62508: LD_VAR 0 4
62512: ARRAY
62513: PPUSH
62514: CALL_OW 141
// end ;
62518: GO 62350
62520: POP
62521: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
62522: LD_VAR 0 1
62526: PPUSH
62527: LD_EXP 89
62531: PUSH
62532: LD_VAR 0 5
62536: ARRAY
62537: PUSH
62538: LD_INT 0
62540: PLUS
62541: PPUSH
62542: CALL_OW 505
// end ;
62546: LD_VAR 0 3
62550: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
62551: LD_INT 0
62553: PPUSH
62554: PPUSH
62555: PPUSH
62556: PPUSH
// if not hack in hackTanks then
62557: LD_VAR 0 1
62561: PUSH
62562: LD_EXP 88
62566: IN
62567: NOT
62568: IFFALSE 62572
// exit ;
62570: GO 62812
// index := GetElementIndex ( hackTanks , hack ) ;
62572: LD_ADDR_VAR 0 4
62576: PUSH
62577: LD_EXP 88
62581: PPUSH
62582: LD_VAR 0 1
62586: PPUSH
62587: CALL 24146 0 2
62591: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
62592: LD_ADDR_VAR 0 3
62596: PUSH
62597: DOUBLE
62598: LD_EXP 89
62602: PUSH
62603: LD_VAR 0 4
62607: ARRAY
62608: INC
62609: ST_TO_ADDR
62610: LD_INT 1
62612: PUSH
62613: FOR_DOWNTO
62614: IFFALSE 62786
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
62616: LD_ADDR_VAR 0 5
62620: PUSH
62621: LD_EXP 89
62625: PUSH
62626: LD_VAR 0 4
62630: ARRAY
62631: PUSH
62632: LD_VAR 0 3
62636: ARRAY
62637: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
62638: LD_VAR 0 5
62642: PUSH
62643: LD_INT 1
62645: ARRAY
62646: PPUSH
62647: CALL_OW 302
62651: NOT
62652: PUSH
62653: LD_VAR 0 5
62657: PUSH
62658: LD_INT 1
62660: ARRAY
62661: PPUSH
62662: CALL_OW 255
62666: PUSH
62667: LD_VAR 0 1
62671: PPUSH
62672: CALL_OW 255
62676: NONEQUAL
62677: OR
62678: IFFALSE 62784
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
62680: LD_VAR 0 5
62684: PUSH
62685: LD_INT 1
62687: ARRAY
62688: PPUSH
62689: CALL_OW 305
62693: PUSH
62694: LD_VAR 0 5
62698: PUSH
62699: LD_INT 1
62701: ARRAY
62702: PPUSH
62703: CALL_OW 255
62707: PUSH
62708: LD_VAR 0 1
62712: PPUSH
62713: CALL_OW 255
62717: EQUAL
62718: AND
62719: IFFALSE 62743
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
62721: LD_VAR 0 5
62725: PUSH
62726: LD_INT 1
62728: ARRAY
62729: PPUSH
62730: LD_VAR 0 5
62734: PUSH
62735: LD_INT 2
62737: ARRAY
62738: PPUSH
62739: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
62743: LD_ADDR_EXP 89
62747: PUSH
62748: LD_EXP 89
62752: PPUSH
62753: LD_VAR 0 4
62757: PPUSH
62758: LD_EXP 89
62762: PUSH
62763: LD_VAR 0 4
62767: ARRAY
62768: PPUSH
62769: LD_VAR 0 3
62773: PPUSH
62774: CALL_OW 3
62778: PPUSH
62779: CALL_OW 1
62783: ST_TO_ADDR
// end ; end ;
62784: GO 62613
62786: POP
62787: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
62788: LD_VAR 0 1
62792: PPUSH
62793: LD_EXP 89
62797: PUSH
62798: LD_VAR 0 4
62802: ARRAY
62803: PUSH
62804: LD_INT 0
62806: PLUS
62807: PPUSH
62808: CALL_OW 505
// end ;
62812: LD_VAR 0 2
62816: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
62817: LD_INT 0
62819: PPUSH
62820: PPUSH
62821: PPUSH
62822: PPUSH
// if not hack in hackTanks then
62823: LD_VAR 0 1
62827: PUSH
62828: LD_EXP 88
62832: IN
62833: NOT
62834: IFFALSE 62838
// exit ;
62836: GO 62923
// index := GetElementIndex ( hackTanks , hack ) ;
62838: LD_ADDR_VAR 0 5
62842: PUSH
62843: LD_EXP 88
62847: PPUSH
62848: LD_VAR 0 1
62852: PPUSH
62853: CALL 24146 0 2
62857: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
62858: LD_ADDR_VAR 0 4
62862: PUSH
62863: DOUBLE
62864: LD_INT 1
62866: DEC
62867: ST_TO_ADDR
62868: LD_EXP 89
62872: PUSH
62873: LD_VAR 0 5
62877: ARRAY
62878: PUSH
62879: FOR_TO
62880: IFFALSE 62921
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
62882: LD_EXP 89
62886: PUSH
62887: LD_VAR 0 5
62891: ARRAY
62892: PUSH
62893: LD_VAR 0 4
62897: ARRAY
62898: PUSH
62899: LD_INT 1
62901: ARRAY
62902: PUSH
62903: LD_VAR 0 2
62907: EQUAL
62908: IFFALSE 62919
// KillUnit ( vehicle ) ;
62910: LD_VAR 0 2
62914: PPUSH
62915: CALL_OW 66
62919: GO 62879
62921: POP
62922: POP
// end ;
62923: LD_VAR 0 3
62927: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
62928: LD_EXP 93
62932: NOT
62933: IFFALSE 62968
62935: GO 62937
62937: DISABLE
// begin initMiner := true ;
62938: LD_ADDR_EXP 93
62942: PUSH
62943: LD_INT 1
62945: ST_TO_ADDR
// minersList := [ ] ;
62946: LD_ADDR_EXP 94
62950: PUSH
62951: EMPTY
62952: ST_TO_ADDR
// minerMinesList := [ ] ;
62953: LD_ADDR_EXP 95
62957: PUSH
62958: EMPTY
62959: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
62960: LD_ADDR_EXP 96
62964: PUSH
62965: LD_INT 5
62967: ST_TO_ADDR
// end ;
62968: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
62969: LD_EXP 93
62973: PUSH
62974: LD_INT 34
62976: PUSH
62977: LD_INT 81
62979: PUSH
62980: EMPTY
62981: LIST
62982: LIST
62983: PPUSH
62984: CALL_OW 69
62988: AND
62989: IFFALSE 63450
62991: GO 62993
62993: DISABLE
62994: LD_INT 0
62996: PPUSH
62997: PPUSH
62998: PPUSH
62999: PPUSH
// begin enable ;
63000: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
63001: LD_ADDR_VAR 0 1
63005: PUSH
63006: LD_INT 34
63008: PUSH
63009: LD_INT 81
63011: PUSH
63012: EMPTY
63013: LIST
63014: LIST
63015: PPUSH
63016: CALL_OW 69
63020: PUSH
63021: FOR_IN
63022: IFFALSE 63094
// begin if not i in minersList then
63024: LD_VAR 0 1
63028: PUSH
63029: LD_EXP 94
63033: IN
63034: NOT
63035: IFFALSE 63092
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
63037: LD_ADDR_EXP 94
63041: PUSH
63042: LD_EXP 94
63046: PPUSH
63047: LD_EXP 94
63051: PUSH
63052: LD_INT 1
63054: PLUS
63055: PPUSH
63056: LD_VAR 0 1
63060: PPUSH
63061: CALL_OW 1
63065: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
63066: LD_ADDR_EXP 95
63070: PUSH
63071: LD_EXP 95
63075: PPUSH
63076: LD_EXP 95
63080: PUSH
63081: LD_INT 1
63083: PLUS
63084: PPUSH
63085: EMPTY
63086: PPUSH
63087: CALL_OW 1
63091: ST_TO_ADDR
// end end ;
63092: GO 63021
63094: POP
63095: POP
// for i := minerMinesList downto 1 do
63096: LD_ADDR_VAR 0 1
63100: PUSH
63101: DOUBLE
63102: LD_EXP 95
63106: INC
63107: ST_TO_ADDR
63108: LD_INT 1
63110: PUSH
63111: FOR_DOWNTO
63112: IFFALSE 63448
// begin if IsLive ( minersList [ i ] ) then
63114: LD_EXP 94
63118: PUSH
63119: LD_VAR 0 1
63123: ARRAY
63124: PPUSH
63125: CALL_OW 300
63129: IFFALSE 63157
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
63131: LD_EXP 94
63135: PUSH
63136: LD_VAR 0 1
63140: ARRAY
63141: PPUSH
63142: LD_EXP 95
63146: PUSH
63147: LD_VAR 0 1
63151: ARRAY
63152: PPUSH
63153: CALL_OW 505
// if not minerMinesList [ i ] then
63157: LD_EXP 95
63161: PUSH
63162: LD_VAR 0 1
63166: ARRAY
63167: NOT
63168: IFFALSE 63172
// continue ;
63170: GO 63111
// for j := minerMinesList [ i ] downto 1 do
63172: LD_ADDR_VAR 0 2
63176: PUSH
63177: DOUBLE
63178: LD_EXP 95
63182: PUSH
63183: LD_VAR 0 1
63187: ARRAY
63188: INC
63189: ST_TO_ADDR
63190: LD_INT 1
63192: PUSH
63193: FOR_DOWNTO
63194: IFFALSE 63444
// begin side := GetSide ( minersList [ i ] ) ;
63196: LD_ADDR_VAR 0 3
63200: PUSH
63201: LD_EXP 94
63205: PUSH
63206: LD_VAR 0 1
63210: ARRAY
63211: PPUSH
63212: CALL_OW 255
63216: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
63217: LD_ADDR_VAR 0 4
63221: PUSH
63222: LD_EXP 95
63226: PUSH
63227: LD_VAR 0 1
63231: ARRAY
63232: PUSH
63233: LD_VAR 0 2
63237: ARRAY
63238: PUSH
63239: LD_INT 1
63241: ARRAY
63242: PPUSH
63243: LD_EXP 95
63247: PUSH
63248: LD_VAR 0 1
63252: ARRAY
63253: PUSH
63254: LD_VAR 0 2
63258: ARRAY
63259: PUSH
63260: LD_INT 2
63262: ARRAY
63263: PPUSH
63264: CALL_OW 428
63268: ST_TO_ADDR
// if not tmp then
63269: LD_VAR 0 4
63273: NOT
63274: IFFALSE 63278
// continue ;
63276: GO 63193
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
63278: LD_VAR 0 4
63282: PUSH
63283: LD_INT 81
63285: PUSH
63286: LD_VAR 0 3
63290: PUSH
63291: EMPTY
63292: LIST
63293: LIST
63294: PPUSH
63295: CALL_OW 69
63299: IN
63300: PUSH
63301: LD_EXP 95
63305: PUSH
63306: LD_VAR 0 1
63310: ARRAY
63311: PUSH
63312: LD_VAR 0 2
63316: ARRAY
63317: PUSH
63318: LD_INT 1
63320: ARRAY
63321: PPUSH
63322: LD_EXP 95
63326: PUSH
63327: LD_VAR 0 1
63331: ARRAY
63332: PUSH
63333: LD_VAR 0 2
63337: ARRAY
63338: PUSH
63339: LD_INT 2
63341: ARRAY
63342: PPUSH
63343: CALL_OW 458
63347: AND
63348: IFFALSE 63442
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
63350: LD_EXP 95
63354: PUSH
63355: LD_VAR 0 1
63359: ARRAY
63360: PUSH
63361: LD_VAR 0 2
63365: ARRAY
63366: PUSH
63367: LD_INT 1
63369: ARRAY
63370: PPUSH
63371: LD_EXP 95
63375: PUSH
63376: LD_VAR 0 1
63380: ARRAY
63381: PUSH
63382: LD_VAR 0 2
63386: ARRAY
63387: PUSH
63388: LD_INT 2
63390: ARRAY
63391: PPUSH
63392: LD_VAR 0 3
63396: PPUSH
63397: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
63401: LD_ADDR_EXP 95
63405: PUSH
63406: LD_EXP 95
63410: PPUSH
63411: LD_VAR 0 1
63415: PPUSH
63416: LD_EXP 95
63420: PUSH
63421: LD_VAR 0 1
63425: ARRAY
63426: PPUSH
63427: LD_VAR 0 2
63431: PPUSH
63432: CALL_OW 3
63436: PPUSH
63437: CALL_OW 1
63441: ST_TO_ADDR
// end ; end ;
63442: GO 63193
63444: POP
63445: POP
// end ;
63446: GO 63111
63448: POP
63449: POP
// end ;
63450: PPOPN 4
63452: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
63453: LD_INT 0
63455: PPUSH
63456: PPUSH
// result := false ;
63457: LD_ADDR_VAR 0 4
63461: PUSH
63462: LD_INT 0
63464: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
63465: LD_VAR 0 1
63469: PPUSH
63470: CALL_OW 264
63474: PUSH
63475: LD_INT 81
63477: EQUAL
63478: NOT
63479: IFFALSE 63483
// exit ;
63481: GO 63723
// index := GetElementIndex ( minersList , unit ) ;
63483: LD_ADDR_VAR 0 5
63487: PUSH
63488: LD_EXP 94
63492: PPUSH
63493: LD_VAR 0 1
63497: PPUSH
63498: CALL 24146 0 2
63502: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
63503: LD_EXP 95
63507: PUSH
63508: LD_VAR 0 5
63512: ARRAY
63513: PUSH
63514: LD_EXP 96
63518: GREATEREQUAL
63519: IFFALSE 63523
// exit ;
63521: GO 63723
// ComMoveXY ( unit , x , y ) ;
63523: LD_VAR 0 1
63527: PPUSH
63528: LD_VAR 0 2
63532: PPUSH
63533: LD_VAR 0 3
63537: PPUSH
63538: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
63542: LD_INT 35
63544: PPUSH
63545: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
63549: LD_VAR 0 1
63553: PPUSH
63554: LD_VAR 0 2
63558: PPUSH
63559: LD_VAR 0 3
63563: PPUSH
63564: CALL 55501 0 3
63568: NOT
63569: PUSH
63570: LD_VAR 0 1
63574: PPUSH
63575: CALL_OW 314
63579: AND
63580: IFFALSE 63584
// exit ;
63582: GO 63723
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
63584: LD_VAR 0 2
63588: PPUSH
63589: LD_VAR 0 3
63593: PPUSH
63594: CALL_OW 428
63598: PUSH
63599: LD_VAR 0 1
63603: EQUAL
63604: PUSH
63605: LD_VAR 0 1
63609: PPUSH
63610: CALL_OW 314
63614: NOT
63615: AND
63616: IFFALSE 63542
// PlaySoundXY ( x , y , PlantMine ) ;
63618: LD_VAR 0 2
63622: PPUSH
63623: LD_VAR 0 3
63627: PPUSH
63628: LD_STRING PlantMine
63630: PPUSH
63631: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
63635: LD_VAR 0 2
63639: PPUSH
63640: LD_VAR 0 3
63644: PPUSH
63645: LD_VAR 0 1
63649: PPUSH
63650: CALL_OW 255
63654: PPUSH
63655: LD_INT 0
63657: PPUSH
63658: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
63662: LD_ADDR_EXP 95
63666: PUSH
63667: LD_EXP 95
63671: PPUSH
63672: LD_VAR 0 5
63676: PUSH
63677: LD_EXP 95
63681: PUSH
63682: LD_VAR 0 5
63686: ARRAY
63687: PUSH
63688: LD_INT 1
63690: PLUS
63691: PUSH
63692: EMPTY
63693: LIST
63694: LIST
63695: PPUSH
63696: LD_VAR 0 2
63700: PUSH
63701: LD_VAR 0 3
63705: PUSH
63706: EMPTY
63707: LIST
63708: LIST
63709: PPUSH
63710: CALL 24361 0 3
63714: ST_TO_ADDR
// result := true ;
63715: LD_ADDR_VAR 0 4
63719: PUSH
63720: LD_INT 1
63722: ST_TO_ADDR
// end ;
63723: LD_VAR 0 4
63727: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
63728: LD_INT 0
63730: PPUSH
63731: PPUSH
63732: PPUSH
// if not unit in minersList then
63733: LD_VAR 0 1
63737: PUSH
63738: LD_EXP 94
63742: IN
63743: NOT
63744: IFFALSE 63748
// exit ;
63746: GO 64140
// index := GetElementIndex ( minersList , unit ) ;
63748: LD_ADDR_VAR 0 6
63752: PUSH
63753: LD_EXP 94
63757: PPUSH
63758: LD_VAR 0 1
63762: PPUSH
63763: CALL 24146 0 2
63767: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
63768: LD_ADDR_VAR 0 5
63772: PUSH
63773: DOUBLE
63774: LD_EXP 95
63778: PUSH
63779: LD_VAR 0 6
63783: ARRAY
63784: INC
63785: ST_TO_ADDR
63786: LD_INT 1
63788: PUSH
63789: FOR_DOWNTO
63790: IFFALSE 63951
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
63792: LD_EXP 95
63796: PUSH
63797: LD_VAR 0 6
63801: ARRAY
63802: PUSH
63803: LD_VAR 0 5
63807: ARRAY
63808: PUSH
63809: LD_INT 1
63811: ARRAY
63812: PUSH
63813: LD_VAR 0 2
63817: EQUAL
63818: PUSH
63819: LD_EXP 95
63823: PUSH
63824: LD_VAR 0 6
63828: ARRAY
63829: PUSH
63830: LD_VAR 0 5
63834: ARRAY
63835: PUSH
63836: LD_INT 2
63838: ARRAY
63839: PUSH
63840: LD_VAR 0 3
63844: EQUAL
63845: AND
63846: IFFALSE 63949
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
63848: LD_EXP 95
63852: PUSH
63853: LD_VAR 0 6
63857: ARRAY
63858: PUSH
63859: LD_VAR 0 5
63863: ARRAY
63864: PUSH
63865: LD_INT 1
63867: ARRAY
63868: PPUSH
63869: LD_EXP 95
63873: PUSH
63874: LD_VAR 0 6
63878: ARRAY
63879: PUSH
63880: LD_VAR 0 5
63884: ARRAY
63885: PUSH
63886: LD_INT 2
63888: ARRAY
63889: PPUSH
63890: LD_VAR 0 1
63894: PPUSH
63895: CALL_OW 255
63899: PPUSH
63900: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
63904: LD_ADDR_EXP 95
63908: PUSH
63909: LD_EXP 95
63913: PPUSH
63914: LD_VAR 0 6
63918: PPUSH
63919: LD_EXP 95
63923: PUSH
63924: LD_VAR 0 6
63928: ARRAY
63929: PPUSH
63930: LD_VAR 0 5
63934: PPUSH
63935: CALL_OW 3
63939: PPUSH
63940: CALL_OW 1
63944: ST_TO_ADDR
// exit ;
63945: POP
63946: POP
63947: GO 64140
// end ; end ;
63949: GO 63789
63951: POP
63952: POP
// for i := minerMinesList [ index ] downto 1 do
63953: LD_ADDR_VAR 0 5
63957: PUSH
63958: DOUBLE
63959: LD_EXP 95
63963: PUSH
63964: LD_VAR 0 6
63968: ARRAY
63969: INC
63970: ST_TO_ADDR
63971: LD_INT 1
63973: PUSH
63974: FOR_DOWNTO
63975: IFFALSE 64138
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
63977: LD_EXP 95
63981: PUSH
63982: LD_VAR 0 6
63986: ARRAY
63987: PUSH
63988: LD_VAR 0 5
63992: ARRAY
63993: PUSH
63994: LD_INT 1
63996: ARRAY
63997: PPUSH
63998: LD_EXP 95
64002: PUSH
64003: LD_VAR 0 6
64007: ARRAY
64008: PUSH
64009: LD_VAR 0 5
64013: ARRAY
64014: PUSH
64015: LD_INT 2
64017: ARRAY
64018: PPUSH
64019: LD_VAR 0 2
64023: PPUSH
64024: LD_VAR 0 3
64028: PPUSH
64029: CALL_OW 298
64033: PUSH
64034: LD_INT 6
64036: LESS
64037: IFFALSE 64136
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
64039: LD_EXP 95
64043: PUSH
64044: LD_VAR 0 6
64048: ARRAY
64049: PUSH
64050: LD_VAR 0 5
64054: ARRAY
64055: PUSH
64056: LD_INT 1
64058: ARRAY
64059: PPUSH
64060: LD_EXP 95
64064: PUSH
64065: LD_VAR 0 6
64069: ARRAY
64070: PUSH
64071: LD_VAR 0 5
64075: ARRAY
64076: PUSH
64077: LD_INT 2
64079: ARRAY
64080: PPUSH
64081: LD_VAR 0 1
64085: PPUSH
64086: CALL_OW 255
64090: PPUSH
64091: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
64095: LD_ADDR_EXP 95
64099: PUSH
64100: LD_EXP 95
64104: PPUSH
64105: LD_VAR 0 6
64109: PPUSH
64110: LD_EXP 95
64114: PUSH
64115: LD_VAR 0 6
64119: ARRAY
64120: PPUSH
64121: LD_VAR 0 5
64125: PPUSH
64126: CALL_OW 3
64130: PPUSH
64131: CALL_OW 1
64135: ST_TO_ADDR
// end ; end ;
64136: GO 63974
64138: POP
64139: POP
// end ;
64140: LD_VAR 0 4
64144: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
64145: LD_INT 0
64147: PPUSH
64148: PPUSH
64149: PPUSH
64150: PPUSH
64151: PPUSH
64152: PPUSH
64153: PPUSH
64154: PPUSH
64155: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
64156: LD_VAR 0 1
64160: PPUSH
64161: CALL_OW 264
64165: PUSH
64166: LD_INT 81
64168: EQUAL
64169: NOT
64170: PUSH
64171: LD_VAR 0 1
64175: PUSH
64176: LD_EXP 94
64180: IN
64181: NOT
64182: OR
64183: IFFALSE 64187
// exit ;
64185: GO 64509
// index := GetElementIndex ( minersList , unit ) ;
64187: LD_ADDR_VAR 0 6
64191: PUSH
64192: LD_EXP 94
64196: PPUSH
64197: LD_VAR 0 1
64201: PPUSH
64202: CALL 24146 0 2
64206: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
64207: LD_ADDR_VAR 0 8
64211: PUSH
64212: LD_EXP 96
64216: PUSH
64217: LD_EXP 95
64221: PUSH
64222: LD_VAR 0 6
64226: ARRAY
64227: MINUS
64228: ST_TO_ADDR
// if not minesFreeAmount then
64229: LD_VAR 0 8
64233: NOT
64234: IFFALSE 64238
// exit ;
64236: GO 64509
// tmp := [ ] ;
64238: LD_ADDR_VAR 0 7
64242: PUSH
64243: EMPTY
64244: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
64245: LD_ADDR_VAR 0 5
64249: PUSH
64250: DOUBLE
64251: LD_INT 1
64253: DEC
64254: ST_TO_ADDR
64255: LD_VAR 0 8
64259: PUSH
64260: FOR_TO
64261: IFFALSE 64456
// begin _d := rand ( 0 , 5 ) ;
64263: LD_ADDR_VAR 0 11
64267: PUSH
64268: LD_INT 0
64270: PPUSH
64271: LD_INT 5
64273: PPUSH
64274: CALL_OW 12
64278: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
64279: LD_ADDR_VAR 0 12
64283: PUSH
64284: LD_INT 2
64286: PPUSH
64287: LD_INT 6
64289: PPUSH
64290: CALL_OW 12
64294: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
64295: LD_ADDR_VAR 0 9
64299: PUSH
64300: LD_VAR 0 2
64304: PPUSH
64305: LD_VAR 0 11
64309: PPUSH
64310: LD_VAR 0 12
64314: PPUSH
64315: CALL_OW 272
64319: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
64320: LD_ADDR_VAR 0 10
64324: PUSH
64325: LD_VAR 0 3
64329: PPUSH
64330: LD_VAR 0 11
64334: PPUSH
64335: LD_VAR 0 12
64339: PPUSH
64340: CALL_OW 273
64344: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
64345: LD_VAR 0 9
64349: PPUSH
64350: LD_VAR 0 10
64354: PPUSH
64355: CALL_OW 488
64359: PUSH
64360: LD_VAR 0 9
64364: PUSH
64365: LD_VAR 0 10
64369: PUSH
64370: EMPTY
64371: LIST
64372: LIST
64373: PUSH
64374: LD_VAR 0 7
64378: IN
64379: NOT
64380: AND
64381: PUSH
64382: LD_VAR 0 9
64386: PPUSH
64387: LD_VAR 0 10
64391: PPUSH
64392: CALL_OW 458
64396: NOT
64397: AND
64398: IFFALSE 64440
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
64400: LD_ADDR_VAR 0 7
64404: PUSH
64405: LD_VAR 0 7
64409: PPUSH
64410: LD_VAR 0 7
64414: PUSH
64415: LD_INT 1
64417: PLUS
64418: PPUSH
64419: LD_VAR 0 9
64423: PUSH
64424: LD_VAR 0 10
64428: PUSH
64429: EMPTY
64430: LIST
64431: LIST
64432: PPUSH
64433: CALL_OW 1
64437: ST_TO_ADDR
64438: GO 64454
// i := i - 1 ;
64440: LD_ADDR_VAR 0 5
64444: PUSH
64445: LD_VAR 0 5
64449: PUSH
64450: LD_INT 1
64452: MINUS
64453: ST_TO_ADDR
// end ;
64454: GO 64260
64456: POP
64457: POP
// for i in tmp do
64458: LD_ADDR_VAR 0 5
64462: PUSH
64463: LD_VAR 0 7
64467: PUSH
64468: FOR_IN
64469: IFFALSE 64507
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
64471: LD_VAR 0 1
64475: PPUSH
64476: LD_VAR 0 5
64480: PUSH
64481: LD_INT 1
64483: ARRAY
64484: PPUSH
64485: LD_VAR 0 5
64489: PUSH
64490: LD_INT 2
64492: ARRAY
64493: PPUSH
64494: CALL 63453 0 3
64498: NOT
64499: IFFALSE 64505
// exit ;
64501: POP
64502: POP
64503: GO 64509
64505: GO 64468
64507: POP
64508: POP
// end ;
64509: LD_VAR 0 4
64513: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
64514: LD_INT 0
64516: PPUSH
64517: PPUSH
64518: PPUSH
64519: PPUSH
64520: PPUSH
64521: PPUSH
64522: PPUSH
// if not GetClass ( unit ) = class_sniper then
64523: LD_VAR 0 1
64527: PPUSH
64528: CALL_OW 257
64532: PUSH
64533: LD_INT 5
64535: EQUAL
64536: NOT
64537: IFFALSE 64541
// exit ;
64539: GO 64929
// dist := 8 ;
64541: LD_ADDR_VAR 0 5
64545: PUSH
64546: LD_INT 8
64548: ST_TO_ADDR
// viewRange := 12 ;
64549: LD_ADDR_VAR 0 7
64553: PUSH
64554: LD_INT 12
64556: ST_TO_ADDR
// side := GetSide ( unit ) ;
64557: LD_ADDR_VAR 0 6
64561: PUSH
64562: LD_VAR 0 1
64566: PPUSH
64567: CALL_OW 255
64571: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
64572: LD_INT 61
64574: PPUSH
64575: LD_VAR 0 6
64579: PPUSH
64580: CALL_OW 321
64584: PUSH
64585: LD_INT 2
64587: EQUAL
64588: IFFALSE 64598
// viewRange := 16 ;
64590: LD_ADDR_VAR 0 7
64594: PUSH
64595: LD_INT 16
64597: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
64598: LD_VAR 0 1
64602: PPUSH
64603: LD_VAR 0 2
64607: PPUSH
64608: LD_VAR 0 3
64612: PPUSH
64613: CALL_OW 297
64617: PUSH
64618: LD_VAR 0 5
64622: GREATER
64623: IFFALSE 64702
// begin ComMoveXY ( unit , x , y ) ;
64625: LD_VAR 0 1
64629: PPUSH
64630: LD_VAR 0 2
64634: PPUSH
64635: LD_VAR 0 3
64639: PPUSH
64640: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
64644: LD_INT 35
64646: PPUSH
64647: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
64651: LD_VAR 0 1
64655: PPUSH
64656: LD_VAR 0 2
64660: PPUSH
64661: LD_VAR 0 3
64665: PPUSH
64666: CALL 55501 0 3
64670: NOT
64671: IFFALSE 64675
// exit ;
64673: GO 64929
// until GetDistUnitXY ( unit , x , y ) < dist ;
64675: LD_VAR 0 1
64679: PPUSH
64680: LD_VAR 0 2
64684: PPUSH
64685: LD_VAR 0 3
64689: PPUSH
64690: CALL_OW 297
64694: PUSH
64695: LD_VAR 0 5
64699: LESS
64700: IFFALSE 64644
// end ; ComTurnXY ( unit , x , y ) ;
64702: LD_VAR 0 1
64706: PPUSH
64707: LD_VAR 0 2
64711: PPUSH
64712: LD_VAR 0 3
64716: PPUSH
64717: CALL_OW 118
// wait ( 5 ) ;
64721: LD_INT 5
64723: PPUSH
64724: CALL_OW 67
// _d := GetDir ( unit ) ;
64728: LD_ADDR_VAR 0 10
64732: PUSH
64733: LD_VAR 0 1
64737: PPUSH
64738: CALL_OW 254
64742: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
64743: LD_ADDR_VAR 0 8
64747: PUSH
64748: LD_VAR 0 1
64752: PPUSH
64753: CALL_OW 250
64757: PPUSH
64758: LD_VAR 0 10
64762: PPUSH
64763: LD_VAR 0 5
64767: PPUSH
64768: CALL_OW 272
64772: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
64773: LD_ADDR_VAR 0 9
64777: PUSH
64778: LD_VAR 0 1
64782: PPUSH
64783: CALL_OW 251
64787: PPUSH
64788: LD_VAR 0 10
64792: PPUSH
64793: LD_VAR 0 5
64797: PPUSH
64798: CALL_OW 273
64802: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
64803: LD_VAR 0 8
64807: PPUSH
64808: LD_VAR 0 9
64812: PPUSH
64813: CALL_OW 488
64817: NOT
64818: IFFALSE 64822
// exit ;
64820: GO 64929
// ComAnimCustom ( unit , 1 ) ;
64822: LD_VAR 0 1
64826: PPUSH
64827: LD_INT 1
64829: PPUSH
64830: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
64834: LD_VAR 0 8
64838: PPUSH
64839: LD_VAR 0 9
64843: PPUSH
64844: LD_VAR 0 6
64848: PPUSH
64849: LD_VAR 0 7
64853: PPUSH
64854: CALL_OW 330
// repeat wait ( 1 ) ;
64858: LD_INT 1
64860: PPUSH
64861: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
64865: LD_VAR 0 1
64869: PPUSH
64870: CALL_OW 316
64874: PUSH
64875: LD_VAR 0 1
64879: PPUSH
64880: CALL_OW 314
64884: OR
64885: PUSH
64886: LD_VAR 0 1
64890: PPUSH
64891: CALL_OW 302
64895: NOT
64896: OR
64897: PUSH
64898: LD_VAR 0 1
64902: PPUSH
64903: CALL_OW 301
64907: OR
64908: IFFALSE 64858
// RemoveSeeing ( _x , _y , side ) ;
64910: LD_VAR 0 8
64914: PPUSH
64915: LD_VAR 0 9
64919: PPUSH
64920: LD_VAR 0 6
64924: PPUSH
64925: CALL_OW 331
// end ; end_of_file
64929: LD_VAR 0 4
64933: RET
// every 0 0$1 do
64934: GO 64936
64936: DISABLE
// begin enable ;
64937: ENABLE
// ToLua ( updateTimer( & tick & ); ) ;
64938: LD_STRING updateTimer(
64940: PUSH
64941: LD_OWVAR 1
64945: STR
64946: PUSH
64947: LD_STRING );
64949: STR
64950: PPUSH
64951: CALL_OW 559
// end ;
64955: END
// export function SOS_MapStart ( ) ; begin
64956: LD_INT 0
64958: PPUSH
// if streamModeActive then
64959: LD_EXP 98
64963: IFFALSE 64972
// DefineStreamItems ( true ) ;
64965: LD_INT 1
64967: PPUSH
64968: CALL 66776 0 1
// UpdateLuaVariables ( ) ;
64972: CALL 64989 0 0
// UpdateFactoryWaypoints ( ) ;
64976: CALL 79637 0 0
// UpdateWarehouseGatheringPoints ( ) ;
64980: CALL 79894 0 0
// end ;
64984: LD_VAR 0 1
64988: RET
// export globalGameSaveCounter ; function UpdateLuaVariables ( ) ; begin
64989: LD_INT 0
64991: PPUSH
// if not globalGameSaveCounter then
64992: LD_EXP 97
64996: NOT
64997: IFFALSE 65008
// ToLua ( setGameSaveCounter(0) ) else
64999: LD_STRING setGameSaveCounter(0)
65001: PPUSH
65002: CALL_OW 559
65006: GO 65040
// begin globalGameSaveCounter := Inc ( globalGameSaveCounter ) ;
65008: LD_ADDR_EXP 97
65012: PUSH
65013: LD_EXP 97
65017: PPUSH
65018: CALL 58053 0 1
65022: ST_TO_ADDR
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
65023: LD_STRING setGameSaveCounter(
65025: PUSH
65026: LD_EXP 97
65030: STR
65031: PUSH
65032: LD_STRING )
65034: STR
65035: PPUSH
65036: CALL_OW 559
// end ; ToLua ( setGameDifficulty( & Difficulty & ) ) ;
65040: LD_STRING setGameDifficulty(
65042: PUSH
65043: LD_OWVAR 67
65047: STR
65048: PUSH
65049: LD_STRING )
65051: STR
65052: PPUSH
65053: CALL_OW 559
// end ;
65057: LD_VAR 0 1
65061: RET
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
65062: LD_INT 0
65064: PPUSH
// if p2 = stream_mode then
65065: LD_VAR 0 2
65069: PUSH
65070: LD_INT 100
65072: EQUAL
65073: IFFALSE 66076
// begin if not StreamModeActive then
65075: LD_EXP 98
65079: NOT
65080: IFFALSE 65090
// StreamModeActive := true ;
65082: LD_ADDR_EXP 98
65086: PUSH
65087: LD_INT 1
65089: ST_TO_ADDR
// if p3 = 0 then
65090: LD_VAR 0 3
65094: PUSH
65095: LD_INT 0
65097: EQUAL
65098: IFFALSE 65104
// InitStreamMode ;
65100: CALL 66312 0 0
// if p3 = 1 then
65104: LD_VAR 0 3
65108: PUSH
65109: LD_INT 1
65111: EQUAL
65112: IFFALSE 65122
// sRocket := true ;
65114: LD_ADDR_EXP 103
65118: PUSH
65119: LD_INT 1
65121: ST_TO_ADDR
// if p3 = 2 then
65122: LD_VAR 0 3
65126: PUSH
65127: LD_INT 2
65129: EQUAL
65130: IFFALSE 65140
// sSpeed := true ;
65132: LD_ADDR_EXP 102
65136: PUSH
65137: LD_INT 1
65139: ST_TO_ADDR
// if p3 = 3 then
65140: LD_VAR 0 3
65144: PUSH
65145: LD_INT 3
65147: EQUAL
65148: IFFALSE 65158
// sEngine := true ;
65150: LD_ADDR_EXP 104
65154: PUSH
65155: LD_INT 1
65157: ST_TO_ADDR
// if p3 = 4 then
65158: LD_VAR 0 3
65162: PUSH
65163: LD_INT 4
65165: EQUAL
65166: IFFALSE 65176
// sSpec := true ;
65168: LD_ADDR_EXP 101
65172: PUSH
65173: LD_INT 1
65175: ST_TO_ADDR
// if p3 = 5 then
65176: LD_VAR 0 3
65180: PUSH
65181: LD_INT 5
65183: EQUAL
65184: IFFALSE 65194
// sLevel := true ;
65186: LD_ADDR_EXP 105
65190: PUSH
65191: LD_INT 1
65193: ST_TO_ADDR
// if p3 = 6 then
65194: LD_VAR 0 3
65198: PUSH
65199: LD_INT 6
65201: EQUAL
65202: IFFALSE 65212
// sArmoury := true ;
65204: LD_ADDR_EXP 106
65208: PUSH
65209: LD_INT 1
65211: ST_TO_ADDR
// if p3 = 7 then
65212: LD_VAR 0 3
65216: PUSH
65217: LD_INT 7
65219: EQUAL
65220: IFFALSE 65230
// sRadar := true ;
65222: LD_ADDR_EXP 107
65226: PUSH
65227: LD_INT 1
65229: ST_TO_ADDR
// if p3 = 8 then
65230: LD_VAR 0 3
65234: PUSH
65235: LD_INT 8
65237: EQUAL
65238: IFFALSE 65248
// sBunker := true ;
65240: LD_ADDR_EXP 108
65244: PUSH
65245: LD_INT 1
65247: ST_TO_ADDR
// if p3 = 9 then
65248: LD_VAR 0 3
65252: PUSH
65253: LD_INT 9
65255: EQUAL
65256: IFFALSE 65266
// sHack := true ;
65258: LD_ADDR_EXP 109
65262: PUSH
65263: LD_INT 1
65265: ST_TO_ADDR
// if p3 = 10 then
65266: LD_VAR 0 3
65270: PUSH
65271: LD_INT 10
65273: EQUAL
65274: IFFALSE 65284
// sFire := true ;
65276: LD_ADDR_EXP 110
65280: PUSH
65281: LD_INT 1
65283: ST_TO_ADDR
// if p3 = 11 then
65284: LD_VAR 0 3
65288: PUSH
65289: LD_INT 11
65291: EQUAL
65292: IFFALSE 65302
// sRefresh := true ;
65294: LD_ADDR_EXP 111
65298: PUSH
65299: LD_INT 1
65301: ST_TO_ADDR
// if p3 = 12 then
65302: LD_VAR 0 3
65306: PUSH
65307: LD_INT 12
65309: EQUAL
65310: IFFALSE 65320
// sExp := true ;
65312: LD_ADDR_EXP 112
65316: PUSH
65317: LD_INT 1
65319: ST_TO_ADDR
// if p3 = 13 then
65320: LD_VAR 0 3
65324: PUSH
65325: LD_INT 13
65327: EQUAL
65328: IFFALSE 65338
// sDepot := true ;
65330: LD_ADDR_EXP 113
65334: PUSH
65335: LD_INT 1
65337: ST_TO_ADDR
// if p3 = 14 then
65338: LD_VAR 0 3
65342: PUSH
65343: LD_INT 14
65345: EQUAL
65346: IFFALSE 65356
// sFlag := true ;
65348: LD_ADDR_EXP 114
65352: PUSH
65353: LD_INT 1
65355: ST_TO_ADDR
// if p3 = 15 then
65356: LD_VAR 0 3
65360: PUSH
65361: LD_INT 15
65363: EQUAL
65364: IFFALSE 65374
// sKamikadze := true ;
65366: LD_ADDR_EXP 122
65370: PUSH
65371: LD_INT 1
65373: ST_TO_ADDR
// if p3 = 16 then
65374: LD_VAR 0 3
65378: PUSH
65379: LD_INT 16
65381: EQUAL
65382: IFFALSE 65392
// sTroll := true ;
65384: LD_ADDR_EXP 123
65388: PUSH
65389: LD_INT 1
65391: ST_TO_ADDR
// if p3 = 17 then
65392: LD_VAR 0 3
65396: PUSH
65397: LD_INT 17
65399: EQUAL
65400: IFFALSE 65410
// sSlow := true ;
65402: LD_ADDR_EXP 124
65406: PUSH
65407: LD_INT 1
65409: ST_TO_ADDR
// if p3 = 18 then
65410: LD_VAR 0 3
65414: PUSH
65415: LD_INT 18
65417: EQUAL
65418: IFFALSE 65428
// sLack := true ;
65420: LD_ADDR_EXP 125
65424: PUSH
65425: LD_INT 1
65427: ST_TO_ADDR
// if p3 = 19 then
65428: LD_VAR 0 3
65432: PUSH
65433: LD_INT 19
65435: EQUAL
65436: IFFALSE 65446
// sTank := true ;
65438: LD_ADDR_EXP 127
65442: PUSH
65443: LD_INT 1
65445: ST_TO_ADDR
// if p3 = 20 then
65446: LD_VAR 0 3
65450: PUSH
65451: LD_INT 20
65453: EQUAL
65454: IFFALSE 65464
// sRemote := true ;
65456: LD_ADDR_EXP 128
65460: PUSH
65461: LD_INT 1
65463: ST_TO_ADDR
// if p3 = 21 then
65464: LD_VAR 0 3
65468: PUSH
65469: LD_INT 21
65471: EQUAL
65472: IFFALSE 65482
// sPowell := true ;
65474: LD_ADDR_EXP 129
65478: PUSH
65479: LD_INT 1
65481: ST_TO_ADDR
// if p3 = 22 then
65482: LD_VAR 0 3
65486: PUSH
65487: LD_INT 22
65489: EQUAL
65490: IFFALSE 65500
// sTeleport := true ;
65492: LD_ADDR_EXP 132
65496: PUSH
65497: LD_INT 1
65499: ST_TO_ADDR
// if p3 = 23 then
65500: LD_VAR 0 3
65504: PUSH
65505: LD_INT 23
65507: EQUAL
65508: IFFALSE 65518
// sOilTower := true ;
65510: LD_ADDR_EXP 134
65514: PUSH
65515: LD_INT 1
65517: ST_TO_ADDR
// if p3 = 24 then
65518: LD_VAR 0 3
65522: PUSH
65523: LD_INT 24
65525: EQUAL
65526: IFFALSE 65536
// sShovel := true ;
65528: LD_ADDR_EXP 135
65532: PUSH
65533: LD_INT 1
65535: ST_TO_ADDR
// if p3 = 25 then
65536: LD_VAR 0 3
65540: PUSH
65541: LD_INT 25
65543: EQUAL
65544: IFFALSE 65554
// sSheik := true ;
65546: LD_ADDR_EXP 136
65550: PUSH
65551: LD_INT 1
65553: ST_TO_ADDR
// if p3 = 26 then
65554: LD_VAR 0 3
65558: PUSH
65559: LD_INT 26
65561: EQUAL
65562: IFFALSE 65572
// sEarthquake := true ;
65564: LD_ADDR_EXP 138
65568: PUSH
65569: LD_INT 1
65571: ST_TO_ADDR
// if p3 = 27 then
65572: LD_VAR 0 3
65576: PUSH
65577: LD_INT 27
65579: EQUAL
65580: IFFALSE 65590
// sAI := true ;
65582: LD_ADDR_EXP 139
65586: PUSH
65587: LD_INT 1
65589: ST_TO_ADDR
// if p3 = 28 then
65590: LD_VAR 0 3
65594: PUSH
65595: LD_INT 28
65597: EQUAL
65598: IFFALSE 65608
// sCargo := true ;
65600: LD_ADDR_EXP 142
65604: PUSH
65605: LD_INT 1
65607: ST_TO_ADDR
// if p3 = 29 then
65608: LD_VAR 0 3
65612: PUSH
65613: LD_INT 29
65615: EQUAL
65616: IFFALSE 65626
// sDLaser := true ;
65618: LD_ADDR_EXP 143
65622: PUSH
65623: LD_INT 1
65625: ST_TO_ADDR
// if p3 = 30 then
65626: LD_VAR 0 3
65630: PUSH
65631: LD_INT 30
65633: EQUAL
65634: IFFALSE 65644
// sExchange := true ;
65636: LD_ADDR_EXP 144
65640: PUSH
65641: LD_INT 1
65643: ST_TO_ADDR
// if p3 = 31 then
65644: LD_VAR 0 3
65648: PUSH
65649: LD_INT 31
65651: EQUAL
65652: IFFALSE 65662
// sFac := true ;
65654: LD_ADDR_EXP 145
65658: PUSH
65659: LD_INT 1
65661: ST_TO_ADDR
// if p3 = 32 then
65662: LD_VAR 0 3
65666: PUSH
65667: LD_INT 32
65669: EQUAL
65670: IFFALSE 65680
// sPower := true ;
65672: LD_ADDR_EXP 146
65676: PUSH
65677: LD_INT 1
65679: ST_TO_ADDR
// if p3 = 33 then
65680: LD_VAR 0 3
65684: PUSH
65685: LD_INT 33
65687: EQUAL
65688: IFFALSE 65698
// sRandom := true ;
65690: LD_ADDR_EXP 147
65694: PUSH
65695: LD_INT 1
65697: ST_TO_ADDR
// if p3 = 34 then
65698: LD_VAR 0 3
65702: PUSH
65703: LD_INT 34
65705: EQUAL
65706: IFFALSE 65716
// sShield := true ;
65708: LD_ADDR_EXP 148
65712: PUSH
65713: LD_INT 1
65715: ST_TO_ADDR
// if p3 = 35 then
65716: LD_VAR 0 3
65720: PUSH
65721: LD_INT 35
65723: EQUAL
65724: IFFALSE 65734
// sTime := true ;
65726: LD_ADDR_EXP 149
65730: PUSH
65731: LD_INT 1
65733: ST_TO_ADDR
// if p3 = 36 then
65734: LD_VAR 0 3
65738: PUSH
65739: LD_INT 36
65741: EQUAL
65742: IFFALSE 65752
// sTools := true ;
65744: LD_ADDR_EXP 150
65748: PUSH
65749: LD_INT 1
65751: ST_TO_ADDR
// if p3 = 101 then
65752: LD_VAR 0 3
65756: PUSH
65757: LD_INT 101
65759: EQUAL
65760: IFFALSE 65770
// sSold := true ;
65762: LD_ADDR_EXP 115
65766: PUSH
65767: LD_INT 1
65769: ST_TO_ADDR
// if p3 = 102 then
65770: LD_VAR 0 3
65774: PUSH
65775: LD_INT 102
65777: EQUAL
65778: IFFALSE 65788
// sDiff := true ;
65780: LD_ADDR_EXP 116
65784: PUSH
65785: LD_INT 1
65787: ST_TO_ADDR
// if p3 = 103 then
65788: LD_VAR 0 3
65792: PUSH
65793: LD_INT 103
65795: EQUAL
65796: IFFALSE 65806
// sFog := true ;
65798: LD_ADDR_EXP 119
65802: PUSH
65803: LD_INT 1
65805: ST_TO_ADDR
// if p3 = 104 then
65806: LD_VAR 0 3
65810: PUSH
65811: LD_INT 104
65813: EQUAL
65814: IFFALSE 65824
// sReset := true ;
65816: LD_ADDR_EXP 120
65820: PUSH
65821: LD_INT 1
65823: ST_TO_ADDR
// if p3 = 105 then
65824: LD_VAR 0 3
65828: PUSH
65829: LD_INT 105
65831: EQUAL
65832: IFFALSE 65842
// sSun := true ;
65834: LD_ADDR_EXP 121
65838: PUSH
65839: LD_INT 1
65841: ST_TO_ADDR
// if p3 = 106 then
65842: LD_VAR 0 3
65846: PUSH
65847: LD_INT 106
65849: EQUAL
65850: IFFALSE 65860
// sTiger := true ;
65852: LD_ADDR_EXP 117
65856: PUSH
65857: LD_INT 1
65859: ST_TO_ADDR
// if p3 = 107 then
65860: LD_VAR 0 3
65864: PUSH
65865: LD_INT 107
65867: EQUAL
65868: IFFALSE 65878
// sBomb := true ;
65870: LD_ADDR_EXP 118
65874: PUSH
65875: LD_INT 1
65877: ST_TO_ADDR
// if p3 = 108 then
65878: LD_VAR 0 3
65882: PUSH
65883: LD_INT 108
65885: EQUAL
65886: IFFALSE 65896
// sWound := true ;
65888: LD_ADDR_EXP 126
65892: PUSH
65893: LD_INT 1
65895: ST_TO_ADDR
// if p3 = 109 then
65896: LD_VAR 0 3
65900: PUSH
65901: LD_INT 109
65903: EQUAL
65904: IFFALSE 65914
// sBetray := true ;
65906: LD_ADDR_EXP 130
65910: PUSH
65911: LD_INT 1
65913: ST_TO_ADDR
// if p3 = 110 then
65914: LD_VAR 0 3
65918: PUSH
65919: LD_INT 110
65921: EQUAL
65922: IFFALSE 65932
// sContamin := true ;
65924: LD_ADDR_EXP 131
65928: PUSH
65929: LD_INT 1
65931: ST_TO_ADDR
// if p3 = 111 then
65932: LD_VAR 0 3
65936: PUSH
65937: LD_INT 111
65939: EQUAL
65940: IFFALSE 65950
// sOil := true ;
65942: LD_ADDR_EXP 133
65946: PUSH
65947: LD_INT 1
65949: ST_TO_ADDR
// if p3 = 112 then
65950: LD_VAR 0 3
65954: PUSH
65955: LD_INT 112
65957: EQUAL
65958: IFFALSE 65968
// sStu := true ;
65960: LD_ADDR_EXP 137
65964: PUSH
65965: LD_INT 1
65967: ST_TO_ADDR
// if p3 = 113 then
65968: LD_VAR 0 3
65972: PUSH
65973: LD_INT 113
65975: EQUAL
65976: IFFALSE 65986
// sBazooka := true ;
65978: LD_ADDR_EXP 140
65982: PUSH
65983: LD_INT 1
65985: ST_TO_ADDR
// if p3 = 114 then
65986: LD_VAR 0 3
65990: PUSH
65991: LD_INT 114
65993: EQUAL
65994: IFFALSE 66004
// sMortar := true ;
65996: LD_ADDR_EXP 141
66000: PUSH
66001: LD_INT 1
66003: ST_TO_ADDR
// if p3 = 115 then
66004: LD_VAR 0 3
66008: PUSH
66009: LD_INT 115
66011: EQUAL
66012: IFFALSE 66022
// sRanger := true ;
66014: LD_ADDR_EXP 151
66018: PUSH
66019: LD_INT 1
66021: ST_TO_ADDR
// if p3 = 116 then
66022: LD_VAR 0 3
66026: PUSH
66027: LD_INT 116
66029: EQUAL
66030: IFFALSE 66040
// sComputer := true ;
66032: LD_ADDR_EXP 152
66036: PUSH
66037: LD_INT 1
66039: ST_TO_ADDR
// if p3 = 117 then
66040: LD_VAR 0 3
66044: PUSH
66045: LD_INT 117
66047: EQUAL
66048: IFFALSE 66058
// s30 := true ;
66050: LD_ADDR_EXP 153
66054: PUSH
66055: LD_INT 1
66057: ST_TO_ADDR
// if p3 = 118 then
66058: LD_VAR 0 3
66062: PUSH
66063: LD_INT 118
66065: EQUAL
66066: IFFALSE 66076
// s60 := true ;
66068: LD_ADDR_EXP 154
66072: PUSH
66073: LD_INT 1
66075: ST_TO_ADDR
// end ; if p2 = hack_mode then
66076: LD_VAR 0 2
66080: PUSH
66081: LD_INT 101
66083: EQUAL
66084: IFFALSE 66212
// begin case p3 of 1 :
66086: LD_VAR 0 3
66090: PUSH
66091: LD_INT 1
66093: DOUBLE
66094: EQUAL
66095: IFTRUE 66099
66097: GO 66106
66099: POP
// hHackUnlimitedResources ; 2 :
66100: CALL 78383 0 0
66104: GO 66212
66106: LD_INT 2
66108: DOUBLE
66109: EQUAL
66110: IFTRUE 66114
66112: GO 66121
66114: POP
// hHackSetLevel10 ; 3 :
66115: CALL 78516 0 0
66119: GO 66212
66121: LD_INT 3
66123: DOUBLE
66124: EQUAL
66125: IFTRUE 66129
66127: GO 66136
66129: POP
// hHackSetLevel10YourUnits ; 4 :
66130: CALL 78601 0 0
66134: GO 66212
66136: LD_INT 4
66138: DOUBLE
66139: EQUAL
66140: IFTRUE 66144
66142: GO 66151
66144: POP
// hHackInvincible ; 5 :
66145: CALL 79049 0 0
66149: GO 66212
66151: LD_INT 5
66153: DOUBLE
66154: EQUAL
66155: IFTRUE 66159
66157: GO 66166
66159: POP
// hHackInvisible ; 6 :
66160: CALL 79160 0 0
66164: GO 66212
66166: LD_INT 6
66168: DOUBLE
66169: EQUAL
66170: IFTRUE 66174
66172: GO 66181
66174: POP
// hHackChangeYourSide ; 7 :
66175: CALL 79217 0 0
66179: GO 66212
66181: LD_INT 7
66183: DOUBLE
66184: EQUAL
66185: IFTRUE 66189
66187: GO 66196
66189: POP
// hHackChangeUnitSide ; 8 :
66190: CALL 79259 0 0
66194: GO 66212
66196: LD_INT 8
66198: DOUBLE
66199: EQUAL
66200: IFTRUE 66204
66202: GO 66211
66204: POP
// hHackFog ; end ;
66205: CALL 79360 0 0
66209: GO 66212
66211: POP
// end ; if p2 = game_save_mode then
66212: LD_VAR 0 2
66216: PUSH
66217: LD_INT 102
66219: EQUAL
66220: IFFALSE 66285
// begin if p3 = 1 then
66222: LD_VAR 0 3
66226: PUSH
66227: LD_INT 1
66229: EQUAL
66230: IFFALSE 66242
// globalGameSaveCounter := p4 ;
66232: LD_ADDR_EXP 97
66236: PUSH
66237: LD_VAR 0 4
66241: ST_TO_ADDR
// if p3 = 2 and globalGameSaveCounter then
66242: LD_VAR 0 3
66246: PUSH
66247: LD_INT 2
66249: EQUAL
66250: PUSH
66251: LD_EXP 97
66255: AND
66256: IFFALSE 66275
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
66258: LD_STRING setGameSaveCounter(
66260: PUSH
66261: LD_EXP 97
66265: STR
66266: PUSH
66267: LD_STRING )
66269: STR
66270: PPUSH
66271: CALL_OW 559
// display_strings := globalGameSaveCounter ;
66275: LD_ADDR_OWVAR 47
66279: PUSH
66280: LD_EXP 97
66284: ST_TO_ADDR
// end ; end ;
66285: LD_VAR 0 7
66289: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger , sComputer , s30 , s60 ; every 0 0$1 do
66290: GO 66292
66292: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
66293: LD_STRING initStreamRollete();
66295: PPUSH
66296: CALL_OW 559
// InitStreamMode ;
66300: CALL 66312 0 0
// DefineStreamItems ( false ) ;
66304: LD_INT 0
66306: PPUSH
66307: CALL 66776 0 1
// end ;
66311: END
// function InitStreamMode ; begin
66312: LD_INT 0
66314: PPUSH
// streamModeActive := false ;
66315: LD_ADDR_EXP 98
66319: PUSH
66320: LD_INT 0
66322: ST_TO_ADDR
// normalCounter := 36 ;
66323: LD_ADDR_EXP 99
66327: PUSH
66328: LD_INT 36
66330: ST_TO_ADDR
// hardcoreCounter := 18 ;
66331: LD_ADDR_EXP 100
66335: PUSH
66336: LD_INT 18
66338: ST_TO_ADDR
// sRocket := false ;
66339: LD_ADDR_EXP 103
66343: PUSH
66344: LD_INT 0
66346: ST_TO_ADDR
// sSpeed := false ;
66347: LD_ADDR_EXP 102
66351: PUSH
66352: LD_INT 0
66354: ST_TO_ADDR
// sEngine := false ;
66355: LD_ADDR_EXP 104
66359: PUSH
66360: LD_INT 0
66362: ST_TO_ADDR
// sSpec := false ;
66363: LD_ADDR_EXP 101
66367: PUSH
66368: LD_INT 0
66370: ST_TO_ADDR
// sLevel := false ;
66371: LD_ADDR_EXP 105
66375: PUSH
66376: LD_INT 0
66378: ST_TO_ADDR
// sArmoury := false ;
66379: LD_ADDR_EXP 106
66383: PUSH
66384: LD_INT 0
66386: ST_TO_ADDR
// sRadar := false ;
66387: LD_ADDR_EXP 107
66391: PUSH
66392: LD_INT 0
66394: ST_TO_ADDR
// sBunker := false ;
66395: LD_ADDR_EXP 108
66399: PUSH
66400: LD_INT 0
66402: ST_TO_ADDR
// sHack := false ;
66403: LD_ADDR_EXP 109
66407: PUSH
66408: LD_INT 0
66410: ST_TO_ADDR
// sFire := false ;
66411: LD_ADDR_EXP 110
66415: PUSH
66416: LD_INT 0
66418: ST_TO_ADDR
// sRefresh := false ;
66419: LD_ADDR_EXP 111
66423: PUSH
66424: LD_INT 0
66426: ST_TO_ADDR
// sExp := false ;
66427: LD_ADDR_EXP 112
66431: PUSH
66432: LD_INT 0
66434: ST_TO_ADDR
// sDepot := false ;
66435: LD_ADDR_EXP 113
66439: PUSH
66440: LD_INT 0
66442: ST_TO_ADDR
// sFlag := false ;
66443: LD_ADDR_EXP 114
66447: PUSH
66448: LD_INT 0
66450: ST_TO_ADDR
// sKamikadze := false ;
66451: LD_ADDR_EXP 122
66455: PUSH
66456: LD_INT 0
66458: ST_TO_ADDR
// sTroll := false ;
66459: LD_ADDR_EXP 123
66463: PUSH
66464: LD_INT 0
66466: ST_TO_ADDR
// sSlow := false ;
66467: LD_ADDR_EXP 124
66471: PUSH
66472: LD_INT 0
66474: ST_TO_ADDR
// sLack := false ;
66475: LD_ADDR_EXP 125
66479: PUSH
66480: LD_INT 0
66482: ST_TO_ADDR
// sTank := false ;
66483: LD_ADDR_EXP 127
66487: PUSH
66488: LD_INT 0
66490: ST_TO_ADDR
// sRemote := false ;
66491: LD_ADDR_EXP 128
66495: PUSH
66496: LD_INT 0
66498: ST_TO_ADDR
// sPowell := false ;
66499: LD_ADDR_EXP 129
66503: PUSH
66504: LD_INT 0
66506: ST_TO_ADDR
// sTeleport := false ;
66507: LD_ADDR_EXP 132
66511: PUSH
66512: LD_INT 0
66514: ST_TO_ADDR
// sOilTower := false ;
66515: LD_ADDR_EXP 134
66519: PUSH
66520: LD_INT 0
66522: ST_TO_ADDR
// sShovel := false ;
66523: LD_ADDR_EXP 135
66527: PUSH
66528: LD_INT 0
66530: ST_TO_ADDR
// sSheik := false ;
66531: LD_ADDR_EXP 136
66535: PUSH
66536: LD_INT 0
66538: ST_TO_ADDR
// sEarthquake := false ;
66539: LD_ADDR_EXP 138
66543: PUSH
66544: LD_INT 0
66546: ST_TO_ADDR
// sAI := false ;
66547: LD_ADDR_EXP 139
66551: PUSH
66552: LD_INT 0
66554: ST_TO_ADDR
// sCargo := false ;
66555: LD_ADDR_EXP 142
66559: PUSH
66560: LD_INT 0
66562: ST_TO_ADDR
// sDLaser := false ;
66563: LD_ADDR_EXP 143
66567: PUSH
66568: LD_INT 0
66570: ST_TO_ADDR
// sExchange := false ;
66571: LD_ADDR_EXP 144
66575: PUSH
66576: LD_INT 0
66578: ST_TO_ADDR
// sFac := false ;
66579: LD_ADDR_EXP 145
66583: PUSH
66584: LD_INT 0
66586: ST_TO_ADDR
// sPower := false ;
66587: LD_ADDR_EXP 146
66591: PUSH
66592: LD_INT 0
66594: ST_TO_ADDR
// sRandom := false ;
66595: LD_ADDR_EXP 147
66599: PUSH
66600: LD_INT 0
66602: ST_TO_ADDR
// sShield := false ;
66603: LD_ADDR_EXP 148
66607: PUSH
66608: LD_INT 0
66610: ST_TO_ADDR
// sTime := false ;
66611: LD_ADDR_EXP 149
66615: PUSH
66616: LD_INT 0
66618: ST_TO_ADDR
// sTools := false ;
66619: LD_ADDR_EXP 150
66623: PUSH
66624: LD_INT 0
66626: ST_TO_ADDR
// sSold := false ;
66627: LD_ADDR_EXP 115
66631: PUSH
66632: LD_INT 0
66634: ST_TO_ADDR
// sDiff := false ;
66635: LD_ADDR_EXP 116
66639: PUSH
66640: LD_INT 0
66642: ST_TO_ADDR
// sFog := false ;
66643: LD_ADDR_EXP 119
66647: PUSH
66648: LD_INT 0
66650: ST_TO_ADDR
// sReset := false ;
66651: LD_ADDR_EXP 120
66655: PUSH
66656: LD_INT 0
66658: ST_TO_ADDR
// sSun := false ;
66659: LD_ADDR_EXP 121
66663: PUSH
66664: LD_INT 0
66666: ST_TO_ADDR
// sTiger := false ;
66667: LD_ADDR_EXP 117
66671: PUSH
66672: LD_INT 0
66674: ST_TO_ADDR
// sBomb := false ;
66675: LD_ADDR_EXP 118
66679: PUSH
66680: LD_INT 0
66682: ST_TO_ADDR
// sWound := false ;
66683: LD_ADDR_EXP 126
66687: PUSH
66688: LD_INT 0
66690: ST_TO_ADDR
// sBetray := false ;
66691: LD_ADDR_EXP 130
66695: PUSH
66696: LD_INT 0
66698: ST_TO_ADDR
// sContamin := false ;
66699: LD_ADDR_EXP 131
66703: PUSH
66704: LD_INT 0
66706: ST_TO_ADDR
// sOil := false ;
66707: LD_ADDR_EXP 133
66711: PUSH
66712: LD_INT 0
66714: ST_TO_ADDR
// sStu := false ;
66715: LD_ADDR_EXP 137
66719: PUSH
66720: LD_INT 0
66722: ST_TO_ADDR
// sBazooka := false ;
66723: LD_ADDR_EXP 140
66727: PUSH
66728: LD_INT 0
66730: ST_TO_ADDR
// sMortar := false ;
66731: LD_ADDR_EXP 141
66735: PUSH
66736: LD_INT 0
66738: ST_TO_ADDR
// sRanger := false ;
66739: LD_ADDR_EXP 151
66743: PUSH
66744: LD_INT 0
66746: ST_TO_ADDR
// sComputer := false ;
66747: LD_ADDR_EXP 152
66751: PUSH
66752: LD_INT 0
66754: ST_TO_ADDR
// s30 := false ;
66755: LD_ADDR_EXP 153
66759: PUSH
66760: LD_INT 0
66762: ST_TO_ADDR
// s60 := false ;
66763: LD_ADDR_EXP 154
66767: PUSH
66768: LD_INT 0
66770: ST_TO_ADDR
// end ;
66771: LD_VAR 0 1
66775: RET
// function DefineStreamItems ( isGameLoad ) ; var tmp , flags , normal , hardcore , active , i ; begin
66776: LD_INT 0
66778: PPUSH
66779: PPUSH
66780: PPUSH
66781: PPUSH
66782: PPUSH
66783: PPUSH
66784: PPUSH
// result := [ ] ;
66785: LD_ADDR_VAR 0 2
66789: PUSH
66790: EMPTY
66791: ST_TO_ADDR
// if campaign_id = 1 then
66792: LD_OWVAR 69
66796: PUSH
66797: LD_INT 1
66799: EQUAL
66800: IFFALSE 69966
// begin case mission_number of 1 :
66802: LD_OWVAR 70
66806: PUSH
66807: LD_INT 1
66809: DOUBLE
66810: EQUAL
66811: IFTRUE 66815
66813: GO 66891
66815: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 , 116 , 117 , 118 ] ] ; 2 :
66816: LD_ADDR_VAR 0 2
66820: PUSH
66821: LD_INT 2
66823: PUSH
66824: LD_INT 4
66826: PUSH
66827: LD_INT 11
66829: PUSH
66830: LD_INT 12
66832: PUSH
66833: LD_INT 15
66835: PUSH
66836: LD_INT 16
66838: PUSH
66839: LD_INT 22
66841: PUSH
66842: LD_INT 23
66844: PUSH
66845: LD_INT 26
66847: PUSH
66848: EMPTY
66849: LIST
66850: LIST
66851: LIST
66852: LIST
66853: LIST
66854: LIST
66855: LIST
66856: LIST
66857: LIST
66858: PUSH
66859: LD_INT 101
66861: PUSH
66862: LD_INT 102
66864: PUSH
66865: LD_INT 106
66867: PUSH
66868: LD_INT 116
66870: PUSH
66871: LD_INT 117
66873: PUSH
66874: LD_INT 118
66876: PUSH
66877: EMPTY
66878: LIST
66879: LIST
66880: LIST
66881: LIST
66882: LIST
66883: LIST
66884: PUSH
66885: EMPTY
66886: LIST
66887: LIST
66888: ST_TO_ADDR
66889: GO 69964
66891: LD_INT 2
66893: DOUBLE
66894: EQUAL
66895: IFTRUE 66899
66897: GO 66983
66899: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 3 :
66900: LD_ADDR_VAR 0 2
66904: PUSH
66905: LD_INT 2
66907: PUSH
66908: LD_INT 4
66910: PUSH
66911: LD_INT 11
66913: PUSH
66914: LD_INT 12
66916: PUSH
66917: LD_INT 15
66919: PUSH
66920: LD_INT 16
66922: PUSH
66923: LD_INT 22
66925: PUSH
66926: LD_INT 23
66928: PUSH
66929: LD_INT 26
66931: PUSH
66932: EMPTY
66933: LIST
66934: LIST
66935: LIST
66936: LIST
66937: LIST
66938: LIST
66939: LIST
66940: LIST
66941: LIST
66942: PUSH
66943: LD_INT 101
66945: PUSH
66946: LD_INT 102
66948: PUSH
66949: LD_INT 105
66951: PUSH
66952: LD_INT 106
66954: PUSH
66955: LD_INT 108
66957: PUSH
66958: LD_INT 116
66960: PUSH
66961: LD_INT 117
66963: PUSH
66964: LD_INT 118
66966: PUSH
66967: EMPTY
66968: LIST
66969: LIST
66970: LIST
66971: LIST
66972: LIST
66973: LIST
66974: LIST
66975: LIST
66976: PUSH
66977: EMPTY
66978: LIST
66979: LIST
66980: ST_TO_ADDR
66981: GO 69964
66983: LD_INT 3
66985: DOUBLE
66986: EQUAL
66987: IFTRUE 66991
66989: GO 67079
66991: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 4 :
66992: LD_ADDR_VAR 0 2
66996: PUSH
66997: LD_INT 2
66999: PUSH
67000: LD_INT 4
67002: PUSH
67003: LD_INT 5
67005: PUSH
67006: LD_INT 11
67008: PUSH
67009: LD_INT 12
67011: PUSH
67012: LD_INT 15
67014: PUSH
67015: LD_INT 16
67017: PUSH
67018: LD_INT 22
67020: PUSH
67021: LD_INT 26
67023: PUSH
67024: LD_INT 36
67026: PUSH
67027: EMPTY
67028: LIST
67029: LIST
67030: LIST
67031: LIST
67032: LIST
67033: LIST
67034: LIST
67035: LIST
67036: LIST
67037: LIST
67038: PUSH
67039: LD_INT 101
67041: PUSH
67042: LD_INT 102
67044: PUSH
67045: LD_INT 105
67047: PUSH
67048: LD_INT 106
67050: PUSH
67051: LD_INT 108
67053: PUSH
67054: LD_INT 116
67056: PUSH
67057: LD_INT 117
67059: PUSH
67060: LD_INT 118
67062: PUSH
67063: EMPTY
67064: LIST
67065: LIST
67066: LIST
67067: LIST
67068: LIST
67069: LIST
67070: LIST
67071: LIST
67072: PUSH
67073: EMPTY
67074: LIST
67075: LIST
67076: ST_TO_ADDR
67077: GO 69964
67079: LD_INT 4
67081: DOUBLE
67082: EQUAL
67083: IFTRUE 67087
67085: GO 67183
67087: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 5 :
67088: LD_ADDR_VAR 0 2
67092: PUSH
67093: LD_INT 2
67095: PUSH
67096: LD_INT 4
67098: PUSH
67099: LD_INT 5
67101: PUSH
67102: LD_INT 8
67104: PUSH
67105: LD_INT 11
67107: PUSH
67108: LD_INT 12
67110: PUSH
67111: LD_INT 15
67113: PUSH
67114: LD_INT 16
67116: PUSH
67117: LD_INT 22
67119: PUSH
67120: LD_INT 23
67122: PUSH
67123: LD_INT 26
67125: PUSH
67126: LD_INT 36
67128: PUSH
67129: EMPTY
67130: LIST
67131: LIST
67132: LIST
67133: LIST
67134: LIST
67135: LIST
67136: LIST
67137: LIST
67138: LIST
67139: LIST
67140: LIST
67141: LIST
67142: PUSH
67143: LD_INT 101
67145: PUSH
67146: LD_INT 102
67148: PUSH
67149: LD_INT 105
67151: PUSH
67152: LD_INT 106
67154: PUSH
67155: LD_INT 108
67157: PUSH
67158: LD_INT 116
67160: PUSH
67161: LD_INT 117
67163: PUSH
67164: LD_INT 118
67166: PUSH
67167: EMPTY
67168: LIST
67169: LIST
67170: LIST
67171: LIST
67172: LIST
67173: LIST
67174: LIST
67175: LIST
67176: PUSH
67177: EMPTY
67178: LIST
67179: LIST
67180: ST_TO_ADDR
67181: GO 69964
67183: LD_INT 5
67185: DOUBLE
67186: EQUAL
67187: IFTRUE 67191
67189: GO 67303
67191: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 6 :
67192: LD_ADDR_VAR 0 2
67196: PUSH
67197: LD_INT 2
67199: PUSH
67200: LD_INT 4
67202: PUSH
67203: LD_INT 5
67205: PUSH
67206: LD_INT 6
67208: PUSH
67209: LD_INT 8
67211: PUSH
67212: LD_INT 11
67214: PUSH
67215: LD_INT 12
67217: PUSH
67218: LD_INT 15
67220: PUSH
67221: LD_INT 16
67223: PUSH
67224: LD_INT 22
67226: PUSH
67227: LD_INT 23
67229: PUSH
67230: LD_INT 25
67232: PUSH
67233: LD_INT 26
67235: PUSH
67236: LD_INT 36
67238: PUSH
67239: EMPTY
67240: LIST
67241: LIST
67242: LIST
67243: LIST
67244: LIST
67245: LIST
67246: LIST
67247: LIST
67248: LIST
67249: LIST
67250: LIST
67251: LIST
67252: LIST
67253: LIST
67254: PUSH
67255: LD_INT 101
67257: PUSH
67258: LD_INT 102
67260: PUSH
67261: LD_INT 105
67263: PUSH
67264: LD_INT 106
67266: PUSH
67267: LD_INT 108
67269: PUSH
67270: LD_INT 109
67272: PUSH
67273: LD_INT 112
67275: PUSH
67276: LD_INT 116
67278: PUSH
67279: LD_INT 117
67281: PUSH
67282: LD_INT 118
67284: PUSH
67285: EMPTY
67286: LIST
67287: LIST
67288: LIST
67289: LIST
67290: LIST
67291: LIST
67292: LIST
67293: LIST
67294: LIST
67295: LIST
67296: PUSH
67297: EMPTY
67298: LIST
67299: LIST
67300: ST_TO_ADDR
67301: GO 69964
67303: LD_INT 6
67305: DOUBLE
67306: EQUAL
67307: IFTRUE 67311
67309: GO 67443
67311: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 7 :
67312: LD_ADDR_VAR 0 2
67316: PUSH
67317: LD_INT 2
67319: PUSH
67320: LD_INT 4
67322: PUSH
67323: LD_INT 5
67325: PUSH
67326: LD_INT 6
67328: PUSH
67329: LD_INT 8
67331: PUSH
67332: LD_INT 11
67334: PUSH
67335: LD_INT 12
67337: PUSH
67338: LD_INT 15
67340: PUSH
67341: LD_INT 16
67343: PUSH
67344: LD_INT 20
67346: PUSH
67347: LD_INT 21
67349: PUSH
67350: LD_INT 22
67352: PUSH
67353: LD_INT 23
67355: PUSH
67356: LD_INT 25
67358: PUSH
67359: LD_INT 26
67361: PUSH
67362: LD_INT 30
67364: PUSH
67365: LD_INT 31
67367: PUSH
67368: LD_INT 32
67370: PUSH
67371: LD_INT 36
67373: PUSH
67374: EMPTY
67375: LIST
67376: LIST
67377: LIST
67378: LIST
67379: LIST
67380: LIST
67381: LIST
67382: LIST
67383: LIST
67384: LIST
67385: LIST
67386: LIST
67387: LIST
67388: LIST
67389: LIST
67390: LIST
67391: LIST
67392: LIST
67393: LIST
67394: PUSH
67395: LD_INT 101
67397: PUSH
67398: LD_INT 102
67400: PUSH
67401: LD_INT 105
67403: PUSH
67404: LD_INT 106
67406: PUSH
67407: LD_INT 108
67409: PUSH
67410: LD_INT 109
67412: PUSH
67413: LD_INT 112
67415: PUSH
67416: LD_INT 116
67418: PUSH
67419: LD_INT 117
67421: PUSH
67422: LD_INT 118
67424: PUSH
67425: EMPTY
67426: LIST
67427: LIST
67428: LIST
67429: LIST
67430: LIST
67431: LIST
67432: LIST
67433: LIST
67434: LIST
67435: LIST
67436: PUSH
67437: EMPTY
67438: LIST
67439: LIST
67440: ST_TO_ADDR
67441: GO 69964
67443: LD_INT 7
67445: DOUBLE
67446: EQUAL
67447: IFTRUE 67451
67449: GO 67563
67451: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 , 116 , 117 , 118 ] ] ; 8 :
67452: LD_ADDR_VAR 0 2
67456: PUSH
67457: LD_INT 2
67459: PUSH
67460: LD_INT 4
67462: PUSH
67463: LD_INT 5
67465: PUSH
67466: LD_INT 7
67468: PUSH
67469: LD_INT 11
67471: PUSH
67472: LD_INT 12
67474: PUSH
67475: LD_INT 15
67477: PUSH
67478: LD_INT 16
67480: PUSH
67481: LD_INT 20
67483: PUSH
67484: LD_INT 21
67486: PUSH
67487: LD_INT 22
67489: PUSH
67490: LD_INT 23
67492: PUSH
67493: LD_INT 25
67495: PUSH
67496: LD_INT 26
67498: PUSH
67499: EMPTY
67500: LIST
67501: LIST
67502: LIST
67503: LIST
67504: LIST
67505: LIST
67506: LIST
67507: LIST
67508: LIST
67509: LIST
67510: LIST
67511: LIST
67512: LIST
67513: LIST
67514: PUSH
67515: LD_INT 101
67517: PUSH
67518: LD_INT 102
67520: PUSH
67521: LD_INT 103
67523: PUSH
67524: LD_INT 105
67526: PUSH
67527: LD_INT 106
67529: PUSH
67530: LD_INT 108
67532: PUSH
67533: LD_INT 112
67535: PUSH
67536: LD_INT 116
67538: PUSH
67539: LD_INT 117
67541: PUSH
67542: LD_INT 118
67544: PUSH
67545: EMPTY
67546: LIST
67547: LIST
67548: LIST
67549: LIST
67550: LIST
67551: LIST
67552: LIST
67553: LIST
67554: LIST
67555: LIST
67556: PUSH
67557: EMPTY
67558: LIST
67559: LIST
67560: ST_TO_ADDR
67561: GO 69964
67563: LD_INT 8
67565: DOUBLE
67566: EQUAL
67567: IFTRUE 67571
67569: GO 67711
67571: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 9 :
67572: LD_ADDR_VAR 0 2
67576: PUSH
67577: LD_INT 2
67579: PUSH
67580: LD_INT 4
67582: PUSH
67583: LD_INT 5
67585: PUSH
67586: LD_INT 6
67588: PUSH
67589: LD_INT 7
67591: PUSH
67592: LD_INT 8
67594: PUSH
67595: LD_INT 11
67597: PUSH
67598: LD_INT 12
67600: PUSH
67601: LD_INT 15
67603: PUSH
67604: LD_INT 16
67606: PUSH
67607: LD_INT 20
67609: PUSH
67610: LD_INT 21
67612: PUSH
67613: LD_INT 22
67615: PUSH
67616: LD_INT 23
67618: PUSH
67619: LD_INT 25
67621: PUSH
67622: LD_INT 26
67624: PUSH
67625: LD_INT 30
67627: PUSH
67628: LD_INT 31
67630: PUSH
67631: LD_INT 32
67633: PUSH
67634: LD_INT 36
67636: PUSH
67637: EMPTY
67638: LIST
67639: LIST
67640: LIST
67641: LIST
67642: LIST
67643: LIST
67644: LIST
67645: LIST
67646: LIST
67647: LIST
67648: LIST
67649: LIST
67650: LIST
67651: LIST
67652: LIST
67653: LIST
67654: LIST
67655: LIST
67656: LIST
67657: LIST
67658: PUSH
67659: LD_INT 101
67661: PUSH
67662: LD_INT 102
67664: PUSH
67665: LD_INT 103
67667: PUSH
67668: LD_INT 105
67670: PUSH
67671: LD_INT 106
67673: PUSH
67674: LD_INT 108
67676: PUSH
67677: LD_INT 109
67679: PUSH
67680: LD_INT 112
67682: PUSH
67683: LD_INT 116
67685: PUSH
67686: LD_INT 117
67688: PUSH
67689: LD_INT 118
67691: PUSH
67692: EMPTY
67693: LIST
67694: LIST
67695: LIST
67696: LIST
67697: LIST
67698: LIST
67699: LIST
67700: LIST
67701: LIST
67702: LIST
67703: LIST
67704: PUSH
67705: EMPTY
67706: LIST
67707: LIST
67708: ST_TO_ADDR
67709: GO 69964
67711: LD_INT 9
67713: DOUBLE
67714: EQUAL
67715: IFTRUE 67719
67717: GO 67867
67719: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 , 116 , 117 , 118 ] ] ; 10 :
67720: LD_ADDR_VAR 0 2
67724: PUSH
67725: LD_INT 2
67727: PUSH
67728: LD_INT 4
67730: PUSH
67731: LD_INT 5
67733: PUSH
67734: LD_INT 6
67736: PUSH
67737: LD_INT 7
67739: PUSH
67740: LD_INT 8
67742: PUSH
67743: LD_INT 11
67745: PUSH
67746: LD_INT 12
67748: PUSH
67749: LD_INT 15
67751: PUSH
67752: LD_INT 16
67754: PUSH
67755: LD_INT 20
67757: PUSH
67758: LD_INT 21
67760: PUSH
67761: LD_INT 22
67763: PUSH
67764: LD_INT 23
67766: PUSH
67767: LD_INT 25
67769: PUSH
67770: LD_INT 26
67772: PUSH
67773: LD_INT 28
67775: PUSH
67776: LD_INT 30
67778: PUSH
67779: LD_INT 31
67781: PUSH
67782: LD_INT 32
67784: PUSH
67785: LD_INT 36
67787: PUSH
67788: EMPTY
67789: LIST
67790: LIST
67791: LIST
67792: LIST
67793: LIST
67794: LIST
67795: LIST
67796: LIST
67797: LIST
67798: LIST
67799: LIST
67800: LIST
67801: LIST
67802: LIST
67803: LIST
67804: LIST
67805: LIST
67806: LIST
67807: LIST
67808: LIST
67809: LIST
67810: PUSH
67811: LD_INT 101
67813: PUSH
67814: LD_INT 102
67816: PUSH
67817: LD_INT 103
67819: PUSH
67820: LD_INT 105
67822: PUSH
67823: LD_INT 106
67825: PUSH
67826: LD_INT 108
67828: PUSH
67829: LD_INT 109
67831: PUSH
67832: LD_INT 112
67834: PUSH
67835: LD_INT 114
67837: PUSH
67838: LD_INT 116
67840: PUSH
67841: LD_INT 117
67843: PUSH
67844: LD_INT 118
67846: PUSH
67847: EMPTY
67848: LIST
67849: LIST
67850: LIST
67851: LIST
67852: LIST
67853: LIST
67854: LIST
67855: LIST
67856: LIST
67857: LIST
67858: LIST
67859: LIST
67860: PUSH
67861: EMPTY
67862: LIST
67863: LIST
67864: ST_TO_ADDR
67865: GO 69964
67867: LD_INT 10
67869: DOUBLE
67870: EQUAL
67871: IFTRUE 67875
67873: GO 68071
67875: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 11 :
67876: LD_ADDR_VAR 0 2
67880: PUSH
67881: LD_INT 2
67883: PUSH
67884: LD_INT 4
67886: PUSH
67887: LD_INT 5
67889: PUSH
67890: LD_INT 6
67892: PUSH
67893: LD_INT 7
67895: PUSH
67896: LD_INT 8
67898: PUSH
67899: LD_INT 9
67901: PUSH
67902: LD_INT 10
67904: PUSH
67905: LD_INT 11
67907: PUSH
67908: LD_INT 12
67910: PUSH
67911: LD_INT 13
67913: PUSH
67914: LD_INT 14
67916: PUSH
67917: LD_INT 15
67919: PUSH
67920: LD_INT 16
67922: PUSH
67923: LD_INT 17
67925: PUSH
67926: LD_INT 18
67928: PUSH
67929: LD_INT 19
67931: PUSH
67932: LD_INT 20
67934: PUSH
67935: LD_INT 21
67937: PUSH
67938: LD_INT 22
67940: PUSH
67941: LD_INT 23
67943: PUSH
67944: LD_INT 24
67946: PUSH
67947: LD_INT 25
67949: PUSH
67950: LD_INT 26
67952: PUSH
67953: LD_INT 28
67955: PUSH
67956: LD_INT 30
67958: PUSH
67959: LD_INT 31
67961: PUSH
67962: LD_INT 32
67964: PUSH
67965: LD_INT 36
67967: PUSH
67968: EMPTY
67969: LIST
67970: LIST
67971: LIST
67972: LIST
67973: LIST
67974: LIST
67975: LIST
67976: LIST
67977: LIST
67978: LIST
67979: LIST
67980: LIST
67981: LIST
67982: LIST
67983: LIST
67984: LIST
67985: LIST
67986: LIST
67987: LIST
67988: LIST
67989: LIST
67990: LIST
67991: LIST
67992: LIST
67993: LIST
67994: LIST
67995: LIST
67996: LIST
67997: LIST
67998: PUSH
67999: LD_INT 101
68001: PUSH
68002: LD_INT 102
68004: PUSH
68005: LD_INT 103
68007: PUSH
68008: LD_INT 104
68010: PUSH
68011: LD_INT 105
68013: PUSH
68014: LD_INT 106
68016: PUSH
68017: LD_INT 107
68019: PUSH
68020: LD_INT 108
68022: PUSH
68023: LD_INT 109
68025: PUSH
68026: LD_INT 110
68028: PUSH
68029: LD_INT 111
68031: PUSH
68032: LD_INT 112
68034: PUSH
68035: LD_INT 114
68037: PUSH
68038: LD_INT 116
68040: PUSH
68041: LD_INT 117
68043: PUSH
68044: LD_INT 118
68046: PUSH
68047: EMPTY
68048: LIST
68049: LIST
68050: LIST
68051: LIST
68052: LIST
68053: LIST
68054: LIST
68055: LIST
68056: LIST
68057: LIST
68058: LIST
68059: LIST
68060: LIST
68061: LIST
68062: LIST
68063: LIST
68064: PUSH
68065: EMPTY
68066: LIST
68067: LIST
68068: ST_TO_ADDR
68069: GO 69964
68071: LD_INT 11
68073: DOUBLE
68074: EQUAL
68075: IFTRUE 68079
68077: GO 68283
68079: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 12 :
68080: LD_ADDR_VAR 0 2
68084: PUSH
68085: LD_INT 2
68087: PUSH
68088: LD_INT 3
68090: PUSH
68091: LD_INT 4
68093: PUSH
68094: LD_INT 5
68096: PUSH
68097: LD_INT 6
68099: PUSH
68100: LD_INT 7
68102: PUSH
68103: LD_INT 8
68105: PUSH
68106: LD_INT 9
68108: PUSH
68109: LD_INT 10
68111: PUSH
68112: LD_INT 11
68114: PUSH
68115: LD_INT 12
68117: PUSH
68118: LD_INT 13
68120: PUSH
68121: LD_INT 14
68123: PUSH
68124: LD_INT 15
68126: PUSH
68127: LD_INT 16
68129: PUSH
68130: LD_INT 17
68132: PUSH
68133: LD_INT 18
68135: PUSH
68136: LD_INT 19
68138: PUSH
68139: LD_INT 20
68141: PUSH
68142: LD_INT 21
68144: PUSH
68145: LD_INT 22
68147: PUSH
68148: LD_INT 23
68150: PUSH
68151: LD_INT 24
68153: PUSH
68154: LD_INT 25
68156: PUSH
68157: LD_INT 26
68159: PUSH
68160: LD_INT 28
68162: PUSH
68163: LD_INT 30
68165: PUSH
68166: LD_INT 31
68168: PUSH
68169: LD_INT 32
68171: PUSH
68172: LD_INT 34
68174: PUSH
68175: LD_INT 36
68177: PUSH
68178: EMPTY
68179: LIST
68180: LIST
68181: LIST
68182: LIST
68183: LIST
68184: LIST
68185: LIST
68186: LIST
68187: LIST
68188: LIST
68189: LIST
68190: LIST
68191: LIST
68192: LIST
68193: LIST
68194: LIST
68195: LIST
68196: LIST
68197: LIST
68198: LIST
68199: LIST
68200: LIST
68201: LIST
68202: LIST
68203: LIST
68204: LIST
68205: LIST
68206: LIST
68207: LIST
68208: LIST
68209: LIST
68210: PUSH
68211: LD_INT 101
68213: PUSH
68214: LD_INT 102
68216: PUSH
68217: LD_INT 103
68219: PUSH
68220: LD_INT 104
68222: PUSH
68223: LD_INT 105
68225: PUSH
68226: LD_INT 106
68228: PUSH
68229: LD_INT 107
68231: PUSH
68232: LD_INT 108
68234: PUSH
68235: LD_INT 109
68237: PUSH
68238: LD_INT 110
68240: PUSH
68241: LD_INT 111
68243: PUSH
68244: LD_INT 112
68246: PUSH
68247: LD_INT 114
68249: PUSH
68250: LD_INT 116
68252: PUSH
68253: LD_INT 117
68255: PUSH
68256: LD_INT 118
68258: PUSH
68259: EMPTY
68260: LIST
68261: LIST
68262: LIST
68263: LIST
68264: LIST
68265: LIST
68266: LIST
68267: LIST
68268: LIST
68269: LIST
68270: LIST
68271: LIST
68272: LIST
68273: LIST
68274: LIST
68275: LIST
68276: PUSH
68277: EMPTY
68278: LIST
68279: LIST
68280: ST_TO_ADDR
68281: GO 69964
68283: LD_INT 12
68285: DOUBLE
68286: EQUAL
68287: IFTRUE 68291
68289: GO 68511
68291: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 13 :
68292: LD_ADDR_VAR 0 2
68296: PUSH
68297: LD_INT 1
68299: PUSH
68300: LD_INT 2
68302: PUSH
68303: LD_INT 3
68305: PUSH
68306: LD_INT 4
68308: PUSH
68309: LD_INT 5
68311: PUSH
68312: LD_INT 6
68314: PUSH
68315: LD_INT 7
68317: PUSH
68318: LD_INT 8
68320: PUSH
68321: LD_INT 9
68323: PUSH
68324: LD_INT 10
68326: PUSH
68327: LD_INT 11
68329: PUSH
68330: LD_INT 12
68332: PUSH
68333: LD_INT 13
68335: PUSH
68336: LD_INT 14
68338: PUSH
68339: LD_INT 15
68341: PUSH
68342: LD_INT 16
68344: PUSH
68345: LD_INT 17
68347: PUSH
68348: LD_INT 18
68350: PUSH
68351: LD_INT 19
68353: PUSH
68354: LD_INT 20
68356: PUSH
68357: LD_INT 21
68359: PUSH
68360: LD_INT 22
68362: PUSH
68363: LD_INT 23
68365: PUSH
68366: LD_INT 24
68368: PUSH
68369: LD_INT 25
68371: PUSH
68372: LD_INT 26
68374: PUSH
68375: LD_INT 27
68377: PUSH
68378: LD_INT 28
68380: PUSH
68381: LD_INT 30
68383: PUSH
68384: LD_INT 31
68386: PUSH
68387: LD_INT 32
68389: PUSH
68390: LD_INT 33
68392: PUSH
68393: LD_INT 34
68395: PUSH
68396: LD_INT 36
68398: PUSH
68399: EMPTY
68400: LIST
68401: LIST
68402: LIST
68403: LIST
68404: LIST
68405: LIST
68406: LIST
68407: LIST
68408: LIST
68409: LIST
68410: LIST
68411: LIST
68412: LIST
68413: LIST
68414: LIST
68415: LIST
68416: LIST
68417: LIST
68418: LIST
68419: LIST
68420: LIST
68421: LIST
68422: LIST
68423: LIST
68424: LIST
68425: LIST
68426: LIST
68427: LIST
68428: LIST
68429: LIST
68430: LIST
68431: LIST
68432: LIST
68433: LIST
68434: PUSH
68435: LD_INT 101
68437: PUSH
68438: LD_INT 102
68440: PUSH
68441: LD_INT 103
68443: PUSH
68444: LD_INT 104
68446: PUSH
68447: LD_INT 105
68449: PUSH
68450: LD_INT 106
68452: PUSH
68453: LD_INT 107
68455: PUSH
68456: LD_INT 108
68458: PUSH
68459: LD_INT 109
68461: PUSH
68462: LD_INT 110
68464: PUSH
68465: LD_INT 111
68467: PUSH
68468: LD_INT 112
68470: PUSH
68471: LD_INT 113
68473: PUSH
68474: LD_INT 114
68476: PUSH
68477: LD_INT 116
68479: PUSH
68480: LD_INT 117
68482: PUSH
68483: LD_INT 118
68485: PUSH
68486: EMPTY
68487: LIST
68488: LIST
68489: LIST
68490: LIST
68491: LIST
68492: LIST
68493: LIST
68494: LIST
68495: LIST
68496: LIST
68497: LIST
68498: LIST
68499: LIST
68500: LIST
68501: LIST
68502: LIST
68503: LIST
68504: PUSH
68505: EMPTY
68506: LIST
68507: LIST
68508: ST_TO_ADDR
68509: GO 69964
68511: LD_INT 13
68513: DOUBLE
68514: EQUAL
68515: IFTRUE 68519
68517: GO 68727
68519: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 14 :
68520: LD_ADDR_VAR 0 2
68524: PUSH
68525: LD_INT 1
68527: PUSH
68528: LD_INT 2
68530: PUSH
68531: LD_INT 3
68533: PUSH
68534: LD_INT 4
68536: PUSH
68537: LD_INT 5
68539: PUSH
68540: LD_INT 8
68542: PUSH
68543: LD_INT 9
68545: PUSH
68546: LD_INT 10
68548: PUSH
68549: LD_INT 11
68551: PUSH
68552: LD_INT 12
68554: PUSH
68555: LD_INT 14
68557: PUSH
68558: LD_INT 15
68560: PUSH
68561: LD_INT 16
68563: PUSH
68564: LD_INT 17
68566: PUSH
68567: LD_INT 18
68569: PUSH
68570: LD_INT 19
68572: PUSH
68573: LD_INT 20
68575: PUSH
68576: LD_INT 21
68578: PUSH
68579: LD_INT 22
68581: PUSH
68582: LD_INT 23
68584: PUSH
68585: LD_INT 24
68587: PUSH
68588: LD_INT 25
68590: PUSH
68591: LD_INT 26
68593: PUSH
68594: LD_INT 27
68596: PUSH
68597: LD_INT 28
68599: PUSH
68600: LD_INT 30
68602: PUSH
68603: LD_INT 31
68605: PUSH
68606: LD_INT 32
68608: PUSH
68609: LD_INT 33
68611: PUSH
68612: LD_INT 34
68614: PUSH
68615: LD_INT 36
68617: PUSH
68618: EMPTY
68619: LIST
68620: LIST
68621: LIST
68622: LIST
68623: LIST
68624: LIST
68625: LIST
68626: LIST
68627: LIST
68628: LIST
68629: LIST
68630: LIST
68631: LIST
68632: LIST
68633: LIST
68634: LIST
68635: LIST
68636: LIST
68637: LIST
68638: LIST
68639: LIST
68640: LIST
68641: LIST
68642: LIST
68643: LIST
68644: LIST
68645: LIST
68646: LIST
68647: LIST
68648: LIST
68649: LIST
68650: PUSH
68651: LD_INT 101
68653: PUSH
68654: LD_INT 102
68656: PUSH
68657: LD_INT 103
68659: PUSH
68660: LD_INT 104
68662: PUSH
68663: LD_INT 105
68665: PUSH
68666: LD_INT 106
68668: PUSH
68669: LD_INT 107
68671: PUSH
68672: LD_INT 108
68674: PUSH
68675: LD_INT 109
68677: PUSH
68678: LD_INT 110
68680: PUSH
68681: LD_INT 111
68683: PUSH
68684: LD_INT 112
68686: PUSH
68687: LD_INT 113
68689: PUSH
68690: LD_INT 114
68692: PUSH
68693: LD_INT 116
68695: PUSH
68696: LD_INT 117
68698: PUSH
68699: LD_INT 118
68701: PUSH
68702: EMPTY
68703: LIST
68704: LIST
68705: LIST
68706: LIST
68707: LIST
68708: LIST
68709: LIST
68710: LIST
68711: LIST
68712: LIST
68713: LIST
68714: LIST
68715: LIST
68716: LIST
68717: LIST
68718: LIST
68719: LIST
68720: PUSH
68721: EMPTY
68722: LIST
68723: LIST
68724: ST_TO_ADDR
68725: GO 69964
68727: LD_INT 14
68729: DOUBLE
68730: EQUAL
68731: IFTRUE 68735
68733: GO 68959
68735: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 15 :
68736: LD_ADDR_VAR 0 2
68740: PUSH
68741: LD_INT 1
68743: PUSH
68744: LD_INT 2
68746: PUSH
68747: LD_INT 3
68749: PUSH
68750: LD_INT 4
68752: PUSH
68753: LD_INT 5
68755: PUSH
68756: LD_INT 6
68758: PUSH
68759: LD_INT 7
68761: PUSH
68762: LD_INT 8
68764: PUSH
68765: LD_INT 9
68767: PUSH
68768: LD_INT 10
68770: PUSH
68771: LD_INT 11
68773: PUSH
68774: LD_INT 12
68776: PUSH
68777: LD_INT 13
68779: PUSH
68780: LD_INT 14
68782: PUSH
68783: LD_INT 15
68785: PUSH
68786: LD_INT 16
68788: PUSH
68789: LD_INT 17
68791: PUSH
68792: LD_INT 18
68794: PUSH
68795: LD_INT 19
68797: PUSH
68798: LD_INT 20
68800: PUSH
68801: LD_INT 21
68803: PUSH
68804: LD_INT 22
68806: PUSH
68807: LD_INT 23
68809: PUSH
68810: LD_INT 24
68812: PUSH
68813: LD_INT 25
68815: PUSH
68816: LD_INT 26
68818: PUSH
68819: LD_INT 27
68821: PUSH
68822: LD_INT 28
68824: PUSH
68825: LD_INT 29
68827: PUSH
68828: LD_INT 30
68830: PUSH
68831: LD_INT 31
68833: PUSH
68834: LD_INT 32
68836: PUSH
68837: LD_INT 33
68839: PUSH
68840: LD_INT 34
68842: PUSH
68843: LD_INT 36
68845: PUSH
68846: EMPTY
68847: LIST
68848: LIST
68849: LIST
68850: LIST
68851: LIST
68852: LIST
68853: LIST
68854: LIST
68855: LIST
68856: LIST
68857: LIST
68858: LIST
68859: LIST
68860: LIST
68861: LIST
68862: LIST
68863: LIST
68864: LIST
68865: LIST
68866: LIST
68867: LIST
68868: LIST
68869: LIST
68870: LIST
68871: LIST
68872: LIST
68873: LIST
68874: LIST
68875: LIST
68876: LIST
68877: LIST
68878: LIST
68879: LIST
68880: LIST
68881: LIST
68882: PUSH
68883: LD_INT 101
68885: PUSH
68886: LD_INT 102
68888: PUSH
68889: LD_INT 103
68891: PUSH
68892: LD_INT 104
68894: PUSH
68895: LD_INT 105
68897: PUSH
68898: LD_INT 106
68900: PUSH
68901: LD_INT 107
68903: PUSH
68904: LD_INT 108
68906: PUSH
68907: LD_INT 109
68909: PUSH
68910: LD_INT 110
68912: PUSH
68913: LD_INT 111
68915: PUSH
68916: LD_INT 112
68918: PUSH
68919: LD_INT 113
68921: PUSH
68922: LD_INT 114
68924: PUSH
68925: LD_INT 116
68927: PUSH
68928: LD_INT 117
68930: PUSH
68931: LD_INT 118
68933: PUSH
68934: EMPTY
68935: LIST
68936: LIST
68937: LIST
68938: LIST
68939: LIST
68940: LIST
68941: LIST
68942: LIST
68943: LIST
68944: LIST
68945: LIST
68946: LIST
68947: LIST
68948: LIST
68949: LIST
68950: LIST
68951: LIST
68952: PUSH
68953: EMPTY
68954: LIST
68955: LIST
68956: ST_TO_ADDR
68957: GO 69964
68959: LD_INT 15
68961: DOUBLE
68962: EQUAL
68963: IFTRUE 68967
68965: GO 69191
68967: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 16 :
68968: LD_ADDR_VAR 0 2
68972: PUSH
68973: LD_INT 1
68975: PUSH
68976: LD_INT 2
68978: PUSH
68979: LD_INT 3
68981: PUSH
68982: LD_INT 4
68984: PUSH
68985: LD_INT 5
68987: PUSH
68988: LD_INT 6
68990: PUSH
68991: LD_INT 7
68993: PUSH
68994: LD_INT 8
68996: PUSH
68997: LD_INT 9
68999: PUSH
69000: LD_INT 10
69002: PUSH
69003: LD_INT 11
69005: PUSH
69006: LD_INT 12
69008: PUSH
69009: LD_INT 13
69011: PUSH
69012: LD_INT 14
69014: PUSH
69015: LD_INT 15
69017: PUSH
69018: LD_INT 16
69020: PUSH
69021: LD_INT 17
69023: PUSH
69024: LD_INT 18
69026: PUSH
69027: LD_INT 19
69029: PUSH
69030: LD_INT 20
69032: PUSH
69033: LD_INT 21
69035: PUSH
69036: LD_INT 22
69038: PUSH
69039: LD_INT 23
69041: PUSH
69042: LD_INT 24
69044: PUSH
69045: LD_INT 25
69047: PUSH
69048: LD_INT 26
69050: PUSH
69051: LD_INT 27
69053: PUSH
69054: LD_INT 28
69056: PUSH
69057: LD_INT 29
69059: PUSH
69060: LD_INT 30
69062: PUSH
69063: LD_INT 31
69065: PUSH
69066: LD_INT 32
69068: PUSH
69069: LD_INT 33
69071: PUSH
69072: LD_INT 34
69074: PUSH
69075: LD_INT 36
69077: PUSH
69078: EMPTY
69079: LIST
69080: LIST
69081: LIST
69082: LIST
69083: LIST
69084: LIST
69085: LIST
69086: LIST
69087: LIST
69088: LIST
69089: LIST
69090: LIST
69091: LIST
69092: LIST
69093: LIST
69094: LIST
69095: LIST
69096: LIST
69097: LIST
69098: LIST
69099: LIST
69100: LIST
69101: LIST
69102: LIST
69103: LIST
69104: LIST
69105: LIST
69106: LIST
69107: LIST
69108: LIST
69109: LIST
69110: LIST
69111: LIST
69112: LIST
69113: LIST
69114: PUSH
69115: LD_INT 101
69117: PUSH
69118: LD_INT 102
69120: PUSH
69121: LD_INT 103
69123: PUSH
69124: LD_INT 104
69126: PUSH
69127: LD_INT 105
69129: PUSH
69130: LD_INT 106
69132: PUSH
69133: LD_INT 107
69135: PUSH
69136: LD_INT 108
69138: PUSH
69139: LD_INT 109
69141: PUSH
69142: LD_INT 110
69144: PUSH
69145: LD_INT 111
69147: PUSH
69148: LD_INT 112
69150: PUSH
69151: LD_INT 113
69153: PUSH
69154: LD_INT 114
69156: PUSH
69157: LD_INT 116
69159: PUSH
69160: LD_INT 117
69162: PUSH
69163: LD_INT 118
69165: PUSH
69166: EMPTY
69167: LIST
69168: LIST
69169: LIST
69170: LIST
69171: LIST
69172: LIST
69173: LIST
69174: LIST
69175: LIST
69176: LIST
69177: LIST
69178: LIST
69179: LIST
69180: LIST
69181: LIST
69182: LIST
69183: LIST
69184: PUSH
69185: EMPTY
69186: LIST
69187: LIST
69188: ST_TO_ADDR
69189: GO 69964
69191: LD_INT 16
69193: DOUBLE
69194: EQUAL
69195: IFTRUE 69199
69197: GO 69335
69199: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 17 :
69200: LD_ADDR_VAR 0 2
69204: PUSH
69205: LD_INT 2
69207: PUSH
69208: LD_INT 4
69210: PUSH
69211: LD_INT 5
69213: PUSH
69214: LD_INT 7
69216: PUSH
69217: LD_INT 11
69219: PUSH
69220: LD_INT 12
69222: PUSH
69223: LD_INT 15
69225: PUSH
69226: LD_INT 16
69228: PUSH
69229: LD_INT 20
69231: PUSH
69232: LD_INT 21
69234: PUSH
69235: LD_INT 22
69237: PUSH
69238: LD_INT 23
69240: PUSH
69241: LD_INT 25
69243: PUSH
69244: LD_INT 26
69246: PUSH
69247: LD_INT 30
69249: PUSH
69250: LD_INT 31
69252: PUSH
69253: LD_INT 32
69255: PUSH
69256: LD_INT 33
69258: PUSH
69259: LD_INT 34
69261: PUSH
69262: EMPTY
69263: LIST
69264: LIST
69265: LIST
69266: LIST
69267: LIST
69268: LIST
69269: LIST
69270: LIST
69271: LIST
69272: LIST
69273: LIST
69274: LIST
69275: LIST
69276: LIST
69277: LIST
69278: LIST
69279: LIST
69280: LIST
69281: LIST
69282: PUSH
69283: LD_INT 101
69285: PUSH
69286: LD_INT 102
69288: PUSH
69289: LD_INT 103
69291: PUSH
69292: LD_INT 106
69294: PUSH
69295: LD_INT 108
69297: PUSH
69298: LD_INT 112
69300: PUSH
69301: LD_INT 113
69303: PUSH
69304: LD_INT 114
69306: PUSH
69307: LD_INT 116
69309: PUSH
69310: LD_INT 117
69312: PUSH
69313: LD_INT 118
69315: PUSH
69316: EMPTY
69317: LIST
69318: LIST
69319: LIST
69320: LIST
69321: LIST
69322: LIST
69323: LIST
69324: LIST
69325: LIST
69326: LIST
69327: LIST
69328: PUSH
69329: EMPTY
69330: LIST
69331: LIST
69332: ST_TO_ADDR
69333: GO 69964
69335: LD_INT 17
69337: DOUBLE
69338: EQUAL
69339: IFTRUE 69343
69341: GO 69567
69343: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 18 :
69344: LD_ADDR_VAR 0 2
69348: PUSH
69349: LD_INT 1
69351: PUSH
69352: LD_INT 2
69354: PUSH
69355: LD_INT 3
69357: PUSH
69358: LD_INT 4
69360: PUSH
69361: LD_INT 5
69363: PUSH
69364: LD_INT 6
69366: PUSH
69367: LD_INT 7
69369: PUSH
69370: LD_INT 8
69372: PUSH
69373: LD_INT 9
69375: PUSH
69376: LD_INT 10
69378: PUSH
69379: LD_INT 11
69381: PUSH
69382: LD_INT 12
69384: PUSH
69385: LD_INT 13
69387: PUSH
69388: LD_INT 14
69390: PUSH
69391: LD_INT 15
69393: PUSH
69394: LD_INT 16
69396: PUSH
69397: LD_INT 17
69399: PUSH
69400: LD_INT 18
69402: PUSH
69403: LD_INT 19
69405: PUSH
69406: LD_INT 20
69408: PUSH
69409: LD_INT 21
69411: PUSH
69412: LD_INT 22
69414: PUSH
69415: LD_INT 23
69417: PUSH
69418: LD_INT 24
69420: PUSH
69421: LD_INT 25
69423: PUSH
69424: LD_INT 26
69426: PUSH
69427: LD_INT 27
69429: PUSH
69430: LD_INT 28
69432: PUSH
69433: LD_INT 29
69435: PUSH
69436: LD_INT 30
69438: PUSH
69439: LD_INT 31
69441: PUSH
69442: LD_INT 32
69444: PUSH
69445: LD_INT 33
69447: PUSH
69448: LD_INT 34
69450: PUSH
69451: LD_INT 36
69453: PUSH
69454: EMPTY
69455: LIST
69456: LIST
69457: LIST
69458: LIST
69459: LIST
69460: LIST
69461: LIST
69462: LIST
69463: LIST
69464: LIST
69465: LIST
69466: LIST
69467: LIST
69468: LIST
69469: LIST
69470: LIST
69471: LIST
69472: LIST
69473: LIST
69474: LIST
69475: LIST
69476: LIST
69477: LIST
69478: LIST
69479: LIST
69480: LIST
69481: LIST
69482: LIST
69483: LIST
69484: LIST
69485: LIST
69486: LIST
69487: LIST
69488: LIST
69489: LIST
69490: PUSH
69491: LD_INT 101
69493: PUSH
69494: LD_INT 102
69496: PUSH
69497: LD_INT 103
69499: PUSH
69500: LD_INT 104
69502: PUSH
69503: LD_INT 105
69505: PUSH
69506: LD_INT 106
69508: PUSH
69509: LD_INT 107
69511: PUSH
69512: LD_INT 108
69514: PUSH
69515: LD_INT 109
69517: PUSH
69518: LD_INT 110
69520: PUSH
69521: LD_INT 111
69523: PUSH
69524: LD_INT 112
69526: PUSH
69527: LD_INT 113
69529: PUSH
69530: LD_INT 114
69532: PUSH
69533: LD_INT 116
69535: PUSH
69536: LD_INT 117
69538: PUSH
69539: LD_INT 118
69541: PUSH
69542: EMPTY
69543: LIST
69544: LIST
69545: LIST
69546: LIST
69547: LIST
69548: LIST
69549: LIST
69550: LIST
69551: LIST
69552: LIST
69553: LIST
69554: LIST
69555: LIST
69556: LIST
69557: LIST
69558: LIST
69559: LIST
69560: PUSH
69561: EMPTY
69562: LIST
69563: LIST
69564: ST_TO_ADDR
69565: GO 69964
69567: LD_INT 18
69569: DOUBLE
69570: EQUAL
69571: IFTRUE 69575
69573: GO 69723
69575: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; 19 :
69576: LD_ADDR_VAR 0 2
69580: PUSH
69581: LD_INT 2
69583: PUSH
69584: LD_INT 4
69586: PUSH
69587: LD_INT 5
69589: PUSH
69590: LD_INT 7
69592: PUSH
69593: LD_INT 11
69595: PUSH
69596: LD_INT 12
69598: PUSH
69599: LD_INT 15
69601: PUSH
69602: LD_INT 16
69604: PUSH
69605: LD_INT 20
69607: PUSH
69608: LD_INT 21
69610: PUSH
69611: LD_INT 22
69613: PUSH
69614: LD_INT 23
69616: PUSH
69617: LD_INT 25
69619: PUSH
69620: LD_INT 26
69622: PUSH
69623: LD_INT 30
69625: PUSH
69626: LD_INT 31
69628: PUSH
69629: LD_INT 32
69631: PUSH
69632: LD_INT 33
69634: PUSH
69635: LD_INT 34
69637: PUSH
69638: LD_INT 35
69640: PUSH
69641: LD_INT 36
69643: PUSH
69644: EMPTY
69645: LIST
69646: LIST
69647: LIST
69648: LIST
69649: LIST
69650: LIST
69651: LIST
69652: LIST
69653: LIST
69654: LIST
69655: LIST
69656: LIST
69657: LIST
69658: LIST
69659: LIST
69660: LIST
69661: LIST
69662: LIST
69663: LIST
69664: LIST
69665: LIST
69666: PUSH
69667: LD_INT 101
69669: PUSH
69670: LD_INT 102
69672: PUSH
69673: LD_INT 103
69675: PUSH
69676: LD_INT 106
69678: PUSH
69679: LD_INT 108
69681: PUSH
69682: LD_INT 112
69684: PUSH
69685: LD_INT 113
69687: PUSH
69688: LD_INT 114
69690: PUSH
69691: LD_INT 115
69693: PUSH
69694: LD_INT 116
69696: PUSH
69697: LD_INT 117
69699: PUSH
69700: LD_INT 118
69702: PUSH
69703: EMPTY
69704: LIST
69705: LIST
69706: LIST
69707: LIST
69708: LIST
69709: LIST
69710: LIST
69711: LIST
69712: LIST
69713: LIST
69714: LIST
69715: LIST
69716: PUSH
69717: EMPTY
69718: LIST
69719: LIST
69720: ST_TO_ADDR
69721: GO 69964
69723: LD_INT 19
69725: DOUBLE
69726: EQUAL
69727: IFTRUE 69731
69729: GO 69963
69731: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; end ;
69732: LD_ADDR_VAR 0 2
69736: PUSH
69737: LD_INT 1
69739: PUSH
69740: LD_INT 2
69742: PUSH
69743: LD_INT 3
69745: PUSH
69746: LD_INT 4
69748: PUSH
69749: LD_INT 5
69751: PUSH
69752: LD_INT 6
69754: PUSH
69755: LD_INT 7
69757: PUSH
69758: LD_INT 8
69760: PUSH
69761: LD_INT 9
69763: PUSH
69764: LD_INT 10
69766: PUSH
69767: LD_INT 11
69769: PUSH
69770: LD_INT 12
69772: PUSH
69773: LD_INT 13
69775: PUSH
69776: LD_INT 14
69778: PUSH
69779: LD_INT 15
69781: PUSH
69782: LD_INT 16
69784: PUSH
69785: LD_INT 17
69787: PUSH
69788: LD_INT 18
69790: PUSH
69791: LD_INT 19
69793: PUSH
69794: LD_INT 20
69796: PUSH
69797: LD_INT 21
69799: PUSH
69800: LD_INT 22
69802: PUSH
69803: LD_INT 23
69805: PUSH
69806: LD_INT 24
69808: PUSH
69809: LD_INT 25
69811: PUSH
69812: LD_INT 26
69814: PUSH
69815: LD_INT 27
69817: PUSH
69818: LD_INT 28
69820: PUSH
69821: LD_INT 29
69823: PUSH
69824: LD_INT 30
69826: PUSH
69827: LD_INT 31
69829: PUSH
69830: LD_INT 32
69832: PUSH
69833: LD_INT 33
69835: PUSH
69836: LD_INT 34
69838: PUSH
69839: LD_INT 35
69841: PUSH
69842: LD_INT 36
69844: PUSH
69845: EMPTY
69846: LIST
69847: LIST
69848: LIST
69849: LIST
69850: LIST
69851: LIST
69852: LIST
69853: LIST
69854: LIST
69855: LIST
69856: LIST
69857: LIST
69858: LIST
69859: LIST
69860: LIST
69861: LIST
69862: LIST
69863: LIST
69864: LIST
69865: LIST
69866: LIST
69867: LIST
69868: LIST
69869: LIST
69870: LIST
69871: LIST
69872: LIST
69873: LIST
69874: LIST
69875: LIST
69876: LIST
69877: LIST
69878: LIST
69879: LIST
69880: LIST
69881: LIST
69882: PUSH
69883: LD_INT 101
69885: PUSH
69886: LD_INT 102
69888: PUSH
69889: LD_INT 103
69891: PUSH
69892: LD_INT 104
69894: PUSH
69895: LD_INT 105
69897: PUSH
69898: LD_INT 106
69900: PUSH
69901: LD_INT 107
69903: PUSH
69904: LD_INT 108
69906: PUSH
69907: LD_INT 109
69909: PUSH
69910: LD_INT 110
69912: PUSH
69913: LD_INT 111
69915: PUSH
69916: LD_INT 112
69918: PUSH
69919: LD_INT 113
69921: PUSH
69922: LD_INT 114
69924: PUSH
69925: LD_INT 115
69927: PUSH
69928: LD_INT 116
69930: PUSH
69931: LD_INT 117
69933: PUSH
69934: LD_INT 118
69936: PUSH
69937: EMPTY
69938: LIST
69939: LIST
69940: LIST
69941: LIST
69942: LIST
69943: LIST
69944: LIST
69945: LIST
69946: LIST
69947: LIST
69948: LIST
69949: LIST
69950: LIST
69951: LIST
69952: LIST
69953: LIST
69954: LIST
69955: LIST
69956: PUSH
69957: EMPTY
69958: LIST
69959: LIST
69960: ST_TO_ADDR
69961: GO 69964
69963: POP
// end else
69964: GO 70195
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ;
69966: LD_ADDR_VAR 0 2
69970: PUSH
69971: LD_INT 1
69973: PUSH
69974: LD_INT 2
69976: PUSH
69977: LD_INT 3
69979: PUSH
69980: LD_INT 4
69982: PUSH
69983: LD_INT 5
69985: PUSH
69986: LD_INT 6
69988: PUSH
69989: LD_INT 7
69991: PUSH
69992: LD_INT 8
69994: PUSH
69995: LD_INT 9
69997: PUSH
69998: LD_INT 10
70000: PUSH
70001: LD_INT 11
70003: PUSH
70004: LD_INT 12
70006: PUSH
70007: LD_INT 13
70009: PUSH
70010: LD_INT 14
70012: PUSH
70013: LD_INT 15
70015: PUSH
70016: LD_INT 16
70018: PUSH
70019: LD_INT 17
70021: PUSH
70022: LD_INT 18
70024: PUSH
70025: LD_INT 19
70027: PUSH
70028: LD_INT 20
70030: PUSH
70031: LD_INT 21
70033: PUSH
70034: LD_INT 22
70036: PUSH
70037: LD_INT 23
70039: PUSH
70040: LD_INT 24
70042: PUSH
70043: LD_INT 25
70045: PUSH
70046: LD_INT 26
70048: PUSH
70049: LD_INT 27
70051: PUSH
70052: LD_INT 28
70054: PUSH
70055: LD_INT 29
70057: PUSH
70058: LD_INT 30
70060: PUSH
70061: LD_INT 31
70063: PUSH
70064: LD_INT 32
70066: PUSH
70067: LD_INT 33
70069: PUSH
70070: LD_INT 34
70072: PUSH
70073: LD_INT 35
70075: PUSH
70076: LD_INT 36
70078: PUSH
70079: EMPTY
70080: LIST
70081: LIST
70082: LIST
70083: LIST
70084: LIST
70085: LIST
70086: LIST
70087: LIST
70088: LIST
70089: LIST
70090: LIST
70091: LIST
70092: LIST
70093: LIST
70094: LIST
70095: LIST
70096: LIST
70097: LIST
70098: LIST
70099: LIST
70100: LIST
70101: LIST
70102: LIST
70103: LIST
70104: LIST
70105: LIST
70106: LIST
70107: LIST
70108: LIST
70109: LIST
70110: LIST
70111: LIST
70112: LIST
70113: LIST
70114: LIST
70115: LIST
70116: PUSH
70117: LD_INT 101
70119: PUSH
70120: LD_INT 102
70122: PUSH
70123: LD_INT 103
70125: PUSH
70126: LD_INT 104
70128: PUSH
70129: LD_INT 105
70131: PUSH
70132: LD_INT 106
70134: PUSH
70135: LD_INT 107
70137: PUSH
70138: LD_INT 108
70140: PUSH
70141: LD_INT 109
70143: PUSH
70144: LD_INT 110
70146: PUSH
70147: LD_INT 111
70149: PUSH
70150: LD_INT 112
70152: PUSH
70153: LD_INT 113
70155: PUSH
70156: LD_INT 114
70158: PUSH
70159: LD_INT 115
70161: PUSH
70162: LD_INT 116
70164: PUSH
70165: LD_INT 117
70167: PUSH
70168: LD_INT 118
70170: PUSH
70171: EMPTY
70172: LIST
70173: LIST
70174: LIST
70175: LIST
70176: LIST
70177: LIST
70178: LIST
70179: LIST
70180: LIST
70181: LIST
70182: LIST
70183: LIST
70184: LIST
70185: LIST
70186: LIST
70187: LIST
70188: LIST
70189: LIST
70190: PUSH
70191: EMPTY
70192: LIST
70193: LIST
70194: ST_TO_ADDR
// if result then
70195: LD_VAR 0 2
70199: IFFALSE 70985
// begin normal :=  ;
70201: LD_ADDR_VAR 0 5
70205: PUSH
70206: LD_STRING 
70208: ST_TO_ADDR
// hardcore :=  ;
70209: LD_ADDR_VAR 0 6
70213: PUSH
70214: LD_STRING 
70216: ST_TO_ADDR
// active :=  ;
70217: LD_ADDR_VAR 0 7
70221: PUSH
70222: LD_STRING 
70224: ST_TO_ADDR
// for i = 1 to normalCounter do
70225: LD_ADDR_VAR 0 8
70229: PUSH
70230: DOUBLE
70231: LD_INT 1
70233: DEC
70234: ST_TO_ADDR
70235: LD_EXP 99
70239: PUSH
70240: FOR_TO
70241: IFFALSE 70342
// begin tmp := 0 ;
70243: LD_ADDR_VAR 0 3
70247: PUSH
70248: LD_STRING 0
70250: ST_TO_ADDR
// if result [ 1 ] then
70251: LD_VAR 0 2
70255: PUSH
70256: LD_INT 1
70258: ARRAY
70259: IFFALSE 70324
// if result [ 1 ] [ 1 ] = i then
70261: LD_VAR 0 2
70265: PUSH
70266: LD_INT 1
70268: ARRAY
70269: PUSH
70270: LD_INT 1
70272: ARRAY
70273: PUSH
70274: LD_VAR 0 8
70278: EQUAL
70279: IFFALSE 70324
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
70281: LD_ADDR_VAR 0 2
70285: PUSH
70286: LD_VAR 0 2
70290: PPUSH
70291: LD_INT 1
70293: PPUSH
70294: LD_VAR 0 2
70298: PUSH
70299: LD_INT 1
70301: ARRAY
70302: PPUSH
70303: LD_INT 1
70305: PPUSH
70306: CALL_OW 3
70310: PPUSH
70311: CALL_OW 1
70315: ST_TO_ADDR
// tmp := 1 ;
70316: LD_ADDR_VAR 0 3
70320: PUSH
70321: LD_STRING 1
70323: ST_TO_ADDR
// end ; normal := normal & tmp ;
70324: LD_ADDR_VAR 0 5
70328: PUSH
70329: LD_VAR 0 5
70333: PUSH
70334: LD_VAR 0 3
70338: STR
70339: ST_TO_ADDR
// end ;
70340: GO 70240
70342: POP
70343: POP
// for i = 1 to hardcoreCounter do
70344: LD_ADDR_VAR 0 8
70348: PUSH
70349: DOUBLE
70350: LD_INT 1
70352: DEC
70353: ST_TO_ADDR
70354: LD_EXP 100
70358: PUSH
70359: FOR_TO
70360: IFFALSE 70465
// begin tmp := 0 ;
70362: LD_ADDR_VAR 0 3
70366: PUSH
70367: LD_STRING 0
70369: ST_TO_ADDR
// if result [ 2 ] then
70370: LD_VAR 0 2
70374: PUSH
70375: LD_INT 2
70377: ARRAY
70378: IFFALSE 70447
// if result [ 2 ] [ 1 ] = 100 + i then
70380: LD_VAR 0 2
70384: PUSH
70385: LD_INT 2
70387: ARRAY
70388: PUSH
70389: LD_INT 1
70391: ARRAY
70392: PUSH
70393: LD_INT 100
70395: PUSH
70396: LD_VAR 0 8
70400: PLUS
70401: EQUAL
70402: IFFALSE 70447
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
70404: LD_ADDR_VAR 0 2
70408: PUSH
70409: LD_VAR 0 2
70413: PPUSH
70414: LD_INT 2
70416: PPUSH
70417: LD_VAR 0 2
70421: PUSH
70422: LD_INT 2
70424: ARRAY
70425: PPUSH
70426: LD_INT 1
70428: PPUSH
70429: CALL_OW 3
70433: PPUSH
70434: CALL_OW 1
70438: ST_TO_ADDR
// tmp := 1 ;
70439: LD_ADDR_VAR 0 3
70443: PUSH
70444: LD_STRING 1
70446: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
70447: LD_ADDR_VAR 0 6
70451: PUSH
70452: LD_VAR 0 6
70456: PUSH
70457: LD_VAR 0 3
70461: STR
70462: ST_TO_ADDR
// end ;
70463: GO 70359
70465: POP
70466: POP
// if isGameLoad then
70467: LD_VAR 0 1
70471: IFFALSE 70946
// begin flags := [ sRocket , sSpeed , sEngine , sSpec , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sKamikadze , sTroll , sSlow , sLack , sTank , sRemote , sPowell , sTeleport , sOilTower , sShovel , sSheik , sEarthquake , sAI , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sSold , sDiff , sFog , sReset , sSun , sTiger , sBomb , sWound , sBetray , sContamin , sOil , sStu , sBazooka , sMortar , sRanger , sComputer , s30 , s60 ] ;
70473: LD_ADDR_VAR 0 4
70477: PUSH
70478: LD_EXP 103
70482: PUSH
70483: LD_EXP 102
70487: PUSH
70488: LD_EXP 104
70492: PUSH
70493: LD_EXP 101
70497: PUSH
70498: LD_EXP 105
70502: PUSH
70503: LD_EXP 106
70507: PUSH
70508: LD_EXP 107
70512: PUSH
70513: LD_EXP 108
70517: PUSH
70518: LD_EXP 109
70522: PUSH
70523: LD_EXP 110
70527: PUSH
70528: LD_EXP 111
70532: PUSH
70533: LD_EXP 112
70537: PUSH
70538: LD_EXP 113
70542: PUSH
70543: LD_EXP 114
70547: PUSH
70548: LD_EXP 122
70552: PUSH
70553: LD_EXP 123
70557: PUSH
70558: LD_EXP 124
70562: PUSH
70563: LD_EXP 125
70567: PUSH
70568: LD_EXP 127
70572: PUSH
70573: LD_EXP 128
70577: PUSH
70578: LD_EXP 129
70582: PUSH
70583: LD_EXP 132
70587: PUSH
70588: LD_EXP 134
70592: PUSH
70593: LD_EXP 135
70597: PUSH
70598: LD_EXP 136
70602: PUSH
70603: LD_EXP 138
70607: PUSH
70608: LD_EXP 139
70612: PUSH
70613: LD_EXP 142
70617: PUSH
70618: LD_EXP 143
70622: PUSH
70623: LD_EXP 144
70627: PUSH
70628: LD_EXP 145
70632: PUSH
70633: LD_EXP 146
70637: PUSH
70638: LD_EXP 147
70642: PUSH
70643: LD_EXP 148
70647: PUSH
70648: LD_EXP 149
70652: PUSH
70653: LD_EXP 150
70657: PUSH
70658: LD_EXP 115
70662: PUSH
70663: LD_EXP 116
70667: PUSH
70668: LD_EXP 119
70672: PUSH
70673: LD_EXP 120
70677: PUSH
70678: LD_EXP 121
70682: PUSH
70683: LD_EXP 117
70687: PUSH
70688: LD_EXP 118
70692: PUSH
70693: LD_EXP 126
70697: PUSH
70698: LD_EXP 130
70702: PUSH
70703: LD_EXP 131
70707: PUSH
70708: LD_EXP 133
70712: PUSH
70713: LD_EXP 137
70717: PUSH
70718: LD_EXP 140
70722: PUSH
70723: LD_EXP 141
70727: PUSH
70728: LD_EXP 151
70732: PUSH
70733: LD_EXP 152
70737: PUSH
70738: LD_EXP 153
70742: PUSH
70743: LD_EXP 154
70747: PUSH
70748: EMPTY
70749: LIST
70750: LIST
70751: LIST
70752: LIST
70753: LIST
70754: LIST
70755: LIST
70756: LIST
70757: LIST
70758: LIST
70759: LIST
70760: LIST
70761: LIST
70762: LIST
70763: LIST
70764: LIST
70765: LIST
70766: LIST
70767: LIST
70768: LIST
70769: LIST
70770: LIST
70771: LIST
70772: LIST
70773: LIST
70774: LIST
70775: LIST
70776: LIST
70777: LIST
70778: LIST
70779: LIST
70780: LIST
70781: LIST
70782: LIST
70783: LIST
70784: LIST
70785: LIST
70786: LIST
70787: LIST
70788: LIST
70789: LIST
70790: LIST
70791: LIST
70792: LIST
70793: LIST
70794: LIST
70795: LIST
70796: LIST
70797: LIST
70798: LIST
70799: LIST
70800: LIST
70801: LIST
70802: LIST
70803: ST_TO_ADDR
// tmp :=  ;
70804: LD_ADDR_VAR 0 3
70808: PUSH
70809: LD_STRING 
70811: ST_TO_ADDR
// for i = 1 to normalCounter do
70812: LD_ADDR_VAR 0 8
70816: PUSH
70817: DOUBLE
70818: LD_INT 1
70820: DEC
70821: ST_TO_ADDR
70822: LD_EXP 99
70826: PUSH
70827: FOR_TO
70828: IFFALSE 70864
// begin if flags [ i ] then
70830: LD_VAR 0 4
70834: PUSH
70835: LD_VAR 0 8
70839: ARRAY
70840: IFFALSE 70862
// tmp := tmp & i & ; ;
70842: LD_ADDR_VAR 0 3
70846: PUSH
70847: LD_VAR 0 3
70851: PUSH
70852: LD_VAR 0 8
70856: STR
70857: PUSH
70858: LD_STRING ;
70860: STR
70861: ST_TO_ADDR
// end ;
70862: GO 70827
70864: POP
70865: POP
// for i = 1 to hardcoreCounter do
70866: LD_ADDR_VAR 0 8
70870: PUSH
70871: DOUBLE
70872: LD_INT 1
70874: DEC
70875: ST_TO_ADDR
70876: LD_EXP 100
70880: PUSH
70881: FOR_TO
70882: IFFALSE 70928
// begin if flags [ normalCounter + i ] then
70884: LD_VAR 0 4
70888: PUSH
70889: LD_EXP 99
70893: PUSH
70894: LD_VAR 0 8
70898: PLUS
70899: ARRAY
70900: IFFALSE 70926
// tmp := tmp & ( 100 + i ) & ; ;
70902: LD_ADDR_VAR 0 3
70906: PUSH
70907: LD_VAR 0 3
70911: PUSH
70912: LD_INT 100
70914: PUSH
70915: LD_VAR 0 8
70919: PLUS
70920: STR
70921: PUSH
70922: LD_STRING ;
70924: STR
70925: ST_TO_ADDR
// end ;
70926: GO 70881
70928: POP
70929: POP
// if tmp then
70930: LD_VAR 0 3
70934: IFFALSE 70946
// active := tmp ;
70936: LD_ADDR_VAR 0 7
70940: PUSH
70941: LD_VAR 0 3
70945: ST_TO_ADDR
// end ; ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & "," & active & ") ) ;
70946: LD_STRING getStreamItemsFromMission("
70948: PUSH
70949: LD_VAR 0 5
70953: STR
70954: PUSH
70955: LD_STRING ","
70957: STR
70958: PUSH
70959: LD_VAR 0 6
70963: STR
70964: PUSH
70965: LD_STRING ","
70967: STR
70968: PUSH
70969: LD_VAR 0 7
70973: STR
70974: PUSH
70975: LD_STRING ")
70977: STR
70978: PPUSH
70979: CALL_OW 559
// end else
70983: GO 70992
// ToLua ( getStreamItemsFromMission("","","") ) ;
70985: LD_STRING getStreamItemsFromMission("","","")
70987: PPUSH
70988: CALL_OW 559
// end ;
70992: LD_VAR 0 2
70996: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
70997: LD_EXP 98
71001: PUSH
71002: LD_EXP 103
71006: AND
71007: IFFALSE 71131
71009: GO 71011
71011: DISABLE
71012: LD_INT 0
71014: PPUSH
71015: PPUSH
// begin enable ;
71016: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
71017: LD_ADDR_VAR 0 2
71021: PUSH
71022: LD_INT 22
71024: PUSH
71025: LD_OWVAR 2
71029: PUSH
71030: EMPTY
71031: LIST
71032: LIST
71033: PUSH
71034: LD_INT 2
71036: PUSH
71037: LD_INT 34
71039: PUSH
71040: LD_INT 7
71042: PUSH
71043: EMPTY
71044: LIST
71045: LIST
71046: PUSH
71047: LD_INT 34
71049: PUSH
71050: LD_INT 45
71052: PUSH
71053: EMPTY
71054: LIST
71055: LIST
71056: PUSH
71057: LD_INT 34
71059: PUSH
71060: LD_INT 28
71062: PUSH
71063: EMPTY
71064: LIST
71065: LIST
71066: PUSH
71067: LD_INT 34
71069: PUSH
71070: LD_INT 47
71072: PUSH
71073: EMPTY
71074: LIST
71075: LIST
71076: PUSH
71077: EMPTY
71078: LIST
71079: LIST
71080: LIST
71081: LIST
71082: LIST
71083: PUSH
71084: EMPTY
71085: LIST
71086: LIST
71087: PPUSH
71088: CALL_OW 69
71092: ST_TO_ADDR
// if not tmp then
71093: LD_VAR 0 2
71097: NOT
71098: IFFALSE 71102
// exit ;
71100: GO 71131
// for i in tmp do
71102: LD_ADDR_VAR 0 1
71106: PUSH
71107: LD_VAR 0 2
71111: PUSH
71112: FOR_IN
71113: IFFALSE 71129
// begin SetLives ( i , 0 ) ;
71115: LD_VAR 0 1
71119: PPUSH
71120: LD_INT 0
71122: PPUSH
71123: CALL_OW 234
// end ;
71127: GO 71112
71129: POP
71130: POP
// end ;
71131: PPOPN 2
71133: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
71134: LD_EXP 98
71138: PUSH
71139: LD_EXP 104
71143: AND
71144: IFFALSE 71228
71146: GO 71148
71148: DISABLE
71149: LD_INT 0
71151: PPUSH
71152: PPUSH
// begin enable ;
71153: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
71154: LD_ADDR_VAR 0 2
71158: PUSH
71159: LD_INT 22
71161: PUSH
71162: LD_OWVAR 2
71166: PUSH
71167: EMPTY
71168: LIST
71169: LIST
71170: PUSH
71171: LD_INT 32
71173: PUSH
71174: LD_INT 3
71176: PUSH
71177: EMPTY
71178: LIST
71179: LIST
71180: PUSH
71181: EMPTY
71182: LIST
71183: LIST
71184: PPUSH
71185: CALL_OW 69
71189: ST_TO_ADDR
// if not tmp then
71190: LD_VAR 0 2
71194: NOT
71195: IFFALSE 71199
// exit ;
71197: GO 71228
// for i in tmp do
71199: LD_ADDR_VAR 0 1
71203: PUSH
71204: LD_VAR 0 2
71208: PUSH
71209: FOR_IN
71210: IFFALSE 71226
// begin SetLives ( i , 0 ) ;
71212: LD_VAR 0 1
71216: PPUSH
71217: LD_INT 0
71219: PPUSH
71220: CALL_OW 234
// end ;
71224: GO 71209
71226: POP
71227: POP
// end ;
71228: PPOPN 2
71230: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
71231: LD_EXP 98
71235: PUSH
71236: LD_EXP 101
71240: AND
71241: IFFALSE 71334
71243: GO 71245
71245: DISABLE
71246: LD_INT 0
71248: PPUSH
// begin enable ;
71249: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
71250: LD_ADDR_VAR 0 1
71254: PUSH
71255: LD_INT 22
71257: PUSH
71258: LD_OWVAR 2
71262: PUSH
71263: EMPTY
71264: LIST
71265: LIST
71266: PUSH
71267: LD_INT 2
71269: PUSH
71270: LD_INT 25
71272: PUSH
71273: LD_INT 5
71275: PUSH
71276: EMPTY
71277: LIST
71278: LIST
71279: PUSH
71280: LD_INT 25
71282: PUSH
71283: LD_INT 9
71285: PUSH
71286: EMPTY
71287: LIST
71288: LIST
71289: PUSH
71290: LD_INT 25
71292: PUSH
71293: LD_INT 8
71295: PUSH
71296: EMPTY
71297: LIST
71298: LIST
71299: PUSH
71300: EMPTY
71301: LIST
71302: LIST
71303: LIST
71304: LIST
71305: PUSH
71306: EMPTY
71307: LIST
71308: LIST
71309: PPUSH
71310: CALL_OW 69
71314: PUSH
71315: FOR_IN
71316: IFFALSE 71332
// begin SetClass ( i , 1 ) ;
71318: LD_VAR 0 1
71322: PPUSH
71323: LD_INT 1
71325: PPUSH
71326: CALL_OW 336
// end ;
71330: GO 71315
71332: POP
71333: POP
// end ;
71334: PPOPN 1
71336: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
71337: LD_EXP 98
71341: PUSH
71342: LD_EXP 102
71346: AND
71347: PUSH
71348: LD_OWVAR 65
71352: PUSH
71353: LD_INT 7
71355: LESS
71356: AND
71357: IFFALSE 71371
71359: GO 71361
71361: DISABLE
// begin enable ;
71362: ENABLE
// game_speed := 7 ;
71363: LD_ADDR_OWVAR 65
71367: PUSH
71368: LD_INT 7
71370: ST_TO_ADDR
// end ;
71371: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
71372: LD_EXP 98
71376: PUSH
71377: LD_EXP 105
71381: AND
71382: IFFALSE 71584
71384: GO 71386
71386: DISABLE
71387: LD_INT 0
71389: PPUSH
71390: PPUSH
71391: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
71392: LD_ADDR_VAR 0 3
71396: PUSH
71397: LD_INT 81
71399: PUSH
71400: LD_OWVAR 2
71404: PUSH
71405: EMPTY
71406: LIST
71407: LIST
71408: PUSH
71409: LD_INT 21
71411: PUSH
71412: LD_INT 1
71414: PUSH
71415: EMPTY
71416: LIST
71417: LIST
71418: PUSH
71419: EMPTY
71420: LIST
71421: LIST
71422: PPUSH
71423: CALL_OW 69
71427: ST_TO_ADDR
// if not tmp then
71428: LD_VAR 0 3
71432: NOT
71433: IFFALSE 71437
// exit ;
71435: GO 71584
// if tmp > 5 then
71437: LD_VAR 0 3
71441: PUSH
71442: LD_INT 5
71444: GREATER
71445: IFFALSE 71457
// k := 5 else
71447: LD_ADDR_VAR 0 2
71451: PUSH
71452: LD_INT 5
71454: ST_TO_ADDR
71455: GO 71467
// k := tmp ;
71457: LD_ADDR_VAR 0 2
71461: PUSH
71462: LD_VAR 0 3
71466: ST_TO_ADDR
// for i := 1 to k do
71467: LD_ADDR_VAR 0 1
71471: PUSH
71472: DOUBLE
71473: LD_INT 1
71475: DEC
71476: ST_TO_ADDR
71477: LD_VAR 0 2
71481: PUSH
71482: FOR_TO
71483: IFFALSE 71582
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
71485: LD_VAR 0 3
71489: PUSH
71490: LD_VAR 0 1
71494: ARRAY
71495: PPUSH
71496: LD_VAR 0 1
71500: PUSH
71501: LD_INT 4
71503: MOD
71504: PUSH
71505: LD_INT 1
71507: PLUS
71508: PPUSH
71509: CALL_OW 259
71513: PUSH
71514: LD_INT 10
71516: LESS
71517: IFFALSE 71580
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
71519: LD_VAR 0 3
71523: PUSH
71524: LD_VAR 0 1
71528: ARRAY
71529: PPUSH
71530: LD_VAR 0 1
71534: PUSH
71535: LD_INT 4
71537: MOD
71538: PUSH
71539: LD_INT 1
71541: PLUS
71542: PPUSH
71543: LD_VAR 0 3
71547: PUSH
71548: LD_VAR 0 1
71552: ARRAY
71553: PPUSH
71554: LD_VAR 0 1
71558: PUSH
71559: LD_INT 4
71561: MOD
71562: PUSH
71563: LD_INT 1
71565: PLUS
71566: PPUSH
71567: CALL_OW 259
71571: PUSH
71572: LD_INT 1
71574: PLUS
71575: PPUSH
71576: CALL_OW 237
71580: GO 71482
71582: POP
71583: POP
// end ;
71584: PPOPN 3
71586: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
71587: LD_EXP 98
71591: PUSH
71592: LD_EXP 106
71596: AND
71597: IFFALSE 71617
71599: GO 71601
71601: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
71602: LD_INT 4
71604: PPUSH
71605: LD_OWVAR 2
71609: PPUSH
71610: LD_INT 0
71612: PPUSH
71613: CALL_OW 324
71617: END
// every 0 0$1 trigger StreamModeActive and sShovel do
71618: LD_EXP 98
71622: PUSH
71623: LD_EXP 135
71627: AND
71628: IFFALSE 71648
71630: GO 71632
71632: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
71633: LD_INT 19
71635: PPUSH
71636: LD_OWVAR 2
71640: PPUSH
71641: LD_INT 0
71643: PPUSH
71644: CALL_OW 324
71648: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
71649: LD_EXP 98
71653: PUSH
71654: LD_EXP 107
71658: AND
71659: IFFALSE 71761
71661: GO 71663
71663: DISABLE
71664: LD_INT 0
71666: PPUSH
71667: PPUSH
// begin enable ;
71668: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
71669: LD_ADDR_VAR 0 2
71673: PUSH
71674: LD_INT 22
71676: PUSH
71677: LD_OWVAR 2
71681: PUSH
71682: EMPTY
71683: LIST
71684: LIST
71685: PUSH
71686: LD_INT 2
71688: PUSH
71689: LD_INT 34
71691: PUSH
71692: LD_INT 11
71694: PUSH
71695: EMPTY
71696: LIST
71697: LIST
71698: PUSH
71699: LD_INT 34
71701: PUSH
71702: LD_INT 30
71704: PUSH
71705: EMPTY
71706: LIST
71707: LIST
71708: PUSH
71709: EMPTY
71710: LIST
71711: LIST
71712: LIST
71713: PUSH
71714: EMPTY
71715: LIST
71716: LIST
71717: PPUSH
71718: CALL_OW 69
71722: ST_TO_ADDR
// if not tmp then
71723: LD_VAR 0 2
71727: NOT
71728: IFFALSE 71732
// exit ;
71730: GO 71761
// for i in tmp do
71732: LD_ADDR_VAR 0 1
71736: PUSH
71737: LD_VAR 0 2
71741: PUSH
71742: FOR_IN
71743: IFFALSE 71759
// begin SetLives ( i , 0 ) ;
71745: LD_VAR 0 1
71749: PPUSH
71750: LD_INT 0
71752: PPUSH
71753: CALL_OW 234
// end ;
71757: GO 71742
71759: POP
71760: POP
// end ;
71761: PPOPN 2
71763: END
// every 0 0$1 trigger StreamModeActive and sBunker do
71764: LD_EXP 98
71768: PUSH
71769: LD_EXP 108
71773: AND
71774: IFFALSE 71794
71776: GO 71778
71778: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
71779: LD_INT 32
71781: PPUSH
71782: LD_OWVAR 2
71786: PPUSH
71787: LD_INT 0
71789: PPUSH
71790: CALL_OW 324
71794: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
71795: LD_EXP 98
71799: PUSH
71800: LD_EXP 109
71804: AND
71805: IFFALSE 71986
71807: GO 71809
71809: DISABLE
71810: LD_INT 0
71812: PPUSH
71813: PPUSH
71814: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
71815: LD_ADDR_VAR 0 2
71819: PUSH
71820: LD_INT 22
71822: PUSH
71823: LD_OWVAR 2
71827: PUSH
71828: EMPTY
71829: LIST
71830: LIST
71831: PUSH
71832: LD_INT 33
71834: PUSH
71835: LD_INT 3
71837: PUSH
71838: EMPTY
71839: LIST
71840: LIST
71841: PUSH
71842: EMPTY
71843: LIST
71844: LIST
71845: PPUSH
71846: CALL_OW 69
71850: ST_TO_ADDR
// if not tmp then
71851: LD_VAR 0 2
71855: NOT
71856: IFFALSE 71860
// exit ;
71858: GO 71986
// side := 0 ;
71860: LD_ADDR_VAR 0 3
71864: PUSH
71865: LD_INT 0
71867: ST_TO_ADDR
// for i := 1 to 8 do
71868: LD_ADDR_VAR 0 1
71872: PUSH
71873: DOUBLE
71874: LD_INT 1
71876: DEC
71877: ST_TO_ADDR
71878: LD_INT 8
71880: PUSH
71881: FOR_TO
71882: IFFALSE 71930
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
71884: LD_OWVAR 2
71888: PUSH
71889: LD_VAR 0 1
71893: NONEQUAL
71894: PUSH
71895: LD_OWVAR 2
71899: PPUSH
71900: LD_VAR 0 1
71904: PPUSH
71905: CALL_OW 81
71909: PUSH
71910: LD_INT 2
71912: EQUAL
71913: AND
71914: IFFALSE 71928
// begin side := i ;
71916: LD_ADDR_VAR 0 3
71920: PUSH
71921: LD_VAR 0 1
71925: ST_TO_ADDR
// break ;
71926: GO 71930
// end ;
71928: GO 71881
71930: POP
71931: POP
// if not side then
71932: LD_VAR 0 3
71936: NOT
71937: IFFALSE 71941
// exit ;
71939: GO 71986
// for i := 1 to tmp do
71941: LD_ADDR_VAR 0 1
71945: PUSH
71946: DOUBLE
71947: LD_INT 1
71949: DEC
71950: ST_TO_ADDR
71951: LD_VAR 0 2
71955: PUSH
71956: FOR_TO
71957: IFFALSE 71984
// if Prob ( 60 ) then
71959: LD_INT 60
71961: PPUSH
71962: CALL_OW 13
71966: IFFALSE 71982
// SetSide ( i , side ) ;
71968: LD_VAR 0 1
71972: PPUSH
71973: LD_VAR 0 3
71977: PPUSH
71978: CALL_OW 235
71982: GO 71956
71984: POP
71985: POP
// end ;
71986: PPOPN 3
71988: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
71989: LD_EXP 98
71993: PUSH
71994: LD_EXP 111
71998: AND
71999: IFFALSE 72118
72001: GO 72003
72003: DISABLE
72004: LD_INT 0
72006: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
72007: LD_ADDR_VAR 0 1
72011: PUSH
72012: LD_INT 22
72014: PUSH
72015: LD_OWVAR 2
72019: PUSH
72020: EMPTY
72021: LIST
72022: LIST
72023: PUSH
72024: LD_INT 21
72026: PUSH
72027: LD_INT 1
72029: PUSH
72030: EMPTY
72031: LIST
72032: LIST
72033: PUSH
72034: LD_INT 3
72036: PUSH
72037: LD_INT 23
72039: PUSH
72040: LD_INT 0
72042: PUSH
72043: EMPTY
72044: LIST
72045: LIST
72046: PUSH
72047: EMPTY
72048: LIST
72049: LIST
72050: PUSH
72051: EMPTY
72052: LIST
72053: LIST
72054: LIST
72055: PPUSH
72056: CALL_OW 69
72060: PUSH
72061: FOR_IN
72062: IFFALSE 72116
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
72064: LD_VAR 0 1
72068: PPUSH
72069: CALL_OW 257
72073: PUSH
72074: LD_INT 1
72076: PUSH
72077: LD_INT 2
72079: PUSH
72080: LD_INT 3
72082: PUSH
72083: LD_INT 4
72085: PUSH
72086: EMPTY
72087: LIST
72088: LIST
72089: LIST
72090: LIST
72091: IN
72092: IFFALSE 72114
// SetClass ( un , rand ( 1 , 4 ) ) ;
72094: LD_VAR 0 1
72098: PPUSH
72099: LD_INT 1
72101: PPUSH
72102: LD_INT 4
72104: PPUSH
72105: CALL_OW 12
72109: PPUSH
72110: CALL_OW 336
72114: GO 72061
72116: POP
72117: POP
// end ;
72118: PPOPN 1
72120: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
72121: LD_EXP 98
72125: PUSH
72126: LD_EXP 110
72130: AND
72131: IFFALSE 72210
72133: GO 72135
72135: DISABLE
72136: LD_INT 0
72138: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
72139: LD_ADDR_VAR 0 1
72143: PUSH
72144: LD_INT 22
72146: PUSH
72147: LD_OWVAR 2
72151: PUSH
72152: EMPTY
72153: LIST
72154: LIST
72155: PUSH
72156: LD_INT 21
72158: PUSH
72159: LD_INT 3
72161: PUSH
72162: EMPTY
72163: LIST
72164: LIST
72165: PUSH
72166: EMPTY
72167: LIST
72168: LIST
72169: PPUSH
72170: CALL_OW 69
72174: ST_TO_ADDR
// if not tmp then
72175: LD_VAR 0 1
72179: NOT
72180: IFFALSE 72184
// exit ;
72182: GO 72210
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
72184: LD_VAR 0 1
72188: PUSH
72189: LD_INT 1
72191: PPUSH
72192: LD_VAR 0 1
72196: PPUSH
72197: CALL_OW 12
72201: ARRAY
72202: PPUSH
72203: LD_INT 100
72205: PPUSH
72206: CALL_OW 234
// end ;
72210: PPOPN 1
72212: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
72213: LD_EXP 98
72217: PUSH
72218: LD_EXP 112
72222: AND
72223: IFFALSE 72321
72225: GO 72227
72227: DISABLE
72228: LD_INT 0
72230: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
72231: LD_ADDR_VAR 0 1
72235: PUSH
72236: LD_INT 22
72238: PUSH
72239: LD_OWVAR 2
72243: PUSH
72244: EMPTY
72245: LIST
72246: LIST
72247: PUSH
72248: LD_INT 21
72250: PUSH
72251: LD_INT 1
72253: PUSH
72254: EMPTY
72255: LIST
72256: LIST
72257: PUSH
72258: EMPTY
72259: LIST
72260: LIST
72261: PPUSH
72262: CALL_OW 69
72266: ST_TO_ADDR
// if not tmp then
72267: LD_VAR 0 1
72271: NOT
72272: IFFALSE 72276
// exit ;
72274: GO 72321
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
72276: LD_VAR 0 1
72280: PUSH
72281: LD_INT 1
72283: PPUSH
72284: LD_VAR 0 1
72288: PPUSH
72289: CALL_OW 12
72293: ARRAY
72294: PPUSH
72295: LD_INT 1
72297: PPUSH
72298: LD_INT 4
72300: PPUSH
72301: CALL_OW 12
72305: PPUSH
72306: LD_INT 3000
72308: PPUSH
72309: LD_INT 9000
72311: PPUSH
72312: CALL_OW 12
72316: PPUSH
72317: CALL_OW 492
// end ;
72321: PPOPN 1
72323: END
// every 0 0$1 trigger StreamModeActive and sDepot do
72324: LD_EXP 98
72328: PUSH
72329: LD_EXP 113
72333: AND
72334: IFFALSE 72354
72336: GO 72338
72338: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
72339: LD_INT 1
72341: PPUSH
72342: LD_OWVAR 2
72346: PPUSH
72347: LD_INT 0
72349: PPUSH
72350: CALL_OW 324
72354: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
72355: LD_EXP 98
72359: PUSH
72360: LD_EXP 114
72364: AND
72365: IFFALSE 72448
72367: GO 72369
72369: DISABLE
72370: LD_INT 0
72372: PPUSH
72373: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
72374: LD_ADDR_VAR 0 2
72378: PUSH
72379: LD_INT 22
72381: PUSH
72382: LD_OWVAR 2
72386: PUSH
72387: EMPTY
72388: LIST
72389: LIST
72390: PUSH
72391: LD_INT 21
72393: PUSH
72394: LD_INT 3
72396: PUSH
72397: EMPTY
72398: LIST
72399: LIST
72400: PUSH
72401: EMPTY
72402: LIST
72403: LIST
72404: PPUSH
72405: CALL_OW 69
72409: ST_TO_ADDR
// if not tmp then
72410: LD_VAR 0 2
72414: NOT
72415: IFFALSE 72419
// exit ;
72417: GO 72448
// for i in tmp do
72419: LD_ADDR_VAR 0 1
72423: PUSH
72424: LD_VAR 0 2
72428: PUSH
72429: FOR_IN
72430: IFFALSE 72446
// SetBLevel ( i , 10 ) ;
72432: LD_VAR 0 1
72436: PPUSH
72437: LD_INT 10
72439: PPUSH
72440: CALL_OW 241
72444: GO 72429
72446: POP
72447: POP
// end ;
72448: PPOPN 2
72450: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
72451: LD_EXP 98
72455: PUSH
72456: LD_EXP 115
72460: AND
72461: IFFALSE 72572
72463: GO 72465
72465: DISABLE
72466: LD_INT 0
72468: PPUSH
72469: PPUSH
72470: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
72471: LD_ADDR_VAR 0 3
72475: PUSH
72476: LD_INT 22
72478: PUSH
72479: LD_OWVAR 2
72483: PUSH
72484: EMPTY
72485: LIST
72486: LIST
72487: PUSH
72488: LD_INT 25
72490: PUSH
72491: LD_INT 1
72493: PUSH
72494: EMPTY
72495: LIST
72496: LIST
72497: PUSH
72498: EMPTY
72499: LIST
72500: LIST
72501: PPUSH
72502: CALL_OW 69
72506: ST_TO_ADDR
// if not tmp then
72507: LD_VAR 0 3
72511: NOT
72512: IFFALSE 72516
// exit ;
72514: GO 72572
// un := tmp [ rand ( 1 , tmp ) ] ;
72516: LD_ADDR_VAR 0 2
72520: PUSH
72521: LD_VAR 0 3
72525: PUSH
72526: LD_INT 1
72528: PPUSH
72529: LD_VAR 0 3
72533: PPUSH
72534: CALL_OW 12
72538: ARRAY
72539: ST_TO_ADDR
// if Crawls ( un ) then
72540: LD_VAR 0 2
72544: PPUSH
72545: CALL_OW 318
72549: IFFALSE 72560
// ComWalk ( un ) ;
72551: LD_VAR 0 2
72555: PPUSH
72556: CALL_OW 138
// SetClass ( un , class_sniper ) ;
72560: LD_VAR 0 2
72564: PPUSH
72565: LD_INT 5
72567: PPUSH
72568: CALL_OW 336
// end ;
72572: PPOPN 3
72574: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 4 do
72575: LD_EXP 98
72579: PUSH
72580: LD_EXP 116
72584: AND
72585: PUSH
72586: LD_OWVAR 67
72590: PUSH
72591: LD_INT 4
72593: LESS
72594: AND
72595: IFFALSE 72614
72597: GO 72599
72599: DISABLE
// begin Difficulty := Difficulty + 1 ;
72600: LD_ADDR_OWVAR 67
72604: PUSH
72605: LD_OWVAR 67
72609: PUSH
72610: LD_INT 1
72612: PLUS
72613: ST_TO_ADDR
// end ;
72614: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
72615: LD_EXP 98
72619: PUSH
72620: LD_EXP 117
72624: AND
72625: IFFALSE 72728
72627: GO 72629
72629: DISABLE
72630: LD_INT 0
72632: PPUSH
// begin for i := 1 to 5 do
72633: LD_ADDR_VAR 0 1
72637: PUSH
72638: DOUBLE
72639: LD_INT 1
72641: DEC
72642: ST_TO_ADDR
72643: LD_INT 5
72645: PUSH
72646: FOR_TO
72647: IFFALSE 72726
// begin uc_nation := nation_nature ;
72649: LD_ADDR_OWVAR 21
72653: PUSH
72654: LD_INT 0
72656: ST_TO_ADDR
// uc_side := 0 ;
72657: LD_ADDR_OWVAR 20
72661: PUSH
72662: LD_INT 0
72664: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
72665: LD_ADDR_OWVAR 29
72669: PUSH
72670: LD_INT 12
72672: PUSH
72673: LD_INT 12
72675: PUSH
72676: EMPTY
72677: LIST
72678: LIST
72679: ST_TO_ADDR
// hc_agressivity := 20 ;
72680: LD_ADDR_OWVAR 35
72684: PUSH
72685: LD_INT 20
72687: ST_TO_ADDR
// hc_class := class_tiger ;
72688: LD_ADDR_OWVAR 28
72692: PUSH
72693: LD_INT 14
72695: ST_TO_ADDR
// hc_gallery :=  ;
72696: LD_ADDR_OWVAR 33
72700: PUSH
72701: LD_STRING 
72703: ST_TO_ADDR
// hc_name :=  ;
72704: LD_ADDR_OWVAR 26
72708: PUSH
72709: LD_STRING 
72711: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
72712: CALL_OW 44
72716: PPUSH
72717: LD_INT 0
72719: PPUSH
72720: CALL_OW 51
// end ;
72724: GO 72646
72726: POP
72727: POP
// end ;
72728: PPOPN 1
72730: END
// every 0 0$1 trigger StreamModeActive and sBomb do
72731: LD_EXP 98
72735: PUSH
72736: LD_EXP 118
72740: AND
72741: IFFALSE 72750
72743: GO 72745
72745: DISABLE
// StreamSibBomb ;
72746: CALL 72751 0 0
72750: END
// export function StreamSibBomb ; var i , x , y ; begin
72751: LD_INT 0
72753: PPUSH
72754: PPUSH
72755: PPUSH
72756: PPUSH
// result := false ;
72757: LD_ADDR_VAR 0 1
72761: PUSH
72762: LD_INT 0
72764: ST_TO_ADDR
// for i := 1 to 16 do
72765: LD_ADDR_VAR 0 2
72769: PUSH
72770: DOUBLE
72771: LD_INT 1
72773: DEC
72774: ST_TO_ADDR
72775: LD_INT 16
72777: PUSH
72778: FOR_TO
72779: IFFALSE 72978
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
72781: LD_ADDR_VAR 0 3
72785: PUSH
72786: LD_INT 10
72788: PUSH
72789: LD_INT 20
72791: PUSH
72792: LD_INT 30
72794: PUSH
72795: LD_INT 40
72797: PUSH
72798: LD_INT 50
72800: PUSH
72801: LD_INT 60
72803: PUSH
72804: LD_INT 70
72806: PUSH
72807: LD_INT 80
72809: PUSH
72810: LD_INT 90
72812: PUSH
72813: LD_INT 100
72815: PUSH
72816: LD_INT 110
72818: PUSH
72819: LD_INT 120
72821: PUSH
72822: LD_INT 130
72824: PUSH
72825: LD_INT 140
72827: PUSH
72828: LD_INT 150
72830: PUSH
72831: EMPTY
72832: LIST
72833: LIST
72834: LIST
72835: LIST
72836: LIST
72837: LIST
72838: LIST
72839: LIST
72840: LIST
72841: LIST
72842: LIST
72843: LIST
72844: LIST
72845: LIST
72846: LIST
72847: PUSH
72848: LD_INT 1
72850: PPUSH
72851: LD_INT 15
72853: PPUSH
72854: CALL_OW 12
72858: ARRAY
72859: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
72860: LD_ADDR_VAR 0 4
72864: PUSH
72865: LD_INT 10
72867: PUSH
72868: LD_INT 20
72870: PUSH
72871: LD_INT 30
72873: PUSH
72874: LD_INT 40
72876: PUSH
72877: LD_INT 50
72879: PUSH
72880: LD_INT 60
72882: PUSH
72883: LD_INT 70
72885: PUSH
72886: LD_INT 80
72888: PUSH
72889: LD_INT 90
72891: PUSH
72892: LD_INT 100
72894: PUSH
72895: LD_INT 110
72897: PUSH
72898: LD_INT 120
72900: PUSH
72901: LD_INT 130
72903: PUSH
72904: LD_INT 140
72906: PUSH
72907: LD_INT 150
72909: PUSH
72910: EMPTY
72911: LIST
72912: LIST
72913: LIST
72914: LIST
72915: LIST
72916: LIST
72917: LIST
72918: LIST
72919: LIST
72920: LIST
72921: LIST
72922: LIST
72923: LIST
72924: LIST
72925: LIST
72926: PUSH
72927: LD_INT 1
72929: PPUSH
72930: LD_INT 15
72932: PPUSH
72933: CALL_OW 12
72937: ARRAY
72938: ST_TO_ADDR
// if ValidHex ( x , y ) then
72939: LD_VAR 0 3
72943: PPUSH
72944: LD_VAR 0 4
72948: PPUSH
72949: CALL_OW 488
72953: IFFALSE 72976
// begin result := [ x , y ] ;
72955: LD_ADDR_VAR 0 1
72959: PUSH
72960: LD_VAR 0 3
72964: PUSH
72965: LD_VAR 0 4
72969: PUSH
72970: EMPTY
72971: LIST
72972: LIST
72973: ST_TO_ADDR
// break ;
72974: GO 72978
// end ; end ;
72976: GO 72778
72978: POP
72979: POP
// if result then
72980: LD_VAR 0 1
72984: IFFALSE 73044
// begin ToLua ( playSibBomb() ) ;
72986: LD_STRING playSibBomb()
72988: PPUSH
72989: CALL_OW 559
// wait ( 0 0$14 ) ;
72993: LD_INT 490
72995: PPUSH
72996: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
73000: LD_VAR 0 1
73004: PUSH
73005: LD_INT 1
73007: ARRAY
73008: PPUSH
73009: LD_VAR 0 1
73013: PUSH
73014: LD_INT 2
73016: ARRAY
73017: PPUSH
73018: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
73022: LD_VAR 0 1
73026: PUSH
73027: LD_INT 1
73029: ARRAY
73030: PPUSH
73031: LD_VAR 0 1
73035: PUSH
73036: LD_INT 2
73038: ARRAY
73039: PPUSH
73040: CALL_OW 429
// end ; end ;
73044: LD_VAR 0 1
73048: RET
// every 0 0$1 trigger StreamModeActive and sReset do
73049: LD_EXP 98
73053: PUSH
73054: LD_EXP 120
73058: AND
73059: IFFALSE 73071
73061: GO 73063
73063: DISABLE
// YouLost (  ) ;
73064: LD_STRING 
73066: PPUSH
73067: CALL_OW 104
73071: END
// every 0 0$1 trigger StreamModeActive and sFog do
73072: LD_EXP 98
73076: PUSH
73077: LD_EXP 119
73081: AND
73082: IFFALSE 73096
73084: GO 73086
73086: DISABLE
// FogOff ( your_side ) ;
73087: LD_OWVAR 2
73091: PPUSH
73092: CALL_OW 344
73096: END
// every 0 0$1 trigger StreamModeActive and sSun do
73097: LD_EXP 98
73101: PUSH
73102: LD_EXP 121
73106: AND
73107: IFFALSE 73135
73109: GO 73111
73111: DISABLE
// begin solar_recharge_percent := 0 ;
73112: LD_ADDR_OWVAR 79
73116: PUSH
73117: LD_INT 0
73119: ST_TO_ADDR
// wait ( 5 5$00 ) ;
73120: LD_INT 10500
73122: PPUSH
73123: CALL_OW 67
// solar_recharge_percent := 100 ;
73127: LD_ADDR_OWVAR 79
73131: PUSH
73132: LD_INT 100
73134: ST_TO_ADDR
// end ;
73135: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
73136: LD_EXP 98
73140: PUSH
73141: LD_EXP 122
73145: AND
73146: IFFALSE 73385
73148: GO 73150
73150: DISABLE
73151: LD_INT 0
73153: PPUSH
73154: PPUSH
73155: PPUSH
// begin tmp := [ ] ;
73156: LD_ADDR_VAR 0 3
73160: PUSH
73161: EMPTY
73162: ST_TO_ADDR
// for i := 1 to 6 do
73163: LD_ADDR_VAR 0 1
73167: PUSH
73168: DOUBLE
73169: LD_INT 1
73171: DEC
73172: ST_TO_ADDR
73173: LD_INT 6
73175: PUSH
73176: FOR_TO
73177: IFFALSE 73282
// begin uc_nation := nation_nature ;
73179: LD_ADDR_OWVAR 21
73183: PUSH
73184: LD_INT 0
73186: ST_TO_ADDR
// uc_side := 0 ;
73187: LD_ADDR_OWVAR 20
73191: PUSH
73192: LD_INT 0
73194: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
73195: LD_ADDR_OWVAR 29
73199: PUSH
73200: LD_INT 12
73202: PUSH
73203: LD_INT 12
73205: PUSH
73206: EMPTY
73207: LIST
73208: LIST
73209: ST_TO_ADDR
// hc_agressivity := 20 ;
73210: LD_ADDR_OWVAR 35
73214: PUSH
73215: LD_INT 20
73217: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
73218: LD_ADDR_OWVAR 28
73222: PUSH
73223: LD_INT 17
73225: ST_TO_ADDR
// hc_gallery :=  ;
73226: LD_ADDR_OWVAR 33
73230: PUSH
73231: LD_STRING 
73233: ST_TO_ADDR
// hc_name :=  ;
73234: LD_ADDR_OWVAR 26
73238: PUSH
73239: LD_STRING 
73241: ST_TO_ADDR
// un := CreateHuman ;
73242: LD_ADDR_VAR 0 2
73246: PUSH
73247: CALL_OW 44
73251: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
73252: LD_VAR 0 2
73256: PPUSH
73257: LD_INT 1
73259: PPUSH
73260: CALL_OW 51
// tmp := tmp ^ un ;
73264: LD_ADDR_VAR 0 3
73268: PUSH
73269: LD_VAR 0 3
73273: PUSH
73274: LD_VAR 0 2
73278: ADD
73279: ST_TO_ADDR
// end ;
73280: GO 73176
73282: POP
73283: POP
// repeat wait ( 0 0$1 ) ;
73284: LD_INT 35
73286: PPUSH
73287: CALL_OW 67
// for un in tmp do
73291: LD_ADDR_VAR 0 2
73295: PUSH
73296: LD_VAR 0 3
73300: PUSH
73301: FOR_IN
73302: IFFALSE 73376
// begin if IsDead ( un ) then
73304: LD_VAR 0 2
73308: PPUSH
73309: CALL_OW 301
73313: IFFALSE 73333
// begin tmp := tmp diff un ;
73315: LD_ADDR_VAR 0 3
73319: PUSH
73320: LD_VAR 0 3
73324: PUSH
73325: LD_VAR 0 2
73329: DIFF
73330: ST_TO_ADDR
// continue ;
73331: GO 73301
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
73333: LD_VAR 0 2
73337: PPUSH
73338: LD_INT 3
73340: PUSH
73341: LD_INT 22
73343: PUSH
73344: LD_INT 0
73346: PUSH
73347: EMPTY
73348: LIST
73349: LIST
73350: PUSH
73351: EMPTY
73352: LIST
73353: LIST
73354: PPUSH
73355: CALL_OW 69
73359: PPUSH
73360: LD_VAR 0 2
73364: PPUSH
73365: CALL_OW 74
73369: PPUSH
73370: CALL_OW 115
// end ;
73374: GO 73301
73376: POP
73377: POP
// until not tmp ;
73378: LD_VAR 0 3
73382: NOT
73383: IFFALSE 73284
// end ;
73385: PPOPN 3
73387: END
// every 0 0$1 trigger StreamModeActive and sTroll do
73388: LD_EXP 98
73392: PUSH
73393: LD_EXP 123
73397: AND
73398: IFFALSE 73452
73400: GO 73402
73402: DISABLE
// begin ToLua ( displayTroll(); ) ;
73403: LD_STRING displayTroll();
73405: PPUSH
73406: CALL_OW 559
// wait ( 3 3$00 ) ;
73410: LD_INT 6300
73412: PPUSH
73413: CALL_OW 67
// ToLua ( hideTroll(); ) ;
73417: LD_STRING hideTroll();
73419: PPUSH
73420: CALL_OW 559
// wait ( 1 1$00 ) ;
73424: LD_INT 2100
73426: PPUSH
73427: CALL_OW 67
// ToLua ( displayTroll(); ) ;
73431: LD_STRING displayTroll();
73433: PPUSH
73434: CALL_OW 559
// wait ( 1 1$00 ) ;
73438: LD_INT 2100
73440: PPUSH
73441: CALL_OW 67
// ToLua ( hideTroll(); ) ;
73445: LD_STRING hideTroll();
73447: PPUSH
73448: CALL_OW 559
// end ;
73452: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
73453: LD_EXP 98
73457: PUSH
73458: LD_EXP 124
73462: AND
73463: IFFALSE 73526
73465: GO 73467
73467: DISABLE
73468: LD_INT 0
73470: PPUSH
// begin p := 0 ;
73471: LD_ADDR_VAR 0 1
73475: PUSH
73476: LD_INT 0
73478: ST_TO_ADDR
// repeat game_speed := 1 ;
73479: LD_ADDR_OWVAR 65
73483: PUSH
73484: LD_INT 1
73486: ST_TO_ADDR
// wait ( 0 0$1 ) ;
73487: LD_INT 35
73489: PPUSH
73490: CALL_OW 67
// p := p + 1 ;
73494: LD_ADDR_VAR 0 1
73498: PUSH
73499: LD_VAR 0 1
73503: PUSH
73504: LD_INT 1
73506: PLUS
73507: ST_TO_ADDR
// until p >= 60 ;
73508: LD_VAR 0 1
73512: PUSH
73513: LD_INT 60
73515: GREATEREQUAL
73516: IFFALSE 73479
// game_speed := 4 ;
73518: LD_ADDR_OWVAR 65
73522: PUSH
73523: LD_INT 4
73525: ST_TO_ADDR
// end ;
73526: PPOPN 1
73528: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
73529: LD_EXP 98
73533: PUSH
73534: LD_EXP 125
73538: AND
73539: IFFALSE 73685
73541: GO 73543
73543: DISABLE
73544: LD_INT 0
73546: PPUSH
73547: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
73548: LD_ADDR_VAR 0 1
73552: PUSH
73553: LD_INT 22
73555: PUSH
73556: LD_OWVAR 2
73560: PUSH
73561: EMPTY
73562: LIST
73563: LIST
73564: PUSH
73565: LD_INT 2
73567: PUSH
73568: LD_INT 30
73570: PUSH
73571: LD_INT 0
73573: PUSH
73574: EMPTY
73575: LIST
73576: LIST
73577: PUSH
73578: LD_INT 30
73580: PUSH
73581: LD_INT 1
73583: PUSH
73584: EMPTY
73585: LIST
73586: LIST
73587: PUSH
73588: EMPTY
73589: LIST
73590: LIST
73591: LIST
73592: PUSH
73593: EMPTY
73594: LIST
73595: LIST
73596: PPUSH
73597: CALL_OW 69
73601: ST_TO_ADDR
// if not depot then
73602: LD_VAR 0 1
73606: NOT
73607: IFFALSE 73611
// exit ;
73609: GO 73685
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
73611: LD_ADDR_VAR 0 2
73615: PUSH
73616: LD_VAR 0 1
73620: PUSH
73621: LD_INT 1
73623: PPUSH
73624: LD_VAR 0 1
73628: PPUSH
73629: CALL_OW 12
73633: ARRAY
73634: PPUSH
73635: CALL_OW 274
73639: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
73640: LD_VAR 0 2
73644: PPUSH
73645: LD_INT 1
73647: PPUSH
73648: LD_INT 0
73650: PPUSH
73651: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
73655: LD_VAR 0 2
73659: PPUSH
73660: LD_INT 2
73662: PPUSH
73663: LD_INT 0
73665: PPUSH
73666: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
73670: LD_VAR 0 2
73674: PPUSH
73675: LD_INT 3
73677: PPUSH
73678: LD_INT 0
73680: PPUSH
73681: CALL_OW 277
// end ;
73685: PPOPN 2
73687: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
73688: LD_EXP 98
73692: PUSH
73693: LD_EXP 126
73697: AND
73698: IFFALSE 73795
73700: GO 73702
73702: DISABLE
73703: LD_INT 0
73705: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
73706: LD_ADDR_VAR 0 1
73710: PUSH
73711: LD_INT 22
73713: PUSH
73714: LD_OWVAR 2
73718: PUSH
73719: EMPTY
73720: LIST
73721: LIST
73722: PUSH
73723: LD_INT 21
73725: PUSH
73726: LD_INT 1
73728: PUSH
73729: EMPTY
73730: LIST
73731: LIST
73732: PUSH
73733: LD_INT 3
73735: PUSH
73736: LD_INT 23
73738: PUSH
73739: LD_INT 0
73741: PUSH
73742: EMPTY
73743: LIST
73744: LIST
73745: PUSH
73746: EMPTY
73747: LIST
73748: LIST
73749: PUSH
73750: EMPTY
73751: LIST
73752: LIST
73753: LIST
73754: PPUSH
73755: CALL_OW 69
73759: ST_TO_ADDR
// if not tmp then
73760: LD_VAR 0 1
73764: NOT
73765: IFFALSE 73769
// exit ;
73767: GO 73795
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
73769: LD_VAR 0 1
73773: PUSH
73774: LD_INT 1
73776: PPUSH
73777: LD_VAR 0 1
73781: PPUSH
73782: CALL_OW 12
73786: ARRAY
73787: PPUSH
73788: LD_INT 200
73790: PPUSH
73791: CALL_OW 234
// end ;
73795: PPOPN 1
73797: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
73798: LD_EXP 98
73802: PUSH
73803: LD_EXP 127
73807: AND
73808: IFFALSE 73887
73810: GO 73812
73812: DISABLE
73813: LD_INT 0
73815: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
73816: LD_ADDR_VAR 0 1
73820: PUSH
73821: LD_INT 22
73823: PUSH
73824: LD_OWVAR 2
73828: PUSH
73829: EMPTY
73830: LIST
73831: LIST
73832: PUSH
73833: LD_INT 21
73835: PUSH
73836: LD_INT 2
73838: PUSH
73839: EMPTY
73840: LIST
73841: LIST
73842: PUSH
73843: EMPTY
73844: LIST
73845: LIST
73846: PPUSH
73847: CALL_OW 69
73851: ST_TO_ADDR
// if not tmp then
73852: LD_VAR 0 1
73856: NOT
73857: IFFALSE 73861
// exit ;
73859: GO 73887
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
73861: LD_VAR 0 1
73865: PUSH
73866: LD_INT 1
73868: PPUSH
73869: LD_VAR 0 1
73873: PPUSH
73874: CALL_OW 12
73878: ARRAY
73879: PPUSH
73880: LD_INT 60
73882: PPUSH
73883: CALL_OW 234
// end ;
73887: PPOPN 1
73889: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
73890: LD_EXP 98
73894: PUSH
73895: LD_EXP 128
73899: AND
73900: IFFALSE 73999
73902: GO 73904
73904: DISABLE
73905: LD_INT 0
73907: PPUSH
73908: PPUSH
// begin enable ;
73909: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
73910: LD_ADDR_VAR 0 1
73914: PUSH
73915: LD_INT 22
73917: PUSH
73918: LD_OWVAR 2
73922: PUSH
73923: EMPTY
73924: LIST
73925: LIST
73926: PUSH
73927: LD_INT 61
73929: PUSH
73930: EMPTY
73931: LIST
73932: PUSH
73933: LD_INT 33
73935: PUSH
73936: LD_INT 2
73938: PUSH
73939: EMPTY
73940: LIST
73941: LIST
73942: PUSH
73943: EMPTY
73944: LIST
73945: LIST
73946: LIST
73947: PPUSH
73948: CALL_OW 69
73952: ST_TO_ADDR
// if not tmp then
73953: LD_VAR 0 1
73957: NOT
73958: IFFALSE 73962
// exit ;
73960: GO 73999
// for i in tmp do
73962: LD_ADDR_VAR 0 2
73966: PUSH
73967: LD_VAR 0 1
73971: PUSH
73972: FOR_IN
73973: IFFALSE 73997
// if IsControledBy ( i ) then
73975: LD_VAR 0 2
73979: PPUSH
73980: CALL_OW 312
73984: IFFALSE 73995
// ComUnlink ( i ) ;
73986: LD_VAR 0 2
73990: PPUSH
73991: CALL_OW 136
73995: GO 73972
73997: POP
73998: POP
// end ;
73999: PPOPN 2
74001: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
74002: LD_EXP 98
74006: PUSH
74007: LD_EXP 129
74011: AND
74012: IFFALSE 74152
74014: GO 74016
74016: DISABLE
74017: LD_INT 0
74019: PPUSH
74020: PPUSH
// begin ToLua ( displayPowell(); ) ;
74021: LD_STRING displayPowell();
74023: PPUSH
74024: CALL_OW 559
// uc_side := 0 ;
74028: LD_ADDR_OWVAR 20
74032: PUSH
74033: LD_INT 0
74035: ST_TO_ADDR
// uc_nation := 2 ;
74036: LD_ADDR_OWVAR 21
74040: PUSH
74041: LD_INT 2
74043: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
74044: LD_ADDR_OWVAR 37
74048: PUSH
74049: LD_INT 14
74051: ST_TO_ADDR
// vc_engine := engine_siberite ;
74052: LD_ADDR_OWVAR 39
74056: PUSH
74057: LD_INT 3
74059: ST_TO_ADDR
// vc_control := control_apeman ;
74060: LD_ADDR_OWVAR 38
74064: PUSH
74065: LD_INT 5
74067: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
74068: LD_ADDR_OWVAR 40
74072: PUSH
74073: LD_INT 29
74075: ST_TO_ADDR
// un := CreateVehicle ;
74076: LD_ADDR_VAR 0 2
74080: PUSH
74081: CALL_OW 45
74085: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
74086: LD_VAR 0 2
74090: PPUSH
74091: LD_INT 1
74093: PPUSH
74094: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
74098: LD_INT 35
74100: PPUSH
74101: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
74105: LD_VAR 0 2
74109: PPUSH
74110: LD_INT 22
74112: PUSH
74113: LD_OWVAR 2
74117: PUSH
74118: EMPTY
74119: LIST
74120: LIST
74121: PPUSH
74122: CALL_OW 69
74126: PPUSH
74127: LD_VAR 0 2
74131: PPUSH
74132: CALL_OW 74
74136: PPUSH
74137: CALL_OW 115
// until IsDead ( un ) ;
74141: LD_VAR 0 2
74145: PPUSH
74146: CALL_OW 301
74150: IFFALSE 74098
// end ;
74152: PPOPN 2
74154: END
// every 0 0$1 trigger StreamModeActive and sStu do
74155: LD_EXP 98
74159: PUSH
74160: LD_EXP 137
74164: AND
74165: IFFALSE 74181
74167: GO 74169
74169: DISABLE
// begin ToLua ( displayStucuk(); ) ;
74170: LD_STRING displayStucuk();
74172: PPUSH
74173: CALL_OW 559
// ResetFog ;
74177: CALL_OW 335
// end ;
74181: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
74182: LD_EXP 98
74186: PUSH
74187: LD_EXP 130
74191: AND
74192: IFFALSE 74333
74194: GO 74196
74196: DISABLE
74197: LD_INT 0
74199: PPUSH
74200: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
74201: LD_ADDR_VAR 0 2
74205: PUSH
74206: LD_INT 22
74208: PUSH
74209: LD_OWVAR 2
74213: PUSH
74214: EMPTY
74215: LIST
74216: LIST
74217: PUSH
74218: LD_INT 21
74220: PUSH
74221: LD_INT 1
74223: PUSH
74224: EMPTY
74225: LIST
74226: LIST
74227: PUSH
74228: EMPTY
74229: LIST
74230: LIST
74231: PPUSH
74232: CALL_OW 69
74236: ST_TO_ADDR
// if not tmp then
74237: LD_VAR 0 2
74241: NOT
74242: IFFALSE 74246
// exit ;
74244: GO 74333
// un := tmp [ rand ( 1 , tmp ) ] ;
74246: LD_ADDR_VAR 0 1
74250: PUSH
74251: LD_VAR 0 2
74255: PUSH
74256: LD_INT 1
74258: PPUSH
74259: LD_VAR 0 2
74263: PPUSH
74264: CALL_OW 12
74268: ARRAY
74269: ST_TO_ADDR
// SetSide ( un , 0 ) ;
74270: LD_VAR 0 1
74274: PPUSH
74275: LD_INT 0
74277: PPUSH
74278: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
74282: LD_VAR 0 1
74286: PPUSH
74287: LD_OWVAR 3
74291: PUSH
74292: LD_VAR 0 1
74296: DIFF
74297: PPUSH
74298: LD_VAR 0 1
74302: PPUSH
74303: CALL_OW 74
74307: PPUSH
74308: CALL_OW 115
// wait ( 0 0$20 ) ;
74312: LD_INT 700
74314: PPUSH
74315: CALL_OW 67
// SetSide ( un , your_side ) ;
74319: LD_VAR 0 1
74323: PPUSH
74324: LD_OWVAR 2
74328: PPUSH
74329: CALL_OW 235
// end ;
74333: PPOPN 2
74335: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
74336: LD_EXP 98
74340: PUSH
74341: LD_EXP 131
74345: AND
74346: IFFALSE 74452
74348: GO 74350
74350: DISABLE
74351: LD_INT 0
74353: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
74354: LD_ADDR_VAR 0 1
74358: PUSH
74359: LD_INT 22
74361: PUSH
74362: LD_OWVAR 2
74366: PUSH
74367: EMPTY
74368: LIST
74369: LIST
74370: PUSH
74371: LD_INT 2
74373: PUSH
74374: LD_INT 30
74376: PUSH
74377: LD_INT 0
74379: PUSH
74380: EMPTY
74381: LIST
74382: LIST
74383: PUSH
74384: LD_INT 30
74386: PUSH
74387: LD_INT 1
74389: PUSH
74390: EMPTY
74391: LIST
74392: LIST
74393: PUSH
74394: EMPTY
74395: LIST
74396: LIST
74397: LIST
74398: PUSH
74399: EMPTY
74400: LIST
74401: LIST
74402: PPUSH
74403: CALL_OW 69
74407: ST_TO_ADDR
// if not depot then
74408: LD_VAR 0 1
74412: NOT
74413: IFFALSE 74417
// exit ;
74415: GO 74452
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
74417: LD_VAR 0 1
74421: PUSH
74422: LD_INT 1
74424: ARRAY
74425: PPUSH
74426: CALL_OW 250
74430: PPUSH
74431: LD_VAR 0 1
74435: PUSH
74436: LD_INT 1
74438: ARRAY
74439: PPUSH
74440: CALL_OW 251
74444: PPUSH
74445: LD_INT 70
74447: PPUSH
74448: CALL_OW 495
// end ;
74452: PPOPN 1
74454: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
74455: LD_EXP 98
74459: PUSH
74460: LD_EXP 132
74464: AND
74465: IFFALSE 74676
74467: GO 74469
74469: DISABLE
74470: LD_INT 0
74472: PPUSH
74473: PPUSH
74474: PPUSH
74475: PPUSH
74476: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
74477: LD_ADDR_VAR 0 5
74481: PUSH
74482: LD_INT 22
74484: PUSH
74485: LD_OWVAR 2
74489: PUSH
74490: EMPTY
74491: LIST
74492: LIST
74493: PUSH
74494: LD_INT 21
74496: PUSH
74497: LD_INT 1
74499: PUSH
74500: EMPTY
74501: LIST
74502: LIST
74503: PUSH
74504: EMPTY
74505: LIST
74506: LIST
74507: PPUSH
74508: CALL_OW 69
74512: ST_TO_ADDR
// if not tmp then
74513: LD_VAR 0 5
74517: NOT
74518: IFFALSE 74522
// exit ;
74520: GO 74676
// for i in tmp do
74522: LD_ADDR_VAR 0 1
74526: PUSH
74527: LD_VAR 0 5
74531: PUSH
74532: FOR_IN
74533: IFFALSE 74674
// begin d := rand ( 0 , 5 ) ;
74535: LD_ADDR_VAR 0 4
74539: PUSH
74540: LD_INT 0
74542: PPUSH
74543: LD_INT 5
74545: PPUSH
74546: CALL_OW 12
74550: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
74551: LD_ADDR_VAR 0 2
74555: PUSH
74556: LD_VAR 0 1
74560: PPUSH
74561: CALL_OW 250
74565: PPUSH
74566: LD_VAR 0 4
74570: PPUSH
74571: LD_INT 3
74573: PPUSH
74574: LD_INT 12
74576: PPUSH
74577: CALL_OW 12
74581: PPUSH
74582: CALL_OW 272
74586: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
74587: LD_ADDR_VAR 0 3
74591: PUSH
74592: LD_VAR 0 1
74596: PPUSH
74597: CALL_OW 251
74601: PPUSH
74602: LD_VAR 0 4
74606: PPUSH
74607: LD_INT 3
74609: PPUSH
74610: LD_INT 12
74612: PPUSH
74613: CALL_OW 12
74617: PPUSH
74618: CALL_OW 273
74622: ST_TO_ADDR
// if ValidHex ( x , y ) then
74623: LD_VAR 0 2
74627: PPUSH
74628: LD_VAR 0 3
74632: PPUSH
74633: CALL_OW 488
74637: IFFALSE 74672
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
74639: LD_VAR 0 1
74643: PPUSH
74644: LD_VAR 0 2
74648: PPUSH
74649: LD_VAR 0 3
74653: PPUSH
74654: LD_INT 3
74656: PPUSH
74657: LD_INT 6
74659: PPUSH
74660: CALL_OW 12
74664: PPUSH
74665: LD_INT 1
74667: PPUSH
74668: CALL_OW 483
// end ;
74672: GO 74532
74674: POP
74675: POP
// end ;
74676: PPOPN 5
74678: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
74679: LD_EXP 98
74683: PUSH
74684: LD_EXP 133
74688: AND
74689: IFFALSE 74783
74691: GO 74693
74693: DISABLE
74694: LD_INT 0
74696: PPUSH
74697: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
74698: LD_ADDR_VAR 0 2
74702: PUSH
74703: LD_INT 22
74705: PUSH
74706: LD_OWVAR 2
74710: PUSH
74711: EMPTY
74712: LIST
74713: LIST
74714: PUSH
74715: LD_INT 32
74717: PUSH
74718: LD_INT 1
74720: PUSH
74721: EMPTY
74722: LIST
74723: LIST
74724: PUSH
74725: LD_INT 21
74727: PUSH
74728: LD_INT 2
74730: PUSH
74731: EMPTY
74732: LIST
74733: LIST
74734: PUSH
74735: EMPTY
74736: LIST
74737: LIST
74738: LIST
74739: PPUSH
74740: CALL_OW 69
74744: ST_TO_ADDR
// if not tmp then
74745: LD_VAR 0 2
74749: NOT
74750: IFFALSE 74754
// exit ;
74752: GO 74783
// for i in tmp do
74754: LD_ADDR_VAR 0 1
74758: PUSH
74759: LD_VAR 0 2
74763: PUSH
74764: FOR_IN
74765: IFFALSE 74781
// SetFuel ( i , 0 ) ;
74767: LD_VAR 0 1
74771: PPUSH
74772: LD_INT 0
74774: PPUSH
74775: CALL_OW 240
74779: GO 74764
74781: POP
74782: POP
// end ;
74783: PPOPN 2
74785: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
74786: LD_EXP 98
74790: PUSH
74791: LD_EXP 134
74795: AND
74796: IFFALSE 74862
74798: GO 74800
74800: DISABLE
74801: LD_INT 0
74803: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
74804: LD_ADDR_VAR 0 1
74808: PUSH
74809: LD_INT 22
74811: PUSH
74812: LD_OWVAR 2
74816: PUSH
74817: EMPTY
74818: LIST
74819: LIST
74820: PUSH
74821: LD_INT 30
74823: PUSH
74824: LD_INT 29
74826: PUSH
74827: EMPTY
74828: LIST
74829: LIST
74830: PUSH
74831: EMPTY
74832: LIST
74833: LIST
74834: PPUSH
74835: CALL_OW 69
74839: ST_TO_ADDR
// if not tmp then
74840: LD_VAR 0 1
74844: NOT
74845: IFFALSE 74849
// exit ;
74847: GO 74862
// DestroyUnit ( tmp [ 1 ] ) ;
74849: LD_VAR 0 1
74853: PUSH
74854: LD_INT 1
74856: ARRAY
74857: PPUSH
74858: CALL_OW 65
// end ;
74862: PPOPN 1
74864: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
74865: LD_EXP 98
74869: PUSH
74870: LD_EXP 136
74874: AND
74875: IFFALSE 75004
74877: GO 74879
74879: DISABLE
74880: LD_INT 0
74882: PPUSH
// begin uc_side := 0 ;
74883: LD_ADDR_OWVAR 20
74887: PUSH
74888: LD_INT 0
74890: ST_TO_ADDR
// uc_nation := nation_arabian ;
74891: LD_ADDR_OWVAR 21
74895: PUSH
74896: LD_INT 2
74898: ST_TO_ADDR
// hc_gallery :=  ;
74899: LD_ADDR_OWVAR 33
74903: PUSH
74904: LD_STRING 
74906: ST_TO_ADDR
// hc_name :=  ;
74907: LD_ADDR_OWVAR 26
74911: PUSH
74912: LD_STRING 
74914: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
74915: LD_INT 1
74917: PPUSH
74918: LD_INT 11
74920: PPUSH
74921: LD_INT 10
74923: PPUSH
74924: CALL_OW 380
// un := CreateHuman ;
74928: LD_ADDR_VAR 0 1
74932: PUSH
74933: CALL_OW 44
74937: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
74938: LD_VAR 0 1
74942: PPUSH
74943: LD_INT 1
74945: PPUSH
74946: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
74950: LD_INT 35
74952: PPUSH
74953: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
74957: LD_VAR 0 1
74961: PPUSH
74962: LD_INT 22
74964: PUSH
74965: LD_OWVAR 2
74969: PUSH
74970: EMPTY
74971: LIST
74972: LIST
74973: PPUSH
74974: CALL_OW 69
74978: PPUSH
74979: LD_VAR 0 1
74983: PPUSH
74984: CALL_OW 74
74988: PPUSH
74989: CALL_OW 115
// until IsDead ( un ) ;
74993: LD_VAR 0 1
74997: PPUSH
74998: CALL_OW 301
75002: IFFALSE 74950
// end ;
75004: PPOPN 1
75006: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
75007: LD_EXP 98
75011: PUSH
75012: LD_EXP 138
75016: AND
75017: IFFALSE 75029
75019: GO 75021
75021: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
75022: LD_STRING earthquake(getX(game), 0, 32)
75024: PPUSH
75025: CALL_OW 559
75029: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
75030: LD_EXP 98
75034: PUSH
75035: LD_EXP 139
75039: AND
75040: IFFALSE 75131
75042: GO 75044
75044: DISABLE
75045: LD_INT 0
75047: PPUSH
// begin enable ;
75048: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
75049: LD_ADDR_VAR 0 1
75053: PUSH
75054: LD_INT 22
75056: PUSH
75057: LD_OWVAR 2
75061: PUSH
75062: EMPTY
75063: LIST
75064: LIST
75065: PUSH
75066: LD_INT 21
75068: PUSH
75069: LD_INT 2
75071: PUSH
75072: EMPTY
75073: LIST
75074: LIST
75075: PUSH
75076: LD_INT 33
75078: PUSH
75079: LD_INT 3
75081: PUSH
75082: EMPTY
75083: LIST
75084: LIST
75085: PUSH
75086: EMPTY
75087: LIST
75088: LIST
75089: LIST
75090: PPUSH
75091: CALL_OW 69
75095: ST_TO_ADDR
// if not tmp then
75096: LD_VAR 0 1
75100: NOT
75101: IFFALSE 75105
// exit ;
75103: GO 75131
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
75105: LD_VAR 0 1
75109: PUSH
75110: LD_INT 1
75112: PPUSH
75113: LD_VAR 0 1
75117: PPUSH
75118: CALL_OW 12
75122: ARRAY
75123: PPUSH
75124: LD_INT 1
75126: PPUSH
75127: CALL_OW 234
// end ;
75131: PPOPN 1
75133: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
75134: LD_EXP 98
75138: PUSH
75139: LD_EXP 140
75143: AND
75144: IFFALSE 75285
75146: GO 75148
75148: DISABLE
75149: LD_INT 0
75151: PPUSH
75152: PPUSH
75153: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
75154: LD_ADDR_VAR 0 3
75158: PUSH
75159: LD_INT 22
75161: PUSH
75162: LD_OWVAR 2
75166: PUSH
75167: EMPTY
75168: LIST
75169: LIST
75170: PUSH
75171: LD_INT 25
75173: PUSH
75174: LD_INT 1
75176: PUSH
75177: EMPTY
75178: LIST
75179: LIST
75180: PUSH
75181: EMPTY
75182: LIST
75183: LIST
75184: PPUSH
75185: CALL_OW 69
75189: ST_TO_ADDR
// if not tmp then
75190: LD_VAR 0 3
75194: NOT
75195: IFFALSE 75199
// exit ;
75197: GO 75285
// un := tmp [ rand ( 1 , tmp ) ] ;
75199: LD_ADDR_VAR 0 2
75203: PUSH
75204: LD_VAR 0 3
75208: PUSH
75209: LD_INT 1
75211: PPUSH
75212: LD_VAR 0 3
75216: PPUSH
75217: CALL_OW 12
75221: ARRAY
75222: ST_TO_ADDR
// if Crawls ( un ) then
75223: LD_VAR 0 2
75227: PPUSH
75228: CALL_OW 318
75232: IFFALSE 75243
// ComWalk ( un ) ;
75234: LD_VAR 0 2
75238: PPUSH
75239: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
75243: LD_VAR 0 2
75247: PPUSH
75248: LD_INT 9
75250: PPUSH
75251: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
75255: LD_INT 28
75257: PPUSH
75258: LD_OWVAR 2
75262: PPUSH
75263: LD_INT 2
75265: PPUSH
75266: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
75270: LD_INT 29
75272: PPUSH
75273: LD_OWVAR 2
75277: PPUSH
75278: LD_INT 2
75280: PPUSH
75281: CALL_OW 322
// end ;
75285: PPOPN 3
75287: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
75288: LD_EXP 98
75292: PUSH
75293: LD_EXP 141
75297: AND
75298: IFFALSE 75409
75300: GO 75302
75302: DISABLE
75303: LD_INT 0
75305: PPUSH
75306: PPUSH
75307: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
75308: LD_ADDR_VAR 0 3
75312: PUSH
75313: LD_INT 22
75315: PUSH
75316: LD_OWVAR 2
75320: PUSH
75321: EMPTY
75322: LIST
75323: LIST
75324: PUSH
75325: LD_INT 25
75327: PUSH
75328: LD_INT 1
75330: PUSH
75331: EMPTY
75332: LIST
75333: LIST
75334: PUSH
75335: EMPTY
75336: LIST
75337: LIST
75338: PPUSH
75339: CALL_OW 69
75343: ST_TO_ADDR
// if not tmp then
75344: LD_VAR 0 3
75348: NOT
75349: IFFALSE 75353
// exit ;
75351: GO 75409
// un := tmp [ rand ( 1 , tmp ) ] ;
75353: LD_ADDR_VAR 0 2
75357: PUSH
75358: LD_VAR 0 3
75362: PUSH
75363: LD_INT 1
75365: PPUSH
75366: LD_VAR 0 3
75370: PPUSH
75371: CALL_OW 12
75375: ARRAY
75376: ST_TO_ADDR
// if Crawls ( un ) then
75377: LD_VAR 0 2
75381: PPUSH
75382: CALL_OW 318
75386: IFFALSE 75397
// ComWalk ( un ) ;
75388: LD_VAR 0 2
75392: PPUSH
75393: CALL_OW 138
// SetClass ( un , class_mortar ) ;
75397: LD_VAR 0 2
75401: PPUSH
75402: LD_INT 8
75404: PPUSH
75405: CALL_OW 336
// end ;
75409: PPOPN 3
75411: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
75412: LD_EXP 98
75416: PUSH
75417: LD_EXP 142
75421: AND
75422: IFFALSE 75566
75424: GO 75426
75426: DISABLE
75427: LD_INT 0
75429: PPUSH
75430: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
75431: LD_ADDR_VAR 0 2
75435: PUSH
75436: LD_INT 22
75438: PUSH
75439: LD_OWVAR 2
75443: PUSH
75444: EMPTY
75445: LIST
75446: LIST
75447: PUSH
75448: LD_INT 21
75450: PUSH
75451: LD_INT 2
75453: PUSH
75454: EMPTY
75455: LIST
75456: LIST
75457: PUSH
75458: LD_INT 2
75460: PUSH
75461: LD_INT 34
75463: PUSH
75464: LD_INT 12
75466: PUSH
75467: EMPTY
75468: LIST
75469: LIST
75470: PUSH
75471: LD_INT 34
75473: PUSH
75474: LD_INT 51
75476: PUSH
75477: EMPTY
75478: LIST
75479: LIST
75480: PUSH
75481: LD_INT 34
75483: PUSH
75484: LD_INT 32
75486: PUSH
75487: EMPTY
75488: LIST
75489: LIST
75490: PUSH
75491: EMPTY
75492: LIST
75493: LIST
75494: LIST
75495: LIST
75496: PUSH
75497: EMPTY
75498: LIST
75499: LIST
75500: LIST
75501: PPUSH
75502: CALL_OW 69
75506: ST_TO_ADDR
// if not tmp then
75507: LD_VAR 0 2
75511: NOT
75512: IFFALSE 75516
// exit ;
75514: GO 75566
// for i in tmp do
75516: LD_ADDR_VAR 0 1
75520: PUSH
75521: LD_VAR 0 2
75525: PUSH
75526: FOR_IN
75527: IFFALSE 75564
// if GetCargo ( i , mat_artifact ) = 0 then
75529: LD_VAR 0 1
75533: PPUSH
75534: LD_INT 4
75536: PPUSH
75537: CALL_OW 289
75541: PUSH
75542: LD_INT 0
75544: EQUAL
75545: IFFALSE 75562
// SetCargo ( i , mat_siberit , 100 ) ;
75547: LD_VAR 0 1
75551: PPUSH
75552: LD_INT 3
75554: PPUSH
75555: LD_INT 100
75557: PPUSH
75558: CALL_OW 290
75562: GO 75526
75564: POP
75565: POP
// end ;
75566: PPOPN 2
75568: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
75569: LD_EXP 98
75573: PUSH
75574: LD_EXP 143
75578: AND
75579: IFFALSE 75762
75581: GO 75583
75583: DISABLE
75584: LD_INT 0
75586: PPUSH
75587: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
75588: LD_ADDR_VAR 0 2
75592: PUSH
75593: LD_INT 22
75595: PUSH
75596: LD_OWVAR 2
75600: PUSH
75601: EMPTY
75602: LIST
75603: LIST
75604: PPUSH
75605: CALL_OW 69
75609: ST_TO_ADDR
// if not tmp then
75610: LD_VAR 0 2
75614: NOT
75615: IFFALSE 75619
// exit ;
75617: GO 75762
// for i := 1 to 2 do
75619: LD_ADDR_VAR 0 1
75623: PUSH
75624: DOUBLE
75625: LD_INT 1
75627: DEC
75628: ST_TO_ADDR
75629: LD_INT 2
75631: PUSH
75632: FOR_TO
75633: IFFALSE 75760
// begin uc_side := your_side ;
75635: LD_ADDR_OWVAR 20
75639: PUSH
75640: LD_OWVAR 2
75644: ST_TO_ADDR
// uc_nation := nation_american ;
75645: LD_ADDR_OWVAR 21
75649: PUSH
75650: LD_INT 1
75652: ST_TO_ADDR
// vc_chassis := us_morphling ;
75653: LD_ADDR_OWVAR 37
75657: PUSH
75658: LD_INT 5
75660: ST_TO_ADDR
// vc_engine := engine_siberite ;
75661: LD_ADDR_OWVAR 39
75665: PUSH
75666: LD_INT 3
75668: ST_TO_ADDR
// vc_control := control_computer ;
75669: LD_ADDR_OWVAR 38
75673: PUSH
75674: LD_INT 3
75676: ST_TO_ADDR
// vc_weapon := us_double_laser ;
75677: LD_ADDR_OWVAR 40
75681: PUSH
75682: LD_INT 10
75684: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
75685: LD_VAR 0 2
75689: PUSH
75690: LD_INT 1
75692: ARRAY
75693: PPUSH
75694: CALL_OW 310
75698: NOT
75699: IFFALSE 75746
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
75701: CALL_OW 45
75705: PPUSH
75706: LD_VAR 0 2
75710: PUSH
75711: LD_INT 1
75713: ARRAY
75714: PPUSH
75715: CALL_OW 250
75719: PPUSH
75720: LD_VAR 0 2
75724: PUSH
75725: LD_INT 1
75727: ARRAY
75728: PPUSH
75729: CALL_OW 251
75733: PPUSH
75734: LD_INT 12
75736: PPUSH
75737: LD_INT 1
75739: PPUSH
75740: CALL_OW 50
75744: GO 75758
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
75746: CALL_OW 45
75750: PPUSH
75751: LD_INT 1
75753: PPUSH
75754: CALL_OW 51
// end ;
75758: GO 75632
75760: POP
75761: POP
// end ;
75762: PPOPN 2
75764: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
75765: LD_EXP 98
75769: PUSH
75770: LD_EXP 144
75774: AND
75775: IFFALSE 75997
75777: GO 75779
75779: DISABLE
75780: LD_INT 0
75782: PPUSH
75783: PPUSH
75784: PPUSH
75785: PPUSH
75786: PPUSH
75787: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
75788: LD_ADDR_VAR 0 6
75792: PUSH
75793: LD_INT 22
75795: PUSH
75796: LD_OWVAR 2
75800: PUSH
75801: EMPTY
75802: LIST
75803: LIST
75804: PUSH
75805: LD_INT 21
75807: PUSH
75808: LD_INT 1
75810: PUSH
75811: EMPTY
75812: LIST
75813: LIST
75814: PUSH
75815: LD_INT 3
75817: PUSH
75818: LD_INT 23
75820: PUSH
75821: LD_INT 0
75823: PUSH
75824: EMPTY
75825: LIST
75826: LIST
75827: PUSH
75828: EMPTY
75829: LIST
75830: LIST
75831: PUSH
75832: EMPTY
75833: LIST
75834: LIST
75835: LIST
75836: PPUSH
75837: CALL_OW 69
75841: ST_TO_ADDR
// if not tmp then
75842: LD_VAR 0 6
75846: NOT
75847: IFFALSE 75851
// exit ;
75849: GO 75997
// s1 := rand ( 1 , 4 ) ;
75851: LD_ADDR_VAR 0 2
75855: PUSH
75856: LD_INT 1
75858: PPUSH
75859: LD_INT 4
75861: PPUSH
75862: CALL_OW 12
75866: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
75867: LD_ADDR_VAR 0 4
75871: PUSH
75872: LD_VAR 0 6
75876: PUSH
75877: LD_INT 1
75879: ARRAY
75880: PPUSH
75881: LD_VAR 0 2
75885: PPUSH
75886: CALL_OW 259
75890: ST_TO_ADDR
// if s1 = 1 then
75891: LD_VAR 0 2
75895: PUSH
75896: LD_INT 1
75898: EQUAL
75899: IFFALSE 75919
// s2 := rand ( 2 , 4 ) else
75901: LD_ADDR_VAR 0 3
75905: PUSH
75906: LD_INT 2
75908: PPUSH
75909: LD_INT 4
75911: PPUSH
75912: CALL_OW 12
75916: ST_TO_ADDR
75917: GO 75927
// s2 := 1 ;
75919: LD_ADDR_VAR 0 3
75923: PUSH
75924: LD_INT 1
75926: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
75927: LD_ADDR_VAR 0 5
75931: PUSH
75932: LD_VAR 0 6
75936: PUSH
75937: LD_INT 1
75939: ARRAY
75940: PPUSH
75941: LD_VAR 0 3
75945: PPUSH
75946: CALL_OW 259
75950: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
75951: LD_VAR 0 6
75955: PUSH
75956: LD_INT 1
75958: ARRAY
75959: PPUSH
75960: LD_VAR 0 2
75964: PPUSH
75965: LD_VAR 0 5
75969: PPUSH
75970: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
75974: LD_VAR 0 6
75978: PUSH
75979: LD_INT 1
75981: ARRAY
75982: PPUSH
75983: LD_VAR 0 3
75987: PPUSH
75988: LD_VAR 0 4
75992: PPUSH
75993: CALL_OW 237
// end ;
75997: PPOPN 6
75999: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
76000: LD_EXP 98
76004: PUSH
76005: LD_EXP 145
76009: AND
76010: IFFALSE 76089
76012: GO 76014
76014: DISABLE
76015: LD_INT 0
76017: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
76018: LD_ADDR_VAR 0 1
76022: PUSH
76023: LD_INT 22
76025: PUSH
76026: LD_OWVAR 2
76030: PUSH
76031: EMPTY
76032: LIST
76033: LIST
76034: PUSH
76035: LD_INT 30
76037: PUSH
76038: LD_INT 3
76040: PUSH
76041: EMPTY
76042: LIST
76043: LIST
76044: PUSH
76045: EMPTY
76046: LIST
76047: LIST
76048: PPUSH
76049: CALL_OW 69
76053: ST_TO_ADDR
// if not tmp then
76054: LD_VAR 0 1
76058: NOT
76059: IFFALSE 76063
// exit ;
76061: GO 76089
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
76063: LD_VAR 0 1
76067: PUSH
76068: LD_INT 1
76070: PPUSH
76071: LD_VAR 0 1
76075: PPUSH
76076: CALL_OW 12
76080: ARRAY
76081: PPUSH
76082: LD_INT 1
76084: PPUSH
76085: CALL_OW 234
// end ;
76089: PPOPN 1
76091: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
76092: LD_EXP 98
76096: PUSH
76097: LD_EXP 146
76101: AND
76102: IFFALSE 76214
76104: GO 76106
76106: DISABLE
76107: LD_INT 0
76109: PPUSH
76110: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
76111: LD_ADDR_VAR 0 2
76115: PUSH
76116: LD_INT 22
76118: PUSH
76119: LD_OWVAR 2
76123: PUSH
76124: EMPTY
76125: LIST
76126: LIST
76127: PUSH
76128: LD_INT 2
76130: PUSH
76131: LD_INT 30
76133: PUSH
76134: LD_INT 27
76136: PUSH
76137: EMPTY
76138: LIST
76139: LIST
76140: PUSH
76141: LD_INT 30
76143: PUSH
76144: LD_INT 26
76146: PUSH
76147: EMPTY
76148: LIST
76149: LIST
76150: PUSH
76151: LD_INT 30
76153: PUSH
76154: LD_INT 28
76156: PUSH
76157: EMPTY
76158: LIST
76159: LIST
76160: PUSH
76161: EMPTY
76162: LIST
76163: LIST
76164: LIST
76165: LIST
76166: PUSH
76167: EMPTY
76168: LIST
76169: LIST
76170: PPUSH
76171: CALL_OW 69
76175: ST_TO_ADDR
// if not tmp then
76176: LD_VAR 0 2
76180: NOT
76181: IFFALSE 76185
// exit ;
76183: GO 76214
// for i in tmp do
76185: LD_ADDR_VAR 0 1
76189: PUSH
76190: LD_VAR 0 2
76194: PUSH
76195: FOR_IN
76196: IFFALSE 76212
// SetLives ( i , 1 ) ;
76198: LD_VAR 0 1
76202: PPUSH
76203: LD_INT 1
76205: PPUSH
76206: CALL_OW 234
76210: GO 76195
76212: POP
76213: POP
// end ;
76214: PPOPN 2
76216: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
76217: LD_EXP 98
76221: PUSH
76222: LD_EXP 147
76226: AND
76227: IFFALSE 76514
76229: GO 76231
76231: DISABLE
76232: LD_INT 0
76234: PPUSH
76235: PPUSH
76236: PPUSH
// begin i := rand ( 1 , 7 ) ;
76237: LD_ADDR_VAR 0 1
76241: PUSH
76242: LD_INT 1
76244: PPUSH
76245: LD_INT 7
76247: PPUSH
76248: CALL_OW 12
76252: ST_TO_ADDR
// case i of 1 :
76253: LD_VAR 0 1
76257: PUSH
76258: LD_INT 1
76260: DOUBLE
76261: EQUAL
76262: IFTRUE 76266
76264: GO 76276
76266: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
76267: LD_STRING earthquake(getX(game), 0, 32)
76269: PPUSH
76270: CALL_OW 559
76274: GO 76514
76276: LD_INT 2
76278: DOUBLE
76279: EQUAL
76280: IFTRUE 76284
76282: GO 76298
76284: POP
// begin ToLua ( displayStucuk(); ) ;
76285: LD_STRING displayStucuk();
76287: PPUSH
76288: CALL_OW 559
// ResetFog ;
76292: CALL_OW 335
// end ; 3 :
76296: GO 76514
76298: LD_INT 3
76300: DOUBLE
76301: EQUAL
76302: IFTRUE 76306
76304: GO 76410
76306: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
76307: LD_ADDR_VAR 0 2
76311: PUSH
76312: LD_INT 22
76314: PUSH
76315: LD_OWVAR 2
76319: PUSH
76320: EMPTY
76321: LIST
76322: LIST
76323: PUSH
76324: LD_INT 25
76326: PUSH
76327: LD_INT 1
76329: PUSH
76330: EMPTY
76331: LIST
76332: LIST
76333: PUSH
76334: EMPTY
76335: LIST
76336: LIST
76337: PPUSH
76338: CALL_OW 69
76342: ST_TO_ADDR
// if not tmp then
76343: LD_VAR 0 2
76347: NOT
76348: IFFALSE 76352
// exit ;
76350: GO 76514
// un := tmp [ rand ( 1 , tmp ) ] ;
76352: LD_ADDR_VAR 0 3
76356: PUSH
76357: LD_VAR 0 2
76361: PUSH
76362: LD_INT 1
76364: PPUSH
76365: LD_VAR 0 2
76369: PPUSH
76370: CALL_OW 12
76374: ARRAY
76375: ST_TO_ADDR
// if Crawls ( un ) then
76376: LD_VAR 0 3
76380: PPUSH
76381: CALL_OW 318
76385: IFFALSE 76396
// ComWalk ( un ) ;
76387: LD_VAR 0 3
76391: PPUSH
76392: CALL_OW 138
// SetClass ( un , class_mortar ) ;
76396: LD_VAR 0 3
76400: PPUSH
76401: LD_INT 8
76403: PPUSH
76404: CALL_OW 336
// end ; 4 :
76408: GO 76514
76410: LD_INT 4
76412: DOUBLE
76413: EQUAL
76414: IFTRUE 76418
76416: GO 76492
76418: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
76419: LD_ADDR_VAR 0 2
76423: PUSH
76424: LD_INT 22
76426: PUSH
76427: LD_OWVAR 2
76431: PUSH
76432: EMPTY
76433: LIST
76434: LIST
76435: PUSH
76436: LD_INT 30
76438: PUSH
76439: LD_INT 29
76441: PUSH
76442: EMPTY
76443: LIST
76444: LIST
76445: PUSH
76446: EMPTY
76447: LIST
76448: LIST
76449: PPUSH
76450: CALL_OW 69
76454: ST_TO_ADDR
// if not tmp then
76455: LD_VAR 0 2
76459: NOT
76460: IFFALSE 76464
// exit ;
76462: GO 76514
// CenterNowOnUnits ( tmp [ 1 ] ) ;
76464: LD_VAR 0 2
76468: PUSH
76469: LD_INT 1
76471: ARRAY
76472: PPUSH
76473: CALL_OW 87
// DestroyUnit ( tmp [ 1 ] ) ;
76477: LD_VAR 0 2
76481: PUSH
76482: LD_INT 1
76484: ARRAY
76485: PPUSH
76486: CALL_OW 65
// end ; 5 .. 7 :
76490: GO 76514
76492: LD_INT 5
76494: DOUBLE
76495: GREATEREQUAL
76496: IFFALSE 76504
76498: LD_INT 7
76500: DOUBLE
76501: LESSEQUAL
76502: IFTRUE 76506
76504: GO 76513
76506: POP
// StreamSibBomb ; end ;
76507: CALL 72751 0 0
76511: GO 76514
76513: POP
// end ;
76514: PPOPN 3
76516: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
76517: LD_EXP 98
76521: PUSH
76522: LD_EXP 148
76526: AND
76527: IFFALSE 76683
76529: GO 76531
76531: DISABLE
76532: LD_INT 0
76534: PPUSH
76535: PPUSH
76536: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
76537: LD_ADDR_VAR 0 2
76541: PUSH
76542: LD_INT 81
76544: PUSH
76545: LD_OWVAR 2
76549: PUSH
76550: EMPTY
76551: LIST
76552: LIST
76553: PUSH
76554: LD_INT 2
76556: PUSH
76557: LD_INT 21
76559: PUSH
76560: LD_INT 1
76562: PUSH
76563: EMPTY
76564: LIST
76565: LIST
76566: PUSH
76567: LD_INT 21
76569: PUSH
76570: LD_INT 2
76572: PUSH
76573: EMPTY
76574: LIST
76575: LIST
76576: PUSH
76577: EMPTY
76578: LIST
76579: LIST
76580: LIST
76581: PUSH
76582: EMPTY
76583: LIST
76584: LIST
76585: PPUSH
76586: CALL_OW 69
76590: ST_TO_ADDR
// if not tmp then
76591: LD_VAR 0 2
76595: NOT
76596: IFFALSE 76600
// exit ;
76598: GO 76683
// p := 0 ;
76600: LD_ADDR_VAR 0 3
76604: PUSH
76605: LD_INT 0
76607: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
76608: LD_INT 35
76610: PPUSH
76611: CALL_OW 67
// p := p + 1 ;
76615: LD_ADDR_VAR 0 3
76619: PUSH
76620: LD_VAR 0 3
76624: PUSH
76625: LD_INT 1
76627: PLUS
76628: ST_TO_ADDR
// for i in tmp do
76629: LD_ADDR_VAR 0 1
76633: PUSH
76634: LD_VAR 0 2
76638: PUSH
76639: FOR_IN
76640: IFFALSE 76671
// if GetLives ( i ) < 1000 then
76642: LD_VAR 0 1
76646: PPUSH
76647: CALL_OW 256
76651: PUSH
76652: LD_INT 1000
76654: LESS
76655: IFFALSE 76669
// SetLives ( i , 1000 ) ;
76657: LD_VAR 0 1
76661: PPUSH
76662: LD_INT 1000
76664: PPUSH
76665: CALL_OW 234
76669: GO 76639
76671: POP
76672: POP
// until p > 20 ;
76673: LD_VAR 0 3
76677: PUSH
76678: LD_INT 20
76680: GREATER
76681: IFFALSE 76608
// end ;
76683: PPOPN 3
76685: END
// every 0 0$1 trigger StreamModeActive and sTime do
76686: LD_EXP 98
76690: PUSH
76691: LD_EXP 149
76695: AND
76696: IFFALSE 76731
76698: GO 76700
76700: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
76701: LD_INT 28
76703: PPUSH
76704: LD_OWVAR 2
76708: PPUSH
76709: LD_INT 2
76711: PPUSH
76712: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
76716: LD_INT 30
76718: PPUSH
76719: LD_OWVAR 2
76723: PPUSH
76724: LD_INT 2
76726: PPUSH
76727: CALL_OW 322
// end ;
76731: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
76732: LD_EXP 98
76736: PUSH
76737: LD_EXP 150
76741: AND
76742: IFFALSE 76863
76744: GO 76746
76746: DISABLE
76747: LD_INT 0
76749: PPUSH
76750: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
76751: LD_ADDR_VAR 0 2
76755: PUSH
76756: LD_INT 22
76758: PUSH
76759: LD_OWVAR 2
76763: PUSH
76764: EMPTY
76765: LIST
76766: LIST
76767: PUSH
76768: LD_INT 21
76770: PUSH
76771: LD_INT 1
76773: PUSH
76774: EMPTY
76775: LIST
76776: LIST
76777: PUSH
76778: LD_INT 3
76780: PUSH
76781: LD_INT 23
76783: PUSH
76784: LD_INT 0
76786: PUSH
76787: EMPTY
76788: LIST
76789: LIST
76790: PUSH
76791: EMPTY
76792: LIST
76793: LIST
76794: PUSH
76795: EMPTY
76796: LIST
76797: LIST
76798: LIST
76799: PPUSH
76800: CALL_OW 69
76804: ST_TO_ADDR
// if not tmp then
76805: LD_VAR 0 2
76809: NOT
76810: IFFALSE 76814
// exit ;
76812: GO 76863
// for i in tmp do
76814: LD_ADDR_VAR 0 1
76818: PUSH
76819: LD_VAR 0 2
76823: PUSH
76824: FOR_IN
76825: IFFALSE 76861
// begin if Crawls ( i ) then
76827: LD_VAR 0 1
76831: PPUSH
76832: CALL_OW 318
76836: IFFALSE 76847
// ComWalk ( i ) ;
76838: LD_VAR 0 1
76842: PPUSH
76843: CALL_OW 138
// SetClass ( i , 2 ) ;
76847: LD_VAR 0 1
76851: PPUSH
76852: LD_INT 2
76854: PPUSH
76855: CALL_OW 336
// end ;
76859: GO 76824
76861: POP
76862: POP
// end ;
76863: PPOPN 2
76865: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
76866: LD_EXP 98
76870: PUSH
76871: LD_EXP 151
76875: AND
76876: IFFALSE 77164
76878: GO 76880
76880: DISABLE
76881: LD_INT 0
76883: PPUSH
76884: PPUSH
76885: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
76886: LD_OWVAR 2
76890: PPUSH
76891: LD_INT 9
76893: PPUSH
76894: LD_INT 1
76896: PPUSH
76897: LD_INT 1
76899: PPUSH
76900: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
76904: LD_INT 9
76906: PPUSH
76907: LD_OWVAR 2
76911: PPUSH
76912: CALL_OW 343
// uc_side := 9 ;
76916: LD_ADDR_OWVAR 20
76920: PUSH
76921: LD_INT 9
76923: ST_TO_ADDR
// uc_nation := 2 ;
76924: LD_ADDR_OWVAR 21
76928: PUSH
76929: LD_INT 2
76931: ST_TO_ADDR
// hc_name := Dark Warrior ;
76932: LD_ADDR_OWVAR 26
76936: PUSH
76937: LD_STRING Dark Warrior
76939: ST_TO_ADDR
// hc_gallery :=  ;
76940: LD_ADDR_OWVAR 33
76944: PUSH
76945: LD_STRING 
76947: ST_TO_ADDR
// hc_noskilllimit := true ;
76948: LD_ADDR_OWVAR 76
76952: PUSH
76953: LD_INT 1
76955: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
76956: LD_ADDR_OWVAR 31
76960: PUSH
76961: LD_INT 30
76963: PUSH
76964: LD_INT 30
76966: PUSH
76967: LD_INT 30
76969: PUSH
76970: LD_INT 30
76972: PUSH
76973: EMPTY
76974: LIST
76975: LIST
76976: LIST
76977: LIST
76978: ST_TO_ADDR
// un := CreateHuman ;
76979: LD_ADDR_VAR 0 3
76983: PUSH
76984: CALL_OW 44
76988: ST_TO_ADDR
// hc_noskilllimit := false ;
76989: LD_ADDR_OWVAR 76
76993: PUSH
76994: LD_INT 0
76996: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
76997: LD_VAR 0 3
77001: PPUSH
77002: LD_INT 1
77004: PPUSH
77005: CALL_OW 51
// ToLua ( playRanger() ) ;
77009: LD_STRING playRanger()
77011: PPUSH
77012: CALL_OW 559
// p := 0 ;
77016: LD_ADDR_VAR 0 2
77020: PUSH
77021: LD_INT 0
77023: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
77024: LD_INT 35
77026: PPUSH
77027: CALL_OW 67
// p := p + 1 ;
77031: LD_ADDR_VAR 0 2
77035: PUSH
77036: LD_VAR 0 2
77040: PUSH
77041: LD_INT 1
77043: PLUS
77044: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
77045: LD_VAR 0 3
77049: PPUSH
77050: CALL_OW 256
77054: PUSH
77055: LD_INT 1000
77057: LESS
77058: IFFALSE 77072
// SetLives ( un , 1000 ) ;
77060: LD_VAR 0 3
77064: PPUSH
77065: LD_INT 1000
77067: PPUSH
77068: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
77072: LD_VAR 0 3
77076: PPUSH
77077: LD_INT 81
77079: PUSH
77080: LD_OWVAR 2
77084: PUSH
77085: EMPTY
77086: LIST
77087: LIST
77088: PUSH
77089: LD_INT 91
77091: PUSH
77092: LD_VAR 0 3
77096: PUSH
77097: LD_INT 30
77099: PUSH
77100: EMPTY
77101: LIST
77102: LIST
77103: LIST
77104: PUSH
77105: EMPTY
77106: LIST
77107: LIST
77108: PPUSH
77109: CALL_OW 69
77113: PPUSH
77114: LD_VAR 0 3
77118: PPUSH
77119: CALL_OW 74
77123: PPUSH
77124: CALL_OW 115
// until p > 80 or IsDead ( un ) ;
77128: LD_VAR 0 2
77132: PUSH
77133: LD_INT 80
77135: GREATER
77136: PUSH
77137: LD_VAR 0 3
77141: PPUSH
77142: CALL_OW 301
77146: OR
77147: IFFALSE 77024
// if un then
77149: LD_VAR 0 3
77153: IFFALSE 77164
// RemoveUnit ( un ) ;
77155: LD_VAR 0 3
77159: PPUSH
77160: CALL_OW 64
// end ;
77164: PPOPN 3
77166: END
// every 0 0$1 trigger sComputer do var i , tmp , j ;
77167: LD_EXP 152
77171: IFFALSE 77287
77173: GO 77175
77175: DISABLE
77176: LD_INT 0
77178: PPUSH
77179: PPUSH
77180: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
77181: LD_ADDR_VAR 0 2
77185: PUSH
77186: LD_INT 81
77188: PUSH
77189: LD_OWVAR 2
77193: PUSH
77194: EMPTY
77195: LIST
77196: LIST
77197: PUSH
77198: LD_INT 21
77200: PUSH
77201: LD_INT 1
77203: PUSH
77204: EMPTY
77205: LIST
77206: LIST
77207: PUSH
77208: EMPTY
77209: LIST
77210: LIST
77211: PPUSH
77212: CALL_OW 69
77216: ST_TO_ADDR
// ToLua ( playComputer() ) ;
77217: LD_STRING playComputer()
77219: PPUSH
77220: CALL_OW 559
// if not tmp then
77224: LD_VAR 0 2
77228: NOT
77229: IFFALSE 77233
// exit ;
77231: GO 77287
// for i in tmp do
77233: LD_ADDR_VAR 0 1
77237: PUSH
77238: LD_VAR 0 2
77242: PUSH
77243: FOR_IN
77244: IFFALSE 77285
// for j := 1 to 4 do
77246: LD_ADDR_VAR 0 3
77250: PUSH
77251: DOUBLE
77252: LD_INT 1
77254: DEC
77255: ST_TO_ADDR
77256: LD_INT 4
77258: PUSH
77259: FOR_TO
77260: IFFALSE 77281
// SetSkill ( i , j , 10 ) ;
77262: LD_VAR 0 1
77266: PPUSH
77267: LD_VAR 0 3
77271: PPUSH
77272: LD_INT 10
77274: PPUSH
77275: CALL_OW 237
77279: GO 77259
77281: POP
77282: POP
77283: GO 77243
77285: POP
77286: POP
// end ;
77287: PPOPN 3
77289: END
// every 0 0$1 trigger s30 do var i , tmp ;
77290: LD_EXP 153
77294: IFFALSE 77363
77296: GO 77298
77298: DISABLE
77299: LD_INT 0
77301: PPUSH
77302: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
77303: LD_ADDR_VAR 0 2
77307: PUSH
77308: LD_INT 22
77310: PUSH
77311: LD_OWVAR 2
77315: PUSH
77316: EMPTY
77317: LIST
77318: LIST
77319: PPUSH
77320: CALL_OW 69
77324: ST_TO_ADDR
// if not tmp then
77325: LD_VAR 0 2
77329: NOT
77330: IFFALSE 77334
// exit ;
77332: GO 77363
// for i in tmp do
77334: LD_ADDR_VAR 0 1
77338: PUSH
77339: LD_VAR 0 2
77343: PUSH
77344: FOR_IN
77345: IFFALSE 77361
// SetLives ( i , 300 ) ;
77347: LD_VAR 0 1
77351: PPUSH
77352: LD_INT 300
77354: PPUSH
77355: CALL_OW 234
77359: GO 77344
77361: POP
77362: POP
// end ;
77363: PPOPN 2
77365: END
// every 0 0$1 trigger s60 do var i , tmp ;
77366: LD_EXP 154
77370: IFFALSE 77439
77372: GO 77374
77374: DISABLE
77375: LD_INT 0
77377: PPUSH
77378: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
77379: LD_ADDR_VAR 0 2
77383: PUSH
77384: LD_INT 22
77386: PUSH
77387: LD_OWVAR 2
77391: PUSH
77392: EMPTY
77393: LIST
77394: LIST
77395: PPUSH
77396: CALL_OW 69
77400: ST_TO_ADDR
// if not tmp then
77401: LD_VAR 0 2
77405: NOT
77406: IFFALSE 77410
// exit ;
77408: GO 77439
// for i in tmp do
77410: LD_ADDR_VAR 0 1
77414: PUSH
77415: LD_VAR 0 2
77419: PUSH
77420: FOR_IN
77421: IFFALSE 77437
// SetLives ( i , 600 ) ;
77423: LD_VAR 0 1
77427: PPUSH
77428: LD_INT 600
77430: PPUSH
77431: CALL_OW 234
77435: GO 77420
77437: POP
77438: POP
// end ;
77439: PPOPN 2
77441: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
77442: LD_INT 0
77444: PPUSH
// case cmd of 301 :
77445: LD_VAR 0 1
77449: PUSH
77450: LD_INT 301
77452: DOUBLE
77453: EQUAL
77454: IFTRUE 77458
77456: GO 77490
77458: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
77459: LD_VAR 0 6
77463: PPUSH
77464: LD_VAR 0 7
77468: PPUSH
77469: LD_VAR 0 8
77473: PPUSH
77474: LD_VAR 0 4
77478: PPUSH
77479: LD_VAR 0 5
77483: PPUSH
77484: CALL 78691 0 5
77488: GO 77611
77490: LD_INT 302
77492: DOUBLE
77493: EQUAL
77494: IFTRUE 77498
77496: GO 77535
77498: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
77499: LD_VAR 0 6
77503: PPUSH
77504: LD_VAR 0 7
77508: PPUSH
77509: LD_VAR 0 8
77513: PPUSH
77514: LD_VAR 0 9
77518: PPUSH
77519: LD_VAR 0 4
77523: PPUSH
77524: LD_VAR 0 5
77528: PPUSH
77529: CALL 78782 0 6
77533: GO 77611
77535: LD_INT 303
77537: DOUBLE
77538: EQUAL
77539: IFTRUE 77543
77541: GO 77580
77543: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
77544: LD_VAR 0 6
77548: PPUSH
77549: LD_VAR 0 7
77553: PPUSH
77554: LD_VAR 0 8
77558: PPUSH
77559: LD_VAR 0 9
77563: PPUSH
77564: LD_VAR 0 4
77568: PPUSH
77569: LD_VAR 0 5
77573: PPUSH
77574: CALL 77616 0 6
77578: GO 77611
77580: LD_INT 304
77582: DOUBLE
77583: EQUAL
77584: IFTRUE 77588
77586: GO 77610
77588: POP
// hHackTeleport ( unit , x , y ) ; end ;
77589: LD_VAR 0 2
77593: PPUSH
77594: LD_VAR 0 4
77598: PPUSH
77599: LD_VAR 0 5
77603: PPUSH
77604: CALL 79375 0 3
77608: GO 77611
77610: POP
// end ;
77611: LD_VAR 0 12
77615: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
77616: LD_INT 0
77618: PPUSH
77619: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
77620: LD_VAR 0 1
77624: PUSH
77625: LD_INT 1
77627: LESS
77628: PUSH
77629: LD_VAR 0 1
77633: PUSH
77634: LD_INT 3
77636: GREATER
77637: OR
77638: PUSH
77639: LD_VAR 0 5
77643: PPUSH
77644: LD_VAR 0 6
77648: PPUSH
77649: CALL_OW 428
77653: OR
77654: IFFALSE 77658
// exit ;
77656: GO 78378
// uc_side := your_side ;
77658: LD_ADDR_OWVAR 20
77662: PUSH
77663: LD_OWVAR 2
77667: ST_TO_ADDR
// uc_nation := nation ;
77668: LD_ADDR_OWVAR 21
77672: PUSH
77673: LD_VAR 0 1
77677: ST_TO_ADDR
// bc_level = 1 ;
77678: LD_ADDR_OWVAR 43
77682: PUSH
77683: LD_INT 1
77685: ST_TO_ADDR
// case btype of 1 :
77686: LD_VAR 0 2
77690: PUSH
77691: LD_INT 1
77693: DOUBLE
77694: EQUAL
77695: IFTRUE 77699
77697: GO 77710
77699: POP
// bc_type := b_depot ; 2 :
77700: LD_ADDR_OWVAR 42
77704: PUSH
77705: LD_INT 0
77707: ST_TO_ADDR
77708: GO 78322
77710: LD_INT 2
77712: DOUBLE
77713: EQUAL
77714: IFTRUE 77718
77716: GO 77729
77718: POP
// bc_type := b_warehouse ; 3 :
77719: LD_ADDR_OWVAR 42
77723: PUSH
77724: LD_INT 1
77726: ST_TO_ADDR
77727: GO 78322
77729: LD_INT 3
77731: DOUBLE
77732: EQUAL
77733: IFTRUE 77737
77735: GO 77748
77737: POP
// bc_type := b_lab ; 4 .. 9 :
77738: LD_ADDR_OWVAR 42
77742: PUSH
77743: LD_INT 6
77745: ST_TO_ADDR
77746: GO 78322
77748: LD_INT 4
77750: DOUBLE
77751: GREATEREQUAL
77752: IFFALSE 77760
77754: LD_INT 9
77756: DOUBLE
77757: LESSEQUAL
77758: IFTRUE 77762
77760: GO 77814
77762: POP
// begin bc_type := b_lab_half ;
77763: LD_ADDR_OWVAR 42
77767: PUSH
77768: LD_INT 7
77770: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
77771: LD_ADDR_OWVAR 44
77775: PUSH
77776: LD_INT 10
77778: PUSH
77779: LD_INT 11
77781: PUSH
77782: LD_INT 12
77784: PUSH
77785: LD_INT 15
77787: PUSH
77788: LD_INT 14
77790: PUSH
77791: LD_INT 13
77793: PUSH
77794: EMPTY
77795: LIST
77796: LIST
77797: LIST
77798: LIST
77799: LIST
77800: LIST
77801: PUSH
77802: LD_VAR 0 2
77806: PUSH
77807: LD_INT 3
77809: MINUS
77810: ARRAY
77811: ST_TO_ADDR
// end ; 10 .. 13 :
77812: GO 78322
77814: LD_INT 10
77816: DOUBLE
77817: GREATEREQUAL
77818: IFFALSE 77826
77820: LD_INT 13
77822: DOUBLE
77823: LESSEQUAL
77824: IFTRUE 77828
77826: GO 77905
77828: POP
// begin bc_type := b_lab_full ;
77829: LD_ADDR_OWVAR 42
77833: PUSH
77834: LD_INT 8
77836: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
77837: LD_ADDR_OWVAR 44
77841: PUSH
77842: LD_INT 10
77844: PUSH
77845: LD_INT 12
77847: PUSH
77848: LD_INT 14
77850: PUSH
77851: LD_INT 13
77853: PUSH
77854: EMPTY
77855: LIST
77856: LIST
77857: LIST
77858: LIST
77859: PUSH
77860: LD_VAR 0 2
77864: PUSH
77865: LD_INT 9
77867: MINUS
77868: ARRAY
77869: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
77870: LD_ADDR_OWVAR 45
77874: PUSH
77875: LD_INT 11
77877: PUSH
77878: LD_INT 15
77880: PUSH
77881: LD_INT 12
77883: PUSH
77884: LD_INT 15
77886: PUSH
77887: EMPTY
77888: LIST
77889: LIST
77890: LIST
77891: LIST
77892: PUSH
77893: LD_VAR 0 2
77897: PUSH
77898: LD_INT 9
77900: MINUS
77901: ARRAY
77902: ST_TO_ADDR
// end ; 14 :
77903: GO 78322
77905: LD_INT 14
77907: DOUBLE
77908: EQUAL
77909: IFTRUE 77913
77911: GO 77924
77913: POP
// bc_type := b_workshop ; 15 :
77914: LD_ADDR_OWVAR 42
77918: PUSH
77919: LD_INT 2
77921: ST_TO_ADDR
77922: GO 78322
77924: LD_INT 15
77926: DOUBLE
77927: EQUAL
77928: IFTRUE 77932
77930: GO 77943
77932: POP
// bc_type := b_factory ; 16 :
77933: LD_ADDR_OWVAR 42
77937: PUSH
77938: LD_INT 3
77940: ST_TO_ADDR
77941: GO 78322
77943: LD_INT 16
77945: DOUBLE
77946: EQUAL
77947: IFTRUE 77951
77949: GO 77962
77951: POP
// bc_type := b_ext_gun ; 17 :
77952: LD_ADDR_OWVAR 42
77956: PUSH
77957: LD_INT 17
77959: ST_TO_ADDR
77960: GO 78322
77962: LD_INT 17
77964: DOUBLE
77965: EQUAL
77966: IFTRUE 77970
77968: GO 77998
77970: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
77971: LD_ADDR_OWVAR 42
77975: PUSH
77976: LD_INT 19
77978: PUSH
77979: LD_INT 23
77981: PUSH
77982: LD_INT 19
77984: PUSH
77985: EMPTY
77986: LIST
77987: LIST
77988: LIST
77989: PUSH
77990: LD_VAR 0 1
77994: ARRAY
77995: ST_TO_ADDR
77996: GO 78322
77998: LD_INT 18
78000: DOUBLE
78001: EQUAL
78002: IFTRUE 78006
78004: GO 78017
78006: POP
// bc_type := b_ext_radar ; 19 :
78007: LD_ADDR_OWVAR 42
78011: PUSH
78012: LD_INT 20
78014: ST_TO_ADDR
78015: GO 78322
78017: LD_INT 19
78019: DOUBLE
78020: EQUAL
78021: IFTRUE 78025
78023: GO 78036
78025: POP
// bc_type := b_ext_radio ; 20 :
78026: LD_ADDR_OWVAR 42
78030: PUSH
78031: LD_INT 22
78033: ST_TO_ADDR
78034: GO 78322
78036: LD_INT 20
78038: DOUBLE
78039: EQUAL
78040: IFTRUE 78044
78042: GO 78055
78044: POP
// bc_type := b_ext_siberium ; 21 :
78045: LD_ADDR_OWVAR 42
78049: PUSH
78050: LD_INT 21
78052: ST_TO_ADDR
78053: GO 78322
78055: LD_INT 21
78057: DOUBLE
78058: EQUAL
78059: IFTRUE 78063
78061: GO 78074
78063: POP
// bc_type := b_ext_computer ; 22 :
78064: LD_ADDR_OWVAR 42
78068: PUSH
78069: LD_INT 24
78071: ST_TO_ADDR
78072: GO 78322
78074: LD_INT 22
78076: DOUBLE
78077: EQUAL
78078: IFTRUE 78082
78080: GO 78093
78082: POP
// bc_type := b_ext_track ; 23 :
78083: LD_ADDR_OWVAR 42
78087: PUSH
78088: LD_INT 16
78090: ST_TO_ADDR
78091: GO 78322
78093: LD_INT 23
78095: DOUBLE
78096: EQUAL
78097: IFTRUE 78101
78099: GO 78112
78101: POP
// bc_type := b_ext_laser ; 24 :
78102: LD_ADDR_OWVAR 42
78106: PUSH
78107: LD_INT 25
78109: ST_TO_ADDR
78110: GO 78322
78112: LD_INT 24
78114: DOUBLE
78115: EQUAL
78116: IFTRUE 78120
78118: GO 78131
78120: POP
// bc_type := b_control_tower ; 25 :
78121: LD_ADDR_OWVAR 42
78125: PUSH
78126: LD_INT 36
78128: ST_TO_ADDR
78129: GO 78322
78131: LD_INT 25
78133: DOUBLE
78134: EQUAL
78135: IFTRUE 78139
78137: GO 78150
78139: POP
// bc_type := b_breastwork ; 26 :
78140: LD_ADDR_OWVAR 42
78144: PUSH
78145: LD_INT 31
78147: ST_TO_ADDR
78148: GO 78322
78150: LD_INT 26
78152: DOUBLE
78153: EQUAL
78154: IFTRUE 78158
78156: GO 78169
78158: POP
// bc_type := b_bunker ; 27 :
78159: LD_ADDR_OWVAR 42
78163: PUSH
78164: LD_INT 32
78166: ST_TO_ADDR
78167: GO 78322
78169: LD_INT 27
78171: DOUBLE
78172: EQUAL
78173: IFTRUE 78177
78175: GO 78188
78177: POP
// bc_type := b_turret ; 28 :
78178: LD_ADDR_OWVAR 42
78182: PUSH
78183: LD_INT 33
78185: ST_TO_ADDR
78186: GO 78322
78188: LD_INT 28
78190: DOUBLE
78191: EQUAL
78192: IFTRUE 78196
78194: GO 78207
78196: POP
// bc_type := b_armoury ; 29 :
78197: LD_ADDR_OWVAR 42
78201: PUSH
78202: LD_INT 4
78204: ST_TO_ADDR
78205: GO 78322
78207: LD_INT 29
78209: DOUBLE
78210: EQUAL
78211: IFTRUE 78215
78213: GO 78226
78215: POP
// bc_type := b_barracks ; 30 :
78216: LD_ADDR_OWVAR 42
78220: PUSH
78221: LD_INT 5
78223: ST_TO_ADDR
78224: GO 78322
78226: LD_INT 30
78228: DOUBLE
78229: EQUAL
78230: IFTRUE 78234
78232: GO 78245
78234: POP
// bc_type := b_solar_power ; 31 :
78235: LD_ADDR_OWVAR 42
78239: PUSH
78240: LD_INT 27
78242: ST_TO_ADDR
78243: GO 78322
78245: LD_INT 31
78247: DOUBLE
78248: EQUAL
78249: IFTRUE 78253
78251: GO 78264
78253: POP
// bc_type := b_oil_power ; 32 :
78254: LD_ADDR_OWVAR 42
78258: PUSH
78259: LD_INT 26
78261: ST_TO_ADDR
78262: GO 78322
78264: LD_INT 32
78266: DOUBLE
78267: EQUAL
78268: IFTRUE 78272
78270: GO 78283
78272: POP
// bc_type := b_siberite_power ; 33 :
78273: LD_ADDR_OWVAR 42
78277: PUSH
78278: LD_INT 28
78280: ST_TO_ADDR
78281: GO 78322
78283: LD_INT 33
78285: DOUBLE
78286: EQUAL
78287: IFTRUE 78291
78289: GO 78302
78291: POP
// bc_type := b_oil_mine ; 34 :
78292: LD_ADDR_OWVAR 42
78296: PUSH
78297: LD_INT 29
78299: ST_TO_ADDR
78300: GO 78322
78302: LD_INT 34
78304: DOUBLE
78305: EQUAL
78306: IFTRUE 78310
78308: GO 78321
78310: POP
// bc_type := b_siberite_mine ; end ;
78311: LD_ADDR_OWVAR 42
78315: PUSH
78316: LD_INT 30
78318: ST_TO_ADDR
78319: GO 78322
78321: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
78322: LD_ADDR_VAR 0 8
78326: PUSH
78327: LD_VAR 0 5
78331: PPUSH
78332: LD_VAR 0 6
78336: PPUSH
78337: LD_VAR 0 3
78341: PPUSH
78342: CALL_OW 47
78346: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
78347: LD_OWVAR 42
78351: PUSH
78352: LD_INT 32
78354: PUSH
78355: LD_INT 33
78357: PUSH
78358: EMPTY
78359: LIST
78360: LIST
78361: IN
78362: IFFALSE 78378
// PlaceWeaponTurret ( b , weapon ) ;
78364: LD_VAR 0 8
78368: PPUSH
78369: LD_VAR 0 4
78373: PPUSH
78374: CALL_OW 431
// end ;
78378: LD_VAR 0 7
78382: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
78383: LD_INT 0
78385: PPUSH
78386: PPUSH
78387: PPUSH
78388: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
78389: LD_ADDR_VAR 0 4
78393: PUSH
78394: LD_INT 22
78396: PUSH
78397: LD_OWVAR 2
78401: PUSH
78402: EMPTY
78403: LIST
78404: LIST
78405: PUSH
78406: LD_INT 2
78408: PUSH
78409: LD_INT 30
78411: PUSH
78412: LD_INT 0
78414: PUSH
78415: EMPTY
78416: LIST
78417: LIST
78418: PUSH
78419: LD_INT 30
78421: PUSH
78422: LD_INT 1
78424: PUSH
78425: EMPTY
78426: LIST
78427: LIST
78428: PUSH
78429: EMPTY
78430: LIST
78431: LIST
78432: LIST
78433: PUSH
78434: EMPTY
78435: LIST
78436: LIST
78437: PPUSH
78438: CALL_OW 69
78442: ST_TO_ADDR
// if not tmp then
78443: LD_VAR 0 4
78447: NOT
78448: IFFALSE 78452
// exit ;
78450: GO 78511
// for i in tmp do
78452: LD_ADDR_VAR 0 2
78456: PUSH
78457: LD_VAR 0 4
78461: PUSH
78462: FOR_IN
78463: IFFALSE 78509
// for j = 1 to 3 do
78465: LD_ADDR_VAR 0 3
78469: PUSH
78470: DOUBLE
78471: LD_INT 1
78473: DEC
78474: ST_TO_ADDR
78475: LD_INT 3
78477: PUSH
78478: FOR_TO
78479: IFFALSE 78505
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
78481: LD_VAR 0 2
78485: PPUSH
78486: CALL_OW 274
78490: PPUSH
78491: LD_VAR 0 3
78495: PPUSH
78496: LD_INT 99999
78498: PPUSH
78499: CALL_OW 277
78503: GO 78478
78505: POP
78506: POP
78507: GO 78462
78509: POP
78510: POP
// end ;
78511: LD_VAR 0 1
78515: RET
// export function hHackSetLevel10 ; var i , j ; begin
78516: LD_INT 0
78518: PPUSH
78519: PPUSH
78520: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
78521: LD_ADDR_VAR 0 2
78525: PUSH
78526: LD_INT 21
78528: PUSH
78529: LD_INT 1
78531: PUSH
78532: EMPTY
78533: LIST
78534: LIST
78535: PPUSH
78536: CALL_OW 69
78540: PUSH
78541: FOR_IN
78542: IFFALSE 78594
// if IsSelected ( i ) then
78544: LD_VAR 0 2
78548: PPUSH
78549: CALL_OW 306
78553: IFFALSE 78592
// begin for j := 1 to 4 do
78555: LD_ADDR_VAR 0 3
78559: PUSH
78560: DOUBLE
78561: LD_INT 1
78563: DEC
78564: ST_TO_ADDR
78565: LD_INT 4
78567: PUSH
78568: FOR_TO
78569: IFFALSE 78590
// SetSkill ( i , j , 10 ) ;
78571: LD_VAR 0 2
78575: PPUSH
78576: LD_VAR 0 3
78580: PPUSH
78581: LD_INT 10
78583: PPUSH
78584: CALL_OW 237
78588: GO 78568
78590: POP
78591: POP
// end ;
78592: GO 78541
78594: POP
78595: POP
// end ;
78596: LD_VAR 0 1
78600: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
78601: LD_INT 0
78603: PPUSH
78604: PPUSH
78605: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
78606: LD_ADDR_VAR 0 2
78610: PUSH
78611: LD_INT 22
78613: PUSH
78614: LD_OWVAR 2
78618: PUSH
78619: EMPTY
78620: LIST
78621: LIST
78622: PUSH
78623: LD_INT 21
78625: PUSH
78626: LD_INT 1
78628: PUSH
78629: EMPTY
78630: LIST
78631: LIST
78632: PUSH
78633: EMPTY
78634: LIST
78635: LIST
78636: PPUSH
78637: CALL_OW 69
78641: PUSH
78642: FOR_IN
78643: IFFALSE 78684
// begin for j := 1 to 4 do
78645: LD_ADDR_VAR 0 3
78649: PUSH
78650: DOUBLE
78651: LD_INT 1
78653: DEC
78654: ST_TO_ADDR
78655: LD_INT 4
78657: PUSH
78658: FOR_TO
78659: IFFALSE 78680
// SetSkill ( i , j , 10 ) ;
78661: LD_VAR 0 2
78665: PPUSH
78666: LD_VAR 0 3
78670: PPUSH
78671: LD_INT 10
78673: PPUSH
78674: CALL_OW 237
78678: GO 78658
78680: POP
78681: POP
// end ;
78682: GO 78642
78684: POP
78685: POP
// end ;
78686: LD_VAR 0 1
78690: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
78691: LD_INT 0
78693: PPUSH
// uc_side := your_side ;
78694: LD_ADDR_OWVAR 20
78698: PUSH
78699: LD_OWVAR 2
78703: ST_TO_ADDR
// uc_nation := nation ;
78704: LD_ADDR_OWVAR 21
78708: PUSH
78709: LD_VAR 0 1
78713: ST_TO_ADDR
// InitHc ;
78714: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
78718: LD_INT 0
78720: PPUSH
78721: LD_VAR 0 2
78725: PPUSH
78726: LD_VAR 0 3
78730: PPUSH
78731: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
78735: LD_VAR 0 4
78739: PPUSH
78740: LD_VAR 0 5
78744: PPUSH
78745: CALL_OW 428
78749: PUSH
78750: LD_INT 0
78752: EQUAL
78753: IFFALSE 78777
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
78755: CALL_OW 44
78759: PPUSH
78760: LD_VAR 0 4
78764: PPUSH
78765: LD_VAR 0 5
78769: PPUSH
78770: LD_INT 1
78772: PPUSH
78773: CALL_OW 48
// end ;
78777: LD_VAR 0 6
78781: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
78782: LD_INT 0
78784: PPUSH
78785: PPUSH
// uc_side := your_side ;
78786: LD_ADDR_OWVAR 20
78790: PUSH
78791: LD_OWVAR 2
78795: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
78796: LD_VAR 0 1
78800: PUSH
78801: LD_INT 1
78803: PUSH
78804: LD_INT 2
78806: PUSH
78807: LD_INT 3
78809: PUSH
78810: LD_INT 4
78812: PUSH
78813: LD_INT 5
78815: PUSH
78816: EMPTY
78817: LIST
78818: LIST
78819: LIST
78820: LIST
78821: LIST
78822: IN
78823: IFFALSE 78835
// uc_nation := nation_american else
78825: LD_ADDR_OWVAR 21
78829: PUSH
78830: LD_INT 1
78832: ST_TO_ADDR
78833: GO 78878
// if chassis in [ 11 , 12 , 13 , 14 ] then
78835: LD_VAR 0 1
78839: PUSH
78840: LD_INT 11
78842: PUSH
78843: LD_INT 12
78845: PUSH
78846: LD_INT 13
78848: PUSH
78849: LD_INT 14
78851: PUSH
78852: EMPTY
78853: LIST
78854: LIST
78855: LIST
78856: LIST
78857: IN
78858: IFFALSE 78870
// uc_nation := nation_arabian else
78860: LD_ADDR_OWVAR 21
78864: PUSH
78865: LD_INT 2
78867: ST_TO_ADDR
78868: GO 78878
// uc_nation := nation_russian ;
78870: LD_ADDR_OWVAR 21
78874: PUSH
78875: LD_INT 3
78877: ST_TO_ADDR
// vc_chassis := chassis ;
78878: LD_ADDR_OWVAR 37
78882: PUSH
78883: LD_VAR 0 1
78887: ST_TO_ADDR
// vc_engine := engine ;
78888: LD_ADDR_OWVAR 39
78892: PUSH
78893: LD_VAR 0 2
78897: ST_TO_ADDR
// vc_control := control ;
78898: LD_ADDR_OWVAR 38
78902: PUSH
78903: LD_VAR 0 3
78907: ST_TO_ADDR
// vc_weapon := weapon ;
78908: LD_ADDR_OWVAR 40
78912: PUSH
78913: LD_VAR 0 4
78917: ST_TO_ADDR
// un := CreateVehicle ;
78918: LD_ADDR_VAR 0 8
78922: PUSH
78923: CALL_OW 45
78927: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
78928: LD_VAR 0 8
78932: PPUSH
78933: LD_INT 0
78935: PPUSH
78936: LD_INT 5
78938: PPUSH
78939: CALL_OW 12
78943: PPUSH
78944: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
78948: LD_VAR 0 8
78952: PPUSH
78953: LD_VAR 0 5
78957: PPUSH
78958: LD_VAR 0 6
78962: PPUSH
78963: LD_INT 1
78965: PPUSH
78966: CALL_OW 48
// end ;
78970: LD_VAR 0 7
78974: RET
// export hInvincible ; every 1 do
78975: GO 78977
78977: DISABLE
// hInvincible := [ ] ;
78978: LD_ADDR_EXP 155
78982: PUSH
78983: EMPTY
78984: ST_TO_ADDR
78985: END
// every 10 do var i ;
78986: GO 78988
78988: DISABLE
78989: LD_INT 0
78991: PPUSH
// begin enable ;
78992: ENABLE
// if not hInvincible then
78993: LD_EXP 155
78997: NOT
78998: IFFALSE 79002
// exit ;
79000: GO 79046
// for i in hInvincible do
79002: LD_ADDR_VAR 0 1
79006: PUSH
79007: LD_EXP 155
79011: PUSH
79012: FOR_IN
79013: IFFALSE 79044
// if GetLives ( i ) < 1000 then
79015: LD_VAR 0 1
79019: PPUSH
79020: CALL_OW 256
79024: PUSH
79025: LD_INT 1000
79027: LESS
79028: IFFALSE 79042
// SetLives ( i , 1000 ) ;
79030: LD_VAR 0 1
79034: PPUSH
79035: LD_INT 1000
79037: PPUSH
79038: CALL_OW 234
79042: GO 79012
79044: POP
79045: POP
// end ;
79046: PPOPN 1
79048: END
// export function hHackInvincible ; var i ; begin
79049: LD_INT 0
79051: PPUSH
79052: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
79053: LD_ADDR_VAR 0 2
79057: PUSH
79058: LD_INT 2
79060: PUSH
79061: LD_INT 21
79063: PUSH
79064: LD_INT 1
79066: PUSH
79067: EMPTY
79068: LIST
79069: LIST
79070: PUSH
79071: LD_INT 21
79073: PUSH
79074: LD_INT 2
79076: PUSH
79077: EMPTY
79078: LIST
79079: LIST
79080: PUSH
79081: EMPTY
79082: LIST
79083: LIST
79084: LIST
79085: PPUSH
79086: CALL_OW 69
79090: PUSH
79091: FOR_IN
79092: IFFALSE 79153
// if IsSelected ( i ) then
79094: LD_VAR 0 2
79098: PPUSH
79099: CALL_OW 306
79103: IFFALSE 79151
// begin if i in hInvincible then
79105: LD_VAR 0 2
79109: PUSH
79110: LD_EXP 155
79114: IN
79115: IFFALSE 79135
// hInvincible := hInvincible diff i else
79117: LD_ADDR_EXP 155
79121: PUSH
79122: LD_EXP 155
79126: PUSH
79127: LD_VAR 0 2
79131: DIFF
79132: ST_TO_ADDR
79133: GO 79151
// hInvincible := hInvincible union i ;
79135: LD_ADDR_EXP 155
79139: PUSH
79140: LD_EXP 155
79144: PUSH
79145: LD_VAR 0 2
79149: UNION
79150: ST_TO_ADDR
// end ;
79151: GO 79091
79153: POP
79154: POP
// end ;
79155: LD_VAR 0 1
79159: RET
// export function hHackInvisible ; var i , j ; begin
79160: LD_INT 0
79162: PPUSH
79163: PPUSH
79164: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
79165: LD_ADDR_VAR 0 2
79169: PUSH
79170: LD_INT 21
79172: PUSH
79173: LD_INT 1
79175: PUSH
79176: EMPTY
79177: LIST
79178: LIST
79179: PPUSH
79180: CALL_OW 69
79184: PUSH
79185: FOR_IN
79186: IFFALSE 79210
// if IsSelected ( i ) then
79188: LD_VAR 0 2
79192: PPUSH
79193: CALL_OW 306
79197: IFFALSE 79208
// ComForceInvisible ( i ) ;
79199: LD_VAR 0 2
79203: PPUSH
79204: CALL_OW 496
79208: GO 79185
79210: POP
79211: POP
// end ;
79212: LD_VAR 0 1
79216: RET
// export function hHackChangeYourSide ; begin
79217: LD_INT 0
79219: PPUSH
// if your_side = 8 then
79220: LD_OWVAR 2
79224: PUSH
79225: LD_INT 8
79227: EQUAL
79228: IFFALSE 79240
// your_side := 0 else
79230: LD_ADDR_OWVAR 2
79234: PUSH
79235: LD_INT 0
79237: ST_TO_ADDR
79238: GO 79254
// your_side := your_side + 1 ;
79240: LD_ADDR_OWVAR 2
79244: PUSH
79245: LD_OWVAR 2
79249: PUSH
79250: LD_INT 1
79252: PLUS
79253: ST_TO_ADDR
// end ;
79254: LD_VAR 0 1
79258: RET
// export function hHackChangeUnitSide ; var i , j ; begin
79259: LD_INT 0
79261: PPUSH
79262: PPUSH
79263: PPUSH
// for i in all_units do
79264: LD_ADDR_VAR 0 2
79268: PUSH
79269: LD_OWVAR 3
79273: PUSH
79274: FOR_IN
79275: IFFALSE 79353
// if IsSelected ( i ) then
79277: LD_VAR 0 2
79281: PPUSH
79282: CALL_OW 306
79286: IFFALSE 79351
// begin j := GetSide ( i ) ;
79288: LD_ADDR_VAR 0 3
79292: PUSH
79293: LD_VAR 0 2
79297: PPUSH
79298: CALL_OW 255
79302: ST_TO_ADDR
// if j = 8 then
79303: LD_VAR 0 3
79307: PUSH
79308: LD_INT 8
79310: EQUAL
79311: IFFALSE 79323
// j := 0 else
79313: LD_ADDR_VAR 0 3
79317: PUSH
79318: LD_INT 0
79320: ST_TO_ADDR
79321: GO 79337
// j := j + 1 ;
79323: LD_ADDR_VAR 0 3
79327: PUSH
79328: LD_VAR 0 3
79332: PUSH
79333: LD_INT 1
79335: PLUS
79336: ST_TO_ADDR
// SetSide ( i , j ) ;
79337: LD_VAR 0 2
79341: PPUSH
79342: LD_VAR 0 3
79346: PPUSH
79347: CALL_OW 235
// end ;
79351: GO 79274
79353: POP
79354: POP
// end ;
79355: LD_VAR 0 1
79359: RET
// export function hHackFog ; begin
79360: LD_INT 0
79362: PPUSH
// FogOff ( true ) ;
79363: LD_INT 1
79365: PPUSH
79366: CALL_OW 344
// end ;
79370: LD_VAR 0 1
79374: RET
// export function hHackTeleport ( unit , x , y ) ; begin
79375: LD_INT 0
79377: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
79378: LD_VAR 0 1
79382: PPUSH
79383: LD_VAR 0 2
79387: PPUSH
79388: LD_VAR 0 3
79392: PPUSH
79393: LD_INT 1
79395: PPUSH
79396: LD_INT 1
79398: PPUSH
79399: CALL_OW 483
// CenterOnXY ( x , y ) ;
79403: LD_VAR 0 2
79407: PPUSH
79408: LD_VAR 0 3
79412: PPUSH
79413: CALL_OW 84
// end ;
79417: LD_VAR 0 4
79421: RET
// export factoryWaypoints ; export function SetFactoryWaypoint ( factory , x , y ) ; var i ; begin
79422: LD_INT 0
79424: PPUSH
79425: PPUSH
// if not factory or not ValidHex ( x , y ) or ( GetBType ( factory ) <> b_factory and not GetType ( factory ) = unit_human ) then
79426: LD_VAR 0 1
79430: NOT
79431: PUSH
79432: LD_VAR 0 2
79436: PPUSH
79437: LD_VAR 0 3
79441: PPUSH
79442: CALL_OW 488
79446: NOT
79447: OR
79448: PUSH
79449: LD_VAR 0 1
79453: PPUSH
79454: CALL_OW 266
79458: PUSH
79459: LD_INT 3
79461: NONEQUAL
79462: PUSH
79463: LD_VAR 0 1
79467: PPUSH
79468: CALL_OW 247
79472: PUSH
79473: LD_INT 1
79475: EQUAL
79476: NOT
79477: AND
79478: OR
79479: IFFALSE 79483
// exit ;
79481: GO 79632
// if GetType ( factory ) = unit_human then
79483: LD_VAR 0 1
79487: PPUSH
79488: CALL_OW 247
79492: PUSH
79493: LD_INT 1
79495: EQUAL
79496: IFFALSE 79513
// factory := IsInUnit ( factory ) ;
79498: LD_ADDR_VAR 0 1
79502: PUSH
79503: LD_VAR 0 1
79507: PPUSH
79508: CALL_OW 310
79512: ST_TO_ADDR
// if GetBType ( factory ) <> b_factory then
79513: LD_VAR 0 1
79517: PPUSH
79518: CALL_OW 266
79522: PUSH
79523: LD_INT 3
79525: NONEQUAL
79526: IFFALSE 79530
// exit ;
79528: GO 79632
// if HexInfo ( x , y ) = factory then
79530: LD_VAR 0 2
79534: PPUSH
79535: LD_VAR 0 3
79539: PPUSH
79540: CALL_OW 428
79544: PUSH
79545: LD_VAR 0 1
79549: EQUAL
79550: IFFALSE 79577
// factoryWaypoints := Replace ( factoryWaypoints , factory , 0 ) else
79552: LD_ADDR_EXP 156
79556: PUSH
79557: LD_EXP 156
79561: PPUSH
79562: LD_VAR 0 1
79566: PPUSH
79567: LD_INT 0
79569: PPUSH
79570: CALL_OW 1
79574: ST_TO_ADDR
79575: GO 79628
// factoryWaypoints := Replace ( factoryWaypoints , factory , [ GetSide ( factory ) , factory , x , y ] ) ;
79577: LD_ADDR_EXP 156
79581: PUSH
79582: LD_EXP 156
79586: PPUSH
79587: LD_VAR 0 1
79591: PPUSH
79592: LD_VAR 0 1
79596: PPUSH
79597: CALL_OW 255
79601: PUSH
79602: LD_VAR 0 1
79606: PUSH
79607: LD_VAR 0 2
79611: PUSH
79612: LD_VAR 0 3
79616: PUSH
79617: EMPTY
79618: LIST
79619: LIST
79620: LIST
79621: LIST
79622: PPUSH
79623: CALL_OW 1
79627: ST_TO_ADDR
// UpdateFactoryWaypoints ;
79628: CALL 79637 0 0
// end ;
79632: LD_VAR 0 4
79636: RET
// export function UpdateFactoryWaypoints ( ) ; var i , list ; begin
79637: LD_INT 0
79639: PPUSH
79640: PPUSH
79641: PPUSH
// ToLua ( resetFactoryWaypoint(); ) ;
79642: LD_STRING resetFactoryWaypoint();
79644: PPUSH
79645: CALL_OW 559
// if factoryWaypoints then
79649: LD_EXP 156
79653: IFFALSE 79779
// begin list := PrepareArray ( factoryWaypoints ) ;
79655: LD_ADDR_VAR 0 3
79659: PUSH
79660: LD_EXP 156
79664: PPUSH
79665: CALL 60450 0 1
79669: ST_TO_ADDR
// for i := 1 to list do
79670: LD_ADDR_VAR 0 2
79674: PUSH
79675: DOUBLE
79676: LD_INT 1
79678: DEC
79679: ST_TO_ADDR
79680: LD_VAR 0 3
79684: PUSH
79685: FOR_TO
79686: IFFALSE 79777
// ToLua ( setFactoryWaypointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
79688: LD_STRING setFactoryWaypointXY(
79690: PUSH
79691: LD_VAR 0 3
79695: PUSH
79696: LD_VAR 0 2
79700: ARRAY
79701: PUSH
79702: LD_INT 1
79704: ARRAY
79705: STR
79706: PUSH
79707: LD_STRING ,
79709: STR
79710: PUSH
79711: LD_VAR 0 3
79715: PUSH
79716: LD_VAR 0 2
79720: ARRAY
79721: PUSH
79722: LD_INT 2
79724: ARRAY
79725: STR
79726: PUSH
79727: LD_STRING ,
79729: STR
79730: PUSH
79731: LD_VAR 0 3
79735: PUSH
79736: LD_VAR 0 2
79740: ARRAY
79741: PUSH
79742: LD_INT 3
79744: ARRAY
79745: STR
79746: PUSH
79747: LD_STRING ,
79749: STR
79750: PUSH
79751: LD_VAR 0 3
79755: PUSH
79756: LD_VAR 0 2
79760: ARRAY
79761: PUSH
79762: LD_INT 4
79764: ARRAY
79765: STR
79766: PUSH
79767: LD_STRING )
79769: STR
79770: PPUSH
79771: CALL_OW 559
79775: GO 79685
79777: POP
79778: POP
// end ; end ;
79779: LD_VAR 0 1
79783: RET
// export warehouseGatheringPoints , warehouseCratesCollectors ; export function SetWarehouseGatheringPoint ( warehouse , x , y ) ; begin
79784: LD_INT 0
79786: PPUSH
// if HexInfo ( x , y ) = warehouse then
79787: LD_VAR 0 2
79791: PPUSH
79792: LD_VAR 0 3
79796: PPUSH
79797: CALL_OW 428
79801: PUSH
79802: LD_VAR 0 1
79806: EQUAL
79807: IFFALSE 79834
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , 0 ) else
79809: LD_ADDR_EXP 157
79813: PUSH
79814: LD_EXP 157
79818: PPUSH
79819: LD_VAR 0 1
79823: PPUSH
79824: LD_INT 0
79826: PPUSH
79827: CALL_OW 1
79831: ST_TO_ADDR
79832: GO 79885
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , [ GetSide ( warehouse ) , warehouse , x , y ] ) ;
79834: LD_ADDR_EXP 157
79838: PUSH
79839: LD_EXP 157
79843: PPUSH
79844: LD_VAR 0 1
79848: PPUSH
79849: LD_VAR 0 1
79853: PPUSH
79854: CALL_OW 255
79858: PUSH
79859: LD_VAR 0 1
79863: PUSH
79864: LD_VAR 0 2
79868: PUSH
79869: LD_VAR 0 3
79873: PUSH
79874: EMPTY
79875: LIST
79876: LIST
79877: LIST
79878: LIST
79879: PPUSH
79880: CALL_OW 1
79884: ST_TO_ADDR
// UpdateWarehouseGatheringPoints ;
79885: CALL 79894 0 0
// end ;
79889: LD_VAR 0 4
79893: RET
// export function UpdateWarehouseGatheringPoints ( ) ; var i , list ; begin
79894: LD_INT 0
79896: PPUSH
79897: PPUSH
79898: PPUSH
// ToLua ( resetWarehouseGatheringPoints(); ) ;
79899: LD_STRING resetWarehouseGatheringPoints();
79901: PPUSH
79902: CALL_OW 559
// if warehouseGatheringPoints then
79906: LD_EXP 157
79910: IFFALSE 80036
// begin list := PrepareArray ( warehouseGatheringPoints ) ;
79912: LD_ADDR_VAR 0 3
79916: PUSH
79917: LD_EXP 157
79921: PPUSH
79922: CALL 60450 0 1
79926: ST_TO_ADDR
// for i := 1 to list do
79927: LD_ADDR_VAR 0 2
79931: PUSH
79932: DOUBLE
79933: LD_INT 1
79935: DEC
79936: ST_TO_ADDR
79937: LD_VAR 0 3
79941: PUSH
79942: FOR_TO
79943: IFFALSE 80034
// ToLua ( setWarehouseGatheringPointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
79945: LD_STRING setWarehouseGatheringPointXY(
79947: PUSH
79948: LD_VAR 0 3
79952: PUSH
79953: LD_VAR 0 2
79957: ARRAY
79958: PUSH
79959: LD_INT 1
79961: ARRAY
79962: STR
79963: PUSH
79964: LD_STRING ,
79966: STR
79967: PUSH
79968: LD_VAR 0 3
79972: PUSH
79973: LD_VAR 0 2
79977: ARRAY
79978: PUSH
79979: LD_INT 2
79981: ARRAY
79982: STR
79983: PUSH
79984: LD_STRING ,
79986: STR
79987: PUSH
79988: LD_VAR 0 3
79992: PUSH
79993: LD_VAR 0 2
79997: ARRAY
79998: PUSH
79999: LD_INT 3
80001: ARRAY
80002: STR
80003: PUSH
80004: LD_STRING ,
80006: STR
80007: PUSH
80008: LD_VAR 0 3
80012: PUSH
80013: LD_VAR 0 2
80017: ARRAY
80018: PUSH
80019: LD_INT 4
80021: ARRAY
80022: STR
80023: PUSH
80024: LD_STRING )
80026: STR
80027: PPUSH
80028: CALL_OW 559
80032: GO 79942
80034: POP
80035: POP
// end ; end ;
80036: LD_VAR 0 1
80040: RET
// every 0 0$20 trigger warehouseGatheringPoints do var i , j , list , tmp , side , x , y , depot , cratesNearbyPoint ;
80041: LD_EXP 157
80045: IFFALSE 80730
80047: GO 80049
80049: DISABLE
80050: LD_INT 0
80052: PPUSH
80053: PPUSH
80054: PPUSH
80055: PPUSH
80056: PPUSH
80057: PPUSH
80058: PPUSH
80059: PPUSH
80060: PPUSH
// begin enable ;
80061: ENABLE
// list := PrepareArray ( warehouseGatheringPoints ) ;
80062: LD_ADDR_VAR 0 3
80066: PUSH
80067: LD_EXP 157
80071: PPUSH
80072: CALL 60450 0 1
80076: ST_TO_ADDR
// if not list then
80077: LD_VAR 0 3
80081: NOT
80082: IFFALSE 80086
// exit ;
80084: GO 80730
// for i := 1 to list do
80086: LD_ADDR_VAR 0 1
80090: PUSH
80091: DOUBLE
80092: LD_INT 1
80094: DEC
80095: ST_TO_ADDR
80096: LD_VAR 0 3
80100: PUSH
80101: FOR_TO
80102: IFFALSE 80728
// begin depot := list [ i ] [ 2 ] ;
80104: LD_ADDR_VAR 0 8
80108: PUSH
80109: LD_VAR 0 3
80113: PUSH
80114: LD_VAR 0 1
80118: ARRAY
80119: PUSH
80120: LD_INT 2
80122: ARRAY
80123: ST_TO_ADDR
// side := list [ i ] [ 1 ] ;
80124: LD_ADDR_VAR 0 5
80128: PUSH
80129: LD_VAR 0 3
80133: PUSH
80134: LD_VAR 0 1
80138: ARRAY
80139: PUSH
80140: LD_INT 1
80142: ARRAY
80143: ST_TO_ADDR
// if IsDead ( depot ) or side <> GetSide ( depot ) then
80144: LD_VAR 0 8
80148: PPUSH
80149: CALL_OW 301
80153: PUSH
80154: LD_VAR 0 5
80158: PUSH
80159: LD_VAR 0 8
80163: PPUSH
80164: CALL_OW 255
80168: NONEQUAL
80169: OR
80170: IFFALSE 80199
// begin warehouseGatheringPoints := Replace ( warehouseGatheringPoints , depot , 0 ) ;
80172: LD_ADDR_EXP 157
80176: PUSH
80177: LD_EXP 157
80181: PPUSH
80182: LD_VAR 0 8
80186: PPUSH
80187: LD_INT 0
80189: PPUSH
80190: CALL_OW 1
80194: ST_TO_ADDR
// exit ;
80195: POP
80196: POP
80197: GO 80730
// end ; x := list [ i ] [ 3 ] ;
80199: LD_ADDR_VAR 0 6
80203: PUSH
80204: LD_VAR 0 3
80208: PUSH
80209: LD_VAR 0 1
80213: ARRAY
80214: PUSH
80215: LD_INT 3
80217: ARRAY
80218: ST_TO_ADDR
// y := list [ i ] [ 4 ] ;
80219: LD_ADDR_VAR 0 7
80223: PUSH
80224: LD_VAR 0 3
80228: PUSH
80229: LD_VAR 0 1
80233: ARRAY
80234: PUSH
80235: LD_INT 4
80237: ARRAY
80238: ST_TO_ADDR
// cratesNearbyPoint := GetCratesNearbyXY ( x , y , 16 ) ;
80239: LD_ADDR_VAR 0 9
80243: PUSH
80244: LD_VAR 0 6
80248: PPUSH
80249: LD_VAR 0 7
80253: PPUSH
80254: LD_INT 16
80256: PPUSH
80257: CALL 59038 0 3
80261: ST_TO_ADDR
// if not cratesNearbyPoint then
80262: LD_VAR 0 9
80266: NOT
80267: IFFALSE 80273
// exit ;
80269: POP
80270: POP
80271: GO 80730
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_hastask ] ] , [ f_dist , depot , 6 ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) union UnitFilter ( UnitsInside ( depot ) , [ [ f_not , [ f_hastask ] ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) ;
80273: LD_ADDR_VAR 0 4
80277: PUSH
80278: LD_INT 22
80280: PUSH
80281: LD_VAR 0 5
80285: PUSH
80286: EMPTY
80287: LIST
80288: LIST
80289: PUSH
80290: LD_INT 3
80292: PUSH
80293: LD_INT 60
80295: PUSH
80296: EMPTY
80297: LIST
80298: PUSH
80299: EMPTY
80300: LIST
80301: LIST
80302: PUSH
80303: LD_INT 91
80305: PUSH
80306: LD_VAR 0 8
80310: PUSH
80311: LD_INT 6
80313: PUSH
80314: EMPTY
80315: LIST
80316: LIST
80317: LIST
80318: PUSH
80319: LD_INT 2
80321: PUSH
80322: LD_INT 25
80324: PUSH
80325: LD_INT 2
80327: PUSH
80328: EMPTY
80329: LIST
80330: LIST
80331: PUSH
80332: LD_INT 25
80334: PUSH
80335: LD_INT 16
80337: PUSH
80338: EMPTY
80339: LIST
80340: LIST
80341: PUSH
80342: EMPTY
80343: LIST
80344: LIST
80345: LIST
80346: PUSH
80347: EMPTY
80348: LIST
80349: LIST
80350: LIST
80351: LIST
80352: PPUSH
80353: CALL_OW 69
80357: PUSH
80358: LD_VAR 0 8
80362: PPUSH
80363: CALL_OW 313
80367: PPUSH
80368: LD_INT 3
80370: PUSH
80371: LD_INT 60
80373: PUSH
80374: EMPTY
80375: LIST
80376: PUSH
80377: EMPTY
80378: LIST
80379: LIST
80380: PUSH
80381: LD_INT 2
80383: PUSH
80384: LD_INT 25
80386: PUSH
80387: LD_INT 2
80389: PUSH
80390: EMPTY
80391: LIST
80392: LIST
80393: PUSH
80394: LD_INT 25
80396: PUSH
80397: LD_INT 16
80399: PUSH
80400: EMPTY
80401: LIST
80402: LIST
80403: PUSH
80404: EMPTY
80405: LIST
80406: LIST
80407: LIST
80408: PUSH
80409: EMPTY
80410: LIST
80411: LIST
80412: PPUSH
80413: CALL_OW 72
80417: UNION
80418: ST_TO_ADDR
// if tmp then
80419: LD_VAR 0 4
80423: IFFALSE 80503
// begin tmp := ShrinkArray ( tmp , 3 ) ;
80425: LD_ADDR_VAR 0 4
80429: PUSH
80430: LD_VAR 0 4
80434: PPUSH
80435: LD_INT 3
80437: PPUSH
80438: CALL 57007 0 2
80442: ST_TO_ADDR
// for j in tmp do
80443: LD_ADDR_VAR 0 2
80447: PUSH
80448: LD_VAR 0 4
80452: PUSH
80453: FOR_IN
80454: IFFALSE 80497
// begin if IsInUnit ( j ) then
80456: LD_VAR 0 2
80460: PPUSH
80461: CALL_OW 310
80465: IFFALSE 80476
// ComExit ( j ) ;
80467: LD_VAR 0 2
80471: PPUSH
80472: CALL 57090 0 1
// AddComCollect ( j , x , y ) ;
80476: LD_VAR 0 2
80480: PPUSH
80481: LD_VAR 0 6
80485: PPUSH
80486: LD_VAR 0 7
80490: PPUSH
80491: CALL_OW 177
// end ;
80495: GO 80453
80497: POP
80498: POP
// exit ;
80499: POP
80500: POP
80501: GO 80730
// end ; tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_dist , depot , 8 ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ] ) ;
80503: LD_ADDR_VAR 0 4
80507: PUSH
80508: LD_INT 22
80510: PUSH
80511: LD_VAR 0 5
80515: PUSH
80516: EMPTY
80517: LIST
80518: LIST
80519: PUSH
80520: LD_INT 91
80522: PUSH
80523: LD_VAR 0 8
80527: PUSH
80528: LD_INT 8
80530: PUSH
80531: EMPTY
80532: LIST
80533: LIST
80534: LIST
80535: PUSH
80536: LD_INT 2
80538: PUSH
80539: LD_INT 34
80541: PUSH
80542: LD_INT 12
80544: PUSH
80545: EMPTY
80546: LIST
80547: LIST
80548: PUSH
80549: LD_INT 34
80551: PUSH
80552: LD_INT 51
80554: PUSH
80555: EMPTY
80556: LIST
80557: LIST
80558: PUSH
80559: LD_INT 34
80561: PUSH
80562: LD_INT 32
80564: PUSH
80565: EMPTY
80566: LIST
80567: LIST
80568: PUSH
80569: LD_INT 34
80571: PUSH
80572: LD_INT 89
80574: PUSH
80575: EMPTY
80576: LIST
80577: LIST
80578: PUSH
80579: EMPTY
80580: LIST
80581: LIST
80582: LIST
80583: LIST
80584: LIST
80585: PUSH
80586: EMPTY
80587: LIST
80588: LIST
80589: LIST
80590: PPUSH
80591: CALL_OW 69
80595: ST_TO_ADDR
// if tmp then
80596: LD_VAR 0 4
80600: IFFALSE 80726
// begin for j in tmp do
80602: LD_ADDR_VAR 0 2
80606: PUSH
80607: LD_VAR 0 4
80611: PUSH
80612: FOR_IN
80613: IFFALSE 80724
// if ( GetEngine ( j ) = engine_siberite or GetFuel ( j ) > 20 ) and not HasTask ( j ) and ( GetControl ( j ) <> control_manual or IsDrivenBy ( j ) ) then
80615: LD_VAR 0 2
80619: PPUSH
80620: CALL_OW 262
80624: PUSH
80625: LD_INT 3
80627: EQUAL
80628: PUSH
80629: LD_VAR 0 2
80633: PPUSH
80634: CALL_OW 261
80638: PUSH
80639: LD_INT 20
80641: GREATER
80642: OR
80643: PUSH
80644: LD_VAR 0 2
80648: PPUSH
80649: CALL_OW 314
80653: NOT
80654: AND
80655: PUSH
80656: LD_VAR 0 2
80660: PPUSH
80661: CALL_OW 263
80665: PUSH
80666: LD_INT 1
80668: NONEQUAL
80669: PUSH
80670: LD_VAR 0 2
80674: PPUSH
80675: CALL_OW 311
80679: OR
80680: AND
80681: IFFALSE 80722
// begin ComCollect ( j , x , y ) ;
80683: LD_VAR 0 2
80687: PPUSH
80688: LD_VAR 0 6
80692: PPUSH
80693: LD_VAR 0 7
80697: PPUSH
80698: CALL_OW 117
// AddComMoveUnit ( j , depot ) ;
80702: LD_VAR 0 2
80706: PPUSH
80707: LD_VAR 0 8
80711: PPUSH
80712: CALL_OW 172
// exit ;
80716: POP
80717: POP
80718: POP
80719: POP
80720: GO 80730
// end ;
80722: GO 80612
80724: POP
80725: POP
// end ; end ;
80726: GO 80101
80728: POP
80729: POP
// end ; end_of_file
80730: PPOPN 9
80732: END
// export ru_radar on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
80733: LD_VAR 0 1
80737: PUSH
80738: LD_INT 200
80740: DOUBLE
80741: GREATEREQUAL
80742: IFFALSE 80750
80744: LD_INT 299
80746: DOUBLE
80747: LESSEQUAL
80748: IFTRUE 80752
80750: GO 80784
80752: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
80753: LD_VAR 0 1
80757: PPUSH
80758: LD_VAR 0 2
80762: PPUSH
80763: LD_VAR 0 3
80767: PPUSH
80768: LD_VAR 0 4
80772: PPUSH
80773: LD_VAR 0 5
80777: PPUSH
80778: CALL 61021 0 5
80782: GO 80861
80784: LD_INT 300
80786: DOUBLE
80787: GREATEREQUAL
80788: IFFALSE 80796
80790: LD_INT 399
80792: DOUBLE
80793: LESSEQUAL
80794: IFTRUE 80798
80796: GO 80860
80798: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
80799: LD_VAR 0 1
80803: PPUSH
80804: LD_VAR 0 2
80808: PPUSH
80809: LD_VAR 0 3
80813: PPUSH
80814: LD_VAR 0 4
80818: PPUSH
80819: LD_VAR 0 5
80823: PPUSH
80824: LD_VAR 0 6
80828: PPUSH
80829: LD_VAR 0 7
80833: PPUSH
80834: LD_VAR 0 8
80838: PPUSH
80839: LD_VAR 0 9
80843: PPUSH
80844: LD_VAR 0 10
80848: PPUSH
80849: LD_VAR 0 11
80853: PPUSH
80854: CALL 77442 0 11
80858: GO 80861
80860: POP
// end ;
80861: PPOPN 11
80863: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
80864: LD_VAR 0 1
80868: PPUSH
80869: LD_VAR 0 2
80873: PPUSH
80874: LD_VAR 0 3
80878: PPUSH
80879: LD_VAR 0 4
80883: PPUSH
80884: LD_VAR 0 5
80888: PPUSH
80889: CALL 60757 0 5
// end ; end_of_file
80893: PPOPN 5
80895: END
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
80896: LD_INT 0
80898: PPUSH
80899: PPUSH
80900: PPUSH
80901: PPUSH
80902: PPUSH
80903: PPUSH
80904: PPUSH
80905: PPUSH
80906: PPUSH
80907: PPUSH
80908: PPUSH
80909: PPUSH
80910: PPUSH
80911: PPUSH
80912: PPUSH
80913: PPUSH
80914: PPUSH
80915: PPUSH
80916: PPUSH
80917: PPUSH
80918: PPUSH
80919: PPUSH
80920: PPUSH
80921: PPUSH
80922: PPUSH
80923: PPUSH
80924: PPUSH
80925: PPUSH
80926: PPUSH
80927: PPUSH
80928: PPUSH
80929: PPUSH
80930: PPUSH
80931: PPUSH
// if not list then
80932: LD_VAR 0 1
80936: NOT
80937: IFFALSE 80941
// exit ;
80939: GO 85600
// base := list [ 1 ] ;
80941: LD_ADDR_VAR 0 3
80945: PUSH
80946: LD_VAR 0 1
80950: PUSH
80951: LD_INT 1
80953: ARRAY
80954: ST_TO_ADDR
// group := list [ 2 ] ;
80955: LD_ADDR_VAR 0 4
80959: PUSH
80960: LD_VAR 0 1
80964: PUSH
80965: LD_INT 2
80967: ARRAY
80968: ST_TO_ADDR
// path := list [ 3 ] ;
80969: LD_ADDR_VAR 0 5
80973: PUSH
80974: LD_VAR 0 1
80978: PUSH
80979: LD_INT 3
80981: ARRAY
80982: ST_TO_ADDR
// flags := list [ 4 ] ;
80983: LD_ADDR_VAR 0 6
80987: PUSH
80988: LD_VAR 0 1
80992: PUSH
80993: LD_INT 4
80995: ARRAY
80996: ST_TO_ADDR
// mined := [ ] ;
80997: LD_ADDR_VAR 0 27
81001: PUSH
81002: EMPTY
81003: ST_TO_ADDR
// bombed := [ ] ;
81004: LD_ADDR_VAR 0 28
81008: PUSH
81009: EMPTY
81010: ST_TO_ADDR
// healers := [ ] ;
81011: LD_ADDR_VAR 0 31
81015: PUSH
81016: EMPTY
81017: ST_TO_ADDR
// to_heal := [ ] ;
81018: LD_ADDR_VAR 0 30
81022: PUSH
81023: EMPTY
81024: ST_TO_ADDR
// repairs := [ ] ;
81025: LD_ADDR_VAR 0 33
81029: PUSH
81030: EMPTY
81031: ST_TO_ADDR
// to_repair := [ ] ;
81032: LD_ADDR_VAR 0 32
81036: PUSH
81037: EMPTY
81038: ST_TO_ADDR
// if not group or not path then
81039: LD_VAR 0 4
81043: NOT
81044: PUSH
81045: LD_VAR 0 5
81049: NOT
81050: OR
81051: IFFALSE 81055
// exit ;
81053: GO 85600
// side := GetSide ( group [ 1 ] ) ;
81055: LD_ADDR_VAR 0 35
81059: PUSH
81060: LD_VAR 0 4
81064: PUSH
81065: LD_INT 1
81067: ARRAY
81068: PPUSH
81069: CALL_OW 255
81073: ST_TO_ADDR
// if flags then
81074: LD_VAR 0 6
81078: IFFALSE 81222
// begin f_ignore_area := flags [ 1 ] ;
81080: LD_ADDR_VAR 0 17
81084: PUSH
81085: LD_VAR 0 6
81089: PUSH
81090: LD_INT 1
81092: ARRAY
81093: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
81094: LD_ADDR_VAR 0 18
81098: PUSH
81099: LD_VAR 0 6
81103: PUSH
81104: LD_INT 2
81106: ARRAY
81107: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
81108: LD_ADDR_VAR 0 19
81112: PUSH
81113: LD_VAR 0 6
81117: PUSH
81118: LD_INT 3
81120: ARRAY
81121: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
81122: LD_ADDR_VAR 0 20
81126: PUSH
81127: LD_VAR 0 6
81131: PUSH
81132: LD_INT 4
81134: ARRAY
81135: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
81136: LD_ADDR_VAR 0 21
81140: PUSH
81141: LD_VAR 0 6
81145: PUSH
81146: LD_INT 5
81148: ARRAY
81149: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
81150: LD_ADDR_VAR 0 22
81154: PUSH
81155: LD_VAR 0 6
81159: PUSH
81160: LD_INT 6
81162: ARRAY
81163: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
81164: LD_ADDR_VAR 0 23
81168: PUSH
81169: LD_VAR 0 6
81173: PUSH
81174: LD_INT 7
81176: ARRAY
81177: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
81178: LD_ADDR_VAR 0 24
81182: PUSH
81183: LD_VAR 0 6
81187: PUSH
81188: LD_INT 8
81190: ARRAY
81191: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
81192: LD_ADDR_VAR 0 25
81196: PUSH
81197: LD_VAR 0 6
81201: PUSH
81202: LD_INT 9
81204: ARRAY
81205: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
81206: LD_ADDR_VAR 0 26
81210: PUSH
81211: LD_VAR 0 6
81215: PUSH
81216: LD_INT 10
81218: ARRAY
81219: ST_TO_ADDR
// end else
81220: GO 81302
// begin f_ignore_area := false ;
81222: LD_ADDR_VAR 0 17
81226: PUSH
81227: LD_INT 0
81229: ST_TO_ADDR
// f_capture := false ;
81230: LD_ADDR_VAR 0 18
81234: PUSH
81235: LD_INT 0
81237: ST_TO_ADDR
// f_ignore_civ := false ;
81238: LD_ADDR_VAR 0 19
81242: PUSH
81243: LD_INT 0
81245: ST_TO_ADDR
// f_murder := false ;
81246: LD_ADDR_VAR 0 20
81250: PUSH
81251: LD_INT 0
81253: ST_TO_ADDR
// f_mines := false ;
81254: LD_ADDR_VAR 0 21
81258: PUSH
81259: LD_INT 0
81261: ST_TO_ADDR
// f_repair := false ;
81262: LD_ADDR_VAR 0 22
81266: PUSH
81267: LD_INT 0
81269: ST_TO_ADDR
// f_heal := false ;
81270: LD_ADDR_VAR 0 23
81274: PUSH
81275: LD_INT 0
81277: ST_TO_ADDR
// f_spacetime := false ;
81278: LD_ADDR_VAR 0 24
81282: PUSH
81283: LD_INT 0
81285: ST_TO_ADDR
// f_attack_depot := false ;
81286: LD_ADDR_VAR 0 25
81290: PUSH
81291: LD_INT 0
81293: ST_TO_ADDR
// f_crawl := false ;
81294: LD_ADDR_VAR 0 26
81298: PUSH
81299: LD_INT 0
81301: ST_TO_ADDR
// end ; if f_heal then
81302: LD_VAR 0 23
81306: IFFALSE 81333
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
81308: LD_ADDR_VAR 0 31
81312: PUSH
81313: LD_VAR 0 4
81317: PPUSH
81318: LD_INT 25
81320: PUSH
81321: LD_INT 4
81323: PUSH
81324: EMPTY
81325: LIST
81326: LIST
81327: PPUSH
81328: CALL_OW 72
81332: ST_TO_ADDR
// if f_repair then
81333: LD_VAR 0 22
81337: IFFALSE 81364
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
81339: LD_ADDR_VAR 0 33
81343: PUSH
81344: LD_VAR 0 4
81348: PPUSH
81349: LD_INT 25
81351: PUSH
81352: LD_INT 3
81354: PUSH
81355: EMPTY
81356: LIST
81357: LIST
81358: PPUSH
81359: CALL_OW 72
81363: ST_TO_ADDR
// units_path := [ ] ;
81364: LD_ADDR_VAR 0 16
81368: PUSH
81369: EMPTY
81370: ST_TO_ADDR
// for i = 1 to group do
81371: LD_ADDR_VAR 0 7
81375: PUSH
81376: DOUBLE
81377: LD_INT 1
81379: DEC
81380: ST_TO_ADDR
81381: LD_VAR 0 4
81385: PUSH
81386: FOR_TO
81387: IFFALSE 81416
// units_path := Replace ( units_path , i , path ) ;
81389: LD_ADDR_VAR 0 16
81393: PUSH
81394: LD_VAR 0 16
81398: PPUSH
81399: LD_VAR 0 7
81403: PPUSH
81404: LD_VAR 0 5
81408: PPUSH
81409: CALL_OW 1
81413: ST_TO_ADDR
81414: GO 81386
81416: POP
81417: POP
// repeat for i = group downto 1 do
81418: LD_ADDR_VAR 0 7
81422: PUSH
81423: DOUBLE
81424: LD_VAR 0 4
81428: INC
81429: ST_TO_ADDR
81430: LD_INT 1
81432: PUSH
81433: FOR_DOWNTO
81434: IFFALSE 85556
// begin wait ( 5 ) ;
81436: LD_INT 5
81438: PPUSH
81439: CALL_OW 67
// tmp := [ ] ;
81443: LD_ADDR_VAR 0 14
81447: PUSH
81448: EMPTY
81449: ST_TO_ADDR
// attacking := false ;
81450: LD_ADDR_VAR 0 29
81454: PUSH
81455: LD_INT 0
81457: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
81458: LD_VAR 0 4
81462: PUSH
81463: LD_VAR 0 7
81467: ARRAY
81468: PPUSH
81469: CALL_OW 301
81473: PUSH
81474: LD_VAR 0 4
81478: PUSH
81479: LD_VAR 0 7
81483: ARRAY
81484: NOT
81485: OR
81486: IFFALSE 81595
// begin if GetType ( group [ i ] ) = unit_human then
81488: LD_VAR 0 4
81492: PUSH
81493: LD_VAR 0 7
81497: ARRAY
81498: PPUSH
81499: CALL_OW 247
81503: PUSH
81504: LD_INT 1
81506: EQUAL
81507: IFFALSE 81553
// begin to_heal := to_heal diff group [ i ] ;
81509: LD_ADDR_VAR 0 30
81513: PUSH
81514: LD_VAR 0 30
81518: PUSH
81519: LD_VAR 0 4
81523: PUSH
81524: LD_VAR 0 7
81528: ARRAY
81529: DIFF
81530: ST_TO_ADDR
// healers := healers diff group [ i ] ;
81531: LD_ADDR_VAR 0 31
81535: PUSH
81536: LD_VAR 0 31
81540: PUSH
81541: LD_VAR 0 4
81545: PUSH
81546: LD_VAR 0 7
81550: ARRAY
81551: DIFF
81552: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
81553: LD_ADDR_VAR 0 4
81557: PUSH
81558: LD_VAR 0 4
81562: PPUSH
81563: LD_VAR 0 7
81567: PPUSH
81568: CALL_OW 3
81572: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
81573: LD_ADDR_VAR 0 16
81577: PUSH
81578: LD_VAR 0 16
81582: PPUSH
81583: LD_VAR 0 7
81587: PPUSH
81588: CALL_OW 3
81592: ST_TO_ADDR
// continue ;
81593: GO 81433
// end ; if f_repair then
81595: LD_VAR 0 22
81599: IFFALSE 82088
// begin if GetType ( group [ i ] ) = unit_vehicle then
81601: LD_VAR 0 4
81605: PUSH
81606: LD_VAR 0 7
81610: ARRAY
81611: PPUSH
81612: CALL_OW 247
81616: PUSH
81617: LD_INT 2
81619: EQUAL
81620: IFFALSE 81810
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
81622: LD_VAR 0 4
81626: PUSH
81627: LD_VAR 0 7
81631: ARRAY
81632: PPUSH
81633: CALL_OW 256
81637: PUSH
81638: LD_INT 700
81640: LESS
81641: PUSH
81642: LD_VAR 0 4
81646: PUSH
81647: LD_VAR 0 7
81651: ARRAY
81652: PUSH
81653: LD_VAR 0 32
81657: IN
81658: NOT
81659: AND
81660: IFFALSE 81684
// to_repair := to_repair union group [ i ] ;
81662: LD_ADDR_VAR 0 32
81666: PUSH
81667: LD_VAR 0 32
81671: PUSH
81672: LD_VAR 0 4
81676: PUSH
81677: LD_VAR 0 7
81681: ARRAY
81682: UNION
81683: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
81684: LD_VAR 0 4
81688: PUSH
81689: LD_VAR 0 7
81693: ARRAY
81694: PPUSH
81695: CALL_OW 256
81699: PUSH
81700: LD_INT 1000
81702: EQUAL
81703: PUSH
81704: LD_VAR 0 4
81708: PUSH
81709: LD_VAR 0 7
81713: ARRAY
81714: PUSH
81715: LD_VAR 0 32
81719: IN
81720: AND
81721: IFFALSE 81745
// to_repair := to_repair diff group [ i ] ;
81723: LD_ADDR_VAR 0 32
81727: PUSH
81728: LD_VAR 0 32
81732: PUSH
81733: LD_VAR 0 4
81737: PUSH
81738: LD_VAR 0 7
81742: ARRAY
81743: DIFF
81744: ST_TO_ADDR
// if group [ i ] in to_repair then
81745: LD_VAR 0 4
81749: PUSH
81750: LD_VAR 0 7
81754: ARRAY
81755: PUSH
81756: LD_VAR 0 32
81760: IN
81761: IFFALSE 81808
// begin if not IsInArea ( group [ i ] , f_repair ) then
81763: LD_VAR 0 4
81767: PUSH
81768: LD_VAR 0 7
81772: ARRAY
81773: PPUSH
81774: LD_VAR 0 22
81778: PPUSH
81779: CALL_OW 308
81783: NOT
81784: IFFALSE 81806
// ComMoveToArea ( group [ i ] , f_repair ) ;
81786: LD_VAR 0 4
81790: PUSH
81791: LD_VAR 0 7
81795: ARRAY
81796: PPUSH
81797: LD_VAR 0 22
81801: PPUSH
81802: CALL_OW 113
// continue ;
81806: GO 81433
// end ; end else
81808: GO 82088
// if group [ i ] in repairs then
81810: LD_VAR 0 4
81814: PUSH
81815: LD_VAR 0 7
81819: ARRAY
81820: PUSH
81821: LD_VAR 0 33
81825: IN
81826: IFFALSE 82088
// begin if IsInUnit ( group [ i ] ) then
81828: LD_VAR 0 4
81832: PUSH
81833: LD_VAR 0 7
81837: ARRAY
81838: PPUSH
81839: CALL_OW 310
81843: IFFALSE 81911
// begin z := IsInUnit ( group [ i ] ) ;
81845: LD_ADDR_VAR 0 13
81849: PUSH
81850: LD_VAR 0 4
81854: PUSH
81855: LD_VAR 0 7
81859: ARRAY
81860: PPUSH
81861: CALL_OW 310
81865: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
81866: LD_VAR 0 13
81870: PUSH
81871: LD_VAR 0 32
81875: IN
81876: PUSH
81877: LD_VAR 0 13
81881: PPUSH
81882: LD_VAR 0 22
81886: PPUSH
81887: CALL_OW 308
81891: AND
81892: IFFALSE 81909
// ComExitVehicle ( group [ i ] ) ;
81894: LD_VAR 0 4
81898: PUSH
81899: LD_VAR 0 7
81903: ARRAY
81904: PPUSH
81905: CALL_OW 121
// end else
81909: GO 82088
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
81911: LD_ADDR_VAR 0 13
81915: PUSH
81916: LD_VAR 0 4
81920: PPUSH
81921: LD_INT 95
81923: PUSH
81924: LD_VAR 0 22
81928: PUSH
81929: EMPTY
81930: LIST
81931: LIST
81932: PUSH
81933: LD_INT 58
81935: PUSH
81936: EMPTY
81937: LIST
81938: PUSH
81939: EMPTY
81940: LIST
81941: LIST
81942: PPUSH
81943: CALL_OW 72
81947: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
81948: LD_VAR 0 4
81952: PUSH
81953: LD_VAR 0 7
81957: ARRAY
81958: PPUSH
81959: CALL_OW 314
81963: NOT
81964: IFFALSE 82086
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
81966: LD_ADDR_VAR 0 10
81970: PUSH
81971: LD_VAR 0 13
81975: PPUSH
81976: LD_VAR 0 4
81980: PUSH
81981: LD_VAR 0 7
81985: ARRAY
81986: PPUSH
81987: CALL_OW 74
81991: ST_TO_ADDR
// if not x then
81992: LD_VAR 0 10
81996: NOT
81997: IFFALSE 82001
// continue ;
81999: GO 81433
// if GetLives ( x ) < 1000 then
82001: LD_VAR 0 10
82005: PPUSH
82006: CALL_OW 256
82010: PUSH
82011: LD_INT 1000
82013: LESS
82014: IFFALSE 82038
// ComRepairVehicle ( group [ i ] , x ) else
82016: LD_VAR 0 4
82020: PUSH
82021: LD_VAR 0 7
82025: ARRAY
82026: PPUSH
82027: LD_VAR 0 10
82031: PPUSH
82032: CALL_OW 129
82036: GO 82086
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
82038: LD_VAR 0 23
82042: PUSH
82043: LD_VAR 0 4
82047: PUSH
82048: LD_VAR 0 7
82052: ARRAY
82053: PPUSH
82054: CALL_OW 256
82058: PUSH
82059: LD_INT 1000
82061: LESS
82062: AND
82063: NOT
82064: IFFALSE 82086
// ComEnterUnit ( group [ i ] , x ) ;
82066: LD_VAR 0 4
82070: PUSH
82071: LD_VAR 0 7
82075: ARRAY
82076: PPUSH
82077: LD_VAR 0 10
82081: PPUSH
82082: CALL_OW 120
// end ; continue ;
82086: GO 81433
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
82088: LD_VAR 0 23
82092: PUSH
82093: LD_VAR 0 4
82097: PUSH
82098: LD_VAR 0 7
82102: ARRAY
82103: PPUSH
82104: CALL_OW 247
82108: PUSH
82109: LD_INT 1
82111: EQUAL
82112: AND
82113: IFFALSE 82591
// begin if group [ i ] in healers then
82115: LD_VAR 0 4
82119: PUSH
82120: LD_VAR 0 7
82124: ARRAY
82125: PUSH
82126: LD_VAR 0 31
82130: IN
82131: IFFALSE 82404
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
82133: LD_VAR 0 4
82137: PUSH
82138: LD_VAR 0 7
82142: ARRAY
82143: PPUSH
82144: LD_VAR 0 23
82148: PPUSH
82149: CALL_OW 308
82153: NOT
82154: PUSH
82155: LD_VAR 0 4
82159: PUSH
82160: LD_VAR 0 7
82164: ARRAY
82165: PPUSH
82166: CALL_OW 314
82170: NOT
82171: AND
82172: IFFALSE 82196
// ComMoveToArea ( group [ i ] , f_heal ) else
82174: LD_VAR 0 4
82178: PUSH
82179: LD_VAR 0 7
82183: ARRAY
82184: PPUSH
82185: LD_VAR 0 23
82189: PPUSH
82190: CALL_OW 113
82194: GO 82402
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
82196: LD_VAR 0 4
82200: PUSH
82201: LD_VAR 0 7
82205: ARRAY
82206: PPUSH
82207: CALL 54084 0 1
82211: PPUSH
82212: CALL_OW 256
82216: PUSH
82217: LD_INT 1000
82219: EQUAL
82220: IFFALSE 82239
// ComStop ( group [ i ] ) else
82222: LD_VAR 0 4
82226: PUSH
82227: LD_VAR 0 7
82231: ARRAY
82232: PPUSH
82233: CALL_OW 141
82237: GO 82402
// if not HasTask ( group [ i ] ) and to_heal then
82239: LD_VAR 0 4
82243: PUSH
82244: LD_VAR 0 7
82248: ARRAY
82249: PPUSH
82250: CALL_OW 314
82254: NOT
82255: PUSH
82256: LD_VAR 0 30
82260: AND
82261: IFFALSE 82402
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
82263: LD_ADDR_VAR 0 13
82267: PUSH
82268: LD_VAR 0 30
82272: PPUSH
82273: LD_INT 3
82275: PUSH
82276: LD_INT 54
82278: PUSH
82279: EMPTY
82280: LIST
82281: PUSH
82282: EMPTY
82283: LIST
82284: LIST
82285: PPUSH
82286: CALL_OW 72
82290: PPUSH
82291: LD_VAR 0 4
82295: PUSH
82296: LD_VAR 0 7
82300: ARRAY
82301: PPUSH
82302: CALL_OW 74
82306: ST_TO_ADDR
// if z then
82307: LD_VAR 0 13
82311: IFFALSE 82402
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
82313: LD_INT 91
82315: PUSH
82316: LD_VAR 0 13
82320: PUSH
82321: LD_INT 10
82323: PUSH
82324: EMPTY
82325: LIST
82326: LIST
82327: LIST
82328: PUSH
82329: LD_INT 81
82331: PUSH
82332: LD_VAR 0 13
82336: PPUSH
82337: CALL_OW 255
82341: PUSH
82342: EMPTY
82343: LIST
82344: LIST
82345: PUSH
82346: EMPTY
82347: LIST
82348: LIST
82349: PPUSH
82350: CALL_OW 69
82354: PUSH
82355: LD_INT 0
82357: EQUAL
82358: IFFALSE 82382
// ComHeal ( group [ i ] , z ) else
82360: LD_VAR 0 4
82364: PUSH
82365: LD_VAR 0 7
82369: ARRAY
82370: PPUSH
82371: LD_VAR 0 13
82375: PPUSH
82376: CALL_OW 128
82380: GO 82402
// ComMoveToArea ( group [ i ] , f_heal ) ;
82382: LD_VAR 0 4
82386: PUSH
82387: LD_VAR 0 7
82391: ARRAY
82392: PPUSH
82393: LD_VAR 0 23
82397: PPUSH
82398: CALL_OW 113
// end ; continue ;
82402: GO 81433
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
82404: LD_VAR 0 4
82408: PUSH
82409: LD_VAR 0 7
82413: ARRAY
82414: PPUSH
82415: CALL_OW 256
82419: PUSH
82420: LD_INT 700
82422: LESS
82423: PUSH
82424: LD_VAR 0 4
82428: PUSH
82429: LD_VAR 0 7
82433: ARRAY
82434: PUSH
82435: LD_VAR 0 30
82439: IN
82440: NOT
82441: AND
82442: IFFALSE 82466
// to_heal := to_heal union group [ i ] ;
82444: LD_ADDR_VAR 0 30
82448: PUSH
82449: LD_VAR 0 30
82453: PUSH
82454: LD_VAR 0 4
82458: PUSH
82459: LD_VAR 0 7
82463: ARRAY
82464: UNION
82465: ST_TO_ADDR
// if group [ i ] in to_heal then
82466: LD_VAR 0 4
82470: PUSH
82471: LD_VAR 0 7
82475: ARRAY
82476: PUSH
82477: LD_VAR 0 30
82481: IN
82482: IFFALSE 82591
// begin if GetLives ( group [ i ] ) = 1000 then
82484: LD_VAR 0 4
82488: PUSH
82489: LD_VAR 0 7
82493: ARRAY
82494: PPUSH
82495: CALL_OW 256
82499: PUSH
82500: LD_INT 1000
82502: EQUAL
82503: IFFALSE 82529
// to_heal := to_heal diff group [ i ] else
82505: LD_ADDR_VAR 0 30
82509: PUSH
82510: LD_VAR 0 30
82514: PUSH
82515: LD_VAR 0 4
82519: PUSH
82520: LD_VAR 0 7
82524: ARRAY
82525: DIFF
82526: ST_TO_ADDR
82527: GO 82591
// begin if not IsInArea ( group [ i ] , to_heal ) then
82529: LD_VAR 0 4
82533: PUSH
82534: LD_VAR 0 7
82538: ARRAY
82539: PPUSH
82540: LD_VAR 0 30
82544: PPUSH
82545: CALL_OW 308
82549: NOT
82550: IFFALSE 82574
// ComMoveToArea ( group [ i ] , f_heal ) else
82552: LD_VAR 0 4
82556: PUSH
82557: LD_VAR 0 7
82561: ARRAY
82562: PPUSH
82563: LD_VAR 0 23
82567: PPUSH
82568: CALL_OW 113
82572: GO 82589
// ComHold ( group [ i ] ) ;
82574: LD_VAR 0 4
82578: PUSH
82579: LD_VAR 0 7
82583: ARRAY
82584: PPUSH
82585: CALL_OW 140
// continue ;
82589: GO 81433
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
82591: LD_VAR 0 4
82595: PUSH
82596: LD_VAR 0 7
82600: ARRAY
82601: PPUSH
82602: LD_INT 10
82604: PPUSH
82605: CALL 51855 0 2
82609: NOT
82610: PUSH
82611: LD_VAR 0 16
82615: PUSH
82616: LD_VAR 0 7
82620: ARRAY
82621: PUSH
82622: EMPTY
82623: EQUAL
82624: NOT
82625: AND
82626: IFFALSE 82892
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
82628: LD_VAR 0 4
82632: PUSH
82633: LD_VAR 0 7
82637: ARRAY
82638: PPUSH
82639: CALL_OW 262
82643: PUSH
82644: LD_INT 1
82646: PUSH
82647: LD_INT 2
82649: PUSH
82650: EMPTY
82651: LIST
82652: LIST
82653: IN
82654: IFFALSE 82695
// if GetFuel ( group [ i ] ) < 10 then
82656: LD_VAR 0 4
82660: PUSH
82661: LD_VAR 0 7
82665: ARRAY
82666: PPUSH
82667: CALL_OW 261
82671: PUSH
82672: LD_INT 10
82674: LESS
82675: IFFALSE 82695
// SetFuel ( group [ i ] , 12 ) ;
82677: LD_VAR 0 4
82681: PUSH
82682: LD_VAR 0 7
82686: ARRAY
82687: PPUSH
82688: LD_INT 12
82690: PPUSH
82691: CALL_OW 240
// if units_path [ i ] then
82695: LD_VAR 0 16
82699: PUSH
82700: LD_VAR 0 7
82704: ARRAY
82705: IFFALSE 82890
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
82707: LD_VAR 0 4
82711: PUSH
82712: LD_VAR 0 7
82716: ARRAY
82717: PPUSH
82718: LD_VAR 0 16
82722: PUSH
82723: LD_VAR 0 7
82727: ARRAY
82728: PUSH
82729: LD_INT 1
82731: ARRAY
82732: PUSH
82733: LD_INT 1
82735: ARRAY
82736: PPUSH
82737: LD_VAR 0 16
82741: PUSH
82742: LD_VAR 0 7
82746: ARRAY
82747: PUSH
82748: LD_INT 1
82750: ARRAY
82751: PUSH
82752: LD_INT 2
82754: ARRAY
82755: PPUSH
82756: CALL_OW 297
82760: PUSH
82761: LD_INT 6
82763: GREATER
82764: IFFALSE 82839
// begin if not HasTask ( group [ i ] ) then
82766: LD_VAR 0 4
82770: PUSH
82771: LD_VAR 0 7
82775: ARRAY
82776: PPUSH
82777: CALL_OW 314
82781: NOT
82782: IFFALSE 82837
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
82784: LD_VAR 0 4
82788: PUSH
82789: LD_VAR 0 7
82793: ARRAY
82794: PPUSH
82795: LD_VAR 0 16
82799: PUSH
82800: LD_VAR 0 7
82804: ARRAY
82805: PUSH
82806: LD_INT 1
82808: ARRAY
82809: PUSH
82810: LD_INT 1
82812: ARRAY
82813: PPUSH
82814: LD_VAR 0 16
82818: PUSH
82819: LD_VAR 0 7
82823: ARRAY
82824: PUSH
82825: LD_INT 1
82827: ARRAY
82828: PUSH
82829: LD_INT 2
82831: ARRAY
82832: PPUSH
82833: CALL_OW 114
// end else
82837: GO 82890
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
82839: LD_ADDR_VAR 0 15
82843: PUSH
82844: LD_VAR 0 16
82848: PUSH
82849: LD_VAR 0 7
82853: ARRAY
82854: PPUSH
82855: LD_INT 1
82857: PPUSH
82858: CALL_OW 3
82862: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
82863: LD_ADDR_VAR 0 16
82867: PUSH
82868: LD_VAR 0 16
82872: PPUSH
82873: LD_VAR 0 7
82877: PPUSH
82878: LD_VAR 0 15
82882: PPUSH
82883: CALL_OW 1
82887: ST_TO_ADDR
// continue ;
82888: GO 81433
// end ; end ; end else
82890: GO 85554
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
82892: LD_ADDR_VAR 0 14
82896: PUSH
82897: LD_INT 81
82899: PUSH
82900: LD_VAR 0 4
82904: PUSH
82905: LD_VAR 0 7
82909: ARRAY
82910: PPUSH
82911: CALL_OW 255
82915: PUSH
82916: EMPTY
82917: LIST
82918: LIST
82919: PPUSH
82920: CALL_OW 69
82924: ST_TO_ADDR
// if not tmp then
82925: LD_VAR 0 14
82929: NOT
82930: IFFALSE 82934
// continue ;
82932: GO 81433
// if f_ignore_area then
82934: LD_VAR 0 17
82938: IFFALSE 83026
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
82940: LD_ADDR_VAR 0 15
82944: PUSH
82945: LD_VAR 0 14
82949: PPUSH
82950: LD_INT 3
82952: PUSH
82953: LD_INT 92
82955: PUSH
82956: LD_VAR 0 17
82960: PUSH
82961: LD_INT 1
82963: ARRAY
82964: PUSH
82965: LD_VAR 0 17
82969: PUSH
82970: LD_INT 2
82972: ARRAY
82973: PUSH
82974: LD_VAR 0 17
82978: PUSH
82979: LD_INT 3
82981: ARRAY
82982: PUSH
82983: EMPTY
82984: LIST
82985: LIST
82986: LIST
82987: LIST
82988: PUSH
82989: EMPTY
82990: LIST
82991: LIST
82992: PPUSH
82993: CALL_OW 72
82997: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
82998: LD_VAR 0 14
83002: PUSH
83003: LD_VAR 0 15
83007: DIFF
83008: IFFALSE 83026
// tmp := tmp diff tmp2 ;
83010: LD_ADDR_VAR 0 14
83014: PUSH
83015: LD_VAR 0 14
83019: PUSH
83020: LD_VAR 0 15
83024: DIFF
83025: ST_TO_ADDR
// end ; if not f_murder then
83026: LD_VAR 0 20
83030: NOT
83031: IFFALSE 83089
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
83033: LD_ADDR_VAR 0 15
83037: PUSH
83038: LD_VAR 0 14
83042: PPUSH
83043: LD_INT 3
83045: PUSH
83046: LD_INT 50
83048: PUSH
83049: EMPTY
83050: LIST
83051: PUSH
83052: EMPTY
83053: LIST
83054: LIST
83055: PPUSH
83056: CALL_OW 72
83060: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
83061: LD_VAR 0 14
83065: PUSH
83066: LD_VAR 0 15
83070: DIFF
83071: IFFALSE 83089
// tmp := tmp diff tmp2 ;
83073: LD_ADDR_VAR 0 14
83077: PUSH
83078: LD_VAR 0 14
83082: PUSH
83083: LD_VAR 0 15
83087: DIFF
83088: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
83089: LD_ADDR_VAR 0 14
83093: PUSH
83094: LD_VAR 0 4
83098: PUSH
83099: LD_VAR 0 7
83103: ARRAY
83104: PPUSH
83105: LD_VAR 0 14
83109: PPUSH
83110: LD_INT 1
83112: PPUSH
83113: LD_INT 1
83115: PPUSH
83116: CALL 24796 0 4
83120: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
83121: LD_VAR 0 4
83125: PUSH
83126: LD_VAR 0 7
83130: ARRAY
83131: PPUSH
83132: CALL_OW 257
83136: PUSH
83137: LD_INT 1
83139: EQUAL
83140: IFFALSE 83588
// begin if WantPlant ( group [ i ] ) then
83142: LD_VAR 0 4
83146: PUSH
83147: LD_VAR 0 7
83151: ARRAY
83152: PPUSH
83153: CALL 24297 0 1
83157: IFFALSE 83161
// continue ;
83159: GO 81433
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
83161: LD_VAR 0 18
83165: PUSH
83166: LD_VAR 0 4
83170: PUSH
83171: LD_VAR 0 7
83175: ARRAY
83176: PPUSH
83177: CALL_OW 310
83181: NOT
83182: AND
83183: PUSH
83184: LD_VAR 0 14
83188: PUSH
83189: LD_INT 1
83191: ARRAY
83192: PUSH
83193: LD_VAR 0 14
83197: PPUSH
83198: LD_INT 21
83200: PUSH
83201: LD_INT 2
83203: PUSH
83204: EMPTY
83205: LIST
83206: LIST
83207: PUSH
83208: LD_INT 58
83210: PUSH
83211: EMPTY
83212: LIST
83213: PUSH
83214: EMPTY
83215: LIST
83216: LIST
83217: PPUSH
83218: CALL_OW 72
83222: IN
83223: AND
83224: IFFALSE 83260
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
83226: LD_VAR 0 4
83230: PUSH
83231: LD_VAR 0 7
83235: ARRAY
83236: PPUSH
83237: LD_VAR 0 14
83241: PUSH
83242: LD_INT 1
83244: ARRAY
83245: PPUSH
83246: CALL_OW 120
// attacking := true ;
83250: LD_ADDR_VAR 0 29
83254: PUSH
83255: LD_INT 1
83257: ST_TO_ADDR
// continue ;
83258: GO 81433
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
83260: LD_VAR 0 26
83264: PUSH
83265: LD_VAR 0 4
83269: PUSH
83270: LD_VAR 0 7
83274: ARRAY
83275: PPUSH
83276: CALL_OW 257
83280: PUSH
83281: LD_INT 1
83283: EQUAL
83284: AND
83285: PUSH
83286: LD_VAR 0 4
83290: PUSH
83291: LD_VAR 0 7
83295: ARRAY
83296: PPUSH
83297: CALL_OW 256
83301: PUSH
83302: LD_INT 800
83304: LESS
83305: AND
83306: PUSH
83307: LD_VAR 0 4
83311: PUSH
83312: LD_VAR 0 7
83316: ARRAY
83317: PPUSH
83318: CALL_OW 318
83322: NOT
83323: AND
83324: IFFALSE 83341
// ComCrawl ( group [ i ] ) ;
83326: LD_VAR 0 4
83330: PUSH
83331: LD_VAR 0 7
83335: ARRAY
83336: PPUSH
83337: CALL_OW 137
// if f_mines then
83341: LD_VAR 0 21
83345: IFFALSE 83588
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
83347: LD_VAR 0 14
83351: PUSH
83352: LD_INT 1
83354: ARRAY
83355: PPUSH
83356: CALL_OW 247
83360: PUSH
83361: LD_INT 3
83363: EQUAL
83364: PUSH
83365: LD_VAR 0 14
83369: PUSH
83370: LD_INT 1
83372: ARRAY
83373: PUSH
83374: LD_VAR 0 27
83378: IN
83379: NOT
83380: AND
83381: IFFALSE 83588
// begin x := GetX ( tmp [ 1 ] ) ;
83383: LD_ADDR_VAR 0 10
83387: PUSH
83388: LD_VAR 0 14
83392: PUSH
83393: LD_INT 1
83395: ARRAY
83396: PPUSH
83397: CALL_OW 250
83401: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
83402: LD_ADDR_VAR 0 11
83406: PUSH
83407: LD_VAR 0 14
83411: PUSH
83412: LD_INT 1
83414: ARRAY
83415: PPUSH
83416: CALL_OW 251
83420: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
83421: LD_ADDR_VAR 0 12
83425: PUSH
83426: LD_VAR 0 4
83430: PUSH
83431: LD_VAR 0 7
83435: ARRAY
83436: PPUSH
83437: CALL 51940 0 1
83441: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
83442: LD_VAR 0 4
83446: PUSH
83447: LD_VAR 0 7
83451: ARRAY
83452: PPUSH
83453: LD_VAR 0 10
83457: PPUSH
83458: LD_VAR 0 11
83462: PPUSH
83463: LD_VAR 0 14
83467: PUSH
83468: LD_INT 1
83470: ARRAY
83471: PPUSH
83472: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
83476: LD_VAR 0 4
83480: PUSH
83481: LD_VAR 0 7
83485: ARRAY
83486: PPUSH
83487: LD_VAR 0 10
83491: PPUSH
83492: LD_VAR 0 12
83496: PPUSH
83497: LD_INT 7
83499: PPUSH
83500: CALL_OW 272
83504: PPUSH
83505: LD_VAR 0 11
83509: PPUSH
83510: LD_VAR 0 12
83514: PPUSH
83515: LD_INT 7
83517: PPUSH
83518: CALL_OW 273
83522: PPUSH
83523: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
83527: LD_VAR 0 4
83531: PUSH
83532: LD_VAR 0 7
83536: ARRAY
83537: PPUSH
83538: LD_INT 71
83540: PPUSH
83541: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
83545: LD_ADDR_VAR 0 27
83549: PUSH
83550: LD_VAR 0 27
83554: PPUSH
83555: LD_VAR 0 27
83559: PUSH
83560: LD_INT 1
83562: PLUS
83563: PPUSH
83564: LD_VAR 0 14
83568: PUSH
83569: LD_INT 1
83571: ARRAY
83572: PPUSH
83573: CALL_OW 1
83577: ST_TO_ADDR
// attacking := true ;
83578: LD_ADDR_VAR 0 29
83582: PUSH
83583: LD_INT 1
83585: ST_TO_ADDR
// continue ;
83586: GO 81433
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
83588: LD_VAR 0 4
83592: PUSH
83593: LD_VAR 0 7
83597: ARRAY
83598: PPUSH
83599: CALL_OW 257
83603: PUSH
83604: LD_INT 17
83606: EQUAL
83607: PUSH
83608: LD_VAR 0 4
83612: PUSH
83613: LD_VAR 0 7
83617: ARRAY
83618: PPUSH
83619: CALL_OW 110
83623: PUSH
83624: LD_INT 71
83626: EQUAL
83627: NOT
83628: AND
83629: IFFALSE 83775
// begin attacking := false ;
83631: LD_ADDR_VAR 0 29
83635: PUSH
83636: LD_INT 0
83638: ST_TO_ADDR
// k := 5 ;
83639: LD_ADDR_VAR 0 9
83643: PUSH
83644: LD_INT 5
83646: ST_TO_ADDR
// if tmp < k then
83647: LD_VAR 0 14
83651: PUSH
83652: LD_VAR 0 9
83656: LESS
83657: IFFALSE 83669
// k := tmp ;
83659: LD_ADDR_VAR 0 9
83663: PUSH
83664: LD_VAR 0 14
83668: ST_TO_ADDR
// for j = 1 to k do
83669: LD_ADDR_VAR 0 8
83673: PUSH
83674: DOUBLE
83675: LD_INT 1
83677: DEC
83678: ST_TO_ADDR
83679: LD_VAR 0 9
83683: PUSH
83684: FOR_TO
83685: IFFALSE 83773
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
83687: LD_VAR 0 14
83691: PUSH
83692: LD_VAR 0 8
83696: ARRAY
83697: PUSH
83698: LD_VAR 0 14
83702: PPUSH
83703: LD_INT 58
83705: PUSH
83706: EMPTY
83707: LIST
83708: PPUSH
83709: CALL_OW 72
83713: IN
83714: NOT
83715: IFFALSE 83771
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
83717: LD_VAR 0 4
83721: PUSH
83722: LD_VAR 0 7
83726: ARRAY
83727: PPUSH
83728: LD_VAR 0 14
83732: PUSH
83733: LD_VAR 0 8
83737: ARRAY
83738: PPUSH
83739: CALL_OW 115
// attacking := true ;
83743: LD_ADDR_VAR 0 29
83747: PUSH
83748: LD_INT 1
83750: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
83751: LD_VAR 0 4
83755: PUSH
83756: LD_VAR 0 7
83760: ARRAY
83761: PPUSH
83762: LD_INT 71
83764: PPUSH
83765: CALL_OW 109
// continue ;
83769: GO 83684
// end ; end ;
83771: GO 83684
83773: POP
83774: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
83775: LD_VAR 0 4
83779: PUSH
83780: LD_VAR 0 7
83784: ARRAY
83785: PPUSH
83786: CALL_OW 257
83790: PUSH
83791: LD_INT 8
83793: EQUAL
83794: PUSH
83795: LD_VAR 0 4
83799: PUSH
83800: LD_VAR 0 7
83804: ARRAY
83805: PPUSH
83806: CALL_OW 264
83810: PUSH
83811: LD_INT 28
83813: PUSH
83814: LD_INT 45
83816: PUSH
83817: LD_INT 7
83819: PUSH
83820: LD_INT 47
83822: PUSH
83823: EMPTY
83824: LIST
83825: LIST
83826: LIST
83827: LIST
83828: IN
83829: OR
83830: IFFALSE 84086
// begin attacking := false ;
83832: LD_ADDR_VAR 0 29
83836: PUSH
83837: LD_INT 0
83839: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
83840: LD_VAR 0 14
83844: PUSH
83845: LD_INT 1
83847: ARRAY
83848: PPUSH
83849: CALL_OW 266
83853: PUSH
83854: LD_INT 32
83856: PUSH
83857: LD_INT 31
83859: PUSH
83860: LD_INT 33
83862: PUSH
83863: LD_INT 4
83865: PUSH
83866: LD_INT 5
83868: PUSH
83869: EMPTY
83870: LIST
83871: LIST
83872: LIST
83873: LIST
83874: LIST
83875: IN
83876: IFFALSE 84062
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
83878: LD_ADDR_VAR 0 9
83882: PUSH
83883: LD_VAR 0 14
83887: PUSH
83888: LD_INT 1
83890: ARRAY
83891: PPUSH
83892: CALL_OW 266
83896: PPUSH
83897: LD_VAR 0 14
83901: PUSH
83902: LD_INT 1
83904: ARRAY
83905: PPUSH
83906: CALL_OW 250
83910: PPUSH
83911: LD_VAR 0 14
83915: PUSH
83916: LD_INT 1
83918: ARRAY
83919: PPUSH
83920: CALL_OW 251
83924: PPUSH
83925: LD_VAR 0 14
83929: PUSH
83930: LD_INT 1
83932: ARRAY
83933: PPUSH
83934: CALL_OW 254
83938: PPUSH
83939: LD_VAR 0 14
83943: PUSH
83944: LD_INT 1
83946: ARRAY
83947: PPUSH
83948: CALL_OW 248
83952: PPUSH
83953: LD_INT 0
83955: PPUSH
83956: CALL 33310 0 6
83960: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
83961: LD_ADDR_VAR 0 8
83965: PUSH
83966: LD_VAR 0 4
83970: PUSH
83971: LD_VAR 0 7
83975: ARRAY
83976: PPUSH
83977: LD_VAR 0 9
83981: PPUSH
83982: CALL 52053 0 2
83986: ST_TO_ADDR
// if j then
83987: LD_VAR 0 8
83991: IFFALSE 84060
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
83993: LD_VAR 0 8
83997: PUSH
83998: LD_INT 1
84000: ARRAY
84001: PPUSH
84002: LD_VAR 0 8
84006: PUSH
84007: LD_INT 2
84009: ARRAY
84010: PPUSH
84011: CALL_OW 488
84015: IFFALSE 84060
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
84017: LD_VAR 0 4
84021: PUSH
84022: LD_VAR 0 7
84026: ARRAY
84027: PPUSH
84028: LD_VAR 0 8
84032: PUSH
84033: LD_INT 1
84035: ARRAY
84036: PPUSH
84037: LD_VAR 0 8
84041: PUSH
84042: LD_INT 2
84044: ARRAY
84045: PPUSH
84046: CALL_OW 116
// attacking := true ;
84050: LD_ADDR_VAR 0 29
84054: PUSH
84055: LD_INT 1
84057: ST_TO_ADDR
// continue ;
84058: GO 81433
// end ; end else
84060: GO 84086
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
84062: LD_VAR 0 4
84066: PUSH
84067: LD_VAR 0 7
84071: ARRAY
84072: PPUSH
84073: LD_VAR 0 14
84077: PUSH
84078: LD_INT 1
84080: ARRAY
84081: PPUSH
84082: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
84086: LD_VAR 0 4
84090: PUSH
84091: LD_VAR 0 7
84095: ARRAY
84096: PPUSH
84097: CALL_OW 265
84101: PUSH
84102: LD_INT 11
84104: EQUAL
84105: IFFALSE 84383
// begin k := 10 ;
84107: LD_ADDR_VAR 0 9
84111: PUSH
84112: LD_INT 10
84114: ST_TO_ADDR
// x := 0 ;
84115: LD_ADDR_VAR 0 10
84119: PUSH
84120: LD_INT 0
84122: ST_TO_ADDR
// if tmp < k then
84123: LD_VAR 0 14
84127: PUSH
84128: LD_VAR 0 9
84132: LESS
84133: IFFALSE 84145
// k := tmp ;
84135: LD_ADDR_VAR 0 9
84139: PUSH
84140: LD_VAR 0 14
84144: ST_TO_ADDR
// for j = k downto 1 do
84145: LD_ADDR_VAR 0 8
84149: PUSH
84150: DOUBLE
84151: LD_VAR 0 9
84155: INC
84156: ST_TO_ADDR
84157: LD_INT 1
84159: PUSH
84160: FOR_DOWNTO
84161: IFFALSE 84236
// begin if GetType ( tmp [ j ] ) = unit_human then
84163: LD_VAR 0 14
84167: PUSH
84168: LD_VAR 0 8
84172: ARRAY
84173: PPUSH
84174: CALL_OW 247
84178: PUSH
84179: LD_INT 1
84181: EQUAL
84182: IFFALSE 84234
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
84184: LD_VAR 0 4
84188: PUSH
84189: LD_VAR 0 7
84193: ARRAY
84194: PPUSH
84195: LD_VAR 0 14
84199: PUSH
84200: LD_VAR 0 8
84204: ARRAY
84205: PPUSH
84206: CALL 52307 0 2
// x := tmp [ j ] ;
84210: LD_ADDR_VAR 0 10
84214: PUSH
84215: LD_VAR 0 14
84219: PUSH
84220: LD_VAR 0 8
84224: ARRAY
84225: ST_TO_ADDR
// attacking := true ;
84226: LD_ADDR_VAR 0 29
84230: PUSH
84231: LD_INT 1
84233: ST_TO_ADDR
// end ; end ;
84234: GO 84160
84236: POP
84237: POP
// if not x then
84238: LD_VAR 0 10
84242: NOT
84243: IFFALSE 84383
// begin attacking := true ;
84245: LD_ADDR_VAR 0 29
84249: PUSH
84250: LD_INT 1
84252: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
84253: LD_VAR 0 4
84257: PUSH
84258: LD_VAR 0 7
84262: ARRAY
84263: PPUSH
84264: CALL_OW 250
84268: PPUSH
84269: LD_VAR 0 4
84273: PUSH
84274: LD_VAR 0 7
84278: ARRAY
84279: PPUSH
84280: CALL_OW 251
84284: PPUSH
84285: CALL_OW 546
84289: PUSH
84290: LD_INT 2
84292: ARRAY
84293: PUSH
84294: LD_VAR 0 14
84298: PUSH
84299: LD_INT 1
84301: ARRAY
84302: PPUSH
84303: CALL_OW 250
84307: PPUSH
84308: LD_VAR 0 14
84312: PUSH
84313: LD_INT 1
84315: ARRAY
84316: PPUSH
84317: CALL_OW 251
84321: PPUSH
84322: CALL_OW 546
84326: PUSH
84327: LD_INT 2
84329: ARRAY
84330: EQUAL
84331: IFFALSE 84359
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
84333: LD_VAR 0 4
84337: PUSH
84338: LD_VAR 0 7
84342: ARRAY
84343: PPUSH
84344: LD_VAR 0 14
84348: PUSH
84349: LD_INT 1
84351: ARRAY
84352: PPUSH
84353: CALL 52307 0 2
84357: GO 84383
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
84359: LD_VAR 0 4
84363: PUSH
84364: LD_VAR 0 7
84368: ARRAY
84369: PPUSH
84370: LD_VAR 0 14
84374: PUSH
84375: LD_INT 1
84377: ARRAY
84378: PPUSH
84379: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
84383: LD_VAR 0 4
84387: PUSH
84388: LD_VAR 0 7
84392: ARRAY
84393: PPUSH
84394: CALL_OW 264
84398: PUSH
84399: LD_INT 29
84401: EQUAL
84402: IFFALSE 84768
// begin if WantsToAttack ( group [ i ] ) in bombed then
84404: LD_VAR 0 4
84408: PUSH
84409: LD_VAR 0 7
84413: ARRAY
84414: PPUSH
84415: CALL_OW 319
84419: PUSH
84420: LD_VAR 0 28
84424: IN
84425: IFFALSE 84429
// continue ;
84427: GO 81433
// k := 8 ;
84429: LD_ADDR_VAR 0 9
84433: PUSH
84434: LD_INT 8
84436: ST_TO_ADDR
// x := 0 ;
84437: LD_ADDR_VAR 0 10
84441: PUSH
84442: LD_INT 0
84444: ST_TO_ADDR
// if tmp < k then
84445: LD_VAR 0 14
84449: PUSH
84450: LD_VAR 0 9
84454: LESS
84455: IFFALSE 84467
// k := tmp ;
84457: LD_ADDR_VAR 0 9
84461: PUSH
84462: LD_VAR 0 14
84466: ST_TO_ADDR
// for j = 1 to k do
84467: LD_ADDR_VAR 0 8
84471: PUSH
84472: DOUBLE
84473: LD_INT 1
84475: DEC
84476: ST_TO_ADDR
84477: LD_VAR 0 9
84481: PUSH
84482: FOR_TO
84483: IFFALSE 84615
// begin if GetType ( tmp [ j ] ) = unit_building then
84485: LD_VAR 0 14
84489: PUSH
84490: LD_VAR 0 8
84494: ARRAY
84495: PPUSH
84496: CALL_OW 247
84500: PUSH
84501: LD_INT 3
84503: EQUAL
84504: IFFALSE 84613
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
84506: LD_VAR 0 14
84510: PUSH
84511: LD_VAR 0 8
84515: ARRAY
84516: PUSH
84517: LD_VAR 0 28
84521: IN
84522: NOT
84523: PUSH
84524: LD_VAR 0 14
84528: PUSH
84529: LD_VAR 0 8
84533: ARRAY
84534: PPUSH
84535: CALL_OW 313
84539: AND
84540: IFFALSE 84613
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
84542: LD_VAR 0 4
84546: PUSH
84547: LD_VAR 0 7
84551: ARRAY
84552: PPUSH
84553: LD_VAR 0 14
84557: PUSH
84558: LD_VAR 0 8
84562: ARRAY
84563: PPUSH
84564: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
84568: LD_ADDR_VAR 0 28
84572: PUSH
84573: LD_VAR 0 28
84577: PPUSH
84578: LD_VAR 0 28
84582: PUSH
84583: LD_INT 1
84585: PLUS
84586: PPUSH
84587: LD_VAR 0 14
84591: PUSH
84592: LD_VAR 0 8
84596: ARRAY
84597: PPUSH
84598: CALL_OW 1
84602: ST_TO_ADDR
// attacking := true ;
84603: LD_ADDR_VAR 0 29
84607: PUSH
84608: LD_INT 1
84610: ST_TO_ADDR
// break ;
84611: GO 84615
// end ; end ;
84613: GO 84482
84615: POP
84616: POP
// if not attacking and f_attack_depot then
84617: LD_VAR 0 29
84621: NOT
84622: PUSH
84623: LD_VAR 0 25
84627: AND
84628: IFFALSE 84723
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
84630: LD_ADDR_VAR 0 13
84634: PUSH
84635: LD_VAR 0 14
84639: PPUSH
84640: LD_INT 2
84642: PUSH
84643: LD_INT 30
84645: PUSH
84646: LD_INT 0
84648: PUSH
84649: EMPTY
84650: LIST
84651: LIST
84652: PUSH
84653: LD_INT 30
84655: PUSH
84656: LD_INT 1
84658: PUSH
84659: EMPTY
84660: LIST
84661: LIST
84662: PUSH
84663: EMPTY
84664: LIST
84665: LIST
84666: LIST
84667: PPUSH
84668: CALL_OW 72
84672: ST_TO_ADDR
// if z then
84673: LD_VAR 0 13
84677: IFFALSE 84723
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
84679: LD_VAR 0 4
84683: PUSH
84684: LD_VAR 0 7
84688: ARRAY
84689: PPUSH
84690: LD_VAR 0 13
84694: PPUSH
84695: LD_VAR 0 4
84699: PUSH
84700: LD_VAR 0 7
84704: ARRAY
84705: PPUSH
84706: CALL_OW 74
84710: PPUSH
84711: CALL_OW 115
// attacking := true ;
84715: LD_ADDR_VAR 0 29
84719: PUSH
84720: LD_INT 1
84722: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
84723: LD_VAR 0 4
84727: PUSH
84728: LD_VAR 0 7
84732: ARRAY
84733: PPUSH
84734: CALL_OW 256
84738: PUSH
84739: LD_INT 500
84741: LESS
84742: IFFALSE 84768
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
84744: LD_VAR 0 4
84748: PUSH
84749: LD_VAR 0 7
84753: ARRAY
84754: PPUSH
84755: LD_VAR 0 14
84759: PUSH
84760: LD_INT 1
84762: ARRAY
84763: PPUSH
84764: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
84768: LD_VAR 0 4
84772: PUSH
84773: LD_VAR 0 7
84777: ARRAY
84778: PPUSH
84779: CALL_OW 264
84783: PUSH
84784: LD_INT 49
84786: EQUAL
84787: IFFALSE 84908
// begin if not HasTask ( group [ i ] ) then
84789: LD_VAR 0 4
84793: PUSH
84794: LD_VAR 0 7
84798: ARRAY
84799: PPUSH
84800: CALL_OW 314
84804: NOT
84805: IFFALSE 84908
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
84807: LD_ADDR_VAR 0 9
84811: PUSH
84812: LD_INT 81
84814: PUSH
84815: LD_VAR 0 4
84819: PUSH
84820: LD_VAR 0 7
84824: ARRAY
84825: PPUSH
84826: CALL_OW 255
84830: PUSH
84831: EMPTY
84832: LIST
84833: LIST
84834: PPUSH
84835: CALL_OW 69
84839: PPUSH
84840: LD_VAR 0 4
84844: PUSH
84845: LD_VAR 0 7
84849: ARRAY
84850: PPUSH
84851: CALL_OW 74
84855: ST_TO_ADDR
// if k then
84856: LD_VAR 0 9
84860: IFFALSE 84908
// if GetDistUnits ( group [ i ] , k ) > 10 then
84862: LD_VAR 0 4
84866: PUSH
84867: LD_VAR 0 7
84871: ARRAY
84872: PPUSH
84873: LD_VAR 0 9
84877: PPUSH
84878: CALL_OW 296
84882: PUSH
84883: LD_INT 10
84885: GREATER
84886: IFFALSE 84908
// ComMoveUnit ( group [ i ] , k ) ;
84888: LD_VAR 0 4
84892: PUSH
84893: LD_VAR 0 7
84897: ARRAY
84898: PPUSH
84899: LD_VAR 0 9
84903: PPUSH
84904: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
84908: LD_VAR 0 4
84912: PUSH
84913: LD_VAR 0 7
84917: ARRAY
84918: PPUSH
84919: CALL_OW 256
84923: PUSH
84924: LD_INT 250
84926: LESS
84927: PUSH
84928: LD_VAR 0 4
84932: PUSH
84933: LD_VAR 0 7
84937: ARRAY
84938: PUSH
84939: LD_INT 21
84941: PUSH
84942: LD_INT 2
84944: PUSH
84945: EMPTY
84946: LIST
84947: LIST
84948: PUSH
84949: LD_INT 23
84951: PUSH
84952: LD_INT 2
84954: PUSH
84955: EMPTY
84956: LIST
84957: LIST
84958: PUSH
84959: EMPTY
84960: LIST
84961: LIST
84962: PPUSH
84963: CALL_OW 69
84967: IN
84968: AND
84969: IFFALSE 85094
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
84971: LD_ADDR_VAR 0 9
84975: PUSH
84976: LD_OWVAR 3
84980: PUSH
84981: LD_VAR 0 4
84985: PUSH
84986: LD_VAR 0 7
84990: ARRAY
84991: DIFF
84992: PPUSH
84993: LD_VAR 0 4
84997: PUSH
84998: LD_VAR 0 7
85002: ARRAY
85003: PPUSH
85004: CALL_OW 74
85008: ST_TO_ADDR
// if not k then
85009: LD_VAR 0 9
85013: NOT
85014: IFFALSE 85018
// continue ;
85016: GO 81433
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
85018: LD_VAR 0 9
85022: PUSH
85023: LD_INT 81
85025: PUSH
85026: LD_VAR 0 4
85030: PUSH
85031: LD_VAR 0 7
85035: ARRAY
85036: PPUSH
85037: CALL_OW 255
85041: PUSH
85042: EMPTY
85043: LIST
85044: LIST
85045: PPUSH
85046: CALL_OW 69
85050: IN
85051: PUSH
85052: LD_VAR 0 9
85056: PPUSH
85057: LD_VAR 0 4
85061: PUSH
85062: LD_VAR 0 7
85066: ARRAY
85067: PPUSH
85068: CALL_OW 296
85072: PUSH
85073: LD_INT 5
85075: LESS
85076: AND
85077: IFFALSE 85094
// ComAutodestruct ( group [ i ] ) ;
85079: LD_VAR 0 4
85083: PUSH
85084: LD_VAR 0 7
85088: ARRAY
85089: PPUSH
85090: CALL 52205 0 1
// end ; if f_attack_depot then
85094: LD_VAR 0 25
85098: IFFALSE 85210
// begin k := 6 ;
85100: LD_ADDR_VAR 0 9
85104: PUSH
85105: LD_INT 6
85107: ST_TO_ADDR
// if tmp < k then
85108: LD_VAR 0 14
85112: PUSH
85113: LD_VAR 0 9
85117: LESS
85118: IFFALSE 85130
// k := tmp ;
85120: LD_ADDR_VAR 0 9
85124: PUSH
85125: LD_VAR 0 14
85129: ST_TO_ADDR
// for j = 1 to k do
85130: LD_ADDR_VAR 0 8
85134: PUSH
85135: DOUBLE
85136: LD_INT 1
85138: DEC
85139: ST_TO_ADDR
85140: LD_VAR 0 9
85144: PUSH
85145: FOR_TO
85146: IFFALSE 85208
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
85148: LD_VAR 0 8
85152: PPUSH
85153: CALL_OW 266
85157: PUSH
85158: LD_INT 0
85160: PUSH
85161: LD_INT 1
85163: PUSH
85164: EMPTY
85165: LIST
85166: LIST
85167: IN
85168: IFFALSE 85206
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
85170: LD_VAR 0 4
85174: PUSH
85175: LD_VAR 0 7
85179: ARRAY
85180: PPUSH
85181: LD_VAR 0 14
85185: PUSH
85186: LD_VAR 0 8
85190: ARRAY
85191: PPUSH
85192: CALL_OW 115
// attacking := true ;
85196: LD_ADDR_VAR 0 29
85200: PUSH
85201: LD_INT 1
85203: ST_TO_ADDR
// break ;
85204: GO 85208
// end ;
85206: GO 85145
85208: POP
85209: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
85210: LD_VAR 0 4
85214: PUSH
85215: LD_VAR 0 7
85219: ARRAY
85220: PPUSH
85221: CALL_OW 302
85225: PUSH
85226: LD_VAR 0 29
85230: NOT
85231: AND
85232: IFFALSE 85554
// begin if GetTag ( group [ i ] ) = 71 then
85234: LD_VAR 0 4
85238: PUSH
85239: LD_VAR 0 7
85243: ARRAY
85244: PPUSH
85245: CALL_OW 110
85249: PUSH
85250: LD_INT 71
85252: EQUAL
85253: IFFALSE 85294
// begin if HasTask ( group [ i ] ) then
85255: LD_VAR 0 4
85259: PUSH
85260: LD_VAR 0 7
85264: ARRAY
85265: PPUSH
85266: CALL_OW 314
85270: IFFALSE 85276
// continue else
85272: GO 81433
85274: GO 85294
// SetTag ( group [ i ] , 0 ) ;
85276: LD_VAR 0 4
85280: PUSH
85281: LD_VAR 0 7
85285: ARRAY
85286: PPUSH
85287: LD_INT 0
85289: PPUSH
85290: CALL_OW 109
// end ; k := 8 ;
85294: LD_ADDR_VAR 0 9
85298: PUSH
85299: LD_INT 8
85301: ST_TO_ADDR
// x := 0 ;
85302: LD_ADDR_VAR 0 10
85306: PUSH
85307: LD_INT 0
85309: ST_TO_ADDR
// if tmp < k then
85310: LD_VAR 0 14
85314: PUSH
85315: LD_VAR 0 9
85319: LESS
85320: IFFALSE 85332
// k := tmp ;
85322: LD_ADDR_VAR 0 9
85326: PUSH
85327: LD_VAR 0 14
85331: ST_TO_ADDR
// for j = 1 to k do
85332: LD_ADDR_VAR 0 8
85336: PUSH
85337: DOUBLE
85338: LD_INT 1
85340: DEC
85341: ST_TO_ADDR
85342: LD_VAR 0 9
85346: PUSH
85347: FOR_TO
85348: IFFALSE 85446
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
85350: LD_VAR 0 14
85354: PUSH
85355: LD_VAR 0 8
85359: ARRAY
85360: PPUSH
85361: CALL_OW 247
85365: PUSH
85366: LD_INT 1
85368: EQUAL
85369: PUSH
85370: LD_VAR 0 14
85374: PUSH
85375: LD_VAR 0 8
85379: ARRAY
85380: PPUSH
85381: CALL_OW 256
85385: PUSH
85386: LD_INT 250
85388: LESS
85389: PUSH
85390: LD_VAR 0 20
85394: AND
85395: PUSH
85396: LD_VAR 0 20
85400: NOT
85401: PUSH
85402: LD_VAR 0 14
85406: PUSH
85407: LD_VAR 0 8
85411: ARRAY
85412: PPUSH
85413: CALL_OW 256
85417: PUSH
85418: LD_INT 250
85420: GREATEREQUAL
85421: AND
85422: OR
85423: AND
85424: IFFALSE 85444
// begin x := tmp [ j ] ;
85426: LD_ADDR_VAR 0 10
85430: PUSH
85431: LD_VAR 0 14
85435: PUSH
85436: LD_VAR 0 8
85440: ARRAY
85441: ST_TO_ADDR
// break ;
85442: GO 85446
// end ;
85444: GO 85347
85446: POP
85447: POP
// if x then
85448: LD_VAR 0 10
85452: IFFALSE 85476
// ComAttackUnit ( group [ i ] , x ) else
85454: LD_VAR 0 4
85458: PUSH
85459: LD_VAR 0 7
85463: ARRAY
85464: PPUSH
85465: LD_VAR 0 10
85469: PPUSH
85470: CALL_OW 115
85474: GO 85500
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
85476: LD_VAR 0 4
85480: PUSH
85481: LD_VAR 0 7
85485: ARRAY
85486: PPUSH
85487: LD_VAR 0 14
85491: PUSH
85492: LD_INT 1
85494: ARRAY
85495: PPUSH
85496: CALL_OW 115
// if not HasTask ( group [ i ] ) then
85500: LD_VAR 0 4
85504: PUSH
85505: LD_VAR 0 7
85509: ARRAY
85510: PPUSH
85511: CALL_OW 314
85515: NOT
85516: IFFALSE 85554
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
85518: LD_VAR 0 4
85522: PUSH
85523: LD_VAR 0 7
85527: ARRAY
85528: PPUSH
85529: LD_VAR 0 14
85533: PPUSH
85534: LD_VAR 0 4
85538: PUSH
85539: LD_VAR 0 7
85543: ARRAY
85544: PPUSH
85545: CALL_OW 74
85549: PPUSH
85550: CALL_OW 115
// end ; end ; end ;
85554: GO 81433
85556: POP
85557: POP
// wait ( 0 0$2 ) ;
85558: LD_INT 70
85560: PPUSH
85561: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
85565: LD_VAR 0 4
85569: NOT
85570: PUSH
85571: LD_VAR 0 4
85575: PUSH
85576: EMPTY
85577: EQUAL
85578: OR
85579: PUSH
85580: LD_INT 81
85582: PUSH
85583: LD_VAR 0 35
85587: PUSH
85588: EMPTY
85589: LIST
85590: LIST
85591: PPUSH
85592: CALL_OW 69
85596: NOT
85597: OR
85598: IFFALSE 81418
// end ;
85600: LD_VAR 0 2
85604: RET
// export function BasicDefend ( base , solds ) ; var enemy , e , side , i , hex ; begin
85605: LD_INT 0
85607: PPUSH
85608: PPUSH
85609: PPUSH
85610: PPUSH
85611: PPUSH
85612: PPUSH
// if not base or not mc_bases [ base ] or not solds then
85613: LD_VAR 0 1
85617: NOT
85618: PUSH
85619: LD_EXP 161
85623: PUSH
85624: LD_VAR 0 1
85628: ARRAY
85629: NOT
85630: OR
85631: PUSH
85632: LD_VAR 0 2
85636: NOT
85637: OR
85638: IFFALSE 85642
// exit ;
85640: GO 86196
// side := mc_sides [ base ] ;
85642: LD_ADDR_VAR 0 6
85646: PUSH
85647: LD_EXP 187
85651: PUSH
85652: LD_VAR 0 1
85656: ARRAY
85657: ST_TO_ADDR
// if not side then
85658: LD_VAR 0 6
85662: NOT
85663: IFFALSE 85667
// exit ;
85665: GO 86196
// for i in solds do
85667: LD_ADDR_VAR 0 7
85671: PUSH
85672: LD_VAR 0 2
85676: PUSH
85677: FOR_IN
85678: IFFALSE 85739
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
85680: LD_VAR 0 7
85684: PPUSH
85685: CALL_OW 310
85689: PPUSH
85690: CALL_OW 266
85694: PUSH
85695: LD_INT 32
85697: PUSH
85698: LD_INT 31
85700: PUSH
85701: EMPTY
85702: LIST
85703: LIST
85704: IN
85705: IFFALSE 85725
// solds := solds diff i else
85707: LD_ADDR_VAR 0 2
85711: PUSH
85712: LD_VAR 0 2
85716: PUSH
85717: LD_VAR 0 7
85721: DIFF
85722: ST_TO_ADDR
85723: GO 85737
// SetTag ( i , 18 ) ;
85725: LD_VAR 0 7
85729: PPUSH
85730: LD_INT 18
85732: PPUSH
85733: CALL_OW 109
85737: GO 85677
85739: POP
85740: POP
// if not solds then
85741: LD_VAR 0 2
85745: NOT
85746: IFFALSE 85750
// exit ;
85748: GO 86196
// repeat wait ( 0 0$2 ) ;
85750: LD_INT 70
85752: PPUSH
85753: CALL_OW 67
// enemy := mc_scan [ base ] ;
85757: LD_ADDR_VAR 0 4
85761: PUSH
85762: LD_EXP 184
85766: PUSH
85767: LD_VAR 0 1
85771: ARRAY
85772: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
85773: LD_EXP 161
85777: PUSH
85778: LD_VAR 0 1
85782: ARRAY
85783: NOT
85784: PUSH
85785: LD_EXP 161
85789: PUSH
85790: LD_VAR 0 1
85794: ARRAY
85795: PUSH
85796: EMPTY
85797: EQUAL
85798: OR
85799: IFFALSE 85836
// begin for i in solds do
85801: LD_ADDR_VAR 0 7
85805: PUSH
85806: LD_VAR 0 2
85810: PUSH
85811: FOR_IN
85812: IFFALSE 85825
// ComStop ( i ) ;
85814: LD_VAR 0 7
85818: PPUSH
85819: CALL_OW 141
85823: GO 85811
85825: POP
85826: POP
// solds := [ ] ;
85827: LD_ADDR_VAR 0 2
85831: PUSH
85832: EMPTY
85833: ST_TO_ADDR
// exit ;
85834: GO 86196
// end ; for i in solds do
85836: LD_ADDR_VAR 0 7
85840: PUSH
85841: LD_VAR 0 2
85845: PUSH
85846: FOR_IN
85847: IFFALSE 86168
// begin if IsInUnit ( i ) then
85849: LD_VAR 0 7
85853: PPUSH
85854: CALL_OW 310
85858: IFFALSE 85869
// ComExitBuilding ( i ) ;
85860: LD_VAR 0 7
85864: PPUSH
85865: CALL_OW 122
// if GetLives ( i ) > 500 then
85869: LD_VAR 0 7
85873: PPUSH
85874: CALL_OW 256
85878: PUSH
85879: LD_INT 500
85881: GREATER
85882: IFFALSE 85935
// begin e := NearestUnitToUnit ( enemy , i ) ;
85884: LD_ADDR_VAR 0 5
85888: PUSH
85889: LD_VAR 0 4
85893: PPUSH
85894: LD_VAR 0 7
85898: PPUSH
85899: CALL_OW 74
85903: ST_TO_ADDR
// ComAgressiveMove ( i , GetX ( e ) , GetY ( e ) ) ;
85904: LD_VAR 0 7
85908: PPUSH
85909: LD_VAR 0 5
85913: PPUSH
85914: CALL_OW 250
85918: PPUSH
85919: LD_VAR 0 5
85923: PPUSH
85924: CALL_OW 251
85928: PPUSH
85929: CALL_OW 114
// end else
85933: GO 86166
// if GetDistUnits ( i , NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ) > 10 then
85935: LD_VAR 0 7
85939: PPUSH
85940: LD_EXP 161
85944: PUSH
85945: LD_VAR 0 1
85949: ARRAY
85950: PPUSH
85951: LD_INT 2
85953: PUSH
85954: LD_INT 30
85956: PUSH
85957: LD_INT 0
85959: PUSH
85960: EMPTY
85961: LIST
85962: LIST
85963: PUSH
85964: LD_INT 30
85966: PUSH
85967: LD_INT 1
85969: PUSH
85970: EMPTY
85971: LIST
85972: LIST
85973: PUSH
85974: LD_INT 30
85976: PUSH
85977: LD_INT 6
85979: PUSH
85980: EMPTY
85981: LIST
85982: LIST
85983: PUSH
85984: EMPTY
85985: LIST
85986: LIST
85987: LIST
85988: LIST
85989: PPUSH
85990: CALL_OW 72
85994: PPUSH
85995: LD_VAR 0 7
85999: PPUSH
86000: CALL_OW 74
86004: PPUSH
86005: CALL_OW 296
86009: PUSH
86010: LD_INT 10
86012: GREATER
86013: IFFALSE 86166
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
86015: LD_ADDR_VAR 0 8
86019: PUSH
86020: LD_EXP 161
86024: PUSH
86025: LD_VAR 0 1
86029: ARRAY
86030: PPUSH
86031: LD_INT 2
86033: PUSH
86034: LD_INT 30
86036: PUSH
86037: LD_INT 0
86039: PUSH
86040: EMPTY
86041: LIST
86042: LIST
86043: PUSH
86044: LD_INT 30
86046: PUSH
86047: LD_INT 1
86049: PUSH
86050: EMPTY
86051: LIST
86052: LIST
86053: PUSH
86054: LD_INT 30
86056: PUSH
86057: LD_INT 6
86059: PUSH
86060: EMPTY
86061: LIST
86062: LIST
86063: PUSH
86064: EMPTY
86065: LIST
86066: LIST
86067: LIST
86068: LIST
86069: PPUSH
86070: CALL_OW 72
86074: PPUSH
86075: LD_VAR 0 7
86079: PPUSH
86080: CALL_OW 74
86084: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
86085: LD_VAR 0 7
86089: PPUSH
86090: LD_VAR 0 8
86094: PPUSH
86095: CALL_OW 250
86099: PPUSH
86100: LD_INT 3
86102: PPUSH
86103: LD_INT 5
86105: PPUSH
86106: CALL_OW 272
86110: PPUSH
86111: LD_VAR 0 8
86115: PPUSH
86116: CALL_OW 251
86120: PPUSH
86121: LD_INT 3
86123: PPUSH
86124: LD_INT 5
86126: PPUSH
86127: CALL_OW 273
86131: PPUSH
86132: CALL_OW 111
// SetTag ( i , 0 ) ;
86136: LD_VAR 0 7
86140: PPUSH
86141: LD_INT 0
86143: PPUSH
86144: CALL_OW 109
// solds := solds diff i ;
86148: LD_ADDR_VAR 0 2
86152: PUSH
86153: LD_VAR 0 2
86157: PUSH
86158: LD_VAR 0 7
86162: DIFF
86163: ST_TO_ADDR
// continue ;
86164: GO 85846
// end ; end ;
86166: GO 85846
86168: POP
86169: POP
// until not solds or not enemy ;
86170: LD_VAR 0 2
86174: NOT
86175: PUSH
86176: LD_VAR 0 4
86180: NOT
86181: OR
86182: IFFALSE 85750
// MC_Reset ( base , 18 ) ;
86184: LD_VAR 0 1
86188: PPUSH
86189: LD_INT 18
86191: PPUSH
86192: CALL 92358 0 2
// end ;
86196: LD_VAR 0 3
86200: RET
// export function Defend ( base , defenders ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend , class , enemy ; begin
86201: LD_INT 0
86203: PPUSH
86204: PPUSH
86205: PPUSH
86206: PPUSH
86207: PPUSH
86208: PPUSH
86209: PPUSH
86210: PPUSH
86211: PPUSH
86212: PPUSH
86213: PPUSH
86214: PPUSH
86215: PPUSH
86216: PPUSH
86217: PPUSH
86218: PPUSH
86219: PPUSH
86220: PPUSH
86221: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
86222: LD_ADDR_VAR 0 12
86226: PUSH
86227: LD_EXP 161
86231: PUSH
86232: LD_VAR 0 1
86236: ARRAY
86237: PPUSH
86238: LD_INT 25
86240: PUSH
86241: LD_INT 3
86243: PUSH
86244: EMPTY
86245: LIST
86246: LIST
86247: PPUSH
86248: CALL_OW 72
86252: ST_TO_ADDR
// if mc_remote_driver [ base ] then
86253: LD_EXP 201
86257: PUSH
86258: LD_VAR 0 1
86262: ARRAY
86263: IFFALSE 86287
// mechs := mechs diff mc_remote_driver [ base ] ;
86265: LD_ADDR_VAR 0 12
86269: PUSH
86270: LD_VAR 0 12
86274: PUSH
86275: LD_EXP 201
86279: PUSH
86280: LD_VAR 0 1
86284: ARRAY
86285: DIFF
86286: ST_TO_ADDR
// for i in mechs do
86287: LD_ADDR_VAR 0 4
86291: PUSH
86292: LD_VAR 0 12
86296: PUSH
86297: FOR_IN
86298: IFFALSE 86333
// if GetTag ( i ) > 0 then
86300: LD_VAR 0 4
86304: PPUSH
86305: CALL_OW 110
86309: PUSH
86310: LD_INT 0
86312: GREATER
86313: IFFALSE 86331
// mechs := mechs diff i ;
86315: LD_ADDR_VAR 0 12
86319: PUSH
86320: LD_VAR 0 12
86324: PUSH
86325: LD_VAR 0 4
86329: DIFF
86330: ST_TO_ADDR
86331: GO 86297
86333: POP
86334: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
86335: LD_ADDR_VAR 0 8
86339: PUSH
86340: LD_EXP 161
86344: PUSH
86345: LD_VAR 0 1
86349: ARRAY
86350: PPUSH
86351: LD_INT 2
86353: PUSH
86354: LD_INT 25
86356: PUSH
86357: LD_INT 1
86359: PUSH
86360: EMPTY
86361: LIST
86362: LIST
86363: PUSH
86364: LD_INT 25
86366: PUSH
86367: LD_INT 5
86369: PUSH
86370: EMPTY
86371: LIST
86372: LIST
86373: PUSH
86374: LD_INT 25
86376: PUSH
86377: LD_INT 8
86379: PUSH
86380: EMPTY
86381: LIST
86382: LIST
86383: PUSH
86384: LD_INT 25
86386: PUSH
86387: LD_INT 9
86389: PUSH
86390: EMPTY
86391: LIST
86392: LIST
86393: PUSH
86394: EMPTY
86395: LIST
86396: LIST
86397: LIST
86398: LIST
86399: LIST
86400: PPUSH
86401: CALL_OW 72
86405: ST_TO_ADDR
// if not defenders and not solds then
86406: LD_VAR 0 2
86410: NOT
86411: PUSH
86412: LD_VAR 0 8
86416: NOT
86417: AND
86418: IFFALSE 86422
// exit ;
86420: GO 88192
// depot_under_attack := false ;
86422: LD_ADDR_VAR 0 16
86426: PUSH
86427: LD_INT 0
86429: ST_TO_ADDR
// sold_defenders := [ ] ;
86430: LD_ADDR_VAR 0 17
86434: PUSH
86435: EMPTY
86436: ST_TO_ADDR
// if mechs then
86437: LD_VAR 0 12
86441: IFFALSE 86594
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
86443: LD_ADDR_VAR 0 4
86447: PUSH
86448: LD_VAR 0 2
86452: PPUSH
86453: LD_INT 21
86455: PUSH
86456: LD_INT 2
86458: PUSH
86459: EMPTY
86460: LIST
86461: LIST
86462: PPUSH
86463: CALL_OW 72
86467: PUSH
86468: FOR_IN
86469: IFFALSE 86592
// begin if GetTag ( i ) <> 20 then
86471: LD_VAR 0 4
86475: PPUSH
86476: CALL_OW 110
86480: PUSH
86481: LD_INT 20
86483: NONEQUAL
86484: IFFALSE 86498
// SetTag ( i , 20 ) ;
86486: LD_VAR 0 4
86490: PPUSH
86491: LD_INT 20
86493: PPUSH
86494: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
86498: LD_VAR 0 4
86502: PPUSH
86503: CALL_OW 263
86507: PUSH
86508: LD_INT 1
86510: EQUAL
86511: PUSH
86512: LD_VAR 0 4
86516: PPUSH
86517: CALL_OW 311
86521: NOT
86522: AND
86523: IFFALSE 86590
// begin un := mechs [ 1 ] ;
86525: LD_ADDR_VAR 0 10
86529: PUSH
86530: LD_VAR 0 12
86534: PUSH
86535: LD_INT 1
86537: ARRAY
86538: ST_TO_ADDR
// ComExit ( un ) ;
86539: LD_VAR 0 10
86543: PPUSH
86544: CALL 57090 0 1
// AddComEnterUnit ( un , i ) ;
86548: LD_VAR 0 10
86552: PPUSH
86553: LD_VAR 0 4
86557: PPUSH
86558: CALL_OW 180
// SetTag ( un , 19 ) ;
86562: LD_VAR 0 10
86566: PPUSH
86567: LD_INT 19
86569: PPUSH
86570: CALL_OW 109
// mechs := mechs diff un ;
86574: LD_ADDR_VAR 0 12
86578: PUSH
86579: LD_VAR 0 12
86583: PUSH
86584: LD_VAR 0 10
86588: DIFF
86589: ST_TO_ADDR
// end ; end ;
86590: GO 86468
86592: POP
86593: POP
// if solds then
86594: LD_VAR 0 8
86598: IFFALSE 86657
// for i in solds do
86600: LD_ADDR_VAR 0 4
86604: PUSH
86605: LD_VAR 0 8
86609: PUSH
86610: FOR_IN
86611: IFFALSE 86655
// if not GetTag ( i ) then
86613: LD_VAR 0 4
86617: PPUSH
86618: CALL_OW 110
86622: NOT
86623: IFFALSE 86653
// begin defenders := defenders union i ;
86625: LD_ADDR_VAR 0 2
86629: PUSH
86630: LD_VAR 0 2
86634: PUSH
86635: LD_VAR 0 4
86639: UNION
86640: ST_TO_ADDR
// SetTag ( i , 18 ) ;
86641: LD_VAR 0 4
86645: PPUSH
86646: LD_INT 18
86648: PPUSH
86649: CALL_OW 109
// end ;
86653: GO 86610
86655: POP
86656: POP
// repeat wait ( 0 0$2 ) ;
86657: LD_INT 70
86659: PPUSH
86660: CALL_OW 67
// enemy := mc_scan [ base ] ;
86664: LD_ADDR_VAR 0 21
86668: PUSH
86669: LD_EXP 184
86673: PUSH
86674: LD_VAR 0 1
86678: ARRAY
86679: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
86680: LD_EXP 161
86684: PUSH
86685: LD_VAR 0 1
86689: ARRAY
86690: NOT
86691: PUSH
86692: LD_EXP 161
86696: PUSH
86697: LD_VAR 0 1
86701: ARRAY
86702: PUSH
86703: EMPTY
86704: EQUAL
86705: OR
86706: IFFALSE 86743
// begin for i in defenders do
86708: LD_ADDR_VAR 0 4
86712: PUSH
86713: LD_VAR 0 2
86717: PUSH
86718: FOR_IN
86719: IFFALSE 86732
// ComStop ( i ) ;
86721: LD_VAR 0 4
86725: PPUSH
86726: CALL_OW 141
86730: GO 86718
86732: POP
86733: POP
// defenders := [ ] ;
86734: LD_ADDR_VAR 0 2
86738: PUSH
86739: EMPTY
86740: ST_TO_ADDR
// exit ;
86741: GO 88192
// end ; for i in defenders do
86743: LD_ADDR_VAR 0 4
86747: PUSH
86748: LD_VAR 0 2
86752: PUSH
86753: FOR_IN
86754: IFFALSE 87652
// begin e := NearestUnitToUnit ( enemy , i ) ;
86756: LD_ADDR_VAR 0 13
86760: PUSH
86761: LD_VAR 0 21
86765: PPUSH
86766: LD_VAR 0 4
86770: PPUSH
86771: CALL_OW 74
86775: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
86776: LD_ADDR_VAR 0 7
86780: PUSH
86781: LD_EXP 161
86785: PUSH
86786: LD_VAR 0 1
86790: ARRAY
86791: PPUSH
86792: LD_INT 2
86794: PUSH
86795: LD_INT 30
86797: PUSH
86798: LD_INT 0
86800: PUSH
86801: EMPTY
86802: LIST
86803: LIST
86804: PUSH
86805: LD_INT 30
86807: PUSH
86808: LD_INT 1
86810: PUSH
86811: EMPTY
86812: LIST
86813: LIST
86814: PUSH
86815: EMPTY
86816: LIST
86817: LIST
86818: LIST
86819: PPUSH
86820: CALL_OW 72
86824: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
86825: LD_ADDR_VAR 0 16
86829: PUSH
86830: LD_VAR 0 7
86834: NOT
86835: PUSH
86836: LD_VAR 0 7
86840: PPUSH
86841: LD_INT 3
86843: PUSH
86844: LD_INT 24
86846: PUSH
86847: LD_INT 600
86849: PUSH
86850: EMPTY
86851: LIST
86852: LIST
86853: PUSH
86854: EMPTY
86855: LIST
86856: LIST
86857: PPUSH
86858: CALL_OW 72
86862: OR
86863: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
86864: LD_VAR 0 4
86868: PPUSH
86869: CALL_OW 247
86873: PUSH
86874: LD_INT 2
86876: DOUBLE
86877: EQUAL
86878: IFTRUE 86882
86880: GO 87278
86882: POP
// begin if GetLives ( i ) = 1000 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
86883: LD_VAR 0 4
86887: PPUSH
86888: CALL_OW 256
86892: PUSH
86893: LD_INT 1000
86895: EQUAL
86896: PUSH
86897: LD_VAR 0 4
86901: PPUSH
86902: LD_VAR 0 13
86906: PPUSH
86907: CALL_OW 296
86911: PUSH
86912: LD_INT 40
86914: LESS
86915: PUSH
86916: LD_VAR 0 13
86920: PPUSH
86921: LD_EXP 186
86925: PUSH
86926: LD_VAR 0 1
86930: ARRAY
86931: PPUSH
86932: CALL_OW 308
86936: OR
86937: AND
86938: IFFALSE 87060
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
86940: LD_VAR 0 4
86944: PPUSH
86945: CALL_OW 262
86949: PUSH
86950: LD_INT 1
86952: EQUAL
86953: PUSH
86954: LD_VAR 0 4
86958: PPUSH
86959: CALL_OW 261
86963: PUSH
86964: LD_INT 30
86966: LESS
86967: AND
86968: PUSH
86969: LD_VAR 0 7
86973: AND
86974: IFFALSE 87044
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
86976: LD_VAR 0 4
86980: PPUSH
86981: LD_VAR 0 7
86985: PPUSH
86986: LD_VAR 0 4
86990: PPUSH
86991: CALL_OW 74
86995: PPUSH
86996: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
87000: LD_VAR 0 4
87004: PPUSH
87005: LD_VAR 0 7
87009: PPUSH
87010: LD_VAR 0 4
87014: PPUSH
87015: CALL_OW 74
87019: PPUSH
87020: CALL_OW 296
87024: PUSH
87025: LD_INT 6
87027: LESS
87028: IFFALSE 87042
// SetFuel ( i , 100 ) ;
87030: LD_VAR 0 4
87034: PPUSH
87035: LD_INT 100
87037: PPUSH
87038: CALL_OW 240
// end else
87042: GO 87058
// ComAttackUnit ( i , e ) ;
87044: LD_VAR 0 4
87048: PPUSH
87049: LD_VAR 0 13
87053: PPUSH
87054: CALL_OW 115
// end else
87058: GO 87161
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
87060: LD_VAR 0 13
87064: PPUSH
87065: LD_EXP 186
87069: PUSH
87070: LD_VAR 0 1
87074: ARRAY
87075: PPUSH
87076: CALL_OW 308
87080: NOT
87081: PUSH
87082: LD_VAR 0 4
87086: PPUSH
87087: LD_VAR 0 13
87091: PPUSH
87092: CALL_OW 296
87096: PUSH
87097: LD_INT 40
87099: GREATEREQUAL
87100: AND
87101: PUSH
87102: LD_VAR 0 4
87106: PPUSH
87107: CALL_OW 256
87111: PUSH
87112: LD_INT 650
87114: LESSEQUAL
87115: OR
87116: PUSH
87117: LD_VAR 0 4
87121: PPUSH
87122: LD_EXP 185
87126: PUSH
87127: LD_VAR 0 1
87131: ARRAY
87132: PPUSH
87133: CALL_OW 308
87137: NOT
87138: AND
87139: IFFALSE 87161
// ComMoveToArea ( i , mc_parking [ base ] ) ;
87141: LD_VAR 0 4
87145: PPUSH
87146: LD_EXP 185
87150: PUSH
87151: LD_VAR 0 1
87155: ARRAY
87156: PPUSH
87157: CALL_OW 113
// if GetLives ( i ) < 1000 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
87161: LD_VAR 0 4
87165: PPUSH
87166: CALL_OW 256
87170: PUSH
87171: LD_INT 1000
87173: LESS
87174: PUSH
87175: LD_VAR 0 4
87179: PPUSH
87180: CALL_OW 263
87184: PUSH
87185: LD_INT 1
87187: EQUAL
87188: AND
87189: PUSH
87190: LD_VAR 0 4
87194: PPUSH
87195: CALL_OW 311
87199: AND
87200: PUSH
87201: LD_VAR 0 4
87205: PPUSH
87206: LD_EXP 185
87210: PUSH
87211: LD_VAR 0 1
87215: ARRAY
87216: PPUSH
87217: CALL_OW 308
87221: AND
87222: IFFALSE 87276
// begin mech := IsDrivenBy ( i ) ;
87224: LD_ADDR_VAR 0 9
87228: PUSH
87229: LD_VAR 0 4
87233: PPUSH
87234: CALL_OW 311
87238: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
87239: LD_VAR 0 9
87243: PPUSH
87244: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
87248: LD_VAR 0 9
87252: PPUSH
87253: LD_VAR 0 4
87257: PPUSH
87258: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
87262: LD_VAR 0 9
87266: PPUSH
87267: LD_VAR 0 4
87271: PPUSH
87272: CALL_OW 180
// end ; end ; unit_human :
87276: GO 87623
87278: LD_INT 1
87280: DOUBLE
87281: EQUAL
87282: IFTRUE 87286
87284: GO 87622
87286: POP
// begin b := IsInUnit ( i ) ;
87287: LD_ADDR_VAR 0 18
87291: PUSH
87292: LD_VAR 0 4
87296: PPUSH
87297: CALL_OW 310
87301: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
87302: LD_ADDR_VAR 0 19
87306: PUSH
87307: LD_VAR 0 18
87311: NOT
87312: PUSH
87313: LD_VAR 0 18
87317: PPUSH
87318: CALL_OW 266
87322: PUSH
87323: LD_INT 32
87325: PUSH
87326: LD_INT 31
87328: PUSH
87329: EMPTY
87330: LIST
87331: LIST
87332: IN
87333: OR
87334: ST_TO_ADDR
// if GetBType ( b ) = b_barracks and GetClass ( i ) in [ 1 , 2 , 3 , 4 ] then
87335: LD_VAR 0 18
87339: PPUSH
87340: CALL_OW 266
87344: PUSH
87345: LD_INT 5
87347: EQUAL
87348: PUSH
87349: LD_VAR 0 4
87353: PPUSH
87354: CALL_OW 257
87358: PUSH
87359: LD_INT 1
87361: PUSH
87362: LD_INT 2
87364: PUSH
87365: LD_INT 3
87367: PUSH
87368: LD_INT 4
87370: PUSH
87371: EMPTY
87372: LIST
87373: LIST
87374: LIST
87375: LIST
87376: IN
87377: AND
87378: IFFALSE 87415
// begin class := AllowSpecClass ( i ) ;
87380: LD_ADDR_VAR 0 20
87384: PUSH
87385: LD_VAR 0 4
87389: PPUSH
87390: CALL 21010 0 1
87394: ST_TO_ADDR
// if class then
87395: LD_VAR 0 20
87399: IFFALSE 87415
// ComChangeProfession ( i , class ) ;
87401: LD_VAR 0 4
87405: PPUSH
87406: LD_VAR 0 20
87410: PPUSH
87411: CALL_OW 123
// end ; if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
87415: LD_VAR 0 16
87419: PUSH
87420: LD_VAR 0 2
87424: PPUSH
87425: LD_INT 21
87427: PUSH
87428: LD_INT 2
87430: PUSH
87431: EMPTY
87432: LIST
87433: LIST
87434: PPUSH
87435: CALL_OW 72
87439: PUSH
87440: LD_INT 1
87442: LESSEQUAL
87443: OR
87444: PUSH
87445: LD_VAR 0 19
87449: AND
87450: PUSH
87451: LD_VAR 0 4
87455: PUSH
87456: LD_VAR 0 17
87460: IN
87461: NOT
87462: AND
87463: IFFALSE 87556
// begin if b then
87465: LD_VAR 0 18
87469: IFFALSE 87518
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
87471: LD_VAR 0 18
87475: PPUSH
87476: LD_VAR 0 21
87480: PPUSH
87481: LD_VAR 0 18
87485: PPUSH
87486: CALL_OW 74
87490: PPUSH
87491: CALL_OW 296
87495: PUSH
87496: LD_INT 10
87498: LESS
87499: PUSH
87500: LD_VAR 0 18
87504: PPUSH
87505: CALL_OW 461
87509: PUSH
87510: LD_INT 7
87512: NONEQUAL
87513: AND
87514: IFFALSE 87518
// continue ;
87516: GO 86753
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
87518: LD_ADDR_VAR 0 17
87522: PUSH
87523: LD_VAR 0 17
87527: PPUSH
87528: LD_VAR 0 17
87532: PUSH
87533: LD_INT 1
87535: PLUS
87536: PPUSH
87537: LD_VAR 0 4
87541: PPUSH
87542: CALL_OW 1
87546: ST_TO_ADDR
// ComExitBuilding ( i ) ;
87547: LD_VAR 0 4
87551: PPUSH
87552: CALL_OW 122
// end ; if sold_defenders then
87556: LD_VAR 0 17
87560: IFFALSE 87620
// if i in sold_defenders then
87562: LD_VAR 0 4
87566: PUSH
87567: LD_VAR 0 17
87571: IN
87572: IFFALSE 87620
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
87574: LD_VAR 0 4
87578: PPUSH
87579: CALL_OW 314
87583: NOT
87584: PUSH
87585: LD_VAR 0 4
87589: PPUSH
87590: LD_VAR 0 13
87594: PPUSH
87595: CALL_OW 296
87599: PUSH
87600: LD_INT 30
87602: LESS
87603: AND
87604: IFFALSE 87620
// ComAttackUnit ( i , e ) ;
87606: LD_VAR 0 4
87610: PPUSH
87611: LD_VAR 0 13
87615: PPUSH
87616: CALL_OW 115
// end ; end ; end ;
87620: GO 87623
87622: POP
// if IsDead ( i ) then
87623: LD_VAR 0 4
87627: PPUSH
87628: CALL_OW 301
87632: IFFALSE 87650
// defenders := defenders diff i ;
87634: LD_ADDR_VAR 0 2
87638: PUSH
87639: LD_VAR 0 2
87643: PUSH
87644: LD_VAR 0 4
87648: DIFF
87649: ST_TO_ADDR
// end ;
87650: GO 86753
87652: POP
87653: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
87654: LD_VAR 0 21
87658: NOT
87659: PUSH
87660: LD_VAR 0 2
87664: NOT
87665: OR
87666: PUSH
87667: LD_EXP 161
87671: PUSH
87672: LD_VAR 0 1
87676: ARRAY
87677: NOT
87678: OR
87679: IFFALSE 86657
// MC_Reset ( base , 18 ) ;
87681: LD_VAR 0 1
87685: PPUSH
87686: LD_INT 18
87688: PPUSH
87689: CALL 92358 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
87693: LD_ADDR_VAR 0 2
87697: PUSH
87698: LD_VAR 0 2
87702: PUSH
87703: LD_VAR 0 2
87707: PPUSH
87708: LD_INT 2
87710: PUSH
87711: LD_INT 25
87713: PUSH
87714: LD_INT 1
87716: PUSH
87717: EMPTY
87718: LIST
87719: LIST
87720: PUSH
87721: LD_INT 25
87723: PUSH
87724: LD_INT 5
87726: PUSH
87727: EMPTY
87728: LIST
87729: LIST
87730: PUSH
87731: LD_INT 25
87733: PUSH
87734: LD_INT 8
87736: PUSH
87737: EMPTY
87738: LIST
87739: LIST
87740: PUSH
87741: LD_INT 25
87743: PUSH
87744: LD_INT 9
87746: PUSH
87747: EMPTY
87748: LIST
87749: LIST
87750: PUSH
87751: EMPTY
87752: LIST
87753: LIST
87754: LIST
87755: LIST
87756: LIST
87757: PPUSH
87758: CALL_OW 72
87762: DIFF
87763: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
87764: LD_VAR 0 21
87768: NOT
87769: PUSH
87770: LD_VAR 0 2
87774: PPUSH
87775: LD_INT 21
87777: PUSH
87778: LD_INT 2
87780: PUSH
87781: EMPTY
87782: LIST
87783: LIST
87784: PPUSH
87785: CALL_OW 72
87789: AND
87790: IFFALSE 88128
// begin tmp := FilterByTag ( defenders , 19 ) ;
87792: LD_ADDR_VAR 0 11
87796: PUSH
87797: LD_VAR 0 2
87801: PPUSH
87802: LD_INT 19
87804: PPUSH
87805: CALL 54273 0 2
87809: ST_TO_ADDR
// if tmp then
87810: LD_VAR 0 11
87814: IFFALSE 87884
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
87816: LD_ADDR_VAR 0 11
87820: PUSH
87821: LD_VAR 0 11
87825: PPUSH
87826: LD_INT 25
87828: PUSH
87829: LD_INT 3
87831: PUSH
87832: EMPTY
87833: LIST
87834: LIST
87835: PPUSH
87836: CALL_OW 72
87840: ST_TO_ADDR
// if tmp then
87841: LD_VAR 0 11
87845: IFFALSE 87884
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
87847: LD_ADDR_EXP 173
87851: PUSH
87852: LD_EXP 173
87856: PPUSH
87857: LD_VAR 0 1
87861: PPUSH
87862: LD_EXP 173
87866: PUSH
87867: LD_VAR 0 1
87871: ARRAY
87872: PUSH
87873: LD_VAR 0 11
87877: UNION
87878: PPUSH
87879: CALL_OW 1
87883: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
87884: LD_VAR 0 1
87888: PPUSH
87889: LD_INT 19
87891: PPUSH
87892: CALL 92358 0 2
// repeat wait ( 0 0$1 ) ;
87896: LD_INT 35
87898: PPUSH
87899: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
87903: LD_EXP 161
87907: PUSH
87908: LD_VAR 0 1
87912: ARRAY
87913: NOT
87914: PUSH
87915: LD_EXP 161
87919: PUSH
87920: LD_VAR 0 1
87924: ARRAY
87925: PUSH
87926: EMPTY
87927: EQUAL
87928: OR
87929: IFFALSE 87966
// begin for i in defenders do
87931: LD_ADDR_VAR 0 4
87935: PUSH
87936: LD_VAR 0 2
87940: PUSH
87941: FOR_IN
87942: IFFALSE 87955
// ComStop ( i ) ;
87944: LD_VAR 0 4
87948: PPUSH
87949: CALL_OW 141
87953: GO 87941
87955: POP
87956: POP
// defenders := [ ] ;
87957: LD_ADDR_VAR 0 2
87961: PUSH
87962: EMPTY
87963: ST_TO_ADDR
// exit ;
87964: GO 88192
// end ; for i in defenders do
87966: LD_ADDR_VAR 0 4
87970: PUSH
87971: LD_VAR 0 2
87975: PUSH
87976: FOR_IN
87977: IFFALSE 88066
// begin if not IsInArea ( i , mc_parking [ base ] ) then
87979: LD_VAR 0 4
87983: PPUSH
87984: LD_EXP 185
87988: PUSH
87989: LD_VAR 0 1
87993: ARRAY
87994: PPUSH
87995: CALL_OW 308
87999: NOT
88000: IFFALSE 88024
// ComMoveToArea ( i , mc_parking [ base ] ) else
88002: LD_VAR 0 4
88006: PPUSH
88007: LD_EXP 185
88011: PUSH
88012: LD_VAR 0 1
88016: ARRAY
88017: PPUSH
88018: CALL_OW 113
88022: GO 88064
// if GetControl ( i ) = control_manual then
88024: LD_VAR 0 4
88028: PPUSH
88029: CALL_OW 263
88033: PUSH
88034: LD_INT 1
88036: EQUAL
88037: IFFALSE 88064
// if IsDrivenBy ( i ) then
88039: LD_VAR 0 4
88043: PPUSH
88044: CALL_OW 311
88048: IFFALSE 88064
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
88050: LD_VAR 0 4
88054: PPUSH
88055: CALL_OW 311
88059: PPUSH
88060: CALL_OW 121
// end ;
88064: GO 87976
88066: POP
88067: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
88068: LD_VAR 0 2
88072: PPUSH
88073: LD_INT 95
88075: PUSH
88076: LD_EXP 185
88080: PUSH
88081: LD_VAR 0 1
88085: ARRAY
88086: PUSH
88087: EMPTY
88088: LIST
88089: LIST
88090: PPUSH
88091: CALL_OW 72
88095: PUSH
88096: LD_VAR 0 2
88100: EQUAL
88101: PUSH
88102: LD_EXP 184
88106: PUSH
88107: LD_VAR 0 1
88111: ARRAY
88112: OR
88113: PUSH
88114: LD_EXP 161
88118: PUSH
88119: LD_VAR 0 1
88123: ARRAY
88124: NOT
88125: OR
88126: IFFALSE 87896
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
88128: LD_ADDR_EXP 183
88132: PUSH
88133: LD_EXP 183
88137: PPUSH
88138: LD_VAR 0 1
88142: PPUSH
88143: LD_VAR 0 2
88147: PPUSH
88148: LD_INT 21
88150: PUSH
88151: LD_INT 2
88153: PUSH
88154: EMPTY
88155: LIST
88156: LIST
88157: PPUSH
88158: CALL_OW 72
88162: PPUSH
88163: CALL_OW 1
88167: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
88168: LD_VAR 0 1
88172: PPUSH
88173: LD_INT 19
88175: PPUSH
88176: CALL 92358 0 2
// MC_Reset ( base , 20 ) ;
88180: LD_VAR 0 1
88184: PPUSH
88185: LD_INT 20
88187: PPUSH
88188: CALL 92358 0 2
// end ; end_of_file
88192: LD_VAR 0 3
88196: RET
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use , mc_is_defending ; export function InitMacro ; var i ; begin
88197: LD_INT 0
88199: PPUSH
88200: PPUSH
// skirmish := false ;
88201: LD_ADDR_EXP 159
88205: PUSH
88206: LD_INT 0
88208: ST_TO_ADDR
// debug_mc := false ;
88209: LD_ADDR_EXP 160
88213: PUSH
88214: LD_INT 0
88216: ST_TO_ADDR
// mc_bases := [ ] ;
88217: LD_ADDR_EXP 161
88221: PUSH
88222: EMPTY
88223: ST_TO_ADDR
// mc_sides := [ ] ;
88224: LD_ADDR_EXP 187
88228: PUSH
88229: EMPTY
88230: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
88231: LD_ADDR_EXP 162
88235: PUSH
88236: EMPTY
88237: ST_TO_ADDR
// mc_building_repairs := [ ] ;
88238: LD_ADDR_EXP 163
88242: PUSH
88243: EMPTY
88244: ST_TO_ADDR
// mc_need_heal := [ ] ;
88245: LD_ADDR_EXP 164
88249: PUSH
88250: EMPTY
88251: ST_TO_ADDR
// mc_healers := [ ] ;
88252: LD_ADDR_EXP 165
88256: PUSH
88257: EMPTY
88258: ST_TO_ADDR
// mc_build_list := [ ] ;
88259: LD_ADDR_EXP 166
88263: PUSH
88264: EMPTY
88265: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
88266: LD_ADDR_EXP 193
88270: PUSH
88271: EMPTY
88272: ST_TO_ADDR
// mc_builders := [ ] ;
88273: LD_ADDR_EXP 167
88277: PUSH
88278: EMPTY
88279: ST_TO_ADDR
// mc_construct_list := [ ] ;
88280: LD_ADDR_EXP 168
88284: PUSH
88285: EMPTY
88286: ST_TO_ADDR
// mc_turret_list := [ ] ;
88287: LD_ADDR_EXP 169
88291: PUSH
88292: EMPTY
88293: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
88294: LD_ADDR_EXP 170
88298: PUSH
88299: EMPTY
88300: ST_TO_ADDR
// mc_miners := [ ] ;
88301: LD_ADDR_EXP 175
88305: PUSH
88306: EMPTY
88307: ST_TO_ADDR
// mc_mines := [ ] ;
88308: LD_ADDR_EXP 174
88312: PUSH
88313: EMPTY
88314: ST_TO_ADDR
// mc_minefields := [ ] ;
88315: LD_ADDR_EXP 176
88319: PUSH
88320: EMPTY
88321: ST_TO_ADDR
// mc_crates := [ ] ;
88322: LD_ADDR_EXP 177
88326: PUSH
88327: EMPTY
88328: ST_TO_ADDR
// mc_crates_collector := [ ] ;
88329: LD_ADDR_EXP 178
88333: PUSH
88334: EMPTY
88335: ST_TO_ADDR
// mc_crates_area := [ ] ;
88336: LD_ADDR_EXP 179
88340: PUSH
88341: EMPTY
88342: ST_TO_ADDR
// mc_vehicles := [ ] ;
88343: LD_ADDR_EXP 180
88347: PUSH
88348: EMPTY
88349: ST_TO_ADDR
// mc_attack := [ ] ;
88350: LD_ADDR_EXP 181
88354: PUSH
88355: EMPTY
88356: ST_TO_ADDR
// mc_produce := [ ] ;
88357: LD_ADDR_EXP 182
88361: PUSH
88362: EMPTY
88363: ST_TO_ADDR
// mc_defender := [ ] ;
88364: LD_ADDR_EXP 183
88368: PUSH
88369: EMPTY
88370: ST_TO_ADDR
// mc_parking := [ ] ;
88371: LD_ADDR_EXP 185
88375: PUSH
88376: EMPTY
88377: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
88378: LD_ADDR_EXP 171
88382: PUSH
88383: EMPTY
88384: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
88385: LD_ADDR_EXP 173
88389: PUSH
88390: EMPTY
88391: ST_TO_ADDR
// mc_scan := [ ] ;
88392: LD_ADDR_EXP 184
88396: PUSH
88397: EMPTY
88398: ST_TO_ADDR
// mc_scan_area := [ ] ;
88399: LD_ADDR_EXP 186
88403: PUSH
88404: EMPTY
88405: ST_TO_ADDR
// mc_tech := [ ] ;
88406: LD_ADDR_EXP 188
88410: PUSH
88411: EMPTY
88412: ST_TO_ADDR
// mc_class := [ ] ;
88413: LD_ADDR_EXP 202
88417: PUSH
88418: EMPTY
88419: ST_TO_ADDR
// mc_class_case_use := [ ] ;
88420: LD_ADDR_EXP 203
88424: PUSH
88425: EMPTY
88426: ST_TO_ADDR
// mc_is_defending := [ ] ;
88427: LD_ADDR_EXP 204
88431: PUSH
88432: EMPTY
88433: ST_TO_ADDR
// mc_lab_upgrade := [ ] ;
88434: LD_ADDR_EXP 195
88438: PUSH
88439: EMPTY
88440: ST_TO_ADDR
// end ;
88441: LD_VAR 0 1
88445: RET
// export function MC_Kill ( base ) ; begin
88446: LD_INT 0
88448: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
88449: LD_ADDR_EXP 161
88453: PUSH
88454: LD_EXP 161
88458: PPUSH
88459: LD_VAR 0 1
88463: PPUSH
88464: EMPTY
88465: PPUSH
88466: CALL_OW 1
88470: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
88471: LD_ADDR_EXP 162
88475: PUSH
88476: LD_EXP 162
88480: PPUSH
88481: LD_VAR 0 1
88485: PPUSH
88486: EMPTY
88487: PPUSH
88488: CALL_OW 1
88492: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
88493: LD_ADDR_EXP 163
88497: PUSH
88498: LD_EXP 163
88502: PPUSH
88503: LD_VAR 0 1
88507: PPUSH
88508: EMPTY
88509: PPUSH
88510: CALL_OW 1
88514: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
88515: LD_ADDR_EXP 164
88519: PUSH
88520: LD_EXP 164
88524: PPUSH
88525: LD_VAR 0 1
88529: PPUSH
88530: EMPTY
88531: PPUSH
88532: CALL_OW 1
88536: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
88537: LD_ADDR_EXP 165
88541: PUSH
88542: LD_EXP 165
88546: PPUSH
88547: LD_VAR 0 1
88551: PPUSH
88552: EMPTY
88553: PPUSH
88554: CALL_OW 1
88558: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
88559: LD_ADDR_EXP 166
88563: PUSH
88564: LD_EXP 166
88568: PPUSH
88569: LD_VAR 0 1
88573: PPUSH
88574: EMPTY
88575: PPUSH
88576: CALL_OW 1
88580: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
88581: LD_ADDR_EXP 167
88585: PUSH
88586: LD_EXP 167
88590: PPUSH
88591: LD_VAR 0 1
88595: PPUSH
88596: EMPTY
88597: PPUSH
88598: CALL_OW 1
88602: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
88603: LD_ADDR_EXP 168
88607: PUSH
88608: LD_EXP 168
88612: PPUSH
88613: LD_VAR 0 1
88617: PPUSH
88618: EMPTY
88619: PPUSH
88620: CALL_OW 1
88624: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
88625: LD_ADDR_EXP 169
88629: PUSH
88630: LD_EXP 169
88634: PPUSH
88635: LD_VAR 0 1
88639: PPUSH
88640: EMPTY
88641: PPUSH
88642: CALL_OW 1
88646: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
88647: LD_ADDR_EXP 170
88651: PUSH
88652: LD_EXP 170
88656: PPUSH
88657: LD_VAR 0 1
88661: PPUSH
88662: EMPTY
88663: PPUSH
88664: CALL_OW 1
88668: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
88669: LD_ADDR_EXP 171
88673: PUSH
88674: LD_EXP 171
88678: PPUSH
88679: LD_VAR 0 1
88683: PPUSH
88684: EMPTY
88685: PPUSH
88686: CALL_OW 1
88690: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
88691: LD_ADDR_EXP 172
88695: PUSH
88696: LD_EXP 172
88700: PPUSH
88701: LD_VAR 0 1
88705: PPUSH
88706: LD_INT 0
88708: PPUSH
88709: CALL_OW 1
88713: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
88714: LD_ADDR_EXP 173
88718: PUSH
88719: LD_EXP 173
88723: PPUSH
88724: LD_VAR 0 1
88728: PPUSH
88729: EMPTY
88730: PPUSH
88731: CALL_OW 1
88735: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
88736: LD_ADDR_EXP 174
88740: PUSH
88741: LD_EXP 174
88745: PPUSH
88746: LD_VAR 0 1
88750: PPUSH
88751: EMPTY
88752: PPUSH
88753: CALL_OW 1
88757: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
88758: LD_ADDR_EXP 175
88762: PUSH
88763: LD_EXP 175
88767: PPUSH
88768: LD_VAR 0 1
88772: PPUSH
88773: EMPTY
88774: PPUSH
88775: CALL_OW 1
88779: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
88780: LD_ADDR_EXP 176
88784: PUSH
88785: LD_EXP 176
88789: PPUSH
88790: LD_VAR 0 1
88794: PPUSH
88795: EMPTY
88796: PPUSH
88797: CALL_OW 1
88801: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
88802: LD_ADDR_EXP 177
88806: PUSH
88807: LD_EXP 177
88811: PPUSH
88812: LD_VAR 0 1
88816: PPUSH
88817: EMPTY
88818: PPUSH
88819: CALL_OW 1
88823: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
88824: LD_ADDR_EXP 178
88828: PUSH
88829: LD_EXP 178
88833: PPUSH
88834: LD_VAR 0 1
88838: PPUSH
88839: EMPTY
88840: PPUSH
88841: CALL_OW 1
88845: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
88846: LD_ADDR_EXP 179
88850: PUSH
88851: LD_EXP 179
88855: PPUSH
88856: LD_VAR 0 1
88860: PPUSH
88861: EMPTY
88862: PPUSH
88863: CALL_OW 1
88867: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
88868: LD_ADDR_EXP 180
88872: PUSH
88873: LD_EXP 180
88877: PPUSH
88878: LD_VAR 0 1
88882: PPUSH
88883: EMPTY
88884: PPUSH
88885: CALL_OW 1
88889: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
88890: LD_ADDR_EXP 181
88894: PUSH
88895: LD_EXP 181
88899: PPUSH
88900: LD_VAR 0 1
88904: PPUSH
88905: EMPTY
88906: PPUSH
88907: CALL_OW 1
88911: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
88912: LD_ADDR_EXP 182
88916: PUSH
88917: LD_EXP 182
88921: PPUSH
88922: LD_VAR 0 1
88926: PPUSH
88927: EMPTY
88928: PPUSH
88929: CALL_OW 1
88933: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
88934: LD_ADDR_EXP 183
88938: PUSH
88939: LD_EXP 183
88943: PPUSH
88944: LD_VAR 0 1
88948: PPUSH
88949: EMPTY
88950: PPUSH
88951: CALL_OW 1
88955: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
88956: LD_ADDR_EXP 184
88960: PUSH
88961: LD_EXP 184
88965: PPUSH
88966: LD_VAR 0 1
88970: PPUSH
88971: EMPTY
88972: PPUSH
88973: CALL_OW 1
88977: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
88978: LD_ADDR_EXP 185
88982: PUSH
88983: LD_EXP 185
88987: PPUSH
88988: LD_VAR 0 1
88992: PPUSH
88993: EMPTY
88994: PPUSH
88995: CALL_OW 1
88999: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
89000: LD_ADDR_EXP 186
89004: PUSH
89005: LD_EXP 186
89009: PPUSH
89010: LD_VAR 0 1
89014: PPUSH
89015: EMPTY
89016: PPUSH
89017: CALL_OW 1
89021: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
89022: LD_ADDR_EXP 188
89026: PUSH
89027: LD_EXP 188
89031: PPUSH
89032: LD_VAR 0 1
89036: PPUSH
89037: EMPTY
89038: PPUSH
89039: CALL_OW 1
89043: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
89044: LD_ADDR_EXP 190
89048: PUSH
89049: LD_EXP 190
89053: PPUSH
89054: LD_VAR 0 1
89058: PPUSH
89059: EMPTY
89060: PPUSH
89061: CALL_OW 1
89065: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
89066: LD_ADDR_EXP 191
89070: PUSH
89071: LD_EXP 191
89075: PPUSH
89076: LD_VAR 0 1
89080: PPUSH
89081: EMPTY
89082: PPUSH
89083: CALL_OW 1
89087: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
89088: LD_ADDR_EXP 192
89092: PUSH
89093: LD_EXP 192
89097: PPUSH
89098: LD_VAR 0 1
89102: PPUSH
89103: EMPTY
89104: PPUSH
89105: CALL_OW 1
89109: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
89110: LD_ADDR_EXP 193
89114: PUSH
89115: LD_EXP 193
89119: PPUSH
89120: LD_VAR 0 1
89124: PPUSH
89125: EMPTY
89126: PPUSH
89127: CALL_OW 1
89131: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
89132: LD_ADDR_EXP 194
89136: PUSH
89137: LD_EXP 194
89141: PPUSH
89142: LD_VAR 0 1
89146: PPUSH
89147: EMPTY
89148: PPUSH
89149: CALL_OW 1
89153: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
89154: LD_ADDR_EXP 195
89158: PUSH
89159: LD_EXP 195
89163: PPUSH
89164: LD_VAR 0 1
89168: PPUSH
89169: EMPTY
89170: PPUSH
89171: CALL_OW 1
89175: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
89176: LD_ADDR_EXP 196
89180: PUSH
89181: LD_EXP 196
89185: PPUSH
89186: LD_VAR 0 1
89190: PPUSH
89191: EMPTY
89192: PPUSH
89193: CALL_OW 1
89197: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
89198: LD_ADDR_EXP 197
89202: PUSH
89203: LD_EXP 197
89207: PPUSH
89208: LD_VAR 0 1
89212: PPUSH
89213: EMPTY
89214: PPUSH
89215: CALL_OW 1
89219: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
89220: LD_ADDR_EXP 198
89224: PUSH
89225: LD_EXP 198
89229: PPUSH
89230: LD_VAR 0 1
89234: PPUSH
89235: EMPTY
89236: PPUSH
89237: CALL_OW 1
89241: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
89242: LD_ADDR_EXP 199
89246: PUSH
89247: LD_EXP 199
89251: PPUSH
89252: LD_VAR 0 1
89256: PPUSH
89257: EMPTY
89258: PPUSH
89259: CALL_OW 1
89263: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
89264: LD_ADDR_EXP 200
89268: PUSH
89269: LD_EXP 200
89273: PPUSH
89274: LD_VAR 0 1
89278: PPUSH
89279: EMPTY
89280: PPUSH
89281: CALL_OW 1
89285: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
89286: LD_ADDR_EXP 201
89290: PUSH
89291: LD_EXP 201
89295: PPUSH
89296: LD_VAR 0 1
89300: PPUSH
89301: EMPTY
89302: PPUSH
89303: CALL_OW 1
89307: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
89308: LD_ADDR_EXP 202
89312: PUSH
89313: LD_EXP 202
89317: PPUSH
89318: LD_VAR 0 1
89322: PPUSH
89323: EMPTY
89324: PPUSH
89325: CALL_OW 1
89329: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
89330: LD_ADDR_EXP 203
89334: PUSH
89335: LD_EXP 203
89339: PPUSH
89340: LD_VAR 0 1
89344: PPUSH
89345: LD_INT 0
89347: PPUSH
89348: CALL_OW 1
89352: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
89353: LD_ADDR_EXP 204
89357: PUSH
89358: LD_EXP 204
89362: PPUSH
89363: LD_VAR 0 1
89367: PPUSH
89368: LD_INT 0
89370: PPUSH
89371: CALL_OW 1
89375: ST_TO_ADDR
// end ;
89376: LD_VAR 0 2
89380: RET
// export function MC_Add ( side , units ) ; var base ; begin
89381: LD_INT 0
89383: PPUSH
89384: PPUSH
// base := mc_bases + 1 ;
89385: LD_ADDR_VAR 0 4
89389: PUSH
89390: LD_EXP 161
89394: PUSH
89395: LD_INT 1
89397: PLUS
89398: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
89399: LD_ADDR_EXP 187
89403: PUSH
89404: LD_EXP 187
89408: PPUSH
89409: LD_VAR 0 4
89413: PPUSH
89414: LD_VAR 0 1
89418: PPUSH
89419: CALL_OW 1
89423: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
89424: LD_ADDR_EXP 161
89428: PUSH
89429: LD_EXP 161
89433: PPUSH
89434: LD_VAR 0 4
89438: PPUSH
89439: LD_VAR 0 2
89443: PPUSH
89444: CALL_OW 1
89448: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
89449: LD_ADDR_EXP 162
89453: PUSH
89454: LD_EXP 162
89458: PPUSH
89459: LD_VAR 0 4
89463: PPUSH
89464: EMPTY
89465: PPUSH
89466: CALL_OW 1
89470: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
89471: LD_ADDR_EXP 163
89475: PUSH
89476: LD_EXP 163
89480: PPUSH
89481: LD_VAR 0 4
89485: PPUSH
89486: EMPTY
89487: PPUSH
89488: CALL_OW 1
89492: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
89493: LD_ADDR_EXP 164
89497: PUSH
89498: LD_EXP 164
89502: PPUSH
89503: LD_VAR 0 4
89507: PPUSH
89508: EMPTY
89509: PPUSH
89510: CALL_OW 1
89514: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
89515: LD_ADDR_EXP 165
89519: PUSH
89520: LD_EXP 165
89524: PPUSH
89525: LD_VAR 0 4
89529: PPUSH
89530: EMPTY
89531: PPUSH
89532: CALL_OW 1
89536: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
89537: LD_ADDR_EXP 166
89541: PUSH
89542: LD_EXP 166
89546: PPUSH
89547: LD_VAR 0 4
89551: PPUSH
89552: EMPTY
89553: PPUSH
89554: CALL_OW 1
89558: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
89559: LD_ADDR_EXP 167
89563: PUSH
89564: LD_EXP 167
89568: PPUSH
89569: LD_VAR 0 4
89573: PPUSH
89574: EMPTY
89575: PPUSH
89576: CALL_OW 1
89580: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
89581: LD_ADDR_EXP 168
89585: PUSH
89586: LD_EXP 168
89590: PPUSH
89591: LD_VAR 0 4
89595: PPUSH
89596: EMPTY
89597: PPUSH
89598: CALL_OW 1
89602: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
89603: LD_ADDR_EXP 169
89607: PUSH
89608: LD_EXP 169
89612: PPUSH
89613: LD_VAR 0 4
89617: PPUSH
89618: EMPTY
89619: PPUSH
89620: CALL_OW 1
89624: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
89625: LD_ADDR_EXP 170
89629: PUSH
89630: LD_EXP 170
89634: PPUSH
89635: LD_VAR 0 4
89639: PPUSH
89640: EMPTY
89641: PPUSH
89642: CALL_OW 1
89646: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
89647: LD_ADDR_EXP 171
89651: PUSH
89652: LD_EXP 171
89656: PPUSH
89657: LD_VAR 0 4
89661: PPUSH
89662: EMPTY
89663: PPUSH
89664: CALL_OW 1
89668: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
89669: LD_ADDR_EXP 172
89673: PUSH
89674: LD_EXP 172
89678: PPUSH
89679: LD_VAR 0 4
89683: PPUSH
89684: LD_INT 0
89686: PPUSH
89687: CALL_OW 1
89691: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
89692: LD_ADDR_EXP 173
89696: PUSH
89697: LD_EXP 173
89701: PPUSH
89702: LD_VAR 0 4
89706: PPUSH
89707: EMPTY
89708: PPUSH
89709: CALL_OW 1
89713: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
89714: LD_ADDR_EXP 174
89718: PUSH
89719: LD_EXP 174
89723: PPUSH
89724: LD_VAR 0 4
89728: PPUSH
89729: EMPTY
89730: PPUSH
89731: CALL_OW 1
89735: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
89736: LD_ADDR_EXP 175
89740: PUSH
89741: LD_EXP 175
89745: PPUSH
89746: LD_VAR 0 4
89750: PPUSH
89751: EMPTY
89752: PPUSH
89753: CALL_OW 1
89757: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
89758: LD_ADDR_EXP 176
89762: PUSH
89763: LD_EXP 176
89767: PPUSH
89768: LD_VAR 0 4
89772: PPUSH
89773: EMPTY
89774: PPUSH
89775: CALL_OW 1
89779: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
89780: LD_ADDR_EXP 177
89784: PUSH
89785: LD_EXP 177
89789: PPUSH
89790: LD_VAR 0 4
89794: PPUSH
89795: EMPTY
89796: PPUSH
89797: CALL_OW 1
89801: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
89802: LD_ADDR_EXP 178
89806: PUSH
89807: LD_EXP 178
89811: PPUSH
89812: LD_VAR 0 4
89816: PPUSH
89817: EMPTY
89818: PPUSH
89819: CALL_OW 1
89823: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
89824: LD_ADDR_EXP 179
89828: PUSH
89829: LD_EXP 179
89833: PPUSH
89834: LD_VAR 0 4
89838: PPUSH
89839: EMPTY
89840: PPUSH
89841: CALL_OW 1
89845: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
89846: LD_ADDR_EXP 180
89850: PUSH
89851: LD_EXP 180
89855: PPUSH
89856: LD_VAR 0 4
89860: PPUSH
89861: EMPTY
89862: PPUSH
89863: CALL_OW 1
89867: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
89868: LD_ADDR_EXP 181
89872: PUSH
89873: LD_EXP 181
89877: PPUSH
89878: LD_VAR 0 4
89882: PPUSH
89883: EMPTY
89884: PPUSH
89885: CALL_OW 1
89889: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
89890: LD_ADDR_EXP 182
89894: PUSH
89895: LD_EXP 182
89899: PPUSH
89900: LD_VAR 0 4
89904: PPUSH
89905: EMPTY
89906: PPUSH
89907: CALL_OW 1
89911: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
89912: LD_ADDR_EXP 183
89916: PUSH
89917: LD_EXP 183
89921: PPUSH
89922: LD_VAR 0 4
89926: PPUSH
89927: EMPTY
89928: PPUSH
89929: CALL_OW 1
89933: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
89934: LD_ADDR_EXP 184
89938: PUSH
89939: LD_EXP 184
89943: PPUSH
89944: LD_VAR 0 4
89948: PPUSH
89949: EMPTY
89950: PPUSH
89951: CALL_OW 1
89955: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
89956: LD_ADDR_EXP 185
89960: PUSH
89961: LD_EXP 185
89965: PPUSH
89966: LD_VAR 0 4
89970: PPUSH
89971: EMPTY
89972: PPUSH
89973: CALL_OW 1
89977: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
89978: LD_ADDR_EXP 186
89982: PUSH
89983: LD_EXP 186
89987: PPUSH
89988: LD_VAR 0 4
89992: PPUSH
89993: EMPTY
89994: PPUSH
89995: CALL_OW 1
89999: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
90000: LD_ADDR_EXP 188
90004: PUSH
90005: LD_EXP 188
90009: PPUSH
90010: LD_VAR 0 4
90014: PPUSH
90015: EMPTY
90016: PPUSH
90017: CALL_OW 1
90021: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
90022: LD_ADDR_EXP 190
90026: PUSH
90027: LD_EXP 190
90031: PPUSH
90032: LD_VAR 0 4
90036: PPUSH
90037: EMPTY
90038: PPUSH
90039: CALL_OW 1
90043: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
90044: LD_ADDR_EXP 191
90048: PUSH
90049: LD_EXP 191
90053: PPUSH
90054: LD_VAR 0 4
90058: PPUSH
90059: EMPTY
90060: PPUSH
90061: CALL_OW 1
90065: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
90066: LD_ADDR_EXP 192
90070: PUSH
90071: LD_EXP 192
90075: PPUSH
90076: LD_VAR 0 4
90080: PPUSH
90081: EMPTY
90082: PPUSH
90083: CALL_OW 1
90087: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
90088: LD_ADDR_EXP 193
90092: PUSH
90093: LD_EXP 193
90097: PPUSH
90098: LD_VAR 0 4
90102: PPUSH
90103: EMPTY
90104: PPUSH
90105: CALL_OW 1
90109: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
90110: LD_ADDR_EXP 194
90114: PUSH
90115: LD_EXP 194
90119: PPUSH
90120: LD_VAR 0 4
90124: PPUSH
90125: EMPTY
90126: PPUSH
90127: CALL_OW 1
90131: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
90132: LD_ADDR_EXP 195
90136: PUSH
90137: LD_EXP 195
90141: PPUSH
90142: LD_VAR 0 4
90146: PPUSH
90147: EMPTY
90148: PPUSH
90149: CALL_OW 1
90153: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
90154: LD_ADDR_EXP 196
90158: PUSH
90159: LD_EXP 196
90163: PPUSH
90164: LD_VAR 0 4
90168: PPUSH
90169: EMPTY
90170: PPUSH
90171: CALL_OW 1
90175: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
90176: LD_ADDR_EXP 197
90180: PUSH
90181: LD_EXP 197
90185: PPUSH
90186: LD_VAR 0 4
90190: PPUSH
90191: EMPTY
90192: PPUSH
90193: CALL_OW 1
90197: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
90198: LD_ADDR_EXP 198
90202: PUSH
90203: LD_EXP 198
90207: PPUSH
90208: LD_VAR 0 4
90212: PPUSH
90213: EMPTY
90214: PPUSH
90215: CALL_OW 1
90219: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
90220: LD_ADDR_EXP 199
90224: PUSH
90225: LD_EXP 199
90229: PPUSH
90230: LD_VAR 0 4
90234: PPUSH
90235: EMPTY
90236: PPUSH
90237: CALL_OW 1
90241: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
90242: LD_ADDR_EXP 200
90246: PUSH
90247: LD_EXP 200
90251: PPUSH
90252: LD_VAR 0 4
90256: PPUSH
90257: EMPTY
90258: PPUSH
90259: CALL_OW 1
90263: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
90264: LD_ADDR_EXP 201
90268: PUSH
90269: LD_EXP 201
90273: PPUSH
90274: LD_VAR 0 4
90278: PPUSH
90279: EMPTY
90280: PPUSH
90281: CALL_OW 1
90285: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
90286: LD_ADDR_EXP 202
90290: PUSH
90291: LD_EXP 202
90295: PPUSH
90296: LD_VAR 0 4
90300: PPUSH
90301: EMPTY
90302: PPUSH
90303: CALL_OW 1
90307: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
90308: LD_ADDR_EXP 203
90312: PUSH
90313: LD_EXP 203
90317: PPUSH
90318: LD_VAR 0 4
90322: PPUSH
90323: LD_INT 0
90325: PPUSH
90326: CALL_OW 1
90330: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
90331: LD_ADDR_EXP 204
90335: PUSH
90336: LD_EXP 204
90340: PPUSH
90341: LD_VAR 0 4
90345: PPUSH
90346: LD_INT 0
90348: PPUSH
90349: CALL_OW 1
90353: ST_TO_ADDR
// result := base ;
90354: LD_ADDR_VAR 0 3
90358: PUSH
90359: LD_VAR 0 4
90363: ST_TO_ADDR
// end ;
90364: LD_VAR 0 3
90368: RET
// export function MC_Start ( ) ; var i ; begin
90369: LD_INT 0
90371: PPUSH
90372: PPUSH
// for i = 1 to mc_bases do
90373: LD_ADDR_VAR 0 2
90377: PUSH
90378: DOUBLE
90379: LD_INT 1
90381: DEC
90382: ST_TO_ADDR
90383: LD_EXP 161
90387: PUSH
90388: FOR_TO
90389: IFFALSE 91489
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
90391: LD_ADDR_EXP 161
90395: PUSH
90396: LD_EXP 161
90400: PPUSH
90401: LD_VAR 0 2
90405: PPUSH
90406: LD_EXP 161
90410: PUSH
90411: LD_VAR 0 2
90415: ARRAY
90416: PUSH
90417: LD_INT 0
90419: DIFF
90420: PPUSH
90421: CALL_OW 1
90425: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
90426: LD_ADDR_EXP 162
90430: PUSH
90431: LD_EXP 162
90435: PPUSH
90436: LD_VAR 0 2
90440: PPUSH
90441: EMPTY
90442: PPUSH
90443: CALL_OW 1
90447: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
90448: LD_ADDR_EXP 163
90452: PUSH
90453: LD_EXP 163
90457: PPUSH
90458: LD_VAR 0 2
90462: PPUSH
90463: EMPTY
90464: PPUSH
90465: CALL_OW 1
90469: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
90470: LD_ADDR_EXP 164
90474: PUSH
90475: LD_EXP 164
90479: PPUSH
90480: LD_VAR 0 2
90484: PPUSH
90485: EMPTY
90486: PPUSH
90487: CALL_OW 1
90491: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
90492: LD_ADDR_EXP 165
90496: PUSH
90497: LD_EXP 165
90501: PPUSH
90502: LD_VAR 0 2
90506: PPUSH
90507: EMPTY
90508: PUSH
90509: EMPTY
90510: PUSH
90511: EMPTY
90512: LIST
90513: LIST
90514: PPUSH
90515: CALL_OW 1
90519: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
90520: LD_ADDR_EXP 166
90524: PUSH
90525: LD_EXP 166
90529: PPUSH
90530: LD_VAR 0 2
90534: PPUSH
90535: EMPTY
90536: PPUSH
90537: CALL_OW 1
90541: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
90542: LD_ADDR_EXP 193
90546: PUSH
90547: LD_EXP 193
90551: PPUSH
90552: LD_VAR 0 2
90556: PPUSH
90557: EMPTY
90558: PPUSH
90559: CALL_OW 1
90563: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
90564: LD_ADDR_EXP 167
90568: PUSH
90569: LD_EXP 167
90573: PPUSH
90574: LD_VAR 0 2
90578: PPUSH
90579: EMPTY
90580: PPUSH
90581: CALL_OW 1
90585: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
90586: LD_ADDR_EXP 168
90590: PUSH
90591: LD_EXP 168
90595: PPUSH
90596: LD_VAR 0 2
90600: PPUSH
90601: EMPTY
90602: PPUSH
90603: CALL_OW 1
90607: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
90608: LD_ADDR_EXP 169
90612: PUSH
90613: LD_EXP 169
90617: PPUSH
90618: LD_VAR 0 2
90622: PPUSH
90623: LD_EXP 161
90627: PUSH
90628: LD_VAR 0 2
90632: ARRAY
90633: PPUSH
90634: LD_INT 2
90636: PUSH
90637: LD_INT 30
90639: PUSH
90640: LD_INT 32
90642: PUSH
90643: EMPTY
90644: LIST
90645: LIST
90646: PUSH
90647: LD_INT 30
90649: PUSH
90650: LD_INT 33
90652: PUSH
90653: EMPTY
90654: LIST
90655: LIST
90656: PUSH
90657: EMPTY
90658: LIST
90659: LIST
90660: LIST
90661: PPUSH
90662: CALL_OW 72
90666: PPUSH
90667: CALL_OW 1
90671: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
90672: LD_ADDR_EXP 170
90676: PUSH
90677: LD_EXP 170
90681: PPUSH
90682: LD_VAR 0 2
90686: PPUSH
90687: LD_EXP 161
90691: PUSH
90692: LD_VAR 0 2
90696: ARRAY
90697: PPUSH
90698: LD_INT 2
90700: PUSH
90701: LD_INT 30
90703: PUSH
90704: LD_INT 32
90706: PUSH
90707: EMPTY
90708: LIST
90709: LIST
90710: PUSH
90711: LD_INT 30
90713: PUSH
90714: LD_INT 31
90716: PUSH
90717: EMPTY
90718: LIST
90719: LIST
90720: PUSH
90721: EMPTY
90722: LIST
90723: LIST
90724: LIST
90725: PUSH
90726: LD_INT 58
90728: PUSH
90729: EMPTY
90730: LIST
90731: PUSH
90732: EMPTY
90733: LIST
90734: LIST
90735: PPUSH
90736: CALL_OW 72
90740: PPUSH
90741: CALL_OW 1
90745: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
90746: LD_ADDR_EXP 171
90750: PUSH
90751: LD_EXP 171
90755: PPUSH
90756: LD_VAR 0 2
90760: PPUSH
90761: EMPTY
90762: PPUSH
90763: CALL_OW 1
90767: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
90768: LD_ADDR_EXP 175
90772: PUSH
90773: LD_EXP 175
90777: PPUSH
90778: LD_VAR 0 2
90782: PPUSH
90783: EMPTY
90784: PPUSH
90785: CALL_OW 1
90789: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
90790: LD_ADDR_EXP 174
90794: PUSH
90795: LD_EXP 174
90799: PPUSH
90800: LD_VAR 0 2
90804: PPUSH
90805: EMPTY
90806: PPUSH
90807: CALL_OW 1
90811: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
90812: LD_ADDR_EXP 176
90816: PUSH
90817: LD_EXP 176
90821: PPUSH
90822: LD_VAR 0 2
90826: PPUSH
90827: EMPTY
90828: PPUSH
90829: CALL_OW 1
90833: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
90834: LD_ADDR_EXP 177
90838: PUSH
90839: LD_EXP 177
90843: PPUSH
90844: LD_VAR 0 2
90848: PPUSH
90849: EMPTY
90850: PPUSH
90851: CALL_OW 1
90855: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
90856: LD_ADDR_EXP 178
90860: PUSH
90861: LD_EXP 178
90865: PPUSH
90866: LD_VAR 0 2
90870: PPUSH
90871: EMPTY
90872: PPUSH
90873: CALL_OW 1
90877: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
90878: LD_ADDR_EXP 179
90882: PUSH
90883: LD_EXP 179
90887: PPUSH
90888: LD_VAR 0 2
90892: PPUSH
90893: EMPTY
90894: PPUSH
90895: CALL_OW 1
90899: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
90900: LD_ADDR_EXP 180
90904: PUSH
90905: LD_EXP 180
90909: PPUSH
90910: LD_VAR 0 2
90914: PPUSH
90915: EMPTY
90916: PPUSH
90917: CALL_OW 1
90921: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
90922: LD_ADDR_EXP 181
90926: PUSH
90927: LD_EXP 181
90931: PPUSH
90932: LD_VAR 0 2
90936: PPUSH
90937: EMPTY
90938: PPUSH
90939: CALL_OW 1
90943: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
90944: LD_ADDR_EXP 182
90948: PUSH
90949: LD_EXP 182
90953: PPUSH
90954: LD_VAR 0 2
90958: PPUSH
90959: EMPTY
90960: PPUSH
90961: CALL_OW 1
90965: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
90966: LD_ADDR_EXP 183
90970: PUSH
90971: LD_EXP 183
90975: PPUSH
90976: LD_VAR 0 2
90980: PPUSH
90981: EMPTY
90982: PPUSH
90983: CALL_OW 1
90987: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
90988: LD_ADDR_EXP 172
90992: PUSH
90993: LD_EXP 172
90997: PPUSH
90998: LD_VAR 0 2
91002: PPUSH
91003: LD_INT 0
91005: PPUSH
91006: CALL_OW 1
91010: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
91011: LD_ADDR_EXP 185
91015: PUSH
91016: LD_EXP 185
91020: PPUSH
91021: LD_VAR 0 2
91025: PPUSH
91026: LD_INT 0
91028: PPUSH
91029: CALL_OW 1
91033: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
91034: LD_ADDR_EXP 173
91038: PUSH
91039: LD_EXP 173
91043: PPUSH
91044: LD_VAR 0 2
91048: PPUSH
91049: EMPTY
91050: PPUSH
91051: CALL_OW 1
91055: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
91056: LD_ADDR_EXP 184
91060: PUSH
91061: LD_EXP 184
91065: PPUSH
91066: LD_VAR 0 2
91070: PPUSH
91071: LD_INT 0
91073: PPUSH
91074: CALL_OW 1
91078: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
91079: LD_ADDR_EXP 186
91083: PUSH
91084: LD_EXP 186
91088: PPUSH
91089: LD_VAR 0 2
91093: PPUSH
91094: EMPTY
91095: PPUSH
91096: CALL_OW 1
91100: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
91101: LD_ADDR_EXP 189
91105: PUSH
91106: LD_EXP 189
91110: PPUSH
91111: LD_VAR 0 2
91115: PPUSH
91116: LD_INT 0
91118: PPUSH
91119: CALL_OW 1
91123: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
91124: LD_ADDR_EXP 190
91128: PUSH
91129: LD_EXP 190
91133: PPUSH
91134: LD_VAR 0 2
91138: PPUSH
91139: EMPTY
91140: PPUSH
91141: CALL_OW 1
91145: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
91146: LD_ADDR_EXP 191
91150: PUSH
91151: LD_EXP 191
91155: PPUSH
91156: LD_VAR 0 2
91160: PPUSH
91161: EMPTY
91162: PPUSH
91163: CALL_OW 1
91167: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
91168: LD_ADDR_EXP 192
91172: PUSH
91173: LD_EXP 192
91177: PPUSH
91178: LD_VAR 0 2
91182: PPUSH
91183: EMPTY
91184: PPUSH
91185: CALL_OW 1
91189: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
91190: LD_ADDR_EXP 194
91194: PUSH
91195: LD_EXP 194
91199: PPUSH
91200: LD_VAR 0 2
91204: PPUSH
91205: LD_EXP 161
91209: PUSH
91210: LD_VAR 0 2
91214: ARRAY
91215: PPUSH
91216: LD_INT 2
91218: PUSH
91219: LD_INT 30
91221: PUSH
91222: LD_INT 6
91224: PUSH
91225: EMPTY
91226: LIST
91227: LIST
91228: PUSH
91229: LD_INT 30
91231: PUSH
91232: LD_INT 7
91234: PUSH
91235: EMPTY
91236: LIST
91237: LIST
91238: PUSH
91239: LD_INT 30
91241: PUSH
91242: LD_INT 8
91244: PUSH
91245: EMPTY
91246: LIST
91247: LIST
91248: PUSH
91249: EMPTY
91250: LIST
91251: LIST
91252: LIST
91253: LIST
91254: PPUSH
91255: CALL_OW 72
91259: PPUSH
91260: CALL_OW 1
91264: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
91265: LD_ADDR_EXP 195
91269: PUSH
91270: LD_EXP 195
91274: PPUSH
91275: LD_VAR 0 2
91279: PPUSH
91280: EMPTY
91281: PPUSH
91282: CALL_OW 1
91286: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
91287: LD_ADDR_EXP 196
91291: PUSH
91292: LD_EXP 196
91296: PPUSH
91297: LD_VAR 0 2
91301: PPUSH
91302: EMPTY
91303: PPUSH
91304: CALL_OW 1
91308: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
91309: LD_ADDR_EXP 197
91313: PUSH
91314: LD_EXP 197
91318: PPUSH
91319: LD_VAR 0 2
91323: PPUSH
91324: EMPTY
91325: PPUSH
91326: CALL_OW 1
91330: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
91331: LD_ADDR_EXP 198
91335: PUSH
91336: LD_EXP 198
91340: PPUSH
91341: LD_VAR 0 2
91345: PPUSH
91346: EMPTY
91347: PPUSH
91348: CALL_OW 1
91352: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
91353: LD_ADDR_EXP 199
91357: PUSH
91358: LD_EXP 199
91362: PPUSH
91363: LD_VAR 0 2
91367: PPUSH
91368: EMPTY
91369: PPUSH
91370: CALL_OW 1
91374: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
91375: LD_ADDR_EXP 200
91379: PUSH
91380: LD_EXP 200
91384: PPUSH
91385: LD_VAR 0 2
91389: PPUSH
91390: EMPTY
91391: PPUSH
91392: CALL_OW 1
91396: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
91397: LD_ADDR_EXP 201
91401: PUSH
91402: LD_EXP 201
91406: PPUSH
91407: LD_VAR 0 2
91411: PPUSH
91412: EMPTY
91413: PPUSH
91414: CALL_OW 1
91418: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
91419: LD_ADDR_EXP 202
91423: PUSH
91424: LD_EXP 202
91428: PPUSH
91429: LD_VAR 0 2
91433: PPUSH
91434: EMPTY
91435: PPUSH
91436: CALL_OW 1
91440: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
91441: LD_ADDR_EXP 203
91445: PUSH
91446: LD_EXP 203
91450: PPUSH
91451: LD_VAR 0 2
91455: PPUSH
91456: LD_INT 0
91458: PPUSH
91459: CALL_OW 1
91463: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
91464: LD_ADDR_EXP 204
91468: PUSH
91469: LD_EXP 204
91473: PPUSH
91474: LD_VAR 0 2
91478: PPUSH
91479: LD_INT 0
91481: PPUSH
91482: CALL_OW 1
91486: ST_TO_ADDR
// end ;
91487: GO 90388
91489: POP
91490: POP
// MC_InitSides ( ) ;
91491: CALL 91777 0 0
// MC_InitResearch ( ) ;
91495: CALL 91516 0 0
// CustomInitMacro ( ) ;
91499: CALL 350 0 0
// skirmish := true ;
91503: LD_ADDR_EXP 159
91507: PUSH
91508: LD_INT 1
91510: ST_TO_ADDR
// end ;
91511: LD_VAR 0 1
91515: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
91516: LD_INT 0
91518: PPUSH
91519: PPUSH
91520: PPUSH
91521: PPUSH
91522: PPUSH
91523: PPUSH
// if not mc_bases then
91524: LD_EXP 161
91528: NOT
91529: IFFALSE 91533
// exit ;
91531: GO 91772
// for i = 1 to 8 do
91533: LD_ADDR_VAR 0 2
91537: PUSH
91538: DOUBLE
91539: LD_INT 1
91541: DEC
91542: ST_TO_ADDR
91543: LD_INT 8
91545: PUSH
91546: FOR_TO
91547: IFFALSE 91573
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
91549: LD_ADDR_EXP 188
91553: PUSH
91554: LD_EXP 188
91558: PPUSH
91559: LD_VAR 0 2
91563: PPUSH
91564: EMPTY
91565: PPUSH
91566: CALL_OW 1
91570: ST_TO_ADDR
91571: GO 91546
91573: POP
91574: POP
// tmp := [ ] ;
91575: LD_ADDR_VAR 0 5
91579: PUSH
91580: EMPTY
91581: ST_TO_ADDR
// for i = 1 to mc_sides do
91582: LD_ADDR_VAR 0 2
91586: PUSH
91587: DOUBLE
91588: LD_INT 1
91590: DEC
91591: ST_TO_ADDR
91592: LD_EXP 187
91596: PUSH
91597: FOR_TO
91598: IFFALSE 91656
// if not mc_sides [ i ] in tmp then
91600: LD_EXP 187
91604: PUSH
91605: LD_VAR 0 2
91609: ARRAY
91610: PUSH
91611: LD_VAR 0 5
91615: IN
91616: NOT
91617: IFFALSE 91654
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
91619: LD_ADDR_VAR 0 5
91623: PUSH
91624: LD_VAR 0 5
91628: PPUSH
91629: LD_VAR 0 5
91633: PUSH
91634: LD_INT 1
91636: PLUS
91637: PPUSH
91638: LD_EXP 187
91642: PUSH
91643: LD_VAR 0 2
91647: ARRAY
91648: PPUSH
91649: CALL_OW 2
91653: ST_TO_ADDR
91654: GO 91597
91656: POP
91657: POP
// if not tmp then
91658: LD_VAR 0 5
91662: NOT
91663: IFFALSE 91667
// exit ;
91665: GO 91772
// for j in tmp do
91667: LD_ADDR_VAR 0 3
91671: PUSH
91672: LD_VAR 0 5
91676: PUSH
91677: FOR_IN
91678: IFFALSE 91770
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
91680: LD_ADDR_VAR 0 6
91684: PUSH
91685: LD_INT 22
91687: PUSH
91688: LD_VAR 0 3
91692: PUSH
91693: EMPTY
91694: LIST
91695: LIST
91696: PPUSH
91697: CALL_OW 69
91701: ST_TO_ADDR
// if not un then
91702: LD_VAR 0 6
91706: NOT
91707: IFFALSE 91711
// continue ;
91709: GO 91677
// nation := GetNation ( un [ 1 ] ) ;
91711: LD_ADDR_VAR 0 4
91715: PUSH
91716: LD_VAR 0 6
91720: PUSH
91721: LD_INT 1
91723: ARRAY
91724: PPUSH
91725: CALL_OW 248
91729: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
91730: LD_ADDR_EXP 188
91734: PUSH
91735: LD_EXP 188
91739: PPUSH
91740: LD_VAR 0 3
91744: PPUSH
91745: LD_VAR 0 3
91749: PPUSH
91750: LD_VAR 0 4
91754: PPUSH
91755: LD_INT 1
91757: PPUSH
91758: CALL 19287 0 3
91762: PPUSH
91763: CALL_OW 1
91767: ST_TO_ADDR
// end ;
91768: GO 91677
91770: POP
91771: POP
// end ;
91772: LD_VAR 0 1
91776: RET
// export function MC_InitSides ( ) ; var i ; begin
91777: LD_INT 0
91779: PPUSH
91780: PPUSH
// if not mc_bases then
91781: LD_EXP 161
91785: NOT
91786: IFFALSE 91790
// exit ;
91788: GO 91864
// for i = 1 to mc_bases do
91790: LD_ADDR_VAR 0 2
91794: PUSH
91795: DOUBLE
91796: LD_INT 1
91798: DEC
91799: ST_TO_ADDR
91800: LD_EXP 161
91804: PUSH
91805: FOR_TO
91806: IFFALSE 91862
// if mc_bases [ i ] then
91808: LD_EXP 161
91812: PUSH
91813: LD_VAR 0 2
91817: ARRAY
91818: IFFALSE 91860
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
91820: LD_ADDR_EXP 187
91824: PUSH
91825: LD_EXP 187
91829: PPUSH
91830: LD_VAR 0 2
91834: PPUSH
91835: LD_EXP 161
91839: PUSH
91840: LD_VAR 0 2
91844: ARRAY
91845: PUSH
91846: LD_INT 1
91848: ARRAY
91849: PPUSH
91850: CALL_OW 255
91854: PPUSH
91855: CALL_OW 1
91859: ST_TO_ADDR
91860: GO 91805
91862: POP
91863: POP
// end ;
91864: LD_VAR 0 1
91868: RET
// every 0 0$03 trigger skirmish do
91869: LD_EXP 159
91873: IFFALSE 92027
91875: GO 91877
91877: DISABLE
// begin enable ;
91878: ENABLE
// MC_CheckBuildings ( ) ;
91879: CALL 96525 0 0
// MC_CheckPeopleLife ( ) ;
91883: CALL 96686 0 0
// RaiseSailEvent ( 100 ) ;
91887: LD_INT 100
91889: PPUSH
91890: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
91894: LD_INT 103
91896: PPUSH
91897: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
91901: LD_INT 104
91903: PPUSH
91904: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
91908: LD_INT 105
91910: PPUSH
91911: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
91915: LD_INT 106
91917: PPUSH
91918: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
91922: LD_INT 107
91924: PPUSH
91925: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
91929: LD_INT 108
91931: PPUSH
91932: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
91936: LD_INT 109
91938: PPUSH
91939: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
91943: LD_INT 110
91945: PPUSH
91946: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
91950: LD_INT 111
91952: PPUSH
91953: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
91957: LD_INT 112
91959: PPUSH
91960: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
91964: LD_INT 113
91966: PPUSH
91967: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
91971: LD_INT 120
91973: PPUSH
91974: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
91978: LD_INT 121
91980: PPUSH
91981: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
91985: LD_INT 122
91987: PPUSH
91988: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
91992: LD_INT 123
91994: PPUSH
91995: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
91999: LD_INT 124
92001: PPUSH
92002: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
92006: LD_INT 125
92008: PPUSH
92009: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
92013: LD_INT 126
92015: PPUSH
92016: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
92020: LD_INT 200
92022: PPUSH
92023: CALL_OW 427
// end ;
92027: END
// on SailEvent ( event ) do begin if event < 100 then
92028: LD_VAR 0 1
92032: PUSH
92033: LD_INT 100
92035: LESS
92036: IFFALSE 92047
// CustomEvent ( event ) ;
92038: LD_VAR 0 1
92042: PPUSH
92043: CALL 16158 0 1
// if event = 100 then
92047: LD_VAR 0 1
92051: PUSH
92052: LD_INT 100
92054: EQUAL
92055: IFFALSE 92061
// MC_ClassManager ( ) ;
92057: CALL 92453 0 0
// if event = 101 then
92061: LD_VAR 0 1
92065: PUSH
92066: LD_INT 101
92068: EQUAL
92069: IFFALSE 92075
// MC_RepairBuildings ( ) ;
92071: CALL 97271 0 0
// if event = 102 then
92075: LD_VAR 0 1
92079: PUSH
92080: LD_INT 102
92082: EQUAL
92083: IFFALSE 92089
// MC_Heal ( ) ;
92085: CALL 98206 0 0
// if event = 103 then
92089: LD_VAR 0 1
92093: PUSH
92094: LD_INT 103
92096: EQUAL
92097: IFFALSE 92103
// MC_Build ( ) ;
92099: CALL 98628 0 0
// if event = 104 then
92103: LD_VAR 0 1
92107: PUSH
92108: LD_INT 104
92110: EQUAL
92111: IFFALSE 92117
// MC_TurretWeapon ( ) ;
92113: CALL 100262 0 0
// if event = 105 then
92117: LD_VAR 0 1
92121: PUSH
92122: LD_INT 105
92124: EQUAL
92125: IFFALSE 92131
// MC_BuildUpgrade ( ) ;
92127: CALL 99813 0 0
// if event = 106 then
92131: LD_VAR 0 1
92135: PUSH
92136: LD_INT 106
92138: EQUAL
92139: IFFALSE 92145
// MC_PlantMines ( ) ;
92141: CALL 100692 0 0
// if event = 107 then
92145: LD_VAR 0 1
92149: PUSH
92150: LD_INT 107
92152: EQUAL
92153: IFFALSE 92159
// MC_CollectCrates ( ) ;
92155: CALL 101483 0 0
// if event = 108 then
92159: LD_VAR 0 1
92163: PUSH
92164: LD_INT 108
92166: EQUAL
92167: IFFALSE 92173
// MC_LinkRemoteControl ( ) ;
92169: CALL 103333 0 0
// if event = 109 then
92173: LD_VAR 0 1
92177: PUSH
92178: LD_INT 109
92180: EQUAL
92181: IFFALSE 92187
// MC_ProduceVehicle ( ) ;
92183: CALL 103514 0 0
// if event = 110 then
92187: LD_VAR 0 1
92191: PUSH
92192: LD_INT 110
92194: EQUAL
92195: IFFALSE 92201
// MC_SendAttack ( ) ;
92197: CALL 103980 0 0
// if event = 111 then
92201: LD_VAR 0 1
92205: PUSH
92206: LD_INT 111
92208: EQUAL
92209: IFFALSE 92215
// MC_Defend ( ) ;
92211: CALL 104088 0 0
// if event = 112 then
92215: LD_VAR 0 1
92219: PUSH
92220: LD_INT 112
92222: EQUAL
92223: IFFALSE 92229
// MC_Research ( ) ;
92225: CALL 104968 0 0
// if event = 113 then
92229: LD_VAR 0 1
92233: PUSH
92234: LD_INT 113
92236: EQUAL
92237: IFFALSE 92243
// MC_MinesTrigger ( ) ;
92239: CALL 106082 0 0
// if event = 120 then
92243: LD_VAR 0 1
92247: PUSH
92248: LD_INT 120
92250: EQUAL
92251: IFFALSE 92257
// MC_RepairVehicle ( ) ;
92253: CALL 106181 0 0
// if event = 121 then
92257: LD_VAR 0 1
92261: PUSH
92262: LD_INT 121
92264: EQUAL
92265: IFFALSE 92271
// MC_TameApe ( ) ;
92267: CALL 106950 0 0
// if event = 122 then
92271: LD_VAR 0 1
92275: PUSH
92276: LD_INT 122
92278: EQUAL
92279: IFFALSE 92285
// MC_ChangeApeClass ( ) ;
92281: CALL 107779 0 0
// if event = 123 then
92285: LD_VAR 0 1
92289: PUSH
92290: LD_INT 123
92292: EQUAL
92293: IFFALSE 92299
// MC_Bazooka ( ) ;
92295: CALL 108429 0 0
// if event = 124 then
92299: LD_VAR 0 1
92303: PUSH
92304: LD_INT 124
92306: EQUAL
92307: IFFALSE 92313
// MC_TeleportExit ( ) ;
92309: CALL 108627 0 0
// if event = 125 then
92313: LD_VAR 0 1
92317: PUSH
92318: LD_INT 125
92320: EQUAL
92321: IFFALSE 92327
// MC_Deposits ( ) ;
92323: CALL 109274 0 0
// if event = 126 then
92327: LD_VAR 0 1
92331: PUSH
92332: LD_INT 126
92334: EQUAL
92335: IFFALSE 92341
// MC_RemoteDriver ( ) ;
92337: CALL 109899 0 0
// if event = 200 then
92341: LD_VAR 0 1
92345: PUSH
92346: LD_INT 200
92348: EQUAL
92349: IFFALSE 92355
// MC_Idle ( ) ;
92351: CALL 111848 0 0
// end ;
92355: PPOPN 1
92357: END
// export function MC_Reset ( base , tag ) ; var i ; begin
92358: LD_INT 0
92360: PPUSH
92361: PPUSH
// if not mc_bases [ base ] or not tag then
92362: LD_EXP 161
92366: PUSH
92367: LD_VAR 0 1
92371: ARRAY
92372: NOT
92373: PUSH
92374: LD_VAR 0 2
92378: NOT
92379: OR
92380: IFFALSE 92384
// exit ;
92382: GO 92448
// for i in mc_bases [ base ] union mc_ape [ base ] do
92384: LD_ADDR_VAR 0 4
92388: PUSH
92389: LD_EXP 161
92393: PUSH
92394: LD_VAR 0 1
92398: ARRAY
92399: PUSH
92400: LD_EXP 190
92404: PUSH
92405: LD_VAR 0 1
92409: ARRAY
92410: UNION
92411: PUSH
92412: FOR_IN
92413: IFFALSE 92446
// if GetTag ( i ) = tag then
92415: LD_VAR 0 4
92419: PPUSH
92420: CALL_OW 110
92424: PUSH
92425: LD_VAR 0 2
92429: EQUAL
92430: IFFALSE 92444
// SetTag ( i , 0 ) ;
92432: LD_VAR 0 4
92436: PPUSH
92437: LD_INT 0
92439: PPUSH
92440: CALL_OW 109
92444: GO 92412
92446: POP
92447: POP
// end ;
92448: LD_VAR 0 3
92452: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
92453: LD_INT 0
92455: PPUSH
92456: PPUSH
92457: PPUSH
92458: PPUSH
92459: PPUSH
92460: PPUSH
92461: PPUSH
92462: PPUSH
// if not mc_bases then
92463: LD_EXP 161
92467: NOT
92468: IFFALSE 92472
// exit ;
92470: GO 92930
// for i = 1 to mc_bases do
92472: LD_ADDR_VAR 0 2
92476: PUSH
92477: DOUBLE
92478: LD_INT 1
92480: DEC
92481: ST_TO_ADDR
92482: LD_EXP 161
92486: PUSH
92487: FOR_TO
92488: IFFALSE 92928
// begin tmp := MC_ClassCheckReq ( i ) ;
92490: LD_ADDR_VAR 0 4
92494: PUSH
92495: LD_VAR 0 2
92499: PPUSH
92500: CALL 92935 0 1
92504: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
92505: LD_ADDR_EXP 202
92509: PUSH
92510: LD_EXP 202
92514: PPUSH
92515: LD_VAR 0 2
92519: PPUSH
92520: LD_VAR 0 4
92524: PPUSH
92525: CALL_OW 1
92529: ST_TO_ADDR
// if not tmp then
92530: LD_VAR 0 4
92534: NOT
92535: IFFALSE 92539
// continue ;
92537: GO 92487
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
92539: LD_ADDR_VAR 0 6
92543: PUSH
92544: LD_EXP 161
92548: PUSH
92549: LD_VAR 0 2
92553: ARRAY
92554: PPUSH
92555: LD_INT 2
92557: PUSH
92558: LD_INT 30
92560: PUSH
92561: LD_INT 4
92563: PUSH
92564: EMPTY
92565: LIST
92566: LIST
92567: PUSH
92568: LD_INT 30
92570: PUSH
92571: LD_INT 5
92573: PUSH
92574: EMPTY
92575: LIST
92576: LIST
92577: PUSH
92578: EMPTY
92579: LIST
92580: LIST
92581: LIST
92582: PPUSH
92583: CALL_OW 72
92587: PUSH
92588: LD_EXP 161
92592: PUSH
92593: LD_VAR 0 2
92597: ARRAY
92598: PPUSH
92599: LD_INT 2
92601: PUSH
92602: LD_INT 30
92604: PUSH
92605: LD_INT 0
92607: PUSH
92608: EMPTY
92609: LIST
92610: LIST
92611: PUSH
92612: LD_INT 30
92614: PUSH
92615: LD_INT 1
92617: PUSH
92618: EMPTY
92619: LIST
92620: LIST
92621: PUSH
92622: EMPTY
92623: LIST
92624: LIST
92625: LIST
92626: PPUSH
92627: CALL_OW 72
92631: PUSH
92632: LD_EXP 161
92636: PUSH
92637: LD_VAR 0 2
92641: ARRAY
92642: PPUSH
92643: LD_INT 30
92645: PUSH
92646: LD_INT 3
92648: PUSH
92649: EMPTY
92650: LIST
92651: LIST
92652: PPUSH
92653: CALL_OW 72
92657: PUSH
92658: LD_EXP 161
92662: PUSH
92663: LD_VAR 0 2
92667: ARRAY
92668: PPUSH
92669: LD_INT 2
92671: PUSH
92672: LD_INT 30
92674: PUSH
92675: LD_INT 6
92677: PUSH
92678: EMPTY
92679: LIST
92680: LIST
92681: PUSH
92682: LD_INT 30
92684: PUSH
92685: LD_INT 7
92687: PUSH
92688: EMPTY
92689: LIST
92690: LIST
92691: PUSH
92692: LD_INT 30
92694: PUSH
92695: LD_INT 8
92697: PUSH
92698: EMPTY
92699: LIST
92700: LIST
92701: PUSH
92702: EMPTY
92703: LIST
92704: LIST
92705: LIST
92706: LIST
92707: PPUSH
92708: CALL_OW 72
92712: PUSH
92713: EMPTY
92714: LIST
92715: LIST
92716: LIST
92717: LIST
92718: ST_TO_ADDR
// for j = 1 to 4 do
92719: LD_ADDR_VAR 0 3
92723: PUSH
92724: DOUBLE
92725: LD_INT 1
92727: DEC
92728: ST_TO_ADDR
92729: LD_INT 4
92731: PUSH
92732: FOR_TO
92733: IFFALSE 92924
// begin if not tmp [ j ] then
92735: LD_VAR 0 4
92739: PUSH
92740: LD_VAR 0 3
92744: ARRAY
92745: NOT
92746: IFFALSE 92750
// continue ;
92748: GO 92732
// for p in tmp [ j ] do
92750: LD_ADDR_VAR 0 5
92754: PUSH
92755: LD_VAR 0 4
92759: PUSH
92760: LD_VAR 0 3
92764: ARRAY
92765: PUSH
92766: FOR_IN
92767: IFFALSE 92920
// begin if not b [ j ] then
92769: LD_VAR 0 6
92773: PUSH
92774: LD_VAR 0 3
92778: ARRAY
92779: NOT
92780: IFFALSE 92784
// break ;
92782: GO 92920
// e := 0 ;
92784: LD_ADDR_VAR 0 7
92788: PUSH
92789: LD_INT 0
92791: ST_TO_ADDR
// for k in b [ j ] do
92792: LD_ADDR_VAR 0 8
92796: PUSH
92797: LD_VAR 0 6
92801: PUSH
92802: LD_VAR 0 3
92806: ARRAY
92807: PUSH
92808: FOR_IN
92809: IFFALSE 92836
// if IsNotFull ( k ) then
92811: LD_VAR 0 8
92815: PPUSH
92816: CALL 21440 0 1
92820: IFFALSE 92834
// begin e := k ;
92822: LD_ADDR_VAR 0 7
92826: PUSH
92827: LD_VAR 0 8
92831: ST_TO_ADDR
// break ;
92832: GO 92836
// end ;
92834: GO 92808
92836: POP
92837: POP
// if e and not UnitGoingToBuilding ( p , e ) then
92838: LD_VAR 0 7
92842: PUSH
92843: LD_VAR 0 5
92847: PPUSH
92848: LD_VAR 0 7
92852: PPUSH
92853: CALL 55336 0 2
92857: NOT
92858: AND
92859: IFFALSE 92918
// begin if IsInUnit ( p ) then
92861: LD_VAR 0 5
92865: PPUSH
92866: CALL_OW 310
92870: IFFALSE 92881
// ComExitBuilding ( p ) ;
92872: LD_VAR 0 5
92876: PPUSH
92877: CALL_OW 122
// ComEnterUnit ( p , e ) ;
92881: LD_VAR 0 5
92885: PPUSH
92886: LD_VAR 0 7
92890: PPUSH
92891: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
92895: LD_VAR 0 5
92899: PPUSH
92900: LD_VAR 0 3
92904: PPUSH
92905: CALL_OW 183
// AddComExitBuilding ( p ) ;
92909: LD_VAR 0 5
92913: PPUSH
92914: CALL_OW 182
// end ; end ;
92918: GO 92766
92920: POP
92921: POP
// end ;
92922: GO 92732
92924: POP
92925: POP
// end ;
92926: GO 92487
92928: POP
92929: POP
// end ;
92930: LD_VAR 0 1
92934: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
92935: LD_INT 0
92937: PPUSH
92938: PPUSH
92939: PPUSH
92940: PPUSH
92941: PPUSH
92942: PPUSH
92943: PPUSH
92944: PPUSH
92945: PPUSH
92946: PPUSH
92947: PPUSH
92948: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
92949: LD_VAR 0 1
92953: NOT
92954: PUSH
92955: LD_EXP 161
92959: PUSH
92960: LD_VAR 0 1
92964: ARRAY
92965: NOT
92966: OR
92967: PUSH
92968: LD_EXP 161
92972: PUSH
92973: LD_VAR 0 1
92977: ARRAY
92978: PPUSH
92979: LD_INT 2
92981: PUSH
92982: LD_INT 30
92984: PUSH
92985: LD_INT 0
92987: PUSH
92988: EMPTY
92989: LIST
92990: LIST
92991: PUSH
92992: LD_INT 30
92994: PUSH
92995: LD_INT 1
92997: PUSH
92998: EMPTY
92999: LIST
93000: LIST
93001: PUSH
93002: EMPTY
93003: LIST
93004: LIST
93005: LIST
93006: PPUSH
93007: CALL_OW 72
93011: NOT
93012: OR
93013: IFFALSE 93017
// exit ;
93015: GO 96520
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
93017: LD_ADDR_VAR 0 4
93021: PUSH
93022: LD_EXP 161
93026: PUSH
93027: LD_VAR 0 1
93031: ARRAY
93032: PPUSH
93033: LD_INT 2
93035: PUSH
93036: LD_INT 25
93038: PUSH
93039: LD_INT 1
93041: PUSH
93042: EMPTY
93043: LIST
93044: LIST
93045: PUSH
93046: LD_INT 25
93048: PUSH
93049: LD_INT 2
93051: PUSH
93052: EMPTY
93053: LIST
93054: LIST
93055: PUSH
93056: LD_INT 25
93058: PUSH
93059: LD_INT 3
93061: PUSH
93062: EMPTY
93063: LIST
93064: LIST
93065: PUSH
93066: LD_INT 25
93068: PUSH
93069: LD_INT 4
93071: PUSH
93072: EMPTY
93073: LIST
93074: LIST
93075: PUSH
93076: LD_INT 25
93078: PUSH
93079: LD_INT 5
93081: PUSH
93082: EMPTY
93083: LIST
93084: LIST
93085: PUSH
93086: LD_INT 25
93088: PUSH
93089: LD_INT 8
93091: PUSH
93092: EMPTY
93093: LIST
93094: LIST
93095: PUSH
93096: LD_INT 25
93098: PUSH
93099: LD_INT 9
93101: PUSH
93102: EMPTY
93103: LIST
93104: LIST
93105: PUSH
93106: EMPTY
93107: LIST
93108: LIST
93109: LIST
93110: LIST
93111: LIST
93112: LIST
93113: LIST
93114: LIST
93115: PPUSH
93116: CALL_OW 72
93120: ST_TO_ADDR
// if not tmp then
93121: LD_VAR 0 4
93125: NOT
93126: IFFALSE 93130
// exit ;
93128: GO 96520
// for i in tmp do
93130: LD_ADDR_VAR 0 3
93134: PUSH
93135: LD_VAR 0 4
93139: PUSH
93140: FOR_IN
93141: IFFALSE 93172
// if GetTag ( i ) then
93143: LD_VAR 0 3
93147: PPUSH
93148: CALL_OW 110
93152: IFFALSE 93170
// tmp := tmp diff i ;
93154: LD_ADDR_VAR 0 4
93158: PUSH
93159: LD_VAR 0 4
93163: PUSH
93164: LD_VAR 0 3
93168: DIFF
93169: ST_TO_ADDR
93170: GO 93140
93172: POP
93173: POP
// if not tmp then
93174: LD_VAR 0 4
93178: NOT
93179: IFFALSE 93183
// exit ;
93181: GO 96520
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
93183: LD_ADDR_VAR 0 5
93187: PUSH
93188: LD_EXP 161
93192: PUSH
93193: LD_VAR 0 1
93197: ARRAY
93198: PPUSH
93199: LD_INT 2
93201: PUSH
93202: LD_INT 25
93204: PUSH
93205: LD_INT 1
93207: PUSH
93208: EMPTY
93209: LIST
93210: LIST
93211: PUSH
93212: LD_INT 25
93214: PUSH
93215: LD_INT 5
93217: PUSH
93218: EMPTY
93219: LIST
93220: LIST
93221: PUSH
93222: LD_INT 25
93224: PUSH
93225: LD_INT 8
93227: PUSH
93228: EMPTY
93229: LIST
93230: LIST
93231: PUSH
93232: LD_INT 25
93234: PUSH
93235: LD_INT 9
93237: PUSH
93238: EMPTY
93239: LIST
93240: LIST
93241: PUSH
93242: EMPTY
93243: LIST
93244: LIST
93245: LIST
93246: LIST
93247: LIST
93248: PPUSH
93249: CALL_OW 72
93253: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
93254: LD_ADDR_VAR 0 6
93258: PUSH
93259: LD_EXP 161
93263: PUSH
93264: LD_VAR 0 1
93268: ARRAY
93269: PPUSH
93270: LD_INT 25
93272: PUSH
93273: LD_INT 2
93275: PUSH
93276: EMPTY
93277: LIST
93278: LIST
93279: PPUSH
93280: CALL_OW 72
93284: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
93285: LD_ADDR_VAR 0 7
93289: PUSH
93290: LD_EXP 161
93294: PUSH
93295: LD_VAR 0 1
93299: ARRAY
93300: PPUSH
93301: LD_INT 25
93303: PUSH
93304: LD_INT 3
93306: PUSH
93307: EMPTY
93308: LIST
93309: LIST
93310: PPUSH
93311: CALL_OW 72
93315: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
93316: LD_ADDR_VAR 0 8
93320: PUSH
93321: LD_EXP 161
93325: PUSH
93326: LD_VAR 0 1
93330: ARRAY
93331: PPUSH
93332: LD_INT 25
93334: PUSH
93335: LD_INT 4
93337: PUSH
93338: EMPTY
93339: LIST
93340: LIST
93341: PUSH
93342: LD_INT 24
93344: PUSH
93345: LD_INT 251
93347: PUSH
93348: EMPTY
93349: LIST
93350: LIST
93351: PUSH
93352: EMPTY
93353: LIST
93354: LIST
93355: PPUSH
93356: CALL_OW 72
93360: ST_TO_ADDR
// if mc_is_defending [ base ] then
93361: LD_EXP 204
93365: PUSH
93366: LD_VAR 0 1
93370: ARRAY
93371: IFFALSE 93832
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
93373: LD_ADDR_EXP 203
93377: PUSH
93378: LD_EXP 203
93382: PPUSH
93383: LD_VAR 0 1
93387: PPUSH
93388: LD_INT 4
93390: PPUSH
93391: CALL_OW 1
93395: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
93396: LD_ADDR_VAR 0 12
93400: PUSH
93401: LD_EXP 161
93405: PUSH
93406: LD_VAR 0 1
93410: ARRAY
93411: PPUSH
93412: LD_INT 2
93414: PUSH
93415: LD_INT 30
93417: PUSH
93418: LD_INT 4
93420: PUSH
93421: EMPTY
93422: LIST
93423: LIST
93424: PUSH
93425: LD_INT 30
93427: PUSH
93428: LD_INT 5
93430: PUSH
93431: EMPTY
93432: LIST
93433: LIST
93434: PUSH
93435: EMPTY
93436: LIST
93437: LIST
93438: LIST
93439: PPUSH
93440: CALL_OW 72
93444: ST_TO_ADDR
// if not b then
93445: LD_VAR 0 12
93449: NOT
93450: IFFALSE 93454
// exit ;
93452: GO 96520
// p := [ ] ;
93454: LD_ADDR_VAR 0 11
93458: PUSH
93459: EMPTY
93460: ST_TO_ADDR
// if sci >= 2 then
93461: LD_VAR 0 8
93465: PUSH
93466: LD_INT 2
93468: GREATEREQUAL
93469: IFFALSE 93500
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
93471: LD_ADDR_VAR 0 8
93475: PUSH
93476: LD_VAR 0 8
93480: PUSH
93481: LD_INT 1
93483: ARRAY
93484: PUSH
93485: LD_VAR 0 8
93489: PUSH
93490: LD_INT 2
93492: ARRAY
93493: PUSH
93494: EMPTY
93495: LIST
93496: LIST
93497: ST_TO_ADDR
93498: GO 93561
// if sci = 1 then
93500: LD_VAR 0 8
93504: PUSH
93505: LD_INT 1
93507: EQUAL
93508: IFFALSE 93529
// sci := [ sci [ 1 ] ] else
93510: LD_ADDR_VAR 0 8
93514: PUSH
93515: LD_VAR 0 8
93519: PUSH
93520: LD_INT 1
93522: ARRAY
93523: PUSH
93524: EMPTY
93525: LIST
93526: ST_TO_ADDR
93527: GO 93561
// if sci = 0 then
93529: LD_VAR 0 8
93533: PUSH
93534: LD_INT 0
93536: EQUAL
93537: IFFALSE 93561
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
93539: LD_ADDR_VAR 0 11
93543: PUSH
93544: LD_VAR 0 4
93548: PPUSH
93549: LD_INT 4
93551: PPUSH
93552: CALL 55208 0 2
93556: PUSH
93557: LD_INT 1
93559: ARRAY
93560: ST_TO_ADDR
// if eng > 4 then
93561: LD_VAR 0 6
93565: PUSH
93566: LD_INT 4
93568: GREATER
93569: IFFALSE 93615
// for i = eng downto 4 do
93571: LD_ADDR_VAR 0 3
93575: PUSH
93576: DOUBLE
93577: LD_VAR 0 6
93581: INC
93582: ST_TO_ADDR
93583: LD_INT 4
93585: PUSH
93586: FOR_DOWNTO
93587: IFFALSE 93613
// eng := eng diff eng [ i ] ;
93589: LD_ADDR_VAR 0 6
93593: PUSH
93594: LD_VAR 0 6
93598: PUSH
93599: LD_VAR 0 6
93603: PUSH
93604: LD_VAR 0 3
93608: ARRAY
93609: DIFF
93610: ST_TO_ADDR
93611: GO 93586
93613: POP
93614: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
93615: LD_ADDR_VAR 0 4
93619: PUSH
93620: LD_VAR 0 4
93624: PUSH
93625: LD_VAR 0 5
93629: PUSH
93630: LD_VAR 0 6
93634: UNION
93635: PUSH
93636: LD_VAR 0 7
93640: UNION
93641: PUSH
93642: LD_VAR 0 8
93646: UNION
93647: DIFF
93648: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
93649: LD_ADDR_VAR 0 13
93653: PUSH
93654: LD_EXP 161
93658: PUSH
93659: LD_VAR 0 1
93663: ARRAY
93664: PPUSH
93665: LD_INT 2
93667: PUSH
93668: LD_INT 30
93670: PUSH
93671: LD_INT 32
93673: PUSH
93674: EMPTY
93675: LIST
93676: LIST
93677: PUSH
93678: LD_INT 30
93680: PUSH
93681: LD_INT 31
93683: PUSH
93684: EMPTY
93685: LIST
93686: LIST
93687: PUSH
93688: EMPTY
93689: LIST
93690: LIST
93691: LIST
93692: PPUSH
93693: CALL_OW 72
93697: PUSH
93698: LD_EXP 161
93702: PUSH
93703: LD_VAR 0 1
93707: ARRAY
93708: PPUSH
93709: LD_INT 2
93711: PUSH
93712: LD_INT 30
93714: PUSH
93715: LD_INT 4
93717: PUSH
93718: EMPTY
93719: LIST
93720: LIST
93721: PUSH
93722: LD_INT 30
93724: PUSH
93725: LD_INT 5
93727: PUSH
93728: EMPTY
93729: LIST
93730: LIST
93731: PUSH
93732: EMPTY
93733: LIST
93734: LIST
93735: LIST
93736: PPUSH
93737: CALL_OW 72
93741: PUSH
93742: LD_INT 6
93744: MUL
93745: PLUS
93746: ST_TO_ADDR
// if bcount < tmp then
93747: LD_VAR 0 13
93751: PUSH
93752: LD_VAR 0 4
93756: LESS
93757: IFFALSE 93803
// for i = tmp downto bcount do
93759: LD_ADDR_VAR 0 3
93763: PUSH
93764: DOUBLE
93765: LD_VAR 0 4
93769: INC
93770: ST_TO_ADDR
93771: LD_VAR 0 13
93775: PUSH
93776: FOR_DOWNTO
93777: IFFALSE 93801
// tmp := Delete ( tmp , tmp ) ;
93779: LD_ADDR_VAR 0 4
93783: PUSH
93784: LD_VAR 0 4
93788: PPUSH
93789: LD_VAR 0 4
93793: PPUSH
93794: CALL_OW 3
93798: ST_TO_ADDR
93799: GO 93776
93801: POP
93802: POP
// result := [ tmp , 0 , 0 , p ] ;
93803: LD_ADDR_VAR 0 2
93807: PUSH
93808: LD_VAR 0 4
93812: PUSH
93813: LD_INT 0
93815: PUSH
93816: LD_INT 0
93818: PUSH
93819: LD_VAR 0 11
93823: PUSH
93824: EMPTY
93825: LIST
93826: LIST
93827: LIST
93828: LIST
93829: ST_TO_ADDR
// exit ;
93830: GO 96520
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
93832: LD_EXP 161
93836: PUSH
93837: LD_VAR 0 1
93841: ARRAY
93842: PPUSH
93843: LD_INT 2
93845: PUSH
93846: LD_INT 30
93848: PUSH
93849: LD_INT 6
93851: PUSH
93852: EMPTY
93853: LIST
93854: LIST
93855: PUSH
93856: LD_INT 30
93858: PUSH
93859: LD_INT 7
93861: PUSH
93862: EMPTY
93863: LIST
93864: LIST
93865: PUSH
93866: LD_INT 30
93868: PUSH
93869: LD_INT 8
93871: PUSH
93872: EMPTY
93873: LIST
93874: LIST
93875: PUSH
93876: EMPTY
93877: LIST
93878: LIST
93879: LIST
93880: LIST
93881: PPUSH
93882: CALL_OW 72
93886: NOT
93887: PUSH
93888: LD_EXP 161
93892: PUSH
93893: LD_VAR 0 1
93897: ARRAY
93898: PPUSH
93899: LD_INT 30
93901: PUSH
93902: LD_INT 3
93904: PUSH
93905: EMPTY
93906: LIST
93907: LIST
93908: PPUSH
93909: CALL_OW 72
93913: NOT
93914: AND
93915: IFFALSE 93987
// begin if eng = tmp then
93917: LD_VAR 0 6
93921: PUSH
93922: LD_VAR 0 4
93926: EQUAL
93927: IFFALSE 93931
// exit ;
93929: GO 96520
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
93931: LD_ADDR_EXP 203
93935: PUSH
93936: LD_EXP 203
93940: PPUSH
93941: LD_VAR 0 1
93945: PPUSH
93946: LD_INT 1
93948: PPUSH
93949: CALL_OW 1
93953: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
93954: LD_ADDR_VAR 0 2
93958: PUSH
93959: LD_INT 0
93961: PUSH
93962: LD_VAR 0 4
93966: PUSH
93967: LD_VAR 0 6
93971: DIFF
93972: PUSH
93973: LD_INT 0
93975: PUSH
93976: LD_INT 0
93978: PUSH
93979: EMPTY
93980: LIST
93981: LIST
93982: LIST
93983: LIST
93984: ST_TO_ADDR
// exit ;
93985: GO 96520
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
93987: LD_EXP 188
93991: PUSH
93992: LD_EXP 187
93996: PUSH
93997: LD_VAR 0 1
94001: ARRAY
94002: ARRAY
94003: PUSH
94004: LD_EXP 161
94008: PUSH
94009: LD_VAR 0 1
94013: ARRAY
94014: PPUSH
94015: LD_INT 2
94017: PUSH
94018: LD_INT 30
94020: PUSH
94021: LD_INT 6
94023: PUSH
94024: EMPTY
94025: LIST
94026: LIST
94027: PUSH
94028: LD_INT 30
94030: PUSH
94031: LD_INT 7
94033: PUSH
94034: EMPTY
94035: LIST
94036: LIST
94037: PUSH
94038: LD_INT 30
94040: PUSH
94041: LD_INT 8
94043: PUSH
94044: EMPTY
94045: LIST
94046: LIST
94047: PUSH
94048: EMPTY
94049: LIST
94050: LIST
94051: LIST
94052: LIST
94053: PPUSH
94054: CALL_OW 72
94058: AND
94059: PUSH
94060: LD_EXP 161
94064: PUSH
94065: LD_VAR 0 1
94069: ARRAY
94070: PPUSH
94071: LD_INT 30
94073: PUSH
94074: LD_INT 3
94076: PUSH
94077: EMPTY
94078: LIST
94079: LIST
94080: PPUSH
94081: CALL_OW 72
94085: NOT
94086: AND
94087: IFFALSE 94301
// begin if sci >= 6 then
94089: LD_VAR 0 8
94093: PUSH
94094: LD_INT 6
94096: GREATEREQUAL
94097: IFFALSE 94101
// exit ;
94099: GO 96520
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
94101: LD_ADDR_EXP 203
94105: PUSH
94106: LD_EXP 203
94110: PPUSH
94111: LD_VAR 0 1
94115: PPUSH
94116: LD_INT 2
94118: PPUSH
94119: CALL_OW 1
94123: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
94124: LD_ADDR_VAR 0 9
94128: PUSH
94129: LD_VAR 0 4
94133: PUSH
94134: LD_VAR 0 8
94138: DIFF
94139: PPUSH
94140: LD_INT 4
94142: PPUSH
94143: CALL 55208 0 2
94147: ST_TO_ADDR
// p := [ ] ;
94148: LD_ADDR_VAR 0 11
94152: PUSH
94153: EMPTY
94154: ST_TO_ADDR
// if sci < 6 and sort > 6 then
94155: LD_VAR 0 8
94159: PUSH
94160: LD_INT 6
94162: LESS
94163: PUSH
94164: LD_VAR 0 9
94168: PUSH
94169: LD_INT 6
94171: GREATER
94172: AND
94173: IFFALSE 94254
// begin for i = 1 to 6 - sci do
94175: LD_ADDR_VAR 0 3
94179: PUSH
94180: DOUBLE
94181: LD_INT 1
94183: DEC
94184: ST_TO_ADDR
94185: LD_INT 6
94187: PUSH
94188: LD_VAR 0 8
94192: MINUS
94193: PUSH
94194: FOR_TO
94195: IFFALSE 94250
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
94197: LD_ADDR_VAR 0 11
94201: PUSH
94202: LD_VAR 0 11
94206: PPUSH
94207: LD_VAR 0 11
94211: PUSH
94212: LD_INT 1
94214: PLUS
94215: PPUSH
94216: LD_VAR 0 9
94220: PUSH
94221: LD_INT 1
94223: ARRAY
94224: PPUSH
94225: CALL_OW 2
94229: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
94230: LD_ADDR_VAR 0 9
94234: PUSH
94235: LD_VAR 0 9
94239: PPUSH
94240: LD_INT 1
94242: PPUSH
94243: CALL_OW 3
94247: ST_TO_ADDR
// end ;
94248: GO 94194
94250: POP
94251: POP
// end else
94252: GO 94274
// if sort then
94254: LD_VAR 0 9
94258: IFFALSE 94274
// p := sort [ 1 ] ;
94260: LD_ADDR_VAR 0 11
94264: PUSH
94265: LD_VAR 0 9
94269: PUSH
94270: LD_INT 1
94272: ARRAY
94273: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
94274: LD_ADDR_VAR 0 2
94278: PUSH
94279: LD_INT 0
94281: PUSH
94282: LD_INT 0
94284: PUSH
94285: LD_INT 0
94287: PUSH
94288: LD_VAR 0 11
94292: PUSH
94293: EMPTY
94294: LIST
94295: LIST
94296: LIST
94297: LIST
94298: ST_TO_ADDR
// exit ;
94299: GO 96520
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
94301: LD_EXP 188
94305: PUSH
94306: LD_EXP 187
94310: PUSH
94311: LD_VAR 0 1
94315: ARRAY
94316: ARRAY
94317: PUSH
94318: LD_EXP 161
94322: PUSH
94323: LD_VAR 0 1
94327: ARRAY
94328: PPUSH
94329: LD_INT 2
94331: PUSH
94332: LD_INT 30
94334: PUSH
94335: LD_INT 6
94337: PUSH
94338: EMPTY
94339: LIST
94340: LIST
94341: PUSH
94342: LD_INT 30
94344: PUSH
94345: LD_INT 7
94347: PUSH
94348: EMPTY
94349: LIST
94350: LIST
94351: PUSH
94352: LD_INT 30
94354: PUSH
94355: LD_INT 8
94357: PUSH
94358: EMPTY
94359: LIST
94360: LIST
94361: PUSH
94362: EMPTY
94363: LIST
94364: LIST
94365: LIST
94366: LIST
94367: PPUSH
94368: CALL_OW 72
94372: AND
94373: PUSH
94374: LD_EXP 161
94378: PUSH
94379: LD_VAR 0 1
94383: ARRAY
94384: PPUSH
94385: LD_INT 30
94387: PUSH
94388: LD_INT 3
94390: PUSH
94391: EMPTY
94392: LIST
94393: LIST
94394: PPUSH
94395: CALL_OW 72
94399: AND
94400: IFFALSE 95134
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
94402: LD_ADDR_EXP 203
94406: PUSH
94407: LD_EXP 203
94411: PPUSH
94412: LD_VAR 0 1
94416: PPUSH
94417: LD_INT 3
94419: PPUSH
94420: CALL_OW 1
94424: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
94425: LD_ADDR_VAR 0 2
94429: PUSH
94430: LD_INT 0
94432: PUSH
94433: LD_INT 0
94435: PUSH
94436: LD_INT 0
94438: PUSH
94439: LD_INT 0
94441: PUSH
94442: EMPTY
94443: LIST
94444: LIST
94445: LIST
94446: LIST
94447: ST_TO_ADDR
// if not eng then
94448: LD_VAR 0 6
94452: NOT
94453: IFFALSE 94516
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
94455: LD_ADDR_VAR 0 11
94459: PUSH
94460: LD_VAR 0 4
94464: PPUSH
94465: LD_INT 2
94467: PPUSH
94468: CALL 55208 0 2
94472: PUSH
94473: LD_INT 1
94475: ARRAY
94476: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
94477: LD_ADDR_VAR 0 2
94481: PUSH
94482: LD_VAR 0 2
94486: PPUSH
94487: LD_INT 2
94489: PPUSH
94490: LD_VAR 0 11
94494: PPUSH
94495: CALL_OW 1
94499: ST_TO_ADDR
// tmp := tmp diff p ;
94500: LD_ADDR_VAR 0 4
94504: PUSH
94505: LD_VAR 0 4
94509: PUSH
94510: LD_VAR 0 11
94514: DIFF
94515: ST_TO_ADDR
// end ; if tmp and sci < 6 then
94516: LD_VAR 0 4
94520: PUSH
94521: LD_VAR 0 8
94525: PUSH
94526: LD_INT 6
94528: LESS
94529: AND
94530: IFFALSE 94718
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
94532: LD_ADDR_VAR 0 9
94536: PUSH
94537: LD_VAR 0 4
94541: PUSH
94542: LD_VAR 0 8
94546: PUSH
94547: LD_VAR 0 7
94551: UNION
94552: DIFF
94553: PPUSH
94554: LD_INT 4
94556: PPUSH
94557: CALL 55208 0 2
94561: ST_TO_ADDR
// p := [ ] ;
94562: LD_ADDR_VAR 0 11
94566: PUSH
94567: EMPTY
94568: ST_TO_ADDR
// if sort then
94569: LD_VAR 0 9
94573: IFFALSE 94689
// for i = 1 to 6 - sci do
94575: LD_ADDR_VAR 0 3
94579: PUSH
94580: DOUBLE
94581: LD_INT 1
94583: DEC
94584: ST_TO_ADDR
94585: LD_INT 6
94587: PUSH
94588: LD_VAR 0 8
94592: MINUS
94593: PUSH
94594: FOR_TO
94595: IFFALSE 94687
// begin if i = sort then
94597: LD_VAR 0 3
94601: PUSH
94602: LD_VAR 0 9
94606: EQUAL
94607: IFFALSE 94611
// break ;
94609: GO 94687
// if GetClass ( i ) = 4 then
94611: LD_VAR 0 3
94615: PPUSH
94616: CALL_OW 257
94620: PUSH
94621: LD_INT 4
94623: EQUAL
94624: IFFALSE 94628
// continue ;
94626: GO 94594
// p := Insert ( p , p + 1 , sort [ i ] ) ;
94628: LD_ADDR_VAR 0 11
94632: PUSH
94633: LD_VAR 0 11
94637: PPUSH
94638: LD_VAR 0 11
94642: PUSH
94643: LD_INT 1
94645: PLUS
94646: PPUSH
94647: LD_VAR 0 9
94651: PUSH
94652: LD_VAR 0 3
94656: ARRAY
94657: PPUSH
94658: CALL_OW 2
94662: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
94663: LD_ADDR_VAR 0 4
94667: PUSH
94668: LD_VAR 0 4
94672: PUSH
94673: LD_VAR 0 9
94677: PUSH
94678: LD_VAR 0 3
94682: ARRAY
94683: DIFF
94684: ST_TO_ADDR
// end ;
94685: GO 94594
94687: POP
94688: POP
// if p then
94689: LD_VAR 0 11
94693: IFFALSE 94718
// result := Replace ( result , 4 , p ) ;
94695: LD_ADDR_VAR 0 2
94699: PUSH
94700: LD_VAR 0 2
94704: PPUSH
94705: LD_INT 4
94707: PPUSH
94708: LD_VAR 0 11
94712: PPUSH
94713: CALL_OW 1
94717: ST_TO_ADDR
// end ; if tmp and mech < 6 then
94718: LD_VAR 0 4
94722: PUSH
94723: LD_VAR 0 7
94727: PUSH
94728: LD_INT 6
94730: LESS
94731: AND
94732: IFFALSE 94920
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
94734: LD_ADDR_VAR 0 9
94738: PUSH
94739: LD_VAR 0 4
94743: PUSH
94744: LD_VAR 0 8
94748: PUSH
94749: LD_VAR 0 7
94753: UNION
94754: DIFF
94755: PPUSH
94756: LD_INT 3
94758: PPUSH
94759: CALL 55208 0 2
94763: ST_TO_ADDR
// p := [ ] ;
94764: LD_ADDR_VAR 0 11
94768: PUSH
94769: EMPTY
94770: ST_TO_ADDR
// if sort then
94771: LD_VAR 0 9
94775: IFFALSE 94891
// for i = 1 to 6 - mech do
94777: LD_ADDR_VAR 0 3
94781: PUSH
94782: DOUBLE
94783: LD_INT 1
94785: DEC
94786: ST_TO_ADDR
94787: LD_INT 6
94789: PUSH
94790: LD_VAR 0 7
94794: MINUS
94795: PUSH
94796: FOR_TO
94797: IFFALSE 94889
// begin if i = sort then
94799: LD_VAR 0 3
94803: PUSH
94804: LD_VAR 0 9
94808: EQUAL
94809: IFFALSE 94813
// break ;
94811: GO 94889
// if GetClass ( i ) = 3 then
94813: LD_VAR 0 3
94817: PPUSH
94818: CALL_OW 257
94822: PUSH
94823: LD_INT 3
94825: EQUAL
94826: IFFALSE 94830
// continue ;
94828: GO 94796
// p := Insert ( p , p + 1 , sort [ i ] ) ;
94830: LD_ADDR_VAR 0 11
94834: PUSH
94835: LD_VAR 0 11
94839: PPUSH
94840: LD_VAR 0 11
94844: PUSH
94845: LD_INT 1
94847: PLUS
94848: PPUSH
94849: LD_VAR 0 9
94853: PUSH
94854: LD_VAR 0 3
94858: ARRAY
94859: PPUSH
94860: CALL_OW 2
94864: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
94865: LD_ADDR_VAR 0 4
94869: PUSH
94870: LD_VAR 0 4
94874: PUSH
94875: LD_VAR 0 9
94879: PUSH
94880: LD_VAR 0 3
94884: ARRAY
94885: DIFF
94886: ST_TO_ADDR
// end ;
94887: GO 94796
94889: POP
94890: POP
// if p then
94891: LD_VAR 0 11
94895: IFFALSE 94920
// result := Replace ( result , 3 , p ) ;
94897: LD_ADDR_VAR 0 2
94901: PUSH
94902: LD_VAR 0 2
94906: PPUSH
94907: LD_INT 3
94909: PPUSH
94910: LD_VAR 0 11
94914: PPUSH
94915: CALL_OW 1
94919: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
94920: LD_VAR 0 4
94924: PUSH
94925: LD_INT 6
94927: GREATER
94928: PUSH
94929: LD_VAR 0 6
94933: PUSH
94934: LD_INT 6
94936: LESS
94937: AND
94938: IFFALSE 95132
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
94940: LD_ADDR_VAR 0 9
94944: PUSH
94945: LD_VAR 0 4
94949: PUSH
94950: LD_VAR 0 8
94954: PUSH
94955: LD_VAR 0 7
94959: UNION
94960: PUSH
94961: LD_VAR 0 6
94965: UNION
94966: DIFF
94967: PPUSH
94968: LD_INT 2
94970: PPUSH
94971: CALL 55208 0 2
94975: ST_TO_ADDR
// p := [ ] ;
94976: LD_ADDR_VAR 0 11
94980: PUSH
94981: EMPTY
94982: ST_TO_ADDR
// if sort then
94983: LD_VAR 0 9
94987: IFFALSE 95103
// for i = 1 to 6 - eng do
94989: LD_ADDR_VAR 0 3
94993: PUSH
94994: DOUBLE
94995: LD_INT 1
94997: DEC
94998: ST_TO_ADDR
94999: LD_INT 6
95001: PUSH
95002: LD_VAR 0 6
95006: MINUS
95007: PUSH
95008: FOR_TO
95009: IFFALSE 95101
// begin if i = sort then
95011: LD_VAR 0 3
95015: PUSH
95016: LD_VAR 0 9
95020: EQUAL
95021: IFFALSE 95025
// break ;
95023: GO 95101
// if GetClass ( i ) = 2 then
95025: LD_VAR 0 3
95029: PPUSH
95030: CALL_OW 257
95034: PUSH
95035: LD_INT 2
95037: EQUAL
95038: IFFALSE 95042
// continue ;
95040: GO 95008
// p := Insert ( p , p + 1 , sort [ i ] ) ;
95042: LD_ADDR_VAR 0 11
95046: PUSH
95047: LD_VAR 0 11
95051: PPUSH
95052: LD_VAR 0 11
95056: PUSH
95057: LD_INT 1
95059: PLUS
95060: PPUSH
95061: LD_VAR 0 9
95065: PUSH
95066: LD_VAR 0 3
95070: ARRAY
95071: PPUSH
95072: CALL_OW 2
95076: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
95077: LD_ADDR_VAR 0 4
95081: PUSH
95082: LD_VAR 0 4
95086: PUSH
95087: LD_VAR 0 9
95091: PUSH
95092: LD_VAR 0 3
95096: ARRAY
95097: DIFF
95098: ST_TO_ADDR
// end ;
95099: GO 95008
95101: POP
95102: POP
// if p then
95103: LD_VAR 0 11
95107: IFFALSE 95132
// result := Replace ( result , 2 , p ) ;
95109: LD_ADDR_VAR 0 2
95113: PUSH
95114: LD_VAR 0 2
95118: PPUSH
95119: LD_INT 2
95121: PPUSH
95122: LD_VAR 0 11
95126: PPUSH
95127: CALL_OW 1
95131: ST_TO_ADDR
// end ; exit ;
95132: GO 96520
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
95134: LD_EXP 188
95138: PUSH
95139: LD_EXP 187
95143: PUSH
95144: LD_VAR 0 1
95148: ARRAY
95149: ARRAY
95150: NOT
95151: PUSH
95152: LD_EXP 161
95156: PUSH
95157: LD_VAR 0 1
95161: ARRAY
95162: PPUSH
95163: LD_INT 30
95165: PUSH
95166: LD_INT 3
95168: PUSH
95169: EMPTY
95170: LIST
95171: LIST
95172: PPUSH
95173: CALL_OW 72
95177: AND
95178: PUSH
95179: LD_EXP 166
95183: PUSH
95184: LD_VAR 0 1
95188: ARRAY
95189: AND
95190: IFFALSE 95798
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
95192: LD_ADDR_EXP 203
95196: PUSH
95197: LD_EXP 203
95201: PPUSH
95202: LD_VAR 0 1
95206: PPUSH
95207: LD_INT 5
95209: PPUSH
95210: CALL_OW 1
95214: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
95215: LD_ADDR_VAR 0 2
95219: PUSH
95220: LD_INT 0
95222: PUSH
95223: LD_INT 0
95225: PUSH
95226: LD_INT 0
95228: PUSH
95229: LD_INT 0
95231: PUSH
95232: EMPTY
95233: LIST
95234: LIST
95235: LIST
95236: LIST
95237: ST_TO_ADDR
// if sci > 1 then
95238: LD_VAR 0 8
95242: PUSH
95243: LD_INT 1
95245: GREATER
95246: IFFALSE 95274
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
95248: LD_ADDR_VAR 0 4
95252: PUSH
95253: LD_VAR 0 4
95257: PUSH
95258: LD_VAR 0 8
95262: PUSH
95263: LD_VAR 0 8
95267: PUSH
95268: LD_INT 1
95270: ARRAY
95271: DIFF
95272: DIFF
95273: ST_TO_ADDR
// if tmp and not sci then
95274: LD_VAR 0 4
95278: PUSH
95279: LD_VAR 0 8
95283: NOT
95284: AND
95285: IFFALSE 95354
// begin sort := SortBySkill ( tmp , 4 ) ;
95287: LD_ADDR_VAR 0 9
95291: PUSH
95292: LD_VAR 0 4
95296: PPUSH
95297: LD_INT 4
95299: PPUSH
95300: CALL 55208 0 2
95304: ST_TO_ADDR
// if sort then
95305: LD_VAR 0 9
95309: IFFALSE 95325
// p := sort [ 1 ] ;
95311: LD_ADDR_VAR 0 11
95315: PUSH
95316: LD_VAR 0 9
95320: PUSH
95321: LD_INT 1
95323: ARRAY
95324: ST_TO_ADDR
// if p then
95325: LD_VAR 0 11
95329: IFFALSE 95354
// result := Replace ( result , 4 , p ) ;
95331: LD_ADDR_VAR 0 2
95335: PUSH
95336: LD_VAR 0 2
95340: PPUSH
95341: LD_INT 4
95343: PPUSH
95344: LD_VAR 0 11
95348: PPUSH
95349: CALL_OW 1
95353: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
95354: LD_ADDR_VAR 0 4
95358: PUSH
95359: LD_VAR 0 4
95363: PUSH
95364: LD_VAR 0 7
95368: DIFF
95369: ST_TO_ADDR
// if tmp and mech < 6 then
95370: LD_VAR 0 4
95374: PUSH
95375: LD_VAR 0 7
95379: PUSH
95380: LD_INT 6
95382: LESS
95383: AND
95384: IFFALSE 95572
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
95386: LD_ADDR_VAR 0 9
95390: PUSH
95391: LD_VAR 0 4
95395: PUSH
95396: LD_VAR 0 8
95400: PUSH
95401: LD_VAR 0 7
95405: UNION
95406: DIFF
95407: PPUSH
95408: LD_INT 3
95410: PPUSH
95411: CALL 55208 0 2
95415: ST_TO_ADDR
// p := [ ] ;
95416: LD_ADDR_VAR 0 11
95420: PUSH
95421: EMPTY
95422: ST_TO_ADDR
// if sort then
95423: LD_VAR 0 9
95427: IFFALSE 95543
// for i = 1 to 6 - mech do
95429: LD_ADDR_VAR 0 3
95433: PUSH
95434: DOUBLE
95435: LD_INT 1
95437: DEC
95438: ST_TO_ADDR
95439: LD_INT 6
95441: PUSH
95442: LD_VAR 0 7
95446: MINUS
95447: PUSH
95448: FOR_TO
95449: IFFALSE 95541
// begin if i = sort then
95451: LD_VAR 0 3
95455: PUSH
95456: LD_VAR 0 9
95460: EQUAL
95461: IFFALSE 95465
// break ;
95463: GO 95541
// if GetClass ( i ) = 3 then
95465: LD_VAR 0 3
95469: PPUSH
95470: CALL_OW 257
95474: PUSH
95475: LD_INT 3
95477: EQUAL
95478: IFFALSE 95482
// continue ;
95480: GO 95448
// p := Insert ( p , p + 1 , sort [ i ] ) ;
95482: LD_ADDR_VAR 0 11
95486: PUSH
95487: LD_VAR 0 11
95491: PPUSH
95492: LD_VAR 0 11
95496: PUSH
95497: LD_INT 1
95499: PLUS
95500: PPUSH
95501: LD_VAR 0 9
95505: PUSH
95506: LD_VAR 0 3
95510: ARRAY
95511: PPUSH
95512: CALL_OW 2
95516: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
95517: LD_ADDR_VAR 0 4
95521: PUSH
95522: LD_VAR 0 4
95526: PUSH
95527: LD_VAR 0 9
95531: PUSH
95532: LD_VAR 0 3
95536: ARRAY
95537: DIFF
95538: ST_TO_ADDR
// end ;
95539: GO 95448
95541: POP
95542: POP
// if p then
95543: LD_VAR 0 11
95547: IFFALSE 95572
// result := Replace ( result , 3 , p ) ;
95549: LD_ADDR_VAR 0 2
95553: PUSH
95554: LD_VAR 0 2
95558: PPUSH
95559: LD_INT 3
95561: PPUSH
95562: LD_VAR 0 11
95566: PPUSH
95567: CALL_OW 1
95571: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
95572: LD_ADDR_VAR 0 4
95576: PUSH
95577: LD_VAR 0 4
95581: PUSH
95582: LD_VAR 0 6
95586: DIFF
95587: ST_TO_ADDR
// if tmp and eng < 6 then
95588: LD_VAR 0 4
95592: PUSH
95593: LD_VAR 0 6
95597: PUSH
95598: LD_INT 6
95600: LESS
95601: AND
95602: IFFALSE 95796
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
95604: LD_ADDR_VAR 0 9
95608: PUSH
95609: LD_VAR 0 4
95613: PUSH
95614: LD_VAR 0 8
95618: PUSH
95619: LD_VAR 0 7
95623: UNION
95624: PUSH
95625: LD_VAR 0 6
95629: UNION
95630: DIFF
95631: PPUSH
95632: LD_INT 2
95634: PPUSH
95635: CALL 55208 0 2
95639: ST_TO_ADDR
// p := [ ] ;
95640: LD_ADDR_VAR 0 11
95644: PUSH
95645: EMPTY
95646: ST_TO_ADDR
// if sort then
95647: LD_VAR 0 9
95651: IFFALSE 95767
// for i = 1 to 6 - eng do
95653: LD_ADDR_VAR 0 3
95657: PUSH
95658: DOUBLE
95659: LD_INT 1
95661: DEC
95662: ST_TO_ADDR
95663: LD_INT 6
95665: PUSH
95666: LD_VAR 0 6
95670: MINUS
95671: PUSH
95672: FOR_TO
95673: IFFALSE 95765
// begin if i = sort then
95675: LD_VAR 0 3
95679: PUSH
95680: LD_VAR 0 9
95684: EQUAL
95685: IFFALSE 95689
// break ;
95687: GO 95765
// if GetClass ( i ) = 2 then
95689: LD_VAR 0 3
95693: PPUSH
95694: CALL_OW 257
95698: PUSH
95699: LD_INT 2
95701: EQUAL
95702: IFFALSE 95706
// continue ;
95704: GO 95672
// p := Insert ( p , p + 1 , sort [ i ] ) ;
95706: LD_ADDR_VAR 0 11
95710: PUSH
95711: LD_VAR 0 11
95715: PPUSH
95716: LD_VAR 0 11
95720: PUSH
95721: LD_INT 1
95723: PLUS
95724: PPUSH
95725: LD_VAR 0 9
95729: PUSH
95730: LD_VAR 0 3
95734: ARRAY
95735: PPUSH
95736: CALL_OW 2
95740: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
95741: LD_ADDR_VAR 0 4
95745: PUSH
95746: LD_VAR 0 4
95750: PUSH
95751: LD_VAR 0 9
95755: PUSH
95756: LD_VAR 0 3
95760: ARRAY
95761: DIFF
95762: ST_TO_ADDR
// end ;
95763: GO 95672
95765: POP
95766: POP
// if p then
95767: LD_VAR 0 11
95771: IFFALSE 95796
// result := Replace ( result , 2 , p ) ;
95773: LD_ADDR_VAR 0 2
95777: PUSH
95778: LD_VAR 0 2
95782: PPUSH
95783: LD_INT 2
95785: PPUSH
95786: LD_VAR 0 11
95790: PPUSH
95791: CALL_OW 1
95795: ST_TO_ADDR
// end ; exit ;
95796: GO 96520
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
95798: LD_EXP 188
95802: PUSH
95803: LD_EXP 187
95807: PUSH
95808: LD_VAR 0 1
95812: ARRAY
95813: ARRAY
95814: NOT
95815: PUSH
95816: LD_EXP 161
95820: PUSH
95821: LD_VAR 0 1
95825: ARRAY
95826: PPUSH
95827: LD_INT 30
95829: PUSH
95830: LD_INT 3
95832: PUSH
95833: EMPTY
95834: LIST
95835: LIST
95836: PPUSH
95837: CALL_OW 72
95841: AND
95842: PUSH
95843: LD_EXP 166
95847: PUSH
95848: LD_VAR 0 1
95852: ARRAY
95853: NOT
95854: AND
95855: IFFALSE 96520
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
95857: LD_ADDR_EXP 203
95861: PUSH
95862: LD_EXP 203
95866: PPUSH
95867: LD_VAR 0 1
95871: PPUSH
95872: LD_INT 6
95874: PPUSH
95875: CALL_OW 1
95879: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
95880: LD_ADDR_VAR 0 2
95884: PUSH
95885: LD_INT 0
95887: PUSH
95888: LD_INT 0
95890: PUSH
95891: LD_INT 0
95893: PUSH
95894: LD_INT 0
95896: PUSH
95897: EMPTY
95898: LIST
95899: LIST
95900: LIST
95901: LIST
95902: ST_TO_ADDR
// if sci >= 1 then
95903: LD_VAR 0 8
95907: PUSH
95908: LD_INT 1
95910: GREATEREQUAL
95911: IFFALSE 95933
// tmp := tmp diff sci [ 1 ] ;
95913: LD_ADDR_VAR 0 4
95917: PUSH
95918: LD_VAR 0 4
95922: PUSH
95923: LD_VAR 0 8
95927: PUSH
95928: LD_INT 1
95930: ARRAY
95931: DIFF
95932: ST_TO_ADDR
// if tmp and not sci then
95933: LD_VAR 0 4
95937: PUSH
95938: LD_VAR 0 8
95942: NOT
95943: AND
95944: IFFALSE 96013
// begin sort := SortBySkill ( tmp , 4 ) ;
95946: LD_ADDR_VAR 0 9
95950: PUSH
95951: LD_VAR 0 4
95955: PPUSH
95956: LD_INT 4
95958: PPUSH
95959: CALL 55208 0 2
95963: ST_TO_ADDR
// if sort then
95964: LD_VAR 0 9
95968: IFFALSE 95984
// p := sort [ 1 ] ;
95970: LD_ADDR_VAR 0 11
95974: PUSH
95975: LD_VAR 0 9
95979: PUSH
95980: LD_INT 1
95982: ARRAY
95983: ST_TO_ADDR
// if p then
95984: LD_VAR 0 11
95988: IFFALSE 96013
// result := Replace ( result , 4 , p ) ;
95990: LD_ADDR_VAR 0 2
95994: PUSH
95995: LD_VAR 0 2
95999: PPUSH
96000: LD_INT 4
96002: PPUSH
96003: LD_VAR 0 11
96007: PPUSH
96008: CALL_OW 1
96012: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
96013: LD_ADDR_VAR 0 4
96017: PUSH
96018: LD_VAR 0 4
96022: PUSH
96023: LD_VAR 0 7
96027: DIFF
96028: ST_TO_ADDR
// if tmp and mech < 6 then
96029: LD_VAR 0 4
96033: PUSH
96034: LD_VAR 0 7
96038: PUSH
96039: LD_INT 6
96041: LESS
96042: AND
96043: IFFALSE 96225
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
96045: LD_ADDR_VAR 0 9
96049: PUSH
96050: LD_VAR 0 4
96054: PUSH
96055: LD_VAR 0 7
96059: DIFF
96060: PPUSH
96061: LD_INT 3
96063: PPUSH
96064: CALL 55208 0 2
96068: ST_TO_ADDR
// p := [ ] ;
96069: LD_ADDR_VAR 0 11
96073: PUSH
96074: EMPTY
96075: ST_TO_ADDR
// if sort then
96076: LD_VAR 0 9
96080: IFFALSE 96196
// for i = 1 to 6 - mech do
96082: LD_ADDR_VAR 0 3
96086: PUSH
96087: DOUBLE
96088: LD_INT 1
96090: DEC
96091: ST_TO_ADDR
96092: LD_INT 6
96094: PUSH
96095: LD_VAR 0 7
96099: MINUS
96100: PUSH
96101: FOR_TO
96102: IFFALSE 96194
// begin if i = sort then
96104: LD_VAR 0 3
96108: PUSH
96109: LD_VAR 0 9
96113: EQUAL
96114: IFFALSE 96118
// break ;
96116: GO 96194
// if GetClass ( i ) = 3 then
96118: LD_VAR 0 3
96122: PPUSH
96123: CALL_OW 257
96127: PUSH
96128: LD_INT 3
96130: EQUAL
96131: IFFALSE 96135
// continue ;
96133: GO 96101
// p := Insert ( p , p + 1 , sort [ i ] ) ;
96135: LD_ADDR_VAR 0 11
96139: PUSH
96140: LD_VAR 0 11
96144: PPUSH
96145: LD_VAR 0 11
96149: PUSH
96150: LD_INT 1
96152: PLUS
96153: PPUSH
96154: LD_VAR 0 9
96158: PUSH
96159: LD_VAR 0 3
96163: ARRAY
96164: PPUSH
96165: CALL_OW 2
96169: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
96170: LD_ADDR_VAR 0 4
96174: PUSH
96175: LD_VAR 0 4
96179: PUSH
96180: LD_VAR 0 9
96184: PUSH
96185: LD_VAR 0 3
96189: ARRAY
96190: DIFF
96191: ST_TO_ADDR
// end ;
96192: GO 96101
96194: POP
96195: POP
// if p then
96196: LD_VAR 0 11
96200: IFFALSE 96225
// result := Replace ( result , 3 , p ) ;
96202: LD_ADDR_VAR 0 2
96206: PUSH
96207: LD_VAR 0 2
96211: PPUSH
96212: LD_INT 3
96214: PPUSH
96215: LD_VAR 0 11
96219: PPUSH
96220: CALL_OW 1
96224: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
96225: LD_ADDR_VAR 0 4
96229: PUSH
96230: LD_VAR 0 4
96234: PUSH
96235: LD_VAR 0 6
96239: DIFF
96240: ST_TO_ADDR
// if tmp and eng < 4 then
96241: LD_VAR 0 4
96245: PUSH
96246: LD_VAR 0 6
96250: PUSH
96251: LD_INT 4
96253: LESS
96254: AND
96255: IFFALSE 96445
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
96257: LD_ADDR_VAR 0 9
96261: PUSH
96262: LD_VAR 0 4
96266: PUSH
96267: LD_VAR 0 7
96271: PUSH
96272: LD_VAR 0 6
96276: UNION
96277: DIFF
96278: PPUSH
96279: LD_INT 2
96281: PPUSH
96282: CALL 55208 0 2
96286: ST_TO_ADDR
// p := [ ] ;
96287: LD_ADDR_VAR 0 11
96291: PUSH
96292: EMPTY
96293: ST_TO_ADDR
// if sort then
96294: LD_VAR 0 9
96298: IFFALSE 96414
// for i = 1 to 4 - eng do
96300: LD_ADDR_VAR 0 3
96304: PUSH
96305: DOUBLE
96306: LD_INT 1
96308: DEC
96309: ST_TO_ADDR
96310: LD_INT 4
96312: PUSH
96313: LD_VAR 0 6
96317: MINUS
96318: PUSH
96319: FOR_TO
96320: IFFALSE 96412
// begin if i = sort then
96322: LD_VAR 0 3
96326: PUSH
96327: LD_VAR 0 9
96331: EQUAL
96332: IFFALSE 96336
// break ;
96334: GO 96412
// if GetClass ( i ) = 2 then
96336: LD_VAR 0 3
96340: PPUSH
96341: CALL_OW 257
96345: PUSH
96346: LD_INT 2
96348: EQUAL
96349: IFFALSE 96353
// continue ;
96351: GO 96319
// p := Insert ( p , p + 1 , sort [ i ] ) ;
96353: LD_ADDR_VAR 0 11
96357: PUSH
96358: LD_VAR 0 11
96362: PPUSH
96363: LD_VAR 0 11
96367: PUSH
96368: LD_INT 1
96370: PLUS
96371: PPUSH
96372: LD_VAR 0 9
96376: PUSH
96377: LD_VAR 0 3
96381: ARRAY
96382: PPUSH
96383: CALL_OW 2
96387: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
96388: LD_ADDR_VAR 0 4
96392: PUSH
96393: LD_VAR 0 4
96397: PUSH
96398: LD_VAR 0 9
96402: PUSH
96403: LD_VAR 0 3
96407: ARRAY
96408: DIFF
96409: ST_TO_ADDR
// end ;
96410: GO 96319
96412: POP
96413: POP
// if p then
96414: LD_VAR 0 11
96418: IFFALSE 96443
// result := Replace ( result , 2 , p ) ;
96420: LD_ADDR_VAR 0 2
96424: PUSH
96425: LD_VAR 0 2
96429: PPUSH
96430: LD_INT 2
96432: PPUSH
96433: LD_VAR 0 11
96437: PPUSH
96438: CALL_OW 1
96442: ST_TO_ADDR
// end else
96443: GO 96489
// for i = eng downto 5 do
96445: LD_ADDR_VAR 0 3
96449: PUSH
96450: DOUBLE
96451: LD_VAR 0 6
96455: INC
96456: ST_TO_ADDR
96457: LD_INT 5
96459: PUSH
96460: FOR_DOWNTO
96461: IFFALSE 96487
// tmp := tmp union eng [ i ] ;
96463: LD_ADDR_VAR 0 4
96467: PUSH
96468: LD_VAR 0 4
96472: PUSH
96473: LD_VAR 0 6
96477: PUSH
96478: LD_VAR 0 3
96482: ARRAY
96483: UNION
96484: ST_TO_ADDR
96485: GO 96460
96487: POP
96488: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
96489: LD_ADDR_VAR 0 2
96493: PUSH
96494: LD_VAR 0 2
96498: PPUSH
96499: LD_INT 1
96501: PPUSH
96502: LD_VAR 0 4
96506: PUSH
96507: LD_VAR 0 5
96511: DIFF
96512: PPUSH
96513: CALL_OW 1
96517: ST_TO_ADDR
// exit ;
96518: GO 96520
// end ; end ;
96520: LD_VAR 0 2
96524: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
96525: LD_INT 0
96527: PPUSH
96528: PPUSH
96529: PPUSH
// if not mc_bases then
96530: LD_EXP 161
96534: NOT
96535: IFFALSE 96539
// exit ;
96537: GO 96681
// for i = 1 to mc_bases do
96539: LD_ADDR_VAR 0 2
96543: PUSH
96544: DOUBLE
96545: LD_INT 1
96547: DEC
96548: ST_TO_ADDR
96549: LD_EXP 161
96553: PUSH
96554: FOR_TO
96555: IFFALSE 96672
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
96557: LD_ADDR_VAR 0 3
96561: PUSH
96562: LD_EXP 161
96566: PUSH
96567: LD_VAR 0 2
96571: ARRAY
96572: PPUSH
96573: LD_INT 21
96575: PUSH
96576: LD_INT 3
96578: PUSH
96579: EMPTY
96580: LIST
96581: LIST
96582: PUSH
96583: LD_INT 3
96585: PUSH
96586: LD_INT 2
96588: PUSH
96589: LD_INT 30
96591: PUSH
96592: LD_INT 29
96594: PUSH
96595: EMPTY
96596: LIST
96597: LIST
96598: PUSH
96599: LD_INT 30
96601: PUSH
96602: LD_INT 30
96604: PUSH
96605: EMPTY
96606: LIST
96607: LIST
96608: PUSH
96609: EMPTY
96610: LIST
96611: LIST
96612: LIST
96613: PUSH
96614: EMPTY
96615: LIST
96616: LIST
96617: PUSH
96618: LD_INT 3
96620: PUSH
96621: LD_INT 24
96623: PUSH
96624: LD_INT 1000
96626: PUSH
96627: EMPTY
96628: LIST
96629: LIST
96630: PUSH
96631: EMPTY
96632: LIST
96633: LIST
96634: PUSH
96635: EMPTY
96636: LIST
96637: LIST
96638: LIST
96639: PPUSH
96640: CALL_OW 72
96644: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
96645: LD_ADDR_EXP 162
96649: PUSH
96650: LD_EXP 162
96654: PPUSH
96655: LD_VAR 0 2
96659: PPUSH
96660: LD_VAR 0 3
96664: PPUSH
96665: CALL_OW 1
96669: ST_TO_ADDR
// end ;
96670: GO 96554
96672: POP
96673: POP
// RaiseSailEvent ( 101 ) ;
96674: LD_INT 101
96676: PPUSH
96677: CALL_OW 427
// end ;
96681: LD_VAR 0 1
96685: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
96686: LD_INT 0
96688: PPUSH
96689: PPUSH
96690: PPUSH
96691: PPUSH
96692: PPUSH
96693: PPUSH
96694: PPUSH
// if not mc_bases then
96695: LD_EXP 161
96699: NOT
96700: IFFALSE 96704
// exit ;
96702: GO 97266
// for i = 1 to mc_bases do
96704: LD_ADDR_VAR 0 2
96708: PUSH
96709: DOUBLE
96710: LD_INT 1
96712: DEC
96713: ST_TO_ADDR
96714: LD_EXP 161
96718: PUSH
96719: FOR_TO
96720: IFFALSE 97257
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
96722: LD_ADDR_VAR 0 5
96726: PUSH
96727: LD_EXP 161
96731: PUSH
96732: LD_VAR 0 2
96736: ARRAY
96737: PUSH
96738: LD_EXP 190
96742: PUSH
96743: LD_VAR 0 2
96747: ARRAY
96748: UNION
96749: PPUSH
96750: LD_INT 21
96752: PUSH
96753: LD_INT 1
96755: PUSH
96756: EMPTY
96757: LIST
96758: LIST
96759: PUSH
96760: LD_INT 1
96762: PUSH
96763: LD_INT 3
96765: PUSH
96766: LD_INT 54
96768: PUSH
96769: EMPTY
96770: LIST
96771: PUSH
96772: EMPTY
96773: LIST
96774: LIST
96775: PUSH
96776: LD_INT 3
96778: PUSH
96779: LD_INT 24
96781: PUSH
96782: LD_INT 1000
96784: PUSH
96785: EMPTY
96786: LIST
96787: LIST
96788: PUSH
96789: EMPTY
96790: LIST
96791: LIST
96792: PUSH
96793: EMPTY
96794: LIST
96795: LIST
96796: LIST
96797: PUSH
96798: EMPTY
96799: LIST
96800: LIST
96801: PPUSH
96802: CALL_OW 72
96806: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
96807: LD_ADDR_VAR 0 6
96811: PUSH
96812: LD_EXP 161
96816: PUSH
96817: LD_VAR 0 2
96821: ARRAY
96822: PPUSH
96823: LD_INT 21
96825: PUSH
96826: LD_INT 1
96828: PUSH
96829: EMPTY
96830: LIST
96831: LIST
96832: PUSH
96833: LD_INT 1
96835: PUSH
96836: LD_INT 3
96838: PUSH
96839: LD_INT 54
96841: PUSH
96842: EMPTY
96843: LIST
96844: PUSH
96845: EMPTY
96846: LIST
96847: LIST
96848: PUSH
96849: LD_INT 3
96851: PUSH
96852: LD_INT 24
96854: PUSH
96855: LD_INT 250
96857: PUSH
96858: EMPTY
96859: LIST
96860: LIST
96861: PUSH
96862: EMPTY
96863: LIST
96864: LIST
96865: PUSH
96866: EMPTY
96867: LIST
96868: LIST
96869: LIST
96870: PUSH
96871: EMPTY
96872: LIST
96873: LIST
96874: PPUSH
96875: CALL_OW 72
96879: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
96880: LD_ADDR_VAR 0 7
96884: PUSH
96885: LD_VAR 0 5
96889: PUSH
96890: LD_VAR 0 6
96894: DIFF
96895: ST_TO_ADDR
// if not need_heal_1 then
96896: LD_VAR 0 6
96900: NOT
96901: IFFALSE 96934
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
96903: LD_ADDR_EXP 164
96907: PUSH
96908: LD_EXP 164
96912: PPUSH
96913: LD_VAR 0 2
96917: PUSH
96918: LD_INT 1
96920: PUSH
96921: EMPTY
96922: LIST
96923: LIST
96924: PPUSH
96925: EMPTY
96926: PPUSH
96927: CALL 24361 0 3
96931: ST_TO_ADDR
96932: GO 97004
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
96934: LD_ADDR_EXP 164
96938: PUSH
96939: LD_EXP 164
96943: PPUSH
96944: LD_VAR 0 2
96948: PUSH
96949: LD_INT 1
96951: PUSH
96952: EMPTY
96953: LIST
96954: LIST
96955: PPUSH
96956: LD_EXP 164
96960: PUSH
96961: LD_VAR 0 2
96965: ARRAY
96966: PUSH
96967: LD_INT 1
96969: ARRAY
96970: PPUSH
96971: LD_INT 3
96973: PUSH
96974: LD_INT 24
96976: PUSH
96977: LD_INT 1000
96979: PUSH
96980: EMPTY
96981: LIST
96982: LIST
96983: PUSH
96984: EMPTY
96985: LIST
96986: LIST
96987: PPUSH
96988: CALL_OW 72
96992: PUSH
96993: LD_VAR 0 6
96997: UNION
96998: PPUSH
96999: CALL 24361 0 3
97003: ST_TO_ADDR
// if not need_heal_2 then
97004: LD_VAR 0 7
97008: NOT
97009: IFFALSE 97042
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
97011: LD_ADDR_EXP 164
97015: PUSH
97016: LD_EXP 164
97020: PPUSH
97021: LD_VAR 0 2
97025: PUSH
97026: LD_INT 2
97028: PUSH
97029: EMPTY
97030: LIST
97031: LIST
97032: PPUSH
97033: EMPTY
97034: PPUSH
97035: CALL 24361 0 3
97039: ST_TO_ADDR
97040: GO 97074
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
97042: LD_ADDR_EXP 164
97046: PUSH
97047: LD_EXP 164
97051: PPUSH
97052: LD_VAR 0 2
97056: PUSH
97057: LD_INT 2
97059: PUSH
97060: EMPTY
97061: LIST
97062: LIST
97063: PPUSH
97064: LD_VAR 0 7
97068: PPUSH
97069: CALL 24361 0 3
97073: ST_TO_ADDR
// if need_heal_2 then
97074: LD_VAR 0 7
97078: IFFALSE 97239
// for j in need_heal_2 do
97080: LD_ADDR_VAR 0 3
97084: PUSH
97085: LD_VAR 0 7
97089: PUSH
97090: FOR_IN
97091: IFFALSE 97237
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
97093: LD_ADDR_VAR 0 5
97097: PUSH
97098: LD_EXP 161
97102: PUSH
97103: LD_VAR 0 2
97107: ARRAY
97108: PPUSH
97109: LD_INT 2
97111: PUSH
97112: LD_INT 30
97114: PUSH
97115: LD_INT 6
97117: PUSH
97118: EMPTY
97119: LIST
97120: LIST
97121: PUSH
97122: LD_INT 30
97124: PUSH
97125: LD_INT 7
97127: PUSH
97128: EMPTY
97129: LIST
97130: LIST
97131: PUSH
97132: LD_INT 30
97134: PUSH
97135: LD_INT 8
97137: PUSH
97138: EMPTY
97139: LIST
97140: LIST
97141: PUSH
97142: LD_INT 30
97144: PUSH
97145: LD_INT 0
97147: PUSH
97148: EMPTY
97149: LIST
97150: LIST
97151: PUSH
97152: LD_INT 30
97154: PUSH
97155: LD_INT 1
97157: PUSH
97158: EMPTY
97159: LIST
97160: LIST
97161: PUSH
97162: EMPTY
97163: LIST
97164: LIST
97165: LIST
97166: LIST
97167: LIST
97168: LIST
97169: PPUSH
97170: CALL_OW 72
97174: ST_TO_ADDR
// if tmp then
97175: LD_VAR 0 5
97179: IFFALSE 97235
// begin k := NearestUnitToUnit ( tmp , j ) ;
97181: LD_ADDR_VAR 0 4
97185: PUSH
97186: LD_VAR 0 5
97190: PPUSH
97191: LD_VAR 0 3
97195: PPUSH
97196: CALL_OW 74
97200: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
97201: LD_VAR 0 3
97205: PPUSH
97206: LD_VAR 0 4
97210: PPUSH
97211: CALL_OW 296
97215: PUSH
97216: LD_INT 5
97218: GREATER
97219: IFFALSE 97235
// ComMoveToNearbyEntrance ( j , k ) ;
97221: LD_VAR 0 3
97225: PPUSH
97226: LD_VAR 0 4
97230: PPUSH
97231: CALL 57569 0 2
// end ; end ;
97235: GO 97090
97237: POP
97238: POP
// if not need_heal_1 and not need_heal_2 then
97239: LD_VAR 0 6
97243: NOT
97244: PUSH
97245: LD_VAR 0 7
97249: NOT
97250: AND
97251: IFFALSE 97255
// continue ;
97253: GO 96719
// end ;
97255: GO 96719
97257: POP
97258: POP
// RaiseSailEvent ( 102 ) ;
97259: LD_INT 102
97261: PPUSH
97262: CALL_OW 427
// end ;
97266: LD_VAR 0 1
97270: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
97271: LD_INT 0
97273: PPUSH
97274: PPUSH
97275: PPUSH
97276: PPUSH
97277: PPUSH
97278: PPUSH
97279: PPUSH
97280: PPUSH
// if not mc_bases then
97281: LD_EXP 161
97285: NOT
97286: IFFALSE 97290
// exit ;
97288: GO 98201
// for i = 1 to mc_bases do
97290: LD_ADDR_VAR 0 2
97294: PUSH
97295: DOUBLE
97296: LD_INT 1
97298: DEC
97299: ST_TO_ADDR
97300: LD_EXP 161
97304: PUSH
97305: FOR_TO
97306: IFFALSE 98199
// begin if not mc_building_need_repair [ i ] then
97308: LD_EXP 162
97312: PUSH
97313: LD_VAR 0 2
97317: ARRAY
97318: NOT
97319: IFFALSE 97504
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
97321: LD_ADDR_VAR 0 6
97325: PUSH
97326: LD_EXP 180
97330: PUSH
97331: LD_VAR 0 2
97335: ARRAY
97336: PPUSH
97337: LD_INT 3
97339: PUSH
97340: LD_INT 24
97342: PUSH
97343: LD_INT 1000
97345: PUSH
97346: EMPTY
97347: LIST
97348: LIST
97349: PUSH
97350: EMPTY
97351: LIST
97352: LIST
97353: PUSH
97354: LD_INT 2
97356: PUSH
97357: LD_INT 34
97359: PUSH
97360: LD_INT 13
97362: PUSH
97363: EMPTY
97364: LIST
97365: LIST
97366: PUSH
97367: LD_INT 34
97369: PUSH
97370: LD_INT 52
97372: PUSH
97373: EMPTY
97374: LIST
97375: LIST
97376: PUSH
97377: LD_INT 34
97379: PUSH
97380: LD_INT 88
97382: PUSH
97383: EMPTY
97384: LIST
97385: LIST
97386: PUSH
97387: EMPTY
97388: LIST
97389: LIST
97390: LIST
97391: LIST
97392: PUSH
97393: EMPTY
97394: LIST
97395: LIST
97396: PPUSH
97397: CALL_OW 72
97401: ST_TO_ADDR
// if cranes then
97402: LD_VAR 0 6
97406: IFFALSE 97468
// for j in cranes do
97408: LD_ADDR_VAR 0 3
97412: PUSH
97413: LD_VAR 0 6
97417: PUSH
97418: FOR_IN
97419: IFFALSE 97466
// if not IsInArea ( j , mc_parking [ i ] ) then
97421: LD_VAR 0 3
97425: PPUSH
97426: LD_EXP 185
97430: PUSH
97431: LD_VAR 0 2
97435: ARRAY
97436: PPUSH
97437: CALL_OW 308
97441: NOT
97442: IFFALSE 97464
// ComMoveToArea ( j , mc_parking [ i ] ) ;
97444: LD_VAR 0 3
97448: PPUSH
97449: LD_EXP 185
97453: PUSH
97454: LD_VAR 0 2
97458: ARRAY
97459: PPUSH
97460: CALL_OW 113
97464: GO 97418
97466: POP
97467: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
97468: LD_ADDR_EXP 163
97472: PUSH
97473: LD_EXP 163
97477: PPUSH
97478: LD_VAR 0 2
97482: PPUSH
97483: EMPTY
97484: PPUSH
97485: CALL_OW 1
97489: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
97490: LD_VAR 0 2
97494: PPUSH
97495: LD_INT 101
97497: PPUSH
97498: CALL 92358 0 2
// continue ;
97502: GO 97305
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
97504: LD_ADDR_EXP 167
97508: PUSH
97509: LD_EXP 167
97513: PPUSH
97514: LD_VAR 0 2
97518: PPUSH
97519: EMPTY
97520: PPUSH
97521: CALL_OW 1
97525: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
97526: LD_VAR 0 2
97530: PPUSH
97531: LD_INT 103
97533: PPUSH
97534: CALL 92358 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
97538: LD_ADDR_VAR 0 5
97542: PUSH
97543: LD_EXP 161
97547: PUSH
97548: LD_VAR 0 2
97552: ARRAY
97553: PUSH
97554: LD_EXP 190
97558: PUSH
97559: LD_VAR 0 2
97563: ARRAY
97564: UNION
97565: PPUSH
97566: LD_INT 2
97568: PUSH
97569: LD_INT 25
97571: PUSH
97572: LD_INT 2
97574: PUSH
97575: EMPTY
97576: LIST
97577: LIST
97578: PUSH
97579: LD_INT 25
97581: PUSH
97582: LD_INT 16
97584: PUSH
97585: EMPTY
97586: LIST
97587: LIST
97588: PUSH
97589: EMPTY
97590: LIST
97591: LIST
97592: LIST
97593: PUSH
97594: EMPTY
97595: LIST
97596: PPUSH
97597: CALL_OW 72
97601: ST_TO_ADDR
// if mc_need_heal [ i ] then
97602: LD_EXP 164
97606: PUSH
97607: LD_VAR 0 2
97611: ARRAY
97612: IFFALSE 97656
// tmp := tmp diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
97614: LD_ADDR_VAR 0 5
97618: PUSH
97619: LD_VAR 0 5
97623: PUSH
97624: LD_EXP 164
97628: PUSH
97629: LD_VAR 0 2
97633: ARRAY
97634: PUSH
97635: LD_INT 1
97637: ARRAY
97638: PUSH
97639: LD_EXP 164
97643: PUSH
97644: LD_VAR 0 2
97648: ARRAY
97649: PUSH
97650: LD_INT 2
97652: ARRAY
97653: UNION
97654: DIFF
97655: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
97656: LD_ADDR_VAR 0 6
97660: PUSH
97661: LD_EXP 180
97665: PUSH
97666: LD_VAR 0 2
97670: ARRAY
97671: PPUSH
97672: LD_INT 2
97674: PUSH
97675: LD_INT 34
97677: PUSH
97678: LD_INT 13
97680: PUSH
97681: EMPTY
97682: LIST
97683: LIST
97684: PUSH
97685: LD_INT 34
97687: PUSH
97688: LD_INT 52
97690: PUSH
97691: EMPTY
97692: LIST
97693: LIST
97694: PUSH
97695: LD_INT 34
97697: PUSH
97698: LD_INT 88
97700: PUSH
97701: EMPTY
97702: LIST
97703: LIST
97704: PUSH
97705: EMPTY
97706: LIST
97707: LIST
97708: LIST
97709: LIST
97710: PPUSH
97711: CALL_OW 72
97715: ST_TO_ADDR
// if cranes then
97716: LD_VAR 0 6
97720: IFFALSE 97888
// begin for j in cranes do
97722: LD_ADDR_VAR 0 3
97726: PUSH
97727: LD_VAR 0 6
97731: PUSH
97732: FOR_IN
97733: IFFALSE 97886
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
97735: LD_VAR 0 3
97739: PPUSH
97740: CALL_OW 256
97744: PUSH
97745: LD_INT 1000
97747: EQUAL
97748: PUSH
97749: LD_VAR 0 3
97753: PPUSH
97754: CALL_OW 314
97758: NOT
97759: AND
97760: IFFALSE 97826
// begin to_repair := NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ;
97762: LD_ADDR_VAR 0 8
97766: PUSH
97767: LD_EXP 162
97771: PUSH
97772: LD_VAR 0 2
97776: ARRAY
97777: PPUSH
97778: LD_VAR 0 3
97782: PPUSH
97783: CALL_OW 74
97787: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
97788: LD_VAR 0 8
97792: PPUSH
97793: LD_INT 16
97795: PPUSH
97796: CALL 26958 0 2
97800: PUSH
97801: LD_INT 4
97803: ARRAY
97804: PUSH
97805: LD_INT 10
97807: LESS
97808: IFFALSE 97824
// ComRepairBuilding ( j , to_repair ) ;
97810: LD_VAR 0 3
97814: PPUSH
97815: LD_VAR 0 8
97819: PPUSH
97820: CALL_OW 130
// end else
97824: GO 97884
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
97826: LD_VAR 0 3
97830: PPUSH
97831: CALL_OW 256
97835: PUSH
97836: LD_INT 500
97838: LESS
97839: PUSH
97840: LD_VAR 0 3
97844: PPUSH
97845: LD_EXP 185
97849: PUSH
97850: LD_VAR 0 2
97854: ARRAY
97855: PPUSH
97856: CALL_OW 308
97860: NOT
97861: AND
97862: IFFALSE 97884
// ComMoveToArea ( j , mc_parking [ i ] ) ;
97864: LD_VAR 0 3
97868: PPUSH
97869: LD_EXP 185
97873: PUSH
97874: LD_VAR 0 2
97878: ARRAY
97879: PPUSH
97880: CALL_OW 113
// end ;
97884: GO 97732
97886: POP
97887: POP
// end ; if tmp > 3 then
97888: LD_VAR 0 5
97892: PUSH
97893: LD_INT 3
97895: GREATER
97896: IFFALSE 97916
// tmp := ShrinkArray ( tmp , 4 ) ;
97898: LD_ADDR_VAR 0 5
97902: PUSH
97903: LD_VAR 0 5
97907: PPUSH
97908: LD_INT 4
97910: PPUSH
97911: CALL 57007 0 2
97915: ST_TO_ADDR
// if not tmp then
97916: LD_VAR 0 5
97920: NOT
97921: IFFALSE 97925
// continue ;
97923: GO 97305
// for j in tmp do
97925: LD_ADDR_VAR 0 3
97929: PUSH
97930: LD_VAR 0 5
97934: PUSH
97935: FOR_IN
97936: IFFALSE 98195
// begin if IsInUnit ( j ) then
97938: LD_VAR 0 3
97942: PPUSH
97943: CALL_OW 310
97947: IFFALSE 97958
// ComExitBuilding ( j ) ;
97949: LD_VAR 0 3
97953: PPUSH
97954: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
97958: LD_VAR 0 3
97962: PUSH
97963: LD_EXP 163
97967: PUSH
97968: LD_VAR 0 2
97972: ARRAY
97973: IN
97974: NOT
97975: IFFALSE 98033
// begin SetTag ( j , 101 ) ;
97977: LD_VAR 0 3
97981: PPUSH
97982: LD_INT 101
97984: PPUSH
97985: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
97989: LD_ADDR_EXP 163
97993: PUSH
97994: LD_EXP 163
97998: PPUSH
97999: LD_VAR 0 2
98003: PUSH
98004: LD_EXP 163
98008: PUSH
98009: LD_VAR 0 2
98013: ARRAY
98014: PUSH
98015: LD_INT 1
98017: PLUS
98018: PUSH
98019: EMPTY
98020: LIST
98021: LIST
98022: PPUSH
98023: LD_VAR 0 3
98027: PPUSH
98028: CALL 24361 0 3
98032: ST_TO_ADDR
// end ; wait ( 1 ) ;
98033: LD_INT 1
98035: PPUSH
98036: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
98040: LD_ADDR_VAR 0 7
98044: PUSH
98045: LD_EXP 162
98049: PUSH
98050: LD_VAR 0 2
98054: ARRAY
98055: ST_TO_ADDR
// if mc_scan [ i ] then
98056: LD_EXP 184
98060: PUSH
98061: LD_VAR 0 2
98065: ARRAY
98066: IFFALSE 98128
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
98068: LD_ADDR_VAR 0 7
98072: PUSH
98073: LD_EXP 162
98077: PUSH
98078: LD_VAR 0 2
98082: ARRAY
98083: PPUSH
98084: LD_INT 3
98086: PUSH
98087: LD_INT 30
98089: PUSH
98090: LD_INT 32
98092: PUSH
98093: EMPTY
98094: LIST
98095: LIST
98096: PUSH
98097: LD_INT 30
98099: PUSH
98100: LD_INT 33
98102: PUSH
98103: EMPTY
98104: LIST
98105: LIST
98106: PUSH
98107: LD_INT 30
98109: PUSH
98110: LD_INT 31
98112: PUSH
98113: EMPTY
98114: LIST
98115: LIST
98116: PUSH
98117: EMPTY
98118: LIST
98119: LIST
98120: LIST
98121: LIST
98122: PPUSH
98123: CALL_OW 72
98127: ST_TO_ADDR
// if not to_repair_tmp then
98128: LD_VAR 0 7
98132: NOT
98133: IFFALSE 98137
// continue ;
98135: GO 97935
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
98137: LD_ADDR_VAR 0 8
98141: PUSH
98142: LD_VAR 0 7
98146: PPUSH
98147: LD_VAR 0 3
98151: PPUSH
98152: CALL_OW 74
98156: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 14 then
98157: LD_VAR 0 8
98161: PPUSH
98162: LD_INT 16
98164: PPUSH
98165: CALL 26958 0 2
98169: PUSH
98170: LD_INT 4
98172: ARRAY
98173: PUSH
98174: LD_INT 14
98176: LESS
98177: IFFALSE 98193
// ComRepairBuilding ( j , to_repair ) ;
98179: LD_VAR 0 3
98183: PPUSH
98184: LD_VAR 0 8
98188: PPUSH
98189: CALL_OW 130
// end ;
98193: GO 97935
98195: POP
98196: POP
// end ;
98197: GO 97305
98199: POP
98200: POP
// end ;
98201: LD_VAR 0 1
98205: RET
// export function MC_Heal ; var i , j , tmp ; begin
98206: LD_INT 0
98208: PPUSH
98209: PPUSH
98210: PPUSH
98211: PPUSH
// if not mc_bases then
98212: LD_EXP 161
98216: NOT
98217: IFFALSE 98221
// exit ;
98219: GO 98623
// for i = 1 to mc_bases do
98221: LD_ADDR_VAR 0 2
98225: PUSH
98226: DOUBLE
98227: LD_INT 1
98229: DEC
98230: ST_TO_ADDR
98231: LD_EXP 161
98235: PUSH
98236: FOR_TO
98237: IFFALSE 98621
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
98239: LD_EXP 164
98243: PUSH
98244: LD_VAR 0 2
98248: ARRAY
98249: PUSH
98250: LD_INT 1
98252: ARRAY
98253: NOT
98254: PUSH
98255: LD_EXP 164
98259: PUSH
98260: LD_VAR 0 2
98264: ARRAY
98265: PUSH
98266: LD_INT 2
98268: ARRAY
98269: NOT
98270: AND
98271: IFFALSE 98309
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
98273: LD_ADDR_EXP 165
98277: PUSH
98278: LD_EXP 165
98282: PPUSH
98283: LD_VAR 0 2
98287: PPUSH
98288: EMPTY
98289: PPUSH
98290: CALL_OW 1
98294: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
98295: LD_VAR 0 2
98299: PPUSH
98300: LD_INT 102
98302: PPUSH
98303: CALL 92358 0 2
// continue ;
98307: GO 98236
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
98309: LD_ADDR_VAR 0 4
98313: PUSH
98314: LD_EXP 161
98318: PUSH
98319: LD_VAR 0 2
98323: ARRAY
98324: PPUSH
98325: LD_INT 25
98327: PUSH
98328: LD_INT 4
98330: PUSH
98331: EMPTY
98332: LIST
98333: LIST
98334: PPUSH
98335: CALL_OW 72
98339: ST_TO_ADDR
// if not tmp then
98340: LD_VAR 0 4
98344: NOT
98345: IFFALSE 98349
// continue ;
98347: GO 98236
// if mc_taming [ i ] then
98349: LD_EXP 192
98353: PUSH
98354: LD_VAR 0 2
98358: ARRAY
98359: IFFALSE 98383
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
98361: LD_ADDR_EXP 192
98365: PUSH
98366: LD_EXP 192
98370: PPUSH
98371: LD_VAR 0 2
98375: PPUSH
98376: EMPTY
98377: PPUSH
98378: CALL_OW 1
98382: ST_TO_ADDR
// for j in tmp do
98383: LD_ADDR_VAR 0 3
98387: PUSH
98388: LD_VAR 0 4
98392: PUSH
98393: FOR_IN
98394: IFFALSE 98617
// begin if IsInUnit ( j ) then
98396: LD_VAR 0 3
98400: PPUSH
98401: CALL_OW 310
98405: IFFALSE 98416
// ComExitBuilding ( j ) ;
98407: LD_VAR 0 3
98411: PPUSH
98412: CALL_OW 122
// if not j in mc_healers [ i ] then
98416: LD_VAR 0 3
98420: PUSH
98421: LD_EXP 165
98425: PUSH
98426: LD_VAR 0 2
98430: ARRAY
98431: IN
98432: NOT
98433: IFFALSE 98479
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
98435: LD_ADDR_EXP 165
98439: PUSH
98440: LD_EXP 165
98444: PPUSH
98445: LD_VAR 0 2
98449: PUSH
98450: LD_EXP 165
98454: PUSH
98455: LD_VAR 0 2
98459: ARRAY
98460: PUSH
98461: LD_INT 1
98463: PLUS
98464: PUSH
98465: EMPTY
98466: LIST
98467: LIST
98468: PPUSH
98469: LD_VAR 0 3
98473: PPUSH
98474: CALL 24361 0 3
98478: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
98479: LD_VAR 0 3
98483: PPUSH
98484: CALL_OW 110
98488: PUSH
98489: LD_INT 102
98491: NONEQUAL
98492: IFFALSE 98506
// SetTag ( j , 102 ) ;
98494: LD_VAR 0 3
98498: PPUSH
98499: LD_INT 102
98501: PPUSH
98502: CALL_OW 109
// Wait ( 3 ) ;
98506: LD_INT 3
98508: PPUSH
98509: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
98513: LD_EXP 164
98517: PUSH
98518: LD_VAR 0 2
98522: ARRAY
98523: PUSH
98524: LD_INT 1
98526: ARRAY
98527: IFFALSE 98559
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
98529: LD_VAR 0 3
98533: PPUSH
98534: LD_EXP 164
98538: PUSH
98539: LD_VAR 0 2
98543: ARRAY
98544: PUSH
98545: LD_INT 1
98547: ARRAY
98548: PUSH
98549: LD_INT 1
98551: ARRAY
98552: PPUSH
98553: CALL_OW 128
98557: GO 98615
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
98559: LD_VAR 0 3
98563: PPUSH
98564: CALL_OW 314
98568: NOT
98569: PUSH
98570: LD_EXP 164
98574: PUSH
98575: LD_VAR 0 2
98579: ARRAY
98580: PUSH
98581: LD_INT 2
98583: ARRAY
98584: AND
98585: IFFALSE 98615
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
98587: LD_VAR 0 3
98591: PPUSH
98592: LD_EXP 164
98596: PUSH
98597: LD_VAR 0 2
98601: ARRAY
98602: PUSH
98603: LD_INT 2
98605: ARRAY
98606: PUSH
98607: LD_INT 1
98609: ARRAY
98610: PPUSH
98611: CALL_OW 128
// end ;
98615: GO 98393
98617: POP
98618: POP
// end ;
98619: GO 98236
98621: POP
98622: POP
// end ;
98623: LD_VAR 0 1
98627: RET
// export function MC_Build ( ) ; var i , j , k , tmp , depot ; begin
98628: LD_INT 0
98630: PPUSH
98631: PPUSH
98632: PPUSH
98633: PPUSH
98634: PPUSH
98635: PPUSH
// if not mc_bases then
98636: LD_EXP 161
98640: NOT
98641: IFFALSE 98645
// exit ;
98643: GO 99808
// for i = 1 to mc_bases do
98645: LD_ADDR_VAR 0 2
98649: PUSH
98650: DOUBLE
98651: LD_INT 1
98653: DEC
98654: ST_TO_ADDR
98655: LD_EXP 161
98659: PUSH
98660: FOR_TO
98661: IFFALSE 99806
// begin if mc_scan [ i ] then
98663: LD_EXP 184
98667: PUSH
98668: LD_VAR 0 2
98672: ARRAY
98673: IFFALSE 98677
// continue ;
98675: GO 98660
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
98677: LD_EXP 166
98681: PUSH
98682: LD_VAR 0 2
98686: ARRAY
98687: NOT
98688: PUSH
98689: LD_EXP 168
98693: PUSH
98694: LD_VAR 0 2
98698: ARRAY
98699: NOT
98700: AND
98701: PUSH
98702: LD_EXP 167
98706: PUSH
98707: LD_VAR 0 2
98711: ARRAY
98712: AND
98713: IFFALSE 98751
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
98715: LD_ADDR_EXP 167
98719: PUSH
98720: LD_EXP 167
98724: PPUSH
98725: LD_VAR 0 2
98729: PPUSH
98730: EMPTY
98731: PPUSH
98732: CALL_OW 1
98736: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
98737: LD_VAR 0 2
98741: PPUSH
98742: LD_INT 103
98744: PPUSH
98745: CALL 92358 0 2
// continue ;
98749: GO 98660
// end ; if mc_construct_list [ i ] then
98751: LD_EXP 168
98755: PUSH
98756: LD_VAR 0 2
98760: ARRAY
98761: IFFALSE 98981
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
98763: LD_ADDR_VAR 0 5
98767: PUSH
98768: LD_EXP 161
98772: PUSH
98773: LD_VAR 0 2
98777: ARRAY
98778: PPUSH
98779: LD_INT 25
98781: PUSH
98782: LD_INT 2
98784: PUSH
98785: EMPTY
98786: LIST
98787: LIST
98788: PPUSH
98789: CALL_OW 72
98793: PUSH
98794: LD_EXP 163
98798: PUSH
98799: LD_VAR 0 2
98803: ARRAY
98804: DIFF
98805: ST_TO_ADDR
// if not tmp then
98806: LD_VAR 0 5
98810: NOT
98811: IFFALSE 98815
// continue ;
98813: GO 98660
// for j in tmp do
98815: LD_ADDR_VAR 0 3
98819: PUSH
98820: LD_VAR 0 5
98824: PUSH
98825: FOR_IN
98826: IFFALSE 98977
// begin if not mc_builders [ i ] then
98828: LD_EXP 167
98832: PUSH
98833: LD_VAR 0 2
98837: ARRAY
98838: NOT
98839: IFFALSE 98897
// begin SetTag ( j , 103 ) ;
98841: LD_VAR 0 3
98845: PPUSH
98846: LD_INT 103
98848: PPUSH
98849: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
98853: LD_ADDR_EXP 167
98857: PUSH
98858: LD_EXP 167
98862: PPUSH
98863: LD_VAR 0 2
98867: PUSH
98868: LD_EXP 167
98872: PUSH
98873: LD_VAR 0 2
98877: ARRAY
98878: PUSH
98879: LD_INT 1
98881: PLUS
98882: PUSH
98883: EMPTY
98884: LIST
98885: LIST
98886: PPUSH
98887: LD_VAR 0 3
98891: PPUSH
98892: CALL 24361 0 3
98896: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
98897: LD_VAR 0 3
98901: PPUSH
98902: CALL_OW 310
98906: IFFALSE 98917
// ComExitBuilding ( j ) ;
98908: LD_VAR 0 3
98912: PPUSH
98913: CALL_OW 122
// wait ( 3 ) ;
98917: LD_INT 3
98919: PPUSH
98920: CALL_OW 67
// if not mc_construct_list [ i ] then
98924: LD_EXP 168
98928: PUSH
98929: LD_VAR 0 2
98933: ARRAY
98934: NOT
98935: IFFALSE 98939
// break ;
98937: GO 98977
// if not HasTask ( j ) then
98939: LD_VAR 0 3
98943: PPUSH
98944: CALL_OW 314
98948: NOT
98949: IFFALSE 98975
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
98951: LD_VAR 0 3
98955: PPUSH
98956: LD_EXP 168
98960: PUSH
98961: LD_VAR 0 2
98965: ARRAY
98966: PUSH
98967: LD_INT 1
98969: ARRAY
98970: PPUSH
98971: CALL 27222 0 2
// end ;
98975: GO 98825
98977: POP
98978: POP
// end else
98979: GO 99804
// if mc_build_list [ i ] then
98981: LD_EXP 166
98985: PUSH
98986: LD_VAR 0 2
98990: ARRAY
98991: IFFALSE 99804
// begin if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
98993: LD_EXP 166
98997: PUSH
98998: LD_VAR 0 2
99002: ARRAY
99003: PUSH
99004: LD_INT 1
99006: ARRAY
99007: PUSH
99008: LD_INT 1
99010: ARRAY
99011: PPUSH
99012: CALL 27046 0 1
99016: PUSH
99017: LD_EXP 161
99021: PUSH
99022: LD_VAR 0 2
99026: ARRAY
99027: PPUSH
99028: LD_INT 2
99030: PUSH
99031: LD_INT 30
99033: PUSH
99034: LD_INT 2
99036: PUSH
99037: EMPTY
99038: LIST
99039: LIST
99040: PUSH
99041: LD_INT 30
99043: PUSH
99044: LD_INT 3
99046: PUSH
99047: EMPTY
99048: LIST
99049: LIST
99050: PUSH
99051: EMPTY
99052: LIST
99053: LIST
99054: LIST
99055: PPUSH
99056: CALL_OW 72
99060: NOT
99061: AND
99062: IFFALSE 99167
// begin for j = 1 to mc_build_list [ i ] do
99064: LD_ADDR_VAR 0 3
99068: PUSH
99069: DOUBLE
99070: LD_INT 1
99072: DEC
99073: ST_TO_ADDR
99074: LD_EXP 166
99078: PUSH
99079: LD_VAR 0 2
99083: ARRAY
99084: PUSH
99085: FOR_TO
99086: IFFALSE 99165
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
99088: LD_EXP 166
99092: PUSH
99093: LD_VAR 0 2
99097: ARRAY
99098: PUSH
99099: LD_VAR 0 3
99103: ARRAY
99104: PUSH
99105: LD_INT 1
99107: ARRAY
99108: PUSH
99109: LD_INT 2
99111: EQUAL
99112: IFFALSE 99163
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
99114: LD_ADDR_EXP 166
99118: PUSH
99119: LD_EXP 166
99123: PPUSH
99124: LD_VAR 0 2
99128: PPUSH
99129: LD_EXP 166
99133: PUSH
99134: LD_VAR 0 2
99138: ARRAY
99139: PPUSH
99140: LD_VAR 0 3
99144: PPUSH
99145: LD_INT 1
99147: PPUSH
99148: LD_INT 0
99150: PPUSH
99151: CALL 23779 0 4
99155: PPUSH
99156: CALL_OW 1
99160: ST_TO_ADDR
// break ;
99161: GO 99165
// end ;
99163: GO 99085
99165: POP
99166: POP
// end ; depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
99167: LD_ADDR_VAR 0 6
99171: PUSH
99172: LD_EXP 161
99176: PUSH
99177: LD_VAR 0 2
99181: ARRAY
99182: PPUSH
99183: LD_INT 2
99185: PUSH
99186: LD_INT 30
99188: PUSH
99189: LD_INT 0
99191: PUSH
99192: EMPTY
99193: LIST
99194: LIST
99195: PUSH
99196: LD_INT 30
99198: PUSH
99199: LD_INT 1
99201: PUSH
99202: EMPTY
99203: LIST
99204: LIST
99205: PUSH
99206: EMPTY
99207: LIST
99208: LIST
99209: LIST
99210: PPUSH
99211: CALL_OW 72
99215: ST_TO_ADDR
// for k := 1 to depot do
99216: LD_ADDR_VAR 0 4
99220: PUSH
99221: DOUBLE
99222: LD_INT 1
99224: DEC
99225: ST_TO_ADDR
99226: LD_VAR 0 6
99230: PUSH
99231: FOR_TO
99232: IFFALSE 99802
// begin if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or CanBeBuilt ( depot [ k ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
99234: LD_EXP 166
99238: PUSH
99239: LD_VAR 0 2
99243: ARRAY
99244: PUSH
99245: LD_INT 1
99247: ARRAY
99248: PUSH
99249: LD_INT 1
99251: ARRAY
99252: PUSH
99253: LD_INT 0
99255: EQUAL
99256: PUSH
99257: LD_VAR 0 6
99261: PUSH
99262: LD_VAR 0 4
99266: ARRAY
99267: PPUSH
99268: LD_EXP 166
99272: PUSH
99273: LD_VAR 0 2
99277: ARRAY
99278: PUSH
99279: LD_INT 1
99281: ARRAY
99282: PUSH
99283: LD_INT 1
99285: ARRAY
99286: PPUSH
99287: LD_EXP 166
99291: PUSH
99292: LD_VAR 0 2
99296: ARRAY
99297: PUSH
99298: LD_INT 1
99300: ARRAY
99301: PUSH
99302: LD_INT 2
99304: ARRAY
99305: PPUSH
99306: LD_EXP 166
99310: PUSH
99311: LD_VAR 0 2
99315: ARRAY
99316: PUSH
99317: LD_INT 1
99319: ARRAY
99320: PUSH
99321: LD_INT 3
99323: ARRAY
99324: PPUSH
99325: LD_EXP 166
99329: PUSH
99330: LD_VAR 0 2
99334: ARRAY
99335: PUSH
99336: LD_INT 1
99338: ARRAY
99339: PUSH
99340: LD_INT 4
99342: ARRAY
99343: PPUSH
99344: CALL 32458 0 5
99348: OR
99349: IFFALSE 99630
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
99351: LD_ADDR_VAR 0 5
99355: PUSH
99356: LD_EXP 161
99360: PUSH
99361: LD_VAR 0 2
99365: ARRAY
99366: PPUSH
99367: LD_INT 25
99369: PUSH
99370: LD_INT 2
99372: PUSH
99373: EMPTY
99374: LIST
99375: LIST
99376: PPUSH
99377: CALL_OW 72
99381: PUSH
99382: LD_EXP 163
99386: PUSH
99387: LD_VAR 0 2
99391: ARRAY
99392: DIFF
99393: ST_TO_ADDR
// if not tmp then
99394: LD_VAR 0 5
99398: NOT
99399: IFFALSE 99403
// continue ;
99401: GO 99231
// for j in tmp do
99403: LD_ADDR_VAR 0 3
99407: PUSH
99408: LD_VAR 0 5
99412: PUSH
99413: FOR_IN
99414: IFFALSE 99626
// begin if not mc_builders [ i ] then
99416: LD_EXP 167
99420: PUSH
99421: LD_VAR 0 2
99425: ARRAY
99426: NOT
99427: IFFALSE 99485
// begin SetTag ( j , 103 ) ;
99429: LD_VAR 0 3
99433: PPUSH
99434: LD_INT 103
99436: PPUSH
99437: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
99441: LD_ADDR_EXP 167
99445: PUSH
99446: LD_EXP 167
99450: PPUSH
99451: LD_VAR 0 2
99455: PUSH
99456: LD_EXP 167
99460: PUSH
99461: LD_VAR 0 2
99465: ARRAY
99466: PUSH
99467: LD_INT 1
99469: PLUS
99470: PUSH
99471: EMPTY
99472: LIST
99473: LIST
99474: PPUSH
99475: LD_VAR 0 3
99479: PPUSH
99480: CALL 24361 0 3
99484: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
99485: LD_VAR 0 3
99489: PPUSH
99490: CALL_OW 310
99494: IFFALSE 99505
// ComExitBuilding ( j ) ;
99496: LD_VAR 0 3
99500: PPUSH
99501: CALL_OW 122
// wait ( 3 ) ;
99505: LD_INT 3
99507: PPUSH
99508: CALL_OW 67
// if not mc_build_list [ i ] then
99512: LD_EXP 166
99516: PUSH
99517: LD_VAR 0 2
99521: ARRAY
99522: NOT
99523: IFFALSE 99527
// break ;
99525: GO 99626
// if not HasTask ( j ) then
99527: LD_VAR 0 3
99531: PPUSH
99532: CALL_OW 314
99536: NOT
99537: IFFALSE 99624
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
99539: LD_VAR 0 3
99543: PPUSH
99544: LD_EXP 166
99548: PUSH
99549: LD_VAR 0 2
99553: ARRAY
99554: PUSH
99555: LD_INT 1
99557: ARRAY
99558: PUSH
99559: LD_INT 1
99561: ARRAY
99562: PPUSH
99563: LD_EXP 166
99567: PUSH
99568: LD_VAR 0 2
99572: ARRAY
99573: PUSH
99574: LD_INT 1
99576: ARRAY
99577: PUSH
99578: LD_INT 2
99580: ARRAY
99581: PPUSH
99582: LD_EXP 166
99586: PUSH
99587: LD_VAR 0 2
99591: ARRAY
99592: PUSH
99593: LD_INT 1
99595: ARRAY
99596: PUSH
99597: LD_INT 3
99599: ARRAY
99600: PPUSH
99601: LD_EXP 166
99605: PUSH
99606: LD_VAR 0 2
99610: ARRAY
99611: PUSH
99612: LD_INT 1
99614: ARRAY
99615: PUSH
99616: LD_INT 4
99618: ARRAY
99619: PPUSH
99620: CALL_OW 145
// end ;
99624: GO 99413
99626: POP
99627: POP
// end else
99628: GO 99800
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
99630: LD_EXP 161
99634: PUSH
99635: LD_VAR 0 2
99639: ARRAY
99640: PPUSH
99641: LD_EXP 166
99645: PUSH
99646: LD_VAR 0 2
99650: ARRAY
99651: PUSH
99652: LD_INT 1
99654: ARRAY
99655: PUSH
99656: LD_INT 1
99658: ARRAY
99659: PPUSH
99660: LD_EXP 166
99664: PUSH
99665: LD_VAR 0 2
99669: ARRAY
99670: PUSH
99671: LD_INT 1
99673: ARRAY
99674: PUSH
99675: LD_INT 2
99677: ARRAY
99678: PPUSH
99679: LD_EXP 166
99683: PUSH
99684: LD_VAR 0 2
99688: ARRAY
99689: PUSH
99690: LD_INT 1
99692: ARRAY
99693: PUSH
99694: LD_INT 3
99696: ARRAY
99697: PPUSH
99698: LD_EXP 166
99702: PUSH
99703: LD_VAR 0 2
99707: ARRAY
99708: PUSH
99709: LD_INT 1
99711: ARRAY
99712: PUSH
99713: LD_INT 4
99715: ARRAY
99716: PPUSH
99717: LD_EXP 161
99721: PUSH
99722: LD_VAR 0 2
99726: ARRAY
99727: PPUSH
99728: LD_INT 21
99730: PUSH
99731: LD_INT 3
99733: PUSH
99734: EMPTY
99735: LIST
99736: LIST
99737: PPUSH
99738: CALL_OW 72
99742: PPUSH
99743: EMPTY
99744: PPUSH
99745: CALL 31212 0 7
99749: NOT
99750: IFFALSE 99800
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
99752: LD_ADDR_EXP 166
99756: PUSH
99757: LD_EXP 166
99761: PPUSH
99762: LD_VAR 0 2
99766: PPUSH
99767: LD_EXP 166
99771: PUSH
99772: LD_VAR 0 2
99776: ARRAY
99777: PPUSH
99778: LD_INT 1
99780: PPUSH
99781: LD_INT 1
99783: NEG
99784: PPUSH
99785: LD_INT 0
99787: PPUSH
99788: CALL 23779 0 4
99792: PPUSH
99793: CALL_OW 1
99797: ST_TO_ADDR
// continue ;
99798: GO 99231
// end ; end ;
99800: GO 99231
99802: POP
99803: POP
// end ; end ;
99804: GO 98660
99806: POP
99807: POP
// end ;
99808: LD_VAR 0 1
99812: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
99813: LD_INT 0
99815: PPUSH
99816: PPUSH
99817: PPUSH
99818: PPUSH
99819: PPUSH
99820: PPUSH
// if not mc_bases then
99821: LD_EXP 161
99825: NOT
99826: IFFALSE 99830
// exit ;
99828: GO 100257
// for i = 1 to mc_bases do
99830: LD_ADDR_VAR 0 2
99834: PUSH
99835: DOUBLE
99836: LD_INT 1
99838: DEC
99839: ST_TO_ADDR
99840: LD_EXP 161
99844: PUSH
99845: FOR_TO
99846: IFFALSE 100255
// begin tmp := mc_build_upgrade [ i ] ;
99848: LD_ADDR_VAR 0 4
99852: PUSH
99853: LD_EXP 193
99857: PUSH
99858: LD_VAR 0 2
99862: ARRAY
99863: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
99864: LD_ADDR_VAR 0 6
99868: PUSH
99869: LD_EXP 194
99873: PUSH
99874: LD_VAR 0 2
99878: ARRAY
99879: PPUSH
99880: LD_INT 2
99882: PUSH
99883: LD_INT 30
99885: PUSH
99886: LD_INT 6
99888: PUSH
99889: EMPTY
99890: LIST
99891: LIST
99892: PUSH
99893: LD_INT 30
99895: PUSH
99896: LD_INT 7
99898: PUSH
99899: EMPTY
99900: LIST
99901: LIST
99902: PUSH
99903: EMPTY
99904: LIST
99905: LIST
99906: LIST
99907: PPUSH
99908: CALL_OW 72
99912: ST_TO_ADDR
// if not tmp and not lab then
99913: LD_VAR 0 4
99917: NOT
99918: PUSH
99919: LD_VAR 0 6
99923: NOT
99924: AND
99925: IFFALSE 99929
// continue ;
99927: GO 99845
// if tmp then
99929: LD_VAR 0 4
99933: IFFALSE 100053
// for j in tmp do
99935: LD_ADDR_VAR 0 3
99939: PUSH
99940: LD_VAR 0 4
99944: PUSH
99945: FOR_IN
99946: IFFALSE 100051
// begin if UpgradeCost ( j ) then
99948: LD_VAR 0 3
99952: PPUSH
99953: CALL 30872 0 1
99957: IFFALSE 100049
// begin ComUpgrade ( j ) ;
99959: LD_VAR 0 3
99963: PPUSH
99964: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
99968: LD_ADDR_EXP 193
99972: PUSH
99973: LD_EXP 193
99977: PPUSH
99978: LD_VAR 0 2
99982: PPUSH
99983: LD_EXP 193
99987: PUSH
99988: LD_VAR 0 2
99992: ARRAY
99993: PUSH
99994: LD_VAR 0 3
99998: DIFF
99999: PPUSH
100000: CALL_OW 1
100004: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
100005: LD_ADDR_EXP 168
100009: PUSH
100010: LD_EXP 168
100014: PPUSH
100015: LD_VAR 0 2
100019: PUSH
100020: LD_EXP 168
100024: PUSH
100025: LD_VAR 0 2
100029: ARRAY
100030: PUSH
100031: LD_INT 1
100033: PLUS
100034: PUSH
100035: EMPTY
100036: LIST
100037: LIST
100038: PPUSH
100039: LD_VAR 0 3
100043: PPUSH
100044: CALL 24361 0 3
100048: ST_TO_ADDR
// end ; end ;
100049: GO 99945
100051: POP
100052: POP
// if not lab or not mc_lab_upgrade [ i ] then
100053: LD_VAR 0 6
100057: NOT
100058: PUSH
100059: LD_EXP 195
100063: PUSH
100064: LD_VAR 0 2
100068: ARRAY
100069: NOT
100070: OR
100071: IFFALSE 100075
// continue ;
100073: GO 99845
// for j in lab do
100075: LD_ADDR_VAR 0 3
100079: PUSH
100080: LD_VAR 0 6
100084: PUSH
100085: FOR_IN
100086: IFFALSE 100251
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
100088: LD_VAR 0 3
100092: PPUSH
100093: CALL_OW 266
100097: PUSH
100098: LD_INT 6
100100: PUSH
100101: LD_INT 7
100103: PUSH
100104: EMPTY
100105: LIST
100106: LIST
100107: IN
100108: PUSH
100109: LD_VAR 0 3
100113: PPUSH
100114: CALL_OW 461
100118: PUSH
100119: LD_INT 1
100121: NONEQUAL
100122: AND
100123: IFFALSE 100249
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
100125: LD_VAR 0 3
100129: PPUSH
100130: LD_EXP 195
100134: PUSH
100135: LD_VAR 0 2
100139: ARRAY
100140: PUSH
100141: LD_INT 1
100143: ARRAY
100144: PPUSH
100145: CALL 31077 0 2
100149: IFFALSE 100249
// begin ComCancel ( j ) ;
100151: LD_VAR 0 3
100155: PPUSH
100156: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
100160: LD_VAR 0 3
100164: PPUSH
100165: LD_EXP 195
100169: PUSH
100170: LD_VAR 0 2
100174: ARRAY
100175: PUSH
100176: LD_INT 1
100178: ARRAY
100179: PPUSH
100180: CALL_OW 207
// if not j in mc_construct_list [ i ] then
100184: LD_VAR 0 3
100188: PUSH
100189: LD_EXP 168
100193: PUSH
100194: LD_VAR 0 2
100198: ARRAY
100199: IN
100200: NOT
100201: IFFALSE 100247
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
100203: LD_ADDR_EXP 168
100207: PUSH
100208: LD_EXP 168
100212: PPUSH
100213: LD_VAR 0 2
100217: PUSH
100218: LD_EXP 168
100222: PUSH
100223: LD_VAR 0 2
100227: ARRAY
100228: PUSH
100229: LD_INT 1
100231: PLUS
100232: PUSH
100233: EMPTY
100234: LIST
100235: LIST
100236: PPUSH
100237: LD_VAR 0 3
100241: PPUSH
100242: CALL 24361 0 3
100246: ST_TO_ADDR
// break ;
100247: GO 100251
// end ; end ; end ;
100249: GO 100085
100251: POP
100252: POP
// end ;
100253: GO 99845
100255: POP
100256: POP
// end ;
100257: LD_VAR 0 1
100261: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
100262: LD_INT 0
100264: PPUSH
100265: PPUSH
100266: PPUSH
100267: PPUSH
100268: PPUSH
100269: PPUSH
100270: PPUSH
100271: PPUSH
100272: PPUSH
// if not mc_bases then
100273: LD_EXP 161
100277: NOT
100278: IFFALSE 100282
// exit ;
100280: GO 100687
// for i = 1 to mc_bases do
100282: LD_ADDR_VAR 0 2
100286: PUSH
100287: DOUBLE
100288: LD_INT 1
100290: DEC
100291: ST_TO_ADDR
100292: LD_EXP 161
100296: PUSH
100297: FOR_TO
100298: IFFALSE 100685
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
100300: LD_EXP 169
100304: PUSH
100305: LD_VAR 0 2
100309: ARRAY
100310: NOT
100311: PUSH
100312: LD_EXP 161
100316: PUSH
100317: LD_VAR 0 2
100321: ARRAY
100322: PPUSH
100323: LD_INT 30
100325: PUSH
100326: LD_INT 3
100328: PUSH
100329: EMPTY
100330: LIST
100331: LIST
100332: PPUSH
100333: CALL_OW 72
100337: NOT
100338: OR
100339: IFFALSE 100343
// continue ;
100341: GO 100297
// busy := false ;
100343: LD_ADDR_VAR 0 8
100347: PUSH
100348: LD_INT 0
100350: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
100351: LD_ADDR_VAR 0 4
100355: PUSH
100356: LD_EXP 161
100360: PUSH
100361: LD_VAR 0 2
100365: ARRAY
100366: PPUSH
100367: LD_INT 30
100369: PUSH
100370: LD_INT 3
100372: PUSH
100373: EMPTY
100374: LIST
100375: LIST
100376: PPUSH
100377: CALL_OW 72
100381: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
100382: LD_ADDR_VAR 0 6
100386: PUSH
100387: LD_EXP 169
100391: PUSH
100392: LD_VAR 0 2
100396: ARRAY
100397: PPUSH
100398: LD_INT 2
100400: PUSH
100401: LD_INT 30
100403: PUSH
100404: LD_INT 32
100406: PUSH
100407: EMPTY
100408: LIST
100409: LIST
100410: PUSH
100411: LD_INT 30
100413: PUSH
100414: LD_INT 33
100416: PUSH
100417: EMPTY
100418: LIST
100419: LIST
100420: PUSH
100421: EMPTY
100422: LIST
100423: LIST
100424: LIST
100425: PPUSH
100426: CALL_OW 72
100430: ST_TO_ADDR
// if not t then
100431: LD_VAR 0 6
100435: NOT
100436: IFFALSE 100440
// continue ;
100438: GO 100297
// for j in tmp do
100440: LD_ADDR_VAR 0 3
100444: PUSH
100445: LD_VAR 0 4
100449: PUSH
100450: FOR_IN
100451: IFFALSE 100481
// if not BuildingStatus ( j ) = bs_idle then
100453: LD_VAR 0 3
100457: PPUSH
100458: CALL_OW 461
100462: PUSH
100463: LD_INT 2
100465: EQUAL
100466: NOT
100467: IFFALSE 100479
// begin busy := true ;
100469: LD_ADDR_VAR 0 8
100473: PUSH
100474: LD_INT 1
100476: ST_TO_ADDR
// break ;
100477: GO 100481
// end ;
100479: GO 100450
100481: POP
100482: POP
// if busy then
100483: LD_VAR 0 8
100487: IFFALSE 100491
// continue ;
100489: GO 100297
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
100491: LD_ADDR_VAR 0 7
100495: PUSH
100496: LD_VAR 0 6
100500: PPUSH
100501: LD_INT 35
100503: PUSH
100504: LD_INT 0
100506: PUSH
100507: EMPTY
100508: LIST
100509: LIST
100510: PPUSH
100511: CALL_OW 72
100515: ST_TO_ADDR
// if tw then
100516: LD_VAR 0 7
100520: IFFALSE 100597
// begin tw := tw [ 1 ] ;
100522: LD_ADDR_VAR 0 7
100526: PUSH
100527: LD_VAR 0 7
100531: PUSH
100532: LD_INT 1
100534: ARRAY
100535: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
100536: LD_ADDR_VAR 0 9
100540: PUSH
100541: LD_VAR 0 7
100545: PPUSH
100546: LD_EXP 186
100550: PUSH
100551: LD_VAR 0 2
100555: ARRAY
100556: PPUSH
100557: CALL 29369 0 2
100561: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
100562: LD_EXP 200
100566: PUSH
100567: LD_VAR 0 2
100571: ARRAY
100572: IFFALSE 100595
// if not weapon in mc_allowed_tower_weapons [ i ] then
100574: LD_VAR 0 9
100578: PUSH
100579: LD_EXP 200
100583: PUSH
100584: LD_VAR 0 2
100588: ARRAY
100589: IN
100590: NOT
100591: IFFALSE 100595
// continue ;
100593: GO 100297
// end else
100595: GO 100660
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
100597: LD_ADDR_VAR 0 5
100601: PUSH
100602: LD_EXP 169
100606: PUSH
100607: LD_VAR 0 2
100611: ARRAY
100612: PPUSH
100613: LD_VAR 0 4
100617: PPUSH
100618: CALL 56240 0 2
100622: ST_TO_ADDR
// if not tmp2 then
100623: LD_VAR 0 5
100627: NOT
100628: IFFALSE 100632
// continue ;
100630: GO 100297
// tw := tmp2 [ 1 ] ;
100632: LD_ADDR_VAR 0 7
100636: PUSH
100637: LD_VAR 0 5
100641: PUSH
100642: LD_INT 1
100644: ARRAY
100645: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
100646: LD_ADDR_VAR 0 9
100650: PUSH
100651: LD_VAR 0 5
100655: PUSH
100656: LD_INT 2
100658: ARRAY
100659: ST_TO_ADDR
// end ; if not weapon then
100660: LD_VAR 0 9
100664: NOT
100665: IFFALSE 100669
// continue ;
100667: GO 100297
// ComPlaceWeapon ( tw , weapon ) ;
100669: LD_VAR 0 7
100673: PPUSH
100674: LD_VAR 0 9
100678: PPUSH
100679: CALL_OW 148
// end ;
100683: GO 100297
100685: POP
100686: POP
// end ;
100687: LD_VAR 0 1
100691: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
100692: LD_INT 0
100694: PPUSH
100695: PPUSH
100696: PPUSH
100697: PPUSH
100698: PPUSH
100699: PPUSH
100700: PPUSH
// if not mc_bases then
100701: LD_EXP 161
100705: NOT
100706: IFFALSE 100710
// exit ;
100708: GO 101478
// for i = 1 to mc_bases do
100710: LD_ADDR_VAR 0 2
100714: PUSH
100715: DOUBLE
100716: LD_INT 1
100718: DEC
100719: ST_TO_ADDR
100720: LD_EXP 161
100724: PUSH
100725: FOR_TO
100726: IFFALSE 101476
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
100728: LD_EXP 174
100732: PUSH
100733: LD_VAR 0 2
100737: ARRAY
100738: NOT
100739: PUSH
100740: LD_EXP 174
100744: PUSH
100745: LD_VAR 0 2
100749: ARRAY
100750: PUSH
100751: LD_EXP 175
100755: PUSH
100756: LD_VAR 0 2
100760: ARRAY
100761: EQUAL
100762: OR
100763: PUSH
100764: LD_EXP 184
100768: PUSH
100769: LD_VAR 0 2
100773: ARRAY
100774: OR
100775: IFFALSE 100779
// continue ;
100777: GO 100725
// if mc_miners [ i ] then
100779: LD_EXP 175
100783: PUSH
100784: LD_VAR 0 2
100788: ARRAY
100789: IFFALSE 101163
// begin for j = mc_miners [ i ] downto 1 do
100791: LD_ADDR_VAR 0 3
100795: PUSH
100796: DOUBLE
100797: LD_EXP 175
100801: PUSH
100802: LD_VAR 0 2
100806: ARRAY
100807: INC
100808: ST_TO_ADDR
100809: LD_INT 1
100811: PUSH
100812: FOR_DOWNTO
100813: IFFALSE 101161
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
100815: LD_EXP 175
100819: PUSH
100820: LD_VAR 0 2
100824: ARRAY
100825: PUSH
100826: LD_VAR 0 3
100830: ARRAY
100831: PPUSH
100832: CALL_OW 301
100836: PUSH
100837: LD_EXP 175
100841: PUSH
100842: LD_VAR 0 2
100846: ARRAY
100847: PUSH
100848: LD_VAR 0 3
100852: ARRAY
100853: PPUSH
100854: CALL_OW 257
100858: PUSH
100859: LD_INT 1
100861: NONEQUAL
100862: OR
100863: IFFALSE 100926
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
100865: LD_ADDR_VAR 0 5
100869: PUSH
100870: LD_EXP 175
100874: PUSH
100875: LD_VAR 0 2
100879: ARRAY
100880: PUSH
100881: LD_EXP 175
100885: PUSH
100886: LD_VAR 0 2
100890: ARRAY
100891: PUSH
100892: LD_VAR 0 3
100896: ARRAY
100897: DIFF
100898: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
100899: LD_ADDR_EXP 175
100903: PUSH
100904: LD_EXP 175
100908: PPUSH
100909: LD_VAR 0 2
100913: PPUSH
100914: LD_VAR 0 5
100918: PPUSH
100919: CALL_OW 1
100923: ST_TO_ADDR
// continue ;
100924: GO 100812
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
100926: LD_EXP 175
100930: PUSH
100931: LD_VAR 0 2
100935: ARRAY
100936: PUSH
100937: LD_VAR 0 3
100941: ARRAY
100942: PPUSH
100943: CALL_OW 257
100947: PUSH
100948: LD_INT 1
100950: EQUAL
100951: PUSH
100952: LD_EXP 175
100956: PUSH
100957: LD_VAR 0 2
100961: ARRAY
100962: PUSH
100963: LD_VAR 0 3
100967: ARRAY
100968: PPUSH
100969: CALL_OW 459
100973: NOT
100974: AND
100975: PUSH
100976: LD_EXP 175
100980: PUSH
100981: LD_VAR 0 2
100985: ARRAY
100986: PUSH
100987: LD_VAR 0 3
100991: ARRAY
100992: PPUSH
100993: CALL_OW 314
100997: NOT
100998: AND
100999: IFFALSE 101159
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
101001: LD_EXP 175
101005: PUSH
101006: LD_VAR 0 2
101010: ARRAY
101011: PUSH
101012: LD_VAR 0 3
101016: ARRAY
101017: PPUSH
101018: CALL_OW 310
101022: IFFALSE 101045
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
101024: LD_EXP 175
101028: PUSH
101029: LD_VAR 0 2
101033: ARRAY
101034: PUSH
101035: LD_VAR 0 3
101039: ARRAY
101040: PPUSH
101041: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
101045: LD_EXP 175
101049: PUSH
101050: LD_VAR 0 2
101054: ARRAY
101055: PUSH
101056: LD_VAR 0 3
101060: ARRAY
101061: PPUSH
101062: CALL_OW 314
101066: NOT
101067: IFFALSE 101159
// begin r := rand ( 1 , mc_mines [ i ] ) ;
101069: LD_ADDR_VAR 0 7
101073: PUSH
101074: LD_INT 1
101076: PPUSH
101077: LD_EXP 174
101081: PUSH
101082: LD_VAR 0 2
101086: ARRAY
101087: PPUSH
101088: CALL_OW 12
101092: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
101093: LD_EXP 175
101097: PUSH
101098: LD_VAR 0 2
101102: ARRAY
101103: PUSH
101104: LD_VAR 0 3
101108: ARRAY
101109: PPUSH
101110: LD_EXP 174
101114: PUSH
101115: LD_VAR 0 2
101119: ARRAY
101120: PUSH
101121: LD_VAR 0 7
101125: ARRAY
101126: PUSH
101127: LD_INT 1
101129: ARRAY
101130: PPUSH
101131: LD_EXP 174
101135: PUSH
101136: LD_VAR 0 2
101140: ARRAY
101141: PUSH
101142: LD_VAR 0 7
101146: ARRAY
101147: PUSH
101148: LD_INT 2
101150: ARRAY
101151: PPUSH
101152: LD_INT 0
101154: PPUSH
101155: CALL_OW 193
// end ; end ; end ;
101159: GO 100812
101161: POP
101162: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
101163: LD_ADDR_VAR 0 5
101167: PUSH
101168: LD_EXP 161
101172: PUSH
101173: LD_VAR 0 2
101177: ARRAY
101178: PPUSH
101179: LD_INT 2
101181: PUSH
101182: LD_INT 30
101184: PUSH
101185: LD_INT 4
101187: PUSH
101188: EMPTY
101189: LIST
101190: LIST
101191: PUSH
101192: LD_INT 30
101194: PUSH
101195: LD_INT 5
101197: PUSH
101198: EMPTY
101199: LIST
101200: LIST
101201: PUSH
101202: LD_INT 30
101204: PUSH
101205: LD_INT 32
101207: PUSH
101208: EMPTY
101209: LIST
101210: LIST
101211: PUSH
101212: EMPTY
101213: LIST
101214: LIST
101215: LIST
101216: LIST
101217: PPUSH
101218: CALL_OW 72
101222: ST_TO_ADDR
// if not tmp then
101223: LD_VAR 0 5
101227: NOT
101228: IFFALSE 101232
// continue ;
101230: GO 100725
// list := [ ] ;
101232: LD_ADDR_VAR 0 6
101236: PUSH
101237: EMPTY
101238: ST_TO_ADDR
// for j in tmp do
101239: LD_ADDR_VAR 0 3
101243: PUSH
101244: LD_VAR 0 5
101248: PUSH
101249: FOR_IN
101250: IFFALSE 101319
// begin for k in UnitsInside ( j ) do
101252: LD_ADDR_VAR 0 4
101256: PUSH
101257: LD_VAR 0 3
101261: PPUSH
101262: CALL_OW 313
101266: PUSH
101267: FOR_IN
101268: IFFALSE 101315
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
101270: LD_VAR 0 4
101274: PPUSH
101275: CALL_OW 257
101279: PUSH
101280: LD_INT 1
101282: EQUAL
101283: PUSH
101284: LD_VAR 0 4
101288: PPUSH
101289: CALL_OW 459
101293: NOT
101294: AND
101295: IFFALSE 101313
// list := list ^ k ;
101297: LD_ADDR_VAR 0 6
101301: PUSH
101302: LD_VAR 0 6
101306: PUSH
101307: LD_VAR 0 4
101311: ADD
101312: ST_TO_ADDR
101313: GO 101267
101315: POP
101316: POP
// end ;
101317: GO 101249
101319: POP
101320: POP
// list := list diff mc_miners [ i ] ;
101321: LD_ADDR_VAR 0 6
101325: PUSH
101326: LD_VAR 0 6
101330: PUSH
101331: LD_EXP 175
101335: PUSH
101336: LD_VAR 0 2
101340: ARRAY
101341: DIFF
101342: ST_TO_ADDR
// if not list then
101343: LD_VAR 0 6
101347: NOT
101348: IFFALSE 101352
// continue ;
101350: GO 100725
// k := mc_mines [ i ] - mc_miners [ i ] ;
101352: LD_ADDR_VAR 0 4
101356: PUSH
101357: LD_EXP 174
101361: PUSH
101362: LD_VAR 0 2
101366: ARRAY
101367: PUSH
101368: LD_EXP 175
101372: PUSH
101373: LD_VAR 0 2
101377: ARRAY
101378: MINUS
101379: ST_TO_ADDR
// if k > list then
101380: LD_VAR 0 4
101384: PUSH
101385: LD_VAR 0 6
101389: GREATER
101390: IFFALSE 101402
// k := list ;
101392: LD_ADDR_VAR 0 4
101396: PUSH
101397: LD_VAR 0 6
101401: ST_TO_ADDR
// for j = 1 to k do
101402: LD_ADDR_VAR 0 3
101406: PUSH
101407: DOUBLE
101408: LD_INT 1
101410: DEC
101411: ST_TO_ADDR
101412: LD_VAR 0 4
101416: PUSH
101417: FOR_TO
101418: IFFALSE 101472
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
101420: LD_ADDR_EXP 175
101424: PUSH
101425: LD_EXP 175
101429: PPUSH
101430: LD_VAR 0 2
101434: PUSH
101435: LD_EXP 175
101439: PUSH
101440: LD_VAR 0 2
101444: ARRAY
101445: PUSH
101446: LD_INT 1
101448: PLUS
101449: PUSH
101450: EMPTY
101451: LIST
101452: LIST
101453: PPUSH
101454: LD_VAR 0 6
101458: PUSH
101459: LD_VAR 0 3
101463: ARRAY
101464: PPUSH
101465: CALL 24361 0 3
101469: ST_TO_ADDR
101470: GO 101417
101472: POP
101473: POP
// end ;
101474: GO 100725
101476: POP
101477: POP
// end ;
101478: LD_VAR 0 1
101482: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , side , target , cargo , depot , fac , components ; begin
101483: LD_INT 0
101485: PPUSH
101486: PPUSH
101487: PPUSH
101488: PPUSH
101489: PPUSH
101490: PPUSH
101491: PPUSH
101492: PPUSH
101493: PPUSH
101494: PPUSH
101495: PPUSH
// if not mc_bases then
101496: LD_EXP 161
101500: NOT
101501: IFFALSE 101505
// exit ;
101503: GO 103328
// for i = 1 to mc_bases do
101505: LD_ADDR_VAR 0 2
101509: PUSH
101510: DOUBLE
101511: LD_INT 1
101513: DEC
101514: ST_TO_ADDR
101515: LD_EXP 161
101519: PUSH
101520: FOR_TO
101521: IFFALSE 103326
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
101523: LD_EXP 161
101527: PUSH
101528: LD_VAR 0 2
101532: ARRAY
101533: NOT
101534: PUSH
101535: LD_EXP 168
101539: PUSH
101540: LD_VAR 0 2
101544: ARRAY
101545: OR
101546: IFFALSE 101550
// continue ;
101548: GO 101520
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
101550: LD_EXP 177
101554: PUSH
101555: LD_VAR 0 2
101559: ARRAY
101560: NOT
101561: PUSH
101562: LD_EXP 178
101566: PUSH
101567: LD_VAR 0 2
101571: ARRAY
101572: AND
101573: IFFALSE 101611
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
101575: LD_ADDR_EXP 178
101579: PUSH
101580: LD_EXP 178
101584: PPUSH
101585: LD_VAR 0 2
101589: PPUSH
101590: EMPTY
101591: PPUSH
101592: CALL_OW 1
101596: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
101597: LD_VAR 0 2
101601: PPUSH
101602: LD_INT 107
101604: PPUSH
101605: CALL 92358 0 2
// continue ;
101609: GO 101520
// end ; target := [ ] ;
101611: LD_ADDR_VAR 0 7
101615: PUSH
101616: EMPTY
101617: ST_TO_ADDR
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
101618: LD_ADDR_VAR 0 6
101622: PUSH
101623: LD_EXP 161
101627: PUSH
101628: LD_VAR 0 2
101632: ARRAY
101633: PUSH
101634: LD_INT 1
101636: ARRAY
101637: PPUSH
101638: CALL_OW 255
101642: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
101643: LD_ADDR_VAR 0 9
101647: PUSH
101648: LD_EXP 161
101652: PUSH
101653: LD_VAR 0 2
101657: ARRAY
101658: PPUSH
101659: LD_INT 2
101661: PUSH
101662: LD_INT 30
101664: PUSH
101665: LD_INT 0
101667: PUSH
101668: EMPTY
101669: LIST
101670: LIST
101671: PUSH
101672: LD_INT 30
101674: PUSH
101675: LD_INT 1
101677: PUSH
101678: EMPTY
101679: LIST
101680: LIST
101681: PUSH
101682: EMPTY
101683: LIST
101684: LIST
101685: LIST
101686: PPUSH
101687: CALL_OW 72
101691: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
101692: LD_ADDR_VAR 0 3
101696: PUSH
101697: DOUBLE
101698: LD_EXP 177
101702: PUSH
101703: LD_VAR 0 2
101707: ARRAY
101708: INC
101709: ST_TO_ADDR
101710: LD_INT 1
101712: PUSH
101713: FOR_DOWNTO
101714: IFFALSE 101959
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
101716: LD_EXP 177
101720: PUSH
101721: LD_VAR 0 2
101725: ARRAY
101726: PUSH
101727: LD_VAR 0 3
101731: ARRAY
101732: PUSH
101733: LD_INT 2
101735: ARRAY
101736: PPUSH
101737: LD_EXP 177
101741: PUSH
101742: LD_VAR 0 2
101746: ARRAY
101747: PUSH
101748: LD_VAR 0 3
101752: ARRAY
101753: PUSH
101754: LD_INT 3
101756: ARRAY
101757: PPUSH
101758: CALL_OW 488
101762: PUSH
101763: LD_EXP 177
101767: PUSH
101768: LD_VAR 0 2
101772: ARRAY
101773: PUSH
101774: LD_VAR 0 3
101778: ARRAY
101779: PUSH
101780: LD_INT 2
101782: ARRAY
101783: PPUSH
101784: LD_EXP 177
101788: PUSH
101789: LD_VAR 0 2
101793: ARRAY
101794: PUSH
101795: LD_VAR 0 3
101799: ARRAY
101800: PUSH
101801: LD_INT 3
101803: ARRAY
101804: PPUSH
101805: CALL_OW 284
101809: PUSH
101810: LD_INT 0
101812: EQUAL
101813: AND
101814: IFFALSE 101869
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
101816: LD_ADDR_VAR 0 5
101820: PUSH
101821: LD_EXP 177
101825: PUSH
101826: LD_VAR 0 2
101830: ARRAY
101831: PPUSH
101832: LD_VAR 0 3
101836: PPUSH
101837: CALL_OW 3
101841: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
101842: LD_ADDR_EXP 177
101846: PUSH
101847: LD_EXP 177
101851: PPUSH
101852: LD_VAR 0 2
101856: PPUSH
101857: LD_VAR 0 5
101861: PPUSH
101862: CALL_OW 1
101866: ST_TO_ADDR
// continue ;
101867: GO 101713
// end ; if DangerAtRangeXY ( side , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
101869: LD_VAR 0 6
101873: PPUSH
101874: LD_EXP 177
101878: PUSH
101879: LD_VAR 0 2
101883: ARRAY
101884: PUSH
101885: LD_VAR 0 3
101889: ARRAY
101890: PUSH
101891: LD_INT 2
101893: ARRAY
101894: PPUSH
101895: LD_EXP 177
101899: PUSH
101900: LD_VAR 0 2
101904: ARRAY
101905: PUSH
101906: LD_VAR 0 3
101910: ARRAY
101911: PUSH
101912: LD_INT 3
101914: ARRAY
101915: PPUSH
101916: LD_INT 30
101918: PPUSH
101919: CALL 25257 0 4
101923: PUSH
101924: LD_INT 4
101926: ARRAY
101927: PUSH
101928: LD_INT 0
101930: EQUAL
101931: IFFALSE 101957
// begin target := mc_crates [ i ] [ j ] ;
101933: LD_ADDR_VAR 0 7
101937: PUSH
101938: LD_EXP 177
101942: PUSH
101943: LD_VAR 0 2
101947: ARRAY
101948: PUSH
101949: LD_VAR 0 3
101953: ARRAY
101954: ST_TO_ADDR
// break ;
101955: GO 101959
// end ; end ;
101957: GO 101713
101959: POP
101960: POP
// if not target then
101961: LD_VAR 0 7
101965: NOT
101966: IFFALSE 101970
// continue ;
101968: GO 101520
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
101970: LD_ADDR_VAR 0 8
101974: PUSH
101975: LD_EXP 180
101979: PUSH
101980: LD_VAR 0 2
101984: ARRAY
101985: PPUSH
101986: LD_INT 2
101988: PUSH
101989: LD_INT 3
101991: PUSH
101992: LD_INT 58
101994: PUSH
101995: EMPTY
101996: LIST
101997: PUSH
101998: EMPTY
101999: LIST
102000: LIST
102001: PUSH
102002: LD_INT 61
102004: PUSH
102005: EMPTY
102006: LIST
102007: PUSH
102008: LD_INT 33
102010: PUSH
102011: LD_INT 5
102013: PUSH
102014: EMPTY
102015: LIST
102016: LIST
102017: PUSH
102018: LD_INT 33
102020: PUSH
102021: LD_INT 3
102023: PUSH
102024: EMPTY
102025: LIST
102026: LIST
102027: PUSH
102028: EMPTY
102029: LIST
102030: LIST
102031: LIST
102032: LIST
102033: LIST
102034: PUSH
102035: LD_INT 2
102037: PUSH
102038: LD_INT 34
102040: PUSH
102041: LD_INT 32
102043: PUSH
102044: EMPTY
102045: LIST
102046: LIST
102047: PUSH
102048: LD_INT 34
102050: PUSH
102051: LD_INT 51
102053: PUSH
102054: EMPTY
102055: LIST
102056: LIST
102057: PUSH
102058: LD_INT 34
102060: PUSH
102061: LD_INT 12
102063: PUSH
102064: EMPTY
102065: LIST
102066: LIST
102067: PUSH
102068: EMPTY
102069: LIST
102070: LIST
102071: LIST
102072: LIST
102073: PUSH
102074: EMPTY
102075: LIST
102076: LIST
102077: PPUSH
102078: CALL_OW 72
102082: ST_TO_ADDR
// if not cargo then
102083: LD_VAR 0 8
102087: NOT
102088: IFFALSE 102794
// begin if mc_crates_collector [ i ] < 5 then
102090: LD_EXP 178
102094: PUSH
102095: LD_VAR 0 2
102099: ARRAY
102100: PUSH
102101: LD_INT 5
102103: LESS
102104: IFFALSE 102470
// begin if mc_ape [ i ] then
102106: LD_EXP 190
102110: PUSH
102111: LD_VAR 0 2
102115: ARRAY
102116: IFFALSE 102163
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
102118: LD_ADDR_VAR 0 5
102122: PUSH
102123: LD_EXP 190
102127: PUSH
102128: LD_VAR 0 2
102132: ARRAY
102133: PPUSH
102134: LD_INT 25
102136: PUSH
102137: LD_INT 16
102139: PUSH
102140: EMPTY
102141: LIST
102142: LIST
102143: PUSH
102144: LD_INT 24
102146: PUSH
102147: LD_INT 750
102149: PUSH
102150: EMPTY
102151: LIST
102152: LIST
102153: PUSH
102154: EMPTY
102155: LIST
102156: LIST
102157: PPUSH
102158: CALL_OW 72
102162: ST_TO_ADDR
// if not tmp then
102163: LD_VAR 0 5
102167: NOT
102168: IFFALSE 102215
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
102170: LD_ADDR_VAR 0 5
102174: PUSH
102175: LD_EXP 161
102179: PUSH
102180: LD_VAR 0 2
102184: ARRAY
102185: PPUSH
102186: LD_INT 25
102188: PUSH
102189: LD_INT 2
102191: PUSH
102192: EMPTY
102193: LIST
102194: LIST
102195: PUSH
102196: LD_INT 24
102198: PUSH
102199: LD_INT 750
102201: PUSH
102202: EMPTY
102203: LIST
102204: LIST
102205: PUSH
102206: EMPTY
102207: LIST
102208: LIST
102209: PPUSH
102210: CALL_OW 72
102214: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
102215: LD_EXP 190
102219: PUSH
102220: LD_VAR 0 2
102224: ARRAY
102225: PUSH
102226: LD_EXP 161
102230: PUSH
102231: LD_VAR 0 2
102235: ARRAY
102236: PPUSH
102237: LD_INT 25
102239: PUSH
102240: LD_INT 2
102242: PUSH
102243: EMPTY
102244: LIST
102245: LIST
102246: PUSH
102247: LD_INT 24
102249: PUSH
102250: LD_INT 750
102252: PUSH
102253: EMPTY
102254: LIST
102255: LIST
102256: PUSH
102257: EMPTY
102258: LIST
102259: LIST
102260: PPUSH
102261: CALL_OW 72
102265: AND
102266: PUSH
102267: LD_VAR 0 5
102271: PUSH
102272: LD_INT 5
102274: LESS
102275: AND
102276: IFFALSE 102358
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
102278: LD_ADDR_VAR 0 3
102282: PUSH
102283: LD_EXP 161
102287: PUSH
102288: LD_VAR 0 2
102292: ARRAY
102293: PPUSH
102294: LD_INT 25
102296: PUSH
102297: LD_INT 2
102299: PUSH
102300: EMPTY
102301: LIST
102302: LIST
102303: PUSH
102304: LD_INT 24
102306: PUSH
102307: LD_INT 750
102309: PUSH
102310: EMPTY
102311: LIST
102312: LIST
102313: PUSH
102314: EMPTY
102315: LIST
102316: LIST
102317: PPUSH
102318: CALL_OW 72
102322: PUSH
102323: FOR_IN
102324: IFFALSE 102356
// begin tmp := tmp union j ;
102326: LD_ADDR_VAR 0 5
102330: PUSH
102331: LD_VAR 0 5
102335: PUSH
102336: LD_VAR 0 3
102340: UNION
102341: ST_TO_ADDR
// if tmp >= 5 then
102342: LD_VAR 0 5
102346: PUSH
102347: LD_INT 5
102349: GREATEREQUAL
102350: IFFALSE 102354
// break ;
102352: GO 102356
// end ;
102354: GO 102323
102356: POP
102357: POP
// end ; if not tmp then
102358: LD_VAR 0 5
102362: NOT
102363: IFFALSE 102367
// continue ;
102365: GO 101520
// for j in tmp do
102367: LD_ADDR_VAR 0 3
102371: PUSH
102372: LD_VAR 0 5
102376: PUSH
102377: FOR_IN
102378: IFFALSE 102468
// if not GetTag ( j ) then
102380: LD_VAR 0 3
102384: PPUSH
102385: CALL_OW 110
102389: NOT
102390: IFFALSE 102466
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
102392: LD_ADDR_EXP 178
102396: PUSH
102397: LD_EXP 178
102401: PPUSH
102402: LD_VAR 0 2
102406: PUSH
102407: LD_EXP 178
102411: PUSH
102412: LD_VAR 0 2
102416: ARRAY
102417: PUSH
102418: LD_INT 1
102420: PLUS
102421: PUSH
102422: EMPTY
102423: LIST
102424: LIST
102425: PPUSH
102426: LD_VAR 0 3
102430: PPUSH
102431: CALL 24361 0 3
102435: ST_TO_ADDR
// SetTag ( j , 107 ) ;
102436: LD_VAR 0 3
102440: PPUSH
102441: LD_INT 107
102443: PPUSH
102444: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
102448: LD_EXP 178
102452: PUSH
102453: LD_VAR 0 2
102457: ARRAY
102458: PUSH
102459: LD_INT 5
102461: GREATEREQUAL
102462: IFFALSE 102466
// break ;
102464: GO 102468
// end ;
102466: GO 102377
102468: POP
102469: POP
// end ; if mc_crates_collector [ i ] and target then
102470: LD_EXP 178
102474: PUSH
102475: LD_VAR 0 2
102479: ARRAY
102480: PUSH
102481: LD_VAR 0 7
102485: AND
102486: IFFALSE 102792
// begin if mc_crates_collector [ i ] < target [ 1 ] then
102488: LD_EXP 178
102492: PUSH
102493: LD_VAR 0 2
102497: ARRAY
102498: PUSH
102499: LD_VAR 0 7
102503: PUSH
102504: LD_INT 1
102506: ARRAY
102507: LESS
102508: IFFALSE 102528
// tmp := mc_crates_collector [ i ] else
102510: LD_ADDR_VAR 0 5
102514: PUSH
102515: LD_EXP 178
102519: PUSH
102520: LD_VAR 0 2
102524: ARRAY
102525: ST_TO_ADDR
102526: GO 102542
// tmp := target [ 1 ] ;
102528: LD_ADDR_VAR 0 5
102532: PUSH
102533: LD_VAR 0 7
102537: PUSH
102538: LD_INT 1
102540: ARRAY
102541: ST_TO_ADDR
// k := 0 ;
102542: LD_ADDR_VAR 0 4
102546: PUSH
102547: LD_INT 0
102549: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
102550: LD_ADDR_VAR 0 3
102554: PUSH
102555: LD_EXP 178
102559: PUSH
102560: LD_VAR 0 2
102564: ARRAY
102565: PUSH
102566: FOR_IN
102567: IFFALSE 102790
// begin k := k + 1 ;
102569: LD_ADDR_VAR 0 4
102573: PUSH
102574: LD_VAR 0 4
102578: PUSH
102579: LD_INT 1
102581: PLUS
102582: ST_TO_ADDR
// if k > tmp then
102583: LD_VAR 0 4
102587: PUSH
102588: LD_VAR 0 5
102592: GREATER
102593: IFFALSE 102597
// break ;
102595: GO 102790
// if not GetClass ( j ) in [ 2 , 16 ] then
102597: LD_VAR 0 3
102601: PPUSH
102602: CALL_OW 257
102606: PUSH
102607: LD_INT 2
102609: PUSH
102610: LD_INT 16
102612: PUSH
102613: EMPTY
102614: LIST
102615: LIST
102616: IN
102617: NOT
102618: IFFALSE 102671
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
102620: LD_ADDR_EXP 178
102624: PUSH
102625: LD_EXP 178
102629: PPUSH
102630: LD_VAR 0 2
102634: PPUSH
102635: LD_EXP 178
102639: PUSH
102640: LD_VAR 0 2
102644: ARRAY
102645: PUSH
102646: LD_VAR 0 3
102650: DIFF
102651: PPUSH
102652: CALL_OW 1
102656: ST_TO_ADDR
// SetTag ( j , 0 ) ;
102657: LD_VAR 0 3
102661: PPUSH
102662: LD_INT 0
102664: PPUSH
102665: CALL_OW 109
// continue ;
102669: GO 102566
// end ; if IsInUnit ( j ) then
102671: LD_VAR 0 3
102675: PPUSH
102676: CALL_OW 310
102680: IFFALSE 102691
// ComExitBuilding ( j ) ;
102682: LD_VAR 0 3
102686: PPUSH
102687: CALL_OW 122
// wait ( 3 ) ;
102691: LD_INT 3
102693: PPUSH
102694: CALL_OW 67
// if HasTask ( j ) and DangerAtRangeXY ( side , target [ 2 ] , target [ 3 ] , 30 ) [ 4 ] then
102698: LD_VAR 0 3
102702: PPUSH
102703: CALL_OW 314
102707: PUSH
102708: LD_VAR 0 6
102712: PPUSH
102713: LD_VAR 0 7
102717: PUSH
102718: LD_INT 2
102720: ARRAY
102721: PPUSH
102722: LD_VAR 0 7
102726: PUSH
102727: LD_INT 3
102729: ARRAY
102730: PPUSH
102731: LD_INT 30
102733: PPUSH
102734: CALL 25257 0 4
102738: PUSH
102739: LD_INT 4
102741: ARRAY
102742: AND
102743: IFFALSE 102761
// ComStandNearbyBuilding ( j , depot ) else
102745: LD_VAR 0 3
102749: PPUSH
102750: LD_VAR 0 9
102754: PPUSH
102755: CALL 20788 0 2
102759: GO 102788
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
102761: LD_VAR 0 3
102765: PPUSH
102766: LD_VAR 0 7
102770: PUSH
102771: LD_INT 2
102773: ARRAY
102774: PPUSH
102775: LD_VAR 0 7
102779: PUSH
102780: LD_INT 3
102782: ARRAY
102783: PPUSH
102784: CALL_OW 117
// end ;
102788: GO 102566
102790: POP
102791: POP
// end ; end else
102792: GO 103324
// begin for j in cargo do
102794: LD_ADDR_VAR 0 3
102798: PUSH
102799: LD_VAR 0 8
102803: PUSH
102804: FOR_IN
102805: IFFALSE 103322
// begin if GetTag ( j ) <> 0 then
102807: LD_VAR 0 3
102811: PPUSH
102812: CALL_OW 110
102816: PUSH
102817: LD_INT 0
102819: NONEQUAL
102820: IFFALSE 102824
// continue ;
102822: GO 102804
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
102824: LD_VAR 0 3
102828: PPUSH
102829: CALL_OW 256
102833: PUSH
102834: LD_INT 1000
102836: LESS
102837: PUSH
102838: LD_VAR 0 3
102842: PPUSH
102843: LD_EXP 185
102847: PUSH
102848: LD_VAR 0 2
102852: ARRAY
102853: PPUSH
102854: CALL_OW 308
102858: NOT
102859: AND
102860: IFFALSE 102882
// ComMoveToArea ( j , mc_parking [ i ] ) ;
102862: LD_VAR 0 3
102866: PPUSH
102867: LD_EXP 185
102871: PUSH
102872: LD_VAR 0 2
102876: ARRAY
102877: PPUSH
102878: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
102882: LD_VAR 0 3
102886: PPUSH
102887: CALL_OW 256
102891: PUSH
102892: LD_INT 1000
102894: LESS
102895: PUSH
102896: LD_VAR 0 3
102900: PPUSH
102901: LD_EXP 185
102905: PUSH
102906: LD_VAR 0 2
102910: ARRAY
102911: PPUSH
102912: CALL_OW 308
102916: AND
102917: IFFALSE 102921
// continue ;
102919: GO 102804
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
102921: LD_VAR 0 3
102925: PPUSH
102926: CALL_OW 262
102930: PUSH
102931: LD_INT 2
102933: EQUAL
102934: PUSH
102935: LD_VAR 0 3
102939: PPUSH
102940: CALL_OW 261
102944: PUSH
102945: LD_INT 15
102947: LESS
102948: AND
102949: IFFALSE 102953
// continue ;
102951: GO 102804
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
102953: LD_VAR 0 3
102957: PPUSH
102958: CALL_OW 262
102962: PUSH
102963: LD_INT 1
102965: EQUAL
102966: PUSH
102967: LD_VAR 0 3
102971: PPUSH
102972: CALL_OW 261
102976: PUSH
102977: LD_INT 10
102979: LESS
102980: AND
102981: IFFALSE 103261
// begin if not depot then
102983: LD_VAR 0 9
102987: NOT
102988: IFFALSE 102992
// continue ;
102990: GO 102804
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
102992: LD_VAR 0 3
102996: PPUSH
102997: LD_VAR 0 9
103001: PPUSH
103002: LD_VAR 0 3
103006: PPUSH
103007: CALL_OW 74
103011: PPUSH
103012: CALL_OW 296
103016: PUSH
103017: LD_INT 6
103019: LESS
103020: IFFALSE 103036
// SetFuel ( j , 100 ) else
103022: LD_VAR 0 3
103026: PPUSH
103027: LD_INT 100
103029: PPUSH
103030: CALL_OW 240
103034: GO 103261
// if GetFuel ( j ) = 0 then
103036: LD_VAR 0 3
103040: PPUSH
103041: CALL_OW 261
103045: PUSH
103046: LD_INT 0
103048: EQUAL
103049: IFFALSE 103261
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
103051: LD_ADDR_EXP 180
103055: PUSH
103056: LD_EXP 180
103060: PPUSH
103061: LD_VAR 0 2
103065: PPUSH
103066: LD_EXP 180
103070: PUSH
103071: LD_VAR 0 2
103075: ARRAY
103076: PUSH
103077: LD_VAR 0 3
103081: DIFF
103082: PPUSH
103083: CALL_OW 1
103087: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
103088: LD_VAR 0 3
103092: PPUSH
103093: CALL_OW 263
103097: PUSH
103098: LD_INT 1
103100: EQUAL
103101: IFFALSE 103117
// ComExitVehicle ( IsInUnit ( j ) ) ;
103103: LD_VAR 0 3
103107: PPUSH
103108: CALL_OW 310
103112: PPUSH
103113: CALL_OW 121
// if GetControl ( j ) = control_remote then
103117: LD_VAR 0 3
103121: PPUSH
103122: CALL_OW 263
103126: PUSH
103127: LD_INT 2
103129: EQUAL
103130: IFFALSE 103141
// ComUnlink ( j ) ;
103132: LD_VAR 0 3
103136: PPUSH
103137: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
103141: LD_ADDR_VAR 0 10
103145: PUSH
103146: LD_VAR 0 2
103150: PPUSH
103151: LD_INT 3
103153: PPUSH
103154: CALL 112928 0 2
103158: ST_TO_ADDR
// if fac then
103159: LD_VAR 0 10
103163: IFFALSE 103259
// begin for k in fac do
103165: LD_ADDR_VAR 0 4
103169: PUSH
103170: LD_VAR 0 10
103174: PUSH
103175: FOR_IN
103176: IFFALSE 103257
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
103178: LD_ADDR_VAR 0 11
103182: PUSH
103183: LD_VAR 0 10
103187: PPUSH
103188: LD_VAR 0 3
103192: PPUSH
103193: CALL_OW 265
103197: PPUSH
103198: LD_VAR 0 3
103202: PPUSH
103203: CALL_OW 262
103207: PPUSH
103208: LD_VAR 0 3
103212: PPUSH
103213: CALL_OW 263
103217: PPUSH
103218: LD_VAR 0 3
103222: PPUSH
103223: CALL_OW 264
103227: PPUSH
103228: CALL 21859 0 5
103232: ST_TO_ADDR
// if components then
103233: LD_VAR 0 11
103237: IFFALSE 103255
// begin MC_InsertProduceList ( i , components ) ;
103239: LD_VAR 0 2
103243: PPUSH
103244: LD_VAR 0 11
103248: PPUSH
103249: CALL 112473 0 2
// break ;
103253: GO 103257
// end ; end ;
103255: GO 103175
103257: POP
103258: POP
// end ; continue ;
103259: GO 102804
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
103261: LD_VAR 0 3
103265: PPUSH
103266: LD_INT 1
103268: PPUSH
103269: CALL_OW 289
103273: PUSH
103274: LD_INT 100
103276: LESS
103277: PUSH
103278: LD_VAR 0 3
103282: PPUSH
103283: CALL_OW 314
103287: NOT
103288: AND
103289: IFFALSE 103318
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
103291: LD_VAR 0 3
103295: PPUSH
103296: LD_VAR 0 7
103300: PUSH
103301: LD_INT 2
103303: ARRAY
103304: PPUSH
103305: LD_VAR 0 7
103309: PUSH
103310: LD_INT 3
103312: ARRAY
103313: PPUSH
103314: CALL_OW 117
// break ;
103318: GO 103322
// end ;
103320: GO 102804
103322: POP
103323: POP
// end ; end ;
103324: GO 101520
103326: POP
103327: POP
// end ;
103328: LD_VAR 0 1
103332: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
103333: LD_INT 0
103335: PPUSH
103336: PPUSH
103337: PPUSH
103338: PPUSH
// if not mc_bases then
103339: LD_EXP 161
103343: NOT
103344: IFFALSE 103348
// exit ;
103346: GO 103509
// for i = 1 to mc_bases do
103348: LD_ADDR_VAR 0 2
103352: PUSH
103353: DOUBLE
103354: LD_INT 1
103356: DEC
103357: ST_TO_ADDR
103358: LD_EXP 161
103362: PUSH
103363: FOR_TO
103364: IFFALSE 103507
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
103366: LD_ADDR_VAR 0 4
103370: PUSH
103371: LD_EXP 180
103375: PUSH
103376: LD_VAR 0 2
103380: ARRAY
103381: PUSH
103382: LD_EXP 183
103386: PUSH
103387: LD_VAR 0 2
103391: ARRAY
103392: UNION
103393: PPUSH
103394: LD_INT 33
103396: PUSH
103397: LD_INT 2
103399: PUSH
103400: EMPTY
103401: LIST
103402: LIST
103403: PPUSH
103404: CALL_OW 72
103408: ST_TO_ADDR
// if tmp then
103409: LD_VAR 0 4
103413: IFFALSE 103505
// for j in tmp do
103415: LD_ADDR_VAR 0 3
103419: PUSH
103420: LD_VAR 0 4
103424: PUSH
103425: FOR_IN
103426: IFFALSE 103503
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
103428: LD_VAR 0 3
103432: PPUSH
103433: CALL_OW 312
103437: NOT
103438: PUSH
103439: LD_VAR 0 3
103443: PPUSH
103444: CALL_OW 256
103448: PUSH
103449: LD_INT 250
103451: GREATEREQUAL
103452: AND
103453: IFFALSE 103466
// Connect ( j ) else
103455: LD_VAR 0 3
103459: PPUSH
103460: CALL 27330 0 1
103464: GO 103501
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
103466: LD_VAR 0 3
103470: PPUSH
103471: CALL_OW 256
103475: PUSH
103476: LD_INT 250
103478: LESS
103479: PUSH
103480: LD_VAR 0 3
103484: PPUSH
103485: CALL_OW 312
103489: AND
103490: IFFALSE 103501
// ComUnlink ( j ) ;
103492: LD_VAR 0 3
103496: PPUSH
103497: CALL_OW 136
103501: GO 103425
103503: POP
103504: POP
// end ;
103505: GO 103363
103507: POP
103508: POP
// end ;
103509: LD_VAR 0 1
103513: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
103514: LD_INT 0
103516: PPUSH
103517: PPUSH
103518: PPUSH
103519: PPUSH
103520: PPUSH
// if not mc_bases then
103521: LD_EXP 161
103525: NOT
103526: IFFALSE 103530
// exit ;
103528: GO 103975
// for i = 1 to mc_bases do
103530: LD_ADDR_VAR 0 2
103534: PUSH
103535: DOUBLE
103536: LD_INT 1
103538: DEC
103539: ST_TO_ADDR
103540: LD_EXP 161
103544: PUSH
103545: FOR_TO
103546: IFFALSE 103973
// begin if not mc_produce [ i ] then
103548: LD_EXP 182
103552: PUSH
103553: LD_VAR 0 2
103557: ARRAY
103558: NOT
103559: IFFALSE 103563
// continue ;
103561: GO 103545
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
103563: LD_ADDR_VAR 0 5
103567: PUSH
103568: LD_EXP 161
103572: PUSH
103573: LD_VAR 0 2
103577: ARRAY
103578: PPUSH
103579: LD_INT 30
103581: PUSH
103582: LD_INT 3
103584: PUSH
103585: EMPTY
103586: LIST
103587: LIST
103588: PPUSH
103589: CALL_OW 72
103593: ST_TO_ADDR
// if not fac then
103594: LD_VAR 0 5
103598: NOT
103599: IFFALSE 103603
// continue ;
103601: GO 103545
// for j in fac do
103603: LD_ADDR_VAR 0 3
103607: PUSH
103608: LD_VAR 0 5
103612: PUSH
103613: FOR_IN
103614: IFFALSE 103969
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
103616: LD_VAR 0 3
103620: PPUSH
103621: CALL_OW 461
103625: PUSH
103626: LD_INT 2
103628: NONEQUAL
103629: PUSH
103630: LD_VAR 0 3
103634: PPUSH
103635: LD_INT 15
103637: PPUSH
103638: CALL 26958 0 2
103642: PUSH
103643: LD_INT 4
103645: ARRAY
103646: OR
103647: IFFALSE 103651
// continue ;
103649: GO 103613
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
103651: LD_VAR 0 3
103655: PPUSH
103656: LD_EXP 182
103660: PUSH
103661: LD_VAR 0 2
103665: ARRAY
103666: PUSH
103667: LD_INT 1
103669: ARRAY
103670: PUSH
103671: LD_INT 1
103673: ARRAY
103674: PPUSH
103675: LD_EXP 182
103679: PUSH
103680: LD_VAR 0 2
103684: ARRAY
103685: PUSH
103686: LD_INT 1
103688: ARRAY
103689: PUSH
103690: LD_INT 2
103692: ARRAY
103693: PPUSH
103694: LD_EXP 182
103698: PUSH
103699: LD_VAR 0 2
103703: ARRAY
103704: PUSH
103705: LD_INT 1
103707: ARRAY
103708: PUSH
103709: LD_INT 3
103711: ARRAY
103712: PPUSH
103713: LD_EXP 182
103717: PUSH
103718: LD_VAR 0 2
103722: ARRAY
103723: PUSH
103724: LD_INT 1
103726: ARRAY
103727: PUSH
103728: LD_INT 4
103730: ARRAY
103731: PPUSH
103732: CALL_OW 448
103736: PUSH
103737: LD_VAR 0 3
103741: PPUSH
103742: LD_EXP 182
103746: PUSH
103747: LD_VAR 0 2
103751: ARRAY
103752: PUSH
103753: LD_INT 1
103755: ARRAY
103756: PUSH
103757: LD_INT 1
103759: ARRAY
103760: PUSH
103761: LD_EXP 182
103765: PUSH
103766: LD_VAR 0 2
103770: ARRAY
103771: PUSH
103772: LD_INT 1
103774: ARRAY
103775: PUSH
103776: LD_INT 2
103778: ARRAY
103779: PUSH
103780: LD_EXP 182
103784: PUSH
103785: LD_VAR 0 2
103789: ARRAY
103790: PUSH
103791: LD_INT 1
103793: ARRAY
103794: PUSH
103795: LD_INT 3
103797: ARRAY
103798: PUSH
103799: LD_EXP 182
103803: PUSH
103804: LD_VAR 0 2
103808: ARRAY
103809: PUSH
103810: LD_INT 1
103812: ARRAY
103813: PUSH
103814: LD_INT 4
103816: ARRAY
103817: PUSH
103818: EMPTY
103819: LIST
103820: LIST
103821: LIST
103822: LIST
103823: PPUSH
103824: CALL 30725 0 2
103828: AND
103829: IFFALSE 103967
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
103831: LD_VAR 0 3
103835: PPUSH
103836: LD_EXP 182
103840: PUSH
103841: LD_VAR 0 2
103845: ARRAY
103846: PUSH
103847: LD_INT 1
103849: ARRAY
103850: PUSH
103851: LD_INT 1
103853: ARRAY
103854: PPUSH
103855: LD_EXP 182
103859: PUSH
103860: LD_VAR 0 2
103864: ARRAY
103865: PUSH
103866: LD_INT 1
103868: ARRAY
103869: PUSH
103870: LD_INT 2
103872: ARRAY
103873: PPUSH
103874: LD_EXP 182
103878: PUSH
103879: LD_VAR 0 2
103883: ARRAY
103884: PUSH
103885: LD_INT 1
103887: ARRAY
103888: PUSH
103889: LD_INT 3
103891: ARRAY
103892: PPUSH
103893: LD_EXP 182
103897: PUSH
103898: LD_VAR 0 2
103902: ARRAY
103903: PUSH
103904: LD_INT 1
103906: ARRAY
103907: PUSH
103908: LD_INT 4
103910: ARRAY
103911: PPUSH
103912: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
103916: LD_ADDR_VAR 0 4
103920: PUSH
103921: LD_EXP 182
103925: PUSH
103926: LD_VAR 0 2
103930: ARRAY
103931: PPUSH
103932: LD_INT 1
103934: PPUSH
103935: CALL_OW 3
103939: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
103940: LD_ADDR_EXP 182
103944: PUSH
103945: LD_EXP 182
103949: PPUSH
103950: LD_VAR 0 2
103954: PPUSH
103955: LD_VAR 0 4
103959: PPUSH
103960: CALL_OW 1
103964: ST_TO_ADDR
// break ;
103965: GO 103969
// end ; end ;
103967: GO 103613
103969: POP
103970: POP
// end ;
103971: GO 103545
103973: POP
103974: POP
// end ;
103975: LD_VAR 0 1
103979: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
103980: LD_INT 0
103982: PPUSH
103983: PPUSH
103984: PPUSH
// if not mc_bases then
103985: LD_EXP 161
103989: NOT
103990: IFFALSE 103994
// exit ;
103992: GO 104083
// for i = 1 to mc_bases do
103994: LD_ADDR_VAR 0 2
103998: PUSH
103999: DOUBLE
104000: LD_INT 1
104002: DEC
104003: ST_TO_ADDR
104004: LD_EXP 161
104008: PUSH
104009: FOR_TO
104010: IFFALSE 104081
// begin if mc_attack [ i ] then
104012: LD_EXP 181
104016: PUSH
104017: LD_VAR 0 2
104021: ARRAY
104022: IFFALSE 104079
// begin tmp := mc_attack [ i ] [ 1 ] ;
104024: LD_ADDR_VAR 0 3
104028: PUSH
104029: LD_EXP 181
104033: PUSH
104034: LD_VAR 0 2
104038: ARRAY
104039: PUSH
104040: LD_INT 1
104042: ARRAY
104043: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
104044: LD_ADDR_EXP 181
104048: PUSH
104049: LD_EXP 181
104053: PPUSH
104054: LD_VAR 0 2
104058: PPUSH
104059: EMPTY
104060: PPUSH
104061: CALL_OW 1
104065: ST_TO_ADDR
// Attack ( tmp ) ;
104066: LD_VAR 0 3
104070: PPUSH
104071: CALL 80896 0 1
// exit ;
104075: POP
104076: POP
104077: GO 104083
// end ; end ;
104079: GO 104009
104081: POP
104082: POP
// end ;
104083: LD_VAR 0 1
104087: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
104088: LD_INT 0
104090: PPUSH
104091: PPUSH
104092: PPUSH
104093: PPUSH
104094: PPUSH
104095: PPUSH
104096: PPUSH
// if not mc_bases then
104097: LD_EXP 161
104101: NOT
104102: IFFALSE 104106
// exit ;
104104: GO 104963
// for i = 1 to mc_bases do
104106: LD_ADDR_VAR 0 2
104110: PUSH
104111: DOUBLE
104112: LD_INT 1
104114: DEC
104115: ST_TO_ADDR
104116: LD_EXP 161
104120: PUSH
104121: FOR_TO
104122: IFFALSE 104961
// begin if not mc_bases [ i ] then
104124: LD_EXP 161
104128: PUSH
104129: LD_VAR 0 2
104133: ARRAY
104134: NOT
104135: IFFALSE 104139
// continue ;
104137: GO 104121
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
104139: LD_ADDR_VAR 0 7
104143: PUSH
104144: LD_EXP 161
104148: PUSH
104149: LD_VAR 0 2
104153: ARRAY
104154: PUSH
104155: LD_INT 1
104157: ARRAY
104158: PPUSH
104159: CALL 21010 0 1
104163: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
104164: LD_ADDR_EXP 184
104168: PUSH
104169: LD_EXP 184
104173: PPUSH
104174: LD_VAR 0 2
104178: PPUSH
104179: LD_EXP 161
104183: PUSH
104184: LD_VAR 0 2
104188: ARRAY
104189: PUSH
104190: LD_INT 1
104192: ARRAY
104193: PPUSH
104194: CALL_OW 255
104198: PPUSH
104199: LD_EXP 186
104203: PUSH
104204: LD_VAR 0 2
104208: ARRAY
104209: PPUSH
104210: CALL 20975 0 2
104214: PPUSH
104215: CALL_OW 1
104219: ST_TO_ADDR
// if not mc_scan [ i ] then
104220: LD_EXP 184
104224: PUSH
104225: LD_VAR 0 2
104229: ARRAY
104230: NOT
104231: IFFALSE 104409
// begin mc_is_defending := Replace ( mc_is_defending , i , false ) ;
104233: LD_ADDR_EXP 204
104237: PUSH
104238: LD_EXP 204
104242: PPUSH
104243: LD_VAR 0 2
104247: PPUSH
104248: LD_INT 0
104250: PPUSH
104251: CALL_OW 1
104255: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
104256: LD_ADDR_VAR 0 4
104260: PUSH
104261: LD_EXP 161
104265: PUSH
104266: LD_VAR 0 2
104270: ARRAY
104271: PPUSH
104272: LD_INT 2
104274: PUSH
104275: LD_INT 25
104277: PUSH
104278: LD_INT 5
104280: PUSH
104281: EMPTY
104282: LIST
104283: LIST
104284: PUSH
104285: LD_INT 25
104287: PUSH
104288: LD_INT 8
104290: PUSH
104291: EMPTY
104292: LIST
104293: LIST
104294: PUSH
104295: LD_INT 25
104297: PUSH
104298: LD_INT 9
104300: PUSH
104301: EMPTY
104302: LIST
104303: LIST
104304: PUSH
104305: EMPTY
104306: LIST
104307: LIST
104308: LIST
104309: LIST
104310: PPUSH
104311: CALL_OW 72
104315: ST_TO_ADDR
// if not tmp then
104316: LD_VAR 0 4
104320: NOT
104321: IFFALSE 104325
// continue ;
104323: GO 104121
// for j in tmp do
104325: LD_ADDR_VAR 0 3
104329: PUSH
104330: LD_VAR 0 4
104334: PUSH
104335: FOR_IN
104336: IFFALSE 104407
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
104338: LD_VAR 0 3
104342: PPUSH
104343: CALL_OW 310
104347: PPUSH
104348: CALL_OW 266
104352: PUSH
104353: LD_INT 5
104355: EQUAL
104356: PUSH
104357: LD_VAR 0 3
104361: PPUSH
104362: CALL_OW 257
104366: PUSH
104367: LD_INT 1
104369: EQUAL
104370: AND
104371: PUSH
104372: LD_VAR 0 3
104376: PPUSH
104377: CALL_OW 459
104381: NOT
104382: AND
104383: PUSH
104384: LD_VAR 0 7
104388: AND
104389: IFFALSE 104405
// ComChangeProfession ( j , class ) ;
104391: LD_VAR 0 3
104395: PPUSH
104396: LD_VAR 0 7
104400: PPUSH
104401: CALL_OW 123
104405: GO 104335
104407: POP
104408: POP
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and not mc_defender [ i ] and ( UnitFilter ( mc_bases [ i ] , [ [ f_ok ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) < 4 or UnitFilter ( mc_bases [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ) then
104409: LD_EXP 184
104413: PUSH
104414: LD_VAR 0 2
104418: ARRAY
104419: PUSH
104420: LD_EXP 204
104424: PUSH
104425: LD_VAR 0 2
104429: ARRAY
104430: NOT
104431: AND
104432: PUSH
104433: LD_EXP 183
104437: PUSH
104438: LD_VAR 0 2
104442: ARRAY
104443: NOT
104444: AND
104445: PUSH
104446: LD_EXP 161
104450: PUSH
104451: LD_VAR 0 2
104455: ARRAY
104456: PPUSH
104457: LD_INT 50
104459: PUSH
104460: EMPTY
104461: LIST
104462: PUSH
104463: LD_INT 2
104465: PUSH
104466: LD_INT 30
104468: PUSH
104469: LD_INT 32
104471: PUSH
104472: EMPTY
104473: LIST
104474: LIST
104475: PUSH
104476: LD_INT 30
104478: PUSH
104479: LD_INT 33
104481: PUSH
104482: EMPTY
104483: LIST
104484: LIST
104485: PUSH
104486: LD_INT 30
104488: PUSH
104489: LD_INT 4
104491: PUSH
104492: EMPTY
104493: LIST
104494: LIST
104495: PUSH
104496: LD_INT 30
104498: PUSH
104499: LD_INT 5
104501: PUSH
104502: EMPTY
104503: LIST
104504: LIST
104505: PUSH
104506: EMPTY
104507: LIST
104508: LIST
104509: LIST
104510: LIST
104511: LIST
104512: PUSH
104513: EMPTY
104514: LIST
104515: LIST
104516: PPUSH
104517: CALL_OW 72
104521: PUSH
104522: LD_INT 4
104524: LESS
104525: PUSH
104526: LD_EXP 161
104530: PUSH
104531: LD_VAR 0 2
104535: ARRAY
104536: PPUSH
104537: LD_INT 3
104539: PUSH
104540: LD_INT 24
104542: PUSH
104543: LD_INT 1000
104545: PUSH
104546: EMPTY
104547: LIST
104548: LIST
104549: PUSH
104550: EMPTY
104551: LIST
104552: LIST
104553: PUSH
104554: LD_INT 2
104556: PUSH
104557: LD_INT 30
104559: PUSH
104560: LD_INT 0
104562: PUSH
104563: EMPTY
104564: LIST
104565: LIST
104566: PUSH
104567: LD_INT 30
104569: PUSH
104570: LD_INT 1
104572: PUSH
104573: EMPTY
104574: LIST
104575: LIST
104576: PUSH
104577: EMPTY
104578: LIST
104579: LIST
104580: LIST
104581: PUSH
104582: EMPTY
104583: LIST
104584: LIST
104585: PPUSH
104586: CALL_OW 72
104590: OR
104591: AND
104592: IFFALSE 104843
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
104594: LD_ADDR_EXP 204
104598: PUSH
104599: LD_EXP 204
104603: PPUSH
104604: LD_VAR 0 2
104608: PPUSH
104609: LD_INT 1
104611: PPUSH
104612: CALL_OW 1
104616: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
104617: LD_ADDR_VAR 0 4
104621: PUSH
104622: LD_EXP 161
104626: PUSH
104627: LD_VAR 0 2
104631: ARRAY
104632: PPUSH
104633: LD_INT 2
104635: PUSH
104636: LD_INT 25
104638: PUSH
104639: LD_INT 1
104641: PUSH
104642: EMPTY
104643: LIST
104644: LIST
104645: PUSH
104646: LD_INT 25
104648: PUSH
104649: LD_INT 5
104651: PUSH
104652: EMPTY
104653: LIST
104654: LIST
104655: PUSH
104656: LD_INT 25
104658: PUSH
104659: LD_INT 8
104661: PUSH
104662: EMPTY
104663: LIST
104664: LIST
104665: PUSH
104666: LD_INT 25
104668: PUSH
104669: LD_INT 9
104671: PUSH
104672: EMPTY
104673: LIST
104674: LIST
104675: PUSH
104676: EMPTY
104677: LIST
104678: LIST
104679: LIST
104680: LIST
104681: LIST
104682: PPUSH
104683: CALL_OW 72
104687: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
104688: LD_ADDR_VAR 0 4
104692: PUSH
104693: LD_VAR 0 4
104697: PUSH
104698: LD_VAR 0 4
104702: PPUSH
104703: LD_INT 18
104705: PPUSH
104706: CALL 54273 0 2
104710: DIFF
104711: ST_TO_ADDR
// if not tmp and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
104712: LD_VAR 0 4
104716: NOT
104717: PUSH
104718: LD_EXP 161
104722: PUSH
104723: LD_VAR 0 2
104727: ARRAY
104728: PPUSH
104729: LD_INT 2
104731: PUSH
104732: LD_INT 30
104734: PUSH
104735: LD_INT 4
104737: PUSH
104738: EMPTY
104739: LIST
104740: LIST
104741: PUSH
104742: LD_INT 30
104744: PUSH
104745: LD_INT 5
104747: PUSH
104748: EMPTY
104749: LIST
104750: LIST
104751: PUSH
104752: EMPTY
104753: LIST
104754: LIST
104755: LIST
104756: PPUSH
104757: CALL_OW 72
104761: NOT
104762: AND
104763: IFFALSE 104825
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
104765: LD_ADDR_VAR 0 4
104769: PUSH
104770: LD_EXP 161
104774: PUSH
104775: LD_VAR 0 2
104779: ARRAY
104780: PPUSH
104781: LD_INT 2
104783: PUSH
104784: LD_INT 25
104786: PUSH
104787: LD_INT 2
104789: PUSH
104790: EMPTY
104791: LIST
104792: LIST
104793: PUSH
104794: LD_INT 25
104796: PUSH
104797: LD_INT 3
104799: PUSH
104800: EMPTY
104801: LIST
104802: LIST
104803: PUSH
104804: LD_INT 25
104806: PUSH
104807: LD_INT 4
104809: PUSH
104810: EMPTY
104811: LIST
104812: LIST
104813: PUSH
104814: EMPTY
104815: LIST
104816: LIST
104817: LIST
104818: LIST
104819: PPUSH
104820: CALL_OW 72
104824: ST_TO_ADDR
// BasicDefend ( i , tmp ) ;
104825: LD_VAR 0 2
104829: PPUSH
104830: LD_VAR 0 4
104834: PPUSH
104835: CALL 85605 0 2
// exit ;
104839: POP
104840: POP
104841: GO 104963
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and mc_defender [ i ] then
104843: LD_EXP 184
104847: PUSH
104848: LD_VAR 0 2
104852: ARRAY
104853: PUSH
104854: LD_EXP 204
104858: PUSH
104859: LD_VAR 0 2
104863: ARRAY
104864: NOT
104865: AND
104866: PUSH
104867: LD_EXP 183
104871: PUSH
104872: LD_VAR 0 2
104876: ARRAY
104877: AND
104878: IFFALSE 104959
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
104880: LD_ADDR_EXP 204
104884: PUSH
104885: LD_EXP 204
104889: PPUSH
104890: LD_VAR 0 2
104894: PPUSH
104895: LD_INT 1
104897: PPUSH
104898: CALL_OW 1
104902: ST_TO_ADDR
// tmp := mc_defender [ i ] ;
104903: LD_ADDR_VAR 0 4
104907: PUSH
104908: LD_EXP 183
104912: PUSH
104913: LD_VAR 0 2
104917: ARRAY
104918: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
104919: LD_ADDR_EXP 183
104923: PUSH
104924: LD_EXP 183
104928: PPUSH
104929: LD_VAR 0 2
104933: PPUSH
104934: EMPTY
104935: PPUSH
104936: CALL_OW 1
104940: ST_TO_ADDR
// Defend ( i , tmp ) ;
104941: LD_VAR 0 2
104945: PPUSH
104946: LD_VAR 0 4
104950: PPUSH
104951: CALL 86201 0 2
// exit ;
104955: POP
104956: POP
104957: GO 104963
// end ; end ;
104959: GO 104121
104961: POP
104962: POP
// end ;
104963: LD_VAR 0 1
104967: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
104968: LD_INT 0
104970: PPUSH
104971: PPUSH
104972: PPUSH
104973: PPUSH
104974: PPUSH
104975: PPUSH
104976: PPUSH
104977: PPUSH
104978: PPUSH
104979: PPUSH
104980: PPUSH
// if not mc_bases then
104981: LD_EXP 161
104985: NOT
104986: IFFALSE 104990
// exit ;
104988: GO 106077
// for i = 1 to mc_bases do
104990: LD_ADDR_VAR 0 2
104994: PUSH
104995: DOUBLE
104996: LD_INT 1
104998: DEC
104999: ST_TO_ADDR
105000: LD_EXP 161
105004: PUSH
105005: FOR_TO
105006: IFFALSE 106075
// begin tmp := mc_lab [ i ] ;
105008: LD_ADDR_VAR 0 6
105012: PUSH
105013: LD_EXP 194
105017: PUSH
105018: LD_VAR 0 2
105022: ARRAY
105023: ST_TO_ADDR
// if not tmp then
105024: LD_VAR 0 6
105028: NOT
105029: IFFALSE 105033
// continue ;
105031: GO 105005
// idle_lab := 0 ;
105033: LD_ADDR_VAR 0 11
105037: PUSH
105038: LD_INT 0
105040: ST_TO_ADDR
// for j in tmp do
105041: LD_ADDR_VAR 0 3
105045: PUSH
105046: LD_VAR 0 6
105050: PUSH
105051: FOR_IN
105052: IFFALSE 106071
// begin researching := false ;
105054: LD_ADDR_VAR 0 10
105058: PUSH
105059: LD_INT 0
105061: ST_TO_ADDR
// side := GetSide ( j ) ;
105062: LD_ADDR_VAR 0 4
105066: PUSH
105067: LD_VAR 0 3
105071: PPUSH
105072: CALL_OW 255
105076: ST_TO_ADDR
// if not mc_tech [ side ] then
105077: LD_EXP 188
105081: PUSH
105082: LD_VAR 0 4
105086: ARRAY
105087: NOT
105088: IFFALSE 105092
// continue ;
105090: GO 105051
// if BuildingStatus ( j ) = bs_idle then
105092: LD_VAR 0 3
105096: PPUSH
105097: CALL_OW 461
105101: PUSH
105102: LD_INT 2
105104: EQUAL
105105: IFFALSE 105293
// begin if idle_lab and UnitsInside ( j ) < 6 then
105107: LD_VAR 0 11
105111: PUSH
105112: LD_VAR 0 3
105116: PPUSH
105117: CALL_OW 313
105121: PUSH
105122: LD_INT 6
105124: LESS
105125: AND
105126: IFFALSE 105197
// begin tmp2 := UnitsInside ( idle_lab ) ;
105128: LD_ADDR_VAR 0 9
105132: PUSH
105133: LD_VAR 0 11
105137: PPUSH
105138: CALL_OW 313
105142: ST_TO_ADDR
// if tmp2 then
105143: LD_VAR 0 9
105147: IFFALSE 105189
// for x in tmp2 do
105149: LD_ADDR_VAR 0 7
105153: PUSH
105154: LD_VAR 0 9
105158: PUSH
105159: FOR_IN
105160: IFFALSE 105187
// begin ComExitBuilding ( x ) ;
105162: LD_VAR 0 7
105166: PPUSH
105167: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
105171: LD_VAR 0 7
105175: PPUSH
105176: LD_VAR 0 3
105180: PPUSH
105181: CALL_OW 180
// end ;
105185: GO 105159
105187: POP
105188: POP
// idle_lab := 0 ;
105189: LD_ADDR_VAR 0 11
105193: PUSH
105194: LD_INT 0
105196: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
105197: LD_ADDR_VAR 0 5
105201: PUSH
105202: LD_EXP 188
105206: PUSH
105207: LD_VAR 0 4
105211: ARRAY
105212: PUSH
105213: FOR_IN
105214: IFFALSE 105274
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
105216: LD_VAR 0 3
105220: PPUSH
105221: LD_VAR 0 5
105225: PPUSH
105226: CALL_OW 430
105230: PUSH
105231: LD_VAR 0 4
105235: PPUSH
105236: LD_VAR 0 5
105240: PPUSH
105241: CALL 20080 0 2
105245: AND
105246: IFFALSE 105272
// begin researching := true ;
105248: LD_ADDR_VAR 0 10
105252: PUSH
105253: LD_INT 1
105255: ST_TO_ADDR
// ComResearch ( j , t ) ;
105256: LD_VAR 0 3
105260: PPUSH
105261: LD_VAR 0 5
105265: PPUSH
105266: CALL_OW 124
// break ;
105270: GO 105274
// end ;
105272: GO 105213
105274: POP
105275: POP
// if not researching then
105276: LD_VAR 0 10
105280: NOT
105281: IFFALSE 105293
// idle_lab := j ;
105283: LD_ADDR_VAR 0 11
105287: PUSH
105288: LD_VAR 0 3
105292: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
105293: LD_VAR 0 3
105297: PPUSH
105298: CALL_OW 461
105302: PUSH
105303: LD_INT 10
105305: EQUAL
105306: IFFALSE 105894
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
105308: LD_EXP 190
105312: PUSH
105313: LD_VAR 0 2
105317: ARRAY
105318: NOT
105319: PUSH
105320: LD_EXP 191
105324: PUSH
105325: LD_VAR 0 2
105329: ARRAY
105330: NOT
105331: AND
105332: PUSH
105333: LD_EXP 188
105337: PUSH
105338: LD_VAR 0 4
105342: ARRAY
105343: PUSH
105344: LD_INT 1
105346: GREATER
105347: AND
105348: IFFALSE 105479
// begin ComCancel ( j ) ;
105350: LD_VAR 0 3
105354: PPUSH
105355: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
105359: LD_ADDR_EXP 188
105363: PUSH
105364: LD_EXP 188
105368: PPUSH
105369: LD_VAR 0 4
105373: PPUSH
105374: LD_EXP 188
105378: PUSH
105379: LD_VAR 0 4
105383: ARRAY
105384: PPUSH
105385: LD_EXP 188
105389: PUSH
105390: LD_VAR 0 4
105394: ARRAY
105395: PUSH
105396: LD_INT 1
105398: MINUS
105399: PPUSH
105400: LD_EXP 188
105404: PUSH
105405: LD_VAR 0 4
105409: ARRAY
105410: PPUSH
105411: LD_INT 0
105413: PPUSH
105414: CALL 23779 0 4
105418: PPUSH
105419: CALL_OW 1
105423: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
105424: LD_ADDR_EXP 188
105428: PUSH
105429: LD_EXP 188
105433: PPUSH
105434: LD_VAR 0 4
105438: PPUSH
105439: LD_EXP 188
105443: PUSH
105444: LD_VAR 0 4
105448: ARRAY
105449: PPUSH
105450: LD_EXP 188
105454: PUSH
105455: LD_VAR 0 4
105459: ARRAY
105460: PPUSH
105461: LD_INT 1
105463: PPUSH
105464: LD_INT 0
105466: PPUSH
105467: CALL 23779 0 4
105471: PPUSH
105472: CALL_OW 1
105476: ST_TO_ADDR
// continue ;
105477: GO 105051
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
105479: LD_EXP 190
105483: PUSH
105484: LD_VAR 0 2
105488: ARRAY
105489: PUSH
105490: LD_EXP 191
105494: PUSH
105495: LD_VAR 0 2
105499: ARRAY
105500: NOT
105501: AND
105502: IFFALSE 105629
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
105504: LD_ADDR_EXP 191
105508: PUSH
105509: LD_EXP 191
105513: PPUSH
105514: LD_VAR 0 2
105518: PUSH
105519: LD_EXP 191
105523: PUSH
105524: LD_VAR 0 2
105528: ARRAY
105529: PUSH
105530: LD_INT 1
105532: PLUS
105533: PUSH
105534: EMPTY
105535: LIST
105536: LIST
105537: PPUSH
105538: LD_EXP 190
105542: PUSH
105543: LD_VAR 0 2
105547: ARRAY
105548: PUSH
105549: LD_INT 1
105551: ARRAY
105552: PPUSH
105553: CALL 24361 0 3
105557: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
105558: LD_EXP 190
105562: PUSH
105563: LD_VAR 0 2
105567: ARRAY
105568: PUSH
105569: LD_INT 1
105571: ARRAY
105572: PPUSH
105573: LD_INT 112
105575: PPUSH
105576: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
105580: LD_ADDR_VAR 0 9
105584: PUSH
105585: LD_EXP 190
105589: PUSH
105590: LD_VAR 0 2
105594: ARRAY
105595: PPUSH
105596: LD_INT 1
105598: PPUSH
105599: CALL_OW 3
105603: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
105604: LD_ADDR_EXP 190
105608: PUSH
105609: LD_EXP 190
105613: PPUSH
105614: LD_VAR 0 2
105618: PPUSH
105619: LD_VAR 0 9
105623: PPUSH
105624: CALL_OW 1
105628: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
105629: LD_EXP 190
105633: PUSH
105634: LD_VAR 0 2
105638: ARRAY
105639: PUSH
105640: LD_EXP 191
105644: PUSH
105645: LD_VAR 0 2
105649: ARRAY
105650: AND
105651: PUSH
105652: LD_EXP 191
105656: PUSH
105657: LD_VAR 0 2
105661: ARRAY
105662: PUSH
105663: LD_INT 1
105665: ARRAY
105666: PPUSH
105667: CALL_OW 310
105671: NOT
105672: AND
105673: PUSH
105674: LD_VAR 0 3
105678: PPUSH
105679: CALL_OW 313
105683: PUSH
105684: LD_INT 6
105686: EQUAL
105687: AND
105688: IFFALSE 105744
// begin tmp2 := UnitsInside ( j ) ;
105690: LD_ADDR_VAR 0 9
105694: PUSH
105695: LD_VAR 0 3
105699: PPUSH
105700: CALL_OW 313
105704: ST_TO_ADDR
// if tmp2 = 6 then
105705: LD_VAR 0 9
105709: PUSH
105710: LD_INT 6
105712: EQUAL
105713: IFFALSE 105744
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
105715: LD_VAR 0 9
105719: PUSH
105720: LD_INT 1
105722: ARRAY
105723: PPUSH
105724: LD_INT 112
105726: PPUSH
105727: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
105731: LD_VAR 0 9
105735: PUSH
105736: LD_INT 1
105738: ARRAY
105739: PPUSH
105740: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
105744: LD_EXP 191
105748: PUSH
105749: LD_VAR 0 2
105753: ARRAY
105754: PUSH
105755: LD_EXP 191
105759: PUSH
105760: LD_VAR 0 2
105764: ARRAY
105765: PUSH
105766: LD_INT 1
105768: ARRAY
105769: PPUSH
105770: CALL_OW 314
105774: NOT
105775: AND
105776: PUSH
105777: LD_EXP 191
105781: PUSH
105782: LD_VAR 0 2
105786: ARRAY
105787: PUSH
105788: LD_INT 1
105790: ARRAY
105791: PPUSH
105792: CALL_OW 310
105796: NOT
105797: AND
105798: IFFALSE 105824
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
105800: LD_EXP 191
105804: PUSH
105805: LD_VAR 0 2
105809: ARRAY
105810: PUSH
105811: LD_INT 1
105813: ARRAY
105814: PPUSH
105815: LD_VAR 0 3
105819: PPUSH
105820: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
105824: LD_EXP 191
105828: PUSH
105829: LD_VAR 0 2
105833: ARRAY
105834: PUSH
105835: LD_INT 1
105837: ARRAY
105838: PPUSH
105839: CALL_OW 310
105843: PUSH
105844: LD_EXP 191
105848: PUSH
105849: LD_VAR 0 2
105853: ARRAY
105854: PUSH
105855: LD_INT 1
105857: ARRAY
105858: PPUSH
105859: CALL_OW 310
105863: PPUSH
105864: CALL_OW 461
105868: PUSH
105869: LD_INT 3
105871: NONEQUAL
105872: AND
105873: IFFALSE 105894
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
105875: LD_EXP 191
105879: PUSH
105880: LD_VAR 0 2
105884: ARRAY
105885: PUSH
105886: LD_INT 1
105888: ARRAY
105889: PPUSH
105890: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
105894: LD_VAR 0 3
105898: PPUSH
105899: CALL_OW 461
105903: PUSH
105904: LD_INT 6
105906: EQUAL
105907: PUSH
105908: LD_VAR 0 6
105912: PUSH
105913: LD_INT 1
105915: GREATER
105916: AND
105917: IFFALSE 106069
// begin sci := [ ] ;
105919: LD_ADDR_VAR 0 8
105923: PUSH
105924: EMPTY
105925: ST_TO_ADDR
// for x in ( tmp diff j ) do
105926: LD_ADDR_VAR 0 7
105930: PUSH
105931: LD_VAR 0 6
105935: PUSH
105936: LD_VAR 0 3
105940: DIFF
105941: PUSH
105942: FOR_IN
105943: IFFALSE 105995
// begin if sci = 6 then
105945: LD_VAR 0 8
105949: PUSH
105950: LD_INT 6
105952: EQUAL
105953: IFFALSE 105957
// break ;
105955: GO 105995
// if BuildingStatus ( x ) = bs_idle then
105957: LD_VAR 0 7
105961: PPUSH
105962: CALL_OW 461
105966: PUSH
105967: LD_INT 2
105969: EQUAL
105970: IFFALSE 105993
// sci := sci ^ UnitsInside ( x ) ;
105972: LD_ADDR_VAR 0 8
105976: PUSH
105977: LD_VAR 0 8
105981: PUSH
105982: LD_VAR 0 7
105986: PPUSH
105987: CALL_OW 313
105991: ADD
105992: ST_TO_ADDR
// end ;
105993: GO 105942
105995: POP
105996: POP
// if not sci then
105997: LD_VAR 0 8
106001: NOT
106002: IFFALSE 106006
// continue ;
106004: GO 105051
// for x in sci do
106006: LD_ADDR_VAR 0 7
106010: PUSH
106011: LD_VAR 0 8
106015: PUSH
106016: FOR_IN
106017: IFFALSE 106067
// if IsInUnit ( x ) and not HasTask ( x ) then
106019: LD_VAR 0 7
106023: PPUSH
106024: CALL_OW 310
106028: PUSH
106029: LD_VAR 0 7
106033: PPUSH
106034: CALL_OW 314
106038: NOT
106039: AND
106040: IFFALSE 106065
// begin ComExitBuilding ( x ) ;
106042: LD_VAR 0 7
106046: PPUSH
106047: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
106051: LD_VAR 0 7
106055: PPUSH
106056: LD_VAR 0 3
106060: PPUSH
106061: CALL_OW 180
// end ;
106065: GO 106016
106067: POP
106068: POP
// end ; end ;
106069: GO 105051
106071: POP
106072: POP
// end ;
106073: GO 105005
106075: POP
106076: POP
// end ;
106077: LD_VAR 0 1
106081: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
106082: LD_INT 0
106084: PPUSH
106085: PPUSH
// if not mc_bases then
106086: LD_EXP 161
106090: NOT
106091: IFFALSE 106095
// exit ;
106093: GO 106176
// for i = 1 to mc_bases do
106095: LD_ADDR_VAR 0 2
106099: PUSH
106100: DOUBLE
106101: LD_INT 1
106103: DEC
106104: ST_TO_ADDR
106105: LD_EXP 161
106109: PUSH
106110: FOR_TO
106111: IFFALSE 106174
// if mc_mines [ i ] and mc_miners [ i ] then
106113: LD_EXP 174
106117: PUSH
106118: LD_VAR 0 2
106122: ARRAY
106123: PUSH
106124: LD_EXP 175
106128: PUSH
106129: LD_VAR 0 2
106133: ARRAY
106134: AND
106135: IFFALSE 106172
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
106137: LD_EXP 175
106141: PUSH
106142: LD_VAR 0 2
106146: ARRAY
106147: PUSH
106148: LD_INT 1
106150: ARRAY
106151: PPUSH
106152: CALL_OW 255
106156: PPUSH
106157: LD_EXP 174
106161: PUSH
106162: LD_VAR 0 2
106166: ARRAY
106167: PPUSH
106168: CALL 21163 0 2
106172: GO 106110
106174: POP
106175: POP
// end ;
106176: LD_VAR 0 1
106180: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
106181: LD_INT 0
106183: PPUSH
106184: PPUSH
106185: PPUSH
106186: PPUSH
106187: PPUSH
106188: PPUSH
106189: PPUSH
106190: PPUSH
// if not mc_bases or not mc_parking then
106191: LD_EXP 161
106195: NOT
106196: PUSH
106197: LD_EXP 185
106201: NOT
106202: OR
106203: IFFALSE 106207
// exit ;
106205: GO 106945
// for i = 1 to mc_bases do
106207: LD_ADDR_VAR 0 2
106211: PUSH
106212: DOUBLE
106213: LD_INT 1
106215: DEC
106216: ST_TO_ADDR
106217: LD_EXP 161
106221: PUSH
106222: FOR_TO
106223: IFFALSE 106943
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
106225: LD_EXP 161
106229: PUSH
106230: LD_VAR 0 2
106234: ARRAY
106235: NOT
106236: PUSH
106237: LD_EXP 185
106241: PUSH
106242: LD_VAR 0 2
106246: ARRAY
106247: NOT
106248: OR
106249: IFFALSE 106253
// continue ;
106251: GO 106222
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
106253: LD_ADDR_VAR 0 5
106257: PUSH
106258: LD_EXP 161
106262: PUSH
106263: LD_VAR 0 2
106267: ARRAY
106268: PUSH
106269: LD_INT 1
106271: ARRAY
106272: PPUSH
106273: CALL_OW 255
106277: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
106278: LD_ADDR_VAR 0 6
106282: PUSH
106283: LD_EXP 161
106287: PUSH
106288: LD_VAR 0 2
106292: ARRAY
106293: PPUSH
106294: LD_INT 30
106296: PUSH
106297: LD_INT 3
106299: PUSH
106300: EMPTY
106301: LIST
106302: LIST
106303: PPUSH
106304: CALL_OW 72
106308: ST_TO_ADDR
// if not fac then
106309: LD_VAR 0 6
106313: NOT
106314: IFFALSE 106365
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
106316: LD_ADDR_VAR 0 6
106320: PUSH
106321: LD_EXP 161
106325: PUSH
106326: LD_VAR 0 2
106330: ARRAY
106331: PPUSH
106332: LD_INT 2
106334: PUSH
106335: LD_INT 30
106337: PUSH
106338: LD_INT 0
106340: PUSH
106341: EMPTY
106342: LIST
106343: LIST
106344: PUSH
106345: LD_INT 30
106347: PUSH
106348: LD_INT 1
106350: PUSH
106351: EMPTY
106352: LIST
106353: LIST
106354: PUSH
106355: EMPTY
106356: LIST
106357: LIST
106358: LIST
106359: PPUSH
106360: CALL_OW 72
106364: ST_TO_ADDR
// if not fac then
106365: LD_VAR 0 6
106369: NOT
106370: IFFALSE 106374
// continue ;
106372: GO 106222
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
106374: LD_ADDR_VAR 0 7
106378: PUSH
106379: LD_EXP 185
106383: PUSH
106384: LD_VAR 0 2
106388: ARRAY
106389: PPUSH
106390: LD_INT 22
106392: PUSH
106393: LD_VAR 0 5
106397: PUSH
106398: EMPTY
106399: LIST
106400: LIST
106401: PUSH
106402: LD_INT 21
106404: PUSH
106405: LD_INT 2
106407: PUSH
106408: EMPTY
106409: LIST
106410: LIST
106411: PUSH
106412: LD_INT 3
106414: PUSH
106415: LD_INT 60
106417: PUSH
106418: EMPTY
106419: LIST
106420: PUSH
106421: EMPTY
106422: LIST
106423: LIST
106424: PUSH
106425: LD_INT 3
106427: PUSH
106428: LD_INT 24
106430: PUSH
106431: LD_INT 1000
106433: PUSH
106434: EMPTY
106435: LIST
106436: LIST
106437: PUSH
106438: EMPTY
106439: LIST
106440: LIST
106441: PUSH
106442: EMPTY
106443: LIST
106444: LIST
106445: LIST
106446: LIST
106447: PPUSH
106448: CALL_OW 70
106452: ST_TO_ADDR
// for j in fac do
106453: LD_ADDR_VAR 0 3
106457: PUSH
106458: LD_VAR 0 6
106462: PUSH
106463: FOR_IN
106464: IFFALSE 106559
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
106466: LD_ADDR_VAR 0 7
106470: PUSH
106471: LD_VAR 0 7
106475: PUSH
106476: LD_INT 22
106478: PUSH
106479: LD_VAR 0 5
106483: PUSH
106484: EMPTY
106485: LIST
106486: LIST
106487: PUSH
106488: LD_INT 91
106490: PUSH
106491: LD_VAR 0 3
106495: PUSH
106496: LD_INT 15
106498: PUSH
106499: EMPTY
106500: LIST
106501: LIST
106502: LIST
106503: PUSH
106504: LD_INT 21
106506: PUSH
106507: LD_INT 2
106509: PUSH
106510: EMPTY
106511: LIST
106512: LIST
106513: PUSH
106514: LD_INT 3
106516: PUSH
106517: LD_INT 60
106519: PUSH
106520: EMPTY
106521: LIST
106522: PUSH
106523: EMPTY
106524: LIST
106525: LIST
106526: PUSH
106527: LD_INT 3
106529: PUSH
106530: LD_INT 24
106532: PUSH
106533: LD_INT 1000
106535: PUSH
106536: EMPTY
106537: LIST
106538: LIST
106539: PUSH
106540: EMPTY
106541: LIST
106542: LIST
106543: PUSH
106544: EMPTY
106545: LIST
106546: LIST
106547: LIST
106548: LIST
106549: LIST
106550: PPUSH
106551: CALL_OW 69
106555: UNION
106556: ST_TO_ADDR
106557: GO 106463
106559: POP
106560: POP
// if not vehs then
106561: LD_VAR 0 7
106565: NOT
106566: IFFALSE 106592
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
106568: LD_ADDR_EXP 173
106572: PUSH
106573: LD_EXP 173
106577: PPUSH
106578: LD_VAR 0 2
106582: PPUSH
106583: EMPTY
106584: PPUSH
106585: CALL_OW 1
106589: ST_TO_ADDR
// continue ;
106590: GO 106222
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
106592: LD_ADDR_VAR 0 8
106596: PUSH
106597: LD_EXP 161
106601: PUSH
106602: LD_VAR 0 2
106606: ARRAY
106607: PPUSH
106608: LD_INT 30
106610: PUSH
106611: LD_INT 3
106613: PUSH
106614: EMPTY
106615: LIST
106616: LIST
106617: PPUSH
106618: CALL_OW 72
106622: ST_TO_ADDR
// if tmp then
106623: LD_VAR 0 8
106627: IFFALSE 106730
// begin for j in tmp do
106629: LD_ADDR_VAR 0 3
106633: PUSH
106634: LD_VAR 0 8
106638: PUSH
106639: FOR_IN
106640: IFFALSE 106728
// for k in UnitsInside ( j ) do
106642: LD_ADDR_VAR 0 4
106646: PUSH
106647: LD_VAR 0 3
106651: PPUSH
106652: CALL_OW 313
106656: PUSH
106657: FOR_IN
106658: IFFALSE 106724
// if k then
106660: LD_VAR 0 4
106664: IFFALSE 106722
// if not k in mc_repair_vehicle [ i ] then
106666: LD_VAR 0 4
106670: PUSH
106671: LD_EXP 173
106675: PUSH
106676: LD_VAR 0 2
106680: ARRAY
106681: IN
106682: NOT
106683: IFFALSE 106722
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
106685: LD_ADDR_EXP 173
106689: PUSH
106690: LD_EXP 173
106694: PPUSH
106695: LD_VAR 0 2
106699: PPUSH
106700: LD_EXP 173
106704: PUSH
106705: LD_VAR 0 2
106709: ARRAY
106710: PUSH
106711: LD_VAR 0 4
106715: UNION
106716: PPUSH
106717: CALL_OW 1
106721: ST_TO_ADDR
106722: GO 106657
106724: POP
106725: POP
106726: GO 106639
106728: POP
106729: POP
// end ; if not mc_repair_vehicle [ i ] then
106730: LD_EXP 173
106734: PUSH
106735: LD_VAR 0 2
106739: ARRAY
106740: NOT
106741: IFFALSE 106745
// continue ;
106743: GO 106222
// for j in mc_repair_vehicle [ i ] do
106745: LD_ADDR_VAR 0 3
106749: PUSH
106750: LD_EXP 173
106754: PUSH
106755: LD_VAR 0 2
106759: ARRAY
106760: PUSH
106761: FOR_IN
106762: IFFALSE 106939
// begin if GetClass ( j ) <> 3 then
106764: LD_VAR 0 3
106768: PPUSH
106769: CALL_OW 257
106773: PUSH
106774: LD_INT 3
106776: NONEQUAL
106777: IFFALSE 106818
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
106779: LD_ADDR_EXP 173
106783: PUSH
106784: LD_EXP 173
106788: PPUSH
106789: LD_VAR 0 2
106793: PPUSH
106794: LD_EXP 173
106798: PUSH
106799: LD_VAR 0 2
106803: ARRAY
106804: PUSH
106805: LD_VAR 0 3
106809: DIFF
106810: PPUSH
106811: CALL_OW 1
106815: ST_TO_ADDR
// continue ;
106816: GO 106761
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
106818: LD_VAR 0 3
106822: PPUSH
106823: CALL_OW 311
106827: NOT
106828: PUSH
106829: LD_VAR 0 3
106833: PUSH
106834: LD_EXP 164
106838: PUSH
106839: LD_VAR 0 2
106843: ARRAY
106844: PUSH
106845: LD_INT 1
106847: ARRAY
106848: IN
106849: NOT
106850: AND
106851: PUSH
106852: LD_VAR 0 3
106856: PUSH
106857: LD_EXP 164
106861: PUSH
106862: LD_VAR 0 2
106866: ARRAY
106867: PUSH
106868: LD_INT 2
106870: ARRAY
106871: IN
106872: NOT
106873: AND
106874: IFFALSE 106937
// begin if IsInUnit ( j ) then
106876: LD_VAR 0 3
106880: PPUSH
106881: CALL_OW 310
106885: IFFALSE 106898
// ComExitBuilding ( j ) else
106887: LD_VAR 0 3
106891: PPUSH
106892: CALL_OW 122
106896: GO 106937
// if not WantToRepairVehicle ( j , vehs [ 1 ] ) then
106898: LD_VAR 0 3
106902: PPUSH
106903: LD_VAR 0 7
106907: PUSH
106908: LD_INT 1
106910: ARRAY
106911: PPUSH
106912: CALL 58757 0 2
106916: NOT
106917: IFFALSE 106937
// ComRepairVehicle ( j , vehs [ 1 ] ) ;
106919: LD_VAR 0 3
106923: PPUSH
106924: LD_VAR 0 7
106928: PUSH
106929: LD_INT 1
106931: ARRAY
106932: PPUSH
106933: CALL_OW 129
// end ; end ;
106937: GO 106761
106939: POP
106940: POP
// end ;
106941: GO 106222
106943: POP
106944: POP
// end ;
106945: LD_VAR 0 1
106949: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
106950: LD_INT 0
106952: PPUSH
106953: PPUSH
106954: PPUSH
106955: PPUSH
106956: PPUSH
106957: PPUSH
106958: PPUSH
106959: PPUSH
106960: PPUSH
106961: PPUSH
106962: PPUSH
// if not mc_bases then
106963: LD_EXP 161
106967: NOT
106968: IFFALSE 106972
// exit ;
106970: GO 107774
// for i = 1 to mc_bases do
106972: LD_ADDR_VAR 0 2
106976: PUSH
106977: DOUBLE
106978: LD_INT 1
106980: DEC
106981: ST_TO_ADDR
106982: LD_EXP 161
106986: PUSH
106987: FOR_TO
106988: IFFALSE 107772
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
106990: LD_EXP 189
106994: PUSH
106995: LD_VAR 0 2
106999: ARRAY
107000: NOT
107001: PUSH
107002: LD_EXP 164
107006: PUSH
107007: LD_VAR 0 2
107011: ARRAY
107012: PUSH
107013: LD_INT 1
107015: ARRAY
107016: OR
107017: PUSH
107018: LD_EXP 164
107022: PUSH
107023: LD_VAR 0 2
107027: ARRAY
107028: PUSH
107029: LD_INT 2
107031: ARRAY
107032: OR
107033: PUSH
107034: LD_EXP 187
107038: PUSH
107039: LD_VAR 0 2
107043: ARRAY
107044: PPUSH
107045: LD_INT 1
107047: PPUSH
107048: CALL_OW 325
107052: NOT
107053: OR
107054: PUSH
107055: LD_EXP 184
107059: PUSH
107060: LD_VAR 0 2
107064: ARRAY
107065: OR
107066: IFFALSE 107070
// continue ;
107068: GO 106987
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
107070: LD_ADDR_VAR 0 8
107074: PUSH
107075: LD_EXP 161
107079: PUSH
107080: LD_VAR 0 2
107084: ARRAY
107085: PPUSH
107086: LD_INT 25
107088: PUSH
107089: LD_INT 4
107091: PUSH
107092: EMPTY
107093: LIST
107094: LIST
107095: PUSH
107096: LD_INT 50
107098: PUSH
107099: EMPTY
107100: LIST
107101: PUSH
107102: LD_INT 3
107104: PUSH
107105: LD_INT 60
107107: PUSH
107108: EMPTY
107109: LIST
107110: PUSH
107111: EMPTY
107112: LIST
107113: LIST
107114: PUSH
107115: EMPTY
107116: LIST
107117: LIST
107118: LIST
107119: PPUSH
107120: CALL_OW 72
107124: PUSH
107125: LD_EXP 165
107129: PUSH
107130: LD_VAR 0 2
107134: ARRAY
107135: DIFF
107136: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
107137: LD_ADDR_VAR 0 9
107141: PUSH
107142: LD_EXP 161
107146: PUSH
107147: LD_VAR 0 2
107151: ARRAY
107152: PPUSH
107153: LD_INT 2
107155: PUSH
107156: LD_INT 30
107158: PUSH
107159: LD_INT 0
107161: PUSH
107162: EMPTY
107163: LIST
107164: LIST
107165: PUSH
107166: LD_INT 30
107168: PUSH
107169: LD_INT 1
107171: PUSH
107172: EMPTY
107173: LIST
107174: LIST
107175: PUSH
107176: EMPTY
107177: LIST
107178: LIST
107179: LIST
107180: PPUSH
107181: CALL_OW 72
107185: ST_TO_ADDR
// if not tmp or not dep then
107186: LD_VAR 0 8
107190: NOT
107191: PUSH
107192: LD_VAR 0 9
107196: NOT
107197: OR
107198: IFFALSE 107202
// continue ;
107200: GO 106987
// side := GetSide ( tmp [ 1 ] ) ;
107202: LD_ADDR_VAR 0 11
107206: PUSH
107207: LD_VAR 0 8
107211: PUSH
107212: LD_INT 1
107214: ARRAY
107215: PPUSH
107216: CALL_OW 255
107220: ST_TO_ADDR
// dep := dep [ 1 ] ;
107221: LD_ADDR_VAR 0 9
107225: PUSH
107226: LD_VAR 0 9
107230: PUSH
107231: LD_INT 1
107233: ARRAY
107234: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
107235: LD_ADDR_VAR 0 7
107239: PUSH
107240: LD_EXP 189
107244: PUSH
107245: LD_VAR 0 2
107249: ARRAY
107250: PPUSH
107251: LD_INT 22
107253: PUSH
107254: LD_INT 0
107256: PUSH
107257: EMPTY
107258: LIST
107259: LIST
107260: PUSH
107261: LD_INT 25
107263: PUSH
107264: LD_INT 12
107266: PUSH
107267: EMPTY
107268: LIST
107269: LIST
107270: PUSH
107271: EMPTY
107272: LIST
107273: LIST
107274: PPUSH
107275: CALL_OW 70
107279: PUSH
107280: LD_INT 22
107282: PUSH
107283: LD_INT 0
107285: PUSH
107286: EMPTY
107287: LIST
107288: LIST
107289: PUSH
107290: LD_INT 25
107292: PUSH
107293: LD_INT 12
107295: PUSH
107296: EMPTY
107297: LIST
107298: LIST
107299: PUSH
107300: LD_INT 91
107302: PUSH
107303: LD_VAR 0 9
107307: PUSH
107308: LD_INT 20
107310: PUSH
107311: EMPTY
107312: LIST
107313: LIST
107314: LIST
107315: PUSH
107316: EMPTY
107317: LIST
107318: LIST
107319: LIST
107320: PPUSH
107321: CALL_OW 69
107325: UNION
107326: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
107327: LD_ADDR_VAR 0 10
107331: PUSH
107332: LD_EXP 189
107336: PUSH
107337: LD_VAR 0 2
107341: ARRAY
107342: PPUSH
107343: LD_INT 81
107345: PUSH
107346: LD_VAR 0 11
107350: PUSH
107351: EMPTY
107352: LIST
107353: LIST
107354: PPUSH
107355: CALL_OW 70
107359: ST_TO_ADDR
// if not apes or danger_at_area then
107360: LD_VAR 0 7
107364: NOT
107365: PUSH
107366: LD_VAR 0 10
107370: OR
107371: IFFALSE 107421
// begin if mc_taming [ i ] then
107373: LD_EXP 192
107377: PUSH
107378: LD_VAR 0 2
107382: ARRAY
107383: IFFALSE 107419
// begin MC_Reset ( i , 121 ) ;
107385: LD_VAR 0 2
107389: PPUSH
107390: LD_INT 121
107392: PPUSH
107393: CALL 92358 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
107397: LD_ADDR_EXP 192
107401: PUSH
107402: LD_EXP 192
107406: PPUSH
107407: LD_VAR 0 2
107411: PPUSH
107412: EMPTY
107413: PPUSH
107414: CALL_OW 1
107418: ST_TO_ADDR
// end ; continue ;
107419: GO 106987
// end ; for j in tmp do
107421: LD_ADDR_VAR 0 3
107425: PUSH
107426: LD_VAR 0 8
107430: PUSH
107431: FOR_IN
107432: IFFALSE 107768
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
107434: LD_VAR 0 3
107438: PUSH
107439: LD_EXP 192
107443: PUSH
107444: LD_VAR 0 2
107448: ARRAY
107449: IN
107450: NOT
107451: PUSH
107452: LD_EXP 192
107456: PUSH
107457: LD_VAR 0 2
107461: ARRAY
107462: PUSH
107463: LD_INT 3
107465: LESS
107466: AND
107467: IFFALSE 107525
// begin SetTag ( j , 121 ) ;
107469: LD_VAR 0 3
107473: PPUSH
107474: LD_INT 121
107476: PPUSH
107477: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
107481: LD_ADDR_EXP 192
107485: PUSH
107486: LD_EXP 192
107490: PPUSH
107491: LD_VAR 0 2
107495: PUSH
107496: LD_EXP 192
107500: PUSH
107501: LD_VAR 0 2
107505: ARRAY
107506: PUSH
107507: LD_INT 1
107509: PLUS
107510: PUSH
107511: EMPTY
107512: LIST
107513: LIST
107514: PPUSH
107515: LD_VAR 0 3
107519: PPUSH
107520: CALL 24361 0 3
107524: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
107525: LD_VAR 0 3
107529: PUSH
107530: LD_EXP 192
107534: PUSH
107535: LD_VAR 0 2
107539: ARRAY
107540: IN
107541: IFFALSE 107766
// begin if GetClass ( j ) <> 4 then
107543: LD_VAR 0 3
107547: PPUSH
107548: CALL_OW 257
107552: PUSH
107553: LD_INT 4
107555: NONEQUAL
107556: IFFALSE 107609
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
107558: LD_ADDR_EXP 192
107562: PUSH
107563: LD_EXP 192
107567: PPUSH
107568: LD_VAR 0 2
107572: PPUSH
107573: LD_EXP 192
107577: PUSH
107578: LD_VAR 0 2
107582: ARRAY
107583: PUSH
107584: LD_VAR 0 3
107588: DIFF
107589: PPUSH
107590: CALL_OW 1
107594: ST_TO_ADDR
// SetTag ( j , 0 ) ;
107595: LD_VAR 0 3
107599: PPUSH
107600: LD_INT 0
107602: PPUSH
107603: CALL_OW 109
// continue ;
107607: GO 107431
// end ; if IsInUnit ( j ) then
107609: LD_VAR 0 3
107613: PPUSH
107614: CALL_OW 310
107618: IFFALSE 107629
// ComExitBuilding ( j ) ;
107620: LD_VAR 0 3
107624: PPUSH
107625: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
107629: LD_ADDR_VAR 0 6
107633: PUSH
107634: LD_VAR 0 7
107638: PPUSH
107639: LD_VAR 0 3
107643: PPUSH
107644: CALL_OW 74
107648: ST_TO_ADDR
// if not ape then
107649: LD_VAR 0 6
107653: NOT
107654: IFFALSE 107658
// break ;
107656: GO 107768
// x := GetX ( ape ) ;
107658: LD_ADDR_VAR 0 4
107662: PUSH
107663: LD_VAR 0 6
107667: PPUSH
107668: CALL_OW 250
107672: ST_TO_ADDR
// y := GetY ( ape ) ;
107673: LD_ADDR_VAR 0 5
107677: PUSH
107678: LD_VAR 0 6
107682: PPUSH
107683: CALL_OW 251
107687: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
107688: LD_VAR 0 4
107692: PPUSH
107693: LD_VAR 0 5
107697: PPUSH
107698: CALL_OW 488
107702: NOT
107703: PUSH
107704: LD_VAR 0 11
107708: PPUSH
107709: LD_VAR 0 4
107713: PPUSH
107714: LD_VAR 0 5
107718: PPUSH
107719: LD_INT 20
107721: PPUSH
107722: CALL 25257 0 4
107726: PUSH
107727: LD_INT 4
107729: ARRAY
107730: OR
107731: IFFALSE 107735
// break ;
107733: GO 107768
// if not HasTask ( j ) then
107735: LD_VAR 0 3
107739: PPUSH
107740: CALL_OW 314
107744: NOT
107745: IFFALSE 107766
// ComTameXY ( j , x , y ) ;
107747: LD_VAR 0 3
107751: PPUSH
107752: LD_VAR 0 4
107756: PPUSH
107757: LD_VAR 0 5
107761: PPUSH
107762: CALL_OW 131
// end ; end ;
107766: GO 107431
107768: POP
107769: POP
// end ;
107770: GO 106987
107772: POP
107773: POP
// end ;
107774: LD_VAR 0 1
107778: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
107779: LD_INT 0
107781: PPUSH
107782: PPUSH
107783: PPUSH
107784: PPUSH
107785: PPUSH
107786: PPUSH
107787: PPUSH
107788: PPUSH
// if not mc_bases then
107789: LD_EXP 161
107793: NOT
107794: IFFALSE 107798
// exit ;
107796: GO 108424
// for i = 1 to mc_bases do
107798: LD_ADDR_VAR 0 2
107802: PUSH
107803: DOUBLE
107804: LD_INT 1
107806: DEC
107807: ST_TO_ADDR
107808: LD_EXP 161
107812: PUSH
107813: FOR_TO
107814: IFFALSE 108422
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
107816: LD_EXP 190
107820: PUSH
107821: LD_VAR 0 2
107825: ARRAY
107826: NOT
107827: PUSH
107828: LD_EXP 190
107832: PUSH
107833: LD_VAR 0 2
107837: ARRAY
107838: PPUSH
107839: LD_INT 25
107841: PUSH
107842: LD_INT 12
107844: PUSH
107845: EMPTY
107846: LIST
107847: LIST
107848: PPUSH
107849: CALL_OW 72
107853: NOT
107854: OR
107855: IFFALSE 107859
// continue ;
107857: GO 107813
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
107859: LD_ADDR_VAR 0 5
107863: PUSH
107864: LD_EXP 190
107868: PUSH
107869: LD_VAR 0 2
107873: ARRAY
107874: PUSH
107875: LD_INT 1
107877: ARRAY
107878: PPUSH
107879: CALL_OW 255
107883: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
107884: LD_VAR 0 5
107888: PPUSH
107889: LD_INT 2
107891: PPUSH
107892: CALL_OW 325
107896: IFFALSE 108149
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
107898: LD_ADDR_VAR 0 4
107902: PUSH
107903: LD_EXP 190
107907: PUSH
107908: LD_VAR 0 2
107912: ARRAY
107913: PPUSH
107914: LD_INT 25
107916: PUSH
107917: LD_INT 16
107919: PUSH
107920: EMPTY
107921: LIST
107922: LIST
107923: PPUSH
107924: CALL_OW 72
107928: ST_TO_ADDR
// if tmp < 6 then
107929: LD_VAR 0 4
107933: PUSH
107934: LD_INT 6
107936: LESS
107937: IFFALSE 108149
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
107939: LD_ADDR_VAR 0 6
107943: PUSH
107944: LD_EXP 161
107948: PUSH
107949: LD_VAR 0 2
107953: ARRAY
107954: PPUSH
107955: LD_INT 2
107957: PUSH
107958: LD_INT 30
107960: PUSH
107961: LD_INT 0
107963: PUSH
107964: EMPTY
107965: LIST
107966: LIST
107967: PUSH
107968: LD_INT 30
107970: PUSH
107971: LD_INT 1
107973: PUSH
107974: EMPTY
107975: LIST
107976: LIST
107977: PUSH
107978: EMPTY
107979: LIST
107980: LIST
107981: LIST
107982: PPUSH
107983: CALL_OW 72
107987: ST_TO_ADDR
// if depot then
107988: LD_VAR 0 6
107992: IFFALSE 108149
// begin selected := 0 ;
107994: LD_ADDR_VAR 0 7
107998: PUSH
107999: LD_INT 0
108001: ST_TO_ADDR
// for j in depot do
108002: LD_ADDR_VAR 0 3
108006: PUSH
108007: LD_VAR 0 6
108011: PUSH
108012: FOR_IN
108013: IFFALSE 108044
// begin if UnitsInside ( j ) < 6 then
108015: LD_VAR 0 3
108019: PPUSH
108020: CALL_OW 313
108024: PUSH
108025: LD_INT 6
108027: LESS
108028: IFFALSE 108042
// begin selected := j ;
108030: LD_ADDR_VAR 0 7
108034: PUSH
108035: LD_VAR 0 3
108039: ST_TO_ADDR
// break ;
108040: GO 108044
// end ; end ;
108042: GO 108012
108044: POP
108045: POP
// if selected then
108046: LD_VAR 0 7
108050: IFFALSE 108149
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
108052: LD_ADDR_VAR 0 3
108056: PUSH
108057: LD_EXP 190
108061: PUSH
108062: LD_VAR 0 2
108066: ARRAY
108067: PPUSH
108068: LD_INT 25
108070: PUSH
108071: LD_INT 12
108073: PUSH
108074: EMPTY
108075: LIST
108076: LIST
108077: PPUSH
108078: CALL_OW 72
108082: PUSH
108083: FOR_IN
108084: IFFALSE 108147
// if not HasTask ( j ) then
108086: LD_VAR 0 3
108090: PPUSH
108091: CALL_OW 314
108095: NOT
108096: IFFALSE 108145
// begin if not IsInUnit ( j ) then
108098: LD_VAR 0 3
108102: PPUSH
108103: CALL_OW 310
108107: NOT
108108: IFFALSE 108124
// ComEnterUnit ( j , selected ) ;
108110: LD_VAR 0 3
108114: PPUSH
108115: LD_VAR 0 7
108119: PPUSH
108120: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
108124: LD_VAR 0 3
108128: PPUSH
108129: LD_INT 16
108131: PPUSH
108132: CALL_OW 183
// AddComExitBuilding ( j ) ;
108136: LD_VAR 0 3
108140: PPUSH
108141: CALL_OW 182
// end ;
108145: GO 108083
108147: POP
108148: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
108149: LD_VAR 0 5
108153: PPUSH
108154: LD_INT 11
108156: PPUSH
108157: CALL_OW 325
108161: IFFALSE 108420
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
108163: LD_ADDR_VAR 0 4
108167: PUSH
108168: LD_EXP 190
108172: PUSH
108173: LD_VAR 0 2
108177: ARRAY
108178: PPUSH
108179: LD_INT 25
108181: PUSH
108182: LD_INT 16
108184: PUSH
108185: EMPTY
108186: LIST
108187: LIST
108188: PPUSH
108189: CALL_OW 72
108193: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
108194: LD_VAR 0 4
108198: PUSH
108199: LD_INT 6
108201: GREATEREQUAL
108202: PUSH
108203: LD_VAR 0 5
108207: PPUSH
108208: LD_INT 2
108210: PPUSH
108211: CALL_OW 325
108215: NOT
108216: OR
108217: IFFALSE 108420
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
108219: LD_ADDR_VAR 0 8
108223: PUSH
108224: LD_EXP 161
108228: PUSH
108229: LD_VAR 0 2
108233: ARRAY
108234: PPUSH
108235: LD_INT 2
108237: PUSH
108238: LD_INT 30
108240: PUSH
108241: LD_INT 4
108243: PUSH
108244: EMPTY
108245: LIST
108246: LIST
108247: PUSH
108248: LD_INT 30
108250: PUSH
108251: LD_INT 5
108253: PUSH
108254: EMPTY
108255: LIST
108256: LIST
108257: PUSH
108258: EMPTY
108259: LIST
108260: LIST
108261: LIST
108262: PPUSH
108263: CALL_OW 72
108267: ST_TO_ADDR
// if barracks then
108268: LD_VAR 0 8
108272: IFFALSE 108420
// begin selected := 0 ;
108274: LD_ADDR_VAR 0 7
108278: PUSH
108279: LD_INT 0
108281: ST_TO_ADDR
// for j in barracks do
108282: LD_ADDR_VAR 0 3
108286: PUSH
108287: LD_VAR 0 8
108291: PUSH
108292: FOR_IN
108293: IFFALSE 108324
// begin if UnitsInside ( j ) < 6 then
108295: LD_VAR 0 3
108299: PPUSH
108300: CALL_OW 313
108304: PUSH
108305: LD_INT 6
108307: LESS
108308: IFFALSE 108322
// begin selected := j ;
108310: LD_ADDR_VAR 0 7
108314: PUSH
108315: LD_VAR 0 3
108319: ST_TO_ADDR
// break ;
108320: GO 108324
// end ; end ;
108322: GO 108292
108324: POP
108325: POP
// if selected then
108326: LD_VAR 0 7
108330: IFFALSE 108420
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
108332: LD_ADDR_VAR 0 3
108336: PUSH
108337: LD_EXP 190
108341: PUSH
108342: LD_VAR 0 2
108346: ARRAY
108347: PPUSH
108348: LD_INT 25
108350: PUSH
108351: LD_INT 12
108353: PUSH
108354: EMPTY
108355: LIST
108356: LIST
108357: PPUSH
108358: CALL_OW 72
108362: PUSH
108363: FOR_IN
108364: IFFALSE 108418
// if not IsInUnit ( j ) and not HasTask ( j ) then
108366: LD_VAR 0 3
108370: PPUSH
108371: CALL_OW 310
108375: NOT
108376: PUSH
108377: LD_VAR 0 3
108381: PPUSH
108382: CALL_OW 314
108386: NOT
108387: AND
108388: IFFALSE 108416
// begin ComEnterUnit ( j , selected ) ;
108390: LD_VAR 0 3
108394: PPUSH
108395: LD_VAR 0 7
108399: PPUSH
108400: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
108404: LD_VAR 0 3
108408: PPUSH
108409: LD_INT 15
108411: PPUSH
108412: CALL_OW 183
// end ;
108416: GO 108363
108418: POP
108419: POP
// end ; end ; end ; end ; end ;
108420: GO 107813
108422: POP
108423: POP
// end ;
108424: LD_VAR 0 1
108428: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
108429: LD_INT 0
108431: PPUSH
108432: PPUSH
108433: PPUSH
108434: PPUSH
// if not mc_bases then
108435: LD_EXP 161
108439: NOT
108440: IFFALSE 108444
// exit ;
108442: GO 108622
// for i = 1 to mc_bases do
108444: LD_ADDR_VAR 0 2
108448: PUSH
108449: DOUBLE
108450: LD_INT 1
108452: DEC
108453: ST_TO_ADDR
108454: LD_EXP 161
108458: PUSH
108459: FOR_TO
108460: IFFALSE 108620
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
108462: LD_ADDR_VAR 0 4
108466: PUSH
108467: LD_EXP 161
108471: PUSH
108472: LD_VAR 0 2
108476: ARRAY
108477: PPUSH
108478: LD_INT 25
108480: PUSH
108481: LD_INT 9
108483: PUSH
108484: EMPTY
108485: LIST
108486: LIST
108487: PPUSH
108488: CALL_OW 72
108492: ST_TO_ADDR
// if not tmp then
108493: LD_VAR 0 4
108497: NOT
108498: IFFALSE 108502
// continue ;
108500: GO 108459
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
108502: LD_EXP 187
108506: PUSH
108507: LD_VAR 0 2
108511: ARRAY
108512: PPUSH
108513: LD_INT 29
108515: PPUSH
108516: CALL_OW 325
108520: NOT
108521: PUSH
108522: LD_EXP 187
108526: PUSH
108527: LD_VAR 0 2
108531: ARRAY
108532: PPUSH
108533: LD_INT 28
108535: PPUSH
108536: CALL_OW 325
108540: NOT
108541: AND
108542: IFFALSE 108546
// continue ;
108544: GO 108459
// for j in tmp do
108546: LD_ADDR_VAR 0 3
108550: PUSH
108551: LD_VAR 0 4
108555: PUSH
108556: FOR_IN
108557: IFFALSE 108616
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
108559: LD_VAR 0 3
108563: PUSH
108564: LD_EXP 164
108568: PUSH
108569: LD_VAR 0 2
108573: ARRAY
108574: PUSH
108575: LD_INT 1
108577: ARRAY
108578: IN
108579: NOT
108580: PUSH
108581: LD_VAR 0 3
108585: PUSH
108586: LD_EXP 164
108590: PUSH
108591: LD_VAR 0 2
108595: ARRAY
108596: PUSH
108597: LD_INT 2
108599: ARRAY
108600: IN
108601: NOT
108602: AND
108603: IFFALSE 108614
// ComSpaceTimeShoot ( j ) ;
108605: LD_VAR 0 3
108609: PPUSH
108610: CALL 20171 0 1
108614: GO 108556
108616: POP
108617: POP
// end ;
108618: GO 108459
108620: POP
108621: POP
// end ;
108622: LD_VAR 0 1
108626: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
108627: LD_INT 0
108629: PPUSH
108630: PPUSH
108631: PPUSH
108632: PPUSH
108633: PPUSH
108634: PPUSH
108635: PPUSH
108636: PPUSH
108637: PPUSH
// if not mc_bases then
108638: LD_EXP 161
108642: NOT
108643: IFFALSE 108647
// exit ;
108645: GO 109269
// for i = 1 to mc_bases do
108647: LD_ADDR_VAR 0 2
108651: PUSH
108652: DOUBLE
108653: LD_INT 1
108655: DEC
108656: ST_TO_ADDR
108657: LD_EXP 161
108661: PUSH
108662: FOR_TO
108663: IFFALSE 109267
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
108665: LD_EXP 196
108669: PUSH
108670: LD_VAR 0 2
108674: ARRAY
108675: NOT
108676: PUSH
108677: LD_INT 38
108679: PPUSH
108680: LD_EXP 187
108684: PUSH
108685: LD_VAR 0 2
108689: ARRAY
108690: PPUSH
108691: CALL_OW 321
108695: PUSH
108696: LD_INT 2
108698: NONEQUAL
108699: OR
108700: IFFALSE 108704
// continue ;
108702: GO 108662
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
108704: LD_ADDR_VAR 0 8
108708: PUSH
108709: LD_EXP 161
108713: PUSH
108714: LD_VAR 0 2
108718: ARRAY
108719: PPUSH
108720: LD_INT 30
108722: PUSH
108723: LD_INT 34
108725: PUSH
108726: EMPTY
108727: LIST
108728: LIST
108729: PPUSH
108730: CALL_OW 72
108734: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
108735: LD_ADDR_VAR 0 9
108739: PUSH
108740: LD_EXP 161
108744: PUSH
108745: LD_VAR 0 2
108749: ARRAY
108750: PPUSH
108751: LD_INT 25
108753: PUSH
108754: LD_INT 4
108756: PUSH
108757: EMPTY
108758: LIST
108759: LIST
108760: PPUSH
108761: CALL_OW 72
108765: PPUSH
108766: LD_INT 0
108768: PPUSH
108769: CALL 54273 0 2
108773: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
108774: LD_VAR 0 9
108778: NOT
108779: PUSH
108780: LD_VAR 0 8
108784: NOT
108785: OR
108786: PUSH
108787: LD_EXP 161
108791: PUSH
108792: LD_VAR 0 2
108796: ARRAY
108797: PPUSH
108798: LD_INT 124
108800: PPUSH
108801: CALL 54273 0 2
108805: OR
108806: IFFALSE 108810
// continue ;
108808: GO 108662
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
108810: LD_EXP 197
108814: PUSH
108815: LD_VAR 0 2
108819: ARRAY
108820: PUSH
108821: LD_EXP 196
108825: PUSH
108826: LD_VAR 0 2
108830: ARRAY
108831: LESS
108832: PUSH
108833: LD_EXP 197
108837: PUSH
108838: LD_VAR 0 2
108842: ARRAY
108843: PUSH
108844: LD_VAR 0 8
108848: LESS
108849: AND
108850: IFFALSE 109265
// begin tmp := sci [ 1 ] ;
108852: LD_ADDR_VAR 0 7
108856: PUSH
108857: LD_VAR 0 9
108861: PUSH
108862: LD_INT 1
108864: ARRAY
108865: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
108866: LD_VAR 0 7
108870: PPUSH
108871: LD_INT 124
108873: PPUSH
108874: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
108878: LD_ADDR_VAR 0 3
108882: PUSH
108883: DOUBLE
108884: LD_EXP 196
108888: PUSH
108889: LD_VAR 0 2
108893: ARRAY
108894: INC
108895: ST_TO_ADDR
108896: LD_EXP 196
108900: PUSH
108901: LD_VAR 0 2
108905: ARRAY
108906: PUSH
108907: FOR_DOWNTO
108908: IFFALSE 109251
// begin if IsInUnit ( tmp ) then
108910: LD_VAR 0 7
108914: PPUSH
108915: CALL_OW 310
108919: IFFALSE 108930
// ComExitBuilding ( tmp ) ;
108921: LD_VAR 0 7
108925: PPUSH
108926: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
108930: LD_INT 35
108932: PPUSH
108933: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
108937: LD_VAR 0 7
108941: PPUSH
108942: CALL_OW 310
108946: NOT
108947: PUSH
108948: LD_VAR 0 7
108952: PPUSH
108953: CALL_OW 314
108957: NOT
108958: AND
108959: IFFALSE 108930
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
108961: LD_ADDR_VAR 0 6
108965: PUSH
108966: LD_VAR 0 7
108970: PPUSH
108971: CALL_OW 250
108975: PUSH
108976: LD_VAR 0 7
108980: PPUSH
108981: CALL_OW 251
108985: PUSH
108986: EMPTY
108987: LIST
108988: LIST
108989: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
108990: LD_INT 35
108992: PPUSH
108993: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
108997: LD_ADDR_VAR 0 4
109001: PUSH
109002: LD_EXP 196
109006: PUSH
109007: LD_VAR 0 2
109011: ARRAY
109012: PUSH
109013: LD_VAR 0 3
109017: ARRAY
109018: PUSH
109019: LD_INT 1
109021: ARRAY
109022: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
109023: LD_ADDR_VAR 0 5
109027: PUSH
109028: LD_EXP 196
109032: PUSH
109033: LD_VAR 0 2
109037: ARRAY
109038: PUSH
109039: LD_VAR 0 3
109043: ARRAY
109044: PUSH
109045: LD_INT 2
109047: ARRAY
109048: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
109049: LD_VAR 0 7
109053: PPUSH
109054: LD_INT 10
109056: PPUSH
109057: CALL 26958 0 2
109061: PUSH
109062: LD_INT 4
109064: ARRAY
109065: IFFALSE 109103
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
109067: LD_VAR 0 7
109071: PPUSH
109072: LD_VAR 0 6
109076: PUSH
109077: LD_INT 1
109079: ARRAY
109080: PPUSH
109081: LD_VAR 0 6
109085: PUSH
109086: LD_INT 2
109088: ARRAY
109089: PPUSH
109090: CALL_OW 111
// wait ( 0 0$10 ) ;
109094: LD_INT 350
109096: PPUSH
109097: CALL_OW 67
// end else
109101: GO 109129
// begin ComMoveXY ( tmp , x , y ) ;
109103: LD_VAR 0 7
109107: PPUSH
109108: LD_VAR 0 4
109112: PPUSH
109113: LD_VAR 0 5
109117: PPUSH
109118: CALL_OW 111
// wait ( 0 0$3 ) ;
109122: LD_INT 105
109124: PPUSH
109125: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
109129: LD_VAR 0 7
109133: PPUSH
109134: LD_VAR 0 4
109138: PPUSH
109139: LD_VAR 0 5
109143: PPUSH
109144: CALL_OW 307
109148: IFFALSE 108990
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
109150: LD_VAR 0 7
109154: PPUSH
109155: LD_VAR 0 4
109159: PPUSH
109160: LD_VAR 0 5
109164: PPUSH
109165: LD_VAR 0 8
109169: PUSH
109170: LD_VAR 0 3
109174: ARRAY
109175: PPUSH
109176: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
109180: LD_INT 35
109182: PPUSH
109183: CALL_OW 67
// until not HasTask ( tmp ) ;
109187: LD_VAR 0 7
109191: PPUSH
109192: CALL_OW 314
109196: NOT
109197: IFFALSE 109180
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
109199: LD_ADDR_EXP 197
109203: PUSH
109204: LD_EXP 197
109208: PPUSH
109209: LD_VAR 0 2
109213: PUSH
109214: LD_EXP 197
109218: PUSH
109219: LD_VAR 0 2
109223: ARRAY
109224: PUSH
109225: LD_INT 1
109227: PLUS
109228: PUSH
109229: EMPTY
109230: LIST
109231: LIST
109232: PPUSH
109233: LD_VAR 0 8
109237: PUSH
109238: LD_VAR 0 3
109242: ARRAY
109243: PPUSH
109244: CALL 24361 0 3
109248: ST_TO_ADDR
// end ;
109249: GO 108907
109251: POP
109252: POP
// MC_Reset ( i , 124 ) ;
109253: LD_VAR 0 2
109257: PPUSH
109258: LD_INT 124
109260: PPUSH
109261: CALL 92358 0 2
// end ; end ;
109265: GO 108662
109267: POP
109268: POP
// end ;
109269: LD_VAR 0 1
109273: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
109274: LD_INT 0
109276: PPUSH
109277: PPUSH
109278: PPUSH
// if not mc_bases then
109279: LD_EXP 161
109283: NOT
109284: IFFALSE 109288
// exit ;
109286: GO 109894
// for i = 1 to mc_bases do
109288: LD_ADDR_VAR 0 2
109292: PUSH
109293: DOUBLE
109294: LD_INT 1
109296: DEC
109297: ST_TO_ADDR
109298: LD_EXP 161
109302: PUSH
109303: FOR_TO
109304: IFFALSE 109892
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
109306: LD_ADDR_VAR 0 3
109310: PUSH
109311: LD_EXP 161
109315: PUSH
109316: LD_VAR 0 2
109320: ARRAY
109321: PPUSH
109322: LD_INT 25
109324: PUSH
109325: LD_INT 4
109327: PUSH
109328: EMPTY
109329: LIST
109330: LIST
109331: PPUSH
109332: CALL_OW 72
109336: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
109337: LD_VAR 0 3
109341: NOT
109342: PUSH
109343: LD_EXP 198
109347: PUSH
109348: LD_VAR 0 2
109352: ARRAY
109353: NOT
109354: OR
109355: PUSH
109356: LD_EXP 161
109360: PUSH
109361: LD_VAR 0 2
109365: ARRAY
109366: PPUSH
109367: LD_INT 2
109369: PUSH
109370: LD_INT 30
109372: PUSH
109373: LD_INT 0
109375: PUSH
109376: EMPTY
109377: LIST
109378: LIST
109379: PUSH
109380: LD_INT 30
109382: PUSH
109383: LD_INT 1
109385: PUSH
109386: EMPTY
109387: LIST
109388: LIST
109389: PUSH
109390: EMPTY
109391: LIST
109392: LIST
109393: LIST
109394: PPUSH
109395: CALL_OW 72
109399: NOT
109400: OR
109401: IFFALSE 109451
// begin if mc_deposits_finder [ i ] then
109403: LD_EXP 199
109407: PUSH
109408: LD_VAR 0 2
109412: ARRAY
109413: IFFALSE 109449
// begin MC_Reset ( i , 125 ) ;
109415: LD_VAR 0 2
109419: PPUSH
109420: LD_INT 125
109422: PPUSH
109423: CALL 92358 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
109427: LD_ADDR_EXP 199
109431: PUSH
109432: LD_EXP 199
109436: PPUSH
109437: LD_VAR 0 2
109441: PPUSH
109442: EMPTY
109443: PPUSH
109444: CALL_OW 1
109448: ST_TO_ADDR
// end ; continue ;
109449: GO 109303
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
109451: LD_EXP 198
109455: PUSH
109456: LD_VAR 0 2
109460: ARRAY
109461: PUSH
109462: LD_INT 1
109464: ARRAY
109465: PUSH
109466: LD_INT 3
109468: ARRAY
109469: PUSH
109470: LD_INT 1
109472: EQUAL
109473: PUSH
109474: LD_INT 20
109476: PPUSH
109477: LD_EXP 187
109481: PUSH
109482: LD_VAR 0 2
109486: ARRAY
109487: PPUSH
109488: CALL_OW 321
109492: PUSH
109493: LD_INT 2
109495: NONEQUAL
109496: AND
109497: IFFALSE 109547
// begin if mc_deposits_finder [ i ] then
109499: LD_EXP 199
109503: PUSH
109504: LD_VAR 0 2
109508: ARRAY
109509: IFFALSE 109545
// begin MC_Reset ( i , 125 ) ;
109511: LD_VAR 0 2
109515: PPUSH
109516: LD_INT 125
109518: PPUSH
109519: CALL 92358 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
109523: LD_ADDR_EXP 199
109527: PUSH
109528: LD_EXP 199
109532: PPUSH
109533: LD_VAR 0 2
109537: PPUSH
109538: EMPTY
109539: PPUSH
109540: CALL_OW 1
109544: ST_TO_ADDR
// end ; continue ;
109545: GO 109303
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
109547: LD_EXP 198
109551: PUSH
109552: LD_VAR 0 2
109556: ARRAY
109557: PUSH
109558: LD_INT 1
109560: ARRAY
109561: PUSH
109562: LD_INT 1
109564: ARRAY
109565: PPUSH
109566: LD_EXP 198
109570: PUSH
109571: LD_VAR 0 2
109575: ARRAY
109576: PUSH
109577: LD_INT 1
109579: ARRAY
109580: PUSH
109581: LD_INT 2
109583: ARRAY
109584: PPUSH
109585: LD_EXP 187
109589: PUSH
109590: LD_VAR 0 2
109594: ARRAY
109595: PPUSH
109596: CALL_OW 440
109600: IFFALSE 109643
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
109602: LD_ADDR_EXP 198
109606: PUSH
109607: LD_EXP 198
109611: PPUSH
109612: LD_VAR 0 2
109616: PPUSH
109617: LD_EXP 198
109621: PUSH
109622: LD_VAR 0 2
109626: ARRAY
109627: PPUSH
109628: LD_INT 1
109630: PPUSH
109631: CALL_OW 3
109635: PPUSH
109636: CALL_OW 1
109640: ST_TO_ADDR
109641: GO 109890
// begin if not mc_deposits_finder [ i ] then
109643: LD_EXP 199
109647: PUSH
109648: LD_VAR 0 2
109652: ARRAY
109653: NOT
109654: IFFALSE 109706
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
109656: LD_ADDR_EXP 199
109660: PUSH
109661: LD_EXP 199
109665: PPUSH
109666: LD_VAR 0 2
109670: PPUSH
109671: LD_VAR 0 3
109675: PUSH
109676: LD_INT 1
109678: ARRAY
109679: PUSH
109680: EMPTY
109681: LIST
109682: PPUSH
109683: CALL_OW 1
109687: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
109688: LD_VAR 0 3
109692: PUSH
109693: LD_INT 1
109695: ARRAY
109696: PPUSH
109697: LD_INT 125
109699: PPUSH
109700: CALL_OW 109
// end else
109704: GO 109890
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
109706: LD_EXP 199
109710: PUSH
109711: LD_VAR 0 2
109715: ARRAY
109716: PUSH
109717: LD_INT 1
109719: ARRAY
109720: PPUSH
109721: CALL_OW 310
109725: IFFALSE 109748
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
109727: LD_EXP 199
109731: PUSH
109732: LD_VAR 0 2
109736: ARRAY
109737: PUSH
109738: LD_INT 1
109740: ARRAY
109741: PPUSH
109742: CALL_OW 122
109746: GO 109890
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
109748: LD_EXP 199
109752: PUSH
109753: LD_VAR 0 2
109757: ARRAY
109758: PUSH
109759: LD_INT 1
109761: ARRAY
109762: PPUSH
109763: CALL_OW 314
109767: NOT
109768: PUSH
109769: LD_EXP 199
109773: PUSH
109774: LD_VAR 0 2
109778: ARRAY
109779: PUSH
109780: LD_INT 1
109782: ARRAY
109783: PPUSH
109784: LD_EXP 198
109788: PUSH
109789: LD_VAR 0 2
109793: ARRAY
109794: PUSH
109795: LD_INT 1
109797: ARRAY
109798: PUSH
109799: LD_INT 1
109801: ARRAY
109802: PPUSH
109803: LD_EXP 198
109807: PUSH
109808: LD_VAR 0 2
109812: ARRAY
109813: PUSH
109814: LD_INT 1
109816: ARRAY
109817: PUSH
109818: LD_INT 2
109820: ARRAY
109821: PPUSH
109822: CALL_OW 297
109826: PUSH
109827: LD_INT 6
109829: GREATER
109830: AND
109831: IFFALSE 109890
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
109833: LD_EXP 199
109837: PUSH
109838: LD_VAR 0 2
109842: ARRAY
109843: PUSH
109844: LD_INT 1
109846: ARRAY
109847: PPUSH
109848: LD_EXP 198
109852: PUSH
109853: LD_VAR 0 2
109857: ARRAY
109858: PUSH
109859: LD_INT 1
109861: ARRAY
109862: PUSH
109863: LD_INT 1
109865: ARRAY
109866: PPUSH
109867: LD_EXP 198
109871: PUSH
109872: LD_VAR 0 2
109876: ARRAY
109877: PUSH
109878: LD_INT 1
109880: ARRAY
109881: PUSH
109882: LD_INT 2
109884: ARRAY
109885: PPUSH
109886: CALL_OW 111
// end ; end ; end ;
109890: GO 109303
109892: POP
109893: POP
// end ;
109894: LD_VAR 0 1
109898: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
109899: LD_INT 0
109901: PPUSH
109902: PPUSH
109903: PPUSH
109904: PPUSH
109905: PPUSH
109906: PPUSH
109907: PPUSH
109908: PPUSH
109909: PPUSH
109910: PPUSH
109911: PPUSH
// if not mc_bases then
109912: LD_EXP 161
109916: NOT
109917: IFFALSE 109921
// exit ;
109919: GO 110861
// for i = 1 to mc_bases do
109921: LD_ADDR_VAR 0 2
109925: PUSH
109926: DOUBLE
109927: LD_INT 1
109929: DEC
109930: ST_TO_ADDR
109931: LD_EXP 161
109935: PUSH
109936: FOR_TO
109937: IFFALSE 110859
// begin if not mc_bases [ i ] or mc_scan [ i ] then
109939: LD_EXP 161
109943: PUSH
109944: LD_VAR 0 2
109948: ARRAY
109949: NOT
109950: PUSH
109951: LD_EXP 184
109955: PUSH
109956: LD_VAR 0 2
109960: ARRAY
109961: OR
109962: IFFALSE 109966
// continue ;
109964: GO 109936
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
109966: LD_ADDR_VAR 0 7
109970: PUSH
109971: LD_EXP 161
109975: PUSH
109976: LD_VAR 0 2
109980: ARRAY
109981: PUSH
109982: LD_INT 1
109984: ARRAY
109985: PPUSH
109986: CALL_OW 248
109990: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
109991: LD_VAR 0 7
109995: PUSH
109996: LD_INT 3
109998: EQUAL
109999: PUSH
110000: LD_EXP 180
110004: PUSH
110005: LD_VAR 0 2
110009: ARRAY
110010: PUSH
110011: LD_EXP 183
110015: PUSH
110016: LD_VAR 0 2
110020: ARRAY
110021: UNION
110022: PPUSH
110023: LD_INT 33
110025: PUSH
110026: LD_INT 2
110028: PUSH
110029: EMPTY
110030: LIST
110031: LIST
110032: PPUSH
110033: CALL_OW 72
110037: NOT
110038: OR
110039: IFFALSE 110043
// continue ;
110041: GO 109936
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
110043: LD_ADDR_VAR 0 9
110047: PUSH
110048: LD_EXP 161
110052: PUSH
110053: LD_VAR 0 2
110057: ARRAY
110058: PPUSH
110059: LD_INT 30
110061: PUSH
110062: LD_INT 36
110064: PUSH
110065: EMPTY
110066: LIST
110067: LIST
110068: PPUSH
110069: CALL_OW 72
110073: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
110074: LD_ADDR_VAR 0 10
110078: PUSH
110079: LD_EXP 180
110083: PUSH
110084: LD_VAR 0 2
110088: ARRAY
110089: PPUSH
110090: LD_INT 34
110092: PUSH
110093: LD_INT 31
110095: PUSH
110096: EMPTY
110097: LIST
110098: LIST
110099: PPUSH
110100: CALL_OW 72
110104: ST_TO_ADDR
// if not cts and not mcts then
110105: LD_VAR 0 9
110109: NOT
110110: PUSH
110111: LD_VAR 0 10
110115: NOT
110116: AND
110117: IFFALSE 110121
// continue ;
110119: GO 109936
// x := cts ;
110121: LD_ADDR_VAR 0 11
110125: PUSH
110126: LD_VAR 0 9
110130: ST_TO_ADDR
// if not x then
110131: LD_VAR 0 11
110135: NOT
110136: IFFALSE 110148
// x := mcts ;
110138: LD_ADDR_VAR 0 11
110142: PUSH
110143: LD_VAR 0 10
110147: ST_TO_ADDR
// if not x then
110148: LD_VAR 0 11
110152: NOT
110153: IFFALSE 110157
// continue ;
110155: GO 109936
// if mc_remote_driver [ i ] then
110157: LD_EXP 201
110161: PUSH
110162: LD_VAR 0 2
110166: ARRAY
110167: IFFALSE 110554
// for j in mc_remote_driver [ i ] do
110169: LD_ADDR_VAR 0 3
110173: PUSH
110174: LD_EXP 201
110178: PUSH
110179: LD_VAR 0 2
110183: ARRAY
110184: PUSH
110185: FOR_IN
110186: IFFALSE 110552
// begin if GetClass ( j ) <> 3 then
110188: LD_VAR 0 3
110192: PPUSH
110193: CALL_OW 257
110197: PUSH
110198: LD_INT 3
110200: NONEQUAL
110201: IFFALSE 110254
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
110203: LD_ADDR_EXP 201
110207: PUSH
110208: LD_EXP 201
110212: PPUSH
110213: LD_VAR 0 2
110217: PPUSH
110218: LD_EXP 201
110222: PUSH
110223: LD_VAR 0 2
110227: ARRAY
110228: PUSH
110229: LD_VAR 0 3
110233: DIFF
110234: PPUSH
110235: CALL_OW 1
110239: ST_TO_ADDR
// SetTag ( j , 0 ) ;
110240: LD_VAR 0 3
110244: PPUSH
110245: LD_INT 0
110247: PPUSH
110248: CALL_OW 109
// continue ;
110252: GO 110185
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
110254: LD_EXP 180
110258: PUSH
110259: LD_VAR 0 2
110263: ARRAY
110264: PPUSH
110265: LD_INT 34
110267: PUSH
110268: LD_INT 31
110270: PUSH
110271: EMPTY
110272: LIST
110273: LIST
110274: PUSH
110275: LD_INT 58
110277: PUSH
110278: EMPTY
110279: LIST
110280: PUSH
110281: EMPTY
110282: LIST
110283: LIST
110284: PPUSH
110285: CALL_OW 72
110289: PUSH
110290: LD_VAR 0 3
110294: PPUSH
110295: CALL 54308 0 1
110299: NOT
110300: AND
110301: IFFALSE 110372
// begin if IsInUnit ( j ) then
110303: LD_VAR 0 3
110307: PPUSH
110308: CALL_OW 310
110312: IFFALSE 110323
// ComExitBuilding ( j ) ;
110314: LD_VAR 0 3
110318: PPUSH
110319: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
110323: LD_VAR 0 3
110327: PPUSH
110328: LD_EXP 180
110332: PUSH
110333: LD_VAR 0 2
110337: ARRAY
110338: PPUSH
110339: LD_INT 34
110341: PUSH
110342: LD_INT 31
110344: PUSH
110345: EMPTY
110346: LIST
110347: LIST
110348: PUSH
110349: LD_INT 58
110351: PUSH
110352: EMPTY
110353: LIST
110354: PUSH
110355: EMPTY
110356: LIST
110357: LIST
110358: PPUSH
110359: CALL_OW 72
110363: PUSH
110364: LD_INT 1
110366: ARRAY
110367: PPUSH
110368: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
110372: LD_VAR 0 3
110376: PPUSH
110377: CALL_OW 310
110381: NOT
110382: PUSH
110383: LD_VAR 0 3
110387: PPUSH
110388: CALL_OW 310
110392: PPUSH
110393: CALL_OW 266
110397: PUSH
110398: LD_INT 36
110400: NONEQUAL
110401: PUSH
110402: LD_VAR 0 3
110406: PPUSH
110407: CALL 54308 0 1
110411: NOT
110412: AND
110413: OR
110414: IFFALSE 110550
// begin if IsInUnit ( j ) then
110416: LD_VAR 0 3
110420: PPUSH
110421: CALL_OW 310
110425: IFFALSE 110436
// ComExitBuilding ( j ) ;
110427: LD_VAR 0 3
110431: PPUSH
110432: CALL_OW 122
// ct := 0 ;
110436: LD_ADDR_VAR 0 8
110440: PUSH
110441: LD_INT 0
110443: ST_TO_ADDR
// for k in x do
110444: LD_ADDR_VAR 0 4
110448: PUSH
110449: LD_VAR 0 11
110453: PUSH
110454: FOR_IN
110455: IFFALSE 110528
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
110457: LD_VAR 0 4
110461: PPUSH
110462: CALL_OW 264
110466: PUSH
110467: LD_INT 31
110469: EQUAL
110470: PUSH
110471: LD_VAR 0 4
110475: PPUSH
110476: CALL_OW 311
110480: NOT
110481: AND
110482: PUSH
110483: LD_VAR 0 4
110487: PPUSH
110488: CALL_OW 266
110492: PUSH
110493: LD_INT 36
110495: EQUAL
110496: PUSH
110497: LD_VAR 0 4
110501: PPUSH
110502: CALL_OW 313
110506: PUSH
110507: LD_INT 3
110509: LESS
110510: AND
110511: OR
110512: IFFALSE 110526
// begin ct := k ;
110514: LD_ADDR_VAR 0 8
110518: PUSH
110519: LD_VAR 0 4
110523: ST_TO_ADDR
// break ;
110524: GO 110528
// end ;
110526: GO 110454
110528: POP
110529: POP
// if ct then
110530: LD_VAR 0 8
110534: IFFALSE 110550
// ComEnterUnit ( j , ct ) ;
110536: LD_VAR 0 3
110540: PPUSH
110541: LD_VAR 0 8
110545: PPUSH
110546: CALL_OW 120
// end ; end ;
110550: GO 110185
110552: POP
110553: POP
// places := 0 ;
110554: LD_ADDR_VAR 0 5
110558: PUSH
110559: LD_INT 0
110561: ST_TO_ADDR
// for j = 1 to x do
110562: LD_ADDR_VAR 0 3
110566: PUSH
110567: DOUBLE
110568: LD_INT 1
110570: DEC
110571: ST_TO_ADDR
110572: LD_VAR 0 11
110576: PUSH
110577: FOR_TO
110578: IFFALSE 110654
// if GetWeapon ( x [ j ] ) = ar_control_tower then
110580: LD_VAR 0 11
110584: PUSH
110585: LD_VAR 0 3
110589: ARRAY
110590: PPUSH
110591: CALL_OW 264
110595: PUSH
110596: LD_INT 31
110598: EQUAL
110599: IFFALSE 110617
// places := places + 1 else
110601: LD_ADDR_VAR 0 5
110605: PUSH
110606: LD_VAR 0 5
110610: PUSH
110611: LD_INT 1
110613: PLUS
110614: ST_TO_ADDR
110615: GO 110652
// if GetBType ( x [ j ] ) = b_control_tower then
110617: LD_VAR 0 11
110621: PUSH
110622: LD_VAR 0 3
110626: ARRAY
110627: PPUSH
110628: CALL_OW 266
110632: PUSH
110633: LD_INT 36
110635: EQUAL
110636: IFFALSE 110652
// places := places + 3 ;
110638: LD_ADDR_VAR 0 5
110642: PUSH
110643: LD_VAR 0 5
110647: PUSH
110648: LD_INT 3
110650: PLUS
110651: ST_TO_ADDR
110652: GO 110577
110654: POP
110655: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
110656: LD_VAR 0 5
110660: PUSH
110661: LD_INT 0
110663: EQUAL
110664: PUSH
110665: LD_VAR 0 5
110669: PUSH
110670: LD_EXP 201
110674: PUSH
110675: LD_VAR 0 2
110679: ARRAY
110680: LESSEQUAL
110681: OR
110682: IFFALSE 110686
// continue ;
110684: GO 109936
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
110686: LD_ADDR_VAR 0 6
110690: PUSH
110691: LD_EXP 161
110695: PUSH
110696: LD_VAR 0 2
110700: ARRAY
110701: PPUSH
110702: LD_INT 25
110704: PUSH
110705: LD_INT 3
110707: PUSH
110708: EMPTY
110709: LIST
110710: LIST
110711: PPUSH
110712: CALL_OW 72
110716: PUSH
110717: LD_EXP 201
110721: PUSH
110722: LD_VAR 0 2
110726: ARRAY
110727: DIFF
110728: PPUSH
110729: LD_INT 3
110731: PPUSH
110732: CALL 55208 0 2
110736: ST_TO_ADDR
// for j in tmp do
110737: LD_ADDR_VAR 0 3
110741: PUSH
110742: LD_VAR 0 6
110746: PUSH
110747: FOR_IN
110748: IFFALSE 110783
// if GetTag ( j ) > 0 then
110750: LD_VAR 0 3
110754: PPUSH
110755: CALL_OW 110
110759: PUSH
110760: LD_INT 0
110762: GREATER
110763: IFFALSE 110781
// tmp := tmp diff j ;
110765: LD_ADDR_VAR 0 6
110769: PUSH
110770: LD_VAR 0 6
110774: PUSH
110775: LD_VAR 0 3
110779: DIFF
110780: ST_TO_ADDR
110781: GO 110747
110783: POP
110784: POP
// if not tmp then
110785: LD_VAR 0 6
110789: NOT
110790: IFFALSE 110794
// continue ;
110792: GO 109936
// if places then
110794: LD_VAR 0 5
110798: IFFALSE 110857
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
110800: LD_ADDR_EXP 201
110804: PUSH
110805: LD_EXP 201
110809: PPUSH
110810: LD_VAR 0 2
110814: PPUSH
110815: LD_EXP 201
110819: PUSH
110820: LD_VAR 0 2
110824: ARRAY
110825: PUSH
110826: LD_VAR 0 6
110830: PUSH
110831: LD_INT 1
110833: ARRAY
110834: UNION
110835: PPUSH
110836: CALL_OW 1
110840: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
110841: LD_VAR 0 6
110845: PUSH
110846: LD_INT 1
110848: ARRAY
110849: PPUSH
110850: LD_INT 126
110852: PPUSH
110853: CALL_OW 109
// end ; end ;
110857: GO 109936
110859: POP
110860: POP
// end ;
110861: LD_VAR 0 1
110865: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
110866: LD_INT 0
110868: PPUSH
110869: PPUSH
110870: PPUSH
110871: PPUSH
110872: PPUSH
110873: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
110874: LD_VAR 0 1
110878: NOT
110879: PUSH
110880: LD_VAR 0 2
110884: NOT
110885: OR
110886: PUSH
110887: LD_VAR 0 3
110891: NOT
110892: OR
110893: PUSH
110894: LD_VAR 0 4
110898: PUSH
110899: LD_INT 1
110901: PUSH
110902: LD_INT 2
110904: PUSH
110905: LD_INT 3
110907: PUSH
110908: LD_INT 4
110910: PUSH
110911: LD_INT 5
110913: PUSH
110914: LD_INT 8
110916: PUSH
110917: LD_INT 9
110919: PUSH
110920: LD_INT 15
110922: PUSH
110923: LD_INT 16
110925: PUSH
110926: EMPTY
110927: LIST
110928: LIST
110929: LIST
110930: LIST
110931: LIST
110932: LIST
110933: LIST
110934: LIST
110935: LIST
110936: IN
110937: NOT
110938: OR
110939: IFFALSE 110943
// exit ;
110941: GO 111843
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
110943: LD_ADDR_VAR 0 2
110947: PUSH
110948: LD_VAR 0 2
110952: PPUSH
110953: LD_INT 21
110955: PUSH
110956: LD_INT 3
110958: PUSH
110959: EMPTY
110960: LIST
110961: LIST
110962: PUSH
110963: LD_INT 24
110965: PUSH
110966: LD_INT 250
110968: PUSH
110969: EMPTY
110970: LIST
110971: LIST
110972: PUSH
110973: EMPTY
110974: LIST
110975: LIST
110976: PPUSH
110977: CALL_OW 72
110981: ST_TO_ADDR
// case class of 1 , 15 :
110982: LD_VAR 0 4
110986: PUSH
110987: LD_INT 1
110989: DOUBLE
110990: EQUAL
110991: IFTRUE 111001
110993: LD_INT 15
110995: DOUBLE
110996: EQUAL
110997: IFTRUE 111001
110999: GO 111086
111001: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
111002: LD_ADDR_VAR 0 8
111006: PUSH
111007: LD_VAR 0 2
111011: PPUSH
111012: LD_INT 2
111014: PUSH
111015: LD_INT 30
111017: PUSH
111018: LD_INT 32
111020: PUSH
111021: EMPTY
111022: LIST
111023: LIST
111024: PUSH
111025: LD_INT 30
111027: PUSH
111028: LD_INT 31
111030: PUSH
111031: EMPTY
111032: LIST
111033: LIST
111034: PUSH
111035: EMPTY
111036: LIST
111037: LIST
111038: LIST
111039: PPUSH
111040: CALL_OW 72
111044: PUSH
111045: LD_VAR 0 2
111049: PPUSH
111050: LD_INT 2
111052: PUSH
111053: LD_INT 30
111055: PUSH
111056: LD_INT 4
111058: PUSH
111059: EMPTY
111060: LIST
111061: LIST
111062: PUSH
111063: LD_INT 30
111065: PUSH
111066: LD_INT 5
111068: PUSH
111069: EMPTY
111070: LIST
111071: LIST
111072: PUSH
111073: EMPTY
111074: LIST
111075: LIST
111076: LIST
111077: PPUSH
111078: CALL_OW 72
111082: ADD
111083: ST_TO_ADDR
111084: GO 111332
111086: LD_INT 2
111088: DOUBLE
111089: EQUAL
111090: IFTRUE 111100
111092: LD_INT 16
111094: DOUBLE
111095: EQUAL
111096: IFTRUE 111100
111098: GO 111146
111100: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
111101: LD_ADDR_VAR 0 8
111105: PUSH
111106: LD_VAR 0 2
111110: PPUSH
111111: LD_INT 2
111113: PUSH
111114: LD_INT 30
111116: PUSH
111117: LD_INT 0
111119: PUSH
111120: EMPTY
111121: LIST
111122: LIST
111123: PUSH
111124: LD_INT 30
111126: PUSH
111127: LD_INT 1
111129: PUSH
111130: EMPTY
111131: LIST
111132: LIST
111133: PUSH
111134: EMPTY
111135: LIST
111136: LIST
111137: LIST
111138: PPUSH
111139: CALL_OW 72
111143: ST_TO_ADDR
111144: GO 111332
111146: LD_INT 3
111148: DOUBLE
111149: EQUAL
111150: IFTRUE 111154
111152: GO 111200
111154: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
111155: LD_ADDR_VAR 0 8
111159: PUSH
111160: LD_VAR 0 2
111164: PPUSH
111165: LD_INT 2
111167: PUSH
111168: LD_INT 30
111170: PUSH
111171: LD_INT 2
111173: PUSH
111174: EMPTY
111175: LIST
111176: LIST
111177: PUSH
111178: LD_INT 30
111180: PUSH
111181: LD_INT 3
111183: PUSH
111184: EMPTY
111185: LIST
111186: LIST
111187: PUSH
111188: EMPTY
111189: LIST
111190: LIST
111191: LIST
111192: PPUSH
111193: CALL_OW 72
111197: ST_TO_ADDR
111198: GO 111332
111200: LD_INT 4
111202: DOUBLE
111203: EQUAL
111204: IFTRUE 111208
111206: GO 111265
111208: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
111209: LD_ADDR_VAR 0 8
111213: PUSH
111214: LD_VAR 0 2
111218: PPUSH
111219: LD_INT 2
111221: PUSH
111222: LD_INT 30
111224: PUSH
111225: LD_INT 6
111227: PUSH
111228: EMPTY
111229: LIST
111230: LIST
111231: PUSH
111232: LD_INT 30
111234: PUSH
111235: LD_INT 7
111237: PUSH
111238: EMPTY
111239: LIST
111240: LIST
111241: PUSH
111242: LD_INT 30
111244: PUSH
111245: LD_INT 8
111247: PUSH
111248: EMPTY
111249: LIST
111250: LIST
111251: PUSH
111252: EMPTY
111253: LIST
111254: LIST
111255: LIST
111256: LIST
111257: PPUSH
111258: CALL_OW 72
111262: ST_TO_ADDR
111263: GO 111332
111265: LD_INT 5
111267: DOUBLE
111268: EQUAL
111269: IFTRUE 111285
111271: LD_INT 8
111273: DOUBLE
111274: EQUAL
111275: IFTRUE 111285
111277: LD_INT 9
111279: DOUBLE
111280: EQUAL
111281: IFTRUE 111285
111283: GO 111331
111285: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
111286: LD_ADDR_VAR 0 8
111290: PUSH
111291: LD_VAR 0 2
111295: PPUSH
111296: LD_INT 2
111298: PUSH
111299: LD_INT 30
111301: PUSH
111302: LD_INT 4
111304: PUSH
111305: EMPTY
111306: LIST
111307: LIST
111308: PUSH
111309: LD_INT 30
111311: PUSH
111312: LD_INT 5
111314: PUSH
111315: EMPTY
111316: LIST
111317: LIST
111318: PUSH
111319: EMPTY
111320: LIST
111321: LIST
111322: LIST
111323: PPUSH
111324: CALL_OW 72
111328: ST_TO_ADDR
111329: GO 111332
111331: POP
// if not tmp then
111332: LD_VAR 0 8
111336: NOT
111337: IFFALSE 111341
// exit ;
111339: GO 111843
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
111341: LD_VAR 0 4
111345: PUSH
111346: LD_INT 1
111348: PUSH
111349: LD_INT 15
111351: PUSH
111352: EMPTY
111353: LIST
111354: LIST
111355: IN
111356: PUSH
111357: LD_EXP 170
111361: PUSH
111362: LD_VAR 0 1
111366: ARRAY
111367: AND
111368: IFFALSE 111524
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
111370: LD_ADDR_VAR 0 9
111374: PUSH
111375: LD_EXP 170
111379: PUSH
111380: LD_VAR 0 1
111384: ARRAY
111385: PUSH
111386: LD_INT 1
111388: ARRAY
111389: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
111390: LD_VAR 0 9
111394: PUSH
111395: LD_EXP 171
111399: PUSH
111400: LD_VAR 0 1
111404: ARRAY
111405: IN
111406: NOT
111407: IFFALSE 111522
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
111409: LD_ADDR_EXP 171
111413: PUSH
111414: LD_EXP 171
111418: PPUSH
111419: LD_VAR 0 1
111423: PUSH
111424: LD_EXP 171
111428: PUSH
111429: LD_VAR 0 1
111433: ARRAY
111434: PUSH
111435: LD_INT 1
111437: PLUS
111438: PUSH
111439: EMPTY
111440: LIST
111441: LIST
111442: PPUSH
111443: LD_VAR 0 9
111447: PPUSH
111448: CALL 24361 0 3
111452: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
111453: LD_ADDR_EXP 170
111457: PUSH
111458: LD_EXP 170
111462: PPUSH
111463: LD_VAR 0 1
111467: PPUSH
111468: LD_EXP 170
111472: PUSH
111473: LD_VAR 0 1
111477: ARRAY
111478: PUSH
111479: LD_VAR 0 9
111483: DIFF
111484: PPUSH
111485: CALL_OW 1
111489: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
111490: LD_VAR 0 3
111494: PPUSH
111495: LD_EXP 171
111499: PUSH
111500: LD_VAR 0 1
111504: ARRAY
111505: PUSH
111506: LD_EXP 171
111510: PUSH
111511: LD_VAR 0 1
111515: ARRAY
111516: ARRAY
111517: PPUSH
111518: CALL_OW 120
// end ; exit ;
111522: GO 111843
// end ; if tmp > 1 then
111524: LD_VAR 0 8
111528: PUSH
111529: LD_INT 1
111531: GREATER
111532: IFFALSE 111636
// for i = 2 to tmp do
111534: LD_ADDR_VAR 0 6
111538: PUSH
111539: DOUBLE
111540: LD_INT 2
111542: DEC
111543: ST_TO_ADDR
111544: LD_VAR 0 8
111548: PUSH
111549: FOR_TO
111550: IFFALSE 111634
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
111552: LD_VAR 0 8
111556: PUSH
111557: LD_VAR 0 6
111561: ARRAY
111562: PPUSH
111563: CALL_OW 461
111567: PUSH
111568: LD_INT 6
111570: EQUAL
111571: IFFALSE 111632
// begin x := tmp [ i ] ;
111573: LD_ADDR_VAR 0 9
111577: PUSH
111578: LD_VAR 0 8
111582: PUSH
111583: LD_VAR 0 6
111587: ARRAY
111588: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
111589: LD_ADDR_VAR 0 8
111593: PUSH
111594: LD_VAR 0 8
111598: PPUSH
111599: LD_VAR 0 6
111603: PPUSH
111604: CALL_OW 3
111608: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
111609: LD_ADDR_VAR 0 8
111613: PUSH
111614: LD_VAR 0 8
111618: PPUSH
111619: LD_INT 1
111621: PPUSH
111622: LD_VAR 0 9
111626: PPUSH
111627: CALL_OW 2
111631: ST_TO_ADDR
// end ;
111632: GO 111549
111634: POP
111635: POP
// for i in tmp do
111636: LD_ADDR_VAR 0 6
111640: PUSH
111641: LD_VAR 0 8
111645: PUSH
111646: FOR_IN
111647: IFFALSE 111716
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
111649: LD_VAR 0 6
111653: PPUSH
111654: CALL_OW 313
111658: PUSH
111659: LD_INT 6
111661: LESS
111662: PUSH
111663: LD_VAR 0 6
111667: PPUSH
111668: CALL_OW 266
111672: PUSH
111673: LD_INT 31
111675: PUSH
111676: LD_INT 32
111678: PUSH
111679: EMPTY
111680: LIST
111681: LIST
111682: IN
111683: NOT
111684: AND
111685: PUSH
111686: LD_VAR 0 6
111690: PPUSH
111691: CALL_OW 313
111695: PUSH
111696: LD_INT 0
111698: EQUAL
111699: OR
111700: IFFALSE 111714
// begin j := i ;
111702: LD_ADDR_VAR 0 7
111706: PUSH
111707: LD_VAR 0 6
111711: ST_TO_ADDR
// break ;
111712: GO 111716
// end ; end ;
111714: GO 111646
111716: POP
111717: POP
// if j then
111718: LD_VAR 0 7
111722: IFFALSE 111740
// ComEnterUnit ( unit , j ) else
111724: LD_VAR 0 3
111728: PPUSH
111729: LD_VAR 0 7
111733: PPUSH
111734: CALL_OW 120
111738: GO 111843
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
111740: LD_ADDR_VAR 0 10
111744: PUSH
111745: LD_VAR 0 2
111749: PPUSH
111750: LD_INT 2
111752: PUSH
111753: LD_INT 30
111755: PUSH
111756: LD_INT 0
111758: PUSH
111759: EMPTY
111760: LIST
111761: LIST
111762: PUSH
111763: LD_INT 30
111765: PUSH
111766: LD_INT 1
111768: PUSH
111769: EMPTY
111770: LIST
111771: LIST
111772: PUSH
111773: EMPTY
111774: LIST
111775: LIST
111776: LIST
111777: PPUSH
111778: CALL_OW 72
111782: ST_TO_ADDR
// if depot then
111783: LD_VAR 0 10
111787: IFFALSE 111843
// begin depot := NearestUnitToUnit ( depot , unit ) ;
111789: LD_ADDR_VAR 0 10
111793: PUSH
111794: LD_VAR 0 10
111798: PPUSH
111799: LD_VAR 0 3
111803: PPUSH
111804: CALL_OW 74
111808: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
111809: LD_VAR 0 3
111813: PPUSH
111814: LD_VAR 0 10
111818: PPUSH
111819: CALL_OW 296
111823: PUSH
111824: LD_INT 10
111826: GREATER
111827: IFFALSE 111843
// ComStandNearbyBuilding ( unit , depot ) ;
111829: LD_VAR 0 3
111833: PPUSH
111834: LD_VAR 0 10
111838: PPUSH
111839: CALL 20788 0 2
// end ; end ; end ;
111843: LD_VAR 0 5
111847: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
111848: LD_INT 0
111850: PPUSH
111851: PPUSH
111852: PPUSH
111853: PPUSH
// if not mc_bases then
111854: LD_EXP 161
111858: NOT
111859: IFFALSE 111863
// exit ;
111861: GO 112102
// for i = 1 to mc_bases do
111863: LD_ADDR_VAR 0 2
111867: PUSH
111868: DOUBLE
111869: LD_INT 1
111871: DEC
111872: ST_TO_ADDR
111873: LD_EXP 161
111877: PUSH
111878: FOR_TO
111879: IFFALSE 112100
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
111881: LD_ADDR_VAR 0 4
111885: PUSH
111886: LD_EXP 161
111890: PUSH
111891: LD_VAR 0 2
111895: ARRAY
111896: PPUSH
111897: LD_INT 21
111899: PUSH
111900: LD_INT 1
111902: PUSH
111903: EMPTY
111904: LIST
111905: LIST
111906: PPUSH
111907: CALL_OW 72
111911: PUSH
111912: LD_EXP 190
111916: PUSH
111917: LD_VAR 0 2
111921: ARRAY
111922: UNION
111923: ST_TO_ADDR
// if not tmp then
111924: LD_VAR 0 4
111928: NOT
111929: IFFALSE 111933
// continue ;
111931: GO 111878
// for j in tmp do
111933: LD_ADDR_VAR 0 3
111937: PUSH
111938: LD_VAR 0 4
111942: PUSH
111943: FOR_IN
111944: IFFALSE 112096
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
111946: LD_VAR 0 3
111950: PPUSH
111951: CALL_OW 110
111955: NOT
111956: PUSH
111957: LD_VAR 0 3
111961: PPUSH
111962: CALL_OW 314
111966: NOT
111967: AND
111968: PUSH
111969: LD_VAR 0 3
111973: PPUSH
111974: CALL_OW 311
111978: NOT
111979: AND
111980: PUSH
111981: LD_VAR 0 3
111985: PPUSH
111986: CALL_OW 310
111990: NOT
111991: AND
111992: PUSH
111993: LD_VAR 0 3
111997: PUSH
111998: LD_EXP 164
112002: PUSH
112003: LD_VAR 0 2
112007: ARRAY
112008: PUSH
112009: LD_INT 1
112011: ARRAY
112012: IN
112013: NOT
112014: AND
112015: PUSH
112016: LD_VAR 0 3
112020: PUSH
112021: LD_EXP 164
112025: PUSH
112026: LD_VAR 0 2
112030: ARRAY
112031: PUSH
112032: LD_INT 2
112034: ARRAY
112035: IN
112036: NOT
112037: AND
112038: PUSH
112039: LD_VAR 0 3
112043: PUSH
112044: LD_EXP 173
112048: PUSH
112049: LD_VAR 0 2
112053: ARRAY
112054: IN
112055: NOT
112056: AND
112057: IFFALSE 112094
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
112059: LD_VAR 0 2
112063: PPUSH
112064: LD_EXP 161
112068: PUSH
112069: LD_VAR 0 2
112073: ARRAY
112074: PPUSH
112075: LD_VAR 0 3
112079: PPUSH
112080: LD_VAR 0 3
112084: PPUSH
112085: CALL_OW 257
112089: PPUSH
112090: CALL 110866 0 4
// end ;
112094: GO 111943
112096: POP
112097: POP
// end ;
112098: GO 111878
112100: POP
112101: POP
// end ;
112102: LD_VAR 0 1
112106: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
112107: LD_INT 0
112109: PPUSH
112110: PPUSH
112111: PPUSH
112112: PPUSH
112113: PPUSH
112114: PPUSH
// if not mc_bases [ base ] then
112115: LD_EXP 161
112119: PUSH
112120: LD_VAR 0 1
112124: ARRAY
112125: NOT
112126: IFFALSE 112130
// exit ;
112128: GO 112312
// tmp := [ ] ;
112130: LD_ADDR_VAR 0 6
112134: PUSH
112135: EMPTY
112136: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
112137: LD_ADDR_VAR 0 7
112141: PUSH
112142: LD_VAR 0 3
112146: PPUSH
112147: LD_INT 0
112149: PPUSH
112150: CALL_OW 517
112154: ST_TO_ADDR
// if not list then
112155: LD_VAR 0 7
112159: NOT
112160: IFFALSE 112164
// exit ;
112162: GO 112312
// for i = 1 to amount do
112164: LD_ADDR_VAR 0 5
112168: PUSH
112169: DOUBLE
112170: LD_INT 1
112172: DEC
112173: ST_TO_ADDR
112174: LD_VAR 0 2
112178: PUSH
112179: FOR_TO
112180: IFFALSE 112260
// begin x := rand ( 1 , list [ 1 ] ) ;
112182: LD_ADDR_VAR 0 8
112186: PUSH
112187: LD_INT 1
112189: PPUSH
112190: LD_VAR 0 7
112194: PUSH
112195: LD_INT 1
112197: ARRAY
112198: PPUSH
112199: CALL_OW 12
112203: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
112204: LD_ADDR_VAR 0 6
112208: PUSH
112209: LD_VAR 0 6
112213: PPUSH
112214: LD_VAR 0 5
112218: PPUSH
112219: LD_VAR 0 7
112223: PUSH
112224: LD_INT 1
112226: ARRAY
112227: PUSH
112228: LD_VAR 0 8
112232: ARRAY
112233: PUSH
112234: LD_VAR 0 7
112238: PUSH
112239: LD_INT 2
112241: ARRAY
112242: PUSH
112243: LD_VAR 0 8
112247: ARRAY
112248: PUSH
112249: EMPTY
112250: LIST
112251: LIST
112252: PPUSH
112253: CALL_OW 1
112257: ST_TO_ADDR
// end ;
112258: GO 112179
112260: POP
112261: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
112262: LD_ADDR_EXP 174
112266: PUSH
112267: LD_EXP 174
112271: PPUSH
112272: LD_VAR 0 1
112276: PPUSH
112277: LD_VAR 0 6
112281: PPUSH
112282: CALL_OW 1
112286: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
112287: LD_ADDR_EXP 176
112291: PUSH
112292: LD_EXP 176
112296: PPUSH
112297: LD_VAR 0 1
112301: PPUSH
112302: LD_VAR 0 3
112306: PPUSH
112307: CALL_OW 1
112311: ST_TO_ADDR
// end ;
112312: LD_VAR 0 4
112316: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
112317: LD_INT 0
112319: PPUSH
// if not mc_bases [ base ] then
112320: LD_EXP 161
112324: PUSH
112325: LD_VAR 0 1
112329: ARRAY
112330: NOT
112331: IFFALSE 112335
// exit ;
112333: GO 112360
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
112335: LD_ADDR_EXP 166
112339: PUSH
112340: LD_EXP 166
112344: PPUSH
112345: LD_VAR 0 1
112349: PPUSH
112350: LD_VAR 0 2
112354: PPUSH
112355: CALL_OW 1
112359: ST_TO_ADDR
// end ;
112360: LD_VAR 0 3
112364: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
112365: LD_INT 0
112367: PPUSH
// if not mc_bases [ base ] then
112368: LD_EXP 161
112372: PUSH
112373: LD_VAR 0 1
112377: ARRAY
112378: NOT
112379: IFFALSE 112383
// exit ;
112381: GO 112420
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
112383: LD_ADDR_EXP 166
112387: PUSH
112388: LD_EXP 166
112392: PPUSH
112393: LD_VAR 0 1
112397: PPUSH
112398: LD_EXP 166
112402: PUSH
112403: LD_VAR 0 1
112407: ARRAY
112408: PUSH
112409: LD_VAR 0 2
112413: UNION
112414: PPUSH
112415: CALL_OW 1
112419: ST_TO_ADDR
// end ;
112420: LD_VAR 0 3
112424: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
112425: LD_INT 0
112427: PPUSH
// if not mc_bases [ base ] then
112428: LD_EXP 161
112432: PUSH
112433: LD_VAR 0 1
112437: ARRAY
112438: NOT
112439: IFFALSE 112443
// exit ;
112441: GO 112468
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
112443: LD_ADDR_EXP 182
112447: PUSH
112448: LD_EXP 182
112452: PPUSH
112453: LD_VAR 0 1
112457: PPUSH
112458: LD_VAR 0 2
112462: PPUSH
112463: CALL_OW 1
112467: ST_TO_ADDR
// end ;
112468: LD_VAR 0 3
112472: RET
// export function MC_InsertProduceList ( base , components ) ; begin
112473: LD_INT 0
112475: PPUSH
// if not mc_bases [ base ] then
112476: LD_EXP 161
112480: PUSH
112481: LD_VAR 0 1
112485: ARRAY
112486: NOT
112487: IFFALSE 112491
// exit ;
112489: GO 112528
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
112491: LD_ADDR_EXP 182
112495: PUSH
112496: LD_EXP 182
112500: PPUSH
112501: LD_VAR 0 1
112505: PPUSH
112506: LD_EXP 182
112510: PUSH
112511: LD_VAR 0 1
112515: ARRAY
112516: PUSH
112517: LD_VAR 0 2
112521: ADD
112522: PPUSH
112523: CALL_OW 1
112527: ST_TO_ADDR
// end ;
112528: LD_VAR 0 3
112532: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
112533: LD_INT 0
112535: PPUSH
// if not mc_bases [ base ] then
112536: LD_EXP 161
112540: PUSH
112541: LD_VAR 0 1
112545: ARRAY
112546: NOT
112547: IFFALSE 112551
// exit ;
112549: GO 112605
// mc_defender := Replace ( mc_defender , base , deflist ) ;
112551: LD_ADDR_EXP 183
112555: PUSH
112556: LD_EXP 183
112560: PPUSH
112561: LD_VAR 0 1
112565: PPUSH
112566: LD_VAR 0 2
112570: PPUSH
112571: CALL_OW 1
112575: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
112576: LD_ADDR_EXP 172
112580: PUSH
112581: LD_EXP 172
112585: PPUSH
112586: LD_VAR 0 1
112590: PPUSH
112591: LD_VAR 0 2
112595: PUSH
112596: LD_INT 0
112598: PLUS
112599: PPUSH
112600: CALL_OW 1
112604: ST_TO_ADDR
// end ;
112605: LD_VAR 0 3
112609: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
112610: LD_INT 0
112612: PPUSH
// if not mc_bases [ base ] then
112613: LD_EXP 161
112617: PUSH
112618: LD_VAR 0 1
112622: ARRAY
112623: NOT
112624: IFFALSE 112628
// exit ;
112626: GO 112653
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
112628: LD_ADDR_EXP 172
112632: PUSH
112633: LD_EXP 172
112637: PPUSH
112638: LD_VAR 0 1
112642: PPUSH
112643: LD_VAR 0 2
112647: PPUSH
112648: CALL_OW 1
112652: ST_TO_ADDR
// end ;
112653: LD_VAR 0 3
112657: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
112658: LD_INT 0
112660: PPUSH
112661: PPUSH
112662: PPUSH
112663: PPUSH
// if not mc_bases [ base ] then
112664: LD_EXP 161
112668: PUSH
112669: LD_VAR 0 1
112673: ARRAY
112674: NOT
112675: IFFALSE 112679
// exit ;
112677: GO 112744
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
112679: LD_ADDR_EXP 181
112683: PUSH
112684: LD_EXP 181
112688: PPUSH
112689: LD_VAR 0 1
112693: PUSH
112694: LD_EXP 181
112698: PUSH
112699: LD_VAR 0 1
112703: ARRAY
112704: PUSH
112705: LD_INT 1
112707: PLUS
112708: PUSH
112709: EMPTY
112710: LIST
112711: LIST
112712: PPUSH
112713: LD_VAR 0 1
112717: PUSH
112718: LD_VAR 0 2
112722: PUSH
112723: LD_VAR 0 3
112727: PUSH
112728: LD_VAR 0 4
112732: PUSH
112733: EMPTY
112734: LIST
112735: LIST
112736: LIST
112737: LIST
112738: PPUSH
112739: CALL 24361 0 3
112743: ST_TO_ADDR
// end ;
112744: LD_VAR 0 5
112748: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
112749: LD_INT 0
112751: PPUSH
// if not mc_bases [ base ] then
112752: LD_EXP 161
112756: PUSH
112757: LD_VAR 0 1
112761: ARRAY
112762: NOT
112763: IFFALSE 112767
// exit ;
112765: GO 112792
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
112767: LD_ADDR_EXP 198
112771: PUSH
112772: LD_EXP 198
112776: PPUSH
112777: LD_VAR 0 1
112781: PPUSH
112782: LD_VAR 0 2
112786: PPUSH
112787: CALL_OW 1
112791: ST_TO_ADDR
// end ;
112792: LD_VAR 0 3
112796: RET
// export function MC_GetMinesField ( base ) ; begin
112797: LD_INT 0
112799: PPUSH
// result := mc_mines [ base ] ;
112800: LD_ADDR_VAR 0 2
112804: PUSH
112805: LD_EXP 174
112809: PUSH
112810: LD_VAR 0 1
112814: ARRAY
112815: ST_TO_ADDR
// end ;
112816: LD_VAR 0 2
112820: RET
// export function MC_GetProduceList ( base ) ; begin
112821: LD_INT 0
112823: PPUSH
// result := mc_produce [ base ] ;
112824: LD_ADDR_VAR 0 2
112828: PUSH
112829: LD_EXP 182
112833: PUSH
112834: LD_VAR 0 1
112838: ARRAY
112839: ST_TO_ADDR
// end ;
112840: LD_VAR 0 2
112844: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
112845: LD_INT 0
112847: PPUSH
112848: PPUSH
// if not mc_bases then
112849: LD_EXP 161
112853: NOT
112854: IFFALSE 112858
// exit ;
112856: GO 112923
// if mc_bases [ base ] then
112858: LD_EXP 161
112862: PUSH
112863: LD_VAR 0 1
112867: ARRAY
112868: IFFALSE 112923
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
112870: LD_ADDR_VAR 0 3
112874: PUSH
112875: LD_EXP 161
112879: PUSH
112880: LD_VAR 0 1
112884: ARRAY
112885: PPUSH
112886: LD_INT 30
112888: PUSH
112889: LD_VAR 0 2
112893: PUSH
112894: EMPTY
112895: LIST
112896: LIST
112897: PPUSH
112898: CALL_OW 72
112902: ST_TO_ADDR
// if result then
112903: LD_VAR 0 3
112907: IFFALSE 112923
// result := result [ 1 ] ;
112909: LD_ADDR_VAR 0 3
112913: PUSH
112914: LD_VAR 0 3
112918: PUSH
112919: LD_INT 1
112921: ARRAY
112922: ST_TO_ADDR
// end ; end ;
112923: LD_VAR 0 3
112927: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
112928: LD_INT 0
112930: PPUSH
112931: PPUSH
// if not mc_bases then
112932: LD_EXP 161
112936: NOT
112937: IFFALSE 112941
// exit ;
112939: GO 112986
// if mc_bases [ base ] then
112941: LD_EXP 161
112945: PUSH
112946: LD_VAR 0 1
112950: ARRAY
112951: IFFALSE 112986
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
112953: LD_ADDR_VAR 0 3
112957: PUSH
112958: LD_EXP 161
112962: PUSH
112963: LD_VAR 0 1
112967: ARRAY
112968: PPUSH
112969: LD_INT 30
112971: PUSH
112972: LD_VAR 0 2
112976: PUSH
112977: EMPTY
112978: LIST
112979: LIST
112980: PPUSH
112981: CALL_OW 72
112985: ST_TO_ADDR
// end ;
112986: LD_VAR 0 3
112990: RET
// export function MC_SetTame ( base , area ) ; begin
112991: LD_INT 0
112993: PPUSH
// if not mc_bases or not base then
112994: LD_EXP 161
112998: NOT
112999: PUSH
113000: LD_VAR 0 1
113004: NOT
113005: OR
113006: IFFALSE 113010
// exit ;
113008: GO 113035
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
113010: LD_ADDR_EXP 189
113014: PUSH
113015: LD_EXP 189
113019: PPUSH
113020: LD_VAR 0 1
113024: PPUSH
113025: LD_VAR 0 2
113029: PPUSH
113030: CALL_OW 1
113034: ST_TO_ADDR
// end ;
113035: LD_VAR 0 3
113039: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
113040: LD_INT 0
113042: PPUSH
113043: PPUSH
// if not mc_bases or not base then
113044: LD_EXP 161
113048: NOT
113049: PUSH
113050: LD_VAR 0 1
113054: NOT
113055: OR
113056: IFFALSE 113060
// exit ;
113058: GO 113162
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
113060: LD_ADDR_VAR 0 4
113064: PUSH
113065: LD_EXP 161
113069: PUSH
113070: LD_VAR 0 1
113074: ARRAY
113075: PPUSH
113076: LD_INT 30
113078: PUSH
113079: LD_VAR 0 2
113083: PUSH
113084: EMPTY
113085: LIST
113086: LIST
113087: PPUSH
113088: CALL_OW 72
113092: ST_TO_ADDR
// if not tmp then
113093: LD_VAR 0 4
113097: NOT
113098: IFFALSE 113102
// exit ;
113100: GO 113162
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
113102: LD_ADDR_EXP 193
113106: PUSH
113107: LD_EXP 193
113111: PPUSH
113112: LD_VAR 0 1
113116: PPUSH
113117: LD_EXP 193
113121: PUSH
113122: LD_VAR 0 1
113126: ARRAY
113127: PPUSH
113128: LD_EXP 193
113132: PUSH
113133: LD_VAR 0 1
113137: ARRAY
113138: PUSH
113139: LD_INT 1
113141: PLUS
113142: PPUSH
113143: LD_VAR 0 4
113147: PUSH
113148: LD_INT 1
113150: ARRAY
113151: PPUSH
113152: CALL_OW 2
113156: PPUSH
113157: CALL_OW 1
113161: ST_TO_ADDR
// end ;
113162: LD_VAR 0 3
113166: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
113167: LD_INT 0
113169: PPUSH
113170: PPUSH
// if not mc_bases or not base or not kinds then
113171: LD_EXP 161
113175: NOT
113176: PUSH
113177: LD_VAR 0 1
113181: NOT
113182: OR
113183: PUSH
113184: LD_VAR 0 2
113188: NOT
113189: OR
113190: IFFALSE 113194
// exit ;
113192: GO 113255
// for i in kinds do
113194: LD_ADDR_VAR 0 4
113198: PUSH
113199: LD_VAR 0 2
113203: PUSH
113204: FOR_IN
113205: IFFALSE 113253
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
113207: LD_ADDR_EXP 195
113211: PUSH
113212: LD_EXP 195
113216: PPUSH
113217: LD_VAR 0 1
113221: PUSH
113222: LD_EXP 195
113226: PUSH
113227: LD_VAR 0 1
113231: ARRAY
113232: PUSH
113233: LD_INT 1
113235: PLUS
113236: PUSH
113237: EMPTY
113238: LIST
113239: LIST
113240: PPUSH
113241: LD_VAR 0 4
113245: PPUSH
113246: CALL 24361 0 3
113250: ST_TO_ADDR
113251: GO 113204
113253: POP
113254: POP
// end ;
113255: LD_VAR 0 3
113259: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
113260: LD_INT 0
113262: PPUSH
// if not mc_bases or not base or not areas then
113263: LD_EXP 161
113267: NOT
113268: PUSH
113269: LD_VAR 0 1
113273: NOT
113274: OR
113275: PUSH
113276: LD_VAR 0 2
113280: NOT
113281: OR
113282: IFFALSE 113286
// exit ;
113284: GO 113311
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
113286: LD_ADDR_EXP 179
113290: PUSH
113291: LD_EXP 179
113295: PPUSH
113296: LD_VAR 0 1
113300: PPUSH
113301: LD_VAR 0 2
113305: PPUSH
113306: CALL_OW 1
113310: ST_TO_ADDR
// end ;
113311: LD_VAR 0 3
113315: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
113316: LD_INT 0
113318: PPUSH
// if not mc_bases or not base or not teleports_exit then
113319: LD_EXP 161
113323: NOT
113324: PUSH
113325: LD_VAR 0 1
113329: NOT
113330: OR
113331: PUSH
113332: LD_VAR 0 2
113336: NOT
113337: OR
113338: IFFALSE 113342
// exit ;
113340: GO 113367
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
113342: LD_ADDR_EXP 196
113346: PUSH
113347: LD_EXP 196
113351: PPUSH
113352: LD_VAR 0 1
113356: PPUSH
113357: LD_VAR 0 2
113361: PPUSH
113362: CALL_OW 1
113366: ST_TO_ADDR
// end ;
113367: LD_VAR 0 3
113371: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
113372: LD_INT 0
113374: PPUSH
113375: PPUSH
113376: PPUSH
// if not mc_bases or not base or not ext_list then
113377: LD_EXP 161
113381: NOT
113382: PUSH
113383: LD_VAR 0 1
113387: NOT
113388: OR
113389: PUSH
113390: LD_VAR 0 5
113394: NOT
113395: OR
113396: IFFALSE 113400
// exit ;
113398: GO 113573
// tmp := GetFacExtXYD ( x , y , d ) ;
113400: LD_ADDR_VAR 0 8
113404: PUSH
113405: LD_VAR 0 2
113409: PPUSH
113410: LD_VAR 0 3
113414: PPUSH
113415: LD_VAR 0 4
113419: PPUSH
113420: CALL 54338 0 3
113424: ST_TO_ADDR
// if not tmp then
113425: LD_VAR 0 8
113429: NOT
113430: IFFALSE 113434
// exit ;
113432: GO 113573
// for i in tmp do
113434: LD_ADDR_VAR 0 7
113438: PUSH
113439: LD_VAR 0 8
113443: PUSH
113444: FOR_IN
113445: IFFALSE 113571
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
113447: LD_ADDR_EXP 166
113451: PUSH
113452: LD_EXP 166
113456: PPUSH
113457: LD_VAR 0 1
113461: PPUSH
113462: LD_EXP 166
113466: PUSH
113467: LD_VAR 0 1
113471: ARRAY
113472: PPUSH
113473: LD_EXP 166
113477: PUSH
113478: LD_VAR 0 1
113482: ARRAY
113483: PUSH
113484: LD_INT 1
113486: PLUS
113487: PPUSH
113488: LD_VAR 0 5
113492: PUSH
113493: LD_INT 1
113495: ARRAY
113496: PUSH
113497: LD_VAR 0 7
113501: PUSH
113502: LD_INT 1
113504: ARRAY
113505: PUSH
113506: LD_VAR 0 7
113510: PUSH
113511: LD_INT 2
113513: ARRAY
113514: PUSH
113515: LD_VAR 0 7
113519: PUSH
113520: LD_INT 3
113522: ARRAY
113523: PUSH
113524: EMPTY
113525: LIST
113526: LIST
113527: LIST
113528: LIST
113529: PPUSH
113530: CALL_OW 2
113534: PPUSH
113535: CALL_OW 1
113539: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
113540: LD_ADDR_VAR 0 5
113544: PUSH
113545: LD_VAR 0 5
113549: PPUSH
113550: LD_INT 1
113552: PPUSH
113553: CALL_OW 3
113557: ST_TO_ADDR
// if not ext_list then
113558: LD_VAR 0 5
113562: NOT
113563: IFFALSE 113569
// exit ;
113565: POP
113566: POP
113567: GO 113573
// end ;
113569: GO 113444
113571: POP
113572: POP
// end ;
113573: LD_VAR 0 6
113577: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
113578: LD_INT 0
113580: PPUSH
// if not mc_bases or not base or not weapon_list then
113581: LD_EXP 161
113585: NOT
113586: PUSH
113587: LD_VAR 0 1
113591: NOT
113592: OR
113593: PUSH
113594: LD_VAR 0 2
113598: NOT
113599: OR
113600: IFFALSE 113604
// exit ;
113602: GO 113629
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
113604: LD_ADDR_EXP 200
113608: PUSH
113609: LD_EXP 200
113613: PPUSH
113614: LD_VAR 0 1
113618: PPUSH
113619: LD_VAR 0 2
113623: PPUSH
113624: CALL_OW 1
113628: ST_TO_ADDR
// end ;
113629: LD_VAR 0 3
113633: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
113634: LD_INT 0
113636: PPUSH
// if not mc_bases or not base or not tech_list then
113637: LD_EXP 161
113641: NOT
113642: PUSH
113643: LD_VAR 0 1
113647: NOT
113648: OR
113649: PUSH
113650: LD_VAR 0 2
113654: NOT
113655: OR
113656: IFFALSE 113660
// exit ;
113658: GO 113685
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
113660: LD_ADDR_EXP 188
113664: PUSH
113665: LD_EXP 188
113669: PPUSH
113670: LD_VAR 0 1
113674: PPUSH
113675: LD_VAR 0 2
113679: PPUSH
113680: CALL_OW 1
113684: ST_TO_ADDR
// end ;
113685: LD_VAR 0 3
113689: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
113690: LD_INT 0
113692: PPUSH
// if not mc_bases or not parking_area or not base then
113693: LD_EXP 161
113697: NOT
113698: PUSH
113699: LD_VAR 0 2
113703: NOT
113704: OR
113705: PUSH
113706: LD_VAR 0 1
113710: NOT
113711: OR
113712: IFFALSE 113716
// exit ;
113714: GO 113741
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
113716: LD_ADDR_EXP 185
113720: PUSH
113721: LD_EXP 185
113725: PPUSH
113726: LD_VAR 0 1
113730: PPUSH
113731: LD_VAR 0 2
113735: PPUSH
113736: CALL_OW 1
113740: ST_TO_ADDR
// end ;
113741: LD_VAR 0 3
113745: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
113746: LD_INT 0
113748: PPUSH
// if not mc_bases or not base or not scan_area then
113749: LD_EXP 161
113753: NOT
113754: PUSH
113755: LD_VAR 0 1
113759: NOT
113760: OR
113761: PUSH
113762: LD_VAR 0 2
113766: NOT
113767: OR
113768: IFFALSE 113772
// exit ;
113770: GO 113797
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
113772: LD_ADDR_EXP 186
113776: PUSH
113777: LD_EXP 186
113781: PPUSH
113782: LD_VAR 0 1
113786: PPUSH
113787: LD_VAR 0 2
113791: PPUSH
113792: CALL_OW 1
113796: ST_TO_ADDR
// end ;
113797: LD_VAR 0 3
113801: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
113802: LD_INT 0
113804: PPUSH
113805: PPUSH
// if not mc_bases or not base then
113806: LD_EXP 161
113810: NOT
113811: PUSH
113812: LD_VAR 0 1
113816: NOT
113817: OR
113818: IFFALSE 113822
// exit ;
113820: GO 113886
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
113822: LD_ADDR_VAR 0 3
113826: PUSH
113827: LD_INT 1
113829: PUSH
113830: LD_INT 2
113832: PUSH
113833: LD_INT 3
113835: PUSH
113836: LD_INT 4
113838: PUSH
113839: LD_INT 11
113841: PUSH
113842: EMPTY
113843: LIST
113844: LIST
113845: LIST
113846: LIST
113847: LIST
113848: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
113849: LD_ADDR_EXP 188
113853: PUSH
113854: LD_EXP 188
113858: PPUSH
113859: LD_VAR 0 1
113863: PPUSH
113864: LD_EXP 188
113868: PUSH
113869: LD_VAR 0 1
113873: ARRAY
113874: PUSH
113875: LD_VAR 0 3
113879: DIFF
113880: PPUSH
113881: CALL_OW 1
113885: ST_TO_ADDR
// end ;
113886: LD_VAR 0 2
113890: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
113891: LD_INT 0
113893: PPUSH
// result := mc_vehicles [ base ] ;
113894: LD_ADDR_VAR 0 3
113898: PUSH
113899: LD_EXP 180
113903: PUSH
113904: LD_VAR 0 1
113908: ARRAY
113909: ST_TO_ADDR
// if onlyCombat then
113910: LD_VAR 0 2
113914: IFFALSE 114086
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
113916: LD_ADDR_VAR 0 3
113920: PUSH
113921: LD_VAR 0 3
113925: PUSH
113926: LD_VAR 0 3
113930: PPUSH
113931: LD_INT 2
113933: PUSH
113934: LD_INT 34
113936: PUSH
113937: LD_INT 12
113939: PUSH
113940: EMPTY
113941: LIST
113942: LIST
113943: PUSH
113944: LD_INT 34
113946: PUSH
113947: LD_INT 51
113949: PUSH
113950: EMPTY
113951: LIST
113952: LIST
113953: PUSH
113954: LD_INT 34
113956: PUSH
113957: LD_INT 89
113959: PUSH
113960: EMPTY
113961: LIST
113962: LIST
113963: PUSH
113964: LD_INT 34
113966: PUSH
113967: LD_INT 32
113969: PUSH
113970: EMPTY
113971: LIST
113972: LIST
113973: PUSH
113974: LD_INT 34
113976: PUSH
113977: LD_INT 13
113979: PUSH
113980: EMPTY
113981: LIST
113982: LIST
113983: PUSH
113984: LD_INT 34
113986: PUSH
113987: LD_INT 52
113989: PUSH
113990: EMPTY
113991: LIST
113992: LIST
113993: PUSH
113994: LD_INT 34
113996: PUSH
113997: LD_INT 88
113999: PUSH
114000: EMPTY
114001: LIST
114002: LIST
114003: PUSH
114004: LD_INT 34
114006: PUSH
114007: LD_INT 14
114009: PUSH
114010: EMPTY
114011: LIST
114012: LIST
114013: PUSH
114014: LD_INT 34
114016: PUSH
114017: LD_INT 53
114019: PUSH
114020: EMPTY
114021: LIST
114022: LIST
114023: PUSH
114024: LD_INT 34
114026: PUSH
114027: LD_INT 98
114029: PUSH
114030: EMPTY
114031: LIST
114032: LIST
114033: PUSH
114034: LD_INT 34
114036: PUSH
114037: LD_INT 31
114039: PUSH
114040: EMPTY
114041: LIST
114042: LIST
114043: PUSH
114044: LD_INT 34
114046: PUSH
114047: LD_INT 48
114049: PUSH
114050: EMPTY
114051: LIST
114052: LIST
114053: PUSH
114054: LD_INT 34
114056: PUSH
114057: LD_INT 8
114059: PUSH
114060: EMPTY
114061: LIST
114062: LIST
114063: PUSH
114064: EMPTY
114065: LIST
114066: LIST
114067: LIST
114068: LIST
114069: LIST
114070: LIST
114071: LIST
114072: LIST
114073: LIST
114074: LIST
114075: LIST
114076: LIST
114077: LIST
114078: LIST
114079: PPUSH
114080: CALL_OW 72
114084: DIFF
114085: ST_TO_ADDR
// end ; end_of_file
114086: LD_VAR 0 3
114090: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
114091: LD_INT 0
114093: PPUSH
114094: PPUSH
114095: PPUSH
// if not mc_bases or not skirmish then
114096: LD_EXP 161
114100: NOT
114101: PUSH
114102: LD_EXP 159
114106: NOT
114107: OR
114108: IFFALSE 114112
// exit ;
114110: GO 114277
// for i = 1 to mc_bases do
114112: LD_ADDR_VAR 0 4
114116: PUSH
114117: DOUBLE
114118: LD_INT 1
114120: DEC
114121: ST_TO_ADDR
114122: LD_EXP 161
114126: PUSH
114127: FOR_TO
114128: IFFALSE 114275
// begin if sci in mc_bases [ i ] then
114130: LD_VAR 0 2
114134: PUSH
114135: LD_EXP 161
114139: PUSH
114140: LD_VAR 0 4
114144: ARRAY
114145: IN
114146: IFFALSE 114273
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
114148: LD_ADDR_EXP 190
114152: PUSH
114153: LD_EXP 190
114157: PPUSH
114158: LD_VAR 0 4
114162: PUSH
114163: LD_EXP 190
114167: PUSH
114168: LD_VAR 0 4
114172: ARRAY
114173: PUSH
114174: LD_INT 1
114176: PLUS
114177: PUSH
114178: EMPTY
114179: LIST
114180: LIST
114181: PPUSH
114182: LD_VAR 0 1
114186: PPUSH
114187: CALL 24361 0 3
114191: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
114192: LD_ADDR_VAR 0 5
114196: PUSH
114197: LD_EXP 161
114201: PUSH
114202: LD_VAR 0 4
114206: ARRAY
114207: PPUSH
114208: LD_INT 2
114210: PUSH
114211: LD_INT 30
114213: PUSH
114214: LD_INT 0
114216: PUSH
114217: EMPTY
114218: LIST
114219: LIST
114220: PUSH
114221: LD_INT 30
114223: PUSH
114224: LD_INT 1
114226: PUSH
114227: EMPTY
114228: LIST
114229: LIST
114230: PUSH
114231: EMPTY
114232: LIST
114233: LIST
114234: LIST
114235: PPUSH
114236: CALL_OW 72
114240: PPUSH
114241: LD_VAR 0 1
114245: PPUSH
114246: CALL_OW 74
114250: ST_TO_ADDR
// if tmp then
114251: LD_VAR 0 5
114255: IFFALSE 114271
// ComStandNearbyBuilding ( ape , tmp ) ;
114257: LD_VAR 0 1
114261: PPUSH
114262: LD_VAR 0 5
114266: PPUSH
114267: CALL 20788 0 2
// break ;
114271: GO 114275
// end ; end ;
114273: GO 114127
114275: POP
114276: POP
// end ;
114277: LD_VAR 0 3
114281: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
114282: LD_INT 0
114284: PPUSH
114285: PPUSH
114286: PPUSH
// if not mc_bases or not skirmish then
114287: LD_EXP 161
114291: NOT
114292: PUSH
114293: LD_EXP 159
114297: NOT
114298: OR
114299: IFFALSE 114303
// exit ;
114301: GO 114392
// for i = 1 to mc_bases do
114303: LD_ADDR_VAR 0 4
114307: PUSH
114308: DOUBLE
114309: LD_INT 1
114311: DEC
114312: ST_TO_ADDR
114313: LD_EXP 161
114317: PUSH
114318: FOR_TO
114319: IFFALSE 114390
// begin if building in mc_busy_turret_list [ i ] then
114321: LD_VAR 0 1
114325: PUSH
114326: LD_EXP 171
114330: PUSH
114331: LD_VAR 0 4
114335: ARRAY
114336: IN
114337: IFFALSE 114388
// begin tmp := mc_busy_turret_list [ i ] diff building ;
114339: LD_ADDR_VAR 0 5
114343: PUSH
114344: LD_EXP 171
114348: PUSH
114349: LD_VAR 0 4
114353: ARRAY
114354: PUSH
114355: LD_VAR 0 1
114359: DIFF
114360: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
114361: LD_ADDR_EXP 171
114365: PUSH
114366: LD_EXP 171
114370: PPUSH
114371: LD_VAR 0 4
114375: PPUSH
114376: LD_VAR 0 5
114380: PPUSH
114381: CALL_OW 1
114385: ST_TO_ADDR
// break ;
114386: GO 114390
// end ; end ;
114388: GO 114318
114390: POP
114391: POP
// end ;
114392: LD_VAR 0 3
114396: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
114397: LD_INT 0
114399: PPUSH
114400: PPUSH
114401: PPUSH
// if not mc_bases or not skirmish then
114402: LD_EXP 161
114406: NOT
114407: PUSH
114408: LD_EXP 159
114412: NOT
114413: OR
114414: IFFALSE 114418
// exit ;
114416: GO 114617
// for i = 1 to mc_bases do
114418: LD_ADDR_VAR 0 5
114422: PUSH
114423: DOUBLE
114424: LD_INT 1
114426: DEC
114427: ST_TO_ADDR
114428: LD_EXP 161
114432: PUSH
114433: FOR_TO
114434: IFFALSE 114615
// if building in mc_bases [ i ] then
114436: LD_VAR 0 1
114440: PUSH
114441: LD_EXP 161
114445: PUSH
114446: LD_VAR 0 5
114450: ARRAY
114451: IN
114452: IFFALSE 114613
// begin tmp := mc_bases [ i ] diff building ;
114454: LD_ADDR_VAR 0 6
114458: PUSH
114459: LD_EXP 161
114463: PUSH
114464: LD_VAR 0 5
114468: ARRAY
114469: PUSH
114470: LD_VAR 0 1
114474: DIFF
114475: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
114476: LD_ADDR_EXP 161
114480: PUSH
114481: LD_EXP 161
114485: PPUSH
114486: LD_VAR 0 5
114490: PPUSH
114491: LD_VAR 0 6
114495: PPUSH
114496: CALL_OW 1
114500: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
114501: LD_VAR 0 1
114505: PUSH
114506: LD_EXP 169
114510: PUSH
114511: LD_VAR 0 5
114515: ARRAY
114516: IN
114517: IFFALSE 114556
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
114519: LD_ADDR_EXP 169
114523: PUSH
114524: LD_EXP 169
114528: PPUSH
114529: LD_VAR 0 5
114533: PPUSH
114534: LD_EXP 169
114538: PUSH
114539: LD_VAR 0 5
114543: ARRAY
114544: PUSH
114545: LD_VAR 0 1
114549: DIFF
114550: PPUSH
114551: CALL_OW 1
114555: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
114556: LD_VAR 0 1
114560: PUSH
114561: LD_EXP 170
114565: PUSH
114566: LD_VAR 0 5
114570: ARRAY
114571: IN
114572: IFFALSE 114611
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
114574: LD_ADDR_EXP 170
114578: PUSH
114579: LD_EXP 170
114583: PPUSH
114584: LD_VAR 0 5
114588: PPUSH
114589: LD_EXP 170
114593: PUSH
114594: LD_VAR 0 5
114598: ARRAY
114599: PUSH
114600: LD_VAR 0 1
114604: DIFF
114605: PPUSH
114606: CALL_OW 1
114610: ST_TO_ADDR
// break ;
114611: GO 114615
// end ;
114613: GO 114433
114615: POP
114616: POP
// end ;
114617: LD_VAR 0 4
114621: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
114622: LD_INT 0
114624: PPUSH
114625: PPUSH
114626: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
114627: LD_EXP 161
114631: NOT
114632: PUSH
114633: LD_EXP 159
114637: NOT
114638: OR
114639: PUSH
114640: LD_VAR 0 3
114644: PUSH
114645: LD_EXP 187
114649: IN
114650: NOT
114651: OR
114652: IFFALSE 114656
// exit ;
114654: GO 114779
// for i = 1 to mc_vehicles do
114656: LD_ADDR_VAR 0 6
114660: PUSH
114661: DOUBLE
114662: LD_INT 1
114664: DEC
114665: ST_TO_ADDR
114666: LD_EXP 180
114670: PUSH
114671: FOR_TO
114672: IFFALSE 114777
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
114674: LD_VAR 0 2
114678: PUSH
114679: LD_EXP 180
114683: PUSH
114684: LD_VAR 0 6
114688: ARRAY
114689: IN
114690: PUSH
114691: LD_VAR 0 1
114695: PUSH
114696: LD_EXP 180
114700: PUSH
114701: LD_VAR 0 6
114705: ARRAY
114706: IN
114707: OR
114708: IFFALSE 114775
// begin tmp := mc_vehicles [ i ] diff old ;
114710: LD_ADDR_VAR 0 7
114714: PUSH
114715: LD_EXP 180
114719: PUSH
114720: LD_VAR 0 6
114724: ARRAY
114725: PUSH
114726: LD_VAR 0 2
114730: DIFF
114731: ST_TO_ADDR
// tmp := tmp diff new ;
114732: LD_ADDR_VAR 0 7
114736: PUSH
114737: LD_VAR 0 7
114741: PUSH
114742: LD_VAR 0 1
114746: DIFF
114747: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
114748: LD_ADDR_EXP 180
114752: PUSH
114753: LD_EXP 180
114757: PPUSH
114758: LD_VAR 0 6
114762: PPUSH
114763: LD_VAR 0 7
114767: PPUSH
114768: CALL_OW 1
114772: ST_TO_ADDR
// break ;
114773: GO 114777
// end ;
114775: GO 114671
114777: POP
114778: POP
// end ;
114779: LD_VAR 0 5
114783: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
114784: LD_INT 0
114786: PPUSH
114787: PPUSH
114788: PPUSH
114789: PPUSH
// if not mc_bases or not skirmish then
114790: LD_EXP 161
114794: NOT
114795: PUSH
114796: LD_EXP 159
114800: NOT
114801: OR
114802: IFFALSE 114806
// exit ;
114804: GO 115188
// side := GetSide ( vehicle ) ;
114806: LD_ADDR_VAR 0 5
114810: PUSH
114811: LD_VAR 0 1
114815: PPUSH
114816: CALL_OW 255
114820: ST_TO_ADDR
// for i = 1 to mc_bases do
114821: LD_ADDR_VAR 0 4
114825: PUSH
114826: DOUBLE
114827: LD_INT 1
114829: DEC
114830: ST_TO_ADDR
114831: LD_EXP 161
114835: PUSH
114836: FOR_TO
114837: IFFALSE 115186
// begin if factory in mc_bases [ i ] then
114839: LD_VAR 0 2
114843: PUSH
114844: LD_EXP 161
114848: PUSH
114849: LD_VAR 0 4
114853: ARRAY
114854: IN
114855: IFFALSE 115184
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
114857: LD_EXP 183
114861: PUSH
114862: LD_VAR 0 4
114866: ARRAY
114867: PUSH
114868: LD_EXP 172
114872: PUSH
114873: LD_VAR 0 4
114877: ARRAY
114878: LESS
114879: PUSH
114880: LD_VAR 0 1
114884: PPUSH
114885: CALL_OW 264
114889: PUSH
114890: LD_INT 31
114892: PUSH
114893: LD_INT 32
114895: PUSH
114896: LD_INT 51
114898: PUSH
114899: LD_INT 89
114901: PUSH
114902: LD_INT 12
114904: PUSH
114905: LD_INT 30
114907: PUSH
114908: LD_INT 98
114910: PUSH
114911: LD_INT 11
114913: PUSH
114914: LD_INT 53
114916: PUSH
114917: LD_INT 14
114919: PUSH
114920: LD_INT 91
114922: PUSH
114923: LD_INT 29
114925: PUSH
114926: LD_INT 99
114928: PUSH
114929: LD_INT 13
114931: PUSH
114932: LD_INT 52
114934: PUSH
114935: LD_INT 88
114937: PUSH
114938: LD_INT 48
114940: PUSH
114941: LD_INT 8
114943: PUSH
114944: EMPTY
114945: LIST
114946: LIST
114947: LIST
114948: LIST
114949: LIST
114950: LIST
114951: LIST
114952: LIST
114953: LIST
114954: LIST
114955: LIST
114956: LIST
114957: LIST
114958: LIST
114959: LIST
114960: LIST
114961: LIST
114962: LIST
114963: IN
114964: NOT
114965: AND
114966: IFFALSE 115014
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
114968: LD_ADDR_EXP 183
114972: PUSH
114973: LD_EXP 183
114977: PPUSH
114978: LD_VAR 0 4
114982: PUSH
114983: LD_EXP 183
114987: PUSH
114988: LD_VAR 0 4
114992: ARRAY
114993: PUSH
114994: LD_INT 1
114996: PLUS
114997: PUSH
114998: EMPTY
114999: LIST
115000: LIST
115001: PPUSH
115002: LD_VAR 0 1
115006: PPUSH
115007: CALL 24361 0 3
115011: ST_TO_ADDR
115012: GO 115058
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
115014: LD_ADDR_EXP 180
115018: PUSH
115019: LD_EXP 180
115023: PPUSH
115024: LD_VAR 0 4
115028: PUSH
115029: LD_EXP 180
115033: PUSH
115034: LD_VAR 0 4
115038: ARRAY
115039: PUSH
115040: LD_INT 1
115042: PLUS
115043: PUSH
115044: EMPTY
115045: LIST
115046: LIST
115047: PPUSH
115048: LD_VAR 0 1
115052: PPUSH
115053: CALL 24361 0 3
115057: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
115058: LD_VAR 0 1
115062: PPUSH
115063: CALL_OW 263
115067: PUSH
115068: LD_INT 2
115070: EQUAL
115071: IFFALSE 115100
// begin repeat wait ( 0 0$3 ) ;
115073: LD_INT 105
115075: PPUSH
115076: CALL_OW 67
// Connect ( vehicle ) ;
115080: LD_VAR 0 1
115084: PPUSH
115085: CALL 27330 0 1
// until IsControledBy ( vehicle ) ;
115089: LD_VAR 0 1
115093: PPUSH
115094: CALL_OW 312
115098: IFFALSE 115073
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
115100: LD_VAR 0 1
115104: PPUSH
115105: LD_EXP 185
115109: PUSH
115110: LD_VAR 0 4
115114: ARRAY
115115: PPUSH
115116: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
115120: LD_VAR 0 1
115124: PPUSH
115125: CALL_OW 263
115129: PUSH
115130: LD_INT 1
115132: NONEQUAL
115133: IFFALSE 115137
// break ;
115135: GO 115186
// repeat wait ( 0 0$1 ) ;
115137: LD_INT 35
115139: PPUSH
115140: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
115144: LD_VAR 0 1
115148: PPUSH
115149: LD_EXP 185
115153: PUSH
115154: LD_VAR 0 4
115158: ARRAY
115159: PPUSH
115160: CALL_OW 308
115164: IFFALSE 115137
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
115166: LD_VAR 0 1
115170: PPUSH
115171: CALL_OW 311
115175: PPUSH
115176: CALL_OW 121
// exit ;
115180: POP
115181: POP
115182: GO 115188
// end ; end ;
115184: GO 114836
115186: POP
115187: POP
// end ;
115188: LD_VAR 0 3
115192: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
115193: LD_INT 0
115195: PPUSH
115196: PPUSH
115197: PPUSH
115198: PPUSH
// if not mc_bases or not skirmish then
115199: LD_EXP 161
115203: NOT
115204: PUSH
115205: LD_EXP 159
115209: NOT
115210: OR
115211: IFFALSE 115215
// exit ;
115213: GO 115568
// repeat wait ( 0 0$1 ) ;
115215: LD_INT 35
115217: PPUSH
115218: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
115222: LD_VAR 0 2
115226: PPUSH
115227: LD_VAR 0 3
115231: PPUSH
115232: CALL_OW 284
115236: IFFALSE 115215
// if GetResourceTypeXY ( x , y ) = mat_artefact then
115238: LD_VAR 0 2
115242: PPUSH
115243: LD_VAR 0 3
115247: PPUSH
115248: CALL_OW 283
115252: PUSH
115253: LD_INT 4
115255: EQUAL
115256: IFFALSE 115260
// exit ;
115258: GO 115568
// for i = 1 to mc_bases do
115260: LD_ADDR_VAR 0 7
115264: PUSH
115265: DOUBLE
115266: LD_INT 1
115268: DEC
115269: ST_TO_ADDR
115270: LD_EXP 161
115274: PUSH
115275: FOR_TO
115276: IFFALSE 115566
// begin if mc_crates_area [ i ] then
115278: LD_EXP 179
115282: PUSH
115283: LD_VAR 0 7
115287: ARRAY
115288: IFFALSE 115399
// for j in mc_crates_area [ i ] do
115290: LD_ADDR_VAR 0 8
115294: PUSH
115295: LD_EXP 179
115299: PUSH
115300: LD_VAR 0 7
115304: ARRAY
115305: PUSH
115306: FOR_IN
115307: IFFALSE 115397
// if InArea ( x , y , j ) then
115309: LD_VAR 0 2
115313: PPUSH
115314: LD_VAR 0 3
115318: PPUSH
115319: LD_VAR 0 8
115323: PPUSH
115324: CALL_OW 309
115328: IFFALSE 115395
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
115330: LD_ADDR_EXP 177
115334: PUSH
115335: LD_EXP 177
115339: PPUSH
115340: LD_VAR 0 7
115344: PUSH
115345: LD_EXP 177
115349: PUSH
115350: LD_VAR 0 7
115354: ARRAY
115355: PUSH
115356: LD_INT 1
115358: PLUS
115359: PUSH
115360: EMPTY
115361: LIST
115362: LIST
115363: PPUSH
115364: LD_VAR 0 4
115368: PUSH
115369: LD_VAR 0 2
115373: PUSH
115374: LD_VAR 0 3
115378: PUSH
115379: EMPTY
115380: LIST
115381: LIST
115382: LIST
115383: PPUSH
115384: CALL 24361 0 3
115388: ST_TO_ADDR
// exit ;
115389: POP
115390: POP
115391: POP
115392: POP
115393: GO 115568
// end ;
115395: GO 115306
115397: POP
115398: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
115399: LD_ADDR_VAR 0 9
115403: PUSH
115404: LD_EXP 161
115408: PUSH
115409: LD_VAR 0 7
115413: ARRAY
115414: PPUSH
115415: LD_INT 2
115417: PUSH
115418: LD_INT 30
115420: PUSH
115421: LD_INT 0
115423: PUSH
115424: EMPTY
115425: LIST
115426: LIST
115427: PUSH
115428: LD_INT 30
115430: PUSH
115431: LD_INT 1
115433: PUSH
115434: EMPTY
115435: LIST
115436: LIST
115437: PUSH
115438: EMPTY
115439: LIST
115440: LIST
115441: LIST
115442: PPUSH
115443: CALL_OW 72
115447: ST_TO_ADDR
// if not depot then
115448: LD_VAR 0 9
115452: NOT
115453: IFFALSE 115457
// continue ;
115455: GO 115275
// for j in depot do
115457: LD_ADDR_VAR 0 8
115461: PUSH
115462: LD_VAR 0 9
115466: PUSH
115467: FOR_IN
115468: IFFALSE 115562
// if GetDistUnitXY ( j , x , y ) < 30 then
115470: LD_VAR 0 8
115474: PPUSH
115475: LD_VAR 0 2
115479: PPUSH
115480: LD_VAR 0 3
115484: PPUSH
115485: CALL_OW 297
115489: PUSH
115490: LD_INT 30
115492: LESS
115493: IFFALSE 115560
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
115495: LD_ADDR_EXP 177
115499: PUSH
115500: LD_EXP 177
115504: PPUSH
115505: LD_VAR 0 7
115509: PUSH
115510: LD_EXP 177
115514: PUSH
115515: LD_VAR 0 7
115519: ARRAY
115520: PUSH
115521: LD_INT 1
115523: PLUS
115524: PUSH
115525: EMPTY
115526: LIST
115527: LIST
115528: PPUSH
115529: LD_VAR 0 4
115533: PUSH
115534: LD_VAR 0 2
115538: PUSH
115539: LD_VAR 0 3
115543: PUSH
115544: EMPTY
115545: LIST
115546: LIST
115547: LIST
115548: PPUSH
115549: CALL 24361 0 3
115553: ST_TO_ADDR
// exit ;
115554: POP
115555: POP
115556: POP
115557: POP
115558: GO 115568
// end ;
115560: GO 115467
115562: POP
115563: POP
// end ;
115564: GO 115275
115566: POP
115567: POP
// end ;
115568: LD_VAR 0 6
115572: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
115573: LD_INT 0
115575: PPUSH
115576: PPUSH
115577: PPUSH
115578: PPUSH
// if not mc_bases or not skirmish then
115579: LD_EXP 161
115583: NOT
115584: PUSH
115585: LD_EXP 159
115589: NOT
115590: OR
115591: IFFALSE 115595
// exit ;
115593: GO 115872
// side := GetSide ( lab ) ;
115595: LD_ADDR_VAR 0 4
115599: PUSH
115600: LD_VAR 0 2
115604: PPUSH
115605: CALL_OW 255
115609: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
115610: LD_VAR 0 4
115614: PUSH
115615: LD_EXP 187
115619: IN
115620: NOT
115621: PUSH
115622: LD_EXP 188
115626: NOT
115627: OR
115628: PUSH
115629: LD_EXP 161
115633: NOT
115634: OR
115635: IFFALSE 115639
// exit ;
115637: GO 115872
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
115639: LD_ADDR_EXP 188
115643: PUSH
115644: LD_EXP 188
115648: PPUSH
115649: LD_VAR 0 4
115653: PPUSH
115654: LD_EXP 188
115658: PUSH
115659: LD_VAR 0 4
115663: ARRAY
115664: PUSH
115665: LD_VAR 0 1
115669: DIFF
115670: PPUSH
115671: CALL_OW 1
115675: ST_TO_ADDR
// for i = 1 to mc_bases do
115676: LD_ADDR_VAR 0 5
115680: PUSH
115681: DOUBLE
115682: LD_INT 1
115684: DEC
115685: ST_TO_ADDR
115686: LD_EXP 161
115690: PUSH
115691: FOR_TO
115692: IFFALSE 115870
// begin if lab in mc_bases [ i ] then
115694: LD_VAR 0 2
115698: PUSH
115699: LD_EXP 161
115703: PUSH
115704: LD_VAR 0 5
115708: ARRAY
115709: IN
115710: IFFALSE 115868
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
115712: LD_VAR 0 1
115716: PUSH
115717: LD_INT 11
115719: PUSH
115720: LD_INT 4
115722: PUSH
115723: LD_INT 3
115725: PUSH
115726: LD_INT 2
115728: PUSH
115729: EMPTY
115730: LIST
115731: LIST
115732: LIST
115733: LIST
115734: IN
115735: PUSH
115736: LD_EXP 191
115740: PUSH
115741: LD_VAR 0 5
115745: ARRAY
115746: AND
115747: IFFALSE 115868
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
115749: LD_ADDR_VAR 0 6
115753: PUSH
115754: LD_EXP 191
115758: PUSH
115759: LD_VAR 0 5
115763: ARRAY
115764: PUSH
115765: LD_INT 1
115767: ARRAY
115768: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
115769: LD_ADDR_EXP 191
115773: PUSH
115774: LD_EXP 191
115778: PPUSH
115779: LD_VAR 0 5
115783: PPUSH
115784: EMPTY
115785: PPUSH
115786: CALL_OW 1
115790: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
115791: LD_VAR 0 6
115795: PPUSH
115796: LD_INT 0
115798: PPUSH
115799: CALL_OW 109
// ComExitBuilding ( tmp ) ;
115803: LD_VAR 0 6
115807: PPUSH
115808: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
115812: LD_ADDR_EXP 190
115816: PUSH
115817: LD_EXP 190
115821: PPUSH
115822: LD_VAR 0 5
115826: PPUSH
115827: LD_EXP 190
115831: PUSH
115832: LD_VAR 0 5
115836: ARRAY
115837: PPUSH
115838: LD_INT 1
115840: PPUSH
115841: LD_VAR 0 6
115845: PPUSH
115846: CALL_OW 2
115850: PPUSH
115851: CALL_OW 1
115855: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
115856: LD_VAR 0 5
115860: PPUSH
115861: LD_INT 112
115863: PPUSH
115864: CALL 92358 0 2
// end ; end ; end ;
115868: GO 115691
115870: POP
115871: POP
// end ;
115872: LD_VAR 0 3
115876: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
115877: LD_INT 0
115879: PPUSH
115880: PPUSH
115881: PPUSH
115882: PPUSH
115883: PPUSH
115884: PPUSH
115885: PPUSH
115886: PPUSH
// if not mc_bases or not skirmish then
115887: LD_EXP 161
115891: NOT
115892: PUSH
115893: LD_EXP 159
115897: NOT
115898: OR
115899: IFFALSE 115903
// exit ;
115901: GO 117272
// for i = 1 to mc_bases do
115903: LD_ADDR_VAR 0 3
115907: PUSH
115908: DOUBLE
115909: LD_INT 1
115911: DEC
115912: ST_TO_ADDR
115913: LD_EXP 161
115917: PUSH
115918: FOR_TO
115919: IFFALSE 117270
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
115921: LD_VAR 0 1
115925: PUSH
115926: LD_EXP 161
115930: PUSH
115931: LD_VAR 0 3
115935: ARRAY
115936: IN
115937: PUSH
115938: LD_VAR 0 1
115942: PUSH
115943: LD_EXP 168
115947: PUSH
115948: LD_VAR 0 3
115952: ARRAY
115953: IN
115954: OR
115955: PUSH
115956: LD_VAR 0 1
115960: PUSH
115961: LD_EXP 183
115965: PUSH
115966: LD_VAR 0 3
115970: ARRAY
115971: IN
115972: OR
115973: PUSH
115974: LD_VAR 0 1
115978: PUSH
115979: LD_EXP 180
115983: PUSH
115984: LD_VAR 0 3
115988: ARRAY
115989: IN
115990: OR
115991: PUSH
115992: LD_VAR 0 1
115996: PUSH
115997: LD_EXP 190
116001: PUSH
116002: LD_VAR 0 3
116006: ARRAY
116007: IN
116008: OR
116009: PUSH
116010: LD_VAR 0 1
116014: PUSH
116015: LD_EXP 191
116019: PUSH
116020: LD_VAR 0 3
116024: ARRAY
116025: IN
116026: OR
116027: IFFALSE 117268
// begin if un in mc_ape [ i ] then
116029: LD_VAR 0 1
116033: PUSH
116034: LD_EXP 190
116038: PUSH
116039: LD_VAR 0 3
116043: ARRAY
116044: IN
116045: IFFALSE 116084
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
116047: LD_ADDR_EXP 190
116051: PUSH
116052: LD_EXP 190
116056: PPUSH
116057: LD_VAR 0 3
116061: PPUSH
116062: LD_EXP 190
116066: PUSH
116067: LD_VAR 0 3
116071: ARRAY
116072: PUSH
116073: LD_VAR 0 1
116077: DIFF
116078: PPUSH
116079: CALL_OW 1
116083: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
116084: LD_VAR 0 1
116088: PUSH
116089: LD_EXP 191
116093: PUSH
116094: LD_VAR 0 3
116098: ARRAY
116099: IN
116100: IFFALSE 116124
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
116102: LD_ADDR_EXP 191
116106: PUSH
116107: LD_EXP 191
116111: PPUSH
116112: LD_VAR 0 3
116116: PPUSH
116117: EMPTY
116118: PPUSH
116119: CALL_OW 1
116123: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
116124: LD_VAR 0 1
116128: PPUSH
116129: CALL_OW 247
116133: PUSH
116134: LD_INT 2
116136: EQUAL
116137: PUSH
116138: LD_VAR 0 1
116142: PPUSH
116143: CALL_OW 110
116147: PUSH
116148: LD_INT 20
116150: EQUAL
116151: PUSH
116152: LD_VAR 0 1
116156: PUSH
116157: LD_EXP 183
116161: PUSH
116162: LD_VAR 0 3
116166: ARRAY
116167: IN
116168: OR
116169: PUSH
116170: LD_VAR 0 1
116174: PPUSH
116175: CALL_OW 264
116179: PUSH
116180: LD_INT 12
116182: PUSH
116183: LD_INT 51
116185: PUSH
116186: LD_INT 89
116188: PUSH
116189: LD_INT 32
116191: PUSH
116192: LD_INT 13
116194: PUSH
116195: LD_INT 52
116197: PUSH
116198: LD_INT 31
116200: PUSH
116201: EMPTY
116202: LIST
116203: LIST
116204: LIST
116205: LIST
116206: LIST
116207: LIST
116208: LIST
116209: IN
116210: OR
116211: AND
116212: IFFALSE 116520
// begin if un in mc_defender [ i ] then
116214: LD_VAR 0 1
116218: PUSH
116219: LD_EXP 183
116223: PUSH
116224: LD_VAR 0 3
116228: ARRAY
116229: IN
116230: IFFALSE 116269
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
116232: LD_ADDR_EXP 183
116236: PUSH
116237: LD_EXP 183
116241: PPUSH
116242: LD_VAR 0 3
116246: PPUSH
116247: LD_EXP 183
116251: PUSH
116252: LD_VAR 0 3
116256: ARRAY
116257: PUSH
116258: LD_VAR 0 1
116262: DIFF
116263: PPUSH
116264: CALL_OW 1
116268: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
116269: LD_ADDR_VAR 0 8
116273: PUSH
116274: LD_VAR 0 3
116278: PPUSH
116279: LD_INT 3
116281: PPUSH
116282: CALL 112928 0 2
116286: ST_TO_ADDR
// if fac then
116287: LD_VAR 0 8
116291: IFFALSE 116520
// begin for j in fac do
116293: LD_ADDR_VAR 0 4
116297: PUSH
116298: LD_VAR 0 8
116302: PUSH
116303: FOR_IN
116304: IFFALSE 116518
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
116306: LD_ADDR_VAR 0 9
116310: PUSH
116311: LD_VAR 0 8
116315: PPUSH
116316: LD_VAR 0 1
116320: PPUSH
116321: CALL_OW 265
116325: PPUSH
116326: LD_VAR 0 1
116330: PPUSH
116331: CALL_OW 262
116335: PPUSH
116336: LD_VAR 0 1
116340: PPUSH
116341: CALL_OW 263
116345: PPUSH
116346: LD_VAR 0 1
116350: PPUSH
116351: CALL_OW 264
116355: PPUSH
116356: CALL 21859 0 5
116360: ST_TO_ADDR
// if components then
116361: LD_VAR 0 9
116365: IFFALSE 116516
// begin if GetWeapon ( un ) = ar_control_tower then
116367: LD_VAR 0 1
116371: PPUSH
116372: CALL_OW 264
116376: PUSH
116377: LD_INT 31
116379: EQUAL
116380: IFFALSE 116497
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
116382: LD_VAR 0 1
116386: PPUSH
116387: CALL_OW 311
116391: PPUSH
116392: LD_INT 0
116394: PPUSH
116395: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
116399: LD_ADDR_EXP 201
116403: PUSH
116404: LD_EXP 201
116408: PPUSH
116409: LD_VAR 0 3
116413: PPUSH
116414: LD_EXP 201
116418: PUSH
116419: LD_VAR 0 3
116423: ARRAY
116424: PUSH
116425: LD_VAR 0 1
116429: PPUSH
116430: CALL_OW 311
116434: DIFF
116435: PPUSH
116436: CALL_OW 1
116440: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
116441: LD_ADDR_VAR 0 7
116445: PUSH
116446: LD_EXP 182
116450: PUSH
116451: LD_VAR 0 3
116455: ARRAY
116456: PPUSH
116457: LD_INT 1
116459: PPUSH
116460: LD_VAR 0 9
116464: PPUSH
116465: CALL_OW 2
116469: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
116470: LD_ADDR_EXP 182
116474: PUSH
116475: LD_EXP 182
116479: PPUSH
116480: LD_VAR 0 3
116484: PPUSH
116485: LD_VAR 0 7
116489: PPUSH
116490: CALL_OW 1
116494: ST_TO_ADDR
// end else
116495: GO 116514
// MC_InsertProduceList ( i , [ components ] ) ;
116497: LD_VAR 0 3
116501: PPUSH
116502: LD_VAR 0 9
116506: PUSH
116507: EMPTY
116508: LIST
116509: PPUSH
116510: CALL 112473 0 2
// break ;
116514: GO 116518
// end ; end ;
116516: GO 116303
116518: POP
116519: POP
// end ; end ; if GetType ( un ) = unit_building then
116520: LD_VAR 0 1
116524: PPUSH
116525: CALL_OW 247
116529: PUSH
116530: LD_INT 3
116532: EQUAL
116533: IFFALSE 116936
// begin btype := GetBType ( un ) ;
116535: LD_ADDR_VAR 0 5
116539: PUSH
116540: LD_VAR 0 1
116544: PPUSH
116545: CALL_OW 266
116549: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
116550: LD_VAR 0 5
116554: PUSH
116555: LD_INT 29
116557: PUSH
116558: LD_INT 30
116560: PUSH
116561: EMPTY
116562: LIST
116563: LIST
116564: IN
116565: IFFALSE 116638
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
116567: LD_VAR 0 1
116571: PPUSH
116572: CALL_OW 250
116576: PPUSH
116577: LD_VAR 0 1
116581: PPUSH
116582: CALL_OW 251
116586: PPUSH
116587: LD_VAR 0 1
116591: PPUSH
116592: CALL_OW 255
116596: PPUSH
116597: CALL_OW 440
116601: NOT
116602: IFFALSE 116638
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
116604: LD_VAR 0 1
116608: PPUSH
116609: CALL_OW 250
116613: PPUSH
116614: LD_VAR 0 1
116618: PPUSH
116619: CALL_OW 251
116623: PPUSH
116624: LD_VAR 0 1
116628: PPUSH
116629: CALL_OW 255
116633: PPUSH
116634: CALL_OW 441
// end ; if btype = b_warehouse then
116638: LD_VAR 0 5
116642: PUSH
116643: LD_INT 1
116645: EQUAL
116646: IFFALSE 116664
// begin btype := b_depot ;
116648: LD_ADDR_VAR 0 5
116652: PUSH
116653: LD_INT 0
116655: ST_TO_ADDR
// pos := 1 ;
116656: LD_ADDR_VAR 0 6
116660: PUSH
116661: LD_INT 1
116663: ST_TO_ADDR
// end ; if btype = b_factory then
116664: LD_VAR 0 5
116668: PUSH
116669: LD_INT 3
116671: EQUAL
116672: IFFALSE 116690
// begin btype := b_workshop ;
116674: LD_ADDR_VAR 0 5
116678: PUSH
116679: LD_INT 2
116681: ST_TO_ADDR
// pos := 1 ;
116682: LD_ADDR_VAR 0 6
116686: PUSH
116687: LD_INT 1
116689: ST_TO_ADDR
// end ; if btype = b_barracks then
116690: LD_VAR 0 5
116694: PUSH
116695: LD_INT 5
116697: EQUAL
116698: IFFALSE 116708
// btype := b_armoury ;
116700: LD_ADDR_VAR 0 5
116704: PUSH
116705: LD_INT 4
116707: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
116708: LD_VAR 0 5
116712: PUSH
116713: LD_INT 7
116715: PUSH
116716: LD_INT 8
116718: PUSH
116719: EMPTY
116720: LIST
116721: LIST
116722: IN
116723: IFFALSE 116733
// btype := b_lab ;
116725: LD_ADDR_VAR 0 5
116729: PUSH
116730: LD_INT 6
116732: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
116733: LD_ADDR_EXP 166
116737: PUSH
116738: LD_EXP 166
116742: PPUSH
116743: LD_VAR 0 3
116747: PUSH
116748: LD_EXP 166
116752: PUSH
116753: LD_VAR 0 3
116757: ARRAY
116758: PUSH
116759: LD_INT 1
116761: PLUS
116762: PUSH
116763: EMPTY
116764: LIST
116765: LIST
116766: PPUSH
116767: LD_VAR 0 5
116771: PUSH
116772: LD_VAR 0 1
116776: PPUSH
116777: CALL_OW 250
116781: PUSH
116782: LD_VAR 0 1
116786: PPUSH
116787: CALL_OW 251
116791: PUSH
116792: LD_VAR 0 1
116796: PPUSH
116797: CALL_OW 254
116801: PUSH
116802: EMPTY
116803: LIST
116804: LIST
116805: LIST
116806: LIST
116807: PPUSH
116808: CALL 24361 0 3
116812: ST_TO_ADDR
// if pos = 1 then
116813: LD_VAR 0 6
116817: PUSH
116818: LD_INT 1
116820: EQUAL
116821: IFFALSE 116936
// begin tmp := mc_build_list [ i ] ;
116823: LD_ADDR_VAR 0 7
116827: PUSH
116828: LD_EXP 166
116832: PUSH
116833: LD_VAR 0 3
116837: ARRAY
116838: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
116839: LD_VAR 0 7
116843: PPUSH
116844: LD_INT 2
116846: PUSH
116847: LD_INT 30
116849: PUSH
116850: LD_INT 0
116852: PUSH
116853: EMPTY
116854: LIST
116855: LIST
116856: PUSH
116857: LD_INT 30
116859: PUSH
116860: LD_INT 1
116862: PUSH
116863: EMPTY
116864: LIST
116865: LIST
116866: PUSH
116867: EMPTY
116868: LIST
116869: LIST
116870: LIST
116871: PPUSH
116872: CALL_OW 72
116876: IFFALSE 116886
// pos := 2 ;
116878: LD_ADDR_VAR 0 6
116882: PUSH
116883: LD_INT 2
116885: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
116886: LD_ADDR_VAR 0 7
116890: PUSH
116891: LD_VAR 0 7
116895: PPUSH
116896: LD_VAR 0 6
116900: PPUSH
116901: LD_VAR 0 7
116905: PPUSH
116906: CALL 24687 0 3
116910: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
116911: LD_ADDR_EXP 166
116915: PUSH
116916: LD_EXP 166
116920: PPUSH
116921: LD_VAR 0 3
116925: PPUSH
116926: LD_VAR 0 7
116930: PPUSH
116931: CALL_OW 1
116935: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
116936: LD_VAR 0 1
116940: PUSH
116941: LD_EXP 161
116945: PUSH
116946: LD_VAR 0 3
116950: ARRAY
116951: IN
116952: IFFALSE 116991
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
116954: LD_ADDR_EXP 161
116958: PUSH
116959: LD_EXP 161
116963: PPUSH
116964: LD_VAR 0 3
116968: PPUSH
116969: LD_EXP 161
116973: PUSH
116974: LD_VAR 0 3
116978: ARRAY
116979: PUSH
116980: LD_VAR 0 1
116984: DIFF
116985: PPUSH
116986: CALL_OW 1
116990: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
116991: LD_VAR 0 1
116995: PUSH
116996: LD_EXP 168
117000: PUSH
117001: LD_VAR 0 3
117005: ARRAY
117006: IN
117007: IFFALSE 117046
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
117009: LD_ADDR_EXP 168
117013: PUSH
117014: LD_EXP 168
117018: PPUSH
117019: LD_VAR 0 3
117023: PPUSH
117024: LD_EXP 168
117028: PUSH
117029: LD_VAR 0 3
117033: ARRAY
117034: PUSH
117035: LD_VAR 0 1
117039: DIFF
117040: PPUSH
117041: CALL_OW 1
117045: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
117046: LD_VAR 0 1
117050: PUSH
117051: LD_EXP 180
117055: PUSH
117056: LD_VAR 0 3
117060: ARRAY
117061: IN
117062: IFFALSE 117101
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
117064: LD_ADDR_EXP 180
117068: PUSH
117069: LD_EXP 180
117073: PPUSH
117074: LD_VAR 0 3
117078: PPUSH
117079: LD_EXP 180
117083: PUSH
117084: LD_VAR 0 3
117088: ARRAY
117089: PUSH
117090: LD_VAR 0 1
117094: DIFF
117095: PPUSH
117096: CALL_OW 1
117100: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
117101: LD_VAR 0 1
117105: PUSH
117106: LD_EXP 183
117110: PUSH
117111: LD_VAR 0 3
117115: ARRAY
117116: IN
117117: IFFALSE 117156
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
117119: LD_ADDR_EXP 183
117123: PUSH
117124: LD_EXP 183
117128: PPUSH
117129: LD_VAR 0 3
117133: PPUSH
117134: LD_EXP 183
117138: PUSH
117139: LD_VAR 0 3
117143: ARRAY
117144: PUSH
117145: LD_VAR 0 1
117149: DIFF
117150: PPUSH
117151: CALL_OW 1
117155: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
117156: LD_VAR 0 1
117160: PUSH
117161: LD_EXP 170
117165: PUSH
117166: LD_VAR 0 3
117170: ARRAY
117171: IN
117172: IFFALSE 117211
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
117174: LD_ADDR_EXP 170
117178: PUSH
117179: LD_EXP 170
117183: PPUSH
117184: LD_VAR 0 3
117188: PPUSH
117189: LD_EXP 170
117193: PUSH
117194: LD_VAR 0 3
117198: ARRAY
117199: PUSH
117200: LD_VAR 0 1
117204: DIFF
117205: PPUSH
117206: CALL_OW 1
117210: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
117211: LD_VAR 0 1
117215: PUSH
117216: LD_EXP 169
117220: PUSH
117221: LD_VAR 0 3
117225: ARRAY
117226: IN
117227: IFFALSE 117266
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
117229: LD_ADDR_EXP 169
117233: PUSH
117234: LD_EXP 169
117238: PPUSH
117239: LD_VAR 0 3
117243: PPUSH
117244: LD_EXP 169
117248: PUSH
117249: LD_VAR 0 3
117253: ARRAY
117254: PUSH
117255: LD_VAR 0 1
117259: DIFF
117260: PPUSH
117261: CALL_OW 1
117265: ST_TO_ADDR
// end ; break ;
117266: GO 117270
// end ;
117268: GO 115918
117270: POP
117271: POP
// end ;
117272: LD_VAR 0 2
117276: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
117277: LD_INT 0
117279: PPUSH
117280: PPUSH
117281: PPUSH
// if not mc_bases or not skirmish then
117282: LD_EXP 161
117286: NOT
117287: PUSH
117288: LD_EXP 159
117292: NOT
117293: OR
117294: IFFALSE 117298
// exit ;
117296: GO 117513
// for i = 1 to mc_bases do
117298: LD_ADDR_VAR 0 3
117302: PUSH
117303: DOUBLE
117304: LD_INT 1
117306: DEC
117307: ST_TO_ADDR
117308: LD_EXP 161
117312: PUSH
117313: FOR_TO
117314: IFFALSE 117511
// begin if building in mc_construct_list [ i ] then
117316: LD_VAR 0 1
117320: PUSH
117321: LD_EXP 168
117325: PUSH
117326: LD_VAR 0 3
117330: ARRAY
117331: IN
117332: IFFALSE 117509
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
117334: LD_ADDR_EXP 168
117338: PUSH
117339: LD_EXP 168
117343: PPUSH
117344: LD_VAR 0 3
117348: PPUSH
117349: LD_EXP 168
117353: PUSH
117354: LD_VAR 0 3
117358: ARRAY
117359: PUSH
117360: LD_VAR 0 1
117364: DIFF
117365: PPUSH
117366: CALL_OW 1
117370: ST_TO_ADDR
// if building in mc_lab [ i ] then
117371: LD_VAR 0 1
117375: PUSH
117376: LD_EXP 194
117380: PUSH
117381: LD_VAR 0 3
117385: ARRAY
117386: IN
117387: IFFALSE 117442
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
117389: LD_ADDR_EXP 195
117393: PUSH
117394: LD_EXP 195
117398: PPUSH
117399: LD_VAR 0 3
117403: PPUSH
117404: LD_EXP 195
117408: PUSH
117409: LD_VAR 0 3
117413: ARRAY
117414: PPUSH
117415: LD_INT 1
117417: PPUSH
117418: LD_EXP 195
117422: PUSH
117423: LD_VAR 0 3
117427: ARRAY
117428: PPUSH
117429: LD_INT 0
117431: PPUSH
117432: CALL 23779 0 4
117436: PPUSH
117437: CALL_OW 1
117441: ST_TO_ADDR
// if not building in mc_bases [ i ] then
117442: LD_VAR 0 1
117446: PUSH
117447: LD_EXP 161
117451: PUSH
117452: LD_VAR 0 3
117456: ARRAY
117457: IN
117458: NOT
117459: IFFALSE 117505
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
117461: LD_ADDR_EXP 161
117465: PUSH
117466: LD_EXP 161
117470: PPUSH
117471: LD_VAR 0 3
117475: PUSH
117476: LD_EXP 161
117480: PUSH
117481: LD_VAR 0 3
117485: ARRAY
117486: PUSH
117487: LD_INT 1
117489: PLUS
117490: PUSH
117491: EMPTY
117492: LIST
117493: LIST
117494: PPUSH
117495: LD_VAR 0 1
117499: PPUSH
117500: CALL 24361 0 3
117504: ST_TO_ADDR
// exit ;
117505: POP
117506: POP
117507: GO 117513
// end ; end ;
117509: GO 117313
117511: POP
117512: POP
// end ;
117513: LD_VAR 0 2
117517: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
117518: LD_INT 0
117520: PPUSH
117521: PPUSH
117522: PPUSH
117523: PPUSH
117524: PPUSH
117525: PPUSH
117526: PPUSH
// if not mc_bases or not skirmish then
117527: LD_EXP 161
117531: NOT
117532: PUSH
117533: LD_EXP 159
117537: NOT
117538: OR
117539: IFFALSE 117543
// exit ;
117541: GO 118204
// for i = 1 to mc_bases do
117543: LD_ADDR_VAR 0 3
117547: PUSH
117548: DOUBLE
117549: LD_INT 1
117551: DEC
117552: ST_TO_ADDR
117553: LD_EXP 161
117557: PUSH
117558: FOR_TO
117559: IFFALSE 118202
// begin if building in mc_construct_list [ i ] then
117561: LD_VAR 0 1
117565: PUSH
117566: LD_EXP 168
117570: PUSH
117571: LD_VAR 0 3
117575: ARRAY
117576: IN
117577: IFFALSE 118200
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
117579: LD_ADDR_EXP 168
117583: PUSH
117584: LD_EXP 168
117588: PPUSH
117589: LD_VAR 0 3
117593: PPUSH
117594: LD_EXP 168
117598: PUSH
117599: LD_VAR 0 3
117603: ARRAY
117604: PUSH
117605: LD_VAR 0 1
117609: DIFF
117610: PPUSH
117611: CALL_OW 1
117615: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
117616: LD_ADDR_EXP 161
117620: PUSH
117621: LD_EXP 161
117625: PPUSH
117626: LD_VAR 0 3
117630: PUSH
117631: LD_EXP 161
117635: PUSH
117636: LD_VAR 0 3
117640: ARRAY
117641: PUSH
117642: LD_INT 1
117644: PLUS
117645: PUSH
117646: EMPTY
117647: LIST
117648: LIST
117649: PPUSH
117650: LD_VAR 0 1
117654: PPUSH
117655: CALL 24361 0 3
117659: ST_TO_ADDR
// btype := GetBType ( building ) ;
117660: LD_ADDR_VAR 0 5
117664: PUSH
117665: LD_VAR 0 1
117669: PPUSH
117670: CALL_OW 266
117674: ST_TO_ADDR
// side := GetSide ( building ) ;
117675: LD_ADDR_VAR 0 8
117679: PUSH
117680: LD_VAR 0 1
117684: PPUSH
117685: CALL_OW 255
117689: ST_TO_ADDR
// if btype = b_lab then
117690: LD_VAR 0 5
117694: PUSH
117695: LD_INT 6
117697: EQUAL
117698: IFFALSE 117748
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
117700: LD_ADDR_EXP 194
117704: PUSH
117705: LD_EXP 194
117709: PPUSH
117710: LD_VAR 0 3
117714: PUSH
117715: LD_EXP 194
117719: PUSH
117720: LD_VAR 0 3
117724: ARRAY
117725: PUSH
117726: LD_INT 1
117728: PLUS
117729: PUSH
117730: EMPTY
117731: LIST
117732: LIST
117733: PPUSH
117734: LD_VAR 0 1
117738: PPUSH
117739: CALL 24361 0 3
117743: ST_TO_ADDR
// exit ;
117744: POP
117745: POP
117746: GO 118204
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
117748: LD_VAR 0 5
117752: PUSH
117753: LD_INT 0
117755: PUSH
117756: LD_INT 2
117758: PUSH
117759: LD_INT 4
117761: PUSH
117762: EMPTY
117763: LIST
117764: LIST
117765: LIST
117766: IN
117767: IFFALSE 117891
// begin if btype = b_armoury then
117769: LD_VAR 0 5
117773: PUSH
117774: LD_INT 4
117776: EQUAL
117777: IFFALSE 117787
// btype := b_barracks ;
117779: LD_ADDR_VAR 0 5
117783: PUSH
117784: LD_INT 5
117786: ST_TO_ADDR
// if btype = b_depot then
117787: LD_VAR 0 5
117791: PUSH
117792: LD_INT 0
117794: EQUAL
117795: IFFALSE 117805
// btype := b_warehouse ;
117797: LD_ADDR_VAR 0 5
117801: PUSH
117802: LD_INT 1
117804: ST_TO_ADDR
// if btype = b_workshop then
117805: LD_VAR 0 5
117809: PUSH
117810: LD_INT 2
117812: EQUAL
117813: IFFALSE 117823
// btype := b_factory ;
117815: LD_ADDR_VAR 0 5
117819: PUSH
117820: LD_INT 3
117822: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
117823: LD_VAR 0 5
117827: PPUSH
117828: LD_VAR 0 8
117832: PPUSH
117833: CALL_OW 323
117837: PUSH
117838: LD_INT 1
117840: EQUAL
117841: IFFALSE 117887
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
117843: LD_ADDR_EXP 193
117847: PUSH
117848: LD_EXP 193
117852: PPUSH
117853: LD_VAR 0 3
117857: PUSH
117858: LD_EXP 193
117862: PUSH
117863: LD_VAR 0 3
117867: ARRAY
117868: PUSH
117869: LD_INT 1
117871: PLUS
117872: PUSH
117873: EMPTY
117874: LIST
117875: LIST
117876: PPUSH
117877: LD_VAR 0 1
117881: PPUSH
117882: CALL 24361 0 3
117886: ST_TO_ADDR
// exit ;
117887: POP
117888: POP
117889: GO 118204
// end ; if btype in [ b_bunker , b_turret ] then
117891: LD_VAR 0 5
117895: PUSH
117896: LD_INT 32
117898: PUSH
117899: LD_INT 33
117901: PUSH
117902: EMPTY
117903: LIST
117904: LIST
117905: IN
117906: IFFALSE 118196
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
117908: LD_ADDR_EXP 169
117912: PUSH
117913: LD_EXP 169
117917: PPUSH
117918: LD_VAR 0 3
117922: PUSH
117923: LD_EXP 169
117927: PUSH
117928: LD_VAR 0 3
117932: ARRAY
117933: PUSH
117934: LD_INT 1
117936: PLUS
117937: PUSH
117938: EMPTY
117939: LIST
117940: LIST
117941: PPUSH
117942: LD_VAR 0 1
117946: PPUSH
117947: CALL 24361 0 3
117951: ST_TO_ADDR
// if btype = b_bunker then
117952: LD_VAR 0 5
117956: PUSH
117957: LD_INT 32
117959: EQUAL
117960: IFFALSE 118196
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
117962: LD_ADDR_EXP 170
117966: PUSH
117967: LD_EXP 170
117971: PPUSH
117972: LD_VAR 0 3
117976: PUSH
117977: LD_EXP 170
117981: PUSH
117982: LD_VAR 0 3
117986: ARRAY
117987: PUSH
117988: LD_INT 1
117990: PLUS
117991: PUSH
117992: EMPTY
117993: LIST
117994: LIST
117995: PPUSH
117996: LD_VAR 0 1
118000: PPUSH
118001: CALL 24361 0 3
118005: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
118006: LD_ADDR_VAR 0 6
118010: PUSH
118011: LD_EXP 161
118015: PUSH
118016: LD_VAR 0 3
118020: ARRAY
118021: PPUSH
118022: LD_INT 25
118024: PUSH
118025: LD_INT 1
118027: PUSH
118028: EMPTY
118029: LIST
118030: LIST
118031: PUSH
118032: LD_INT 3
118034: PUSH
118035: LD_INT 54
118037: PUSH
118038: EMPTY
118039: LIST
118040: PUSH
118041: EMPTY
118042: LIST
118043: LIST
118044: PUSH
118045: EMPTY
118046: LIST
118047: LIST
118048: PPUSH
118049: CALL_OW 72
118053: ST_TO_ADDR
// if tmp then
118054: LD_VAR 0 6
118058: IFFALSE 118064
// exit ;
118060: POP
118061: POP
118062: GO 118204
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
118064: LD_ADDR_VAR 0 6
118068: PUSH
118069: LD_EXP 161
118073: PUSH
118074: LD_VAR 0 3
118078: ARRAY
118079: PPUSH
118080: LD_INT 2
118082: PUSH
118083: LD_INT 30
118085: PUSH
118086: LD_INT 4
118088: PUSH
118089: EMPTY
118090: LIST
118091: LIST
118092: PUSH
118093: LD_INT 30
118095: PUSH
118096: LD_INT 5
118098: PUSH
118099: EMPTY
118100: LIST
118101: LIST
118102: PUSH
118103: EMPTY
118104: LIST
118105: LIST
118106: LIST
118107: PPUSH
118108: CALL_OW 72
118112: ST_TO_ADDR
// if not tmp then
118113: LD_VAR 0 6
118117: NOT
118118: IFFALSE 118124
// exit ;
118120: POP
118121: POP
118122: GO 118204
// for j in tmp do
118124: LD_ADDR_VAR 0 4
118128: PUSH
118129: LD_VAR 0 6
118133: PUSH
118134: FOR_IN
118135: IFFALSE 118194
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
118137: LD_ADDR_VAR 0 7
118141: PUSH
118142: LD_VAR 0 4
118146: PPUSH
118147: CALL_OW 313
118151: PPUSH
118152: LD_INT 25
118154: PUSH
118155: LD_INT 1
118157: PUSH
118158: EMPTY
118159: LIST
118160: LIST
118161: PPUSH
118162: CALL_OW 72
118166: ST_TO_ADDR
// if units then
118167: LD_VAR 0 7
118171: IFFALSE 118192
// begin ComExitBuilding ( units [ 1 ] ) ;
118173: LD_VAR 0 7
118177: PUSH
118178: LD_INT 1
118180: ARRAY
118181: PPUSH
118182: CALL_OW 122
// exit ;
118186: POP
118187: POP
118188: POP
118189: POP
118190: GO 118204
// end ; end ;
118192: GO 118134
118194: POP
118195: POP
// end ; end ; exit ;
118196: POP
118197: POP
118198: GO 118204
// end ; end ;
118200: GO 117558
118202: POP
118203: POP
// end ;
118204: LD_VAR 0 2
118208: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
118209: LD_INT 0
118211: PPUSH
118212: PPUSH
118213: PPUSH
118214: PPUSH
118215: PPUSH
118216: PPUSH
118217: PPUSH
// if not mc_bases or not skirmish then
118218: LD_EXP 161
118222: NOT
118223: PUSH
118224: LD_EXP 159
118228: NOT
118229: OR
118230: IFFALSE 118234
// exit ;
118232: GO 118499
// btype := GetBType ( building ) ;
118234: LD_ADDR_VAR 0 6
118238: PUSH
118239: LD_VAR 0 1
118243: PPUSH
118244: CALL_OW 266
118248: ST_TO_ADDR
// x := GetX ( building ) ;
118249: LD_ADDR_VAR 0 7
118253: PUSH
118254: LD_VAR 0 1
118258: PPUSH
118259: CALL_OW 250
118263: ST_TO_ADDR
// y := GetY ( building ) ;
118264: LD_ADDR_VAR 0 8
118268: PUSH
118269: LD_VAR 0 1
118273: PPUSH
118274: CALL_OW 251
118278: ST_TO_ADDR
// d := GetDir ( building ) ;
118279: LD_ADDR_VAR 0 9
118283: PUSH
118284: LD_VAR 0 1
118288: PPUSH
118289: CALL_OW 254
118293: ST_TO_ADDR
// for i = 1 to mc_bases do
118294: LD_ADDR_VAR 0 4
118298: PUSH
118299: DOUBLE
118300: LD_INT 1
118302: DEC
118303: ST_TO_ADDR
118304: LD_EXP 161
118308: PUSH
118309: FOR_TO
118310: IFFALSE 118497
// begin if not mc_build_list [ i ] then
118312: LD_EXP 166
118316: PUSH
118317: LD_VAR 0 4
118321: ARRAY
118322: NOT
118323: IFFALSE 118327
// continue ;
118325: GO 118309
// for j := 1 to mc_build_list [ i ] do
118327: LD_ADDR_VAR 0 5
118331: PUSH
118332: DOUBLE
118333: LD_INT 1
118335: DEC
118336: ST_TO_ADDR
118337: LD_EXP 166
118341: PUSH
118342: LD_VAR 0 4
118346: ARRAY
118347: PUSH
118348: FOR_TO
118349: IFFALSE 118493
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ j ] ) then
118351: LD_VAR 0 6
118355: PUSH
118356: LD_VAR 0 7
118360: PUSH
118361: LD_VAR 0 8
118365: PUSH
118366: LD_VAR 0 9
118370: PUSH
118371: EMPTY
118372: LIST
118373: LIST
118374: LIST
118375: LIST
118376: PPUSH
118377: LD_EXP 166
118381: PUSH
118382: LD_VAR 0 4
118386: ARRAY
118387: PUSH
118388: LD_VAR 0 5
118392: ARRAY
118393: PPUSH
118394: CALL 30541 0 2
118398: IFFALSE 118491
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , j ) ) ;
118400: LD_ADDR_EXP 166
118404: PUSH
118405: LD_EXP 166
118409: PPUSH
118410: LD_VAR 0 4
118414: PPUSH
118415: LD_EXP 166
118419: PUSH
118420: LD_VAR 0 4
118424: ARRAY
118425: PPUSH
118426: LD_VAR 0 5
118430: PPUSH
118431: CALL_OW 3
118435: PPUSH
118436: CALL_OW 1
118440: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
118441: LD_ADDR_EXP 168
118445: PUSH
118446: LD_EXP 168
118450: PPUSH
118451: LD_VAR 0 4
118455: PUSH
118456: LD_EXP 168
118460: PUSH
118461: LD_VAR 0 4
118465: ARRAY
118466: PUSH
118467: LD_INT 1
118469: PLUS
118470: PUSH
118471: EMPTY
118472: LIST
118473: LIST
118474: PPUSH
118475: LD_VAR 0 1
118479: PPUSH
118480: CALL 24361 0 3
118484: ST_TO_ADDR
// exit ;
118485: POP
118486: POP
118487: POP
118488: POP
118489: GO 118499
// end ;
118491: GO 118348
118493: POP
118494: POP
// end ;
118495: GO 118309
118497: POP
118498: POP
// end ;
118499: LD_VAR 0 3
118503: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
118504: LD_INT 0
118506: PPUSH
118507: PPUSH
118508: PPUSH
// if not mc_bases or not skirmish then
118509: LD_EXP 161
118513: NOT
118514: PUSH
118515: LD_EXP 159
118519: NOT
118520: OR
118521: IFFALSE 118525
// exit ;
118523: GO 118715
// for i = 1 to mc_bases do
118525: LD_ADDR_VAR 0 4
118529: PUSH
118530: DOUBLE
118531: LD_INT 1
118533: DEC
118534: ST_TO_ADDR
118535: LD_EXP 161
118539: PUSH
118540: FOR_TO
118541: IFFALSE 118628
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
118543: LD_VAR 0 1
118547: PUSH
118548: LD_EXP 169
118552: PUSH
118553: LD_VAR 0 4
118557: ARRAY
118558: IN
118559: PUSH
118560: LD_VAR 0 1
118564: PUSH
118565: LD_EXP 170
118569: PUSH
118570: LD_VAR 0 4
118574: ARRAY
118575: IN
118576: NOT
118577: AND
118578: IFFALSE 118626
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
118580: LD_ADDR_EXP 170
118584: PUSH
118585: LD_EXP 170
118589: PPUSH
118590: LD_VAR 0 4
118594: PUSH
118595: LD_EXP 170
118599: PUSH
118600: LD_VAR 0 4
118604: ARRAY
118605: PUSH
118606: LD_INT 1
118608: PLUS
118609: PUSH
118610: EMPTY
118611: LIST
118612: LIST
118613: PPUSH
118614: LD_VAR 0 1
118618: PPUSH
118619: CALL 24361 0 3
118623: ST_TO_ADDR
// break ;
118624: GO 118628
// end ; end ;
118626: GO 118540
118628: POP
118629: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
118630: LD_VAR 0 1
118634: PPUSH
118635: CALL_OW 257
118639: PUSH
118640: LD_EXP 187
118644: IN
118645: PUSH
118646: LD_VAR 0 1
118650: PPUSH
118651: CALL_OW 266
118655: PUSH
118656: LD_INT 5
118658: EQUAL
118659: AND
118660: PUSH
118661: LD_VAR 0 2
118665: PPUSH
118666: CALL_OW 110
118670: PUSH
118671: LD_INT 18
118673: NONEQUAL
118674: AND
118675: IFFALSE 118715
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
118677: LD_VAR 0 2
118681: PPUSH
118682: CALL_OW 257
118686: PUSH
118687: LD_INT 5
118689: PUSH
118690: LD_INT 8
118692: PUSH
118693: LD_INT 9
118695: PUSH
118696: EMPTY
118697: LIST
118698: LIST
118699: LIST
118700: IN
118701: IFFALSE 118715
// SetClass ( unit , 1 ) ;
118703: LD_VAR 0 2
118707: PPUSH
118708: LD_INT 1
118710: PPUSH
118711: CALL_OW 336
// end ;
118715: LD_VAR 0 3
118719: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
118720: LD_INT 0
118722: PPUSH
118723: PPUSH
// if not mc_bases or not skirmish then
118724: LD_EXP 161
118728: NOT
118729: PUSH
118730: LD_EXP 159
118734: NOT
118735: OR
118736: IFFALSE 118740
// exit ;
118738: GO 118856
// if GetLives ( abandoned_vehicle ) > 250 then
118740: LD_VAR 0 2
118744: PPUSH
118745: CALL_OW 256
118749: PUSH
118750: LD_INT 250
118752: GREATER
118753: IFFALSE 118757
// exit ;
118755: GO 118856
// for i = 1 to mc_bases do
118757: LD_ADDR_VAR 0 6
118761: PUSH
118762: DOUBLE
118763: LD_INT 1
118765: DEC
118766: ST_TO_ADDR
118767: LD_EXP 161
118771: PUSH
118772: FOR_TO
118773: IFFALSE 118854
// begin if driver in mc_bases [ i ] then
118775: LD_VAR 0 1
118779: PUSH
118780: LD_EXP 161
118784: PUSH
118785: LD_VAR 0 6
118789: ARRAY
118790: IN
118791: IFFALSE 118852
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
118793: LD_VAR 0 1
118797: PPUSH
118798: LD_EXP 161
118802: PUSH
118803: LD_VAR 0 6
118807: ARRAY
118808: PPUSH
118809: LD_INT 2
118811: PUSH
118812: LD_INT 30
118814: PUSH
118815: LD_INT 0
118817: PUSH
118818: EMPTY
118819: LIST
118820: LIST
118821: PUSH
118822: LD_INT 30
118824: PUSH
118825: LD_INT 1
118827: PUSH
118828: EMPTY
118829: LIST
118830: LIST
118831: PUSH
118832: EMPTY
118833: LIST
118834: LIST
118835: LIST
118836: PPUSH
118837: CALL_OW 72
118841: PUSH
118842: LD_INT 1
118844: ARRAY
118845: PPUSH
118846: CALL 57569 0 2
// break ;
118850: GO 118854
// end ; end ;
118852: GO 118772
118854: POP
118855: POP
// end ;
118856: LD_VAR 0 5
118860: RET
