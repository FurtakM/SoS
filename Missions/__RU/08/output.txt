// starting begin InitMission ;
   0: CALL 5 0 0
// end ;
   4: END
// export HeikeCaptured ; export coopWithGensher ; export HeikeStatus ; export Masha ; export dial_BuildDepotBlocker , dial_BuildArBarrackBlocker , dial_ArriveGensherUnitsBlocker ; export buildingsToBuild , techsToResearch , vehWeaponsToConstruct , availableWeapons , weaponsData , allBuildings ; export HeikeTargetX , HeikeTargetY , GensherTargetX , GensherTargetY ; export allowExitFromMap ; export acceptKurtOffert , askCommanders ; export KurtCanEscape , KurtStatus , KurtWaitingForFreeHeike , KurtWaitingForBuildBarrack ; export KurtAttack , americansAttack , forceStopKurtAttack ; export canSendHeike , canShootTrening ; export BurlakRespect ; export acceptLegionOffert , paidLegionOffert , legionOffertCountdown , legionOffertTime ; export firstMashaQuery , canChooseMashaVehicle ; export buildCompVehicle , buildArabBarrack , testedTeleport ; export lostUnits ; function InitMission ; begin
   5: LD_INT 0
   7: PPUSH
// ResetFog ;
   8: CALL_OW 335
// RandomizeAll ;
  12: CALL_OW 11
// InGameOn ;
  16: CALL_OW 8
// InitMapConfig ;
  20: CALL 358 0 0
// HeikeCaptured = LoadVariable ( 07_HeikeCaptured_1 , 0 ) ;
  24: LD_ADDR_EXP 1
  28: PUSH
  29: LD_STRING 07_HeikeCaptured_1
  31: PPUSH
  32: LD_INT 0
  34: PPUSH
  35: CALL_OW 30
  39: ST_TO_ADDR
// coopWithGensher = 0 ;
  40: LD_ADDR_EXP 2
  44: PUSH
  45: LD_INT 0
  47: ST_TO_ADDR
// HeikeStatus = 0 ;
  48: LD_ADDR_EXP 3
  52: PUSH
  53: LD_INT 0
  55: ST_TO_ADDR
// Masha = [ ] ;
  56: LD_ADDR_EXP 4
  60: PUSH
  61: EMPTY
  62: ST_TO_ADDR
// buildingsToBuild = [ ] ;
  63: LD_ADDR_EXP 8
  67: PUSH
  68: EMPTY
  69: ST_TO_ADDR
// techsToResearch = [ ] ;
  70: LD_ADDR_EXP 9
  74: PUSH
  75: EMPTY
  76: ST_TO_ADDR
// vehWeaponsToConstruct = [ ] ;
  77: LD_ADDR_EXP 10
  81: PUSH
  82: EMPTY
  83: ST_TO_ADDR
// availableWeapons = [ ] ;
  84: LD_ADDR_EXP 11
  88: PUSH
  89: EMPTY
  90: ST_TO_ADDR
// weaponsData = [ ] ;
  91: LD_ADDR_EXP 12
  95: PUSH
  96: EMPTY
  97: ST_TO_ADDR
// allBuildings = [ ] ;
  98: LD_ADDR_EXP 13
 102: PUSH
 103: EMPTY
 104: ST_TO_ADDR
// HeikeTargetX = 0 ;
 105: LD_ADDR_EXP 14
 109: PUSH
 110: LD_INT 0
 112: ST_TO_ADDR
// HeikeTargetY = 0 ;
 113: LD_ADDR_EXP 15
 117: PUSH
 118: LD_INT 0
 120: ST_TO_ADDR
// GensherTargetX = 0 ;
 121: LD_ADDR_EXP 16
 125: PUSH
 126: LD_INT 0
 128: ST_TO_ADDR
// GensherTargetY = 0 ;
 129: LD_ADDR_EXP 17
 133: PUSH
 134: LD_INT 0
 136: ST_TO_ADDR
// allowExitFromMap = 0 ;
 137: LD_ADDR_EXP 18
 141: PUSH
 142: LD_INT 0
 144: ST_TO_ADDR
// acceptKurtOffert = 0 ;
 145: LD_ADDR_EXP 19
 149: PUSH
 150: LD_INT 0
 152: ST_TO_ADDR
// askCommanders = 0 ;
 153: LD_ADDR_EXP 20
 157: PUSH
 158: LD_INT 0
 160: ST_TO_ADDR
// KurtCanEscape = true ;
 161: LD_ADDR_EXP 21
 165: PUSH
 166: LD_INT 1
 168: ST_TO_ADDR
// KurtAttack = false ;
 169: LD_ADDR_EXP 25
 173: PUSH
 174: LD_INT 0
 176: ST_TO_ADDR
// KurtWaitingForFreeHeike = false ;
 177: LD_ADDR_EXP 23
 181: PUSH
 182: LD_INT 0
 184: ST_TO_ADDR
// KurtWaitingForBuildBarrack = false ;
 185: LD_ADDR_EXP 24
 189: PUSH
 190: LD_INT 0
 192: ST_TO_ADDR
// KurtStatus = 0 ;
 193: LD_ADDR_EXP 22
 197: PUSH
 198: LD_INT 0
 200: ST_TO_ADDR
// americansAttack = false ;
 201: LD_ADDR_EXP 26
 205: PUSH
 206: LD_INT 0
 208: ST_TO_ADDR
// forceStopKurtAttack = false ;
 209: LD_ADDR_EXP 27
 213: PUSH
 214: LD_INT 0
 216: ST_TO_ADDR
// canSendHeike = false ;
 217: LD_ADDR_EXP 28
 221: PUSH
 222: LD_INT 0
 224: ST_TO_ADDR
// canShootTrening = false ;
 225: LD_ADDR_EXP 29
 229: PUSH
 230: LD_INT 0
 232: ST_TO_ADDR
// BurlakRespect = 0 ;
 233: LD_ADDR_EXP 30
 237: PUSH
 238: LD_INT 0
 240: ST_TO_ADDR
// acceptLegionOffert = false ;
 241: LD_ADDR_EXP 31
 245: PUSH
 246: LD_INT 0
 248: ST_TO_ADDR
// paidLegionOffert = false ;
 249: LD_ADDR_EXP 32
 253: PUSH
 254: LD_INT 0
 256: ST_TO_ADDR
// legionOffertCountdown = false ;
 257: LD_ADDR_EXP 33
 261: PUSH
 262: LD_INT 0
 264: ST_TO_ADDR
// legionOffertTime = 0 0$60 ;
 265: LD_ADDR_EXP 34
 269: PUSH
 270: LD_INT 2100
 272: ST_TO_ADDR
// canChooseMashaVehicle = false ;
 273: LD_ADDR_EXP 36
 277: PUSH
 278: LD_INT 0
 280: ST_TO_ADDR
// firstMashaQuery = true ;
 281: LD_ADDR_EXP 35
 285: PUSH
 286: LD_INT 1
 288: ST_TO_ADDR
// buildArabBarrack = false ;
 289: LD_ADDR_EXP 38
 293: PUSH
 294: LD_INT 0
 296: ST_TO_ADDR
// buildCompVehicle = false ;
 297: LD_ADDR_EXP 37
 301: PUSH
 302: LD_INT 0
 304: ST_TO_ADDR
// testedTeleport = false ;
 305: LD_ADDR_EXP 39
 309: PUSH
 310: LD_INT 0
 312: ST_TO_ADDR
// lostUnits = 0 ;
 313: LD_ADDR_EXP 40
 317: PUSH
 318: LD_INT 0
 320: ST_TO_ADDR
// PrepareRussians ;
 321: CALL 1292 0 0
// PrepareArabians ;
 325: CALL 3847 0 0
// PrepareAmericans ;
 329: CALL 2975 0 0
// Nef_PrepareNature ;
 333: CALL 4831 0 0
// SpawnTrees ;
 337: CALL 5452 0 0
// MissionIntro ;
 341: CALL 9085 0 0
// end ;
 345: LD_VAR 0 1
 349: RET
// export function CustomInitMacro ; begin
 350: LD_INT 0
 352: PPUSH
// end ; end_of_file
 353: LD_VAR 0 1
 357: RET
// export function InitMapConfig ; begin
 358: LD_INT 0
 360: PPUSH
// BaseMapConfig ;
 361: CALL 374 0 0
// MissionMapConfig ;
 365: CALL 464 0 0
// end ;
 369: LD_VAR 0 1
 373: RET
// export animalsAmount , animalsStats , animalsAgression , missionPrefix , previousMissionPrefix , debugMode ; function BaseMapConfig ; begin
 374: LD_INT 0
 376: PPUSH
// animalsAmount = [ 6 , 3 , 4 , 4 , 1 ] ;
 377: LD_ADDR_EXP 41
 381: PUSH
 382: LD_INT 6
 384: PUSH
 385: LD_INT 3
 387: PUSH
 388: LD_INT 4
 390: PUSH
 391: LD_INT 4
 393: PUSH
 394: LD_INT 1
 396: PUSH
 397: EMPTY
 398: LIST
 399: LIST
 400: LIST
 401: LIST
 402: LIST
 403: ST_TO_ADDR
// animalsStats = [ 2 , 2 , 2 , 2 ] ;
 404: LD_ADDR_EXP 42
 408: PUSH
 409: LD_INT 2
 411: PUSH
 412: LD_INT 2
 414: PUSH
 415: LD_INT 2
 417: PUSH
 418: LD_INT 2
 420: PUSH
 421: EMPTY
 422: LIST
 423: LIST
 424: LIST
 425: LIST
 426: ST_TO_ADDR
// animalsAgression = 3 ;
 427: LD_ADDR_EXP 43
 431: PUSH
 432: LD_INT 3
 434: ST_TO_ADDR
// debugMode = 0 ;
 435: LD_ADDR_EXP 46
 439: PUSH
 440: LD_INT 0
 442: ST_TO_ADDR
// missionPrefix = 08_ ;
 443: LD_ADDR_EXP 44
 447: PUSH
 448: LD_STRING 08_
 450: ST_TO_ADDR
// previousMissionPrefix = 07_ ;
 451: LD_ADDR_EXP 45
 455: PUSH
 456: LD_STRING 07_
 458: ST_TO_ADDR
// end ;
 459: LD_VAR 0 1
 463: RET
// export KurtAttackWaves , americansAttackWaves ; export firstAttackDelay ; export waveCooldown ; export legionReduceAmericansUnits ; export speedMedalTime ; export enemyAttackUnitsData ; export timeToFreeHeike , timeToBuildArBarrack ; export enemySkillLevel ; function MissionMapConfig ; begin
 464: LD_INT 0
 466: PPUSH
// KurtAttackWaves = [ 3 , 4 , 5 , 6 ] [ Difficulty ] ;
 467: LD_ADDR_EXP 47
 471: PUSH
 472: LD_INT 3
 474: PUSH
 475: LD_INT 4
 477: PUSH
 478: LD_INT 5
 480: PUSH
 481: LD_INT 6
 483: PUSH
 484: EMPTY
 485: LIST
 486: LIST
 487: LIST
 488: LIST
 489: PUSH
 490: LD_OWVAR 67
 494: ARRAY
 495: ST_TO_ADDR
// americansAttackWaves = [ 1 , 2 , 3 , 4 ] [ Difficulty ] ;
 496: LD_ADDR_EXP 48
 500: PUSH
 501: LD_INT 1
 503: PUSH
 504: LD_INT 2
 506: PUSH
 507: LD_INT 3
 509: PUSH
 510: LD_INT 4
 512: PUSH
 513: EMPTY
 514: LIST
 515: LIST
 516: LIST
 517: LIST
 518: PUSH
 519: LD_OWVAR 67
 523: ARRAY
 524: ST_TO_ADDR
// enemySkillLevel = [ 3 , 4 , 5 , 6 ] [ Difficulty ] ;
 525: LD_ADDR_EXP 56
 529: PUSH
 530: LD_INT 3
 532: PUSH
 533: LD_INT 4
 535: PUSH
 536: LD_INT 5
 538: PUSH
 539: LD_INT 6
 541: PUSH
 542: EMPTY
 543: LIST
 544: LIST
 545: LIST
 546: LIST
 547: PUSH
 548: LD_OWVAR 67
 552: ARRAY
 553: ST_TO_ADDR
// waveCooldown = 1 1$30 ;
 554: LD_ADDR_EXP 50
 558: PUSH
 559: LD_INT 3150
 561: ST_TO_ADDR
// firstAttackDelay = 1 1$00 ;
 562: LD_ADDR_EXP 49
 566: PUSH
 567: LD_INT 2100
 569: ST_TO_ADDR
// timeToFreeHeike = 2 2$00 ;
 570: LD_ADDR_EXP 54
 574: PUSH
 575: LD_INT 4200
 577: ST_TO_ADDR
// timeToBuildArBarrack = 5 5$00 ;
 578: LD_ADDR_EXP 55
 582: PUSH
 583: LD_INT 10500
 585: ST_TO_ADDR
// legionReduceAmericansUnits = [ 5 , 5 , 6 , 6 ] [ Difficulty ] ;
 586: LD_ADDR_EXP 51
 590: PUSH
 591: LD_INT 5
 593: PUSH
 594: LD_INT 5
 596: PUSH
 597: LD_INT 6
 599: PUSH
 600: LD_INT 6
 602: PUSH
 603: EMPTY
 604: LIST
 605: LIST
 606: LIST
 607: LIST
 608: PUSH
 609: LD_OWVAR 67
 613: ARRAY
 614: ST_TO_ADDR
// speedMedalTime = [ 80 80$0 , 70 70$0 , 60 60$0 , 50 50$0 ] [ Difficulty ] ;
 615: LD_ADDR_EXP 52
 619: PUSH
 620: LD_INT 168000
 622: PUSH
 623: LD_INT 147000
 625: PUSH
 626: LD_INT 126000
 628: PUSH
 629: LD_INT 105000
 631: PUSH
 632: EMPTY
 633: LIST
 634: LIST
 635: LIST
 636: LIST
 637: PUSH
 638: LD_OWVAR 67
 642: ARRAY
 643: ST_TO_ADDR
// enemyAttackUnitsData = [ [ 1 , [ 4 , 5 , 6 , 6 ] [ Difficulty ] , [ 7 , 8 , 9 , 9 ] [ Difficulty ] , [ 1 , 2 , 2 , 3 ] [ Difficulty ] , [ 3 , 3 , 4 , 4 ] [ Difficulty ] , [ 6 , 7 , 8 , 8 ] [ Difficulty ] , [ 10 , 12 , 15 , 15 ] [ Difficulty ] ] , [ 8 , [ 2 , 3 , 4 , 4 ] [ Difficulty ] , [ 6 , 6 , 7 , 7 ] [ Difficulty ] , [ 0 , 1 , 1 , 2 ] [ Difficulty ] , [ 1 , 2 , 3 , 3 ] [ Difficulty ] , [ 1 , 2 , 2 , 2 ] [ Difficulty ] , [ 2 , 3 , 5 , 5 ] [ Difficulty ] ] ] ;
 644: LD_ADDR_EXP 53
 648: PUSH
 649: LD_INT 1
 651: PUSH
 652: LD_INT 4
 654: PUSH
 655: LD_INT 5
 657: PUSH
 658: LD_INT 6
 660: PUSH
 661: LD_INT 6
 663: PUSH
 664: EMPTY
 665: LIST
 666: LIST
 667: LIST
 668: LIST
 669: PUSH
 670: LD_OWVAR 67
 674: ARRAY
 675: PUSH
 676: LD_INT 7
 678: PUSH
 679: LD_INT 8
 681: PUSH
 682: LD_INT 9
 684: PUSH
 685: LD_INT 9
 687: PUSH
 688: EMPTY
 689: LIST
 690: LIST
 691: LIST
 692: LIST
 693: PUSH
 694: LD_OWVAR 67
 698: ARRAY
 699: PUSH
 700: LD_INT 1
 702: PUSH
 703: LD_INT 2
 705: PUSH
 706: LD_INT 2
 708: PUSH
 709: LD_INT 3
 711: PUSH
 712: EMPTY
 713: LIST
 714: LIST
 715: LIST
 716: LIST
 717: PUSH
 718: LD_OWVAR 67
 722: ARRAY
 723: PUSH
 724: LD_INT 3
 726: PUSH
 727: LD_INT 3
 729: PUSH
 730: LD_INT 4
 732: PUSH
 733: LD_INT 4
 735: PUSH
 736: EMPTY
 737: LIST
 738: LIST
 739: LIST
 740: LIST
 741: PUSH
 742: LD_OWVAR 67
 746: ARRAY
 747: PUSH
 748: LD_INT 6
 750: PUSH
 751: LD_INT 7
 753: PUSH
 754: LD_INT 8
 756: PUSH
 757: LD_INT 8
 759: PUSH
 760: EMPTY
 761: LIST
 762: LIST
 763: LIST
 764: LIST
 765: PUSH
 766: LD_OWVAR 67
 770: ARRAY
 771: PUSH
 772: LD_INT 10
 774: PUSH
 775: LD_INT 12
 777: PUSH
 778: LD_INT 15
 780: PUSH
 781: LD_INT 15
 783: PUSH
 784: EMPTY
 785: LIST
 786: LIST
 787: LIST
 788: LIST
 789: PUSH
 790: LD_OWVAR 67
 794: ARRAY
 795: PUSH
 796: EMPTY
 797: LIST
 798: LIST
 799: LIST
 800: LIST
 801: LIST
 802: LIST
 803: LIST
 804: PUSH
 805: LD_INT 8
 807: PUSH
 808: LD_INT 2
 810: PUSH
 811: LD_INT 3
 813: PUSH
 814: LD_INT 4
 816: PUSH
 817: LD_INT 4
 819: PUSH
 820: EMPTY
 821: LIST
 822: LIST
 823: LIST
 824: LIST
 825: PUSH
 826: LD_OWVAR 67
 830: ARRAY
 831: PUSH
 832: LD_INT 6
 834: PUSH
 835: LD_INT 6
 837: PUSH
 838: LD_INT 7
 840: PUSH
 841: LD_INT 7
 843: PUSH
 844: EMPTY
 845: LIST
 846: LIST
 847: LIST
 848: LIST
 849: PUSH
 850: LD_OWVAR 67
 854: ARRAY
 855: PUSH
 856: LD_INT 0
 858: PUSH
 859: LD_INT 1
 861: PUSH
 862: LD_INT 1
 864: PUSH
 865: LD_INT 2
 867: PUSH
 868: EMPTY
 869: LIST
 870: LIST
 871: LIST
 872: LIST
 873: PUSH
 874: LD_OWVAR 67
 878: ARRAY
 879: PUSH
 880: LD_INT 1
 882: PUSH
 883: LD_INT 2
 885: PUSH
 886: LD_INT 3
 888: PUSH
 889: LD_INT 3
 891: PUSH
 892: EMPTY
 893: LIST
 894: LIST
 895: LIST
 896: LIST
 897: PUSH
 898: LD_OWVAR 67
 902: ARRAY
 903: PUSH
 904: LD_INT 1
 906: PUSH
 907: LD_INT 2
 909: PUSH
 910: LD_INT 2
 912: PUSH
 913: LD_INT 2
 915: PUSH
 916: EMPTY
 917: LIST
 918: LIST
 919: LIST
 920: LIST
 921: PUSH
 922: LD_OWVAR 67
 926: ARRAY
 927: PUSH
 928: LD_INT 2
 930: PUSH
 931: LD_INT 3
 933: PUSH
 934: LD_INT 5
 936: PUSH
 937: LD_INT 5
 939: PUSH
 940: EMPTY
 941: LIST
 942: LIST
 943: LIST
 944: LIST
 945: PUSH
 946: LD_OWVAR 67
 950: ARRAY
 951: PUSH
 952: EMPTY
 953: LIST
 954: LIST
 955: LIST
 956: LIST
 957: LIST
 958: LIST
 959: LIST
 960: PUSH
 961: EMPTY
 962: LIST
 963: LIST
 964: ST_TO_ADDR
// end ;
 965: LD_VAR 0 1
 969: RET
// every 0 0$1 trigger debugMode do var i ;
 970: LD_EXP 46
 974: IFFALSE 1289
 976: GO 978
 978: DISABLE
 979: LD_INT 0
 981: PPUSH
// begin enable ;
 982: ENABLE
// FogOff ( your_side ) ;
 983: LD_OWVAR 2
 987: PPUSH
 988: CALL_OW 344
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) do
 992: LD_ADDR_VAR 0 1
 996: PUSH
 997: LD_INT 22
 999: PUSH
1000: LD_OWVAR 2
1004: PUSH
1005: EMPTY
1006: LIST
1007: LIST
1008: PUSH
1009: LD_INT 2
1011: PUSH
1012: LD_INT 21
1014: PUSH
1015: LD_INT 1
1017: PUSH
1018: EMPTY
1019: LIST
1020: LIST
1021: PUSH
1022: LD_INT 21
1024: PUSH
1025: LD_INT 2
1027: PUSH
1028: EMPTY
1029: LIST
1030: LIST
1031: PUSH
1032: EMPTY
1033: LIST
1034: LIST
1035: LIST
1036: PUSH
1037: EMPTY
1038: LIST
1039: LIST
1040: PPUSH
1041: CALL_OW 69
1045: PUSH
1046: FOR_IN
1047: IFFALSE 1063
// SetLives ( i , 1000 ) ;
1049: LD_VAR 0 1
1053: PPUSH
1054: LD_INT 1000
1056: PPUSH
1057: CALL_OW 234
1061: GO 1046
1063: POP
1064: POP
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
1065: LD_ADDR_VAR 0 1
1069: PUSH
1070: LD_INT 22
1072: PUSH
1073: LD_OWVAR 2
1077: PUSH
1078: EMPTY
1079: LIST
1080: LIST
1081: PUSH
1082: LD_INT 21
1084: PUSH
1085: LD_INT 1
1087: PUSH
1088: EMPTY
1089: LIST
1090: LIST
1091: PUSH
1092: EMPTY
1093: LIST
1094: LIST
1095: PPUSH
1096: CALL_OW 69
1100: PUSH
1101: FOR_IN
1102: IFFALSE 1166
// begin SetSkill ( i , skill_combat , 10 ) ;
1104: LD_VAR 0 1
1108: PPUSH
1109: LD_INT 1
1111: PPUSH
1112: LD_INT 10
1114: PPUSH
1115: CALL_OW 237
// SetSkill ( i , skill_engineering , 10 ) ;
1119: LD_VAR 0 1
1123: PPUSH
1124: LD_INT 2
1126: PPUSH
1127: LD_INT 10
1129: PPUSH
1130: CALL_OW 237
// SetSkill ( i , skill_mechanical , 10 ) ;
1134: LD_VAR 0 1
1138: PPUSH
1139: LD_INT 3
1141: PPUSH
1142: LD_INT 10
1144: PPUSH
1145: CALL_OW 237
// SetSkill ( i , skill_scientistic , 10 ) ;
1149: LD_VAR 0 1
1153: PPUSH
1154: LD_INT 4
1156: PPUSH
1157: LD_INT 10
1159: PPUSH
1160: CALL_OW 237
// end ;
1164: GO 1101
1166: POP
1167: POP
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) do
1168: LD_ADDR_VAR 0 1
1172: PUSH
1173: LD_INT 22
1175: PUSH
1176: LD_OWVAR 2
1180: PUSH
1181: EMPTY
1182: LIST
1183: LIST
1184: PUSH
1185: LD_INT 2
1187: PUSH
1188: LD_INT 30
1190: PUSH
1191: LD_INT 0
1193: PUSH
1194: EMPTY
1195: LIST
1196: LIST
1197: PUSH
1198: LD_INT 30
1200: PUSH
1201: LD_INT 1
1203: PUSH
1204: EMPTY
1205: LIST
1206: LIST
1207: PUSH
1208: EMPTY
1209: LIST
1210: LIST
1211: LIST
1212: PUSH
1213: EMPTY
1214: LIST
1215: LIST
1216: PPUSH
1217: CALL_OW 69
1221: PUSH
1222: FOR_IN
1223: IFFALSE 1287
// begin SetResourceType ( GetBase ( i ) , mat_cans , 9999 ) ;
1225: LD_VAR 0 1
1229: PPUSH
1230: CALL_OW 274
1234: PPUSH
1235: LD_INT 1
1237: PPUSH
1238: LD_INT 9999
1240: PPUSH
1241: CALL_OW 277
// SetResourceType ( GetBase ( i ) , mat_oil , 9999 ) ;
1245: LD_VAR 0 1
1249: PPUSH
1250: CALL_OW 274
1254: PPUSH
1255: LD_INT 2
1257: PPUSH
1258: LD_INT 9999
1260: PPUSH
1261: CALL_OW 277
// SetResourceType ( GetBase ( i ) , mat_siberit , 9999 ) ;
1265: LD_VAR 0 1
1269: PPUSH
1270: CALL_OW 274
1274: PPUSH
1275: LD_INT 3
1277: PPUSH
1278: LD_INT 9999
1280: PPUSH
1281: CALL_OW 277
// end ;
1285: GO 1222
1287: POP
1288: POP
// end ; end_of_file
1289: PPOPN 1
1291: END
// export Burlak , Karamazov , Petrovova , Gleb , Petrosyan , Titov , Dolgov , Lipshchin , Kirilenkova , Belkov , Belkov2 , Xavier ; export Gnyevko , Kovalyuk , Scholtze , Kuzmov ; export Kozlov , Oblukov , Kapitsova ; export Popov ; export russianEscort ; export function PrepareRussians ; begin
1292: LD_INT 0
1294: PPUSH
// russianEscort = [ ] ;
1295: LD_ADDR_EXP 77
1299: PUSH
1300: EMPTY
1301: ST_TO_ADDR
// Masha = [ ] ;
1302: LD_ADDR_EXP 4
1306: PUSH
1307: EMPTY
1308: ST_TO_ADDR
// PrepareHeroes ;
1309: CALL 1322 0 0
// InitRussianRequiments ;
1313: CALL 2717 0 0
// end ;
1317: LD_VAR 0 1
1321: RET
// function PrepareHeroes ; var i , un , other_survivors , yourUnits , emptyVeh ; begin
1322: LD_INT 0
1324: PPUSH
1325: PPUSH
1326: PPUSH
1327: PPUSH
1328: PPUSH
1329: PPUSH
// uc_side = 3 ;
1330: LD_ADDR_OWVAR 20
1334: PUSH
1335: LD_INT 3
1337: ST_TO_ADDR
// uc_nation = 3 ;
1338: LD_ADDR_OWVAR 21
1342: PUSH
1343: LD_INT 3
1345: ST_TO_ADDR
// Burlak := PrepareUnitExt ( Burlak , true , class_mechanic ) ;
1346: LD_ADDR_EXP 57
1350: PUSH
1351: LD_STRING Burlak
1353: PPUSH
1354: LD_INT 1
1356: PPUSH
1357: LD_INT 3
1359: PPUSH
1360: CALL 5930 0 3
1364: ST_TO_ADDR
// Titov := PrepareUnitExt ( Titov , true , class_soldier ) ;
1365: LD_ADDR_EXP 62
1369: PUSH
1370: LD_STRING Titov
1372: PPUSH
1373: LD_INT 1
1375: PPUSH
1376: LD_INT 1
1378: PPUSH
1379: CALL 5930 0 3
1383: ST_TO_ADDR
// Dolgov := PrepareUnitExt ( Dolgov , true , class_scientistic ) ;
1384: LD_ADDR_EXP 63
1388: PUSH
1389: LD_STRING Dolgov
1391: PPUSH
1392: LD_INT 1
1394: PPUSH
1395: LD_INT 4
1397: PPUSH
1398: CALL 5930 0 3
1402: ST_TO_ADDR
// Lipshchin := PrepareUnitExt ( Lipshchin , true , class_soldier ) ;
1403: LD_ADDR_EXP 64
1407: PUSH
1408: LD_STRING Lipshchin
1410: PPUSH
1411: LD_INT 1
1413: PPUSH
1414: LD_INT 1
1416: PPUSH
1417: CALL 5930 0 3
1421: ST_TO_ADDR
// Karamazov := PrepareUnitExt ( Karamazov , true , class_engineer ) ;
1422: LD_ADDR_EXP 58
1426: PUSH
1427: LD_STRING Karamazov
1429: PPUSH
1430: LD_INT 1
1432: PPUSH
1433: LD_INT 2
1435: PPUSH
1436: CALL 5930 0 3
1440: ST_TO_ADDR
// Petrovova := PrepareUnitExt ( Petrovova , true , class_soldier ) ;
1441: LD_ADDR_EXP 59
1445: PUSH
1446: LD_STRING Petrovova
1448: PPUSH
1449: LD_INT 1
1451: PPUSH
1452: LD_INT 1
1454: PPUSH
1455: CALL 5930 0 3
1459: ST_TO_ADDR
// Gleb := PrepareUnitExt ( Gleb , true , class_soldier ) ;
1460: LD_ADDR_EXP 60
1464: PUSH
1465: LD_STRING Gleb
1467: PPUSH
1468: LD_INT 1
1470: PPUSH
1471: LD_INT 1
1473: PPUSH
1474: CALL 5930 0 3
1478: ST_TO_ADDR
// Petrosyan := PrepareUnitExt ( Petrosyan , true , class_scientistic ) ;
1479: LD_ADDR_EXP 61
1483: PUSH
1484: LD_STRING Petrosyan
1486: PPUSH
1487: LD_INT 1
1489: PPUSH
1490: LD_INT 4
1492: PPUSH
1493: CALL 5930 0 3
1497: ST_TO_ADDR
// Kirilenkova := PrepareUnitExt ( Kirilenkova , true , class_scientistic ) ;
1498: LD_ADDR_EXP 65
1502: PUSH
1503: LD_STRING Kirilenkova
1505: PPUSH
1506: LD_INT 1
1508: PPUSH
1509: LD_INT 4
1511: PPUSH
1512: CALL 5930 0 3
1516: ST_TO_ADDR
// Belkov := PrepareUnitExt ( Belkov , true , class_soldier ) ;
1517: LD_ADDR_EXP 66
1521: PUSH
1522: LD_STRING Belkov
1524: PPUSH
1525: LD_INT 1
1527: PPUSH
1528: LD_INT 1
1530: PPUSH
1531: CALL 5930 0 3
1535: ST_TO_ADDR
// Belkov2 := PrepareUnitExt ( Belkov2 , true , class_soldier ) ;
1536: LD_ADDR_EXP 67
1540: PUSH
1541: LD_STRING Belkov2
1543: PPUSH
1544: LD_INT 1
1546: PPUSH
1547: LD_INT 1
1549: PPUSH
1550: CALL 5930 0 3
1554: ST_TO_ADDR
// Xavier := PrepareUnitExt ( Xavier , true , class_soldier ) ;
1555: LD_ADDR_EXP 68
1559: PUSH
1560: LD_STRING Xavier
1562: PPUSH
1563: LD_INT 1
1565: PPUSH
1566: LD_INT 1
1568: PPUSH
1569: CALL 5930 0 3
1573: ST_TO_ADDR
// Gnyevko := CreateCharacter ( 04_Gnyevko ) ;
1574: LD_ADDR_EXP 69
1578: PUSH
1579: LD_STRING 04_Gnyevko
1581: PPUSH
1582: CALL_OW 34
1586: ST_TO_ADDR
// SetClass ( Gnyevko , class_soldier ) ;
1587: LD_EXP 69
1591: PPUSH
1592: LD_INT 1
1594: PPUSH
1595: CALL_OW 336
// Kovalyuk := CreateCharacter ( 04_Kovalyuk ) ;
1599: LD_ADDR_EXP 70
1603: PUSH
1604: LD_STRING 04_Kovalyuk
1606: PPUSH
1607: CALL_OW 34
1611: ST_TO_ADDR
// SetClass ( Kovalyuk , class_mechanic ) ;
1612: LD_EXP 70
1616: PPUSH
1617: LD_INT 3
1619: PPUSH
1620: CALL_OW 336
// Scholtze := CreateCharacter ( 04_Scholtze ) ;
1624: LD_ADDR_EXP 71
1628: PUSH
1629: LD_STRING 04_Scholtze
1631: PPUSH
1632: CALL_OW 34
1636: ST_TO_ADDR
// SetClass ( Scholtze , class_scientistic ) ;
1637: LD_EXP 71
1641: PPUSH
1642: LD_INT 4
1644: PPUSH
1645: CALL_OW 336
// Kuzmov := CreateCharacter ( 04_Kuzmov ) ;
1649: LD_ADDR_EXP 72
1653: PUSH
1654: LD_STRING 04_Kuzmov
1656: PPUSH
1657: CALL_OW 34
1661: ST_TO_ADDR
// SetClass ( Kuzmov , class_soldier ) ;
1662: LD_EXP 72
1666: PPUSH
1667: LD_INT 1
1669: PPUSH
1670: CALL_OW 336
// Kozlov := PrepareUnitExt ( Kozlov , false , class_engineer ) ;
1674: LD_ADDR_EXP 73
1678: PUSH
1679: LD_STRING Kozlov
1681: PPUSH
1682: LD_INT 0
1684: PPUSH
1685: LD_INT 2
1687: PPUSH
1688: CALL 5930 0 3
1692: ST_TO_ADDR
// Oblukov := PrepareUnitExt ( Oblukov , false , class_soldier ) ;
1693: LD_ADDR_EXP 74
1697: PUSH
1698: LD_STRING Oblukov
1700: PPUSH
1701: LD_INT 0
1703: PPUSH
1704: LD_INT 1
1706: PPUSH
1707: CALL 5930 0 3
1711: ST_TO_ADDR
// Kapitsova := PrepareUnitExt ( Kapitsova , false , class_scientistic ) ;
1712: LD_ADDR_EXP 75
1716: PUSH
1717: LD_STRING Kapitsova
1719: PPUSH
1720: LD_INT 0
1722: PPUSH
1723: LD_INT 4
1725: PPUSH
1726: CALL 5930 0 3
1730: ST_TO_ADDR
// Popov := PrepareUnitExt ( Popov , false , 0 ) ;
1731: LD_ADDR_EXP 76
1735: PUSH
1736: LD_STRING Popov
1738: PPUSH
1739: LD_INT 0
1741: PPUSH
1742: LD_INT 0
1744: PPUSH
1745: CALL 5930 0 3
1749: ST_TO_ADDR
// PlaceUnitsArea ( [ Burlak , Karamazov , Petrovova , Gleb , Petrosyan , Titov , Dolgov , Lipshchin , Kirilenkova , Belkov , Belkov2 , Xavier , Gnyevko , Kovalyuk , Scholtze , Kuzmov , Kozlov , Oblukov , Kapitsova ] , RussianSpawnArea , false ) ;
1750: LD_EXP 57
1754: PUSH
1755: LD_EXP 58
1759: PUSH
1760: LD_EXP 59
1764: PUSH
1765: LD_EXP 60
1769: PUSH
1770: LD_EXP 61
1774: PUSH
1775: LD_EXP 62
1779: PUSH
1780: LD_EXP 63
1784: PUSH
1785: LD_EXP 64
1789: PUSH
1790: LD_EXP 65
1794: PUSH
1795: LD_EXP 66
1799: PUSH
1800: LD_EXP 67
1804: PUSH
1805: LD_EXP 68
1809: PUSH
1810: LD_EXP 69
1814: PUSH
1815: LD_EXP 70
1819: PUSH
1820: LD_EXP 71
1824: PUSH
1825: LD_EXP 72
1829: PUSH
1830: LD_EXP 73
1834: PUSH
1835: LD_EXP 74
1839: PUSH
1840: LD_EXP 75
1844: PUSH
1845: EMPTY
1846: LIST
1847: LIST
1848: LIST
1849: LIST
1850: LIST
1851: LIST
1852: LIST
1853: LIST
1854: LIST
1855: LIST
1856: LIST
1857: LIST
1858: LIST
1859: LIST
1860: LIST
1861: LIST
1862: LIST
1863: LIST
1864: LIST
1865: PPUSH
1866: LD_INT 2
1868: PPUSH
1869: LD_INT 0
1871: PPUSH
1872: CALL 6204 0 3
// PrepareVehicles ;
1876: CALL 2417 0 0
// other_survivors = CreateCharacterSet ( 07_other_survivors ) ;
1880: LD_ADDR_VAR 0 4
1884: PUSH
1885: LD_STRING 07_other_survivors
1887: PPUSH
1888: CALL_OW 31
1892: ST_TO_ADDR
// other_survivors = other_survivors ^ CreateCharacterSet ( 04_other_survivors ) ;
1893: LD_ADDR_VAR 0 4
1897: PUSH
1898: LD_VAR 0 4
1902: PUSH
1903: LD_STRING 04_other_survivors
1905: PPUSH
1906: CALL_OW 31
1910: ADD
1911: ST_TO_ADDR
// other_survivors = other_survivors ^ CreateCharacterSet ( 04_other_survivors_with_popov ) ;
1912: LD_ADDR_VAR 0 4
1916: PUSH
1917: LD_VAR 0 4
1921: PUSH
1922: LD_STRING 04_other_survivors_with_popov
1924: PPUSH
1925: CALL_OW 31
1929: ADD
1930: ST_TO_ADDR
// for un in other_survivors do
1931: LD_ADDR_VAR 0 3
1935: PUSH
1936: LD_VAR 0 4
1940: PUSH
1941: FOR_IN
1942: IFFALSE 2028
// begin emptyVeh = FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] , [ f_empty ] ] ) ;
1944: LD_ADDR_VAR 0 6
1948: PUSH
1949: LD_INT 22
1951: PUSH
1952: LD_INT 3
1954: PUSH
1955: EMPTY
1956: LIST
1957: LIST
1958: PUSH
1959: LD_INT 21
1961: PUSH
1962: LD_INT 2
1964: PUSH
1965: EMPTY
1966: LIST
1967: LIST
1968: PUSH
1969: LD_INT 58
1971: PUSH
1972: EMPTY
1973: LIST
1974: PUSH
1975: EMPTY
1976: LIST
1977: LIST
1978: LIST
1979: PPUSH
1980: CALL_OW 69
1984: ST_TO_ADDR
// if emptyVeh then
1985: LD_VAR 0 6
1989: IFFALSE 2011
// PlaceHumanInUnit ( un , emptyVeh [ 1 ] ) else
1991: LD_VAR 0 3
1995: PPUSH
1996: LD_VAR 0 6
2000: PUSH
2001: LD_INT 1
2003: ARRAY
2004: PPUSH
2005: CALL_OW 52
2009: GO 2026
// PlaceUnitArea ( un , RussianSpawnArea , false ) ;
2011: LD_VAR 0 3
2015: PPUSH
2016: LD_INT 2
2018: PPUSH
2019: LD_INT 0
2021: PPUSH
2022: CALL_OW 49
// end ;
2026: GO 1941
2028: POP
2029: POP
// yourUnits = FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_nation , nation_russian ] ] ) ;
2030: LD_ADDR_VAR 0 5
2034: PUSH
2035: LD_INT 22
2037: PUSH
2038: LD_INT 3
2040: PUSH
2041: EMPTY
2042: LIST
2043: LIST
2044: PUSH
2045: LD_INT 21
2047: PUSH
2048: LD_INT 1
2050: PUSH
2051: EMPTY
2052: LIST
2053: LIST
2054: PUSH
2055: LD_INT 23
2057: PUSH
2058: LD_INT 3
2060: PUSH
2061: EMPTY
2062: LIST
2063: LIST
2064: PUSH
2065: EMPTY
2066: LIST
2067: LIST
2068: LIST
2069: PPUSH
2070: CALL_OW 69
2074: ST_TO_ADDR
// if yourUnits < 15 then
2075: LD_VAR 0 5
2079: PUSH
2080: LD_INT 15
2082: LESS
2083: IFFALSE 2232
// for i := 1 to 15 - yourUnits do
2085: LD_ADDR_VAR 0 2
2089: PUSH
2090: DOUBLE
2091: LD_INT 1
2093: DEC
2094: ST_TO_ADDR
2095: LD_INT 15
2097: PUSH
2098: LD_VAR 0 5
2102: MINUS
2103: PUSH
2104: FOR_TO
2105: IFFALSE 2230
// begin PrepareHuman ( false , rand ( 1 , 4 ) , rand ( 2 , 4 ) ) ;
2107: LD_INT 0
2109: PPUSH
2110: LD_INT 1
2112: PPUSH
2113: LD_INT 4
2115: PPUSH
2116: CALL_OW 12
2120: PPUSH
2121: LD_INT 2
2123: PPUSH
2124: LD_INT 4
2126: PPUSH
2127: CALL_OW 12
2131: PPUSH
2132: CALL_OW 380
// un = CreateHuman ;
2136: LD_ADDR_VAR 0 3
2140: PUSH
2141: CALL_OW 44
2145: ST_TO_ADDR
// emptyVeh = FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] , [ f_empty ] ] ) ;
2146: LD_ADDR_VAR 0 6
2150: PUSH
2151: LD_INT 22
2153: PUSH
2154: LD_INT 3
2156: PUSH
2157: EMPTY
2158: LIST
2159: LIST
2160: PUSH
2161: LD_INT 21
2163: PUSH
2164: LD_INT 2
2166: PUSH
2167: EMPTY
2168: LIST
2169: LIST
2170: PUSH
2171: LD_INT 58
2173: PUSH
2174: EMPTY
2175: LIST
2176: PUSH
2177: EMPTY
2178: LIST
2179: LIST
2180: LIST
2181: PPUSH
2182: CALL_OW 69
2186: ST_TO_ADDR
// if emptyVeh then
2187: LD_VAR 0 6
2191: IFFALSE 2213
// PlaceHumanInUnit ( un , emptyVeh [ 1 ] ) else
2193: LD_VAR 0 3
2197: PPUSH
2198: LD_VAR 0 6
2202: PUSH
2203: LD_INT 1
2205: ARRAY
2206: PPUSH
2207: CALL_OW 52
2211: GO 2228
// PlaceUnitArea ( un , RussianSpawnArea , false ) ;
2213: LD_VAR 0 3
2217: PPUSH
2218: LD_INT 2
2220: PPUSH
2221: LD_INT 0
2223: PPUSH
2224: CALL_OW 49
// end ;
2228: GO 2104
2230: POP
2231: POP
// yourUnits = FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_nation , nation_russian ] ] ) ;
2232: LD_ADDR_VAR 0 5
2236: PUSH
2237: LD_INT 22
2239: PUSH
2240: LD_INT 3
2242: PUSH
2243: EMPTY
2244: LIST
2245: LIST
2246: PUSH
2247: LD_INT 21
2249: PUSH
2250: LD_INT 1
2252: PUSH
2253: EMPTY
2254: LIST
2255: LIST
2256: PUSH
2257: LD_INT 23
2259: PUSH
2260: LD_INT 3
2262: PUSH
2263: EMPTY
2264: LIST
2265: LIST
2266: PUSH
2267: EMPTY
2268: LIST
2269: LIST
2270: LIST
2271: PPUSH
2272: CALL_OW 69
2276: ST_TO_ADDR
// if not UnitFilter ( yourUnits , [ f_class , class_engineer ] ) then
2277: LD_VAR 0 5
2281: PPUSH
2282: LD_INT 25
2284: PUSH
2285: LD_INT 2
2287: PUSH
2288: EMPTY
2289: LIST
2290: LIST
2291: PPUSH
2292: CALL_OW 72
2296: NOT
2297: IFFALSE 2315
// SetClass ( yourUnits [ 1 ] , 2 ) ;
2299: LD_VAR 0 5
2303: PUSH
2304: LD_INT 1
2306: ARRAY
2307: PPUSH
2308: LD_INT 2
2310: PPUSH
2311: CALL_OW 336
// end ;
2315: LD_VAR 0 1
2319: RET
// export function PrepareRussianEscort ; var i , unit ; begin
2320: LD_INT 0
2322: PPUSH
2323: PPUSH
2324: PPUSH
// uc_side = 6 ;
2325: LD_ADDR_OWVAR 20
2329: PUSH
2330: LD_INT 6
2332: ST_TO_ADDR
// uc_nation = 3 ;
2333: LD_ADDR_OWVAR 21
2337: PUSH
2338: LD_INT 3
2340: ST_TO_ADDR
// for i := 1 to 2 do
2341: LD_ADDR_VAR 0 2
2345: PUSH
2346: DOUBLE
2347: LD_INT 1
2349: DEC
2350: ST_TO_ADDR
2351: LD_INT 2
2353: PUSH
2354: FOR_TO
2355: IFFALSE 2410
// begin PrepareSoldier ( false , 4 ) ;
2357: LD_INT 0
2359: PPUSH
2360: LD_INT 4
2362: PPUSH
2363: CALL_OW 381
// unit = CreateHuman ;
2367: LD_ADDR_VAR 0 3
2371: PUSH
2372: CALL_OW 44
2376: ST_TO_ADDR
// russianEscort = russianEscort ^ unit ;
2377: LD_ADDR_EXP 77
2381: PUSH
2382: LD_EXP 77
2386: PUSH
2387: LD_VAR 0 3
2391: ADD
2392: ST_TO_ADDR
// PlaceUnitArea ( unit , RussianSpawn2Area , false ) ;
2393: LD_VAR 0 3
2397: PPUSH
2398: LD_INT 7
2400: PPUSH
2401: LD_INT 0
2403: PPUSH
2404: CALL_OW 49
// end ;
2408: GO 2354
2410: POP
2411: POP
// end ;
2412: LD_VAR 0 1
2416: RET
// function PrepareVehicles ; var i , veh ; begin
2417: LD_INT 0
2419: PPUSH
2420: PPUSH
2421: PPUSH
// uc_side = 3 ;
2422: LD_ADDR_OWVAR 20
2426: PUSH
2427: LD_INT 3
2429: ST_TO_ADDR
// uc_nation = 3 ;
2430: LD_ADDR_OWVAR 21
2434: PUSH
2435: LD_INT 3
2437: ST_TO_ADDR
// for i := 1 to 5 do
2438: LD_ADDR_VAR 0 2
2442: PUSH
2443: DOUBLE
2444: LD_INT 1
2446: DEC
2447: ST_TO_ADDR
2448: LD_INT 5
2450: PUSH
2451: FOR_TO
2452: IFFALSE 2562
// begin PrepareVehicle ( ru_medium_wheeled , engine_combustion , control_manual , ru_cargo_bay , rand ( 60 , 80 ) ) ;
2454: LD_INT 21
2456: PPUSH
2457: LD_INT 1
2459: PPUSH
2460: LD_INT 1
2462: PPUSH
2463: LD_INT 51
2465: PPUSH
2466: LD_INT 60
2468: PPUSH
2469: LD_INT 80
2471: PPUSH
2472: CALL_OW 12
2476: PPUSH
2477: CALL 24088 0 5
// veh = CreateVehicle ;
2481: LD_ADDR_VAR 0 3
2485: PUSH
2486: CALL_OW 45
2490: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
2491: LD_VAR 0 3
2495: PPUSH
2496: LD_INT 4
2498: PPUSH
2499: CALL_OW 233
// PlaceUnitArea ( veh , RussianSpawnArea , false ) ;
2503: LD_VAR 0 3
2507: PPUSH
2508: LD_INT 2
2510: PPUSH
2511: LD_INT 0
2513: PPUSH
2514: CALL_OW 49
// if ( i <> 5 ) then
2518: LD_VAR 0 2
2522: PUSH
2523: LD_INT 5
2525: NONEQUAL
2526: IFFALSE 2545
// AddCargo ( veh , mat_cans , 100 ) else
2528: LD_VAR 0 3
2532: PPUSH
2533: LD_INT 1
2535: PPUSH
2536: LD_INT 100
2538: PPUSH
2539: CALL_OW 291
2543: GO 2560
// AddCargo ( veh , mat_oil , 100 ) ;
2545: LD_VAR 0 3
2549: PPUSH
2550: LD_INT 2
2552: PPUSH
2553: LD_INT 100
2555: PPUSH
2556: CALL_OW 291
// end ;
2560: GO 2451
2562: POP
2563: POP
// PrepareVehicle ( ru_medium_wheeled , engine_combustion , control_manual , ru_crane , rand ( 60 , 80 ) ) ;
2564: LD_INT 21
2566: PPUSH
2567: LD_INT 1
2569: PPUSH
2570: LD_INT 1
2572: PPUSH
2573: LD_INT 52
2575: PPUSH
2576: LD_INT 60
2578: PPUSH
2579: LD_INT 80
2581: PPUSH
2582: CALL_OW 12
2586: PPUSH
2587: CALL 24088 0 5
// veh = CreateVehicle ;
2591: LD_ADDR_VAR 0 3
2595: PUSH
2596: CALL_OW 45
2600: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
2601: LD_VAR 0 3
2605: PPUSH
2606: LD_INT 4
2608: PPUSH
2609: CALL_OW 233
// PlaceUnitArea ( veh , RussianSpawnArea , false ) ;
2613: LD_VAR 0 3
2617: PPUSH
2618: LD_INT 2
2620: PPUSH
2621: LD_INT 0
2623: PPUSH
2624: CALL_OW 49
// for i := 1 to 3 do
2628: LD_ADDR_VAR 0 2
2632: PUSH
2633: DOUBLE
2634: LD_INT 1
2636: DEC
2637: ST_TO_ADDR
2638: LD_INT 3
2640: PUSH
2641: FOR_TO
2642: IFFALSE 2710
// begin PrepareVehicle ( ru_heavy_tracked , engine_combustion , control_manual , ru_bulldozer , rand ( 60 , 80 ) ) ;
2644: LD_INT 24
2646: PPUSH
2647: LD_INT 1
2649: PPUSH
2650: LD_INT 1
2652: PPUSH
2653: LD_INT 53
2655: PPUSH
2656: LD_INT 60
2658: PPUSH
2659: LD_INT 80
2661: PPUSH
2662: CALL_OW 12
2666: PPUSH
2667: CALL 24088 0 5
// veh = CreateVehicle ;
2671: LD_ADDR_VAR 0 3
2675: PUSH
2676: CALL_OW 45
2680: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
2681: LD_VAR 0 3
2685: PPUSH
2686: LD_INT 4
2688: PPUSH
2689: CALL_OW 233
// PlaceUnitArea ( veh , RussianSpawnArea , false ) ;
2693: LD_VAR 0 3
2697: PPUSH
2698: LD_INT 2
2700: PPUSH
2701: LD_INT 0
2703: PPUSH
2704: CALL_OW 49
// end ;
2708: GO 2641
2710: POP
2711: POP
// end ;
2712: LD_VAR 0 1
2716: RET
// function InitRussianRequiments ; var i ; begin
2717: LD_INT 0
2719: PPUSH
2720: PPUSH
// availableWeapons = [ ru_heavy_machine_gun , ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher ] ;
2721: LD_ADDR_EXP 11
2725: PUSH
2726: LD_INT 42
2728: PUSH
2729: LD_INT 43
2731: PUSH
2732: LD_INT 44
2734: PUSH
2735: LD_INT 46
2737: PUSH
2738: LD_INT 45
2740: PUSH
2741: EMPTY
2742: LIST
2743: LIST
2744: LIST
2745: LIST
2746: LIST
2747: ST_TO_ADDR
// for i := 1 to availableWeapons do
2748: LD_ADDR_VAR 0 2
2752: PUSH
2753: DOUBLE
2754: LD_INT 1
2756: DEC
2757: ST_TO_ADDR
2758: LD_EXP 11
2762: PUSH
2763: FOR_TO
2764: IFFALSE 2804
// weaponsData = weaponsData ^ [ [ availableWeapons [ i ] , false , false ] ] ;
2766: LD_ADDR_EXP 12
2770: PUSH
2771: LD_EXP 12
2775: PUSH
2776: LD_EXP 11
2780: PUSH
2781: LD_VAR 0 2
2785: ARRAY
2786: PUSH
2787: LD_INT 0
2789: PUSH
2790: LD_INT 0
2792: PUSH
2793: EMPTY
2794: LIST
2795: LIST
2796: LIST
2797: PUSH
2798: EMPTY
2799: LIST
2800: ADD
2801: ST_TO_ADDR
2802: GO 2763
2804: POP
2805: POP
// for i := 0 to 50 do
2806: LD_ADDR_VAR 0 2
2810: PUSH
2811: DOUBLE
2812: LD_INT 0
2814: DEC
2815: ST_TO_ADDR
2816: LD_INT 50
2818: PUSH
2819: FOR_TO
2820: IFFALSE 2858
// if GetRestrict ( i , 3 ) = state_enabled then
2822: LD_VAR 0 2
2826: PPUSH
2827: LD_INT 3
2829: PPUSH
2830: CALL_OW 323
2834: PUSH
2835: LD_INT 1
2837: EQUAL
2838: IFFALSE 2856
// buildingsToBuild = buildingsToBuild ^ i ;
2840: LD_ADDR_EXP 8
2844: PUSH
2845: LD_EXP 8
2849: PUSH
2850: LD_VAR 0 2
2854: ADD
2855: ST_TO_ADDR
2856: GO 2819
2858: POP
2859: POP
// buildingsToBuild = buildingsToBuild diff [ 0 , 2 , 4 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 14 , 22 , 31 , 32 , 33 , 39 , 40 ] ;
2860: LD_ADDR_EXP 8
2864: PUSH
2865: LD_EXP 8
2869: PUSH
2870: LD_INT 0
2872: PUSH
2873: LD_INT 2
2875: PUSH
2876: LD_INT 4
2878: PUSH
2879: LD_INT 6
2881: PUSH
2882: LD_INT 7
2884: PUSH
2885: LD_INT 8
2887: PUSH
2888: LD_INT 9
2890: PUSH
2891: LD_INT 10
2893: PUSH
2894: LD_INT 11
2896: PUSH
2897: LD_INT 12
2899: PUSH
2900: LD_INT 14
2902: PUSH
2903: LD_INT 22
2905: PUSH
2906: LD_INT 31
2908: PUSH
2909: LD_INT 32
2911: PUSH
2912: LD_INT 33
2914: PUSH
2915: LD_INT 39
2917: PUSH
2918: LD_INT 40
2920: PUSH
2921: EMPTY
2922: LIST
2923: LIST
2924: LIST
2925: LIST
2926: LIST
2927: LIST
2928: LIST
2929: LIST
2930: LIST
2931: LIST
2932: LIST
2933: LIST
2934: LIST
2935: LIST
2936: LIST
2937: LIST
2938: LIST
2939: DIFF
2940: ST_TO_ADDR
// allBuildings = buildingsToBuild ;
2941: LD_ADDR_EXP 13
2945: PUSH
2946: LD_EXP 8
2950: ST_TO_ADDR
// techsToResearch = GetTechNation ( 3 , nation_russian , state_enabled ) ;
2951: LD_ADDR_EXP 9
2955: PUSH
2956: LD_INT 3
2958: PPUSH
2959: LD_INT 3
2961: PPUSH
2962: LD_INT 1
2964: PPUSH
2965: CALL 19287 0 3
2969: ST_TO_ADDR
// end ; end_of_file
2970: LD_VAR 0 1
2974: RET
// export amAttackTeam ; export function PrepareAmericans ; begin
2975: LD_INT 0
2977: PPUSH
// amAttackTeam = [ ] ;
2978: LD_ADDR_EXP 78
2982: PUSH
2983: EMPTY
2984: ST_TO_ADDR
// SpawnAmericansSnipers ;
2985: CALL 3119 0 0
// case Difficulty of 2 :
2989: LD_OWVAR 67
2993: PUSH
2994: LD_INT 2
2996: DOUBLE
2997: EQUAL
2998: IFTRUE 3002
3000: GO 3031
3002: POP
// begin SetTech ( tech_comp1 , 1 , state_researched ) ;
3003: LD_INT 57
3005: PPUSH
3006: LD_INT 1
3008: PPUSH
3009: LD_INT 2
3011: PPUSH
3012: CALL_OW 322
// SetTech ( tech_opto1 , 1 , state_researched ) ;
3016: LD_INT 60
3018: PPUSH
3019: LD_INT 1
3021: PPUSH
3022: LD_INT 2
3024: PPUSH
3025: CALL_OW 322
// end ; 3 .. 4 :
3029: GO 3114
3031: LD_INT 3
3033: DOUBLE
3034: GREATEREQUAL
3035: IFFALSE 3043
3037: LD_INT 4
3039: DOUBLE
3040: LESSEQUAL
3041: IFTRUE 3045
3043: GO 3113
3045: POP
// begin SetTech ( tech_comp1 , 1 , state_researched ) ;
3046: LD_INT 57
3048: PPUSH
3049: LD_INT 1
3051: PPUSH
3052: LD_INT 2
3054: PPUSH
3055: CALL_OW 322
// SetTech ( tech_comp2 , 1 , state_researched ) ;
3059: LD_INT 58
3061: PPUSH
3062: LD_INT 1
3064: PPUSH
3065: LD_INT 2
3067: PPUSH
3068: CALL_OW 322
// SetTech ( tech_weap3 , 1 , state_researched ) ;
3072: LD_INT 53
3074: PPUSH
3075: LD_INT 1
3077: PPUSH
3078: LD_INT 2
3080: PPUSH
3081: CALL_OW 322
// SetTech ( tech_opto1 , 1 , state_researched ) ;
3085: LD_INT 60
3087: PPUSH
3088: LD_INT 1
3090: PPUSH
3091: LD_INT 2
3093: PPUSH
3094: CALL_OW 322
// SetTech ( tech_opto2 , 1 , state_researched ) ;
3098: LD_INT 61
3100: PPUSH
3101: LD_INT 1
3103: PPUSH
3104: LD_INT 2
3106: PPUSH
3107: CALL_OW 322
// end ; end ;
3111: GO 3114
3113: POP
// end ;
3114: LD_VAR 0 1
3118: RET
// export function SpawnAmericansSnipers ; var i , un ; begin
3119: LD_INT 0
3121: PPUSH
3122: PPUSH
3123: PPUSH
// uc_side = 1 ;
3124: LD_ADDR_OWVAR 20
3128: PUSH
3129: LD_INT 1
3131: ST_TO_ADDR
// uc_nation = 1 ;
3132: LD_ADDR_OWVAR 21
3136: PUSH
3137: LD_INT 1
3139: ST_TO_ADDR
// for i := 1 to 8 do
3140: LD_ADDR_VAR 0 2
3144: PUSH
3145: DOUBLE
3146: LD_INT 1
3148: DEC
3149: ST_TO_ADDR
3150: LD_INT 8
3152: PUSH
3153: FOR_TO
3154: IFFALSE 3207
// begin PrepareHuman ( false , class_sniper , enemySkillLevel ) ;
3156: LD_INT 0
3158: PPUSH
3159: LD_INT 5
3161: PPUSH
3162: LD_EXP 56
3166: PPUSH
3167: CALL_OW 380
// un = CreateHuman ;
3171: LD_ADDR_VAR 0 3
3175: PUSH
3176: CALL_OW 44
3180: ST_TO_ADDR
// PlaceUnitArea ( un , AmericansSnipersSpawnArea , false ) ;
3181: LD_VAR 0 3
3185: PPUSH
3186: LD_INT 14
3188: PPUSH
3189: LD_INT 0
3191: PPUSH
3192: CALL_OW 49
// ComHold ( un ) ;
3196: LD_VAR 0 3
3200: PPUSH
3201: CALL_OW 140
// end ;
3205: GO 3153
3207: POP
3208: POP
// end ;
3209: LD_VAR 0 1
3213: RET
// export function SpawnAmAttackTeam ; var i , unit , veh , randVehType , weapon , chassis , amSolds , amSnipers , amVehs ; begin
3214: LD_INT 0
3216: PPUSH
3217: PPUSH
3218: PPUSH
3219: PPUSH
3220: PPUSH
3221: PPUSH
3222: PPUSH
3223: PPUSH
3224: PPUSH
3225: PPUSH
// uc_side = 1 ;
3226: LD_ADDR_OWVAR 20
3230: PUSH
3231: LD_INT 1
3233: ST_TO_ADDR
// uc_nation = 1 ;
3234: LD_ADDR_OWVAR 21
3238: PUSH
3239: LD_INT 1
3241: ST_TO_ADDR
// amSolds = Rand ( enemyAttackUnitsData [ 1 ] [ 2 ] , enemyAttackUnitsData [ 1 ] [ 3 ] ) ;
3242: LD_ADDR_VAR 0 8
3246: PUSH
3247: LD_EXP 53
3251: PUSH
3252: LD_INT 1
3254: ARRAY
3255: PUSH
3256: LD_INT 2
3258: ARRAY
3259: PPUSH
3260: LD_EXP 53
3264: PUSH
3265: LD_INT 1
3267: ARRAY
3268: PUSH
3269: LD_INT 3
3271: ARRAY
3272: PPUSH
3273: CALL_OW 12
3277: ST_TO_ADDR
// amSnipers = Rand ( enemyAttackUnitsData [ 1 ] [ 4 ] , enemyAttackUnitsData [ 1 ] [ 5 ] ) ;
3278: LD_ADDR_VAR 0 9
3282: PUSH
3283: LD_EXP 53
3287: PUSH
3288: LD_INT 1
3290: ARRAY
3291: PUSH
3292: LD_INT 4
3294: ARRAY
3295: PPUSH
3296: LD_EXP 53
3300: PUSH
3301: LD_INT 1
3303: ARRAY
3304: PUSH
3305: LD_INT 5
3307: ARRAY
3308: PPUSH
3309: CALL_OW 12
3313: ST_TO_ADDR
// amVehs = Rand ( enemyAttackUnitsData [ 1 ] [ 6 ] , enemyAttackUnitsData [ 1 ] [ 7 ] ) ;
3314: LD_ADDR_VAR 0 10
3318: PUSH
3319: LD_EXP 53
3323: PUSH
3324: LD_INT 1
3326: ARRAY
3327: PUSH
3328: LD_INT 6
3330: ARRAY
3331: PPUSH
3332: LD_EXP 53
3336: PUSH
3337: LD_INT 1
3339: ARRAY
3340: PUSH
3341: LD_INT 7
3343: ARRAY
3344: PPUSH
3345: CALL_OW 12
3349: ST_TO_ADDR
// if paidLegionOffert then
3350: LD_EXP 32
3354: IFFALSE 3388
// begin amSolds = amSolds - legionReduceAmericansUnits ;
3356: LD_ADDR_VAR 0 8
3360: PUSH
3361: LD_VAR 0 8
3365: PUSH
3366: LD_EXP 51
3370: MINUS
3371: ST_TO_ADDR
// amVehs = amVehs - legionReduceAmericansUnits ;
3372: LD_ADDR_VAR 0 10
3376: PUSH
3377: LD_VAR 0 10
3381: PUSH
3382: LD_EXP 51
3386: MINUS
3387: ST_TO_ADDR
// end ; for i := 1 to amSolds do
3388: LD_ADDR_VAR 0 2
3392: PUSH
3393: DOUBLE
3394: LD_INT 1
3396: DEC
3397: ST_TO_ADDR
3398: LD_VAR 0 8
3402: PUSH
3403: FOR_TO
3404: IFFALSE 3461
// begin PrepareSoldier ( false , enemySkillLevel ) ;
3406: LD_INT 0
3408: PPUSH
3409: LD_EXP 56
3413: PPUSH
3414: CALL_OW 381
// unit = CreateHuman ;
3418: LD_ADDR_VAR 0 3
3422: PUSH
3423: CALL_OW 44
3427: ST_TO_ADDR
// PlaceUnitArea ( unit , AmericanSpawnArea , false ) ;
3428: LD_VAR 0 3
3432: PPUSH
3433: LD_INT 3
3435: PPUSH
3436: LD_INT 0
3438: PPUSH
3439: CALL_OW 49
// amAttackTeam = amAttackTeam ^ unit ;
3443: LD_ADDR_EXP 78
3447: PUSH
3448: LD_EXP 78
3452: PUSH
3453: LD_VAR 0 3
3457: ADD
3458: ST_TO_ADDR
// end ;
3459: GO 3403
3461: POP
3462: POP
// for i := 1 to amSnipers do
3463: LD_ADDR_VAR 0 2
3467: PUSH
3468: DOUBLE
3469: LD_INT 1
3471: DEC
3472: ST_TO_ADDR
3473: LD_VAR 0 9
3477: PUSH
3478: FOR_TO
3479: IFFALSE 3539
// begin PrepareHuman ( false , class_sniper , enemySkillLevel ) ;
3481: LD_INT 0
3483: PPUSH
3484: LD_INT 5
3486: PPUSH
3487: LD_EXP 56
3491: PPUSH
3492: CALL_OW 380
// unit = CreateHuman ;
3496: LD_ADDR_VAR 0 3
3500: PUSH
3501: CALL_OW 44
3505: ST_TO_ADDR
// PlaceUnitArea ( unit , AmericanSpawnArea , false ) ;
3506: LD_VAR 0 3
3510: PPUSH
3511: LD_INT 3
3513: PPUSH
3514: LD_INT 0
3516: PPUSH
3517: CALL_OW 49
// amAttackTeam = amAttackTeam ^ unit ;
3521: LD_ADDR_EXP 78
3525: PUSH
3526: LD_EXP 78
3530: PUSH
3531: LD_VAR 0 3
3535: ADD
3536: ST_TO_ADDR
// end ;
3537: GO 3478
3539: POP
3540: POP
// for i := 1 to amVehs do
3541: LD_ADDR_VAR 0 2
3545: PUSH
3546: DOUBLE
3547: LD_INT 1
3549: DEC
3550: ST_TO_ADDR
3551: LD_VAR 0 10
3555: PUSH
3556: FOR_TO
3557: IFFALSE 3840
// begin randVehType = Rand ( 1 , 4 ) ;
3559: LD_ADDR_VAR 0 5
3563: PUSH
3564: LD_INT 1
3566: PPUSH
3567: LD_INT 4
3569: PPUSH
3570: CALL_OW 12
3574: ST_TO_ADDR
// weapon = [ us_gatling_gun , us_double_gun , us_light_gun , us_rocket_launcher , us_heavy_gun ] [ Rand ( 1 , 5 ) ] ;
3575: LD_ADDR_VAR 0 6
3579: PUSH
3580: LD_INT 4
3582: PUSH
3583: LD_INT 5
3585: PUSH
3586: LD_INT 3
3588: PUSH
3589: LD_INT 7
3591: PUSH
3592: LD_INT 6
3594: PUSH
3595: EMPTY
3596: LIST
3597: LIST
3598: LIST
3599: LIST
3600: LIST
3601: PUSH
3602: LD_INT 1
3604: PPUSH
3605: LD_INT 5
3607: PPUSH
3608: CALL_OW 12
3612: ARRAY
3613: ST_TO_ADDR
// if weapon = us_heavy_gun then
3614: LD_VAR 0 6
3618: PUSH
3619: LD_INT 6
3621: EQUAL
3622: IFFALSE 3634
// chassis = us_heavy_tracked else
3624: LD_ADDR_VAR 0 7
3628: PUSH
3629: LD_INT 4
3631: ST_TO_ADDR
3632: GO 3661
// chassis = [ us_medium_tracked , us_heavy_tracked ] [ Rand ( 1 , 2 ) ] ;
3634: LD_ADDR_VAR 0 7
3638: PUSH
3639: LD_INT 3
3641: PUSH
3642: LD_INT 4
3644: PUSH
3645: EMPTY
3646: LIST
3647: LIST
3648: PUSH
3649: LD_INT 1
3651: PPUSH
3652: LD_INT 2
3654: PPUSH
3655: CALL_OW 12
3659: ARRAY
3660: ST_TO_ADDR
// if randVehType = 1 then
3661: LD_VAR 0 5
3665: PUSH
3666: LD_INT 1
3668: EQUAL
3669: IFFALSE 3704
// PrepareVehicle ( chassis , engine_combustion , control_manual , weapon , Rand ( 70 , 90 ) ) else
3671: LD_VAR 0 7
3675: PPUSH
3676: LD_INT 1
3678: PPUSH
3679: LD_INT 1
3681: PPUSH
3682: LD_VAR 0 6
3686: PPUSH
3687: LD_INT 70
3689: PPUSH
3690: LD_INT 90
3692: PPUSH
3693: CALL_OW 12
3697: PPUSH
3698: CALL 24088 0 5
3702: GO 3735
// PrepareVehicle ( chassis , engine_combustion , control_computer , weapon , Rand ( 70 , 90 ) ) ;
3704: LD_VAR 0 7
3708: PPUSH
3709: LD_INT 1
3711: PPUSH
3712: LD_INT 3
3714: PPUSH
3715: LD_VAR 0 6
3719: PPUSH
3720: LD_INT 70
3722: PPUSH
3723: LD_INT 90
3725: PPUSH
3726: CALL_OW 12
3730: PPUSH
3731: CALL 24088 0 5
// veh = CreateVehicle ;
3735: LD_ADDR_VAR 0 4
3739: PUSH
3740: CALL_OW 45
3744: ST_TO_ADDR
// PlaceUnitArea ( veh , AmericanSpawnArea , false ) ;
3745: LD_VAR 0 4
3749: PPUSH
3750: LD_INT 3
3752: PPUSH
3753: LD_INT 0
3755: PPUSH
3756: CALL_OW 49
// amAttackTeam = amAttackTeam ^ veh ;
3760: LD_ADDR_EXP 78
3764: PUSH
3765: LD_EXP 78
3769: PUSH
3770: LD_VAR 0 4
3774: ADD
3775: ST_TO_ADDR
// if randVehType = 1 then
3776: LD_VAR 0 5
3780: PUSH
3781: LD_INT 1
3783: EQUAL
3784: IFFALSE 3838
// begin PrepareMechanic ( false , enemySkillLevel ) ;
3786: LD_INT 0
3788: PPUSH
3789: LD_EXP 56
3793: PPUSH
3794: CALL_OW 383
// unit = CreateHuman ;
3798: LD_ADDR_VAR 0 3
3802: PUSH
3803: CALL_OW 44
3807: ST_TO_ADDR
// PlaceHumanInUnit ( unit , veh ) ;
3808: LD_VAR 0 3
3812: PPUSH
3813: LD_VAR 0 4
3817: PPUSH
3818: CALL_OW 52
// amAttackTeam = amAttackTeam ^ unit ;
3822: LD_ADDR_EXP 78
3826: PUSH
3827: LD_EXP 78
3831: PUSH
3832: LD_VAR 0 3
3836: ADD
3837: ST_TO_ADDR
// end ; end ;
3838: GO 3556
3840: POP
3841: POP
// end ; end_of_file
3842: LD_VAR 0 1
3846: RET
// export Heike , Kurt , Dietrich ; export KurtEng ; export GensherTeam ; export arAttackTeam ; export function PrepareArabians ; begin
3847: LD_INT 0
3849: PPUSH
// arAttackTeam = [ ] ;
3850: LD_ADDR_EXP 84
3854: PUSH
3855: EMPTY
3856: ST_TO_ADDR
// PrepareHeroes ;
3857: CALL 4262 0 0
// case Difficulty of 2 :
3861: LD_OWVAR 67
3865: PUSH
3866: LD_INT 2
3868: DOUBLE
3869: EQUAL
3870: IFTRUE 3874
3872: GO 3890
3874: POP
// begin SetTech ( tech_stimDrugs , 8 , state_researched ) ;
3875: LD_INT 5
3877: PPUSH
3878: LD_INT 8
3880: PPUSH
3881: LD_INT 2
3883: PPUSH
3884: CALL_OW 322
// end ; 3 :
3888: GO 3941
3890: LD_INT 3
3892: DOUBLE
3893: EQUAL
3894: IFTRUE 3898
3896: GO 3940
3898: POP
// begin SetTech ( tech_stimDrugs , 8 , state_researched ) ;
3899: LD_INT 5
3901: PPUSH
3902: LD_INT 8
3904: PPUSH
3905: LD_INT 2
3907: PPUSH
3908: CALL_OW 322
// SetTech ( tech_bio1 , 8 , state_researched ) ;
3912: LD_INT 66
3914: PPUSH
3915: LD_INT 8
3917: PPUSH
3918: LD_INT 2
3920: PPUSH
3921: CALL_OW 322
// SetTech ( tech_weap3 , 8 , state_researched ) ;
3925: LD_INT 53
3927: PPUSH
3928: LD_INT 8
3930: PPUSH
3931: LD_INT 2
3933: PPUSH
3934: CALL_OW 322
// end ; end ;
3938: GO 3941
3940: POP
// end ;
3941: LD_VAR 0 1
3945: RET
// export function SpawnGensherTeam ; var i , driver , veh ; begin
3946: LD_INT 0
3948: PPUSH
3949: PPUSH
3950: PPUSH
3951: PPUSH
// GensherTeam = [ ] ;
3952: LD_ADDR_EXP 83
3956: PUSH
3957: EMPTY
3958: ST_TO_ADDR
// uc_side = 2 ;
3959: LD_ADDR_OWVAR 20
3963: PUSH
3964: LD_INT 2
3966: ST_TO_ADDR
// uc_nation = 2 ;
3967: LD_ADDR_OWVAR 21
3971: PUSH
3972: LD_INT 2
3974: ST_TO_ADDR
// for i := 1 to 3 do
3975: LD_ADDR_VAR 0 2
3979: PUSH
3980: DOUBLE
3981: LD_INT 1
3983: DEC
3984: ST_TO_ADDR
3985: LD_INT 3
3987: PUSH
3988: FOR_TO
3989: IFFALSE 4148
// begin PrepareSoldier ( sex_male , rand ( 3 , 5 ) ) ;
3991: LD_INT 1
3993: PPUSH
3994: LD_INT 3
3996: PPUSH
3997: LD_INT 5
3999: PPUSH
4000: CALL_OW 12
4004: PPUSH
4005: CALL_OW 381
// driver = CreateHuman ;
4009: LD_ADDR_VAR 0 3
4013: PUSH
4014: CALL_OW 44
4018: ST_TO_ADDR
// PrepareVehicle ( ar_medium_trike , engine_combustion , control_manual , ar_cargo_bay , rand ( 50 , 70 ) ) ;
4019: LD_INT 13
4021: PPUSH
4022: LD_INT 1
4024: PPUSH
4025: LD_INT 1
4027: PPUSH
4028: LD_INT 32
4030: PPUSH
4031: LD_INT 50
4033: PPUSH
4034: LD_INT 70
4036: PPUSH
4037: CALL_OW 12
4041: PPUSH
4042: CALL 24088 0 5
// veh = CreateVehicle ;
4046: LD_ADDR_VAR 0 4
4050: PUSH
4051: CALL_OW 45
4055: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
4056: LD_VAR 0 4
4060: PPUSH
4061: LD_INT 4
4063: PPUSH
4064: CALL_OW 233
// PlaceUnitArea ( veh , GensherSpawnArea , false ) ;
4068: LD_VAR 0 4
4072: PPUSH
4073: LD_INT 4
4075: PPUSH
4076: LD_INT 0
4078: PPUSH
4079: CALL_OW 49
// PlaceHumanInUnit ( driver , veh ) ;
4083: LD_VAR 0 3
4087: PPUSH
4088: LD_VAR 0 4
4092: PPUSH
4093: CALL_OW 52
// AddCargo ( veh , i , 100 ) ;
4097: LD_VAR 0 4
4101: PPUSH
4102: LD_VAR 0 2
4106: PPUSH
4107: LD_INT 100
4109: PPUSH
4110: CALL_OW 291
// GensherTeam = GensherTeam ^ driver ;
4114: LD_ADDR_EXP 83
4118: PUSH
4119: LD_EXP 83
4123: PUSH
4124: LD_VAR 0 3
4128: ADD
4129: ST_TO_ADDR
// GensherTeam = GensherTeam ^ veh ;
4130: LD_ADDR_EXP 83
4134: PUSH
4135: LD_EXP 83
4139: PUSH
4140: LD_VAR 0 4
4144: ADD
4145: ST_TO_ADDR
// end ;
4146: GO 3988
4148: POP
4149: POP
// if IsOK ( KurtEng ) and GetSide ( KurtEng ) = 3 then
4150: LD_EXP 82
4154: PPUSH
4155: CALL_OW 302
4159: PUSH
4160: LD_EXP 82
4164: PPUSH
4165: CALL_OW 255
4169: PUSH
4170: LD_INT 3
4172: EQUAL
4173: AND
4174: IFFALSE 4208
// begin GensherTargetX = GetX ( Kurt ) ;
4176: LD_ADDR_EXP 16
4180: PUSH
4181: LD_EXP 80
4185: PPUSH
4186: CALL_OW 250
4190: ST_TO_ADDR
// GensherTargetY = GetY ( Kurt ) ;
4191: LD_ADDR_EXP 17
4195: PUSH
4196: LD_EXP 80
4200: PPUSH
4201: CALL_OW 251
4205: ST_TO_ADDR
// end else
4206: GO 4238
// begin GensherTargetX = GetX ( Burlak ) ;
4208: LD_ADDR_EXP 16
4212: PUSH
4213: LD_EXP 57
4217: PPUSH
4218: CALL_OW 250
4222: ST_TO_ADDR
// GensherTargetY = GetY ( Burlak ) ;
4223: LD_ADDR_EXP 17
4227: PUSH
4228: LD_EXP 57
4232: PPUSH
4233: CALL_OW 251
4237: ST_TO_ADDR
// end ; ComMoveXY ( GensherTeam , GensherTargetX , GensherTargetY ) ;
4238: LD_EXP 83
4242: PPUSH
4243: LD_EXP 16
4247: PPUSH
4248: LD_EXP 17
4252: PPUSH
4253: CALL_OW 111
// end ;
4257: LD_VAR 0 1
4261: RET
// function PrepareHeroes ; begin
4262: LD_INT 0
4264: PPUSH
// uc_side = 5 ;
4265: LD_ADDR_OWVAR 20
4269: PUSH
4270: LD_INT 5
4272: ST_TO_ADDR
// uc_nation = 2 ;
4273: LD_ADDR_OWVAR 21
4277: PUSH
4278: LD_INT 2
4280: ST_TO_ADDR
// Heike = PrepareUnitExt ( Heike , true , class_engineer ) ;
4281: LD_ADDR_EXP 79
4285: PUSH
4286: LD_STRING Heike
4288: PPUSH
4289: LD_INT 1
4291: PPUSH
4292: LD_INT 2
4294: PPUSH
4295: CALL 5930 0 3
4299: ST_TO_ADDR
// uc_side = 8 ;
4300: LD_ADDR_OWVAR 20
4304: PUSH
4305: LD_INT 8
4307: ST_TO_ADDR
// Kurt = PrepareUnitExt ( Kurt , false , 0 ) ;
4308: LD_ADDR_EXP 80
4312: PUSH
4313: LD_STRING Kurt
4315: PPUSH
4316: LD_INT 0
4318: PPUSH
4319: LD_INT 0
4321: PPUSH
4322: CALL 5930 0 3
4326: ST_TO_ADDR
// uc_side = 2 ;
4327: LD_ADDR_OWVAR 20
4331: PUSH
4332: LD_INT 2
4334: ST_TO_ADDR
// Dietrich = PrepareUnitExt ( Dietrich , false , 0 ) ;
4335: LD_ADDR_EXP 81
4339: PUSH
4340: LD_STRING Dietrich
4342: PPUSH
4343: LD_INT 0
4345: PPUSH
4346: LD_INT 0
4348: PPUSH
4349: CALL 5930 0 3
4353: ST_TO_ADDR
// end ;
4354: LD_VAR 0 1
4358: RET
// export function SpawnArAttackTeam ; var i , unit , veh , weapon , chassis ; begin
4359: LD_INT 0
4361: PPUSH
4362: PPUSH
4363: PPUSH
4364: PPUSH
4365: PPUSH
4366: PPUSH
// uc_side = 8 ;
4367: LD_ADDR_OWVAR 20
4371: PUSH
4372: LD_INT 8
4374: ST_TO_ADDR
// uc_nation = 2 ;
4375: LD_ADDR_OWVAR 21
4379: PUSH
4380: LD_INT 2
4382: ST_TO_ADDR
// for i := 1 to Rand ( enemyAttackUnitsData [ 1 ] [ 2 ] , enemyAttackUnitsData [ 1 ] [ 3 ] ) do
4383: LD_ADDR_VAR 0 2
4387: PUSH
4388: DOUBLE
4389: LD_INT 1
4391: DEC
4392: ST_TO_ADDR
4393: LD_EXP 53
4397: PUSH
4398: LD_INT 1
4400: ARRAY
4401: PUSH
4402: LD_INT 2
4404: ARRAY
4405: PPUSH
4406: LD_EXP 53
4410: PUSH
4411: LD_INT 1
4413: ARRAY
4414: PUSH
4415: LD_INT 3
4417: ARRAY
4418: PPUSH
4419: CALL_OW 12
4423: PUSH
4424: FOR_TO
4425: IFFALSE 4482
// begin PrepareSoldier ( false , enemySkillLevel ) ;
4427: LD_INT 0
4429: PPUSH
4430: LD_EXP 56
4434: PPUSH
4435: CALL_OW 381
// unit = CreateHuman ;
4439: LD_ADDR_VAR 0 3
4443: PUSH
4444: CALL_OW 44
4448: ST_TO_ADDR
// PlaceUnitArea ( unit , KurtUnitsSpawnArea , false ) ;
4449: LD_VAR 0 3
4453: PPUSH
4454: LD_INT 10
4456: PPUSH
4457: LD_INT 0
4459: PPUSH
4460: CALL_OW 49
// arAttackTeam = arAttackTeam ^ unit ;
4464: LD_ADDR_EXP 84
4468: PUSH
4469: LD_EXP 84
4473: PUSH
4474: LD_VAR 0 3
4478: ADD
4479: ST_TO_ADDR
// end ;
4480: GO 4424
4482: POP
4483: POP
// for i := 1 to Rand ( enemyAttackUnitsData [ 1 ] [ 4 ] , enemyAttackUnitsData [ 1 ] [ 5 ] ) do
4484: LD_ADDR_VAR 0 2
4488: PUSH
4489: DOUBLE
4490: LD_INT 1
4492: DEC
4493: ST_TO_ADDR
4494: LD_EXP 53
4498: PUSH
4499: LD_INT 1
4501: ARRAY
4502: PUSH
4503: LD_INT 4
4505: ARRAY
4506: PPUSH
4507: LD_EXP 53
4511: PUSH
4512: LD_INT 1
4514: ARRAY
4515: PUSH
4516: LD_INT 5
4518: ARRAY
4519: PPUSH
4520: CALL_OW 12
4524: PUSH
4525: FOR_TO
4526: IFFALSE 4586
// begin PrepareHuman ( false , class_mortar , enemySkillLevel ) ;
4528: LD_INT 0
4530: PPUSH
4531: LD_INT 8
4533: PPUSH
4534: LD_EXP 56
4538: PPUSH
4539: CALL_OW 380
// unit = CreateHuman ;
4543: LD_ADDR_VAR 0 3
4547: PUSH
4548: CALL_OW 44
4552: ST_TO_ADDR
// PlaceUnitArea ( unit , KurtUnitsSpawnArea , false ) ;
4553: LD_VAR 0 3
4557: PPUSH
4558: LD_INT 10
4560: PPUSH
4561: LD_INT 0
4563: PPUSH
4564: CALL_OW 49
// arAttackTeam = arAttackTeam ^ unit ;
4568: LD_ADDR_EXP 84
4572: PUSH
4573: LD_EXP 84
4577: PUSH
4578: LD_VAR 0 3
4582: ADD
4583: ST_TO_ADDR
// end ;
4584: GO 4525
4586: POP
4587: POP
// for i := 1 to Rand ( enemyAttackUnitsData [ 1 ] [ 6 ] , enemyAttackUnitsData [ 1 ] [ 7 ] ) do
4588: LD_ADDR_VAR 0 2
4592: PUSH
4593: DOUBLE
4594: LD_INT 1
4596: DEC
4597: ST_TO_ADDR
4598: LD_EXP 53
4602: PUSH
4603: LD_INT 1
4605: ARRAY
4606: PUSH
4607: LD_INT 6
4609: ARRAY
4610: PPUSH
4611: LD_EXP 53
4615: PUSH
4616: LD_INT 1
4618: ARRAY
4619: PUSH
4620: LD_INT 7
4622: ARRAY
4623: PPUSH
4624: CALL_OW 12
4628: PUSH
4629: FOR_TO
4630: IFFALSE 4824
// begin weapon = [ ar_gun , ar_flame_thrower , ar_rocket_launcher , ar_light_gun , ar_gatling_gun ] [ Rand ( 1 , 5 ) ] ;
4632: LD_ADDR_VAR 0 5
4636: PUSH
4637: LD_INT 27
4639: PUSH
4640: LD_INT 26
4642: PUSH
4643: LD_INT 28
4645: PUSH
4646: LD_INT 23
4648: PUSH
4649: LD_INT 25
4651: PUSH
4652: EMPTY
4653: LIST
4654: LIST
4655: LIST
4656: LIST
4657: LIST
4658: PUSH
4659: LD_INT 1
4661: PPUSH
4662: LD_INT 5
4664: PPUSH
4665: CALL_OW 12
4669: ARRAY
4670: ST_TO_ADDR
// chassis = [ ar_medium_trike , ar_half_tracked ] [ Rand ( 1 , 2 ) ] ;
4671: LD_ADDR_VAR 0 6
4675: PUSH
4676: LD_INT 13
4678: PUSH
4679: LD_INT 14
4681: PUSH
4682: EMPTY
4683: LIST
4684: LIST
4685: PUSH
4686: LD_INT 1
4688: PPUSH
4689: LD_INT 2
4691: PPUSH
4692: CALL_OW 12
4696: ARRAY
4697: ST_TO_ADDR
// PrepareVehicle ( chassis , engine_combustion , control_manual , weapon , Rand ( 70 , 90 ) ) ;
4698: LD_VAR 0 6
4702: PPUSH
4703: LD_INT 1
4705: PPUSH
4706: LD_INT 1
4708: PPUSH
4709: LD_VAR 0 5
4713: PPUSH
4714: LD_INT 70
4716: PPUSH
4717: LD_INT 90
4719: PPUSH
4720: CALL_OW 12
4724: PPUSH
4725: CALL 24088 0 5
// veh = CreateVehicle ;
4729: LD_ADDR_VAR 0 4
4733: PUSH
4734: CALL_OW 45
4738: ST_TO_ADDR
// PlaceUnitArea ( veh , KurtUnitsSpawnArea , false ) ;
4739: LD_VAR 0 4
4743: PPUSH
4744: LD_INT 10
4746: PPUSH
4747: LD_INT 0
4749: PPUSH
4750: CALL_OW 49
// arAttackTeam = arAttackTeam ^ veh ;
4754: LD_ADDR_EXP 84
4758: PUSH
4759: LD_EXP 84
4763: PUSH
4764: LD_VAR 0 4
4768: ADD
4769: ST_TO_ADDR
// PrepareMechanic ( false , enemySkillLevel ) ;
4770: LD_INT 0
4772: PPUSH
4773: LD_EXP 56
4777: PPUSH
4778: CALL_OW 383
// unit = CreateHuman ;
4782: LD_ADDR_VAR 0 3
4786: PUSH
4787: CALL_OW 44
4791: ST_TO_ADDR
// PlaceHumanInUnit ( unit , veh ) ;
4792: LD_VAR 0 3
4796: PPUSH
4797: LD_VAR 0 4
4801: PPUSH
4802: CALL_OW 52
// arAttackTeam = arAttackTeam ^ unit ;
4806: LD_ADDR_EXP 84
4810: PUSH
4811: LD_EXP 84
4815: PUSH
4816: LD_VAR 0 3
4820: ADD
4821: ST_TO_ADDR
// end ;
4822: GO 4629
4824: POP
4825: POP
// end ; end_of_file
4826: LD_VAR 0 1
4830: RET
// export function Nef_PrepareNature ; var i , un ; begin
4831: LD_INT 0
4833: PPUSH
4834: PPUSH
4835: PPUSH
// for i := 1 to animalsAmount [ 1 ] do
4836: LD_ADDR_VAR 0 2
4840: PUSH
4841: DOUBLE
4842: LD_INT 1
4844: DEC
4845: ST_TO_ADDR
4846: LD_EXP 41
4850: PUSH
4851: LD_INT 1
4853: ARRAY
4854: PUSH
4855: FOR_TO
4856: IFFALSE 4966
// begin uc_side = 0 ;
4858: LD_ADDR_OWVAR 20
4862: PUSH
4863: LD_INT 0
4865: ST_TO_ADDR
// uc_nation = nation_nature ;
4866: LD_ADDR_OWVAR 21
4870: PUSH
4871: LD_INT 0
4873: ST_TO_ADDR
// hc_class = class_apeman ;
4874: LD_ADDR_OWVAR 28
4878: PUSH
4879: LD_INT 12
4881: ST_TO_ADDR
// hc_skills = [ animalsStats [ 1 ] , animalsStats [ 2 ] , animalsStats [ 3 ] , animalsStats [ 4 ] ] ;
4882: LD_ADDR_OWVAR 31
4886: PUSH
4887: LD_EXP 42
4891: PUSH
4892: LD_INT 1
4894: ARRAY
4895: PUSH
4896: LD_EXP 42
4900: PUSH
4901: LD_INT 2
4903: ARRAY
4904: PUSH
4905: LD_EXP 42
4909: PUSH
4910: LD_INT 3
4912: ARRAY
4913: PUSH
4914: LD_EXP 42
4918: PUSH
4919: LD_INT 4
4921: ARRAY
4922: PUSH
4923: EMPTY
4924: LIST
4925: LIST
4926: LIST
4927: LIST
4928: ST_TO_ADDR
// hc_agressivity = animalsAgression ;
4929: LD_ADDR_OWVAR 35
4933: PUSH
4934: LD_EXP 43
4938: ST_TO_ADDR
// un = CreateHuman ;
4939: LD_ADDR_VAR 0 3
4943: PUSH
4944: CALL_OW 44
4948: ST_TO_ADDR
// PlaceUnitArea ( un , NatureArea , false ) ;
4949: LD_VAR 0 3
4953: PPUSH
4954: LD_INT 5
4956: PPUSH
4957: LD_INT 0
4959: PPUSH
4960: CALL_OW 49
// end ;
4964: GO 4855
4966: POP
4967: POP
// for i := 1 to animalsAmount [ 2 ] do
4968: LD_ADDR_VAR 0 2
4972: PUSH
4973: DOUBLE
4974: LD_INT 1
4976: DEC
4977: ST_TO_ADDR
4978: LD_EXP 41
4982: PUSH
4983: LD_INT 2
4985: ARRAY
4986: PUSH
4987: FOR_TO
4988: IFFALSE 5098
// begin uc_side = 0 ;
4990: LD_ADDR_OWVAR 20
4994: PUSH
4995: LD_INT 0
4997: ST_TO_ADDR
// uc_nation = nation_nature ;
4998: LD_ADDR_OWVAR 21
5002: PUSH
5003: LD_INT 0
5005: ST_TO_ADDR
// hc_class = class_phororhacos ;
5006: LD_ADDR_OWVAR 28
5010: PUSH
5011: LD_INT 18
5013: ST_TO_ADDR
// hc_skills = [ animalsStats [ 1 ] , animalsStats [ 2 ] , animalsStats [ 3 ] , animalsStats [ 4 ] ] ;
5014: LD_ADDR_OWVAR 31
5018: PUSH
5019: LD_EXP 42
5023: PUSH
5024: LD_INT 1
5026: ARRAY
5027: PUSH
5028: LD_EXP 42
5032: PUSH
5033: LD_INT 2
5035: ARRAY
5036: PUSH
5037: LD_EXP 42
5041: PUSH
5042: LD_INT 3
5044: ARRAY
5045: PUSH
5046: LD_EXP 42
5050: PUSH
5051: LD_INT 4
5053: ARRAY
5054: PUSH
5055: EMPTY
5056: LIST
5057: LIST
5058: LIST
5059: LIST
5060: ST_TO_ADDR
// hc_agressivity = animalsAgression ;
5061: LD_ADDR_OWVAR 35
5065: PUSH
5066: LD_EXP 43
5070: ST_TO_ADDR
// un = CreateHuman ;
5071: LD_ADDR_VAR 0 3
5075: PUSH
5076: CALL_OW 44
5080: ST_TO_ADDR
// PlaceUnitArea ( un , NatureArea , false ) ;
5081: LD_VAR 0 3
5085: PPUSH
5086: LD_INT 5
5088: PPUSH
5089: LD_INT 0
5091: PPUSH
5092: CALL_OW 49
// end ;
5096: GO 4987
5098: POP
5099: POP
// for i := 1 to animalsAmount [ 3 ] do
5100: LD_ADDR_VAR 0 2
5104: PUSH
5105: DOUBLE
5106: LD_INT 1
5108: DEC
5109: ST_TO_ADDR
5110: LD_EXP 41
5114: PUSH
5115: LD_INT 3
5117: ARRAY
5118: PUSH
5119: FOR_TO
5120: IFFALSE 5230
// begin uc_side = 0 ;
5122: LD_ADDR_OWVAR 20
5126: PUSH
5127: LD_INT 0
5129: ST_TO_ADDR
// uc_nation = nation_nature ;
5130: LD_ADDR_OWVAR 21
5134: PUSH
5135: LD_INT 0
5137: ST_TO_ADDR
// hc_class = class_tiger ;
5138: LD_ADDR_OWVAR 28
5142: PUSH
5143: LD_INT 14
5145: ST_TO_ADDR
// hc_skills = [ animalsStats [ 1 ] , animalsStats [ 2 ] , animalsStats [ 3 ] , animalsStats [ 4 ] ] ;
5146: LD_ADDR_OWVAR 31
5150: PUSH
5151: LD_EXP 42
5155: PUSH
5156: LD_INT 1
5158: ARRAY
5159: PUSH
5160: LD_EXP 42
5164: PUSH
5165: LD_INT 2
5167: ARRAY
5168: PUSH
5169: LD_EXP 42
5173: PUSH
5174: LD_INT 3
5176: ARRAY
5177: PUSH
5178: LD_EXP 42
5182: PUSH
5183: LD_INT 4
5185: ARRAY
5186: PUSH
5187: EMPTY
5188: LIST
5189: LIST
5190: LIST
5191: LIST
5192: ST_TO_ADDR
// hc_agressivity = animalsAgression ;
5193: LD_ADDR_OWVAR 35
5197: PUSH
5198: LD_EXP 43
5202: ST_TO_ADDR
// un = CreateHuman ;
5203: LD_ADDR_VAR 0 3
5207: PUSH
5208: CALL_OW 44
5212: ST_TO_ADDR
// PlaceUnitArea ( un , NatureArea , false ) ;
5213: LD_VAR 0 3
5217: PPUSH
5218: LD_INT 5
5220: PPUSH
5221: LD_INT 0
5223: PPUSH
5224: CALL_OW 49
// end ;
5228: GO 5119
5230: POP
5231: POP
// for i := 1 to animalsAmount [ 4 ] do
5232: LD_ADDR_VAR 0 2
5236: PUSH
5237: DOUBLE
5238: LD_INT 1
5240: DEC
5241: ST_TO_ADDR
5242: LD_EXP 41
5246: PUSH
5247: LD_INT 4
5249: ARRAY
5250: PUSH
5251: FOR_TO
5252: IFFALSE 5362
// begin uc_side = 0 ;
5254: LD_ADDR_OWVAR 20
5258: PUSH
5259: LD_INT 0
5261: ST_TO_ADDR
// uc_nation = nation_nature ;
5262: LD_ADDR_OWVAR 21
5266: PUSH
5267: LD_INT 0
5269: ST_TO_ADDR
// hc_class = 21 ;
5270: LD_ADDR_OWVAR 28
5274: PUSH
5275: LD_INT 21
5277: ST_TO_ADDR
// hc_skills = [ animalsStats [ 1 ] , animalsStats [ 2 ] , animalsStats [ 3 ] , animalsStats [ 4 ] ] ;
5278: LD_ADDR_OWVAR 31
5282: PUSH
5283: LD_EXP 42
5287: PUSH
5288: LD_INT 1
5290: ARRAY
5291: PUSH
5292: LD_EXP 42
5296: PUSH
5297: LD_INT 2
5299: ARRAY
5300: PUSH
5301: LD_EXP 42
5305: PUSH
5306: LD_INT 3
5308: ARRAY
5309: PUSH
5310: LD_EXP 42
5314: PUSH
5315: LD_INT 4
5317: ARRAY
5318: PUSH
5319: EMPTY
5320: LIST
5321: LIST
5322: LIST
5323: LIST
5324: ST_TO_ADDR
// hc_agressivity = animalsAgression ;
5325: LD_ADDR_OWVAR 35
5329: PUSH
5330: LD_EXP 43
5334: ST_TO_ADDR
// un = CreateHuman ;
5335: LD_ADDR_VAR 0 3
5339: PUSH
5340: CALL_OW 44
5344: ST_TO_ADDR
// PlaceUnitArea ( un , NatureArea , false ) ;
5345: LD_VAR 0 3
5349: PPUSH
5350: LD_INT 5
5352: PPUSH
5353: LD_INT 0
5355: PPUSH
5356: CALL_OW 49
// end ;
5360: GO 5251
5362: POP
5363: POP
// for i := 1 to animalsAmount [ 5 ] do
5364: LD_ADDR_VAR 0 2
5368: PUSH
5369: DOUBLE
5370: LD_INT 1
5372: DEC
5373: ST_TO_ADDR
5374: LD_EXP 41
5378: PUSH
5379: LD_INT 5
5381: ARRAY
5382: PUSH
5383: FOR_TO
5384: IFFALSE 5445
// begin uc_side = 0 ;
5386: LD_ADDR_OWVAR 20
5390: PUSH
5391: LD_INT 0
5393: ST_TO_ADDR
// uc_nation = nation_nature ;
5394: LD_ADDR_OWVAR 21
5398: PUSH
5399: LD_INT 0
5401: ST_TO_ADDR
// vc_chassis := 31 ;
5402: LD_ADDR_OWVAR 37
5406: PUSH
5407: LD_INT 31
5409: ST_TO_ADDR
// vc_control := control_rider ;
5410: LD_ADDR_OWVAR 38
5414: PUSH
5415: LD_INT 4
5417: ST_TO_ADDR
// un := CreateVehicle ;
5418: LD_ADDR_VAR 0 3
5422: PUSH
5423: CALL_OW 45
5427: ST_TO_ADDR
// PlaceUnitArea ( un , NatureArea , false ) ;
5428: LD_VAR 0 3
5432: PPUSH
5433: LD_INT 5
5435: PPUSH
5436: LD_INT 0
5438: PPUSH
5439: CALL_OW 49
// end ;
5443: GO 5383
5445: POP
5446: POP
// end ;
5447: LD_VAR 0 1
5451: RET
// export function SpawnTrees ; begin
5452: LD_INT 0
5454: PPUSH
// PlaceTreesToArea ( TreeArea , [ 2 , 10 , 11 , 27 , 35 ] , 40 , 10 , 4 ) ;
5455: LD_INT 1
5457: PPUSH
5458: LD_INT 2
5460: PUSH
5461: LD_INT 10
5463: PUSH
5464: LD_INT 11
5466: PUSH
5467: LD_INT 27
5469: PUSH
5470: LD_INT 35
5472: PUSH
5473: EMPTY
5474: LIST
5475: LIST
5476: LIST
5477: LIST
5478: LIST
5479: PPUSH
5480: LD_INT 40
5482: PPUSH
5483: LD_INT 10
5485: PPUSH
5486: LD_INT 4
5488: PPUSH
5489: CALL_OW 352
// PlaceTreesToArea ( TreeArea , [ 9 , 10 , 27 , 35 , 48 ] , 30 , 10 , 4 ) ;
5493: LD_INT 1
5495: PPUSH
5496: LD_INT 9
5498: PUSH
5499: LD_INT 10
5501: PUSH
5502: LD_INT 27
5504: PUSH
5505: LD_INT 35
5507: PUSH
5508: LD_INT 48
5510: PUSH
5511: EMPTY
5512: LIST
5513: LIST
5514: LIST
5515: LIST
5516: LIST
5517: PPUSH
5518: LD_INT 30
5520: PPUSH
5521: LD_INT 10
5523: PPUSH
5524: LD_INT 4
5526: PPUSH
5527: CALL_OW 352
// PlaceTreesToArea ( TreeArea , [ 2 , 9 , 10 , 11 , 27 ] , 60 , 10 , 4 ) ;
5531: LD_INT 1
5533: PPUSH
5534: LD_INT 2
5536: PUSH
5537: LD_INT 9
5539: PUSH
5540: LD_INT 10
5542: PUSH
5543: LD_INT 11
5545: PUSH
5546: LD_INT 27
5548: PUSH
5549: EMPTY
5550: LIST
5551: LIST
5552: LIST
5553: LIST
5554: LIST
5555: PPUSH
5556: LD_INT 60
5558: PPUSH
5559: LD_INT 10
5561: PPUSH
5562: LD_INT 4
5564: PPUSH
5565: CALL_OW 352
// PlaceTreesToArea ( TreeArea , [ 9 , 10 , 27 , 35 , 48 ] , 90 , 10 , 4 ) ;
5569: LD_INT 1
5571: PPUSH
5572: LD_INT 9
5574: PUSH
5575: LD_INT 10
5577: PUSH
5578: LD_INT 27
5580: PUSH
5581: LD_INT 35
5583: PUSH
5584: LD_INT 48
5586: PUSH
5587: EMPTY
5588: LIST
5589: LIST
5590: LIST
5591: LIST
5592: LIST
5593: PPUSH
5594: LD_INT 90
5596: PPUSH
5597: LD_INT 10
5599: PPUSH
5600: LD_INT 4
5602: PPUSH
5603: CALL_OW 352
// PlaceTreesToArea ( TreeArea , [ 2 , 9 , 10 , 11 , 48 ] , 120 , 10 , 4 ) ;
5607: LD_INT 1
5609: PPUSH
5610: LD_INT 2
5612: PUSH
5613: LD_INT 9
5615: PUSH
5616: LD_INT 10
5618: PUSH
5619: LD_INT 11
5621: PUSH
5622: LD_INT 48
5624: PUSH
5625: EMPTY
5626: LIST
5627: LIST
5628: LIST
5629: LIST
5630: LIST
5631: PPUSH
5632: LD_INT 120
5634: PPUSH
5635: LD_INT 10
5637: PPUSH
5638: LD_INT 4
5640: PPUSH
5641: CALL_OW 352
// PlaceTreesToArea ( TreeArea , [ 2 , 11 , 27 , 35 , 48 ] , 45 , 10 , 4 ) ;
5645: LD_INT 1
5647: PPUSH
5648: LD_INT 2
5650: PUSH
5651: LD_INT 11
5653: PUSH
5654: LD_INT 27
5656: PUSH
5657: LD_INT 35
5659: PUSH
5660: LD_INT 48
5662: PUSH
5663: EMPTY
5664: LIST
5665: LIST
5666: LIST
5667: LIST
5668: LIST
5669: PPUSH
5670: LD_INT 45
5672: PPUSH
5673: LD_INT 10
5675: PPUSH
5676: LD_INT 4
5678: PPUSH
5679: CALL_OW 352
// end ;
5683: LD_VAR 0 1
5687: RET
// every 0 0$1 do var i , un ;
5688: GO 5690
5690: DISABLE
5691: LD_INT 0
5693: PPUSH
5694: PPUSH
// begin if ( GetTech ( tech_apelang , 3 ) = state_enabled or GetTech ( tech_apepsych , 3 ) = state_enabled or GetTech ( tech_apeagres , 3 ) = state_enabled ) and not FilterAllUnits ( [ [ f_or , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman_soldier ] ] ] ) then
5695: LD_INT 1
5697: PPUSH
5698: LD_INT 3
5700: PPUSH
5701: CALL_OW 321
5705: PUSH
5706: LD_INT 1
5708: EQUAL
5709: PUSH
5710: LD_INT 2
5712: PPUSH
5713: LD_INT 3
5715: PPUSH
5716: CALL_OW 321
5720: PUSH
5721: LD_INT 1
5723: EQUAL
5724: OR
5725: PUSH
5726: LD_INT 11
5728: PPUSH
5729: LD_INT 3
5731: PPUSH
5732: CALL_OW 321
5736: PUSH
5737: LD_INT 1
5739: EQUAL
5740: OR
5741: PUSH
5742: LD_INT 2
5744: PUSH
5745: LD_INT 25
5747: PUSH
5748: LD_INT 12
5750: PUSH
5751: EMPTY
5752: LIST
5753: LIST
5754: PUSH
5755: LD_INT 25
5757: PUSH
5758: LD_INT 16
5760: PUSH
5761: EMPTY
5762: LIST
5763: LIST
5764: PUSH
5765: LD_INT 25
5767: PUSH
5768: LD_INT 15
5770: PUSH
5771: EMPTY
5772: LIST
5773: LIST
5774: PUSH
5775: EMPTY
5776: LIST
5777: LIST
5778: LIST
5779: LIST
5780: PUSH
5781: EMPTY
5782: LIST
5783: PPUSH
5784: CALL_OW 69
5788: NOT
5789: AND
5790: IFFALSE 5926
// begin for i := 1 to Rand ( 2 , 4 ) do
5792: LD_ADDR_VAR 0 1
5796: PUSH
5797: DOUBLE
5798: LD_INT 1
5800: DEC
5801: ST_TO_ADDR
5802: LD_INT 2
5804: PPUSH
5805: LD_INT 4
5807: PPUSH
5808: CALL_OW 12
5812: PUSH
5813: FOR_TO
5814: IFFALSE 5924
// begin uc_side = 0 ;
5816: LD_ADDR_OWVAR 20
5820: PUSH
5821: LD_INT 0
5823: ST_TO_ADDR
// uc_nation = nation_nature ;
5824: LD_ADDR_OWVAR 21
5828: PUSH
5829: LD_INT 0
5831: ST_TO_ADDR
// hc_class = class_apeman ;
5832: LD_ADDR_OWVAR 28
5836: PUSH
5837: LD_INT 12
5839: ST_TO_ADDR
// hc_skills = [ animalsStats [ 1 ] , animalsStats [ 2 ] , animalsStats [ 3 ] , animalsStats [ 4 ] ] ;
5840: LD_ADDR_OWVAR 31
5844: PUSH
5845: LD_EXP 42
5849: PUSH
5850: LD_INT 1
5852: ARRAY
5853: PUSH
5854: LD_EXP 42
5858: PUSH
5859: LD_INT 2
5861: ARRAY
5862: PUSH
5863: LD_EXP 42
5867: PUSH
5868: LD_INT 3
5870: ARRAY
5871: PUSH
5872: LD_EXP 42
5876: PUSH
5877: LD_INT 4
5879: ARRAY
5880: PUSH
5881: EMPTY
5882: LIST
5883: LIST
5884: LIST
5885: LIST
5886: ST_TO_ADDR
// hc_agressivity = animalsAgression ;
5887: LD_ADDR_OWVAR 35
5891: PUSH
5892: LD_EXP 43
5896: ST_TO_ADDR
// un = CreateHuman ;
5897: LD_ADDR_VAR 0 2
5901: PUSH
5902: CALL_OW 44
5906: ST_TO_ADDR
// PlaceUnitArea ( un , NatureArea , false ) ;
5907: LD_VAR 0 2
5911: PPUSH
5912: LD_INT 5
5914: PPUSH
5915: LD_INT 0
5917: PPUSH
5918: CALL_OW 49
// end ;
5922: GO 5813
5924: POP
5925: POP
// end ; enable ;
5926: ENABLE
// end ; end_of_file
5927: PPOPN 2
5929: END
// export function PrepareUnitExt ( ident , exist_mode , class ) ; var unit ; begin
5930: LD_INT 0
5932: PPUSH
5933: PPUSH
// if debugMode then
5934: LD_EXP 46
5938: IFFALSE 5955
// unit := NewCharacter ( ident ) ;
5940: LD_ADDR_VAR 0 5
5944: PUSH
5945: LD_VAR 0 1
5949: PPUSH
5950: CALL_OW 25
5954: ST_TO_ADDR
// if exist_mode and not debugMode then
5955: LD_VAR 0 2
5959: PUSH
5960: LD_EXP 46
5964: NOT
5965: AND
5966: IFFALSE 5991
// unit := CreateCharacter ( previousMissionPrefix & ident ) else
5968: LD_ADDR_VAR 0 5
5972: PUSH
5973: LD_EXP 45
5977: PUSH
5978: LD_VAR 0 1
5982: STR
5983: PPUSH
5984: CALL_OW 34
5988: ST_TO_ADDR
5989: GO 6013
// if not debugMode then
5991: LD_EXP 46
5995: NOT
5996: IFFALSE 6013
// unit := NewCharacter ( ident ) ;
5998: LD_ADDR_VAR 0 5
6002: PUSH
6003: LD_VAR 0 1
6007: PPUSH
6008: CALL_OW 25
6012: ST_TO_ADDR
// if class then
6013: LD_VAR 0 3
6017: IFFALSE 6033
// SetClass ( unit , class ) ;
6019: LD_VAR 0 5
6023: PPUSH
6024: LD_VAR 0 3
6028: PPUSH
6029: CALL_OW 336
// result := unit ;
6033: LD_ADDR_VAR 0 4
6037: PUSH
6038: LD_VAR 0 5
6042: ST_TO_ADDR
// end ;
6043: LD_VAR 0 4
6047: RET
// export function ExtSaveCharacter ( character , characterStringID , side ) ; begin
6048: LD_INT 0
6050: PPUSH
// if GetSide ( character ) = side and not IsDead ( character ) then
6051: LD_VAR 0 1
6055: PPUSH
6056: CALL_OW 255
6060: PUSH
6061: LD_VAR 0 3
6065: EQUAL
6066: PUSH
6067: LD_VAR 0 1
6071: PPUSH
6072: CALL_OW 301
6076: NOT
6077: AND
6078: IFFALSE 6100
// SaveCharacters ( character , missionPrefix & characterStringID ) ;
6080: LD_VAR 0 1
6084: PPUSH
6085: LD_EXP 44
6089: PUSH
6090: LD_VAR 0 2
6094: STR
6095: PPUSH
6096: CALL_OW 38
// end ;
6100: LD_VAR 0 4
6104: RET
// export function ExtSaveCharacters ( characters , charactersStringID , side ) ; var unit , resultCharactersToSave ; begin
6105: LD_INT 0
6107: PPUSH
6108: PPUSH
6109: PPUSH
// resultCharactersToSave = [ ] ;
6110: LD_ADDR_VAR 0 6
6114: PUSH
6115: EMPTY
6116: ST_TO_ADDR
// for unit in characters do
6117: LD_ADDR_VAR 0 5
6121: PUSH
6122: LD_VAR 0 1
6126: PUSH
6127: FOR_IN
6128: IFFALSE 6177
// if GetSide ( unit ) = side and not IsDead ( unit ) then
6130: LD_VAR 0 5
6134: PPUSH
6135: CALL_OW 255
6139: PUSH
6140: LD_VAR 0 3
6144: EQUAL
6145: PUSH
6146: LD_VAR 0 5
6150: PPUSH
6151: CALL_OW 301
6155: NOT
6156: AND
6157: IFFALSE 6175
// resultCharactersToSave = resultCharactersToSave ^ unit ;
6159: LD_ADDR_VAR 0 6
6163: PUSH
6164: LD_VAR 0 6
6168: PUSH
6169: LD_VAR 0 5
6173: ADD
6174: ST_TO_ADDR
6175: GO 6127
6177: POP
6178: POP
// SaveCharacters ( resultCharactersToSave , missionPrefix & charactersStringID ) ;
6179: LD_VAR 0 6
6183: PPUSH
6184: LD_EXP 44
6188: PUSH
6189: LD_VAR 0 2
6193: STR
6194: PPUSH
6195: CALL_OW 38
// end ;
6199: LD_VAR 0 4
6203: RET
// export function PlaceUnitsArea ( units , area , spawnMode ) ; var unit ; begin
6204: LD_INT 0
6206: PPUSH
6207: PPUSH
// for unit in units do
6208: LD_ADDR_VAR 0 5
6212: PUSH
6213: LD_VAR 0 1
6217: PUSH
6218: FOR_IN
6219: IFFALSE 6242
// PlaceUnitArea ( unit , area , spawnMode ) ;
6221: LD_VAR 0 5
6225: PPUSH
6226: LD_VAR 0 2
6230: PPUSH
6231: LD_VAR 0 3
6235: PPUSH
6236: CALL_OW 49
6240: GO 6218
6242: POP
6243: POP
// end ;
6244: LD_VAR 0 4
6248: RET
// export function DialogRandom ( characters , dialogMID , dialogFID , radio , canTalkHero ) ; var i , speaker , units ; begin
6249: LD_INT 0
6251: PPUSH
6252: PPUSH
6253: PPUSH
6254: PPUSH
// units = characters ;
6255: LD_ADDR_VAR 0 9
6259: PUSH
6260: LD_VAR 0 1
6264: ST_TO_ADDR
// units := units diff [ Burlak , Karamazov , Petrovova , Gleb , Petrosyan , Titov , Dolgov , Lipshchin , Kirilenkova ] ;
6265: LD_ADDR_VAR 0 9
6269: PUSH
6270: LD_VAR 0 9
6274: PUSH
6275: LD_EXP 57
6279: PUSH
6280: LD_EXP 58
6284: PUSH
6285: LD_EXP 59
6289: PUSH
6290: LD_EXP 60
6294: PUSH
6295: LD_EXP 61
6299: PUSH
6300: LD_EXP 62
6304: PUSH
6305: LD_EXP 63
6309: PUSH
6310: LD_EXP 64
6314: PUSH
6315: LD_EXP 65
6319: PUSH
6320: EMPTY
6321: LIST
6322: LIST
6323: LIST
6324: LIST
6325: LIST
6326: LIST
6327: LIST
6328: LIST
6329: LIST
6330: DIFF
6331: ST_TO_ADDR
// if not units and not canTalkHero then
6332: LD_VAR 0 9
6336: NOT
6337: PUSH
6338: LD_VAR 0 5
6342: NOT
6343: AND
6344: IFFALSE 6348
// exit ;
6346: GO 6521
// if not units then
6348: LD_VAR 0 9
6352: NOT
6353: IFFALSE 6374
// units = characters diff [ Burlak ] ;
6355: LD_ADDR_VAR 0 9
6359: PUSH
6360: LD_VAR 0 1
6364: PUSH
6365: LD_EXP 57
6369: PUSH
6370: EMPTY
6371: LIST
6372: DIFF
6373: ST_TO_ADDR
// if not units and canTalkHero then
6374: LD_VAR 0 9
6378: NOT
6379: PUSH
6380: LD_VAR 0 5
6384: AND
6385: IFFALSE 6389
// exit ;
6387: GO 6521
// speaker := units [ rand ( 1 , units ) ] ;
6389: LD_ADDR_VAR 0 8
6393: PUSH
6394: LD_VAR 0 9
6398: PUSH
6399: LD_INT 1
6401: PPUSH
6402: LD_VAR 0 9
6406: PPUSH
6407: CALL_OW 12
6411: ARRAY
6412: ST_TO_ADDR
// if radio then
6413: LD_VAR 0 4
6417: IFFALSE 6466
// begin if GetSex ( speaker ) = sex_male then
6419: LD_VAR 0 8
6423: PPUSH
6424: CALL_OW 258
6428: PUSH
6429: LD_INT 1
6431: EQUAL
6432: IFFALSE 6450
// SayRadio ( speaker , dialogMID ) else
6434: LD_VAR 0 8
6438: PPUSH
6439: LD_VAR 0 2
6443: PPUSH
6444: CALL_OW 94
6448: GO 6464
// SayRadio ( speaker , dialogFID ) ;
6450: LD_VAR 0 8
6454: PPUSH
6455: LD_VAR 0 3
6459: PPUSH
6460: CALL_OW 94
// end else
6464: GO 6511
// begin if GetSex ( speaker ) = sex_male then
6466: LD_VAR 0 8
6470: PPUSH
6471: CALL_OW 258
6475: PUSH
6476: LD_INT 1
6478: EQUAL
6479: IFFALSE 6497
// Say ( speaker , dialogMID ) else
6481: LD_VAR 0 8
6485: PPUSH
6486: LD_VAR 0 2
6490: PPUSH
6491: CALL_OW 88
6495: GO 6511
// Say ( speaker , dialogFID ) ;
6497: LD_VAR 0 8
6501: PPUSH
6502: LD_VAR 0 3
6506: PPUSH
6507: CALL_OW 88
// end ; result := speaker ;
6511: LD_ADDR_VAR 0 6
6515: PUSH
6516: LD_VAR 0 8
6520: ST_TO_ADDR
// end ;
6521: LD_VAR 0 6
6525: RET
// export function RemoveUnits ( units ) ; var unit ; begin
6526: LD_INT 0
6528: PPUSH
6529: PPUSH
// if not units then
6530: LD_VAR 0 1
6534: NOT
6535: IFFALSE 6539
// exit ;
6537: GO 6685
// if Heike in units then
6539: LD_EXP 79
6543: PUSH
6544: LD_VAR 0 1
6548: IN
6549: IFFALSE 6605
// begin if GetAttitude ( 3 , 8 ) = att_neutral then
6551: LD_INT 3
6553: PPUSH
6554: LD_INT 8
6556: PPUSH
6557: CALL_OW 81
6561: PUSH
6562: LD_INT 0
6564: EQUAL
6565: IFFALSE 6577
// HeikeStatus = 1 else
6567: LD_ADDR_EXP 3
6571: PUSH
6572: LD_INT 1
6574: ST_TO_ADDR
6575: GO 6585
// HeikeStatus = 2 ;
6577: LD_ADDR_EXP 3
6581: PUSH
6582: LD_INT 2
6584: ST_TO_ADDR
// forceStopKurtAttack = true ;
6585: LD_ADDR_EXP 27
6589: PUSH
6590: LD_INT 1
6592: ST_TO_ADDR
// SetClass ( Heike , 1 ) ;
6593: LD_EXP 79
6597: PPUSH
6598: LD_INT 1
6600: PPUSH
6601: CALL_OW 336
// end ; if Kurt in units then
6605: LD_EXP 80
6609: PUSH
6610: LD_VAR 0 1
6614: IN
6615: IFFALSE 6659
// begin if GetAttitude ( 3 , 8 ) = att_neutral then
6617: LD_INT 3
6619: PPUSH
6620: LD_INT 8
6622: PPUSH
6623: CALL_OW 81
6627: PUSH
6628: LD_INT 0
6630: EQUAL
6631: IFFALSE 6643
// KurtStatus = 1 else
6633: LD_ADDR_EXP 22
6637: PUSH
6638: LD_INT 1
6640: ST_TO_ADDR
6641: GO 6659
// begin KurtStatus = 2 ;
6643: LD_ADDR_EXP 22
6647: PUSH
6648: LD_INT 2
6650: ST_TO_ADDR
// KurtAttack = 1 ;
6651: LD_ADDR_EXP 25
6655: PUSH
6656: LD_INT 1
6658: ST_TO_ADDR
// end ; end ; for unit in units do
6659: LD_ADDR_VAR 0 3
6663: PUSH
6664: LD_VAR 0 1
6668: PUSH
6669: FOR_IN
6670: IFFALSE 6683
// RemoveUnit ( unit ) ;
6672: LD_VAR 0 3
6676: PPUSH
6677: CALL_OW 64
6681: GO 6669
6683: POP
6684: POP
// end ;
6685: LD_VAR 0 2
6689: RET
// export function GetAmountWeaponsDataBuildOnTurret ( isBuild ) ; var i , amount ; begin
6690: LD_INT 0
6692: PPUSH
6693: PPUSH
6694: PPUSH
// amount = 0 ;
6695: LD_ADDR_VAR 0 4
6699: PUSH
6700: LD_INT 0
6702: ST_TO_ADDR
// for i := 1 to weaponsData do
6703: LD_ADDR_VAR 0 3
6707: PUSH
6708: DOUBLE
6709: LD_INT 1
6711: DEC
6712: ST_TO_ADDR
6713: LD_EXP 12
6717: PUSH
6718: FOR_TO
6719: IFFALSE 6759
// if weaponsData [ i ] [ 2 ] = isBuild then
6721: LD_EXP 12
6725: PUSH
6726: LD_VAR 0 3
6730: ARRAY
6731: PUSH
6732: LD_INT 2
6734: ARRAY
6735: PUSH
6736: LD_VAR 0 1
6740: EQUAL
6741: IFFALSE 6757
// amount = amount + 1 ;
6743: LD_ADDR_VAR 0 4
6747: PUSH
6748: LD_VAR 0 4
6752: PUSH
6753: LD_INT 1
6755: PLUS
6756: ST_TO_ADDR
6757: GO 6718
6759: POP
6760: POP
// if isBuild then
6761: LD_VAR 0 1
6765: IFFALSE 6785
// if amount >= 3 then
6767: LD_VAR 0 4
6771: PUSH
6772: LD_INT 3
6774: GREATEREQUAL
6775: IFFALSE 6785
// amount = 3 ;
6777: LD_ADDR_VAR 0 4
6781: PUSH
6782: LD_INT 3
6784: ST_TO_ADDR
// result = amount ;
6785: LD_ADDR_VAR 0 2
6789: PUSH
6790: LD_VAR 0 4
6794: ST_TO_ADDR
// end ;
6795: LD_VAR 0 2
6799: RET
// export function GetAmountWeaponsDataBuildOnVehicle ( isBuild ) ; var i , amount ; begin
6800: LD_INT 0
6802: PPUSH
6803: PPUSH
6804: PPUSH
// amount = 0 ;
6805: LD_ADDR_VAR 0 4
6809: PUSH
6810: LD_INT 0
6812: ST_TO_ADDR
// for i := 1 to weaponsData do
6813: LD_ADDR_VAR 0 3
6817: PUSH
6818: DOUBLE
6819: LD_INT 1
6821: DEC
6822: ST_TO_ADDR
6823: LD_EXP 12
6827: PUSH
6828: FOR_TO
6829: IFFALSE 6869
// if weaponsData [ i ] [ 3 ] = isBuild then
6831: LD_EXP 12
6835: PUSH
6836: LD_VAR 0 3
6840: ARRAY
6841: PUSH
6842: LD_INT 3
6844: ARRAY
6845: PUSH
6846: LD_VAR 0 1
6850: EQUAL
6851: IFFALSE 6867
// amount = amount + 1 ;
6853: LD_ADDR_VAR 0 4
6857: PUSH
6858: LD_VAR 0 4
6862: PUSH
6863: LD_INT 1
6865: PLUS
6866: ST_TO_ADDR
6867: GO 6828
6869: POP
6870: POP
// result = amount ;
6871: LD_ADDR_VAR 0 2
6875: PUSH
6876: LD_VAR 0 4
6880: ST_TO_ADDR
// end ;
6881: LD_VAR 0 2
6885: RET
// export function SetWeaponDataBuild ( weapon , turret ) ; var i ; begin
6886: LD_INT 0
6888: PPUSH
6889: PPUSH
// if turret then
6890: LD_VAR 0 2
6894: IFFALSE 6992
// begin for i := 1 to weaponsData do
6896: LD_ADDR_VAR 0 4
6900: PUSH
6901: DOUBLE
6902: LD_INT 1
6904: DEC
6905: ST_TO_ADDR
6906: LD_EXP 12
6910: PUSH
6911: FOR_TO
6912: IFFALSE 6988
// if weaponsData [ i ] [ 1 ] = weapon and weaponsData [ i ] [ 2 ] = false then
6914: LD_EXP 12
6918: PUSH
6919: LD_VAR 0 4
6923: ARRAY
6924: PUSH
6925: LD_INT 1
6927: ARRAY
6928: PUSH
6929: LD_VAR 0 1
6933: EQUAL
6934: PUSH
6935: LD_EXP 12
6939: PUSH
6940: LD_VAR 0 4
6944: ARRAY
6945: PUSH
6946: LD_INT 2
6948: ARRAY
6949: PUSH
6950: LD_INT 0
6952: EQUAL
6953: AND
6954: IFFALSE 6986
// weaponsData = ReplaceIn ( weaponsData , [ i , 2 ] , true ) ;
6956: LD_ADDR_EXP 12
6960: PUSH
6961: LD_EXP 12
6965: PPUSH
6966: LD_VAR 0 4
6970: PUSH
6971: LD_INT 2
6973: PUSH
6974: EMPTY
6975: LIST
6976: LIST
6977: PPUSH
6978: LD_INT 1
6980: PPUSH
6981: CALL 24210 0 3
6985: ST_TO_ADDR
6986: GO 6911
6988: POP
6989: POP
// end else
6990: GO 7086
// begin for i := 1 to weaponsData do
6992: LD_ADDR_VAR 0 4
6996: PUSH
6997: DOUBLE
6998: LD_INT 1
7000: DEC
7001: ST_TO_ADDR
7002: LD_EXP 12
7006: PUSH
7007: FOR_TO
7008: IFFALSE 7084
// if weaponsData [ i ] [ 1 ] = weapon and weaponsData [ i ] [ 3 ] = false then
7010: LD_EXP 12
7014: PUSH
7015: LD_VAR 0 4
7019: ARRAY
7020: PUSH
7021: LD_INT 1
7023: ARRAY
7024: PUSH
7025: LD_VAR 0 1
7029: EQUAL
7030: PUSH
7031: LD_EXP 12
7035: PUSH
7036: LD_VAR 0 4
7040: ARRAY
7041: PUSH
7042: LD_INT 3
7044: ARRAY
7045: PUSH
7046: LD_INT 0
7048: EQUAL
7049: AND
7050: IFFALSE 7082
// weaponsData = ReplaceIn ( weaponsData , [ i , 3 ] , true ) ;
7052: LD_ADDR_EXP 12
7056: PUSH
7057: LD_EXP 12
7061: PPUSH
7062: LD_VAR 0 4
7066: PUSH
7067: LD_INT 3
7069: PUSH
7070: EMPTY
7071: LIST
7072: LIST
7073: PPUSH
7074: LD_INT 1
7076: PPUSH
7077: CALL 24210 0 3
7081: ST_TO_ADDR
7082: GO 7007
7084: POP
7085: POP
// end ; end ;
7086: LD_VAR 0 3
7090: RET
// export function ShootTreningController ; var i , unitsInArea , unit , depots , depot , barrelsAreaList , randIndex , randPosX , randPosY , barrelsInArea ; begin
7091: LD_INT 0
7093: PPUSH
7094: PPUSH
7095: PPUSH
7096: PPUSH
7097: PPUSH
7098: PPUSH
7099: PPUSH
7100: PPUSH
7101: PPUSH
7102: PPUSH
7103: PPUSH
// unitsInArea = FilterUnitsInArea ( ShootArea , [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) ;
7104: LD_ADDR_VAR 0 3
7108: PUSH
7109: LD_INT 12
7111: PPUSH
7112: LD_INT 22
7114: PUSH
7115: LD_INT 3
7117: PUSH
7118: EMPTY
7119: LIST
7120: LIST
7121: PUSH
7122: LD_INT 21
7124: PUSH
7125: LD_INT 1
7127: PUSH
7128: EMPTY
7129: LIST
7130: LIST
7131: PUSH
7132: LD_INT 50
7134: PUSH
7135: EMPTY
7136: LIST
7137: PUSH
7138: LD_INT 3
7140: PUSH
7141: LD_INT 60
7143: PUSH
7144: EMPTY
7145: LIST
7146: PUSH
7147: EMPTY
7148: LIST
7149: LIST
7150: PUSH
7151: EMPTY
7152: LIST
7153: LIST
7154: LIST
7155: LIST
7156: PPUSH
7157: CALL_OW 70
7161: ST_TO_ADDR
// depots = FilterAllUnits ( [ [ f_side , 3 ] , [ f_ok ] , [ f_type , unit_building ] , [ f_not , [ f_constructed ] ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
7162: LD_ADDR_VAR 0 5
7166: PUSH
7167: LD_INT 22
7169: PUSH
7170: LD_INT 3
7172: PUSH
7173: EMPTY
7174: LIST
7175: LIST
7176: PUSH
7177: LD_INT 50
7179: PUSH
7180: EMPTY
7181: LIST
7182: PUSH
7183: LD_INT 21
7185: PUSH
7186: LD_INT 3
7188: PUSH
7189: EMPTY
7190: LIST
7191: LIST
7192: PUSH
7193: LD_INT 3
7195: PUSH
7196: LD_INT 57
7198: PUSH
7199: EMPTY
7200: LIST
7201: PUSH
7202: EMPTY
7203: LIST
7204: LIST
7205: PUSH
7206: LD_INT 2
7208: PUSH
7209: LD_INT 30
7211: PUSH
7212: LD_INT 0
7214: PUSH
7215: EMPTY
7216: LIST
7217: LIST
7218: PUSH
7219: LD_INT 30
7221: PUSH
7222: LD_INT 1
7224: PUSH
7225: EMPTY
7226: LIST
7227: LIST
7228: PUSH
7229: EMPTY
7230: LIST
7231: LIST
7232: LIST
7233: PUSH
7234: EMPTY
7235: LIST
7236: LIST
7237: LIST
7238: LIST
7239: LIST
7240: PPUSH
7241: CALL_OW 69
7245: ST_TO_ADDR
// barrelsAreaList = AreaToList ( BarrelsArea , 0 ) ;
7246: LD_ADDR_VAR 0 7
7250: PUSH
7251: LD_INT 13
7253: PPUSH
7254: LD_INT 0
7256: PPUSH
7257: CALL_OW 517
7261: ST_TO_ADDR
// if not depots or not unitsInArea then
7262: LD_VAR 0 5
7266: NOT
7267: PUSH
7268: LD_VAR 0 3
7272: NOT
7273: OR
7274: IFFALSE 7278
// exit ;
7276: GO 7714
// depot = depots [ 1 ] ;
7278: LD_ADDR_VAR 0 6
7282: PUSH
7283: LD_VAR 0 5
7287: PUSH
7288: LD_INT 1
7290: ARRAY
7291: ST_TO_ADDR
// for unit in unitsInArea do
7292: LD_ADDR_VAR 0 4
7296: PUSH
7297: LD_VAR 0 3
7301: PUSH
7302: FOR_IN
7303: IFFALSE 7712
// begin if not GetClass ( unit ) = class_engineer then
7305: LD_VAR 0 4
7309: PPUSH
7310: CALL_OW 257
7314: PUSH
7315: LD_INT 2
7317: EQUAL
7318: NOT
7319: IFFALSE 7356
// begin ComEnterUnit ( unit , depot ) ;
7321: LD_VAR 0 4
7325: PPUSH
7326: LD_VAR 0 6
7330: PPUSH
7331: CALL_OW 120
// AddComChangeProfession ( unit , class_engineer ) ;
7335: LD_VAR 0 4
7339: PPUSH
7340: LD_INT 2
7342: PPUSH
7343: CALL_OW 183
// AddComExitBuilding ( unit ) ;
7347: LD_VAR 0 4
7351: PPUSH
7352: CALL_OW 182
// end ; if GetCargo ( unit , mat_oil ) = 0 then
7356: LD_VAR 0 4
7360: PPUSH
7361: LD_INT 2
7363: PPUSH
7364: CALL_OW 289
7368: PUSH
7369: LD_INT 0
7371: EQUAL
7372: IFFALSE 7391
// AddComTransport ( unit , depot , mat_oil ) ;
7374: LD_VAR 0 4
7378: PPUSH
7379: LD_VAR 0 6
7383: PPUSH
7384: LD_INT 2
7386: PPUSH
7387: CALL_OW 211
// repeat wait ( 0 0$1 ) ;
7391: LD_INT 35
7393: PPUSH
7394: CALL_OW 67
// until not HasTask ( unit ) ;
7398: LD_VAR 0 4
7402: PPUSH
7403: CALL_OW 314
7407: NOT
7408: IFFALSE 7391
// if GetCargo ( unit , mat_oil ) > 0 then
7410: LD_VAR 0 4
7414: PPUSH
7415: LD_INT 2
7417: PPUSH
7418: CALL_OW 289
7422: PUSH
7423: LD_INT 0
7425: GREATER
7426: IFFALSE 7710
// begin randIndex = Rand ( 1 , barrelsAreaList [ 1 ] ) ;
7428: LD_ADDR_VAR 0 8
7432: PUSH
7433: LD_INT 1
7435: PPUSH
7436: LD_VAR 0 7
7440: PUSH
7441: LD_INT 1
7443: ARRAY
7444: PPUSH
7445: CALL_OW 12
7449: ST_TO_ADDR
// randPosX = barrelsAreaList [ 1 ] [ randIndex ] ;
7450: LD_ADDR_VAR 0 9
7454: PUSH
7455: LD_VAR 0 7
7459: PUSH
7460: LD_INT 1
7462: ARRAY
7463: PUSH
7464: LD_VAR 0 8
7468: ARRAY
7469: ST_TO_ADDR
// randPosY = barrelsAreaList [ 2 ] [ RandIndex ] ;
7470: LD_ADDR_VAR 0 10
7474: PUSH
7475: LD_VAR 0 7
7479: PUSH
7480: LD_INT 2
7482: ARRAY
7483: PUSH
7484: LD_VAR 0 8
7488: ARRAY
7489: ST_TO_ADDR
// AddComMoveXY ( unit , randPosX , randPosY ) ;
7490: LD_VAR 0 4
7494: PPUSH
7495: LD_VAR 0 9
7499: PPUSH
7500: LD_VAR 0 10
7504: PPUSH
7505: CALL_OW 171
// AddComUnload ( unit ) ;
7509: LD_VAR 0 4
7513: PPUSH
7514: CALL_OW 219
// AddComMoveXY ( unit , randPosX + 2 , randPosY + 2 ) ;
7518: LD_VAR 0 4
7522: PPUSH
7523: LD_VAR 0 9
7527: PUSH
7528: LD_INT 2
7530: PLUS
7531: PPUSH
7532: LD_VAR 0 10
7536: PUSH
7537: LD_INT 2
7539: PLUS
7540: PPUSH
7541: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
7545: LD_INT 35
7547: PPUSH
7548: CALL_OW 67
// until not HasTask ( unit ) ;
7552: LD_VAR 0 4
7556: PPUSH
7557: CALL_OW 314
7561: NOT
7562: IFFALSE 7545
// barrelsInArea = GetListOfCratesInArea ( ShootArea ) ;
7564: LD_ADDR_VAR 0 11
7568: PUSH
7569: LD_INT 12
7571: PPUSH
7572: CALL_OW 435
7576: ST_TO_ADDR
// for i := 1 to barrelsInArea / 2 do
7577: LD_ADDR_VAR 0 2
7581: PUSH
7582: DOUBLE
7583: LD_INT 1
7585: DEC
7586: ST_TO_ADDR
7587: LD_VAR 0 11
7591: PUSH
7592: LD_INT 2
7594: DIVREAL
7595: PUSH
7596: FOR_TO
7597: IFFALSE 7708
// begin if GetDistUnitXY ( unit , barrelsInArea [ i ] , barrelsInArea [ i + 1 ] ) <= 6 then
7599: LD_VAR 0 4
7603: PPUSH
7604: LD_VAR 0 11
7608: PUSH
7609: LD_VAR 0 2
7613: ARRAY
7614: PPUSH
7615: LD_VAR 0 11
7619: PUSH
7620: LD_VAR 0 2
7624: PUSH
7625: LD_INT 1
7627: PLUS
7628: ARRAY
7629: PPUSH
7630: CALL_OW 297
7634: PUSH
7635: LD_INT 6
7637: LESSEQUAL
7638: IFFALSE 7692
// begin AddComAttackPlace ( unit , barrelsInArea [ i ] , barrelsInArea [ i + 1 ] ) ;
7640: LD_VAR 0 4
7644: PPUSH
7645: LD_VAR 0 11
7649: PUSH
7650: LD_VAR 0 2
7654: ARRAY
7655: PPUSH
7656: LD_VAR 0 11
7660: PUSH
7661: LD_VAR 0 2
7665: PUSH
7666: LD_INT 1
7668: PLUS
7669: ARRAY
7670: PPUSH
7671: CALL_OW 176
// AddExperience ( unit , skill_combat , 5 ) ;
7675: LD_VAR 0 4
7679: PPUSH
7680: LD_INT 1
7682: PPUSH
7683: LD_INT 5
7685: PPUSH
7686: CALL_OW 492
// break ;
7690: GO 7708
// end ; i = i + 2 ;
7692: LD_ADDR_VAR 0 2
7696: PUSH
7697: LD_VAR 0 2
7701: PUSH
7702: LD_INT 2
7704: PLUS
7705: ST_TO_ADDR
// end ;
7706: GO 7596
7708: POP
7709: POP
// end ; end ;
7710: GO 7302
7712: POP
7713: POP
// end ;
7714: LD_VAR 0 1
7718: RET
// export function GoToHunt ( hunter ) ; var i , barracks , barrackTarget , barrackTargetCurrentHP , animals , animal ; begin
7719: LD_INT 0
7721: PPUSH
7722: PPUSH
7723: PPUSH
7724: PPUSH
7725: PPUSH
7726: PPUSH
7727: PPUSH
// animals = [ ] ;
7728: LD_ADDR_VAR 0 7
7732: PUSH
7733: EMPTY
7734: ST_TO_ADDR
// barracks = FilterAllUnits ( [ [ f_ok ] , [ f_not , [ f_constructed ] ] , [ f_or , [ f_btype , b_barracks ] , [ f_btype , b_armoury ] ] ] ) ;
7735: LD_ADDR_VAR 0 4
7739: PUSH
7740: LD_INT 50
7742: PUSH
7743: EMPTY
7744: LIST
7745: PUSH
7746: LD_INT 3
7748: PUSH
7749: LD_INT 57
7751: PUSH
7752: EMPTY
7753: LIST
7754: PUSH
7755: EMPTY
7756: LIST
7757: LIST
7758: PUSH
7759: LD_INT 2
7761: PUSH
7762: LD_INT 30
7764: PUSH
7765: LD_INT 5
7767: PUSH
7768: EMPTY
7769: LIST
7770: LIST
7771: PUSH
7772: LD_INT 30
7774: PUSH
7775: LD_INT 4
7777: PUSH
7778: EMPTY
7779: LIST
7780: LIST
7781: PUSH
7782: EMPTY
7783: LIST
7784: LIST
7785: LIST
7786: PUSH
7787: EMPTY
7788: LIST
7789: LIST
7790: LIST
7791: PPUSH
7792: CALL_OW 69
7796: ST_TO_ADDR
// SetSide ( hunter , 6 ) ;
7797: LD_VAR 0 1
7801: PPUSH
7802: LD_INT 6
7804: PPUSH
7805: CALL_OW 235
// if IsInUnit ( hunter ) then
7809: LD_VAR 0 1
7813: PPUSH
7814: CALL_OW 310
7818: IFFALSE 7860
// begin if GetBType ( IsInUnit ( hunter ) = unit_vehicle ) then
7820: LD_VAR 0 1
7824: PPUSH
7825: CALL_OW 310
7829: PUSH
7830: LD_INT 2
7832: EQUAL
7833: PPUSH
7834: CALL_OW 266
7838: IFFALSE 7851
// ComExitVehicle ( hunter ) else
7840: LD_VAR 0 1
7844: PPUSH
7845: CALL_OW 121
7849: GO 7860
// ComExitBuilding ( hunter ) ;
7851: LD_VAR 0 1
7855: PPUSH
7856: CALL_OW 122
// end ; ComWalk ( hunter ) ;
7860: LD_VAR 0 1
7864: PPUSH
7865: CALL_OW 138
// wait ( 0 0$1 ) ;
7869: LD_INT 35
7871: PPUSH
7872: CALL_OW 67
// if not GetClass ( hunter ) = class_soldier and barracks then
7876: LD_VAR 0 1
7880: PPUSH
7881: CALL_OW 257
7885: PUSH
7886: LD_INT 1
7888: EQUAL
7889: NOT
7890: PUSH
7891: LD_VAR 0 4
7895: AND
7896: IFFALSE 8039
// begin barrackTarget = barracks [ 1 ] ;
7898: LD_ADDR_VAR 0 5
7902: PUSH
7903: LD_VAR 0 4
7907: PUSH
7908: LD_INT 1
7910: ARRAY
7911: ST_TO_ADDR
// barrackTargetCurrentHP = GetLives ( barrackTarget ) ;
7912: LD_ADDR_VAR 0 6
7916: PUSH
7917: LD_VAR 0 5
7921: PPUSH
7922: CALL_OW 256
7926: ST_TO_ADDR
// SetSide ( barrackTarget , 6 ) ;
7927: LD_VAR 0 5
7931: PPUSH
7932: LD_INT 6
7934: PPUSH
7935: CALL_OW 235
// ComEnterUnit ( hunter , barrackTarget ) ;
7939: LD_VAR 0 1
7943: PPUSH
7944: LD_VAR 0 5
7948: PPUSH
7949: CALL_OW 120
// repeat wait ( 0 0$1 ) ;
7953: LD_INT 35
7955: PPUSH
7956: CALL_OW 67
// ComEnterUnit ( hunter , barrackTarget ) ;
7960: LD_VAR 0 1
7964: PPUSH
7965: LD_VAR 0 5
7969: PPUSH
7970: CALL_OW 120
// SetLives ( barrackTarget , barrackTargetCurrentHP ) ;
7974: LD_VAR 0 5
7978: PPUSH
7979: LD_VAR 0 6
7983: PPUSH
7984: CALL_OW 234
// until IsInUnit ( hunter ) ;
7988: LD_VAR 0 1
7992: PPUSH
7993: CALL_OW 310
7997: IFFALSE 7953
// SetClass ( hunter , class_soldier ) ;
7999: LD_VAR 0 1
8003: PPUSH
8004: LD_INT 1
8006: PPUSH
8007: CALL_OW 336
// ComExitBuilding ( hunter ) ;
8011: LD_VAR 0 1
8015: PPUSH
8016: CALL_OW 122
// SetSide ( barrackTarget , 3 ) ;
8020: LD_VAR 0 5
8024: PPUSH
8025: LD_INT 3
8027: PPUSH
8028: CALL_OW 235
// wait ( 0 0$1 ) ;
8032: LD_INT 35
8034: PPUSH
8035: CALL_OW 67
// end ; for i := 1 to 3 do
8039: LD_ADDR_VAR 0 3
8043: PUSH
8044: DOUBLE
8045: LD_INT 1
8047: DEC
8048: ST_TO_ADDR
8049: LD_INT 3
8051: PUSH
8052: FOR_TO
8053: IFFALSE 8158
// begin uc_side = 0 ;
8055: LD_ADDR_OWVAR 20
8059: PUSH
8060: LD_INT 0
8062: ST_TO_ADDR
// uc_nation = nation_nature ;
8063: LD_ADDR_OWVAR 21
8067: PUSH
8068: LD_INT 0
8070: ST_TO_ADDR
// PrepareHuman ( false , [ class_phororhacos , class_tiger , 21 ] [ Rand ( 1 , 3 ) ] , 0 ) ;
8071: LD_INT 0
8073: PPUSH
8074: LD_INT 18
8076: PUSH
8077: LD_INT 14
8079: PUSH
8080: LD_INT 21
8082: PUSH
8083: EMPTY
8084: LIST
8085: LIST
8086: LIST
8087: PUSH
8088: LD_INT 1
8090: PPUSH
8091: LD_INT 3
8093: PPUSH
8094: CALL_OW 12
8098: ARRAY
8099: PPUSH
8100: LD_INT 0
8102: PPUSH
8103: CALL_OW 380
// hc_agressivity = 0 ;
8107: LD_ADDR_OWVAR 35
8111: PUSH
8112: LD_INT 0
8114: ST_TO_ADDR
// animal = CreateHuman ;
8115: LD_ADDR_VAR 0 8
8119: PUSH
8120: CALL_OW 44
8124: ST_TO_ADDR
// PlaceUnitArea ( animal , NatureArea , false ) ;
8125: LD_VAR 0 8
8129: PPUSH
8130: LD_INT 5
8132: PPUSH
8133: LD_INT 0
8135: PPUSH
8136: CALL_OW 49
// animals = animals ^ animal ;
8140: LD_ADDR_VAR 0 7
8144: PUSH
8145: LD_VAR 0 7
8149: PUSH
8150: LD_VAR 0 8
8154: ADD
8155: ST_TO_ADDR
// end ;
8156: GO 8052
8158: POP
8159: POP
// for i := 1 to animals do
8160: LD_ADDR_VAR 0 3
8164: PUSH
8165: DOUBLE
8166: LD_INT 1
8168: DEC
8169: ST_TO_ADDR
8170: LD_VAR 0 7
8174: PUSH
8175: FOR_TO
8176: IFFALSE 8200
// AddComAttackUnit ( hunter , animals [ i ] ) ;
8178: LD_VAR 0 1
8182: PPUSH
8183: LD_VAR 0 7
8187: PUSH
8188: LD_VAR 0 3
8192: ARRAY
8193: PPUSH
8194: CALL_OW 175
8198: GO 8175
8200: POP
8201: POP
// repeat wait ( 0 0$1 ) ;
8202: LD_INT 35
8204: PPUSH
8205: CALL_OW 67
// if GetClass ( hunter ) = class_soldier then
8209: LD_VAR 0 1
8213: PPUSH
8214: CALL_OW 257
8218: PUSH
8219: LD_INT 1
8221: EQUAL
8222: IFFALSE 8269
// begin if GetDistUnits ( hunter , WantsToAttack ( hunter ) ) < 13 then
8224: LD_VAR 0 1
8228: PPUSH
8229: LD_VAR 0 1
8233: PPUSH
8234: CALL_OW 319
8238: PPUSH
8239: CALL_OW 296
8243: PUSH
8244: LD_INT 13
8246: LESS
8247: IFFALSE 8260
// ComCrawl ( hunter ) else
8249: LD_VAR 0 1
8253: PPUSH
8254: CALL_OW 137
8258: GO 8269
// ComWalk ( hunter ) ;
8260: LD_VAR 0 1
8264: PPUSH
8265: CALL_OW 138
// end ; until not HasTask ( hunter ) ;
8269: LD_VAR 0 1
8273: PPUSH
8274: CALL_OW 314
8278: NOT
8279: IFFALSE 8202
// repeat wait ( 0 0$1 ) ;
8281: LD_INT 35
8283: PPUSH
8284: CALL_OW 67
// ComMoveXY ( hunter , GetX ( Burlak ) , GetY ( Burlak ) ) ;
8288: LD_VAR 0 1
8292: PPUSH
8293: LD_EXP 57
8297: PPUSH
8298: CALL_OW 250
8302: PPUSH
8303: LD_EXP 57
8307: PPUSH
8308: CALL_OW 251
8312: PPUSH
8313: CALL_OW 111
// until GetDistUnits ( hunter , Burlak ) <= 9 ;
8317: LD_VAR 0 1
8321: PPUSH
8322: LD_EXP 57
8326: PPUSH
8327: CALL_OW 296
8331: PUSH
8332: LD_INT 9
8334: LESSEQUAL
8335: IFFALSE 8281
// SetSide ( hunter , 3 ) ;
8337: LD_VAR 0 1
8341: PPUSH
8342: LD_INT 3
8344: PPUSH
8345: CALL_OW 235
// CenterOnUnits ( hunter ) ;
8349: LD_VAR 0 1
8353: PPUSH
8354: CALL_OW 85
// AddExperience ( hunter , skill_combat , 3000 ) ;
8358: LD_VAR 0 1
8362: PPUSH
8363: LD_INT 1
8365: PPUSH
8366: LD_INT 3000
8368: PPUSH
8369: CALL_OW 492
// end ;
8373: LD_VAR 0 2
8377: RET
// export function SetMashaData ( vehicle ) ; begin
8378: LD_INT 0
8380: PPUSH
// if Masha then
8381: LD_EXP 4
8385: IFFALSE 8403
// SetMark ( Masha [ 1 ] , 0 ) ;
8387: LD_EXP 4
8391: PUSH
8392: LD_INT 1
8394: ARRAY
8395: PPUSH
8396: LD_INT 0
8398: PPUSH
8399: CALL_OW 242
// Masha = [ vehicle , GetChassis ( vehicle ) , GetEngine ( vehicle ) , GetControl ( vehicle ) , GetWeapon ( vehicle ) ] ;
8403: LD_ADDR_EXP 4
8407: PUSH
8408: LD_VAR 0 1
8412: PUSH
8413: LD_VAR 0 1
8417: PPUSH
8418: CALL_OW 265
8422: PUSH
8423: LD_VAR 0 1
8427: PPUSH
8428: CALL_OW 262
8432: PUSH
8433: LD_VAR 0 1
8437: PPUSH
8438: CALL_OW 263
8442: PUSH
8443: LD_VAR 0 1
8447: PPUSH
8448: CALL_OW 264
8452: PUSH
8453: EMPTY
8454: LIST
8455: LIST
8456: LIST
8457: LIST
8458: LIST
8459: ST_TO_ADDR
// ChangeMissionObjectives ( MMashaDone ) ;
8460: LD_STRING MMashaDone
8462: PPUSH
8463: CALL_OW 337
// SetMark ( vehicle , 1 ) ;
8467: LD_VAR 0 1
8471: PPUSH
8472: LD_INT 1
8474: PPUSH
8475: CALL_OW 242
// end ;
8479: LD_VAR 0 2
8483: RET
// export function SaveBase ( buildings , ident ) ; var i , buildingsToSave ; begin
8484: LD_INT 0
8486: PPUSH
8487: PPUSH
8488: PPUSH
// buildingsToSave = [ ] ;
8489: LD_ADDR_VAR 0 5
8493: PUSH
8494: EMPTY
8495: ST_TO_ADDR
// if not buildings then
8496: LD_VAR 0 1
8500: NOT
8501: IFFALSE 8505
// exit ;
8503: GO 9080
// for i in buildings do
8505: LD_ADDR_VAR 0 4
8509: PUSH
8510: LD_VAR 0 1
8514: PUSH
8515: FOR_IN
8516: IFFALSE 9064
// begin if GetBType ( i ) in [ b_lab , b_lab_half , b_lab_full ] then
8518: LD_VAR 0 4
8522: PPUSH
8523: CALL_OW 266
8527: PUSH
8528: LD_INT 6
8530: PUSH
8531: LD_INT 7
8533: PUSH
8534: LD_INT 8
8536: PUSH
8537: EMPTY
8538: LIST
8539: LIST
8540: LIST
8541: IN
8542: IFFALSE 8667
// buildingsToSave = buildingsToSave ^ [ [ GetBType ( i ) , GetX ( i ) , GetY ( i ) , GetDir ( i ) , GetBLevel ( i ) , GetNation ( i ) , GetLives ( i ) , GetLabKind ( i , 1 ) , GetLabKind ( i , 2 ) ] ] else
8544: LD_ADDR_VAR 0 5
8548: PUSH
8549: LD_VAR 0 5
8553: PUSH
8554: LD_VAR 0 4
8558: PPUSH
8559: CALL_OW 266
8563: PUSH
8564: LD_VAR 0 4
8568: PPUSH
8569: CALL_OW 250
8573: PUSH
8574: LD_VAR 0 4
8578: PPUSH
8579: CALL_OW 251
8583: PUSH
8584: LD_VAR 0 4
8588: PPUSH
8589: CALL_OW 254
8593: PUSH
8594: LD_VAR 0 4
8598: PPUSH
8599: CALL_OW 267
8603: PUSH
8604: LD_VAR 0 4
8608: PPUSH
8609: CALL_OW 248
8613: PUSH
8614: LD_VAR 0 4
8618: PPUSH
8619: CALL_OW 256
8623: PUSH
8624: LD_VAR 0 4
8628: PPUSH
8629: LD_INT 1
8631: PPUSH
8632: CALL_OW 268
8636: PUSH
8637: LD_VAR 0 4
8641: PPUSH
8642: LD_INT 2
8644: PPUSH
8645: CALL_OW 268
8649: PUSH
8650: EMPTY
8651: LIST
8652: LIST
8653: LIST
8654: LIST
8655: LIST
8656: LIST
8657: LIST
8658: LIST
8659: LIST
8660: PUSH
8661: EMPTY
8662: LIST
8663: ADD
8664: ST_TO_ADDR
8665: GO 9062
// if GetBType ( i ) in [ b_bunker , b_turret ] then
8667: LD_VAR 0 4
8671: PPUSH
8672: CALL_OW 266
8676: PUSH
8677: LD_INT 32
8679: PUSH
8680: LD_INT 33
8682: PUSH
8683: EMPTY
8684: LIST
8685: LIST
8686: IN
8687: IFFALSE 8795
// buildingsToSave = buildingsToSave ^ [ [ GetBType ( i ) , GetX ( i ) , GetY ( i ) , GetDir ( i ) , GetBLevel ( i ) , GetNation ( i ) , GetLives ( i ) , GetBWeapon ( i ) ] ] else
8689: LD_ADDR_VAR 0 5
8693: PUSH
8694: LD_VAR 0 5
8698: PUSH
8699: LD_VAR 0 4
8703: PPUSH
8704: CALL_OW 266
8708: PUSH
8709: LD_VAR 0 4
8713: PPUSH
8714: CALL_OW 250
8718: PUSH
8719: LD_VAR 0 4
8723: PPUSH
8724: CALL_OW 251
8728: PUSH
8729: LD_VAR 0 4
8733: PPUSH
8734: CALL_OW 254
8738: PUSH
8739: LD_VAR 0 4
8743: PPUSH
8744: CALL_OW 267
8748: PUSH
8749: LD_VAR 0 4
8753: PPUSH
8754: CALL_OW 248
8758: PUSH
8759: LD_VAR 0 4
8763: PPUSH
8764: CALL_OW 256
8768: PUSH
8769: LD_VAR 0 4
8773: PPUSH
8774: CALL_OW 269
8778: PUSH
8779: EMPTY
8780: LIST
8781: LIST
8782: LIST
8783: LIST
8784: LIST
8785: LIST
8786: LIST
8787: LIST
8788: PUSH
8789: EMPTY
8790: LIST
8791: ADD
8792: ST_TO_ADDR
8793: GO 9062
// if GetBType ( i ) in [ b_depot , b_warehouse ] then
8795: LD_VAR 0 4
8799: PPUSH
8800: CALL_OW 266
8804: PUSH
8805: LD_INT 0
8807: PUSH
8808: LD_INT 1
8810: PUSH
8811: EMPTY
8812: LIST
8813: LIST
8814: IN
8815: IFFALSE 8969
// buildingsToSave = buildingsToSave ^ [ [ GetBType ( i ) , GetX ( i ) , GetY ( i ) , GetDir ( i ) , GetBLevel ( i ) , GetNation ( i ) , GetLives ( i ) , GetResourceType ( GetBase ( i ) , mat_cans ) , GetResourceType ( GetBase ( i ) , mat_oil ) , GetResourceType ( GetBase ( i ) , mat_siberit ) ] ] else
8817: LD_ADDR_VAR 0 5
8821: PUSH
8822: LD_VAR 0 5
8826: PUSH
8827: LD_VAR 0 4
8831: PPUSH
8832: CALL_OW 266
8836: PUSH
8837: LD_VAR 0 4
8841: PPUSH
8842: CALL_OW 250
8846: PUSH
8847: LD_VAR 0 4
8851: PPUSH
8852: CALL_OW 251
8856: PUSH
8857: LD_VAR 0 4
8861: PPUSH
8862: CALL_OW 254
8866: PUSH
8867: LD_VAR 0 4
8871: PPUSH
8872: CALL_OW 267
8876: PUSH
8877: LD_VAR 0 4
8881: PPUSH
8882: CALL_OW 248
8886: PUSH
8887: LD_VAR 0 4
8891: PPUSH
8892: CALL_OW 256
8896: PUSH
8897: LD_VAR 0 4
8901: PPUSH
8902: CALL_OW 274
8906: PPUSH
8907: LD_INT 1
8909: PPUSH
8910: CALL_OW 275
8914: PUSH
8915: LD_VAR 0 4
8919: PPUSH
8920: CALL_OW 274
8924: PPUSH
8925: LD_INT 2
8927: PPUSH
8928: CALL_OW 275
8932: PUSH
8933: LD_VAR 0 4
8937: PPUSH
8938: CALL_OW 274
8942: PPUSH
8943: LD_INT 3
8945: PPUSH
8946: CALL_OW 275
8950: PUSH
8951: EMPTY
8952: LIST
8953: LIST
8954: LIST
8955: LIST
8956: LIST
8957: LIST
8958: LIST
8959: LIST
8960: LIST
8961: LIST
8962: PUSH
8963: EMPTY
8964: LIST
8965: ADD
8966: ST_TO_ADDR
8967: GO 9062
// buildingsToSave = buildingsToSave ^ [ [ GetBType ( i ) , GetX ( i ) , GetY ( i ) , GetDir ( i ) , GetBLevel ( i ) , GetNation ( i ) , GetLives ( i ) ] ] ;
8969: LD_ADDR_VAR 0 5
8973: PUSH
8974: LD_VAR 0 5
8978: PUSH
8979: LD_VAR 0 4
8983: PPUSH
8984: CALL_OW 266
8988: PUSH
8989: LD_VAR 0 4
8993: PPUSH
8994: CALL_OW 250
8998: PUSH
8999: LD_VAR 0 4
9003: PPUSH
9004: CALL_OW 251
9008: PUSH
9009: LD_VAR 0 4
9013: PPUSH
9014: CALL_OW 254
9018: PUSH
9019: LD_VAR 0 4
9023: PPUSH
9024: CALL_OW 267
9028: PUSH
9029: LD_VAR 0 4
9033: PPUSH
9034: CALL_OW 248
9038: PUSH
9039: LD_VAR 0 4
9043: PPUSH
9044: CALL_OW 256
9048: PUSH
9049: EMPTY
9050: LIST
9051: LIST
9052: LIST
9053: LIST
9054: LIST
9055: LIST
9056: LIST
9057: PUSH
9058: EMPTY
9059: LIST
9060: ADD
9061: ST_TO_ADDR
// end ;
9062: GO 8515
9064: POP
9065: POP
// SaveVariable ( buildingsToSave , ident ) ;
9066: LD_VAR 0 5
9070: PPUSH
9071: LD_VAR 0 2
9075: PPUSH
9076: CALL_OW 39
// end ; end_of_file
9080: LD_VAR 0 3
9084: RET
// export function MissionIntro ; begin
9085: LD_INT 0
9087: PPUSH
// CenterNowOnUnits ( Burlak ) ;
9088: LD_EXP 57
9092: PPUSH
9093: CALL_OW 87
// DialogueOn ;
9097: CALL_OW 6
// SayRadio ( Popov , DStart-Pop-1 ) ;
9101: LD_EXP 76
9105: PPUSH
9106: LD_STRING DStart-Pop-1
9108: PPUSH
9109: CALL_OW 94
// Say ( Burlak , DStart-Bur-1 ) ;
9113: LD_EXP 57
9117: PPUSH
9118: LD_STRING DStart-Bur-1
9120: PPUSH
9121: CALL_OW 88
// DialogueOff ;
9125: CALL_OW 7
// IngameOff ;
9129: CALL_OW 9
// ChangeMissionObjectives ( MStart ) ;
9133: LD_STRING MStart
9135: PPUSH
9136: CALL_OW 337
// SaveForQuickRestart ;
9140: CALL_OW 22
// end ;
9144: LD_VAR 0 1
9148: RET
// export function Dial_EscortHeike ( x , y ) ; begin
9149: LD_INT 0
9151: PPUSH
// dial_BuildDepotBlocker = true ;
9152: LD_ADDR_EXP 5
9156: PUSH
9157: LD_INT 1
9159: ST_TO_ADDR
// HeikeTargetX = x ;
9160: LD_ADDR_EXP 14
9164: PUSH
9165: LD_VAR 0 1
9169: ST_TO_ADDR
// HeikeTargetY = y ;
9170: LD_ADDR_EXP 15
9174: PUSH
9175: LD_VAR 0 2
9179: ST_TO_ADDR
// SayRadio ( Popov , DHeike-Pop-1 ) ;
9180: LD_EXP 76
9184: PPUSH
9185: LD_STRING DHeike-Pop-1
9187: PPUSH
9188: CALL_OW 94
// wait ( 0 0$10 ) ;
9192: LD_INT 350
9194: PPUSH
9195: CALL_OW 67
// PrepareRussianEscort ;
9199: CALL 2320 0 0
// PlaceUnitArea ( Heike , RussianSpawn2Area , false ) ;
9203: LD_EXP 79
9207: PPUSH
9208: LD_INT 7
9210: PPUSH
9211: LD_INT 0
9213: PPUSH
9214: CALL_OW 49
// ComMoveXY ( russianEscort , HeikeTargetX , HeikeTargetY ) ;
9218: LD_EXP 77
9222: PPUSH
9223: LD_EXP 14
9227: PPUSH
9228: LD_EXP 15
9232: PPUSH
9233: CALL_OW 111
// AddComMoveToArea ( russianEscort , RussianSpawn2Area ) ;
9237: LD_EXP 77
9241: PPUSH
9242: LD_INT 7
9244: PPUSH
9245: CALL_OW 173
// ComMoveXY ( Heike , HeikeTargetX , HeikeTargetY ) ;
9249: LD_EXP 79
9253: PPUSH
9254: LD_EXP 14
9258: PPUSH
9259: LD_EXP 15
9263: PPUSH
9264: CALL_OW 111
// AddComHold ( Heike ) ;
9268: LD_EXP 79
9272: PPUSH
9273: CALL_OW 200
// end ;
9277: LD_VAR 0 3
9281: RET
// every 1 trigger GetDistUnitXY ( Heike , HeikeTargetX , HeikeTargetY ) <= 5 do
9282: LD_EXP 79
9286: PPUSH
9287: LD_EXP 14
9291: PPUSH
9292: LD_EXP 15
9296: PPUSH
9297: CALL_OW 297
9301: PUSH
9302: LD_INT 5
9304: LESSEQUAL
9305: IFFALSE 9318
9307: GO 9309
9309: DISABLE
// allowExitFromMap = 1 ;
9310: LD_ADDR_EXP 18
9314: PUSH
9315: LD_INT 1
9317: ST_TO_ADDR
9318: END
// every 7 7$0 trigger IsPlaced ( Heike ) and IsOk ( Heike ) and GetAttitude ( 3 , 5 ) = att_friend and HeikeCaptured do
9319: LD_EXP 79
9323: PPUSH
9324: CALL_OW 305
9328: PUSH
9329: LD_EXP 79
9333: PPUSH
9334: CALL_OW 302
9338: AND
9339: PUSH
9340: LD_INT 3
9342: PPUSH
9343: LD_INT 5
9345: PPUSH
9346: CALL_OW 81
9350: PUSH
9351: LD_INT 1
9353: EQUAL
9354: AND
9355: PUSH
9356: LD_EXP 1
9360: AND
9361: IFFALSE 9580
9363: GO 9365
9365: DISABLE
// begin DialogueOn ;
9366: CALL_OW 6
// SayRadio ( Kurt , DMercHelp-Kurt-1 ) ;
9370: LD_EXP 80
9374: PPUSH
9375: LD_STRING DMercHelp-Kurt-1
9377: PPUSH
9378: CALL_OW 94
// Say ( Burlak , DMercHelp-Bur-1 ) ;
9382: LD_EXP 57
9386: PPUSH
9387: LD_STRING DMercHelp-Bur-1
9389: PPUSH
9390: CALL_OW 88
// SayRadio ( Kurt , DMercHelp-Kurt-2 ) ;
9394: LD_EXP 80
9398: PPUSH
9399: LD_STRING DMercHelp-Kurt-2
9401: PPUSH
9402: CALL_OW 94
// Say ( Burlak , DMercHelp-Bur-2 ) ;
9406: LD_EXP 57
9410: PPUSH
9411: LD_STRING DMercHelp-Bur-2
9413: PPUSH
9414: CALL_OW 88
// SayRadio ( Kurt , DMercHelp-Kurt-3 ) ;
9418: LD_EXP 80
9422: PPUSH
9423: LD_STRING DMercHelp-Kurt-3
9425: PPUSH
9426: CALL_OW 94
// case Query ( QMerc ) of 1 :
9430: LD_STRING QMerc
9432: PPUSH
9433: CALL_OW 97
9437: PUSH
9438: LD_INT 1
9440: DOUBLE
9441: EQUAL
9442: IFTRUE 9446
9444: GO 9481
9446: POP
// begin Say ( Burlak , DQrMerc#1-Bur-1 ) ;
9447: LD_EXP 57
9451: PPUSH
9452: LD_STRING DQrMerc#1-Bur-1
9454: PPUSH
9455: CALL_OW 88
// SayRadio ( Kurt , DQrMerc#1-Kurt-1 ) ;
9459: LD_EXP 80
9463: PPUSH
9464: LD_STRING DQrMerc#1-Kurt-1
9466: PPUSH
9467: CALL_OW 94
// acceptKurtOffert = true ;
9471: LD_ADDR_EXP 19
9475: PUSH
9476: LD_INT 1
9478: ST_TO_ADDR
// end ; 2 :
9479: GO 9576
9481: LD_INT 2
9483: DOUBLE
9484: EQUAL
9485: IFTRUE 9489
9487: GO 9544
9489: POP
// begin askCommanders = true ;
9490: LD_ADDR_EXP 20
9494: PUSH
9495: LD_INT 1
9497: ST_TO_ADDR
// Say ( Burlak , DQrMerc#2-Bur-1 ) ;
9498: LD_EXP 57
9502: PPUSH
9503: LD_STRING DQrMerc#2-Bur-1
9505: PPUSH
9506: CALL_OW 88
// SayRadio ( Popov , DQrMerc#2-Pop-1 ) ;
9510: LD_EXP 76
9514: PPUSH
9515: LD_STRING DQrMerc#2-Pop-1
9517: PPUSH
9518: CALL_OW 94
// Say ( Burlak , DQrMerc#2-Bur-2 ) ;
9522: LD_EXP 57
9526: PPUSH
9527: LD_STRING DQrMerc#2-Bur-2
9529: PPUSH
9530: CALL_OW 88
// acceptKurtOffert = true ;
9534: LD_ADDR_EXP 19
9538: PUSH
9539: LD_INT 1
9541: ST_TO_ADDR
// end ; 3 :
9542: GO 9576
9544: LD_INT 3
9546: DOUBLE
9547: EQUAL
9548: IFTRUE 9552
9550: GO 9575
9552: POP
// begin Say ( Burlak , DQrMerc#3-Bur-1 ) ;
9553: LD_EXP 57
9557: PPUSH
9558: LD_STRING DQrMerc#3-Bur-1
9560: PPUSH
9561: CALL_OW 88
// KurtAttack = true ;
9565: LD_ADDR_EXP 25
9569: PUSH
9570: LD_INT 1
9572: ST_TO_ADDR
// end ; end ;
9573: GO 9576
9575: POP
// DialogueOff ;
9576: CALL_OW 7
// end ;
9580: END
// every 0 0$1 trigger acceptKurtOffert do
9581: LD_EXP 19
9585: IFFALSE 9741
9587: GO 9589
9589: DISABLE
// begin PlaceUnitArea ( Kurt , KurtSpawnArea , false ) ;
9590: LD_EXP 80
9594: PPUSH
9595: LD_INT 9
9597: PPUSH
9598: LD_INT 0
9600: PPUSH
9601: CALL_OW 49
// uc_side = 8 ;
9605: LD_ADDR_OWVAR 20
9609: PUSH
9610: LD_INT 8
9612: ST_TO_ADDR
// uc_nation = 2 ;
9613: LD_ADDR_OWVAR 21
9617: PUSH
9618: LD_INT 2
9620: ST_TO_ADDR
// PrepareEngineer ( false , 3 ) ;
9621: LD_INT 0
9623: PPUSH
9624: LD_INT 3
9626: PPUSH
9627: CALL_OW 382
// KurtEng = CreateHuman ;
9631: LD_ADDR_EXP 82
9635: PUSH
9636: CALL_OW 44
9640: ST_TO_ADDR
// PlaceUnitArea ( KurtEng , KurtSpawnArea , false ) ;
9641: LD_EXP 82
9645: PPUSH
9646: LD_INT 9
9648: PPUSH
9649: LD_INT 0
9651: PPUSH
9652: CALL_OW 49
// repeat wait ( 0 0$1 ) ;
9656: LD_INT 35
9658: PPUSH
9659: CALL_OW 67
// ComMoveXY ( [ Kurt , KurtEng ] , GetX ( Burlak ) , GetY ( Burlak ) ) ;
9663: LD_EXP 80
9667: PUSH
9668: LD_EXP 82
9672: PUSH
9673: EMPTY
9674: LIST
9675: LIST
9676: PPUSH
9677: LD_EXP 57
9681: PPUSH
9682: CALL_OW 250
9686: PPUSH
9687: LD_EXP 57
9691: PPUSH
9692: CALL_OW 251
9696: PPUSH
9697: CALL_OW 111
// until GetDistUnits ( Kurt , Burlak ) <= 5 or GetDistUnits ( KurtEng , Burlak ) <= 5 ;
9701: LD_EXP 80
9705: PPUSH
9706: LD_EXP 57
9710: PPUSH
9711: CALL_OW 296
9715: PUSH
9716: LD_INT 5
9718: LESSEQUAL
9719: PUSH
9720: LD_EXP 82
9724: PPUSH
9725: LD_EXP 57
9729: PPUSH
9730: CALL_OW 296
9734: PUSH
9735: LD_INT 5
9737: LESSEQUAL
9738: OR
9739: IFFALSE 9656
// end ;
9741: END
// every 0 0$1 trigger GetDistUnits ( Kurt , Burlak ) <= 5 or GetDistUnits ( KurtEng , Burlak ) <= 5 do
9742: LD_EXP 80
9746: PPUSH
9747: LD_EXP 57
9751: PPUSH
9752: CALL_OW 296
9756: PUSH
9757: LD_INT 5
9759: LESSEQUAL
9760: PUSH
9761: LD_EXP 82
9765: PPUSH
9766: LD_EXP 57
9770: PPUSH
9771: CALL_OW 296
9775: PUSH
9776: LD_INT 5
9778: LESSEQUAL
9779: OR
9780: IFFALSE 9959
9782: GO 9784
9784: DISABLE
// begin KurtWaitingForBuildBarrack = true ;
9785: LD_ADDR_EXP 24
9789: PUSH
9790: LD_INT 1
9792: ST_TO_ADDR
// SetSide ( KurtEng , 3 ) ;
9793: LD_EXP 82
9797: PPUSH
9798: LD_INT 3
9800: PPUSH
9801: CALL_OW 235
// wait ( 1 1$30 ) ;
9805: LD_INT 3150
9807: PPUSH
9808: CALL_OW 67
// DialogueOn ;
9812: CALL_OW 6
// SayRadio ( Dietrich , DArabianRequest-Diet-1 ) ;
9816: LD_EXP 81
9820: PPUSH
9821: LD_STRING DArabianRequest-Diet-1
9823: PPUSH
9824: CALL_OW 94
// Say ( Burlak , DArabianRequest-Bur-1 ) ;
9828: LD_EXP 57
9832: PPUSH
9833: LD_STRING DArabianRequest-Bur-1
9835: PPUSH
9836: CALL_OW 88
// SayRadio ( Dietrich , DArabianRequest-Diet-2 ) ;
9840: LD_EXP 81
9844: PPUSH
9845: LD_STRING DArabianRequest-Diet-2
9847: PPUSH
9848: CALL_OW 94
// DialogueOff ;
9852: CALL_OW 7
// case Query ( QHandOver ) of 1 :
9856: LD_STRING QHandOver
9858: PPUSH
9859: CALL_OW 97
9863: PUSH
9864: LD_INT 1
9866: DOUBLE
9867: EQUAL
9868: IFTRUE 9872
9870: GO 9911
9872: POP
// begin Say ( Burlak , DQrHandOver#1-Bur-1 ) ;
9873: LD_EXP 57
9877: PPUSH
9878: LD_STRING DQrHandOver#1-Bur-1
9880: PPUSH
9881: CALL_OW 88
// SayRadio ( Dietrich , DQrHandOver#1-Diet-1 ) ;
9885: LD_EXP 81
9889: PPUSH
9890: LD_STRING DQrHandOver#1-Diet-1
9892: PPUSH
9893: CALL_OW 94
// coopWithGensher = true ;
9897: LD_ADDR_EXP 2
9901: PUSH
9902: LD_INT 1
9904: ST_TO_ADDR
// SpawnGensherTeam ;
9905: CALL 3946 0 0
// end ; 2 :
9909: GO 9959
9911: LD_INT 2
9913: DOUBLE
9914: EQUAL
9915: IFTRUE 9919
9917: GO 9958
9919: POP
// begin Say ( Burlak , DQrHandOver#2-Bur-1 ) ;
9920: LD_EXP 57
9924: PPUSH
9925: LD_STRING DQrHandOver#2-Bur-1
9927: PPUSH
9928: CALL_OW 88
// SayRadio ( Dietrich , DQrHandOver#2-Diet-1 ) ;
9932: LD_EXP 81
9936: PPUSH
9937: LD_STRING DQrHandOver#2-Diet-1
9939: PPUSH
9940: CALL_OW 94
// Say ( Burlak , DQrHandOver#2-Bur-2 ) ;
9944: LD_EXP 57
9948: PPUSH
9949: LD_STRING DQrHandOver#2-Bur-2
9951: PPUSH
9952: CALL_OW 88
// end ; end ;
9956: GO 9959
9958: POP
// end ;
9959: END
// export function Dial_UpgradeArmoury ; begin
9960: LD_INT 0
9962: PPUSH
// dial_BuildArBarrackBlocker = true ;
9963: LD_ADDR_EXP 6
9967: PUSH
9968: LD_INT 1
9970: ST_TO_ADDR
// buildArabBarrack = true ;
9971: LD_ADDR_EXP 38
9975: PUSH
9976: LD_INT 1
9978: ST_TO_ADDR
// if GetSide ( Kurt ) = 2 or GetSide ( KurtEng ) = 8 then
9979: LD_EXP 80
9983: PPUSH
9984: CALL_OW 255
9988: PUSH
9989: LD_INT 2
9991: EQUAL
9992: PUSH
9993: LD_EXP 82
9997: PPUSH
9998: CALL_OW 255
10002: PUSH
10003: LD_INT 8
10005: EQUAL
10006: OR
10007: IFFALSE 10011
// exit ;
10009: GO 10111
// SetSide ( KurtEng , 8 ) ;
10011: LD_EXP 82
10015: PPUSH
10016: LD_INT 8
10018: PPUSH
10019: CALL_OW 235
// ComStop ( KurtEng ) ;
10023: LD_EXP 82
10027: PPUSH
10028: CALL_OW 141
// DialogueOn ;
10032: CALL_OW 6
// Say ( Kurt , DMercCompleted-Kurt-1 ) ;
10036: LD_EXP 80
10040: PPUSH
10041: LD_STRING DMercCompleted-Kurt-1
10043: PPUSH
10044: CALL_OW 88
// DialogueOff ;
10048: CALL_OW 7
// canSendHeike = true ;
10052: LD_ADDR_EXP 28
10056: PUSH
10057: LD_INT 1
10059: ST_TO_ADDR
// KurtWaitingForFreeHeike = true ;
10060: LD_ADDR_EXP 23
10064: PUSH
10065: LD_INT 1
10067: ST_TO_ADDR
// KurtWaitingForBuildBarrack = false ;
10068: LD_ADDR_EXP 24
10072: PUSH
10073: LD_INT 0
10075: ST_TO_ADDR
// allowExitFromMap = 3 ;
10076: LD_ADDR_EXP 18
10080: PUSH
10081: LD_INT 3
10083: ST_TO_ADDR
// if KurtCanEscape then
10084: LD_EXP 21
10088: IFFALSE 10111
// ComMoveToArea ( [ Kurt , KurtEng ] , KurtExitMapArea ) ;
10090: LD_EXP 80
10094: PUSH
10095: LD_EXP 82
10099: PUSH
10100: EMPTY
10101: LIST
10102: LIST
10103: PPUSH
10104: LD_INT 11
10106: PPUSH
10107: CALL_OW 113
// end ;
10111: LD_VAR 0 1
10115: RET
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 2 ] ] ) and not dial_ArriveGensherUnitsBlocker do var veh , nearGensherUnit , maleSold , waitForKurt ;
10116: LD_INT 22
10118: PUSH
10119: LD_INT 2
10121: PUSH
10122: EMPTY
10123: LIST
10124: LIST
10125: PUSH
10126: EMPTY
10127: LIST
10128: PPUSH
10129: CALL_OW 69
10133: PUSH
10134: LD_EXP 7
10138: NOT
10139: AND
10140: IFFALSE 10913
10142: GO 10144
10144: DISABLE
10145: LD_INT 0
10147: PPUSH
10148: PPUSH
10149: PPUSH
10150: PPUSH
// begin nearGensherUnit = NearestUnitToXY ( UnitFilter ( GensherTeam , [ [ f_type , unit_vehicle ] ] ) , GensherTargetX , GensherTargetY ) ;
10151: LD_ADDR_VAR 0 2
10155: PUSH
10156: LD_EXP 83
10160: PPUSH
10161: LD_INT 21
10163: PUSH
10164: LD_INT 2
10166: PUSH
10167: EMPTY
10168: LIST
10169: LIST
10170: PUSH
10171: EMPTY
10172: LIST
10173: PPUSH
10174: CALL_OW 72
10178: PPUSH
10179: LD_EXP 16
10183: PPUSH
10184: LD_EXP 17
10188: PPUSH
10189: CALL_OW 73
10193: ST_TO_ADDR
// maleSold = UnitsInside ( nearGensherUnit [ 1 ] ) ;
10194: LD_ADDR_VAR 0 3
10198: PUSH
10199: LD_VAR 0 2
10203: PUSH
10204: LD_INT 1
10206: ARRAY
10207: PPUSH
10208: CALL_OW 313
10212: ST_TO_ADDR
// if GetDistUnitXY ( nearGensherUnit , GensherTargetX , GensherTargetY ) <= 5 then
10213: LD_VAR 0 2
10217: PPUSH
10218: LD_EXP 16
10222: PPUSH
10223: LD_EXP 17
10227: PPUSH
10228: CALL_OW 297
10232: PUSH
10233: LD_INT 5
10235: LESSEQUAL
10236: IFFALSE 10912
// begin dial_ArriveGensherUnitsBlocker = true ;
10238: LD_ADDR_EXP 7
10242: PUSH
10243: LD_INT 1
10245: ST_TO_ADDR
// for veh in UnitFilter ( GensherTeam , [ [ f_type , unit_vehicle ] ] ) do
10246: LD_ADDR_VAR 0 1
10250: PUSH
10251: LD_EXP 83
10255: PPUSH
10256: LD_INT 21
10258: PUSH
10259: LD_INT 2
10261: PUSH
10262: EMPTY
10263: LIST
10264: LIST
10265: PUSH
10266: EMPTY
10267: LIST
10268: PPUSH
10269: CALL_OW 72
10273: PUSH
10274: FOR_IN
10275: IFFALSE 10297
// ComExitVehicle ( UnitsInside ( veh ) [ 1 ] ) ;
10277: LD_VAR 0 1
10281: PPUSH
10282: CALL_OW 313
10286: PUSH
10287: LD_INT 1
10289: ARRAY
10290: PPUSH
10291: CALL_OW 121
10295: GO 10274
10297: POP
10298: POP
// wait ( 0 0$1 ) ;
10299: LD_INT 35
10301: PPUSH
10302: CALL_OW 67
// SetSide ( UnitFilter ( GensherTeam , [ [ f_type , unit_vehicle ] ] ) , 3 ) ;
10306: LD_EXP 83
10310: PPUSH
10311: LD_INT 21
10313: PUSH
10314: LD_INT 2
10316: PUSH
10317: EMPTY
10318: LIST
10319: LIST
10320: PUSH
10321: EMPTY
10322: LIST
10323: PPUSH
10324: CALL_OW 72
10328: PPUSH
10329: LD_INT 3
10331: PPUSH
10332: CALL_OW 235
// CenterOnUnits ( maleSold ) ;
10336: LD_VAR 0 3
10340: PPUSH
10341: CALL_OW 85
// DialogueOn ;
10345: CALL_OW 6
// Say ( maleSold , DHandOverCome-ASol1-1 ) ;
10349: LD_VAR 0 3
10353: PPUSH
10354: LD_STRING DHandOverCome-ASol1-1
10356: PPUSH
10357: CALL_OW 88
// Say ( Kurt , DHandOverCome-Kurt-1 ) ;
10361: LD_EXP 80
10365: PPUSH
10366: LD_STRING DHandOverCome-Kurt-1
10368: PPUSH
10369: CALL_OW 88
// DialogueOff ;
10373: CALL_OW 7
// KurtWaitingForBuildBarrack = false ;
10377: LD_ADDR_EXP 24
10381: PUSH
10382: LD_INT 0
10384: ST_TO_ADDR
// if GetDistUnits ( Kurt , UnitFilter ( GensherTeam , [ f_type , unit_vehicle ] ) [ 1 ] ) <= 8 or GetSide ( KurtEng ) = 3 then
10385: LD_EXP 80
10389: PPUSH
10390: LD_EXP 83
10394: PPUSH
10395: LD_INT 21
10397: PUSH
10398: LD_INT 2
10400: PUSH
10401: EMPTY
10402: LIST
10403: LIST
10404: PPUSH
10405: CALL_OW 72
10409: PUSH
10410: LD_INT 1
10412: ARRAY
10413: PPUSH
10414: CALL_OW 296
10418: PUSH
10419: LD_INT 8
10421: LESSEQUAL
10422: PUSH
10423: LD_EXP 82
10427: PPUSH
10428: CALL_OW 255
10432: PUSH
10433: LD_INT 3
10435: EQUAL
10436: OR
10437: IFFALSE 10542
// begin KurtCanEscape = false ;
10439: LD_ADDR_EXP 21
10443: PUSH
10444: LD_INT 0
10446: ST_TO_ADDR
// SetSide ( [ Kurt , KurtEng ] , 2 ) ;
10447: LD_EXP 80
10451: PUSH
10452: LD_EXP 82
10456: PUSH
10457: EMPTY
10458: LIST
10459: LIST
10460: PPUSH
10461: LD_INT 2
10463: PPUSH
10464: CALL_OW 235
// ComStop ( [ Kurt , KurtEng ] ) ;
10468: LD_EXP 80
10472: PUSH
10473: LD_EXP 82
10477: PUSH
10478: EMPTY
10479: LIST
10480: LIST
10481: PPUSH
10482: CALL_OW 141
// ComMoveXY ( [ Kurt , KurtEng ] , GetX ( maleSold ) , GetY ( maleSold ) ) ;
10486: LD_EXP 80
10490: PUSH
10491: LD_EXP 82
10495: PUSH
10496: EMPTY
10497: LIST
10498: LIST
10499: PPUSH
10500: LD_VAR 0 3
10504: PPUSH
10505: CALL_OW 250
10509: PPUSH
10510: LD_VAR 0 3
10514: PPUSH
10515: CALL_OW 251
10519: PPUSH
10520: CALL_OW 111
// waitForKurt = true ;
10524: LD_ADDR_VAR 0 4
10528: PUSH
10529: LD_INT 1
10531: ST_TO_ADDR
// KurtStatus = 3 ;
10532: LD_ADDR_EXP 22
10536: PUSH
10537: LD_INT 3
10539: ST_TO_ADDR
// end else
10540: GO 10780
// if GetDistUnits ( Kurt , UnitFilter ( GensherTeam , [ f_type , unit_vehicle ] ) [ 1 ] ) > 8 then
10542: LD_EXP 80
10546: PPUSH
10547: LD_EXP 83
10551: PPUSH
10552: LD_INT 21
10554: PUSH
10555: LD_INT 2
10557: PUSH
10558: EMPTY
10559: LIST
10560: LIST
10561: PPUSH
10562: CALL_OW 72
10566: PUSH
10567: LD_INT 1
10569: ARRAY
10570: PPUSH
10571: CALL_OW 296
10575: PUSH
10576: LD_INT 8
10578: GREATER
10579: IFFALSE 10780
// begin allowExitFromMap = 4 ;
10581: LD_ADDR_EXP 18
10585: PUSH
10586: LD_INT 4
10588: ST_TO_ADDR
// KurtStatus = 2 ;
10589: LD_ADDR_EXP 22
10593: PUSH
10594: LD_INT 2
10596: ST_TO_ADDR
// ComMoveToArea ( [ Kurt , KurtEng ] , KurtExitMapArea ) ;
10597: LD_EXP 80
10601: PUSH
10602: LD_EXP 82
10606: PUSH
10607: EMPTY
10608: LIST
10609: LIST
10610: PPUSH
10611: LD_INT 11
10613: PPUSH
10614: CALL_OW 113
// repeat ComAttackUnit ( UnitFilter ( GensherTeam , [ [ f_type , unit_human ] ] ) , Kurt ) ;
10618: LD_EXP 83
10622: PPUSH
10623: LD_INT 21
10625: PUSH
10626: LD_INT 1
10628: PUSH
10629: EMPTY
10630: LIST
10631: LIST
10632: PUSH
10633: EMPTY
10634: LIST
10635: PPUSH
10636: CALL_OW 72
10640: PPUSH
10641: LD_EXP 80
10645: PPUSH
10646: CALL_OW 115
// wait ( 0 0$1 ) ;
10650: LD_INT 35
10652: PPUSH
10653: CALL_OW 67
// until GetDistUnits ( NearestUnitToUnit ( UnitFilter ( GensherTeam , [ [ f_type , unit_human ] ] ) , Kurt ) , Kurt ) <= 9 or ( not IsPlaced ( Kurt ) and not IsPlaced ( KurtEng ) ) ;
10657: LD_EXP 83
10661: PPUSH
10662: LD_INT 21
10664: PUSH
10665: LD_INT 1
10667: PUSH
10668: EMPTY
10669: LIST
10670: LIST
10671: PUSH
10672: EMPTY
10673: LIST
10674: PPUSH
10675: CALL_OW 72
10679: PPUSH
10680: LD_EXP 80
10684: PPUSH
10685: CALL_OW 74
10689: PPUSH
10690: LD_EXP 80
10694: PPUSH
10695: CALL_OW 296
10699: PUSH
10700: LD_INT 9
10702: LESSEQUAL
10703: PUSH
10704: LD_EXP 80
10708: PPUSH
10709: CALL_OW 305
10713: NOT
10714: PUSH
10715: LD_EXP 82
10719: PPUSH
10720: CALL_OW 305
10724: NOT
10725: AND
10726: OR
10727: IFFALSE 10618
// ComMoveToArea ( [ Kurt , KurtEng ] , ExitMapArea ) ;
10729: LD_EXP 80
10733: PUSH
10734: LD_EXP 82
10738: PUSH
10739: EMPTY
10740: LIST
10741: LIST
10742: PPUSH
10743: LD_INT 8
10745: PPUSH
10746: CALL_OW 113
// ComMoveToArea ( UnitFilter ( GensherTeam , [ [ f_type , unit_human ] ] ) , ExitMapArea ) ;
10750: LD_EXP 83
10754: PPUSH
10755: LD_INT 21
10757: PUSH
10758: LD_INT 1
10760: PUSH
10761: EMPTY
10762: LIST
10763: LIST
10764: PUSH
10765: EMPTY
10766: LIST
10767: PPUSH
10768: CALL_OW 72
10772: PPUSH
10773: LD_INT 8
10775: PPUSH
10776: CALL_OW 113
// end ; if waitForKurt then
10780: LD_VAR 0 4
10784: IFFALSE 10910
// begin repeat wait ( 0 0$1 ) ;
10786: LD_INT 35
10788: PPUSH
10789: CALL_OW 67
// ComMoveXY ( [ Kurt , KurtEng ] , GetX ( maleSold ) , GetY ( maleSold ) ) ;
10793: LD_EXP 80
10797: PUSH
10798: LD_EXP 82
10802: PUSH
10803: EMPTY
10804: LIST
10805: LIST
10806: PPUSH
10807: LD_VAR 0 3
10811: PPUSH
10812: CALL_OW 250
10816: PPUSH
10817: LD_VAR 0 3
10821: PPUSH
10822: CALL_OW 251
10826: PPUSH
10827: CALL_OW 111
// until GetDistUnits ( Kurt , maleSold ) <= 2 ;
10831: LD_EXP 80
10835: PPUSH
10836: LD_VAR 0 3
10840: PPUSH
10841: CALL_OW 296
10845: PUSH
10846: LD_INT 2
10848: LESSEQUAL
10849: IFFALSE 10786
// allowExitFromMap = 4 ;
10851: LD_ADDR_EXP 18
10855: PUSH
10856: LD_INT 4
10858: ST_TO_ADDR
// ComMoveToArea ( [ Kurt , KurtEng ] , ExitMapArea ) ;
10859: LD_EXP 80
10863: PUSH
10864: LD_EXP 82
10868: PUSH
10869: EMPTY
10870: LIST
10871: LIST
10872: PPUSH
10873: LD_INT 8
10875: PPUSH
10876: CALL_OW 113
// ComMoveToArea ( UnitFilter ( GensherTeam , [ [ f_type , unit_human ] ] ) , ExitMapArea ) ;
10880: LD_EXP 83
10884: PPUSH
10885: LD_INT 21
10887: PUSH
10888: LD_INT 1
10890: PUSH
10891: EMPTY
10892: LIST
10893: LIST
10894: PUSH
10895: EMPTY
10896: LIST
10897: PPUSH
10898: CALL_OW 72
10902: PPUSH
10903: LD_INT 8
10905: PPUSH
10906: CALL_OW 113
// end ; exit ;
10910: GO 10913
// end ; enable ;
10912: ENABLE
// end ;
10913: PPOPN 4
10915: END
// export function Dial_AttackGensher ; var unit ; begin
10916: LD_INT 0
10918: PPUSH
10919: PPUSH
// DialogueOn ;
10920: CALL_OW 6
// SayRadio ( Dietrich , DHandOverSpoiled-Diet-1 ) ;
10924: LD_EXP 81
10928: PPUSH
10929: LD_STRING DHandOverSpoiled-Diet-1
10931: PPUSH
10932: CALL_OW 94
// DialogueOff ;
10936: CALL_OW 7
// SetAttitude ( 3 , 2 , att_enemy , true ) ;
10940: LD_INT 3
10942: PPUSH
10943: LD_INT 2
10945: PPUSH
10946: LD_INT 2
10948: PPUSH
10949: LD_INT 1
10951: PPUSH
10952: CALL_OW 80
// for unit in UnitFilter ( GensherTeam , [ [ f_type , unit_human ] ] ) do
10956: LD_ADDR_VAR 0 2
10960: PUSH
10961: LD_EXP 83
10965: PPUSH
10966: LD_INT 21
10968: PUSH
10969: LD_INT 1
10971: PUSH
10972: EMPTY
10973: LIST
10974: LIST
10975: PUSH
10976: EMPTY
10977: LIST
10978: PPUSH
10979: CALL_OW 72
10983: PUSH
10984: FOR_IN
10985: IFFALSE 11045
// begin if IsInUnit ( unit ) then
10987: LD_VAR 0 2
10991: PPUSH
10992: CALL_OW 310
10996: IFFALSE 11007
// ComExitVehicle ( unit ) ;
10998: LD_VAR 0 2
11002: PPUSH
11003: CALL_OW 121
// wait ( 0 0$01 ) ;
11007: LD_INT 35
11009: PPUSH
11010: CALL_OW 67
// AddComAgressiveMove ( unit , GetX ( Burlak ) , GetY ( Burlak ) ) ;
11014: LD_VAR 0 2
11018: PPUSH
11019: LD_EXP 57
11023: PPUSH
11024: CALL_OW 250
11028: PPUSH
11029: LD_EXP 57
11033: PPUSH
11034: CALL_OW 251
11038: PPUSH
11039: CALL_OW 174
// end ;
11043: GO 10984
11045: POP
11046: POP
// coopWithGensher = 2 ;
11047: LD_ADDR_EXP 2
11051: PUSH
11052: LD_INT 2
11054: ST_TO_ADDR
// end ;
11055: LD_VAR 0 1
11059: RET
// every 0 0$1 trigger canSendHeike and IsOK ( Heike ) and GetSide ( Heike ) = 5 do var legionSold ;
11060: LD_EXP 28
11064: PUSH
11065: LD_EXP 79
11069: PPUSH
11070: CALL_OW 302
11074: AND
11075: PUSH
11076: LD_EXP 79
11080: PPUSH
11081: CALL_OW 255
11085: PUSH
11086: LD_INT 5
11088: EQUAL
11089: AND
11090: IFFALSE 11410
11092: GO 11094
11094: DISABLE
11095: LD_INT 0
11097: PPUSH
// begin if IsSelected ( Heike ) then
11098: LD_EXP 79
11102: PPUSH
11103: CALL_OW 306
11107: IFFALSE 11402
// begin if Query ( QSendHeike ) = 1 then
11109: LD_STRING QSendHeike
11111: PPUSH
11112: CALL_OW 97
11116: PUSH
11117: LD_INT 1
11119: EQUAL
11120: IFFALSE 11402
// begin KurtWaitingForFreeHeike = false ;
11122: LD_ADDR_EXP 23
11126: PUSH
11127: LD_INT 0
11129: ST_TO_ADDR
// ComMoveXY ( Heike , 82 , 46 ) ;
11130: LD_EXP 79
11134: PPUSH
11135: LD_INT 82
11137: PPUSH
11138: LD_INT 46
11140: PPUSH
11141: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
11145: LD_INT 35
11147: PPUSH
11148: CALL_OW 67
// until GetDistUnitXY ( Heike , 82 , 46 ) <= 5 or IsDead ( Heike ) ;
11152: LD_EXP 79
11156: PPUSH
11157: LD_INT 82
11159: PPUSH
11160: LD_INT 46
11162: PPUSH
11163: CALL_OW 297
11167: PUSH
11168: LD_INT 5
11170: LESSEQUAL
11171: PUSH
11172: LD_EXP 79
11176: PPUSH
11177: CALL_OW 301
11181: OR
11182: IFFALSE 11145
// if not askCommanders then
11184: LD_EXP 20
11188: NOT
11189: IFFALSE 11235
// begin DialogueOn ;
11191: CALL_OW 6
// SayRadio ( Popov , DMercPopov-Pop-1 ) ;
11195: LD_EXP 76
11199: PPUSH
11200: LD_STRING DMercPopov-Pop-1
11202: PPUSH
11203: CALL_OW 94
// Say ( Burlak , DMercPopov-Bur-1 ) ;
11207: LD_EXP 57
11211: PPUSH
11212: LD_STRING DMercPopov-Bur-1
11214: PPUSH
11215: CALL_OW 88
// SayRadio ( Popov , DMercPopov-Pop-2 ) ;
11219: LD_EXP 76
11223: PPUSH
11224: LD_STRING DMercPopov-Pop-2
11226: PPUSH
11227: CALL_OW 94
// DialogueOff ;
11231: CALL_OW 7
// end ; uc_side = 8 ;
11235: LD_ADDR_OWVAR 20
11239: PUSH
11240: LD_INT 8
11242: ST_TO_ADDR
// uc_nation = 2 ;
11243: LD_ADDR_OWVAR 21
11247: PUSH
11248: LD_INT 2
11250: ST_TO_ADDR
// PrepareSoldier ( false , 6 ) ;
11251: LD_INT 0
11253: PPUSH
11254: LD_INT 6
11256: PPUSH
11257: CALL_OW 381
// legionSold = CreateHuman ;
11261: LD_ADDR_VAR 0 1
11265: PUSH
11266: CALL_OW 44
11270: ST_TO_ADDR
// PlaceUnitXYR ( legionSold , 26 , 48 , 4 , false ) ;
11271: LD_VAR 0 1
11275: PPUSH
11276: LD_INT 26
11278: PPUSH
11279: LD_INT 48
11281: PPUSH
11282: LD_INT 4
11284: PPUSH
11285: LD_INT 0
11287: PPUSH
11288: CALL_OW 50
// repeat wait ( 0 0$1 ) ;
11292: LD_INT 35
11294: PPUSH
11295: CALL_OW 67
// ComMoveXY ( legionSold , GetX ( Heike ) , GetY ( Heike ) ) ;
11299: LD_VAR 0 1
11303: PPUSH
11304: LD_EXP 79
11308: PPUSH
11309: CALL_OW 250
11313: PPUSH
11314: LD_EXP 79
11318: PPUSH
11319: CALL_OW 251
11323: PPUSH
11324: CALL_OW 111
// until GetDistUnits ( legionSold , Heike ) <= 5 or IsDead ( Heike ) ;
11328: LD_VAR 0 1
11332: PPUSH
11333: LD_EXP 79
11337: PPUSH
11338: CALL_OW 296
11342: PUSH
11343: LD_INT 5
11345: LESSEQUAL
11346: PUSH
11347: LD_EXP 79
11351: PPUSH
11352: CALL_OW 301
11356: OR
11357: IFFALSE 11292
// SetSide ( Heike , 8 ) ;
11359: LD_EXP 79
11363: PPUSH
11364: LD_INT 8
11366: PPUSH
11367: CALL_OW 235
// allowExitFromMap = 3 ;
11371: LD_ADDR_EXP 18
11375: PUSH
11376: LD_INT 3
11378: ST_TO_ADDR
// ComMoveToArea ( [ legionSold , Heike ] , KurtExitMapArea ) ;
11379: LD_VAR 0 1
11383: PUSH
11384: LD_EXP 79
11388: PUSH
11389: EMPTY
11390: LIST
11391: LIST
11392: PPUSH
11393: LD_INT 11
11395: PPUSH
11396: CALL_OW 113
// exit ;
11400: GO 11410
// end ; end ; wait ( 0 0$3 ) ;
11402: LD_INT 105
11404: PPUSH
11405: CALL_OW 67
// enable ;
11409: ENABLE
// end ;
11410: PPOPN 1
11412: END
// export function Dial_PlayerDontSendHeike ; begin
11413: LD_INT 0
11415: PPUSH
// DialogueOn ;
11416: CALL_OW 6
// SayRadio ( Kurt , DMercDeceived-Kurt-1 ) ;
11420: LD_EXP 80
11424: PPUSH
11425: LD_STRING DMercDeceived-Kurt-1
11427: PPUSH
11428: CALL_OW 94
// DialogueOff ;
11432: CALL_OW 7
// SetAttitude ( 3 , 8 , att_enemy , true ) ;
11436: LD_INT 3
11438: PPUSH
11439: LD_INT 8
11441: PPUSH
11442: LD_INT 2
11444: PPUSH
11445: LD_INT 1
11447: PPUSH
11448: CALL_OW 80
// KurtAttack = true ;
11452: LD_ADDR_EXP 25
11456: PUSH
11457: LD_INT 1
11459: ST_TO_ADDR
// end ;
11460: LD_VAR 0 1
11464: RET
// export function Dial_BetrayedKurt1 ; begin
11465: LD_INT 0
11467: PPUSH
// DialogueOn ;
11468: CALL_OW 6
// Say ( Kurt , DMercDeceived-Kurt-1 ) ;
11472: LD_EXP 80
11476: PPUSH
11477: LD_STRING DMercDeceived-Kurt-1
11479: PPUSH
11480: CALL_OW 88
// DialogueOff ;
11484: CALL_OW 7
// if IsPlaced ( Kurt ) then
11488: LD_EXP 80
11492: PPUSH
11493: CALL_OW 305
11497: IFFALSE 11546
// begin SetSide ( KurtEng , 8 ) ;
11499: LD_EXP 82
11503: PPUSH
11504: LD_INT 8
11506: PPUSH
11507: CALL_OW 235
// allowExitFromMap = 3 ;
11511: LD_ADDR_EXP 18
11515: PUSH
11516: LD_INT 3
11518: ST_TO_ADDR
// if KurtCanEscape then
11519: LD_EXP 21
11523: IFFALSE 11546
// ComMoveToArea ( [ Kurt , KurtEng ] , KurtExitMapArea ) ;
11525: LD_EXP 80
11529: PUSH
11530: LD_EXP 82
11534: PUSH
11535: EMPTY
11536: LIST
11537: LIST
11538: PPUSH
11539: LD_INT 11
11541: PPUSH
11542: CALL_OW 113
// end ; end ;
11546: LD_VAR 0 1
11550: RET
// export function Dial_BetrayedKurt2 ; begin
11551: LD_INT 0
11553: PPUSH
// DialogueOn ;
11554: CALL_OW 6
// Say ( Kurt , DMercAmbush-Kurt-1 ) ;
11558: LD_EXP 80
11562: PPUSH
11563: LD_STRING DMercAmbush-Kurt-1
11565: PPUSH
11566: CALL_OW 88
// DialogueOff ;
11570: CALL_OW 7
// if IsPlaced ( Kurt ) then
11574: LD_EXP 80
11578: PPUSH
11579: CALL_OW 305
11583: IFFALSE 11632
// begin SetSide ( KurtEng , 8 ) ;
11585: LD_EXP 82
11589: PPUSH
11590: LD_INT 8
11592: PPUSH
11593: CALL_OW 235
// allowExitFromMap = 3 ;
11597: LD_ADDR_EXP 18
11601: PUSH
11602: LD_INT 3
11604: ST_TO_ADDR
// if KurtCanEscape then
11605: LD_EXP 21
11609: IFFALSE 11632
// ComMoveToArea ( [ Kurt , KurtEng ] , KurtExitMapArea ) ;
11611: LD_EXP 80
11615: PUSH
11616: LD_EXP 82
11620: PUSH
11621: EMPTY
11622: LIST
11623: LIST
11624: PPUSH
11625: LD_INT 11
11627: PPUSH
11628: CALL_OW 113
// end ; end ;
11632: LD_VAR 0 1
11636: RET
// every 0 0$1 trigger GetSide ( KurtEng ) = 3 do var playerUnits , unit ;
11637: LD_EXP 82
11641: PPUSH
11642: CALL_OW 255
11646: PUSH
11647: LD_INT 3
11649: EQUAL
11650: IFFALSE 11797
11652: GO 11654
11654: DISABLE
11655: LD_INT 0
11657: PPUSH
11658: PPUSH
// begin playerUnits = FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
11659: LD_ADDR_VAR 0 1
11663: PUSH
11664: LD_INT 22
11666: PUSH
11667: LD_INT 3
11669: PUSH
11670: EMPTY
11671: LIST
11672: LIST
11673: PUSH
11674: LD_INT 2
11676: PUSH
11677: LD_INT 21
11679: PUSH
11680: LD_INT 1
11682: PUSH
11683: EMPTY
11684: LIST
11685: LIST
11686: PUSH
11687: LD_INT 21
11689: PUSH
11690: LD_INT 2
11692: PUSH
11693: EMPTY
11694: LIST
11695: LIST
11696: PUSH
11697: EMPTY
11698: LIST
11699: LIST
11700: LIST
11701: PUSH
11702: EMPTY
11703: LIST
11704: LIST
11705: PPUSH
11706: CALL_OW 69
11710: ST_TO_ADDR
// for unit in playerUnits do
11711: LD_ADDR_VAR 0 2
11715: PUSH
11716: LD_VAR 0 1
11720: PUSH
11721: FOR_IN
11722: IFFALSE 11751
// begin if WantsToAttack ( unit ) = KurtEng then
11724: LD_VAR 0 2
11728: PPUSH
11729: CALL_OW 319
11733: PUSH
11734: LD_EXP 82
11738: EQUAL
11739: IFFALSE 11749
// begin Dial_BetrayedKurt2 ;
11741: CALL 11551 0 0
// exit ;
11745: POP
11746: POP
11747: GO 11797
// end ; end ;
11749: GO 11721
11751: POP
11752: POP
// if ( IsDying ( KurtEng ) or IsDead ( KurtEng ) ) and GetSide ( KurtEng ) = 3 then
11753: LD_EXP 82
11757: PPUSH
11758: CALL_OW 303
11762: PUSH
11763: LD_EXP 82
11767: PPUSH
11768: CALL_OW 301
11772: OR
11773: PUSH
11774: LD_EXP 82
11778: PPUSH
11779: CALL_OW 255
11783: PUSH
11784: LD_INT 3
11786: EQUAL
11787: AND
11788: IFFALSE 11796
// begin Dial_BetrayedKurt2 ;
11790: CALL 11551 0 0
// exit ;
11794: GO 11797
// end ; enable ;
11796: ENABLE
// end ;
11797: PPOPN 2
11799: END
// every 0 0$1 trigger GetAttitude ( 3 , 8 ) = att_neutral and GetLives ( Kurt ) <= 999 do
11800: LD_INT 3
11802: PPUSH
11803: LD_INT 8
11805: PPUSH
11806: CALL_OW 81
11810: PUSH
11811: LD_INT 0
11813: EQUAL
11814: PUSH
11815: LD_EXP 80
11819: PPUSH
11820: CALL_OW 256
11824: PUSH
11825: LD_INT 999
11827: LESSEQUAL
11828: AND
11829: IFFALSE 11854
11831: GO 11833
11833: DISABLE
// begin Dial_BetrayedKurt1 ;
11834: CALL 11465 0 0
// SetAttitude ( 3 , 8 , att_enemy , true ) ;
11838: LD_INT 3
11840: PPUSH
11841: LD_INT 8
11843: PPUSH
11844: LD_INT 2
11846: PPUSH
11847: LD_INT 1
11849: PPUSH
11850: CALL_OW 80
// end ;
11854: END
// every 0 0$1 trigger buildingsToBuild <= 11 do
11855: LD_EXP 8
11859: PUSH
11860: LD_INT 11
11862: LESSEQUAL
11863: IFFALSE 12112
11865: GO 11867
11867: DISABLE
// begin if not IsOK ( Kuzmov ) and not IsOK ( Oblukov ) then
11868: LD_EXP 72
11872: PPUSH
11873: CALL_OW 302
11877: NOT
11878: PUSH
11879: LD_EXP 74
11883: PPUSH
11884: CALL_OW 302
11888: NOT
11889: AND
11890: IFFALSE 11894
// exit ;
11892: GO 12112
// DialogueOn ;
11894: CALL_OW 6
// if IsOK ( Kuzmov ) then
11898: LD_EXP 72
11902: PPUSH
11903: CALL_OW 302
11907: IFFALSE 11923
// Say ( Kuzmov , DFiringRange-Kuz-1 ) else
11909: LD_EXP 72
11913: PPUSH
11914: LD_STRING DFiringRange-Kuz-1
11916: PPUSH
11917: CALL_OW 88
11921: GO 11935
// Say ( Oblukov , DFiringRange-Obl-1 ) ;
11923: LD_EXP 74
11927: PPUSH
11928: LD_STRING DFiringRange-Obl-1
11930: PPUSH
11931: CALL_OW 88
// Say ( Burlak , DFiringRange-Bur-1 ) ;
11935: LD_EXP 57
11939: PPUSH
11940: LD_STRING DFiringRange-Bur-1
11942: PPUSH
11943: CALL_OW 88
// CenterOnXY ( 99 , 30 ) ;
11947: LD_INT 99
11949: PPUSH
11950: LD_INT 30
11952: PPUSH
11953: CALL_OW 84
// Wait ( 0 0$0.5 ) ;
11957: LD_INT 18
11959: PPUSH
11960: CALL_OW 67
// RevealFogArea ( 3 , ShootArea ) ;
11964: LD_INT 3
11966: PPUSH
11967: LD_INT 12
11969: PPUSH
11970: CALL_OW 332
// SetAreaMapShow ( ShootArea , 1 ) ;
11974: LD_INT 12
11976: PPUSH
11977: LD_INT 1
11979: PPUSH
11980: CALL_OW 424
// if IsOK ( Kuzmov ) then
11984: LD_EXP 72
11988: PPUSH
11989: CALL_OW 302
11993: IFFALSE 12009
// Say ( Kuzmov , DFiringRange-Kuz-2 ) else
11995: LD_EXP 72
11999: PPUSH
12000: LD_STRING DFiringRange-Kuz-2
12002: PPUSH
12003: CALL_OW 88
12007: GO 12021
// Say ( Oblukov , DFiringRange-Obl-2 ) ;
12009: LD_EXP 74
12013: PPUSH
12014: LD_STRING DFiringRange-Obl-2
12016: PPUSH
12017: CALL_OW 88
// case Query ( QShootingGallery ) of 1 :
12021: LD_STRING QShootingGallery
12023: PPUSH
12024: CALL_OW 97
12028: PUSH
12029: LD_INT 1
12031: DOUBLE
12032: EQUAL
12033: IFTRUE 12037
12035: GO 12074
12037: POP
// begin Say ( Burlak , DQrShootingGallery#1-Bur-1 ) ;
12038: LD_EXP 57
12042: PPUSH
12043: LD_STRING DQrShootingGallery#1-Bur-1
12045: PPUSH
12046: CALL_OW 88
// BurlakRespect = BurlakRespect + 1 ;
12050: LD_ADDR_EXP 30
12054: PUSH
12055: LD_EXP 30
12059: PUSH
12060: LD_INT 1
12062: PLUS
12063: ST_TO_ADDR
// canShootTrening = true ;
12064: LD_ADDR_EXP 29
12068: PUSH
12069: LD_INT 1
12071: ST_TO_ADDR
// end ; 2 :
12072: GO 12108
12074: LD_INT 2
12076: DOUBLE
12077: EQUAL
12078: IFTRUE 12082
12080: GO 12107
12082: POP
// begin Say ( Burlak , DQrShootingGallery#2-Bur-1 ) ;
12083: LD_EXP 57
12087: PPUSH
12088: LD_STRING DQrShootingGallery#2-Bur-1
12090: PPUSH
12091: CALL_OW 88
// SetAreaMapShow ( ShootArea , 0 ) ;
12095: LD_INT 12
12097: PPUSH
12098: LD_INT 0
12100: PPUSH
12101: CALL_OW 424
// end ; end ;
12105: GO 12108
12107: POP
// DialogueOff ;
12108: CALL_OW 7
// end ;
12112: END
// every 0 0$1 trigger canShootTrening do
12113: LD_EXP 29
12117: IFFALSE 12127
12119: GO 12121
12121: DISABLE
// begin enable ;
12122: ENABLE
// ShootTreningController ;
12123: CALL 7091 0 0
// end ;
12127: END
// every 0 0$1 trigger buildingsToBuild <= 7 do var hunters , hunter ;
12128: LD_EXP 8
12132: PUSH
12133: LD_INT 7
12135: LESSEQUAL
12136: IFFALSE 12526
12138: GO 12140
12140: DISABLE
12141: LD_INT 0
12143: PPUSH
12144: PPUSH
// begin hunters = [ ] ;
12145: LD_ADDR_VAR 0 1
12149: PUSH
12150: EMPTY
12151: ST_TO_ADDR
// if IsOK ( Belkov ) then
12152: LD_EXP 66
12156: PPUSH
12157: CALL_OW 302
12161: IFFALSE 12179
// hunters = hunters ^ Belkov ;
12163: LD_ADDR_VAR 0 1
12167: PUSH
12168: LD_VAR 0 1
12172: PUSH
12173: LD_EXP 66
12177: ADD
12178: ST_TO_ADDR
// if IsOK ( Karamazov ) then
12179: LD_EXP 58
12183: PPUSH
12184: CALL_OW 302
12188: IFFALSE 12206
// hunters = hunters ^ Karamazov ;
12190: LD_ADDR_VAR 0 1
12194: PUSH
12195: LD_VAR 0 1
12199: PUSH
12200: LD_EXP 58
12204: ADD
12205: ST_TO_ADDR
// if IsOK ( Kozlov ) then
12206: LD_EXP 73
12210: PPUSH
12211: CALL_OW 302
12215: IFFALSE 12233
// hunters = hunters ^ Kozlov ;
12217: LD_ADDR_VAR 0 1
12221: PUSH
12222: LD_VAR 0 1
12226: PUSH
12227: LD_EXP 73
12231: ADD
12232: ST_TO_ADDR
// if not hunters then
12233: LD_VAR 0 1
12237: NOT
12238: IFFALSE 12242
// exit ;
12240: GO 12526
// hunter = hunters [ Rand ( 1 , hunters ) ] ;
12242: LD_ADDR_VAR 0 2
12246: PUSH
12247: LD_VAR 0 1
12251: PUSH
12252: LD_INT 1
12254: PPUSH
12255: LD_VAR 0 1
12259: PPUSH
12260: CALL_OW 12
12264: ARRAY
12265: ST_TO_ADDR
// DialogueOn ;
12266: CALL_OW 6
// case hunter of Belkov :
12270: LD_VAR 0 2
12274: PUSH
12275: LD_EXP 66
12279: DOUBLE
12280: EQUAL
12281: IFTRUE 12285
12283: GO 12300
12285: POP
// Say ( Belkov , DHunting-Bel-1 ) ; Karamazov :
12286: LD_EXP 66
12290: PPUSH
12291: LD_STRING DHunting-Bel-1
12293: PPUSH
12294: CALL_OW 88
12298: GO 12351
12300: LD_EXP 58
12304: DOUBLE
12305: EQUAL
12306: IFTRUE 12310
12308: GO 12325
12310: POP
// Say ( Karamazov , DHunting-Kar-1 ) ; Kozlov :
12311: LD_EXP 58
12315: PPUSH
12316: LD_STRING DHunting-Kar-1
12318: PPUSH
12319: CALL_OW 88
12323: GO 12351
12325: LD_EXP 73
12329: DOUBLE
12330: EQUAL
12331: IFTRUE 12335
12333: GO 12350
12335: POP
// Say ( Kozlov , DHunting-Koz-1 ) ; end ;
12336: LD_EXP 73
12340: PPUSH
12341: LD_STRING DHunting-Koz-1
12343: PPUSH
12344: CALL_OW 88
12348: GO 12351
12350: POP
// Say ( Burlak , DHunting-Bur-1 ) ;
12351: LD_EXP 57
12355: PPUSH
12356: LD_STRING DHunting-Bur-1
12358: PPUSH
12359: CALL_OW 88
// case hunter of Belkov :
12363: LD_VAR 0 2
12367: PUSH
12368: LD_EXP 66
12372: DOUBLE
12373: EQUAL
12374: IFTRUE 12378
12376: GO 12393
12378: POP
// Say ( Belkov , DHunting-Bel-2 ) ; Karamazov :
12379: LD_EXP 66
12383: PPUSH
12384: LD_STRING DHunting-Bel-2
12386: PPUSH
12387: CALL_OW 88
12391: GO 12444
12393: LD_EXP 58
12397: DOUBLE
12398: EQUAL
12399: IFTRUE 12403
12401: GO 12418
12403: POP
// Say ( Karamazov , DHunting-Kar-2 ) ; Kozlov :
12404: LD_EXP 58
12408: PPUSH
12409: LD_STRING DHunting-Kar-2
12411: PPUSH
12412: CALL_OW 88
12416: GO 12444
12418: LD_EXP 73
12422: DOUBLE
12423: EQUAL
12424: IFTRUE 12428
12426: GO 12443
12428: POP
// Say ( Kozlov , DHunting-Koz-2 ) ; end ;
12429: LD_EXP 73
12433: PPUSH
12434: LD_STRING DHunting-Koz-2
12436: PPUSH
12437: CALL_OW 88
12441: GO 12444
12443: POP
// DialogueOff ;
12444: CALL_OW 7
// case Query ( QHunting ) of 1 :
12448: LD_STRING QHunting
12450: PPUSH
12451: CALL_OW 97
12455: PUSH
12456: LD_INT 1
12458: DOUBLE
12459: EQUAL
12460: IFTRUE 12464
12462: GO 12502
12464: POP
// begin Say ( Burlak , DQrHunting#1-Bur-1 ) ;
12465: LD_EXP 57
12469: PPUSH
12470: LD_STRING DQrHunting#1-Bur-1
12472: PPUSH
12473: CALL_OW 88
// BurlakRespect = BurlakRespect + 1 ;
12477: LD_ADDR_EXP 30
12481: PUSH
12482: LD_EXP 30
12486: PUSH
12487: LD_INT 1
12489: PLUS
12490: ST_TO_ADDR
// GoToHunt ( hunter ) ;
12491: LD_VAR 0 2
12495: PPUSH
12496: CALL 7719 0 1
// end ; 2 :
12500: GO 12526
12502: LD_INT 2
12504: DOUBLE
12505: EQUAL
12506: IFTRUE 12510
12508: GO 12525
12510: POP
// Say ( Burlak , DQrHunting#2-Bur-1 ) ; end ;
12511: LD_EXP 57
12515: PPUSH
12516: LD_STRING DQrHunting#2-Bur-1
12518: PPUSH
12519: CALL_OW 88
12523: GO 12526
12525: POP
// end ;
12526: PPOPN 2
12528: END
// every 0 0$1 trigger buildingsToBuild <= 3 do var unit , womans , men , woman , man , depots ;
12529: LD_EXP 8
12533: PUSH
12534: LD_INT 3
12536: LESSEQUAL
12537: IFFALSE 13524
12539: GO 12541
12541: DISABLE
12542: LD_INT 0
12544: PPUSH
12545: PPUSH
12546: PPUSH
12547: PPUSH
12548: PPUSH
12549: PPUSH
// begin womans = [ ] ;
12550: LD_ADDR_VAR 0 2
12554: PUSH
12555: EMPTY
12556: ST_TO_ADDR
// men = [ ] ;
12557: LD_ADDR_VAR 0 3
12561: PUSH
12562: EMPTY
12563: ST_TO_ADDR
// if IsOK ( Petrovova ) then
12564: LD_EXP 59
12568: PPUSH
12569: CALL_OW 302
12573: IFFALSE 12591
// womans = womans ^ Petrovova ;
12575: LD_ADDR_VAR 0 2
12579: PUSH
12580: LD_VAR 0 2
12584: PUSH
12585: LD_EXP 59
12589: ADD
12590: ST_TO_ADDR
// if IsOK ( Kirilenkova ) then
12591: LD_EXP 65
12595: PPUSH
12596: CALL_OW 302
12600: IFFALSE 12618
// womans = womans ^ Kirilenkova ;
12602: LD_ADDR_VAR 0 2
12606: PUSH
12607: LD_VAR 0 2
12611: PUSH
12612: LD_EXP 65
12616: ADD
12617: ST_TO_ADDR
// if IsOK ( Kapitsova ) then
12618: LD_EXP 75
12622: PPUSH
12623: CALL_OW 302
12627: IFFALSE 12645
// womans = womans ^ Kapitsova ;
12629: LD_ADDR_VAR 0 2
12633: PUSH
12634: LD_VAR 0 2
12638: PUSH
12639: LD_EXP 75
12643: ADD
12644: ST_TO_ADDR
// DialogueOn ;
12645: CALL_OW 6
// if womans then
12649: LD_VAR 0 2
12653: IFFALSE 12780
// begin case womans [ Rand ( 1 , womans ) ] of Petrovova :
12655: LD_VAR 0 2
12659: PUSH
12660: LD_INT 1
12662: PPUSH
12663: LD_VAR 0 2
12667: PPUSH
12668: CALL_OW 12
12672: ARRAY
12673: PUSH
12674: LD_EXP 59
12678: DOUBLE
12679: EQUAL
12680: IFTRUE 12684
12682: GO 12709
12684: POP
// begin Say ( Petrovova , DFreeTime-Ptr-1 ) ;
12685: LD_EXP 59
12689: PPUSH
12690: LD_STRING DFreeTime-Ptr-1
12692: PPUSH
12693: CALL_OW 88
// woman = Petrovova ;
12697: LD_ADDR_VAR 0 4
12701: PUSH
12702: LD_EXP 59
12706: ST_TO_ADDR
// end ; Kirilenkova :
12707: GO 12780
12709: LD_EXP 65
12713: DOUBLE
12714: EQUAL
12715: IFTRUE 12719
12717: GO 12744
12719: POP
// begin Say ( Kirilenkova , DFreeTime-Kir-1 ) ;
12720: LD_EXP 65
12724: PPUSH
12725: LD_STRING DFreeTime-Kir-1
12727: PPUSH
12728: CALL_OW 88
// woman = Kirilenkova ;
12732: LD_ADDR_VAR 0 4
12736: PUSH
12737: LD_EXP 65
12741: ST_TO_ADDR
// end ; Kapitsova :
12742: GO 12780
12744: LD_EXP 75
12748: DOUBLE
12749: EQUAL
12750: IFTRUE 12754
12752: GO 12779
12754: POP
// begin Say ( Kapitsova , DFreeTime-Kap-1 ) ;
12755: LD_EXP 75
12759: PPUSH
12760: LD_STRING DFreeTime-Kap-1
12762: PPUSH
12763: CALL_OW 88
// woman = Kapitsova ;
12767: LD_ADDR_VAR 0 4
12771: PUSH
12772: LD_EXP 75
12776: ST_TO_ADDR
// end ; end ;
12777: GO 12780
12779: POP
// end ; if IsOK ( Kuzmov ) then
12780: LD_EXP 72
12784: PPUSH
12785: CALL_OW 302
12789: IFFALSE 12807
// men = men ^ Kuzmov ;
12791: LD_ADDR_VAR 0 3
12795: PUSH
12796: LD_VAR 0 3
12800: PUSH
12801: LD_EXP 72
12805: ADD
12806: ST_TO_ADDR
// if IsOK ( Titov ) then
12807: LD_EXP 62
12811: PPUSH
12812: CALL_OW 302
12816: IFFALSE 12834
// men = men ^ Titov ;
12818: LD_ADDR_VAR 0 3
12822: PUSH
12823: LD_VAR 0 3
12827: PUSH
12828: LD_EXP 62
12832: ADD
12833: ST_TO_ADDR
// if IsOK ( Gnyevko ) then
12834: LD_EXP 69
12838: PPUSH
12839: CALL_OW 302
12843: IFFALSE 12861
// men = men ^ Gnyevko ;
12845: LD_ADDR_VAR 0 3
12849: PUSH
12850: LD_VAR 0 3
12854: PUSH
12855: LD_EXP 69
12859: ADD
12860: ST_TO_ADDR
// if IsOK ( Oblukov ) then
12861: LD_EXP 74
12865: PPUSH
12866: CALL_OW 302
12870: IFFALSE 12888
// men = men ^ Oblukov ;
12872: LD_ADDR_VAR 0 3
12876: PUSH
12877: LD_VAR 0 3
12881: PUSH
12882: LD_EXP 74
12886: ADD
12887: ST_TO_ADDR
// if men then
12888: LD_VAR 0 3
12892: IFFALSE 13054
// begin case men [ Rand ( 1 , men ) ] of Kuzmov :
12894: LD_VAR 0 3
12898: PUSH
12899: LD_INT 1
12901: PPUSH
12902: LD_VAR 0 3
12906: PPUSH
12907: CALL_OW 12
12911: ARRAY
12912: PUSH
12913: LD_EXP 72
12917: DOUBLE
12918: EQUAL
12919: IFTRUE 12923
12921: GO 12948
12923: POP
// begin Say ( Kuzmov , DFreeTime-Kuz-1 ) ;
12924: LD_EXP 72
12928: PPUSH
12929: LD_STRING DFreeTime-Kuz-1
12931: PPUSH
12932: CALL_OW 88
// man = Kuzmov ;
12936: LD_ADDR_VAR 0 5
12940: PUSH
12941: LD_EXP 72
12945: ST_TO_ADDR
// end ; Titov :
12946: GO 13054
12948: LD_EXP 62
12952: DOUBLE
12953: EQUAL
12954: IFTRUE 12958
12956: GO 12983
12958: POP
// begin Say ( Titov , DFreeTime-Tit-1 ) ;
12959: LD_EXP 62
12963: PPUSH
12964: LD_STRING DFreeTime-Tit-1
12966: PPUSH
12967: CALL_OW 88
// man = Titov ;
12971: LD_ADDR_VAR 0 5
12975: PUSH
12976: LD_EXP 62
12980: ST_TO_ADDR
// end ; Gnyevko :
12981: GO 13054
12983: LD_EXP 69
12987: DOUBLE
12988: EQUAL
12989: IFTRUE 12993
12991: GO 13018
12993: POP
// begin Say ( Gnyevko , DFreeTime-Gny-1 ) ;
12994: LD_EXP 69
12998: PPUSH
12999: LD_STRING DFreeTime-Gny-1
13001: PPUSH
13002: CALL_OW 88
// man = Gnyevko ;
13006: LD_ADDR_VAR 0 5
13010: PUSH
13011: LD_EXP 69
13015: ST_TO_ADDR
// end ; Oblukov :
13016: GO 13054
13018: LD_EXP 74
13022: DOUBLE
13023: EQUAL
13024: IFTRUE 13028
13026: GO 13053
13028: POP
// begin Say ( Oblukov , DFreeTime-Obl-1 ) ;
13029: LD_EXP 74
13033: PPUSH
13034: LD_STRING DFreeTime-Obl-1
13036: PPUSH
13037: CALL_OW 88
// man = Oblukov ;
13041: LD_ADDR_VAR 0 5
13045: PUSH
13046: LD_EXP 74
13050: ST_TO_ADDR
// end ; end ;
13051: GO 13054
13053: POP
// end ; DialogueOff ;
13054: CALL_OW 7
// if not woman and not man then
13058: LD_VAR 0 4
13062: NOT
13063: PUSH
13064: LD_VAR 0 5
13068: NOT
13069: AND
13070: IFFALSE 13078
// begin DialogueOff ;
13072: CALL_OW 7
// exit ;
13076: GO 13524
// end ; case Query ( QFreeTime ) of 1 :
13078: LD_STRING QFreeTime
13080: PPUSH
13081: CALL_OW 97
13085: PUSH
13086: LD_INT 1
13088: DOUBLE
13089: EQUAL
13090: IFTRUE 13094
13092: GO 13496
13094: POP
// begin Say ( Burlak , DQrFreeTime#1-Bur-1 ) ;
13095: LD_EXP 57
13099: PPUSH
13100: LD_STRING DQrFreeTime#1-Bur-1
13102: PPUSH
13103: CALL_OW 88
// DialogueOff ;
13107: CALL_OW 7
// BurlakRespect = BurlakRespect + 1 ;
13111: LD_ADDR_EXP 30
13115: PUSH
13116: LD_EXP 30
13120: PUSH
13121: LD_INT 1
13123: PLUS
13124: ST_TO_ADDR
// SetSide ( [ woman , man ] , 6 ) ;
13125: LD_VAR 0 4
13129: PUSH
13130: LD_VAR 0 5
13134: PUSH
13135: EMPTY
13136: LIST
13137: LIST
13138: PPUSH
13139: LD_INT 6
13141: PPUSH
13142: CALL_OW 235
// for unit in [ woman , man ] do
13146: LD_ADDR_VAR 0 1
13150: PUSH
13151: LD_VAR 0 4
13155: PUSH
13156: LD_VAR 0 5
13160: PUSH
13161: EMPTY
13162: LIST
13163: LIST
13164: PUSH
13165: FOR_IN
13166: IFFALSE 13221
// if IsInUnit ( unit ) then
13168: LD_VAR 0 1
13172: PPUSH
13173: CALL_OW 310
13177: IFFALSE 13219
// begin if GetType ( IsInUnit ( unit ) ) = unit_vehicle then
13179: LD_VAR 0 1
13183: PPUSH
13184: CALL_OW 310
13188: PPUSH
13189: CALL_OW 247
13193: PUSH
13194: LD_INT 2
13196: EQUAL
13197: IFFALSE 13210
// ComExitVehicle ( unit ) else
13199: LD_VAR 0 1
13203: PPUSH
13204: CALL_OW 121
13208: GO 13219
// ComExitBuilding ( unit ) ;
13210: LD_VAR 0 1
13214: PPUSH
13215: CALL_OW 122
// end ;
13219: GO 13165
13221: POP
13222: POP
// wait ( 0 0$1 ) ;
13223: LD_INT 35
13225: PPUSH
13226: CALL_OW 67
// ComMoveToArea ( [ woman , man ] , ExitMapArea ) ;
13230: LD_VAR 0 4
13234: PUSH
13235: LD_VAR 0 5
13239: PUSH
13240: EMPTY
13241: LIST
13242: LIST
13243: PPUSH
13244: LD_INT 8
13246: PPUSH
13247: CALL_OW 113
// allowExitFromMap = 1 ;
13251: LD_ADDR_EXP 18
13255: PUSH
13256: LD_INT 1
13258: ST_TO_ADDR
// wait ( 3 3$0 ) ;
13259: LD_INT 6300
13261: PPUSH
13262: CALL_OW 67
// PlaceUnitXYR ( woman , 157 , 29 , 3 , false ) ;
13266: LD_VAR 0 4
13270: PPUSH
13271: LD_INT 157
13273: PPUSH
13274: LD_INT 29
13276: PPUSH
13277: LD_INT 3
13279: PPUSH
13280: LD_INT 0
13282: PPUSH
13283: CALL_OW 50
// PlaceUnitXYR ( man , 157 , 29 , 3 , false ) ;
13287: LD_VAR 0 5
13291: PPUSH
13292: LD_INT 157
13294: PPUSH
13295: LD_INT 29
13297: PPUSH
13298: LD_INT 3
13300: PPUSH
13301: LD_INT 0
13303: PPUSH
13304: CALL_OW 50
// SetSide ( [ woman , man ] , 3 ) ;
13308: LD_VAR 0 4
13312: PUSH
13313: LD_VAR 0 5
13317: PUSH
13318: EMPTY
13319: LIST
13320: LIST
13321: PPUSH
13322: LD_INT 3
13324: PPUSH
13325: CALL_OW 235
// depots = FilterAllUnits ( [ [ f_side , 3 ] , [ [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ] ) ;
13329: LD_ADDR_VAR 0 6
13333: PUSH
13334: LD_INT 22
13336: PUSH
13337: LD_INT 3
13339: PUSH
13340: EMPTY
13341: LIST
13342: LIST
13343: PUSH
13344: LD_INT 2
13346: PUSH
13347: LD_INT 30
13349: PUSH
13350: LD_INT 0
13352: PUSH
13353: EMPTY
13354: LIST
13355: LIST
13356: PUSH
13357: LD_INT 30
13359: PUSH
13360: LD_INT 1
13362: PUSH
13363: EMPTY
13364: LIST
13365: LIST
13366: PUSH
13367: EMPTY
13368: LIST
13369: LIST
13370: LIST
13371: PUSH
13372: EMPTY
13373: LIST
13374: PUSH
13375: EMPTY
13376: LIST
13377: LIST
13378: PPUSH
13379: CALL_OW 69
13383: ST_TO_ADDR
// if depots then
13384: LD_VAR 0 6
13388: IFFALSE 13438
// ComMoveXY ( [ woman , man ] , GetX ( depots [ 1 ] ) , GetY ( depots [ 1 ] ) ) else
13390: LD_VAR 0 4
13394: PUSH
13395: LD_VAR 0 5
13399: PUSH
13400: EMPTY
13401: LIST
13402: LIST
13403: PPUSH
13404: LD_VAR 0 6
13408: PUSH
13409: LD_INT 1
13411: ARRAY
13412: PPUSH
13413: CALL_OW 250
13417: PPUSH
13418: LD_VAR 0 6
13422: PUSH
13423: LD_INT 1
13425: ARRAY
13426: PPUSH
13427: CALL_OW 251
13431: PPUSH
13432: CALL_OW 111
13436: GO 13476
// ComMoveXY ( [ woman , man ] , GetX ( Burlak ) , GetY ( Burlak ) ) ;
13438: LD_VAR 0 4
13442: PUSH
13443: LD_VAR 0 5
13447: PUSH
13448: EMPTY
13449: LIST
13450: LIST
13451: PPUSH
13452: LD_EXP 57
13456: PPUSH
13457: CALL_OW 250
13461: PPUSH
13462: LD_EXP 57
13466: PPUSH
13467: CALL_OW 251
13471: PPUSH
13472: CALL_OW 111
// CenterOnUnits ( [ woman , man ] ) ;
13476: LD_VAR 0 4
13480: PUSH
13481: LD_VAR 0 5
13485: PUSH
13486: EMPTY
13487: LIST
13488: LIST
13489: PPUSH
13490: CALL_OW 85
// end ; 2 :
13494: GO 13520
13496: LD_INT 2
13498: DOUBLE
13499: EQUAL
13500: IFTRUE 13504
13502: GO 13519
13504: POP
// Say ( Burlak , DQrFreeTime#2-Bur-1 ) ; end ;
13505: LD_EXP 57
13509: PPUSH
13510: LD_STRING DQrFreeTime#2-Bur-1
13512: PPUSH
13513: CALL_OW 88
13517: GO 13520
13519: POP
// DialogueOff ;
13520: CALL_OW 7
// end ;
13524: PPOPN 6
13526: END
// every 0 0$1 trigger GetAmountWeaponsDataBuildOnVehicle ( false ) <= 2 do
13527: LD_INT 0
13529: PPUSH
13530: CALL 6800 0 1
13534: PUSH
13535: LD_INT 2
13537: LESSEQUAL
13538: IFFALSE 13673
13540: GO 13542
13542: DISABLE
// begin DialogueOn ;
13543: CALL_OW 6
// if IsOK ( Kozlov ) then
13547: LD_EXP 73
13551: PPUSH
13552: CALL_OW 302
13556: IFFALSE 13572
// Say ( Kozlov , DMasha-Koz-1 ) else
13558: LD_EXP 73
13562: PPUSH
13563: LD_STRING DMasha-Koz-1
13565: PPUSH
13566: CALL_OW 88
13570: GO 13635
// DialogRandom ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_ok ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) , DMasha-Koz-1 ,  , false , false ) ;
13572: LD_INT 22
13574: PUSH
13575: LD_INT 3
13577: PUSH
13578: EMPTY
13579: LIST
13580: LIST
13581: PUSH
13582: LD_INT 50
13584: PUSH
13585: EMPTY
13586: LIST
13587: PUSH
13588: LD_INT 21
13590: PUSH
13591: LD_INT 1
13593: PUSH
13594: EMPTY
13595: LIST
13596: LIST
13597: PUSH
13598: LD_INT 26
13600: PUSH
13601: LD_INT 1
13603: PUSH
13604: EMPTY
13605: LIST
13606: LIST
13607: PUSH
13608: EMPTY
13609: LIST
13610: LIST
13611: LIST
13612: LIST
13613: PPUSH
13614: CALL_OW 69
13618: PPUSH
13619: LD_STRING DMasha-Koz-1
13621: PPUSH
13622: LD_STRING 
13624: PPUSH
13625: LD_INT 0
13627: PPUSH
13628: LD_INT 0
13630: PPUSH
13631: CALL 6249 0 5
// Say ( Burlak , DMasha2-Bur-1 ) ;
13635: LD_EXP 57
13639: PPUSH
13640: LD_STRING DMasha2-Bur-1
13642: PPUSH
13643: CALL_OW 88
// DialogueOff ;
13647: CALL_OW 7
// Query ( QMasha ) ;
13651: LD_STRING QMasha
13653: PPUSH
13654: CALL_OW 97
// ChangeMissionObjectives ( MMasha ) ;
13658: LD_STRING MMasha
13660: PPUSH
13661: CALL_OW 337
// canChooseMashaVehicle = true ;
13665: LD_ADDR_EXP 36
13669: PUSH
13670: LD_INT 1
13672: ST_TO_ADDR
// end ;
13673: END
// export function Dial_ComputerTechResearched ; begin
13674: LD_INT 0
13676: PPUSH
// if IsOk ( Scholtze ) or IsOK ( Kapitsova ) then
13677: LD_EXP 71
13681: PPUSH
13682: CALL_OW 302
13686: PUSH
13687: LD_EXP 75
13691: PPUSH
13692: CALL_OW 302
13696: OR
13697: IFFALSE 13793
// begin DialogueOn ;
13699: CALL_OW 6
// if IsOK ( Scholtze ) then
13703: LD_EXP 71
13707: PPUSH
13708: CALL_OW 302
13712: IFFALSE 13728
// Say ( Scholtze , DAI-Sch-1 ) else
13714: LD_EXP 71
13718: PPUSH
13719: LD_STRING DAI-Sch-1
13721: PPUSH
13722: CALL_OW 88
13726: GO 13740
// Say ( Kapitsova , DAI-Kap-1 ) ;
13728: LD_EXP 75
13732: PPUSH
13733: LD_STRING DAI-Kap-1
13735: PPUSH
13736: CALL_OW 88
// Say ( Burlak , DAI-Bur-1 ) ;
13740: LD_EXP 57
13744: PPUSH
13745: LD_STRING DAI-Bur-1
13747: PPUSH
13748: CALL_OW 88
// if IsOK ( Scholtze ) then
13752: LD_EXP 71
13756: PPUSH
13757: CALL_OW 302
13761: IFFALSE 13777
// Say ( Scholtze , DAI-Sch-2 ) else
13763: LD_EXP 71
13767: PPUSH
13768: LD_STRING DAI-Sch-2
13770: PPUSH
13771: CALL_OW 88
13775: GO 13789
// Say ( Kapitsova , DAI-Kap-2 ) ;
13777: LD_EXP 75
13781: PPUSH
13782: LD_STRING DAI-Kap-2
13784: PPUSH
13785: CALL_OW 88
// DialogueOff ;
13789: CALL_OW 7
// end ; ChangeMissionObjectives ( MAI ) ;
13793: LD_STRING MAI
13795: PPUSH
13796: CALL_OW 337
// end ;
13800: LD_VAR 0 1
13804: RET
// export function Dial_TeleportTechResearched ; begin
13805: LD_INT 0
13807: PPUSH
// if IsOk ( Scholtze ) or IsOK ( Kapitsova ) then
13808: LD_EXP 71
13812: PPUSH
13813: CALL_OW 302
13817: PUSH
13818: LD_EXP 75
13822: PPUSH
13823: CALL_OW 302
13827: OR
13828: IFFALSE 13936
// begin DialogueOn ;
13830: CALL_OW 6
// if IsOK ( Scholtze ) then
13834: LD_EXP 71
13838: PPUSH
13839: CALL_OW 302
13843: IFFALSE 13859
// Say ( Scholtze , DSpontTelep-Sch-1 ) else
13845: LD_EXP 71
13849: PPUSH
13850: LD_STRING DSpontTelep-Sch-1
13852: PPUSH
13853: CALL_OW 88
13857: GO 13871
// Say ( Kapitsova , DSpontTelep-Kap-1 ) ;
13859: LD_EXP 75
13863: PPUSH
13864: LD_STRING DSpontTelep-Kap-1
13866: PPUSH
13867: CALL_OW 88
// Say ( Burlak , DSpontTelep-Bur-1 ) ;
13871: LD_EXP 57
13875: PPUSH
13876: LD_STRING DSpontTelep-Bur-1
13878: PPUSH
13879: CALL_OW 88
// if IsOK ( Scholtze ) then
13883: LD_EXP 71
13887: PPUSH
13888: CALL_OW 302
13892: IFFALSE 13908
// Say ( Scholtze , DSpontTelep-Sch-2 ) else
13894: LD_EXP 71
13898: PPUSH
13899: LD_STRING DSpontTelep-Sch-2
13901: PPUSH
13902: CALL_OW 88
13906: GO 13920
// Say ( Kapitsova , DSpontTelep-Kap-2 ) ;
13908: LD_EXP 75
13912: PPUSH
13913: LD_STRING DSpontTelep-Kap-2
13915: PPUSH
13916: CALL_OW 88
// Say ( Burlak , DSpontTelep-Bur-2 ) ;
13920: LD_EXP 57
13924: PPUSH
13925: LD_STRING DSpontTelep-Bur-2
13927: PPUSH
13928: CALL_OW 88
// DialogueOff ;
13932: CALL_OW 7
// end ; ChangeMissionObjectives ( MTele ) ;
13936: LD_STRING MTele
13938: PPUSH
13939: CALL_OW 337
// end ;
13943: LD_VAR 0 1
13947: RET
// every 0 0$1 trigger buildingsToBuild <= 3 and GetAmountWeaponsDataBuildOnVehicle ( false ) <= 1 and techsToResearch <= 4 do
13948: LD_EXP 8
13952: PUSH
13953: LD_INT 3
13955: LESSEQUAL
13956: PUSH
13957: LD_INT 0
13959: PPUSH
13960: CALL 6800 0 1
13964: PUSH
13965: LD_INT 1
13967: LESSEQUAL
13968: AND
13969: PUSH
13970: LD_EXP 9
13974: PUSH
13975: LD_INT 4
13977: LESSEQUAL
13978: AND
13979: IFFALSE 14180
13981: GO 13983
13983: DISABLE
// begin SayRadio ( Popov , DAmAttackStart-Pop-1 ) ;
13984: LD_EXP 76
13988: PPUSH
13989: LD_STRING DAmAttackStart-Pop-1
13991: PPUSH
13992: CALL_OW 94
// if KurtStatus = 1 and HeikeStatus = 1 then
13996: LD_EXP 22
14000: PUSH
14001: LD_INT 1
14003: EQUAL
14004: PUSH
14005: LD_EXP 3
14009: PUSH
14010: LD_INT 1
14012: EQUAL
14013: AND
14014: IFFALSE 14172
// begin wait ( 0 0$10 ) ;
14016: LD_INT 350
14018: PPUSH
14019: CALL_OW 67
// DialogueOn ;
14023: CALL_OW 6
// SayRadio ( Heike , DLegionFormed-Hke-1 ) ;
14027: LD_EXP 79
14031: PPUSH
14032: LD_STRING DLegionFormed-Hke-1
14034: PPUSH
14035: CALL_OW 94
// Say ( Burlak , DLegionFormed-Bur-1 ) ;
14039: LD_EXP 57
14043: PPUSH
14044: LD_STRING DLegionFormed-Bur-1
14046: PPUSH
14047: CALL_OW 88
// SayRadio ( Heike , DLegionFormed-Hke-2 ) ;
14051: LD_EXP 79
14055: PPUSH
14056: LD_STRING DLegionFormed-Hke-2
14058: PPUSH
14059: CALL_OW 94
// Say ( Burlak , DLegionFormed-Bur-2 ) ;
14063: LD_EXP 57
14067: PPUSH
14068: LD_STRING DLegionFormed-Bur-2
14070: PPUSH
14071: CALL_OW 88
// SayRadio ( Heike , DLegionFormed-Hke-3 ) ;
14075: LD_EXP 79
14079: PPUSH
14080: LD_STRING DLegionFormed-Hke-3
14082: PPUSH
14083: CALL_OW 94
// case Query ( QLegion ) of 1 :
14087: LD_STRING QLegion
14089: PPUSH
14090: CALL_OW 97
14094: PUSH
14095: LD_INT 1
14097: DOUBLE
14098: EQUAL
14099: IFTRUE 14103
14101: GO 14134
14103: POP
// begin acceptLegionOffert = true ;
14104: LD_ADDR_EXP 31
14108: PUSH
14109: LD_INT 1
14111: ST_TO_ADDR
// legionOffertCountdown = true ;
14112: LD_ADDR_EXP 33
14116: PUSH
14117: LD_INT 1
14119: ST_TO_ADDR
// Say ( Burlak , DQrLegion#1-Bur-1 ) ;
14120: LD_EXP 57
14124: PPUSH
14125: LD_STRING DQrLegion#1-Bur-1
14127: PPUSH
14128: CALL_OW 88
// end ; 2 :
14132: GO 14166
14134: LD_INT 2
14136: DOUBLE
14137: EQUAL
14138: IFTRUE 14142
14140: GO 14165
14142: POP
// begin Say ( Burlak , DQrLegion#2-Bur-1 ) ;
14143: LD_EXP 57
14147: PPUSH
14148: LD_STRING DQrLegion#2-Bur-1
14150: PPUSH
14151: CALL_OW 88
// americansAttack = true ;
14155: LD_ADDR_EXP 26
14159: PUSH
14160: LD_INT 1
14162: ST_TO_ADDR
// end ; end ;
14163: GO 14166
14165: POP
// DialogueOff ;
14166: CALL_OW 7
// end else
14170: GO 14180
// begin americansAttack = true ;
14172: LD_ADDR_EXP 26
14176: PUSH
14177: LD_INT 1
14179: ST_TO_ADDR
// end ; end ;
14180: END
// every 0 0$1 trigger legionOffertTime <= 0 0$00 do
14181: LD_EXP 34
14185: PUSH
14186: LD_INT 0
14188: LESSEQUAL
14189: IFFALSE 14210
14191: GO 14193
14193: DISABLE
// begin legionOffertCountdown = false ;
14194: LD_ADDR_EXP 33
14198: PUSH
14199: LD_INT 0
14201: ST_TO_ADDR
// americansAttack = true ;
14202: LD_ADDR_EXP 26
14206: PUSH
14207: LD_INT 1
14209: ST_TO_ADDR
// end ;
14210: END
// every 0 0$1 trigger legionOffertCountdown do var needCrates , depots , depot , crates ;
14211: LD_EXP 33
14215: IFFALSE 14401
14217: GO 14219
14219: DISABLE
14220: LD_INT 0
14222: PPUSH
14223: PPUSH
14224: PPUSH
14225: PPUSH
// begin needCrates = 50 ;
14226: LD_ADDR_VAR 0 1
14230: PUSH
14231: LD_INT 50
14233: ST_TO_ADDR
// crates = 0 ;
14234: LD_ADDR_VAR 0 4
14238: PUSH
14239: LD_INT 0
14241: ST_TO_ADDR
// depots = FilterAllUnits ( [ [ f_side , 3 ] , [ [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ] ) ;
14242: LD_ADDR_VAR 0 2
14246: PUSH
14247: LD_INT 22
14249: PUSH
14250: LD_INT 3
14252: PUSH
14253: EMPTY
14254: LIST
14255: LIST
14256: PUSH
14257: LD_INT 2
14259: PUSH
14260: LD_INT 30
14262: PUSH
14263: LD_INT 0
14265: PUSH
14266: EMPTY
14267: LIST
14268: LIST
14269: PUSH
14270: LD_INT 30
14272: PUSH
14273: LD_INT 1
14275: PUSH
14276: EMPTY
14277: LIST
14278: LIST
14279: PUSH
14280: EMPTY
14281: LIST
14282: LIST
14283: LIST
14284: PUSH
14285: EMPTY
14286: LIST
14287: PUSH
14288: EMPTY
14289: LIST
14290: LIST
14291: PPUSH
14292: CALL_OW 69
14296: ST_TO_ADDR
// for depot in depots do
14297: LD_ADDR_VAR 0 3
14301: PUSH
14302: LD_VAR 0 2
14306: PUSH
14307: FOR_IN
14308: IFFALSE 14399
// begin crates = GetResourceType ( GetBase ( depot ) , mat_cans ) ;
14310: LD_ADDR_VAR 0 4
14314: PUSH
14315: LD_VAR 0 3
14319: PPUSH
14320: CALL_OW 274
14324: PPUSH
14325: LD_INT 1
14327: PPUSH
14328: CALL_OW 275
14332: ST_TO_ADDR
// if crates >= needCrates then
14333: LD_VAR 0 4
14337: PUSH
14338: LD_VAR 0 1
14342: GREATEREQUAL
14343: IFFALSE 14397
// begin SetResourceType ( GetBase ( depot ) , mat_cans , crates - needCrates ) ;
14345: LD_VAR 0 3
14349: PPUSH
14350: CALL_OW 274
14354: PPUSH
14355: LD_INT 1
14357: PPUSH
14358: LD_VAR 0 4
14362: PUSH
14363: LD_VAR 0 1
14367: MINUS
14368: PPUSH
14369: CALL_OW 277
// legionOffertCountdown = false ;
14373: LD_ADDR_EXP 33
14377: PUSH
14378: LD_INT 0
14380: ST_TO_ADDR
// paidLegionOffert = true ;
14381: LD_ADDR_EXP 32
14385: PUSH
14386: LD_INT 1
14388: ST_TO_ADDR
// americansAttack = true ;
14389: LD_ADDR_EXP 26
14393: PUSH
14394: LD_INT 1
14396: ST_TO_ADDR
// end ; end ;
14397: GO 14307
14399: POP
14400: POP
// end ;
14401: PPOPN 4
14403: END
// every 0 0$1 trigger currentAmWave >= americansAttackWaves and FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_type , unit_human ] , [ f_and , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ] ] ) = 0 do
14404: LD_EXP 85
14408: PUSH
14409: LD_EXP 48
14413: GREATEREQUAL
14414: PUSH
14415: LD_INT 22
14417: PUSH
14418: LD_INT 1
14420: PUSH
14421: EMPTY
14422: LIST
14423: LIST
14424: PUSH
14425: LD_INT 2
14427: PUSH
14428: LD_INT 21
14430: PUSH
14431: LD_INT 1
14433: PUSH
14434: EMPTY
14435: LIST
14436: LIST
14437: PUSH
14438: LD_INT 1
14440: PUSH
14441: LD_INT 21
14443: PUSH
14444: LD_INT 2
14446: PUSH
14447: EMPTY
14448: LIST
14449: LIST
14450: PUSH
14451: LD_INT 33
14453: PUSH
14454: LD_INT 3
14456: PUSH
14457: EMPTY
14458: LIST
14459: LIST
14460: PUSH
14461: EMPTY
14462: LIST
14463: LIST
14464: LIST
14465: PUSH
14466: EMPTY
14467: LIST
14468: LIST
14469: LIST
14470: PUSH
14471: EMPTY
14472: LIST
14473: LIST
14474: PPUSH
14475: CALL_OW 69
14479: PUSH
14480: LD_INT 0
14482: EQUAL
14483: AND
14484: IFFALSE 14684
14486: GO 14488
14488: DISABLE
// begin DialogueOn ;
14489: CALL_OW 6
// if IsOK ( Belkov ) then
14493: LD_EXP 66
14497: PPUSH
14498: CALL_OW 302
14502: IFFALSE 14518
// Say ( Belkov , DAmAttackFin-Bel-1 ) else
14504: LD_EXP 66
14508: PPUSH
14509: LD_STRING DAmAttackFin-Bel-1
14511: PPUSH
14512: CALL_OW 88
14516: GO 14541
// if IsOK ( Belkov2 ) then
14518: LD_EXP 67
14522: PPUSH
14523: CALL_OW 302
14527: IFFALSE 14541
// Say ( Belkov2 , DAmAttackFin-Bel-1 ) ;
14529: LD_EXP 67
14533: PPUSH
14534: LD_STRING DAmAttackFin-Bel-1
14536: PPUSH
14537: CALL_OW 88
// if IsOK ( Gnyevko ) then
14541: LD_EXP 69
14545: PPUSH
14546: CALL_OW 302
14550: IFFALSE 14564
// Say ( Gnyevko , DAmAttackFin-Gny-1 ) ;
14552: LD_EXP 69
14556: PPUSH
14557: LD_STRING DAmAttackFin-Gny-1
14559: PPUSH
14560: CALL_OW 88
// if IsOK ( Titov ) then
14564: LD_EXP 62
14568: PPUSH
14569: CALL_OW 302
14573: IFFALSE 14587
// Say ( Titov , DAmAttackFin-Tit-1 ) ;
14575: LD_EXP 62
14579: PPUSH
14580: LD_STRING DAmAttackFin-Tit-1
14582: PPUSH
14583: CALL_OW 88
// if IsOK ( Lipshchin ) then
14587: LD_EXP 64
14591: PPUSH
14592: CALL_OW 302
14596: IFFALSE 14610
// Say ( Lipshchin , DAmAttackFin-Lip-1 ) ;
14598: LD_EXP 64
14602: PPUSH
14603: LD_STRING DAmAttackFin-Lip-1
14605: PPUSH
14606: CALL_OW 88
// if IsOK ( Karamazov ) then
14610: LD_EXP 58
14614: PPUSH
14615: CALL_OW 302
14619: IFFALSE 14633
// Say ( Karamazov , DAmAttackFin-Kar-1 ) ;
14621: LD_EXP 58
14625: PPUSH
14626: LD_STRING DAmAttackFin-Kar-1
14628: PPUSH
14629: CALL_OW 88
// if IsOK ( Oblukov ) then
14633: LD_EXP 74
14637: PPUSH
14638: CALL_OW 302
14642: IFFALSE 14656
// Say ( Oblukov , DAmAttackFin-Obl-1 ) ;
14644: LD_EXP 74
14648: PPUSH
14649: LD_STRING DAmAttackFin-Obl-1
14651: PPUSH
14652: CALL_OW 88
// Say ( Burlak , AmAttackFin-Bur-1 ) ;
14656: LD_EXP 57
14660: PPUSH
14661: LD_STRING AmAttackFin-Bur-1
14663: PPUSH
14664: CALL_OW 88
// SayRadio ( Popov , DAmAttackFin-Pop-1 ) ;
14668: LD_EXP 76
14672: PPUSH
14673: LD_STRING DAmAttackFin-Pop-1
14675: PPUSH
14676: CALL_OW 94
// DialogueOff ;
14680: CALL_OW 7
// end ;
14684: END
// every 0 0$1 trigger buildingsToBuild + ( 3 - GetAmountWeaponsDataBuildOnTurret ( true ) ) = 0 do
14685: LD_EXP 8
14689: PUSH
14690: LD_INT 3
14692: PUSH
14693: LD_INT 1
14695: PPUSH
14696: CALL 6690 0 1
14700: MINUS
14701: PLUS
14702: PUSH
14703: LD_INT 0
14705: EQUAL
14706: IFFALSE 14718
14708: GO 14710
14710: DISABLE
// ChangeMissionObjectives ( MBuildingsDone ) ;
14711: LD_STRING MBuildingsDone
14713: PPUSH
14714: CALL_OW 337
14718: END
// every 0 0$1 trigger GetAmountWeaponsDataBuildOnVehicle ( false ) = 0 do
14719: LD_INT 0
14721: PPUSH
14722: CALL 6800 0 1
14726: PUSH
14727: LD_INT 0
14729: EQUAL
14730: IFFALSE 14742
14732: GO 14734
14734: DISABLE
// ChangeMissionObjectives ( MWeaponsDone ) ;
14735: LD_STRING MWeaponsDone
14737: PPUSH
14738: CALL_OW 337
14742: END
// every 0 0$1 trigger techsToResearch = 0 do
14743: LD_EXP 9
14747: PUSH
14748: LD_INT 0
14750: EQUAL
14751: IFFALSE 14763
14753: GO 14755
14755: DISABLE
// ChangeMissionObjectives ( MTechnoDone ) ;
14756: LD_STRING MTechnoDone
14758: PPUSH
14759: CALL_OW 337
14763: END
// every 0 0$1 trigger americansAttack and not FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_type , unit_human ] , [ f_and , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ] ] ) do
14764: LD_EXP 26
14768: PUSH
14769: LD_INT 22
14771: PUSH
14772: LD_INT 1
14774: PUSH
14775: EMPTY
14776: LIST
14777: LIST
14778: PUSH
14779: LD_INT 2
14781: PUSH
14782: LD_INT 21
14784: PUSH
14785: LD_INT 1
14787: PUSH
14788: EMPTY
14789: LIST
14790: LIST
14791: PUSH
14792: LD_INT 1
14794: PUSH
14795: LD_INT 21
14797: PUSH
14798: LD_INT 2
14800: PUSH
14801: EMPTY
14802: LIST
14803: LIST
14804: PUSH
14805: LD_INT 33
14807: PUSH
14808: LD_INT 3
14810: PUSH
14811: EMPTY
14812: LIST
14813: LIST
14814: PUSH
14815: EMPTY
14816: LIST
14817: LIST
14818: LIST
14819: PUSH
14820: EMPTY
14821: LIST
14822: LIST
14823: LIST
14824: PUSH
14825: EMPTY
14826: LIST
14827: LIST
14828: PPUSH
14829: CALL_OW 69
14833: NOT
14834: AND
14835: IFFALSE 14847
14837: GO 14839
14839: DISABLE
// ChangeMissionObjectives ( MEnemyDone ) ;
14840: LD_STRING MEnemyDone
14842: PPUSH
14843: CALL_OW 337
14847: END
// every 0 0$1 trigger ( buildingsToBuild + ( 3 - GetAmountWeaponsDataBuildOnTurret ( true ) ) ) = 0 and GetAmountWeaponsDataBuildOnVehicle ( false ) = 0 and techsToResearch = 0 and FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_type , unit_human ] , [ f_and , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ] ] ) = 0 and Masha and IsOK ( Masha [ 1 ] ) and buildCompVehicle and testedTeleport do
14848: LD_EXP 8
14852: PUSH
14853: LD_INT 3
14855: PUSH
14856: LD_INT 1
14858: PPUSH
14859: CALL 6690 0 1
14863: MINUS
14864: PLUS
14865: PUSH
14866: LD_INT 0
14868: EQUAL
14869: PUSH
14870: LD_INT 0
14872: PPUSH
14873: CALL 6800 0 1
14877: PUSH
14878: LD_INT 0
14880: EQUAL
14881: AND
14882: PUSH
14883: LD_EXP 9
14887: PUSH
14888: LD_INT 0
14890: EQUAL
14891: AND
14892: PUSH
14893: LD_INT 22
14895: PUSH
14896: LD_INT 8
14898: PUSH
14899: EMPTY
14900: LIST
14901: LIST
14902: PUSH
14903: LD_INT 21
14905: PUSH
14906: LD_INT 1
14908: PUSH
14909: EMPTY
14910: LIST
14911: LIST
14912: PUSH
14913: EMPTY
14914: LIST
14915: LIST
14916: PPUSH
14917: CALL_OW 69
14921: PUSH
14922: LD_INT 0
14924: EQUAL
14925: AND
14926: PUSH
14927: LD_INT 22
14929: PUSH
14930: LD_INT 1
14932: PUSH
14933: EMPTY
14934: LIST
14935: LIST
14936: PUSH
14937: LD_INT 2
14939: PUSH
14940: LD_INT 21
14942: PUSH
14943: LD_INT 1
14945: PUSH
14946: EMPTY
14947: LIST
14948: LIST
14949: PUSH
14950: LD_INT 1
14952: PUSH
14953: LD_INT 21
14955: PUSH
14956: LD_INT 2
14958: PUSH
14959: EMPTY
14960: LIST
14961: LIST
14962: PUSH
14963: LD_INT 33
14965: PUSH
14966: LD_INT 3
14968: PUSH
14969: EMPTY
14970: LIST
14971: LIST
14972: PUSH
14973: EMPTY
14974: LIST
14975: LIST
14976: LIST
14977: PUSH
14978: EMPTY
14979: LIST
14980: LIST
14981: LIST
14982: PUSH
14983: EMPTY
14984: LIST
14985: LIST
14986: PPUSH
14987: CALL_OW 69
14991: PUSH
14992: LD_INT 0
14994: EQUAL
14995: AND
14996: PUSH
14997: LD_EXP 4
15001: AND
15002: PUSH
15003: LD_EXP 4
15007: PUSH
15008: LD_INT 1
15010: ARRAY
15011: PPUSH
15012: CALL_OW 302
15016: AND
15017: PUSH
15018: LD_EXP 37
15022: AND
15023: PUSH
15024: LD_EXP 39
15028: AND
15029: IFFALSE 15038
15031: GO 15033
15033: DISABLE
// begin FinishMission ;
15034: CALL 15243 0 0
// end ;
15038: END
// every 0 0$1 do var unit ;
15039: GO 15041
15041: DISABLE
15042: LD_INT 0
15044: PPUSH
// begin case allowExitFromMap of 1 :
15045: LD_EXP 18
15049: PUSH
15050: LD_INT 1
15052: DOUBLE
15053: EQUAL
15054: IFTRUE 15058
15056: GO 15086
15058: POP
// RemoveUnits ( FilterUnitsInArea ( ExitMapArea , [ [ f_side , 6 ] ] ) ) ; 3 :
15059: LD_INT 8
15061: PPUSH
15062: LD_INT 22
15064: PUSH
15065: LD_INT 6
15067: PUSH
15068: EMPTY
15069: LIST
15070: LIST
15071: PUSH
15072: EMPTY
15073: LIST
15074: PPUSH
15075: CALL_OW 70
15079: PPUSH
15080: CALL 6526 0 1
15084: GO 15209
15086: LD_INT 3
15088: DOUBLE
15089: EQUAL
15090: IFTRUE 15094
15092: GO 15122
15094: POP
// RemoveUnits ( FilterUnitsInArea ( KurtExitMapArea , [ [ f_side , 8 ] ] ) ) ; 4 :
15095: LD_INT 11
15097: PPUSH
15098: LD_INT 22
15100: PUSH
15101: LD_INT 8
15103: PUSH
15104: EMPTY
15105: LIST
15106: LIST
15107: PUSH
15108: EMPTY
15109: LIST
15110: PPUSH
15111: CALL_OW 70
15115: PPUSH
15116: CALL 6526 0 1
15120: GO 15209
15122: LD_INT 4
15124: DOUBLE
15125: EQUAL
15126: IFTRUE 15130
15128: GO 15208
15130: POP
// begin RemoveUnits ( FilterUnitsInArea ( ExitMapArea , [ [ f_side , 8 ] ] ) ) ;
15131: LD_INT 8
15133: PPUSH
15134: LD_INT 22
15136: PUSH
15137: LD_INT 8
15139: PUSH
15140: EMPTY
15141: LIST
15142: LIST
15143: PUSH
15144: EMPTY
15145: LIST
15146: PPUSH
15147: CALL_OW 70
15151: PPUSH
15152: CALL 6526 0 1
// RemoveUnits ( FilterUnitsInArea ( KurtExitMapArea , [ [ f_side , 8 ] ] ) ) ;
15156: LD_INT 11
15158: PPUSH
15159: LD_INT 22
15161: PUSH
15162: LD_INT 8
15164: PUSH
15165: EMPTY
15166: LIST
15167: LIST
15168: PUSH
15169: EMPTY
15170: LIST
15171: PPUSH
15172: CALL_OW 70
15176: PPUSH
15177: CALL 6526 0 1
// RemoveUnits ( FilterUnitsInArea ( ExitMapArea , [ [ f_side , 2 ] ] ) ) ;
15181: LD_INT 8
15183: PPUSH
15184: LD_INT 22
15186: PUSH
15187: LD_INT 2
15189: PUSH
15190: EMPTY
15191: LIST
15192: LIST
15193: PUSH
15194: EMPTY
15195: LIST
15196: PPUSH
15197: CALL_OW 70
15201: PPUSH
15202: CALL 6526 0 1
// end ; end ;
15206: GO 15209
15208: POP
// enable ;
15209: ENABLE
// end ; end_of_file
15210: PPOPN 1
15212: END
// export function Lose_Burlak ; begin
15213: LD_INT 0
15215: PPUSH
// YouLost ( Burlak ) ;
15216: LD_STRING Burlak
15218: PPUSH
15219: CALL_OW 104
// end ;
15223: LD_VAR 0 1
15227: RET
// export function Lost_AttackAlly ; begin
15228: LD_INT 0
15230: PPUSH
// YouLost ( SelfAttack ) ;
15231: LD_STRING SelfAttack
15233: PPUSH
15234: CALL_OW 104
// end ; end_of_file
15238: LD_VAR 0 1
15242: RET
// export function FinishMission ; begin
15243: LD_INT 0
15245: PPUSH
// SetRewards ;
15246: CALL 15267 0 0
// SavePlayerCharacters ;
15250: CALL 15528 0 0
// SaveGlobalVariables ;
15254: CALL 16078 0 0
// YouWin ;
15258: CALL_OW 103
// end ;
15262: LD_VAR 0 1
15266: RET
// function SetRewards ; begin
15267: LD_INT 0
15269: PPUSH
// AddMedal ( ArtisticImpression , 1 ) ;
15270: LD_STRING ArtisticImpression
15272: PPUSH
15273: LD_INT 1
15275: PPUSH
15276: CALL_OW 101
// if not HeikeCaptured then
15280: LD_EXP 1
15284: NOT
15285: IFFALSE 15319
// begin if speedMedalTime >= 0 0$00 then
15287: LD_EXP 52
15291: PUSH
15292: LD_INT 0
15294: GREATEREQUAL
15295: IFFALSE 15309
// AddMedal ( Speed , 1 ) else
15297: LD_STRING Speed
15299: PPUSH
15300: LD_INT 1
15302: PPUSH
15303: CALL_OW 101
15307: GO 15319
// AddMedal ( Speed , 1 ) ;
15309: LD_STRING Speed
15311: PPUSH
15312: LD_INT 1
15314: PPUSH
15315: CALL_OW 101
// end ; if lostUnits then
15319: LD_EXP 40
15323: IFFALSE 15338
// begin AddMedal ( FavouriteCommander , - 1 ) ;
15325: LD_STRING FavouriteCommander
15327: PPUSH
15328: LD_INT 1
15330: NEG
15331: PPUSH
15332: CALL_OW 101
// end else
15336: GO 15430
// begin case BurlakRespect of 0 :
15338: LD_EXP 30
15342: PUSH
15343: LD_INT 0
15345: DOUBLE
15346: EQUAL
15347: IFTRUE 15351
15349: GO 15365
15351: POP
// AddMedal ( FavouriteCommander , - 2 ) ; 1 :
15352: LD_STRING FavouriteCommander
15354: PPUSH
15355: LD_INT 2
15357: NEG
15358: PPUSH
15359: CALL_OW 101
15363: GO 15430
15365: LD_INT 1
15367: DOUBLE
15368: EQUAL
15369: IFTRUE 15373
15371: GO 15387
15373: POP
// AddMedal ( FavouriteCommander , - 3 ) ; 2 :
15374: LD_STRING FavouriteCommander
15376: PPUSH
15377: LD_INT 3
15379: NEG
15380: PPUSH
15381: CALL_OW 101
15385: GO 15430
15387: LD_INT 2
15389: DOUBLE
15390: EQUAL
15391: IFTRUE 15395
15393: GO 15408
15395: POP
// AddMedal ( FavouriteCommander , 1 ) ; 3 :
15396: LD_STRING FavouriteCommander
15398: PPUSH
15399: LD_INT 1
15401: PPUSH
15402: CALL_OW 101
15406: GO 15430
15408: LD_INT 3
15410: DOUBLE
15411: EQUAL
15412: IFTRUE 15416
15414: GO 15429
15416: POP
// AddMedal ( FavouriteCommander , 1 ) ; end ;
15417: LD_STRING FavouriteCommander
15419: PPUSH
15420: LD_INT 1
15422: PPUSH
15423: CALL_OW 101
15427: GO 15430
15429: POP
// end ; if HeikeCaptured then
15430: LD_EXP 1
15434: IFFALSE 15465
// begin if buildArabBarrack then
15436: LD_EXP 38
15440: IFFALSE 15454
// AddMedal ( ArabBarracks , 1 ) else
15442: LD_STRING ArabBarracks
15444: PPUSH
15445: LD_INT 1
15447: PPUSH
15448: CALL_OW 101
15452: GO 15465
// AddMedal ( ArabBarracks , - 1 ) ;
15454: LD_STRING ArabBarracks
15456: PPUSH
15457: LD_INT 1
15459: NEG
15460: PPUSH
15461: CALL_OW 101
// end ; GiveMedals ( Main1 ) ;
15465: LD_STRING Main1
15467: PPUSH
15468: CALL_OW 102
// RewardPeople ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_nation , nation_russian ] , [ f_ok ] ] ) ) ;
15472: LD_INT 22
15474: PUSH
15475: LD_INT 3
15477: PUSH
15478: EMPTY
15479: LIST
15480: LIST
15481: PUSH
15482: LD_INT 21
15484: PUSH
15485: LD_INT 1
15487: PUSH
15488: EMPTY
15489: LIST
15490: LIST
15491: PUSH
15492: LD_INT 23
15494: PUSH
15495: LD_INT 3
15497: PUSH
15498: EMPTY
15499: LIST
15500: LIST
15501: PUSH
15502: LD_INT 50
15504: PUSH
15505: EMPTY
15506: LIST
15507: PUSH
15508: EMPTY
15509: LIST
15510: LIST
15511: LIST
15512: LIST
15513: PPUSH
15514: CALL_OW 69
15518: PPUSH
15519: CALL_OW 43
// end ;
15523: LD_VAR 0 1
15527: RET
// function SavePlayerCharacters ; var randomsToSave ; begin
15528: LD_INT 0
15530: PPUSH
15531: PPUSH
// ExtSaveCharacter ( Burlak , Burlak , 3 ) ;
15532: LD_EXP 57
15536: PPUSH
15537: LD_STRING Burlak
15539: PPUSH
15540: LD_INT 3
15542: PPUSH
15543: CALL 6048 0 3
// ExtSaveCharacter ( Karamazov , Karamazov , 3 ) ;
15547: LD_EXP 58
15551: PPUSH
15552: LD_STRING Karamazov
15554: PPUSH
15555: LD_INT 3
15557: PPUSH
15558: CALL 6048 0 3
// ExtSaveCharacter ( Petrovova , Petrovova , 3 ) ;
15562: LD_EXP 59
15566: PPUSH
15567: LD_STRING Petrovova
15569: PPUSH
15570: LD_INT 3
15572: PPUSH
15573: CALL 6048 0 3
// ExtSaveCharacter ( Gleb , Gleb , 3 ) ;
15577: LD_EXP 60
15581: PPUSH
15582: LD_STRING Gleb
15584: PPUSH
15585: LD_INT 3
15587: PPUSH
15588: CALL 6048 0 3
// ExtSaveCharacter ( Petrosyan , Petrosyan , 3 ) ;
15592: LD_EXP 61
15596: PPUSH
15597: LD_STRING Petrosyan
15599: PPUSH
15600: LD_INT 3
15602: PPUSH
15603: CALL 6048 0 3
// ExtSaveCharacter ( Dolgov , Dolgov , 3 ) ;
15607: LD_EXP 63
15611: PPUSH
15612: LD_STRING Dolgov
15614: PPUSH
15615: LD_INT 3
15617: PPUSH
15618: CALL 6048 0 3
// ExtSaveCharacter ( Lipshchin , Lipshchin , 3 ) ;
15622: LD_EXP 64
15626: PPUSH
15627: LD_STRING Lipshchin
15629: PPUSH
15630: LD_INT 3
15632: PPUSH
15633: CALL 6048 0 3
// ExtSaveCharacter ( Titov , Titov , 3 ) ;
15637: LD_EXP 62
15641: PPUSH
15642: LD_STRING Titov
15644: PPUSH
15645: LD_INT 3
15647: PPUSH
15648: CALL 6048 0 3
// ExtSaveCharacter ( Kirilenkova , Kirilenkova , 3 ) ;
15652: LD_EXP 65
15656: PPUSH
15657: LD_STRING Kirilenkova
15659: PPUSH
15660: LD_INT 3
15662: PPUSH
15663: CALL 6048 0 3
// ExtSaveCharacter ( Belkov , Belkov , 3 ) ;
15667: LD_EXP 66
15671: PPUSH
15672: LD_STRING Belkov
15674: PPUSH
15675: LD_INT 3
15677: PPUSH
15678: CALL 6048 0 3
// ExtSaveCharacter ( Belkov2 , Belkov2 , 3 ) ;
15682: LD_EXP 67
15686: PPUSH
15687: LD_STRING Belkov2
15689: PPUSH
15690: LD_INT 3
15692: PPUSH
15693: CALL 6048 0 3
// ExtSaveCharacter ( Xavier , Xavier , 3 ) ;
15697: LD_EXP 68
15701: PPUSH
15702: LD_STRING Xavier
15704: PPUSH
15705: LD_INT 3
15707: PPUSH
15708: CALL 6048 0 3
// ExtSaveCharacter ( Kozlov , Kozlov , 3 ) ;
15712: LD_EXP 73
15716: PPUSH
15717: LD_STRING Kozlov
15719: PPUSH
15720: LD_INT 3
15722: PPUSH
15723: CALL 6048 0 3
// ExtSaveCharacter ( Oblukov , Oblukov , 3 ) ;
15727: LD_EXP 74
15731: PPUSH
15732: LD_STRING Oblukov
15734: PPUSH
15735: LD_INT 3
15737: PPUSH
15738: CALL 6048 0 3
// ExtSaveCharacter ( Kapitsova , Kapitsova , 3 ) ;
15742: LD_EXP 75
15746: PPUSH
15747: LD_STRING Kapitsova
15749: PPUSH
15750: LD_INT 3
15752: PPUSH
15753: CALL 6048 0 3
// ExtSaveCharacter ( Gnyevko , Gnyevko , 3 ) ;
15757: LD_EXP 69
15761: PPUSH
15762: LD_STRING Gnyevko
15764: PPUSH
15765: LD_INT 3
15767: PPUSH
15768: CALL 6048 0 3
// ExtSaveCharacter ( Kovalyuk , Kovalyuk , 3 ) ;
15772: LD_EXP 70
15776: PPUSH
15777: LD_STRING Kovalyuk
15779: PPUSH
15780: LD_INT 3
15782: PPUSH
15783: CALL 6048 0 3
// ExtSaveCharacter ( Scholtze , Scholtze , 3 ) ;
15787: LD_EXP 71
15791: PPUSH
15792: LD_STRING Scholtze
15794: PPUSH
15795: LD_INT 3
15797: PPUSH
15798: CALL 6048 0 3
// ExtSaveCharacter ( Kuzmov , Kuzmov , 3 ) ;
15802: LD_EXP 72
15806: PPUSH
15807: LD_STRING Kuzmov
15809: PPUSH
15810: LD_INT 3
15812: PPUSH
15813: CALL 6048 0 3
// ExtSaveCharacters ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_or , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman_soldier ] ] ] ) , other_apemans , 3 ) ;
15817: LD_INT 22
15819: PUSH
15820: LD_INT 3
15822: PUSH
15823: EMPTY
15824: LIST
15825: LIST
15826: PUSH
15827: LD_INT 21
15829: PUSH
15830: LD_INT 1
15832: PUSH
15833: EMPTY
15834: LIST
15835: LIST
15836: PUSH
15837: LD_INT 2
15839: PUSH
15840: LD_INT 25
15842: PUSH
15843: LD_INT 12
15845: PUSH
15846: EMPTY
15847: LIST
15848: LIST
15849: PUSH
15850: LD_INT 25
15852: PUSH
15853: LD_INT 16
15855: PUSH
15856: EMPTY
15857: LIST
15858: LIST
15859: PUSH
15860: LD_INT 25
15862: PUSH
15863: LD_INT 15
15865: PUSH
15866: EMPTY
15867: LIST
15868: LIST
15869: PUSH
15870: EMPTY
15871: LIST
15872: LIST
15873: LIST
15874: LIST
15875: PUSH
15876: EMPTY
15877: LIST
15878: LIST
15879: LIST
15880: PPUSH
15881: CALL_OW 69
15885: PPUSH
15886: LD_STRING other_apemans
15888: PPUSH
15889: LD_INT 3
15891: PPUSH
15892: CALL 6105 0 3
// randomsToSave = FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_nation , nation_russian ] ] ) diff [ Burlak , Karamazov , Petrovova , Gleb , Petrosyan , Titov , Dolgov , Lipshchin , Kirilenkova , Belkov , Belkov2 , Xavier , Gnyevko , Kovalyuk , Scholtze , Kuzmov , Kozlov , Oblukov , Kapitsova ] ;
15896: LD_ADDR_VAR 0 2
15900: PUSH
15901: LD_INT 22
15903: PUSH
15904: LD_INT 3
15906: PUSH
15907: EMPTY
15908: LIST
15909: LIST
15910: PUSH
15911: LD_INT 21
15913: PUSH
15914: LD_INT 1
15916: PUSH
15917: EMPTY
15918: LIST
15919: LIST
15920: PUSH
15921: LD_INT 23
15923: PUSH
15924: LD_INT 3
15926: PUSH
15927: EMPTY
15928: LIST
15929: LIST
15930: PUSH
15931: EMPTY
15932: LIST
15933: LIST
15934: LIST
15935: PPUSH
15936: CALL_OW 69
15940: PUSH
15941: LD_EXP 57
15945: PUSH
15946: LD_EXP 58
15950: PUSH
15951: LD_EXP 59
15955: PUSH
15956: LD_EXP 60
15960: PUSH
15961: LD_EXP 61
15965: PUSH
15966: LD_EXP 62
15970: PUSH
15971: LD_EXP 63
15975: PUSH
15976: LD_EXP 64
15980: PUSH
15981: LD_EXP 65
15985: PUSH
15986: LD_EXP 66
15990: PUSH
15991: LD_EXP 67
15995: PUSH
15996: LD_EXP 68
16000: PUSH
16001: LD_EXP 69
16005: PUSH
16006: LD_EXP 70
16010: PUSH
16011: LD_EXP 71
16015: PUSH
16016: LD_EXP 72
16020: PUSH
16021: LD_EXP 73
16025: PUSH
16026: LD_EXP 74
16030: PUSH
16031: LD_EXP 75
16035: PUSH
16036: EMPTY
16037: LIST
16038: LIST
16039: LIST
16040: LIST
16041: LIST
16042: LIST
16043: LIST
16044: LIST
16045: LIST
16046: LIST
16047: LIST
16048: LIST
16049: LIST
16050: LIST
16051: LIST
16052: LIST
16053: LIST
16054: LIST
16055: LIST
16056: DIFF
16057: ST_TO_ADDR
// ExtSaveCharacters ( randomsToSave , other_survivors , 3 ) ;
16058: LD_VAR 0 2
16062: PPUSH
16063: LD_STRING other_survivors
16065: PPUSH
16066: LD_INT 3
16068: PPUSH
16069: CALL 6105 0 3
// end ;
16073: LD_VAR 0 1
16077: RET
// function SaveGlobalVariables ; begin
16078: LD_INT 0
16080: PPUSH
// SaveBase ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] ] ) , 08_TrockyBase_1 ) ;
16081: LD_INT 22
16083: PUSH
16084: LD_INT 3
16086: PUSH
16087: EMPTY
16088: LIST
16089: LIST
16090: PUSH
16091: LD_INT 21
16093: PUSH
16094: LD_INT 3
16096: PUSH
16097: EMPTY
16098: LIST
16099: LIST
16100: PUSH
16101: EMPTY
16102: LIST
16103: LIST
16104: PPUSH
16105: CALL_OW 69
16109: PPUSH
16110: LD_STRING 08_TrockyBase_1
16112: PPUSH
16113: CALL 8484 0 2
// SaveVariable ( coopWithGensher , 08_CoopWithGensher_2 ) ;
16117: LD_EXP 2
16121: PPUSH
16122: LD_STRING 08_CoopWithGensher_2
16124: PPUSH
16125: CALL_OW 39
// SaveVariable ( HeikeStatus , 08_HeikeStatus_3 ) ;
16129: LD_EXP 3
16133: PPUSH
16134: LD_STRING 08_HeikeStatus_3
16136: PPUSH
16137: CALL_OW 39
// SaveVariable ( Masha , 08_Masha_4 ) ;
16141: LD_EXP 4
16145: PPUSH
16146: LD_STRING 08_Masha_4
16148: PPUSH
16149: CALL_OW 39
// end ; end_of_file
16153: LD_VAR 0 1
16157: RET
// export function CustomEvent ( event ) ; begin
16158: LD_INT 0
16160: PPUSH
// end ;
16161: LD_VAR 0 2
16165: RET
// on BuildingComplete ( building ) do begin if GetBType ( building ) in buildingsToBuild and GetNation ( building ) = nation_russian then
16166: LD_VAR 0 1
16170: PPUSH
16171: CALL_OW 266
16175: PUSH
16176: LD_EXP 8
16180: IN
16181: PUSH
16182: LD_VAR 0 1
16186: PPUSH
16187: CALL_OW 248
16191: PUSH
16192: LD_INT 3
16194: EQUAL
16195: AND
16196: IFFALSE 16219
// buildingsToBuild = buildingsToBuild diff GetBType ( building ) ;
16198: LD_ADDR_EXP 8
16202: PUSH
16203: LD_EXP 8
16207: PUSH
16208: LD_VAR 0 1
16212: PPUSH
16213: CALL_OW 266
16217: DIFF
16218: ST_TO_ADDR
// if GetBType ( building ) = b_depot then
16219: LD_VAR 0 1
16223: PPUSH
16224: CALL_OW 266
16228: PUSH
16229: LD_INT 0
16231: EQUAL
16232: IFFALSE 16283
// begin SetBName ( building , trockij ) ;
16234: LD_VAR 0 1
16238: PPUSH
16239: LD_STRING trockij
16241: PPUSH
16242: CALL_OW 500
// if not dial_BuildDepotBlocker and HeikeCaptured then
16246: LD_EXP 5
16250: NOT
16251: PUSH
16252: LD_EXP 1
16256: AND
16257: IFFALSE 16283
// Dial_EscortHeike ( GetX ( building ) , GetY ( building ) ) ;
16259: LD_VAR 0 1
16263: PPUSH
16264: CALL_OW 250
16268: PPUSH
16269: LD_VAR 0 1
16273: PPUSH
16274: CALL_OW 251
16278: PPUSH
16279: CALL 9149 0 2
// end ; end ;
16283: PPOPN 1
16285: END
// on UpgradeComplete ( building ) do begin if GetBType ( building ) in buildingsToBuild and GetNation ( building ) = nation_russian then
16286: LD_VAR 0 1
16290: PPUSH
16291: CALL_OW 266
16295: PUSH
16296: LD_EXP 8
16300: IN
16301: PUSH
16302: LD_VAR 0 1
16306: PPUSH
16307: CALL_OW 248
16311: PUSH
16312: LD_INT 3
16314: EQUAL
16315: AND
16316: IFFALSE 16339
// buildingsToBuild = buildingsToBuild diff GetBType ( building ) ;
16318: LD_ADDR_EXP 8
16322: PUSH
16323: LD_EXP 8
16327: PUSH
16328: LD_VAR 0 1
16332: PPUSH
16333: CALL_OW 266
16337: DIFF
16338: ST_TO_ADDR
// if GetBType ( building ) = b_barracks and GetNation ( building ) = 2 and not dial_BuildArBarrackBlocker then
16339: LD_VAR 0 1
16343: PPUSH
16344: CALL_OW 266
16348: PUSH
16349: LD_INT 5
16351: EQUAL
16352: PUSH
16353: LD_VAR 0 1
16357: PPUSH
16358: CALL_OW 248
16362: PUSH
16363: LD_INT 2
16365: EQUAL
16366: AND
16367: PUSH
16368: LD_EXP 6
16372: NOT
16373: AND
16374: IFFALSE 16380
// Dial_UpgradeArmoury ;
16376: CALL 9960 0 0
// end ;
16380: PPOPN 1
16382: END
// on ResearchComplete ( research , building ) do begin if research in techsToResearch then
16383: LD_VAR 0 1
16387: PUSH
16388: LD_EXP 9
16392: IN
16393: IFFALSE 16411
// techsToResearch = techsToResearch diff research ;
16395: LD_ADDR_EXP 9
16399: PUSH
16400: LD_EXP 9
16404: PUSH
16405: LD_VAR 0 1
16409: DIFF
16410: ST_TO_ADDR
// if research = tech_LimTeleport then
16411: LD_VAR 0 1
16415: PUSH
16416: LD_INT 37
16418: EQUAL
16419: IFFALSE 16425
// Dial_TeleportTechResearched ;
16421: CALL 13805 0 0
// if research = tech_AdvAI then
16425: LD_VAR 0 1
16429: PUSH
16430: LD_INT 27
16432: EQUAL
16433: IFFALSE 16439
// Dial_ComputerTechResearched ;
16435: CALL 13674 0 0
// end ;
16439: PPOPN 2
16441: END
// on EnterVehicle ( vehicle , human ) do begin if not canChooseMashaVehicle then
16442: LD_EXP 36
16446: NOT
16447: IFFALSE 16451
// exit ;
16449: GO 16618
// wait ( 0 0$1 ) ;
16451: LD_INT 35
16453: PPUSH
16454: CALL_OW 67
// if GetSide ( vehicle ) = 3 and human = Burlak and GetNation ( vehicle ) = nation_russian and GetWeapon ( vehicle ) in [ ru_heavy_machine_gun , ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher ] then
16458: LD_VAR 0 1
16462: PPUSH
16463: CALL_OW 255
16467: PUSH
16468: LD_INT 3
16470: EQUAL
16471: PUSH
16472: LD_VAR 0 2
16476: PUSH
16477: LD_EXP 57
16481: EQUAL
16482: AND
16483: PUSH
16484: LD_VAR 0 1
16488: PPUSH
16489: CALL_OW 248
16493: PUSH
16494: LD_INT 3
16496: EQUAL
16497: AND
16498: PUSH
16499: LD_VAR 0 1
16503: PPUSH
16504: CALL_OW 264
16508: PUSH
16509: LD_INT 42
16511: PUSH
16512: LD_INT 43
16514: PUSH
16515: LD_INT 44
16517: PUSH
16518: LD_INT 46
16520: PUSH
16521: LD_INT 45
16523: PUSH
16524: EMPTY
16525: LIST
16526: LIST
16527: LIST
16528: LIST
16529: LIST
16530: IN
16531: AND
16532: IFFALSE 16618
// begin if Masha then
16534: LD_EXP 4
16538: IFFALSE 16558
// if Masha [ 1 ] = vehicle then
16540: LD_EXP 4
16544: PUSH
16545: LD_INT 1
16547: ARRAY
16548: PUSH
16549: LD_VAR 0 1
16553: EQUAL
16554: IFFALSE 16558
// exit ;
16556: GO 16618
// if firstMashaQuery then
16558: LD_EXP 35
16562: IFFALSE 16596
// begin firstMashaQuery = false ;
16564: LD_ADDR_EXP 35
16568: PUSH
16569: LD_INT 0
16571: ST_TO_ADDR
// if Query ( QMashaQuery ) = 1 then
16572: LD_STRING QMashaQuery
16574: PPUSH
16575: CALL_OW 97
16579: PUSH
16580: LD_INT 1
16582: EQUAL
16583: IFFALSE 16594
// SetMashaData ( vehicle ) ;
16585: LD_VAR 0 1
16589: PPUSH
16590: CALL 8378 0 1
// end else
16594: GO 16618
// begin if Query ( QMashaQuery2 ) = 1 then
16596: LD_STRING QMashaQuery2
16598: PPUSH
16599: CALL_OW 97
16603: PUSH
16604: LD_INT 1
16606: EQUAL
16607: IFFALSE 16618
// SetMashaData ( vehicle ) ;
16609: LD_VAR 0 1
16613: PPUSH
16614: CALL 8378 0 1
// end ; end ; end ;
16618: PPOPN 2
16620: END
// on UnitDestroyed ( unit ) do begin if Masha then
16621: LD_EXP 4
16625: IFFALSE 16650
// if unit = Masha [ 1 ] then
16627: LD_VAR 0 1
16631: PUSH
16632: LD_EXP 4
16636: PUSH
16637: LD_INT 1
16639: ARRAY
16640: EQUAL
16641: IFFALSE 16650
// Masha = [ ] ;
16643: LD_ADDR_EXP 4
16647: PUSH
16648: EMPTY
16649: ST_TO_ADDR
// if unit = Burlak then
16650: LD_VAR 0 1
16654: PUSH
16655: LD_EXP 57
16659: EQUAL
16660: IFFALSE 16666
// Lose_Burlak ;
16662: CALL 15213 0 0
// if GetType ( unit ) = unit_human and GetNation ( unit ) = nation_russian then
16666: LD_VAR 0 1
16670: PPUSH
16671: CALL_OW 247
16675: PUSH
16676: LD_INT 1
16678: EQUAL
16679: PUSH
16680: LD_VAR 0 1
16684: PPUSH
16685: CALL_OW 248
16689: PUSH
16690: LD_INT 3
16692: EQUAL
16693: AND
16694: IFFALSE 16710
// lostUnits = lostUnits + 1 ;
16696: LD_ADDR_EXP 40
16700: PUSH
16701: LD_EXP 40
16705: PUSH
16706: LD_INT 1
16708: PLUS
16709: ST_TO_ADDR
// end ;
16710: PPOPN 1
16712: END
// on UnitGoesToRed ( unit ) do begin if GetType ( unit ) = unit_vehicle and GetNation ( unit ) = nation_russian and GetTech ( tech_LimTeleport , 3 ) = state_researched and not testedTeleport then
16713: LD_VAR 0 1
16717: PPUSH
16718: CALL_OW 247
16722: PUSH
16723: LD_INT 2
16725: EQUAL
16726: PUSH
16727: LD_VAR 0 1
16731: PPUSH
16732: CALL_OW 248
16736: PUSH
16737: LD_INT 3
16739: EQUAL
16740: AND
16741: PUSH
16742: LD_INT 37
16744: PPUSH
16745: LD_INT 3
16747: PPUSH
16748: CALL_OW 321
16752: PUSH
16753: LD_INT 2
16755: EQUAL
16756: AND
16757: PUSH
16758: LD_EXP 39
16762: NOT
16763: AND
16764: IFFALSE 16781
// begin testedTeleport = true ;
16766: LD_ADDR_EXP 39
16770: PUSH
16771: LD_INT 1
16773: ST_TO_ADDR
// ChangeMissionObjectives ( MTeleDone ) ;
16774: LD_STRING MTeleDone
16776: PPUSH
16777: CALL_OW 337
// end ; if unit = Heike then
16781: LD_VAR 0 1
16785: PUSH
16786: LD_EXP 79
16790: EQUAL
16791: IFFALSE 16834
// begin DialogueOn ;
16793: CALL_OW 6
// CenterNowOnUnits ( Heike ) ;
16797: LD_EXP 79
16801: PPUSH
16802: CALL_OW 87
// ForceSay ( Heike , DHeikeKilled-Hke-1 ) ;
16806: LD_EXP 79
16810: PPUSH
16811: LD_STRING DHeikeKilled-Hke-1
16813: PPUSH
16814: CALL_OW 91
// DialogueOff ;
16818: CALL_OW 7
// SetLives ( Heike , 0 ) ;
16822: LD_EXP 79
16826: PPUSH
16827: LD_INT 0
16829: PPUSH
16830: CALL_OW 234
// end ; end ;
16834: PPOPN 1
16836: END
// on Contact ( side1 , side2 ) do begin if side1 = 3 and side2 = 6 then
16837: LD_VAR 0 1
16841: PUSH
16842: LD_INT 3
16844: EQUAL
16845: PUSH
16846: LD_VAR 0 2
16850: PUSH
16851: LD_INT 6
16853: EQUAL
16854: AND
16855: IFFALSE 16861
// Lost_AttackAlly ;
16857: CALL 15228 0 0
// if side1 = 3 and side2 = 2 then
16861: LD_VAR 0 1
16865: PUSH
16866: LD_INT 3
16868: EQUAL
16869: PUSH
16870: LD_VAR 0 2
16874: PUSH
16875: LD_INT 2
16877: EQUAL
16878: AND
16879: IFFALSE 16885
// Dial_AttackGensher ;
16881: CALL 10916 0 0
// if side1 = 3 and side2 = 5 then
16885: LD_VAR 0 1
16889: PUSH
16890: LD_INT 3
16892: EQUAL
16893: PUSH
16894: LD_VAR 0 2
16898: PUSH
16899: LD_INT 5
16901: EQUAL
16902: AND
16903: IFFALSE 16947
// begin SetAttitude ( 3 , 5 , att_enemy , true ) ;
16905: LD_INT 3
16907: PPUSH
16908: LD_INT 5
16910: PPUSH
16911: LD_INT 2
16913: PPUSH
16914: LD_INT 1
16916: PPUSH
16917: CALL_OW 80
// if acceptKurtOffert and not GetSide ( Kurt ) = 2 then
16921: LD_EXP 19
16925: PUSH
16926: LD_EXP 80
16930: PPUSH
16931: CALL_OW 255
16935: PUSH
16936: LD_INT 2
16938: EQUAL
16939: NOT
16940: AND
16941: IFFALSE 16947
// Dial_BetrayedKurt1 ;
16943: CALL 11465 0 0
// end ; if side1 = 3 and side2 = 8 and GetAttitude ( 3 , 8 ) = att_neutral then
16947: LD_VAR 0 1
16951: PUSH
16952: LD_INT 3
16954: EQUAL
16955: PUSH
16956: LD_VAR 0 2
16960: PUSH
16961: LD_INT 8
16963: EQUAL
16964: AND
16965: PUSH
16966: LD_INT 3
16968: PPUSH
16969: LD_INT 8
16971: PPUSH
16972: CALL_OW 81
16976: PUSH
16977: LD_INT 0
16979: EQUAL
16980: AND
16981: IFFALSE 16993
// begin if acceptKurtOffert then
16983: LD_EXP 19
16987: IFFALSE 16993
// Dial_BetrayedKurt2 ;
16989: CALL 11551 0 0
// end ; end ;
16993: PPOPN 2
16995: END
// on VehicleConstructed ( vehicle , building ) do begin SetWeaponDataBuild ( GetWeapon ( vehicle ) , false ) ;
16996: LD_VAR 0 1
17000: PPUSH
17001: CALL_OW 264
17005: PPUSH
17006: LD_INT 0
17008: PPUSH
17009: CALL 6886 0 2
// if GetControl ( vehicle ) = control_computer and not buildCompVehicle then
17013: LD_VAR 0 1
17017: PPUSH
17018: CALL_OW 263
17022: PUSH
17023: LD_INT 3
17025: EQUAL
17026: PUSH
17027: LD_EXP 37
17031: NOT
17032: AND
17033: IFFALSE 17050
// begin buildCompVehicle = true ;
17035: LD_ADDR_EXP 37
17039: PUSH
17040: LD_INT 1
17042: ST_TO_ADDR
// ChangeMissionObjectives ( MAIDone ) ;
17043: LD_STRING MAIDone
17045: PPUSH
17046: CALL_OW 337
// end ; end ;
17050: PPOPN 2
17052: END
// on WeaponPlaced ( building , factory ) do begin SetWeaponDataBuild ( GetBWeapon ( building ) , true ) ;
17053: LD_VAR 0 1
17057: PPUSH
17058: CALL_OW 269
17062: PPUSH
17063: LD_INT 1
17065: PPUSH
17066: CALL 6886 0 2
// end ;
17070: PPOPN 2
17072: END
// on Command ( comandid ) do var i ;
17073: LD_INT 0
17075: PPUSH
// begin if IsOK ( KurtEng ) and GetSide ( KurtEng ) = 3 then
17076: LD_EXP 82
17080: PPUSH
17081: CALL_OW 302
17085: PUSH
17086: LD_EXP 82
17090: PPUSH
17091: CALL_OW 255
17095: PUSH
17096: LD_INT 3
17098: EQUAL
17099: AND
17100: IFFALSE 17309
// if GetTaskList ( KurtEng ) then
17102: LD_EXP 82
17106: PPUSH
17107: CALL_OW 437
17111: IFFALSE 17309
// begin for i := 1 to ( GetTaskList ( KurtEng ) ) do
17113: LD_ADDR_VAR 0 2
17117: PUSH
17118: DOUBLE
17119: LD_INT 1
17121: DEC
17122: ST_TO_ADDR
17123: LD_EXP 82
17127: PPUSH
17128: CALL_OW 437
17132: PUSH
17133: FOR_TO
17134: IFFALSE 17307
// begin if ( GetTaskList ( KurtEng ) [ i ] [ 1 ] in [ F , H , M , U , V , a , h , u , v , ~ , ^ , > , + , ; , 4 , { ] ) or ( GetTaskList ( KurtEng ) [ i ] [ 1 ] = B and GetTaskList ( KurtEng ) [ i ] [ 5 ] = 36 ) then
17136: LD_EXP 82
17140: PPUSH
17141: CALL_OW 437
17145: PUSH
17146: LD_VAR 0 2
17150: ARRAY
17151: PUSH
17152: LD_INT 1
17154: ARRAY
17155: PUSH
17156: LD_STRING F
17158: PUSH
17159: LD_STRING H
17161: PUSH
17162: LD_STRING M
17164: PUSH
17165: LD_STRING U
17167: PUSH
17168: LD_STRING V
17170: PUSH
17171: LD_STRING a
17173: PUSH
17174: LD_STRING h
17176: PUSH
17177: LD_STRING u
17179: PUSH
17180: LD_STRING v
17182: PUSH
17183: LD_STRING ~
17185: PUSH
17186: LD_STRING ^
17188: PUSH
17189: LD_STRING >
17191: PUSH
17192: LD_STRING +
17194: PUSH
17195: LD_STRING ;
17197: PUSH
17198: LD_STRING 4
17200: PUSH
17201: LD_STRING {
17203: PUSH
17204: EMPTY
17205: LIST
17206: LIST
17207: LIST
17208: LIST
17209: LIST
17210: LIST
17211: LIST
17212: LIST
17213: LIST
17214: LIST
17215: LIST
17216: LIST
17217: LIST
17218: LIST
17219: LIST
17220: LIST
17221: IN
17222: PUSH
17223: LD_EXP 82
17227: PPUSH
17228: CALL_OW 437
17232: PUSH
17233: LD_VAR 0 2
17237: ARRAY
17238: PUSH
17239: LD_INT 1
17241: ARRAY
17242: PUSH
17243: LD_STRING B
17245: EQUAL
17246: PUSH
17247: LD_EXP 82
17251: PPUSH
17252: CALL_OW 437
17256: PUSH
17257: LD_VAR 0 2
17261: ARRAY
17262: PUSH
17263: LD_INT 5
17265: ARRAY
17266: PUSH
17267: LD_INT 36
17269: EQUAL
17270: AND
17271: OR
17272: IFFALSE 17276
// else
17274: GO 17305
// begin RemoveTasks ( KurtEng ) ;
17276: LD_EXP 82
17280: PPUSH
17281: CALL_OW 493
// DialogueOn ;
17285: CALL_OW 6
// Say ( Kurt , DMercRefuseBuild-Kurt-1 ) ;
17289: LD_EXP 80
17293: PPUSH
17294: LD_STRING DMercRefuseBuild-Kurt-1
17296: PPUSH
17297: CALL_OW 88
// DialogueOff ;
17301: CALL_OW 7
// end ; end ;
17305: GO 17133
17307: POP
17308: POP
// end ; end ; end_of_file
17309: PPOPN 2
17311: END
// every 0 0$01 do var timer , cratesSpawned ;
17312: GO 17314
17314: DISABLE
17315: LD_INT 0
17317: PPUSH
17318: PPUSH
// begin timer := 1 1$30 ;
17319: LD_ADDR_VAR 0 1
17323: PUSH
17324: LD_INT 3150
17326: ST_TO_ADDR
// repeat wait ( timer ) ;
17327: LD_VAR 0 1
17331: PPUSH
17332: CALL_OW 67
// if cratesSpawned >= 6 and cratesSpawned < 18 then
17336: LD_VAR 0 2
17340: PUSH
17341: LD_INT 6
17343: GREATEREQUAL
17344: PUSH
17345: LD_VAR 0 2
17349: PUSH
17350: LD_INT 18
17352: LESS
17353: AND
17354: IFFALSE 17370
// timer := timer + 0 0$3 ;
17356: LD_ADDR_VAR 0 1
17360: PUSH
17361: LD_VAR 0 1
17365: PUSH
17366: LD_INT 105
17368: PLUS
17369: ST_TO_ADDR
// if cratesSpawned >= 18 then
17370: LD_VAR 0 2
17374: PUSH
17375: LD_INT 18
17377: GREATEREQUAL
17378: IFFALSE 17394
// timer := timer + 0 0$9 ;
17380: LD_ADDR_VAR 0 1
17384: PUSH
17385: LD_VAR 0 1
17389: PUSH
17390: LD_INT 315
17392: PLUS
17393: ST_TO_ADDR
// if timer > 3 3$00 then
17394: LD_VAR 0 1
17398: PUSH
17399: LD_INT 6300
17401: GREATER
17402: IFFALSE 17412
// timer := 0 0$50 ;
17404: LD_ADDR_VAR 0 1
17408: PUSH
17409: LD_INT 1750
17411: ST_TO_ADDR
// CreateCratesArea ( rand ( 3 , 5 ) , CratesSpawnArea , true ) ;
17412: LD_INT 3
17414: PPUSH
17415: LD_INT 5
17417: PPUSH
17418: CALL_OW 12
17422: PPUSH
17423: LD_INT 15
17425: PPUSH
17426: LD_INT 1
17428: PPUSH
17429: CALL_OW 55
// cratesSpawned = cratesSpawned + 1 ;
17433: LD_ADDR_VAR 0 2
17437: PUSH
17438: LD_VAR 0 2
17442: PUSH
17443: LD_INT 1
17445: PLUS
17446: ST_TO_ADDR
// until false ;
17447: LD_INT 0
17449: IFFALSE 17327
// end ; end_of_file
17451: PPOPN 2
17453: END
// every 0 0$1 do
17454: GO 17456
17456: DISABLE
// begin enable ;
17457: ENABLE
// end ;
17458: END
// every 0 0$1 do var building , playerBuildings , playerBuildingsBType ;
17459: GO 17461
17461: DISABLE
17462: LD_INT 0
17464: PPUSH
17465: PPUSH
17466: PPUSH
// begin playerBuildings = FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] , [ f_nation , nation_russian ] ] ) ;
17467: LD_ADDR_VAR 0 2
17471: PUSH
17472: LD_INT 22
17474: PUSH
17475: LD_INT 3
17477: PUSH
17478: EMPTY
17479: LIST
17480: LIST
17481: PUSH
17482: LD_INT 21
17484: PUSH
17485: LD_INT 3
17487: PUSH
17488: EMPTY
17489: LIST
17490: LIST
17491: PUSH
17492: LD_INT 23
17494: PUSH
17495: LD_INT 3
17497: PUSH
17498: EMPTY
17499: LIST
17500: LIST
17501: PUSH
17502: EMPTY
17503: LIST
17504: LIST
17505: LIST
17506: PPUSH
17507: CALL_OW 69
17511: ST_TO_ADDR
// playerBuildingsBType = [ ] ;
17512: LD_ADDR_VAR 0 3
17516: PUSH
17517: EMPTY
17518: ST_TO_ADDR
// for building in playerBuildings do
17519: LD_ADDR_VAR 0 1
17523: PUSH
17524: LD_VAR 0 2
17528: PUSH
17529: FOR_IN
17530: IFFALSE 17555
// playerBuildingsBType = playerBuildingsBType ^ GetBType ( building ) ;
17532: LD_ADDR_VAR 0 3
17536: PUSH
17537: LD_VAR 0 3
17541: PUSH
17542: LD_VAR 0 1
17546: PPUSH
17547: CALL_OW 266
17551: ADD
17552: ST_TO_ADDR
17553: GO 17529
17555: POP
17556: POP
// for building in allBuildings do
17557: LD_ADDR_VAR 0 1
17561: PUSH
17562: LD_EXP 13
17566: PUSH
17567: FOR_IN
17568: IFFALSE 17614
// if not building in playerBuildingsBType and not building in buildingsToBuild then
17570: LD_VAR 0 1
17574: PUSH
17575: LD_VAR 0 3
17579: IN
17580: NOT
17581: PUSH
17582: LD_VAR 0 1
17586: PUSH
17587: LD_EXP 8
17591: IN
17592: NOT
17593: AND
17594: IFFALSE 17612
// buildingsToBuild = buildingsToBuild ^ building ;
17596: LD_ADDR_EXP 8
17600: PUSH
17601: LD_EXP 8
17605: PUSH
17606: LD_VAR 0 1
17610: ADD
17611: ST_TO_ADDR
17612: GO 17567
17614: POP
17615: POP
// enable ;
17616: ENABLE
// end ;
17617: PPOPN 3
17619: END
// every 0 0$1 trigger legionOffertCountdown do
17620: LD_EXP 33
17624: IFFALSE 17644
17626: GO 17628
17628: DISABLE
// begin legionOffertTime = legionOffertTime - 0 0$01 ;
17629: LD_ADDR_EXP 34
17633: PUSH
17634: LD_EXP 34
17638: PUSH
17639: LD_INT 35
17641: MINUS
17642: ST_TO_ADDR
// enable ;
17643: ENABLE
// end ;
17644: END
// every 0 0$1 trigger KurtWaitingForFreeHeike do
17645: LD_EXP 23
17649: IFFALSE 17683
17651: GO 17653
17653: DISABLE
// begin timeToFreeHeike = timeToFreeHeike - 0 0$01 ;
17654: LD_ADDR_EXP 54
17658: PUSH
17659: LD_EXP 54
17663: PUSH
17664: LD_INT 35
17666: MINUS
17667: ST_TO_ADDR
// if timeToFreeHeike <= 0 0$00 then
17668: LD_EXP 54
17672: PUSH
17673: LD_INT 0
17675: LESSEQUAL
17676: IFFALSE 17682
// Dial_PlayerDontSendHeike ;
17678: CALL 11413 0 0
// enable ;
17682: ENABLE
// end ;
17683: END
// every 0 0$1 trigger KurtWaitingForBuildBarrack and GetSide ( KurtEng ) = 3 do
17684: LD_EXP 24
17688: PUSH
17689: LD_EXP 82
17693: PPUSH
17694: CALL_OW 255
17698: PUSH
17699: LD_INT 3
17701: EQUAL
17702: AND
17703: IFFALSE 17776
17705: GO 17707
17707: DISABLE
// begin timeToBuildArBarrack = timeToBuildArBarrack - 0 0$01 ;
17708: LD_ADDR_EXP 55
17712: PUSH
17713: LD_EXP 55
17717: PUSH
17718: LD_INT 35
17720: MINUS
17721: ST_TO_ADDR
// if timeToBuildArBarrack <= 0 0$00 then
17722: LD_EXP 55
17726: PUSH
17727: LD_INT 0
17729: LESSEQUAL
17730: IFFALSE 17775
// begin Dial_BetrayedKurt1 ;
17732: CALL 11465 0 0
// wait ( 2 2$0 ) ;
17736: LD_INT 4200
17738: PPUSH
17739: CALL_OW 67
// SetAttitude ( 3 , 8 , att_enemy , true ) ;
17743: LD_INT 3
17745: PPUSH
17746: LD_INT 8
17748: PPUSH
17749: LD_INT 2
17751: PPUSH
17752: LD_INT 1
17754: PPUSH
17755: CALL_OW 80
// KurtAttack = true ;
17759: LD_ADDR_EXP 25
17763: PUSH
17764: LD_INT 1
17766: ST_TO_ADDR
// KurtWaitingForBuildBarrack = false ;
17767: LD_ADDR_EXP 24
17771: PUSH
17772: LD_INT 0
17774: ST_TO_ADDR
// end ; enable ;
17775: ENABLE
// end ; end_of_file
17776: END
// export currentAmWave , currentArWave ; every 0 0$1 trigger americansAttack do var i ;
17777: LD_EXP 26
17781: IFFALSE 17927
17783: GO 17785
17785: DISABLE
17786: LD_INT 0
17788: PPUSH
// begin currentAmWave = 0 ;
17789: LD_ADDR_EXP 85
17793: PUSH
17794: LD_INT 0
17796: ST_TO_ADDR
// wait ( firstAttackDelay ) ;
17797: LD_EXP 49
17801: PPUSH
17802: CALL_OW 67
// for i := 1 to americansAttackWaves do
17806: LD_ADDR_VAR 0 1
17810: PUSH
17811: DOUBLE
17812: LD_INT 1
17814: DEC
17815: ST_TO_ADDR
17816: LD_EXP 48
17820: PUSH
17821: FOR_TO
17822: IFFALSE 17925
// begin SpawnAmAttackTeam ;
17824: CALL 3214 0 0
// currentAmWave = currentAmWave + 1 ;
17828: LD_ADDR_EXP 85
17832: PUSH
17833: LD_EXP 85
17837: PUSH
17838: LD_INT 1
17840: PLUS
17841: ST_TO_ADDR
// if currentAmWave = 1 then
17842: LD_EXP 85
17846: PUSH
17847: LD_INT 1
17849: EQUAL
17850: IFFALSE 17914
// begin if paidLegionOffert then
17852: LD_EXP 32
17856: IFFALSE 17895
// begin Say ( Burlak , DAmAttackStart-Bur-1 ) ;
17858: LD_EXP 57
17862: PPUSH
17863: LD_STRING DAmAttackStart-Bur-1
17865: PPUSH
17866: CALL_OW 88
// if IsOK ( Gleb ) then
17870: LD_EXP 60
17874: PPUSH
17875: CALL_OW 302
17879: IFFALSE 17893
// Say ( Gleb , DAmAttackStart-Glb-1 ) ;
17881: LD_EXP 60
17885: PPUSH
17886: LD_STRING DAmAttackStart-Glb-1
17888: PPUSH
17889: CALL_OW 88
// end else
17893: GO 17907
// Say ( Burlak , DAmAttackStart-Bur-2 ) ;
17895: LD_EXP 57
17899: PPUSH
17900: LD_STRING DAmAttackStart-Bur-2
17902: PPUSH
17903: CALL_OW 88
// ChangeMissionObjectives ( MEnemy ) ;
17907: LD_STRING MEnemy
17909: PPUSH
17910: CALL_OW 337
// end ; wait ( waveCooldown ) ;
17914: LD_EXP 50
17918: PPUSH
17919: CALL_OW 67
// end ;
17923: GO 17821
17925: POP
17926: POP
// end ;
17927: PPOPN 1
17929: END
// every 0 0$1 trigger currentAmWave = 1 do
17930: LD_EXP 85
17934: PUSH
17935: LD_INT 1
17937: EQUAL
17938: IFFALSE 18027
17940: GO 17942
17942: DISABLE
// Attack ( [ 0 , amAttackTeam , [ [ 115 , 42 ] , [ 51 , 67 ] ] , [ 0 , 0 , 0 , 1 , 1 , 1 , 0 , 0 , 1 , 0 ] ] ) ;
17943: LD_INT 0
17945: PUSH
17946: LD_EXP 78
17950: PUSH
17951: LD_INT 115
17953: PUSH
17954: LD_INT 42
17956: PUSH
17957: EMPTY
17958: LIST
17959: LIST
17960: PUSH
17961: LD_INT 51
17963: PUSH
17964: LD_INT 67
17966: PUSH
17967: EMPTY
17968: LIST
17969: LIST
17970: PUSH
17971: EMPTY
17972: LIST
17973: LIST
17974: PUSH
17975: LD_INT 0
17977: PUSH
17978: LD_INT 0
17980: PUSH
17981: LD_INT 0
17983: PUSH
17984: LD_INT 1
17986: PUSH
17987: LD_INT 1
17989: PUSH
17990: LD_INT 1
17992: PUSH
17993: LD_INT 0
17995: PUSH
17996: LD_INT 0
17998: PUSH
17999: LD_INT 1
18001: PUSH
18002: LD_INT 0
18004: PUSH
18005: EMPTY
18006: LIST
18007: LIST
18008: LIST
18009: LIST
18010: LIST
18011: LIST
18012: LIST
18013: LIST
18014: LIST
18015: LIST
18016: PUSH
18017: EMPTY
18018: LIST
18019: LIST
18020: LIST
18021: LIST
18022: PPUSH
18023: CALL 77458 0 1
18027: END
// every 0 0$1 trigger currentAmWave = 2 do
18028: LD_EXP 85
18032: PUSH
18033: LD_INT 2
18035: EQUAL
18036: IFFALSE 18125
18038: GO 18040
18040: DISABLE
// Attack ( [ 0 , amAttackTeam , [ [ 115 , 42 ] , [ 51 , 67 ] ] , [ 0 , 0 , 0 , 1 , 1 , 1 , 0 , 0 , 1 , 0 ] ] ) ;
18041: LD_INT 0
18043: PUSH
18044: LD_EXP 78
18048: PUSH
18049: LD_INT 115
18051: PUSH
18052: LD_INT 42
18054: PUSH
18055: EMPTY
18056: LIST
18057: LIST
18058: PUSH
18059: LD_INT 51
18061: PUSH
18062: LD_INT 67
18064: PUSH
18065: EMPTY
18066: LIST
18067: LIST
18068: PUSH
18069: EMPTY
18070: LIST
18071: LIST
18072: PUSH
18073: LD_INT 0
18075: PUSH
18076: LD_INT 0
18078: PUSH
18079: LD_INT 0
18081: PUSH
18082: LD_INT 1
18084: PUSH
18085: LD_INT 1
18087: PUSH
18088: LD_INT 1
18090: PUSH
18091: LD_INT 0
18093: PUSH
18094: LD_INT 0
18096: PUSH
18097: LD_INT 1
18099: PUSH
18100: LD_INT 0
18102: PUSH
18103: EMPTY
18104: LIST
18105: LIST
18106: LIST
18107: LIST
18108: LIST
18109: LIST
18110: LIST
18111: LIST
18112: LIST
18113: LIST
18114: PUSH
18115: EMPTY
18116: LIST
18117: LIST
18118: LIST
18119: LIST
18120: PPUSH
18121: CALL 77458 0 1
18125: END
// every 0 0$1 trigger currentAmWave = 3 do
18126: LD_EXP 85
18130: PUSH
18131: LD_INT 3
18133: EQUAL
18134: IFFALSE 18223
18136: GO 18138
18138: DISABLE
// Attack ( [ 0 , amAttackTeam , [ [ 115 , 42 ] , [ 51 , 67 ] ] , [ 0 , 0 , 0 , 1 , 1 , 1 , 0 , 0 , 1 , 0 ] ] ) ;
18139: LD_INT 0
18141: PUSH
18142: LD_EXP 78
18146: PUSH
18147: LD_INT 115
18149: PUSH
18150: LD_INT 42
18152: PUSH
18153: EMPTY
18154: LIST
18155: LIST
18156: PUSH
18157: LD_INT 51
18159: PUSH
18160: LD_INT 67
18162: PUSH
18163: EMPTY
18164: LIST
18165: LIST
18166: PUSH
18167: EMPTY
18168: LIST
18169: LIST
18170: PUSH
18171: LD_INT 0
18173: PUSH
18174: LD_INT 0
18176: PUSH
18177: LD_INT 0
18179: PUSH
18180: LD_INT 1
18182: PUSH
18183: LD_INT 1
18185: PUSH
18186: LD_INT 1
18188: PUSH
18189: LD_INT 0
18191: PUSH
18192: LD_INT 0
18194: PUSH
18195: LD_INT 1
18197: PUSH
18198: LD_INT 0
18200: PUSH
18201: EMPTY
18202: LIST
18203: LIST
18204: LIST
18205: LIST
18206: LIST
18207: LIST
18208: LIST
18209: LIST
18210: LIST
18211: LIST
18212: PUSH
18213: EMPTY
18214: LIST
18215: LIST
18216: LIST
18217: LIST
18218: PPUSH
18219: CALL 77458 0 1
18223: END
// every 0 0$1 trigger KurtAttack do var i ;
18224: LD_EXP 25
18228: IFFALSE 18349
18230: GO 18232
18232: DISABLE
18233: LD_INT 0
18235: PPUSH
// begin currentArWave = 0 ;
18236: LD_ADDR_EXP 86
18240: PUSH
18241: LD_INT 0
18243: ST_TO_ADDR
// wait ( firstAttackDelay ) ;
18244: LD_EXP 49
18248: PPUSH
18249: CALL_OW 67
// for i := 1 to KurtAttackWaves do
18253: LD_ADDR_VAR 0 1
18257: PUSH
18258: DOUBLE
18259: LD_INT 1
18261: DEC
18262: ST_TO_ADDR
18263: LD_EXP 47
18267: PUSH
18268: FOR_TO
18269: IFFALSE 18347
// begin if KurtAttack and IsOK ( Heike ) then
18271: LD_EXP 25
18275: PUSH
18276: LD_EXP 79
18280: PPUSH
18281: CALL_OW 302
18285: AND
18286: IFFALSE 18345
// begin SpawnArAttackTeam ;
18288: CALL 4359 0 0
// currentArWave = currentArWave + 1 ;
18292: LD_ADDR_EXP 86
18296: PUSH
18297: LD_EXP 86
18301: PUSH
18302: LD_INT 1
18304: PLUS
18305: ST_TO_ADDR
// if currentArWave = 2 then
18306: LD_EXP 86
18310: PUSH
18311: LD_INT 2
18313: EQUAL
18314: IFFALSE 18336
// begin SayRadio ( Kurt , DMercAttack-Kurt-1 ) ;
18316: LD_EXP 80
18320: PPUSH
18321: LD_STRING DMercAttack-Kurt-1
18323: PPUSH
18324: CALL_OW 94
// canSendHeike = true ;
18328: LD_ADDR_EXP 28
18332: PUSH
18333: LD_INT 1
18335: ST_TO_ADDR
// end ; wait ( waveCooldown ) ;
18336: LD_EXP 50
18340: PPUSH
18341: CALL_OW 67
// end ; end ;
18345: GO 18268
18347: POP
18348: POP
// end ;
18349: PPOPN 1
18351: END
// every 0 0$1 trigger currentArWave = 1 do
18352: LD_EXP 86
18356: PUSH
18357: LD_INT 1
18359: EQUAL
18360: IFFALSE 18449
18362: GO 18364
18364: DISABLE
// Attack ( [ 0 , arAttackTeam , [ [ 115 , 42 ] , [ 51 , 67 ] ] , [ 0 , 0 , 0 , 1 , 1 , 1 , 0 , 0 , 1 , 0 ] ] ) ;
18365: LD_INT 0
18367: PUSH
18368: LD_EXP 84
18372: PUSH
18373: LD_INT 115
18375: PUSH
18376: LD_INT 42
18378: PUSH
18379: EMPTY
18380: LIST
18381: LIST
18382: PUSH
18383: LD_INT 51
18385: PUSH
18386: LD_INT 67
18388: PUSH
18389: EMPTY
18390: LIST
18391: LIST
18392: PUSH
18393: EMPTY
18394: LIST
18395: LIST
18396: PUSH
18397: LD_INT 0
18399: PUSH
18400: LD_INT 0
18402: PUSH
18403: LD_INT 0
18405: PUSH
18406: LD_INT 1
18408: PUSH
18409: LD_INT 1
18411: PUSH
18412: LD_INT 1
18414: PUSH
18415: LD_INT 0
18417: PUSH
18418: LD_INT 0
18420: PUSH
18421: LD_INT 1
18423: PUSH
18424: LD_INT 0
18426: PUSH
18427: EMPTY
18428: LIST
18429: LIST
18430: LIST
18431: LIST
18432: LIST
18433: LIST
18434: LIST
18435: LIST
18436: LIST
18437: LIST
18438: PUSH
18439: EMPTY
18440: LIST
18441: LIST
18442: LIST
18443: LIST
18444: PPUSH
18445: CALL 77458 0 1
18449: END
// every 0 0$1 trigger currentArWave = 2 do
18450: LD_EXP 86
18454: PUSH
18455: LD_INT 2
18457: EQUAL
18458: IFFALSE 18547
18460: GO 18462
18462: DISABLE
// Attack ( [ 0 , arAttackTeam , [ [ 115 , 42 ] , [ 51 , 67 ] ] , [ 0 , 0 , 0 , 1 , 1 , 1 , 0 , 0 , 1 , 0 ] ] ) ;
18463: LD_INT 0
18465: PUSH
18466: LD_EXP 84
18470: PUSH
18471: LD_INT 115
18473: PUSH
18474: LD_INT 42
18476: PUSH
18477: EMPTY
18478: LIST
18479: LIST
18480: PUSH
18481: LD_INT 51
18483: PUSH
18484: LD_INT 67
18486: PUSH
18487: EMPTY
18488: LIST
18489: LIST
18490: PUSH
18491: EMPTY
18492: LIST
18493: LIST
18494: PUSH
18495: LD_INT 0
18497: PUSH
18498: LD_INT 0
18500: PUSH
18501: LD_INT 0
18503: PUSH
18504: LD_INT 1
18506: PUSH
18507: LD_INT 1
18509: PUSH
18510: LD_INT 1
18512: PUSH
18513: LD_INT 0
18515: PUSH
18516: LD_INT 0
18518: PUSH
18519: LD_INT 1
18521: PUSH
18522: LD_INT 0
18524: PUSH
18525: EMPTY
18526: LIST
18527: LIST
18528: LIST
18529: LIST
18530: LIST
18531: LIST
18532: LIST
18533: LIST
18534: LIST
18535: LIST
18536: PUSH
18537: EMPTY
18538: LIST
18539: LIST
18540: LIST
18541: LIST
18542: PPUSH
18543: CALL 77458 0 1
18547: END
// every 0 0$1 trigger currentArWave = 3 do
18548: LD_EXP 86
18552: PUSH
18553: LD_INT 3
18555: EQUAL
18556: IFFALSE 18645
18558: GO 18560
18560: DISABLE
// Attack ( [ 0 , arAttackTeam , [ [ 115 , 42 ] , [ 51 , 67 ] ] , [ 0 , 0 , 0 , 1 , 1 , 1 , 0 , 0 , 1 , 0 ] ] ) ;
18561: LD_INT 0
18563: PUSH
18564: LD_EXP 84
18568: PUSH
18569: LD_INT 115
18571: PUSH
18572: LD_INT 42
18574: PUSH
18575: EMPTY
18576: LIST
18577: LIST
18578: PUSH
18579: LD_INT 51
18581: PUSH
18582: LD_INT 67
18584: PUSH
18585: EMPTY
18586: LIST
18587: LIST
18588: PUSH
18589: EMPTY
18590: LIST
18591: LIST
18592: PUSH
18593: LD_INT 0
18595: PUSH
18596: LD_INT 0
18598: PUSH
18599: LD_INT 0
18601: PUSH
18602: LD_INT 1
18604: PUSH
18605: LD_INT 1
18607: PUSH
18608: LD_INT 1
18610: PUSH
18611: LD_INT 0
18613: PUSH
18614: LD_INT 0
18616: PUSH
18617: LD_INT 1
18619: PUSH
18620: LD_INT 0
18622: PUSH
18623: EMPTY
18624: LIST
18625: LIST
18626: LIST
18627: LIST
18628: LIST
18629: LIST
18630: LIST
18631: LIST
18632: LIST
18633: LIST
18634: PUSH
18635: EMPTY
18636: LIST
18637: LIST
18638: LIST
18639: LIST
18640: PPUSH
18641: CALL 77458 0 1
18645: END
// every 0 0$1 trigger currentArWave = 4 do
18646: LD_EXP 86
18650: PUSH
18651: LD_INT 4
18653: EQUAL
18654: IFFALSE 18743
18656: GO 18658
18658: DISABLE
// Attack ( [ 0 , arAttackTeam , [ [ 115 , 42 ] , [ 51 , 67 ] ] , [ 0 , 0 , 0 , 1 , 1 , 1 , 0 , 0 , 1 , 0 ] ] ) ;
18659: LD_INT 0
18661: PUSH
18662: LD_EXP 84
18666: PUSH
18667: LD_INT 115
18669: PUSH
18670: LD_INT 42
18672: PUSH
18673: EMPTY
18674: LIST
18675: LIST
18676: PUSH
18677: LD_INT 51
18679: PUSH
18680: LD_INT 67
18682: PUSH
18683: EMPTY
18684: LIST
18685: LIST
18686: PUSH
18687: EMPTY
18688: LIST
18689: LIST
18690: PUSH
18691: LD_INT 0
18693: PUSH
18694: LD_INT 0
18696: PUSH
18697: LD_INT 0
18699: PUSH
18700: LD_INT 1
18702: PUSH
18703: LD_INT 1
18705: PUSH
18706: LD_INT 1
18708: PUSH
18709: LD_INT 0
18711: PUSH
18712: LD_INT 0
18714: PUSH
18715: LD_INT 1
18717: PUSH
18718: LD_INT 0
18720: PUSH
18721: EMPTY
18722: LIST
18723: LIST
18724: LIST
18725: LIST
18726: LIST
18727: LIST
18728: LIST
18729: LIST
18730: LIST
18731: LIST
18732: PUSH
18733: EMPTY
18734: LIST
18735: LIST
18736: LIST
18737: LIST
18738: PPUSH
18739: CALL 77458 0 1
18743: END
// every 0 0$1 trigger currentArWave = 5 do
18744: LD_EXP 86
18748: PUSH
18749: LD_INT 5
18751: EQUAL
18752: IFFALSE 18841
18754: GO 18756
18756: DISABLE
// Attack ( [ 0 , arAttackTeam , [ [ 115 , 42 ] , [ 51 , 67 ] ] , [ 0 , 0 , 0 , 1 , 1 , 1 , 0 , 0 , 1 , 0 ] ] ) ; end_of_file
18757: LD_INT 0
18759: PUSH
18760: LD_EXP 84
18764: PUSH
18765: LD_INT 115
18767: PUSH
18768: LD_INT 42
18770: PUSH
18771: EMPTY
18772: LIST
18773: LIST
18774: PUSH
18775: LD_INT 51
18777: PUSH
18778: LD_INT 67
18780: PUSH
18781: EMPTY
18782: LIST
18783: LIST
18784: PUSH
18785: EMPTY
18786: LIST
18787: LIST
18788: PUSH
18789: LD_INT 0
18791: PUSH
18792: LD_INT 0
18794: PUSH
18795: LD_INT 0
18797: PUSH
18798: LD_INT 1
18800: PUSH
18801: LD_INT 1
18803: PUSH
18804: LD_INT 1
18806: PUSH
18807: LD_INT 0
18809: PUSH
18810: LD_INT 0
18812: PUSH
18813: LD_INT 1
18815: PUSH
18816: LD_INT 0
18818: PUSH
18819: EMPTY
18820: LIST
18821: LIST
18822: LIST
18823: LIST
18824: LIST
18825: LIST
18826: LIST
18827: LIST
18828: LIST
18829: LIST
18830: PUSH
18831: EMPTY
18832: LIST
18833: LIST
18834: LIST
18835: LIST
18836: PPUSH
18837: CALL 77458 0 1
18841: END
// every 0 0$1 do var arVehs , arVeh , nearPlayerUnit ;
18842: GO 18844
18844: DISABLE
18845: LD_INT 0
18847: PPUSH
18848: PPUSH
18849: PPUSH
// begin enable ;
18850: ENABLE
// arVehs = FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_vehicle ] , [ f_empty ] ] ) ;
18851: LD_ADDR_VAR 0 1
18855: PUSH
18856: LD_INT 22
18858: PUSH
18859: LD_INT 8
18861: PUSH
18862: EMPTY
18863: LIST
18864: LIST
18865: PUSH
18866: LD_INT 21
18868: PUSH
18869: LD_INT 2
18871: PUSH
18872: EMPTY
18873: LIST
18874: LIST
18875: PUSH
18876: LD_INT 58
18878: PUSH
18879: EMPTY
18880: LIST
18881: PUSH
18882: EMPTY
18883: LIST
18884: LIST
18885: LIST
18886: PPUSH
18887: CALL_OW 69
18891: ST_TO_ADDR
// if not arVehs or not GetAttitude ( 3 , 8 ) = att_enemy then
18892: LD_VAR 0 1
18896: NOT
18897: PUSH
18898: LD_INT 3
18900: PPUSH
18901: LD_INT 8
18903: PPUSH
18904: CALL_OW 81
18908: PUSH
18909: LD_INT 2
18911: EQUAL
18912: NOT
18913: OR
18914: IFFALSE 18918
// exit ;
18916: GO 19008
// for arVeh in arVehs do
18918: LD_ADDR_VAR 0 2
18922: PUSH
18923: LD_VAR 0 1
18927: PUSH
18928: FOR_IN
18929: IFFALSE 19006
// begin nearPlayerUnit = NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) , arVeh ) ;
18931: LD_ADDR_VAR 0 3
18935: PUSH
18936: LD_INT 22
18938: PUSH
18939: LD_INT 3
18941: PUSH
18942: EMPTY
18943: LIST
18944: LIST
18945: PUSH
18946: LD_INT 21
18948: PUSH
18949: LD_INT 1
18951: PUSH
18952: EMPTY
18953: LIST
18954: LIST
18955: PUSH
18956: EMPTY
18957: LIST
18958: LIST
18959: PPUSH
18960: CALL_OW 69
18964: PPUSH
18965: LD_VAR 0 2
18969: PPUSH
18970: CALL_OW 74
18974: ST_TO_ADDR
// if GetDistUnits ( nearPlayerUnit , arVeh ) <= 2 then
18975: LD_VAR 0 3
18979: PPUSH
18980: LD_VAR 0 2
18984: PPUSH
18985: CALL_OW 296
18989: PUSH
18990: LD_INT 2
18992: LESSEQUAL
18993: IFFALSE 19004
// ComSelfDestruction ( arVeh ) ;
18995: LD_VAR 0 2
18999: PPUSH
19000: CALL_OW 577
// end ;
19004: GO 18928
19006: POP
19007: POP
// end ;
19008: PPOPN 3
19010: END
// every 0 0$1 trigger forceStopKurtAttack do
19011: LD_EXP 27
19015: IFFALSE 19081
19017: GO 19019
19019: DISABLE
// begin KurtAttack = false ;
19020: LD_ADDR_EXP 25
19024: PUSH
19025: LD_INT 0
19027: ST_TO_ADDR
// allowExitFromMap = 4 ;
19028: LD_ADDR_EXP 18
19032: PUSH
19033: LD_INT 4
19035: ST_TO_ADDR
// SetAttitude ( 3 , 8 , att_friend , true ) ;
19036: LD_INT 3
19038: PPUSH
19039: LD_INT 8
19041: PPUSH
19042: LD_INT 1
19044: PPUSH
19045: LD_INT 1
19047: PPUSH
19048: CALL_OW 80
// arAttackTeam = [ ] ;
19052: LD_ADDR_EXP 84
19056: PUSH
19057: EMPTY
19058: ST_TO_ADDR
// ComMoveToArea ( FilterAllUnits ( [ f_side , 8 ] ) , KurtExitMapArea ) ;
19059: LD_INT 22
19061: PUSH
19062: LD_INT 8
19064: PUSH
19065: EMPTY
19066: LIST
19067: LIST
19068: PPUSH
19069: CALL_OW 69
19073: PPUSH
19074: LD_INT 11
19076: PPUSH
19077: CALL_OW 113
// end ; end_of_file end_of_file
19081: END
// every 0 0$01 do var timer , cratesSpawned ;
19082: GO 19084
19084: DISABLE
19085: LD_INT 0
19087: PPUSH
19088: PPUSH
// begin timer := 1 1$30 ;
19089: LD_ADDR_VAR 0 1
19093: PUSH
19094: LD_INT 3150
19096: ST_TO_ADDR
// repeat wait ( timer ) ;
19097: LD_VAR 0 1
19101: PPUSH
19102: CALL_OW 67
// if cratesSpawned >= 6 and cratesSpawned < 18 then
19106: LD_VAR 0 2
19110: PUSH
19111: LD_INT 6
19113: GREATEREQUAL
19114: PUSH
19115: LD_VAR 0 2
19119: PUSH
19120: LD_INT 18
19122: LESS
19123: AND
19124: IFFALSE 19140
// timer := timer + 0 0$3 ;
19126: LD_ADDR_VAR 0 1
19130: PUSH
19131: LD_VAR 0 1
19135: PUSH
19136: LD_INT 105
19138: PLUS
19139: ST_TO_ADDR
// if cratesSpawned >= 18 then
19140: LD_VAR 0 2
19144: PUSH
19145: LD_INT 18
19147: GREATEREQUAL
19148: IFFALSE 19164
// timer := timer + 0 0$9 ;
19150: LD_ADDR_VAR 0 1
19154: PUSH
19155: LD_VAR 0 1
19159: PUSH
19160: LD_INT 315
19162: PLUS
19163: ST_TO_ADDR
// if timer > 3 3$00 then
19164: LD_VAR 0 1
19168: PUSH
19169: LD_INT 6300
19171: GREATER
19172: IFFALSE 19182
// timer := 0 0$50 ;
19174: LD_ADDR_VAR 0 1
19178: PUSH
19179: LD_INT 1750
19181: ST_TO_ADDR
// CreateCratesArea ( rand ( 3 , 5 ) , CratesSpawnArea , true ) ;
19182: LD_INT 3
19184: PPUSH
19185: LD_INT 5
19187: PPUSH
19188: CALL_OW 12
19192: PPUSH
19193: LD_INT 15
19195: PPUSH
19196: LD_INT 1
19198: PPUSH
19199: CALL_OW 55
// cratesSpawned = cratesSpawned + 1 ;
19203: LD_ADDR_VAR 0 2
19207: PUSH
19208: LD_VAR 0 2
19212: PUSH
19213: LD_INT 1
19215: PLUS
19216: ST_TO_ADDR
// until false ;
19217: LD_INT 0
19219: IFFALSE 19097
// end ; end_of_file
19221: PPOPN 2
19223: END
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
19224: LD_INT 0
19226: PPUSH
19227: PPUSH
// if exist_mode then
19228: LD_VAR 0 2
19232: IFFALSE 19257
// unit := CreateCharacter ( prefix & ident ) else
19234: LD_ADDR_VAR 0 5
19238: PUSH
19239: LD_VAR 0 3
19243: PUSH
19244: LD_VAR 0 1
19248: STR
19249: PPUSH
19250: CALL_OW 34
19254: ST_TO_ADDR
19255: GO 19272
// unit := NewCharacter ( ident ) ;
19257: LD_ADDR_VAR 0 5
19261: PUSH
19262: LD_VAR 0 1
19266: PPUSH
19267: CALL_OW 25
19271: ST_TO_ADDR
// result := unit ;
19272: LD_ADDR_VAR 0 4
19276: PUSH
19277: LD_VAR 0 5
19281: ST_TO_ADDR
// end ;
19282: LD_VAR 0 4
19286: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
19287: LD_INT 0
19289: PPUSH
19290: PPUSH
// if not side or not nation then
19291: LD_VAR 0 1
19295: NOT
19296: PUSH
19297: LD_VAR 0 2
19301: NOT
19302: OR
19303: IFFALSE 19307
// exit ;
19305: GO 20075
// case nation of nation_american :
19307: LD_VAR 0 2
19311: PUSH
19312: LD_INT 1
19314: DOUBLE
19315: EQUAL
19316: IFTRUE 19320
19318: GO 19534
19320: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
19321: LD_ADDR_VAR 0 4
19325: PUSH
19326: LD_INT 35
19328: PUSH
19329: LD_INT 45
19331: PUSH
19332: LD_INT 46
19334: PUSH
19335: LD_INT 47
19337: PUSH
19338: LD_INT 82
19340: PUSH
19341: LD_INT 83
19343: PUSH
19344: LD_INT 84
19346: PUSH
19347: LD_INT 85
19349: PUSH
19350: LD_INT 86
19352: PUSH
19353: LD_INT 1
19355: PUSH
19356: LD_INT 2
19358: PUSH
19359: LD_INT 6
19361: PUSH
19362: LD_INT 15
19364: PUSH
19365: LD_INT 16
19367: PUSH
19368: LD_INT 7
19370: PUSH
19371: LD_INT 12
19373: PUSH
19374: LD_INT 13
19376: PUSH
19377: LD_INT 10
19379: PUSH
19380: LD_INT 14
19382: PUSH
19383: LD_INT 20
19385: PUSH
19386: LD_INT 21
19388: PUSH
19389: LD_INT 22
19391: PUSH
19392: LD_INT 25
19394: PUSH
19395: LD_INT 32
19397: PUSH
19398: LD_INT 27
19400: PUSH
19401: LD_INT 36
19403: PUSH
19404: LD_INT 69
19406: PUSH
19407: LD_INT 39
19409: PUSH
19410: LD_INT 34
19412: PUSH
19413: LD_INT 40
19415: PUSH
19416: LD_INT 48
19418: PUSH
19419: LD_INT 49
19421: PUSH
19422: LD_INT 50
19424: PUSH
19425: LD_INT 51
19427: PUSH
19428: LD_INT 52
19430: PUSH
19431: LD_INT 53
19433: PUSH
19434: LD_INT 54
19436: PUSH
19437: LD_INT 55
19439: PUSH
19440: LD_INT 56
19442: PUSH
19443: LD_INT 57
19445: PUSH
19446: LD_INT 58
19448: PUSH
19449: LD_INT 59
19451: PUSH
19452: LD_INT 60
19454: PUSH
19455: LD_INT 61
19457: PUSH
19458: LD_INT 62
19460: PUSH
19461: LD_INT 80
19463: PUSH
19464: LD_INT 82
19466: PUSH
19467: LD_INT 83
19469: PUSH
19470: LD_INT 84
19472: PUSH
19473: LD_INT 85
19475: PUSH
19476: LD_INT 86
19478: PUSH
19479: EMPTY
19480: LIST
19481: LIST
19482: LIST
19483: LIST
19484: LIST
19485: LIST
19486: LIST
19487: LIST
19488: LIST
19489: LIST
19490: LIST
19491: LIST
19492: LIST
19493: LIST
19494: LIST
19495: LIST
19496: LIST
19497: LIST
19498: LIST
19499: LIST
19500: LIST
19501: LIST
19502: LIST
19503: LIST
19504: LIST
19505: LIST
19506: LIST
19507: LIST
19508: LIST
19509: LIST
19510: LIST
19511: LIST
19512: LIST
19513: LIST
19514: LIST
19515: LIST
19516: LIST
19517: LIST
19518: LIST
19519: LIST
19520: LIST
19521: LIST
19522: LIST
19523: LIST
19524: LIST
19525: LIST
19526: LIST
19527: LIST
19528: LIST
19529: LIST
19530: LIST
19531: ST_TO_ADDR
19532: GO 19999
19534: LD_INT 2
19536: DOUBLE
19537: EQUAL
19538: IFTRUE 19542
19540: GO 19768
19542: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 ] ; nation_russian :
19543: LD_ADDR_VAR 0 4
19547: PUSH
19548: LD_INT 35
19550: PUSH
19551: LD_INT 45
19553: PUSH
19554: LD_INT 46
19556: PUSH
19557: LD_INT 47
19559: PUSH
19560: LD_INT 82
19562: PUSH
19563: LD_INT 83
19565: PUSH
19566: LD_INT 84
19568: PUSH
19569: LD_INT 85
19571: PUSH
19572: LD_INT 87
19574: PUSH
19575: LD_INT 70
19577: PUSH
19578: LD_INT 1
19580: PUSH
19581: LD_INT 11
19583: PUSH
19584: LD_INT 3
19586: PUSH
19587: LD_INT 4
19589: PUSH
19590: LD_INT 5
19592: PUSH
19593: LD_INT 6
19595: PUSH
19596: LD_INT 15
19598: PUSH
19599: LD_INT 18
19601: PUSH
19602: LD_INT 7
19604: PUSH
19605: LD_INT 17
19607: PUSH
19608: LD_INT 8
19610: PUSH
19611: LD_INT 20
19613: PUSH
19614: LD_INT 21
19616: PUSH
19617: LD_INT 22
19619: PUSH
19620: LD_INT 72
19622: PUSH
19623: LD_INT 26
19625: PUSH
19626: LD_INT 69
19628: PUSH
19629: LD_INT 39
19631: PUSH
19632: LD_INT 40
19634: PUSH
19635: LD_INT 41
19637: PUSH
19638: LD_INT 42
19640: PUSH
19641: LD_INT 43
19643: PUSH
19644: LD_INT 48
19646: PUSH
19647: LD_INT 49
19649: PUSH
19650: LD_INT 50
19652: PUSH
19653: LD_INT 51
19655: PUSH
19656: LD_INT 52
19658: PUSH
19659: LD_INT 53
19661: PUSH
19662: LD_INT 54
19664: PUSH
19665: LD_INT 55
19667: PUSH
19668: LD_INT 56
19670: PUSH
19671: LD_INT 60
19673: PUSH
19674: LD_INT 61
19676: PUSH
19677: LD_INT 62
19679: PUSH
19680: LD_INT 66
19682: PUSH
19683: LD_INT 67
19685: PUSH
19686: LD_INT 68
19688: PUSH
19689: LD_INT 81
19691: PUSH
19692: LD_INT 82
19694: PUSH
19695: LD_INT 83
19697: PUSH
19698: LD_INT 84
19700: PUSH
19701: LD_INT 85
19703: PUSH
19704: LD_INT 87
19706: PUSH
19707: LD_INT 88
19709: PUSH
19710: EMPTY
19711: LIST
19712: LIST
19713: LIST
19714: LIST
19715: LIST
19716: LIST
19717: LIST
19718: LIST
19719: LIST
19720: LIST
19721: LIST
19722: LIST
19723: LIST
19724: LIST
19725: LIST
19726: LIST
19727: LIST
19728: LIST
19729: LIST
19730: LIST
19731: LIST
19732: LIST
19733: LIST
19734: LIST
19735: LIST
19736: LIST
19737: LIST
19738: LIST
19739: LIST
19740: LIST
19741: LIST
19742: LIST
19743: LIST
19744: LIST
19745: LIST
19746: LIST
19747: LIST
19748: LIST
19749: LIST
19750: LIST
19751: LIST
19752: LIST
19753: LIST
19754: LIST
19755: LIST
19756: LIST
19757: LIST
19758: LIST
19759: LIST
19760: LIST
19761: LIST
19762: LIST
19763: LIST
19764: LIST
19765: ST_TO_ADDR
19766: GO 19999
19768: LD_INT 3
19770: DOUBLE
19771: EQUAL
19772: IFTRUE 19776
19774: GO 19998
19776: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
19777: LD_ADDR_VAR 0 4
19781: PUSH
19782: LD_INT 46
19784: PUSH
19785: LD_INT 47
19787: PUSH
19788: LD_INT 1
19790: PUSH
19791: LD_INT 2
19793: PUSH
19794: LD_INT 82
19796: PUSH
19797: LD_INT 83
19799: PUSH
19800: LD_INT 84
19802: PUSH
19803: LD_INT 85
19805: PUSH
19806: LD_INT 86
19808: PUSH
19809: LD_INT 11
19811: PUSH
19812: LD_INT 9
19814: PUSH
19815: LD_INT 20
19817: PUSH
19818: LD_INT 19
19820: PUSH
19821: LD_INT 21
19823: PUSH
19824: LD_INT 24
19826: PUSH
19827: LD_INT 22
19829: PUSH
19830: LD_INT 25
19832: PUSH
19833: LD_INT 28
19835: PUSH
19836: LD_INT 29
19838: PUSH
19839: LD_INT 30
19841: PUSH
19842: LD_INT 31
19844: PUSH
19845: LD_INT 37
19847: PUSH
19848: LD_INT 38
19850: PUSH
19851: LD_INT 32
19853: PUSH
19854: LD_INT 27
19856: PUSH
19857: LD_INT 33
19859: PUSH
19860: LD_INT 69
19862: PUSH
19863: LD_INT 39
19865: PUSH
19866: LD_INT 34
19868: PUSH
19869: LD_INT 40
19871: PUSH
19872: LD_INT 71
19874: PUSH
19875: LD_INT 23
19877: PUSH
19878: LD_INT 44
19880: PUSH
19881: LD_INT 48
19883: PUSH
19884: LD_INT 49
19886: PUSH
19887: LD_INT 50
19889: PUSH
19890: LD_INT 51
19892: PUSH
19893: LD_INT 52
19895: PUSH
19896: LD_INT 53
19898: PUSH
19899: LD_INT 54
19901: PUSH
19902: LD_INT 55
19904: PUSH
19905: LD_INT 56
19907: PUSH
19908: LD_INT 57
19910: PUSH
19911: LD_INT 58
19913: PUSH
19914: LD_INT 59
19916: PUSH
19917: LD_INT 63
19919: PUSH
19920: LD_INT 64
19922: PUSH
19923: LD_INT 65
19925: PUSH
19926: LD_INT 82
19928: PUSH
19929: LD_INT 83
19931: PUSH
19932: LD_INT 84
19934: PUSH
19935: LD_INT 85
19937: PUSH
19938: LD_INT 86
19940: PUSH
19941: EMPTY
19942: LIST
19943: LIST
19944: LIST
19945: LIST
19946: LIST
19947: LIST
19948: LIST
19949: LIST
19950: LIST
19951: LIST
19952: LIST
19953: LIST
19954: LIST
19955: LIST
19956: LIST
19957: LIST
19958: LIST
19959: LIST
19960: LIST
19961: LIST
19962: LIST
19963: LIST
19964: LIST
19965: LIST
19966: LIST
19967: LIST
19968: LIST
19969: LIST
19970: LIST
19971: LIST
19972: LIST
19973: LIST
19974: LIST
19975: LIST
19976: LIST
19977: LIST
19978: LIST
19979: LIST
19980: LIST
19981: LIST
19982: LIST
19983: LIST
19984: LIST
19985: LIST
19986: LIST
19987: LIST
19988: LIST
19989: LIST
19990: LIST
19991: LIST
19992: LIST
19993: LIST
19994: LIST
19995: ST_TO_ADDR
19996: GO 19999
19998: POP
// if state > - 1 and state < 3 then
19999: LD_VAR 0 3
20003: PUSH
20004: LD_INT 1
20006: NEG
20007: GREATER
20008: PUSH
20009: LD_VAR 0 3
20013: PUSH
20014: LD_INT 3
20016: LESS
20017: AND
20018: IFFALSE 20075
// for i in result do
20020: LD_ADDR_VAR 0 5
20024: PUSH
20025: LD_VAR 0 4
20029: PUSH
20030: FOR_IN
20031: IFFALSE 20073
// if GetTech ( i , side ) <> state then
20033: LD_VAR 0 5
20037: PPUSH
20038: LD_VAR 0 1
20042: PPUSH
20043: CALL_OW 321
20047: PUSH
20048: LD_VAR 0 3
20052: NONEQUAL
20053: IFFALSE 20071
// result := result diff i ;
20055: LD_ADDR_VAR 0 4
20059: PUSH
20060: LD_VAR 0 4
20064: PUSH
20065: LD_VAR 0 5
20069: DIFF
20070: ST_TO_ADDR
20071: GO 20030
20073: POP
20074: POP
// end ;
20075: LD_VAR 0 4
20079: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
20080: LD_INT 0
20082: PPUSH
20083: PPUSH
20084: PPUSH
// result := true ;
20085: LD_ADDR_VAR 0 3
20089: PUSH
20090: LD_INT 1
20092: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
20093: LD_ADDR_VAR 0 5
20097: PUSH
20098: LD_VAR 0 2
20102: PPUSH
20103: CALL_OW 480
20107: ST_TO_ADDR
// if not tmp then
20108: LD_VAR 0 5
20112: NOT
20113: IFFALSE 20117
// exit ;
20115: GO 20166
// for i in tmp do
20117: LD_ADDR_VAR 0 4
20121: PUSH
20122: LD_VAR 0 5
20126: PUSH
20127: FOR_IN
20128: IFFALSE 20164
// if GetTech ( i , side ) <> state_researched then
20130: LD_VAR 0 4
20134: PPUSH
20135: LD_VAR 0 1
20139: PPUSH
20140: CALL_OW 321
20144: PUSH
20145: LD_INT 2
20147: NONEQUAL
20148: IFFALSE 20162
// begin result := false ;
20150: LD_ADDR_VAR 0 3
20154: PUSH
20155: LD_INT 0
20157: ST_TO_ADDR
// exit ;
20158: POP
20159: POP
20160: GO 20166
// end ;
20162: GO 20127
20164: POP
20165: POP
// end ;
20166: LD_VAR 0 3
20170: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
20171: LD_INT 0
20173: PPUSH
20174: PPUSH
20175: PPUSH
20176: PPUSH
20177: PPUSH
20178: PPUSH
20179: PPUSH
20180: PPUSH
20181: PPUSH
20182: PPUSH
20183: PPUSH
20184: PPUSH
20185: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
20186: LD_VAR 0 1
20190: NOT
20191: PUSH
20192: LD_VAR 0 1
20196: PPUSH
20197: CALL_OW 257
20201: PUSH
20202: LD_INT 9
20204: NONEQUAL
20205: OR
20206: IFFALSE 20210
// exit ;
20208: GO 20783
// side := GetSide ( unit ) ;
20210: LD_ADDR_VAR 0 9
20214: PUSH
20215: LD_VAR 0 1
20219: PPUSH
20220: CALL_OW 255
20224: ST_TO_ADDR
// tech_space := tech_spacanom ;
20225: LD_ADDR_VAR 0 12
20229: PUSH
20230: LD_INT 29
20232: ST_TO_ADDR
// tech_time := tech_taurad ;
20233: LD_ADDR_VAR 0 13
20237: PUSH
20238: LD_INT 28
20240: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
20241: LD_ADDR_VAR 0 11
20245: PUSH
20246: LD_VAR 0 1
20250: PPUSH
20251: CALL_OW 310
20255: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
20256: LD_VAR 0 11
20260: PPUSH
20261: CALL_OW 247
20265: PUSH
20266: LD_INT 2
20268: EQUAL
20269: IFFALSE 20273
// exit ;
20271: GO 20783
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
20273: LD_ADDR_VAR 0 8
20277: PUSH
20278: LD_INT 81
20280: PUSH
20281: LD_VAR 0 9
20285: PUSH
20286: EMPTY
20287: LIST
20288: LIST
20289: PUSH
20290: LD_INT 3
20292: PUSH
20293: LD_INT 21
20295: PUSH
20296: LD_INT 3
20298: PUSH
20299: EMPTY
20300: LIST
20301: LIST
20302: PUSH
20303: EMPTY
20304: LIST
20305: LIST
20306: PUSH
20307: EMPTY
20308: LIST
20309: LIST
20310: PPUSH
20311: CALL_OW 69
20315: ST_TO_ADDR
// if not tmp then
20316: LD_VAR 0 8
20320: NOT
20321: IFFALSE 20325
// exit ;
20323: GO 20783
// if in_unit then
20325: LD_VAR 0 11
20329: IFFALSE 20353
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
20331: LD_ADDR_VAR 0 10
20335: PUSH
20336: LD_VAR 0 8
20340: PPUSH
20341: LD_VAR 0 11
20345: PPUSH
20346: CALL_OW 74
20350: ST_TO_ADDR
20351: GO 20373
// enemy := NearestUnitToUnit ( tmp , unit ) ;
20353: LD_ADDR_VAR 0 10
20357: PUSH
20358: LD_VAR 0 8
20362: PPUSH
20363: LD_VAR 0 1
20367: PPUSH
20368: CALL_OW 74
20372: ST_TO_ADDR
// if not enemy then
20373: LD_VAR 0 10
20377: NOT
20378: IFFALSE 20382
// exit ;
20380: GO 20783
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
20382: LD_VAR 0 11
20386: PUSH
20387: LD_VAR 0 11
20391: PPUSH
20392: LD_VAR 0 10
20396: PPUSH
20397: CALL_OW 296
20401: PUSH
20402: LD_INT 13
20404: GREATER
20405: AND
20406: PUSH
20407: LD_VAR 0 1
20411: PPUSH
20412: LD_VAR 0 10
20416: PPUSH
20417: CALL_OW 296
20421: PUSH
20422: LD_INT 12
20424: GREATER
20425: OR
20426: IFFALSE 20430
// exit ;
20428: GO 20783
// missile := [ 1 ] ;
20430: LD_ADDR_VAR 0 14
20434: PUSH
20435: LD_INT 1
20437: PUSH
20438: EMPTY
20439: LIST
20440: ST_TO_ADDR
// if Researched ( side , tech_space ) then
20441: LD_VAR 0 9
20445: PPUSH
20446: LD_VAR 0 12
20450: PPUSH
20451: CALL_OW 325
20455: IFFALSE 20484
// missile := Insert ( missile , missile + 1 , 2 ) ;
20457: LD_ADDR_VAR 0 14
20461: PUSH
20462: LD_VAR 0 14
20466: PPUSH
20467: LD_VAR 0 14
20471: PUSH
20472: LD_INT 1
20474: PLUS
20475: PPUSH
20476: LD_INT 2
20478: PPUSH
20479: CALL_OW 2
20483: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
20484: LD_VAR 0 9
20488: PPUSH
20489: LD_VAR 0 13
20493: PPUSH
20494: CALL_OW 325
20498: PUSH
20499: LD_VAR 0 10
20503: PPUSH
20504: CALL_OW 255
20508: PPUSH
20509: LD_VAR 0 13
20513: PPUSH
20514: CALL_OW 325
20518: NOT
20519: AND
20520: IFFALSE 20549
// missile := Insert ( missile , missile + 1 , 3 ) ;
20522: LD_ADDR_VAR 0 14
20526: PUSH
20527: LD_VAR 0 14
20531: PPUSH
20532: LD_VAR 0 14
20536: PUSH
20537: LD_INT 1
20539: PLUS
20540: PPUSH
20541: LD_INT 3
20543: PPUSH
20544: CALL_OW 2
20548: ST_TO_ADDR
// if missile < 2 then
20549: LD_VAR 0 14
20553: PUSH
20554: LD_INT 2
20556: LESS
20557: IFFALSE 20561
// exit ;
20559: GO 20783
// x := GetX ( enemy ) ;
20561: LD_ADDR_VAR 0 4
20565: PUSH
20566: LD_VAR 0 10
20570: PPUSH
20571: CALL_OW 250
20575: ST_TO_ADDR
// y := GetY ( enemy ) ;
20576: LD_ADDR_VAR 0 5
20580: PUSH
20581: LD_VAR 0 10
20585: PPUSH
20586: CALL_OW 251
20590: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
20591: LD_ADDR_VAR 0 6
20595: PUSH
20596: LD_VAR 0 4
20600: PUSH
20601: LD_INT 1
20603: NEG
20604: PPUSH
20605: LD_INT 1
20607: PPUSH
20608: CALL_OW 12
20612: PLUS
20613: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
20614: LD_ADDR_VAR 0 7
20618: PUSH
20619: LD_VAR 0 5
20623: PUSH
20624: LD_INT 1
20626: NEG
20627: PPUSH
20628: LD_INT 1
20630: PPUSH
20631: CALL_OW 12
20635: PLUS
20636: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
20637: LD_VAR 0 6
20641: PPUSH
20642: LD_VAR 0 7
20646: PPUSH
20647: CALL_OW 488
20651: NOT
20652: IFFALSE 20674
// begin _x := x ;
20654: LD_ADDR_VAR 0 6
20658: PUSH
20659: LD_VAR 0 4
20663: ST_TO_ADDR
// _y := y ;
20664: LD_ADDR_VAR 0 7
20668: PUSH
20669: LD_VAR 0 5
20673: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
20674: LD_ADDR_VAR 0 3
20678: PUSH
20679: LD_INT 1
20681: PPUSH
20682: LD_VAR 0 14
20686: PPUSH
20687: CALL_OW 12
20691: ST_TO_ADDR
// case i of 1 :
20692: LD_VAR 0 3
20696: PUSH
20697: LD_INT 1
20699: DOUBLE
20700: EQUAL
20701: IFTRUE 20705
20703: GO 20722
20705: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
20706: LD_VAR 0 1
20710: PPUSH
20711: LD_VAR 0 10
20715: PPUSH
20716: CALL_OW 115
20720: GO 20783
20722: LD_INT 2
20724: DOUBLE
20725: EQUAL
20726: IFTRUE 20730
20728: GO 20752
20730: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
20731: LD_VAR 0 1
20735: PPUSH
20736: LD_VAR 0 6
20740: PPUSH
20741: LD_VAR 0 7
20745: PPUSH
20746: CALL_OW 153
20750: GO 20783
20752: LD_INT 3
20754: DOUBLE
20755: EQUAL
20756: IFTRUE 20760
20758: GO 20782
20760: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
20761: LD_VAR 0 1
20765: PPUSH
20766: LD_VAR 0 6
20770: PPUSH
20771: LD_VAR 0 7
20775: PPUSH
20776: CALL_OW 154
20780: GO 20783
20782: POP
// end ;
20783: LD_VAR 0 2
20787: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
20788: LD_INT 0
20790: PPUSH
20791: PPUSH
20792: PPUSH
20793: PPUSH
20794: PPUSH
20795: PPUSH
// if not unit or not building then
20796: LD_VAR 0 1
20800: NOT
20801: PUSH
20802: LD_VAR 0 2
20806: NOT
20807: OR
20808: IFFALSE 20812
// exit ;
20810: GO 20970
// x := GetX ( building ) ;
20812: LD_ADDR_VAR 0 5
20816: PUSH
20817: LD_VAR 0 2
20821: PPUSH
20822: CALL_OW 250
20826: ST_TO_ADDR
// y := GetY ( building ) ;
20827: LD_ADDR_VAR 0 6
20831: PUSH
20832: LD_VAR 0 2
20836: PPUSH
20837: CALL_OW 251
20841: ST_TO_ADDR
// for i = 0 to 5 do
20842: LD_ADDR_VAR 0 4
20846: PUSH
20847: DOUBLE
20848: LD_INT 0
20850: DEC
20851: ST_TO_ADDR
20852: LD_INT 5
20854: PUSH
20855: FOR_TO
20856: IFFALSE 20968
// begin _x := ShiftX ( x , i , 3 ) ;
20858: LD_ADDR_VAR 0 7
20862: PUSH
20863: LD_VAR 0 5
20867: PPUSH
20868: LD_VAR 0 4
20872: PPUSH
20873: LD_INT 3
20875: PPUSH
20876: CALL_OW 272
20880: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
20881: LD_ADDR_VAR 0 8
20885: PUSH
20886: LD_VAR 0 6
20890: PPUSH
20891: LD_VAR 0 4
20895: PPUSH
20896: LD_INT 3
20898: PPUSH
20899: CALL_OW 273
20903: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
20904: LD_VAR 0 7
20908: PPUSH
20909: LD_VAR 0 8
20913: PPUSH
20914: CALL_OW 488
20918: NOT
20919: IFFALSE 20923
// continue ;
20921: GO 20855
// if HexInfo ( _x , _y ) = 0 then
20923: LD_VAR 0 7
20927: PPUSH
20928: LD_VAR 0 8
20932: PPUSH
20933: CALL_OW 428
20937: PUSH
20938: LD_INT 0
20940: EQUAL
20941: IFFALSE 20966
// begin ComMoveXY ( unit , _x , _y ) ;
20943: LD_VAR 0 1
20947: PPUSH
20948: LD_VAR 0 7
20952: PPUSH
20953: LD_VAR 0 8
20957: PPUSH
20958: CALL_OW 111
// exit ;
20962: POP
20963: POP
20964: GO 20970
// end ; end ;
20966: GO 20855
20968: POP
20969: POP
// end ;
20970: LD_VAR 0 3
20974: RET
// export function ScanBase ( side , base_area ) ; begin
20975: LD_INT 0
20977: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
20978: LD_ADDR_VAR 0 3
20982: PUSH
20983: LD_VAR 0 2
20987: PPUSH
20988: LD_INT 81
20990: PUSH
20991: LD_VAR 0 1
20995: PUSH
20996: EMPTY
20997: LIST
20998: LIST
20999: PPUSH
21000: CALL_OW 70
21004: ST_TO_ADDR
// end ;
21005: LD_VAR 0 3
21009: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
21010: LD_INT 0
21012: PPUSH
21013: PPUSH
21014: PPUSH
21015: PPUSH
// result := false ;
21016: LD_ADDR_VAR 0 2
21020: PUSH
21021: LD_INT 0
21023: ST_TO_ADDR
// side := GetSide ( unit ) ;
21024: LD_ADDR_VAR 0 3
21028: PUSH
21029: LD_VAR 0 1
21033: PPUSH
21034: CALL_OW 255
21038: ST_TO_ADDR
// nat := GetNation ( unit ) ;
21039: LD_ADDR_VAR 0 4
21043: PUSH
21044: LD_VAR 0 1
21048: PPUSH
21049: CALL_OW 248
21053: ST_TO_ADDR
// case nat of 1 :
21054: LD_VAR 0 4
21058: PUSH
21059: LD_INT 1
21061: DOUBLE
21062: EQUAL
21063: IFTRUE 21067
21065: GO 21078
21067: POP
// tech := tech_lassight ; 2 :
21068: LD_ADDR_VAR 0 5
21072: PUSH
21073: LD_INT 12
21075: ST_TO_ADDR
21076: GO 21117
21078: LD_INT 2
21080: DOUBLE
21081: EQUAL
21082: IFTRUE 21086
21084: GO 21097
21086: POP
// tech := tech_mortar ; 3 :
21087: LD_ADDR_VAR 0 5
21091: PUSH
21092: LD_INT 41
21094: ST_TO_ADDR
21095: GO 21117
21097: LD_INT 3
21099: DOUBLE
21100: EQUAL
21101: IFTRUE 21105
21103: GO 21116
21105: POP
// tech := tech_bazooka ; end ;
21106: LD_ADDR_VAR 0 5
21110: PUSH
21111: LD_INT 44
21113: ST_TO_ADDR
21114: GO 21117
21116: POP
// if Researched ( side , tech ) then
21117: LD_VAR 0 3
21121: PPUSH
21122: LD_VAR 0 5
21126: PPUSH
21127: CALL_OW 325
21131: IFFALSE 21158
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
21133: LD_ADDR_VAR 0 2
21137: PUSH
21138: LD_INT 5
21140: PUSH
21141: LD_INT 8
21143: PUSH
21144: LD_INT 9
21146: PUSH
21147: EMPTY
21148: LIST
21149: LIST
21150: LIST
21151: PUSH
21152: LD_VAR 0 4
21156: ARRAY
21157: ST_TO_ADDR
// end ;
21158: LD_VAR 0 2
21162: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
21163: LD_INT 0
21165: PPUSH
21166: PPUSH
21167: PPUSH
// if not mines then
21168: LD_VAR 0 2
21172: NOT
21173: IFFALSE 21177
// exit ;
21175: GO 21321
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
21177: LD_ADDR_VAR 0 5
21181: PUSH
21182: LD_INT 81
21184: PUSH
21185: LD_VAR 0 1
21189: PUSH
21190: EMPTY
21191: LIST
21192: LIST
21193: PUSH
21194: LD_INT 3
21196: PUSH
21197: LD_INT 21
21199: PUSH
21200: LD_INT 3
21202: PUSH
21203: EMPTY
21204: LIST
21205: LIST
21206: PUSH
21207: EMPTY
21208: LIST
21209: LIST
21210: PUSH
21211: EMPTY
21212: LIST
21213: LIST
21214: PPUSH
21215: CALL_OW 69
21219: ST_TO_ADDR
// for i in mines do
21220: LD_ADDR_VAR 0 4
21224: PUSH
21225: LD_VAR 0 2
21229: PUSH
21230: FOR_IN
21231: IFFALSE 21319
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
21233: LD_VAR 0 4
21237: PUSH
21238: LD_INT 1
21240: ARRAY
21241: PPUSH
21242: LD_VAR 0 4
21246: PUSH
21247: LD_INT 2
21249: ARRAY
21250: PPUSH
21251: CALL_OW 458
21255: NOT
21256: IFFALSE 21260
// continue ;
21258: GO 21230
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
21260: LD_VAR 0 4
21264: PUSH
21265: LD_INT 1
21267: ARRAY
21268: PPUSH
21269: LD_VAR 0 4
21273: PUSH
21274: LD_INT 2
21276: ARRAY
21277: PPUSH
21278: CALL_OW 428
21282: PUSH
21283: LD_VAR 0 5
21287: IN
21288: IFFALSE 21317
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
21290: LD_VAR 0 4
21294: PUSH
21295: LD_INT 1
21297: ARRAY
21298: PPUSH
21299: LD_VAR 0 4
21303: PUSH
21304: LD_INT 2
21306: ARRAY
21307: PPUSH
21308: LD_VAR 0 1
21312: PPUSH
21313: CALL_OW 456
// end ;
21317: GO 21230
21319: POP
21320: POP
// end ;
21321: LD_VAR 0 3
21325: RET
// export function Count ( array ) ; var i ; begin
21326: LD_INT 0
21328: PPUSH
21329: PPUSH
// result := 0 ;
21330: LD_ADDR_VAR 0 2
21334: PUSH
21335: LD_INT 0
21337: ST_TO_ADDR
// for i in array do
21338: LD_ADDR_VAR 0 3
21342: PUSH
21343: LD_VAR 0 1
21347: PUSH
21348: FOR_IN
21349: IFFALSE 21373
// if i then
21351: LD_VAR 0 3
21355: IFFALSE 21371
// result := result + 1 ;
21357: LD_ADDR_VAR 0 2
21361: PUSH
21362: LD_VAR 0 2
21366: PUSH
21367: LD_INT 1
21369: PLUS
21370: ST_TO_ADDR
21371: GO 21348
21373: POP
21374: POP
// end ;
21375: LD_VAR 0 2
21379: RET
// export function IsEmpty ( building ) ; begin
21380: LD_INT 0
21382: PPUSH
// if not building then
21383: LD_VAR 0 1
21387: NOT
21388: IFFALSE 21392
// exit ;
21390: GO 21435
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
21392: LD_ADDR_VAR 0 2
21396: PUSH
21397: LD_VAR 0 1
21401: PUSH
21402: LD_INT 22
21404: PUSH
21405: LD_VAR 0 1
21409: PPUSH
21410: CALL_OW 255
21414: PUSH
21415: EMPTY
21416: LIST
21417: LIST
21418: PUSH
21419: LD_INT 58
21421: PUSH
21422: EMPTY
21423: LIST
21424: PUSH
21425: EMPTY
21426: LIST
21427: LIST
21428: PPUSH
21429: CALL_OW 69
21433: IN
21434: ST_TO_ADDR
// end ;
21435: LD_VAR 0 2
21439: RET
// export function IsNotFull ( building ) ; begin
21440: LD_INT 0
21442: PPUSH
// if not building then
21443: LD_VAR 0 1
21447: NOT
21448: IFFALSE 21452
// exit ;
21450: GO 21471
// result := UnitsInside ( building ) < 6 ;
21452: LD_ADDR_VAR 0 2
21456: PUSH
21457: LD_VAR 0 1
21461: PPUSH
21462: CALL_OW 313
21466: PUSH
21467: LD_INT 6
21469: LESS
21470: ST_TO_ADDR
// end ;
21471: LD_VAR 0 2
21475: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
21476: LD_INT 0
21478: PPUSH
21479: PPUSH
21480: PPUSH
21481: PPUSH
// tmp := [ ] ;
21482: LD_ADDR_VAR 0 3
21486: PUSH
21487: EMPTY
21488: ST_TO_ADDR
// list := [ ] ;
21489: LD_ADDR_VAR 0 5
21493: PUSH
21494: EMPTY
21495: ST_TO_ADDR
// for i = 16 to 25 do
21496: LD_ADDR_VAR 0 4
21500: PUSH
21501: DOUBLE
21502: LD_INT 16
21504: DEC
21505: ST_TO_ADDR
21506: LD_INT 25
21508: PUSH
21509: FOR_TO
21510: IFFALSE 21583
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
21512: LD_ADDR_VAR 0 3
21516: PUSH
21517: LD_VAR 0 3
21521: PUSH
21522: LD_INT 22
21524: PUSH
21525: LD_VAR 0 1
21529: PPUSH
21530: CALL_OW 255
21534: PUSH
21535: EMPTY
21536: LIST
21537: LIST
21538: PUSH
21539: LD_INT 91
21541: PUSH
21542: LD_VAR 0 1
21546: PUSH
21547: LD_INT 6
21549: PUSH
21550: EMPTY
21551: LIST
21552: LIST
21553: LIST
21554: PUSH
21555: LD_INT 30
21557: PUSH
21558: LD_VAR 0 4
21562: PUSH
21563: EMPTY
21564: LIST
21565: LIST
21566: PUSH
21567: EMPTY
21568: LIST
21569: LIST
21570: LIST
21571: PUSH
21572: EMPTY
21573: LIST
21574: PPUSH
21575: CALL_OW 69
21579: ADD
21580: ST_TO_ADDR
21581: GO 21509
21583: POP
21584: POP
// for i = 1 to tmp do
21585: LD_ADDR_VAR 0 4
21589: PUSH
21590: DOUBLE
21591: LD_INT 1
21593: DEC
21594: ST_TO_ADDR
21595: LD_VAR 0 3
21599: PUSH
21600: FOR_TO
21601: IFFALSE 21689
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
21603: LD_ADDR_VAR 0 5
21607: PUSH
21608: LD_VAR 0 5
21612: PUSH
21613: LD_VAR 0 3
21617: PUSH
21618: LD_VAR 0 4
21622: ARRAY
21623: PPUSH
21624: CALL_OW 266
21628: PUSH
21629: LD_VAR 0 3
21633: PUSH
21634: LD_VAR 0 4
21638: ARRAY
21639: PPUSH
21640: CALL_OW 250
21644: PUSH
21645: LD_VAR 0 3
21649: PUSH
21650: LD_VAR 0 4
21654: ARRAY
21655: PPUSH
21656: CALL_OW 251
21660: PUSH
21661: LD_VAR 0 3
21665: PUSH
21666: LD_VAR 0 4
21670: ARRAY
21671: PPUSH
21672: CALL_OW 254
21676: PUSH
21677: EMPTY
21678: LIST
21679: LIST
21680: LIST
21681: LIST
21682: PUSH
21683: EMPTY
21684: LIST
21685: ADD
21686: ST_TO_ADDR
21687: GO 21600
21689: POP
21690: POP
// result := list ;
21691: LD_ADDR_VAR 0 2
21695: PUSH
21696: LD_VAR 0 5
21700: ST_TO_ADDR
// end ;
21701: LD_VAR 0 2
21705: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
21706: LD_INT 0
21708: PPUSH
21709: PPUSH
21710: PPUSH
21711: PPUSH
21712: PPUSH
21713: PPUSH
21714: PPUSH
// if not factory then
21715: LD_VAR 0 1
21719: NOT
21720: IFFALSE 21724
// exit ;
21722: GO 22317
// if control = control_apeman then
21724: LD_VAR 0 4
21728: PUSH
21729: LD_INT 5
21731: EQUAL
21732: IFFALSE 21841
// begin tmp := UnitsInside ( factory ) ;
21734: LD_ADDR_VAR 0 8
21738: PUSH
21739: LD_VAR 0 1
21743: PPUSH
21744: CALL_OW 313
21748: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
21749: LD_VAR 0 8
21753: PPUSH
21754: LD_INT 25
21756: PUSH
21757: LD_INT 12
21759: PUSH
21760: EMPTY
21761: LIST
21762: LIST
21763: PPUSH
21764: CALL_OW 72
21768: NOT
21769: IFFALSE 21779
// control := control_manual ;
21771: LD_ADDR_VAR 0 4
21775: PUSH
21776: LD_INT 1
21778: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
21779: LD_ADDR_VAR 0 8
21783: PUSH
21784: LD_VAR 0 1
21788: PPUSH
21789: CALL 21476 0 1
21793: ST_TO_ADDR
// if tmp then
21794: LD_VAR 0 8
21798: IFFALSE 21841
// begin for i in tmp do
21800: LD_ADDR_VAR 0 7
21804: PUSH
21805: LD_VAR 0 8
21809: PUSH
21810: FOR_IN
21811: IFFALSE 21839
// if i [ 1 ] = b_ext_radio then
21813: LD_VAR 0 7
21817: PUSH
21818: LD_INT 1
21820: ARRAY
21821: PUSH
21822: LD_INT 22
21824: EQUAL
21825: IFFALSE 21837
// begin control := control_remote ;
21827: LD_ADDR_VAR 0 4
21831: PUSH
21832: LD_INT 2
21834: ST_TO_ADDR
// break ;
21835: GO 21839
// end ;
21837: GO 21810
21839: POP
21840: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
21841: LD_VAR 0 1
21845: PPUSH
21846: LD_VAR 0 2
21850: PPUSH
21851: LD_VAR 0 3
21855: PPUSH
21856: LD_VAR 0 4
21860: PPUSH
21861: LD_VAR 0 5
21865: PPUSH
21866: CALL_OW 448
21870: IFFALSE 21905
// begin result := [ chassis , engine , control , weapon ] ;
21872: LD_ADDR_VAR 0 6
21876: PUSH
21877: LD_VAR 0 2
21881: PUSH
21882: LD_VAR 0 3
21886: PUSH
21887: LD_VAR 0 4
21891: PUSH
21892: LD_VAR 0 5
21896: PUSH
21897: EMPTY
21898: LIST
21899: LIST
21900: LIST
21901: LIST
21902: ST_TO_ADDR
// exit ;
21903: GO 22317
// end ; _chassis := AvailableChassisList ( factory ) ;
21905: LD_ADDR_VAR 0 9
21909: PUSH
21910: LD_VAR 0 1
21914: PPUSH
21915: CALL_OW 475
21919: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
21920: LD_ADDR_VAR 0 11
21924: PUSH
21925: LD_VAR 0 1
21929: PPUSH
21930: CALL_OW 476
21934: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
21935: LD_ADDR_VAR 0 12
21939: PUSH
21940: LD_VAR 0 1
21944: PPUSH
21945: CALL_OW 477
21949: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
21950: LD_ADDR_VAR 0 10
21954: PUSH
21955: LD_VAR 0 1
21959: PPUSH
21960: CALL_OW 478
21964: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
21965: LD_VAR 0 9
21969: NOT
21970: PUSH
21971: LD_VAR 0 11
21975: NOT
21976: OR
21977: PUSH
21978: LD_VAR 0 12
21982: NOT
21983: OR
21984: PUSH
21985: LD_VAR 0 10
21989: NOT
21990: OR
21991: IFFALSE 22026
// begin result := [ chassis , engine , control , weapon ] ;
21993: LD_ADDR_VAR 0 6
21997: PUSH
21998: LD_VAR 0 2
22002: PUSH
22003: LD_VAR 0 3
22007: PUSH
22008: LD_VAR 0 4
22012: PUSH
22013: LD_VAR 0 5
22017: PUSH
22018: EMPTY
22019: LIST
22020: LIST
22021: LIST
22022: LIST
22023: ST_TO_ADDR
// exit ;
22024: GO 22317
// end ; if not chassis in _chassis then
22026: LD_VAR 0 2
22030: PUSH
22031: LD_VAR 0 9
22035: IN
22036: NOT
22037: IFFALSE 22063
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
22039: LD_ADDR_VAR 0 2
22043: PUSH
22044: LD_VAR 0 9
22048: PUSH
22049: LD_INT 1
22051: PPUSH
22052: LD_VAR 0 9
22056: PPUSH
22057: CALL_OW 12
22061: ARRAY
22062: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
22063: LD_VAR 0 2
22067: PPUSH
22068: LD_VAR 0 3
22072: PPUSH
22073: CALL 22322 0 2
22077: NOT
22078: IFFALSE 22137
// repeat engine := _engine [ 1 ] ;
22080: LD_ADDR_VAR 0 3
22084: PUSH
22085: LD_VAR 0 11
22089: PUSH
22090: LD_INT 1
22092: ARRAY
22093: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
22094: LD_ADDR_VAR 0 11
22098: PUSH
22099: LD_VAR 0 11
22103: PPUSH
22104: LD_INT 1
22106: PPUSH
22107: CALL_OW 3
22111: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
22112: LD_VAR 0 2
22116: PPUSH
22117: LD_VAR 0 3
22121: PPUSH
22122: CALL 22322 0 2
22126: PUSH
22127: LD_VAR 0 11
22131: PUSH
22132: EMPTY
22133: EQUAL
22134: OR
22135: IFFALSE 22080
// if not control in _control then
22137: LD_VAR 0 4
22141: PUSH
22142: LD_VAR 0 12
22146: IN
22147: NOT
22148: IFFALSE 22174
// control := _control [ rand ( 1 , _control ) ] ;
22150: LD_ADDR_VAR 0 4
22154: PUSH
22155: LD_VAR 0 12
22159: PUSH
22160: LD_INT 1
22162: PPUSH
22163: LD_VAR 0 12
22167: PPUSH
22168: CALL_OW 12
22172: ARRAY
22173: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
22174: LD_VAR 0 2
22178: PPUSH
22179: LD_VAR 0 5
22183: PPUSH
22184: CALL 22542 0 2
22188: NOT
22189: IFFALSE 22248
// repeat weapon := _weapon [ 1 ] ;
22191: LD_ADDR_VAR 0 5
22195: PUSH
22196: LD_VAR 0 10
22200: PUSH
22201: LD_INT 1
22203: ARRAY
22204: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
22205: LD_ADDR_VAR 0 10
22209: PUSH
22210: LD_VAR 0 10
22214: PPUSH
22215: LD_INT 1
22217: PPUSH
22218: CALL_OW 3
22222: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
22223: LD_VAR 0 2
22227: PPUSH
22228: LD_VAR 0 5
22232: PPUSH
22233: CALL 22542 0 2
22237: PUSH
22238: LD_VAR 0 10
22242: PUSH
22243: EMPTY
22244: EQUAL
22245: OR
22246: IFFALSE 22191
// result := [ ] ;
22248: LD_ADDR_VAR 0 6
22252: PUSH
22253: EMPTY
22254: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
22255: LD_VAR 0 1
22259: PPUSH
22260: LD_VAR 0 2
22264: PPUSH
22265: LD_VAR 0 3
22269: PPUSH
22270: LD_VAR 0 4
22274: PPUSH
22275: LD_VAR 0 5
22279: PPUSH
22280: CALL_OW 448
22284: IFFALSE 22317
// result := [ chassis , engine , control , weapon ] ;
22286: LD_ADDR_VAR 0 6
22290: PUSH
22291: LD_VAR 0 2
22295: PUSH
22296: LD_VAR 0 3
22300: PUSH
22301: LD_VAR 0 4
22305: PUSH
22306: LD_VAR 0 5
22310: PUSH
22311: EMPTY
22312: LIST
22313: LIST
22314: LIST
22315: LIST
22316: ST_TO_ADDR
// end ;
22317: LD_VAR 0 6
22321: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
22322: LD_INT 0
22324: PPUSH
// if not chassis or not engine then
22325: LD_VAR 0 1
22329: NOT
22330: PUSH
22331: LD_VAR 0 2
22335: NOT
22336: OR
22337: IFFALSE 22341
// exit ;
22339: GO 22537
// case engine of engine_solar :
22341: LD_VAR 0 2
22345: PUSH
22346: LD_INT 2
22348: DOUBLE
22349: EQUAL
22350: IFTRUE 22354
22352: GO 22392
22354: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
22355: LD_ADDR_VAR 0 3
22359: PUSH
22360: LD_INT 11
22362: PUSH
22363: LD_INT 12
22365: PUSH
22366: LD_INT 13
22368: PUSH
22369: LD_INT 14
22371: PUSH
22372: LD_INT 1
22374: PUSH
22375: LD_INT 2
22377: PUSH
22378: LD_INT 3
22380: PUSH
22381: EMPTY
22382: LIST
22383: LIST
22384: LIST
22385: LIST
22386: LIST
22387: LIST
22388: LIST
22389: ST_TO_ADDR
22390: GO 22521
22392: LD_INT 1
22394: DOUBLE
22395: EQUAL
22396: IFTRUE 22400
22398: GO 22462
22400: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
22401: LD_ADDR_VAR 0 3
22405: PUSH
22406: LD_INT 11
22408: PUSH
22409: LD_INT 12
22411: PUSH
22412: LD_INT 13
22414: PUSH
22415: LD_INT 14
22417: PUSH
22418: LD_INT 1
22420: PUSH
22421: LD_INT 2
22423: PUSH
22424: LD_INT 3
22426: PUSH
22427: LD_INT 4
22429: PUSH
22430: LD_INT 5
22432: PUSH
22433: LD_INT 21
22435: PUSH
22436: LD_INT 23
22438: PUSH
22439: LD_INT 22
22441: PUSH
22442: LD_INT 24
22444: PUSH
22445: EMPTY
22446: LIST
22447: LIST
22448: LIST
22449: LIST
22450: LIST
22451: LIST
22452: LIST
22453: LIST
22454: LIST
22455: LIST
22456: LIST
22457: LIST
22458: LIST
22459: ST_TO_ADDR
22460: GO 22521
22462: LD_INT 3
22464: DOUBLE
22465: EQUAL
22466: IFTRUE 22470
22468: GO 22520
22470: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
22471: LD_ADDR_VAR 0 3
22475: PUSH
22476: LD_INT 13
22478: PUSH
22479: LD_INT 14
22481: PUSH
22482: LD_INT 2
22484: PUSH
22485: LD_INT 3
22487: PUSH
22488: LD_INT 4
22490: PUSH
22491: LD_INT 5
22493: PUSH
22494: LD_INT 21
22496: PUSH
22497: LD_INT 22
22499: PUSH
22500: LD_INT 23
22502: PUSH
22503: LD_INT 24
22505: PUSH
22506: EMPTY
22507: LIST
22508: LIST
22509: LIST
22510: LIST
22511: LIST
22512: LIST
22513: LIST
22514: LIST
22515: LIST
22516: LIST
22517: ST_TO_ADDR
22518: GO 22521
22520: POP
// result := ( chassis in result ) ;
22521: LD_ADDR_VAR 0 3
22525: PUSH
22526: LD_VAR 0 1
22530: PUSH
22531: LD_VAR 0 3
22535: IN
22536: ST_TO_ADDR
// end ;
22537: LD_VAR 0 3
22541: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
22542: LD_INT 0
22544: PPUSH
// if not chassis or not weapon then
22545: LD_VAR 0 1
22549: NOT
22550: PUSH
22551: LD_VAR 0 2
22555: NOT
22556: OR
22557: IFFALSE 22561
// exit ;
22559: GO 23623
// case weapon of us_machine_gun :
22561: LD_VAR 0 2
22565: PUSH
22566: LD_INT 2
22568: DOUBLE
22569: EQUAL
22570: IFTRUE 22574
22572: GO 22604
22574: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
22575: LD_ADDR_VAR 0 3
22579: PUSH
22580: LD_INT 1
22582: PUSH
22583: LD_INT 2
22585: PUSH
22586: LD_INT 3
22588: PUSH
22589: LD_INT 4
22591: PUSH
22592: LD_INT 5
22594: PUSH
22595: EMPTY
22596: LIST
22597: LIST
22598: LIST
22599: LIST
22600: LIST
22601: ST_TO_ADDR
22602: GO 23607
22604: LD_INT 3
22606: DOUBLE
22607: EQUAL
22608: IFTRUE 22612
22610: GO 22642
22612: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
22613: LD_ADDR_VAR 0 3
22617: PUSH
22618: LD_INT 1
22620: PUSH
22621: LD_INT 2
22623: PUSH
22624: LD_INT 3
22626: PUSH
22627: LD_INT 4
22629: PUSH
22630: LD_INT 5
22632: PUSH
22633: EMPTY
22634: LIST
22635: LIST
22636: LIST
22637: LIST
22638: LIST
22639: ST_TO_ADDR
22640: GO 23607
22642: LD_INT 11
22644: DOUBLE
22645: EQUAL
22646: IFTRUE 22650
22648: GO 22680
22650: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
22651: LD_ADDR_VAR 0 3
22655: PUSH
22656: LD_INT 1
22658: PUSH
22659: LD_INT 2
22661: PUSH
22662: LD_INT 3
22664: PUSH
22665: LD_INT 4
22667: PUSH
22668: LD_INT 5
22670: PUSH
22671: EMPTY
22672: LIST
22673: LIST
22674: LIST
22675: LIST
22676: LIST
22677: ST_TO_ADDR
22678: GO 23607
22680: LD_INT 4
22682: DOUBLE
22683: EQUAL
22684: IFTRUE 22688
22686: GO 22714
22688: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
22689: LD_ADDR_VAR 0 3
22693: PUSH
22694: LD_INT 2
22696: PUSH
22697: LD_INT 3
22699: PUSH
22700: LD_INT 4
22702: PUSH
22703: LD_INT 5
22705: PUSH
22706: EMPTY
22707: LIST
22708: LIST
22709: LIST
22710: LIST
22711: ST_TO_ADDR
22712: GO 23607
22714: LD_INT 5
22716: DOUBLE
22717: EQUAL
22718: IFTRUE 22722
22720: GO 22748
22722: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
22723: LD_ADDR_VAR 0 3
22727: PUSH
22728: LD_INT 2
22730: PUSH
22731: LD_INT 3
22733: PUSH
22734: LD_INT 4
22736: PUSH
22737: LD_INT 5
22739: PUSH
22740: EMPTY
22741: LIST
22742: LIST
22743: LIST
22744: LIST
22745: ST_TO_ADDR
22746: GO 23607
22748: LD_INT 9
22750: DOUBLE
22751: EQUAL
22752: IFTRUE 22756
22754: GO 22782
22756: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
22757: LD_ADDR_VAR 0 3
22761: PUSH
22762: LD_INT 2
22764: PUSH
22765: LD_INT 3
22767: PUSH
22768: LD_INT 4
22770: PUSH
22771: LD_INT 5
22773: PUSH
22774: EMPTY
22775: LIST
22776: LIST
22777: LIST
22778: LIST
22779: ST_TO_ADDR
22780: GO 23607
22782: LD_INT 7
22784: DOUBLE
22785: EQUAL
22786: IFTRUE 22790
22788: GO 22816
22790: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
22791: LD_ADDR_VAR 0 3
22795: PUSH
22796: LD_INT 2
22798: PUSH
22799: LD_INT 3
22801: PUSH
22802: LD_INT 4
22804: PUSH
22805: LD_INT 5
22807: PUSH
22808: EMPTY
22809: LIST
22810: LIST
22811: LIST
22812: LIST
22813: ST_TO_ADDR
22814: GO 23607
22816: LD_INT 12
22818: DOUBLE
22819: EQUAL
22820: IFTRUE 22824
22822: GO 22850
22824: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
22825: LD_ADDR_VAR 0 3
22829: PUSH
22830: LD_INT 2
22832: PUSH
22833: LD_INT 3
22835: PUSH
22836: LD_INT 4
22838: PUSH
22839: LD_INT 5
22841: PUSH
22842: EMPTY
22843: LIST
22844: LIST
22845: LIST
22846: LIST
22847: ST_TO_ADDR
22848: GO 23607
22850: LD_INT 13
22852: DOUBLE
22853: EQUAL
22854: IFTRUE 22858
22856: GO 22884
22858: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
22859: LD_ADDR_VAR 0 3
22863: PUSH
22864: LD_INT 2
22866: PUSH
22867: LD_INT 3
22869: PUSH
22870: LD_INT 4
22872: PUSH
22873: LD_INT 5
22875: PUSH
22876: EMPTY
22877: LIST
22878: LIST
22879: LIST
22880: LIST
22881: ST_TO_ADDR
22882: GO 23607
22884: LD_INT 14
22886: DOUBLE
22887: EQUAL
22888: IFTRUE 22892
22890: GO 22910
22892: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
22893: LD_ADDR_VAR 0 3
22897: PUSH
22898: LD_INT 4
22900: PUSH
22901: LD_INT 5
22903: PUSH
22904: EMPTY
22905: LIST
22906: LIST
22907: ST_TO_ADDR
22908: GO 23607
22910: LD_INT 6
22912: DOUBLE
22913: EQUAL
22914: IFTRUE 22918
22916: GO 22936
22918: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
22919: LD_ADDR_VAR 0 3
22923: PUSH
22924: LD_INT 4
22926: PUSH
22927: LD_INT 5
22929: PUSH
22930: EMPTY
22931: LIST
22932: LIST
22933: ST_TO_ADDR
22934: GO 23607
22936: LD_INT 10
22938: DOUBLE
22939: EQUAL
22940: IFTRUE 22944
22942: GO 22962
22944: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
22945: LD_ADDR_VAR 0 3
22949: PUSH
22950: LD_INT 4
22952: PUSH
22953: LD_INT 5
22955: PUSH
22956: EMPTY
22957: LIST
22958: LIST
22959: ST_TO_ADDR
22960: GO 23607
22962: LD_INT 22
22964: DOUBLE
22965: EQUAL
22966: IFTRUE 22970
22968: GO 22996
22970: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
22971: LD_ADDR_VAR 0 3
22975: PUSH
22976: LD_INT 11
22978: PUSH
22979: LD_INT 12
22981: PUSH
22982: LD_INT 13
22984: PUSH
22985: LD_INT 14
22987: PUSH
22988: EMPTY
22989: LIST
22990: LIST
22991: LIST
22992: LIST
22993: ST_TO_ADDR
22994: GO 23607
22996: LD_INT 23
22998: DOUBLE
22999: EQUAL
23000: IFTRUE 23004
23002: GO 23030
23004: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
23005: LD_ADDR_VAR 0 3
23009: PUSH
23010: LD_INT 11
23012: PUSH
23013: LD_INT 12
23015: PUSH
23016: LD_INT 13
23018: PUSH
23019: LD_INT 14
23021: PUSH
23022: EMPTY
23023: LIST
23024: LIST
23025: LIST
23026: LIST
23027: ST_TO_ADDR
23028: GO 23607
23030: LD_INT 24
23032: DOUBLE
23033: EQUAL
23034: IFTRUE 23038
23036: GO 23064
23038: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
23039: LD_ADDR_VAR 0 3
23043: PUSH
23044: LD_INT 11
23046: PUSH
23047: LD_INT 12
23049: PUSH
23050: LD_INT 13
23052: PUSH
23053: LD_INT 14
23055: PUSH
23056: EMPTY
23057: LIST
23058: LIST
23059: LIST
23060: LIST
23061: ST_TO_ADDR
23062: GO 23607
23064: LD_INT 30
23066: DOUBLE
23067: EQUAL
23068: IFTRUE 23072
23070: GO 23098
23072: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
23073: LD_ADDR_VAR 0 3
23077: PUSH
23078: LD_INT 11
23080: PUSH
23081: LD_INT 12
23083: PUSH
23084: LD_INT 13
23086: PUSH
23087: LD_INT 14
23089: PUSH
23090: EMPTY
23091: LIST
23092: LIST
23093: LIST
23094: LIST
23095: ST_TO_ADDR
23096: GO 23607
23098: LD_INT 25
23100: DOUBLE
23101: EQUAL
23102: IFTRUE 23106
23104: GO 23124
23106: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
23107: LD_ADDR_VAR 0 3
23111: PUSH
23112: LD_INT 13
23114: PUSH
23115: LD_INT 14
23117: PUSH
23118: EMPTY
23119: LIST
23120: LIST
23121: ST_TO_ADDR
23122: GO 23607
23124: LD_INT 27
23126: DOUBLE
23127: EQUAL
23128: IFTRUE 23132
23130: GO 23150
23132: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
23133: LD_ADDR_VAR 0 3
23137: PUSH
23138: LD_INT 13
23140: PUSH
23141: LD_INT 14
23143: PUSH
23144: EMPTY
23145: LIST
23146: LIST
23147: ST_TO_ADDR
23148: GO 23607
23150: LD_EXP 162
23154: DOUBLE
23155: EQUAL
23156: IFTRUE 23160
23158: GO 23186
23160: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
23161: LD_ADDR_VAR 0 3
23165: PUSH
23166: LD_INT 11
23168: PUSH
23169: LD_INT 12
23171: PUSH
23172: LD_INT 13
23174: PUSH
23175: LD_INT 14
23177: PUSH
23178: EMPTY
23179: LIST
23180: LIST
23181: LIST
23182: LIST
23183: ST_TO_ADDR
23184: GO 23607
23186: LD_INT 28
23188: DOUBLE
23189: EQUAL
23190: IFTRUE 23194
23192: GO 23212
23194: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
23195: LD_ADDR_VAR 0 3
23199: PUSH
23200: LD_INT 13
23202: PUSH
23203: LD_INT 14
23205: PUSH
23206: EMPTY
23207: LIST
23208: LIST
23209: ST_TO_ADDR
23210: GO 23607
23212: LD_INT 29
23214: DOUBLE
23215: EQUAL
23216: IFTRUE 23220
23218: GO 23238
23220: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
23221: LD_ADDR_VAR 0 3
23225: PUSH
23226: LD_INT 13
23228: PUSH
23229: LD_INT 14
23231: PUSH
23232: EMPTY
23233: LIST
23234: LIST
23235: ST_TO_ADDR
23236: GO 23607
23238: LD_INT 31
23240: DOUBLE
23241: EQUAL
23242: IFTRUE 23246
23244: GO 23264
23246: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
23247: LD_ADDR_VAR 0 3
23251: PUSH
23252: LD_INT 13
23254: PUSH
23255: LD_INT 14
23257: PUSH
23258: EMPTY
23259: LIST
23260: LIST
23261: ST_TO_ADDR
23262: GO 23607
23264: LD_INT 26
23266: DOUBLE
23267: EQUAL
23268: IFTRUE 23272
23270: GO 23290
23272: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
23273: LD_ADDR_VAR 0 3
23277: PUSH
23278: LD_INT 13
23280: PUSH
23281: LD_INT 14
23283: PUSH
23284: EMPTY
23285: LIST
23286: LIST
23287: ST_TO_ADDR
23288: GO 23607
23290: LD_INT 42
23292: DOUBLE
23293: EQUAL
23294: IFTRUE 23298
23296: GO 23324
23298: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
23299: LD_ADDR_VAR 0 3
23303: PUSH
23304: LD_INT 21
23306: PUSH
23307: LD_INT 22
23309: PUSH
23310: LD_INT 23
23312: PUSH
23313: LD_INT 24
23315: PUSH
23316: EMPTY
23317: LIST
23318: LIST
23319: LIST
23320: LIST
23321: ST_TO_ADDR
23322: GO 23607
23324: LD_INT 43
23326: DOUBLE
23327: EQUAL
23328: IFTRUE 23332
23330: GO 23358
23332: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
23333: LD_ADDR_VAR 0 3
23337: PUSH
23338: LD_INT 21
23340: PUSH
23341: LD_INT 22
23343: PUSH
23344: LD_INT 23
23346: PUSH
23347: LD_INT 24
23349: PUSH
23350: EMPTY
23351: LIST
23352: LIST
23353: LIST
23354: LIST
23355: ST_TO_ADDR
23356: GO 23607
23358: LD_INT 44
23360: DOUBLE
23361: EQUAL
23362: IFTRUE 23366
23364: GO 23392
23366: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
23367: LD_ADDR_VAR 0 3
23371: PUSH
23372: LD_INT 21
23374: PUSH
23375: LD_INT 22
23377: PUSH
23378: LD_INT 23
23380: PUSH
23381: LD_INT 24
23383: PUSH
23384: EMPTY
23385: LIST
23386: LIST
23387: LIST
23388: LIST
23389: ST_TO_ADDR
23390: GO 23607
23392: LD_INT 45
23394: DOUBLE
23395: EQUAL
23396: IFTRUE 23400
23398: GO 23426
23400: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
23401: LD_ADDR_VAR 0 3
23405: PUSH
23406: LD_INT 21
23408: PUSH
23409: LD_INT 22
23411: PUSH
23412: LD_INT 23
23414: PUSH
23415: LD_INT 24
23417: PUSH
23418: EMPTY
23419: LIST
23420: LIST
23421: LIST
23422: LIST
23423: ST_TO_ADDR
23424: GO 23607
23426: LD_INT 49
23428: DOUBLE
23429: EQUAL
23430: IFTRUE 23434
23432: GO 23460
23434: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
23435: LD_ADDR_VAR 0 3
23439: PUSH
23440: LD_INT 21
23442: PUSH
23443: LD_INT 22
23445: PUSH
23446: LD_INT 23
23448: PUSH
23449: LD_INT 24
23451: PUSH
23452: EMPTY
23453: LIST
23454: LIST
23455: LIST
23456: LIST
23457: ST_TO_ADDR
23458: GO 23607
23460: LD_INT 51
23462: DOUBLE
23463: EQUAL
23464: IFTRUE 23468
23466: GO 23494
23468: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
23469: LD_ADDR_VAR 0 3
23473: PUSH
23474: LD_INT 21
23476: PUSH
23477: LD_INT 22
23479: PUSH
23480: LD_INT 23
23482: PUSH
23483: LD_INT 24
23485: PUSH
23486: EMPTY
23487: LIST
23488: LIST
23489: LIST
23490: LIST
23491: ST_TO_ADDR
23492: GO 23607
23494: LD_INT 52
23496: DOUBLE
23497: EQUAL
23498: IFTRUE 23502
23500: GO 23528
23502: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
23503: LD_ADDR_VAR 0 3
23507: PUSH
23508: LD_INT 21
23510: PUSH
23511: LD_INT 22
23513: PUSH
23514: LD_INT 23
23516: PUSH
23517: LD_INT 24
23519: PUSH
23520: EMPTY
23521: LIST
23522: LIST
23523: LIST
23524: LIST
23525: ST_TO_ADDR
23526: GO 23607
23528: LD_INT 53
23530: DOUBLE
23531: EQUAL
23532: IFTRUE 23536
23534: GO 23554
23536: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
23537: LD_ADDR_VAR 0 3
23541: PUSH
23542: LD_INT 23
23544: PUSH
23545: LD_INT 24
23547: PUSH
23548: EMPTY
23549: LIST
23550: LIST
23551: ST_TO_ADDR
23552: GO 23607
23554: LD_INT 46
23556: DOUBLE
23557: EQUAL
23558: IFTRUE 23562
23560: GO 23580
23562: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
23563: LD_ADDR_VAR 0 3
23567: PUSH
23568: LD_INT 23
23570: PUSH
23571: LD_INT 24
23573: PUSH
23574: EMPTY
23575: LIST
23576: LIST
23577: ST_TO_ADDR
23578: GO 23607
23580: LD_INT 47
23582: DOUBLE
23583: EQUAL
23584: IFTRUE 23588
23586: GO 23606
23588: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
23589: LD_ADDR_VAR 0 3
23593: PUSH
23594: LD_INT 23
23596: PUSH
23597: LD_INT 24
23599: PUSH
23600: EMPTY
23601: LIST
23602: LIST
23603: ST_TO_ADDR
23604: GO 23607
23606: POP
// result := ( chassis in result ) ;
23607: LD_ADDR_VAR 0 3
23611: PUSH
23612: LD_VAR 0 1
23616: PUSH
23617: LD_VAR 0 3
23621: IN
23622: ST_TO_ADDR
// end ;
23623: LD_VAR 0 3
23627: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
23628: LD_INT 0
23630: PPUSH
23631: PPUSH
23632: PPUSH
23633: PPUSH
23634: PPUSH
23635: PPUSH
23636: PPUSH
// result := array ;
23637: LD_ADDR_VAR 0 5
23641: PUSH
23642: LD_VAR 0 1
23646: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
23647: LD_VAR 0 1
23651: NOT
23652: PUSH
23653: LD_VAR 0 2
23657: NOT
23658: OR
23659: PUSH
23660: LD_VAR 0 3
23664: NOT
23665: OR
23666: PUSH
23667: LD_VAR 0 2
23671: PUSH
23672: LD_VAR 0 1
23676: GREATER
23677: OR
23678: PUSH
23679: LD_VAR 0 3
23683: PUSH
23684: LD_VAR 0 1
23688: GREATER
23689: OR
23690: IFFALSE 23694
// exit ;
23692: GO 23990
// if direction then
23694: LD_VAR 0 4
23698: IFFALSE 23762
// begin d := 1 ;
23700: LD_ADDR_VAR 0 9
23704: PUSH
23705: LD_INT 1
23707: ST_TO_ADDR
// if i_from > i_to then
23708: LD_VAR 0 2
23712: PUSH
23713: LD_VAR 0 3
23717: GREATER
23718: IFFALSE 23744
// length := ( array - i_from ) + i_to else
23720: LD_ADDR_VAR 0 11
23724: PUSH
23725: LD_VAR 0 1
23729: PUSH
23730: LD_VAR 0 2
23734: MINUS
23735: PUSH
23736: LD_VAR 0 3
23740: PLUS
23741: ST_TO_ADDR
23742: GO 23760
// length := i_to - i_from ;
23744: LD_ADDR_VAR 0 11
23748: PUSH
23749: LD_VAR 0 3
23753: PUSH
23754: LD_VAR 0 2
23758: MINUS
23759: ST_TO_ADDR
// end else
23760: GO 23823
// begin d := - 1 ;
23762: LD_ADDR_VAR 0 9
23766: PUSH
23767: LD_INT 1
23769: NEG
23770: ST_TO_ADDR
// if i_from > i_to then
23771: LD_VAR 0 2
23775: PUSH
23776: LD_VAR 0 3
23780: GREATER
23781: IFFALSE 23801
// length := i_from - i_to else
23783: LD_ADDR_VAR 0 11
23787: PUSH
23788: LD_VAR 0 2
23792: PUSH
23793: LD_VAR 0 3
23797: MINUS
23798: ST_TO_ADDR
23799: GO 23823
// length := ( array - i_to ) + i_from ;
23801: LD_ADDR_VAR 0 11
23805: PUSH
23806: LD_VAR 0 1
23810: PUSH
23811: LD_VAR 0 3
23815: MINUS
23816: PUSH
23817: LD_VAR 0 2
23821: PLUS
23822: ST_TO_ADDR
// end ; if not length then
23823: LD_VAR 0 11
23827: NOT
23828: IFFALSE 23832
// exit ;
23830: GO 23990
// tmp := array ;
23832: LD_ADDR_VAR 0 10
23836: PUSH
23837: LD_VAR 0 1
23841: ST_TO_ADDR
// for i = 1 to length do
23842: LD_ADDR_VAR 0 6
23846: PUSH
23847: DOUBLE
23848: LD_INT 1
23850: DEC
23851: ST_TO_ADDR
23852: LD_VAR 0 11
23856: PUSH
23857: FOR_TO
23858: IFFALSE 23978
// begin for j = 1 to array do
23860: LD_ADDR_VAR 0 7
23864: PUSH
23865: DOUBLE
23866: LD_INT 1
23868: DEC
23869: ST_TO_ADDR
23870: LD_VAR 0 1
23874: PUSH
23875: FOR_TO
23876: IFFALSE 23964
// begin k := j + d ;
23878: LD_ADDR_VAR 0 8
23882: PUSH
23883: LD_VAR 0 7
23887: PUSH
23888: LD_VAR 0 9
23892: PLUS
23893: ST_TO_ADDR
// if k > array then
23894: LD_VAR 0 8
23898: PUSH
23899: LD_VAR 0 1
23903: GREATER
23904: IFFALSE 23914
// k := 1 ;
23906: LD_ADDR_VAR 0 8
23910: PUSH
23911: LD_INT 1
23913: ST_TO_ADDR
// if not k then
23914: LD_VAR 0 8
23918: NOT
23919: IFFALSE 23931
// k := array ;
23921: LD_ADDR_VAR 0 8
23925: PUSH
23926: LD_VAR 0 1
23930: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
23931: LD_ADDR_VAR 0 10
23935: PUSH
23936: LD_VAR 0 10
23940: PPUSH
23941: LD_VAR 0 8
23945: PPUSH
23946: LD_VAR 0 1
23950: PUSH
23951: LD_VAR 0 7
23955: ARRAY
23956: PPUSH
23957: CALL_OW 1
23961: ST_TO_ADDR
// end ;
23962: GO 23875
23964: POP
23965: POP
// array := tmp ;
23966: LD_ADDR_VAR 0 1
23970: PUSH
23971: LD_VAR 0 10
23975: ST_TO_ADDR
// end ;
23976: GO 23857
23978: POP
23979: POP
// result := array ;
23980: LD_ADDR_VAR 0 5
23984: PUSH
23985: LD_VAR 0 1
23989: ST_TO_ADDR
// end ;
23990: LD_VAR 0 5
23994: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
23995: LD_INT 0
23997: PPUSH
23998: PPUSH
// result := 0 ;
23999: LD_ADDR_VAR 0 3
24003: PUSH
24004: LD_INT 0
24006: ST_TO_ADDR
// if not array or not value in array then
24007: LD_VAR 0 1
24011: NOT
24012: PUSH
24013: LD_VAR 0 2
24017: PUSH
24018: LD_VAR 0 1
24022: IN
24023: NOT
24024: OR
24025: IFFALSE 24029
// exit ;
24027: GO 24083
// for i = 1 to array do
24029: LD_ADDR_VAR 0 4
24033: PUSH
24034: DOUBLE
24035: LD_INT 1
24037: DEC
24038: ST_TO_ADDR
24039: LD_VAR 0 1
24043: PUSH
24044: FOR_TO
24045: IFFALSE 24081
// if value = array [ i ] then
24047: LD_VAR 0 2
24051: PUSH
24052: LD_VAR 0 1
24056: PUSH
24057: LD_VAR 0 4
24061: ARRAY
24062: EQUAL
24063: IFFALSE 24079
// begin result := i ;
24065: LD_ADDR_VAR 0 3
24069: PUSH
24070: LD_VAR 0 4
24074: ST_TO_ADDR
// exit ;
24075: POP
24076: POP
24077: GO 24083
// end ;
24079: GO 24044
24081: POP
24082: POP
// end ;
24083: LD_VAR 0 3
24087: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
24088: LD_INT 0
24090: PPUSH
// vc_chassis := chassis ;
24091: LD_ADDR_OWVAR 37
24095: PUSH
24096: LD_VAR 0 1
24100: ST_TO_ADDR
// vc_engine := engine ;
24101: LD_ADDR_OWVAR 39
24105: PUSH
24106: LD_VAR 0 2
24110: ST_TO_ADDR
// vc_control := control ;
24111: LD_ADDR_OWVAR 38
24115: PUSH
24116: LD_VAR 0 3
24120: ST_TO_ADDR
// vc_weapon := weapon ;
24121: LD_ADDR_OWVAR 40
24125: PUSH
24126: LD_VAR 0 4
24130: ST_TO_ADDR
// vc_fuel_battery := fuel ;
24131: LD_ADDR_OWVAR 41
24135: PUSH
24136: LD_VAR 0 5
24140: ST_TO_ADDR
// end ;
24141: LD_VAR 0 6
24145: RET
// export function WantPlant ( unit ) ; var task ; begin
24146: LD_INT 0
24148: PPUSH
24149: PPUSH
// result := false ;
24150: LD_ADDR_VAR 0 2
24154: PUSH
24155: LD_INT 0
24157: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
24158: LD_ADDR_VAR 0 3
24162: PUSH
24163: LD_VAR 0 1
24167: PPUSH
24168: CALL_OW 437
24172: ST_TO_ADDR
// if task then
24173: LD_VAR 0 3
24177: IFFALSE 24205
// if task [ 1 ] [ 1 ] = p then
24179: LD_VAR 0 3
24183: PUSH
24184: LD_INT 1
24186: ARRAY
24187: PUSH
24188: LD_INT 1
24190: ARRAY
24191: PUSH
24192: LD_STRING p
24194: EQUAL
24195: IFFALSE 24205
// result := true ;
24197: LD_ADDR_VAR 0 2
24201: PUSH
24202: LD_INT 1
24204: ST_TO_ADDR
// end ;
24205: LD_VAR 0 2
24209: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
24210: LD_INT 0
24212: PPUSH
24213: PPUSH
24214: PPUSH
24215: PPUSH
// if pos < 1 then
24216: LD_VAR 0 2
24220: PUSH
24221: LD_INT 1
24223: LESS
24224: IFFALSE 24228
// exit ;
24226: GO 24531
// if pos = 1 then
24228: LD_VAR 0 2
24232: PUSH
24233: LD_INT 1
24235: EQUAL
24236: IFFALSE 24269
// result := Replace ( arr , pos [ 1 ] , value ) else
24238: LD_ADDR_VAR 0 4
24242: PUSH
24243: LD_VAR 0 1
24247: PPUSH
24248: LD_VAR 0 2
24252: PUSH
24253: LD_INT 1
24255: ARRAY
24256: PPUSH
24257: LD_VAR 0 3
24261: PPUSH
24262: CALL_OW 1
24266: ST_TO_ADDR
24267: GO 24531
// begin tmp := arr ;
24269: LD_ADDR_VAR 0 6
24273: PUSH
24274: LD_VAR 0 1
24278: ST_TO_ADDR
// s_arr := [ tmp ] ;
24279: LD_ADDR_VAR 0 7
24283: PUSH
24284: LD_VAR 0 6
24288: PUSH
24289: EMPTY
24290: LIST
24291: ST_TO_ADDR
// for i = 1 to pos - 1 do
24292: LD_ADDR_VAR 0 5
24296: PUSH
24297: DOUBLE
24298: LD_INT 1
24300: DEC
24301: ST_TO_ADDR
24302: LD_VAR 0 2
24306: PUSH
24307: LD_INT 1
24309: MINUS
24310: PUSH
24311: FOR_TO
24312: IFFALSE 24357
// begin tmp := tmp [ pos [ i ] ] ;
24314: LD_ADDR_VAR 0 6
24318: PUSH
24319: LD_VAR 0 6
24323: PUSH
24324: LD_VAR 0 2
24328: PUSH
24329: LD_VAR 0 5
24333: ARRAY
24334: ARRAY
24335: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
24336: LD_ADDR_VAR 0 7
24340: PUSH
24341: LD_VAR 0 7
24345: PUSH
24346: LD_VAR 0 6
24350: PUSH
24351: EMPTY
24352: LIST
24353: ADD
24354: ST_TO_ADDR
// end ;
24355: GO 24311
24357: POP
24358: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
24359: LD_ADDR_VAR 0 6
24363: PUSH
24364: LD_VAR 0 6
24368: PPUSH
24369: LD_VAR 0 2
24373: PUSH
24374: LD_VAR 0 2
24378: ARRAY
24379: PPUSH
24380: LD_VAR 0 3
24384: PPUSH
24385: CALL_OW 1
24389: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
24390: LD_ADDR_VAR 0 7
24394: PUSH
24395: LD_VAR 0 7
24399: PPUSH
24400: LD_VAR 0 7
24404: PPUSH
24405: LD_VAR 0 6
24409: PPUSH
24410: CALL_OW 1
24414: ST_TO_ADDR
// for i = s_arr downto 2 do
24415: LD_ADDR_VAR 0 5
24419: PUSH
24420: DOUBLE
24421: LD_VAR 0 7
24425: INC
24426: ST_TO_ADDR
24427: LD_INT 2
24429: PUSH
24430: FOR_DOWNTO
24431: IFFALSE 24515
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
24433: LD_ADDR_VAR 0 6
24437: PUSH
24438: LD_VAR 0 7
24442: PUSH
24443: LD_VAR 0 5
24447: PUSH
24448: LD_INT 1
24450: MINUS
24451: ARRAY
24452: PPUSH
24453: LD_VAR 0 2
24457: PUSH
24458: LD_VAR 0 5
24462: PUSH
24463: LD_INT 1
24465: MINUS
24466: ARRAY
24467: PPUSH
24468: LD_VAR 0 7
24472: PUSH
24473: LD_VAR 0 5
24477: ARRAY
24478: PPUSH
24479: CALL_OW 1
24483: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
24484: LD_ADDR_VAR 0 7
24488: PUSH
24489: LD_VAR 0 7
24493: PPUSH
24494: LD_VAR 0 5
24498: PUSH
24499: LD_INT 1
24501: MINUS
24502: PPUSH
24503: LD_VAR 0 6
24507: PPUSH
24508: CALL_OW 1
24512: ST_TO_ADDR
// end ;
24513: GO 24430
24515: POP
24516: POP
// result := s_arr [ 1 ] ;
24517: LD_ADDR_VAR 0 4
24521: PUSH
24522: LD_VAR 0 7
24526: PUSH
24527: LD_INT 1
24529: ARRAY
24530: ST_TO_ADDR
// end ; end ;
24531: LD_VAR 0 4
24535: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
24536: LD_INT 0
24538: PPUSH
24539: PPUSH
// if not list then
24540: LD_VAR 0 1
24544: NOT
24545: IFFALSE 24549
// exit ;
24547: GO 24640
// i := list [ pos1 ] ;
24549: LD_ADDR_VAR 0 5
24553: PUSH
24554: LD_VAR 0 1
24558: PUSH
24559: LD_VAR 0 2
24563: ARRAY
24564: ST_TO_ADDR
// if not i then
24565: LD_VAR 0 5
24569: NOT
24570: IFFALSE 24574
// exit ;
24572: GO 24640
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
24574: LD_ADDR_VAR 0 1
24578: PUSH
24579: LD_VAR 0 1
24583: PPUSH
24584: LD_VAR 0 2
24588: PPUSH
24589: LD_VAR 0 1
24593: PUSH
24594: LD_VAR 0 3
24598: ARRAY
24599: PPUSH
24600: CALL_OW 1
24604: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
24605: LD_ADDR_VAR 0 1
24609: PUSH
24610: LD_VAR 0 1
24614: PPUSH
24615: LD_VAR 0 3
24619: PPUSH
24620: LD_VAR 0 5
24624: PPUSH
24625: CALL_OW 1
24629: ST_TO_ADDR
// result := list ;
24630: LD_ADDR_VAR 0 4
24634: PUSH
24635: LD_VAR 0 1
24639: ST_TO_ADDR
// end ;
24640: LD_VAR 0 4
24644: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
24645: LD_INT 0
24647: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
24648: LD_ADDR_VAR 0 5
24652: PUSH
24653: LD_VAR 0 1
24657: PPUSH
24658: CALL_OW 250
24662: PPUSH
24663: LD_VAR 0 1
24667: PPUSH
24668: CALL_OW 251
24672: PPUSH
24673: LD_VAR 0 2
24677: PPUSH
24678: LD_VAR 0 3
24682: PPUSH
24683: LD_VAR 0 4
24687: PPUSH
24688: CALL 24698 0 5
24692: ST_TO_ADDR
// end ;
24693: LD_VAR 0 5
24697: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
24698: LD_INT 0
24700: PPUSH
24701: PPUSH
24702: PPUSH
24703: PPUSH
// if not list then
24704: LD_VAR 0 3
24708: NOT
24709: IFFALSE 24713
// exit ;
24711: GO 25101
// result := [ ] ;
24713: LD_ADDR_VAR 0 6
24717: PUSH
24718: EMPTY
24719: ST_TO_ADDR
// for i in list do
24720: LD_ADDR_VAR 0 7
24724: PUSH
24725: LD_VAR 0 3
24729: PUSH
24730: FOR_IN
24731: IFFALSE 24933
// begin tmp := GetDistUnitXY ( i , x , y ) ;
24733: LD_ADDR_VAR 0 9
24737: PUSH
24738: LD_VAR 0 7
24742: PPUSH
24743: LD_VAR 0 1
24747: PPUSH
24748: LD_VAR 0 2
24752: PPUSH
24753: CALL_OW 297
24757: ST_TO_ADDR
// if not result then
24758: LD_VAR 0 6
24762: NOT
24763: IFFALSE 24789
// result := [ [ i , tmp ] ] else
24765: LD_ADDR_VAR 0 6
24769: PUSH
24770: LD_VAR 0 7
24774: PUSH
24775: LD_VAR 0 9
24779: PUSH
24780: EMPTY
24781: LIST
24782: LIST
24783: PUSH
24784: EMPTY
24785: LIST
24786: ST_TO_ADDR
24787: GO 24931
// begin if result [ result ] [ 2 ] < tmp then
24789: LD_VAR 0 6
24793: PUSH
24794: LD_VAR 0 6
24798: ARRAY
24799: PUSH
24800: LD_INT 2
24802: ARRAY
24803: PUSH
24804: LD_VAR 0 9
24808: LESS
24809: IFFALSE 24851
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
24811: LD_ADDR_VAR 0 6
24815: PUSH
24816: LD_VAR 0 6
24820: PPUSH
24821: LD_VAR 0 6
24825: PUSH
24826: LD_INT 1
24828: PLUS
24829: PPUSH
24830: LD_VAR 0 7
24834: PUSH
24835: LD_VAR 0 9
24839: PUSH
24840: EMPTY
24841: LIST
24842: LIST
24843: PPUSH
24844: CALL_OW 2
24848: ST_TO_ADDR
24849: GO 24931
// for j = 1 to result do
24851: LD_ADDR_VAR 0 8
24855: PUSH
24856: DOUBLE
24857: LD_INT 1
24859: DEC
24860: ST_TO_ADDR
24861: LD_VAR 0 6
24865: PUSH
24866: FOR_TO
24867: IFFALSE 24929
// begin if tmp < result [ j ] [ 2 ] then
24869: LD_VAR 0 9
24873: PUSH
24874: LD_VAR 0 6
24878: PUSH
24879: LD_VAR 0 8
24883: ARRAY
24884: PUSH
24885: LD_INT 2
24887: ARRAY
24888: LESS
24889: IFFALSE 24927
// begin result := Insert ( result , j , [ i , tmp ] ) ;
24891: LD_ADDR_VAR 0 6
24895: PUSH
24896: LD_VAR 0 6
24900: PPUSH
24901: LD_VAR 0 8
24905: PPUSH
24906: LD_VAR 0 7
24910: PUSH
24911: LD_VAR 0 9
24915: PUSH
24916: EMPTY
24917: LIST
24918: LIST
24919: PPUSH
24920: CALL_OW 2
24924: ST_TO_ADDR
// break ;
24925: GO 24929
// end ; end ;
24927: GO 24866
24929: POP
24930: POP
// end ; end ;
24931: GO 24730
24933: POP
24934: POP
// if result and not asc then
24935: LD_VAR 0 6
24939: PUSH
24940: LD_VAR 0 4
24944: NOT
24945: AND
24946: IFFALSE 25021
// begin tmp := result ;
24948: LD_ADDR_VAR 0 9
24952: PUSH
24953: LD_VAR 0 6
24957: ST_TO_ADDR
// for i = tmp downto 1 do
24958: LD_ADDR_VAR 0 7
24962: PUSH
24963: DOUBLE
24964: LD_VAR 0 9
24968: INC
24969: ST_TO_ADDR
24970: LD_INT 1
24972: PUSH
24973: FOR_DOWNTO
24974: IFFALSE 25019
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
24976: LD_ADDR_VAR 0 6
24980: PUSH
24981: LD_VAR 0 6
24985: PPUSH
24986: LD_VAR 0 9
24990: PUSH
24991: LD_VAR 0 7
24995: MINUS
24996: PUSH
24997: LD_INT 1
24999: PLUS
25000: PPUSH
25001: LD_VAR 0 9
25005: PUSH
25006: LD_VAR 0 7
25010: ARRAY
25011: PPUSH
25012: CALL_OW 1
25016: ST_TO_ADDR
25017: GO 24973
25019: POP
25020: POP
// end ; tmp := [ ] ;
25021: LD_ADDR_VAR 0 9
25025: PUSH
25026: EMPTY
25027: ST_TO_ADDR
// if mode then
25028: LD_VAR 0 5
25032: IFFALSE 25101
// begin for i = 1 to result do
25034: LD_ADDR_VAR 0 7
25038: PUSH
25039: DOUBLE
25040: LD_INT 1
25042: DEC
25043: ST_TO_ADDR
25044: LD_VAR 0 6
25048: PUSH
25049: FOR_TO
25050: IFFALSE 25089
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
25052: LD_ADDR_VAR 0 9
25056: PUSH
25057: LD_VAR 0 9
25061: PPUSH
25062: LD_VAR 0 7
25066: PPUSH
25067: LD_VAR 0 6
25071: PUSH
25072: LD_VAR 0 7
25076: ARRAY
25077: PUSH
25078: LD_INT 1
25080: ARRAY
25081: PPUSH
25082: CALL_OW 1
25086: ST_TO_ADDR
25087: GO 25049
25089: POP
25090: POP
// result := tmp ;
25091: LD_ADDR_VAR 0 6
25095: PUSH
25096: LD_VAR 0 9
25100: ST_TO_ADDR
// end ; end ;
25101: LD_VAR 0 6
25105: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
25106: LD_INT 0
25108: PPUSH
25109: PPUSH
25110: PPUSH
25111: PPUSH
25112: PPUSH
25113: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
25114: LD_ADDR_VAR 0 5
25118: PUSH
25119: LD_INT 0
25121: PUSH
25122: LD_INT 0
25124: PUSH
25125: LD_INT 0
25127: PUSH
25128: EMPTY
25129: PUSH
25130: EMPTY
25131: LIST
25132: LIST
25133: LIST
25134: LIST
25135: ST_TO_ADDR
// if not x or not y then
25136: LD_VAR 0 2
25140: NOT
25141: PUSH
25142: LD_VAR 0 3
25146: NOT
25147: OR
25148: IFFALSE 25152
// exit ;
25150: GO 26804
// if not range then
25152: LD_VAR 0 4
25156: NOT
25157: IFFALSE 25167
// range := 10 ;
25159: LD_ADDR_VAR 0 4
25163: PUSH
25164: LD_INT 10
25166: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
25167: LD_ADDR_VAR 0 8
25171: PUSH
25172: LD_INT 81
25174: PUSH
25175: LD_VAR 0 1
25179: PUSH
25180: EMPTY
25181: LIST
25182: LIST
25183: PUSH
25184: LD_INT 92
25186: PUSH
25187: LD_VAR 0 2
25191: PUSH
25192: LD_VAR 0 3
25196: PUSH
25197: LD_VAR 0 4
25201: PUSH
25202: EMPTY
25203: LIST
25204: LIST
25205: LIST
25206: LIST
25207: PUSH
25208: LD_INT 3
25210: PUSH
25211: LD_INT 21
25213: PUSH
25214: LD_INT 3
25216: PUSH
25217: EMPTY
25218: LIST
25219: LIST
25220: PUSH
25221: EMPTY
25222: LIST
25223: LIST
25224: PUSH
25225: EMPTY
25226: LIST
25227: LIST
25228: LIST
25229: PPUSH
25230: CALL_OW 69
25234: ST_TO_ADDR
// if not tmp then
25235: LD_VAR 0 8
25239: NOT
25240: IFFALSE 25244
// exit ;
25242: GO 26804
// for i in tmp do
25244: LD_ADDR_VAR 0 6
25248: PUSH
25249: LD_VAR 0 8
25253: PUSH
25254: FOR_IN
25255: IFFALSE 26779
// begin points := [ 0 , 0 , 0 ] ;
25257: LD_ADDR_VAR 0 9
25261: PUSH
25262: LD_INT 0
25264: PUSH
25265: LD_INT 0
25267: PUSH
25268: LD_INT 0
25270: PUSH
25271: EMPTY
25272: LIST
25273: LIST
25274: LIST
25275: ST_TO_ADDR
// bpoints := 1 ;
25276: LD_ADDR_VAR 0 10
25280: PUSH
25281: LD_INT 1
25283: ST_TO_ADDR
// case GetType ( i ) of unit_human :
25284: LD_VAR 0 6
25288: PPUSH
25289: CALL_OW 247
25293: PUSH
25294: LD_INT 1
25296: DOUBLE
25297: EQUAL
25298: IFTRUE 25302
25300: GO 25880
25302: POP
// begin if GetClass ( i ) = 1 then
25303: LD_VAR 0 6
25307: PPUSH
25308: CALL_OW 257
25312: PUSH
25313: LD_INT 1
25315: EQUAL
25316: IFFALSE 25337
// points := [ 10 , 5 , 3 ] ;
25318: LD_ADDR_VAR 0 9
25322: PUSH
25323: LD_INT 10
25325: PUSH
25326: LD_INT 5
25328: PUSH
25329: LD_INT 3
25331: PUSH
25332: EMPTY
25333: LIST
25334: LIST
25335: LIST
25336: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
25337: LD_VAR 0 6
25341: PPUSH
25342: CALL_OW 257
25346: PUSH
25347: LD_INT 2
25349: PUSH
25350: LD_INT 3
25352: PUSH
25353: LD_INT 4
25355: PUSH
25356: EMPTY
25357: LIST
25358: LIST
25359: LIST
25360: IN
25361: IFFALSE 25382
// points := [ 3 , 2 , 1 ] ;
25363: LD_ADDR_VAR 0 9
25367: PUSH
25368: LD_INT 3
25370: PUSH
25371: LD_INT 2
25373: PUSH
25374: LD_INT 1
25376: PUSH
25377: EMPTY
25378: LIST
25379: LIST
25380: LIST
25381: ST_TO_ADDR
// if GetClass ( i ) = 5 then
25382: LD_VAR 0 6
25386: PPUSH
25387: CALL_OW 257
25391: PUSH
25392: LD_INT 5
25394: EQUAL
25395: IFFALSE 25416
// points := [ 130 , 5 , 2 ] ;
25397: LD_ADDR_VAR 0 9
25401: PUSH
25402: LD_INT 130
25404: PUSH
25405: LD_INT 5
25407: PUSH
25408: LD_INT 2
25410: PUSH
25411: EMPTY
25412: LIST
25413: LIST
25414: LIST
25415: ST_TO_ADDR
// if GetClass ( i ) = 8 then
25416: LD_VAR 0 6
25420: PPUSH
25421: CALL_OW 257
25425: PUSH
25426: LD_INT 8
25428: EQUAL
25429: IFFALSE 25450
// points := [ 35 , 35 , 30 ] ;
25431: LD_ADDR_VAR 0 9
25435: PUSH
25436: LD_INT 35
25438: PUSH
25439: LD_INT 35
25441: PUSH
25442: LD_INT 30
25444: PUSH
25445: EMPTY
25446: LIST
25447: LIST
25448: LIST
25449: ST_TO_ADDR
// if GetClass ( i ) = 9 then
25450: LD_VAR 0 6
25454: PPUSH
25455: CALL_OW 257
25459: PUSH
25460: LD_INT 9
25462: EQUAL
25463: IFFALSE 25484
// points := [ 20 , 55 , 40 ] ;
25465: LD_ADDR_VAR 0 9
25469: PUSH
25470: LD_INT 20
25472: PUSH
25473: LD_INT 55
25475: PUSH
25476: LD_INT 40
25478: PUSH
25479: EMPTY
25480: LIST
25481: LIST
25482: LIST
25483: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
25484: LD_VAR 0 6
25488: PPUSH
25489: CALL_OW 257
25493: PUSH
25494: LD_INT 12
25496: PUSH
25497: LD_INT 16
25499: PUSH
25500: EMPTY
25501: LIST
25502: LIST
25503: IN
25504: IFFALSE 25525
// points := [ 5 , 3 , 2 ] ;
25506: LD_ADDR_VAR 0 9
25510: PUSH
25511: LD_INT 5
25513: PUSH
25514: LD_INT 3
25516: PUSH
25517: LD_INT 2
25519: PUSH
25520: EMPTY
25521: LIST
25522: LIST
25523: LIST
25524: ST_TO_ADDR
// if GetClass ( i ) = 17 then
25525: LD_VAR 0 6
25529: PPUSH
25530: CALL_OW 257
25534: PUSH
25535: LD_INT 17
25537: EQUAL
25538: IFFALSE 25559
// points := [ 100 , 50 , 75 ] ;
25540: LD_ADDR_VAR 0 9
25544: PUSH
25545: LD_INT 100
25547: PUSH
25548: LD_INT 50
25550: PUSH
25551: LD_INT 75
25553: PUSH
25554: EMPTY
25555: LIST
25556: LIST
25557: LIST
25558: ST_TO_ADDR
// if GetClass ( i ) = 15 then
25559: LD_VAR 0 6
25563: PPUSH
25564: CALL_OW 257
25568: PUSH
25569: LD_INT 15
25571: EQUAL
25572: IFFALSE 25593
// points := [ 10 , 5 , 3 ] ;
25574: LD_ADDR_VAR 0 9
25578: PUSH
25579: LD_INT 10
25581: PUSH
25582: LD_INT 5
25584: PUSH
25585: LD_INT 3
25587: PUSH
25588: EMPTY
25589: LIST
25590: LIST
25591: LIST
25592: ST_TO_ADDR
// if GetClass ( i ) = 14 then
25593: LD_VAR 0 6
25597: PPUSH
25598: CALL_OW 257
25602: PUSH
25603: LD_INT 14
25605: EQUAL
25606: IFFALSE 25627
// points := [ 10 , 0 , 0 ] ;
25608: LD_ADDR_VAR 0 9
25612: PUSH
25613: LD_INT 10
25615: PUSH
25616: LD_INT 0
25618: PUSH
25619: LD_INT 0
25621: PUSH
25622: EMPTY
25623: LIST
25624: LIST
25625: LIST
25626: ST_TO_ADDR
// if GetClass ( i ) = 11 then
25627: LD_VAR 0 6
25631: PPUSH
25632: CALL_OW 257
25636: PUSH
25637: LD_INT 11
25639: EQUAL
25640: IFFALSE 25661
// points := [ 30 , 10 , 5 ] ;
25642: LD_ADDR_VAR 0 9
25646: PUSH
25647: LD_INT 30
25649: PUSH
25650: LD_INT 10
25652: PUSH
25653: LD_INT 5
25655: PUSH
25656: EMPTY
25657: LIST
25658: LIST
25659: LIST
25660: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
25661: LD_VAR 0 1
25665: PPUSH
25666: LD_INT 5
25668: PPUSH
25669: CALL_OW 321
25673: PUSH
25674: LD_INT 2
25676: EQUAL
25677: IFFALSE 25694
// bpoints := bpoints * 1.8 ;
25679: LD_ADDR_VAR 0 10
25683: PUSH
25684: LD_VAR 0 10
25688: PUSH
25689: LD_REAL  1.80000000000000E+0000
25692: MUL
25693: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
25694: LD_VAR 0 6
25698: PPUSH
25699: CALL_OW 257
25703: PUSH
25704: LD_INT 1
25706: PUSH
25707: LD_INT 2
25709: PUSH
25710: LD_INT 3
25712: PUSH
25713: LD_INT 4
25715: PUSH
25716: EMPTY
25717: LIST
25718: LIST
25719: LIST
25720: LIST
25721: IN
25722: PUSH
25723: LD_VAR 0 1
25727: PPUSH
25728: LD_INT 51
25730: PPUSH
25731: CALL_OW 321
25735: PUSH
25736: LD_INT 2
25738: EQUAL
25739: AND
25740: IFFALSE 25757
// bpoints := bpoints * 1.2 ;
25742: LD_ADDR_VAR 0 10
25746: PUSH
25747: LD_VAR 0 10
25751: PUSH
25752: LD_REAL  1.20000000000000E+0000
25755: MUL
25756: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
25757: LD_VAR 0 6
25761: PPUSH
25762: CALL_OW 257
25766: PUSH
25767: LD_INT 5
25769: PUSH
25770: LD_INT 7
25772: PUSH
25773: LD_INT 9
25775: PUSH
25776: EMPTY
25777: LIST
25778: LIST
25779: LIST
25780: IN
25781: PUSH
25782: LD_VAR 0 1
25786: PPUSH
25787: LD_INT 52
25789: PPUSH
25790: CALL_OW 321
25794: PUSH
25795: LD_INT 2
25797: EQUAL
25798: AND
25799: IFFALSE 25816
// bpoints := bpoints * 1.5 ;
25801: LD_ADDR_VAR 0 10
25805: PUSH
25806: LD_VAR 0 10
25810: PUSH
25811: LD_REAL  1.50000000000000E+0000
25814: MUL
25815: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
25816: LD_VAR 0 1
25820: PPUSH
25821: LD_INT 66
25823: PPUSH
25824: CALL_OW 321
25828: PUSH
25829: LD_INT 2
25831: EQUAL
25832: IFFALSE 25849
// bpoints := bpoints * 1.1 ;
25834: LD_ADDR_VAR 0 10
25838: PUSH
25839: LD_VAR 0 10
25843: PUSH
25844: LD_REAL  1.10000000000000E+0000
25847: MUL
25848: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
25849: LD_ADDR_VAR 0 10
25853: PUSH
25854: LD_VAR 0 10
25858: PUSH
25859: LD_VAR 0 6
25863: PPUSH
25864: LD_INT 1
25866: PPUSH
25867: CALL_OW 259
25871: PUSH
25872: LD_REAL  1.15000000000000E+0000
25875: MUL
25876: MUL
25877: ST_TO_ADDR
// end ; unit_vehicle :
25878: GO 26708
25880: LD_INT 2
25882: DOUBLE
25883: EQUAL
25884: IFTRUE 25888
25886: GO 26696
25888: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
25889: LD_VAR 0 6
25893: PPUSH
25894: CALL_OW 264
25898: PUSH
25899: LD_INT 2
25901: PUSH
25902: LD_INT 42
25904: PUSH
25905: LD_INT 24
25907: PUSH
25908: EMPTY
25909: LIST
25910: LIST
25911: LIST
25912: IN
25913: IFFALSE 25934
// points := [ 25 , 5 , 3 ] ;
25915: LD_ADDR_VAR 0 9
25919: PUSH
25920: LD_INT 25
25922: PUSH
25923: LD_INT 5
25925: PUSH
25926: LD_INT 3
25928: PUSH
25929: EMPTY
25930: LIST
25931: LIST
25932: LIST
25933: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
25934: LD_VAR 0 6
25938: PPUSH
25939: CALL_OW 264
25943: PUSH
25944: LD_INT 4
25946: PUSH
25947: LD_INT 43
25949: PUSH
25950: LD_INT 25
25952: PUSH
25953: EMPTY
25954: LIST
25955: LIST
25956: LIST
25957: IN
25958: IFFALSE 25979
// points := [ 40 , 15 , 5 ] ;
25960: LD_ADDR_VAR 0 9
25964: PUSH
25965: LD_INT 40
25967: PUSH
25968: LD_INT 15
25970: PUSH
25971: LD_INT 5
25973: PUSH
25974: EMPTY
25975: LIST
25976: LIST
25977: LIST
25978: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
25979: LD_VAR 0 6
25983: PPUSH
25984: CALL_OW 264
25988: PUSH
25989: LD_INT 3
25991: PUSH
25992: LD_INT 23
25994: PUSH
25995: EMPTY
25996: LIST
25997: LIST
25998: IN
25999: IFFALSE 26020
// points := [ 7 , 25 , 8 ] ;
26001: LD_ADDR_VAR 0 9
26005: PUSH
26006: LD_INT 7
26008: PUSH
26009: LD_INT 25
26011: PUSH
26012: LD_INT 8
26014: PUSH
26015: EMPTY
26016: LIST
26017: LIST
26018: LIST
26019: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
26020: LD_VAR 0 6
26024: PPUSH
26025: CALL_OW 264
26029: PUSH
26030: LD_INT 5
26032: PUSH
26033: LD_INT 27
26035: PUSH
26036: LD_INT 44
26038: PUSH
26039: EMPTY
26040: LIST
26041: LIST
26042: LIST
26043: IN
26044: IFFALSE 26065
// points := [ 14 , 50 , 16 ] ;
26046: LD_ADDR_VAR 0 9
26050: PUSH
26051: LD_INT 14
26053: PUSH
26054: LD_INT 50
26056: PUSH
26057: LD_INT 16
26059: PUSH
26060: EMPTY
26061: LIST
26062: LIST
26063: LIST
26064: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
26065: LD_VAR 0 6
26069: PPUSH
26070: CALL_OW 264
26074: PUSH
26075: LD_INT 6
26077: PUSH
26078: LD_INT 46
26080: PUSH
26081: EMPTY
26082: LIST
26083: LIST
26084: IN
26085: IFFALSE 26106
// points := [ 32 , 120 , 70 ] ;
26087: LD_ADDR_VAR 0 9
26091: PUSH
26092: LD_INT 32
26094: PUSH
26095: LD_INT 120
26097: PUSH
26098: LD_INT 70
26100: PUSH
26101: EMPTY
26102: LIST
26103: LIST
26104: LIST
26105: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
26106: LD_VAR 0 6
26110: PPUSH
26111: CALL_OW 264
26115: PUSH
26116: LD_INT 7
26118: PUSH
26119: LD_INT 28
26121: PUSH
26122: LD_INT 45
26124: PUSH
26125: LD_EXP 162
26129: PUSH
26130: EMPTY
26131: LIST
26132: LIST
26133: LIST
26134: LIST
26135: IN
26136: IFFALSE 26157
// points := [ 35 , 20 , 45 ] ;
26138: LD_ADDR_VAR 0 9
26142: PUSH
26143: LD_INT 35
26145: PUSH
26146: LD_INT 20
26148: PUSH
26149: LD_INT 45
26151: PUSH
26152: EMPTY
26153: LIST
26154: LIST
26155: LIST
26156: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
26157: LD_VAR 0 6
26161: PPUSH
26162: CALL_OW 264
26166: PUSH
26167: LD_INT 47
26169: PUSH
26170: EMPTY
26171: LIST
26172: IN
26173: IFFALSE 26194
// points := [ 67 , 45 , 75 ] ;
26175: LD_ADDR_VAR 0 9
26179: PUSH
26180: LD_INT 67
26182: PUSH
26183: LD_INT 45
26185: PUSH
26186: LD_INT 75
26188: PUSH
26189: EMPTY
26190: LIST
26191: LIST
26192: LIST
26193: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
26194: LD_VAR 0 6
26198: PPUSH
26199: CALL_OW 264
26203: PUSH
26204: LD_INT 26
26206: PUSH
26207: EMPTY
26208: LIST
26209: IN
26210: IFFALSE 26231
// points := [ 120 , 30 , 80 ] ;
26212: LD_ADDR_VAR 0 9
26216: PUSH
26217: LD_INT 120
26219: PUSH
26220: LD_INT 30
26222: PUSH
26223: LD_INT 80
26225: PUSH
26226: EMPTY
26227: LIST
26228: LIST
26229: LIST
26230: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
26231: LD_VAR 0 6
26235: PPUSH
26236: CALL_OW 264
26240: PUSH
26241: LD_INT 22
26243: PUSH
26244: EMPTY
26245: LIST
26246: IN
26247: IFFALSE 26268
// points := [ 40 , 1 , 1 ] ;
26249: LD_ADDR_VAR 0 9
26253: PUSH
26254: LD_INT 40
26256: PUSH
26257: LD_INT 1
26259: PUSH
26260: LD_INT 1
26262: PUSH
26263: EMPTY
26264: LIST
26265: LIST
26266: LIST
26267: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
26268: LD_VAR 0 6
26272: PPUSH
26273: CALL_OW 264
26277: PUSH
26278: LD_INT 29
26280: PUSH
26281: EMPTY
26282: LIST
26283: IN
26284: IFFALSE 26305
// points := [ 70 , 200 , 400 ] ;
26286: LD_ADDR_VAR 0 9
26290: PUSH
26291: LD_INT 70
26293: PUSH
26294: LD_INT 200
26296: PUSH
26297: LD_INT 400
26299: PUSH
26300: EMPTY
26301: LIST
26302: LIST
26303: LIST
26304: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
26305: LD_VAR 0 6
26309: PPUSH
26310: CALL_OW 264
26314: PUSH
26315: LD_INT 14
26317: PUSH
26318: LD_INT 53
26320: PUSH
26321: EMPTY
26322: LIST
26323: LIST
26324: IN
26325: IFFALSE 26346
// points := [ 40 , 10 , 20 ] ;
26327: LD_ADDR_VAR 0 9
26331: PUSH
26332: LD_INT 40
26334: PUSH
26335: LD_INT 10
26337: PUSH
26338: LD_INT 20
26340: PUSH
26341: EMPTY
26342: LIST
26343: LIST
26344: LIST
26345: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
26346: LD_VAR 0 6
26350: PPUSH
26351: CALL_OW 264
26355: PUSH
26356: LD_INT 9
26358: PUSH
26359: EMPTY
26360: LIST
26361: IN
26362: IFFALSE 26383
// points := [ 5 , 70 , 20 ] ;
26364: LD_ADDR_VAR 0 9
26368: PUSH
26369: LD_INT 5
26371: PUSH
26372: LD_INT 70
26374: PUSH
26375: LD_INT 20
26377: PUSH
26378: EMPTY
26379: LIST
26380: LIST
26381: LIST
26382: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
26383: LD_VAR 0 6
26387: PPUSH
26388: CALL_OW 264
26392: PUSH
26393: LD_INT 10
26395: PUSH
26396: EMPTY
26397: LIST
26398: IN
26399: IFFALSE 26420
// points := [ 35 , 110 , 70 ] ;
26401: LD_ADDR_VAR 0 9
26405: PUSH
26406: LD_INT 35
26408: PUSH
26409: LD_INT 110
26411: PUSH
26412: LD_INT 70
26414: PUSH
26415: EMPTY
26416: LIST
26417: LIST
26418: LIST
26419: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
26420: LD_VAR 0 6
26424: PPUSH
26425: CALL_OW 265
26429: PUSH
26430: LD_INT 25
26432: EQUAL
26433: IFFALSE 26454
// points := [ 80 , 65 , 100 ] ;
26435: LD_ADDR_VAR 0 9
26439: PUSH
26440: LD_INT 80
26442: PUSH
26443: LD_INT 65
26445: PUSH
26446: LD_INT 100
26448: PUSH
26449: EMPTY
26450: LIST
26451: LIST
26452: LIST
26453: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
26454: LD_VAR 0 6
26458: PPUSH
26459: CALL_OW 263
26463: PUSH
26464: LD_INT 1
26466: EQUAL
26467: IFFALSE 26502
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
26469: LD_ADDR_VAR 0 10
26473: PUSH
26474: LD_VAR 0 10
26478: PUSH
26479: LD_VAR 0 6
26483: PPUSH
26484: CALL_OW 311
26488: PPUSH
26489: LD_INT 3
26491: PPUSH
26492: CALL_OW 259
26496: PUSH
26497: LD_INT 4
26499: MUL
26500: MUL
26501: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
26502: LD_VAR 0 6
26506: PPUSH
26507: CALL_OW 263
26511: PUSH
26512: LD_INT 2
26514: EQUAL
26515: IFFALSE 26566
// begin j := IsControledBy ( i ) ;
26517: LD_ADDR_VAR 0 7
26521: PUSH
26522: LD_VAR 0 6
26526: PPUSH
26527: CALL_OW 312
26531: ST_TO_ADDR
// if j then
26532: LD_VAR 0 7
26536: IFFALSE 26566
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
26538: LD_ADDR_VAR 0 10
26542: PUSH
26543: LD_VAR 0 10
26547: PUSH
26548: LD_VAR 0 7
26552: PPUSH
26553: LD_INT 3
26555: PPUSH
26556: CALL_OW 259
26560: PUSH
26561: LD_INT 3
26563: MUL
26564: MUL
26565: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
26566: LD_VAR 0 6
26570: PPUSH
26571: CALL_OW 264
26575: PUSH
26576: LD_INT 5
26578: PUSH
26579: LD_INT 6
26581: PUSH
26582: LD_INT 46
26584: PUSH
26585: LD_INT 44
26587: PUSH
26588: LD_INT 47
26590: PUSH
26591: LD_INT 45
26593: PUSH
26594: LD_INT 28
26596: PUSH
26597: LD_INT 7
26599: PUSH
26600: LD_INT 27
26602: PUSH
26603: LD_INT 29
26605: PUSH
26606: EMPTY
26607: LIST
26608: LIST
26609: LIST
26610: LIST
26611: LIST
26612: LIST
26613: LIST
26614: LIST
26615: LIST
26616: LIST
26617: IN
26618: PUSH
26619: LD_VAR 0 1
26623: PPUSH
26624: LD_INT 52
26626: PPUSH
26627: CALL_OW 321
26631: PUSH
26632: LD_INT 2
26634: EQUAL
26635: AND
26636: IFFALSE 26653
// bpoints := bpoints * 1.2 ;
26638: LD_ADDR_VAR 0 10
26642: PUSH
26643: LD_VAR 0 10
26647: PUSH
26648: LD_REAL  1.20000000000000E+0000
26651: MUL
26652: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
26653: LD_VAR 0 6
26657: PPUSH
26658: CALL_OW 264
26662: PUSH
26663: LD_INT 6
26665: PUSH
26666: LD_INT 46
26668: PUSH
26669: LD_INT 47
26671: PUSH
26672: EMPTY
26673: LIST
26674: LIST
26675: LIST
26676: IN
26677: IFFALSE 26694
// bpoints := bpoints * 1.2 ;
26679: LD_ADDR_VAR 0 10
26683: PUSH
26684: LD_VAR 0 10
26688: PUSH
26689: LD_REAL  1.20000000000000E+0000
26692: MUL
26693: ST_TO_ADDR
// end ; unit_building :
26694: GO 26708
26696: LD_INT 3
26698: DOUBLE
26699: EQUAL
26700: IFTRUE 26704
26702: GO 26707
26704: POP
// ; end ;
26705: GO 26708
26707: POP
// for j = 1 to 3 do
26708: LD_ADDR_VAR 0 7
26712: PUSH
26713: DOUBLE
26714: LD_INT 1
26716: DEC
26717: ST_TO_ADDR
26718: LD_INT 3
26720: PUSH
26721: FOR_TO
26722: IFFALSE 26775
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
26724: LD_ADDR_VAR 0 5
26728: PUSH
26729: LD_VAR 0 5
26733: PPUSH
26734: LD_VAR 0 7
26738: PPUSH
26739: LD_VAR 0 5
26743: PUSH
26744: LD_VAR 0 7
26748: ARRAY
26749: PUSH
26750: LD_VAR 0 9
26754: PUSH
26755: LD_VAR 0 7
26759: ARRAY
26760: PUSH
26761: LD_VAR 0 10
26765: MUL
26766: PLUS
26767: PPUSH
26768: CALL_OW 1
26772: ST_TO_ADDR
26773: GO 26721
26775: POP
26776: POP
// end ;
26777: GO 25254
26779: POP
26780: POP
// result := Replace ( result , 4 , tmp ) ;
26781: LD_ADDR_VAR 0 5
26785: PUSH
26786: LD_VAR 0 5
26790: PPUSH
26791: LD_INT 4
26793: PPUSH
26794: LD_VAR 0 8
26798: PPUSH
26799: CALL_OW 1
26803: ST_TO_ADDR
// end ;
26804: LD_VAR 0 5
26808: RET
// export function DangerAtRange ( unit , range ) ; begin
26809: LD_INT 0
26811: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
26812: LD_ADDR_VAR 0 3
26816: PUSH
26817: LD_VAR 0 1
26821: PPUSH
26822: CALL_OW 255
26826: PPUSH
26827: LD_VAR 0 1
26831: PPUSH
26832: CALL_OW 250
26836: PPUSH
26837: LD_VAR 0 1
26841: PPUSH
26842: CALL_OW 251
26846: PPUSH
26847: LD_VAR 0 2
26851: PPUSH
26852: CALL 25106 0 4
26856: ST_TO_ADDR
// end ;
26857: LD_VAR 0 3
26861: RET
// export function DangerInArea ( side , area ) ; begin
26862: LD_INT 0
26864: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
26865: LD_ADDR_VAR 0 3
26869: PUSH
26870: LD_VAR 0 2
26874: PPUSH
26875: LD_INT 81
26877: PUSH
26878: LD_VAR 0 1
26882: PUSH
26883: EMPTY
26884: LIST
26885: LIST
26886: PPUSH
26887: CALL_OW 70
26891: ST_TO_ADDR
// end ;
26892: LD_VAR 0 3
26896: RET
// export function IsExtension ( b ) ; begin
26897: LD_INT 0
26899: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
26900: LD_ADDR_VAR 0 2
26904: PUSH
26905: LD_VAR 0 1
26909: PUSH
26910: LD_INT 23
26912: PUSH
26913: LD_INT 20
26915: PUSH
26916: LD_INT 22
26918: PUSH
26919: LD_INT 17
26921: PUSH
26922: LD_INT 24
26924: PUSH
26925: LD_INT 21
26927: PUSH
26928: LD_INT 19
26930: PUSH
26931: LD_INT 16
26933: PUSH
26934: LD_INT 25
26936: PUSH
26937: LD_INT 18
26939: PUSH
26940: EMPTY
26941: LIST
26942: LIST
26943: LIST
26944: LIST
26945: LIST
26946: LIST
26947: LIST
26948: LIST
26949: LIST
26950: LIST
26951: IN
26952: ST_TO_ADDR
// end ;
26953: LD_VAR 0 2
26957: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
26958: LD_INT 0
26960: PPUSH
26961: PPUSH
26962: PPUSH
// result := [ ] ;
26963: LD_ADDR_VAR 0 4
26967: PUSH
26968: EMPTY
26969: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
26970: LD_ADDR_VAR 0 5
26974: PUSH
26975: LD_VAR 0 2
26979: PPUSH
26980: LD_INT 21
26982: PUSH
26983: LD_INT 3
26985: PUSH
26986: EMPTY
26987: LIST
26988: LIST
26989: PPUSH
26990: CALL_OW 70
26994: ST_TO_ADDR
// if not tmp then
26995: LD_VAR 0 5
26999: NOT
27000: IFFALSE 27004
// exit ;
27002: GO 27068
// if checkLink then
27004: LD_VAR 0 3
27008: IFFALSE 27058
// begin for i in tmp do
27010: LD_ADDR_VAR 0 6
27014: PUSH
27015: LD_VAR 0 5
27019: PUSH
27020: FOR_IN
27021: IFFALSE 27056
// if GetBase ( i ) <> base then
27023: LD_VAR 0 6
27027: PPUSH
27028: CALL_OW 274
27032: PUSH
27033: LD_VAR 0 1
27037: NONEQUAL
27038: IFFALSE 27054
// ComLinkToBase ( base , i ) ;
27040: LD_VAR 0 1
27044: PPUSH
27045: LD_VAR 0 6
27049: PPUSH
27050: CALL_OW 169
27054: GO 27020
27056: POP
27057: POP
// end ; result := tmp ;
27058: LD_ADDR_VAR 0 4
27062: PUSH
27063: LD_VAR 0 5
27067: ST_TO_ADDR
// end ;
27068: LD_VAR 0 4
27072: RET
// export function ComComplete ( units , b ) ; var i ; begin
27073: LD_INT 0
27075: PPUSH
27076: PPUSH
// if not units then
27077: LD_VAR 0 1
27081: NOT
27082: IFFALSE 27086
// exit ;
27084: GO 27176
// for i in units do
27086: LD_ADDR_VAR 0 4
27090: PUSH
27091: LD_VAR 0 1
27095: PUSH
27096: FOR_IN
27097: IFFALSE 27174
// if BuildingStatus ( b ) = bs_build then
27099: LD_VAR 0 2
27103: PPUSH
27104: CALL_OW 461
27108: PUSH
27109: LD_INT 1
27111: EQUAL
27112: IFFALSE 27172
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
27114: LD_VAR 0 4
27118: PPUSH
27119: LD_STRING h
27121: PUSH
27122: LD_VAR 0 2
27126: PPUSH
27127: CALL_OW 250
27131: PUSH
27132: LD_VAR 0 2
27136: PPUSH
27137: CALL_OW 251
27141: PUSH
27142: LD_VAR 0 2
27146: PUSH
27147: LD_INT 0
27149: PUSH
27150: LD_INT 0
27152: PUSH
27153: LD_INT 0
27155: PUSH
27156: EMPTY
27157: LIST
27158: LIST
27159: LIST
27160: LIST
27161: LIST
27162: LIST
27163: LIST
27164: PUSH
27165: EMPTY
27166: LIST
27167: PPUSH
27168: CALL_OW 446
27172: GO 27096
27174: POP
27175: POP
// end ;
27176: LD_VAR 0 3
27180: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
27181: LD_INT 0
27183: PPUSH
27184: PPUSH
27185: PPUSH
27186: PPUSH
27187: PPUSH
27188: PPUSH
// if not vehicle or GetControl ( vehicle ) <> control_remote then
27189: LD_VAR 0 1
27193: NOT
27194: PUSH
27195: LD_VAR 0 1
27199: PPUSH
27200: CALL_OW 263
27204: PUSH
27205: LD_INT 2
27207: NONEQUAL
27208: OR
27209: IFFALSE 27213
// exit ;
27211: GO 27529
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
27213: LD_ADDR_VAR 0 6
27217: PUSH
27218: LD_INT 22
27220: PUSH
27221: LD_VAR 0 1
27225: PPUSH
27226: CALL_OW 255
27230: PUSH
27231: EMPTY
27232: LIST
27233: LIST
27234: PUSH
27235: LD_INT 2
27237: PUSH
27238: LD_INT 30
27240: PUSH
27241: LD_INT 36
27243: PUSH
27244: EMPTY
27245: LIST
27246: LIST
27247: PUSH
27248: LD_INT 34
27250: PUSH
27251: LD_INT 31
27253: PUSH
27254: EMPTY
27255: LIST
27256: LIST
27257: PUSH
27258: EMPTY
27259: LIST
27260: LIST
27261: LIST
27262: PUSH
27263: EMPTY
27264: LIST
27265: LIST
27266: PPUSH
27267: CALL_OW 69
27271: ST_TO_ADDR
// if not tmp then
27272: LD_VAR 0 6
27276: NOT
27277: IFFALSE 27281
// exit ;
27279: GO 27529
// result := [ ] ;
27281: LD_ADDR_VAR 0 2
27285: PUSH
27286: EMPTY
27287: ST_TO_ADDR
// for i in tmp do
27288: LD_ADDR_VAR 0 3
27292: PUSH
27293: LD_VAR 0 6
27297: PUSH
27298: FOR_IN
27299: IFFALSE 27370
// begin t := UnitsInside ( i ) ;
27301: LD_ADDR_VAR 0 4
27305: PUSH
27306: LD_VAR 0 3
27310: PPUSH
27311: CALL_OW 313
27315: ST_TO_ADDR
// if t then
27316: LD_VAR 0 4
27320: IFFALSE 27368
// for j in t do
27322: LD_ADDR_VAR 0 7
27326: PUSH
27327: LD_VAR 0 4
27331: PUSH
27332: FOR_IN
27333: IFFALSE 27366
// result := Replace ( result , result + 1 , j ) ;
27335: LD_ADDR_VAR 0 2
27339: PUSH
27340: LD_VAR 0 2
27344: PPUSH
27345: LD_VAR 0 2
27349: PUSH
27350: LD_INT 1
27352: PLUS
27353: PPUSH
27354: LD_VAR 0 7
27358: PPUSH
27359: CALL_OW 1
27363: ST_TO_ADDR
27364: GO 27332
27366: POP
27367: POP
// end ;
27368: GO 27298
27370: POP
27371: POP
// if not result then
27372: LD_VAR 0 2
27376: NOT
27377: IFFALSE 27381
// exit ;
27379: GO 27529
// mech := result [ 1 ] ;
27381: LD_ADDR_VAR 0 5
27385: PUSH
27386: LD_VAR 0 2
27390: PUSH
27391: LD_INT 1
27393: ARRAY
27394: ST_TO_ADDR
// if result > 1 then
27395: LD_VAR 0 2
27399: PUSH
27400: LD_INT 1
27402: GREATER
27403: IFFALSE 27515
// begin for i = 2 to result do
27405: LD_ADDR_VAR 0 3
27409: PUSH
27410: DOUBLE
27411: LD_INT 2
27413: DEC
27414: ST_TO_ADDR
27415: LD_VAR 0 2
27419: PUSH
27420: FOR_TO
27421: IFFALSE 27513
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
27423: LD_ADDR_VAR 0 4
27427: PUSH
27428: LD_VAR 0 2
27432: PUSH
27433: LD_VAR 0 3
27437: ARRAY
27438: PPUSH
27439: LD_INT 3
27441: PPUSH
27442: CALL_OW 259
27446: PUSH
27447: LD_VAR 0 2
27451: PUSH
27452: LD_VAR 0 3
27456: ARRAY
27457: PPUSH
27458: CALL_OW 432
27462: MINUS
27463: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
27464: LD_VAR 0 4
27468: PUSH
27469: LD_VAR 0 5
27473: PPUSH
27474: LD_INT 3
27476: PPUSH
27477: CALL_OW 259
27481: PUSH
27482: LD_VAR 0 5
27486: PPUSH
27487: CALL_OW 432
27491: MINUS
27492: GREATEREQUAL
27493: IFFALSE 27511
// mech := result [ i ] ;
27495: LD_ADDR_VAR 0 5
27499: PUSH
27500: LD_VAR 0 2
27504: PUSH
27505: LD_VAR 0 3
27509: ARRAY
27510: ST_TO_ADDR
// end ;
27511: GO 27420
27513: POP
27514: POP
// end ; ComLinkTo ( vehicle , mech ) ;
27515: LD_VAR 0 1
27519: PPUSH
27520: LD_VAR 0 5
27524: PPUSH
27525: CALL_OW 135
// end ;
27529: LD_VAR 0 2
27533: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
27534: LD_INT 0
27536: PPUSH
27537: PPUSH
27538: PPUSH
27539: PPUSH
27540: PPUSH
27541: PPUSH
27542: PPUSH
27543: PPUSH
27544: PPUSH
27545: PPUSH
27546: PPUSH
27547: PPUSH
27548: PPUSH
// result := [ ] ;
27549: LD_ADDR_VAR 0 7
27553: PUSH
27554: EMPTY
27555: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
27556: LD_VAR 0 1
27560: PPUSH
27561: CALL_OW 266
27565: PUSH
27566: LD_INT 0
27568: PUSH
27569: LD_INT 1
27571: PUSH
27572: EMPTY
27573: LIST
27574: LIST
27575: IN
27576: NOT
27577: IFFALSE 27581
// exit ;
27579: GO 29215
// if name then
27581: LD_VAR 0 3
27585: IFFALSE 27601
// SetBName ( base_dep , name ) ;
27587: LD_VAR 0 1
27591: PPUSH
27592: LD_VAR 0 3
27596: PPUSH
27597: CALL_OW 500
// base := GetBase ( base_dep ) ;
27601: LD_ADDR_VAR 0 15
27605: PUSH
27606: LD_VAR 0 1
27610: PPUSH
27611: CALL_OW 274
27615: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
27616: LD_ADDR_VAR 0 16
27620: PUSH
27621: LD_VAR 0 1
27625: PPUSH
27626: CALL_OW 255
27630: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
27631: LD_ADDR_VAR 0 17
27635: PUSH
27636: LD_VAR 0 1
27640: PPUSH
27641: CALL_OW 248
27645: ST_TO_ADDR
// if sources then
27646: LD_VAR 0 5
27650: IFFALSE 27697
// for i = 1 to 3 do
27652: LD_ADDR_VAR 0 8
27656: PUSH
27657: DOUBLE
27658: LD_INT 1
27660: DEC
27661: ST_TO_ADDR
27662: LD_INT 3
27664: PUSH
27665: FOR_TO
27666: IFFALSE 27695
// AddResourceType ( base , i , sources [ i ] ) ;
27668: LD_VAR 0 15
27672: PPUSH
27673: LD_VAR 0 8
27677: PPUSH
27678: LD_VAR 0 5
27682: PUSH
27683: LD_VAR 0 8
27687: ARRAY
27688: PPUSH
27689: CALL_OW 276
27693: GO 27665
27695: POP
27696: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
27697: LD_ADDR_VAR 0 18
27701: PUSH
27702: LD_VAR 0 15
27706: PPUSH
27707: LD_VAR 0 2
27711: PPUSH
27712: LD_INT 1
27714: PPUSH
27715: CALL 26958 0 3
27719: ST_TO_ADDR
// InitHc ;
27720: CALL_OW 19
// InitUc ;
27724: CALL_OW 18
// uc_side := side ;
27728: LD_ADDR_OWVAR 20
27732: PUSH
27733: LD_VAR 0 16
27737: ST_TO_ADDR
// uc_nation := nation ;
27738: LD_ADDR_OWVAR 21
27742: PUSH
27743: LD_VAR 0 17
27747: ST_TO_ADDR
// if buildings then
27748: LD_VAR 0 18
27752: IFFALSE 29074
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
27754: LD_ADDR_VAR 0 19
27758: PUSH
27759: LD_VAR 0 18
27763: PPUSH
27764: LD_INT 2
27766: PUSH
27767: LD_INT 30
27769: PUSH
27770: LD_INT 29
27772: PUSH
27773: EMPTY
27774: LIST
27775: LIST
27776: PUSH
27777: LD_INT 30
27779: PUSH
27780: LD_INT 30
27782: PUSH
27783: EMPTY
27784: LIST
27785: LIST
27786: PUSH
27787: EMPTY
27788: LIST
27789: LIST
27790: LIST
27791: PPUSH
27792: CALL_OW 72
27796: ST_TO_ADDR
// if tmp then
27797: LD_VAR 0 19
27801: IFFALSE 27849
// for i in tmp do
27803: LD_ADDR_VAR 0 8
27807: PUSH
27808: LD_VAR 0 19
27812: PUSH
27813: FOR_IN
27814: IFFALSE 27847
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
27816: LD_VAR 0 8
27820: PPUSH
27821: CALL_OW 250
27825: PPUSH
27826: LD_VAR 0 8
27830: PPUSH
27831: CALL_OW 251
27835: PPUSH
27836: LD_VAR 0 16
27840: PPUSH
27841: CALL_OW 441
27845: GO 27813
27847: POP
27848: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
27849: LD_VAR 0 18
27853: PPUSH
27854: LD_INT 2
27856: PUSH
27857: LD_INT 30
27859: PUSH
27860: LD_INT 32
27862: PUSH
27863: EMPTY
27864: LIST
27865: LIST
27866: PUSH
27867: LD_INT 30
27869: PUSH
27870: LD_INT 33
27872: PUSH
27873: EMPTY
27874: LIST
27875: LIST
27876: PUSH
27877: EMPTY
27878: LIST
27879: LIST
27880: LIST
27881: PPUSH
27882: CALL_OW 72
27886: IFFALSE 27974
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
27888: LD_ADDR_VAR 0 8
27892: PUSH
27893: LD_VAR 0 18
27897: PPUSH
27898: LD_INT 2
27900: PUSH
27901: LD_INT 30
27903: PUSH
27904: LD_INT 32
27906: PUSH
27907: EMPTY
27908: LIST
27909: LIST
27910: PUSH
27911: LD_INT 30
27913: PUSH
27914: LD_INT 33
27916: PUSH
27917: EMPTY
27918: LIST
27919: LIST
27920: PUSH
27921: EMPTY
27922: LIST
27923: LIST
27924: LIST
27925: PPUSH
27926: CALL_OW 72
27930: PUSH
27931: FOR_IN
27932: IFFALSE 27972
// begin if not GetBWeapon ( i ) then
27934: LD_VAR 0 8
27938: PPUSH
27939: CALL_OW 269
27943: NOT
27944: IFFALSE 27970
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
27946: LD_VAR 0 8
27950: PPUSH
27951: LD_VAR 0 8
27955: PPUSH
27956: LD_VAR 0 2
27960: PPUSH
27961: CALL 29220 0 2
27965: PPUSH
27966: CALL_OW 431
// end ;
27970: GO 27931
27972: POP
27973: POP
// end ; for i = 1 to personel do
27974: LD_ADDR_VAR 0 8
27978: PUSH
27979: DOUBLE
27980: LD_INT 1
27982: DEC
27983: ST_TO_ADDR
27984: LD_VAR 0 6
27988: PUSH
27989: FOR_TO
27990: IFFALSE 29054
// begin if i > 4 then
27992: LD_VAR 0 8
27996: PUSH
27997: LD_INT 4
27999: GREATER
28000: IFFALSE 28004
// break ;
28002: GO 29054
// case i of 1 :
28004: LD_VAR 0 8
28008: PUSH
28009: LD_INT 1
28011: DOUBLE
28012: EQUAL
28013: IFTRUE 28017
28015: GO 28097
28017: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
28018: LD_ADDR_VAR 0 12
28022: PUSH
28023: LD_VAR 0 18
28027: PPUSH
28028: LD_INT 22
28030: PUSH
28031: LD_VAR 0 16
28035: PUSH
28036: EMPTY
28037: LIST
28038: LIST
28039: PUSH
28040: LD_INT 58
28042: PUSH
28043: EMPTY
28044: LIST
28045: PUSH
28046: LD_INT 2
28048: PUSH
28049: LD_INT 30
28051: PUSH
28052: LD_INT 32
28054: PUSH
28055: EMPTY
28056: LIST
28057: LIST
28058: PUSH
28059: LD_INT 30
28061: PUSH
28062: LD_INT 4
28064: PUSH
28065: EMPTY
28066: LIST
28067: LIST
28068: PUSH
28069: LD_INT 30
28071: PUSH
28072: LD_INT 5
28074: PUSH
28075: EMPTY
28076: LIST
28077: LIST
28078: PUSH
28079: EMPTY
28080: LIST
28081: LIST
28082: LIST
28083: LIST
28084: PUSH
28085: EMPTY
28086: LIST
28087: LIST
28088: LIST
28089: PPUSH
28090: CALL_OW 72
28094: ST_TO_ADDR
28095: GO 28319
28097: LD_INT 2
28099: DOUBLE
28100: EQUAL
28101: IFTRUE 28105
28103: GO 28167
28105: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
28106: LD_ADDR_VAR 0 12
28110: PUSH
28111: LD_VAR 0 18
28115: PPUSH
28116: LD_INT 22
28118: PUSH
28119: LD_VAR 0 16
28123: PUSH
28124: EMPTY
28125: LIST
28126: LIST
28127: PUSH
28128: LD_INT 2
28130: PUSH
28131: LD_INT 30
28133: PUSH
28134: LD_INT 0
28136: PUSH
28137: EMPTY
28138: LIST
28139: LIST
28140: PUSH
28141: LD_INT 30
28143: PUSH
28144: LD_INT 1
28146: PUSH
28147: EMPTY
28148: LIST
28149: LIST
28150: PUSH
28151: EMPTY
28152: LIST
28153: LIST
28154: LIST
28155: PUSH
28156: EMPTY
28157: LIST
28158: LIST
28159: PPUSH
28160: CALL_OW 72
28164: ST_TO_ADDR
28165: GO 28319
28167: LD_INT 3
28169: DOUBLE
28170: EQUAL
28171: IFTRUE 28175
28173: GO 28237
28175: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
28176: LD_ADDR_VAR 0 12
28180: PUSH
28181: LD_VAR 0 18
28185: PPUSH
28186: LD_INT 22
28188: PUSH
28189: LD_VAR 0 16
28193: PUSH
28194: EMPTY
28195: LIST
28196: LIST
28197: PUSH
28198: LD_INT 2
28200: PUSH
28201: LD_INT 30
28203: PUSH
28204: LD_INT 2
28206: PUSH
28207: EMPTY
28208: LIST
28209: LIST
28210: PUSH
28211: LD_INT 30
28213: PUSH
28214: LD_INT 3
28216: PUSH
28217: EMPTY
28218: LIST
28219: LIST
28220: PUSH
28221: EMPTY
28222: LIST
28223: LIST
28224: LIST
28225: PUSH
28226: EMPTY
28227: LIST
28228: LIST
28229: PPUSH
28230: CALL_OW 72
28234: ST_TO_ADDR
28235: GO 28319
28237: LD_INT 4
28239: DOUBLE
28240: EQUAL
28241: IFTRUE 28245
28243: GO 28318
28245: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
28246: LD_ADDR_VAR 0 12
28250: PUSH
28251: LD_VAR 0 18
28255: PPUSH
28256: LD_INT 22
28258: PUSH
28259: LD_VAR 0 16
28263: PUSH
28264: EMPTY
28265: LIST
28266: LIST
28267: PUSH
28268: LD_INT 2
28270: PUSH
28271: LD_INT 30
28273: PUSH
28274: LD_INT 6
28276: PUSH
28277: EMPTY
28278: LIST
28279: LIST
28280: PUSH
28281: LD_INT 30
28283: PUSH
28284: LD_INT 7
28286: PUSH
28287: EMPTY
28288: LIST
28289: LIST
28290: PUSH
28291: LD_INT 30
28293: PUSH
28294: LD_INT 8
28296: PUSH
28297: EMPTY
28298: LIST
28299: LIST
28300: PUSH
28301: EMPTY
28302: LIST
28303: LIST
28304: LIST
28305: LIST
28306: PUSH
28307: EMPTY
28308: LIST
28309: LIST
28310: PPUSH
28311: CALL_OW 72
28315: ST_TO_ADDR
28316: GO 28319
28318: POP
// if i = 1 then
28319: LD_VAR 0 8
28323: PUSH
28324: LD_INT 1
28326: EQUAL
28327: IFFALSE 28438
// begin tmp := [ ] ;
28329: LD_ADDR_VAR 0 19
28333: PUSH
28334: EMPTY
28335: ST_TO_ADDR
// for j in f do
28336: LD_ADDR_VAR 0 9
28340: PUSH
28341: LD_VAR 0 12
28345: PUSH
28346: FOR_IN
28347: IFFALSE 28420
// if GetBType ( j ) = b_bunker then
28349: LD_VAR 0 9
28353: PPUSH
28354: CALL_OW 266
28358: PUSH
28359: LD_INT 32
28361: EQUAL
28362: IFFALSE 28389
// tmp := Insert ( tmp , 1 , j ) else
28364: LD_ADDR_VAR 0 19
28368: PUSH
28369: LD_VAR 0 19
28373: PPUSH
28374: LD_INT 1
28376: PPUSH
28377: LD_VAR 0 9
28381: PPUSH
28382: CALL_OW 2
28386: ST_TO_ADDR
28387: GO 28418
// tmp := Insert ( tmp , tmp + 1 , j ) ;
28389: LD_ADDR_VAR 0 19
28393: PUSH
28394: LD_VAR 0 19
28398: PPUSH
28399: LD_VAR 0 19
28403: PUSH
28404: LD_INT 1
28406: PLUS
28407: PPUSH
28408: LD_VAR 0 9
28412: PPUSH
28413: CALL_OW 2
28417: ST_TO_ADDR
28418: GO 28346
28420: POP
28421: POP
// if tmp then
28422: LD_VAR 0 19
28426: IFFALSE 28438
// f := tmp ;
28428: LD_ADDR_VAR 0 12
28432: PUSH
28433: LD_VAR 0 19
28437: ST_TO_ADDR
// end ; x := personel [ i ] ;
28438: LD_ADDR_VAR 0 13
28442: PUSH
28443: LD_VAR 0 6
28447: PUSH
28448: LD_VAR 0 8
28452: ARRAY
28453: ST_TO_ADDR
// if x = - 1 then
28454: LD_VAR 0 13
28458: PUSH
28459: LD_INT 1
28461: NEG
28462: EQUAL
28463: IFFALSE 28672
// begin for j in f do
28465: LD_ADDR_VAR 0 9
28469: PUSH
28470: LD_VAR 0 12
28474: PUSH
28475: FOR_IN
28476: IFFALSE 28668
// repeat InitHc ;
28478: CALL_OW 19
// if GetBType ( j ) = b_barracks then
28482: LD_VAR 0 9
28486: PPUSH
28487: CALL_OW 266
28491: PUSH
28492: LD_INT 5
28494: EQUAL
28495: IFFALSE 28565
// begin if UnitsInside ( j ) < 3 then
28497: LD_VAR 0 9
28501: PPUSH
28502: CALL_OW 313
28506: PUSH
28507: LD_INT 3
28509: LESS
28510: IFFALSE 28546
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
28512: LD_INT 0
28514: PPUSH
28515: LD_INT 5
28517: PUSH
28518: LD_INT 8
28520: PUSH
28521: LD_INT 9
28523: PUSH
28524: EMPTY
28525: LIST
28526: LIST
28527: LIST
28528: PUSH
28529: LD_VAR 0 17
28533: ARRAY
28534: PPUSH
28535: LD_VAR 0 4
28539: PPUSH
28540: CALL_OW 380
28544: GO 28563
// PrepareHuman ( false , i , skill ) ;
28546: LD_INT 0
28548: PPUSH
28549: LD_VAR 0 8
28553: PPUSH
28554: LD_VAR 0 4
28558: PPUSH
28559: CALL_OW 380
// end else
28563: GO 28582
// PrepareHuman ( false , i , skill ) ;
28565: LD_INT 0
28567: PPUSH
28568: LD_VAR 0 8
28572: PPUSH
28573: LD_VAR 0 4
28577: PPUSH
28578: CALL_OW 380
// un := CreateHuman ;
28582: LD_ADDR_VAR 0 14
28586: PUSH
28587: CALL_OW 44
28591: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
28592: LD_ADDR_VAR 0 7
28596: PUSH
28597: LD_VAR 0 7
28601: PPUSH
28602: LD_INT 1
28604: PPUSH
28605: LD_VAR 0 14
28609: PPUSH
28610: CALL_OW 2
28614: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
28615: LD_VAR 0 14
28619: PPUSH
28620: LD_VAR 0 9
28624: PPUSH
28625: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
28629: LD_VAR 0 9
28633: PPUSH
28634: CALL_OW 313
28638: PUSH
28639: LD_INT 6
28641: EQUAL
28642: PUSH
28643: LD_VAR 0 9
28647: PPUSH
28648: CALL_OW 266
28652: PUSH
28653: LD_INT 32
28655: PUSH
28656: LD_INT 31
28658: PUSH
28659: EMPTY
28660: LIST
28661: LIST
28662: IN
28663: OR
28664: IFFALSE 28478
28666: GO 28475
28668: POP
28669: POP
// end else
28670: GO 29052
// for j = 1 to x do
28672: LD_ADDR_VAR 0 9
28676: PUSH
28677: DOUBLE
28678: LD_INT 1
28680: DEC
28681: ST_TO_ADDR
28682: LD_VAR 0 13
28686: PUSH
28687: FOR_TO
28688: IFFALSE 29050
// begin InitHc ;
28690: CALL_OW 19
// if not f then
28694: LD_VAR 0 12
28698: NOT
28699: IFFALSE 28788
// begin PrepareHuman ( false , i , skill ) ;
28701: LD_INT 0
28703: PPUSH
28704: LD_VAR 0 8
28708: PPUSH
28709: LD_VAR 0 4
28713: PPUSH
28714: CALL_OW 380
// un := CreateHuman ;
28718: LD_ADDR_VAR 0 14
28722: PUSH
28723: CALL_OW 44
28727: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
28728: LD_ADDR_VAR 0 7
28732: PUSH
28733: LD_VAR 0 7
28737: PPUSH
28738: LD_INT 1
28740: PPUSH
28741: LD_VAR 0 14
28745: PPUSH
28746: CALL_OW 2
28750: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
28751: LD_VAR 0 14
28755: PPUSH
28756: LD_VAR 0 1
28760: PPUSH
28761: CALL_OW 250
28765: PPUSH
28766: LD_VAR 0 1
28770: PPUSH
28771: CALL_OW 251
28775: PPUSH
28776: LD_INT 10
28778: PPUSH
28779: LD_INT 0
28781: PPUSH
28782: CALL_OW 50
// continue ;
28786: GO 28687
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
28788: LD_VAR 0 12
28792: PUSH
28793: LD_INT 1
28795: ARRAY
28796: PPUSH
28797: CALL_OW 313
28801: PUSH
28802: LD_VAR 0 12
28806: PUSH
28807: LD_INT 1
28809: ARRAY
28810: PPUSH
28811: CALL_OW 266
28815: PUSH
28816: LD_INT 32
28818: PUSH
28819: LD_INT 31
28821: PUSH
28822: EMPTY
28823: LIST
28824: LIST
28825: IN
28826: AND
28827: PUSH
28828: LD_VAR 0 12
28832: PUSH
28833: LD_INT 1
28835: ARRAY
28836: PPUSH
28837: CALL_OW 313
28841: PUSH
28842: LD_INT 6
28844: EQUAL
28845: OR
28846: IFFALSE 28866
// f := Delete ( f , 1 ) ;
28848: LD_ADDR_VAR 0 12
28852: PUSH
28853: LD_VAR 0 12
28857: PPUSH
28858: LD_INT 1
28860: PPUSH
28861: CALL_OW 3
28865: ST_TO_ADDR
// if not f then
28866: LD_VAR 0 12
28870: NOT
28871: IFFALSE 28889
// begin x := x + 2 ;
28873: LD_ADDR_VAR 0 13
28877: PUSH
28878: LD_VAR 0 13
28882: PUSH
28883: LD_INT 2
28885: PLUS
28886: ST_TO_ADDR
// continue ;
28887: GO 28687
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
28889: LD_VAR 0 12
28893: PUSH
28894: LD_INT 1
28896: ARRAY
28897: PPUSH
28898: CALL_OW 266
28902: PUSH
28903: LD_INT 5
28905: EQUAL
28906: IFFALSE 28980
// begin if UnitsInside ( f [ 1 ] ) < 3 then
28908: LD_VAR 0 12
28912: PUSH
28913: LD_INT 1
28915: ARRAY
28916: PPUSH
28917: CALL_OW 313
28921: PUSH
28922: LD_INT 3
28924: LESS
28925: IFFALSE 28961
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
28927: LD_INT 0
28929: PPUSH
28930: LD_INT 5
28932: PUSH
28933: LD_INT 8
28935: PUSH
28936: LD_INT 9
28938: PUSH
28939: EMPTY
28940: LIST
28941: LIST
28942: LIST
28943: PUSH
28944: LD_VAR 0 17
28948: ARRAY
28949: PPUSH
28950: LD_VAR 0 4
28954: PPUSH
28955: CALL_OW 380
28959: GO 28978
// PrepareHuman ( false , i , skill ) ;
28961: LD_INT 0
28963: PPUSH
28964: LD_VAR 0 8
28968: PPUSH
28969: LD_VAR 0 4
28973: PPUSH
28974: CALL_OW 380
// end else
28978: GO 28997
// PrepareHuman ( false , i , skill ) ;
28980: LD_INT 0
28982: PPUSH
28983: LD_VAR 0 8
28987: PPUSH
28988: LD_VAR 0 4
28992: PPUSH
28993: CALL_OW 380
// un := CreateHuman ;
28997: LD_ADDR_VAR 0 14
29001: PUSH
29002: CALL_OW 44
29006: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
29007: LD_ADDR_VAR 0 7
29011: PUSH
29012: LD_VAR 0 7
29016: PPUSH
29017: LD_INT 1
29019: PPUSH
29020: LD_VAR 0 14
29024: PPUSH
29025: CALL_OW 2
29029: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
29030: LD_VAR 0 14
29034: PPUSH
29035: LD_VAR 0 12
29039: PUSH
29040: LD_INT 1
29042: ARRAY
29043: PPUSH
29044: CALL_OW 52
// end ;
29048: GO 28687
29050: POP
29051: POP
// end ;
29052: GO 27989
29054: POP
29055: POP
// result := result ^ buildings ;
29056: LD_ADDR_VAR 0 7
29060: PUSH
29061: LD_VAR 0 7
29065: PUSH
29066: LD_VAR 0 18
29070: ADD
29071: ST_TO_ADDR
// end else
29072: GO 29215
// begin for i = 1 to personel do
29074: LD_ADDR_VAR 0 8
29078: PUSH
29079: DOUBLE
29080: LD_INT 1
29082: DEC
29083: ST_TO_ADDR
29084: LD_VAR 0 6
29088: PUSH
29089: FOR_TO
29090: IFFALSE 29213
// begin if i > 4 then
29092: LD_VAR 0 8
29096: PUSH
29097: LD_INT 4
29099: GREATER
29100: IFFALSE 29104
// break ;
29102: GO 29213
// x := personel [ i ] ;
29104: LD_ADDR_VAR 0 13
29108: PUSH
29109: LD_VAR 0 6
29113: PUSH
29114: LD_VAR 0 8
29118: ARRAY
29119: ST_TO_ADDR
// if x = - 1 then
29120: LD_VAR 0 13
29124: PUSH
29125: LD_INT 1
29127: NEG
29128: EQUAL
29129: IFFALSE 29133
// continue ;
29131: GO 29089
// PrepareHuman ( false , i , skill ) ;
29133: LD_INT 0
29135: PPUSH
29136: LD_VAR 0 8
29140: PPUSH
29141: LD_VAR 0 4
29145: PPUSH
29146: CALL_OW 380
// un := CreateHuman ;
29150: LD_ADDR_VAR 0 14
29154: PUSH
29155: CALL_OW 44
29159: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
29160: LD_VAR 0 14
29164: PPUSH
29165: LD_VAR 0 1
29169: PPUSH
29170: CALL_OW 250
29174: PPUSH
29175: LD_VAR 0 1
29179: PPUSH
29180: CALL_OW 251
29184: PPUSH
29185: LD_INT 10
29187: PPUSH
29188: LD_INT 0
29190: PPUSH
29191: CALL_OW 50
// result := result ^ un ;
29195: LD_ADDR_VAR 0 7
29199: PUSH
29200: LD_VAR 0 7
29204: PUSH
29205: LD_VAR 0 14
29209: ADD
29210: ST_TO_ADDR
// end ;
29211: GO 29089
29213: POP
29214: POP
// end ; end ;
29215: LD_VAR 0 7
29219: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
29220: LD_INT 0
29222: PPUSH
29223: PPUSH
29224: PPUSH
29225: PPUSH
29226: PPUSH
29227: PPUSH
29228: PPUSH
29229: PPUSH
29230: PPUSH
29231: PPUSH
29232: PPUSH
29233: PPUSH
29234: PPUSH
29235: PPUSH
29236: PPUSH
29237: PPUSH
// result := false ;
29238: LD_ADDR_VAR 0 3
29242: PUSH
29243: LD_INT 0
29245: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
29246: LD_VAR 0 1
29250: NOT
29251: PUSH
29252: LD_VAR 0 1
29256: PPUSH
29257: CALL_OW 266
29261: PUSH
29262: LD_INT 32
29264: PUSH
29265: LD_INT 33
29267: PUSH
29268: EMPTY
29269: LIST
29270: LIST
29271: IN
29272: NOT
29273: OR
29274: IFFALSE 29278
// exit ;
29276: GO 30387
// nat := GetNation ( tower ) ;
29278: LD_ADDR_VAR 0 12
29282: PUSH
29283: LD_VAR 0 1
29287: PPUSH
29288: CALL_OW 248
29292: ST_TO_ADDR
// side := GetSide ( tower ) ;
29293: LD_ADDR_VAR 0 16
29297: PUSH
29298: LD_VAR 0 1
29302: PPUSH
29303: CALL_OW 255
29307: ST_TO_ADDR
// x := GetX ( tower ) ;
29308: LD_ADDR_VAR 0 10
29312: PUSH
29313: LD_VAR 0 1
29317: PPUSH
29318: CALL_OW 250
29322: ST_TO_ADDR
// y := GetY ( tower ) ;
29323: LD_ADDR_VAR 0 11
29327: PUSH
29328: LD_VAR 0 1
29332: PPUSH
29333: CALL_OW 251
29337: ST_TO_ADDR
// if not x or not y then
29338: LD_VAR 0 10
29342: NOT
29343: PUSH
29344: LD_VAR 0 11
29348: NOT
29349: OR
29350: IFFALSE 29354
// exit ;
29352: GO 30387
// weapon := 0 ;
29354: LD_ADDR_VAR 0 18
29358: PUSH
29359: LD_INT 0
29361: ST_TO_ADDR
// fac_list := [ ] ;
29362: LD_ADDR_VAR 0 17
29366: PUSH
29367: EMPTY
29368: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
29369: LD_ADDR_VAR 0 6
29373: PUSH
29374: LD_VAR 0 1
29378: PPUSH
29379: CALL_OW 274
29383: PPUSH
29384: LD_VAR 0 2
29388: PPUSH
29389: LD_INT 0
29391: PPUSH
29392: CALL 26958 0 3
29396: PPUSH
29397: LD_INT 30
29399: PUSH
29400: LD_INT 3
29402: PUSH
29403: EMPTY
29404: LIST
29405: LIST
29406: PPUSH
29407: CALL_OW 72
29411: ST_TO_ADDR
// if not factories then
29412: LD_VAR 0 6
29416: NOT
29417: IFFALSE 29421
// exit ;
29419: GO 30387
// for i in factories do
29421: LD_ADDR_VAR 0 8
29425: PUSH
29426: LD_VAR 0 6
29430: PUSH
29431: FOR_IN
29432: IFFALSE 29457
// fac_list := fac_list union AvailableWeaponList ( i ) ;
29434: LD_ADDR_VAR 0 17
29438: PUSH
29439: LD_VAR 0 17
29443: PUSH
29444: LD_VAR 0 8
29448: PPUSH
29449: CALL_OW 478
29453: UNION
29454: ST_TO_ADDR
29455: GO 29431
29457: POP
29458: POP
// if not fac_list then
29459: LD_VAR 0 17
29463: NOT
29464: IFFALSE 29468
// exit ;
29466: GO 30387
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
29468: LD_ADDR_VAR 0 5
29472: PUSH
29473: LD_INT 4
29475: PUSH
29476: LD_INT 5
29478: PUSH
29479: LD_INT 9
29481: PUSH
29482: LD_INT 10
29484: PUSH
29485: LD_INT 6
29487: PUSH
29488: LD_INT 7
29490: PUSH
29491: LD_INT 11
29493: PUSH
29494: EMPTY
29495: LIST
29496: LIST
29497: LIST
29498: LIST
29499: LIST
29500: LIST
29501: LIST
29502: PUSH
29503: LD_INT 27
29505: PUSH
29506: LD_INT 28
29508: PUSH
29509: LD_INT 26
29511: PUSH
29512: LD_INT 30
29514: PUSH
29515: EMPTY
29516: LIST
29517: LIST
29518: LIST
29519: LIST
29520: PUSH
29521: LD_INT 43
29523: PUSH
29524: LD_INT 44
29526: PUSH
29527: LD_INT 46
29529: PUSH
29530: LD_INT 45
29532: PUSH
29533: LD_INT 47
29535: PUSH
29536: LD_INT 49
29538: PUSH
29539: EMPTY
29540: LIST
29541: LIST
29542: LIST
29543: LIST
29544: LIST
29545: LIST
29546: PUSH
29547: EMPTY
29548: LIST
29549: LIST
29550: LIST
29551: PUSH
29552: LD_VAR 0 12
29556: ARRAY
29557: ST_TO_ADDR
// list := list isect fac_list ;
29558: LD_ADDR_VAR 0 5
29562: PUSH
29563: LD_VAR 0 5
29567: PUSH
29568: LD_VAR 0 17
29572: ISECT
29573: ST_TO_ADDR
// if not list then
29574: LD_VAR 0 5
29578: NOT
29579: IFFALSE 29583
// exit ;
29581: GO 30387
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
29583: LD_VAR 0 12
29587: PUSH
29588: LD_INT 3
29590: EQUAL
29591: PUSH
29592: LD_INT 49
29594: PUSH
29595: LD_VAR 0 5
29599: IN
29600: AND
29601: PUSH
29602: LD_INT 31
29604: PPUSH
29605: LD_VAR 0 16
29609: PPUSH
29610: CALL_OW 321
29614: PUSH
29615: LD_INT 2
29617: EQUAL
29618: AND
29619: IFFALSE 29679
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
29621: LD_INT 22
29623: PUSH
29624: LD_VAR 0 16
29628: PUSH
29629: EMPTY
29630: LIST
29631: LIST
29632: PUSH
29633: LD_INT 35
29635: PUSH
29636: LD_INT 49
29638: PUSH
29639: EMPTY
29640: LIST
29641: LIST
29642: PUSH
29643: LD_INT 91
29645: PUSH
29646: LD_VAR 0 1
29650: PUSH
29651: LD_INT 10
29653: PUSH
29654: EMPTY
29655: LIST
29656: LIST
29657: LIST
29658: PUSH
29659: EMPTY
29660: LIST
29661: LIST
29662: LIST
29663: PPUSH
29664: CALL_OW 69
29668: NOT
29669: IFFALSE 29679
// weapon := ru_time_lapser ;
29671: LD_ADDR_VAR 0 18
29675: PUSH
29676: LD_INT 49
29678: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
29679: LD_VAR 0 12
29683: PUSH
29684: LD_INT 1
29686: PUSH
29687: LD_INT 2
29689: PUSH
29690: EMPTY
29691: LIST
29692: LIST
29693: IN
29694: PUSH
29695: LD_INT 11
29697: PUSH
29698: LD_VAR 0 5
29702: IN
29703: PUSH
29704: LD_INT 30
29706: PUSH
29707: LD_VAR 0 5
29711: IN
29712: OR
29713: AND
29714: PUSH
29715: LD_INT 6
29717: PPUSH
29718: LD_VAR 0 16
29722: PPUSH
29723: CALL_OW 321
29727: PUSH
29728: LD_INT 2
29730: EQUAL
29731: AND
29732: IFFALSE 29897
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
29734: LD_INT 22
29736: PUSH
29737: LD_VAR 0 16
29741: PUSH
29742: EMPTY
29743: LIST
29744: LIST
29745: PUSH
29746: LD_INT 2
29748: PUSH
29749: LD_INT 35
29751: PUSH
29752: LD_INT 11
29754: PUSH
29755: EMPTY
29756: LIST
29757: LIST
29758: PUSH
29759: LD_INT 35
29761: PUSH
29762: LD_INT 30
29764: PUSH
29765: EMPTY
29766: LIST
29767: LIST
29768: PUSH
29769: EMPTY
29770: LIST
29771: LIST
29772: LIST
29773: PUSH
29774: LD_INT 91
29776: PUSH
29777: LD_VAR 0 1
29781: PUSH
29782: LD_INT 18
29784: PUSH
29785: EMPTY
29786: LIST
29787: LIST
29788: LIST
29789: PUSH
29790: EMPTY
29791: LIST
29792: LIST
29793: LIST
29794: PPUSH
29795: CALL_OW 69
29799: NOT
29800: PUSH
29801: LD_INT 22
29803: PUSH
29804: LD_VAR 0 16
29808: PUSH
29809: EMPTY
29810: LIST
29811: LIST
29812: PUSH
29813: LD_INT 2
29815: PUSH
29816: LD_INT 30
29818: PUSH
29819: LD_INT 32
29821: PUSH
29822: EMPTY
29823: LIST
29824: LIST
29825: PUSH
29826: LD_INT 30
29828: PUSH
29829: LD_INT 33
29831: PUSH
29832: EMPTY
29833: LIST
29834: LIST
29835: PUSH
29836: EMPTY
29837: LIST
29838: LIST
29839: LIST
29840: PUSH
29841: LD_INT 91
29843: PUSH
29844: LD_VAR 0 1
29848: PUSH
29849: LD_INT 12
29851: PUSH
29852: EMPTY
29853: LIST
29854: LIST
29855: LIST
29856: PUSH
29857: EMPTY
29858: LIST
29859: LIST
29860: LIST
29861: PUSH
29862: EMPTY
29863: LIST
29864: PPUSH
29865: CALL_OW 69
29869: PUSH
29870: LD_INT 2
29872: GREATER
29873: AND
29874: IFFALSE 29897
// weapon := [ us_radar , ar_radar ] [ nat ] ;
29876: LD_ADDR_VAR 0 18
29880: PUSH
29881: LD_INT 11
29883: PUSH
29884: LD_INT 30
29886: PUSH
29887: EMPTY
29888: LIST
29889: LIST
29890: PUSH
29891: LD_VAR 0 12
29895: ARRAY
29896: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
29897: LD_VAR 0 18
29901: NOT
29902: PUSH
29903: LD_INT 40
29905: PPUSH
29906: LD_VAR 0 16
29910: PPUSH
29911: CALL_OW 321
29915: PUSH
29916: LD_INT 2
29918: EQUAL
29919: AND
29920: PUSH
29921: LD_INT 7
29923: PUSH
29924: LD_VAR 0 5
29928: IN
29929: PUSH
29930: LD_INT 28
29932: PUSH
29933: LD_VAR 0 5
29937: IN
29938: OR
29939: PUSH
29940: LD_INT 45
29942: PUSH
29943: LD_VAR 0 5
29947: IN
29948: OR
29949: AND
29950: IFFALSE 30204
// begin hex := GetHexInfo ( x , y ) ;
29952: LD_ADDR_VAR 0 4
29956: PUSH
29957: LD_VAR 0 10
29961: PPUSH
29962: LD_VAR 0 11
29966: PPUSH
29967: CALL_OW 546
29971: ST_TO_ADDR
// if hex [ 1 ] then
29972: LD_VAR 0 4
29976: PUSH
29977: LD_INT 1
29979: ARRAY
29980: IFFALSE 29984
// exit ;
29982: GO 30387
// height := hex [ 2 ] ;
29984: LD_ADDR_VAR 0 15
29988: PUSH
29989: LD_VAR 0 4
29993: PUSH
29994: LD_INT 2
29996: ARRAY
29997: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
29998: LD_ADDR_VAR 0 14
30002: PUSH
30003: LD_INT 0
30005: PUSH
30006: LD_INT 2
30008: PUSH
30009: LD_INT 3
30011: PUSH
30012: LD_INT 5
30014: PUSH
30015: EMPTY
30016: LIST
30017: LIST
30018: LIST
30019: LIST
30020: ST_TO_ADDR
// for i in tmp do
30021: LD_ADDR_VAR 0 8
30025: PUSH
30026: LD_VAR 0 14
30030: PUSH
30031: FOR_IN
30032: IFFALSE 30202
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
30034: LD_ADDR_VAR 0 9
30038: PUSH
30039: LD_VAR 0 10
30043: PPUSH
30044: LD_VAR 0 8
30048: PPUSH
30049: LD_INT 5
30051: PPUSH
30052: CALL_OW 272
30056: PUSH
30057: LD_VAR 0 11
30061: PPUSH
30062: LD_VAR 0 8
30066: PPUSH
30067: LD_INT 5
30069: PPUSH
30070: CALL_OW 273
30074: PUSH
30075: EMPTY
30076: LIST
30077: LIST
30078: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
30079: LD_VAR 0 9
30083: PUSH
30084: LD_INT 1
30086: ARRAY
30087: PPUSH
30088: LD_VAR 0 9
30092: PUSH
30093: LD_INT 2
30095: ARRAY
30096: PPUSH
30097: CALL_OW 488
30101: IFFALSE 30200
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
30103: LD_ADDR_VAR 0 4
30107: PUSH
30108: LD_VAR 0 9
30112: PUSH
30113: LD_INT 1
30115: ARRAY
30116: PPUSH
30117: LD_VAR 0 9
30121: PUSH
30122: LD_INT 2
30124: ARRAY
30125: PPUSH
30126: CALL_OW 546
30130: ST_TO_ADDR
// if hex [ 1 ] then
30131: LD_VAR 0 4
30135: PUSH
30136: LD_INT 1
30138: ARRAY
30139: IFFALSE 30143
// continue ;
30141: GO 30031
// h := hex [ 2 ] ;
30143: LD_ADDR_VAR 0 13
30147: PUSH
30148: LD_VAR 0 4
30152: PUSH
30153: LD_INT 2
30155: ARRAY
30156: ST_TO_ADDR
// if h + 7 < height then
30157: LD_VAR 0 13
30161: PUSH
30162: LD_INT 7
30164: PLUS
30165: PUSH
30166: LD_VAR 0 15
30170: LESS
30171: IFFALSE 30200
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
30173: LD_ADDR_VAR 0 18
30177: PUSH
30178: LD_INT 7
30180: PUSH
30181: LD_INT 28
30183: PUSH
30184: LD_INT 45
30186: PUSH
30187: EMPTY
30188: LIST
30189: LIST
30190: LIST
30191: PUSH
30192: LD_VAR 0 12
30196: ARRAY
30197: ST_TO_ADDR
// break ;
30198: GO 30202
// end ; end ; end ;
30200: GO 30031
30202: POP
30203: POP
// end ; if not weapon then
30204: LD_VAR 0 18
30208: NOT
30209: IFFALSE 30269
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
30211: LD_ADDR_VAR 0 5
30215: PUSH
30216: LD_VAR 0 5
30220: PUSH
30221: LD_INT 11
30223: PUSH
30224: LD_INT 30
30226: PUSH
30227: LD_INT 49
30229: PUSH
30230: EMPTY
30231: LIST
30232: LIST
30233: LIST
30234: DIFF
30235: ST_TO_ADDR
// if not list then
30236: LD_VAR 0 5
30240: NOT
30241: IFFALSE 30245
// exit ;
30243: GO 30387
// weapon := list [ rand ( 1 , list ) ] ;
30245: LD_ADDR_VAR 0 18
30249: PUSH
30250: LD_VAR 0 5
30254: PUSH
30255: LD_INT 1
30257: PPUSH
30258: LD_VAR 0 5
30262: PPUSH
30263: CALL_OW 12
30267: ARRAY
30268: ST_TO_ADDR
// end ; if weapon then
30269: LD_VAR 0 18
30273: IFFALSE 30387
// begin tmp := CostOfWeapon ( weapon ) ;
30275: LD_ADDR_VAR 0 14
30279: PUSH
30280: LD_VAR 0 18
30284: PPUSH
30285: CALL_OW 451
30289: ST_TO_ADDR
// j := GetBase ( tower ) ;
30290: LD_ADDR_VAR 0 9
30294: PUSH
30295: LD_VAR 0 1
30299: PPUSH
30300: CALL_OW 274
30304: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
30305: LD_VAR 0 9
30309: PPUSH
30310: LD_INT 1
30312: PPUSH
30313: CALL_OW 275
30317: PUSH
30318: LD_VAR 0 14
30322: PUSH
30323: LD_INT 1
30325: ARRAY
30326: GREATEREQUAL
30327: PUSH
30328: LD_VAR 0 9
30332: PPUSH
30333: LD_INT 2
30335: PPUSH
30336: CALL_OW 275
30340: PUSH
30341: LD_VAR 0 14
30345: PUSH
30346: LD_INT 2
30348: ARRAY
30349: GREATEREQUAL
30350: AND
30351: PUSH
30352: LD_VAR 0 9
30356: PPUSH
30357: LD_INT 3
30359: PPUSH
30360: CALL_OW 275
30364: PUSH
30365: LD_VAR 0 14
30369: PUSH
30370: LD_INT 3
30372: ARRAY
30373: GREATEREQUAL
30374: AND
30375: IFFALSE 30387
// result := weapon ;
30377: LD_ADDR_VAR 0 3
30381: PUSH
30382: LD_VAR 0 18
30386: ST_TO_ADDR
// end ; end ;
30387: LD_VAR 0 3
30391: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
30392: LD_INT 0
30394: PPUSH
30395: PPUSH
// result := true ;
30396: LD_ADDR_VAR 0 3
30400: PUSH
30401: LD_INT 1
30403: ST_TO_ADDR
// if array1 = array2 then
30404: LD_VAR 0 1
30408: PUSH
30409: LD_VAR 0 2
30413: EQUAL
30414: IFFALSE 30474
// begin for i = 1 to array1 do
30416: LD_ADDR_VAR 0 4
30420: PUSH
30421: DOUBLE
30422: LD_INT 1
30424: DEC
30425: ST_TO_ADDR
30426: LD_VAR 0 1
30430: PUSH
30431: FOR_TO
30432: IFFALSE 30470
// if array1 [ i ] <> array2 [ i ] then
30434: LD_VAR 0 1
30438: PUSH
30439: LD_VAR 0 4
30443: ARRAY
30444: PUSH
30445: LD_VAR 0 2
30449: PUSH
30450: LD_VAR 0 4
30454: ARRAY
30455: NONEQUAL
30456: IFFALSE 30468
// begin result := false ;
30458: LD_ADDR_VAR 0 3
30462: PUSH
30463: LD_INT 0
30465: ST_TO_ADDR
// break ;
30466: GO 30470
// end ;
30468: GO 30431
30470: POP
30471: POP
// end else
30472: GO 30482
// result := false ;
30474: LD_ADDR_VAR 0 3
30478: PUSH
30479: LD_INT 0
30481: ST_TO_ADDR
// end ;
30482: LD_VAR 0 3
30486: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
30487: LD_INT 0
30489: PPUSH
30490: PPUSH
// if not array1 or not array2 then
30491: LD_VAR 0 1
30495: NOT
30496: PUSH
30497: LD_VAR 0 2
30501: NOT
30502: OR
30503: IFFALSE 30507
// exit ;
30505: GO 30571
// result := true ;
30507: LD_ADDR_VAR 0 3
30511: PUSH
30512: LD_INT 1
30514: ST_TO_ADDR
// for i = 1 to array1 do
30515: LD_ADDR_VAR 0 4
30519: PUSH
30520: DOUBLE
30521: LD_INT 1
30523: DEC
30524: ST_TO_ADDR
30525: LD_VAR 0 1
30529: PUSH
30530: FOR_TO
30531: IFFALSE 30569
// if array1 [ i ] <> array2 [ i ] then
30533: LD_VAR 0 1
30537: PUSH
30538: LD_VAR 0 4
30542: ARRAY
30543: PUSH
30544: LD_VAR 0 2
30548: PUSH
30549: LD_VAR 0 4
30553: ARRAY
30554: NONEQUAL
30555: IFFALSE 30567
// begin result := false ;
30557: LD_ADDR_VAR 0 3
30561: PUSH
30562: LD_INT 0
30564: ST_TO_ADDR
// break ;
30565: GO 30569
// end ;
30567: GO 30530
30569: POP
30570: POP
// end ;
30571: LD_VAR 0 3
30575: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
30576: LD_INT 0
30578: PPUSH
30579: PPUSH
30580: PPUSH
// pom := GetBase ( fac ) ;
30581: LD_ADDR_VAR 0 5
30585: PUSH
30586: LD_VAR 0 1
30590: PPUSH
30591: CALL_OW 274
30595: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
30596: LD_ADDR_VAR 0 4
30600: PUSH
30601: LD_VAR 0 2
30605: PUSH
30606: LD_INT 1
30608: ARRAY
30609: PPUSH
30610: LD_VAR 0 2
30614: PUSH
30615: LD_INT 2
30617: ARRAY
30618: PPUSH
30619: LD_VAR 0 2
30623: PUSH
30624: LD_INT 3
30626: ARRAY
30627: PPUSH
30628: LD_VAR 0 2
30632: PUSH
30633: LD_INT 4
30635: ARRAY
30636: PPUSH
30637: CALL_OW 449
30641: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
30642: LD_ADDR_VAR 0 3
30646: PUSH
30647: LD_VAR 0 5
30651: PPUSH
30652: LD_INT 1
30654: PPUSH
30655: CALL_OW 275
30659: PUSH
30660: LD_VAR 0 4
30664: PUSH
30665: LD_INT 1
30667: ARRAY
30668: GREATEREQUAL
30669: PUSH
30670: LD_VAR 0 5
30674: PPUSH
30675: LD_INT 2
30677: PPUSH
30678: CALL_OW 275
30682: PUSH
30683: LD_VAR 0 4
30687: PUSH
30688: LD_INT 2
30690: ARRAY
30691: GREATEREQUAL
30692: AND
30693: PUSH
30694: LD_VAR 0 5
30698: PPUSH
30699: LD_INT 3
30701: PPUSH
30702: CALL_OW 275
30706: PUSH
30707: LD_VAR 0 4
30711: PUSH
30712: LD_INT 3
30714: ARRAY
30715: GREATEREQUAL
30716: AND
30717: ST_TO_ADDR
// end ;
30718: LD_VAR 0 3
30722: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
30723: LD_INT 0
30725: PPUSH
30726: PPUSH
30727: PPUSH
30728: PPUSH
// pom := GetBase ( building ) ;
30729: LD_ADDR_VAR 0 3
30733: PUSH
30734: LD_VAR 0 1
30738: PPUSH
30739: CALL_OW 274
30743: ST_TO_ADDR
// if not pom then
30744: LD_VAR 0 3
30748: NOT
30749: IFFALSE 30753
// exit ;
30751: GO 30923
// btype := GetBType ( building ) ;
30753: LD_ADDR_VAR 0 5
30757: PUSH
30758: LD_VAR 0 1
30762: PPUSH
30763: CALL_OW 266
30767: ST_TO_ADDR
// if btype = b_armoury then
30768: LD_VAR 0 5
30772: PUSH
30773: LD_INT 4
30775: EQUAL
30776: IFFALSE 30786
// btype := b_barracks ;
30778: LD_ADDR_VAR 0 5
30782: PUSH
30783: LD_INT 5
30785: ST_TO_ADDR
// if btype = b_depot then
30786: LD_VAR 0 5
30790: PUSH
30791: LD_INT 0
30793: EQUAL
30794: IFFALSE 30804
// btype := b_warehouse ;
30796: LD_ADDR_VAR 0 5
30800: PUSH
30801: LD_INT 1
30803: ST_TO_ADDR
// if btype = b_workshop then
30804: LD_VAR 0 5
30808: PUSH
30809: LD_INT 2
30811: EQUAL
30812: IFFALSE 30822
// btype := b_factory ;
30814: LD_ADDR_VAR 0 5
30818: PUSH
30819: LD_INT 3
30821: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
30822: LD_ADDR_VAR 0 4
30826: PUSH
30827: LD_VAR 0 5
30831: PPUSH
30832: LD_VAR 0 1
30836: PPUSH
30837: CALL_OW 248
30841: PPUSH
30842: CALL_OW 450
30846: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
30847: LD_ADDR_VAR 0 2
30851: PUSH
30852: LD_VAR 0 3
30856: PPUSH
30857: LD_INT 1
30859: PPUSH
30860: CALL_OW 275
30864: PUSH
30865: LD_VAR 0 4
30869: PUSH
30870: LD_INT 1
30872: ARRAY
30873: GREATEREQUAL
30874: PUSH
30875: LD_VAR 0 3
30879: PPUSH
30880: LD_INT 2
30882: PPUSH
30883: CALL_OW 275
30887: PUSH
30888: LD_VAR 0 4
30892: PUSH
30893: LD_INT 2
30895: ARRAY
30896: GREATEREQUAL
30897: AND
30898: PUSH
30899: LD_VAR 0 3
30903: PPUSH
30904: LD_INT 3
30906: PPUSH
30907: CALL_OW 275
30911: PUSH
30912: LD_VAR 0 4
30916: PUSH
30917: LD_INT 3
30919: ARRAY
30920: GREATEREQUAL
30921: AND
30922: ST_TO_ADDR
// end ;
30923: LD_VAR 0 2
30927: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
30928: LD_INT 0
30930: PPUSH
30931: PPUSH
30932: PPUSH
// pom := GetBase ( building ) ;
30933: LD_ADDR_VAR 0 4
30937: PUSH
30938: LD_VAR 0 1
30942: PPUSH
30943: CALL_OW 274
30947: ST_TO_ADDR
// if not pom then
30948: LD_VAR 0 4
30952: NOT
30953: IFFALSE 30957
// exit ;
30955: GO 31058
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
30957: LD_ADDR_VAR 0 5
30961: PUSH
30962: LD_VAR 0 2
30966: PPUSH
30967: LD_VAR 0 1
30971: PPUSH
30972: CALL_OW 248
30976: PPUSH
30977: CALL_OW 450
30981: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
30982: LD_ADDR_VAR 0 3
30986: PUSH
30987: LD_VAR 0 4
30991: PPUSH
30992: LD_INT 1
30994: PPUSH
30995: CALL_OW 275
30999: PUSH
31000: LD_VAR 0 5
31004: PUSH
31005: LD_INT 1
31007: ARRAY
31008: GREATEREQUAL
31009: PUSH
31010: LD_VAR 0 4
31014: PPUSH
31015: LD_INT 2
31017: PPUSH
31018: CALL_OW 275
31022: PUSH
31023: LD_VAR 0 5
31027: PUSH
31028: LD_INT 2
31030: ARRAY
31031: GREATEREQUAL
31032: AND
31033: PUSH
31034: LD_VAR 0 4
31038: PPUSH
31039: LD_INT 3
31041: PPUSH
31042: CALL_OW 275
31046: PUSH
31047: LD_VAR 0 5
31051: PUSH
31052: LD_INT 3
31054: ARRAY
31055: GREATEREQUAL
31056: AND
31057: ST_TO_ADDR
// end ;
31058: LD_VAR 0 3
31062: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
31063: LD_INT 0
31065: PPUSH
31066: PPUSH
31067: PPUSH
31068: PPUSH
31069: PPUSH
31070: PPUSH
31071: PPUSH
31072: PPUSH
31073: PPUSH
31074: PPUSH
31075: PPUSH
// result := false ;
31076: LD_ADDR_VAR 0 8
31080: PUSH
31081: LD_INT 0
31083: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
31084: LD_VAR 0 5
31088: NOT
31089: PUSH
31090: LD_VAR 0 1
31094: NOT
31095: OR
31096: PUSH
31097: LD_VAR 0 2
31101: NOT
31102: OR
31103: PUSH
31104: LD_VAR 0 3
31108: NOT
31109: OR
31110: IFFALSE 31114
// exit ;
31112: GO 31928
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
31114: LD_ADDR_VAR 0 14
31118: PUSH
31119: LD_VAR 0 1
31123: PPUSH
31124: LD_VAR 0 2
31128: PPUSH
31129: LD_VAR 0 3
31133: PPUSH
31134: LD_VAR 0 4
31138: PPUSH
31139: LD_VAR 0 5
31143: PUSH
31144: LD_INT 1
31146: ARRAY
31147: PPUSH
31148: CALL_OW 248
31152: PPUSH
31153: LD_INT 0
31155: PPUSH
31156: CALL 33165 0 6
31160: ST_TO_ADDR
// if not hexes then
31161: LD_VAR 0 14
31165: NOT
31166: IFFALSE 31170
// exit ;
31168: GO 31928
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
31170: LD_ADDR_VAR 0 17
31174: PUSH
31175: LD_VAR 0 5
31179: PPUSH
31180: LD_INT 22
31182: PUSH
31183: LD_VAR 0 13
31187: PPUSH
31188: CALL_OW 255
31192: PUSH
31193: EMPTY
31194: LIST
31195: LIST
31196: PUSH
31197: LD_INT 2
31199: PUSH
31200: LD_INT 30
31202: PUSH
31203: LD_INT 0
31205: PUSH
31206: EMPTY
31207: LIST
31208: LIST
31209: PUSH
31210: LD_INT 30
31212: PUSH
31213: LD_INT 1
31215: PUSH
31216: EMPTY
31217: LIST
31218: LIST
31219: PUSH
31220: EMPTY
31221: LIST
31222: LIST
31223: LIST
31224: PUSH
31225: EMPTY
31226: LIST
31227: LIST
31228: PPUSH
31229: CALL_OW 72
31233: ST_TO_ADDR
// for i = 1 to hexes do
31234: LD_ADDR_VAR 0 9
31238: PUSH
31239: DOUBLE
31240: LD_INT 1
31242: DEC
31243: ST_TO_ADDR
31244: LD_VAR 0 14
31248: PUSH
31249: FOR_TO
31250: IFFALSE 31926
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
31252: LD_ADDR_VAR 0 13
31256: PUSH
31257: LD_VAR 0 14
31261: PUSH
31262: LD_VAR 0 9
31266: ARRAY
31267: PUSH
31268: LD_INT 1
31270: ARRAY
31271: PPUSH
31272: LD_VAR 0 14
31276: PUSH
31277: LD_VAR 0 9
31281: ARRAY
31282: PUSH
31283: LD_INT 2
31285: ARRAY
31286: PPUSH
31287: CALL_OW 428
31291: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
31292: LD_VAR 0 14
31296: PUSH
31297: LD_VAR 0 9
31301: ARRAY
31302: PUSH
31303: LD_INT 1
31305: ARRAY
31306: PPUSH
31307: LD_VAR 0 14
31311: PUSH
31312: LD_VAR 0 9
31316: ARRAY
31317: PUSH
31318: LD_INT 2
31320: ARRAY
31321: PPUSH
31322: CALL_OW 351
31326: PUSH
31327: LD_VAR 0 14
31331: PUSH
31332: LD_VAR 0 9
31336: ARRAY
31337: PUSH
31338: LD_INT 1
31340: ARRAY
31341: PPUSH
31342: LD_VAR 0 14
31346: PUSH
31347: LD_VAR 0 9
31351: ARRAY
31352: PUSH
31353: LD_INT 2
31355: ARRAY
31356: PPUSH
31357: CALL_OW 488
31361: NOT
31362: OR
31363: PUSH
31364: LD_VAR 0 13
31368: PPUSH
31369: CALL_OW 247
31373: PUSH
31374: LD_INT 3
31376: EQUAL
31377: OR
31378: IFFALSE 31384
// exit ;
31380: POP
31381: POP
31382: GO 31928
// if not tmp then
31384: LD_VAR 0 13
31388: NOT
31389: IFFALSE 31393
// continue ;
31391: GO 31249
// result := true ;
31393: LD_ADDR_VAR 0 8
31397: PUSH
31398: LD_INT 1
31400: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
31401: LD_VAR 0 6
31405: PUSH
31406: LD_VAR 0 13
31410: PPUSH
31411: CALL_OW 247
31415: PUSH
31416: LD_INT 2
31418: EQUAL
31419: AND
31420: PUSH
31421: LD_VAR 0 13
31425: PPUSH
31426: CALL_OW 263
31430: PUSH
31431: LD_INT 1
31433: EQUAL
31434: AND
31435: IFFALSE 31599
// begin if IsDrivenBy ( tmp ) then
31437: LD_VAR 0 13
31441: PPUSH
31442: CALL_OW 311
31446: IFFALSE 31450
// continue ;
31448: GO 31249
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
31450: LD_VAR 0 6
31454: PPUSH
31455: LD_INT 3
31457: PUSH
31458: LD_INT 60
31460: PUSH
31461: EMPTY
31462: LIST
31463: PUSH
31464: EMPTY
31465: LIST
31466: LIST
31467: PUSH
31468: LD_INT 3
31470: PUSH
31471: LD_INT 55
31473: PUSH
31474: EMPTY
31475: LIST
31476: PUSH
31477: EMPTY
31478: LIST
31479: LIST
31480: PUSH
31481: EMPTY
31482: LIST
31483: LIST
31484: PPUSH
31485: CALL_OW 72
31489: IFFALSE 31597
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
31491: LD_ADDR_VAR 0 18
31495: PUSH
31496: LD_VAR 0 6
31500: PPUSH
31501: LD_INT 3
31503: PUSH
31504: LD_INT 60
31506: PUSH
31507: EMPTY
31508: LIST
31509: PUSH
31510: EMPTY
31511: LIST
31512: LIST
31513: PUSH
31514: LD_INT 3
31516: PUSH
31517: LD_INT 55
31519: PUSH
31520: EMPTY
31521: LIST
31522: PUSH
31523: EMPTY
31524: LIST
31525: LIST
31526: PUSH
31527: EMPTY
31528: LIST
31529: LIST
31530: PPUSH
31531: CALL_OW 72
31535: PUSH
31536: LD_INT 1
31538: ARRAY
31539: ST_TO_ADDR
// if IsInUnit ( driver ) then
31540: LD_VAR 0 18
31544: PPUSH
31545: CALL_OW 310
31549: IFFALSE 31560
// ComExit ( driver ) ;
31551: LD_VAR 0 18
31555: PPUSH
31556: CALL 56349 0 1
// AddComEnterUnit ( driver , tmp ) ;
31560: LD_VAR 0 18
31564: PPUSH
31565: LD_VAR 0 13
31569: PPUSH
31570: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
31574: LD_VAR 0 18
31578: PPUSH
31579: LD_VAR 0 7
31583: PPUSH
31584: CALL_OW 173
// AddComExitVehicle ( driver ) ;
31588: LD_VAR 0 18
31592: PPUSH
31593: CALL_OW 181
// end ; continue ;
31597: GO 31249
// end ; if not cleaners or not tmp in cleaners then
31599: LD_VAR 0 6
31603: NOT
31604: PUSH
31605: LD_VAR 0 13
31609: PUSH
31610: LD_VAR 0 6
31614: IN
31615: NOT
31616: OR
31617: IFFALSE 31924
// begin if dep then
31619: LD_VAR 0 17
31623: IFFALSE 31759
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
31625: LD_ADDR_VAR 0 16
31629: PUSH
31630: LD_VAR 0 17
31634: PUSH
31635: LD_INT 1
31637: ARRAY
31638: PPUSH
31639: CALL_OW 250
31643: PPUSH
31644: LD_VAR 0 17
31648: PUSH
31649: LD_INT 1
31651: ARRAY
31652: PPUSH
31653: CALL_OW 254
31657: PPUSH
31658: LD_INT 5
31660: PPUSH
31661: CALL_OW 272
31665: PUSH
31666: LD_VAR 0 17
31670: PUSH
31671: LD_INT 1
31673: ARRAY
31674: PPUSH
31675: CALL_OW 251
31679: PPUSH
31680: LD_VAR 0 17
31684: PUSH
31685: LD_INT 1
31687: ARRAY
31688: PPUSH
31689: CALL_OW 254
31693: PPUSH
31694: LD_INT 5
31696: PPUSH
31697: CALL_OW 273
31701: PUSH
31702: EMPTY
31703: LIST
31704: LIST
31705: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
31706: LD_VAR 0 16
31710: PUSH
31711: LD_INT 1
31713: ARRAY
31714: PPUSH
31715: LD_VAR 0 16
31719: PUSH
31720: LD_INT 2
31722: ARRAY
31723: PPUSH
31724: CALL_OW 488
31728: IFFALSE 31759
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
31730: LD_VAR 0 13
31734: PPUSH
31735: LD_VAR 0 16
31739: PUSH
31740: LD_INT 1
31742: ARRAY
31743: PPUSH
31744: LD_VAR 0 16
31748: PUSH
31749: LD_INT 2
31751: ARRAY
31752: PPUSH
31753: CALL_OW 111
// continue ;
31757: GO 31249
// end ; end ; r := GetDir ( tmp ) ;
31759: LD_ADDR_VAR 0 15
31763: PUSH
31764: LD_VAR 0 13
31768: PPUSH
31769: CALL_OW 254
31773: ST_TO_ADDR
// if r = 5 then
31774: LD_VAR 0 15
31778: PUSH
31779: LD_INT 5
31781: EQUAL
31782: IFFALSE 31792
// r := 0 ;
31784: LD_ADDR_VAR 0 15
31788: PUSH
31789: LD_INT 0
31791: ST_TO_ADDR
// for j = r to 5 do
31792: LD_ADDR_VAR 0 10
31796: PUSH
31797: DOUBLE
31798: LD_VAR 0 15
31802: DEC
31803: ST_TO_ADDR
31804: LD_INT 5
31806: PUSH
31807: FOR_TO
31808: IFFALSE 31922
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
31810: LD_ADDR_VAR 0 11
31814: PUSH
31815: LD_VAR 0 13
31819: PPUSH
31820: CALL_OW 250
31824: PPUSH
31825: LD_VAR 0 10
31829: PPUSH
31830: LD_INT 2
31832: PPUSH
31833: CALL_OW 272
31837: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
31838: LD_ADDR_VAR 0 12
31842: PUSH
31843: LD_VAR 0 13
31847: PPUSH
31848: CALL_OW 251
31852: PPUSH
31853: LD_VAR 0 10
31857: PPUSH
31858: LD_INT 2
31860: PPUSH
31861: CALL_OW 273
31865: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
31866: LD_VAR 0 11
31870: PPUSH
31871: LD_VAR 0 12
31875: PPUSH
31876: CALL_OW 488
31880: PUSH
31881: LD_VAR 0 11
31885: PPUSH
31886: LD_VAR 0 12
31890: PPUSH
31891: CALL_OW 428
31895: NOT
31896: AND
31897: IFFALSE 31920
// begin ComMoveXY ( tmp , _x , _y ) ;
31899: LD_VAR 0 13
31903: PPUSH
31904: LD_VAR 0 11
31908: PPUSH
31909: LD_VAR 0 12
31913: PPUSH
31914: CALL_OW 111
// break ;
31918: GO 31922
// end ; end ;
31920: GO 31807
31922: POP
31923: POP
// end ; end ;
31924: GO 31249
31926: POP
31927: POP
// end ;
31928: LD_VAR 0 8
31932: RET
// export function BuildingTechInvented ( side , btype ) ; begin
31933: LD_INT 0
31935: PPUSH
// result := true ;
31936: LD_ADDR_VAR 0 3
31940: PUSH
31941: LD_INT 1
31943: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
31944: LD_VAR 0 2
31948: PUSH
31949: LD_INT 24
31951: DOUBLE
31952: EQUAL
31953: IFTRUE 31963
31955: LD_INT 33
31957: DOUBLE
31958: EQUAL
31959: IFTRUE 31963
31961: GO 31988
31963: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
31964: LD_ADDR_VAR 0 3
31968: PUSH
31969: LD_INT 32
31971: PPUSH
31972: LD_VAR 0 1
31976: PPUSH
31977: CALL_OW 321
31981: PUSH
31982: LD_INT 2
31984: EQUAL
31985: ST_TO_ADDR
31986: GO 32308
31988: LD_INT 20
31990: DOUBLE
31991: EQUAL
31992: IFTRUE 31996
31994: GO 32021
31996: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
31997: LD_ADDR_VAR 0 3
32001: PUSH
32002: LD_INT 6
32004: PPUSH
32005: LD_VAR 0 1
32009: PPUSH
32010: CALL_OW 321
32014: PUSH
32015: LD_INT 2
32017: EQUAL
32018: ST_TO_ADDR
32019: GO 32308
32021: LD_INT 22
32023: DOUBLE
32024: EQUAL
32025: IFTRUE 32035
32027: LD_INT 36
32029: DOUBLE
32030: EQUAL
32031: IFTRUE 32035
32033: GO 32060
32035: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
32036: LD_ADDR_VAR 0 3
32040: PUSH
32041: LD_INT 15
32043: PPUSH
32044: LD_VAR 0 1
32048: PPUSH
32049: CALL_OW 321
32053: PUSH
32054: LD_INT 2
32056: EQUAL
32057: ST_TO_ADDR
32058: GO 32308
32060: LD_INT 30
32062: DOUBLE
32063: EQUAL
32064: IFTRUE 32068
32066: GO 32093
32068: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
32069: LD_ADDR_VAR 0 3
32073: PUSH
32074: LD_INT 20
32076: PPUSH
32077: LD_VAR 0 1
32081: PPUSH
32082: CALL_OW 321
32086: PUSH
32087: LD_INT 2
32089: EQUAL
32090: ST_TO_ADDR
32091: GO 32308
32093: LD_INT 28
32095: DOUBLE
32096: EQUAL
32097: IFTRUE 32107
32099: LD_INT 21
32101: DOUBLE
32102: EQUAL
32103: IFTRUE 32107
32105: GO 32132
32107: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
32108: LD_ADDR_VAR 0 3
32112: PUSH
32113: LD_INT 21
32115: PPUSH
32116: LD_VAR 0 1
32120: PPUSH
32121: CALL_OW 321
32125: PUSH
32126: LD_INT 2
32128: EQUAL
32129: ST_TO_ADDR
32130: GO 32308
32132: LD_INT 16
32134: DOUBLE
32135: EQUAL
32136: IFTRUE 32140
32138: GO 32167
32140: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
32141: LD_ADDR_VAR 0 3
32145: PUSH
32146: LD_EXP 169
32150: PPUSH
32151: LD_VAR 0 1
32155: PPUSH
32156: CALL_OW 321
32160: PUSH
32161: LD_INT 2
32163: EQUAL
32164: ST_TO_ADDR
32165: GO 32308
32167: LD_INT 19
32169: DOUBLE
32170: EQUAL
32171: IFTRUE 32181
32173: LD_INT 23
32175: DOUBLE
32176: EQUAL
32177: IFTRUE 32181
32179: GO 32208
32181: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
32182: LD_ADDR_VAR 0 3
32186: PUSH
32187: LD_EXP 168
32191: PPUSH
32192: LD_VAR 0 1
32196: PPUSH
32197: CALL_OW 321
32201: PUSH
32202: LD_INT 2
32204: EQUAL
32205: ST_TO_ADDR
32206: GO 32308
32208: LD_INT 17
32210: DOUBLE
32211: EQUAL
32212: IFTRUE 32216
32214: GO 32241
32216: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
32217: LD_ADDR_VAR 0 3
32221: PUSH
32222: LD_INT 39
32224: PPUSH
32225: LD_VAR 0 1
32229: PPUSH
32230: CALL_OW 321
32234: PUSH
32235: LD_INT 2
32237: EQUAL
32238: ST_TO_ADDR
32239: GO 32308
32241: LD_INT 18
32243: DOUBLE
32244: EQUAL
32245: IFTRUE 32249
32247: GO 32274
32249: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
32250: LD_ADDR_VAR 0 3
32254: PUSH
32255: LD_INT 40
32257: PPUSH
32258: LD_VAR 0 1
32262: PPUSH
32263: CALL_OW 321
32267: PUSH
32268: LD_INT 2
32270: EQUAL
32271: ST_TO_ADDR
32272: GO 32308
32274: LD_INT 27
32276: DOUBLE
32277: EQUAL
32278: IFTRUE 32282
32280: GO 32307
32282: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
32283: LD_ADDR_VAR 0 3
32287: PUSH
32288: LD_INT 35
32290: PPUSH
32291: LD_VAR 0 1
32295: PPUSH
32296: CALL_OW 321
32300: PUSH
32301: LD_INT 2
32303: EQUAL
32304: ST_TO_ADDR
32305: GO 32308
32307: POP
// end ;
32308: LD_VAR 0 3
32312: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
32313: LD_INT 0
32315: PPUSH
32316: PPUSH
32317: PPUSH
32318: PPUSH
32319: PPUSH
32320: PPUSH
32321: PPUSH
32322: PPUSH
32323: PPUSH
32324: PPUSH
32325: PPUSH
// result := false ;
32326: LD_ADDR_VAR 0 6
32330: PUSH
32331: LD_INT 0
32333: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
32334: LD_VAR 0 1
32338: NOT
32339: PUSH
32340: LD_VAR 0 1
32344: PPUSH
32345: CALL_OW 266
32349: PUSH
32350: LD_INT 0
32352: PUSH
32353: LD_INT 1
32355: PUSH
32356: EMPTY
32357: LIST
32358: LIST
32359: IN
32360: NOT
32361: OR
32362: PUSH
32363: LD_VAR 0 2
32367: NOT
32368: OR
32369: PUSH
32370: LD_VAR 0 5
32374: PUSH
32375: LD_INT 0
32377: PUSH
32378: LD_INT 1
32380: PUSH
32381: LD_INT 2
32383: PUSH
32384: LD_INT 3
32386: PUSH
32387: LD_INT 4
32389: PUSH
32390: LD_INT 5
32392: PUSH
32393: EMPTY
32394: LIST
32395: LIST
32396: LIST
32397: LIST
32398: LIST
32399: LIST
32400: IN
32401: NOT
32402: OR
32403: PUSH
32404: LD_VAR 0 3
32408: PPUSH
32409: LD_VAR 0 4
32413: PPUSH
32414: CALL_OW 488
32418: NOT
32419: OR
32420: IFFALSE 32424
// exit ;
32422: GO 33160
// side := GetSide ( depot ) ;
32424: LD_ADDR_VAR 0 9
32428: PUSH
32429: LD_VAR 0 1
32433: PPUSH
32434: CALL_OW 255
32438: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
32439: LD_VAR 0 9
32443: PPUSH
32444: LD_VAR 0 2
32448: PPUSH
32449: CALL 31933 0 2
32453: NOT
32454: IFFALSE 32458
// exit ;
32456: GO 33160
// pom := GetBase ( depot ) ;
32458: LD_ADDR_VAR 0 10
32462: PUSH
32463: LD_VAR 0 1
32467: PPUSH
32468: CALL_OW 274
32472: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
32473: LD_ADDR_VAR 0 11
32477: PUSH
32478: LD_VAR 0 2
32482: PPUSH
32483: LD_VAR 0 1
32487: PPUSH
32488: CALL_OW 248
32492: PPUSH
32493: CALL_OW 450
32497: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
32498: LD_VAR 0 10
32502: PPUSH
32503: LD_INT 1
32505: PPUSH
32506: CALL_OW 275
32510: PUSH
32511: LD_VAR 0 11
32515: PUSH
32516: LD_INT 1
32518: ARRAY
32519: GREATEREQUAL
32520: PUSH
32521: LD_VAR 0 10
32525: PPUSH
32526: LD_INT 2
32528: PPUSH
32529: CALL_OW 275
32533: PUSH
32534: LD_VAR 0 11
32538: PUSH
32539: LD_INT 2
32541: ARRAY
32542: GREATEREQUAL
32543: AND
32544: PUSH
32545: LD_VAR 0 10
32549: PPUSH
32550: LD_INT 3
32552: PPUSH
32553: CALL_OW 275
32557: PUSH
32558: LD_VAR 0 11
32562: PUSH
32563: LD_INT 3
32565: ARRAY
32566: GREATEREQUAL
32567: AND
32568: NOT
32569: IFFALSE 32573
// exit ;
32571: GO 33160
// if GetBType ( depot ) = b_depot then
32573: LD_VAR 0 1
32577: PPUSH
32578: CALL_OW 266
32582: PUSH
32583: LD_INT 0
32585: EQUAL
32586: IFFALSE 32598
// dist := 28 else
32588: LD_ADDR_VAR 0 14
32592: PUSH
32593: LD_INT 28
32595: ST_TO_ADDR
32596: GO 32606
// dist := 36 ;
32598: LD_ADDR_VAR 0 14
32602: PUSH
32603: LD_INT 36
32605: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
32606: LD_VAR 0 1
32610: PPUSH
32611: LD_VAR 0 3
32615: PPUSH
32616: LD_VAR 0 4
32620: PPUSH
32621: CALL_OW 297
32625: PUSH
32626: LD_VAR 0 14
32630: GREATER
32631: IFFALSE 32635
// exit ;
32633: GO 33160
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
32635: LD_ADDR_VAR 0 12
32639: PUSH
32640: LD_VAR 0 2
32644: PPUSH
32645: LD_VAR 0 3
32649: PPUSH
32650: LD_VAR 0 4
32654: PPUSH
32655: LD_VAR 0 5
32659: PPUSH
32660: LD_VAR 0 1
32664: PPUSH
32665: CALL_OW 248
32669: PPUSH
32670: LD_INT 0
32672: PPUSH
32673: CALL 33165 0 6
32677: ST_TO_ADDR
// if not hexes then
32678: LD_VAR 0 12
32682: NOT
32683: IFFALSE 32687
// exit ;
32685: GO 33160
// hex := GetHexInfo ( x , y ) ;
32687: LD_ADDR_VAR 0 15
32691: PUSH
32692: LD_VAR 0 3
32696: PPUSH
32697: LD_VAR 0 4
32701: PPUSH
32702: CALL_OW 546
32706: ST_TO_ADDR
// if hex [ 1 ] then
32707: LD_VAR 0 15
32711: PUSH
32712: LD_INT 1
32714: ARRAY
32715: IFFALSE 32719
// exit ;
32717: GO 33160
// height := hex [ 2 ] ;
32719: LD_ADDR_VAR 0 13
32723: PUSH
32724: LD_VAR 0 15
32728: PUSH
32729: LD_INT 2
32731: ARRAY
32732: ST_TO_ADDR
// for i = 1 to hexes do
32733: LD_ADDR_VAR 0 7
32737: PUSH
32738: DOUBLE
32739: LD_INT 1
32741: DEC
32742: ST_TO_ADDR
32743: LD_VAR 0 12
32747: PUSH
32748: FOR_TO
32749: IFFALSE 33079
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
32751: LD_VAR 0 12
32755: PUSH
32756: LD_VAR 0 7
32760: ARRAY
32761: PUSH
32762: LD_INT 1
32764: ARRAY
32765: PPUSH
32766: LD_VAR 0 12
32770: PUSH
32771: LD_VAR 0 7
32775: ARRAY
32776: PUSH
32777: LD_INT 2
32779: ARRAY
32780: PPUSH
32781: CALL_OW 488
32785: NOT
32786: PUSH
32787: LD_VAR 0 12
32791: PUSH
32792: LD_VAR 0 7
32796: ARRAY
32797: PUSH
32798: LD_INT 1
32800: ARRAY
32801: PPUSH
32802: LD_VAR 0 12
32806: PUSH
32807: LD_VAR 0 7
32811: ARRAY
32812: PUSH
32813: LD_INT 2
32815: ARRAY
32816: PPUSH
32817: CALL_OW 428
32821: PUSH
32822: LD_INT 0
32824: GREATER
32825: OR
32826: PUSH
32827: LD_VAR 0 12
32831: PUSH
32832: LD_VAR 0 7
32836: ARRAY
32837: PUSH
32838: LD_INT 1
32840: ARRAY
32841: PPUSH
32842: LD_VAR 0 12
32846: PUSH
32847: LD_VAR 0 7
32851: ARRAY
32852: PUSH
32853: LD_INT 2
32855: ARRAY
32856: PPUSH
32857: CALL_OW 351
32861: OR
32862: IFFALSE 32868
// exit ;
32864: POP
32865: POP
32866: GO 33160
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
32868: LD_ADDR_VAR 0 8
32872: PUSH
32873: LD_VAR 0 12
32877: PUSH
32878: LD_VAR 0 7
32882: ARRAY
32883: PUSH
32884: LD_INT 1
32886: ARRAY
32887: PPUSH
32888: LD_VAR 0 12
32892: PUSH
32893: LD_VAR 0 7
32897: ARRAY
32898: PUSH
32899: LD_INT 2
32901: ARRAY
32902: PPUSH
32903: CALL_OW 546
32907: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
32908: LD_VAR 0 8
32912: PUSH
32913: LD_INT 1
32915: ARRAY
32916: PUSH
32917: LD_VAR 0 8
32921: PUSH
32922: LD_INT 2
32924: ARRAY
32925: PUSH
32926: LD_VAR 0 13
32930: PUSH
32931: LD_INT 2
32933: PLUS
32934: GREATER
32935: OR
32936: PUSH
32937: LD_VAR 0 8
32941: PUSH
32942: LD_INT 2
32944: ARRAY
32945: PUSH
32946: LD_VAR 0 13
32950: PUSH
32951: LD_INT 2
32953: MINUS
32954: LESS
32955: OR
32956: PUSH
32957: LD_VAR 0 8
32961: PUSH
32962: LD_INT 3
32964: ARRAY
32965: PUSH
32966: LD_INT 0
32968: PUSH
32969: LD_INT 8
32971: PUSH
32972: LD_INT 9
32974: PUSH
32975: LD_INT 10
32977: PUSH
32978: LD_INT 11
32980: PUSH
32981: LD_INT 12
32983: PUSH
32984: LD_INT 13
32986: PUSH
32987: LD_INT 16
32989: PUSH
32990: LD_INT 17
32992: PUSH
32993: LD_INT 18
32995: PUSH
32996: LD_INT 19
32998: PUSH
32999: LD_INT 20
33001: PUSH
33002: LD_INT 21
33004: PUSH
33005: EMPTY
33006: LIST
33007: LIST
33008: LIST
33009: LIST
33010: LIST
33011: LIST
33012: LIST
33013: LIST
33014: LIST
33015: LIST
33016: LIST
33017: LIST
33018: LIST
33019: IN
33020: NOT
33021: OR
33022: PUSH
33023: LD_VAR 0 8
33027: PUSH
33028: LD_INT 5
33030: ARRAY
33031: NOT
33032: OR
33033: PUSH
33034: LD_VAR 0 8
33038: PUSH
33039: LD_INT 6
33041: ARRAY
33042: PUSH
33043: LD_INT 1
33045: PUSH
33046: LD_INT 2
33048: PUSH
33049: LD_INT 7
33051: PUSH
33052: LD_INT 9
33054: PUSH
33055: LD_INT 10
33057: PUSH
33058: LD_INT 11
33060: PUSH
33061: EMPTY
33062: LIST
33063: LIST
33064: LIST
33065: LIST
33066: LIST
33067: LIST
33068: IN
33069: NOT
33070: OR
33071: IFFALSE 33077
// exit ;
33073: POP
33074: POP
33075: GO 33160
// end ;
33077: GO 32748
33079: POP
33080: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
33081: LD_VAR 0 9
33085: PPUSH
33086: LD_VAR 0 3
33090: PPUSH
33091: LD_VAR 0 4
33095: PPUSH
33096: LD_INT 20
33098: PPUSH
33099: CALL 25106 0 4
33103: PUSH
33104: LD_INT 4
33106: ARRAY
33107: IFFALSE 33111
// exit ;
33109: GO 33160
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
33111: LD_VAR 0 2
33115: PUSH
33116: LD_INT 29
33118: PUSH
33119: LD_INT 30
33121: PUSH
33122: EMPTY
33123: LIST
33124: LIST
33125: IN
33126: PUSH
33127: LD_VAR 0 3
33131: PPUSH
33132: LD_VAR 0 4
33136: PPUSH
33137: LD_VAR 0 9
33141: PPUSH
33142: CALL_OW 440
33146: NOT
33147: AND
33148: IFFALSE 33152
// exit ;
33150: GO 33160
// result := true ;
33152: LD_ADDR_VAR 0 6
33156: PUSH
33157: LD_INT 1
33159: ST_TO_ADDR
// end ;
33160: LD_VAR 0 6
33164: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
33165: LD_INT 0
33167: PPUSH
33168: PPUSH
33169: PPUSH
33170: PPUSH
33171: PPUSH
33172: PPUSH
33173: PPUSH
33174: PPUSH
33175: PPUSH
33176: PPUSH
33177: PPUSH
33178: PPUSH
33179: PPUSH
33180: PPUSH
33181: PPUSH
33182: PPUSH
33183: PPUSH
33184: PPUSH
33185: PPUSH
33186: PPUSH
33187: PPUSH
33188: PPUSH
33189: PPUSH
33190: PPUSH
33191: PPUSH
33192: PPUSH
33193: PPUSH
33194: PPUSH
33195: PPUSH
33196: PPUSH
33197: PPUSH
33198: PPUSH
33199: PPUSH
33200: PPUSH
33201: PPUSH
33202: PPUSH
33203: PPUSH
33204: PPUSH
33205: PPUSH
33206: PPUSH
33207: PPUSH
33208: PPUSH
33209: PPUSH
33210: PPUSH
33211: PPUSH
33212: PPUSH
33213: PPUSH
33214: PPUSH
33215: PPUSH
33216: PPUSH
33217: PPUSH
33218: PPUSH
33219: PPUSH
33220: PPUSH
33221: PPUSH
33222: PPUSH
33223: PPUSH
33224: PPUSH
// result = [ ] ;
33225: LD_ADDR_VAR 0 7
33229: PUSH
33230: EMPTY
33231: ST_TO_ADDR
// temp_list = [ ] ;
33232: LD_ADDR_VAR 0 9
33236: PUSH
33237: EMPTY
33238: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
33239: LD_VAR 0 4
33243: PUSH
33244: LD_INT 0
33246: PUSH
33247: LD_INT 1
33249: PUSH
33250: LD_INT 2
33252: PUSH
33253: LD_INT 3
33255: PUSH
33256: LD_INT 4
33258: PUSH
33259: LD_INT 5
33261: PUSH
33262: EMPTY
33263: LIST
33264: LIST
33265: LIST
33266: LIST
33267: LIST
33268: LIST
33269: IN
33270: NOT
33271: PUSH
33272: LD_VAR 0 1
33276: PUSH
33277: LD_INT 0
33279: PUSH
33280: LD_INT 1
33282: PUSH
33283: EMPTY
33284: LIST
33285: LIST
33286: IN
33287: PUSH
33288: LD_VAR 0 5
33292: PUSH
33293: LD_INT 1
33295: PUSH
33296: LD_INT 2
33298: PUSH
33299: LD_INT 3
33301: PUSH
33302: EMPTY
33303: LIST
33304: LIST
33305: LIST
33306: IN
33307: NOT
33308: AND
33309: OR
33310: IFFALSE 33314
// exit ;
33312: GO 51705
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
33314: LD_VAR 0 1
33318: PUSH
33319: LD_INT 6
33321: PUSH
33322: LD_INT 7
33324: PUSH
33325: LD_INT 8
33327: PUSH
33328: LD_INT 13
33330: PUSH
33331: LD_INT 12
33333: PUSH
33334: LD_INT 15
33336: PUSH
33337: LD_INT 11
33339: PUSH
33340: LD_INT 14
33342: PUSH
33343: LD_INT 10
33345: PUSH
33346: EMPTY
33347: LIST
33348: LIST
33349: LIST
33350: LIST
33351: LIST
33352: LIST
33353: LIST
33354: LIST
33355: LIST
33356: IN
33357: IFFALSE 33367
// btype = b_lab ;
33359: LD_ADDR_VAR 0 1
33363: PUSH
33364: LD_INT 6
33366: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
33367: LD_VAR 0 6
33371: PUSH
33372: LD_INT 0
33374: PUSH
33375: LD_INT 1
33377: PUSH
33378: LD_INT 2
33380: PUSH
33381: EMPTY
33382: LIST
33383: LIST
33384: LIST
33385: IN
33386: NOT
33387: PUSH
33388: LD_VAR 0 1
33392: PUSH
33393: LD_INT 0
33395: PUSH
33396: LD_INT 1
33398: PUSH
33399: LD_INT 2
33401: PUSH
33402: LD_INT 3
33404: PUSH
33405: LD_INT 6
33407: PUSH
33408: LD_INT 36
33410: PUSH
33411: LD_INT 4
33413: PUSH
33414: LD_INT 5
33416: PUSH
33417: LD_INT 31
33419: PUSH
33420: LD_INT 32
33422: PUSH
33423: LD_INT 33
33425: PUSH
33426: EMPTY
33427: LIST
33428: LIST
33429: LIST
33430: LIST
33431: LIST
33432: LIST
33433: LIST
33434: LIST
33435: LIST
33436: LIST
33437: LIST
33438: IN
33439: NOT
33440: PUSH
33441: LD_VAR 0 6
33445: PUSH
33446: LD_INT 1
33448: EQUAL
33449: AND
33450: OR
33451: PUSH
33452: LD_VAR 0 1
33456: PUSH
33457: LD_INT 2
33459: PUSH
33460: LD_INT 3
33462: PUSH
33463: EMPTY
33464: LIST
33465: LIST
33466: IN
33467: NOT
33468: PUSH
33469: LD_VAR 0 6
33473: PUSH
33474: LD_INT 2
33476: EQUAL
33477: AND
33478: OR
33479: IFFALSE 33489
// mode = 0 ;
33481: LD_ADDR_VAR 0 6
33485: PUSH
33486: LD_INT 0
33488: ST_TO_ADDR
// case mode of 0 :
33489: LD_VAR 0 6
33493: PUSH
33494: LD_INT 0
33496: DOUBLE
33497: EQUAL
33498: IFTRUE 33502
33500: GO 44955
33502: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
33503: LD_ADDR_VAR 0 11
33507: PUSH
33508: LD_INT 0
33510: PUSH
33511: LD_INT 0
33513: PUSH
33514: EMPTY
33515: LIST
33516: LIST
33517: PUSH
33518: LD_INT 0
33520: PUSH
33521: LD_INT 1
33523: NEG
33524: PUSH
33525: EMPTY
33526: LIST
33527: LIST
33528: PUSH
33529: LD_INT 1
33531: PUSH
33532: LD_INT 0
33534: PUSH
33535: EMPTY
33536: LIST
33537: LIST
33538: PUSH
33539: LD_INT 1
33541: PUSH
33542: LD_INT 1
33544: PUSH
33545: EMPTY
33546: LIST
33547: LIST
33548: PUSH
33549: LD_INT 0
33551: PUSH
33552: LD_INT 1
33554: PUSH
33555: EMPTY
33556: LIST
33557: LIST
33558: PUSH
33559: LD_INT 1
33561: NEG
33562: PUSH
33563: LD_INT 0
33565: PUSH
33566: EMPTY
33567: LIST
33568: LIST
33569: PUSH
33570: LD_INT 1
33572: NEG
33573: PUSH
33574: LD_INT 1
33576: NEG
33577: PUSH
33578: EMPTY
33579: LIST
33580: LIST
33581: PUSH
33582: LD_INT 1
33584: NEG
33585: PUSH
33586: LD_INT 2
33588: NEG
33589: PUSH
33590: EMPTY
33591: LIST
33592: LIST
33593: PUSH
33594: LD_INT 0
33596: PUSH
33597: LD_INT 2
33599: NEG
33600: PUSH
33601: EMPTY
33602: LIST
33603: LIST
33604: PUSH
33605: LD_INT 1
33607: PUSH
33608: LD_INT 1
33610: NEG
33611: PUSH
33612: EMPTY
33613: LIST
33614: LIST
33615: PUSH
33616: LD_INT 1
33618: PUSH
33619: LD_INT 2
33621: PUSH
33622: EMPTY
33623: LIST
33624: LIST
33625: PUSH
33626: LD_INT 0
33628: PUSH
33629: LD_INT 2
33631: PUSH
33632: EMPTY
33633: LIST
33634: LIST
33635: PUSH
33636: LD_INT 1
33638: NEG
33639: PUSH
33640: LD_INT 1
33642: PUSH
33643: EMPTY
33644: LIST
33645: LIST
33646: PUSH
33647: LD_INT 1
33649: PUSH
33650: LD_INT 3
33652: PUSH
33653: EMPTY
33654: LIST
33655: LIST
33656: PUSH
33657: LD_INT 0
33659: PUSH
33660: LD_INT 3
33662: PUSH
33663: EMPTY
33664: LIST
33665: LIST
33666: PUSH
33667: LD_INT 1
33669: NEG
33670: PUSH
33671: LD_INT 2
33673: PUSH
33674: EMPTY
33675: LIST
33676: LIST
33677: PUSH
33678: EMPTY
33679: LIST
33680: LIST
33681: LIST
33682: LIST
33683: LIST
33684: LIST
33685: LIST
33686: LIST
33687: LIST
33688: LIST
33689: LIST
33690: LIST
33691: LIST
33692: LIST
33693: LIST
33694: LIST
33695: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
33696: LD_ADDR_VAR 0 12
33700: PUSH
33701: LD_INT 0
33703: PUSH
33704: LD_INT 0
33706: PUSH
33707: EMPTY
33708: LIST
33709: LIST
33710: PUSH
33711: LD_INT 0
33713: PUSH
33714: LD_INT 1
33716: NEG
33717: PUSH
33718: EMPTY
33719: LIST
33720: LIST
33721: PUSH
33722: LD_INT 1
33724: PUSH
33725: LD_INT 0
33727: PUSH
33728: EMPTY
33729: LIST
33730: LIST
33731: PUSH
33732: LD_INT 1
33734: PUSH
33735: LD_INT 1
33737: PUSH
33738: EMPTY
33739: LIST
33740: LIST
33741: PUSH
33742: LD_INT 0
33744: PUSH
33745: LD_INT 1
33747: PUSH
33748: EMPTY
33749: LIST
33750: LIST
33751: PUSH
33752: LD_INT 1
33754: NEG
33755: PUSH
33756: LD_INT 0
33758: PUSH
33759: EMPTY
33760: LIST
33761: LIST
33762: PUSH
33763: LD_INT 1
33765: NEG
33766: PUSH
33767: LD_INT 1
33769: NEG
33770: PUSH
33771: EMPTY
33772: LIST
33773: LIST
33774: PUSH
33775: LD_INT 1
33777: PUSH
33778: LD_INT 1
33780: NEG
33781: PUSH
33782: EMPTY
33783: LIST
33784: LIST
33785: PUSH
33786: LD_INT 2
33788: PUSH
33789: LD_INT 0
33791: PUSH
33792: EMPTY
33793: LIST
33794: LIST
33795: PUSH
33796: LD_INT 2
33798: PUSH
33799: LD_INT 1
33801: PUSH
33802: EMPTY
33803: LIST
33804: LIST
33805: PUSH
33806: LD_INT 1
33808: NEG
33809: PUSH
33810: LD_INT 1
33812: PUSH
33813: EMPTY
33814: LIST
33815: LIST
33816: PUSH
33817: LD_INT 2
33819: NEG
33820: PUSH
33821: LD_INT 0
33823: PUSH
33824: EMPTY
33825: LIST
33826: LIST
33827: PUSH
33828: LD_INT 2
33830: NEG
33831: PUSH
33832: LD_INT 1
33834: NEG
33835: PUSH
33836: EMPTY
33837: LIST
33838: LIST
33839: PUSH
33840: LD_INT 2
33842: NEG
33843: PUSH
33844: LD_INT 1
33846: PUSH
33847: EMPTY
33848: LIST
33849: LIST
33850: PUSH
33851: LD_INT 3
33853: NEG
33854: PUSH
33855: LD_INT 0
33857: PUSH
33858: EMPTY
33859: LIST
33860: LIST
33861: PUSH
33862: LD_INT 3
33864: NEG
33865: PUSH
33866: LD_INT 1
33868: NEG
33869: PUSH
33870: EMPTY
33871: LIST
33872: LIST
33873: PUSH
33874: EMPTY
33875: LIST
33876: LIST
33877: LIST
33878: LIST
33879: LIST
33880: LIST
33881: LIST
33882: LIST
33883: LIST
33884: LIST
33885: LIST
33886: LIST
33887: LIST
33888: LIST
33889: LIST
33890: LIST
33891: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
33892: LD_ADDR_VAR 0 13
33896: PUSH
33897: LD_INT 0
33899: PUSH
33900: LD_INT 0
33902: PUSH
33903: EMPTY
33904: LIST
33905: LIST
33906: PUSH
33907: LD_INT 0
33909: PUSH
33910: LD_INT 1
33912: NEG
33913: PUSH
33914: EMPTY
33915: LIST
33916: LIST
33917: PUSH
33918: LD_INT 1
33920: PUSH
33921: LD_INT 0
33923: PUSH
33924: EMPTY
33925: LIST
33926: LIST
33927: PUSH
33928: LD_INT 1
33930: PUSH
33931: LD_INT 1
33933: PUSH
33934: EMPTY
33935: LIST
33936: LIST
33937: PUSH
33938: LD_INT 0
33940: PUSH
33941: LD_INT 1
33943: PUSH
33944: EMPTY
33945: LIST
33946: LIST
33947: PUSH
33948: LD_INT 1
33950: NEG
33951: PUSH
33952: LD_INT 0
33954: PUSH
33955: EMPTY
33956: LIST
33957: LIST
33958: PUSH
33959: LD_INT 1
33961: NEG
33962: PUSH
33963: LD_INT 1
33965: NEG
33966: PUSH
33967: EMPTY
33968: LIST
33969: LIST
33970: PUSH
33971: LD_INT 1
33973: NEG
33974: PUSH
33975: LD_INT 2
33977: NEG
33978: PUSH
33979: EMPTY
33980: LIST
33981: LIST
33982: PUSH
33983: LD_INT 2
33985: PUSH
33986: LD_INT 1
33988: PUSH
33989: EMPTY
33990: LIST
33991: LIST
33992: PUSH
33993: LD_INT 2
33995: PUSH
33996: LD_INT 2
33998: PUSH
33999: EMPTY
34000: LIST
34001: LIST
34002: PUSH
34003: LD_INT 1
34005: PUSH
34006: LD_INT 2
34008: PUSH
34009: EMPTY
34010: LIST
34011: LIST
34012: PUSH
34013: LD_INT 2
34015: NEG
34016: PUSH
34017: LD_INT 1
34019: NEG
34020: PUSH
34021: EMPTY
34022: LIST
34023: LIST
34024: PUSH
34025: LD_INT 2
34027: NEG
34028: PUSH
34029: LD_INT 2
34031: NEG
34032: PUSH
34033: EMPTY
34034: LIST
34035: LIST
34036: PUSH
34037: LD_INT 2
34039: NEG
34040: PUSH
34041: LD_INT 3
34043: NEG
34044: PUSH
34045: EMPTY
34046: LIST
34047: LIST
34048: PUSH
34049: LD_INT 3
34051: NEG
34052: PUSH
34053: LD_INT 2
34055: NEG
34056: PUSH
34057: EMPTY
34058: LIST
34059: LIST
34060: PUSH
34061: LD_INT 3
34063: NEG
34064: PUSH
34065: LD_INT 3
34067: NEG
34068: PUSH
34069: EMPTY
34070: LIST
34071: LIST
34072: PUSH
34073: EMPTY
34074: LIST
34075: LIST
34076: LIST
34077: LIST
34078: LIST
34079: LIST
34080: LIST
34081: LIST
34082: LIST
34083: LIST
34084: LIST
34085: LIST
34086: LIST
34087: LIST
34088: LIST
34089: LIST
34090: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
34091: LD_ADDR_VAR 0 14
34095: PUSH
34096: LD_INT 0
34098: PUSH
34099: LD_INT 0
34101: PUSH
34102: EMPTY
34103: LIST
34104: LIST
34105: PUSH
34106: LD_INT 0
34108: PUSH
34109: LD_INT 1
34111: NEG
34112: PUSH
34113: EMPTY
34114: LIST
34115: LIST
34116: PUSH
34117: LD_INT 1
34119: PUSH
34120: LD_INT 0
34122: PUSH
34123: EMPTY
34124: LIST
34125: LIST
34126: PUSH
34127: LD_INT 1
34129: PUSH
34130: LD_INT 1
34132: PUSH
34133: EMPTY
34134: LIST
34135: LIST
34136: PUSH
34137: LD_INT 0
34139: PUSH
34140: LD_INT 1
34142: PUSH
34143: EMPTY
34144: LIST
34145: LIST
34146: PUSH
34147: LD_INT 1
34149: NEG
34150: PUSH
34151: LD_INT 0
34153: PUSH
34154: EMPTY
34155: LIST
34156: LIST
34157: PUSH
34158: LD_INT 1
34160: NEG
34161: PUSH
34162: LD_INT 1
34164: NEG
34165: PUSH
34166: EMPTY
34167: LIST
34168: LIST
34169: PUSH
34170: LD_INT 1
34172: NEG
34173: PUSH
34174: LD_INT 2
34176: NEG
34177: PUSH
34178: EMPTY
34179: LIST
34180: LIST
34181: PUSH
34182: LD_INT 0
34184: PUSH
34185: LD_INT 2
34187: NEG
34188: PUSH
34189: EMPTY
34190: LIST
34191: LIST
34192: PUSH
34193: LD_INT 1
34195: PUSH
34196: LD_INT 1
34198: NEG
34199: PUSH
34200: EMPTY
34201: LIST
34202: LIST
34203: PUSH
34204: LD_INT 1
34206: PUSH
34207: LD_INT 2
34209: PUSH
34210: EMPTY
34211: LIST
34212: LIST
34213: PUSH
34214: LD_INT 0
34216: PUSH
34217: LD_INT 2
34219: PUSH
34220: EMPTY
34221: LIST
34222: LIST
34223: PUSH
34224: LD_INT 1
34226: NEG
34227: PUSH
34228: LD_INT 1
34230: PUSH
34231: EMPTY
34232: LIST
34233: LIST
34234: PUSH
34235: LD_INT 1
34237: NEG
34238: PUSH
34239: LD_INT 3
34241: NEG
34242: PUSH
34243: EMPTY
34244: LIST
34245: LIST
34246: PUSH
34247: LD_INT 0
34249: PUSH
34250: LD_INT 3
34252: NEG
34253: PUSH
34254: EMPTY
34255: LIST
34256: LIST
34257: PUSH
34258: LD_INT 1
34260: PUSH
34261: LD_INT 2
34263: NEG
34264: PUSH
34265: EMPTY
34266: LIST
34267: LIST
34268: PUSH
34269: EMPTY
34270: LIST
34271: LIST
34272: LIST
34273: LIST
34274: LIST
34275: LIST
34276: LIST
34277: LIST
34278: LIST
34279: LIST
34280: LIST
34281: LIST
34282: LIST
34283: LIST
34284: LIST
34285: LIST
34286: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
34287: LD_ADDR_VAR 0 15
34291: PUSH
34292: LD_INT 0
34294: PUSH
34295: LD_INT 0
34297: PUSH
34298: EMPTY
34299: LIST
34300: LIST
34301: PUSH
34302: LD_INT 0
34304: PUSH
34305: LD_INT 1
34307: NEG
34308: PUSH
34309: EMPTY
34310: LIST
34311: LIST
34312: PUSH
34313: LD_INT 1
34315: PUSH
34316: LD_INT 0
34318: PUSH
34319: EMPTY
34320: LIST
34321: LIST
34322: PUSH
34323: LD_INT 1
34325: PUSH
34326: LD_INT 1
34328: PUSH
34329: EMPTY
34330: LIST
34331: LIST
34332: PUSH
34333: LD_INT 0
34335: PUSH
34336: LD_INT 1
34338: PUSH
34339: EMPTY
34340: LIST
34341: LIST
34342: PUSH
34343: LD_INT 1
34345: NEG
34346: PUSH
34347: LD_INT 0
34349: PUSH
34350: EMPTY
34351: LIST
34352: LIST
34353: PUSH
34354: LD_INT 1
34356: NEG
34357: PUSH
34358: LD_INT 1
34360: NEG
34361: PUSH
34362: EMPTY
34363: LIST
34364: LIST
34365: PUSH
34366: LD_INT 1
34368: PUSH
34369: LD_INT 1
34371: NEG
34372: PUSH
34373: EMPTY
34374: LIST
34375: LIST
34376: PUSH
34377: LD_INT 2
34379: PUSH
34380: LD_INT 0
34382: PUSH
34383: EMPTY
34384: LIST
34385: LIST
34386: PUSH
34387: LD_INT 2
34389: PUSH
34390: LD_INT 1
34392: PUSH
34393: EMPTY
34394: LIST
34395: LIST
34396: PUSH
34397: LD_INT 1
34399: NEG
34400: PUSH
34401: LD_INT 1
34403: PUSH
34404: EMPTY
34405: LIST
34406: LIST
34407: PUSH
34408: LD_INT 2
34410: NEG
34411: PUSH
34412: LD_INT 0
34414: PUSH
34415: EMPTY
34416: LIST
34417: LIST
34418: PUSH
34419: LD_INT 2
34421: NEG
34422: PUSH
34423: LD_INT 1
34425: NEG
34426: PUSH
34427: EMPTY
34428: LIST
34429: LIST
34430: PUSH
34431: LD_INT 2
34433: PUSH
34434: LD_INT 1
34436: NEG
34437: PUSH
34438: EMPTY
34439: LIST
34440: LIST
34441: PUSH
34442: LD_INT 3
34444: PUSH
34445: LD_INT 0
34447: PUSH
34448: EMPTY
34449: LIST
34450: LIST
34451: PUSH
34452: LD_INT 3
34454: PUSH
34455: LD_INT 1
34457: PUSH
34458: EMPTY
34459: LIST
34460: LIST
34461: PUSH
34462: EMPTY
34463: LIST
34464: LIST
34465: LIST
34466: LIST
34467: LIST
34468: LIST
34469: LIST
34470: LIST
34471: LIST
34472: LIST
34473: LIST
34474: LIST
34475: LIST
34476: LIST
34477: LIST
34478: LIST
34479: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
34480: LD_ADDR_VAR 0 16
34484: PUSH
34485: LD_INT 0
34487: PUSH
34488: LD_INT 0
34490: PUSH
34491: EMPTY
34492: LIST
34493: LIST
34494: PUSH
34495: LD_INT 0
34497: PUSH
34498: LD_INT 1
34500: NEG
34501: PUSH
34502: EMPTY
34503: LIST
34504: LIST
34505: PUSH
34506: LD_INT 1
34508: PUSH
34509: LD_INT 0
34511: PUSH
34512: EMPTY
34513: LIST
34514: LIST
34515: PUSH
34516: LD_INT 1
34518: PUSH
34519: LD_INT 1
34521: PUSH
34522: EMPTY
34523: LIST
34524: LIST
34525: PUSH
34526: LD_INT 0
34528: PUSH
34529: LD_INT 1
34531: PUSH
34532: EMPTY
34533: LIST
34534: LIST
34535: PUSH
34536: LD_INT 1
34538: NEG
34539: PUSH
34540: LD_INT 0
34542: PUSH
34543: EMPTY
34544: LIST
34545: LIST
34546: PUSH
34547: LD_INT 1
34549: NEG
34550: PUSH
34551: LD_INT 1
34553: NEG
34554: PUSH
34555: EMPTY
34556: LIST
34557: LIST
34558: PUSH
34559: LD_INT 1
34561: NEG
34562: PUSH
34563: LD_INT 2
34565: NEG
34566: PUSH
34567: EMPTY
34568: LIST
34569: LIST
34570: PUSH
34571: LD_INT 2
34573: PUSH
34574: LD_INT 1
34576: PUSH
34577: EMPTY
34578: LIST
34579: LIST
34580: PUSH
34581: LD_INT 2
34583: PUSH
34584: LD_INT 2
34586: PUSH
34587: EMPTY
34588: LIST
34589: LIST
34590: PUSH
34591: LD_INT 1
34593: PUSH
34594: LD_INT 2
34596: PUSH
34597: EMPTY
34598: LIST
34599: LIST
34600: PUSH
34601: LD_INT 2
34603: NEG
34604: PUSH
34605: LD_INT 1
34607: NEG
34608: PUSH
34609: EMPTY
34610: LIST
34611: LIST
34612: PUSH
34613: LD_INT 2
34615: NEG
34616: PUSH
34617: LD_INT 2
34619: NEG
34620: PUSH
34621: EMPTY
34622: LIST
34623: LIST
34624: PUSH
34625: LD_INT 3
34627: PUSH
34628: LD_INT 2
34630: PUSH
34631: EMPTY
34632: LIST
34633: LIST
34634: PUSH
34635: LD_INT 3
34637: PUSH
34638: LD_INT 3
34640: PUSH
34641: EMPTY
34642: LIST
34643: LIST
34644: PUSH
34645: LD_INT 2
34647: PUSH
34648: LD_INT 3
34650: PUSH
34651: EMPTY
34652: LIST
34653: LIST
34654: PUSH
34655: EMPTY
34656: LIST
34657: LIST
34658: LIST
34659: LIST
34660: LIST
34661: LIST
34662: LIST
34663: LIST
34664: LIST
34665: LIST
34666: LIST
34667: LIST
34668: LIST
34669: LIST
34670: LIST
34671: LIST
34672: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
34673: LD_ADDR_VAR 0 17
34677: PUSH
34678: LD_INT 0
34680: PUSH
34681: LD_INT 0
34683: PUSH
34684: EMPTY
34685: LIST
34686: LIST
34687: PUSH
34688: LD_INT 0
34690: PUSH
34691: LD_INT 1
34693: NEG
34694: PUSH
34695: EMPTY
34696: LIST
34697: LIST
34698: PUSH
34699: LD_INT 1
34701: PUSH
34702: LD_INT 0
34704: PUSH
34705: EMPTY
34706: LIST
34707: LIST
34708: PUSH
34709: LD_INT 1
34711: PUSH
34712: LD_INT 1
34714: PUSH
34715: EMPTY
34716: LIST
34717: LIST
34718: PUSH
34719: LD_INT 0
34721: PUSH
34722: LD_INT 1
34724: PUSH
34725: EMPTY
34726: LIST
34727: LIST
34728: PUSH
34729: LD_INT 1
34731: NEG
34732: PUSH
34733: LD_INT 0
34735: PUSH
34736: EMPTY
34737: LIST
34738: LIST
34739: PUSH
34740: LD_INT 1
34742: NEG
34743: PUSH
34744: LD_INT 1
34746: NEG
34747: PUSH
34748: EMPTY
34749: LIST
34750: LIST
34751: PUSH
34752: LD_INT 1
34754: NEG
34755: PUSH
34756: LD_INT 2
34758: NEG
34759: PUSH
34760: EMPTY
34761: LIST
34762: LIST
34763: PUSH
34764: LD_INT 0
34766: PUSH
34767: LD_INT 2
34769: NEG
34770: PUSH
34771: EMPTY
34772: LIST
34773: LIST
34774: PUSH
34775: LD_INT 1
34777: PUSH
34778: LD_INT 1
34780: NEG
34781: PUSH
34782: EMPTY
34783: LIST
34784: LIST
34785: PUSH
34786: LD_INT 2
34788: PUSH
34789: LD_INT 0
34791: PUSH
34792: EMPTY
34793: LIST
34794: LIST
34795: PUSH
34796: LD_INT 2
34798: PUSH
34799: LD_INT 1
34801: PUSH
34802: EMPTY
34803: LIST
34804: LIST
34805: PUSH
34806: LD_INT 2
34808: PUSH
34809: LD_INT 2
34811: PUSH
34812: EMPTY
34813: LIST
34814: LIST
34815: PUSH
34816: LD_INT 1
34818: PUSH
34819: LD_INT 2
34821: PUSH
34822: EMPTY
34823: LIST
34824: LIST
34825: PUSH
34826: LD_INT 0
34828: PUSH
34829: LD_INT 2
34831: PUSH
34832: EMPTY
34833: LIST
34834: LIST
34835: PUSH
34836: LD_INT 1
34838: NEG
34839: PUSH
34840: LD_INT 1
34842: PUSH
34843: EMPTY
34844: LIST
34845: LIST
34846: PUSH
34847: LD_INT 2
34849: NEG
34850: PUSH
34851: LD_INT 0
34853: PUSH
34854: EMPTY
34855: LIST
34856: LIST
34857: PUSH
34858: LD_INT 2
34860: NEG
34861: PUSH
34862: LD_INT 1
34864: NEG
34865: PUSH
34866: EMPTY
34867: LIST
34868: LIST
34869: PUSH
34870: LD_INT 2
34872: NEG
34873: PUSH
34874: LD_INT 2
34876: NEG
34877: PUSH
34878: EMPTY
34879: LIST
34880: LIST
34881: PUSH
34882: EMPTY
34883: LIST
34884: LIST
34885: LIST
34886: LIST
34887: LIST
34888: LIST
34889: LIST
34890: LIST
34891: LIST
34892: LIST
34893: LIST
34894: LIST
34895: LIST
34896: LIST
34897: LIST
34898: LIST
34899: LIST
34900: LIST
34901: LIST
34902: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
34903: LD_ADDR_VAR 0 18
34907: PUSH
34908: LD_INT 0
34910: PUSH
34911: LD_INT 0
34913: PUSH
34914: EMPTY
34915: LIST
34916: LIST
34917: PUSH
34918: LD_INT 0
34920: PUSH
34921: LD_INT 1
34923: NEG
34924: PUSH
34925: EMPTY
34926: LIST
34927: LIST
34928: PUSH
34929: LD_INT 1
34931: PUSH
34932: LD_INT 0
34934: PUSH
34935: EMPTY
34936: LIST
34937: LIST
34938: PUSH
34939: LD_INT 1
34941: PUSH
34942: LD_INT 1
34944: PUSH
34945: EMPTY
34946: LIST
34947: LIST
34948: PUSH
34949: LD_INT 0
34951: PUSH
34952: LD_INT 1
34954: PUSH
34955: EMPTY
34956: LIST
34957: LIST
34958: PUSH
34959: LD_INT 1
34961: NEG
34962: PUSH
34963: LD_INT 0
34965: PUSH
34966: EMPTY
34967: LIST
34968: LIST
34969: PUSH
34970: LD_INT 1
34972: NEG
34973: PUSH
34974: LD_INT 1
34976: NEG
34977: PUSH
34978: EMPTY
34979: LIST
34980: LIST
34981: PUSH
34982: LD_INT 1
34984: NEG
34985: PUSH
34986: LD_INT 2
34988: NEG
34989: PUSH
34990: EMPTY
34991: LIST
34992: LIST
34993: PUSH
34994: LD_INT 0
34996: PUSH
34997: LD_INT 2
34999: NEG
35000: PUSH
35001: EMPTY
35002: LIST
35003: LIST
35004: PUSH
35005: LD_INT 1
35007: PUSH
35008: LD_INT 1
35010: NEG
35011: PUSH
35012: EMPTY
35013: LIST
35014: LIST
35015: PUSH
35016: LD_INT 2
35018: PUSH
35019: LD_INT 0
35021: PUSH
35022: EMPTY
35023: LIST
35024: LIST
35025: PUSH
35026: LD_INT 2
35028: PUSH
35029: LD_INT 1
35031: PUSH
35032: EMPTY
35033: LIST
35034: LIST
35035: PUSH
35036: LD_INT 2
35038: PUSH
35039: LD_INT 2
35041: PUSH
35042: EMPTY
35043: LIST
35044: LIST
35045: PUSH
35046: LD_INT 1
35048: PUSH
35049: LD_INT 2
35051: PUSH
35052: EMPTY
35053: LIST
35054: LIST
35055: PUSH
35056: LD_INT 0
35058: PUSH
35059: LD_INT 2
35061: PUSH
35062: EMPTY
35063: LIST
35064: LIST
35065: PUSH
35066: LD_INT 1
35068: NEG
35069: PUSH
35070: LD_INT 1
35072: PUSH
35073: EMPTY
35074: LIST
35075: LIST
35076: PUSH
35077: LD_INT 2
35079: NEG
35080: PUSH
35081: LD_INT 0
35083: PUSH
35084: EMPTY
35085: LIST
35086: LIST
35087: PUSH
35088: LD_INT 2
35090: NEG
35091: PUSH
35092: LD_INT 1
35094: NEG
35095: PUSH
35096: EMPTY
35097: LIST
35098: LIST
35099: PUSH
35100: LD_INT 2
35102: NEG
35103: PUSH
35104: LD_INT 2
35106: NEG
35107: PUSH
35108: EMPTY
35109: LIST
35110: LIST
35111: PUSH
35112: EMPTY
35113: LIST
35114: LIST
35115: LIST
35116: LIST
35117: LIST
35118: LIST
35119: LIST
35120: LIST
35121: LIST
35122: LIST
35123: LIST
35124: LIST
35125: LIST
35126: LIST
35127: LIST
35128: LIST
35129: LIST
35130: LIST
35131: LIST
35132: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
35133: LD_ADDR_VAR 0 19
35137: PUSH
35138: LD_INT 0
35140: PUSH
35141: LD_INT 0
35143: PUSH
35144: EMPTY
35145: LIST
35146: LIST
35147: PUSH
35148: LD_INT 0
35150: PUSH
35151: LD_INT 1
35153: NEG
35154: PUSH
35155: EMPTY
35156: LIST
35157: LIST
35158: PUSH
35159: LD_INT 1
35161: PUSH
35162: LD_INT 0
35164: PUSH
35165: EMPTY
35166: LIST
35167: LIST
35168: PUSH
35169: LD_INT 1
35171: PUSH
35172: LD_INT 1
35174: PUSH
35175: EMPTY
35176: LIST
35177: LIST
35178: PUSH
35179: LD_INT 0
35181: PUSH
35182: LD_INT 1
35184: PUSH
35185: EMPTY
35186: LIST
35187: LIST
35188: PUSH
35189: LD_INT 1
35191: NEG
35192: PUSH
35193: LD_INT 0
35195: PUSH
35196: EMPTY
35197: LIST
35198: LIST
35199: PUSH
35200: LD_INT 1
35202: NEG
35203: PUSH
35204: LD_INT 1
35206: NEG
35207: PUSH
35208: EMPTY
35209: LIST
35210: LIST
35211: PUSH
35212: LD_INT 1
35214: NEG
35215: PUSH
35216: LD_INT 2
35218: NEG
35219: PUSH
35220: EMPTY
35221: LIST
35222: LIST
35223: PUSH
35224: LD_INT 0
35226: PUSH
35227: LD_INT 2
35229: NEG
35230: PUSH
35231: EMPTY
35232: LIST
35233: LIST
35234: PUSH
35235: LD_INT 1
35237: PUSH
35238: LD_INT 1
35240: NEG
35241: PUSH
35242: EMPTY
35243: LIST
35244: LIST
35245: PUSH
35246: LD_INT 2
35248: PUSH
35249: LD_INT 0
35251: PUSH
35252: EMPTY
35253: LIST
35254: LIST
35255: PUSH
35256: LD_INT 2
35258: PUSH
35259: LD_INT 1
35261: PUSH
35262: EMPTY
35263: LIST
35264: LIST
35265: PUSH
35266: LD_INT 2
35268: PUSH
35269: LD_INT 2
35271: PUSH
35272: EMPTY
35273: LIST
35274: LIST
35275: PUSH
35276: LD_INT 1
35278: PUSH
35279: LD_INT 2
35281: PUSH
35282: EMPTY
35283: LIST
35284: LIST
35285: PUSH
35286: LD_INT 0
35288: PUSH
35289: LD_INT 2
35291: PUSH
35292: EMPTY
35293: LIST
35294: LIST
35295: PUSH
35296: LD_INT 1
35298: NEG
35299: PUSH
35300: LD_INT 1
35302: PUSH
35303: EMPTY
35304: LIST
35305: LIST
35306: PUSH
35307: LD_INT 2
35309: NEG
35310: PUSH
35311: LD_INT 0
35313: PUSH
35314: EMPTY
35315: LIST
35316: LIST
35317: PUSH
35318: LD_INT 2
35320: NEG
35321: PUSH
35322: LD_INT 1
35324: NEG
35325: PUSH
35326: EMPTY
35327: LIST
35328: LIST
35329: PUSH
35330: LD_INT 2
35332: NEG
35333: PUSH
35334: LD_INT 2
35336: NEG
35337: PUSH
35338: EMPTY
35339: LIST
35340: LIST
35341: PUSH
35342: EMPTY
35343: LIST
35344: LIST
35345: LIST
35346: LIST
35347: LIST
35348: LIST
35349: LIST
35350: LIST
35351: LIST
35352: LIST
35353: LIST
35354: LIST
35355: LIST
35356: LIST
35357: LIST
35358: LIST
35359: LIST
35360: LIST
35361: LIST
35362: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
35363: LD_ADDR_VAR 0 20
35367: PUSH
35368: LD_INT 0
35370: PUSH
35371: LD_INT 0
35373: PUSH
35374: EMPTY
35375: LIST
35376: LIST
35377: PUSH
35378: LD_INT 0
35380: PUSH
35381: LD_INT 1
35383: NEG
35384: PUSH
35385: EMPTY
35386: LIST
35387: LIST
35388: PUSH
35389: LD_INT 1
35391: PUSH
35392: LD_INT 0
35394: PUSH
35395: EMPTY
35396: LIST
35397: LIST
35398: PUSH
35399: LD_INT 1
35401: PUSH
35402: LD_INT 1
35404: PUSH
35405: EMPTY
35406: LIST
35407: LIST
35408: PUSH
35409: LD_INT 0
35411: PUSH
35412: LD_INT 1
35414: PUSH
35415: EMPTY
35416: LIST
35417: LIST
35418: PUSH
35419: LD_INT 1
35421: NEG
35422: PUSH
35423: LD_INT 0
35425: PUSH
35426: EMPTY
35427: LIST
35428: LIST
35429: PUSH
35430: LD_INT 1
35432: NEG
35433: PUSH
35434: LD_INT 1
35436: NEG
35437: PUSH
35438: EMPTY
35439: LIST
35440: LIST
35441: PUSH
35442: LD_INT 1
35444: NEG
35445: PUSH
35446: LD_INT 2
35448: NEG
35449: PUSH
35450: EMPTY
35451: LIST
35452: LIST
35453: PUSH
35454: LD_INT 0
35456: PUSH
35457: LD_INT 2
35459: NEG
35460: PUSH
35461: EMPTY
35462: LIST
35463: LIST
35464: PUSH
35465: LD_INT 1
35467: PUSH
35468: LD_INT 1
35470: NEG
35471: PUSH
35472: EMPTY
35473: LIST
35474: LIST
35475: PUSH
35476: LD_INT 2
35478: PUSH
35479: LD_INT 0
35481: PUSH
35482: EMPTY
35483: LIST
35484: LIST
35485: PUSH
35486: LD_INT 2
35488: PUSH
35489: LD_INT 1
35491: PUSH
35492: EMPTY
35493: LIST
35494: LIST
35495: PUSH
35496: LD_INT 2
35498: PUSH
35499: LD_INT 2
35501: PUSH
35502: EMPTY
35503: LIST
35504: LIST
35505: PUSH
35506: LD_INT 1
35508: PUSH
35509: LD_INT 2
35511: PUSH
35512: EMPTY
35513: LIST
35514: LIST
35515: PUSH
35516: LD_INT 0
35518: PUSH
35519: LD_INT 2
35521: PUSH
35522: EMPTY
35523: LIST
35524: LIST
35525: PUSH
35526: LD_INT 1
35528: NEG
35529: PUSH
35530: LD_INT 1
35532: PUSH
35533: EMPTY
35534: LIST
35535: LIST
35536: PUSH
35537: LD_INT 2
35539: NEG
35540: PUSH
35541: LD_INT 0
35543: PUSH
35544: EMPTY
35545: LIST
35546: LIST
35547: PUSH
35548: LD_INT 2
35550: NEG
35551: PUSH
35552: LD_INT 1
35554: NEG
35555: PUSH
35556: EMPTY
35557: LIST
35558: LIST
35559: PUSH
35560: LD_INT 2
35562: NEG
35563: PUSH
35564: LD_INT 2
35566: NEG
35567: PUSH
35568: EMPTY
35569: LIST
35570: LIST
35571: PUSH
35572: EMPTY
35573: LIST
35574: LIST
35575: LIST
35576: LIST
35577: LIST
35578: LIST
35579: LIST
35580: LIST
35581: LIST
35582: LIST
35583: LIST
35584: LIST
35585: LIST
35586: LIST
35587: LIST
35588: LIST
35589: LIST
35590: LIST
35591: LIST
35592: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
35593: LD_ADDR_VAR 0 21
35597: PUSH
35598: LD_INT 0
35600: PUSH
35601: LD_INT 0
35603: PUSH
35604: EMPTY
35605: LIST
35606: LIST
35607: PUSH
35608: LD_INT 0
35610: PUSH
35611: LD_INT 1
35613: NEG
35614: PUSH
35615: EMPTY
35616: LIST
35617: LIST
35618: PUSH
35619: LD_INT 1
35621: PUSH
35622: LD_INT 0
35624: PUSH
35625: EMPTY
35626: LIST
35627: LIST
35628: PUSH
35629: LD_INT 1
35631: PUSH
35632: LD_INT 1
35634: PUSH
35635: EMPTY
35636: LIST
35637: LIST
35638: PUSH
35639: LD_INT 0
35641: PUSH
35642: LD_INT 1
35644: PUSH
35645: EMPTY
35646: LIST
35647: LIST
35648: PUSH
35649: LD_INT 1
35651: NEG
35652: PUSH
35653: LD_INT 0
35655: PUSH
35656: EMPTY
35657: LIST
35658: LIST
35659: PUSH
35660: LD_INT 1
35662: NEG
35663: PUSH
35664: LD_INT 1
35666: NEG
35667: PUSH
35668: EMPTY
35669: LIST
35670: LIST
35671: PUSH
35672: LD_INT 1
35674: NEG
35675: PUSH
35676: LD_INT 2
35678: NEG
35679: PUSH
35680: EMPTY
35681: LIST
35682: LIST
35683: PUSH
35684: LD_INT 0
35686: PUSH
35687: LD_INT 2
35689: NEG
35690: PUSH
35691: EMPTY
35692: LIST
35693: LIST
35694: PUSH
35695: LD_INT 1
35697: PUSH
35698: LD_INT 1
35700: NEG
35701: PUSH
35702: EMPTY
35703: LIST
35704: LIST
35705: PUSH
35706: LD_INT 2
35708: PUSH
35709: LD_INT 0
35711: PUSH
35712: EMPTY
35713: LIST
35714: LIST
35715: PUSH
35716: LD_INT 2
35718: PUSH
35719: LD_INT 1
35721: PUSH
35722: EMPTY
35723: LIST
35724: LIST
35725: PUSH
35726: LD_INT 2
35728: PUSH
35729: LD_INT 2
35731: PUSH
35732: EMPTY
35733: LIST
35734: LIST
35735: PUSH
35736: LD_INT 1
35738: PUSH
35739: LD_INT 2
35741: PUSH
35742: EMPTY
35743: LIST
35744: LIST
35745: PUSH
35746: LD_INT 0
35748: PUSH
35749: LD_INT 2
35751: PUSH
35752: EMPTY
35753: LIST
35754: LIST
35755: PUSH
35756: LD_INT 1
35758: NEG
35759: PUSH
35760: LD_INT 1
35762: PUSH
35763: EMPTY
35764: LIST
35765: LIST
35766: PUSH
35767: LD_INT 2
35769: NEG
35770: PUSH
35771: LD_INT 0
35773: PUSH
35774: EMPTY
35775: LIST
35776: LIST
35777: PUSH
35778: LD_INT 2
35780: NEG
35781: PUSH
35782: LD_INT 1
35784: NEG
35785: PUSH
35786: EMPTY
35787: LIST
35788: LIST
35789: PUSH
35790: LD_INT 2
35792: NEG
35793: PUSH
35794: LD_INT 2
35796: NEG
35797: PUSH
35798: EMPTY
35799: LIST
35800: LIST
35801: PUSH
35802: EMPTY
35803: LIST
35804: LIST
35805: LIST
35806: LIST
35807: LIST
35808: LIST
35809: LIST
35810: LIST
35811: LIST
35812: LIST
35813: LIST
35814: LIST
35815: LIST
35816: LIST
35817: LIST
35818: LIST
35819: LIST
35820: LIST
35821: LIST
35822: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
35823: LD_ADDR_VAR 0 22
35827: PUSH
35828: LD_INT 0
35830: PUSH
35831: LD_INT 0
35833: PUSH
35834: EMPTY
35835: LIST
35836: LIST
35837: PUSH
35838: LD_INT 0
35840: PUSH
35841: LD_INT 1
35843: NEG
35844: PUSH
35845: EMPTY
35846: LIST
35847: LIST
35848: PUSH
35849: LD_INT 1
35851: PUSH
35852: LD_INT 0
35854: PUSH
35855: EMPTY
35856: LIST
35857: LIST
35858: PUSH
35859: LD_INT 1
35861: PUSH
35862: LD_INT 1
35864: PUSH
35865: EMPTY
35866: LIST
35867: LIST
35868: PUSH
35869: LD_INT 0
35871: PUSH
35872: LD_INT 1
35874: PUSH
35875: EMPTY
35876: LIST
35877: LIST
35878: PUSH
35879: LD_INT 1
35881: NEG
35882: PUSH
35883: LD_INT 0
35885: PUSH
35886: EMPTY
35887: LIST
35888: LIST
35889: PUSH
35890: LD_INT 1
35892: NEG
35893: PUSH
35894: LD_INT 1
35896: NEG
35897: PUSH
35898: EMPTY
35899: LIST
35900: LIST
35901: PUSH
35902: LD_INT 1
35904: NEG
35905: PUSH
35906: LD_INT 2
35908: NEG
35909: PUSH
35910: EMPTY
35911: LIST
35912: LIST
35913: PUSH
35914: LD_INT 0
35916: PUSH
35917: LD_INT 2
35919: NEG
35920: PUSH
35921: EMPTY
35922: LIST
35923: LIST
35924: PUSH
35925: LD_INT 1
35927: PUSH
35928: LD_INT 1
35930: NEG
35931: PUSH
35932: EMPTY
35933: LIST
35934: LIST
35935: PUSH
35936: LD_INT 2
35938: PUSH
35939: LD_INT 0
35941: PUSH
35942: EMPTY
35943: LIST
35944: LIST
35945: PUSH
35946: LD_INT 2
35948: PUSH
35949: LD_INT 1
35951: PUSH
35952: EMPTY
35953: LIST
35954: LIST
35955: PUSH
35956: LD_INT 2
35958: PUSH
35959: LD_INT 2
35961: PUSH
35962: EMPTY
35963: LIST
35964: LIST
35965: PUSH
35966: LD_INT 1
35968: PUSH
35969: LD_INT 2
35971: PUSH
35972: EMPTY
35973: LIST
35974: LIST
35975: PUSH
35976: LD_INT 0
35978: PUSH
35979: LD_INT 2
35981: PUSH
35982: EMPTY
35983: LIST
35984: LIST
35985: PUSH
35986: LD_INT 1
35988: NEG
35989: PUSH
35990: LD_INT 1
35992: PUSH
35993: EMPTY
35994: LIST
35995: LIST
35996: PUSH
35997: LD_INT 2
35999: NEG
36000: PUSH
36001: LD_INT 0
36003: PUSH
36004: EMPTY
36005: LIST
36006: LIST
36007: PUSH
36008: LD_INT 2
36010: NEG
36011: PUSH
36012: LD_INT 1
36014: NEG
36015: PUSH
36016: EMPTY
36017: LIST
36018: LIST
36019: PUSH
36020: LD_INT 2
36022: NEG
36023: PUSH
36024: LD_INT 2
36026: NEG
36027: PUSH
36028: EMPTY
36029: LIST
36030: LIST
36031: PUSH
36032: EMPTY
36033: LIST
36034: LIST
36035: LIST
36036: LIST
36037: LIST
36038: LIST
36039: LIST
36040: LIST
36041: LIST
36042: LIST
36043: LIST
36044: LIST
36045: LIST
36046: LIST
36047: LIST
36048: LIST
36049: LIST
36050: LIST
36051: LIST
36052: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
36053: LD_ADDR_VAR 0 23
36057: PUSH
36058: LD_INT 0
36060: PUSH
36061: LD_INT 0
36063: PUSH
36064: EMPTY
36065: LIST
36066: LIST
36067: PUSH
36068: LD_INT 0
36070: PUSH
36071: LD_INT 1
36073: NEG
36074: PUSH
36075: EMPTY
36076: LIST
36077: LIST
36078: PUSH
36079: LD_INT 1
36081: PUSH
36082: LD_INT 0
36084: PUSH
36085: EMPTY
36086: LIST
36087: LIST
36088: PUSH
36089: LD_INT 1
36091: PUSH
36092: LD_INT 1
36094: PUSH
36095: EMPTY
36096: LIST
36097: LIST
36098: PUSH
36099: LD_INT 0
36101: PUSH
36102: LD_INT 1
36104: PUSH
36105: EMPTY
36106: LIST
36107: LIST
36108: PUSH
36109: LD_INT 1
36111: NEG
36112: PUSH
36113: LD_INT 0
36115: PUSH
36116: EMPTY
36117: LIST
36118: LIST
36119: PUSH
36120: LD_INT 1
36122: NEG
36123: PUSH
36124: LD_INT 1
36126: NEG
36127: PUSH
36128: EMPTY
36129: LIST
36130: LIST
36131: PUSH
36132: LD_INT 1
36134: NEG
36135: PUSH
36136: LD_INT 2
36138: NEG
36139: PUSH
36140: EMPTY
36141: LIST
36142: LIST
36143: PUSH
36144: LD_INT 0
36146: PUSH
36147: LD_INT 2
36149: NEG
36150: PUSH
36151: EMPTY
36152: LIST
36153: LIST
36154: PUSH
36155: LD_INT 1
36157: PUSH
36158: LD_INT 1
36160: NEG
36161: PUSH
36162: EMPTY
36163: LIST
36164: LIST
36165: PUSH
36166: LD_INT 2
36168: PUSH
36169: LD_INT 0
36171: PUSH
36172: EMPTY
36173: LIST
36174: LIST
36175: PUSH
36176: LD_INT 2
36178: PUSH
36179: LD_INT 1
36181: PUSH
36182: EMPTY
36183: LIST
36184: LIST
36185: PUSH
36186: LD_INT 2
36188: PUSH
36189: LD_INT 2
36191: PUSH
36192: EMPTY
36193: LIST
36194: LIST
36195: PUSH
36196: LD_INT 1
36198: PUSH
36199: LD_INT 2
36201: PUSH
36202: EMPTY
36203: LIST
36204: LIST
36205: PUSH
36206: LD_INT 0
36208: PUSH
36209: LD_INT 2
36211: PUSH
36212: EMPTY
36213: LIST
36214: LIST
36215: PUSH
36216: LD_INT 1
36218: NEG
36219: PUSH
36220: LD_INT 1
36222: PUSH
36223: EMPTY
36224: LIST
36225: LIST
36226: PUSH
36227: LD_INT 2
36229: NEG
36230: PUSH
36231: LD_INT 0
36233: PUSH
36234: EMPTY
36235: LIST
36236: LIST
36237: PUSH
36238: LD_INT 2
36240: NEG
36241: PUSH
36242: LD_INT 1
36244: NEG
36245: PUSH
36246: EMPTY
36247: LIST
36248: LIST
36249: PUSH
36250: LD_INT 2
36252: NEG
36253: PUSH
36254: LD_INT 2
36256: NEG
36257: PUSH
36258: EMPTY
36259: LIST
36260: LIST
36261: PUSH
36262: LD_INT 2
36264: NEG
36265: PUSH
36266: LD_INT 3
36268: NEG
36269: PUSH
36270: EMPTY
36271: LIST
36272: LIST
36273: PUSH
36274: LD_INT 1
36276: NEG
36277: PUSH
36278: LD_INT 3
36280: NEG
36281: PUSH
36282: EMPTY
36283: LIST
36284: LIST
36285: PUSH
36286: LD_INT 1
36288: PUSH
36289: LD_INT 2
36291: NEG
36292: PUSH
36293: EMPTY
36294: LIST
36295: LIST
36296: PUSH
36297: LD_INT 2
36299: PUSH
36300: LD_INT 1
36302: NEG
36303: PUSH
36304: EMPTY
36305: LIST
36306: LIST
36307: PUSH
36308: EMPTY
36309: LIST
36310: LIST
36311: LIST
36312: LIST
36313: LIST
36314: LIST
36315: LIST
36316: LIST
36317: LIST
36318: LIST
36319: LIST
36320: LIST
36321: LIST
36322: LIST
36323: LIST
36324: LIST
36325: LIST
36326: LIST
36327: LIST
36328: LIST
36329: LIST
36330: LIST
36331: LIST
36332: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
36333: LD_ADDR_VAR 0 24
36337: PUSH
36338: LD_INT 0
36340: PUSH
36341: LD_INT 0
36343: PUSH
36344: EMPTY
36345: LIST
36346: LIST
36347: PUSH
36348: LD_INT 0
36350: PUSH
36351: LD_INT 1
36353: NEG
36354: PUSH
36355: EMPTY
36356: LIST
36357: LIST
36358: PUSH
36359: LD_INT 1
36361: PUSH
36362: LD_INT 0
36364: PUSH
36365: EMPTY
36366: LIST
36367: LIST
36368: PUSH
36369: LD_INT 1
36371: PUSH
36372: LD_INT 1
36374: PUSH
36375: EMPTY
36376: LIST
36377: LIST
36378: PUSH
36379: LD_INT 0
36381: PUSH
36382: LD_INT 1
36384: PUSH
36385: EMPTY
36386: LIST
36387: LIST
36388: PUSH
36389: LD_INT 1
36391: NEG
36392: PUSH
36393: LD_INT 0
36395: PUSH
36396: EMPTY
36397: LIST
36398: LIST
36399: PUSH
36400: LD_INT 1
36402: NEG
36403: PUSH
36404: LD_INT 1
36406: NEG
36407: PUSH
36408: EMPTY
36409: LIST
36410: LIST
36411: PUSH
36412: LD_INT 1
36414: NEG
36415: PUSH
36416: LD_INT 2
36418: NEG
36419: PUSH
36420: EMPTY
36421: LIST
36422: LIST
36423: PUSH
36424: LD_INT 0
36426: PUSH
36427: LD_INT 2
36429: NEG
36430: PUSH
36431: EMPTY
36432: LIST
36433: LIST
36434: PUSH
36435: LD_INT 1
36437: PUSH
36438: LD_INT 1
36440: NEG
36441: PUSH
36442: EMPTY
36443: LIST
36444: LIST
36445: PUSH
36446: LD_INT 2
36448: PUSH
36449: LD_INT 0
36451: PUSH
36452: EMPTY
36453: LIST
36454: LIST
36455: PUSH
36456: LD_INT 2
36458: PUSH
36459: LD_INT 1
36461: PUSH
36462: EMPTY
36463: LIST
36464: LIST
36465: PUSH
36466: LD_INT 2
36468: PUSH
36469: LD_INT 2
36471: PUSH
36472: EMPTY
36473: LIST
36474: LIST
36475: PUSH
36476: LD_INT 1
36478: PUSH
36479: LD_INT 2
36481: PUSH
36482: EMPTY
36483: LIST
36484: LIST
36485: PUSH
36486: LD_INT 0
36488: PUSH
36489: LD_INT 2
36491: PUSH
36492: EMPTY
36493: LIST
36494: LIST
36495: PUSH
36496: LD_INT 1
36498: NEG
36499: PUSH
36500: LD_INT 1
36502: PUSH
36503: EMPTY
36504: LIST
36505: LIST
36506: PUSH
36507: LD_INT 2
36509: NEG
36510: PUSH
36511: LD_INT 0
36513: PUSH
36514: EMPTY
36515: LIST
36516: LIST
36517: PUSH
36518: LD_INT 2
36520: NEG
36521: PUSH
36522: LD_INT 1
36524: NEG
36525: PUSH
36526: EMPTY
36527: LIST
36528: LIST
36529: PUSH
36530: LD_INT 2
36532: NEG
36533: PUSH
36534: LD_INT 2
36536: NEG
36537: PUSH
36538: EMPTY
36539: LIST
36540: LIST
36541: PUSH
36542: LD_INT 1
36544: PUSH
36545: LD_INT 2
36547: NEG
36548: PUSH
36549: EMPTY
36550: LIST
36551: LIST
36552: PUSH
36553: LD_INT 2
36555: PUSH
36556: LD_INT 1
36558: NEG
36559: PUSH
36560: EMPTY
36561: LIST
36562: LIST
36563: PUSH
36564: LD_INT 3
36566: PUSH
36567: LD_INT 1
36569: PUSH
36570: EMPTY
36571: LIST
36572: LIST
36573: PUSH
36574: LD_INT 3
36576: PUSH
36577: LD_INT 2
36579: PUSH
36580: EMPTY
36581: LIST
36582: LIST
36583: PUSH
36584: EMPTY
36585: LIST
36586: LIST
36587: LIST
36588: LIST
36589: LIST
36590: LIST
36591: LIST
36592: LIST
36593: LIST
36594: LIST
36595: LIST
36596: LIST
36597: LIST
36598: LIST
36599: LIST
36600: LIST
36601: LIST
36602: LIST
36603: LIST
36604: LIST
36605: LIST
36606: LIST
36607: LIST
36608: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
36609: LD_ADDR_VAR 0 25
36613: PUSH
36614: LD_INT 0
36616: PUSH
36617: LD_INT 0
36619: PUSH
36620: EMPTY
36621: LIST
36622: LIST
36623: PUSH
36624: LD_INT 0
36626: PUSH
36627: LD_INT 1
36629: NEG
36630: PUSH
36631: EMPTY
36632: LIST
36633: LIST
36634: PUSH
36635: LD_INT 1
36637: PUSH
36638: LD_INT 0
36640: PUSH
36641: EMPTY
36642: LIST
36643: LIST
36644: PUSH
36645: LD_INT 1
36647: PUSH
36648: LD_INT 1
36650: PUSH
36651: EMPTY
36652: LIST
36653: LIST
36654: PUSH
36655: LD_INT 0
36657: PUSH
36658: LD_INT 1
36660: PUSH
36661: EMPTY
36662: LIST
36663: LIST
36664: PUSH
36665: LD_INT 1
36667: NEG
36668: PUSH
36669: LD_INT 0
36671: PUSH
36672: EMPTY
36673: LIST
36674: LIST
36675: PUSH
36676: LD_INT 1
36678: NEG
36679: PUSH
36680: LD_INT 1
36682: NEG
36683: PUSH
36684: EMPTY
36685: LIST
36686: LIST
36687: PUSH
36688: LD_INT 1
36690: NEG
36691: PUSH
36692: LD_INT 2
36694: NEG
36695: PUSH
36696: EMPTY
36697: LIST
36698: LIST
36699: PUSH
36700: LD_INT 0
36702: PUSH
36703: LD_INT 2
36705: NEG
36706: PUSH
36707: EMPTY
36708: LIST
36709: LIST
36710: PUSH
36711: LD_INT 1
36713: PUSH
36714: LD_INT 1
36716: NEG
36717: PUSH
36718: EMPTY
36719: LIST
36720: LIST
36721: PUSH
36722: LD_INT 2
36724: PUSH
36725: LD_INT 0
36727: PUSH
36728: EMPTY
36729: LIST
36730: LIST
36731: PUSH
36732: LD_INT 2
36734: PUSH
36735: LD_INT 1
36737: PUSH
36738: EMPTY
36739: LIST
36740: LIST
36741: PUSH
36742: LD_INT 2
36744: PUSH
36745: LD_INT 2
36747: PUSH
36748: EMPTY
36749: LIST
36750: LIST
36751: PUSH
36752: LD_INT 1
36754: PUSH
36755: LD_INT 2
36757: PUSH
36758: EMPTY
36759: LIST
36760: LIST
36761: PUSH
36762: LD_INT 0
36764: PUSH
36765: LD_INT 2
36767: PUSH
36768: EMPTY
36769: LIST
36770: LIST
36771: PUSH
36772: LD_INT 1
36774: NEG
36775: PUSH
36776: LD_INT 1
36778: PUSH
36779: EMPTY
36780: LIST
36781: LIST
36782: PUSH
36783: LD_INT 2
36785: NEG
36786: PUSH
36787: LD_INT 0
36789: PUSH
36790: EMPTY
36791: LIST
36792: LIST
36793: PUSH
36794: LD_INT 2
36796: NEG
36797: PUSH
36798: LD_INT 1
36800: NEG
36801: PUSH
36802: EMPTY
36803: LIST
36804: LIST
36805: PUSH
36806: LD_INT 2
36808: NEG
36809: PUSH
36810: LD_INT 2
36812: NEG
36813: PUSH
36814: EMPTY
36815: LIST
36816: LIST
36817: PUSH
36818: LD_INT 3
36820: PUSH
36821: LD_INT 1
36823: PUSH
36824: EMPTY
36825: LIST
36826: LIST
36827: PUSH
36828: LD_INT 3
36830: PUSH
36831: LD_INT 2
36833: PUSH
36834: EMPTY
36835: LIST
36836: LIST
36837: PUSH
36838: LD_INT 2
36840: PUSH
36841: LD_INT 3
36843: PUSH
36844: EMPTY
36845: LIST
36846: LIST
36847: PUSH
36848: LD_INT 1
36850: PUSH
36851: LD_INT 3
36853: PUSH
36854: EMPTY
36855: LIST
36856: LIST
36857: PUSH
36858: EMPTY
36859: LIST
36860: LIST
36861: LIST
36862: LIST
36863: LIST
36864: LIST
36865: LIST
36866: LIST
36867: LIST
36868: LIST
36869: LIST
36870: LIST
36871: LIST
36872: LIST
36873: LIST
36874: LIST
36875: LIST
36876: LIST
36877: LIST
36878: LIST
36879: LIST
36880: LIST
36881: LIST
36882: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
36883: LD_ADDR_VAR 0 26
36887: PUSH
36888: LD_INT 0
36890: PUSH
36891: LD_INT 0
36893: PUSH
36894: EMPTY
36895: LIST
36896: LIST
36897: PUSH
36898: LD_INT 0
36900: PUSH
36901: LD_INT 1
36903: NEG
36904: PUSH
36905: EMPTY
36906: LIST
36907: LIST
36908: PUSH
36909: LD_INT 1
36911: PUSH
36912: LD_INT 0
36914: PUSH
36915: EMPTY
36916: LIST
36917: LIST
36918: PUSH
36919: LD_INT 1
36921: PUSH
36922: LD_INT 1
36924: PUSH
36925: EMPTY
36926: LIST
36927: LIST
36928: PUSH
36929: LD_INT 0
36931: PUSH
36932: LD_INT 1
36934: PUSH
36935: EMPTY
36936: LIST
36937: LIST
36938: PUSH
36939: LD_INT 1
36941: NEG
36942: PUSH
36943: LD_INT 0
36945: PUSH
36946: EMPTY
36947: LIST
36948: LIST
36949: PUSH
36950: LD_INT 1
36952: NEG
36953: PUSH
36954: LD_INT 1
36956: NEG
36957: PUSH
36958: EMPTY
36959: LIST
36960: LIST
36961: PUSH
36962: LD_INT 1
36964: NEG
36965: PUSH
36966: LD_INT 2
36968: NEG
36969: PUSH
36970: EMPTY
36971: LIST
36972: LIST
36973: PUSH
36974: LD_INT 0
36976: PUSH
36977: LD_INT 2
36979: NEG
36980: PUSH
36981: EMPTY
36982: LIST
36983: LIST
36984: PUSH
36985: LD_INT 1
36987: PUSH
36988: LD_INT 1
36990: NEG
36991: PUSH
36992: EMPTY
36993: LIST
36994: LIST
36995: PUSH
36996: LD_INT 2
36998: PUSH
36999: LD_INT 0
37001: PUSH
37002: EMPTY
37003: LIST
37004: LIST
37005: PUSH
37006: LD_INT 2
37008: PUSH
37009: LD_INT 1
37011: PUSH
37012: EMPTY
37013: LIST
37014: LIST
37015: PUSH
37016: LD_INT 2
37018: PUSH
37019: LD_INT 2
37021: PUSH
37022: EMPTY
37023: LIST
37024: LIST
37025: PUSH
37026: LD_INT 1
37028: PUSH
37029: LD_INT 2
37031: PUSH
37032: EMPTY
37033: LIST
37034: LIST
37035: PUSH
37036: LD_INT 0
37038: PUSH
37039: LD_INT 2
37041: PUSH
37042: EMPTY
37043: LIST
37044: LIST
37045: PUSH
37046: LD_INT 1
37048: NEG
37049: PUSH
37050: LD_INT 1
37052: PUSH
37053: EMPTY
37054: LIST
37055: LIST
37056: PUSH
37057: LD_INT 2
37059: NEG
37060: PUSH
37061: LD_INT 0
37063: PUSH
37064: EMPTY
37065: LIST
37066: LIST
37067: PUSH
37068: LD_INT 2
37070: NEG
37071: PUSH
37072: LD_INT 1
37074: NEG
37075: PUSH
37076: EMPTY
37077: LIST
37078: LIST
37079: PUSH
37080: LD_INT 2
37082: NEG
37083: PUSH
37084: LD_INT 2
37086: NEG
37087: PUSH
37088: EMPTY
37089: LIST
37090: LIST
37091: PUSH
37092: LD_INT 2
37094: PUSH
37095: LD_INT 3
37097: PUSH
37098: EMPTY
37099: LIST
37100: LIST
37101: PUSH
37102: LD_INT 1
37104: PUSH
37105: LD_INT 3
37107: PUSH
37108: EMPTY
37109: LIST
37110: LIST
37111: PUSH
37112: LD_INT 1
37114: NEG
37115: PUSH
37116: LD_INT 2
37118: PUSH
37119: EMPTY
37120: LIST
37121: LIST
37122: PUSH
37123: LD_INT 2
37125: NEG
37126: PUSH
37127: LD_INT 1
37129: PUSH
37130: EMPTY
37131: LIST
37132: LIST
37133: PUSH
37134: EMPTY
37135: LIST
37136: LIST
37137: LIST
37138: LIST
37139: LIST
37140: LIST
37141: LIST
37142: LIST
37143: LIST
37144: LIST
37145: LIST
37146: LIST
37147: LIST
37148: LIST
37149: LIST
37150: LIST
37151: LIST
37152: LIST
37153: LIST
37154: LIST
37155: LIST
37156: LIST
37157: LIST
37158: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
37159: LD_ADDR_VAR 0 27
37163: PUSH
37164: LD_INT 0
37166: PUSH
37167: LD_INT 0
37169: PUSH
37170: EMPTY
37171: LIST
37172: LIST
37173: PUSH
37174: LD_INT 0
37176: PUSH
37177: LD_INT 1
37179: NEG
37180: PUSH
37181: EMPTY
37182: LIST
37183: LIST
37184: PUSH
37185: LD_INT 1
37187: PUSH
37188: LD_INT 0
37190: PUSH
37191: EMPTY
37192: LIST
37193: LIST
37194: PUSH
37195: LD_INT 1
37197: PUSH
37198: LD_INT 1
37200: PUSH
37201: EMPTY
37202: LIST
37203: LIST
37204: PUSH
37205: LD_INT 0
37207: PUSH
37208: LD_INT 1
37210: PUSH
37211: EMPTY
37212: LIST
37213: LIST
37214: PUSH
37215: LD_INT 1
37217: NEG
37218: PUSH
37219: LD_INT 0
37221: PUSH
37222: EMPTY
37223: LIST
37224: LIST
37225: PUSH
37226: LD_INT 1
37228: NEG
37229: PUSH
37230: LD_INT 1
37232: NEG
37233: PUSH
37234: EMPTY
37235: LIST
37236: LIST
37237: PUSH
37238: LD_INT 1
37240: NEG
37241: PUSH
37242: LD_INT 2
37244: NEG
37245: PUSH
37246: EMPTY
37247: LIST
37248: LIST
37249: PUSH
37250: LD_INT 0
37252: PUSH
37253: LD_INT 2
37255: NEG
37256: PUSH
37257: EMPTY
37258: LIST
37259: LIST
37260: PUSH
37261: LD_INT 1
37263: PUSH
37264: LD_INT 1
37266: NEG
37267: PUSH
37268: EMPTY
37269: LIST
37270: LIST
37271: PUSH
37272: LD_INT 2
37274: PUSH
37275: LD_INT 0
37277: PUSH
37278: EMPTY
37279: LIST
37280: LIST
37281: PUSH
37282: LD_INT 2
37284: PUSH
37285: LD_INT 1
37287: PUSH
37288: EMPTY
37289: LIST
37290: LIST
37291: PUSH
37292: LD_INT 2
37294: PUSH
37295: LD_INT 2
37297: PUSH
37298: EMPTY
37299: LIST
37300: LIST
37301: PUSH
37302: LD_INT 1
37304: PUSH
37305: LD_INT 2
37307: PUSH
37308: EMPTY
37309: LIST
37310: LIST
37311: PUSH
37312: LD_INT 0
37314: PUSH
37315: LD_INT 2
37317: PUSH
37318: EMPTY
37319: LIST
37320: LIST
37321: PUSH
37322: LD_INT 1
37324: NEG
37325: PUSH
37326: LD_INT 1
37328: PUSH
37329: EMPTY
37330: LIST
37331: LIST
37332: PUSH
37333: LD_INT 2
37335: NEG
37336: PUSH
37337: LD_INT 0
37339: PUSH
37340: EMPTY
37341: LIST
37342: LIST
37343: PUSH
37344: LD_INT 2
37346: NEG
37347: PUSH
37348: LD_INT 1
37350: NEG
37351: PUSH
37352: EMPTY
37353: LIST
37354: LIST
37355: PUSH
37356: LD_INT 2
37358: NEG
37359: PUSH
37360: LD_INT 2
37362: NEG
37363: PUSH
37364: EMPTY
37365: LIST
37366: LIST
37367: PUSH
37368: LD_INT 1
37370: NEG
37371: PUSH
37372: LD_INT 2
37374: PUSH
37375: EMPTY
37376: LIST
37377: LIST
37378: PUSH
37379: LD_INT 2
37381: NEG
37382: PUSH
37383: LD_INT 1
37385: PUSH
37386: EMPTY
37387: LIST
37388: LIST
37389: PUSH
37390: LD_INT 3
37392: NEG
37393: PUSH
37394: LD_INT 1
37396: NEG
37397: PUSH
37398: EMPTY
37399: LIST
37400: LIST
37401: PUSH
37402: LD_INT 3
37404: NEG
37405: PUSH
37406: LD_INT 2
37408: NEG
37409: PUSH
37410: EMPTY
37411: LIST
37412: LIST
37413: PUSH
37414: EMPTY
37415: LIST
37416: LIST
37417: LIST
37418: LIST
37419: LIST
37420: LIST
37421: LIST
37422: LIST
37423: LIST
37424: LIST
37425: LIST
37426: LIST
37427: LIST
37428: LIST
37429: LIST
37430: LIST
37431: LIST
37432: LIST
37433: LIST
37434: LIST
37435: LIST
37436: LIST
37437: LIST
37438: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
37439: LD_ADDR_VAR 0 28
37443: PUSH
37444: LD_INT 0
37446: PUSH
37447: LD_INT 0
37449: PUSH
37450: EMPTY
37451: LIST
37452: LIST
37453: PUSH
37454: LD_INT 0
37456: PUSH
37457: LD_INT 1
37459: NEG
37460: PUSH
37461: EMPTY
37462: LIST
37463: LIST
37464: PUSH
37465: LD_INT 1
37467: PUSH
37468: LD_INT 0
37470: PUSH
37471: EMPTY
37472: LIST
37473: LIST
37474: PUSH
37475: LD_INT 1
37477: PUSH
37478: LD_INT 1
37480: PUSH
37481: EMPTY
37482: LIST
37483: LIST
37484: PUSH
37485: LD_INT 0
37487: PUSH
37488: LD_INT 1
37490: PUSH
37491: EMPTY
37492: LIST
37493: LIST
37494: PUSH
37495: LD_INT 1
37497: NEG
37498: PUSH
37499: LD_INT 0
37501: PUSH
37502: EMPTY
37503: LIST
37504: LIST
37505: PUSH
37506: LD_INT 1
37508: NEG
37509: PUSH
37510: LD_INT 1
37512: NEG
37513: PUSH
37514: EMPTY
37515: LIST
37516: LIST
37517: PUSH
37518: LD_INT 1
37520: NEG
37521: PUSH
37522: LD_INT 2
37524: NEG
37525: PUSH
37526: EMPTY
37527: LIST
37528: LIST
37529: PUSH
37530: LD_INT 0
37532: PUSH
37533: LD_INT 2
37535: NEG
37536: PUSH
37537: EMPTY
37538: LIST
37539: LIST
37540: PUSH
37541: LD_INT 1
37543: PUSH
37544: LD_INT 1
37546: NEG
37547: PUSH
37548: EMPTY
37549: LIST
37550: LIST
37551: PUSH
37552: LD_INT 2
37554: PUSH
37555: LD_INT 0
37557: PUSH
37558: EMPTY
37559: LIST
37560: LIST
37561: PUSH
37562: LD_INT 2
37564: PUSH
37565: LD_INT 1
37567: PUSH
37568: EMPTY
37569: LIST
37570: LIST
37571: PUSH
37572: LD_INT 2
37574: PUSH
37575: LD_INT 2
37577: PUSH
37578: EMPTY
37579: LIST
37580: LIST
37581: PUSH
37582: LD_INT 1
37584: PUSH
37585: LD_INT 2
37587: PUSH
37588: EMPTY
37589: LIST
37590: LIST
37591: PUSH
37592: LD_INT 0
37594: PUSH
37595: LD_INT 2
37597: PUSH
37598: EMPTY
37599: LIST
37600: LIST
37601: PUSH
37602: LD_INT 1
37604: NEG
37605: PUSH
37606: LD_INT 1
37608: PUSH
37609: EMPTY
37610: LIST
37611: LIST
37612: PUSH
37613: LD_INT 2
37615: NEG
37616: PUSH
37617: LD_INT 0
37619: PUSH
37620: EMPTY
37621: LIST
37622: LIST
37623: PUSH
37624: LD_INT 2
37626: NEG
37627: PUSH
37628: LD_INT 1
37630: NEG
37631: PUSH
37632: EMPTY
37633: LIST
37634: LIST
37635: PUSH
37636: LD_INT 2
37638: NEG
37639: PUSH
37640: LD_INT 2
37642: NEG
37643: PUSH
37644: EMPTY
37645: LIST
37646: LIST
37647: PUSH
37648: LD_INT 2
37650: NEG
37651: PUSH
37652: LD_INT 3
37654: NEG
37655: PUSH
37656: EMPTY
37657: LIST
37658: LIST
37659: PUSH
37660: LD_INT 1
37662: NEG
37663: PUSH
37664: LD_INT 3
37666: NEG
37667: PUSH
37668: EMPTY
37669: LIST
37670: LIST
37671: PUSH
37672: LD_INT 3
37674: NEG
37675: PUSH
37676: LD_INT 1
37678: NEG
37679: PUSH
37680: EMPTY
37681: LIST
37682: LIST
37683: PUSH
37684: LD_INT 3
37686: NEG
37687: PUSH
37688: LD_INT 2
37690: NEG
37691: PUSH
37692: EMPTY
37693: LIST
37694: LIST
37695: PUSH
37696: EMPTY
37697: LIST
37698: LIST
37699: LIST
37700: LIST
37701: LIST
37702: LIST
37703: LIST
37704: LIST
37705: LIST
37706: LIST
37707: LIST
37708: LIST
37709: LIST
37710: LIST
37711: LIST
37712: LIST
37713: LIST
37714: LIST
37715: LIST
37716: LIST
37717: LIST
37718: LIST
37719: LIST
37720: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
37721: LD_ADDR_VAR 0 29
37725: PUSH
37726: LD_INT 0
37728: PUSH
37729: LD_INT 0
37731: PUSH
37732: EMPTY
37733: LIST
37734: LIST
37735: PUSH
37736: LD_INT 0
37738: PUSH
37739: LD_INT 1
37741: NEG
37742: PUSH
37743: EMPTY
37744: LIST
37745: LIST
37746: PUSH
37747: LD_INT 1
37749: PUSH
37750: LD_INT 0
37752: PUSH
37753: EMPTY
37754: LIST
37755: LIST
37756: PUSH
37757: LD_INT 1
37759: PUSH
37760: LD_INT 1
37762: PUSH
37763: EMPTY
37764: LIST
37765: LIST
37766: PUSH
37767: LD_INT 0
37769: PUSH
37770: LD_INT 1
37772: PUSH
37773: EMPTY
37774: LIST
37775: LIST
37776: PUSH
37777: LD_INT 1
37779: NEG
37780: PUSH
37781: LD_INT 0
37783: PUSH
37784: EMPTY
37785: LIST
37786: LIST
37787: PUSH
37788: LD_INT 1
37790: NEG
37791: PUSH
37792: LD_INT 1
37794: NEG
37795: PUSH
37796: EMPTY
37797: LIST
37798: LIST
37799: PUSH
37800: LD_INT 1
37802: NEG
37803: PUSH
37804: LD_INT 2
37806: NEG
37807: PUSH
37808: EMPTY
37809: LIST
37810: LIST
37811: PUSH
37812: LD_INT 0
37814: PUSH
37815: LD_INT 2
37817: NEG
37818: PUSH
37819: EMPTY
37820: LIST
37821: LIST
37822: PUSH
37823: LD_INT 1
37825: PUSH
37826: LD_INT 1
37828: NEG
37829: PUSH
37830: EMPTY
37831: LIST
37832: LIST
37833: PUSH
37834: LD_INT 2
37836: PUSH
37837: LD_INT 0
37839: PUSH
37840: EMPTY
37841: LIST
37842: LIST
37843: PUSH
37844: LD_INT 2
37846: PUSH
37847: LD_INT 1
37849: PUSH
37850: EMPTY
37851: LIST
37852: LIST
37853: PUSH
37854: LD_INT 1
37856: PUSH
37857: LD_INT 2
37859: PUSH
37860: EMPTY
37861: LIST
37862: LIST
37863: PUSH
37864: LD_INT 0
37866: PUSH
37867: LD_INT 2
37869: PUSH
37870: EMPTY
37871: LIST
37872: LIST
37873: PUSH
37874: LD_INT 1
37876: NEG
37877: PUSH
37878: LD_INT 1
37880: PUSH
37881: EMPTY
37882: LIST
37883: LIST
37884: PUSH
37885: LD_INT 2
37887: NEG
37888: PUSH
37889: LD_INT 1
37891: NEG
37892: PUSH
37893: EMPTY
37894: LIST
37895: LIST
37896: PUSH
37897: LD_INT 2
37899: NEG
37900: PUSH
37901: LD_INT 2
37903: NEG
37904: PUSH
37905: EMPTY
37906: LIST
37907: LIST
37908: PUSH
37909: LD_INT 2
37911: NEG
37912: PUSH
37913: LD_INT 3
37915: NEG
37916: PUSH
37917: EMPTY
37918: LIST
37919: LIST
37920: PUSH
37921: LD_INT 2
37923: PUSH
37924: LD_INT 1
37926: NEG
37927: PUSH
37928: EMPTY
37929: LIST
37930: LIST
37931: PUSH
37932: LD_INT 3
37934: PUSH
37935: LD_INT 1
37937: PUSH
37938: EMPTY
37939: LIST
37940: LIST
37941: PUSH
37942: LD_INT 1
37944: PUSH
37945: LD_INT 3
37947: PUSH
37948: EMPTY
37949: LIST
37950: LIST
37951: PUSH
37952: LD_INT 1
37954: NEG
37955: PUSH
37956: LD_INT 2
37958: PUSH
37959: EMPTY
37960: LIST
37961: LIST
37962: PUSH
37963: LD_INT 3
37965: NEG
37966: PUSH
37967: LD_INT 2
37969: NEG
37970: PUSH
37971: EMPTY
37972: LIST
37973: LIST
37974: PUSH
37975: EMPTY
37976: LIST
37977: LIST
37978: LIST
37979: LIST
37980: LIST
37981: LIST
37982: LIST
37983: LIST
37984: LIST
37985: LIST
37986: LIST
37987: LIST
37988: LIST
37989: LIST
37990: LIST
37991: LIST
37992: LIST
37993: LIST
37994: LIST
37995: LIST
37996: LIST
37997: LIST
37998: LIST
37999: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
38000: LD_ADDR_VAR 0 30
38004: PUSH
38005: LD_INT 0
38007: PUSH
38008: LD_INT 0
38010: PUSH
38011: EMPTY
38012: LIST
38013: LIST
38014: PUSH
38015: LD_INT 0
38017: PUSH
38018: LD_INT 1
38020: NEG
38021: PUSH
38022: EMPTY
38023: LIST
38024: LIST
38025: PUSH
38026: LD_INT 1
38028: PUSH
38029: LD_INT 0
38031: PUSH
38032: EMPTY
38033: LIST
38034: LIST
38035: PUSH
38036: LD_INT 1
38038: PUSH
38039: LD_INT 1
38041: PUSH
38042: EMPTY
38043: LIST
38044: LIST
38045: PUSH
38046: LD_INT 0
38048: PUSH
38049: LD_INT 1
38051: PUSH
38052: EMPTY
38053: LIST
38054: LIST
38055: PUSH
38056: LD_INT 1
38058: NEG
38059: PUSH
38060: LD_INT 0
38062: PUSH
38063: EMPTY
38064: LIST
38065: LIST
38066: PUSH
38067: LD_INT 1
38069: NEG
38070: PUSH
38071: LD_INT 1
38073: NEG
38074: PUSH
38075: EMPTY
38076: LIST
38077: LIST
38078: PUSH
38079: LD_INT 1
38081: NEG
38082: PUSH
38083: LD_INT 2
38085: NEG
38086: PUSH
38087: EMPTY
38088: LIST
38089: LIST
38090: PUSH
38091: LD_INT 0
38093: PUSH
38094: LD_INT 2
38096: NEG
38097: PUSH
38098: EMPTY
38099: LIST
38100: LIST
38101: PUSH
38102: LD_INT 1
38104: PUSH
38105: LD_INT 1
38107: NEG
38108: PUSH
38109: EMPTY
38110: LIST
38111: LIST
38112: PUSH
38113: LD_INT 2
38115: PUSH
38116: LD_INT 0
38118: PUSH
38119: EMPTY
38120: LIST
38121: LIST
38122: PUSH
38123: LD_INT 2
38125: PUSH
38126: LD_INT 1
38128: PUSH
38129: EMPTY
38130: LIST
38131: LIST
38132: PUSH
38133: LD_INT 2
38135: PUSH
38136: LD_INT 2
38138: PUSH
38139: EMPTY
38140: LIST
38141: LIST
38142: PUSH
38143: LD_INT 1
38145: PUSH
38146: LD_INT 2
38148: PUSH
38149: EMPTY
38150: LIST
38151: LIST
38152: PUSH
38153: LD_INT 1
38155: NEG
38156: PUSH
38157: LD_INT 1
38159: PUSH
38160: EMPTY
38161: LIST
38162: LIST
38163: PUSH
38164: LD_INT 2
38166: NEG
38167: PUSH
38168: LD_INT 0
38170: PUSH
38171: EMPTY
38172: LIST
38173: LIST
38174: PUSH
38175: LD_INT 2
38177: NEG
38178: PUSH
38179: LD_INT 1
38181: NEG
38182: PUSH
38183: EMPTY
38184: LIST
38185: LIST
38186: PUSH
38187: LD_INT 1
38189: NEG
38190: PUSH
38191: LD_INT 3
38193: NEG
38194: PUSH
38195: EMPTY
38196: LIST
38197: LIST
38198: PUSH
38199: LD_INT 1
38201: PUSH
38202: LD_INT 2
38204: NEG
38205: PUSH
38206: EMPTY
38207: LIST
38208: LIST
38209: PUSH
38210: LD_INT 3
38212: PUSH
38213: LD_INT 2
38215: PUSH
38216: EMPTY
38217: LIST
38218: LIST
38219: PUSH
38220: LD_INT 2
38222: PUSH
38223: LD_INT 3
38225: PUSH
38226: EMPTY
38227: LIST
38228: LIST
38229: PUSH
38230: LD_INT 2
38232: NEG
38233: PUSH
38234: LD_INT 1
38236: PUSH
38237: EMPTY
38238: LIST
38239: LIST
38240: PUSH
38241: LD_INT 3
38243: NEG
38244: PUSH
38245: LD_INT 1
38247: NEG
38248: PUSH
38249: EMPTY
38250: LIST
38251: LIST
38252: PUSH
38253: EMPTY
38254: LIST
38255: LIST
38256: LIST
38257: LIST
38258: LIST
38259: LIST
38260: LIST
38261: LIST
38262: LIST
38263: LIST
38264: LIST
38265: LIST
38266: LIST
38267: LIST
38268: LIST
38269: LIST
38270: LIST
38271: LIST
38272: LIST
38273: LIST
38274: LIST
38275: LIST
38276: LIST
38277: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
38278: LD_ADDR_VAR 0 31
38282: PUSH
38283: LD_INT 0
38285: PUSH
38286: LD_INT 0
38288: PUSH
38289: EMPTY
38290: LIST
38291: LIST
38292: PUSH
38293: LD_INT 0
38295: PUSH
38296: LD_INT 1
38298: NEG
38299: PUSH
38300: EMPTY
38301: LIST
38302: LIST
38303: PUSH
38304: LD_INT 1
38306: PUSH
38307: LD_INT 0
38309: PUSH
38310: EMPTY
38311: LIST
38312: LIST
38313: PUSH
38314: LD_INT 1
38316: PUSH
38317: LD_INT 1
38319: PUSH
38320: EMPTY
38321: LIST
38322: LIST
38323: PUSH
38324: LD_INT 0
38326: PUSH
38327: LD_INT 1
38329: PUSH
38330: EMPTY
38331: LIST
38332: LIST
38333: PUSH
38334: LD_INT 1
38336: NEG
38337: PUSH
38338: LD_INT 0
38340: PUSH
38341: EMPTY
38342: LIST
38343: LIST
38344: PUSH
38345: LD_INT 1
38347: NEG
38348: PUSH
38349: LD_INT 1
38351: NEG
38352: PUSH
38353: EMPTY
38354: LIST
38355: LIST
38356: PUSH
38357: LD_INT 1
38359: NEG
38360: PUSH
38361: LD_INT 2
38363: NEG
38364: PUSH
38365: EMPTY
38366: LIST
38367: LIST
38368: PUSH
38369: LD_INT 1
38371: PUSH
38372: LD_INT 1
38374: NEG
38375: PUSH
38376: EMPTY
38377: LIST
38378: LIST
38379: PUSH
38380: LD_INT 2
38382: PUSH
38383: LD_INT 0
38385: PUSH
38386: EMPTY
38387: LIST
38388: LIST
38389: PUSH
38390: LD_INT 2
38392: PUSH
38393: LD_INT 1
38395: PUSH
38396: EMPTY
38397: LIST
38398: LIST
38399: PUSH
38400: LD_INT 2
38402: PUSH
38403: LD_INT 2
38405: PUSH
38406: EMPTY
38407: LIST
38408: LIST
38409: PUSH
38410: LD_INT 1
38412: PUSH
38413: LD_INT 2
38415: PUSH
38416: EMPTY
38417: LIST
38418: LIST
38419: PUSH
38420: LD_INT 0
38422: PUSH
38423: LD_INT 2
38425: PUSH
38426: EMPTY
38427: LIST
38428: LIST
38429: PUSH
38430: LD_INT 1
38432: NEG
38433: PUSH
38434: LD_INT 1
38436: PUSH
38437: EMPTY
38438: LIST
38439: LIST
38440: PUSH
38441: LD_INT 2
38443: NEG
38444: PUSH
38445: LD_INT 1
38447: NEG
38448: PUSH
38449: EMPTY
38450: LIST
38451: LIST
38452: PUSH
38453: LD_INT 2
38455: NEG
38456: PUSH
38457: LD_INT 2
38459: NEG
38460: PUSH
38461: EMPTY
38462: LIST
38463: LIST
38464: PUSH
38465: LD_INT 2
38467: NEG
38468: PUSH
38469: LD_INT 3
38471: NEG
38472: PUSH
38473: EMPTY
38474: LIST
38475: LIST
38476: PUSH
38477: LD_INT 2
38479: PUSH
38480: LD_INT 1
38482: NEG
38483: PUSH
38484: EMPTY
38485: LIST
38486: LIST
38487: PUSH
38488: LD_INT 3
38490: PUSH
38491: LD_INT 1
38493: PUSH
38494: EMPTY
38495: LIST
38496: LIST
38497: PUSH
38498: LD_INT 1
38500: PUSH
38501: LD_INT 3
38503: PUSH
38504: EMPTY
38505: LIST
38506: LIST
38507: PUSH
38508: LD_INT 1
38510: NEG
38511: PUSH
38512: LD_INT 2
38514: PUSH
38515: EMPTY
38516: LIST
38517: LIST
38518: PUSH
38519: LD_INT 3
38521: NEG
38522: PUSH
38523: LD_INT 2
38525: NEG
38526: PUSH
38527: EMPTY
38528: LIST
38529: LIST
38530: PUSH
38531: EMPTY
38532: LIST
38533: LIST
38534: LIST
38535: LIST
38536: LIST
38537: LIST
38538: LIST
38539: LIST
38540: LIST
38541: LIST
38542: LIST
38543: LIST
38544: LIST
38545: LIST
38546: LIST
38547: LIST
38548: LIST
38549: LIST
38550: LIST
38551: LIST
38552: LIST
38553: LIST
38554: LIST
38555: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
38556: LD_ADDR_VAR 0 32
38560: PUSH
38561: LD_INT 0
38563: PUSH
38564: LD_INT 0
38566: PUSH
38567: EMPTY
38568: LIST
38569: LIST
38570: PUSH
38571: LD_INT 0
38573: PUSH
38574: LD_INT 1
38576: NEG
38577: PUSH
38578: EMPTY
38579: LIST
38580: LIST
38581: PUSH
38582: LD_INT 1
38584: PUSH
38585: LD_INT 0
38587: PUSH
38588: EMPTY
38589: LIST
38590: LIST
38591: PUSH
38592: LD_INT 1
38594: PUSH
38595: LD_INT 1
38597: PUSH
38598: EMPTY
38599: LIST
38600: LIST
38601: PUSH
38602: LD_INT 0
38604: PUSH
38605: LD_INT 1
38607: PUSH
38608: EMPTY
38609: LIST
38610: LIST
38611: PUSH
38612: LD_INT 1
38614: NEG
38615: PUSH
38616: LD_INT 0
38618: PUSH
38619: EMPTY
38620: LIST
38621: LIST
38622: PUSH
38623: LD_INT 1
38625: NEG
38626: PUSH
38627: LD_INT 1
38629: NEG
38630: PUSH
38631: EMPTY
38632: LIST
38633: LIST
38634: PUSH
38635: LD_INT 1
38637: NEG
38638: PUSH
38639: LD_INT 2
38641: NEG
38642: PUSH
38643: EMPTY
38644: LIST
38645: LIST
38646: PUSH
38647: LD_INT 0
38649: PUSH
38650: LD_INT 2
38652: NEG
38653: PUSH
38654: EMPTY
38655: LIST
38656: LIST
38657: PUSH
38658: LD_INT 1
38660: PUSH
38661: LD_INT 1
38663: NEG
38664: PUSH
38665: EMPTY
38666: LIST
38667: LIST
38668: PUSH
38669: LD_INT 2
38671: PUSH
38672: LD_INT 1
38674: PUSH
38675: EMPTY
38676: LIST
38677: LIST
38678: PUSH
38679: LD_INT 2
38681: PUSH
38682: LD_INT 2
38684: PUSH
38685: EMPTY
38686: LIST
38687: LIST
38688: PUSH
38689: LD_INT 1
38691: PUSH
38692: LD_INT 2
38694: PUSH
38695: EMPTY
38696: LIST
38697: LIST
38698: PUSH
38699: LD_INT 0
38701: PUSH
38702: LD_INT 2
38704: PUSH
38705: EMPTY
38706: LIST
38707: LIST
38708: PUSH
38709: LD_INT 1
38711: NEG
38712: PUSH
38713: LD_INT 1
38715: PUSH
38716: EMPTY
38717: LIST
38718: LIST
38719: PUSH
38720: LD_INT 2
38722: NEG
38723: PUSH
38724: LD_INT 0
38726: PUSH
38727: EMPTY
38728: LIST
38729: LIST
38730: PUSH
38731: LD_INT 2
38733: NEG
38734: PUSH
38735: LD_INT 1
38737: NEG
38738: PUSH
38739: EMPTY
38740: LIST
38741: LIST
38742: PUSH
38743: LD_INT 1
38745: NEG
38746: PUSH
38747: LD_INT 3
38749: NEG
38750: PUSH
38751: EMPTY
38752: LIST
38753: LIST
38754: PUSH
38755: LD_INT 1
38757: PUSH
38758: LD_INT 2
38760: NEG
38761: PUSH
38762: EMPTY
38763: LIST
38764: LIST
38765: PUSH
38766: LD_INT 3
38768: PUSH
38769: LD_INT 2
38771: PUSH
38772: EMPTY
38773: LIST
38774: LIST
38775: PUSH
38776: LD_INT 2
38778: PUSH
38779: LD_INT 3
38781: PUSH
38782: EMPTY
38783: LIST
38784: LIST
38785: PUSH
38786: LD_INT 2
38788: NEG
38789: PUSH
38790: LD_INT 1
38792: PUSH
38793: EMPTY
38794: LIST
38795: LIST
38796: PUSH
38797: LD_INT 3
38799: NEG
38800: PUSH
38801: LD_INT 1
38803: NEG
38804: PUSH
38805: EMPTY
38806: LIST
38807: LIST
38808: PUSH
38809: EMPTY
38810: LIST
38811: LIST
38812: LIST
38813: LIST
38814: LIST
38815: LIST
38816: LIST
38817: LIST
38818: LIST
38819: LIST
38820: LIST
38821: LIST
38822: LIST
38823: LIST
38824: LIST
38825: LIST
38826: LIST
38827: LIST
38828: LIST
38829: LIST
38830: LIST
38831: LIST
38832: LIST
38833: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
38834: LD_ADDR_VAR 0 33
38838: PUSH
38839: LD_INT 0
38841: PUSH
38842: LD_INT 0
38844: PUSH
38845: EMPTY
38846: LIST
38847: LIST
38848: PUSH
38849: LD_INT 0
38851: PUSH
38852: LD_INT 1
38854: NEG
38855: PUSH
38856: EMPTY
38857: LIST
38858: LIST
38859: PUSH
38860: LD_INT 1
38862: PUSH
38863: LD_INT 0
38865: PUSH
38866: EMPTY
38867: LIST
38868: LIST
38869: PUSH
38870: LD_INT 1
38872: PUSH
38873: LD_INT 1
38875: PUSH
38876: EMPTY
38877: LIST
38878: LIST
38879: PUSH
38880: LD_INT 0
38882: PUSH
38883: LD_INT 1
38885: PUSH
38886: EMPTY
38887: LIST
38888: LIST
38889: PUSH
38890: LD_INT 1
38892: NEG
38893: PUSH
38894: LD_INT 0
38896: PUSH
38897: EMPTY
38898: LIST
38899: LIST
38900: PUSH
38901: LD_INT 1
38903: NEG
38904: PUSH
38905: LD_INT 1
38907: NEG
38908: PUSH
38909: EMPTY
38910: LIST
38911: LIST
38912: PUSH
38913: LD_INT 1
38915: NEG
38916: PUSH
38917: LD_INT 2
38919: NEG
38920: PUSH
38921: EMPTY
38922: LIST
38923: LIST
38924: PUSH
38925: LD_INT 1
38927: PUSH
38928: LD_INT 1
38930: NEG
38931: PUSH
38932: EMPTY
38933: LIST
38934: LIST
38935: PUSH
38936: LD_INT 2
38938: PUSH
38939: LD_INT 0
38941: PUSH
38942: EMPTY
38943: LIST
38944: LIST
38945: PUSH
38946: LD_INT 2
38948: PUSH
38949: LD_INT 1
38951: PUSH
38952: EMPTY
38953: LIST
38954: LIST
38955: PUSH
38956: LD_INT 1
38958: PUSH
38959: LD_INT 2
38961: PUSH
38962: EMPTY
38963: LIST
38964: LIST
38965: PUSH
38966: LD_INT 0
38968: PUSH
38969: LD_INT 2
38971: PUSH
38972: EMPTY
38973: LIST
38974: LIST
38975: PUSH
38976: LD_INT 1
38978: NEG
38979: PUSH
38980: LD_INT 1
38982: PUSH
38983: EMPTY
38984: LIST
38985: LIST
38986: PUSH
38987: LD_INT 2
38989: NEG
38990: PUSH
38991: LD_INT 0
38993: PUSH
38994: EMPTY
38995: LIST
38996: LIST
38997: PUSH
38998: LD_INT 2
39000: NEG
39001: PUSH
39002: LD_INT 1
39004: NEG
39005: PUSH
39006: EMPTY
39007: LIST
39008: LIST
39009: PUSH
39010: LD_INT 2
39012: NEG
39013: PUSH
39014: LD_INT 2
39016: NEG
39017: PUSH
39018: EMPTY
39019: LIST
39020: LIST
39021: PUSH
39022: LD_INT 2
39024: NEG
39025: PUSH
39026: LD_INT 3
39028: NEG
39029: PUSH
39030: EMPTY
39031: LIST
39032: LIST
39033: PUSH
39034: LD_INT 2
39036: PUSH
39037: LD_INT 1
39039: NEG
39040: PUSH
39041: EMPTY
39042: LIST
39043: LIST
39044: PUSH
39045: LD_INT 3
39047: PUSH
39048: LD_INT 1
39050: PUSH
39051: EMPTY
39052: LIST
39053: LIST
39054: PUSH
39055: LD_INT 1
39057: PUSH
39058: LD_INT 3
39060: PUSH
39061: EMPTY
39062: LIST
39063: LIST
39064: PUSH
39065: LD_INT 1
39067: NEG
39068: PUSH
39069: LD_INT 2
39071: PUSH
39072: EMPTY
39073: LIST
39074: LIST
39075: PUSH
39076: LD_INT 3
39078: NEG
39079: PUSH
39080: LD_INT 2
39082: NEG
39083: PUSH
39084: EMPTY
39085: LIST
39086: LIST
39087: PUSH
39088: EMPTY
39089: LIST
39090: LIST
39091: LIST
39092: LIST
39093: LIST
39094: LIST
39095: LIST
39096: LIST
39097: LIST
39098: LIST
39099: LIST
39100: LIST
39101: LIST
39102: LIST
39103: LIST
39104: LIST
39105: LIST
39106: LIST
39107: LIST
39108: LIST
39109: LIST
39110: LIST
39111: LIST
39112: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
39113: LD_ADDR_VAR 0 34
39117: PUSH
39118: LD_INT 0
39120: PUSH
39121: LD_INT 0
39123: PUSH
39124: EMPTY
39125: LIST
39126: LIST
39127: PUSH
39128: LD_INT 0
39130: PUSH
39131: LD_INT 1
39133: NEG
39134: PUSH
39135: EMPTY
39136: LIST
39137: LIST
39138: PUSH
39139: LD_INT 1
39141: PUSH
39142: LD_INT 0
39144: PUSH
39145: EMPTY
39146: LIST
39147: LIST
39148: PUSH
39149: LD_INT 1
39151: PUSH
39152: LD_INT 1
39154: PUSH
39155: EMPTY
39156: LIST
39157: LIST
39158: PUSH
39159: LD_INT 0
39161: PUSH
39162: LD_INT 1
39164: PUSH
39165: EMPTY
39166: LIST
39167: LIST
39168: PUSH
39169: LD_INT 1
39171: NEG
39172: PUSH
39173: LD_INT 0
39175: PUSH
39176: EMPTY
39177: LIST
39178: LIST
39179: PUSH
39180: LD_INT 1
39182: NEG
39183: PUSH
39184: LD_INT 1
39186: NEG
39187: PUSH
39188: EMPTY
39189: LIST
39190: LIST
39191: PUSH
39192: LD_INT 1
39194: NEG
39195: PUSH
39196: LD_INT 2
39198: NEG
39199: PUSH
39200: EMPTY
39201: LIST
39202: LIST
39203: PUSH
39204: LD_INT 0
39206: PUSH
39207: LD_INT 2
39209: NEG
39210: PUSH
39211: EMPTY
39212: LIST
39213: LIST
39214: PUSH
39215: LD_INT 1
39217: PUSH
39218: LD_INT 1
39220: NEG
39221: PUSH
39222: EMPTY
39223: LIST
39224: LIST
39225: PUSH
39226: LD_INT 2
39228: PUSH
39229: LD_INT 1
39231: PUSH
39232: EMPTY
39233: LIST
39234: LIST
39235: PUSH
39236: LD_INT 2
39238: PUSH
39239: LD_INT 2
39241: PUSH
39242: EMPTY
39243: LIST
39244: LIST
39245: PUSH
39246: LD_INT 1
39248: PUSH
39249: LD_INT 2
39251: PUSH
39252: EMPTY
39253: LIST
39254: LIST
39255: PUSH
39256: LD_INT 1
39258: NEG
39259: PUSH
39260: LD_INT 1
39262: PUSH
39263: EMPTY
39264: LIST
39265: LIST
39266: PUSH
39267: LD_INT 2
39269: NEG
39270: PUSH
39271: LD_INT 0
39273: PUSH
39274: EMPTY
39275: LIST
39276: LIST
39277: PUSH
39278: LD_INT 2
39280: NEG
39281: PUSH
39282: LD_INT 1
39284: NEG
39285: PUSH
39286: EMPTY
39287: LIST
39288: LIST
39289: PUSH
39290: LD_INT 2
39292: NEG
39293: PUSH
39294: LD_INT 2
39296: NEG
39297: PUSH
39298: EMPTY
39299: LIST
39300: LIST
39301: PUSH
39302: LD_INT 1
39304: NEG
39305: PUSH
39306: LD_INT 3
39308: NEG
39309: PUSH
39310: EMPTY
39311: LIST
39312: LIST
39313: PUSH
39314: LD_INT 1
39316: PUSH
39317: LD_INT 2
39319: NEG
39320: PUSH
39321: EMPTY
39322: LIST
39323: LIST
39324: PUSH
39325: LD_INT 3
39327: PUSH
39328: LD_INT 2
39330: PUSH
39331: EMPTY
39332: LIST
39333: LIST
39334: PUSH
39335: LD_INT 2
39337: PUSH
39338: LD_INT 3
39340: PUSH
39341: EMPTY
39342: LIST
39343: LIST
39344: PUSH
39345: LD_INT 2
39347: NEG
39348: PUSH
39349: LD_INT 1
39351: PUSH
39352: EMPTY
39353: LIST
39354: LIST
39355: PUSH
39356: LD_INT 3
39358: NEG
39359: PUSH
39360: LD_INT 1
39362: NEG
39363: PUSH
39364: EMPTY
39365: LIST
39366: LIST
39367: PUSH
39368: EMPTY
39369: LIST
39370: LIST
39371: LIST
39372: LIST
39373: LIST
39374: LIST
39375: LIST
39376: LIST
39377: LIST
39378: LIST
39379: LIST
39380: LIST
39381: LIST
39382: LIST
39383: LIST
39384: LIST
39385: LIST
39386: LIST
39387: LIST
39388: LIST
39389: LIST
39390: LIST
39391: LIST
39392: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
39393: LD_ADDR_VAR 0 35
39397: PUSH
39398: LD_INT 0
39400: PUSH
39401: LD_INT 0
39403: PUSH
39404: EMPTY
39405: LIST
39406: LIST
39407: PUSH
39408: LD_INT 0
39410: PUSH
39411: LD_INT 1
39413: NEG
39414: PUSH
39415: EMPTY
39416: LIST
39417: LIST
39418: PUSH
39419: LD_INT 1
39421: PUSH
39422: LD_INT 0
39424: PUSH
39425: EMPTY
39426: LIST
39427: LIST
39428: PUSH
39429: LD_INT 1
39431: PUSH
39432: LD_INT 1
39434: PUSH
39435: EMPTY
39436: LIST
39437: LIST
39438: PUSH
39439: LD_INT 0
39441: PUSH
39442: LD_INT 1
39444: PUSH
39445: EMPTY
39446: LIST
39447: LIST
39448: PUSH
39449: LD_INT 1
39451: NEG
39452: PUSH
39453: LD_INT 0
39455: PUSH
39456: EMPTY
39457: LIST
39458: LIST
39459: PUSH
39460: LD_INT 1
39462: NEG
39463: PUSH
39464: LD_INT 1
39466: NEG
39467: PUSH
39468: EMPTY
39469: LIST
39470: LIST
39471: PUSH
39472: LD_INT 2
39474: PUSH
39475: LD_INT 1
39477: PUSH
39478: EMPTY
39479: LIST
39480: LIST
39481: PUSH
39482: LD_INT 2
39484: NEG
39485: PUSH
39486: LD_INT 1
39488: NEG
39489: PUSH
39490: EMPTY
39491: LIST
39492: LIST
39493: PUSH
39494: EMPTY
39495: LIST
39496: LIST
39497: LIST
39498: LIST
39499: LIST
39500: LIST
39501: LIST
39502: LIST
39503: LIST
39504: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
39505: LD_ADDR_VAR 0 36
39509: PUSH
39510: LD_INT 0
39512: PUSH
39513: LD_INT 0
39515: PUSH
39516: EMPTY
39517: LIST
39518: LIST
39519: PUSH
39520: LD_INT 0
39522: PUSH
39523: LD_INT 1
39525: NEG
39526: PUSH
39527: EMPTY
39528: LIST
39529: LIST
39530: PUSH
39531: LD_INT 1
39533: PUSH
39534: LD_INT 0
39536: PUSH
39537: EMPTY
39538: LIST
39539: LIST
39540: PUSH
39541: LD_INT 1
39543: PUSH
39544: LD_INT 1
39546: PUSH
39547: EMPTY
39548: LIST
39549: LIST
39550: PUSH
39551: LD_INT 0
39553: PUSH
39554: LD_INT 1
39556: PUSH
39557: EMPTY
39558: LIST
39559: LIST
39560: PUSH
39561: LD_INT 1
39563: NEG
39564: PUSH
39565: LD_INT 0
39567: PUSH
39568: EMPTY
39569: LIST
39570: LIST
39571: PUSH
39572: LD_INT 1
39574: NEG
39575: PUSH
39576: LD_INT 1
39578: NEG
39579: PUSH
39580: EMPTY
39581: LIST
39582: LIST
39583: PUSH
39584: LD_INT 1
39586: NEG
39587: PUSH
39588: LD_INT 2
39590: NEG
39591: PUSH
39592: EMPTY
39593: LIST
39594: LIST
39595: PUSH
39596: LD_INT 1
39598: PUSH
39599: LD_INT 2
39601: PUSH
39602: EMPTY
39603: LIST
39604: LIST
39605: PUSH
39606: EMPTY
39607: LIST
39608: LIST
39609: LIST
39610: LIST
39611: LIST
39612: LIST
39613: LIST
39614: LIST
39615: LIST
39616: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
39617: LD_ADDR_VAR 0 37
39621: PUSH
39622: LD_INT 0
39624: PUSH
39625: LD_INT 0
39627: PUSH
39628: EMPTY
39629: LIST
39630: LIST
39631: PUSH
39632: LD_INT 0
39634: PUSH
39635: LD_INT 1
39637: NEG
39638: PUSH
39639: EMPTY
39640: LIST
39641: LIST
39642: PUSH
39643: LD_INT 1
39645: PUSH
39646: LD_INT 0
39648: PUSH
39649: EMPTY
39650: LIST
39651: LIST
39652: PUSH
39653: LD_INT 1
39655: PUSH
39656: LD_INT 1
39658: PUSH
39659: EMPTY
39660: LIST
39661: LIST
39662: PUSH
39663: LD_INT 0
39665: PUSH
39666: LD_INT 1
39668: PUSH
39669: EMPTY
39670: LIST
39671: LIST
39672: PUSH
39673: LD_INT 1
39675: NEG
39676: PUSH
39677: LD_INT 0
39679: PUSH
39680: EMPTY
39681: LIST
39682: LIST
39683: PUSH
39684: LD_INT 1
39686: NEG
39687: PUSH
39688: LD_INT 1
39690: NEG
39691: PUSH
39692: EMPTY
39693: LIST
39694: LIST
39695: PUSH
39696: LD_INT 1
39698: PUSH
39699: LD_INT 1
39701: NEG
39702: PUSH
39703: EMPTY
39704: LIST
39705: LIST
39706: PUSH
39707: LD_INT 1
39709: NEG
39710: PUSH
39711: LD_INT 1
39713: PUSH
39714: EMPTY
39715: LIST
39716: LIST
39717: PUSH
39718: EMPTY
39719: LIST
39720: LIST
39721: LIST
39722: LIST
39723: LIST
39724: LIST
39725: LIST
39726: LIST
39727: LIST
39728: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
39729: LD_ADDR_VAR 0 38
39733: PUSH
39734: LD_INT 0
39736: PUSH
39737: LD_INT 0
39739: PUSH
39740: EMPTY
39741: LIST
39742: LIST
39743: PUSH
39744: LD_INT 0
39746: PUSH
39747: LD_INT 1
39749: NEG
39750: PUSH
39751: EMPTY
39752: LIST
39753: LIST
39754: PUSH
39755: LD_INT 1
39757: PUSH
39758: LD_INT 0
39760: PUSH
39761: EMPTY
39762: LIST
39763: LIST
39764: PUSH
39765: LD_INT 1
39767: PUSH
39768: LD_INT 1
39770: PUSH
39771: EMPTY
39772: LIST
39773: LIST
39774: PUSH
39775: LD_INT 0
39777: PUSH
39778: LD_INT 1
39780: PUSH
39781: EMPTY
39782: LIST
39783: LIST
39784: PUSH
39785: LD_INT 1
39787: NEG
39788: PUSH
39789: LD_INT 0
39791: PUSH
39792: EMPTY
39793: LIST
39794: LIST
39795: PUSH
39796: LD_INT 1
39798: NEG
39799: PUSH
39800: LD_INT 1
39802: NEG
39803: PUSH
39804: EMPTY
39805: LIST
39806: LIST
39807: PUSH
39808: LD_INT 2
39810: PUSH
39811: LD_INT 1
39813: PUSH
39814: EMPTY
39815: LIST
39816: LIST
39817: PUSH
39818: LD_INT 2
39820: NEG
39821: PUSH
39822: LD_INT 1
39824: NEG
39825: PUSH
39826: EMPTY
39827: LIST
39828: LIST
39829: PUSH
39830: EMPTY
39831: LIST
39832: LIST
39833: LIST
39834: LIST
39835: LIST
39836: LIST
39837: LIST
39838: LIST
39839: LIST
39840: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
39841: LD_ADDR_VAR 0 39
39845: PUSH
39846: LD_INT 0
39848: PUSH
39849: LD_INT 0
39851: PUSH
39852: EMPTY
39853: LIST
39854: LIST
39855: PUSH
39856: LD_INT 0
39858: PUSH
39859: LD_INT 1
39861: NEG
39862: PUSH
39863: EMPTY
39864: LIST
39865: LIST
39866: PUSH
39867: LD_INT 1
39869: PUSH
39870: LD_INT 0
39872: PUSH
39873: EMPTY
39874: LIST
39875: LIST
39876: PUSH
39877: LD_INT 1
39879: PUSH
39880: LD_INT 1
39882: PUSH
39883: EMPTY
39884: LIST
39885: LIST
39886: PUSH
39887: LD_INT 0
39889: PUSH
39890: LD_INT 1
39892: PUSH
39893: EMPTY
39894: LIST
39895: LIST
39896: PUSH
39897: LD_INT 1
39899: NEG
39900: PUSH
39901: LD_INT 0
39903: PUSH
39904: EMPTY
39905: LIST
39906: LIST
39907: PUSH
39908: LD_INT 1
39910: NEG
39911: PUSH
39912: LD_INT 1
39914: NEG
39915: PUSH
39916: EMPTY
39917: LIST
39918: LIST
39919: PUSH
39920: LD_INT 1
39922: NEG
39923: PUSH
39924: LD_INT 2
39926: NEG
39927: PUSH
39928: EMPTY
39929: LIST
39930: LIST
39931: PUSH
39932: LD_INT 1
39934: PUSH
39935: LD_INT 2
39937: PUSH
39938: EMPTY
39939: LIST
39940: LIST
39941: PUSH
39942: EMPTY
39943: LIST
39944: LIST
39945: LIST
39946: LIST
39947: LIST
39948: LIST
39949: LIST
39950: LIST
39951: LIST
39952: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
39953: LD_ADDR_VAR 0 40
39957: PUSH
39958: LD_INT 0
39960: PUSH
39961: LD_INT 0
39963: PUSH
39964: EMPTY
39965: LIST
39966: LIST
39967: PUSH
39968: LD_INT 0
39970: PUSH
39971: LD_INT 1
39973: NEG
39974: PUSH
39975: EMPTY
39976: LIST
39977: LIST
39978: PUSH
39979: LD_INT 1
39981: PUSH
39982: LD_INT 0
39984: PUSH
39985: EMPTY
39986: LIST
39987: LIST
39988: PUSH
39989: LD_INT 1
39991: PUSH
39992: LD_INT 1
39994: PUSH
39995: EMPTY
39996: LIST
39997: LIST
39998: PUSH
39999: LD_INT 0
40001: PUSH
40002: LD_INT 1
40004: PUSH
40005: EMPTY
40006: LIST
40007: LIST
40008: PUSH
40009: LD_INT 1
40011: NEG
40012: PUSH
40013: LD_INT 0
40015: PUSH
40016: EMPTY
40017: LIST
40018: LIST
40019: PUSH
40020: LD_INT 1
40022: NEG
40023: PUSH
40024: LD_INT 1
40026: NEG
40027: PUSH
40028: EMPTY
40029: LIST
40030: LIST
40031: PUSH
40032: LD_INT 1
40034: PUSH
40035: LD_INT 1
40037: NEG
40038: PUSH
40039: EMPTY
40040: LIST
40041: LIST
40042: PUSH
40043: LD_INT 1
40045: NEG
40046: PUSH
40047: LD_INT 1
40049: PUSH
40050: EMPTY
40051: LIST
40052: LIST
40053: PUSH
40054: EMPTY
40055: LIST
40056: LIST
40057: LIST
40058: LIST
40059: LIST
40060: LIST
40061: LIST
40062: LIST
40063: LIST
40064: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
40065: LD_ADDR_VAR 0 41
40069: PUSH
40070: LD_INT 0
40072: PUSH
40073: LD_INT 0
40075: PUSH
40076: EMPTY
40077: LIST
40078: LIST
40079: PUSH
40080: LD_INT 0
40082: PUSH
40083: LD_INT 1
40085: NEG
40086: PUSH
40087: EMPTY
40088: LIST
40089: LIST
40090: PUSH
40091: LD_INT 1
40093: PUSH
40094: LD_INT 0
40096: PUSH
40097: EMPTY
40098: LIST
40099: LIST
40100: PUSH
40101: LD_INT 1
40103: PUSH
40104: LD_INT 1
40106: PUSH
40107: EMPTY
40108: LIST
40109: LIST
40110: PUSH
40111: LD_INT 0
40113: PUSH
40114: LD_INT 1
40116: PUSH
40117: EMPTY
40118: LIST
40119: LIST
40120: PUSH
40121: LD_INT 1
40123: NEG
40124: PUSH
40125: LD_INT 0
40127: PUSH
40128: EMPTY
40129: LIST
40130: LIST
40131: PUSH
40132: LD_INT 1
40134: NEG
40135: PUSH
40136: LD_INT 1
40138: NEG
40139: PUSH
40140: EMPTY
40141: LIST
40142: LIST
40143: PUSH
40144: LD_INT 1
40146: NEG
40147: PUSH
40148: LD_INT 2
40150: NEG
40151: PUSH
40152: EMPTY
40153: LIST
40154: LIST
40155: PUSH
40156: LD_INT 1
40158: PUSH
40159: LD_INT 1
40161: NEG
40162: PUSH
40163: EMPTY
40164: LIST
40165: LIST
40166: PUSH
40167: LD_INT 2
40169: PUSH
40170: LD_INT 0
40172: PUSH
40173: EMPTY
40174: LIST
40175: LIST
40176: PUSH
40177: LD_INT 2
40179: PUSH
40180: LD_INT 1
40182: PUSH
40183: EMPTY
40184: LIST
40185: LIST
40186: PUSH
40187: LD_INT 2
40189: PUSH
40190: LD_INT 2
40192: PUSH
40193: EMPTY
40194: LIST
40195: LIST
40196: PUSH
40197: LD_INT 1
40199: PUSH
40200: LD_INT 2
40202: PUSH
40203: EMPTY
40204: LIST
40205: LIST
40206: PUSH
40207: LD_INT 1
40209: NEG
40210: PUSH
40211: LD_INT 1
40213: PUSH
40214: EMPTY
40215: LIST
40216: LIST
40217: PUSH
40218: LD_INT 2
40220: NEG
40221: PUSH
40222: LD_INT 0
40224: PUSH
40225: EMPTY
40226: LIST
40227: LIST
40228: PUSH
40229: LD_INT 2
40231: NEG
40232: PUSH
40233: LD_INT 1
40235: NEG
40236: PUSH
40237: EMPTY
40238: LIST
40239: LIST
40240: PUSH
40241: LD_INT 2
40243: NEG
40244: PUSH
40245: LD_INT 2
40247: NEG
40248: PUSH
40249: EMPTY
40250: LIST
40251: LIST
40252: PUSH
40253: LD_INT 2
40255: NEG
40256: PUSH
40257: LD_INT 3
40259: NEG
40260: PUSH
40261: EMPTY
40262: LIST
40263: LIST
40264: PUSH
40265: LD_INT 2
40267: PUSH
40268: LD_INT 1
40270: NEG
40271: PUSH
40272: EMPTY
40273: LIST
40274: LIST
40275: PUSH
40276: LD_INT 3
40278: PUSH
40279: LD_INT 0
40281: PUSH
40282: EMPTY
40283: LIST
40284: LIST
40285: PUSH
40286: LD_INT 3
40288: PUSH
40289: LD_INT 1
40291: PUSH
40292: EMPTY
40293: LIST
40294: LIST
40295: PUSH
40296: LD_INT 3
40298: PUSH
40299: LD_INT 2
40301: PUSH
40302: EMPTY
40303: LIST
40304: LIST
40305: PUSH
40306: LD_INT 3
40308: PUSH
40309: LD_INT 3
40311: PUSH
40312: EMPTY
40313: LIST
40314: LIST
40315: PUSH
40316: LD_INT 2
40318: PUSH
40319: LD_INT 3
40321: PUSH
40322: EMPTY
40323: LIST
40324: LIST
40325: PUSH
40326: LD_INT 2
40328: NEG
40329: PUSH
40330: LD_INT 1
40332: PUSH
40333: EMPTY
40334: LIST
40335: LIST
40336: PUSH
40337: LD_INT 3
40339: NEG
40340: PUSH
40341: LD_INT 0
40343: PUSH
40344: EMPTY
40345: LIST
40346: LIST
40347: PUSH
40348: LD_INT 3
40350: NEG
40351: PUSH
40352: LD_INT 1
40354: NEG
40355: PUSH
40356: EMPTY
40357: LIST
40358: LIST
40359: PUSH
40360: LD_INT 3
40362: NEG
40363: PUSH
40364: LD_INT 2
40366: NEG
40367: PUSH
40368: EMPTY
40369: LIST
40370: LIST
40371: PUSH
40372: LD_INT 3
40374: NEG
40375: PUSH
40376: LD_INT 3
40378: NEG
40379: PUSH
40380: EMPTY
40381: LIST
40382: LIST
40383: PUSH
40384: EMPTY
40385: LIST
40386: LIST
40387: LIST
40388: LIST
40389: LIST
40390: LIST
40391: LIST
40392: LIST
40393: LIST
40394: LIST
40395: LIST
40396: LIST
40397: LIST
40398: LIST
40399: LIST
40400: LIST
40401: LIST
40402: LIST
40403: LIST
40404: LIST
40405: LIST
40406: LIST
40407: LIST
40408: LIST
40409: LIST
40410: LIST
40411: LIST
40412: LIST
40413: LIST
40414: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
40415: LD_ADDR_VAR 0 42
40419: PUSH
40420: LD_INT 0
40422: PUSH
40423: LD_INT 0
40425: PUSH
40426: EMPTY
40427: LIST
40428: LIST
40429: PUSH
40430: LD_INT 0
40432: PUSH
40433: LD_INT 1
40435: NEG
40436: PUSH
40437: EMPTY
40438: LIST
40439: LIST
40440: PUSH
40441: LD_INT 1
40443: PUSH
40444: LD_INT 0
40446: PUSH
40447: EMPTY
40448: LIST
40449: LIST
40450: PUSH
40451: LD_INT 1
40453: PUSH
40454: LD_INT 1
40456: PUSH
40457: EMPTY
40458: LIST
40459: LIST
40460: PUSH
40461: LD_INT 0
40463: PUSH
40464: LD_INT 1
40466: PUSH
40467: EMPTY
40468: LIST
40469: LIST
40470: PUSH
40471: LD_INT 1
40473: NEG
40474: PUSH
40475: LD_INT 0
40477: PUSH
40478: EMPTY
40479: LIST
40480: LIST
40481: PUSH
40482: LD_INT 1
40484: NEG
40485: PUSH
40486: LD_INT 1
40488: NEG
40489: PUSH
40490: EMPTY
40491: LIST
40492: LIST
40493: PUSH
40494: LD_INT 1
40496: NEG
40497: PUSH
40498: LD_INT 2
40500: NEG
40501: PUSH
40502: EMPTY
40503: LIST
40504: LIST
40505: PUSH
40506: LD_INT 0
40508: PUSH
40509: LD_INT 2
40511: NEG
40512: PUSH
40513: EMPTY
40514: LIST
40515: LIST
40516: PUSH
40517: LD_INT 1
40519: PUSH
40520: LD_INT 1
40522: NEG
40523: PUSH
40524: EMPTY
40525: LIST
40526: LIST
40527: PUSH
40528: LD_INT 2
40530: PUSH
40531: LD_INT 1
40533: PUSH
40534: EMPTY
40535: LIST
40536: LIST
40537: PUSH
40538: LD_INT 2
40540: PUSH
40541: LD_INT 2
40543: PUSH
40544: EMPTY
40545: LIST
40546: LIST
40547: PUSH
40548: LD_INT 1
40550: PUSH
40551: LD_INT 2
40553: PUSH
40554: EMPTY
40555: LIST
40556: LIST
40557: PUSH
40558: LD_INT 0
40560: PUSH
40561: LD_INT 2
40563: PUSH
40564: EMPTY
40565: LIST
40566: LIST
40567: PUSH
40568: LD_INT 1
40570: NEG
40571: PUSH
40572: LD_INT 1
40574: PUSH
40575: EMPTY
40576: LIST
40577: LIST
40578: PUSH
40579: LD_INT 2
40581: NEG
40582: PUSH
40583: LD_INT 1
40585: NEG
40586: PUSH
40587: EMPTY
40588: LIST
40589: LIST
40590: PUSH
40591: LD_INT 2
40593: NEG
40594: PUSH
40595: LD_INT 2
40597: NEG
40598: PUSH
40599: EMPTY
40600: LIST
40601: LIST
40602: PUSH
40603: LD_INT 2
40605: NEG
40606: PUSH
40607: LD_INT 3
40609: NEG
40610: PUSH
40611: EMPTY
40612: LIST
40613: LIST
40614: PUSH
40615: LD_INT 1
40617: NEG
40618: PUSH
40619: LD_INT 3
40621: NEG
40622: PUSH
40623: EMPTY
40624: LIST
40625: LIST
40626: PUSH
40627: LD_INT 0
40629: PUSH
40630: LD_INT 3
40632: NEG
40633: PUSH
40634: EMPTY
40635: LIST
40636: LIST
40637: PUSH
40638: LD_INT 1
40640: PUSH
40641: LD_INT 2
40643: NEG
40644: PUSH
40645: EMPTY
40646: LIST
40647: LIST
40648: PUSH
40649: LD_INT 3
40651: PUSH
40652: LD_INT 2
40654: PUSH
40655: EMPTY
40656: LIST
40657: LIST
40658: PUSH
40659: LD_INT 3
40661: PUSH
40662: LD_INT 3
40664: PUSH
40665: EMPTY
40666: LIST
40667: LIST
40668: PUSH
40669: LD_INT 2
40671: PUSH
40672: LD_INT 3
40674: PUSH
40675: EMPTY
40676: LIST
40677: LIST
40678: PUSH
40679: LD_INT 1
40681: PUSH
40682: LD_INT 3
40684: PUSH
40685: EMPTY
40686: LIST
40687: LIST
40688: PUSH
40689: LD_INT 0
40691: PUSH
40692: LD_INT 3
40694: PUSH
40695: EMPTY
40696: LIST
40697: LIST
40698: PUSH
40699: LD_INT 1
40701: NEG
40702: PUSH
40703: LD_INT 2
40705: PUSH
40706: EMPTY
40707: LIST
40708: LIST
40709: PUSH
40710: LD_INT 3
40712: NEG
40713: PUSH
40714: LD_INT 2
40716: NEG
40717: PUSH
40718: EMPTY
40719: LIST
40720: LIST
40721: PUSH
40722: LD_INT 3
40724: NEG
40725: PUSH
40726: LD_INT 3
40728: NEG
40729: PUSH
40730: EMPTY
40731: LIST
40732: LIST
40733: PUSH
40734: EMPTY
40735: LIST
40736: LIST
40737: LIST
40738: LIST
40739: LIST
40740: LIST
40741: LIST
40742: LIST
40743: LIST
40744: LIST
40745: LIST
40746: LIST
40747: LIST
40748: LIST
40749: LIST
40750: LIST
40751: LIST
40752: LIST
40753: LIST
40754: LIST
40755: LIST
40756: LIST
40757: LIST
40758: LIST
40759: LIST
40760: LIST
40761: LIST
40762: LIST
40763: LIST
40764: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
40765: LD_ADDR_VAR 0 43
40769: PUSH
40770: LD_INT 0
40772: PUSH
40773: LD_INT 0
40775: PUSH
40776: EMPTY
40777: LIST
40778: LIST
40779: PUSH
40780: LD_INT 0
40782: PUSH
40783: LD_INT 1
40785: NEG
40786: PUSH
40787: EMPTY
40788: LIST
40789: LIST
40790: PUSH
40791: LD_INT 1
40793: PUSH
40794: LD_INT 0
40796: PUSH
40797: EMPTY
40798: LIST
40799: LIST
40800: PUSH
40801: LD_INT 1
40803: PUSH
40804: LD_INT 1
40806: PUSH
40807: EMPTY
40808: LIST
40809: LIST
40810: PUSH
40811: LD_INT 0
40813: PUSH
40814: LD_INT 1
40816: PUSH
40817: EMPTY
40818: LIST
40819: LIST
40820: PUSH
40821: LD_INT 1
40823: NEG
40824: PUSH
40825: LD_INT 0
40827: PUSH
40828: EMPTY
40829: LIST
40830: LIST
40831: PUSH
40832: LD_INT 1
40834: NEG
40835: PUSH
40836: LD_INT 1
40838: NEG
40839: PUSH
40840: EMPTY
40841: LIST
40842: LIST
40843: PUSH
40844: LD_INT 1
40846: NEG
40847: PUSH
40848: LD_INT 2
40850: NEG
40851: PUSH
40852: EMPTY
40853: LIST
40854: LIST
40855: PUSH
40856: LD_INT 0
40858: PUSH
40859: LD_INT 2
40861: NEG
40862: PUSH
40863: EMPTY
40864: LIST
40865: LIST
40866: PUSH
40867: LD_INT 1
40869: PUSH
40870: LD_INT 1
40872: NEG
40873: PUSH
40874: EMPTY
40875: LIST
40876: LIST
40877: PUSH
40878: LD_INT 2
40880: PUSH
40881: LD_INT 0
40883: PUSH
40884: EMPTY
40885: LIST
40886: LIST
40887: PUSH
40888: LD_INT 2
40890: PUSH
40891: LD_INT 1
40893: PUSH
40894: EMPTY
40895: LIST
40896: LIST
40897: PUSH
40898: LD_INT 1
40900: PUSH
40901: LD_INT 2
40903: PUSH
40904: EMPTY
40905: LIST
40906: LIST
40907: PUSH
40908: LD_INT 0
40910: PUSH
40911: LD_INT 2
40913: PUSH
40914: EMPTY
40915: LIST
40916: LIST
40917: PUSH
40918: LD_INT 1
40920: NEG
40921: PUSH
40922: LD_INT 1
40924: PUSH
40925: EMPTY
40926: LIST
40927: LIST
40928: PUSH
40929: LD_INT 2
40931: NEG
40932: PUSH
40933: LD_INT 0
40935: PUSH
40936: EMPTY
40937: LIST
40938: LIST
40939: PUSH
40940: LD_INT 2
40942: NEG
40943: PUSH
40944: LD_INT 1
40946: NEG
40947: PUSH
40948: EMPTY
40949: LIST
40950: LIST
40951: PUSH
40952: LD_INT 1
40954: NEG
40955: PUSH
40956: LD_INT 3
40958: NEG
40959: PUSH
40960: EMPTY
40961: LIST
40962: LIST
40963: PUSH
40964: LD_INT 0
40966: PUSH
40967: LD_INT 3
40969: NEG
40970: PUSH
40971: EMPTY
40972: LIST
40973: LIST
40974: PUSH
40975: LD_INT 1
40977: PUSH
40978: LD_INT 2
40980: NEG
40981: PUSH
40982: EMPTY
40983: LIST
40984: LIST
40985: PUSH
40986: LD_INT 2
40988: PUSH
40989: LD_INT 1
40991: NEG
40992: PUSH
40993: EMPTY
40994: LIST
40995: LIST
40996: PUSH
40997: LD_INT 3
40999: PUSH
41000: LD_INT 0
41002: PUSH
41003: EMPTY
41004: LIST
41005: LIST
41006: PUSH
41007: LD_INT 3
41009: PUSH
41010: LD_INT 1
41012: PUSH
41013: EMPTY
41014: LIST
41015: LIST
41016: PUSH
41017: LD_INT 1
41019: PUSH
41020: LD_INT 3
41022: PUSH
41023: EMPTY
41024: LIST
41025: LIST
41026: PUSH
41027: LD_INT 0
41029: PUSH
41030: LD_INT 3
41032: PUSH
41033: EMPTY
41034: LIST
41035: LIST
41036: PUSH
41037: LD_INT 1
41039: NEG
41040: PUSH
41041: LD_INT 2
41043: PUSH
41044: EMPTY
41045: LIST
41046: LIST
41047: PUSH
41048: LD_INT 2
41050: NEG
41051: PUSH
41052: LD_INT 1
41054: PUSH
41055: EMPTY
41056: LIST
41057: LIST
41058: PUSH
41059: LD_INT 3
41061: NEG
41062: PUSH
41063: LD_INT 0
41065: PUSH
41066: EMPTY
41067: LIST
41068: LIST
41069: PUSH
41070: LD_INT 3
41072: NEG
41073: PUSH
41074: LD_INT 1
41076: NEG
41077: PUSH
41078: EMPTY
41079: LIST
41080: LIST
41081: PUSH
41082: EMPTY
41083: LIST
41084: LIST
41085: LIST
41086: LIST
41087: LIST
41088: LIST
41089: LIST
41090: LIST
41091: LIST
41092: LIST
41093: LIST
41094: LIST
41095: LIST
41096: LIST
41097: LIST
41098: LIST
41099: LIST
41100: LIST
41101: LIST
41102: LIST
41103: LIST
41104: LIST
41105: LIST
41106: LIST
41107: LIST
41108: LIST
41109: LIST
41110: LIST
41111: LIST
41112: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
41113: LD_ADDR_VAR 0 44
41117: PUSH
41118: LD_INT 0
41120: PUSH
41121: LD_INT 0
41123: PUSH
41124: EMPTY
41125: LIST
41126: LIST
41127: PUSH
41128: LD_INT 0
41130: PUSH
41131: LD_INT 1
41133: NEG
41134: PUSH
41135: EMPTY
41136: LIST
41137: LIST
41138: PUSH
41139: LD_INT 1
41141: PUSH
41142: LD_INT 0
41144: PUSH
41145: EMPTY
41146: LIST
41147: LIST
41148: PUSH
41149: LD_INT 1
41151: PUSH
41152: LD_INT 1
41154: PUSH
41155: EMPTY
41156: LIST
41157: LIST
41158: PUSH
41159: LD_INT 0
41161: PUSH
41162: LD_INT 1
41164: PUSH
41165: EMPTY
41166: LIST
41167: LIST
41168: PUSH
41169: LD_INT 1
41171: NEG
41172: PUSH
41173: LD_INT 0
41175: PUSH
41176: EMPTY
41177: LIST
41178: LIST
41179: PUSH
41180: LD_INT 1
41182: NEG
41183: PUSH
41184: LD_INT 1
41186: NEG
41187: PUSH
41188: EMPTY
41189: LIST
41190: LIST
41191: PUSH
41192: LD_INT 1
41194: NEG
41195: PUSH
41196: LD_INT 2
41198: NEG
41199: PUSH
41200: EMPTY
41201: LIST
41202: LIST
41203: PUSH
41204: LD_INT 1
41206: PUSH
41207: LD_INT 1
41209: NEG
41210: PUSH
41211: EMPTY
41212: LIST
41213: LIST
41214: PUSH
41215: LD_INT 2
41217: PUSH
41218: LD_INT 0
41220: PUSH
41221: EMPTY
41222: LIST
41223: LIST
41224: PUSH
41225: LD_INT 2
41227: PUSH
41228: LD_INT 1
41230: PUSH
41231: EMPTY
41232: LIST
41233: LIST
41234: PUSH
41235: LD_INT 2
41237: PUSH
41238: LD_INT 2
41240: PUSH
41241: EMPTY
41242: LIST
41243: LIST
41244: PUSH
41245: LD_INT 1
41247: PUSH
41248: LD_INT 2
41250: PUSH
41251: EMPTY
41252: LIST
41253: LIST
41254: PUSH
41255: LD_INT 1
41257: NEG
41258: PUSH
41259: LD_INT 1
41261: PUSH
41262: EMPTY
41263: LIST
41264: LIST
41265: PUSH
41266: LD_INT 2
41268: NEG
41269: PUSH
41270: LD_INT 0
41272: PUSH
41273: EMPTY
41274: LIST
41275: LIST
41276: PUSH
41277: LD_INT 2
41279: NEG
41280: PUSH
41281: LD_INT 1
41283: NEG
41284: PUSH
41285: EMPTY
41286: LIST
41287: LIST
41288: PUSH
41289: LD_INT 2
41291: NEG
41292: PUSH
41293: LD_INT 2
41295: NEG
41296: PUSH
41297: EMPTY
41298: LIST
41299: LIST
41300: PUSH
41301: LD_INT 2
41303: NEG
41304: PUSH
41305: LD_INT 3
41307: NEG
41308: PUSH
41309: EMPTY
41310: LIST
41311: LIST
41312: PUSH
41313: LD_INT 2
41315: PUSH
41316: LD_INT 1
41318: NEG
41319: PUSH
41320: EMPTY
41321: LIST
41322: LIST
41323: PUSH
41324: LD_INT 3
41326: PUSH
41327: LD_INT 0
41329: PUSH
41330: EMPTY
41331: LIST
41332: LIST
41333: PUSH
41334: LD_INT 3
41336: PUSH
41337: LD_INT 1
41339: PUSH
41340: EMPTY
41341: LIST
41342: LIST
41343: PUSH
41344: LD_INT 3
41346: PUSH
41347: LD_INT 2
41349: PUSH
41350: EMPTY
41351: LIST
41352: LIST
41353: PUSH
41354: LD_INT 3
41356: PUSH
41357: LD_INT 3
41359: PUSH
41360: EMPTY
41361: LIST
41362: LIST
41363: PUSH
41364: LD_INT 2
41366: PUSH
41367: LD_INT 3
41369: PUSH
41370: EMPTY
41371: LIST
41372: LIST
41373: PUSH
41374: LD_INT 2
41376: NEG
41377: PUSH
41378: LD_INT 1
41380: PUSH
41381: EMPTY
41382: LIST
41383: LIST
41384: PUSH
41385: LD_INT 3
41387: NEG
41388: PUSH
41389: LD_INT 0
41391: PUSH
41392: EMPTY
41393: LIST
41394: LIST
41395: PUSH
41396: LD_INT 3
41398: NEG
41399: PUSH
41400: LD_INT 1
41402: NEG
41403: PUSH
41404: EMPTY
41405: LIST
41406: LIST
41407: PUSH
41408: LD_INT 3
41410: NEG
41411: PUSH
41412: LD_INT 2
41414: NEG
41415: PUSH
41416: EMPTY
41417: LIST
41418: LIST
41419: PUSH
41420: LD_INT 3
41422: NEG
41423: PUSH
41424: LD_INT 3
41426: NEG
41427: PUSH
41428: EMPTY
41429: LIST
41430: LIST
41431: PUSH
41432: EMPTY
41433: LIST
41434: LIST
41435: LIST
41436: LIST
41437: LIST
41438: LIST
41439: LIST
41440: LIST
41441: LIST
41442: LIST
41443: LIST
41444: LIST
41445: LIST
41446: LIST
41447: LIST
41448: LIST
41449: LIST
41450: LIST
41451: LIST
41452: LIST
41453: LIST
41454: LIST
41455: LIST
41456: LIST
41457: LIST
41458: LIST
41459: LIST
41460: LIST
41461: LIST
41462: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
41463: LD_ADDR_VAR 0 45
41467: PUSH
41468: LD_INT 0
41470: PUSH
41471: LD_INT 0
41473: PUSH
41474: EMPTY
41475: LIST
41476: LIST
41477: PUSH
41478: LD_INT 0
41480: PUSH
41481: LD_INT 1
41483: NEG
41484: PUSH
41485: EMPTY
41486: LIST
41487: LIST
41488: PUSH
41489: LD_INT 1
41491: PUSH
41492: LD_INT 0
41494: PUSH
41495: EMPTY
41496: LIST
41497: LIST
41498: PUSH
41499: LD_INT 1
41501: PUSH
41502: LD_INT 1
41504: PUSH
41505: EMPTY
41506: LIST
41507: LIST
41508: PUSH
41509: LD_INT 0
41511: PUSH
41512: LD_INT 1
41514: PUSH
41515: EMPTY
41516: LIST
41517: LIST
41518: PUSH
41519: LD_INT 1
41521: NEG
41522: PUSH
41523: LD_INT 0
41525: PUSH
41526: EMPTY
41527: LIST
41528: LIST
41529: PUSH
41530: LD_INT 1
41532: NEG
41533: PUSH
41534: LD_INT 1
41536: NEG
41537: PUSH
41538: EMPTY
41539: LIST
41540: LIST
41541: PUSH
41542: LD_INT 1
41544: NEG
41545: PUSH
41546: LD_INT 2
41548: NEG
41549: PUSH
41550: EMPTY
41551: LIST
41552: LIST
41553: PUSH
41554: LD_INT 0
41556: PUSH
41557: LD_INT 2
41559: NEG
41560: PUSH
41561: EMPTY
41562: LIST
41563: LIST
41564: PUSH
41565: LD_INT 1
41567: PUSH
41568: LD_INT 1
41570: NEG
41571: PUSH
41572: EMPTY
41573: LIST
41574: LIST
41575: PUSH
41576: LD_INT 2
41578: PUSH
41579: LD_INT 1
41581: PUSH
41582: EMPTY
41583: LIST
41584: LIST
41585: PUSH
41586: LD_INT 2
41588: PUSH
41589: LD_INT 2
41591: PUSH
41592: EMPTY
41593: LIST
41594: LIST
41595: PUSH
41596: LD_INT 1
41598: PUSH
41599: LD_INT 2
41601: PUSH
41602: EMPTY
41603: LIST
41604: LIST
41605: PUSH
41606: LD_INT 0
41608: PUSH
41609: LD_INT 2
41611: PUSH
41612: EMPTY
41613: LIST
41614: LIST
41615: PUSH
41616: LD_INT 1
41618: NEG
41619: PUSH
41620: LD_INT 1
41622: PUSH
41623: EMPTY
41624: LIST
41625: LIST
41626: PUSH
41627: LD_INT 2
41629: NEG
41630: PUSH
41631: LD_INT 1
41633: NEG
41634: PUSH
41635: EMPTY
41636: LIST
41637: LIST
41638: PUSH
41639: LD_INT 2
41641: NEG
41642: PUSH
41643: LD_INT 2
41645: NEG
41646: PUSH
41647: EMPTY
41648: LIST
41649: LIST
41650: PUSH
41651: LD_INT 2
41653: NEG
41654: PUSH
41655: LD_INT 3
41657: NEG
41658: PUSH
41659: EMPTY
41660: LIST
41661: LIST
41662: PUSH
41663: LD_INT 1
41665: NEG
41666: PUSH
41667: LD_INT 3
41669: NEG
41670: PUSH
41671: EMPTY
41672: LIST
41673: LIST
41674: PUSH
41675: LD_INT 0
41677: PUSH
41678: LD_INT 3
41680: NEG
41681: PUSH
41682: EMPTY
41683: LIST
41684: LIST
41685: PUSH
41686: LD_INT 1
41688: PUSH
41689: LD_INT 2
41691: NEG
41692: PUSH
41693: EMPTY
41694: LIST
41695: LIST
41696: PUSH
41697: LD_INT 3
41699: PUSH
41700: LD_INT 2
41702: PUSH
41703: EMPTY
41704: LIST
41705: LIST
41706: PUSH
41707: LD_INT 3
41709: PUSH
41710: LD_INT 3
41712: PUSH
41713: EMPTY
41714: LIST
41715: LIST
41716: PUSH
41717: LD_INT 2
41719: PUSH
41720: LD_INT 3
41722: PUSH
41723: EMPTY
41724: LIST
41725: LIST
41726: PUSH
41727: LD_INT 1
41729: PUSH
41730: LD_INT 3
41732: PUSH
41733: EMPTY
41734: LIST
41735: LIST
41736: PUSH
41737: LD_INT 0
41739: PUSH
41740: LD_INT 3
41742: PUSH
41743: EMPTY
41744: LIST
41745: LIST
41746: PUSH
41747: LD_INT 1
41749: NEG
41750: PUSH
41751: LD_INT 2
41753: PUSH
41754: EMPTY
41755: LIST
41756: LIST
41757: PUSH
41758: LD_INT 3
41760: NEG
41761: PUSH
41762: LD_INT 2
41764: NEG
41765: PUSH
41766: EMPTY
41767: LIST
41768: LIST
41769: PUSH
41770: LD_INT 3
41772: NEG
41773: PUSH
41774: LD_INT 3
41776: NEG
41777: PUSH
41778: EMPTY
41779: LIST
41780: LIST
41781: PUSH
41782: EMPTY
41783: LIST
41784: LIST
41785: LIST
41786: LIST
41787: LIST
41788: LIST
41789: LIST
41790: LIST
41791: LIST
41792: LIST
41793: LIST
41794: LIST
41795: LIST
41796: LIST
41797: LIST
41798: LIST
41799: LIST
41800: LIST
41801: LIST
41802: LIST
41803: LIST
41804: LIST
41805: LIST
41806: LIST
41807: LIST
41808: LIST
41809: LIST
41810: LIST
41811: LIST
41812: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
41813: LD_ADDR_VAR 0 46
41817: PUSH
41818: LD_INT 0
41820: PUSH
41821: LD_INT 0
41823: PUSH
41824: EMPTY
41825: LIST
41826: LIST
41827: PUSH
41828: LD_INT 0
41830: PUSH
41831: LD_INT 1
41833: NEG
41834: PUSH
41835: EMPTY
41836: LIST
41837: LIST
41838: PUSH
41839: LD_INT 1
41841: PUSH
41842: LD_INT 0
41844: PUSH
41845: EMPTY
41846: LIST
41847: LIST
41848: PUSH
41849: LD_INT 1
41851: PUSH
41852: LD_INT 1
41854: PUSH
41855: EMPTY
41856: LIST
41857: LIST
41858: PUSH
41859: LD_INT 0
41861: PUSH
41862: LD_INT 1
41864: PUSH
41865: EMPTY
41866: LIST
41867: LIST
41868: PUSH
41869: LD_INT 1
41871: NEG
41872: PUSH
41873: LD_INT 0
41875: PUSH
41876: EMPTY
41877: LIST
41878: LIST
41879: PUSH
41880: LD_INT 1
41882: NEG
41883: PUSH
41884: LD_INT 1
41886: NEG
41887: PUSH
41888: EMPTY
41889: LIST
41890: LIST
41891: PUSH
41892: LD_INT 1
41894: NEG
41895: PUSH
41896: LD_INT 2
41898: NEG
41899: PUSH
41900: EMPTY
41901: LIST
41902: LIST
41903: PUSH
41904: LD_INT 0
41906: PUSH
41907: LD_INT 2
41909: NEG
41910: PUSH
41911: EMPTY
41912: LIST
41913: LIST
41914: PUSH
41915: LD_INT 1
41917: PUSH
41918: LD_INT 1
41920: NEG
41921: PUSH
41922: EMPTY
41923: LIST
41924: LIST
41925: PUSH
41926: LD_INT 2
41928: PUSH
41929: LD_INT 0
41931: PUSH
41932: EMPTY
41933: LIST
41934: LIST
41935: PUSH
41936: LD_INT 2
41938: PUSH
41939: LD_INT 1
41941: PUSH
41942: EMPTY
41943: LIST
41944: LIST
41945: PUSH
41946: LD_INT 1
41948: PUSH
41949: LD_INT 2
41951: PUSH
41952: EMPTY
41953: LIST
41954: LIST
41955: PUSH
41956: LD_INT 0
41958: PUSH
41959: LD_INT 2
41961: PUSH
41962: EMPTY
41963: LIST
41964: LIST
41965: PUSH
41966: LD_INT 1
41968: NEG
41969: PUSH
41970: LD_INT 1
41972: PUSH
41973: EMPTY
41974: LIST
41975: LIST
41976: PUSH
41977: LD_INT 2
41979: NEG
41980: PUSH
41981: LD_INT 0
41983: PUSH
41984: EMPTY
41985: LIST
41986: LIST
41987: PUSH
41988: LD_INT 2
41990: NEG
41991: PUSH
41992: LD_INT 1
41994: NEG
41995: PUSH
41996: EMPTY
41997: LIST
41998: LIST
41999: PUSH
42000: LD_INT 1
42002: NEG
42003: PUSH
42004: LD_INT 3
42006: NEG
42007: PUSH
42008: EMPTY
42009: LIST
42010: LIST
42011: PUSH
42012: LD_INT 0
42014: PUSH
42015: LD_INT 3
42017: NEG
42018: PUSH
42019: EMPTY
42020: LIST
42021: LIST
42022: PUSH
42023: LD_INT 1
42025: PUSH
42026: LD_INT 2
42028: NEG
42029: PUSH
42030: EMPTY
42031: LIST
42032: LIST
42033: PUSH
42034: LD_INT 2
42036: PUSH
42037: LD_INT 1
42039: NEG
42040: PUSH
42041: EMPTY
42042: LIST
42043: LIST
42044: PUSH
42045: LD_INT 3
42047: PUSH
42048: LD_INT 0
42050: PUSH
42051: EMPTY
42052: LIST
42053: LIST
42054: PUSH
42055: LD_INT 3
42057: PUSH
42058: LD_INT 1
42060: PUSH
42061: EMPTY
42062: LIST
42063: LIST
42064: PUSH
42065: LD_INT 1
42067: PUSH
42068: LD_INT 3
42070: PUSH
42071: EMPTY
42072: LIST
42073: LIST
42074: PUSH
42075: LD_INT 0
42077: PUSH
42078: LD_INT 3
42080: PUSH
42081: EMPTY
42082: LIST
42083: LIST
42084: PUSH
42085: LD_INT 1
42087: NEG
42088: PUSH
42089: LD_INT 2
42091: PUSH
42092: EMPTY
42093: LIST
42094: LIST
42095: PUSH
42096: LD_INT 2
42098: NEG
42099: PUSH
42100: LD_INT 1
42102: PUSH
42103: EMPTY
42104: LIST
42105: LIST
42106: PUSH
42107: LD_INT 3
42109: NEG
42110: PUSH
42111: LD_INT 0
42113: PUSH
42114: EMPTY
42115: LIST
42116: LIST
42117: PUSH
42118: LD_INT 3
42120: NEG
42121: PUSH
42122: LD_INT 1
42124: NEG
42125: PUSH
42126: EMPTY
42127: LIST
42128: LIST
42129: PUSH
42130: EMPTY
42131: LIST
42132: LIST
42133: LIST
42134: LIST
42135: LIST
42136: LIST
42137: LIST
42138: LIST
42139: LIST
42140: LIST
42141: LIST
42142: LIST
42143: LIST
42144: LIST
42145: LIST
42146: LIST
42147: LIST
42148: LIST
42149: LIST
42150: LIST
42151: LIST
42152: LIST
42153: LIST
42154: LIST
42155: LIST
42156: LIST
42157: LIST
42158: LIST
42159: LIST
42160: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
42161: LD_ADDR_VAR 0 47
42165: PUSH
42166: LD_INT 0
42168: PUSH
42169: LD_INT 0
42171: PUSH
42172: EMPTY
42173: LIST
42174: LIST
42175: PUSH
42176: LD_INT 0
42178: PUSH
42179: LD_INT 1
42181: NEG
42182: PUSH
42183: EMPTY
42184: LIST
42185: LIST
42186: PUSH
42187: LD_INT 1
42189: PUSH
42190: LD_INT 0
42192: PUSH
42193: EMPTY
42194: LIST
42195: LIST
42196: PUSH
42197: LD_INT 1
42199: PUSH
42200: LD_INT 1
42202: PUSH
42203: EMPTY
42204: LIST
42205: LIST
42206: PUSH
42207: LD_INT 0
42209: PUSH
42210: LD_INT 1
42212: PUSH
42213: EMPTY
42214: LIST
42215: LIST
42216: PUSH
42217: LD_INT 1
42219: NEG
42220: PUSH
42221: LD_INT 0
42223: PUSH
42224: EMPTY
42225: LIST
42226: LIST
42227: PUSH
42228: LD_INT 1
42230: NEG
42231: PUSH
42232: LD_INT 1
42234: NEG
42235: PUSH
42236: EMPTY
42237: LIST
42238: LIST
42239: PUSH
42240: LD_INT 1
42242: NEG
42243: PUSH
42244: LD_INT 2
42246: NEG
42247: PUSH
42248: EMPTY
42249: LIST
42250: LIST
42251: PUSH
42252: LD_INT 0
42254: PUSH
42255: LD_INT 2
42257: NEG
42258: PUSH
42259: EMPTY
42260: LIST
42261: LIST
42262: PUSH
42263: LD_INT 1
42265: PUSH
42266: LD_INT 1
42268: NEG
42269: PUSH
42270: EMPTY
42271: LIST
42272: LIST
42273: PUSH
42274: LD_INT 2
42276: NEG
42277: PUSH
42278: LD_INT 1
42280: NEG
42281: PUSH
42282: EMPTY
42283: LIST
42284: LIST
42285: PUSH
42286: LD_INT 2
42288: NEG
42289: PUSH
42290: LD_INT 2
42292: NEG
42293: PUSH
42294: EMPTY
42295: LIST
42296: LIST
42297: PUSH
42298: EMPTY
42299: LIST
42300: LIST
42301: LIST
42302: LIST
42303: LIST
42304: LIST
42305: LIST
42306: LIST
42307: LIST
42308: LIST
42309: LIST
42310: LIST
42311: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
42312: LD_ADDR_VAR 0 48
42316: PUSH
42317: LD_INT 0
42319: PUSH
42320: LD_INT 0
42322: PUSH
42323: EMPTY
42324: LIST
42325: LIST
42326: PUSH
42327: LD_INT 0
42329: PUSH
42330: LD_INT 1
42332: NEG
42333: PUSH
42334: EMPTY
42335: LIST
42336: LIST
42337: PUSH
42338: LD_INT 1
42340: PUSH
42341: LD_INT 0
42343: PUSH
42344: EMPTY
42345: LIST
42346: LIST
42347: PUSH
42348: LD_INT 1
42350: PUSH
42351: LD_INT 1
42353: PUSH
42354: EMPTY
42355: LIST
42356: LIST
42357: PUSH
42358: LD_INT 0
42360: PUSH
42361: LD_INT 1
42363: PUSH
42364: EMPTY
42365: LIST
42366: LIST
42367: PUSH
42368: LD_INT 1
42370: NEG
42371: PUSH
42372: LD_INT 0
42374: PUSH
42375: EMPTY
42376: LIST
42377: LIST
42378: PUSH
42379: LD_INT 1
42381: NEG
42382: PUSH
42383: LD_INT 1
42385: NEG
42386: PUSH
42387: EMPTY
42388: LIST
42389: LIST
42390: PUSH
42391: LD_INT 1
42393: NEG
42394: PUSH
42395: LD_INT 2
42397: NEG
42398: PUSH
42399: EMPTY
42400: LIST
42401: LIST
42402: PUSH
42403: LD_INT 0
42405: PUSH
42406: LD_INT 2
42408: NEG
42409: PUSH
42410: EMPTY
42411: LIST
42412: LIST
42413: PUSH
42414: LD_INT 1
42416: PUSH
42417: LD_INT 1
42419: NEG
42420: PUSH
42421: EMPTY
42422: LIST
42423: LIST
42424: PUSH
42425: LD_INT 2
42427: PUSH
42428: LD_INT 0
42430: PUSH
42431: EMPTY
42432: LIST
42433: LIST
42434: PUSH
42435: LD_INT 2
42437: PUSH
42438: LD_INT 1
42440: PUSH
42441: EMPTY
42442: LIST
42443: LIST
42444: PUSH
42445: EMPTY
42446: LIST
42447: LIST
42448: LIST
42449: LIST
42450: LIST
42451: LIST
42452: LIST
42453: LIST
42454: LIST
42455: LIST
42456: LIST
42457: LIST
42458: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
42459: LD_ADDR_VAR 0 49
42463: PUSH
42464: LD_INT 0
42466: PUSH
42467: LD_INT 0
42469: PUSH
42470: EMPTY
42471: LIST
42472: LIST
42473: PUSH
42474: LD_INT 0
42476: PUSH
42477: LD_INT 1
42479: NEG
42480: PUSH
42481: EMPTY
42482: LIST
42483: LIST
42484: PUSH
42485: LD_INT 1
42487: PUSH
42488: LD_INT 0
42490: PUSH
42491: EMPTY
42492: LIST
42493: LIST
42494: PUSH
42495: LD_INT 1
42497: PUSH
42498: LD_INT 1
42500: PUSH
42501: EMPTY
42502: LIST
42503: LIST
42504: PUSH
42505: LD_INT 0
42507: PUSH
42508: LD_INT 1
42510: PUSH
42511: EMPTY
42512: LIST
42513: LIST
42514: PUSH
42515: LD_INT 1
42517: NEG
42518: PUSH
42519: LD_INT 0
42521: PUSH
42522: EMPTY
42523: LIST
42524: LIST
42525: PUSH
42526: LD_INT 1
42528: NEG
42529: PUSH
42530: LD_INT 1
42532: NEG
42533: PUSH
42534: EMPTY
42535: LIST
42536: LIST
42537: PUSH
42538: LD_INT 1
42540: PUSH
42541: LD_INT 1
42543: NEG
42544: PUSH
42545: EMPTY
42546: LIST
42547: LIST
42548: PUSH
42549: LD_INT 2
42551: PUSH
42552: LD_INT 0
42554: PUSH
42555: EMPTY
42556: LIST
42557: LIST
42558: PUSH
42559: LD_INT 2
42561: PUSH
42562: LD_INT 1
42564: PUSH
42565: EMPTY
42566: LIST
42567: LIST
42568: PUSH
42569: LD_INT 2
42571: PUSH
42572: LD_INT 2
42574: PUSH
42575: EMPTY
42576: LIST
42577: LIST
42578: PUSH
42579: LD_INT 1
42581: PUSH
42582: LD_INT 2
42584: PUSH
42585: EMPTY
42586: LIST
42587: LIST
42588: PUSH
42589: EMPTY
42590: LIST
42591: LIST
42592: LIST
42593: LIST
42594: LIST
42595: LIST
42596: LIST
42597: LIST
42598: LIST
42599: LIST
42600: LIST
42601: LIST
42602: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
42603: LD_ADDR_VAR 0 50
42607: PUSH
42608: LD_INT 0
42610: PUSH
42611: LD_INT 0
42613: PUSH
42614: EMPTY
42615: LIST
42616: LIST
42617: PUSH
42618: LD_INT 0
42620: PUSH
42621: LD_INT 1
42623: NEG
42624: PUSH
42625: EMPTY
42626: LIST
42627: LIST
42628: PUSH
42629: LD_INT 1
42631: PUSH
42632: LD_INT 0
42634: PUSH
42635: EMPTY
42636: LIST
42637: LIST
42638: PUSH
42639: LD_INT 1
42641: PUSH
42642: LD_INT 1
42644: PUSH
42645: EMPTY
42646: LIST
42647: LIST
42648: PUSH
42649: LD_INT 0
42651: PUSH
42652: LD_INT 1
42654: PUSH
42655: EMPTY
42656: LIST
42657: LIST
42658: PUSH
42659: LD_INT 1
42661: NEG
42662: PUSH
42663: LD_INT 0
42665: PUSH
42666: EMPTY
42667: LIST
42668: LIST
42669: PUSH
42670: LD_INT 1
42672: NEG
42673: PUSH
42674: LD_INT 1
42676: NEG
42677: PUSH
42678: EMPTY
42679: LIST
42680: LIST
42681: PUSH
42682: LD_INT 2
42684: PUSH
42685: LD_INT 1
42687: PUSH
42688: EMPTY
42689: LIST
42690: LIST
42691: PUSH
42692: LD_INT 2
42694: PUSH
42695: LD_INT 2
42697: PUSH
42698: EMPTY
42699: LIST
42700: LIST
42701: PUSH
42702: LD_INT 1
42704: PUSH
42705: LD_INT 2
42707: PUSH
42708: EMPTY
42709: LIST
42710: LIST
42711: PUSH
42712: LD_INT 0
42714: PUSH
42715: LD_INT 2
42717: PUSH
42718: EMPTY
42719: LIST
42720: LIST
42721: PUSH
42722: LD_INT 1
42724: NEG
42725: PUSH
42726: LD_INT 1
42728: PUSH
42729: EMPTY
42730: LIST
42731: LIST
42732: PUSH
42733: EMPTY
42734: LIST
42735: LIST
42736: LIST
42737: LIST
42738: LIST
42739: LIST
42740: LIST
42741: LIST
42742: LIST
42743: LIST
42744: LIST
42745: LIST
42746: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
42747: LD_ADDR_VAR 0 51
42751: PUSH
42752: LD_INT 0
42754: PUSH
42755: LD_INT 0
42757: PUSH
42758: EMPTY
42759: LIST
42760: LIST
42761: PUSH
42762: LD_INT 0
42764: PUSH
42765: LD_INT 1
42767: NEG
42768: PUSH
42769: EMPTY
42770: LIST
42771: LIST
42772: PUSH
42773: LD_INT 1
42775: PUSH
42776: LD_INT 0
42778: PUSH
42779: EMPTY
42780: LIST
42781: LIST
42782: PUSH
42783: LD_INT 1
42785: PUSH
42786: LD_INT 1
42788: PUSH
42789: EMPTY
42790: LIST
42791: LIST
42792: PUSH
42793: LD_INT 0
42795: PUSH
42796: LD_INT 1
42798: PUSH
42799: EMPTY
42800: LIST
42801: LIST
42802: PUSH
42803: LD_INT 1
42805: NEG
42806: PUSH
42807: LD_INT 0
42809: PUSH
42810: EMPTY
42811: LIST
42812: LIST
42813: PUSH
42814: LD_INT 1
42816: NEG
42817: PUSH
42818: LD_INT 1
42820: NEG
42821: PUSH
42822: EMPTY
42823: LIST
42824: LIST
42825: PUSH
42826: LD_INT 1
42828: PUSH
42829: LD_INT 2
42831: PUSH
42832: EMPTY
42833: LIST
42834: LIST
42835: PUSH
42836: LD_INT 0
42838: PUSH
42839: LD_INT 2
42841: PUSH
42842: EMPTY
42843: LIST
42844: LIST
42845: PUSH
42846: LD_INT 1
42848: NEG
42849: PUSH
42850: LD_INT 1
42852: PUSH
42853: EMPTY
42854: LIST
42855: LIST
42856: PUSH
42857: LD_INT 2
42859: NEG
42860: PUSH
42861: LD_INT 0
42863: PUSH
42864: EMPTY
42865: LIST
42866: LIST
42867: PUSH
42868: LD_INT 2
42870: NEG
42871: PUSH
42872: LD_INT 1
42874: NEG
42875: PUSH
42876: EMPTY
42877: LIST
42878: LIST
42879: PUSH
42880: EMPTY
42881: LIST
42882: LIST
42883: LIST
42884: LIST
42885: LIST
42886: LIST
42887: LIST
42888: LIST
42889: LIST
42890: LIST
42891: LIST
42892: LIST
42893: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
42894: LD_ADDR_VAR 0 52
42898: PUSH
42899: LD_INT 0
42901: PUSH
42902: LD_INT 0
42904: PUSH
42905: EMPTY
42906: LIST
42907: LIST
42908: PUSH
42909: LD_INT 0
42911: PUSH
42912: LD_INT 1
42914: NEG
42915: PUSH
42916: EMPTY
42917: LIST
42918: LIST
42919: PUSH
42920: LD_INT 1
42922: PUSH
42923: LD_INT 0
42925: PUSH
42926: EMPTY
42927: LIST
42928: LIST
42929: PUSH
42930: LD_INT 1
42932: PUSH
42933: LD_INT 1
42935: PUSH
42936: EMPTY
42937: LIST
42938: LIST
42939: PUSH
42940: LD_INT 0
42942: PUSH
42943: LD_INT 1
42945: PUSH
42946: EMPTY
42947: LIST
42948: LIST
42949: PUSH
42950: LD_INT 1
42952: NEG
42953: PUSH
42954: LD_INT 0
42956: PUSH
42957: EMPTY
42958: LIST
42959: LIST
42960: PUSH
42961: LD_INT 1
42963: NEG
42964: PUSH
42965: LD_INT 1
42967: NEG
42968: PUSH
42969: EMPTY
42970: LIST
42971: LIST
42972: PUSH
42973: LD_INT 1
42975: NEG
42976: PUSH
42977: LD_INT 2
42979: NEG
42980: PUSH
42981: EMPTY
42982: LIST
42983: LIST
42984: PUSH
42985: LD_INT 1
42987: NEG
42988: PUSH
42989: LD_INT 1
42991: PUSH
42992: EMPTY
42993: LIST
42994: LIST
42995: PUSH
42996: LD_INT 2
42998: NEG
42999: PUSH
43000: LD_INT 0
43002: PUSH
43003: EMPTY
43004: LIST
43005: LIST
43006: PUSH
43007: LD_INT 2
43009: NEG
43010: PUSH
43011: LD_INT 1
43013: NEG
43014: PUSH
43015: EMPTY
43016: LIST
43017: LIST
43018: PUSH
43019: LD_INT 2
43021: NEG
43022: PUSH
43023: LD_INT 2
43025: NEG
43026: PUSH
43027: EMPTY
43028: LIST
43029: LIST
43030: PUSH
43031: EMPTY
43032: LIST
43033: LIST
43034: LIST
43035: LIST
43036: LIST
43037: LIST
43038: LIST
43039: LIST
43040: LIST
43041: LIST
43042: LIST
43043: LIST
43044: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
43045: LD_ADDR_VAR 0 53
43049: PUSH
43050: LD_INT 0
43052: PUSH
43053: LD_INT 0
43055: PUSH
43056: EMPTY
43057: LIST
43058: LIST
43059: PUSH
43060: LD_INT 0
43062: PUSH
43063: LD_INT 1
43065: NEG
43066: PUSH
43067: EMPTY
43068: LIST
43069: LIST
43070: PUSH
43071: LD_INT 1
43073: PUSH
43074: LD_INT 0
43076: PUSH
43077: EMPTY
43078: LIST
43079: LIST
43080: PUSH
43081: LD_INT 1
43083: PUSH
43084: LD_INT 1
43086: PUSH
43087: EMPTY
43088: LIST
43089: LIST
43090: PUSH
43091: LD_INT 0
43093: PUSH
43094: LD_INT 1
43096: PUSH
43097: EMPTY
43098: LIST
43099: LIST
43100: PUSH
43101: LD_INT 1
43103: NEG
43104: PUSH
43105: LD_INT 0
43107: PUSH
43108: EMPTY
43109: LIST
43110: LIST
43111: PUSH
43112: LD_INT 1
43114: NEG
43115: PUSH
43116: LD_INT 1
43118: NEG
43119: PUSH
43120: EMPTY
43121: LIST
43122: LIST
43123: PUSH
43124: LD_INT 1
43126: NEG
43127: PUSH
43128: LD_INT 2
43130: NEG
43131: PUSH
43132: EMPTY
43133: LIST
43134: LIST
43135: PUSH
43136: LD_INT 0
43138: PUSH
43139: LD_INT 2
43141: NEG
43142: PUSH
43143: EMPTY
43144: LIST
43145: LIST
43146: PUSH
43147: LD_INT 1
43149: PUSH
43150: LD_INT 1
43152: NEG
43153: PUSH
43154: EMPTY
43155: LIST
43156: LIST
43157: PUSH
43158: LD_INT 2
43160: PUSH
43161: LD_INT 0
43163: PUSH
43164: EMPTY
43165: LIST
43166: LIST
43167: PUSH
43168: LD_INT 2
43170: PUSH
43171: LD_INT 1
43173: PUSH
43174: EMPTY
43175: LIST
43176: LIST
43177: PUSH
43178: LD_INT 2
43180: PUSH
43181: LD_INT 2
43183: PUSH
43184: EMPTY
43185: LIST
43186: LIST
43187: PUSH
43188: LD_INT 1
43190: PUSH
43191: LD_INT 2
43193: PUSH
43194: EMPTY
43195: LIST
43196: LIST
43197: PUSH
43198: LD_INT 0
43200: PUSH
43201: LD_INT 2
43203: PUSH
43204: EMPTY
43205: LIST
43206: LIST
43207: PUSH
43208: LD_INT 1
43210: NEG
43211: PUSH
43212: LD_INT 1
43214: PUSH
43215: EMPTY
43216: LIST
43217: LIST
43218: PUSH
43219: LD_INT 2
43221: NEG
43222: PUSH
43223: LD_INT 0
43225: PUSH
43226: EMPTY
43227: LIST
43228: LIST
43229: PUSH
43230: LD_INT 2
43232: NEG
43233: PUSH
43234: LD_INT 1
43236: NEG
43237: PUSH
43238: EMPTY
43239: LIST
43240: LIST
43241: PUSH
43242: LD_INT 2
43244: NEG
43245: PUSH
43246: LD_INT 2
43248: NEG
43249: PUSH
43250: EMPTY
43251: LIST
43252: LIST
43253: PUSH
43254: EMPTY
43255: LIST
43256: LIST
43257: LIST
43258: LIST
43259: LIST
43260: LIST
43261: LIST
43262: LIST
43263: LIST
43264: LIST
43265: LIST
43266: LIST
43267: LIST
43268: LIST
43269: LIST
43270: LIST
43271: LIST
43272: LIST
43273: LIST
43274: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
43275: LD_ADDR_VAR 0 54
43279: PUSH
43280: LD_INT 0
43282: PUSH
43283: LD_INT 0
43285: PUSH
43286: EMPTY
43287: LIST
43288: LIST
43289: PUSH
43290: LD_INT 0
43292: PUSH
43293: LD_INT 1
43295: NEG
43296: PUSH
43297: EMPTY
43298: LIST
43299: LIST
43300: PUSH
43301: LD_INT 1
43303: PUSH
43304: LD_INT 0
43306: PUSH
43307: EMPTY
43308: LIST
43309: LIST
43310: PUSH
43311: LD_INT 1
43313: PUSH
43314: LD_INT 1
43316: PUSH
43317: EMPTY
43318: LIST
43319: LIST
43320: PUSH
43321: LD_INT 0
43323: PUSH
43324: LD_INT 1
43326: PUSH
43327: EMPTY
43328: LIST
43329: LIST
43330: PUSH
43331: LD_INT 1
43333: NEG
43334: PUSH
43335: LD_INT 0
43337: PUSH
43338: EMPTY
43339: LIST
43340: LIST
43341: PUSH
43342: LD_INT 1
43344: NEG
43345: PUSH
43346: LD_INT 1
43348: NEG
43349: PUSH
43350: EMPTY
43351: LIST
43352: LIST
43353: PUSH
43354: LD_INT 1
43356: NEG
43357: PUSH
43358: LD_INT 2
43360: NEG
43361: PUSH
43362: EMPTY
43363: LIST
43364: LIST
43365: PUSH
43366: LD_INT 0
43368: PUSH
43369: LD_INT 2
43371: NEG
43372: PUSH
43373: EMPTY
43374: LIST
43375: LIST
43376: PUSH
43377: LD_INT 1
43379: PUSH
43380: LD_INT 1
43382: NEG
43383: PUSH
43384: EMPTY
43385: LIST
43386: LIST
43387: PUSH
43388: LD_INT 2
43390: PUSH
43391: LD_INT 0
43393: PUSH
43394: EMPTY
43395: LIST
43396: LIST
43397: PUSH
43398: LD_INT 2
43400: PUSH
43401: LD_INT 1
43403: PUSH
43404: EMPTY
43405: LIST
43406: LIST
43407: PUSH
43408: LD_INT 2
43410: PUSH
43411: LD_INT 2
43413: PUSH
43414: EMPTY
43415: LIST
43416: LIST
43417: PUSH
43418: LD_INT 1
43420: PUSH
43421: LD_INT 2
43423: PUSH
43424: EMPTY
43425: LIST
43426: LIST
43427: PUSH
43428: LD_INT 0
43430: PUSH
43431: LD_INT 2
43433: PUSH
43434: EMPTY
43435: LIST
43436: LIST
43437: PUSH
43438: LD_INT 1
43440: NEG
43441: PUSH
43442: LD_INT 1
43444: PUSH
43445: EMPTY
43446: LIST
43447: LIST
43448: PUSH
43449: LD_INT 2
43451: NEG
43452: PUSH
43453: LD_INT 0
43455: PUSH
43456: EMPTY
43457: LIST
43458: LIST
43459: PUSH
43460: LD_INT 2
43462: NEG
43463: PUSH
43464: LD_INT 1
43466: NEG
43467: PUSH
43468: EMPTY
43469: LIST
43470: LIST
43471: PUSH
43472: LD_INT 2
43474: NEG
43475: PUSH
43476: LD_INT 2
43478: NEG
43479: PUSH
43480: EMPTY
43481: LIST
43482: LIST
43483: PUSH
43484: EMPTY
43485: LIST
43486: LIST
43487: LIST
43488: LIST
43489: LIST
43490: LIST
43491: LIST
43492: LIST
43493: LIST
43494: LIST
43495: LIST
43496: LIST
43497: LIST
43498: LIST
43499: LIST
43500: LIST
43501: LIST
43502: LIST
43503: LIST
43504: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
43505: LD_ADDR_VAR 0 55
43509: PUSH
43510: LD_INT 0
43512: PUSH
43513: LD_INT 0
43515: PUSH
43516: EMPTY
43517: LIST
43518: LIST
43519: PUSH
43520: LD_INT 0
43522: PUSH
43523: LD_INT 1
43525: NEG
43526: PUSH
43527: EMPTY
43528: LIST
43529: LIST
43530: PUSH
43531: LD_INT 1
43533: PUSH
43534: LD_INT 0
43536: PUSH
43537: EMPTY
43538: LIST
43539: LIST
43540: PUSH
43541: LD_INT 1
43543: PUSH
43544: LD_INT 1
43546: PUSH
43547: EMPTY
43548: LIST
43549: LIST
43550: PUSH
43551: LD_INT 0
43553: PUSH
43554: LD_INT 1
43556: PUSH
43557: EMPTY
43558: LIST
43559: LIST
43560: PUSH
43561: LD_INT 1
43563: NEG
43564: PUSH
43565: LD_INT 0
43567: PUSH
43568: EMPTY
43569: LIST
43570: LIST
43571: PUSH
43572: LD_INT 1
43574: NEG
43575: PUSH
43576: LD_INT 1
43578: NEG
43579: PUSH
43580: EMPTY
43581: LIST
43582: LIST
43583: PUSH
43584: LD_INT 1
43586: NEG
43587: PUSH
43588: LD_INT 2
43590: NEG
43591: PUSH
43592: EMPTY
43593: LIST
43594: LIST
43595: PUSH
43596: LD_INT 0
43598: PUSH
43599: LD_INT 2
43601: NEG
43602: PUSH
43603: EMPTY
43604: LIST
43605: LIST
43606: PUSH
43607: LD_INT 1
43609: PUSH
43610: LD_INT 1
43612: NEG
43613: PUSH
43614: EMPTY
43615: LIST
43616: LIST
43617: PUSH
43618: LD_INT 2
43620: PUSH
43621: LD_INT 0
43623: PUSH
43624: EMPTY
43625: LIST
43626: LIST
43627: PUSH
43628: LD_INT 2
43630: PUSH
43631: LD_INT 1
43633: PUSH
43634: EMPTY
43635: LIST
43636: LIST
43637: PUSH
43638: LD_INT 2
43640: PUSH
43641: LD_INT 2
43643: PUSH
43644: EMPTY
43645: LIST
43646: LIST
43647: PUSH
43648: LD_INT 1
43650: PUSH
43651: LD_INT 2
43653: PUSH
43654: EMPTY
43655: LIST
43656: LIST
43657: PUSH
43658: LD_INT 0
43660: PUSH
43661: LD_INT 2
43663: PUSH
43664: EMPTY
43665: LIST
43666: LIST
43667: PUSH
43668: LD_INT 1
43670: NEG
43671: PUSH
43672: LD_INT 1
43674: PUSH
43675: EMPTY
43676: LIST
43677: LIST
43678: PUSH
43679: LD_INT 2
43681: NEG
43682: PUSH
43683: LD_INT 0
43685: PUSH
43686: EMPTY
43687: LIST
43688: LIST
43689: PUSH
43690: LD_INT 2
43692: NEG
43693: PUSH
43694: LD_INT 1
43696: NEG
43697: PUSH
43698: EMPTY
43699: LIST
43700: LIST
43701: PUSH
43702: LD_INT 2
43704: NEG
43705: PUSH
43706: LD_INT 2
43708: NEG
43709: PUSH
43710: EMPTY
43711: LIST
43712: LIST
43713: PUSH
43714: EMPTY
43715: LIST
43716: LIST
43717: LIST
43718: LIST
43719: LIST
43720: LIST
43721: LIST
43722: LIST
43723: LIST
43724: LIST
43725: LIST
43726: LIST
43727: LIST
43728: LIST
43729: LIST
43730: LIST
43731: LIST
43732: LIST
43733: LIST
43734: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
43735: LD_ADDR_VAR 0 56
43739: PUSH
43740: LD_INT 0
43742: PUSH
43743: LD_INT 0
43745: PUSH
43746: EMPTY
43747: LIST
43748: LIST
43749: PUSH
43750: LD_INT 0
43752: PUSH
43753: LD_INT 1
43755: NEG
43756: PUSH
43757: EMPTY
43758: LIST
43759: LIST
43760: PUSH
43761: LD_INT 1
43763: PUSH
43764: LD_INT 0
43766: PUSH
43767: EMPTY
43768: LIST
43769: LIST
43770: PUSH
43771: LD_INT 1
43773: PUSH
43774: LD_INT 1
43776: PUSH
43777: EMPTY
43778: LIST
43779: LIST
43780: PUSH
43781: LD_INT 0
43783: PUSH
43784: LD_INT 1
43786: PUSH
43787: EMPTY
43788: LIST
43789: LIST
43790: PUSH
43791: LD_INT 1
43793: NEG
43794: PUSH
43795: LD_INT 0
43797: PUSH
43798: EMPTY
43799: LIST
43800: LIST
43801: PUSH
43802: LD_INT 1
43804: NEG
43805: PUSH
43806: LD_INT 1
43808: NEG
43809: PUSH
43810: EMPTY
43811: LIST
43812: LIST
43813: PUSH
43814: LD_INT 1
43816: NEG
43817: PUSH
43818: LD_INT 2
43820: NEG
43821: PUSH
43822: EMPTY
43823: LIST
43824: LIST
43825: PUSH
43826: LD_INT 0
43828: PUSH
43829: LD_INT 2
43831: NEG
43832: PUSH
43833: EMPTY
43834: LIST
43835: LIST
43836: PUSH
43837: LD_INT 1
43839: PUSH
43840: LD_INT 1
43842: NEG
43843: PUSH
43844: EMPTY
43845: LIST
43846: LIST
43847: PUSH
43848: LD_INT 2
43850: PUSH
43851: LD_INT 0
43853: PUSH
43854: EMPTY
43855: LIST
43856: LIST
43857: PUSH
43858: LD_INT 2
43860: PUSH
43861: LD_INT 1
43863: PUSH
43864: EMPTY
43865: LIST
43866: LIST
43867: PUSH
43868: LD_INT 2
43870: PUSH
43871: LD_INT 2
43873: PUSH
43874: EMPTY
43875: LIST
43876: LIST
43877: PUSH
43878: LD_INT 1
43880: PUSH
43881: LD_INT 2
43883: PUSH
43884: EMPTY
43885: LIST
43886: LIST
43887: PUSH
43888: LD_INT 0
43890: PUSH
43891: LD_INT 2
43893: PUSH
43894: EMPTY
43895: LIST
43896: LIST
43897: PUSH
43898: LD_INT 1
43900: NEG
43901: PUSH
43902: LD_INT 1
43904: PUSH
43905: EMPTY
43906: LIST
43907: LIST
43908: PUSH
43909: LD_INT 2
43911: NEG
43912: PUSH
43913: LD_INT 0
43915: PUSH
43916: EMPTY
43917: LIST
43918: LIST
43919: PUSH
43920: LD_INT 2
43922: NEG
43923: PUSH
43924: LD_INT 1
43926: NEG
43927: PUSH
43928: EMPTY
43929: LIST
43930: LIST
43931: PUSH
43932: LD_INT 2
43934: NEG
43935: PUSH
43936: LD_INT 2
43938: NEG
43939: PUSH
43940: EMPTY
43941: LIST
43942: LIST
43943: PUSH
43944: EMPTY
43945: LIST
43946: LIST
43947: LIST
43948: LIST
43949: LIST
43950: LIST
43951: LIST
43952: LIST
43953: LIST
43954: LIST
43955: LIST
43956: LIST
43957: LIST
43958: LIST
43959: LIST
43960: LIST
43961: LIST
43962: LIST
43963: LIST
43964: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
43965: LD_ADDR_VAR 0 57
43969: PUSH
43970: LD_INT 0
43972: PUSH
43973: LD_INT 0
43975: PUSH
43976: EMPTY
43977: LIST
43978: LIST
43979: PUSH
43980: LD_INT 0
43982: PUSH
43983: LD_INT 1
43985: NEG
43986: PUSH
43987: EMPTY
43988: LIST
43989: LIST
43990: PUSH
43991: LD_INT 1
43993: PUSH
43994: LD_INT 0
43996: PUSH
43997: EMPTY
43998: LIST
43999: LIST
44000: PUSH
44001: LD_INT 1
44003: PUSH
44004: LD_INT 1
44006: PUSH
44007: EMPTY
44008: LIST
44009: LIST
44010: PUSH
44011: LD_INT 0
44013: PUSH
44014: LD_INT 1
44016: PUSH
44017: EMPTY
44018: LIST
44019: LIST
44020: PUSH
44021: LD_INT 1
44023: NEG
44024: PUSH
44025: LD_INT 0
44027: PUSH
44028: EMPTY
44029: LIST
44030: LIST
44031: PUSH
44032: LD_INT 1
44034: NEG
44035: PUSH
44036: LD_INT 1
44038: NEG
44039: PUSH
44040: EMPTY
44041: LIST
44042: LIST
44043: PUSH
44044: LD_INT 1
44046: NEG
44047: PUSH
44048: LD_INT 2
44050: NEG
44051: PUSH
44052: EMPTY
44053: LIST
44054: LIST
44055: PUSH
44056: LD_INT 0
44058: PUSH
44059: LD_INT 2
44061: NEG
44062: PUSH
44063: EMPTY
44064: LIST
44065: LIST
44066: PUSH
44067: LD_INT 1
44069: PUSH
44070: LD_INT 1
44072: NEG
44073: PUSH
44074: EMPTY
44075: LIST
44076: LIST
44077: PUSH
44078: LD_INT 2
44080: PUSH
44081: LD_INT 0
44083: PUSH
44084: EMPTY
44085: LIST
44086: LIST
44087: PUSH
44088: LD_INT 2
44090: PUSH
44091: LD_INT 1
44093: PUSH
44094: EMPTY
44095: LIST
44096: LIST
44097: PUSH
44098: LD_INT 2
44100: PUSH
44101: LD_INT 2
44103: PUSH
44104: EMPTY
44105: LIST
44106: LIST
44107: PUSH
44108: LD_INT 1
44110: PUSH
44111: LD_INT 2
44113: PUSH
44114: EMPTY
44115: LIST
44116: LIST
44117: PUSH
44118: LD_INT 0
44120: PUSH
44121: LD_INT 2
44123: PUSH
44124: EMPTY
44125: LIST
44126: LIST
44127: PUSH
44128: LD_INT 1
44130: NEG
44131: PUSH
44132: LD_INT 1
44134: PUSH
44135: EMPTY
44136: LIST
44137: LIST
44138: PUSH
44139: LD_INT 2
44141: NEG
44142: PUSH
44143: LD_INT 0
44145: PUSH
44146: EMPTY
44147: LIST
44148: LIST
44149: PUSH
44150: LD_INT 2
44152: NEG
44153: PUSH
44154: LD_INT 1
44156: NEG
44157: PUSH
44158: EMPTY
44159: LIST
44160: LIST
44161: PUSH
44162: LD_INT 2
44164: NEG
44165: PUSH
44166: LD_INT 2
44168: NEG
44169: PUSH
44170: EMPTY
44171: LIST
44172: LIST
44173: PUSH
44174: EMPTY
44175: LIST
44176: LIST
44177: LIST
44178: LIST
44179: LIST
44180: LIST
44181: LIST
44182: LIST
44183: LIST
44184: LIST
44185: LIST
44186: LIST
44187: LIST
44188: LIST
44189: LIST
44190: LIST
44191: LIST
44192: LIST
44193: LIST
44194: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
44195: LD_ADDR_VAR 0 58
44199: PUSH
44200: LD_INT 0
44202: PUSH
44203: LD_INT 0
44205: PUSH
44206: EMPTY
44207: LIST
44208: LIST
44209: PUSH
44210: LD_INT 0
44212: PUSH
44213: LD_INT 1
44215: NEG
44216: PUSH
44217: EMPTY
44218: LIST
44219: LIST
44220: PUSH
44221: LD_INT 1
44223: PUSH
44224: LD_INT 0
44226: PUSH
44227: EMPTY
44228: LIST
44229: LIST
44230: PUSH
44231: LD_INT 1
44233: PUSH
44234: LD_INT 1
44236: PUSH
44237: EMPTY
44238: LIST
44239: LIST
44240: PUSH
44241: LD_INT 0
44243: PUSH
44244: LD_INT 1
44246: PUSH
44247: EMPTY
44248: LIST
44249: LIST
44250: PUSH
44251: LD_INT 1
44253: NEG
44254: PUSH
44255: LD_INT 0
44257: PUSH
44258: EMPTY
44259: LIST
44260: LIST
44261: PUSH
44262: LD_INT 1
44264: NEG
44265: PUSH
44266: LD_INT 1
44268: NEG
44269: PUSH
44270: EMPTY
44271: LIST
44272: LIST
44273: PUSH
44274: LD_INT 1
44276: NEG
44277: PUSH
44278: LD_INT 2
44280: NEG
44281: PUSH
44282: EMPTY
44283: LIST
44284: LIST
44285: PUSH
44286: LD_INT 0
44288: PUSH
44289: LD_INT 2
44291: NEG
44292: PUSH
44293: EMPTY
44294: LIST
44295: LIST
44296: PUSH
44297: LD_INT 1
44299: PUSH
44300: LD_INT 1
44302: NEG
44303: PUSH
44304: EMPTY
44305: LIST
44306: LIST
44307: PUSH
44308: LD_INT 2
44310: PUSH
44311: LD_INT 0
44313: PUSH
44314: EMPTY
44315: LIST
44316: LIST
44317: PUSH
44318: LD_INT 2
44320: PUSH
44321: LD_INT 1
44323: PUSH
44324: EMPTY
44325: LIST
44326: LIST
44327: PUSH
44328: LD_INT 2
44330: PUSH
44331: LD_INT 2
44333: PUSH
44334: EMPTY
44335: LIST
44336: LIST
44337: PUSH
44338: LD_INT 1
44340: PUSH
44341: LD_INT 2
44343: PUSH
44344: EMPTY
44345: LIST
44346: LIST
44347: PUSH
44348: LD_INT 0
44350: PUSH
44351: LD_INT 2
44353: PUSH
44354: EMPTY
44355: LIST
44356: LIST
44357: PUSH
44358: LD_INT 1
44360: NEG
44361: PUSH
44362: LD_INT 1
44364: PUSH
44365: EMPTY
44366: LIST
44367: LIST
44368: PUSH
44369: LD_INT 2
44371: NEG
44372: PUSH
44373: LD_INT 0
44375: PUSH
44376: EMPTY
44377: LIST
44378: LIST
44379: PUSH
44380: LD_INT 2
44382: NEG
44383: PUSH
44384: LD_INT 1
44386: NEG
44387: PUSH
44388: EMPTY
44389: LIST
44390: LIST
44391: PUSH
44392: LD_INT 2
44394: NEG
44395: PUSH
44396: LD_INT 2
44398: NEG
44399: PUSH
44400: EMPTY
44401: LIST
44402: LIST
44403: PUSH
44404: EMPTY
44405: LIST
44406: LIST
44407: LIST
44408: LIST
44409: LIST
44410: LIST
44411: LIST
44412: LIST
44413: LIST
44414: LIST
44415: LIST
44416: LIST
44417: LIST
44418: LIST
44419: LIST
44420: LIST
44421: LIST
44422: LIST
44423: LIST
44424: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
44425: LD_ADDR_VAR 0 59
44429: PUSH
44430: LD_INT 0
44432: PUSH
44433: LD_INT 0
44435: PUSH
44436: EMPTY
44437: LIST
44438: LIST
44439: PUSH
44440: LD_INT 0
44442: PUSH
44443: LD_INT 1
44445: NEG
44446: PUSH
44447: EMPTY
44448: LIST
44449: LIST
44450: PUSH
44451: LD_INT 1
44453: PUSH
44454: LD_INT 0
44456: PUSH
44457: EMPTY
44458: LIST
44459: LIST
44460: PUSH
44461: LD_INT 1
44463: PUSH
44464: LD_INT 1
44466: PUSH
44467: EMPTY
44468: LIST
44469: LIST
44470: PUSH
44471: LD_INT 0
44473: PUSH
44474: LD_INT 1
44476: PUSH
44477: EMPTY
44478: LIST
44479: LIST
44480: PUSH
44481: LD_INT 1
44483: NEG
44484: PUSH
44485: LD_INT 0
44487: PUSH
44488: EMPTY
44489: LIST
44490: LIST
44491: PUSH
44492: LD_INT 1
44494: NEG
44495: PUSH
44496: LD_INT 1
44498: NEG
44499: PUSH
44500: EMPTY
44501: LIST
44502: LIST
44503: PUSH
44504: EMPTY
44505: LIST
44506: LIST
44507: LIST
44508: LIST
44509: LIST
44510: LIST
44511: LIST
44512: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
44513: LD_ADDR_VAR 0 60
44517: PUSH
44518: LD_INT 0
44520: PUSH
44521: LD_INT 0
44523: PUSH
44524: EMPTY
44525: LIST
44526: LIST
44527: PUSH
44528: LD_INT 0
44530: PUSH
44531: LD_INT 1
44533: NEG
44534: PUSH
44535: EMPTY
44536: LIST
44537: LIST
44538: PUSH
44539: LD_INT 1
44541: PUSH
44542: LD_INT 0
44544: PUSH
44545: EMPTY
44546: LIST
44547: LIST
44548: PUSH
44549: LD_INT 1
44551: PUSH
44552: LD_INT 1
44554: PUSH
44555: EMPTY
44556: LIST
44557: LIST
44558: PUSH
44559: LD_INT 0
44561: PUSH
44562: LD_INT 1
44564: PUSH
44565: EMPTY
44566: LIST
44567: LIST
44568: PUSH
44569: LD_INT 1
44571: NEG
44572: PUSH
44573: LD_INT 0
44575: PUSH
44576: EMPTY
44577: LIST
44578: LIST
44579: PUSH
44580: LD_INT 1
44582: NEG
44583: PUSH
44584: LD_INT 1
44586: NEG
44587: PUSH
44588: EMPTY
44589: LIST
44590: LIST
44591: PUSH
44592: EMPTY
44593: LIST
44594: LIST
44595: LIST
44596: LIST
44597: LIST
44598: LIST
44599: LIST
44600: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
44601: LD_ADDR_VAR 0 61
44605: PUSH
44606: LD_INT 0
44608: PUSH
44609: LD_INT 0
44611: PUSH
44612: EMPTY
44613: LIST
44614: LIST
44615: PUSH
44616: LD_INT 0
44618: PUSH
44619: LD_INT 1
44621: NEG
44622: PUSH
44623: EMPTY
44624: LIST
44625: LIST
44626: PUSH
44627: LD_INT 1
44629: PUSH
44630: LD_INT 0
44632: PUSH
44633: EMPTY
44634: LIST
44635: LIST
44636: PUSH
44637: LD_INT 1
44639: PUSH
44640: LD_INT 1
44642: PUSH
44643: EMPTY
44644: LIST
44645: LIST
44646: PUSH
44647: LD_INT 0
44649: PUSH
44650: LD_INT 1
44652: PUSH
44653: EMPTY
44654: LIST
44655: LIST
44656: PUSH
44657: LD_INT 1
44659: NEG
44660: PUSH
44661: LD_INT 0
44663: PUSH
44664: EMPTY
44665: LIST
44666: LIST
44667: PUSH
44668: LD_INT 1
44670: NEG
44671: PUSH
44672: LD_INT 1
44674: NEG
44675: PUSH
44676: EMPTY
44677: LIST
44678: LIST
44679: PUSH
44680: EMPTY
44681: LIST
44682: LIST
44683: LIST
44684: LIST
44685: LIST
44686: LIST
44687: LIST
44688: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
44689: LD_ADDR_VAR 0 62
44693: PUSH
44694: LD_INT 0
44696: PUSH
44697: LD_INT 0
44699: PUSH
44700: EMPTY
44701: LIST
44702: LIST
44703: PUSH
44704: LD_INT 0
44706: PUSH
44707: LD_INT 1
44709: NEG
44710: PUSH
44711: EMPTY
44712: LIST
44713: LIST
44714: PUSH
44715: LD_INT 1
44717: PUSH
44718: LD_INT 0
44720: PUSH
44721: EMPTY
44722: LIST
44723: LIST
44724: PUSH
44725: LD_INT 1
44727: PUSH
44728: LD_INT 1
44730: PUSH
44731: EMPTY
44732: LIST
44733: LIST
44734: PUSH
44735: LD_INT 0
44737: PUSH
44738: LD_INT 1
44740: PUSH
44741: EMPTY
44742: LIST
44743: LIST
44744: PUSH
44745: LD_INT 1
44747: NEG
44748: PUSH
44749: LD_INT 0
44751: PUSH
44752: EMPTY
44753: LIST
44754: LIST
44755: PUSH
44756: LD_INT 1
44758: NEG
44759: PUSH
44760: LD_INT 1
44762: NEG
44763: PUSH
44764: EMPTY
44765: LIST
44766: LIST
44767: PUSH
44768: EMPTY
44769: LIST
44770: LIST
44771: LIST
44772: LIST
44773: LIST
44774: LIST
44775: LIST
44776: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
44777: LD_ADDR_VAR 0 63
44781: PUSH
44782: LD_INT 0
44784: PUSH
44785: LD_INT 0
44787: PUSH
44788: EMPTY
44789: LIST
44790: LIST
44791: PUSH
44792: LD_INT 0
44794: PUSH
44795: LD_INT 1
44797: NEG
44798: PUSH
44799: EMPTY
44800: LIST
44801: LIST
44802: PUSH
44803: LD_INT 1
44805: PUSH
44806: LD_INT 0
44808: PUSH
44809: EMPTY
44810: LIST
44811: LIST
44812: PUSH
44813: LD_INT 1
44815: PUSH
44816: LD_INT 1
44818: PUSH
44819: EMPTY
44820: LIST
44821: LIST
44822: PUSH
44823: LD_INT 0
44825: PUSH
44826: LD_INT 1
44828: PUSH
44829: EMPTY
44830: LIST
44831: LIST
44832: PUSH
44833: LD_INT 1
44835: NEG
44836: PUSH
44837: LD_INT 0
44839: PUSH
44840: EMPTY
44841: LIST
44842: LIST
44843: PUSH
44844: LD_INT 1
44846: NEG
44847: PUSH
44848: LD_INT 1
44850: NEG
44851: PUSH
44852: EMPTY
44853: LIST
44854: LIST
44855: PUSH
44856: EMPTY
44857: LIST
44858: LIST
44859: LIST
44860: LIST
44861: LIST
44862: LIST
44863: LIST
44864: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
44865: LD_ADDR_VAR 0 64
44869: PUSH
44870: LD_INT 0
44872: PUSH
44873: LD_INT 0
44875: PUSH
44876: EMPTY
44877: LIST
44878: LIST
44879: PUSH
44880: LD_INT 0
44882: PUSH
44883: LD_INT 1
44885: NEG
44886: PUSH
44887: EMPTY
44888: LIST
44889: LIST
44890: PUSH
44891: LD_INT 1
44893: PUSH
44894: LD_INT 0
44896: PUSH
44897: EMPTY
44898: LIST
44899: LIST
44900: PUSH
44901: LD_INT 1
44903: PUSH
44904: LD_INT 1
44906: PUSH
44907: EMPTY
44908: LIST
44909: LIST
44910: PUSH
44911: LD_INT 0
44913: PUSH
44914: LD_INT 1
44916: PUSH
44917: EMPTY
44918: LIST
44919: LIST
44920: PUSH
44921: LD_INT 1
44923: NEG
44924: PUSH
44925: LD_INT 0
44927: PUSH
44928: EMPTY
44929: LIST
44930: LIST
44931: PUSH
44932: LD_INT 1
44934: NEG
44935: PUSH
44936: LD_INT 1
44938: NEG
44939: PUSH
44940: EMPTY
44941: LIST
44942: LIST
44943: PUSH
44944: EMPTY
44945: LIST
44946: LIST
44947: LIST
44948: LIST
44949: LIST
44950: LIST
44951: LIST
44952: ST_TO_ADDR
// end ; 1 :
44953: GO 50850
44955: LD_INT 1
44957: DOUBLE
44958: EQUAL
44959: IFTRUE 44963
44961: GO 47586
44963: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
44964: LD_ADDR_VAR 0 11
44968: PUSH
44969: LD_INT 1
44971: NEG
44972: PUSH
44973: LD_INT 3
44975: NEG
44976: PUSH
44977: EMPTY
44978: LIST
44979: LIST
44980: PUSH
44981: LD_INT 0
44983: PUSH
44984: LD_INT 3
44986: NEG
44987: PUSH
44988: EMPTY
44989: LIST
44990: LIST
44991: PUSH
44992: LD_INT 1
44994: PUSH
44995: LD_INT 2
44997: NEG
44998: PUSH
44999: EMPTY
45000: LIST
45001: LIST
45002: PUSH
45003: EMPTY
45004: LIST
45005: LIST
45006: LIST
45007: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
45008: LD_ADDR_VAR 0 12
45012: PUSH
45013: LD_INT 2
45015: PUSH
45016: LD_INT 1
45018: NEG
45019: PUSH
45020: EMPTY
45021: LIST
45022: LIST
45023: PUSH
45024: LD_INT 3
45026: PUSH
45027: LD_INT 0
45029: PUSH
45030: EMPTY
45031: LIST
45032: LIST
45033: PUSH
45034: LD_INT 3
45036: PUSH
45037: LD_INT 1
45039: PUSH
45040: EMPTY
45041: LIST
45042: LIST
45043: PUSH
45044: EMPTY
45045: LIST
45046: LIST
45047: LIST
45048: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
45049: LD_ADDR_VAR 0 13
45053: PUSH
45054: LD_INT 3
45056: PUSH
45057: LD_INT 2
45059: PUSH
45060: EMPTY
45061: LIST
45062: LIST
45063: PUSH
45064: LD_INT 3
45066: PUSH
45067: LD_INT 3
45069: PUSH
45070: EMPTY
45071: LIST
45072: LIST
45073: PUSH
45074: LD_INT 2
45076: PUSH
45077: LD_INT 3
45079: PUSH
45080: EMPTY
45081: LIST
45082: LIST
45083: PUSH
45084: EMPTY
45085: LIST
45086: LIST
45087: LIST
45088: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
45089: LD_ADDR_VAR 0 14
45093: PUSH
45094: LD_INT 1
45096: PUSH
45097: LD_INT 3
45099: PUSH
45100: EMPTY
45101: LIST
45102: LIST
45103: PUSH
45104: LD_INT 0
45106: PUSH
45107: LD_INT 3
45109: PUSH
45110: EMPTY
45111: LIST
45112: LIST
45113: PUSH
45114: LD_INT 1
45116: NEG
45117: PUSH
45118: LD_INT 2
45120: PUSH
45121: EMPTY
45122: LIST
45123: LIST
45124: PUSH
45125: EMPTY
45126: LIST
45127: LIST
45128: LIST
45129: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
45130: LD_ADDR_VAR 0 15
45134: PUSH
45135: LD_INT 2
45137: NEG
45138: PUSH
45139: LD_INT 1
45141: PUSH
45142: EMPTY
45143: LIST
45144: LIST
45145: PUSH
45146: LD_INT 3
45148: NEG
45149: PUSH
45150: LD_INT 0
45152: PUSH
45153: EMPTY
45154: LIST
45155: LIST
45156: PUSH
45157: LD_INT 3
45159: NEG
45160: PUSH
45161: LD_INT 1
45163: NEG
45164: PUSH
45165: EMPTY
45166: LIST
45167: LIST
45168: PUSH
45169: EMPTY
45170: LIST
45171: LIST
45172: LIST
45173: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
45174: LD_ADDR_VAR 0 16
45178: PUSH
45179: LD_INT 2
45181: NEG
45182: PUSH
45183: LD_INT 3
45185: NEG
45186: PUSH
45187: EMPTY
45188: LIST
45189: LIST
45190: PUSH
45191: LD_INT 3
45193: NEG
45194: PUSH
45195: LD_INT 2
45197: NEG
45198: PUSH
45199: EMPTY
45200: LIST
45201: LIST
45202: PUSH
45203: LD_INT 3
45205: NEG
45206: PUSH
45207: LD_INT 3
45209: NEG
45210: PUSH
45211: EMPTY
45212: LIST
45213: LIST
45214: PUSH
45215: EMPTY
45216: LIST
45217: LIST
45218: LIST
45219: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
45220: LD_ADDR_VAR 0 17
45224: PUSH
45225: LD_INT 1
45227: NEG
45228: PUSH
45229: LD_INT 3
45231: NEG
45232: PUSH
45233: EMPTY
45234: LIST
45235: LIST
45236: PUSH
45237: LD_INT 0
45239: PUSH
45240: LD_INT 3
45242: NEG
45243: PUSH
45244: EMPTY
45245: LIST
45246: LIST
45247: PUSH
45248: LD_INT 1
45250: PUSH
45251: LD_INT 2
45253: NEG
45254: PUSH
45255: EMPTY
45256: LIST
45257: LIST
45258: PUSH
45259: EMPTY
45260: LIST
45261: LIST
45262: LIST
45263: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
45264: LD_ADDR_VAR 0 18
45268: PUSH
45269: LD_INT 2
45271: PUSH
45272: LD_INT 1
45274: NEG
45275: PUSH
45276: EMPTY
45277: LIST
45278: LIST
45279: PUSH
45280: LD_INT 3
45282: PUSH
45283: LD_INT 0
45285: PUSH
45286: EMPTY
45287: LIST
45288: LIST
45289: PUSH
45290: LD_INT 3
45292: PUSH
45293: LD_INT 1
45295: PUSH
45296: EMPTY
45297: LIST
45298: LIST
45299: PUSH
45300: EMPTY
45301: LIST
45302: LIST
45303: LIST
45304: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
45305: LD_ADDR_VAR 0 19
45309: PUSH
45310: LD_INT 3
45312: PUSH
45313: LD_INT 2
45315: PUSH
45316: EMPTY
45317: LIST
45318: LIST
45319: PUSH
45320: LD_INT 3
45322: PUSH
45323: LD_INT 3
45325: PUSH
45326: EMPTY
45327: LIST
45328: LIST
45329: PUSH
45330: LD_INT 2
45332: PUSH
45333: LD_INT 3
45335: PUSH
45336: EMPTY
45337: LIST
45338: LIST
45339: PUSH
45340: EMPTY
45341: LIST
45342: LIST
45343: LIST
45344: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
45345: LD_ADDR_VAR 0 20
45349: PUSH
45350: LD_INT 1
45352: PUSH
45353: LD_INT 3
45355: PUSH
45356: EMPTY
45357: LIST
45358: LIST
45359: PUSH
45360: LD_INT 0
45362: PUSH
45363: LD_INT 3
45365: PUSH
45366: EMPTY
45367: LIST
45368: LIST
45369: PUSH
45370: LD_INT 1
45372: NEG
45373: PUSH
45374: LD_INT 2
45376: PUSH
45377: EMPTY
45378: LIST
45379: LIST
45380: PUSH
45381: EMPTY
45382: LIST
45383: LIST
45384: LIST
45385: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
45386: LD_ADDR_VAR 0 21
45390: PUSH
45391: LD_INT 2
45393: NEG
45394: PUSH
45395: LD_INT 1
45397: PUSH
45398: EMPTY
45399: LIST
45400: LIST
45401: PUSH
45402: LD_INT 3
45404: NEG
45405: PUSH
45406: LD_INT 0
45408: PUSH
45409: EMPTY
45410: LIST
45411: LIST
45412: PUSH
45413: LD_INT 3
45415: NEG
45416: PUSH
45417: LD_INT 1
45419: NEG
45420: PUSH
45421: EMPTY
45422: LIST
45423: LIST
45424: PUSH
45425: EMPTY
45426: LIST
45427: LIST
45428: LIST
45429: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
45430: LD_ADDR_VAR 0 22
45434: PUSH
45435: LD_INT 2
45437: NEG
45438: PUSH
45439: LD_INT 3
45441: NEG
45442: PUSH
45443: EMPTY
45444: LIST
45445: LIST
45446: PUSH
45447: LD_INT 3
45449: NEG
45450: PUSH
45451: LD_INT 2
45453: NEG
45454: PUSH
45455: EMPTY
45456: LIST
45457: LIST
45458: PUSH
45459: LD_INT 3
45461: NEG
45462: PUSH
45463: LD_INT 3
45465: NEG
45466: PUSH
45467: EMPTY
45468: LIST
45469: LIST
45470: PUSH
45471: EMPTY
45472: LIST
45473: LIST
45474: LIST
45475: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
45476: LD_ADDR_VAR 0 23
45480: PUSH
45481: LD_INT 0
45483: PUSH
45484: LD_INT 3
45486: NEG
45487: PUSH
45488: EMPTY
45489: LIST
45490: LIST
45491: PUSH
45492: LD_INT 1
45494: NEG
45495: PUSH
45496: LD_INT 4
45498: NEG
45499: PUSH
45500: EMPTY
45501: LIST
45502: LIST
45503: PUSH
45504: LD_INT 1
45506: PUSH
45507: LD_INT 3
45509: NEG
45510: PUSH
45511: EMPTY
45512: LIST
45513: LIST
45514: PUSH
45515: EMPTY
45516: LIST
45517: LIST
45518: LIST
45519: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
45520: LD_ADDR_VAR 0 24
45524: PUSH
45525: LD_INT 3
45527: PUSH
45528: LD_INT 0
45530: PUSH
45531: EMPTY
45532: LIST
45533: LIST
45534: PUSH
45535: LD_INT 3
45537: PUSH
45538: LD_INT 1
45540: NEG
45541: PUSH
45542: EMPTY
45543: LIST
45544: LIST
45545: PUSH
45546: LD_INT 4
45548: PUSH
45549: LD_INT 1
45551: PUSH
45552: EMPTY
45553: LIST
45554: LIST
45555: PUSH
45556: EMPTY
45557: LIST
45558: LIST
45559: LIST
45560: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
45561: LD_ADDR_VAR 0 25
45565: PUSH
45566: LD_INT 3
45568: PUSH
45569: LD_INT 3
45571: PUSH
45572: EMPTY
45573: LIST
45574: LIST
45575: PUSH
45576: LD_INT 4
45578: PUSH
45579: LD_INT 3
45581: PUSH
45582: EMPTY
45583: LIST
45584: LIST
45585: PUSH
45586: LD_INT 3
45588: PUSH
45589: LD_INT 4
45591: PUSH
45592: EMPTY
45593: LIST
45594: LIST
45595: PUSH
45596: EMPTY
45597: LIST
45598: LIST
45599: LIST
45600: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
45601: LD_ADDR_VAR 0 26
45605: PUSH
45606: LD_INT 0
45608: PUSH
45609: LD_INT 3
45611: PUSH
45612: EMPTY
45613: LIST
45614: LIST
45615: PUSH
45616: LD_INT 1
45618: PUSH
45619: LD_INT 4
45621: PUSH
45622: EMPTY
45623: LIST
45624: LIST
45625: PUSH
45626: LD_INT 1
45628: NEG
45629: PUSH
45630: LD_INT 3
45632: PUSH
45633: EMPTY
45634: LIST
45635: LIST
45636: PUSH
45637: EMPTY
45638: LIST
45639: LIST
45640: LIST
45641: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
45642: LD_ADDR_VAR 0 27
45646: PUSH
45647: LD_INT 3
45649: NEG
45650: PUSH
45651: LD_INT 0
45653: PUSH
45654: EMPTY
45655: LIST
45656: LIST
45657: PUSH
45658: LD_INT 3
45660: NEG
45661: PUSH
45662: LD_INT 1
45664: PUSH
45665: EMPTY
45666: LIST
45667: LIST
45668: PUSH
45669: LD_INT 4
45671: NEG
45672: PUSH
45673: LD_INT 1
45675: NEG
45676: PUSH
45677: EMPTY
45678: LIST
45679: LIST
45680: PUSH
45681: EMPTY
45682: LIST
45683: LIST
45684: LIST
45685: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
45686: LD_ADDR_VAR 0 28
45690: PUSH
45691: LD_INT 3
45693: NEG
45694: PUSH
45695: LD_INT 3
45697: NEG
45698: PUSH
45699: EMPTY
45700: LIST
45701: LIST
45702: PUSH
45703: LD_INT 3
45705: NEG
45706: PUSH
45707: LD_INT 4
45709: NEG
45710: PUSH
45711: EMPTY
45712: LIST
45713: LIST
45714: PUSH
45715: LD_INT 4
45717: NEG
45718: PUSH
45719: LD_INT 3
45721: NEG
45722: PUSH
45723: EMPTY
45724: LIST
45725: LIST
45726: PUSH
45727: EMPTY
45728: LIST
45729: LIST
45730: LIST
45731: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
45732: LD_ADDR_VAR 0 29
45736: PUSH
45737: LD_INT 1
45739: NEG
45740: PUSH
45741: LD_INT 3
45743: NEG
45744: PUSH
45745: EMPTY
45746: LIST
45747: LIST
45748: PUSH
45749: LD_INT 0
45751: PUSH
45752: LD_INT 3
45754: NEG
45755: PUSH
45756: EMPTY
45757: LIST
45758: LIST
45759: PUSH
45760: LD_INT 1
45762: PUSH
45763: LD_INT 2
45765: NEG
45766: PUSH
45767: EMPTY
45768: LIST
45769: LIST
45770: PUSH
45771: LD_INT 1
45773: NEG
45774: PUSH
45775: LD_INT 4
45777: NEG
45778: PUSH
45779: EMPTY
45780: LIST
45781: LIST
45782: PUSH
45783: LD_INT 0
45785: PUSH
45786: LD_INT 4
45788: NEG
45789: PUSH
45790: EMPTY
45791: LIST
45792: LIST
45793: PUSH
45794: LD_INT 1
45796: PUSH
45797: LD_INT 3
45799: NEG
45800: PUSH
45801: EMPTY
45802: LIST
45803: LIST
45804: PUSH
45805: LD_INT 1
45807: NEG
45808: PUSH
45809: LD_INT 5
45811: NEG
45812: PUSH
45813: EMPTY
45814: LIST
45815: LIST
45816: PUSH
45817: LD_INT 0
45819: PUSH
45820: LD_INT 5
45822: NEG
45823: PUSH
45824: EMPTY
45825: LIST
45826: LIST
45827: PUSH
45828: LD_INT 1
45830: PUSH
45831: LD_INT 4
45833: NEG
45834: PUSH
45835: EMPTY
45836: LIST
45837: LIST
45838: PUSH
45839: LD_INT 1
45841: NEG
45842: PUSH
45843: LD_INT 6
45845: NEG
45846: PUSH
45847: EMPTY
45848: LIST
45849: LIST
45850: PUSH
45851: LD_INT 0
45853: PUSH
45854: LD_INT 6
45856: NEG
45857: PUSH
45858: EMPTY
45859: LIST
45860: LIST
45861: PUSH
45862: LD_INT 1
45864: PUSH
45865: LD_INT 5
45867: NEG
45868: PUSH
45869: EMPTY
45870: LIST
45871: LIST
45872: PUSH
45873: EMPTY
45874: LIST
45875: LIST
45876: LIST
45877: LIST
45878: LIST
45879: LIST
45880: LIST
45881: LIST
45882: LIST
45883: LIST
45884: LIST
45885: LIST
45886: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
45887: LD_ADDR_VAR 0 30
45891: PUSH
45892: LD_INT 2
45894: PUSH
45895: LD_INT 1
45897: NEG
45898: PUSH
45899: EMPTY
45900: LIST
45901: LIST
45902: PUSH
45903: LD_INT 3
45905: PUSH
45906: LD_INT 0
45908: PUSH
45909: EMPTY
45910: LIST
45911: LIST
45912: PUSH
45913: LD_INT 3
45915: PUSH
45916: LD_INT 1
45918: PUSH
45919: EMPTY
45920: LIST
45921: LIST
45922: PUSH
45923: LD_INT 3
45925: PUSH
45926: LD_INT 1
45928: NEG
45929: PUSH
45930: EMPTY
45931: LIST
45932: LIST
45933: PUSH
45934: LD_INT 4
45936: PUSH
45937: LD_INT 0
45939: PUSH
45940: EMPTY
45941: LIST
45942: LIST
45943: PUSH
45944: LD_INT 4
45946: PUSH
45947: LD_INT 1
45949: PUSH
45950: EMPTY
45951: LIST
45952: LIST
45953: PUSH
45954: LD_INT 4
45956: PUSH
45957: LD_INT 1
45959: NEG
45960: PUSH
45961: EMPTY
45962: LIST
45963: LIST
45964: PUSH
45965: LD_INT 5
45967: PUSH
45968: LD_INT 0
45970: PUSH
45971: EMPTY
45972: LIST
45973: LIST
45974: PUSH
45975: LD_INT 5
45977: PUSH
45978: LD_INT 1
45980: PUSH
45981: EMPTY
45982: LIST
45983: LIST
45984: PUSH
45985: LD_INT 5
45987: PUSH
45988: LD_INT 1
45990: NEG
45991: PUSH
45992: EMPTY
45993: LIST
45994: LIST
45995: PUSH
45996: LD_INT 6
45998: PUSH
45999: LD_INT 0
46001: PUSH
46002: EMPTY
46003: LIST
46004: LIST
46005: PUSH
46006: LD_INT 6
46008: PUSH
46009: LD_INT 1
46011: PUSH
46012: EMPTY
46013: LIST
46014: LIST
46015: PUSH
46016: EMPTY
46017: LIST
46018: LIST
46019: LIST
46020: LIST
46021: LIST
46022: LIST
46023: LIST
46024: LIST
46025: LIST
46026: LIST
46027: LIST
46028: LIST
46029: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
46030: LD_ADDR_VAR 0 31
46034: PUSH
46035: LD_INT 3
46037: PUSH
46038: LD_INT 2
46040: PUSH
46041: EMPTY
46042: LIST
46043: LIST
46044: PUSH
46045: LD_INT 3
46047: PUSH
46048: LD_INT 3
46050: PUSH
46051: EMPTY
46052: LIST
46053: LIST
46054: PUSH
46055: LD_INT 2
46057: PUSH
46058: LD_INT 3
46060: PUSH
46061: EMPTY
46062: LIST
46063: LIST
46064: PUSH
46065: LD_INT 4
46067: PUSH
46068: LD_INT 3
46070: PUSH
46071: EMPTY
46072: LIST
46073: LIST
46074: PUSH
46075: LD_INT 4
46077: PUSH
46078: LD_INT 4
46080: PUSH
46081: EMPTY
46082: LIST
46083: LIST
46084: PUSH
46085: LD_INT 3
46087: PUSH
46088: LD_INT 4
46090: PUSH
46091: EMPTY
46092: LIST
46093: LIST
46094: PUSH
46095: LD_INT 5
46097: PUSH
46098: LD_INT 4
46100: PUSH
46101: EMPTY
46102: LIST
46103: LIST
46104: PUSH
46105: LD_INT 5
46107: PUSH
46108: LD_INT 5
46110: PUSH
46111: EMPTY
46112: LIST
46113: LIST
46114: PUSH
46115: LD_INT 4
46117: PUSH
46118: LD_INT 5
46120: PUSH
46121: EMPTY
46122: LIST
46123: LIST
46124: PUSH
46125: LD_INT 6
46127: PUSH
46128: LD_INT 5
46130: PUSH
46131: EMPTY
46132: LIST
46133: LIST
46134: PUSH
46135: LD_INT 6
46137: PUSH
46138: LD_INT 6
46140: PUSH
46141: EMPTY
46142: LIST
46143: LIST
46144: PUSH
46145: LD_INT 5
46147: PUSH
46148: LD_INT 6
46150: PUSH
46151: EMPTY
46152: LIST
46153: LIST
46154: PUSH
46155: EMPTY
46156: LIST
46157: LIST
46158: LIST
46159: LIST
46160: LIST
46161: LIST
46162: LIST
46163: LIST
46164: LIST
46165: LIST
46166: LIST
46167: LIST
46168: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
46169: LD_ADDR_VAR 0 32
46173: PUSH
46174: LD_INT 1
46176: PUSH
46177: LD_INT 3
46179: PUSH
46180: EMPTY
46181: LIST
46182: LIST
46183: PUSH
46184: LD_INT 0
46186: PUSH
46187: LD_INT 3
46189: PUSH
46190: EMPTY
46191: LIST
46192: LIST
46193: PUSH
46194: LD_INT 1
46196: NEG
46197: PUSH
46198: LD_INT 2
46200: PUSH
46201: EMPTY
46202: LIST
46203: LIST
46204: PUSH
46205: LD_INT 1
46207: PUSH
46208: LD_INT 4
46210: PUSH
46211: EMPTY
46212: LIST
46213: LIST
46214: PUSH
46215: LD_INT 0
46217: PUSH
46218: LD_INT 4
46220: PUSH
46221: EMPTY
46222: LIST
46223: LIST
46224: PUSH
46225: LD_INT 1
46227: NEG
46228: PUSH
46229: LD_INT 3
46231: PUSH
46232: EMPTY
46233: LIST
46234: LIST
46235: PUSH
46236: LD_INT 1
46238: PUSH
46239: LD_INT 5
46241: PUSH
46242: EMPTY
46243: LIST
46244: LIST
46245: PUSH
46246: LD_INT 0
46248: PUSH
46249: LD_INT 5
46251: PUSH
46252: EMPTY
46253: LIST
46254: LIST
46255: PUSH
46256: LD_INT 1
46258: NEG
46259: PUSH
46260: LD_INT 4
46262: PUSH
46263: EMPTY
46264: LIST
46265: LIST
46266: PUSH
46267: LD_INT 1
46269: PUSH
46270: LD_INT 6
46272: PUSH
46273: EMPTY
46274: LIST
46275: LIST
46276: PUSH
46277: LD_INT 0
46279: PUSH
46280: LD_INT 6
46282: PUSH
46283: EMPTY
46284: LIST
46285: LIST
46286: PUSH
46287: LD_INT 1
46289: NEG
46290: PUSH
46291: LD_INT 5
46293: PUSH
46294: EMPTY
46295: LIST
46296: LIST
46297: PUSH
46298: EMPTY
46299: LIST
46300: LIST
46301: LIST
46302: LIST
46303: LIST
46304: LIST
46305: LIST
46306: LIST
46307: LIST
46308: LIST
46309: LIST
46310: LIST
46311: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
46312: LD_ADDR_VAR 0 33
46316: PUSH
46317: LD_INT 2
46319: NEG
46320: PUSH
46321: LD_INT 1
46323: PUSH
46324: EMPTY
46325: LIST
46326: LIST
46327: PUSH
46328: LD_INT 3
46330: NEG
46331: PUSH
46332: LD_INT 0
46334: PUSH
46335: EMPTY
46336: LIST
46337: LIST
46338: PUSH
46339: LD_INT 3
46341: NEG
46342: PUSH
46343: LD_INT 1
46345: NEG
46346: PUSH
46347: EMPTY
46348: LIST
46349: LIST
46350: PUSH
46351: LD_INT 3
46353: NEG
46354: PUSH
46355: LD_INT 1
46357: PUSH
46358: EMPTY
46359: LIST
46360: LIST
46361: PUSH
46362: LD_INT 4
46364: NEG
46365: PUSH
46366: LD_INT 0
46368: PUSH
46369: EMPTY
46370: LIST
46371: LIST
46372: PUSH
46373: LD_INT 4
46375: NEG
46376: PUSH
46377: LD_INT 1
46379: NEG
46380: PUSH
46381: EMPTY
46382: LIST
46383: LIST
46384: PUSH
46385: LD_INT 4
46387: NEG
46388: PUSH
46389: LD_INT 1
46391: PUSH
46392: EMPTY
46393: LIST
46394: LIST
46395: PUSH
46396: LD_INT 5
46398: NEG
46399: PUSH
46400: LD_INT 0
46402: PUSH
46403: EMPTY
46404: LIST
46405: LIST
46406: PUSH
46407: LD_INT 5
46409: NEG
46410: PUSH
46411: LD_INT 1
46413: NEG
46414: PUSH
46415: EMPTY
46416: LIST
46417: LIST
46418: PUSH
46419: LD_INT 5
46421: NEG
46422: PUSH
46423: LD_INT 1
46425: PUSH
46426: EMPTY
46427: LIST
46428: LIST
46429: PUSH
46430: LD_INT 6
46432: NEG
46433: PUSH
46434: LD_INT 0
46436: PUSH
46437: EMPTY
46438: LIST
46439: LIST
46440: PUSH
46441: LD_INT 6
46443: NEG
46444: PUSH
46445: LD_INT 1
46447: NEG
46448: PUSH
46449: EMPTY
46450: LIST
46451: LIST
46452: PUSH
46453: EMPTY
46454: LIST
46455: LIST
46456: LIST
46457: LIST
46458: LIST
46459: LIST
46460: LIST
46461: LIST
46462: LIST
46463: LIST
46464: LIST
46465: LIST
46466: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
46467: LD_ADDR_VAR 0 34
46471: PUSH
46472: LD_INT 2
46474: NEG
46475: PUSH
46476: LD_INT 3
46478: NEG
46479: PUSH
46480: EMPTY
46481: LIST
46482: LIST
46483: PUSH
46484: LD_INT 3
46486: NEG
46487: PUSH
46488: LD_INT 2
46490: NEG
46491: PUSH
46492: EMPTY
46493: LIST
46494: LIST
46495: PUSH
46496: LD_INT 3
46498: NEG
46499: PUSH
46500: LD_INT 3
46502: NEG
46503: PUSH
46504: EMPTY
46505: LIST
46506: LIST
46507: PUSH
46508: LD_INT 3
46510: NEG
46511: PUSH
46512: LD_INT 4
46514: NEG
46515: PUSH
46516: EMPTY
46517: LIST
46518: LIST
46519: PUSH
46520: LD_INT 4
46522: NEG
46523: PUSH
46524: LD_INT 3
46526: NEG
46527: PUSH
46528: EMPTY
46529: LIST
46530: LIST
46531: PUSH
46532: LD_INT 4
46534: NEG
46535: PUSH
46536: LD_INT 4
46538: NEG
46539: PUSH
46540: EMPTY
46541: LIST
46542: LIST
46543: PUSH
46544: LD_INT 4
46546: NEG
46547: PUSH
46548: LD_INT 5
46550: NEG
46551: PUSH
46552: EMPTY
46553: LIST
46554: LIST
46555: PUSH
46556: LD_INT 5
46558: NEG
46559: PUSH
46560: LD_INT 4
46562: NEG
46563: PUSH
46564: EMPTY
46565: LIST
46566: LIST
46567: PUSH
46568: LD_INT 5
46570: NEG
46571: PUSH
46572: LD_INT 5
46574: NEG
46575: PUSH
46576: EMPTY
46577: LIST
46578: LIST
46579: PUSH
46580: LD_INT 5
46582: NEG
46583: PUSH
46584: LD_INT 6
46586: NEG
46587: PUSH
46588: EMPTY
46589: LIST
46590: LIST
46591: PUSH
46592: LD_INT 6
46594: NEG
46595: PUSH
46596: LD_INT 5
46598: NEG
46599: PUSH
46600: EMPTY
46601: LIST
46602: LIST
46603: PUSH
46604: LD_INT 6
46606: NEG
46607: PUSH
46608: LD_INT 6
46610: NEG
46611: PUSH
46612: EMPTY
46613: LIST
46614: LIST
46615: PUSH
46616: EMPTY
46617: LIST
46618: LIST
46619: LIST
46620: LIST
46621: LIST
46622: LIST
46623: LIST
46624: LIST
46625: LIST
46626: LIST
46627: LIST
46628: LIST
46629: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
46630: LD_ADDR_VAR 0 41
46634: PUSH
46635: LD_INT 0
46637: PUSH
46638: LD_INT 2
46640: NEG
46641: PUSH
46642: EMPTY
46643: LIST
46644: LIST
46645: PUSH
46646: LD_INT 1
46648: NEG
46649: PUSH
46650: LD_INT 3
46652: NEG
46653: PUSH
46654: EMPTY
46655: LIST
46656: LIST
46657: PUSH
46658: LD_INT 1
46660: PUSH
46661: LD_INT 2
46663: NEG
46664: PUSH
46665: EMPTY
46666: LIST
46667: LIST
46668: PUSH
46669: EMPTY
46670: LIST
46671: LIST
46672: LIST
46673: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
46674: LD_ADDR_VAR 0 42
46678: PUSH
46679: LD_INT 2
46681: PUSH
46682: LD_INT 0
46684: PUSH
46685: EMPTY
46686: LIST
46687: LIST
46688: PUSH
46689: LD_INT 2
46691: PUSH
46692: LD_INT 1
46694: NEG
46695: PUSH
46696: EMPTY
46697: LIST
46698: LIST
46699: PUSH
46700: LD_INT 3
46702: PUSH
46703: LD_INT 1
46705: PUSH
46706: EMPTY
46707: LIST
46708: LIST
46709: PUSH
46710: EMPTY
46711: LIST
46712: LIST
46713: LIST
46714: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
46715: LD_ADDR_VAR 0 43
46719: PUSH
46720: LD_INT 2
46722: PUSH
46723: LD_INT 2
46725: PUSH
46726: EMPTY
46727: LIST
46728: LIST
46729: PUSH
46730: LD_INT 3
46732: PUSH
46733: LD_INT 2
46735: PUSH
46736: EMPTY
46737: LIST
46738: LIST
46739: PUSH
46740: LD_INT 2
46742: PUSH
46743: LD_INT 3
46745: PUSH
46746: EMPTY
46747: LIST
46748: LIST
46749: PUSH
46750: EMPTY
46751: LIST
46752: LIST
46753: LIST
46754: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
46755: LD_ADDR_VAR 0 44
46759: PUSH
46760: LD_INT 0
46762: PUSH
46763: LD_INT 2
46765: PUSH
46766: EMPTY
46767: LIST
46768: LIST
46769: PUSH
46770: LD_INT 1
46772: PUSH
46773: LD_INT 3
46775: PUSH
46776: EMPTY
46777: LIST
46778: LIST
46779: PUSH
46780: LD_INT 1
46782: NEG
46783: PUSH
46784: LD_INT 2
46786: PUSH
46787: EMPTY
46788: LIST
46789: LIST
46790: PUSH
46791: EMPTY
46792: LIST
46793: LIST
46794: LIST
46795: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
46796: LD_ADDR_VAR 0 45
46800: PUSH
46801: LD_INT 2
46803: NEG
46804: PUSH
46805: LD_INT 0
46807: PUSH
46808: EMPTY
46809: LIST
46810: LIST
46811: PUSH
46812: LD_INT 2
46814: NEG
46815: PUSH
46816: LD_INT 1
46818: PUSH
46819: EMPTY
46820: LIST
46821: LIST
46822: PUSH
46823: LD_INT 3
46825: NEG
46826: PUSH
46827: LD_INT 1
46829: NEG
46830: PUSH
46831: EMPTY
46832: LIST
46833: LIST
46834: PUSH
46835: EMPTY
46836: LIST
46837: LIST
46838: LIST
46839: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
46840: LD_ADDR_VAR 0 46
46844: PUSH
46845: LD_INT 2
46847: NEG
46848: PUSH
46849: LD_INT 2
46851: NEG
46852: PUSH
46853: EMPTY
46854: LIST
46855: LIST
46856: PUSH
46857: LD_INT 2
46859: NEG
46860: PUSH
46861: LD_INT 3
46863: NEG
46864: PUSH
46865: EMPTY
46866: LIST
46867: LIST
46868: PUSH
46869: LD_INT 3
46871: NEG
46872: PUSH
46873: LD_INT 2
46875: NEG
46876: PUSH
46877: EMPTY
46878: LIST
46879: LIST
46880: PUSH
46881: EMPTY
46882: LIST
46883: LIST
46884: LIST
46885: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
46886: LD_ADDR_VAR 0 47
46890: PUSH
46891: LD_INT 2
46893: NEG
46894: PUSH
46895: LD_INT 3
46897: NEG
46898: PUSH
46899: EMPTY
46900: LIST
46901: LIST
46902: PUSH
46903: LD_INT 1
46905: NEG
46906: PUSH
46907: LD_INT 3
46909: NEG
46910: PUSH
46911: EMPTY
46912: LIST
46913: LIST
46914: PUSH
46915: EMPTY
46916: LIST
46917: LIST
46918: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
46919: LD_ADDR_VAR 0 48
46923: PUSH
46924: LD_INT 1
46926: PUSH
46927: LD_INT 2
46929: NEG
46930: PUSH
46931: EMPTY
46932: LIST
46933: LIST
46934: PUSH
46935: LD_INT 2
46937: PUSH
46938: LD_INT 1
46940: NEG
46941: PUSH
46942: EMPTY
46943: LIST
46944: LIST
46945: PUSH
46946: EMPTY
46947: LIST
46948: LIST
46949: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
46950: LD_ADDR_VAR 0 49
46954: PUSH
46955: LD_INT 3
46957: PUSH
46958: LD_INT 1
46960: PUSH
46961: EMPTY
46962: LIST
46963: LIST
46964: PUSH
46965: LD_INT 3
46967: PUSH
46968: LD_INT 2
46970: PUSH
46971: EMPTY
46972: LIST
46973: LIST
46974: PUSH
46975: EMPTY
46976: LIST
46977: LIST
46978: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
46979: LD_ADDR_VAR 0 50
46983: PUSH
46984: LD_INT 2
46986: PUSH
46987: LD_INT 3
46989: PUSH
46990: EMPTY
46991: LIST
46992: LIST
46993: PUSH
46994: LD_INT 1
46996: PUSH
46997: LD_INT 3
46999: PUSH
47000: EMPTY
47001: LIST
47002: LIST
47003: PUSH
47004: EMPTY
47005: LIST
47006: LIST
47007: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
47008: LD_ADDR_VAR 0 51
47012: PUSH
47013: LD_INT 1
47015: NEG
47016: PUSH
47017: LD_INT 2
47019: PUSH
47020: EMPTY
47021: LIST
47022: LIST
47023: PUSH
47024: LD_INT 2
47026: NEG
47027: PUSH
47028: LD_INT 1
47030: PUSH
47031: EMPTY
47032: LIST
47033: LIST
47034: PUSH
47035: EMPTY
47036: LIST
47037: LIST
47038: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
47039: LD_ADDR_VAR 0 52
47043: PUSH
47044: LD_INT 3
47046: NEG
47047: PUSH
47048: LD_INT 1
47050: NEG
47051: PUSH
47052: EMPTY
47053: LIST
47054: LIST
47055: PUSH
47056: LD_INT 3
47058: NEG
47059: PUSH
47060: LD_INT 2
47062: NEG
47063: PUSH
47064: EMPTY
47065: LIST
47066: LIST
47067: PUSH
47068: EMPTY
47069: LIST
47070: LIST
47071: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
47072: LD_ADDR_VAR 0 53
47076: PUSH
47077: LD_INT 1
47079: NEG
47080: PUSH
47081: LD_INT 3
47083: NEG
47084: PUSH
47085: EMPTY
47086: LIST
47087: LIST
47088: PUSH
47089: LD_INT 0
47091: PUSH
47092: LD_INT 3
47094: NEG
47095: PUSH
47096: EMPTY
47097: LIST
47098: LIST
47099: PUSH
47100: LD_INT 1
47102: PUSH
47103: LD_INT 2
47105: NEG
47106: PUSH
47107: EMPTY
47108: LIST
47109: LIST
47110: PUSH
47111: EMPTY
47112: LIST
47113: LIST
47114: LIST
47115: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
47116: LD_ADDR_VAR 0 54
47120: PUSH
47121: LD_INT 2
47123: PUSH
47124: LD_INT 1
47126: NEG
47127: PUSH
47128: EMPTY
47129: LIST
47130: LIST
47131: PUSH
47132: LD_INT 3
47134: PUSH
47135: LD_INT 0
47137: PUSH
47138: EMPTY
47139: LIST
47140: LIST
47141: PUSH
47142: LD_INT 3
47144: PUSH
47145: LD_INT 1
47147: PUSH
47148: EMPTY
47149: LIST
47150: LIST
47151: PUSH
47152: EMPTY
47153: LIST
47154: LIST
47155: LIST
47156: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
47157: LD_ADDR_VAR 0 55
47161: PUSH
47162: LD_INT 3
47164: PUSH
47165: LD_INT 2
47167: PUSH
47168: EMPTY
47169: LIST
47170: LIST
47171: PUSH
47172: LD_INT 3
47174: PUSH
47175: LD_INT 3
47177: PUSH
47178: EMPTY
47179: LIST
47180: LIST
47181: PUSH
47182: LD_INT 2
47184: PUSH
47185: LD_INT 3
47187: PUSH
47188: EMPTY
47189: LIST
47190: LIST
47191: PUSH
47192: EMPTY
47193: LIST
47194: LIST
47195: LIST
47196: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
47197: LD_ADDR_VAR 0 56
47201: PUSH
47202: LD_INT 1
47204: PUSH
47205: LD_INT 3
47207: PUSH
47208: EMPTY
47209: LIST
47210: LIST
47211: PUSH
47212: LD_INT 0
47214: PUSH
47215: LD_INT 3
47217: PUSH
47218: EMPTY
47219: LIST
47220: LIST
47221: PUSH
47222: LD_INT 1
47224: NEG
47225: PUSH
47226: LD_INT 2
47228: PUSH
47229: EMPTY
47230: LIST
47231: LIST
47232: PUSH
47233: EMPTY
47234: LIST
47235: LIST
47236: LIST
47237: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
47238: LD_ADDR_VAR 0 57
47242: PUSH
47243: LD_INT 2
47245: NEG
47246: PUSH
47247: LD_INT 1
47249: PUSH
47250: EMPTY
47251: LIST
47252: LIST
47253: PUSH
47254: LD_INT 3
47256: NEG
47257: PUSH
47258: LD_INT 0
47260: PUSH
47261: EMPTY
47262: LIST
47263: LIST
47264: PUSH
47265: LD_INT 3
47267: NEG
47268: PUSH
47269: LD_INT 1
47271: NEG
47272: PUSH
47273: EMPTY
47274: LIST
47275: LIST
47276: PUSH
47277: EMPTY
47278: LIST
47279: LIST
47280: LIST
47281: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
47282: LD_ADDR_VAR 0 58
47286: PUSH
47287: LD_INT 2
47289: NEG
47290: PUSH
47291: LD_INT 3
47293: NEG
47294: PUSH
47295: EMPTY
47296: LIST
47297: LIST
47298: PUSH
47299: LD_INT 3
47301: NEG
47302: PUSH
47303: LD_INT 2
47305: NEG
47306: PUSH
47307: EMPTY
47308: LIST
47309: LIST
47310: PUSH
47311: LD_INT 3
47313: NEG
47314: PUSH
47315: LD_INT 3
47317: NEG
47318: PUSH
47319: EMPTY
47320: LIST
47321: LIST
47322: PUSH
47323: EMPTY
47324: LIST
47325: LIST
47326: LIST
47327: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
47328: LD_ADDR_VAR 0 59
47332: PUSH
47333: LD_INT 1
47335: NEG
47336: PUSH
47337: LD_INT 2
47339: NEG
47340: PUSH
47341: EMPTY
47342: LIST
47343: LIST
47344: PUSH
47345: LD_INT 0
47347: PUSH
47348: LD_INT 2
47350: NEG
47351: PUSH
47352: EMPTY
47353: LIST
47354: LIST
47355: PUSH
47356: LD_INT 1
47358: PUSH
47359: LD_INT 1
47361: NEG
47362: PUSH
47363: EMPTY
47364: LIST
47365: LIST
47366: PUSH
47367: EMPTY
47368: LIST
47369: LIST
47370: LIST
47371: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
47372: LD_ADDR_VAR 0 60
47376: PUSH
47377: LD_INT 1
47379: PUSH
47380: LD_INT 1
47382: NEG
47383: PUSH
47384: EMPTY
47385: LIST
47386: LIST
47387: PUSH
47388: LD_INT 2
47390: PUSH
47391: LD_INT 0
47393: PUSH
47394: EMPTY
47395: LIST
47396: LIST
47397: PUSH
47398: LD_INT 2
47400: PUSH
47401: LD_INT 1
47403: PUSH
47404: EMPTY
47405: LIST
47406: LIST
47407: PUSH
47408: EMPTY
47409: LIST
47410: LIST
47411: LIST
47412: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
47413: LD_ADDR_VAR 0 61
47417: PUSH
47418: LD_INT 2
47420: PUSH
47421: LD_INT 1
47423: PUSH
47424: EMPTY
47425: LIST
47426: LIST
47427: PUSH
47428: LD_INT 2
47430: PUSH
47431: LD_INT 2
47433: PUSH
47434: EMPTY
47435: LIST
47436: LIST
47437: PUSH
47438: LD_INT 1
47440: PUSH
47441: LD_INT 2
47443: PUSH
47444: EMPTY
47445: LIST
47446: LIST
47447: PUSH
47448: EMPTY
47449: LIST
47450: LIST
47451: LIST
47452: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
47453: LD_ADDR_VAR 0 62
47457: PUSH
47458: LD_INT 1
47460: PUSH
47461: LD_INT 2
47463: PUSH
47464: EMPTY
47465: LIST
47466: LIST
47467: PUSH
47468: LD_INT 0
47470: PUSH
47471: LD_INT 2
47473: PUSH
47474: EMPTY
47475: LIST
47476: LIST
47477: PUSH
47478: LD_INT 1
47480: NEG
47481: PUSH
47482: LD_INT 1
47484: PUSH
47485: EMPTY
47486: LIST
47487: LIST
47488: PUSH
47489: EMPTY
47490: LIST
47491: LIST
47492: LIST
47493: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
47494: LD_ADDR_VAR 0 63
47498: PUSH
47499: LD_INT 1
47501: NEG
47502: PUSH
47503: LD_INT 1
47505: PUSH
47506: EMPTY
47507: LIST
47508: LIST
47509: PUSH
47510: LD_INT 2
47512: NEG
47513: PUSH
47514: LD_INT 0
47516: PUSH
47517: EMPTY
47518: LIST
47519: LIST
47520: PUSH
47521: LD_INT 2
47523: NEG
47524: PUSH
47525: LD_INT 1
47527: NEG
47528: PUSH
47529: EMPTY
47530: LIST
47531: LIST
47532: PUSH
47533: EMPTY
47534: LIST
47535: LIST
47536: LIST
47537: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
47538: LD_ADDR_VAR 0 64
47542: PUSH
47543: LD_INT 1
47545: NEG
47546: PUSH
47547: LD_INT 2
47549: NEG
47550: PUSH
47551: EMPTY
47552: LIST
47553: LIST
47554: PUSH
47555: LD_INT 2
47557: NEG
47558: PUSH
47559: LD_INT 1
47561: NEG
47562: PUSH
47563: EMPTY
47564: LIST
47565: LIST
47566: PUSH
47567: LD_INT 2
47569: NEG
47570: PUSH
47571: LD_INT 2
47573: NEG
47574: PUSH
47575: EMPTY
47576: LIST
47577: LIST
47578: PUSH
47579: EMPTY
47580: LIST
47581: LIST
47582: LIST
47583: ST_TO_ADDR
// end ; 2 :
47584: GO 50850
47586: LD_INT 2
47588: DOUBLE
47589: EQUAL
47590: IFTRUE 47594
47592: GO 50849
47594: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
47595: LD_ADDR_VAR 0 29
47599: PUSH
47600: LD_INT 4
47602: PUSH
47603: LD_INT 0
47605: PUSH
47606: EMPTY
47607: LIST
47608: LIST
47609: PUSH
47610: LD_INT 4
47612: PUSH
47613: LD_INT 1
47615: NEG
47616: PUSH
47617: EMPTY
47618: LIST
47619: LIST
47620: PUSH
47621: LD_INT 5
47623: PUSH
47624: LD_INT 0
47626: PUSH
47627: EMPTY
47628: LIST
47629: LIST
47630: PUSH
47631: LD_INT 5
47633: PUSH
47634: LD_INT 1
47636: PUSH
47637: EMPTY
47638: LIST
47639: LIST
47640: PUSH
47641: LD_INT 4
47643: PUSH
47644: LD_INT 1
47646: PUSH
47647: EMPTY
47648: LIST
47649: LIST
47650: PUSH
47651: LD_INT 3
47653: PUSH
47654: LD_INT 0
47656: PUSH
47657: EMPTY
47658: LIST
47659: LIST
47660: PUSH
47661: LD_INT 3
47663: PUSH
47664: LD_INT 1
47666: NEG
47667: PUSH
47668: EMPTY
47669: LIST
47670: LIST
47671: PUSH
47672: LD_INT 3
47674: PUSH
47675: LD_INT 2
47677: NEG
47678: PUSH
47679: EMPTY
47680: LIST
47681: LIST
47682: PUSH
47683: LD_INT 5
47685: PUSH
47686: LD_INT 2
47688: PUSH
47689: EMPTY
47690: LIST
47691: LIST
47692: PUSH
47693: LD_INT 3
47695: PUSH
47696: LD_INT 3
47698: PUSH
47699: EMPTY
47700: LIST
47701: LIST
47702: PUSH
47703: LD_INT 3
47705: PUSH
47706: LD_INT 2
47708: PUSH
47709: EMPTY
47710: LIST
47711: LIST
47712: PUSH
47713: LD_INT 4
47715: PUSH
47716: LD_INT 3
47718: PUSH
47719: EMPTY
47720: LIST
47721: LIST
47722: PUSH
47723: LD_INT 4
47725: PUSH
47726: LD_INT 4
47728: PUSH
47729: EMPTY
47730: LIST
47731: LIST
47732: PUSH
47733: LD_INT 3
47735: PUSH
47736: LD_INT 4
47738: PUSH
47739: EMPTY
47740: LIST
47741: LIST
47742: PUSH
47743: LD_INT 2
47745: PUSH
47746: LD_INT 3
47748: PUSH
47749: EMPTY
47750: LIST
47751: LIST
47752: PUSH
47753: LD_INT 2
47755: PUSH
47756: LD_INT 2
47758: PUSH
47759: EMPTY
47760: LIST
47761: LIST
47762: PUSH
47763: LD_INT 4
47765: PUSH
47766: LD_INT 2
47768: PUSH
47769: EMPTY
47770: LIST
47771: LIST
47772: PUSH
47773: LD_INT 2
47775: PUSH
47776: LD_INT 4
47778: PUSH
47779: EMPTY
47780: LIST
47781: LIST
47782: PUSH
47783: LD_INT 0
47785: PUSH
47786: LD_INT 4
47788: PUSH
47789: EMPTY
47790: LIST
47791: LIST
47792: PUSH
47793: LD_INT 0
47795: PUSH
47796: LD_INT 3
47798: PUSH
47799: EMPTY
47800: LIST
47801: LIST
47802: PUSH
47803: LD_INT 1
47805: PUSH
47806: LD_INT 4
47808: PUSH
47809: EMPTY
47810: LIST
47811: LIST
47812: PUSH
47813: LD_INT 1
47815: PUSH
47816: LD_INT 5
47818: PUSH
47819: EMPTY
47820: LIST
47821: LIST
47822: PUSH
47823: LD_INT 0
47825: PUSH
47826: LD_INT 5
47828: PUSH
47829: EMPTY
47830: LIST
47831: LIST
47832: PUSH
47833: LD_INT 1
47835: NEG
47836: PUSH
47837: LD_INT 4
47839: PUSH
47840: EMPTY
47841: LIST
47842: LIST
47843: PUSH
47844: LD_INT 1
47846: NEG
47847: PUSH
47848: LD_INT 3
47850: PUSH
47851: EMPTY
47852: LIST
47853: LIST
47854: PUSH
47855: LD_INT 2
47857: PUSH
47858: LD_INT 5
47860: PUSH
47861: EMPTY
47862: LIST
47863: LIST
47864: PUSH
47865: LD_INT 2
47867: NEG
47868: PUSH
47869: LD_INT 3
47871: PUSH
47872: EMPTY
47873: LIST
47874: LIST
47875: PUSH
47876: LD_INT 3
47878: NEG
47879: PUSH
47880: LD_INT 0
47882: PUSH
47883: EMPTY
47884: LIST
47885: LIST
47886: PUSH
47887: LD_INT 3
47889: NEG
47890: PUSH
47891: LD_INT 1
47893: NEG
47894: PUSH
47895: EMPTY
47896: LIST
47897: LIST
47898: PUSH
47899: LD_INT 2
47901: NEG
47902: PUSH
47903: LD_INT 0
47905: PUSH
47906: EMPTY
47907: LIST
47908: LIST
47909: PUSH
47910: LD_INT 2
47912: NEG
47913: PUSH
47914: LD_INT 1
47916: PUSH
47917: EMPTY
47918: LIST
47919: LIST
47920: PUSH
47921: LD_INT 3
47923: NEG
47924: PUSH
47925: LD_INT 1
47927: PUSH
47928: EMPTY
47929: LIST
47930: LIST
47931: PUSH
47932: LD_INT 4
47934: NEG
47935: PUSH
47936: LD_INT 0
47938: PUSH
47939: EMPTY
47940: LIST
47941: LIST
47942: PUSH
47943: LD_INT 4
47945: NEG
47946: PUSH
47947: LD_INT 1
47949: NEG
47950: PUSH
47951: EMPTY
47952: LIST
47953: LIST
47954: PUSH
47955: LD_INT 4
47957: NEG
47958: PUSH
47959: LD_INT 2
47961: NEG
47962: PUSH
47963: EMPTY
47964: LIST
47965: LIST
47966: PUSH
47967: LD_INT 2
47969: NEG
47970: PUSH
47971: LD_INT 2
47973: PUSH
47974: EMPTY
47975: LIST
47976: LIST
47977: PUSH
47978: LD_INT 4
47980: NEG
47981: PUSH
47982: LD_INT 4
47984: NEG
47985: PUSH
47986: EMPTY
47987: LIST
47988: LIST
47989: PUSH
47990: LD_INT 4
47992: NEG
47993: PUSH
47994: LD_INT 5
47996: NEG
47997: PUSH
47998: EMPTY
47999: LIST
48000: LIST
48001: PUSH
48002: LD_INT 3
48004: NEG
48005: PUSH
48006: LD_INT 4
48008: NEG
48009: PUSH
48010: EMPTY
48011: LIST
48012: LIST
48013: PUSH
48014: LD_INT 3
48016: NEG
48017: PUSH
48018: LD_INT 3
48020: NEG
48021: PUSH
48022: EMPTY
48023: LIST
48024: LIST
48025: PUSH
48026: LD_INT 4
48028: NEG
48029: PUSH
48030: LD_INT 3
48032: NEG
48033: PUSH
48034: EMPTY
48035: LIST
48036: LIST
48037: PUSH
48038: LD_INT 5
48040: NEG
48041: PUSH
48042: LD_INT 4
48044: NEG
48045: PUSH
48046: EMPTY
48047: LIST
48048: LIST
48049: PUSH
48050: LD_INT 5
48052: NEG
48053: PUSH
48054: LD_INT 5
48056: NEG
48057: PUSH
48058: EMPTY
48059: LIST
48060: LIST
48061: PUSH
48062: LD_INT 3
48064: NEG
48065: PUSH
48066: LD_INT 5
48068: NEG
48069: PUSH
48070: EMPTY
48071: LIST
48072: LIST
48073: PUSH
48074: LD_INT 5
48076: NEG
48077: PUSH
48078: LD_INT 3
48080: NEG
48081: PUSH
48082: EMPTY
48083: LIST
48084: LIST
48085: PUSH
48086: EMPTY
48087: LIST
48088: LIST
48089: LIST
48090: LIST
48091: LIST
48092: LIST
48093: LIST
48094: LIST
48095: LIST
48096: LIST
48097: LIST
48098: LIST
48099: LIST
48100: LIST
48101: LIST
48102: LIST
48103: LIST
48104: LIST
48105: LIST
48106: LIST
48107: LIST
48108: LIST
48109: LIST
48110: LIST
48111: LIST
48112: LIST
48113: LIST
48114: LIST
48115: LIST
48116: LIST
48117: LIST
48118: LIST
48119: LIST
48120: LIST
48121: LIST
48122: LIST
48123: LIST
48124: LIST
48125: LIST
48126: LIST
48127: LIST
48128: LIST
48129: LIST
48130: LIST
48131: LIST
48132: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
48133: LD_ADDR_VAR 0 30
48137: PUSH
48138: LD_INT 4
48140: PUSH
48141: LD_INT 4
48143: PUSH
48144: EMPTY
48145: LIST
48146: LIST
48147: PUSH
48148: LD_INT 4
48150: PUSH
48151: LD_INT 3
48153: PUSH
48154: EMPTY
48155: LIST
48156: LIST
48157: PUSH
48158: LD_INT 5
48160: PUSH
48161: LD_INT 4
48163: PUSH
48164: EMPTY
48165: LIST
48166: LIST
48167: PUSH
48168: LD_INT 5
48170: PUSH
48171: LD_INT 5
48173: PUSH
48174: EMPTY
48175: LIST
48176: LIST
48177: PUSH
48178: LD_INT 4
48180: PUSH
48181: LD_INT 5
48183: PUSH
48184: EMPTY
48185: LIST
48186: LIST
48187: PUSH
48188: LD_INT 3
48190: PUSH
48191: LD_INT 4
48193: PUSH
48194: EMPTY
48195: LIST
48196: LIST
48197: PUSH
48198: LD_INT 3
48200: PUSH
48201: LD_INT 3
48203: PUSH
48204: EMPTY
48205: LIST
48206: LIST
48207: PUSH
48208: LD_INT 5
48210: PUSH
48211: LD_INT 3
48213: PUSH
48214: EMPTY
48215: LIST
48216: LIST
48217: PUSH
48218: LD_INT 3
48220: PUSH
48221: LD_INT 5
48223: PUSH
48224: EMPTY
48225: LIST
48226: LIST
48227: PUSH
48228: LD_INT 0
48230: PUSH
48231: LD_INT 3
48233: PUSH
48234: EMPTY
48235: LIST
48236: LIST
48237: PUSH
48238: LD_INT 0
48240: PUSH
48241: LD_INT 2
48243: PUSH
48244: EMPTY
48245: LIST
48246: LIST
48247: PUSH
48248: LD_INT 1
48250: PUSH
48251: LD_INT 3
48253: PUSH
48254: EMPTY
48255: LIST
48256: LIST
48257: PUSH
48258: LD_INT 1
48260: PUSH
48261: LD_INT 4
48263: PUSH
48264: EMPTY
48265: LIST
48266: LIST
48267: PUSH
48268: LD_INT 0
48270: PUSH
48271: LD_INT 4
48273: PUSH
48274: EMPTY
48275: LIST
48276: LIST
48277: PUSH
48278: LD_INT 1
48280: NEG
48281: PUSH
48282: LD_INT 3
48284: PUSH
48285: EMPTY
48286: LIST
48287: LIST
48288: PUSH
48289: LD_INT 1
48291: NEG
48292: PUSH
48293: LD_INT 2
48295: PUSH
48296: EMPTY
48297: LIST
48298: LIST
48299: PUSH
48300: LD_INT 2
48302: PUSH
48303: LD_INT 4
48305: PUSH
48306: EMPTY
48307: LIST
48308: LIST
48309: PUSH
48310: LD_INT 2
48312: NEG
48313: PUSH
48314: LD_INT 2
48316: PUSH
48317: EMPTY
48318: LIST
48319: LIST
48320: PUSH
48321: LD_INT 4
48323: NEG
48324: PUSH
48325: LD_INT 0
48327: PUSH
48328: EMPTY
48329: LIST
48330: LIST
48331: PUSH
48332: LD_INT 4
48334: NEG
48335: PUSH
48336: LD_INT 1
48338: NEG
48339: PUSH
48340: EMPTY
48341: LIST
48342: LIST
48343: PUSH
48344: LD_INT 3
48346: NEG
48347: PUSH
48348: LD_INT 0
48350: PUSH
48351: EMPTY
48352: LIST
48353: LIST
48354: PUSH
48355: LD_INT 3
48357: NEG
48358: PUSH
48359: LD_INT 1
48361: PUSH
48362: EMPTY
48363: LIST
48364: LIST
48365: PUSH
48366: LD_INT 4
48368: NEG
48369: PUSH
48370: LD_INT 1
48372: PUSH
48373: EMPTY
48374: LIST
48375: LIST
48376: PUSH
48377: LD_INT 5
48379: NEG
48380: PUSH
48381: LD_INT 0
48383: PUSH
48384: EMPTY
48385: LIST
48386: LIST
48387: PUSH
48388: LD_INT 5
48390: NEG
48391: PUSH
48392: LD_INT 1
48394: NEG
48395: PUSH
48396: EMPTY
48397: LIST
48398: LIST
48399: PUSH
48400: LD_INT 5
48402: NEG
48403: PUSH
48404: LD_INT 2
48406: NEG
48407: PUSH
48408: EMPTY
48409: LIST
48410: LIST
48411: PUSH
48412: LD_INT 3
48414: NEG
48415: PUSH
48416: LD_INT 2
48418: PUSH
48419: EMPTY
48420: LIST
48421: LIST
48422: PUSH
48423: LD_INT 3
48425: NEG
48426: PUSH
48427: LD_INT 3
48429: NEG
48430: PUSH
48431: EMPTY
48432: LIST
48433: LIST
48434: PUSH
48435: LD_INT 3
48437: NEG
48438: PUSH
48439: LD_INT 4
48441: NEG
48442: PUSH
48443: EMPTY
48444: LIST
48445: LIST
48446: PUSH
48447: LD_INT 2
48449: NEG
48450: PUSH
48451: LD_INT 3
48453: NEG
48454: PUSH
48455: EMPTY
48456: LIST
48457: LIST
48458: PUSH
48459: LD_INT 2
48461: NEG
48462: PUSH
48463: LD_INT 2
48465: NEG
48466: PUSH
48467: EMPTY
48468: LIST
48469: LIST
48470: PUSH
48471: LD_INT 3
48473: NEG
48474: PUSH
48475: LD_INT 2
48477: NEG
48478: PUSH
48479: EMPTY
48480: LIST
48481: LIST
48482: PUSH
48483: LD_INT 4
48485: NEG
48486: PUSH
48487: LD_INT 3
48489: NEG
48490: PUSH
48491: EMPTY
48492: LIST
48493: LIST
48494: PUSH
48495: LD_INT 4
48497: NEG
48498: PUSH
48499: LD_INT 4
48501: NEG
48502: PUSH
48503: EMPTY
48504: LIST
48505: LIST
48506: PUSH
48507: LD_INT 2
48509: NEG
48510: PUSH
48511: LD_INT 4
48513: NEG
48514: PUSH
48515: EMPTY
48516: LIST
48517: LIST
48518: PUSH
48519: LD_INT 4
48521: NEG
48522: PUSH
48523: LD_INT 2
48525: NEG
48526: PUSH
48527: EMPTY
48528: LIST
48529: LIST
48530: PUSH
48531: LD_INT 0
48533: PUSH
48534: LD_INT 4
48536: NEG
48537: PUSH
48538: EMPTY
48539: LIST
48540: LIST
48541: PUSH
48542: LD_INT 0
48544: PUSH
48545: LD_INT 5
48547: NEG
48548: PUSH
48549: EMPTY
48550: LIST
48551: LIST
48552: PUSH
48553: LD_INT 1
48555: PUSH
48556: LD_INT 4
48558: NEG
48559: PUSH
48560: EMPTY
48561: LIST
48562: LIST
48563: PUSH
48564: LD_INT 1
48566: PUSH
48567: LD_INT 3
48569: NEG
48570: PUSH
48571: EMPTY
48572: LIST
48573: LIST
48574: PUSH
48575: LD_INT 0
48577: PUSH
48578: LD_INT 3
48580: NEG
48581: PUSH
48582: EMPTY
48583: LIST
48584: LIST
48585: PUSH
48586: LD_INT 1
48588: NEG
48589: PUSH
48590: LD_INT 4
48592: NEG
48593: PUSH
48594: EMPTY
48595: LIST
48596: LIST
48597: PUSH
48598: LD_INT 1
48600: NEG
48601: PUSH
48602: LD_INT 5
48604: NEG
48605: PUSH
48606: EMPTY
48607: LIST
48608: LIST
48609: PUSH
48610: LD_INT 2
48612: PUSH
48613: LD_INT 3
48615: NEG
48616: PUSH
48617: EMPTY
48618: LIST
48619: LIST
48620: PUSH
48621: LD_INT 2
48623: NEG
48624: PUSH
48625: LD_INT 5
48627: NEG
48628: PUSH
48629: EMPTY
48630: LIST
48631: LIST
48632: PUSH
48633: EMPTY
48634: LIST
48635: LIST
48636: LIST
48637: LIST
48638: LIST
48639: LIST
48640: LIST
48641: LIST
48642: LIST
48643: LIST
48644: LIST
48645: LIST
48646: LIST
48647: LIST
48648: LIST
48649: LIST
48650: LIST
48651: LIST
48652: LIST
48653: LIST
48654: LIST
48655: LIST
48656: LIST
48657: LIST
48658: LIST
48659: LIST
48660: LIST
48661: LIST
48662: LIST
48663: LIST
48664: LIST
48665: LIST
48666: LIST
48667: LIST
48668: LIST
48669: LIST
48670: LIST
48671: LIST
48672: LIST
48673: LIST
48674: LIST
48675: LIST
48676: LIST
48677: LIST
48678: LIST
48679: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
48680: LD_ADDR_VAR 0 31
48684: PUSH
48685: LD_INT 0
48687: PUSH
48688: LD_INT 4
48690: PUSH
48691: EMPTY
48692: LIST
48693: LIST
48694: PUSH
48695: LD_INT 0
48697: PUSH
48698: LD_INT 3
48700: PUSH
48701: EMPTY
48702: LIST
48703: LIST
48704: PUSH
48705: LD_INT 1
48707: PUSH
48708: LD_INT 4
48710: PUSH
48711: EMPTY
48712: LIST
48713: LIST
48714: PUSH
48715: LD_INT 1
48717: PUSH
48718: LD_INT 5
48720: PUSH
48721: EMPTY
48722: LIST
48723: LIST
48724: PUSH
48725: LD_INT 0
48727: PUSH
48728: LD_INT 5
48730: PUSH
48731: EMPTY
48732: LIST
48733: LIST
48734: PUSH
48735: LD_INT 1
48737: NEG
48738: PUSH
48739: LD_INT 4
48741: PUSH
48742: EMPTY
48743: LIST
48744: LIST
48745: PUSH
48746: LD_INT 1
48748: NEG
48749: PUSH
48750: LD_INT 3
48752: PUSH
48753: EMPTY
48754: LIST
48755: LIST
48756: PUSH
48757: LD_INT 2
48759: PUSH
48760: LD_INT 5
48762: PUSH
48763: EMPTY
48764: LIST
48765: LIST
48766: PUSH
48767: LD_INT 2
48769: NEG
48770: PUSH
48771: LD_INT 3
48773: PUSH
48774: EMPTY
48775: LIST
48776: LIST
48777: PUSH
48778: LD_INT 3
48780: NEG
48781: PUSH
48782: LD_INT 0
48784: PUSH
48785: EMPTY
48786: LIST
48787: LIST
48788: PUSH
48789: LD_INT 3
48791: NEG
48792: PUSH
48793: LD_INT 1
48795: NEG
48796: PUSH
48797: EMPTY
48798: LIST
48799: LIST
48800: PUSH
48801: LD_INT 2
48803: NEG
48804: PUSH
48805: LD_INT 0
48807: PUSH
48808: EMPTY
48809: LIST
48810: LIST
48811: PUSH
48812: LD_INT 2
48814: NEG
48815: PUSH
48816: LD_INT 1
48818: PUSH
48819: EMPTY
48820: LIST
48821: LIST
48822: PUSH
48823: LD_INT 3
48825: NEG
48826: PUSH
48827: LD_INT 1
48829: PUSH
48830: EMPTY
48831: LIST
48832: LIST
48833: PUSH
48834: LD_INT 4
48836: NEG
48837: PUSH
48838: LD_INT 0
48840: PUSH
48841: EMPTY
48842: LIST
48843: LIST
48844: PUSH
48845: LD_INT 4
48847: NEG
48848: PUSH
48849: LD_INT 1
48851: NEG
48852: PUSH
48853: EMPTY
48854: LIST
48855: LIST
48856: PUSH
48857: LD_INT 4
48859: NEG
48860: PUSH
48861: LD_INT 2
48863: NEG
48864: PUSH
48865: EMPTY
48866: LIST
48867: LIST
48868: PUSH
48869: LD_INT 2
48871: NEG
48872: PUSH
48873: LD_INT 2
48875: PUSH
48876: EMPTY
48877: LIST
48878: LIST
48879: PUSH
48880: LD_INT 4
48882: NEG
48883: PUSH
48884: LD_INT 4
48886: NEG
48887: PUSH
48888: EMPTY
48889: LIST
48890: LIST
48891: PUSH
48892: LD_INT 4
48894: NEG
48895: PUSH
48896: LD_INT 5
48898: NEG
48899: PUSH
48900: EMPTY
48901: LIST
48902: LIST
48903: PUSH
48904: LD_INT 3
48906: NEG
48907: PUSH
48908: LD_INT 4
48910: NEG
48911: PUSH
48912: EMPTY
48913: LIST
48914: LIST
48915: PUSH
48916: LD_INT 3
48918: NEG
48919: PUSH
48920: LD_INT 3
48922: NEG
48923: PUSH
48924: EMPTY
48925: LIST
48926: LIST
48927: PUSH
48928: LD_INT 4
48930: NEG
48931: PUSH
48932: LD_INT 3
48934: NEG
48935: PUSH
48936: EMPTY
48937: LIST
48938: LIST
48939: PUSH
48940: LD_INT 5
48942: NEG
48943: PUSH
48944: LD_INT 4
48946: NEG
48947: PUSH
48948: EMPTY
48949: LIST
48950: LIST
48951: PUSH
48952: LD_INT 5
48954: NEG
48955: PUSH
48956: LD_INT 5
48958: NEG
48959: PUSH
48960: EMPTY
48961: LIST
48962: LIST
48963: PUSH
48964: LD_INT 3
48966: NEG
48967: PUSH
48968: LD_INT 5
48970: NEG
48971: PUSH
48972: EMPTY
48973: LIST
48974: LIST
48975: PUSH
48976: LD_INT 5
48978: NEG
48979: PUSH
48980: LD_INT 3
48982: NEG
48983: PUSH
48984: EMPTY
48985: LIST
48986: LIST
48987: PUSH
48988: LD_INT 0
48990: PUSH
48991: LD_INT 3
48993: NEG
48994: PUSH
48995: EMPTY
48996: LIST
48997: LIST
48998: PUSH
48999: LD_INT 0
49001: PUSH
49002: LD_INT 4
49004: NEG
49005: PUSH
49006: EMPTY
49007: LIST
49008: LIST
49009: PUSH
49010: LD_INT 1
49012: PUSH
49013: LD_INT 3
49015: NEG
49016: PUSH
49017: EMPTY
49018: LIST
49019: LIST
49020: PUSH
49021: LD_INT 1
49023: PUSH
49024: LD_INT 2
49026: NEG
49027: PUSH
49028: EMPTY
49029: LIST
49030: LIST
49031: PUSH
49032: LD_INT 0
49034: PUSH
49035: LD_INT 2
49037: NEG
49038: PUSH
49039: EMPTY
49040: LIST
49041: LIST
49042: PUSH
49043: LD_INT 1
49045: NEG
49046: PUSH
49047: LD_INT 3
49049: NEG
49050: PUSH
49051: EMPTY
49052: LIST
49053: LIST
49054: PUSH
49055: LD_INT 1
49057: NEG
49058: PUSH
49059: LD_INT 4
49061: NEG
49062: PUSH
49063: EMPTY
49064: LIST
49065: LIST
49066: PUSH
49067: LD_INT 2
49069: PUSH
49070: LD_INT 2
49072: NEG
49073: PUSH
49074: EMPTY
49075: LIST
49076: LIST
49077: PUSH
49078: LD_INT 2
49080: NEG
49081: PUSH
49082: LD_INT 4
49084: NEG
49085: PUSH
49086: EMPTY
49087: LIST
49088: LIST
49089: PUSH
49090: LD_INT 4
49092: PUSH
49093: LD_INT 0
49095: PUSH
49096: EMPTY
49097: LIST
49098: LIST
49099: PUSH
49100: LD_INT 4
49102: PUSH
49103: LD_INT 1
49105: NEG
49106: PUSH
49107: EMPTY
49108: LIST
49109: LIST
49110: PUSH
49111: LD_INT 5
49113: PUSH
49114: LD_INT 0
49116: PUSH
49117: EMPTY
49118: LIST
49119: LIST
49120: PUSH
49121: LD_INT 5
49123: PUSH
49124: LD_INT 1
49126: PUSH
49127: EMPTY
49128: LIST
49129: LIST
49130: PUSH
49131: LD_INT 4
49133: PUSH
49134: LD_INT 1
49136: PUSH
49137: EMPTY
49138: LIST
49139: LIST
49140: PUSH
49141: LD_INT 3
49143: PUSH
49144: LD_INT 0
49146: PUSH
49147: EMPTY
49148: LIST
49149: LIST
49150: PUSH
49151: LD_INT 3
49153: PUSH
49154: LD_INT 1
49156: NEG
49157: PUSH
49158: EMPTY
49159: LIST
49160: LIST
49161: PUSH
49162: LD_INT 3
49164: PUSH
49165: LD_INT 2
49167: NEG
49168: PUSH
49169: EMPTY
49170: LIST
49171: LIST
49172: PUSH
49173: LD_INT 5
49175: PUSH
49176: LD_INT 2
49178: PUSH
49179: EMPTY
49180: LIST
49181: LIST
49182: PUSH
49183: EMPTY
49184: LIST
49185: LIST
49186: LIST
49187: LIST
49188: LIST
49189: LIST
49190: LIST
49191: LIST
49192: LIST
49193: LIST
49194: LIST
49195: LIST
49196: LIST
49197: LIST
49198: LIST
49199: LIST
49200: LIST
49201: LIST
49202: LIST
49203: LIST
49204: LIST
49205: LIST
49206: LIST
49207: LIST
49208: LIST
49209: LIST
49210: LIST
49211: LIST
49212: LIST
49213: LIST
49214: LIST
49215: LIST
49216: LIST
49217: LIST
49218: LIST
49219: LIST
49220: LIST
49221: LIST
49222: LIST
49223: LIST
49224: LIST
49225: LIST
49226: LIST
49227: LIST
49228: LIST
49229: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
49230: LD_ADDR_VAR 0 32
49234: PUSH
49235: LD_INT 4
49237: NEG
49238: PUSH
49239: LD_INT 0
49241: PUSH
49242: EMPTY
49243: LIST
49244: LIST
49245: PUSH
49246: LD_INT 4
49248: NEG
49249: PUSH
49250: LD_INT 1
49252: NEG
49253: PUSH
49254: EMPTY
49255: LIST
49256: LIST
49257: PUSH
49258: LD_INT 3
49260: NEG
49261: PUSH
49262: LD_INT 0
49264: PUSH
49265: EMPTY
49266: LIST
49267: LIST
49268: PUSH
49269: LD_INT 3
49271: NEG
49272: PUSH
49273: LD_INT 1
49275: PUSH
49276: EMPTY
49277: LIST
49278: LIST
49279: PUSH
49280: LD_INT 4
49282: NEG
49283: PUSH
49284: LD_INT 1
49286: PUSH
49287: EMPTY
49288: LIST
49289: LIST
49290: PUSH
49291: LD_INT 5
49293: NEG
49294: PUSH
49295: LD_INT 0
49297: PUSH
49298: EMPTY
49299: LIST
49300: LIST
49301: PUSH
49302: LD_INT 5
49304: NEG
49305: PUSH
49306: LD_INT 1
49308: NEG
49309: PUSH
49310: EMPTY
49311: LIST
49312: LIST
49313: PUSH
49314: LD_INT 5
49316: NEG
49317: PUSH
49318: LD_INT 2
49320: NEG
49321: PUSH
49322: EMPTY
49323: LIST
49324: LIST
49325: PUSH
49326: LD_INT 3
49328: NEG
49329: PUSH
49330: LD_INT 2
49332: PUSH
49333: EMPTY
49334: LIST
49335: LIST
49336: PUSH
49337: LD_INT 3
49339: NEG
49340: PUSH
49341: LD_INT 3
49343: NEG
49344: PUSH
49345: EMPTY
49346: LIST
49347: LIST
49348: PUSH
49349: LD_INT 3
49351: NEG
49352: PUSH
49353: LD_INT 4
49355: NEG
49356: PUSH
49357: EMPTY
49358: LIST
49359: LIST
49360: PUSH
49361: LD_INT 2
49363: NEG
49364: PUSH
49365: LD_INT 3
49367: NEG
49368: PUSH
49369: EMPTY
49370: LIST
49371: LIST
49372: PUSH
49373: LD_INT 2
49375: NEG
49376: PUSH
49377: LD_INT 2
49379: NEG
49380: PUSH
49381: EMPTY
49382: LIST
49383: LIST
49384: PUSH
49385: LD_INT 3
49387: NEG
49388: PUSH
49389: LD_INT 2
49391: NEG
49392: PUSH
49393: EMPTY
49394: LIST
49395: LIST
49396: PUSH
49397: LD_INT 4
49399: NEG
49400: PUSH
49401: LD_INT 3
49403: NEG
49404: PUSH
49405: EMPTY
49406: LIST
49407: LIST
49408: PUSH
49409: LD_INT 4
49411: NEG
49412: PUSH
49413: LD_INT 4
49415: NEG
49416: PUSH
49417: EMPTY
49418: LIST
49419: LIST
49420: PUSH
49421: LD_INT 2
49423: NEG
49424: PUSH
49425: LD_INT 4
49427: NEG
49428: PUSH
49429: EMPTY
49430: LIST
49431: LIST
49432: PUSH
49433: LD_INT 4
49435: NEG
49436: PUSH
49437: LD_INT 2
49439: NEG
49440: PUSH
49441: EMPTY
49442: LIST
49443: LIST
49444: PUSH
49445: LD_INT 0
49447: PUSH
49448: LD_INT 4
49450: NEG
49451: PUSH
49452: EMPTY
49453: LIST
49454: LIST
49455: PUSH
49456: LD_INT 0
49458: PUSH
49459: LD_INT 5
49461: NEG
49462: PUSH
49463: EMPTY
49464: LIST
49465: LIST
49466: PUSH
49467: LD_INT 1
49469: PUSH
49470: LD_INT 4
49472: NEG
49473: PUSH
49474: EMPTY
49475: LIST
49476: LIST
49477: PUSH
49478: LD_INT 1
49480: PUSH
49481: LD_INT 3
49483: NEG
49484: PUSH
49485: EMPTY
49486: LIST
49487: LIST
49488: PUSH
49489: LD_INT 0
49491: PUSH
49492: LD_INT 3
49494: NEG
49495: PUSH
49496: EMPTY
49497: LIST
49498: LIST
49499: PUSH
49500: LD_INT 1
49502: NEG
49503: PUSH
49504: LD_INT 4
49506: NEG
49507: PUSH
49508: EMPTY
49509: LIST
49510: LIST
49511: PUSH
49512: LD_INT 1
49514: NEG
49515: PUSH
49516: LD_INT 5
49518: NEG
49519: PUSH
49520: EMPTY
49521: LIST
49522: LIST
49523: PUSH
49524: LD_INT 2
49526: PUSH
49527: LD_INT 3
49529: NEG
49530: PUSH
49531: EMPTY
49532: LIST
49533: LIST
49534: PUSH
49535: LD_INT 2
49537: NEG
49538: PUSH
49539: LD_INT 5
49541: NEG
49542: PUSH
49543: EMPTY
49544: LIST
49545: LIST
49546: PUSH
49547: LD_INT 3
49549: PUSH
49550: LD_INT 0
49552: PUSH
49553: EMPTY
49554: LIST
49555: LIST
49556: PUSH
49557: LD_INT 3
49559: PUSH
49560: LD_INT 1
49562: NEG
49563: PUSH
49564: EMPTY
49565: LIST
49566: LIST
49567: PUSH
49568: LD_INT 4
49570: PUSH
49571: LD_INT 0
49573: PUSH
49574: EMPTY
49575: LIST
49576: LIST
49577: PUSH
49578: LD_INT 4
49580: PUSH
49581: LD_INT 1
49583: PUSH
49584: EMPTY
49585: LIST
49586: LIST
49587: PUSH
49588: LD_INT 3
49590: PUSH
49591: LD_INT 1
49593: PUSH
49594: EMPTY
49595: LIST
49596: LIST
49597: PUSH
49598: LD_INT 2
49600: PUSH
49601: LD_INT 0
49603: PUSH
49604: EMPTY
49605: LIST
49606: LIST
49607: PUSH
49608: LD_INT 2
49610: PUSH
49611: LD_INT 1
49613: NEG
49614: PUSH
49615: EMPTY
49616: LIST
49617: LIST
49618: PUSH
49619: LD_INT 2
49621: PUSH
49622: LD_INT 2
49624: NEG
49625: PUSH
49626: EMPTY
49627: LIST
49628: LIST
49629: PUSH
49630: LD_INT 4
49632: PUSH
49633: LD_INT 2
49635: PUSH
49636: EMPTY
49637: LIST
49638: LIST
49639: PUSH
49640: LD_INT 4
49642: PUSH
49643: LD_INT 4
49645: PUSH
49646: EMPTY
49647: LIST
49648: LIST
49649: PUSH
49650: LD_INT 4
49652: PUSH
49653: LD_INT 3
49655: PUSH
49656: EMPTY
49657: LIST
49658: LIST
49659: PUSH
49660: LD_INT 5
49662: PUSH
49663: LD_INT 4
49665: PUSH
49666: EMPTY
49667: LIST
49668: LIST
49669: PUSH
49670: LD_INT 5
49672: PUSH
49673: LD_INT 5
49675: PUSH
49676: EMPTY
49677: LIST
49678: LIST
49679: PUSH
49680: LD_INT 4
49682: PUSH
49683: LD_INT 5
49685: PUSH
49686: EMPTY
49687: LIST
49688: LIST
49689: PUSH
49690: LD_INT 3
49692: PUSH
49693: LD_INT 4
49695: PUSH
49696: EMPTY
49697: LIST
49698: LIST
49699: PUSH
49700: LD_INT 3
49702: PUSH
49703: LD_INT 3
49705: PUSH
49706: EMPTY
49707: LIST
49708: LIST
49709: PUSH
49710: LD_INT 5
49712: PUSH
49713: LD_INT 3
49715: PUSH
49716: EMPTY
49717: LIST
49718: LIST
49719: PUSH
49720: LD_INT 3
49722: PUSH
49723: LD_INT 5
49725: PUSH
49726: EMPTY
49727: LIST
49728: LIST
49729: PUSH
49730: EMPTY
49731: LIST
49732: LIST
49733: LIST
49734: LIST
49735: LIST
49736: LIST
49737: LIST
49738: LIST
49739: LIST
49740: LIST
49741: LIST
49742: LIST
49743: LIST
49744: LIST
49745: LIST
49746: LIST
49747: LIST
49748: LIST
49749: LIST
49750: LIST
49751: LIST
49752: LIST
49753: LIST
49754: LIST
49755: LIST
49756: LIST
49757: LIST
49758: LIST
49759: LIST
49760: LIST
49761: LIST
49762: LIST
49763: LIST
49764: LIST
49765: LIST
49766: LIST
49767: LIST
49768: LIST
49769: LIST
49770: LIST
49771: LIST
49772: LIST
49773: LIST
49774: LIST
49775: LIST
49776: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
49777: LD_ADDR_VAR 0 33
49781: PUSH
49782: LD_INT 4
49784: NEG
49785: PUSH
49786: LD_INT 4
49788: NEG
49789: PUSH
49790: EMPTY
49791: LIST
49792: LIST
49793: PUSH
49794: LD_INT 4
49796: NEG
49797: PUSH
49798: LD_INT 5
49800: NEG
49801: PUSH
49802: EMPTY
49803: LIST
49804: LIST
49805: PUSH
49806: LD_INT 3
49808: NEG
49809: PUSH
49810: LD_INT 4
49812: NEG
49813: PUSH
49814: EMPTY
49815: LIST
49816: LIST
49817: PUSH
49818: LD_INT 3
49820: NEG
49821: PUSH
49822: LD_INT 3
49824: NEG
49825: PUSH
49826: EMPTY
49827: LIST
49828: LIST
49829: PUSH
49830: LD_INT 4
49832: NEG
49833: PUSH
49834: LD_INT 3
49836: NEG
49837: PUSH
49838: EMPTY
49839: LIST
49840: LIST
49841: PUSH
49842: LD_INT 5
49844: NEG
49845: PUSH
49846: LD_INT 4
49848: NEG
49849: PUSH
49850: EMPTY
49851: LIST
49852: LIST
49853: PUSH
49854: LD_INT 5
49856: NEG
49857: PUSH
49858: LD_INT 5
49860: NEG
49861: PUSH
49862: EMPTY
49863: LIST
49864: LIST
49865: PUSH
49866: LD_INT 3
49868: NEG
49869: PUSH
49870: LD_INT 5
49872: NEG
49873: PUSH
49874: EMPTY
49875: LIST
49876: LIST
49877: PUSH
49878: LD_INT 5
49880: NEG
49881: PUSH
49882: LD_INT 3
49884: NEG
49885: PUSH
49886: EMPTY
49887: LIST
49888: LIST
49889: PUSH
49890: LD_INT 0
49892: PUSH
49893: LD_INT 3
49895: NEG
49896: PUSH
49897: EMPTY
49898: LIST
49899: LIST
49900: PUSH
49901: LD_INT 0
49903: PUSH
49904: LD_INT 4
49906: NEG
49907: PUSH
49908: EMPTY
49909: LIST
49910: LIST
49911: PUSH
49912: LD_INT 1
49914: PUSH
49915: LD_INT 3
49917: NEG
49918: PUSH
49919: EMPTY
49920: LIST
49921: LIST
49922: PUSH
49923: LD_INT 1
49925: PUSH
49926: LD_INT 2
49928: NEG
49929: PUSH
49930: EMPTY
49931: LIST
49932: LIST
49933: PUSH
49934: LD_INT 0
49936: PUSH
49937: LD_INT 2
49939: NEG
49940: PUSH
49941: EMPTY
49942: LIST
49943: LIST
49944: PUSH
49945: LD_INT 1
49947: NEG
49948: PUSH
49949: LD_INT 3
49951: NEG
49952: PUSH
49953: EMPTY
49954: LIST
49955: LIST
49956: PUSH
49957: LD_INT 1
49959: NEG
49960: PUSH
49961: LD_INT 4
49963: NEG
49964: PUSH
49965: EMPTY
49966: LIST
49967: LIST
49968: PUSH
49969: LD_INT 2
49971: PUSH
49972: LD_INT 2
49974: NEG
49975: PUSH
49976: EMPTY
49977: LIST
49978: LIST
49979: PUSH
49980: LD_INT 2
49982: NEG
49983: PUSH
49984: LD_INT 4
49986: NEG
49987: PUSH
49988: EMPTY
49989: LIST
49990: LIST
49991: PUSH
49992: LD_INT 4
49994: PUSH
49995: LD_INT 0
49997: PUSH
49998: EMPTY
49999: LIST
50000: LIST
50001: PUSH
50002: LD_INT 4
50004: PUSH
50005: LD_INT 1
50007: NEG
50008: PUSH
50009: EMPTY
50010: LIST
50011: LIST
50012: PUSH
50013: LD_INT 5
50015: PUSH
50016: LD_INT 0
50018: PUSH
50019: EMPTY
50020: LIST
50021: LIST
50022: PUSH
50023: LD_INT 5
50025: PUSH
50026: LD_INT 1
50028: PUSH
50029: EMPTY
50030: LIST
50031: LIST
50032: PUSH
50033: LD_INT 4
50035: PUSH
50036: LD_INT 1
50038: PUSH
50039: EMPTY
50040: LIST
50041: LIST
50042: PUSH
50043: LD_INT 3
50045: PUSH
50046: LD_INT 0
50048: PUSH
50049: EMPTY
50050: LIST
50051: LIST
50052: PUSH
50053: LD_INT 3
50055: PUSH
50056: LD_INT 1
50058: NEG
50059: PUSH
50060: EMPTY
50061: LIST
50062: LIST
50063: PUSH
50064: LD_INT 3
50066: PUSH
50067: LD_INT 2
50069: NEG
50070: PUSH
50071: EMPTY
50072: LIST
50073: LIST
50074: PUSH
50075: LD_INT 5
50077: PUSH
50078: LD_INT 2
50080: PUSH
50081: EMPTY
50082: LIST
50083: LIST
50084: PUSH
50085: LD_INT 3
50087: PUSH
50088: LD_INT 3
50090: PUSH
50091: EMPTY
50092: LIST
50093: LIST
50094: PUSH
50095: LD_INT 3
50097: PUSH
50098: LD_INT 2
50100: PUSH
50101: EMPTY
50102: LIST
50103: LIST
50104: PUSH
50105: LD_INT 4
50107: PUSH
50108: LD_INT 3
50110: PUSH
50111: EMPTY
50112: LIST
50113: LIST
50114: PUSH
50115: LD_INT 4
50117: PUSH
50118: LD_INT 4
50120: PUSH
50121: EMPTY
50122: LIST
50123: LIST
50124: PUSH
50125: LD_INT 3
50127: PUSH
50128: LD_INT 4
50130: PUSH
50131: EMPTY
50132: LIST
50133: LIST
50134: PUSH
50135: LD_INT 2
50137: PUSH
50138: LD_INT 3
50140: PUSH
50141: EMPTY
50142: LIST
50143: LIST
50144: PUSH
50145: LD_INT 2
50147: PUSH
50148: LD_INT 2
50150: PUSH
50151: EMPTY
50152: LIST
50153: LIST
50154: PUSH
50155: LD_INT 4
50157: PUSH
50158: LD_INT 2
50160: PUSH
50161: EMPTY
50162: LIST
50163: LIST
50164: PUSH
50165: LD_INT 2
50167: PUSH
50168: LD_INT 4
50170: PUSH
50171: EMPTY
50172: LIST
50173: LIST
50174: PUSH
50175: LD_INT 0
50177: PUSH
50178: LD_INT 4
50180: PUSH
50181: EMPTY
50182: LIST
50183: LIST
50184: PUSH
50185: LD_INT 0
50187: PUSH
50188: LD_INT 3
50190: PUSH
50191: EMPTY
50192: LIST
50193: LIST
50194: PUSH
50195: LD_INT 1
50197: PUSH
50198: LD_INT 4
50200: PUSH
50201: EMPTY
50202: LIST
50203: LIST
50204: PUSH
50205: LD_INT 1
50207: PUSH
50208: LD_INT 5
50210: PUSH
50211: EMPTY
50212: LIST
50213: LIST
50214: PUSH
50215: LD_INT 0
50217: PUSH
50218: LD_INT 5
50220: PUSH
50221: EMPTY
50222: LIST
50223: LIST
50224: PUSH
50225: LD_INT 1
50227: NEG
50228: PUSH
50229: LD_INT 4
50231: PUSH
50232: EMPTY
50233: LIST
50234: LIST
50235: PUSH
50236: LD_INT 1
50238: NEG
50239: PUSH
50240: LD_INT 3
50242: PUSH
50243: EMPTY
50244: LIST
50245: LIST
50246: PUSH
50247: LD_INT 2
50249: PUSH
50250: LD_INT 5
50252: PUSH
50253: EMPTY
50254: LIST
50255: LIST
50256: PUSH
50257: LD_INT 2
50259: NEG
50260: PUSH
50261: LD_INT 3
50263: PUSH
50264: EMPTY
50265: LIST
50266: LIST
50267: PUSH
50268: EMPTY
50269: LIST
50270: LIST
50271: LIST
50272: LIST
50273: LIST
50274: LIST
50275: LIST
50276: LIST
50277: LIST
50278: LIST
50279: LIST
50280: LIST
50281: LIST
50282: LIST
50283: LIST
50284: LIST
50285: LIST
50286: LIST
50287: LIST
50288: LIST
50289: LIST
50290: LIST
50291: LIST
50292: LIST
50293: LIST
50294: LIST
50295: LIST
50296: LIST
50297: LIST
50298: LIST
50299: LIST
50300: LIST
50301: LIST
50302: LIST
50303: LIST
50304: LIST
50305: LIST
50306: LIST
50307: LIST
50308: LIST
50309: LIST
50310: LIST
50311: LIST
50312: LIST
50313: LIST
50314: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
50315: LD_ADDR_VAR 0 34
50319: PUSH
50320: LD_INT 0
50322: PUSH
50323: LD_INT 4
50325: NEG
50326: PUSH
50327: EMPTY
50328: LIST
50329: LIST
50330: PUSH
50331: LD_INT 0
50333: PUSH
50334: LD_INT 5
50336: NEG
50337: PUSH
50338: EMPTY
50339: LIST
50340: LIST
50341: PUSH
50342: LD_INT 1
50344: PUSH
50345: LD_INT 4
50347: NEG
50348: PUSH
50349: EMPTY
50350: LIST
50351: LIST
50352: PUSH
50353: LD_INT 1
50355: PUSH
50356: LD_INT 3
50358: NEG
50359: PUSH
50360: EMPTY
50361: LIST
50362: LIST
50363: PUSH
50364: LD_INT 0
50366: PUSH
50367: LD_INT 3
50369: NEG
50370: PUSH
50371: EMPTY
50372: LIST
50373: LIST
50374: PUSH
50375: LD_INT 1
50377: NEG
50378: PUSH
50379: LD_INT 4
50381: NEG
50382: PUSH
50383: EMPTY
50384: LIST
50385: LIST
50386: PUSH
50387: LD_INT 1
50389: NEG
50390: PUSH
50391: LD_INT 5
50393: NEG
50394: PUSH
50395: EMPTY
50396: LIST
50397: LIST
50398: PUSH
50399: LD_INT 2
50401: PUSH
50402: LD_INT 3
50404: NEG
50405: PUSH
50406: EMPTY
50407: LIST
50408: LIST
50409: PUSH
50410: LD_INT 2
50412: NEG
50413: PUSH
50414: LD_INT 5
50416: NEG
50417: PUSH
50418: EMPTY
50419: LIST
50420: LIST
50421: PUSH
50422: LD_INT 3
50424: PUSH
50425: LD_INT 0
50427: PUSH
50428: EMPTY
50429: LIST
50430: LIST
50431: PUSH
50432: LD_INT 3
50434: PUSH
50435: LD_INT 1
50437: NEG
50438: PUSH
50439: EMPTY
50440: LIST
50441: LIST
50442: PUSH
50443: LD_INT 4
50445: PUSH
50446: LD_INT 0
50448: PUSH
50449: EMPTY
50450: LIST
50451: LIST
50452: PUSH
50453: LD_INT 4
50455: PUSH
50456: LD_INT 1
50458: PUSH
50459: EMPTY
50460: LIST
50461: LIST
50462: PUSH
50463: LD_INT 3
50465: PUSH
50466: LD_INT 1
50468: PUSH
50469: EMPTY
50470: LIST
50471: LIST
50472: PUSH
50473: LD_INT 2
50475: PUSH
50476: LD_INT 0
50478: PUSH
50479: EMPTY
50480: LIST
50481: LIST
50482: PUSH
50483: LD_INT 2
50485: PUSH
50486: LD_INT 1
50488: NEG
50489: PUSH
50490: EMPTY
50491: LIST
50492: LIST
50493: PUSH
50494: LD_INT 2
50496: PUSH
50497: LD_INT 2
50499: NEG
50500: PUSH
50501: EMPTY
50502: LIST
50503: LIST
50504: PUSH
50505: LD_INT 4
50507: PUSH
50508: LD_INT 2
50510: PUSH
50511: EMPTY
50512: LIST
50513: LIST
50514: PUSH
50515: LD_INT 4
50517: PUSH
50518: LD_INT 4
50520: PUSH
50521: EMPTY
50522: LIST
50523: LIST
50524: PUSH
50525: LD_INT 4
50527: PUSH
50528: LD_INT 3
50530: PUSH
50531: EMPTY
50532: LIST
50533: LIST
50534: PUSH
50535: LD_INT 5
50537: PUSH
50538: LD_INT 4
50540: PUSH
50541: EMPTY
50542: LIST
50543: LIST
50544: PUSH
50545: LD_INT 5
50547: PUSH
50548: LD_INT 5
50550: PUSH
50551: EMPTY
50552: LIST
50553: LIST
50554: PUSH
50555: LD_INT 4
50557: PUSH
50558: LD_INT 5
50560: PUSH
50561: EMPTY
50562: LIST
50563: LIST
50564: PUSH
50565: LD_INT 3
50567: PUSH
50568: LD_INT 4
50570: PUSH
50571: EMPTY
50572: LIST
50573: LIST
50574: PUSH
50575: LD_INT 3
50577: PUSH
50578: LD_INT 3
50580: PUSH
50581: EMPTY
50582: LIST
50583: LIST
50584: PUSH
50585: LD_INT 5
50587: PUSH
50588: LD_INT 3
50590: PUSH
50591: EMPTY
50592: LIST
50593: LIST
50594: PUSH
50595: LD_INT 3
50597: PUSH
50598: LD_INT 5
50600: PUSH
50601: EMPTY
50602: LIST
50603: LIST
50604: PUSH
50605: LD_INT 0
50607: PUSH
50608: LD_INT 3
50610: PUSH
50611: EMPTY
50612: LIST
50613: LIST
50614: PUSH
50615: LD_INT 0
50617: PUSH
50618: LD_INT 2
50620: PUSH
50621: EMPTY
50622: LIST
50623: LIST
50624: PUSH
50625: LD_INT 1
50627: PUSH
50628: LD_INT 3
50630: PUSH
50631: EMPTY
50632: LIST
50633: LIST
50634: PUSH
50635: LD_INT 1
50637: PUSH
50638: LD_INT 4
50640: PUSH
50641: EMPTY
50642: LIST
50643: LIST
50644: PUSH
50645: LD_INT 0
50647: PUSH
50648: LD_INT 4
50650: PUSH
50651: EMPTY
50652: LIST
50653: LIST
50654: PUSH
50655: LD_INT 1
50657: NEG
50658: PUSH
50659: LD_INT 3
50661: PUSH
50662: EMPTY
50663: LIST
50664: LIST
50665: PUSH
50666: LD_INT 1
50668: NEG
50669: PUSH
50670: LD_INT 2
50672: PUSH
50673: EMPTY
50674: LIST
50675: LIST
50676: PUSH
50677: LD_INT 2
50679: PUSH
50680: LD_INT 4
50682: PUSH
50683: EMPTY
50684: LIST
50685: LIST
50686: PUSH
50687: LD_INT 2
50689: NEG
50690: PUSH
50691: LD_INT 2
50693: PUSH
50694: EMPTY
50695: LIST
50696: LIST
50697: PUSH
50698: LD_INT 4
50700: NEG
50701: PUSH
50702: LD_INT 0
50704: PUSH
50705: EMPTY
50706: LIST
50707: LIST
50708: PUSH
50709: LD_INT 4
50711: NEG
50712: PUSH
50713: LD_INT 1
50715: NEG
50716: PUSH
50717: EMPTY
50718: LIST
50719: LIST
50720: PUSH
50721: LD_INT 3
50723: NEG
50724: PUSH
50725: LD_INT 0
50727: PUSH
50728: EMPTY
50729: LIST
50730: LIST
50731: PUSH
50732: LD_INT 3
50734: NEG
50735: PUSH
50736: LD_INT 1
50738: PUSH
50739: EMPTY
50740: LIST
50741: LIST
50742: PUSH
50743: LD_INT 4
50745: NEG
50746: PUSH
50747: LD_INT 1
50749: PUSH
50750: EMPTY
50751: LIST
50752: LIST
50753: PUSH
50754: LD_INT 5
50756: NEG
50757: PUSH
50758: LD_INT 0
50760: PUSH
50761: EMPTY
50762: LIST
50763: LIST
50764: PUSH
50765: LD_INT 5
50767: NEG
50768: PUSH
50769: LD_INT 1
50771: NEG
50772: PUSH
50773: EMPTY
50774: LIST
50775: LIST
50776: PUSH
50777: LD_INT 5
50779: NEG
50780: PUSH
50781: LD_INT 2
50783: NEG
50784: PUSH
50785: EMPTY
50786: LIST
50787: LIST
50788: PUSH
50789: LD_INT 3
50791: NEG
50792: PUSH
50793: LD_INT 2
50795: PUSH
50796: EMPTY
50797: LIST
50798: LIST
50799: PUSH
50800: EMPTY
50801: LIST
50802: LIST
50803: LIST
50804: LIST
50805: LIST
50806: LIST
50807: LIST
50808: LIST
50809: LIST
50810: LIST
50811: LIST
50812: LIST
50813: LIST
50814: LIST
50815: LIST
50816: LIST
50817: LIST
50818: LIST
50819: LIST
50820: LIST
50821: LIST
50822: LIST
50823: LIST
50824: LIST
50825: LIST
50826: LIST
50827: LIST
50828: LIST
50829: LIST
50830: LIST
50831: LIST
50832: LIST
50833: LIST
50834: LIST
50835: LIST
50836: LIST
50837: LIST
50838: LIST
50839: LIST
50840: LIST
50841: LIST
50842: LIST
50843: LIST
50844: LIST
50845: LIST
50846: ST_TO_ADDR
// end ; end ;
50847: GO 50850
50849: POP
// case btype of b_depot , b_warehouse :
50850: LD_VAR 0 1
50854: PUSH
50855: LD_INT 0
50857: DOUBLE
50858: EQUAL
50859: IFTRUE 50869
50861: LD_INT 1
50863: DOUBLE
50864: EQUAL
50865: IFTRUE 50869
50867: GO 51070
50869: POP
// case nation of nation_american :
50870: LD_VAR 0 5
50874: PUSH
50875: LD_INT 1
50877: DOUBLE
50878: EQUAL
50879: IFTRUE 50883
50881: GO 50939
50883: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
50884: LD_ADDR_VAR 0 9
50888: PUSH
50889: LD_VAR 0 11
50893: PUSH
50894: LD_VAR 0 12
50898: PUSH
50899: LD_VAR 0 13
50903: PUSH
50904: LD_VAR 0 14
50908: PUSH
50909: LD_VAR 0 15
50913: PUSH
50914: LD_VAR 0 16
50918: PUSH
50919: EMPTY
50920: LIST
50921: LIST
50922: LIST
50923: LIST
50924: LIST
50925: LIST
50926: PUSH
50927: LD_VAR 0 4
50931: PUSH
50932: LD_INT 1
50934: PLUS
50935: ARRAY
50936: ST_TO_ADDR
50937: GO 51068
50939: LD_INT 2
50941: DOUBLE
50942: EQUAL
50943: IFTRUE 50947
50945: GO 51003
50947: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
50948: LD_ADDR_VAR 0 9
50952: PUSH
50953: LD_VAR 0 17
50957: PUSH
50958: LD_VAR 0 18
50962: PUSH
50963: LD_VAR 0 19
50967: PUSH
50968: LD_VAR 0 20
50972: PUSH
50973: LD_VAR 0 21
50977: PUSH
50978: LD_VAR 0 22
50982: PUSH
50983: EMPTY
50984: LIST
50985: LIST
50986: LIST
50987: LIST
50988: LIST
50989: LIST
50990: PUSH
50991: LD_VAR 0 4
50995: PUSH
50996: LD_INT 1
50998: PLUS
50999: ARRAY
51000: ST_TO_ADDR
51001: GO 51068
51003: LD_INT 3
51005: DOUBLE
51006: EQUAL
51007: IFTRUE 51011
51009: GO 51067
51011: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
51012: LD_ADDR_VAR 0 9
51016: PUSH
51017: LD_VAR 0 23
51021: PUSH
51022: LD_VAR 0 24
51026: PUSH
51027: LD_VAR 0 25
51031: PUSH
51032: LD_VAR 0 26
51036: PUSH
51037: LD_VAR 0 27
51041: PUSH
51042: LD_VAR 0 28
51046: PUSH
51047: EMPTY
51048: LIST
51049: LIST
51050: LIST
51051: LIST
51052: LIST
51053: LIST
51054: PUSH
51055: LD_VAR 0 4
51059: PUSH
51060: LD_INT 1
51062: PLUS
51063: ARRAY
51064: ST_TO_ADDR
51065: GO 51068
51067: POP
51068: GO 51623
51070: LD_INT 2
51072: DOUBLE
51073: EQUAL
51074: IFTRUE 51084
51076: LD_INT 3
51078: DOUBLE
51079: EQUAL
51080: IFTRUE 51084
51082: GO 51140
51084: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
51085: LD_ADDR_VAR 0 9
51089: PUSH
51090: LD_VAR 0 29
51094: PUSH
51095: LD_VAR 0 30
51099: PUSH
51100: LD_VAR 0 31
51104: PUSH
51105: LD_VAR 0 32
51109: PUSH
51110: LD_VAR 0 33
51114: PUSH
51115: LD_VAR 0 34
51119: PUSH
51120: EMPTY
51121: LIST
51122: LIST
51123: LIST
51124: LIST
51125: LIST
51126: LIST
51127: PUSH
51128: LD_VAR 0 4
51132: PUSH
51133: LD_INT 1
51135: PLUS
51136: ARRAY
51137: ST_TO_ADDR
51138: GO 51623
51140: LD_INT 16
51142: DOUBLE
51143: EQUAL
51144: IFTRUE 51202
51146: LD_INT 17
51148: DOUBLE
51149: EQUAL
51150: IFTRUE 51202
51152: LD_INT 18
51154: DOUBLE
51155: EQUAL
51156: IFTRUE 51202
51158: LD_INT 19
51160: DOUBLE
51161: EQUAL
51162: IFTRUE 51202
51164: LD_INT 22
51166: DOUBLE
51167: EQUAL
51168: IFTRUE 51202
51170: LD_INT 20
51172: DOUBLE
51173: EQUAL
51174: IFTRUE 51202
51176: LD_INT 21
51178: DOUBLE
51179: EQUAL
51180: IFTRUE 51202
51182: LD_INT 23
51184: DOUBLE
51185: EQUAL
51186: IFTRUE 51202
51188: LD_INT 24
51190: DOUBLE
51191: EQUAL
51192: IFTRUE 51202
51194: LD_INT 25
51196: DOUBLE
51197: EQUAL
51198: IFTRUE 51202
51200: GO 51258
51202: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
51203: LD_ADDR_VAR 0 9
51207: PUSH
51208: LD_VAR 0 35
51212: PUSH
51213: LD_VAR 0 36
51217: PUSH
51218: LD_VAR 0 37
51222: PUSH
51223: LD_VAR 0 38
51227: PUSH
51228: LD_VAR 0 39
51232: PUSH
51233: LD_VAR 0 40
51237: PUSH
51238: EMPTY
51239: LIST
51240: LIST
51241: LIST
51242: LIST
51243: LIST
51244: LIST
51245: PUSH
51246: LD_VAR 0 4
51250: PUSH
51251: LD_INT 1
51253: PLUS
51254: ARRAY
51255: ST_TO_ADDR
51256: GO 51623
51258: LD_INT 6
51260: DOUBLE
51261: EQUAL
51262: IFTRUE 51314
51264: LD_INT 7
51266: DOUBLE
51267: EQUAL
51268: IFTRUE 51314
51270: LD_INT 8
51272: DOUBLE
51273: EQUAL
51274: IFTRUE 51314
51276: LD_INT 13
51278: DOUBLE
51279: EQUAL
51280: IFTRUE 51314
51282: LD_INT 12
51284: DOUBLE
51285: EQUAL
51286: IFTRUE 51314
51288: LD_INT 15
51290: DOUBLE
51291: EQUAL
51292: IFTRUE 51314
51294: LD_INT 11
51296: DOUBLE
51297: EQUAL
51298: IFTRUE 51314
51300: LD_INT 14
51302: DOUBLE
51303: EQUAL
51304: IFTRUE 51314
51306: LD_INT 10
51308: DOUBLE
51309: EQUAL
51310: IFTRUE 51314
51312: GO 51370
51314: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
51315: LD_ADDR_VAR 0 9
51319: PUSH
51320: LD_VAR 0 41
51324: PUSH
51325: LD_VAR 0 42
51329: PUSH
51330: LD_VAR 0 43
51334: PUSH
51335: LD_VAR 0 44
51339: PUSH
51340: LD_VAR 0 45
51344: PUSH
51345: LD_VAR 0 46
51349: PUSH
51350: EMPTY
51351: LIST
51352: LIST
51353: LIST
51354: LIST
51355: LIST
51356: LIST
51357: PUSH
51358: LD_VAR 0 4
51362: PUSH
51363: LD_INT 1
51365: PLUS
51366: ARRAY
51367: ST_TO_ADDR
51368: GO 51623
51370: LD_INT 36
51372: DOUBLE
51373: EQUAL
51374: IFTRUE 51378
51376: GO 51434
51378: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
51379: LD_ADDR_VAR 0 9
51383: PUSH
51384: LD_VAR 0 47
51388: PUSH
51389: LD_VAR 0 48
51393: PUSH
51394: LD_VAR 0 49
51398: PUSH
51399: LD_VAR 0 50
51403: PUSH
51404: LD_VAR 0 51
51408: PUSH
51409: LD_VAR 0 52
51413: PUSH
51414: EMPTY
51415: LIST
51416: LIST
51417: LIST
51418: LIST
51419: LIST
51420: LIST
51421: PUSH
51422: LD_VAR 0 4
51426: PUSH
51427: LD_INT 1
51429: PLUS
51430: ARRAY
51431: ST_TO_ADDR
51432: GO 51623
51434: LD_INT 4
51436: DOUBLE
51437: EQUAL
51438: IFTRUE 51460
51440: LD_INT 5
51442: DOUBLE
51443: EQUAL
51444: IFTRUE 51460
51446: LD_INT 34
51448: DOUBLE
51449: EQUAL
51450: IFTRUE 51460
51452: LD_INT 37
51454: DOUBLE
51455: EQUAL
51456: IFTRUE 51460
51458: GO 51516
51460: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
51461: LD_ADDR_VAR 0 9
51465: PUSH
51466: LD_VAR 0 53
51470: PUSH
51471: LD_VAR 0 54
51475: PUSH
51476: LD_VAR 0 55
51480: PUSH
51481: LD_VAR 0 56
51485: PUSH
51486: LD_VAR 0 57
51490: PUSH
51491: LD_VAR 0 58
51495: PUSH
51496: EMPTY
51497: LIST
51498: LIST
51499: LIST
51500: LIST
51501: LIST
51502: LIST
51503: PUSH
51504: LD_VAR 0 4
51508: PUSH
51509: LD_INT 1
51511: PLUS
51512: ARRAY
51513: ST_TO_ADDR
51514: GO 51623
51516: LD_INT 31
51518: DOUBLE
51519: EQUAL
51520: IFTRUE 51566
51522: LD_INT 32
51524: DOUBLE
51525: EQUAL
51526: IFTRUE 51566
51528: LD_INT 33
51530: DOUBLE
51531: EQUAL
51532: IFTRUE 51566
51534: LD_INT 27
51536: DOUBLE
51537: EQUAL
51538: IFTRUE 51566
51540: LD_INT 26
51542: DOUBLE
51543: EQUAL
51544: IFTRUE 51566
51546: LD_INT 28
51548: DOUBLE
51549: EQUAL
51550: IFTRUE 51566
51552: LD_INT 29
51554: DOUBLE
51555: EQUAL
51556: IFTRUE 51566
51558: LD_INT 30
51560: DOUBLE
51561: EQUAL
51562: IFTRUE 51566
51564: GO 51622
51566: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
51567: LD_ADDR_VAR 0 9
51571: PUSH
51572: LD_VAR 0 59
51576: PUSH
51577: LD_VAR 0 60
51581: PUSH
51582: LD_VAR 0 61
51586: PUSH
51587: LD_VAR 0 62
51591: PUSH
51592: LD_VAR 0 63
51596: PUSH
51597: LD_VAR 0 64
51601: PUSH
51602: EMPTY
51603: LIST
51604: LIST
51605: LIST
51606: LIST
51607: LIST
51608: LIST
51609: PUSH
51610: LD_VAR 0 4
51614: PUSH
51615: LD_INT 1
51617: PLUS
51618: ARRAY
51619: ST_TO_ADDR
51620: GO 51623
51622: POP
// temp_list2 = [ ] ;
51623: LD_ADDR_VAR 0 10
51627: PUSH
51628: EMPTY
51629: ST_TO_ADDR
// for i in temp_list do
51630: LD_ADDR_VAR 0 8
51634: PUSH
51635: LD_VAR 0 9
51639: PUSH
51640: FOR_IN
51641: IFFALSE 51693
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
51643: LD_ADDR_VAR 0 10
51647: PUSH
51648: LD_VAR 0 10
51652: PUSH
51653: LD_VAR 0 8
51657: PUSH
51658: LD_INT 1
51660: ARRAY
51661: PUSH
51662: LD_VAR 0 2
51666: PLUS
51667: PUSH
51668: LD_VAR 0 8
51672: PUSH
51673: LD_INT 2
51675: ARRAY
51676: PUSH
51677: LD_VAR 0 3
51681: PLUS
51682: PUSH
51683: EMPTY
51684: LIST
51685: LIST
51686: PUSH
51687: EMPTY
51688: LIST
51689: ADD
51690: ST_TO_ADDR
51691: GO 51640
51693: POP
51694: POP
// result = temp_list2 ;
51695: LD_ADDR_VAR 0 7
51699: PUSH
51700: LD_VAR 0 10
51704: ST_TO_ADDR
// end ;
51705: LD_VAR 0 7
51709: RET
// export function EnemyInRange ( unit , dist ) ; begin
51710: LD_INT 0
51712: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
51713: LD_ADDR_VAR 0 3
51717: PUSH
51718: LD_VAR 0 1
51722: PPUSH
51723: CALL_OW 255
51727: PPUSH
51728: LD_VAR 0 1
51732: PPUSH
51733: CALL_OW 250
51737: PPUSH
51738: LD_VAR 0 1
51742: PPUSH
51743: CALL_OW 251
51747: PPUSH
51748: LD_VAR 0 2
51752: PPUSH
51753: CALL 25106 0 4
51757: PUSH
51758: LD_INT 4
51760: ARRAY
51761: ST_TO_ADDR
// end ;
51762: LD_VAR 0 3
51766: RET
// export function PlayerSeeMe ( unit ) ; begin
51767: LD_INT 0
51769: PPUSH
// result := See ( your_side , unit ) ;
51770: LD_ADDR_VAR 0 2
51774: PUSH
51775: LD_OWVAR 2
51779: PPUSH
51780: LD_VAR 0 1
51784: PPUSH
51785: CALL_OW 292
51789: ST_TO_ADDR
// end ;
51790: LD_VAR 0 2
51794: RET
// export function ReverseDir ( unit ) ; begin
51795: LD_INT 0
51797: PPUSH
// if not unit then
51798: LD_VAR 0 1
51802: NOT
51803: IFFALSE 51807
// exit ;
51805: GO 51830
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
51807: LD_ADDR_VAR 0 2
51811: PUSH
51812: LD_VAR 0 1
51816: PPUSH
51817: CALL_OW 254
51821: PUSH
51822: LD_INT 3
51824: PLUS
51825: PUSH
51826: LD_INT 6
51828: MOD
51829: ST_TO_ADDR
// end ;
51830: LD_VAR 0 2
51834: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
51835: LD_INT 0
51837: PPUSH
51838: PPUSH
51839: PPUSH
51840: PPUSH
51841: PPUSH
// if not hexes then
51842: LD_VAR 0 2
51846: NOT
51847: IFFALSE 51851
// exit ;
51849: GO 51999
// dist := 9999 ;
51851: LD_ADDR_VAR 0 5
51855: PUSH
51856: LD_INT 9999
51858: ST_TO_ADDR
// for i = 1 to hexes do
51859: LD_ADDR_VAR 0 4
51863: PUSH
51864: DOUBLE
51865: LD_INT 1
51867: DEC
51868: ST_TO_ADDR
51869: LD_VAR 0 2
51873: PUSH
51874: FOR_TO
51875: IFFALSE 51987
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
51877: LD_VAR 0 1
51881: PPUSH
51882: LD_VAR 0 2
51886: PUSH
51887: LD_VAR 0 4
51891: ARRAY
51892: PUSH
51893: LD_INT 1
51895: ARRAY
51896: PPUSH
51897: LD_VAR 0 2
51901: PUSH
51902: LD_VAR 0 4
51906: ARRAY
51907: PUSH
51908: LD_INT 2
51910: ARRAY
51911: PPUSH
51912: CALL_OW 297
51916: PUSH
51917: LD_VAR 0 5
51921: LESS
51922: IFFALSE 51985
// begin hex := hexes [ i ] ;
51924: LD_ADDR_VAR 0 7
51928: PUSH
51929: LD_VAR 0 2
51933: PUSH
51934: LD_VAR 0 4
51938: ARRAY
51939: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
51940: LD_ADDR_VAR 0 5
51944: PUSH
51945: LD_VAR 0 1
51949: PPUSH
51950: LD_VAR 0 2
51954: PUSH
51955: LD_VAR 0 4
51959: ARRAY
51960: PUSH
51961: LD_INT 1
51963: ARRAY
51964: PPUSH
51965: LD_VAR 0 2
51969: PUSH
51970: LD_VAR 0 4
51974: ARRAY
51975: PUSH
51976: LD_INT 2
51978: ARRAY
51979: PPUSH
51980: CALL_OW 297
51984: ST_TO_ADDR
// end ; end ;
51985: GO 51874
51987: POP
51988: POP
// result := hex ;
51989: LD_ADDR_VAR 0 3
51993: PUSH
51994: LD_VAR 0 7
51998: ST_TO_ADDR
// end ;
51999: LD_VAR 0 3
52003: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
52004: LD_INT 0
52006: PPUSH
52007: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
52008: LD_VAR 0 1
52012: NOT
52013: PUSH
52014: LD_VAR 0 1
52018: PUSH
52019: LD_INT 21
52021: PUSH
52022: LD_INT 2
52024: PUSH
52025: EMPTY
52026: LIST
52027: LIST
52028: PUSH
52029: LD_INT 23
52031: PUSH
52032: LD_INT 2
52034: PUSH
52035: EMPTY
52036: LIST
52037: LIST
52038: PUSH
52039: EMPTY
52040: LIST
52041: LIST
52042: PPUSH
52043: CALL_OW 69
52047: IN
52048: NOT
52049: OR
52050: IFFALSE 52054
// exit ;
52052: GO 52101
// for i = 1 to 3 do
52054: LD_ADDR_VAR 0 3
52058: PUSH
52059: DOUBLE
52060: LD_INT 1
52062: DEC
52063: ST_TO_ADDR
52064: LD_INT 3
52066: PUSH
52067: FOR_TO
52068: IFFALSE 52099
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
52070: LD_VAR 0 1
52074: PPUSH
52075: CALL_OW 250
52079: PPUSH
52080: LD_VAR 0 1
52084: PPUSH
52085: CALL_OW 251
52089: PPUSH
52090: LD_INT 1
52092: PPUSH
52093: CALL_OW 453
52097: GO 52067
52099: POP
52100: POP
// end ;
52101: LD_VAR 0 2
52105: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
52106: LD_INT 0
52108: PPUSH
52109: PPUSH
52110: PPUSH
52111: PPUSH
52112: PPUSH
52113: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
52114: LD_VAR 0 1
52118: NOT
52119: PUSH
52120: LD_VAR 0 2
52124: NOT
52125: OR
52126: PUSH
52127: LD_VAR 0 1
52131: PPUSH
52132: CALL_OW 314
52136: OR
52137: IFFALSE 52141
// exit ;
52139: GO 52582
// x := GetX ( enemy_unit ) ;
52141: LD_ADDR_VAR 0 7
52145: PUSH
52146: LD_VAR 0 2
52150: PPUSH
52151: CALL_OW 250
52155: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
52156: LD_ADDR_VAR 0 8
52160: PUSH
52161: LD_VAR 0 2
52165: PPUSH
52166: CALL_OW 251
52170: ST_TO_ADDR
// if not x or not y then
52171: LD_VAR 0 7
52175: NOT
52176: PUSH
52177: LD_VAR 0 8
52181: NOT
52182: OR
52183: IFFALSE 52187
// exit ;
52185: GO 52582
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
52187: LD_ADDR_VAR 0 6
52191: PUSH
52192: LD_VAR 0 7
52196: PPUSH
52197: LD_INT 0
52199: PPUSH
52200: LD_INT 4
52202: PPUSH
52203: CALL_OW 272
52207: PUSH
52208: LD_VAR 0 8
52212: PPUSH
52213: LD_INT 0
52215: PPUSH
52216: LD_INT 4
52218: PPUSH
52219: CALL_OW 273
52223: PUSH
52224: EMPTY
52225: LIST
52226: LIST
52227: PUSH
52228: LD_VAR 0 7
52232: PPUSH
52233: LD_INT 1
52235: PPUSH
52236: LD_INT 4
52238: PPUSH
52239: CALL_OW 272
52243: PUSH
52244: LD_VAR 0 8
52248: PPUSH
52249: LD_INT 1
52251: PPUSH
52252: LD_INT 4
52254: PPUSH
52255: CALL_OW 273
52259: PUSH
52260: EMPTY
52261: LIST
52262: LIST
52263: PUSH
52264: LD_VAR 0 7
52268: PPUSH
52269: LD_INT 2
52271: PPUSH
52272: LD_INT 4
52274: PPUSH
52275: CALL_OW 272
52279: PUSH
52280: LD_VAR 0 8
52284: PPUSH
52285: LD_INT 2
52287: PPUSH
52288: LD_INT 4
52290: PPUSH
52291: CALL_OW 273
52295: PUSH
52296: EMPTY
52297: LIST
52298: LIST
52299: PUSH
52300: LD_VAR 0 7
52304: PPUSH
52305: LD_INT 3
52307: PPUSH
52308: LD_INT 4
52310: PPUSH
52311: CALL_OW 272
52315: PUSH
52316: LD_VAR 0 8
52320: PPUSH
52321: LD_INT 3
52323: PPUSH
52324: LD_INT 4
52326: PPUSH
52327: CALL_OW 273
52331: PUSH
52332: EMPTY
52333: LIST
52334: LIST
52335: PUSH
52336: LD_VAR 0 7
52340: PPUSH
52341: LD_INT 4
52343: PPUSH
52344: LD_INT 4
52346: PPUSH
52347: CALL_OW 272
52351: PUSH
52352: LD_VAR 0 8
52356: PPUSH
52357: LD_INT 4
52359: PPUSH
52360: LD_INT 4
52362: PPUSH
52363: CALL_OW 273
52367: PUSH
52368: EMPTY
52369: LIST
52370: LIST
52371: PUSH
52372: LD_VAR 0 7
52376: PPUSH
52377: LD_INT 5
52379: PPUSH
52380: LD_INT 4
52382: PPUSH
52383: CALL_OW 272
52387: PUSH
52388: LD_VAR 0 8
52392: PPUSH
52393: LD_INT 5
52395: PPUSH
52396: LD_INT 4
52398: PPUSH
52399: CALL_OW 273
52403: PUSH
52404: EMPTY
52405: LIST
52406: LIST
52407: PUSH
52408: EMPTY
52409: LIST
52410: LIST
52411: LIST
52412: LIST
52413: LIST
52414: LIST
52415: ST_TO_ADDR
// for i = tmp downto 1 do
52416: LD_ADDR_VAR 0 4
52420: PUSH
52421: DOUBLE
52422: LD_VAR 0 6
52426: INC
52427: ST_TO_ADDR
52428: LD_INT 1
52430: PUSH
52431: FOR_DOWNTO
52432: IFFALSE 52533
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
52434: LD_VAR 0 6
52438: PUSH
52439: LD_VAR 0 4
52443: ARRAY
52444: PUSH
52445: LD_INT 1
52447: ARRAY
52448: PPUSH
52449: LD_VAR 0 6
52453: PUSH
52454: LD_VAR 0 4
52458: ARRAY
52459: PUSH
52460: LD_INT 2
52462: ARRAY
52463: PPUSH
52464: CALL_OW 488
52468: NOT
52469: PUSH
52470: LD_VAR 0 6
52474: PUSH
52475: LD_VAR 0 4
52479: ARRAY
52480: PUSH
52481: LD_INT 1
52483: ARRAY
52484: PPUSH
52485: LD_VAR 0 6
52489: PUSH
52490: LD_VAR 0 4
52494: ARRAY
52495: PUSH
52496: LD_INT 2
52498: ARRAY
52499: PPUSH
52500: CALL_OW 428
52504: PUSH
52505: LD_INT 0
52507: NONEQUAL
52508: OR
52509: IFFALSE 52531
// tmp := Delete ( tmp , i ) ;
52511: LD_ADDR_VAR 0 6
52515: PUSH
52516: LD_VAR 0 6
52520: PPUSH
52521: LD_VAR 0 4
52525: PPUSH
52526: CALL_OW 3
52530: ST_TO_ADDR
52531: GO 52431
52533: POP
52534: POP
// j := GetClosestHex ( unit , tmp ) ;
52535: LD_ADDR_VAR 0 5
52539: PUSH
52540: LD_VAR 0 1
52544: PPUSH
52545: LD_VAR 0 6
52549: PPUSH
52550: CALL 51835 0 2
52554: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
52555: LD_VAR 0 1
52559: PPUSH
52560: LD_VAR 0 5
52564: PUSH
52565: LD_INT 1
52567: ARRAY
52568: PPUSH
52569: LD_VAR 0 5
52573: PUSH
52574: LD_INT 2
52576: ARRAY
52577: PPUSH
52578: CALL_OW 111
// end ;
52582: LD_VAR 0 3
52586: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
52587: LD_INT 0
52589: PPUSH
52590: PPUSH
52591: PPUSH
// uc_side = 0 ;
52592: LD_ADDR_OWVAR 20
52596: PUSH
52597: LD_INT 0
52599: ST_TO_ADDR
// uc_nation = 0 ;
52600: LD_ADDR_OWVAR 21
52604: PUSH
52605: LD_INT 0
52607: ST_TO_ADDR
// InitHc_All ( ) ;
52608: CALL_OW 584
// InitVc ;
52612: CALL_OW 20
// if mastodonts then
52616: LD_VAR 0 6
52620: IFFALSE 52687
// for i = 1 to mastodonts do
52622: LD_ADDR_VAR 0 11
52626: PUSH
52627: DOUBLE
52628: LD_INT 1
52630: DEC
52631: ST_TO_ADDR
52632: LD_VAR 0 6
52636: PUSH
52637: FOR_TO
52638: IFFALSE 52685
// begin vc_chassis := 31 ;
52640: LD_ADDR_OWVAR 37
52644: PUSH
52645: LD_INT 31
52647: ST_TO_ADDR
// vc_control := control_rider ;
52648: LD_ADDR_OWVAR 38
52652: PUSH
52653: LD_INT 4
52655: ST_TO_ADDR
// animal := CreateVehicle ;
52656: LD_ADDR_VAR 0 12
52660: PUSH
52661: CALL_OW 45
52665: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
52666: LD_VAR 0 12
52670: PPUSH
52671: LD_VAR 0 8
52675: PPUSH
52676: LD_INT 0
52678: PPUSH
52679: CALL 54875 0 3
// end ;
52683: GO 52637
52685: POP
52686: POP
// if horses then
52687: LD_VAR 0 5
52691: IFFALSE 52758
// for i = 1 to horses do
52693: LD_ADDR_VAR 0 11
52697: PUSH
52698: DOUBLE
52699: LD_INT 1
52701: DEC
52702: ST_TO_ADDR
52703: LD_VAR 0 5
52707: PUSH
52708: FOR_TO
52709: IFFALSE 52756
// begin hc_class := 21 ;
52711: LD_ADDR_OWVAR 28
52715: PUSH
52716: LD_INT 21
52718: ST_TO_ADDR
// hc_gallery :=  ;
52719: LD_ADDR_OWVAR 33
52723: PUSH
52724: LD_STRING 
52726: ST_TO_ADDR
// animal := CreateHuman ;
52727: LD_ADDR_VAR 0 12
52731: PUSH
52732: CALL_OW 44
52736: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
52737: LD_VAR 0 12
52741: PPUSH
52742: LD_VAR 0 8
52746: PPUSH
52747: LD_INT 0
52749: PPUSH
52750: CALL 54875 0 3
// end ;
52754: GO 52708
52756: POP
52757: POP
// if birds then
52758: LD_VAR 0 1
52762: IFFALSE 52829
// for i = 1 to birds do
52764: LD_ADDR_VAR 0 11
52768: PUSH
52769: DOUBLE
52770: LD_INT 1
52772: DEC
52773: ST_TO_ADDR
52774: LD_VAR 0 1
52778: PUSH
52779: FOR_TO
52780: IFFALSE 52827
// begin hc_class = 18 ;
52782: LD_ADDR_OWVAR 28
52786: PUSH
52787: LD_INT 18
52789: ST_TO_ADDR
// hc_gallery =  ;
52790: LD_ADDR_OWVAR 33
52794: PUSH
52795: LD_STRING 
52797: ST_TO_ADDR
// animal := CreateHuman ;
52798: LD_ADDR_VAR 0 12
52802: PUSH
52803: CALL_OW 44
52807: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
52808: LD_VAR 0 12
52812: PPUSH
52813: LD_VAR 0 8
52817: PPUSH
52818: LD_INT 0
52820: PPUSH
52821: CALL 54875 0 3
// end ;
52825: GO 52779
52827: POP
52828: POP
// if tigers then
52829: LD_VAR 0 2
52833: IFFALSE 52917
// for i = 1 to tigers do
52835: LD_ADDR_VAR 0 11
52839: PUSH
52840: DOUBLE
52841: LD_INT 1
52843: DEC
52844: ST_TO_ADDR
52845: LD_VAR 0 2
52849: PUSH
52850: FOR_TO
52851: IFFALSE 52915
// begin hc_class = class_tiger ;
52853: LD_ADDR_OWVAR 28
52857: PUSH
52858: LD_INT 14
52860: ST_TO_ADDR
// hc_gallery =  ;
52861: LD_ADDR_OWVAR 33
52865: PUSH
52866: LD_STRING 
52868: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
52869: LD_ADDR_OWVAR 35
52873: PUSH
52874: LD_INT 7
52876: NEG
52877: PPUSH
52878: LD_INT 7
52880: PPUSH
52881: CALL_OW 12
52885: ST_TO_ADDR
// animal := CreateHuman ;
52886: LD_ADDR_VAR 0 12
52890: PUSH
52891: CALL_OW 44
52895: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
52896: LD_VAR 0 12
52900: PPUSH
52901: LD_VAR 0 8
52905: PPUSH
52906: LD_INT 0
52908: PPUSH
52909: CALL 54875 0 3
// end ;
52913: GO 52850
52915: POP
52916: POP
// if apemans then
52917: LD_VAR 0 3
52921: IFFALSE 53044
// for i = 1 to apemans do
52923: LD_ADDR_VAR 0 11
52927: PUSH
52928: DOUBLE
52929: LD_INT 1
52931: DEC
52932: ST_TO_ADDR
52933: LD_VAR 0 3
52937: PUSH
52938: FOR_TO
52939: IFFALSE 53042
// begin hc_class = class_apeman ;
52941: LD_ADDR_OWVAR 28
52945: PUSH
52946: LD_INT 12
52948: ST_TO_ADDR
// hc_gallery =  ;
52949: LD_ADDR_OWVAR 33
52953: PUSH
52954: LD_STRING 
52956: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
52957: LD_ADDR_OWVAR 35
52961: PUSH
52962: LD_INT 2
52964: NEG
52965: PPUSH
52966: LD_INT 2
52968: PPUSH
52969: CALL_OW 12
52973: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
52974: LD_ADDR_OWVAR 31
52978: PUSH
52979: LD_INT 1
52981: PPUSH
52982: LD_INT 3
52984: PPUSH
52985: CALL_OW 12
52989: PUSH
52990: LD_INT 1
52992: PPUSH
52993: LD_INT 3
52995: PPUSH
52996: CALL_OW 12
53000: PUSH
53001: LD_INT 0
53003: PUSH
53004: LD_INT 0
53006: PUSH
53007: EMPTY
53008: LIST
53009: LIST
53010: LIST
53011: LIST
53012: ST_TO_ADDR
// animal := CreateHuman ;
53013: LD_ADDR_VAR 0 12
53017: PUSH
53018: CALL_OW 44
53022: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
53023: LD_VAR 0 12
53027: PPUSH
53028: LD_VAR 0 8
53032: PPUSH
53033: LD_INT 0
53035: PPUSH
53036: CALL 54875 0 3
// end ;
53040: GO 52938
53042: POP
53043: POP
// if enchidnas then
53044: LD_VAR 0 4
53048: IFFALSE 53115
// for i = 1 to enchidnas do
53050: LD_ADDR_VAR 0 11
53054: PUSH
53055: DOUBLE
53056: LD_INT 1
53058: DEC
53059: ST_TO_ADDR
53060: LD_VAR 0 4
53064: PUSH
53065: FOR_TO
53066: IFFALSE 53113
// begin hc_class = 13 ;
53068: LD_ADDR_OWVAR 28
53072: PUSH
53073: LD_INT 13
53075: ST_TO_ADDR
// hc_gallery =  ;
53076: LD_ADDR_OWVAR 33
53080: PUSH
53081: LD_STRING 
53083: ST_TO_ADDR
// animal := CreateHuman ;
53084: LD_ADDR_VAR 0 12
53088: PUSH
53089: CALL_OW 44
53093: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
53094: LD_VAR 0 12
53098: PPUSH
53099: LD_VAR 0 8
53103: PPUSH
53104: LD_INT 0
53106: PPUSH
53107: CALL 54875 0 3
// end ;
53111: GO 53065
53113: POP
53114: POP
// if fishes then
53115: LD_VAR 0 7
53119: IFFALSE 53186
// for i = 1 to fishes do
53121: LD_ADDR_VAR 0 11
53125: PUSH
53126: DOUBLE
53127: LD_INT 1
53129: DEC
53130: ST_TO_ADDR
53131: LD_VAR 0 7
53135: PUSH
53136: FOR_TO
53137: IFFALSE 53184
// begin hc_class = 20 ;
53139: LD_ADDR_OWVAR 28
53143: PUSH
53144: LD_INT 20
53146: ST_TO_ADDR
// hc_gallery =  ;
53147: LD_ADDR_OWVAR 33
53151: PUSH
53152: LD_STRING 
53154: ST_TO_ADDR
// animal := CreateHuman ;
53155: LD_ADDR_VAR 0 12
53159: PUSH
53160: CALL_OW 44
53164: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
53165: LD_VAR 0 12
53169: PPUSH
53170: LD_VAR 0 9
53174: PPUSH
53175: LD_INT 0
53177: PPUSH
53178: CALL 54875 0 3
// end ;
53182: GO 53136
53184: POP
53185: POP
// end ;
53186: LD_VAR 0 10
53190: RET
// export function WantHeal ( sci , unit ) ; begin
53191: LD_INT 0
53193: PPUSH
// if GetTaskList ( sci ) > 0 then
53194: LD_VAR 0 1
53198: PPUSH
53199: CALL_OW 437
53203: PUSH
53204: LD_INT 0
53206: GREATER
53207: IFFALSE 53277
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
53209: LD_VAR 0 1
53213: PPUSH
53214: CALL_OW 437
53218: PUSH
53219: LD_INT 1
53221: ARRAY
53222: PUSH
53223: LD_INT 1
53225: ARRAY
53226: PUSH
53227: LD_STRING l
53229: EQUAL
53230: PUSH
53231: LD_VAR 0 1
53235: PPUSH
53236: CALL_OW 437
53240: PUSH
53241: LD_INT 1
53243: ARRAY
53244: PUSH
53245: LD_INT 4
53247: ARRAY
53248: PUSH
53249: LD_VAR 0 2
53253: EQUAL
53254: AND
53255: IFFALSE 53267
// result := true else
53257: LD_ADDR_VAR 0 3
53261: PUSH
53262: LD_INT 1
53264: ST_TO_ADDR
53265: GO 53275
// result := false ;
53267: LD_ADDR_VAR 0 3
53271: PUSH
53272: LD_INT 0
53274: ST_TO_ADDR
// end else
53275: GO 53285
// result := false ;
53277: LD_ADDR_VAR 0 3
53281: PUSH
53282: LD_INT 0
53284: ST_TO_ADDR
// end ;
53285: LD_VAR 0 3
53289: RET
// export function HealTarget ( sci ) ; begin
53290: LD_INT 0
53292: PPUSH
// if not sci then
53293: LD_VAR 0 1
53297: NOT
53298: IFFALSE 53302
// exit ;
53300: GO 53367
// result := 0 ;
53302: LD_ADDR_VAR 0 2
53306: PUSH
53307: LD_INT 0
53309: ST_TO_ADDR
// if GetTaskList ( sci ) then
53310: LD_VAR 0 1
53314: PPUSH
53315: CALL_OW 437
53319: IFFALSE 53367
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
53321: LD_VAR 0 1
53325: PPUSH
53326: CALL_OW 437
53330: PUSH
53331: LD_INT 1
53333: ARRAY
53334: PUSH
53335: LD_INT 1
53337: ARRAY
53338: PUSH
53339: LD_STRING l
53341: EQUAL
53342: IFFALSE 53367
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
53344: LD_ADDR_VAR 0 2
53348: PUSH
53349: LD_VAR 0 1
53353: PPUSH
53354: CALL_OW 437
53358: PUSH
53359: LD_INT 1
53361: ARRAY
53362: PUSH
53363: LD_INT 4
53365: ARRAY
53366: ST_TO_ADDR
// end ;
53367: LD_VAR 0 2
53371: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
53372: LD_INT 0
53374: PPUSH
53375: PPUSH
53376: PPUSH
53377: PPUSH
// if not base_units then
53378: LD_VAR 0 1
53382: NOT
53383: IFFALSE 53387
// exit ;
53385: GO 53474
// result := false ;
53387: LD_ADDR_VAR 0 2
53391: PUSH
53392: LD_INT 0
53394: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
53395: LD_ADDR_VAR 0 5
53399: PUSH
53400: LD_VAR 0 1
53404: PPUSH
53405: LD_INT 21
53407: PUSH
53408: LD_INT 3
53410: PUSH
53411: EMPTY
53412: LIST
53413: LIST
53414: PPUSH
53415: CALL_OW 72
53419: ST_TO_ADDR
// if not tmp then
53420: LD_VAR 0 5
53424: NOT
53425: IFFALSE 53429
// exit ;
53427: GO 53474
// for i in tmp do
53429: LD_ADDR_VAR 0 3
53433: PUSH
53434: LD_VAR 0 5
53438: PUSH
53439: FOR_IN
53440: IFFALSE 53472
// begin result := EnemyInRange ( i , 22 ) ;
53442: LD_ADDR_VAR 0 2
53446: PUSH
53447: LD_VAR 0 3
53451: PPUSH
53452: LD_INT 22
53454: PPUSH
53455: CALL 51710 0 2
53459: ST_TO_ADDR
// if result then
53460: LD_VAR 0 2
53464: IFFALSE 53470
// exit ;
53466: POP
53467: POP
53468: GO 53474
// end ;
53470: GO 53439
53472: POP
53473: POP
// end ;
53474: LD_VAR 0 2
53478: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
53479: LD_INT 0
53481: PPUSH
53482: PPUSH
// if not units then
53483: LD_VAR 0 1
53487: NOT
53488: IFFALSE 53492
// exit ;
53490: GO 53562
// result := [ ] ;
53492: LD_ADDR_VAR 0 3
53496: PUSH
53497: EMPTY
53498: ST_TO_ADDR
// for i in units do
53499: LD_ADDR_VAR 0 4
53503: PUSH
53504: LD_VAR 0 1
53508: PUSH
53509: FOR_IN
53510: IFFALSE 53560
// if GetTag ( i ) = tag then
53512: LD_VAR 0 4
53516: PPUSH
53517: CALL_OW 110
53521: PUSH
53522: LD_VAR 0 2
53526: EQUAL
53527: IFFALSE 53558
// result := Replace ( result , result + 1 , i ) ;
53529: LD_ADDR_VAR 0 3
53533: PUSH
53534: LD_VAR 0 3
53538: PPUSH
53539: LD_VAR 0 3
53543: PUSH
53544: LD_INT 1
53546: PLUS
53547: PPUSH
53548: LD_VAR 0 4
53552: PPUSH
53553: CALL_OW 1
53557: ST_TO_ADDR
53558: GO 53509
53560: POP
53561: POP
// end ;
53562: LD_VAR 0 3
53566: RET
// export function IsDriver ( un ) ; begin
53567: LD_INT 0
53569: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
53570: LD_ADDR_VAR 0 2
53574: PUSH
53575: LD_VAR 0 1
53579: PUSH
53580: LD_INT 55
53582: PUSH
53583: EMPTY
53584: LIST
53585: PPUSH
53586: CALL_OW 69
53590: IN
53591: ST_TO_ADDR
// end ;
53592: LD_VAR 0 2
53596: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
53597: LD_INT 0
53599: PPUSH
53600: PPUSH
// list := [ ] ;
53601: LD_ADDR_VAR 0 5
53605: PUSH
53606: EMPTY
53607: ST_TO_ADDR
// case d of 0 :
53608: LD_VAR 0 3
53612: PUSH
53613: LD_INT 0
53615: DOUBLE
53616: EQUAL
53617: IFTRUE 53621
53619: GO 53754
53621: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
53622: LD_ADDR_VAR 0 5
53626: PUSH
53627: LD_VAR 0 1
53631: PUSH
53632: LD_INT 4
53634: MINUS
53635: PUSH
53636: LD_VAR 0 2
53640: PUSH
53641: LD_INT 4
53643: MINUS
53644: PUSH
53645: LD_INT 2
53647: PUSH
53648: EMPTY
53649: LIST
53650: LIST
53651: LIST
53652: PUSH
53653: LD_VAR 0 1
53657: PUSH
53658: LD_INT 3
53660: MINUS
53661: PUSH
53662: LD_VAR 0 2
53666: PUSH
53667: LD_INT 1
53669: PUSH
53670: EMPTY
53671: LIST
53672: LIST
53673: LIST
53674: PUSH
53675: LD_VAR 0 1
53679: PUSH
53680: LD_INT 4
53682: PLUS
53683: PUSH
53684: LD_VAR 0 2
53688: PUSH
53689: LD_INT 4
53691: PUSH
53692: EMPTY
53693: LIST
53694: LIST
53695: LIST
53696: PUSH
53697: LD_VAR 0 1
53701: PUSH
53702: LD_INT 3
53704: PLUS
53705: PUSH
53706: LD_VAR 0 2
53710: PUSH
53711: LD_INT 3
53713: PLUS
53714: PUSH
53715: LD_INT 5
53717: PUSH
53718: EMPTY
53719: LIST
53720: LIST
53721: LIST
53722: PUSH
53723: LD_VAR 0 1
53727: PUSH
53728: LD_VAR 0 2
53732: PUSH
53733: LD_INT 4
53735: PLUS
53736: PUSH
53737: LD_INT 0
53739: PUSH
53740: EMPTY
53741: LIST
53742: LIST
53743: LIST
53744: PUSH
53745: EMPTY
53746: LIST
53747: LIST
53748: LIST
53749: LIST
53750: LIST
53751: ST_TO_ADDR
// end ; 1 :
53752: GO 54452
53754: LD_INT 1
53756: DOUBLE
53757: EQUAL
53758: IFTRUE 53762
53760: GO 53895
53762: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
53763: LD_ADDR_VAR 0 5
53767: PUSH
53768: LD_VAR 0 1
53772: PUSH
53773: LD_VAR 0 2
53777: PUSH
53778: LD_INT 4
53780: MINUS
53781: PUSH
53782: LD_INT 3
53784: PUSH
53785: EMPTY
53786: LIST
53787: LIST
53788: LIST
53789: PUSH
53790: LD_VAR 0 1
53794: PUSH
53795: LD_INT 3
53797: MINUS
53798: PUSH
53799: LD_VAR 0 2
53803: PUSH
53804: LD_INT 3
53806: MINUS
53807: PUSH
53808: LD_INT 2
53810: PUSH
53811: EMPTY
53812: LIST
53813: LIST
53814: LIST
53815: PUSH
53816: LD_VAR 0 1
53820: PUSH
53821: LD_INT 4
53823: MINUS
53824: PUSH
53825: LD_VAR 0 2
53829: PUSH
53830: LD_INT 1
53832: PUSH
53833: EMPTY
53834: LIST
53835: LIST
53836: LIST
53837: PUSH
53838: LD_VAR 0 1
53842: PUSH
53843: LD_VAR 0 2
53847: PUSH
53848: LD_INT 3
53850: PLUS
53851: PUSH
53852: LD_INT 0
53854: PUSH
53855: EMPTY
53856: LIST
53857: LIST
53858: LIST
53859: PUSH
53860: LD_VAR 0 1
53864: PUSH
53865: LD_INT 4
53867: PLUS
53868: PUSH
53869: LD_VAR 0 2
53873: PUSH
53874: LD_INT 4
53876: PLUS
53877: PUSH
53878: LD_INT 5
53880: PUSH
53881: EMPTY
53882: LIST
53883: LIST
53884: LIST
53885: PUSH
53886: EMPTY
53887: LIST
53888: LIST
53889: LIST
53890: LIST
53891: LIST
53892: ST_TO_ADDR
// end ; 2 :
53893: GO 54452
53895: LD_INT 2
53897: DOUBLE
53898: EQUAL
53899: IFTRUE 53903
53901: GO 54032
53903: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
53904: LD_ADDR_VAR 0 5
53908: PUSH
53909: LD_VAR 0 1
53913: PUSH
53914: LD_VAR 0 2
53918: PUSH
53919: LD_INT 3
53921: MINUS
53922: PUSH
53923: LD_INT 3
53925: PUSH
53926: EMPTY
53927: LIST
53928: LIST
53929: LIST
53930: PUSH
53931: LD_VAR 0 1
53935: PUSH
53936: LD_INT 4
53938: PLUS
53939: PUSH
53940: LD_VAR 0 2
53944: PUSH
53945: LD_INT 4
53947: PUSH
53948: EMPTY
53949: LIST
53950: LIST
53951: LIST
53952: PUSH
53953: LD_VAR 0 1
53957: PUSH
53958: LD_VAR 0 2
53962: PUSH
53963: LD_INT 4
53965: PLUS
53966: PUSH
53967: LD_INT 0
53969: PUSH
53970: EMPTY
53971: LIST
53972: LIST
53973: LIST
53974: PUSH
53975: LD_VAR 0 1
53979: PUSH
53980: LD_INT 3
53982: MINUS
53983: PUSH
53984: LD_VAR 0 2
53988: PUSH
53989: LD_INT 1
53991: PUSH
53992: EMPTY
53993: LIST
53994: LIST
53995: LIST
53996: PUSH
53997: LD_VAR 0 1
54001: PUSH
54002: LD_INT 4
54004: MINUS
54005: PUSH
54006: LD_VAR 0 2
54010: PUSH
54011: LD_INT 4
54013: MINUS
54014: PUSH
54015: LD_INT 2
54017: PUSH
54018: EMPTY
54019: LIST
54020: LIST
54021: LIST
54022: PUSH
54023: EMPTY
54024: LIST
54025: LIST
54026: LIST
54027: LIST
54028: LIST
54029: ST_TO_ADDR
// end ; 3 :
54030: GO 54452
54032: LD_INT 3
54034: DOUBLE
54035: EQUAL
54036: IFTRUE 54040
54038: GO 54173
54040: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
54041: LD_ADDR_VAR 0 5
54045: PUSH
54046: LD_VAR 0 1
54050: PUSH
54051: LD_INT 3
54053: PLUS
54054: PUSH
54055: LD_VAR 0 2
54059: PUSH
54060: LD_INT 4
54062: PUSH
54063: EMPTY
54064: LIST
54065: LIST
54066: LIST
54067: PUSH
54068: LD_VAR 0 1
54072: PUSH
54073: LD_INT 4
54075: PLUS
54076: PUSH
54077: LD_VAR 0 2
54081: PUSH
54082: LD_INT 4
54084: PLUS
54085: PUSH
54086: LD_INT 5
54088: PUSH
54089: EMPTY
54090: LIST
54091: LIST
54092: LIST
54093: PUSH
54094: LD_VAR 0 1
54098: PUSH
54099: LD_INT 4
54101: MINUS
54102: PUSH
54103: LD_VAR 0 2
54107: PUSH
54108: LD_INT 1
54110: PUSH
54111: EMPTY
54112: LIST
54113: LIST
54114: LIST
54115: PUSH
54116: LD_VAR 0 1
54120: PUSH
54121: LD_VAR 0 2
54125: PUSH
54126: LD_INT 4
54128: MINUS
54129: PUSH
54130: LD_INT 3
54132: PUSH
54133: EMPTY
54134: LIST
54135: LIST
54136: LIST
54137: PUSH
54138: LD_VAR 0 1
54142: PUSH
54143: LD_INT 3
54145: MINUS
54146: PUSH
54147: LD_VAR 0 2
54151: PUSH
54152: LD_INT 3
54154: MINUS
54155: PUSH
54156: LD_INT 2
54158: PUSH
54159: EMPTY
54160: LIST
54161: LIST
54162: LIST
54163: PUSH
54164: EMPTY
54165: LIST
54166: LIST
54167: LIST
54168: LIST
54169: LIST
54170: ST_TO_ADDR
// end ; 4 :
54171: GO 54452
54173: LD_INT 4
54175: DOUBLE
54176: EQUAL
54177: IFTRUE 54181
54179: GO 54314
54181: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
54182: LD_ADDR_VAR 0 5
54186: PUSH
54187: LD_VAR 0 1
54191: PUSH
54192: LD_VAR 0 2
54196: PUSH
54197: LD_INT 4
54199: PLUS
54200: PUSH
54201: LD_INT 0
54203: PUSH
54204: EMPTY
54205: LIST
54206: LIST
54207: LIST
54208: PUSH
54209: LD_VAR 0 1
54213: PUSH
54214: LD_INT 3
54216: PLUS
54217: PUSH
54218: LD_VAR 0 2
54222: PUSH
54223: LD_INT 3
54225: PLUS
54226: PUSH
54227: LD_INT 5
54229: PUSH
54230: EMPTY
54231: LIST
54232: LIST
54233: LIST
54234: PUSH
54235: LD_VAR 0 1
54239: PUSH
54240: LD_INT 4
54242: PLUS
54243: PUSH
54244: LD_VAR 0 2
54248: PUSH
54249: LD_INT 4
54251: PUSH
54252: EMPTY
54253: LIST
54254: LIST
54255: LIST
54256: PUSH
54257: LD_VAR 0 1
54261: PUSH
54262: LD_VAR 0 2
54266: PUSH
54267: LD_INT 3
54269: MINUS
54270: PUSH
54271: LD_INT 3
54273: PUSH
54274: EMPTY
54275: LIST
54276: LIST
54277: LIST
54278: PUSH
54279: LD_VAR 0 1
54283: PUSH
54284: LD_INT 4
54286: MINUS
54287: PUSH
54288: LD_VAR 0 2
54292: PUSH
54293: LD_INT 4
54295: MINUS
54296: PUSH
54297: LD_INT 2
54299: PUSH
54300: EMPTY
54301: LIST
54302: LIST
54303: LIST
54304: PUSH
54305: EMPTY
54306: LIST
54307: LIST
54308: LIST
54309: LIST
54310: LIST
54311: ST_TO_ADDR
// end ; 5 :
54312: GO 54452
54314: LD_INT 5
54316: DOUBLE
54317: EQUAL
54318: IFTRUE 54322
54320: GO 54451
54322: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
54323: LD_ADDR_VAR 0 5
54327: PUSH
54328: LD_VAR 0 1
54332: PUSH
54333: LD_INT 4
54335: MINUS
54336: PUSH
54337: LD_VAR 0 2
54341: PUSH
54342: LD_INT 1
54344: PUSH
54345: EMPTY
54346: LIST
54347: LIST
54348: LIST
54349: PUSH
54350: LD_VAR 0 1
54354: PUSH
54355: LD_VAR 0 2
54359: PUSH
54360: LD_INT 4
54362: MINUS
54363: PUSH
54364: LD_INT 3
54366: PUSH
54367: EMPTY
54368: LIST
54369: LIST
54370: LIST
54371: PUSH
54372: LD_VAR 0 1
54376: PUSH
54377: LD_INT 4
54379: PLUS
54380: PUSH
54381: LD_VAR 0 2
54385: PUSH
54386: LD_INT 4
54388: PLUS
54389: PUSH
54390: LD_INT 5
54392: PUSH
54393: EMPTY
54394: LIST
54395: LIST
54396: LIST
54397: PUSH
54398: LD_VAR 0 1
54402: PUSH
54403: LD_INT 3
54405: PLUS
54406: PUSH
54407: LD_VAR 0 2
54411: PUSH
54412: LD_INT 4
54414: PUSH
54415: EMPTY
54416: LIST
54417: LIST
54418: LIST
54419: PUSH
54420: LD_VAR 0 1
54424: PUSH
54425: LD_VAR 0 2
54429: PUSH
54430: LD_INT 3
54432: PLUS
54433: PUSH
54434: LD_INT 0
54436: PUSH
54437: EMPTY
54438: LIST
54439: LIST
54440: LIST
54441: PUSH
54442: EMPTY
54443: LIST
54444: LIST
54445: LIST
54446: LIST
54447: LIST
54448: ST_TO_ADDR
// end ; end ;
54449: GO 54452
54451: POP
// result := list ;
54452: LD_ADDR_VAR 0 4
54456: PUSH
54457: LD_VAR 0 5
54461: ST_TO_ADDR
// end ;
54462: LD_VAR 0 4
54466: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
54467: LD_INT 0
54469: PPUSH
54470: PPUSH
54471: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
54472: LD_VAR 0 1
54476: NOT
54477: PUSH
54478: LD_VAR 0 2
54482: PUSH
54483: LD_INT 1
54485: PUSH
54486: LD_INT 2
54488: PUSH
54489: LD_INT 3
54491: PUSH
54492: LD_INT 4
54494: PUSH
54495: EMPTY
54496: LIST
54497: LIST
54498: LIST
54499: LIST
54500: IN
54501: NOT
54502: OR
54503: IFFALSE 54507
// exit ;
54505: GO 54599
// tmp := [ ] ;
54507: LD_ADDR_VAR 0 5
54511: PUSH
54512: EMPTY
54513: ST_TO_ADDR
// for i in units do
54514: LD_ADDR_VAR 0 4
54518: PUSH
54519: LD_VAR 0 1
54523: PUSH
54524: FOR_IN
54525: IFFALSE 54568
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
54527: LD_ADDR_VAR 0 5
54531: PUSH
54532: LD_VAR 0 5
54536: PPUSH
54537: LD_VAR 0 5
54541: PUSH
54542: LD_INT 1
54544: PLUS
54545: PPUSH
54546: LD_VAR 0 4
54550: PPUSH
54551: LD_VAR 0 2
54555: PPUSH
54556: CALL_OW 259
54560: PPUSH
54561: CALL_OW 2
54565: ST_TO_ADDR
54566: GO 54524
54568: POP
54569: POP
// if not tmp then
54570: LD_VAR 0 5
54574: NOT
54575: IFFALSE 54579
// exit ;
54577: GO 54599
// result := SortListByListDesc ( units , tmp ) ;
54579: LD_ADDR_VAR 0 3
54583: PUSH
54584: LD_VAR 0 1
54588: PPUSH
54589: LD_VAR 0 5
54593: PPUSH
54594: CALL_OW 77
54598: ST_TO_ADDR
// end ;
54599: LD_VAR 0 3
54603: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
54604: LD_INT 0
54606: PPUSH
54607: PPUSH
54608: PPUSH
// result := false ;
54609: LD_ADDR_VAR 0 3
54613: PUSH
54614: LD_INT 0
54616: ST_TO_ADDR
// x := GetX ( building ) ;
54617: LD_ADDR_VAR 0 4
54621: PUSH
54622: LD_VAR 0 2
54626: PPUSH
54627: CALL_OW 250
54631: ST_TO_ADDR
// y := GetY ( building ) ;
54632: LD_ADDR_VAR 0 5
54636: PUSH
54637: LD_VAR 0 2
54641: PPUSH
54642: CALL_OW 251
54646: ST_TO_ADDR
// if not building or not x or not y then
54647: LD_VAR 0 2
54651: NOT
54652: PUSH
54653: LD_VAR 0 4
54657: NOT
54658: OR
54659: PUSH
54660: LD_VAR 0 5
54664: NOT
54665: OR
54666: IFFALSE 54670
// exit ;
54668: GO 54762
// if GetTaskList ( unit ) then
54670: LD_VAR 0 1
54674: PPUSH
54675: CALL_OW 437
54679: IFFALSE 54762
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
54681: LD_STRING e
54683: PUSH
54684: LD_VAR 0 1
54688: PPUSH
54689: CALL_OW 437
54693: PUSH
54694: LD_INT 1
54696: ARRAY
54697: PUSH
54698: LD_INT 1
54700: ARRAY
54701: EQUAL
54702: PUSH
54703: LD_VAR 0 4
54707: PUSH
54708: LD_VAR 0 1
54712: PPUSH
54713: CALL_OW 437
54717: PUSH
54718: LD_INT 1
54720: ARRAY
54721: PUSH
54722: LD_INT 2
54724: ARRAY
54725: EQUAL
54726: AND
54727: PUSH
54728: LD_VAR 0 5
54732: PUSH
54733: LD_VAR 0 1
54737: PPUSH
54738: CALL_OW 437
54742: PUSH
54743: LD_INT 1
54745: ARRAY
54746: PUSH
54747: LD_INT 3
54749: ARRAY
54750: EQUAL
54751: AND
54752: IFFALSE 54762
// result := true end ;
54754: LD_ADDR_VAR 0 3
54758: PUSH
54759: LD_INT 1
54761: ST_TO_ADDR
// end ;
54762: LD_VAR 0 3
54766: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
54767: LD_INT 0
54769: PPUSH
// result := false ;
54770: LD_ADDR_VAR 0 4
54774: PUSH
54775: LD_INT 0
54777: ST_TO_ADDR
// if GetTaskList ( unit ) then
54778: LD_VAR 0 1
54782: PPUSH
54783: CALL_OW 437
54787: IFFALSE 54870
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
54789: LD_STRING M
54791: PUSH
54792: LD_VAR 0 1
54796: PPUSH
54797: CALL_OW 437
54801: PUSH
54802: LD_INT 1
54804: ARRAY
54805: PUSH
54806: LD_INT 1
54808: ARRAY
54809: EQUAL
54810: PUSH
54811: LD_VAR 0 2
54815: PUSH
54816: LD_VAR 0 1
54820: PPUSH
54821: CALL_OW 437
54825: PUSH
54826: LD_INT 1
54828: ARRAY
54829: PUSH
54830: LD_INT 2
54832: ARRAY
54833: EQUAL
54834: AND
54835: PUSH
54836: LD_VAR 0 3
54840: PUSH
54841: LD_VAR 0 1
54845: PPUSH
54846: CALL_OW 437
54850: PUSH
54851: LD_INT 1
54853: ARRAY
54854: PUSH
54855: LD_INT 3
54857: ARRAY
54858: EQUAL
54859: AND
54860: IFFALSE 54870
// result := true ;
54862: LD_ADDR_VAR 0 4
54866: PUSH
54867: LD_INT 1
54869: ST_TO_ADDR
// end ; end ;
54870: LD_VAR 0 4
54874: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
54875: LD_INT 0
54877: PPUSH
54878: PPUSH
54879: PPUSH
54880: PPUSH
// if not unit or not area then
54881: LD_VAR 0 1
54885: NOT
54886: PUSH
54887: LD_VAR 0 2
54891: NOT
54892: OR
54893: IFFALSE 54897
// exit ;
54895: GO 55061
// tmp := AreaToList ( area , i ) ;
54897: LD_ADDR_VAR 0 6
54901: PUSH
54902: LD_VAR 0 2
54906: PPUSH
54907: LD_VAR 0 5
54911: PPUSH
54912: CALL_OW 517
54916: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
54917: LD_ADDR_VAR 0 5
54921: PUSH
54922: DOUBLE
54923: LD_INT 1
54925: DEC
54926: ST_TO_ADDR
54927: LD_VAR 0 6
54931: PUSH
54932: LD_INT 1
54934: ARRAY
54935: PUSH
54936: FOR_TO
54937: IFFALSE 55059
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
54939: LD_ADDR_VAR 0 7
54943: PUSH
54944: LD_VAR 0 6
54948: PUSH
54949: LD_INT 1
54951: ARRAY
54952: PUSH
54953: LD_VAR 0 5
54957: ARRAY
54958: PUSH
54959: LD_VAR 0 6
54963: PUSH
54964: LD_INT 2
54966: ARRAY
54967: PUSH
54968: LD_VAR 0 5
54972: ARRAY
54973: PUSH
54974: EMPTY
54975: LIST
54976: LIST
54977: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
54978: LD_VAR 0 7
54982: PUSH
54983: LD_INT 1
54985: ARRAY
54986: PPUSH
54987: LD_VAR 0 7
54991: PUSH
54992: LD_INT 2
54994: ARRAY
54995: PPUSH
54996: CALL_OW 428
55000: PUSH
55001: LD_INT 0
55003: EQUAL
55004: IFFALSE 55057
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
55006: LD_VAR 0 1
55010: PPUSH
55011: LD_VAR 0 7
55015: PUSH
55016: LD_INT 1
55018: ARRAY
55019: PPUSH
55020: LD_VAR 0 7
55024: PUSH
55025: LD_INT 2
55027: ARRAY
55028: PPUSH
55029: LD_VAR 0 3
55033: PPUSH
55034: CALL_OW 48
// result := IsPlaced ( unit ) ;
55038: LD_ADDR_VAR 0 4
55042: PUSH
55043: LD_VAR 0 1
55047: PPUSH
55048: CALL_OW 305
55052: ST_TO_ADDR
// exit ;
55053: POP
55054: POP
55055: GO 55061
// end ; end ;
55057: GO 54936
55059: POP
55060: POP
// end ;
55061: LD_VAR 0 4
55065: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
55066: LD_INT 0
55068: PPUSH
55069: PPUSH
55070: PPUSH
// if not side or side > 8 then
55071: LD_VAR 0 1
55075: NOT
55076: PUSH
55077: LD_VAR 0 1
55081: PUSH
55082: LD_INT 8
55084: GREATER
55085: OR
55086: IFFALSE 55090
// exit ;
55088: GO 55277
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
55090: LD_ADDR_VAR 0 4
55094: PUSH
55095: LD_INT 22
55097: PUSH
55098: LD_VAR 0 1
55102: PUSH
55103: EMPTY
55104: LIST
55105: LIST
55106: PUSH
55107: LD_INT 21
55109: PUSH
55110: LD_INT 3
55112: PUSH
55113: EMPTY
55114: LIST
55115: LIST
55116: PUSH
55117: EMPTY
55118: LIST
55119: LIST
55120: PPUSH
55121: CALL_OW 69
55125: ST_TO_ADDR
// if not tmp then
55126: LD_VAR 0 4
55130: NOT
55131: IFFALSE 55135
// exit ;
55133: GO 55277
// enable_addtolog := true ;
55135: LD_ADDR_OWVAR 81
55139: PUSH
55140: LD_INT 1
55142: ST_TO_ADDR
// AddToLog ( [ ) ;
55143: LD_STRING [
55145: PPUSH
55146: CALL_OW 561
// for i in tmp do
55150: LD_ADDR_VAR 0 3
55154: PUSH
55155: LD_VAR 0 4
55159: PUSH
55160: FOR_IN
55161: IFFALSE 55268
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
55163: LD_STRING [
55165: PUSH
55166: LD_VAR 0 3
55170: PPUSH
55171: CALL_OW 266
55175: STR
55176: PUSH
55177: LD_STRING , 
55179: STR
55180: PUSH
55181: LD_VAR 0 3
55185: PPUSH
55186: CALL_OW 250
55190: STR
55191: PUSH
55192: LD_STRING , 
55194: STR
55195: PUSH
55196: LD_VAR 0 3
55200: PPUSH
55201: CALL_OW 251
55205: STR
55206: PUSH
55207: LD_STRING , 
55209: STR
55210: PUSH
55211: LD_VAR 0 3
55215: PPUSH
55216: CALL_OW 254
55220: STR
55221: PUSH
55222: LD_STRING , 
55224: STR
55225: PUSH
55226: LD_VAR 0 3
55230: PPUSH
55231: LD_INT 1
55233: PPUSH
55234: CALL_OW 268
55238: STR
55239: PUSH
55240: LD_STRING , 
55242: STR
55243: PUSH
55244: LD_VAR 0 3
55248: PPUSH
55249: LD_INT 2
55251: PPUSH
55252: CALL_OW 268
55256: STR
55257: PUSH
55258: LD_STRING ],
55260: STR
55261: PPUSH
55262: CALL_OW 561
// end ;
55266: GO 55160
55268: POP
55269: POP
// AddToLog ( ]; ) ;
55270: LD_STRING ];
55272: PPUSH
55273: CALL_OW 561
// end ;
55277: LD_VAR 0 2
55281: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
55282: LD_INT 0
55284: PPUSH
55285: PPUSH
55286: PPUSH
55287: PPUSH
55288: PPUSH
// if not area or not rate or not max then
55289: LD_VAR 0 1
55293: NOT
55294: PUSH
55295: LD_VAR 0 2
55299: NOT
55300: OR
55301: PUSH
55302: LD_VAR 0 4
55306: NOT
55307: OR
55308: IFFALSE 55312
// exit ;
55310: GO 55504
// while 1 do
55312: LD_INT 1
55314: IFFALSE 55504
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
55316: LD_ADDR_VAR 0 9
55320: PUSH
55321: LD_VAR 0 1
55325: PPUSH
55326: LD_INT 1
55328: PPUSH
55329: CALL_OW 287
55333: PUSH
55334: LD_INT 10
55336: MUL
55337: ST_TO_ADDR
// r := rate / 10 ;
55338: LD_ADDR_VAR 0 7
55342: PUSH
55343: LD_VAR 0 2
55347: PUSH
55348: LD_INT 10
55350: DIVREAL
55351: ST_TO_ADDR
// time := 1 1$00 ;
55352: LD_ADDR_VAR 0 8
55356: PUSH
55357: LD_INT 2100
55359: ST_TO_ADDR
// if amount < min then
55360: LD_VAR 0 9
55364: PUSH
55365: LD_VAR 0 3
55369: LESS
55370: IFFALSE 55388
// r := r * 2 else
55372: LD_ADDR_VAR 0 7
55376: PUSH
55377: LD_VAR 0 7
55381: PUSH
55382: LD_INT 2
55384: MUL
55385: ST_TO_ADDR
55386: GO 55414
// if amount > max then
55388: LD_VAR 0 9
55392: PUSH
55393: LD_VAR 0 4
55397: GREATER
55398: IFFALSE 55414
// r := r / 2 ;
55400: LD_ADDR_VAR 0 7
55404: PUSH
55405: LD_VAR 0 7
55409: PUSH
55410: LD_INT 2
55412: DIVREAL
55413: ST_TO_ADDR
// time := time / r ;
55414: LD_ADDR_VAR 0 8
55418: PUSH
55419: LD_VAR 0 8
55423: PUSH
55424: LD_VAR 0 7
55428: DIVREAL
55429: ST_TO_ADDR
// if time < 0 then
55430: LD_VAR 0 8
55434: PUSH
55435: LD_INT 0
55437: LESS
55438: IFFALSE 55455
// time := time * - 1 ;
55440: LD_ADDR_VAR 0 8
55444: PUSH
55445: LD_VAR 0 8
55449: PUSH
55450: LD_INT 1
55452: NEG
55453: MUL
55454: ST_TO_ADDR
// wait ( time ) ;
55455: LD_VAR 0 8
55459: PPUSH
55460: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
55464: LD_INT 35
55466: PPUSH
55467: LD_INT 875
55469: PPUSH
55470: CALL_OW 12
55474: PPUSH
55475: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
55479: LD_INT 1
55481: PPUSH
55482: LD_INT 5
55484: PPUSH
55485: CALL_OW 12
55489: PPUSH
55490: LD_VAR 0 1
55494: PPUSH
55495: LD_INT 1
55497: PPUSH
55498: CALL_OW 55
// end ;
55502: GO 55312
// end ;
55504: LD_VAR 0 5
55508: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
55509: LD_INT 0
55511: PPUSH
55512: PPUSH
55513: PPUSH
55514: PPUSH
55515: PPUSH
55516: PPUSH
55517: PPUSH
55518: PPUSH
// if not turrets or not factories then
55519: LD_VAR 0 1
55523: NOT
55524: PUSH
55525: LD_VAR 0 2
55529: NOT
55530: OR
55531: IFFALSE 55535
// exit ;
55533: GO 55842
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
55535: LD_ADDR_VAR 0 10
55539: PUSH
55540: LD_INT 5
55542: PUSH
55543: LD_INT 6
55545: PUSH
55546: EMPTY
55547: LIST
55548: LIST
55549: PUSH
55550: LD_INT 2
55552: PUSH
55553: LD_INT 4
55555: PUSH
55556: EMPTY
55557: LIST
55558: LIST
55559: PUSH
55560: LD_INT 3
55562: PUSH
55563: LD_INT 5
55565: PUSH
55566: EMPTY
55567: LIST
55568: LIST
55569: PUSH
55570: EMPTY
55571: LIST
55572: LIST
55573: LIST
55574: PUSH
55575: LD_INT 24
55577: PUSH
55578: LD_INT 25
55580: PUSH
55581: EMPTY
55582: LIST
55583: LIST
55584: PUSH
55585: LD_INT 23
55587: PUSH
55588: LD_INT 27
55590: PUSH
55591: EMPTY
55592: LIST
55593: LIST
55594: PUSH
55595: EMPTY
55596: LIST
55597: LIST
55598: PUSH
55599: LD_INT 42
55601: PUSH
55602: LD_INT 43
55604: PUSH
55605: EMPTY
55606: LIST
55607: LIST
55608: PUSH
55609: LD_INT 44
55611: PUSH
55612: LD_INT 46
55614: PUSH
55615: EMPTY
55616: LIST
55617: LIST
55618: PUSH
55619: LD_INT 45
55621: PUSH
55622: LD_INT 47
55624: PUSH
55625: EMPTY
55626: LIST
55627: LIST
55628: PUSH
55629: EMPTY
55630: LIST
55631: LIST
55632: LIST
55633: PUSH
55634: EMPTY
55635: LIST
55636: LIST
55637: LIST
55638: ST_TO_ADDR
// result := [ ] ;
55639: LD_ADDR_VAR 0 3
55643: PUSH
55644: EMPTY
55645: ST_TO_ADDR
// for i in turrets do
55646: LD_ADDR_VAR 0 4
55650: PUSH
55651: LD_VAR 0 1
55655: PUSH
55656: FOR_IN
55657: IFFALSE 55840
// begin nat := GetNation ( i ) ;
55659: LD_ADDR_VAR 0 7
55663: PUSH
55664: LD_VAR 0 4
55668: PPUSH
55669: CALL_OW 248
55673: ST_TO_ADDR
// weapon := 0 ;
55674: LD_ADDR_VAR 0 8
55678: PUSH
55679: LD_INT 0
55681: ST_TO_ADDR
// if not nat then
55682: LD_VAR 0 7
55686: NOT
55687: IFFALSE 55691
// continue ;
55689: GO 55656
// for j in list [ nat ] do
55691: LD_ADDR_VAR 0 5
55695: PUSH
55696: LD_VAR 0 10
55700: PUSH
55701: LD_VAR 0 7
55705: ARRAY
55706: PUSH
55707: FOR_IN
55708: IFFALSE 55749
// if GetBWeapon ( i ) = j [ 1 ] then
55710: LD_VAR 0 4
55714: PPUSH
55715: CALL_OW 269
55719: PUSH
55720: LD_VAR 0 5
55724: PUSH
55725: LD_INT 1
55727: ARRAY
55728: EQUAL
55729: IFFALSE 55747
// begin weapon := j [ 2 ] ;
55731: LD_ADDR_VAR 0 8
55735: PUSH
55736: LD_VAR 0 5
55740: PUSH
55741: LD_INT 2
55743: ARRAY
55744: ST_TO_ADDR
// break ;
55745: GO 55749
// end ;
55747: GO 55707
55749: POP
55750: POP
// if not weapon then
55751: LD_VAR 0 8
55755: NOT
55756: IFFALSE 55760
// continue ;
55758: GO 55656
// for k in factories do
55760: LD_ADDR_VAR 0 6
55764: PUSH
55765: LD_VAR 0 2
55769: PUSH
55770: FOR_IN
55771: IFFALSE 55836
// begin weapons := AvailableWeaponList ( k ) ;
55773: LD_ADDR_VAR 0 9
55777: PUSH
55778: LD_VAR 0 6
55782: PPUSH
55783: CALL_OW 478
55787: ST_TO_ADDR
// if not weapons then
55788: LD_VAR 0 9
55792: NOT
55793: IFFALSE 55797
// continue ;
55795: GO 55770
// if weapon in weapons then
55797: LD_VAR 0 8
55801: PUSH
55802: LD_VAR 0 9
55806: IN
55807: IFFALSE 55834
// begin result := [ i , weapon ] ;
55809: LD_ADDR_VAR 0 3
55813: PUSH
55814: LD_VAR 0 4
55818: PUSH
55819: LD_VAR 0 8
55823: PUSH
55824: EMPTY
55825: LIST
55826: LIST
55827: ST_TO_ADDR
// exit ;
55828: POP
55829: POP
55830: POP
55831: POP
55832: GO 55842
// end ; end ;
55834: GO 55770
55836: POP
55837: POP
// end ;
55838: GO 55656
55840: POP
55841: POP
// end ;
55842: LD_VAR 0 3
55846: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
55847: LD_INT 0
55849: PPUSH
// if not side or side > 8 then
55850: LD_VAR 0 3
55854: NOT
55855: PUSH
55856: LD_VAR 0 3
55860: PUSH
55861: LD_INT 8
55863: GREATER
55864: OR
55865: IFFALSE 55869
// exit ;
55867: GO 55928
// if not range then
55869: LD_VAR 0 4
55873: NOT
55874: IFFALSE 55885
// range := - 12 ;
55876: LD_ADDR_VAR 0 4
55880: PUSH
55881: LD_INT 12
55883: NEG
55884: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
55885: LD_VAR 0 1
55889: PPUSH
55890: LD_VAR 0 2
55894: PPUSH
55895: LD_VAR 0 3
55899: PPUSH
55900: LD_VAR 0 4
55904: PPUSH
55905: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
55909: LD_VAR 0 1
55913: PPUSH
55914: LD_VAR 0 2
55918: PPUSH
55919: LD_VAR 0 3
55923: PPUSH
55924: CALL_OW 331
// end ;
55928: LD_VAR 0 5
55932: RET
// export function Video ( mode ) ; begin
55933: LD_INT 0
55935: PPUSH
// ingame_video = mode ;
55936: LD_ADDR_OWVAR 52
55940: PUSH
55941: LD_VAR 0 1
55945: ST_TO_ADDR
// interface_hidden = mode ;
55946: LD_ADDR_OWVAR 54
55950: PUSH
55951: LD_VAR 0 1
55955: ST_TO_ADDR
// end ;
55956: LD_VAR 0 2
55960: RET
// export function Join ( array , element ) ; begin
55961: LD_INT 0
55963: PPUSH
// result := Replace ( array , array + 1 , element ) ;
55964: LD_ADDR_VAR 0 3
55968: PUSH
55969: LD_VAR 0 1
55973: PPUSH
55974: LD_VAR 0 1
55978: PUSH
55979: LD_INT 1
55981: PLUS
55982: PPUSH
55983: LD_VAR 0 2
55987: PPUSH
55988: CALL_OW 1
55992: ST_TO_ADDR
// end ;
55993: LD_VAR 0 3
55997: RET
// export function JoinUnion ( array , element ) ; begin
55998: LD_INT 0
56000: PPUSH
// result := array union element ;
56001: LD_ADDR_VAR 0 3
56005: PUSH
56006: LD_VAR 0 1
56010: PUSH
56011: LD_VAR 0 2
56015: UNION
56016: ST_TO_ADDR
// end ;
56017: LD_VAR 0 3
56021: RET
// export function GetBehemoths ( side ) ; begin
56022: LD_INT 0
56024: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
56025: LD_ADDR_VAR 0 2
56029: PUSH
56030: LD_INT 22
56032: PUSH
56033: LD_VAR 0 1
56037: PUSH
56038: EMPTY
56039: LIST
56040: LIST
56041: PUSH
56042: LD_INT 31
56044: PUSH
56045: LD_INT 25
56047: PUSH
56048: EMPTY
56049: LIST
56050: LIST
56051: PUSH
56052: EMPTY
56053: LIST
56054: LIST
56055: PPUSH
56056: CALL_OW 69
56060: ST_TO_ADDR
// end ;
56061: LD_VAR 0 2
56065: RET
// export function Shuffle ( array ) ; var i , index ; begin
56066: LD_INT 0
56068: PPUSH
56069: PPUSH
56070: PPUSH
// result := [ ] ;
56071: LD_ADDR_VAR 0 2
56075: PUSH
56076: EMPTY
56077: ST_TO_ADDR
// if not array then
56078: LD_VAR 0 1
56082: NOT
56083: IFFALSE 56087
// exit ;
56085: GO 56186
// Randomize ;
56087: CALL_OW 10
// for i = array downto 1 do
56091: LD_ADDR_VAR 0 3
56095: PUSH
56096: DOUBLE
56097: LD_VAR 0 1
56101: INC
56102: ST_TO_ADDR
56103: LD_INT 1
56105: PUSH
56106: FOR_DOWNTO
56107: IFFALSE 56184
// begin index := rand ( 1 , array ) ;
56109: LD_ADDR_VAR 0 4
56113: PUSH
56114: LD_INT 1
56116: PPUSH
56117: LD_VAR 0 1
56121: PPUSH
56122: CALL_OW 12
56126: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
56127: LD_ADDR_VAR 0 2
56131: PUSH
56132: LD_VAR 0 2
56136: PPUSH
56137: LD_VAR 0 2
56141: PUSH
56142: LD_INT 1
56144: PLUS
56145: PPUSH
56146: LD_VAR 0 1
56150: PUSH
56151: LD_VAR 0 4
56155: ARRAY
56156: PPUSH
56157: CALL_OW 2
56161: ST_TO_ADDR
// array := Delete ( array , index ) ;
56162: LD_ADDR_VAR 0 1
56166: PUSH
56167: LD_VAR 0 1
56171: PPUSH
56172: LD_VAR 0 4
56176: PPUSH
56177: CALL_OW 3
56181: ST_TO_ADDR
// end ;
56182: GO 56106
56184: POP
56185: POP
// end ;
56186: LD_VAR 0 2
56190: RET
// export function GetBaseMaterials ( base ) ; begin
56191: LD_INT 0
56193: PPUSH
// result := [ 0 , 0 , 0 ] ;
56194: LD_ADDR_VAR 0 2
56198: PUSH
56199: LD_INT 0
56201: PUSH
56202: LD_INT 0
56204: PUSH
56205: LD_INT 0
56207: PUSH
56208: EMPTY
56209: LIST
56210: LIST
56211: LIST
56212: ST_TO_ADDR
// if not base then
56213: LD_VAR 0 1
56217: NOT
56218: IFFALSE 56222
// exit ;
56220: GO 56271
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
56222: LD_ADDR_VAR 0 2
56226: PUSH
56227: LD_VAR 0 1
56231: PPUSH
56232: LD_INT 1
56234: PPUSH
56235: CALL_OW 275
56239: PUSH
56240: LD_VAR 0 1
56244: PPUSH
56245: LD_INT 2
56247: PPUSH
56248: CALL_OW 275
56252: PUSH
56253: LD_VAR 0 1
56257: PPUSH
56258: LD_INT 3
56260: PPUSH
56261: CALL_OW 275
56265: PUSH
56266: EMPTY
56267: LIST
56268: LIST
56269: LIST
56270: ST_TO_ADDR
// end ;
56271: LD_VAR 0 2
56275: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
56276: LD_INT 0
56278: PPUSH
56279: PPUSH
// result := array ;
56280: LD_ADDR_VAR 0 3
56284: PUSH
56285: LD_VAR 0 1
56289: ST_TO_ADDR
// if size > 0 then
56290: LD_VAR 0 2
56294: PUSH
56295: LD_INT 0
56297: GREATER
56298: IFFALSE 56344
// for i := array downto size do
56300: LD_ADDR_VAR 0 4
56304: PUSH
56305: DOUBLE
56306: LD_VAR 0 1
56310: INC
56311: ST_TO_ADDR
56312: LD_VAR 0 2
56316: PUSH
56317: FOR_DOWNTO
56318: IFFALSE 56342
// result := Delete ( result , result ) ;
56320: LD_ADDR_VAR 0 3
56324: PUSH
56325: LD_VAR 0 3
56329: PPUSH
56330: LD_VAR 0 3
56334: PPUSH
56335: CALL_OW 3
56339: ST_TO_ADDR
56340: GO 56317
56342: POP
56343: POP
// end ;
56344: LD_VAR 0 3
56348: RET
// export function ComExit ( unit ) ; var tmp ; begin
56349: LD_INT 0
56351: PPUSH
56352: PPUSH
// if not IsInUnit ( unit ) then
56353: LD_VAR 0 1
56357: PPUSH
56358: CALL_OW 310
56362: NOT
56363: IFFALSE 56367
// exit ;
56365: GO 56427
// tmp := IsInUnit ( unit ) ;
56367: LD_ADDR_VAR 0 3
56371: PUSH
56372: LD_VAR 0 1
56376: PPUSH
56377: CALL_OW 310
56381: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
56382: LD_VAR 0 3
56386: PPUSH
56387: CALL_OW 247
56391: PUSH
56392: LD_INT 2
56394: EQUAL
56395: IFFALSE 56408
// ComExitVehicle ( unit ) else
56397: LD_VAR 0 1
56401: PPUSH
56402: CALL_OW 121
56406: GO 56417
// ComExitBuilding ( unit ) ;
56408: LD_VAR 0 1
56412: PPUSH
56413: CALL_OW 122
// result := tmp ;
56417: LD_ADDR_VAR 0 2
56421: PUSH
56422: LD_VAR 0 3
56426: ST_TO_ADDR
// end ;
56427: LD_VAR 0 2
56431: RET
// export function ComExitAll ( units ) ; var i ; begin
56432: LD_INT 0
56434: PPUSH
56435: PPUSH
// if not units then
56436: LD_VAR 0 1
56440: NOT
56441: IFFALSE 56445
// exit ;
56443: GO 56471
// for i in units do
56445: LD_ADDR_VAR 0 3
56449: PUSH
56450: LD_VAR 0 1
56454: PUSH
56455: FOR_IN
56456: IFFALSE 56469
// ComExit ( i ) ;
56458: LD_VAR 0 3
56462: PPUSH
56463: CALL 56349 0 1
56467: GO 56455
56469: POP
56470: POP
// end ;
56471: LD_VAR 0 2
56475: RET
// export function ResetHc ; begin
56476: LD_INT 0
56478: PPUSH
// InitHc ;
56479: CALL_OW 19
// hc_importance := 0 ;
56483: LD_ADDR_OWVAR 32
56487: PUSH
56488: LD_INT 0
56490: ST_TO_ADDR
// end ;
56491: LD_VAR 0 1
56495: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
56496: LD_INT 0
56498: PPUSH
56499: PPUSH
56500: PPUSH
// _x := ( x1 + x2 ) div 2 ;
56501: LD_ADDR_VAR 0 6
56505: PUSH
56506: LD_VAR 0 1
56510: PUSH
56511: LD_VAR 0 3
56515: PLUS
56516: PUSH
56517: LD_INT 2
56519: DIV
56520: ST_TO_ADDR
// if _x < 0 then
56521: LD_VAR 0 6
56525: PUSH
56526: LD_INT 0
56528: LESS
56529: IFFALSE 56546
// _x := _x * - 1 ;
56531: LD_ADDR_VAR 0 6
56535: PUSH
56536: LD_VAR 0 6
56540: PUSH
56541: LD_INT 1
56543: NEG
56544: MUL
56545: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
56546: LD_ADDR_VAR 0 7
56550: PUSH
56551: LD_VAR 0 2
56555: PUSH
56556: LD_VAR 0 4
56560: PLUS
56561: PUSH
56562: LD_INT 2
56564: DIV
56565: ST_TO_ADDR
// if _y < 0 then
56566: LD_VAR 0 7
56570: PUSH
56571: LD_INT 0
56573: LESS
56574: IFFALSE 56591
// _y := _y * - 1 ;
56576: LD_ADDR_VAR 0 7
56580: PUSH
56581: LD_VAR 0 7
56585: PUSH
56586: LD_INT 1
56588: NEG
56589: MUL
56590: ST_TO_ADDR
// result := [ _x , _y ] ;
56591: LD_ADDR_VAR 0 5
56595: PUSH
56596: LD_VAR 0 6
56600: PUSH
56601: LD_VAR 0 7
56605: PUSH
56606: EMPTY
56607: LIST
56608: LIST
56609: ST_TO_ADDR
// end ;
56610: LD_VAR 0 5
56614: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
56615: LD_INT 0
56617: PPUSH
56618: PPUSH
56619: PPUSH
56620: PPUSH
// task := GetTaskList ( unit ) ;
56621: LD_ADDR_VAR 0 7
56625: PUSH
56626: LD_VAR 0 1
56630: PPUSH
56631: CALL_OW 437
56635: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
56636: LD_VAR 0 7
56640: NOT
56641: PUSH
56642: LD_VAR 0 1
56646: PPUSH
56647: LD_VAR 0 2
56651: PPUSH
56652: CALL_OW 308
56656: NOT
56657: AND
56658: IFFALSE 56662
// exit ;
56660: GO 56780
// if IsInArea ( unit , area ) then
56662: LD_VAR 0 1
56666: PPUSH
56667: LD_VAR 0 2
56671: PPUSH
56672: CALL_OW 308
56676: IFFALSE 56694
// begin ComMoveToArea ( unit , goAway ) ;
56678: LD_VAR 0 1
56682: PPUSH
56683: LD_VAR 0 3
56687: PPUSH
56688: CALL_OW 113
// exit ;
56692: GO 56780
// end ; if task [ 1 ] [ 1 ] <> M then
56694: LD_VAR 0 7
56698: PUSH
56699: LD_INT 1
56701: ARRAY
56702: PUSH
56703: LD_INT 1
56705: ARRAY
56706: PUSH
56707: LD_STRING M
56709: NONEQUAL
56710: IFFALSE 56714
// exit ;
56712: GO 56780
// x := task [ 1 ] [ 2 ] ;
56714: LD_ADDR_VAR 0 5
56718: PUSH
56719: LD_VAR 0 7
56723: PUSH
56724: LD_INT 1
56726: ARRAY
56727: PUSH
56728: LD_INT 2
56730: ARRAY
56731: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
56732: LD_ADDR_VAR 0 6
56736: PUSH
56737: LD_VAR 0 7
56741: PUSH
56742: LD_INT 1
56744: ARRAY
56745: PUSH
56746: LD_INT 3
56748: ARRAY
56749: ST_TO_ADDR
// if InArea ( x , y , area ) then
56750: LD_VAR 0 5
56754: PPUSH
56755: LD_VAR 0 6
56759: PPUSH
56760: LD_VAR 0 2
56764: PPUSH
56765: CALL_OW 309
56769: IFFALSE 56780
// ComStop ( unit ) ;
56771: LD_VAR 0 1
56775: PPUSH
56776: CALL_OW 141
// end ;
56780: LD_VAR 0 4
56784: RET
// export function Abs ( value ) ; begin
56785: LD_INT 0
56787: PPUSH
// result := value ;
56788: LD_ADDR_VAR 0 2
56792: PUSH
56793: LD_VAR 0 1
56797: ST_TO_ADDR
// if value < 0 then
56798: LD_VAR 0 1
56802: PUSH
56803: LD_INT 0
56805: LESS
56806: IFFALSE 56823
// result := value * - 1 ;
56808: LD_ADDR_VAR 0 2
56812: PUSH
56813: LD_VAR 0 1
56817: PUSH
56818: LD_INT 1
56820: NEG
56821: MUL
56822: ST_TO_ADDR
// end ;
56823: LD_VAR 0 2
56827: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
56828: LD_INT 0
56830: PPUSH
56831: PPUSH
56832: PPUSH
56833: PPUSH
56834: PPUSH
56835: PPUSH
56836: PPUSH
56837: PPUSH
// if not unit or not building then
56838: LD_VAR 0 1
56842: NOT
56843: PUSH
56844: LD_VAR 0 2
56848: NOT
56849: OR
56850: IFFALSE 56854
// exit ;
56852: GO 57080
// x := GetX ( building ) ;
56854: LD_ADDR_VAR 0 4
56858: PUSH
56859: LD_VAR 0 2
56863: PPUSH
56864: CALL_OW 250
56868: ST_TO_ADDR
// y := GetY ( building ) ;
56869: LD_ADDR_VAR 0 6
56873: PUSH
56874: LD_VAR 0 2
56878: PPUSH
56879: CALL_OW 251
56883: ST_TO_ADDR
// d := GetDir ( building ) ;
56884: LD_ADDR_VAR 0 8
56888: PUSH
56889: LD_VAR 0 2
56893: PPUSH
56894: CALL_OW 254
56898: ST_TO_ADDR
// r := 4 ;
56899: LD_ADDR_VAR 0 9
56903: PUSH
56904: LD_INT 4
56906: ST_TO_ADDR
// for i := 1 to 5 do
56907: LD_ADDR_VAR 0 10
56911: PUSH
56912: DOUBLE
56913: LD_INT 1
56915: DEC
56916: ST_TO_ADDR
56917: LD_INT 5
56919: PUSH
56920: FOR_TO
56921: IFFALSE 57078
// begin _x := ShiftX ( x , d , r + i ) ;
56923: LD_ADDR_VAR 0 5
56927: PUSH
56928: LD_VAR 0 4
56932: PPUSH
56933: LD_VAR 0 8
56937: PPUSH
56938: LD_VAR 0 9
56942: PUSH
56943: LD_VAR 0 10
56947: PLUS
56948: PPUSH
56949: CALL_OW 272
56953: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
56954: LD_ADDR_VAR 0 7
56958: PUSH
56959: LD_VAR 0 6
56963: PPUSH
56964: LD_VAR 0 8
56968: PPUSH
56969: LD_VAR 0 9
56973: PUSH
56974: LD_VAR 0 10
56978: PLUS
56979: PPUSH
56980: CALL_OW 273
56984: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
56985: LD_VAR 0 5
56989: PPUSH
56990: LD_VAR 0 7
56994: PPUSH
56995: CALL_OW 488
56999: PUSH
57000: LD_VAR 0 5
57004: PPUSH
57005: LD_VAR 0 7
57009: PPUSH
57010: CALL_OW 428
57014: PPUSH
57015: CALL_OW 247
57019: PUSH
57020: LD_INT 3
57022: PUSH
57023: LD_INT 2
57025: PUSH
57026: EMPTY
57027: LIST
57028: LIST
57029: IN
57030: NOT
57031: AND
57032: IFFALSE 57076
// begin ComMoveXY ( unit , _x , _y ) ;
57034: LD_VAR 0 1
57038: PPUSH
57039: LD_VAR 0 5
57043: PPUSH
57044: LD_VAR 0 7
57048: PPUSH
57049: CALL_OW 111
// result := [ _x , _y ] ;
57053: LD_ADDR_VAR 0 3
57057: PUSH
57058: LD_VAR 0 5
57062: PUSH
57063: LD_VAR 0 7
57067: PUSH
57068: EMPTY
57069: LIST
57070: LIST
57071: ST_TO_ADDR
// exit ;
57072: POP
57073: POP
57074: GO 57080
// end ; end ;
57076: GO 56920
57078: POP
57079: POP
// end ;
57080: LD_VAR 0 3
57084: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
57085: LD_INT 0
57087: PPUSH
57088: PPUSH
57089: PPUSH
// result := 0 ;
57090: LD_ADDR_VAR 0 3
57094: PUSH
57095: LD_INT 0
57097: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
57098: LD_VAR 0 1
57102: PUSH
57103: LD_INT 0
57105: LESS
57106: PUSH
57107: LD_VAR 0 1
57111: PUSH
57112: LD_INT 8
57114: GREATER
57115: OR
57116: PUSH
57117: LD_VAR 0 2
57121: PUSH
57122: LD_INT 0
57124: LESS
57125: OR
57126: PUSH
57127: LD_VAR 0 2
57131: PUSH
57132: LD_INT 8
57134: GREATER
57135: OR
57136: IFFALSE 57140
// exit ;
57138: GO 57215
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
57140: LD_ADDR_VAR 0 4
57144: PUSH
57145: LD_INT 22
57147: PUSH
57148: LD_VAR 0 2
57152: PUSH
57153: EMPTY
57154: LIST
57155: LIST
57156: PPUSH
57157: CALL_OW 69
57161: PUSH
57162: FOR_IN
57163: IFFALSE 57213
// begin un := UnitShoot ( i ) ;
57165: LD_ADDR_VAR 0 5
57169: PUSH
57170: LD_VAR 0 4
57174: PPUSH
57175: CALL_OW 504
57179: ST_TO_ADDR
// if GetSide ( un ) = side1 then
57180: LD_VAR 0 5
57184: PPUSH
57185: CALL_OW 255
57189: PUSH
57190: LD_VAR 0 1
57194: EQUAL
57195: IFFALSE 57211
// begin result := un ;
57197: LD_ADDR_VAR 0 3
57201: PUSH
57202: LD_VAR 0 5
57206: ST_TO_ADDR
// exit ;
57207: POP
57208: POP
57209: GO 57215
// end ; end ;
57211: GO 57162
57213: POP
57214: POP
// end ;
57215: LD_VAR 0 3
57219: RET
// export function GetCargoBay ( units ) ; begin
57220: LD_INT 0
57222: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
57223: LD_ADDR_VAR 0 2
57227: PUSH
57228: LD_VAR 0 1
57232: PPUSH
57233: LD_INT 2
57235: PUSH
57236: LD_INT 34
57238: PUSH
57239: LD_INT 12
57241: PUSH
57242: EMPTY
57243: LIST
57244: LIST
57245: PUSH
57246: LD_INT 34
57248: PUSH
57249: LD_INT 51
57251: PUSH
57252: EMPTY
57253: LIST
57254: LIST
57255: PUSH
57256: LD_INT 34
57258: PUSH
57259: LD_INT 32
57261: PUSH
57262: EMPTY
57263: LIST
57264: LIST
57265: PUSH
57266: LD_INT 34
57268: PUSH
57269: LD_EXP 158
57273: PUSH
57274: EMPTY
57275: LIST
57276: LIST
57277: PUSH
57278: EMPTY
57279: LIST
57280: LIST
57281: LIST
57282: LIST
57283: LIST
57284: PPUSH
57285: CALL_OW 72
57289: ST_TO_ADDR
// end ;
57290: LD_VAR 0 2
57294: RET
// export function Negate ( value ) ; begin
57295: LD_INT 0
57297: PPUSH
// result := not value ;
57298: LD_ADDR_VAR 0 2
57302: PUSH
57303: LD_VAR 0 1
57307: NOT
57308: ST_TO_ADDR
// end ;
57309: LD_VAR 0 2
57313: RET
// export function Inc ( value ) ; begin
57314: LD_INT 0
57316: PPUSH
// result := value + 1 ;
57317: LD_ADDR_VAR 0 2
57321: PUSH
57322: LD_VAR 0 1
57326: PUSH
57327: LD_INT 1
57329: PLUS
57330: ST_TO_ADDR
// end ;
57331: LD_VAR 0 2
57335: RET
// export function Dec ( value ) ; begin
57336: LD_INT 0
57338: PPUSH
// result := value - 1 ;
57339: LD_ADDR_VAR 0 2
57343: PUSH
57344: LD_VAR 0 1
57348: PUSH
57349: LD_INT 1
57351: MINUS
57352: ST_TO_ADDR
// end ;
57353: LD_VAR 0 2
57357: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; var i , _x , _y , tmp , distance , centerDist , centerPoint ; begin
57358: LD_INT 0
57360: PPUSH
57361: PPUSH
57362: PPUSH
57363: PPUSH
57364: PPUSH
57365: PPUSH
57366: PPUSH
57367: PPUSH
// if not ValidHex ( x1 , y1 ) or not ValidHex ( x2 , y2 ) then
57368: LD_VAR 0 1
57372: PPUSH
57373: LD_VAR 0 2
57377: PPUSH
57378: CALL_OW 488
57382: NOT
57383: PUSH
57384: LD_VAR 0 3
57388: PPUSH
57389: LD_VAR 0 4
57393: PPUSH
57394: CALL_OW 488
57398: NOT
57399: OR
57400: IFFALSE 57413
// begin result := - 1 ;
57402: LD_ADDR_VAR 0 5
57406: PUSH
57407: LD_INT 1
57409: NEG
57410: ST_TO_ADDR
// exit ;
57411: GO 57648
// end ; centerPoint := PointBetweenXY ( x1 , y1 , x2 , y2 ) ;
57413: LD_ADDR_VAR 0 12
57417: PUSH
57418: LD_VAR 0 1
57422: PPUSH
57423: LD_VAR 0 2
57427: PPUSH
57428: LD_VAR 0 3
57432: PPUSH
57433: LD_VAR 0 4
57437: PPUSH
57438: CALL 56496 0 4
57442: ST_TO_ADDR
// centerDist := GetDistXY ( x1 , y1 , centerPoint [ 1 ] , centerPoint [ 2 ] ) ;
57443: LD_ADDR_VAR 0 11
57447: PUSH
57448: LD_VAR 0 1
57452: PPUSH
57453: LD_VAR 0 2
57457: PPUSH
57458: LD_VAR 0 12
57462: PUSH
57463: LD_INT 1
57465: ARRAY
57466: PPUSH
57467: LD_VAR 0 12
57471: PUSH
57472: LD_INT 2
57474: ARRAY
57475: PPUSH
57476: CALL_OW 298
57480: ST_TO_ADDR
// distance := 9999 ;
57481: LD_ADDR_VAR 0 10
57485: PUSH
57486: LD_INT 9999
57488: ST_TO_ADDR
// for i := 0 to 5 do
57489: LD_ADDR_VAR 0 6
57493: PUSH
57494: DOUBLE
57495: LD_INT 0
57497: DEC
57498: ST_TO_ADDR
57499: LD_INT 5
57501: PUSH
57502: FOR_TO
57503: IFFALSE 57646
// begin _x := ShiftX ( x1 , i , centerDist ) ;
57505: LD_ADDR_VAR 0 7
57509: PUSH
57510: LD_VAR 0 1
57514: PPUSH
57515: LD_VAR 0 6
57519: PPUSH
57520: LD_VAR 0 11
57524: PPUSH
57525: CALL_OW 272
57529: ST_TO_ADDR
// _y := ShiftY ( y1 , i , centerDist ) ;
57530: LD_ADDR_VAR 0 8
57534: PUSH
57535: LD_VAR 0 2
57539: PPUSH
57540: LD_VAR 0 6
57544: PPUSH
57545: LD_VAR 0 11
57549: PPUSH
57550: CALL_OW 273
57554: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
57555: LD_VAR 0 7
57559: PPUSH
57560: LD_VAR 0 8
57564: PPUSH
57565: CALL_OW 488
57569: NOT
57570: IFFALSE 57574
// continue ;
57572: GO 57502
// tmp := GetDistXY ( centerPoint [ 1 ] , centerPoint [ 2 ] , _x , _y ) ;
57574: LD_ADDR_VAR 0 9
57578: PUSH
57579: LD_VAR 0 12
57583: PUSH
57584: LD_INT 1
57586: ARRAY
57587: PPUSH
57588: LD_VAR 0 12
57592: PUSH
57593: LD_INT 2
57595: ARRAY
57596: PPUSH
57597: LD_VAR 0 7
57601: PPUSH
57602: LD_VAR 0 8
57606: PPUSH
57607: CALL_OW 298
57611: ST_TO_ADDR
// if tmp < distance then
57612: LD_VAR 0 9
57616: PUSH
57617: LD_VAR 0 10
57621: LESS
57622: IFFALSE 57644
// begin result := i ;
57624: LD_ADDR_VAR 0 5
57628: PUSH
57629: LD_VAR 0 6
57633: ST_TO_ADDR
// distance := tmp ;
57634: LD_ADDR_VAR 0 10
57638: PUSH
57639: LD_VAR 0 9
57643: ST_TO_ADDR
// end ; end ;
57644: GO 57502
57646: POP
57647: POP
// end ;
57648: LD_VAR 0 5
57652: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
57653: LD_INT 0
57655: PPUSH
57656: PPUSH
// if not driver or not IsInUnit ( driver ) then
57657: LD_VAR 0 1
57661: NOT
57662: PUSH
57663: LD_VAR 0 1
57667: PPUSH
57668: CALL_OW 310
57672: NOT
57673: OR
57674: IFFALSE 57678
// exit ;
57676: GO 57768
// vehicle := IsInUnit ( driver ) ;
57678: LD_ADDR_VAR 0 3
57682: PUSH
57683: LD_VAR 0 1
57687: PPUSH
57688: CALL_OW 310
57692: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
57693: LD_VAR 0 1
57697: PPUSH
57698: LD_STRING \
57700: PUSH
57701: LD_INT 0
57703: PUSH
57704: LD_INT 0
57706: PUSH
57707: LD_INT 0
57709: PUSH
57710: LD_INT 0
57712: PUSH
57713: LD_INT 0
57715: PUSH
57716: LD_INT 0
57718: PUSH
57719: EMPTY
57720: LIST
57721: LIST
57722: LIST
57723: LIST
57724: LIST
57725: LIST
57726: LIST
57727: PUSH
57728: LD_STRING E
57730: PUSH
57731: LD_INT 0
57733: PUSH
57734: LD_INT 0
57736: PUSH
57737: LD_VAR 0 3
57741: PUSH
57742: LD_INT 0
57744: PUSH
57745: LD_INT 0
57747: PUSH
57748: LD_INT 0
57750: PUSH
57751: EMPTY
57752: LIST
57753: LIST
57754: LIST
57755: LIST
57756: LIST
57757: LIST
57758: LIST
57759: PUSH
57760: EMPTY
57761: LIST
57762: LIST
57763: PPUSH
57764: CALL_OW 446
// end ;
57768: LD_VAR 0 2
57772: RET
// export function AddComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
57773: LD_INT 0
57775: PPUSH
57776: PPUSH
// if not driver or not IsInUnit ( driver ) then
57777: LD_VAR 0 1
57781: NOT
57782: PUSH
57783: LD_VAR 0 1
57787: PPUSH
57788: CALL_OW 310
57792: NOT
57793: OR
57794: IFFALSE 57798
// exit ;
57796: GO 57888
// vehicle := IsInUnit ( driver ) ;
57798: LD_ADDR_VAR 0 3
57802: PUSH
57803: LD_VAR 0 1
57807: PPUSH
57808: CALL_OW 310
57812: ST_TO_ADDR
// AddTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
57813: LD_VAR 0 1
57817: PPUSH
57818: LD_STRING \
57820: PUSH
57821: LD_INT 0
57823: PUSH
57824: LD_INT 0
57826: PUSH
57827: LD_INT 0
57829: PUSH
57830: LD_INT 0
57832: PUSH
57833: LD_INT 0
57835: PUSH
57836: LD_INT 0
57838: PUSH
57839: EMPTY
57840: LIST
57841: LIST
57842: LIST
57843: LIST
57844: LIST
57845: LIST
57846: LIST
57847: PUSH
57848: LD_STRING E
57850: PUSH
57851: LD_INT 0
57853: PUSH
57854: LD_INT 0
57856: PUSH
57857: LD_VAR 0 3
57861: PUSH
57862: LD_INT 0
57864: PUSH
57865: LD_INT 0
57867: PUSH
57868: LD_INT 0
57870: PUSH
57871: EMPTY
57872: LIST
57873: LIST
57874: LIST
57875: LIST
57876: LIST
57877: LIST
57878: LIST
57879: PUSH
57880: EMPTY
57881: LIST
57882: LIST
57883: PPUSH
57884: CALL_OW 447
// end ;
57888: LD_VAR 0 2
57892: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
57893: LD_INT 0
57895: PPUSH
57896: PPUSH
57897: PPUSH
// tmp := [ ] ;
57898: LD_ADDR_VAR 0 5
57902: PUSH
57903: EMPTY
57904: ST_TO_ADDR
// for i in units do
57905: LD_ADDR_VAR 0 4
57909: PUSH
57910: LD_VAR 0 1
57914: PUSH
57915: FOR_IN
57916: IFFALSE 57954
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
57918: LD_ADDR_VAR 0 5
57922: PUSH
57923: LD_VAR 0 5
57927: PPUSH
57928: LD_VAR 0 5
57932: PUSH
57933: LD_INT 1
57935: PLUS
57936: PPUSH
57937: LD_VAR 0 4
57941: PPUSH
57942: CALL_OW 256
57946: PPUSH
57947: CALL_OW 2
57951: ST_TO_ADDR
57952: GO 57915
57954: POP
57955: POP
// if not tmp then
57956: LD_VAR 0 5
57960: NOT
57961: IFFALSE 57965
// exit ;
57963: GO 58013
// if asc then
57965: LD_VAR 0 2
57969: IFFALSE 57993
// result := SortListByListAsc ( units , tmp ) else
57971: LD_ADDR_VAR 0 3
57975: PUSH
57976: LD_VAR 0 1
57980: PPUSH
57981: LD_VAR 0 5
57985: PPUSH
57986: CALL_OW 76
57990: ST_TO_ADDR
57991: GO 58013
// result := SortListByListDesc ( units , tmp ) ;
57993: LD_ADDR_VAR 0 3
57997: PUSH
57998: LD_VAR 0 1
58002: PPUSH
58003: LD_VAR 0 5
58007: PPUSH
58008: CALL_OW 77
58012: ST_TO_ADDR
// end ;
58013: LD_VAR 0 3
58017: RET
// export function WantToRepairVehicle ( mech , vehicle ) ; var task ; begin
58018: LD_INT 0
58020: PPUSH
58021: PPUSH
// task := GetTaskList ( mech ) ;
58022: LD_ADDR_VAR 0 4
58026: PUSH
58027: LD_VAR 0 1
58031: PPUSH
58032: CALL_OW 437
58036: ST_TO_ADDR
// if not task then
58037: LD_VAR 0 4
58041: NOT
58042: IFFALSE 58046
// exit ;
58044: GO 58088
// result := task [ 1 ] [ 1 ] = r and task [ 1 ] [ 4 ] = vehicle ;
58046: LD_ADDR_VAR 0 3
58050: PUSH
58051: LD_VAR 0 4
58055: PUSH
58056: LD_INT 1
58058: ARRAY
58059: PUSH
58060: LD_INT 1
58062: ARRAY
58063: PUSH
58064: LD_STRING r
58066: EQUAL
58067: PUSH
58068: LD_VAR 0 4
58072: PUSH
58073: LD_INT 1
58075: ARRAY
58076: PUSH
58077: LD_INT 4
58079: ARRAY
58080: PUSH
58081: LD_VAR 0 2
58085: EQUAL
58086: AND
58087: ST_TO_ADDR
// end ;
58088: LD_VAR 0 3
58092: RET
// export function PlaceUnitXYD ( unit , x , y , d , mode ) ; begin
58093: LD_INT 0
58095: PPUSH
// SetDir ( unit , d ) ;
58096: LD_VAR 0 1
58100: PPUSH
58101: LD_VAR 0 4
58105: PPUSH
58106: CALL_OW 233
// PlaceUnitXY ( unit , x , y , mode ) ;
58110: LD_VAR 0 1
58114: PPUSH
58115: LD_VAR 0 2
58119: PPUSH
58120: LD_VAR 0 3
58124: PPUSH
58125: LD_VAR 0 5
58129: PPUSH
58130: CALL_OW 48
// end ;
58134: LD_VAR 0 6
58138: RET
// export function ToNaturalNumber ( number ) ; begin
58139: LD_INT 0
58141: PPUSH
// result := number div 1 ;
58142: LD_ADDR_VAR 0 2
58146: PUSH
58147: LD_VAR 0 1
58151: PUSH
58152: LD_INT 1
58154: DIV
58155: ST_TO_ADDR
// if number < 0 then
58156: LD_VAR 0 1
58160: PUSH
58161: LD_INT 0
58163: LESS
58164: IFFALSE 58174
// result := 0 ;
58166: LD_ADDR_VAR 0 2
58170: PUSH
58171: LD_INT 0
58173: ST_TO_ADDR
// end ;
58174: LD_VAR 0 2
58178: RET
// export function SortByClass ( units , class ) ; var un ; begin
58179: LD_INT 0
58181: PPUSH
58182: PPUSH
// if not units or not class then
58183: LD_VAR 0 1
58187: NOT
58188: PUSH
58189: LD_VAR 0 2
58193: NOT
58194: OR
58195: IFFALSE 58199
// exit ;
58197: GO 58294
// result := [ ] ;
58199: LD_ADDR_VAR 0 3
58203: PUSH
58204: EMPTY
58205: ST_TO_ADDR
// for un in units do
58206: LD_ADDR_VAR 0 4
58210: PUSH
58211: LD_VAR 0 1
58215: PUSH
58216: FOR_IN
58217: IFFALSE 58292
// if GetClass ( un ) = class then
58219: LD_VAR 0 4
58223: PPUSH
58224: CALL_OW 257
58228: PUSH
58229: LD_VAR 0 2
58233: EQUAL
58234: IFFALSE 58261
// result := Insert ( result , 1 , un ) else
58236: LD_ADDR_VAR 0 3
58240: PUSH
58241: LD_VAR 0 3
58245: PPUSH
58246: LD_INT 1
58248: PPUSH
58249: LD_VAR 0 4
58253: PPUSH
58254: CALL_OW 2
58258: ST_TO_ADDR
58259: GO 58290
// result := Replace ( result , result + 1 , un ) ;
58261: LD_ADDR_VAR 0 3
58265: PUSH
58266: LD_VAR 0 3
58270: PPUSH
58271: LD_VAR 0 3
58275: PUSH
58276: LD_INT 1
58278: PLUS
58279: PPUSH
58280: LD_VAR 0 4
58284: PPUSH
58285: CALL_OW 1
58289: ST_TO_ADDR
58290: GO 58216
58292: POP
58293: POP
// end ;
58294: LD_VAR 0 3
58298: RET
// export function GetCratesNearbyXY ( x , y , r ) ; var _x , _y , min_y , min_x , max_x , max_y ; begin
58299: LD_INT 0
58301: PPUSH
58302: PPUSH
58303: PPUSH
58304: PPUSH
58305: PPUSH
58306: PPUSH
58307: PPUSH
// result := [ ] ;
58308: LD_ADDR_VAR 0 4
58312: PUSH
58313: EMPTY
58314: ST_TO_ADDR
// if x - r < 0 then
58315: LD_VAR 0 1
58319: PUSH
58320: LD_VAR 0 3
58324: MINUS
58325: PUSH
58326: LD_INT 0
58328: LESS
58329: IFFALSE 58341
// min_x := 0 else
58331: LD_ADDR_VAR 0 8
58335: PUSH
58336: LD_INT 0
58338: ST_TO_ADDR
58339: GO 58357
// min_x := x - r ;
58341: LD_ADDR_VAR 0 8
58345: PUSH
58346: LD_VAR 0 1
58350: PUSH
58351: LD_VAR 0 3
58355: MINUS
58356: ST_TO_ADDR
// if y - r < 0 then
58357: LD_VAR 0 2
58361: PUSH
58362: LD_VAR 0 3
58366: MINUS
58367: PUSH
58368: LD_INT 0
58370: LESS
58371: IFFALSE 58383
// min_y := 0 else
58373: LD_ADDR_VAR 0 7
58377: PUSH
58378: LD_INT 0
58380: ST_TO_ADDR
58381: GO 58399
// min_y := y - r ;
58383: LD_ADDR_VAR 0 7
58387: PUSH
58388: LD_VAR 0 2
58392: PUSH
58393: LD_VAR 0 3
58397: MINUS
58398: ST_TO_ADDR
// max_x := x + r ;
58399: LD_ADDR_VAR 0 9
58403: PUSH
58404: LD_VAR 0 1
58408: PUSH
58409: LD_VAR 0 3
58413: PLUS
58414: ST_TO_ADDR
// max_y := y + r ;
58415: LD_ADDR_VAR 0 10
58419: PUSH
58420: LD_VAR 0 2
58424: PUSH
58425: LD_VAR 0 3
58429: PLUS
58430: ST_TO_ADDR
// for _x = min_x to max_x do
58431: LD_ADDR_VAR 0 5
58435: PUSH
58436: DOUBLE
58437: LD_VAR 0 8
58441: DEC
58442: ST_TO_ADDR
58443: LD_VAR 0 9
58447: PUSH
58448: FOR_TO
58449: IFFALSE 58550
// for _y = min_y to max_y do
58451: LD_ADDR_VAR 0 6
58455: PUSH
58456: DOUBLE
58457: LD_VAR 0 7
58461: DEC
58462: ST_TO_ADDR
58463: LD_VAR 0 10
58467: PUSH
58468: FOR_TO
58469: IFFALSE 58546
// begin if not ValidHex ( _x , _y ) then
58471: LD_VAR 0 5
58475: PPUSH
58476: LD_VAR 0 6
58480: PPUSH
58481: CALL_OW 488
58485: NOT
58486: IFFALSE 58490
// continue ;
58488: GO 58468
// if GetResourceTypeXY ( _x , _y ) then
58490: LD_VAR 0 5
58494: PPUSH
58495: LD_VAR 0 6
58499: PPUSH
58500: CALL_OW 283
58504: IFFALSE 58544
// result := Replace ( result , result + 1 , [ _x , _y ] ) ;
58506: LD_ADDR_VAR 0 4
58510: PUSH
58511: LD_VAR 0 4
58515: PPUSH
58516: LD_VAR 0 4
58520: PUSH
58521: LD_INT 1
58523: PLUS
58524: PPUSH
58525: LD_VAR 0 5
58529: PUSH
58530: LD_VAR 0 6
58534: PUSH
58535: EMPTY
58536: LIST
58537: LIST
58538: PPUSH
58539: CALL_OW 1
58543: ST_TO_ADDR
// end ;
58544: GO 58468
58546: POP
58547: POP
58548: GO 58448
58550: POP
58551: POP
// end ;
58552: LD_VAR 0 4
58556: RET
// export function AgressiveMove ( units , path ) ; var i , enemy , nearEnemy , cr , side , tag , ignoreCratesWeapon ; begin
58557: LD_INT 0
58559: PPUSH
58560: PPUSH
58561: PPUSH
58562: PPUSH
58563: PPUSH
58564: PPUSH
58565: PPUSH
58566: PPUSH
// if not units then
58567: LD_VAR 0 1
58571: NOT
58572: IFFALSE 58576
// exit ;
58574: GO 59001
// result := UnitFilter ( units , [ f_ok ] ) ;
58576: LD_ADDR_VAR 0 3
58580: PUSH
58581: LD_VAR 0 1
58585: PPUSH
58586: LD_INT 50
58588: PUSH
58589: EMPTY
58590: LIST
58591: PPUSH
58592: CALL_OW 72
58596: ST_TO_ADDR
// side := GetSide ( units [ 1 ] ) ;
58597: LD_ADDR_VAR 0 8
58601: PUSH
58602: LD_VAR 0 1
58606: PUSH
58607: LD_INT 1
58609: ARRAY
58610: PPUSH
58611: CALL_OW 255
58615: ST_TO_ADDR
// ignoreCratesWeapon := [ ar_selfpropelled_bomb , ar_bio_bomb ] ;
58616: LD_ADDR_VAR 0 10
58620: PUSH
58621: LD_INT 29
58623: PUSH
58624: LD_EXP 161
58628: PUSH
58629: EMPTY
58630: LIST
58631: LIST
58632: ST_TO_ADDR
// if not result then
58633: LD_VAR 0 3
58637: NOT
58638: IFFALSE 58642
// exit ;
58640: GO 59001
// enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
58642: LD_ADDR_VAR 0 5
58646: PUSH
58647: LD_INT 81
58649: PUSH
58650: LD_VAR 0 8
58654: PUSH
58655: EMPTY
58656: LIST
58657: LIST
58658: PPUSH
58659: CALL_OW 69
58663: ST_TO_ADDR
// for i in result do
58664: LD_ADDR_VAR 0 4
58668: PUSH
58669: LD_VAR 0 3
58673: PUSH
58674: FOR_IN
58675: IFFALSE 58999
// begin tag := GetTag ( i ) + 1 ;
58677: LD_ADDR_VAR 0 9
58681: PUSH
58682: LD_VAR 0 4
58686: PPUSH
58687: CALL_OW 110
58691: PUSH
58692: LD_INT 1
58694: PLUS
58695: ST_TO_ADDR
// cr := GetCratesNearbyXY ( GetX ( i ) , GetY ( i ) , 6 ) ;
58696: LD_ADDR_VAR 0 7
58700: PUSH
58701: LD_VAR 0 4
58705: PPUSH
58706: CALL_OW 250
58710: PPUSH
58711: LD_VAR 0 4
58715: PPUSH
58716: CALL_OW 251
58720: PPUSH
58721: LD_INT 6
58723: PPUSH
58724: CALL 58299 0 3
58728: ST_TO_ADDR
// if cr and not GetWeapon ( i ) in ignoreCratesWeapon then
58729: LD_VAR 0 7
58733: PUSH
58734: LD_VAR 0 4
58738: PPUSH
58739: CALL_OW 264
58743: PUSH
58744: LD_VAR 0 10
58748: IN
58749: NOT
58750: AND
58751: IFFALSE 58790
// ComAttackPlace ( i , cr [ 1 ] [ 1 ] , cr [ 1 ] [ 2 ] ) else
58753: LD_VAR 0 4
58757: PPUSH
58758: LD_VAR 0 7
58762: PUSH
58763: LD_INT 1
58765: ARRAY
58766: PUSH
58767: LD_INT 1
58769: ARRAY
58770: PPUSH
58771: LD_VAR 0 7
58775: PUSH
58776: LD_INT 1
58778: ARRAY
58779: PUSH
58780: LD_INT 2
58782: ARRAY
58783: PPUSH
58784: CALL_OW 116
58788: GO 58997
// if path > tag then
58790: LD_VAR 0 2
58794: PUSH
58795: LD_VAR 0 9
58799: GREATER
58800: IFFALSE 58967
// begin nearEnemy := UnitFilter ( enemy , [ f_dist , i , 12 ] ) ;
58802: LD_ADDR_VAR 0 6
58806: PUSH
58807: LD_VAR 0 5
58811: PPUSH
58812: LD_INT 91
58814: PUSH
58815: LD_VAR 0 4
58819: PUSH
58820: LD_INT 12
58822: PUSH
58823: EMPTY
58824: LIST
58825: LIST
58826: LIST
58827: PPUSH
58828: CALL_OW 72
58832: ST_TO_ADDR
// if nearEnemy then
58833: LD_VAR 0 6
58837: IFFALSE 58865
// ComAttackUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) else
58839: LD_VAR 0 4
58843: PPUSH
58844: LD_VAR 0 6
58848: PPUSH
58849: LD_VAR 0 4
58853: PPUSH
58854: CALL_OW 74
58858: PPUSH
58859: CALL_OW 115
58863: GO 58965
// if GetDistUnitXY ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) > 6 then
58865: LD_VAR 0 4
58869: PPUSH
58870: LD_VAR 0 2
58874: PUSH
58875: LD_VAR 0 9
58879: ARRAY
58880: PUSH
58881: LD_INT 1
58883: ARRAY
58884: PPUSH
58885: LD_VAR 0 2
58889: PUSH
58890: LD_VAR 0 9
58894: ARRAY
58895: PUSH
58896: LD_INT 2
58898: ARRAY
58899: PPUSH
58900: CALL_OW 297
58904: PUSH
58905: LD_INT 6
58907: GREATER
58908: IFFALSE 58951
// ComAgressiveMove ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) else
58910: LD_VAR 0 4
58914: PPUSH
58915: LD_VAR 0 2
58919: PUSH
58920: LD_VAR 0 9
58924: ARRAY
58925: PUSH
58926: LD_INT 1
58928: ARRAY
58929: PPUSH
58930: LD_VAR 0 2
58934: PUSH
58935: LD_VAR 0 9
58939: ARRAY
58940: PUSH
58941: LD_INT 2
58943: ARRAY
58944: PPUSH
58945: CALL_OW 114
58949: GO 58965
// SetTag ( i , tag ) ;
58951: LD_VAR 0 4
58955: PPUSH
58956: LD_VAR 0 9
58960: PPUSH
58961: CALL_OW 109
// end else
58965: GO 58997
// if enemy then
58967: LD_VAR 0 5
58971: IFFALSE 58997
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
58973: LD_VAR 0 4
58977: PPUSH
58978: LD_VAR 0 5
58982: PPUSH
58983: LD_VAR 0 4
58987: PPUSH
58988: CALL_OW 74
58992: PPUSH
58993: CALL_OW 115
// end ;
58997: GO 58674
58999: POP
59000: POP
// end ;
59001: LD_VAR 0 3
59005: RET
// export function ComLookAtDir ( unit , direction ) ; var x , y ; begin
59006: LD_INT 0
59008: PPUSH
59009: PPUSH
59010: PPUSH
// if not unit or IsInUnit ( unit ) then
59011: LD_VAR 0 1
59015: NOT
59016: PUSH
59017: LD_VAR 0 1
59021: PPUSH
59022: CALL_OW 310
59026: OR
59027: IFFALSE 59031
// exit ;
59029: GO 59122
// x := ShiftX ( GetX ( unit ) , direction , 1 ) ;
59031: LD_ADDR_VAR 0 4
59035: PUSH
59036: LD_VAR 0 1
59040: PPUSH
59041: CALL_OW 250
59045: PPUSH
59046: LD_VAR 0 2
59050: PPUSH
59051: LD_INT 1
59053: PPUSH
59054: CALL_OW 272
59058: ST_TO_ADDR
// y := ShiftY ( GetY ( unit ) , direction , 1 ) ;
59059: LD_ADDR_VAR 0 5
59063: PUSH
59064: LD_VAR 0 1
59068: PPUSH
59069: CALL_OW 251
59073: PPUSH
59074: LD_VAR 0 2
59078: PPUSH
59079: LD_INT 1
59081: PPUSH
59082: CALL_OW 273
59086: ST_TO_ADDR
// if ValidHex ( x , y ) then
59087: LD_VAR 0 4
59091: PPUSH
59092: LD_VAR 0 5
59096: PPUSH
59097: CALL_OW 488
59101: IFFALSE 59122
// ComTurnXY ( unit , x , y ) ;
59103: LD_VAR 0 1
59107: PPUSH
59108: LD_VAR 0 4
59112: PPUSH
59113: LD_VAR 0 5
59117: PPUSH
59118: CALL_OW 118
// end ;
59122: LD_VAR 0 3
59126: RET
// export function SeeUnits ( side , units ) ; var i ; begin
59127: LD_INT 0
59129: PPUSH
59130: PPUSH
// result := false ;
59131: LD_ADDR_VAR 0 3
59135: PUSH
59136: LD_INT 0
59138: ST_TO_ADDR
// if not units then
59139: LD_VAR 0 2
59143: NOT
59144: IFFALSE 59148
// exit ;
59146: GO 59193
// for i in units do
59148: LD_ADDR_VAR 0 4
59152: PUSH
59153: LD_VAR 0 2
59157: PUSH
59158: FOR_IN
59159: IFFALSE 59191
// if See ( side , i ) then
59161: LD_VAR 0 1
59165: PPUSH
59166: LD_VAR 0 4
59170: PPUSH
59171: CALL_OW 292
59175: IFFALSE 59189
// begin result := true ;
59177: LD_ADDR_VAR 0 3
59181: PUSH
59182: LD_INT 1
59184: ST_TO_ADDR
// exit ;
59185: POP
59186: POP
59187: GO 59193
// end ;
59189: GO 59158
59191: POP
59192: POP
// end ;
59193: LD_VAR 0 3
59197: RET
// export function GetNearestPoint ( unit , points ) ; var i , dist , tmpDist ; begin
59198: LD_INT 0
59200: PPUSH
59201: PPUSH
59202: PPUSH
59203: PPUSH
// if not unit or not points then
59204: LD_VAR 0 1
59208: NOT
59209: PUSH
59210: LD_VAR 0 2
59214: NOT
59215: OR
59216: IFFALSE 59220
// exit ;
59218: GO 59310
// dist := 99999 ;
59220: LD_ADDR_VAR 0 5
59224: PUSH
59225: LD_INT 99999
59227: ST_TO_ADDR
// for i in points do
59228: LD_ADDR_VAR 0 4
59232: PUSH
59233: LD_VAR 0 2
59237: PUSH
59238: FOR_IN
59239: IFFALSE 59308
// begin tmpDist := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
59241: LD_ADDR_VAR 0 6
59245: PUSH
59246: LD_VAR 0 1
59250: PPUSH
59251: LD_VAR 0 4
59255: PUSH
59256: LD_INT 1
59258: ARRAY
59259: PPUSH
59260: LD_VAR 0 4
59264: PUSH
59265: LD_INT 2
59267: ARRAY
59268: PPUSH
59269: CALL_OW 297
59273: ST_TO_ADDR
// if tmpDist < dist then
59274: LD_VAR 0 6
59278: PUSH
59279: LD_VAR 0 5
59283: LESS
59284: IFFALSE 59306
// begin result := i ;
59286: LD_ADDR_VAR 0 3
59290: PUSH
59291: LD_VAR 0 4
59295: ST_TO_ADDR
// dist := tmpDist ;
59296: LD_ADDR_VAR 0 5
59300: PUSH
59301: LD_VAR 0 6
59305: ST_TO_ADDR
// end ; end ;
59306: GO 59238
59308: POP
59309: POP
// end ; end_of_file
59310: LD_VAR 0 3
59314: RET
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
59315: LD_INT 0
59317: PPUSH
59318: PPUSH
59319: PPUSH
59320: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
59321: LD_VAR 0 1
59325: PPUSH
59326: CALL_OW 264
59330: PUSH
59331: LD_EXP 161
59335: EQUAL
59336: IFFALSE 59408
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
59338: LD_INT 68
59340: PPUSH
59341: LD_VAR 0 1
59345: PPUSH
59346: CALL_OW 255
59350: PPUSH
59351: CALL_OW 321
59355: PUSH
59356: LD_INT 2
59358: EQUAL
59359: IFFALSE 59371
// eff := 70 else
59361: LD_ADDR_VAR 0 4
59365: PUSH
59366: LD_INT 70
59368: ST_TO_ADDR
59369: GO 59379
// eff := 30 ;
59371: LD_ADDR_VAR 0 4
59375: PUSH
59376: LD_INT 30
59378: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
59379: LD_VAR 0 1
59383: PPUSH
59384: CALL_OW 250
59388: PPUSH
59389: LD_VAR 0 1
59393: PPUSH
59394: CALL_OW 251
59398: PPUSH
59399: LD_VAR 0 4
59403: PPUSH
59404: CALL_OW 495
// end ; end ;
59408: LD_VAR 0 2
59412: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
59413: LD_INT 0
59415: PPUSH
// end ;
59416: LD_VAR 0 4
59420: RET
// export function SOS_Command ( cmd ) ; begin
59421: LD_INT 0
59423: PPUSH
// end ;
59424: LD_VAR 0 2
59428: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
59429: LD_INT 0
59431: PPUSH
// end ;
59432: LD_VAR 0 6
59436: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
59437: LD_INT 0
59439: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
59440: LD_VAR 0 1
59444: PUSH
59445: LD_INT 250
59447: EQUAL
59448: PUSH
59449: LD_VAR 0 2
59453: PPUSH
59454: CALL_OW 264
59458: PUSH
59459: LD_EXP 164
59463: EQUAL
59464: AND
59465: IFFALSE 59486
// MinerPlaceMine ( unit , x , y ) ;
59467: LD_VAR 0 2
59471: PPUSH
59472: LD_VAR 0 4
59476: PPUSH
59477: LD_VAR 0 5
59481: PPUSH
59482: CALL 61835 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
59486: LD_VAR 0 1
59490: PUSH
59491: LD_INT 251
59493: EQUAL
59494: PUSH
59495: LD_VAR 0 2
59499: PPUSH
59500: CALL_OW 264
59504: PUSH
59505: LD_EXP 164
59509: EQUAL
59510: AND
59511: IFFALSE 59532
// MinerDetonateMine ( unit , x , y ) ;
59513: LD_VAR 0 2
59517: PPUSH
59518: LD_VAR 0 4
59522: PPUSH
59523: LD_VAR 0 5
59527: PPUSH
59528: CALL 62112 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
59532: LD_VAR 0 1
59536: PUSH
59537: LD_INT 252
59539: EQUAL
59540: PUSH
59541: LD_VAR 0 2
59545: PPUSH
59546: CALL_OW 264
59550: PUSH
59551: LD_EXP 164
59555: EQUAL
59556: AND
59557: IFFALSE 59578
// MinerCreateMinefield ( unit , x , y ) ;
59559: LD_VAR 0 2
59563: PPUSH
59564: LD_VAR 0 4
59568: PPUSH
59569: LD_VAR 0 5
59573: PPUSH
59574: CALL 62529 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
59578: LD_VAR 0 1
59582: PUSH
59583: LD_INT 253
59585: EQUAL
59586: PUSH
59587: LD_VAR 0 2
59591: PPUSH
59592: CALL_OW 257
59596: PUSH
59597: LD_INT 5
59599: EQUAL
59600: AND
59601: IFFALSE 59622
// ComBinocular ( unit , x , y ) ;
59603: LD_VAR 0 2
59607: PPUSH
59608: LD_VAR 0 4
59612: PPUSH
59613: LD_VAR 0 5
59617: PPUSH
59618: CALL 62900 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
59622: LD_VAR 0 1
59626: PUSH
59627: LD_INT 254
59629: EQUAL
59630: PUSH
59631: LD_VAR 0 2
59635: PPUSH
59636: CALL_OW 264
59640: PUSH
59641: LD_EXP 159
59645: EQUAL
59646: AND
59647: PUSH
59648: LD_VAR 0 3
59652: PPUSH
59653: CALL_OW 263
59657: PUSH
59658: LD_INT 3
59660: EQUAL
59661: AND
59662: IFFALSE 59678
// HackDestroyVehicle ( unit , selectedUnit ) ;
59664: LD_VAR 0 2
59668: PPUSH
59669: LD_VAR 0 3
59673: PPUSH
59674: CALL 61195 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
59678: LD_VAR 0 1
59682: PUSH
59683: LD_INT 255
59685: EQUAL
59686: PUSH
59687: LD_VAR 0 2
59691: PPUSH
59692: CALL_OW 264
59696: PUSH
59697: LD_INT 14
59699: PUSH
59700: LD_INT 53
59702: PUSH
59703: EMPTY
59704: LIST
59705: LIST
59706: IN
59707: AND
59708: PUSH
59709: LD_VAR 0 4
59713: PPUSH
59714: LD_VAR 0 5
59718: PPUSH
59719: CALL_OW 488
59723: AND
59724: IFFALSE 59748
// CutTreeXYR ( unit , x , y , 12 ) ;
59726: LD_VAR 0 2
59730: PPUSH
59731: LD_VAR 0 4
59735: PPUSH
59736: LD_VAR 0 5
59740: PPUSH
59741: LD_INT 12
59743: PPUSH
59744: CALL 59761 0 4
// end ;
59748: LD_VAR 0 6
59752: RET
// export initPlantMineScript , plantMineList ; export function ComGroupPlantMineXY ( units , x , y ) ; begin
59753: LD_INT 0
59755: PPUSH
// end ;
59756: LD_VAR 0 4
59760: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
59761: LD_INT 0
59763: PPUSH
59764: PPUSH
59765: PPUSH
59766: PPUSH
59767: PPUSH
59768: PPUSH
59769: PPUSH
59770: PPUSH
59771: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
59772: LD_VAR 0 1
59776: NOT
59777: PUSH
59778: LD_VAR 0 2
59782: PPUSH
59783: LD_VAR 0 3
59787: PPUSH
59788: CALL_OW 488
59792: NOT
59793: OR
59794: PUSH
59795: LD_VAR 0 4
59799: NOT
59800: OR
59801: IFFALSE 59805
// exit ;
59803: GO 60145
// list := [ ] ;
59805: LD_ADDR_VAR 0 13
59809: PUSH
59810: EMPTY
59811: ST_TO_ADDR
// if x - r < 0 then
59812: LD_VAR 0 2
59816: PUSH
59817: LD_VAR 0 4
59821: MINUS
59822: PUSH
59823: LD_INT 0
59825: LESS
59826: IFFALSE 59838
// min_x := 0 else
59828: LD_ADDR_VAR 0 7
59832: PUSH
59833: LD_INT 0
59835: ST_TO_ADDR
59836: GO 59854
// min_x := x - r ;
59838: LD_ADDR_VAR 0 7
59842: PUSH
59843: LD_VAR 0 2
59847: PUSH
59848: LD_VAR 0 4
59852: MINUS
59853: ST_TO_ADDR
// if y - r < 0 then
59854: LD_VAR 0 3
59858: PUSH
59859: LD_VAR 0 4
59863: MINUS
59864: PUSH
59865: LD_INT 0
59867: LESS
59868: IFFALSE 59880
// min_y := 0 else
59870: LD_ADDR_VAR 0 8
59874: PUSH
59875: LD_INT 0
59877: ST_TO_ADDR
59878: GO 59896
// min_y := y - r ;
59880: LD_ADDR_VAR 0 8
59884: PUSH
59885: LD_VAR 0 3
59889: PUSH
59890: LD_VAR 0 4
59894: MINUS
59895: ST_TO_ADDR
// max_x := x + r ;
59896: LD_ADDR_VAR 0 9
59900: PUSH
59901: LD_VAR 0 2
59905: PUSH
59906: LD_VAR 0 4
59910: PLUS
59911: ST_TO_ADDR
// max_y := y + r ;
59912: LD_ADDR_VAR 0 10
59916: PUSH
59917: LD_VAR 0 3
59921: PUSH
59922: LD_VAR 0 4
59926: PLUS
59927: ST_TO_ADDR
// for _x = min_x to max_x do
59928: LD_ADDR_VAR 0 11
59932: PUSH
59933: DOUBLE
59934: LD_VAR 0 7
59938: DEC
59939: ST_TO_ADDR
59940: LD_VAR 0 9
59944: PUSH
59945: FOR_TO
59946: IFFALSE 60063
// for _y = min_y to max_y do
59948: LD_ADDR_VAR 0 12
59952: PUSH
59953: DOUBLE
59954: LD_VAR 0 8
59958: DEC
59959: ST_TO_ADDR
59960: LD_VAR 0 10
59964: PUSH
59965: FOR_TO
59966: IFFALSE 60059
// begin if not ValidHex ( _x , _y ) then
59968: LD_VAR 0 11
59972: PPUSH
59973: LD_VAR 0 12
59977: PPUSH
59978: CALL_OW 488
59982: NOT
59983: IFFALSE 59987
// continue ;
59985: GO 59965
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
59987: LD_VAR 0 11
59991: PPUSH
59992: LD_VAR 0 12
59996: PPUSH
59997: CALL_OW 351
60001: PUSH
60002: LD_VAR 0 11
60006: PPUSH
60007: LD_VAR 0 12
60011: PPUSH
60012: CALL_OW 554
60016: AND
60017: IFFALSE 60057
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
60019: LD_ADDR_VAR 0 13
60023: PUSH
60024: LD_VAR 0 13
60028: PPUSH
60029: LD_VAR 0 13
60033: PUSH
60034: LD_INT 1
60036: PLUS
60037: PPUSH
60038: LD_VAR 0 11
60042: PUSH
60043: LD_VAR 0 12
60047: PUSH
60048: EMPTY
60049: LIST
60050: LIST
60051: PPUSH
60052: CALL_OW 2
60056: ST_TO_ADDR
// end ;
60057: GO 59965
60059: POP
60060: POP
60061: GO 59945
60063: POP
60064: POP
// if not list then
60065: LD_VAR 0 13
60069: NOT
60070: IFFALSE 60074
// exit ;
60072: GO 60145
// for i in list do
60074: LD_ADDR_VAR 0 6
60078: PUSH
60079: LD_VAR 0 13
60083: PUSH
60084: FOR_IN
60085: IFFALSE 60143
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
60087: LD_VAR 0 1
60091: PPUSH
60092: LD_STRING M
60094: PUSH
60095: LD_VAR 0 6
60099: PUSH
60100: LD_INT 1
60102: ARRAY
60103: PUSH
60104: LD_VAR 0 6
60108: PUSH
60109: LD_INT 2
60111: ARRAY
60112: PUSH
60113: LD_INT 0
60115: PUSH
60116: LD_INT 0
60118: PUSH
60119: LD_INT 0
60121: PUSH
60122: LD_INT 0
60124: PUSH
60125: EMPTY
60126: LIST
60127: LIST
60128: LIST
60129: LIST
60130: LIST
60131: LIST
60132: LIST
60133: PUSH
60134: EMPTY
60135: LIST
60136: PPUSH
60137: CALL_OW 447
60141: GO 60084
60143: POP
60144: POP
// end ;
60145: LD_VAR 0 5
60149: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
60150: LD_EXP 89
60154: NOT
60155: IFFALSE 60205
60157: GO 60159
60159: DISABLE
// begin initHack := true ;
60160: LD_ADDR_EXP 89
60164: PUSH
60165: LD_INT 1
60167: ST_TO_ADDR
// hackTanks := [ ] ;
60168: LD_ADDR_EXP 90
60172: PUSH
60173: EMPTY
60174: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
60175: LD_ADDR_EXP 91
60179: PUSH
60180: EMPTY
60181: ST_TO_ADDR
// hackLimit := 3 ;
60182: LD_ADDR_EXP 92
60186: PUSH
60187: LD_INT 3
60189: ST_TO_ADDR
// hackDist := 12 ;
60190: LD_ADDR_EXP 93
60194: PUSH
60195: LD_INT 12
60197: ST_TO_ADDR
// hackCounter := [ ] ;
60198: LD_ADDR_EXP 94
60202: PUSH
60203: EMPTY
60204: ST_TO_ADDR
// end ;
60205: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
60206: LD_EXP 89
60210: PUSH
60211: LD_INT 34
60213: PUSH
60214: LD_EXP 159
60218: PUSH
60219: EMPTY
60220: LIST
60221: LIST
60222: PPUSH
60223: CALL_OW 69
60227: AND
60228: IFFALSE 60483
60230: GO 60232
60232: DISABLE
60233: LD_INT 0
60235: PPUSH
60236: PPUSH
// begin enable ;
60237: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
60238: LD_ADDR_VAR 0 1
60242: PUSH
60243: LD_INT 34
60245: PUSH
60246: LD_EXP 159
60250: PUSH
60251: EMPTY
60252: LIST
60253: LIST
60254: PPUSH
60255: CALL_OW 69
60259: PUSH
60260: FOR_IN
60261: IFFALSE 60481
// begin if not i in hackTanks then
60263: LD_VAR 0 1
60267: PUSH
60268: LD_EXP 90
60272: IN
60273: NOT
60274: IFFALSE 60357
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
60276: LD_ADDR_EXP 90
60280: PUSH
60281: LD_EXP 90
60285: PPUSH
60286: LD_EXP 90
60290: PUSH
60291: LD_INT 1
60293: PLUS
60294: PPUSH
60295: LD_VAR 0 1
60299: PPUSH
60300: CALL_OW 1
60304: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
60305: LD_ADDR_EXP 91
60309: PUSH
60310: LD_EXP 91
60314: PPUSH
60315: LD_EXP 91
60319: PUSH
60320: LD_INT 1
60322: PLUS
60323: PPUSH
60324: EMPTY
60325: PPUSH
60326: CALL_OW 1
60330: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
60331: LD_ADDR_EXP 94
60335: PUSH
60336: LD_EXP 94
60340: PPUSH
60341: LD_EXP 94
60345: PUSH
60346: LD_INT 1
60348: PLUS
60349: PPUSH
60350: EMPTY
60351: PPUSH
60352: CALL_OW 1
60356: ST_TO_ADDR
// end ; if not IsOk ( i ) then
60357: LD_VAR 0 1
60361: PPUSH
60362: CALL_OW 302
60366: NOT
60367: IFFALSE 60380
// begin HackUnlinkAll ( i ) ;
60369: LD_VAR 0 1
60373: PPUSH
60374: CALL 60486 0 1
// continue ;
60378: GO 60260
// end ; HackCheckCapturedStatus ( i ) ;
60380: LD_VAR 0 1
60384: PPUSH
60385: CALL 60929 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
60389: LD_ADDR_VAR 0 2
60393: PUSH
60394: LD_INT 81
60396: PUSH
60397: LD_VAR 0 1
60401: PPUSH
60402: CALL_OW 255
60406: PUSH
60407: EMPTY
60408: LIST
60409: LIST
60410: PUSH
60411: LD_INT 33
60413: PUSH
60414: LD_INT 3
60416: PUSH
60417: EMPTY
60418: LIST
60419: LIST
60420: PUSH
60421: LD_INT 91
60423: PUSH
60424: LD_VAR 0 1
60428: PUSH
60429: LD_EXP 93
60433: PUSH
60434: EMPTY
60435: LIST
60436: LIST
60437: LIST
60438: PUSH
60439: LD_INT 50
60441: PUSH
60442: EMPTY
60443: LIST
60444: PUSH
60445: EMPTY
60446: LIST
60447: LIST
60448: LIST
60449: LIST
60450: PPUSH
60451: CALL_OW 69
60455: ST_TO_ADDR
// if not tmp then
60456: LD_VAR 0 2
60460: NOT
60461: IFFALSE 60465
// continue ;
60463: GO 60260
// HackLink ( i , tmp ) ;
60465: LD_VAR 0 1
60469: PPUSH
60470: LD_VAR 0 2
60474: PPUSH
60475: CALL 60622 0 2
// end ;
60479: GO 60260
60481: POP
60482: POP
// end ;
60483: PPOPN 2
60485: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
60486: LD_INT 0
60488: PPUSH
60489: PPUSH
60490: PPUSH
// if not hack in hackTanks then
60491: LD_VAR 0 1
60495: PUSH
60496: LD_EXP 90
60500: IN
60501: NOT
60502: IFFALSE 60506
// exit ;
60504: GO 60617
// index := GetElementIndex ( hackTanks , hack ) ;
60506: LD_ADDR_VAR 0 4
60510: PUSH
60511: LD_EXP 90
60515: PPUSH
60516: LD_VAR 0 1
60520: PPUSH
60521: CALL 23995 0 2
60525: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
60526: LD_EXP 91
60530: PUSH
60531: LD_VAR 0 4
60535: ARRAY
60536: IFFALSE 60617
// begin for i in hackTanksCaptured [ index ] do
60538: LD_ADDR_VAR 0 3
60542: PUSH
60543: LD_EXP 91
60547: PUSH
60548: LD_VAR 0 4
60552: ARRAY
60553: PUSH
60554: FOR_IN
60555: IFFALSE 60581
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
60557: LD_VAR 0 3
60561: PUSH
60562: LD_INT 1
60564: ARRAY
60565: PPUSH
60566: LD_VAR 0 3
60570: PUSH
60571: LD_INT 2
60573: ARRAY
60574: PPUSH
60575: CALL_OW 235
60579: GO 60554
60581: POP
60582: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
60583: LD_ADDR_EXP 91
60587: PUSH
60588: LD_EXP 91
60592: PPUSH
60593: LD_VAR 0 4
60597: PPUSH
60598: EMPTY
60599: PPUSH
60600: CALL_OW 1
60604: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
60605: LD_VAR 0 1
60609: PPUSH
60610: LD_INT 0
60612: PPUSH
60613: CALL_OW 505
// end ; end ;
60617: LD_VAR 0 2
60621: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
60622: LD_INT 0
60624: PPUSH
60625: PPUSH
60626: PPUSH
// if not hack in hackTanks or not vehicles then
60627: LD_VAR 0 1
60631: PUSH
60632: LD_EXP 90
60636: IN
60637: NOT
60638: PUSH
60639: LD_VAR 0 2
60643: NOT
60644: OR
60645: IFFALSE 60649
// exit ;
60647: GO 60924
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
60649: LD_ADDR_VAR 0 2
60653: PUSH
60654: LD_VAR 0 1
60658: PPUSH
60659: LD_VAR 0 2
60663: PPUSH
60664: LD_INT 1
60666: PPUSH
60667: LD_INT 1
60669: PPUSH
60670: CALL 24645 0 4
60674: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
60675: LD_ADDR_VAR 0 5
60679: PUSH
60680: LD_EXP 90
60684: PPUSH
60685: LD_VAR 0 1
60689: PPUSH
60690: CALL 23995 0 2
60694: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
60695: LD_EXP 91
60699: PUSH
60700: LD_VAR 0 5
60704: ARRAY
60705: PUSH
60706: LD_EXP 92
60710: LESS
60711: IFFALSE 60900
// begin for i := 1 to vehicles do
60713: LD_ADDR_VAR 0 4
60717: PUSH
60718: DOUBLE
60719: LD_INT 1
60721: DEC
60722: ST_TO_ADDR
60723: LD_VAR 0 2
60727: PUSH
60728: FOR_TO
60729: IFFALSE 60898
// begin if hackTanksCaptured [ index ] = hackLimit then
60731: LD_EXP 91
60735: PUSH
60736: LD_VAR 0 5
60740: ARRAY
60741: PUSH
60742: LD_EXP 92
60746: EQUAL
60747: IFFALSE 60751
// break ;
60749: GO 60898
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
60751: LD_ADDR_EXP 94
60755: PUSH
60756: LD_EXP 94
60760: PPUSH
60761: LD_VAR 0 5
60765: PPUSH
60766: LD_EXP 94
60770: PUSH
60771: LD_VAR 0 5
60775: ARRAY
60776: PUSH
60777: LD_INT 1
60779: PLUS
60780: PPUSH
60781: CALL_OW 1
60785: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
60786: LD_ADDR_EXP 91
60790: PUSH
60791: LD_EXP 91
60795: PPUSH
60796: LD_VAR 0 5
60800: PUSH
60801: LD_EXP 91
60805: PUSH
60806: LD_VAR 0 5
60810: ARRAY
60811: PUSH
60812: LD_INT 1
60814: PLUS
60815: PUSH
60816: EMPTY
60817: LIST
60818: LIST
60819: PPUSH
60820: LD_VAR 0 2
60824: PUSH
60825: LD_VAR 0 4
60829: ARRAY
60830: PUSH
60831: LD_VAR 0 2
60835: PUSH
60836: LD_VAR 0 4
60840: ARRAY
60841: PPUSH
60842: CALL_OW 255
60846: PUSH
60847: EMPTY
60848: LIST
60849: LIST
60850: PPUSH
60851: CALL 24210 0 3
60855: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
60856: LD_VAR 0 2
60860: PUSH
60861: LD_VAR 0 4
60865: ARRAY
60866: PPUSH
60867: LD_VAR 0 1
60871: PPUSH
60872: CALL_OW 255
60876: PPUSH
60877: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
60881: LD_VAR 0 2
60885: PUSH
60886: LD_VAR 0 4
60890: ARRAY
60891: PPUSH
60892: CALL_OW 141
// end ;
60896: GO 60728
60898: POP
60899: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
60900: LD_VAR 0 1
60904: PPUSH
60905: LD_EXP 91
60909: PUSH
60910: LD_VAR 0 5
60914: ARRAY
60915: PUSH
60916: LD_INT 0
60918: PLUS
60919: PPUSH
60920: CALL_OW 505
// end ;
60924: LD_VAR 0 3
60928: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
60929: LD_INT 0
60931: PPUSH
60932: PPUSH
60933: PPUSH
60934: PPUSH
// if not hack in hackTanks then
60935: LD_VAR 0 1
60939: PUSH
60940: LD_EXP 90
60944: IN
60945: NOT
60946: IFFALSE 60950
// exit ;
60948: GO 61190
// index := GetElementIndex ( hackTanks , hack ) ;
60950: LD_ADDR_VAR 0 4
60954: PUSH
60955: LD_EXP 90
60959: PPUSH
60960: LD_VAR 0 1
60964: PPUSH
60965: CALL 23995 0 2
60969: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
60970: LD_ADDR_VAR 0 3
60974: PUSH
60975: DOUBLE
60976: LD_EXP 91
60980: PUSH
60981: LD_VAR 0 4
60985: ARRAY
60986: INC
60987: ST_TO_ADDR
60988: LD_INT 1
60990: PUSH
60991: FOR_DOWNTO
60992: IFFALSE 61164
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
60994: LD_ADDR_VAR 0 5
60998: PUSH
60999: LD_EXP 91
61003: PUSH
61004: LD_VAR 0 4
61008: ARRAY
61009: PUSH
61010: LD_VAR 0 3
61014: ARRAY
61015: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
61016: LD_VAR 0 5
61020: PUSH
61021: LD_INT 1
61023: ARRAY
61024: PPUSH
61025: CALL_OW 302
61029: NOT
61030: PUSH
61031: LD_VAR 0 5
61035: PUSH
61036: LD_INT 1
61038: ARRAY
61039: PPUSH
61040: CALL_OW 255
61044: PUSH
61045: LD_VAR 0 1
61049: PPUSH
61050: CALL_OW 255
61054: NONEQUAL
61055: OR
61056: IFFALSE 61162
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
61058: LD_VAR 0 5
61062: PUSH
61063: LD_INT 1
61065: ARRAY
61066: PPUSH
61067: CALL_OW 305
61071: PUSH
61072: LD_VAR 0 5
61076: PUSH
61077: LD_INT 1
61079: ARRAY
61080: PPUSH
61081: CALL_OW 255
61085: PUSH
61086: LD_VAR 0 1
61090: PPUSH
61091: CALL_OW 255
61095: EQUAL
61096: AND
61097: IFFALSE 61121
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
61099: LD_VAR 0 5
61103: PUSH
61104: LD_INT 1
61106: ARRAY
61107: PPUSH
61108: LD_VAR 0 5
61112: PUSH
61113: LD_INT 2
61115: ARRAY
61116: PPUSH
61117: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
61121: LD_ADDR_EXP 91
61125: PUSH
61126: LD_EXP 91
61130: PPUSH
61131: LD_VAR 0 4
61135: PPUSH
61136: LD_EXP 91
61140: PUSH
61141: LD_VAR 0 4
61145: ARRAY
61146: PPUSH
61147: LD_VAR 0 3
61151: PPUSH
61152: CALL_OW 3
61156: PPUSH
61157: CALL_OW 1
61161: ST_TO_ADDR
// end ; end ;
61162: GO 60991
61164: POP
61165: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
61166: LD_VAR 0 1
61170: PPUSH
61171: LD_EXP 91
61175: PUSH
61176: LD_VAR 0 4
61180: ARRAY
61181: PUSH
61182: LD_INT 0
61184: PLUS
61185: PPUSH
61186: CALL_OW 505
// end ;
61190: LD_VAR 0 2
61194: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
61195: LD_INT 0
61197: PPUSH
61198: PPUSH
61199: PPUSH
61200: PPUSH
// if not hack in hackTanks then
61201: LD_VAR 0 1
61205: PUSH
61206: LD_EXP 90
61210: IN
61211: NOT
61212: IFFALSE 61216
// exit ;
61214: GO 61301
// index := GetElementIndex ( hackTanks , hack ) ;
61216: LD_ADDR_VAR 0 5
61220: PUSH
61221: LD_EXP 90
61225: PPUSH
61226: LD_VAR 0 1
61230: PPUSH
61231: CALL 23995 0 2
61235: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
61236: LD_ADDR_VAR 0 4
61240: PUSH
61241: DOUBLE
61242: LD_INT 1
61244: DEC
61245: ST_TO_ADDR
61246: LD_EXP 91
61250: PUSH
61251: LD_VAR 0 5
61255: ARRAY
61256: PUSH
61257: FOR_TO
61258: IFFALSE 61299
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
61260: LD_EXP 91
61264: PUSH
61265: LD_VAR 0 5
61269: ARRAY
61270: PUSH
61271: LD_VAR 0 4
61275: ARRAY
61276: PUSH
61277: LD_INT 1
61279: ARRAY
61280: PUSH
61281: LD_VAR 0 2
61285: EQUAL
61286: IFFALSE 61297
// KillUnit ( vehicle ) ;
61288: LD_VAR 0 2
61292: PPUSH
61293: CALL_OW 66
61297: GO 61257
61299: POP
61300: POP
// end ;
61301: LD_VAR 0 3
61305: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
61306: LD_EXP 95
61310: NOT
61311: IFFALSE 61346
61313: GO 61315
61315: DISABLE
// begin initMiner := true ;
61316: LD_ADDR_EXP 95
61320: PUSH
61321: LD_INT 1
61323: ST_TO_ADDR
// minersList := [ ] ;
61324: LD_ADDR_EXP 96
61328: PUSH
61329: EMPTY
61330: ST_TO_ADDR
// minerMinesList := [ ] ;
61331: LD_ADDR_EXP 97
61335: PUSH
61336: EMPTY
61337: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
61338: LD_ADDR_EXP 98
61342: PUSH
61343: LD_INT 5
61345: ST_TO_ADDR
// end ;
61346: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
61347: LD_EXP 95
61351: PUSH
61352: LD_INT 34
61354: PUSH
61355: LD_EXP 164
61359: PUSH
61360: EMPTY
61361: LIST
61362: LIST
61363: PPUSH
61364: CALL_OW 69
61368: AND
61369: IFFALSE 61832
61371: GO 61373
61373: DISABLE
61374: LD_INT 0
61376: PPUSH
61377: PPUSH
61378: PPUSH
61379: PPUSH
// begin enable ;
61380: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
61381: LD_ADDR_VAR 0 1
61385: PUSH
61386: LD_INT 34
61388: PUSH
61389: LD_EXP 164
61393: PUSH
61394: EMPTY
61395: LIST
61396: LIST
61397: PPUSH
61398: CALL_OW 69
61402: PUSH
61403: FOR_IN
61404: IFFALSE 61476
// begin if not i in minersList then
61406: LD_VAR 0 1
61410: PUSH
61411: LD_EXP 96
61415: IN
61416: NOT
61417: IFFALSE 61474
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
61419: LD_ADDR_EXP 96
61423: PUSH
61424: LD_EXP 96
61428: PPUSH
61429: LD_EXP 96
61433: PUSH
61434: LD_INT 1
61436: PLUS
61437: PPUSH
61438: LD_VAR 0 1
61442: PPUSH
61443: CALL_OW 1
61447: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
61448: LD_ADDR_EXP 97
61452: PUSH
61453: LD_EXP 97
61457: PPUSH
61458: LD_EXP 97
61462: PUSH
61463: LD_INT 1
61465: PLUS
61466: PPUSH
61467: EMPTY
61468: PPUSH
61469: CALL_OW 1
61473: ST_TO_ADDR
// end end ;
61474: GO 61403
61476: POP
61477: POP
// for i := minerMinesList downto 1 do
61478: LD_ADDR_VAR 0 1
61482: PUSH
61483: DOUBLE
61484: LD_EXP 97
61488: INC
61489: ST_TO_ADDR
61490: LD_INT 1
61492: PUSH
61493: FOR_DOWNTO
61494: IFFALSE 61830
// begin if IsLive ( minersList [ i ] ) then
61496: LD_EXP 96
61500: PUSH
61501: LD_VAR 0 1
61505: ARRAY
61506: PPUSH
61507: CALL_OW 300
61511: IFFALSE 61539
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
61513: LD_EXP 96
61517: PUSH
61518: LD_VAR 0 1
61522: ARRAY
61523: PPUSH
61524: LD_EXP 97
61528: PUSH
61529: LD_VAR 0 1
61533: ARRAY
61534: PPUSH
61535: CALL_OW 505
// if not minerMinesList [ i ] then
61539: LD_EXP 97
61543: PUSH
61544: LD_VAR 0 1
61548: ARRAY
61549: NOT
61550: IFFALSE 61554
// continue ;
61552: GO 61493
// for j := minerMinesList [ i ] downto 1 do
61554: LD_ADDR_VAR 0 2
61558: PUSH
61559: DOUBLE
61560: LD_EXP 97
61564: PUSH
61565: LD_VAR 0 1
61569: ARRAY
61570: INC
61571: ST_TO_ADDR
61572: LD_INT 1
61574: PUSH
61575: FOR_DOWNTO
61576: IFFALSE 61826
// begin side := GetSide ( minersList [ i ] ) ;
61578: LD_ADDR_VAR 0 3
61582: PUSH
61583: LD_EXP 96
61587: PUSH
61588: LD_VAR 0 1
61592: ARRAY
61593: PPUSH
61594: CALL_OW 255
61598: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
61599: LD_ADDR_VAR 0 4
61603: PUSH
61604: LD_EXP 97
61608: PUSH
61609: LD_VAR 0 1
61613: ARRAY
61614: PUSH
61615: LD_VAR 0 2
61619: ARRAY
61620: PUSH
61621: LD_INT 1
61623: ARRAY
61624: PPUSH
61625: LD_EXP 97
61629: PUSH
61630: LD_VAR 0 1
61634: ARRAY
61635: PUSH
61636: LD_VAR 0 2
61640: ARRAY
61641: PUSH
61642: LD_INT 2
61644: ARRAY
61645: PPUSH
61646: CALL_OW 428
61650: ST_TO_ADDR
// if not tmp then
61651: LD_VAR 0 4
61655: NOT
61656: IFFALSE 61660
// continue ;
61658: GO 61575
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
61660: LD_VAR 0 4
61664: PUSH
61665: LD_INT 81
61667: PUSH
61668: LD_VAR 0 3
61672: PUSH
61673: EMPTY
61674: LIST
61675: LIST
61676: PPUSH
61677: CALL_OW 69
61681: IN
61682: PUSH
61683: LD_EXP 97
61687: PUSH
61688: LD_VAR 0 1
61692: ARRAY
61693: PUSH
61694: LD_VAR 0 2
61698: ARRAY
61699: PUSH
61700: LD_INT 1
61702: ARRAY
61703: PPUSH
61704: LD_EXP 97
61708: PUSH
61709: LD_VAR 0 1
61713: ARRAY
61714: PUSH
61715: LD_VAR 0 2
61719: ARRAY
61720: PUSH
61721: LD_INT 2
61723: ARRAY
61724: PPUSH
61725: CALL_OW 458
61729: AND
61730: IFFALSE 61824
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
61732: LD_EXP 97
61736: PUSH
61737: LD_VAR 0 1
61741: ARRAY
61742: PUSH
61743: LD_VAR 0 2
61747: ARRAY
61748: PUSH
61749: LD_INT 1
61751: ARRAY
61752: PPUSH
61753: LD_EXP 97
61757: PUSH
61758: LD_VAR 0 1
61762: ARRAY
61763: PUSH
61764: LD_VAR 0 2
61768: ARRAY
61769: PUSH
61770: LD_INT 2
61772: ARRAY
61773: PPUSH
61774: LD_VAR 0 3
61778: PPUSH
61779: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
61783: LD_ADDR_EXP 97
61787: PUSH
61788: LD_EXP 97
61792: PPUSH
61793: LD_VAR 0 1
61797: PPUSH
61798: LD_EXP 97
61802: PUSH
61803: LD_VAR 0 1
61807: ARRAY
61808: PPUSH
61809: LD_VAR 0 2
61813: PPUSH
61814: CALL_OW 3
61818: PPUSH
61819: CALL_OW 1
61823: ST_TO_ADDR
// end ; end ;
61824: GO 61575
61826: POP
61827: POP
// end ;
61828: GO 61493
61830: POP
61831: POP
// end ;
61832: PPOPN 4
61834: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
61835: LD_INT 0
61837: PPUSH
61838: PPUSH
// result := false ;
61839: LD_ADDR_VAR 0 4
61843: PUSH
61844: LD_INT 0
61846: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
61847: LD_VAR 0 1
61851: PPUSH
61852: CALL_OW 264
61856: PUSH
61857: LD_EXP 164
61861: EQUAL
61862: NOT
61863: IFFALSE 61867
// exit ;
61865: GO 62107
// index := GetElementIndex ( minersList , unit ) ;
61867: LD_ADDR_VAR 0 5
61871: PUSH
61872: LD_EXP 96
61876: PPUSH
61877: LD_VAR 0 1
61881: PPUSH
61882: CALL 23995 0 2
61886: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
61887: LD_EXP 97
61891: PUSH
61892: LD_VAR 0 5
61896: ARRAY
61897: PUSH
61898: LD_EXP 98
61902: GREATEREQUAL
61903: IFFALSE 61907
// exit ;
61905: GO 62107
// ComMoveXY ( unit , x , y ) ;
61907: LD_VAR 0 1
61911: PPUSH
61912: LD_VAR 0 2
61916: PPUSH
61917: LD_VAR 0 3
61921: PPUSH
61922: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
61926: LD_INT 35
61928: PPUSH
61929: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
61933: LD_VAR 0 1
61937: PPUSH
61938: LD_VAR 0 2
61942: PPUSH
61943: LD_VAR 0 3
61947: PPUSH
61948: CALL 54767 0 3
61952: NOT
61953: PUSH
61954: LD_VAR 0 1
61958: PPUSH
61959: CALL_OW 314
61963: AND
61964: IFFALSE 61968
// exit ;
61966: GO 62107
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
61968: LD_VAR 0 2
61972: PPUSH
61973: LD_VAR 0 3
61977: PPUSH
61978: CALL_OW 428
61982: PUSH
61983: LD_VAR 0 1
61987: EQUAL
61988: PUSH
61989: LD_VAR 0 1
61993: PPUSH
61994: CALL_OW 314
61998: NOT
61999: AND
62000: IFFALSE 61926
// PlaySoundXY ( x , y , PlantMine ) ;
62002: LD_VAR 0 2
62006: PPUSH
62007: LD_VAR 0 3
62011: PPUSH
62012: LD_STRING PlantMine
62014: PPUSH
62015: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
62019: LD_VAR 0 2
62023: PPUSH
62024: LD_VAR 0 3
62028: PPUSH
62029: LD_VAR 0 1
62033: PPUSH
62034: CALL_OW 255
62038: PPUSH
62039: LD_INT 0
62041: PPUSH
62042: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
62046: LD_ADDR_EXP 97
62050: PUSH
62051: LD_EXP 97
62055: PPUSH
62056: LD_VAR 0 5
62060: PUSH
62061: LD_EXP 97
62065: PUSH
62066: LD_VAR 0 5
62070: ARRAY
62071: PUSH
62072: LD_INT 1
62074: PLUS
62075: PUSH
62076: EMPTY
62077: LIST
62078: LIST
62079: PPUSH
62080: LD_VAR 0 2
62084: PUSH
62085: LD_VAR 0 3
62089: PUSH
62090: EMPTY
62091: LIST
62092: LIST
62093: PPUSH
62094: CALL 24210 0 3
62098: ST_TO_ADDR
// result := true ;
62099: LD_ADDR_VAR 0 4
62103: PUSH
62104: LD_INT 1
62106: ST_TO_ADDR
// end ;
62107: LD_VAR 0 4
62111: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
62112: LD_INT 0
62114: PPUSH
62115: PPUSH
62116: PPUSH
// if not unit in minersList then
62117: LD_VAR 0 1
62121: PUSH
62122: LD_EXP 96
62126: IN
62127: NOT
62128: IFFALSE 62132
// exit ;
62130: GO 62524
// index := GetElementIndex ( minersList , unit ) ;
62132: LD_ADDR_VAR 0 6
62136: PUSH
62137: LD_EXP 96
62141: PPUSH
62142: LD_VAR 0 1
62146: PPUSH
62147: CALL 23995 0 2
62151: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
62152: LD_ADDR_VAR 0 5
62156: PUSH
62157: DOUBLE
62158: LD_EXP 97
62162: PUSH
62163: LD_VAR 0 6
62167: ARRAY
62168: INC
62169: ST_TO_ADDR
62170: LD_INT 1
62172: PUSH
62173: FOR_DOWNTO
62174: IFFALSE 62335
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
62176: LD_EXP 97
62180: PUSH
62181: LD_VAR 0 6
62185: ARRAY
62186: PUSH
62187: LD_VAR 0 5
62191: ARRAY
62192: PUSH
62193: LD_INT 1
62195: ARRAY
62196: PUSH
62197: LD_VAR 0 2
62201: EQUAL
62202: PUSH
62203: LD_EXP 97
62207: PUSH
62208: LD_VAR 0 6
62212: ARRAY
62213: PUSH
62214: LD_VAR 0 5
62218: ARRAY
62219: PUSH
62220: LD_INT 2
62222: ARRAY
62223: PUSH
62224: LD_VAR 0 3
62228: EQUAL
62229: AND
62230: IFFALSE 62333
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
62232: LD_EXP 97
62236: PUSH
62237: LD_VAR 0 6
62241: ARRAY
62242: PUSH
62243: LD_VAR 0 5
62247: ARRAY
62248: PUSH
62249: LD_INT 1
62251: ARRAY
62252: PPUSH
62253: LD_EXP 97
62257: PUSH
62258: LD_VAR 0 6
62262: ARRAY
62263: PUSH
62264: LD_VAR 0 5
62268: ARRAY
62269: PUSH
62270: LD_INT 2
62272: ARRAY
62273: PPUSH
62274: LD_VAR 0 1
62278: PPUSH
62279: CALL_OW 255
62283: PPUSH
62284: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
62288: LD_ADDR_EXP 97
62292: PUSH
62293: LD_EXP 97
62297: PPUSH
62298: LD_VAR 0 6
62302: PPUSH
62303: LD_EXP 97
62307: PUSH
62308: LD_VAR 0 6
62312: ARRAY
62313: PPUSH
62314: LD_VAR 0 5
62318: PPUSH
62319: CALL_OW 3
62323: PPUSH
62324: CALL_OW 1
62328: ST_TO_ADDR
// exit ;
62329: POP
62330: POP
62331: GO 62524
// end ; end ;
62333: GO 62173
62335: POP
62336: POP
// for i := minerMinesList [ index ] downto 1 do
62337: LD_ADDR_VAR 0 5
62341: PUSH
62342: DOUBLE
62343: LD_EXP 97
62347: PUSH
62348: LD_VAR 0 6
62352: ARRAY
62353: INC
62354: ST_TO_ADDR
62355: LD_INT 1
62357: PUSH
62358: FOR_DOWNTO
62359: IFFALSE 62522
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
62361: LD_EXP 97
62365: PUSH
62366: LD_VAR 0 6
62370: ARRAY
62371: PUSH
62372: LD_VAR 0 5
62376: ARRAY
62377: PUSH
62378: LD_INT 1
62380: ARRAY
62381: PPUSH
62382: LD_EXP 97
62386: PUSH
62387: LD_VAR 0 6
62391: ARRAY
62392: PUSH
62393: LD_VAR 0 5
62397: ARRAY
62398: PUSH
62399: LD_INT 2
62401: ARRAY
62402: PPUSH
62403: LD_VAR 0 2
62407: PPUSH
62408: LD_VAR 0 3
62412: PPUSH
62413: CALL_OW 298
62417: PUSH
62418: LD_INT 6
62420: LESS
62421: IFFALSE 62520
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
62423: LD_EXP 97
62427: PUSH
62428: LD_VAR 0 6
62432: ARRAY
62433: PUSH
62434: LD_VAR 0 5
62438: ARRAY
62439: PUSH
62440: LD_INT 1
62442: ARRAY
62443: PPUSH
62444: LD_EXP 97
62448: PUSH
62449: LD_VAR 0 6
62453: ARRAY
62454: PUSH
62455: LD_VAR 0 5
62459: ARRAY
62460: PUSH
62461: LD_INT 2
62463: ARRAY
62464: PPUSH
62465: LD_VAR 0 1
62469: PPUSH
62470: CALL_OW 255
62474: PPUSH
62475: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
62479: LD_ADDR_EXP 97
62483: PUSH
62484: LD_EXP 97
62488: PPUSH
62489: LD_VAR 0 6
62493: PPUSH
62494: LD_EXP 97
62498: PUSH
62499: LD_VAR 0 6
62503: ARRAY
62504: PPUSH
62505: LD_VAR 0 5
62509: PPUSH
62510: CALL_OW 3
62514: PPUSH
62515: CALL_OW 1
62519: ST_TO_ADDR
// end ; end ;
62520: GO 62358
62522: POP
62523: POP
// end ;
62524: LD_VAR 0 4
62528: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
62529: LD_INT 0
62531: PPUSH
62532: PPUSH
62533: PPUSH
62534: PPUSH
62535: PPUSH
62536: PPUSH
62537: PPUSH
62538: PPUSH
62539: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
62540: LD_VAR 0 1
62544: PPUSH
62545: CALL_OW 264
62549: PUSH
62550: LD_EXP 164
62554: EQUAL
62555: NOT
62556: PUSH
62557: LD_VAR 0 1
62561: PUSH
62562: LD_EXP 96
62566: IN
62567: NOT
62568: OR
62569: IFFALSE 62573
// exit ;
62571: GO 62895
// index := GetElementIndex ( minersList , unit ) ;
62573: LD_ADDR_VAR 0 6
62577: PUSH
62578: LD_EXP 96
62582: PPUSH
62583: LD_VAR 0 1
62587: PPUSH
62588: CALL 23995 0 2
62592: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
62593: LD_ADDR_VAR 0 8
62597: PUSH
62598: LD_EXP 98
62602: PUSH
62603: LD_EXP 97
62607: PUSH
62608: LD_VAR 0 6
62612: ARRAY
62613: MINUS
62614: ST_TO_ADDR
// if not minesFreeAmount then
62615: LD_VAR 0 8
62619: NOT
62620: IFFALSE 62624
// exit ;
62622: GO 62895
// tmp := [ ] ;
62624: LD_ADDR_VAR 0 7
62628: PUSH
62629: EMPTY
62630: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
62631: LD_ADDR_VAR 0 5
62635: PUSH
62636: DOUBLE
62637: LD_INT 1
62639: DEC
62640: ST_TO_ADDR
62641: LD_VAR 0 8
62645: PUSH
62646: FOR_TO
62647: IFFALSE 62842
// begin _d := rand ( 0 , 5 ) ;
62649: LD_ADDR_VAR 0 11
62653: PUSH
62654: LD_INT 0
62656: PPUSH
62657: LD_INT 5
62659: PPUSH
62660: CALL_OW 12
62664: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
62665: LD_ADDR_VAR 0 12
62669: PUSH
62670: LD_INT 2
62672: PPUSH
62673: LD_INT 6
62675: PPUSH
62676: CALL_OW 12
62680: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
62681: LD_ADDR_VAR 0 9
62685: PUSH
62686: LD_VAR 0 2
62690: PPUSH
62691: LD_VAR 0 11
62695: PPUSH
62696: LD_VAR 0 12
62700: PPUSH
62701: CALL_OW 272
62705: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
62706: LD_ADDR_VAR 0 10
62710: PUSH
62711: LD_VAR 0 3
62715: PPUSH
62716: LD_VAR 0 11
62720: PPUSH
62721: LD_VAR 0 12
62725: PPUSH
62726: CALL_OW 273
62730: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
62731: LD_VAR 0 9
62735: PPUSH
62736: LD_VAR 0 10
62740: PPUSH
62741: CALL_OW 488
62745: PUSH
62746: LD_VAR 0 9
62750: PUSH
62751: LD_VAR 0 10
62755: PUSH
62756: EMPTY
62757: LIST
62758: LIST
62759: PUSH
62760: LD_VAR 0 7
62764: IN
62765: NOT
62766: AND
62767: PUSH
62768: LD_VAR 0 9
62772: PPUSH
62773: LD_VAR 0 10
62777: PPUSH
62778: CALL_OW 458
62782: NOT
62783: AND
62784: IFFALSE 62826
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
62786: LD_ADDR_VAR 0 7
62790: PUSH
62791: LD_VAR 0 7
62795: PPUSH
62796: LD_VAR 0 7
62800: PUSH
62801: LD_INT 1
62803: PLUS
62804: PPUSH
62805: LD_VAR 0 9
62809: PUSH
62810: LD_VAR 0 10
62814: PUSH
62815: EMPTY
62816: LIST
62817: LIST
62818: PPUSH
62819: CALL_OW 1
62823: ST_TO_ADDR
62824: GO 62840
// i := i - 1 ;
62826: LD_ADDR_VAR 0 5
62830: PUSH
62831: LD_VAR 0 5
62835: PUSH
62836: LD_INT 1
62838: MINUS
62839: ST_TO_ADDR
// end ;
62840: GO 62646
62842: POP
62843: POP
// for i in tmp do
62844: LD_ADDR_VAR 0 5
62848: PUSH
62849: LD_VAR 0 7
62853: PUSH
62854: FOR_IN
62855: IFFALSE 62893
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
62857: LD_VAR 0 1
62861: PPUSH
62862: LD_VAR 0 5
62866: PUSH
62867: LD_INT 1
62869: ARRAY
62870: PPUSH
62871: LD_VAR 0 5
62875: PUSH
62876: LD_INT 2
62878: ARRAY
62879: PPUSH
62880: CALL 61835 0 3
62884: NOT
62885: IFFALSE 62891
// exit ;
62887: POP
62888: POP
62889: GO 62895
62891: GO 62854
62893: POP
62894: POP
// end ;
62895: LD_VAR 0 4
62899: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
62900: LD_INT 0
62902: PPUSH
62903: PPUSH
62904: PPUSH
62905: PPUSH
62906: PPUSH
62907: PPUSH
62908: PPUSH
// if not GetClass ( unit ) = class_sniper then
62909: LD_VAR 0 1
62913: PPUSH
62914: CALL_OW 257
62918: PUSH
62919: LD_INT 5
62921: EQUAL
62922: NOT
62923: IFFALSE 62927
// exit ;
62925: GO 63315
// dist := 8 ;
62927: LD_ADDR_VAR 0 5
62931: PUSH
62932: LD_INT 8
62934: ST_TO_ADDR
// viewRange := 12 ;
62935: LD_ADDR_VAR 0 7
62939: PUSH
62940: LD_INT 12
62942: ST_TO_ADDR
// side := GetSide ( unit ) ;
62943: LD_ADDR_VAR 0 6
62947: PUSH
62948: LD_VAR 0 1
62952: PPUSH
62953: CALL_OW 255
62957: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
62958: LD_INT 61
62960: PPUSH
62961: LD_VAR 0 6
62965: PPUSH
62966: CALL_OW 321
62970: PUSH
62971: LD_INT 2
62973: EQUAL
62974: IFFALSE 62984
// viewRange := 16 ;
62976: LD_ADDR_VAR 0 7
62980: PUSH
62981: LD_INT 16
62983: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
62984: LD_VAR 0 1
62988: PPUSH
62989: LD_VAR 0 2
62993: PPUSH
62994: LD_VAR 0 3
62998: PPUSH
62999: CALL_OW 297
63003: PUSH
63004: LD_VAR 0 5
63008: GREATER
63009: IFFALSE 63088
// begin ComMoveXY ( unit , x , y ) ;
63011: LD_VAR 0 1
63015: PPUSH
63016: LD_VAR 0 2
63020: PPUSH
63021: LD_VAR 0 3
63025: PPUSH
63026: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
63030: LD_INT 35
63032: PPUSH
63033: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
63037: LD_VAR 0 1
63041: PPUSH
63042: LD_VAR 0 2
63046: PPUSH
63047: LD_VAR 0 3
63051: PPUSH
63052: CALL 54767 0 3
63056: NOT
63057: IFFALSE 63061
// exit ;
63059: GO 63315
// until GetDistUnitXY ( unit , x , y ) < dist ;
63061: LD_VAR 0 1
63065: PPUSH
63066: LD_VAR 0 2
63070: PPUSH
63071: LD_VAR 0 3
63075: PPUSH
63076: CALL_OW 297
63080: PUSH
63081: LD_VAR 0 5
63085: LESS
63086: IFFALSE 63030
// end ; ComTurnXY ( unit , x , y ) ;
63088: LD_VAR 0 1
63092: PPUSH
63093: LD_VAR 0 2
63097: PPUSH
63098: LD_VAR 0 3
63102: PPUSH
63103: CALL_OW 118
// wait ( 5 ) ;
63107: LD_INT 5
63109: PPUSH
63110: CALL_OW 67
// _d := GetDir ( unit ) ;
63114: LD_ADDR_VAR 0 10
63118: PUSH
63119: LD_VAR 0 1
63123: PPUSH
63124: CALL_OW 254
63128: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
63129: LD_ADDR_VAR 0 8
63133: PUSH
63134: LD_VAR 0 1
63138: PPUSH
63139: CALL_OW 250
63143: PPUSH
63144: LD_VAR 0 10
63148: PPUSH
63149: LD_VAR 0 5
63153: PPUSH
63154: CALL_OW 272
63158: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
63159: LD_ADDR_VAR 0 9
63163: PUSH
63164: LD_VAR 0 1
63168: PPUSH
63169: CALL_OW 251
63173: PPUSH
63174: LD_VAR 0 10
63178: PPUSH
63179: LD_VAR 0 5
63183: PPUSH
63184: CALL_OW 273
63188: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
63189: LD_VAR 0 8
63193: PPUSH
63194: LD_VAR 0 9
63198: PPUSH
63199: CALL_OW 488
63203: NOT
63204: IFFALSE 63208
// exit ;
63206: GO 63315
// ComAnimCustom ( unit , 1 ) ;
63208: LD_VAR 0 1
63212: PPUSH
63213: LD_INT 1
63215: PPUSH
63216: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
63220: LD_VAR 0 8
63224: PPUSH
63225: LD_VAR 0 9
63229: PPUSH
63230: LD_VAR 0 6
63234: PPUSH
63235: LD_VAR 0 7
63239: PPUSH
63240: CALL_OW 330
// repeat wait ( 1 ) ;
63244: LD_INT 1
63246: PPUSH
63247: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
63251: LD_VAR 0 1
63255: PPUSH
63256: CALL_OW 316
63260: PUSH
63261: LD_VAR 0 1
63265: PPUSH
63266: CALL_OW 314
63270: OR
63271: PUSH
63272: LD_VAR 0 1
63276: PPUSH
63277: CALL_OW 302
63281: NOT
63282: OR
63283: PUSH
63284: LD_VAR 0 1
63288: PPUSH
63289: CALL_OW 301
63293: OR
63294: IFFALSE 63244
// RemoveSeeing ( _x , _y , side ) ;
63296: LD_VAR 0 8
63300: PPUSH
63301: LD_VAR 0 9
63305: PPUSH
63306: LD_VAR 0 6
63310: PPUSH
63311: CALL_OW 331
// end ; end_of_file
63315: LD_VAR 0 4
63319: RET
// every 0 0$1 do
63320: GO 63322
63322: DISABLE
// begin enable ;
63323: ENABLE
// ToLua ( updateTimer( & tick & ); ) ;
63324: LD_STRING updateTimer(
63326: PUSH
63327: LD_OWVAR 1
63331: STR
63332: PUSH
63333: LD_STRING );
63335: STR
63336: PPUSH
63337: CALL_OW 559
// end ;
63341: END
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
63342: LD_INT 0
63344: PPUSH
// if p2 = 100 then
63345: LD_VAR 0 2
63349: PUSH
63350: LD_INT 100
63352: EQUAL
63353: IFFALSE 64356
// begin if not StreamModeActive then
63355: LD_EXP 99
63359: NOT
63360: IFFALSE 63370
// StreamModeActive := true ;
63362: LD_ADDR_EXP 99
63366: PUSH
63367: LD_INT 1
63369: ST_TO_ADDR
// if p3 = 0 then
63370: LD_VAR 0 3
63374: PUSH
63375: LD_INT 0
63377: EQUAL
63378: IFFALSE 63384
// InitStreamMode ;
63380: CALL 64516 0 0
// if p3 = 1 then
63384: LD_VAR 0 3
63388: PUSH
63389: LD_INT 1
63391: EQUAL
63392: IFFALSE 63402
// sRocket := true ;
63394: LD_ADDR_EXP 104
63398: PUSH
63399: LD_INT 1
63401: ST_TO_ADDR
// if p3 = 2 then
63402: LD_VAR 0 3
63406: PUSH
63407: LD_INT 2
63409: EQUAL
63410: IFFALSE 63420
// sSpeed := true ;
63412: LD_ADDR_EXP 103
63416: PUSH
63417: LD_INT 1
63419: ST_TO_ADDR
// if p3 = 3 then
63420: LD_VAR 0 3
63424: PUSH
63425: LD_INT 3
63427: EQUAL
63428: IFFALSE 63438
// sEngine := true ;
63430: LD_ADDR_EXP 105
63434: PUSH
63435: LD_INT 1
63437: ST_TO_ADDR
// if p3 = 4 then
63438: LD_VAR 0 3
63442: PUSH
63443: LD_INT 4
63445: EQUAL
63446: IFFALSE 63456
// sSpec := true ;
63448: LD_ADDR_EXP 102
63452: PUSH
63453: LD_INT 1
63455: ST_TO_ADDR
// if p3 = 5 then
63456: LD_VAR 0 3
63460: PUSH
63461: LD_INT 5
63463: EQUAL
63464: IFFALSE 63474
// sLevel := true ;
63466: LD_ADDR_EXP 106
63470: PUSH
63471: LD_INT 1
63473: ST_TO_ADDR
// if p3 = 6 then
63474: LD_VAR 0 3
63478: PUSH
63479: LD_INT 6
63481: EQUAL
63482: IFFALSE 63492
// sArmoury := true ;
63484: LD_ADDR_EXP 107
63488: PUSH
63489: LD_INT 1
63491: ST_TO_ADDR
// if p3 = 7 then
63492: LD_VAR 0 3
63496: PUSH
63497: LD_INT 7
63499: EQUAL
63500: IFFALSE 63510
// sRadar := true ;
63502: LD_ADDR_EXP 108
63506: PUSH
63507: LD_INT 1
63509: ST_TO_ADDR
// if p3 = 8 then
63510: LD_VAR 0 3
63514: PUSH
63515: LD_INT 8
63517: EQUAL
63518: IFFALSE 63528
// sBunker := true ;
63520: LD_ADDR_EXP 109
63524: PUSH
63525: LD_INT 1
63527: ST_TO_ADDR
// if p3 = 9 then
63528: LD_VAR 0 3
63532: PUSH
63533: LD_INT 9
63535: EQUAL
63536: IFFALSE 63546
// sHack := true ;
63538: LD_ADDR_EXP 110
63542: PUSH
63543: LD_INT 1
63545: ST_TO_ADDR
// if p3 = 10 then
63546: LD_VAR 0 3
63550: PUSH
63551: LD_INT 10
63553: EQUAL
63554: IFFALSE 63564
// sFire := true ;
63556: LD_ADDR_EXP 111
63560: PUSH
63561: LD_INT 1
63563: ST_TO_ADDR
// if p3 = 11 then
63564: LD_VAR 0 3
63568: PUSH
63569: LD_INT 11
63571: EQUAL
63572: IFFALSE 63582
// sRefresh := true ;
63574: LD_ADDR_EXP 112
63578: PUSH
63579: LD_INT 1
63581: ST_TO_ADDR
// if p3 = 12 then
63582: LD_VAR 0 3
63586: PUSH
63587: LD_INT 12
63589: EQUAL
63590: IFFALSE 63600
// sExp := true ;
63592: LD_ADDR_EXP 113
63596: PUSH
63597: LD_INT 1
63599: ST_TO_ADDR
// if p3 = 13 then
63600: LD_VAR 0 3
63604: PUSH
63605: LD_INT 13
63607: EQUAL
63608: IFFALSE 63618
// sDepot := true ;
63610: LD_ADDR_EXP 114
63614: PUSH
63615: LD_INT 1
63617: ST_TO_ADDR
// if p3 = 14 then
63618: LD_VAR 0 3
63622: PUSH
63623: LD_INT 14
63625: EQUAL
63626: IFFALSE 63636
// sFlag := true ;
63628: LD_ADDR_EXP 115
63632: PUSH
63633: LD_INT 1
63635: ST_TO_ADDR
// if p3 = 15 then
63636: LD_VAR 0 3
63640: PUSH
63641: LD_INT 15
63643: EQUAL
63644: IFFALSE 63654
// sKamikadze := true ;
63646: LD_ADDR_EXP 123
63650: PUSH
63651: LD_INT 1
63653: ST_TO_ADDR
// if p3 = 16 then
63654: LD_VAR 0 3
63658: PUSH
63659: LD_INT 16
63661: EQUAL
63662: IFFALSE 63672
// sTroll := true ;
63664: LD_ADDR_EXP 124
63668: PUSH
63669: LD_INT 1
63671: ST_TO_ADDR
// if p3 = 17 then
63672: LD_VAR 0 3
63676: PUSH
63677: LD_INT 17
63679: EQUAL
63680: IFFALSE 63690
// sSlow := true ;
63682: LD_ADDR_EXP 125
63686: PUSH
63687: LD_INT 1
63689: ST_TO_ADDR
// if p3 = 18 then
63690: LD_VAR 0 3
63694: PUSH
63695: LD_INT 18
63697: EQUAL
63698: IFFALSE 63708
// sLack := true ;
63700: LD_ADDR_EXP 126
63704: PUSH
63705: LD_INT 1
63707: ST_TO_ADDR
// if p3 = 19 then
63708: LD_VAR 0 3
63712: PUSH
63713: LD_INT 19
63715: EQUAL
63716: IFFALSE 63726
// sTank := true ;
63718: LD_ADDR_EXP 128
63722: PUSH
63723: LD_INT 1
63725: ST_TO_ADDR
// if p3 = 20 then
63726: LD_VAR 0 3
63730: PUSH
63731: LD_INT 20
63733: EQUAL
63734: IFFALSE 63744
// sRemote := true ;
63736: LD_ADDR_EXP 129
63740: PUSH
63741: LD_INT 1
63743: ST_TO_ADDR
// if p3 = 21 then
63744: LD_VAR 0 3
63748: PUSH
63749: LD_INT 21
63751: EQUAL
63752: IFFALSE 63762
// sPowell := true ;
63754: LD_ADDR_EXP 130
63758: PUSH
63759: LD_INT 1
63761: ST_TO_ADDR
// if p3 = 22 then
63762: LD_VAR 0 3
63766: PUSH
63767: LD_INT 22
63769: EQUAL
63770: IFFALSE 63780
// sTeleport := true ;
63772: LD_ADDR_EXP 133
63776: PUSH
63777: LD_INT 1
63779: ST_TO_ADDR
// if p3 = 23 then
63780: LD_VAR 0 3
63784: PUSH
63785: LD_INT 23
63787: EQUAL
63788: IFFALSE 63798
// sOilTower := true ;
63790: LD_ADDR_EXP 135
63794: PUSH
63795: LD_INT 1
63797: ST_TO_ADDR
// if p3 = 24 then
63798: LD_VAR 0 3
63802: PUSH
63803: LD_INT 24
63805: EQUAL
63806: IFFALSE 63816
// sShovel := true ;
63808: LD_ADDR_EXP 136
63812: PUSH
63813: LD_INT 1
63815: ST_TO_ADDR
// if p3 = 25 then
63816: LD_VAR 0 3
63820: PUSH
63821: LD_INT 25
63823: EQUAL
63824: IFFALSE 63834
// sSheik := true ;
63826: LD_ADDR_EXP 137
63830: PUSH
63831: LD_INT 1
63833: ST_TO_ADDR
// if p3 = 26 then
63834: LD_VAR 0 3
63838: PUSH
63839: LD_INT 26
63841: EQUAL
63842: IFFALSE 63852
// sEarthquake := true ;
63844: LD_ADDR_EXP 139
63848: PUSH
63849: LD_INT 1
63851: ST_TO_ADDR
// if p3 = 27 then
63852: LD_VAR 0 3
63856: PUSH
63857: LD_INT 27
63859: EQUAL
63860: IFFALSE 63870
// sAI := true ;
63862: LD_ADDR_EXP 140
63866: PUSH
63867: LD_INT 1
63869: ST_TO_ADDR
// if p3 = 28 then
63870: LD_VAR 0 3
63874: PUSH
63875: LD_INT 28
63877: EQUAL
63878: IFFALSE 63888
// sCargo := true ;
63880: LD_ADDR_EXP 143
63884: PUSH
63885: LD_INT 1
63887: ST_TO_ADDR
// if p3 = 29 then
63888: LD_VAR 0 3
63892: PUSH
63893: LD_INT 29
63895: EQUAL
63896: IFFALSE 63906
// sDLaser := true ;
63898: LD_ADDR_EXP 144
63902: PUSH
63903: LD_INT 1
63905: ST_TO_ADDR
// if p3 = 30 then
63906: LD_VAR 0 3
63910: PUSH
63911: LD_INT 30
63913: EQUAL
63914: IFFALSE 63924
// sExchange := true ;
63916: LD_ADDR_EXP 145
63920: PUSH
63921: LD_INT 1
63923: ST_TO_ADDR
// if p3 = 31 then
63924: LD_VAR 0 3
63928: PUSH
63929: LD_INT 31
63931: EQUAL
63932: IFFALSE 63942
// sFac := true ;
63934: LD_ADDR_EXP 146
63938: PUSH
63939: LD_INT 1
63941: ST_TO_ADDR
// if p3 = 32 then
63942: LD_VAR 0 3
63946: PUSH
63947: LD_INT 32
63949: EQUAL
63950: IFFALSE 63960
// sPower := true ;
63952: LD_ADDR_EXP 147
63956: PUSH
63957: LD_INT 1
63959: ST_TO_ADDR
// if p3 = 33 then
63960: LD_VAR 0 3
63964: PUSH
63965: LD_INT 33
63967: EQUAL
63968: IFFALSE 63978
// sRandom := true ;
63970: LD_ADDR_EXP 148
63974: PUSH
63975: LD_INT 1
63977: ST_TO_ADDR
// if p3 = 34 then
63978: LD_VAR 0 3
63982: PUSH
63983: LD_INT 34
63985: EQUAL
63986: IFFALSE 63996
// sShield := true ;
63988: LD_ADDR_EXP 149
63992: PUSH
63993: LD_INT 1
63995: ST_TO_ADDR
// if p3 = 35 then
63996: LD_VAR 0 3
64000: PUSH
64001: LD_INT 35
64003: EQUAL
64004: IFFALSE 64014
// sTime := true ;
64006: LD_ADDR_EXP 150
64010: PUSH
64011: LD_INT 1
64013: ST_TO_ADDR
// if p3 = 36 then
64014: LD_VAR 0 3
64018: PUSH
64019: LD_INT 36
64021: EQUAL
64022: IFFALSE 64032
// sTools := true ;
64024: LD_ADDR_EXP 151
64028: PUSH
64029: LD_INT 1
64031: ST_TO_ADDR
// if p3 = 101 then
64032: LD_VAR 0 3
64036: PUSH
64037: LD_INT 101
64039: EQUAL
64040: IFFALSE 64050
// sSold := true ;
64042: LD_ADDR_EXP 116
64046: PUSH
64047: LD_INT 1
64049: ST_TO_ADDR
// if p3 = 102 then
64050: LD_VAR 0 3
64054: PUSH
64055: LD_INT 102
64057: EQUAL
64058: IFFALSE 64068
// sDiff := true ;
64060: LD_ADDR_EXP 117
64064: PUSH
64065: LD_INT 1
64067: ST_TO_ADDR
// if p3 = 103 then
64068: LD_VAR 0 3
64072: PUSH
64073: LD_INT 103
64075: EQUAL
64076: IFFALSE 64086
// sFog := true ;
64078: LD_ADDR_EXP 120
64082: PUSH
64083: LD_INT 1
64085: ST_TO_ADDR
// if p3 = 104 then
64086: LD_VAR 0 3
64090: PUSH
64091: LD_INT 104
64093: EQUAL
64094: IFFALSE 64104
// sReset := true ;
64096: LD_ADDR_EXP 121
64100: PUSH
64101: LD_INT 1
64103: ST_TO_ADDR
// if p3 = 105 then
64104: LD_VAR 0 3
64108: PUSH
64109: LD_INT 105
64111: EQUAL
64112: IFFALSE 64122
// sSun := true ;
64114: LD_ADDR_EXP 122
64118: PUSH
64119: LD_INT 1
64121: ST_TO_ADDR
// if p3 = 106 then
64122: LD_VAR 0 3
64126: PUSH
64127: LD_INT 106
64129: EQUAL
64130: IFFALSE 64140
// sTiger := true ;
64132: LD_ADDR_EXP 118
64136: PUSH
64137: LD_INT 1
64139: ST_TO_ADDR
// if p3 = 107 then
64140: LD_VAR 0 3
64144: PUSH
64145: LD_INT 107
64147: EQUAL
64148: IFFALSE 64158
// sBomb := true ;
64150: LD_ADDR_EXP 119
64154: PUSH
64155: LD_INT 1
64157: ST_TO_ADDR
// if p3 = 108 then
64158: LD_VAR 0 3
64162: PUSH
64163: LD_INT 108
64165: EQUAL
64166: IFFALSE 64176
// sWound := true ;
64168: LD_ADDR_EXP 127
64172: PUSH
64173: LD_INT 1
64175: ST_TO_ADDR
// if p3 = 109 then
64176: LD_VAR 0 3
64180: PUSH
64181: LD_INT 109
64183: EQUAL
64184: IFFALSE 64194
// sBetray := true ;
64186: LD_ADDR_EXP 131
64190: PUSH
64191: LD_INT 1
64193: ST_TO_ADDR
// if p3 = 110 then
64194: LD_VAR 0 3
64198: PUSH
64199: LD_INT 110
64201: EQUAL
64202: IFFALSE 64212
// sContamin := true ;
64204: LD_ADDR_EXP 132
64208: PUSH
64209: LD_INT 1
64211: ST_TO_ADDR
// if p3 = 111 then
64212: LD_VAR 0 3
64216: PUSH
64217: LD_INT 111
64219: EQUAL
64220: IFFALSE 64230
// sOil := true ;
64222: LD_ADDR_EXP 134
64226: PUSH
64227: LD_INT 1
64229: ST_TO_ADDR
// if p3 = 112 then
64230: LD_VAR 0 3
64234: PUSH
64235: LD_INT 112
64237: EQUAL
64238: IFFALSE 64248
// sStu := true ;
64240: LD_ADDR_EXP 138
64244: PUSH
64245: LD_INT 1
64247: ST_TO_ADDR
// if p3 = 113 then
64248: LD_VAR 0 3
64252: PUSH
64253: LD_INT 113
64255: EQUAL
64256: IFFALSE 64266
// sBazooka := true ;
64258: LD_ADDR_EXP 141
64262: PUSH
64263: LD_INT 1
64265: ST_TO_ADDR
// if p3 = 114 then
64266: LD_VAR 0 3
64270: PUSH
64271: LD_INT 114
64273: EQUAL
64274: IFFALSE 64284
// sMortar := true ;
64276: LD_ADDR_EXP 142
64280: PUSH
64281: LD_INT 1
64283: ST_TO_ADDR
// if p3 = 115 then
64284: LD_VAR 0 3
64288: PUSH
64289: LD_INT 115
64291: EQUAL
64292: IFFALSE 64302
// sRanger := true ;
64294: LD_ADDR_EXP 152
64298: PUSH
64299: LD_INT 1
64301: ST_TO_ADDR
// if p3 = 116 then
64302: LD_VAR 0 3
64306: PUSH
64307: LD_INT 116
64309: EQUAL
64310: IFFALSE 64320
// sComputer := true ;
64312: LD_ADDR_EXP 153
64316: PUSH
64317: LD_INT 1
64319: ST_TO_ADDR
// if p3 = 117 then
64320: LD_VAR 0 3
64324: PUSH
64325: LD_INT 117
64327: EQUAL
64328: IFFALSE 64338
// s30 := true ;
64330: LD_ADDR_EXP 154
64334: PUSH
64335: LD_INT 1
64337: ST_TO_ADDR
// if p3 = 118 then
64338: LD_VAR 0 3
64342: PUSH
64343: LD_INT 118
64345: EQUAL
64346: IFFALSE 64356
// s60 := true ;
64348: LD_ADDR_EXP 155
64352: PUSH
64353: LD_INT 1
64355: ST_TO_ADDR
// end ; if p2 = 101 then
64356: LD_VAR 0 2
64360: PUSH
64361: LD_INT 101
64363: EQUAL
64364: IFFALSE 64492
// begin case p3 of 1 :
64366: LD_VAR 0 3
64370: PUSH
64371: LD_INT 1
64373: DOUBLE
64374: EQUAL
64375: IFTRUE 64379
64377: GO 64386
64379: POP
// hHackUnlimitedResources ; 2 :
64380: CALL 76088 0 0
64384: GO 64492
64386: LD_INT 2
64388: DOUBLE
64389: EQUAL
64390: IFTRUE 64394
64392: GO 64401
64394: POP
// hHackSetLevel10 ; 3 :
64395: CALL 76221 0 0
64399: GO 64492
64401: LD_INT 3
64403: DOUBLE
64404: EQUAL
64405: IFTRUE 64409
64407: GO 64416
64409: POP
// hHackSetLevel10YourUnits ; 4 :
64410: CALL 76306 0 0
64414: GO 64492
64416: LD_INT 4
64418: DOUBLE
64419: EQUAL
64420: IFTRUE 64424
64422: GO 64431
64424: POP
// hHackInvincible ; 5 :
64425: CALL 76754 0 0
64429: GO 64492
64431: LD_INT 5
64433: DOUBLE
64434: EQUAL
64435: IFTRUE 64439
64437: GO 64446
64439: POP
// hHackInvisible ; 6 :
64440: CALL 76865 0 0
64444: GO 64492
64446: LD_INT 6
64448: DOUBLE
64449: EQUAL
64450: IFTRUE 64454
64452: GO 64461
64454: POP
// hHackChangeYourSide ; 7 :
64455: CALL 76922 0 0
64459: GO 64492
64461: LD_INT 7
64463: DOUBLE
64464: EQUAL
64465: IFTRUE 64469
64467: GO 64476
64469: POP
// hHackChangeUnitSide ; 8 :
64470: CALL 76964 0 0
64474: GO 64492
64476: LD_INT 8
64478: DOUBLE
64479: EQUAL
64480: IFTRUE 64484
64482: GO 64491
64484: POP
// hHackFog ; end ;
64485: CALL 77065 0 0
64489: GO 64492
64491: POP
// end ; end ;
64492: LD_VAR 0 7
64496: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger , sComputer , s30 , s60 ; every 0 0$1 do
64497: GO 64499
64499: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
64500: LD_STRING initStreamRollete();
64502: PPUSH
64503: CALL_OW 559
// InitStreamMode ;
64507: CALL 64516 0 0
// DefineStreamItems ( ) ;
64511: CALL 64980 0 0
// end ;
64515: END
// function InitStreamMode ; begin
64516: LD_INT 0
64518: PPUSH
// streamModeActive := false ;
64519: LD_ADDR_EXP 99
64523: PUSH
64524: LD_INT 0
64526: ST_TO_ADDR
// normalCounter := 36 ;
64527: LD_ADDR_EXP 100
64531: PUSH
64532: LD_INT 36
64534: ST_TO_ADDR
// hardcoreCounter := 16 ;
64535: LD_ADDR_EXP 101
64539: PUSH
64540: LD_INT 16
64542: ST_TO_ADDR
// sRocket := false ;
64543: LD_ADDR_EXP 104
64547: PUSH
64548: LD_INT 0
64550: ST_TO_ADDR
// sSpeed := false ;
64551: LD_ADDR_EXP 103
64555: PUSH
64556: LD_INT 0
64558: ST_TO_ADDR
// sEngine := false ;
64559: LD_ADDR_EXP 105
64563: PUSH
64564: LD_INT 0
64566: ST_TO_ADDR
// sSpec := false ;
64567: LD_ADDR_EXP 102
64571: PUSH
64572: LD_INT 0
64574: ST_TO_ADDR
// sLevel := false ;
64575: LD_ADDR_EXP 106
64579: PUSH
64580: LD_INT 0
64582: ST_TO_ADDR
// sArmoury := false ;
64583: LD_ADDR_EXP 107
64587: PUSH
64588: LD_INT 0
64590: ST_TO_ADDR
// sRadar := false ;
64591: LD_ADDR_EXP 108
64595: PUSH
64596: LD_INT 0
64598: ST_TO_ADDR
// sBunker := false ;
64599: LD_ADDR_EXP 109
64603: PUSH
64604: LD_INT 0
64606: ST_TO_ADDR
// sHack := false ;
64607: LD_ADDR_EXP 110
64611: PUSH
64612: LD_INT 0
64614: ST_TO_ADDR
// sFire := false ;
64615: LD_ADDR_EXP 111
64619: PUSH
64620: LD_INT 0
64622: ST_TO_ADDR
// sRefresh := false ;
64623: LD_ADDR_EXP 112
64627: PUSH
64628: LD_INT 0
64630: ST_TO_ADDR
// sExp := false ;
64631: LD_ADDR_EXP 113
64635: PUSH
64636: LD_INT 0
64638: ST_TO_ADDR
// sDepot := false ;
64639: LD_ADDR_EXP 114
64643: PUSH
64644: LD_INT 0
64646: ST_TO_ADDR
// sFlag := false ;
64647: LD_ADDR_EXP 115
64651: PUSH
64652: LD_INT 0
64654: ST_TO_ADDR
// sKamikadze := false ;
64655: LD_ADDR_EXP 123
64659: PUSH
64660: LD_INT 0
64662: ST_TO_ADDR
// sTroll := false ;
64663: LD_ADDR_EXP 124
64667: PUSH
64668: LD_INT 0
64670: ST_TO_ADDR
// sSlow := false ;
64671: LD_ADDR_EXP 125
64675: PUSH
64676: LD_INT 0
64678: ST_TO_ADDR
// sLack := false ;
64679: LD_ADDR_EXP 126
64683: PUSH
64684: LD_INT 0
64686: ST_TO_ADDR
// sTank := false ;
64687: LD_ADDR_EXP 128
64691: PUSH
64692: LD_INT 0
64694: ST_TO_ADDR
// sRemote := false ;
64695: LD_ADDR_EXP 129
64699: PUSH
64700: LD_INT 0
64702: ST_TO_ADDR
// sPowell := false ;
64703: LD_ADDR_EXP 130
64707: PUSH
64708: LD_INT 0
64710: ST_TO_ADDR
// sTeleport := false ;
64711: LD_ADDR_EXP 133
64715: PUSH
64716: LD_INT 0
64718: ST_TO_ADDR
// sOilTower := false ;
64719: LD_ADDR_EXP 135
64723: PUSH
64724: LD_INT 0
64726: ST_TO_ADDR
// sShovel := false ;
64727: LD_ADDR_EXP 136
64731: PUSH
64732: LD_INT 0
64734: ST_TO_ADDR
// sSheik := false ;
64735: LD_ADDR_EXP 137
64739: PUSH
64740: LD_INT 0
64742: ST_TO_ADDR
// sEarthquake := false ;
64743: LD_ADDR_EXP 139
64747: PUSH
64748: LD_INT 0
64750: ST_TO_ADDR
// sAI := false ;
64751: LD_ADDR_EXP 140
64755: PUSH
64756: LD_INT 0
64758: ST_TO_ADDR
// sCargo := false ;
64759: LD_ADDR_EXP 143
64763: PUSH
64764: LD_INT 0
64766: ST_TO_ADDR
// sDLaser := false ;
64767: LD_ADDR_EXP 144
64771: PUSH
64772: LD_INT 0
64774: ST_TO_ADDR
// sExchange := false ;
64775: LD_ADDR_EXP 145
64779: PUSH
64780: LD_INT 0
64782: ST_TO_ADDR
// sFac := false ;
64783: LD_ADDR_EXP 146
64787: PUSH
64788: LD_INT 0
64790: ST_TO_ADDR
// sPower := false ;
64791: LD_ADDR_EXP 147
64795: PUSH
64796: LD_INT 0
64798: ST_TO_ADDR
// sRandom := false ;
64799: LD_ADDR_EXP 148
64803: PUSH
64804: LD_INT 0
64806: ST_TO_ADDR
// sShield := false ;
64807: LD_ADDR_EXP 149
64811: PUSH
64812: LD_INT 0
64814: ST_TO_ADDR
// sTime := false ;
64815: LD_ADDR_EXP 150
64819: PUSH
64820: LD_INT 0
64822: ST_TO_ADDR
// sTools := false ;
64823: LD_ADDR_EXP 151
64827: PUSH
64828: LD_INT 0
64830: ST_TO_ADDR
// sSold := false ;
64831: LD_ADDR_EXP 116
64835: PUSH
64836: LD_INT 0
64838: ST_TO_ADDR
// sDiff := false ;
64839: LD_ADDR_EXP 117
64843: PUSH
64844: LD_INT 0
64846: ST_TO_ADDR
// sFog := false ;
64847: LD_ADDR_EXP 120
64851: PUSH
64852: LD_INT 0
64854: ST_TO_ADDR
// sReset := false ;
64855: LD_ADDR_EXP 121
64859: PUSH
64860: LD_INT 0
64862: ST_TO_ADDR
// sSun := false ;
64863: LD_ADDR_EXP 122
64867: PUSH
64868: LD_INT 0
64870: ST_TO_ADDR
// sTiger := false ;
64871: LD_ADDR_EXP 118
64875: PUSH
64876: LD_INT 0
64878: ST_TO_ADDR
// sBomb := false ;
64879: LD_ADDR_EXP 119
64883: PUSH
64884: LD_INT 0
64886: ST_TO_ADDR
// sWound := false ;
64887: LD_ADDR_EXP 127
64891: PUSH
64892: LD_INT 0
64894: ST_TO_ADDR
// sBetray := false ;
64895: LD_ADDR_EXP 131
64899: PUSH
64900: LD_INT 0
64902: ST_TO_ADDR
// sContamin := false ;
64903: LD_ADDR_EXP 132
64907: PUSH
64908: LD_INT 0
64910: ST_TO_ADDR
// sOil := false ;
64911: LD_ADDR_EXP 134
64915: PUSH
64916: LD_INT 0
64918: ST_TO_ADDR
// sStu := false ;
64919: LD_ADDR_EXP 138
64923: PUSH
64924: LD_INT 0
64926: ST_TO_ADDR
// sBazooka := false ;
64927: LD_ADDR_EXP 141
64931: PUSH
64932: LD_INT 0
64934: ST_TO_ADDR
// sMortar := false ;
64935: LD_ADDR_EXP 142
64939: PUSH
64940: LD_INT 0
64942: ST_TO_ADDR
// sRanger := false ;
64943: LD_ADDR_EXP 152
64947: PUSH
64948: LD_INT 0
64950: ST_TO_ADDR
// sComputer := false ;
64951: LD_ADDR_EXP 153
64955: PUSH
64956: LD_INT 0
64958: ST_TO_ADDR
// s30 := false ;
64959: LD_ADDR_EXP 154
64963: PUSH
64964: LD_INT 0
64966: ST_TO_ADDR
// s60 := false ;
64967: LD_ADDR_EXP 155
64971: PUSH
64972: LD_INT 0
64974: ST_TO_ADDR
// end ;
64975: LD_VAR 0 1
64979: RET
// function DefineStreamItems ( ) ; var tmp , normal , hardcore , i ; begin
64980: LD_INT 0
64982: PPUSH
64983: PPUSH
64984: PPUSH
64985: PPUSH
64986: PPUSH
// result := [ ] ;
64987: LD_ADDR_VAR 0 1
64991: PUSH
64992: EMPTY
64993: ST_TO_ADDR
// if campaign_id = 1 then
64994: LD_OWVAR 69
64998: PUSH
64999: LD_INT 1
65001: EQUAL
65002: IFFALSE 68168
// begin case mission_number of 1 :
65004: LD_OWVAR 70
65008: PUSH
65009: LD_INT 1
65011: DOUBLE
65012: EQUAL
65013: IFTRUE 65017
65015: GO 65093
65017: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 , 116 , 117 , 118 ] ] ; 2 :
65018: LD_ADDR_VAR 0 1
65022: PUSH
65023: LD_INT 2
65025: PUSH
65026: LD_INT 4
65028: PUSH
65029: LD_INT 11
65031: PUSH
65032: LD_INT 12
65034: PUSH
65035: LD_INT 15
65037: PUSH
65038: LD_INT 16
65040: PUSH
65041: LD_INT 22
65043: PUSH
65044: LD_INT 23
65046: PUSH
65047: LD_INT 26
65049: PUSH
65050: EMPTY
65051: LIST
65052: LIST
65053: LIST
65054: LIST
65055: LIST
65056: LIST
65057: LIST
65058: LIST
65059: LIST
65060: PUSH
65061: LD_INT 101
65063: PUSH
65064: LD_INT 102
65066: PUSH
65067: LD_INT 106
65069: PUSH
65070: LD_INT 116
65072: PUSH
65073: LD_INT 117
65075: PUSH
65076: LD_INT 118
65078: PUSH
65079: EMPTY
65080: LIST
65081: LIST
65082: LIST
65083: LIST
65084: LIST
65085: LIST
65086: PUSH
65087: EMPTY
65088: LIST
65089: LIST
65090: ST_TO_ADDR
65091: GO 68166
65093: LD_INT 2
65095: DOUBLE
65096: EQUAL
65097: IFTRUE 65101
65099: GO 65185
65101: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 3 :
65102: LD_ADDR_VAR 0 1
65106: PUSH
65107: LD_INT 2
65109: PUSH
65110: LD_INT 4
65112: PUSH
65113: LD_INT 11
65115: PUSH
65116: LD_INT 12
65118: PUSH
65119: LD_INT 15
65121: PUSH
65122: LD_INT 16
65124: PUSH
65125: LD_INT 22
65127: PUSH
65128: LD_INT 23
65130: PUSH
65131: LD_INT 26
65133: PUSH
65134: EMPTY
65135: LIST
65136: LIST
65137: LIST
65138: LIST
65139: LIST
65140: LIST
65141: LIST
65142: LIST
65143: LIST
65144: PUSH
65145: LD_INT 101
65147: PUSH
65148: LD_INT 102
65150: PUSH
65151: LD_INT 105
65153: PUSH
65154: LD_INT 106
65156: PUSH
65157: LD_INT 108
65159: PUSH
65160: LD_INT 116
65162: PUSH
65163: LD_INT 117
65165: PUSH
65166: LD_INT 118
65168: PUSH
65169: EMPTY
65170: LIST
65171: LIST
65172: LIST
65173: LIST
65174: LIST
65175: LIST
65176: LIST
65177: LIST
65178: PUSH
65179: EMPTY
65180: LIST
65181: LIST
65182: ST_TO_ADDR
65183: GO 68166
65185: LD_INT 3
65187: DOUBLE
65188: EQUAL
65189: IFTRUE 65193
65191: GO 65281
65193: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 4 :
65194: LD_ADDR_VAR 0 1
65198: PUSH
65199: LD_INT 2
65201: PUSH
65202: LD_INT 4
65204: PUSH
65205: LD_INT 5
65207: PUSH
65208: LD_INT 11
65210: PUSH
65211: LD_INT 12
65213: PUSH
65214: LD_INT 15
65216: PUSH
65217: LD_INT 16
65219: PUSH
65220: LD_INT 22
65222: PUSH
65223: LD_INT 26
65225: PUSH
65226: LD_INT 36
65228: PUSH
65229: EMPTY
65230: LIST
65231: LIST
65232: LIST
65233: LIST
65234: LIST
65235: LIST
65236: LIST
65237: LIST
65238: LIST
65239: LIST
65240: PUSH
65241: LD_INT 101
65243: PUSH
65244: LD_INT 102
65246: PUSH
65247: LD_INT 105
65249: PUSH
65250: LD_INT 106
65252: PUSH
65253: LD_INT 108
65255: PUSH
65256: LD_INT 116
65258: PUSH
65259: LD_INT 117
65261: PUSH
65262: LD_INT 118
65264: PUSH
65265: EMPTY
65266: LIST
65267: LIST
65268: LIST
65269: LIST
65270: LIST
65271: LIST
65272: LIST
65273: LIST
65274: PUSH
65275: EMPTY
65276: LIST
65277: LIST
65278: ST_TO_ADDR
65279: GO 68166
65281: LD_INT 4
65283: DOUBLE
65284: EQUAL
65285: IFTRUE 65289
65287: GO 65385
65289: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 5 :
65290: LD_ADDR_VAR 0 1
65294: PUSH
65295: LD_INT 2
65297: PUSH
65298: LD_INT 4
65300: PUSH
65301: LD_INT 5
65303: PUSH
65304: LD_INT 8
65306: PUSH
65307: LD_INT 11
65309: PUSH
65310: LD_INT 12
65312: PUSH
65313: LD_INT 15
65315: PUSH
65316: LD_INT 16
65318: PUSH
65319: LD_INT 22
65321: PUSH
65322: LD_INT 23
65324: PUSH
65325: LD_INT 26
65327: PUSH
65328: LD_INT 36
65330: PUSH
65331: EMPTY
65332: LIST
65333: LIST
65334: LIST
65335: LIST
65336: LIST
65337: LIST
65338: LIST
65339: LIST
65340: LIST
65341: LIST
65342: LIST
65343: LIST
65344: PUSH
65345: LD_INT 101
65347: PUSH
65348: LD_INT 102
65350: PUSH
65351: LD_INT 105
65353: PUSH
65354: LD_INT 106
65356: PUSH
65357: LD_INT 108
65359: PUSH
65360: LD_INT 116
65362: PUSH
65363: LD_INT 117
65365: PUSH
65366: LD_INT 118
65368: PUSH
65369: EMPTY
65370: LIST
65371: LIST
65372: LIST
65373: LIST
65374: LIST
65375: LIST
65376: LIST
65377: LIST
65378: PUSH
65379: EMPTY
65380: LIST
65381: LIST
65382: ST_TO_ADDR
65383: GO 68166
65385: LD_INT 5
65387: DOUBLE
65388: EQUAL
65389: IFTRUE 65393
65391: GO 65505
65393: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 6 :
65394: LD_ADDR_VAR 0 1
65398: PUSH
65399: LD_INT 2
65401: PUSH
65402: LD_INT 4
65404: PUSH
65405: LD_INT 5
65407: PUSH
65408: LD_INT 6
65410: PUSH
65411: LD_INT 8
65413: PUSH
65414: LD_INT 11
65416: PUSH
65417: LD_INT 12
65419: PUSH
65420: LD_INT 15
65422: PUSH
65423: LD_INT 16
65425: PUSH
65426: LD_INT 22
65428: PUSH
65429: LD_INT 23
65431: PUSH
65432: LD_INT 25
65434: PUSH
65435: LD_INT 26
65437: PUSH
65438: LD_INT 36
65440: PUSH
65441: EMPTY
65442: LIST
65443: LIST
65444: LIST
65445: LIST
65446: LIST
65447: LIST
65448: LIST
65449: LIST
65450: LIST
65451: LIST
65452: LIST
65453: LIST
65454: LIST
65455: LIST
65456: PUSH
65457: LD_INT 101
65459: PUSH
65460: LD_INT 102
65462: PUSH
65463: LD_INT 105
65465: PUSH
65466: LD_INT 106
65468: PUSH
65469: LD_INT 108
65471: PUSH
65472: LD_INT 109
65474: PUSH
65475: LD_INT 112
65477: PUSH
65478: LD_INT 116
65480: PUSH
65481: LD_INT 117
65483: PUSH
65484: LD_INT 118
65486: PUSH
65487: EMPTY
65488: LIST
65489: LIST
65490: LIST
65491: LIST
65492: LIST
65493: LIST
65494: LIST
65495: LIST
65496: LIST
65497: LIST
65498: PUSH
65499: EMPTY
65500: LIST
65501: LIST
65502: ST_TO_ADDR
65503: GO 68166
65505: LD_INT 6
65507: DOUBLE
65508: EQUAL
65509: IFTRUE 65513
65511: GO 65645
65513: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 7 :
65514: LD_ADDR_VAR 0 1
65518: PUSH
65519: LD_INT 2
65521: PUSH
65522: LD_INT 4
65524: PUSH
65525: LD_INT 5
65527: PUSH
65528: LD_INT 6
65530: PUSH
65531: LD_INT 8
65533: PUSH
65534: LD_INT 11
65536: PUSH
65537: LD_INT 12
65539: PUSH
65540: LD_INT 15
65542: PUSH
65543: LD_INT 16
65545: PUSH
65546: LD_INT 20
65548: PUSH
65549: LD_INT 21
65551: PUSH
65552: LD_INT 22
65554: PUSH
65555: LD_INT 23
65557: PUSH
65558: LD_INT 25
65560: PUSH
65561: LD_INT 26
65563: PUSH
65564: LD_INT 30
65566: PUSH
65567: LD_INT 31
65569: PUSH
65570: LD_INT 32
65572: PUSH
65573: LD_INT 36
65575: PUSH
65576: EMPTY
65577: LIST
65578: LIST
65579: LIST
65580: LIST
65581: LIST
65582: LIST
65583: LIST
65584: LIST
65585: LIST
65586: LIST
65587: LIST
65588: LIST
65589: LIST
65590: LIST
65591: LIST
65592: LIST
65593: LIST
65594: LIST
65595: LIST
65596: PUSH
65597: LD_INT 101
65599: PUSH
65600: LD_INT 102
65602: PUSH
65603: LD_INT 105
65605: PUSH
65606: LD_INT 106
65608: PUSH
65609: LD_INT 108
65611: PUSH
65612: LD_INT 109
65614: PUSH
65615: LD_INT 112
65617: PUSH
65618: LD_INT 116
65620: PUSH
65621: LD_INT 117
65623: PUSH
65624: LD_INT 118
65626: PUSH
65627: EMPTY
65628: LIST
65629: LIST
65630: LIST
65631: LIST
65632: LIST
65633: LIST
65634: LIST
65635: LIST
65636: LIST
65637: LIST
65638: PUSH
65639: EMPTY
65640: LIST
65641: LIST
65642: ST_TO_ADDR
65643: GO 68166
65645: LD_INT 7
65647: DOUBLE
65648: EQUAL
65649: IFTRUE 65653
65651: GO 65765
65653: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 , 116 , 117 , 118 ] ] ; 8 :
65654: LD_ADDR_VAR 0 1
65658: PUSH
65659: LD_INT 2
65661: PUSH
65662: LD_INT 4
65664: PUSH
65665: LD_INT 5
65667: PUSH
65668: LD_INT 7
65670: PUSH
65671: LD_INT 11
65673: PUSH
65674: LD_INT 12
65676: PUSH
65677: LD_INT 15
65679: PUSH
65680: LD_INT 16
65682: PUSH
65683: LD_INT 20
65685: PUSH
65686: LD_INT 21
65688: PUSH
65689: LD_INT 22
65691: PUSH
65692: LD_INT 23
65694: PUSH
65695: LD_INT 25
65697: PUSH
65698: LD_INT 26
65700: PUSH
65701: EMPTY
65702: LIST
65703: LIST
65704: LIST
65705: LIST
65706: LIST
65707: LIST
65708: LIST
65709: LIST
65710: LIST
65711: LIST
65712: LIST
65713: LIST
65714: LIST
65715: LIST
65716: PUSH
65717: LD_INT 101
65719: PUSH
65720: LD_INT 102
65722: PUSH
65723: LD_INT 103
65725: PUSH
65726: LD_INT 105
65728: PUSH
65729: LD_INT 106
65731: PUSH
65732: LD_INT 108
65734: PUSH
65735: LD_INT 112
65737: PUSH
65738: LD_INT 116
65740: PUSH
65741: LD_INT 117
65743: PUSH
65744: LD_INT 118
65746: PUSH
65747: EMPTY
65748: LIST
65749: LIST
65750: LIST
65751: LIST
65752: LIST
65753: LIST
65754: LIST
65755: LIST
65756: LIST
65757: LIST
65758: PUSH
65759: EMPTY
65760: LIST
65761: LIST
65762: ST_TO_ADDR
65763: GO 68166
65765: LD_INT 8
65767: DOUBLE
65768: EQUAL
65769: IFTRUE 65773
65771: GO 65913
65773: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 9 :
65774: LD_ADDR_VAR 0 1
65778: PUSH
65779: LD_INT 2
65781: PUSH
65782: LD_INT 4
65784: PUSH
65785: LD_INT 5
65787: PUSH
65788: LD_INT 6
65790: PUSH
65791: LD_INT 7
65793: PUSH
65794: LD_INT 8
65796: PUSH
65797: LD_INT 11
65799: PUSH
65800: LD_INT 12
65802: PUSH
65803: LD_INT 15
65805: PUSH
65806: LD_INT 16
65808: PUSH
65809: LD_INT 20
65811: PUSH
65812: LD_INT 21
65814: PUSH
65815: LD_INT 22
65817: PUSH
65818: LD_INT 23
65820: PUSH
65821: LD_INT 25
65823: PUSH
65824: LD_INT 26
65826: PUSH
65827: LD_INT 30
65829: PUSH
65830: LD_INT 31
65832: PUSH
65833: LD_INT 32
65835: PUSH
65836: LD_INT 36
65838: PUSH
65839: EMPTY
65840: LIST
65841: LIST
65842: LIST
65843: LIST
65844: LIST
65845: LIST
65846: LIST
65847: LIST
65848: LIST
65849: LIST
65850: LIST
65851: LIST
65852: LIST
65853: LIST
65854: LIST
65855: LIST
65856: LIST
65857: LIST
65858: LIST
65859: LIST
65860: PUSH
65861: LD_INT 101
65863: PUSH
65864: LD_INT 102
65866: PUSH
65867: LD_INT 103
65869: PUSH
65870: LD_INT 105
65872: PUSH
65873: LD_INT 106
65875: PUSH
65876: LD_INT 108
65878: PUSH
65879: LD_INT 109
65881: PUSH
65882: LD_INT 112
65884: PUSH
65885: LD_INT 116
65887: PUSH
65888: LD_INT 117
65890: PUSH
65891: LD_INT 118
65893: PUSH
65894: EMPTY
65895: LIST
65896: LIST
65897: LIST
65898: LIST
65899: LIST
65900: LIST
65901: LIST
65902: LIST
65903: LIST
65904: LIST
65905: LIST
65906: PUSH
65907: EMPTY
65908: LIST
65909: LIST
65910: ST_TO_ADDR
65911: GO 68166
65913: LD_INT 9
65915: DOUBLE
65916: EQUAL
65917: IFTRUE 65921
65919: GO 66069
65921: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 , 116 , 117 , 118 ] ] ; 10 :
65922: LD_ADDR_VAR 0 1
65926: PUSH
65927: LD_INT 2
65929: PUSH
65930: LD_INT 4
65932: PUSH
65933: LD_INT 5
65935: PUSH
65936: LD_INT 6
65938: PUSH
65939: LD_INT 7
65941: PUSH
65942: LD_INT 8
65944: PUSH
65945: LD_INT 11
65947: PUSH
65948: LD_INT 12
65950: PUSH
65951: LD_INT 15
65953: PUSH
65954: LD_INT 16
65956: PUSH
65957: LD_INT 20
65959: PUSH
65960: LD_INT 21
65962: PUSH
65963: LD_INT 22
65965: PUSH
65966: LD_INT 23
65968: PUSH
65969: LD_INT 25
65971: PUSH
65972: LD_INT 26
65974: PUSH
65975: LD_INT 28
65977: PUSH
65978: LD_INT 30
65980: PUSH
65981: LD_INT 31
65983: PUSH
65984: LD_INT 32
65986: PUSH
65987: LD_INT 36
65989: PUSH
65990: EMPTY
65991: LIST
65992: LIST
65993: LIST
65994: LIST
65995: LIST
65996: LIST
65997: LIST
65998: LIST
65999: LIST
66000: LIST
66001: LIST
66002: LIST
66003: LIST
66004: LIST
66005: LIST
66006: LIST
66007: LIST
66008: LIST
66009: LIST
66010: LIST
66011: LIST
66012: PUSH
66013: LD_INT 101
66015: PUSH
66016: LD_INT 102
66018: PUSH
66019: LD_INT 103
66021: PUSH
66022: LD_INT 105
66024: PUSH
66025: LD_INT 106
66027: PUSH
66028: LD_INT 108
66030: PUSH
66031: LD_INT 109
66033: PUSH
66034: LD_INT 112
66036: PUSH
66037: LD_INT 114
66039: PUSH
66040: LD_INT 116
66042: PUSH
66043: LD_INT 117
66045: PUSH
66046: LD_INT 118
66048: PUSH
66049: EMPTY
66050: LIST
66051: LIST
66052: LIST
66053: LIST
66054: LIST
66055: LIST
66056: LIST
66057: LIST
66058: LIST
66059: LIST
66060: LIST
66061: LIST
66062: PUSH
66063: EMPTY
66064: LIST
66065: LIST
66066: ST_TO_ADDR
66067: GO 68166
66069: LD_INT 10
66071: DOUBLE
66072: EQUAL
66073: IFTRUE 66077
66075: GO 66273
66077: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 11 :
66078: LD_ADDR_VAR 0 1
66082: PUSH
66083: LD_INT 2
66085: PUSH
66086: LD_INT 4
66088: PUSH
66089: LD_INT 5
66091: PUSH
66092: LD_INT 6
66094: PUSH
66095: LD_INT 7
66097: PUSH
66098: LD_INT 8
66100: PUSH
66101: LD_INT 9
66103: PUSH
66104: LD_INT 10
66106: PUSH
66107: LD_INT 11
66109: PUSH
66110: LD_INT 12
66112: PUSH
66113: LD_INT 13
66115: PUSH
66116: LD_INT 14
66118: PUSH
66119: LD_INT 15
66121: PUSH
66122: LD_INT 16
66124: PUSH
66125: LD_INT 17
66127: PUSH
66128: LD_INT 18
66130: PUSH
66131: LD_INT 19
66133: PUSH
66134: LD_INT 20
66136: PUSH
66137: LD_INT 21
66139: PUSH
66140: LD_INT 22
66142: PUSH
66143: LD_INT 23
66145: PUSH
66146: LD_INT 24
66148: PUSH
66149: LD_INT 25
66151: PUSH
66152: LD_INT 26
66154: PUSH
66155: LD_INT 28
66157: PUSH
66158: LD_INT 30
66160: PUSH
66161: LD_INT 31
66163: PUSH
66164: LD_INT 32
66166: PUSH
66167: LD_INT 36
66169: PUSH
66170: EMPTY
66171: LIST
66172: LIST
66173: LIST
66174: LIST
66175: LIST
66176: LIST
66177: LIST
66178: LIST
66179: LIST
66180: LIST
66181: LIST
66182: LIST
66183: LIST
66184: LIST
66185: LIST
66186: LIST
66187: LIST
66188: LIST
66189: LIST
66190: LIST
66191: LIST
66192: LIST
66193: LIST
66194: LIST
66195: LIST
66196: LIST
66197: LIST
66198: LIST
66199: LIST
66200: PUSH
66201: LD_INT 101
66203: PUSH
66204: LD_INT 102
66206: PUSH
66207: LD_INT 103
66209: PUSH
66210: LD_INT 104
66212: PUSH
66213: LD_INT 105
66215: PUSH
66216: LD_INT 106
66218: PUSH
66219: LD_INT 107
66221: PUSH
66222: LD_INT 108
66224: PUSH
66225: LD_INT 109
66227: PUSH
66228: LD_INT 110
66230: PUSH
66231: LD_INT 111
66233: PUSH
66234: LD_INT 112
66236: PUSH
66237: LD_INT 114
66239: PUSH
66240: LD_INT 116
66242: PUSH
66243: LD_INT 117
66245: PUSH
66246: LD_INT 118
66248: PUSH
66249: EMPTY
66250: LIST
66251: LIST
66252: LIST
66253: LIST
66254: LIST
66255: LIST
66256: LIST
66257: LIST
66258: LIST
66259: LIST
66260: LIST
66261: LIST
66262: LIST
66263: LIST
66264: LIST
66265: LIST
66266: PUSH
66267: EMPTY
66268: LIST
66269: LIST
66270: ST_TO_ADDR
66271: GO 68166
66273: LD_INT 11
66275: DOUBLE
66276: EQUAL
66277: IFTRUE 66281
66279: GO 66485
66281: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 12 :
66282: LD_ADDR_VAR 0 1
66286: PUSH
66287: LD_INT 2
66289: PUSH
66290: LD_INT 3
66292: PUSH
66293: LD_INT 4
66295: PUSH
66296: LD_INT 5
66298: PUSH
66299: LD_INT 6
66301: PUSH
66302: LD_INT 7
66304: PUSH
66305: LD_INT 8
66307: PUSH
66308: LD_INT 9
66310: PUSH
66311: LD_INT 10
66313: PUSH
66314: LD_INT 11
66316: PUSH
66317: LD_INT 12
66319: PUSH
66320: LD_INT 13
66322: PUSH
66323: LD_INT 14
66325: PUSH
66326: LD_INT 15
66328: PUSH
66329: LD_INT 16
66331: PUSH
66332: LD_INT 17
66334: PUSH
66335: LD_INT 18
66337: PUSH
66338: LD_INT 19
66340: PUSH
66341: LD_INT 20
66343: PUSH
66344: LD_INT 21
66346: PUSH
66347: LD_INT 22
66349: PUSH
66350: LD_INT 23
66352: PUSH
66353: LD_INT 24
66355: PUSH
66356: LD_INT 25
66358: PUSH
66359: LD_INT 26
66361: PUSH
66362: LD_INT 28
66364: PUSH
66365: LD_INT 30
66367: PUSH
66368: LD_INT 31
66370: PUSH
66371: LD_INT 32
66373: PUSH
66374: LD_INT 34
66376: PUSH
66377: LD_INT 36
66379: PUSH
66380: EMPTY
66381: LIST
66382: LIST
66383: LIST
66384: LIST
66385: LIST
66386: LIST
66387: LIST
66388: LIST
66389: LIST
66390: LIST
66391: LIST
66392: LIST
66393: LIST
66394: LIST
66395: LIST
66396: LIST
66397: LIST
66398: LIST
66399: LIST
66400: LIST
66401: LIST
66402: LIST
66403: LIST
66404: LIST
66405: LIST
66406: LIST
66407: LIST
66408: LIST
66409: LIST
66410: LIST
66411: LIST
66412: PUSH
66413: LD_INT 101
66415: PUSH
66416: LD_INT 102
66418: PUSH
66419: LD_INT 103
66421: PUSH
66422: LD_INT 104
66424: PUSH
66425: LD_INT 105
66427: PUSH
66428: LD_INT 106
66430: PUSH
66431: LD_INT 107
66433: PUSH
66434: LD_INT 108
66436: PUSH
66437: LD_INT 109
66439: PUSH
66440: LD_INT 110
66442: PUSH
66443: LD_INT 111
66445: PUSH
66446: LD_INT 112
66448: PUSH
66449: LD_INT 114
66451: PUSH
66452: LD_INT 116
66454: PUSH
66455: LD_INT 117
66457: PUSH
66458: LD_INT 118
66460: PUSH
66461: EMPTY
66462: LIST
66463: LIST
66464: LIST
66465: LIST
66466: LIST
66467: LIST
66468: LIST
66469: LIST
66470: LIST
66471: LIST
66472: LIST
66473: LIST
66474: LIST
66475: LIST
66476: LIST
66477: LIST
66478: PUSH
66479: EMPTY
66480: LIST
66481: LIST
66482: ST_TO_ADDR
66483: GO 68166
66485: LD_INT 12
66487: DOUBLE
66488: EQUAL
66489: IFTRUE 66493
66491: GO 66713
66493: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 13 :
66494: LD_ADDR_VAR 0 1
66498: PUSH
66499: LD_INT 1
66501: PUSH
66502: LD_INT 2
66504: PUSH
66505: LD_INT 3
66507: PUSH
66508: LD_INT 4
66510: PUSH
66511: LD_INT 5
66513: PUSH
66514: LD_INT 6
66516: PUSH
66517: LD_INT 7
66519: PUSH
66520: LD_INT 8
66522: PUSH
66523: LD_INT 9
66525: PUSH
66526: LD_INT 10
66528: PUSH
66529: LD_INT 11
66531: PUSH
66532: LD_INT 12
66534: PUSH
66535: LD_INT 13
66537: PUSH
66538: LD_INT 14
66540: PUSH
66541: LD_INT 15
66543: PUSH
66544: LD_INT 16
66546: PUSH
66547: LD_INT 17
66549: PUSH
66550: LD_INT 18
66552: PUSH
66553: LD_INT 19
66555: PUSH
66556: LD_INT 20
66558: PUSH
66559: LD_INT 21
66561: PUSH
66562: LD_INT 22
66564: PUSH
66565: LD_INT 23
66567: PUSH
66568: LD_INT 24
66570: PUSH
66571: LD_INT 25
66573: PUSH
66574: LD_INT 26
66576: PUSH
66577: LD_INT 27
66579: PUSH
66580: LD_INT 28
66582: PUSH
66583: LD_INT 30
66585: PUSH
66586: LD_INT 31
66588: PUSH
66589: LD_INT 32
66591: PUSH
66592: LD_INT 33
66594: PUSH
66595: LD_INT 34
66597: PUSH
66598: LD_INT 36
66600: PUSH
66601: EMPTY
66602: LIST
66603: LIST
66604: LIST
66605: LIST
66606: LIST
66607: LIST
66608: LIST
66609: LIST
66610: LIST
66611: LIST
66612: LIST
66613: LIST
66614: LIST
66615: LIST
66616: LIST
66617: LIST
66618: LIST
66619: LIST
66620: LIST
66621: LIST
66622: LIST
66623: LIST
66624: LIST
66625: LIST
66626: LIST
66627: LIST
66628: LIST
66629: LIST
66630: LIST
66631: LIST
66632: LIST
66633: LIST
66634: LIST
66635: LIST
66636: PUSH
66637: LD_INT 101
66639: PUSH
66640: LD_INT 102
66642: PUSH
66643: LD_INT 103
66645: PUSH
66646: LD_INT 104
66648: PUSH
66649: LD_INT 105
66651: PUSH
66652: LD_INT 106
66654: PUSH
66655: LD_INT 107
66657: PUSH
66658: LD_INT 108
66660: PUSH
66661: LD_INT 109
66663: PUSH
66664: LD_INT 110
66666: PUSH
66667: LD_INT 111
66669: PUSH
66670: LD_INT 112
66672: PUSH
66673: LD_INT 113
66675: PUSH
66676: LD_INT 114
66678: PUSH
66679: LD_INT 116
66681: PUSH
66682: LD_INT 117
66684: PUSH
66685: LD_INT 118
66687: PUSH
66688: EMPTY
66689: LIST
66690: LIST
66691: LIST
66692: LIST
66693: LIST
66694: LIST
66695: LIST
66696: LIST
66697: LIST
66698: LIST
66699: LIST
66700: LIST
66701: LIST
66702: LIST
66703: LIST
66704: LIST
66705: LIST
66706: PUSH
66707: EMPTY
66708: LIST
66709: LIST
66710: ST_TO_ADDR
66711: GO 68166
66713: LD_INT 13
66715: DOUBLE
66716: EQUAL
66717: IFTRUE 66721
66719: GO 66929
66721: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 14 :
66722: LD_ADDR_VAR 0 1
66726: PUSH
66727: LD_INT 1
66729: PUSH
66730: LD_INT 2
66732: PUSH
66733: LD_INT 3
66735: PUSH
66736: LD_INT 4
66738: PUSH
66739: LD_INT 5
66741: PUSH
66742: LD_INT 8
66744: PUSH
66745: LD_INT 9
66747: PUSH
66748: LD_INT 10
66750: PUSH
66751: LD_INT 11
66753: PUSH
66754: LD_INT 12
66756: PUSH
66757: LD_INT 14
66759: PUSH
66760: LD_INT 15
66762: PUSH
66763: LD_INT 16
66765: PUSH
66766: LD_INT 17
66768: PUSH
66769: LD_INT 18
66771: PUSH
66772: LD_INT 19
66774: PUSH
66775: LD_INT 20
66777: PUSH
66778: LD_INT 21
66780: PUSH
66781: LD_INT 22
66783: PUSH
66784: LD_INT 23
66786: PUSH
66787: LD_INT 24
66789: PUSH
66790: LD_INT 25
66792: PUSH
66793: LD_INT 26
66795: PUSH
66796: LD_INT 27
66798: PUSH
66799: LD_INT 28
66801: PUSH
66802: LD_INT 30
66804: PUSH
66805: LD_INT 31
66807: PUSH
66808: LD_INT 32
66810: PUSH
66811: LD_INT 33
66813: PUSH
66814: LD_INT 34
66816: PUSH
66817: LD_INT 36
66819: PUSH
66820: EMPTY
66821: LIST
66822: LIST
66823: LIST
66824: LIST
66825: LIST
66826: LIST
66827: LIST
66828: LIST
66829: LIST
66830: LIST
66831: LIST
66832: LIST
66833: LIST
66834: LIST
66835: LIST
66836: LIST
66837: LIST
66838: LIST
66839: LIST
66840: LIST
66841: LIST
66842: LIST
66843: LIST
66844: LIST
66845: LIST
66846: LIST
66847: LIST
66848: LIST
66849: LIST
66850: LIST
66851: LIST
66852: PUSH
66853: LD_INT 101
66855: PUSH
66856: LD_INT 102
66858: PUSH
66859: LD_INT 103
66861: PUSH
66862: LD_INT 104
66864: PUSH
66865: LD_INT 105
66867: PUSH
66868: LD_INT 106
66870: PUSH
66871: LD_INT 107
66873: PUSH
66874: LD_INT 108
66876: PUSH
66877: LD_INT 109
66879: PUSH
66880: LD_INT 110
66882: PUSH
66883: LD_INT 111
66885: PUSH
66886: LD_INT 112
66888: PUSH
66889: LD_INT 113
66891: PUSH
66892: LD_INT 114
66894: PUSH
66895: LD_INT 116
66897: PUSH
66898: LD_INT 117
66900: PUSH
66901: LD_INT 118
66903: PUSH
66904: EMPTY
66905: LIST
66906: LIST
66907: LIST
66908: LIST
66909: LIST
66910: LIST
66911: LIST
66912: LIST
66913: LIST
66914: LIST
66915: LIST
66916: LIST
66917: LIST
66918: LIST
66919: LIST
66920: LIST
66921: LIST
66922: PUSH
66923: EMPTY
66924: LIST
66925: LIST
66926: ST_TO_ADDR
66927: GO 68166
66929: LD_INT 14
66931: DOUBLE
66932: EQUAL
66933: IFTRUE 66937
66935: GO 67161
66937: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 15 :
66938: LD_ADDR_VAR 0 1
66942: PUSH
66943: LD_INT 1
66945: PUSH
66946: LD_INT 2
66948: PUSH
66949: LD_INT 3
66951: PUSH
66952: LD_INT 4
66954: PUSH
66955: LD_INT 5
66957: PUSH
66958: LD_INT 6
66960: PUSH
66961: LD_INT 7
66963: PUSH
66964: LD_INT 8
66966: PUSH
66967: LD_INT 9
66969: PUSH
66970: LD_INT 10
66972: PUSH
66973: LD_INT 11
66975: PUSH
66976: LD_INT 12
66978: PUSH
66979: LD_INT 13
66981: PUSH
66982: LD_INT 14
66984: PUSH
66985: LD_INT 15
66987: PUSH
66988: LD_INT 16
66990: PUSH
66991: LD_INT 17
66993: PUSH
66994: LD_INT 18
66996: PUSH
66997: LD_INT 19
66999: PUSH
67000: LD_INT 20
67002: PUSH
67003: LD_INT 21
67005: PUSH
67006: LD_INT 22
67008: PUSH
67009: LD_INT 23
67011: PUSH
67012: LD_INT 24
67014: PUSH
67015: LD_INT 25
67017: PUSH
67018: LD_INT 26
67020: PUSH
67021: LD_INT 27
67023: PUSH
67024: LD_INT 28
67026: PUSH
67027: LD_INT 29
67029: PUSH
67030: LD_INT 30
67032: PUSH
67033: LD_INT 31
67035: PUSH
67036: LD_INT 32
67038: PUSH
67039: LD_INT 33
67041: PUSH
67042: LD_INT 34
67044: PUSH
67045: LD_INT 36
67047: PUSH
67048: EMPTY
67049: LIST
67050: LIST
67051: LIST
67052: LIST
67053: LIST
67054: LIST
67055: LIST
67056: LIST
67057: LIST
67058: LIST
67059: LIST
67060: LIST
67061: LIST
67062: LIST
67063: LIST
67064: LIST
67065: LIST
67066: LIST
67067: LIST
67068: LIST
67069: LIST
67070: LIST
67071: LIST
67072: LIST
67073: LIST
67074: LIST
67075: LIST
67076: LIST
67077: LIST
67078: LIST
67079: LIST
67080: LIST
67081: LIST
67082: LIST
67083: LIST
67084: PUSH
67085: LD_INT 101
67087: PUSH
67088: LD_INT 102
67090: PUSH
67091: LD_INT 103
67093: PUSH
67094: LD_INT 104
67096: PUSH
67097: LD_INT 105
67099: PUSH
67100: LD_INT 106
67102: PUSH
67103: LD_INT 107
67105: PUSH
67106: LD_INT 108
67108: PUSH
67109: LD_INT 109
67111: PUSH
67112: LD_INT 110
67114: PUSH
67115: LD_INT 111
67117: PUSH
67118: LD_INT 112
67120: PUSH
67121: LD_INT 113
67123: PUSH
67124: LD_INT 114
67126: PUSH
67127: LD_INT 116
67129: PUSH
67130: LD_INT 117
67132: PUSH
67133: LD_INT 118
67135: PUSH
67136: EMPTY
67137: LIST
67138: LIST
67139: LIST
67140: LIST
67141: LIST
67142: LIST
67143: LIST
67144: LIST
67145: LIST
67146: LIST
67147: LIST
67148: LIST
67149: LIST
67150: LIST
67151: LIST
67152: LIST
67153: LIST
67154: PUSH
67155: EMPTY
67156: LIST
67157: LIST
67158: ST_TO_ADDR
67159: GO 68166
67161: LD_INT 15
67163: DOUBLE
67164: EQUAL
67165: IFTRUE 67169
67167: GO 67393
67169: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 16 :
67170: LD_ADDR_VAR 0 1
67174: PUSH
67175: LD_INT 1
67177: PUSH
67178: LD_INT 2
67180: PUSH
67181: LD_INT 3
67183: PUSH
67184: LD_INT 4
67186: PUSH
67187: LD_INT 5
67189: PUSH
67190: LD_INT 6
67192: PUSH
67193: LD_INT 7
67195: PUSH
67196: LD_INT 8
67198: PUSH
67199: LD_INT 9
67201: PUSH
67202: LD_INT 10
67204: PUSH
67205: LD_INT 11
67207: PUSH
67208: LD_INT 12
67210: PUSH
67211: LD_INT 13
67213: PUSH
67214: LD_INT 14
67216: PUSH
67217: LD_INT 15
67219: PUSH
67220: LD_INT 16
67222: PUSH
67223: LD_INT 17
67225: PUSH
67226: LD_INT 18
67228: PUSH
67229: LD_INT 19
67231: PUSH
67232: LD_INT 20
67234: PUSH
67235: LD_INT 21
67237: PUSH
67238: LD_INT 22
67240: PUSH
67241: LD_INT 23
67243: PUSH
67244: LD_INT 24
67246: PUSH
67247: LD_INT 25
67249: PUSH
67250: LD_INT 26
67252: PUSH
67253: LD_INT 27
67255: PUSH
67256: LD_INT 28
67258: PUSH
67259: LD_INT 29
67261: PUSH
67262: LD_INT 30
67264: PUSH
67265: LD_INT 31
67267: PUSH
67268: LD_INT 32
67270: PUSH
67271: LD_INT 33
67273: PUSH
67274: LD_INT 34
67276: PUSH
67277: LD_INT 36
67279: PUSH
67280: EMPTY
67281: LIST
67282: LIST
67283: LIST
67284: LIST
67285: LIST
67286: LIST
67287: LIST
67288: LIST
67289: LIST
67290: LIST
67291: LIST
67292: LIST
67293: LIST
67294: LIST
67295: LIST
67296: LIST
67297: LIST
67298: LIST
67299: LIST
67300: LIST
67301: LIST
67302: LIST
67303: LIST
67304: LIST
67305: LIST
67306: LIST
67307: LIST
67308: LIST
67309: LIST
67310: LIST
67311: LIST
67312: LIST
67313: LIST
67314: LIST
67315: LIST
67316: PUSH
67317: LD_INT 101
67319: PUSH
67320: LD_INT 102
67322: PUSH
67323: LD_INT 103
67325: PUSH
67326: LD_INT 104
67328: PUSH
67329: LD_INT 105
67331: PUSH
67332: LD_INT 106
67334: PUSH
67335: LD_INT 107
67337: PUSH
67338: LD_INT 108
67340: PUSH
67341: LD_INT 109
67343: PUSH
67344: LD_INT 110
67346: PUSH
67347: LD_INT 111
67349: PUSH
67350: LD_INT 112
67352: PUSH
67353: LD_INT 113
67355: PUSH
67356: LD_INT 114
67358: PUSH
67359: LD_INT 116
67361: PUSH
67362: LD_INT 117
67364: PUSH
67365: LD_INT 118
67367: PUSH
67368: EMPTY
67369: LIST
67370: LIST
67371: LIST
67372: LIST
67373: LIST
67374: LIST
67375: LIST
67376: LIST
67377: LIST
67378: LIST
67379: LIST
67380: LIST
67381: LIST
67382: LIST
67383: LIST
67384: LIST
67385: LIST
67386: PUSH
67387: EMPTY
67388: LIST
67389: LIST
67390: ST_TO_ADDR
67391: GO 68166
67393: LD_INT 16
67395: DOUBLE
67396: EQUAL
67397: IFTRUE 67401
67399: GO 67537
67401: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 17 :
67402: LD_ADDR_VAR 0 1
67406: PUSH
67407: LD_INT 2
67409: PUSH
67410: LD_INT 4
67412: PUSH
67413: LD_INT 5
67415: PUSH
67416: LD_INT 7
67418: PUSH
67419: LD_INT 11
67421: PUSH
67422: LD_INT 12
67424: PUSH
67425: LD_INT 15
67427: PUSH
67428: LD_INT 16
67430: PUSH
67431: LD_INT 20
67433: PUSH
67434: LD_INT 21
67436: PUSH
67437: LD_INT 22
67439: PUSH
67440: LD_INT 23
67442: PUSH
67443: LD_INT 25
67445: PUSH
67446: LD_INT 26
67448: PUSH
67449: LD_INT 30
67451: PUSH
67452: LD_INT 31
67454: PUSH
67455: LD_INT 32
67457: PUSH
67458: LD_INT 33
67460: PUSH
67461: LD_INT 34
67463: PUSH
67464: EMPTY
67465: LIST
67466: LIST
67467: LIST
67468: LIST
67469: LIST
67470: LIST
67471: LIST
67472: LIST
67473: LIST
67474: LIST
67475: LIST
67476: LIST
67477: LIST
67478: LIST
67479: LIST
67480: LIST
67481: LIST
67482: LIST
67483: LIST
67484: PUSH
67485: LD_INT 101
67487: PUSH
67488: LD_INT 102
67490: PUSH
67491: LD_INT 103
67493: PUSH
67494: LD_INT 106
67496: PUSH
67497: LD_INT 108
67499: PUSH
67500: LD_INT 112
67502: PUSH
67503: LD_INT 113
67505: PUSH
67506: LD_INT 114
67508: PUSH
67509: LD_INT 116
67511: PUSH
67512: LD_INT 117
67514: PUSH
67515: LD_INT 118
67517: PUSH
67518: EMPTY
67519: LIST
67520: LIST
67521: LIST
67522: LIST
67523: LIST
67524: LIST
67525: LIST
67526: LIST
67527: LIST
67528: LIST
67529: LIST
67530: PUSH
67531: EMPTY
67532: LIST
67533: LIST
67534: ST_TO_ADDR
67535: GO 68166
67537: LD_INT 17
67539: DOUBLE
67540: EQUAL
67541: IFTRUE 67545
67543: GO 67769
67545: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 18 :
67546: LD_ADDR_VAR 0 1
67550: PUSH
67551: LD_INT 1
67553: PUSH
67554: LD_INT 2
67556: PUSH
67557: LD_INT 3
67559: PUSH
67560: LD_INT 4
67562: PUSH
67563: LD_INT 5
67565: PUSH
67566: LD_INT 6
67568: PUSH
67569: LD_INT 7
67571: PUSH
67572: LD_INT 8
67574: PUSH
67575: LD_INT 9
67577: PUSH
67578: LD_INT 10
67580: PUSH
67581: LD_INT 11
67583: PUSH
67584: LD_INT 12
67586: PUSH
67587: LD_INT 13
67589: PUSH
67590: LD_INT 14
67592: PUSH
67593: LD_INT 15
67595: PUSH
67596: LD_INT 16
67598: PUSH
67599: LD_INT 17
67601: PUSH
67602: LD_INT 18
67604: PUSH
67605: LD_INT 19
67607: PUSH
67608: LD_INT 20
67610: PUSH
67611: LD_INT 21
67613: PUSH
67614: LD_INT 22
67616: PUSH
67617: LD_INT 23
67619: PUSH
67620: LD_INT 24
67622: PUSH
67623: LD_INT 25
67625: PUSH
67626: LD_INT 26
67628: PUSH
67629: LD_INT 27
67631: PUSH
67632: LD_INT 28
67634: PUSH
67635: LD_INT 29
67637: PUSH
67638: LD_INT 30
67640: PUSH
67641: LD_INT 31
67643: PUSH
67644: LD_INT 32
67646: PUSH
67647: LD_INT 33
67649: PUSH
67650: LD_INT 34
67652: PUSH
67653: LD_INT 36
67655: PUSH
67656: EMPTY
67657: LIST
67658: LIST
67659: LIST
67660: LIST
67661: LIST
67662: LIST
67663: LIST
67664: LIST
67665: LIST
67666: LIST
67667: LIST
67668: LIST
67669: LIST
67670: LIST
67671: LIST
67672: LIST
67673: LIST
67674: LIST
67675: LIST
67676: LIST
67677: LIST
67678: LIST
67679: LIST
67680: LIST
67681: LIST
67682: LIST
67683: LIST
67684: LIST
67685: LIST
67686: LIST
67687: LIST
67688: LIST
67689: LIST
67690: LIST
67691: LIST
67692: PUSH
67693: LD_INT 101
67695: PUSH
67696: LD_INT 102
67698: PUSH
67699: LD_INT 103
67701: PUSH
67702: LD_INT 104
67704: PUSH
67705: LD_INT 105
67707: PUSH
67708: LD_INT 106
67710: PUSH
67711: LD_INT 107
67713: PUSH
67714: LD_INT 108
67716: PUSH
67717: LD_INT 109
67719: PUSH
67720: LD_INT 110
67722: PUSH
67723: LD_INT 111
67725: PUSH
67726: LD_INT 112
67728: PUSH
67729: LD_INT 113
67731: PUSH
67732: LD_INT 114
67734: PUSH
67735: LD_INT 116
67737: PUSH
67738: LD_INT 117
67740: PUSH
67741: LD_INT 118
67743: PUSH
67744: EMPTY
67745: LIST
67746: LIST
67747: LIST
67748: LIST
67749: LIST
67750: LIST
67751: LIST
67752: LIST
67753: LIST
67754: LIST
67755: LIST
67756: LIST
67757: LIST
67758: LIST
67759: LIST
67760: LIST
67761: LIST
67762: PUSH
67763: EMPTY
67764: LIST
67765: LIST
67766: ST_TO_ADDR
67767: GO 68166
67769: LD_INT 18
67771: DOUBLE
67772: EQUAL
67773: IFTRUE 67777
67775: GO 67925
67777: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; 19 :
67778: LD_ADDR_VAR 0 1
67782: PUSH
67783: LD_INT 2
67785: PUSH
67786: LD_INT 4
67788: PUSH
67789: LD_INT 5
67791: PUSH
67792: LD_INT 7
67794: PUSH
67795: LD_INT 11
67797: PUSH
67798: LD_INT 12
67800: PUSH
67801: LD_INT 15
67803: PUSH
67804: LD_INT 16
67806: PUSH
67807: LD_INT 20
67809: PUSH
67810: LD_INT 21
67812: PUSH
67813: LD_INT 22
67815: PUSH
67816: LD_INT 23
67818: PUSH
67819: LD_INT 25
67821: PUSH
67822: LD_INT 26
67824: PUSH
67825: LD_INT 30
67827: PUSH
67828: LD_INT 31
67830: PUSH
67831: LD_INT 32
67833: PUSH
67834: LD_INT 33
67836: PUSH
67837: LD_INT 34
67839: PUSH
67840: LD_INT 35
67842: PUSH
67843: LD_INT 36
67845: PUSH
67846: EMPTY
67847: LIST
67848: LIST
67849: LIST
67850: LIST
67851: LIST
67852: LIST
67853: LIST
67854: LIST
67855: LIST
67856: LIST
67857: LIST
67858: LIST
67859: LIST
67860: LIST
67861: LIST
67862: LIST
67863: LIST
67864: LIST
67865: LIST
67866: LIST
67867: LIST
67868: PUSH
67869: LD_INT 101
67871: PUSH
67872: LD_INT 102
67874: PUSH
67875: LD_INT 103
67877: PUSH
67878: LD_INT 106
67880: PUSH
67881: LD_INT 108
67883: PUSH
67884: LD_INT 112
67886: PUSH
67887: LD_INT 113
67889: PUSH
67890: LD_INT 114
67892: PUSH
67893: LD_INT 115
67895: PUSH
67896: LD_INT 116
67898: PUSH
67899: LD_INT 117
67901: PUSH
67902: LD_INT 118
67904: PUSH
67905: EMPTY
67906: LIST
67907: LIST
67908: LIST
67909: LIST
67910: LIST
67911: LIST
67912: LIST
67913: LIST
67914: LIST
67915: LIST
67916: LIST
67917: LIST
67918: PUSH
67919: EMPTY
67920: LIST
67921: LIST
67922: ST_TO_ADDR
67923: GO 68166
67925: LD_INT 19
67927: DOUBLE
67928: EQUAL
67929: IFTRUE 67933
67931: GO 68165
67933: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; end ;
67934: LD_ADDR_VAR 0 1
67938: PUSH
67939: LD_INT 1
67941: PUSH
67942: LD_INT 2
67944: PUSH
67945: LD_INT 3
67947: PUSH
67948: LD_INT 4
67950: PUSH
67951: LD_INT 5
67953: PUSH
67954: LD_INT 6
67956: PUSH
67957: LD_INT 7
67959: PUSH
67960: LD_INT 8
67962: PUSH
67963: LD_INT 9
67965: PUSH
67966: LD_INT 10
67968: PUSH
67969: LD_INT 11
67971: PUSH
67972: LD_INT 12
67974: PUSH
67975: LD_INT 13
67977: PUSH
67978: LD_INT 14
67980: PUSH
67981: LD_INT 15
67983: PUSH
67984: LD_INT 16
67986: PUSH
67987: LD_INT 17
67989: PUSH
67990: LD_INT 18
67992: PUSH
67993: LD_INT 19
67995: PUSH
67996: LD_INT 20
67998: PUSH
67999: LD_INT 21
68001: PUSH
68002: LD_INT 22
68004: PUSH
68005: LD_INT 23
68007: PUSH
68008: LD_INT 24
68010: PUSH
68011: LD_INT 25
68013: PUSH
68014: LD_INT 26
68016: PUSH
68017: LD_INT 27
68019: PUSH
68020: LD_INT 28
68022: PUSH
68023: LD_INT 29
68025: PUSH
68026: LD_INT 30
68028: PUSH
68029: LD_INT 31
68031: PUSH
68032: LD_INT 32
68034: PUSH
68035: LD_INT 33
68037: PUSH
68038: LD_INT 34
68040: PUSH
68041: LD_INT 35
68043: PUSH
68044: LD_INT 36
68046: PUSH
68047: EMPTY
68048: LIST
68049: LIST
68050: LIST
68051: LIST
68052: LIST
68053: LIST
68054: LIST
68055: LIST
68056: LIST
68057: LIST
68058: LIST
68059: LIST
68060: LIST
68061: LIST
68062: LIST
68063: LIST
68064: LIST
68065: LIST
68066: LIST
68067: LIST
68068: LIST
68069: LIST
68070: LIST
68071: LIST
68072: LIST
68073: LIST
68074: LIST
68075: LIST
68076: LIST
68077: LIST
68078: LIST
68079: LIST
68080: LIST
68081: LIST
68082: LIST
68083: LIST
68084: PUSH
68085: LD_INT 101
68087: PUSH
68088: LD_INT 102
68090: PUSH
68091: LD_INT 103
68093: PUSH
68094: LD_INT 104
68096: PUSH
68097: LD_INT 105
68099: PUSH
68100: LD_INT 106
68102: PUSH
68103: LD_INT 107
68105: PUSH
68106: LD_INT 108
68108: PUSH
68109: LD_INT 109
68111: PUSH
68112: LD_INT 110
68114: PUSH
68115: LD_INT 111
68117: PUSH
68118: LD_INT 112
68120: PUSH
68121: LD_INT 113
68123: PUSH
68124: LD_INT 114
68126: PUSH
68127: LD_INT 115
68129: PUSH
68130: LD_INT 116
68132: PUSH
68133: LD_INT 117
68135: PUSH
68136: LD_INT 118
68138: PUSH
68139: EMPTY
68140: LIST
68141: LIST
68142: LIST
68143: LIST
68144: LIST
68145: LIST
68146: LIST
68147: LIST
68148: LIST
68149: LIST
68150: LIST
68151: LIST
68152: LIST
68153: LIST
68154: LIST
68155: LIST
68156: LIST
68157: LIST
68158: PUSH
68159: EMPTY
68160: LIST
68161: LIST
68162: ST_TO_ADDR
68163: GO 68166
68165: POP
// end else
68166: GO 68397
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ;
68168: LD_ADDR_VAR 0 1
68172: PUSH
68173: LD_INT 1
68175: PUSH
68176: LD_INT 2
68178: PUSH
68179: LD_INT 3
68181: PUSH
68182: LD_INT 4
68184: PUSH
68185: LD_INT 5
68187: PUSH
68188: LD_INT 6
68190: PUSH
68191: LD_INT 7
68193: PUSH
68194: LD_INT 8
68196: PUSH
68197: LD_INT 9
68199: PUSH
68200: LD_INT 10
68202: PUSH
68203: LD_INT 11
68205: PUSH
68206: LD_INT 12
68208: PUSH
68209: LD_INT 13
68211: PUSH
68212: LD_INT 14
68214: PUSH
68215: LD_INT 15
68217: PUSH
68218: LD_INT 16
68220: PUSH
68221: LD_INT 17
68223: PUSH
68224: LD_INT 18
68226: PUSH
68227: LD_INT 19
68229: PUSH
68230: LD_INT 20
68232: PUSH
68233: LD_INT 21
68235: PUSH
68236: LD_INT 22
68238: PUSH
68239: LD_INT 23
68241: PUSH
68242: LD_INT 24
68244: PUSH
68245: LD_INT 25
68247: PUSH
68248: LD_INT 26
68250: PUSH
68251: LD_INT 27
68253: PUSH
68254: LD_INT 28
68256: PUSH
68257: LD_INT 29
68259: PUSH
68260: LD_INT 30
68262: PUSH
68263: LD_INT 31
68265: PUSH
68266: LD_INT 32
68268: PUSH
68269: LD_INT 33
68271: PUSH
68272: LD_INT 34
68274: PUSH
68275: LD_INT 35
68277: PUSH
68278: LD_INT 36
68280: PUSH
68281: EMPTY
68282: LIST
68283: LIST
68284: LIST
68285: LIST
68286: LIST
68287: LIST
68288: LIST
68289: LIST
68290: LIST
68291: LIST
68292: LIST
68293: LIST
68294: LIST
68295: LIST
68296: LIST
68297: LIST
68298: LIST
68299: LIST
68300: LIST
68301: LIST
68302: LIST
68303: LIST
68304: LIST
68305: LIST
68306: LIST
68307: LIST
68308: LIST
68309: LIST
68310: LIST
68311: LIST
68312: LIST
68313: LIST
68314: LIST
68315: LIST
68316: LIST
68317: LIST
68318: PUSH
68319: LD_INT 101
68321: PUSH
68322: LD_INT 102
68324: PUSH
68325: LD_INT 103
68327: PUSH
68328: LD_INT 104
68330: PUSH
68331: LD_INT 105
68333: PUSH
68334: LD_INT 106
68336: PUSH
68337: LD_INT 107
68339: PUSH
68340: LD_INT 108
68342: PUSH
68343: LD_INT 109
68345: PUSH
68346: LD_INT 110
68348: PUSH
68349: LD_INT 111
68351: PUSH
68352: LD_INT 112
68354: PUSH
68355: LD_INT 113
68357: PUSH
68358: LD_INT 114
68360: PUSH
68361: LD_INT 115
68363: PUSH
68364: LD_INT 116
68366: PUSH
68367: LD_INT 117
68369: PUSH
68370: LD_INT 118
68372: PUSH
68373: EMPTY
68374: LIST
68375: LIST
68376: LIST
68377: LIST
68378: LIST
68379: LIST
68380: LIST
68381: LIST
68382: LIST
68383: LIST
68384: LIST
68385: LIST
68386: LIST
68387: LIST
68388: LIST
68389: LIST
68390: LIST
68391: LIST
68392: PUSH
68393: EMPTY
68394: LIST
68395: LIST
68396: ST_TO_ADDR
// if result then
68397: LD_VAR 0 1
68401: IFFALSE 68690
// begin normal :=  ;
68403: LD_ADDR_VAR 0 3
68407: PUSH
68408: LD_STRING 
68410: ST_TO_ADDR
// hardcore :=  ;
68411: LD_ADDR_VAR 0 4
68415: PUSH
68416: LD_STRING 
68418: ST_TO_ADDR
// for i = 1 to normalCounter do
68419: LD_ADDR_VAR 0 5
68423: PUSH
68424: DOUBLE
68425: LD_INT 1
68427: DEC
68428: ST_TO_ADDR
68429: LD_EXP 100
68433: PUSH
68434: FOR_TO
68435: IFFALSE 68536
// begin tmp := 0 ;
68437: LD_ADDR_VAR 0 2
68441: PUSH
68442: LD_STRING 0
68444: ST_TO_ADDR
// if result [ 1 ] then
68445: LD_VAR 0 1
68449: PUSH
68450: LD_INT 1
68452: ARRAY
68453: IFFALSE 68518
// if result [ 1 ] [ 1 ] = i then
68455: LD_VAR 0 1
68459: PUSH
68460: LD_INT 1
68462: ARRAY
68463: PUSH
68464: LD_INT 1
68466: ARRAY
68467: PUSH
68468: LD_VAR 0 5
68472: EQUAL
68473: IFFALSE 68518
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
68475: LD_ADDR_VAR 0 1
68479: PUSH
68480: LD_VAR 0 1
68484: PPUSH
68485: LD_INT 1
68487: PPUSH
68488: LD_VAR 0 1
68492: PUSH
68493: LD_INT 1
68495: ARRAY
68496: PPUSH
68497: LD_INT 1
68499: PPUSH
68500: CALL_OW 3
68504: PPUSH
68505: CALL_OW 1
68509: ST_TO_ADDR
// tmp := 1 ;
68510: LD_ADDR_VAR 0 2
68514: PUSH
68515: LD_STRING 1
68517: ST_TO_ADDR
// end ; normal := normal & tmp ;
68518: LD_ADDR_VAR 0 3
68522: PUSH
68523: LD_VAR 0 3
68527: PUSH
68528: LD_VAR 0 2
68532: STR
68533: ST_TO_ADDR
// end ;
68534: GO 68434
68536: POP
68537: POP
// for i = 1 to hardcoreCounter do
68538: LD_ADDR_VAR 0 5
68542: PUSH
68543: DOUBLE
68544: LD_INT 1
68546: DEC
68547: ST_TO_ADDR
68548: LD_EXP 101
68552: PUSH
68553: FOR_TO
68554: IFFALSE 68659
// begin tmp := 0 ;
68556: LD_ADDR_VAR 0 2
68560: PUSH
68561: LD_STRING 0
68563: ST_TO_ADDR
// if result [ 2 ] then
68564: LD_VAR 0 1
68568: PUSH
68569: LD_INT 2
68571: ARRAY
68572: IFFALSE 68641
// if result [ 2 ] [ 1 ] = 100 + i then
68574: LD_VAR 0 1
68578: PUSH
68579: LD_INT 2
68581: ARRAY
68582: PUSH
68583: LD_INT 1
68585: ARRAY
68586: PUSH
68587: LD_INT 100
68589: PUSH
68590: LD_VAR 0 5
68594: PLUS
68595: EQUAL
68596: IFFALSE 68641
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
68598: LD_ADDR_VAR 0 1
68602: PUSH
68603: LD_VAR 0 1
68607: PPUSH
68608: LD_INT 2
68610: PPUSH
68611: LD_VAR 0 1
68615: PUSH
68616: LD_INT 2
68618: ARRAY
68619: PPUSH
68620: LD_INT 1
68622: PPUSH
68623: CALL_OW 3
68627: PPUSH
68628: CALL_OW 1
68632: ST_TO_ADDR
// tmp := 1 ;
68633: LD_ADDR_VAR 0 2
68637: PUSH
68638: LD_STRING 1
68640: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
68641: LD_ADDR_VAR 0 4
68645: PUSH
68646: LD_VAR 0 4
68650: PUSH
68651: LD_VAR 0 2
68655: STR
68656: ST_TO_ADDR
// end ;
68657: GO 68553
68659: POP
68660: POP
// ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & ") ) ;
68661: LD_STRING getStreamItemsFromMission("
68663: PUSH
68664: LD_VAR 0 3
68668: STR
68669: PUSH
68670: LD_STRING ","
68672: STR
68673: PUSH
68674: LD_VAR 0 4
68678: STR
68679: PUSH
68680: LD_STRING ")
68682: STR
68683: PPUSH
68684: CALL_OW 559
// end else
68688: GO 68697
// ToLua ( getStreamItemsFromMission("","") ) ;
68690: LD_STRING getStreamItemsFromMission("","")
68692: PPUSH
68693: CALL_OW 559
// end ;
68697: LD_VAR 0 1
68701: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
68702: LD_EXP 99
68706: PUSH
68707: LD_EXP 104
68711: AND
68712: IFFALSE 68836
68714: GO 68716
68716: DISABLE
68717: LD_INT 0
68719: PPUSH
68720: PPUSH
// begin enable ;
68721: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
68722: LD_ADDR_VAR 0 2
68726: PUSH
68727: LD_INT 22
68729: PUSH
68730: LD_OWVAR 2
68734: PUSH
68735: EMPTY
68736: LIST
68737: LIST
68738: PUSH
68739: LD_INT 2
68741: PUSH
68742: LD_INT 34
68744: PUSH
68745: LD_INT 7
68747: PUSH
68748: EMPTY
68749: LIST
68750: LIST
68751: PUSH
68752: LD_INT 34
68754: PUSH
68755: LD_INT 45
68757: PUSH
68758: EMPTY
68759: LIST
68760: LIST
68761: PUSH
68762: LD_INT 34
68764: PUSH
68765: LD_INT 28
68767: PUSH
68768: EMPTY
68769: LIST
68770: LIST
68771: PUSH
68772: LD_INT 34
68774: PUSH
68775: LD_INT 47
68777: PUSH
68778: EMPTY
68779: LIST
68780: LIST
68781: PUSH
68782: EMPTY
68783: LIST
68784: LIST
68785: LIST
68786: LIST
68787: LIST
68788: PUSH
68789: EMPTY
68790: LIST
68791: LIST
68792: PPUSH
68793: CALL_OW 69
68797: ST_TO_ADDR
// if not tmp then
68798: LD_VAR 0 2
68802: NOT
68803: IFFALSE 68807
// exit ;
68805: GO 68836
// for i in tmp do
68807: LD_ADDR_VAR 0 1
68811: PUSH
68812: LD_VAR 0 2
68816: PUSH
68817: FOR_IN
68818: IFFALSE 68834
// begin SetLives ( i , 0 ) ;
68820: LD_VAR 0 1
68824: PPUSH
68825: LD_INT 0
68827: PPUSH
68828: CALL_OW 234
// end ;
68832: GO 68817
68834: POP
68835: POP
// end ;
68836: PPOPN 2
68838: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
68839: LD_EXP 99
68843: PUSH
68844: LD_EXP 105
68848: AND
68849: IFFALSE 68933
68851: GO 68853
68853: DISABLE
68854: LD_INT 0
68856: PPUSH
68857: PPUSH
// begin enable ;
68858: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
68859: LD_ADDR_VAR 0 2
68863: PUSH
68864: LD_INT 22
68866: PUSH
68867: LD_OWVAR 2
68871: PUSH
68872: EMPTY
68873: LIST
68874: LIST
68875: PUSH
68876: LD_INT 32
68878: PUSH
68879: LD_INT 3
68881: PUSH
68882: EMPTY
68883: LIST
68884: LIST
68885: PUSH
68886: EMPTY
68887: LIST
68888: LIST
68889: PPUSH
68890: CALL_OW 69
68894: ST_TO_ADDR
// if not tmp then
68895: LD_VAR 0 2
68899: NOT
68900: IFFALSE 68904
// exit ;
68902: GO 68933
// for i in tmp do
68904: LD_ADDR_VAR 0 1
68908: PUSH
68909: LD_VAR 0 2
68913: PUSH
68914: FOR_IN
68915: IFFALSE 68931
// begin SetLives ( i , 0 ) ;
68917: LD_VAR 0 1
68921: PPUSH
68922: LD_INT 0
68924: PPUSH
68925: CALL_OW 234
// end ;
68929: GO 68914
68931: POP
68932: POP
// end ;
68933: PPOPN 2
68935: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
68936: LD_EXP 99
68940: PUSH
68941: LD_EXP 102
68945: AND
68946: IFFALSE 69039
68948: GO 68950
68950: DISABLE
68951: LD_INT 0
68953: PPUSH
// begin enable ;
68954: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
68955: LD_ADDR_VAR 0 1
68959: PUSH
68960: LD_INT 22
68962: PUSH
68963: LD_OWVAR 2
68967: PUSH
68968: EMPTY
68969: LIST
68970: LIST
68971: PUSH
68972: LD_INT 2
68974: PUSH
68975: LD_INT 25
68977: PUSH
68978: LD_INT 5
68980: PUSH
68981: EMPTY
68982: LIST
68983: LIST
68984: PUSH
68985: LD_INT 25
68987: PUSH
68988: LD_INT 9
68990: PUSH
68991: EMPTY
68992: LIST
68993: LIST
68994: PUSH
68995: LD_INT 25
68997: PUSH
68998: LD_INT 8
69000: PUSH
69001: EMPTY
69002: LIST
69003: LIST
69004: PUSH
69005: EMPTY
69006: LIST
69007: LIST
69008: LIST
69009: LIST
69010: PUSH
69011: EMPTY
69012: LIST
69013: LIST
69014: PPUSH
69015: CALL_OW 69
69019: PUSH
69020: FOR_IN
69021: IFFALSE 69037
// begin SetClass ( i , 1 ) ;
69023: LD_VAR 0 1
69027: PPUSH
69028: LD_INT 1
69030: PPUSH
69031: CALL_OW 336
// end ;
69035: GO 69020
69037: POP
69038: POP
// end ;
69039: PPOPN 1
69041: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
69042: LD_EXP 99
69046: PUSH
69047: LD_EXP 103
69051: AND
69052: PUSH
69053: LD_OWVAR 65
69057: PUSH
69058: LD_INT 7
69060: LESS
69061: AND
69062: IFFALSE 69076
69064: GO 69066
69066: DISABLE
// begin enable ;
69067: ENABLE
// game_speed := 7 ;
69068: LD_ADDR_OWVAR 65
69072: PUSH
69073: LD_INT 7
69075: ST_TO_ADDR
// end ;
69076: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
69077: LD_EXP 99
69081: PUSH
69082: LD_EXP 106
69086: AND
69087: IFFALSE 69289
69089: GO 69091
69091: DISABLE
69092: LD_INT 0
69094: PPUSH
69095: PPUSH
69096: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
69097: LD_ADDR_VAR 0 3
69101: PUSH
69102: LD_INT 81
69104: PUSH
69105: LD_OWVAR 2
69109: PUSH
69110: EMPTY
69111: LIST
69112: LIST
69113: PUSH
69114: LD_INT 21
69116: PUSH
69117: LD_INT 1
69119: PUSH
69120: EMPTY
69121: LIST
69122: LIST
69123: PUSH
69124: EMPTY
69125: LIST
69126: LIST
69127: PPUSH
69128: CALL_OW 69
69132: ST_TO_ADDR
// if not tmp then
69133: LD_VAR 0 3
69137: NOT
69138: IFFALSE 69142
// exit ;
69140: GO 69289
// if tmp > 5 then
69142: LD_VAR 0 3
69146: PUSH
69147: LD_INT 5
69149: GREATER
69150: IFFALSE 69162
// k := 5 else
69152: LD_ADDR_VAR 0 2
69156: PUSH
69157: LD_INT 5
69159: ST_TO_ADDR
69160: GO 69172
// k := tmp ;
69162: LD_ADDR_VAR 0 2
69166: PUSH
69167: LD_VAR 0 3
69171: ST_TO_ADDR
// for i := 1 to k do
69172: LD_ADDR_VAR 0 1
69176: PUSH
69177: DOUBLE
69178: LD_INT 1
69180: DEC
69181: ST_TO_ADDR
69182: LD_VAR 0 2
69186: PUSH
69187: FOR_TO
69188: IFFALSE 69287
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
69190: LD_VAR 0 3
69194: PUSH
69195: LD_VAR 0 1
69199: ARRAY
69200: PPUSH
69201: LD_VAR 0 1
69205: PUSH
69206: LD_INT 4
69208: MOD
69209: PUSH
69210: LD_INT 1
69212: PLUS
69213: PPUSH
69214: CALL_OW 259
69218: PUSH
69219: LD_INT 10
69221: LESS
69222: IFFALSE 69285
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
69224: LD_VAR 0 3
69228: PUSH
69229: LD_VAR 0 1
69233: ARRAY
69234: PPUSH
69235: LD_VAR 0 1
69239: PUSH
69240: LD_INT 4
69242: MOD
69243: PUSH
69244: LD_INT 1
69246: PLUS
69247: PPUSH
69248: LD_VAR 0 3
69252: PUSH
69253: LD_VAR 0 1
69257: ARRAY
69258: PPUSH
69259: LD_VAR 0 1
69263: PUSH
69264: LD_INT 4
69266: MOD
69267: PUSH
69268: LD_INT 1
69270: PLUS
69271: PPUSH
69272: CALL_OW 259
69276: PUSH
69277: LD_INT 1
69279: PLUS
69280: PPUSH
69281: CALL_OW 237
69285: GO 69187
69287: POP
69288: POP
// end ;
69289: PPOPN 3
69291: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
69292: LD_EXP 99
69296: PUSH
69297: LD_EXP 107
69301: AND
69302: IFFALSE 69322
69304: GO 69306
69306: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
69307: LD_INT 4
69309: PPUSH
69310: LD_OWVAR 2
69314: PPUSH
69315: LD_INT 0
69317: PPUSH
69318: CALL_OW 324
69322: END
// every 0 0$1 trigger StreamModeActive and sShovel do
69323: LD_EXP 99
69327: PUSH
69328: LD_EXP 136
69332: AND
69333: IFFALSE 69353
69335: GO 69337
69337: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
69338: LD_INT 19
69340: PPUSH
69341: LD_OWVAR 2
69345: PPUSH
69346: LD_INT 0
69348: PPUSH
69349: CALL_OW 324
69353: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
69354: LD_EXP 99
69358: PUSH
69359: LD_EXP 108
69363: AND
69364: IFFALSE 69466
69366: GO 69368
69368: DISABLE
69369: LD_INT 0
69371: PPUSH
69372: PPUSH
// begin enable ;
69373: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
69374: LD_ADDR_VAR 0 2
69378: PUSH
69379: LD_INT 22
69381: PUSH
69382: LD_OWVAR 2
69386: PUSH
69387: EMPTY
69388: LIST
69389: LIST
69390: PUSH
69391: LD_INT 2
69393: PUSH
69394: LD_INT 34
69396: PUSH
69397: LD_INT 11
69399: PUSH
69400: EMPTY
69401: LIST
69402: LIST
69403: PUSH
69404: LD_INT 34
69406: PUSH
69407: LD_INT 30
69409: PUSH
69410: EMPTY
69411: LIST
69412: LIST
69413: PUSH
69414: EMPTY
69415: LIST
69416: LIST
69417: LIST
69418: PUSH
69419: EMPTY
69420: LIST
69421: LIST
69422: PPUSH
69423: CALL_OW 69
69427: ST_TO_ADDR
// if not tmp then
69428: LD_VAR 0 2
69432: NOT
69433: IFFALSE 69437
// exit ;
69435: GO 69466
// for i in tmp do
69437: LD_ADDR_VAR 0 1
69441: PUSH
69442: LD_VAR 0 2
69446: PUSH
69447: FOR_IN
69448: IFFALSE 69464
// begin SetLives ( i , 0 ) ;
69450: LD_VAR 0 1
69454: PPUSH
69455: LD_INT 0
69457: PPUSH
69458: CALL_OW 234
// end ;
69462: GO 69447
69464: POP
69465: POP
// end ;
69466: PPOPN 2
69468: END
// every 0 0$1 trigger StreamModeActive and sBunker do
69469: LD_EXP 99
69473: PUSH
69474: LD_EXP 109
69478: AND
69479: IFFALSE 69499
69481: GO 69483
69483: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
69484: LD_INT 32
69486: PPUSH
69487: LD_OWVAR 2
69491: PPUSH
69492: LD_INT 0
69494: PPUSH
69495: CALL_OW 324
69499: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
69500: LD_EXP 99
69504: PUSH
69505: LD_EXP 110
69509: AND
69510: IFFALSE 69691
69512: GO 69514
69514: DISABLE
69515: LD_INT 0
69517: PPUSH
69518: PPUSH
69519: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
69520: LD_ADDR_VAR 0 2
69524: PUSH
69525: LD_INT 22
69527: PUSH
69528: LD_OWVAR 2
69532: PUSH
69533: EMPTY
69534: LIST
69535: LIST
69536: PUSH
69537: LD_INT 33
69539: PUSH
69540: LD_INT 3
69542: PUSH
69543: EMPTY
69544: LIST
69545: LIST
69546: PUSH
69547: EMPTY
69548: LIST
69549: LIST
69550: PPUSH
69551: CALL_OW 69
69555: ST_TO_ADDR
// if not tmp then
69556: LD_VAR 0 2
69560: NOT
69561: IFFALSE 69565
// exit ;
69563: GO 69691
// side := 0 ;
69565: LD_ADDR_VAR 0 3
69569: PUSH
69570: LD_INT 0
69572: ST_TO_ADDR
// for i := 1 to 8 do
69573: LD_ADDR_VAR 0 1
69577: PUSH
69578: DOUBLE
69579: LD_INT 1
69581: DEC
69582: ST_TO_ADDR
69583: LD_INT 8
69585: PUSH
69586: FOR_TO
69587: IFFALSE 69635
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
69589: LD_OWVAR 2
69593: PUSH
69594: LD_VAR 0 1
69598: NONEQUAL
69599: PUSH
69600: LD_OWVAR 2
69604: PPUSH
69605: LD_VAR 0 1
69609: PPUSH
69610: CALL_OW 81
69614: PUSH
69615: LD_INT 2
69617: EQUAL
69618: AND
69619: IFFALSE 69633
// begin side := i ;
69621: LD_ADDR_VAR 0 3
69625: PUSH
69626: LD_VAR 0 1
69630: ST_TO_ADDR
// break ;
69631: GO 69635
// end ;
69633: GO 69586
69635: POP
69636: POP
// if not side then
69637: LD_VAR 0 3
69641: NOT
69642: IFFALSE 69646
// exit ;
69644: GO 69691
// for i := 1 to tmp do
69646: LD_ADDR_VAR 0 1
69650: PUSH
69651: DOUBLE
69652: LD_INT 1
69654: DEC
69655: ST_TO_ADDR
69656: LD_VAR 0 2
69660: PUSH
69661: FOR_TO
69662: IFFALSE 69689
// if Prob ( 60 ) then
69664: LD_INT 60
69666: PPUSH
69667: CALL_OW 13
69671: IFFALSE 69687
// SetSide ( i , side ) ;
69673: LD_VAR 0 1
69677: PPUSH
69678: LD_VAR 0 3
69682: PPUSH
69683: CALL_OW 235
69687: GO 69661
69689: POP
69690: POP
// end ;
69691: PPOPN 3
69693: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
69694: LD_EXP 99
69698: PUSH
69699: LD_EXP 112
69703: AND
69704: IFFALSE 69823
69706: GO 69708
69708: DISABLE
69709: LD_INT 0
69711: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
69712: LD_ADDR_VAR 0 1
69716: PUSH
69717: LD_INT 22
69719: PUSH
69720: LD_OWVAR 2
69724: PUSH
69725: EMPTY
69726: LIST
69727: LIST
69728: PUSH
69729: LD_INT 21
69731: PUSH
69732: LD_INT 1
69734: PUSH
69735: EMPTY
69736: LIST
69737: LIST
69738: PUSH
69739: LD_INT 3
69741: PUSH
69742: LD_INT 23
69744: PUSH
69745: LD_INT 0
69747: PUSH
69748: EMPTY
69749: LIST
69750: LIST
69751: PUSH
69752: EMPTY
69753: LIST
69754: LIST
69755: PUSH
69756: EMPTY
69757: LIST
69758: LIST
69759: LIST
69760: PPUSH
69761: CALL_OW 69
69765: PUSH
69766: FOR_IN
69767: IFFALSE 69821
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
69769: LD_VAR 0 1
69773: PPUSH
69774: CALL_OW 257
69778: PUSH
69779: LD_INT 1
69781: PUSH
69782: LD_INT 2
69784: PUSH
69785: LD_INT 3
69787: PUSH
69788: LD_INT 4
69790: PUSH
69791: EMPTY
69792: LIST
69793: LIST
69794: LIST
69795: LIST
69796: IN
69797: IFFALSE 69819
// SetClass ( un , rand ( 1 , 4 ) ) ;
69799: LD_VAR 0 1
69803: PPUSH
69804: LD_INT 1
69806: PPUSH
69807: LD_INT 4
69809: PPUSH
69810: CALL_OW 12
69814: PPUSH
69815: CALL_OW 336
69819: GO 69766
69821: POP
69822: POP
// end ;
69823: PPOPN 1
69825: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
69826: LD_EXP 99
69830: PUSH
69831: LD_EXP 111
69835: AND
69836: IFFALSE 69915
69838: GO 69840
69840: DISABLE
69841: LD_INT 0
69843: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
69844: LD_ADDR_VAR 0 1
69848: PUSH
69849: LD_INT 22
69851: PUSH
69852: LD_OWVAR 2
69856: PUSH
69857: EMPTY
69858: LIST
69859: LIST
69860: PUSH
69861: LD_INT 21
69863: PUSH
69864: LD_INT 3
69866: PUSH
69867: EMPTY
69868: LIST
69869: LIST
69870: PUSH
69871: EMPTY
69872: LIST
69873: LIST
69874: PPUSH
69875: CALL_OW 69
69879: ST_TO_ADDR
// if not tmp then
69880: LD_VAR 0 1
69884: NOT
69885: IFFALSE 69889
// exit ;
69887: GO 69915
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
69889: LD_VAR 0 1
69893: PUSH
69894: LD_INT 1
69896: PPUSH
69897: LD_VAR 0 1
69901: PPUSH
69902: CALL_OW 12
69906: ARRAY
69907: PPUSH
69908: LD_INT 100
69910: PPUSH
69911: CALL_OW 234
// end ;
69915: PPOPN 1
69917: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
69918: LD_EXP 99
69922: PUSH
69923: LD_EXP 113
69927: AND
69928: IFFALSE 70026
69930: GO 69932
69932: DISABLE
69933: LD_INT 0
69935: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
69936: LD_ADDR_VAR 0 1
69940: PUSH
69941: LD_INT 22
69943: PUSH
69944: LD_OWVAR 2
69948: PUSH
69949: EMPTY
69950: LIST
69951: LIST
69952: PUSH
69953: LD_INT 21
69955: PUSH
69956: LD_INT 1
69958: PUSH
69959: EMPTY
69960: LIST
69961: LIST
69962: PUSH
69963: EMPTY
69964: LIST
69965: LIST
69966: PPUSH
69967: CALL_OW 69
69971: ST_TO_ADDR
// if not tmp then
69972: LD_VAR 0 1
69976: NOT
69977: IFFALSE 69981
// exit ;
69979: GO 70026
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
69981: LD_VAR 0 1
69985: PUSH
69986: LD_INT 1
69988: PPUSH
69989: LD_VAR 0 1
69993: PPUSH
69994: CALL_OW 12
69998: ARRAY
69999: PPUSH
70000: LD_INT 1
70002: PPUSH
70003: LD_INT 4
70005: PPUSH
70006: CALL_OW 12
70010: PPUSH
70011: LD_INT 3000
70013: PPUSH
70014: LD_INT 9000
70016: PPUSH
70017: CALL_OW 12
70021: PPUSH
70022: CALL_OW 492
// end ;
70026: PPOPN 1
70028: END
// every 0 0$1 trigger StreamModeActive and sDepot do
70029: LD_EXP 99
70033: PUSH
70034: LD_EXP 114
70038: AND
70039: IFFALSE 70059
70041: GO 70043
70043: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
70044: LD_INT 1
70046: PPUSH
70047: LD_OWVAR 2
70051: PPUSH
70052: LD_INT 0
70054: PPUSH
70055: CALL_OW 324
70059: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
70060: LD_EXP 99
70064: PUSH
70065: LD_EXP 115
70069: AND
70070: IFFALSE 70153
70072: GO 70074
70074: DISABLE
70075: LD_INT 0
70077: PPUSH
70078: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
70079: LD_ADDR_VAR 0 2
70083: PUSH
70084: LD_INT 22
70086: PUSH
70087: LD_OWVAR 2
70091: PUSH
70092: EMPTY
70093: LIST
70094: LIST
70095: PUSH
70096: LD_INT 21
70098: PUSH
70099: LD_INT 3
70101: PUSH
70102: EMPTY
70103: LIST
70104: LIST
70105: PUSH
70106: EMPTY
70107: LIST
70108: LIST
70109: PPUSH
70110: CALL_OW 69
70114: ST_TO_ADDR
// if not tmp then
70115: LD_VAR 0 2
70119: NOT
70120: IFFALSE 70124
// exit ;
70122: GO 70153
// for i in tmp do
70124: LD_ADDR_VAR 0 1
70128: PUSH
70129: LD_VAR 0 2
70133: PUSH
70134: FOR_IN
70135: IFFALSE 70151
// SetBLevel ( i , 10 ) ;
70137: LD_VAR 0 1
70141: PPUSH
70142: LD_INT 10
70144: PPUSH
70145: CALL_OW 241
70149: GO 70134
70151: POP
70152: POP
// end ;
70153: PPOPN 2
70155: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
70156: LD_EXP 99
70160: PUSH
70161: LD_EXP 116
70165: AND
70166: IFFALSE 70277
70168: GO 70170
70170: DISABLE
70171: LD_INT 0
70173: PPUSH
70174: PPUSH
70175: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
70176: LD_ADDR_VAR 0 3
70180: PUSH
70181: LD_INT 22
70183: PUSH
70184: LD_OWVAR 2
70188: PUSH
70189: EMPTY
70190: LIST
70191: LIST
70192: PUSH
70193: LD_INT 25
70195: PUSH
70196: LD_INT 1
70198: PUSH
70199: EMPTY
70200: LIST
70201: LIST
70202: PUSH
70203: EMPTY
70204: LIST
70205: LIST
70206: PPUSH
70207: CALL_OW 69
70211: ST_TO_ADDR
// if not tmp then
70212: LD_VAR 0 3
70216: NOT
70217: IFFALSE 70221
// exit ;
70219: GO 70277
// un := tmp [ rand ( 1 , tmp ) ] ;
70221: LD_ADDR_VAR 0 2
70225: PUSH
70226: LD_VAR 0 3
70230: PUSH
70231: LD_INT 1
70233: PPUSH
70234: LD_VAR 0 3
70238: PPUSH
70239: CALL_OW 12
70243: ARRAY
70244: ST_TO_ADDR
// if Crawls ( un ) then
70245: LD_VAR 0 2
70249: PPUSH
70250: CALL_OW 318
70254: IFFALSE 70265
// ComWalk ( un ) ;
70256: LD_VAR 0 2
70260: PPUSH
70261: CALL_OW 138
// SetClass ( un , class_sniper ) ;
70265: LD_VAR 0 2
70269: PPUSH
70270: LD_INT 5
70272: PPUSH
70273: CALL_OW 336
// end ;
70277: PPOPN 3
70279: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 4 do
70280: LD_EXP 99
70284: PUSH
70285: LD_EXP 117
70289: AND
70290: PUSH
70291: LD_OWVAR 67
70295: PUSH
70296: LD_INT 4
70298: LESS
70299: AND
70300: IFFALSE 70319
70302: GO 70304
70304: DISABLE
// begin Difficulty := Difficulty + 1 ;
70305: LD_ADDR_OWVAR 67
70309: PUSH
70310: LD_OWVAR 67
70314: PUSH
70315: LD_INT 1
70317: PLUS
70318: ST_TO_ADDR
// end ;
70319: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
70320: LD_EXP 99
70324: PUSH
70325: LD_EXP 118
70329: AND
70330: IFFALSE 70433
70332: GO 70334
70334: DISABLE
70335: LD_INT 0
70337: PPUSH
// begin for i := 1 to 5 do
70338: LD_ADDR_VAR 0 1
70342: PUSH
70343: DOUBLE
70344: LD_INT 1
70346: DEC
70347: ST_TO_ADDR
70348: LD_INT 5
70350: PUSH
70351: FOR_TO
70352: IFFALSE 70431
// begin uc_nation := nation_nature ;
70354: LD_ADDR_OWVAR 21
70358: PUSH
70359: LD_INT 0
70361: ST_TO_ADDR
// uc_side := 0 ;
70362: LD_ADDR_OWVAR 20
70366: PUSH
70367: LD_INT 0
70369: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
70370: LD_ADDR_OWVAR 29
70374: PUSH
70375: LD_INT 12
70377: PUSH
70378: LD_INT 12
70380: PUSH
70381: EMPTY
70382: LIST
70383: LIST
70384: ST_TO_ADDR
// hc_agressivity := 20 ;
70385: LD_ADDR_OWVAR 35
70389: PUSH
70390: LD_INT 20
70392: ST_TO_ADDR
// hc_class := class_tiger ;
70393: LD_ADDR_OWVAR 28
70397: PUSH
70398: LD_INT 14
70400: ST_TO_ADDR
// hc_gallery :=  ;
70401: LD_ADDR_OWVAR 33
70405: PUSH
70406: LD_STRING 
70408: ST_TO_ADDR
// hc_name :=  ;
70409: LD_ADDR_OWVAR 26
70413: PUSH
70414: LD_STRING 
70416: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
70417: CALL_OW 44
70421: PPUSH
70422: LD_INT 0
70424: PPUSH
70425: CALL_OW 51
// end ;
70429: GO 70351
70431: POP
70432: POP
// end ;
70433: PPOPN 1
70435: END
// every 0 0$1 trigger StreamModeActive and sBomb do
70436: LD_EXP 99
70440: PUSH
70441: LD_EXP 119
70445: AND
70446: IFFALSE 70455
70448: GO 70450
70450: DISABLE
// StreamSibBomb ;
70451: CALL 70456 0 0
70455: END
// export function StreamSibBomb ; var i , x , y ; begin
70456: LD_INT 0
70458: PPUSH
70459: PPUSH
70460: PPUSH
70461: PPUSH
// result := false ;
70462: LD_ADDR_VAR 0 1
70466: PUSH
70467: LD_INT 0
70469: ST_TO_ADDR
// for i := 1 to 16 do
70470: LD_ADDR_VAR 0 2
70474: PUSH
70475: DOUBLE
70476: LD_INT 1
70478: DEC
70479: ST_TO_ADDR
70480: LD_INT 16
70482: PUSH
70483: FOR_TO
70484: IFFALSE 70683
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
70486: LD_ADDR_VAR 0 3
70490: PUSH
70491: LD_INT 10
70493: PUSH
70494: LD_INT 20
70496: PUSH
70497: LD_INT 30
70499: PUSH
70500: LD_INT 40
70502: PUSH
70503: LD_INT 50
70505: PUSH
70506: LD_INT 60
70508: PUSH
70509: LD_INT 70
70511: PUSH
70512: LD_INT 80
70514: PUSH
70515: LD_INT 90
70517: PUSH
70518: LD_INT 100
70520: PUSH
70521: LD_INT 110
70523: PUSH
70524: LD_INT 120
70526: PUSH
70527: LD_INT 130
70529: PUSH
70530: LD_INT 140
70532: PUSH
70533: LD_INT 150
70535: PUSH
70536: EMPTY
70537: LIST
70538: LIST
70539: LIST
70540: LIST
70541: LIST
70542: LIST
70543: LIST
70544: LIST
70545: LIST
70546: LIST
70547: LIST
70548: LIST
70549: LIST
70550: LIST
70551: LIST
70552: PUSH
70553: LD_INT 1
70555: PPUSH
70556: LD_INT 15
70558: PPUSH
70559: CALL_OW 12
70563: ARRAY
70564: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
70565: LD_ADDR_VAR 0 4
70569: PUSH
70570: LD_INT 10
70572: PUSH
70573: LD_INT 20
70575: PUSH
70576: LD_INT 30
70578: PUSH
70579: LD_INT 40
70581: PUSH
70582: LD_INT 50
70584: PUSH
70585: LD_INT 60
70587: PUSH
70588: LD_INT 70
70590: PUSH
70591: LD_INT 80
70593: PUSH
70594: LD_INT 90
70596: PUSH
70597: LD_INT 100
70599: PUSH
70600: LD_INT 110
70602: PUSH
70603: LD_INT 120
70605: PUSH
70606: LD_INT 130
70608: PUSH
70609: LD_INT 140
70611: PUSH
70612: LD_INT 150
70614: PUSH
70615: EMPTY
70616: LIST
70617: LIST
70618: LIST
70619: LIST
70620: LIST
70621: LIST
70622: LIST
70623: LIST
70624: LIST
70625: LIST
70626: LIST
70627: LIST
70628: LIST
70629: LIST
70630: LIST
70631: PUSH
70632: LD_INT 1
70634: PPUSH
70635: LD_INT 15
70637: PPUSH
70638: CALL_OW 12
70642: ARRAY
70643: ST_TO_ADDR
// if ValidHex ( x , y ) then
70644: LD_VAR 0 3
70648: PPUSH
70649: LD_VAR 0 4
70653: PPUSH
70654: CALL_OW 488
70658: IFFALSE 70681
// begin result := [ x , y ] ;
70660: LD_ADDR_VAR 0 1
70664: PUSH
70665: LD_VAR 0 3
70669: PUSH
70670: LD_VAR 0 4
70674: PUSH
70675: EMPTY
70676: LIST
70677: LIST
70678: ST_TO_ADDR
// break ;
70679: GO 70683
// end ; end ;
70681: GO 70483
70683: POP
70684: POP
// if result then
70685: LD_VAR 0 1
70689: IFFALSE 70749
// begin ToLua ( playSibBomb() ) ;
70691: LD_STRING playSibBomb()
70693: PPUSH
70694: CALL_OW 559
// wait ( 0 0$14 ) ;
70698: LD_INT 490
70700: PPUSH
70701: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
70705: LD_VAR 0 1
70709: PUSH
70710: LD_INT 1
70712: ARRAY
70713: PPUSH
70714: LD_VAR 0 1
70718: PUSH
70719: LD_INT 2
70721: ARRAY
70722: PPUSH
70723: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
70727: LD_VAR 0 1
70731: PUSH
70732: LD_INT 1
70734: ARRAY
70735: PPUSH
70736: LD_VAR 0 1
70740: PUSH
70741: LD_INT 2
70743: ARRAY
70744: PPUSH
70745: CALL_OW 429
// end ; end ;
70749: LD_VAR 0 1
70753: RET
// every 0 0$1 trigger StreamModeActive and sReset do
70754: LD_EXP 99
70758: PUSH
70759: LD_EXP 121
70763: AND
70764: IFFALSE 70776
70766: GO 70768
70768: DISABLE
// YouLost (  ) ;
70769: LD_STRING 
70771: PPUSH
70772: CALL_OW 104
70776: END
// every 0 0$1 trigger StreamModeActive and sFog do
70777: LD_EXP 99
70781: PUSH
70782: LD_EXP 120
70786: AND
70787: IFFALSE 70801
70789: GO 70791
70791: DISABLE
// FogOff ( your_side ) ;
70792: LD_OWVAR 2
70796: PPUSH
70797: CALL_OW 344
70801: END
// every 0 0$1 trigger StreamModeActive and sSun do
70802: LD_EXP 99
70806: PUSH
70807: LD_EXP 122
70811: AND
70812: IFFALSE 70840
70814: GO 70816
70816: DISABLE
// begin solar_recharge_percent := 0 ;
70817: LD_ADDR_OWVAR 79
70821: PUSH
70822: LD_INT 0
70824: ST_TO_ADDR
// wait ( 5 5$00 ) ;
70825: LD_INT 10500
70827: PPUSH
70828: CALL_OW 67
// solar_recharge_percent := 100 ;
70832: LD_ADDR_OWVAR 79
70836: PUSH
70837: LD_INT 100
70839: ST_TO_ADDR
// end ;
70840: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
70841: LD_EXP 99
70845: PUSH
70846: LD_EXP 123
70850: AND
70851: IFFALSE 71090
70853: GO 70855
70855: DISABLE
70856: LD_INT 0
70858: PPUSH
70859: PPUSH
70860: PPUSH
// begin tmp := [ ] ;
70861: LD_ADDR_VAR 0 3
70865: PUSH
70866: EMPTY
70867: ST_TO_ADDR
// for i := 1 to 6 do
70868: LD_ADDR_VAR 0 1
70872: PUSH
70873: DOUBLE
70874: LD_INT 1
70876: DEC
70877: ST_TO_ADDR
70878: LD_INT 6
70880: PUSH
70881: FOR_TO
70882: IFFALSE 70987
// begin uc_nation := nation_nature ;
70884: LD_ADDR_OWVAR 21
70888: PUSH
70889: LD_INT 0
70891: ST_TO_ADDR
// uc_side := 0 ;
70892: LD_ADDR_OWVAR 20
70896: PUSH
70897: LD_INT 0
70899: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
70900: LD_ADDR_OWVAR 29
70904: PUSH
70905: LD_INT 12
70907: PUSH
70908: LD_INT 12
70910: PUSH
70911: EMPTY
70912: LIST
70913: LIST
70914: ST_TO_ADDR
// hc_agressivity := 20 ;
70915: LD_ADDR_OWVAR 35
70919: PUSH
70920: LD_INT 20
70922: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
70923: LD_ADDR_OWVAR 28
70927: PUSH
70928: LD_INT 17
70930: ST_TO_ADDR
// hc_gallery :=  ;
70931: LD_ADDR_OWVAR 33
70935: PUSH
70936: LD_STRING 
70938: ST_TO_ADDR
// hc_name :=  ;
70939: LD_ADDR_OWVAR 26
70943: PUSH
70944: LD_STRING 
70946: ST_TO_ADDR
// un := CreateHuman ;
70947: LD_ADDR_VAR 0 2
70951: PUSH
70952: CALL_OW 44
70956: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
70957: LD_VAR 0 2
70961: PPUSH
70962: LD_INT 1
70964: PPUSH
70965: CALL_OW 51
// tmp := tmp ^ un ;
70969: LD_ADDR_VAR 0 3
70973: PUSH
70974: LD_VAR 0 3
70978: PUSH
70979: LD_VAR 0 2
70983: ADD
70984: ST_TO_ADDR
// end ;
70985: GO 70881
70987: POP
70988: POP
// repeat wait ( 0 0$1 ) ;
70989: LD_INT 35
70991: PPUSH
70992: CALL_OW 67
// for un in tmp do
70996: LD_ADDR_VAR 0 2
71000: PUSH
71001: LD_VAR 0 3
71005: PUSH
71006: FOR_IN
71007: IFFALSE 71081
// begin if IsDead ( un ) then
71009: LD_VAR 0 2
71013: PPUSH
71014: CALL_OW 301
71018: IFFALSE 71038
// begin tmp := tmp diff un ;
71020: LD_ADDR_VAR 0 3
71024: PUSH
71025: LD_VAR 0 3
71029: PUSH
71030: LD_VAR 0 2
71034: DIFF
71035: ST_TO_ADDR
// continue ;
71036: GO 71006
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
71038: LD_VAR 0 2
71042: PPUSH
71043: LD_INT 3
71045: PUSH
71046: LD_INT 22
71048: PUSH
71049: LD_INT 0
71051: PUSH
71052: EMPTY
71053: LIST
71054: LIST
71055: PUSH
71056: EMPTY
71057: LIST
71058: LIST
71059: PPUSH
71060: CALL_OW 69
71064: PPUSH
71065: LD_VAR 0 2
71069: PPUSH
71070: CALL_OW 74
71074: PPUSH
71075: CALL_OW 115
// end ;
71079: GO 71006
71081: POP
71082: POP
// until not tmp ;
71083: LD_VAR 0 3
71087: NOT
71088: IFFALSE 70989
// end ;
71090: PPOPN 3
71092: END
// every 0 0$1 trigger StreamModeActive and sTroll do
71093: LD_EXP 99
71097: PUSH
71098: LD_EXP 124
71102: AND
71103: IFFALSE 71157
71105: GO 71107
71107: DISABLE
// begin ToLua ( displayTroll(); ) ;
71108: LD_STRING displayTroll();
71110: PPUSH
71111: CALL_OW 559
// wait ( 3 3$00 ) ;
71115: LD_INT 6300
71117: PPUSH
71118: CALL_OW 67
// ToLua ( hideTroll(); ) ;
71122: LD_STRING hideTroll();
71124: PPUSH
71125: CALL_OW 559
// wait ( 1 1$00 ) ;
71129: LD_INT 2100
71131: PPUSH
71132: CALL_OW 67
// ToLua ( displayTroll(); ) ;
71136: LD_STRING displayTroll();
71138: PPUSH
71139: CALL_OW 559
// wait ( 1 1$00 ) ;
71143: LD_INT 2100
71145: PPUSH
71146: CALL_OW 67
// ToLua ( hideTroll(); ) ;
71150: LD_STRING hideTroll();
71152: PPUSH
71153: CALL_OW 559
// end ;
71157: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
71158: LD_EXP 99
71162: PUSH
71163: LD_EXP 125
71167: AND
71168: IFFALSE 71231
71170: GO 71172
71172: DISABLE
71173: LD_INT 0
71175: PPUSH
// begin p := 0 ;
71176: LD_ADDR_VAR 0 1
71180: PUSH
71181: LD_INT 0
71183: ST_TO_ADDR
// repeat game_speed := 1 ;
71184: LD_ADDR_OWVAR 65
71188: PUSH
71189: LD_INT 1
71191: ST_TO_ADDR
// wait ( 0 0$1 ) ;
71192: LD_INT 35
71194: PPUSH
71195: CALL_OW 67
// p := p + 1 ;
71199: LD_ADDR_VAR 0 1
71203: PUSH
71204: LD_VAR 0 1
71208: PUSH
71209: LD_INT 1
71211: PLUS
71212: ST_TO_ADDR
// until p >= 60 ;
71213: LD_VAR 0 1
71217: PUSH
71218: LD_INT 60
71220: GREATEREQUAL
71221: IFFALSE 71184
// game_speed := 4 ;
71223: LD_ADDR_OWVAR 65
71227: PUSH
71228: LD_INT 4
71230: ST_TO_ADDR
// end ;
71231: PPOPN 1
71233: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
71234: LD_EXP 99
71238: PUSH
71239: LD_EXP 126
71243: AND
71244: IFFALSE 71390
71246: GO 71248
71248: DISABLE
71249: LD_INT 0
71251: PPUSH
71252: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
71253: LD_ADDR_VAR 0 1
71257: PUSH
71258: LD_INT 22
71260: PUSH
71261: LD_OWVAR 2
71265: PUSH
71266: EMPTY
71267: LIST
71268: LIST
71269: PUSH
71270: LD_INT 2
71272: PUSH
71273: LD_INT 30
71275: PUSH
71276: LD_INT 0
71278: PUSH
71279: EMPTY
71280: LIST
71281: LIST
71282: PUSH
71283: LD_INT 30
71285: PUSH
71286: LD_INT 1
71288: PUSH
71289: EMPTY
71290: LIST
71291: LIST
71292: PUSH
71293: EMPTY
71294: LIST
71295: LIST
71296: LIST
71297: PUSH
71298: EMPTY
71299: LIST
71300: LIST
71301: PPUSH
71302: CALL_OW 69
71306: ST_TO_ADDR
// if not depot then
71307: LD_VAR 0 1
71311: NOT
71312: IFFALSE 71316
// exit ;
71314: GO 71390
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
71316: LD_ADDR_VAR 0 2
71320: PUSH
71321: LD_VAR 0 1
71325: PUSH
71326: LD_INT 1
71328: PPUSH
71329: LD_VAR 0 1
71333: PPUSH
71334: CALL_OW 12
71338: ARRAY
71339: PPUSH
71340: CALL_OW 274
71344: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
71345: LD_VAR 0 2
71349: PPUSH
71350: LD_INT 1
71352: PPUSH
71353: LD_INT 0
71355: PPUSH
71356: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
71360: LD_VAR 0 2
71364: PPUSH
71365: LD_INT 2
71367: PPUSH
71368: LD_INT 0
71370: PPUSH
71371: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
71375: LD_VAR 0 2
71379: PPUSH
71380: LD_INT 3
71382: PPUSH
71383: LD_INT 0
71385: PPUSH
71386: CALL_OW 277
// end ;
71390: PPOPN 2
71392: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
71393: LD_EXP 99
71397: PUSH
71398: LD_EXP 127
71402: AND
71403: IFFALSE 71500
71405: GO 71407
71407: DISABLE
71408: LD_INT 0
71410: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
71411: LD_ADDR_VAR 0 1
71415: PUSH
71416: LD_INT 22
71418: PUSH
71419: LD_OWVAR 2
71423: PUSH
71424: EMPTY
71425: LIST
71426: LIST
71427: PUSH
71428: LD_INT 21
71430: PUSH
71431: LD_INT 1
71433: PUSH
71434: EMPTY
71435: LIST
71436: LIST
71437: PUSH
71438: LD_INT 3
71440: PUSH
71441: LD_INT 23
71443: PUSH
71444: LD_INT 0
71446: PUSH
71447: EMPTY
71448: LIST
71449: LIST
71450: PUSH
71451: EMPTY
71452: LIST
71453: LIST
71454: PUSH
71455: EMPTY
71456: LIST
71457: LIST
71458: LIST
71459: PPUSH
71460: CALL_OW 69
71464: ST_TO_ADDR
// if not tmp then
71465: LD_VAR 0 1
71469: NOT
71470: IFFALSE 71474
// exit ;
71472: GO 71500
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
71474: LD_VAR 0 1
71478: PUSH
71479: LD_INT 1
71481: PPUSH
71482: LD_VAR 0 1
71486: PPUSH
71487: CALL_OW 12
71491: ARRAY
71492: PPUSH
71493: LD_INT 200
71495: PPUSH
71496: CALL_OW 234
// end ;
71500: PPOPN 1
71502: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
71503: LD_EXP 99
71507: PUSH
71508: LD_EXP 128
71512: AND
71513: IFFALSE 71592
71515: GO 71517
71517: DISABLE
71518: LD_INT 0
71520: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
71521: LD_ADDR_VAR 0 1
71525: PUSH
71526: LD_INT 22
71528: PUSH
71529: LD_OWVAR 2
71533: PUSH
71534: EMPTY
71535: LIST
71536: LIST
71537: PUSH
71538: LD_INT 21
71540: PUSH
71541: LD_INT 2
71543: PUSH
71544: EMPTY
71545: LIST
71546: LIST
71547: PUSH
71548: EMPTY
71549: LIST
71550: LIST
71551: PPUSH
71552: CALL_OW 69
71556: ST_TO_ADDR
// if not tmp then
71557: LD_VAR 0 1
71561: NOT
71562: IFFALSE 71566
// exit ;
71564: GO 71592
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
71566: LD_VAR 0 1
71570: PUSH
71571: LD_INT 1
71573: PPUSH
71574: LD_VAR 0 1
71578: PPUSH
71579: CALL_OW 12
71583: ARRAY
71584: PPUSH
71585: LD_INT 60
71587: PPUSH
71588: CALL_OW 234
// end ;
71592: PPOPN 1
71594: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
71595: LD_EXP 99
71599: PUSH
71600: LD_EXP 129
71604: AND
71605: IFFALSE 71704
71607: GO 71609
71609: DISABLE
71610: LD_INT 0
71612: PPUSH
71613: PPUSH
// begin enable ;
71614: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
71615: LD_ADDR_VAR 0 1
71619: PUSH
71620: LD_INT 22
71622: PUSH
71623: LD_OWVAR 2
71627: PUSH
71628: EMPTY
71629: LIST
71630: LIST
71631: PUSH
71632: LD_INT 61
71634: PUSH
71635: EMPTY
71636: LIST
71637: PUSH
71638: LD_INT 33
71640: PUSH
71641: LD_INT 2
71643: PUSH
71644: EMPTY
71645: LIST
71646: LIST
71647: PUSH
71648: EMPTY
71649: LIST
71650: LIST
71651: LIST
71652: PPUSH
71653: CALL_OW 69
71657: ST_TO_ADDR
// if not tmp then
71658: LD_VAR 0 1
71662: NOT
71663: IFFALSE 71667
// exit ;
71665: GO 71704
// for i in tmp do
71667: LD_ADDR_VAR 0 2
71671: PUSH
71672: LD_VAR 0 1
71676: PUSH
71677: FOR_IN
71678: IFFALSE 71702
// if IsControledBy ( i ) then
71680: LD_VAR 0 2
71684: PPUSH
71685: CALL_OW 312
71689: IFFALSE 71700
// ComUnlink ( i ) ;
71691: LD_VAR 0 2
71695: PPUSH
71696: CALL_OW 136
71700: GO 71677
71702: POP
71703: POP
// end ;
71704: PPOPN 2
71706: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
71707: LD_EXP 99
71711: PUSH
71712: LD_EXP 130
71716: AND
71717: IFFALSE 71857
71719: GO 71721
71721: DISABLE
71722: LD_INT 0
71724: PPUSH
71725: PPUSH
// begin ToLua ( displayPowell(); ) ;
71726: LD_STRING displayPowell();
71728: PPUSH
71729: CALL_OW 559
// uc_side := 0 ;
71733: LD_ADDR_OWVAR 20
71737: PUSH
71738: LD_INT 0
71740: ST_TO_ADDR
// uc_nation := 2 ;
71741: LD_ADDR_OWVAR 21
71745: PUSH
71746: LD_INT 2
71748: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
71749: LD_ADDR_OWVAR 37
71753: PUSH
71754: LD_INT 14
71756: ST_TO_ADDR
// vc_engine := engine_siberite ;
71757: LD_ADDR_OWVAR 39
71761: PUSH
71762: LD_INT 3
71764: ST_TO_ADDR
// vc_control := control_apeman ;
71765: LD_ADDR_OWVAR 38
71769: PUSH
71770: LD_INT 5
71772: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
71773: LD_ADDR_OWVAR 40
71777: PUSH
71778: LD_INT 29
71780: ST_TO_ADDR
// un := CreateVehicle ;
71781: LD_ADDR_VAR 0 2
71785: PUSH
71786: CALL_OW 45
71790: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
71791: LD_VAR 0 2
71795: PPUSH
71796: LD_INT 1
71798: PPUSH
71799: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
71803: LD_INT 35
71805: PPUSH
71806: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
71810: LD_VAR 0 2
71814: PPUSH
71815: LD_INT 22
71817: PUSH
71818: LD_OWVAR 2
71822: PUSH
71823: EMPTY
71824: LIST
71825: LIST
71826: PPUSH
71827: CALL_OW 69
71831: PPUSH
71832: LD_VAR 0 2
71836: PPUSH
71837: CALL_OW 74
71841: PPUSH
71842: CALL_OW 115
// until IsDead ( un ) ;
71846: LD_VAR 0 2
71850: PPUSH
71851: CALL_OW 301
71855: IFFALSE 71803
// end ;
71857: PPOPN 2
71859: END
// every 0 0$1 trigger StreamModeActive and sStu do
71860: LD_EXP 99
71864: PUSH
71865: LD_EXP 138
71869: AND
71870: IFFALSE 71886
71872: GO 71874
71874: DISABLE
// begin ToLua ( displayStucuk(); ) ;
71875: LD_STRING displayStucuk();
71877: PPUSH
71878: CALL_OW 559
// ResetFog ;
71882: CALL_OW 335
// end ;
71886: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
71887: LD_EXP 99
71891: PUSH
71892: LD_EXP 131
71896: AND
71897: IFFALSE 72038
71899: GO 71901
71901: DISABLE
71902: LD_INT 0
71904: PPUSH
71905: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
71906: LD_ADDR_VAR 0 2
71910: PUSH
71911: LD_INT 22
71913: PUSH
71914: LD_OWVAR 2
71918: PUSH
71919: EMPTY
71920: LIST
71921: LIST
71922: PUSH
71923: LD_INT 21
71925: PUSH
71926: LD_INT 1
71928: PUSH
71929: EMPTY
71930: LIST
71931: LIST
71932: PUSH
71933: EMPTY
71934: LIST
71935: LIST
71936: PPUSH
71937: CALL_OW 69
71941: ST_TO_ADDR
// if not tmp then
71942: LD_VAR 0 2
71946: NOT
71947: IFFALSE 71951
// exit ;
71949: GO 72038
// un := tmp [ rand ( 1 , tmp ) ] ;
71951: LD_ADDR_VAR 0 1
71955: PUSH
71956: LD_VAR 0 2
71960: PUSH
71961: LD_INT 1
71963: PPUSH
71964: LD_VAR 0 2
71968: PPUSH
71969: CALL_OW 12
71973: ARRAY
71974: ST_TO_ADDR
// SetSide ( un , 0 ) ;
71975: LD_VAR 0 1
71979: PPUSH
71980: LD_INT 0
71982: PPUSH
71983: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
71987: LD_VAR 0 1
71991: PPUSH
71992: LD_OWVAR 3
71996: PUSH
71997: LD_VAR 0 1
72001: DIFF
72002: PPUSH
72003: LD_VAR 0 1
72007: PPUSH
72008: CALL_OW 74
72012: PPUSH
72013: CALL_OW 115
// wait ( 0 0$20 ) ;
72017: LD_INT 700
72019: PPUSH
72020: CALL_OW 67
// SetSide ( un , your_side ) ;
72024: LD_VAR 0 1
72028: PPUSH
72029: LD_OWVAR 2
72033: PPUSH
72034: CALL_OW 235
// end ;
72038: PPOPN 2
72040: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
72041: LD_EXP 99
72045: PUSH
72046: LD_EXP 132
72050: AND
72051: IFFALSE 72157
72053: GO 72055
72055: DISABLE
72056: LD_INT 0
72058: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
72059: LD_ADDR_VAR 0 1
72063: PUSH
72064: LD_INT 22
72066: PUSH
72067: LD_OWVAR 2
72071: PUSH
72072: EMPTY
72073: LIST
72074: LIST
72075: PUSH
72076: LD_INT 2
72078: PUSH
72079: LD_INT 30
72081: PUSH
72082: LD_INT 0
72084: PUSH
72085: EMPTY
72086: LIST
72087: LIST
72088: PUSH
72089: LD_INT 30
72091: PUSH
72092: LD_INT 1
72094: PUSH
72095: EMPTY
72096: LIST
72097: LIST
72098: PUSH
72099: EMPTY
72100: LIST
72101: LIST
72102: LIST
72103: PUSH
72104: EMPTY
72105: LIST
72106: LIST
72107: PPUSH
72108: CALL_OW 69
72112: ST_TO_ADDR
// if not depot then
72113: LD_VAR 0 1
72117: NOT
72118: IFFALSE 72122
// exit ;
72120: GO 72157
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
72122: LD_VAR 0 1
72126: PUSH
72127: LD_INT 1
72129: ARRAY
72130: PPUSH
72131: CALL_OW 250
72135: PPUSH
72136: LD_VAR 0 1
72140: PUSH
72141: LD_INT 1
72143: ARRAY
72144: PPUSH
72145: CALL_OW 251
72149: PPUSH
72150: LD_INT 70
72152: PPUSH
72153: CALL_OW 495
// end ;
72157: PPOPN 1
72159: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
72160: LD_EXP 99
72164: PUSH
72165: LD_EXP 133
72169: AND
72170: IFFALSE 72381
72172: GO 72174
72174: DISABLE
72175: LD_INT 0
72177: PPUSH
72178: PPUSH
72179: PPUSH
72180: PPUSH
72181: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
72182: LD_ADDR_VAR 0 5
72186: PUSH
72187: LD_INT 22
72189: PUSH
72190: LD_OWVAR 2
72194: PUSH
72195: EMPTY
72196: LIST
72197: LIST
72198: PUSH
72199: LD_INT 21
72201: PUSH
72202: LD_INT 1
72204: PUSH
72205: EMPTY
72206: LIST
72207: LIST
72208: PUSH
72209: EMPTY
72210: LIST
72211: LIST
72212: PPUSH
72213: CALL_OW 69
72217: ST_TO_ADDR
// if not tmp then
72218: LD_VAR 0 5
72222: NOT
72223: IFFALSE 72227
// exit ;
72225: GO 72381
// for i in tmp do
72227: LD_ADDR_VAR 0 1
72231: PUSH
72232: LD_VAR 0 5
72236: PUSH
72237: FOR_IN
72238: IFFALSE 72379
// begin d := rand ( 0 , 5 ) ;
72240: LD_ADDR_VAR 0 4
72244: PUSH
72245: LD_INT 0
72247: PPUSH
72248: LD_INT 5
72250: PPUSH
72251: CALL_OW 12
72255: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
72256: LD_ADDR_VAR 0 2
72260: PUSH
72261: LD_VAR 0 1
72265: PPUSH
72266: CALL_OW 250
72270: PPUSH
72271: LD_VAR 0 4
72275: PPUSH
72276: LD_INT 3
72278: PPUSH
72279: LD_INT 12
72281: PPUSH
72282: CALL_OW 12
72286: PPUSH
72287: CALL_OW 272
72291: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
72292: LD_ADDR_VAR 0 3
72296: PUSH
72297: LD_VAR 0 1
72301: PPUSH
72302: CALL_OW 251
72306: PPUSH
72307: LD_VAR 0 4
72311: PPUSH
72312: LD_INT 3
72314: PPUSH
72315: LD_INT 12
72317: PPUSH
72318: CALL_OW 12
72322: PPUSH
72323: CALL_OW 273
72327: ST_TO_ADDR
// if ValidHex ( x , y ) then
72328: LD_VAR 0 2
72332: PPUSH
72333: LD_VAR 0 3
72337: PPUSH
72338: CALL_OW 488
72342: IFFALSE 72377
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
72344: LD_VAR 0 1
72348: PPUSH
72349: LD_VAR 0 2
72353: PPUSH
72354: LD_VAR 0 3
72358: PPUSH
72359: LD_INT 3
72361: PPUSH
72362: LD_INT 6
72364: PPUSH
72365: CALL_OW 12
72369: PPUSH
72370: LD_INT 1
72372: PPUSH
72373: CALL_OW 483
// end ;
72377: GO 72237
72379: POP
72380: POP
// end ;
72381: PPOPN 5
72383: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
72384: LD_EXP 99
72388: PUSH
72389: LD_EXP 134
72393: AND
72394: IFFALSE 72488
72396: GO 72398
72398: DISABLE
72399: LD_INT 0
72401: PPUSH
72402: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
72403: LD_ADDR_VAR 0 2
72407: PUSH
72408: LD_INT 22
72410: PUSH
72411: LD_OWVAR 2
72415: PUSH
72416: EMPTY
72417: LIST
72418: LIST
72419: PUSH
72420: LD_INT 32
72422: PUSH
72423: LD_INT 1
72425: PUSH
72426: EMPTY
72427: LIST
72428: LIST
72429: PUSH
72430: LD_INT 21
72432: PUSH
72433: LD_INT 2
72435: PUSH
72436: EMPTY
72437: LIST
72438: LIST
72439: PUSH
72440: EMPTY
72441: LIST
72442: LIST
72443: LIST
72444: PPUSH
72445: CALL_OW 69
72449: ST_TO_ADDR
// if not tmp then
72450: LD_VAR 0 2
72454: NOT
72455: IFFALSE 72459
// exit ;
72457: GO 72488
// for i in tmp do
72459: LD_ADDR_VAR 0 1
72463: PUSH
72464: LD_VAR 0 2
72468: PUSH
72469: FOR_IN
72470: IFFALSE 72486
// SetFuel ( i , 0 ) ;
72472: LD_VAR 0 1
72476: PPUSH
72477: LD_INT 0
72479: PPUSH
72480: CALL_OW 240
72484: GO 72469
72486: POP
72487: POP
// end ;
72488: PPOPN 2
72490: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
72491: LD_EXP 99
72495: PUSH
72496: LD_EXP 135
72500: AND
72501: IFFALSE 72567
72503: GO 72505
72505: DISABLE
72506: LD_INT 0
72508: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
72509: LD_ADDR_VAR 0 1
72513: PUSH
72514: LD_INT 22
72516: PUSH
72517: LD_OWVAR 2
72521: PUSH
72522: EMPTY
72523: LIST
72524: LIST
72525: PUSH
72526: LD_INT 30
72528: PUSH
72529: LD_INT 29
72531: PUSH
72532: EMPTY
72533: LIST
72534: LIST
72535: PUSH
72536: EMPTY
72537: LIST
72538: LIST
72539: PPUSH
72540: CALL_OW 69
72544: ST_TO_ADDR
// if not tmp then
72545: LD_VAR 0 1
72549: NOT
72550: IFFALSE 72554
// exit ;
72552: GO 72567
// DestroyUnit ( tmp [ 1 ] ) ;
72554: LD_VAR 0 1
72558: PUSH
72559: LD_INT 1
72561: ARRAY
72562: PPUSH
72563: CALL_OW 65
// end ;
72567: PPOPN 1
72569: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
72570: LD_EXP 99
72574: PUSH
72575: LD_EXP 137
72579: AND
72580: IFFALSE 72709
72582: GO 72584
72584: DISABLE
72585: LD_INT 0
72587: PPUSH
// begin uc_side := 0 ;
72588: LD_ADDR_OWVAR 20
72592: PUSH
72593: LD_INT 0
72595: ST_TO_ADDR
// uc_nation := nation_arabian ;
72596: LD_ADDR_OWVAR 21
72600: PUSH
72601: LD_INT 2
72603: ST_TO_ADDR
// hc_gallery :=  ;
72604: LD_ADDR_OWVAR 33
72608: PUSH
72609: LD_STRING 
72611: ST_TO_ADDR
// hc_name :=  ;
72612: LD_ADDR_OWVAR 26
72616: PUSH
72617: LD_STRING 
72619: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
72620: LD_INT 1
72622: PPUSH
72623: LD_INT 11
72625: PPUSH
72626: LD_INT 10
72628: PPUSH
72629: CALL_OW 380
// un := CreateHuman ;
72633: LD_ADDR_VAR 0 1
72637: PUSH
72638: CALL_OW 44
72642: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
72643: LD_VAR 0 1
72647: PPUSH
72648: LD_INT 1
72650: PPUSH
72651: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
72655: LD_INT 35
72657: PPUSH
72658: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
72662: LD_VAR 0 1
72666: PPUSH
72667: LD_INT 22
72669: PUSH
72670: LD_OWVAR 2
72674: PUSH
72675: EMPTY
72676: LIST
72677: LIST
72678: PPUSH
72679: CALL_OW 69
72683: PPUSH
72684: LD_VAR 0 1
72688: PPUSH
72689: CALL_OW 74
72693: PPUSH
72694: CALL_OW 115
// until IsDead ( un ) ;
72698: LD_VAR 0 1
72702: PPUSH
72703: CALL_OW 301
72707: IFFALSE 72655
// end ;
72709: PPOPN 1
72711: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
72712: LD_EXP 99
72716: PUSH
72717: LD_EXP 139
72721: AND
72722: IFFALSE 72734
72724: GO 72726
72726: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
72727: LD_STRING earthquake(getX(game), 0, 32)
72729: PPUSH
72730: CALL_OW 559
72734: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
72735: LD_EXP 99
72739: PUSH
72740: LD_EXP 140
72744: AND
72745: IFFALSE 72836
72747: GO 72749
72749: DISABLE
72750: LD_INT 0
72752: PPUSH
// begin enable ;
72753: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
72754: LD_ADDR_VAR 0 1
72758: PUSH
72759: LD_INT 22
72761: PUSH
72762: LD_OWVAR 2
72766: PUSH
72767: EMPTY
72768: LIST
72769: LIST
72770: PUSH
72771: LD_INT 21
72773: PUSH
72774: LD_INT 2
72776: PUSH
72777: EMPTY
72778: LIST
72779: LIST
72780: PUSH
72781: LD_INT 33
72783: PUSH
72784: LD_INT 3
72786: PUSH
72787: EMPTY
72788: LIST
72789: LIST
72790: PUSH
72791: EMPTY
72792: LIST
72793: LIST
72794: LIST
72795: PPUSH
72796: CALL_OW 69
72800: ST_TO_ADDR
// if not tmp then
72801: LD_VAR 0 1
72805: NOT
72806: IFFALSE 72810
// exit ;
72808: GO 72836
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
72810: LD_VAR 0 1
72814: PUSH
72815: LD_INT 1
72817: PPUSH
72818: LD_VAR 0 1
72822: PPUSH
72823: CALL_OW 12
72827: ARRAY
72828: PPUSH
72829: LD_INT 1
72831: PPUSH
72832: CALL_OW 234
// end ;
72836: PPOPN 1
72838: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
72839: LD_EXP 99
72843: PUSH
72844: LD_EXP 141
72848: AND
72849: IFFALSE 72990
72851: GO 72853
72853: DISABLE
72854: LD_INT 0
72856: PPUSH
72857: PPUSH
72858: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
72859: LD_ADDR_VAR 0 3
72863: PUSH
72864: LD_INT 22
72866: PUSH
72867: LD_OWVAR 2
72871: PUSH
72872: EMPTY
72873: LIST
72874: LIST
72875: PUSH
72876: LD_INT 25
72878: PUSH
72879: LD_INT 1
72881: PUSH
72882: EMPTY
72883: LIST
72884: LIST
72885: PUSH
72886: EMPTY
72887: LIST
72888: LIST
72889: PPUSH
72890: CALL_OW 69
72894: ST_TO_ADDR
// if not tmp then
72895: LD_VAR 0 3
72899: NOT
72900: IFFALSE 72904
// exit ;
72902: GO 72990
// un := tmp [ rand ( 1 , tmp ) ] ;
72904: LD_ADDR_VAR 0 2
72908: PUSH
72909: LD_VAR 0 3
72913: PUSH
72914: LD_INT 1
72916: PPUSH
72917: LD_VAR 0 3
72921: PPUSH
72922: CALL_OW 12
72926: ARRAY
72927: ST_TO_ADDR
// if Crawls ( un ) then
72928: LD_VAR 0 2
72932: PPUSH
72933: CALL_OW 318
72937: IFFALSE 72948
// ComWalk ( un ) ;
72939: LD_VAR 0 2
72943: PPUSH
72944: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
72948: LD_VAR 0 2
72952: PPUSH
72953: LD_INT 9
72955: PPUSH
72956: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
72960: LD_INT 28
72962: PPUSH
72963: LD_OWVAR 2
72967: PPUSH
72968: LD_INT 2
72970: PPUSH
72971: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
72975: LD_INT 29
72977: PPUSH
72978: LD_OWVAR 2
72982: PPUSH
72983: LD_INT 2
72985: PPUSH
72986: CALL_OW 322
// end ;
72990: PPOPN 3
72992: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
72993: LD_EXP 99
72997: PUSH
72998: LD_EXP 142
73002: AND
73003: IFFALSE 73114
73005: GO 73007
73007: DISABLE
73008: LD_INT 0
73010: PPUSH
73011: PPUSH
73012: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
73013: LD_ADDR_VAR 0 3
73017: PUSH
73018: LD_INT 22
73020: PUSH
73021: LD_OWVAR 2
73025: PUSH
73026: EMPTY
73027: LIST
73028: LIST
73029: PUSH
73030: LD_INT 25
73032: PUSH
73033: LD_INT 1
73035: PUSH
73036: EMPTY
73037: LIST
73038: LIST
73039: PUSH
73040: EMPTY
73041: LIST
73042: LIST
73043: PPUSH
73044: CALL_OW 69
73048: ST_TO_ADDR
// if not tmp then
73049: LD_VAR 0 3
73053: NOT
73054: IFFALSE 73058
// exit ;
73056: GO 73114
// un := tmp [ rand ( 1 , tmp ) ] ;
73058: LD_ADDR_VAR 0 2
73062: PUSH
73063: LD_VAR 0 3
73067: PUSH
73068: LD_INT 1
73070: PPUSH
73071: LD_VAR 0 3
73075: PPUSH
73076: CALL_OW 12
73080: ARRAY
73081: ST_TO_ADDR
// if Crawls ( un ) then
73082: LD_VAR 0 2
73086: PPUSH
73087: CALL_OW 318
73091: IFFALSE 73102
// ComWalk ( un ) ;
73093: LD_VAR 0 2
73097: PPUSH
73098: CALL_OW 138
// SetClass ( un , class_mortar ) ;
73102: LD_VAR 0 2
73106: PPUSH
73107: LD_INT 8
73109: PPUSH
73110: CALL_OW 336
// end ;
73114: PPOPN 3
73116: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
73117: LD_EXP 99
73121: PUSH
73122: LD_EXP 143
73126: AND
73127: IFFALSE 73271
73129: GO 73131
73131: DISABLE
73132: LD_INT 0
73134: PPUSH
73135: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
73136: LD_ADDR_VAR 0 2
73140: PUSH
73141: LD_INT 22
73143: PUSH
73144: LD_OWVAR 2
73148: PUSH
73149: EMPTY
73150: LIST
73151: LIST
73152: PUSH
73153: LD_INT 21
73155: PUSH
73156: LD_INT 2
73158: PUSH
73159: EMPTY
73160: LIST
73161: LIST
73162: PUSH
73163: LD_INT 2
73165: PUSH
73166: LD_INT 34
73168: PUSH
73169: LD_INT 12
73171: PUSH
73172: EMPTY
73173: LIST
73174: LIST
73175: PUSH
73176: LD_INT 34
73178: PUSH
73179: LD_INT 51
73181: PUSH
73182: EMPTY
73183: LIST
73184: LIST
73185: PUSH
73186: LD_INT 34
73188: PUSH
73189: LD_INT 32
73191: PUSH
73192: EMPTY
73193: LIST
73194: LIST
73195: PUSH
73196: EMPTY
73197: LIST
73198: LIST
73199: LIST
73200: LIST
73201: PUSH
73202: EMPTY
73203: LIST
73204: LIST
73205: LIST
73206: PPUSH
73207: CALL_OW 69
73211: ST_TO_ADDR
// if not tmp then
73212: LD_VAR 0 2
73216: NOT
73217: IFFALSE 73221
// exit ;
73219: GO 73271
// for i in tmp do
73221: LD_ADDR_VAR 0 1
73225: PUSH
73226: LD_VAR 0 2
73230: PUSH
73231: FOR_IN
73232: IFFALSE 73269
// if GetCargo ( i , mat_artifact ) = 0 then
73234: LD_VAR 0 1
73238: PPUSH
73239: LD_INT 4
73241: PPUSH
73242: CALL_OW 289
73246: PUSH
73247: LD_INT 0
73249: EQUAL
73250: IFFALSE 73267
// SetCargo ( i , mat_siberit , 100 ) ;
73252: LD_VAR 0 1
73256: PPUSH
73257: LD_INT 3
73259: PPUSH
73260: LD_INT 100
73262: PPUSH
73263: CALL_OW 290
73267: GO 73231
73269: POP
73270: POP
// end ;
73271: PPOPN 2
73273: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
73274: LD_EXP 99
73278: PUSH
73279: LD_EXP 144
73283: AND
73284: IFFALSE 73467
73286: GO 73288
73288: DISABLE
73289: LD_INT 0
73291: PPUSH
73292: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
73293: LD_ADDR_VAR 0 2
73297: PUSH
73298: LD_INT 22
73300: PUSH
73301: LD_OWVAR 2
73305: PUSH
73306: EMPTY
73307: LIST
73308: LIST
73309: PPUSH
73310: CALL_OW 69
73314: ST_TO_ADDR
// if not tmp then
73315: LD_VAR 0 2
73319: NOT
73320: IFFALSE 73324
// exit ;
73322: GO 73467
// for i := 1 to 2 do
73324: LD_ADDR_VAR 0 1
73328: PUSH
73329: DOUBLE
73330: LD_INT 1
73332: DEC
73333: ST_TO_ADDR
73334: LD_INT 2
73336: PUSH
73337: FOR_TO
73338: IFFALSE 73465
// begin uc_side := your_side ;
73340: LD_ADDR_OWVAR 20
73344: PUSH
73345: LD_OWVAR 2
73349: ST_TO_ADDR
// uc_nation := nation_american ;
73350: LD_ADDR_OWVAR 21
73354: PUSH
73355: LD_INT 1
73357: ST_TO_ADDR
// vc_chassis := us_morphling ;
73358: LD_ADDR_OWVAR 37
73362: PUSH
73363: LD_INT 5
73365: ST_TO_ADDR
// vc_engine := engine_siberite ;
73366: LD_ADDR_OWVAR 39
73370: PUSH
73371: LD_INT 3
73373: ST_TO_ADDR
// vc_control := control_computer ;
73374: LD_ADDR_OWVAR 38
73378: PUSH
73379: LD_INT 3
73381: ST_TO_ADDR
// vc_weapon := us_double_laser ;
73382: LD_ADDR_OWVAR 40
73386: PUSH
73387: LD_INT 10
73389: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
73390: LD_VAR 0 2
73394: PUSH
73395: LD_INT 1
73397: ARRAY
73398: PPUSH
73399: CALL_OW 310
73403: NOT
73404: IFFALSE 73451
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
73406: CALL_OW 45
73410: PPUSH
73411: LD_VAR 0 2
73415: PUSH
73416: LD_INT 1
73418: ARRAY
73419: PPUSH
73420: CALL_OW 250
73424: PPUSH
73425: LD_VAR 0 2
73429: PUSH
73430: LD_INT 1
73432: ARRAY
73433: PPUSH
73434: CALL_OW 251
73438: PPUSH
73439: LD_INT 12
73441: PPUSH
73442: LD_INT 1
73444: PPUSH
73445: CALL_OW 50
73449: GO 73463
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
73451: CALL_OW 45
73455: PPUSH
73456: LD_INT 1
73458: PPUSH
73459: CALL_OW 51
// end ;
73463: GO 73337
73465: POP
73466: POP
// end ;
73467: PPOPN 2
73469: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
73470: LD_EXP 99
73474: PUSH
73475: LD_EXP 145
73479: AND
73480: IFFALSE 73702
73482: GO 73484
73484: DISABLE
73485: LD_INT 0
73487: PPUSH
73488: PPUSH
73489: PPUSH
73490: PPUSH
73491: PPUSH
73492: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
73493: LD_ADDR_VAR 0 6
73497: PUSH
73498: LD_INT 22
73500: PUSH
73501: LD_OWVAR 2
73505: PUSH
73506: EMPTY
73507: LIST
73508: LIST
73509: PUSH
73510: LD_INT 21
73512: PUSH
73513: LD_INT 1
73515: PUSH
73516: EMPTY
73517: LIST
73518: LIST
73519: PUSH
73520: LD_INT 3
73522: PUSH
73523: LD_INT 23
73525: PUSH
73526: LD_INT 0
73528: PUSH
73529: EMPTY
73530: LIST
73531: LIST
73532: PUSH
73533: EMPTY
73534: LIST
73535: LIST
73536: PUSH
73537: EMPTY
73538: LIST
73539: LIST
73540: LIST
73541: PPUSH
73542: CALL_OW 69
73546: ST_TO_ADDR
// if not tmp then
73547: LD_VAR 0 6
73551: NOT
73552: IFFALSE 73556
// exit ;
73554: GO 73702
// s1 := rand ( 1 , 4 ) ;
73556: LD_ADDR_VAR 0 2
73560: PUSH
73561: LD_INT 1
73563: PPUSH
73564: LD_INT 4
73566: PPUSH
73567: CALL_OW 12
73571: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
73572: LD_ADDR_VAR 0 4
73576: PUSH
73577: LD_VAR 0 6
73581: PUSH
73582: LD_INT 1
73584: ARRAY
73585: PPUSH
73586: LD_VAR 0 2
73590: PPUSH
73591: CALL_OW 259
73595: ST_TO_ADDR
// if s1 = 1 then
73596: LD_VAR 0 2
73600: PUSH
73601: LD_INT 1
73603: EQUAL
73604: IFFALSE 73624
// s2 := rand ( 2 , 4 ) else
73606: LD_ADDR_VAR 0 3
73610: PUSH
73611: LD_INT 2
73613: PPUSH
73614: LD_INT 4
73616: PPUSH
73617: CALL_OW 12
73621: ST_TO_ADDR
73622: GO 73632
// s2 := 1 ;
73624: LD_ADDR_VAR 0 3
73628: PUSH
73629: LD_INT 1
73631: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
73632: LD_ADDR_VAR 0 5
73636: PUSH
73637: LD_VAR 0 6
73641: PUSH
73642: LD_INT 1
73644: ARRAY
73645: PPUSH
73646: LD_VAR 0 3
73650: PPUSH
73651: CALL_OW 259
73655: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
73656: LD_VAR 0 6
73660: PUSH
73661: LD_INT 1
73663: ARRAY
73664: PPUSH
73665: LD_VAR 0 2
73669: PPUSH
73670: LD_VAR 0 5
73674: PPUSH
73675: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
73679: LD_VAR 0 6
73683: PUSH
73684: LD_INT 1
73686: ARRAY
73687: PPUSH
73688: LD_VAR 0 3
73692: PPUSH
73693: LD_VAR 0 4
73697: PPUSH
73698: CALL_OW 237
// end ;
73702: PPOPN 6
73704: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
73705: LD_EXP 99
73709: PUSH
73710: LD_EXP 146
73714: AND
73715: IFFALSE 73794
73717: GO 73719
73719: DISABLE
73720: LD_INT 0
73722: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
73723: LD_ADDR_VAR 0 1
73727: PUSH
73728: LD_INT 22
73730: PUSH
73731: LD_OWVAR 2
73735: PUSH
73736: EMPTY
73737: LIST
73738: LIST
73739: PUSH
73740: LD_INT 30
73742: PUSH
73743: LD_INT 3
73745: PUSH
73746: EMPTY
73747: LIST
73748: LIST
73749: PUSH
73750: EMPTY
73751: LIST
73752: LIST
73753: PPUSH
73754: CALL_OW 69
73758: ST_TO_ADDR
// if not tmp then
73759: LD_VAR 0 1
73763: NOT
73764: IFFALSE 73768
// exit ;
73766: GO 73794
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
73768: LD_VAR 0 1
73772: PUSH
73773: LD_INT 1
73775: PPUSH
73776: LD_VAR 0 1
73780: PPUSH
73781: CALL_OW 12
73785: ARRAY
73786: PPUSH
73787: LD_INT 1
73789: PPUSH
73790: CALL_OW 234
// end ;
73794: PPOPN 1
73796: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
73797: LD_EXP 99
73801: PUSH
73802: LD_EXP 147
73806: AND
73807: IFFALSE 73919
73809: GO 73811
73811: DISABLE
73812: LD_INT 0
73814: PPUSH
73815: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
73816: LD_ADDR_VAR 0 2
73820: PUSH
73821: LD_INT 22
73823: PUSH
73824: LD_OWVAR 2
73828: PUSH
73829: EMPTY
73830: LIST
73831: LIST
73832: PUSH
73833: LD_INT 2
73835: PUSH
73836: LD_INT 30
73838: PUSH
73839: LD_INT 27
73841: PUSH
73842: EMPTY
73843: LIST
73844: LIST
73845: PUSH
73846: LD_INT 30
73848: PUSH
73849: LD_INT 26
73851: PUSH
73852: EMPTY
73853: LIST
73854: LIST
73855: PUSH
73856: LD_INT 30
73858: PUSH
73859: LD_INT 28
73861: PUSH
73862: EMPTY
73863: LIST
73864: LIST
73865: PUSH
73866: EMPTY
73867: LIST
73868: LIST
73869: LIST
73870: LIST
73871: PUSH
73872: EMPTY
73873: LIST
73874: LIST
73875: PPUSH
73876: CALL_OW 69
73880: ST_TO_ADDR
// if not tmp then
73881: LD_VAR 0 2
73885: NOT
73886: IFFALSE 73890
// exit ;
73888: GO 73919
// for i in tmp do
73890: LD_ADDR_VAR 0 1
73894: PUSH
73895: LD_VAR 0 2
73899: PUSH
73900: FOR_IN
73901: IFFALSE 73917
// SetLives ( i , 1 ) ;
73903: LD_VAR 0 1
73907: PPUSH
73908: LD_INT 1
73910: PPUSH
73911: CALL_OW 234
73915: GO 73900
73917: POP
73918: POP
// end ;
73919: PPOPN 2
73921: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
73922: LD_EXP 99
73926: PUSH
73927: LD_EXP 148
73931: AND
73932: IFFALSE 74219
73934: GO 73936
73936: DISABLE
73937: LD_INT 0
73939: PPUSH
73940: PPUSH
73941: PPUSH
// begin i := rand ( 1 , 7 ) ;
73942: LD_ADDR_VAR 0 1
73946: PUSH
73947: LD_INT 1
73949: PPUSH
73950: LD_INT 7
73952: PPUSH
73953: CALL_OW 12
73957: ST_TO_ADDR
// case i of 1 :
73958: LD_VAR 0 1
73962: PUSH
73963: LD_INT 1
73965: DOUBLE
73966: EQUAL
73967: IFTRUE 73971
73969: GO 73981
73971: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
73972: LD_STRING earthquake(getX(game), 0, 32)
73974: PPUSH
73975: CALL_OW 559
73979: GO 74219
73981: LD_INT 2
73983: DOUBLE
73984: EQUAL
73985: IFTRUE 73989
73987: GO 74003
73989: POP
// begin ToLua ( displayStucuk(); ) ;
73990: LD_STRING displayStucuk();
73992: PPUSH
73993: CALL_OW 559
// ResetFog ;
73997: CALL_OW 335
// end ; 3 :
74001: GO 74219
74003: LD_INT 3
74005: DOUBLE
74006: EQUAL
74007: IFTRUE 74011
74009: GO 74115
74011: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
74012: LD_ADDR_VAR 0 2
74016: PUSH
74017: LD_INT 22
74019: PUSH
74020: LD_OWVAR 2
74024: PUSH
74025: EMPTY
74026: LIST
74027: LIST
74028: PUSH
74029: LD_INT 25
74031: PUSH
74032: LD_INT 1
74034: PUSH
74035: EMPTY
74036: LIST
74037: LIST
74038: PUSH
74039: EMPTY
74040: LIST
74041: LIST
74042: PPUSH
74043: CALL_OW 69
74047: ST_TO_ADDR
// if not tmp then
74048: LD_VAR 0 2
74052: NOT
74053: IFFALSE 74057
// exit ;
74055: GO 74219
// un := tmp [ rand ( 1 , tmp ) ] ;
74057: LD_ADDR_VAR 0 3
74061: PUSH
74062: LD_VAR 0 2
74066: PUSH
74067: LD_INT 1
74069: PPUSH
74070: LD_VAR 0 2
74074: PPUSH
74075: CALL_OW 12
74079: ARRAY
74080: ST_TO_ADDR
// if Crawls ( un ) then
74081: LD_VAR 0 3
74085: PPUSH
74086: CALL_OW 318
74090: IFFALSE 74101
// ComWalk ( un ) ;
74092: LD_VAR 0 3
74096: PPUSH
74097: CALL_OW 138
// SetClass ( un , class_mortar ) ;
74101: LD_VAR 0 3
74105: PPUSH
74106: LD_INT 8
74108: PPUSH
74109: CALL_OW 336
// end ; 4 :
74113: GO 74219
74115: LD_INT 4
74117: DOUBLE
74118: EQUAL
74119: IFTRUE 74123
74121: GO 74197
74123: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
74124: LD_ADDR_VAR 0 2
74128: PUSH
74129: LD_INT 22
74131: PUSH
74132: LD_OWVAR 2
74136: PUSH
74137: EMPTY
74138: LIST
74139: LIST
74140: PUSH
74141: LD_INT 30
74143: PUSH
74144: LD_INT 29
74146: PUSH
74147: EMPTY
74148: LIST
74149: LIST
74150: PUSH
74151: EMPTY
74152: LIST
74153: LIST
74154: PPUSH
74155: CALL_OW 69
74159: ST_TO_ADDR
// if not tmp then
74160: LD_VAR 0 2
74164: NOT
74165: IFFALSE 74169
// exit ;
74167: GO 74219
// CenterNowOnUnits ( tmp [ 1 ] ) ;
74169: LD_VAR 0 2
74173: PUSH
74174: LD_INT 1
74176: ARRAY
74177: PPUSH
74178: CALL_OW 87
// DestroyUnit ( tmp [ 1 ] ) ;
74182: LD_VAR 0 2
74186: PUSH
74187: LD_INT 1
74189: ARRAY
74190: PPUSH
74191: CALL_OW 65
// end ; 5 .. 7 :
74195: GO 74219
74197: LD_INT 5
74199: DOUBLE
74200: GREATEREQUAL
74201: IFFALSE 74209
74203: LD_INT 7
74205: DOUBLE
74206: LESSEQUAL
74207: IFTRUE 74211
74209: GO 74218
74211: POP
// StreamSibBomb ; end ;
74212: CALL 70456 0 0
74216: GO 74219
74218: POP
// end ;
74219: PPOPN 3
74221: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
74222: LD_EXP 99
74226: PUSH
74227: LD_EXP 149
74231: AND
74232: IFFALSE 74388
74234: GO 74236
74236: DISABLE
74237: LD_INT 0
74239: PPUSH
74240: PPUSH
74241: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
74242: LD_ADDR_VAR 0 2
74246: PUSH
74247: LD_INT 81
74249: PUSH
74250: LD_OWVAR 2
74254: PUSH
74255: EMPTY
74256: LIST
74257: LIST
74258: PUSH
74259: LD_INT 2
74261: PUSH
74262: LD_INT 21
74264: PUSH
74265: LD_INT 1
74267: PUSH
74268: EMPTY
74269: LIST
74270: LIST
74271: PUSH
74272: LD_INT 21
74274: PUSH
74275: LD_INT 2
74277: PUSH
74278: EMPTY
74279: LIST
74280: LIST
74281: PUSH
74282: EMPTY
74283: LIST
74284: LIST
74285: LIST
74286: PUSH
74287: EMPTY
74288: LIST
74289: LIST
74290: PPUSH
74291: CALL_OW 69
74295: ST_TO_ADDR
// if not tmp then
74296: LD_VAR 0 2
74300: NOT
74301: IFFALSE 74305
// exit ;
74303: GO 74388
// p := 0 ;
74305: LD_ADDR_VAR 0 3
74309: PUSH
74310: LD_INT 0
74312: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
74313: LD_INT 35
74315: PPUSH
74316: CALL_OW 67
// p := p + 1 ;
74320: LD_ADDR_VAR 0 3
74324: PUSH
74325: LD_VAR 0 3
74329: PUSH
74330: LD_INT 1
74332: PLUS
74333: ST_TO_ADDR
// for i in tmp do
74334: LD_ADDR_VAR 0 1
74338: PUSH
74339: LD_VAR 0 2
74343: PUSH
74344: FOR_IN
74345: IFFALSE 74376
// if GetLives ( i ) < 1000 then
74347: LD_VAR 0 1
74351: PPUSH
74352: CALL_OW 256
74356: PUSH
74357: LD_INT 1000
74359: LESS
74360: IFFALSE 74374
// SetLives ( i , 1000 ) ;
74362: LD_VAR 0 1
74366: PPUSH
74367: LD_INT 1000
74369: PPUSH
74370: CALL_OW 234
74374: GO 74344
74376: POP
74377: POP
// until p > 20 ;
74378: LD_VAR 0 3
74382: PUSH
74383: LD_INT 20
74385: GREATER
74386: IFFALSE 74313
// end ;
74388: PPOPN 3
74390: END
// every 0 0$1 trigger StreamModeActive and sTime do
74391: LD_EXP 99
74395: PUSH
74396: LD_EXP 150
74400: AND
74401: IFFALSE 74436
74403: GO 74405
74405: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
74406: LD_INT 28
74408: PPUSH
74409: LD_OWVAR 2
74413: PPUSH
74414: LD_INT 2
74416: PPUSH
74417: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
74421: LD_INT 30
74423: PPUSH
74424: LD_OWVAR 2
74428: PPUSH
74429: LD_INT 2
74431: PPUSH
74432: CALL_OW 322
// end ;
74436: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
74437: LD_EXP 99
74441: PUSH
74442: LD_EXP 151
74446: AND
74447: IFFALSE 74568
74449: GO 74451
74451: DISABLE
74452: LD_INT 0
74454: PPUSH
74455: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
74456: LD_ADDR_VAR 0 2
74460: PUSH
74461: LD_INT 22
74463: PUSH
74464: LD_OWVAR 2
74468: PUSH
74469: EMPTY
74470: LIST
74471: LIST
74472: PUSH
74473: LD_INT 21
74475: PUSH
74476: LD_INT 1
74478: PUSH
74479: EMPTY
74480: LIST
74481: LIST
74482: PUSH
74483: LD_INT 3
74485: PUSH
74486: LD_INT 23
74488: PUSH
74489: LD_INT 0
74491: PUSH
74492: EMPTY
74493: LIST
74494: LIST
74495: PUSH
74496: EMPTY
74497: LIST
74498: LIST
74499: PUSH
74500: EMPTY
74501: LIST
74502: LIST
74503: LIST
74504: PPUSH
74505: CALL_OW 69
74509: ST_TO_ADDR
// if not tmp then
74510: LD_VAR 0 2
74514: NOT
74515: IFFALSE 74519
// exit ;
74517: GO 74568
// for i in tmp do
74519: LD_ADDR_VAR 0 1
74523: PUSH
74524: LD_VAR 0 2
74528: PUSH
74529: FOR_IN
74530: IFFALSE 74566
// begin if Crawls ( i ) then
74532: LD_VAR 0 1
74536: PPUSH
74537: CALL_OW 318
74541: IFFALSE 74552
// ComWalk ( i ) ;
74543: LD_VAR 0 1
74547: PPUSH
74548: CALL_OW 138
// SetClass ( i , 2 ) ;
74552: LD_VAR 0 1
74556: PPUSH
74557: LD_INT 2
74559: PPUSH
74560: CALL_OW 336
// end ;
74564: GO 74529
74566: POP
74567: POP
// end ;
74568: PPOPN 2
74570: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
74571: LD_EXP 99
74575: PUSH
74576: LD_EXP 152
74580: AND
74581: IFFALSE 74869
74583: GO 74585
74585: DISABLE
74586: LD_INT 0
74588: PPUSH
74589: PPUSH
74590: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
74591: LD_OWVAR 2
74595: PPUSH
74596: LD_INT 9
74598: PPUSH
74599: LD_INT 1
74601: PPUSH
74602: LD_INT 1
74604: PPUSH
74605: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
74609: LD_INT 9
74611: PPUSH
74612: LD_OWVAR 2
74616: PPUSH
74617: CALL_OW 343
// uc_side := 9 ;
74621: LD_ADDR_OWVAR 20
74625: PUSH
74626: LD_INT 9
74628: ST_TO_ADDR
// uc_nation := 2 ;
74629: LD_ADDR_OWVAR 21
74633: PUSH
74634: LD_INT 2
74636: ST_TO_ADDR
// hc_name := Dark Warrior ;
74637: LD_ADDR_OWVAR 26
74641: PUSH
74642: LD_STRING Dark Warrior
74644: ST_TO_ADDR
// hc_gallery :=  ;
74645: LD_ADDR_OWVAR 33
74649: PUSH
74650: LD_STRING 
74652: ST_TO_ADDR
// hc_noskilllimit := true ;
74653: LD_ADDR_OWVAR 76
74657: PUSH
74658: LD_INT 1
74660: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
74661: LD_ADDR_OWVAR 31
74665: PUSH
74666: LD_INT 30
74668: PUSH
74669: LD_INT 30
74671: PUSH
74672: LD_INT 30
74674: PUSH
74675: LD_INT 30
74677: PUSH
74678: EMPTY
74679: LIST
74680: LIST
74681: LIST
74682: LIST
74683: ST_TO_ADDR
// un := CreateHuman ;
74684: LD_ADDR_VAR 0 3
74688: PUSH
74689: CALL_OW 44
74693: ST_TO_ADDR
// hc_noskilllimit := false ;
74694: LD_ADDR_OWVAR 76
74698: PUSH
74699: LD_INT 0
74701: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
74702: LD_VAR 0 3
74706: PPUSH
74707: LD_INT 1
74709: PPUSH
74710: CALL_OW 51
// ToLua ( playRanger() ) ;
74714: LD_STRING playRanger()
74716: PPUSH
74717: CALL_OW 559
// p := 0 ;
74721: LD_ADDR_VAR 0 2
74725: PUSH
74726: LD_INT 0
74728: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
74729: LD_INT 35
74731: PPUSH
74732: CALL_OW 67
// p := p + 1 ;
74736: LD_ADDR_VAR 0 2
74740: PUSH
74741: LD_VAR 0 2
74745: PUSH
74746: LD_INT 1
74748: PLUS
74749: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
74750: LD_VAR 0 3
74754: PPUSH
74755: CALL_OW 256
74759: PUSH
74760: LD_INT 1000
74762: LESS
74763: IFFALSE 74777
// SetLives ( un , 1000 ) ;
74765: LD_VAR 0 3
74769: PPUSH
74770: LD_INT 1000
74772: PPUSH
74773: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
74777: LD_VAR 0 3
74781: PPUSH
74782: LD_INT 81
74784: PUSH
74785: LD_OWVAR 2
74789: PUSH
74790: EMPTY
74791: LIST
74792: LIST
74793: PUSH
74794: LD_INT 91
74796: PUSH
74797: LD_VAR 0 3
74801: PUSH
74802: LD_INT 30
74804: PUSH
74805: EMPTY
74806: LIST
74807: LIST
74808: LIST
74809: PUSH
74810: EMPTY
74811: LIST
74812: LIST
74813: PPUSH
74814: CALL_OW 69
74818: PPUSH
74819: LD_VAR 0 3
74823: PPUSH
74824: CALL_OW 74
74828: PPUSH
74829: CALL_OW 115
// until p > 80 or IsDead ( un ) ;
74833: LD_VAR 0 2
74837: PUSH
74838: LD_INT 80
74840: GREATER
74841: PUSH
74842: LD_VAR 0 3
74846: PPUSH
74847: CALL_OW 301
74851: OR
74852: IFFALSE 74729
// if un then
74854: LD_VAR 0 3
74858: IFFALSE 74869
// RemoveUnit ( un ) ;
74860: LD_VAR 0 3
74864: PPUSH
74865: CALL_OW 64
// end ;
74869: PPOPN 3
74871: END
// every 0 0$1 trigger sComputer do var i , tmp , j ;
74872: LD_EXP 153
74876: IFFALSE 74992
74878: GO 74880
74880: DISABLE
74881: LD_INT 0
74883: PPUSH
74884: PPUSH
74885: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
74886: LD_ADDR_VAR 0 2
74890: PUSH
74891: LD_INT 81
74893: PUSH
74894: LD_OWVAR 2
74898: PUSH
74899: EMPTY
74900: LIST
74901: LIST
74902: PUSH
74903: LD_INT 21
74905: PUSH
74906: LD_INT 1
74908: PUSH
74909: EMPTY
74910: LIST
74911: LIST
74912: PUSH
74913: EMPTY
74914: LIST
74915: LIST
74916: PPUSH
74917: CALL_OW 69
74921: ST_TO_ADDR
// ToLua ( playComputer() ) ;
74922: LD_STRING playComputer()
74924: PPUSH
74925: CALL_OW 559
// if not tmp then
74929: LD_VAR 0 2
74933: NOT
74934: IFFALSE 74938
// exit ;
74936: GO 74992
// for i in tmp do
74938: LD_ADDR_VAR 0 1
74942: PUSH
74943: LD_VAR 0 2
74947: PUSH
74948: FOR_IN
74949: IFFALSE 74990
// for j := 1 to 4 do
74951: LD_ADDR_VAR 0 3
74955: PUSH
74956: DOUBLE
74957: LD_INT 1
74959: DEC
74960: ST_TO_ADDR
74961: LD_INT 4
74963: PUSH
74964: FOR_TO
74965: IFFALSE 74986
// SetSkill ( i , j , 10 ) ;
74967: LD_VAR 0 1
74971: PPUSH
74972: LD_VAR 0 3
74976: PPUSH
74977: LD_INT 10
74979: PPUSH
74980: CALL_OW 237
74984: GO 74964
74986: POP
74987: POP
74988: GO 74948
74990: POP
74991: POP
// end ;
74992: PPOPN 3
74994: END
// every 0 0$1 trigger s30 do var i , tmp ;
74995: LD_EXP 154
74999: IFFALSE 75068
75001: GO 75003
75003: DISABLE
75004: LD_INT 0
75006: PPUSH
75007: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
75008: LD_ADDR_VAR 0 2
75012: PUSH
75013: LD_INT 22
75015: PUSH
75016: LD_OWVAR 2
75020: PUSH
75021: EMPTY
75022: LIST
75023: LIST
75024: PPUSH
75025: CALL_OW 69
75029: ST_TO_ADDR
// if not tmp then
75030: LD_VAR 0 2
75034: NOT
75035: IFFALSE 75039
// exit ;
75037: GO 75068
// for i in tmp do
75039: LD_ADDR_VAR 0 1
75043: PUSH
75044: LD_VAR 0 2
75048: PUSH
75049: FOR_IN
75050: IFFALSE 75066
// SetLives ( i , 300 ) ;
75052: LD_VAR 0 1
75056: PPUSH
75057: LD_INT 300
75059: PPUSH
75060: CALL_OW 234
75064: GO 75049
75066: POP
75067: POP
// end ;
75068: PPOPN 2
75070: END
// every 0 0$1 trigger s60 do var i , tmp ;
75071: LD_EXP 155
75075: IFFALSE 75144
75077: GO 75079
75079: DISABLE
75080: LD_INT 0
75082: PPUSH
75083: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
75084: LD_ADDR_VAR 0 2
75088: PUSH
75089: LD_INT 22
75091: PUSH
75092: LD_OWVAR 2
75096: PUSH
75097: EMPTY
75098: LIST
75099: LIST
75100: PPUSH
75101: CALL_OW 69
75105: ST_TO_ADDR
// if not tmp then
75106: LD_VAR 0 2
75110: NOT
75111: IFFALSE 75115
// exit ;
75113: GO 75144
// for i in tmp do
75115: LD_ADDR_VAR 0 1
75119: PUSH
75120: LD_VAR 0 2
75124: PUSH
75125: FOR_IN
75126: IFFALSE 75142
// SetLives ( i , 600 ) ;
75128: LD_VAR 0 1
75132: PPUSH
75133: LD_INT 600
75135: PPUSH
75136: CALL_OW 234
75140: GO 75125
75142: POP
75143: POP
// end ;
75144: PPOPN 2
75146: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
75147: LD_INT 0
75149: PPUSH
// case cmd of 301 :
75150: LD_VAR 0 1
75154: PUSH
75155: LD_INT 301
75157: DOUBLE
75158: EQUAL
75159: IFTRUE 75163
75161: GO 75195
75163: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
75164: LD_VAR 0 6
75168: PPUSH
75169: LD_VAR 0 7
75173: PPUSH
75174: LD_VAR 0 8
75178: PPUSH
75179: LD_VAR 0 4
75183: PPUSH
75184: LD_VAR 0 5
75188: PPUSH
75189: CALL 76396 0 5
75193: GO 75316
75195: LD_INT 302
75197: DOUBLE
75198: EQUAL
75199: IFTRUE 75203
75201: GO 75240
75203: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
75204: LD_VAR 0 6
75208: PPUSH
75209: LD_VAR 0 7
75213: PPUSH
75214: LD_VAR 0 8
75218: PPUSH
75219: LD_VAR 0 9
75223: PPUSH
75224: LD_VAR 0 4
75228: PPUSH
75229: LD_VAR 0 5
75233: PPUSH
75234: CALL 76487 0 6
75238: GO 75316
75240: LD_INT 303
75242: DOUBLE
75243: EQUAL
75244: IFTRUE 75248
75246: GO 75285
75248: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
75249: LD_VAR 0 6
75253: PPUSH
75254: LD_VAR 0 7
75258: PPUSH
75259: LD_VAR 0 8
75263: PPUSH
75264: LD_VAR 0 9
75268: PPUSH
75269: LD_VAR 0 4
75273: PPUSH
75274: LD_VAR 0 5
75278: PPUSH
75279: CALL 75321 0 6
75283: GO 75316
75285: LD_INT 304
75287: DOUBLE
75288: EQUAL
75289: IFTRUE 75293
75291: GO 75315
75293: POP
// hHackTeleport ( unit , x , y ) ; end ;
75294: LD_VAR 0 2
75298: PPUSH
75299: LD_VAR 0 4
75303: PPUSH
75304: LD_VAR 0 5
75308: PPUSH
75309: CALL 77080 0 3
75313: GO 75316
75315: POP
// end ;
75316: LD_VAR 0 12
75320: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
75321: LD_INT 0
75323: PPUSH
75324: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
75325: LD_VAR 0 1
75329: PUSH
75330: LD_INT 1
75332: LESS
75333: PUSH
75334: LD_VAR 0 1
75338: PUSH
75339: LD_INT 3
75341: GREATER
75342: OR
75343: PUSH
75344: LD_VAR 0 5
75348: PPUSH
75349: LD_VAR 0 6
75353: PPUSH
75354: CALL_OW 428
75358: OR
75359: IFFALSE 75363
// exit ;
75361: GO 76083
// uc_side := your_side ;
75363: LD_ADDR_OWVAR 20
75367: PUSH
75368: LD_OWVAR 2
75372: ST_TO_ADDR
// uc_nation := nation ;
75373: LD_ADDR_OWVAR 21
75377: PUSH
75378: LD_VAR 0 1
75382: ST_TO_ADDR
// bc_level = 1 ;
75383: LD_ADDR_OWVAR 43
75387: PUSH
75388: LD_INT 1
75390: ST_TO_ADDR
// case btype of 1 :
75391: LD_VAR 0 2
75395: PUSH
75396: LD_INT 1
75398: DOUBLE
75399: EQUAL
75400: IFTRUE 75404
75402: GO 75415
75404: POP
// bc_type := b_depot ; 2 :
75405: LD_ADDR_OWVAR 42
75409: PUSH
75410: LD_INT 0
75412: ST_TO_ADDR
75413: GO 76027
75415: LD_INT 2
75417: DOUBLE
75418: EQUAL
75419: IFTRUE 75423
75421: GO 75434
75423: POP
// bc_type := b_warehouse ; 3 :
75424: LD_ADDR_OWVAR 42
75428: PUSH
75429: LD_INT 1
75431: ST_TO_ADDR
75432: GO 76027
75434: LD_INT 3
75436: DOUBLE
75437: EQUAL
75438: IFTRUE 75442
75440: GO 75453
75442: POP
// bc_type := b_lab ; 4 .. 9 :
75443: LD_ADDR_OWVAR 42
75447: PUSH
75448: LD_INT 6
75450: ST_TO_ADDR
75451: GO 76027
75453: LD_INT 4
75455: DOUBLE
75456: GREATEREQUAL
75457: IFFALSE 75465
75459: LD_INT 9
75461: DOUBLE
75462: LESSEQUAL
75463: IFTRUE 75467
75465: GO 75519
75467: POP
// begin bc_type := b_lab_half ;
75468: LD_ADDR_OWVAR 42
75472: PUSH
75473: LD_INT 7
75475: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
75476: LD_ADDR_OWVAR 44
75480: PUSH
75481: LD_INT 10
75483: PUSH
75484: LD_INT 11
75486: PUSH
75487: LD_INT 12
75489: PUSH
75490: LD_INT 15
75492: PUSH
75493: LD_INT 14
75495: PUSH
75496: LD_INT 13
75498: PUSH
75499: EMPTY
75500: LIST
75501: LIST
75502: LIST
75503: LIST
75504: LIST
75505: LIST
75506: PUSH
75507: LD_VAR 0 2
75511: PUSH
75512: LD_INT 3
75514: MINUS
75515: ARRAY
75516: ST_TO_ADDR
// end ; 10 .. 13 :
75517: GO 76027
75519: LD_INT 10
75521: DOUBLE
75522: GREATEREQUAL
75523: IFFALSE 75531
75525: LD_INT 13
75527: DOUBLE
75528: LESSEQUAL
75529: IFTRUE 75533
75531: GO 75610
75533: POP
// begin bc_type := b_lab_full ;
75534: LD_ADDR_OWVAR 42
75538: PUSH
75539: LD_INT 8
75541: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
75542: LD_ADDR_OWVAR 44
75546: PUSH
75547: LD_INT 10
75549: PUSH
75550: LD_INT 12
75552: PUSH
75553: LD_INT 14
75555: PUSH
75556: LD_INT 13
75558: PUSH
75559: EMPTY
75560: LIST
75561: LIST
75562: LIST
75563: LIST
75564: PUSH
75565: LD_VAR 0 2
75569: PUSH
75570: LD_INT 9
75572: MINUS
75573: ARRAY
75574: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
75575: LD_ADDR_OWVAR 45
75579: PUSH
75580: LD_INT 11
75582: PUSH
75583: LD_INT 15
75585: PUSH
75586: LD_INT 12
75588: PUSH
75589: LD_INT 15
75591: PUSH
75592: EMPTY
75593: LIST
75594: LIST
75595: LIST
75596: LIST
75597: PUSH
75598: LD_VAR 0 2
75602: PUSH
75603: LD_INT 9
75605: MINUS
75606: ARRAY
75607: ST_TO_ADDR
// end ; 14 :
75608: GO 76027
75610: LD_INT 14
75612: DOUBLE
75613: EQUAL
75614: IFTRUE 75618
75616: GO 75629
75618: POP
// bc_type := b_workshop ; 15 :
75619: LD_ADDR_OWVAR 42
75623: PUSH
75624: LD_INT 2
75626: ST_TO_ADDR
75627: GO 76027
75629: LD_INT 15
75631: DOUBLE
75632: EQUAL
75633: IFTRUE 75637
75635: GO 75648
75637: POP
// bc_type := b_factory ; 16 :
75638: LD_ADDR_OWVAR 42
75642: PUSH
75643: LD_INT 3
75645: ST_TO_ADDR
75646: GO 76027
75648: LD_INT 16
75650: DOUBLE
75651: EQUAL
75652: IFTRUE 75656
75654: GO 75667
75656: POP
// bc_type := b_ext_gun ; 17 :
75657: LD_ADDR_OWVAR 42
75661: PUSH
75662: LD_INT 17
75664: ST_TO_ADDR
75665: GO 76027
75667: LD_INT 17
75669: DOUBLE
75670: EQUAL
75671: IFTRUE 75675
75673: GO 75703
75675: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
75676: LD_ADDR_OWVAR 42
75680: PUSH
75681: LD_INT 19
75683: PUSH
75684: LD_INT 23
75686: PUSH
75687: LD_INT 19
75689: PUSH
75690: EMPTY
75691: LIST
75692: LIST
75693: LIST
75694: PUSH
75695: LD_VAR 0 1
75699: ARRAY
75700: ST_TO_ADDR
75701: GO 76027
75703: LD_INT 18
75705: DOUBLE
75706: EQUAL
75707: IFTRUE 75711
75709: GO 75722
75711: POP
// bc_type := b_ext_radar ; 19 :
75712: LD_ADDR_OWVAR 42
75716: PUSH
75717: LD_INT 20
75719: ST_TO_ADDR
75720: GO 76027
75722: LD_INT 19
75724: DOUBLE
75725: EQUAL
75726: IFTRUE 75730
75728: GO 75741
75730: POP
// bc_type := b_ext_radio ; 20 :
75731: LD_ADDR_OWVAR 42
75735: PUSH
75736: LD_INT 22
75738: ST_TO_ADDR
75739: GO 76027
75741: LD_INT 20
75743: DOUBLE
75744: EQUAL
75745: IFTRUE 75749
75747: GO 75760
75749: POP
// bc_type := b_ext_siberium ; 21 :
75750: LD_ADDR_OWVAR 42
75754: PUSH
75755: LD_INT 21
75757: ST_TO_ADDR
75758: GO 76027
75760: LD_INT 21
75762: DOUBLE
75763: EQUAL
75764: IFTRUE 75768
75766: GO 75779
75768: POP
// bc_type := b_ext_computer ; 22 :
75769: LD_ADDR_OWVAR 42
75773: PUSH
75774: LD_INT 24
75776: ST_TO_ADDR
75777: GO 76027
75779: LD_INT 22
75781: DOUBLE
75782: EQUAL
75783: IFTRUE 75787
75785: GO 75798
75787: POP
// bc_type := b_ext_track ; 23 :
75788: LD_ADDR_OWVAR 42
75792: PUSH
75793: LD_INT 16
75795: ST_TO_ADDR
75796: GO 76027
75798: LD_INT 23
75800: DOUBLE
75801: EQUAL
75802: IFTRUE 75806
75804: GO 75817
75806: POP
// bc_type := b_ext_laser ; 24 :
75807: LD_ADDR_OWVAR 42
75811: PUSH
75812: LD_INT 25
75814: ST_TO_ADDR
75815: GO 76027
75817: LD_INT 24
75819: DOUBLE
75820: EQUAL
75821: IFTRUE 75825
75823: GO 75836
75825: POP
// bc_type := b_control_tower ; 25 :
75826: LD_ADDR_OWVAR 42
75830: PUSH
75831: LD_INT 36
75833: ST_TO_ADDR
75834: GO 76027
75836: LD_INT 25
75838: DOUBLE
75839: EQUAL
75840: IFTRUE 75844
75842: GO 75855
75844: POP
// bc_type := b_breastwork ; 26 :
75845: LD_ADDR_OWVAR 42
75849: PUSH
75850: LD_INT 31
75852: ST_TO_ADDR
75853: GO 76027
75855: LD_INT 26
75857: DOUBLE
75858: EQUAL
75859: IFTRUE 75863
75861: GO 75874
75863: POP
// bc_type := b_bunker ; 27 :
75864: LD_ADDR_OWVAR 42
75868: PUSH
75869: LD_INT 32
75871: ST_TO_ADDR
75872: GO 76027
75874: LD_INT 27
75876: DOUBLE
75877: EQUAL
75878: IFTRUE 75882
75880: GO 75893
75882: POP
// bc_type := b_turret ; 28 :
75883: LD_ADDR_OWVAR 42
75887: PUSH
75888: LD_INT 33
75890: ST_TO_ADDR
75891: GO 76027
75893: LD_INT 28
75895: DOUBLE
75896: EQUAL
75897: IFTRUE 75901
75899: GO 75912
75901: POP
// bc_type := b_armoury ; 29 :
75902: LD_ADDR_OWVAR 42
75906: PUSH
75907: LD_INT 4
75909: ST_TO_ADDR
75910: GO 76027
75912: LD_INT 29
75914: DOUBLE
75915: EQUAL
75916: IFTRUE 75920
75918: GO 75931
75920: POP
// bc_type := b_barracks ; 30 :
75921: LD_ADDR_OWVAR 42
75925: PUSH
75926: LD_INT 5
75928: ST_TO_ADDR
75929: GO 76027
75931: LD_INT 30
75933: DOUBLE
75934: EQUAL
75935: IFTRUE 75939
75937: GO 75950
75939: POP
// bc_type := b_solar_power ; 31 :
75940: LD_ADDR_OWVAR 42
75944: PUSH
75945: LD_INT 27
75947: ST_TO_ADDR
75948: GO 76027
75950: LD_INT 31
75952: DOUBLE
75953: EQUAL
75954: IFTRUE 75958
75956: GO 75969
75958: POP
// bc_type := b_oil_power ; 32 :
75959: LD_ADDR_OWVAR 42
75963: PUSH
75964: LD_INT 26
75966: ST_TO_ADDR
75967: GO 76027
75969: LD_INT 32
75971: DOUBLE
75972: EQUAL
75973: IFTRUE 75977
75975: GO 75988
75977: POP
// bc_type := b_siberite_power ; 33 :
75978: LD_ADDR_OWVAR 42
75982: PUSH
75983: LD_INT 28
75985: ST_TO_ADDR
75986: GO 76027
75988: LD_INT 33
75990: DOUBLE
75991: EQUAL
75992: IFTRUE 75996
75994: GO 76007
75996: POP
// bc_type := b_oil_mine ; 34 :
75997: LD_ADDR_OWVAR 42
76001: PUSH
76002: LD_INT 29
76004: ST_TO_ADDR
76005: GO 76027
76007: LD_INT 34
76009: DOUBLE
76010: EQUAL
76011: IFTRUE 76015
76013: GO 76026
76015: POP
// bc_type := b_siberite_mine ; end ;
76016: LD_ADDR_OWVAR 42
76020: PUSH
76021: LD_INT 30
76023: ST_TO_ADDR
76024: GO 76027
76026: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
76027: LD_ADDR_VAR 0 8
76031: PUSH
76032: LD_VAR 0 5
76036: PPUSH
76037: LD_VAR 0 6
76041: PPUSH
76042: LD_VAR 0 3
76046: PPUSH
76047: CALL_OW 47
76051: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
76052: LD_OWVAR 42
76056: PUSH
76057: LD_INT 32
76059: PUSH
76060: LD_INT 33
76062: PUSH
76063: EMPTY
76064: LIST
76065: LIST
76066: IN
76067: IFFALSE 76083
// PlaceWeaponTurret ( b , weapon ) ;
76069: LD_VAR 0 8
76073: PPUSH
76074: LD_VAR 0 4
76078: PPUSH
76079: CALL_OW 431
// end ;
76083: LD_VAR 0 7
76087: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
76088: LD_INT 0
76090: PPUSH
76091: PPUSH
76092: PPUSH
76093: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
76094: LD_ADDR_VAR 0 4
76098: PUSH
76099: LD_INT 22
76101: PUSH
76102: LD_OWVAR 2
76106: PUSH
76107: EMPTY
76108: LIST
76109: LIST
76110: PUSH
76111: LD_INT 2
76113: PUSH
76114: LD_INT 30
76116: PUSH
76117: LD_INT 0
76119: PUSH
76120: EMPTY
76121: LIST
76122: LIST
76123: PUSH
76124: LD_INT 30
76126: PUSH
76127: LD_INT 1
76129: PUSH
76130: EMPTY
76131: LIST
76132: LIST
76133: PUSH
76134: EMPTY
76135: LIST
76136: LIST
76137: LIST
76138: PUSH
76139: EMPTY
76140: LIST
76141: LIST
76142: PPUSH
76143: CALL_OW 69
76147: ST_TO_ADDR
// if not tmp then
76148: LD_VAR 0 4
76152: NOT
76153: IFFALSE 76157
// exit ;
76155: GO 76216
// for i in tmp do
76157: LD_ADDR_VAR 0 2
76161: PUSH
76162: LD_VAR 0 4
76166: PUSH
76167: FOR_IN
76168: IFFALSE 76214
// for j = 1 to 3 do
76170: LD_ADDR_VAR 0 3
76174: PUSH
76175: DOUBLE
76176: LD_INT 1
76178: DEC
76179: ST_TO_ADDR
76180: LD_INT 3
76182: PUSH
76183: FOR_TO
76184: IFFALSE 76210
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
76186: LD_VAR 0 2
76190: PPUSH
76191: CALL_OW 274
76195: PPUSH
76196: LD_VAR 0 3
76200: PPUSH
76201: LD_INT 99999
76203: PPUSH
76204: CALL_OW 277
76208: GO 76183
76210: POP
76211: POP
76212: GO 76167
76214: POP
76215: POP
// end ;
76216: LD_VAR 0 1
76220: RET
// export function hHackSetLevel10 ; var i , j ; begin
76221: LD_INT 0
76223: PPUSH
76224: PPUSH
76225: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
76226: LD_ADDR_VAR 0 2
76230: PUSH
76231: LD_INT 21
76233: PUSH
76234: LD_INT 1
76236: PUSH
76237: EMPTY
76238: LIST
76239: LIST
76240: PPUSH
76241: CALL_OW 69
76245: PUSH
76246: FOR_IN
76247: IFFALSE 76299
// if IsSelected ( i ) then
76249: LD_VAR 0 2
76253: PPUSH
76254: CALL_OW 306
76258: IFFALSE 76297
// begin for j := 1 to 4 do
76260: LD_ADDR_VAR 0 3
76264: PUSH
76265: DOUBLE
76266: LD_INT 1
76268: DEC
76269: ST_TO_ADDR
76270: LD_INT 4
76272: PUSH
76273: FOR_TO
76274: IFFALSE 76295
// SetSkill ( i , j , 10 ) ;
76276: LD_VAR 0 2
76280: PPUSH
76281: LD_VAR 0 3
76285: PPUSH
76286: LD_INT 10
76288: PPUSH
76289: CALL_OW 237
76293: GO 76273
76295: POP
76296: POP
// end ;
76297: GO 76246
76299: POP
76300: POP
// end ;
76301: LD_VAR 0 1
76305: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
76306: LD_INT 0
76308: PPUSH
76309: PPUSH
76310: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
76311: LD_ADDR_VAR 0 2
76315: PUSH
76316: LD_INT 22
76318: PUSH
76319: LD_OWVAR 2
76323: PUSH
76324: EMPTY
76325: LIST
76326: LIST
76327: PUSH
76328: LD_INT 21
76330: PUSH
76331: LD_INT 1
76333: PUSH
76334: EMPTY
76335: LIST
76336: LIST
76337: PUSH
76338: EMPTY
76339: LIST
76340: LIST
76341: PPUSH
76342: CALL_OW 69
76346: PUSH
76347: FOR_IN
76348: IFFALSE 76389
// begin for j := 1 to 4 do
76350: LD_ADDR_VAR 0 3
76354: PUSH
76355: DOUBLE
76356: LD_INT 1
76358: DEC
76359: ST_TO_ADDR
76360: LD_INT 4
76362: PUSH
76363: FOR_TO
76364: IFFALSE 76385
// SetSkill ( i , j , 10 ) ;
76366: LD_VAR 0 2
76370: PPUSH
76371: LD_VAR 0 3
76375: PPUSH
76376: LD_INT 10
76378: PPUSH
76379: CALL_OW 237
76383: GO 76363
76385: POP
76386: POP
// end ;
76387: GO 76347
76389: POP
76390: POP
// end ;
76391: LD_VAR 0 1
76395: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
76396: LD_INT 0
76398: PPUSH
// uc_side := your_side ;
76399: LD_ADDR_OWVAR 20
76403: PUSH
76404: LD_OWVAR 2
76408: ST_TO_ADDR
// uc_nation := nation ;
76409: LD_ADDR_OWVAR 21
76413: PUSH
76414: LD_VAR 0 1
76418: ST_TO_ADDR
// InitHc ;
76419: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
76423: LD_INT 0
76425: PPUSH
76426: LD_VAR 0 2
76430: PPUSH
76431: LD_VAR 0 3
76435: PPUSH
76436: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
76440: LD_VAR 0 4
76444: PPUSH
76445: LD_VAR 0 5
76449: PPUSH
76450: CALL_OW 428
76454: PUSH
76455: LD_INT 0
76457: EQUAL
76458: IFFALSE 76482
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
76460: CALL_OW 44
76464: PPUSH
76465: LD_VAR 0 4
76469: PPUSH
76470: LD_VAR 0 5
76474: PPUSH
76475: LD_INT 1
76477: PPUSH
76478: CALL_OW 48
// end ;
76482: LD_VAR 0 6
76486: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
76487: LD_INT 0
76489: PPUSH
76490: PPUSH
// uc_side := your_side ;
76491: LD_ADDR_OWVAR 20
76495: PUSH
76496: LD_OWVAR 2
76500: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
76501: LD_VAR 0 1
76505: PUSH
76506: LD_INT 1
76508: PUSH
76509: LD_INT 2
76511: PUSH
76512: LD_INT 3
76514: PUSH
76515: LD_INT 4
76517: PUSH
76518: LD_INT 5
76520: PUSH
76521: EMPTY
76522: LIST
76523: LIST
76524: LIST
76525: LIST
76526: LIST
76527: IN
76528: IFFALSE 76540
// uc_nation := nation_american else
76530: LD_ADDR_OWVAR 21
76534: PUSH
76535: LD_INT 1
76537: ST_TO_ADDR
76538: GO 76583
// if chassis in [ 11 , 12 , 13 , 14 ] then
76540: LD_VAR 0 1
76544: PUSH
76545: LD_INT 11
76547: PUSH
76548: LD_INT 12
76550: PUSH
76551: LD_INT 13
76553: PUSH
76554: LD_INT 14
76556: PUSH
76557: EMPTY
76558: LIST
76559: LIST
76560: LIST
76561: LIST
76562: IN
76563: IFFALSE 76575
// uc_nation := nation_arabian else
76565: LD_ADDR_OWVAR 21
76569: PUSH
76570: LD_INT 2
76572: ST_TO_ADDR
76573: GO 76583
// uc_nation := nation_russian ;
76575: LD_ADDR_OWVAR 21
76579: PUSH
76580: LD_INT 3
76582: ST_TO_ADDR
// vc_chassis := chassis ;
76583: LD_ADDR_OWVAR 37
76587: PUSH
76588: LD_VAR 0 1
76592: ST_TO_ADDR
// vc_engine := engine ;
76593: LD_ADDR_OWVAR 39
76597: PUSH
76598: LD_VAR 0 2
76602: ST_TO_ADDR
// vc_control := control ;
76603: LD_ADDR_OWVAR 38
76607: PUSH
76608: LD_VAR 0 3
76612: ST_TO_ADDR
// vc_weapon := weapon ;
76613: LD_ADDR_OWVAR 40
76617: PUSH
76618: LD_VAR 0 4
76622: ST_TO_ADDR
// un := CreateVehicle ;
76623: LD_ADDR_VAR 0 8
76627: PUSH
76628: CALL_OW 45
76632: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
76633: LD_VAR 0 8
76637: PPUSH
76638: LD_INT 0
76640: PPUSH
76641: LD_INT 5
76643: PPUSH
76644: CALL_OW 12
76648: PPUSH
76649: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
76653: LD_VAR 0 8
76657: PPUSH
76658: LD_VAR 0 5
76662: PPUSH
76663: LD_VAR 0 6
76667: PPUSH
76668: LD_INT 1
76670: PPUSH
76671: CALL_OW 48
// end ;
76675: LD_VAR 0 7
76679: RET
// export hInvincible ; every 1 do
76680: GO 76682
76682: DISABLE
// hInvincible := [ ] ;
76683: LD_ADDR_EXP 156
76687: PUSH
76688: EMPTY
76689: ST_TO_ADDR
76690: END
// every 10 do var i ;
76691: GO 76693
76693: DISABLE
76694: LD_INT 0
76696: PPUSH
// begin enable ;
76697: ENABLE
// if not hInvincible then
76698: LD_EXP 156
76702: NOT
76703: IFFALSE 76707
// exit ;
76705: GO 76751
// for i in hInvincible do
76707: LD_ADDR_VAR 0 1
76711: PUSH
76712: LD_EXP 156
76716: PUSH
76717: FOR_IN
76718: IFFALSE 76749
// if GetLives ( i ) < 1000 then
76720: LD_VAR 0 1
76724: PPUSH
76725: CALL_OW 256
76729: PUSH
76730: LD_INT 1000
76732: LESS
76733: IFFALSE 76747
// SetLives ( i , 1000 ) ;
76735: LD_VAR 0 1
76739: PPUSH
76740: LD_INT 1000
76742: PPUSH
76743: CALL_OW 234
76747: GO 76717
76749: POP
76750: POP
// end ;
76751: PPOPN 1
76753: END
// export function hHackInvincible ; var i ; begin
76754: LD_INT 0
76756: PPUSH
76757: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
76758: LD_ADDR_VAR 0 2
76762: PUSH
76763: LD_INT 2
76765: PUSH
76766: LD_INT 21
76768: PUSH
76769: LD_INT 1
76771: PUSH
76772: EMPTY
76773: LIST
76774: LIST
76775: PUSH
76776: LD_INT 21
76778: PUSH
76779: LD_INT 2
76781: PUSH
76782: EMPTY
76783: LIST
76784: LIST
76785: PUSH
76786: EMPTY
76787: LIST
76788: LIST
76789: LIST
76790: PPUSH
76791: CALL_OW 69
76795: PUSH
76796: FOR_IN
76797: IFFALSE 76858
// if IsSelected ( i ) then
76799: LD_VAR 0 2
76803: PPUSH
76804: CALL_OW 306
76808: IFFALSE 76856
// begin if i in hInvincible then
76810: LD_VAR 0 2
76814: PUSH
76815: LD_EXP 156
76819: IN
76820: IFFALSE 76840
// hInvincible := hInvincible diff i else
76822: LD_ADDR_EXP 156
76826: PUSH
76827: LD_EXP 156
76831: PUSH
76832: LD_VAR 0 2
76836: DIFF
76837: ST_TO_ADDR
76838: GO 76856
// hInvincible := hInvincible union i ;
76840: LD_ADDR_EXP 156
76844: PUSH
76845: LD_EXP 156
76849: PUSH
76850: LD_VAR 0 2
76854: UNION
76855: ST_TO_ADDR
// end ;
76856: GO 76796
76858: POP
76859: POP
// end ;
76860: LD_VAR 0 1
76864: RET
// export function hHackInvisible ; var i , j ; begin
76865: LD_INT 0
76867: PPUSH
76868: PPUSH
76869: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
76870: LD_ADDR_VAR 0 2
76874: PUSH
76875: LD_INT 21
76877: PUSH
76878: LD_INT 1
76880: PUSH
76881: EMPTY
76882: LIST
76883: LIST
76884: PPUSH
76885: CALL_OW 69
76889: PUSH
76890: FOR_IN
76891: IFFALSE 76915
// if IsSelected ( i ) then
76893: LD_VAR 0 2
76897: PPUSH
76898: CALL_OW 306
76902: IFFALSE 76913
// ComForceInvisible ( i ) ;
76904: LD_VAR 0 2
76908: PPUSH
76909: CALL_OW 496
76913: GO 76890
76915: POP
76916: POP
// end ;
76917: LD_VAR 0 1
76921: RET
// export function hHackChangeYourSide ; begin
76922: LD_INT 0
76924: PPUSH
// if your_side = 8 then
76925: LD_OWVAR 2
76929: PUSH
76930: LD_INT 8
76932: EQUAL
76933: IFFALSE 76945
// your_side := 0 else
76935: LD_ADDR_OWVAR 2
76939: PUSH
76940: LD_INT 0
76942: ST_TO_ADDR
76943: GO 76959
// your_side := your_side + 1 ;
76945: LD_ADDR_OWVAR 2
76949: PUSH
76950: LD_OWVAR 2
76954: PUSH
76955: LD_INT 1
76957: PLUS
76958: ST_TO_ADDR
// end ;
76959: LD_VAR 0 1
76963: RET
// export function hHackChangeUnitSide ; var i , j ; begin
76964: LD_INT 0
76966: PPUSH
76967: PPUSH
76968: PPUSH
// for i in all_units do
76969: LD_ADDR_VAR 0 2
76973: PUSH
76974: LD_OWVAR 3
76978: PUSH
76979: FOR_IN
76980: IFFALSE 77058
// if IsSelected ( i ) then
76982: LD_VAR 0 2
76986: PPUSH
76987: CALL_OW 306
76991: IFFALSE 77056
// begin j := GetSide ( i ) ;
76993: LD_ADDR_VAR 0 3
76997: PUSH
76998: LD_VAR 0 2
77002: PPUSH
77003: CALL_OW 255
77007: ST_TO_ADDR
// if j = 8 then
77008: LD_VAR 0 3
77012: PUSH
77013: LD_INT 8
77015: EQUAL
77016: IFFALSE 77028
// j := 0 else
77018: LD_ADDR_VAR 0 3
77022: PUSH
77023: LD_INT 0
77025: ST_TO_ADDR
77026: GO 77042
// j := j + 1 ;
77028: LD_ADDR_VAR 0 3
77032: PUSH
77033: LD_VAR 0 3
77037: PUSH
77038: LD_INT 1
77040: PLUS
77041: ST_TO_ADDR
// SetSide ( i , j ) ;
77042: LD_VAR 0 2
77046: PPUSH
77047: LD_VAR 0 3
77051: PPUSH
77052: CALL_OW 235
// end ;
77056: GO 76979
77058: POP
77059: POP
// end ;
77060: LD_VAR 0 1
77064: RET
// export function hHackFog ; begin
77065: LD_INT 0
77067: PPUSH
// FogOff ( true ) ;
77068: LD_INT 1
77070: PPUSH
77071: CALL_OW 344
// end ;
77075: LD_VAR 0 1
77079: RET
// export function hHackTeleport ( unit , x , y ) ; begin
77080: LD_INT 0
77082: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
77083: LD_VAR 0 1
77087: PPUSH
77088: LD_VAR 0 2
77092: PPUSH
77093: LD_VAR 0 3
77097: PPUSH
77098: LD_INT 1
77100: PPUSH
77101: LD_INT 1
77103: PPUSH
77104: CALL_OW 483
// CenterOnXY ( x , y ) ;
77108: LD_VAR 0 2
77112: PPUSH
77113: LD_VAR 0 3
77117: PPUSH
77118: CALL_OW 84
// end ; end_of_file
77122: LD_VAR 0 4
77126: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb , ar_mortar , ar_crane , ar_miner ; export tech_Artillery , tech_RadMat , tech_BasicTools , tech_Cargo , tech_Track , tech_Crane , tech_Bulldozer , tech_Hovercraft , tech_MultiBarrels ; export class_mastodont , class_horse ; export function InitGlobalVariables ; begin
77127: LD_INT 0
77129: PPUSH
// ar_miner := 81 ;
77130: LD_ADDR_EXP 164
77134: PUSH
77135: LD_INT 81
77137: ST_TO_ADDR
// ar_crane := 88 ;
77138: LD_ADDR_EXP 163
77142: PUSH
77143: LD_INT 88
77145: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
77146: LD_ADDR_EXP 158
77150: PUSH
77151: LD_INT 89
77153: ST_TO_ADDR
// us_hack := 99 ;
77154: LD_ADDR_EXP 159
77158: PUSH
77159: LD_INT 99
77161: ST_TO_ADDR
// us_artillery := 97 ;
77162: LD_ADDR_EXP 160
77166: PUSH
77167: LD_INT 97
77169: ST_TO_ADDR
// ar_bio_bomb := 91 ;
77170: LD_ADDR_EXP 161
77174: PUSH
77175: LD_INT 91
77177: ST_TO_ADDR
// ar_mortar := 92 ;
77178: LD_ADDR_EXP 162
77182: PUSH
77183: LD_INT 92
77185: ST_TO_ADDR
// ru_radar := 98 ;
77186: LD_ADDR_EXP 157
77190: PUSH
77191: LD_INT 98
77193: ST_TO_ADDR
// tech_Artillery := 80 ;
77194: LD_ADDR_EXP 165
77198: PUSH
77199: LD_INT 80
77201: ST_TO_ADDR
// tech_RadMat := 81 ;
77202: LD_ADDR_EXP 166
77206: PUSH
77207: LD_INT 81
77209: ST_TO_ADDR
// tech_BasicTools := 82 ;
77210: LD_ADDR_EXP 167
77214: PUSH
77215: LD_INT 82
77217: ST_TO_ADDR
// tech_Cargo := 83 ;
77218: LD_ADDR_EXP 168
77222: PUSH
77223: LD_INT 83
77225: ST_TO_ADDR
// tech_Track := 84 ;
77226: LD_ADDR_EXP 169
77230: PUSH
77231: LD_INT 84
77233: ST_TO_ADDR
// tech_Crane := 85 ;
77234: LD_ADDR_EXP 170
77238: PUSH
77239: LD_INT 85
77241: ST_TO_ADDR
// tech_Bulldozer := 86 ;
77242: LD_ADDR_EXP 171
77246: PUSH
77247: LD_INT 86
77249: ST_TO_ADDR
// tech_Hovercraft := 87 ;
77250: LD_ADDR_EXP 172
77254: PUSH
77255: LD_INT 87
77257: ST_TO_ADDR
// tech_MultiBarrels := 88 ;
77258: LD_ADDR_EXP 173
77262: PUSH
77263: LD_INT 88
77265: ST_TO_ADDR
// class_mastodont := 31 ;
77266: LD_ADDR_EXP 174
77270: PUSH
77271: LD_INT 31
77273: ST_TO_ADDR
// class_horse := 21 ;
77274: LD_ADDR_EXP 175
77278: PUSH
77279: LD_INT 21
77281: ST_TO_ADDR
// end ;
77282: LD_VAR 0 1
77286: RET
// every 1 do
77287: GO 77289
77289: DISABLE
// InitGlobalVariables ; end_of_file
77290: CALL 77127 0 0
77294: END
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
77295: LD_VAR 0 1
77299: PUSH
77300: LD_INT 200
77302: DOUBLE
77303: GREATEREQUAL
77304: IFFALSE 77312
77306: LD_INT 299
77308: DOUBLE
77309: LESSEQUAL
77310: IFTRUE 77314
77312: GO 77346
77314: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
77315: LD_VAR 0 1
77319: PPUSH
77320: LD_VAR 0 2
77324: PPUSH
77325: LD_VAR 0 3
77329: PPUSH
77330: LD_VAR 0 4
77334: PPUSH
77335: LD_VAR 0 5
77339: PPUSH
77340: CALL 59437 0 5
77344: GO 77423
77346: LD_INT 300
77348: DOUBLE
77349: GREATEREQUAL
77350: IFFALSE 77358
77352: LD_INT 399
77354: DOUBLE
77355: LESSEQUAL
77356: IFTRUE 77360
77358: GO 77422
77360: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
77361: LD_VAR 0 1
77365: PPUSH
77366: LD_VAR 0 2
77370: PPUSH
77371: LD_VAR 0 3
77375: PPUSH
77376: LD_VAR 0 4
77380: PPUSH
77381: LD_VAR 0 5
77385: PPUSH
77386: LD_VAR 0 6
77390: PPUSH
77391: LD_VAR 0 7
77395: PPUSH
77396: LD_VAR 0 8
77400: PPUSH
77401: LD_VAR 0 9
77405: PPUSH
77406: LD_VAR 0 10
77410: PPUSH
77411: LD_VAR 0 11
77415: PPUSH
77416: CALL 75147 0 11
77420: GO 77423
77422: POP
// end ;
77423: PPOPN 11
77425: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
77426: LD_VAR 0 1
77430: PPUSH
77431: LD_VAR 0 2
77435: PPUSH
77436: LD_VAR 0 3
77440: PPUSH
77441: LD_VAR 0 4
77445: PPUSH
77446: LD_VAR 0 5
77450: PPUSH
77451: CALL 59429 0 5
// end ; end_of_file
77455: PPOPN 5
77457: END
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
77458: LD_INT 0
77460: PPUSH
77461: PPUSH
77462: PPUSH
77463: PPUSH
77464: PPUSH
77465: PPUSH
77466: PPUSH
77467: PPUSH
77468: PPUSH
77469: PPUSH
77470: PPUSH
77471: PPUSH
77472: PPUSH
77473: PPUSH
77474: PPUSH
77475: PPUSH
77476: PPUSH
77477: PPUSH
77478: PPUSH
77479: PPUSH
77480: PPUSH
77481: PPUSH
77482: PPUSH
77483: PPUSH
77484: PPUSH
77485: PPUSH
77486: PPUSH
77487: PPUSH
77488: PPUSH
77489: PPUSH
77490: PPUSH
77491: PPUSH
77492: PPUSH
77493: PPUSH
// if not list then
77494: LD_VAR 0 1
77498: NOT
77499: IFFALSE 77503
// exit ;
77501: GO 82162
// base := list [ 1 ] ;
77503: LD_ADDR_VAR 0 3
77507: PUSH
77508: LD_VAR 0 1
77512: PUSH
77513: LD_INT 1
77515: ARRAY
77516: ST_TO_ADDR
// group := list [ 2 ] ;
77517: LD_ADDR_VAR 0 4
77521: PUSH
77522: LD_VAR 0 1
77526: PUSH
77527: LD_INT 2
77529: ARRAY
77530: ST_TO_ADDR
// path := list [ 3 ] ;
77531: LD_ADDR_VAR 0 5
77535: PUSH
77536: LD_VAR 0 1
77540: PUSH
77541: LD_INT 3
77543: ARRAY
77544: ST_TO_ADDR
// flags := list [ 4 ] ;
77545: LD_ADDR_VAR 0 6
77549: PUSH
77550: LD_VAR 0 1
77554: PUSH
77555: LD_INT 4
77557: ARRAY
77558: ST_TO_ADDR
// mined := [ ] ;
77559: LD_ADDR_VAR 0 27
77563: PUSH
77564: EMPTY
77565: ST_TO_ADDR
// bombed := [ ] ;
77566: LD_ADDR_VAR 0 28
77570: PUSH
77571: EMPTY
77572: ST_TO_ADDR
// healers := [ ] ;
77573: LD_ADDR_VAR 0 31
77577: PUSH
77578: EMPTY
77579: ST_TO_ADDR
// to_heal := [ ] ;
77580: LD_ADDR_VAR 0 30
77584: PUSH
77585: EMPTY
77586: ST_TO_ADDR
// repairs := [ ] ;
77587: LD_ADDR_VAR 0 33
77591: PUSH
77592: EMPTY
77593: ST_TO_ADDR
// to_repair := [ ] ;
77594: LD_ADDR_VAR 0 32
77598: PUSH
77599: EMPTY
77600: ST_TO_ADDR
// if not group or not path then
77601: LD_VAR 0 4
77605: NOT
77606: PUSH
77607: LD_VAR 0 5
77611: NOT
77612: OR
77613: IFFALSE 77617
// exit ;
77615: GO 82162
// side := GetSide ( group [ 1 ] ) ;
77617: LD_ADDR_VAR 0 35
77621: PUSH
77622: LD_VAR 0 4
77626: PUSH
77627: LD_INT 1
77629: ARRAY
77630: PPUSH
77631: CALL_OW 255
77635: ST_TO_ADDR
// if flags then
77636: LD_VAR 0 6
77640: IFFALSE 77784
// begin f_ignore_area := flags [ 1 ] ;
77642: LD_ADDR_VAR 0 17
77646: PUSH
77647: LD_VAR 0 6
77651: PUSH
77652: LD_INT 1
77654: ARRAY
77655: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
77656: LD_ADDR_VAR 0 18
77660: PUSH
77661: LD_VAR 0 6
77665: PUSH
77666: LD_INT 2
77668: ARRAY
77669: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
77670: LD_ADDR_VAR 0 19
77674: PUSH
77675: LD_VAR 0 6
77679: PUSH
77680: LD_INT 3
77682: ARRAY
77683: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
77684: LD_ADDR_VAR 0 20
77688: PUSH
77689: LD_VAR 0 6
77693: PUSH
77694: LD_INT 4
77696: ARRAY
77697: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
77698: LD_ADDR_VAR 0 21
77702: PUSH
77703: LD_VAR 0 6
77707: PUSH
77708: LD_INT 5
77710: ARRAY
77711: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
77712: LD_ADDR_VAR 0 22
77716: PUSH
77717: LD_VAR 0 6
77721: PUSH
77722: LD_INT 6
77724: ARRAY
77725: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
77726: LD_ADDR_VAR 0 23
77730: PUSH
77731: LD_VAR 0 6
77735: PUSH
77736: LD_INT 7
77738: ARRAY
77739: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
77740: LD_ADDR_VAR 0 24
77744: PUSH
77745: LD_VAR 0 6
77749: PUSH
77750: LD_INT 8
77752: ARRAY
77753: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
77754: LD_ADDR_VAR 0 25
77758: PUSH
77759: LD_VAR 0 6
77763: PUSH
77764: LD_INT 9
77766: ARRAY
77767: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
77768: LD_ADDR_VAR 0 26
77772: PUSH
77773: LD_VAR 0 6
77777: PUSH
77778: LD_INT 10
77780: ARRAY
77781: ST_TO_ADDR
// end else
77782: GO 77864
// begin f_ignore_area := false ;
77784: LD_ADDR_VAR 0 17
77788: PUSH
77789: LD_INT 0
77791: ST_TO_ADDR
// f_capture := false ;
77792: LD_ADDR_VAR 0 18
77796: PUSH
77797: LD_INT 0
77799: ST_TO_ADDR
// f_ignore_civ := false ;
77800: LD_ADDR_VAR 0 19
77804: PUSH
77805: LD_INT 0
77807: ST_TO_ADDR
// f_murder := false ;
77808: LD_ADDR_VAR 0 20
77812: PUSH
77813: LD_INT 0
77815: ST_TO_ADDR
// f_mines := false ;
77816: LD_ADDR_VAR 0 21
77820: PUSH
77821: LD_INT 0
77823: ST_TO_ADDR
// f_repair := false ;
77824: LD_ADDR_VAR 0 22
77828: PUSH
77829: LD_INT 0
77831: ST_TO_ADDR
// f_heal := false ;
77832: LD_ADDR_VAR 0 23
77836: PUSH
77837: LD_INT 0
77839: ST_TO_ADDR
// f_spacetime := false ;
77840: LD_ADDR_VAR 0 24
77844: PUSH
77845: LD_INT 0
77847: ST_TO_ADDR
// f_attack_depot := false ;
77848: LD_ADDR_VAR 0 25
77852: PUSH
77853: LD_INT 0
77855: ST_TO_ADDR
// f_crawl := false ;
77856: LD_ADDR_VAR 0 26
77860: PUSH
77861: LD_INT 0
77863: ST_TO_ADDR
// end ; if f_heal then
77864: LD_VAR 0 23
77868: IFFALSE 77895
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
77870: LD_ADDR_VAR 0 31
77874: PUSH
77875: LD_VAR 0 4
77879: PPUSH
77880: LD_INT 25
77882: PUSH
77883: LD_INT 4
77885: PUSH
77886: EMPTY
77887: LIST
77888: LIST
77889: PPUSH
77890: CALL_OW 72
77894: ST_TO_ADDR
// if f_repair then
77895: LD_VAR 0 22
77899: IFFALSE 77926
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
77901: LD_ADDR_VAR 0 33
77905: PUSH
77906: LD_VAR 0 4
77910: PPUSH
77911: LD_INT 25
77913: PUSH
77914: LD_INT 3
77916: PUSH
77917: EMPTY
77918: LIST
77919: LIST
77920: PPUSH
77921: CALL_OW 72
77925: ST_TO_ADDR
// units_path := [ ] ;
77926: LD_ADDR_VAR 0 16
77930: PUSH
77931: EMPTY
77932: ST_TO_ADDR
// for i = 1 to group do
77933: LD_ADDR_VAR 0 7
77937: PUSH
77938: DOUBLE
77939: LD_INT 1
77941: DEC
77942: ST_TO_ADDR
77943: LD_VAR 0 4
77947: PUSH
77948: FOR_TO
77949: IFFALSE 77978
// units_path := Replace ( units_path , i , path ) ;
77951: LD_ADDR_VAR 0 16
77955: PUSH
77956: LD_VAR 0 16
77960: PPUSH
77961: LD_VAR 0 7
77965: PPUSH
77966: LD_VAR 0 5
77970: PPUSH
77971: CALL_OW 1
77975: ST_TO_ADDR
77976: GO 77948
77978: POP
77979: POP
// repeat for i = group downto 1 do
77980: LD_ADDR_VAR 0 7
77984: PUSH
77985: DOUBLE
77986: LD_VAR 0 4
77990: INC
77991: ST_TO_ADDR
77992: LD_INT 1
77994: PUSH
77995: FOR_DOWNTO
77996: IFFALSE 82118
// begin wait ( 5 ) ;
77998: LD_INT 5
78000: PPUSH
78001: CALL_OW 67
// tmp := [ ] ;
78005: LD_ADDR_VAR 0 14
78009: PUSH
78010: EMPTY
78011: ST_TO_ADDR
// attacking := false ;
78012: LD_ADDR_VAR 0 29
78016: PUSH
78017: LD_INT 0
78019: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
78020: LD_VAR 0 4
78024: PUSH
78025: LD_VAR 0 7
78029: ARRAY
78030: PPUSH
78031: CALL_OW 301
78035: PUSH
78036: LD_VAR 0 4
78040: PUSH
78041: LD_VAR 0 7
78045: ARRAY
78046: NOT
78047: OR
78048: IFFALSE 78157
// begin if GetType ( group [ i ] ) = unit_human then
78050: LD_VAR 0 4
78054: PUSH
78055: LD_VAR 0 7
78059: ARRAY
78060: PPUSH
78061: CALL_OW 247
78065: PUSH
78066: LD_INT 1
78068: EQUAL
78069: IFFALSE 78115
// begin to_heal := to_heal diff group [ i ] ;
78071: LD_ADDR_VAR 0 30
78075: PUSH
78076: LD_VAR 0 30
78080: PUSH
78081: LD_VAR 0 4
78085: PUSH
78086: LD_VAR 0 7
78090: ARRAY
78091: DIFF
78092: ST_TO_ADDR
// healers := healers diff group [ i ] ;
78093: LD_ADDR_VAR 0 31
78097: PUSH
78098: LD_VAR 0 31
78102: PUSH
78103: LD_VAR 0 4
78107: PUSH
78108: LD_VAR 0 7
78112: ARRAY
78113: DIFF
78114: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
78115: LD_ADDR_VAR 0 4
78119: PUSH
78120: LD_VAR 0 4
78124: PPUSH
78125: LD_VAR 0 7
78129: PPUSH
78130: CALL_OW 3
78134: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
78135: LD_ADDR_VAR 0 16
78139: PUSH
78140: LD_VAR 0 16
78144: PPUSH
78145: LD_VAR 0 7
78149: PPUSH
78150: CALL_OW 3
78154: ST_TO_ADDR
// continue ;
78155: GO 77995
// end ; if f_repair then
78157: LD_VAR 0 22
78161: IFFALSE 78650
// begin if GetType ( group [ i ] ) = unit_vehicle then
78163: LD_VAR 0 4
78167: PUSH
78168: LD_VAR 0 7
78172: ARRAY
78173: PPUSH
78174: CALL_OW 247
78178: PUSH
78179: LD_INT 2
78181: EQUAL
78182: IFFALSE 78372
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
78184: LD_VAR 0 4
78188: PUSH
78189: LD_VAR 0 7
78193: ARRAY
78194: PPUSH
78195: CALL_OW 256
78199: PUSH
78200: LD_INT 700
78202: LESS
78203: PUSH
78204: LD_VAR 0 4
78208: PUSH
78209: LD_VAR 0 7
78213: ARRAY
78214: PUSH
78215: LD_VAR 0 32
78219: IN
78220: NOT
78221: AND
78222: IFFALSE 78246
// to_repair := to_repair union group [ i ] ;
78224: LD_ADDR_VAR 0 32
78228: PUSH
78229: LD_VAR 0 32
78233: PUSH
78234: LD_VAR 0 4
78238: PUSH
78239: LD_VAR 0 7
78243: ARRAY
78244: UNION
78245: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
78246: LD_VAR 0 4
78250: PUSH
78251: LD_VAR 0 7
78255: ARRAY
78256: PPUSH
78257: CALL_OW 256
78261: PUSH
78262: LD_INT 1000
78264: EQUAL
78265: PUSH
78266: LD_VAR 0 4
78270: PUSH
78271: LD_VAR 0 7
78275: ARRAY
78276: PUSH
78277: LD_VAR 0 32
78281: IN
78282: AND
78283: IFFALSE 78307
// to_repair := to_repair diff group [ i ] ;
78285: LD_ADDR_VAR 0 32
78289: PUSH
78290: LD_VAR 0 32
78294: PUSH
78295: LD_VAR 0 4
78299: PUSH
78300: LD_VAR 0 7
78304: ARRAY
78305: DIFF
78306: ST_TO_ADDR
// if group [ i ] in to_repair then
78307: LD_VAR 0 4
78311: PUSH
78312: LD_VAR 0 7
78316: ARRAY
78317: PUSH
78318: LD_VAR 0 32
78322: IN
78323: IFFALSE 78370
// begin if not IsInArea ( group [ i ] , f_repair ) then
78325: LD_VAR 0 4
78329: PUSH
78330: LD_VAR 0 7
78334: ARRAY
78335: PPUSH
78336: LD_VAR 0 22
78340: PPUSH
78341: CALL_OW 308
78345: NOT
78346: IFFALSE 78368
// ComMoveToArea ( group [ i ] , f_repair ) ;
78348: LD_VAR 0 4
78352: PUSH
78353: LD_VAR 0 7
78357: ARRAY
78358: PPUSH
78359: LD_VAR 0 22
78363: PPUSH
78364: CALL_OW 113
// continue ;
78368: GO 77995
// end ; end else
78370: GO 78650
// if group [ i ] in repairs then
78372: LD_VAR 0 4
78376: PUSH
78377: LD_VAR 0 7
78381: ARRAY
78382: PUSH
78383: LD_VAR 0 33
78387: IN
78388: IFFALSE 78650
// begin if IsInUnit ( group [ i ] ) then
78390: LD_VAR 0 4
78394: PUSH
78395: LD_VAR 0 7
78399: ARRAY
78400: PPUSH
78401: CALL_OW 310
78405: IFFALSE 78473
// begin z := IsInUnit ( group [ i ] ) ;
78407: LD_ADDR_VAR 0 13
78411: PUSH
78412: LD_VAR 0 4
78416: PUSH
78417: LD_VAR 0 7
78421: ARRAY
78422: PPUSH
78423: CALL_OW 310
78427: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
78428: LD_VAR 0 13
78432: PUSH
78433: LD_VAR 0 32
78437: IN
78438: PUSH
78439: LD_VAR 0 13
78443: PPUSH
78444: LD_VAR 0 22
78448: PPUSH
78449: CALL_OW 308
78453: AND
78454: IFFALSE 78471
// ComExitVehicle ( group [ i ] ) ;
78456: LD_VAR 0 4
78460: PUSH
78461: LD_VAR 0 7
78465: ARRAY
78466: PPUSH
78467: CALL_OW 121
// end else
78471: GO 78650
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
78473: LD_ADDR_VAR 0 13
78477: PUSH
78478: LD_VAR 0 4
78482: PPUSH
78483: LD_INT 95
78485: PUSH
78486: LD_VAR 0 22
78490: PUSH
78491: EMPTY
78492: LIST
78493: LIST
78494: PUSH
78495: LD_INT 58
78497: PUSH
78498: EMPTY
78499: LIST
78500: PUSH
78501: EMPTY
78502: LIST
78503: LIST
78504: PPUSH
78505: CALL_OW 72
78509: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
78510: LD_VAR 0 4
78514: PUSH
78515: LD_VAR 0 7
78519: ARRAY
78520: PPUSH
78521: CALL_OW 314
78525: NOT
78526: IFFALSE 78648
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
78528: LD_ADDR_VAR 0 10
78532: PUSH
78533: LD_VAR 0 13
78537: PPUSH
78538: LD_VAR 0 4
78542: PUSH
78543: LD_VAR 0 7
78547: ARRAY
78548: PPUSH
78549: CALL_OW 74
78553: ST_TO_ADDR
// if not x then
78554: LD_VAR 0 10
78558: NOT
78559: IFFALSE 78563
// continue ;
78561: GO 77995
// if GetLives ( x ) < 1000 then
78563: LD_VAR 0 10
78567: PPUSH
78568: CALL_OW 256
78572: PUSH
78573: LD_INT 1000
78575: LESS
78576: IFFALSE 78600
// ComRepairVehicle ( group [ i ] , x ) else
78578: LD_VAR 0 4
78582: PUSH
78583: LD_VAR 0 7
78587: ARRAY
78588: PPUSH
78589: LD_VAR 0 10
78593: PPUSH
78594: CALL_OW 129
78598: GO 78648
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
78600: LD_VAR 0 23
78604: PUSH
78605: LD_VAR 0 4
78609: PUSH
78610: LD_VAR 0 7
78614: ARRAY
78615: PPUSH
78616: CALL_OW 256
78620: PUSH
78621: LD_INT 1000
78623: LESS
78624: AND
78625: NOT
78626: IFFALSE 78648
// ComEnterUnit ( group [ i ] , x ) ;
78628: LD_VAR 0 4
78632: PUSH
78633: LD_VAR 0 7
78637: ARRAY
78638: PPUSH
78639: LD_VAR 0 10
78643: PPUSH
78644: CALL_OW 120
// end ; continue ;
78648: GO 77995
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
78650: LD_VAR 0 23
78654: PUSH
78655: LD_VAR 0 4
78659: PUSH
78660: LD_VAR 0 7
78664: ARRAY
78665: PPUSH
78666: CALL_OW 247
78670: PUSH
78671: LD_INT 1
78673: EQUAL
78674: AND
78675: IFFALSE 79153
// begin if group [ i ] in healers then
78677: LD_VAR 0 4
78681: PUSH
78682: LD_VAR 0 7
78686: ARRAY
78687: PUSH
78688: LD_VAR 0 31
78692: IN
78693: IFFALSE 78966
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
78695: LD_VAR 0 4
78699: PUSH
78700: LD_VAR 0 7
78704: ARRAY
78705: PPUSH
78706: LD_VAR 0 23
78710: PPUSH
78711: CALL_OW 308
78715: NOT
78716: PUSH
78717: LD_VAR 0 4
78721: PUSH
78722: LD_VAR 0 7
78726: ARRAY
78727: PPUSH
78728: CALL_OW 314
78732: NOT
78733: AND
78734: IFFALSE 78758
// ComMoveToArea ( group [ i ] , f_heal ) else
78736: LD_VAR 0 4
78740: PUSH
78741: LD_VAR 0 7
78745: ARRAY
78746: PPUSH
78747: LD_VAR 0 23
78751: PPUSH
78752: CALL_OW 113
78756: GO 78964
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
78758: LD_VAR 0 4
78762: PUSH
78763: LD_VAR 0 7
78767: ARRAY
78768: PPUSH
78769: CALL 53290 0 1
78773: PPUSH
78774: CALL_OW 256
78778: PUSH
78779: LD_INT 1000
78781: EQUAL
78782: IFFALSE 78801
// ComStop ( group [ i ] ) else
78784: LD_VAR 0 4
78788: PUSH
78789: LD_VAR 0 7
78793: ARRAY
78794: PPUSH
78795: CALL_OW 141
78799: GO 78964
// if not HasTask ( group [ i ] ) and to_heal then
78801: LD_VAR 0 4
78805: PUSH
78806: LD_VAR 0 7
78810: ARRAY
78811: PPUSH
78812: CALL_OW 314
78816: NOT
78817: PUSH
78818: LD_VAR 0 30
78822: AND
78823: IFFALSE 78964
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
78825: LD_ADDR_VAR 0 13
78829: PUSH
78830: LD_VAR 0 30
78834: PPUSH
78835: LD_INT 3
78837: PUSH
78838: LD_INT 54
78840: PUSH
78841: EMPTY
78842: LIST
78843: PUSH
78844: EMPTY
78845: LIST
78846: LIST
78847: PPUSH
78848: CALL_OW 72
78852: PPUSH
78853: LD_VAR 0 4
78857: PUSH
78858: LD_VAR 0 7
78862: ARRAY
78863: PPUSH
78864: CALL_OW 74
78868: ST_TO_ADDR
// if z then
78869: LD_VAR 0 13
78873: IFFALSE 78964
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
78875: LD_INT 91
78877: PUSH
78878: LD_VAR 0 13
78882: PUSH
78883: LD_INT 10
78885: PUSH
78886: EMPTY
78887: LIST
78888: LIST
78889: LIST
78890: PUSH
78891: LD_INT 81
78893: PUSH
78894: LD_VAR 0 13
78898: PPUSH
78899: CALL_OW 255
78903: PUSH
78904: EMPTY
78905: LIST
78906: LIST
78907: PUSH
78908: EMPTY
78909: LIST
78910: LIST
78911: PPUSH
78912: CALL_OW 69
78916: PUSH
78917: LD_INT 0
78919: EQUAL
78920: IFFALSE 78944
// ComHeal ( group [ i ] , z ) else
78922: LD_VAR 0 4
78926: PUSH
78927: LD_VAR 0 7
78931: ARRAY
78932: PPUSH
78933: LD_VAR 0 13
78937: PPUSH
78938: CALL_OW 128
78942: GO 78964
// ComMoveToArea ( group [ i ] , f_heal ) ;
78944: LD_VAR 0 4
78948: PUSH
78949: LD_VAR 0 7
78953: ARRAY
78954: PPUSH
78955: LD_VAR 0 23
78959: PPUSH
78960: CALL_OW 113
// end ; continue ;
78964: GO 77995
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
78966: LD_VAR 0 4
78970: PUSH
78971: LD_VAR 0 7
78975: ARRAY
78976: PPUSH
78977: CALL_OW 256
78981: PUSH
78982: LD_INT 700
78984: LESS
78985: PUSH
78986: LD_VAR 0 4
78990: PUSH
78991: LD_VAR 0 7
78995: ARRAY
78996: PUSH
78997: LD_VAR 0 30
79001: IN
79002: NOT
79003: AND
79004: IFFALSE 79028
// to_heal := to_heal union group [ i ] ;
79006: LD_ADDR_VAR 0 30
79010: PUSH
79011: LD_VAR 0 30
79015: PUSH
79016: LD_VAR 0 4
79020: PUSH
79021: LD_VAR 0 7
79025: ARRAY
79026: UNION
79027: ST_TO_ADDR
// if group [ i ] in to_heal then
79028: LD_VAR 0 4
79032: PUSH
79033: LD_VAR 0 7
79037: ARRAY
79038: PUSH
79039: LD_VAR 0 30
79043: IN
79044: IFFALSE 79153
// begin if GetLives ( group [ i ] ) = 1000 then
79046: LD_VAR 0 4
79050: PUSH
79051: LD_VAR 0 7
79055: ARRAY
79056: PPUSH
79057: CALL_OW 256
79061: PUSH
79062: LD_INT 1000
79064: EQUAL
79065: IFFALSE 79091
// to_heal := to_heal diff group [ i ] else
79067: LD_ADDR_VAR 0 30
79071: PUSH
79072: LD_VAR 0 30
79076: PUSH
79077: LD_VAR 0 4
79081: PUSH
79082: LD_VAR 0 7
79086: ARRAY
79087: DIFF
79088: ST_TO_ADDR
79089: GO 79153
// begin if not IsInArea ( group [ i ] , to_heal ) then
79091: LD_VAR 0 4
79095: PUSH
79096: LD_VAR 0 7
79100: ARRAY
79101: PPUSH
79102: LD_VAR 0 30
79106: PPUSH
79107: CALL_OW 308
79111: NOT
79112: IFFALSE 79136
// ComMoveToArea ( group [ i ] , f_heal ) else
79114: LD_VAR 0 4
79118: PUSH
79119: LD_VAR 0 7
79123: ARRAY
79124: PPUSH
79125: LD_VAR 0 23
79129: PPUSH
79130: CALL_OW 113
79134: GO 79151
// ComHold ( group [ i ] ) ;
79136: LD_VAR 0 4
79140: PUSH
79141: LD_VAR 0 7
79145: ARRAY
79146: PPUSH
79147: CALL_OW 140
// continue ;
79151: GO 77995
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
79153: LD_VAR 0 4
79157: PUSH
79158: LD_VAR 0 7
79162: ARRAY
79163: PPUSH
79164: LD_INT 10
79166: PPUSH
79167: CALL 51710 0 2
79171: NOT
79172: PUSH
79173: LD_VAR 0 16
79177: PUSH
79178: LD_VAR 0 7
79182: ARRAY
79183: PUSH
79184: EMPTY
79185: EQUAL
79186: NOT
79187: AND
79188: IFFALSE 79454
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
79190: LD_VAR 0 4
79194: PUSH
79195: LD_VAR 0 7
79199: ARRAY
79200: PPUSH
79201: CALL_OW 262
79205: PUSH
79206: LD_INT 1
79208: PUSH
79209: LD_INT 2
79211: PUSH
79212: EMPTY
79213: LIST
79214: LIST
79215: IN
79216: IFFALSE 79257
// if GetFuel ( group [ i ] ) < 10 then
79218: LD_VAR 0 4
79222: PUSH
79223: LD_VAR 0 7
79227: ARRAY
79228: PPUSH
79229: CALL_OW 261
79233: PUSH
79234: LD_INT 10
79236: LESS
79237: IFFALSE 79257
// SetFuel ( group [ i ] , 12 ) ;
79239: LD_VAR 0 4
79243: PUSH
79244: LD_VAR 0 7
79248: ARRAY
79249: PPUSH
79250: LD_INT 12
79252: PPUSH
79253: CALL_OW 240
// if units_path [ i ] then
79257: LD_VAR 0 16
79261: PUSH
79262: LD_VAR 0 7
79266: ARRAY
79267: IFFALSE 79452
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
79269: LD_VAR 0 4
79273: PUSH
79274: LD_VAR 0 7
79278: ARRAY
79279: PPUSH
79280: LD_VAR 0 16
79284: PUSH
79285: LD_VAR 0 7
79289: ARRAY
79290: PUSH
79291: LD_INT 1
79293: ARRAY
79294: PUSH
79295: LD_INT 1
79297: ARRAY
79298: PPUSH
79299: LD_VAR 0 16
79303: PUSH
79304: LD_VAR 0 7
79308: ARRAY
79309: PUSH
79310: LD_INT 1
79312: ARRAY
79313: PUSH
79314: LD_INT 2
79316: ARRAY
79317: PPUSH
79318: CALL_OW 297
79322: PUSH
79323: LD_INT 6
79325: GREATER
79326: IFFALSE 79401
// begin if not HasTask ( group [ i ] ) then
79328: LD_VAR 0 4
79332: PUSH
79333: LD_VAR 0 7
79337: ARRAY
79338: PPUSH
79339: CALL_OW 314
79343: NOT
79344: IFFALSE 79399
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
79346: LD_VAR 0 4
79350: PUSH
79351: LD_VAR 0 7
79355: ARRAY
79356: PPUSH
79357: LD_VAR 0 16
79361: PUSH
79362: LD_VAR 0 7
79366: ARRAY
79367: PUSH
79368: LD_INT 1
79370: ARRAY
79371: PUSH
79372: LD_INT 1
79374: ARRAY
79375: PPUSH
79376: LD_VAR 0 16
79380: PUSH
79381: LD_VAR 0 7
79385: ARRAY
79386: PUSH
79387: LD_INT 1
79389: ARRAY
79390: PUSH
79391: LD_INT 2
79393: ARRAY
79394: PPUSH
79395: CALL_OW 114
// end else
79399: GO 79452
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
79401: LD_ADDR_VAR 0 15
79405: PUSH
79406: LD_VAR 0 16
79410: PUSH
79411: LD_VAR 0 7
79415: ARRAY
79416: PPUSH
79417: LD_INT 1
79419: PPUSH
79420: CALL_OW 3
79424: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
79425: LD_ADDR_VAR 0 16
79429: PUSH
79430: LD_VAR 0 16
79434: PPUSH
79435: LD_VAR 0 7
79439: PPUSH
79440: LD_VAR 0 15
79444: PPUSH
79445: CALL_OW 1
79449: ST_TO_ADDR
// continue ;
79450: GO 77995
// end ; end ; end else
79452: GO 82116
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
79454: LD_ADDR_VAR 0 14
79458: PUSH
79459: LD_INT 81
79461: PUSH
79462: LD_VAR 0 4
79466: PUSH
79467: LD_VAR 0 7
79471: ARRAY
79472: PPUSH
79473: CALL_OW 255
79477: PUSH
79478: EMPTY
79479: LIST
79480: LIST
79481: PPUSH
79482: CALL_OW 69
79486: ST_TO_ADDR
// if not tmp then
79487: LD_VAR 0 14
79491: NOT
79492: IFFALSE 79496
// continue ;
79494: GO 77995
// if f_ignore_area then
79496: LD_VAR 0 17
79500: IFFALSE 79588
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
79502: LD_ADDR_VAR 0 15
79506: PUSH
79507: LD_VAR 0 14
79511: PPUSH
79512: LD_INT 3
79514: PUSH
79515: LD_INT 92
79517: PUSH
79518: LD_VAR 0 17
79522: PUSH
79523: LD_INT 1
79525: ARRAY
79526: PUSH
79527: LD_VAR 0 17
79531: PUSH
79532: LD_INT 2
79534: ARRAY
79535: PUSH
79536: LD_VAR 0 17
79540: PUSH
79541: LD_INT 3
79543: ARRAY
79544: PUSH
79545: EMPTY
79546: LIST
79547: LIST
79548: LIST
79549: LIST
79550: PUSH
79551: EMPTY
79552: LIST
79553: LIST
79554: PPUSH
79555: CALL_OW 72
79559: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
79560: LD_VAR 0 14
79564: PUSH
79565: LD_VAR 0 15
79569: DIFF
79570: IFFALSE 79588
// tmp := tmp diff tmp2 ;
79572: LD_ADDR_VAR 0 14
79576: PUSH
79577: LD_VAR 0 14
79581: PUSH
79582: LD_VAR 0 15
79586: DIFF
79587: ST_TO_ADDR
// end ; if not f_murder then
79588: LD_VAR 0 20
79592: NOT
79593: IFFALSE 79651
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
79595: LD_ADDR_VAR 0 15
79599: PUSH
79600: LD_VAR 0 14
79604: PPUSH
79605: LD_INT 3
79607: PUSH
79608: LD_INT 50
79610: PUSH
79611: EMPTY
79612: LIST
79613: PUSH
79614: EMPTY
79615: LIST
79616: LIST
79617: PPUSH
79618: CALL_OW 72
79622: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
79623: LD_VAR 0 14
79627: PUSH
79628: LD_VAR 0 15
79632: DIFF
79633: IFFALSE 79651
// tmp := tmp diff tmp2 ;
79635: LD_ADDR_VAR 0 14
79639: PUSH
79640: LD_VAR 0 14
79644: PUSH
79645: LD_VAR 0 15
79649: DIFF
79650: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
79651: LD_ADDR_VAR 0 14
79655: PUSH
79656: LD_VAR 0 4
79660: PUSH
79661: LD_VAR 0 7
79665: ARRAY
79666: PPUSH
79667: LD_VAR 0 14
79671: PPUSH
79672: LD_INT 1
79674: PPUSH
79675: LD_INT 1
79677: PPUSH
79678: CALL 24645 0 4
79682: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
79683: LD_VAR 0 4
79687: PUSH
79688: LD_VAR 0 7
79692: ARRAY
79693: PPUSH
79694: CALL_OW 257
79698: PUSH
79699: LD_INT 1
79701: EQUAL
79702: IFFALSE 80150
// begin if WantPlant ( group [ i ] ) then
79704: LD_VAR 0 4
79708: PUSH
79709: LD_VAR 0 7
79713: ARRAY
79714: PPUSH
79715: CALL 24146 0 1
79719: IFFALSE 79723
// continue ;
79721: GO 77995
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
79723: LD_VAR 0 18
79727: PUSH
79728: LD_VAR 0 4
79732: PUSH
79733: LD_VAR 0 7
79737: ARRAY
79738: PPUSH
79739: CALL_OW 310
79743: NOT
79744: AND
79745: PUSH
79746: LD_VAR 0 14
79750: PUSH
79751: LD_INT 1
79753: ARRAY
79754: PUSH
79755: LD_VAR 0 14
79759: PPUSH
79760: LD_INT 21
79762: PUSH
79763: LD_INT 2
79765: PUSH
79766: EMPTY
79767: LIST
79768: LIST
79769: PUSH
79770: LD_INT 58
79772: PUSH
79773: EMPTY
79774: LIST
79775: PUSH
79776: EMPTY
79777: LIST
79778: LIST
79779: PPUSH
79780: CALL_OW 72
79784: IN
79785: AND
79786: IFFALSE 79822
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
79788: LD_VAR 0 4
79792: PUSH
79793: LD_VAR 0 7
79797: ARRAY
79798: PPUSH
79799: LD_VAR 0 14
79803: PUSH
79804: LD_INT 1
79806: ARRAY
79807: PPUSH
79808: CALL_OW 120
// attacking := true ;
79812: LD_ADDR_VAR 0 29
79816: PUSH
79817: LD_INT 1
79819: ST_TO_ADDR
// continue ;
79820: GO 77995
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
79822: LD_VAR 0 26
79826: PUSH
79827: LD_VAR 0 4
79831: PUSH
79832: LD_VAR 0 7
79836: ARRAY
79837: PPUSH
79838: CALL_OW 257
79842: PUSH
79843: LD_INT 1
79845: EQUAL
79846: AND
79847: PUSH
79848: LD_VAR 0 4
79852: PUSH
79853: LD_VAR 0 7
79857: ARRAY
79858: PPUSH
79859: CALL_OW 256
79863: PUSH
79864: LD_INT 800
79866: LESS
79867: AND
79868: PUSH
79869: LD_VAR 0 4
79873: PUSH
79874: LD_VAR 0 7
79878: ARRAY
79879: PPUSH
79880: CALL_OW 318
79884: NOT
79885: AND
79886: IFFALSE 79903
// ComCrawl ( group [ i ] ) ;
79888: LD_VAR 0 4
79892: PUSH
79893: LD_VAR 0 7
79897: ARRAY
79898: PPUSH
79899: CALL_OW 137
// if f_mines then
79903: LD_VAR 0 21
79907: IFFALSE 80150
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
79909: LD_VAR 0 14
79913: PUSH
79914: LD_INT 1
79916: ARRAY
79917: PPUSH
79918: CALL_OW 247
79922: PUSH
79923: LD_INT 3
79925: EQUAL
79926: PUSH
79927: LD_VAR 0 14
79931: PUSH
79932: LD_INT 1
79934: ARRAY
79935: PUSH
79936: LD_VAR 0 27
79940: IN
79941: NOT
79942: AND
79943: IFFALSE 80150
// begin x := GetX ( tmp [ 1 ] ) ;
79945: LD_ADDR_VAR 0 10
79949: PUSH
79950: LD_VAR 0 14
79954: PUSH
79955: LD_INT 1
79957: ARRAY
79958: PPUSH
79959: CALL_OW 250
79963: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
79964: LD_ADDR_VAR 0 11
79968: PUSH
79969: LD_VAR 0 14
79973: PUSH
79974: LD_INT 1
79976: ARRAY
79977: PPUSH
79978: CALL_OW 251
79982: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
79983: LD_ADDR_VAR 0 12
79987: PUSH
79988: LD_VAR 0 4
79992: PUSH
79993: LD_VAR 0 7
79997: ARRAY
79998: PPUSH
79999: CALL 51795 0 1
80003: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
80004: LD_VAR 0 4
80008: PUSH
80009: LD_VAR 0 7
80013: ARRAY
80014: PPUSH
80015: LD_VAR 0 10
80019: PPUSH
80020: LD_VAR 0 11
80024: PPUSH
80025: LD_VAR 0 14
80029: PUSH
80030: LD_INT 1
80032: ARRAY
80033: PPUSH
80034: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
80038: LD_VAR 0 4
80042: PUSH
80043: LD_VAR 0 7
80047: ARRAY
80048: PPUSH
80049: LD_VAR 0 10
80053: PPUSH
80054: LD_VAR 0 12
80058: PPUSH
80059: LD_INT 7
80061: PPUSH
80062: CALL_OW 272
80066: PPUSH
80067: LD_VAR 0 11
80071: PPUSH
80072: LD_VAR 0 12
80076: PPUSH
80077: LD_INT 7
80079: PPUSH
80080: CALL_OW 273
80084: PPUSH
80085: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
80089: LD_VAR 0 4
80093: PUSH
80094: LD_VAR 0 7
80098: ARRAY
80099: PPUSH
80100: LD_INT 71
80102: PPUSH
80103: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
80107: LD_ADDR_VAR 0 27
80111: PUSH
80112: LD_VAR 0 27
80116: PPUSH
80117: LD_VAR 0 27
80121: PUSH
80122: LD_INT 1
80124: PLUS
80125: PPUSH
80126: LD_VAR 0 14
80130: PUSH
80131: LD_INT 1
80133: ARRAY
80134: PPUSH
80135: CALL_OW 1
80139: ST_TO_ADDR
// attacking := true ;
80140: LD_ADDR_VAR 0 29
80144: PUSH
80145: LD_INT 1
80147: ST_TO_ADDR
// continue ;
80148: GO 77995
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
80150: LD_VAR 0 4
80154: PUSH
80155: LD_VAR 0 7
80159: ARRAY
80160: PPUSH
80161: CALL_OW 257
80165: PUSH
80166: LD_INT 17
80168: EQUAL
80169: PUSH
80170: LD_VAR 0 4
80174: PUSH
80175: LD_VAR 0 7
80179: ARRAY
80180: PPUSH
80181: CALL_OW 110
80185: PUSH
80186: LD_INT 71
80188: EQUAL
80189: NOT
80190: AND
80191: IFFALSE 80337
// begin attacking := false ;
80193: LD_ADDR_VAR 0 29
80197: PUSH
80198: LD_INT 0
80200: ST_TO_ADDR
// k := 5 ;
80201: LD_ADDR_VAR 0 9
80205: PUSH
80206: LD_INT 5
80208: ST_TO_ADDR
// if tmp < k then
80209: LD_VAR 0 14
80213: PUSH
80214: LD_VAR 0 9
80218: LESS
80219: IFFALSE 80231
// k := tmp ;
80221: LD_ADDR_VAR 0 9
80225: PUSH
80226: LD_VAR 0 14
80230: ST_TO_ADDR
// for j = 1 to k do
80231: LD_ADDR_VAR 0 8
80235: PUSH
80236: DOUBLE
80237: LD_INT 1
80239: DEC
80240: ST_TO_ADDR
80241: LD_VAR 0 9
80245: PUSH
80246: FOR_TO
80247: IFFALSE 80335
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
80249: LD_VAR 0 14
80253: PUSH
80254: LD_VAR 0 8
80258: ARRAY
80259: PUSH
80260: LD_VAR 0 14
80264: PPUSH
80265: LD_INT 58
80267: PUSH
80268: EMPTY
80269: LIST
80270: PPUSH
80271: CALL_OW 72
80275: IN
80276: NOT
80277: IFFALSE 80333
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
80279: LD_VAR 0 4
80283: PUSH
80284: LD_VAR 0 7
80288: ARRAY
80289: PPUSH
80290: LD_VAR 0 14
80294: PUSH
80295: LD_VAR 0 8
80299: ARRAY
80300: PPUSH
80301: CALL_OW 115
// attacking := true ;
80305: LD_ADDR_VAR 0 29
80309: PUSH
80310: LD_INT 1
80312: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
80313: LD_VAR 0 4
80317: PUSH
80318: LD_VAR 0 7
80322: ARRAY
80323: PPUSH
80324: LD_INT 71
80326: PPUSH
80327: CALL_OW 109
// continue ;
80331: GO 80246
// end ; end ;
80333: GO 80246
80335: POP
80336: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
80337: LD_VAR 0 4
80341: PUSH
80342: LD_VAR 0 7
80346: ARRAY
80347: PPUSH
80348: CALL_OW 257
80352: PUSH
80353: LD_INT 8
80355: EQUAL
80356: PUSH
80357: LD_VAR 0 4
80361: PUSH
80362: LD_VAR 0 7
80366: ARRAY
80367: PPUSH
80368: CALL_OW 264
80372: PUSH
80373: LD_INT 28
80375: PUSH
80376: LD_INT 45
80378: PUSH
80379: LD_INT 7
80381: PUSH
80382: LD_INT 47
80384: PUSH
80385: EMPTY
80386: LIST
80387: LIST
80388: LIST
80389: LIST
80390: IN
80391: OR
80392: IFFALSE 80648
// begin attacking := false ;
80394: LD_ADDR_VAR 0 29
80398: PUSH
80399: LD_INT 0
80401: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
80402: LD_VAR 0 14
80406: PUSH
80407: LD_INT 1
80409: ARRAY
80410: PPUSH
80411: CALL_OW 266
80415: PUSH
80416: LD_INT 32
80418: PUSH
80419: LD_INT 31
80421: PUSH
80422: LD_INT 33
80424: PUSH
80425: LD_INT 4
80427: PUSH
80428: LD_INT 5
80430: PUSH
80431: EMPTY
80432: LIST
80433: LIST
80434: LIST
80435: LIST
80436: LIST
80437: IN
80438: IFFALSE 80624
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
80440: LD_ADDR_VAR 0 9
80444: PUSH
80445: LD_VAR 0 14
80449: PUSH
80450: LD_INT 1
80452: ARRAY
80453: PPUSH
80454: CALL_OW 266
80458: PPUSH
80459: LD_VAR 0 14
80463: PUSH
80464: LD_INT 1
80466: ARRAY
80467: PPUSH
80468: CALL_OW 250
80472: PPUSH
80473: LD_VAR 0 14
80477: PUSH
80478: LD_INT 1
80480: ARRAY
80481: PPUSH
80482: CALL_OW 251
80486: PPUSH
80487: LD_VAR 0 14
80491: PUSH
80492: LD_INT 1
80494: ARRAY
80495: PPUSH
80496: CALL_OW 254
80500: PPUSH
80501: LD_VAR 0 14
80505: PUSH
80506: LD_INT 1
80508: ARRAY
80509: PPUSH
80510: CALL_OW 248
80514: PPUSH
80515: LD_INT 0
80517: PPUSH
80518: CALL 33165 0 6
80522: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
80523: LD_ADDR_VAR 0 8
80527: PUSH
80528: LD_VAR 0 4
80532: PUSH
80533: LD_VAR 0 7
80537: ARRAY
80538: PPUSH
80539: LD_VAR 0 9
80543: PPUSH
80544: CALL 51835 0 2
80548: ST_TO_ADDR
// if j then
80549: LD_VAR 0 8
80553: IFFALSE 80622
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
80555: LD_VAR 0 8
80559: PUSH
80560: LD_INT 1
80562: ARRAY
80563: PPUSH
80564: LD_VAR 0 8
80568: PUSH
80569: LD_INT 2
80571: ARRAY
80572: PPUSH
80573: CALL_OW 488
80577: IFFALSE 80622
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
80579: LD_VAR 0 4
80583: PUSH
80584: LD_VAR 0 7
80588: ARRAY
80589: PPUSH
80590: LD_VAR 0 8
80594: PUSH
80595: LD_INT 1
80597: ARRAY
80598: PPUSH
80599: LD_VAR 0 8
80603: PUSH
80604: LD_INT 2
80606: ARRAY
80607: PPUSH
80608: CALL_OW 116
// attacking := true ;
80612: LD_ADDR_VAR 0 29
80616: PUSH
80617: LD_INT 1
80619: ST_TO_ADDR
// continue ;
80620: GO 77995
// end ; end else
80622: GO 80648
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
80624: LD_VAR 0 4
80628: PUSH
80629: LD_VAR 0 7
80633: ARRAY
80634: PPUSH
80635: LD_VAR 0 14
80639: PUSH
80640: LD_INT 1
80642: ARRAY
80643: PPUSH
80644: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
80648: LD_VAR 0 4
80652: PUSH
80653: LD_VAR 0 7
80657: ARRAY
80658: PPUSH
80659: CALL_OW 265
80663: PUSH
80664: LD_INT 11
80666: EQUAL
80667: IFFALSE 80945
// begin k := 10 ;
80669: LD_ADDR_VAR 0 9
80673: PUSH
80674: LD_INT 10
80676: ST_TO_ADDR
// x := 0 ;
80677: LD_ADDR_VAR 0 10
80681: PUSH
80682: LD_INT 0
80684: ST_TO_ADDR
// if tmp < k then
80685: LD_VAR 0 14
80689: PUSH
80690: LD_VAR 0 9
80694: LESS
80695: IFFALSE 80707
// k := tmp ;
80697: LD_ADDR_VAR 0 9
80701: PUSH
80702: LD_VAR 0 14
80706: ST_TO_ADDR
// for j = k downto 1 do
80707: LD_ADDR_VAR 0 8
80711: PUSH
80712: DOUBLE
80713: LD_VAR 0 9
80717: INC
80718: ST_TO_ADDR
80719: LD_INT 1
80721: PUSH
80722: FOR_DOWNTO
80723: IFFALSE 80798
// begin if GetType ( tmp [ j ] ) = unit_human then
80725: LD_VAR 0 14
80729: PUSH
80730: LD_VAR 0 8
80734: ARRAY
80735: PPUSH
80736: CALL_OW 247
80740: PUSH
80741: LD_INT 1
80743: EQUAL
80744: IFFALSE 80796
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
80746: LD_VAR 0 4
80750: PUSH
80751: LD_VAR 0 7
80755: ARRAY
80756: PPUSH
80757: LD_VAR 0 14
80761: PUSH
80762: LD_VAR 0 8
80766: ARRAY
80767: PPUSH
80768: CALL 52106 0 2
// x := tmp [ j ] ;
80772: LD_ADDR_VAR 0 10
80776: PUSH
80777: LD_VAR 0 14
80781: PUSH
80782: LD_VAR 0 8
80786: ARRAY
80787: ST_TO_ADDR
// attacking := true ;
80788: LD_ADDR_VAR 0 29
80792: PUSH
80793: LD_INT 1
80795: ST_TO_ADDR
// end ; end ;
80796: GO 80722
80798: POP
80799: POP
// if not x then
80800: LD_VAR 0 10
80804: NOT
80805: IFFALSE 80945
// begin attacking := true ;
80807: LD_ADDR_VAR 0 29
80811: PUSH
80812: LD_INT 1
80814: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
80815: LD_VAR 0 4
80819: PUSH
80820: LD_VAR 0 7
80824: ARRAY
80825: PPUSH
80826: CALL_OW 250
80830: PPUSH
80831: LD_VAR 0 4
80835: PUSH
80836: LD_VAR 0 7
80840: ARRAY
80841: PPUSH
80842: CALL_OW 251
80846: PPUSH
80847: CALL_OW 546
80851: PUSH
80852: LD_INT 2
80854: ARRAY
80855: PUSH
80856: LD_VAR 0 14
80860: PUSH
80861: LD_INT 1
80863: ARRAY
80864: PPUSH
80865: CALL_OW 250
80869: PPUSH
80870: LD_VAR 0 14
80874: PUSH
80875: LD_INT 1
80877: ARRAY
80878: PPUSH
80879: CALL_OW 251
80883: PPUSH
80884: CALL_OW 546
80888: PUSH
80889: LD_INT 2
80891: ARRAY
80892: EQUAL
80893: IFFALSE 80921
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
80895: LD_VAR 0 4
80899: PUSH
80900: LD_VAR 0 7
80904: ARRAY
80905: PPUSH
80906: LD_VAR 0 14
80910: PUSH
80911: LD_INT 1
80913: ARRAY
80914: PPUSH
80915: CALL 52106 0 2
80919: GO 80945
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
80921: LD_VAR 0 4
80925: PUSH
80926: LD_VAR 0 7
80930: ARRAY
80931: PPUSH
80932: LD_VAR 0 14
80936: PUSH
80937: LD_INT 1
80939: ARRAY
80940: PPUSH
80941: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
80945: LD_VAR 0 4
80949: PUSH
80950: LD_VAR 0 7
80954: ARRAY
80955: PPUSH
80956: CALL_OW 264
80960: PUSH
80961: LD_INT 29
80963: EQUAL
80964: IFFALSE 81330
// begin if WantsToAttack ( group [ i ] ) in bombed then
80966: LD_VAR 0 4
80970: PUSH
80971: LD_VAR 0 7
80975: ARRAY
80976: PPUSH
80977: CALL_OW 319
80981: PUSH
80982: LD_VAR 0 28
80986: IN
80987: IFFALSE 80991
// continue ;
80989: GO 77995
// k := 8 ;
80991: LD_ADDR_VAR 0 9
80995: PUSH
80996: LD_INT 8
80998: ST_TO_ADDR
// x := 0 ;
80999: LD_ADDR_VAR 0 10
81003: PUSH
81004: LD_INT 0
81006: ST_TO_ADDR
// if tmp < k then
81007: LD_VAR 0 14
81011: PUSH
81012: LD_VAR 0 9
81016: LESS
81017: IFFALSE 81029
// k := tmp ;
81019: LD_ADDR_VAR 0 9
81023: PUSH
81024: LD_VAR 0 14
81028: ST_TO_ADDR
// for j = 1 to k do
81029: LD_ADDR_VAR 0 8
81033: PUSH
81034: DOUBLE
81035: LD_INT 1
81037: DEC
81038: ST_TO_ADDR
81039: LD_VAR 0 9
81043: PUSH
81044: FOR_TO
81045: IFFALSE 81177
// begin if GetType ( tmp [ j ] ) = unit_building then
81047: LD_VAR 0 14
81051: PUSH
81052: LD_VAR 0 8
81056: ARRAY
81057: PPUSH
81058: CALL_OW 247
81062: PUSH
81063: LD_INT 3
81065: EQUAL
81066: IFFALSE 81175
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
81068: LD_VAR 0 14
81072: PUSH
81073: LD_VAR 0 8
81077: ARRAY
81078: PUSH
81079: LD_VAR 0 28
81083: IN
81084: NOT
81085: PUSH
81086: LD_VAR 0 14
81090: PUSH
81091: LD_VAR 0 8
81095: ARRAY
81096: PPUSH
81097: CALL_OW 313
81101: AND
81102: IFFALSE 81175
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
81104: LD_VAR 0 4
81108: PUSH
81109: LD_VAR 0 7
81113: ARRAY
81114: PPUSH
81115: LD_VAR 0 14
81119: PUSH
81120: LD_VAR 0 8
81124: ARRAY
81125: PPUSH
81126: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
81130: LD_ADDR_VAR 0 28
81134: PUSH
81135: LD_VAR 0 28
81139: PPUSH
81140: LD_VAR 0 28
81144: PUSH
81145: LD_INT 1
81147: PLUS
81148: PPUSH
81149: LD_VAR 0 14
81153: PUSH
81154: LD_VAR 0 8
81158: ARRAY
81159: PPUSH
81160: CALL_OW 1
81164: ST_TO_ADDR
// attacking := true ;
81165: LD_ADDR_VAR 0 29
81169: PUSH
81170: LD_INT 1
81172: ST_TO_ADDR
// break ;
81173: GO 81177
// end ; end ;
81175: GO 81044
81177: POP
81178: POP
// if not attacking and f_attack_depot then
81179: LD_VAR 0 29
81183: NOT
81184: PUSH
81185: LD_VAR 0 25
81189: AND
81190: IFFALSE 81285
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
81192: LD_ADDR_VAR 0 13
81196: PUSH
81197: LD_VAR 0 14
81201: PPUSH
81202: LD_INT 2
81204: PUSH
81205: LD_INT 30
81207: PUSH
81208: LD_INT 0
81210: PUSH
81211: EMPTY
81212: LIST
81213: LIST
81214: PUSH
81215: LD_INT 30
81217: PUSH
81218: LD_INT 1
81220: PUSH
81221: EMPTY
81222: LIST
81223: LIST
81224: PUSH
81225: EMPTY
81226: LIST
81227: LIST
81228: LIST
81229: PPUSH
81230: CALL_OW 72
81234: ST_TO_ADDR
// if z then
81235: LD_VAR 0 13
81239: IFFALSE 81285
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
81241: LD_VAR 0 4
81245: PUSH
81246: LD_VAR 0 7
81250: ARRAY
81251: PPUSH
81252: LD_VAR 0 13
81256: PPUSH
81257: LD_VAR 0 4
81261: PUSH
81262: LD_VAR 0 7
81266: ARRAY
81267: PPUSH
81268: CALL_OW 74
81272: PPUSH
81273: CALL_OW 115
// attacking := true ;
81277: LD_ADDR_VAR 0 29
81281: PUSH
81282: LD_INT 1
81284: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
81285: LD_VAR 0 4
81289: PUSH
81290: LD_VAR 0 7
81294: ARRAY
81295: PPUSH
81296: CALL_OW 256
81300: PUSH
81301: LD_INT 500
81303: LESS
81304: IFFALSE 81330
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
81306: LD_VAR 0 4
81310: PUSH
81311: LD_VAR 0 7
81315: ARRAY
81316: PPUSH
81317: LD_VAR 0 14
81321: PUSH
81322: LD_INT 1
81324: ARRAY
81325: PPUSH
81326: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
81330: LD_VAR 0 4
81334: PUSH
81335: LD_VAR 0 7
81339: ARRAY
81340: PPUSH
81341: CALL_OW 264
81345: PUSH
81346: LD_INT 49
81348: EQUAL
81349: IFFALSE 81470
// begin if not HasTask ( group [ i ] ) then
81351: LD_VAR 0 4
81355: PUSH
81356: LD_VAR 0 7
81360: ARRAY
81361: PPUSH
81362: CALL_OW 314
81366: NOT
81367: IFFALSE 81470
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
81369: LD_ADDR_VAR 0 9
81373: PUSH
81374: LD_INT 81
81376: PUSH
81377: LD_VAR 0 4
81381: PUSH
81382: LD_VAR 0 7
81386: ARRAY
81387: PPUSH
81388: CALL_OW 255
81392: PUSH
81393: EMPTY
81394: LIST
81395: LIST
81396: PPUSH
81397: CALL_OW 69
81401: PPUSH
81402: LD_VAR 0 4
81406: PUSH
81407: LD_VAR 0 7
81411: ARRAY
81412: PPUSH
81413: CALL_OW 74
81417: ST_TO_ADDR
// if k then
81418: LD_VAR 0 9
81422: IFFALSE 81470
// if GetDistUnits ( group [ i ] , k ) > 10 then
81424: LD_VAR 0 4
81428: PUSH
81429: LD_VAR 0 7
81433: ARRAY
81434: PPUSH
81435: LD_VAR 0 9
81439: PPUSH
81440: CALL_OW 296
81444: PUSH
81445: LD_INT 10
81447: GREATER
81448: IFFALSE 81470
// ComMoveUnit ( group [ i ] , k ) ;
81450: LD_VAR 0 4
81454: PUSH
81455: LD_VAR 0 7
81459: ARRAY
81460: PPUSH
81461: LD_VAR 0 9
81465: PPUSH
81466: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
81470: LD_VAR 0 4
81474: PUSH
81475: LD_VAR 0 7
81479: ARRAY
81480: PPUSH
81481: CALL_OW 256
81485: PUSH
81486: LD_INT 250
81488: LESS
81489: PUSH
81490: LD_VAR 0 4
81494: PUSH
81495: LD_VAR 0 7
81499: ARRAY
81500: PUSH
81501: LD_INT 21
81503: PUSH
81504: LD_INT 2
81506: PUSH
81507: EMPTY
81508: LIST
81509: LIST
81510: PUSH
81511: LD_INT 23
81513: PUSH
81514: LD_INT 2
81516: PUSH
81517: EMPTY
81518: LIST
81519: LIST
81520: PUSH
81521: EMPTY
81522: LIST
81523: LIST
81524: PPUSH
81525: CALL_OW 69
81529: IN
81530: AND
81531: IFFALSE 81656
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
81533: LD_ADDR_VAR 0 9
81537: PUSH
81538: LD_OWVAR 3
81542: PUSH
81543: LD_VAR 0 4
81547: PUSH
81548: LD_VAR 0 7
81552: ARRAY
81553: DIFF
81554: PPUSH
81555: LD_VAR 0 4
81559: PUSH
81560: LD_VAR 0 7
81564: ARRAY
81565: PPUSH
81566: CALL_OW 74
81570: ST_TO_ADDR
// if not k then
81571: LD_VAR 0 9
81575: NOT
81576: IFFALSE 81580
// continue ;
81578: GO 77995
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
81580: LD_VAR 0 9
81584: PUSH
81585: LD_INT 81
81587: PUSH
81588: LD_VAR 0 4
81592: PUSH
81593: LD_VAR 0 7
81597: ARRAY
81598: PPUSH
81599: CALL_OW 255
81603: PUSH
81604: EMPTY
81605: LIST
81606: LIST
81607: PPUSH
81608: CALL_OW 69
81612: IN
81613: PUSH
81614: LD_VAR 0 9
81618: PPUSH
81619: LD_VAR 0 4
81623: PUSH
81624: LD_VAR 0 7
81628: ARRAY
81629: PPUSH
81630: CALL_OW 296
81634: PUSH
81635: LD_INT 5
81637: LESS
81638: AND
81639: IFFALSE 81656
// ComAutodestruct ( group [ i ] ) ;
81641: LD_VAR 0 4
81645: PUSH
81646: LD_VAR 0 7
81650: ARRAY
81651: PPUSH
81652: CALL 52004 0 1
// end ; if f_attack_depot then
81656: LD_VAR 0 25
81660: IFFALSE 81772
// begin k := 6 ;
81662: LD_ADDR_VAR 0 9
81666: PUSH
81667: LD_INT 6
81669: ST_TO_ADDR
// if tmp < k then
81670: LD_VAR 0 14
81674: PUSH
81675: LD_VAR 0 9
81679: LESS
81680: IFFALSE 81692
// k := tmp ;
81682: LD_ADDR_VAR 0 9
81686: PUSH
81687: LD_VAR 0 14
81691: ST_TO_ADDR
// for j = 1 to k do
81692: LD_ADDR_VAR 0 8
81696: PUSH
81697: DOUBLE
81698: LD_INT 1
81700: DEC
81701: ST_TO_ADDR
81702: LD_VAR 0 9
81706: PUSH
81707: FOR_TO
81708: IFFALSE 81770
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
81710: LD_VAR 0 8
81714: PPUSH
81715: CALL_OW 266
81719: PUSH
81720: LD_INT 0
81722: PUSH
81723: LD_INT 1
81725: PUSH
81726: EMPTY
81727: LIST
81728: LIST
81729: IN
81730: IFFALSE 81768
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
81732: LD_VAR 0 4
81736: PUSH
81737: LD_VAR 0 7
81741: ARRAY
81742: PPUSH
81743: LD_VAR 0 14
81747: PUSH
81748: LD_VAR 0 8
81752: ARRAY
81753: PPUSH
81754: CALL_OW 115
// attacking := true ;
81758: LD_ADDR_VAR 0 29
81762: PUSH
81763: LD_INT 1
81765: ST_TO_ADDR
// break ;
81766: GO 81770
// end ;
81768: GO 81707
81770: POP
81771: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
81772: LD_VAR 0 4
81776: PUSH
81777: LD_VAR 0 7
81781: ARRAY
81782: PPUSH
81783: CALL_OW 302
81787: PUSH
81788: LD_VAR 0 29
81792: NOT
81793: AND
81794: IFFALSE 82116
// begin if GetTag ( group [ i ] ) = 71 then
81796: LD_VAR 0 4
81800: PUSH
81801: LD_VAR 0 7
81805: ARRAY
81806: PPUSH
81807: CALL_OW 110
81811: PUSH
81812: LD_INT 71
81814: EQUAL
81815: IFFALSE 81856
// begin if HasTask ( group [ i ] ) then
81817: LD_VAR 0 4
81821: PUSH
81822: LD_VAR 0 7
81826: ARRAY
81827: PPUSH
81828: CALL_OW 314
81832: IFFALSE 81838
// continue else
81834: GO 77995
81836: GO 81856
// SetTag ( group [ i ] , 0 ) ;
81838: LD_VAR 0 4
81842: PUSH
81843: LD_VAR 0 7
81847: ARRAY
81848: PPUSH
81849: LD_INT 0
81851: PPUSH
81852: CALL_OW 109
// end ; k := 8 ;
81856: LD_ADDR_VAR 0 9
81860: PUSH
81861: LD_INT 8
81863: ST_TO_ADDR
// x := 0 ;
81864: LD_ADDR_VAR 0 10
81868: PUSH
81869: LD_INT 0
81871: ST_TO_ADDR
// if tmp < k then
81872: LD_VAR 0 14
81876: PUSH
81877: LD_VAR 0 9
81881: LESS
81882: IFFALSE 81894
// k := tmp ;
81884: LD_ADDR_VAR 0 9
81888: PUSH
81889: LD_VAR 0 14
81893: ST_TO_ADDR
// for j = 1 to k do
81894: LD_ADDR_VAR 0 8
81898: PUSH
81899: DOUBLE
81900: LD_INT 1
81902: DEC
81903: ST_TO_ADDR
81904: LD_VAR 0 9
81908: PUSH
81909: FOR_TO
81910: IFFALSE 82008
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
81912: LD_VAR 0 14
81916: PUSH
81917: LD_VAR 0 8
81921: ARRAY
81922: PPUSH
81923: CALL_OW 247
81927: PUSH
81928: LD_INT 1
81930: EQUAL
81931: PUSH
81932: LD_VAR 0 14
81936: PUSH
81937: LD_VAR 0 8
81941: ARRAY
81942: PPUSH
81943: CALL_OW 256
81947: PUSH
81948: LD_INT 250
81950: LESS
81951: PUSH
81952: LD_VAR 0 20
81956: AND
81957: PUSH
81958: LD_VAR 0 20
81962: NOT
81963: PUSH
81964: LD_VAR 0 14
81968: PUSH
81969: LD_VAR 0 8
81973: ARRAY
81974: PPUSH
81975: CALL_OW 256
81979: PUSH
81980: LD_INT 250
81982: GREATEREQUAL
81983: AND
81984: OR
81985: AND
81986: IFFALSE 82006
// begin x := tmp [ j ] ;
81988: LD_ADDR_VAR 0 10
81992: PUSH
81993: LD_VAR 0 14
81997: PUSH
81998: LD_VAR 0 8
82002: ARRAY
82003: ST_TO_ADDR
// break ;
82004: GO 82008
// end ;
82006: GO 81909
82008: POP
82009: POP
// if x then
82010: LD_VAR 0 10
82014: IFFALSE 82038
// ComAttackUnit ( group [ i ] , x ) else
82016: LD_VAR 0 4
82020: PUSH
82021: LD_VAR 0 7
82025: ARRAY
82026: PPUSH
82027: LD_VAR 0 10
82031: PPUSH
82032: CALL_OW 115
82036: GO 82062
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
82038: LD_VAR 0 4
82042: PUSH
82043: LD_VAR 0 7
82047: ARRAY
82048: PPUSH
82049: LD_VAR 0 14
82053: PUSH
82054: LD_INT 1
82056: ARRAY
82057: PPUSH
82058: CALL_OW 115
// if not HasTask ( group [ i ] ) then
82062: LD_VAR 0 4
82066: PUSH
82067: LD_VAR 0 7
82071: ARRAY
82072: PPUSH
82073: CALL_OW 314
82077: NOT
82078: IFFALSE 82116
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
82080: LD_VAR 0 4
82084: PUSH
82085: LD_VAR 0 7
82089: ARRAY
82090: PPUSH
82091: LD_VAR 0 14
82095: PPUSH
82096: LD_VAR 0 4
82100: PUSH
82101: LD_VAR 0 7
82105: ARRAY
82106: PPUSH
82107: CALL_OW 74
82111: PPUSH
82112: CALL_OW 115
// end ; end ; end ;
82116: GO 77995
82118: POP
82119: POP
// wait ( 0 0$2 ) ;
82120: LD_INT 70
82122: PPUSH
82123: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
82127: LD_VAR 0 4
82131: NOT
82132: PUSH
82133: LD_VAR 0 4
82137: PUSH
82138: EMPTY
82139: EQUAL
82140: OR
82141: PUSH
82142: LD_INT 81
82144: PUSH
82145: LD_VAR 0 35
82149: PUSH
82150: EMPTY
82151: LIST
82152: LIST
82153: PPUSH
82154: CALL_OW 69
82158: NOT
82159: OR
82160: IFFALSE 77980
// end ;
82162: LD_VAR 0 2
82166: RET
// export function BasicDefend ( base , solds ) ; var enemy , e , side , i , hex ; begin
82167: LD_INT 0
82169: PPUSH
82170: PPUSH
82171: PPUSH
82172: PPUSH
82173: PPUSH
82174: PPUSH
// if not base or not mc_bases [ base ] or not solds then
82175: LD_VAR 0 1
82179: NOT
82180: PUSH
82181: LD_EXP 178
82185: PUSH
82186: LD_VAR 0 1
82190: ARRAY
82191: NOT
82192: OR
82193: PUSH
82194: LD_VAR 0 2
82198: NOT
82199: OR
82200: IFFALSE 82204
// exit ;
82202: GO 82758
// side := mc_sides [ base ] ;
82204: LD_ADDR_VAR 0 6
82208: PUSH
82209: LD_EXP 204
82213: PUSH
82214: LD_VAR 0 1
82218: ARRAY
82219: ST_TO_ADDR
// if not side then
82220: LD_VAR 0 6
82224: NOT
82225: IFFALSE 82229
// exit ;
82227: GO 82758
// for i in solds do
82229: LD_ADDR_VAR 0 7
82233: PUSH
82234: LD_VAR 0 2
82238: PUSH
82239: FOR_IN
82240: IFFALSE 82301
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
82242: LD_VAR 0 7
82246: PPUSH
82247: CALL_OW 310
82251: PPUSH
82252: CALL_OW 266
82256: PUSH
82257: LD_INT 32
82259: PUSH
82260: LD_INT 31
82262: PUSH
82263: EMPTY
82264: LIST
82265: LIST
82266: IN
82267: IFFALSE 82287
// solds := solds diff i else
82269: LD_ADDR_VAR 0 2
82273: PUSH
82274: LD_VAR 0 2
82278: PUSH
82279: LD_VAR 0 7
82283: DIFF
82284: ST_TO_ADDR
82285: GO 82299
// SetTag ( i , 18 ) ;
82287: LD_VAR 0 7
82291: PPUSH
82292: LD_INT 18
82294: PPUSH
82295: CALL_OW 109
82299: GO 82239
82301: POP
82302: POP
// if not solds then
82303: LD_VAR 0 2
82307: NOT
82308: IFFALSE 82312
// exit ;
82310: GO 82758
// repeat wait ( 0 0$2 ) ;
82312: LD_INT 70
82314: PPUSH
82315: CALL_OW 67
// enemy := mc_scan [ base ] ;
82319: LD_ADDR_VAR 0 4
82323: PUSH
82324: LD_EXP 201
82328: PUSH
82329: LD_VAR 0 1
82333: ARRAY
82334: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
82335: LD_EXP 178
82339: PUSH
82340: LD_VAR 0 1
82344: ARRAY
82345: NOT
82346: PUSH
82347: LD_EXP 178
82351: PUSH
82352: LD_VAR 0 1
82356: ARRAY
82357: PUSH
82358: EMPTY
82359: EQUAL
82360: OR
82361: IFFALSE 82398
// begin for i in solds do
82363: LD_ADDR_VAR 0 7
82367: PUSH
82368: LD_VAR 0 2
82372: PUSH
82373: FOR_IN
82374: IFFALSE 82387
// ComStop ( i ) ;
82376: LD_VAR 0 7
82380: PPUSH
82381: CALL_OW 141
82385: GO 82373
82387: POP
82388: POP
// solds := [ ] ;
82389: LD_ADDR_VAR 0 2
82393: PUSH
82394: EMPTY
82395: ST_TO_ADDR
// exit ;
82396: GO 82758
// end ; for i in solds do
82398: LD_ADDR_VAR 0 7
82402: PUSH
82403: LD_VAR 0 2
82407: PUSH
82408: FOR_IN
82409: IFFALSE 82730
// begin if IsInUnit ( i ) then
82411: LD_VAR 0 7
82415: PPUSH
82416: CALL_OW 310
82420: IFFALSE 82431
// ComExitBuilding ( i ) ;
82422: LD_VAR 0 7
82426: PPUSH
82427: CALL_OW 122
// if GetLives ( i ) > 500 then
82431: LD_VAR 0 7
82435: PPUSH
82436: CALL_OW 256
82440: PUSH
82441: LD_INT 500
82443: GREATER
82444: IFFALSE 82497
// begin e := NearestUnitToUnit ( enemy , i ) ;
82446: LD_ADDR_VAR 0 5
82450: PUSH
82451: LD_VAR 0 4
82455: PPUSH
82456: LD_VAR 0 7
82460: PPUSH
82461: CALL_OW 74
82465: ST_TO_ADDR
// ComAgressiveMove ( i , GetX ( e ) , GetY ( e ) ) ;
82466: LD_VAR 0 7
82470: PPUSH
82471: LD_VAR 0 5
82475: PPUSH
82476: CALL_OW 250
82480: PPUSH
82481: LD_VAR 0 5
82485: PPUSH
82486: CALL_OW 251
82490: PPUSH
82491: CALL_OW 114
// end else
82495: GO 82728
// if GetDistUnits ( i , NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ) > 10 then
82497: LD_VAR 0 7
82501: PPUSH
82502: LD_EXP 178
82506: PUSH
82507: LD_VAR 0 1
82511: ARRAY
82512: PPUSH
82513: LD_INT 2
82515: PUSH
82516: LD_INT 30
82518: PUSH
82519: LD_INT 0
82521: PUSH
82522: EMPTY
82523: LIST
82524: LIST
82525: PUSH
82526: LD_INT 30
82528: PUSH
82529: LD_INT 1
82531: PUSH
82532: EMPTY
82533: LIST
82534: LIST
82535: PUSH
82536: LD_INT 30
82538: PUSH
82539: LD_INT 6
82541: PUSH
82542: EMPTY
82543: LIST
82544: LIST
82545: PUSH
82546: EMPTY
82547: LIST
82548: LIST
82549: LIST
82550: LIST
82551: PPUSH
82552: CALL_OW 72
82556: PPUSH
82557: LD_VAR 0 7
82561: PPUSH
82562: CALL_OW 74
82566: PPUSH
82567: CALL_OW 296
82571: PUSH
82572: LD_INT 10
82574: GREATER
82575: IFFALSE 82728
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
82577: LD_ADDR_VAR 0 8
82581: PUSH
82582: LD_EXP 178
82586: PUSH
82587: LD_VAR 0 1
82591: ARRAY
82592: PPUSH
82593: LD_INT 2
82595: PUSH
82596: LD_INT 30
82598: PUSH
82599: LD_INT 0
82601: PUSH
82602: EMPTY
82603: LIST
82604: LIST
82605: PUSH
82606: LD_INT 30
82608: PUSH
82609: LD_INT 1
82611: PUSH
82612: EMPTY
82613: LIST
82614: LIST
82615: PUSH
82616: LD_INT 30
82618: PUSH
82619: LD_INT 6
82621: PUSH
82622: EMPTY
82623: LIST
82624: LIST
82625: PUSH
82626: EMPTY
82627: LIST
82628: LIST
82629: LIST
82630: LIST
82631: PPUSH
82632: CALL_OW 72
82636: PPUSH
82637: LD_VAR 0 7
82641: PPUSH
82642: CALL_OW 74
82646: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
82647: LD_VAR 0 7
82651: PPUSH
82652: LD_VAR 0 8
82656: PPUSH
82657: CALL_OW 250
82661: PPUSH
82662: LD_INT 3
82664: PPUSH
82665: LD_INT 5
82667: PPUSH
82668: CALL_OW 272
82672: PPUSH
82673: LD_VAR 0 8
82677: PPUSH
82678: CALL_OW 251
82682: PPUSH
82683: LD_INT 3
82685: PPUSH
82686: LD_INT 5
82688: PPUSH
82689: CALL_OW 273
82693: PPUSH
82694: CALL_OW 111
// SetTag ( i , 0 ) ;
82698: LD_VAR 0 7
82702: PPUSH
82703: LD_INT 0
82705: PPUSH
82706: CALL_OW 109
// solds := solds diff i ;
82710: LD_ADDR_VAR 0 2
82714: PUSH
82715: LD_VAR 0 2
82719: PUSH
82720: LD_VAR 0 7
82724: DIFF
82725: ST_TO_ADDR
// continue ;
82726: GO 82408
// end ; end ;
82728: GO 82408
82730: POP
82731: POP
// until not solds or not enemy ;
82732: LD_VAR 0 2
82736: NOT
82737: PUSH
82738: LD_VAR 0 4
82742: NOT
82743: OR
82744: IFFALSE 82312
// MC_Reset ( base , 18 ) ;
82746: LD_VAR 0 1
82750: PPUSH
82751: LD_INT 18
82753: PPUSH
82754: CALL 88913 0 2
// end ;
82758: LD_VAR 0 3
82762: RET
// export function Defend ( base , defenders ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend , class , enemy ; begin
82763: LD_INT 0
82765: PPUSH
82766: PPUSH
82767: PPUSH
82768: PPUSH
82769: PPUSH
82770: PPUSH
82771: PPUSH
82772: PPUSH
82773: PPUSH
82774: PPUSH
82775: PPUSH
82776: PPUSH
82777: PPUSH
82778: PPUSH
82779: PPUSH
82780: PPUSH
82781: PPUSH
82782: PPUSH
82783: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
82784: LD_ADDR_VAR 0 12
82788: PUSH
82789: LD_EXP 178
82793: PUSH
82794: LD_VAR 0 1
82798: ARRAY
82799: PPUSH
82800: LD_INT 25
82802: PUSH
82803: LD_INT 3
82805: PUSH
82806: EMPTY
82807: LIST
82808: LIST
82809: PPUSH
82810: CALL_OW 72
82814: ST_TO_ADDR
// if mc_remote_driver [ base ] then
82815: LD_EXP 218
82819: PUSH
82820: LD_VAR 0 1
82824: ARRAY
82825: IFFALSE 82849
// mechs := mechs diff mc_remote_driver [ base ] ;
82827: LD_ADDR_VAR 0 12
82831: PUSH
82832: LD_VAR 0 12
82836: PUSH
82837: LD_EXP 218
82841: PUSH
82842: LD_VAR 0 1
82846: ARRAY
82847: DIFF
82848: ST_TO_ADDR
// for i in mechs do
82849: LD_ADDR_VAR 0 4
82853: PUSH
82854: LD_VAR 0 12
82858: PUSH
82859: FOR_IN
82860: IFFALSE 82895
// if GetTag ( i ) > 0 then
82862: LD_VAR 0 4
82866: PPUSH
82867: CALL_OW 110
82871: PUSH
82872: LD_INT 0
82874: GREATER
82875: IFFALSE 82893
// mechs := mechs diff i ;
82877: LD_ADDR_VAR 0 12
82881: PUSH
82882: LD_VAR 0 12
82886: PUSH
82887: LD_VAR 0 4
82891: DIFF
82892: ST_TO_ADDR
82893: GO 82859
82895: POP
82896: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
82897: LD_ADDR_VAR 0 8
82901: PUSH
82902: LD_EXP 178
82906: PUSH
82907: LD_VAR 0 1
82911: ARRAY
82912: PPUSH
82913: LD_INT 2
82915: PUSH
82916: LD_INT 25
82918: PUSH
82919: LD_INT 1
82921: PUSH
82922: EMPTY
82923: LIST
82924: LIST
82925: PUSH
82926: LD_INT 25
82928: PUSH
82929: LD_INT 5
82931: PUSH
82932: EMPTY
82933: LIST
82934: LIST
82935: PUSH
82936: LD_INT 25
82938: PUSH
82939: LD_INT 8
82941: PUSH
82942: EMPTY
82943: LIST
82944: LIST
82945: PUSH
82946: LD_INT 25
82948: PUSH
82949: LD_INT 9
82951: PUSH
82952: EMPTY
82953: LIST
82954: LIST
82955: PUSH
82956: EMPTY
82957: LIST
82958: LIST
82959: LIST
82960: LIST
82961: LIST
82962: PPUSH
82963: CALL_OW 72
82967: ST_TO_ADDR
// if not defenders and not solds then
82968: LD_VAR 0 2
82972: NOT
82973: PUSH
82974: LD_VAR 0 8
82978: NOT
82979: AND
82980: IFFALSE 82984
// exit ;
82982: GO 84754
// depot_under_attack := false ;
82984: LD_ADDR_VAR 0 16
82988: PUSH
82989: LD_INT 0
82991: ST_TO_ADDR
// sold_defenders := [ ] ;
82992: LD_ADDR_VAR 0 17
82996: PUSH
82997: EMPTY
82998: ST_TO_ADDR
// if mechs then
82999: LD_VAR 0 12
83003: IFFALSE 83156
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
83005: LD_ADDR_VAR 0 4
83009: PUSH
83010: LD_VAR 0 2
83014: PPUSH
83015: LD_INT 21
83017: PUSH
83018: LD_INT 2
83020: PUSH
83021: EMPTY
83022: LIST
83023: LIST
83024: PPUSH
83025: CALL_OW 72
83029: PUSH
83030: FOR_IN
83031: IFFALSE 83154
// begin if GetTag ( i ) <> 20 then
83033: LD_VAR 0 4
83037: PPUSH
83038: CALL_OW 110
83042: PUSH
83043: LD_INT 20
83045: NONEQUAL
83046: IFFALSE 83060
// SetTag ( i , 20 ) ;
83048: LD_VAR 0 4
83052: PPUSH
83053: LD_INT 20
83055: PPUSH
83056: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
83060: LD_VAR 0 4
83064: PPUSH
83065: CALL_OW 263
83069: PUSH
83070: LD_INT 1
83072: EQUAL
83073: PUSH
83074: LD_VAR 0 4
83078: PPUSH
83079: CALL_OW 311
83083: NOT
83084: AND
83085: IFFALSE 83152
// begin un := mechs [ 1 ] ;
83087: LD_ADDR_VAR 0 10
83091: PUSH
83092: LD_VAR 0 12
83096: PUSH
83097: LD_INT 1
83099: ARRAY
83100: ST_TO_ADDR
// ComExit ( un ) ;
83101: LD_VAR 0 10
83105: PPUSH
83106: CALL 56349 0 1
// AddComEnterUnit ( un , i ) ;
83110: LD_VAR 0 10
83114: PPUSH
83115: LD_VAR 0 4
83119: PPUSH
83120: CALL_OW 180
// SetTag ( un , 19 ) ;
83124: LD_VAR 0 10
83128: PPUSH
83129: LD_INT 19
83131: PPUSH
83132: CALL_OW 109
// mechs := mechs diff un ;
83136: LD_ADDR_VAR 0 12
83140: PUSH
83141: LD_VAR 0 12
83145: PUSH
83146: LD_VAR 0 10
83150: DIFF
83151: ST_TO_ADDR
// end ; end ;
83152: GO 83030
83154: POP
83155: POP
// if solds then
83156: LD_VAR 0 8
83160: IFFALSE 83219
// for i in solds do
83162: LD_ADDR_VAR 0 4
83166: PUSH
83167: LD_VAR 0 8
83171: PUSH
83172: FOR_IN
83173: IFFALSE 83217
// if not GetTag ( i ) then
83175: LD_VAR 0 4
83179: PPUSH
83180: CALL_OW 110
83184: NOT
83185: IFFALSE 83215
// begin defenders := defenders union i ;
83187: LD_ADDR_VAR 0 2
83191: PUSH
83192: LD_VAR 0 2
83196: PUSH
83197: LD_VAR 0 4
83201: UNION
83202: ST_TO_ADDR
// SetTag ( i , 18 ) ;
83203: LD_VAR 0 4
83207: PPUSH
83208: LD_INT 18
83210: PPUSH
83211: CALL_OW 109
// end ;
83215: GO 83172
83217: POP
83218: POP
// repeat wait ( 0 0$2 ) ;
83219: LD_INT 70
83221: PPUSH
83222: CALL_OW 67
// enemy := mc_scan [ base ] ;
83226: LD_ADDR_VAR 0 21
83230: PUSH
83231: LD_EXP 201
83235: PUSH
83236: LD_VAR 0 1
83240: ARRAY
83241: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
83242: LD_EXP 178
83246: PUSH
83247: LD_VAR 0 1
83251: ARRAY
83252: NOT
83253: PUSH
83254: LD_EXP 178
83258: PUSH
83259: LD_VAR 0 1
83263: ARRAY
83264: PUSH
83265: EMPTY
83266: EQUAL
83267: OR
83268: IFFALSE 83305
// begin for i in defenders do
83270: LD_ADDR_VAR 0 4
83274: PUSH
83275: LD_VAR 0 2
83279: PUSH
83280: FOR_IN
83281: IFFALSE 83294
// ComStop ( i ) ;
83283: LD_VAR 0 4
83287: PPUSH
83288: CALL_OW 141
83292: GO 83280
83294: POP
83295: POP
// defenders := [ ] ;
83296: LD_ADDR_VAR 0 2
83300: PUSH
83301: EMPTY
83302: ST_TO_ADDR
// exit ;
83303: GO 84754
// end ; for i in defenders do
83305: LD_ADDR_VAR 0 4
83309: PUSH
83310: LD_VAR 0 2
83314: PUSH
83315: FOR_IN
83316: IFFALSE 84214
// begin e := NearestUnitToUnit ( enemy , i ) ;
83318: LD_ADDR_VAR 0 13
83322: PUSH
83323: LD_VAR 0 21
83327: PPUSH
83328: LD_VAR 0 4
83332: PPUSH
83333: CALL_OW 74
83337: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
83338: LD_ADDR_VAR 0 7
83342: PUSH
83343: LD_EXP 178
83347: PUSH
83348: LD_VAR 0 1
83352: ARRAY
83353: PPUSH
83354: LD_INT 2
83356: PUSH
83357: LD_INT 30
83359: PUSH
83360: LD_INT 0
83362: PUSH
83363: EMPTY
83364: LIST
83365: LIST
83366: PUSH
83367: LD_INT 30
83369: PUSH
83370: LD_INT 1
83372: PUSH
83373: EMPTY
83374: LIST
83375: LIST
83376: PUSH
83377: EMPTY
83378: LIST
83379: LIST
83380: LIST
83381: PPUSH
83382: CALL_OW 72
83386: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
83387: LD_ADDR_VAR 0 16
83391: PUSH
83392: LD_VAR 0 7
83396: NOT
83397: PUSH
83398: LD_VAR 0 7
83402: PPUSH
83403: LD_INT 3
83405: PUSH
83406: LD_INT 24
83408: PUSH
83409: LD_INT 600
83411: PUSH
83412: EMPTY
83413: LIST
83414: LIST
83415: PUSH
83416: EMPTY
83417: LIST
83418: LIST
83419: PPUSH
83420: CALL_OW 72
83424: OR
83425: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
83426: LD_VAR 0 4
83430: PPUSH
83431: CALL_OW 247
83435: PUSH
83436: LD_INT 2
83438: DOUBLE
83439: EQUAL
83440: IFTRUE 83444
83442: GO 83840
83444: POP
// begin if GetLives ( i ) = 1000 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
83445: LD_VAR 0 4
83449: PPUSH
83450: CALL_OW 256
83454: PUSH
83455: LD_INT 1000
83457: EQUAL
83458: PUSH
83459: LD_VAR 0 4
83463: PPUSH
83464: LD_VAR 0 13
83468: PPUSH
83469: CALL_OW 296
83473: PUSH
83474: LD_INT 40
83476: LESS
83477: PUSH
83478: LD_VAR 0 13
83482: PPUSH
83483: LD_EXP 203
83487: PUSH
83488: LD_VAR 0 1
83492: ARRAY
83493: PPUSH
83494: CALL_OW 308
83498: OR
83499: AND
83500: IFFALSE 83622
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
83502: LD_VAR 0 4
83506: PPUSH
83507: CALL_OW 262
83511: PUSH
83512: LD_INT 1
83514: EQUAL
83515: PUSH
83516: LD_VAR 0 4
83520: PPUSH
83521: CALL_OW 261
83525: PUSH
83526: LD_INT 30
83528: LESS
83529: AND
83530: PUSH
83531: LD_VAR 0 7
83535: AND
83536: IFFALSE 83606
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
83538: LD_VAR 0 4
83542: PPUSH
83543: LD_VAR 0 7
83547: PPUSH
83548: LD_VAR 0 4
83552: PPUSH
83553: CALL_OW 74
83557: PPUSH
83558: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
83562: LD_VAR 0 4
83566: PPUSH
83567: LD_VAR 0 7
83571: PPUSH
83572: LD_VAR 0 4
83576: PPUSH
83577: CALL_OW 74
83581: PPUSH
83582: CALL_OW 296
83586: PUSH
83587: LD_INT 6
83589: LESS
83590: IFFALSE 83604
// SetFuel ( i , 100 ) ;
83592: LD_VAR 0 4
83596: PPUSH
83597: LD_INT 100
83599: PPUSH
83600: CALL_OW 240
// end else
83604: GO 83620
// ComAttackUnit ( i , e ) ;
83606: LD_VAR 0 4
83610: PPUSH
83611: LD_VAR 0 13
83615: PPUSH
83616: CALL_OW 115
// end else
83620: GO 83723
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
83622: LD_VAR 0 13
83626: PPUSH
83627: LD_EXP 203
83631: PUSH
83632: LD_VAR 0 1
83636: ARRAY
83637: PPUSH
83638: CALL_OW 308
83642: NOT
83643: PUSH
83644: LD_VAR 0 4
83648: PPUSH
83649: LD_VAR 0 13
83653: PPUSH
83654: CALL_OW 296
83658: PUSH
83659: LD_INT 40
83661: GREATEREQUAL
83662: AND
83663: PUSH
83664: LD_VAR 0 4
83668: PPUSH
83669: CALL_OW 256
83673: PUSH
83674: LD_INT 650
83676: LESSEQUAL
83677: OR
83678: PUSH
83679: LD_VAR 0 4
83683: PPUSH
83684: LD_EXP 202
83688: PUSH
83689: LD_VAR 0 1
83693: ARRAY
83694: PPUSH
83695: CALL_OW 308
83699: NOT
83700: AND
83701: IFFALSE 83723
// ComMoveToArea ( i , mc_parking [ base ] ) ;
83703: LD_VAR 0 4
83707: PPUSH
83708: LD_EXP 202
83712: PUSH
83713: LD_VAR 0 1
83717: ARRAY
83718: PPUSH
83719: CALL_OW 113
// if GetLives ( i ) < 1000 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
83723: LD_VAR 0 4
83727: PPUSH
83728: CALL_OW 256
83732: PUSH
83733: LD_INT 1000
83735: LESS
83736: PUSH
83737: LD_VAR 0 4
83741: PPUSH
83742: CALL_OW 263
83746: PUSH
83747: LD_INT 1
83749: EQUAL
83750: AND
83751: PUSH
83752: LD_VAR 0 4
83756: PPUSH
83757: CALL_OW 311
83761: AND
83762: PUSH
83763: LD_VAR 0 4
83767: PPUSH
83768: LD_EXP 202
83772: PUSH
83773: LD_VAR 0 1
83777: ARRAY
83778: PPUSH
83779: CALL_OW 308
83783: AND
83784: IFFALSE 83838
// begin mech := IsDrivenBy ( i ) ;
83786: LD_ADDR_VAR 0 9
83790: PUSH
83791: LD_VAR 0 4
83795: PPUSH
83796: CALL_OW 311
83800: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
83801: LD_VAR 0 9
83805: PPUSH
83806: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
83810: LD_VAR 0 9
83814: PPUSH
83815: LD_VAR 0 4
83819: PPUSH
83820: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
83824: LD_VAR 0 9
83828: PPUSH
83829: LD_VAR 0 4
83833: PPUSH
83834: CALL_OW 180
// end ; end ; unit_human :
83838: GO 84185
83840: LD_INT 1
83842: DOUBLE
83843: EQUAL
83844: IFTRUE 83848
83846: GO 84184
83848: POP
// begin b := IsInUnit ( i ) ;
83849: LD_ADDR_VAR 0 18
83853: PUSH
83854: LD_VAR 0 4
83858: PPUSH
83859: CALL_OW 310
83863: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
83864: LD_ADDR_VAR 0 19
83868: PUSH
83869: LD_VAR 0 18
83873: NOT
83874: PUSH
83875: LD_VAR 0 18
83879: PPUSH
83880: CALL_OW 266
83884: PUSH
83885: LD_INT 32
83887: PUSH
83888: LD_INT 31
83890: PUSH
83891: EMPTY
83892: LIST
83893: LIST
83894: IN
83895: OR
83896: ST_TO_ADDR
// if GetBType ( b ) = b_barracks and GetClass ( i ) in [ 1 , 2 , 3 , 4 ] then
83897: LD_VAR 0 18
83901: PPUSH
83902: CALL_OW 266
83906: PUSH
83907: LD_INT 5
83909: EQUAL
83910: PUSH
83911: LD_VAR 0 4
83915: PPUSH
83916: CALL_OW 257
83920: PUSH
83921: LD_INT 1
83923: PUSH
83924: LD_INT 2
83926: PUSH
83927: LD_INT 3
83929: PUSH
83930: LD_INT 4
83932: PUSH
83933: EMPTY
83934: LIST
83935: LIST
83936: LIST
83937: LIST
83938: IN
83939: AND
83940: IFFALSE 83977
// begin class := AllowSpecClass ( i ) ;
83942: LD_ADDR_VAR 0 20
83946: PUSH
83947: LD_VAR 0 4
83951: PPUSH
83952: CALL 21010 0 1
83956: ST_TO_ADDR
// if class then
83957: LD_VAR 0 20
83961: IFFALSE 83977
// ComChangeProfession ( i , class ) ;
83963: LD_VAR 0 4
83967: PPUSH
83968: LD_VAR 0 20
83972: PPUSH
83973: CALL_OW 123
// end ; if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
83977: LD_VAR 0 16
83981: PUSH
83982: LD_VAR 0 2
83986: PPUSH
83987: LD_INT 21
83989: PUSH
83990: LD_INT 2
83992: PUSH
83993: EMPTY
83994: LIST
83995: LIST
83996: PPUSH
83997: CALL_OW 72
84001: PUSH
84002: LD_INT 1
84004: LESSEQUAL
84005: OR
84006: PUSH
84007: LD_VAR 0 19
84011: AND
84012: PUSH
84013: LD_VAR 0 4
84017: PUSH
84018: LD_VAR 0 17
84022: IN
84023: NOT
84024: AND
84025: IFFALSE 84118
// begin if b then
84027: LD_VAR 0 18
84031: IFFALSE 84080
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
84033: LD_VAR 0 18
84037: PPUSH
84038: LD_VAR 0 21
84042: PPUSH
84043: LD_VAR 0 18
84047: PPUSH
84048: CALL_OW 74
84052: PPUSH
84053: CALL_OW 296
84057: PUSH
84058: LD_INT 10
84060: LESS
84061: PUSH
84062: LD_VAR 0 18
84066: PPUSH
84067: CALL_OW 461
84071: PUSH
84072: LD_INT 7
84074: NONEQUAL
84075: AND
84076: IFFALSE 84080
// continue ;
84078: GO 83315
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
84080: LD_ADDR_VAR 0 17
84084: PUSH
84085: LD_VAR 0 17
84089: PPUSH
84090: LD_VAR 0 17
84094: PUSH
84095: LD_INT 1
84097: PLUS
84098: PPUSH
84099: LD_VAR 0 4
84103: PPUSH
84104: CALL_OW 1
84108: ST_TO_ADDR
// ComExitBuilding ( i ) ;
84109: LD_VAR 0 4
84113: PPUSH
84114: CALL_OW 122
// end ; if sold_defenders then
84118: LD_VAR 0 17
84122: IFFALSE 84182
// if i in sold_defenders then
84124: LD_VAR 0 4
84128: PUSH
84129: LD_VAR 0 17
84133: IN
84134: IFFALSE 84182
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
84136: LD_VAR 0 4
84140: PPUSH
84141: CALL_OW 314
84145: NOT
84146: PUSH
84147: LD_VAR 0 4
84151: PPUSH
84152: LD_VAR 0 13
84156: PPUSH
84157: CALL_OW 296
84161: PUSH
84162: LD_INT 30
84164: LESS
84165: AND
84166: IFFALSE 84182
// ComAttackUnit ( i , e ) ;
84168: LD_VAR 0 4
84172: PPUSH
84173: LD_VAR 0 13
84177: PPUSH
84178: CALL_OW 115
// end ; end ; end ;
84182: GO 84185
84184: POP
// if IsDead ( i ) then
84185: LD_VAR 0 4
84189: PPUSH
84190: CALL_OW 301
84194: IFFALSE 84212
// defenders := defenders diff i ;
84196: LD_ADDR_VAR 0 2
84200: PUSH
84201: LD_VAR 0 2
84205: PUSH
84206: LD_VAR 0 4
84210: DIFF
84211: ST_TO_ADDR
// end ;
84212: GO 83315
84214: POP
84215: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
84216: LD_VAR 0 21
84220: NOT
84221: PUSH
84222: LD_VAR 0 2
84226: NOT
84227: OR
84228: PUSH
84229: LD_EXP 178
84233: PUSH
84234: LD_VAR 0 1
84238: ARRAY
84239: NOT
84240: OR
84241: IFFALSE 83219
// MC_Reset ( base , 18 ) ;
84243: LD_VAR 0 1
84247: PPUSH
84248: LD_INT 18
84250: PPUSH
84251: CALL 88913 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
84255: LD_ADDR_VAR 0 2
84259: PUSH
84260: LD_VAR 0 2
84264: PUSH
84265: LD_VAR 0 2
84269: PPUSH
84270: LD_INT 2
84272: PUSH
84273: LD_INT 25
84275: PUSH
84276: LD_INT 1
84278: PUSH
84279: EMPTY
84280: LIST
84281: LIST
84282: PUSH
84283: LD_INT 25
84285: PUSH
84286: LD_INT 5
84288: PUSH
84289: EMPTY
84290: LIST
84291: LIST
84292: PUSH
84293: LD_INT 25
84295: PUSH
84296: LD_INT 8
84298: PUSH
84299: EMPTY
84300: LIST
84301: LIST
84302: PUSH
84303: LD_INT 25
84305: PUSH
84306: LD_INT 9
84308: PUSH
84309: EMPTY
84310: LIST
84311: LIST
84312: PUSH
84313: EMPTY
84314: LIST
84315: LIST
84316: LIST
84317: LIST
84318: LIST
84319: PPUSH
84320: CALL_OW 72
84324: DIFF
84325: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
84326: LD_VAR 0 21
84330: NOT
84331: PUSH
84332: LD_VAR 0 2
84336: PPUSH
84337: LD_INT 21
84339: PUSH
84340: LD_INT 2
84342: PUSH
84343: EMPTY
84344: LIST
84345: LIST
84346: PPUSH
84347: CALL_OW 72
84351: AND
84352: IFFALSE 84690
// begin tmp := FilterByTag ( defenders , 19 ) ;
84354: LD_ADDR_VAR 0 11
84358: PUSH
84359: LD_VAR 0 2
84363: PPUSH
84364: LD_INT 19
84366: PPUSH
84367: CALL 53479 0 2
84371: ST_TO_ADDR
// if tmp then
84372: LD_VAR 0 11
84376: IFFALSE 84446
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
84378: LD_ADDR_VAR 0 11
84382: PUSH
84383: LD_VAR 0 11
84387: PPUSH
84388: LD_INT 25
84390: PUSH
84391: LD_INT 3
84393: PUSH
84394: EMPTY
84395: LIST
84396: LIST
84397: PPUSH
84398: CALL_OW 72
84402: ST_TO_ADDR
// if tmp then
84403: LD_VAR 0 11
84407: IFFALSE 84446
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
84409: LD_ADDR_EXP 190
84413: PUSH
84414: LD_EXP 190
84418: PPUSH
84419: LD_VAR 0 1
84423: PPUSH
84424: LD_EXP 190
84428: PUSH
84429: LD_VAR 0 1
84433: ARRAY
84434: PUSH
84435: LD_VAR 0 11
84439: UNION
84440: PPUSH
84441: CALL_OW 1
84445: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
84446: LD_VAR 0 1
84450: PPUSH
84451: LD_INT 19
84453: PPUSH
84454: CALL 88913 0 2
// repeat wait ( 0 0$1 ) ;
84458: LD_INT 35
84460: PPUSH
84461: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
84465: LD_EXP 178
84469: PUSH
84470: LD_VAR 0 1
84474: ARRAY
84475: NOT
84476: PUSH
84477: LD_EXP 178
84481: PUSH
84482: LD_VAR 0 1
84486: ARRAY
84487: PUSH
84488: EMPTY
84489: EQUAL
84490: OR
84491: IFFALSE 84528
// begin for i in defenders do
84493: LD_ADDR_VAR 0 4
84497: PUSH
84498: LD_VAR 0 2
84502: PUSH
84503: FOR_IN
84504: IFFALSE 84517
// ComStop ( i ) ;
84506: LD_VAR 0 4
84510: PPUSH
84511: CALL_OW 141
84515: GO 84503
84517: POP
84518: POP
// defenders := [ ] ;
84519: LD_ADDR_VAR 0 2
84523: PUSH
84524: EMPTY
84525: ST_TO_ADDR
// exit ;
84526: GO 84754
// end ; for i in defenders do
84528: LD_ADDR_VAR 0 4
84532: PUSH
84533: LD_VAR 0 2
84537: PUSH
84538: FOR_IN
84539: IFFALSE 84628
// begin if not IsInArea ( i , mc_parking [ base ] ) then
84541: LD_VAR 0 4
84545: PPUSH
84546: LD_EXP 202
84550: PUSH
84551: LD_VAR 0 1
84555: ARRAY
84556: PPUSH
84557: CALL_OW 308
84561: NOT
84562: IFFALSE 84586
// ComMoveToArea ( i , mc_parking [ base ] ) else
84564: LD_VAR 0 4
84568: PPUSH
84569: LD_EXP 202
84573: PUSH
84574: LD_VAR 0 1
84578: ARRAY
84579: PPUSH
84580: CALL_OW 113
84584: GO 84626
// if GetControl ( i ) = control_manual then
84586: LD_VAR 0 4
84590: PPUSH
84591: CALL_OW 263
84595: PUSH
84596: LD_INT 1
84598: EQUAL
84599: IFFALSE 84626
// if IsDrivenBy ( i ) then
84601: LD_VAR 0 4
84605: PPUSH
84606: CALL_OW 311
84610: IFFALSE 84626
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
84612: LD_VAR 0 4
84616: PPUSH
84617: CALL_OW 311
84621: PPUSH
84622: CALL_OW 121
// end ;
84626: GO 84538
84628: POP
84629: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
84630: LD_VAR 0 2
84634: PPUSH
84635: LD_INT 95
84637: PUSH
84638: LD_EXP 202
84642: PUSH
84643: LD_VAR 0 1
84647: ARRAY
84648: PUSH
84649: EMPTY
84650: LIST
84651: LIST
84652: PPUSH
84653: CALL_OW 72
84657: PUSH
84658: LD_VAR 0 2
84662: EQUAL
84663: PUSH
84664: LD_EXP 201
84668: PUSH
84669: LD_VAR 0 1
84673: ARRAY
84674: OR
84675: PUSH
84676: LD_EXP 178
84680: PUSH
84681: LD_VAR 0 1
84685: ARRAY
84686: NOT
84687: OR
84688: IFFALSE 84458
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
84690: LD_ADDR_EXP 200
84694: PUSH
84695: LD_EXP 200
84699: PPUSH
84700: LD_VAR 0 1
84704: PPUSH
84705: LD_VAR 0 2
84709: PPUSH
84710: LD_INT 21
84712: PUSH
84713: LD_INT 2
84715: PUSH
84716: EMPTY
84717: LIST
84718: LIST
84719: PPUSH
84720: CALL_OW 72
84724: PPUSH
84725: CALL_OW 1
84729: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
84730: LD_VAR 0 1
84734: PPUSH
84735: LD_INT 19
84737: PPUSH
84738: CALL 88913 0 2
// MC_Reset ( base , 20 ) ;
84742: LD_VAR 0 1
84746: PPUSH
84747: LD_INT 20
84749: PPUSH
84750: CALL 88913 0 2
// end ; end_of_file
84754: LD_VAR 0 3
84758: RET
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use , mc_is_defending ; export function InitMacro ; var i ; begin
84759: LD_INT 0
84761: PPUSH
84762: PPUSH
// skirmish := false ;
84763: LD_ADDR_EXP 176
84767: PUSH
84768: LD_INT 0
84770: ST_TO_ADDR
// debug_mc := false ;
84771: LD_ADDR_EXP 177
84775: PUSH
84776: LD_INT 0
84778: ST_TO_ADDR
// mc_bases := [ ] ;
84779: LD_ADDR_EXP 178
84783: PUSH
84784: EMPTY
84785: ST_TO_ADDR
// mc_sides := [ ] ;
84786: LD_ADDR_EXP 204
84790: PUSH
84791: EMPTY
84792: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
84793: LD_ADDR_EXP 179
84797: PUSH
84798: EMPTY
84799: ST_TO_ADDR
// mc_building_repairs := [ ] ;
84800: LD_ADDR_EXP 180
84804: PUSH
84805: EMPTY
84806: ST_TO_ADDR
// mc_need_heal := [ ] ;
84807: LD_ADDR_EXP 181
84811: PUSH
84812: EMPTY
84813: ST_TO_ADDR
// mc_healers := [ ] ;
84814: LD_ADDR_EXP 182
84818: PUSH
84819: EMPTY
84820: ST_TO_ADDR
// mc_build_list := [ ] ;
84821: LD_ADDR_EXP 183
84825: PUSH
84826: EMPTY
84827: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
84828: LD_ADDR_EXP 210
84832: PUSH
84833: EMPTY
84834: ST_TO_ADDR
// mc_builders := [ ] ;
84835: LD_ADDR_EXP 184
84839: PUSH
84840: EMPTY
84841: ST_TO_ADDR
// mc_construct_list := [ ] ;
84842: LD_ADDR_EXP 185
84846: PUSH
84847: EMPTY
84848: ST_TO_ADDR
// mc_turret_list := [ ] ;
84849: LD_ADDR_EXP 186
84853: PUSH
84854: EMPTY
84855: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
84856: LD_ADDR_EXP 187
84860: PUSH
84861: EMPTY
84862: ST_TO_ADDR
// mc_miners := [ ] ;
84863: LD_ADDR_EXP 192
84867: PUSH
84868: EMPTY
84869: ST_TO_ADDR
// mc_mines := [ ] ;
84870: LD_ADDR_EXP 191
84874: PUSH
84875: EMPTY
84876: ST_TO_ADDR
// mc_minefields := [ ] ;
84877: LD_ADDR_EXP 193
84881: PUSH
84882: EMPTY
84883: ST_TO_ADDR
// mc_crates := [ ] ;
84884: LD_ADDR_EXP 194
84888: PUSH
84889: EMPTY
84890: ST_TO_ADDR
// mc_crates_collector := [ ] ;
84891: LD_ADDR_EXP 195
84895: PUSH
84896: EMPTY
84897: ST_TO_ADDR
// mc_crates_area := [ ] ;
84898: LD_ADDR_EXP 196
84902: PUSH
84903: EMPTY
84904: ST_TO_ADDR
// mc_vehicles := [ ] ;
84905: LD_ADDR_EXP 197
84909: PUSH
84910: EMPTY
84911: ST_TO_ADDR
// mc_attack := [ ] ;
84912: LD_ADDR_EXP 198
84916: PUSH
84917: EMPTY
84918: ST_TO_ADDR
// mc_produce := [ ] ;
84919: LD_ADDR_EXP 199
84923: PUSH
84924: EMPTY
84925: ST_TO_ADDR
// mc_defender := [ ] ;
84926: LD_ADDR_EXP 200
84930: PUSH
84931: EMPTY
84932: ST_TO_ADDR
// mc_parking := [ ] ;
84933: LD_ADDR_EXP 202
84937: PUSH
84938: EMPTY
84939: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
84940: LD_ADDR_EXP 188
84944: PUSH
84945: EMPTY
84946: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
84947: LD_ADDR_EXP 190
84951: PUSH
84952: EMPTY
84953: ST_TO_ADDR
// mc_scan := [ ] ;
84954: LD_ADDR_EXP 201
84958: PUSH
84959: EMPTY
84960: ST_TO_ADDR
// mc_scan_area := [ ] ;
84961: LD_ADDR_EXP 203
84965: PUSH
84966: EMPTY
84967: ST_TO_ADDR
// mc_tech := [ ] ;
84968: LD_ADDR_EXP 205
84972: PUSH
84973: EMPTY
84974: ST_TO_ADDR
// mc_class := [ ] ;
84975: LD_ADDR_EXP 219
84979: PUSH
84980: EMPTY
84981: ST_TO_ADDR
// mc_class_case_use := [ ] ;
84982: LD_ADDR_EXP 220
84986: PUSH
84987: EMPTY
84988: ST_TO_ADDR
// mc_is_defending := [ ] ;
84989: LD_ADDR_EXP 221
84993: PUSH
84994: EMPTY
84995: ST_TO_ADDR
// end ;
84996: LD_VAR 0 1
85000: RET
// export function MC_Kill ( base ) ; begin
85001: LD_INT 0
85003: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
85004: LD_ADDR_EXP 178
85008: PUSH
85009: LD_EXP 178
85013: PPUSH
85014: LD_VAR 0 1
85018: PPUSH
85019: EMPTY
85020: PPUSH
85021: CALL_OW 1
85025: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
85026: LD_ADDR_EXP 179
85030: PUSH
85031: LD_EXP 179
85035: PPUSH
85036: LD_VAR 0 1
85040: PPUSH
85041: EMPTY
85042: PPUSH
85043: CALL_OW 1
85047: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
85048: LD_ADDR_EXP 180
85052: PUSH
85053: LD_EXP 180
85057: PPUSH
85058: LD_VAR 0 1
85062: PPUSH
85063: EMPTY
85064: PPUSH
85065: CALL_OW 1
85069: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
85070: LD_ADDR_EXP 181
85074: PUSH
85075: LD_EXP 181
85079: PPUSH
85080: LD_VAR 0 1
85084: PPUSH
85085: EMPTY
85086: PPUSH
85087: CALL_OW 1
85091: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
85092: LD_ADDR_EXP 182
85096: PUSH
85097: LD_EXP 182
85101: PPUSH
85102: LD_VAR 0 1
85106: PPUSH
85107: EMPTY
85108: PPUSH
85109: CALL_OW 1
85113: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
85114: LD_ADDR_EXP 183
85118: PUSH
85119: LD_EXP 183
85123: PPUSH
85124: LD_VAR 0 1
85128: PPUSH
85129: EMPTY
85130: PPUSH
85131: CALL_OW 1
85135: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
85136: LD_ADDR_EXP 184
85140: PUSH
85141: LD_EXP 184
85145: PPUSH
85146: LD_VAR 0 1
85150: PPUSH
85151: EMPTY
85152: PPUSH
85153: CALL_OW 1
85157: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
85158: LD_ADDR_EXP 185
85162: PUSH
85163: LD_EXP 185
85167: PPUSH
85168: LD_VAR 0 1
85172: PPUSH
85173: EMPTY
85174: PPUSH
85175: CALL_OW 1
85179: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
85180: LD_ADDR_EXP 186
85184: PUSH
85185: LD_EXP 186
85189: PPUSH
85190: LD_VAR 0 1
85194: PPUSH
85195: EMPTY
85196: PPUSH
85197: CALL_OW 1
85201: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
85202: LD_ADDR_EXP 187
85206: PUSH
85207: LD_EXP 187
85211: PPUSH
85212: LD_VAR 0 1
85216: PPUSH
85217: EMPTY
85218: PPUSH
85219: CALL_OW 1
85223: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
85224: LD_ADDR_EXP 188
85228: PUSH
85229: LD_EXP 188
85233: PPUSH
85234: LD_VAR 0 1
85238: PPUSH
85239: EMPTY
85240: PPUSH
85241: CALL_OW 1
85245: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
85246: LD_ADDR_EXP 189
85250: PUSH
85251: LD_EXP 189
85255: PPUSH
85256: LD_VAR 0 1
85260: PPUSH
85261: LD_INT 0
85263: PPUSH
85264: CALL_OW 1
85268: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
85269: LD_ADDR_EXP 190
85273: PUSH
85274: LD_EXP 190
85278: PPUSH
85279: LD_VAR 0 1
85283: PPUSH
85284: EMPTY
85285: PPUSH
85286: CALL_OW 1
85290: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
85291: LD_ADDR_EXP 191
85295: PUSH
85296: LD_EXP 191
85300: PPUSH
85301: LD_VAR 0 1
85305: PPUSH
85306: EMPTY
85307: PPUSH
85308: CALL_OW 1
85312: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
85313: LD_ADDR_EXP 192
85317: PUSH
85318: LD_EXP 192
85322: PPUSH
85323: LD_VAR 0 1
85327: PPUSH
85328: EMPTY
85329: PPUSH
85330: CALL_OW 1
85334: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
85335: LD_ADDR_EXP 193
85339: PUSH
85340: LD_EXP 193
85344: PPUSH
85345: LD_VAR 0 1
85349: PPUSH
85350: EMPTY
85351: PPUSH
85352: CALL_OW 1
85356: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
85357: LD_ADDR_EXP 194
85361: PUSH
85362: LD_EXP 194
85366: PPUSH
85367: LD_VAR 0 1
85371: PPUSH
85372: EMPTY
85373: PPUSH
85374: CALL_OW 1
85378: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
85379: LD_ADDR_EXP 195
85383: PUSH
85384: LD_EXP 195
85388: PPUSH
85389: LD_VAR 0 1
85393: PPUSH
85394: EMPTY
85395: PPUSH
85396: CALL_OW 1
85400: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
85401: LD_ADDR_EXP 196
85405: PUSH
85406: LD_EXP 196
85410: PPUSH
85411: LD_VAR 0 1
85415: PPUSH
85416: EMPTY
85417: PPUSH
85418: CALL_OW 1
85422: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
85423: LD_ADDR_EXP 197
85427: PUSH
85428: LD_EXP 197
85432: PPUSH
85433: LD_VAR 0 1
85437: PPUSH
85438: EMPTY
85439: PPUSH
85440: CALL_OW 1
85444: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
85445: LD_ADDR_EXP 198
85449: PUSH
85450: LD_EXP 198
85454: PPUSH
85455: LD_VAR 0 1
85459: PPUSH
85460: EMPTY
85461: PPUSH
85462: CALL_OW 1
85466: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
85467: LD_ADDR_EXP 199
85471: PUSH
85472: LD_EXP 199
85476: PPUSH
85477: LD_VAR 0 1
85481: PPUSH
85482: EMPTY
85483: PPUSH
85484: CALL_OW 1
85488: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
85489: LD_ADDR_EXP 200
85493: PUSH
85494: LD_EXP 200
85498: PPUSH
85499: LD_VAR 0 1
85503: PPUSH
85504: EMPTY
85505: PPUSH
85506: CALL_OW 1
85510: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
85511: LD_ADDR_EXP 201
85515: PUSH
85516: LD_EXP 201
85520: PPUSH
85521: LD_VAR 0 1
85525: PPUSH
85526: EMPTY
85527: PPUSH
85528: CALL_OW 1
85532: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
85533: LD_ADDR_EXP 202
85537: PUSH
85538: LD_EXP 202
85542: PPUSH
85543: LD_VAR 0 1
85547: PPUSH
85548: EMPTY
85549: PPUSH
85550: CALL_OW 1
85554: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
85555: LD_ADDR_EXP 203
85559: PUSH
85560: LD_EXP 203
85564: PPUSH
85565: LD_VAR 0 1
85569: PPUSH
85570: EMPTY
85571: PPUSH
85572: CALL_OW 1
85576: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
85577: LD_ADDR_EXP 205
85581: PUSH
85582: LD_EXP 205
85586: PPUSH
85587: LD_VAR 0 1
85591: PPUSH
85592: EMPTY
85593: PPUSH
85594: CALL_OW 1
85598: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
85599: LD_ADDR_EXP 207
85603: PUSH
85604: LD_EXP 207
85608: PPUSH
85609: LD_VAR 0 1
85613: PPUSH
85614: EMPTY
85615: PPUSH
85616: CALL_OW 1
85620: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
85621: LD_ADDR_EXP 208
85625: PUSH
85626: LD_EXP 208
85630: PPUSH
85631: LD_VAR 0 1
85635: PPUSH
85636: EMPTY
85637: PPUSH
85638: CALL_OW 1
85642: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
85643: LD_ADDR_EXP 209
85647: PUSH
85648: LD_EXP 209
85652: PPUSH
85653: LD_VAR 0 1
85657: PPUSH
85658: EMPTY
85659: PPUSH
85660: CALL_OW 1
85664: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
85665: LD_ADDR_EXP 210
85669: PUSH
85670: LD_EXP 210
85674: PPUSH
85675: LD_VAR 0 1
85679: PPUSH
85680: EMPTY
85681: PPUSH
85682: CALL_OW 1
85686: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
85687: LD_ADDR_EXP 211
85691: PUSH
85692: LD_EXP 211
85696: PPUSH
85697: LD_VAR 0 1
85701: PPUSH
85702: EMPTY
85703: PPUSH
85704: CALL_OW 1
85708: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
85709: LD_ADDR_EXP 212
85713: PUSH
85714: LD_EXP 212
85718: PPUSH
85719: LD_VAR 0 1
85723: PPUSH
85724: EMPTY
85725: PPUSH
85726: CALL_OW 1
85730: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
85731: LD_ADDR_EXP 213
85735: PUSH
85736: LD_EXP 213
85740: PPUSH
85741: LD_VAR 0 1
85745: PPUSH
85746: EMPTY
85747: PPUSH
85748: CALL_OW 1
85752: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
85753: LD_ADDR_EXP 214
85757: PUSH
85758: LD_EXP 214
85762: PPUSH
85763: LD_VAR 0 1
85767: PPUSH
85768: EMPTY
85769: PPUSH
85770: CALL_OW 1
85774: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
85775: LD_ADDR_EXP 215
85779: PUSH
85780: LD_EXP 215
85784: PPUSH
85785: LD_VAR 0 1
85789: PPUSH
85790: EMPTY
85791: PPUSH
85792: CALL_OW 1
85796: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
85797: LD_ADDR_EXP 216
85801: PUSH
85802: LD_EXP 216
85806: PPUSH
85807: LD_VAR 0 1
85811: PPUSH
85812: EMPTY
85813: PPUSH
85814: CALL_OW 1
85818: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
85819: LD_ADDR_EXP 217
85823: PUSH
85824: LD_EXP 217
85828: PPUSH
85829: LD_VAR 0 1
85833: PPUSH
85834: EMPTY
85835: PPUSH
85836: CALL_OW 1
85840: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
85841: LD_ADDR_EXP 218
85845: PUSH
85846: LD_EXP 218
85850: PPUSH
85851: LD_VAR 0 1
85855: PPUSH
85856: EMPTY
85857: PPUSH
85858: CALL_OW 1
85862: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
85863: LD_ADDR_EXP 219
85867: PUSH
85868: LD_EXP 219
85872: PPUSH
85873: LD_VAR 0 1
85877: PPUSH
85878: EMPTY
85879: PPUSH
85880: CALL_OW 1
85884: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
85885: LD_ADDR_EXP 220
85889: PUSH
85890: LD_EXP 220
85894: PPUSH
85895: LD_VAR 0 1
85899: PPUSH
85900: LD_INT 0
85902: PPUSH
85903: CALL_OW 1
85907: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
85908: LD_ADDR_EXP 221
85912: PUSH
85913: LD_EXP 221
85917: PPUSH
85918: LD_VAR 0 1
85922: PPUSH
85923: LD_INT 0
85925: PPUSH
85926: CALL_OW 1
85930: ST_TO_ADDR
// end ;
85931: LD_VAR 0 2
85935: RET
// export function MC_Add ( side , units ) ; var base ; begin
85936: LD_INT 0
85938: PPUSH
85939: PPUSH
// base := mc_bases + 1 ;
85940: LD_ADDR_VAR 0 4
85944: PUSH
85945: LD_EXP 178
85949: PUSH
85950: LD_INT 1
85952: PLUS
85953: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
85954: LD_ADDR_EXP 204
85958: PUSH
85959: LD_EXP 204
85963: PPUSH
85964: LD_VAR 0 4
85968: PPUSH
85969: LD_VAR 0 1
85973: PPUSH
85974: CALL_OW 1
85978: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
85979: LD_ADDR_EXP 178
85983: PUSH
85984: LD_EXP 178
85988: PPUSH
85989: LD_VAR 0 4
85993: PPUSH
85994: LD_VAR 0 2
85998: PPUSH
85999: CALL_OW 1
86003: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
86004: LD_ADDR_EXP 179
86008: PUSH
86009: LD_EXP 179
86013: PPUSH
86014: LD_VAR 0 4
86018: PPUSH
86019: EMPTY
86020: PPUSH
86021: CALL_OW 1
86025: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
86026: LD_ADDR_EXP 180
86030: PUSH
86031: LD_EXP 180
86035: PPUSH
86036: LD_VAR 0 4
86040: PPUSH
86041: EMPTY
86042: PPUSH
86043: CALL_OW 1
86047: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
86048: LD_ADDR_EXP 181
86052: PUSH
86053: LD_EXP 181
86057: PPUSH
86058: LD_VAR 0 4
86062: PPUSH
86063: EMPTY
86064: PPUSH
86065: CALL_OW 1
86069: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
86070: LD_ADDR_EXP 182
86074: PUSH
86075: LD_EXP 182
86079: PPUSH
86080: LD_VAR 0 4
86084: PPUSH
86085: EMPTY
86086: PPUSH
86087: CALL_OW 1
86091: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
86092: LD_ADDR_EXP 183
86096: PUSH
86097: LD_EXP 183
86101: PPUSH
86102: LD_VAR 0 4
86106: PPUSH
86107: EMPTY
86108: PPUSH
86109: CALL_OW 1
86113: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
86114: LD_ADDR_EXP 184
86118: PUSH
86119: LD_EXP 184
86123: PPUSH
86124: LD_VAR 0 4
86128: PPUSH
86129: EMPTY
86130: PPUSH
86131: CALL_OW 1
86135: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
86136: LD_ADDR_EXP 185
86140: PUSH
86141: LD_EXP 185
86145: PPUSH
86146: LD_VAR 0 4
86150: PPUSH
86151: EMPTY
86152: PPUSH
86153: CALL_OW 1
86157: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
86158: LD_ADDR_EXP 186
86162: PUSH
86163: LD_EXP 186
86167: PPUSH
86168: LD_VAR 0 4
86172: PPUSH
86173: EMPTY
86174: PPUSH
86175: CALL_OW 1
86179: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
86180: LD_ADDR_EXP 187
86184: PUSH
86185: LD_EXP 187
86189: PPUSH
86190: LD_VAR 0 4
86194: PPUSH
86195: EMPTY
86196: PPUSH
86197: CALL_OW 1
86201: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
86202: LD_ADDR_EXP 188
86206: PUSH
86207: LD_EXP 188
86211: PPUSH
86212: LD_VAR 0 4
86216: PPUSH
86217: EMPTY
86218: PPUSH
86219: CALL_OW 1
86223: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
86224: LD_ADDR_EXP 189
86228: PUSH
86229: LD_EXP 189
86233: PPUSH
86234: LD_VAR 0 4
86238: PPUSH
86239: LD_INT 0
86241: PPUSH
86242: CALL_OW 1
86246: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
86247: LD_ADDR_EXP 190
86251: PUSH
86252: LD_EXP 190
86256: PPUSH
86257: LD_VAR 0 4
86261: PPUSH
86262: EMPTY
86263: PPUSH
86264: CALL_OW 1
86268: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
86269: LD_ADDR_EXP 191
86273: PUSH
86274: LD_EXP 191
86278: PPUSH
86279: LD_VAR 0 4
86283: PPUSH
86284: EMPTY
86285: PPUSH
86286: CALL_OW 1
86290: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
86291: LD_ADDR_EXP 192
86295: PUSH
86296: LD_EXP 192
86300: PPUSH
86301: LD_VAR 0 4
86305: PPUSH
86306: EMPTY
86307: PPUSH
86308: CALL_OW 1
86312: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
86313: LD_ADDR_EXP 193
86317: PUSH
86318: LD_EXP 193
86322: PPUSH
86323: LD_VAR 0 4
86327: PPUSH
86328: EMPTY
86329: PPUSH
86330: CALL_OW 1
86334: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
86335: LD_ADDR_EXP 194
86339: PUSH
86340: LD_EXP 194
86344: PPUSH
86345: LD_VAR 0 4
86349: PPUSH
86350: EMPTY
86351: PPUSH
86352: CALL_OW 1
86356: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
86357: LD_ADDR_EXP 195
86361: PUSH
86362: LD_EXP 195
86366: PPUSH
86367: LD_VAR 0 4
86371: PPUSH
86372: EMPTY
86373: PPUSH
86374: CALL_OW 1
86378: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
86379: LD_ADDR_EXP 196
86383: PUSH
86384: LD_EXP 196
86388: PPUSH
86389: LD_VAR 0 4
86393: PPUSH
86394: EMPTY
86395: PPUSH
86396: CALL_OW 1
86400: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
86401: LD_ADDR_EXP 197
86405: PUSH
86406: LD_EXP 197
86410: PPUSH
86411: LD_VAR 0 4
86415: PPUSH
86416: EMPTY
86417: PPUSH
86418: CALL_OW 1
86422: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
86423: LD_ADDR_EXP 198
86427: PUSH
86428: LD_EXP 198
86432: PPUSH
86433: LD_VAR 0 4
86437: PPUSH
86438: EMPTY
86439: PPUSH
86440: CALL_OW 1
86444: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
86445: LD_ADDR_EXP 199
86449: PUSH
86450: LD_EXP 199
86454: PPUSH
86455: LD_VAR 0 4
86459: PPUSH
86460: EMPTY
86461: PPUSH
86462: CALL_OW 1
86466: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
86467: LD_ADDR_EXP 200
86471: PUSH
86472: LD_EXP 200
86476: PPUSH
86477: LD_VAR 0 4
86481: PPUSH
86482: EMPTY
86483: PPUSH
86484: CALL_OW 1
86488: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
86489: LD_ADDR_EXP 201
86493: PUSH
86494: LD_EXP 201
86498: PPUSH
86499: LD_VAR 0 4
86503: PPUSH
86504: EMPTY
86505: PPUSH
86506: CALL_OW 1
86510: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
86511: LD_ADDR_EXP 202
86515: PUSH
86516: LD_EXP 202
86520: PPUSH
86521: LD_VAR 0 4
86525: PPUSH
86526: EMPTY
86527: PPUSH
86528: CALL_OW 1
86532: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
86533: LD_ADDR_EXP 203
86537: PUSH
86538: LD_EXP 203
86542: PPUSH
86543: LD_VAR 0 4
86547: PPUSH
86548: EMPTY
86549: PPUSH
86550: CALL_OW 1
86554: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
86555: LD_ADDR_EXP 205
86559: PUSH
86560: LD_EXP 205
86564: PPUSH
86565: LD_VAR 0 4
86569: PPUSH
86570: EMPTY
86571: PPUSH
86572: CALL_OW 1
86576: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
86577: LD_ADDR_EXP 207
86581: PUSH
86582: LD_EXP 207
86586: PPUSH
86587: LD_VAR 0 4
86591: PPUSH
86592: EMPTY
86593: PPUSH
86594: CALL_OW 1
86598: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
86599: LD_ADDR_EXP 208
86603: PUSH
86604: LD_EXP 208
86608: PPUSH
86609: LD_VAR 0 4
86613: PPUSH
86614: EMPTY
86615: PPUSH
86616: CALL_OW 1
86620: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
86621: LD_ADDR_EXP 209
86625: PUSH
86626: LD_EXP 209
86630: PPUSH
86631: LD_VAR 0 4
86635: PPUSH
86636: EMPTY
86637: PPUSH
86638: CALL_OW 1
86642: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
86643: LD_ADDR_EXP 210
86647: PUSH
86648: LD_EXP 210
86652: PPUSH
86653: LD_VAR 0 4
86657: PPUSH
86658: EMPTY
86659: PPUSH
86660: CALL_OW 1
86664: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
86665: LD_ADDR_EXP 211
86669: PUSH
86670: LD_EXP 211
86674: PPUSH
86675: LD_VAR 0 4
86679: PPUSH
86680: EMPTY
86681: PPUSH
86682: CALL_OW 1
86686: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
86687: LD_ADDR_EXP 212
86691: PUSH
86692: LD_EXP 212
86696: PPUSH
86697: LD_VAR 0 4
86701: PPUSH
86702: EMPTY
86703: PPUSH
86704: CALL_OW 1
86708: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
86709: LD_ADDR_EXP 213
86713: PUSH
86714: LD_EXP 213
86718: PPUSH
86719: LD_VAR 0 4
86723: PPUSH
86724: EMPTY
86725: PPUSH
86726: CALL_OW 1
86730: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
86731: LD_ADDR_EXP 214
86735: PUSH
86736: LD_EXP 214
86740: PPUSH
86741: LD_VAR 0 4
86745: PPUSH
86746: EMPTY
86747: PPUSH
86748: CALL_OW 1
86752: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
86753: LD_ADDR_EXP 215
86757: PUSH
86758: LD_EXP 215
86762: PPUSH
86763: LD_VAR 0 4
86767: PPUSH
86768: EMPTY
86769: PPUSH
86770: CALL_OW 1
86774: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
86775: LD_ADDR_EXP 216
86779: PUSH
86780: LD_EXP 216
86784: PPUSH
86785: LD_VAR 0 4
86789: PPUSH
86790: EMPTY
86791: PPUSH
86792: CALL_OW 1
86796: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
86797: LD_ADDR_EXP 217
86801: PUSH
86802: LD_EXP 217
86806: PPUSH
86807: LD_VAR 0 4
86811: PPUSH
86812: EMPTY
86813: PPUSH
86814: CALL_OW 1
86818: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
86819: LD_ADDR_EXP 218
86823: PUSH
86824: LD_EXP 218
86828: PPUSH
86829: LD_VAR 0 4
86833: PPUSH
86834: EMPTY
86835: PPUSH
86836: CALL_OW 1
86840: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
86841: LD_ADDR_EXP 219
86845: PUSH
86846: LD_EXP 219
86850: PPUSH
86851: LD_VAR 0 4
86855: PPUSH
86856: EMPTY
86857: PPUSH
86858: CALL_OW 1
86862: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
86863: LD_ADDR_EXP 220
86867: PUSH
86868: LD_EXP 220
86872: PPUSH
86873: LD_VAR 0 4
86877: PPUSH
86878: LD_INT 0
86880: PPUSH
86881: CALL_OW 1
86885: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
86886: LD_ADDR_EXP 221
86890: PUSH
86891: LD_EXP 221
86895: PPUSH
86896: LD_VAR 0 4
86900: PPUSH
86901: LD_INT 0
86903: PPUSH
86904: CALL_OW 1
86908: ST_TO_ADDR
// result := base ;
86909: LD_ADDR_VAR 0 3
86913: PUSH
86914: LD_VAR 0 4
86918: ST_TO_ADDR
// end ;
86919: LD_VAR 0 3
86923: RET
// export function MC_Start ( ) ; var i ; begin
86924: LD_INT 0
86926: PPUSH
86927: PPUSH
// for i = 1 to mc_bases do
86928: LD_ADDR_VAR 0 2
86932: PUSH
86933: DOUBLE
86934: LD_INT 1
86936: DEC
86937: ST_TO_ADDR
86938: LD_EXP 178
86942: PUSH
86943: FOR_TO
86944: IFFALSE 88044
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
86946: LD_ADDR_EXP 178
86950: PUSH
86951: LD_EXP 178
86955: PPUSH
86956: LD_VAR 0 2
86960: PPUSH
86961: LD_EXP 178
86965: PUSH
86966: LD_VAR 0 2
86970: ARRAY
86971: PUSH
86972: LD_INT 0
86974: DIFF
86975: PPUSH
86976: CALL_OW 1
86980: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
86981: LD_ADDR_EXP 179
86985: PUSH
86986: LD_EXP 179
86990: PPUSH
86991: LD_VAR 0 2
86995: PPUSH
86996: EMPTY
86997: PPUSH
86998: CALL_OW 1
87002: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
87003: LD_ADDR_EXP 180
87007: PUSH
87008: LD_EXP 180
87012: PPUSH
87013: LD_VAR 0 2
87017: PPUSH
87018: EMPTY
87019: PPUSH
87020: CALL_OW 1
87024: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
87025: LD_ADDR_EXP 181
87029: PUSH
87030: LD_EXP 181
87034: PPUSH
87035: LD_VAR 0 2
87039: PPUSH
87040: EMPTY
87041: PPUSH
87042: CALL_OW 1
87046: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
87047: LD_ADDR_EXP 182
87051: PUSH
87052: LD_EXP 182
87056: PPUSH
87057: LD_VAR 0 2
87061: PPUSH
87062: EMPTY
87063: PUSH
87064: EMPTY
87065: PUSH
87066: EMPTY
87067: LIST
87068: LIST
87069: PPUSH
87070: CALL_OW 1
87074: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
87075: LD_ADDR_EXP 183
87079: PUSH
87080: LD_EXP 183
87084: PPUSH
87085: LD_VAR 0 2
87089: PPUSH
87090: EMPTY
87091: PPUSH
87092: CALL_OW 1
87096: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
87097: LD_ADDR_EXP 210
87101: PUSH
87102: LD_EXP 210
87106: PPUSH
87107: LD_VAR 0 2
87111: PPUSH
87112: EMPTY
87113: PPUSH
87114: CALL_OW 1
87118: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
87119: LD_ADDR_EXP 184
87123: PUSH
87124: LD_EXP 184
87128: PPUSH
87129: LD_VAR 0 2
87133: PPUSH
87134: EMPTY
87135: PPUSH
87136: CALL_OW 1
87140: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
87141: LD_ADDR_EXP 185
87145: PUSH
87146: LD_EXP 185
87150: PPUSH
87151: LD_VAR 0 2
87155: PPUSH
87156: EMPTY
87157: PPUSH
87158: CALL_OW 1
87162: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
87163: LD_ADDR_EXP 186
87167: PUSH
87168: LD_EXP 186
87172: PPUSH
87173: LD_VAR 0 2
87177: PPUSH
87178: LD_EXP 178
87182: PUSH
87183: LD_VAR 0 2
87187: ARRAY
87188: PPUSH
87189: LD_INT 2
87191: PUSH
87192: LD_INT 30
87194: PUSH
87195: LD_INT 32
87197: PUSH
87198: EMPTY
87199: LIST
87200: LIST
87201: PUSH
87202: LD_INT 30
87204: PUSH
87205: LD_INT 33
87207: PUSH
87208: EMPTY
87209: LIST
87210: LIST
87211: PUSH
87212: EMPTY
87213: LIST
87214: LIST
87215: LIST
87216: PPUSH
87217: CALL_OW 72
87221: PPUSH
87222: CALL_OW 1
87226: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
87227: LD_ADDR_EXP 187
87231: PUSH
87232: LD_EXP 187
87236: PPUSH
87237: LD_VAR 0 2
87241: PPUSH
87242: LD_EXP 178
87246: PUSH
87247: LD_VAR 0 2
87251: ARRAY
87252: PPUSH
87253: LD_INT 2
87255: PUSH
87256: LD_INT 30
87258: PUSH
87259: LD_INT 32
87261: PUSH
87262: EMPTY
87263: LIST
87264: LIST
87265: PUSH
87266: LD_INT 30
87268: PUSH
87269: LD_INT 31
87271: PUSH
87272: EMPTY
87273: LIST
87274: LIST
87275: PUSH
87276: EMPTY
87277: LIST
87278: LIST
87279: LIST
87280: PUSH
87281: LD_INT 58
87283: PUSH
87284: EMPTY
87285: LIST
87286: PUSH
87287: EMPTY
87288: LIST
87289: LIST
87290: PPUSH
87291: CALL_OW 72
87295: PPUSH
87296: CALL_OW 1
87300: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
87301: LD_ADDR_EXP 188
87305: PUSH
87306: LD_EXP 188
87310: PPUSH
87311: LD_VAR 0 2
87315: PPUSH
87316: EMPTY
87317: PPUSH
87318: CALL_OW 1
87322: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
87323: LD_ADDR_EXP 192
87327: PUSH
87328: LD_EXP 192
87332: PPUSH
87333: LD_VAR 0 2
87337: PPUSH
87338: EMPTY
87339: PPUSH
87340: CALL_OW 1
87344: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
87345: LD_ADDR_EXP 191
87349: PUSH
87350: LD_EXP 191
87354: PPUSH
87355: LD_VAR 0 2
87359: PPUSH
87360: EMPTY
87361: PPUSH
87362: CALL_OW 1
87366: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
87367: LD_ADDR_EXP 193
87371: PUSH
87372: LD_EXP 193
87376: PPUSH
87377: LD_VAR 0 2
87381: PPUSH
87382: EMPTY
87383: PPUSH
87384: CALL_OW 1
87388: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
87389: LD_ADDR_EXP 194
87393: PUSH
87394: LD_EXP 194
87398: PPUSH
87399: LD_VAR 0 2
87403: PPUSH
87404: EMPTY
87405: PPUSH
87406: CALL_OW 1
87410: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
87411: LD_ADDR_EXP 195
87415: PUSH
87416: LD_EXP 195
87420: PPUSH
87421: LD_VAR 0 2
87425: PPUSH
87426: EMPTY
87427: PPUSH
87428: CALL_OW 1
87432: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
87433: LD_ADDR_EXP 196
87437: PUSH
87438: LD_EXP 196
87442: PPUSH
87443: LD_VAR 0 2
87447: PPUSH
87448: EMPTY
87449: PPUSH
87450: CALL_OW 1
87454: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
87455: LD_ADDR_EXP 197
87459: PUSH
87460: LD_EXP 197
87464: PPUSH
87465: LD_VAR 0 2
87469: PPUSH
87470: EMPTY
87471: PPUSH
87472: CALL_OW 1
87476: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
87477: LD_ADDR_EXP 198
87481: PUSH
87482: LD_EXP 198
87486: PPUSH
87487: LD_VAR 0 2
87491: PPUSH
87492: EMPTY
87493: PPUSH
87494: CALL_OW 1
87498: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
87499: LD_ADDR_EXP 199
87503: PUSH
87504: LD_EXP 199
87508: PPUSH
87509: LD_VAR 0 2
87513: PPUSH
87514: EMPTY
87515: PPUSH
87516: CALL_OW 1
87520: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
87521: LD_ADDR_EXP 200
87525: PUSH
87526: LD_EXP 200
87530: PPUSH
87531: LD_VAR 0 2
87535: PPUSH
87536: EMPTY
87537: PPUSH
87538: CALL_OW 1
87542: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
87543: LD_ADDR_EXP 189
87547: PUSH
87548: LD_EXP 189
87552: PPUSH
87553: LD_VAR 0 2
87557: PPUSH
87558: LD_INT 0
87560: PPUSH
87561: CALL_OW 1
87565: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
87566: LD_ADDR_EXP 202
87570: PUSH
87571: LD_EXP 202
87575: PPUSH
87576: LD_VAR 0 2
87580: PPUSH
87581: LD_INT 0
87583: PPUSH
87584: CALL_OW 1
87588: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
87589: LD_ADDR_EXP 190
87593: PUSH
87594: LD_EXP 190
87598: PPUSH
87599: LD_VAR 0 2
87603: PPUSH
87604: EMPTY
87605: PPUSH
87606: CALL_OW 1
87610: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
87611: LD_ADDR_EXP 201
87615: PUSH
87616: LD_EXP 201
87620: PPUSH
87621: LD_VAR 0 2
87625: PPUSH
87626: LD_INT 0
87628: PPUSH
87629: CALL_OW 1
87633: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
87634: LD_ADDR_EXP 203
87638: PUSH
87639: LD_EXP 203
87643: PPUSH
87644: LD_VAR 0 2
87648: PPUSH
87649: EMPTY
87650: PPUSH
87651: CALL_OW 1
87655: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
87656: LD_ADDR_EXP 206
87660: PUSH
87661: LD_EXP 206
87665: PPUSH
87666: LD_VAR 0 2
87670: PPUSH
87671: LD_INT 0
87673: PPUSH
87674: CALL_OW 1
87678: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
87679: LD_ADDR_EXP 207
87683: PUSH
87684: LD_EXP 207
87688: PPUSH
87689: LD_VAR 0 2
87693: PPUSH
87694: EMPTY
87695: PPUSH
87696: CALL_OW 1
87700: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
87701: LD_ADDR_EXP 208
87705: PUSH
87706: LD_EXP 208
87710: PPUSH
87711: LD_VAR 0 2
87715: PPUSH
87716: EMPTY
87717: PPUSH
87718: CALL_OW 1
87722: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
87723: LD_ADDR_EXP 209
87727: PUSH
87728: LD_EXP 209
87732: PPUSH
87733: LD_VAR 0 2
87737: PPUSH
87738: EMPTY
87739: PPUSH
87740: CALL_OW 1
87744: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
87745: LD_ADDR_EXP 211
87749: PUSH
87750: LD_EXP 211
87754: PPUSH
87755: LD_VAR 0 2
87759: PPUSH
87760: LD_EXP 178
87764: PUSH
87765: LD_VAR 0 2
87769: ARRAY
87770: PPUSH
87771: LD_INT 2
87773: PUSH
87774: LD_INT 30
87776: PUSH
87777: LD_INT 6
87779: PUSH
87780: EMPTY
87781: LIST
87782: LIST
87783: PUSH
87784: LD_INT 30
87786: PUSH
87787: LD_INT 7
87789: PUSH
87790: EMPTY
87791: LIST
87792: LIST
87793: PUSH
87794: LD_INT 30
87796: PUSH
87797: LD_INT 8
87799: PUSH
87800: EMPTY
87801: LIST
87802: LIST
87803: PUSH
87804: EMPTY
87805: LIST
87806: LIST
87807: LIST
87808: LIST
87809: PPUSH
87810: CALL_OW 72
87814: PPUSH
87815: CALL_OW 1
87819: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
87820: LD_ADDR_EXP 212
87824: PUSH
87825: LD_EXP 212
87829: PPUSH
87830: LD_VAR 0 2
87834: PPUSH
87835: EMPTY
87836: PPUSH
87837: CALL_OW 1
87841: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
87842: LD_ADDR_EXP 213
87846: PUSH
87847: LD_EXP 213
87851: PPUSH
87852: LD_VAR 0 2
87856: PPUSH
87857: EMPTY
87858: PPUSH
87859: CALL_OW 1
87863: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
87864: LD_ADDR_EXP 214
87868: PUSH
87869: LD_EXP 214
87873: PPUSH
87874: LD_VAR 0 2
87878: PPUSH
87879: EMPTY
87880: PPUSH
87881: CALL_OW 1
87885: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
87886: LD_ADDR_EXP 215
87890: PUSH
87891: LD_EXP 215
87895: PPUSH
87896: LD_VAR 0 2
87900: PPUSH
87901: EMPTY
87902: PPUSH
87903: CALL_OW 1
87907: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
87908: LD_ADDR_EXP 216
87912: PUSH
87913: LD_EXP 216
87917: PPUSH
87918: LD_VAR 0 2
87922: PPUSH
87923: EMPTY
87924: PPUSH
87925: CALL_OW 1
87929: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
87930: LD_ADDR_EXP 217
87934: PUSH
87935: LD_EXP 217
87939: PPUSH
87940: LD_VAR 0 2
87944: PPUSH
87945: EMPTY
87946: PPUSH
87947: CALL_OW 1
87951: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
87952: LD_ADDR_EXP 218
87956: PUSH
87957: LD_EXP 218
87961: PPUSH
87962: LD_VAR 0 2
87966: PPUSH
87967: EMPTY
87968: PPUSH
87969: CALL_OW 1
87973: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
87974: LD_ADDR_EXP 219
87978: PUSH
87979: LD_EXP 219
87983: PPUSH
87984: LD_VAR 0 2
87988: PPUSH
87989: EMPTY
87990: PPUSH
87991: CALL_OW 1
87995: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
87996: LD_ADDR_EXP 220
88000: PUSH
88001: LD_EXP 220
88005: PPUSH
88006: LD_VAR 0 2
88010: PPUSH
88011: LD_INT 0
88013: PPUSH
88014: CALL_OW 1
88018: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
88019: LD_ADDR_EXP 221
88023: PUSH
88024: LD_EXP 221
88028: PPUSH
88029: LD_VAR 0 2
88033: PPUSH
88034: LD_INT 0
88036: PPUSH
88037: CALL_OW 1
88041: ST_TO_ADDR
// end ;
88042: GO 86943
88044: POP
88045: POP
// MC_InitSides ( ) ;
88046: CALL 88332 0 0
// MC_InitResearch ( ) ;
88050: CALL 88071 0 0
// CustomInitMacro ( ) ;
88054: CALL 350 0 0
// skirmish := true ;
88058: LD_ADDR_EXP 176
88062: PUSH
88063: LD_INT 1
88065: ST_TO_ADDR
// end ;
88066: LD_VAR 0 1
88070: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
88071: LD_INT 0
88073: PPUSH
88074: PPUSH
88075: PPUSH
88076: PPUSH
88077: PPUSH
88078: PPUSH
// if not mc_bases then
88079: LD_EXP 178
88083: NOT
88084: IFFALSE 88088
// exit ;
88086: GO 88327
// for i = 1 to 8 do
88088: LD_ADDR_VAR 0 2
88092: PUSH
88093: DOUBLE
88094: LD_INT 1
88096: DEC
88097: ST_TO_ADDR
88098: LD_INT 8
88100: PUSH
88101: FOR_TO
88102: IFFALSE 88128
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
88104: LD_ADDR_EXP 205
88108: PUSH
88109: LD_EXP 205
88113: PPUSH
88114: LD_VAR 0 2
88118: PPUSH
88119: EMPTY
88120: PPUSH
88121: CALL_OW 1
88125: ST_TO_ADDR
88126: GO 88101
88128: POP
88129: POP
// tmp := [ ] ;
88130: LD_ADDR_VAR 0 5
88134: PUSH
88135: EMPTY
88136: ST_TO_ADDR
// for i = 1 to mc_sides do
88137: LD_ADDR_VAR 0 2
88141: PUSH
88142: DOUBLE
88143: LD_INT 1
88145: DEC
88146: ST_TO_ADDR
88147: LD_EXP 204
88151: PUSH
88152: FOR_TO
88153: IFFALSE 88211
// if not mc_sides [ i ] in tmp then
88155: LD_EXP 204
88159: PUSH
88160: LD_VAR 0 2
88164: ARRAY
88165: PUSH
88166: LD_VAR 0 5
88170: IN
88171: NOT
88172: IFFALSE 88209
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
88174: LD_ADDR_VAR 0 5
88178: PUSH
88179: LD_VAR 0 5
88183: PPUSH
88184: LD_VAR 0 5
88188: PUSH
88189: LD_INT 1
88191: PLUS
88192: PPUSH
88193: LD_EXP 204
88197: PUSH
88198: LD_VAR 0 2
88202: ARRAY
88203: PPUSH
88204: CALL_OW 2
88208: ST_TO_ADDR
88209: GO 88152
88211: POP
88212: POP
// if not tmp then
88213: LD_VAR 0 5
88217: NOT
88218: IFFALSE 88222
// exit ;
88220: GO 88327
// for j in tmp do
88222: LD_ADDR_VAR 0 3
88226: PUSH
88227: LD_VAR 0 5
88231: PUSH
88232: FOR_IN
88233: IFFALSE 88325
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
88235: LD_ADDR_VAR 0 6
88239: PUSH
88240: LD_INT 22
88242: PUSH
88243: LD_VAR 0 3
88247: PUSH
88248: EMPTY
88249: LIST
88250: LIST
88251: PPUSH
88252: CALL_OW 69
88256: ST_TO_ADDR
// if not un then
88257: LD_VAR 0 6
88261: NOT
88262: IFFALSE 88266
// continue ;
88264: GO 88232
// nation := GetNation ( un [ 1 ] ) ;
88266: LD_ADDR_VAR 0 4
88270: PUSH
88271: LD_VAR 0 6
88275: PUSH
88276: LD_INT 1
88278: ARRAY
88279: PPUSH
88280: CALL_OW 248
88284: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
88285: LD_ADDR_EXP 205
88289: PUSH
88290: LD_EXP 205
88294: PPUSH
88295: LD_VAR 0 3
88299: PPUSH
88300: LD_VAR 0 3
88304: PPUSH
88305: LD_VAR 0 4
88309: PPUSH
88310: LD_INT 1
88312: PPUSH
88313: CALL 19287 0 3
88317: PPUSH
88318: CALL_OW 1
88322: ST_TO_ADDR
// end ;
88323: GO 88232
88325: POP
88326: POP
// end ;
88327: LD_VAR 0 1
88331: RET
// export function MC_InitSides ( ) ; var i ; begin
88332: LD_INT 0
88334: PPUSH
88335: PPUSH
// if not mc_bases then
88336: LD_EXP 178
88340: NOT
88341: IFFALSE 88345
// exit ;
88343: GO 88419
// for i = 1 to mc_bases do
88345: LD_ADDR_VAR 0 2
88349: PUSH
88350: DOUBLE
88351: LD_INT 1
88353: DEC
88354: ST_TO_ADDR
88355: LD_EXP 178
88359: PUSH
88360: FOR_TO
88361: IFFALSE 88417
// if mc_bases [ i ] then
88363: LD_EXP 178
88367: PUSH
88368: LD_VAR 0 2
88372: ARRAY
88373: IFFALSE 88415
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
88375: LD_ADDR_EXP 204
88379: PUSH
88380: LD_EXP 204
88384: PPUSH
88385: LD_VAR 0 2
88389: PPUSH
88390: LD_EXP 178
88394: PUSH
88395: LD_VAR 0 2
88399: ARRAY
88400: PUSH
88401: LD_INT 1
88403: ARRAY
88404: PPUSH
88405: CALL_OW 255
88409: PPUSH
88410: CALL_OW 1
88414: ST_TO_ADDR
88415: GO 88360
88417: POP
88418: POP
// end ;
88419: LD_VAR 0 1
88423: RET
// every 0 0$03 trigger skirmish do
88424: LD_EXP 176
88428: IFFALSE 88582
88430: GO 88432
88432: DISABLE
// begin enable ;
88433: ENABLE
// MC_CheckBuildings ( ) ;
88434: CALL 93080 0 0
// MC_CheckPeopleLife ( ) ;
88438: CALL 93241 0 0
// RaiseSailEvent ( 100 ) ;
88442: LD_INT 100
88444: PPUSH
88445: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
88449: LD_INT 103
88451: PPUSH
88452: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
88456: LD_INT 104
88458: PPUSH
88459: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
88463: LD_INT 105
88465: PPUSH
88466: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
88470: LD_INT 106
88472: PPUSH
88473: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
88477: LD_INT 107
88479: PPUSH
88480: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
88484: LD_INT 108
88486: PPUSH
88487: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
88491: LD_INT 109
88493: PPUSH
88494: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
88498: LD_INT 110
88500: PPUSH
88501: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
88505: LD_INT 111
88507: PPUSH
88508: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
88512: LD_INT 112
88514: PPUSH
88515: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
88519: LD_INT 113
88521: PPUSH
88522: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
88526: LD_INT 120
88528: PPUSH
88529: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
88533: LD_INT 121
88535: PPUSH
88536: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
88540: LD_INT 122
88542: PPUSH
88543: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
88547: LD_INT 123
88549: PPUSH
88550: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
88554: LD_INT 124
88556: PPUSH
88557: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
88561: LD_INT 125
88563: PPUSH
88564: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
88568: LD_INT 126
88570: PPUSH
88571: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
88575: LD_INT 200
88577: PPUSH
88578: CALL_OW 427
// end ;
88582: END
// on SailEvent ( event ) do begin if event < 100 then
88583: LD_VAR 0 1
88587: PUSH
88588: LD_INT 100
88590: LESS
88591: IFFALSE 88602
// CustomEvent ( event ) ;
88593: LD_VAR 0 1
88597: PPUSH
88598: CALL 16158 0 1
// if event = 100 then
88602: LD_VAR 0 1
88606: PUSH
88607: LD_INT 100
88609: EQUAL
88610: IFFALSE 88616
// MC_ClassManager ( ) ;
88612: CALL 89008 0 0
// if event = 101 then
88616: LD_VAR 0 1
88620: PUSH
88621: LD_INT 101
88623: EQUAL
88624: IFFALSE 88630
// MC_RepairBuildings ( ) ;
88626: CALL 93826 0 0
// if event = 102 then
88630: LD_VAR 0 1
88634: PUSH
88635: LD_INT 102
88637: EQUAL
88638: IFFALSE 88644
// MC_Heal ( ) ;
88640: CALL 94733 0 0
// if event = 103 then
88644: LD_VAR 0 1
88648: PUSH
88649: LD_INT 103
88651: EQUAL
88652: IFFALSE 88658
// MC_Build ( ) ;
88654: CALL 95155 0 0
// if event = 104 then
88658: LD_VAR 0 1
88662: PUSH
88663: LD_INT 104
88665: EQUAL
88666: IFFALSE 88672
// MC_TurretWeapon ( ) ;
88668: CALL 96796 0 0
// if event = 105 then
88672: LD_VAR 0 1
88676: PUSH
88677: LD_INT 105
88679: EQUAL
88680: IFFALSE 88686
// MC_BuildUpgrade ( ) ;
88682: CALL 96347 0 0
// if event = 106 then
88686: LD_VAR 0 1
88690: PUSH
88691: LD_INT 106
88693: EQUAL
88694: IFFALSE 88700
// MC_PlantMines ( ) ;
88696: CALL 97226 0 0
// if event = 107 then
88700: LD_VAR 0 1
88704: PUSH
88705: LD_INT 107
88707: EQUAL
88708: IFFALSE 88714
// MC_CollectCrates ( ) ;
88710: CALL 98017 0 0
// if event = 108 then
88714: LD_VAR 0 1
88718: PUSH
88719: LD_INT 108
88721: EQUAL
88722: IFFALSE 88728
// MC_LinkRemoteControl ( ) ;
88724: CALL 99867 0 0
// if event = 109 then
88728: LD_VAR 0 1
88732: PUSH
88733: LD_INT 109
88735: EQUAL
88736: IFFALSE 88742
// MC_ProduceVehicle ( ) ;
88738: CALL 100048 0 0
// if event = 110 then
88742: LD_VAR 0 1
88746: PUSH
88747: LD_INT 110
88749: EQUAL
88750: IFFALSE 88756
// MC_SendAttack ( ) ;
88752: CALL 100514 0 0
// if event = 111 then
88756: LD_VAR 0 1
88760: PUSH
88761: LD_INT 111
88763: EQUAL
88764: IFFALSE 88770
// MC_Defend ( ) ;
88766: CALL 100622 0 0
// if event = 112 then
88770: LD_VAR 0 1
88774: PUSH
88775: LD_INT 112
88777: EQUAL
88778: IFFALSE 88784
// MC_Research ( ) ;
88780: CALL 101502 0 0
// if event = 113 then
88784: LD_VAR 0 1
88788: PUSH
88789: LD_INT 113
88791: EQUAL
88792: IFFALSE 88798
// MC_MinesTrigger ( ) ;
88794: CALL 102616 0 0
// if event = 120 then
88798: LD_VAR 0 1
88802: PUSH
88803: LD_INT 120
88805: EQUAL
88806: IFFALSE 88812
// MC_RepairVehicle ( ) ;
88808: CALL 102715 0 0
// if event = 121 then
88812: LD_VAR 0 1
88816: PUSH
88817: LD_INT 121
88819: EQUAL
88820: IFFALSE 88826
// MC_TameApe ( ) ;
88822: CALL 103456 0 0
// if event = 122 then
88826: LD_VAR 0 1
88830: PUSH
88831: LD_INT 122
88833: EQUAL
88834: IFFALSE 88840
// MC_ChangeApeClass ( ) ;
88836: CALL 104285 0 0
// if event = 123 then
88840: LD_VAR 0 1
88844: PUSH
88845: LD_INT 123
88847: EQUAL
88848: IFFALSE 88854
// MC_Bazooka ( ) ;
88850: CALL 104935 0 0
// if event = 124 then
88854: LD_VAR 0 1
88858: PUSH
88859: LD_INT 124
88861: EQUAL
88862: IFFALSE 88868
// MC_TeleportExit ( ) ;
88864: CALL 105133 0 0
// if event = 125 then
88868: LD_VAR 0 1
88872: PUSH
88873: LD_INT 125
88875: EQUAL
88876: IFFALSE 88882
// MC_Deposits ( ) ;
88878: CALL 105780 0 0
// if event = 126 then
88882: LD_VAR 0 1
88886: PUSH
88887: LD_INT 126
88889: EQUAL
88890: IFFALSE 88896
// MC_RemoteDriver ( ) ;
88892: CALL 106405 0 0
// if event = 200 then
88896: LD_VAR 0 1
88900: PUSH
88901: LD_INT 200
88903: EQUAL
88904: IFFALSE 88910
// MC_Idle ( ) ;
88906: CALL 108354 0 0
// end ;
88910: PPOPN 1
88912: END
// export function MC_Reset ( base , tag ) ; var i ; begin
88913: LD_INT 0
88915: PPUSH
88916: PPUSH
// if not mc_bases [ base ] or not tag then
88917: LD_EXP 178
88921: PUSH
88922: LD_VAR 0 1
88926: ARRAY
88927: NOT
88928: PUSH
88929: LD_VAR 0 2
88933: NOT
88934: OR
88935: IFFALSE 88939
// exit ;
88937: GO 89003
// for i in mc_bases [ base ] union mc_ape [ base ] do
88939: LD_ADDR_VAR 0 4
88943: PUSH
88944: LD_EXP 178
88948: PUSH
88949: LD_VAR 0 1
88953: ARRAY
88954: PUSH
88955: LD_EXP 207
88959: PUSH
88960: LD_VAR 0 1
88964: ARRAY
88965: UNION
88966: PUSH
88967: FOR_IN
88968: IFFALSE 89001
// if GetTag ( i ) = tag then
88970: LD_VAR 0 4
88974: PPUSH
88975: CALL_OW 110
88979: PUSH
88980: LD_VAR 0 2
88984: EQUAL
88985: IFFALSE 88999
// SetTag ( i , 0 ) ;
88987: LD_VAR 0 4
88991: PPUSH
88992: LD_INT 0
88994: PPUSH
88995: CALL_OW 109
88999: GO 88967
89001: POP
89002: POP
// end ;
89003: LD_VAR 0 3
89007: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
89008: LD_INT 0
89010: PPUSH
89011: PPUSH
89012: PPUSH
89013: PPUSH
89014: PPUSH
89015: PPUSH
89016: PPUSH
89017: PPUSH
// if not mc_bases then
89018: LD_EXP 178
89022: NOT
89023: IFFALSE 89027
// exit ;
89025: GO 89485
// for i = 1 to mc_bases do
89027: LD_ADDR_VAR 0 2
89031: PUSH
89032: DOUBLE
89033: LD_INT 1
89035: DEC
89036: ST_TO_ADDR
89037: LD_EXP 178
89041: PUSH
89042: FOR_TO
89043: IFFALSE 89483
// begin tmp := MC_ClassCheckReq ( i ) ;
89045: LD_ADDR_VAR 0 4
89049: PUSH
89050: LD_VAR 0 2
89054: PPUSH
89055: CALL 89490 0 1
89059: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
89060: LD_ADDR_EXP 219
89064: PUSH
89065: LD_EXP 219
89069: PPUSH
89070: LD_VAR 0 2
89074: PPUSH
89075: LD_VAR 0 4
89079: PPUSH
89080: CALL_OW 1
89084: ST_TO_ADDR
// if not tmp then
89085: LD_VAR 0 4
89089: NOT
89090: IFFALSE 89094
// continue ;
89092: GO 89042
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
89094: LD_ADDR_VAR 0 6
89098: PUSH
89099: LD_EXP 178
89103: PUSH
89104: LD_VAR 0 2
89108: ARRAY
89109: PPUSH
89110: LD_INT 2
89112: PUSH
89113: LD_INT 30
89115: PUSH
89116: LD_INT 4
89118: PUSH
89119: EMPTY
89120: LIST
89121: LIST
89122: PUSH
89123: LD_INT 30
89125: PUSH
89126: LD_INT 5
89128: PUSH
89129: EMPTY
89130: LIST
89131: LIST
89132: PUSH
89133: EMPTY
89134: LIST
89135: LIST
89136: LIST
89137: PPUSH
89138: CALL_OW 72
89142: PUSH
89143: LD_EXP 178
89147: PUSH
89148: LD_VAR 0 2
89152: ARRAY
89153: PPUSH
89154: LD_INT 2
89156: PUSH
89157: LD_INT 30
89159: PUSH
89160: LD_INT 0
89162: PUSH
89163: EMPTY
89164: LIST
89165: LIST
89166: PUSH
89167: LD_INT 30
89169: PUSH
89170: LD_INT 1
89172: PUSH
89173: EMPTY
89174: LIST
89175: LIST
89176: PUSH
89177: EMPTY
89178: LIST
89179: LIST
89180: LIST
89181: PPUSH
89182: CALL_OW 72
89186: PUSH
89187: LD_EXP 178
89191: PUSH
89192: LD_VAR 0 2
89196: ARRAY
89197: PPUSH
89198: LD_INT 30
89200: PUSH
89201: LD_INT 3
89203: PUSH
89204: EMPTY
89205: LIST
89206: LIST
89207: PPUSH
89208: CALL_OW 72
89212: PUSH
89213: LD_EXP 178
89217: PUSH
89218: LD_VAR 0 2
89222: ARRAY
89223: PPUSH
89224: LD_INT 2
89226: PUSH
89227: LD_INT 30
89229: PUSH
89230: LD_INT 6
89232: PUSH
89233: EMPTY
89234: LIST
89235: LIST
89236: PUSH
89237: LD_INT 30
89239: PUSH
89240: LD_INT 7
89242: PUSH
89243: EMPTY
89244: LIST
89245: LIST
89246: PUSH
89247: LD_INT 30
89249: PUSH
89250: LD_INT 8
89252: PUSH
89253: EMPTY
89254: LIST
89255: LIST
89256: PUSH
89257: EMPTY
89258: LIST
89259: LIST
89260: LIST
89261: LIST
89262: PPUSH
89263: CALL_OW 72
89267: PUSH
89268: EMPTY
89269: LIST
89270: LIST
89271: LIST
89272: LIST
89273: ST_TO_ADDR
// for j = 1 to 4 do
89274: LD_ADDR_VAR 0 3
89278: PUSH
89279: DOUBLE
89280: LD_INT 1
89282: DEC
89283: ST_TO_ADDR
89284: LD_INT 4
89286: PUSH
89287: FOR_TO
89288: IFFALSE 89479
// begin if not tmp [ j ] then
89290: LD_VAR 0 4
89294: PUSH
89295: LD_VAR 0 3
89299: ARRAY
89300: NOT
89301: IFFALSE 89305
// continue ;
89303: GO 89287
// for p in tmp [ j ] do
89305: LD_ADDR_VAR 0 5
89309: PUSH
89310: LD_VAR 0 4
89314: PUSH
89315: LD_VAR 0 3
89319: ARRAY
89320: PUSH
89321: FOR_IN
89322: IFFALSE 89475
// begin if not b [ j ] then
89324: LD_VAR 0 6
89328: PUSH
89329: LD_VAR 0 3
89333: ARRAY
89334: NOT
89335: IFFALSE 89339
// break ;
89337: GO 89475
// e := 0 ;
89339: LD_ADDR_VAR 0 7
89343: PUSH
89344: LD_INT 0
89346: ST_TO_ADDR
// for k in b [ j ] do
89347: LD_ADDR_VAR 0 8
89351: PUSH
89352: LD_VAR 0 6
89356: PUSH
89357: LD_VAR 0 3
89361: ARRAY
89362: PUSH
89363: FOR_IN
89364: IFFALSE 89391
// if IsNotFull ( k ) then
89366: LD_VAR 0 8
89370: PPUSH
89371: CALL 21440 0 1
89375: IFFALSE 89389
// begin e := k ;
89377: LD_ADDR_VAR 0 7
89381: PUSH
89382: LD_VAR 0 8
89386: ST_TO_ADDR
// break ;
89387: GO 89391
// end ;
89389: GO 89363
89391: POP
89392: POP
// if e and not UnitGoingToBuilding ( p , e ) then
89393: LD_VAR 0 7
89397: PUSH
89398: LD_VAR 0 5
89402: PPUSH
89403: LD_VAR 0 7
89407: PPUSH
89408: CALL 54604 0 2
89412: NOT
89413: AND
89414: IFFALSE 89473
// begin if IsInUnit ( p ) then
89416: LD_VAR 0 5
89420: PPUSH
89421: CALL_OW 310
89425: IFFALSE 89436
// ComExitBuilding ( p ) ;
89427: LD_VAR 0 5
89431: PPUSH
89432: CALL_OW 122
// ComEnterUnit ( p , e ) ;
89436: LD_VAR 0 5
89440: PPUSH
89441: LD_VAR 0 7
89445: PPUSH
89446: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
89450: LD_VAR 0 5
89454: PPUSH
89455: LD_VAR 0 3
89459: PPUSH
89460: CALL_OW 183
// AddComExitBuilding ( p ) ;
89464: LD_VAR 0 5
89468: PPUSH
89469: CALL_OW 182
// end ; end ;
89473: GO 89321
89475: POP
89476: POP
// end ;
89477: GO 89287
89479: POP
89480: POP
// end ;
89481: GO 89042
89483: POP
89484: POP
// end ;
89485: LD_VAR 0 1
89489: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
89490: LD_INT 0
89492: PPUSH
89493: PPUSH
89494: PPUSH
89495: PPUSH
89496: PPUSH
89497: PPUSH
89498: PPUSH
89499: PPUSH
89500: PPUSH
89501: PPUSH
89502: PPUSH
89503: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
89504: LD_VAR 0 1
89508: NOT
89509: PUSH
89510: LD_EXP 178
89514: PUSH
89515: LD_VAR 0 1
89519: ARRAY
89520: NOT
89521: OR
89522: PUSH
89523: LD_EXP 178
89527: PUSH
89528: LD_VAR 0 1
89532: ARRAY
89533: PPUSH
89534: LD_INT 2
89536: PUSH
89537: LD_INT 30
89539: PUSH
89540: LD_INT 0
89542: PUSH
89543: EMPTY
89544: LIST
89545: LIST
89546: PUSH
89547: LD_INT 30
89549: PUSH
89550: LD_INT 1
89552: PUSH
89553: EMPTY
89554: LIST
89555: LIST
89556: PUSH
89557: EMPTY
89558: LIST
89559: LIST
89560: LIST
89561: PPUSH
89562: CALL_OW 72
89566: NOT
89567: OR
89568: IFFALSE 89572
// exit ;
89570: GO 93075
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
89572: LD_ADDR_VAR 0 4
89576: PUSH
89577: LD_EXP 178
89581: PUSH
89582: LD_VAR 0 1
89586: ARRAY
89587: PPUSH
89588: LD_INT 2
89590: PUSH
89591: LD_INT 25
89593: PUSH
89594: LD_INT 1
89596: PUSH
89597: EMPTY
89598: LIST
89599: LIST
89600: PUSH
89601: LD_INT 25
89603: PUSH
89604: LD_INT 2
89606: PUSH
89607: EMPTY
89608: LIST
89609: LIST
89610: PUSH
89611: LD_INT 25
89613: PUSH
89614: LD_INT 3
89616: PUSH
89617: EMPTY
89618: LIST
89619: LIST
89620: PUSH
89621: LD_INT 25
89623: PUSH
89624: LD_INT 4
89626: PUSH
89627: EMPTY
89628: LIST
89629: LIST
89630: PUSH
89631: LD_INT 25
89633: PUSH
89634: LD_INT 5
89636: PUSH
89637: EMPTY
89638: LIST
89639: LIST
89640: PUSH
89641: LD_INT 25
89643: PUSH
89644: LD_INT 8
89646: PUSH
89647: EMPTY
89648: LIST
89649: LIST
89650: PUSH
89651: LD_INT 25
89653: PUSH
89654: LD_INT 9
89656: PUSH
89657: EMPTY
89658: LIST
89659: LIST
89660: PUSH
89661: EMPTY
89662: LIST
89663: LIST
89664: LIST
89665: LIST
89666: LIST
89667: LIST
89668: LIST
89669: LIST
89670: PPUSH
89671: CALL_OW 72
89675: ST_TO_ADDR
// if not tmp then
89676: LD_VAR 0 4
89680: NOT
89681: IFFALSE 89685
// exit ;
89683: GO 93075
// for i in tmp do
89685: LD_ADDR_VAR 0 3
89689: PUSH
89690: LD_VAR 0 4
89694: PUSH
89695: FOR_IN
89696: IFFALSE 89727
// if GetTag ( i ) then
89698: LD_VAR 0 3
89702: PPUSH
89703: CALL_OW 110
89707: IFFALSE 89725
// tmp := tmp diff i ;
89709: LD_ADDR_VAR 0 4
89713: PUSH
89714: LD_VAR 0 4
89718: PUSH
89719: LD_VAR 0 3
89723: DIFF
89724: ST_TO_ADDR
89725: GO 89695
89727: POP
89728: POP
// if not tmp then
89729: LD_VAR 0 4
89733: NOT
89734: IFFALSE 89738
// exit ;
89736: GO 93075
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
89738: LD_ADDR_VAR 0 5
89742: PUSH
89743: LD_EXP 178
89747: PUSH
89748: LD_VAR 0 1
89752: ARRAY
89753: PPUSH
89754: LD_INT 2
89756: PUSH
89757: LD_INT 25
89759: PUSH
89760: LD_INT 1
89762: PUSH
89763: EMPTY
89764: LIST
89765: LIST
89766: PUSH
89767: LD_INT 25
89769: PUSH
89770: LD_INT 5
89772: PUSH
89773: EMPTY
89774: LIST
89775: LIST
89776: PUSH
89777: LD_INT 25
89779: PUSH
89780: LD_INT 8
89782: PUSH
89783: EMPTY
89784: LIST
89785: LIST
89786: PUSH
89787: LD_INT 25
89789: PUSH
89790: LD_INT 9
89792: PUSH
89793: EMPTY
89794: LIST
89795: LIST
89796: PUSH
89797: EMPTY
89798: LIST
89799: LIST
89800: LIST
89801: LIST
89802: LIST
89803: PPUSH
89804: CALL_OW 72
89808: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
89809: LD_ADDR_VAR 0 6
89813: PUSH
89814: LD_EXP 178
89818: PUSH
89819: LD_VAR 0 1
89823: ARRAY
89824: PPUSH
89825: LD_INT 25
89827: PUSH
89828: LD_INT 2
89830: PUSH
89831: EMPTY
89832: LIST
89833: LIST
89834: PPUSH
89835: CALL_OW 72
89839: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
89840: LD_ADDR_VAR 0 7
89844: PUSH
89845: LD_EXP 178
89849: PUSH
89850: LD_VAR 0 1
89854: ARRAY
89855: PPUSH
89856: LD_INT 25
89858: PUSH
89859: LD_INT 3
89861: PUSH
89862: EMPTY
89863: LIST
89864: LIST
89865: PPUSH
89866: CALL_OW 72
89870: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
89871: LD_ADDR_VAR 0 8
89875: PUSH
89876: LD_EXP 178
89880: PUSH
89881: LD_VAR 0 1
89885: ARRAY
89886: PPUSH
89887: LD_INT 25
89889: PUSH
89890: LD_INT 4
89892: PUSH
89893: EMPTY
89894: LIST
89895: LIST
89896: PUSH
89897: LD_INT 24
89899: PUSH
89900: LD_INT 251
89902: PUSH
89903: EMPTY
89904: LIST
89905: LIST
89906: PUSH
89907: EMPTY
89908: LIST
89909: LIST
89910: PPUSH
89911: CALL_OW 72
89915: ST_TO_ADDR
// if mc_is_defending [ base ] then
89916: LD_EXP 221
89920: PUSH
89921: LD_VAR 0 1
89925: ARRAY
89926: IFFALSE 90387
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
89928: LD_ADDR_EXP 220
89932: PUSH
89933: LD_EXP 220
89937: PPUSH
89938: LD_VAR 0 1
89942: PPUSH
89943: LD_INT 4
89945: PPUSH
89946: CALL_OW 1
89950: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
89951: LD_ADDR_VAR 0 12
89955: PUSH
89956: LD_EXP 178
89960: PUSH
89961: LD_VAR 0 1
89965: ARRAY
89966: PPUSH
89967: LD_INT 2
89969: PUSH
89970: LD_INT 30
89972: PUSH
89973: LD_INT 4
89975: PUSH
89976: EMPTY
89977: LIST
89978: LIST
89979: PUSH
89980: LD_INT 30
89982: PUSH
89983: LD_INT 5
89985: PUSH
89986: EMPTY
89987: LIST
89988: LIST
89989: PUSH
89990: EMPTY
89991: LIST
89992: LIST
89993: LIST
89994: PPUSH
89995: CALL_OW 72
89999: ST_TO_ADDR
// if not b then
90000: LD_VAR 0 12
90004: NOT
90005: IFFALSE 90009
// exit ;
90007: GO 93075
// p := [ ] ;
90009: LD_ADDR_VAR 0 11
90013: PUSH
90014: EMPTY
90015: ST_TO_ADDR
// if sci >= 2 then
90016: LD_VAR 0 8
90020: PUSH
90021: LD_INT 2
90023: GREATEREQUAL
90024: IFFALSE 90055
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
90026: LD_ADDR_VAR 0 8
90030: PUSH
90031: LD_VAR 0 8
90035: PUSH
90036: LD_INT 1
90038: ARRAY
90039: PUSH
90040: LD_VAR 0 8
90044: PUSH
90045: LD_INT 2
90047: ARRAY
90048: PUSH
90049: EMPTY
90050: LIST
90051: LIST
90052: ST_TO_ADDR
90053: GO 90116
// if sci = 1 then
90055: LD_VAR 0 8
90059: PUSH
90060: LD_INT 1
90062: EQUAL
90063: IFFALSE 90084
// sci := [ sci [ 1 ] ] else
90065: LD_ADDR_VAR 0 8
90069: PUSH
90070: LD_VAR 0 8
90074: PUSH
90075: LD_INT 1
90077: ARRAY
90078: PUSH
90079: EMPTY
90080: LIST
90081: ST_TO_ADDR
90082: GO 90116
// if sci = 0 then
90084: LD_VAR 0 8
90088: PUSH
90089: LD_INT 0
90091: EQUAL
90092: IFFALSE 90116
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
90094: LD_ADDR_VAR 0 11
90098: PUSH
90099: LD_VAR 0 4
90103: PPUSH
90104: LD_INT 4
90106: PPUSH
90107: CALL 54467 0 2
90111: PUSH
90112: LD_INT 1
90114: ARRAY
90115: ST_TO_ADDR
// if eng > 4 then
90116: LD_VAR 0 6
90120: PUSH
90121: LD_INT 4
90123: GREATER
90124: IFFALSE 90170
// for i = eng downto 4 do
90126: LD_ADDR_VAR 0 3
90130: PUSH
90131: DOUBLE
90132: LD_VAR 0 6
90136: INC
90137: ST_TO_ADDR
90138: LD_INT 4
90140: PUSH
90141: FOR_DOWNTO
90142: IFFALSE 90168
// eng := eng diff eng [ i ] ;
90144: LD_ADDR_VAR 0 6
90148: PUSH
90149: LD_VAR 0 6
90153: PUSH
90154: LD_VAR 0 6
90158: PUSH
90159: LD_VAR 0 3
90163: ARRAY
90164: DIFF
90165: ST_TO_ADDR
90166: GO 90141
90168: POP
90169: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
90170: LD_ADDR_VAR 0 4
90174: PUSH
90175: LD_VAR 0 4
90179: PUSH
90180: LD_VAR 0 5
90184: PUSH
90185: LD_VAR 0 6
90189: UNION
90190: PUSH
90191: LD_VAR 0 7
90195: UNION
90196: PUSH
90197: LD_VAR 0 8
90201: UNION
90202: DIFF
90203: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
90204: LD_ADDR_VAR 0 13
90208: PUSH
90209: LD_EXP 178
90213: PUSH
90214: LD_VAR 0 1
90218: ARRAY
90219: PPUSH
90220: LD_INT 2
90222: PUSH
90223: LD_INT 30
90225: PUSH
90226: LD_INT 32
90228: PUSH
90229: EMPTY
90230: LIST
90231: LIST
90232: PUSH
90233: LD_INT 30
90235: PUSH
90236: LD_INT 31
90238: PUSH
90239: EMPTY
90240: LIST
90241: LIST
90242: PUSH
90243: EMPTY
90244: LIST
90245: LIST
90246: LIST
90247: PPUSH
90248: CALL_OW 72
90252: PUSH
90253: LD_EXP 178
90257: PUSH
90258: LD_VAR 0 1
90262: ARRAY
90263: PPUSH
90264: LD_INT 2
90266: PUSH
90267: LD_INT 30
90269: PUSH
90270: LD_INT 4
90272: PUSH
90273: EMPTY
90274: LIST
90275: LIST
90276: PUSH
90277: LD_INT 30
90279: PUSH
90280: LD_INT 5
90282: PUSH
90283: EMPTY
90284: LIST
90285: LIST
90286: PUSH
90287: EMPTY
90288: LIST
90289: LIST
90290: LIST
90291: PPUSH
90292: CALL_OW 72
90296: PUSH
90297: LD_INT 6
90299: MUL
90300: PLUS
90301: ST_TO_ADDR
// if bcount < tmp then
90302: LD_VAR 0 13
90306: PUSH
90307: LD_VAR 0 4
90311: LESS
90312: IFFALSE 90358
// for i = tmp downto bcount do
90314: LD_ADDR_VAR 0 3
90318: PUSH
90319: DOUBLE
90320: LD_VAR 0 4
90324: INC
90325: ST_TO_ADDR
90326: LD_VAR 0 13
90330: PUSH
90331: FOR_DOWNTO
90332: IFFALSE 90356
// tmp := Delete ( tmp , tmp ) ;
90334: LD_ADDR_VAR 0 4
90338: PUSH
90339: LD_VAR 0 4
90343: PPUSH
90344: LD_VAR 0 4
90348: PPUSH
90349: CALL_OW 3
90353: ST_TO_ADDR
90354: GO 90331
90356: POP
90357: POP
// result := [ tmp , 0 , 0 , p ] ;
90358: LD_ADDR_VAR 0 2
90362: PUSH
90363: LD_VAR 0 4
90367: PUSH
90368: LD_INT 0
90370: PUSH
90371: LD_INT 0
90373: PUSH
90374: LD_VAR 0 11
90378: PUSH
90379: EMPTY
90380: LIST
90381: LIST
90382: LIST
90383: LIST
90384: ST_TO_ADDR
// exit ;
90385: GO 93075
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
90387: LD_EXP 178
90391: PUSH
90392: LD_VAR 0 1
90396: ARRAY
90397: PPUSH
90398: LD_INT 2
90400: PUSH
90401: LD_INT 30
90403: PUSH
90404: LD_INT 6
90406: PUSH
90407: EMPTY
90408: LIST
90409: LIST
90410: PUSH
90411: LD_INT 30
90413: PUSH
90414: LD_INT 7
90416: PUSH
90417: EMPTY
90418: LIST
90419: LIST
90420: PUSH
90421: LD_INT 30
90423: PUSH
90424: LD_INT 8
90426: PUSH
90427: EMPTY
90428: LIST
90429: LIST
90430: PUSH
90431: EMPTY
90432: LIST
90433: LIST
90434: LIST
90435: LIST
90436: PPUSH
90437: CALL_OW 72
90441: NOT
90442: PUSH
90443: LD_EXP 178
90447: PUSH
90448: LD_VAR 0 1
90452: ARRAY
90453: PPUSH
90454: LD_INT 30
90456: PUSH
90457: LD_INT 3
90459: PUSH
90460: EMPTY
90461: LIST
90462: LIST
90463: PPUSH
90464: CALL_OW 72
90468: NOT
90469: AND
90470: IFFALSE 90542
// begin if eng = tmp then
90472: LD_VAR 0 6
90476: PUSH
90477: LD_VAR 0 4
90481: EQUAL
90482: IFFALSE 90486
// exit ;
90484: GO 93075
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
90486: LD_ADDR_EXP 220
90490: PUSH
90491: LD_EXP 220
90495: PPUSH
90496: LD_VAR 0 1
90500: PPUSH
90501: LD_INT 1
90503: PPUSH
90504: CALL_OW 1
90508: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
90509: LD_ADDR_VAR 0 2
90513: PUSH
90514: LD_INT 0
90516: PUSH
90517: LD_VAR 0 4
90521: PUSH
90522: LD_VAR 0 6
90526: DIFF
90527: PUSH
90528: LD_INT 0
90530: PUSH
90531: LD_INT 0
90533: PUSH
90534: EMPTY
90535: LIST
90536: LIST
90537: LIST
90538: LIST
90539: ST_TO_ADDR
// exit ;
90540: GO 93075
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
90542: LD_EXP 205
90546: PUSH
90547: LD_EXP 204
90551: PUSH
90552: LD_VAR 0 1
90556: ARRAY
90557: ARRAY
90558: PUSH
90559: LD_EXP 178
90563: PUSH
90564: LD_VAR 0 1
90568: ARRAY
90569: PPUSH
90570: LD_INT 2
90572: PUSH
90573: LD_INT 30
90575: PUSH
90576: LD_INT 6
90578: PUSH
90579: EMPTY
90580: LIST
90581: LIST
90582: PUSH
90583: LD_INT 30
90585: PUSH
90586: LD_INT 7
90588: PUSH
90589: EMPTY
90590: LIST
90591: LIST
90592: PUSH
90593: LD_INT 30
90595: PUSH
90596: LD_INT 8
90598: PUSH
90599: EMPTY
90600: LIST
90601: LIST
90602: PUSH
90603: EMPTY
90604: LIST
90605: LIST
90606: LIST
90607: LIST
90608: PPUSH
90609: CALL_OW 72
90613: AND
90614: PUSH
90615: LD_EXP 178
90619: PUSH
90620: LD_VAR 0 1
90624: ARRAY
90625: PPUSH
90626: LD_INT 30
90628: PUSH
90629: LD_INT 3
90631: PUSH
90632: EMPTY
90633: LIST
90634: LIST
90635: PPUSH
90636: CALL_OW 72
90640: NOT
90641: AND
90642: IFFALSE 90856
// begin if sci >= 6 then
90644: LD_VAR 0 8
90648: PUSH
90649: LD_INT 6
90651: GREATEREQUAL
90652: IFFALSE 90656
// exit ;
90654: GO 93075
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
90656: LD_ADDR_EXP 220
90660: PUSH
90661: LD_EXP 220
90665: PPUSH
90666: LD_VAR 0 1
90670: PPUSH
90671: LD_INT 2
90673: PPUSH
90674: CALL_OW 1
90678: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
90679: LD_ADDR_VAR 0 9
90683: PUSH
90684: LD_VAR 0 4
90688: PUSH
90689: LD_VAR 0 8
90693: DIFF
90694: PPUSH
90695: LD_INT 4
90697: PPUSH
90698: CALL 54467 0 2
90702: ST_TO_ADDR
// p := [ ] ;
90703: LD_ADDR_VAR 0 11
90707: PUSH
90708: EMPTY
90709: ST_TO_ADDR
// if sci < 6 and sort > 6 then
90710: LD_VAR 0 8
90714: PUSH
90715: LD_INT 6
90717: LESS
90718: PUSH
90719: LD_VAR 0 9
90723: PUSH
90724: LD_INT 6
90726: GREATER
90727: AND
90728: IFFALSE 90809
// begin for i = 1 to 6 - sci do
90730: LD_ADDR_VAR 0 3
90734: PUSH
90735: DOUBLE
90736: LD_INT 1
90738: DEC
90739: ST_TO_ADDR
90740: LD_INT 6
90742: PUSH
90743: LD_VAR 0 8
90747: MINUS
90748: PUSH
90749: FOR_TO
90750: IFFALSE 90805
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
90752: LD_ADDR_VAR 0 11
90756: PUSH
90757: LD_VAR 0 11
90761: PPUSH
90762: LD_VAR 0 11
90766: PUSH
90767: LD_INT 1
90769: PLUS
90770: PPUSH
90771: LD_VAR 0 9
90775: PUSH
90776: LD_INT 1
90778: ARRAY
90779: PPUSH
90780: CALL_OW 2
90784: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
90785: LD_ADDR_VAR 0 9
90789: PUSH
90790: LD_VAR 0 9
90794: PPUSH
90795: LD_INT 1
90797: PPUSH
90798: CALL_OW 3
90802: ST_TO_ADDR
// end ;
90803: GO 90749
90805: POP
90806: POP
// end else
90807: GO 90829
// if sort then
90809: LD_VAR 0 9
90813: IFFALSE 90829
// p := sort [ 1 ] ;
90815: LD_ADDR_VAR 0 11
90819: PUSH
90820: LD_VAR 0 9
90824: PUSH
90825: LD_INT 1
90827: ARRAY
90828: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
90829: LD_ADDR_VAR 0 2
90833: PUSH
90834: LD_INT 0
90836: PUSH
90837: LD_INT 0
90839: PUSH
90840: LD_INT 0
90842: PUSH
90843: LD_VAR 0 11
90847: PUSH
90848: EMPTY
90849: LIST
90850: LIST
90851: LIST
90852: LIST
90853: ST_TO_ADDR
// exit ;
90854: GO 93075
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
90856: LD_EXP 205
90860: PUSH
90861: LD_EXP 204
90865: PUSH
90866: LD_VAR 0 1
90870: ARRAY
90871: ARRAY
90872: PUSH
90873: LD_EXP 178
90877: PUSH
90878: LD_VAR 0 1
90882: ARRAY
90883: PPUSH
90884: LD_INT 2
90886: PUSH
90887: LD_INT 30
90889: PUSH
90890: LD_INT 6
90892: PUSH
90893: EMPTY
90894: LIST
90895: LIST
90896: PUSH
90897: LD_INT 30
90899: PUSH
90900: LD_INT 7
90902: PUSH
90903: EMPTY
90904: LIST
90905: LIST
90906: PUSH
90907: LD_INT 30
90909: PUSH
90910: LD_INT 8
90912: PUSH
90913: EMPTY
90914: LIST
90915: LIST
90916: PUSH
90917: EMPTY
90918: LIST
90919: LIST
90920: LIST
90921: LIST
90922: PPUSH
90923: CALL_OW 72
90927: AND
90928: PUSH
90929: LD_EXP 178
90933: PUSH
90934: LD_VAR 0 1
90938: ARRAY
90939: PPUSH
90940: LD_INT 30
90942: PUSH
90943: LD_INT 3
90945: PUSH
90946: EMPTY
90947: LIST
90948: LIST
90949: PPUSH
90950: CALL_OW 72
90954: AND
90955: IFFALSE 91689
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
90957: LD_ADDR_EXP 220
90961: PUSH
90962: LD_EXP 220
90966: PPUSH
90967: LD_VAR 0 1
90971: PPUSH
90972: LD_INT 3
90974: PPUSH
90975: CALL_OW 1
90979: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
90980: LD_ADDR_VAR 0 2
90984: PUSH
90985: LD_INT 0
90987: PUSH
90988: LD_INT 0
90990: PUSH
90991: LD_INT 0
90993: PUSH
90994: LD_INT 0
90996: PUSH
90997: EMPTY
90998: LIST
90999: LIST
91000: LIST
91001: LIST
91002: ST_TO_ADDR
// if not eng then
91003: LD_VAR 0 6
91007: NOT
91008: IFFALSE 91071
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
91010: LD_ADDR_VAR 0 11
91014: PUSH
91015: LD_VAR 0 4
91019: PPUSH
91020: LD_INT 2
91022: PPUSH
91023: CALL 54467 0 2
91027: PUSH
91028: LD_INT 1
91030: ARRAY
91031: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
91032: LD_ADDR_VAR 0 2
91036: PUSH
91037: LD_VAR 0 2
91041: PPUSH
91042: LD_INT 2
91044: PPUSH
91045: LD_VAR 0 11
91049: PPUSH
91050: CALL_OW 1
91054: ST_TO_ADDR
// tmp := tmp diff p ;
91055: LD_ADDR_VAR 0 4
91059: PUSH
91060: LD_VAR 0 4
91064: PUSH
91065: LD_VAR 0 11
91069: DIFF
91070: ST_TO_ADDR
// end ; if tmp and sci < 6 then
91071: LD_VAR 0 4
91075: PUSH
91076: LD_VAR 0 8
91080: PUSH
91081: LD_INT 6
91083: LESS
91084: AND
91085: IFFALSE 91273
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
91087: LD_ADDR_VAR 0 9
91091: PUSH
91092: LD_VAR 0 4
91096: PUSH
91097: LD_VAR 0 8
91101: PUSH
91102: LD_VAR 0 7
91106: UNION
91107: DIFF
91108: PPUSH
91109: LD_INT 4
91111: PPUSH
91112: CALL 54467 0 2
91116: ST_TO_ADDR
// p := [ ] ;
91117: LD_ADDR_VAR 0 11
91121: PUSH
91122: EMPTY
91123: ST_TO_ADDR
// if sort then
91124: LD_VAR 0 9
91128: IFFALSE 91244
// for i = 1 to 6 - sci do
91130: LD_ADDR_VAR 0 3
91134: PUSH
91135: DOUBLE
91136: LD_INT 1
91138: DEC
91139: ST_TO_ADDR
91140: LD_INT 6
91142: PUSH
91143: LD_VAR 0 8
91147: MINUS
91148: PUSH
91149: FOR_TO
91150: IFFALSE 91242
// begin if i = sort then
91152: LD_VAR 0 3
91156: PUSH
91157: LD_VAR 0 9
91161: EQUAL
91162: IFFALSE 91166
// break ;
91164: GO 91242
// if GetClass ( i ) = 4 then
91166: LD_VAR 0 3
91170: PPUSH
91171: CALL_OW 257
91175: PUSH
91176: LD_INT 4
91178: EQUAL
91179: IFFALSE 91183
// continue ;
91181: GO 91149
// p := Insert ( p , p + 1 , sort [ i ] ) ;
91183: LD_ADDR_VAR 0 11
91187: PUSH
91188: LD_VAR 0 11
91192: PPUSH
91193: LD_VAR 0 11
91197: PUSH
91198: LD_INT 1
91200: PLUS
91201: PPUSH
91202: LD_VAR 0 9
91206: PUSH
91207: LD_VAR 0 3
91211: ARRAY
91212: PPUSH
91213: CALL_OW 2
91217: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
91218: LD_ADDR_VAR 0 4
91222: PUSH
91223: LD_VAR 0 4
91227: PUSH
91228: LD_VAR 0 9
91232: PUSH
91233: LD_VAR 0 3
91237: ARRAY
91238: DIFF
91239: ST_TO_ADDR
// end ;
91240: GO 91149
91242: POP
91243: POP
// if p then
91244: LD_VAR 0 11
91248: IFFALSE 91273
// result := Replace ( result , 4 , p ) ;
91250: LD_ADDR_VAR 0 2
91254: PUSH
91255: LD_VAR 0 2
91259: PPUSH
91260: LD_INT 4
91262: PPUSH
91263: LD_VAR 0 11
91267: PPUSH
91268: CALL_OW 1
91272: ST_TO_ADDR
// end ; if tmp and mech < 6 then
91273: LD_VAR 0 4
91277: PUSH
91278: LD_VAR 0 7
91282: PUSH
91283: LD_INT 6
91285: LESS
91286: AND
91287: IFFALSE 91475
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
91289: LD_ADDR_VAR 0 9
91293: PUSH
91294: LD_VAR 0 4
91298: PUSH
91299: LD_VAR 0 8
91303: PUSH
91304: LD_VAR 0 7
91308: UNION
91309: DIFF
91310: PPUSH
91311: LD_INT 3
91313: PPUSH
91314: CALL 54467 0 2
91318: ST_TO_ADDR
// p := [ ] ;
91319: LD_ADDR_VAR 0 11
91323: PUSH
91324: EMPTY
91325: ST_TO_ADDR
// if sort then
91326: LD_VAR 0 9
91330: IFFALSE 91446
// for i = 1 to 6 - mech do
91332: LD_ADDR_VAR 0 3
91336: PUSH
91337: DOUBLE
91338: LD_INT 1
91340: DEC
91341: ST_TO_ADDR
91342: LD_INT 6
91344: PUSH
91345: LD_VAR 0 7
91349: MINUS
91350: PUSH
91351: FOR_TO
91352: IFFALSE 91444
// begin if i = sort then
91354: LD_VAR 0 3
91358: PUSH
91359: LD_VAR 0 9
91363: EQUAL
91364: IFFALSE 91368
// break ;
91366: GO 91444
// if GetClass ( i ) = 3 then
91368: LD_VAR 0 3
91372: PPUSH
91373: CALL_OW 257
91377: PUSH
91378: LD_INT 3
91380: EQUAL
91381: IFFALSE 91385
// continue ;
91383: GO 91351
// p := Insert ( p , p + 1 , sort [ i ] ) ;
91385: LD_ADDR_VAR 0 11
91389: PUSH
91390: LD_VAR 0 11
91394: PPUSH
91395: LD_VAR 0 11
91399: PUSH
91400: LD_INT 1
91402: PLUS
91403: PPUSH
91404: LD_VAR 0 9
91408: PUSH
91409: LD_VAR 0 3
91413: ARRAY
91414: PPUSH
91415: CALL_OW 2
91419: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
91420: LD_ADDR_VAR 0 4
91424: PUSH
91425: LD_VAR 0 4
91429: PUSH
91430: LD_VAR 0 9
91434: PUSH
91435: LD_VAR 0 3
91439: ARRAY
91440: DIFF
91441: ST_TO_ADDR
// end ;
91442: GO 91351
91444: POP
91445: POP
// if p then
91446: LD_VAR 0 11
91450: IFFALSE 91475
// result := Replace ( result , 3 , p ) ;
91452: LD_ADDR_VAR 0 2
91456: PUSH
91457: LD_VAR 0 2
91461: PPUSH
91462: LD_INT 3
91464: PPUSH
91465: LD_VAR 0 11
91469: PPUSH
91470: CALL_OW 1
91474: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
91475: LD_VAR 0 4
91479: PUSH
91480: LD_INT 6
91482: GREATER
91483: PUSH
91484: LD_VAR 0 6
91488: PUSH
91489: LD_INT 6
91491: LESS
91492: AND
91493: IFFALSE 91687
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
91495: LD_ADDR_VAR 0 9
91499: PUSH
91500: LD_VAR 0 4
91504: PUSH
91505: LD_VAR 0 8
91509: PUSH
91510: LD_VAR 0 7
91514: UNION
91515: PUSH
91516: LD_VAR 0 6
91520: UNION
91521: DIFF
91522: PPUSH
91523: LD_INT 2
91525: PPUSH
91526: CALL 54467 0 2
91530: ST_TO_ADDR
// p := [ ] ;
91531: LD_ADDR_VAR 0 11
91535: PUSH
91536: EMPTY
91537: ST_TO_ADDR
// if sort then
91538: LD_VAR 0 9
91542: IFFALSE 91658
// for i = 1 to 6 - eng do
91544: LD_ADDR_VAR 0 3
91548: PUSH
91549: DOUBLE
91550: LD_INT 1
91552: DEC
91553: ST_TO_ADDR
91554: LD_INT 6
91556: PUSH
91557: LD_VAR 0 6
91561: MINUS
91562: PUSH
91563: FOR_TO
91564: IFFALSE 91656
// begin if i = sort then
91566: LD_VAR 0 3
91570: PUSH
91571: LD_VAR 0 9
91575: EQUAL
91576: IFFALSE 91580
// break ;
91578: GO 91656
// if GetClass ( i ) = 2 then
91580: LD_VAR 0 3
91584: PPUSH
91585: CALL_OW 257
91589: PUSH
91590: LD_INT 2
91592: EQUAL
91593: IFFALSE 91597
// continue ;
91595: GO 91563
// p := Insert ( p , p + 1 , sort [ i ] ) ;
91597: LD_ADDR_VAR 0 11
91601: PUSH
91602: LD_VAR 0 11
91606: PPUSH
91607: LD_VAR 0 11
91611: PUSH
91612: LD_INT 1
91614: PLUS
91615: PPUSH
91616: LD_VAR 0 9
91620: PUSH
91621: LD_VAR 0 3
91625: ARRAY
91626: PPUSH
91627: CALL_OW 2
91631: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
91632: LD_ADDR_VAR 0 4
91636: PUSH
91637: LD_VAR 0 4
91641: PUSH
91642: LD_VAR 0 9
91646: PUSH
91647: LD_VAR 0 3
91651: ARRAY
91652: DIFF
91653: ST_TO_ADDR
// end ;
91654: GO 91563
91656: POP
91657: POP
// if p then
91658: LD_VAR 0 11
91662: IFFALSE 91687
// result := Replace ( result , 2 , p ) ;
91664: LD_ADDR_VAR 0 2
91668: PUSH
91669: LD_VAR 0 2
91673: PPUSH
91674: LD_INT 2
91676: PPUSH
91677: LD_VAR 0 11
91681: PPUSH
91682: CALL_OW 1
91686: ST_TO_ADDR
// end ; exit ;
91687: GO 93075
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
91689: LD_EXP 205
91693: PUSH
91694: LD_EXP 204
91698: PUSH
91699: LD_VAR 0 1
91703: ARRAY
91704: ARRAY
91705: NOT
91706: PUSH
91707: LD_EXP 178
91711: PUSH
91712: LD_VAR 0 1
91716: ARRAY
91717: PPUSH
91718: LD_INT 30
91720: PUSH
91721: LD_INT 3
91723: PUSH
91724: EMPTY
91725: LIST
91726: LIST
91727: PPUSH
91728: CALL_OW 72
91732: AND
91733: PUSH
91734: LD_EXP 183
91738: PUSH
91739: LD_VAR 0 1
91743: ARRAY
91744: AND
91745: IFFALSE 92353
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
91747: LD_ADDR_EXP 220
91751: PUSH
91752: LD_EXP 220
91756: PPUSH
91757: LD_VAR 0 1
91761: PPUSH
91762: LD_INT 5
91764: PPUSH
91765: CALL_OW 1
91769: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
91770: LD_ADDR_VAR 0 2
91774: PUSH
91775: LD_INT 0
91777: PUSH
91778: LD_INT 0
91780: PUSH
91781: LD_INT 0
91783: PUSH
91784: LD_INT 0
91786: PUSH
91787: EMPTY
91788: LIST
91789: LIST
91790: LIST
91791: LIST
91792: ST_TO_ADDR
// if sci > 1 then
91793: LD_VAR 0 8
91797: PUSH
91798: LD_INT 1
91800: GREATER
91801: IFFALSE 91829
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
91803: LD_ADDR_VAR 0 4
91807: PUSH
91808: LD_VAR 0 4
91812: PUSH
91813: LD_VAR 0 8
91817: PUSH
91818: LD_VAR 0 8
91822: PUSH
91823: LD_INT 1
91825: ARRAY
91826: DIFF
91827: DIFF
91828: ST_TO_ADDR
// if tmp and not sci then
91829: LD_VAR 0 4
91833: PUSH
91834: LD_VAR 0 8
91838: NOT
91839: AND
91840: IFFALSE 91909
// begin sort := SortBySkill ( tmp , 4 ) ;
91842: LD_ADDR_VAR 0 9
91846: PUSH
91847: LD_VAR 0 4
91851: PPUSH
91852: LD_INT 4
91854: PPUSH
91855: CALL 54467 0 2
91859: ST_TO_ADDR
// if sort then
91860: LD_VAR 0 9
91864: IFFALSE 91880
// p := sort [ 1 ] ;
91866: LD_ADDR_VAR 0 11
91870: PUSH
91871: LD_VAR 0 9
91875: PUSH
91876: LD_INT 1
91878: ARRAY
91879: ST_TO_ADDR
// if p then
91880: LD_VAR 0 11
91884: IFFALSE 91909
// result := Replace ( result , 4 , p ) ;
91886: LD_ADDR_VAR 0 2
91890: PUSH
91891: LD_VAR 0 2
91895: PPUSH
91896: LD_INT 4
91898: PPUSH
91899: LD_VAR 0 11
91903: PPUSH
91904: CALL_OW 1
91908: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
91909: LD_ADDR_VAR 0 4
91913: PUSH
91914: LD_VAR 0 4
91918: PUSH
91919: LD_VAR 0 7
91923: DIFF
91924: ST_TO_ADDR
// if tmp and mech < 6 then
91925: LD_VAR 0 4
91929: PUSH
91930: LD_VAR 0 7
91934: PUSH
91935: LD_INT 6
91937: LESS
91938: AND
91939: IFFALSE 92127
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
91941: LD_ADDR_VAR 0 9
91945: PUSH
91946: LD_VAR 0 4
91950: PUSH
91951: LD_VAR 0 8
91955: PUSH
91956: LD_VAR 0 7
91960: UNION
91961: DIFF
91962: PPUSH
91963: LD_INT 3
91965: PPUSH
91966: CALL 54467 0 2
91970: ST_TO_ADDR
// p := [ ] ;
91971: LD_ADDR_VAR 0 11
91975: PUSH
91976: EMPTY
91977: ST_TO_ADDR
// if sort then
91978: LD_VAR 0 9
91982: IFFALSE 92098
// for i = 1 to 6 - mech do
91984: LD_ADDR_VAR 0 3
91988: PUSH
91989: DOUBLE
91990: LD_INT 1
91992: DEC
91993: ST_TO_ADDR
91994: LD_INT 6
91996: PUSH
91997: LD_VAR 0 7
92001: MINUS
92002: PUSH
92003: FOR_TO
92004: IFFALSE 92096
// begin if i = sort then
92006: LD_VAR 0 3
92010: PUSH
92011: LD_VAR 0 9
92015: EQUAL
92016: IFFALSE 92020
// break ;
92018: GO 92096
// if GetClass ( i ) = 3 then
92020: LD_VAR 0 3
92024: PPUSH
92025: CALL_OW 257
92029: PUSH
92030: LD_INT 3
92032: EQUAL
92033: IFFALSE 92037
// continue ;
92035: GO 92003
// p := Insert ( p , p + 1 , sort [ i ] ) ;
92037: LD_ADDR_VAR 0 11
92041: PUSH
92042: LD_VAR 0 11
92046: PPUSH
92047: LD_VAR 0 11
92051: PUSH
92052: LD_INT 1
92054: PLUS
92055: PPUSH
92056: LD_VAR 0 9
92060: PUSH
92061: LD_VAR 0 3
92065: ARRAY
92066: PPUSH
92067: CALL_OW 2
92071: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
92072: LD_ADDR_VAR 0 4
92076: PUSH
92077: LD_VAR 0 4
92081: PUSH
92082: LD_VAR 0 9
92086: PUSH
92087: LD_VAR 0 3
92091: ARRAY
92092: DIFF
92093: ST_TO_ADDR
// end ;
92094: GO 92003
92096: POP
92097: POP
// if p then
92098: LD_VAR 0 11
92102: IFFALSE 92127
// result := Replace ( result , 3 , p ) ;
92104: LD_ADDR_VAR 0 2
92108: PUSH
92109: LD_VAR 0 2
92113: PPUSH
92114: LD_INT 3
92116: PPUSH
92117: LD_VAR 0 11
92121: PPUSH
92122: CALL_OW 1
92126: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
92127: LD_ADDR_VAR 0 4
92131: PUSH
92132: LD_VAR 0 4
92136: PUSH
92137: LD_VAR 0 6
92141: DIFF
92142: ST_TO_ADDR
// if tmp and eng < 6 then
92143: LD_VAR 0 4
92147: PUSH
92148: LD_VAR 0 6
92152: PUSH
92153: LD_INT 6
92155: LESS
92156: AND
92157: IFFALSE 92351
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
92159: LD_ADDR_VAR 0 9
92163: PUSH
92164: LD_VAR 0 4
92168: PUSH
92169: LD_VAR 0 8
92173: PUSH
92174: LD_VAR 0 7
92178: UNION
92179: PUSH
92180: LD_VAR 0 6
92184: UNION
92185: DIFF
92186: PPUSH
92187: LD_INT 2
92189: PPUSH
92190: CALL 54467 0 2
92194: ST_TO_ADDR
// p := [ ] ;
92195: LD_ADDR_VAR 0 11
92199: PUSH
92200: EMPTY
92201: ST_TO_ADDR
// if sort then
92202: LD_VAR 0 9
92206: IFFALSE 92322
// for i = 1 to 6 - eng do
92208: LD_ADDR_VAR 0 3
92212: PUSH
92213: DOUBLE
92214: LD_INT 1
92216: DEC
92217: ST_TO_ADDR
92218: LD_INT 6
92220: PUSH
92221: LD_VAR 0 6
92225: MINUS
92226: PUSH
92227: FOR_TO
92228: IFFALSE 92320
// begin if i = sort then
92230: LD_VAR 0 3
92234: PUSH
92235: LD_VAR 0 9
92239: EQUAL
92240: IFFALSE 92244
// break ;
92242: GO 92320
// if GetClass ( i ) = 2 then
92244: LD_VAR 0 3
92248: PPUSH
92249: CALL_OW 257
92253: PUSH
92254: LD_INT 2
92256: EQUAL
92257: IFFALSE 92261
// continue ;
92259: GO 92227
// p := Insert ( p , p + 1 , sort [ i ] ) ;
92261: LD_ADDR_VAR 0 11
92265: PUSH
92266: LD_VAR 0 11
92270: PPUSH
92271: LD_VAR 0 11
92275: PUSH
92276: LD_INT 1
92278: PLUS
92279: PPUSH
92280: LD_VAR 0 9
92284: PUSH
92285: LD_VAR 0 3
92289: ARRAY
92290: PPUSH
92291: CALL_OW 2
92295: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
92296: LD_ADDR_VAR 0 4
92300: PUSH
92301: LD_VAR 0 4
92305: PUSH
92306: LD_VAR 0 9
92310: PUSH
92311: LD_VAR 0 3
92315: ARRAY
92316: DIFF
92317: ST_TO_ADDR
// end ;
92318: GO 92227
92320: POP
92321: POP
// if p then
92322: LD_VAR 0 11
92326: IFFALSE 92351
// result := Replace ( result , 2 , p ) ;
92328: LD_ADDR_VAR 0 2
92332: PUSH
92333: LD_VAR 0 2
92337: PPUSH
92338: LD_INT 2
92340: PPUSH
92341: LD_VAR 0 11
92345: PPUSH
92346: CALL_OW 1
92350: ST_TO_ADDR
// end ; exit ;
92351: GO 93075
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
92353: LD_EXP 205
92357: PUSH
92358: LD_EXP 204
92362: PUSH
92363: LD_VAR 0 1
92367: ARRAY
92368: ARRAY
92369: NOT
92370: PUSH
92371: LD_EXP 178
92375: PUSH
92376: LD_VAR 0 1
92380: ARRAY
92381: PPUSH
92382: LD_INT 30
92384: PUSH
92385: LD_INT 3
92387: PUSH
92388: EMPTY
92389: LIST
92390: LIST
92391: PPUSH
92392: CALL_OW 72
92396: AND
92397: PUSH
92398: LD_EXP 183
92402: PUSH
92403: LD_VAR 0 1
92407: ARRAY
92408: NOT
92409: AND
92410: IFFALSE 93075
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
92412: LD_ADDR_EXP 220
92416: PUSH
92417: LD_EXP 220
92421: PPUSH
92422: LD_VAR 0 1
92426: PPUSH
92427: LD_INT 6
92429: PPUSH
92430: CALL_OW 1
92434: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
92435: LD_ADDR_VAR 0 2
92439: PUSH
92440: LD_INT 0
92442: PUSH
92443: LD_INT 0
92445: PUSH
92446: LD_INT 0
92448: PUSH
92449: LD_INT 0
92451: PUSH
92452: EMPTY
92453: LIST
92454: LIST
92455: LIST
92456: LIST
92457: ST_TO_ADDR
// if sci >= 1 then
92458: LD_VAR 0 8
92462: PUSH
92463: LD_INT 1
92465: GREATEREQUAL
92466: IFFALSE 92488
// tmp := tmp diff sci [ 1 ] ;
92468: LD_ADDR_VAR 0 4
92472: PUSH
92473: LD_VAR 0 4
92477: PUSH
92478: LD_VAR 0 8
92482: PUSH
92483: LD_INT 1
92485: ARRAY
92486: DIFF
92487: ST_TO_ADDR
// if tmp and not sci then
92488: LD_VAR 0 4
92492: PUSH
92493: LD_VAR 0 8
92497: NOT
92498: AND
92499: IFFALSE 92568
// begin sort := SortBySkill ( tmp , 4 ) ;
92501: LD_ADDR_VAR 0 9
92505: PUSH
92506: LD_VAR 0 4
92510: PPUSH
92511: LD_INT 4
92513: PPUSH
92514: CALL 54467 0 2
92518: ST_TO_ADDR
// if sort then
92519: LD_VAR 0 9
92523: IFFALSE 92539
// p := sort [ 1 ] ;
92525: LD_ADDR_VAR 0 11
92529: PUSH
92530: LD_VAR 0 9
92534: PUSH
92535: LD_INT 1
92537: ARRAY
92538: ST_TO_ADDR
// if p then
92539: LD_VAR 0 11
92543: IFFALSE 92568
// result := Replace ( result , 4 , p ) ;
92545: LD_ADDR_VAR 0 2
92549: PUSH
92550: LD_VAR 0 2
92554: PPUSH
92555: LD_INT 4
92557: PPUSH
92558: LD_VAR 0 11
92562: PPUSH
92563: CALL_OW 1
92567: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
92568: LD_ADDR_VAR 0 4
92572: PUSH
92573: LD_VAR 0 4
92577: PUSH
92578: LD_VAR 0 7
92582: DIFF
92583: ST_TO_ADDR
// if tmp and mech < 6 then
92584: LD_VAR 0 4
92588: PUSH
92589: LD_VAR 0 7
92593: PUSH
92594: LD_INT 6
92596: LESS
92597: AND
92598: IFFALSE 92780
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
92600: LD_ADDR_VAR 0 9
92604: PUSH
92605: LD_VAR 0 4
92609: PUSH
92610: LD_VAR 0 7
92614: DIFF
92615: PPUSH
92616: LD_INT 3
92618: PPUSH
92619: CALL 54467 0 2
92623: ST_TO_ADDR
// p := [ ] ;
92624: LD_ADDR_VAR 0 11
92628: PUSH
92629: EMPTY
92630: ST_TO_ADDR
// if sort then
92631: LD_VAR 0 9
92635: IFFALSE 92751
// for i = 1 to 6 - mech do
92637: LD_ADDR_VAR 0 3
92641: PUSH
92642: DOUBLE
92643: LD_INT 1
92645: DEC
92646: ST_TO_ADDR
92647: LD_INT 6
92649: PUSH
92650: LD_VAR 0 7
92654: MINUS
92655: PUSH
92656: FOR_TO
92657: IFFALSE 92749
// begin if i = sort then
92659: LD_VAR 0 3
92663: PUSH
92664: LD_VAR 0 9
92668: EQUAL
92669: IFFALSE 92673
// break ;
92671: GO 92749
// if GetClass ( i ) = 3 then
92673: LD_VAR 0 3
92677: PPUSH
92678: CALL_OW 257
92682: PUSH
92683: LD_INT 3
92685: EQUAL
92686: IFFALSE 92690
// continue ;
92688: GO 92656
// p := Insert ( p , p + 1 , sort [ i ] ) ;
92690: LD_ADDR_VAR 0 11
92694: PUSH
92695: LD_VAR 0 11
92699: PPUSH
92700: LD_VAR 0 11
92704: PUSH
92705: LD_INT 1
92707: PLUS
92708: PPUSH
92709: LD_VAR 0 9
92713: PUSH
92714: LD_VAR 0 3
92718: ARRAY
92719: PPUSH
92720: CALL_OW 2
92724: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
92725: LD_ADDR_VAR 0 4
92729: PUSH
92730: LD_VAR 0 4
92734: PUSH
92735: LD_VAR 0 9
92739: PUSH
92740: LD_VAR 0 3
92744: ARRAY
92745: DIFF
92746: ST_TO_ADDR
// end ;
92747: GO 92656
92749: POP
92750: POP
// if p then
92751: LD_VAR 0 11
92755: IFFALSE 92780
// result := Replace ( result , 3 , p ) ;
92757: LD_ADDR_VAR 0 2
92761: PUSH
92762: LD_VAR 0 2
92766: PPUSH
92767: LD_INT 3
92769: PPUSH
92770: LD_VAR 0 11
92774: PPUSH
92775: CALL_OW 1
92779: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
92780: LD_ADDR_VAR 0 4
92784: PUSH
92785: LD_VAR 0 4
92789: PUSH
92790: LD_VAR 0 6
92794: DIFF
92795: ST_TO_ADDR
// if tmp and eng < 4 then
92796: LD_VAR 0 4
92800: PUSH
92801: LD_VAR 0 6
92805: PUSH
92806: LD_INT 4
92808: LESS
92809: AND
92810: IFFALSE 93000
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
92812: LD_ADDR_VAR 0 9
92816: PUSH
92817: LD_VAR 0 4
92821: PUSH
92822: LD_VAR 0 7
92826: PUSH
92827: LD_VAR 0 6
92831: UNION
92832: DIFF
92833: PPUSH
92834: LD_INT 2
92836: PPUSH
92837: CALL 54467 0 2
92841: ST_TO_ADDR
// p := [ ] ;
92842: LD_ADDR_VAR 0 11
92846: PUSH
92847: EMPTY
92848: ST_TO_ADDR
// if sort then
92849: LD_VAR 0 9
92853: IFFALSE 92969
// for i = 1 to 4 - eng do
92855: LD_ADDR_VAR 0 3
92859: PUSH
92860: DOUBLE
92861: LD_INT 1
92863: DEC
92864: ST_TO_ADDR
92865: LD_INT 4
92867: PUSH
92868: LD_VAR 0 6
92872: MINUS
92873: PUSH
92874: FOR_TO
92875: IFFALSE 92967
// begin if i = sort then
92877: LD_VAR 0 3
92881: PUSH
92882: LD_VAR 0 9
92886: EQUAL
92887: IFFALSE 92891
// break ;
92889: GO 92967
// if GetClass ( i ) = 2 then
92891: LD_VAR 0 3
92895: PPUSH
92896: CALL_OW 257
92900: PUSH
92901: LD_INT 2
92903: EQUAL
92904: IFFALSE 92908
// continue ;
92906: GO 92874
// p := Insert ( p , p + 1 , sort [ i ] ) ;
92908: LD_ADDR_VAR 0 11
92912: PUSH
92913: LD_VAR 0 11
92917: PPUSH
92918: LD_VAR 0 11
92922: PUSH
92923: LD_INT 1
92925: PLUS
92926: PPUSH
92927: LD_VAR 0 9
92931: PUSH
92932: LD_VAR 0 3
92936: ARRAY
92937: PPUSH
92938: CALL_OW 2
92942: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
92943: LD_ADDR_VAR 0 4
92947: PUSH
92948: LD_VAR 0 4
92952: PUSH
92953: LD_VAR 0 9
92957: PUSH
92958: LD_VAR 0 3
92962: ARRAY
92963: DIFF
92964: ST_TO_ADDR
// end ;
92965: GO 92874
92967: POP
92968: POP
// if p then
92969: LD_VAR 0 11
92973: IFFALSE 92998
// result := Replace ( result , 2 , p ) ;
92975: LD_ADDR_VAR 0 2
92979: PUSH
92980: LD_VAR 0 2
92984: PPUSH
92985: LD_INT 2
92987: PPUSH
92988: LD_VAR 0 11
92992: PPUSH
92993: CALL_OW 1
92997: ST_TO_ADDR
// end else
92998: GO 93044
// for i = eng downto 5 do
93000: LD_ADDR_VAR 0 3
93004: PUSH
93005: DOUBLE
93006: LD_VAR 0 6
93010: INC
93011: ST_TO_ADDR
93012: LD_INT 5
93014: PUSH
93015: FOR_DOWNTO
93016: IFFALSE 93042
// tmp := tmp union eng [ i ] ;
93018: LD_ADDR_VAR 0 4
93022: PUSH
93023: LD_VAR 0 4
93027: PUSH
93028: LD_VAR 0 6
93032: PUSH
93033: LD_VAR 0 3
93037: ARRAY
93038: UNION
93039: ST_TO_ADDR
93040: GO 93015
93042: POP
93043: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
93044: LD_ADDR_VAR 0 2
93048: PUSH
93049: LD_VAR 0 2
93053: PPUSH
93054: LD_INT 1
93056: PPUSH
93057: LD_VAR 0 4
93061: PUSH
93062: LD_VAR 0 5
93066: DIFF
93067: PPUSH
93068: CALL_OW 1
93072: ST_TO_ADDR
// exit ;
93073: GO 93075
// end ; end ;
93075: LD_VAR 0 2
93079: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
93080: LD_INT 0
93082: PPUSH
93083: PPUSH
93084: PPUSH
// if not mc_bases then
93085: LD_EXP 178
93089: NOT
93090: IFFALSE 93094
// exit ;
93092: GO 93236
// for i = 1 to mc_bases do
93094: LD_ADDR_VAR 0 2
93098: PUSH
93099: DOUBLE
93100: LD_INT 1
93102: DEC
93103: ST_TO_ADDR
93104: LD_EXP 178
93108: PUSH
93109: FOR_TO
93110: IFFALSE 93227
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
93112: LD_ADDR_VAR 0 3
93116: PUSH
93117: LD_EXP 178
93121: PUSH
93122: LD_VAR 0 2
93126: ARRAY
93127: PPUSH
93128: LD_INT 21
93130: PUSH
93131: LD_INT 3
93133: PUSH
93134: EMPTY
93135: LIST
93136: LIST
93137: PUSH
93138: LD_INT 3
93140: PUSH
93141: LD_INT 2
93143: PUSH
93144: LD_INT 30
93146: PUSH
93147: LD_INT 29
93149: PUSH
93150: EMPTY
93151: LIST
93152: LIST
93153: PUSH
93154: LD_INT 30
93156: PUSH
93157: LD_INT 30
93159: PUSH
93160: EMPTY
93161: LIST
93162: LIST
93163: PUSH
93164: EMPTY
93165: LIST
93166: LIST
93167: LIST
93168: PUSH
93169: EMPTY
93170: LIST
93171: LIST
93172: PUSH
93173: LD_INT 3
93175: PUSH
93176: LD_INT 24
93178: PUSH
93179: LD_INT 1000
93181: PUSH
93182: EMPTY
93183: LIST
93184: LIST
93185: PUSH
93186: EMPTY
93187: LIST
93188: LIST
93189: PUSH
93190: EMPTY
93191: LIST
93192: LIST
93193: LIST
93194: PPUSH
93195: CALL_OW 72
93199: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
93200: LD_ADDR_EXP 179
93204: PUSH
93205: LD_EXP 179
93209: PPUSH
93210: LD_VAR 0 2
93214: PPUSH
93215: LD_VAR 0 3
93219: PPUSH
93220: CALL_OW 1
93224: ST_TO_ADDR
// end ;
93225: GO 93109
93227: POP
93228: POP
// RaiseSailEvent ( 101 ) ;
93229: LD_INT 101
93231: PPUSH
93232: CALL_OW 427
// end ;
93236: LD_VAR 0 1
93240: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
93241: LD_INT 0
93243: PPUSH
93244: PPUSH
93245: PPUSH
93246: PPUSH
93247: PPUSH
93248: PPUSH
93249: PPUSH
// if not mc_bases then
93250: LD_EXP 178
93254: NOT
93255: IFFALSE 93259
// exit ;
93257: GO 93821
// for i = 1 to mc_bases do
93259: LD_ADDR_VAR 0 2
93263: PUSH
93264: DOUBLE
93265: LD_INT 1
93267: DEC
93268: ST_TO_ADDR
93269: LD_EXP 178
93273: PUSH
93274: FOR_TO
93275: IFFALSE 93812
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
93277: LD_ADDR_VAR 0 5
93281: PUSH
93282: LD_EXP 178
93286: PUSH
93287: LD_VAR 0 2
93291: ARRAY
93292: PUSH
93293: LD_EXP 207
93297: PUSH
93298: LD_VAR 0 2
93302: ARRAY
93303: UNION
93304: PPUSH
93305: LD_INT 21
93307: PUSH
93308: LD_INT 1
93310: PUSH
93311: EMPTY
93312: LIST
93313: LIST
93314: PUSH
93315: LD_INT 1
93317: PUSH
93318: LD_INT 3
93320: PUSH
93321: LD_INT 54
93323: PUSH
93324: EMPTY
93325: LIST
93326: PUSH
93327: EMPTY
93328: LIST
93329: LIST
93330: PUSH
93331: LD_INT 3
93333: PUSH
93334: LD_INT 24
93336: PUSH
93337: LD_INT 1000
93339: PUSH
93340: EMPTY
93341: LIST
93342: LIST
93343: PUSH
93344: EMPTY
93345: LIST
93346: LIST
93347: PUSH
93348: EMPTY
93349: LIST
93350: LIST
93351: LIST
93352: PUSH
93353: EMPTY
93354: LIST
93355: LIST
93356: PPUSH
93357: CALL_OW 72
93361: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
93362: LD_ADDR_VAR 0 6
93366: PUSH
93367: LD_EXP 178
93371: PUSH
93372: LD_VAR 0 2
93376: ARRAY
93377: PPUSH
93378: LD_INT 21
93380: PUSH
93381: LD_INT 1
93383: PUSH
93384: EMPTY
93385: LIST
93386: LIST
93387: PUSH
93388: LD_INT 1
93390: PUSH
93391: LD_INT 3
93393: PUSH
93394: LD_INT 54
93396: PUSH
93397: EMPTY
93398: LIST
93399: PUSH
93400: EMPTY
93401: LIST
93402: LIST
93403: PUSH
93404: LD_INT 3
93406: PUSH
93407: LD_INT 24
93409: PUSH
93410: LD_INT 250
93412: PUSH
93413: EMPTY
93414: LIST
93415: LIST
93416: PUSH
93417: EMPTY
93418: LIST
93419: LIST
93420: PUSH
93421: EMPTY
93422: LIST
93423: LIST
93424: LIST
93425: PUSH
93426: EMPTY
93427: LIST
93428: LIST
93429: PPUSH
93430: CALL_OW 72
93434: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
93435: LD_ADDR_VAR 0 7
93439: PUSH
93440: LD_VAR 0 5
93444: PUSH
93445: LD_VAR 0 6
93449: DIFF
93450: ST_TO_ADDR
// if not need_heal_1 then
93451: LD_VAR 0 6
93455: NOT
93456: IFFALSE 93489
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
93458: LD_ADDR_EXP 181
93462: PUSH
93463: LD_EXP 181
93467: PPUSH
93468: LD_VAR 0 2
93472: PUSH
93473: LD_INT 1
93475: PUSH
93476: EMPTY
93477: LIST
93478: LIST
93479: PPUSH
93480: EMPTY
93481: PPUSH
93482: CALL 24210 0 3
93486: ST_TO_ADDR
93487: GO 93559
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
93489: LD_ADDR_EXP 181
93493: PUSH
93494: LD_EXP 181
93498: PPUSH
93499: LD_VAR 0 2
93503: PUSH
93504: LD_INT 1
93506: PUSH
93507: EMPTY
93508: LIST
93509: LIST
93510: PPUSH
93511: LD_EXP 181
93515: PUSH
93516: LD_VAR 0 2
93520: ARRAY
93521: PUSH
93522: LD_INT 1
93524: ARRAY
93525: PPUSH
93526: LD_INT 3
93528: PUSH
93529: LD_INT 24
93531: PUSH
93532: LD_INT 1000
93534: PUSH
93535: EMPTY
93536: LIST
93537: LIST
93538: PUSH
93539: EMPTY
93540: LIST
93541: LIST
93542: PPUSH
93543: CALL_OW 72
93547: PUSH
93548: LD_VAR 0 6
93552: UNION
93553: PPUSH
93554: CALL 24210 0 3
93558: ST_TO_ADDR
// if not need_heal_2 then
93559: LD_VAR 0 7
93563: NOT
93564: IFFALSE 93597
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
93566: LD_ADDR_EXP 181
93570: PUSH
93571: LD_EXP 181
93575: PPUSH
93576: LD_VAR 0 2
93580: PUSH
93581: LD_INT 2
93583: PUSH
93584: EMPTY
93585: LIST
93586: LIST
93587: PPUSH
93588: EMPTY
93589: PPUSH
93590: CALL 24210 0 3
93594: ST_TO_ADDR
93595: GO 93629
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
93597: LD_ADDR_EXP 181
93601: PUSH
93602: LD_EXP 181
93606: PPUSH
93607: LD_VAR 0 2
93611: PUSH
93612: LD_INT 2
93614: PUSH
93615: EMPTY
93616: LIST
93617: LIST
93618: PPUSH
93619: LD_VAR 0 7
93623: PPUSH
93624: CALL 24210 0 3
93628: ST_TO_ADDR
// if need_heal_2 then
93629: LD_VAR 0 7
93633: IFFALSE 93794
// for j in need_heal_2 do
93635: LD_ADDR_VAR 0 3
93639: PUSH
93640: LD_VAR 0 7
93644: PUSH
93645: FOR_IN
93646: IFFALSE 93792
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
93648: LD_ADDR_VAR 0 5
93652: PUSH
93653: LD_EXP 178
93657: PUSH
93658: LD_VAR 0 2
93662: ARRAY
93663: PPUSH
93664: LD_INT 2
93666: PUSH
93667: LD_INT 30
93669: PUSH
93670: LD_INT 6
93672: PUSH
93673: EMPTY
93674: LIST
93675: LIST
93676: PUSH
93677: LD_INT 30
93679: PUSH
93680: LD_INT 7
93682: PUSH
93683: EMPTY
93684: LIST
93685: LIST
93686: PUSH
93687: LD_INT 30
93689: PUSH
93690: LD_INT 8
93692: PUSH
93693: EMPTY
93694: LIST
93695: LIST
93696: PUSH
93697: LD_INT 30
93699: PUSH
93700: LD_INT 0
93702: PUSH
93703: EMPTY
93704: LIST
93705: LIST
93706: PUSH
93707: LD_INT 30
93709: PUSH
93710: LD_INT 1
93712: PUSH
93713: EMPTY
93714: LIST
93715: LIST
93716: PUSH
93717: EMPTY
93718: LIST
93719: LIST
93720: LIST
93721: LIST
93722: LIST
93723: LIST
93724: PPUSH
93725: CALL_OW 72
93729: ST_TO_ADDR
// if tmp then
93730: LD_VAR 0 5
93734: IFFALSE 93790
// begin k := NearestUnitToUnit ( tmp , j ) ;
93736: LD_ADDR_VAR 0 4
93740: PUSH
93741: LD_VAR 0 5
93745: PPUSH
93746: LD_VAR 0 3
93750: PPUSH
93751: CALL_OW 74
93755: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
93756: LD_VAR 0 3
93760: PPUSH
93761: LD_VAR 0 4
93765: PPUSH
93766: CALL_OW 296
93770: PUSH
93771: LD_INT 5
93773: GREATER
93774: IFFALSE 93790
// ComMoveToNearbyEntrance ( j , k ) ;
93776: LD_VAR 0 3
93780: PPUSH
93781: LD_VAR 0 4
93785: PPUSH
93786: CALL 56828 0 2
// end ; end ;
93790: GO 93645
93792: POP
93793: POP
// if not need_heal_1 and not need_heal_2 then
93794: LD_VAR 0 6
93798: NOT
93799: PUSH
93800: LD_VAR 0 7
93804: NOT
93805: AND
93806: IFFALSE 93810
// continue ;
93808: GO 93274
// end ;
93810: GO 93274
93812: POP
93813: POP
// RaiseSailEvent ( 102 ) ;
93814: LD_INT 102
93816: PPUSH
93817: CALL_OW 427
// end ;
93821: LD_VAR 0 1
93825: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
93826: LD_INT 0
93828: PPUSH
93829: PPUSH
93830: PPUSH
93831: PPUSH
93832: PPUSH
93833: PPUSH
93834: PPUSH
93835: PPUSH
// if not mc_bases then
93836: LD_EXP 178
93840: NOT
93841: IFFALSE 93845
// exit ;
93843: GO 94728
// for i = 1 to mc_bases do
93845: LD_ADDR_VAR 0 2
93849: PUSH
93850: DOUBLE
93851: LD_INT 1
93853: DEC
93854: ST_TO_ADDR
93855: LD_EXP 178
93859: PUSH
93860: FOR_TO
93861: IFFALSE 94726
// begin if not mc_building_need_repair [ i ] then
93863: LD_EXP 179
93867: PUSH
93868: LD_VAR 0 2
93872: ARRAY
93873: NOT
93874: IFFALSE 94061
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
93876: LD_ADDR_VAR 0 6
93880: PUSH
93881: LD_EXP 197
93885: PUSH
93886: LD_VAR 0 2
93890: ARRAY
93891: PPUSH
93892: LD_INT 3
93894: PUSH
93895: LD_INT 24
93897: PUSH
93898: LD_INT 1000
93900: PUSH
93901: EMPTY
93902: LIST
93903: LIST
93904: PUSH
93905: EMPTY
93906: LIST
93907: LIST
93908: PUSH
93909: LD_INT 2
93911: PUSH
93912: LD_INT 34
93914: PUSH
93915: LD_INT 13
93917: PUSH
93918: EMPTY
93919: LIST
93920: LIST
93921: PUSH
93922: LD_INT 34
93924: PUSH
93925: LD_INT 52
93927: PUSH
93928: EMPTY
93929: LIST
93930: LIST
93931: PUSH
93932: LD_INT 34
93934: PUSH
93935: LD_EXP 163
93939: PUSH
93940: EMPTY
93941: LIST
93942: LIST
93943: PUSH
93944: EMPTY
93945: LIST
93946: LIST
93947: LIST
93948: LIST
93949: PUSH
93950: EMPTY
93951: LIST
93952: LIST
93953: PPUSH
93954: CALL_OW 72
93958: ST_TO_ADDR
// if cranes then
93959: LD_VAR 0 6
93963: IFFALSE 94025
// for j in cranes do
93965: LD_ADDR_VAR 0 3
93969: PUSH
93970: LD_VAR 0 6
93974: PUSH
93975: FOR_IN
93976: IFFALSE 94023
// if not IsInArea ( j , mc_parking [ i ] ) then
93978: LD_VAR 0 3
93982: PPUSH
93983: LD_EXP 202
93987: PUSH
93988: LD_VAR 0 2
93992: ARRAY
93993: PPUSH
93994: CALL_OW 308
93998: NOT
93999: IFFALSE 94021
// ComMoveToArea ( j , mc_parking [ i ] ) ;
94001: LD_VAR 0 3
94005: PPUSH
94006: LD_EXP 202
94010: PUSH
94011: LD_VAR 0 2
94015: ARRAY
94016: PPUSH
94017: CALL_OW 113
94021: GO 93975
94023: POP
94024: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
94025: LD_ADDR_EXP 180
94029: PUSH
94030: LD_EXP 180
94034: PPUSH
94035: LD_VAR 0 2
94039: PPUSH
94040: EMPTY
94041: PPUSH
94042: CALL_OW 1
94046: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
94047: LD_VAR 0 2
94051: PPUSH
94052: LD_INT 101
94054: PPUSH
94055: CALL 88913 0 2
// continue ;
94059: GO 93860
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
94061: LD_ADDR_EXP 184
94065: PUSH
94066: LD_EXP 184
94070: PPUSH
94071: LD_VAR 0 2
94075: PPUSH
94076: EMPTY
94077: PPUSH
94078: CALL_OW 1
94082: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
94083: LD_VAR 0 2
94087: PPUSH
94088: LD_INT 103
94090: PPUSH
94091: CALL 88913 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
94095: LD_ADDR_VAR 0 5
94099: PUSH
94100: LD_EXP 178
94104: PUSH
94105: LD_VAR 0 2
94109: ARRAY
94110: PUSH
94111: LD_EXP 207
94115: PUSH
94116: LD_VAR 0 2
94120: ARRAY
94121: UNION
94122: PPUSH
94123: LD_INT 2
94125: PUSH
94126: LD_INT 25
94128: PUSH
94129: LD_INT 2
94131: PUSH
94132: EMPTY
94133: LIST
94134: LIST
94135: PUSH
94136: LD_INT 25
94138: PUSH
94139: LD_INT 16
94141: PUSH
94142: EMPTY
94143: LIST
94144: LIST
94145: PUSH
94146: EMPTY
94147: LIST
94148: LIST
94149: LIST
94150: PUSH
94151: EMPTY
94152: LIST
94153: PPUSH
94154: CALL_OW 72
94158: ST_TO_ADDR
// if mc_need_heal [ i ] then
94159: LD_EXP 181
94163: PUSH
94164: LD_VAR 0 2
94168: ARRAY
94169: IFFALSE 94213
// tmp := tmp diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
94171: LD_ADDR_VAR 0 5
94175: PUSH
94176: LD_VAR 0 5
94180: PUSH
94181: LD_EXP 181
94185: PUSH
94186: LD_VAR 0 2
94190: ARRAY
94191: PUSH
94192: LD_INT 1
94194: ARRAY
94195: PUSH
94196: LD_EXP 181
94200: PUSH
94201: LD_VAR 0 2
94205: ARRAY
94206: PUSH
94207: LD_INT 2
94209: ARRAY
94210: UNION
94211: DIFF
94212: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
94213: LD_ADDR_VAR 0 6
94217: PUSH
94218: LD_EXP 197
94222: PUSH
94223: LD_VAR 0 2
94227: ARRAY
94228: PPUSH
94229: LD_INT 2
94231: PUSH
94232: LD_INT 34
94234: PUSH
94235: LD_INT 13
94237: PUSH
94238: EMPTY
94239: LIST
94240: LIST
94241: PUSH
94242: LD_INT 34
94244: PUSH
94245: LD_INT 52
94247: PUSH
94248: EMPTY
94249: LIST
94250: LIST
94251: PUSH
94252: LD_INT 34
94254: PUSH
94255: LD_EXP 163
94259: PUSH
94260: EMPTY
94261: LIST
94262: LIST
94263: PUSH
94264: EMPTY
94265: LIST
94266: LIST
94267: LIST
94268: LIST
94269: PPUSH
94270: CALL_OW 72
94274: ST_TO_ADDR
// if cranes then
94275: LD_VAR 0 6
94279: IFFALSE 94415
// begin for j in cranes do
94281: LD_ADDR_VAR 0 3
94285: PUSH
94286: LD_VAR 0 6
94290: PUSH
94291: FOR_IN
94292: IFFALSE 94413
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
94294: LD_VAR 0 3
94298: PPUSH
94299: CALL_OW 256
94303: PUSH
94304: LD_INT 1000
94306: EQUAL
94307: PUSH
94308: LD_VAR 0 3
94312: PPUSH
94313: CALL_OW 314
94317: NOT
94318: AND
94319: IFFALSE 94353
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) else
94321: LD_VAR 0 3
94325: PPUSH
94326: LD_EXP 179
94330: PUSH
94331: LD_VAR 0 2
94335: ARRAY
94336: PPUSH
94337: LD_VAR 0 3
94341: PPUSH
94342: CALL_OW 74
94346: PPUSH
94347: CALL_OW 130
94351: GO 94411
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
94353: LD_VAR 0 3
94357: PPUSH
94358: CALL_OW 256
94362: PUSH
94363: LD_INT 500
94365: LESS
94366: PUSH
94367: LD_VAR 0 3
94371: PPUSH
94372: LD_EXP 202
94376: PUSH
94377: LD_VAR 0 2
94381: ARRAY
94382: PPUSH
94383: CALL_OW 308
94387: NOT
94388: AND
94389: IFFALSE 94411
// ComMoveToArea ( j , mc_parking [ i ] ) ;
94391: LD_VAR 0 3
94395: PPUSH
94396: LD_EXP 202
94400: PUSH
94401: LD_VAR 0 2
94405: ARRAY
94406: PPUSH
94407: CALL_OW 113
// end ;
94411: GO 94291
94413: POP
94414: POP
// end ; if tmp > 3 then
94415: LD_VAR 0 5
94419: PUSH
94420: LD_INT 3
94422: GREATER
94423: IFFALSE 94443
// tmp := ShrinkArray ( tmp , 4 ) ;
94425: LD_ADDR_VAR 0 5
94429: PUSH
94430: LD_VAR 0 5
94434: PPUSH
94435: LD_INT 4
94437: PPUSH
94438: CALL 56276 0 2
94442: ST_TO_ADDR
// if not tmp then
94443: LD_VAR 0 5
94447: NOT
94448: IFFALSE 94452
// continue ;
94450: GO 93860
// for j in tmp do
94452: LD_ADDR_VAR 0 3
94456: PUSH
94457: LD_VAR 0 5
94461: PUSH
94462: FOR_IN
94463: IFFALSE 94722
// begin if IsInUnit ( j ) then
94465: LD_VAR 0 3
94469: PPUSH
94470: CALL_OW 310
94474: IFFALSE 94485
// ComExitBuilding ( j ) ;
94476: LD_VAR 0 3
94480: PPUSH
94481: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
94485: LD_VAR 0 3
94489: PUSH
94490: LD_EXP 180
94494: PUSH
94495: LD_VAR 0 2
94499: ARRAY
94500: IN
94501: NOT
94502: IFFALSE 94560
// begin SetTag ( j , 101 ) ;
94504: LD_VAR 0 3
94508: PPUSH
94509: LD_INT 101
94511: PPUSH
94512: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
94516: LD_ADDR_EXP 180
94520: PUSH
94521: LD_EXP 180
94525: PPUSH
94526: LD_VAR 0 2
94530: PUSH
94531: LD_EXP 180
94535: PUSH
94536: LD_VAR 0 2
94540: ARRAY
94541: PUSH
94542: LD_INT 1
94544: PLUS
94545: PUSH
94546: EMPTY
94547: LIST
94548: LIST
94549: PPUSH
94550: LD_VAR 0 3
94554: PPUSH
94555: CALL 24210 0 3
94559: ST_TO_ADDR
// end ; wait ( 1 ) ;
94560: LD_INT 1
94562: PPUSH
94563: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
94567: LD_ADDR_VAR 0 7
94571: PUSH
94572: LD_EXP 179
94576: PUSH
94577: LD_VAR 0 2
94581: ARRAY
94582: ST_TO_ADDR
// if mc_scan [ i ] then
94583: LD_EXP 201
94587: PUSH
94588: LD_VAR 0 2
94592: ARRAY
94593: IFFALSE 94655
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
94595: LD_ADDR_VAR 0 7
94599: PUSH
94600: LD_EXP 179
94604: PUSH
94605: LD_VAR 0 2
94609: ARRAY
94610: PPUSH
94611: LD_INT 3
94613: PUSH
94614: LD_INT 30
94616: PUSH
94617: LD_INT 32
94619: PUSH
94620: EMPTY
94621: LIST
94622: LIST
94623: PUSH
94624: LD_INT 30
94626: PUSH
94627: LD_INT 33
94629: PUSH
94630: EMPTY
94631: LIST
94632: LIST
94633: PUSH
94634: LD_INT 30
94636: PUSH
94637: LD_INT 31
94639: PUSH
94640: EMPTY
94641: LIST
94642: LIST
94643: PUSH
94644: EMPTY
94645: LIST
94646: LIST
94647: LIST
94648: LIST
94649: PPUSH
94650: CALL_OW 72
94654: ST_TO_ADDR
// if not to_repair_tmp then
94655: LD_VAR 0 7
94659: NOT
94660: IFFALSE 94664
// continue ;
94662: GO 94462
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
94664: LD_ADDR_VAR 0 8
94668: PUSH
94669: LD_VAR 0 7
94673: PPUSH
94674: LD_VAR 0 3
94678: PPUSH
94679: CALL_OW 74
94683: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
94684: LD_VAR 0 8
94688: PPUSH
94689: LD_INT 16
94691: PPUSH
94692: CALL 26809 0 2
94696: PUSH
94697: LD_INT 4
94699: ARRAY
94700: PUSH
94701: LD_INT 10
94703: LESS
94704: IFFALSE 94720
// ComRepairBuilding ( j , to_repair ) ;
94706: LD_VAR 0 3
94710: PPUSH
94711: LD_VAR 0 8
94715: PPUSH
94716: CALL_OW 130
// end ;
94720: GO 94462
94722: POP
94723: POP
// end ;
94724: GO 93860
94726: POP
94727: POP
// end ;
94728: LD_VAR 0 1
94732: RET
// export function MC_Heal ; var i , j , tmp ; begin
94733: LD_INT 0
94735: PPUSH
94736: PPUSH
94737: PPUSH
94738: PPUSH
// if not mc_bases then
94739: LD_EXP 178
94743: NOT
94744: IFFALSE 94748
// exit ;
94746: GO 95150
// for i = 1 to mc_bases do
94748: LD_ADDR_VAR 0 2
94752: PUSH
94753: DOUBLE
94754: LD_INT 1
94756: DEC
94757: ST_TO_ADDR
94758: LD_EXP 178
94762: PUSH
94763: FOR_TO
94764: IFFALSE 95148
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
94766: LD_EXP 181
94770: PUSH
94771: LD_VAR 0 2
94775: ARRAY
94776: PUSH
94777: LD_INT 1
94779: ARRAY
94780: NOT
94781: PUSH
94782: LD_EXP 181
94786: PUSH
94787: LD_VAR 0 2
94791: ARRAY
94792: PUSH
94793: LD_INT 2
94795: ARRAY
94796: NOT
94797: AND
94798: IFFALSE 94836
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
94800: LD_ADDR_EXP 182
94804: PUSH
94805: LD_EXP 182
94809: PPUSH
94810: LD_VAR 0 2
94814: PPUSH
94815: EMPTY
94816: PPUSH
94817: CALL_OW 1
94821: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
94822: LD_VAR 0 2
94826: PPUSH
94827: LD_INT 102
94829: PPUSH
94830: CALL 88913 0 2
// continue ;
94834: GO 94763
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
94836: LD_ADDR_VAR 0 4
94840: PUSH
94841: LD_EXP 178
94845: PUSH
94846: LD_VAR 0 2
94850: ARRAY
94851: PPUSH
94852: LD_INT 25
94854: PUSH
94855: LD_INT 4
94857: PUSH
94858: EMPTY
94859: LIST
94860: LIST
94861: PPUSH
94862: CALL_OW 72
94866: ST_TO_ADDR
// if not tmp then
94867: LD_VAR 0 4
94871: NOT
94872: IFFALSE 94876
// continue ;
94874: GO 94763
// if mc_taming [ i ] then
94876: LD_EXP 209
94880: PUSH
94881: LD_VAR 0 2
94885: ARRAY
94886: IFFALSE 94910
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
94888: LD_ADDR_EXP 209
94892: PUSH
94893: LD_EXP 209
94897: PPUSH
94898: LD_VAR 0 2
94902: PPUSH
94903: EMPTY
94904: PPUSH
94905: CALL_OW 1
94909: ST_TO_ADDR
// for j in tmp do
94910: LD_ADDR_VAR 0 3
94914: PUSH
94915: LD_VAR 0 4
94919: PUSH
94920: FOR_IN
94921: IFFALSE 95144
// begin if IsInUnit ( j ) then
94923: LD_VAR 0 3
94927: PPUSH
94928: CALL_OW 310
94932: IFFALSE 94943
// ComExitBuilding ( j ) ;
94934: LD_VAR 0 3
94938: PPUSH
94939: CALL_OW 122
// if not j in mc_healers [ i ] then
94943: LD_VAR 0 3
94947: PUSH
94948: LD_EXP 182
94952: PUSH
94953: LD_VAR 0 2
94957: ARRAY
94958: IN
94959: NOT
94960: IFFALSE 95006
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
94962: LD_ADDR_EXP 182
94966: PUSH
94967: LD_EXP 182
94971: PPUSH
94972: LD_VAR 0 2
94976: PUSH
94977: LD_EXP 182
94981: PUSH
94982: LD_VAR 0 2
94986: ARRAY
94987: PUSH
94988: LD_INT 1
94990: PLUS
94991: PUSH
94992: EMPTY
94993: LIST
94994: LIST
94995: PPUSH
94996: LD_VAR 0 3
95000: PPUSH
95001: CALL 24210 0 3
95005: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
95006: LD_VAR 0 3
95010: PPUSH
95011: CALL_OW 110
95015: PUSH
95016: LD_INT 102
95018: NONEQUAL
95019: IFFALSE 95033
// SetTag ( j , 102 ) ;
95021: LD_VAR 0 3
95025: PPUSH
95026: LD_INT 102
95028: PPUSH
95029: CALL_OW 109
// Wait ( 3 ) ;
95033: LD_INT 3
95035: PPUSH
95036: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
95040: LD_EXP 181
95044: PUSH
95045: LD_VAR 0 2
95049: ARRAY
95050: PUSH
95051: LD_INT 1
95053: ARRAY
95054: IFFALSE 95086
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
95056: LD_VAR 0 3
95060: PPUSH
95061: LD_EXP 181
95065: PUSH
95066: LD_VAR 0 2
95070: ARRAY
95071: PUSH
95072: LD_INT 1
95074: ARRAY
95075: PUSH
95076: LD_INT 1
95078: ARRAY
95079: PPUSH
95080: CALL_OW 128
95084: GO 95142
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
95086: LD_VAR 0 3
95090: PPUSH
95091: CALL_OW 314
95095: NOT
95096: PUSH
95097: LD_EXP 181
95101: PUSH
95102: LD_VAR 0 2
95106: ARRAY
95107: PUSH
95108: LD_INT 2
95110: ARRAY
95111: AND
95112: IFFALSE 95142
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
95114: LD_VAR 0 3
95118: PPUSH
95119: LD_EXP 181
95123: PUSH
95124: LD_VAR 0 2
95128: ARRAY
95129: PUSH
95130: LD_INT 2
95132: ARRAY
95133: PUSH
95134: LD_INT 1
95136: ARRAY
95137: PPUSH
95138: CALL_OW 128
// end ;
95142: GO 94920
95144: POP
95145: POP
// end ;
95146: GO 94763
95148: POP
95149: POP
// end ;
95150: LD_VAR 0 1
95154: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
95155: LD_INT 0
95157: PPUSH
95158: PPUSH
95159: PPUSH
95160: PPUSH
95161: PPUSH
// if not mc_bases then
95162: LD_EXP 178
95166: NOT
95167: IFFALSE 95171
// exit ;
95169: GO 96342
// for i = 1 to mc_bases do
95171: LD_ADDR_VAR 0 2
95175: PUSH
95176: DOUBLE
95177: LD_INT 1
95179: DEC
95180: ST_TO_ADDR
95181: LD_EXP 178
95185: PUSH
95186: FOR_TO
95187: IFFALSE 96340
// begin if mc_scan [ i ] then
95189: LD_EXP 201
95193: PUSH
95194: LD_VAR 0 2
95198: ARRAY
95199: IFFALSE 95203
// continue ;
95201: GO 95186
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
95203: LD_EXP 183
95207: PUSH
95208: LD_VAR 0 2
95212: ARRAY
95213: NOT
95214: PUSH
95215: LD_EXP 185
95219: PUSH
95220: LD_VAR 0 2
95224: ARRAY
95225: NOT
95226: AND
95227: PUSH
95228: LD_EXP 184
95232: PUSH
95233: LD_VAR 0 2
95237: ARRAY
95238: AND
95239: IFFALSE 95277
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
95241: LD_ADDR_EXP 184
95245: PUSH
95246: LD_EXP 184
95250: PPUSH
95251: LD_VAR 0 2
95255: PPUSH
95256: EMPTY
95257: PPUSH
95258: CALL_OW 1
95262: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
95263: LD_VAR 0 2
95267: PPUSH
95268: LD_INT 103
95270: PPUSH
95271: CALL 88913 0 2
// continue ;
95275: GO 95186
// end ; if mc_construct_list [ i ] then
95277: LD_EXP 185
95281: PUSH
95282: LD_VAR 0 2
95286: ARRAY
95287: IFFALSE 95507
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
95289: LD_ADDR_VAR 0 4
95293: PUSH
95294: LD_EXP 178
95298: PUSH
95299: LD_VAR 0 2
95303: ARRAY
95304: PPUSH
95305: LD_INT 25
95307: PUSH
95308: LD_INT 2
95310: PUSH
95311: EMPTY
95312: LIST
95313: LIST
95314: PPUSH
95315: CALL_OW 72
95319: PUSH
95320: LD_EXP 180
95324: PUSH
95325: LD_VAR 0 2
95329: ARRAY
95330: DIFF
95331: ST_TO_ADDR
// if not tmp then
95332: LD_VAR 0 4
95336: NOT
95337: IFFALSE 95341
// continue ;
95339: GO 95186
// for j in tmp do
95341: LD_ADDR_VAR 0 3
95345: PUSH
95346: LD_VAR 0 4
95350: PUSH
95351: FOR_IN
95352: IFFALSE 95503
// begin if not mc_builders [ i ] then
95354: LD_EXP 184
95358: PUSH
95359: LD_VAR 0 2
95363: ARRAY
95364: NOT
95365: IFFALSE 95423
// begin SetTag ( j , 103 ) ;
95367: LD_VAR 0 3
95371: PPUSH
95372: LD_INT 103
95374: PPUSH
95375: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
95379: LD_ADDR_EXP 184
95383: PUSH
95384: LD_EXP 184
95388: PPUSH
95389: LD_VAR 0 2
95393: PUSH
95394: LD_EXP 184
95398: PUSH
95399: LD_VAR 0 2
95403: ARRAY
95404: PUSH
95405: LD_INT 1
95407: PLUS
95408: PUSH
95409: EMPTY
95410: LIST
95411: LIST
95412: PPUSH
95413: LD_VAR 0 3
95417: PPUSH
95418: CALL 24210 0 3
95422: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
95423: LD_VAR 0 3
95427: PPUSH
95428: CALL_OW 310
95432: IFFALSE 95443
// ComExitBuilding ( j ) ;
95434: LD_VAR 0 3
95438: PPUSH
95439: CALL_OW 122
// wait ( 3 ) ;
95443: LD_INT 3
95445: PPUSH
95446: CALL_OW 67
// if not mc_construct_list [ i ] then
95450: LD_EXP 185
95454: PUSH
95455: LD_VAR 0 2
95459: ARRAY
95460: NOT
95461: IFFALSE 95465
// break ;
95463: GO 95503
// if not HasTask ( j ) then
95465: LD_VAR 0 3
95469: PPUSH
95470: CALL_OW 314
95474: NOT
95475: IFFALSE 95501
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
95477: LD_VAR 0 3
95481: PPUSH
95482: LD_EXP 185
95486: PUSH
95487: LD_VAR 0 2
95491: ARRAY
95492: PUSH
95493: LD_INT 1
95495: ARRAY
95496: PPUSH
95497: CALL 27073 0 2
// end ;
95501: GO 95351
95503: POP
95504: POP
// end else
95505: GO 96338
// if mc_build_list [ i ] then
95507: LD_EXP 183
95511: PUSH
95512: LD_VAR 0 2
95516: ARRAY
95517: IFFALSE 96338
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
95519: LD_ADDR_VAR 0 5
95523: PUSH
95524: LD_EXP 178
95528: PUSH
95529: LD_VAR 0 2
95533: ARRAY
95534: PPUSH
95535: LD_INT 2
95537: PUSH
95538: LD_INT 30
95540: PUSH
95541: LD_INT 0
95543: PUSH
95544: EMPTY
95545: LIST
95546: LIST
95547: PUSH
95548: LD_INT 30
95550: PUSH
95551: LD_INT 1
95553: PUSH
95554: EMPTY
95555: LIST
95556: LIST
95557: PUSH
95558: EMPTY
95559: LIST
95560: LIST
95561: LIST
95562: PPUSH
95563: CALL_OW 72
95567: ST_TO_ADDR
// if depot then
95568: LD_VAR 0 5
95572: IFFALSE 95590
// depot := depot [ 1 ] else
95574: LD_ADDR_VAR 0 5
95578: PUSH
95579: LD_VAR 0 5
95583: PUSH
95584: LD_INT 1
95586: ARRAY
95587: ST_TO_ADDR
95588: GO 95598
// depot := 0 ;
95590: LD_ADDR_VAR 0 5
95594: PUSH
95595: LD_INT 0
95597: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
95598: LD_EXP 183
95602: PUSH
95603: LD_VAR 0 2
95607: ARRAY
95608: PUSH
95609: LD_INT 1
95611: ARRAY
95612: PUSH
95613: LD_INT 1
95615: ARRAY
95616: PPUSH
95617: CALL 26897 0 1
95621: PUSH
95622: LD_EXP 178
95626: PUSH
95627: LD_VAR 0 2
95631: ARRAY
95632: PPUSH
95633: LD_INT 2
95635: PUSH
95636: LD_INT 30
95638: PUSH
95639: LD_INT 2
95641: PUSH
95642: EMPTY
95643: LIST
95644: LIST
95645: PUSH
95646: LD_INT 30
95648: PUSH
95649: LD_INT 3
95651: PUSH
95652: EMPTY
95653: LIST
95654: LIST
95655: PUSH
95656: EMPTY
95657: LIST
95658: LIST
95659: LIST
95660: PPUSH
95661: CALL_OW 72
95665: NOT
95666: AND
95667: IFFALSE 95772
// begin for j = 1 to mc_build_list [ i ] do
95669: LD_ADDR_VAR 0 3
95673: PUSH
95674: DOUBLE
95675: LD_INT 1
95677: DEC
95678: ST_TO_ADDR
95679: LD_EXP 183
95683: PUSH
95684: LD_VAR 0 2
95688: ARRAY
95689: PUSH
95690: FOR_TO
95691: IFFALSE 95770
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
95693: LD_EXP 183
95697: PUSH
95698: LD_VAR 0 2
95702: ARRAY
95703: PUSH
95704: LD_VAR 0 3
95708: ARRAY
95709: PUSH
95710: LD_INT 1
95712: ARRAY
95713: PUSH
95714: LD_INT 2
95716: EQUAL
95717: IFFALSE 95768
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
95719: LD_ADDR_EXP 183
95723: PUSH
95724: LD_EXP 183
95728: PPUSH
95729: LD_VAR 0 2
95733: PPUSH
95734: LD_EXP 183
95738: PUSH
95739: LD_VAR 0 2
95743: ARRAY
95744: PPUSH
95745: LD_VAR 0 3
95749: PPUSH
95750: LD_INT 1
95752: PPUSH
95753: LD_INT 0
95755: PPUSH
95756: CALL 23628 0 4
95760: PPUSH
95761: CALL_OW 1
95765: ST_TO_ADDR
// break ;
95766: GO 95770
// end ;
95768: GO 95690
95770: POP
95771: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
95772: LD_EXP 183
95776: PUSH
95777: LD_VAR 0 2
95781: ARRAY
95782: PUSH
95783: LD_INT 1
95785: ARRAY
95786: PUSH
95787: LD_INT 1
95789: ARRAY
95790: PUSH
95791: LD_INT 0
95793: EQUAL
95794: PUSH
95795: LD_VAR 0 5
95799: PUSH
95800: LD_VAR 0 5
95804: PPUSH
95805: LD_EXP 183
95809: PUSH
95810: LD_VAR 0 2
95814: ARRAY
95815: PUSH
95816: LD_INT 1
95818: ARRAY
95819: PUSH
95820: LD_INT 1
95822: ARRAY
95823: PPUSH
95824: LD_EXP 183
95828: PUSH
95829: LD_VAR 0 2
95833: ARRAY
95834: PUSH
95835: LD_INT 1
95837: ARRAY
95838: PUSH
95839: LD_INT 2
95841: ARRAY
95842: PPUSH
95843: LD_EXP 183
95847: PUSH
95848: LD_VAR 0 2
95852: ARRAY
95853: PUSH
95854: LD_INT 1
95856: ARRAY
95857: PUSH
95858: LD_INT 3
95860: ARRAY
95861: PPUSH
95862: LD_EXP 183
95866: PUSH
95867: LD_VAR 0 2
95871: ARRAY
95872: PUSH
95873: LD_INT 1
95875: ARRAY
95876: PUSH
95877: LD_INT 4
95879: ARRAY
95880: PPUSH
95881: CALL 32313 0 5
95885: AND
95886: OR
95887: IFFALSE 96168
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
95889: LD_ADDR_VAR 0 4
95893: PUSH
95894: LD_EXP 178
95898: PUSH
95899: LD_VAR 0 2
95903: ARRAY
95904: PPUSH
95905: LD_INT 25
95907: PUSH
95908: LD_INT 2
95910: PUSH
95911: EMPTY
95912: LIST
95913: LIST
95914: PPUSH
95915: CALL_OW 72
95919: PUSH
95920: LD_EXP 180
95924: PUSH
95925: LD_VAR 0 2
95929: ARRAY
95930: DIFF
95931: ST_TO_ADDR
// if not tmp then
95932: LD_VAR 0 4
95936: NOT
95937: IFFALSE 95941
// continue ;
95939: GO 95186
// for j in tmp do
95941: LD_ADDR_VAR 0 3
95945: PUSH
95946: LD_VAR 0 4
95950: PUSH
95951: FOR_IN
95952: IFFALSE 96164
// begin if not mc_builders [ i ] then
95954: LD_EXP 184
95958: PUSH
95959: LD_VAR 0 2
95963: ARRAY
95964: NOT
95965: IFFALSE 96023
// begin SetTag ( j , 103 ) ;
95967: LD_VAR 0 3
95971: PPUSH
95972: LD_INT 103
95974: PPUSH
95975: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
95979: LD_ADDR_EXP 184
95983: PUSH
95984: LD_EXP 184
95988: PPUSH
95989: LD_VAR 0 2
95993: PUSH
95994: LD_EXP 184
95998: PUSH
95999: LD_VAR 0 2
96003: ARRAY
96004: PUSH
96005: LD_INT 1
96007: PLUS
96008: PUSH
96009: EMPTY
96010: LIST
96011: LIST
96012: PPUSH
96013: LD_VAR 0 3
96017: PPUSH
96018: CALL 24210 0 3
96022: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
96023: LD_VAR 0 3
96027: PPUSH
96028: CALL_OW 310
96032: IFFALSE 96043
// ComExitBuilding ( j ) ;
96034: LD_VAR 0 3
96038: PPUSH
96039: CALL_OW 122
// wait ( 3 ) ;
96043: LD_INT 3
96045: PPUSH
96046: CALL_OW 67
// if not mc_build_list [ i ] then
96050: LD_EXP 183
96054: PUSH
96055: LD_VAR 0 2
96059: ARRAY
96060: NOT
96061: IFFALSE 96065
// break ;
96063: GO 96164
// if not HasTask ( j ) then
96065: LD_VAR 0 3
96069: PPUSH
96070: CALL_OW 314
96074: NOT
96075: IFFALSE 96162
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
96077: LD_VAR 0 3
96081: PPUSH
96082: LD_EXP 183
96086: PUSH
96087: LD_VAR 0 2
96091: ARRAY
96092: PUSH
96093: LD_INT 1
96095: ARRAY
96096: PUSH
96097: LD_INT 1
96099: ARRAY
96100: PPUSH
96101: LD_EXP 183
96105: PUSH
96106: LD_VAR 0 2
96110: ARRAY
96111: PUSH
96112: LD_INT 1
96114: ARRAY
96115: PUSH
96116: LD_INT 2
96118: ARRAY
96119: PPUSH
96120: LD_EXP 183
96124: PUSH
96125: LD_VAR 0 2
96129: ARRAY
96130: PUSH
96131: LD_INT 1
96133: ARRAY
96134: PUSH
96135: LD_INT 3
96137: ARRAY
96138: PPUSH
96139: LD_EXP 183
96143: PUSH
96144: LD_VAR 0 2
96148: ARRAY
96149: PUSH
96150: LD_INT 1
96152: ARRAY
96153: PUSH
96154: LD_INT 4
96156: ARRAY
96157: PPUSH
96158: CALL_OW 145
// end ;
96162: GO 95951
96164: POP
96165: POP
// end else
96166: GO 96338
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
96168: LD_EXP 178
96172: PUSH
96173: LD_VAR 0 2
96177: ARRAY
96178: PPUSH
96179: LD_EXP 183
96183: PUSH
96184: LD_VAR 0 2
96188: ARRAY
96189: PUSH
96190: LD_INT 1
96192: ARRAY
96193: PUSH
96194: LD_INT 1
96196: ARRAY
96197: PPUSH
96198: LD_EXP 183
96202: PUSH
96203: LD_VAR 0 2
96207: ARRAY
96208: PUSH
96209: LD_INT 1
96211: ARRAY
96212: PUSH
96213: LD_INT 2
96215: ARRAY
96216: PPUSH
96217: LD_EXP 183
96221: PUSH
96222: LD_VAR 0 2
96226: ARRAY
96227: PUSH
96228: LD_INT 1
96230: ARRAY
96231: PUSH
96232: LD_INT 3
96234: ARRAY
96235: PPUSH
96236: LD_EXP 183
96240: PUSH
96241: LD_VAR 0 2
96245: ARRAY
96246: PUSH
96247: LD_INT 1
96249: ARRAY
96250: PUSH
96251: LD_INT 4
96253: ARRAY
96254: PPUSH
96255: LD_EXP 178
96259: PUSH
96260: LD_VAR 0 2
96264: ARRAY
96265: PPUSH
96266: LD_INT 21
96268: PUSH
96269: LD_INT 3
96271: PUSH
96272: EMPTY
96273: LIST
96274: LIST
96275: PPUSH
96276: CALL_OW 72
96280: PPUSH
96281: EMPTY
96282: PPUSH
96283: CALL 31063 0 7
96287: NOT
96288: IFFALSE 96338
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
96290: LD_ADDR_EXP 183
96294: PUSH
96295: LD_EXP 183
96299: PPUSH
96300: LD_VAR 0 2
96304: PPUSH
96305: LD_EXP 183
96309: PUSH
96310: LD_VAR 0 2
96314: ARRAY
96315: PPUSH
96316: LD_INT 1
96318: PPUSH
96319: LD_INT 1
96321: NEG
96322: PPUSH
96323: LD_INT 0
96325: PPUSH
96326: CALL 23628 0 4
96330: PPUSH
96331: CALL_OW 1
96335: ST_TO_ADDR
// continue ;
96336: GO 95186
// end ; end ; end ;
96338: GO 95186
96340: POP
96341: POP
// end ;
96342: LD_VAR 0 1
96346: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
96347: LD_INT 0
96349: PPUSH
96350: PPUSH
96351: PPUSH
96352: PPUSH
96353: PPUSH
96354: PPUSH
// if not mc_bases then
96355: LD_EXP 178
96359: NOT
96360: IFFALSE 96364
// exit ;
96362: GO 96791
// for i = 1 to mc_bases do
96364: LD_ADDR_VAR 0 2
96368: PUSH
96369: DOUBLE
96370: LD_INT 1
96372: DEC
96373: ST_TO_ADDR
96374: LD_EXP 178
96378: PUSH
96379: FOR_TO
96380: IFFALSE 96789
// begin tmp := mc_build_upgrade [ i ] ;
96382: LD_ADDR_VAR 0 4
96386: PUSH
96387: LD_EXP 210
96391: PUSH
96392: LD_VAR 0 2
96396: ARRAY
96397: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
96398: LD_ADDR_VAR 0 6
96402: PUSH
96403: LD_EXP 211
96407: PUSH
96408: LD_VAR 0 2
96412: ARRAY
96413: PPUSH
96414: LD_INT 2
96416: PUSH
96417: LD_INT 30
96419: PUSH
96420: LD_INT 6
96422: PUSH
96423: EMPTY
96424: LIST
96425: LIST
96426: PUSH
96427: LD_INT 30
96429: PUSH
96430: LD_INT 7
96432: PUSH
96433: EMPTY
96434: LIST
96435: LIST
96436: PUSH
96437: EMPTY
96438: LIST
96439: LIST
96440: LIST
96441: PPUSH
96442: CALL_OW 72
96446: ST_TO_ADDR
// if not tmp and not lab then
96447: LD_VAR 0 4
96451: NOT
96452: PUSH
96453: LD_VAR 0 6
96457: NOT
96458: AND
96459: IFFALSE 96463
// continue ;
96461: GO 96379
// if tmp then
96463: LD_VAR 0 4
96467: IFFALSE 96587
// for j in tmp do
96469: LD_ADDR_VAR 0 3
96473: PUSH
96474: LD_VAR 0 4
96478: PUSH
96479: FOR_IN
96480: IFFALSE 96585
// begin if UpgradeCost ( j ) then
96482: LD_VAR 0 3
96486: PPUSH
96487: CALL 30723 0 1
96491: IFFALSE 96583
// begin ComUpgrade ( j ) ;
96493: LD_VAR 0 3
96497: PPUSH
96498: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
96502: LD_ADDR_EXP 210
96506: PUSH
96507: LD_EXP 210
96511: PPUSH
96512: LD_VAR 0 2
96516: PPUSH
96517: LD_EXP 210
96521: PUSH
96522: LD_VAR 0 2
96526: ARRAY
96527: PUSH
96528: LD_VAR 0 3
96532: DIFF
96533: PPUSH
96534: CALL_OW 1
96538: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
96539: LD_ADDR_EXP 185
96543: PUSH
96544: LD_EXP 185
96548: PPUSH
96549: LD_VAR 0 2
96553: PUSH
96554: LD_EXP 185
96558: PUSH
96559: LD_VAR 0 2
96563: ARRAY
96564: PUSH
96565: LD_INT 1
96567: PLUS
96568: PUSH
96569: EMPTY
96570: LIST
96571: LIST
96572: PPUSH
96573: LD_VAR 0 3
96577: PPUSH
96578: CALL 24210 0 3
96582: ST_TO_ADDR
// end ; end ;
96583: GO 96479
96585: POP
96586: POP
// if not lab or not mc_lab_upgrade [ i ] then
96587: LD_VAR 0 6
96591: NOT
96592: PUSH
96593: LD_EXP 212
96597: PUSH
96598: LD_VAR 0 2
96602: ARRAY
96603: NOT
96604: OR
96605: IFFALSE 96609
// continue ;
96607: GO 96379
// for j in lab do
96609: LD_ADDR_VAR 0 3
96613: PUSH
96614: LD_VAR 0 6
96618: PUSH
96619: FOR_IN
96620: IFFALSE 96785
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
96622: LD_VAR 0 3
96626: PPUSH
96627: CALL_OW 266
96631: PUSH
96632: LD_INT 6
96634: PUSH
96635: LD_INT 7
96637: PUSH
96638: EMPTY
96639: LIST
96640: LIST
96641: IN
96642: PUSH
96643: LD_VAR 0 3
96647: PPUSH
96648: CALL_OW 461
96652: PUSH
96653: LD_INT 1
96655: NONEQUAL
96656: AND
96657: IFFALSE 96783
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
96659: LD_VAR 0 3
96663: PPUSH
96664: LD_EXP 212
96668: PUSH
96669: LD_VAR 0 2
96673: ARRAY
96674: PUSH
96675: LD_INT 1
96677: ARRAY
96678: PPUSH
96679: CALL 30928 0 2
96683: IFFALSE 96783
// begin ComCancel ( j ) ;
96685: LD_VAR 0 3
96689: PPUSH
96690: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
96694: LD_VAR 0 3
96698: PPUSH
96699: LD_EXP 212
96703: PUSH
96704: LD_VAR 0 2
96708: ARRAY
96709: PUSH
96710: LD_INT 1
96712: ARRAY
96713: PPUSH
96714: CALL_OW 207
// if not j in mc_construct_list [ i ] then
96718: LD_VAR 0 3
96722: PUSH
96723: LD_EXP 185
96727: PUSH
96728: LD_VAR 0 2
96732: ARRAY
96733: IN
96734: NOT
96735: IFFALSE 96781
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
96737: LD_ADDR_EXP 185
96741: PUSH
96742: LD_EXP 185
96746: PPUSH
96747: LD_VAR 0 2
96751: PUSH
96752: LD_EXP 185
96756: PUSH
96757: LD_VAR 0 2
96761: ARRAY
96762: PUSH
96763: LD_INT 1
96765: PLUS
96766: PUSH
96767: EMPTY
96768: LIST
96769: LIST
96770: PPUSH
96771: LD_VAR 0 3
96775: PPUSH
96776: CALL 24210 0 3
96780: ST_TO_ADDR
// break ;
96781: GO 96785
// end ; end ; end ;
96783: GO 96619
96785: POP
96786: POP
// end ;
96787: GO 96379
96789: POP
96790: POP
// end ;
96791: LD_VAR 0 1
96795: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
96796: LD_INT 0
96798: PPUSH
96799: PPUSH
96800: PPUSH
96801: PPUSH
96802: PPUSH
96803: PPUSH
96804: PPUSH
96805: PPUSH
96806: PPUSH
// if not mc_bases then
96807: LD_EXP 178
96811: NOT
96812: IFFALSE 96816
// exit ;
96814: GO 97221
// for i = 1 to mc_bases do
96816: LD_ADDR_VAR 0 2
96820: PUSH
96821: DOUBLE
96822: LD_INT 1
96824: DEC
96825: ST_TO_ADDR
96826: LD_EXP 178
96830: PUSH
96831: FOR_TO
96832: IFFALSE 97219
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
96834: LD_EXP 186
96838: PUSH
96839: LD_VAR 0 2
96843: ARRAY
96844: NOT
96845: PUSH
96846: LD_EXP 178
96850: PUSH
96851: LD_VAR 0 2
96855: ARRAY
96856: PPUSH
96857: LD_INT 30
96859: PUSH
96860: LD_INT 3
96862: PUSH
96863: EMPTY
96864: LIST
96865: LIST
96866: PPUSH
96867: CALL_OW 72
96871: NOT
96872: OR
96873: IFFALSE 96877
// continue ;
96875: GO 96831
// busy := false ;
96877: LD_ADDR_VAR 0 8
96881: PUSH
96882: LD_INT 0
96884: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
96885: LD_ADDR_VAR 0 4
96889: PUSH
96890: LD_EXP 178
96894: PUSH
96895: LD_VAR 0 2
96899: ARRAY
96900: PPUSH
96901: LD_INT 30
96903: PUSH
96904: LD_INT 3
96906: PUSH
96907: EMPTY
96908: LIST
96909: LIST
96910: PPUSH
96911: CALL_OW 72
96915: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
96916: LD_ADDR_VAR 0 6
96920: PUSH
96921: LD_EXP 186
96925: PUSH
96926: LD_VAR 0 2
96930: ARRAY
96931: PPUSH
96932: LD_INT 2
96934: PUSH
96935: LD_INT 30
96937: PUSH
96938: LD_INT 32
96940: PUSH
96941: EMPTY
96942: LIST
96943: LIST
96944: PUSH
96945: LD_INT 30
96947: PUSH
96948: LD_INT 33
96950: PUSH
96951: EMPTY
96952: LIST
96953: LIST
96954: PUSH
96955: EMPTY
96956: LIST
96957: LIST
96958: LIST
96959: PPUSH
96960: CALL_OW 72
96964: ST_TO_ADDR
// if not t then
96965: LD_VAR 0 6
96969: NOT
96970: IFFALSE 96974
// continue ;
96972: GO 96831
// for j in tmp do
96974: LD_ADDR_VAR 0 3
96978: PUSH
96979: LD_VAR 0 4
96983: PUSH
96984: FOR_IN
96985: IFFALSE 97015
// if not BuildingStatus ( j ) = bs_idle then
96987: LD_VAR 0 3
96991: PPUSH
96992: CALL_OW 461
96996: PUSH
96997: LD_INT 2
96999: EQUAL
97000: NOT
97001: IFFALSE 97013
// begin busy := true ;
97003: LD_ADDR_VAR 0 8
97007: PUSH
97008: LD_INT 1
97010: ST_TO_ADDR
// break ;
97011: GO 97015
// end ;
97013: GO 96984
97015: POP
97016: POP
// if busy then
97017: LD_VAR 0 8
97021: IFFALSE 97025
// continue ;
97023: GO 96831
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
97025: LD_ADDR_VAR 0 7
97029: PUSH
97030: LD_VAR 0 6
97034: PPUSH
97035: LD_INT 35
97037: PUSH
97038: LD_INT 0
97040: PUSH
97041: EMPTY
97042: LIST
97043: LIST
97044: PPUSH
97045: CALL_OW 72
97049: ST_TO_ADDR
// if tw then
97050: LD_VAR 0 7
97054: IFFALSE 97131
// begin tw := tw [ 1 ] ;
97056: LD_ADDR_VAR 0 7
97060: PUSH
97061: LD_VAR 0 7
97065: PUSH
97066: LD_INT 1
97068: ARRAY
97069: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
97070: LD_ADDR_VAR 0 9
97074: PUSH
97075: LD_VAR 0 7
97079: PPUSH
97080: LD_EXP 203
97084: PUSH
97085: LD_VAR 0 2
97089: ARRAY
97090: PPUSH
97091: CALL 29220 0 2
97095: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
97096: LD_EXP 217
97100: PUSH
97101: LD_VAR 0 2
97105: ARRAY
97106: IFFALSE 97129
// if not weapon in mc_allowed_tower_weapons [ i ] then
97108: LD_VAR 0 9
97112: PUSH
97113: LD_EXP 217
97117: PUSH
97118: LD_VAR 0 2
97122: ARRAY
97123: IN
97124: NOT
97125: IFFALSE 97129
// continue ;
97127: GO 96831
// end else
97129: GO 97194
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
97131: LD_ADDR_VAR 0 5
97135: PUSH
97136: LD_EXP 186
97140: PUSH
97141: LD_VAR 0 2
97145: ARRAY
97146: PPUSH
97147: LD_VAR 0 4
97151: PPUSH
97152: CALL 55509 0 2
97156: ST_TO_ADDR
// if not tmp2 then
97157: LD_VAR 0 5
97161: NOT
97162: IFFALSE 97166
// continue ;
97164: GO 96831
// tw := tmp2 [ 1 ] ;
97166: LD_ADDR_VAR 0 7
97170: PUSH
97171: LD_VAR 0 5
97175: PUSH
97176: LD_INT 1
97178: ARRAY
97179: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
97180: LD_ADDR_VAR 0 9
97184: PUSH
97185: LD_VAR 0 5
97189: PUSH
97190: LD_INT 2
97192: ARRAY
97193: ST_TO_ADDR
// end ; if not weapon then
97194: LD_VAR 0 9
97198: NOT
97199: IFFALSE 97203
// continue ;
97201: GO 96831
// ComPlaceWeapon ( tw , weapon ) ;
97203: LD_VAR 0 7
97207: PPUSH
97208: LD_VAR 0 9
97212: PPUSH
97213: CALL_OW 148
// end ;
97217: GO 96831
97219: POP
97220: POP
// end ;
97221: LD_VAR 0 1
97225: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
97226: LD_INT 0
97228: PPUSH
97229: PPUSH
97230: PPUSH
97231: PPUSH
97232: PPUSH
97233: PPUSH
97234: PPUSH
// if not mc_bases then
97235: LD_EXP 178
97239: NOT
97240: IFFALSE 97244
// exit ;
97242: GO 98012
// for i = 1 to mc_bases do
97244: LD_ADDR_VAR 0 2
97248: PUSH
97249: DOUBLE
97250: LD_INT 1
97252: DEC
97253: ST_TO_ADDR
97254: LD_EXP 178
97258: PUSH
97259: FOR_TO
97260: IFFALSE 98010
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
97262: LD_EXP 191
97266: PUSH
97267: LD_VAR 0 2
97271: ARRAY
97272: NOT
97273: PUSH
97274: LD_EXP 191
97278: PUSH
97279: LD_VAR 0 2
97283: ARRAY
97284: PUSH
97285: LD_EXP 192
97289: PUSH
97290: LD_VAR 0 2
97294: ARRAY
97295: EQUAL
97296: OR
97297: PUSH
97298: LD_EXP 201
97302: PUSH
97303: LD_VAR 0 2
97307: ARRAY
97308: OR
97309: IFFALSE 97313
// continue ;
97311: GO 97259
// if mc_miners [ i ] then
97313: LD_EXP 192
97317: PUSH
97318: LD_VAR 0 2
97322: ARRAY
97323: IFFALSE 97697
// begin for j = mc_miners [ i ] downto 1 do
97325: LD_ADDR_VAR 0 3
97329: PUSH
97330: DOUBLE
97331: LD_EXP 192
97335: PUSH
97336: LD_VAR 0 2
97340: ARRAY
97341: INC
97342: ST_TO_ADDR
97343: LD_INT 1
97345: PUSH
97346: FOR_DOWNTO
97347: IFFALSE 97695
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
97349: LD_EXP 192
97353: PUSH
97354: LD_VAR 0 2
97358: ARRAY
97359: PUSH
97360: LD_VAR 0 3
97364: ARRAY
97365: PPUSH
97366: CALL_OW 301
97370: PUSH
97371: LD_EXP 192
97375: PUSH
97376: LD_VAR 0 2
97380: ARRAY
97381: PUSH
97382: LD_VAR 0 3
97386: ARRAY
97387: PPUSH
97388: CALL_OW 257
97392: PUSH
97393: LD_INT 1
97395: NONEQUAL
97396: OR
97397: IFFALSE 97460
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
97399: LD_ADDR_VAR 0 5
97403: PUSH
97404: LD_EXP 192
97408: PUSH
97409: LD_VAR 0 2
97413: ARRAY
97414: PUSH
97415: LD_EXP 192
97419: PUSH
97420: LD_VAR 0 2
97424: ARRAY
97425: PUSH
97426: LD_VAR 0 3
97430: ARRAY
97431: DIFF
97432: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
97433: LD_ADDR_EXP 192
97437: PUSH
97438: LD_EXP 192
97442: PPUSH
97443: LD_VAR 0 2
97447: PPUSH
97448: LD_VAR 0 5
97452: PPUSH
97453: CALL_OW 1
97457: ST_TO_ADDR
// continue ;
97458: GO 97346
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
97460: LD_EXP 192
97464: PUSH
97465: LD_VAR 0 2
97469: ARRAY
97470: PUSH
97471: LD_VAR 0 3
97475: ARRAY
97476: PPUSH
97477: CALL_OW 257
97481: PUSH
97482: LD_INT 1
97484: EQUAL
97485: PUSH
97486: LD_EXP 192
97490: PUSH
97491: LD_VAR 0 2
97495: ARRAY
97496: PUSH
97497: LD_VAR 0 3
97501: ARRAY
97502: PPUSH
97503: CALL_OW 459
97507: NOT
97508: AND
97509: PUSH
97510: LD_EXP 192
97514: PUSH
97515: LD_VAR 0 2
97519: ARRAY
97520: PUSH
97521: LD_VAR 0 3
97525: ARRAY
97526: PPUSH
97527: CALL_OW 314
97531: NOT
97532: AND
97533: IFFALSE 97693
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
97535: LD_EXP 192
97539: PUSH
97540: LD_VAR 0 2
97544: ARRAY
97545: PUSH
97546: LD_VAR 0 3
97550: ARRAY
97551: PPUSH
97552: CALL_OW 310
97556: IFFALSE 97579
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
97558: LD_EXP 192
97562: PUSH
97563: LD_VAR 0 2
97567: ARRAY
97568: PUSH
97569: LD_VAR 0 3
97573: ARRAY
97574: PPUSH
97575: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
97579: LD_EXP 192
97583: PUSH
97584: LD_VAR 0 2
97588: ARRAY
97589: PUSH
97590: LD_VAR 0 3
97594: ARRAY
97595: PPUSH
97596: CALL_OW 314
97600: NOT
97601: IFFALSE 97693
// begin r := rand ( 1 , mc_mines [ i ] ) ;
97603: LD_ADDR_VAR 0 7
97607: PUSH
97608: LD_INT 1
97610: PPUSH
97611: LD_EXP 191
97615: PUSH
97616: LD_VAR 0 2
97620: ARRAY
97621: PPUSH
97622: CALL_OW 12
97626: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
97627: LD_EXP 192
97631: PUSH
97632: LD_VAR 0 2
97636: ARRAY
97637: PUSH
97638: LD_VAR 0 3
97642: ARRAY
97643: PPUSH
97644: LD_EXP 191
97648: PUSH
97649: LD_VAR 0 2
97653: ARRAY
97654: PUSH
97655: LD_VAR 0 7
97659: ARRAY
97660: PUSH
97661: LD_INT 1
97663: ARRAY
97664: PPUSH
97665: LD_EXP 191
97669: PUSH
97670: LD_VAR 0 2
97674: ARRAY
97675: PUSH
97676: LD_VAR 0 7
97680: ARRAY
97681: PUSH
97682: LD_INT 2
97684: ARRAY
97685: PPUSH
97686: LD_INT 0
97688: PPUSH
97689: CALL_OW 193
// end ; end ; end ;
97693: GO 97346
97695: POP
97696: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
97697: LD_ADDR_VAR 0 5
97701: PUSH
97702: LD_EXP 178
97706: PUSH
97707: LD_VAR 0 2
97711: ARRAY
97712: PPUSH
97713: LD_INT 2
97715: PUSH
97716: LD_INT 30
97718: PUSH
97719: LD_INT 4
97721: PUSH
97722: EMPTY
97723: LIST
97724: LIST
97725: PUSH
97726: LD_INT 30
97728: PUSH
97729: LD_INT 5
97731: PUSH
97732: EMPTY
97733: LIST
97734: LIST
97735: PUSH
97736: LD_INT 30
97738: PUSH
97739: LD_INT 32
97741: PUSH
97742: EMPTY
97743: LIST
97744: LIST
97745: PUSH
97746: EMPTY
97747: LIST
97748: LIST
97749: LIST
97750: LIST
97751: PPUSH
97752: CALL_OW 72
97756: ST_TO_ADDR
// if not tmp then
97757: LD_VAR 0 5
97761: NOT
97762: IFFALSE 97766
// continue ;
97764: GO 97259
// list := [ ] ;
97766: LD_ADDR_VAR 0 6
97770: PUSH
97771: EMPTY
97772: ST_TO_ADDR
// for j in tmp do
97773: LD_ADDR_VAR 0 3
97777: PUSH
97778: LD_VAR 0 5
97782: PUSH
97783: FOR_IN
97784: IFFALSE 97853
// begin for k in UnitsInside ( j ) do
97786: LD_ADDR_VAR 0 4
97790: PUSH
97791: LD_VAR 0 3
97795: PPUSH
97796: CALL_OW 313
97800: PUSH
97801: FOR_IN
97802: IFFALSE 97849
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
97804: LD_VAR 0 4
97808: PPUSH
97809: CALL_OW 257
97813: PUSH
97814: LD_INT 1
97816: EQUAL
97817: PUSH
97818: LD_VAR 0 4
97822: PPUSH
97823: CALL_OW 459
97827: NOT
97828: AND
97829: IFFALSE 97847
// list := list ^ k ;
97831: LD_ADDR_VAR 0 6
97835: PUSH
97836: LD_VAR 0 6
97840: PUSH
97841: LD_VAR 0 4
97845: ADD
97846: ST_TO_ADDR
97847: GO 97801
97849: POP
97850: POP
// end ;
97851: GO 97783
97853: POP
97854: POP
// list := list diff mc_miners [ i ] ;
97855: LD_ADDR_VAR 0 6
97859: PUSH
97860: LD_VAR 0 6
97864: PUSH
97865: LD_EXP 192
97869: PUSH
97870: LD_VAR 0 2
97874: ARRAY
97875: DIFF
97876: ST_TO_ADDR
// if not list then
97877: LD_VAR 0 6
97881: NOT
97882: IFFALSE 97886
// continue ;
97884: GO 97259
// k := mc_mines [ i ] - mc_miners [ i ] ;
97886: LD_ADDR_VAR 0 4
97890: PUSH
97891: LD_EXP 191
97895: PUSH
97896: LD_VAR 0 2
97900: ARRAY
97901: PUSH
97902: LD_EXP 192
97906: PUSH
97907: LD_VAR 0 2
97911: ARRAY
97912: MINUS
97913: ST_TO_ADDR
// if k > list then
97914: LD_VAR 0 4
97918: PUSH
97919: LD_VAR 0 6
97923: GREATER
97924: IFFALSE 97936
// k := list ;
97926: LD_ADDR_VAR 0 4
97930: PUSH
97931: LD_VAR 0 6
97935: ST_TO_ADDR
// for j = 1 to k do
97936: LD_ADDR_VAR 0 3
97940: PUSH
97941: DOUBLE
97942: LD_INT 1
97944: DEC
97945: ST_TO_ADDR
97946: LD_VAR 0 4
97950: PUSH
97951: FOR_TO
97952: IFFALSE 98006
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
97954: LD_ADDR_EXP 192
97958: PUSH
97959: LD_EXP 192
97963: PPUSH
97964: LD_VAR 0 2
97968: PUSH
97969: LD_EXP 192
97973: PUSH
97974: LD_VAR 0 2
97978: ARRAY
97979: PUSH
97980: LD_INT 1
97982: PLUS
97983: PUSH
97984: EMPTY
97985: LIST
97986: LIST
97987: PPUSH
97988: LD_VAR 0 6
97992: PUSH
97993: LD_VAR 0 3
97997: ARRAY
97998: PPUSH
97999: CALL 24210 0 3
98003: ST_TO_ADDR
98004: GO 97951
98006: POP
98007: POP
// end ;
98008: GO 97259
98010: POP
98011: POP
// end ;
98012: LD_VAR 0 1
98016: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , side , target , cargo , depot , fac , components ; begin
98017: LD_INT 0
98019: PPUSH
98020: PPUSH
98021: PPUSH
98022: PPUSH
98023: PPUSH
98024: PPUSH
98025: PPUSH
98026: PPUSH
98027: PPUSH
98028: PPUSH
98029: PPUSH
// if not mc_bases then
98030: LD_EXP 178
98034: NOT
98035: IFFALSE 98039
// exit ;
98037: GO 99862
// for i = 1 to mc_bases do
98039: LD_ADDR_VAR 0 2
98043: PUSH
98044: DOUBLE
98045: LD_INT 1
98047: DEC
98048: ST_TO_ADDR
98049: LD_EXP 178
98053: PUSH
98054: FOR_TO
98055: IFFALSE 99860
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
98057: LD_EXP 178
98061: PUSH
98062: LD_VAR 0 2
98066: ARRAY
98067: NOT
98068: PUSH
98069: LD_EXP 185
98073: PUSH
98074: LD_VAR 0 2
98078: ARRAY
98079: OR
98080: IFFALSE 98084
// continue ;
98082: GO 98054
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
98084: LD_EXP 194
98088: PUSH
98089: LD_VAR 0 2
98093: ARRAY
98094: NOT
98095: PUSH
98096: LD_EXP 195
98100: PUSH
98101: LD_VAR 0 2
98105: ARRAY
98106: AND
98107: IFFALSE 98145
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
98109: LD_ADDR_EXP 195
98113: PUSH
98114: LD_EXP 195
98118: PPUSH
98119: LD_VAR 0 2
98123: PPUSH
98124: EMPTY
98125: PPUSH
98126: CALL_OW 1
98130: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
98131: LD_VAR 0 2
98135: PPUSH
98136: LD_INT 107
98138: PPUSH
98139: CALL 88913 0 2
// continue ;
98143: GO 98054
// end ; target := [ ] ;
98145: LD_ADDR_VAR 0 7
98149: PUSH
98150: EMPTY
98151: ST_TO_ADDR
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
98152: LD_ADDR_VAR 0 6
98156: PUSH
98157: LD_EXP 178
98161: PUSH
98162: LD_VAR 0 2
98166: ARRAY
98167: PUSH
98168: LD_INT 1
98170: ARRAY
98171: PPUSH
98172: CALL_OW 255
98176: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
98177: LD_ADDR_VAR 0 9
98181: PUSH
98182: LD_EXP 178
98186: PUSH
98187: LD_VAR 0 2
98191: ARRAY
98192: PPUSH
98193: LD_INT 2
98195: PUSH
98196: LD_INT 30
98198: PUSH
98199: LD_INT 0
98201: PUSH
98202: EMPTY
98203: LIST
98204: LIST
98205: PUSH
98206: LD_INT 30
98208: PUSH
98209: LD_INT 1
98211: PUSH
98212: EMPTY
98213: LIST
98214: LIST
98215: PUSH
98216: EMPTY
98217: LIST
98218: LIST
98219: LIST
98220: PPUSH
98221: CALL_OW 72
98225: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
98226: LD_ADDR_VAR 0 3
98230: PUSH
98231: DOUBLE
98232: LD_EXP 194
98236: PUSH
98237: LD_VAR 0 2
98241: ARRAY
98242: INC
98243: ST_TO_ADDR
98244: LD_INT 1
98246: PUSH
98247: FOR_DOWNTO
98248: IFFALSE 98493
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
98250: LD_EXP 194
98254: PUSH
98255: LD_VAR 0 2
98259: ARRAY
98260: PUSH
98261: LD_VAR 0 3
98265: ARRAY
98266: PUSH
98267: LD_INT 2
98269: ARRAY
98270: PPUSH
98271: LD_EXP 194
98275: PUSH
98276: LD_VAR 0 2
98280: ARRAY
98281: PUSH
98282: LD_VAR 0 3
98286: ARRAY
98287: PUSH
98288: LD_INT 3
98290: ARRAY
98291: PPUSH
98292: CALL_OW 488
98296: PUSH
98297: LD_EXP 194
98301: PUSH
98302: LD_VAR 0 2
98306: ARRAY
98307: PUSH
98308: LD_VAR 0 3
98312: ARRAY
98313: PUSH
98314: LD_INT 2
98316: ARRAY
98317: PPUSH
98318: LD_EXP 194
98322: PUSH
98323: LD_VAR 0 2
98327: ARRAY
98328: PUSH
98329: LD_VAR 0 3
98333: ARRAY
98334: PUSH
98335: LD_INT 3
98337: ARRAY
98338: PPUSH
98339: CALL_OW 284
98343: PUSH
98344: LD_INT 0
98346: EQUAL
98347: AND
98348: IFFALSE 98403
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
98350: LD_ADDR_VAR 0 5
98354: PUSH
98355: LD_EXP 194
98359: PUSH
98360: LD_VAR 0 2
98364: ARRAY
98365: PPUSH
98366: LD_VAR 0 3
98370: PPUSH
98371: CALL_OW 3
98375: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
98376: LD_ADDR_EXP 194
98380: PUSH
98381: LD_EXP 194
98385: PPUSH
98386: LD_VAR 0 2
98390: PPUSH
98391: LD_VAR 0 5
98395: PPUSH
98396: CALL_OW 1
98400: ST_TO_ADDR
// continue ;
98401: GO 98247
// end ; if DangerAtRangeXY ( side , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
98403: LD_VAR 0 6
98407: PPUSH
98408: LD_EXP 194
98412: PUSH
98413: LD_VAR 0 2
98417: ARRAY
98418: PUSH
98419: LD_VAR 0 3
98423: ARRAY
98424: PUSH
98425: LD_INT 2
98427: ARRAY
98428: PPUSH
98429: LD_EXP 194
98433: PUSH
98434: LD_VAR 0 2
98438: ARRAY
98439: PUSH
98440: LD_VAR 0 3
98444: ARRAY
98445: PUSH
98446: LD_INT 3
98448: ARRAY
98449: PPUSH
98450: LD_INT 30
98452: PPUSH
98453: CALL 25106 0 4
98457: PUSH
98458: LD_INT 4
98460: ARRAY
98461: PUSH
98462: LD_INT 0
98464: EQUAL
98465: IFFALSE 98491
// begin target := mc_crates [ i ] [ j ] ;
98467: LD_ADDR_VAR 0 7
98471: PUSH
98472: LD_EXP 194
98476: PUSH
98477: LD_VAR 0 2
98481: ARRAY
98482: PUSH
98483: LD_VAR 0 3
98487: ARRAY
98488: ST_TO_ADDR
// break ;
98489: GO 98493
// end ; end ;
98491: GO 98247
98493: POP
98494: POP
// if not target then
98495: LD_VAR 0 7
98499: NOT
98500: IFFALSE 98504
// continue ;
98502: GO 98054
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
98504: LD_ADDR_VAR 0 8
98508: PUSH
98509: LD_EXP 197
98513: PUSH
98514: LD_VAR 0 2
98518: ARRAY
98519: PPUSH
98520: LD_INT 2
98522: PUSH
98523: LD_INT 3
98525: PUSH
98526: LD_INT 58
98528: PUSH
98529: EMPTY
98530: LIST
98531: PUSH
98532: EMPTY
98533: LIST
98534: LIST
98535: PUSH
98536: LD_INT 61
98538: PUSH
98539: EMPTY
98540: LIST
98541: PUSH
98542: LD_INT 33
98544: PUSH
98545: LD_INT 5
98547: PUSH
98548: EMPTY
98549: LIST
98550: LIST
98551: PUSH
98552: LD_INT 33
98554: PUSH
98555: LD_INT 3
98557: PUSH
98558: EMPTY
98559: LIST
98560: LIST
98561: PUSH
98562: EMPTY
98563: LIST
98564: LIST
98565: LIST
98566: LIST
98567: LIST
98568: PUSH
98569: LD_INT 2
98571: PUSH
98572: LD_INT 34
98574: PUSH
98575: LD_INT 32
98577: PUSH
98578: EMPTY
98579: LIST
98580: LIST
98581: PUSH
98582: LD_INT 34
98584: PUSH
98585: LD_INT 51
98587: PUSH
98588: EMPTY
98589: LIST
98590: LIST
98591: PUSH
98592: LD_INT 34
98594: PUSH
98595: LD_INT 12
98597: PUSH
98598: EMPTY
98599: LIST
98600: LIST
98601: PUSH
98602: EMPTY
98603: LIST
98604: LIST
98605: LIST
98606: LIST
98607: PUSH
98608: EMPTY
98609: LIST
98610: LIST
98611: PPUSH
98612: CALL_OW 72
98616: ST_TO_ADDR
// if not cargo then
98617: LD_VAR 0 8
98621: NOT
98622: IFFALSE 99328
// begin if mc_crates_collector [ i ] < 5 then
98624: LD_EXP 195
98628: PUSH
98629: LD_VAR 0 2
98633: ARRAY
98634: PUSH
98635: LD_INT 5
98637: LESS
98638: IFFALSE 99004
// begin if mc_ape [ i ] then
98640: LD_EXP 207
98644: PUSH
98645: LD_VAR 0 2
98649: ARRAY
98650: IFFALSE 98697
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
98652: LD_ADDR_VAR 0 5
98656: PUSH
98657: LD_EXP 207
98661: PUSH
98662: LD_VAR 0 2
98666: ARRAY
98667: PPUSH
98668: LD_INT 25
98670: PUSH
98671: LD_INT 16
98673: PUSH
98674: EMPTY
98675: LIST
98676: LIST
98677: PUSH
98678: LD_INT 24
98680: PUSH
98681: LD_INT 750
98683: PUSH
98684: EMPTY
98685: LIST
98686: LIST
98687: PUSH
98688: EMPTY
98689: LIST
98690: LIST
98691: PPUSH
98692: CALL_OW 72
98696: ST_TO_ADDR
// if not tmp then
98697: LD_VAR 0 5
98701: NOT
98702: IFFALSE 98749
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
98704: LD_ADDR_VAR 0 5
98708: PUSH
98709: LD_EXP 178
98713: PUSH
98714: LD_VAR 0 2
98718: ARRAY
98719: PPUSH
98720: LD_INT 25
98722: PUSH
98723: LD_INT 2
98725: PUSH
98726: EMPTY
98727: LIST
98728: LIST
98729: PUSH
98730: LD_INT 24
98732: PUSH
98733: LD_INT 750
98735: PUSH
98736: EMPTY
98737: LIST
98738: LIST
98739: PUSH
98740: EMPTY
98741: LIST
98742: LIST
98743: PPUSH
98744: CALL_OW 72
98748: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
98749: LD_EXP 207
98753: PUSH
98754: LD_VAR 0 2
98758: ARRAY
98759: PUSH
98760: LD_EXP 178
98764: PUSH
98765: LD_VAR 0 2
98769: ARRAY
98770: PPUSH
98771: LD_INT 25
98773: PUSH
98774: LD_INT 2
98776: PUSH
98777: EMPTY
98778: LIST
98779: LIST
98780: PUSH
98781: LD_INT 24
98783: PUSH
98784: LD_INT 750
98786: PUSH
98787: EMPTY
98788: LIST
98789: LIST
98790: PUSH
98791: EMPTY
98792: LIST
98793: LIST
98794: PPUSH
98795: CALL_OW 72
98799: AND
98800: PUSH
98801: LD_VAR 0 5
98805: PUSH
98806: LD_INT 5
98808: LESS
98809: AND
98810: IFFALSE 98892
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
98812: LD_ADDR_VAR 0 3
98816: PUSH
98817: LD_EXP 178
98821: PUSH
98822: LD_VAR 0 2
98826: ARRAY
98827: PPUSH
98828: LD_INT 25
98830: PUSH
98831: LD_INT 2
98833: PUSH
98834: EMPTY
98835: LIST
98836: LIST
98837: PUSH
98838: LD_INT 24
98840: PUSH
98841: LD_INT 750
98843: PUSH
98844: EMPTY
98845: LIST
98846: LIST
98847: PUSH
98848: EMPTY
98849: LIST
98850: LIST
98851: PPUSH
98852: CALL_OW 72
98856: PUSH
98857: FOR_IN
98858: IFFALSE 98890
// begin tmp := tmp union j ;
98860: LD_ADDR_VAR 0 5
98864: PUSH
98865: LD_VAR 0 5
98869: PUSH
98870: LD_VAR 0 3
98874: UNION
98875: ST_TO_ADDR
// if tmp >= 5 then
98876: LD_VAR 0 5
98880: PUSH
98881: LD_INT 5
98883: GREATEREQUAL
98884: IFFALSE 98888
// break ;
98886: GO 98890
// end ;
98888: GO 98857
98890: POP
98891: POP
// end ; if not tmp then
98892: LD_VAR 0 5
98896: NOT
98897: IFFALSE 98901
// continue ;
98899: GO 98054
// for j in tmp do
98901: LD_ADDR_VAR 0 3
98905: PUSH
98906: LD_VAR 0 5
98910: PUSH
98911: FOR_IN
98912: IFFALSE 99002
// if not GetTag ( j ) then
98914: LD_VAR 0 3
98918: PPUSH
98919: CALL_OW 110
98923: NOT
98924: IFFALSE 99000
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
98926: LD_ADDR_EXP 195
98930: PUSH
98931: LD_EXP 195
98935: PPUSH
98936: LD_VAR 0 2
98940: PUSH
98941: LD_EXP 195
98945: PUSH
98946: LD_VAR 0 2
98950: ARRAY
98951: PUSH
98952: LD_INT 1
98954: PLUS
98955: PUSH
98956: EMPTY
98957: LIST
98958: LIST
98959: PPUSH
98960: LD_VAR 0 3
98964: PPUSH
98965: CALL 24210 0 3
98969: ST_TO_ADDR
// SetTag ( j , 107 ) ;
98970: LD_VAR 0 3
98974: PPUSH
98975: LD_INT 107
98977: PPUSH
98978: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
98982: LD_EXP 195
98986: PUSH
98987: LD_VAR 0 2
98991: ARRAY
98992: PUSH
98993: LD_INT 5
98995: GREATEREQUAL
98996: IFFALSE 99000
// break ;
98998: GO 99002
// end ;
99000: GO 98911
99002: POP
99003: POP
// end ; if mc_crates_collector [ i ] and target then
99004: LD_EXP 195
99008: PUSH
99009: LD_VAR 0 2
99013: ARRAY
99014: PUSH
99015: LD_VAR 0 7
99019: AND
99020: IFFALSE 99326
// begin if mc_crates_collector [ i ] < target [ 1 ] then
99022: LD_EXP 195
99026: PUSH
99027: LD_VAR 0 2
99031: ARRAY
99032: PUSH
99033: LD_VAR 0 7
99037: PUSH
99038: LD_INT 1
99040: ARRAY
99041: LESS
99042: IFFALSE 99062
// tmp := mc_crates_collector [ i ] else
99044: LD_ADDR_VAR 0 5
99048: PUSH
99049: LD_EXP 195
99053: PUSH
99054: LD_VAR 0 2
99058: ARRAY
99059: ST_TO_ADDR
99060: GO 99076
// tmp := target [ 1 ] ;
99062: LD_ADDR_VAR 0 5
99066: PUSH
99067: LD_VAR 0 7
99071: PUSH
99072: LD_INT 1
99074: ARRAY
99075: ST_TO_ADDR
// k := 0 ;
99076: LD_ADDR_VAR 0 4
99080: PUSH
99081: LD_INT 0
99083: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
99084: LD_ADDR_VAR 0 3
99088: PUSH
99089: LD_EXP 195
99093: PUSH
99094: LD_VAR 0 2
99098: ARRAY
99099: PUSH
99100: FOR_IN
99101: IFFALSE 99324
// begin k := k + 1 ;
99103: LD_ADDR_VAR 0 4
99107: PUSH
99108: LD_VAR 0 4
99112: PUSH
99113: LD_INT 1
99115: PLUS
99116: ST_TO_ADDR
// if k > tmp then
99117: LD_VAR 0 4
99121: PUSH
99122: LD_VAR 0 5
99126: GREATER
99127: IFFALSE 99131
// break ;
99129: GO 99324
// if not GetClass ( j ) in [ 2 , 16 ] then
99131: LD_VAR 0 3
99135: PPUSH
99136: CALL_OW 257
99140: PUSH
99141: LD_INT 2
99143: PUSH
99144: LD_INT 16
99146: PUSH
99147: EMPTY
99148: LIST
99149: LIST
99150: IN
99151: NOT
99152: IFFALSE 99205
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
99154: LD_ADDR_EXP 195
99158: PUSH
99159: LD_EXP 195
99163: PPUSH
99164: LD_VAR 0 2
99168: PPUSH
99169: LD_EXP 195
99173: PUSH
99174: LD_VAR 0 2
99178: ARRAY
99179: PUSH
99180: LD_VAR 0 3
99184: DIFF
99185: PPUSH
99186: CALL_OW 1
99190: ST_TO_ADDR
// SetTag ( j , 0 ) ;
99191: LD_VAR 0 3
99195: PPUSH
99196: LD_INT 0
99198: PPUSH
99199: CALL_OW 109
// continue ;
99203: GO 99100
// end ; if IsInUnit ( j ) then
99205: LD_VAR 0 3
99209: PPUSH
99210: CALL_OW 310
99214: IFFALSE 99225
// ComExitBuilding ( j ) ;
99216: LD_VAR 0 3
99220: PPUSH
99221: CALL_OW 122
// wait ( 3 ) ;
99225: LD_INT 3
99227: PPUSH
99228: CALL_OW 67
// if HasTask ( j ) and DangerAtRangeXY ( side , target [ 2 ] , target [ 3 ] , 30 ) [ 4 ] then
99232: LD_VAR 0 3
99236: PPUSH
99237: CALL_OW 314
99241: PUSH
99242: LD_VAR 0 6
99246: PPUSH
99247: LD_VAR 0 7
99251: PUSH
99252: LD_INT 2
99254: ARRAY
99255: PPUSH
99256: LD_VAR 0 7
99260: PUSH
99261: LD_INT 3
99263: ARRAY
99264: PPUSH
99265: LD_INT 30
99267: PPUSH
99268: CALL 25106 0 4
99272: PUSH
99273: LD_INT 4
99275: ARRAY
99276: AND
99277: IFFALSE 99295
// ComStandNearbyBuilding ( j , depot ) else
99279: LD_VAR 0 3
99283: PPUSH
99284: LD_VAR 0 9
99288: PPUSH
99289: CALL 20788 0 2
99293: GO 99322
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
99295: LD_VAR 0 3
99299: PPUSH
99300: LD_VAR 0 7
99304: PUSH
99305: LD_INT 2
99307: ARRAY
99308: PPUSH
99309: LD_VAR 0 7
99313: PUSH
99314: LD_INT 3
99316: ARRAY
99317: PPUSH
99318: CALL_OW 117
// end ;
99322: GO 99100
99324: POP
99325: POP
// end ; end else
99326: GO 99858
// begin for j in cargo do
99328: LD_ADDR_VAR 0 3
99332: PUSH
99333: LD_VAR 0 8
99337: PUSH
99338: FOR_IN
99339: IFFALSE 99856
// begin if GetTag ( j ) <> 0 then
99341: LD_VAR 0 3
99345: PPUSH
99346: CALL_OW 110
99350: PUSH
99351: LD_INT 0
99353: NONEQUAL
99354: IFFALSE 99358
// continue ;
99356: GO 99338
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
99358: LD_VAR 0 3
99362: PPUSH
99363: CALL_OW 256
99367: PUSH
99368: LD_INT 1000
99370: LESS
99371: PUSH
99372: LD_VAR 0 3
99376: PPUSH
99377: LD_EXP 202
99381: PUSH
99382: LD_VAR 0 2
99386: ARRAY
99387: PPUSH
99388: CALL_OW 308
99392: NOT
99393: AND
99394: IFFALSE 99416
// ComMoveToArea ( j , mc_parking [ i ] ) ;
99396: LD_VAR 0 3
99400: PPUSH
99401: LD_EXP 202
99405: PUSH
99406: LD_VAR 0 2
99410: ARRAY
99411: PPUSH
99412: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
99416: LD_VAR 0 3
99420: PPUSH
99421: CALL_OW 256
99425: PUSH
99426: LD_INT 1000
99428: LESS
99429: PUSH
99430: LD_VAR 0 3
99434: PPUSH
99435: LD_EXP 202
99439: PUSH
99440: LD_VAR 0 2
99444: ARRAY
99445: PPUSH
99446: CALL_OW 308
99450: AND
99451: IFFALSE 99455
// continue ;
99453: GO 99338
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
99455: LD_VAR 0 3
99459: PPUSH
99460: CALL_OW 262
99464: PUSH
99465: LD_INT 2
99467: EQUAL
99468: PUSH
99469: LD_VAR 0 3
99473: PPUSH
99474: CALL_OW 261
99478: PUSH
99479: LD_INT 15
99481: LESS
99482: AND
99483: IFFALSE 99487
// continue ;
99485: GO 99338
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
99487: LD_VAR 0 3
99491: PPUSH
99492: CALL_OW 262
99496: PUSH
99497: LD_INT 1
99499: EQUAL
99500: PUSH
99501: LD_VAR 0 3
99505: PPUSH
99506: CALL_OW 261
99510: PUSH
99511: LD_INT 10
99513: LESS
99514: AND
99515: IFFALSE 99795
// begin if not depot then
99517: LD_VAR 0 9
99521: NOT
99522: IFFALSE 99526
// continue ;
99524: GO 99338
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
99526: LD_VAR 0 3
99530: PPUSH
99531: LD_VAR 0 9
99535: PPUSH
99536: LD_VAR 0 3
99540: PPUSH
99541: CALL_OW 74
99545: PPUSH
99546: CALL_OW 296
99550: PUSH
99551: LD_INT 6
99553: LESS
99554: IFFALSE 99570
// SetFuel ( j , 100 ) else
99556: LD_VAR 0 3
99560: PPUSH
99561: LD_INT 100
99563: PPUSH
99564: CALL_OW 240
99568: GO 99795
// if GetFuel ( j ) = 0 then
99570: LD_VAR 0 3
99574: PPUSH
99575: CALL_OW 261
99579: PUSH
99580: LD_INT 0
99582: EQUAL
99583: IFFALSE 99795
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
99585: LD_ADDR_EXP 197
99589: PUSH
99590: LD_EXP 197
99594: PPUSH
99595: LD_VAR 0 2
99599: PPUSH
99600: LD_EXP 197
99604: PUSH
99605: LD_VAR 0 2
99609: ARRAY
99610: PUSH
99611: LD_VAR 0 3
99615: DIFF
99616: PPUSH
99617: CALL_OW 1
99621: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
99622: LD_VAR 0 3
99626: PPUSH
99627: CALL_OW 263
99631: PUSH
99632: LD_INT 1
99634: EQUAL
99635: IFFALSE 99651
// ComExitVehicle ( IsInUnit ( j ) ) ;
99637: LD_VAR 0 3
99641: PPUSH
99642: CALL_OW 310
99646: PPUSH
99647: CALL_OW 121
// if GetControl ( j ) = control_remote then
99651: LD_VAR 0 3
99655: PPUSH
99656: CALL_OW 263
99660: PUSH
99661: LD_INT 2
99663: EQUAL
99664: IFFALSE 99675
// ComUnlink ( j ) ;
99666: LD_VAR 0 3
99670: PPUSH
99671: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
99675: LD_ADDR_VAR 0 10
99679: PUSH
99680: LD_VAR 0 2
99684: PPUSH
99685: LD_INT 3
99687: PPUSH
99688: CALL 109434 0 2
99692: ST_TO_ADDR
// if fac then
99693: LD_VAR 0 10
99697: IFFALSE 99793
// begin for k in fac do
99699: LD_ADDR_VAR 0 4
99703: PUSH
99704: LD_VAR 0 10
99708: PUSH
99709: FOR_IN
99710: IFFALSE 99791
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
99712: LD_ADDR_VAR 0 11
99716: PUSH
99717: LD_VAR 0 10
99721: PPUSH
99722: LD_VAR 0 3
99726: PPUSH
99727: CALL_OW 265
99731: PPUSH
99732: LD_VAR 0 3
99736: PPUSH
99737: CALL_OW 262
99741: PPUSH
99742: LD_VAR 0 3
99746: PPUSH
99747: CALL_OW 263
99751: PPUSH
99752: LD_VAR 0 3
99756: PPUSH
99757: CALL_OW 264
99761: PPUSH
99762: CALL 21706 0 5
99766: ST_TO_ADDR
// if components then
99767: LD_VAR 0 11
99771: IFFALSE 99789
// begin MC_InsertProduceList ( i , components ) ;
99773: LD_VAR 0 2
99777: PPUSH
99778: LD_VAR 0 11
99782: PPUSH
99783: CALL 108979 0 2
// break ;
99787: GO 99791
// end ; end ;
99789: GO 99709
99791: POP
99792: POP
// end ; continue ;
99793: GO 99338
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
99795: LD_VAR 0 3
99799: PPUSH
99800: LD_INT 1
99802: PPUSH
99803: CALL_OW 289
99807: PUSH
99808: LD_INT 100
99810: LESS
99811: PUSH
99812: LD_VAR 0 3
99816: PPUSH
99817: CALL_OW 314
99821: NOT
99822: AND
99823: IFFALSE 99852
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
99825: LD_VAR 0 3
99829: PPUSH
99830: LD_VAR 0 7
99834: PUSH
99835: LD_INT 2
99837: ARRAY
99838: PPUSH
99839: LD_VAR 0 7
99843: PUSH
99844: LD_INT 3
99846: ARRAY
99847: PPUSH
99848: CALL_OW 117
// break ;
99852: GO 99856
// end ;
99854: GO 99338
99856: POP
99857: POP
// end ; end ;
99858: GO 98054
99860: POP
99861: POP
// end ;
99862: LD_VAR 0 1
99866: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
99867: LD_INT 0
99869: PPUSH
99870: PPUSH
99871: PPUSH
99872: PPUSH
// if not mc_bases then
99873: LD_EXP 178
99877: NOT
99878: IFFALSE 99882
// exit ;
99880: GO 100043
// for i = 1 to mc_bases do
99882: LD_ADDR_VAR 0 2
99886: PUSH
99887: DOUBLE
99888: LD_INT 1
99890: DEC
99891: ST_TO_ADDR
99892: LD_EXP 178
99896: PUSH
99897: FOR_TO
99898: IFFALSE 100041
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
99900: LD_ADDR_VAR 0 4
99904: PUSH
99905: LD_EXP 197
99909: PUSH
99910: LD_VAR 0 2
99914: ARRAY
99915: PUSH
99916: LD_EXP 200
99920: PUSH
99921: LD_VAR 0 2
99925: ARRAY
99926: UNION
99927: PPUSH
99928: LD_INT 33
99930: PUSH
99931: LD_INT 2
99933: PUSH
99934: EMPTY
99935: LIST
99936: LIST
99937: PPUSH
99938: CALL_OW 72
99942: ST_TO_ADDR
// if tmp then
99943: LD_VAR 0 4
99947: IFFALSE 100039
// for j in tmp do
99949: LD_ADDR_VAR 0 3
99953: PUSH
99954: LD_VAR 0 4
99958: PUSH
99959: FOR_IN
99960: IFFALSE 100037
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
99962: LD_VAR 0 3
99966: PPUSH
99967: CALL_OW 312
99971: NOT
99972: PUSH
99973: LD_VAR 0 3
99977: PPUSH
99978: CALL_OW 256
99982: PUSH
99983: LD_INT 250
99985: GREATEREQUAL
99986: AND
99987: IFFALSE 100000
// Connect ( j ) else
99989: LD_VAR 0 3
99993: PPUSH
99994: CALL 27181 0 1
99998: GO 100035
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
100000: LD_VAR 0 3
100004: PPUSH
100005: CALL_OW 256
100009: PUSH
100010: LD_INT 250
100012: LESS
100013: PUSH
100014: LD_VAR 0 3
100018: PPUSH
100019: CALL_OW 312
100023: AND
100024: IFFALSE 100035
// ComUnlink ( j ) ;
100026: LD_VAR 0 3
100030: PPUSH
100031: CALL_OW 136
100035: GO 99959
100037: POP
100038: POP
// end ;
100039: GO 99897
100041: POP
100042: POP
// end ;
100043: LD_VAR 0 1
100047: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
100048: LD_INT 0
100050: PPUSH
100051: PPUSH
100052: PPUSH
100053: PPUSH
100054: PPUSH
// if not mc_bases then
100055: LD_EXP 178
100059: NOT
100060: IFFALSE 100064
// exit ;
100062: GO 100509
// for i = 1 to mc_bases do
100064: LD_ADDR_VAR 0 2
100068: PUSH
100069: DOUBLE
100070: LD_INT 1
100072: DEC
100073: ST_TO_ADDR
100074: LD_EXP 178
100078: PUSH
100079: FOR_TO
100080: IFFALSE 100507
// begin if not mc_produce [ i ] then
100082: LD_EXP 199
100086: PUSH
100087: LD_VAR 0 2
100091: ARRAY
100092: NOT
100093: IFFALSE 100097
// continue ;
100095: GO 100079
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
100097: LD_ADDR_VAR 0 5
100101: PUSH
100102: LD_EXP 178
100106: PUSH
100107: LD_VAR 0 2
100111: ARRAY
100112: PPUSH
100113: LD_INT 30
100115: PUSH
100116: LD_INT 3
100118: PUSH
100119: EMPTY
100120: LIST
100121: LIST
100122: PPUSH
100123: CALL_OW 72
100127: ST_TO_ADDR
// if not fac then
100128: LD_VAR 0 5
100132: NOT
100133: IFFALSE 100137
// continue ;
100135: GO 100079
// for j in fac do
100137: LD_ADDR_VAR 0 3
100141: PUSH
100142: LD_VAR 0 5
100146: PUSH
100147: FOR_IN
100148: IFFALSE 100503
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
100150: LD_VAR 0 3
100154: PPUSH
100155: CALL_OW 461
100159: PUSH
100160: LD_INT 2
100162: NONEQUAL
100163: PUSH
100164: LD_VAR 0 3
100168: PPUSH
100169: LD_INT 15
100171: PPUSH
100172: CALL 26809 0 2
100176: PUSH
100177: LD_INT 4
100179: ARRAY
100180: OR
100181: IFFALSE 100185
// continue ;
100183: GO 100147
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
100185: LD_VAR 0 3
100189: PPUSH
100190: LD_EXP 199
100194: PUSH
100195: LD_VAR 0 2
100199: ARRAY
100200: PUSH
100201: LD_INT 1
100203: ARRAY
100204: PUSH
100205: LD_INT 1
100207: ARRAY
100208: PPUSH
100209: LD_EXP 199
100213: PUSH
100214: LD_VAR 0 2
100218: ARRAY
100219: PUSH
100220: LD_INT 1
100222: ARRAY
100223: PUSH
100224: LD_INT 2
100226: ARRAY
100227: PPUSH
100228: LD_EXP 199
100232: PUSH
100233: LD_VAR 0 2
100237: ARRAY
100238: PUSH
100239: LD_INT 1
100241: ARRAY
100242: PUSH
100243: LD_INT 3
100245: ARRAY
100246: PPUSH
100247: LD_EXP 199
100251: PUSH
100252: LD_VAR 0 2
100256: ARRAY
100257: PUSH
100258: LD_INT 1
100260: ARRAY
100261: PUSH
100262: LD_INT 4
100264: ARRAY
100265: PPUSH
100266: CALL_OW 448
100270: PUSH
100271: LD_VAR 0 3
100275: PPUSH
100276: LD_EXP 199
100280: PUSH
100281: LD_VAR 0 2
100285: ARRAY
100286: PUSH
100287: LD_INT 1
100289: ARRAY
100290: PUSH
100291: LD_INT 1
100293: ARRAY
100294: PUSH
100295: LD_EXP 199
100299: PUSH
100300: LD_VAR 0 2
100304: ARRAY
100305: PUSH
100306: LD_INT 1
100308: ARRAY
100309: PUSH
100310: LD_INT 2
100312: ARRAY
100313: PUSH
100314: LD_EXP 199
100318: PUSH
100319: LD_VAR 0 2
100323: ARRAY
100324: PUSH
100325: LD_INT 1
100327: ARRAY
100328: PUSH
100329: LD_INT 3
100331: ARRAY
100332: PUSH
100333: LD_EXP 199
100337: PUSH
100338: LD_VAR 0 2
100342: ARRAY
100343: PUSH
100344: LD_INT 1
100346: ARRAY
100347: PUSH
100348: LD_INT 4
100350: ARRAY
100351: PUSH
100352: EMPTY
100353: LIST
100354: LIST
100355: LIST
100356: LIST
100357: PPUSH
100358: CALL 30576 0 2
100362: AND
100363: IFFALSE 100501
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
100365: LD_VAR 0 3
100369: PPUSH
100370: LD_EXP 199
100374: PUSH
100375: LD_VAR 0 2
100379: ARRAY
100380: PUSH
100381: LD_INT 1
100383: ARRAY
100384: PUSH
100385: LD_INT 1
100387: ARRAY
100388: PPUSH
100389: LD_EXP 199
100393: PUSH
100394: LD_VAR 0 2
100398: ARRAY
100399: PUSH
100400: LD_INT 1
100402: ARRAY
100403: PUSH
100404: LD_INT 2
100406: ARRAY
100407: PPUSH
100408: LD_EXP 199
100412: PUSH
100413: LD_VAR 0 2
100417: ARRAY
100418: PUSH
100419: LD_INT 1
100421: ARRAY
100422: PUSH
100423: LD_INT 3
100425: ARRAY
100426: PPUSH
100427: LD_EXP 199
100431: PUSH
100432: LD_VAR 0 2
100436: ARRAY
100437: PUSH
100438: LD_INT 1
100440: ARRAY
100441: PUSH
100442: LD_INT 4
100444: ARRAY
100445: PPUSH
100446: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
100450: LD_ADDR_VAR 0 4
100454: PUSH
100455: LD_EXP 199
100459: PUSH
100460: LD_VAR 0 2
100464: ARRAY
100465: PPUSH
100466: LD_INT 1
100468: PPUSH
100469: CALL_OW 3
100473: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
100474: LD_ADDR_EXP 199
100478: PUSH
100479: LD_EXP 199
100483: PPUSH
100484: LD_VAR 0 2
100488: PPUSH
100489: LD_VAR 0 4
100493: PPUSH
100494: CALL_OW 1
100498: ST_TO_ADDR
// break ;
100499: GO 100503
// end ; end ;
100501: GO 100147
100503: POP
100504: POP
// end ;
100505: GO 100079
100507: POP
100508: POP
// end ;
100509: LD_VAR 0 1
100513: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
100514: LD_INT 0
100516: PPUSH
100517: PPUSH
100518: PPUSH
// if not mc_bases then
100519: LD_EXP 178
100523: NOT
100524: IFFALSE 100528
// exit ;
100526: GO 100617
// for i = 1 to mc_bases do
100528: LD_ADDR_VAR 0 2
100532: PUSH
100533: DOUBLE
100534: LD_INT 1
100536: DEC
100537: ST_TO_ADDR
100538: LD_EXP 178
100542: PUSH
100543: FOR_TO
100544: IFFALSE 100615
// begin if mc_attack [ i ] then
100546: LD_EXP 198
100550: PUSH
100551: LD_VAR 0 2
100555: ARRAY
100556: IFFALSE 100613
// begin tmp := mc_attack [ i ] [ 1 ] ;
100558: LD_ADDR_VAR 0 3
100562: PUSH
100563: LD_EXP 198
100567: PUSH
100568: LD_VAR 0 2
100572: ARRAY
100573: PUSH
100574: LD_INT 1
100576: ARRAY
100577: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
100578: LD_ADDR_EXP 198
100582: PUSH
100583: LD_EXP 198
100587: PPUSH
100588: LD_VAR 0 2
100592: PPUSH
100593: EMPTY
100594: PPUSH
100595: CALL_OW 1
100599: ST_TO_ADDR
// Attack ( tmp ) ;
100600: LD_VAR 0 3
100604: PPUSH
100605: CALL 77458 0 1
// exit ;
100609: POP
100610: POP
100611: GO 100617
// end ; end ;
100613: GO 100543
100615: POP
100616: POP
// end ;
100617: LD_VAR 0 1
100621: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
100622: LD_INT 0
100624: PPUSH
100625: PPUSH
100626: PPUSH
100627: PPUSH
100628: PPUSH
100629: PPUSH
100630: PPUSH
// if not mc_bases then
100631: LD_EXP 178
100635: NOT
100636: IFFALSE 100640
// exit ;
100638: GO 101497
// for i = 1 to mc_bases do
100640: LD_ADDR_VAR 0 2
100644: PUSH
100645: DOUBLE
100646: LD_INT 1
100648: DEC
100649: ST_TO_ADDR
100650: LD_EXP 178
100654: PUSH
100655: FOR_TO
100656: IFFALSE 101495
// begin if not mc_bases [ i ] then
100658: LD_EXP 178
100662: PUSH
100663: LD_VAR 0 2
100667: ARRAY
100668: NOT
100669: IFFALSE 100673
// continue ;
100671: GO 100655
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
100673: LD_ADDR_VAR 0 7
100677: PUSH
100678: LD_EXP 178
100682: PUSH
100683: LD_VAR 0 2
100687: ARRAY
100688: PUSH
100689: LD_INT 1
100691: ARRAY
100692: PPUSH
100693: CALL 21010 0 1
100697: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
100698: LD_ADDR_EXP 201
100702: PUSH
100703: LD_EXP 201
100707: PPUSH
100708: LD_VAR 0 2
100712: PPUSH
100713: LD_EXP 178
100717: PUSH
100718: LD_VAR 0 2
100722: ARRAY
100723: PUSH
100724: LD_INT 1
100726: ARRAY
100727: PPUSH
100728: CALL_OW 255
100732: PPUSH
100733: LD_EXP 203
100737: PUSH
100738: LD_VAR 0 2
100742: ARRAY
100743: PPUSH
100744: CALL 20975 0 2
100748: PPUSH
100749: CALL_OW 1
100753: ST_TO_ADDR
// if not mc_scan [ i ] then
100754: LD_EXP 201
100758: PUSH
100759: LD_VAR 0 2
100763: ARRAY
100764: NOT
100765: IFFALSE 100943
// begin mc_is_defending := Replace ( mc_is_defending , i , false ) ;
100767: LD_ADDR_EXP 221
100771: PUSH
100772: LD_EXP 221
100776: PPUSH
100777: LD_VAR 0 2
100781: PPUSH
100782: LD_INT 0
100784: PPUSH
100785: CALL_OW 1
100789: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
100790: LD_ADDR_VAR 0 4
100794: PUSH
100795: LD_EXP 178
100799: PUSH
100800: LD_VAR 0 2
100804: ARRAY
100805: PPUSH
100806: LD_INT 2
100808: PUSH
100809: LD_INT 25
100811: PUSH
100812: LD_INT 5
100814: PUSH
100815: EMPTY
100816: LIST
100817: LIST
100818: PUSH
100819: LD_INT 25
100821: PUSH
100822: LD_INT 8
100824: PUSH
100825: EMPTY
100826: LIST
100827: LIST
100828: PUSH
100829: LD_INT 25
100831: PUSH
100832: LD_INT 9
100834: PUSH
100835: EMPTY
100836: LIST
100837: LIST
100838: PUSH
100839: EMPTY
100840: LIST
100841: LIST
100842: LIST
100843: LIST
100844: PPUSH
100845: CALL_OW 72
100849: ST_TO_ADDR
// if not tmp then
100850: LD_VAR 0 4
100854: NOT
100855: IFFALSE 100859
// continue ;
100857: GO 100655
// for j in tmp do
100859: LD_ADDR_VAR 0 3
100863: PUSH
100864: LD_VAR 0 4
100868: PUSH
100869: FOR_IN
100870: IFFALSE 100941
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
100872: LD_VAR 0 3
100876: PPUSH
100877: CALL_OW 310
100881: PPUSH
100882: CALL_OW 266
100886: PUSH
100887: LD_INT 5
100889: EQUAL
100890: PUSH
100891: LD_VAR 0 3
100895: PPUSH
100896: CALL_OW 257
100900: PUSH
100901: LD_INT 1
100903: EQUAL
100904: AND
100905: PUSH
100906: LD_VAR 0 3
100910: PPUSH
100911: CALL_OW 459
100915: NOT
100916: AND
100917: PUSH
100918: LD_VAR 0 7
100922: AND
100923: IFFALSE 100939
// ComChangeProfession ( j , class ) ;
100925: LD_VAR 0 3
100929: PPUSH
100930: LD_VAR 0 7
100934: PPUSH
100935: CALL_OW 123
100939: GO 100869
100941: POP
100942: POP
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and not mc_defender [ i ] and ( UnitFilter ( mc_bases [ i ] , [ [ f_ok ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) < 4 or UnitFilter ( mc_bases [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ) then
100943: LD_EXP 201
100947: PUSH
100948: LD_VAR 0 2
100952: ARRAY
100953: PUSH
100954: LD_EXP 221
100958: PUSH
100959: LD_VAR 0 2
100963: ARRAY
100964: NOT
100965: AND
100966: PUSH
100967: LD_EXP 200
100971: PUSH
100972: LD_VAR 0 2
100976: ARRAY
100977: NOT
100978: AND
100979: PUSH
100980: LD_EXP 178
100984: PUSH
100985: LD_VAR 0 2
100989: ARRAY
100990: PPUSH
100991: LD_INT 50
100993: PUSH
100994: EMPTY
100995: LIST
100996: PUSH
100997: LD_INT 2
100999: PUSH
101000: LD_INT 30
101002: PUSH
101003: LD_INT 32
101005: PUSH
101006: EMPTY
101007: LIST
101008: LIST
101009: PUSH
101010: LD_INT 30
101012: PUSH
101013: LD_INT 33
101015: PUSH
101016: EMPTY
101017: LIST
101018: LIST
101019: PUSH
101020: LD_INT 30
101022: PUSH
101023: LD_INT 4
101025: PUSH
101026: EMPTY
101027: LIST
101028: LIST
101029: PUSH
101030: LD_INT 30
101032: PUSH
101033: LD_INT 5
101035: PUSH
101036: EMPTY
101037: LIST
101038: LIST
101039: PUSH
101040: EMPTY
101041: LIST
101042: LIST
101043: LIST
101044: LIST
101045: LIST
101046: PUSH
101047: EMPTY
101048: LIST
101049: LIST
101050: PPUSH
101051: CALL_OW 72
101055: PUSH
101056: LD_INT 4
101058: LESS
101059: PUSH
101060: LD_EXP 178
101064: PUSH
101065: LD_VAR 0 2
101069: ARRAY
101070: PPUSH
101071: LD_INT 3
101073: PUSH
101074: LD_INT 24
101076: PUSH
101077: LD_INT 1000
101079: PUSH
101080: EMPTY
101081: LIST
101082: LIST
101083: PUSH
101084: EMPTY
101085: LIST
101086: LIST
101087: PUSH
101088: LD_INT 2
101090: PUSH
101091: LD_INT 30
101093: PUSH
101094: LD_INT 0
101096: PUSH
101097: EMPTY
101098: LIST
101099: LIST
101100: PUSH
101101: LD_INT 30
101103: PUSH
101104: LD_INT 1
101106: PUSH
101107: EMPTY
101108: LIST
101109: LIST
101110: PUSH
101111: EMPTY
101112: LIST
101113: LIST
101114: LIST
101115: PUSH
101116: EMPTY
101117: LIST
101118: LIST
101119: PPUSH
101120: CALL_OW 72
101124: OR
101125: AND
101126: IFFALSE 101377
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
101128: LD_ADDR_EXP 221
101132: PUSH
101133: LD_EXP 221
101137: PPUSH
101138: LD_VAR 0 2
101142: PPUSH
101143: LD_INT 1
101145: PPUSH
101146: CALL_OW 1
101150: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
101151: LD_ADDR_VAR 0 4
101155: PUSH
101156: LD_EXP 178
101160: PUSH
101161: LD_VAR 0 2
101165: ARRAY
101166: PPUSH
101167: LD_INT 2
101169: PUSH
101170: LD_INT 25
101172: PUSH
101173: LD_INT 1
101175: PUSH
101176: EMPTY
101177: LIST
101178: LIST
101179: PUSH
101180: LD_INT 25
101182: PUSH
101183: LD_INT 5
101185: PUSH
101186: EMPTY
101187: LIST
101188: LIST
101189: PUSH
101190: LD_INT 25
101192: PUSH
101193: LD_INT 8
101195: PUSH
101196: EMPTY
101197: LIST
101198: LIST
101199: PUSH
101200: LD_INT 25
101202: PUSH
101203: LD_INT 9
101205: PUSH
101206: EMPTY
101207: LIST
101208: LIST
101209: PUSH
101210: EMPTY
101211: LIST
101212: LIST
101213: LIST
101214: LIST
101215: LIST
101216: PPUSH
101217: CALL_OW 72
101221: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
101222: LD_ADDR_VAR 0 4
101226: PUSH
101227: LD_VAR 0 4
101231: PUSH
101232: LD_VAR 0 4
101236: PPUSH
101237: LD_INT 18
101239: PPUSH
101240: CALL 53479 0 2
101244: DIFF
101245: ST_TO_ADDR
// if not tmp and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
101246: LD_VAR 0 4
101250: NOT
101251: PUSH
101252: LD_EXP 178
101256: PUSH
101257: LD_VAR 0 2
101261: ARRAY
101262: PPUSH
101263: LD_INT 2
101265: PUSH
101266: LD_INT 30
101268: PUSH
101269: LD_INT 4
101271: PUSH
101272: EMPTY
101273: LIST
101274: LIST
101275: PUSH
101276: LD_INT 30
101278: PUSH
101279: LD_INT 5
101281: PUSH
101282: EMPTY
101283: LIST
101284: LIST
101285: PUSH
101286: EMPTY
101287: LIST
101288: LIST
101289: LIST
101290: PPUSH
101291: CALL_OW 72
101295: NOT
101296: AND
101297: IFFALSE 101359
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
101299: LD_ADDR_VAR 0 4
101303: PUSH
101304: LD_EXP 178
101308: PUSH
101309: LD_VAR 0 2
101313: ARRAY
101314: PPUSH
101315: LD_INT 2
101317: PUSH
101318: LD_INT 25
101320: PUSH
101321: LD_INT 2
101323: PUSH
101324: EMPTY
101325: LIST
101326: LIST
101327: PUSH
101328: LD_INT 25
101330: PUSH
101331: LD_INT 3
101333: PUSH
101334: EMPTY
101335: LIST
101336: LIST
101337: PUSH
101338: LD_INT 25
101340: PUSH
101341: LD_INT 4
101343: PUSH
101344: EMPTY
101345: LIST
101346: LIST
101347: PUSH
101348: EMPTY
101349: LIST
101350: LIST
101351: LIST
101352: LIST
101353: PPUSH
101354: CALL_OW 72
101358: ST_TO_ADDR
// BasicDefend ( i , tmp ) ;
101359: LD_VAR 0 2
101363: PPUSH
101364: LD_VAR 0 4
101368: PPUSH
101369: CALL 82167 0 2
// exit ;
101373: POP
101374: POP
101375: GO 101497
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and mc_defender [ i ] then
101377: LD_EXP 201
101381: PUSH
101382: LD_VAR 0 2
101386: ARRAY
101387: PUSH
101388: LD_EXP 221
101392: PUSH
101393: LD_VAR 0 2
101397: ARRAY
101398: NOT
101399: AND
101400: PUSH
101401: LD_EXP 200
101405: PUSH
101406: LD_VAR 0 2
101410: ARRAY
101411: AND
101412: IFFALSE 101493
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
101414: LD_ADDR_EXP 221
101418: PUSH
101419: LD_EXP 221
101423: PPUSH
101424: LD_VAR 0 2
101428: PPUSH
101429: LD_INT 1
101431: PPUSH
101432: CALL_OW 1
101436: ST_TO_ADDR
// tmp := mc_defender [ i ] ;
101437: LD_ADDR_VAR 0 4
101441: PUSH
101442: LD_EXP 200
101446: PUSH
101447: LD_VAR 0 2
101451: ARRAY
101452: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
101453: LD_ADDR_EXP 200
101457: PUSH
101458: LD_EXP 200
101462: PPUSH
101463: LD_VAR 0 2
101467: PPUSH
101468: EMPTY
101469: PPUSH
101470: CALL_OW 1
101474: ST_TO_ADDR
// Defend ( i , tmp ) ;
101475: LD_VAR 0 2
101479: PPUSH
101480: LD_VAR 0 4
101484: PPUSH
101485: CALL 82763 0 2
// exit ;
101489: POP
101490: POP
101491: GO 101497
// end ; end ;
101493: GO 100655
101495: POP
101496: POP
// end ;
101497: LD_VAR 0 1
101501: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
101502: LD_INT 0
101504: PPUSH
101505: PPUSH
101506: PPUSH
101507: PPUSH
101508: PPUSH
101509: PPUSH
101510: PPUSH
101511: PPUSH
101512: PPUSH
101513: PPUSH
101514: PPUSH
// if not mc_bases then
101515: LD_EXP 178
101519: NOT
101520: IFFALSE 101524
// exit ;
101522: GO 102611
// for i = 1 to mc_bases do
101524: LD_ADDR_VAR 0 2
101528: PUSH
101529: DOUBLE
101530: LD_INT 1
101532: DEC
101533: ST_TO_ADDR
101534: LD_EXP 178
101538: PUSH
101539: FOR_TO
101540: IFFALSE 102609
// begin tmp := mc_lab [ i ] ;
101542: LD_ADDR_VAR 0 6
101546: PUSH
101547: LD_EXP 211
101551: PUSH
101552: LD_VAR 0 2
101556: ARRAY
101557: ST_TO_ADDR
// if not tmp then
101558: LD_VAR 0 6
101562: NOT
101563: IFFALSE 101567
// continue ;
101565: GO 101539
// idle_lab := 0 ;
101567: LD_ADDR_VAR 0 11
101571: PUSH
101572: LD_INT 0
101574: ST_TO_ADDR
// for j in tmp do
101575: LD_ADDR_VAR 0 3
101579: PUSH
101580: LD_VAR 0 6
101584: PUSH
101585: FOR_IN
101586: IFFALSE 102605
// begin researching := false ;
101588: LD_ADDR_VAR 0 10
101592: PUSH
101593: LD_INT 0
101595: ST_TO_ADDR
// side := GetSide ( j ) ;
101596: LD_ADDR_VAR 0 4
101600: PUSH
101601: LD_VAR 0 3
101605: PPUSH
101606: CALL_OW 255
101610: ST_TO_ADDR
// if not mc_tech [ side ] then
101611: LD_EXP 205
101615: PUSH
101616: LD_VAR 0 4
101620: ARRAY
101621: NOT
101622: IFFALSE 101626
// continue ;
101624: GO 101585
// if BuildingStatus ( j ) = bs_idle then
101626: LD_VAR 0 3
101630: PPUSH
101631: CALL_OW 461
101635: PUSH
101636: LD_INT 2
101638: EQUAL
101639: IFFALSE 101827
// begin if idle_lab and UnitsInside ( j ) < 6 then
101641: LD_VAR 0 11
101645: PUSH
101646: LD_VAR 0 3
101650: PPUSH
101651: CALL_OW 313
101655: PUSH
101656: LD_INT 6
101658: LESS
101659: AND
101660: IFFALSE 101731
// begin tmp2 := UnitsInside ( idle_lab ) ;
101662: LD_ADDR_VAR 0 9
101666: PUSH
101667: LD_VAR 0 11
101671: PPUSH
101672: CALL_OW 313
101676: ST_TO_ADDR
// if tmp2 then
101677: LD_VAR 0 9
101681: IFFALSE 101723
// for x in tmp2 do
101683: LD_ADDR_VAR 0 7
101687: PUSH
101688: LD_VAR 0 9
101692: PUSH
101693: FOR_IN
101694: IFFALSE 101721
// begin ComExitBuilding ( x ) ;
101696: LD_VAR 0 7
101700: PPUSH
101701: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
101705: LD_VAR 0 7
101709: PPUSH
101710: LD_VAR 0 3
101714: PPUSH
101715: CALL_OW 180
// end ;
101719: GO 101693
101721: POP
101722: POP
// idle_lab := 0 ;
101723: LD_ADDR_VAR 0 11
101727: PUSH
101728: LD_INT 0
101730: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
101731: LD_ADDR_VAR 0 5
101735: PUSH
101736: LD_EXP 205
101740: PUSH
101741: LD_VAR 0 4
101745: ARRAY
101746: PUSH
101747: FOR_IN
101748: IFFALSE 101808
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
101750: LD_VAR 0 3
101754: PPUSH
101755: LD_VAR 0 5
101759: PPUSH
101760: CALL_OW 430
101764: PUSH
101765: LD_VAR 0 4
101769: PPUSH
101770: LD_VAR 0 5
101774: PPUSH
101775: CALL 20080 0 2
101779: AND
101780: IFFALSE 101806
// begin researching := true ;
101782: LD_ADDR_VAR 0 10
101786: PUSH
101787: LD_INT 1
101789: ST_TO_ADDR
// ComResearch ( j , t ) ;
101790: LD_VAR 0 3
101794: PPUSH
101795: LD_VAR 0 5
101799: PPUSH
101800: CALL_OW 124
// break ;
101804: GO 101808
// end ;
101806: GO 101747
101808: POP
101809: POP
// if not researching then
101810: LD_VAR 0 10
101814: NOT
101815: IFFALSE 101827
// idle_lab := j ;
101817: LD_ADDR_VAR 0 11
101821: PUSH
101822: LD_VAR 0 3
101826: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
101827: LD_VAR 0 3
101831: PPUSH
101832: CALL_OW 461
101836: PUSH
101837: LD_INT 10
101839: EQUAL
101840: IFFALSE 102428
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
101842: LD_EXP 207
101846: PUSH
101847: LD_VAR 0 2
101851: ARRAY
101852: NOT
101853: PUSH
101854: LD_EXP 208
101858: PUSH
101859: LD_VAR 0 2
101863: ARRAY
101864: NOT
101865: AND
101866: PUSH
101867: LD_EXP 205
101871: PUSH
101872: LD_VAR 0 4
101876: ARRAY
101877: PUSH
101878: LD_INT 1
101880: GREATER
101881: AND
101882: IFFALSE 102013
// begin ComCancel ( j ) ;
101884: LD_VAR 0 3
101888: PPUSH
101889: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
101893: LD_ADDR_EXP 205
101897: PUSH
101898: LD_EXP 205
101902: PPUSH
101903: LD_VAR 0 4
101907: PPUSH
101908: LD_EXP 205
101912: PUSH
101913: LD_VAR 0 4
101917: ARRAY
101918: PPUSH
101919: LD_EXP 205
101923: PUSH
101924: LD_VAR 0 4
101928: ARRAY
101929: PUSH
101930: LD_INT 1
101932: MINUS
101933: PPUSH
101934: LD_EXP 205
101938: PUSH
101939: LD_VAR 0 4
101943: ARRAY
101944: PPUSH
101945: LD_INT 0
101947: PPUSH
101948: CALL 23628 0 4
101952: PPUSH
101953: CALL_OW 1
101957: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
101958: LD_ADDR_EXP 205
101962: PUSH
101963: LD_EXP 205
101967: PPUSH
101968: LD_VAR 0 4
101972: PPUSH
101973: LD_EXP 205
101977: PUSH
101978: LD_VAR 0 4
101982: ARRAY
101983: PPUSH
101984: LD_EXP 205
101988: PUSH
101989: LD_VAR 0 4
101993: ARRAY
101994: PPUSH
101995: LD_INT 1
101997: PPUSH
101998: LD_INT 0
102000: PPUSH
102001: CALL 23628 0 4
102005: PPUSH
102006: CALL_OW 1
102010: ST_TO_ADDR
// continue ;
102011: GO 101585
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
102013: LD_EXP 207
102017: PUSH
102018: LD_VAR 0 2
102022: ARRAY
102023: PUSH
102024: LD_EXP 208
102028: PUSH
102029: LD_VAR 0 2
102033: ARRAY
102034: NOT
102035: AND
102036: IFFALSE 102163
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
102038: LD_ADDR_EXP 208
102042: PUSH
102043: LD_EXP 208
102047: PPUSH
102048: LD_VAR 0 2
102052: PUSH
102053: LD_EXP 208
102057: PUSH
102058: LD_VAR 0 2
102062: ARRAY
102063: PUSH
102064: LD_INT 1
102066: PLUS
102067: PUSH
102068: EMPTY
102069: LIST
102070: LIST
102071: PPUSH
102072: LD_EXP 207
102076: PUSH
102077: LD_VAR 0 2
102081: ARRAY
102082: PUSH
102083: LD_INT 1
102085: ARRAY
102086: PPUSH
102087: CALL 24210 0 3
102091: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
102092: LD_EXP 207
102096: PUSH
102097: LD_VAR 0 2
102101: ARRAY
102102: PUSH
102103: LD_INT 1
102105: ARRAY
102106: PPUSH
102107: LD_INT 112
102109: PPUSH
102110: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
102114: LD_ADDR_VAR 0 9
102118: PUSH
102119: LD_EXP 207
102123: PUSH
102124: LD_VAR 0 2
102128: ARRAY
102129: PPUSH
102130: LD_INT 1
102132: PPUSH
102133: CALL_OW 3
102137: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
102138: LD_ADDR_EXP 207
102142: PUSH
102143: LD_EXP 207
102147: PPUSH
102148: LD_VAR 0 2
102152: PPUSH
102153: LD_VAR 0 9
102157: PPUSH
102158: CALL_OW 1
102162: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
102163: LD_EXP 207
102167: PUSH
102168: LD_VAR 0 2
102172: ARRAY
102173: PUSH
102174: LD_EXP 208
102178: PUSH
102179: LD_VAR 0 2
102183: ARRAY
102184: AND
102185: PUSH
102186: LD_EXP 208
102190: PUSH
102191: LD_VAR 0 2
102195: ARRAY
102196: PUSH
102197: LD_INT 1
102199: ARRAY
102200: PPUSH
102201: CALL_OW 310
102205: NOT
102206: AND
102207: PUSH
102208: LD_VAR 0 3
102212: PPUSH
102213: CALL_OW 313
102217: PUSH
102218: LD_INT 6
102220: EQUAL
102221: AND
102222: IFFALSE 102278
// begin tmp2 := UnitsInside ( j ) ;
102224: LD_ADDR_VAR 0 9
102228: PUSH
102229: LD_VAR 0 3
102233: PPUSH
102234: CALL_OW 313
102238: ST_TO_ADDR
// if tmp2 = 6 then
102239: LD_VAR 0 9
102243: PUSH
102244: LD_INT 6
102246: EQUAL
102247: IFFALSE 102278
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
102249: LD_VAR 0 9
102253: PUSH
102254: LD_INT 1
102256: ARRAY
102257: PPUSH
102258: LD_INT 112
102260: PPUSH
102261: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
102265: LD_VAR 0 9
102269: PUSH
102270: LD_INT 1
102272: ARRAY
102273: PPUSH
102274: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
102278: LD_EXP 208
102282: PUSH
102283: LD_VAR 0 2
102287: ARRAY
102288: PUSH
102289: LD_EXP 208
102293: PUSH
102294: LD_VAR 0 2
102298: ARRAY
102299: PUSH
102300: LD_INT 1
102302: ARRAY
102303: PPUSH
102304: CALL_OW 314
102308: NOT
102309: AND
102310: PUSH
102311: LD_EXP 208
102315: PUSH
102316: LD_VAR 0 2
102320: ARRAY
102321: PUSH
102322: LD_INT 1
102324: ARRAY
102325: PPUSH
102326: CALL_OW 310
102330: NOT
102331: AND
102332: IFFALSE 102358
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
102334: LD_EXP 208
102338: PUSH
102339: LD_VAR 0 2
102343: ARRAY
102344: PUSH
102345: LD_INT 1
102347: ARRAY
102348: PPUSH
102349: LD_VAR 0 3
102353: PPUSH
102354: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
102358: LD_EXP 208
102362: PUSH
102363: LD_VAR 0 2
102367: ARRAY
102368: PUSH
102369: LD_INT 1
102371: ARRAY
102372: PPUSH
102373: CALL_OW 310
102377: PUSH
102378: LD_EXP 208
102382: PUSH
102383: LD_VAR 0 2
102387: ARRAY
102388: PUSH
102389: LD_INT 1
102391: ARRAY
102392: PPUSH
102393: CALL_OW 310
102397: PPUSH
102398: CALL_OW 461
102402: PUSH
102403: LD_INT 3
102405: NONEQUAL
102406: AND
102407: IFFALSE 102428
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
102409: LD_EXP 208
102413: PUSH
102414: LD_VAR 0 2
102418: ARRAY
102419: PUSH
102420: LD_INT 1
102422: ARRAY
102423: PPUSH
102424: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
102428: LD_VAR 0 3
102432: PPUSH
102433: CALL_OW 461
102437: PUSH
102438: LD_INT 6
102440: EQUAL
102441: PUSH
102442: LD_VAR 0 6
102446: PUSH
102447: LD_INT 1
102449: GREATER
102450: AND
102451: IFFALSE 102603
// begin sci := [ ] ;
102453: LD_ADDR_VAR 0 8
102457: PUSH
102458: EMPTY
102459: ST_TO_ADDR
// for x in ( tmp diff j ) do
102460: LD_ADDR_VAR 0 7
102464: PUSH
102465: LD_VAR 0 6
102469: PUSH
102470: LD_VAR 0 3
102474: DIFF
102475: PUSH
102476: FOR_IN
102477: IFFALSE 102529
// begin if sci = 6 then
102479: LD_VAR 0 8
102483: PUSH
102484: LD_INT 6
102486: EQUAL
102487: IFFALSE 102491
// break ;
102489: GO 102529
// if BuildingStatus ( x ) = bs_idle then
102491: LD_VAR 0 7
102495: PPUSH
102496: CALL_OW 461
102500: PUSH
102501: LD_INT 2
102503: EQUAL
102504: IFFALSE 102527
// sci := sci ^ UnitsInside ( x ) ;
102506: LD_ADDR_VAR 0 8
102510: PUSH
102511: LD_VAR 0 8
102515: PUSH
102516: LD_VAR 0 7
102520: PPUSH
102521: CALL_OW 313
102525: ADD
102526: ST_TO_ADDR
// end ;
102527: GO 102476
102529: POP
102530: POP
// if not sci then
102531: LD_VAR 0 8
102535: NOT
102536: IFFALSE 102540
// continue ;
102538: GO 101585
// for x in sci do
102540: LD_ADDR_VAR 0 7
102544: PUSH
102545: LD_VAR 0 8
102549: PUSH
102550: FOR_IN
102551: IFFALSE 102601
// if IsInUnit ( x ) and not HasTask ( x ) then
102553: LD_VAR 0 7
102557: PPUSH
102558: CALL_OW 310
102562: PUSH
102563: LD_VAR 0 7
102567: PPUSH
102568: CALL_OW 314
102572: NOT
102573: AND
102574: IFFALSE 102599
// begin ComExitBuilding ( x ) ;
102576: LD_VAR 0 7
102580: PPUSH
102581: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
102585: LD_VAR 0 7
102589: PPUSH
102590: LD_VAR 0 3
102594: PPUSH
102595: CALL_OW 180
// end ;
102599: GO 102550
102601: POP
102602: POP
// end ; end ;
102603: GO 101585
102605: POP
102606: POP
// end ;
102607: GO 101539
102609: POP
102610: POP
// end ;
102611: LD_VAR 0 1
102615: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
102616: LD_INT 0
102618: PPUSH
102619: PPUSH
// if not mc_bases then
102620: LD_EXP 178
102624: NOT
102625: IFFALSE 102629
// exit ;
102627: GO 102710
// for i = 1 to mc_bases do
102629: LD_ADDR_VAR 0 2
102633: PUSH
102634: DOUBLE
102635: LD_INT 1
102637: DEC
102638: ST_TO_ADDR
102639: LD_EXP 178
102643: PUSH
102644: FOR_TO
102645: IFFALSE 102708
// if mc_mines [ i ] and mc_miners [ i ] then
102647: LD_EXP 191
102651: PUSH
102652: LD_VAR 0 2
102656: ARRAY
102657: PUSH
102658: LD_EXP 192
102662: PUSH
102663: LD_VAR 0 2
102667: ARRAY
102668: AND
102669: IFFALSE 102706
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
102671: LD_EXP 192
102675: PUSH
102676: LD_VAR 0 2
102680: ARRAY
102681: PUSH
102682: LD_INT 1
102684: ARRAY
102685: PPUSH
102686: CALL_OW 255
102690: PPUSH
102691: LD_EXP 191
102695: PUSH
102696: LD_VAR 0 2
102700: ARRAY
102701: PPUSH
102702: CALL 21163 0 2
102706: GO 102644
102708: POP
102709: POP
// end ;
102710: LD_VAR 0 1
102714: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
102715: LD_INT 0
102717: PPUSH
102718: PPUSH
102719: PPUSH
102720: PPUSH
102721: PPUSH
102722: PPUSH
102723: PPUSH
102724: PPUSH
// if not mc_bases or not mc_parking then
102725: LD_EXP 178
102729: NOT
102730: PUSH
102731: LD_EXP 202
102735: NOT
102736: OR
102737: IFFALSE 102741
// exit ;
102739: GO 103451
// for i = 1 to mc_bases do
102741: LD_ADDR_VAR 0 2
102745: PUSH
102746: DOUBLE
102747: LD_INT 1
102749: DEC
102750: ST_TO_ADDR
102751: LD_EXP 178
102755: PUSH
102756: FOR_TO
102757: IFFALSE 103449
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
102759: LD_EXP 178
102763: PUSH
102764: LD_VAR 0 2
102768: ARRAY
102769: NOT
102770: PUSH
102771: LD_EXP 202
102775: PUSH
102776: LD_VAR 0 2
102780: ARRAY
102781: NOT
102782: OR
102783: IFFALSE 102787
// continue ;
102785: GO 102756
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
102787: LD_ADDR_VAR 0 5
102791: PUSH
102792: LD_EXP 178
102796: PUSH
102797: LD_VAR 0 2
102801: ARRAY
102802: PUSH
102803: LD_INT 1
102805: ARRAY
102806: PPUSH
102807: CALL_OW 255
102811: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
102812: LD_ADDR_VAR 0 6
102816: PUSH
102817: LD_EXP 178
102821: PUSH
102822: LD_VAR 0 2
102826: ARRAY
102827: PPUSH
102828: LD_INT 30
102830: PUSH
102831: LD_INT 3
102833: PUSH
102834: EMPTY
102835: LIST
102836: LIST
102837: PPUSH
102838: CALL_OW 72
102842: ST_TO_ADDR
// if not fac then
102843: LD_VAR 0 6
102847: NOT
102848: IFFALSE 102899
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
102850: LD_ADDR_VAR 0 6
102854: PUSH
102855: LD_EXP 178
102859: PUSH
102860: LD_VAR 0 2
102864: ARRAY
102865: PPUSH
102866: LD_INT 2
102868: PUSH
102869: LD_INT 30
102871: PUSH
102872: LD_INT 0
102874: PUSH
102875: EMPTY
102876: LIST
102877: LIST
102878: PUSH
102879: LD_INT 30
102881: PUSH
102882: LD_INT 1
102884: PUSH
102885: EMPTY
102886: LIST
102887: LIST
102888: PUSH
102889: EMPTY
102890: LIST
102891: LIST
102892: LIST
102893: PPUSH
102894: CALL_OW 72
102898: ST_TO_ADDR
// if not fac then
102899: LD_VAR 0 6
102903: NOT
102904: IFFALSE 102908
// continue ;
102906: GO 102756
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
102908: LD_ADDR_VAR 0 7
102912: PUSH
102913: LD_EXP 202
102917: PUSH
102918: LD_VAR 0 2
102922: ARRAY
102923: PPUSH
102924: LD_INT 22
102926: PUSH
102927: LD_VAR 0 5
102931: PUSH
102932: EMPTY
102933: LIST
102934: LIST
102935: PUSH
102936: LD_INT 21
102938: PUSH
102939: LD_INT 2
102941: PUSH
102942: EMPTY
102943: LIST
102944: LIST
102945: PUSH
102946: LD_INT 3
102948: PUSH
102949: LD_INT 24
102951: PUSH
102952: LD_INT 1000
102954: PUSH
102955: EMPTY
102956: LIST
102957: LIST
102958: PUSH
102959: EMPTY
102960: LIST
102961: LIST
102962: PUSH
102963: EMPTY
102964: LIST
102965: LIST
102966: LIST
102967: PPUSH
102968: CALL_OW 70
102972: ST_TO_ADDR
// for j in fac do
102973: LD_ADDR_VAR 0 3
102977: PUSH
102978: LD_VAR 0 6
102982: PUSH
102983: FOR_IN
102984: IFFALSE 103065
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
102986: LD_ADDR_VAR 0 7
102990: PUSH
102991: LD_VAR 0 7
102995: PUSH
102996: LD_INT 22
102998: PUSH
102999: LD_VAR 0 5
103003: PUSH
103004: EMPTY
103005: LIST
103006: LIST
103007: PUSH
103008: LD_INT 91
103010: PUSH
103011: LD_VAR 0 3
103015: PUSH
103016: LD_INT 15
103018: PUSH
103019: EMPTY
103020: LIST
103021: LIST
103022: LIST
103023: PUSH
103024: LD_INT 21
103026: PUSH
103027: LD_INT 2
103029: PUSH
103030: EMPTY
103031: LIST
103032: LIST
103033: PUSH
103034: LD_INT 3
103036: PUSH
103037: LD_INT 24
103039: PUSH
103040: LD_INT 1000
103042: PUSH
103043: EMPTY
103044: LIST
103045: LIST
103046: PUSH
103047: EMPTY
103048: LIST
103049: LIST
103050: PUSH
103051: EMPTY
103052: LIST
103053: LIST
103054: LIST
103055: LIST
103056: PPUSH
103057: CALL_OW 69
103061: UNION
103062: ST_TO_ADDR
103063: GO 102983
103065: POP
103066: POP
// if not vehs then
103067: LD_VAR 0 7
103071: NOT
103072: IFFALSE 103098
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
103074: LD_ADDR_EXP 190
103078: PUSH
103079: LD_EXP 190
103083: PPUSH
103084: LD_VAR 0 2
103088: PPUSH
103089: EMPTY
103090: PPUSH
103091: CALL_OW 1
103095: ST_TO_ADDR
// continue ;
103096: GO 102756
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
103098: LD_ADDR_VAR 0 8
103102: PUSH
103103: LD_EXP 178
103107: PUSH
103108: LD_VAR 0 2
103112: ARRAY
103113: PPUSH
103114: LD_INT 30
103116: PUSH
103117: LD_INT 3
103119: PUSH
103120: EMPTY
103121: LIST
103122: LIST
103123: PPUSH
103124: CALL_OW 72
103128: ST_TO_ADDR
// if tmp then
103129: LD_VAR 0 8
103133: IFFALSE 103236
// begin for j in tmp do
103135: LD_ADDR_VAR 0 3
103139: PUSH
103140: LD_VAR 0 8
103144: PUSH
103145: FOR_IN
103146: IFFALSE 103234
// for k in UnitsInside ( j ) do
103148: LD_ADDR_VAR 0 4
103152: PUSH
103153: LD_VAR 0 3
103157: PPUSH
103158: CALL_OW 313
103162: PUSH
103163: FOR_IN
103164: IFFALSE 103230
// if k then
103166: LD_VAR 0 4
103170: IFFALSE 103228
// if not k in mc_repair_vehicle [ i ] then
103172: LD_VAR 0 4
103176: PUSH
103177: LD_EXP 190
103181: PUSH
103182: LD_VAR 0 2
103186: ARRAY
103187: IN
103188: NOT
103189: IFFALSE 103228
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
103191: LD_ADDR_EXP 190
103195: PUSH
103196: LD_EXP 190
103200: PPUSH
103201: LD_VAR 0 2
103205: PPUSH
103206: LD_EXP 190
103210: PUSH
103211: LD_VAR 0 2
103215: ARRAY
103216: PUSH
103217: LD_VAR 0 4
103221: UNION
103222: PPUSH
103223: CALL_OW 1
103227: ST_TO_ADDR
103228: GO 103163
103230: POP
103231: POP
103232: GO 103145
103234: POP
103235: POP
// end ; if not mc_repair_vehicle [ i ] then
103236: LD_EXP 190
103240: PUSH
103241: LD_VAR 0 2
103245: ARRAY
103246: NOT
103247: IFFALSE 103251
// continue ;
103249: GO 102756
// for j in mc_repair_vehicle [ i ] do
103251: LD_ADDR_VAR 0 3
103255: PUSH
103256: LD_EXP 190
103260: PUSH
103261: LD_VAR 0 2
103265: ARRAY
103266: PUSH
103267: FOR_IN
103268: IFFALSE 103445
// begin if GetClass ( j ) <> 3 then
103270: LD_VAR 0 3
103274: PPUSH
103275: CALL_OW 257
103279: PUSH
103280: LD_INT 3
103282: NONEQUAL
103283: IFFALSE 103324
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
103285: LD_ADDR_EXP 190
103289: PUSH
103290: LD_EXP 190
103294: PPUSH
103295: LD_VAR 0 2
103299: PPUSH
103300: LD_EXP 190
103304: PUSH
103305: LD_VAR 0 2
103309: ARRAY
103310: PUSH
103311: LD_VAR 0 3
103315: DIFF
103316: PPUSH
103317: CALL_OW 1
103321: ST_TO_ADDR
// continue ;
103322: GO 103267
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
103324: LD_VAR 0 3
103328: PPUSH
103329: CALL_OW 311
103333: NOT
103334: PUSH
103335: LD_VAR 0 3
103339: PUSH
103340: LD_EXP 181
103344: PUSH
103345: LD_VAR 0 2
103349: ARRAY
103350: PUSH
103351: LD_INT 1
103353: ARRAY
103354: IN
103355: NOT
103356: AND
103357: PUSH
103358: LD_VAR 0 3
103362: PUSH
103363: LD_EXP 181
103367: PUSH
103368: LD_VAR 0 2
103372: ARRAY
103373: PUSH
103374: LD_INT 2
103376: ARRAY
103377: IN
103378: NOT
103379: AND
103380: IFFALSE 103443
// begin if IsInUnit ( j ) then
103382: LD_VAR 0 3
103386: PPUSH
103387: CALL_OW 310
103391: IFFALSE 103404
// ComExitBuilding ( j ) else
103393: LD_VAR 0 3
103397: PPUSH
103398: CALL_OW 122
103402: GO 103443
// if not WantToRepairVehicle ( j , vehs [ 1 ] ) then
103404: LD_VAR 0 3
103408: PPUSH
103409: LD_VAR 0 7
103413: PUSH
103414: LD_INT 1
103416: ARRAY
103417: PPUSH
103418: CALL 58018 0 2
103422: NOT
103423: IFFALSE 103443
// ComRepairVehicle ( j , vehs [ 1 ] ) ;
103425: LD_VAR 0 3
103429: PPUSH
103430: LD_VAR 0 7
103434: PUSH
103435: LD_INT 1
103437: ARRAY
103438: PPUSH
103439: CALL_OW 129
// end ; end ;
103443: GO 103267
103445: POP
103446: POP
// end ;
103447: GO 102756
103449: POP
103450: POP
// end ;
103451: LD_VAR 0 1
103455: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
103456: LD_INT 0
103458: PPUSH
103459: PPUSH
103460: PPUSH
103461: PPUSH
103462: PPUSH
103463: PPUSH
103464: PPUSH
103465: PPUSH
103466: PPUSH
103467: PPUSH
103468: PPUSH
// if not mc_bases then
103469: LD_EXP 178
103473: NOT
103474: IFFALSE 103478
// exit ;
103476: GO 104280
// for i = 1 to mc_bases do
103478: LD_ADDR_VAR 0 2
103482: PUSH
103483: DOUBLE
103484: LD_INT 1
103486: DEC
103487: ST_TO_ADDR
103488: LD_EXP 178
103492: PUSH
103493: FOR_TO
103494: IFFALSE 104278
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
103496: LD_EXP 206
103500: PUSH
103501: LD_VAR 0 2
103505: ARRAY
103506: NOT
103507: PUSH
103508: LD_EXP 181
103512: PUSH
103513: LD_VAR 0 2
103517: ARRAY
103518: PUSH
103519: LD_INT 1
103521: ARRAY
103522: OR
103523: PUSH
103524: LD_EXP 181
103528: PUSH
103529: LD_VAR 0 2
103533: ARRAY
103534: PUSH
103535: LD_INT 2
103537: ARRAY
103538: OR
103539: PUSH
103540: LD_EXP 204
103544: PUSH
103545: LD_VAR 0 2
103549: ARRAY
103550: PPUSH
103551: LD_INT 1
103553: PPUSH
103554: CALL_OW 325
103558: NOT
103559: OR
103560: PUSH
103561: LD_EXP 201
103565: PUSH
103566: LD_VAR 0 2
103570: ARRAY
103571: OR
103572: IFFALSE 103576
// continue ;
103574: GO 103493
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
103576: LD_ADDR_VAR 0 8
103580: PUSH
103581: LD_EXP 178
103585: PUSH
103586: LD_VAR 0 2
103590: ARRAY
103591: PPUSH
103592: LD_INT 25
103594: PUSH
103595: LD_INT 4
103597: PUSH
103598: EMPTY
103599: LIST
103600: LIST
103601: PUSH
103602: LD_INT 50
103604: PUSH
103605: EMPTY
103606: LIST
103607: PUSH
103608: LD_INT 3
103610: PUSH
103611: LD_INT 60
103613: PUSH
103614: EMPTY
103615: LIST
103616: PUSH
103617: EMPTY
103618: LIST
103619: LIST
103620: PUSH
103621: EMPTY
103622: LIST
103623: LIST
103624: LIST
103625: PPUSH
103626: CALL_OW 72
103630: PUSH
103631: LD_EXP 182
103635: PUSH
103636: LD_VAR 0 2
103640: ARRAY
103641: DIFF
103642: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
103643: LD_ADDR_VAR 0 9
103647: PUSH
103648: LD_EXP 178
103652: PUSH
103653: LD_VAR 0 2
103657: ARRAY
103658: PPUSH
103659: LD_INT 2
103661: PUSH
103662: LD_INT 30
103664: PUSH
103665: LD_INT 0
103667: PUSH
103668: EMPTY
103669: LIST
103670: LIST
103671: PUSH
103672: LD_INT 30
103674: PUSH
103675: LD_INT 1
103677: PUSH
103678: EMPTY
103679: LIST
103680: LIST
103681: PUSH
103682: EMPTY
103683: LIST
103684: LIST
103685: LIST
103686: PPUSH
103687: CALL_OW 72
103691: ST_TO_ADDR
// if not tmp or not dep then
103692: LD_VAR 0 8
103696: NOT
103697: PUSH
103698: LD_VAR 0 9
103702: NOT
103703: OR
103704: IFFALSE 103708
// continue ;
103706: GO 103493
// side := GetSide ( tmp [ 1 ] ) ;
103708: LD_ADDR_VAR 0 11
103712: PUSH
103713: LD_VAR 0 8
103717: PUSH
103718: LD_INT 1
103720: ARRAY
103721: PPUSH
103722: CALL_OW 255
103726: ST_TO_ADDR
// dep := dep [ 1 ] ;
103727: LD_ADDR_VAR 0 9
103731: PUSH
103732: LD_VAR 0 9
103736: PUSH
103737: LD_INT 1
103739: ARRAY
103740: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
103741: LD_ADDR_VAR 0 7
103745: PUSH
103746: LD_EXP 206
103750: PUSH
103751: LD_VAR 0 2
103755: ARRAY
103756: PPUSH
103757: LD_INT 22
103759: PUSH
103760: LD_INT 0
103762: PUSH
103763: EMPTY
103764: LIST
103765: LIST
103766: PUSH
103767: LD_INT 25
103769: PUSH
103770: LD_INT 12
103772: PUSH
103773: EMPTY
103774: LIST
103775: LIST
103776: PUSH
103777: EMPTY
103778: LIST
103779: LIST
103780: PPUSH
103781: CALL_OW 70
103785: PUSH
103786: LD_INT 22
103788: PUSH
103789: LD_INT 0
103791: PUSH
103792: EMPTY
103793: LIST
103794: LIST
103795: PUSH
103796: LD_INT 25
103798: PUSH
103799: LD_INT 12
103801: PUSH
103802: EMPTY
103803: LIST
103804: LIST
103805: PUSH
103806: LD_INT 91
103808: PUSH
103809: LD_VAR 0 9
103813: PUSH
103814: LD_INT 20
103816: PUSH
103817: EMPTY
103818: LIST
103819: LIST
103820: LIST
103821: PUSH
103822: EMPTY
103823: LIST
103824: LIST
103825: LIST
103826: PPUSH
103827: CALL_OW 69
103831: UNION
103832: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
103833: LD_ADDR_VAR 0 10
103837: PUSH
103838: LD_EXP 206
103842: PUSH
103843: LD_VAR 0 2
103847: ARRAY
103848: PPUSH
103849: LD_INT 81
103851: PUSH
103852: LD_VAR 0 11
103856: PUSH
103857: EMPTY
103858: LIST
103859: LIST
103860: PPUSH
103861: CALL_OW 70
103865: ST_TO_ADDR
// if not apes or danger_at_area then
103866: LD_VAR 0 7
103870: NOT
103871: PUSH
103872: LD_VAR 0 10
103876: OR
103877: IFFALSE 103927
// begin if mc_taming [ i ] then
103879: LD_EXP 209
103883: PUSH
103884: LD_VAR 0 2
103888: ARRAY
103889: IFFALSE 103925
// begin MC_Reset ( i , 121 ) ;
103891: LD_VAR 0 2
103895: PPUSH
103896: LD_INT 121
103898: PPUSH
103899: CALL 88913 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
103903: LD_ADDR_EXP 209
103907: PUSH
103908: LD_EXP 209
103912: PPUSH
103913: LD_VAR 0 2
103917: PPUSH
103918: EMPTY
103919: PPUSH
103920: CALL_OW 1
103924: ST_TO_ADDR
// end ; continue ;
103925: GO 103493
// end ; for j in tmp do
103927: LD_ADDR_VAR 0 3
103931: PUSH
103932: LD_VAR 0 8
103936: PUSH
103937: FOR_IN
103938: IFFALSE 104274
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
103940: LD_VAR 0 3
103944: PUSH
103945: LD_EXP 209
103949: PUSH
103950: LD_VAR 0 2
103954: ARRAY
103955: IN
103956: NOT
103957: PUSH
103958: LD_EXP 209
103962: PUSH
103963: LD_VAR 0 2
103967: ARRAY
103968: PUSH
103969: LD_INT 3
103971: LESS
103972: AND
103973: IFFALSE 104031
// begin SetTag ( j , 121 ) ;
103975: LD_VAR 0 3
103979: PPUSH
103980: LD_INT 121
103982: PPUSH
103983: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
103987: LD_ADDR_EXP 209
103991: PUSH
103992: LD_EXP 209
103996: PPUSH
103997: LD_VAR 0 2
104001: PUSH
104002: LD_EXP 209
104006: PUSH
104007: LD_VAR 0 2
104011: ARRAY
104012: PUSH
104013: LD_INT 1
104015: PLUS
104016: PUSH
104017: EMPTY
104018: LIST
104019: LIST
104020: PPUSH
104021: LD_VAR 0 3
104025: PPUSH
104026: CALL 24210 0 3
104030: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
104031: LD_VAR 0 3
104035: PUSH
104036: LD_EXP 209
104040: PUSH
104041: LD_VAR 0 2
104045: ARRAY
104046: IN
104047: IFFALSE 104272
// begin if GetClass ( j ) <> 4 then
104049: LD_VAR 0 3
104053: PPUSH
104054: CALL_OW 257
104058: PUSH
104059: LD_INT 4
104061: NONEQUAL
104062: IFFALSE 104115
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
104064: LD_ADDR_EXP 209
104068: PUSH
104069: LD_EXP 209
104073: PPUSH
104074: LD_VAR 0 2
104078: PPUSH
104079: LD_EXP 209
104083: PUSH
104084: LD_VAR 0 2
104088: ARRAY
104089: PUSH
104090: LD_VAR 0 3
104094: DIFF
104095: PPUSH
104096: CALL_OW 1
104100: ST_TO_ADDR
// SetTag ( j , 0 ) ;
104101: LD_VAR 0 3
104105: PPUSH
104106: LD_INT 0
104108: PPUSH
104109: CALL_OW 109
// continue ;
104113: GO 103937
// end ; if IsInUnit ( j ) then
104115: LD_VAR 0 3
104119: PPUSH
104120: CALL_OW 310
104124: IFFALSE 104135
// ComExitBuilding ( j ) ;
104126: LD_VAR 0 3
104130: PPUSH
104131: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
104135: LD_ADDR_VAR 0 6
104139: PUSH
104140: LD_VAR 0 7
104144: PPUSH
104145: LD_VAR 0 3
104149: PPUSH
104150: CALL_OW 74
104154: ST_TO_ADDR
// if not ape then
104155: LD_VAR 0 6
104159: NOT
104160: IFFALSE 104164
// break ;
104162: GO 104274
// x := GetX ( ape ) ;
104164: LD_ADDR_VAR 0 4
104168: PUSH
104169: LD_VAR 0 6
104173: PPUSH
104174: CALL_OW 250
104178: ST_TO_ADDR
// y := GetY ( ape ) ;
104179: LD_ADDR_VAR 0 5
104183: PUSH
104184: LD_VAR 0 6
104188: PPUSH
104189: CALL_OW 251
104193: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
104194: LD_VAR 0 4
104198: PPUSH
104199: LD_VAR 0 5
104203: PPUSH
104204: CALL_OW 488
104208: NOT
104209: PUSH
104210: LD_VAR 0 11
104214: PPUSH
104215: LD_VAR 0 4
104219: PPUSH
104220: LD_VAR 0 5
104224: PPUSH
104225: LD_INT 20
104227: PPUSH
104228: CALL 25106 0 4
104232: PUSH
104233: LD_INT 4
104235: ARRAY
104236: OR
104237: IFFALSE 104241
// break ;
104239: GO 104274
// if not HasTask ( j ) then
104241: LD_VAR 0 3
104245: PPUSH
104246: CALL_OW 314
104250: NOT
104251: IFFALSE 104272
// ComTameXY ( j , x , y ) ;
104253: LD_VAR 0 3
104257: PPUSH
104258: LD_VAR 0 4
104262: PPUSH
104263: LD_VAR 0 5
104267: PPUSH
104268: CALL_OW 131
// end ; end ;
104272: GO 103937
104274: POP
104275: POP
// end ;
104276: GO 103493
104278: POP
104279: POP
// end ;
104280: LD_VAR 0 1
104284: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
104285: LD_INT 0
104287: PPUSH
104288: PPUSH
104289: PPUSH
104290: PPUSH
104291: PPUSH
104292: PPUSH
104293: PPUSH
104294: PPUSH
// if not mc_bases then
104295: LD_EXP 178
104299: NOT
104300: IFFALSE 104304
// exit ;
104302: GO 104930
// for i = 1 to mc_bases do
104304: LD_ADDR_VAR 0 2
104308: PUSH
104309: DOUBLE
104310: LD_INT 1
104312: DEC
104313: ST_TO_ADDR
104314: LD_EXP 178
104318: PUSH
104319: FOR_TO
104320: IFFALSE 104928
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
104322: LD_EXP 207
104326: PUSH
104327: LD_VAR 0 2
104331: ARRAY
104332: NOT
104333: PUSH
104334: LD_EXP 207
104338: PUSH
104339: LD_VAR 0 2
104343: ARRAY
104344: PPUSH
104345: LD_INT 25
104347: PUSH
104348: LD_INT 12
104350: PUSH
104351: EMPTY
104352: LIST
104353: LIST
104354: PPUSH
104355: CALL_OW 72
104359: NOT
104360: OR
104361: IFFALSE 104365
// continue ;
104363: GO 104319
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
104365: LD_ADDR_VAR 0 5
104369: PUSH
104370: LD_EXP 207
104374: PUSH
104375: LD_VAR 0 2
104379: ARRAY
104380: PUSH
104381: LD_INT 1
104383: ARRAY
104384: PPUSH
104385: CALL_OW 255
104389: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
104390: LD_VAR 0 5
104394: PPUSH
104395: LD_INT 2
104397: PPUSH
104398: CALL_OW 325
104402: IFFALSE 104655
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
104404: LD_ADDR_VAR 0 4
104408: PUSH
104409: LD_EXP 207
104413: PUSH
104414: LD_VAR 0 2
104418: ARRAY
104419: PPUSH
104420: LD_INT 25
104422: PUSH
104423: LD_INT 16
104425: PUSH
104426: EMPTY
104427: LIST
104428: LIST
104429: PPUSH
104430: CALL_OW 72
104434: ST_TO_ADDR
// if tmp < 6 then
104435: LD_VAR 0 4
104439: PUSH
104440: LD_INT 6
104442: LESS
104443: IFFALSE 104655
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
104445: LD_ADDR_VAR 0 6
104449: PUSH
104450: LD_EXP 178
104454: PUSH
104455: LD_VAR 0 2
104459: ARRAY
104460: PPUSH
104461: LD_INT 2
104463: PUSH
104464: LD_INT 30
104466: PUSH
104467: LD_INT 0
104469: PUSH
104470: EMPTY
104471: LIST
104472: LIST
104473: PUSH
104474: LD_INT 30
104476: PUSH
104477: LD_INT 1
104479: PUSH
104480: EMPTY
104481: LIST
104482: LIST
104483: PUSH
104484: EMPTY
104485: LIST
104486: LIST
104487: LIST
104488: PPUSH
104489: CALL_OW 72
104493: ST_TO_ADDR
// if depot then
104494: LD_VAR 0 6
104498: IFFALSE 104655
// begin selected := 0 ;
104500: LD_ADDR_VAR 0 7
104504: PUSH
104505: LD_INT 0
104507: ST_TO_ADDR
// for j in depot do
104508: LD_ADDR_VAR 0 3
104512: PUSH
104513: LD_VAR 0 6
104517: PUSH
104518: FOR_IN
104519: IFFALSE 104550
// begin if UnitsInside ( j ) < 6 then
104521: LD_VAR 0 3
104525: PPUSH
104526: CALL_OW 313
104530: PUSH
104531: LD_INT 6
104533: LESS
104534: IFFALSE 104548
// begin selected := j ;
104536: LD_ADDR_VAR 0 7
104540: PUSH
104541: LD_VAR 0 3
104545: ST_TO_ADDR
// break ;
104546: GO 104550
// end ; end ;
104548: GO 104518
104550: POP
104551: POP
// if selected then
104552: LD_VAR 0 7
104556: IFFALSE 104655
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
104558: LD_ADDR_VAR 0 3
104562: PUSH
104563: LD_EXP 207
104567: PUSH
104568: LD_VAR 0 2
104572: ARRAY
104573: PPUSH
104574: LD_INT 25
104576: PUSH
104577: LD_INT 12
104579: PUSH
104580: EMPTY
104581: LIST
104582: LIST
104583: PPUSH
104584: CALL_OW 72
104588: PUSH
104589: FOR_IN
104590: IFFALSE 104653
// if not HasTask ( j ) then
104592: LD_VAR 0 3
104596: PPUSH
104597: CALL_OW 314
104601: NOT
104602: IFFALSE 104651
// begin if not IsInUnit ( j ) then
104604: LD_VAR 0 3
104608: PPUSH
104609: CALL_OW 310
104613: NOT
104614: IFFALSE 104630
// ComEnterUnit ( j , selected ) ;
104616: LD_VAR 0 3
104620: PPUSH
104621: LD_VAR 0 7
104625: PPUSH
104626: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
104630: LD_VAR 0 3
104634: PPUSH
104635: LD_INT 16
104637: PPUSH
104638: CALL_OW 183
// AddComExitBuilding ( j ) ;
104642: LD_VAR 0 3
104646: PPUSH
104647: CALL_OW 182
// end ;
104651: GO 104589
104653: POP
104654: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
104655: LD_VAR 0 5
104659: PPUSH
104660: LD_INT 11
104662: PPUSH
104663: CALL_OW 325
104667: IFFALSE 104926
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
104669: LD_ADDR_VAR 0 4
104673: PUSH
104674: LD_EXP 207
104678: PUSH
104679: LD_VAR 0 2
104683: ARRAY
104684: PPUSH
104685: LD_INT 25
104687: PUSH
104688: LD_INT 16
104690: PUSH
104691: EMPTY
104692: LIST
104693: LIST
104694: PPUSH
104695: CALL_OW 72
104699: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
104700: LD_VAR 0 4
104704: PUSH
104705: LD_INT 6
104707: GREATEREQUAL
104708: PUSH
104709: LD_VAR 0 5
104713: PPUSH
104714: LD_INT 2
104716: PPUSH
104717: CALL_OW 325
104721: NOT
104722: OR
104723: IFFALSE 104926
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
104725: LD_ADDR_VAR 0 8
104729: PUSH
104730: LD_EXP 178
104734: PUSH
104735: LD_VAR 0 2
104739: ARRAY
104740: PPUSH
104741: LD_INT 2
104743: PUSH
104744: LD_INT 30
104746: PUSH
104747: LD_INT 4
104749: PUSH
104750: EMPTY
104751: LIST
104752: LIST
104753: PUSH
104754: LD_INT 30
104756: PUSH
104757: LD_INT 5
104759: PUSH
104760: EMPTY
104761: LIST
104762: LIST
104763: PUSH
104764: EMPTY
104765: LIST
104766: LIST
104767: LIST
104768: PPUSH
104769: CALL_OW 72
104773: ST_TO_ADDR
// if barracks then
104774: LD_VAR 0 8
104778: IFFALSE 104926
// begin selected := 0 ;
104780: LD_ADDR_VAR 0 7
104784: PUSH
104785: LD_INT 0
104787: ST_TO_ADDR
// for j in barracks do
104788: LD_ADDR_VAR 0 3
104792: PUSH
104793: LD_VAR 0 8
104797: PUSH
104798: FOR_IN
104799: IFFALSE 104830
// begin if UnitsInside ( j ) < 6 then
104801: LD_VAR 0 3
104805: PPUSH
104806: CALL_OW 313
104810: PUSH
104811: LD_INT 6
104813: LESS
104814: IFFALSE 104828
// begin selected := j ;
104816: LD_ADDR_VAR 0 7
104820: PUSH
104821: LD_VAR 0 3
104825: ST_TO_ADDR
// break ;
104826: GO 104830
// end ; end ;
104828: GO 104798
104830: POP
104831: POP
// if selected then
104832: LD_VAR 0 7
104836: IFFALSE 104926
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
104838: LD_ADDR_VAR 0 3
104842: PUSH
104843: LD_EXP 207
104847: PUSH
104848: LD_VAR 0 2
104852: ARRAY
104853: PPUSH
104854: LD_INT 25
104856: PUSH
104857: LD_INT 12
104859: PUSH
104860: EMPTY
104861: LIST
104862: LIST
104863: PPUSH
104864: CALL_OW 72
104868: PUSH
104869: FOR_IN
104870: IFFALSE 104924
// if not IsInUnit ( j ) and not HasTask ( j ) then
104872: LD_VAR 0 3
104876: PPUSH
104877: CALL_OW 310
104881: NOT
104882: PUSH
104883: LD_VAR 0 3
104887: PPUSH
104888: CALL_OW 314
104892: NOT
104893: AND
104894: IFFALSE 104922
// begin ComEnterUnit ( j , selected ) ;
104896: LD_VAR 0 3
104900: PPUSH
104901: LD_VAR 0 7
104905: PPUSH
104906: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
104910: LD_VAR 0 3
104914: PPUSH
104915: LD_INT 15
104917: PPUSH
104918: CALL_OW 183
// end ;
104922: GO 104869
104924: POP
104925: POP
// end ; end ; end ; end ; end ;
104926: GO 104319
104928: POP
104929: POP
// end ;
104930: LD_VAR 0 1
104934: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
104935: LD_INT 0
104937: PPUSH
104938: PPUSH
104939: PPUSH
104940: PPUSH
// if not mc_bases then
104941: LD_EXP 178
104945: NOT
104946: IFFALSE 104950
// exit ;
104948: GO 105128
// for i = 1 to mc_bases do
104950: LD_ADDR_VAR 0 2
104954: PUSH
104955: DOUBLE
104956: LD_INT 1
104958: DEC
104959: ST_TO_ADDR
104960: LD_EXP 178
104964: PUSH
104965: FOR_TO
104966: IFFALSE 105126
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
104968: LD_ADDR_VAR 0 4
104972: PUSH
104973: LD_EXP 178
104977: PUSH
104978: LD_VAR 0 2
104982: ARRAY
104983: PPUSH
104984: LD_INT 25
104986: PUSH
104987: LD_INT 9
104989: PUSH
104990: EMPTY
104991: LIST
104992: LIST
104993: PPUSH
104994: CALL_OW 72
104998: ST_TO_ADDR
// if not tmp then
104999: LD_VAR 0 4
105003: NOT
105004: IFFALSE 105008
// continue ;
105006: GO 104965
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
105008: LD_EXP 204
105012: PUSH
105013: LD_VAR 0 2
105017: ARRAY
105018: PPUSH
105019: LD_INT 29
105021: PPUSH
105022: CALL_OW 325
105026: NOT
105027: PUSH
105028: LD_EXP 204
105032: PUSH
105033: LD_VAR 0 2
105037: ARRAY
105038: PPUSH
105039: LD_INT 28
105041: PPUSH
105042: CALL_OW 325
105046: NOT
105047: AND
105048: IFFALSE 105052
// continue ;
105050: GO 104965
// for j in tmp do
105052: LD_ADDR_VAR 0 3
105056: PUSH
105057: LD_VAR 0 4
105061: PUSH
105062: FOR_IN
105063: IFFALSE 105122
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
105065: LD_VAR 0 3
105069: PUSH
105070: LD_EXP 181
105074: PUSH
105075: LD_VAR 0 2
105079: ARRAY
105080: PUSH
105081: LD_INT 1
105083: ARRAY
105084: IN
105085: NOT
105086: PUSH
105087: LD_VAR 0 3
105091: PUSH
105092: LD_EXP 181
105096: PUSH
105097: LD_VAR 0 2
105101: ARRAY
105102: PUSH
105103: LD_INT 2
105105: ARRAY
105106: IN
105107: NOT
105108: AND
105109: IFFALSE 105120
// ComSpaceTimeShoot ( j ) ;
105111: LD_VAR 0 3
105115: PPUSH
105116: CALL 20171 0 1
105120: GO 105062
105122: POP
105123: POP
// end ;
105124: GO 104965
105126: POP
105127: POP
// end ;
105128: LD_VAR 0 1
105132: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
105133: LD_INT 0
105135: PPUSH
105136: PPUSH
105137: PPUSH
105138: PPUSH
105139: PPUSH
105140: PPUSH
105141: PPUSH
105142: PPUSH
105143: PPUSH
// if not mc_bases then
105144: LD_EXP 178
105148: NOT
105149: IFFALSE 105153
// exit ;
105151: GO 105775
// for i = 1 to mc_bases do
105153: LD_ADDR_VAR 0 2
105157: PUSH
105158: DOUBLE
105159: LD_INT 1
105161: DEC
105162: ST_TO_ADDR
105163: LD_EXP 178
105167: PUSH
105168: FOR_TO
105169: IFFALSE 105773
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
105171: LD_EXP 213
105175: PUSH
105176: LD_VAR 0 2
105180: ARRAY
105181: NOT
105182: PUSH
105183: LD_INT 38
105185: PPUSH
105186: LD_EXP 204
105190: PUSH
105191: LD_VAR 0 2
105195: ARRAY
105196: PPUSH
105197: CALL_OW 321
105201: PUSH
105202: LD_INT 2
105204: NONEQUAL
105205: OR
105206: IFFALSE 105210
// continue ;
105208: GO 105168
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
105210: LD_ADDR_VAR 0 8
105214: PUSH
105215: LD_EXP 178
105219: PUSH
105220: LD_VAR 0 2
105224: ARRAY
105225: PPUSH
105226: LD_INT 30
105228: PUSH
105229: LD_INT 34
105231: PUSH
105232: EMPTY
105233: LIST
105234: LIST
105235: PPUSH
105236: CALL_OW 72
105240: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
105241: LD_ADDR_VAR 0 9
105245: PUSH
105246: LD_EXP 178
105250: PUSH
105251: LD_VAR 0 2
105255: ARRAY
105256: PPUSH
105257: LD_INT 25
105259: PUSH
105260: LD_INT 4
105262: PUSH
105263: EMPTY
105264: LIST
105265: LIST
105266: PPUSH
105267: CALL_OW 72
105271: PPUSH
105272: LD_INT 0
105274: PPUSH
105275: CALL 53479 0 2
105279: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
105280: LD_VAR 0 9
105284: NOT
105285: PUSH
105286: LD_VAR 0 8
105290: NOT
105291: OR
105292: PUSH
105293: LD_EXP 178
105297: PUSH
105298: LD_VAR 0 2
105302: ARRAY
105303: PPUSH
105304: LD_INT 124
105306: PPUSH
105307: CALL 53479 0 2
105311: OR
105312: IFFALSE 105316
// continue ;
105314: GO 105168
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
105316: LD_EXP 214
105320: PUSH
105321: LD_VAR 0 2
105325: ARRAY
105326: PUSH
105327: LD_EXP 213
105331: PUSH
105332: LD_VAR 0 2
105336: ARRAY
105337: LESS
105338: PUSH
105339: LD_EXP 214
105343: PUSH
105344: LD_VAR 0 2
105348: ARRAY
105349: PUSH
105350: LD_VAR 0 8
105354: LESS
105355: AND
105356: IFFALSE 105771
// begin tmp := sci [ 1 ] ;
105358: LD_ADDR_VAR 0 7
105362: PUSH
105363: LD_VAR 0 9
105367: PUSH
105368: LD_INT 1
105370: ARRAY
105371: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
105372: LD_VAR 0 7
105376: PPUSH
105377: LD_INT 124
105379: PPUSH
105380: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
105384: LD_ADDR_VAR 0 3
105388: PUSH
105389: DOUBLE
105390: LD_EXP 213
105394: PUSH
105395: LD_VAR 0 2
105399: ARRAY
105400: INC
105401: ST_TO_ADDR
105402: LD_EXP 213
105406: PUSH
105407: LD_VAR 0 2
105411: ARRAY
105412: PUSH
105413: FOR_DOWNTO
105414: IFFALSE 105757
// begin if IsInUnit ( tmp ) then
105416: LD_VAR 0 7
105420: PPUSH
105421: CALL_OW 310
105425: IFFALSE 105436
// ComExitBuilding ( tmp ) ;
105427: LD_VAR 0 7
105431: PPUSH
105432: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
105436: LD_INT 35
105438: PPUSH
105439: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
105443: LD_VAR 0 7
105447: PPUSH
105448: CALL_OW 310
105452: NOT
105453: PUSH
105454: LD_VAR 0 7
105458: PPUSH
105459: CALL_OW 314
105463: NOT
105464: AND
105465: IFFALSE 105436
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
105467: LD_ADDR_VAR 0 6
105471: PUSH
105472: LD_VAR 0 7
105476: PPUSH
105477: CALL_OW 250
105481: PUSH
105482: LD_VAR 0 7
105486: PPUSH
105487: CALL_OW 251
105491: PUSH
105492: EMPTY
105493: LIST
105494: LIST
105495: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
105496: LD_INT 35
105498: PPUSH
105499: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
105503: LD_ADDR_VAR 0 4
105507: PUSH
105508: LD_EXP 213
105512: PUSH
105513: LD_VAR 0 2
105517: ARRAY
105518: PUSH
105519: LD_VAR 0 3
105523: ARRAY
105524: PUSH
105525: LD_INT 1
105527: ARRAY
105528: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
105529: LD_ADDR_VAR 0 5
105533: PUSH
105534: LD_EXP 213
105538: PUSH
105539: LD_VAR 0 2
105543: ARRAY
105544: PUSH
105545: LD_VAR 0 3
105549: ARRAY
105550: PUSH
105551: LD_INT 2
105553: ARRAY
105554: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
105555: LD_VAR 0 7
105559: PPUSH
105560: LD_INT 10
105562: PPUSH
105563: CALL 26809 0 2
105567: PUSH
105568: LD_INT 4
105570: ARRAY
105571: IFFALSE 105609
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
105573: LD_VAR 0 7
105577: PPUSH
105578: LD_VAR 0 6
105582: PUSH
105583: LD_INT 1
105585: ARRAY
105586: PPUSH
105587: LD_VAR 0 6
105591: PUSH
105592: LD_INT 2
105594: ARRAY
105595: PPUSH
105596: CALL_OW 111
// wait ( 0 0$10 ) ;
105600: LD_INT 350
105602: PPUSH
105603: CALL_OW 67
// end else
105607: GO 105635
// begin ComMoveXY ( tmp , x , y ) ;
105609: LD_VAR 0 7
105613: PPUSH
105614: LD_VAR 0 4
105618: PPUSH
105619: LD_VAR 0 5
105623: PPUSH
105624: CALL_OW 111
// wait ( 0 0$3 ) ;
105628: LD_INT 105
105630: PPUSH
105631: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
105635: LD_VAR 0 7
105639: PPUSH
105640: LD_VAR 0 4
105644: PPUSH
105645: LD_VAR 0 5
105649: PPUSH
105650: CALL_OW 307
105654: IFFALSE 105496
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
105656: LD_VAR 0 7
105660: PPUSH
105661: LD_VAR 0 4
105665: PPUSH
105666: LD_VAR 0 5
105670: PPUSH
105671: LD_VAR 0 8
105675: PUSH
105676: LD_VAR 0 3
105680: ARRAY
105681: PPUSH
105682: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
105686: LD_INT 35
105688: PPUSH
105689: CALL_OW 67
// until not HasTask ( tmp ) ;
105693: LD_VAR 0 7
105697: PPUSH
105698: CALL_OW 314
105702: NOT
105703: IFFALSE 105686
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
105705: LD_ADDR_EXP 214
105709: PUSH
105710: LD_EXP 214
105714: PPUSH
105715: LD_VAR 0 2
105719: PUSH
105720: LD_EXP 214
105724: PUSH
105725: LD_VAR 0 2
105729: ARRAY
105730: PUSH
105731: LD_INT 1
105733: PLUS
105734: PUSH
105735: EMPTY
105736: LIST
105737: LIST
105738: PPUSH
105739: LD_VAR 0 8
105743: PUSH
105744: LD_VAR 0 3
105748: ARRAY
105749: PPUSH
105750: CALL 24210 0 3
105754: ST_TO_ADDR
// end ;
105755: GO 105413
105757: POP
105758: POP
// MC_Reset ( i , 124 ) ;
105759: LD_VAR 0 2
105763: PPUSH
105764: LD_INT 124
105766: PPUSH
105767: CALL 88913 0 2
// end ; end ;
105771: GO 105168
105773: POP
105774: POP
// end ;
105775: LD_VAR 0 1
105779: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
105780: LD_INT 0
105782: PPUSH
105783: PPUSH
105784: PPUSH
// if not mc_bases then
105785: LD_EXP 178
105789: NOT
105790: IFFALSE 105794
// exit ;
105792: GO 106400
// for i = 1 to mc_bases do
105794: LD_ADDR_VAR 0 2
105798: PUSH
105799: DOUBLE
105800: LD_INT 1
105802: DEC
105803: ST_TO_ADDR
105804: LD_EXP 178
105808: PUSH
105809: FOR_TO
105810: IFFALSE 106398
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
105812: LD_ADDR_VAR 0 3
105816: PUSH
105817: LD_EXP 178
105821: PUSH
105822: LD_VAR 0 2
105826: ARRAY
105827: PPUSH
105828: LD_INT 25
105830: PUSH
105831: LD_INT 4
105833: PUSH
105834: EMPTY
105835: LIST
105836: LIST
105837: PPUSH
105838: CALL_OW 72
105842: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
105843: LD_VAR 0 3
105847: NOT
105848: PUSH
105849: LD_EXP 215
105853: PUSH
105854: LD_VAR 0 2
105858: ARRAY
105859: NOT
105860: OR
105861: PUSH
105862: LD_EXP 178
105866: PUSH
105867: LD_VAR 0 2
105871: ARRAY
105872: PPUSH
105873: LD_INT 2
105875: PUSH
105876: LD_INT 30
105878: PUSH
105879: LD_INT 0
105881: PUSH
105882: EMPTY
105883: LIST
105884: LIST
105885: PUSH
105886: LD_INT 30
105888: PUSH
105889: LD_INT 1
105891: PUSH
105892: EMPTY
105893: LIST
105894: LIST
105895: PUSH
105896: EMPTY
105897: LIST
105898: LIST
105899: LIST
105900: PPUSH
105901: CALL_OW 72
105905: NOT
105906: OR
105907: IFFALSE 105957
// begin if mc_deposits_finder [ i ] then
105909: LD_EXP 216
105913: PUSH
105914: LD_VAR 0 2
105918: ARRAY
105919: IFFALSE 105955
// begin MC_Reset ( i , 125 ) ;
105921: LD_VAR 0 2
105925: PPUSH
105926: LD_INT 125
105928: PPUSH
105929: CALL 88913 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
105933: LD_ADDR_EXP 216
105937: PUSH
105938: LD_EXP 216
105942: PPUSH
105943: LD_VAR 0 2
105947: PPUSH
105948: EMPTY
105949: PPUSH
105950: CALL_OW 1
105954: ST_TO_ADDR
// end ; continue ;
105955: GO 105809
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
105957: LD_EXP 215
105961: PUSH
105962: LD_VAR 0 2
105966: ARRAY
105967: PUSH
105968: LD_INT 1
105970: ARRAY
105971: PUSH
105972: LD_INT 3
105974: ARRAY
105975: PUSH
105976: LD_INT 1
105978: EQUAL
105979: PUSH
105980: LD_INT 20
105982: PPUSH
105983: LD_EXP 204
105987: PUSH
105988: LD_VAR 0 2
105992: ARRAY
105993: PPUSH
105994: CALL_OW 321
105998: PUSH
105999: LD_INT 2
106001: NONEQUAL
106002: AND
106003: IFFALSE 106053
// begin if mc_deposits_finder [ i ] then
106005: LD_EXP 216
106009: PUSH
106010: LD_VAR 0 2
106014: ARRAY
106015: IFFALSE 106051
// begin MC_Reset ( i , 125 ) ;
106017: LD_VAR 0 2
106021: PPUSH
106022: LD_INT 125
106024: PPUSH
106025: CALL 88913 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
106029: LD_ADDR_EXP 216
106033: PUSH
106034: LD_EXP 216
106038: PPUSH
106039: LD_VAR 0 2
106043: PPUSH
106044: EMPTY
106045: PPUSH
106046: CALL_OW 1
106050: ST_TO_ADDR
// end ; continue ;
106051: GO 105809
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
106053: LD_EXP 215
106057: PUSH
106058: LD_VAR 0 2
106062: ARRAY
106063: PUSH
106064: LD_INT 1
106066: ARRAY
106067: PUSH
106068: LD_INT 1
106070: ARRAY
106071: PPUSH
106072: LD_EXP 215
106076: PUSH
106077: LD_VAR 0 2
106081: ARRAY
106082: PUSH
106083: LD_INT 1
106085: ARRAY
106086: PUSH
106087: LD_INT 2
106089: ARRAY
106090: PPUSH
106091: LD_EXP 204
106095: PUSH
106096: LD_VAR 0 2
106100: ARRAY
106101: PPUSH
106102: CALL_OW 440
106106: IFFALSE 106149
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
106108: LD_ADDR_EXP 215
106112: PUSH
106113: LD_EXP 215
106117: PPUSH
106118: LD_VAR 0 2
106122: PPUSH
106123: LD_EXP 215
106127: PUSH
106128: LD_VAR 0 2
106132: ARRAY
106133: PPUSH
106134: LD_INT 1
106136: PPUSH
106137: CALL_OW 3
106141: PPUSH
106142: CALL_OW 1
106146: ST_TO_ADDR
106147: GO 106396
// begin if not mc_deposits_finder [ i ] then
106149: LD_EXP 216
106153: PUSH
106154: LD_VAR 0 2
106158: ARRAY
106159: NOT
106160: IFFALSE 106212
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
106162: LD_ADDR_EXP 216
106166: PUSH
106167: LD_EXP 216
106171: PPUSH
106172: LD_VAR 0 2
106176: PPUSH
106177: LD_VAR 0 3
106181: PUSH
106182: LD_INT 1
106184: ARRAY
106185: PUSH
106186: EMPTY
106187: LIST
106188: PPUSH
106189: CALL_OW 1
106193: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
106194: LD_VAR 0 3
106198: PUSH
106199: LD_INT 1
106201: ARRAY
106202: PPUSH
106203: LD_INT 125
106205: PPUSH
106206: CALL_OW 109
// end else
106210: GO 106396
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
106212: LD_EXP 216
106216: PUSH
106217: LD_VAR 0 2
106221: ARRAY
106222: PUSH
106223: LD_INT 1
106225: ARRAY
106226: PPUSH
106227: CALL_OW 310
106231: IFFALSE 106254
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
106233: LD_EXP 216
106237: PUSH
106238: LD_VAR 0 2
106242: ARRAY
106243: PUSH
106244: LD_INT 1
106246: ARRAY
106247: PPUSH
106248: CALL_OW 122
106252: GO 106396
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
106254: LD_EXP 216
106258: PUSH
106259: LD_VAR 0 2
106263: ARRAY
106264: PUSH
106265: LD_INT 1
106267: ARRAY
106268: PPUSH
106269: CALL_OW 314
106273: NOT
106274: PUSH
106275: LD_EXP 216
106279: PUSH
106280: LD_VAR 0 2
106284: ARRAY
106285: PUSH
106286: LD_INT 1
106288: ARRAY
106289: PPUSH
106290: LD_EXP 215
106294: PUSH
106295: LD_VAR 0 2
106299: ARRAY
106300: PUSH
106301: LD_INT 1
106303: ARRAY
106304: PUSH
106305: LD_INT 1
106307: ARRAY
106308: PPUSH
106309: LD_EXP 215
106313: PUSH
106314: LD_VAR 0 2
106318: ARRAY
106319: PUSH
106320: LD_INT 1
106322: ARRAY
106323: PUSH
106324: LD_INT 2
106326: ARRAY
106327: PPUSH
106328: CALL_OW 297
106332: PUSH
106333: LD_INT 6
106335: GREATER
106336: AND
106337: IFFALSE 106396
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
106339: LD_EXP 216
106343: PUSH
106344: LD_VAR 0 2
106348: ARRAY
106349: PUSH
106350: LD_INT 1
106352: ARRAY
106353: PPUSH
106354: LD_EXP 215
106358: PUSH
106359: LD_VAR 0 2
106363: ARRAY
106364: PUSH
106365: LD_INT 1
106367: ARRAY
106368: PUSH
106369: LD_INT 1
106371: ARRAY
106372: PPUSH
106373: LD_EXP 215
106377: PUSH
106378: LD_VAR 0 2
106382: ARRAY
106383: PUSH
106384: LD_INT 1
106386: ARRAY
106387: PUSH
106388: LD_INT 2
106390: ARRAY
106391: PPUSH
106392: CALL_OW 111
// end ; end ; end ;
106396: GO 105809
106398: POP
106399: POP
// end ;
106400: LD_VAR 0 1
106404: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
106405: LD_INT 0
106407: PPUSH
106408: PPUSH
106409: PPUSH
106410: PPUSH
106411: PPUSH
106412: PPUSH
106413: PPUSH
106414: PPUSH
106415: PPUSH
106416: PPUSH
106417: PPUSH
// if not mc_bases then
106418: LD_EXP 178
106422: NOT
106423: IFFALSE 106427
// exit ;
106425: GO 107367
// for i = 1 to mc_bases do
106427: LD_ADDR_VAR 0 2
106431: PUSH
106432: DOUBLE
106433: LD_INT 1
106435: DEC
106436: ST_TO_ADDR
106437: LD_EXP 178
106441: PUSH
106442: FOR_TO
106443: IFFALSE 107365
// begin if not mc_bases [ i ] or mc_scan [ i ] then
106445: LD_EXP 178
106449: PUSH
106450: LD_VAR 0 2
106454: ARRAY
106455: NOT
106456: PUSH
106457: LD_EXP 201
106461: PUSH
106462: LD_VAR 0 2
106466: ARRAY
106467: OR
106468: IFFALSE 106472
// continue ;
106470: GO 106442
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
106472: LD_ADDR_VAR 0 7
106476: PUSH
106477: LD_EXP 178
106481: PUSH
106482: LD_VAR 0 2
106486: ARRAY
106487: PUSH
106488: LD_INT 1
106490: ARRAY
106491: PPUSH
106492: CALL_OW 248
106496: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
106497: LD_VAR 0 7
106501: PUSH
106502: LD_INT 3
106504: EQUAL
106505: PUSH
106506: LD_EXP 197
106510: PUSH
106511: LD_VAR 0 2
106515: ARRAY
106516: PUSH
106517: LD_EXP 200
106521: PUSH
106522: LD_VAR 0 2
106526: ARRAY
106527: UNION
106528: PPUSH
106529: LD_INT 33
106531: PUSH
106532: LD_INT 2
106534: PUSH
106535: EMPTY
106536: LIST
106537: LIST
106538: PPUSH
106539: CALL_OW 72
106543: NOT
106544: OR
106545: IFFALSE 106549
// continue ;
106547: GO 106442
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
106549: LD_ADDR_VAR 0 9
106553: PUSH
106554: LD_EXP 178
106558: PUSH
106559: LD_VAR 0 2
106563: ARRAY
106564: PPUSH
106565: LD_INT 30
106567: PUSH
106568: LD_INT 36
106570: PUSH
106571: EMPTY
106572: LIST
106573: LIST
106574: PPUSH
106575: CALL_OW 72
106579: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
106580: LD_ADDR_VAR 0 10
106584: PUSH
106585: LD_EXP 197
106589: PUSH
106590: LD_VAR 0 2
106594: ARRAY
106595: PPUSH
106596: LD_INT 34
106598: PUSH
106599: LD_INT 31
106601: PUSH
106602: EMPTY
106603: LIST
106604: LIST
106605: PPUSH
106606: CALL_OW 72
106610: ST_TO_ADDR
// if not cts and not mcts then
106611: LD_VAR 0 9
106615: NOT
106616: PUSH
106617: LD_VAR 0 10
106621: NOT
106622: AND
106623: IFFALSE 106627
// continue ;
106625: GO 106442
// x := cts ;
106627: LD_ADDR_VAR 0 11
106631: PUSH
106632: LD_VAR 0 9
106636: ST_TO_ADDR
// if not x then
106637: LD_VAR 0 11
106641: NOT
106642: IFFALSE 106654
// x := mcts ;
106644: LD_ADDR_VAR 0 11
106648: PUSH
106649: LD_VAR 0 10
106653: ST_TO_ADDR
// if not x then
106654: LD_VAR 0 11
106658: NOT
106659: IFFALSE 106663
// continue ;
106661: GO 106442
// if mc_remote_driver [ i ] then
106663: LD_EXP 218
106667: PUSH
106668: LD_VAR 0 2
106672: ARRAY
106673: IFFALSE 107060
// for j in mc_remote_driver [ i ] do
106675: LD_ADDR_VAR 0 3
106679: PUSH
106680: LD_EXP 218
106684: PUSH
106685: LD_VAR 0 2
106689: ARRAY
106690: PUSH
106691: FOR_IN
106692: IFFALSE 107058
// begin if GetClass ( j ) <> 3 then
106694: LD_VAR 0 3
106698: PPUSH
106699: CALL_OW 257
106703: PUSH
106704: LD_INT 3
106706: NONEQUAL
106707: IFFALSE 106760
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
106709: LD_ADDR_EXP 218
106713: PUSH
106714: LD_EXP 218
106718: PPUSH
106719: LD_VAR 0 2
106723: PPUSH
106724: LD_EXP 218
106728: PUSH
106729: LD_VAR 0 2
106733: ARRAY
106734: PUSH
106735: LD_VAR 0 3
106739: DIFF
106740: PPUSH
106741: CALL_OW 1
106745: ST_TO_ADDR
// SetTag ( j , 0 ) ;
106746: LD_VAR 0 3
106750: PPUSH
106751: LD_INT 0
106753: PPUSH
106754: CALL_OW 109
// continue ;
106758: GO 106691
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
106760: LD_EXP 197
106764: PUSH
106765: LD_VAR 0 2
106769: ARRAY
106770: PPUSH
106771: LD_INT 34
106773: PUSH
106774: LD_INT 31
106776: PUSH
106777: EMPTY
106778: LIST
106779: LIST
106780: PUSH
106781: LD_INT 58
106783: PUSH
106784: EMPTY
106785: LIST
106786: PUSH
106787: EMPTY
106788: LIST
106789: LIST
106790: PPUSH
106791: CALL_OW 72
106795: PUSH
106796: LD_VAR 0 3
106800: PPUSH
106801: CALL 53567 0 1
106805: NOT
106806: AND
106807: IFFALSE 106878
// begin if IsInUnit ( j ) then
106809: LD_VAR 0 3
106813: PPUSH
106814: CALL_OW 310
106818: IFFALSE 106829
// ComExitBuilding ( j ) ;
106820: LD_VAR 0 3
106824: PPUSH
106825: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
106829: LD_VAR 0 3
106833: PPUSH
106834: LD_EXP 197
106838: PUSH
106839: LD_VAR 0 2
106843: ARRAY
106844: PPUSH
106845: LD_INT 34
106847: PUSH
106848: LD_INT 31
106850: PUSH
106851: EMPTY
106852: LIST
106853: LIST
106854: PUSH
106855: LD_INT 58
106857: PUSH
106858: EMPTY
106859: LIST
106860: PUSH
106861: EMPTY
106862: LIST
106863: LIST
106864: PPUSH
106865: CALL_OW 72
106869: PUSH
106870: LD_INT 1
106872: ARRAY
106873: PPUSH
106874: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
106878: LD_VAR 0 3
106882: PPUSH
106883: CALL_OW 310
106887: NOT
106888: PUSH
106889: LD_VAR 0 3
106893: PPUSH
106894: CALL_OW 310
106898: PPUSH
106899: CALL_OW 266
106903: PUSH
106904: LD_INT 36
106906: NONEQUAL
106907: PUSH
106908: LD_VAR 0 3
106912: PPUSH
106913: CALL 53567 0 1
106917: NOT
106918: AND
106919: OR
106920: IFFALSE 107056
// begin if IsInUnit ( j ) then
106922: LD_VAR 0 3
106926: PPUSH
106927: CALL_OW 310
106931: IFFALSE 106942
// ComExitBuilding ( j ) ;
106933: LD_VAR 0 3
106937: PPUSH
106938: CALL_OW 122
// ct := 0 ;
106942: LD_ADDR_VAR 0 8
106946: PUSH
106947: LD_INT 0
106949: ST_TO_ADDR
// for k in x do
106950: LD_ADDR_VAR 0 4
106954: PUSH
106955: LD_VAR 0 11
106959: PUSH
106960: FOR_IN
106961: IFFALSE 107034
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
106963: LD_VAR 0 4
106967: PPUSH
106968: CALL_OW 264
106972: PUSH
106973: LD_INT 31
106975: EQUAL
106976: PUSH
106977: LD_VAR 0 4
106981: PPUSH
106982: CALL_OW 311
106986: NOT
106987: AND
106988: PUSH
106989: LD_VAR 0 4
106993: PPUSH
106994: CALL_OW 266
106998: PUSH
106999: LD_INT 36
107001: EQUAL
107002: PUSH
107003: LD_VAR 0 4
107007: PPUSH
107008: CALL_OW 313
107012: PUSH
107013: LD_INT 3
107015: LESS
107016: AND
107017: OR
107018: IFFALSE 107032
// begin ct := k ;
107020: LD_ADDR_VAR 0 8
107024: PUSH
107025: LD_VAR 0 4
107029: ST_TO_ADDR
// break ;
107030: GO 107034
// end ;
107032: GO 106960
107034: POP
107035: POP
// if ct then
107036: LD_VAR 0 8
107040: IFFALSE 107056
// ComEnterUnit ( j , ct ) ;
107042: LD_VAR 0 3
107046: PPUSH
107047: LD_VAR 0 8
107051: PPUSH
107052: CALL_OW 120
// end ; end ;
107056: GO 106691
107058: POP
107059: POP
// places := 0 ;
107060: LD_ADDR_VAR 0 5
107064: PUSH
107065: LD_INT 0
107067: ST_TO_ADDR
// for j = 1 to x do
107068: LD_ADDR_VAR 0 3
107072: PUSH
107073: DOUBLE
107074: LD_INT 1
107076: DEC
107077: ST_TO_ADDR
107078: LD_VAR 0 11
107082: PUSH
107083: FOR_TO
107084: IFFALSE 107160
// if GetWeapon ( x [ j ] ) = ar_control_tower then
107086: LD_VAR 0 11
107090: PUSH
107091: LD_VAR 0 3
107095: ARRAY
107096: PPUSH
107097: CALL_OW 264
107101: PUSH
107102: LD_INT 31
107104: EQUAL
107105: IFFALSE 107123
// places := places + 1 else
107107: LD_ADDR_VAR 0 5
107111: PUSH
107112: LD_VAR 0 5
107116: PUSH
107117: LD_INT 1
107119: PLUS
107120: ST_TO_ADDR
107121: GO 107158
// if GetBType ( x [ j ] ) = b_control_tower then
107123: LD_VAR 0 11
107127: PUSH
107128: LD_VAR 0 3
107132: ARRAY
107133: PPUSH
107134: CALL_OW 266
107138: PUSH
107139: LD_INT 36
107141: EQUAL
107142: IFFALSE 107158
// places := places + 3 ;
107144: LD_ADDR_VAR 0 5
107148: PUSH
107149: LD_VAR 0 5
107153: PUSH
107154: LD_INT 3
107156: PLUS
107157: ST_TO_ADDR
107158: GO 107083
107160: POP
107161: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
107162: LD_VAR 0 5
107166: PUSH
107167: LD_INT 0
107169: EQUAL
107170: PUSH
107171: LD_VAR 0 5
107175: PUSH
107176: LD_EXP 218
107180: PUSH
107181: LD_VAR 0 2
107185: ARRAY
107186: LESSEQUAL
107187: OR
107188: IFFALSE 107192
// continue ;
107190: GO 106442
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
107192: LD_ADDR_VAR 0 6
107196: PUSH
107197: LD_EXP 178
107201: PUSH
107202: LD_VAR 0 2
107206: ARRAY
107207: PPUSH
107208: LD_INT 25
107210: PUSH
107211: LD_INT 3
107213: PUSH
107214: EMPTY
107215: LIST
107216: LIST
107217: PPUSH
107218: CALL_OW 72
107222: PUSH
107223: LD_EXP 218
107227: PUSH
107228: LD_VAR 0 2
107232: ARRAY
107233: DIFF
107234: PPUSH
107235: LD_INT 3
107237: PPUSH
107238: CALL 54467 0 2
107242: ST_TO_ADDR
// for j in tmp do
107243: LD_ADDR_VAR 0 3
107247: PUSH
107248: LD_VAR 0 6
107252: PUSH
107253: FOR_IN
107254: IFFALSE 107289
// if GetTag ( j ) > 0 then
107256: LD_VAR 0 3
107260: PPUSH
107261: CALL_OW 110
107265: PUSH
107266: LD_INT 0
107268: GREATER
107269: IFFALSE 107287
// tmp := tmp diff j ;
107271: LD_ADDR_VAR 0 6
107275: PUSH
107276: LD_VAR 0 6
107280: PUSH
107281: LD_VAR 0 3
107285: DIFF
107286: ST_TO_ADDR
107287: GO 107253
107289: POP
107290: POP
// if not tmp then
107291: LD_VAR 0 6
107295: NOT
107296: IFFALSE 107300
// continue ;
107298: GO 106442
// if places then
107300: LD_VAR 0 5
107304: IFFALSE 107363
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
107306: LD_ADDR_EXP 218
107310: PUSH
107311: LD_EXP 218
107315: PPUSH
107316: LD_VAR 0 2
107320: PPUSH
107321: LD_EXP 218
107325: PUSH
107326: LD_VAR 0 2
107330: ARRAY
107331: PUSH
107332: LD_VAR 0 6
107336: PUSH
107337: LD_INT 1
107339: ARRAY
107340: UNION
107341: PPUSH
107342: CALL_OW 1
107346: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
107347: LD_VAR 0 6
107351: PUSH
107352: LD_INT 1
107354: ARRAY
107355: PPUSH
107356: LD_INT 126
107358: PPUSH
107359: CALL_OW 109
// end ; end ;
107363: GO 106442
107365: POP
107366: POP
// end ;
107367: LD_VAR 0 1
107371: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
107372: LD_INT 0
107374: PPUSH
107375: PPUSH
107376: PPUSH
107377: PPUSH
107378: PPUSH
107379: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
107380: LD_VAR 0 1
107384: NOT
107385: PUSH
107386: LD_VAR 0 2
107390: NOT
107391: OR
107392: PUSH
107393: LD_VAR 0 3
107397: NOT
107398: OR
107399: PUSH
107400: LD_VAR 0 4
107404: PUSH
107405: LD_INT 1
107407: PUSH
107408: LD_INT 2
107410: PUSH
107411: LD_INT 3
107413: PUSH
107414: LD_INT 4
107416: PUSH
107417: LD_INT 5
107419: PUSH
107420: LD_INT 8
107422: PUSH
107423: LD_INT 9
107425: PUSH
107426: LD_INT 15
107428: PUSH
107429: LD_INT 16
107431: PUSH
107432: EMPTY
107433: LIST
107434: LIST
107435: LIST
107436: LIST
107437: LIST
107438: LIST
107439: LIST
107440: LIST
107441: LIST
107442: IN
107443: NOT
107444: OR
107445: IFFALSE 107449
// exit ;
107447: GO 108349
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
107449: LD_ADDR_VAR 0 2
107453: PUSH
107454: LD_VAR 0 2
107458: PPUSH
107459: LD_INT 21
107461: PUSH
107462: LD_INT 3
107464: PUSH
107465: EMPTY
107466: LIST
107467: LIST
107468: PUSH
107469: LD_INT 24
107471: PUSH
107472: LD_INT 250
107474: PUSH
107475: EMPTY
107476: LIST
107477: LIST
107478: PUSH
107479: EMPTY
107480: LIST
107481: LIST
107482: PPUSH
107483: CALL_OW 72
107487: ST_TO_ADDR
// case class of 1 , 15 :
107488: LD_VAR 0 4
107492: PUSH
107493: LD_INT 1
107495: DOUBLE
107496: EQUAL
107497: IFTRUE 107507
107499: LD_INT 15
107501: DOUBLE
107502: EQUAL
107503: IFTRUE 107507
107505: GO 107592
107507: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
107508: LD_ADDR_VAR 0 8
107512: PUSH
107513: LD_VAR 0 2
107517: PPUSH
107518: LD_INT 2
107520: PUSH
107521: LD_INT 30
107523: PUSH
107524: LD_INT 32
107526: PUSH
107527: EMPTY
107528: LIST
107529: LIST
107530: PUSH
107531: LD_INT 30
107533: PUSH
107534: LD_INT 31
107536: PUSH
107537: EMPTY
107538: LIST
107539: LIST
107540: PUSH
107541: EMPTY
107542: LIST
107543: LIST
107544: LIST
107545: PPUSH
107546: CALL_OW 72
107550: PUSH
107551: LD_VAR 0 2
107555: PPUSH
107556: LD_INT 2
107558: PUSH
107559: LD_INT 30
107561: PUSH
107562: LD_INT 4
107564: PUSH
107565: EMPTY
107566: LIST
107567: LIST
107568: PUSH
107569: LD_INT 30
107571: PUSH
107572: LD_INT 5
107574: PUSH
107575: EMPTY
107576: LIST
107577: LIST
107578: PUSH
107579: EMPTY
107580: LIST
107581: LIST
107582: LIST
107583: PPUSH
107584: CALL_OW 72
107588: ADD
107589: ST_TO_ADDR
107590: GO 107838
107592: LD_INT 2
107594: DOUBLE
107595: EQUAL
107596: IFTRUE 107606
107598: LD_INT 16
107600: DOUBLE
107601: EQUAL
107602: IFTRUE 107606
107604: GO 107652
107606: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
107607: LD_ADDR_VAR 0 8
107611: PUSH
107612: LD_VAR 0 2
107616: PPUSH
107617: LD_INT 2
107619: PUSH
107620: LD_INT 30
107622: PUSH
107623: LD_INT 0
107625: PUSH
107626: EMPTY
107627: LIST
107628: LIST
107629: PUSH
107630: LD_INT 30
107632: PUSH
107633: LD_INT 1
107635: PUSH
107636: EMPTY
107637: LIST
107638: LIST
107639: PUSH
107640: EMPTY
107641: LIST
107642: LIST
107643: LIST
107644: PPUSH
107645: CALL_OW 72
107649: ST_TO_ADDR
107650: GO 107838
107652: LD_INT 3
107654: DOUBLE
107655: EQUAL
107656: IFTRUE 107660
107658: GO 107706
107660: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
107661: LD_ADDR_VAR 0 8
107665: PUSH
107666: LD_VAR 0 2
107670: PPUSH
107671: LD_INT 2
107673: PUSH
107674: LD_INT 30
107676: PUSH
107677: LD_INT 2
107679: PUSH
107680: EMPTY
107681: LIST
107682: LIST
107683: PUSH
107684: LD_INT 30
107686: PUSH
107687: LD_INT 3
107689: PUSH
107690: EMPTY
107691: LIST
107692: LIST
107693: PUSH
107694: EMPTY
107695: LIST
107696: LIST
107697: LIST
107698: PPUSH
107699: CALL_OW 72
107703: ST_TO_ADDR
107704: GO 107838
107706: LD_INT 4
107708: DOUBLE
107709: EQUAL
107710: IFTRUE 107714
107712: GO 107771
107714: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
107715: LD_ADDR_VAR 0 8
107719: PUSH
107720: LD_VAR 0 2
107724: PPUSH
107725: LD_INT 2
107727: PUSH
107728: LD_INT 30
107730: PUSH
107731: LD_INT 6
107733: PUSH
107734: EMPTY
107735: LIST
107736: LIST
107737: PUSH
107738: LD_INT 30
107740: PUSH
107741: LD_INT 7
107743: PUSH
107744: EMPTY
107745: LIST
107746: LIST
107747: PUSH
107748: LD_INT 30
107750: PUSH
107751: LD_INT 8
107753: PUSH
107754: EMPTY
107755: LIST
107756: LIST
107757: PUSH
107758: EMPTY
107759: LIST
107760: LIST
107761: LIST
107762: LIST
107763: PPUSH
107764: CALL_OW 72
107768: ST_TO_ADDR
107769: GO 107838
107771: LD_INT 5
107773: DOUBLE
107774: EQUAL
107775: IFTRUE 107791
107777: LD_INT 8
107779: DOUBLE
107780: EQUAL
107781: IFTRUE 107791
107783: LD_INT 9
107785: DOUBLE
107786: EQUAL
107787: IFTRUE 107791
107789: GO 107837
107791: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
107792: LD_ADDR_VAR 0 8
107796: PUSH
107797: LD_VAR 0 2
107801: PPUSH
107802: LD_INT 2
107804: PUSH
107805: LD_INT 30
107807: PUSH
107808: LD_INT 4
107810: PUSH
107811: EMPTY
107812: LIST
107813: LIST
107814: PUSH
107815: LD_INT 30
107817: PUSH
107818: LD_INT 5
107820: PUSH
107821: EMPTY
107822: LIST
107823: LIST
107824: PUSH
107825: EMPTY
107826: LIST
107827: LIST
107828: LIST
107829: PPUSH
107830: CALL_OW 72
107834: ST_TO_ADDR
107835: GO 107838
107837: POP
// if not tmp then
107838: LD_VAR 0 8
107842: NOT
107843: IFFALSE 107847
// exit ;
107845: GO 108349
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
107847: LD_VAR 0 4
107851: PUSH
107852: LD_INT 1
107854: PUSH
107855: LD_INT 15
107857: PUSH
107858: EMPTY
107859: LIST
107860: LIST
107861: IN
107862: PUSH
107863: LD_EXP 187
107867: PUSH
107868: LD_VAR 0 1
107872: ARRAY
107873: AND
107874: IFFALSE 108030
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
107876: LD_ADDR_VAR 0 9
107880: PUSH
107881: LD_EXP 187
107885: PUSH
107886: LD_VAR 0 1
107890: ARRAY
107891: PUSH
107892: LD_INT 1
107894: ARRAY
107895: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
107896: LD_VAR 0 9
107900: PUSH
107901: LD_EXP 188
107905: PUSH
107906: LD_VAR 0 1
107910: ARRAY
107911: IN
107912: NOT
107913: IFFALSE 108028
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
107915: LD_ADDR_EXP 188
107919: PUSH
107920: LD_EXP 188
107924: PPUSH
107925: LD_VAR 0 1
107929: PUSH
107930: LD_EXP 188
107934: PUSH
107935: LD_VAR 0 1
107939: ARRAY
107940: PUSH
107941: LD_INT 1
107943: PLUS
107944: PUSH
107945: EMPTY
107946: LIST
107947: LIST
107948: PPUSH
107949: LD_VAR 0 9
107953: PPUSH
107954: CALL 24210 0 3
107958: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
107959: LD_ADDR_EXP 187
107963: PUSH
107964: LD_EXP 187
107968: PPUSH
107969: LD_VAR 0 1
107973: PPUSH
107974: LD_EXP 187
107978: PUSH
107979: LD_VAR 0 1
107983: ARRAY
107984: PUSH
107985: LD_VAR 0 9
107989: DIFF
107990: PPUSH
107991: CALL_OW 1
107995: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
107996: LD_VAR 0 3
108000: PPUSH
108001: LD_EXP 188
108005: PUSH
108006: LD_VAR 0 1
108010: ARRAY
108011: PUSH
108012: LD_EXP 188
108016: PUSH
108017: LD_VAR 0 1
108021: ARRAY
108022: ARRAY
108023: PPUSH
108024: CALL_OW 120
// end ; exit ;
108028: GO 108349
// end ; if tmp > 1 then
108030: LD_VAR 0 8
108034: PUSH
108035: LD_INT 1
108037: GREATER
108038: IFFALSE 108142
// for i = 2 to tmp do
108040: LD_ADDR_VAR 0 6
108044: PUSH
108045: DOUBLE
108046: LD_INT 2
108048: DEC
108049: ST_TO_ADDR
108050: LD_VAR 0 8
108054: PUSH
108055: FOR_TO
108056: IFFALSE 108140
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
108058: LD_VAR 0 8
108062: PUSH
108063: LD_VAR 0 6
108067: ARRAY
108068: PPUSH
108069: CALL_OW 461
108073: PUSH
108074: LD_INT 6
108076: EQUAL
108077: IFFALSE 108138
// begin x := tmp [ i ] ;
108079: LD_ADDR_VAR 0 9
108083: PUSH
108084: LD_VAR 0 8
108088: PUSH
108089: LD_VAR 0 6
108093: ARRAY
108094: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
108095: LD_ADDR_VAR 0 8
108099: PUSH
108100: LD_VAR 0 8
108104: PPUSH
108105: LD_VAR 0 6
108109: PPUSH
108110: CALL_OW 3
108114: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
108115: LD_ADDR_VAR 0 8
108119: PUSH
108120: LD_VAR 0 8
108124: PPUSH
108125: LD_INT 1
108127: PPUSH
108128: LD_VAR 0 9
108132: PPUSH
108133: CALL_OW 2
108137: ST_TO_ADDR
// end ;
108138: GO 108055
108140: POP
108141: POP
// for i in tmp do
108142: LD_ADDR_VAR 0 6
108146: PUSH
108147: LD_VAR 0 8
108151: PUSH
108152: FOR_IN
108153: IFFALSE 108222
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
108155: LD_VAR 0 6
108159: PPUSH
108160: CALL_OW 313
108164: PUSH
108165: LD_INT 6
108167: LESS
108168: PUSH
108169: LD_VAR 0 6
108173: PPUSH
108174: CALL_OW 266
108178: PUSH
108179: LD_INT 31
108181: PUSH
108182: LD_INT 32
108184: PUSH
108185: EMPTY
108186: LIST
108187: LIST
108188: IN
108189: NOT
108190: AND
108191: PUSH
108192: LD_VAR 0 6
108196: PPUSH
108197: CALL_OW 313
108201: PUSH
108202: LD_INT 0
108204: EQUAL
108205: OR
108206: IFFALSE 108220
// begin j := i ;
108208: LD_ADDR_VAR 0 7
108212: PUSH
108213: LD_VAR 0 6
108217: ST_TO_ADDR
// break ;
108218: GO 108222
// end ; end ;
108220: GO 108152
108222: POP
108223: POP
// if j then
108224: LD_VAR 0 7
108228: IFFALSE 108246
// ComEnterUnit ( unit , j ) else
108230: LD_VAR 0 3
108234: PPUSH
108235: LD_VAR 0 7
108239: PPUSH
108240: CALL_OW 120
108244: GO 108349
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
108246: LD_ADDR_VAR 0 10
108250: PUSH
108251: LD_VAR 0 2
108255: PPUSH
108256: LD_INT 2
108258: PUSH
108259: LD_INT 30
108261: PUSH
108262: LD_INT 0
108264: PUSH
108265: EMPTY
108266: LIST
108267: LIST
108268: PUSH
108269: LD_INT 30
108271: PUSH
108272: LD_INT 1
108274: PUSH
108275: EMPTY
108276: LIST
108277: LIST
108278: PUSH
108279: EMPTY
108280: LIST
108281: LIST
108282: LIST
108283: PPUSH
108284: CALL_OW 72
108288: ST_TO_ADDR
// if depot then
108289: LD_VAR 0 10
108293: IFFALSE 108349
// begin depot := NearestUnitToUnit ( depot , unit ) ;
108295: LD_ADDR_VAR 0 10
108299: PUSH
108300: LD_VAR 0 10
108304: PPUSH
108305: LD_VAR 0 3
108309: PPUSH
108310: CALL_OW 74
108314: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
108315: LD_VAR 0 3
108319: PPUSH
108320: LD_VAR 0 10
108324: PPUSH
108325: CALL_OW 296
108329: PUSH
108330: LD_INT 10
108332: GREATER
108333: IFFALSE 108349
// ComStandNearbyBuilding ( unit , depot ) ;
108335: LD_VAR 0 3
108339: PPUSH
108340: LD_VAR 0 10
108344: PPUSH
108345: CALL 20788 0 2
// end ; end ; end ;
108349: LD_VAR 0 5
108353: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
108354: LD_INT 0
108356: PPUSH
108357: PPUSH
108358: PPUSH
108359: PPUSH
// if not mc_bases then
108360: LD_EXP 178
108364: NOT
108365: IFFALSE 108369
// exit ;
108367: GO 108608
// for i = 1 to mc_bases do
108369: LD_ADDR_VAR 0 2
108373: PUSH
108374: DOUBLE
108375: LD_INT 1
108377: DEC
108378: ST_TO_ADDR
108379: LD_EXP 178
108383: PUSH
108384: FOR_TO
108385: IFFALSE 108606
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
108387: LD_ADDR_VAR 0 4
108391: PUSH
108392: LD_EXP 178
108396: PUSH
108397: LD_VAR 0 2
108401: ARRAY
108402: PPUSH
108403: LD_INT 21
108405: PUSH
108406: LD_INT 1
108408: PUSH
108409: EMPTY
108410: LIST
108411: LIST
108412: PPUSH
108413: CALL_OW 72
108417: PUSH
108418: LD_EXP 207
108422: PUSH
108423: LD_VAR 0 2
108427: ARRAY
108428: UNION
108429: ST_TO_ADDR
// if not tmp then
108430: LD_VAR 0 4
108434: NOT
108435: IFFALSE 108439
// continue ;
108437: GO 108384
// for j in tmp do
108439: LD_ADDR_VAR 0 3
108443: PUSH
108444: LD_VAR 0 4
108448: PUSH
108449: FOR_IN
108450: IFFALSE 108602
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
108452: LD_VAR 0 3
108456: PPUSH
108457: CALL_OW 110
108461: NOT
108462: PUSH
108463: LD_VAR 0 3
108467: PPUSH
108468: CALL_OW 314
108472: NOT
108473: AND
108474: PUSH
108475: LD_VAR 0 3
108479: PPUSH
108480: CALL_OW 311
108484: NOT
108485: AND
108486: PUSH
108487: LD_VAR 0 3
108491: PPUSH
108492: CALL_OW 310
108496: NOT
108497: AND
108498: PUSH
108499: LD_VAR 0 3
108503: PUSH
108504: LD_EXP 181
108508: PUSH
108509: LD_VAR 0 2
108513: ARRAY
108514: PUSH
108515: LD_INT 1
108517: ARRAY
108518: IN
108519: NOT
108520: AND
108521: PUSH
108522: LD_VAR 0 3
108526: PUSH
108527: LD_EXP 181
108531: PUSH
108532: LD_VAR 0 2
108536: ARRAY
108537: PUSH
108538: LD_INT 2
108540: ARRAY
108541: IN
108542: NOT
108543: AND
108544: PUSH
108545: LD_VAR 0 3
108549: PUSH
108550: LD_EXP 190
108554: PUSH
108555: LD_VAR 0 2
108559: ARRAY
108560: IN
108561: NOT
108562: AND
108563: IFFALSE 108600
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
108565: LD_VAR 0 2
108569: PPUSH
108570: LD_EXP 178
108574: PUSH
108575: LD_VAR 0 2
108579: ARRAY
108580: PPUSH
108581: LD_VAR 0 3
108585: PPUSH
108586: LD_VAR 0 3
108590: PPUSH
108591: CALL_OW 257
108595: PPUSH
108596: CALL 107372 0 4
// end ;
108600: GO 108449
108602: POP
108603: POP
// end ;
108604: GO 108384
108606: POP
108607: POP
// end ;
108608: LD_VAR 0 1
108612: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
108613: LD_INT 0
108615: PPUSH
108616: PPUSH
108617: PPUSH
108618: PPUSH
108619: PPUSH
108620: PPUSH
// if not mc_bases [ base ] then
108621: LD_EXP 178
108625: PUSH
108626: LD_VAR 0 1
108630: ARRAY
108631: NOT
108632: IFFALSE 108636
// exit ;
108634: GO 108818
// tmp := [ ] ;
108636: LD_ADDR_VAR 0 6
108640: PUSH
108641: EMPTY
108642: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
108643: LD_ADDR_VAR 0 7
108647: PUSH
108648: LD_VAR 0 3
108652: PPUSH
108653: LD_INT 0
108655: PPUSH
108656: CALL_OW 517
108660: ST_TO_ADDR
// if not list then
108661: LD_VAR 0 7
108665: NOT
108666: IFFALSE 108670
// exit ;
108668: GO 108818
// for i = 1 to amount do
108670: LD_ADDR_VAR 0 5
108674: PUSH
108675: DOUBLE
108676: LD_INT 1
108678: DEC
108679: ST_TO_ADDR
108680: LD_VAR 0 2
108684: PUSH
108685: FOR_TO
108686: IFFALSE 108766
// begin x := rand ( 1 , list [ 1 ] ) ;
108688: LD_ADDR_VAR 0 8
108692: PUSH
108693: LD_INT 1
108695: PPUSH
108696: LD_VAR 0 7
108700: PUSH
108701: LD_INT 1
108703: ARRAY
108704: PPUSH
108705: CALL_OW 12
108709: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
108710: LD_ADDR_VAR 0 6
108714: PUSH
108715: LD_VAR 0 6
108719: PPUSH
108720: LD_VAR 0 5
108724: PPUSH
108725: LD_VAR 0 7
108729: PUSH
108730: LD_INT 1
108732: ARRAY
108733: PUSH
108734: LD_VAR 0 8
108738: ARRAY
108739: PUSH
108740: LD_VAR 0 7
108744: PUSH
108745: LD_INT 2
108747: ARRAY
108748: PUSH
108749: LD_VAR 0 8
108753: ARRAY
108754: PUSH
108755: EMPTY
108756: LIST
108757: LIST
108758: PPUSH
108759: CALL_OW 1
108763: ST_TO_ADDR
// end ;
108764: GO 108685
108766: POP
108767: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
108768: LD_ADDR_EXP 191
108772: PUSH
108773: LD_EXP 191
108777: PPUSH
108778: LD_VAR 0 1
108782: PPUSH
108783: LD_VAR 0 6
108787: PPUSH
108788: CALL_OW 1
108792: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
108793: LD_ADDR_EXP 193
108797: PUSH
108798: LD_EXP 193
108802: PPUSH
108803: LD_VAR 0 1
108807: PPUSH
108808: LD_VAR 0 3
108812: PPUSH
108813: CALL_OW 1
108817: ST_TO_ADDR
// end ;
108818: LD_VAR 0 4
108822: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
108823: LD_INT 0
108825: PPUSH
// if not mc_bases [ base ] then
108826: LD_EXP 178
108830: PUSH
108831: LD_VAR 0 1
108835: ARRAY
108836: NOT
108837: IFFALSE 108841
// exit ;
108839: GO 108866
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
108841: LD_ADDR_EXP 183
108845: PUSH
108846: LD_EXP 183
108850: PPUSH
108851: LD_VAR 0 1
108855: PPUSH
108856: LD_VAR 0 2
108860: PPUSH
108861: CALL_OW 1
108865: ST_TO_ADDR
// end ;
108866: LD_VAR 0 3
108870: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
108871: LD_INT 0
108873: PPUSH
// if not mc_bases [ base ] then
108874: LD_EXP 178
108878: PUSH
108879: LD_VAR 0 1
108883: ARRAY
108884: NOT
108885: IFFALSE 108889
// exit ;
108887: GO 108926
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
108889: LD_ADDR_EXP 183
108893: PUSH
108894: LD_EXP 183
108898: PPUSH
108899: LD_VAR 0 1
108903: PPUSH
108904: LD_EXP 183
108908: PUSH
108909: LD_VAR 0 1
108913: ARRAY
108914: PUSH
108915: LD_VAR 0 2
108919: UNION
108920: PPUSH
108921: CALL_OW 1
108925: ST_TO_ADDR
// end ;
108926: LD_VAR 0 3
108930: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
108931: LD_INT 0
108933: PPUSH
// if not mc_bases [ base ] then
108934: LD_EXP 178
108938: PUSH
108939: LD_VAR 0 1
108943: ARRAY
108944: NOT
108945: IFFALSE 108949
// exit ;
108947: GO 108974
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
108949: LD_ADDR_EXP 199
108953: PUSH
108954: LD_EXP 199
108958: PPUSH
108959: LD_VAR 0 1
108963: PPUSH
108964: LD_VAR 0 2
108968: PPUSH
108969: CALL_OW 1
108973: ST_TO_ADDR
// end ;
108974: LD_VAR 0 3
108978: RET
// export function MC_InsertProduceList ( base , components ) ; begin
108979: LD_INT 0
108981: PPUSH
// if not mc_bases [ base ] then
108982: LD_EXP 178
108986: PUSH
108987: LD_VAR 0 1
108991: ARRAY
108992: NOT
108993: IFFALSE 108997
// exit ;
108995: GO 109034
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
108997: LD_ADDR_EXP 199
109001: PUSH
109002: LD_EXP 199
109006: PPUSH
109007: LD_VAR 0 1
109011: PPUSH
109012: LD_EXP 199
109016: PUSH
109017: LD_VAR 0 1
109021: ARRAY
109022: PUSH
109023: LD_VAR 0 2
109027: ADD
109028: PPUSH
109029: CALL_OW 1
109033: ST_TO_ADDR
// end ;
109034: LD_VAR 0 3
109038: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
109039: LD_INT 0
109041: PPUSH
// if not mc_bases [ base ] then
109042: LD_EXP 178
109046: PUSH
109047: LD_VAR 0 1
109051: ARRAY
109052: NOT
109053: IFFALSE 109057
// exit ;
109055: GO 109111
// mc_defender := Replace ( mc_defender , base , deflist ) ;
109057: LD_ADDR_EXP 200
109061: PUSH
109062: LD_EXP 200
109066: PPUSH
109067: LD_VAR 0 1
109071: PPUSH
109072: LD_VAR 0 2
109076: PPUSH
109077: CALL_OW 1
109081: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
109082: LD_ADDR_EXP 189
109086: PUSH
109087: LD_EXP 189
109091: PPUSH
109092: LD_VAR 0 1
109096: PPUSH
109097: LD_VAR 0 2
109101: PUSH
109102: LD_INT 0
109104: PLUS
109105: PPUSH
109106: CALL_OW 1
109110: ST_TO_ADDR
// end ;
109111: LD_VAR 0 3
109115: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
109116: LD_INT 0
109118: PPUSH
// if not mc_bases [ base ] then
109119: LD_EXP 178
109123: PUSH
109124: LD_VAR 0 1
109128: ARRAY
109129: NOT
109130: IFFALSE 109134
// exit ;
109132: GO 109159
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
109134: LD_ADDR_EXP 189
109138: PUSH
109139: LD_EXP 189
109143: PPUSH
109144: LD_VAR 0 1
109148: PPUSH
109149: LD_VAR 0 2
109153: PPUSH
109154: CALL_OW 1
109158: ST_TO_ADDR
// end ;
109159: LD_VAR 0 3
109163: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
109164: LD_INT 0
109166: PPUSH
109167: PPUSH
109168: PPUSH
109169: PPUSH
// if not mc_bases [ base ] then
109170: LD_EXP 178
109174: PUSH
109175: LD_VAR 0 1
109179: ARRAY
109180: NOT
109181: IFFALSE 109185
// exit ;
109183: GO 109250
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
109185: LD_ADDR_EXP 198
109189: PUSH
109190: LD_EXP 198
109194: PPUSH
109195: LD_VAR 0 1
109199: PUSH
109200: LD_EXP 198
109204: PUSH
109205: LD_VAR 0 1
109209: ARRAY
109210: PUSH
109211: LD_INT 1
109213: PLUS
109214: PUSH
109215: EMPTY
109216: LIST
109217: LIST
109218: PPUSH
109219: LD_VAR 0 1
109223: PUSH
109224: LD_VAR 0 2
109228: PUSH
109229: LD_VAR 0 3
109233: PUSH
109234: LD_VAR 0 4
109238: PUSH
109239: EMPTY
109240: LIST
109241: LIST
109242: LIST
109243: LIST
109244: PPUSH
109245: CALL 24210 0 3
109249: ST_TO_ADDR
// end ;
109250: LD_VAR 0 5
109254: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
109255: LD_INT 0
109257: PPUSH
// if not mc_bases [ base ] then
109258: LD_EXP 178
109262: PUSH
109263: LD_VAR 0 1
109267: ARRAY
109268: NOT
109269: IFFALSE 109273
// exit ;
109271: GO 109298
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
109273: LD_ADDR_EXP 215
109277: PUSH
109278: LD_EXP 215
109282: PPUSH
109283: LD_VAR 0 1
109287: PPUSH
109288: LD_VAR 0 2
109292: PPUSH
109293: CALL_OW 1
109297: ST_TO_ADDR
// end ;
109298: LD_VAR 0 3
109302: RET
// export function MC_GetMinesField ( base ) ; begin
109303: LD_INT 0
109305: PPUSH
// result := mc_mines [ base ] ;
109306: LD_ADDR_VAR 0 2
109310: PUSH
109311: LD_EXP 191
109315: PUSH
109316: LD_VAR 0 1
109320: ARRAY
109321: ST_TO_ADDR
// end ;
109322: LD_VAR 0 2
109326: RET
// export function MC_GetProduceList ( base ) ; begin
109327: LD_INT 0
109329: PPUSH
// result := mc_produce [ base ] ;
109330: LD_ADDR_VAR 0 2
109334: PUSH
109335: LD_EXP 199
109339: PUSH
109340: LD_VAR 0 1
109344: ARRAY
109345: ST_TO_ADDR
// end ;
109346: LD_VAR 0 2
109350: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
109351: LD_INT 0
109353: PPUSH
109354: PPUSH
// if not mc_bases then
109355: LD_EXP 178
109359: NOT
109360: IFFALSE 109364
// exit ;
109362: GO 109429
// if mc_bases [ base ] then
109364: LD_EXP 178
109368: PUSH
109369: LD_VAR 0 1
109373: ARRAY
109374: IFFALSE 109429
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
109376: LD_ADDR_VAR 0 3
109380: PUSH
109381: LD_EXP 178
109385: PUSH
109386: LD_VAR 0 1
109390: ARRAY
109391: PPUSH
109392: LD_INT 30
109394: PUSH
109395: LD_VAR 0 2
109399: PUSH
109400: EMPTY
109401: LIST
109402: LIST
109403: PPUSH
109404: CALL_OW 72
109408: ST_TO_ADDR
// if result then
109409: LD_VAR 0 3
109413: IFFALSE 109429
// result := result [ 1 ] ;
109415: LD_ADDR_VAR 0 3
109419: PUSH
109420: LD_VAR 0 3
109424: PUSH
109425: LD_INT 1
109427: ARRAY
109428: ST_TO_ADDR
// end ; end ;
109429: LD_VAR 0 3
109433: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
109434: LD_INT 0
109436: PPUSH
109437: PPUSH
// if not mc_bases then
109438: LD_EXP 178
109442: NOT
109443: IFFALSE 109447
// exit ;
109445: GO 109492
// if mc_bases [ base ] then
109447: LD_EXP 178
109451: PUSH
109452: LD_VAR 0 1
109456: ARRAY
109457: IFFALSE 109492
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
109459: LD_ADDR_VAR 0 3
109463: PUSH
109464: LD_EXP 178
109468: PUSH
109469: LD_VAR 0 1
109473: ARRAY
109474: PPUSH
109475: LD_INT 30
109477: PUSH
109478: LD_VAR 0 2
109482: PUSH
109483: EMPTY
109484: LIST
109485: LIST
109486: PPUSH
109487: CALL_OW 72
109491: ST_TO_ADDR
// end ;
109492: LD_VAR 0 3
109496: RET
// export function MC_SetTame ( base , area ) ; begin
109497: LD_INT 0
109499: PPUSH
// if not mc_bases or not base then
109500: LD_EXP 178
109504: NOT
109505: PUSH
109506: LD_VAR 0 1
109510: NOT
109511: OR
109512: IFFALSE 109516
// exit ;
109514: GO 109541
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
109516: LD_ADDR_EXP 206
109520: PUSH
109521: LD_EXP 206
109525: PPUSH
109526: LD_VAR 0 1
109530: PPUSH
109531: LD_VAR 0 2
109535: PPUSH
109536: CALL_OW 1
109540: ST_TO_ADDR
// end ;
109541: LD_VAR 0 3
109545: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
109546: LD_INT 0
109548: PPUSH
109549: PPUSH
// if not mc_bases or not base then
109550: LD_EXP 178
109554: NOT
109555: PUSH
109556: LD_VAR 0 1
109560: NOT
109561: OR
109562: IFFALSE 109566
// exit ;
109564: GO 109668
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
109566: LD_ADDR_VAR 0 4
109570: PUSH
109571: LD_EXP 178
109575: PUSH
109576: LD_VAR 0 1
109580: ARRAY
109581: PPUSH
109582: LD_INT 30
109584: PUSH
109585: LD_VAR 0 2
109589: PUSH
109590: EMPTY
109591: LIST
109592: LIST
109593: PPUSH
109594: CALL_OW 72
109598: ST_TO_ADDR
// if not tmp then
109599: LD_VAR 0 4
109603: NOT
109604: IFFALSE 109608
// exit ;
109606: GO 109668
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
109608: LD_ADDR_EXP 210
109612: PUSH
109613: LD_EXP 210
109617: PPUSH
109618: LD_VAR 0 1
109622: PPUSH
109623: LD_EXP 210
109627: PUSH
109628: LD_VAR 0 1
109632: ARRAY
109633: PPUSH
109634: LD_EXP 210
109638: PUSH
109639: LD_VAR 0 1
109643: ARRAY
109644: PUSH
109645: LD_INT 1
109647: PLUS
109648: PPUSH
109649: LD_VAR 0 4
109653: PUSH
109654: LD_INT 1
109656: ARRAY
109657: PPUSH
109658: CALL_OW 2
109662: PPUSH
109663: CALL_OW 1
109667: ST_TO_ADDR
// end ;
109668: LD_VAR 0 3
109672: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
109673: LD_INT 0
109675: PPUSH
109676: PPUSH
// if not mc_bases or not base or not kinds then
109677: LD_EXP 178
109681: NOT
109682: PUSH
109683: LD_VAR 0 1
109687: NOT
109688: OR
109689: PUSH
109690: LD_VAR 0 2
109694: NOT
109695: OR
109696: IFFALSE 109700
// exit ;
109698: GO 109761
// for i in kinds do
109700: LD_ADDR_VAR 0 4
109704: PUSH
109705: LD_VAR 0 2
109709: PUSH
109710: FOR_IN
109711: IFFALSE 109759
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
109713: LD_ADDR_EXP 212
109717: PUSH
109718: LD_EXP 212
109722: PPUSH
109723: LD_VAR 0 1
109727: PUSH
109728: LD_EXP 212
109732: PUSH
109733: LD_VAR 0 1
109737: ARRAY
109738: PUSH
109739: LD_INT 1
109741: PLUS
109742: PUSH
109743: EMPTY
109744: LIST
109745: LIST
109746: PPUSH
109747: LD_VAR 0 4
109751: PPUSH
109752: CALL 24210 0 3
109756: ST_TO_ADDR
109757: GO 109710
109759: POP
109760: POP
// end ;
109761: LD_VAR 0 3
109765: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
109766: LD_INT 0
109768: PPUSH
// if not mc_bases or not base or not areas then
109769: LD_EXP 178
109773: NOT
109774: PUSH
109775: LD_VAR 0 1
109779: NOT
109780: OR
109781: PUSH
109782: LD_VAR 0 2
109786: NOT
109787: OR
109788: IFFALSE 109792
// exit ;
109790: GO 109817
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
109792: LD_ADDR_EXP 196
109796: PUSH
109797: LD_EXP 196
109801: PPUSH
109802: LD_VAR 0 1
109806: PPUSH
109807: LD_VAR 0 2
109811: PPUSH
109812: CALL_OW 1
109816: ST_TO_ADDR
// end ;
109817: LD_VAR 0 3
109821: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
109822: LD_INT 0
109824: PPUSH
// if not mc_bases or not base or not teleports_exit then
109825: LD_EXP 178
109829: NOT
109830: PUSH
109831: LD_VAR 0 1
109835: NOT
109836: OR
109837: PUSH
109838: LD_VAR 0 2
109842: NOT
109843: OR
109844: IFFALSE 109848
// exit ;
109846: GO 109873
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
109848: LD_ADDR_EXP 213
109852: PUSH
109853: LD_EXP 213
109857: PPUSH
109858: LD_VAR 0 1
109862: PPUSH
109863: LD_VAR 0 2
109867: PPUSH
109868: CALL_OW 1
109872: ST_TO_ADDR
// end ;
109873: LD_VAR 0 3
109877: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
109878: LD_INT 0
109880: PPUSH
109881: PPUSH
109882: PPUSH
// if not mc_bases or not base or not ext_list then
109883: LD_EXP 178
109887: NOT
109888: PUSH
109889: LD_VAR 0 1
109893: NOT
109894: OR
109895: PUSH
109896: LD_VAR 0 5
109900: NOT
109901: OR
109902: IFFALSE 109906
// exit ;
109904: GO 110079
// tmp := GetFacExtXYD ( x , y , d ) ;
109906: LD_ADDR_VAR 0 8
109910: PUSH
109911: LD_VAR 0 2
109915: PPUSH
109916: LD_VAR 0 3
109920: PPUSH
109921: LD_VAR 0 4
109925: PPUSH
109926: CALL 53597 0 3
109930: ST_TO_ADDR
// if not tmp then
109931: LD_VAR 0 8
109935: NOT
109936: IFFALSE 109940
// exit ;
109938: GO 110079
// for i in tmp do
109940: LD_ADDR_VAR 0 7
109944: PUSH
109945: LD_VAR 0 8
109949: PUSH
109950: FOR_IN
109951: IFFALSE 110077
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
109953: LD_ADDR_EXP 183
109957: PUSH
109958: LD_EXP 183
109962: PPUSH
109963: LD_VAR 0 1
109967: PPUSH
109968: LD_EXP 183
109972: PUSH
109973: LD_VAR 0 1
109977: ARRAY
109978: PPUSH
109979: LD_EXP 183
109983: PUSH
109984: LD_VAR 0 1
109988: ARRAY
109989: PUSH
109990: LD_INT 1
109992: PLUS
109993: PPUSH
109994: LD_VAR 0 5
109998: PUSH
109999: LD_INT 1
110001: ARRAY
110002: PUSH
110003: LD_VAR 0 7
110007: PUSH
110008: LD_INT 1
110010: ARRAY
110011: PUSH
110012: LD_VAR 0 7
110016: PUSH
110017: LD_INT 2
110019: ARRAY
110020: PUSH
110021: LD_VAR 0 7
110025: PUSH
110026: LD_INT 3
110028: ARRAY
110029: PUSH
110030: EMPTY
110031: LIST
110032: LIST
110033: LIST
110034: LIST
110035: PPUSH
110036: CALL_OW 2
110040: PPUSH
110041: CALL_OW 1
110045: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
110046: LD_ADDR_VAR 0 5
110050: PUSH
110051: LD_VAR 0 5
110055: PPUSH
110056: LD_INT 1
110058: PPUSH
110059: CALL_OW 3
110063: ST_TO_ADDR
// if not ext_list then
110064: LD_VAR 0 5
110068: NOT
110069: IFFALSE 110075
// exit ;
110071: POP
110072: POP
110073: GO 110079
// end ;
110075: GO 109950
110077: POP
110078: POP
// end ;
110079: LD_VAR 0 6
110083: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
110084: LD_INT 0
110086: PPUSH
// if not mc_bases or not base or not weapon_list then
110087: LD_EXP 178
110091: NOT
110092: PUSH
110093: LD_VAR 0 1
110097: NOT
110098: OR
110099: PUSH
110100: LD_VAR 0 2
110104: NOT
110105: OR
110106: IFFALSE 110110
// exit ;
110108: GO 110135
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
110110: LD_ADDR_EXP 217
110114: PUSH
110115: LD_EXP 217
110119: PPUSH
110120: LD_VAR 0 1
110124: PPUSH
110125: LD_VAR 0 2
110129: PPUSH
110130: CALL_OW 1
110134: ST_TO_ADDR
// end ;
110135: LD_VAR 0 3
110139: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
110140: LD_INT 0
110142: PPUSH
// if not mc_bases or not base or not tech_list then
110143: LD_EXP 178
110147: NOT
110148: PUSH
110149: LD_VAR 0 1
110153: NOT
110154: OR
110155: PUSH
110156: LD_VAR 0 2
110160: NOT
110161: OR
110162: IFFALSE 110166
// exit ;
110164: GO 110191
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
110166: LD_ADDR_EXP 205
110170: PUSH
110171: LD_EXP 205
110175: PPUSH
110176: LD_VAR 0 1
110180: PPUSH
110181: LD_VAR 0 2
110185: PPUSH
110186: CALL_OW 1
110190: ST_TO_ADDR
// end ;
110191: LD_VAR 0 3
110195: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
110196: LD_INT 0
110198: PPUSH
// if not mc_bases or not parking_area or not base then
110199: LD_EXP 178
110203: NOT
110204: PUSH
110205: LD_VAR 0 2
110209: NOT
110210: OR
110211: PUSH
110212: LD_VAR 0 1
110216: NOT
110217: OR
110218: IFFALSE 110222
// exit ;
110220: GO 110247
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
110222: LD_ADDR_EXP 202
110226: PUSH
110227: LD_EXP 202
110231: PPUSH
110232: LD_VAR 0 1
110236: PPUSH
110237: LD_VAR 0 2
110241: PPUSH
110242: CALL_OW 1
110246: ST_TO_ADDR
// end ;
110247: LD_VAR 0 3
110251: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
110252: LD_INT 0
110254: PPUSH
// if not mc_bases or not base or not scan_area then
110255: LD_EXP 178
110259: NOT
110260: PUSH
110261: LD_VAR 0 1
110265: NOT
110266: OR
110267: PUSH
110268: LD_VAR 0 2
110272: NOT
110273: OR
110274: IFFALSE 110278
// exit ;
110276: GO 110303
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
110278: LD_ADDR_EXP 203
110282: PUSH
110283: LD_EXP 203
110287: PPUSH
110288: LD_VAR 0 1
110292: PPUSH
110293: LD_VAR 0 2
110297: PPUSH
110298: CALL_OW 1
110302: ST_TO_ADDR
// end ;
110303: LD_VAR 0 3
110307: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
110308: LD_INT 0
110310: PPUSH
110311: PPUSH
// if not mc_bases or not base then
110312: LD_EXP 178
110316: NOT
110317: PUSH
110318: LD_VAR 0 1
110322: NOT
110323: OR
110324: IFFALSE 110328
// exit ;
110326: GO 110392
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
110328: LD_ADDR_VAR 0 3
110332: PUSH
110333: LD_INT 1
110335: PUSH
110336: LD_INT 2
110338: PUSH
110339: LD_INT 3
110341: PUSH
110342: LD_INT 4
110344: PUSH
110345: LD_INT 11
110347: PUSH
110348: EMPTY
110349: LIST
110350: LIST
110351: LIST
110352: LIST
110353: LIST
110354: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
110355: LD_ADDR_EXP 205
110359: PUSH
110360: LD_EXP 205
110364: PPUSH
110365: LD_VAR 0 1
110369: PPUSH
110370: LD_EXP 205
110374: PUSH
110375: LD_VAR 0 1
110379: ARRAY
110380: PUSH
110381: LD_VAR 0 3
110385: DIFF
110386: PPUSH
110387: CALL_OW 1
110391: ST_TO_ADDR
// end ;
110392: LD_VAR 0 2
110396: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
110397: LD_INT 0
110399: PPUSH
// result := mc_vehicles [ base ] ;
110400: LD_ADDR_VAR 0 3
110404: PUSH
110405: LD_EXP 197
110409: PUSH
110410: LD_VAR 0 1
110414: ARRAY
110415: ST_TO_ADDR
// if onlyCombat then
110416: LD_VAR 0 2
110420: IFFALSE 110598
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
110422: LD_ADDR_VAR 0 3
110426: PUSH
110427: LD_VAR 0 3
110431: PUSH
110432: LD_VAR 0 3
110436: PPUSH
110437: LD_INT 2
110439: PUSH
110440: LD_INT 34
110442: PUSH
110443: LD_INT 12
110445: PUSH
110446: EMPTY
110447: LIST
110448: LIST
110449: PUSH
110450: LD_INT 34
110452: PUSH
110453: LD_INT 51
110455: PUSH
110456: EMPTY
110457: LIST
110458: LIST
110459: PUSH
110460: LD_INT 34
110462: PUSH
110463: LD_EXP 158
110467: PUSH
110468: EMPTY
110469: LIST
110470: LIST
110471: PUSH
110472: LD_INT 34
110474: PUSH
110475: LD_INT 32
110477: PUSH
110478: EMPTY
110479: LIST
110480: LIST
110481: PUSH
110482: LD_INT 34
110484: PUSH
110485: LD_INT 13
110487: PUSH
110488: EMPTY
110489: LIST
110490: LIST
110491: PUSH
110492: LD_INT 34
110494: PUSH
110495: LD_INT 52
110497: PUSH
110498: EMPTY
110499: LIST
110500: LIST
110501: PUSH
110502: LD_INT 34
110504: PUSH
110505: LD_EXP 163
110509: PUSH
110510: EMPTY
110511: LIST
110512: LIST
110513: PUSH
110514: LD_INT 34
110516: PUSH
110517: LD_INT 14
110519: PUSH
110520: EMPTY
110521: LIST
110522: LIST
110523: PUSH
110524: LD_INT 34
110526: PUSH
110527: LD_INT 53
110529: PUSH
110530: EMPTY
110531: LIST
110532: LIST
110533: PUSH
110534: LD_INT 34
110536: PUSH
110537: LD_EXP 157
110541: PUSH
110542: EMPTY
110543: LIST
110544: LIST
110545: PUSH
110546: LD_INT 34
110548: PUSH
110549: LD_INT 31
110551: PUSH
110552: EMPTY
110553: LIST
110554: LIST
110555: PUSH
110556: LD_INT 34
110558: PUSH
110559: LD_INT 48
110561: PUSH
110562: EMPTY
110563: LIST
110564: LIST
110565: PUSH
110566: LD_INT 34
110568: PUSH
110569: LD_INT 8
110571: PUSH
110572: EMPTY
110573: LIST
110574: LIST
110575: PUSH
110576: EMPTY
110577: LIST
110578: LIST
110579: LIST
110580: LIST
110581: LIST
110582: LIST
110583: LIST
110584: LIST
110585: LIST
110586: LIST
110587: LIST
110588: LIST
110589: LIST
110590: LIST
110591: PPUSH
110592: CALL_OW 72
110596: DIFF
110597: ST_TO_ADDR
// end ; end_of_file
110598: LD_VAR 0 3
110602: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
110603: LD_INT 0
110605: PPUSH
110606: PPUSH
110607: PPUSH
// if not mc_bases or not skirmish then
110608: LD_EXP 178
110612: NOT
110613: PUSH
110614: LD_EXP 176
110618: NOT
110619: OR
110620: IFFALSE 110624
// exit ;
110622: GO 110789
// for i = 1 to mc_bases do
110624: LD_ADDR_VAR 0 4
110628: PUSH
110629: DOUBLE
110630: LD_INT 1
110632: DEC
110633: ST_TO_ADDR
110634: LD_EXP 178
110638: PUSH
110639: FOR_TO
110640: IFFALSE 110787
// begin if sci in mc_bases [ i ] then
110642: LD_VAR 0 2
110646: PUSH
110647: LD_EXP 178
110651: PUSH
110652: LD_VAR 0 4
110656: ARRAY
110657: IN
110658: IFFALSE 110785
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
110660: LD_ADDR_EXP 207
110664: PUSH
110665: LD_EXP 207
110669: PPUSH
110670: LD_VAR 0 4
110674: PUSH
110675: LD_EXP 207
110679: PUSH
110680: LD_VAR 0 4
110684: ARRAY
110685: PUSH
110686: LD_INT 1
110688: PLUS
110689: PUSH
110690: EMPTY
110691: LIST
110692: LIST
110693: PPUSH
110694: LD_VAR 0 1
110698: PPUSH
110699: CALL 24210 0 3
110703: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
110704: LD_ADDR_VAR 0 5
110708: PUSH
110709: LD_EXP 178
110713: PUSH
110714: LD_VAR 0 4
110718: ARRAY
110719: PPUSH
110720: LD_INT 2
110722: PUSH
110723: LD_INT 30
110725: PUSH
110726: LD_INT 0
110728: PUSH
110729: EMPTY
110730: LIST
110731: LIST
110732: PUSH
110733: LD_INT 30
110735: PUSH
110736: LD_INT 1
110738: PUSH
110739: EMPTY
110740: LIST
110741: LIST
110742: PUSH
110743: EMPTY
110744: LIST
110745: LIST
110746: LIST
110747: PPUSH
110748: CALL_OW 72
110752: PPUSH
110753: LD_VAR 0 1
110757: PPUSH
110758: CALL_OW 74
110762: ST_TO_ADDR
// if tmp then
110763: LD_VAR 0 5
110767: IFFALSE 110783
// ComStandNearbyBuilding ( ape , tmp ) ;
110769: LD_VAR 0 1
110773: PPUSH
110774: LD_VAR 0 5
110778: PPUSH
110779: CALL 20788 0 2
// break ;
110783: GO 110787
// end ; end ;
110785: GO 110639
110787: POP
110788: POP
// end ;
110789: LD_VAR 0 3
110793: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
110794: LD_INT 0
110796: PPUSH
110797: PPUSH
110798: PPUSH
// if not mc_bases or not skirmish then
110799: LD_EXP 178
110803: NOT
110804: PUSH
110805: LD_EXP 176
110809: NOT
110810: OR
110811: IFFALSE 110815
// exit ;
110813: GO 110904
// for i = 1 to mc_bases do
110815: LD_ADDR_VAR 0 4
110819: PUSH
110820: DOUBLE
110821: LD_INT 1
110823: DEC
110824: ST_TO_ADDR
110825: LD_EXP 178
110829: PUSH
110830: FOR_TO
110831: IFFALSE 110902
// begin if building in mc_busy_turret_list [ i ] then
110833: LD_VAR 0 1
110837: PUSH
110838: LD_EXP 188
110842: PUSH
110843: LD_VAR 0 4
110847: ARRAY
110848: IN
110849: IFFALSE 110900
// begin tmp := mc_busy_turret_list [ i ] diff building ;
110851: LD_ADDR_VAR 0 5
110855: PUSH
110856: LD_EXP 188
110860: PUSH
110861: LD_VAR 0 4
110865: ARRAY
110866: PUSH
110867: LD_VAR 0 1
110871: DIFF
110872: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
110873: LD_ADDR_EXP 188
110877: PUSH
110878: LD_EXP 188
110882: PPUSH
110883: LD_VAR 0 4
110887: PPUSH
110888: LD_VAR 0 5
110892: PPUSH
110893: CALL_OW 1
110897: ST_TO_ADDR
// break ;
110898: GO 110902
// end ; end ;
110900: GO 110830
110902: POP
110903: POP
// end ;
110904: LD_VAR 0 3
110908: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
110909: LD_INT 0
110911: PPUSH
110912: PPUSH
110913: PPUSH
// if not mc_bases or not skirmish then
110914: LD_EXP 178
110918: NOT
110919: PUSH
110920: LD_EXP 176
110924: NOT
110925: OR
110926: IFFALSE 110930
// exit ;
110928: GO 111129
// for i = 1 to mc_bases do
110930: LD_ADDR_VAR 0 5
110934: PUSH
110935: DOUBLE
110936: LD_INT 1
110938: DEC
110939: ST_TO_ADDR
110940: LD_EXP 178
110944: PUSH
110945: FOR_TO
110946: IFFALSE 111127
// if building in mc_bases [ i ] then
110948: LD_VAR 0 1
110952: PUSH
110953: LD_EXP 178
110957: PUSH
110958: LD_VAR 0 5
110962: ARRAY
110963: IN
110964: IFFALSE 111125
// begin tmp := mc_bases [ i ] diff building ;
110966: LD_ADDR_VAR 0 6
110970: PUSH
110971: LD_EXP 178
110975: PUSH
110976: LD_VAR 0 5
110980: ARRAY
110981: PUSH
110982: LD_VAR 0 1
110986: DIFF
110987: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
110988: LD_ADDR_EXP 178
110992: PUSH
110993: LD_EXP 178
110997: PPUSH
110998: LD_VAR 0 5
111002: PPUSH
111003: LD_VAR 0 6
111007: PPUSH
111008: CALL_OW 1
111012: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
111013: LD_VAR 0 1
111017: PUSH
111018: LD_EXP 186
111022: PUSH
111023: LD_VAR 0 5
111027: ARRAY
111028: IN
111029: IFFALSE 111068
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
111031: LD_ADDR_EXP 186
111035: PUSH
111036: LD_EXP 186
111040: PPUSH
111041: LD_VAR 0 5
111045: PPUSH
111046: LD_EXP 186
111050: PUSH
111051: LD_VAR 0 5
111055: ARRAY
111056: PUSH
111057: LD_VAR 0 1
111061: DIFF
111062: PPUSH
111063: CALL_OW 1
111067: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
111068: LD_VAR 0 1
111072: PUSH
111073: LD_EXP 187
111077: PUSH
111078: LD_VAR 0 5
111082: ARRAY
111083: IN
111084: IFFALSE 111123
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
111086: LD_ADDR_EXP 187
111090: PUSH
111091: LD_EXP 187
111095: PPUSH
111096: LD_VAR 0 5
111100: PPUSH
111101: LD_EXP 187
111105: PUSH
111106: LD_VAR 0 5
111110: ARRAY
111111: PUSH
111112: LD_VAR 0 1
111116: DIFF
111117: PPUSH
111118: CALL_OW 1
111122: ST_TO_ADDR
// break ;
111123: GO 111127
// end ;
111125: GO 110945
111127: POP
111128: POP
// end ;
111129: LD_VAR 0 4
111133: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
111134: LD_INT 0
111136: PPUSH
111137: PPUSH
111138: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
111139: LD_EXP 178
111143: NOT
111144: PUSH
111145: LD_EXP 176
111149: NOT
111150: OR
111151: PUSH
111152: LD_VAR 0 3
111156: PUSH
111157: LD_EXP 204
111161: IN
111162: NOT
111163: OR
111164: IFFALSE 111168
// exit ;
111166: GO 111291
// for i = 1 to mc_vehicles do
111168: LD_ADDR_VAR 0 6
111172: PUSH
111173: DOUBLE
111174: LD_INT 1
111176: DEC
111177: ST_TO_ADDR
111178: LD_EXP 197
111182: PUSH
111183: FOR_TO
111184: IFFALSE 111289
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
111186: LD_VAR 0 2
111190: PUSH
111191: LD_EXP 197
111195: PUSH
111196: LD_VAR 0 6
111200: ARRAY
111201: IN
111202: PUSH
111203: LD_VAR 0 1
111207: PUSH
111208: LD_EXP 197
111212: PUSH
111213: LD_VAR 0 6
111217: ARRAY
111218: IN
111219: OR
111220: IFFALSE 111287
// begin tmp := mc_vehicles [ i ] diff old ;
111222: LD_ADDR_VAR 0 7
111226: PUSH
111227: LD_EXP 197
111231: PUSH
111232: LD_VAR 0 6
111236: ARRAY
111237: PUSH
111238: LD_VAR 0 2
111242: DIFF
111243: ST_TO_ADDR
// tmp := tmp diff new ;
111244: LD_ADDR_VAR 0 7
111248: PUSH
111249: LD_VAR 0 7
111253: PUSH
111254: LD_VAR 0 1
111258: DIFF
111259: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
111260: LD_ADDR_EXP 197
111264: PUSH
111265: LD_EXP 197
111269: PPUSH
111270: LD_VAR 0 6
111274: PPUSH
111275: LD_VAR 0 7
111279: PPUSH
111280: CALL_OW 1
111284: ST_TO_ADDR
// break ;
111285: GO 111289
// end ;
111287: GO 111183
111289: POP
111290: POP
// end ;
111291: LD_VAR 0 5
111295: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
111296: LD_INT 0
111298: PPUSH
111299: PPUSH
111300: PPUSH
111301: PPUSH
// if not mc_bases or not skirmish then
111302: LD_EXP 178
111306: NOT
111307: PUSH
111308: LD_EXP 176
111312: NOT
111313: OR
111314: IFFALSE 111318
// exit ;
111316: GO 111710
// side := GetSide ( vehicle ) ;
111318: LD_ADDR_VAR 0 5
111322: PUSH
111323: LD_VAR 0 1
111327: PPUSH
111328: CALL_OW 255
111332: ST_TO_ADDR
// for i = 1 to mc_bases do
111333: LD_ADDR_VAR 0 4
111337: PUSH
111338: DOUBLE
111339: LD_INT 1
111341: DEC
111342: ST_TO_ADDR
111343: LD_EXP 178
111347: PUSH
111348: FOR_TO
111349: IFFALSE 111708
// begin if factory in mc_bases [ i ] then
111351: LD_VAR 0 2
111355: PUSH
111356: LD_EXP 178
111360: PUSH
111361: LD_VAR 0 4
111365: ARRAY
111366: IN
111367: IFFALSE 111706
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
111369: LD_EXP 200
111373: PUSH
111374: LD_VAR 0 4
111378: ARRAY
111379: PUSH
111380: LD_EXP 189
111384: PUSH
111385: LD_VAR 0 4
111389: ARRAY
111390: LESS
111391: PUSH
111392: LD_VAR 0 1
111396: PPUSH
111397: CALL_OW 264
111401: PUSH
111402: LD_INT 31
111404: PUSH
111405: LD_INT 32
111407: PUSH
111408: LD_INT 51
111410: PUSH
111411: LD_EXP 158
111415: PUSH
111416: LD_INT 12
111418: PUSH
111419: LD_INT 30
111421: PUSH
111422: LD_EXP 157
111426: PUSH
111427: LD_INT 11
111429: PUSH
111430: LD_INT 53
111432: PUSH
111433: LD_INT 14
111435: PUSH
111436: LD_EXP 161
111440: PUSH
111441: LD_INT 29
111443: PUSH
111444: LD_EXP 159
111448: PUSH
111449: LD_INT 13
111451: PUSH
111452: LD_INT 52
111454: PUSH
111455: LD_EXP 163
111459: PUSH
111460: LD_INT 48
111462: PUSH
111463: LD_INT 8
111465: PUSH
111466: EMPTY
111467: LIST
111468: LIST
111469: LIST
111470: LIST
111471: LIST
111472: LIST
111473: LIST
111474: LIST
111475: LIST
111476: LIST
111477: LIST
111478: LIST
111479: LIST
111480: LIST
111481: LIST
111482: LIST
111483: LIST
111484: LIST
111485: IN
111486: NOT
111487: AND
111488: IFFALSE 111536
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
111490: LD_ADDR_EXP 200
111494: PUSH
111495: LD_EXP 200
111499: PPUSH
111500: LD_VAR 0 4
111504: PUSH
111505: LD_EXP 200
111509: PUSH
111510: LD_VAR 0 4
111514: ARRAY
111515: PUSH
111516: LD_INT 1
111518: PLUS
111519: PUSH
111520: EMPTY
111521: LIST
111522: LIST
111523: PPUSH
111524: LD_VAR 0 1
111528: PPUSH
111529: CALL 24210 0 3
111533: ST_TO_ADDR
111534: GO 111580
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
111536: LD_ADDR_EXP 197
111540: PUSH
111541: LD_EXP 197
111545: PPUSH
111546: LD_VAR 0 4
111550: PUSH
111551: LD_EXP 197
111555: PUSH
111556: LD_VAR 0 4
111560: ARRAY
111561: PUSH
111562: LD_INT 1
111564: PLUS
111565: PUSH
111566: EMPTY
111567: LIST
111568: LIST
111569: PPUSH
111570: LD_VAR 0 1
111574: PPUSH
111575: CALL 24210 0 3
111579: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
111580: LD_VAR 0 1
111584: PPUSH
111585: CALL_OW 263
111589: PUSH
111590: LD_INT 2
111592: EQUAL
111593: IFFALSE 111622
// begin repeat wait ( 0 0$3 ) ;
111595: LD_INT 105
111597: PPUSH
111598: CALL_OW 67
// Connect ( vehicle ) ;
111602: LD_VAR 0 1
111606: PPUSH
111607: CALL 27181 0 1
// until IsControledBy ( vehicle ) ;
111611: LD_VAR 0 1
111615: PPUSH
111616: CALL_OW 312
111620: IFFALSE 111595
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
111622: LD_VAR 0 1
111626: PPUSH
111627: LD_EXP 202
111631: PUSH
111632: LD_VAR 0 4
111636: ARRAY
111637: PPUSH
111638: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
111642: LD_VAR 0 1
111646: PPUSH
111647: CALL_OW 263
111651: PUSH
111652: LD_INT 1
111654: NONEQUAL
111655: IFFALSE 111659
// break ;
111657: GO 111708
// repeat wait ( 0 0$1 ) ;
111659: LD_INT 35
111661: PPUSH
111662: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
111666: LD_VAR 0 1
111670: PPUSH
111671: LD_EXP 202
111675: PUSH
111676: LD_VAR 0 4
111680: ARRAY
111681: PPUSH
111682: CALL_OW 308
111686: IFFALSE 111659
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
111688: LD_VAR 0 1
111692: PPUSH
111693: CALL_OW 311
111697: PPUSH
111698: CALL_OW 121
// exit ;
111702: POP
111703: POP
111704: GO 111710
// end ; end ;
111706: GO 111348
111708: POP
111709: POP
// end ;
111710: LD_VAR 0 3
111714: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
111715: LD_INT 0
111717: PPUSH
111718: PPUSH
111719: PPUSH
111720: PPUSH
// if not mc_bases or not skirmish then
111721: LD_EXP 178
111725: NOT
111726: PUSH
111727: LD_EXP 176
111731: NOT
111732: OR
111733: IFFALSE 111737
// exit ;
111735: GO 112090
// repeat wait ( 0 0$1 ) ;
111737: LD_INT 35
111739: PPUSH
111740: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
111744: LD_VAR 0 2
111748: PPUSH
111749: LD_VAR 0 3
111753: PPUSH
111754: CALL_OW 284
111758: IFFALSE 111737
// if GetResourceTypeXY ( x , y ) = mat_artefact then
111760: LD_VAR 0 2
111764: PPUSH
111765: LD_VAR 0 3
111769: PPUSH
111770: CALL_OW 283
111774: PUSH
111775: LD_INT 4
111777: EQUAL
111778: IFFALSE 111782
// exit ;
111780: GO 112090
// for i = 1 to mc_bases do
111782: LD_ADDR_VAR 0 7
111786: PUSH
111787: DOUBLE
111788: LD_INT 1
111790: DEC
111791: ST_TO_ADDR
111792: LD_EXP 178
111796: PUSH
111797: FOR_TO
111798: IFFALSE 112088
// begin if mc_crates_area [ i ] then
111800: LD_EXP 196
111804: PUSH
111805: LD_VAR 0 7
111809: ARRAY
111810: IFFALSE 111921
// for j in mc_crates_area [ i ] do
111812: LD_ADDR_VAR 0 8
111816: PUSH
111817: LD_EXP 196
111821: PUSH
111822: LD_VAR 0 7
111826: ARRAY
111827: PUSH
111828: FOR_IN
111829: IFFALSE 111919
// if InArea ( x , y , j ) then
111831: LD_VAR 0 2
111835: PPUSH
111836: LD_VAR 0 3
111840: PPUSH
111841: LD_VAR 0 8
111845: PPUSH
111846: CALL_OW 309
111850: IFFALSE 111917
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
111852: LD_ADDR_EXP 194
111856: PUSH
111857: LD_EXP 194
111861: PPUSH
111862: LD_VAR 0 7
111866: PUSH
111867: LD_EXP 194
111871: PUSH
111872: LD_VAR 0 7
111876: ARRAY
111877: PUSH
111878: LD_INT 1
111880: PLUS
111881: PUSH
111882: EMPTY
111883: LIST
111884: LIST
111885: PPUSH
111886: LD_VAR 0 4
111890: PUSH
111891: LD_VAR 0 2
111895: PUSH
111896: LD_VAR 0 3
111900: PUSH
111901: EMPTY
111902: LIST
111903: LIST
111904: LIST
111905: PPUSH
111906: CALL 24210 0 3
111910: ST_TO_ADDR
// exit ;
111911: POP
111912: POP
111913: POP
111914: POP
111915: GO 112090
// end ;
111917: GO 111828
111919: POP
111920: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
111921: LD_ADDR_VAR 0 9
111925: PUSH
111926: LD_EXP 178
111930: PUSH
111931: LD_VAR 0 7
111935: ARRAY
111936: PPUSH
111937: LD_INT 2
111939: PUSH
111940: LD_INT 30
111942: PUSH
111943: LD_INT 0
111945: PUSH
111946: EMPTY
111947: LIST
111948: LIST
111949: PUSH
111950: LD_INT 30
111952: PUSH
111953: LD_INT 1
111955: PUSH
111956: EMPTY
111957: LIST
111958: LIST
111959: PUSH
111960: EMPTY
111961: LIST
111962: LIST
111963: LIST
111964: PPUSH
111965: CALL_OW 72
111969: ST_TO_ADDR
// if not depot then
111970: LD_VAR 0 9
111974: NOT
111975: IFFALSE 111979
// continue ;
111977: GO 111797
// for j in depot do
111979: LD_ADDR_VAR 0 8
111983: PUSH
111984: LD_VAR 0 9
111988: PUSH
111989: FOR_IN
111990: IFFALSE 112084
// if GetDistUnitXY ( j , x , y ) < 30 then
111992: LD_VAR 0 8
111996: PPUSH
111997: LD_VAR 0 2
112001: PPUSH
112002: LD_VAR 0 3
112006: PPUSH
112007: CALL_OW 297
112011: PUSH
112012: LD_INT 30
112014: LESS
112015: IFFALSE 112082
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
112017: LD_ADDR_EXP 194
112021: PUSH
112022: LD_EXP 194
112026: PPUSH
112027: LD_VAR 0 7
112031: PUSH
112032: LD_EXP 194
112036: PUSH
112037: LD_VAR 0 7
112041: ARRAY
112042: PUSH
112043: LD_INT 1
112045: PLUS
112046: PUSH
112047: EMPTY
112048: LIST
112049: LIST
112050: PPUSH
112051: LD_VAR 0 4
112055: PUSH
112056: LD_VAR 0 2
112060: PUSH
112061: LD_VAR 0 3
112065: PUSH
112066: EMPTY
112067: LIST
112068: LIST
112069: LIST
112070: PPUSH
112071: CALL 24210 0 3
112075: ST_TO_ADDR
// exit ;
112076: POP
112077: POP
112078: POP
112079: POP
112080: GO 112090
// end ;
112082: GO 111989
112084: POP
112085: POP
// end ;
112086: GO 111797
112088: POP
112089: POP
// end ;
112090: LD_VAR 0 6
112094: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
112095: LD_INT 0
112097: PPUSH
112098: PPUSH
112099: PPUSH
112100: PPUSH
// if not mc_bases or not skirmish then
112101: LD_EXP 178
112105: NOT
112106: PUSH
112107: LD_EXP 176
112111: NOT
112112: OR
112113: IFFALSE 112117
// exit ;
112115: GO 112394
// side := GetSide ( lab ) ;
112117: LD_ADDR_VAR 0 4
112121: PUSH
112122: LD_VAR 0 2
112126: PPUSH
112127: CALL_OW 255
112131: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
112132: LD_VAR 0 4
112136: PUSH
112137: LD_EXP 204
112141: IN
112142: NOT
112143: PUSH
112144: LD_EXP 205
112148: NOT
112149: OR
112150: PUSH
112151: LD_EXP 178
112155: NOT
112156: OR
112157: IFFALSE 112161
// exit ;
112159: GO 112394
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
112161: LD_ADDR_EXP 205
112165: PUSH
112166: LD_EXP 205
112170: PPUSH
112171: LD_VAR 0 4
112175: PPUSH
112176: LD_EXP 205
112180: PUSH
112181: LD_VAR 0 4
112185: ARRAY
112186: PUSH
112187: LD_VAR 0 1
112191: DIFF
112192: PPUSH
112193: CALL_OW 1
112197: ST_TO_ADDR
// for i = 1 to mc_bases do
112198: LD_ADDR_VAR 0 5
112202: PUSH
112203: DOUBLE
112204: LD_INT 1
112206: DEC
112207: ST_TO_ADDR
112208: LD_EXP 178
112212: PUSH
112213: FOR_TO
112214: IFFALSE 112392
// begin if lab in mc_bases [ i ] then
112216: LD_VAR 0 2
112220: PUSH
112221: LD_EXP 178
112225: PUSH
112226: LD_VAR 0 5
112230: ARRAY
112231: IN
112232: IFFALSE 112390
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
112234: LD_VAR 0 1
112238: PUSH
112239: LD_INT 11
112241: PUSH
112242: LD_INT 4
112244: PUSH
112245: LD_INT 3
112247: PUSH
112248: LD_INT 2
112250: PUSH
112251: EMPTY
112252: LIST
112253: LIST
112254: LIST
112255: LIST
112256: IN
112257: PUSH
112258: LD_EXP 208
112262: PUSH
112263: LD_VAR 0 5
112267: ARRAY
112268: AND
112269: IFFALSE 112390
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
112271: LD_ADDR_VAR 0 6
112275: PUSH
112276: LD_EXP 208
112280: PUSH
112281: LD_VAR 0 5
112285: ARRAY
112286: PUSH
112287: LD_INT 1
112289: ARRAY
112290: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
112291: LD_ADDR_EXP 208
112295: PUSH
112296: LD_EXP 208
112300: PPUSH
112301: LD_VAR 0 5
112305: PPUSH
112306: EMPTY
112307: PPUSH
112308: CALL_OW 1
112312: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
112313: LD_VAR 0 6
112317: PPUSH
112318: LD_INT 0
112320: PPUSH
112321: CALL_OW 109
// ComExitBuilding ( tmp ) ;
112325: LD_VAR 0 6
112329: PPUSH
112330: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
112334: LD_ADDR_EXP 207
112338: PUSH
112339: LD_EXP 207
112343: PPUSH
112344: LD_VAR 0 5
112348: PPUSH
112349: LD_EXP 207
112353: PUSH
112354: LD_VAR 0 5
112358: ARRAY
112359: PPUSH
112360: LD_INT 1
112362: PPUSH
112363: LD_VAR 0 6
112367: PPUSH
112368: CALL_OW 2
112372: PPUSH
112373: CALL_OW 1
112377: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
112378: LD_VAR 0 5
112382: PPUSH
112383: LD_INT 112
112385: PPUSH
112386: CALL 88913 0 2
// end ; end ; end ;
112390: GO 112213
112392: POP
112393: POP
// end ;
112394: LD_VAR 0 3
112398: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
112399: LD_INT 0
112401: PPUSH
112402: PPUSH
112403: PPUSH
112404: PPUSH
112405: PPUSH
112406: PPUSH
112407: PPUSH
112408: PPUSH
// if not mc_bases or not skirmish then
112409: LD_EXP 178
112413: NOT
112414: PUSH
112415: LD_EXP 176
112419: NOT
112420: OR
112421: IFFALSE 112425
// exit ;
112423: GO 113796
// for i = 1 to mc_bases do
112425: LD_ADDR_VAR 0 3
112429: PUSH
112430: DOUBLE
112431: LD_INT 1
112433: DEC
112434: ST_TO_ADDR
112435: LD_EXP 178
112439: PUSH
112440: FOR_TO
112441: IFFALSE 113794
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
112443: LD_VAR 0 1
112447: PUSH
112448: LD_EXP 178
112452: PUSH
112453: LD_VAR 0 3
112457: ARRAY
112458: IN
112459: PUSH
112460: LD_VAR 0 1
112464: PUSH
112465: LD_EXP 185
112469: PUSH
112470: LD_VAR 0 3
112474: ARRAY
112475: IN
112476: OR
112477: PUSH
112478: LD_VAR 0 1
112482: PUSH
112483: LD_EXP 200
112487: PUSH
112488: LD_VAR 0 3
112492: ARRAY
112493: IN
112494: OR
112495: PUSH
112496: LD_VAR 0 1
112500: PUSH
112501: LD_EXP 197
112505: PUSH
112506: LD_VAR 0 3
112510: ARRAY
112511: IN
112512: OR
112513: PUSH
112514: LD_VAR 0 1
112518: PUSH
112519: LD_EXP 207
112523: PUSH
112524: LD_VAR 0 3
112528: ARRAY
112529: IN
112530: OR
112531: PUSH
112532: LD_VAR 0 1
112536: PUSH
112537: LD_EXP 208
112541: PUSH
112542: LD_VAR 0 3
112546: ARRAY
112547: IN
112548: OR
112549: IFFALSE 113792
// begin if un in mc_ape [ i ] then
112551: LD_VAR 0 1
112555: PUSH
112556: LD_EXP 207
112560: PUSH
112561: LD_VAR 0 3
112565: ARRAY
112566: IN
112567: IFFALSE 112606
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
112569: LD_ADDR_EXP 207
112573: PUSH
112574: LD_EXP 207
112578: PPUSH
112579: LD_VAR 0 3
112583: PPUSH
112584: LD_EXP 207
112588: PUSH
112589: LD_VAR 0 3
112593: ARRAY
112594: PUSH
112595: LD_VAR 0 1
112599: DIFF
112600: PPUSH
112601: CALL_OW 1
112605: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
112606: LD_VAR 0 1
112610: PUSH
112611: LD_EXP 208
112615: PUSH
112616: LD_VAR 0 3
112620: ARRAY
112621: IN
112622: IFFALSE 112646
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
112624: LD_ADDR_EXP 208
112628: PUSH
112629: LD_EXP 208
112633: PPUSH
112634: LD_VAR 0 3
112638: PPUSH
112639: EMPTY
112640: PPUSH
112641: CALL_OW 1
112645: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
112646: LD_VAR 0 1
112650: PPUSH
112651: CALL_OW 247
112655: PUSH
112656: LD_INT 2
112658: EQUAL
112659: PUSH
112660: LD_VAR 0 1
112664: PPUSH
112665: CALL_OW 110
112669: PUSH
112670: LD_INT 20
112672: EQUAL
112673: PUSH
112674: LD_VAR 0 1
112678: PUSH
112679: LD_EXP 200
112683: PUSH
112684: LD_VAR 0 3
112688: ARRAY
112689: IN
112690: OR
112691: PUSH
112692: LD_VAR 0 1
112696: PPUSH
112697: CALL_OW 264
112701: PUSH
112702: LD_INT 12
112704: PUSH
112705: LD_INT 51
112707: PUSH
112708: LD_EXP 158
112712: PUSH
112713: LD_INT 32
112715: PUSH
112716: LD_INT 13
112718: PUSH
112719: LD_INT 52
112721: PUSH
112722: LD_INT 31
112724: PUSH
112725: EMPTY
112726: LIST
112727: LIST
112728: LIST
112729: LIST
112730: LIST
112731: LIST
112732: LIST
112733: IN
112734: OR
112735: AND
112736: IFFALSE 113044
// begin if un in mc_defender [ i ] then
112738: LD_VAR 0 1
112742: PUSH
112743: LD_EXP 200
112747: PUSH
112748: LD_VAR 0 3
112752: ARRAY
112753: IN
112754: IFFALSE 112793
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
112756: LD_ADDR_EXP 200
112760: PUSH
112761: LD_EXP 200
112765: PPUSH
112766: LD_VAR 0 3
112770: PPUSH
112771: LD_EXP 200
112775: PUSH
112776: LD_VAR 0 3
112780: ARRAY
112781: PUSH
112782: LD_VAR 0 1
112786: DIFF
112787: PPUSH
112788: CALL_OW 1
112792: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
112793: LD_ADDR_VAR 0 8
112797: PUSH
112798: LD_VAR 0 3
112802: PPUSH
112803: LD_INT 3
112805: PPUSH
112806: CALL 109434 0 2
112810: ST_TO_ADDR
// if fac then
112811: LD_VAR 0 8
112815: IFFALSE 113044
// begin for j in fac do
112817: LD_ADDR_VAR 0 4
112821: PUSH
112822: LD_VAR 0 8
112826: PUSH
112827: FOR_IN
112828: IFFALSE 113042
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
112830: LD_ADDR_VAR 0 9
112834: PUSH
112835: LD_VAR 0 8
112839: PPUSH
112840: LD_VAR 0 1
112844: PPUSH
112845: CALL_OW 265
112849: PPUSH
112850: LD_VAR 0 1
112854: PPUSH
112855: CALL_OW 262
112859: PPUSH
112860: LD_VAR 0 1
112864: PPUSH
112865: CALL_OW 263
112869: PPUSH
112870: LD_VAR 0 1
112874: PPUSH
112875: CALL_OW 264
112879: PPUSH
112880: CALL 21706 0 5
112884: ST_TO_ADDR
// if components then
112885: LD_VAR 0 9
112889: IFFALSE 113040
// begin if GetWeapon ( un ) = ar_control_tower then
112891: LD_VAR 0 1
112895: PPUSH
112896: CALL_OW 264
112900: PUSH
112901: LD_INT 31
112903: EQUAL
112904: IFFALSE 113021
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
112906: LD_VAR 0 1
112910: PPUSH
112911: CALL_OW 311
112915: PPUSH
112916: LD_INT 0
112918: PPUSH
112919: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
112923: LD_ADDR_EXP 218
112927: PUSH
112928: LD_EXP 218
112932: PPUSH
112933: LD_VAR 0 3
112937: PPUSH
112938: LD_EXP 218
112942: PUSH
112943: LD_VAR 0 3
112947: ARRAY
112948: PUSH
112949: LD_VAR 0 1
112953: PPUSH
112954: CALL_OW 311
112958: DIFF
112959: PPUSH
112960: CALL_OW 1
112964: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
112965: LD_ADDR_VAR 0 7
112969: PUSH
112970: LD_EXP 199
112974: PUSH
112975: LD_VAR 0 3
112979: ARRAY
112980: PPUSH
112981: LD_INT 1
112983: PPUSH
112984: LD_VAR 0 9
112988: PPUSH
112989: CALL_OW 2
112993: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
112994: LD_ADDR_EXP 199
112998: PUSH
112999: LD_EXP 199
113003: PPUSH
113004: LD_VAR 0 3
113008: PPUSH
113009: LD_VAR 0 7
113013: PPUSH
113014: CALL_OW 1
113018: ST_TO_ADDR
// end else
113019: GO 113038
// MC_InsertProduceList ( i , [ components ] ) ;
113021: LD_VAR 0 3
113025: PPUSH
113026: LD_VAR 0 9
113030: PUSH
113031: EMPTY
113032: LIST
113033: PPUSH
113034: CALL 108979 0 2
// break ;
113038: GO 113042
// end ; end ;
113040: GO 112827
113042: POP
113043: POP
// end ; end ; if GetType ( un ) = unit_building then
113044: LD_VAR 0 1
113048: PPUSH
113049: CALL_OW 247
113053: PUSH
113054: LD_INT 3
113056: EQUAL
113057: IFFALSE 113460
// begin btype := GetBType ( un ) ;
113059: LD_ADDR_VAR 0 5
113063: PUSH
113064: LD_VAR 0 1
113068: PPUSH
113069: CALL_OW 266
113073: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
113074: LD_VAR 0 5
113078: PUSH
113079: LD_INT 29
113081: PUSH
113082: LD_INT 30
113084: PUSH
113085: EMPTY
113086: LIST
113087: LIST
113088: IN
113089: IFFALSE 113162
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
113091: LD_VAR 0 1
113095: PPUSH
113096: CALL_OW 250
113100: PPUSH
113101: LD_VAR 0 1
113105: PPUSH
113106: CALL_OW 251
113110: PPUSH
113111: LD_VAR 0 1
113115: PPUSH
113116: CALL_OW 255
113120: PPUSH
113121: CALL_OW 440
113125: NOT
113126: IFFALSE 113162
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
113128: LD_VAR 0 1
113132: PPUSH
113133: CALL_OW 250
113137: PPUSH
113138: LD_VAR 0 1
113142: PPUSH
113143: CALL_OW 251
113147: PPUSH
113148: LD_VAR 0 1
113152: PPUSH
113153: CALL_OW 255
113157: PPUSH
113158: CALL_OW 441
// end ; if btype = b_warehouse then
113162: LD_VAR 0 5
113166: PUSH
113167: LD_INT 1
113169: EQUAL
113170: IFFALSE 113188
// begin btype := b_depot ;
113172: LD_ADDR_VAR 0 5
113176: PUSH
113177: LD_INT 0
113179: ST_TO_ADDR
// pos := 1 ;
113180: LD_ADDR_VAR 0 6
113184: PUSH
113185: LD_INT 1
113187: ST_TO_ADDR
// end ; if btype = b_factory then
113188: LD_VAR 0 5
113192: PUSH
113193: LD_INT 3
113195: EQUAL
113196: IFFALSE 113214
// begin btype := b_workshop ;
113198: LD_ADDR_VAR 0 5
113202: PUSH
113203: LD_INT 2
113205: ST_TO_ADDR
// pos := 1 ;
113206: LD_ADDR_VAR 0 6
113210: PUSH
113211: LD_INT 1
113213: ST_TO_ADDR
// end ; if btype = b_barracks then
113214: LD_VAR 0 5
113218: PUSH
113219: LD_INT 5
113221: EQUAL
113222: IFFALSE 113232
// btype := b_armoury ;
113224: LD_ADDR_VAR 0 5
113228: PUSH
113229: LD_INT 4
113231: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
113232: LD_VAR 0 5
113236: PUSH
113237: LD_INT 7
113239: PUSH
113240: LD_INT 8
113242: PUSH
113243: EMPTY
113244: LIST
113245: LIST
113246: IN
113247: IFFALSE 113257
// btype := b_lab ;
113249: LD_ADDR_VAR 0 5
113253: PUSH
113254: LD_INT 6
113256: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
113257: LD_ADDR_EXP 183
113261: PUSH
113262: LD_EXP 183
113266: PPUSH
113267: LD_VAR 0 3
113271: PUSH
113272: LD_EXP 183
113276: PUSH
113277: LD_VAR 0 3
113281: ARRAY
113282: PUSH
113283: LD_INT 1
113285: PLUS
113286: PUSH
113287: EMPTY
113288: LIST
113289: LIST
113290: PPUSH
113291: LD_VAR 0 5
113295: PUSH
113296: LD_VAR 0 1
113300: PPUSH
113301: CALL_OW 250
113305: PUSH
113306: LD_VAR 0 1
113310: PPUSH
113311: CALL_OW 251
113315: PUSH
113316: LD_VAR 0 1
113320: PPUSH
113321: CALL_OW 254
113325: PUSH
113326: EMPTY
113327: LIST
113328: LIST
113329: LIST
113330: LIST
113331: PPUSH
113332: CALL 24210 0 3
113336: ST_TO_ADDR
// if pos = 1 then
113337: LD_VAR 0 6
113341: PUSH
113342: LD_INT 1
113344: EQUAL
113345: IFFALSE 113460
// begin tmp := mc_build_list [ i ] ;
113347: LD_ADDR_VAR 0 7
113351: PUSH
113352: LD_EXP 183
113356: PUSH
113357: LD_VAR 0 3
113361: ARRAY
113362: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
113363: LD_VAR 0 7
113367: PPUSH
113368: LD_INT 2
113370: PUSH
113371: LD_INT 30
113373: PUSH
113374: LD_INT 0
113376: PUSH
113377: EMPTY
113378: LIST
113379: LIST
113380: PUSH
113381: LD_INT 30
113383: PUSH
113384: LD_INT 1
113386: PUSH
113387: EMPTY
113388: LIST
113389: LIST
113390: PUSH
113391: EMPTY
113392: LIST
113393: LIST
113394: LIST
113395: PPUSH
113396: CALL_OW 72
113400: IFFALSE 113410
// pos := 2 ;
113402: LD_ADDR_VAR 0 6
113406: PUSH
113407: LD_INT 2
113409: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
113410: LD_ADDR_VAR 0 7
113414: PUSH
113415: LD_VAR 0 7
113419: PPUSH
113420: LD_VAR 0 6
113424: PPUSH
113425: LD_VAR 0 7
113429: PPUSH
113430: CALL 24536 0 3
113434: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
113435: LD_ADDR_EXP 183
113439: PUSH
113440: LD_EXP 183
113444: PPUSH
113445: LD_VAR 0 3
113449: PPUSH
113450: LD_VAR 0 7
113454: PPUSH
113455: CALL_OW 1
113459: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
113460: LD_VAR 0 1
113464: PUSH
113465: LD_EXP 178
113469: PUSH
113470: LD_VAR 0 3
113474: ARRAY
113475: IN
113476: IFFALSE 113515
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
113478: LD_ADDR_EXP 178
113482: PUSH
113483: LD_EXP 178
113487: PPUSH
113488: LD_VAR 0 3
113492: PPUSH
113493: LD_EXP 178
113497: PUSH
113498: LD_VAR 0 3
113502: ARRAY
113503: PUSH
113504: LD_VAR 0 1
113508: DIFF
113509: PPUSH
113510: CALL_OW 1
113514: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
113515: LD_VAR 0 1
113519: PUSH
113520: LD_EXP 185
113524: PUSH
113525: LD_VAR 0 3
113529: ARRAY
113530: IN
113531: IFFALSE 113570
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
113533: LD_ADDR_EXP 185
113537: PUSH
113538: LD_EXP 185
113542: PPUSH
113543: LD_VAR 0 3
113547: PPUSH
113548: LD_EXP 185
113552: PUSH
113553: LD_VAR 0 3
113557: ARRAY
113558: PUSH
113559: LD_VAR 0 1
113563: DIFF
113564: PPUSH
113565: CALL_OW 1
113569: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
113570: LD_VAR 0 1
113574: PUSH
113575: LD_EXP 197
113579: PUSH
113580: LD_VAR 0 3
113584: ARRAY
113585: IN
113586: IFFALSE 113625
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
113588: LD_ADDR_EXP 197
113592: PUSH
113593: LD_EXP 197
113597: PPUSH
113598: LD_VAR 0 3
113602: PPUSH
113603: LD_EXP 197
113607: PUSH
113608: LD_VAR 0 3
113612: ARRAY
113613: PUSH
113614: LD_VAR 0 1
113618: DIFF
113619: PPUSH
113620: CALL_OW 1
113624: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
113625: LD_VAR 0 1
113629: PUSH
113630: LD_EXP 200
113634: PUSH
113635: LD_VAR 0 3
113639: ARRAY
113640: IN
113641: IFFALSE 113680
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
113643: LD_ADDR_EXP 200
113647: PUSH
113648: LD_EXP 200
113652: PPUSH
113653: LD_VAR 0 3
113657: PPUSH
113658: LD_EXP 200
113662: PUSH
113663: LD_VAR 0 3
113667: ARRAY
113668: PUSH
113669: LD_VAR 0 1
113673: DIFF
113674: PPUSH
113675: CALL_OW 1
113679: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
113680: LD_VAR 0 1
113684: PUSH
113685: LD_EXP 187
113689: PUSH
113690: LD_VAR 0 3
113694: ARRAY
113695: IN
113696: IFFALSE 113735
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
113698: LD_ADDR_EXP 187
113702: PUSH
113703: LD_EXP 187
113707: PPUSH
113708: LD_VAR 0 3
113712: PPUSH
113713: LD_EXP 187
113717: PUSH
113718: LD_VAR 0 3
113722: ARRAY
113723: PUSH
113724: LD_VAR 0 1
113728: DIFF
113729: PPUSH
113730: CALL_OW 1
113734: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
113735: LD_VAR 0 1
113739: PUSH
113740: LD_EXP 186
113744: PUSH
113745: LD_VAR 0 3
113749: ARRAY
113750: IN
113751: IFFALSE 113790
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
113753: LD_ADDR_EXP 186
113757: PUSH
113758: LD_EXP 186
113762: PPUSH
113763: LD_VAR 0 3
113767: PPUSH
113768: LD_EXP 186
113772: PUSH
113773: LD_VAR 0 3
113777: ARRAY
113778: PUSH
113779: LD_VAR 0 1
113783: DIFF
113784: PPUSH
113785: CALL_OW 1
113789: ST_TO_ADDR
// end ; break ;
113790: GO 113794
// end ;
113792: GO 112440
113794: POP
113795: POP
// end ;
113796: LD_VAR 0 2
113800: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
113801: LD_INT 0
113803: PPUSH
113804: PPUSH
113805: PPUSH
// if not mc_bases or not skirmish then
113806: LD_EXP 178
113810: NOT
113811: PUSH
113812: LD_EXP 176
113816: NOT
113817: OR
113818: IFFALSE 113822
// exit ;
113820: GO 114037
// for i = 1 to mc_bases do
113822: LD_ADDR_VAR 0 3
113826: PUSH
113827: DOUBLE
113828: LD_INT 1
113830: DEC
113831: ST_TO_ADDR
113832: LD_EXP 178
113836: PUSH
113837: FOR_TO
113838: IFFALSE 114035
// begin if building in mc_construct_list [ i ] then
113840: LD_VAR 0 1
113844: PUSH
113845: LD_EXP 185
113849: PUSH
113850: LD_VAR 0 3
113854: ARRAY
113855: IN
113856: IFFALSE 114033
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
113858: LD_ADDR_EXP 185
113862: PUSH
113863: LD_EXP 185
113867: PPUSH
113868: LD_VAR 0 3
113872: PPUSH
113873: LD_EXP 185
113877: PUSH
113878: LD_VAR 0 3
113882: ARRAY
113883: PUSH
113884: LD_VAR 0 1
113888: DIFF
113889: PPUSH
113890: CALL_OW 1
113894: ST_TO_ADDR
// if building in mc_lab [ i ] then
113895: LD_VAR 0 1
113899: PUSH
113900: LD_EXP 211
113904: PUSH
113905: LD_VAR 0 3
113909: ARRAY
113910: IN
113911: IFFALSE 113966
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
113913: LD_ADDR_EXP 212
113917: PUSH
113918: LD_EXP 212
113922: PPUSH
113923: LD_VAR 0 3
113927: PPUSH
113928: LD_EXP 212
113932: PUSH
113933: LD_VAR 0 3
113937: ARRAY
113938: PPUSH
113939: LD_INT 1
113941: PPUSH
113942: LD_EXP 212
113946: PUSH
113947: LD_VAR 0 3
113951: ARRAY
113952: PPUSH
113953: LD_INT 0
113955: PPUSH
113956: CALL 23628 0 4
113960: PPUSH
113961: CALL_OW 1
113965: ST_TO_ADDR
// if not building in mc_bases [ i ] then
113966: LD_VAR 0 1
113970: PUSH
113971: LD_EXP 178
113975: PUSH
113976: LD_VAR 0 3
113980: ARRAY
113981: IN
113982: NOT
113983: IFFALSE 114029
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
113985: LD_ADDR_EXP 178
113989: PUSH
113990: LD_EXP 178
113994: PPUSH
113995: LD_VAR 0 3
113999: PUSH
114000: LD_EXP 178
114004: PUSH
114005: LD_VAR 0 3
114009: ARRAY
114010: PUSH
114011: LD_INT 1
114013: PLUS
114014: PUSH
114015: EMPTY
114016: LIST
114017: LIST
114018: PPUSH
114019: LD_VAR 0 1
114023: PPUSH
114024: CALL 24210 0 3
114028: ST_TO_ADDR
// exit ;
114029: POP
114030: POP
114031: GO 114037
// end ; end ;
114033: GO 113837
114035: POP
114036: POP
// end ;
114037: LD_VAR 0 2
114041: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
114042: LD_INT 0
114044: PPUSH
114045: PPUSH
114046: PPUSH
114047: PPUSH
114048: PPUSH
114049: PPUSH
114050: PPUSH
// if not mc_bases or not skirmish then
114051: LD_EXP 178
114055: NOT
114056: PUSH
114057: LD_EXP 176
114061: NOT
114062: OR
114063: IFFALSE 114067
// exit ;
114065: GO 114728
// for i = 1 to mc_bases do
114067: LD_ADDR_VAR 0 3
114071: PUSH
114072: DOUBLE
114073: LD_INT 1
114075: DEC
114076: ST_TO_ADDR
114077: LD_EXP 178
114081: PUSH
114082: FOR_TO
114083: IFFALSE 114726
// begin if building in mc_construct_list [ i ] then
114085: LD_VAR 0 1
114089: PUSH
114090: LD_EXP 185
114094: PUSH
114095: LD_VAR 0 3
114099: ARRAY
114100: IN
114101: IFFALSE 114724
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
114103: LD_ADDR_EXP 185
114107: PUSH
114108: LD_EXP 185
114112: PPUSH
114113: LD_VAR 0 3
114117: PPUSH
114118: LD_EXP 185
114122: PUSH
114123: LD_VAR 0 3
114127: ARRAY
114128: PUSH
114129: LD_VAR 0 1
114133: DIFF
114134: PPUSH
114135: CALL_OW 1
114139: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
114140: LD_ADDR_EXP 178
114144: PUSH
114145: LD_EXP 178
114149: PPUSH
114150: LD_VAR 0 3
114154: PUSH
114155: LD_EXP 178
114159: PUSH
114160: LD_VAR 0 3
114164: ARRAY
114165: PUSH
114166: LD_INT 1
114168: PLUS
114169: PUSH
114170: EMPTY
114171: LIST
114172: LIST
114173: PPUSH
114174: LD_VAR 0 1
114178: PPUSH
114179: CALL 24210 0 3
114183: ST_TO_ADDR
// btype := GetBType ( building ) ;
114184: LD_ADDR_VAR 0 5
114188: PUSH
114189: LD_VAR 0 1
114193: PPUSH
114194: CALL_OW 266
114198: ST_TO_ADDR
// side := GetSide ( building ) ;
114199: LD_ADDR_VAR 0 8
114203: PUSH
114204: LD_VAR 0 1
114208: PPUSH
114209: CALL_OW 255
114213: ST_TO_ADDR
// if btype = b_lab then
114214: LD_VAR 0 5
114218: PUSH
114219: LD_INT 6
114221: EQUAL
114222: IFFALSE 114272
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
114224: LD_ADDR_EXP 211
114228: PUSH
114229: LD_EXP 211
114233: PPUSH
114234: LD_VAR 0 3
114238: PUSH
114239: LD_EXP 211
114243: PUSH
114244: LD_VAR 0 3
114248: ARRAY
114249: PUSH
114250: LD_INT 1
114252: PLUS
114253: PUSH
114254: EMPTY
114255: LIST
114256: LIST
114257: PPUSH
114258: LD_VAR 0 1
114262: PPUSH
114263: CALL 24210 0 3
114267: ST_TO_ADDR
// exit ;
114268: POP
114269: POP
114270: GO 114728
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
114272: LD_VAR 0 5
114276: PUSH
114277: LD_INT 0
114279: PUSH
114280: LD_INT 2
114282: PUSH
114283: LD_INT 4
114285: PUSH
114286: EMPTY
114287: LIST
114288: LIST
114289: LIST
114290: IN
114291: IFFALSE 114415
// begin if btype = b_armoury then
114293: LD_VAR 0 5
114297: PUSH
114298: LD_INT 4
114300: EQUAL
114301: IFFALSE 114311
// btype := b_barracks ;
114303: LD_ADDR_VAR 0 5
114307: PUSH
114308: LD_INT 5
114310: ST_TO_ADDR
// if btype = b_depot then
114311: LD_VAR 0 5
114315: PUSH
114316: LD_INT 0
114318: EQUAL
114319: IFFALSE 114329
// btype := b_warehouse ;
114321: LD_ADDR_VAR 0 5
114325: PUSH
114326: LD_INT 1
114328: ST_TO_ADDR
// if btype = b_workshop then
114329: LD_VAR 0 5
114333: PUSH
114334: LD_INT 2
114336: EQUAL
114337: IFFALSE 114347
// btype := b_factory ;
114339: LD_ADDR_VAR 0 5
114343: PUSH
114344: LD_INT 3
114346: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
114347: LD_VAR 0 5
114351: PPUSH
114352: LD_VAR 0 8
114356: PPUSH
114357: CALL_OW 323
114361: PUSH
114362: LD_INT 1
114364: EQUAL
114365: IFFALSE 114411
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
114367: LD_ADDR_EXP 210
114371: PUSH
114372: LD_EXP 210
114376: PPUSH
114377: LD_VAR 0 3
114381: PUSH
114382: LD_EXP 210
114386: PUSH
114387: LD_VAR 0 3
114391: ARRAY
114392: PUSH
114393: LD_INT 1
114395: PLUS
114396: PUSH
114397: EMPTY
114398: LIST
114399: LIST
114400: PPUSH
114401: LD_VAR 0 1
114405: PPUSH
114406: CALL 24210 0 3
114410: ST_TO_ADDR
// exit ;
114411: POP
114412: POP
114413: GO 114728
// end ; if btype in [ b_bunker , b_turret ] then
114415: LD_VAR 0 5
114419: PUSH
114420: LD_INT 32
114422: PUSH
114423: LD_INT 33
114425: PUSH
114426: EMPTY
114427: LIST
114428: LIST
114429: IN
114430: IFFALSE 114720
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
114432: LD_ADDR_EXP 186
114436: PUSH
114437: LD_EXP 186
114441: PPUSH
114442: LD_VAR 0 3
114446: PUSH
114447: LD_EXP 186
114451: PUSH
114452: LD_VAR 0 3
114456: ARRAY
114457: PUSH
114458: LD_INT 1
114460: PLUS
114461: PUSH
114462: EMPTY
114463: LIST
114464: LIST
114465: PPUSH
114466: LD_VAR 0 1
114470: PPUSH
114471: CALL 24210 0 3
114475: ST_TO_ADDR
// if btype = b_bunker then
114476: LD_VAR 0 5
114480: PUSH
114481: LD_INT 32
114483: EQUAL
114484: IFFALSE 114720
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
114486: LD_ADDR_EXP 187
114490: PUSH
114491: LD_EXP 187
114495: PPUSH
114496: LD_VAR 0 3
114500: PUSH
114501: LD_EXP 187
114505: PUSH
114506: LD_VAR 0 3
114510: ARRAY
114511: PUSH
114512: LD_INT 1
114514: PLUS
114515: PUSH
114516: EMPTY
114517: LIST
114518: LIST
114519: PPUSH
114520: LD_VAR 0 1
114524: PPUSH
114525: CALL 24210 0 3
114529: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
114530: LD_ADDR_VAR 0 6
114534: PUSH
114535: LD_EXP 178
114539: PUSH
114540: LD_VAR 0 3
114544: ARRAY
114545: PPUSH
114546: LD_INT 25
114548: PUSH
114549: LD_INT 1
114551: PUSH
114552: EMPTY
114553: LIST
114554: LIST
114555: PUSH
114556: LD_INT 3
114558: PUSH
114559: LD_INT 54
114561: PUSH
114562: EMPTY
114563: LIST
114564: PUSH
114565: EMPTY
114566: LIST
114567: LIST
114568: PUSH
114569: EMPTY
114570: LIST
114571: LIST
114572: PPUSH
114573: CALL_OW 72
114577: ST_TO_ADDR
// if tmp then
114578: LD_VAR 0 6
114582: IFFALSE 114588
// exit ;
114584: POP
114585: POP
114586: GO 114728
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
114588: LD_ADDR_VAR 0 6
114592: PUSH
114593: LD_EXP 178
114597: PUSH
114598: LD_VAR 0 3
114602: ARRAY
114603: PPUSH
114604: LD_INT 2
114606: PUSH
114607: LD_INT 30
114609: PUSH
114610: LD_INT 4
114612: PUSH
114613: EMPTY
114614: LIST
114615: LIST
114616: PUSH
114617: LD_INT 30
114619: PUSH
114620: LD_INT 5
114622: PUSH
114623: EMPTY
114624: LIST
114625: LIST
114626: PUSH
114627: EMPTY
114628: LIST
114629: LIST
114630: LIST
114631: PPUSH
114632: CALL_OW 72
114636: ST_TO_ADDR
// if not tmp then
114637: LD_VAR 0 6
114641: NOT
114642: IFFALSE 114648
// exit ;
114644: POP
114645: POP
114646: GO 114728
// for j in tmp do
114648: LD_ADDR_VAR 0 4
114652: PUSH
114653: LD_VAR 0 6
114657: PUSH
114658: FOR_IN
114659: IFFALSE 114718
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
114661: LD_ADDR_VAR 0 7
114665: PUSH
114666: LD_VAR 0 4
114670: PPUSH
114671: CALL_OW 313
114675: PPUSH
114676: LD_INT 25
114678: PUSH
114679: LD_INT 1
114681: PUSH
114682: EMPTY
114683: LIST
114684: LIST
114685: PPUSH
114686: CALL_OW 72
114690: ST_TO_ADDR
// if units then
114691: LD_VAR 0 7
114695: IFFALSE 114716
// begin ComExitBuilding ( units [ 1 ] ) ;
114697: LD_VAR 0 7
114701: PUSH
114702: LD_INT 1
114704: ARRAY
114705: PPUSH
114706: CALL_OW 122
// exit ;
114710: POP
114711: POP
114712: POP
114713: POP
114714: GO 114728
// end ; end ;
114716: GO 114658
114718: POP
114719: POP
// end ; end ; exit ;
114720: POP
114721: POP
114722: GO 114728
// end ; end ;
114724: GO 114082
114726: POP
114727: POP
// end ;
114728: LD_VAR 0 2
114732: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
114733: LD_INT 0
114735: PPUSH
114736: PPUSH
114737: PPUSH
114738: PPUSH
114739: PPUSH
114740: PPUSH
114741: PPUSH
// if not mc_bases or not skirmish then
114742: LD_EXP 178
114746: NOT
114747: PUSH
114748: LD_EXP 176
114752: NOT
114753: OR
114754: IFFALSE 114758
// exit ;
114756: GO 115023
// btype := GetBType ( building ) ;
114758: LD_ADDR_VAR 0 6
114762: PUSH
114763: LD_VAR 0 1
114767: PPUSH
114768: CALL_OW 266
114772: ST_TO_ADDR
// x := GetX ( building ) ;
114773: LD_ADDR_VAR 0 7
114777: PUSH
114778: LD_VAR 0 1
114782: PPUSH
114783: CALL_OW 250
114787: ST_TO_ADDR
// y := GetY ( building ) ;
114788: LD_ADDR_VAR 0 8
114792: PUSH
114793: LD_VAR 0 1
114797: PPUSH
114798: CALL_OW 251
114802: ST_TO_ADDR
// d := GetDir ( building ) ;
114803: LD_ADDR_VAR 0 9
114807: PUSH
114808: LD_VAR 0 1
114812: PPUSH
114813: CALL_OW 254
114817: ST_TO_ADDR
// for i = 1 to mc_bases do
114818: LD_ADDR_VAR 0 4
114822: PUSH
114823: DOUBLE
114824: LD_INT 1
114826: DEC
114827: ST_TO_ADDR
114828: LD_EXP 178
114832: PUSH
114833: FOR_TO
114834: IFFALSE 115021
// begin if not mc_build_list [ i ] then
114836: LD_EXP 183
114840: PUSH
114841: LD_VAR 0 4
114845: ARRAY
114846: NOT
114847: IFFALSE 114851
// continue ;
114849: GO 114833
// for j := 1 to mc_build_list [ i ] do
114851: LD_ADDR_VAR 0 5
114855: PUSH
114856: DOUBLE
114857: LD_INT 1
114859: DEC
114860: ST_TO_ADDR
114861: LD_EXP 183
114865: PUSH
114866: LD_VAR 0 4
114870: ARRAY
114871: PUSH
114872: FOR_TO
114873: IFFALSE 115017
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ j ] ) then
114875: LD_VAR 0 6
114879: PUSH
114880: LD_VAR 0 7
114884: PUSH
114885: LD_VAR 0 8
114889: PUSH
114890: LD_VAR 0 9
114894: PUSH
114895: EMPTY
114896: LIST
114897: LIST
114898: LIST
114899: LIST
114900: PPUSH
114901: LD_EXP 183
114905: PUSH
114906: LD_VAR 0 4
114910: ARRAY
114911: PUSH
114912: LD_VAR 0 5
114916: ARRAY
114917: PPUSH
114918: CALL 30392 0 2
114922: IFFALSE 115015
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , j ) ) ;
114924: LD_ADDR_EXP 183
114928: PUSH
114929: LD_EXP 183
114933: PPUSH
114934: LD_VAR 0 4
114938: PPUSH
114939: LD_EXP 183
114943: PUSH
114944: LD_VAR 0 4
114948: ARRAY
114949: PPUSH
114950: LD_VAR 0 5
114954: PPUSH
114955: CALL_OW 3
114959: PPUSH
114960: CALL_OW 1
114964: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
114965: LD_ADDR_EXP 185
114969: PUSH
114970: LD_EXP 185
114974: PPUSH
114975: LD_VAR 0 4
114979: PUSH
114980: LD_EXP 185
114984: PUSH
114985: LD_VAR 0 4
114989: ARRAY
114990: PUSH
114991: LD_INT 1
114993: PLUS
114994: PUSH
114995: EMPTY
114996: LIST
114997: LIST
114998: PPUSH
114999: LD_VAR 0 1
115003: PPUSH
115004: CALL 24210 0 3
115008: ST_TO_ADDR
// exit ;
115009: POP
115010: POP
115011: POP
115012: POP
115013: GO 115023
// end ;
115015: GO 114872
115017: POP
115018: POP
// end ;
115019: GO 114833
115021: POP
115022: POP
// end ;
115023: LD_VAR 0 3
115027: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
115028: LD_INT 0
115030: PPUSH
115031: PPUSH
115032: PPUSH
// if not mc_bases or not skirmish then
115033: LD_EXP 178
115037: NOT
115038: PUSH
115039: LD_EXP 176
115043: NOT
115044: OR
115045: IFFALSE 115049
// exit ;
115047: GO 115239
// for i = 1 to mc_bases do
115049: LD_ADDR_VAR 0 4
115053: PUSH
115054: DOUBLE
115055: LD_INT 1
115057: DEC
115058: ST_TO_ADDR
115059: LD_EXP 178
115063: PUSH
115064: FOR_TO
115065: IFFALSE 115152
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
115067: LD_VAR 0 1
115071: PUSH
115072: LD_EXP 186
115076: PUSH
115077: LD_VAR 0 4
115081: ARRAY
115082: IN
115083: PUSH
115084: LD_VAR 0 1
115088: PUSH
115089: LD_EXP 187
115093: PUSH
115094: LD_VAR 0 4
115098: ARRAY
115099: IN
115100: NOT
115101: AND
115102: IFFALSE 115150
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
115104: LD_ADDR_EXP 187
115108: PUSH
115109: LD_EXP 187
115113: PPUSH
115114: LD_VAR 0 4
115118: PUSH
115119: LD_EXP 187
115123: PUSH
115124: LD_VAR 0 4
115128: ARRAY
115129: PUSH
115130: LD_INT 1
115132: PLUS
115133: PUSH
115134: EMPTY
115135: LIST
115136: LIST
115137: PPUSH
115138: LD_VAR 0 1
115142: PPUSH
115143: CALL 24210 0 3
115147: ST_TO_ADDR
// break ;
115148: GO 115152
// end ; end ;
115150: GO 115064
115152: POP
115153: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
115154: LD_VAR 0 1
115158: PPUSH
115159: CALL_OW 257
115163: PUSH
115164: LD_EXP 204
115168: IN
115169: PUSH
115170: LD_VAR 0 1
115174: PPUSH
115175: CALL_OW 266
115179: PUSH
115180: LD_INT 5
115182: EQUAL
115183: AND
115184: PUSH
115185: LD_VAR 0 2
115189: PPUSH
115190: CALL_OW 110
115194: PUSH
115195: LD_INT 18
115197: NONEQUAL
115198: AND
115199: IFFALSE 115239
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
115201: LD_VAR 0 2
115205: PPUSH
115206: CALL_OW 257
115210: PUSH
115211: LD_INT 5
115213: PUSH
115214: LD_INT 8
115216: PUSH
115217: LD_INT 9
115219: PUSH
115220: EMPTY
115221: LIST
115222: LIST
115223: LIST
115224: IN
115225: IFFALSE 115239
// SetClass ( unit , 1 ) ;
115227: LD_VAR 0 2
115231: PPUSH
115232: LD_INT 1
115234: PPUSH
115235: CALL_OW 336
// end ;
115239: LD_VAR 0 3
115243: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
115244: LD_INT 0
115246: PPUSH
115247: PPUSH
// if not mc_bases or not skirmish then
115248: LD_EXP 178
115252: NOT
115253: PUSH
115254: LD_EXP 176
115258: NOT
115259: OR
115260: IFFALSE 115264
// exit ;
115262: GO 115380
// if GetLives ( abandoned_vehicle ) > 250 then
115264: LD_VAR 0 2
115268: PPUSH
115269: CALL_OW 256
115273: PUSH
115274: LD_INT 250
115276: GREATER
115277: IFFALSE 115281
// exit ;
115279: GO 115380
// for i = 1 to mc_bases do
115281: LD_ADDR_VAR 0 6
115285: PUSH
115286: DOUBLE
115287: LD_INT 1
115289: DEC
115290: ST_TO_ADDR
115291: LD_EXP 178
115295: PUSH
115296: FOR_TO
115297: IFFALSE 115378
// begin if driver in mc_bases [ i ] then
115299: LD_VAR 0 1
115303: PUSH
115304: LD_EXP 178
115308: PUSH
115309: LD_VAR 0 6
115313: ARRAY
115314: IN
115315: IFFALSE 115376
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
115317: LD_VAR 0 1
115321: PPUSH
115322: LD_EXP 178
115326: PUSH
115327: LD_VAR 0 6
115331: ARRAY
115332: PPUSH
115333: LD_INT 2
115335: PUSH
115336: LD_INT 30
115338: PUSH
115339: LD_INT 0
115341: PUSH
115342: EMPTY
115343: LIST
115344: LIST
115345: PUSH
115346: LD_INT 30
115348: PUSH
115349: LD_INT 1
115351: PUSH
115352: EMPTY
115353: LIST
115354: LIST
115355: PUSH
115356: EMPTY
115357: LIST
115358: LIST
115359: LIST
115360: PPUSH
115361: CALL_OW 72
115365: PUSH
115366: LD_INT 1
115368: ARRAY
115369: PPUSH
115370: CALL 56828 0 2
// break ;
115374: GO 115378
// end ; end ;
115376: GO 115296
115378: POP
115379: POP
// end ;
115380: LD_VAR 0 5
115384: RET
