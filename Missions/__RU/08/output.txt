// starting begin InitMission ;
   0: CALL 5 0 0
// end ;
   4: END
// export HeikeCaptured ; export coopWithGensher ; export HeikeStatus ; export Masha ; export dial_BuildDepotBlocker , dial_BuildArBarrackBlocker , dial_ArriveGensherUnitsBlocker ; export buildingsToBuild , techsToResearch , vehWeaponsToConstruct , availableWeapons , weaponsData , allBuildings ; export HeikeTargetX , HeikeTargetY , GensherTargetX , GensherTargetY ; export allowExitFromMap ; export acceptKurtOffert , askCommanders ; export KurtCanEscape , KurtStatus , KurtWaitingForFreeHeike , KurtWaitingForBuildBarrack ; export KurtAttack , americansAttack , forceStopKurtAttack ; export canSendHeike , canShootTrening ; export BurlakRespect ; export acceptLegionOffert , paidLegionOffert , legionOffertCountdown , legionOffertTime ; export firstMashaQuery , canChooseMashaVehicle ; export buildCompVehicle , buildArabBarrack , testedTeleport ; export lostUnits ; function InitMission ; begin
   5: LD_INT 0
   7: PPUSH
// ResetFog ;
   8: CALL_OW 335
// RandomizeAll ;
  12: CALL_OW 11
// InGameOn ;
  16: CALL_OW 8
// InitMapConfig ;
  20: CALL 358 0 0
// HeikeCaptured = LoadVariable ( 07_HeikeCaptured_1 , 0 ) ;
  24: LD_ADDR_EXP 1
  28: PUSH
  29: LD_STRING 07_HeikeCaptured_1
  31: PPUSH
  32: LD_INT 0
  34: PPUSH
  35: CALL_OW 30
  39: ST_TO_ADDR
// coopWithGensher = 0 ;
  40: LD_ADDR_EXP 2
  44: PUSH
  45: LD_INT 0
  47: ST_TO_ADDR
// HeikeStatus = 0 ;
  48: LD_ADDR_EXP 3
  52: PUSH
  53: LD_INT 0
  55: ST_TO_ADDR
// Masha = [ ] ;
  56: LD_ADDR_EXP 4
  60: PUSH
  61: EMPTY
  62: ST_TO_ADDR
// buildingsToBuild = [ ] ;
  63: LD_ADDR_EXP 8
  67: PUSH
  68: EMPTY
  69: ST_TO_ADDR
// techsToResearch = [ ] ;
  70: LD_ADDR_EXP 9
  74: PUSH
  75: EMPTY
  76: ST_TO_ADDR
// vehWeaponsToConstruct = [ ] ;
  77: LD_ADDR_EXP 10
  81: PUSH
  82: EMPTY
  83: ST_TO_ADDR
// availableWeapons = [ ] ;
  84: LD_ADDR_EXP 11
  88: PUSH
  89: EMPTY
  90: ST_TO_ADDR
// weaponsData = [ ] ;
  91: LD_ADDR_EXP 12
  95: PUSH
  96: EMPTY
  97: ST_TO_ADDR
// allBuildings = [ ] ;
  98: LD_ADDR_EXP 13
 102: PUSH
 103: EMPTY
 104: ST_TO_ADDR
// HeikeTargetX = 0 ;
 105: LD_ADDR_EXP 14
 109: PUSH
 110: LD_INT 0
 112: ST_TO_ADDR
// HeikeTargetY = 0 ;
 113: LD_ADDR_EXP 15
 117: PUSH
 118: LD_INT 0
 120: ST_TO_ADDR
// GensherTargetX = 0 ;
 121: LD_ADDR_EXP 16
 125: PUSH
 126: LD_INT 0
 128: ST_TO_ADDR
// GensherTargetY = 0 ;
 129: LD_ADDR_EXP 17
 133: PUSH
 134: LD_INT 0
 136: ST_TO_ADDR
// allowExitFromMap = 0 ;
 137: LD_ADDR_EXP 18
 141: PUSH
 142: LD_INT 0
 144: ST_TO_ADDR
// acceptKurtOffert = 0 ;
 145: LD_ADDR_EXP 19
 149: PUSH
 150: LD_INT 0
 152: ST_TO_ADDR
// askCommanders = 0 ;
 153: LD_ADDR_EXP 20
 157: PUSH
 158: LD_INT 0
 160: ST_TO_ADDR
// KurtCanEscape = true ;
 161: LD_ADDR_EXP 21
 165: PUSH
 166: LD_INT 1
 168: ST_TO_ADDR
// KurtAttack = false ;
 169: LD_ADDR_EXP 25
 173: PUSH
 174: LD_INT 0
 176: ST_TO_ADDR
// KurtWaitingForFreeHeike = false ;
 177: LD_ADDR_EXP 23
 181: PUSH
 182: LD_INT 0
 184: ST_TO_ADDR
// KurtWaitingForBuildBarrack = false ;
 185: LD_ADDR_EXP 24
 189: PUSH
 190: LD_INT 0
 192: ST_TO_ADDR
// KurtStatus = 0 ;
 193: LD_ADDR_EXP 22
 197: PUSH
 198: LD_INT 0
 200: ST_TO_ADDR
// americansAttack = false ;
 201: LD_ADDR_EXP 26
 205: PUSH
 206: LD_INT 0
 208: ST_TO_ADDR
// forceStopKurtAttack = false ;
 209: LD_ADDR_EXP 27
 213: PUSH
 214: LD_INT 0
 216: ST_TO_ADDR
// canSendHeike = false ;
 217: LD_ADDR_EXP 28
 221: PUSH
 222: LD_INT 0
 224: ST_TO_ADDR
// canShootTrening = false ;
 225: LD_ADDR_EXP 29
 229: PUSH
 230: LD_INT 0
 232: ST_TO_ADDR
// BurlakRespect = 0 ;
 233: LD_ADDR_EXP 30
 237: PUSH
 238: LD_INT 0
 240: ST_TO_ADDR
// acceptLegionOffert = false ;
 241: LD_ADDR_EXP 31
 245: PUSH
 246: LD_INT 0
 248: ST_TO_ADDR
// paidLegionOffert = false ;
 249: LD_ADDR_EXP 32
 253: PUSH
 254: LD_INT 0
 256: ST_TO_ADDR
// legionOffertCountdown = false ;
 257: LD_ADDR_EXP 33
 261: PUSH
 262: LD_INT 0
 264: ST_TO_ADDR
// legionOffertTime = 0 0$60 ;
 265: LD_ADDR_EXP 34
 269: PUSH
 270: LD_INT 2100
 272: ST_TO_ADDR
// canChooseMashaVehicle = false ;
 273: LD_ADDR_EXP 36
 277: PUSH
 278: LD_INT 0
 280: ST_TO_ADDR
// firstMashaQuery = true ;
 281: LD_ADDR_EXP 35
 285: PUSH
 286: LD_INT 1
 288: ST_TO_ADDR
// buildArabBarrack = false ;
 289: LD_ADDR_EXP 38
 293: PUSH
 294: LD_INT 0
 296: ST_TO_ADDR
// buildCompVehicle = false ;
 297: LD_ADDR_EXP 37
 301: PUSH
 302: LD_INT 0
 304: ST_TO_ADDR
// testedTeleport = false ;
 305: LD_ADDR_EXP 39
 309: PUSH
 310: LD_INT 0
 312: ST_TO_ADDR
// lostUnits = 0 ;
 313: LD_ADDR_EXP 40
 317: PUSH
 318: LD_INT 0
 320: ST_TO_ADDR
// PrepareRussians ;
 321: CALL 1224 0 0
// PrepareArabians ;
 325: CALL 3773 0 0
// PrepareAmericans ;
 329: CALL 2907 0 0
// Nef_PrepareNature ;
 333: CALL 4757 0 0
// SpawnTrees ;
 337: CALL 5378 0 0
// MissionIntro ;
 341: CALL 9011 0 0
// end ;
 345: LD_VAR 0 1
 349: RET
// export function CustomInitMacro ; begin
 350: LD_INT 0
 352: PPUSH
// end ; end_of_file
 353: LD_VAR 0 1
 357: RET
// export function InitMapConfig ; begin
 358: LD_INT 0
 360: PPUSH
// BaseMapConfig ;
 361: CALL 374 0 0
// MissionMapConfig ;
 365: CALL 464 0 0
// end ;
 369: LD_VAR 0 1
 373: RET
// export animalsAmount , animalsStats , animalsAgression , missionPrefix , previousMissionPrefix , debugMode ; function BaseMapConfig ; begin
 374: LD_INT 0
 376: PPUSH
// animalsAmount = [ 6 , 3 , 4 , 4 , 1 ] ;
 377: LD_ADDR_EXP 41
 381: PUSH
 382: LD_INT 6
 384: PUSH
 385: LD_INT 3
 387: PUSH
 388: LD_INT 4
 390: PUSH
 391: LD_INT 4
 393: PUSH
 394: LD_INT 1
 396: PUSH
 397: EMPTY
 398: LIST
 399: LIST
 400: LIST
 401: LIST
 402: LIST
 403: ST_TO_ADDR
// animalsStats = [ 2 , 2 , 2 , 2 ] ;
 404: LD_ADDR_EXP 42
 408: PUSH
 409: LD_INT 2
 411: PUSH
 412: LD_INT 2
 414: PUSH
 415: LD_INT 2
 417: PUSH
 418: LD_INT 2
 420: PUSH
 421: EMPTY
 422: LIST
 423: LIST
 424: LIST
 425: LIST
 426: ST_TO_ADDR
// animalsAgression = 3 ;
 427: LD_ADDR_EXP 43
 431: PUSH
 432: LD_INT 3
 434: ST_TO_ADDR
// debugMode = 0 ;
 435: LD_ADDR_EXP 46
 439: PUSH
 440: LD_INT 0
 442: ST_TO_ADDR
// missionPrefix = 08_ ;
 443: LD_ADDR_EXP 44
 447: PUSH
 448: LD_STRING 08_
 450: ST_TO_ADDR
// previousMissionPrefix = 07_ ;
 451: LD_ADDR_EXP 45
 455: PUSH
 456: LD_STRING 07_
 458: ST_TO_ADDR
// end ;
 459: LD_VAR 0 1
 463: RET
// export KurtAttackWaves , americansAttackWaves ; export firstAttackDelay ; export waveCooldown ; export legionReduceAmericansUnits ; export speedMedalTime ; export enemyAttackUnitsData ; export timeToFreeHeike , timeToBuildArBarrack ; export enemySkillLevel ; function MissionMapConfig ; begin
 464: LD_INT 0
 466: PPUSH
// KurtAttackWaves = [ 3 , 4 , 5 ] [ Difficulty ] ;
 467: LD_ADDR_EXP 47
 471: PUSH
 472: LD_INT 3
 474: PUSH
 475: LD_INT 4
 477: PUSH
 478: LD_INT 5
 480: PUSH
 481: EMPTY
 482: LIST
 483: LIST
 484: LIST
 485: PUSH
 486: LD_OWVAR 67
 490: ARRAY
 491: ST_TO_ADDR
// americansAttackWaves = [ 1 , 2 , 3 ] [ Difficulty ] ;
 492: LD_ADDR_EXP 48
 496: PUSH
 497: LD_INT 1
 499: PUSH
 500: LD_INT 2
 502: PUSH
 503: LD_INT 3
 505: PUSH
 506: EMPTY
 507: LIST
 508: LIST
 509: LIST
 510: PUSH
 511: LD_OWVAR 67
 515: ARRAY
 516: ST_TO_ADDR
// enemySkillLevel = [ 3 , 4 , 5 ] [ Difficulty ] ;
 517: LD_ADDR_EXP 56
 521: PUSH
 522: LD_INT 3
 524: PUSH
 525: LD_INT 4
 527: PUSH
 528: LD_INT 5
 530: PUSH
 531: EMPTY
 532: LIST
 533: LIST
 534: LIST
 535: PUSH
 536: LD_OWVAR 67
 540: ARRAY
 541: ST_TO_ADDR
// waveCooldown = 1 1$30 ;
 542: LD_ADDR_EXP 50
 546: PUSH
 547: LD_INT 3150
 549: ST_TO_ADDR
// firstAttackDelay = 1 1$00 ;
 550: LD_ADDR_EXP 49
 554: PUSH
 555: LD_INT 2100
 557: ST_TO_ADDR
// timeToFreeHeike = 2 2$00 ;
 558: LD_ADDR_EXP 54
 562: PUSH
 563: LD_INT 4200
 565: ST_TO_ADDR
// timeToBuildArBarrack = 5 5$00 ;
 566: LD_ADDR_EXP 55
 570: PUSH
 571: LD_INT 10500
 573: ST_TO_ADDR
// legionReduceAmericansUnits = [ 5 , 5 , 6 ] [ Difficulty ] ;
 574: LD_ADDR_EXP 51
 578: PUSH
 579: LD_INT 5
 581: PUSH
 582: LD_INT 5
 584: PUSH
 585: LD_INT 6
 587: PUSH
 588: EMPTY
 589: LIST
 590: LIST
 591: LIST
 592: PUSH
 593: LD_OWVAR 67
 597: ARRAY
 598: ST_TO_ADDR
// speedMedalTime = [ 80 80$0 , 70 70$0 , 60 60$0 ] [ Difficulty ] ;
 599: LD_ADDR_EXP 52
 603: PUSH
 604: LD_INT 168000
 606: PUSH
 607: LD_INT 147000
 609: PUSH
 610: LD_INT 126000
 612: PUSH
 613: EMPTY
 614: LIST
 615: LIST
 616: LIST
 617: PUSH
 618: LD_OWVAR 67
 622: ARRAY
 623: ST_TO_ADDR
// enemyAttackUnitsData = [ [ 1 , [ 4 , 5 , 6 ] [ Difficulty ] , [ 7 , 8 , 9 ] [ Difficulty ] , [ 1 , 2 , 2 ] [ Difficulty ] , [ 3 , 3 , 4 ] [ Difficulty ] , [ 6 , 7 , 8 ] [ Difficulty ] , [ 10 , 12 , 15 ] [ Difficulty ] ] , [ 8 , [ 2 , 3 , 4 ] [ Difficulty ] , [ 6 , 6 , 7 ] [ Difficulty ] , [ 0 , 1 , 1 ] [ Difficulty ] , [ 1 , 2 , 3 ] [ Difficulty ] , [ 1 , 2 , 2 ] [ Difficulty ] , [ 2 , 3 , 5 ] [ Difficulty ] ] ] ;
 624: LD_ADDR_EXP 53
 628: PUSH
 629: LD_INT 1
 631: PUSH
 632: LD_INT 4
 634: PUSH
 635: LD_INT 5
 637: PUSH
 638: LD_INT 6
 640: PUSH
 641: EMPTY
 642: LIST
 643: LIST
 644: LIST
 645: PUSH
 646: LD_OWVAR 67
 650: ARRAY
 651: PUSH
 652: LD_INT 7
 654: PUSH
 655: LD_INT 8
 657: PUSH
 658: LD_INT 9
 660: PUSH
 661: EMPTY
 662: LIST
 663: LIST
 664: LIST
 665: PUSH
 666: LD_OWVAR 67
 670: ARRAY
 671: PUSH
 672: LD_INT 1
 674: PUSH
 675: LD_INT 2
 677: PUSH
 678: LD_INT 2
 680: PUSH
 681: EMPTY
 682: LIST
 683: LIST
 684: LIST
 685: PUSH
 686: LD_OWVAR 67
 690: ARRAY
 691: PUSH
 692: LD_INT 3
 694: PUSH
 695: LD_INT 3
 697: PUSH
 698: LD_INT 4
 700: PUSH
 701: EMPTY
 702: LIST
 703: LIST
 704: LIST
 705: PUSH
 706: LD_OWVAR 67
 710: ARRAY
 711: PUSH
 712: LD_INT 6
 714: PUSH
 715: LD_INT 7
 717: PUSH
 718: LD_INT 8
 720: PUSH
 721: EMPTY
 722: LIST
 723: LIST
 724: LIST
 725: PUSH
 726: LD_OWVAR 67
 730: ARRAY
 731: PUSH
 732: LD_INT 10
 734: PUSH
 735: LD_INT 12
 737: PUSH
 738: LD_INT 15
 740: PUSH
 741: EMPTY
 742: LIST
 743: LIST
 744: LIST
 745: PUSH
 746: LD_OWVAR 67
 750: ARRAY
 751: PUSH
 752: EMPTY
 753: LIST
 754: LIST
 755: LIST
 756: LIST
 757: LIST
 758: LIST
 759: LIST
 760: PUSH
 761: LD_INT 8
 763: PUSH
 764: LD_INT 2
 766: PUSH
 767: LD_INT 3
 769: PUSH
 770: LD_INT 4
 772: PUSH
 773: EMPTY
 774: LIST
 775: LIST
 776: LIST
 777: PUSH
 778: LD_OWVAR 67
 782: ARRAY
 783: PUSH
 784: LD_INT 6
 786: PUSH
 787: LD_INT 6
 789: PUSH
 790: LD_INT 7
 792: PUSH
 793: EMPTY
 794: LIST
 795: LIST
 796: LIST
 797: PUSH
 798: LD_OWVAR 67
 802: ARRAY
 803: PUSH
 804: LD_INT 0
 806: PUSH
 807: LD_INT 1
 809: PUSH
 810: LD_INT 1
 812: PUSH
 813: EMPTY
 814: LIST
 815: LIST
 816: LIST
 817: PUSH
 818: LD_OWVAR 67
 822: ARRAY
 823: PUSH
 824: LD_INT 1
 826: PUSH
 827: LD_INT 2
 829: PUSH
 830: LD_INT 3
 832: PUSH
 833: EMPTY
 834: LIST
 835: LIST
 836: LIST
 837: PUSH
 838: LD_OWVAR 67
 842: ARRAY
 843: PUSH
 844: LD_INT 1
 846: PUSH
 847: LD_INT 2
 849: PUSH
 850: LD_INT 2
 852: PUSH
 853: EMPTY
 854: LIST
 855: LIST
 856: LIST
 857: PUSH
 858: LD_OWVAR 67
 862: ARRAY
 863: PUSH
 864: LD_INT 2
 866: PUSH
 867: LD_INT 3
 869: PUSH
 870: LD_INT 5
 872: PUSH
 873: EMPTY
 874: LIST
 875: LIST
 876: LIST
 877: PUSH
 878: LD_OWVAR 67
 882: ARRAY
 883: PUSH
 884: EMPTY
 885: LIST
 886: LIST
 887: LIST
 888: LIST
 889: LIST
 890: LIST
 891: LIST
 892: PUSH
 893: EMPTY
 894: LIST
 895: LIST
 896: ST_TO_ADDR
// end ;
 897: LD_VAR 0 1
 901: RET
// every 0 0$1 trigger debugMode do var i ;
 902: LD_EXP 46
 906: IFFALSE 1221
 908: GO 910
 910: DISABLE
 911: LD_INT 0
 913: PPUSH
// begin enable ;
 914: ENABLE
// FogOff ( your_side ) ;
 915: LD_OWVAR 2
 919: PPUSH
 920: CALL_OW 344
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) do
 924: LD_ADDR_VAR 0 1
 928: PUSH
 929: LD_INT 22
 931: PUSH
 932: LD_OWVAR 2
 936: PUSH
 937: EMPTY
 938: LIST
 939: LIST
 940: PUSH
 941: LD_INT 2
 943: PUSH
 944: LD_INT 21
 946: PUSH
 947: LD_INT 1
 949: PUSH
 950: EMPTY
 951: LIST
 952: LIST
 953: PUSH
 954: LD_INT 21
 956: PUSH
 957: LD_INT 2
 959: PUSH
 960: EMPTY
 961: LIST
 962: LIST
 963: PUSH
 964: EMPTY
 965: LIST
 966: LIST
 967: LIST
 968: PUSH
 969: EMPTY
 970: LIST
 971: LIST
 972: PPUSH
 973: CALL_OW 69
 977: PUSH
 978: FOR_IN
 979: IFFALSE 995
// SetLives ( i , 1000 ) ;
 981: LD_VAR 0 1
 985: PPUSH
 986: LD_INT 1000
 988: PPUSH
 989: CALL_OW 234
 993: GO 978
 995: POP
 996: POP
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
 997: LD_ADDR_VAR 0 1
1001: PUSH
1002: LD_INT 22
1004: PUSH
1005: LD_OWVAR 2
1009: PUSH
1010: EMPTY
1011: LIST
1012: LIST
1013: PUSH
1014: LD_INT 21
1016: PUSH
1017: LD_INT 1
1019: PUSH
1020: EMPTY
1021: LIST
1022: LIST
1023: PUSH
1024: EMPTY
1025: LIST
1026: LIST
1027: PPUSH
1028: CALL_OW 69
1032: PUSH
1033: FOR_IN
1034: IFFALSE 1098
// begin SetSkill ( i , skill_combat , 10 ) ;
1036: LD_VAR 0 1
1040: PPUSH
1041: LD_INT 1
1043: PPUSH
1044: LD_INT 10
1046: PPUSH
1047: CALL_OW 237
// SetSkill ( i , skill_engineering , 10 ) ;
1051: LD_VAR 0 1
1055: PPUSH
1056: LD_INT 2
1058: PPUSH
1059: LD_INT 10
1061: PPUSH
1062: CALL_OW 237
// SetSkill ( i , skill_mechanical , 10 ) ;
1066: LD_VAR 0 1
1070: PPUSH
1071: LD_INT 3
1073: PPUSH
1074: LD_INT 10
1076: PPUSH
1077: CALL_OW 237
// SetSkill ( i , skill_scientistic , 10 ) ;
1081: LD_VAR 0 1
1085: PPUSH
1086: LD_INT 4
1088: PPUSH
1089: LD_INT 10
1091: PPUSH
1092: CALL_OW 237
// end ;
1096: GO 1033
1098: POP
1099: POP
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) do
1100: LD_ADDR_VAR 0 1
1104: PUSH
1105: LD_INT 22
1107: PUSH
1108: LD_OWVAR 2
1112: PUSH
1113: EMPTY
1114: LIST
1115: LIST
1116: PUSH
1117: LD_INT 2
1119: PUSH
1120: LD_INT 30
1122: PUSH
1123: LD_INT 0
1125: PUSH
1126: EMPTY
1127: LIST
1128: LIST
1129: PUSH
1130: LD_INT 30
1132: PUSH
1133: LD_INT 1
1135: PUSH
1136: EMPTY
1137: LIST
1138: LIST
1139: PUSH
1140: EMPTY
1141: LIST
1142: LIST
1143: LIST
1144: PUSH
1145: EMPTY
1146: LIST
1147: LIST
1148: PPUSH
1149: CALL_OW 69
1153: PUSH
1154: FOR_IN
1155: IFFALSE 1219
// begin SetResourceType ( GetBase ( i ) , mat_cans , 9999 ) ;
1157: LD_VAR 0 1
1161: PPUSH
1162: CALL_OW 274
1166: PPUSH
1167: LD_INT 1
1169: PPUSH
1170: LD_INT 9999
1172: PPUSH
1173: CALL_OW 277
// SetResourceType ( GetBase ( i ) , mat_oil , 9999 ) ;
1177: LD_VAR 0 1
1181: PPUSH
1182: CALL_OW 274
1186: PPUSH
1187: LD_INT 2
1189: PPUSH
1190: LD_INT 9999
1192: PPUSH
1193: CALL_OW 277
// SetResourceType ( GetBase ( i ) , mat_siberit , 9999 ) ;
1197: LD_VAR 0 1
1201: PPUSH
1202: CALL_OW 274
1206: PPUSH
1207: LD_INT 3
1209: PPUSH
1210: LD_INT 9999
1212: PPUSH
1213: CALL_OW 277
// end ;
1217: GO 1154
1219: POP
1220: POP
// end ; end_of_file
1221: PPOPN 1
1223: END
// export Burlak , Karamazov , Petrovova , Gleb , Petrosyan , Titov , Dolgov , Lipshchin , Kirilenkova , Belkov , Belkov2 , Xavier ; export Gnyevko , Kovalyuk , Scholtze , Kuzmov ; export Kozlov , Oblukov , Kapitsova ; export Popov ; export russianEscort ; export function PrepareRussians ; begin
1224: LD_INT 0
1226: PPUSH
// russianEscort = [ ] ;
1227: LD_ADDR_EXP 77
1231: PUSH
1232: EMPTY
1233: ST_TO_ADDR
// Masha = [ ] ;
1234: LD_ADDR_EXP 4
1238: PUSH
1239: EMPTY
1240: ST_TO_ADDR
// PrepareHeroes ;
1241: CALL 1254 0 0
// InitRussianRequiments ;
1245: CALL 2649 0 0
// end ;
1249: LD_VAR 0 1
1253: RET
// function PrepareHeroes ; var i , un , other_survivors , yourUnits , emptyVeh ; begin
1254: LD_INT 0
1256: PPUSH
1257: PPUSH
1258: PPUSH
1259: PPUSH
1260: PPUSH
1261: PPUSH
// uc_side = 3 ;
1262: LD_ADDR_OWVAR 20
1266: PUSH
1267: LD_INT 3
1269: ST_TO_ADDR
// uc_nation = 3 ;
1270: LD_ADDR_OWVAR 21
1274: PUSH
1275: LD_INT 3
1277: ST_TO_ADDR
// Burlak := PrepareUnitExt ( Burlak , true , class_mechanic ) ;
1278: LD_ADDR_EXP 57
1282: PUSH
1283: LD_STRING Burlak
1285: PPUSH
1286: LD_INT 1
1288: PPUSH
1289: LD_INT 3
1291: PPUSH
1292: CALL 5856 0 3
1296: ST_TO_ADDR
// Titov := PrepareUnitExt ( Titov , true , class_soldier ) ;
1297: LD_ADDR_EXP 62
1301: PUSH
1302: LD_STRING Titov
1304: PPUSH
1305: LD_INT 1
1307: PPUSH
1308: LD_INT 1
1310: PPUSH
1311: CALL 5856 0 3
1315: ST_TO_ADDR
// Dolgov := PrepareUnitExt ( Dolgov , true , class_scientistic ) ;
1316: LD_ADDR_EXP 63
1320: PUSH
1321: LD_STRING Dolgov
1323: PPUSH
1324: LD_INT 1
1326: PPUSH
1327: LD_INT 4
1329: PPUSH
1330: CALL 5856 0 3
1334: ST_TO_ADDR
// Lipshchin := PrepareUnitExt ( Lipshchin , true , class_soldier ) ;
1335: LD_ADDR_EXP 64
1339: PUSH
1340: LD_STRING Lipshchin
1342: PPUSH
1343: LD_INT 1
1345: PPUSH
1346: LD_INT 1
1348: PPUSH
1349: CALL 5856 0 3
1353: ST_TO_ADDR
// Karamazov := PrepareUnitExt ( Karamazov , true , class_engineer ) ;
1354: LD_ADDR_EXP 58
1358: PUSH
1359: LD_STRING Karamazov
1361: PPUSH
1362: LD_INT 1
1364: PPUSH
1365: LD_INT 2
1367: PPUSH
1368: CALL 5856 0 3
1372: ST_TO_ADDR
// Petrovova := PrepareUnitExt ( Petrovova , true , class_soldier ) ;
1373: LD_ADDR_EXP 59
1377: PUSH
1378: LD_STRING Petrovova
1380: PPUSH
1381: LD_INT 1
1383: PPUSH
1384: LD_INT 1
1386: PPUSH
1387: CALL 5856 0 3
1391: ST_TO_ADDR
// Gleb := PrepareUnitExt ( Gleb , true , class_soldier ) ;
1392: LD_ADDR_EXP 60
1396: PUSH
1397: LD_STRING Gleb
1399: PPUSH
1400: LD_INT 1
1402: PPUSH
1403: LD_INT 1
1405: PPUSH
1406: CALL 5856 0 3
1410: ST_TO_ADDR
// Petrosyan := PrepareUnitExt ( Petrosyan , true , class_scientistic ) ;
1411: LD_ADDR_EXP 61
1415: PUSH
1416: LD_STRING Petrosyan
1418: PPUSH
1419: LD_INT 1
1421: PPUSH
1422: LD_INT 4
1424: PPUSH
1425: CALL 5856 0 3
1429: ST_TO_ADDR
// Kirilenkova := PrepareUnitExt ( Kirilenkova , true , class_scientistic ) ;
1430: LD_ADDR_EXP 65
1434: PUSH
1435: LD_STRING Kirilenkova
1437: PPUSH
1438: LD_INT 1
1440: PPUSH
1441: LD_INT 4
1443: PPUSH
1444: CALL 5856 0 3
1448: ST_TO_ADDR
// Belkov := PrepareUnitExt ( Belkov , true , class_soldier ) ;
1449: LD_ADDR_EXP 66
1453: PUSH
1454: LD_STRING Belkov
1456: PPUSH
1457: LD_INT 1
1459: PPUSH
1460: LD_INT 1
1462: PPUSH
1463: CALL 5856 0 3
1467: ST_TO_ADDR
// Belkov2 := PrepareUnitExt ( Belkov2 , true , class_soldier ) ;
1468: LD_ADDR_EXP 67
1472: PUSH
1473: LD_STRING Belkov2
1475: PPUSH
1476: LD_INT 1
1478: PPUSH
1479: LD_INT 1
1481: PPUSH
1482: CALL 5856 0 3
1486: ST_TO_ADDR
// Xavier := PrepareUnitExt ( Xavier , true , class_soldier ) ;
1487: LD_ADDR_EXP 68
1491: PUSH
1492: LD_STRING Xavier
1494: PPUSH
1495: LD_INT 1
1497: PPUSH
1498: LD_INT 1
1500: PPUSH
1501: CALL 5856 0 3
1505: ST_TO_ADDR
// Gnyevko := CreateCharacter ( 04_Gnyevko ) ;
1506: LD_ADDR_EXP 69
1510: PUSH
1511: LD_STRING 04_Gnyevko
1513: PPUSH
1514: CALL_OW 34
1518: ST_TO_ADDR
// SetClass ( Gnyevko , class_soldier ) ;
1519: LD_EXP 69
1523: PPUSH
1524: LD_INT 1
1526: PPUSH
1527: CALL_OW 336
// Kovalyuk := CreateCharacter ( 04_Kovalyuk ) ;
1531: LD_ADDR_EXP 70
1535: PUSH
1536: LD_STRING 04_Kovalyuk
1538: PPUSH
1539: CALL_OW 34
1543: ST_TO_ADDR
// SetClass ( Kovalyuk , class_mechanic ) ;
1544: LD_EXP 70
1548: PPUSH
1549: LD_INT 3
1551: PPUSH
1552: CALL_OW 336
// Scholtze := CreateCharacter ( 04_Scholtze ) ;
1556: LD_ADDR_EXP 71
1560: PUSH
1561: LD_STRING 04_Scholtze
1563: PPUSH
1564: CALL_OW 34
1568: ST_TO_ADDR
// SetClass ( Scholtze , class_scientistic ) ;
1569: LD_EXP 71
1573: PPUSH
1574: LD_INT 4
1576: PPUSH
1577: CALL_OW 336
// Kuzmov := CreateCharacter ( 04_Kuzmov ) ;
1581: LD_ADDR_EXP 72
1585: PUSH
1586: LD_STRING 04_Kuzmov
1588: PPUSH
1589: CALL_OW 34
1593: ST_TO_ADDR
// SetClass ( Kuzmov , class_soldier ) ;
1594: LD_EXP 72
1598: PPUSH
1599: LD_INT 1
1601: PPUSH
1602: CALL_OW 336
// Kozlov := PrepareUnitExt ( Kozlov , false , class_engineer ) ;
1606: LD_ADDR_EXP 73
1610: PUSH
1611: LD_STRING Kozlov
1613: PPUSH
1614: LD_INT 0
1616: PPUSH
1617: LD_INT 2
1619: PPUSH
1620: CALL 5856 0 3
1624: ST_TO_ADDR
// Oblukov := PrepareUnitExt ( Oblukov , false , class_soldier ) ;
1625: LD_ADDR_EXP 74
1629: PUSH
1630: LD_STRING Oblukov
1632: PPUSH
1633: LD_INT 0
1635: PPUSH
1636: LD_INT 1
1638: PPUSH
1639: CALL 5856 0 3
1643: ST_TO_ADDR
// Kapitsova := PrepareUnitExt ( Kapitsova , false , class_scientistic ) ;
1644: LD_ADDR_EXP 75
1648: PUSH
1649: LD_STRING Kapitsova
1651: PPUSH
1652: LD_INT 0
1654: PPUSH
1655: LD_INT 4
1657: PPUSH
1658: CALL 5856 0 3
1662: ST_TO_ADDR
// Popov := PrepareUnitExt ( Popov , false , 0 ) ;
1663: LD_ADDR_EXP 76
1667: PUSH
1668: LD_STRING Popov
1670: PPUSH
1671: LD_INT 0
1673: PPUSH
1674: LD_INT 0
1676: PPUSH
1677: CALL 5856 0 3
1681: ST_TO_ADDR
// PlaceUnitsArea ( [ Burlak , Karamazov , Petrovova , Gleb , Petrosyan , Titov , Dolgov , Lipshchin , Kirilenkova , Belkov , Belkov2 , Xavier , Gnyevko , Kovalyuk , Scholtze , Kuzmov , Kozlov , Oblukov , Kapitsova ] , RussianSpawnArea , false ) ;
1682: LD_EXP 57
1686: PUSH
1687: LD_EXP 58
1691: PUSH
1692: LD_EXP 59
1696: PUSH
1697: LD_EXP 60
1701: PUSH
1702: LD_EXP 61
1706: PUSH
1707: LD_EXP 62
1711: PUSH
1712: LD_EXP 63
1716: PUSH
1717: LD_EXP 64
1721: PUSH
1722: LD_EXP 65
1726: PUSH
1727: LD_EXP 66
1731: PUSH
1732: LD_EXP 67
1736: PUSH
1737: LD_EXP 68
1741: PUSH
1742: LD_EXP 69
1746: PUSH
1747: LD_EXP 70
1751: PUSH
1752: LD_EXP 71
1756: PUSH
1757: LD_EXP 72
1761: PUSH
1762: LD_EXP 73
1766: PUSH
1767: LD_EXP 74
1771: PUSH
1772: LD_EXP 75
1776: PUSH
1777: EMPTY
1778: LIST
1779: LIST
1780: LIST
1781: LIST
1782: LIST
1783: LIST
1784: LIST
1785: LIST
1786: LIST
1787: LIST
1788: LIST
1789: LIST
1790: LIST
1791: LIST
1792: LIST
1793: LIST
1794: LIST
1795: LIST
1796: LIST
1797: PPUSH
1798: LD_INT 2
1800: PPUSH
1801: LD_INT 0
1803: PPUSH
1804: CALL 6130 0 3
// PrepareVehicles ;
1808: CALL 2349 0 0
// other_survivors = CreateCharacterSet ( 07_other_survivors ) ;
1812: LD_ADDR_VAR 0 4
1816: PUSH
1817: LD_STRING 07_other_survivors
1819: PPUSH
1820: CALL_OW 31
1824: ST_TO_ADDR
// other_survivors = other_survivors ^ CreateCharacterSet ( 04_other_survivors ) ;
1825: LD_ADDR_VAR 0 4
1829: PUSH
1830: LD_VAR 0 4
1834: PUSH
1835: LD_STRING 04_other_survivors
1837: PPUSH
1838: CALL_OW 31
1842: ADD
1843: ST_TO_ADDR
// other_survivors = other_survivors ^ CreateCharacterSet ( 04_other_survivors_with_popov ) ;
1844: LD_ADDR_VAR 0 4
1848: PUSH
1849: LD_VAR 0 4
1853: PUSH
1854: LD_STRING 04_other_survivors_with_popov
1856: PPUSH
1857: CALL_OW 31
1861: ADD
1862: ST_TO_ADDR
// for un in other_survivors do
1863: LD_ADDR_VAR 0 3
1867: PUSH
1868: LD_VAR 0 4
1872: PUSH
1873: FOR_IN
1874: IFFALSE 1960
// begin emptyVeh = FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] , [ f_empty ] ] ) ;
1876: LD_ADDR_VAR 0 6
1880: PUSH
1881: LD_INT 22
1883: PUSH
1884: LD_INT 3
1886: PUSH
1887: EMPTY
1888: LIST
1889: LIST
1890: PUSH
1891: LD_INT 21
1893: PUSH
1894: LD_INT 2
1896: PUSH
1897: EMPTY
1898: LIST
1899: LIST
1900: PUSH
1901: LD_INT 58
1903: PUSH
1904: EMPTY
1905: LIST
1906: PUSH
1907: EMPTY
1908: LIST
1909: LIST
1910: LIST
1911: PPUSH
1912: CALL_OW 69
1916: ST_TO_ADDR
// if emptyVeh then
1917: LD_VAR 0 6
1921: IFFALSE 1943
// PlaceHumanInUnit ( un , emptyVeh [ 1 ] ) else
1923: LD_VAR 0 3
1927: PPUSH
1928: LD_VAR 0 6
1932: PUSH
1933: LD_INT 1
1935: ARRAY
1936: PPUSH
1937: CALL_OW 52
1941: GO 1958
// PlaceUnitArea ( un , RussianSpawnArea , false ) ;
1943: LD_VAR 0 3
1947: PPUSH
1948: LD_INT 2
1950: PPUSH
1951: LD_INT 0
1953: PPUSH
1954: CALL_OW 49
// end ;
1958: GO 1873
1960: POP
1961: POP
// yourUnits = FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_nation , nation_russian ] ] ) ;
1962: LD_ADDR_VAR 0 5
1966: PUSH
1967: LD_INT 22
1969: PUSH
1970: LD_INT 3
1972: PUSH
1973: EMPTY
1974: LIST
1975: LIST
1976: PUSH
1977: LD_INT 21
1979: PUSH
1980: LD_INT 1
1982: PUSH
1983: EMPTY
1984: LIST
1985: LIST
1986: PUSH
1987: LD_INT 23
1989: PUSH
1990: LD_INT 3
1992: PUSH
1993: EMPTY
1994: LIST
1995: LIST
1996: PUSH
1997: EMPTY
1998: LIST
1999: LIST
2000: LIST
2001: PPUSH
2002: CALL_OW 69
2006: ST_TO_ADDR
// if yourUnits < 15 then
2007: LD_VAR 0 5
2011: PUSH
2012: LD_INT 15
2014: LESS
2015: IFFALSE 2164
// for i := 1 to 15 - yourUnits do
2017: LD_ADDR_VAR 0 2
2021: PUSH
2022: DOUBLE
2023: LD_INT 1
2025: DEC
2026: ST_TO_ADDR
2027: LD_INT 15
2029: PUSH
2030: LD_VAR 0 5
2034: MINUS
2035: PUSH
2036: FOR_TO
2037: IFFALSE 2162
// begin PrepareHuman ( false , rand ( 1 , 4 ) , rand ( 2 , 4 ) ) ;
2039: LD_INT 0
2041: PPUSH
2042: LD_INT 1
2044: PPUSH
2045: LD_INT 4
2047: PPUSH
2048: CALL_OW 12
2052: PPUSH
2053: LD_INT 2
2055: PPUSH
2056: LD_INT 4
2058: PPUSH
2059: CALL_OW 12
2063: PPUSH
2064: CALL_OW 380
// un = CreateHuman ;
2068: LD_ADDR_VAR 0 3
2072: PUSH
2073: CALL_OW 44
2077: ST_TO_ADDR
// emptyVeh = FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] , [ f_empty ] ] ) ;
2078: LD_ADDR_VAR 0 6
2082: PUSH
2083: LD_INT 22
2085: PUSH
2086: LD_INT 3
2088: PUSH
2089: EMPTY
2090: LIST
2091: LIST
2092: PUSH
2093: LD_INT 21
2095: PUSH
2096: LD_INT 2
2098: PUSH
2099: EMPTY
2100: LIST
2101: LIST
2102: PUSH
2103: LD_INT 58
2105: PUSH
2106: EMPTY
2107: LIST
2108: PUSH
2109: EMPTY
2110: LIST
2111: LIST
2112: LIST
2113: PPUSH
2114: CALL_OW 69
2118: ST_TO_ADDR
// if emptyVeh then
2119: LD_VAR 0 6
2123: IFFALSE 2145
// PlaceHumanInUnit ( un , emptyVeh [ 1 ] ) else
2125: LD_VAR 0 3
2129: PPUSH
2130: LD_VAR 0 6
2134: PUSH
2135: LD_INT 1
2137: ARRAY
2138: PPUSH
2139: CALL_OW 52
2143: GO 2160
// PlaceUnitArea ( un , RussianSpawnArea , false ) ;
2145: LD_VAR 0 3
2149: PPUSH
2150: LD_INT 2
2152: PPUSH
2153: LD_INT 0
2155: PPUSH
2156: CALL_OW 49
// end ;
2160: GO 2036
2162: POP
2163: POP
// yourUnits = FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_nation , nation_russian ] ] ) ;
2164: LD_ADDR_VAR 0 5
2168: PUSH
2169: LD_INT 22
2171: PUSH
2172: LD_INT 3
2174: PUSH
2175: EMPTY
2176: LIST
2177: LIST
2178: PUSH
2179: LD_INT 21
2181: PUSH
2182: LD_INT 1
2184: PUSH
2185: EMPTY
2186: LIST
2187: LIST
2188: PUSH
2189: LD_INT 23
2191: PUSH
2192: LD_INT 3
2194: PUSH
2195: EMPTY
2196: LIST
2197: LIST
2198: PUSH
2199: EMPTY
2200: LIST
2201: LIST
2202: LIST
2203: PPUSH
2204: CALL_OW 69
2208: ST_TO_ADDR
// if not UnitFilter ( yourUnits , [ f_class , class_engineer ] ) then
2209: LD_VAR 0 5
2213: PPUSH
2214: LD_INT 25
2216: PUSH
2217: LD_INT 2
2219: PUSH
2220: EMPTY
2221: LIST
2222: LIST
2223: PPUSH
2224: CALL_OW 72
2228: NOT
2229: IFFALSE 2247
// SetClass ( yourUnits [ 1 ] , 2 ) ;
2231: LD_VAR 0 5
2235: PUSH
2236: LD_INT 1
2238: ARRAY
2239: PPUSH
2240: LD_INT 2
2242: PPUSH
2243: CALL_OW 336
// end ;
2247: LD_VAR 0 1
2251: RET
// export function PrepareRussianEscort ; var i , unit ; begin
2252: LD_INT 0
2254: PPUSH
2255: PPUSH
2256: PPUSH
// uc_side = 6 ;
2257: LD_ADDR_OWVAR 20
2261: PUSH
2262: LD_INT 6
2264: ST_TO_ADDR
// uc_nation = 3 ;
2265: LD_ADDR_OWVAR 21
2269: PUSH
2270: LD_INT 3
2272: ST_TO_ADDR
// for i := 1 to 2 do
2273: LD_ADDR_VAR 0 2
2277: PUSH
2278: DOUBLE
2279: LD_INT 1
2281: DEC
2282: ST_TO_ADDR
2283: LD_INT 2
2285: PUSH
2286: FOR_TO
2287: IFFALSE 2342
// begin PrepareSoldier ( false , 4 ) ;
2289: LD_INT 0
2291: PPUSH
2292: LD_INT 4
2294: PPUSH
2295: CALL_OW 381
// unit = CreateHuman ;
2299: LD_ADDR_VAR 0 3
2303: PUSH
2304: CALL_OW 44
2308: ST_TO_ADDR
// russianEscort = russianEscort ^ unit ;
2309: LD_ADDR_EXP 77
2313: PUSH
2314: LD_EXP 77
2318: PUSH
2319: LD_VAR 0 3
2323: ADD
2324: ST_TO_ADDR
// PlaceUnitArea ( unit , RussianSpawn2Area , false ) ;
2325: LD_VAR 0 3
2329: PPUSH
2330: LD_INT 7
2332: PPUSH
2333: LD_INT 0
2335: PPUSH
2336: CALL_OW 49
// end ;
2340: GO 2286
2342: POP
2343: POP
// end ;
2344: LD_VAR 0 1
2348: RET
// function PrepareVehicles ; var i , veh ; begin
2349: LD_INT 0
2351: PPUSH
2352: PPUSH
2353: PPUSH
// uc_side = 3 ;
2354: LD_ADDR_OWVAR 20
2358: PUSH
2359: LD_INT 3
2361: ST_TO_ADDR
// uc_nation = 3 ;
2362: LD_ADDR_OWVAR 21
2366: PUSH
2367: LD_INT 3
2369: ST_TO_ADDR
// for i := 1 to 5 do
2370: LD_ADDR_VAR 0 2
2374: PUSH
2375: DOUBLE
2376: LD_INT 1
2378: DEC
2379: ST_TO_ADDR
2380: LD_INT 5
2382: PUSH
2383: FOR_TO
2384: IFFALSE 2494
// begin PrepareVehicle ( ru_medium_wheeled , engine_combustion , control_manual , ru_cargo_bay , rand ( 60 , 80 ) ) ;
2386: LD_INT 21
2388: PPUSH
2389: LD_INT 1
2391: PPUSH
2392: LD_INT 1
2394: PPUSH
2395: LD_INT 51
2397: PPUSH
2398: LD_INT 60
2400: PPUSH
2401: LD_INT 80
2403: PPUSH
2404: CALL_OW 12
2408: PPUSH
2409: CALL 23974 0 5
// veh = CreateVehicle ;
2413: LD_ADDR_VAR 0 3
2417: PUSH
2418: CALL_OW 45
2422: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
2423: LD_VAR 0 3
2427: PPUSH
2428: LD_INT 4
2430: PPUSH
2431: CALL_OW 233
// PlaceUnitArea ( veh , RussianSpawnArea , false ) ;
2435: LD_VAR 0 3
2439: PPUSH
2440: LD_INT 2
2442: PPUSH
2443: LD_INT 0
2445: PPUSH
2446: CALL_OW 49
// if ( i <> 5 ) then
2450: LD_VAR 0 2
2454: PUSH
2455: LD_INT 5
2457: NONEQUAL
2458: IFFALSE 2477
// AddCargo ( veh , mat_cans , 100 ) else
2460: LD_VAR 0 3
2464: PPUSH
2465: LD_INT 1
2467: PPUSH
2468: LD_INT 100
2470: PPUSH
2471: CALL_OW 291
2475: GO 2492
// AddCargo ( veh , mat_oil , 100 ) ;
2477: LD_VAR 0 3
2481: PPUSH
2482: LD_INT 2
2484: PPUSH
2485: LD_INT 100
2487: PPUSH
2488: CALL_OW 291
// end ;
2492: GO 2383
2494: POP
2495: POP
// PrepareVehicle ( ru_medium_wheeled , engine_combustion , control_manual , ru_crane , rand ( 60 , 80 ) ) ;
2496: LD_INT 21
2498: PPUSH
2499: LD_INT 1
2501: PPUSH
2502: LD_INT 1
2504: PPUSH
2505: LD_INT 52
2507: PPUSH
2508: LD_INT 60
2510: PPUSH
2511: LD_INT 80
2513: PPUSH
2514: CALL_OW 12
2518: PPUSH
2519: CALL 23974 0 5
// veh = CreateVehicle ;
2523: LD_ADDR_VAR 0 3
2527: PUSH
2528: CALL_OW 45
2532: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
2533: LD_VAR 0 3
2537: PPUSH
2538: LD_INT 4
2540: PPUSH
2541: CALL_OW 233
// PlaceUnitArea ( veh , RussianSpawnArea , false ) ;
2545: LD_VAR 0 3
2549: PPUSH
2550: LD_INT 2
2552: PPUSH
2553: LD_INT 0
2555: PPUSH
2556: CALL_OW 49
// for i := 1 to 3 do
2560: LD_ADDR_VAR 0 2
2564: PUSH
2565: DOUBLE
2566: LD_INT 1
2568: DEC
2569: ST_TO_ADDR
2570: LD_INT 3
2572: PUSH
2573: FOR_TO
2574: IFFALSE 2642
// begin PrepareVehicle ( ru_heavy_tracked , engine_combustion , control_manual , ru_bulldozer , rand ( 60 , 80 ) ) ;
2576: LD_INT 24
2578: PPUSH
2579: LD_INT 1
2581: PPUSH
2582: LD_INT 1
2584: PPUSH
2585: LD_INT 53
2587: PPUSH
2588: LD_INT 60
2590: PPUSH
2591: LD_INT 80
2593: PPUSH
2594: CALL_OW 12
2598: PPUSH
2599: CALL 23974 0 5
// veh = CreateVehicle ;
2603: LD_ADDR_VAR 0 3
2607: PUSH
2608: CALL_OW 45
2612: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
2613: LD_VAR 0 3
2617: PPUSH
2618: LD_INT 4
2620: PPUSH
2621: CALL_OW 233
// PlaceUnitArea ( veh , RussianSpawnArea , false ) ;
2625: LD_VAR 0 3
2629: PPUSH
2630: LD_INT 2
2632: PPUSH
2633: LD_INT 0
2635: PPUSH
2636: CALL_OW 49
// end ;
2640: GO 2573
2642: POP
2643: POP
// end ;
2644: LD_VAR 0 1
2648: RET
// function InitRussianRequiments ; var i ; begin
2649: LD_INT 0
2651: PPUSH
2652: PPUSH
// availableWeapons = [ ru_heavy_machine_gun , ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher ] ;
2653: LD_ADDR_EXP 11
2657: PUSH
2658: LD_INT 42
2660: PUSH
2661: LD_INT 43
2663: PUSH
2664: LD_INT 44
2666: PUSH
2667: LD_INT 46
2669: PUSH
2670: LD_INT 45
2672: PUSH
2673: EMPTY
2674: LIST
2675: LIST
2676: LIST
2677: LIST
2678: LIST
2679: ST_TO_ADDR
// for i := 1 to availableWeapons do
2680: LD_ADDR_VAR 0 2
2684: PUSH
2685: DOUBLE
2686: LD_INT 1
2688: DEC
2689: ST_TO_ADDR
2690: LD_EXP 11
2694: PUSH
2695: FOR_TO
2696: IFFALSE 2736
// weaponsData = weaponsData ^ [ [ availableWeapons [ i ] , false , false ] ] ;
2698: LD_ADDR_EXP 12
2702: PUSH
2703: LD_EXP 12
2707: PUSH
2708: LD_EXP 11
2712: PUSH
2713: LD_VAR 0 2
2717: ARRAY
2718: PUSH
2719: LD_INT 0
2721: PUSH
2722: LD_INT 0
2724: PUSH
2725: EMPTY
2726: LIST
2727: LIST
2728: LIST
2729: PUSH
2730: EMPTY
2731: LIST
2732: ADD
2733: ST_TO_ADDR
2734: GO 2695
2736: POP
2737: POP
// for i := 0 to 50 do
2738: LD_ADDR_VAR 0 2
2742: PUSH
2743: DOUBLE
2744: LD_INT 0
2746: DEC
2747: ST_TO_ADDR
2748: LD_INT 50
2750: PUSH
2751: FOR_TO
2752: IFFALSE 2790
// if GetRestrict ( i , 3 ) = state_enabled then
2754: LD_VAR 0 2
2758: PPUSH
2759: LD_INT 3
2761: PPUSH
2762: CALL_OW 323
2766: PUSH
2767: LD_INT 1
2769: EQUAL
2770: IFFALSE 2788
// buildingsToBuild = buildingsToBuild ^ i ;
2772: LD_ADDR_EXP 8
2776: PUSH
2777: LD_EXP 8
2781: PUSH
2782: LD_VAR 0 2
2786: ADD
2787: ST_TO_ADDR
2788: GO 2751
2790: POP
2791: POP
// buildingsToBuild = buildingsToBuild diff [ 0 , 2 , 4 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 14 , 22 , 31 , 32 , 33 , 39 , 40 ] ;
2792: LD_ADDR_EXP 8
2796: PUSH
2797: LD_EXP 8
2801: PUSH
2802: LD_INT 0
2804: PUSH
2805: LD_INT 2
2807: PUSH
2808: LD_INT 4
2810: PUSH
2811: LD_INT 6
2813: PUSH
2814: LD_INT 7
2816: PUSH
2817: LD_INT 8
2819: PUSH
2820: LD_INT 9
2822: PUSH
2823: LD_INT 10
2825: PUSH
2826: LD_INT 11
2828: PUSH
2829: LD_INT 12
2831: PUSH
2832: LD_INT 14
2834: PUSH
2835: LD_INT 22
2837: PUSH
2838: LD_INT 31
2840: PUSH
2841: LD_INT 32
2843: PUSH
2844: LD_INT 33
2846: PUSH
2847: LD_INT 39
2849: PUSH
2850: LD_INT 40
2852: PUSH
2853: EMPTY
2854: LIST
2855: LIST
2856: LIST
2857: LIST
2858: LIST
2859: LIST
2860: LIST
2861: LIST
2862: LIST
2863: LIST
2864: LIST
2865: LIST
2866: LIST
2867: LIST
2868: LIST
2869: LIST
2870: LIST
2871: DIFF
2872: ST_TO_ADDR
// allBuildings = buildingsToBuild ;
2873: LD_ADDR_EXP 13
2877: PUSH
2878: LD_EXP 8
2882: ST_TO_ADDR
// techsToResearch = GetTechNation ( 3 , nation_russian , state_enabled ) ;
2883: LD_ADDR_EXP 9
2887: PUSH
2888: LD_INT 3
2890: PPUSH
2891: LD_INT 3
2893: PPUSH
2894: LD_INT 1
2896: PPUSH
2897: CALL 19213 0 3
2901: ST_TO_ADDR
// end ; end_of_file
2902: LD_VAR 0 1
2906: RET
// export amAttackTeam ; export function PrepareAmericans ; begin
2907: LD_INT 0
2909: PPUSH
// amAttackTeam = [ ] ;
2910: LD_ADDR_EXP 78
2914: PUSH
2915: EMPTY
2916: ST_TO_ADDR
// SpawnAmericansSnipers ;
2917: CALL 3045 0 0
// case Difficulty of 2 :
2921: LD_OWVAR 67
2925: PUSH
2926: LD_INT 2
2928: DOUBLE
2929: EQUAL
2930: IFTRUE 2934
2932: GO 2963
2934: POP
// begin SetTech ( tech_comp1 , 1 , state_researched ) ;
2935: LD_INT 57
2937: PPUSH
2938: LD_INT 1
2940: PPUSH
2941: LD_INT 2
2943: PPUSH
2944: CALL_OW 322
// SetTech ( tech_opto1 , 1 , state_researched ) ;
2948: LD_INT 60
2950: PPUSH
2951: LD_INT 1
2953: PPUSH
2954: LD_INT 2
2956: PPUSH
2957: CALL_OW 322
// end ; 3 :
2961: GO 3040
2963: LD_INT 3
2965: DOUBLE
2966: EQUAL
2967: IFTRUE 2971
2969: GO 3039
2971: POP
// begin SetTech ( tech_comp1 , 1 , state_researched ) ;
2972: LD_INT 57
2974: PPUSH
2975: LD_INT 1
2977: PPUSH
2978: LD_INT 2
2980: PPUSH
2981: CALL_OW 322
// SetTech ( tech_comp2 , 1 , state_researched ) ;
2985: LD_INT 58
2987: PPUSH
2988: LD_INT 1
2990: PPUSH
2991: LD_INT 2
2993: PPUSH
2994: CALL_OW 322
// SetTech ( tech_weap3 , 1 , state_researched ) ;
2998: LD_INT 53
3000: PPUSH
3001: LD_INT 1
3003: PPUSH
3004: LD_INT 2
3006: PPUSH
3007: CALL_OW 322
// SetTech ( tech_opto1 , 1 , state_researched ) ;
3011: LD_INT 60
3013: PPUSH
3014: LD_INT 1
3016: PPUSH
3017: LD_INT 2
3019: PPUSH
3020: CALL_OW 322
// SetTech ( tech_opto2 , 1 , state_researched ) ;
3024: LD_INT 61
3026: PPUSH
3027: LD_INT 1
3029: PPUSH
3030: LD_INT 2
3032: PPUSH
3033: CALL_OW 322
// end ; end ;
3037: GO 3040
3039: POP
// end ;
3040: LD_VAR 0 1
3044: RET
// export function SpawnAmericansSnipers ; var i , un ; begin
3045: LD_INT 0
3047: PPUSH
3048: PPUSH
3049: PPUSH
// uc_side = 1 ;
3050: LD_ADDR_OWVAR 20
3054: PUSH
3055: LD_INT 1
3057: ST_TO_ADDR
// uc_nation = 1 ;
3058: LD_ADDR_OWVAR 21
3062: PUSH
3063: LD_INT 1
3065: ST_TO_ADDR
// for i := 1 to 8 do
3066: LD_ADDR_VAR 0 2
3070: PUSH
3071: DOUBLE
3072: LD_INT 1
3074: DEC
3075: ST_TO_ADDR
3076: LD_INT 8
3078: PUSH
3079: FOR_TO
3080: IFFALSE 3133
// begin PrepareHuman ( false , class_sniper , enemySkillLevel ) ;
3082: LD_INT 0
3084: PPUSH
3085: LD_INT 5
3087: PPUSH
3088: LD_EXP 56
3092: PPUSH
3093: CALL_OW 380
// un = CreateHuman ;
3097: LD_ADDR_VAR 0 3
3101: PUSH
3102: CALL_OW 44
3106: ST_TO_ADDR
// PlaceUnitArea ( un , AmericansSnipersSpawnArea , false ) ;
3107: LD_VAR 0 3
3111: PPUSH
3112: LD_INT 14
3114: PPUSH
3115: LD_INT 0
3117: PPUSH
3118: CALL_OW 49
// ComHold ( un ) ;
3122: LD_VAR 0 3
3126: PPUSH
3127: CALL_OW 140
// end ;
3131: GO 3079
3133: POP
3134: POP
// end ;
3135: LD_VAR 0 1
3139: RET
// export function SpawnAmAttackTeam ; var i , unit , veh , randVehType , weapon , chassis , amSolds , amSnipers , amVehs ; begin
3140: LD_INT 0
3142: PPUSH
3143: PPUSH
3144: PPUSH
3145: PPUSH
3146: PPUSH
3147: PPUSH
3148: PPUSH
3149: PPUSH
3150: PPUSH
3151: PPUSH
// uc_side = 1 ;
3152: LD_ADDR_OWVAR 20
3156: PUSH
3157: LD_INT 1
3159: ST_TO_ADDR
// uc_nation = 1 ;
3160: LD_ADDR_OWVAR 21
3164: PUSH
3165: LD_INT 1
3167: ST_TO_ADDR
// amSolds = Rand ( enemyAttackUnitsData [ 1 ] [ 2 ] , enemyAttackUnitsData [ 1 ] [ 3 ] ) ;
3168: LD_ADDR_VAR 0 8
3172: PUSH
3173: LD_EXP 53
3177: PUSH
3178: LD_INT 1
3180: ARRAY
3181: PUSH
3182: LD_INT 2
3184: ARRAY
3185: PPUSH
3186: LD_EXP 53
3190: PUSH
3191: LD_INT 1
3193: ARRAY
3194: PUSH
3195: LD_INT 3
3197: ARRAY
3198: PPUSH
3199: CALL_OW 12
3203: ST_TO_ADDR
// amSnipers = Rand ( enemyAttackUnitsData [ 1 ] [ 4 ] , enemyAttackUnitsData [ 1 ] [ 5 ] ) ;
3204: LD_ADDR_VAR 0 9
3208: PUSH
3209: LD_EXP 53
3213: PUSH
3214: LD_INT 1
3216: ARRAY
3217: PUSH
3218: LD_INT 4
3220: ARRAY
3221: PPUSH
3222: LD_EXP 53
3226: PUSH
3227: LD_INT 1
3229: ARRAY
3230: PUSH
3231: LD_INT 5
3233: ARRAY
3234: PPUSH
3235: CALL_OW 12
3239: ST_TO_ADDR
// amVehs = Rand ( enemyAttackUnitsData [ 1 ] [ 6 ] , enemyAttackUnitsData [ 1 ] [ 7 ] ) ;
3240: LD_ADDR_VAR 0 10
3244: PUSH
3245: LD_EXP 53
3249: PUSH
3250: LD_INT 1
3252: ARRAY
3253: PUSH
3254: LD_INT 6
3256: ARRAY
3257: PPUSH
3258: LD_EXP 53
3262: PUSH
3263: LD_INT 1
3265: ARRAY
3266: PUSH
3267: LD_INT 7
3269: ARRAY
3270: PPUSH
3271: CALL_OW 12
3275: ST_TO_ADDR
// if paidLegionOffert then
3276: LD_EXP 32
3280: IFFALSE 3314
// begin amSolds = amSolds - legionReduceAmericansUnits ;
3282: LD_ADDR_VAR 0 8
3286: PUSH
3287: LD_VAR 0 8
3291: PUSH
3292: LD_EXP 51
3296: MINUS
3297: ST_TO_ADDR
// amVehs = amVehs - legionReduceAmericansUnits ;
3298: LD_ADDR_VAR 0 10
3302: PUSH
3303: LD_VAR 0 10
3307: PUSH
3308: LD_EXP 51
3312: MINUS
3313: ST_TO_ADDR
// end ; for i := 1 to amSolds do
3314: LD_ADDR_VAR 0 2
3318: PUSH
3319: DOUBLE
3320: LD_INT 1
3322: DEC
3323: ST_TO_ADDR
3324: LD_VAR 0 8
3328: PUSH
3329: FOR_TO
3330: IFFALSE 3387
// begin PrepareSoldier ( false , enemySkillLevel ) ;
3332: LD_INT 0
3334: PPUSH
3335: LD_EXP 56
3339: PPUSH
3340: CALL_OW 381
// unit = CreateHuman ;
3344: LD_ADDR_VAR 0 3
3348: PUSH
3349: CALL_OW 44
3353: ST_TO_ADDR
// PlaceUnitArea ( unit , AmericanSpawnArea , false ) ;
3354: LD_VAR 0 3
3358: PPUSH
3359: LD_INT 3
3361: PPUSH
3362: LD_INT 0
3364: PPUSH
3365: CALL_OW 49
// amAttackTeam = amAttackTeam ^ unit ;
3369: LD_ADDR_EXP 78
3373: PUSH
3374: LD_EXP 78
3378: PUSH
3379: LD_VAR 0 3
3383: ADD
3384: ST_TO_ADDR
// end ;
3385: GO 3329
3387: POP
3388: POP
// for i := 1 to amSnipers do
3389: LD_ADDR_VAR 0 2
3393: PUSH
3394: DOUBLE
3395: LD_INT 1
3397: DEC
3398: ST_TO_ADDR
3399: LD_VAR 0 9
3403: PUSH
3404: FOR_TO
3405: IFFALSE 3465
// begin PrepareHuman ( false , class_sniper , enemySkillLevel ) ;
3407: LD_INT 0
3409: PPUSH
3410: LD_INT 5
3412: PPUSH
3413: LD_EXP 56
3417: PPUSH
3418: CALL_OW 380
// unit = CreateHuman ;
3422: LD_ADDR_VAR 0 3
3426: PUSH
3427: CALL_OW 44
3431: ST_TO_ADDR
// PlaceUnitArea ( unit , AmericanSpawnArea , false ) ;
3432: LD_VAR 0 3
3436: PPUSH
3437: LD_INT 3
3439: PPUSH
3440: LD_INT 0
3442: PPUSH
3443: CALL_OW 49
// amAttackTeam = amAttackTeam ^ unit ;
3447: LD_ADDR_EXP 78
3451: PUSH
3452: LD_EXP 78
3456: PUSH
3457: LD_VAR 0 3
3461: ADD
3462: ST_TO_ADDR
// end ;
3463: GO 3404
3465: POP
3466: POP
// for i := 1 to amVehs do
3467: LD_ADDR_VAR 0 2
3471: PUSH
3472: DOUBLE
3473: LD_INT 1
3475: DEC
3476: ST_TO_ADDR
3477: LD_VAR 0 10
3481: PUSH
3482: FOR_TO
3483: IFFALSE 3766
// begin randVehType = Rand ( 1 , 4 ) ;
3485: LD_ADDR_VAR 0 5
3489: PUSH
3490: LD_INT 1
3492: PPUSH
3493: LD_INT 4
3495: PPUSH
3496: CALL_OW 12
3500: ST_TO_ADDR
// weapon = [ us_gatling_gun , us_double_gun , us_light_gun , us_rocket_launcher , us_heavy_gun ] [ Rand ( 1 , 5 ) ] ;
3501: LD_ADDR_VAR 0 6
3505: PUSH
3506: LD_INT 4
3508: PUSH
3509: LD_INT 5
3511: PUSH
3512: LD_INT 3
3514: PUSH
3515: LD_INT 7
3517: PUSH
3518: LD_INT 6
3520: PUSH
3521: EMPTY
3522: LIST
3523: LIST
3524: LIST
3525: LIST
3526: LIST
3527: PUSH
3528: LD_INT 1
3530: PPUSH
3531: LD_INT 5
3533: PPUSH
3534: CALL_OW 12
3538: ARRAY
3539: ST_TO_ADDR
// if weapon = us_heavy_gun then
3540: LD_VAR 0 6
3544: PUSH
3545: LD_INT 6
3547: EQUAL
3548: IFFALSE 3560
// chassis = us_heavy_tracked else
3550: LD_ADDR_VAR 0 7
3554: PUSH
3555: LD_INT 4
3557: ST_TO_ADDR
3558: GO 3587
// chassis = [ us_medium_tracked , us_heavy_tracked ] [ Rand ( 1 , 2 ) ] ;
3560: LD_ADDR_VAR 0 7
3564: PUSH
3565: LD_INT 3
3567: PUSH
3568: LD_INT 4
3570: PUSH
3571: EMPTY
3572: LIST
3573: LIST
3574: PUSH
3575: LD_INT 1
3577: PPUSH
3578: LD_INT 2
3580: PPUSH
3581: CALL_OW 12
3585: ARRAY
3586: ST_TO_ADDR
// if randVehType = 1 then
3587: LD_VAR 0 5
3591: PUSH
3592: LD_INT 1
3594: EQUAL
3595: IFFALSE 3630
// PrepareVehicle ( chassis , engine_combustion , control_manual , weapon , Rand ( 70 , 90 ) ) else
3597: LD_VAR 0 7
3601: PPUSH
3602: LD_INT 1
3604: PPUSH
3605: LD_INT 1
3607: PPUSH
3608: LD_VAR 0 6
3612: PPUSH
3613: LD_INT 70
3615: PPUSH
3616: LD_INT 90
3618: PPUSH
3619: CALL_OW 12
3623: PPUSH
3624: CALL 23974 0 5
3628: GO 3661
// PrepareVehicle ( chassis , engine_combustion , control_computer , weapon , Rand ( 70 , 90 ) ) ;
3630: LD_VAR 0 7
3634: PPUSH
3635: LD_INT 1
3637: PPUSH
3638: LD_INT 3
3640: PPUSH
3641: LD_VAR 0 6
3645: PPUSH
3646: LD_INT 70
3648: PPUSH
3649: LD_INT 90
3651: PPUSH
3652: CALL_OW 12
3656: PPUSH
3657: CALL 23974 0 5
// veh = CreateVehicle ;
3661: LD_ADDR_VAR 0 4
3665: PUSH
3666: CALL_OW 45
3670: ST_TO_ADDR
// PlaceUnitArea ( veh , AmericanSpawnArea , false ) ;
3671: LD_VAR 0 4
3675: PPUSH
3676: LD_INT 3
3678: PPUSH
3679: LD_INT 0
3681: PPUSH
3682: CALL_OW 49
// amAttackTeam = amAttackTeam ^ veh ;
3686: LD_ADDR_EXP 78
3690: PUSH
3691: LD_EXP 78
3695: PUSH
3696: LD_VAR 0 4
3700: ADD
3701: ST_TO_ADDR
// if randVehType = 1 then
3702: LD_VAR 0 5
3706: PUSH
3707: LD_INT 1
3709: EQUAL
3710: IFFALSE 3764
// begin PrepareMechanic ( false , enemySkillLevel ) ;
3712: LD_INT 0
3714: PPUSH
3715: LD_EXP 56
3719: PPUSH
3720: CALL_OW 383
// unit = CreateHuman ;
3724: LD_ADDR_VAR 0 3
3728: PUSH
3729: CALL_OW 44
3733: ST_TO_ADDR
// PlaceHumanInUnit ( unit , veh ) ;
3734: LD_VAR 0 3
3738: PPUSH
3739: LD_VAR 0 4
3743: PPUSH
3744: CALL_OW 52
// amAttackTeam = amAttackTeam ^ unit ;
3748: LD_ADDR_EXP 78
3752: PUSH
3753: LD_EXP 78
3757: PUSH
3758: LD_VAR 0 3
3762: ADD
3763: ST_TO_ADDR
// end ; end ;
3764: GO 3482
3766: POP
3767: POP
// end ; end_of_file
3768: LD_VAR 0 1
3772: RET
// export Heike , Kurt , Dietrich ; export KurtEng ; export GensherTeam ; export arAttackTeam ; export function PrepareArabians ; begin
3773: LD_INT 0
3775: PPUSH
// arAttackTeam = [ ] ;
3776: LD_ADDR_EXP 84
3780: PUSH
3781: EMPTY
3782: ST_TO_ADDR
// PrepareHeroes ;
3783: CALL 4188 0 0
// case Difficulty of 2 :
3787: LD_OWVAR 67
3791: PUSH
3792: LD_INT 2
3794: DOUBLE
3795: EQUAL
3796: IFTRUE 3800
3798: GO 3816
3800: POP
// begin SetTech ( tech_stimDrugs , 8 , state_researched ) ;
3801: LD_INT 5
3803: PPUSH
3804: LD_INT 8
3806: PPUSH
3807: LD_INT 2
3809: PPUSH
3810: CALL_OW 322
// end ; 3 :
3814: GO 3867
3816: LD_INT 3
3818: DOUBLE
3819: EQUAL
3820: IFTRUE 3824
3822: GO 3866
3824: POP
// begin SetTech ( tech_stimDrugs , 8 , state_researched ) ;
3825: LD_INT 5
3827: PPUSH
3828: LD_INT 8
3830: PPUSH
3831: LD_INT 2
3833: PPUSH
3834: CALL_OW 322
// SetTech ( tech_bio1 , 8 , state_researched ) ;
3838: LD_INT 66
3840: PPUSH
3841: LD_INT 8
3843: PPUSH
3844: LD_INT 2
3846: PPUSH
3847: CALL_OW 322
// SetTech ( tech_weap3 , 8 , state_researched ) ;
3851: LD_INT 53
3853: PPUSH
3854: LD_INT 8
3856: PPUSH
3857: LD_INT 2
3859: PPUSH
3860: CALL_OW 322
// end ; end ;
3864: GO 3867
3866: POP
// end ;
3867: LD_VAR 0 1
3871: RET
// export function SpawnGensherTeam ; var i , driver , veh ; begin
3872: LD_INT 0
3874: PPUSH
3875: PPUSH
3876: PPUSH
3877: PPUSH
// GensherTeam = [ ] ;
3878: LD_ADDR_EXP 83
3882: PUSH
3883: EMPTY
3884: ST_TO_ADDR
// uc_side = 2 ;
3885: LD_ADDR_OWVAR 20
3889: PUSH
3890: LD_INT 2
3892: ST_TO_ADDR
// uc_nation = 2 ;
3893: LD_ADDR_OWVAR 21
3897: PUSH
3898: LD_INT 2
3900: ST_TO_ADDR
// for i := 1 to 3 do
3901: LD_ADDR_VAR 0 2
3905: PUSH
3906: DOUBLE
3907: LD_INT 1
3909: DEC
3910: ST_TO_ADDR
3911: LD_INT 3
3913: PUSH
3914: FOR_TO
3915: IFFALSE 4074
// begin PrepareSoldier ( sex_male , rand ( 3 , 5 ) ) ;
3917: LD_INT 1
3919: PPUSH
3920: LD_INT 3
3922: PPUSH
3923: LD_INT 5
3925: PPUSH
3926: CALL_OW 12
3930: PPUSH
3931: CALL_OW 381
// driver = CreateHuman ;
3935: LD_ADDR_VAR 0 3
3939: PUSH
3940: CALL_OW 44
3944: ST_TO_ADDR
// PrepareVehicle ( ar_medium_trike , engine_combustion , control_manual , ar_cargo_bay , rand ( 50 , 70 ) ) ;
3945: LD_INT 13
3947: PPUSH
3948: LD_INT 1
3950: PPUSH
3951: LD_INT 1
3953: PPUSH
3954: LD_INT 32
3956: PPUSH
3957: LD_INT 50
3959: PPUSH
3960: LD_INT 70
3962: PPUSH
3963: CALL_OW 12
3967: PPUSH
3968: CALL 23974 0 5
// veh = CreateVehicle ;
3972: LD_ADDR_VAR 0 4
3976: PUSH
3977: CALL_OW 45
3981: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
3982: LD_VAR 0 4
3986: PPUSH
3987: LD_INT 4
3989: PPUSH
3990: CALL_OW 233
// PlaceUnitArea ( veh , GensherSpawnArea , false ) ;
3994: LD_VAR 0 4
3998: PPUSH
3999: LD_INT 4
4001: PPUSH
4002: LD_INT 0
4004: PPUSH
4005: CALL_OW 49
// PlaceHumanInUnit ( driver , veh ) ;
4009: LD_VAR 0 3
4013: PPUSH
4014: LD_VAR 0 4
4018: PPUSH
4019: CALL_OW 52
// AddCargo ( veh , i , 100 ) ;
4023: LD_VAR 0 4
4027: PPUSH
4028: LD_VAR 0 2
4032: PPUSH
4033: LD_INT 100
4035: PPUSH
4036: CALL_OW 291
// GensherTeam = GensherTeam ^ driver ;
4040: LD_ADDR_EXP 83
4044: PUSH
4045: LD_EXP 83
4049: PUSH
4050: LD_VAR 0 3
4054: ADD
4055: ST_TO_ADDR
// GensherTeam = GensherTeam ^ veh ;
4056: LD_ADDR_EXP 83
4060: PUSH
4061: LD_EXP 83
4065: PUSH
4066: LD_VAR 0 4
4070: ADD
4071: ST_TO_ADDR
// end ;
4072: GO 3914
4074: POP
4075: POP
// if IsOK ( KurtEng ) and GetSide ( KurtEng ) = 3 then
4076: LD_EXP 82
4080: PPUSH
4081: CALL_OW 302
4085: PUSH
4086: LD_EXP 82
4090: PPUSH
4091: CALL_OW 255
4095: PUSH
4096: LD_INT 3
4098: EQUAL
4099: AND
4100: IFFALSE 4134
// begin GensherTargetX = GetX ( Kurt ) ;
4102: LD_ADDR_EXP 16
4106: PUSH
4107: LD_EXP 80
4111: PPUSH
4112: CALL_OW 250
4116: ST_TO_ADDR
// GensherTargetY = GetY ( Kurt ) ;
4117: LD_ADDR_EXP 17
4121: PUSH
4122: LD_EXP 80
4126: PPUSH
4127: CALL_OW 251
4131: ST_TO_ADDR
// end else
4132: GO 4164
// begin GensherTargetX = GetX ( Burlak ) ;
4134: LD_ADDR_EXP 16
4138: PUSH
4139: LD_EXP 57
4143: PPUSH
4144: CALL_OW 250
4148: ST_TO_ADDR
// GensherTargetY = GetY ( Burlak ) ;
4149: LD_ADDR_EXP 17
4153: PUSH
4154: LD_EXP 57
4158: PPUSH
4159: CALL_OW 251
4163: ST_TO_ADDR
// end ; ComMoveXY ( GensherTeam , GensherTargetX , GensherTargetY ) ;
4164: LD_EXP 83
4168: PPUSH
4169: LD_EXP 16
4173: PPUSH
4174: LD_EXP 17
4178: PPUSH
4179: CALL_OW 111
// end ;
4183: LD_VAR 0 1
4187: RET
// function PrepareHeroes ; begin
4188: LD_INT 0
4190: PPUSH
// uc_side = 5 ;
4191: LD_ADDR_OWVAR 20
4195: PUSH
4196: LD_INT 5
4198: ST_TO_ADDR
// uc_nation = 2 ;
4199: LD_ADDR_OWVAR 21
4203: PUSH
4204: LD_INT 2
4206: ST_TO_ADDR
// Heike = PrepareUnitExt ( Heike , true , class_engineer ) ;
4207: LD_ADDR_EXP 79
4211: PUSH
4212: LD_STRING Heike
4214: PPUSH
4215: LD_INT 1
4217: PPUSH
4218: LD_INT 2
4220: PPUSH
4221: CALL 5856 0 3
4225: ST_TO_ADDR
// uc_side = 8 ;
4226: LD_ADDR_OWVAR 20
4230: PUSH
4231: LD_INT 8
4233: ST_TO_ADDR
// Kurt = PrepareUnitExt ( Kurt , false , 0 ) ;
4234: LD_ADDR_EXP 80
4238: PUSH
4239: LD_STRING Kurt
4241: PPUSH
4242: LD_INT 0
4244: PPUSH
4245: LD_INT 0
4247: PPUSH
4248: CALL 5856 0 3
4252: ST_TO_ADDR
// uc_side = 2 ;
4253: LD_ADDR_OWVAR 20
4257: PUSH
4258: LD_INT 2
4260: ST_TO_ADDR
// Dietrich = PrepareUnitExt ( Dietrich , false , 0 ) ;
4261: LD_ADDR_EXP 81
4265: PUSH
4266: LD_STRING Dietrich
4268: PPUSH
4269: LD_INT 0
4271: PPUSH
4272: LD_INT 0
4274: PPUSH
4275: CALL 5856 0 3
4279: ST_TO_ADDR
// end ;
4280: LD_VAR 0 1
4284: RET
// export function SpawnArAttackTeam ; var i , unit , veh , weapon , chassis ; begin
4285: LD_INT 0
4287: PPUSH
4288: PPUSH
4289: PPUSH
4290: PPUSH
4291: PPUSH
4292: PPUSH
// uc_side = 8 ;
4293: LD_ADDR_OWVAR 20
4297: PUSH
4298: LD_INT 8
4300: ST_TO_ADDR
// uc_nation = 2 ;
4301: LD_ADDR_OWVAR 21
4305: PUSH
4306: LD_INT 2
4308: ST_TO_ADDR
// for i := 1 to Rand ( enemyAttackUnitsData [ 1 ] [ 2 ] , enemyAttackUnitsData [ 1 ] [ 3 ] ) do
4309: LD_ADDR_VAR 0 2
4313: PUSH
4314: DOUBLE
4315: LD_INT 1
4317: DEC
4318: ST_TO_ADDR
4319: LD_EXP 53
4323: PUSH
4324: LD_INT 1
4326: ARRAY
4327: PUSH
4328: LD_INT 2
4330: ARRAY
4331: PPUSH
4332: LD_EXP 53
4336: PUSH
4337: LD_INT 1
4339: ARRAY
4340: PUSH
4341: LD_INT 3
4343: ARRAY
4344: PPUSH
4345: CALL_OW 12
4349: PUSH
4350: FOR_TO
4351: IFFALSE 4408
// begin PrepareSoldier ( false , enemySkillLevel ) ;
4353: LD_INT 0
4355: PPUSH
4356: LD_EXP 56
4360: PPUSH
4361: CALL_OW 381
// unit = CreateHuman ;
4365: LD_ADDR_VAR 0 3
4369: PUSH
4370: CALL_OW 44
4374: ST_TO_ADDR
// PlaceUnitArea ( unit , KurtUnitsSpawnArea , false ) ;
4375: LD_VAR 0 3
4379: PPUSH
4380: LD_INT 10
4382: PPUSH
4383: LD_INT 0
4385: PPUSH
4386: CALL_OW 49
// arAttackTeam = arAttackTeam ^ unit ;
4390: LD_ADDR_EXP 84
4394: PUSH
4395: LD_EXP 84
4399: PUSH
4400: LD_VAR 0 3
4404: ADD
4405: ST_TO_ADDR
// end ;
4406: GO 4350
4408: POP
4409: POP
// for i := 1 to Rand ( enemyAttackUnitsData [ 1 ] [ 4 ] , enemyAttackUnitsData [ 1 ] [ 5 ] ) do
4410: LD_ADDR_VAR 0 2
4414: PUSH
4415: DOUBLE
4416: LD_INT 1
4418: DEC
4419: ST_TO_ADDR
4420: LD_EXP 53
4424: PUSH
4425: LD_INT 1
4427: ARRAY
4428: PUSH
4429: LD_INT 4
4431: ARRAY
4432: PPUSH
4433: LD_EXP 53
4437: PUSH
4438: LD_INT 1
4440: ARRAY
4441: PUSH
4442: LD_INT 5
4444: ARRAY
4445: PPUSH
4446: CALL_OW 12
4450: PUSH
4451: FOR_TO
4452: IFFALSE 4512
// begin PrepareHuman ( false , class_mortar , enemySkillLevel ) ;
4454: LD_INT 0
4456: PPUSH
4457: LD_INT 8
4459: PPUSH
4460: LD_EXP 56
4464: PPUSH
4465: CALL_OW 380
// unit = CreateHuman ;
4469: LD_ADDR_VAR 0 3
4473: PUSH
4474: CALL_OW 44
4478: ST_TO_ADDR
// PlaceUnitArea ( unit , KurtUnitsSpawnArea , false ) ;
4479: LD_VAR 0 3
4483: PPUSH
4484: LD_INT 10
4486: PPUSH
4487: LD_INT 0
4489: PPUSH
4490: CALL_OW 49
// arAttackTeam = arAttackTeam ^ unit ;
4494: LD_ADDR_EXP 84
4498: PUSH
4499: LD_EXP 84
4503: PUSH
4504: LD_VAR 0 3
4508: ADD
4509: ST_TO_ADDR
// end ;
4510: GO 4451
4512: POP
4513: POP
// for i := 1 to Rand ( enemyAttackUnitsData [ 1 ] [ 6 ] , enemyAttackUnitsData [ 1 ] [ 7 ] ) do
4514: LD_ADDR_VAR 0 2
4518: PUSH
4519: DOUBLE
4520: LD_INT 1
4522: DEC
4523: ST_TO_ADDR
4524: LD_EXP 53
4528: PUSH
4529: LD_INT 1
4531: ARRAY
4532: PUSH
4533: LD_INT 6
4535: ARRAY
4536: PPUSH
4537: LD_EXP 53
4541: PUSH
4542: LD_INT 1
4544: ARRAY
4545: PUSH
4546: LD_INT 7
4548: ARRAY
4549: PPUSH
4550: CALL_OW 12
4554: PUSH
4555: FOR_TO
4556: IFFALSE 4750
// begin weapon = [ ar_gun , ar_flame_thrower , ar_rocket_launcher , ar_light_gun , ar_gatling_gun ] [ Rand ( 1 , 5 ) ] ;
4558: LD_ADDR_VAR 0 5
4562: PUSH
4563: LD_INT 27
4565: PUSH
4566: LD_INT 26
4568: PUSH
4569: LD_INT 28
4571: PUSH
4572: LD_INT 23
4574: PUSH
4575: LD_INT 25
4577: PUSH
4578: EMPTY
4579: LIST
4580: LIST
4581: LIST
4582: LIST
4583: LIST
4584: PUSH
4585: LD_INT 1
4587: PPUSH
4588: LD_INT 5
4590: PPUSH
4591: CALL_OW 12
4595: ARRAY
4596: ST_TO_ADDR
// chassis = [ ar_medium_trike , ar_half_tracked ] [ Rand ( 1 , 2 ) ] ;
4597: LD_ADDR_VAR 0 6
4601: PUSH
4602: LD_INT 13
4604: PUSH
4605: LD_INT 14
4607: PUSH
4608: EMPTY
4609: LIST
4610: LIST
4611: PUSH
4612: LD_INT 1
4614: PPUSH
4615: LD_INT 2
4617: PPUSH
4618: CALL_OW 12
4622: ARRAY
4623: ST_TO_ADDR
// PrepareVehicle ( chassis , engine_combustion , control_manual , weapon , Rand ( 70 , 90 ) ) ;
4624: LD_VAR 0 6
4628: PPUSH
4629: LD_INT 1
4631: PPUSH
4632: LD_INT 1
4634: PPUSH
4635: LD_VAR 0 5
4639: PPUSH
4640: LD_INT 70
4642: PPUSH
4643: LD_INT 90
4645: PPUSH
4646: CALL_OW 12
4650: PPUSH
4651: CALL 23974 0 5
// veh = CreateVehicle ;
4655: LD_ADDR_VAR 0 4
4659: PUSH
4660: CALL_OW 45
4664: ST_TO_ADDR
// PlaceUnitArea ( veh , KurtUnitsSpawnArea , false ) ;
4665: LD_VAR 0 4
4669: PPUSH
4670: LD_INT 10
4672: PPUSH
4673: LD_INT 0
4675: PPUSH
4676: CALL_OW 49
// arAttackTeam = arAttackTeam ^ veh ;
4680: LD_ADDR_EXP 84
4684: PUSH
4685: LD_EXP 84
4689: PUSH
4690: LD_VAR 0 4
4694: ADD
4695: ST_TO_ADDR
// PrepareMechanic ( false , enemySkillLevel ) ;
4696: LD_INT 0
4698: PPUSH
4699: LD_EXP 56
4703: PPUSH
4704: CALL_OW 383
// unit = CreateHuman ;
4708: LD_ADDR_VAR 0 3
4712: PUSH
4713: CALL_OW 44
4717: ST_TO_ADDR
// PlaceHumanInUnit ( unit , veh ) ;
4718: LD_VAR 0 3
4722: PPUSH
4723: LD_VAR 0 4
4727: PPUSH
4728: CALL_OW 52
// arAttackTeam = arAttackTeam ^ unit ;
4732: LD_ADDR_EXP 84
4736: PUSH
4737: LD_EXP 84
4741: PUSH
4742: LD_VAR 0 3
4746: ADD
4747: ST_TO_ADDR
// end ;
4748: GO 4555
4750: POP
4751: POP
// end ; end_of_file
4752: LD_VAR 0 1
4756: RET
// export function Nef_PrepareNature ; var i , un ; begin
4757: LD_INT 0
4759: PPUSH
4760: PPUSH
4761: PPUSH
// for i := 1 to animalsAmount [ 1 ] do
4762: LD_ADDR_VAR 0 2
4766: PUSH
4767: DOUBLE
4768: LD_INT 1
4770: DEC
4771: ST_TO_ADDR
4772: LD_EXP 41
4776: PUSH
4777: LD_INT 1
4779: ARRAY
4780: PUSH
4781: FOR_TO
4782: IFFALSE 4892
// begin uc_side = 0 ;
4784: LD_ADDR_OWVAR 20
4788: PUSH
4789: LD_INT 0
4791: ST_TO_ADDR
// uc_nation = nation_nature ;
4792: LD_ADDR_OWVAR 21
4796: PUSH
4797: LD_INT 0
4799: ST_TO_ADDR
// hc_class = class_apeman ;
4800: LD_ADDR_OWVAR 28
4804: PUSH
4805: LD_INT 12
4807: ST_TO_ADDR
// hc_skills = [ animalsStats [ 1 ] , animalsStats [ 2 ] , animalsStats [ 3 ] , animalsStats [ 4 ] ] ;
4808: LD_ADDR_OWVAR 31
4812: PUSH
4813: LD_EXP 42
4817: PUSH
4818: LD_INT 1
4820: ARRAY
4821: PUSH
4822: LD_EXP 42
4826: PUSH
4827: LD_INT 2
4829: ARRAY
4830: PUSH
4831: LD_EXP 42
4835: PUSH
4836: LD_INT 3
4838: ARRAY
4839: PUSH
4840: LD_EXP 42
4844: PUSH
4845: LD_INT 4
4847: ARRAY
4848: PUSH
4849: EMPTY
4850: LIST
4851: LIST
4852: LIST
4853: LIST
4854: ST_TO_ADDR
// hc_agressivity = animalsAgression ;
4855: LD_ADDR_OWVAR 35
4859: PUSH
4860: LD_EXP 43
4864: ST_TO_ADDR
// un = CreateHuman ;
4865: LD_ADDR_VAR 0 3
4869: PUSH
4870: CALL_OW 44
4874: ST_TO_ADDR
// PlaceUnitArea ( un , NatureArea , false ) ;
4875: LD_VAR 0 3
4879: PPUSH
4880: LD_INT 5
4882: PPUSH
4883: LD_INT 0
4885: PPUSH
4886: CALL_OW 49
// end ;
4890: GO 4781
4892: POP
4893: POP
// for i := 1 to animalsAmount [ 2 ] do
4894: LD_ADDR_VAR 0 2
4898: PUSH
4899: DOUBLE
4900: LD_INT 1
4902: DEC
4903: ST_TO_ADDR
4904: LD_EXP 41
4908: PUSH
4909: LD_INT 2
4911: ARRAY
4912: PUSH
4913: FOR_TO
4914: IFFALSE 5024
// begin uc_side = 0 ;
4916: LD_ADDR_OWVAR 20
4920: PUSH
4921: LD_INT 0
4923: ST_TO_ADDR
// uc_nation = nation_nature ;
4924: LD_ADDR_OWVAR 21
4928: PUSH
4929: LD_INT 0
4931: ST_TO_ADDR
// hc_class = class_phororhacos ;
4932: LD_ADDR_OWVAR 28
4936: PUSH
4937: LD_INT 18
4939: ST_TO_ADDR
// hc_skills = [ animalsStats [ 1 ] , animalsStats [ 2 ] , animalsStats [ 3 ] , animalsStats [ 4 ] ] ;
4940: LD_ADDR_OWVAR 31
4944: PUSH
4945: LD_EXP 42
4949: PUSH
4950: LD_INT 1
4952: ARRAY
4953: PUSH
4954: LD_EXP 42
4958: PUSH
4959: LD_INT 2
4961: ARRAY
4962: PUSH
4963: LD_EXP 42
4967: PUSH
4968: LD_INT 3
4970: ARRAY
4971: PUSH
4972: LD_EXP 42
4976: PUSH
4977: LD_INT 4
4979: ARRAY
4980: PUSH
4981: EMPTY
4982: LIST
4983: LIST
4984: LIST
4985: LIST
4986: ST_TO_ADDR
// hc_agressivity = animalsAgression ;
4987: LD_ADDR_OWVAR 35
4991: PUSH
4992: LD_EXP 43
4996: ST_TO_ADDR
// un = CreateHuman ;
4997: LD_ADDR_VAR 0 3
5001: PUSH
5002: CALL_OW 44
5006: ST_TO_ADDR
// PlaceUnitArea ( un , NatureArea , false ) ;
5007: LD_VAR 0 3
5011: PPUSH
5012: LD_INT 5
5014: PPUSH
5015: LD_INT 0
5017: PPUSH
5018: CALL_OW 49
// end ;
5022: GO 4913
5024: POP
5025: POP
// for i := 1 to animalsAmount [ 3 ] do
5026: LD_ADDR_VAR 0 2
5030: PUSH
5031: DOUBLE
5032: LD_INT 1
5034: DEC
5035: ST_TO_ADDR
5036: LD_EXP 41
5040: PUSH
5041: LD_INT 3
5043: ARRAY
5044: PUSH
5045: FOR_TO
5046: IFFALSE 5156
// begin uc_side = 0 ;
5048: LD_ADDR_OWVAR 20
5052: PUSH
5053: LD_INT 0
5055: ST_TO_ADDR
// uc_nation = nation_nature ;
5056: LD_ADDR_OWVAR 21
5060: PUSH
5061: LD_INT 0
5063: ST_TO_ADDR
// hc_class = class_tiger ;
5064: LD_ADDR_OWVAR 28
5068: PUSH
5069: LD_INT 14
5071: ST_TO_ADDR
// hc_skills = [ animalsStats [ 1 ] , animalsStats [ 2 ] , animalsStats [ 3 ] , animalsStats [ 4 ] ] ;
5072: LD_ADDR_OWVAR 31
5076: PUSH
5077: LD_EXP 42
5081: PUSH
5082: LD_INT 1
5084: ARRAY
5085: PUSH
5086: LD_EXP 42
5090: PUSH
5091: LD_INT 2
5093: ARRAY
5094: PUSH
5095: LD_EXP 42
5099: PUSH
5100: LD_INT 3
5102: ARRAY
5103: PUSH
5104: LD_EXP 42
5108: PUSH
5109: LD_INT 4
5111: ARRAY
5112: PUSH
5113: EMPTY
5114: LIST
5115: LIST
5116: LIST
5117: LIST
5118: ST_TO_ADDR
// hc_agressivity = animalsAgression ;
5119: LD_ADDR_OWVAR 35
5123: PUSH
5124: LD_EXP 43
5128: ST_TO_ADDR
// un = CreateHuman ;
5129: LD_ADDR_VAR 0 3
5133: PUSH
5134: CALL_OW 44
5138: ST_TO_ADDR
// PlaceUnitArea ( un , NatureArea , false ) ;
5139: LD_VAR 0 3
5143: PPUSH
5144: LD_INT 5
5146: PPUSH
5147: LD_INT 0
5149: PPUSH
5150: CALL_OW 49
// end ;
5154: GO 5045
5156: POP
5157: POP
// for i := 1 to animalsAmount [ 4 ] do
5158: LD_ADDR_VAR 0 2
5162: PUSH
5163: DOUBLE
5164: LD_INT 1
5166: DEC
5167: ST_TO_ADDR
5168: LD_EXP 41
5172: PUSH
5173: LD_INT 4
5175: ARRAY
5176: PUSH
5177: FOR_TO
5178: IFFALSE 5288
// begin uc_side = 0 ;
5180: LD_ADDR_OWVAR 20
5184: PUSH
5185: LD_INT 0
5187: ST_TO_ADDR
// uc_nation = nation_nature ;
5188: LD_ADDR_OWVAR 21
5192: PUSH
5193: LD_INT 0
5195: ST_TO_ADDR
// hc_class = 21 ;
5196: LD_ADDR_OWVAR 28
5200: PUSH
5201: LD_INT 21
5203: ST_TO_ADDR
// hc_skills = [ animalsStats [ 1 ] , animalsStats [ 2 ] , animalsStats [ 3 ] , animalsStats [ 4 ] ] ;
5204: LD_ADDR_OWVAR 31
5208: PUSH
5209: LD_EXP 42
5213: PUSH
5214: LD_INT 1
5216: ARRAY
5217: PUSH
5218: LD_EXP 42
5222: PUSH
5223: LD_INT 2
5225: ARRAY
5226: PUSH
5227: LD_EXP 42
5231: PUSH
5232: LD_INT 3
5234: ARRAY
5235: PUSH
5236: LD_EXP 42
5240: PUSH
5241: LD_INT 4
5243: ARRAY
5244: PUSH
5245: EMPTY
5246: LIST
5247: LIST
5248: LIST
5249: LIST
5250: ST_TO_ADDR
// hc_agressivity = animalsAgression ;
5251: LD_ADDR_OWVAR 35
5255: PUSH
5256: LD_EXP 43
5260: ST_TO_ADDR
// un = CreateHuman ;
5261: LD_ADDR_VAR 0 3
5265: PUSH
5266: CALL_OW 44
5270: ST_TO_ADDR
// PlaceUnitArea ( un , NatureArea , false ) ;
5271: LD_VAR 0 3
5275: PPUSH
5276: LD_INT 5
5278: PPUSH
5279: LD_INT 0
5281: PPUSH
5282: CALL_OW 49
// end ;
5286: GO 5177
5288: POP
5289: POP
// for i := 1 to animalsAmount [ 5 ] do
5290: LD_ADDR_VAR 0 2
5294: PUSH
5295: DOUBLE
5296: LD_INT 1
5298: DEC
5299: ST_TO_ADDR
5300: LD_EXP 41
5304: PUSH
5305: LD_INT 5
5307: ARRAY
5308: PUSH
5309: FOR_TO
5310: IFFALSE 5371
// begin uc_side = 0 ;
5312: LD_ADDR_OWVAR 20
5316: PUSH
5317: LD_INT 0
5319: ST_TO_ADDR
// uc_nation = nation_nature ;
5320: LD_ADDR_OWVAR 21
5324: PUSH
5325: LD_INT 0
5327: ST_TO_ADDR
// vc_chassis := 31 ;
5328: LD_ADDR_OWVAR 37
5332: PUSH
5333: LD_INT 31
5335: ST_TO_ADDR
// vc_control := control_rider ;
5336: LD_ADDR_OWVAR 38
5340: PUSH
5341: LD_INT 4
5343: ST_TO_ADDR
// un := CreateVehicle ;
5344: LD_ADDR_VAR 0 3
5348: PUSH
5349: CALL_OW 45
5353: ST_TO_ADDR
// PlaceUnitArea ( un , NatureArea , false ) ;
5354: LD_VAR 0 3
5358: PPUSH
5359: LD_INT 5
5361: PPUSH
5362: LD_INT 0
5364: PPUSH
5365: CALL_OW 49
// end ;
5369: GO 5309
5371: POP
5372: POP
// end ;
5373: LD_VAR 0 1
5377: RET
// export function SpawnTrees ; begin
5378: LD_INT 0
5380: PPUSH
// PlaceTreesToArea ( TreeArea , [ 2 , 10 , 11 , 27 , 35 ] , 40 , 10 , 4 ) ;
5381: LD_INT 1
5383: PPUSH
5384: LD_INT 2
5386: PUSH
5387: LD_INT 10
5389: PUSH
5390: LD_INT 11
5392: PUSH
5393: LD_INT 27
5395: PUSH
5396: LD_INT 35
5398: PUSH
5399: EMPTY
5400: LIST
5401: LIST
5402: LIST
5403: LIST
5404: LIST
5405: PPUSH
5406: LD_INT 40
5408: PPUSH
5409: LD_INT 10
5411: PPUSH
5412: LD_INT 4
5414: PPUSH
5415: CALL_OW 352
// PlaceTreesToArea ( TreeArea , [ 9 , 10 , 27 , 35 , 48 ] , 30 , 10 , 4 ) ;
5419: LD_INT 1
5421: PPUSH
5422: LD_INT 9
5424: PUSH
5425: LD_INT 10
5427: PUSH
5428: LD_INT 27
5430: PUSH
5431: LD_INT 35
5433: PUSH
5434: LD_INT 48
5436: PUSH
5437: EMPTY
5438: LIST
5439: LIST
5440: LIST
5441: LIST
5442: LIST
5443: PPUSH
5444: LD_INT 30
5446: PPUSH
5447: LD_INT 10
5449: PPUSH
5450: LD_INT 4
5452: PPUSH
5453: CALL_OW 352
// PlaceTreesToArea ( TreeArea , [ 2 , 9 , 10 , 11 , 27 ] , 60 , 10 , 4 ) ;
5457: LD_INT 1
5459: PPUSH
5460: LD_INT 2
5462: PUSH
5463: LD_INT 9
5465: PUSH
5466: LD_INT 10
5468: PUSH
5469: LD_INT 11
5471: PUSH
5472: LD_INT 27
5474: PUSH
5475: EMPTY
5476: LIST
5477: LIST
5478: LIST
5479: LIST
5480: LIST
5481: PPUSH
5482: LD_INT 60
5484: PPUSH
5485: LD_INT 10
5487: PPUSH
5488: LD_INT 4
5490: PPUSH
5491: CALL_OW 352
// PlaceTreesToArea ( TreeArea , [ 9 , 10 , 27 , 35 , 48 ] , 90 , 10 , 4 ) ;
5495: LD_INT 1
5497: PPUSH
5498: LD_INT 9
5500: PUSH
5501: LD_INT 10
5503: PUSH
5504: LD_INT 27
5506: PUSH
5507: LD_INT 35
5509: PUSH
5510: LD_INT 48
5512: PUSH
5513: EMPTY
5514: LIST
5515: LIST
5516: LIST
5517: LIST
5518: LIST
5519: PPUSH
5520: LD_INT 90
5522: PPUSH
5523: LD_INT 10
5525: PPUSH
5526: LD_INT 4
5528: PPUSH
5529: CALL_OW 352
// PlaceTreesToArea ( TreeArea , [ 2 , 9 , 10 , 11 , 48 ] , 120 , 10 , 4 ) ;
5533: LD_INT 1
5535: PPUSH
5536: LD_INT 2
5538: PUSH
5539: LD_INT 9
5541: PUSH
5542: LD_INT 10
5544: PUSH
5545: LD_INT 11
5547: PUSH
5548: LD_INT 48
5550: PUSH
5551: EMPTY
5552: LIST
5553: LIST
5554: LIST
5555: LIST
5556: LIST
5557: PPUSH
5558: LD_INT 120
5560: PPUSH
5561: LD_INT 10
5563: PPUSH
5564: LD_INT 4
5566: PPUSH
5567: CALL_OW 352
// PlaceTreesToArea ( TreeArea , [ 2 , 11 , 27 , 35 , 48 ] , 45 , 10 , 4 ) ;
5571: LD_INT 1
5573: PPUSH
5574: LD_INT 2
5576: PUSH
5577: LD_INT 11
5579: PUSH
5580: LD_INT 27
5582: PUSH
5583: LD_INT 35
5585: PUSH
5586: LD_INT 48
5588: PUSH
5589: EMPTY
5590: LIST
5591: LIST
5592: LIST
5593: LIST
5594: LIST
5595: PPUSH
5596: LD_INT 45
5598: PPUSH
5599: LD_INT 10
5601: PPUSH
5602: LD_INT 4
5604: PPUSH
5605: CALL_OW 352
// end ;
5609: LD_VAR 0 1
5613: RET
// every 0 0$1 do var i , un ;
5614: GO 5616
5616: DISABLE
5617: LD_INT 0
5619: PPUSH
5620: PPUSH
// begin if ( GetTech ( tech_apelang , 3 ) = state_enabled or GetTech ( tech_apepsych , 3 ) = state_enabled or GetTech ( tech_apeagres , 3 ) = state_enabled ) and not FilterAllUnits ( [ [ f_or , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman_soldier ] ] ] ) then
5621: LD_INT 1
5623: PPUSH
5624: LD_INT 3
5626: PPUSH
5627: CALL_OW 321
5631: PUSH
5632: LD_INT 1
5634: EQUAL
5635: PUSH
5636: LD_INT 2
5638: PPUSH
5639: LD_INT 3
5641: PPUSH
5642: CALL_OW 321
5646: PUSH
5647: LD_INT 1
5649: EQUAL
5650: OR
5651: PUSH
5652: LD_INT 11
5654: PPUSH
5655: LD_INT 3
5657: PPUSH
5658: CALL_OW 321
5662: PUSH
5663: LD_INT 1
5665: EQUAL
5666: OR
5667: PUSH
5668: LD_INT 2
5670: PUSH
5671: LD_INT 25
5673: PUSH
5674: LD_INT 12
5676: PUSH
5677: EMPTY
5678: LIST
5679: LIST
5680: PUSH
5681: LD_INT 25
5683: PUSH
5684: LD_INT 16
5686: PUSH
5687: EMPTY
5688: LIST
5689: LIST
5690: PUSH
5691: LD_INT 25
5693: PUSH
5694: LD_INT 15
5696: PUSH
5697: EMPTY
5698: LIST
5699: LIST
5700: PUSH
5701: EMPTY
5702: LIST
5703: LIST
5704: LIST
5705: LIST
5706: PUSH
5707: EMPTY
5708: LIST
5709: PPUSH
5710: CALL_OW 69
5714: NOT
5715: AND
5716: IFFALSE 5852
// begin for i := 1 to Rand ( 2 , 4 ) do
5718: LD_ADDR_VAR 0 1
5722: PUSH
5723: DOUBLE
5724: LD_INT 1
5726: DEC
5727: ST_TO_ADDR
5728: LD_INT 2
5730: PPUSH
5731: LD_INT 4
5733: PPUSH
5734: CALL_OW 12
5738: PUSH
5739: FOR_TO
5740: IFFALSE 5850
// begin uc_side = 0 ;
5742: LD_ADDR_OWVAR 20
5746: PUSH
5747: LD_INT 0
5749: ST_TO_ADDR
// uc_nation = nation_nature ;
5750: LD_ADDR_OWVAR 21
5754: PUSH
5755: LD_INT 0
5757: ST_TO_ADDR
// hc_class = class_apeman ;
5758: LD_ADDR_OWVAR 28
5762: PUSH
5763: LD_INT 12
5765: ST_TO_ADDR
// hc_skills = [ animalsStats [ 1 ] , animalsStats [ 2 ] , animalsStats [ 3 ] , animalsStats [ 4 ] ] ;
5766: LD_ADDR_OWVAR 31
5770: PUSH
5771: LD_EXP 42
5775: PUSH
5776: LD_INT 1
5778: ARRAY
5779: PUSH
5780: LD_EXP 42
5784: PUSH
5785: LD_INT 2
5787: ARRAY
5788: PUSH
5789: LD_EXP 42
5793: PUSH
5794: LD_INT 3
5796: ARRAY
5797: PUSH
5798: LD_EXP 42
5802: PUSH
5803: LD_INT 4
5805: ARRAY
5806: PUSH
5807: EMPTY
5808: LIST
5809: LIST
5810: LIST
5811: LIST
5812: ST_TO_ADDR
// hc_agressivity = animalsAgression ;
5813: LD_ADDR_OWVAR 35
5817: PUSH
5818: LD_EXP 43
5822: ST_TO_ADDR
// un = CreateHuman ;
5823: LD_ADDR_VAR 0 2
5827: PUSH
5828: CALL_OW 44
5832: ST_TO_ADDR
// PlaceUnitArea ( un , NatureArea , false ) ;
5833: LD_VAR 0 2
5837: PPUSH
5838: LD_INT 5
5840: PPUSH
5841: LD_INT 0
5843: PPUSH
5844: CALL_OW 49
// end ;
5848: GO 5739
5850: POP
5851: POP
// end ; enable ;
5852: ENABLE
// end ; end_of_file
5853: PPOPN 2
5855: END
// export function PrepareUnitExt ( ident , exist_mode , class ) ; var unit ; begin
5856: LD_INT 0
5858: PPUSH
5859: PPUSH
// if debugMode then
5860: LD_EXP 46
5864: IFFALSE 5881
// unit := NewCharacter ( ident ) ;
5866: LD_ADDR_VAR 0 5
5870: PUSH
5871: LD_VAR 0 1
5875: PPUSH
5876: CALL_OW 25
5880: ST_TO_ADDR
// if exist_mode and not debugMode then
5881: LD_VAR 0 2
5885: PUSH
5886: LD_EXP 46
5890: NOT
5891: AND
5892: IFFALSE 5917
// unit := CreateCharacter ( previousMissionPrefix & ident ) else
5894: LD_ADDR_VAR 0 5
5898: PUSH
5899: LD_EXP 45
5903: PUSH
5904: LD_VAR 0 1
5908: STR
5909: PPUSH
5910: CALL_OW 34
5914: ST_TO_ADDR
5915: GO 5939
// if not debugMode then
5917: LD_EXP 46
5921: NOT
5922: IFFALSE 5939
// unit := NewCharacter ( ident ) ;
5924: LD_ADDR_VAR 0 5
5928: PUSH
5929: LD_VAR 0 1
5933: PPUSH
5934: CALL_OW 25
5938: ST_TO_ADDR
// if class then
5939: LD_VAR 0 3
5943: IFFALSE 5959
// SetClass ( unit , class ) ;
5945: LD_VAR 0 5
5949: PPUSH
5950: LD_VAR 0 3
5954: PPUSH
5955: CALL_OW 336
// result := unit ;
5959: LD_ADDR_VAR 0 4
5963: PUSH
5964: LD_VAR 0 5
5968: ST_TO_ADDR
// end ;
5969: LD_VAR 0 4
5973: RET
// export function ExtSaveCharacter ( character , characterStringID , side ) ; begin
5974: LD_INT 0
5976: PPUSH
// if GetSide ( character ) = side and not IsDead ( character ) then
5977: LD_VAR 0 1
5981: PPUSH
5982: CALL_OW 255
5986: PUSH
5987: LD_VAR 0 3
5991: EQUAL
5992: PUSH
5993: LD_VAR 0 1
5997: PPUSH
5998: CALL_OW 301
6002: NOT
6003: AND
6004: IFFALSE 6026
// SaveCharacters ( character , missionPrefix & characterStringID ) ;
6006: LD_VAR 0 1
6010: PPUSH
6011: LD_EXP 44
6015: PUSH
6016: LD_VAR 0 2
6020: STR
6021: PPUSH
6022: CALL_OW 38
// end ;
6026: LD_VAR 0 4
6030: RET
// export function ExtSaveCharacters ( characters , charactersStringID , side ) ; var unit , resultCharactersToSave ; begin
6031: LD_INT 0
6033: PPUSH
6034: PPUSH
6035: PPUSH
// resultCharactersToSave = [ ] ;
6036: LD_ADDR_VAR 0 6
6040: PUSH
6041: EMPTY
6042: ST_TO_ADDR
// for unit in characters do
6043: LD_ADDR_VAR 0 5
6047: PUSH
6048: LD_VAR 0 1
6052: PUSH
6053: FOR_IN
6054: IFFALSE 6103
// if GetSide ( unit ) = side and not IsDead ( unit ) then
6056: LD_VAR 0 5
6060: PPUSH
6061: CALL_OW 255
6065: PUSH
6066: LD_VAR 0 3
6070: EQUAL
6071: PUSH
6072: LD_VAR 0 5
6076: PPUSH
6077: CALL_OW 301
6081: NOT
6082: AND
6083: IFFALSE 6101
// resultCharactersToSave = resultCharactersToSave ^ unit ;
6085: LD_ADDR_VAR 0 6
6089: PUSH
6090: LD_VAR 0 6
6094: PUSH
6095: LD_VAR 0 5
6099: ADD
6100: ST_TO_ADDR
6101: GO 6053
6103: POP
6104: POP
// SaveCharacters ( resultCharactersToSave , missionPrefix & charactersStringID ) ;
6105: LD_VAR 0 6
6109: PPUSH
6110: LD_EXP 44
6114: PUSH
6115: LD_VAR 0 2
6119: STR
6120: PPUSH
6121: CALL_OW 38
// end ;
6125: LD_VAR 0 4
6129: RET
// export function PlaceUnitsArea ( units , area , spawnMode ) ; var unit ; begin
6130: LD_INT 0
6132: PPUSH
6133: PPUSH
// for unit in units do
6134: LD_ADDR_VAR 0 5
6138: PUSH
6139: LD_VAR 0 1
6143: PUSH
6144: FOR_IN
6145: IFFALSE 6168
// PlaceUnitArea ( unit , area , spawnMode ) ;
6147: LD_VAR 0 5
6151: PPUSH
6152: LD_VAR 0 2
6156: PPUSH
6157: LD_VAR 0 3
6161: PPUSH
6162: CALL_OW 49
6166: GO 6144
6168: POP
6169: POP
// end ;
6170: LD_VAR 0 4
6174: RET
// export function DialogRandom ( characters , dialogMID , dialogFID , radio , canTalkHero ) ; var i , speaker , units ; begin
6175: LD_INT 0
6177: PPUSH
6178: PPUSH
6179: PPUSH
6180: PPUSH
// units = characters ;
6181: LD_ADDR_VAR 0 9
6185: PUSH
6186: LD_VAR 0 1
6190: ST_TO_ADDR
// units := units diff [ Burlak , Karamazov , Petrovova , Gleb , Petrosyan , Titov , Dolgov , Lipshchin , Kirilenkova ] ;
6191: LD_ADDR_VAR 0 9
6195: PUSH
6196: LD_VAR 0 9
6200: PUSH
6201: LD_EXP 57
6205: PUSH
6206: LD_EXP 58
6210: PUSH
6211: LD_EXP 59
6215: PUSH
6216: LD_EXP 60
6220: PUSH
6221: LD_EXP 61
6225: PUSH
6226: LD_EXP 62
6230: PUSH
6231: LD_EXP 63
6235: PUSH
6236: LD_EXP 64
6240: PUSH
6241: LD_EXP 65
6245: PUSH
6246: EMPTY
6247: LIST
6248: LIST
6249: LIST
6250: LIST
6251: LIST
6252: LIST
6253: LIST
6254: LIST
6255: LIST
6256: DIFF
6257: ST_TO_ADDR
// if not units and not canTalkHero then
6258: LD_VAR 0 9
6262: NOT
6263: PUSH
6264: LD_VAR 0 5
6268: NOT
6269: AND
6270: IFFALSE 6274
// exit ;
6272: GO 6447
// if not units then
6274: LD_VAR 0 9
6278: NOT
6279: IFFALSE 6300
// units = characters diff [ Burlak ] ;
6281: LD_ADDR_VAR 0 9
6285: PUSH
6286: LD_VAR 0 1
6290: PUSH
6291: LD_EXP 57
6295: PUSH
6296: EMPTY
6297: LIST
6298: DIFF
6299: ST_TO_ADDR
// if not units and canTalkHero then
6300: LD_VAR 0 9
6304: NOT
6305: PUSH
6306: LD_VAR 0 5
6310: AND
6311: IFFALSE 6315
// exit ;
6313: GO 6447
// speaker := units [ rand ( 1 , units ) ] ;
6315: LD_ADDR_VAR 0 8
6319: PUSH
6320: LD_VAR 0 9
6324: PUSH
6325: LD_INT 1
6327: PPUSH
6328: LD_VAR 0 9
6332: PPUSH
6333: CALL_OW 12
6337: ARRAY
6338: ST_TO_ADDR
// if radio then
6339: LD_VAR 0 4
6343: IFFALSE 6392
// begin if GetSex ( speaker ) = sex_male then
6345: LD_VAR 0 8
6349: PPUSH
6350: CALL_OW 258
6354: PUSH
6355: LD_INT 1
6357: EQUAL
6358: IFFALSE 6376
// SayRadio ( speaker , dialogMID ) else
6360: LD_VAR 0 8
6364: PPUSH
6365: LD_VAR 0 2
6369: PPUSH
6370: CALL_OW 94
6374: GO 6390
// SayRadio ( speaker , dialogFID ) ;
6376: LD_VAR 0 8
6380: PPUSH
6381: LD_VAR 0 3
6385: PPUSH
6386: CALL_OW 94
// end else
6390: GO 6437
// begin if GetSex ( speaker ) = sex_male then
6392: LD_VAR 0 8
6396: PPUSH
6397: CALL_OW 258
6401: PUSH
6402: LD_INT 1
6404: EQUAL
6405: IFFALSE 6423
// Say ( speaker , dialogMID ) else
6407: LD_VAR 0 8
6411: PPUSH
6412: LD_VAR 0 2
6416: PPUSH
6417: CALL_OW 88
6421: GO 6437
// Say ( speaker , dialogFID ) ;
6423: LD_VAR 0 8
6427: PPUSH
6428: LD_VAR 0 3
6432: PPUSH
6433: CALL_OW 88
// end ; result := speaker ;
6437: LD_ADDR_VAR 0 6
6441: PUSH
6442: LD_VAR 0 8
6446: ST_TO_ADDR
// end ;
6447: LD_VAR 0 6
6451: RET
// export function RemoveUnits ( units ) ; var unit ; begin
6452: LD_INT 0
6454: PPUSH
6455: PPUSH
// if not units then
6456: LD_VAR 0 1
6460: NOT
6461: IFFALSE 6465
// exit ;
6463: GO 6611
// if Heike in units then
6465: LD_EXP 79
6469: PUSH
6470: LD_VAR 0 1
6474: IN
6475: IFFALSE 6531
// begin if GetAttitude ( 3 , 8 ) = att_neutral then
6477: LD_INT 3
6479: PPUSH
6480: LD_INT 8
6482: PPUSH
6483: CALL_OW 81
6487: PUSH
6488: LD_INT 0
6490: EQUAL
6491: IFFALSE 6503
// HeikeStatus = 1 else
6493: LD_ADDR_EXP 3
6497: PUSH
6498: LD_INT 1
6500: ST_TO_ADDR
6501: GO 6511
// HeikeStatus = 2 ;
6503: LD_ADDR_EXP 3
6507: PUSH
6508: LD_INT 2
6510: ST_TO_ADDR
// forceStopKurtAttack = true ;
6511: LD_ADDR_EXP 27
6515: PUSH
6516: LD_INT 1
6518: ST_TO_ADDR
// SetClass ( Heike , 1 ) ;
6519: LD_EXP 79
6523: PPUSH
6524: LD_INT 1
6526: PPUSH
6527: CALL_OW 336
// end ; if Kurt in units then
6531: LD_EXP 80
6535: PUSH
6536: LD_VAR 0 1
6540: IN
6541: IFFALSE 6585
// begin if GetAttitude ( 3 , 8 ) = att_neutral then
6543: LD_INT 3
6545: PPUSH
6546: LD_INT 8
6548: PPUSH
6549: CALL_OW 81
6553: PUSH
6554: LD_INT 0
6556: EQUAL
6557: IFFALSE 6569
// KurtStatus = 1 else
6559: LD_ADDR_EXP 22
6563: PUSH
6564: LD_INT 1
6566: ST_TO_ADDR
6567: GO 6585
// begin KurtStatus = 2 ;
6569: LD_ADDR_EXP 22
6573: PUSH
6574: LD_INT 2
6576: ST_TO_ADDR
// KurtAttack = 1 ;
6577: LD_ADDR_EXP 25
6581: PUSH
6582: LD_INT 1
6584: ST_TO_ADDR
// end ; end ; for unit in units do
6585: LD_ADDR_VAR 0 3
6589: PUSH
6590: LD_VAR 0 1
6594: PUSH
6595: FOR_IN
6596: IFFALSE 6609
// RemoveUnit ( unit ) ;
6598: LD_VAR 0 3
6602: PPUSH
6603: CALL_OW 64
6607: GO 6595
6609: POP
6610: POP
// end ;
6611: LD_VAR 0 2
6615: RET
// export function GetAmountWeaponsDataBuildOnTurret ( isBuild ) ; var i , amount ; begin
6616: LD_INT 0
6618: PPUSH
6619: PPUSH
6620: PPUSH
// amount = 0 ;
6621: LD_ADDR_VAR 0 4
6625: PUSH
6626: LD_INT 0
6628: ST_TO_ADDR
// for i := 1 to weaponsData do
6629: LD_ADDR_VAR 0 3
6633: PUSH
6634: DOUBLE
6635: LD_INT 1
6637: DEC
6638: ST_TO_ADDR
6639: LD_EXP 12
6643: PUSH
6644: FOR_TO
6645: IFFALSE 6685
// if weaponsData [ i ] [ 2 ] = isBuild then
6647: LD_EXP 12
6651: PUSH
6652: LD_VAR 0 3
6656: ARRAY
6657: PUSH
6658: LD_INT 2
6660: ARRAY
6661: PUSH
6662: LD_VAR 0 1
6666: EQUAL
6667: IFFALSE 6683
// amount = amount + 1 ;
6669: LD_ADDR_VAR 0 4
6673: PUSH
6674: LD_VAR 0 4
6678: PUSH
6679: LD_INT 1
6681: PLUS
6682: ST_TO_ADDR
6683: GO 6644
6685: POP
6686: POP
// if isBuild then
6687: LD_VAR 0 1
6691: IFFALSE 6711
// if amount >= 3 then
6693: LD_VAR 0 4
6697: PUSH
6698: LD_INT 3
6700: GREATEREQUAL
6701: IFFALSE 6711
// amount = 3 ;
6703: LD_ADDR_VAR 0 4
6707: PUSH
6708: LD_INT 3
6710: ST_TO_ADDR
// result = amount ;
6711: LD_ADDR_VAR 0 2
6715: PUSH
6716: LD_VAR 0 4
6720: ST_TO_ADDR
// end ;
6721: LD_VAR 0 2
6725: RET
// export function GetAmountWeaponsDataBuildOnVehicle ( isBuild ) ; var i , amount ; begin
6726: LD_INT 0
6728: PPUSH
6729: PPUSH
6730: PPUSH
// amount = 0 ;
6731: LD_ADDR_VAR 0 4
6735: PUSH
6736: LD_INT 0
6738: ST_TO_ADDR
// for i := 1 to weaponsData do
6739: LD_ADDR_VAR 0 3
6743: PUSH
6744: DOUBLE
6745: LD_INT 1
6747: DEC
6748: ST_TO_ADDR
6749: LD_EXP 12
6753: PUSH
6754: FOR_TO
6755: IFFALSE 6795
// if weaponsData [ i ] [ 3 ] = isBuild then
6757: LD_EXP 12
6761: PUSH
6762: LD_VAR 0 3
6766: ARRAY
6767: PUSH
6768: LD_INT 3
6770: ARRAY
6771: PUSH
6772: LD_VAR 0 1
6776: EQUAL
6777: IFFALSE 6793
// amount = amount + 1 ;
6779: LD_ADDR_VAR 0 4
6783: PUSH
6784: LD_VAR 0 4
6788: PUSH
6789: LD_INT 1
6791: PLUS
6792: ST_TO_ADDR
6793: GO 6754
6795: POP
6796: POP
// result = amount ;
6797: LD_ADDR_VAR 0 2
6801: PUSH
6802: LD_VAR 0 4
6806: ST_TO_ADDR
// end ;
6807: LD_VAR 0 2
6811: RET
// export function SetWeaponDataBuild ( weapon , turret ) ; var i ; begin
6812: LD_INT 0
6814: PPUSH
6815: PPUSH
// if turret then
6816: LD_VAR 0 2
6820: IFFALSE 6918
// begin for i := 1 to weaponsData do
6822: LD_ADDR_VAR 0 4
6826: PUSH
6827: DOUBLE
6828: LD_INT 1
6830: DEC
6831: ST_TO_ADDR
6832: LD_EXP 12
6836: PUSH
6837: FOR_TO
6838: IFFALSE 6914
// if weaponsData [ i ] [ 1 ] = weapon and weaponsData [ i ] [ 2 ] = false then
6840: LD_EXP 12
6844: PUSH
6845: LD_VAR 0 4
6849: ARRAY
6850: PUSH
6851: LD_INT 1
6853: ARRAY
6854: PUSH
6855: LD_VAR 0 1
6859: EQUAL
6860: PUSH
6861: LD_EXP 12
6865: PUSH
6866: LD_VAR 0 4
6870: ARRAY
6871: PUSH
6872: LD_INT 2
6874: ARRAY
6875: PUSH
6876: LD_INT 0
6878: EQUAL
6879: AND
6880: IFFALSE 6912
// weaponsData = ReplaceIn ( weaponsData , [ i , 2 ] , true ) ;
6882: LD_ADDR_EXP 12
6886: PUSH
6887: LD_EXP 12
6891: PPUSH
6892: LD_VAR 0 4
6896: PUSH
6897: LD_INT 2
6899: PUSH
6900: EMPTY
6901: LIST
6902: LIST
6903: PPUSH
6904: LD_INT 1
6906: PPUSH
6907: CALL 24096 0 3
6911: ST_TO_ADDR
6912: GO 6837
6914: POP
6915: POP
// end else
6916: GO 7012
// begin for i := 1 to weaponsData do
6918: LD_ADDR_VAR 0 4
6922: PUSH
6923: DOUBLE
6924: LD_INT 1
6926: DEC
6927: ST_TO_ADDR
6928: LD_EXP 12
6932: PUSH
6933: FOR_TO
6934: IFFALSE 7010
// if weaponsData [ i ] [ 1 ] = weapon and weaponsData [ i ] [ 3 ] = false then
6936: LD_EXP 12
6940: PUSH
6941: LD_VAR 0 4
6945: ARRAY
6946: PUSH
6947: LD_INT 1
6949: ARRAY
6950: PUSH
6951: LD_VAR 0 1
6955: EQUAL
6956: PUSH
6957: LD_EXP 12
6961: PUSH
6962: LD_VAR 0 4
6966: ARRAY
6967: PUSH
6968: LD_INT 3
6970: ARRAY
6971: PUSH
6972: LD_INT 0
6974: EQUAL
6975: AND
6976: IFFALSE 7008
// weaponsData = ReplaceIn ( weaponsData , [ i , 3 ] , true ) ;
6978: LD_ADDR_EXP 12
6982: PUSH
6983: LD_EXP 12
6987: PPUSH
6988: LD_VAR 0 4
6992: PUSH
6993: LD_INT 3
6995: PUSH
6996: EMPTY
6997: LIST
6998: LIST
6999: PPUSH
7000: LD_INT 1
7002: PPUSH
7003: CALL 24096 0 3
7007: ST_TO_ADDR
7008: GO 6933
7010: POP
7011: POP
// end ; end ;
7012: LD_VAR 0 3
7016: RET
// export function ShootTreningController ; var i , unitsInArea , unit , depots , depot , barrelsAreaList , randIndex , randPosX , randPosY , barrelsInArea ; begin
7017: LD_INT 0
7019: PPUSH
7020: PPUSH
7021: PPUSH
7022: PPUSH
7023: PPUSH
7024: PPUSH
7025: PPUSH
7026: PPUSH
7027: PPUSH
7028: PPUSH
7029: PPUSH
// unitsInArea = FilterUnitsInArea ( ShootArea , [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) ;
7030: LD_ADDR_VAR 0 3
7034: PUSH
7035: LD_INT 12
7037: PPUSH
7038: LD_INT 22
7040: PUSH
7041: LD_INT 3
7043: PUSH
7044: EMPTY
7045: LIST
7046: LIST
7047: PUSH
7048: LD_INT 21
7050: PUSH
7051: LD_INT 1
7053: PUSH
7054: EMPTY
7055: LIST
7056: LIST
7057: PUSH
7058: LD_INT 50
7060: PUSH
7061: EMPTY
7062: LIST
7063: PUSH
7064: LD_INT 3
7066: PUSH
7067: LD_INT 60
7069: PUSH
7070: EMPTY
7071: LIST
7072: PUSH
7073: EMPTY
7074: LIST
7075: LIST
7076: PUSH
7077: EMPTY
7078: LIST
7079: LIST
7080: LIST
7081: LIST
7082: PPUSH
7083: CALL_OW 70
7087: ST_TO_ADDR
// depots = FilterAllUnits ( [ [ f_side , 3 ] , [ f_ok ] , [ f_type , unit_building ] , [ f_not , [ f_constructed ] ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
7088: LD_ADDR_VAR 0 5
7092: PUSH
7093: LD_INT 22
7095: PUSH
7096: LD_INT 3
7098: PUSH
7099: EMPTY
7100: LIST
7101: LIST
7102: PUSH
7103: LD_INT 50
7105: PUSH
7106: EMPTY
7107: LIST
7108: PUSH
7109: LD_INT 21
7111: PUSH
7112: LD_INT 3
7114: PUSH
7115: EMPTY
7116: LIST
7117: LIST
7118: PUSH
7119: LD_INT 3
7121: PUSH
7122: LD_INT 57
7124: PUSH
7125: EMPTY
7126: LIST
7127: PUSH
7128: EMPTY
7129: LIST
7130: LIST
7131: PUSH
7132: LD_INT 2
7134: PUSH
7135: LD_INT 30
7137: PUSH
7138: LD_INT 0
7140: PUSH
7141: EMPTY
7142: LIST
7143: LIST
7144: PUSH
7145: LD_INT 30
7147: PUSH
7148: LD_INT 1
7150: PUSH
7151: EMPTY
7152: LIST
7153: LIST
7154: PUSH
7155: EMPTY
7156: LIST
7157: LIST
7158: LIST
7159: PUSH
7160: EMPTY
7161: LIST
7162: LIST
7163: LIST
7164: LIST
7165: LIST
7166: PPUSH
7167: CALL_OW 69
7171: ST_TO_ADDR
// barrelsAreaList = AreaToList ( BarrelsArea , 0 ) ;
7172: LD_ADDR_VAR 0 7
7176: PUSH
7177: LD_INT 13
7179: PPUSH
7180: LD_INT 0
7182: PPUSH
7183: CALL_OW 517
7187: ST_TO_ADDR
// if not depots or not unitsInArea then
7188: LD_VAR 0 5
7192: NOT
7193: PUSH
7194: LD_VAR 0 3
7198: NOT
7199: OR
7200: IFFALSE 7204
// exit ;
7202: GO 7640
// depot = depots [ 1 ] ;
7204: LD_ADDR_VAR 0 6
7208: PUSH
7209: LD_VAR 0 5
7213: PUSH
7214: LD_INT 1
7216: ARRAY
7217: ST_TO_ADDR
// for unit in unitsInArea do
7218: LD_ADDR_VAR 0 4
7222: PUSH
7223: LD_VAR 0 3
7227: PUSH
7228: FOR_IN
7229: IFFALSE 7638
// begin if not GetClass ( unit ) = class_engineer then
7231: LD_VAR 0 4
7235: PPUSH
7236: CALL_OW 257
7240: PUSH
7241: LD_INT 2
7243: EQUAL
7244: NOT
7245: IFFALSE 7282
// begin ComEnterUnit ( unit , depot ) ;
7247: LD_VAR 0 4
7251: PPUSH
7252: LD_VAR 0 6
7256: PPUSH
7257: CALL_OW 120
// AddComChangeProfession ( unit , class_engineer ) ;
7261: LD_VAR 0 4
7265: PPUSH
7266: LD_INT 2
7268: PPUSH
7269: CALL_OW 183
// AddComExitBuilding ( unit ) ;
7273: LD_VAR 0 4
7277: PPUSH
7278: CALL_OW 182
// end ; if GetCargo ( unit , mat_oil ) = 0 then
7282: LD_VAR 0 4
7286: PPUSH
7287: LD_INT 2
7289: PPUSH
7290: CALL_OW 289
7294: PUSH
7295: LD_INT 0
7297: EQUAL
7298: IFFALSE 7317
// AddComTransport ( unit , depot , mat_oil ) ;
7300: LD_VAR 0 4
7304: PPUSH
7305: LD_VAR 0 6
7309: PPUSH
7310: LD_INT 2
7312: PPUSH
7313: CALL_OW 211
// repeat wait ( 0 0$1 ) ;
7317: LD_INT 35
7319: PPUSH
7320: CALL_OW 67
// until not HasTask ( unit ) ;
7324: LD_VAR 0 4
7328: PPUSH
7329: CALL_OW 314
7333: NOT
7334: IFFALSE 7317
// if GetCargo ( unit , mat_oil ) > 0 then
7336: LD_VAR 0 4
7340: PPUSH
7341: LD_INT 2
7343: PPUSH
7344: CALL_OW 289
7348: PUSH
7349: LD_INT 0
7351: GREATER
7352: IFFALSE 7636
// begin randIndex = Rand ( 1 , barrelsAreaList [ 1 ] ) ;
7354: LD_ADDR_VAR 0 8
7358: PUSH
7359: LD_INT 1
7361: PPUSH
7362: LD_VAR 0 7
7366: PUSH
7367: LD_INT 1
7369: ARRAY
7370: PPUSH
7371: CALL_OW 12
7375: ST_TO_ADDR
// randPosX = barrelsAreaList [ 1 ] [ randIndex ] ;
7376: LD_ADDR_VAR 0 9
7380: PUSH
7381: LD_VAR 0 7
7385: PUSH
7386: LD_INT 1
7388: ARRAY
7389: PUSH
7390: LD_VAR 0 8
7394: ARRAY
7395: ST_TO_ADDR
// randPosY = barrelsAreaList [ 2 ] [ RandIndex ] ;
7396: LD_ADDR_VAR 0 10
7400: PUSH
7401: LD_VAR 0 7
7405: PUSH
7406: LD_INT 2
7408: ARRAY
7409: PUSH
7410: LD_VAR 0 8
7414: ARRAY
7415: ST_TO_ADDR
// AddComMoveXY ( unit , randPosX , randPosY ) ;
7416: LD_VAR 0 4
7420: PPUSH
7421: LD_VAR 0 9
7425: PPUSH
7426: LD_VAR 0 10
7430: PPUSH
7431: CALL_OW 171
// AddComUnload ( unit ) ;
7435: LD_VAR 0 4
7439: PPUSH
7440: CALL_OW 219
// AddComMoveXY ( unit , randPosX + 2 , randPosY + 2 ) ;
7444: LD_VAR 0 4
7448: PPUSH
7449: LD_VAR 0 9
7453: PUSH
7454: LD_INT 2
7456: PLUS
7457: PPUSH
7458: LD_VAR 0 10
7462: PUSH
7463: LD_INT 2
7465: PLUS
7466: PPUSH
7467: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
7471: LD_INT 35
7473: PPUSH
7474: CALL_OW 67
// until not HasTask ( unit ) ;
7478: LD_VAR 0 4
7482: PPUSH
7483: CALL_OW 314
7487: NOT
7488: IFFALSE 7471
// barrelsInArea = GetListOfCratesInArea ( ShootArea ) ;
7490: LD_ADDR_VAR 0 11
7494: PUSH
7495: LD_INT 12
7497: PPUSH
7498: CALL_OW 435
7502: ST_TO_ADDR
// for i := 1 to barrelsInArea / 2 do
7503: LD_ADDR_VAR 0 2
7507: PUSH
7508: DOUBLE
7509: LD_INT 1
7511: DEC
7512: ST_TO_ADDR
7513: LD_VAR 0 11
7517: PUSH
7518: LD_INT 2
7520: DIVREAL
7521: PUSH
7522: FOR_TO
7523: IFFALSE 7634
// begin if GetDistUnitXY ( unit , barrelsInArea [ i ] , barrelsInArea [ i + 1 ] ) <= 6 then
7525: LD_VAR 0 4
7529: PPUSH
7530: LD_VAR 0 11
7534: PUSH
7535: LD_VAR 0 2
7539: ARRAY
7540: PPUSH
7541: LD_VAR 0 11
7545: PUSH
7546: LD_VAR 0 2
7550: PUSH
7551: LD_INT 1
7553: PLUS
7554: ARRAY
7555: PPUSH
7556: CALL_OW 297
7560: PUSH
7561: LD_INT 6
7563: LESSEQUAL
7564: IFFALSE 7618
// begin AddComAttackPlace ( unit , barrelsInArea [ i ] , barrelsInArea [ i + 1 ] ) ;
7566: LD_VAR 0 4
7570: PPUSH
7571: LD_VAR 0 11
7575: PUSH
7576: LD_VAR 0 2
7580: ARRAY
7581: PPUSH
7582: LD_VAR 0 11
7586: PUSH
7587: LD_VAR 0 2
7591: PUSH
7592: LD_INT 1
7594: PLUS
7595: ARRAY
7596: PPUSH
7597: CALL_OW 176
// AddExperience ( unit , skill_combat , 5 ) ;
7601: LD_VAR 0 4
7605: PPUSH
7606: LD_INT 1
7608: PPUSH
7609: LD_INT 5
7611: PPUSH
7612: CALL_OW 492
// break ;
7616: GO 7634
// end ; i = i + 2 ;
7618: LD_ADDR_VAR 0 2
7622: PUSH
7623: LD_VAR 0 2
7627: PUSH
7628: LD_INT 2
7630: PLUS
7631: ST_TO_ADDR
// end ;
7632: GO 7522
7634: POP
7635: POP
// end ; end ;
7636: GO 7228
7638: POP
7639: POP
// end ;
7640: LD_VAR 0 1
7644: RET
// export function GoToHunt ( hunter ) ; var i , barracks , barrackTarget , barrackTargetCurrentHP , animals , animal ; begin
7645: LD_INT 0
7647: PPUSH
7648: PPUSH
7649: PPUSH
7650: PPUSH
7651: PPUSH
7652: PPUSH
7653: PPUSH
// animals = [ ] ;
7654: LD_ADDR_VAR 0 7
7658: PUSH
7659: EMPTY
7660: ST_TO_ADDR
// barracks = FilterAllUnits ( [ [ f_ok ] , [ f_not , [ f_constructed ] ] , [ f_or , [ f_btype , b_barracks ] , [ f_btype , b_armoury ] ] ] ) ;
7661: LD_ADDR_VAR 0 4
7665: PUSH
7666: LD_INT 50
7668: PUSH
7669: EMPTY
7670: LIST
7671: PUSH
7672: LD_INT 3
7674: PUSH
7675: LD_INT 57
7677: PUSH
7678: EMPTY
7679: LIST
7680: PUSH
7681: EMPTY
7682: LIST
7683: LIST
7684: PUSH
7685: LD_INT 2
7687: PUSH
7688: LD_INT 30
7690: PUSH
7691: LD_INT 5
7693: PUSH
7694: EMPTY
7695: LIST
7696: LIST
7697: PUSH
7698: LD_INT 30
7700: PUSH
7701: LD_INT 4
7703: PUSH
7704: EMPTY
7705: LIST
7706: LIST
7707: PUSH
7708: EMPTY
7709: LIST
7710: LIST
7711: LIST
7712: PUSH
7713: EMPTY
7714: LIST
7715: LIST
7716: LIST
7717: PPUSH
7718: CALL_OW 69
7722: ST_TO_ADDR
// SetSide ( hunter , 6 ) ;
7723: LD_VAR 0 1
7727: PPUSH
7728: LD_INT 6
7730: PPUSH
7731: CALL_OW 235
// if IsInUnit ( hunter ) then
7735: LD_VAR 0 1
7739: PPUSH
7740: CALL_OW 310
7744: IFFALSE 7786
// begin if GetBType ( IsInUnit ( hunter ) = unit_vehicle ) then
7746: LD_VAR 0 1
7750: PPUSH
7751: CALL_OW 310
7755: PUSH
7756: LD_INT 2
7758: EQUAL
7759: PPUSH
7760: CALL_OW 266
7764: IFFALSE 7777
// ComExitVehicle ( hunter ) else
7766: LD_VAR 0 1
7770: PPUSH
7771: CALL_OW 121
7775: GO 7786
// ComExitBuilding ( hunter ) ;
7777: LD_VAR 0 1
7781: PPUSH
7782: CALL_OW 122
// end ; ComWalk ( hunter ) ;
7786: LD_VAR 0 1
7790: PPUSH
7791: CALL_OW 138
// wait ( 0 0$1 ) ;
7795: LD_INT 35
7797: PPUSH
7798: CALL_OW 67
// if not GetClass ( hunter ) = class_soldier and barracks then
7802: LD_VAR 0 1
7806: PPUSH
7807: CALL_OW 257
7811: PUSH
7812: LD_INT 1
7814: EQUAL
7815: NOT
7816: PUSH
7817: LD_VAR 0 4
7821: AND
7822: IFFALSE 7965
// begin barrackTarget = barracks [ 1 ] ;
7824: LD_ADDR_VAR 0 5
7828: PUSH
7829: LD_VAR 0 4
7833: PUSH
7834: LD_INT 1
7836: ARRAY
7837: ST_TO_ADDR
// barrackTargetCurrentHP = GetLives ( barrackTarget ) ;
7838: LD_ADDR_VAR 0 6
7842: PUSH
7843: LD_VAR 0 5
7847: PPUSH
7848: CALL_OW 256
7852: ST_TO_ADDR
// SetSide ( barrackTarget , 6 ) ;
7853: LD_VAR 0 5
7857: PPUSH
7858: LD_INT 6
7860: PPUSH
7861: CALL_OW 235
// ComEnterUnit ( hunter , barrackTarget ) ;
7865: LD_VAR 0 1
7869: PPUSH
7870: LD_VAR 0 5
7874: PPUSH
7875: CALL_OW 120
// repeat wait ( 0 0$1 ) ;
7879: LD_INT 35
7881: PPUSH
7882: CALL_OW 67
// ComEnterUnit ( hunter , barrackTarget ) ;
7886: LD_VAR 0 1
7890: PPUSH
7891: LD_VAR 0 5
7895: PPUSH
7896: CALL_OW 120
// SetLives ( barrackTarget , barrackTargetCurrentHP ) ;
7900: LD_VAR 0 5
7904: PPUSH
7905: LD_VAR 0 6
7909: PPUSH
7910: CALL_OW 234
// until IsInUnit ( hunter ) ;
7914: LD_VAR 0 1
7918: PPUSH
7919: CALL_OW 310
7923: IFFALSE 7879
// SetClass ( hunter , class_soldier ) ;
7925: LD_VAR 0 1
7929: PPUSH
7930: LD_INT 1
7932: PPUSH
7933: CALL_OW 336
// ComExitBuilding ( hunter ) ;
7937: LD_VAR 0 1
7941: PPUSH
7942: CALL_OW 122
// SetSide ( barrackTarget , 3 ) ;
7946: LD_VAR 0 5
7950: PPUSH
7951: LD_INT 3
7953: PPUSH
7954: CALL_OW 235
// wait ( 0 0$1 ) ;
7958: LD_INT 35
7960: PPUSH
7961: CALL_OW 67
// end ; for i := 1 to 3 do
7965: LD_ADDR_VAR 0 3
7969: PUSH
7970: DOUBLE
7971: LD_INT 1
7973: DEC
7974: ST_TO_ADDR
7975: LD_INT 3
7977: PUSH
7978: FOR_TO
7979: IFFALSE 8084
// begin uc_side = 0 ;
7981: LD_ADDR_OWVAR 20
7985: PUSH
7986: LD_INT 0
7988: ST_TO_ADDR
// uc_nation = nation_nature ;
7989: LD_ADDR_OWVAR 21
7993: PUSH
7994: LD_INT 0
7996: ST_TO_ADDR
// PrepareHuman ( false , [ class_phororhacos , class_tiger , 21 ] [ Rand ( 1 , 3 ) ] , 0 ) ;
7997: LD_INT 0
7999: PPUSH
8000: LD_INT 18
8002: PUSH
8003: LD_INT 14
8005: PUSH
8006: LD_INT 21
8008: PUSH
8009: EMPTY
8010: LIST
8011: LIST
8012: LIST
8013: PUSH
8014: LD_INT 1
8016: PPUSH
8017: LD_INT 3
8019: PPUSH
8020: CALL_OW 12
8024: ARRAY
8025: PPUSH
8026: LD_INT 0
8028: PPUSH
8029: CALL_OW 380
// hc_agressivity = 0 ;
8033: LD_ADDR_OWVAR 35
8037: PUSH
8038: LD_INT 0
8040: ST_TO_ADDR
// animal = CreateHuman ;
8041: LD_ADDR_VAR 0 8
8045: PUSH
8046: CALL_OW 44
8050: ST_TO_ADDR
// PlaceUnitArea ( animal , NatureArea , false ) ;
8051: LD_VAR 0 8
8055: PPUSH
8056: LD_INT 5
8058: PPUSH
8059: LD_INT 0
8061: PPUSH
8062: CALL_OW 49
// animals = animals ^ animal ;
8066: LD_ADDR_VAR 0 7
8070: PUSH
8071: LD_VAR 0 7
8075: PUSH
8076: LD_VAR 0 8
8080: ADD
8081: ST_TO_ADDR
// end ;
8082: GO 7978
8084: POP
8085: POP
// for i := 1 to animals do
8086: LD_ADDR_VAR 0 3
8090: PUSH
8091: DOUBLE
8092: LD_INT 1
8094: DEC
8095: ST_TO_ADDR
8096: LD_VAR 0 7
8100: PUSH
8101: FOR_TO
8102: IFFALSE 8126
// AddComAttackUnit ( hunter , animals [ i ] ) ;
8104: LD_VAR 0 1
8108: PPUSH
8109: LD_VAR 0 7
8113: PUSH
8114: LD_VAR 0 3
8118: ARRAY
8119: PPUSH
8120: CALL_OW 175
8124: GO 8101
8126: POP
8127: POP
// repeat wait ( 0 0$1 ) ;
8128: LD_INT 35
8130: PPUSH
8131: CALL_OW 67
// if GetClass ( hunter ) = class_soldier then
8135: LD_VAR 0 1
8139: PPUSH
8140: CALL_OW 257
8144: PUSH
8145: LD_INT 1
8147: EQUAL
8148: IFFALSE 8195
// begin if GetDistUnits ( hunter , WantsToAttack ( hunter ) ) < 13 then
8150: LD_VAR 0 1
8154: PPUSH
8155: LD_VAR 0 1
8159: PPUSH
8160: CALL_OW 319
8164: PPUSH
8165: CALL_OW 296
8169: PUSH
8170: LD_INT 13
8172: LESS
8173: IFFALSE 8186
// ComCrawl ( hunter ) else
8175: LD_VAR 0 1
8179: PPUSH
8180: CALL_OW 137
8184: GO 8195
// ComWalk ( hunter ) ;
8186: LD_VAR 0 1
8190: PPUSH
8191: CALL_OW 138
// end ; until not HasTask ( hunter ) ;
8195: LD_VAR 0 1
8199: PPUSH
8200: CALL_OW 314
8204: NOT
8205: IFFALSE 8128
// repeat wait ( 0 0$1 ) ;
8207: LD_INT 35
8209: PPUSH
8210: CALL_OW 67
// ComMoveXY ( hunter , GetX ( Burlak ) , GetY ( Burlak ) ) ;
8214: LD_VAR 0 1
8218: PPUSH
8219: LD_EXP 57
8223: PPUSH
8224: CALL_OW 250
8228: PPUSH
8229: LD_EXP 57
8233: PPUSH
8234: CALL_OW 251
8238: PPUSH
8239: CALL_OW 111
// until GetDistUnits ( hunter , Burlak ) <= 9 ;
8243: LD_VAR 0 1
8247: PPUSH
8248: LD_EXP 57
8252: PPUSH
8253: CALL_OW 296
8257: PUSH
8258: LD_INT 9
8260: LESSEQUAL
8261: IFFALSE 8207
// SetSide ( hunter , 3 ) ;
8263: LD_VAR 0 1
8267: PPUSH
8268: LD_INT 3
8270: PPUSH
8271: CALL_OW 235
// CenterOnUnits ( hunter ) ;
8275: LD_VAR 0 1
8279: PPUSH
8280: CALL_OW 85
// AddExperience ( hunter , skill_combat , 3000 ) ;
8284: LD_VAR 0 1
8288: PPUSH
8289: LD_INT 1
8291: PPUSH
8292: LD_INT 3000
8294: PPUSH
8295: CALL_OW 492
// end ;
8299: LD_VAR 0 2
8303: RET
// export function SetMashaData ( vehicle ) ; begin
8304: LD_INT 0
8306: PPUSH
// if Masha then
8307: LD_EXP 4
8311: IFFALSE 8329
// SetMark ( Masha [ 1 ] , 0 ) ;
8313: LD_EXP 4
8317: PUSH
8318: LD_INT 1
8320: ARRAY
8321: PPUSH
8322: LD_INT 0
8324: PPUSH
8325: CALL_OW 242
// Masha = [ vehicle , GetChassis ( vehicle ) , GetEngine ( vehicle ) , GetControl ( vehicle ) , GetWeapon ( vehicle ) ] ;
8329: LD_ADDR_EXP 4
8333: PUSH
8334: LD_VAR 0 1
8338: PUSH
8339: LD_VAR 0 1
8343: PPUSH
8344: CALL_OW 265
8348: PUSH
8349: LD_VAR 0 1
8353: PPUSH
8354: CALL_OW 262
8358: PUSH
8359: LD_VAR 0 1
8363: PPUSH
8364: CALL_OW 263
8368: PUSH
8369: LD_VAR 0 1
8373: PPUSH
8374: CALL_OW 264
8378: PUSH
8379: EMPTY
8380: LIST
8381: LIST
8382: LIST
8383: LIST
8384: LIST
8385: ST_TO_ADDR
// ChangeMissionObjectives ( MMashaDone ) ;
8386: LD_STRING MMashaDone
8388: PPUSH
8389: CALL_OW 337
// SetMark ( vehicle , 1 ) ;
8393: LD_VAR 0 1
8397: PPUSH
8398: LD_INT 1
8400: PPUSH
8401: CALL_OW 242
// end ;
8405: LD_VAR 0 2
8409: RET
// export function SaveBase ( buildings , ident ) ; var i , buildingsToSave ; begin
8410: LD_INT 0
8412: PPUSH
8413: PPUSH
8414: PPUSH
// buildingsToSave = [ ] ;
8415: LD_ADDR_VAR 0 5
8419: PUSH
8420: EMPTY
8421: ST_TO_ADDR
// if not buildings then
8422: LD_VAR 0 1
8426: NOT
8427: IFFALSE 8431
// exit ;
8429: GO 9006
// for i in buildings do
8431: LD_ADDR_VAR 0 4
8435: PUSH
8436: LD_VAR 0 1
8440: PUSH
8441: FOR_IN
8442: IFFALSE 8990
// begin if GetBType ( i ) in [ b_lab , b_lab_half , b_lab_full ] then
8444: LD_VAR 0 4
8448: PPUSH
8449: CALL_OW 266
8453: PUSH
8454: LD_INT 6
8456: PUSH
8457: LD_INT 7
8459: PUSH
8460: LD_INT 8
8462: PUSH
8463: EMPTY
8464: LIST
8465: LIST
8466: LIST
8467: IN
8468: IFFALSE 8593
// buildingsToSave = buildingsToSave ^ [ [ GetBType ( i ) , GetX ( i ) , GetY ( i ) , GetDir ( i ) , GetBLevel ( i ) , GetNation ( i ) , GetLives ( i ) , GetLabKind ( i , 1 ) , GetLabKind ( i , 2 ) ] ] else
8470: LD_ADDR_VAR 0 5
8474: PUSH
8475: LD_VAR 0 5
8479: PUSH
8480: LD_VAR 0 4
8484: PPUSH
8485: CALL_OW 266
8489: PUSH
8490: LD_VAR 0 4
8494: PPUSH
8495: CALL_OW 250
8499: PUSH
8500: LD_VAR 0 4
8504: PPUSH
8505: CALL_OW 251
8509: PUSH
8510: LD_VAR 0 4
8514: PPUSH
8515: CALL_OW 254
8519: PUSH
8520: LD_VAR 0 4
8524: PPUSH
8525: CALL_OW 267
8529: PUSH
8530: LD_VAR 0 4
8534: PPUSH
8535: CALL_OW 248
8539: PUSH
8540: LD_VAR 0 4
8544: PPUSH
8545: CALL_OW 256
8549: PUSH
8550: LD_VAR 0 4
8554: PPUSH
8555: LD_INT 1
8557: PPUSH
8558: CALL_OW 268
8562: PUSH
8563: LD_VAR 0 4
8567: PPUSH
8568: LD_INT 2
8570: PPUSH
8571: CALL_OW 268
8575: PUSH
8576: EMPTY
8577: LIST
8578: LIST
8579: LIST
8580: LIST
8581: LIST
8582: LIST
8583: LIST
8584: LIST
8585: LIST
8586: PUSH
8587: EMPTY
8588: LIST
8589: ADD
8590: ST_TO_ADDR
8591: GO 8988
// if GetBType ( i ) in [ b_bunker , b_turret ] then
8593: LD_VAR 0 4
8597: PPUSH
8598: CALL_OW 266
8602: PUSH
8603: LD_INT 32
8605: PUSH
8606: LD_INT 33
8608: PUSH
8609: EMPTY
8610: LIST
8611: LIST
8612: IN
8613: IFFALSE 8721
// buildingsToSave = buildingsToSave ^ [ [ GetBType ( i ) , GetX ( i ) , GetY ( i ) , GetDir ( i ) , GetBLevel ( i ) , GetNation ( i ) , GetLives ( i ) , GetBWeapon ( i ) ] ] else
8615: LD_ADDR_VAR 0 5
8619: PUSH
8620: LD_VAR 0 5
8624: PUSH
8625: LD_VAR 0 4
8629: PPUSH
8630: CALL_OW 266
8634: PUSH
8635: LD_VAR 0 4
8639: PPUSH
8640: CALL_OW 250
8644: PUSH
8645: LD_VAR 0 4
8649: PPUSH
8650: CALL_OW 251
8654: PUSH
8655: LD_VAR 0 4
8659: PPUSH
8660: CALL_OW 254
8664: PUSH
8665: LD_VAR 0 4
8669: PPUSH
8670: CALL_OW 267
8674: PUSH
8675: LD_VAR 0 4
8679: PPUSH
8680: CALL_OW 248
8684: PUSH
8685: LD_VAR 0 4
8689: PPUSH
8690: CALL_OW 256
8694: PUSH
8695: LD_VAR 0 4
8699: PPUSH
8700: CALL_OW 269
8704: PUSH
8705: EMPTY
8706: LIST
8707: LIST
8708: LIST
8709: LIST
8710: LIST
8711: LIST
8712: LIST
8713: LIST
8714: PUSH
8715: EMPTY
8716: LIST
8717: ADD
8718: ST_TO_ADDR
8719: GO 8988
// if GetBType ( i ) in [ b_depot , b_warehouse ] then
8721: LD_VAR 0 4
8725: PPUSH
8726: CALL_OW 266
8730: PUSH
8731: LD_INT 0
8733: PUSH
8734: LD_INT 1
8736: PUSH
8737: EMPTY
8738: LIST
8739: LIST
8740: IN
8741: IFFALSE 8895
// buildingsToSave = buildingsToSave ^ [ [ GetBType ( i ) , GetX ( i ) , GetY ( i ) , GetDir ( i ) , GetBLevel ( i ) , GetNation ( i ) , GetLives ( i ) , GetResourceType ( GetBase ( i ) , mat_cans ) , GetResourceType ( GetBase ( i ) , mat_oil ) , GetResourceType ( GetBase ( i ) , mat_siberit ) ] ] else
8743: LD_ADDR_VAR 0 5
8747: PUSH
8748: LD_VAR 0 5
8752: PUSH
8753: LD_VAR 0 4
8757: PPUSH
8758: CALL_OW 266
8762: PUSH
8763: LD_VAR 0 4
8767: PPUSH
8768: CALL_OW 250
8772: PUSH
8773: LD_VAR 0 4
8777: PPUSH
8778: CALL_OW 251
8782: PUSH
8783: LD_VAR 0 4
8787: PPUSH
8788: CALL_OW 254
8792: PUSH
8793: LD_VAR 0 4
8797: PPUSH
8798: CALL_OW 267
8802: PUSH
8803: LD_VAR 0 4
8807: PPUSH
8808: CALL_OW 248
8812: PUSH
8813: LD_VAR 0 4
8817: PPUSH
8818: CALL_OW 256
8822: PUSH
8823: LD_VAR 0 4
8827: PPUSH
8828: CALL_OW 274
8832: PPUSH
8833: LD_INT 1
8835: PPUSH
8836: CALL_OW 275
8840: PUSH
8841: LD_VAR 0 4
8845: PPUSH
8846: CALL_OW 274
8850: PPUSH
8851: LD_INT 2
8853: PPUSH
8854: CALL_OW 275
8858: PUSH
8859: LD_VAR 0 4
8863: PPUSH
8864: CALL_OW 274
8868: PPUSH
8869: LD_INT 3
8871: PPUSH
8872: CALL_OW 275
8876: PUSH
8877: EMPTY
8878: LIST
8879: LIST
8880: LIST
8881: LIST
8882: LIST
8883: LIST
8884: LIST
8885: LIST
8886: LIST
8887: LIST
8888: PUSH
8889: EMPTY
8890: LIST
8891: ADD
8892: ST_TO_ADDR
8893: GO 8988
// buildingsToSave = buildingsToSave ^ [ [ GetBType ( i ) , GetX ( i ) , GetY ( i ) , GetDir ( i ) , GetBLevel ( i ) , GetNation ( i ) , GetLives ( i ) ] ] ;
8895: LD_ADDR_VAR 0 5
8899: PUSH
8900: LD_VAR 0 5
8904: PUSH
8905: LD_VAR 0 4
8909: PPUSH
8910: CALL_OW 266
8914: PUSH
8915: LD_VAR 0 4
8919: PPUSH
8920: CALL_OW 250
8924: PUSH
8925: LD_VAR 0 4
8929: PPUSH
8930: CALL_OW 251
8934: PUSH
8935: LD_VAR 0 4
8939: PPUSH
8940: CALL_OW 254
8944: PUSH
8945: LD_VAR 0 4
8949: PPUSH
8950: CALL_OW 267
8954: PUSH
8955: LD_VAR 0 4
8959: PPUSH
8960: CALL_OW 248
8964: PUSH
8965: LD_VAR 0 4
8969: PPUSH
8970: CALL_OW 256
8974: PUSH
8975: EMPTY
8976: LIST
8977: LIST
8978: LIST
8979: LIST
8980: LIST
8981: LIST
8982: LIST
8983: PUSH
8984: EMPTY
8985: LIST
8986: ADD
8987: ST_TO_ADDR
// end ;
8988: GO 8441
8990: POP
8991: POP
// SaveVariable ( buildingsToSave , ident ) ;
8992: LD_VAR 0 5
8996: PPUSH
8997: LD_VAR 0 2
9001: PPUSH
9002: CALL_OW 39
// end ; end_of_file
9006: LD_VAR 0 3
9010: RET
// export function MissionIntro ; begin
9011: LD_INT 0
9013: PPUSH
// CenterNowOnUnits ( Burlak ) ;
9014: LD_EXP 57
9018: PPUSH
9019: CALL_OW 87
// DialogueOn ;
9023: CALL_OW 6
// SayRadio ( Popov , DStart-Pop-1 ) ;
9027: LD_EXP 76
9031: PPUSH
9032: LD_STRING DStart-Pop-1
9034: PPUSH
9035: CALL_OW 94
// Say ( Burlak , DStart-Bur-1 ) ;
9039: LD_EXP 57
9043: PPUSH
9044: LD_STRING DStart-Bur-1
9046: PPUSH
9047: CALL_OW 88
// DialogueOff ;
9051: CALL_OW 7
// IngameOff ;
9055: CALL_OW 9
// ChangeMissionObjectives ( MStart ) ;
9059: LD_STRING MStart
9061: PPUSH
9062: CALL_OW 337
// SaveForQuickRestart ;
9066: CALL_OW 22
// end ;
9070: LD_VAR 0 1
9074: RET
// export function Dial_EscortHeike ( x , y ) ; begin
9075: LD_INT 0
9077: PPUSH
// dial_BuildDepotBlocker = true ;
9078: LD_ADDR_EXP 5
9082: PUSH
9083: LD_INT 1
9085: ST_TO_ADDR
// HeikeTargetX = x ;
9086: LD_ADDR_EXP 14
9090: PUSH
9091: LD_VAR 0 1
9095: ST_TO_ADDR
// HeikeTargetY = y ;
9096: LD_ADDR_EXP 15
9100: PUSH
9101: LD_VAR 0 2
9105: ST_TO_ADDR
// SayRadio ( Popov , DHeike-Pop-1 ) ;
9106: LD_EXP 76
9110: PPUSH
9111: LD_STRING DHeike-Pop-1
9113: PPUSH
9114: CALL_OW 94
// wait ( 0 0$10 ) ;
9118: LD_INT 350
9120: PPUSH
9121: CALL_OW 67
// PrepareRussianEscort ;
9125: CALL 2252 0 0
// PlaceUnitArea ( Heike , RussianSpawn2Area , false ) ;
9129: LD_EXP 79
9133: PPUSH
9134: LD_INT 7
9136: PPUSH
9137: LD_INT 0
9139: PPUSH
9140: CALL_OW 49
// ComMoveXY ( russianEscort , HeikeTargetX , HeikeTargetY ) ;
9144: LD_EXP 77
9148: PPUSH
9149: LD_EXP 14
9153: PPUSH
9154: LD_EXP 15
9158: PPUSH
9159: CALL_OW 111
// AddComMoveToArea ( russianEscort , RussianSpawn2Area ) ;
9163: LD_EXP 77
9167: PPUSH
9168: LD_INT 7
9170: PPUSH
9171: CALL_OW 173
// ComMoveXY ( Heike , HeikeTargetX , HeikeTargetY ) ;
9175: LD_EXP 79
9179: PPUSH
9180: LD_EXP 14
9184: PPUSH
9185: LD_EXP 15
9189: PPUSH
9190: CALL_OW 111
// AddComHold ( Heike ) ;
9194: LD_EXP 79
9198: PPUSH
9199: CALL_OW 200
// end ;
9203: LD_VAR 0 3
9207: RET
// every 1 trigger GetDistUnitXY ( Heike , HeikeTargetX , HeikeTargetY ) <= 5 do
9208: LD_EXP 79
9212: PPUSH
9213: LD_EXP 14
9217: PPUSH
9218: LD_EXP 15
9222: PPUSH
9223: CALL_OW 297
9227: PUSH
9228: LD_INT 5
9230: LESSEQUAL
9231: IFFALSE 9244
9233: GO 9235
9235: DISABLE
// allowExitFromMap = 1 ;
9236: LD_ADDR_EXP 18
9240: PUSH
9241: LD_INT 1
9243: ST_TO_ADDR
9244: END
// every 7 7$0 trigger IsPlaced ( Heike ) and IsOk ( Heike ) and GetAttitude ( 3 , 5 ) = att_friend and HeikeCaptured do
9245: LD_EXP 79
9249: PPUSH
9250: CALL_OW 305
9254: PUSH
9255: LD_EXP 79
9259: PPUSH
9260: CALL_OW 302
9264: AND
9265: PUSH
9266: LD_INT 3
9268: PPUSH
9269: LD_INT 5
9271: PPUSH
9272: CALL_OW 81
9276: PUSH
9277: LD_INT 1
9279: EQUAL
9280: AND
9281: PUSH
9282: LD_EXP 1
9286: AND
9287: IFFALSE 9506
9289: GO 9291
9291: DISABLE
// begin DialogueOn ;
9292: CALL_OW 6
// SayRadio ( Kurt , DMercHelp-Kurt-1 ) ;
9296: LD_EXP 80
9300: PPUSH
9301: LD_STRING DMercHelp-Kurt-1
9303: PPUSH
9304: CALL_OW 94
// Say ( Burlak , DMercHelp-Bur-1 ) ;
9308: LD_EXP 57
9312: PPUSH
9313: LD_STRING DMercHelp-Bur-1
9315: PPUSH
9316: CALL_OW 88
// SayRadio ( Kurt , DMercHelp-Kurt-2 ) ;
9320: LD_EXP 80
9324: PPUSH
9325: LD_STRING DMercHelp-Kurt-2
9327: PPUSH
9328: CALL_OW 94
// Say ( Burlak , DMercHelp-Bur-2 ) ;
9332: LD_EXP 57
9336: PPUSH
9337: LD_STRING DMercHelp-Bur-2
9339: PPUSH
9340: CALL_OW 88
// SayRadio ( Kurt , DMercHelp-Kurt-3 ) ;
9344: LD_EXP 80
9348: PPUSH
9349: LD_STRING DMercHelp-Kurt-3
9351: PPUSH
9352: CALL_OW 94
// case Query ( QMerc ) of 1 :
9356: LD_STRING QMerc
9358: PPUSH
9359: CALL_OW 97
9363: PUSH
9364: LD_INT 1
9366: DOUBLE
9367: EQUAL
9368: IFTRUE 9372
9370: GO 9407
9372: POP
// begin Say ( Burlak , DQrMerc#1-Bur-1 ) ;
9373: LD_EXP 57
9377: PPUSH
9378: LD_STRING DQrMerc#1-Bur-1
9380: PPUSH
9381: CALL_OW 88
// SayRadio ( Kurt , DQrMerc#1-Kurt-1 ) ;
9385: LD_EXP 80
9389: PPUSH
9390: LD_STRING DQrMerc#1-Kurt-1
9392: PPUSH
9393: CALL_OW 94
// acceptKurtOffert = true ;
9397: LD_ADDR_EXP 19
9401: PUSH
9402: LD_INT 1
9404: ST_TO_ADDR
// end ; 2 :
9405: GO 9502
9407: LD_INT 2
9409: DOUBLE
9410: EQUAL
9411: IFTRUE 9415
9413: GO 9470
9415: POP
// begin askCommanders = true ;
9416: LD_ADDR_EXP 20
9420: PUSH
9421: LD_INT 1
9423: ST_TO_ADDR
// Say ( Burlak , DQrMerc#2-Bur-1 ) ;
9424: LD_EXP 57
9428: PPUSH
9429: LD_STRING DQrMerc#2-Bur-1
9431: PPUSH
9432: CALL_OW 88
// SayRadio ( Popov , DQrMerc#2-Pop-1 ) ;
9436: LD_EXP 76
9440: PPUSH
9441: LD_STRING DQrMerc#2-Pop-1
9443: PPUSH
9444: CALL_OW 94
// Say ( Burlak , DQrMerc#2-Bur-2 ) ;
9448: LD_EXP 57
9452: PPUSH
9453: LD_STRING DQrMerc#2-Bur-2
9455: PPUSH
9456: CALL_OW 88
// acceptKurtOffert = true ;
9460: LD_ADDR_EXP 19
9464: PUSH
9465: LD_INT 1
9467: ST_TO_ADDR
// end ; 3 :
9468: GO 9502
9470: LD_INT 3
9472: DOUBLE
9473: EQUAL
9474: IFTRUE 9478
9476: GO 9501
9478: POP
// begin Say ( Burlak , DQrMerc#3-Bur-1 ) ;
9479: LD_EXP 57
9483: PPUSH
9484: LD_STRING DQrMerc#3-Bur-1
9486: PPUSH
9487: CALL_OW 88
// KurtAttack = true ;
9491: LD_ADDR_EXP 25
9495: PUSH
9496: LD_INT 1
9498: ST_TO_ADDR
// end ; end ;
9499: GO 9502
9501: POP
// DialogueOff ;
9502: CALL_OW 7
// end ;
9506: END
// every 0 0$1 trigger acceptKurtOffert do
9507: LD_EXP 19
9511: IFFALSE 9667
9513: GO 9515
9515: DISABLE
// begin PlaceUnitArea ( Kurt , KurtSpawnArea , false ) ;
9516: LD_EXP 80
9520: PPUSH
9521: LD_INT 9
9523: PPUSH
9524: LD_INT 0
9526: PPUSH
9527: CALL_OW 49
// uc_side = 8 ;
9531: LD_ADDR_OWVAR 20
9535: PUSH
9536: LD_INT 8
9538: ST_TO_ADDR
// uc_nation = 2 ;
9539: LD_ADDR_OWVAR 21
9543: PUSH
9544: LD_INT 2
9546: ST_TO_ADDR
// PrepareEngineer ( false , 3 ) ;
9547: LD_INT 0
9549: PPUSH
9550: LD_INT 3
9552: PPUSH
9553: CALL_OW 382
// KurtEng = CreateHuman ;
9557: LD_ADDR_EXP 82
9561: PUSH
9562: CALL_OW 44
9566: ST_TO_ADDR
// PlaceUnitArea ( KurtEng , KurtSpawnArea , false ) ;
9567: LD_EXP 82
9571: PPUSH
9572: LD_INT 9
9574: PPUSH
9575: LD_INT 0
9577: PPUSH
9578: CALL_OW 49
// repeat wait ( 0 0$1 ) ;
9582: LD_INT 35
9584: PPUSH
9585: CALL_OW 67
// ComMoveXY ( [ Kurt , KurtEng ] , GetX ( Burlak ) , GetY ( Burlak ) ) ;
9589: LD_EXP 80
9593: PUSH
9594: LD_EXP 82
9598: PUSH
9599: EMPTY
9600: LIST
9601: LIST
9602: PPUSH
9603: LD_EXP 57
9607: PPUSH
9608: CALL_OW 250
9612: PPUSH
9613: LD_EXP 57
9617: PPUSH
9618: CALL_OW 251
9622: PPUSH
9623: CALL_OW 111
// until GetDistUnits ( Kurt , Burlak ) <= 5 or GetDistUnits ( KurtEng , Burlak ) <= 5 ;
9627: LD_EXP 80
9631: PPUSH
9632: LD_EXP 57
9636: PPUSH
9637: CALL_OW 296
9641: PUSH
9642: LD_INT 5
9644: LESSEQUAL
9645: PUSH
9646: LD_EXP 82
9650: PPUSH
9651: LD_EXP 57
9655: PPUSH
9656: CALL_OW 296
9660: PUSH
9661: LD_INT 5
9663: LESSEQUAL
9664: OR
9665: IFFALSE 9582
// end ;
9667: END
// every 0 0$1 trigger GetDistUnits ( Kurt , Burlak ) <= 5 or GetDistUnits ( KurtEng , Burlak ) <= 5 do
9668: LD_EXP 80
9672: PPUSH
9673: LD_EXP 57
9677: PPUSH
9678: CALL_OW 296
9682: PUSH
9683: LD_INT 5
9685: LESSEQUAL
9686: PUSH
9687: LD_EXP 82
9691: PPUSH
9692: LD_EXP 57
9696: PPUSH
9697: CALL_OW 296
9701: PUSH
9702: LD_INT 5
9704: LESSEQUAL
9705: OR
9706: IFFALSE 9885
9708: GO 9710
9710: DISABLE
// begin KurtWaitingForBuildBarrack = true ;
9711: LD_ADDR_EXP 24
9715: PUSH
9716: LD_INT 1
9718: ST_TO_ADDR
// SetSide ( KurtEng , 3 ) ;
9719: LD_EXP 82
9723: PPUSH
9724: LD_INT 3
9726: PPUSH
9727: CALL_OW 235
// wait ( 1 1$30 ) ;
9731: LD_INT 3150
9733: PPUSH
9734: CALL_OW 67
// DialogueOn ;
9738: CALL_OW 6
// SayRadio ( Dietrich , DArabianRequest-Diet-1 ) ;
9742: LD_EXP 81
9746: PPUSH
9747: LD_STRING DArabianRequest-Diet-1
9749: PPUSH
9750: CALL_OW 94
// Say ( Burlak , DArabianRequest-Bur-1 ) ;
9754: LD_EXP 57
9758: PPUSH
9759: LD_STRING DArabianRequest-Bur-1
9761: PPUSH
9762: CALL_OW 88
// SayRadio ( Dietrich , DArabianRequest-Diet-2 ) ;
9766: LD_EXP 81
9770: PPUSH
9771: LD_STRING DArabianRequest-Diet-2
9773: PPUSH
9774: CALL_OW 94
// DialogueOff ;
9778: CALL_OW 7
// case Query ( QHandOver ) of 1 :
9782: LD_STRING QHandOver
9784: PPUSH
9785: CALL_OW 97
9789: PUSH
9790: LD_INT 1
9792: DOUBLE
9793: EQUAL
9794: IFTRUE 9798
9796: GO 9837
9798: POP
// begin Say ( Burlak , DQrHandOver#1-Bur-1 ) ;
9799: LD_EXP 57
9803: PPUSH
9804: LD_STRING DQrHandOver#1-Bur-1
9806: PPUSH
9807: CALL_OW 88
// SayRadio ( Dietrich , DQrHandOver#1-Diet-1 ) ;
9811: LD_EXP 81
9815: PPUSH
9816: LD_STRING DQrHandOver#1-Diet-1
9818: PPUSH
9819: CALL_OW 94
// coopWithGensher = true ;
9823: LD_ADDR_EXP 2
9827: PUSH
9828: LD_INT 1
9830: ST_TO_ADDR
// SpawnGensherTeam ;
9831: CALL 3872 0 0
// end ; 2 :
9835: GO 9885
9837: LD_INT 2
9839: DOUBLE
9840: EQUAL
9841: IFTRUE 9845
9843: GO 9884
9845: POP
// begin Say ( Burlak , DQrHandOver#2-Bur-1 ) ;
9846: LD_EXP 57
9850: PPUSH
9851: LD_STRING DQrHandOver#2-Bur-1
9853: PPUSH
9854: CALL_OW 88
// SayRadio ( Dietrich , DQrHandOver#2-Diet-1 ) ;
9858: LD_EXP 81
9862: PPUSH
9863: LD_STRING DQrHandOver#2-Diet-1
9865: PPUSH
9866: CALL_OW 94
// Say ( Burlak , DQrHandOver#2-Bur-2 ) ;
9870: LD_EXP 57
9874: PPUSH
9875: LD_STRING DQrHandOver#2-Bur-2
9877: PPUSH
9878: CALL_OW 88
// end ; end ;
9882: GO 9885
9884: POP
// end ;
9885: END
// export function Dial_UpgradeArmoury ; begin
9886: LD_INT 0
9888: PPUSH
// dial_BuildArBarrackBlocker = true ;
9889: LD_ADDR_EXP 6
9893: PUSH
9894: LD_INT 1
9896: ST_TO_ADDR
// buildArabBarrack = true ;
9897: LD_ADDR_EXP 38
9901: PUSH
9902: LD_INT 1
9904: ST_TO_ADDR
// if GetSide ( Kurt ) = 2 or GetSide ( KurtEng ) = 8 then
9905: LD_EXP 80
9909: PPUSH
9910: CALL_OW 255
9914: PUSH
9915: LD_INT 2
9917: EQUAL
9918: PUSH
9919: LD_EXP 82
9923: PPUSH
9924: CALL_OW 255
9928: PUSH
9929: LD_INT 8
9931: EQUAL
9932: OR
9933: IFFALSE 9937
// exit ;
9935: GO 10037
// SetSide ( KurtEng , 8 ) ;
9937: LD_EXP 82
9941: PPUSH
9942: LD_INT 8
9944: PPUSH
9945: CALL_OW 235
// ComStop ( KurtEng ) ;
9949: LD_EXP 82
9953: PPUSH
9954: CALL_OW 141
// DialogueOn ;
9958: CALL_OW 6
// Say ( Kurt , DMercCompleted-Kurt-1 ) ;
9962: LD_EXP 80
9966: PPUSH
9967: LD_STRING DMercCompleted-Kurt-1
9969: PPUSH
9970: CALL_OW 88
// DialogueOff ;
9974: CALL_OW 7
// canSendHeike = true ;
9978: LD_ADDR_EXP 28
9982: PUSH
9983: LD_INT 1
9985: ST_TO_ADDR
// KurtWaitingForFreeHeike = true ;
9986: LD_ADDR_EXP 23
9990: PUSH
9991: LD_INT 1
9993: ST_TO_ADDR
// KurtWaitingForBuildBarrack = false ;
9994: LD_ADDR_EXP 24
9998: PUSH
9999: LD_INT 0
10001: ST_TO_ADDR
// allowExitFromMap = 3 ;
10002: LD_ADDR_EXP 18
10006: PUSH
10007: LD_INT 3
10009: ST_TO_ADDR
// if KurtCanEscape then
10010: LD_EXP 21
10014: IFFALSE 10037
// ComMoveToArea ( [ Kurt , KurtEng ] , KurtExitMapArea ) ;
10016: LD_EXP 80
10020: PUSH
10021: LD_EXP 82
10025: PUSH
10026: EMPTY
10027: LIST
10028: LIST
10029: PPUSH
10030: LD_INT 11
10032: PPUSH
10033: CALL_OW 113
// end ;
10037: LD_VAR 0 1
10041: RET
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 2 ] ] ) and not dial_ArriveGensherUnitsBlocker do var veh , nearGensherUnit , maleSold , waitForKurt ;
10042: LD_INT 22
10044: PUSH
10045: LD_INT 2
10047: PUSH
10048: EMPTY
10049: LIST
10050: LIST
10051: PUSH
10052: EMPTY
10053: LIST
10054: PPUSH
10055: CALL_OW 69
10059: PUSH
10060: LD_EXP 7
10064: NOT
10065: AND
10066: IFFALSE 10839
10068: GO 10070
10070: DISABLE
10071: LD_INT 0
10073: PPUSH
10074: PPUSH
10075: PPUSH
10076: PPUSH
// begin nearGensherUnit = NearestUnitToXY ( UnitFilter ( GensherTeam , [ [ f_type , unit_vehicle ] ] ) , GensherTargetX , GensherTargetY ) ;
10077: LD_ADDR_VAR 0 2
10081: PUSH
10082: LD_EXP 83
10086: PPUSH
10087: LD_INT 21
10089: PUSH
10090: LD_INT 2
10092: PUSH
10093: EMPTY
10094: LIST
10095: LIST
10096: PUSH
10097: EMPTY
10098: LIST
10099: PPUSH
10100: CALL_OW 72
10104: PPUSH
10105: LD_EXP 16
10109: PPUSH
10110: LD_EXP 17
10114: PPUSH
10115: CALL_OW 73
10119: ST_TO_ADDR
// maleSold = UnitsInside ( nearGensherUnit [ 1 ] ) ;
10120: LD_ADDR_VAR 0 3
10124: PUSH
10125: LD_VAR 0 2
10129: PUSH
10130: LD_INT 1
10132: ARRAY
10133: PPUSH
10134: CALL_OW 313
10138: ST_TO_ADDR
// if GetDistUnitXY ( nearGensherUnit , GensherTargetX , GensherTargetY ) <= 5 then
10139: LD_VAR 0 2
10143: PPUSH
10144: LD_EXP 16
10148: PPUSH
10149: LD_EXP 17
10153: PPUSH
10154: CALL_OW 297
10158: PUSH
10159: LD_INT 5
10161: LESSEQUAL
10162: IFFALSE 10838
// begin dial_ArriveGensherUnitsBlocker = true ;
10164: LD_ADDR_EXP 7
10168: PUSH
10169: LD_INT 1
10171: ST_TO_ADDR
// for veh in UnitFilter ( GensherTeam , [ [ f_type , unit_vehicle ] ] ) do
10172: LD_ADDR_VAR 0 1
10176: PUSH
10177: LD_EXP 83
10181: PPUSH
10182: LD_INT 21
10184: PUSH
10185: LD_INT 2
10187: PUSH
10188: EMPTY
10189: LIST
10190: LIST
10191: PUSH
10192: EMPTY
10193: LIST
10194: PPUSH
10195: CALL_OW 72
10199: PUSH
10200: FOR_IN
10201: IFFALSE 10223
// ComExitVehicle ( UnitsInside ( veh ) [ 1 ] ) ;
10203: LD_VAR 0 1
10207: PPUSH
10208: CALL_OW 313
10212: PUSH
10213: LD_INT 1
10215: ARRAY
10216: PPUSH
10217: CALL_OW 121
10221: GO 10200
10223: POP
10224: POP
// wait ( 0 0$1 ) ;
10225: LD_INT 35
10227: PPUSH
10228: CALL_OW 67
// SetSide ( UnitFilter ( GensherTeam , [ [ f_type , unit_vehicle ] ] ) , 3 ) ;
10232: LD_EXP 83
10236: PPUSH
10237: LD_INT 21
10239: PUSH
10240: LD_INT 2
10242: PUSH
10243: EMPTY
10244: LIST
10245: LIST
10246: PUSH
10247: EMPTY
10248: LIST
10249: PPUSH
10250: CALL_OW 72
10254: PPUSH
10255: LD_INT 3
10257: PPUSH
10258: CALL_OW 235
// CenterOnUnits ( maleSold ) ;
10262: LD_VAR 0 3
10266: PPUSH
10267: CALL_OW 85
// DialogueOn ;
10271: CALL_OW 6
// Say ( maleSold , DHandOverCome-ASol1-1 ) ;
10275: LD_VAR 0 3
10279: PPUSH
10280: LD_STRING DHandOverCome-ASol1-1
10282: PPUSH
10283: CALL_OW 88
// Say ( Kurt , DHandOverCome-Kurt-1 ) ;
10287: LD_EXP 80
10291: PPUSH
10292: LD_STRING DHandOverCome-Kurt-1
10294: PPUSH
10295: CALL_OW 88
// DialogueOff ;
10299: CALL_OW 7
// KurtWaitingForBuildBarrack = false ;
10303: LD_ADDR_EXP 24
10307: PUSH
10308: LD_INT 0
10310: ST_TO_ADDR
// if GetDistUnits ( Kurt , UnitFilter ( GensherTeam , [ f_type , unit_vehicle ] ) [ 1 ] ) <= 8 or GetSide ( KurtEng ) = 3 then
10311: LD_EXP 80
10315: PPUSH
10316: LD_EXP 83
10320: PPUSH
10321: LD_INT 21
10323: PUSH
10324: LD_INT 2
10326: PUSH
10327: EMPTY
10328: LIST
10329: LIST
10330: PPUSH
10331: CALL_OW 72
10335: PUSH
10336: LD_INT 1
10338: ARRAY
10339: PPUSH
10340: CALL_OW 296
10344: PUSH
10345: LD_INT 8
10347: LESSEQUAL
10348: PUSH
10349: LD_EXP 82
10353: PPUSH
10354: CALL_OW 255
10358: PUSH
10359: LD_INT 3
10361: EQUAL
10362: OR
10363: IFFALSE 10468
// begin KurtCanEscape = false ;
10365: LD_ADDR_EXP 21
10369: PUSH
10370: LD_INT 0
10372: ST_TO_ADDR
// SetSide ( [ Kurt , KurtEng ] , 2 ) ;
10373: LD_EXP 80
10377: PUSH
10378: LD_EXP 82
10382: PUSH
10383: EMPTY
10384: LIST
10385: LIST
10386: PPUSH
10387: LD_INT 2
10389: PPUSH
10390: CALL_OW 235
// ComStop ( [ Kurt , KurtEng ] ) ;
10394: LD_EXP 80
10398: PUSH
10399: LD_EXP 82
10403: PUSH
10404: EMPTY
10405: LIST
10406: LIST
10407: PPUSH
10408: CALL_OW 141
// ComMoveXY ( [ Kurt , KurtEng ] , GetX ( maleSold ) , GetY ( maleSold ) ) ;
10412: LD_EXP 80
10416: PUSH
10417: LD_EXP 82
10421: PUSH
10422: EMPTY
10423: LIST
10424: LIST
10425: PPUSH
10426: LD_VAR 0 3
10430: PPUSH
10431: CALL_OW 250
10435: PPUSH
10436: LD_VAR 0 3
10440: PPUSH
10441: CALL_OW 251
10445: PPUSH
10446: CALL_OW 111
// waitForKurt = true ;
10450: LD_ADDR_VAR 0 4
10454: PUSH
10455: LD_INT 1
10457: ST_TO_ADDR
// KurtStatus = 3 ;
10458: LD_ADDR_EXP 22
10462: PUSH
10463: LD_INT 3
10465: ST_TO_ADDR
// end else
10466: GO 10706
// if GetDistUnits ( Kurt , UnitFilter ( GensherTeam , [ f_type , unit_vehicle ] ) [ 1 ] ) > 8 then
10468: LD_EXP 80
10472: PPUSH
10473: LD_EXP 83
10477: PPUSH
10478: LD_INT 21
10480: PUSH
10481: LD_INT 2
10483: PUSH
10484: EMPTY
10485: LIST
10486: LIST
10487: PPUSH
10488: CALL_OW 72
10492: PUSH
10493: LD_INT 1
10495: ARRAY
10496: PPUSH
10497: CALL_OW 296
10501: PUSH
10502: LD_INT 8
10504: GREATER
10505: IFFALSE 10706
// begin allowExitFromMap = 4 ;
10507: LD_ADDR_EXP 18
10511: PUSH
10512: LD_INT 4
10514: ST_TO_ADDR
// KurtStatus = 2 ;
10515: LD_ADDR_EXP 22
10519: PUSH
10520: LD_INT 2
10522: ST_TO_ADDR
// ComMoveToArea ( [ Kurt , KurtEng ] , KurtExitMapArea ) ;
10523: LD_EXP 80
10527: PUSH
10528: LD_EXP 82
10532: PUSH
10533: EMPTY
10534: LIST
10535: LIST
10536: PPUSH
10537: LD_INT 11
10539: PPUSH
10540: CALL_OW 113
// repeat ComAttackUnit ( UnitFilter ( GensherTeam , [ [ f_type , unit_human ] ] ) , Kurt ) ;
10544: LD_EXP 83
10548: PPUSH
10549: LD_INT 21
10551: PUSH
10552: LD_INT 1
10554: PUSH
10555: EMPTY
10556: LIST
10557: LIST
10558: PUSH
10559: EMPTY
10560: LIST
10561: PPUSH
10562: CALL_OW 72
10566: PPUSH
10567: LD_EXP 80
10571: PPUSH
10572: CALL_OW 115
// wait ( 0 0$1 ) ;
10576: LD_INT 35
10578: PPUSH
10579: CALL_OW 67
// until GetDistUnits ( NearestUnitToUnit ( UnitFilter ( GensherTeam , [ [ f_type , unit_human ] ] ) , Kurt ) , Kurt ) <= 9 or ( not IsPlaced ( Kurt ) and not IsPlaced ( KurtEng ) ) ;
10583: LD_EXP 83
10587: PPUSH
10588: LD_INT 21
10590: PUSH
10591: LD_INT 1
10593: PUSH
10594: EMPTY
10595: LIST
10596: LIST
10597: PUSH
10598: EMPTY
10599: LIST
10600: PPUSH
10601: CALL_OW 72
10605: PPUSH
10606: LD_EXP 80
10610: PPUSH
10611: CALL_OW 74
10615: PPUSH
10616: LD_EXP 80
10620: PPUSH
10621: CALL_OW 296
10625: PUSH
10626: LD_INT 9
10628: LESSEQUAL
10629: PUSH
10630: LD_EXP 80
10634: PPUSH
10635: CALL_OW 305
10639: NOT
10640: PUSH
10641: LD_EXP 82
10645: PPUSH
10646: CALL_OW 305
10650: NOT
10651: AND
10652: OR
10653: IFFALSE 10544
// ComMoveToArea ( [ Kurt , KurtEng ] , ExitMapArea ) ;
10655: LD_EXP 80
10659: PUSH
10660: LD_EXP 82
10664: PUSH
10665: EMPTY
10666: LIST
10667: LIST
10668: PPUSH
10669: LD_INT 8
10671: PPUSH
10672: CALL_OW 113
// ComMoveToArea ( UnitFilter ( GensherTeam , [ [ f_type , unit_human ] ] ) , ExitMapArea ) ;
10676: LD_EXP 83
10680: PPUSH
10681: LD_INT 21
10683: PUSH
10684: LD_INT 1
10686: PUSH
10687: EMPTY
10688: LIST
10689: LIST
10690: PUSH
10691: EMPTY
10692: LIST
10693: PPUSH
10694: CALL_OW 72
10698: PPUSH
10699: LD_INT 8
10701: PPUSH
10702: CALL_OW 113
// end ; if waitForKurt then
10706: LD_VAR 0 4
10710: IFFALSE 10836
// begin repeat wait ( 0 0$1 ) ;
10712: LD_INT 35
10714: PPUSH
10715: CALL_OW 67
// ComMoveXY ( [ Kurt , KurtEng ] , GetX ( maleSold ) , GetY ( maleSold ) ) ;
10719: LD_EXP 80
10723: PUSH
10724: LD_EXP 82
10728: PUSH
10729: EMPTY
10730: LIST
10731: LIST
10732: PPUSH
10733: LD_VAR 0 3
10737: PPUSH
10738: CALL_OW 250
10742: PPUSH
10743: LD_VAR 0 3
10747: PPUSH
10748: CALL_OW 251
10752: PPUSH
10753: CALL_OW 111
// until GetDistUnits ( Kurt , maleSold ) <= 2 ;
10757: LD_EXP 80
10761: PPUSH
10762: LD_VAR 0 3
10766: PPUSH
10767: CALL_OW 296
10771: PUSH
10772: LD_INT 2
10774: LESSEQUAL
10775: IFFALSE 10712
// allowExitFromMap = 4 ;
10777: LD_ADDR_EXP 18
10781: PUSH
10782: LD_INT 4
10784: ST_TO_ADDR
// ComMoveToArea ( [ Kurt , KurtEng ] , ExitMapArea ) ;
10785: LD_EXP 80
10789: PUSH
10790: LD_EXP 82
10794: PUSH
10795: EMPTY
10796: LIST
10797: LIST
10798: PPUSH
10799: LD_INT 8
10801: PPUSH
10802: CALL_OW 113
// ComMoveToArea ( UnitFilter ( GensherTeam , [ [ f_type , unit_human ] ] ) , ExitMapArea ) ;
10806: LD_EXP 83
10810: PPUSH
10811: LD_INT 21
10813: PUSH
10814: LD_INT 1
10816: PUSH
10817: EMPTY
10818: LIST
10819: LIST
10820: PUSH
10821: EMPTY
10822: LIST
10823: PPUSH
10824: CALL_OW 72
10828: PPUSH
10829: LD_INT 8
10831: PPUSH
10832: CALL_OW 113
// end ; exit ;
10836: GO 10839
// end ; enable ;
10838: ENABLE
// end ;
10839: PPOPN 4
10841: END
// export function Dial_AttackGensher ; var unit ; begin
10842: LD_INT 0
10844: PPUSH
10845: PPUSH
// DialogueOn ;
10846: CALL_OW 6
// SayRadio ( Dietrich , DHandOverSpoiled-Diet-1 ) ;
10850: LD_EXP 81
10854: PPUSH
10855: LD_STRING DHandOverSpoiled-Diet-1
10857: PPUSH
10858: CALL_OW 94
// DialogueOff ;
10862: CALL_OW 7
// SetAttitude ( 3 , 2 , att_enemy , true ) ;
10866: LD_INT 3
10868: PPUSH
10869: LD_INT 2
10871: PPUSH
10872: LD_INT 2
10874: PPUSH
10875: LD_INT 1
10877: PPUSH
10878: CALL_OW 80
// for unit in UnitFilter ( GensherTeam , [ [ f_type , unit_human ] ] ) do
10882: LD_ADDR_VAR 0 2
10886: PUSH
10887: LD_EXP 83
10891: PPUSH
10892: LD_INT 21
10894: PUSH
10895: LD_INT 1
10897: PUSH
10898: EMPTY
10899: LIST
10900: LIST
10901: PUSH
10902: EMPTY
10903: LIST
10904: PPUSH
10905: CALL_OW 72
10909: PUSH
10910: FOR_IN
10911: IFFALSE 10971
// begin if IsInUnit ( unit ) then
10913: LD_VAR 0 2
10917: PPUSH
10918: CALL_OW 310
10922: IFFALSE 10933
// ComExitVehicle ( unit ) ;
10924: LD_VAR 0 2
10928: PPUSH
10929: CALL_OW 121
// wait ( 0 0$01 ) ;
10933: LD_INT 35
10935: PPUSH
10936: CALL_OW 67
// AddComAgressiveMove ( unit , GetX ( Burlak ) , GetY ( Burlak ) ) ;
10940: LD_VAR 0 2
10944: PPUSH
10945: LD_EXP 57
10949: PPUSH
10950: CALL_OW 250
10954: PPUSH
10955: LD_EXP 57
10959: PPUSH
10960: CALL_OW 251
10964: PPUSH
10965: CALL_OW 174
// end ;
10969: GO 10910
10971: POP
10972: POP
// coopWithGensher = 2 ;
10973: LD_ADDR_EXP 2
10977: PUSH
10978: LD_INT 2
10980: ST_TO_ADDR
// end ;
10981: LD_VAR 0 1
10985: RET
// every 0 0$1 trigger canSendHeike and IsOK ( Heike ) and GetSide ( Heike ) = 5 do var legionSold ;
10986: LD_EXP 28
10990: PUSH
10991: LD_EXP 79
10995: PPUSH
10996: CALL_OW 302
11000: AND
11001: PUSH
11002: LD_EXP 79
11006: PPUSH
11007: CALL_OW 255
11011: PUSH
11012: LD_INT 5
11014: EQUAL
11015: AND
11016: IFFALSE 11336
11018: GO 11020
11020: DISABLE
11021: LD_INT 0
11023: PPUSH
// begin if IsSelected ( Heike ) then
11024: LD_EXP 79
11028: PPUSH
11029: CALL_OW 306
11033: IFFALSE 11328
// begin if Query ( QSendHeike ) = 1 then
11035: LD_STRING QSendHeike
11037: PPUSH
11038: CALL_OW 97
11042: PUSH
11043: LD_INT 1
11045: EQUAL
11046: IFFALSE 11328
// begin KurtWaitingForFreeHeike = false ;
11048: LD_ADDR_EXP 23
11052: PUSH
11053: LD_INT 0
11055: ST_TO_ADDR
// ComMoveXY ( Heike , 82 , 46 ) ;
11056: LD_EXP 79
11060: PPUSH
11061: LD_INT 82
11063: PPUSH
11064: LD_INT 46
11066: PPUSH
11067: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
11071: LD_INT 35
11073: PPUSH
11074: CALL_OW 67
// until GetDistUnitXY ( Heike , 82 , 46 ) <= 5 or IsDead ( Heike ) ;
11078: LD_EXP 79
11082: PPUSH
11083: LD_INT 82
11085: PPUSH
11086: LD_INT 46
11088: PPUSH
11089: CALL_OW 297
11093: PUSH
11094: LD_INT 5
11096: LESSEQUAL
11097: PUSH
11098: LD_EXP 79
11102: PPUSH
11103: CALL_OW 301
11107: OR
11108: IFFALSE 11071
// if not askCommanders then
11110: LD_EXP 20
11114: NOT
11115: IFFALSE 11161
// begin DialogueOn ;
11117: CALL_OW 6
// SayRadio ( Popov , DMercPopov-Pop-1 ) ;
11121: LD_EXP 76
11125: PPUSH
11126: LD_STRING DMercPopov-Pop-1
11128: PPUSH
11129: CALL_OW 94
// Say ( Burlak , DMercPopov-Bur-1 ) ;
11133: LD_EXP 57
11137: PPUSH
11138: LD_STRING DMercPopov-Bur-1
11140: PPUSH
11141: CALL_OW 88
// SayRadio ( Popov , DMercPopov-Pop-2 ) ;
11145: LD_EXP 76
11149: PPUSH
11150: LD_STRING DMercPopov-Pop-2
11152: PPUSH
11153: CALL_OW 94
// DialogueOff ;
11157: CALL_OW 7
// end ; uc_side = 8 ;
11161: LD_ADDR_OWVAR 20
11165: PUSH
11166: LD_INT 8
11168: ST_TO_ADDR
// uc_nation = 2 ;
11169: LD_ADDR_OWVAR 21
11173: PUSH
11174: LD_INT 2
11176: ST_TO_ADDR
// PrepareSoldier ( false , 6 ) ;
11177: LD_INT 0
11179: PPUSH
11180: LD_INT 6
11182: PPUSH
11183: CALL_OW 381
// legionSold = CreateHuman ;
11187: LD_ADDR_VAR 0 1
11191: PUSH
11192: CALL_OW 44
11196: ST_TO_ADDR
// PlaceUnitXYR ( legionSold , 26 , 48 , 4 , false ) ;
11197: LD_VAR 0 1
11201: PPUSH
11202: LD_INT 26
11204: PPUSH
11205: LD_INT 48
11207: PPUSH
11208: LD_INT 4
11210: PPUSH
11211: LD_INT 0
11213: PPUSH
11214: CALL_OW 50
// repeat wait ( 0 0$1 ) ;
11218: LD_INT 35
11220: PPUSH
11221: CALL_OW 67
// ComMoveXY ( legionSold , GetX ( Heike ) , GetY ( Heike ) ) ;
11225: LD_VAR 0 1
11229: PPUSH
11230: LD_EXP 79
11234: PPUSH
11235: CALL_OW 250
11239: PPUSH
11240: LD_EXP 79
11244: PPUSH
11245: CALL_OW 251
11249: PPUSH
11250: CALL_OW 111
// until GetDistUnits ( legionSold , Heike ) <= 5 or IsDead ( Heike ) ;
11254: LD_VAR 0 1
11258: PPUSH
11259: LD_EXP 79
11263: PPUSH
11264: CALL_OW 296
11268: PUSH
11269: LD_INT 5
11271: LESSEQUAL
11272: PUSH
11273: LD_EXP 79
11277: PPUSH
11278: CALL_OW 301
11282: OR
11283: IFFALSE 11218
// SetSide ( Heike , 8 ) ;
11285: LD_EXP 79
11289: PPUSH
11290: LD_INT 8
11292: PPUSH
11293: CALL_OW 235
// allowExitFromMap = 3 ;
11297: LD_ADDR_EXP 18
11301: PUSH
11302: LD_INT 3
11304: ST_TO_ADDR
// ComMoveToArea ( [ legionSold , Heike ] , KurtExitMapArea ) ;
11305: LD_VAR 0 1
11309: PUSH
11310: LD_EXP 79
11314: PUSH
11315: EMPTY
11316: LIST
11317: LIST
11318: PPUSH
11319: LD_INT 11
11321: PPUSH
11322: CALL_OW 113
// exit ;
11326: GO 11336
// end ; end ; wait ( 0 0$3 ) ;
11328: LD_INT 105
11330: PPUSH
11331: CALL_OW 67
// enable ;
11335: ENABLE
// end ;
11336: PPOPN 1
11338: END
// export function Dial_PlayerDontSendHeike ; begin
11339: LD_INT 0
11341: PPUSH
// DialogueOn ;
11342: CALL_OW 6
// SayRadio ( Kurt , DMercDeceived-Kurt-1 ) ;
11346: LD_EXP 80
11350: PPUSH
11351: LD_STRING DMercDeceived-Kurt-1
11353: PPUSH
11354: CALL_OW 94
// DialogueOff ;
11358: CALL_OW 7
// SetAttitude ( 3 , 8 , att_enemy , true ) ;
11362: LD_INT 3
11364: PPUSH
11365: LD_INT 8
11367: PPUSH
11368: LD_INT 2
11370: PPUSH
11371: LD_INT 1
11373: PPUSH
11374: CALL_OW 80
// KurtAttack = true ;
11378: LD_ADDR_EXP 25
11382: PUSH
11383: LD_INT 1
11385: ST_TO_ADDR
// end ;
11386: LD_VAR 0 1
11390: RET
// export function Dial_BetrayedKurt1 ; begin
11391: LD_INT 0
11393: PPUSH
// DialogueOn ;
11394: CALL_OW 6
// Say ( Kurt , DMercDeceived-Kurt-1 ) ;
11398: LD_EXP 80
11402: PPUSH
11403: LD_STRING DMercDeceived-Kurt-1
11405: PPUSH
11406: CALL_OW 88
// DialogueOff ;
11410: CALL_OW 7
// if IsPlaced ( Kurt ) then
11414: LD_EXP 80
11418: PPUSH
11419: CALL_OW 305
11423: IFFALSE 11472
// begin SetSide ( KurtEng , 8 ) ;
11425: LD_EXP 82
11429: PPUSH
11430: LD_INT 8
11432: PPUSH
11433: CALL_OW 235
// allowExitFromMap = 3 ;
11437: LD_ADDR_EXP 18
11441: PUSH
11442: LD_INT 3
11444: ST_TO_ADDR
// if KurtCanEscape then
11445: LD_EXP 21
11449: IFFALSE 11472
// ComMoveToArea ( [ Kurt , KurtEng ] , KurtExitMapArea ) ;
11451: LD_EXP 80
11455: PUSH
11456: LD_EXP 82
11460: PUSH
11461: EMPTY
11462: LIST
11463: LIST
11464: PPUSH
11465: LD_INT 11
11467: PPUSH
11468: CALL_OW 113
// end ; end ;
11472: LD_VAR 0 1
11476: RET
// export function Dial_BetrayedKurt2 ; begin
11477: LD_INT 0
11479: PPUSH
// DialogueOn ;
11480: CALL_OW 6
// Say ( Kurt , DMercAmbush-Kurt-1 ) ;
11484: LD_EXP 80
11488: PPUSH
11489: LD_STRING DMercAmbush-Kurt-1
11491: PPUSH
11492: CALL_OW 88
// DialogueOff ;
11496: CALL_OW 7
// if IsPlaced ( Kurt ) then
11500: LD_EXP 80
11504: PPUSH
11505: CALL_OW 305
11509: IFFALSE 11558
// begin SetSide ( KurtEng , 8 ) ;
11511: LD_EXP 82
11515: PPUSH
11516: LD_INT 8
11518: PPUSH
11519: CALL_OW 235
// allowExitFromMap = 3 ;
11523: LD_ADDR_EXP 18
11527: PUSH
11528: LD_INT 3
11530: ST_TO_ADDR
// if KurtCanEscape then
11531: LD_EXP 21
11535: IFFALSE 11558
// ComMoveToArea ( [ Kurt , KurtEng ] , KurtExitMapArea ) ;
11537: LD_EXP 80
11541: PUSH
11542: LD_EXP 82
11546: PUSH
11547: EMPTY
11548: LIST
11549: LIST
11550: PPUSH
11551: LD_INT 11
11553: PPUSH
11554: CALL_OW 113
// end ; end ;
11558: LD_VAR 0 1
11562: RET
// every 0 0$1 trigger GetSide ( KurtEng ) = 3 do var playerUnits , unit ;
11563: LD_EXP 82
11567: PPUSH
11568: CALL_OW 255
11572: PUSH
11573: LD_INT 3
11575: EQUAL
11576: IFFALSE 11723
11578: GO 11580
11580: DISABLE
11581: LD_INT 0
11583: PPUSH
11584: PPUSH
// begin playerUnits = FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
11585: LD_ADDR_VAR 0 1
11589: PUSH
11590: LD_INT 22
11592: PUSH
11593: LD_INT 3
11595: PUSH
11596: EMPTY
11597: LIST
11598: LIST
11599: PUSH
11600: LD_INT 2
11602: PUSH
11603: LD_INT 21
11605: PUSH
11606: LD_INT 1
11608: PUSH
11609: EMPTY
11610: LIST
11611: LIST
11612: PUSH
11613: LD_INT 21
11615: PUSH
11616: LD_INT 2
11618: PUSH
11619: EMPTY
11620: LIST
11621: LIST
11622: PUSH
11623: EMPTY
11624: LIST
11625: LIST
11626: LIST
11627: PUSH
11628: EMPTY
11629: LIST
11630: LIST
11631: PPUSH
11632: CALL_OW 69
11636: ST_TO_ADDR
// for unit in playerUnits do
11637: LD_ADDR_VAR 0 2
11641: PUSH
11642: LD_VAR 0 1
11646: PUSH
11647: FOR_IN
11648: IFFALSE 11677
// begin if WantsToAttack ( unit ) = KurtEng then
11650: LD_VAR 0 2
11654: PPUSH
11655: CALL_OW 319
11659: PUSH
11660: LD_EXP 82
11664: EQUAL
11665: IFFALSE 11675
// begin Dial_BetrayedKurt2 ;
11667: CALL 11477 0 0
// exit ;
11671: POP
11672: POP
11673: GO 11723
// end ; end ;
11675: GO 11647
11677: POP
11678: POP
// if ( IsDying ( KurtEng ) or IsDead ( KurtEng ) ) and GetSide ( KurtEng ) = 3 then
11679: LD_EXP 82
11683: PPUSH
11684: CALL_OW 303
11688: PUSH
11689: LD_EXP 82
11693: PPUSH
11694: CALL_OW 301
11698: OR
11699: PUSH
11700: LD_EXP 82
11704: PPUSH
11705: CALL_OW 255
11709: PUSH
11710: LD_INT 3
11712: EQUAL
11713: AND
11714: IFFALSE 11722
// begin Dial_BetrayedKurt2 ;
11716: CALL 11477 0 0
// exit ;
11720: GO 11723
// end ; enable ;
11722: ENABLE
// end ;
11723: PPOPN 2
11725: END
// every 0 0$1 trigger GetAttitude ( 3 , 8 ) = att_neutral and GetLives ( Kurt ) <= 999 do
11726: LD_INT 3
11728: PPUSH
11729: LD_INT 8
11731: PPUSH
11732: CALL_OW 81
11736: PUSH
11737: LD_INT 0
11739: EQUAL
11740: PUSH
11741: LD_EXP 80
11745: PPUSH
11746: CALL_OW 256
11750: PUSH
11751: LD_INT 999
11753: LESSEQUAL
11754: AND
11755: IFFALSE 11780
11757: GO 11759
11759: DISABLE
// begin Dial_BetrayedKurt1 ;
11760: CALL 11391 0 0
// SetAttitude ( 3 , 8 , att_enemy , true ) ;
11764: LD_INT 3
11766: PPUSH
11767: LD_INT 8
11769: PPUSH
11770: LD_INT 2
11772: PPUSH
11773: LD_INT 1
11775: PPUSH
11776: CALL_OW 80
// end ;
11780: END
// every 0 0$1 trigger buildingsToBuild <= 11 do
11781: LD_EXP 8
11785: PUSH
11786: LD_INT 11
11788: LESSEQUAL
11789: IFFALSE 12038
11791: GO 11793
11793: DISABLE
// begin if not IsOK ( Kuzmov ) and not IsOK ( Oblukov ) then
11794: LD_EXP 72
11798: PPUSH
11799: CALL_OW 302
11803: NOT
11804: PUSH
11805: LD_EXP 74
11809: PPUSH
11810: CALL_OW 302
11814: NOT
11815: AND
11816: IFFALSE 11820
// exit ;
11818: GO 12038
// DialogueOn ;
11820: CALL_OW 6
// if IsOK ( Kuzmov ) then
11824: LD_EXP 72
11828: PPUSH
11829: CALL_OW 302
11833: IFFALSE 11849
// Say ( Kuzmov , DFiringRange-Kuz-1 ) else
11835: LD_EXP 72
11839: PPUSH
11840: LD_STRING DFiringRange-Kuz-1
11842: PPUSH
11843: CALL_OW 88
11847: GO 11861
// Say ( Oblukov , DFiringRange-Obl-1 ) ;
11849: LD_EXP 74
11853: PPUSH
11854: LD_STRING DFiringRange-Obl-1
11856: PPUSH
11857: CALL_OW 88
// Say ( Burlak , DFiringRange-Bur-1 ) ;
11861: LD_EXP 57
11865: PPUSH
11866: LD_STRING DFiringRange-Bur-1
11868: PPUSH
11869: CALL_OW 88
// CenterOnXY ( 99 , 30 ) ;
11873: LD_INT 99
11875: PPUSH
11876: LD_INT 30
11878: PPUSH
11879: CALL_OW 84
// Wait ( 0 0$0.5 ) ;
11883: LD_INT 18
11885: PPUSH
11886: CALL_OW 67
// RevealFogArea ( 3 , ShootArea ) ;
11890: LD_INT 3
11892: PPUSH
11893: LD_INT 12
11895: PPUSH
11896: CALL_OW 332
// SetAreaMapShow ( ShootArea , 1 ) ;
11900: LD_INT 12
11902: PPUSH
11903: LD_INT 1
11905: PPUSH
11906: CALL_OW 424
// if IsOK ( Kuzmov ) then
11910: LD_EXP 72
11914: PPUSH
11915: CALL_OW 302
11919: IFFALSE 11935
// Say ( Kuzmov , DFiringRange-Kuz-2 ) else
11921: LD_EXP 72
11925: PPUSH
11926: LD_STRING DFiringRange-Kuz-2
11928: PPUSH
11929: CALL_OW 88
11933: GO 11947
// Say ( Oblukov , DFiringRange-Obl-2 ) ;
11935: LD_EXP 74
11939: PPUSH
11940: LD_STRING DFiringRange-Obl-2
11942: PPUSH
11943: CALL_OW 88
// case Query ( QShootingGallery ) of 1 :
11947: LD_STRING QShootingGallery
11949: PPUSH
11950: CALL_OW 97
11954: PUSH
11955: LD_INT 1
11957: DOUBLE
11958: EQUAL
11959: IFTRUE 11963
11961: GO 12000
11963: POP
// begin Say ( Burlak , DQrShootingGallery#1-Bur-1 ) ;
11964: LD_EXP 57
11968: PPUSH
11969: LD_STRING DQrShootingGallery#1-Bur-1
11971: PPUSH
11972: CALL_OW 88
// BurlakRespect = BurlakRespect + 1 ;
11976: LD_ADDR_EXP 30
11980: PUSH
11981: LD_EXP 30
11985: PUSH
11986: LD_INT 1
11988: PLUS
11989: ST_TO_ADDR
// canShootTrening = true ;
11990: LD_ADDR_EXP 29
11994: PUSH
11995: LD_INT 1
11997: ST_TO_ADDR
// end ; 2 :
11998: GO 12034
12000: LD_INT 2
12002: DOUBLE
12003: EQUAL
12004: IFTRUE 12008
12006: GO 12033
12008: POP
// begin Say ( Burlak , DQrShootingGallery#2-Bur-1 ) ;
12009: LD_EXP 57
12013: PPUSH
12014: LD_STRING DQrShootingGallery#2-Bur-1
12016: PPUSH
12017: CALL_OW 88
// SetAreaMapShow ( ShootArea , 0 ) ;
12021: LD_INT 12
12023: PPUSH
12024: LD_INT 0
12026: PPUSH
12027: CALL_OW 424
// end ; end ;
12031: GO 12034
12033: POP
// DialogueOff ;
12034: CALL_OW 7
// end ;
12038: END
// every 0 0$1 trigger canShootTrening do
12039: LD_EXP 29
12043: IFFALSE 12053
12045: GO 12047
12047: DISABLE
// begin enable ;
12048: ENABLE
// ShootTreningController ;
12049: CALL 7017 0 0
// end ;
12053: END
// every 0 0$1 trigger buildingsToBuild <= 7 do var hunters , hunter ;
12054: LD_EXP 8
12058: PUSH
12059: LD_INT 7
12061: LESSEQUAL
12062: IFFALSE 12452
12064: GO 12066
12066: DISABLE
12067: LD_INT 0
12069: PPUSH
12070: PPUSH
// begin hunters = [ ] ;
12071: LD_ADDR_VAR 0 1
12075: PUSH
12076: EMPTY
12077: ST_TO_ADDR
// if IsOK ( Belkov ) then
12078: LD_EXP 66
12082: PPUSH
12083: CALL_OW 302
12087: IFFALSE 12105
// hunters = hunters ^ Belkov ;
12089: LD_ADDR_VAR 0 1
12093: PUSH
12094: LD_VAR 0 1
12098: PUSH
12099: LD_EXP 66
12103: ADD
12104: ST_TO_ADDR
// if IsOK ( Karamazov ) then
12105: LD_EXP 58
12109: PPUSH
12110: CALL_OW 302
12114: IFFALSE 12132
// hunters = hunters ^ Karamazov ;
12116: LD_ADDR_VAR 0 1
12120: PUSH
12121: LD_VAR 0 1
12125: PUSH
12126: LD_EXP 58
12130: ADD
12131: ST_TO_ADDR
// if IsOK ( Kozlov ) then
12132: LD_EXP 73
12136: PPUSH
12137: CALL_OW 302
12141: IFFALSE 12159
// hunters = hunters ^ Kozlov ;
12143: LD_ADDR_VAR 0 1
12147: PUSH
12148: LD_VAR 0 1
12152: PUSH
12153: LD_EXP 73
12157: ADD
12158: ST_TO_ADDR
// if not hunters then
12159: LD_VAR 0 1
12163: NOT
12164: IFFALSE 12168
// exit ;
12166: GO 12452
// hunter = hunters [ Rand ( 1 , hunters ) ] ;
12168: LD_ADDR_VAR 0 2
12172: PUSH
12173: LD_VAR 0 1
12177: PUSH
12178: LD_INT 1
12180: PPUSH
12181: LD_VAR 0 1
12185: PPUSH
12186: CALL_OW 12
12190: ARRAY
12191: ST_TO_ADDR
// DialogueOn ;
12192: CALL_OW 6
// case hunter of Belkov :
12196: LD_VAR 0 2
12200: PUSH
12201: LD_EXP 66
12205: DOUBLE
12206: EQUAL
12207: IFTRUE 12211
12209: GO 12226
12211: POP
// Say ( Belkov , DHunting-Bel-1 ) ; Karamazov :
12212: LD_EXP 66
12216: PPUSH
12217: LD_STRING DHunting-Bel-1
12219: PPUSH
12220: CALL_OW 88
12224: GO 12277
12226: LD_EXP 58
12230: DOUBLE
12231: EQUAL
12232: IFTRUE 12236
12234: GO 12251
12236: POP
// Say ( Karamazov , DHunting-Kar-1 ) ; Kozlov :
12237: LD_EXP 58
12241: PPUSH
12242: LD_STRING DHunting-Kar-1
12244: PPUSH
12245: CALL_OW 88
12249: GO 12277
12251: LD_EXP 73
12255: DOUBLE
12256: EQUAL
12257: IFTRUE 12261
12259: GO 12276
12261: POP
// Say ( Kozlov , DHunting-Koz-1 ) ; end ;
12262: LD_EXP 73
12266: PPUSH
12267: LD_STRING DHunting-Koz-1
12269: PPUSH
12270: CALL_OW 88
12274: GO 12277
12276: POP
// Say ( Burlak , DHunting-Bur-1 ) ;
12277: LD_EXP 57
12281: PPUSH
12282: LD_STRING DHunting-Bur-1
12284: PPUSH
12285: CALL_OW 88
// case hunter of Belkov :
12289: LD_VAR 0 2
12293: PUSH
12294: LD_EXP 66
12298: DOUBLE
12299: EQUAL
12300: IFTRUE 12304
12302: GO 12319
12304: POP
// Say ( Belkov , DHunting-Bel-2 ) ; Karamazov :
12305: LD_EXP 66
12309: PPUSH
12310: LD_STRING DHunting-Bel-2
12312: PPUSH
12313: CALL_OW 88
12317: GO 12370
12319: LD_EXP 58
12323: DOUBLE
12324: EQUAL
12325: IFTRUE 12329
12327: GO 12344
12329: POP
// Say ( Karamazov , DHunting-Kar-2 ) ; Kozlov :
12330: LD_EXP 58
12334: PPUSH
12335: LD_STRING DHunting-Kar-2
12337: PPUSH
12338: CALL_OW 88
12342: GO 12370
12344: LD_EXP 73
12348: DOUBLE
12349: EQUAL
12350: IFTRUE 12354
12352: GO 12369
12354: POP
// Say ( Kozlov , DHunting-Koz-2 ) ; end ;
12355: LD_EXP 73
12359: PPUSH
12360: LD_STRING DHunting-Koz-2
12362: PPUSH
12363: CALL_OW 88
12367: GO 12370
12369: POP
// DialogueOff ;
12370: CALL_OW 7
// case Query ( QHunting ) of 1 :
12374: LD_STRING QHunting
12376: PPUSH
12377: CALL_OW 97
12381: PUSH
12382: LD_INT 1
12384: DOUBLE
12385: EQUAL
12386: IFTRUE 12390
12388: GO 12428
12390: POP
// begin Say ( Burlak , DQrHunting#1-Bur-1 ) ;
12391: LD_EXP 57
12395: PPUSH
12396: LD_STRING DQrHunting#1-Bur-1
12398: PPUSH
12399: CALL_OW 88
// BurlakRespect = BurlakRespect + 1 ;
12403: LD_ADDR_EXP 30
12407: PUSH
12408: LD_EXP 30
12412: PUSH
12413: LD_INT 1
12415: PLUS
12416: ST_TO_ADDR
// GoToHunt ( hunter ) ;
12417: LD_VAR 0 2
12421: PPUSH
12422: CALL 7645 0 1
// end ; 2 :
12426: GO 12452
12428: LD_INT 2
12430: DOUBLE
12431: EQUAL
12432: IFTRUE 12436
12434: GO 12451
12436: POP
// Say ( Burlak , DQrHunting#2-Bur-1 ) ; end ;
12437: LD_EXP 57
12441: PPUSH
12442: LD_STRING DQrHunting#2-Bur-1
12444: PPUSH
12445: CALL_OW 88
12449: GO 12452
12451: POP
// end ;
12452: PPOPN 2
12454: END
// every 0 0$1 trigger buildingsToBuild <= 3 do var unit , womans , men , woman , man , depots ;
12455: LD_EXP 8
12459: PUSH
12460: LD_INT 3
12462: LESSEQUAL
12463: IFFALSE 13450
12465: GO 12467
12467: DISABLE
12468: LD_INT 0
12470: PPUSH
12471: PPUSH
12472: PPUSH
12473: PPUSH
12474: PPUSH
12475: PPUSH
// begin womans = [ ] ;
12476: LD_ADDR_VAR 0 2
12480: PUSH
12481: EMPTY
12482: ST_TO_ADDR
// men = [ ] ;
12483: LD_ADDR_VAR 0 3
12487: PUSH
12488: EMPTY
12489: ST_TO_ADDR
// if IsOK ( Petrovova ) then
12490: LD_EXP 59
12494: PPUSH
12495: CALL_OW 302
12499: IFFALSE 12517
// womans = womans ^ Petrovova ;
12501: LD_ADDR_VAR 0 2
12505: PUSH
12506: LD_VAR 0 2
12510: PUSH
12511: LD_EXP 59
12515: ADD
12516: ST_TO_ADDR
// if IsOK ( Kirilenkova ) then
12517: LD_EXP 65
12521: PPUSH
12522: CALL_OW 302
12526: IFFALSE 12544
// womans = womans ^ Kirilenkova ;
12528: LD_ADDR_VAR 0 2
12532: PUSH
12533: LD_VAR 0 2
12537: PUSH
12538: LD_EXP 65
12542: ADD
12543: ST_TO_ADDR
// if IsOK ( Kapitsova ) then
12544: LD_EXP 75
12548: PPUSH
12549: CALL_OW 302
12553: IFFALSE 12571
// womans = womans ^ Kapitsova ;
12555: LD_ADDR_VAR 0 2
12559: PUSH
12560: LD_VAR 0 2
12564: PUSH
12565: LD_EXP 75
12569: ADD
12570: ST_TO_ADDR
// DialogueOn ;
12571: CALL_OW 6
// if womans then
12575: LD_VAR 0 2
12579: IFFALSE 12706
// begin case womans [ Rand ( 1 , womans ) ] of Petrovova :
12581: LD_VAR 0 2
12585: PUSH
12586: LD_INT 1
12588: PPUSH
12589: LD_VAR 0 2
12593: PPUSH
12594: CALL_OW 12
12598: ARRAY
12599: PUSH
12600: LD_EXP 59
12604: DOUBLE
12605: EQUAL
12606: IFTRUE 12610
12608: GO 12635
12610: POP
// begin Say ( Petrovova , DFreeTime-Ptr-1 ) ;
12611: LD_EXP 59
12615: PPUSH
12616: LD_STRING DFreeTime-Ptr-1
12618: PPUSH
12619: CALL_OW 88
// woman = Petrovova ;
12623: LD_ADDR_VAR 0 4
12627: PUSH
12628: LD_EXP 59
12632: ST_TO_ADDR
// end ; Kirilenkova :
12633: GO 12706
12635: LD_EXP 65
12639: DOUBLE
12640: EQUAL
12641: IFTRUE 12645
12643: GO 12670
12645: POP
// begin Say ( Kirilenkova , DFreeTime-Kir-1 ) ;
12646: LD_EXP 65
12650: PPUSH
12651: LD_STRING DFreeTime-Kir-1
12653: PPUSH
12654: CALL_OW 88
// woman = Kirilenkova ;
12658: LD_ADDR_VAR 0 4
12662: PUSH
12663: LD_EXP 65
12667: ST_TO_ADDR
// end ; Kapitsova :
12668: GO 12706
12670: LD_EXP 75
12674: DOUBLE
12675: EQUAL
12676: IFTRUE 12680
12678: GO 12705
12680: POP
// begin Say ( Kapitsova , DFreeTime-Kap-1 ) ;
12681: LD_EXP 75
12685: PPUSH
12686: LD_STRING DFreeTime-Kap-1
12688: PPUSH
12689: CALL_OW 88
// woman = Kapitsova ;
12693: LD_ADDR_VAR 0 4
12697: PUSH
12698: LD_EXP 75
12702: ST_TO_ADDR
// end ; end ;
12703: GO 12706
12705: POP
// end ; if IsOK ( Kuzmov ) then
12706: LD_EXP 72
12710: PPUSH
12711: CALL_OW 302
12715: IFFALSE 12733
// men = men ^ Kuzmov ;
12717: LD_ADDR_VAR 0 3
12721: PUSH
12722: LD_VAR 0 3
12726: PUSH
12727: LD_EXP 72
12731: ADD
12732: ST_TO_ADDR
// if IsOK ( Titov ) then
12733: LD_EXP 62
12737: PPUSH
12738: CALL_OW 302
12742: IFFALSE 12760
// men = men ^ Titov ;
12744: LD_ADDR_VAR 0 3
12748: PUSH
12749: LD_VAR 0 3
12753: PUSH
12754: LD_EXP 62
12758: ADD
12759: ST_TO_ADDR
// if IsOK ( Gnyevko ) then
12760: LD_EXP 69
12764: PPUSH
12765: CALL_OW 302
12769: IFFALSE 12787
// men = men ^ Gnyevko ;
12771: LD_ADDR_VAR 0 3
12775: PUSH
12776: LD_VAR 0 3
12780: PUSH
12781: LD_EXP 69
12785: ADD
12786: ST_TO_ADDR
// if IsOK ( Oblukov ) then
12787: LD_EXP 74
12791: PPUSH
12792: CALL_OW 302
12796: IFFALSE 12814
// men = men ^ Oblukov ;
12798: LD_ADDR_VAR 0 3
12802: PUSH
12803: LD_VAR 0 3
12807: PUSH
12808: LD_EXP 74
12812: ADD
12813: ST_TO_ADDR
// if men then
12814: LD_VAR 0 3
12818: IFFALSE 12980
// begin case men [ Rand ( 1 , men ) ] of Kuzmov :
12820: LD_VAR 0 3
12824: PUSH
12825: LD_INT 1
12827: PPUSH
12828: LD_VAR 0 3
12832: PPUSH
12833: CALL_OW 12
12837: ARRAY
12838: PUSH
12839: LD_EXP 72
12843: DOUBLE
12844: EQUAL
12845: IFTRUE 12849
12847: GO 12874
12849: POP
// begin Say ( Kuzmov , DFreeTime-Kuz-1 ) ;
12850: LD_EXP 72
12854: PPUSH
12855: LD_STRING DFreeTime-Kuz-1
12857: PPUSH
12858: CALL_OW 88
// man = Kuzmov ;
12862: LD_ADDR_VAR 0 5
12866: PUSH
12867: LD_EXP 72
12871: ST_TO_ADDR
// end ; Titov :
12872: GO 12980
12874: LD_EXP 62
12878: DOUBLE
12879: EQUAL
12880: IFTRUE 12884
12882: GO 12909
12884: POP
// begin Say ( Titov , DFreeTime-Tit-1 ) ;
12885: LD_EXP 62
12889: PPUSH
12890: LD_STRING DFreeTime-Tit-1
12892: PPUSH
12893: CALL_OW 88
// man = Titov ;
12897: LD_ADDR_VAR 0 5
12901: PUSH
12902: LD_EXP 62
12906: ST_TO_ADDR
// end ; Gnyevko :
12907: GO 12980
12909: LD_EXP 69
12913: DOUBLE
12914: EQUAL
12915: IFTRUE 12919
12917: GO 12944
12919: POP
// begin Say ( Gnyevko , DFreeTime-Gny-1 ) ;
12920: LD_EXP 69
12924: PPUSH
12925: LD_STRING DFreeTime-Gny-1
12927: PPUSH
12928: CALL_OW 88
// man = Gnyevko ;
12932: LD_ADDR_VAR 0 5
12936: PUSH
12937: LD_EXP 69
12941: ST_TO_ADDR
// end ; Oblukov :
12942: GO 12980
12944: LD_EXP 74
12948: DOUBLE
12949: EQUAL
12950: IFTRUE 12954
12952: GO 12979
12954: POP
// begin Say ( Oblukov , DFreeTime-Obl-1 ) ;
12955: LD_EXP 74
12959: PPUSH
12960: LD_STRING DFreeTime-Obl-1
12962: PPUSH
12963: CALL_OW 88
// man = Oblukov ;
12967: LD_ADDR_VAR 0 5
12971: PUSH
12972: LD_EXP 74
12976: ST_TO_ADDR
// end ; end ;
12977: GO 12980
12979: POP
// end ; DialogueOff ;
12980: CALL_OW 7
// if not woman and not man then
12984: LD_VAR 0 4
12988: NOT
12989: PUSH
12990: LD_VAR 0 5
12994: NOT
12995: AND
12996: IFFALSE 13004
// begin DialogueOff ;
12998: CALL_OW 7
// exit ;
13002: GO 13450
// end ; case Query ( QFreeTime ) of 1 :
13004: LD_STRING QFreeTime
13006: PPUSH
13007: CALL_OW 97
13011: PUSH
13012: LD_INT 1
13014: DOUBLE
13015: EQUAL
13016: IFTRUE 13020
13018: GO 13422
13020: POP
// begin Say ( Burlak , DQrFreeTime#1-Bur-1 ) ;
13021: LD_EXP 57
13025: PPUSH
13026: LD_STRING DQrFreeTime#1-Bur-1
13028: PPUSH
13029: CALL_OW 88
// DialogueOff ;
13033: CALL_OW 7
// BurlakRespect = BurlakRespect + 1 ;
13037: LD_ADDR_EXP 30
13041: PUSH
13042: LD_EXP 30
13046: PUSH
13047: LD_INT 1
13049: PLUS
13050: ST_TO_ADDR
// SetSide ( [ woman , man ] , 6 ) ;
13051: LD_VAR 0 4
13055: PUSH
13056: LD_VAR 0 5
13060: PUSH
13061: EMPTY
13062: LIST
13063: LIST
13064: PPUSH
13065: LD_INT 6
13067: PPUSH
13068: CALL_OW 235
// for unit in [ woman , man ] do
13072: LD_ADDR_VAR 0 1
13076: PUSH
13077: LD_VAR 0 4
13081: PUSH
13082: LD_VAR 0 5
13086: PUSH
13087: EMPTY
13088: LIST
13089: LIST
13090: PUSH
13091: FOR_IN
13092: IFFALSE 13147
// if IsInUnit ( unit ) then
13094: LD_VAR 0 1
13098: PPUSH
13099: CALL_OW 310
13103: IFFALSE 13145
// begin if GetType ( IsInUnit ( unit ) ) = unit_vehicle then
13105: LD_VAR 0 1
13109: PPUSH
13110: CALL_OW 310
13114: PPUSH
13115: CALL_OW 247
13119: PUSH
13120: LD_INT 2
13122: EQUAL
13123: IFFALSE 13136
// ComExitVehicle ( unit ) else
13125: LD_VAR 0 1
13129: PPUSH
13130: CALL_OW 121
13134: GO 13145
// ComExitBuilding ( unit ) ;
13136: LD_VAR 0 1
13140: PPUSH
13141: CALL_OW 122
// end ;
13145: GO 13091
13147: POP
13148: POP
// wait ( 0 0$1 ) ;
13149: LD_INT 35
13151: PPUSH
13152: CALL_OW 67
// ComMoveToArea ( [ woman , man ] , ExitMapArea ) ;
13156: LD_VAR 0 4
13160: PUSH
13161: LD_VAR 0 5
13165: PUSH
13166: EMPTY
13167: LIST
13168: LIST
13169: PPUSH
13170: LD_INT 8
13172: PPUSH
13173: CALL_OW 113
// allowExitFromMap = 1 ;
13177: LD_ADDR_EXP 18
13181: PUSH
13182: LD_INT 1
13184: ST_TO_ADDR
// wait ( 3 3$0 ) ;
13185: LD_INT 6300
13187: PPUSH
13188: CALL_OW 67
// PlaceUnitXYR ( woman , 157 , 29 , 3 , false ) ;
13192: LD_VAR 0 4
13196: PPUSH
13197: LD_INT 157
13199: PPUSH
13200: LD_INT 29
13202: PPUSH
13203: LD_INT 3
13205: PPUSH
13206: LD_INT 0
13208: PPUSH
13209: CALL_OW 50
// PlaceUnitXYR ( man , 157 , 29 , 3 , false ) ;
13213: LD_VAR 0 5
13217: PPUSH
13218: LD_INT 157
13220: PPUSH
13221: LD_INT 29
13223: PPUSH
13224: LD_INT 3
13226: PPUSH
13227: LD_INT 0
13229: PPUSH
13230: CALL_OW 50
// SetSide ( [ woman , man ] , 3 ) ;
13234: LD_VAR 0 4
13238: PUSH
13239: LD_VAR 0 5
13243: PUSH
13244: EMPTY
13245: LIST
13246: LIST
13247: PPUSH
13248: LD_INT 3
13250: PPUSH
13251: CALL_OW 235
// depots = FilterAllUnits ( [ [ f_side , 3 ] , [ [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ] ) ;
13255: LD_ADDR_VAR 0 6
13259: PUSH
13260: LD_INT 22
13262: PUSH
13263: LD_INT 3
13265: PUSH
13266: EMPTY
13267: LIST
13268: LIST
13269: PUSH
13270: LD_INT 2
13272: PUSH
13273: LD_INT 30
13275: PUSH
13276: LD_INT 0
13278: PUSH
13279: EMPTY
13280: LIST
13281: LIST
13282: PUSH
13283: LD_INT 30
13285: PUSH
13286: LD_INT 1
13288: PUSH
13289: EMPTY
13290: LIST
13291: LIST
13292: PUSH
13293: EMPTY
13294: LIST
13295: LIST
13296: LIST
13297: PUSH
13298: EMPTY
13299: LIST
13300: PUSH
13301: EMPTY
13302: LIST
13303: LIST
13304: PPUSH
13305: CALL_OW 69
13309: ST_TO_ADDR
// if depots then
13310: LD_VAR 0 6
13314: IFFALSE 13364
// ComMoveXY ( [ woman , man ] , GetX ( depots [ 1 ] ) , GetY ( depots [ 1 ] ) ) else
13316: LD_VAR 0 4
13320: PUSH
13321: LD_VAR 0 5
13325: PUSH
13326: EMPTY
13327: LIST
13328: LIST
13329: PPUSH
13330: LD_VAR 0 6
13334: PUSH
13335: LD_INT 1
13337: ARRAY
13338: PPUSH
13339: CALL_OW 250
13343: PPUSH
13344: LD_VAR 0 6
13348: PUSH
13349: LD_INT 1
13351: ARRAY
13352: PPUSH
13353: CALL_OW 251
13357: PPUSH
13358: CALL_OW 111
13362: GO 13402
// ComMoveXY ( [ woman , man ] , GetX ( Burlak ) , GetY ( Burlak ) ) ;
13364: LD_VAR 0 4
13368: PUSH
13369: LD_VAR 0 5
13373: PUSH
13374: EMPTY
13375: LIST
13376: LIST
13377: PPUSH
13378: LD_EXP 57
13382: PPUSH
13383: CALL_OW 250
13387: PPUSH
13388: LD_EXP 57
13392: PPUSH
13393: CALL_OW 251
13397: PPUSH
13398: CALL_OW 111
// CenterOnUnits ( [ woman , man ] ) ;
13402: LD_VAR 0 4
13406: PUSH
13407: LD_VAR 0 5
13411: PUSH
13412: EMPTY
13413: LIST
13414: LIST
13415: PPUSH
13416: CALL_OW 85
// end ; 2 :
13420: GO 13446
13422: LD_INT 2
13424: DOUBLE
13425: EQUAL
13426: IFTRUE 13430
13428: GO 13445
13430: POP
// Say ( Burlak , DQrFreeTime#2-Bur-1 ) ; end ;
13431: LD_EXP 57
13435: PPUSH
13436: LD_STRING DQrFreeTime#2-Bur-1
13438: PPUSH
13439: CALL_OW 88
13443: GO 13446
13445: POP
// DialogueOff ;
13446: CALL_OW 7
// end ;
13450: PPOPN 6
13452: END
// every 0 0$1 trigger GetAmountWeaponsDataBuildOnVehicle ( false ) <= 2 do
13453: LD_INT 0
13455: PPUSH
13456: CALL 6726 0 1
13460: PUSH
13461: LD_INT 2
13463: LESSEQUAL
13464: IFFALSE 13599
13466: GO 13468
13468: DISABLE
// begin DialogueOn ;
13469: CALL_OW 6
// if IsOK ( Kozlov ) then
13473: LD_EXP 73
13477: PPUSH
13478: CALL_OW 302
13482: IFFALSE 13498
// Say ( Kozlov , DMasha-Koz-1 ) else
13484: LD_EXP 73
13488: PPUSH
13489: LD_STRING DMasha-Koz-1
13491: PPUSH
13492: CALL_OW 88
13496: GO 13561
// DialogRandom ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_ok ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) , DMasha-Koz-1 ,  , false , false ) ;
13498: LD_INT 22
13500: PUSH
13501: LD_INT 3
13503: PUSH
13504: EMPTY
13505: LIST
13506: LIST
13507: PUSH
13508: LD_INT 50
13510: PUSH
13511: EMPTY
13512: LIST
13513: PUSH
13514: LD_INT 21
13516: PUSH
13517: LD_INT 1
13519: PUSH
13520: EMPTY
13521: LIST
13522: LIST
13523: PUSH
13524: LD_INT 26
13526: PUSH
13527: LD_INT 1
13529: PUSH
13530: EMPTY
13531: LIST
13532: LIST
13533: PUSH
13534: EMPTY
13535: LIST
13536: LIST
13537: LIST
13538: LIST
13539: PPUSH
13540: CALL_OW 69
13544: PPUSH
13545: LD_STRING DMasha-Koz-1
13547: PPUSH
13548: LD_STRING 
13550: PPUSH
13551: LD_INT 0
13553: PPUSH
13554: LD_INT 0
13556: PPUSH
13557: CALL 6175 0 5
// Say ( Burlak , DMasha2-Bur-1 ) ;
13561: LD_EXP 57
13565: PPUSH
13566: LD_STRING DMasha2-Bur-1
13568: PPUSH
13569: CALL_OW 88
// DialogueOff ;
13573: CALL_OW 7
// Query ( QMasha ) ;
13577: LD_STRING QMasha
13579: PPUSH
13580: CALL_OW 97
// ChangeMissionObjectives ( MMasha ) ;
13584: LD_STRING MMasha
13586: PPUSH
13587: CALL_OW 337
// canChooseMashaVehicle = true ;
13591: LD_ADDR_EXP 36
13595: PUSH
13596: LD_INT 1
13598: ST_TO_ADDR
// end ;
13599: END
// export function Dial_ComputerTechResearched ; begin
13600: LD_INT 0
13602: PPUSH
// if IsOk ( Scholtze ) or IsOK ( Kapitsova ) then
13603: LD_EXP 71
13607: PPUSH
13608: CALL_OW 302
13612: PUSH
13613: LD_EXP 75
13617: PPUSH
13618: CALL_OW 302
13622: OR
13623: IFFALSE 13719
// begin DialogueOn ;
13625: CALL_OW 6
// if IsOK ( Scholtze ) then
13629: LD_EXP 71
13633: PPUSH
13634: CALL_OW 302
13638: IFFALSE 13654
// Say ( Scholtze , DAI-Sch-1 ) else
13640: LD_EXP 71
13644: PPUSH
13645: LD_STRING DAI-Sch-1
13647: PPUSH
13648: CALL_OW 88
13652: GO 13666
// Say ( Kapitsova , DAI-Kap-1 ) ;
13654: LD_EXP 75
13658: PPUSH
13659: LD_STRING DAI-Kap-1
13661: PPUSH
13662: CALL_OW 88
// Say ( Burlak , DAI-Bur-1 ) ;
13666: LD_EXP 57
13670: PPUSH
13671: LD_STRING DAI-Bur-1
13673: PPUSH
13674: CALL_OW 88
// if IsOK ( Scholtze ) then
13678: LD_EXP 71
13682: PPUSH
13683: CALL_OW 302
13687: IFFALSE 13703
// Say ( Scholtze , DAI-Sch-2 ) else
13689: LD_EXP 71
13693: PPUSH
13694: LD_STRING DAI-Sch-2
13696: PPUSH
13697: CALL_OW 88
13701: GO 13715
// Say ( Kapitsova , DAI-Kap-2 ) ;
13703: LD_EXP 75
13707: PPUSH
13708: LD_STRING DAI-Kap-2
13710: PPUSH
13711: CALL_OW 88
// DialogueOff ;
13715: CALL_OW 7
// end ; ChangeMissionObjectives ( MAI ) ;
13719: LD_STRING MAI
13721: PPUSH
13722: CALL_OW 337
// end ;
13726: LD_VAR 0 1
13730: RET
// export function Dial_TeleportTechResearched ; begin
13731: LD_INT 0
13733: PPUSH
// if IsOk ( Scholtze ) or IsOK ( Kapitsova ) then
13734: LD_EXP 71
13738: PPUSH
13739: CALL_OW 302
13743: PUSH
13744: LD_EXP 75
13748: PPUSH
13749: CALL_OW 302
13753: OR
13754: IFFALSE 13862
// begin DialogueOn ;
13756: CALL_OW 6
// if IsOK ( Scholtze ) then
13760: LD_EXP 71
13764: PPUSH
13765: CALL_OW 302
13769: IFFALSE 13785
// Say ( Scholtze , DSpontTelep-Sch-1 ) else
13771: LD_EXP 71
13775: PPUSH
13776: LD_STRING DSpontTelep-Sch-1
13778: PPUSH
13779: CALL_OW 88
13783: GO 13797
// Say ( Kapitsova , DSpontTelep-Kap-1 ) ;
13785: LD_EXP 75
13789: PPUSH
13790: LD_STRING DSpontTelep-Kap-1
13792: PPUSH
13793: CALL_OW 88
// Say ( Burlak , DSpontTelep-Bur-1 ) ;
13797: LD_EXP 57
13801: PPUSH
13802: LD_STRING DSpontTelep-Bur-1
13804: PPUSH
13805: CALL_OW 88
// if IsOK ( Scholtze ) then
13809: LD_EXP 71
13813: PPUSH
13814: CALL_OW 302
13818: IFFALSE 13834
// Say ( Scholtze , DSpontTelep-Sch-2 ) else
13820: LD_EXP 71
13824: PPUSH
13825: LD_STRING DSpontTelep-Sch-2
13827: PPUSH
13828: CALL_OW 88
13832: GO 13846
// Say ( Kapitsova , DSpontTelep-Kap-2 ) ;
13834: LD_EXP 75
13838: PPUSH
13839: LD_STRING DSpontTelep-Kap-2
13841: PPUSH
13842: CALL_OW 88
// Say ( Burlak , DSpontTelep-Bur-2 ) ;
13846: LD_EXP 57
13850: PPUSH
13851: LD_STRING DSpontTelep-Bur-2
13853: PPUSH
13854: CALL_OW 88
// DialogueOff ;
13858: CALL_OW 7
// end ; ChangeMissionObjectives ( MTele ) ;
13862: LD_STRING MTele
13864: PPUSH
13865: CALL_OW 337
// end ;
13869: LD_VAR 0 1
13873: RET
// every 0 0$1 trigger buildingsToBuild <= 3 and GetAmountWeaponsDataBuildOnVehicle ( false ) <= 1 and techsToResearch <= 4 do
13874: LD_EXP 8
13878: PUSH
13879: LD_INT 3
13881: LESSEQUAL
13882: PUSH
13883: LD_INT 0
13885: PPUSH
13886: CALL 6726 0 1
13890: PUSH
13891: LD_INT 1
13893: LESSEQUAL
13894: AND
13895: PUSH
13896: LD_EXP 9
13900: PUSH
13901: LD_INT 4
13903: LESSEQUAL
13904: AND
13905: IFFALSE 14106
13907: GO 13909
13909: DISABLE
// begin SayRadio ( Popov , DAmAttackStart-Pop-1 ) ;
13910: LD_EXP 76
13914: PPUSH
13915: LD_STRING DAmAttackStart-Pop-1
13917: PPUSH
13918: CALL_OW 94
// if KurtStatus = 1 and HeikeStatus = 1 then
13922: LD_EXP 22
13926: PUSH
13927: LD_INT 1
13929: EQUAL
13930: PUSH
13931: LD_EXP 3
13935: PUSH
13936: LD_INT 1
13938: EQUAL
13939: AND
13940: IFFALSE 14098
// begin wait ( 0 0$10 ) ;
13942: LD_INT 350
13944: PPUSH
13945: CALL_OW 67
// DialogueOn ;
13949: CALL_OW 6
// SayRadio ( Heike , DLegionFormed-Hke-1 ) ;
13953: LD_EXP 79
13957: PPUSH
13958: LD_STRING DLegionFormed-Hke-1
13960: PPUSH
13961: CALL_OW 94
// Say ( Burlak , DLegionFormed-Bur-1 ) ;
13965: LD_EXP 57
13969: PPUSH
13970: LD_STRING DLegionFormed-Bur-1
13972: PPUSH
13973: CALL_OW 88
// SayRadio ( Heike , DLegionFormed-Hke-2 ) ;
13977: LD_EXP 79
13981: PPUSH
13982: LD_STRING DLegionFormed-Hke-2
13984: PPUSH
13985: CALL_OW 94
// Say ( Burlak , DLegionFormed-Bur-2 ) ;
13989: LD_EXP 57
13993: PPUSH
13994: LD_STRING DLegionFormed-Bur-2
13996: PPUSH
13997: CALL_OW 88
// SayRadio ( Heike , DLegionFormed-Hke-3 ) ;
14001: LD_EXP 79
14005: PPUSH
14006: LD_STRING DLegionFormed-Hke-3
14008: PPUSH
14009: CALL_OW 94
// case Query ( QLegion ) of 1 :
14013: LD_STRING QLegion
14015: PPUSH
14016: CALL_OW 97
14020: PUSH
14021: LD_INT 1
14023: DOUBLE
14024: EQUAL
14025: IFTRUE 14029
14027: GO 14060
14029: POP
// begin acceptLegionOffert = true ;
14030: LD_ADDR_EXP 31
14034: PUSH
14035: LD_INT 1
14037: ST_TO_ADDR
// legionOffertCountdown = true ;
14038: LD_ADDR_EXP 33
14042: PUSH
14043: LD_INT 1
14045: ST_TO_ADDR
// Say ( Burlak , DQrLegion#1-Bur-1 ) ;
14046: LD_EXP 57
14050: PPUSH
14051: LD_STRING DQrLegion#1-Bur-1
14053: PPUSH
14054: CALL_OW 88
// end ; 2 :
14058: GO 14092
14060: LD_INT 2
14062: DOUBLE
14063: EQUAL
14064: IFTRUE 14068
14066: GO 14091
14068: POP
// begin Say ( Burlak , DQrLegion#2-Bur-1 ) ;
14069: LD_EXP 57
14073: PPUSH
14074: LD_STRING DQrLegion#2-Bur-1
14076: PPUSH
14077: CALL_OW 88
// americansAttack = true ;
14081: LD_ADDR_EXP 26
14085: PUSH
14086: LD_INT 1
14088: ST_TO_ADDR
// end ; end ;
14089: GO 14092
14091: POP
// DialogueOff ;
14092: CALL_OW 7
// end else
14096: GO 14106
// begin americansAttack = true ;
14098: LD_ADDR_EXP 26
14102: PUSH
14103: LD_INT 1
14105: ST_TO_ADDR
// end ; end ;
14106: END
// every 0 0$1 trigger legionOffertTime <= 0 0$00 do
14107: LD_EXP 34
14111: PUSH
14112: LD_INT 0
14114: LESSEQUAL
14115: IFFALSE 14136
14117: GO 14119
14119: DISABLE
// begin legionOffertCountdown = false ;
14120: LD_ADDR_EXP 33
14124: PUSH
14125: LD_INT 0
14127: ST_TO_ADDR
// americansAttack = true ;
14128: LD_ADDR_EXP 26
14132: PUSH
14133: LD_INT 1
14135: ST_TO_ADDR
// end ;
14136: END
// every 0 0$1 trigger legionOffertCountdown do var needCrates , depots , depot , crates ;
14137: LD_EXP 33
14141: IFFALSE 14327
14143: GO 14145
14145: DISABLE
14146: LD_INT 0
14148: PPUSH
14149: PPUSH
14150: PPUSH
14151: PPUSH
// begin needCrates = 50 ;
14152: LD_ADDR_VAR 0 1
14156: PUSH
14157: LD_INT 50
14159: ST_TO_ADDR
// crates = 0 ;
14160: LD_ADDR_VAR 0 4
14164: PUSH
14165: LD_INT 0
14167: ST_TO_ADDR
// depots = FilterAllUnits ( [ [ f_side , 3 ] , [ [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ] ) ;
14168: LD_ADDR_VAR 0 2
14172: PUSH
14173: LD_INT 22
14175: PUSH
14176: LD_INT 3
14178: PUSH
14179: EMPTY
14180: LIST
14181: LIST
14182: PUSH
14183: LD_INT 2
14185: PUSH
14186: LD_INT 30
14188: PUSH
14189: LD_INT 0
14191: PUSH
14192: EMPTY
14193: LIST
14194: LIST
14195: PUSH
14196: LD_INT 30
14198: PUSH
14199: LD_INT 1
14201: PUSH
14202: EMPTY
14203: LIST
14204: LIST
14205: PUSH
14206: EMPTY
14207: LIST
14208: LIST
14209: LIST
14210: PUSH
14211: EMPTY
14212: LIST
14213: PUSH
14214: EMPTY
14215: LIST
14216: LIST
14217: PPUSH
14218: CALL_OW 69
14222: ST_TO_ADDR
// for depot in depots do
14223: LD_ADDR_VAR 0 3
14227: PUSH
14228: LD_VAR 0 2
14232: PUSH
14233: FOR_IN
14234: IFFALSE 14325
// begin crates = GetResourceType ( GetBase ( depot ) , mat_cans ) ;
14236: LD_ADDR_VAR 0 4
14240: PUSH
14241: LD_VAR 0 3
14245: PPUSH
14246: CALL_OW 274
14250: PPUSH
14251: LD_INT 1
14253: PPUSH
14254: CALL_OW 275
14258: ST_TO_ADDR
// if crates >= needCrates then
14259: LD_VAR 0 4
14263: PUSH
14264: LD_VAR 0 1
14268: GREATEREQUAL
14269: IFFALSE 14323
// begin SetResourceType ( GetBase ( depot ) , mat_cans , crates - needCrates ) ;
14271: LD_VAR 0 3
14275: PPUSH
14276: CALL_OW 274
14280: PPUSH
14281: LD_INT 1
14283: PPUSH
14284: LD_VAR 0 4
14288: PUSH
14289: LD_VAR 0 1
14293: MINUS
14294: PPUSH
14295: CALL_OW 277
// legionOffertCountdown = false ;
14299: LD_ADDR_EXP 33
14303: PUSH
14304: LD_INT 0
14306: ST_TO_ADDR
// paidLegionOffert = true ;
14307: LD_ADDR_EXP 32
14311: PUSH
14312: LD_INT 1
14314: ST_TO_ADDR
// americansAttack = true ;
14315: LD_ADDR_EXP 26
14319: PUSH
14320: LD_INT 1
14322: ST_TO_ADDR
// end ; end ;
14323: GO 14233
14325: POP
14326: POP
// end ;
14327: PPOPN 4
14329: END
// every 0 0$1 trigger currentAmWave >= americansAttackWaves and FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_type , unit_human ] , [ f_and , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ] ] ) = 0 do
14330: LD_EXP 85
14334: PUSH
14335: LD_EXP 48
14339: GREATEREQUAL
14340: PUSH
14341: LD_INT 22
14343: PUSH
14344: LD_INT 1
14346: PUSH
14347: EMPTY
14348: LIST
14349: LIST
14350: PUSH
14351: LD_INT 2
14353: PUSH
14354: LD_INT 21
14356: PUSH
14357: LD_INT 1
14359: PUSH
14360: EMPTY
14361: LIST
14362: LIST
14363: PUSH
14364: LD_INT 1
14366: PUSH
14367: LD_INT 21
14369: PUSH
14370: LD_INT 2
14372: PUSH
14373: EMPTY
14374: LIST
14375: LIST
14376: PUSH
14377: LD_INT 33
14379: PUSH
14380: LD_INT 3
14382: PUSH
14383: EMPTY
14384: LIST
14385: LIST
14386: PUSH
14387: EMPTY
14388: LIST
14389: LIST
14390: LIST
14391: PUSH
14392: EMPTY
14393: LIST
14394: LIST
14395: LIST
14396: PUSH
14397: EMPTY
14398: LIST
14399: LIST
14400: PPUSH
14401: CALL_OW 69
14405: PUSH
14406: LD_INT 0
14408: EQUAL
14409: AND
14410: IFFALSE 14610
14412: GO 14414
14414: DISABLE
// begin DialogueOn ;
14415: CALL_OW 6
// if IsOK ( Belkov ) then
14419: LD_EXP 66
14423: PPUSH
14424: CALL_OW 302
14428: IFFALSE 14444
// Say ( Belkov , DAmAttackFin-Bel-1 ) else
14430: LD_EXP 66
14434: PPUSH
14435: LD_STRING DAmAttackFin-Bel-1
14437: PPUSH
14438: CALL_OW 88
14442: GO 14467
// if IsOK ( Belkov2 ) then
14444: LD_EXP 67
14448: PPUSH
14449: CALL_OW 302
14453: IFFALSE 14467
// Say ( Belkov2 , DAmAttackFin-Bel-1 ) ;
14455: LD_EXP 67
14459: PPUSH
14460: LD_STRING DAmAttackFin-Bel-1
14462: PPUSH
14463: CALL_OW 88
// if IsOK ( Gnyevko ) then
14467: LD_EXP 69
14471: PPUSH
14472: CALL_OW 302
14476: IFFALSE 14490
// Say ( Gnyevko , DAmAttackFin-Gny-1 ) ;
14478: LD_EXP 69
14482: PPUSH
14483: LD_STRING DAmAttackFin-Gny-1
14485: PPUSH
14486: CALL_OW 88
// if IsOK ( Titov ) then
14490: LD_EXP 62
14494: PPUSH
14495: CALL_OW 302
14499: IFFALSE 14513
// Say ( Titov , DAmAttackFin-Tit-1 ) ;
14501: LD_EXP 62
14505: PPUSH
14506: LD_STRING DAmAttackFin-Tit-1
14508: PPUSH
14509: CALL_OW 88
// if IsOK ( Lipshchin ) then
14513: LD_EXP 64
14517: PPUSH
14518: CALL_OW 302
14522: IFFALSE 14536
// Say ( Lipshchin , DAmAttackFin-Lip-1 ) ;
14524: LD_EXP 64
14528: PPUSH
14529: LD_STRING DAmAttackFin-Lip-1
14531: PPUSH
14532: CALL_OW 88
// if IsOK ( Karamazov ) then
14536: LD_EXP 58
14540: PPUSH
14541: CALL_OW 302
14545: IFFALSE 14559
// Say ( Karamazov , DAmAttackFin-Kar-1 ) ;
14547: LD_EXP 58
14551: PPUSH
14552: LD_STRING DAmAttackFin-Kar-1
14554: PPUSH
14555: CALL_OW 88
// if IsOK ( Oblukov ) then
14559: LD_EXP 74
14563: PPUSH
14564: CALL_OW 302
14568: IFFALSE 14582
// Say ( Oblukov , DAmAttackFin-Obl-1 ) ;
14570: LD_EXP 74
14574: PPUSH
14575: LD_STRING DAmAttackFin-Obl-1
14577: PPUSH
14578: CALL_OW 88
// Say ( Burlak , AmAttackFin-Bur-1 ) ;
14582: LD_EXP 57
14586: PPUSH
14587: LD_STRING AmAttackFin-Bur-1
14589: PPUSH
14590: CALL_OW 88
// SayRadio ( Popov , DAmAttackFin-Pop-1 ) ;
14594: LD_EXP 76
14598: PPUSH
14599: LD_STRING DAmAttackFin-Pop-1
14601: PPUSH
14602: CALL_OW 94
// DialogueOff ;
14606: CALL_OW 7
// end ;
14610: END
// every 0 0$1 trigger buildingsToBuild + ( 3 - GetAmountWeaponsDataBuildOnTurret ( true ) ) = 0 do
14611: LD_EXP 8
14615: PUSH
14616: LD_INT 3
14618: PUSH
14619: LD_INT 1
14621: PPUSH
14622: CALL 6616 0 1
14626: MINUS
14627: PLUS
14628: PUSH
14629: LD_INT 0
14631: EQUAL
14632: IFFALSE 14644
14634: GO 14636
14636: DISABLE
// ChangeMissionObjectives ( MBuildingsDone ) ;
14637: LD_STRING MBuildingsDone
14639: PPUSH
14640: CALL_OW 337
14644: END
// every 0 0$1 trigger GetAmountWeaponsDataBuildOnVehicle ( false ) = 0 do
14645: LD_INT 0
14647: PPUSH
14648: CALL 6726 0 1
14652: PUSH
14653: LD_INT 0
14655: EQUAL
14656: IFFALSE 14668
14658: GO 14660
14660: DISABLE
// ChangeMissionObjectives ( MWeaponsDone ) ;
14661: LD_STRING MWeaponsDone
14663: PPUSH
14664: CALL_OW 337
14668: END
// every 0 0$1 trigger techsToResearch = 0 do
14669: LD_EXP 9
14673: PUSH
14674: LD_INT 0
14676: EQUAL
14677: IFFALSE 14689
14679: GO 14681
14681: DISABLE
// ChangeMissionObjectives ( MTechnoDone ) ;
14682: LD_STRING MTechnoDone
14684: PPUSH
14685: CALL_OW 337
14689: END
// every 0 0$1 trigger americansAttack and not FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_type , unit_human ] , [ f_and , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ] ] ) do
14690: LD_EXP 26
14694: PUSH
14695: LD_INT 22
14697: PUSH
14698: LD_INT 1
14700: PUSH
14701: EMPTY
14702: LIST
14703: LIST
14704: PUSH
14705: LD_INT 2
14707: PUSH
14708: LD_INT 21
14710: PUSH
14711: LD_INT 1
14713: PUSH
14714: EMPTY
14715: LIST
14716: LIST
14717: PUSH
14718: LD_INT 1
14720: PUSH
14721: LD_INT 21
14723: PUSH
14724: LD_INT 2
14726: PUSH
14727: EMPTY
14728: LIST
14729: LIST
14730: PUSH
14731: LD_INT 33
14733: PUSH
14734: LD_INT 3
14736: PUSH
14737: EMPTY
14738: LIST
14739: LIST
14740: PUSH
14741: EMPTY
14742: LIST
14743: LIST
14744: LIST
14745: PUSH
14746: EMPTY
14747: LIST
14748: LIST
14749: LIST
14750: PUSH
14751: EMPTY
14752: LIST
14753: LIST
14754: PPUSH
14755: CALL_OW 69
14759: NOT
14760: AND
14761: IFFALSE 14773
14763: GO 14765
14765: DISABLE
// ChangeMissionObjectives ( MEnemyDone ) ;
14766: LD_STRING MEnemyDone
14768: PPUSH
14769: CALL_OW 337
14773: END
// every 0 0$1 trigger ( buildingsToBuild + ( 3 - GetAmountWeaponsDataBuildOnTurret ( true ) ) ) = 0 and GetAmountWeaponsDataBuildOnVehicle ( false ) = 0 and techsToResearch = 0 and FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_type , unit_human ] , [ f_and , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ] ] ) = 0 and Masha and IsOK ( Masha [ 1 ] ) and buildCompVehicle and testedTeleport do
14774: LD_EXP 8
14778: PUSH
14779: LD_INT 3
14781: PUSH
14782: LD_INT 1
14784: PPUSH
14785: CALL 6616 0 1
14789: MINUS
14790: PLUS
14791: PUSH
14792: LD_INT 0
14794: EQUAL
14795: PUSH
14796: LD_INT 0
14798: PPUSH
14799: CALL 6726 0 1
14803: PUSH
14804: LD_INT 0
14806: EQUAL
14807: AND
14808: PUSH
14809: LD_EXP 9
14813: PUSH
14814: LD_INT 0
14816: EQUAL
14817: AND
14818: PUSH
14819: LD_INT 22
14821: PUSH
14822: LD_INT 8
14824: PUSH
14825: EMPTY
14826: LIST
14827: LIST
14828: PUSH
14829: LD_INT 21
14831: PUSH
14832: LD_INT 1
14834: PUSH
14835: EMPTY
14836: LIST
14837: LIST
14838: PUSH
14839: EMPTY
14840: LIST
14841: LIST
14842: PPUSH
14843: CALL_OW 69
14847: PUSH
14848: LD_INT 0
14850: EQUAL
14851: AND
14852: PUSH
14853: LD_INT 22
14855: PUSH
14856: LD_INT 1
14858: PUSH
14859: EMPTY
14860: LIST
14861: LIST
14862: PUSH
14863: LD_INT 2
14865: PUSH
14866: LD_INT 21
14868: PUSH
14869: LD_INT 1
14871: PUSH
14872: EMPTY
14873: LIST
14874: LIST
14875: PUSH
14876: LD_INT 1
14878: PUSH
14879: LD_INT 21
14881: PUSH
14882: LD_INT 2
14884: PUSH
14885: EMPTY
14886: LIST
14887: LIST
14888: PUSH
14889: LD_INT 33
14891: PUSH
14892: LD_INT 3
14894: PUSH
14895: EMPTY
14896: LIST
14897: LIST
14898: PUSH
14899: EMPTY
14900: LIST
14901: LIST
14902: LIST
14903: PUSH
14904: EMPTY
14905: LIST
14906: LIST
14907: LIST
14908: PUSH
14909: EMPTY
14910: LIST
14911: LIST
14912: PPUSH
14913: CALL_OW 69
14917: PUSH
14918: LD_INT 0
14920: EQUAL
14921: AND
14922: PUSH
14923: LD_EXP 4
14927: AND
14928: PUSH
14929: LD_EXP 4
14933: PUSH
14934: LD_INT 1
14936: ARRAY
14937: PPUSH
14938: CALL_OW 302
14942: AND
14943: PUSH
14944: LD_EXP 37
14948: AND
14949: PUSH
14950: LD_EXP 39
14954: AND
14955: IFFALSE 14964
14957: GO 14959
14959: DISABLE
// begin FinishMission ;
14960: CALL 15169 0 0
// end ;
14964: END
// every 0 0$1 do var unit ;
14965: GO 14967
14967: DISABLE
14968: LD_INT 0
14970: PPUSH
// begin case allowExitFromMap of 1 :
14971: LD_EXP 18
14975: PUSH
14976: LD_INT 1
14978: DOUBLE
14979: EQUAL
14980: IFTRUE 14984
14982: GO 15012
14984: POP
// RemoveUnits ( FilterUnitsInArea ( ExitMapArea , [ [ f_side , 6 ] ] ) ) ; 3 :
14985: LD_INT 8
14987: PPUSH
14988: LD_INT 22
14990: PUSH
14991: LD_INT 6
14993: PUSH
14994: EMPTY
14995: LIST
14996: LIST
14997: PUSH
14998: EMPTY
14999: LIST
15000: PPUSH
15001: CALL_OW 70
15005: PPUSH
15006: CALL 6452 0 1
15010: GO 15135
15012: LD_INT 3
15014: DOUBLE
15015: EQUAL
15016: IFTRUE 15020
15018: GO 15048
15020: POP
// RemoveUnits ( FilterUnitsInArea ( KurtExitMapArea , [ [ f_side , 8 ] ] ) ) ; 4 :
15021: LD_INT 11
15023: PPUSH
15024: LD_INT 22
15026: PUSH
15027: LD_INT 8
15029: PUSH
15030: EMPTY
15031: LIST
15032: LIST
15033: PUSH
15034: EMPTY
15035: LIST
15036: PPUSH
15037: CALL_OW 70
15041: PPUSH
15042: CALL 6452 0 1
15046: GO 15135
15048: LD_INT 4
15050: DOUBLE
15051: EQUAL
15052: IFTRUE 15056
15054: GO 15134
15056: POP
// begin RemoveUnits ( FilterUnitsInArea ( ExitMapArea , [ [ f_side , 8 ] ] ) ) ;
15057: LD_INT 8
15059: PPUSH
15060: LD_INT 22
15062: PUSH
15063: LD_INT 8
15065: PUSH
15066: EMPTY
15067: LIST
15068: LIST
15069: PUSH
15070: EMPTY
15071: LIST
15072: PPUSH
15073: CALL_OW 70
15077: PPUSH
15078: CALL 6452 0 1
// RemoveUnits ( FilterUnitsInArea ( KurtExitMapArea , [ [ f_side , 8 ] ] ) ) ;
15082: LD_INT 11
15084: PPUSH
15085: LD_INT 22
15087: PUSH
15088: LD_INT 8
15090: PUSH
15091: EMPTY
15092: LIST
15093: LIST
15094: PUSH
15095: EMPTY
15096: LIST
15097: PPUSH
15098: CALL_OW 70
15102: PPUSH
15103: CALL 6452 0 1
// RemoveUnits ( FilterUnitsInArea ( ExitMapArea , [ [ f_side , 2 ] ] ) ) ;
15107: LD_INT 8
15109: PPUSH
15110: LD_INT 22
15112: PUSH
15113: LD_INT 2
15115: PUSH
15116: EMPTY
15117: LIST
15118: LIST
15119: PUSH
15120: EMPTY
15121: LIST
15122: PPUSH
15123: CALL_OW 70
15127: PPUSH
15128: CALL 6452 0 1
// end ; end ;
15132: GO 15135
15134: POP
// enable ;
15135: ENABLE
// end ; end_of_file
15136: PPOPN 1
15138: END
// export function Lose_Burlak ; begin
15139: LD_INT 0
15141: PPUSH
// YouLost ( Burlak ) ;
15142: LD_STRING Burlak
15144: PPUSH
15145: CALL_OW 104
// end ;
15149: LD_VAR 0 1
15153: RET
// export function Lost_AttackAlly ; begin
15154: LD_INT 0
15156: PPUSH
// YouLost ( SelfAttack ) ;
15157: LD_STRING SelfAttack
15159: PPUSH
15160: CALL_OW 104
// end ; end_of_file
15164: LD_VAR 0 1
15168: RET
// export function FinishMission ; begin
15169: LD_INT 0
15171: PPUSH
// SetRewards ;
15172: CALL 15193 0 0
// SavePlayerCharacters ;
15176: CALL 15454 0 0
// SaveGlobalVariables ;
15180: CALL 16004 0 0
// YouWin ;
15184: CALL_OW 103
// end ;
15188: LD_VAR 0 1
15192: RET
// function SetRewards ; begin
15193: LD_INT 0
15195: PPUSH
// AddMedal ( ArtisticImpression , 1 ) ;
15196: LD_STRING ArtisticImpression
15198: PPUSH
15199: LD_INT 1
15201: PPUSH
15202: CALL_OW 101
// if not HeikeCaptured then
15206: LD_EXP 1
15210: NOT
15211: IFFALSE 15245
// begin if speedMedalTime >= 0 0$00 then
15213: LD_EXP 52
15217: PUSH
15218: LD_INT 0
15220: GREATEREQUAL
15221: IFFALSE 15235
// AddMedal ( Speed , 1 ) else
15223: LD_STRING Speed
15225: PPUSH
15226: LD_INT 1
15228: PPUSH
15229: CALL_OW 101
15233: GO 15245
// AddMedal ( Speed , 1 ) ;
15235: LD_STRING Speed
15237: PPUSH
15238: LD_INT 1
15240: PPUSH
15241: CALL_OW 101
// end ; if lostUnits then
15245: LD_EXP 40
15249: IFFALSE 15264
// begin AddMedal ( FavouriteCommander , - 1 ) ;
15251: LD_STRING FavouriteCommander
15253: PPUSH
15254: LD_INT 1
15256: NEG
15257: PPUSH
15258: CALL_OW 101
// end else
15262: GO 15356
// begin case BurlakRespect of 0 :
15264: LD_EXP 30
15268: PUSH
15269: LD_INT 0
15271: DOUBLE
15272: EQUAL
15273: IFTRUE 15277
15275: GO 15291
15277: POP
// AddMedal ( FavouriteCommander , - 2 ) ; 1 :
15278: LD_STRING FavouriteCommander
15280: PPUSH
15281: LD_INT 2
15283: NEG
15284: PPUSH
15285: CALL_OW 101
15289: GO 15356
15291: LD_INT 1
15293: DOUBLE
15294: EQUAL
15295: IFTRUE 15299
15297: GO 15313
15299: POP
// AddMedal ( FavouriteCommander , - 3 ) ; 2 :
15300: LD_STRING FavouriteCommander
15302: PPUSH
15303: LD_INT 3
15305: NEG
15306: PPUSH
15307: CALL_OW 101
15311: GO 15356
15313: LD_INT 2
15315: DOUBLE
15316: EQUAL
15317: IFTRUE 15321
15319: GO 15334
15321: POP
// AddMedal ( FavouriteCommander , 1 ) ; 3 :
15322: LD_STRING FavouriteCommander
15324: PPUSH
15325: LD_INT 1
15327: PPUSH
15328: CALL_OW 101
15332: GO 15356
15334: LD_INT 3
15336: DOUBLE
15337: EQUAL
15338: IFTRUE 15342
15340: GO 15355
15342: POP
// AddMedal ( FavouriteCommander , 1 ) ; end ;
15343: LD_STRING FavouriteCommander
15345: PPUSH
15346: LD_INT 1
15348: PPUSH
15349: CALL_OW 101
15353: GO 15356
15355: POP
// end ; if HeikeCaptured then
15356: LD_EXP 1
15360: IFFALSE 15391
// begin if buildArabBarrack then
15362: LD_EXP 38
15366: IFFALSE 15380
// AddMedal ( ArabBarracks , 1 ) else
15368: LD_STRING ArabBarracks
15370: PPUSH
15371: LD_INT 1
15373: PPUSH
15374: CALL_OW 101
15378: GO 15391
// AddMedal ( ArabBarracks , - 1 ) ;
15380: LD_STRING ArabBarracks
15382: PPUSH
15383: LD_INT 1
15385: NEG
15386: PPUSH
15387: CALL_OW 101
// end ; GiveMedals ( Main1 ) ;
15391: LD_STRING Main1
15393: PPUSH
15394: CALL_OW 102
// RewardPeople ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_nation , nation_russian ] , [ f_ok ] ] ) ) ;
15398: LD_INT 22
15400: PUSH
15401: LD_INT 3
15403: PUSH
15404: EMPTY
15405: LIST
15406: LIST
15407: PUSH
15408: LD_INT 21
15410: PUSH
15411: LD_INT 1
15413: PUSH
15414: EMPTY
15415: LIST
15416: LIST
15417: PUSH
15418: LD_INT 23
15420: PUSH
15421: LD_INT 3
15423: PUSH
15424: EMPTY
15425: LIST
15426: LIST
15427: PUSH
15428: LD_INT 50
15430: PUSH
15431: EMPTY
15432: LIST
15433: PUSH
15434: EMPTY
15435: LIST
15436: LIST
15437: LIST
15438: LIST
15439: PPUSH
15440: CALL_OW 69
15444: PPUSH
15445: CALL_OW 43
// end ;
15449: LD_VAR 0 1
15453: RET
// function SavePlayerCharacters ; var randomsToSave ; begin
15454: LD_INT 0
15456: PPUSH
15457: PPUSH
// ExtSaveCharacter ( Burlak , Burlak , 3 ) ;
15458: LD_EXP 57
15462: PPUSH
15463: LD_STRING Burlak
15465: PPUSH
15466: LD_INT 3
15468: PPUSH
15469: CALL 5974 0 3
// ExtSaveCharacter ( Karamazov , Karamazov , 3 ) ;
15473: LD_EXP 58
15477: PPUSH
15478: LD_STRING Karamazov
15480: PPUSH
15481: LD_INT 3
15483: PPUSH
15484: CALL 5974 0 3
// ExtSaveCharacter ( Petrovova , Petrovova , 3 ) ;
15488: LD_EXP 59
15492: PPUSH
15493: LD_STRING Petrovova
15495: PPUSH
15496: LD_INT 3
15498: PPUSH
15499: CALL 5974 0 3
// ExtSaveCharacter ( Gleb , Gleb , 3 ) ;
15503: LD_EXP 60
15507: PPUSH
15508: LD_STRING Gleb
15510: PPUSH
15511: LD_INT 3
15513: PPUSH
15514: CALL 5974 0 3
// ExtSaveCharacter ( Petrosyan , Petrosyan , 3 ) ;
15518: LD_EXP 61
15522: PPUSH
15523: LD_STRING Petrosyan
15525: PPUSH
15526: LD_INT 3
15528: PPUSH
15529: CALL 5974 0 3
// ExtSaveCharacter ( Dolgov , Dolgov , 3 ) ;
15533: LD_EXP 63
15537: PPUSH
15538: LD_STRING Dolgov
15540: PPUSH
15541: LD_INT 3
15543: PPUSH
15544: CALL 5974 0 3
// ExtSaveCharacter ( Lipshchin , Lipshchin , 3 ) ;
15548: LD_EXP 64
15552: PPUSH
15553: LD_STRING Lipshchin
15555: PPUSH
15556: LD_INT 3
15558: PPUSH
15559: CALL 5974 0 3
// ExtSaveCharacter ( Titov , Titov , 3 ) ;
15563: LD_EXP 62
15567: PPUSH
15568: LD_STRING Titov
15570: PPUSH
15571: LD_INT 3
15573: PPUSH
15574: CALL 5974 0 3
// ExtSaveCharacter ( Kirilenkova , Kirilenkova , 3 ) ;
15578: LD_EXP 65
15582: PPUSH
15583: LD_STRING Kirilenkova
15585: PPUSH
15586: LD_INT 3
15588: PPUSH
15589: CALL 5974 0 3
// ExtSaveCharacter ( Belkov , Belkov , 3 ) ;
15593: LD_EXP 66
15597: PPUSH
15598: LD_STRING Belkov
15600: PPUSH
15601: LD_INT 3
15603: PPUSH
15604: CALL 5974 0 3
// ExtSaveCharacter ( Belkov2 , Belkov2 , 3 ) ;
15608: LD_EXP 67
15612: PPUSH
15613: LD_STRING Belkov2
15615: PPUSH
15616: LD_INT 3
15618: PPUSH
15619: CALL 5974 0 3
// ExtSaveCharacter ( Xavier , Xavier , 3 ) ;
15623: LD_EXP 68
15627: PPUSH
15628: LD_STRING Xavier
15630: PPUSH
15631: LD_INT 3
15633: PPUSH
15634: CALL 5974 0 3
// ExtSaveCharacter ( Kozlov , Kozlov , 3 ) ;
15638: LD_EXP 73
15642: PPUSH
15643: LD_STRING Kozlov
15645: PPUSH
15646: LD_INT 3
15648: PPUSH
15649: CALL 5974 0 3
// ExtSaveCharacter ( Oblukov , Oblukov , 3 ) ;
15653: LD_EXP 74
15657: PPUSH
15658: LD_STRING Oblukov
15660: PPUSH
15661: LD_INT 3
15663: PPUSH
15664: CALL 5974 0 3
// ExtSaveCharacter ( Kapitsova , Kapitsova , 3 ) ;
15668: LD_EXP 75
15672: PPUSH
15673: LD_STRING Kapitsova
15675: PPUSH
15676: LD_INT 3
15678: PPUSH
15679: CALL 5974 0 3
// ExtSaveCharacter ( Gnyevko , Gnyevko , 3 ) ;
15683: LD_EXP 69
15687: PPUSH
15688: LD_STRING Gnyevko
15690: PPUSH
15691: LD_INT 3
15693: PPUSH
15694: CALL 5974 0 3
// ExtSaveCharacter ( Kovalyuk , Kovalyuk , 3 ) ;
15698: LD_EXP 70
15702: PPUSH
15703: LD_STRING Kovalyuk
15705: PPUSH
15706: LD_INT 3
15708: PPUSH
15709: CALL 5974 0 3
// ExtSaveCharacter ( Scholtze , Scholtze , 3 ) ;
15713: LD_EXP 71
15717: PPUSH
15718: LD_STRING Scholtze
15720: PPUSH
15721: LD_INT 3
15723: PPUSH
15724: CALL 5974 0 3
// ExtSaveCharacter ( Kuzmov , Kuzmov , 3 ) ;
15728: LD_EXP 72
15732: PPUSH
15733: LD_STRING Kuzmov
15735: PPUSH
15736: LD_INT 3
15738: PPUSH
15739: CALL 5974 0 3
// ExtSaveCharacters ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_or , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman_soldier ] ] ] ) , other_apemans , 3 ) ;
15743: LD_INT 22
15745: PUSH
15746: LD_INT 3
15748: PUSH
15749: EMPTY
15750: LIST
15751: LIST
15752: PUSH
15753: LD_INT 21
15755: PUSH
15756: LD_INT 1
15758: PUSH
15759: EMPTY
15760: LIST
15761: LIST
15762: PUSH
15763: LD_INT 2
15765: PUSH
15766: LD_INT 25
15768: PUSH
15769: LD_INT 12
15771: PUSH
15772: EMPTY
15773: LIST
15774: LIST
15775: PUSH
15776: LD_INT 25
15778: PUSH
15779: LD_INT 16
15781: PUSH
15782: EMPTY
15783: LIST
15784: LIST
15785: PUSH
15786: LD_INT 25
15788: PUSH
15789: LD_INT 15
15791: PUSH
15792: EMPTY
15793: LIST
15794: LIST
15795: PUSH
15796: EMPTY
15797: LIST
15798: LIST
15799: LIST
15800: LIST
15801: PUSH
15802: EMPTY
15803: LIST
15804: LIST
15805: LIST
15806: PPUSH
15807: CALL_OW 69
15811: PPUSH
15812: LD_STRING other_apemans
15814: PPUSH
15815: LD_INT 3
15817: PPUSH
15818: CALL 6031 0 3
// randomsToSave = FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_nation , nation_russian ] ] ) diff [ Burlak , Karamazov , Petrovova , Gleb , Petrosyan , Titov , Dolgov , Lipshchin , Kirilenkova , Belkov , Belkov2 , Xavier , Gnyevko , Kovalyuk , Scholtze , Kuzmov , Kozlov , Oblukov , Kapitsova ] ;
15822: LD_ADDR_VAR 0 2
15826: PUSH
15827: LD_INT 22
15829: PUSH
15830: LD_INT 3
15832: PUSH
15833: EMPTY
15834: LIST
15835: LIST
15836: PUSH
15837: LD_INT 21
15839: PUSH
15840: LD_INT 1
15842: PUSH
15843: EMPTY
15844: LIST
15845: LIST
15846: PUSH
15847: LD_INT 23
15849: PUSH
15850: LD_INT 3
15852: PUSH
15853: EMPTY
15854: LIST
15855: LIST
15856: PUSH
15857: EMPTY
15858: LIST
15859: LIST
15860: LIST
15861: PPUSH
15862: CALL_OW 69
15866: PUSH
15867: LD_EXP 57
15871: PUSH
15872: LD_EXP 58
15876: PUSH
15877: LD_EXP 59
15881: PUSH
15882: LD_EXP 60
15886: PUSH
15887: LD_EXP 61
15891: PUSH
15892: LD_EXP 62
15896: PUSH
15897: LD_EXP 63
15901: PUSH
15902: LD_EXP 64
15906: PUSH
15907: LD_EXP 65
15911: PUSH
15912: LD_EXP 66
15916: PUSH
15917: LD_EXP 67
15921: PUSH
15922: LD_EXP 68
15926: PUSH
15927: LD_EXP 69
15931: PUSH
15932: LD_EXP 70
15936: PUSH
15937: LD_EXP 71
15941: PUSH
15942: LD_EXP 72
15946: PUSH
15947: LD_EXP 73
15951: PUSH
15952: LD_EXP 74
15956: PUSH
15957: LD_EXP 75
15961: PUSH
15962: EMPTY
15963: LIST
15964: LIST
15965: LIST
15966: LIST
15967: LIST
15968: LIST
15969: LIST
15970: LIST
15971: LIST
15972: LIST
15973: LIST
15974: LIST
15975: LIST
15976: LIST
15977: LIST
15978: LIST
15979: LIST
15980: LIST
15981: LIST
15982: DIFF
15983: ST_TO_ADDR
// ExtSaveCharacters ( randomsToSave , other_survivors , 3 ) ;
15984: LD_VAR 0 2
15988: PPUSH
15989: LD_STRING other_survivors
15991: PPUSH
15992: LD_INT 3
15994: PPUSH
15995: CALL 6031 0 3
// end ;
15999: LD_VAR 0 1
16003: RET
// function SaveGlobalVariables ; begin
16004: LD_INT 0
16006: PPUSH
// SaveBase ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] ] ) , 08_TrockyBase_1 ) ;
16007: LD_INT 22
16009: PUSH
16010: LD_INT 3
16012: PUSH
16013: EMPTY
16014: LIST
16015: LIST
16016: PUSH
16017: LD_INT 21
16019: PUSH
16020: LD_INT 3
16022: PUSH
16023: EMPTY
16024: LIST
16025: LIST
16026: PUSH
16027: EMPTY
16028: LIST
16029: LIST
16030: PPUSH
16031: CALL_OW 69
16035: PPUSH
16036: LD_STRING 08_TrockyBase_1
16038: PPUSH
16039: CALL 8410 0 2
// SaveVariable ( coopWithGensher , 08_CoopWithGensher_2 ) ;
16043: LD_EXP 2
16047: PPUSH
16048: LD_STRING 08_CoopWithGensher_2
16050: PPUSH
16051: CALL_OW 39
// SaveVariable ( HeikeStatus , 08_HeikeStatus_3 ) ;
16055: LD_EXP 3
16059: PPUSH
16060: LD_STRING 08_HeikeStatus_3
16062: PPUSH
16063: CALL_OW 39
// SaveVariable ( Masha , 08_Masha_4 ) ;
16067: LD_EXP 4
16071: PPUSH
16072: LD_STRING 08_Masha_4
16074: PPUSH
16075: CALL_OW 39
// end ; end_of_file
16079: LD_VAR 0 1
16083: RET
// export function CustomEvent ( event ) ; begin
16084: LD_INT 0
16086: PPUSH
// end ;
16087: LD_VAR 0 2
16091: RET
// on BuildingComplete ( building ) do begin if GetBType ( building ) in buildingsToBuild and GetNation ( building ) = nation_russian then
16092: LD_VAR 0 1
16096: PPUSH
16097: CALL_OW 266
16101: PUSH
16102: LD_EXP 8
16106: IN
16107: PUSH
16108: LD_VAR 0 1
16112: PPUSH
16113: CALL_OW 248
16117: PUSH
16118: LD_INT 3
16120: EQUAL
16121: AND
16122: IFFALSE 16145
// buildingsToBuild = buildingsToBuild diff GetBType ( building ) ;
16124: LD_ADDR_EXP 8
16128: PUSH
16129: LD_EXP 8
16133: PUSH
16134: LD_VAR 0 1
16138: PPUSH
16139: CALL_OW 266
16143: DIFF
16144: ST_TO_ADDR
// if GetBType ( building ) = b_depot then
16145: LD_VAR 0 1
16149: PPUSH
16150: CALL_OW 266
16154: PUSH
16155: LD_INT 0
16157: EQUAL
16158: IFFALSE 16209
// begin SetBName ( building , trockij ) ;
16160: LD_VAR 0 1
16164: PPUSH
16165: LD_STRING trockij
16167: PPUSH
16168: CALL_OW 500
// if not dial_BuildDepotBlocker and HeikeCaptured then
16172: LD_EXP 5
16176: NOT
16177: PUSH
16178: LD_EXP 1
16182: AND
16183: IFFALSE 16209
// Dial_EscortHeike ( GetX ( building ) , GetY ( building ) ) ;
16185: LD_VAR 0 1
16189: PPUSH
16190: CALL_OW 250
16194: PPUSH
16195: LD_VAR 0 1
16199: PPUSH
16200: CALL_OW 251
16204: PPUSH
16205: CALL 9075 0 2
// end ; end ;
16209: PPOPN 1
16211: END
// on UpgradeComplete ( building ) do begin if GetBType ( building ) in buildingsToBuild and GetNation ( building ) = nation_russian then
16212: LD_VAR 0 1
16216: PPUSH
16217: CALL_OW 266
16221: PUSH
16222: LD_EXP 8
16226: IN
16227: PUSH
16228: LD_VAR 0 1
16232: PPUSH
16233: CALL_OW 248
16237: PUSH
16238: LD_INT 3
16240: EQUAL
16241: AND
16242: IFFALSE 16265
// buildingsToBuild = buildingsToBuild diff GetBType ( building ) ;
16244: LD_ADDR_EXP 8
16248: PUSH
16249: LD_EXP 8
16253: PUSH
16254: LD_VAR 0 1
16258: PPUSH
16259: CALL_OW 266
16263: DIFF
16264: ST_TO_ADDR
// if GetBType ( building ) = b_barracks and GetNation ( building ) = 2 and not dial_BuildArBarrackBlocker then
16265: LD_VAR 0 1
16269: PPUSH
16270: CALL_OW 266
16274: PUSH
16275: LD_INT 5
16277: EQUAL
16278: PUSH
16279: LD_VAR 0 1
16283: PPUSH
16284: CALL_OW 248
16288: PUSH
16289: LD_INT 2
16291: EQUAL
16292: AND
16293: PUSH
16294: LD_EXP 6
16298: NOT
16299: AND
16300: IFFALSE 16306
// Dial_UpgradeArmoury ;
16302: CALL 9886 0 0
// end ;
16306: PPOPN 1
16308: END
// on ResearchComplete ( research , building ) do begin if research in techsToResearch then
16309: LD_VAR 0 1
16313: PUSH
16314: LD_EXP 9
16318: IN
16319: IFFALSE 16337
// techsToResearch = techsToResearch diff research ;
16321: LD_ADDR_EXP 9
16325: PUSH
16326: LD_EXP 9
16330: PUSH
16331: LD_VAR 0 1
16335: DIFF
16336: ST_TO_ADDR
// if research = tech_LimTeleport then
16337: LD_VAR 0 1
16341: PUSH
16342: LD_INT 37
16344: EQUAL
16345: IFFALSE 16351
// Dial_TeleportTechResearched ;
16347: CALL 13731 0 0
// if research = tech_AdvAI then
16351: LD_VAR 0 1
16355: PUSH
16356: LD_INT 27
16358: EQUAL
16359: IFFALSE 16365
// Dial_ComputerTechResearched ;
16361: CALL 13600 0 0
// end ;
16365: PPOPN 2
16367: END
// on EnterVehicle ( vehicle , human ) do begin if not canChooseMashaVehicle then
16368: LD_EXP 36
16372: NOT
16373: IFFALSE 16377
// exit ;
16375: GO 16544
// wait ( 0 0$1 ) ;
16377: LD_INT 35
16379: PPUSH
16380: CALL_OW 67
// if GetSide ( vehicle ) = 3 and human = Burlak and GetNation ( vehicle ) = nation_russian and GetWeapon ( vehicle ) in [ ru_heavy_machine_gun , ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher ] then
16384: LD_VAR 0 1
16388: PPUSH
16389: CALL_OW 255
16393: PUSH
16394: LD_INT 3
16396: EQUAL
16397: PUSH
16398: LD_VAR 0 2
16402: PUSH
16403: LD_EXP 57
16407: EQUAL
16408: AND
16409: PUSH
16410: LD_VAR 0 1
16414: PPUSH
16415: CALL_OW 248
16419: PUSH
16420: LD_INT 3
16422: EQUAL
16423: AND
16424: PUSH
16425: LD_VAR 0 1
16429: PPUSH
16430: CALL_OW 264
16434: PUSH
16435: LD_INT 42
16437: PUSH
16438: LD_INT 43
16440: PUSH
16441: LD_INT 44
16443: PUSH
16444: LD_INT 46
16446: PUSH
16447: LD_INT 45
16449: PUSH
16450: EMPTY
16451: LIST
16452: LIST
16453: LIST
16454: LIST
16455: LIST
16456: IN
16457: AND
16458: IFFALSE 16544
// begin if Masha then
16460: LD_EXP 4
16464: IFFALSE 16484
// if Masha [ 1 ] = vehicle then
16466: LD_EXP 4
16470: PUSH
16471: LD_INT 1
16473: ARRAY
16474: PUSH
16475: LD_VAR 0 1
16479: EQUAL
16480: IFFALSE 16484
// exit ;
16482: GO 16544
// if firstMashaQuery then
16484: LD_EXP 35
16488: IFFALSE 16522
// begin firstMashaQuery = false ;
16490: LD_ADDR_EXP 35
16494: PUSH
16495: LD_INT 0
16497: ST_TO_ADDR
// if Query ( QMashaQuery ) = 1 then
16498: LD_STRING QMashaQuery
16500: PPUSH
16501: CALL_OW 97
16505: PUSH
16506: LD_INT 1
16508: EQUAL
16509: IFFALSE 16520
// SetMashaData ( vehicle ) ;
16511: LD_VAR 0 1
16515: PPUSH
16516: CALL 8304 0 1
// end else
16520: GO 16544
// begin if Query ( QMashaQuery2 ) = 1 then
16522: LD_STRING QMashaQuery2
16524: PPUSH
16525: CALL_OW 97
16529: PUSH
16530: LD_INT 1
16532: EQUAL
16533: IFFALSE 16544
// SetMashaData ( vehicle ) ;
16535: LD_VAR 0 1
16539: PPUSH
16540: CALL 8304 0 1
// end ; end ; end ;
16544: PPOPN 2
16546: END
// on UnitDestroyed ( unit ) do begin if Masha then
16547: LD_EXP 4
16551: IFFALSE 16576
// if unit = Masha [ 1 ] then
16553: LD_VAR 0 1
16557: PUSH
16558: LD_EXP 4
16562: PUSH
16563: LD_INT 1
16565: ARRAY
16566: EQUAL
16567: IFFALSE 16576
// Masha = [ ] ;
16569: LD_ADDR_EXP 4
16573: PUSH
16574: EMPTY
16575: ST_TO_ADDR
// if unit = Burlak then
16576: LD_VAR 0 1
16580: PUSH
16581: LD_EXP 57
16585: EQUAL
16586: IFFALSE 16592
// Lose_Burlak ;
16588: CALL 15139 0 0
// if GetType ( unit ) = unit_human and GetNation ( unit ) = nation_russian then
16592: LD_VAR 0 1
16596: PPUSH
16597: CALL_OW 247
16601: PUSH
16602: LD_INT 1
16604: EQUAL
16605: PUSH
16606: LD_VAR 0 1
16610: PPUSH
16611: CALL_OW 248
16615: PUSH
16616: LD_INT 3
16618: EQUAL
16619: AND
16620: IFFALSE 16636
// lostUnits = lostUnits + 1 ;
16622: LD_ADDR_EXP 40
16626: PUSH
16627: LD_EXP 40
16631: PUSH
16632: LD_INT 1
16634: PLUS
16635: ST_TO_ADDR
// end ;
16636: PPOPN 1
16638: END
// on UnitGoesToRed ( unit ) do begin if GetType ( unit ) = unit_vehicle and GetNation ( unit ) = nation_russian and GetTech ( tech_LimTeleport , 3 ) = state_researched and not testedTeleport then
16639: LD_VAR 0 1
16643: PPUSH
16644: CALL_OW 247
16648: PUSH
16649: LD_INT 2
16651: EQUAL
16652: PUSH
16653: LD_VAR 0 1
16657: PPUSH
16658: CALL_OW 248
16662: PUSH
16663: LD_INT 3
16665: EQUAL
16666: AND
16667: PUSH
16668: LD_INT 37
16670: PPUSH
16671: LD_INT 3
16673: PPUSH
16674: CALL_OW 321
16678: PUSH
16679: LD_INT 2
16681: EQUAL
16682: AND
16683: PUSH
16684: LD_EXP 39
16688: NOT
16689: AND
16690: IFFALSE 16707
// begin testedTeleport = true ;
16692: LD_ADDR_EXP 39
16696: PUSH
16697: LD_INT 1
16699: ST_TO_ADDR
// ChangeMissionObjectives ( MTeleDone ) ;
16700: LD_STRING MTeleDone
16702: PPUSH
16703: CALL_OW 337
// end ; if unit = Heike then
16707: LD_VAR 0 1
16711: PUSH
16712: LD_EXP 79
16716: EQUAL
16717: IFFALSE 16760
// begin DialogueOn ;
16719: CALL_OW 6
// CenterNowOnUnits ( Heike ) ;
16723: LD_EXP 79
16727: PPUSH
16728: CALL_OW 87
// ForceSay ( Heike , DHeikeKilled-Hke-1 ) ;
16732: LD_EXP 79
16736: PPUSH
16737: LD_STRING DHeikeKilled-Hke-1
16739: PPUSH
16740: CALL_OW 91
// DialogueOff ;
16744: CALL_OW 7
// SetLives ( Heike , 0 ) ;
16748: LD_EXP 79
16752: PPUSH
16753: LD_INT 0
16755: PPUSH
16756: CALL_OW 234
// end ; end ;
16760: PPOPN 1
16762: END
// on Contact ( side1 , side2 ) do begin if side1 = 3 and side2 = 6 then
16763: LD_VAR 0 1
16767: PUSH
16768: LD_INT 3
16770: EQUAL
16771: PUSH
16772: LD_VAR 0 2
16776: PUSH
16777: LD_INT 6
16779: EQUAL
16780: AND
16781: IFFALSE 16787
// Lost_AttackAlly ;
16783: CALL 15154 0 0
// if side1 = 3 and side2 = 2 then
16787: LD_VAR 0 1
16791: PUSH
16792: LD_INT 3
16794: EQUAL
16795: PUSH
16796: LD_VAR 0 2
16800: PUSH
16801: LD_INT 2
16803: EQUAL
16804: AND
16805: IFFALSE 16811
// Dial_AttackGensher ;
16807: CALL 10842 0 0
// if side1 = 3 and side2 = 5 then
16811: LD_VAR 0 1
16815: PUSH
16816: LD_INT 3
16818: EQUAL
16819: PUSH
16820: LD_VAR 0 2
16824: PUSH
16825: LD_INT 5
16827: EQUAL
16828: AND
16829: IFFALSE 16873
// begin SetAttitude ( 3 , 5 , att_enemy , true ) ;
16831: LD_INT 3
16833: PPUSH
16834: LD_INT 5
16836: PPUSH
16837: LD_INT 2
16839: PPUSH
16840: LD_INT 1
16842: PPUSH
16843: CALL_OW 80
// if acceptKurtOffert and not GetSide ( Kurt ) = 2 then
16847: LD_EXP 19
16851: PUSH
16852: LD_EXP 80
16856: PPUSH
16857: CALL_OW 255
16861: PUSH
16862: LD_INT 2
16864: EQUAL
16865: NOT
16866: AND
16867: IFFALSE 16873
// Dial_BetrayedKurt1 ;
16869: CALL 11391 0 0
// end ; if side1 = 3 and side2 = 8 and GetAttitude ( 3 , 8 ) = att_neutral then
16873: LD_VAR 0 1
16877: PUSH
16878: LD_INT 3
16880: EQUAL
16881: PUSH
16882: LD_VAR 0 2
16886: PUSH
16887: LD_INT 8
16889: EQUAL
16890: AND
16891: PUSH
16892: LD_INT 3
16894: PPUSH
16895: LD_INT 8
16897: PPUSH
16898: CALL_OW 81
16902: PUSH
16903: LD_INT 0
16905: EQUAL
16906: AND
16907: IFFALSE 16919
// begin if acceptKurtOffert then
16909: LD_EXP 19
16913: IFFALSE 16919
// Dial_BetrayedKurt2 ;
16915: CALL 11477 0 0
// end ; end ;
16919: PPOPN 2
16921: END
// on VehicleConstructed ( vehicle , building ) do begin SetWeaponDataBuild ( GetWeapon ( vehicle ) , false ) ;
16922: LD_VAR 0 1
16926: PPUSH
16927: CALL_OW 264
16931: PPUSH
16932: LD_INT 0
16934: PPUSH
16935: CALL 6812 0 2
// if GetControl ( vehicle ) = control_computer and not buildCompVehicle then
16939: LD_VAR 0 1
16943: PPUSH
16944: CALL_OW 263
16948: PUSH
16949: LD_INT 3
16951: EQUAL
16952: PUSH
16953: LD_EXP 37
16957: NOT
16958: AND
16959: IFFALSE 16976
// begin buildCompVehicle = true ;
16961: LD_ADDR_EXP 37
16965: PUSH
16966: LD_INT 1
16968: ST_TO_ADDR
// ChangeMissionObjectives ( MAIDone ) ;
16969: LD_STRING MAIDone
16971: PPUSH
16972: CALL_OW 337
// end ; end ;
16976: PPOPN 2
16978: END
// on WeaponPlaced ( building , factory ) do begin SetWeaponDataBuild ( GetBWeapon ( building ) , true ) ;
16979: LD_VAR 0 1
16983: PPUSH
16984: CALL_OW 269
16988: PPUSH
16989: LD_INT 1
16991: PPUSH
16992: CALL 6812 0 2
// end ;
16996: PPOPN 2
16998: END
// on Command ( comandid ) do var i ;
16999: LD_INT 0
17001: PPUSH
// begin if IsOK ( KurtEng ) and GetSide ( KurtEng ) = 3 then
17002: LD_EXP 82
17006: PPUSH
17007: CALL_OW 302
17011: PUSH
17012: LD_EXP 82
17016: PPUSH
17017: CALL_OW 255
17021: PUSH
17022: LD_INT 3
17024: EQUAL
17025: AND
17026: IFFALSE 17235
// if GetTaskList ( KurtEng ) then
17028: LD_EXP 82
17032: PPUSH
17033: CALL_OW 437
17037: IFFALSE 17235
// begin for i := 1 to ( GetTaskList ( KurtEng ) ) do
17039: LD_ADDR_VAR 0 2
17043: PUSH
17044: DOUBLE
17045: LD_INT 1
17047: DEC
17048: ST_TO_ADDR
17049: LD_EXP 82
17053: PPUSH
17054: CALL_OW 437
17058: PUSH
17059: FOR_TO
17060: IFFALSE 17233
// begin if ( GetTaskList ( KurtEng ) [ i ] [ 1 ] in [ F , H , M , U , V , a , h , u , v , ~ , ^ , > , + , ; , 4 , { ] ) or ( GetTaskList ( KurtEng ) [ i ] [ 1 ] = B and GetTaskList ( KurtEng ) [ i ] [ 5 ] = 36 ) then
17062: LD_EXP 82
17066: PPUSH
17067: CALL_OW 437
17071: PUSH
17072: LD_VAR 0 2
17076: ARRAY
17077: PUSH
17078: LD_INT 1
17080: ARRAY
17081: PUSH
17082: LD_STRING F
17084: PUSH
17085: LD_STRING H
17087: PUSH
17088: LD_STRING M
17090: PUSH
17091: LD_STRING U
17093: PUSH
17094: LD_STRING V
17096: PUSH
17097: LD_STRING a
17099: PUSH
17100: LD_STRING h
17102: PUSH
17103: LD_STRING u
17105: PUSH
17106: LD_STRING v
17108: PUSH
17109: LD_STRING ~
17111: PUSH
17112: LD_STRING ^
17114: PUSH
17115: LD_STRING >
17117: PUSH
17118: LD_STRING +
17120: PUSH
17121: LD_STRING ;
17123: PUSH
17124: LD_STRING 4
17126: PUSH
17127: LD_STRING {
17129: PUSH
17130: EMPTY
17131: LIST
17132: LIST
17133: LIST
17134: LIST
17135: LIST
17136: LIST
17137: LIST
17138: LIST
17139: LIST
17140: LIST
17141: LIST
17142: LIST
17143: LIST
17144: LIST
17145: LIST
17146: LIST
17147: IN
17148: PUSH
17149: LD_EXP 82
17153: PPUSH
17154: CALL_OW 437
17158: PUSH
17159: LD_VAR 0 2
17163: ARRAY
17164: PUSH
17165: LD_INT 1
17167: ARRAY
17168: PUSH
17169: LD_STRING B
17171: EQUAL
17172: PUSH
17173: LD_EXP 82
17177: PPUSH
17178: CALL_OW 437
17182: PUSH
17183: LD_VAR 0 2
17187: ARRAY
17188: PUSH
17189: LD_INT 5
17191: ARRAY
17192: PUSH
17193: LD_INT 36
17195: EQUAL
17196: AND
17197: OR
17198: IFFALSE 17202
// else
17200: GO 17231
// begin RemoveTasks ( KurtEng ) ;
17202: LD_EXP 82
17206: PPUSH
17207: CALL_OW 493
// DialogueOn ;
17211: CALL_OW 6
// Say ( Kurt , DMercRefuseBuild-Kurt-1 ) ;
17215: LD_EXP 80
17219: PPUSH
17220: LD_STRING DMercRefuseBuild-Kurt-1
17222: PPUSH
17223: CALL_OW 88
// DialogueOff ;
17227: CALL_OW 7
// end ; end ;
17231: GO 17059
17233: POP
17234: POP
// end ; end ; end_of_file
17235: PPOPN 2
17237: END
// every 0 0$01 do var timer , cratesSpawned ;
17238: GO 17240
17240: DISABLE
17241: LD_INT 0
17243: PPUSH
17244: PPUSH
// begin timer := 1 1$30 ;
17245: LD_ADDR_VAR 0 1
17249: PUSH
17250: LD_INT 3150
17252: ST_TO_ADDR
// repeat wait ( timer ) ;
17253: LD_VAR 0 1
17257: PPUSH
17258: CALL_OW 67
// if cratesSpawned >= 6 and cratesSpawned < 18 then
17262: LD_VAR 0 2
17266: PUSH
17267: LD_INT 6
17269: GREATEREQUAL
17270: PUSH
17271: LD_VAR 0 2
17275: PUSH
17276: LD_INT 18
17278: LESS
17279: AND
17280: IFFALSE 17296
// timer := timer + 0 0$3 ;
17282: LD_ADDR_VAR 0 1
17286: PUSH
17287: LD_VAR 0 1
17291: PUSH
17292: LD_INT 105
17294: PLUS
17295: ST_TO_ADDR
// if cratesSpawned >= 18 then
17296: LD_VAR 0 2
17300: PUSH
17301: LD_INT 18
17303: GREATEREQUAL
17304: IFFALSE 17320
// timer := timer + 0 0$9 ;
17306: LD_ADDR_VAR 0 1
17310: PUSH
17311: LD_VAR 0 1
17315: PUSH
17316: LD_INT 315
17318: PLUS
17319: ST_TO_ADDR
// if timer > 3 3$00 then
17320: LD_VAR 0 1
17324: PUSH
17325: LD_INT 6300
17327: GREATER
17328: IFFALSE 17338
// timer := 0 0$50 ;
17330: LD_ADDR_VAR 0 1
17334: PUSH
17335: LD_INT 1750
17337: ST_TO_ADDR
// CreateCratesArea ( rand ( 3 , 5 ) , CratesSpawnArea , true ) ;
17338: LD_INT 3
17340: PPUSH
17341: LD_INT 5
17343: PPUSH
17344: CALL_OW 12
17348: PPUSH
17349: LD_INT 15
17351: PPUSH
17352: LD_INT 1
17354: PPUSH
17355: CALL_OW 55
// cratesSpawned = cratesSpawned + 1 ;
17359: LD_ADDR_VAR 0 2
17363: PUSH
17364: LD_VAR 0 2
17368: PUSH
17369: LD_INT 1
17371: PLUS
17372: ST_TO_ADDR
// until false ;
17373: LD_INT 0
17375: IFFALSE 17253
// end ; end_of_file
17377: PPOPN 2
17379: END
// every 0 0$1 do
17380: GO 17382
17382: DISABLE
// begin enable ;
17383: ENABLE
// end ;
17384: END
// every 0 0$1 do var building , playerBuildings , playerBuildingsBType ;
17385: GO 17387
17387: DISABLE
17388: LD_INT 0
17390: PPUSH
17391: PPUSH
17392: PPUSH
// begin playerBuildings = FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] , [ f_nation , nation_russian ] ] ) ;
17393: LD_ADDR_VAR 0 2
17397: PUSH
17398: LD_INT 22
17400: PUSH
17401: LD_INT 3
17403: PUSH
17404: EMPTY
17405: LIST
17406: LIST
17407: PUSH
17408: LD_INT 21
17410: PUSH
17411: LD_INT 3
17413: PUSH
17414: EMPTY
17415: LIST
17416: LIST
17417: PUSH
17418: LD_INT 23
17420: PUSH
17421: LD_INT 3
17423: PUSH
17424: EMPTY
17425: LIST
17426: LIST
17427: PUSH
17428: EMPTY
17429: LIST
17430: LIST
17431: LIST
17432: PPUSH
17433: CALL_OW 69
17437: ST_TO_ADDR
// playerBuildingsBType = [ ] ;
17438: LD_ADDR_VAR 0 3
17442: PUSH
17443: EMPTY
17444: ST_TO_ADDR
// for building in playerBuildings do
17445: LD_ADDR_VAR 0 1
17449: PUSH
17450: LD_VAR 0 2
17454: PUSH
17455: FOR_IN
17456: IFFALSE 17481
// playerBuildingsBType = playerBuildingsBType ^ GetBType ( building ) ;
17458: LD_ADDR_VAR 0 3
17462: PUSH
17463: LD_VAR 0 3
17467: PUSH
17468: LD_VAR 0 1
17472: PPUSH
17473: CALL_OW 266
17477: ADD
17478: ST_TO_ADDR
17479: GO 17455
17481: POP
17482: POP
// for building in allBuildings do
17483: LD_ADDR_VAR 0 1
17487: PUSH
17488: LD_EXP 13
17492: PUSH
17493: FOR_IN
17494: IFFALSE 17540
// if not building in playerBuildingsBType and not building in buildingsToBuild then
17496: LD_VAR 0 1
17500: PUSH
17501: LD_VAR 0 3
17505: IN
17506: NOT
17507: PUSH
17508: LD_VAR 0 1
17512: PUSH
17513: LD_EXP 8
17517: IN
17518: NOT
17519: AND
17520: IFFALSE 17538
// buildingsToBuild = buildingsToBuild ^ building ;
17522: LD_ADDR_EXP 8
17526: PUSH
17527: LD_EXP 8
17531: PUSH
17532: LD_VAR 0 1
17536: ADD
17537: ST_TO_ADDR
17538: GO 17493
17540: POP
17541: POP
// enable ;
17542: ENABLE
// end ;
17543: PPOPN 3
17545: END
// every 0 0$1 trigger legionOffertCountdown do
17546: LD_EXP 33
17550: IFFALSE 17570
17552: GO 17554
17554: DISABLE
// begin legionOffertTime = legionOffertTime - 0 0$01 ;
17555: LD_ADDR_EXP 34
17559: PUSH
17560: LD_EXP 34
17564: PUSH
17565: LD_INT 35
17567: MINUS
17568: ST_TO_ADDR
// enable ;
17569: ENABLE
// end ;
17570: END
// every 0 0$1 trigger KurtWaitingForFreeHeike do
17571: LD_EXP 23
17575: IFFALSE 17609
17577: GO 17579
17579: DISABLE
// begin timeToFreeHeike = timeToFreeHeike - 0 0$01 ;
17580: LD_ADDR_EXP 54
17584: PUSH
17585: LD_EXP 54
17589: PUSH
17590: LD_INT 35
17592: MINUS
17593: ST_TO_ADDR
// if timeToFreeHeike <= 0 0$00 then
17594: LD_EXP 54
17598: PUSH
17599: LD_INT 0
17601: LESSEQUAL
17602: IFFALSE 17608
// Dial_PlayerDontSendHeike ;
17604: CALL 11339 0 0
// enable ;
17608: ENABLE
// end ;
17609: END
// every 0 0$1 trigger KurtWaitingForBuildBarrack and GetSide ( KurtEng ) = 3 do
17610: LD_EXP 24
17614: PUSH
17615: LD_EXP 82
17619: PPUSH
17620: CALL_OW 255
17624: PUSH
17625: LD_INT 3
17627: EQUAL
17628: AND
17629: IFFALSE 17702
17631: GO 17633
17633: DISABLE
// begin timeToBuildArBarrack = timeToBuildArBarrack - 0 0$01 ;
17634: LD_ADDR_EXP 55
17638: PUSH
17639: LD_EXP 55
17643: PUSH
17644: LD_INT 35
17646: MINUS
17647: ST_TO_ADDR
// if timeToBuildArBarrack <= 0 0$00 then
17648: LD_EXP 55
17652: PUSH
17653: LD_INT 0
17655: LESSEQUAL
17656: IFFALSE 17701
// begin Dial_BetrayedKurt1 ;
17658: CALL 11391 0 0
// wait ( 2 2$0 ) ;
17662: LD_INT 4200
17664: PPUSH
17665: CALL_OW 67
// SetAttitude ( 3 , 8 , att_enemy , true ) ;
17669: LD_INT 3
17671: PPUSH
17672: LD_INT 8
17674: PPUSH
17675: LD_INT 2
17677: PPUSH
17678: LD_INT 1
17680: PPUSH
17681: CALL_OW 80
// KurtAttack = true ;
17685: LD_ADDR_EXP 25
17689: PUSH
17690: LD_INT 1
17692: ST_TO_ADDR
// KurtWaitingForBuildBarrack = false ;
17693: LD_ADDR_EXP 24
17697: PUSH
17698: LD_INT 0
17700: ST_TO_ADDR
// end ; enable ;
17701: ENABLE
// end ; end_of_file
17702: END
// export currentAmWave , currentArWave ; every 0 0$1 trigger americansAttack do var i ;
17703: LD_EXP 26
17707: IFFALSE 17853
17709: GO 17711
17711: DISABLE
17712: LD_INT 0
17714: PPUSH
// begin currentAmWave = 0 ;
17715: LD_ADDR_EXP 85
17719: PUSH
17720: LD_INT 0
17722: ST_TO_ADDR
// wait ( firstAttackDelay ) ;
17723: LD_EXP 49
17727: PPUSH
17728: CALL_OW 67
// for i := 1 to americansAttackWaves do
17732: LD_ADDR_VAR 0 1
17736: PUSH
17737: DOUBLE
17738: LD_INT 1
17740: DEC
17741: ST_TO_ADDR
17742: LD_EXP 48
17746: PUSH
17747: FOR_TO
17748: IFFALSE 17851
// begin SpawnAmAttackTeam ;
17750: CALL 3140 0 0
// currentAmWave = currentAmWave + 1 ;
17754: LD_ADDR_EXP 85
17758: PUSH
17759: LD_EXP 85
17763: PUSH
17764: LD_INT 1
17766: PLUS
17767: ST_TO_ADDR
// if currentAmWave = 1 then
17768: LD_EXP 85
17772: PUSH
17773: LD_INT 1
17775: EQUAL
17776: IFFALSE 17840
// begin if paidLegionOffert then
17778: LD_EXP 32
17782: IFFALSE 17821
// begin Say ( Burlak , DAmAttackStart-Bur-1 ) ;
17784: LD_EXP 57
17788: PPUSH
17789: LD_STRING DAmAttackStart-Bur-1
17791: PPUSH
17792: CALL_OW 88
// if IsOK ( Gleb ) then
17796: LD_EXP 60
17800: PPUSH
17801: CALL_OW 302
17805: IFFALSE 17819
// Say ( Gleb , DAmAttackStart-Glb-1 ) ;
17807: LD_EXP 60
17811: PPUSH
17812: LD_STRING DAmAttackStart-Glb-1
17814: PPUSH
17815: CALL_OW 88
// end else
17819: GO 17833
// Say ( Burlak , DAmAttackStart-Bur-2 ) ;
17821: LD_EXP 57
17825: PPUSH
17826: LD_STRING DAmAttackStart-Bur-2
17828: PPUSH
17829: CALL_OW 88
// ChangeMissionObjectives ( MEnemy ) ;
17833: LD_STRING MEnemy
17835: PPUSH
17836: CALL_OW 337
// end ; wait ( waveCooldown ) ;
17840: LD_EXP 50
17844: PPUSH
17845: CALL_OW 67
// end ;
17849: GO 17747
17851: POP
17852: POP
// end ;
17853: PPOPN 1
17855: END
// every 0 0$1 trigger currentAmWave = 1 do
17856: LD_EXP 85
17860: PUSH
17861: LD_INT 1
17863: EQUAL
17864: IFFALSE 17953
17866: GO 17868
17868: DISABLE
// Attack ( [ 0 , amAttackTeam , [ [ 115 , 42 ] , [ 51 , 67 ] ] , [ 0 , 0 , 0 , 1 , 1 , 1 , 0 , 0 , 1 , 0 ] ] ) ;
17869: LD_INT 0
17871: PUSH
17872: LD_EXP 78
17876: PUSH
17877: LD_INT 115
17879: PUSH
17880: LD_INT 42
17882: PUSH
17883: EMPTY
17884: LIST
17885: LIST
17886: PUSH
17887: LD_INT 51
17889: PUSH
17890: LD_INT 67
17892: PUSH
17893: EMPTY
17894: LIST
17895: LIST
17896: PUSH
17897: EMPTY
17898: LIST
17899: LIST
17900: PUSH
17901: LD_INT 0
17903: PUSH
17904: LD_INT 0
17906: PUSH
17907: LD_INT 0
17909: PUSH
17910: LD_INT 1
17912: PUSH
17913: LD_INT 1
17915: PUSH
17916: LD_INT 1
17918: PUSH
17919: LD_INT 0
17921: PUSH
17922: LD_INT 0
17924: PUSH
17925: LD_INT 1
17927: PUSH
17928: LD_INT 0
17930: PUSH
17931: EMPTY
17932: LIST
17933: LIST
17934: LIST
17935: LIST
17936: LIST
17937: LIST
17938: LIST
17939: LIST
17940: LIST
17941: LIST
17942: PUSH
17943: EMPTY
17944: LIST
17945: LIST
17946: LIST
17947: LIST
17948: PPUSH
17949: CALL 74295 0 1
17953: END
// every 0 0$1 trigger currentAmWave = 2 do
17954: LD_EXP 85
17958: PUSH
17959: LD_INT 2
17961: EQUAL
17962: IFFALSE 18051
17964: GO 17966
17966: DISABLE
// Attack ( [ 0 , amAttackTeam , [ [ 115 , 42 ] , [ 51 , 67 ] ] , [ 0 , 0 , 0 , 1 , 1 , 1 , 0 , 0 , 1 , 0 ] ] ) ;
17967: LD_INT 0
17969: PUSH
17970: LD_EXP 78
17974: PUSH
17975: LD_INT 115
17977: PUSH
17978: LD_INT 42
17980: PUSH
17981: EMPTY
17982: LIST
17983: LIST
17984: PUSH
17985: LD_INT 51
17987: PUSH
17988: LD_INT 67
17990: PUSH
17991: EMPTY
17992: LIST
17993: LIST
17994: PUSH
17995: EMPTY
17996: LIST
17997: LIST
17998: PUSH
17999: LD_INT 0
18001: PUSH
18002: LD_INT 0
18004: PUSH
18005: LD_INT 0
18007: PUSH
18008: LD_INT 1
18010: PUSH
18011: LD_INT 1
18013: PUSH
18014: LD_INT 1
18016: PUSH
18017: LD_INT 0
18019: PUSH
18020: LD_INT 0
18022: PUSH
18023: LD_INT 1
18025: PUSH
18026: LD_INT 0
18028: PUSH
18029: EMPTY
18030: LIST
18031: LIST
18032: LIST
18033: LIST
18034: LIST
18035: LIST
18036: LIST
18037: LIST
18038: LIST
18039: LIST
18040: PUSH
18041: EMPTY
18042: LIST
18043: LIST
18044: LIST
18045: LIST
18046: PPUSH
18047: CALL 74295 0 1
18051: END
// every 0 0$1 trigger currentAmWave = 3 do
18052: LD_EXP 85
18056: PUSH
18057: LD_INT 3
18059: EQUAL
18060: IFFALSE 18149
18062: GO 18064
18064: DISABLE
// Attack ( [ 0 , amAttackTeam , [ [ 115 , 42 ] , [ 51 , 67 ] ] , [ 0 , 0 , 0 , 1 , 1 , 1 , 0 , 0 , 1 , 0 ] ] ) ;
18065: LD_INT 0
18067: PUSH
18068: LD_EXP 78
18072: PUSH
18073: LD_INT 115
18075: PUSH
18076: LD_INT 42
18078: PUSH
18079: EMPTY
18080: LIST
18081: LIST
18082: PUSH
18083: LD_INT 51
18085: PUSH
18086: LD_INT 67
18088: PUSH
18089: EMPTY
18090: LIST
18091: LIST
18092: PUSH
18093: EMPTY
18094: LIST
18095: LIST
18096: PUSH
18097: LD_INT 0
18099: PUSH
18100: LD_INT 0
18102: PUSH
18103: LD_INT 0
18105: PUSH
18106: LD_INT 1
18108: PUSH
18109: LD_INT 1
18111: PUSH
18112: LD_INT 1
18114: PUSH
18115: LD_INT 0
18117: PUSH
18118: LD_INT 0
18120: PUSH
18121: LD_INT 1
18123: PUSH
18124: LD_INT 0
18126: PUSH
18127: EMPTY
18128: LIST
18129: LIST
18130: LIST
18131: LIST
18132: LIST
18133: LIST
18134: LIST
18135: LIST
18136: LIST
18137: LIST
18138: PUSH
18139: EMPTY
18140: LIST
18141: LIST
18142: LIST
18143: LIST
18144: PPUSH
18145: CALL 74295 0 1
18149: END
// every 0 0$1 trigger KurtAttack do var i ;
18150: LD_EXP 25
18154: IFFALSE 18275
18156: GO 18158
18158: DISABLE
18159: LD_INT 0
18161: PPUSH
// begin currentArWave = 0 ;
18162: LD_ADDR_EXP 86
18166: PUSH
18167: LD_INT 0
18169: ST_TO_ADDR
// wait ( firstAttackDelay ) ;
18170: LD_EXP 49
18174: PPUSH
18175: CALL_OW 67
// for i := 1 to KurtAttackWaves do
18179: LD_ADDR_VAR 0 1
18183: PUSH
18184: DOUBLE
18185: LD_INT 1
18187: DEC
18188: ST_TO_ADDR
18189: LD_EXP 47
18193: PUSH
18194: FOR_TO
18195: IFFALSE 18273
// begin if KurtAttack and IsOK ( Heike ) then
18197: LD_EXP 25
18201: PUSH
18202: LD_EXP 79
18206: PPUSH
18207: CALL_OW 302
18211: AND
18212: IFFALSE 18271
// begin SpawnArAttackTeam ;
18214: CALL 4285 0 0
// currentArWave = currentArWave + 1 ;
18218: LD_ADDR_EXP 86
18222: PUSH
18223: LD_EXP 86
18227: PUSH
18228: LD_INT 1
18230: PLUS
18231: ST_TO_ADDR
// if currentArWave = 2 then
18232: LD_EXP 86
18236: PUSH
18237: LD_INT 2
18239: EQUAL
18240: IFFALSE 18262
// begin SayRadio ( Kurt , DMercAttack-Kurt-1 ) ;
18242: LD_EXP 80
18246: PPUSH
18247: LD_STRING DMercAttack-Kurt-1
18249: PPUSH
18250: CALL_OW 94
// canSendHeike = true ;
18254: LD_ADDR_EXP 28
18258: PUSH
18259: LD_INT 1
18261: ST_TO_ADDR
// end ; wait ( waveCooldown ) ;
18262: LD_EXP 50
18266: PPUSH
18267: CALL_OW 67
// end ; end ;
18271: GO 18194
18273: POP
18274: POP
// end ;
18275: PPOPN 1
18277: END
// every 0 0$1 trigger currentArWave = 1 do
18278: LD_EXP 86
18282: PUSH
18283: LD_INT 1
18285: EQUAL
18286: IFFALSE 18375
18288: GO 18290
18290: DISABLE
// Attack ( [ 0 , arAttackTeam , [ [ 115 , 42 ] , [ 51 , 67 ] ] , [ 0 , 0 , 0 , 1 , 1 , 1 , 0 , 0 , 1 , 0 ] ] ) ;
18291: LD_INT 0
18293: PUSH
18294: LD_EXP 84
18298: PUSH
18299: LD_INT 115
18301: PUSH
18302: LD_INT 42
18304: PUSH
18305: EMPTY
18306: LIST
18307: LIST
18308: PUSH
18309: LD_INT 51
18311: PUSH
18312: LD_INT 67
18314: PUSH
18315: EMPTY
18316: LIST
18317: LIST
18318: PUSH
18319: EMPTY
18320: LIST
18321: LIST
18322: PUSH
18323: LD_INT 0
18325: PUSH
18326: LD_INT 0
18328: PUSH
18329: LD_INT 0
18331: PUSH
18332: LD_INT 1
18334: PUSH
18335: LD_INT 1
18337: PUSH
18338: LD_INT 1
18340: PUSH
18341: LD_INT 0
18343: PUSH
18344: LD_INT 0
18346: PUSH
18347: LD_INT 1
18349: PUSH
18350: LD_INT 0
18352: PUSH
18353: EMPTY
18354: LIST
18355: LIST
18356: LIST
18357: LIST
18358: LIST
18359: LIST
18360: LIST
18361: LIST
18362: LIST
18363: LIST
18364: PUSH
18365: EMPTY
18366: LIST
18367: LIST
18368: LIST
18369: LIST
18370: PPUSH
18371: CALL 74295 0 1
18375: END
// every 0 0$1 trigger currentArWave = 2 do
18376: LD_EXP 86
18380: PUSH
18381: LD_INT 2
18383: EQUAL
18384: IFFALSE 18473
18386: GO 18388
18388: DISABLE
// Attack ( [ 0 , arAttackTeam , [ [ 115 , 42 ] , [ 51 , 67 ] ] , [ 0 , 0 , 0 , 1 , 1 , 1 , 0 , 0 , 1 , 0 ] ] ) ;
18389: LD_INT 0
18391: PUSH
18392: LD_EXP 84
18396: PUSH
18397: LD_INT 115
18399: PUSH
18400: LD_INT 42
18402: PUSH
18403: EMPTY
18404: LIST
18405: LIST
18406: PUSH
18407: LD_INT 51
18409: PUSH
18410: LD_INT 67
18412: PUSH
18413: EMPTY
18414: LIST
18415: LIST
18416: PUSH
18417: EMPTY
18418: LIST
18419: LIST
18420: PUSH
18421: LD_INT 0
18423: PUSH
18424: LD_INT 0
18426: PUSH
18427: LD_INT 0
18429: PUSH
18430: LD_INT 1
18432: PUSH
18433: LD_INT 1
18435: PUSH
18436: LD_INT 1
18438: PUSH
18439: LD_INT 0
18441: PUSH
18442: LD_INT 0
18444: PUSH
18445: LD_INT 1
18447: PUSH
18448: LD_INT 0
18450: PUSH
18451: EMPTY
18452: LIST
18453: LIST
18454: LIST
18455: LIST
18456: LIST
18457: LIST
18458: LIST
18459: LIST
18460: LIST
18461: LIST
18462: PUSH
18463: EMPTY
18464: LIST
18465: LIST
18466: LIST
18467: LIST
18468: PPUSH
18469: CALL 74295 0 1
18473: END
// every 0 0$1 trigger currentArWave = 3 do
18474: LD_EXP 86
18478: PUSH
18479: LD_INT 3
18481: EQUAL
18482: IFFALSE 18571
18484: GO 18486
18486: DISABLE
// Attack ( [ 0 , arAttackTeam , [ [ 115 , 42 ] , [ 51 , 67 ] ] , [ 0 , 0 , 0 , 1 , 1 , 1 , 0 , 0 , 1 , 0 ] ] ) ;
18487: LD_INT 0
18489: PUSH
18490: LD_EXP 84
18494: PUSH
18495: LD_INT 115
18497: PUSH
18498: LD_INT 42
18500: PUSH
18501: EMPTY
18502: LIST
18503: LIST
18504: PUSH
18505: LD_INT 51
18507: PUSH
18508: LD_INT 67
18510: PUSH
18511: EMPTY
18512: LIST
18513: LIST
18514: PUSH
18515: EMPTY
18516: LIST
18517: LIST
18518: PUSH
18519: LD_INT 0
18521: PUSH
18522: LD_INT 0
18524: PUSH
18525: LD_INT 0
18527: PUSH
18528: LD_INT 1
18530: PUSH
18531: LD_INT 1
18533: PUSH
18534: LD_INT 1
18536: PUSH
18537: LD_INT 0
18539: PUSH
18540: LD_INT 0
18542: PUSH
18543: LD_INT 1
18545: PUSH
18546: LD_INT 0
18548: PUSH
18549: EMPTY
18550: LIST
18551: LIST
18552: LIST
18553: LIST
18554: LIST
18555: LIST
18556: LIST
18557: LIST
18558: LIST
18559: LIST
18560: PUSH
18561: EMPTY
18562: LIST
18563: LIST
18564: LIST
18565: LIST
18566: PPUSH
18567: CALL 74295 0 1
18571: END
// every 0 0$1 trigger currentArWave = 4 do
18572: LD_EXP 86
18576: PUSH
18577: LD_INT 4
18579: EQUAL
18580: IFFALSE 18669
18582: GO 18584
18584: DISABLE
// Attack ( [ 0 , arAttackTeam , [ [ 115 , 42 ] , [ 51 , 67 ] ] , [ 0 , 0 , 0 , 1 , 1 , 1 , 0 , 0 , 1 , 0 ] ] ) ;
18585: LD_INT 0
18587: PUSH
18588: LD_EXP 84
18592: PUSH
18593: LD_INT 115
18595: PUSH
18596: LD_INT 42
18598: PUSH
18599: EMPTY
18600: LIST
18601: LIST
18602: PUSH
18603: LD_INT 51
18605: PUSH
18606: LD_INT 67
18608: PUSH
18609: EMPTY
18610: LIST
18611: LIST
18612: PUSH
18613: EMPTY
18614: LIST
18615: LIST
18616: PUSH
18617: LD_INT 0
18619: PUSH
18620: LD_INT 0
18622: PUSH
18623: LD_INT 0
18625: PUSH
18626: LD_INT 1
18628: PUSH
18629: LD_INT 1
18631: PUSH
18632: LD_INT 1
18634: PUSH
18635: LD_INT 0
18637: PUSH
18638: LD_INT 0
18640: PUSH
18641: LD_INT 1
18643: PUSH
18644: LD_INT 0
18646: PUSH
18647: EMPTY
18648: LIST
18649: LIST
18650: LIST
18651: LIST
18652: LIST
18653: LIST
18654: LIST
18655: LIST
18656: LIST
18657: LIST
18658: PUSH
18659: EMPTY
18660: LIST
18661: LIST
18662: LIST
18663: LIST
18664: PPUSH
18665: CALL 74295 0 1
18669: END
// every 0 0$1 trigger currentArWave = 5 do
18670: LD_EXP 86
18674: PUSH
18675: LD_INT 5
18677: EQUAL
18678: IFFALSE 18767
18680: GO 18682
18682: DISABLE
// Attack ( [ 0 , arAttackTeam , [ [ 115 , 42 ] , [ 51 , 67 ] ] , [ 0 , 0 , 0 , 1 , 1 , 1 , 0 , 0 , 1 , 0 ] ] ) ; end_of_file
18683: LD_INT 0
18685: PUSH
18686: LD_EXP 84
18690: PUSH
18691: LD_INT 115
18693: PUSH
18694: LD_INT 42
18696: PUSH
18697: EMPTY
18698: LIST
18699: LIST
18700: PUSH
18701: LD_INT 51
18703: PUSH
18704: LD_INT 67
18706: PUSH
18707: EMPTY
18708: LIST
18709: LIST
18710: PUSH
18711: EMPTY
18712: LIST
18713: LIST
18714: PUSH
18715: LD_INT 0
18717: PUSH
18718: LD_INT 0
18720: PUSH
18721: LD_INT 0
18723: PUSH
18724: LD_INT 1
18726: PUSH
18727: LD_INT 1
18729: PUSH
18730: LD_INT 1
18732: PUSH
18733: LD_INT 0
18735: PUSH
18736: LD_INT 0
18738: PUSH
18739: LD_INT 1
18741: PUSH
18742: LD_INT 0
18744: PUSH
18745: EMPTY
18746: LIST
18747: LIST
18748: LIST
18749: LIST
18750: LIST
18751: LIST
18752: LIST
18753: LIST
18754: LIST
18755: LIST
18756: PUSH
18757: EMPTY
18758: LIST
18759: LIST
18760: LIST
18761: LIST
18762: PPUSH
18763: CALL 74295 0 1
18767: END
// every 0 0$1 do var arVehs , arVeh , nearPlayerUnit ;
18768: GO 18770
18770: DISABLE
18771: LD_INT 0
18773: PPUSH
18774: PPUSH
18775: PPUSH
// begin enable ;
18776: ENABLE
// arVehs = FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_vehicle ] , [ f_empty ] ] ) ;
18777: LD_ADDR_VAR 0 1
18781: PUSH
18782: LD_INT 22
18784: PUSH
18785: LD_INT 8
18787: PUSH
18788: EMPTY
18789: LIST
18790: LIST
18791: PUSH
18792: LD_INT 21
18794: PUSH
18795: LD_INT 2
18797: PUSH
18798: EMPTY
18799: LIST
18800: LIST
18801: PUSH
18802: LD_INT 58
18804: PUSH
18805: EMPTY
18806: LIST
18807: PUSH
18808: EMPTY
18809: LIST
18810: LIST
18811: LIST
18812: PPUSH
18813: CALL_OW 69
18817: ST_TO_ADDR
// if not arVehs or not GetAttitude ( 3 , 8 ) = att_enemy then
18818: LD_VAR 0 1
18822: NOT
18823: PUSH
18824: LD_INT 3
18826: PPUSH
18827: LD_INT 8
18829: PPUSH
18830: CALL_OW 81
18834: PUSH
18835: LD_INT 2
18837: EQUAL
18838: NOT
18839: OR
18840: IFFALSE 18844
// exit ;
18842: GO 18934
// for arVeh in arVehs do
18844: LD_ADDR_VAR 0 2
18848: PUSH
18849: LD_VAR 0 1
18853: PUSH
18854: FOR_IN
18855: IFFALSE 18932
// begin nearPlayerUnit = NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) , arVeh ) ;
18857: LD_ADDR_VAR 0 3
18861: PUSH
18862: LD_INT 22
18864: PUSH
18865: LD_INT 3
18867: PUSH
18868: EMPTY
18869: LIST
18870: LIST
18871: PUSH
18872: LD_INT 21
18874: PUSH
18875: LD_INT 1
18877: PUSH
18878: EMPTY
18879: LIST
18880: LIST
18881: PUSH
18882: EMPTY
18883: LIST
18884: LIST
18885: PPUSH
18886: CALL_OW 69
18890: PPUSH
18891: LD_VAR 0 2
18895: PPUSH
18896: CALL_OW 74
18900: ST_TO_ADDR
// if GetDistUnits ( nearPlayerUnit , arVeh ) <= 2 then
18901: LD_VAR 0 3
18905: PPUSH
18906: LD_VAR 0 2
18910: PPUSH
18911: CALL_OW 296
18915: PUSH
18916: LD_INT 2
18918: LESSEQUAL
18919: IFFALSE 18930
// ComSelfDestruction ( arVeh ) ;
18921: LD_VAR 0 2
18925: PPUSH
18926: CALL_OW 577
// end ;
18930: GO 18854
18932: POP
18933: POP
// end ;
18934: PPOPN 3
18936: END
// every 0 0$1 trigger forceStopKurtAttack do
18937: LD_EXP 27
18941: IFFALSE 19007
18943: GO 18945
18945: DISABLE
// begin KurtAttack = false ;
18946: LD_ADDR_EXP 25
18950: PUSH
18951: LD_INT 0
18953: ST_TO_ADDR
// allowExitFromMap = 4 ;
18954: LD_ADDR_EXP 18
18958: PUSH
18959: LD_INT 4
18961: ST_TO_ADDR
// SetAttitude ( 3 , 8 , att_friend , true ) ;
18962: LD_INT 3
18964: PPUSH
18965: LD_INT 8
18967: PPUSH
18968: LD_INT 1
18970: PPUSH
18971: LD_INT 1
18973: PPUSH
18974: CALL_OW 80
// arAttackTeam = [ ] ;
18978: LD_ADDR_EXP 84
18982: PUSH
18983: EMPTY
18984: ST_TO_ADDR
// ComMoveToArea ( FilterAllUnits ( [ f_side , 8 ] ) , KurtExitMapArea ) ;
18985: LD_INT 22
18987: PUSH
18988: LD_INT 8
18990: PUSH
18991: EMPTY
18992: LIST
18993: LIST
18994: PPUSH
18995: CALL_OW 69
18999: PPUSH
19000: LD_INT 11
19002: PPUSH
19003: CALL_OW 113
// end ; end_of_file end_of_file
19007: END
// every 0 0$01 do var timer , cratesSpawned ;
19008: GO 19010
19010: DISABLE
19011: LD_INT 0
19013: PPUSH
19014: PPUSH
// begin timer := 1 1$30 ;
19015: LD_ADDR_VAR 0 1
19019: PUSH
19020: LD_INT 3150
19022: ST_TO_ADDR
// repeat wait ( timer ) ;
19023: LD_VAR 0 1
19027: PPUSH
19028: CALL_OW 67
// if cratesSpawned >= 6 and cratesSpawned < 18 then
19032: LD_VAR 0 2
19036: PUSH
19037: LD_INT 6
19039: GREATEREQUAL
19040: PUSH
19041: LD_VAR 0 2
19045: PUSH
19046: LD_INT 18
19048: LESS
19049: AND
19050: IFFALSE 19066
// timer := timer + 0 0$3 ;
19052: LD_ADDR_VAR 0 1
19056: PUSH
19057: LD_VAR 0 1
19061: PUSH
19062: LD_INT 105
19064: PLUS
19065: ST_TO_ADDR
// if cratesSpawned >= 18 then
19066: LD_VAR 0 2
19070: PUSH
19071: LD_INT 18
19073: GREATEREQUAL
19074: IFFALSE 19090
// timer := timer + 0 0$9 ;
19076: LD_ADDR_VAR 0 1
19080: PUSH
19081: LD_VAR 0 1
19085: PUSH
19086: LD_INT 315
19088: PLUS
19089: ST_TO_ADDR
// if timer > 3 3$00 then
19090: LD_VAR 0 1
19094: PUSH
19095: LD_INT 6300
19097: GREATER
19098: IFFALSE 19108
// timer := 0 0$50 ;
19100: LD_ADDR_VAR 0 1
19104: PUSH
19105: LD_INT 1750
19107: ST_TO_ADDR
// CreateCratesArea ( rand ( 3 , 5 ) , CratesSpawnArea , true ) ;
19108: LD_INT 3
19110: PPUSH
19111: LD_INT 5
19113: PPUSH
19114: CALL_OW 12
19118: PPUSH
19119: LD_INT 15
19121: PPUSH
19122: LD_INT 1
19124: PPUSH
19125: CALL_OW 55
// cratesSpawned = cratesSpawned + 1 ;
19129: LD_ADDR_VAR 0 2
19133: PUSH
19134: LD_VAR 0 2
19138: PUSH
19139: LD_INT 1
19141: PLUS
19142: ST_TO_ADDR
// until false ;
19143: LD_INT 0
19145: IFFALSE 19023
// end ; end_of_file
19147: PPOPN 2
19149: END
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
19150: LD_INT 0
19152: PPUSH
19153: PPUSH
// if exist_mode then
19154: LD_VAR 0 2
19158: IFFALSE 19183
// unit := CreateCharacter ( prefix & ident ) else
19160: LD_ADDR_VAR 0 5
19164: PUSH
19165: LD_VAR 0 3
19169: PUSH
19170: LD_VAR 0 1
19174: STR
19175: PPUSH
19176: CALL_OW 34
19180: ST_TO_ADDR
19181: GO 19198
// unit := NewCharacter ( ident ) ;
19183: LD_ADDR_VAR 0 5
19187: PUSH
19188: LD_VAR 0 1
19192: PPUSH
19193: CALL_OW 25
19197: ST_TO_ADDR
// result := unit ;
19198: LD_ADDR_VAR 0 4
19202: PUSH
19203: LD_VAR 0 5
19207: ST_TO_ADDR
// end ;
19208: LD_VAR 0 4
19212: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
19213: LD_INT 0
19215: PPUSH
19216: PPUSH
// if not side or not nation then
19217: LD_VAR 0 1
19221: NOT
19222: PUSH
19223: LD_VAR 0 2
19227: NOT
19228: OR
19229: IFFALSE 19233
// exit ;
19231: GO 19997
// case nation of nation_american :
19233: LD_VAR 0 2
19237: PUSH
19238: LD_INT 1
19240: DOUBLE
19241: EQUAL
19242: IFTRUE 19246
19244: GO 19460
19246: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
19247: LD_ADDR_VAR 0 4
19251: PUSH
19252: LD_INT 35
19254: PUSH
19255: LD_INT 45
19257: PUSH
19258: LD_INT 46
19260: PUSH
19261: LD_INT 47
19263: PUSH
19264: LD_INT 82
19266: PUSH
19267: LD_INT 83
19269: PUSH
19270: LD_INT 84
19272: PUSH
19273: LD_INT 85
19275: PUSH
19276: LD_INT 86
19278: PUSH
19279: LD_INT 1
19281: PUSH
19282: LD_INT 2
19284: PUSH
19285: LD_INT 6
19287: PUSH
19288: LD_INT 15
19290: PUSH
19291: LD_INT 16
19293: PUSH
19294: LD_INT 7
19296: PUSH
19297: LD_INT 12
19299: PUSH
19300: LD_INT 13
19302: PUSH
19303: LD_INT 10
19305: PUSH
19306: LD_INT 14
19308: PUSH
19309: LD_INT 20
19311: PUSH
19312: LD_INT 21
19314: PUSH
19315: LD_INT 22
19317: PUSH
19318: LD_INT 25
19320: PUSH
19321: LD_INT 32
19323: PUSH
19324: LD_INT 27
19326: PUSH
19327: LD_INT 36
19329: PUSH
19330: LD_INT 69
19332: PUSH
19333: LD_INT 39
19335: PUSH
19336: LD_INT 34
19338: PUSH
19339: LD_INT 40
19341: PUSH
19342: LD_INT 48
19344: PUSH
19345: LD_INT 49
19347: PUSH
19348: LD_INT 50
19350: PUSH
19351: LD_INT 51
19353: PUSH
19354: LD_INT 52
19356: PUSH
19357: LD_INT 53
19359: PUSH
19360: LD_INT 54
19362: PUSH
19363: LD_INT 55
19365: PUSH
19366: LD_INT 56
19368: PUSH
19369: LD_INT 57
19371: PUSH
19372: LD_INT 58
19374: PUSH
19375: LD_INT 59
19377: PUSH
19378: LD_INT 60
19380: PUSH
19381: LD_INT 61
19383: PUSH
19384: LD_INT 62
19386: PUSH
19387: LD_INT 80
19389: PUSH
19390: LD_INT 82
19392: PUSH
19393: LD_INT 83
19395: PUSH
19396: LD_INT 84
19398: PUSH
19399: LD_INT 85
19401: PUSH
19402: LD_INT 86
19404: PUSH
19405: EMPTY
19406: LIST
19407: LIST
19408: LIST
19409: LIST
19410: LIST
19411: LIST
19412: LIST
19413: LIST
19414: LIST
19415: LIST
19416: LIST
19417: LIST
19418: LIST
19419: LIST
19420: LIST
19421: LIST
19422: LIST
19423: LIST
19424: LIST
19425: LIST
19426: LIST
19427: LIST
19428: LIST
19429: LIST
19430: LIST
19431: LIST
19432: LIST
19433: LIST
19434: LIST
19435: LIST
19436: LIST
19437: LIST
19438: LIST
19439: LIST
19440: LIST
19441: LIST
19442: LIST
19443: LIST
19444: LIST
19445: LIST
19446: LIST
19447: LIST
19448: LIST
19449: LIST
19450: LIST
19451: LIST
19452: LIST
19453: LIST
19454: LIST
19455: LIST
19456: LIST
19457: ST_TO_ADDR
19458: GO 19921
19460: LD_INT 2
19462: DOUBLE
19463: EQUAL
19464: IFTRUE 19468
19466: GO 19690
19468: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 ] ; nation_russian :
19469: LD_ADDR_VAR 0 4
19473: PUSH
19474: LD_INT 35
19476: PUSH
19477: LD_INT 45
19479: PUSH
19480: LD_INT 46
19482: PUSH
19483: LD_INT 47
19485: PUSH
19486: LD_INT 82
19488: PUSH
19489: LD_INT 83
19491: PUSH
19492: LD_INT 84
19494: PUSH
19495: LD_INT 85
19497: PUSH
19498: LD_INT 87
19500: PUSH
19501: LD_INT 70
19503: PUSH
19504: LD_INT 1
19506: PUSH
19507: LD_INT 11
19509: PUSH
19510: LD_INT 3
19512: PUSH
19513: LD_INT 4
19515: PUSH
19516: LD_INT 5
19518: PUSH
19519: LD_INT 6
19521: PUSH
19522: LD_INT 15
19524: PUSH
19525: LD_INT 18
19527: PUSH
19528: LD_INT 7
19530: PUSH
19531: LD_INT 17
19533: PUSH
19534: LD_INT 8
19536: PUSH
19537: LD_INT 20
19539: PUSH
19540: LD_INT 21
19542: PUSH
19543: LD_INT 22
19545: PUSH
19546: LD_INT 72
19548: PUSH
19549: LD_INT 26
19551: PUSH
19552: LD_INT 69
19554: PUSH
19555: LD_INT 39
19557: PUSH
19558: LD_INT 40
19560: PUSH
19561: LD_INT 41
19563: PUSH
19564: LD_INT 42
19566: PUSH
19567: LD_INT 43
19569: PUSH
19570: LD_INT 48
19572: PUSH
19573: LD_INT 49
19575: PUSH
19576: LD_INT 50
19578: PUSH
19579: LD_INT 51
19581: PUSH
19582: LD_INT 52
19584: PUSH
19585: LD_INT 53
19587: PUSH
19588: LD_INT 54
19590: PUSH
19591: LD_INT 55
19593: PUSH
19594: LD_INT 56
19596: PUSH
19597: LD_INT 60
19599: PUSH
19600: LD_INT 61
19602: PUSH
19603: LD_INT 62
19605: PUSH
19606: LD_INT 66
19608: PUSH
19609: LD_INT 67
19611: PUSH
19612: LD_INT 68
19614: PUSH
19615: LD_INT 81
19617: PUSH
19618: LD_INT 82
19620: PUSH
19621: LD_INT 83
19623: PUSH
19624: LD_INT 84
19626: PUSH
19627: LD_INT 85
19629: PUSH
19630: LD_INT 87
19632: PUSH
19633: EMPTY
19634: LIST
19635: LIST
19636: LIST
19637: LIST
19638: LIST
19639: LIST
19640: LIST
19641: LIST
19642: LIST
19643: LIST
19644: LIST
19645: LIST
19646: LIST
19647: LIST
19648: LIST
19649: LIST
19650: LIST
19651: LIST
19652: LIST
19653: LIST
19654: LIST
19655: LIST
19656: LIST
19657: LIST
19658: LIST
19659: LIST
19660: LIST
19661: LIST
19662: LIST
19663: LIST
19664: LIST
19665: LIST
19666: LIST
19667: LIST
19668: LIST
19669: LIST
19670: LIST
19671: LIST
19672: LIST
19673: LIST
19674: LIST
19675: LIST
19676: LIST
19677: LIST
19678: LIST
19679: LIST
19680: LIST
19681: LIST
19682: LIST
19683: LIST
19684: LIST
19685: LIST
19686: LIST
19687: ST_TO_ADDR
19688: GO 19921
19690: LD_INT 3
19692: DOUBLE
19693: EQUAL
19694: IFTRUE 19698
19696: GO 19920
19698: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
19699: LD_ADDR_VAR 0 4
19703: PUSH
19704: LD_INT 46
19706: PUSH
19707: LD_INT 47
19709: PUSH
19710: LD_INT 1
19712: PUSH
19713: LD_INT 2
19715: PUSH
19716: LD_INT 82
19718: PUSH
19719: LD_INT 83
19721: PUSH
19722: LD_INT 84
19724: PUSH
19725: LD_INT 85
19727: PUSH
19728: LD_INT 86
19730: PUSH
19731: LD_INT 11
19733: PUSH
19734: LD_INT 9
19736: PUSH
19737: LD_INT 20
19739: PUSH
19740: LD_INT 19
19742: PUSH
19743: LD_INT 21
19745: PUSH
19746: LD_INT 24
19748: PUSH
19749: LD_INT 22
19751: PUSH
19752: LD_INT 25
19754: PUSH
19755: LD_INT 28
19757: PUSH
19758: LD_INT 29
19760: PUSH
19761: LD_INT 30
19763: PUSH
19764: LD_INT 31
19766: PUSH
19767: LD_INT 37
19769: PUSH
19770: LD_INT 38
19772: PUSH
19773: LD_INT 32
19775: PUSH
19776: LD_INT 27
19778: PUSH
19779: LD_INT 33
19781: PUSH
19782: LD_INT 69
19784: PUSH
19785: LD_INT 39
19787: PUSH
19788: LD_INT 34
19790: PUSH
19791: LD_INT 40
19793: PUSH
19794: LD_INT 71
19796: PUSH
19797: LD_INT 23
19799: PUSH
19800: LD_INT 44
19802: PUSH
19803: LD_INT 48
19805: PUSH
19806: LD_INT 49
19808: PUSH
19809: LD_INT 50
19811: PUSH
19812: LD_INT 51
19814: PUSH
19815: LD_INT 52
19817: PUSH
19818: LD_INT 53
19820: PUSH
19821: LD_INT 54
19823: PUSH
19824: LD_INT 55
19826: PUSH
19827: LD_INT 56
19829: PUSH
19830: LD_INT 57
19832: PUSH
19833: LD_INT 58
19835: PUSH
19836: LD_INT 59
19838: PUSH
19839: LD_INT 63
19841: PUSH
19842: LD_INT 64
19844: PUSH
19845: LD_INT 65
19847: PUSH
19848: LD_INT 82
19850: PUSH
19851: LD_INT 83
19853: PUSH
19854: LD_INT 84
19856: PUSH
19857: LD_INT 85
19859: PUSH
19860: LD_INT 86
19862: PUSH
19863: EMPTY
19864: LIST
19865: LIST
19866: LIST
19867: LIST
19868: LIST
19869: LIST
19870: LIST
19871: LIST
19872: LIST
19873: LIST
19874: LIST
19875: LIST
19876: LIST
19877: LIST
19878: LIST
19879: LIST
19880: LIST
19881: LIST
19882: LIST
19883: LIST
19884: LIST
19885: LIST
19886: LIST
19887: LIST
19888: LIST
19889: LIST
19890: LIST
19891: LIST
19892: LIST
19893: LIST
19894: LIST
19895: LIST
19896: LIST
19897: LIST
19898: LIST
19899: LIST
19900: LIST
19901: LIST
19902: LIST
19903: LIST
19904: LIST
19905: LIST
19906: LIST
19907: LIST
19908: LIST
19909: LIST
19910: LIST
19911: LIST
19912: LIST
19913: LIST
19914: LIST
19915: LIST
19916: LIST
19917: ST_TO_ADDR
19918: GO 19921
19920: POP
// if state > - 1 and state < 3 then
19921: LD_VAR 0 3
19925: PUSH
19926: LD_INT 1
19928: NEG
19929: GREATER
19930: PUSH
19931: LD_VAR 0 3
19935: PUSH
19936: LD_INT 3
19938: LESS
19939: AND
19940: IFFALSE 19997
// for i in result do
19942: LD_ADDR_VAR 0 5
19946: PUSH
19947: LD_VAR 0 4
19951: PUSH
19952: FOR_IN
19953: IFFALSE 19995
// if GetTech ( i , side ) <> state then
19955: LD_VAR 0 5
19959: PPUSH
19960: LD_VAR 0 1
19964: PPUSH
19965: CALL_OW 321
19969: PUSH
19970: LD_VAR 0 3
19974: NONEQUAL
19975: IFFALSE 19993
// result := result diff i ;
19977: LD_ADDR_VAR 0 4
19981: PUSH
19982: LD_VAR 0 4
19986: PUSH
19987: LD_VAR 0 5
19991: DIFF
19992: ST_TO_ADDR
19993: GO 19952
19995: POP
19996: POP
// end ;
19997: LD_VAR 0 4
20001: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
20002: LD_INT 0
20004: PPUSH
20005: PPUSH
20006: PPUSH
// result := true ;
20007: LD_ADDR_VAR 0 3
20011: PUSH
20012: LD_INT 1
20014: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
20015: LD_ADDR_VAR 0 5
20019: PUSH
20020: LD_VAR 0 2
20024: PPUSH
20025: CALL_OW 480
20029: ST_TO_ADDR
// if not tmp then
20030: LD_VAR 0 5
20034: NOT
20035: IFFALSE 20039
// exit ;
20037: GO 20088
// for i in tmp do
20039: LD_ADDR_VAR 0 4
20043: PUSH
20044: LD_VAR 0 5
20048: PUSH
20049: FOR_IN
20050: IFFALSE 20086
// if GetTech ( i , side ) <> state_researched then
20052: LD_VAR 0 4
20056: PPUSH
20057: LD_VAR 0 1
20061: PPUSH
20062: CALL_OW 321
20066: PUSH
20067: LD_INT 2
20069: NONEQUAL
20070: IFFALSE 20084
// begin result := false ;
20072: LD_ADDR_VAR 0 3
20076: PUSH
20077: LD_INT 0
20079: ST_TO_ADDR
// exit ;
20080: POP
20081: POP
20082: GO 20088
// end ;
20084: GO 20049
20086: POP
20087: POP
// end ;
20088: LD_VAR 0 3
20092: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
20093: LD_INT 0
20095: PPUSH
20096: PPUSH
20097: PPUSH
20098: PPUSH
20099: PPUSH
20100: PPUSH
20101: PPUSH
20102: PPUSH
20103: PPUSH
20104: PPUSH
20105: PPUSH
20106: PPUSH
20107: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
20108: LD_VAR 0 1
20112: NOT
20113: PUSH
20114: LD_VAR 0 1
20118: PPUSH
20119: CALL_OW 257
20123: PUSH
20124: LD_INT 9
20126: NONEQUAL
20127: OR
20128: IFFALSE 20132
// exit ;
20130: GO 20705
// side := GetSide ( unit ) ;
20132: LD_ADDR_VAR 0 9
20136: PUSH
20137: LD_VAR 0 1
20141: PPUSH
20142: CALL_OW 255
20146: ST_TO_ADDR
// tech_space := tech_spacanom ;
20147: LD_ADDR_VAR 0 12
20151: PUSH
20152: LD_INT 29
20154: ST_TO_ADDR
// tech_time := tech_taurad ;
20155: LD_ADDR_VAR 0 13
20159: PUSH
20160: LD_INT 28
20162: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
20163: LD_ADDR_VAR 0 11
20167: PUSH
20168: LD_VAR 0 1
20172: PPUSH
20173: CALL_OW 310
20177: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
20178: LD_VAR 0 11
20182: PPUSH
20183: CALL_OW 247
20187: PUSH
20188: LD_INT 2
20190: EQUAL
20191: IFFALSE 20195
// exit ;
20193: GO 20705
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
20195: LD_ADDR_VAR 0 8
20199: PUSH
20200: LD_INT 81
20202: PUSH
20203: LD_VAR 0 9
20207: PUSH
20208: EMPTY
20209: LIST
20210: LIST
20211: PUSH
20212: LD_INT 3
20214: PUSH
20215: LD_INT 21
20217: PUSH
20218: LD_INT 3
20220: PUSH
20221: EMPTY
20222: LIST
20223: LIST
20224: PUSH
20225: EMPTY
20226: LIST
20227: LIST
20228: PUSH
20229: EMPTY
20230: LIST
20231: LIST
20232: PPUSH
20233: CALL_OW 69
20237: ST_TO_ADDR
// if not tmp then
20238: LD_VAR 0 8
20242: NOT
20243: IFFALSE 20247
// exit ;
20245: GO 20705
// if in_unit then
20247: LD_VAR 0 11
20251: IFFALSE 20275
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
20253: LD_ADDR_VAR 0 10
20257: PUSH
20258: LD_VAR 0 8
20262: PPUSH
20263: LD_VAR 0 11
20267: PPUSH
20268: CALL_OW 74
20272: ST_TO_ADDR
20273: GO 20295
// enemy := NearestUnitToUnit ( tmp , unit ) ;
20275: LD_ADDR_VAR 0 10
20279: PUSH
20280: LD_VAR 0 8
20284: PPUSH
20285: LD_VAR 0 1
20289: PPUSH
20290: CALL_OW 74
20294: ST_TO_ADDR
// if not enemy then
20295: LD_VAR 0 10
20299: NOT
20300: IFFALSE 20304
// exit ;
20302: GO 20705
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
20304: LD_VAR 0 11
20308: PUSH
20309: LD_VAR 0 11
20313: PPUSH
20314: LD_VAR 0 10
20318: PPUSH
20319: CALL_OW 296
20323: PUSH
20324: LD_INT 13
20326: GREATER
20327: AND
20328: PUSH
20329: LD_VAR 0 1
20333: PPUSH
20334: LD_VAR 0 10
20338: PPUSH
20339: CALL_OW 296
20343: PUSH
20344: LD_INT 12
20346: GREATER
20347: OR
20348: IFFALSE 20352
// exit ;
20350: GO 20705
// missile := [ 1 ] ;
20352: LD_ADDR_VAR 0 14
20356: PUSH
20357: LD_INT 1
20359: PUSH
20360: EMPTY
20361: LIST
20362: ST_TO_ADDR
// if Researched ( side , tech_space ) then
20363: LD_VAR 0 9
20367: PPUSH
20368: LD_VAR 0 12
20372: PPUSH
20373: CALL_OW 325
20377: IFFALSE 20406
// missile := Insert ( missile , missile + 1 , 2 ) ;
20379: LD_ADDR_VAR 0 14
20383: PUSH
20384: LD_VAR 0 14
20388: PPUSH
20389: LD_VAR 0 14
20393: PUSH
20394: LD_INT 1
20396: PLUS
20397: PPUSH
20398: LD_INT 2
20400: PPUSH
20401: CALL_OW 2
20405: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
20406: LD_VAR 0 9
20410: PPUSH
20411: LD_VAR 0 13
20415: PPUSH
20416: CALL_OW 325
20420: PUSH
20421: LD_VAR 0 10
20425: PPUSH
20426: CALL_OW 255
20430: PPUSH
20431: LD_VAR 0 13
20435: PPUSH
20436: CALL_OW 325
20440: NOT
20441: AND
20442: IFFALSE 20471
// missile := Insert ( missile , missile + 1 , 3 ) ;
20444: LD_ADDR_VAR 0 14
20448: PUSH
20449: LD_VAR 0 14
20453: PPUSH
20454: LD_VAR 0 14
20458: PUSH
20459: LD_INT 1
20461: PLUS
20462: PPUSH
20463: LD_INT 3
20465: PPUSH
20466: CALL_OW 2
20470: ST_TO_ADDR
// if missile < 2 then
20471: LD_VAR 0 14
20475: PUSH
20476: LD_INT 2
20478: LESS
20479: IFFALSE 20483
// exit ;
20481: GO 20705
// x := GetX ( enemy ) ;
20483: LD_ADDR_VAR 0 4
20487: PUSH
20488: LD_VAR 0 10
20492: PPUSH
20493: CALL_OW 250
20497: ST_TO_ADDR
// y := GetY ( enemy ) ;
20498: LD_ADDR_VAR 0 5
20502: PUSH
20503: LD_VAR 0 10
20507: PPUSH
20508: CALL_OW 251
20512: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
20513: LD_ADDR_VAR 0 6
20517: PUSH
20518: LD_VAR 0 4
20522: PUSH
20523: LD_INT 1
20525: NEG
20526: PPUSH
20527: LD_INT 1
20529: PPUSH
20530: CALL_OW 12
20534: PLUS
20535: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
20536: LD_ADDR_VAR 0 7
20540: PUSH
20541: LD_VAR 0 5
20545: PUSH
20546: LD_INT 1
20548: NEG
20549: PPUSH
20550: LD_INT 1
20552: PPUSH
20553: CALL_OW 12
20557: PLUS
20558: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
20559: LD_VAR 0 6
20563: PPUSH
20564: LD_VAR 0 7
20568: PPUSH
20569: CALL_OW 488
20573: NOT
20574: IFFALSE 20596
// begin _x := x ;
20576: LD_ADDR_VAR 0 6
20580: PUSH
20581: LD_VAR 0 4
20585: ST_TO_ADDR
// _y := y ;
20586: LD_ADDR_VAR 0 7
20590: PUSH
20591: LD_VAR 0 5
20595: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
20596: LD_ADDR_VAR 0 3
20600: PUSH
20601: LD_INT 1
20603: PPUSH
20604: LD_VAR 0 14
20608: PPUSH
20609: CALL_OW 12
20613: ST_TO_ADDR
// case i of 1 :
20614: LD_VAR 0 3
20618: PUSH
20619: LD_INT 1
20621: DOUBLE
20622: EQUAL
20623: IFTRUE 20627
20625: GO 20644
20627: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
20628: LD_VAR 0 1
20632: PPUSH
20633: LD_VAR 0 10
20637: PPUSH
20638: CALL_OW 115
20642: GO 20705
20644: LD_INT 2
20646: DOUBLE
20647: EQUAL
20648: IFTRUE 20652
20650: GO 20674
20652: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
20653: LD_VAR 0 1
20657: PPUSH
20658: LD_VAR 0 6
20662: PPUSH
20663: LD_VAR 0 7
20667: PPUSH
20668: CALL_OW 153
20672: GO 20705
20674: LD_INT 3
20676: DOUBLE
20677: EQUAL
20678: IFTRUE 20682
20680: GO 20704
20682: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
20683: LD_VAR 0 1
20687: PPUSH
20688: LD_VAR 0 6
20692: PPUSH
20693: LD_VAR 0 7
20697: PPUSH
20698: CALL_OW 154
20702: GO 20705
20704: POP
// end ;
20705: LD_VAR 0 2
20709: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
20710: LD_INT 0
20712: PPUSH
20713: PPUSH
20714: PPUSH
20715: PPUSH
20716: PPUSH
20717: PPUSH
// if not unit or not building then
20718: LD_VAR 0 1
20722: NOT
20723: PUSH
20724: LD_VAR 0 2
20728: NOT
20729: OR
20730: IFFALSE 20734
// exit ;
20732: GO 20892
// x := GetX ( building ) ;
20734: LD_ADDR_VAR 0 5
20738: PUSH
20739: LD_VAR 0 2
20743: PPUSH
20744: CALL_OW 250
20748: ST_TO_ADDR
// y := GetY ( building ) ;
20749: LD_ADDR_VAR 0 6
20753: PUSH
20754: LD_VAR 0 2
20758: PPUSH
20759: CALL_OW 251
20763: ST_TO_ADDR
// for i = 0 to 5 do
20764: LD_ADDR_VAR 0 4
20768: PUSH
20769: DOUBLE
20770: LD_INT 0
20772: DEC
20773: ST_TO_ADDR
20774: LD_INT 5
20776: PUSH
20777: FOR_TO
20778: IFFALSE 20890
// begin _x := ShiftX ( x , i , 3 ) ;
20780: LD_ADDR_VAR 0 7
20784: PUSH
20785: LD_VAR 0 5
20789: PPUSH
20790: LD_VAR 0 4
20794: PPUSH
20795: LD_INT 3
20797: PPUSH
20798: CALL_OW 272
20802: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
20803: LD_ADDR_VAR 0 8
20807: PUSH
20808: LD_VAR 0 6
20812: PPUSH
20813: LD_VAR 0 4
20817: PPUSH
20818: LD_INT 3
20820: PPUSH
20821: CALL_OW 273
20825: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
20826: LD_VAR 0 7
20830: PPUSH
20831: LD_VAR 0 8
20835: PPUSH
20836: CALL_OW 488
20840: NOT
20841: IFFALSE 20845
// continue ;
20843: GO 20777
// if HexInfo ( _x , _y ) = 0 then
20845: LD_VAR 0 7
20849: PPUSH
20850: LD_VAR 0 8
20854: PPUSH
20855: CALL_OW 428
20859: PUSH
20860: LD_INT 0
20862: EQUAL
20863: IFFALSE 20888
// begin ComMoveXY ( unit , _x , _y ) ;
20865: LD_VAR 0 1
20869: PPUSH
20870: LD_VAR 0 7
20874: PPUSH
20875: LD_VAR 0 8
20879: PPUSH
20880: CALL_OW 111
// exit ;
20884: POP
20885: POP
20886: GO 20892
// end ; end ;
20888: GO 20777
20890: POP
20891: POP
// end ;
20892: LD_VAR 0 3
20896: RET
// export function ScanBase ( side , base_area ) ; begin
20897: LD_INT 0
20899: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
20900: LD_ADDR_VAR 0 3
20904: PUSH
20905: LD_VAR 0 2
20909: PPUSH
20910: LD_INT 81
20912: PUSH
20913: LD_VAR 0 1
20917: PUSH
20918: EMPTY
20919: LIST
20920: LIST
20921: PPUSH
20922: CALL_OW 70
20926: ST_TO_ADDR
// end ;
20927: LD_VAR 0 3
20931: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
20932: LD_INT 0
20934: PPUSH
20935: PPUSH
20936: PPUSH
20937: PPUSH
// result := false ;
20938: LD_ADDR_VAR 0 2
20942: PUSH
20943: LD_INT 0
20945: ST_TO_ADDR
// side := GetSide ( unit ) ;
20946: LD_ADDR_VAR 0 3
20950: PUSH
20951: LD_VAR 0 1
20955: PPUSH
20956: CALL_OW 255
20960: ST_TO_ADDR
// nat := GetNation ( unit ) ;
20961: LD_ADDR_VAR 0 4
20965: PUSH
20966: LD_VAR 0 1
20970: PPUSH
20971: CALL_OW 248
20975: ST_TO_ADDR
// case nat of 1 :
20976: LD_VAR 0 4
20980: PUSH
20981: LD_INT 1
20983: DOUBLE
20984: EQUAL
20985: IFTRUE 20989
20987: GO 21000
20989: POP
// tech := tech_lassight ; 2 :
20990: LD_ADDR_VAR 0 5
20994: PUSH
20995: LD_INT 12
20997: ST_TO_ADDR
20998: GO 21039
21000: LD_INT 2
21002: DOUBLE
21003: EQUAL
21004: IFTRUE 21008
21006: GO 21019
21008: POP
// tech := tech_mortar ; 3 :
21009: LD_ADDR_VAR 0 5
21013: PUSH
21014: LD_INT 41
21016: ST_TO_ADDR
21017: GO 21039
21019: LD_INT 3
21021: DOUBLE
21022: EQUAL
21023: IFTRUE 21027
21025: GO 21038
21027: POP
// tech := tech_bazooka ; end ;
21028: LD_ADDR_VAR 0 5
21032: PUSH
21033: LD_INT 44
21035: ST_TO_ADDR
21036: GO 21039
21038: POP
// if Researched ( side , tech ) then
21039: LD_VAR 0 3
21043: PPUSH
21044: LD_VAR 0 5
21048: PPUSH
21049: CALL_OW 325
21053: IFFALSE 21080
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
21055: LD_ADDR_VAR 0 2
21059: PUSH
21060: LD_INT 5
21062: PUSH
21063: LD_INT 8
21065: PUSH
21066: LD_INT 9
21068: PUSH
21069: EMPTY
21070: LIST
21071: LIST
21072: LIST
21073: PUSH
21074: LD_VAR 0 4
21078: ARRAY
21079: ST_TO_ADDR
// end ;
21080: LD_VAR 0 2
21084: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
21085: LD_INT 0
21087: PPUSH
21088: PPUSH
21089: PPUSH
// if not mines then
21090: LD_VAR 0 2
21094: NOT
21095: IFFALSE 21099
// exit ;
21097: GO 21243
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
21099: LD_ADDR_VAR 0 5
21103: PUSH
21104: LD_INT 81
21106: PUSH
21107: LD_VAR 0 1
21111: PUSH
21112: EMPTY
21113: LIST
21114: LIST
21115: PUSH
21116: LD_INT 3
21118: PUSH
21119: LD_INT 21
21121: PUSH
21122: LD_INT 3
21124: PUSH
21125: EMPTY
21126: LIST
21127: LIST
21128: PUSH
21129: EMPTY
21130: LIST
21131: LIST
21132: PUSH
21133: EMPTY
21134: LIST
21135: LIST
21136: PPUSH
21137: CALL_OW 69
21141: ST_TO_ADDR
// for i in mines do
21142: LD_ADDR_VAR 0 4
21146: PUSH
21147: LD_VAR 0 2
21151: PUSH
21152: FOR_IN
21153: IFFALSE 21241
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
21155: LD_VAR 0 4
21159: PUSH
21160: LD_INT 1
21162: ARRAY
21163: PPUSH
21164: LD_VAR 0 4
21168: PUSH
21169: LD_INT 2
21171: ARRAY
21172: PPUSH
21173: CALL_OW 458
21177: NOT
21178: IFFALSE 21182
// continue ;
21180: GO 21152
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
21182: LD_VAR 0 4
21186: PUSH
21187: LD_INT 1
21189: ARRAY
21190: PPUSH
21191: LD_VAR 0 4
21195: PUSH
21196: LD_INT 2
21198: ARRAY
21199: PPUSH
21200: CALL_OW 428
21204: PUSH
21205: LD_VAR 0 5
21209: IN
21210: IFFALSE 21239
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
21212: LD_VAR 0 4
21216: PUSH
21217: LD_INT 1
21219: ARRAY
21220: PPUSH
21221: LD_VAR 0 4
21225: PUSH
21226: LD_INT 2
21228: ARRAY
21229: PPUSH
21230: LD_VAR 0 1
21234: PPUSH
21235: CALL_OW 456
// end ;
21239: GO 21152
21241: POP
21242: POP
// end ;
21243: LD_VAR 0 3
21247: RET
// export function Count ( array ) ; var i ; begin
21248: LD_INT 0
21250: PPUSH
21251: PPUSH
// result := 0 ;
21252: LD_ADDR_VAR 0 2
21256: PUSH
21257: LD_INT 0
21259: ST_TO_ADDR
// for i in array do
21260: LD_ADDR_VAR 0 3
21264: PUSH
21265: LD_VAR 0 1
21269: PUSH
21270: FOR_IN
21271: IFFALSE 21295
// if i then
21273: LD_VAR 0 3
21277: IFFALSE 21293
// result := result + 1 ;
21279: LD_ADDR_VAR 0 2
21283: PUSH
21284: LD_VAR 0 2
21288: PUSH
21289: LD_INT 1
21291: PLUS
21292: ST_TO_ADDR
21293: GO 21270
21295: POP
21296: POP
// end ;
21297: LD_VAR 0 2
21301: RET
// export function IsEmpty ( building ) ; begin
21302: LD_INT 0
21304: PPUSH
// if not building then
21305: LD_VAR 0 1
21309: NOT
21310: IFFALSE 21314
// exit ;
21312: GO 21357
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
21314: LD_ADDR_VAR 0 2
21318: PUSH
21319: LD_VAR 0 1
21323: PUSH
21324: LD_INT 22
21326: PUSH
21327: LD_VAR 0 1
21331: PPUSH
21332: CALL_OW 255
21336: PUSH
21337: EMPTY
21338: LIST
21339: LIST
21340: PUSH
21341: LD_INT 58
21343: PUSH
21344: EMPTY
21345: LIST
21346: PUSH
21347: EMPTY
21348: LIST
21349: LIST
21350: PPUSH
21351: CALL_OW 69
21355: IN
21356: ST_TO_ADDR
// end ;
21357: LD_VAR 0 2
21361: RET
// export function IsNotFull ( building ) ; begin
21362: LD_INT 0
21364: PPUSH
// if not building then
21365: LD_VAR 0 1
21369: NOT
21370: IFFALSE 21374
// exit ;
21372: GO 21393
// result := UnitsInside ( building ) < 6 ;
21374: LD_ADDR_VAR 0 2
21378: PUSH
21379: LD_VAR 0 1
21383: PPUSH
21384: CALL_OW 313
21388: PUSH
21389: LD_INT 6
21391: LESS
21392: ST_TO_ADDR
// end ;
21393: LD_VAR 0 2
21397: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
21398: LD_INT 0
21400: PPUSH
21401: PPUSH
21402: PPUSH
21403: PPUSH
// tmp := [ ] ;
21404: LD_ADDR_VAR 0 3
21408: PUSH
21409: EMPTY
21410: ST_TO_ADDR
// list := [ ] ;
21411: LD_ADDR_VAR 0 5
21415: PUSH
21416: EMPTY
21417: ST_TO_ADDR
// for i = 16 to 25 do
21418: LD_ADDR_VAR 0 4
21422: PUSH
21423: DOUBLE
21424: LD_INT 16
21426: DEC
21427: ST_TO_ADDR
21428: LD_INT 25
21430: PUSH
21431: FOR_TO
21432: IFFALSE 21505
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
21434: LD_ADDR_VAR 0 3
21438: PUSH
21439: LD_VAR 0 3
21443: PUSH
21444: LD_INT 22
21446: PUSH
21447: LD_VAR 0 1
21451: PPUSH
21452: CALL_OW 255
21456: PUSH
21457: EMPTY
21458: LIST
21459: LIST
21460: PUSH
21461: LD_INT 91
21463: PUSH
21464: LD_VAR 0 1
21468: PUSH
21469: LD_INT 6
21471: PUSH
21472: EMPTY
21473: LIST
21474: LIST
21475: LIST
21476: PUSH
21477: LD_INT 30
21479: PUSH
21480: LD_VAR 0 4
21484: PUSH
21485: EMPTY
21486: LIST
21487: LIST
21488: PUSH
21489: EMPTY
21490: LIST
21491: LIST
21492: LIST
21493: PUSH
21494: EMPTY
21495: LIST
21496: PPUSH
21497: CALL_OW 69
21501: ADD
21502: ST_TO_ADDR
21503: GO 21431
21505: POP
21506: POP
// for i = 1 to tmp do
21507: LD_ADDR_VAR 0 4
21511: PUSH
21512: DOUBLE
21513: LD_INT 1
21515: DEC
21516: ST_TO_ADDR
21517: LD_VAR 0 3
21521: PUSH
21522: FOR_TO
21523: IFFALSE 21611
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
21525: LD_ADDR_VAR 0 5
21529: PUSH
21530: LD_VAR 0 5
21534: PUSH
21535: LD_VAR 0 3
21539: PUSH
21540: LD_VAR 0 4
21544: ARRAY
21545: PPUSH
21546: CALL_OW 266
21550: PUSH
21551: LD_VAR 0 3
21555: PUSH
21556: LD_VAR 0 4
21560: ARRAY
21561: PPUSH
21562: CALL_OW 250
21566: PUSH
21567: LD_VAR 0 3
21571: PUSH
21572: LD_VAR 0 4
21576: ARRAY
21577: PPUSH
21578: CALL_OW 251
21582: PUSH
21583: LD_VAR 0 3
21587: PUSH
21588: LD_VAR 0 4
21592: ARRAY
21593: PPUSH
21594: CALL_OW 254
21598: PUSH
21599: EMPTY
21600: LIST
21601: LIST
21602: LIST
21603: LIST
21604: PUSH
21605: EMPTY
21606: LIST
21607: ADD
21608: ST_TO_ADDR
21609: GO 21522
21611: POP
21612: POP
// result := list ;
21613: LD_ADDR_VAR 0 2
21617: PUSH
21618: LD_VAR 0 5
21622: ST_TO_ADDR
// end ;
21623: LD_VAR 0 2
21627: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
21628: LD_INT 0
21630: PPUSH
21631: PPUSH
21632: PPUSH
21633: PPUSH
21634: PPUSH
21635: PPUSH
21636: PPUSH
// if not factory then
21637: LD_VAR 0 1
21641: NOT
21642: IFFALSE 21646
// exit ;
21644: GO 22239
// if control = control_apeman then
21646: LD_VAR 0 4
21650: PUSH
21651: LD_INT 5
21653: EQUAL
21654: IFFALSE 21763
// begin tmp := UnitsInside ( factory ) ;
21656: LD_ADDR_VAR 0 8
21660: PUSH
21661: LD_VAR 0 1
21665: PPUSH
21666: CALL_OW 313
21670: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
21671: LD_VAR 0 8
21675: PPUSH
21676: LD_INT 25
21678: PUSH
21679: LD_INT 12
21681: PUSH
21682: EMPTY
21683: LIST
21684: LIST
21685: PPUSH
21686: CALL_OW 72
21690: NOT
21691: IFFALSE 21701
// control := control_manual ;
21693: LD_ADDR_VAR 0 4
21697: PUSH
21698: LD_INT 1
21700: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
21701: LD_ADDR_VAR 0 8
21705: PUSH
21706: LD_VAR 0 1
21710: PPUSH
21711: CALL 21398 0 1
21715: ST_TO_ADDR
// if tmp then
21716: LD_VAR 0 8
21720: IFFALSE 21763
// begin for i in tmp do
21722: LD_ADDR_VAR 0 7
21726: PUSH
21727: LD_VAR 0 8
21731: PUSH
21732: FOR_IN
21733: IFFALSE 21761
// if i [ 1 ] = b_ext_radio then
21735: LD_VAR 0 7
21739: PUSH
21740: LD_INT 1
21742: ARRAY
21743: PUSH
21744: LD_INT 22
21746: EQUAL
21747: IFFALSE 21759
// begin control := control_remote ;
21749: LD_ADDR_VAR 0 4
21753: PUSH
21754: LD_INT 2
21756: ST_TO_ADDR
// break ;
21757: GO 21761
// end ;
21759: GO 21732
21761: POP
21762: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
21763: LD_VAR 0 1
21767: PPUSH
21768: LD_VAR 0 2
21772: PPUSH
21773: LD_VAR 0 3
21777: PPUSH
21778: LD_VAR 0 4
21782: PPUSH
21783: LD_VAR 0 5
21787: PPUSH
21788: CALL_OW 448
21792: IFFALSE 21827
// begin result := [ chassis , engine , control , weapon ] ;
21794: LD_ADDR_VAR 0 6
21798: PUSH
21799: LD_VAR 0 2
21803: PUSH
21804: LD_VAR 0 3
21808: PUSH
21809: LD_VAR 0 4
21813: PUSH
21814: LD_VAR 0 5
21818: PUSH
21819: EMPTY
21820: LIST
21821: LIST
21822: LIST
21823: LIST
21824: ST_TO_ADDR
// exit ;
21825: GO 22239
// end ; _chassis := AvailableChassisList ( factory ) ;
21827: LD_ADDR_VAR 0 9
21831: PUSH
21832: LD_VAR 0 1
21836: PPUSH
21837: CALL_OW 475
21841: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
21842: LD_ADDR_VAR 0 11
21846: PUSH
21847: LD_VAR 0 1
21851: PPUSH
21852: CALL_OW 476
21856: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
21857: LD_ADDR_VAR 0 12
21861: PUSH
21862: LD_VAR 0 1
21866: PPUSH
21867: CALL_OW 477
21871: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
21872: LD_ADDR_VAR 0 10
21876: PUSH
21877: LD_VAR 0 1
21881: PPUSH
21882: CALL_OW 478
21886: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
21887: LD_VAR 0 9
21891: NOT
21892: PUSH
21893: LD_VAR 0 11
21897: NOT
21898: OR
21899: PUSH
21900: LD_VAR 0 12
21904: NOT
21905: OR
21906: PUSH
21907: LD_VAR 0 10
21911: NOT
21912: OR
21913: IFFALSE 21948
// begin result := [ chassis , engine , control , weapon ] ;
21915: LD_ADDR_VAR 0 6
21919: PUSH
21920: LD_VAR 0 2
21924: PUSH
21925: LD_VAR 0 3
21929: PUSH
21930: LD_VAR 0 4
21934: PUSH
21935: LD_VAR 0 5
21939: PUSH
21940: EMPTY
21941: LIST
21942: LIST
21943: LIST
21944: LIST
21945: ST_TO_ADDR
// exit ;
21946: GO 22239
// end ; if not chassis in _chassis then
21948: LD_VAR 0 2
21952: PUSH
21953: LD_VAR 0 9
21957: IN
21958: NOT
21959: IFFALSE 21985
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
21961: LD_ADDR_VAR 0 2
21965: PUSH
21966: LD_VAR 0 9
21970: PUSH
21971: LD_INT 1
21973: PPUSH
21974: LD_VAR 0 9
21978: PPUSH
21979: CALL_OW 12
21983: ARRAY
21984: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
21985: LD_VAR 0 2
21989: PPUSH
21990: LD_VAR 0 3
21994: PPUSH
21995: CALL 22244 0 2
21999: NOT
22000: IFFALSE 22059
// repeat engine := _engine [ 1 ] ;
22002: LD_ADDR_VAR 0 3
22006: PUSH
22007: LD_VAR 0 11
22011: PUSH
22012: LD_INT 1
22014: ARRAY
22015: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
22016: LD_ADDR_VAR 0 11
22020: PUSH
22021: LD_VAR 0 11
22025: PPUSH
22026: LD_INT 1
22028: PPUSH
22029: CALL_OW 3
22033: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
22034: LD_VAR 0 2
22038: PPUSH
22039: LD_VAR 0 3
22043: PPUSH
22044: CALL 22244 0 2
22048: PUSH
22049: LD_VAR 0 11
22053: PUSH
22054: EMPTY
22055: EQUAL
22056: OR
22057: IFFALSE 22002
// if not control in _control then
22059: LD_VAR 0 4
22063: PUSH
22064: LD_VAR 0 12
22068: IN
22069: NOT
22070: IFFALSE 22096
// control := _control [ rand ( 1 , _control ) ] ;
22072: LD_ADDR_VAR 0 4
22076: PUSH
22077: LD_VAR 0 12
22081: PUSH
22082: LD_INT 1
22084: PPUSH
22085: LD_VAR 0 12
22089: PPUSH
22090: CALL_OW 12
22094: ARRAY
22095: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
22096: LD_VAR 0 2
22100: PPUSH
22101: LD_VAR 0 5
22105: PPUSH
22106: CALL 22464 0 2
22110: NOT
22111: IFFALSE 22170
// repeat weapon := _weapon [ 1 ] ;
22113: LD_ADDR_VAR 0 5
22117: PUSH
22118: LD_VAR 0 10
22122: PUSH
22123: LD_INT 1
22125: ARRAY
22126: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
22127: LD_ADDR_VAR 0 10
22131: PUSH
22132: LD_VAR 0 10
22136: PPUSH
22137: LD_INT 1
22139: PPUSH
22140: CALL_OW 3
22144: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
22145: LD_VAR 0 2
22149: PPUSH
22150: LD_VAR 0 5
22154: PPUSH
22155: CALL 22464 0 2
22159: PUSH
22160: LD_VAR 0 10
22164: PUSH
22165: EMPTY
22166: EQUAL
22167: OR
22168: IFFALSE 22113
// result := [ ] ;
22170: LD_ADDR_VAR 0 6
22174: PUSH
22175: EMPTY
22176: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
22177: LD_VAR 0 1
22181: PPUSH
22182: LD_VAR 0 2
22186: PPUSH
22187: LD_VAR 0 3
22191: PPUSH
22192: LD_VAR 0 4
22196: PPUSH
22197: LD_VAR 0 5
22201: PPUSH
22202: CALL_OW 448
22206: IFFALSE 22239
// result := [ chassis , engine , control , weapon ] ;
22208: LD_ADDR_VAR 0 6
22212: PUSH
22213: LD_VAR 0 2
22217: PUSH
22218: LD_VAR 0 3
22222: PUSH
22223: LD_VAR 0 4
22227: PUSH
22228: LD_VAR 0 5
22232: PUSH
22233: EMPTY
22234: LIST
22235: LIST
22236: LIST
22237: LIST
22238: ST_TO_ADDR
// end ;
22239: LD_VAR 0 6
22243: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
22244: LD_INT 0
22246: PPUSH
// if not chassis or not engine then
22247: LD_VAR 0 1
22251: NOT
22252: PUSH
22253: LD_VAR 0 2
22257: NOT
22258: OR
22259: IFFALSE 22263
// exit ;
22261: GO 22459
// case engine of engine_solar :
22263: LD_VAR 0 2
22267: PUSH
22268: LD_INT 2
22270: DOUBLE
22271: EQUAL
22272: IFTRUE 22276
22274: GO 22314
22276: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
22277: LD_ADDR_VAR 0 3
22281: PUSH
22282: LD_INT 11
22284: PUSH
22285: LD_INT 12
22287: PUSH
22288: LD_INT 13
22290: PUSH
22291: LD_INT 14
22293: PUSH
22294: LD_INT 1
22296: PUSH
22297: LD_INT 2
22299: PUSH
22300: LD_INT 3
22302: PUSH
22303: EMPTY
22304: LIST
22305: LIST
22306: LIST
22307: LIST
22308: LIST
22309: LIST
22310: LIST
22311: ST_TO_ADDR
22312: GO 22443
22314: LD_INT 1
22316: DOUBLE
22317: EQUAL
22318: IFTRUE 22322
22320: GO 22384
22322: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
22323: LD_ADDR_VAR 0 3
22327: PUSH
22328: LD_INT 11
22330: PUSH
22331: LD_INT 12
22333: PUSH
22334: LD_INT 13
22336: PUSH
22337: LD_INT 14
22339: PUSH
22340: LD_INT 1
22342: PUSH
22343: LD_INT 2
22345: PUSH
22346: LD_INT 3
22348: PUSH
22349: LD_INT 4
22351: PUSH
22352: LD_INT 5
22354: PUSH
22355: LD_INT 21
22357: PUSH
22358: LD_INT 23
22360: PUSH
22361: LD_INT 22
22363: PUSH
22364: LD_INT 24
22366: PUSH
22367: EMPTY
22368: LIST
22369: LIST
22370: LIST
22371: LIST
22372: LIST
22373: LIST
22374: LIST
22375: LIST
22376: LIST
22377: LIST
22378: LIST
22379: LIST
22380: LIST
22381: ST_TO_ADDR
22382: GO 22443
22384: LD_INT 3
22386: DOUBLE
22387: EQUAL
22388: IFTRUE 22392
22390: GO 22442
22392: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
22393: LD_ADDR_VAR 0 3
22397: PUSH
22398: LD_INT 13
22400: PUSH
22401: LD_INT 14
22403: PUSH
22404: LD_INT 2
22406: PUSH
22407: LD_INT 3
22409: PUSH
22410: LD_INT 4
22412: PUSH
22413: LD_INT 5
22415: PUSH
22416: LD_INT 21
22418: PUSH
22419: LD_INT 22
22421: PUSH
22422: LD_INT 23
22424: PUSH
22425: LD_INT 24
22427: PUSH
22428: EMPTY
22429: LIST
22430: LIST
22431: LIST
22432: LIST
22433: LIST
22434: LIST
22435: LIST
22436: LIST
22437: LIST
22438: LIST
22439: ST_TO_ADDR
22440: GO 22443
22442: POP
// result := ( chassis in result ) ;
22443: LD_ADDR_VAR 0 3
22447: PUSH
22448: LD_VAR 0 1
22452: PUSH
22453: LD_VAR 0 3
22457: IN
22458: ST_TO_ADDR
// end ;
22459: LD_VAR 0 3
22463: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
22464: LD_INT 0
22466: PPUSH
// if not chassis or not weapon then
22467: LD_VAR 0 1
22471: NOT
22472: PUSH
22473: LD_VAR 0 2
22477: NOT
22478: OR
22479: IFFALSE 22483
// exit ;
22481: GO 23509
// case weapon of us_machine_gun :
22483: LD_VAR 0 2
22487: PUSH
22488: LD_INT 2
22490: DOUBLE
22491: EQUAL
22492: IFTRUE 22496
22494: GO 22526
22496: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
22497: LD_ADDR_VAR 0 3
22501: PUSH
22502: LD_INT 1
22504: PUSH
22505: LD_INT 2
22507: PUSH
22508: LD_INT 3
22510: PUSH
22511: LD_INT 4
22513: PUSH
22514: LD_INT 5
22516: PUSH
22517: EMPTY
22518: LIST
22519: LIST
22520: LIST
22521: LIST
22522: LIST
22523: ST_TO_ADDR
22524: GO 23493
22526: LD_INT 3
22528: DOUBLE
22529: EQUAL
22530: IFTRUE 22534
22532: GO 22564
22534: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
22535: LD_ADDR_VAR 0 3
22539: PUSH
22540: LD_INT 1
22542: PUSH
22543: LD_INT 2
22545: PUSH
22546: LD_INT 3
22548: PUSH
22549: LD_INT 4
22551: PUSH
22552: LD_INT 5
22554: PUSH
22555: EMPTY
22556: LIST
22557: LIST
22558: LIST
22559: LIST
22560: LIST
22561: ST_TO_ADDR
22562: GO 23493
22564: LD_INT 11
22566: DOUBLE
22567: EQUAL
22568: IFTRUE 22572
22570: GO 22602
22572: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
22573: LD_ADDR_VAR 0 3
22577: PUSH
22578: LD_INT 1
22580: PUSH
22581: LD_INT 2
22583: PUSH
22584: LD_INT 3
22586: PUSH
22587: LD_INT 4
22589: PUSH
22590: LD_INT 5
22592: PUSH
22593: EMPTY
22594: LIST
22595: LIST
22596: LIST
22597: LIST
22598: LIST
22599: ST_TO_ADDR
22600: GO 23493
22602: LD_INT 4
22604: DOUBLE
22605: EQUAL
22606: IFTRUE 22610
22608: GO 22636
22610: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
22611: LD_ADDR_VAR 0 3
22615: PUSH
22616: LD_INT 2
22618: PUSH
22619: LD_INT 3
22621: PUSH
22622: LD_INT 4
22624: PUSH
22625: LD_INT 5
22627: PUSH
22628: EMPTY
22629: LIST
22630: LIST
22631: LIST
22632: LIST
22633: ST_TO_ADDR
22634: GO 23493
22636: LD_INT 5
22638: DOUBLE
22639: EQUAL
22640: IFTRUE 22644
22642: GO 22670
22644: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
22645: LD_ADDR_VAR 0 3
22649: PUSH
22650: LD_INT 2
22652: PUSH
22653: LD_INT 3
22655: PUSH
22656: LD_INT 4
22658: PUSH
22659: LD_INT 5
22661: PUSH
22662: EMPTY
22663: LIST
22664: LIST
22665: LIST
22666: LIST
22667: ST_TO_ADDR
22668: GO 23493
22670: LD_INT 9
22672: DOUBLE
22673: EQUAL
22674: IFTRUE 22678
22676: GO 22704
22678: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
22679: LD_ADDR_VAR 0 3
22683: PUSH
22684: LD_INT 2
22686: PUSH
22687: LD_INT 3
22689: PUSH
22690: LD_INT 4
22692: PUSH
22693: LD_INT 5
22695: PUSH
22696: EMPTY
22697: LIST
22698: LIST
22699: LIST
22700: LIST
22701: ST_TO_ADDR
22702: GO 23493
22704: LD_INT 7
22706: DOUBLE
22707: EQUAL
22708: IFTRUE 22712
22710: GO 22738
22712: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
22713: LD_ADDR_VAR 0 3
22717: PUSH
22718: LD_INT 2
22720: PUSH
22721: LD_INT 3
22723: PUSH
22724: LD_INT 4
22726: PUSH
22727: LD_INT 5
22729: PUSH
22730: EMPTY
22731: LIST
22732: LIST
22733: LIST
22734: LIST
22735: ST_TO_ADDR
22736: GO 23493
22738: LD_INT 12
22740: DOUBLE
22741: EQUAL
22742: IFTRUE 22746
22744: GO 22772
22746: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
22747: LD_ADDR_VAR 0 3
22751: PUSH
22752: LD_INT 2
22754: PUSH
22755: LD_INT 3
22757: PUSH
22758: LD_INT 4
22760: PUSH
22761: LD_INT 5
22763: PUSH
22764: EMPTY
22765: LIST
22766: LIST
22767: LIST
22768: LIST
22769: ST_TO_ADDR
22770: GO 23493
22772: LD_INT 13
22774: DOUBLE
22775: EQUAL
22776: IFTRUE 22780
22778: GO 22806
22780: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
22781: LD_ADDR_VAR 0 3
22785: PUSH
22786: LD_INT 2
22788: PUSH
22789: LD_INT 3
22791: PUSH
22792: LD_INT 4
22794: PUSH
22795: LD_INT 5
22797: PUSH
22798: EMPTY
22799: LIST
22800: LIST
22801: LIST
22802: LIST
22803: ST_TO_ADDR
22804: GO 23493
22806: LD_INT 14
22808: DOUBLE
22809: EQUAL
22810: IFTRUE 22814
22812: GO 22832
22814: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
22815: LD_ADDR_VAR 0 3
22819: PUSH
22820: LD_INT 4
22822: PUSH
22823: LD_INT 5
22825: PUSH
22826: EMPTY
22827: LIST
22828: LIST
22829: ST_TO_ADDR
22830: GO 23493
22832: LD_INT 6
22834: DOUBLE
22835: EQUAL
22836: IFTRUE 22840
22838: GO 22858
22840: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
22841: LD_ADDR_VAR 0 3
22845: PUSH
22846: LD_INT 4
22848: PUSH
22849: LD_INT 5
22851: PUSH
22852: EMPTY
22853: LIST
22854: LIST
22855: ST_TO_ADDR
22856: GO 23493
22858: LD_INT 10
22860: DOUBLE
22861: EQUAL
22862: IFTRUE 22866
22864: GO 22884
22866: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
22867: LD_ADDR_VAR 0 3
22871: PUSH
22872: LD_INT 4
22874: PUSH
22875: LD_INT 5
22877: PUSH
22878: EMPTY
22879: LIST
22880: LIST
22881: ST_TO_ADDR
22882: GO 23493
22884: LD_INT 22
22886: DOUBLE
22887: EQUAL
22888: IFTRUE 22892
22890: GO 22918
22892: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
22893: LD_ADDR_VAR 0 3
22897: PUSH
22898: LD_INT 11
22900: PUSH
22901: LD_INT 12
22903: PUSH
22904: LD_INT 13
22906: PUSH
22907: LD_INT 14
22909: PUSH
22910: EMPTY
22911: LIST
22912: LIST
22913: LIST
22914: LIST
22915: ST_TO_ADDR
22916: GO 23493
22918: LD_INT 23
22920: DOUBLE
22921: EQUAL
22922: IFTRUE 22926
22924: GO 22952
22926: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
22927: LD_ADDR_VAR 0 3
22931: PUSH
22932: LD_INT 11
22934: PUSH
22935: LD_INT 12
22937: PUSH
22938: LD_INT 13
22940: PUSH
22941: LD_INT 14
22943: PUSH
22944: EMPTY
22945: LIST
22946: LIST
22947: LIST
22948: LIST
22949: ST_TO_ADDR
22950: GO 23493
22952: LD_INT 24
22954: DOUBLE
22955: EQUAL
22956: IFTRUE 22960
22958: GO 22986
22960: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
22961: LD_ADDR_VAR 0 3
22965: PUSH
22966: LD_INT 11
22968: PUSH
22969: LD_INT 12
22971: PUSH
22972: LD_INT 13
22974: PUSH
22975: LD_INT 14
22977: PUSH
22978: EMPTY
22979: LIST
22980: LIST
22981: LIST
22982: LIST
22983: ST_TO_ADDR
22984: GO 23493
22986: LD_INT 30
22988: DOUBLE
22989: EQUAL
22990: IFTRUE 22994
22992: GO 23020
22994: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
22995: LD_ADDR_VAR 0 3
22999: PUSH
23000: LD_INT 11
23002: PUSH
23003: LD_INT 12
23005: PUSH
23006: LD_INT 13
23008: PUSH
23009: LD_INT 14
23011: PUSH
23012: EMPTY
23013: LIST
23014: LIST
23015: LIST
23016: LIST
23017: ST_TO_ADDR
23018: GO 23493
23020: LD_INT 25
23022: DOUBLE
23023: EQUAL
23024: IFTRUE 23028
23026: GO 23046
23028: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
23029: LD_ADDR_VAR 0 3
23033: PUSH
23034: LD_INT 13
23036: PUSH
23037: LD_INT 14
23039: PUSH
23040: EMPTY
23041: LIST
23042: LIST
23043: ST_TO_ADDR
23044: GO 23493
23046: LD_INT 27
23048: DOUBLE
23049: EQUAL
23050: IFTRUE 23054
23052: GO 23072
23054: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
23055: LD_ADDR_VAR 0 3
23059: PUSH
23060: LD_INT 13
23062: PUSH
23063: LD_INT 14
23065: PUSH
23066: EMPTY
23067: LIST
23068: LIST
23069: ST_TO_ADDR
23070: GO 23493
23072: LD_INT 28
23074: DOUBLE
23075: EQUAL
23076: IFTRUE 23080
23078: GO 23098
23080: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
23081: LD_ADDR_VAR 0 3
23085: PUSH
23086: LD_INT 13
23088: PUSH
23089: LD_INT 14
23091: PUSH
23092: EMPTY
23093: LIST
23094: LIST
23095: ST_TO_ADDR
23096: GO 23493
23098: LD_INT 29
23100: DOUBLE
23101: EQUAL
23102: IFTRUE 23106
23104: GO 23124
23106: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
23107: LD_ADDR_VAR 0 3
23111: PUSH
23112: LD_INT 13
23114: PUSH
23115: LD_INT 14
23117: PUSH
23118: EMPTY
23119: LIST
23120: LIST
23121: ST_TO_ADDR
23122: GO 23493
23124: LD_INT 31
23126: DOUBLE
23127: EQUAL
23128: IFTRUE 23132
23130: GO 23150
23132: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
23133: LD_ADDR_VAR 0 3
23137: PUSH
23138: LD_INT 13
23140: PUSH
23141: LD_INT 14
23143: PUSH
23144: EMPTY
23145: LIST
23146: LIST
23147: ST_TO_ADDR
23148: GO 23493
23150: LD_INT 26
23152: DOUBLE
23153: EQUAL
23154: IFTRUE 23158
23156: GO 23176
23158: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
23159: LD_ADDR_VAR 0 3
23163: PUSH
23164: LD_INT 13
23166: PUSH
23167: LD_INT 14
23169: PUSH
23170: EMPTY
23171: LIST
23172: LIST
23173: ST_TO_ADDR
23174: GO 23493
23176: LD_INT 42
23178: DOUBLE
23179: EQUAL
23180: IFTRUE 23184
23182: GO 23210
23184: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
23185: LD_ADDR_VAR 0 3
23189: PUSH
23190: LD_INT 21
23192: PUSH
23193: LD_INT 22
23195: PUSH
23196: LD_INT 23
23198: PUSH
23199: LD_INT 24
23201: PUSH
23202: EMPTY
23203: LIST
23204: LIST
23205: LIST
23206: LIST
23207: ST_TO_ADDR
23208: GO 23493
23210: LD_INT 43
23212: DOUBLE
23213: EQUAL
23214: IFTRUE 23218
23216: GO 23244
23218: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
23219: LD_ADDR_VAR 0 3
23223: PUSH
23224: LD_INT 21
23226: PUSH
23227: LD_INT 22
23229: PUSH
23230: LD_INT 23
23232: PUSH
23233: LD_INT 24
23235: PUSH
23236: EMPTY
23237: LIST
23238: LIST
23239: LIST
23240: LIST
23241: ST_TO_ADDR
23242: GO 23493
23244: LD_INT 44
23246: DOUBLE
23247: EQUAL
23248: IFTRUE 23252
23250: GO 23278
23252: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
23253: LD_ADDR_VAR 0 3
23257: PUSH
23258: LD_INT 21
23260: PUSH
23261: LD_INT 22
23263: PUSH
23264: LD_INT 23
23266: PUSH
23267: LD_INT 24
23269: PUSH
23270: EMPTY
23271: LIST
23272: LIST
23273: LIST
23274: LIST
23275: ST_TO_ADDR
23276: GO 23493
23278: LD_INT 45
23280: DOUBLE
23281: EQUAL
23282: IFTRUE 23286
23284: GO 23312
23286: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
23287: LD_ADDR_VAR 0 3
23291: PUSH
23292: LD_INT 21
23294: PUSH
23295: LD_INT 22
23297: PUSH
23298: LD_INT 23
23300: PUSH
23301: LD_INT 24
23303: PUSH
23304: EMPTY
23305: LIST
23306: LIST
23307: LIST
23308: LIST
23309: ST_TO_ADDR
23310: GO 23493
23312: LD_INT 49
23314: DOUBLE
23315: EQUAL
23316: IFTRUE 23320
23318: GO 23346
23320: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
23321: LD_ADDR_VAR 0 3
23325: PUSH
23326: LD_INT 21
23328: PUSH
23329: LD_INT 22
23331: PUSH
23332: LD_INT 23
23334: PUSH
23335: LD_INT 24
23337: PUSH
23338: EMPTY
23339: LIST
23340: LIST
23341: LIST
23342: LIST
23343: ST_TO_ADDR
23344: GO 23493
23346: LD_INT 51
23348: DOUBLE
23349: EQUAL
23350: IFTRUE 23354
23352: GO 23380
23354: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
23355: LD_ADDR_VAR 0 3
23359: PUSH
23360: LD_INT 21
23362: PUSH
23363: LD_INT 22
23365: PUSH
23366: LD_INT 23
23368: PUSH
23369: LD_INT 24
23371: PUSH
23372: EMPTY
23373: LIST
23374: LIST
23375: LIST
23376: LIST
23377: ST_TO_ADDR
23378: GO 23493
23380: LD_INT 52
23382: DOUBLE
23383: EQUAL
23384: IFTRUE 23388
23386: GO 23414
23388: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
23389: LD_ADDR_VAR 0 3
23393: PUSH
23394: LD_INT 21
23396: PUSH
23397: LD_INT 22
23399: PUSH
23400: LD_INT 23
23402: PUSH
23403: LD_INT 24
23405: PUSH
23406: EMPTY
23407: LIST
23408: LIST
23409: LIST
23410: LIST
23411: ST_TO_ADDR
23412: GO 23493
23414: LD_INT 53
23416: DOUBLE
23417: EQUAL
23418: IFTRUE 23422
23420: GO 23440
23422: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
23423: LD_ADDR_VAR 0 3
23427: PUSH
23428: LD_INT 23
23430: PUSH
23431: LD_INT 24
23433: PUSH
23434: EMPTY
23435: LIST
23436: LIST
23437: ST_TO_ADDR
23438: GO 23493
23440: LD_INT 46
23442: DOUBLE
23443: EQUAL
23444: IFTRUE 23448
23446: GO 23466
23448: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
23449: LD_ADDR_VAR 0 3
23453: PUSH
23454: LD_INT 23
23456: PUSH
23457: LD_INT 24
23459: PUSH
23460: EMPTY
23461: LIST
23462: LIST
23463: ST_TO_ADDR
23464: GO 23493
23466: LD_INT 47
23468: DOUBLE
23469: EQUAL
23470: IFTRUE 23474
23472: GO 23492
23474: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
23475: LD_ADDR_VAR 0 3
23479: PUSH
23480: LD_INT 23
23482: PUSH
23483: LD_INT 24
23485: PUSH
23486: EMPTY
23487: LIST
23488: LIST
23489: ST_TO_ADDR
23490: GO 23493
23492: POP
// result := ( chassis in result ) ;
23493: LD_ADDR_VAR 0 3
23497: PUSH
23498: LD_VAR 0 1
23502: PUSH
23503: LD_VAR 0 3
23507: IN
23508: ST_TO_ADDR
// end ;
23509: LD_VAR 0 3
23513: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
23514: LD_INT 0
23516: PPUSH
23517: PPUSH
23518: PPUSH
23519: PPUSH
23520: PPUSH
23521: PPUSH
23522: PPUSH
// result := array ;
23523: LD_ADDR_VAR 0 5
23527: PUSH
23528: LD_VAR 0 1
23532: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
23533: LD_VAR 0 1
23537: NOT
23538: PUSH
23539: LD_VAR 0 2
23543: NOT
23544: OR
23545: PUSH
23546: LD_VAR 0 3
23550: NOT
23551: OR
23552: PUSH
23553: LD_VAR 0 2
23557: PUSH
23558: LD_VAR 0 1
23562: GREATER
23563: OR
23564: PUSH
23565: LD_VAR 0 3
23569: PUSH
23570: LD_VAR 0 1
23574: GREATER
23575: OR
23576: IFFALSE 23580
// exit ;
23578: GO 23876
// if direction then
23580: LD_VAR 0 4
23584: IFFALSE 23648
// begin d := 1 ;
23586: LD_ADDR_VAR 0 9
23590: PUSH
23591: LD_INT 1
23593: ST_TO_ADDR
// if i_from > i_to then
23594: LD_VAR 0 2
23598: PUSH
23599: LD_VAR 0 3
23603: GREATER
23604: IFFALSE 23630
// length := ( array - i_from ) + i_to else
23606: LD_ADDR_VAR 0 11
23610: PUSH
23611: LD_VAR 0 1
23615: PUSH
23616: LD_VAR 0 2
23620: MINUS
23621: PUSH
23622: LD_VAR 0 3
23626: PLUS
23627: ST_TO_ADDR
23628: GO 23646
// length := i_to - i_from ;
23630: LD_ADDR_VAR 0 11
23634: PUSH
23635: LD_VAR 0 3
23639: PUSH
23640: LD_VAR 0 2
23644: MINUS
23645: ST_TO_ADDR
// end else
23646: GO 23709
// begin d := - 1 ;
23648: LD_ADDR_VAR 0 9
23652: PUSH
23653: LD_INT 1
23655: NEG
23656: ST_TO_ADDR
// if i_from > i_to then
23657: LD_VAR 0 2
23661: PUSH
23662: LD_VAR 0 3
23666: GREATER
23667: IFFALSE 23687
// length := i_from - i_to else
23669: LD_ADDR_VAR 0 11
23673: PUSH
23674: LD_VAR 0 2
23678: PUSH
23679: LD_VAR 0 3
23683: MINUS
23684: ST_TO_ADDR
23685: GO 23709
// length := ( array - i_to ) + i_from ;
23687: LD_ADDR_VAR 0 11
23691: PUSH
23692: LD_VAR 0 1
23696: PUSH
23697: LD_VAR 0 3
23701: MINUS
23702: PUSH
23703: LD_VAR 0 2
23707: PLUS
23708: ST_TO_ADDR
// end ; if not length then
23709: LD_VAR 0 11
23713: NOT
23714: IFFALSE 23718
// exit ;
23716: GO 23876
// tmp := array ;
23718: LD_ADDR_VAR 0 10
23722: PUSH
23723: LD_VAR 0 1
23727: ST_TO_ADDR
// for i = 1 to length do
23728: LD_ADDR_VAR 0 6
23732: PUSH
23733: DOUBLE
23734: LD_INT 1
23736: DEC
23737: ST_TO_ADDR
23738: LD_VAR 0 11
23742: PUSH
23743: FOR_TO
23744: IFFALSE 23864
// begin for j = 1 to array do
23746: LD_ADDR_VAR 0 7
23750: PUSH
23751: DOUBLE
23752: LD_INT 1
23754: DEC
23755: ST_TO_ADDR
23756: LD_VAR 0 1
23760: PUSH
23761: FOR_TO
23762: IFFALSE 23850
// begin k := j + d ;
23764: LD_ADDR_VAR 0 8
23768: PUSH
23769: LD_VAR 0 7
23773: PUSH
23774: LD_VAR 0 9
23778: PLUS
23779: ST_TO_ADDR
// if k > array then
23780: LD_VAR 0 8
23784: PUSH
23785: LD_VAR 0 1
23789: GREATER
23790: IFFALSE 23800
// k := 1 ;
23792: LD_ADDR_VAR 0 8
23796: PUSH
23797: LD_INT 1
23799: ST_TO_ADDR
// if not k then
23800: LD_VAR 0 8
23804: NOT
23805: IFFALSE 23817
// k := array ;
23807: LD_ADDR_VAR 0 8
23811: PUSH
23812: LD_VAR 0 1
23816: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
23817: LD_ADDR_VAR 0 10
23821: PUSH
23822: LD_VAR 0 10
23826: PPUSH
23827: LD_VAR 0 8
23831: PPUSH
23832: LD_VAR 0 1
23836: PUSH
23837: LD_VAR 0 7
23841: ARRAY
23842: PPUSH
23843: CALL_OW 1
23847: ST_TO_ADDR
// end ;
23848: GO 23761
23850: POP
23851: POP
// array := tmp ;
23852: LD_ADDR_VAR 0 1
23856: PUSH
23857: LD_VAR 0 10
23861: ST_TO_ADDR
// end ;
23862: GO 23743
23864: POP
23865: POP
// result := array ;
23866: LD_ADDR_VAR 0 5
23870: PUSH
23871: LD_VAR 0 1
23875: ST_TO_ADDR
// end ;
23876: LD_VAR 0 5
23880: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
23881: LD_INT 0
23883: PPUSH
23884: PPUSH
// result := 0 ;
23885: LD_ADDR_VAR 0 3
23889: PUSH
23890: LD_INT 0
23892: ST_TO_ADDR
// if not array or not value in array then
23893: LD_VAR 0 1
23897: NOT
23898: PUSH
23899: LD_VAR 0 2
23903: PUSH
23904: LD_VAR 0 1
23908: IN
23909: NOT
23910: OR
23911: IFFALSE 23915
// exit ;
23913: GO 23969
// for i = 1 to array do
23915: LD_ADDR_VAR 0 4
23919: PUSH
23920: DOUBLE
23921: LD_INT 1
23923: DEC
23924: ST_TO_ADDR
23925: LD_VAR 0 1
23929: PUSH
23930: FOR_TO
23931: IFFALSE 23967
// if value = array [ i ] then
23933: LD_VAR 0 2
23937: PUSH
23938: LD_VAR 0 1
23942: PUSH
23943: LD_VAR 0 4
23947: ARRAY
23948: EQUAL
23949: IFFALSE 23965
// begin result := i ;
23951: LD_ADDR_VAR 0 3
23955: PUSH
23956: LD_VAR 0 4
23960: ST_TO_ADDR
// exit ;
23961: POP
23962: POP
23963: GO 23969
// end ;
23965: GO 23930
23967: POP
23968: POP
// end ;
23969: LD_VAR 0 3
23973: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
23974: LD_INT 0
23976: PPUSH
// vc_chassis := chassis ;
23977: LD_ADDR_OWVAR 37
23981: PUSH
23982: LD_VAR 0 1
23986: ST_TO_ADDR
// vc_engine := engine ;
23987: LD_ADDR_OWVAR 39
23991: PUSH
23992: LD_VAR 0 2
23996: ST_TO_ADDR
// vc_control := control ;
23997: LD_ADDR_OWVAR 38
24001: PUSH
24002: LD_VAR 0 3
24006: ST_TO_ADDR
// vc_weapon := weapon ;
24007: LD_ADDR_OWVAR 40
24011: PUSH
24012: LD_VAR 0 4
24016: ST_TO_ADDR
// vc_fuel_battery := fuel ;
24017: LD_ADDR_OWVAR 41
24021: PUSH
24022: LD_VAR 0 5
24026: ST_TO_ADDR
// end ;
24027: LD_VAR 0 6
24031: RET
// export function WantPlant ( unit ) ; var task ; begin
24032: LD_INT 0
24034: PPUSH
24035: PPUSH
// result := false ;
24036: LD_ADDR_VAR 0 2
24040: PUSH
24041: LD_INT 0
24043: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
24044: LD_ADDR_VAR 0 3
24048: PUSH
24049: LD_VAR 0 1
24053: PPUSH
24054: CALL_OW 437
24058: ST_TO_ADDR
// if task then
24059: LD_VAR 0 3
24063: IFFALSE 24091
// if task [ 1 ] [ 1 ] = p then
24065: LD_VAR 0 3
24069: PUSH
24070: LD_INT 1
24072: ARRAY
24073: PUSH
24074: LD_INT 1
24076: ARRAY
24077: PUSH
24078: LD_STRING p
24080: EQUAL
24081: IFFALSE 24091
// result := true ;
24083: LD_ADDR_VAR 0 2
24087: PUSH
24088: LD_INT 1
24090: ST_TO_ADDR
// end ;
24091: LD_VAR 0 2
24095: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
24096: LD_INT 0
24098: PPUSH
24099: PPUSH
24100: PPUSH
24101: PPUSH
// if pos < 1 then
24102: LD_VAR 0 2
24106: PUSH
24107: LD_INT 1
24109: LESS
24110: IFFALSE 24114
// exit ;
24112: GO 24417
// if pos = 1 then
24114: LD_VAR 0 2
24118: PUSH
24119: LD_INT 1
24121: EQUAL
24122: IFFALSE 24155
// result := Replace ( arr , pos [ 1 ] , value ) else
24124: LD_ADDR_VAR 0 4
24128: PUSH
24129: LD_VAR 0 1
24133: PPUSH
24134: LD_VAR 0 2
24138: PUSH
24139: LD_INT 1
24141: ARRAY
24142: PPUSH
24143: LD_VAR 0 3
24147: PPUSH
24148: CALL_OW 1
24152: ST_TO_ADDR
24153: GO 24417
// begin tmp := arr ;
24155: LD_ADDR_VAR 0 6
24159: PUSH
24160: LD_VAR 0 1
24164: ST_TO_ADDR
// s_arr := [ tmp ] ;
24165: LD_ADDR_VAR 0 7
24169: PUSH
24170: LD_VAR 0 6
24174: PUSH
24175: EMPTY
24176: LIST
24177: ST_TO_ADDR
// for i = 1 to pos - 1 do
24178: LD_ADDR_VAR 0 5
24182: PUSH
24183: DOUBLE
24184: LD_INT 1
24186: DEC
24187: ST_TO_ADDR
24188: LD_VAR 0 2
24192: PUSH
24193: LD_INT 1
24195: MINUS
24196: PUSH
24197: FOR_TO
24198: IFFALSE 24243
// begin tmp := tmp [ pos [ i ] ] ;
24200: LD_ADDR_VAR 0 6
24204: PUSH
24205: LD_VAR 0 6
24209: PUSH
24210: LD_VAR 0 2
24214: PUSH
24215: LD_VAR 0 5
24219: ARRAY
24220: ARRAY
24221: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
24222: LD_ADDR_VAR 0 7
24226: PUSH
24227: LD_VAR 0 7
24231: PUSH
24232: LD_VAR 0 6
24236: PUSH
24237: EMPTY
24238: LIST
24239: ADD
24240: ST_TO_ADDR
// end ;
24241: GO 24197
24243: POP
24244: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
24245: LD_ADDR_VAR 0 6
24249: PUSH
24250: LD_VAR 0 6
24254: PPUSH
24255: LD_VAR 0 2
24259: PUSH
24260: LD_VAR 0 2
24264: ARRAY
24265: PPUSH
24266: LD_VAR 0 3
24270: PPUSH
24271: CALL_OW 1
24275: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
24276: LD_ADDR_VAR 0 7
24280: PUSH
24281: LD_VAR 0 7
24285: PPUSH
24286: LD_VAR 0 7
24290: PPUSH
24291: LD_VAR 0 6
24295: PPUSH
24296: CALL_OW 1
24300: ST_TO_ADDR
// for i = s_arr downto 2 do
24301: LD_ADDR_VAR 0 5
24305: PUSH
24306: DOUBLE
24307: LD_VAR 0 7
24311: INC
24312: ST_TO_ADDR
24313: LD_INT 2
24315: PUSH
24316: FOR_DOWNTO
24317: IFFALSE 24401
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
24319: LD_ADDR_VAR 0 6
24323: PUSH
24324: LD_VAR 0 7
24328: PUSH
24329: LD_VAR 0 5
24333: PUSH
24334: LD_INT 1
24336: MINUS
24337: ARRAY
24338: PPUSH
24339: LD_VAR 0 2
24343: PUSH
24344: LD_VAR 0 5
24348: PUSH
24349: LD_INT 1
24351: MINUS
24352: ARRAY
24353: PPUSH
24354: LD_VAR 0 7
24358: PUSH
24359: LD_VAR 0 5
24363: ARRAY
24364: PPUSH
24365: CALL_OW 1
24369: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
24370: LD_ADDR_VAR 0 7
24374: PUSH
24375: LD_VAR 0 7
24379: PPUSH
24380: LD_VAR 0 5
24384: PUSH
24385: LD_INT 1
24387: MINUS
24388: PPUSH
24389: LD_VAR 0 6
24393: PPUSH
24394: CALL_OW 1
24398: ST_TO_ADDR
// end ;
24399: GO 24316
24401: POP
24402: POP
// result := s_arr [ 1 ] ;
24403: LD_ADDR_VAR 0 4
24407: PUSH
24408: LD_VAR 0 7
24412: PUSH
24413: LD_INT 1
24415: ARRAY
24416: ST_TO_ADDR
// end ; end ;
24417: LD_VAR 0 4
24421: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
24422: LD_INT 0
24424: PPUSH
24425: PPUSH
// if not list then
24426: LD_VAR 0 1
24430: NOT
24431: IFFALSE 24435
// exit ;
24433: GO 24526
// i := list [ pos1 ] ;
24435: LD_ADDR_VAR 0 5
24439: PUSH
24440: LD_VAR 0 1
24444: PUSH
24445: LD_VAR 0 2
24449: ARRAY
24450: ST_TO_ADDR
// if not i then
24451: LD_VAR 0 5
24455: NOT
24456: IFFALSE 24460
// exit ;
24458: GO 24526
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
24460: LD_ADDR_VAR 0 1
24464: PUSH
24465: LD_VAR 0 1
24469: PPUSH
24470: LD_VAR 0 2
24474: PPUSH
24475: LD_VAR 0 1
24479: PUSH
24480: LD_VAR 0 3
24484: ARRAY
24485: PPUSH
24486: CALL_OW 1
24490: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
24491: LD_ADDR_VAR 0 1
24495: PUSH
24496: LD_VAR 0 1
24500: PPUSH
24501: LD_VAR 0 3
24505: PPUSH
24506: LD_VAR 0 5
24510: PPUSH
24511: CALL_OW 1
24515: ST_TO_ADDR
// result := list ;
24516: LD_ADDR_VAR 0 4
24520: PUSH
24521: LD_VAR 0 1
24525: ST_TO_ADDR
// end ;
24526: LD_VAR 0 4
24530: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
24531: LD_INT 0
24533: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
24534: LD_ADDR_VAR 0 5
24538: PUSH
24539: LD_VAR 0 1
24543: PPUSH
24544: CALL_OW 250
24548: PPUSH
24549: LD_VAR 0 1
24553: PPUSH
24554: CALL_OW 251
24558: PPUSH
24559: LD_VAR 0 2
24563: PPUSH
24564: LD_VAR 0 3
24568: PPUSH
24569: LD_VAR 0 4
24573: PPUSH
24574: CALL 24584 0 5
24578: ST_TO_ADDR
// end ;
24579: LD_VAR 0 5
24583: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
24584: LD_INT 0
24586: PPUSH
24587: PPUSH
24588: PPUSH
24589: PPUSH
// if not list then
24590: LD_VAR 0 3
24594: NOT
24595: IFFALSE 24599
// exit ;
24597: GO 24987
// result := [ ] ;
24599: LD_ADDR_VAR 0 6
24603: PUSH
24604: EMPTY
24605: ST_TO_ADDR
// for i in list do
24606: LD_ADDR_VAR 0 7
24610: PUSH
24611: LD_VAR 0 3
24615: PUSH
24616: FOR_IN
24617: IFFALSE 24819
// begin tmp := GetDistUnitXY ( i , x , y ) ;
24619: LD_ADDR_VAR 0 9
24623: PUSH
24624: LD_VAR 0 7
24628: PPUSH
24629: LD_VAR 0 1
24633: PPUSH
24634: LD_VAR 0 2
24638: PPUSH
24639: CALL_OW 297
24643: ST_TO_ADDR
// if not result then
24644: LD_VAR 0 6
24648: NOT
24649: IFFALSE 24675
// result := [ [ i , tmp ] ] else
24651: LD_ADDR_VAR 0 6
24655: PUSH
24656: LD_VAR 0 7
24660: PUSH
24661: LD_VAR 0 9
24665: PUSH
24666: EMPTY
24667: LIST
24668: LIST
24669: PUSH
24670: EMPTY
24671: LIST
24672: ST_TO_ADDR
24673: GO 24817
// begin if result [ result ] [ 2 ] < tmp then
24675: LD_VAR 0 6
24679: PUSH
24680: LD_VAR 0 6
24684: ARRAY
24685: PUSH
24686: LD_INT 2
24688: ARRAY
24689: PUSH
24690: LD_VAR 0 9
24694: LESS
24695: IFFALSE 24737
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
24697: LD_ADDR_VAR 0 6
24701: PUSH
24702: LD_VAR 0 6
24706: PPUSH
24707: LD_VAR 0 6
24711: PUSH
24712: LD_INT 1
24714: PLUS
24715: PPUSH
24716: LD_VAR 0 7
24720: PUSH
24721: LD_VAR 0 9
24725: PUSH
24726: EMPTY
24727: LIST
24728: LIST
24729: PPUSH
24730: CALL_OW 2
24734: ST_TO_ADDR
24735: GO 24817
// for j = 1 to result do
24737: LD_ADDR_VAR 0 8
24741: PUSH
24742: DOUBLE
24743: LD_INT 1
24745: DEC
24746: ST_TO_ADDR
24747: LD_VAR 0 6
24751: PUSH
24752: FOR_TO
24753: IFFALSE 24815
// begin if tmp < result [ j ] [ 2 ] then
24755: LD_VAR 0 9
24759: PUSH
24760: LD_VAR 0 6
24764: PUSH
24765: LD_VAR 0 8
24769: ARRAY
24770: PUSH
24771: LD_INT 2
24773: ARRAY
24774: LESS
24775: IFFALSE 24813
// begin result := Insert ( result , j , [ i , tmp ] ) ;
24777: LD_ADDR_VAR 0 6
24781: PUSH
24782: LD_VAR 0 6
24786: PPUSH
24787: LD_VAR 0 8
24791: PPUSH
24792: LD_VAR 0 7
24796: PUSH
24797: LD_VAR 0 9
24801: PUSH
24802: EMPTY
24803: LIST
24804: LIST
24805: PPUSH
24806: CALL_OW 2
24810: ST_TO_ADDR
// break ;
24811: GO 24815
// end ; end ;
24813: GO 24752
24815: POP
24816: POP
// end ; end ;
24817: GO 24616
24819: POP
24820: POP
// if result and not asc then
24821: LD_VAR 0 6
24825: PUSH
24826: LD_VAR 0 4
24830: NOT
24831: AND
24832: IFFALSE 24907
// begin tmp := result ;
24834: LD_ADDR_VAR 0 9
24838: PUSH
24839: LD_VAR 0 6
24843: ST_TO_ADDR
// for i = tmp downto 1 do
24844: LD_ADDR_VAR 0 7
24848: PUSH
24849: DOUBLE
24850: LD_VAR 0 9
24854: INC
24855: ST_TO_ADDR
24856: LD_INT 1
24858: PUSH
24859: FOR_DOWNTO
24860: IFFALSE 24905
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
24862: LD_ADDR_VAR 0 6
24866: PUSH
24867: LD_VAR 0 6
24871: PPUSH
24872: LD_VAR 0 9
24876: PUSH
24877: LD_VAR 0 7
24881: MINUS
24882: PUSH
24883: LD_INT 1
24885: PLUS
24886: PPUSH
24887: LD_VAR 0 9
24891: PUSH
24892: LD_VAR 0 7
24896: ARRAY
24897: PPUSH
24898: CALL_OW 1
24902: ST_TO_ADDR
24903: GO 24859
24905: POP
24906: POP
// end ; tmp := [ ] ;
24907: LD_ADDR_VAR 0 9
24911: PUSH
24912: EMPTY
24913: ST_TO_ADDR
// if mode then
24914: LD_VAR 0 5
24918: IFFALSE 24987
// begin for i = 1 to result do
24920: LD_ADDR_VAR 0 7
24924: PUSH
24925: DOUBLE
24926: LD_INT 1
24928: DEC
24929: ST_TO_ADDR
24930: LD_VAR 0 6
24934: PUSH
24935: FOR_TO
24936: IFFALSE 24975
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
24938: LD_ADDR_VAR 0 9
24942: PUSH
24943: LD_VAR 0 9
24947: PPUSH
24948: LD_VAR 0 7
24952: PPUSH
24953: LD_VAR 0 6
24957: PUSH
24958: LD_VAR 0 7
24962: ARRAY
24963: PUSH
24964: LD_INT 1
24966: ARRAY
24967: PPUSH
24968: CALL_OW 1
24972: ST_TO_ADDR
24973: GO 24935
24975: POP
24976: POP
// result := tmp ;
24977: LD_ADDR_VAR 0 6
24981: PUSH
24982: LD_VAR 0 9
24986: ST_TO_ADDR
// end ; end ;
24987: LD_VAR 0 6
24991: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
24992: LD_INT 0
24994: PPUSH
24995: PPUSH
24996: PPUSH
24997: PPUSH
24998: PPUSH
24999: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
25000: LD_ADDR_VAR 0 5
25004: PUSH
25005: LD_INT 0
25007: PUSH
25008: LD_INT 0
25010: PUSH
25011: LD_INT 0
25013: PUSH
25014: EMPTY
25015: PUSH
25016: EMPTY
25017: LIST
25018: LIST
25019: LIST
25020: LIST
25021: ST_TO_ADDR
// if not x or not y then
25022: LD_VAR 0 2
25026: NOT
25027: PUSH
25028: LD_VAR 0 3
25032: NOT
25033: OR
25034: IFFALSE 25038
// exit ;
25036: GO 26684
// if not range then
25038: LD_VAR 0 4
25042: NOT
25043: IFFALSE 25053
// range := 10 ;
25045: LD_ADDR_VAR 0 4
25049: PUSH
25050: LD_INT 10
25052: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
25053: LD_ADDR_VAR 0 8
25057: PUSH
25058: LD_INT 81
25060: PUSH
25061: LD_VAR 0 1
25065: PUSH
25066: EMPTY
25067: LIST
25068: LIST
25069: PUSH
25070: LD_INT 92
25072: PUSH
25073: LD_VAR 0 2
25077: PUSH
25078: LD_VAR 0 3
25082: PUSH
25083: LD_VAR 0 4
25087: PUSH
25088: EMPTY
25089: LIST
25090: LIST
25091: LIST
25092: LIST
25093: PUSH
25094: LD_INT 3
25096: PUSH
25097: LD_INT 21
25099: PUSH
25100: LD_INT 3
25102: PUSH
25103: EMPTY
25104: LIST
25105: LIST
25106: PUSH
25107: EMPTY
25108: LIST
25109: LIST
25110: PUSH
25111: EMPTY
25112: LIST
25113: LIST
25114: LIST
25115: PPUSH
25116: CALL_OW 69
25120: ST_TO_ADDR
// if not tmp then
25121: LD_VAR 0 8
25125: NOT
25126: IFFALSE 25130
// exit ;
25128: GO 26684
// for i in tmp do
25130: LD_ADDR_VAR 0 6
25134: PUSH
25135: LD_VAR 0 8
25139: PUSH
25140: FOR_IN
25141: IFFALSE 26659
// begin points := [ 0 , 0 , 0 ] ;
25143: LD_ADDR_VAR 0 9
25147: PUSH
25148: LD_INT 0
25150: PUSH
25151: LD_INT 0
25153: PUSH
25154: LD_INT 0
25156: PUSH
25157: EMPTY
25158: LIST
25159: LIST
25160: LIST
25161: ST_TO_ADDR
// bpoints := 1 ;
25162: LD_ADDR_VAR 0 10
25166: PUSH
25167: LD_INT 1
25169: ST_TO_ADDR
// case GetType ( i ) of unit_human :
25170: LD_VAR 0 6
25174: PPUSH
25175: CALL_OW 247
25179: PUSH
25180: LD_INT 1
25182: DOUBLE
25183: EQUAL
25184: IFTRUE 25188
25186: GO 25766
25188: POP
// begin if GetClass ( i ) = 1 then
25189: LD_VAR 0 6
25193: PPUSH
25194: CALL_OW 257
25198: PUSH
25199: LD_INT 1
25201: EQUAL
25202: IFFALSE 25223
// points := [ 10 , 5 , 3 ] ;
25204: LD_ADDR_VAR 0 9
25208: PUSH
25209: LD_INT 10
25211: PUSH
25212: LD_INT 5
25214: PUSH
25215: LD_INT 3
25217: PUSH
25218: EMPTY
25219: LIST
25220: LIST
25221: LIST
25222: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
25223: LD_VAR 0 6
25227: PPUSH
25228: CALL_OW 257
25232: PUSH
25233: LD_INT 2
25235: PUSH
25236: LD_INT 3
25238: PUSH
25239: LD_INT 4
25241: PUSH
25242: EMPTY
25243: LIST
25244: LIST
25245: LIST
25246: IN
25247: IFFALSE 25268
// points := [ 3 , 2 , 1 ] ;
25249: LD_ADDR_VAR 0 9
25253: PUSH
25254: LD_INT 3
25256: PUSH
25257: LD_INT 2
25259: PUSH
25260: LD_INT 1
25262: PUSH
25263: EMPTY
25264: LIST
25265: LIST
25266: LIST
25267: ST_TO_ADDR
// if GetClass ( i ) = 5 then
25268: LD_VAR 0 6
25272: PPUSH
25273: CALL_OW 257
25277: PUSH
25278: LD_INT 5
25280: EQUAL
25281: IFFALSE 25302
// points := [ 130 , 5 , 2 ] ;
25283: LD_ADDR_VAR 0 9
25287: PUSH
25288: LD_INT 130
25290: PUSH
25291: LD_INT 5
25293: PUSH
25294: LD_INT 2
25296: PUSH
25297: EMPTY
25298: LIST
25299: LIST
25300: LIST
25301: ST_TO_ADDR
// if GetClass ( i ) = 8 then
25302: LD_VAR 0 6
25306: PPUSH
25307: CALL_OW 257
25311: PUSH
25312: LD_INT 8
25314: EQUAL
25315: IFFALSE 25336
// points := [ 35 , 35 , 30 ] ;
25317: LD_ADDR_VAR 0 9
25321: PUSH
25322: LD_INT 35
25324: PUSH
25325: LD_INT 35
25327: PUSH
25328: LD_INT 30
25330: PUSH
25331: EMPTY
25332: LIST
25333: LIST
25334: LIST
25335: ST_TO_ADDR
// if GetClass ( i ) = 9 then
25336: LD_VAR 0 6
25340: PPUSH
25341: CALL_OW 257
25345: PUSH
25346: LD_INT 9
25348: EQUAL
25349: IFFALSE 25370
// points := [ 20 , 55 , 40 ] ;
25351: LD_ADDR_VAR 0 9
25355: PUSH
25356: LD_INT 20
25358: PUSH
25359: LD_INT 55
25361: PUSH
25362: LD_INT 40
25364: PUSH
25365: EMPTY
25366: LIST
25367: LIST
25368: LIST
25369: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
25370: LD_VAR 0 6
25374: PPUSH
25375: CALL_OW 257
25379: PUSH
25380: LD_INT 12
25382: PUSH
25383: LD_INT 16
25385: PUSH
25386: EMPTY
25387: LIST
25388: LIST
25389: IN
25390: IFFALSE 25411
// points := [ 5 , 3 , 2 ] ;
25392: LD_ADDR_VAR 0 9
25396: PUSH
25397: LD_INT 5
25399: PUSH
25400: LD_INT 3
25402: PUSH
25403: LD_INT 2
25405: PUSH
25406: EMPTY
25407: LIST
25408: LIST
25409: LIST
25410: ST_TO_ADDR
// if GetClass ( i ) = 17 then
25411: LD_VAR 0 6
25415: PPUSH
25416: CALL_OW 257
25420: PUSH
25421: LD_INT 17
25423: EQUAL
25424: IFFALSE 25445
// points := [ 100 , 50 , 75 ] ;
25426: LD_ADDR_VAR 0 9
25430: PUSH
25431: LD_INT 100
25433: PUSH
25434: LD_INT 50
25436: PUSH
25437: LD_INT 75
25439: PUSH
25440: EMPTY
25441: LIST
25442: LIST
25443: LIST
25444: ST_TO_ADDR
// if GetClass ( i ) = 15 then
25445: LD_VAR 0 6
25449: PPUSH
25450: CALL_OW 257
25454: PUSH
25455: LD_INT 15
25457: EQUAL
25458: IFFALSE 25479
// points := [ 10 , 5 , 3 ] ;
25460: LD_ADDR_VAR 0 9
25464: PUSH
25465: LD_INT 10
25467: PUSH
25468: LD_INT 5
25470: PUSH
25471: LD_INT 3
25473: PUSH
25474: EMPTY
25475: LIST
25476: LIST
25477: LIST
25478: ST_TO_ADDR
// if GetClass ( i ) = 14 then
25479: LD_VAR 0 6
25483: PPUSH
25484: CALL_OW 257
25488: PUSH
25489: LD_INT 14
25491: EQUAL
25492: IFFALSE 25513
// points := [ 10 , 0 , 0 ] ;
25494: LD_ADDR_VAR 0 9
25498: PUSH
25499: LD_INT 10
25501: PUSH
25502: LD_INT 0
25504: PUSH
25505: LD_INT 0
25507: PUSH
25508: EMPTY
25509: LIST
25510: LIST
25511: LIST
25512: ST_TO_ADDR
// if GetClass ( i ) = 11 then
25513: LD_VAR 0 6
25517: PPUSH
25518: CALL_OW 257
25522: PUSH
25523: LD_INT 11
25525: EQUAL
25526: IFFALSE 25547
// points := [ 30 , 10 , 5 ] ;
25528: LD_ADDR_VAR 0 9
25532: PUSH
25533: LD_INT 30
25535: PUSH
25536: LD_INT 10
25538: PUSH
25539: LD_INT 5
25541: PUSH
25542: EMPTY
25543: LIST
25544: LIST
25545: LIST
25546: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
25547: LD_VAR 0 1
25551: PPUSH
25552: LD_INT 5
25554: PPUSH
25555: CALL_OW 321
25559: PUSH
25560: LD_INT 2
25562: EQUAL
25563: IFFALSE 25580
// bpoints := bpoints * 1.8 ;
25565: LD_ADDR_VAR 0 10
25569: PUSH
25570: LD_VAR 0 10
25574: PUSH
25575: LD_REAL  1.80000000000000E+0000
25578: MUL
25579: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
25580: LD_VAR 0 6
25584: PPUSH
25585: CALL_OW 257
25589: PUSH
25590: LD_INT 1
25592: PUSH
25593: LD_INT 2
25595: PUSH
25596: LD_INT 3
25598: PUSH
25599: LD_INT 4
25601: PUSH
25602: EMPTY
25603: LIST
25604: LIST
25605: LIST
25606: LIST
25607: IN
25608: PUSH
25609: LD_VAR 0 1
25613: PPUSH
25614: LD_INT 51
25616: PPUSH
25617: CALL_OW 321
25621: PUSH
25622: LD_INT 2
25624: EQUAL
25625: AND
25626: IFFALSE 25643
// bpoints := bpoints * 1.2 ;
25628: LD_ADDR_VAR 0 10
25632: PUSH
25633: LD_VAR 0 10
25637: PUSH
25638: LD_REAL  1.20000000000000E+0000
25641: MUL
25642: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
25643: LD_VAR 0 6
25647: PPUSH
25648: CALL_OW 257
25652: PUSH
25653: LD_INT 5
25655: PUSH
25656: LD_INT 7
25658: PUSH
25659: LD_INT 9
25661: PUSH
25662: EMPTY
25663: LIST
25664: LIST
25665: LIST
25666: IN
25667: PUSH
25668: LD_VAR 0 1
25672: PPUSH
25673: LD_INT 52
25675: PPUSH
25676: CALL_OW 321
25680: PUSH
25681: LD_INT 2
25683: EQUAL
25684: AND
25685: IFFALSE 25702
// bpoints := bpoints * 1.5 ;
25687: LD_ADDR_VAR 0 10
25691: PUSH
25692: LD_VAR 0 10
25696: PUSH
25697: LD_REAL  1.50000000000000E+0000
25700: MUL
25701: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
25702: LD_VAR 0 1
25706: PPUSH
25707: LD_INT 66
25709: PPUSH
25710: CALL_OW 321
25714: PUSH
25715: LD_INT 2
25717: EQUAL
25718: IFFALSE 25735
// bpoints := bpoints * 1.1 ;
25720: LD_ADDR_VAR 0 10
25724: PUSH
25725: LD_VAR 0 10
25729: PUSH
25730: LD_REAL  1.10000000000000E+0000
25733: MUL
25734: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
25735: LD_ADDR_VAR 0 10
25739: PUSH
25740: LD_VAR 0 10
25744: PUSH
25745: LD_VAR 0 6
25749: PPUSH
25750: LD_INT 1
25752: PPUSH
25753: CALL_OW 259
25757: PUSH
25758: LD_REAL  1.15000000000000E+0000
25761: MUL
25762: MUL
25763: ST_TO_ADDR
// end ; unit_vehicle :
25764: GO 26588
25766: LD_INT 2
25768: DOUBLE
25769: EQUAL
25770: IFTRUE 25774
25772: GO 26576
25774: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
25775: LD_VAR 0 6
25779: PPUSH
25780: CALL_OW 264
25784: PUSH
25785: LD_INT 2
25787: PUSH
25788: LD_INT 42
25790: PUSH
25791: LD_INT 24
25793: PUSH
25794: EMPTY
25795: LIST
25796: LIST
25797: LIST
25798: IN
25799: IFFALSE 25820
// points := [ 25 , 5 , 3 ] ;
25801: LD_ADDR_VAR 0 9
25805: PUSH
25806: LD_INT 25
25808: PUSH
25809: LD_INT 5
25811: PUSH
25812: LD_INT 3
25814: PUSH
25815: EMPTY
25816: LIST
25817: LIST
25818: LIST
25819: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
25820: LD_VAR 0 6
25824: PPUSH
25825: CALL_OW 264
25829: PUSH
25830: LD_INT 4
25832: PUSH
25833: LD_INT 43
25835: PUSH
25836: LD_INT 25
25838: PUSH
25839: EMPTY
25840: LIST
25841: LIST
25842: LIST
25843: IN
25844: IFFALSE 25865
// points := [ 40 , 15 , 5 ] ;
25846: LD_ADDR_VAR 0 9
25850: PUSH
25851: LD_INT 40
25853: PUSH
25854: LD_INT 15
25856: PUSH
25857: LD_INT 5
25859: PUSH
25860: EMPTY
25861: LIST
25862: LIST
25863: LIST
25864: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
25865: LD_VAR 0 6
25869: PPUSH
25870: CALL_OW 264
25874: PUSH
25875: LD_INT 3
25877: PUSH
25878: LD_INT 23
25880: PUSH
25881: EMPTY
25882: LIST
25883: LIST
25884: IN
25885: IFFALSE 25906
// points := [ 7 , 25 , 8 ] ;
25887: LD_ADDR_VAR 0 9
25891: PUSH
25892: LD_INT 7
25894: PUSH
25895: LD_INT 25
25897: PUSH
25898: LD_INT 8
25900: PUSH
25901: EMPTY
25902: LIST
25903: LIST
25904: LIST
25905: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
25906: LD_VAR 0 6
25910: PPUSH
25911: CALL_OW 264
25915: PUSH
25916: LD_INT 5
25918: PUSH
25919: LD_INT 27
25921: PUSH
25922: LD_INT 44
25924: PUSH
25925: EMPTY
25926: LIST
25927: LIST
25928: LIST
25929: IN
25930: IFFALSE 25951
// points := [ 14 , 50 , 16 ] ;
25932: LD_ADDR_VAR 0 9
25936: PUSH
25937: LD_INT 14
25939: PUSH
25940: LD_INT 50
25942: PUSH
25943: LD_INT 16
25945: PUSH
25946: EMPTY
25947: LIST
25948: LIST
25949: LIST
25950: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
25951: LD_VAR 0 6
25955: PPUSH
25956: CALL_OW 264
25960: PUSH
25961: LD_INT 6
25963: PUSH
25964: LD_INT 46
25966: PUSH
25967: EMPTY
25968: LIST
25969: LIST
25970: IN
25971: IFFALSE 25992
// points := [ 32 , 120 , 70 ] ;
25973: LD_ADDR_VAR 0 9
25977: PUSH
25978: LD_INT 32
25980: PUSH
25981: LD_INT 120
25983: PUSH
25984: LD_INT 70
25986: PUSH
25987: EMPTY
25988: LIST
25989: LIST
25990: LIST
25991: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] then
25992: LD_VAR 0 6
25996: PPUSH
25997: CALL_OW 264
26001: PUSH
26002: LD_INT 7
26004: PUSH
26005: LD_INT 28
26007: PUSH
26008: LD_INT 45
26010: PUSH
26011: EMPTY
26012: LIST
26013: LIST
26014: LIST
26015: IN
26016: IFFALSE 26037
// points := [ 35 , 20 , 45 ] ;
26018: LD_ADDR_VAR 0 9
26022: PUSH
26023: LD_INT 35
26025: PUSH
26026: LD_INT 20
26028: PUSH
26029: LD_INT 45
26031: PUSH
26032: EMPTY
26033: LIST
26034: LIST
26035: LIST
26036: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
26037: LD_VAR 0 6
26041: PPUSH
26042: CALL_OW 264
26046: PUSH
26047: LD_INT 47
26049: PUSH
26050: EMPTY
26051: LIST
26052: IN
26053: IFFALSE 26074
// points := [ 67 , 45 , 75 ] ;
26055: LD_ADDR_VAR 0 9
26059: PUSH
26060: LD_INT 67
26062: PUSH
26063: LD_INT 45
26065: PUSH
26066: LD_INT 75
26068: PUSH
26069: EMPTY
26070: LIST
26071: LIST
26072: LIST
26073: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
26074: LD_VAR 0 6
26078: PPUSH
26079: CALL_OW 264
26083: PUSH
26084: LD_INT 26
26086: PUSH
26087: EMPTY
26088: LIST
26089: IN
26090: IFFALSE 26111
// points := [ 120 , 30 , 80 ] ;
26092: LD_ADDR_VAR 0 9
26096: PUSH
26097: LD_INT 120
26099: PUSH
26100: LD_INT 30
26102: PUSH
26103: LD_INT 80
26105: PUSH
26106: EMPTY
26107: LIST
26108: LIST
26109: LIST
26110: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
26111: LD_VAR 0 6
26115: PPUSH
26116: CALL_OW 264
26120: PUSH
26121: LD_INT 22
26123: PUSH
26124: EMPTY
26125: LIST
26126: IN
26127: IFFALSE 26148
// points := [ 40 , 1 , 1 ] ;
26129: LD_ADDR_VAR 0 9
26133: PUSH
26134: LD_INT 40
26136: PUSH
26137: LD_INT 1
26139: PUSH
26140: LD_INT 1
26142: PUSH
26143: EMPTY
26144: LIST
26145: LIST
26146: LIST
26147: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
26148: LD_VAR 0 6
26152: PPUSH
26153: CALL_OW 264
26157: PUSH
26158: LD_INT 29
26160: PUSH
26161: EMPTY
26162: LIST
26163: IN
26164: IFFALSE 26185
// points := [ 70 , 200 , 400 ] ;
26166: LD_ADDR_VAR 0 9
26170: PUSH
26171: LD_INT 70
26173: PUSH
26174: LD_INT 200
26176: PUSH
26177: LD_INT 400
26179: PUSH
26180: EMPTY
26181: LIST
26182: LIST
26183: LIST
26184: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
26185: LD_VAR 0 6
26189: PPUSH
26190: CALL_OW 264
26194: PUSH
26195: LD_INT 14
26197: PUSH
26198: LD_INT 53
26200: PUSH
26201: EMPTY
26202: LIST
26203: LIST
26204: IN
26205: IFFALSE 26226
// points := [ 40 , 10 , 20 ] ;
26207: LD_ADDR_VAR 0 9
26211: PUSH
26212: LD_INT 40
26214: PUSH
26215: LD_INT 10
26217: PUSH
26218: LD_INT 20
26220: PUSH
26221: EMPTY
26222: LIST
26223: LIST
26224: LIST
26225: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
26226: LD_VAR 0 6
26230: PPUSH
26231: CALL_OW 264
26235: PUSH
26236: LD_INT 9
26238: PUSH
26239: EMPTY
26240: LIST
26241: IN
26242: IFFALSE 26263
// points := [ 5 , 70 , 20 ] ;
26244: LD_ADDR_VAR 0 9
26248: PUSH
26249: LD_INT 5
26251: PUSH
26252: LD_INT 70
26254: PUSH
26255: LD_INT 20
26257: PUSH
26258: EMPTY
26259: LIST
26260: LIST
26261: LIST
26262: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
26263: LD_VAR 0 6
26267: PPUSH
26268: CALL_OW 264
26272: PUSH
26273: LD_INT 10
26275: PUSH
26276: EMPTY
26277: LIST
26278: IN
26279: IFFALSE 26300
// points := [ 35 , 110 , 70 ] ;
26281: LD_ADDR_VAR 0 9
26285: PUSH
26286: LD_INT 35
26288: PUSH
26289: LD_INT 110
26291: PUSH
26292: LD_INT 70
26294: PUSH
26295: EMPTY
26296: LIST
26297: LIST
26298: LIST
26299: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
26300: LD_VAR 0 6
26304: PPUSH
26305: CALL_OW 265
26309: PUSH
26310: LD_INT 25
26312: EQUAL
26313: IFFALSE 26334
// points := [ 80 , 65 , 100 ] ;
26315: LD_ADDR_VAR 0 9
26319: PUSH
26320: LD_INT 80
26322: PUSH
26323: LD_INT 65
26325: PUSH
26326: LD_INT 100
26328: PUSH
26329: EMPTY
26330: LIST
26331: LIST
26332: LIST
26333: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
26334: LD_VAR 0 6
26338: PPUSH
26339: CALL_OW 263
26343: PUSH
26344: LD_INT 1
26346: EQUAL
26347: IFFALSE 26382
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
26349: LD_ADDR_VAR 0 10
26353: PUSH
26354: LD_VAR 0 10
26358: PUSH
26359: LD_VAR 0 6
26363: PPUSH
26364: CALL_OW 311
26368: PPUSH
26369: LD_INT 3
26371: PPUSH
26372: CALL_OW 259
26376: PUSH
26377: LD_INT 4
26379: MUL
26380: MUL
26381: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
26382: LD_VAR 0 6
26386: PPUSH
26387: CALL_OW 263
26391: PUSH
26392: LD_INT 2
26394: EQUAL
26395: IFFALSE 26446
// begin j := IsControledBy ( i ) ;
26397: LD_ADDR_VAR 0 7
26401: PUSH
26402: LD_VAR 0 6
26406: PPUSH
26407: CALL_OW 312
26411: ST_TO_ADDR
// if j then
26412: LD_VAR 0 7
26416: IFFALSE 26446
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
26418: LD_ADDR_VAR 0 10
26422: PUSH
26423: LD_VAR 0 10
26427: PUSH
26428: LD_VAR 0 7
26432: PPUSH
26433: LD_INT 3
26435: PPUSH
26436: CALL_OW 259
26440: PUSH
26441: LD_INT 3
26443: MUL
26444: MUL
26445: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
26446: LD_VAR 0 6
26450: PPUSH
26451: CALL_OW 264
26455: PUSH
26456: LD_INT 5
26458: PUSH
26459: LD_INT 6
26461: PUSH
26462: LD_INT 46
26464: PUSH
26465: LD_INT 44
26467: PUSH
26468: LD_INT 47
26470: PUSH
26471: LD_INT 45
26473: PUSH
26474: LD_INT 28
26476: PUSH
26477: LD_INT 7
26479: PUSH
26480: LD_INT 27
26482: PUSH
26483: LD_INT 29
26485: PUSH
26486: EMPTY
26487: LIST
26488: LIST
26489: LIST
26490: LIST
26491: LIST
26492: LIST
26493: LIST
26494: LIST
26495: LIST
26496: LIST
26497: IN
26498: PUSH
26499: LD_VAR 0 1
26503: PPUSH
26504: LD_INT 52
26506: PPUSH
26507: CALL_OW 321
26511: PUSH
26512: LD_INT 2
26514: EQUAL
26515: AND
26516: IFFALSE 26533
// bpoints := bpoints * 1.2 ;
26518: LD_ADDR_VAR 0 10
26522: PUSH
26523: LD_VAR 0 10
26527: PUSH
26528: LD_REAL  1.20000000000000E+0000
26531: MUL
26532: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
26533: LD_VAR 0 6
26537: PPUSH
26538: CALL_OW 264
26542: PUSH
26543: LD_INT 6
26545: PUSH
26546: LD_INT 46
26548: PUSH
26549: LD_INT 47
26551: PUSH
26552: EMPTY
26553: LIST
26554: LIST
26555: LIST
26556: IN
26557: IFFALSE 26574
// bpoints := bpoints * 1.2 ;
26559: LD_ADDR_VAR 0 10
26563: PUSH
26564: LD_VAR 0 10
26568: PUSH
26569: LD_REAL  1.20000000000000E+0000
26572: MUL
26573: ST_TO_ADDR
// end ; unit_building :
26574: GO 26588
26576: LD_INT 3
26578: DOUBLE
26579: EQUAL
26580: IFTRUE 26584
26582: GO 26587
26584: POP
// ; end ;
26585: GO 26588
26587: POP
// for j = 1 to 3 do
26588: LD_ADDR_VAR 0 7
26592: PUSH
26593: DOUBLE
26594: LD_INT 1
26596: DEC
26597: ST_TO_ADDR
26598: LD_INT 3
26600: PUSH
26601: FOR_TO
26602: IFFALSE 26655
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
26604: LD_ADDR_VAR 0 5
26608: PUSH
26609: LD_VAR 0 5
26613: PPUSH
26614: LD_VAR 0 7
26618: PPUSH
26619: LD_VAR 0 5
26623: PUSH
26624: LD_VAR 0 7
26628: ARRAY
26629: PUSH
26630: LD_VAR 0 9
26634: PUSH
26635: LD_VAR 0 7
26639: ARRAY
26640: PUSH
26641: LD_VAR 0 10
26645: MUL
26646: PLUS
26647: PPUSH
26648: CALL_OW 1
26652: ST_TO_ADDR
26653: GO 26601
26655: POP
26656: POP
// end ;
26657: GO 25140
26659: POP
26660: POP
// result := Replace ( result , 4 , tmp ) ;
26661: LD_ADDR_VAR 0 5
26665: PUSH
26666: LD_VAR 0 5
26670: PPUSH
26671: LD_INT 4
26673: PPUSH
26674: LD_VAR 0 8
26678: PPUSH
26679: CALL_OW 1
26683: ST_TO_ADDR
// end ;
26684: LD_VAR 0 5
26688: RET
// export function DangerAtRange ( unit , range ) ; begin
26689: LD_INT 0
26691: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
26692: LD_ADDR_VAR 0 3
26696: PUSH
26697: LD_VAR 0 1
26701: PPUSH
26702: CALL_OW 255
26706: PPUSH
26707: LD_VAR 0 1
26711: PPUSH
26712: CALL_OW 250
26716: PPUSH
26717: LD_VAR 0 1
26721: PPUSH
26722: CALL_OW 251
26726: PPUSH
26727: LD_VAR 0 2
26731: PPUSH
26732: CALL 24992 0 4
26736: ST_TO_ADDR
// end ;
26737: LD_VAR 0 3
26741: RET
// export function DangerInArea ( side , area ) ; begin
26742: LD_INT 0
26744: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
26745: LD_ADDR_VAR 0 3
26749: PUSH
26750: LD_VAR 0 2
26754: PPUSH
26755: LD_INT 81
26757: PUSH
26758: LD_VAR 0 1
26762: PUSH
26763: EMPTY
26764: LIST
26765: LIST
26766: PPUSH
26767: CALL_OW 70
26771: ST_TO_ADDR
// end ;
26772: LD_VAR 0 3
26776: RET
// export function IsExtension ( b ) ; begin
26777: LD_INT 0
26779: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
26780: LD_ADDR_VAR 0 2
26784: PUSH
26785: LD_VAR 0 1
26789: PUSH
26790: LD_INT 23
26792: PUSH
26793: LD_INT 20
26795: PUSH
26796: LD_INT 22
26798: PUSH
26799: LD_INT 17
26801: PUSH
26802: LD_INT 24
26804: PUSH
26805: LD_INT 21
26807: PUSH
26808: LD_INT 19
26810: PUSH
26811: LD_INT 16
26813: PUSH
26814: LD_INT 25
26816: PUSH
26817: LD_INT 18
26819: PUSH
26820: EMPTY
26821: LIST
26822: LIST
26823: LIST
26824: LIST
26825: LIST
26826: LIST
26827: LIST
26828: LIST
26829: LIST
26830: LIST
26831: IN
26832: ST_TO_ADDR
// end ;
26833: LD_VAR 0 2
26837: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
26838: LD_INT 0
26840: PPUSH
26841: PPUSH
26842: PPUSH
// result := [ ] ;
26843: LD_ADDR_VAR 0 4
26847: PUSH
26848: EMPTY
26849: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
26850: LD_ADDR_VAR 0 5
26854: PUSH
26855: LD_VAR 0 2
26859: PPUSH
26860: LD_INT 21
26862: PUSH
26863: LD_INT 3
26865: PUSH
26866: EMPTY
26867: LIST
26868: LIST
26869: PPUSH
26870: CALL_OW 70
26874: ST_TO_ADDR
// if not tmp then
26875: LD_VAR 0 5
26879: NOT
26880: IFFALSE 26884
// exit ;
26882: GO 26948
// if checkLink then
26884: LD_VAR 0 3
26888: IFFALSE 26938
// begin for i in tmp do
26890: LD_ADDR_VAR 0 6
26894: PUSH
26895: LD_VAR 0 5
26899: PUSH
26900: FOR_IN
26901: IFFALSE 26936
// if GetBase ( i ) <> base then
26903: LD_VAR 0 6
26907: PPUSH
26908: CALL_OW 274
26912: PUSH
26913: LD_VAR 0 1
26917: NONEQUAL
26918: IFFALSE 26934
// ComLinkToBase ( base , i ) ;
26920: LD_VAR 0 1
26924: PPUSH
26925: LD_VAR 0 6
26929: PPUSH
26930: CALL_OW 169
26934: GO 26900
26936: POP
26937: POP
// end ; result := tmp ;
26938: LD_ADDR_VAR 0 4
26942: PUSH
26943: LD_VAR 0 5
26947: ST_TO_ADDR
// end ;
26948: LD_VAR 0 4
26952: RET
// export function ComComplete ( units , b ) ; var i ; begin
26953: LD_INT 0
26955: PPUSH
26956: PPUSH
// if not units then
26957: LD_VAR 0 1
26961: NOT
26962: IFFALSE 26966
// exit ;
26964: GO 27056
// for i in units do
26966: LD_ADDR_VAR 0 4
26970: PUSH
26971: LD_VAR 0 1
26975: PUSH
26976: FOR_IN
26977: IFFALSE 27054
// if BuildingStatus ( b ) = bs_build then
26979: LD_VAR 0 2
26983: PPUSH
26984: CALL_OW 461
26988: PUSH
26989: LD_INT 1
26991: EQUAL
26992: IFFALSE 27052
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
26994: LD_VAR 0 4
26998: PPUSH
26999: LD_STRING h
27001: PUSH
27002: LD_VAR 0 2
27006: PPUSH
27007: CALL_OW 250
27011: PUSH
27012: LD_VAR 0 2
27016: PPUSH
27017: CALL_OW 251
27021: PUSH
27022: LD_VAR 0 2
27026: PUSH
27027: LD_INT 0
27029: PUSH
27030: LD_INT 0
27032: PUSH
27033: LD_INT 0
27035: PUSH
27036: EMPTY
27037: LIST
27038: LIST
27039: LIST
27040: LIST
27041: LIST
27042: LIST
27043: LIST
27044: PUSH
27045: EMPTY
27046: LIST
27047: PPUSH
27048: CALL_OW 446
27052: GO 26976
27054: POP
27055: POP
// end ;
27056: LD_VAR 0 3
27060: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
27061: LD_INT 0
27063: PPUSH
27064: PPUSH
27065: PPUSH
27066: PPUSH
27067: PPUSH
27068: PPUSH
// if not vehicle or not GetControl ( vehicle ) = control_remote then
27069: LD_VAR 0 1
27073: NOT
27074: PUSH
27075: LD_VAR 0 1
27079: PPUSH
27080: CALL_OW 263
27084: PUSH
27085: LD_INT 2
27087: EQUAL
27088: NOT
27089: OR
27090: IFFALSE 27094
// exit ;
27092: GO 27410
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
27094: LD_ADDR_VAR 0 6
27098: PUSH
27099: LD_INT 22
27101: PUSH
27102: LD_VAR 0 1
27106: PPUSH
27107: CALL_OW 255
27111: PUSH
27112: EMPTY
27113: LIST
27114: LIST
27115: PUSH
27116: LD_INT 2
27118: PUSH
27119: LD_INT 30
27121: PUSH
27122: LD_INT 36
27124: PUSH
27125: EMPTY
27126: LIST
27127: LIST
27128: PUSH
27129: LD_INT 34
27131: PUSH
27132: LD_INT 31
27134: PUSH
27135: EMPTY
27136: LIST
27137: LIST
27138: PUSH
27139: EMPTY
27140: LIST
27141: LIST
27142: LIST
27143: PUSH
27144: EMPTY
27145: LIST
27146: LIST
27147: PPUSH
27148: CALL_OW 69
27152: ST_TO_ADDR
// if not tmp then
27153: LD_VAR 0 6
27157: NOT
27158: IFFALSE 27162
// exit ;
27160: GO 27410
// result := [ ] ;
27162: LD_ADDR_VAR 0 2
27166: PUSH
27167: EMPTY
27168: ST_TO_ADDR
// for i in tmp do
27169: LD_ADDR_VAR 0 3
27173: PUSH
27174: LD_VAR 0 6
27178: PUSH
27179: FOR_IN
27180: IFFALSE 27251
// begin t := UnitsInside ( i ) ;
27182: LD_ADDR_VAR 0 4
27186: PUSH
27187: LD_VAR 0 3
27191: PPUSH
27192: CALL_OW 313
27196: ST_TO_ADDR
// if t then
27197: LD_VAR 0 4
27201: IFFALSE 27249
// for j in t do
27203: LD_ADDR_VAR 0 7
27207: PUSH
27208: LD_VAR 0 4
27212: PUSH
27213: FOR_IN
27214: IFFALSE 27247
// result := Insert ( result , result + 1 , j ) ;
27216: LD_ADDR_VAR 0 2
27220: PUSH
27221: LD_VAR 0 2
27225: PPUSH
27226: LD_VAR 0 2
27230: PUSH
27231: LD_INT 1
27233: PLUS
27234: PPUSH
27235: LD_VAR 0 7
27239: PPUSH
27240: CALL_OW 2
27244: ST_TO_ADDR
27245: GO 27213
27247: POP
27248: POP
// end ;
27249: GO 27179
27251: POP
27252: POP
// if not result then
27253: LD_VAR 0 2
27257: NOT
27258: IFFALSE 27262
// exit ;
27260: GO 27410
// mech := result [ 1 ] ;
27262: LD_ADDR_VAR 0 5
27266: PUSH
27267: LD_VAR 0 2
27271: PUSH
27272: LD_INT 1
27274: ARRAY
27275: ST_TO_ADDR
// if result > 1 then
27276: LD_VAR 0 2
27280: PUSH
27281: LD_INT 1
27283: GREATER
27284: IFFALSE 27396
// for i = 2 to result do
27286: LD_ADDR_VAR 0 3
27290: PUSH
27291: DOUBLE
27292: LD_INT 2
27294: DEC
27295: ST_TO_ADDR
27296: LD_VAR 0 2
27300: PUSH
27301: FOR_TO
27302: IFFALSE 27394
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
27304: LD_ADDR_VAR 0 4
27308: PUSH
27309: LD_VAR 0 2
27313: PUSH
27314: LD_VAR 0 3
27318: ARRAY
27319: PPUSH
27320: LD_INT 3
27322: PPUSH
27323: CALL_OW 259
27327: PUSH
27328: LD_VAR 0 2
27332: PUSH
27333: LD_VAR 0 3
27337: ARRAY
27338: PPUSH
27339: CALL_OW 432
27343: MINUS
27344: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
27345: LD_VAR 0 4
27349: PUSH
27350: LD_VAR 0 5
27354: PPUSH
27355: LD_INT 3
27357: PPUSH
27358: CALL_OW 259
27362: PUSH
27363: LD_VAR 0 5
27367: PPUSH
27368: CALL_OW 432
27372: MINUS
27373: GREATEREQUAL
27374: IFFALSE 27392
// mech := result [ i ] ;
27376: LD_ADDR_VAR 0 5
27380: PUSH
27381: LD_VAR 0 2
27385: PUSH
27386: LD_VAR 0 3
27390: ARRAY
27391: ST_TO_ADDR
// end ;
27392: GO 27301
27394: POP
27395: POP
// ComLinkTo ( vehicle , mech ) ;
27396: LD_VAR 0 1
27400: PPUSH
27401: LD_VAR 0 5
27405: PPUSH
27406: CALL_OW 135
// end ;
27410: LD_VAR 0 2
27414: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
27415: LD_INT 0
27417: PPUSH
27418: PPUSH
27419: PPUSH
27420: PPUSH
27421: PPUSH
27422: PPUSH
27423: PPUSH
27424: PPUSH
27425: PPUSH
27426: PPUSH
27427: PPUSH
27428: PPUSH
27429: PPUSH
// result := [ ] ;
27430: LD_ADDR_VAR 0 7
27434: PUSH
27435: EMPTY
27436: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
27437: LD_VAR 0 1
27441: PPUSH
27442: CALL_OW 266
27446: PUSH
27447: LD_INT 0
27449: PUSH
27450: LD_INT 1
27452: PUSH
27453: EMPTY
27454: LIST
27455: LIST
27456: IN
27457: NOT
27458: IFFALSE 27462
// exit ;
27460: GO 29096
// if name then
27462: LD_VAR 0 3
27466: IFFALSE 27482
// SetBName ( base_dep , name ) ;
27468: LD_VAR 0 1
27472: PPUSH
27473: LD_VAR 0 3
27477: PPUSH
27478: CALL_OW 500
// base := GetBase ( base_dep ) ;
27482: LD_ADDR_VAR 0 15
27486: PUSH
27487: LD_VAR 0 1
27491: PPUSH
27492: CALL_OW 274
27496: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
27497: LD_ADDR_VAR 0 16
27501: PUSH
27502: LD_VAR 0 1
27506: PPUSH
27507: CALL_OW 255
27511: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
27512: LD_ADDR_VAR 0 17
27516: PUSH
27517: LD_VAR 0 1
27521: PPUSH
27522: CALL_OW 248
27526: ST_TO_ADDR
// if sources then
27527: LD_VAR 0 5
27531: IFFALSE 27578
// for i = 1 to 3 do
27533: LD_ADDR_VAR 0 8
27537: PUSH
27538: DOUBLE
27539: LD_INT 1
27541: DEC
27542: ST_TO_ADDR
27543: LD_INT 3
27545: PUSH
27546: FOR_TO
27547: IFFALSE 27576
// AddResourceType ( base , i , sources [ i ] ) ;
27549: LD_VAR 0 15
27553: PPUSH
27554: LD_VAR 0 8
27558: PPUSH
27559: LD_VAR 0 5
27563: PUSH
27564: LD_VAR 0 8
27568: ARRAY
27569: PPUSH
27570: CALL_OW 276
27574: GO 27546
27576: POP
27577: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
27578: LD_ADDR_VAR 0 18
27582: PUSH
27583: LD_VAR 0 15
27587: PPUSH
27588: LD_VAR 0 2
27592: PPUSH
27593: LD_INT 1
27595: PPUSH
27596: CALL 26838 0 3
27600: ST_TO_ADDR
// InitHc ;
27601: CALL_OW 19
// InitUc ;
27605: CALL_OW 18
// uc_side := side ;
27609: LD_ADDR_OWVAR 20
27613: PUSH
27614: LD_VAR 0 16
27618: ST_TO_ADDR
// uc_nation := nation ;
27619: LD_ADDR_OWVAR 21
27623: PUSH
27624: LD_VAR 0 17
27628: ST_TO_ADDR
// if buildings then
27629: LD_VAR 0 18
27633: IFFALSE 28955
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
27635: LD_ADDR_VAR 0 19
27639: PUSH
27640: LD_VAR 0 18
27644: PPUSH
27645: LD_INT 2
27647: PUSH
27648: LD_INT 30
27650: PUSH
27651: LD_INT 29
27653: PUSH
27654: EMPTY
27655: LIST
27656: LIST
27657: PUSH
27658: LD_INT 30
27660: PUSH
27661: LD_INT 30
27663: PUSH
27664: EMPTY
27665: LIST
27666: LIST
27667: PUSH
27668: EMPTY
27669: LIST
27670: LIST
27671: LIST
27672: PPUSH
27673: CALL_OW 72
27677: ST_TO_ADDR
// if tmp then
27678: LD_VAR 0 19
27682: IFFALSE 27730
// for i in tmp do
27684: LD_ADDR_VAR 0 8
27688: PUSH
27689: LD_VAR 0 19
27693: PUSH
27694: FOR_IN
27695: IFFALSE 27728
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
27697: LD_VAR 0 8
27701: PPUSH
27702: CALL_OW 250
27706: PPUSH
27707: LD_VAR 0 8
27711: PPUSH
27712: CALL_OW 251
27716: PPUSH
27717: LD_VAR 0 16
27721: PPUSH
27722: CALL_OW 441
27726: GO 27694
27728: POP
27729: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
27730: LD_VAR 0 18
27734: PPUSH
27735: LD_INT 2
27737: PUSH
27738: LD_INT 30
27740: PUSH
27741: LD_INT 32
27743: PUSH
27744: EMPTY
27745: LIST
27746: LIST
27747: PUSH
27748: LD_INT 30
27750: PUSH
27751: LD_INT 33
27753: PUSH
27754: EMPTY
27755: LIST
27756: LIST
27757: PUSH
27758: EMPTY
27759: LIST
27760: LIST
27761: LIST
27762: PPUSH
27763: CALL_OW 72
27767: IFFALSE 27855
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
27769: LD_ADDR_VAR 0 8
27773: PUSH
27774: LD_VAR 0 18
27778: PPUSH
27779: LD_INT 2
27781: PUSH
27782: LD_INT 30
27784: PUSH
27785: LD_INT 32
27787: PUSH
27788: EMPTY
27789: LIST
27790: LIST
27791: PUSH
27792: LD_INT 30
27794: PUSH
27795: LD_INT 33
27797: PUSH
27798: EMPTY
27799: LIST
27800: LIST
27801: PUSH
27802: EMPTY
27803: LIST
27804: LIST
27805: LIST
27806: PPUSH
27807: CALL_OW 72
27811: PUSH
27812: FOR_IN
27813: IFFALSE 27853
// begin if not GetBWeapon ( i ) then
27815: LD_VAR 0 8
27819: PPUSH
27820: CALL_OW 269
27824: NOT
27825: IFFALSE 27851
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
27827: LD_VAR 0 8
27831: PPUSH
27832: LD_VAR 0 8
27836: PPUSH
27837: LD_VAR 0 2
27841: PPUSH
27842: CALL 29101 0 2
27846: PPUSH
27847: CALL_OW 431
// end ;
27851: GO 27812
27853: POP
27854: POP
// end ; for i = 1 to personel do
27855: LD_ADDR_VAR 0 8
27859: PUSH
27860: DOUBLE
27861: LD_INT 1
27863: DEC
27864: ST_TO_ADDR
27865: LD_VAR 0 6
27869: PUSH
27870: FOR_TO
27871: IFFALSE 28935
// begin if i > 4 then
27873: LD_VAR 0 8
27877: PUSH
27878: LD_INT 4
27880: GREATER
27881: IFFALSE 27885
// break ;
27883: GO 28935
// case i of 1 :
27885: LD_VAR 0 8
27889: PUSH
27890: LD_INT 1
27892: DOUBLE
27893: EQUAL
27894: IFTRUE 27898
27896: GO 27978
27898: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
27899: LD_ADDR_VAR 0 12
27903: PUSH
27904: LD_VAR 0 18
27908: PPUSH
27909: LD_INT 22
27911: PUSH
27912: LD_VAR 0 16
27916: PUSH
27917: EMPTY
27918: LIST
27919: LIST
27920: PUSH
27921: LD_INT 58
27923: PUSH
27924: EMPTY
27925: LIST
27926: PUSH
27927: LD_INT 2
27929: PUSH
27930: LD_INT 30
27932: PUSH
27933: LD_INT 32
27935: PUSH
27936: EMPTY
27937: LIST
27938: LIST
27939: PUSH
27940: LD_INT 30
27942: PUSH
27943: LD_INT 4
27945: PUSH
27946: EMPTY
27947: LIST
27948: LIST
27949: PUSH
27950: LD_INT 30
27952: PUSH
27953: LD_INT 5
27955: PUSH
27956: EMPTY
27957: LIST
27958: LIST
27959: PUSH
27960: EMPTY
27961: LIST
27962: LIST
27963: LIST
27964: LIST
27965: PUSH
27966: EMPTY
27967: LIST
27968: LIST
27969: LIST
27970: PPUSH
27971: CALL_OW 72
27975: ST_TO_ADDR
27976: GO 28200
27978: LD_INT 2
27980: DOUBLE
27981: EQUAL
27982: IFTRUE 27986
27984: GO 28048
27986: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
27987: LD_ADDR_VAR 0 12
27991: PUSH
27992: LD_VAR 0 18
27996: PPUSH
27997: LD_INT 22
27999: PUSH
28000: LD_VAR 0 16
28004: PUSH
28005: EMPTY
28006: LIST
28007: LIST
28008: PUSH
28009: LD_INT 2
28011: PUSH
28012: LD_INT 30
28014: PUSH
28015: LD_INT 0
28017: PUSH
28018: EMPTY
28019: LIST
28020: LIST
28021: PUSH
28022: LD_INT 30
28024: PUSH
28025: LD_INT 1
28027: PUSH
28028: EMPTY
28029: LIST
28030: LIST
28031: PUSH
28032: EMPTY
28033: LIST
28034: LIST
28035: LIST
28036: PUSH
28037: EMPTY
28038: LIST
28039: LIST
28040: PPUSH
28041: CALL_OW 72
28045: ST_TO_ADDR
28046: GO 28200
28048: LD_INT 3
28050: DOUBLE
28051: EQUAL
28052: IFTRUE 28056
28054: GO 28118
28056: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
28057: LD_ADDR_VAR 0 12
28061: PUSH
28062: LD_VAR 0 18
28066: PPUSH
28067: LD_INT 22
28069: PUSH
28070: LD_VAR 0 16
28074: PUSH
28075: EMPTY
28076: LIST
28077: LIST
28078: PUSH
28079: LD_INT 2
28081: PUSH
28082: LD_INT 30
28084: PUSH
28085: LD_INT 2
28087: PUSH
28088: EMPTY
28089: LIST
28090: LIST
28091: PUSH
28092: LD_INT 30
28094: PUSH
28095: LD_INT 3
28097: PUSH
28098: EMPTY
28099: LIST
28100: LIST
28101: PUSH
28102: EMPTY
28103: LIST
28104: LIST
28105: LIST
28106: PUSH
28107: EMPTY
28108: LIST
28109: LIST
28110: PPUSH
28111: CALL_OW 72
28115: ST_TO_ADDR
28116: GO 28200
28118: LD_INT 4
28120: DOUBLE
28121: EQUAL
28122: IFTRUE 28126
28124: GO 28199
28126: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
28127: LD_ADDR_VAR 0 12
28131: PUSH
28132: LD_VAR 0 18
28136: PPUSH
28137: LD_INT 22
28139: PUSH
28140: LD_VAR 0 16
28144: PUSH
28145: EMPTY
28146: LIST
28147: LIST
28148: PUSH
28149: LD_INT 2
28151: PUSH
28152: LD_INT 30
28154: PUSH
28155: LD_INT 6
28157: PUSH
28158: EMPTY
28159: LIST
28160: LIST
28161: PUSH
28162: LD_INT 30
28164: PUSH
28165: LD_INT 7
28167: PUSH
28168: EMPTY
28169: LIST
28170: LIST
28171: PUSH
28172: LD_INT 30
28174: PUSH
28175: LD_INT 8
28177: PUSH
28178: EMPTY
28179: LIST
28180: LIST
28181: PUSH
28182: EMPTY
28183: LIST
28184: LIST
28185: LIST
28186: LIST
28187: PUSH
28188: EMPTY
28189: LIST
28190: LIST
28191: PPUSH
28192: CALL_OW 72
28196: ST_TO_ADDR
28197: GO 28200
28199: POP
// if i = 1 then
28200: LD_VAR 0 8
28204: PUSH
28205: LD_INT 1
28207: EQUAL
28208: IFFALSE 28319
// begin tmp := [ ] ;
28210: LD_ADDR_VAR 0 19
28214: PUSH
28215: EMPTY
28216: ST_TO_ADDR
// for j in f do
28217: LD_ADDR_VAR 0 9
28221: PUSH
28222: LD_VAR 0 12
28226: PUSH
28227: FOR_IN
28228: IFFALSE 28301
// if GetBType ( j ) = b_bunker then
28230: LD_VAR 0 9
28234: PPUSH
28235: CALL_OW 266
28239: PUSH
28240: LD_INT 32
28242: EQUAL
28243: IFFALSE 28270
// tmp := Insert ( tmp , 1 , j ) else
28245: LD_ADDR_VAR 0 19
28249: PUSH
28250: LD_VAR 0 19
28254: PPUSH
28255: LD_INT 1
28257: PPUSH
28258: LD_VAR 0 9
28262: PPUSH
28263: CALL_OW 2
28267: ST_TO_ADDR
28268: GO 28299
// tmp := Insert ( tmp , tmp + 1 , j ) ;
28270: LD_ADDR_VAR 0 19
28274: PUSH
28275: LD_VAR 0 19
28279: PPUSH
28280: LD_VAR 0 19
28284: PUSH
28285: LD_INT 1
28287: PLUS
28288: PPUSH
28289: LD_VAR 0 9
28293: PPUSH
28294: CALL_OW 2
28298: ST_TO_ADDR
28299: GO 28227
28301: POP
28302: POP
// if tmp then
28303: LD_VAR 0 19
28307: IFFALSE 28319
// f := tmp ;
28309: LD_ADDR_VAR 0 12
28313: PUSH
28314: LD_VAR 0 19
28318: ST_TO_ADDR
// end ; x := personel [ i ] ;
28319: LD_ADDR_VAR 0 13
28323: PUSH
28324: LD_VAR 0 6
28328: PUSH
28329: LD_VAR 0 8
28333: ARRAY
28334: ST_TO_ADDR
// if x = - 1 then
28335: LD_VAR 0 13
28339: PUSH
28340: LD_INT 1
28342: NEG
28343: EQUAL
28344: IFFALSE 28553
// begin for j in f do
28346: LD_ADDR_VAR 0 9
28350: PUSH
28351: LD_VAR 0 12
28355: PUSH
28356: FOR_IN
28357: IFFALSE 28549
// repeat InitHc ;
28359: CALL_OW 19
// if GetBType ( j ) = b_barracks then
28363: LD_VAR 0 9
28367: PPUSH
28368: CALL_OW 266
28372: PUSH
28373: LD_INT 5
28375: EQUAL
28376: IFFALSE 28446
// begin if UnitsInside ( j ) < 3 then
28378: LD_VAR 0 9
28382: PPUSH
28383: CALL_OW 313
28387: PUSH
28388: LD_INT 3
28390: LESS
28391: IFFALSE 28427
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
28393: LD_INT 0
28395: PPUSH
28396: LD_INT 5
28398: PUSH
28399: LD_INT 8
28401: PUSH
28402: LD_INT 9
28404: PUSH
28405: EMPTY
28406: LIST
28407: LIST
28408: LIST
28409: PUSH
28410: LD_VAR 0 17
28414: ARRAY
28415: PPUSH
28416: LD_VAR 0 4
28420: PPUSH
28421: CALL_OW 380
28425: GO 28444
// PrepareHuman ( false , i , skill ) ;
28427: LD_INT 0
28429: PPUSH
28430: LD_VAR 0 8
28434: PPUSH
28435: LD_VAR 0 4
28439: PPUSH
28440: CALL_OW 380
// end else
28444: GO 28463
// PrepareHuman ( false , i , skill ) ;
28446: LD_INT 0
28448: PPUSH
28449: LD_VAR 0 8
28453: PPUSH
28454: LD_VAR 0 4
28458: PPUSH
28459: CALL_OW 380
// un := CreateHuman ;
28463: LD_ADDR_VAR 0 14
28467: PUSH
28468: CALL_OW 44
28472: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
28473: LD_ADDR_VAR 0 7
28477: PUSH
28478: LD_VAR 0 7
28482: PPUSH
28483: LD_INT 1
28485: PPUSH
28486: LD_VAR 0 14
28490: PPUSH
28491: CALL_OW 2
28495: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
28496: LD_VAR 0 14
28500: PPUSH
28501: LD_VAR 0 9
28505: PPUSH
28506: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
28510: LD_VAR 0 9
28514: PPUSH
28515: CALL_OW 313
28519: PUSH
28520: LD_INT 6
28522: EQUAL
28523: PUSH
28524: LD_VAR 0 9
28528: PPUSH
28529: CALL_OW 266
28533: PUSH
28534: LD_INT 32
28536: PUSH
28537: LD_INT 31
28539: PUSH
28540: EMPTY
28541: LIST
28542: LIST
28543: IN
28544: OR
28545: IFFALSE 28359
28547: GO 28356
28549: POP
28550: POP
// end else
28551: GO 28933
// for j = 1 to x do
28553: LD_ADDR_VAR 0 9
28557: PUSH
28558: DOUBLE
28559: LD_INT 1
28561: DEC
28562: ST_TO_ADDR
28563: LD_VAR 0 13
28567: PUSH
28568: FOR_TO
28569: IFFALSE 28931
// begin InitHc ;
28571: CALL_OW 19
// if not f then
28575: LD_VAR 0 12
28579: NOT
28580: IFFALSE 28669
// begin PrepareHuman ( false , i , skill ) ;
28582: LD_INT 0
28584: PPUSH
28585: LD_VAR 0 8
28589: PPUSH
28590: LD_VAR 0 4
28594: PPUSH
28595: CALL_OW 380
// un := CreateHuman ;
28599: LD_ADDR_VAR 0 14
28603: PUSH
28604: CALL_OW 44
28608: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
28609: LD_ADDR_VAR 0 7
28613: PUSH
28614: LD_VAR 0 7
28618: PPUSH
28619: LD_INT 1
28621: PPUSH
28622: LD_VAR 0 14
28626: PPUSH
28627: CALL_OW 2
28631: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
28632: LD_VAR 0 14
28636: PPUSH
28637: LD_VAR 0 1
28641: PPUSH
28642: CALL_OW 250
28646: PPUSH
28647: LD_VAR 0 1
28651: PPUSH
28652: CALL_OW 251
28656: PPUSH
28657: LD_INT 10
28659: PPUSH
28660: LD_INT 0
28662: PPUSH
28663: CALL_OW 50
// continue ;
28667: GO 28568
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
28669: LD_VAR 0 12
28673: PUSH
28674: LD_INT 1
28676: ARRAY
28677: PPUSH
28678: CALL_OW 313
28682: PUSH
28683: LD_VAR 0 12
28687: PUSH
28688: LD_INT 1
28690: ARRAY
28691: PPUSH
28692: CALL_OW 266
28696: PUSH
28697: LD_INT 32
28699: PUSH
28700: LD_INT 31
28702: PUSH
28703: EMPTY
28704: LIST
28705: LIST
28706: IN
28707: AND
28708: PUSH
28709: LD_VAR 0 12
28713: PUSH
28714: LD_INT 1
28716: ARRAY
28717: PPUSH
28718: CALL_OW 313
28722: PUSH
28723: LD_INT 6
28725: EQUAL
28726: OR
28727: IFFALSE 28747
// f := Delete ( f , 1 ) ;
28729: LD_ADDR_VAR 0 12
28733: PUSH
28734: LD_VAR 0 12
28738: PPUSH
28739: LD_INT 1
28741: PPUSH
28742: CALL_OW 3
28746: ST_TO_ADDR
// if not f then
28747: LD_VAR 0 12
28751: NOT
28752: IFFALSE 28770
// begin x := x + 2 ;
28754: LD_ADDR_VAR 0 13
28758: PUSH
28759: LD_VAR 0 13
28763: PUSH
28764: LD_INT 2
28766: PLUS
28767: ST_TO_ADDR
// continue ;
28768: GO 28568
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
28770: LD_VAR 0 12
28774: PUSH
28775: LD_INT 1
28777: ARRAY
28778: PPUSH
28779: CALL_OW 266
28783: PUSH
28784: LD_INT 5
28786: EQUAL
28787: IFFALSE 28861
// begin if UnitsInside ( f [ 1 ] ) < 3 then
28789: LD_VAR 0 12
28793: PUSH
28794: LD_INT 1
28796: ARRAY
28797: PPUSH
28798: CALL_OW 313
28802: PUSH
28803: LD_INT 3
28805: LESS
28806: IFFALSE 28842
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
28808: LD_INT 0
28810: PPUSH
28811: LD_INT 5
28813: PUSH
28814: LD_INT 8
28816: PUSH
28817: LD_INT 9
28819: PUSH
28820: EMPTY
28821: LIST
28822: LIST
28823: LIST
28824: PUSH
28825: LD_VAR 0 17
28829: ARRAY
28830: PPUSH
28831: LD_VAR 0 4
28835: PPUSH
28836: CALL_OW 380
28840: GO 28859
// PrepareHuman ( false , i , skill ) ;
28842: LD_INT 0
28844: PPUSH
28845: LD_VAR 0 8
28849: PPUSH
28850: LD_VAR 0 4
28854: PPUSH
28855: CALL_OW 380
// end else
28859: GO 28878
// PrepareHuman ( false , i , skill ) ;
28861: LD_INT 0
28863: PPUSH
28864: LD_VAR 0 8
28868: PPUSH
28869: LD_VAR 0 4
28873: PPUSH
28874: CALL_OW 380
// un := CreateHuman ;
28878: LD_ADDR_VAR 0 14
28882: PUSH
28883: CALL_OW 44
28887: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
28888: LD_ADDR_VAR 0 7
28892: PUSH
28893: LD_VAR 0 7
28897: PPUSH
28898: LD_INT 1
28900: PPUSH
28901: LD_VAR 0 14
28905: PPUSH
28906: CALL_OW 2
28910: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
28911: LD_VAR 0 14
28915: PPUSH
28916: LD_VAR 0 12
28920: PUSH
28921: LD_INT 1
28923: ARRAY
28924: PPUSH
28925: CALL_OW 52
// end ;
28929: GO 28568
28931: POP
28932: POP
// end ;
28933: GO 27870
28935: POP
28936: POP
// result := result ^ buildings ;
28937: LD_ADDR_VAR 0 7
28941: PUSH
28942: LD_VAR 0 7
28946: PUSH
28947: LD_VAR 0 18
28951: ADD
28952: ST_TO_ADDR
// end else
28953: GO 29096
// begin for i = 1 to personel do
28955: LD_ADDR_VAR 0 8
28959: PUSH
28960: DOUBLE
28961: LD_INT 1
28963: DEC
28964: ST_TO_ADDR
28965: LD_VAR 0 6
28969: PUSH
28970: FOR_TO
28971: IFFALSE 29094
// begin if i > 4 then
28973: LD_VAR 0 8
28977: PUSH
28978: LD_INT 4
28980: GREATER
28981: IFFALSE 28985
// break ;
28983: GO 29094
// x := personel [ i ] ;
28985: LD_ADDR_VAR 0 13
28989: PUSH
28990: LD_VAR 0 6
28994: PUSH
28995: LD_VAR 0 8
28999: ARRAY
29000: ST_TO_ADDR
// if x = - 1 then
29001: LD_VAR 0 13
29005: PUSH
29006: LD_INT 1
29008: NEG
29009: EQUAL
29010: IFFALSE 29014
// continue ;
29012: GO 28970
// PrepareHuman ( false , i , skill ) ;
29014: LD_INT 0
29016: PPUSH
29017: LD_VAR 0 8
29021: PPUSH
29022: LD_VAR 0 4
29026: PPUSH
29027: CALL_OW 380
// un := CreateHuman ;
29031: LD_ADDR_VAR 0 14
29035: PUSH
29036: CALL_OW 44
29040: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
29041: LD_VAR 0 14
29045: PPUSH
29046: LD_VAR 0 1
29050: PPUSH
29051: CALL_OW 250
29055: PPUSH
29056: LD_VAR 0 1
29060: PPUSH
29061: CALL_OW 251
29065: PPUSH
29066: LD_INT 10
29068: PPUSH
29069: LD_INT 0
29071: PPUSH
29072: CALL_OW 50
// result := result ^ un ;
29076: LD_ADDR_VAR 0 7
29080: PUSH
29081: LD_VAR 0 7
29085: PUSH
29086: LD_VAR 0 14
29090: ADD
29091: ST_TO_ADDR
// end ;
29092: GO 28970
29094: POP
29095: POP
// end ; end ;
29096: LD_VAR 0 7
29100: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
29101: LD_INT 0
29103: PPUSH
29104: PPUSH
29105: PPUSH
29106: PPUSH
29107: PPUSH
29108: PPUSH
29109: PPUSH
29110: PPUSH
29111: PPUSH
29112: PPUSH
29113: PPUSH
29114: PPUSH
29115: PPUSH
29116: PPUSH
29117: PPUSH
29118: PPUSH
// result := false ;
29119: LD_ADDR_VAR 0 3
29123: PUSH
29124: LD_INT 0
29126: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
29127: LD_VAR 0 1
29131: NOT
29132: PUSH
29133: LD_VAR 0 1
29137: PPUSH
29138: CALL_OW 266
29142: PUSH
29143: LD_INT 32
29145: PUSH
29146: LD_INT 33
29148: PUSH
29149: EMPTY
29150: LIST
29151: LIST
29152: IN
29153: NOT
29154: OR
29155: IFFALSE 29159
// exit ;
29157: GO 30298
// nat := GetNation ( tower ) ;
29159: LD_ADDR_VAR 0 12
29163: PUSH
29164: LD_VAR 0 1
29168: PPUSH
29169: CALL_OW 248
29173: ST_TO_ADDR
// side := GetSide ( tower ) ;
29174: LD_ADDR_VAR 0 16
29178: PUSH
29179: LD_VAR 0 1
29183: PPUSH
29184: CALL_OW 255
29188: ST_TO_ADDR
// x := GetX ( tower ) ;
29189: LD_ADDR_VAR 0 10
29193: PUSH
29194: LD_VAR 0 1
29198: PPUSH
29199: CALL_OW 250
29203: ST_TO_ADDR
// y := GetY ( tower ) ;
29204: LD_ADDR_VAR 0 11
29208: PUSH
29209: LD_VAR 0 1
29213: PPUSH
29214: CALL_OW 251
29218: ST_TO_ADDR
// if not x or not y then
29219: LD_VAR 0 10
29223: NOT
29224: PUSH
29225: LD_VAR 0 11
29229: NOT
29230: OR
29231: IFFALSE 29235
// exit ;
29233: GO 30298
// weapon := 0 ;
29235: LD_ADDR_VAR 0 18
29239: PUSH
29240: LD_INT 0
29242: ST_TO_ADDR
// fac_list := [ ] ;
29243: LD_ADDR_VAR 0 17
29247: PUSH
29248: EMPTY
29249: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
29250: LD_ADDR_VAR 0 6
29254: PUSH
29255: LD_VAR 0 1
29259: PPUSH
29260: CALL_OW 274
29264: PPUSH
29265: LD_VAR 0 2
29269: PPUSH
29270: LD_INT 0
29272: PPUSH
29273: CALL 26838 0 3
29277: PPUSH
29278: LD_INT 30
29280: PUSH
29281: LD_INT 3
29283: PUSH
29284: EMPTY
29285: LIST
29286: LIST
29287: PPUSH
29288: CALL_OW 72
29292: ST_TO_ADDR
// if not factories then
29293: LD_VAR 0 6
29297: NOT
29298: IFFALSE 29302
// exit ;
29300: GO 30298
// for i in factories do
29302: LD_ADDR_VAR 0 8
29306: PUSH
29307: LD_VAR 0 6
29311: PUSH
29312: FOR_IN
29313: IFFALSE 29338
// fac_list := fac_list union AvailableWeaponList ( i ) ;
29315: LD_ADDR_VAR 0 17
29319: PUSH
29320: LD_VAR 0 17
29324: PUSH
29325: LD_VAR 0 8
29329: PPUSH
29330: CALL_OW 478
29334: UNION
29335: ST_TO_ADDR
29336: GO 29312
29338: POP
29339: POP
// if not fac_list then
29340: LD_VAR 0 17
29344: NOT
29345: IFFALSE 29349
// exit ;
29347: GO 30298
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
29349: LD_ADDR_VAR 0 5
29353: PUSH
29354: LD_INT 4
29356: PUSH
29357: LD_INT 5
29359: PUSH
29360: LD_INT 9
29362: PUSH
29363: LD_INT 10
29365: PUSH
29366: LD_INT 6
29368: PUSH
29369: LD_INT 7
29371: PUSH
29372: LD_INT 11
29374: PUSH
29375: EMPTY
29376: LIST
29377: LIST
29378: LIST
29379: LIST
29380: LIST
29381: LIST
29382: LIST
29383: PUSH
29384: LD_INT 27
29386: PUSH
29387: LD_INT 28
29389: PUSH
29390: LD_INT 26
29392: PUSH
29393: LD_INT 30
29395: PUSH
29396: EMPTY
29397: LIST
29398: LIST
29399: LIST
29400: LIST
29401: PUSH
29402: LD_INT 43
29404: PUSH
29405: LD_INT 44
29407: PUSH
29408: LD_INT 46
29410: PUSH
29411: LD_INT 45
29413: PUSH
29414: LD_INT 47
29416: PUSH
29417: LD_INT 49
29419: PUSH
29420: EMPTY
29421: LIST
29422: LIST
29423: LIST
29424: LIST
29425: LIST
29426: LIST
29427: PUSH
29428: EMPTY
29429: LIST
29430: LIST
29431: LIST
29432: PUSH
29433: LD_VAR 0 12
29437: ARRAY
29438: ST_TO_ADDR
// for i in list do
29439: LD_ADDR_VAR 0 8
29443: PUSH
29444: LD_VAR 0 5
29448: PUSH
29449: FOR_IN
29450: IFFALSE 29483
// if not i in fac_list then
29452: LD_VAR 0 8
29456: PUSH
29457: LD_VAR 0 17
29461: IN
29462: NOT
29463: IFFALSE 29481
// list := list diff i ;
29465: LD_ADDR_VAR 0 5
29469: PUSH
29470: LD_VAR 0 5
29474: PUSH
29475: LD_VAR 0 8
29479: DIFF
29480: ST_TO_ADDR
29481: GO 29449
29483: POP
29484: POP
// if not list then
29485: LD_VAR 0 5
29489: NOT
29490: IFFALSE 29494
// exit ;
29492: GO 30298
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
29494: LD_VAR 0 12
29498: PUSH
29499: LD_INT 3
29501: EQUAL
29502: PUSH
29503: LD_INT 49
29505: PUSH
29506: LD_VAR 0 5
29510: IN
29511: AND
29512: PUSH
29513: LD_INT 31
29515: PPUSH
29516: LD_VAR 0 16
29520: PPUSH
29521: CALL_OW 321
29525: PUSH
29526: LD_INT 2
29528: EQUAL
29529: AND
29530: IFFALSE 29590
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
29532: LD_INT 22
29534: PUSH
29535: LD_VAR 0 16
29539: PUSH
29540: EMPTY
29541: LIST
29542: LIST
29543: PUSH
29544: LD_INT 35
29546: PUSH
29547: LD_INT 49
29549: PUSH
29550: EMPTY
29551: LIST
29552: LIST
29553: PUSH
29554: LD_INT 91
29556: PUSH
29557: LD_VAR 0 1
29561: PUSH
29562: LD_INT 10
29564: PUSH
29565: EMPTY
29566: LIST
29567: LIST
29568: LIST
29569: PUSH
29570: EMPTY
29571: LIST
29572: LIST
29573: LIST
29574: PPUSH
29575: CALL_OW 69
29579: NOT
29580: IFFALSE 29590
// weapon := ru_time_lapser ;
29582: LD_ADDR_VAR 0 18
29586: PUSH
29587: LD_INT 49
29589: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
29590: LD_VAR 0 12
29594: PUSH
29595: LD_INT 1
29597: PUSH
29598: LD_INT 2
29600: PUSH
29601: EMPTY
29602: LIST
29603: LIST
29604: IN
29605: PUSH
29606: LD_INT 11
29608: PUSH
29609: LD_VAR 0 5
29613: IN
29614: PUSH
29615: LD_INT 30
29617: PUSH
29618: LD_VAR 0 5
29622: IN
29623: OR
29624: AND
29625: PUSH
29626: LD_INT 6
29628: PPUSH
29629: LD_VAR 0 16
29633: PPUSH
29634: CALL_OW 321
29638: PUSH
29639: LD_INT 2
29641: EQUAL
29642: AND
29643: IFFALSE 29808
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
29645: LD_INT 22
29647: PUSH
29648: LD_VAR 0 16
29652: PUSH
29653: EMPTY
29654: LIST
29655: LIST
29656: PUSH
29657: LD_INT 2
29659: PUSH
29660: LD_INT 35
29662: PUSH
29663: LD_INT 11
29665: PUSH
29666: EMPTY
29667: LIST
29668: LIST
29669: PUSH
29670: LD_INT 35
29672: PUSH
29673: LD_INT 30
29675: PUSH
29676: EMPTY
29677: LIST
29678: LIST
29679: PUSH
29680: EMPTY
29681: LIST
29682: LIST
29683: LIST
29684: PUSH
29685: LD_INT 91
29687: PUSH
29688: LD_VAR 0 1
29692: PUSH
29693: LD_INT 18
29695: PUSH
29696: EMPTY
29697: LIST
29698: LIST
29699: LIST
29700: PUSH
29701: EMPTY
29702: LIST
29703: LIST
29704: LIST
29705: PPUSH
29706: CALL_OW 69
29710: NOT
29711: PUSH
29712: LD_INT 22
29714: PUSH
29715: LD_VAR 0 16
29719: PUSH
29720: EMPTY
29721: LIST
29722: LIST
29723: PUSH
29724: LD_INT 2
29726: PUSH
29727: LD_INT 30
29729: PUSH
29730: LD_INT 32
29732: PUSH
29733: EMPTY
29734: LIST
29735: LIST
29736: PUSH
29737: LD_INT 30
29739: PUSH
29740: LD_INT 33
29742: PUSH
29743: EMPTY
29744: LIST
29745: LIST
29746: PUSH
29747: EMPTY
29748: LIST
29749: LIST
29750: LIST
29751: PUSH
29752: LD_INT 91
29754: PUSH
29755: LD_VAR 0 1
29759: PUSH
29760: LD_INT 12
29762: PUSH
29763: EMPTY
29764: LIST
29765: LIST
29766: LIST
29767: PUSH
29768: EMPTY
29769: LIST
29770: LIST
29771: LIST
29772: PUSH
29773: EMPTY
29774: LIST
29775: PPUSH
29776: CALL_OW 69
29780: PUSH
29781: LD_INT 2
29783: GREATER
29784: AND
29785: IFFALSE 29808
// weapon := [ us_radar , ar_radar ] [ nat ] ;
29787: LD_ADDR_VAR 0 18
29791: PUSH
29792: LD_INT 11
29794: PUSH
29795: LD_INT 30
29797: PUSH
29798: EMPTY
29799: LIST
29800: LIST
29801: PUSH
29802: LD_VAR 0 12
29806: ARRAY
29807: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
29808: LD_VAR 0 18
29812: NOT
29813: PUSH
29814: LD_INT 40
29816: PPUSH
29817: LD_VAR 0 16
29821: PPUSH
29822: CALL_OW 321
29826: PUSH
29827: LD_INT 2
29829: EQUAL
29830: AND
29831: PUSH
29832: LD_INT 7
29834: PUSH
29835: LD_VAR 0 5
29839: IN
29840: PUSH
29841: LD_INT 28
29843: PUSH
29844: LD_VAR 0 5
29848: IN
29849: OR
29850: PUSH
29851: LD_INT 45
29853: PUSH
29854: LD_VAR 0 5
29858: IN
29859: OR
29860: AND
29861: IFFALSE 30115
// begin hex := GetHexInfo ( x , y ) ;
29863: LD_ADDR_VAR 0 4
29867: PUSH
29868: LD_VAR 0 10
29872: PPUSH
29873: LD_VAR 0 11
29877: PPUSH
29878: CALL_OW 546
29882: ST_TO_ADDR
// if hex [ 1 ] then
29883: LD_VAR 0 4
29887: PUSH
29888: LD_INT 1
29890: ARRAY
29891: IFFALSE 29895
// exit ;
29893: GO 30298
// height := hex [ 2 ] ;
29895: LD_ADDR_VAR 0 15
29899: PUSH
29900: LD_VAR 0 4
29904: PUSH
29905: LD_INT 2
29907: ARRAY
29908: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
29909: LD_ADDR_VAR 0 14
29913: PUSH
29914: LD_INT 0
29916: PUSH
29917: LD_INT 2
29919: PUSH
29920: LD_INT 3
29922: PUSH
29923: LD_INT 5
29925: PUSH
29926: EMPTY
29927: LIST
29928: LIST
29929: LIST
29930: LIST
29931: ST_TO_ADDR
// for i in tmp do
29932: LD_ADDR_VAR 0 8
29936: PUSH
29937: LD_VAR 0 14
29941: PUSH
29942: FOR_IN
29943: IFFALSE 30113
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
29945: LD_ADDR_VAR 0 9
29949: PUSH
29950: LD_VAR 0 10
29954: PPUSH
29955: LD_VAR 0 8
29959: PPUSH
29960: LD_INT 5
29962: PPUSH
29963: CALL_OW 272
29967: PUSH
29968: LD_VAR 0 11
29972: PPUSH
29973: LD_VAR 0 8
29977: PPUSH
29978: LD_INT 5
29980: PPUSH
29981: CALL_OW 273
29985: PUSH
29986: EMPTY
29987: LIST
29988: LIST
29989: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
29990: LD_VAR 0 9
29994: PUSH
29995: LD_INT 1
29997: ARRAY
29998: PPUSH
29999: LD_VAR 0 9
30003: PUSH
30004: LD_INT 2
30006: ARRAY
30007: PPUSH
30008: CALL_OW 488
30012: IFFALSE 30111
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
30014: LD_ADDR_VAR 0 4
30018: PUSH
30019: LD_VAR 0 9
30023: PUSH
30024: LD_INT 1
30026: ARRAY
30027: PPUSH
30028: LD_VAR 0 9
30032: PUSH
30033: LD_INT 2
30035: ARRAY
30036: PPUSH
30037: CALL_OW 546
30041: ST_TO_ADDR
// if hex [ 1 ] then
30042: LD_VAR 0 4
30046: PUSH
30047: LD_INT 1
30049: ARRAY
30050: IFFALSE 30054
// continue ;
30052: GO 29942
// h := hex [ 2 ] ;
30054: LD_ADDR_VAR 0 13
30058: PUSH
30059: LD_VAR 0 4
30063: PUSH
30064: LD_INT 2
30066: ARRAY
30067: ST_TO_ADDR
// if h + 7 < height then
30068: LD_VAR 0 13
30072: PUSH
30073: LD_INT 7
30075: PLUS
30076: PUSH
30077: LD_VAR 0 15
30081: LESS
30082: IFFALSE 30111
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
30084: LD_ADDR_VAR 0 18
30088: PUSH
30089: LD_INT 7
30091: PUSH
30092: LD_INT 28
30094: PUSH
30095: LD_INT 45
30097: PUSH
30098: EMPTY
30099: LIST
30100: LIST
30101: LIST
30102: PUSH
30103: LD_VAR 0 12
30107: ARRAY
30108: ST_TO_ADDR
// break ;
30109: GO 30113
// end ; end ; end ;
30111: GO 29942
30113: POP
30114: POP
// end ; if not weapon then
30115: LD_VAR 0 18
30119: NOT
30120: IFFALSE 30180
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
30122: LD_ADDR_VAR 0 5
30126: PUSH
30127: LD_VAR 0 5
30131: PUSH
30132: LD_INT 11
30134: PUSH
30135: LD_INT 30
30137: PUSH
30138: LD_INT 49
30140: PUSH
30141: EMPTY
30142: LIST
30143: LIST
30144: LIST
30145: DIFF
30146: ST_TO_ADDR
// if not list then
30147: LD_VAR 0 5
30151: NOT
30152: IFFALSE 30156
// exit ;
30154: GO 30298
// weapon := list [ rand ( 1 , list ) ] ;
30156: LD_ADDR_VAR 0 18
30160: PUSH
30161: LD_VAR 0 5
30165: PUSH
30166: LD_INT 1
30168: PPUSH
30169: LD_VAR 0 5
30173: PPUSH
30174: CALL_OW 12
30178: ARRAY
30179: ST_TO_ADDR
// end ; if weapon then
30180: LD_VAR 0 18
30184: IFFALSE 30298
// begin tmp := CostOfWeapon ( weapon ) ;
30186: LD_ADDR_VAR 0 14
30190: PUSH
30191: LD_VAR 0 18
30195: PPUSH
30196: CALL_OW 451
30200: ST_TO_ADDR
// j := GetBase ( tower ) ;
30201: LD_ADDR_VAR 0 9
30205: PUSH
30206: LD_VAR 0 1
30210: PPUSH
30211: CALL_OW 274
30215: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
30216: LD_VAR 0 9
30220: PPUSH
30221: LD_INT 1
30223: PPUSH
30224: CALL_OW 275
30228: PUSH
30229: LD_VAR 0 14
30233: PUSH
30234: LD_INT 1
30236: ARRAY
30237: GREATEREQUAL
30238: PUSH
30239: LD_VAR 0 9
30243: PPUSH
30244: LD_INT 2
30246: PPUSH
30247: CALL_OW 275
30251: PUSH
30252: LD_VAR 0 14
30256: PUSH
30257: LD_INT 2
30259: ARRAY
30260: GREATEREQUAL
30261: AND
30262: PUSH
30263: LD_VAR 0 9
30267: PPUSH
30268: LD_INT 3
30270: PPUSH
30271: CALL_OW 275
30275: PUSH
30276: LD_VAR 0 14
30280: PUSH
30281: LD_INT 3
30283: ARRAY
30284: GREATEREQUAL
30285: AND
30286: IFFALSE 30298
// result := weapon ;
30288: LD_ADDR_VAR 0 3
30292: PUSH
30293: LD_VAR 0 18
30297: ST_TO_ADDR
// end ; end ;
30298: LD_VAR 0 3
30302: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
30303: LD_INT 0
30305: PPUSH
30306: PPUSH
// result := true ;
30307: LD_ADDR_VAR 0 3
30311: PUSH
30312: LD_INT 1
30314: ST_TO_ADDR
// if array1 = array2 then
30315: LD_VAR 0 1
30319: PUSH
30320: LD_VAR 0 2
30324: EQUAL
30325: IFFALSE 30385
// begin for i = 1 to array1 do
30327: LD_ADDR_VAR 0 4
30331: PUSH
30332: DOUBLE
30333: LD_INT 1
30335: DEC
30336: ST_TO_ADDR
30337: LD_VAR 0 1
30341: PUSH
30342: FOR_TO
30343: IFFALSE 30381
// if array1 [ i ] <> array2 [ i ] then
30345: LD_VAR 0 1
30349: PUSH
30350: LD_VAR 0 4
30354: ARRAY
30355: PUSH
30356: LD_VAR 0 2
30360: PUSH
30361: LD_VAR 0 4
30365: ARRAY
30366: NONEQUAL
30367: IFFALSE 30379
// begin result := false ;
30369: LD_ADDR_VAR 0 3
30373: PUSH
30374: LD_INT 0
30376: ST_TO_ADDR
// break ;
30377: GO 30381
// end ;
30379: GO 30342
30381: POP
30382: POP
// end else
30383: GO 30393
// result := false ;
30385: LD_ADDR_VAR 0 3
30389: PUSH
30390: LD_INT 0
30392: ST_TO_ADDR
// end ;
30393: LD_VAR 0 3
30397: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
30398: LD_INT 0
30400: PPUSH
30401: PPUSH
// if not array1 or not array2 then
30402: LD_VAR 0 1
30406: NOT
30407: PUSH
30408: LD_VAR 0 2
30412: NOT
30413: OR
30414: IFFALSE 30418
// exit ;
30416: GO 30482
// result := true ;
30418: LD_ADDR_VAR 0 3
30422: PUSH
30423: LD_INT 1
30425: ST_TO_ADDR
// for i = 1 to array1 do
30426: LD_ADDR_VAR 0 4
30430: PUSH
30431: DOUBLE
30432: LD_INT 1
30434: DEC
30435: ST_TO_ADDR
30436: LD_VAR 0 1
30440: PUSH
30441: FOR_TO
30442: IFFALSE 30480
// if array1 [ i ] <> array2 [ i ] then
30444: LD_VAR 0 1
30448: PUSH
30449: LD_VAR 0 4
30453: ARRAY
30454: PUSH
30455: LD_VAR 0 2
30459: PUSH
30460: LD_VAR 0 4
30464: ARRAY
30465: NONEQUAL
30466: IFFALSE 30478
// begin result := false ;
30468: LD_ADDR_VAR 0 3
30472: PUSH
30473: LD_INT 0
30475: ST_TO_ADDR
// break ;
30476: GO 30480
// end ;
30478: GO 30441
30480: POP
30481: POP
// end ;
30482: LD_VAR 0 3
30486: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
30487: LD_INT 0
30489: PPUSH
30490: PPUSH
30491: PPUSH
// pom := GetBase ( fac ) ;
30492: LD_ADDR_VAR 0 5
30496: PUSH
30497: LD_VAR 0 1
30501: PPUSH
30502: CALL_OW 274
30506: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
30507: LD_ADDR_VAR 0 4
30511: PUSH
30512: LD_VAR 0 2
30516: PUSH
30517: LD_INT 1
30519: ARRAY
30520: PPUSH
30521: LD_VAR 0 2
30525: PUSH
30526: LD_INT 2
30528: ARRAY
30529: PPUSH
30530: LD_VAR 0 2
30534: PUSH
30535: LD_INT 3
30537: ARRAY
30538: PPUSH
30539: LD_VAR 0 2
30543: PUSH
30544: LD_INT 4
30546: ARRAY
30547: PPUSH
30548: CALL_OW 449
30552: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
30553: LD_ADDR_VAR 0 3
30557: PUSH
30558: LD_VAR 0 5
30562: PPUSH
30563: LD_INT 1
30565: PPUSH
30566: CALL_OW 275
30570: PUSH
30571: LD_VAR 0 4
30575: PUSH
30576: LD_INT 1
30578: ARRAY
30579: GREATEREQUAL
30580: PUSH
30581: LD_VAR 0 5
30585: PPUSH
30586: LD_INT 2
30588: PPUSH
30589: CALL_OW 275
30593: PUSH
30594: LD_VAR 0 4
30598: PUSH
30599: LD_INT 2
30601: ARRAY
30602: GREATEREQUAL
30603: AND
30604: PUSH
30605: LD_VAR 0 5
30609: PPUSH
30610: LD_INT 3
30612: PPUSH
30613: CALL_OW 275
30617: PUSH
30618: LD_VAR 0 4
30622: PUSH
30623: LD_INT 3
30625: ARRAY
30626: GREATEREQUAL
30627: AND
30628: ST_TO_ADDR
// end ;
30629: LD_VAR 0 3
30633: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
30634: LD_INT 0
30636: PPUSH
30637: PPUSH
30638: PPUSH
30639: PPUSH
// pom := GetBase ( building ) ;
30640: LD_ADDR_VAR 0 3
30644: PUSH
30645: LD_VAR 0 1
30649: PPUSH
30650: CALL_OW 274
30654: ST_TO_ADDR
// if not pom then
30655: LD_VAR 0 3
30659: NOT
30660: IFFALSE 30664
// exit ;
30662: GO 30834
// btype := GetBType ( building ) ;
30664: LD_ADDR_VAR 0 5
30668: PUSH
30669: LD_VAR 0 1
30673: PPUSH
30674: CALL_OW 266
30678: ST_TO_ADDR
// if btype = b_armoury then
30679: LD_VAR 0 5
30683: PUSH
30684: LD_INT 4
30686: EQUAL
30687: IFFALSE 30697
// btype := b_barracks ;
30689: LD_ADDR_VAR 0 5
30693: PUSH
30694: LD_INT 5
30696: ST_TO_ADDR
// if btype = b_depot then
30697: LD_VAR 0 5
30701: PUSH
30702: LD_INT 0
30704: EQUAL
30705: IFFALSE 30715
// btype := b_warehouse ;
30707: LD_ADDR_VAR 0 5
30711: PUSH
30712: LD_INT 1
30714: ST_TO_ADDR
// if btype = b_workshop then
30715: LD_VAR 0 5
30719: PUSH
30720: LD_INT 2
30722: EQUAL
30723: IFFALSE 30733
// btype := b_factory ;
30725: LD_ADDR_VAR 0 5
30729: PUSH
30730: LD_INT 3
30732: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
30733: LD_ADDR_VAR 0 4
30737: PUSH
30738: LD_VAR 0 5
30742: PPUSH
30743: LD_VAR 0 1
30747: PPUSH
30748: CALL_OW 248
30752: PPUSH
30753: CALL_OW 450
30757: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
30758: LD_ADDR_VAR 0 2
30762: PUSH
30763: LD_VAR 0 3
30767: PPUSH
30768: LD_INT 1
30770: PPUSH
30771: CALL_OW 275
30775: PUSH
30776: LD_VAR 0 4
30780: PUSH
30781: LD_INT 1
30783: ARRAY
30784: GREATEREQUAL
30785: PUSH
30786: LD_VAR 0 3
30790: PPUSH
30791: LD_INT 2
30793: PPUSH
30794: CALL_OW 275
30798: PUSH
30799: LD_VAR 0 4
30803: PUSH
30804: LD_INT 2
30806: ARRAY
30807: GREATEREQUAL
30808: AND
30809: PUSH
30810: LD_VAR 0 3
30814: PPUSH
30815: LD_INT 3
30817: PPUSH
30818: CALL_OW 275
30822: PUSH
30823: LD_VAR 0 4
30827: PUSH
30828: LD_INT 3
30830: ARRAY
30831: GREATEREQUAL
30832: AND
30833: ST_TO_ADDR
// end ;
30834: LD_VAR 0 2
30838: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
30839: LD_INT 0
30841: PPUSH
30842: PPUSH
30843: PPUSH
// pom := GetBase ( building ) ;
30844: LD_ADDR_VAR 0 4
30848: PUSH
30849: LD_VAR 0 1
30853: PPUSH
30854: CALL_OW 274
30858: ST_TO_ADDR
// if not pom then
30859: LD_VAR 0 4
30863: NOT
30864: IFFALSE 30868
// exit ;
30866: GO 30969
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
30868: LD_ADDR_VAR 0 5
30872: PUSH
30873: LD_VAR 0 2
30877: PPUSH
30878: LD_VAR 0 1
30882: PPUSH
30883: CALL_OW 248
30887: PPUSH
30888: CALL_OW 450
30892: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
30893: LD_ADDR_VAR 0 3
30897: PUSH
30898: LD_VAR 0 4
30902: PPUSH
30903: LD_INT 1
30905: PPUSH
30906: CALL_OW 275
30910: PUSH
30911: LD_VAR 0 5
30915: PUSH
30916: LD_INT 1
30918: ARRAY
30919: GREATEREQUAL
30920: PUSH
30921: LD_VAR 0 4
30925: PPUSH
30926: LD_INT 2
30928: PPUSH
30929: CALL_OW 275
30933: PUSH
30934: LD_VAR 0 5
30938: PUSH
30939: LD_INT 2
30941: ARRAY
30942: GREATEREQUAL
30943: AND
30944: PUSH
30945: LD_VAR 0 4
30949: PPUSH
30950: LD_INT 3
30952: PPUSH
30953: CALL_OW 275
30957: PUSH
30958: LD_VAR 0 5
30962: PUSH
30963: LD_INT 3
30965: ARRAY
30966: GREATEREQUAL
30967: AND
30968: ST_TO_ADDR
// end ;
30969: LD_VAR 0 3
30973: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
30974: LD_INT 0
30976: PPUSH
30977: PPUSH
30978: PPUSH
30979: PPUSH
30980: PPUSH
30981: PPUSH
30982: PPUSH
30983: PPUSH
30984: PPUSH
30985: PPUSH
30986: PPUSH
// result := false ;
30987: LD_ADDR_VAR 0 8
30991: PUSH
30992: LD_INT 0
30994: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
30995: LD_VAR 0 5
30999: NOT
31000: PUSH
31001: LD_VAR 0 1
31005: NOT
31006: OR
31007: PUSH
31008: LD_VAR 0 2
31012: NOT
31013: OR
31014: PUSH
31015: LD_VAR 0 3
31019: NOT
31020: OR
31021: IFFALSE 31025
// exit ;
31023: GO 31839
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
31025: LD_ADDR_VAR 0 14
31029: PUSH
31030: LD_VAR 0 1
31034: PPUSH
31035: LD_VAR 0 2
31039: PPUSH
31040: LD_VAR 0 3
31044: PPUSH
31045: LD_VAR 0 4
31049: PPUSH
31050: LD_VAR 0 5
31054: PUSH
31055: LD_INT 1
31057: ARRAY
31058: PPUSH
31059: CALL_OW 248
31063: PPUSH
31064: LD_INT 0
31066: PPUSH
31067: CALL 32676 0 6
31071: ST_TO_ADDR
// if not hexes then
31072: LD_VAR 0 14
31076: NOT
31077: IFFALSE 31081
// exit ;
31079: GO 31839
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
31081: LD_ADDR_VAR 0 17
31085: PUSH
31086: LD_VAR 0 5
31090: PPUSH
31091: LD_INT 22
31093: PUSH
31094: LD_VAR 0 13
31098: PPUSH
31099: CALL_OW 255
31103: PUSH
31104: EMPTY
31105: LIST
31106: LIST
31107: PUSH
31108: LD_INT 2
31110: PUSH
31111: LD_INT 30
31113: PUSH
31114: LD_INT 0
31116: PUSH
31117: EMPTY
31118: LIST
31119: LIST
31120: PUSH
31121: LD_INT 30
31123: PUSH
31124: LD_INT 1
31126: PUSH
31127: EMPTY
31128: LIST
31129: LIST
31130: PUSH
31131: EMPTY
31132: LIST
31133: LIST
31134: LIST
31135: PUSH
31136: EMPTY
31137: LIST
31138: LIST
31139: PPUSH
31140: CALL_OW 72
31144: ST_TO_ADDR
// for i = 1 to hexes do
31145: LD_ADDR_VAR 0 9
31149: PUSH
31150: DOUBLE
31151: LD_INT 1
31153: DEC
31154: ST_TO_ADDR
31155: LD_VAR 0 14
31159: PUSH
31160: FOR_TO
31161: IFFALSE 31837
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
31163: LD_ADDR_VAR 0 13
31167: PUSH
31168: LD_VAR 0 14
31172: PUSH
31173: LD_VAR 0 9
31177: ARRAY
31178: PUSH
31179: LD_INT 1
31181: ARRAY
31182: PPUSH
31183: LD_VAR 0 14
31187: PUSH
31188: LD_VAR 0 9
31192: ARRAY
31193: PUSH
31194: LD_INT 2
31196: ARRAY
31197: PPUSH
31198: CALL_OW 428
31202: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
31203: LD_VAR 0 14
31207: PUSH
31208: LD_VAR 0 9
31212: ARRAY
31213: PUSH
31214: LD_INT 1
31216: ARRAY
31217: PPUSH
31218: LD_VAR 0 14
31222: PUSH
31223: LD_VAR 0 9
31227: ARRAY
31228: PUSH
31229: LD_INT 2
31231: ARRAY
31232: PPUSH
31233: CALL_OW 351
31237: PUSH
31238: LD_VAR 0 14
31242: PUSH
31243: LD_VAR 0 9
31247: ARRAY
31248: PUSH
31249: LD_INT 1
31251: ARRAY
31252: PPUSH
31253: LD_VAR 0 14
31257: PUSH
31258: LD_VAR 0 9
31262: ARRAY
31263: PUSH
31264: LD_INT 2
31266: ARRAY
31267: PPUSH
31268: CALL_OW 488
31272: NOT
31273: OR
31274: PUSH
31275: LD_VAR 0 13
31279: PPUSH
31280: CALL_OW 247
31284: PUSH
31285: LD_INT 3
31287: EQUAL
31288: OR
31289: IFFALSE 31295
// exit ;
31291: POP
31292: POP
31293: GO 31839
// if not tmp then
31295: LD_VAR 0 13
31299: NOT
31300: IFFALSE 31304
// continue ;
31302: GO 31160
// result := true ;
31304: LD_ADDR_VAR 0 8
31308: PUSH
31309: LD_INT 1
31311: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
31312: LD_VAR 0 6
31316: PUSH
31317: LD_VAR 0 13
31321: PPUSH
31322: CALL_OW 247
31326: PUSH
31327: LD_INT 2
31329: EQUAL
31330: AND
31331: PUSH
31332: LD_VAR 0 13
31336: PPUSH
31337: CALL_OW 263
31341: PUSH
31342: LD_INT 1
31344: EQUAL
31345: AND
31346: IFFALSE 31510
// begin if IsDrivenBy ( tmp ) then
31348: LD_VAR 0 13
31352: PPUSH
31353: CALL_OW 311
31357: IFFALSE 31361
// continue ;
31359: GO 31160
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
31361: LD_VAR 0 6
31365: PPUSH
31366: LD_INT 3
31368: PUSH
31369: LD_INT 60
31371: PUSH
31372: EMPTY
31373: LIST
31374: PUSH
31375: EMPTY
31376: LIST
31377: LIST
31378: PUSH
31379: LD_INT 3
31381: PUSH
31382: LD_INT 55
31384: PUSH
31385: EMPTY
31386: LIST
31387: PUSH
31388: EMPTY
31389: LIST
31390: LIST
31391: PUSH
31392: EMPTY
31393: LIST
31394: LIST
31395: PPUSH
31396: CALL_OW 72
31400: IFFALSE 31508
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
31402: LD_ADDR_VAR 0 18
31406: PUSH
31407: LD_VAR 0 6
31411: PPUSH
31412: LD_INT 3
31414: PUSH
31415: LD_INT 60
31417: PUSH
31418: EMPTY
31419: LIST
31420: PUSH
31421: EMPTY
31422: LIST
31423: LIST
31424: PUSH
31425: LD_INT 3
31427: PUSH
31428: LD_INT 55
31430: PUSH
31431: EMPTY
31432: LIST
31433: PUSH
31434: EMPTY
31435: LIST
31436: LIST
31437: PUSH
31438: EMPTY
31439: LIST
31440: LIST
31441: PPUSH
31442: CALL_OW 72
31446: PUSH
31447: LD_INT 1
31449: ARRAY
31450: ST_TO_ADDR
// if IsInUnit ( driver ) then
31451: LD_VAR 0 18
31455: PPUSH
31456: CALL_OW 310
31460: IFFALSE 31471
// ComExit ( driver ) ;
31462: LD_VAR 0 18
31466: PPUSH
31467: CALL 55860 0 1
// AddComEnterUnit ( driver , tmp ) ;
31471: LD_VAR 0 18
31475: PPUSH
31476: LD_VAR 0 13
31480: PPUSH
31481: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
31485: LD_VAR 0 18
31489: PPUSH
31490: LD_VAR 0 7
31494: PPUSH
31495: CALL_OW 173
// AddComExitVehicle ( driver ) ;
31499: LD_VAR 0 18
31503: PPUSH
31504: CALL_OW 181
// end ; continue ;
31508: GO 31160
// end ; if not cleaners or not tmp in cleaners then
31510: LD_VAR 0 6
31514: NOT
31515: PUSH
31516: LD_VAR 0 13
31520: PUSH
31521: LD_VAR 0 6
31525: IN
31526: NOT
31527: OR
31528: IFFALSE 31835
// begin if dep then
31530: LD_VAR 0 17
31534: IFFALSE 31670
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
31536: LD_ADDR_VAR 0 16
31540: PUSH
31541: LD_VAR 0 17
31545: PUSH
31546: LD_INT 1
31548: ARRAY
31549: PPUSH
31550: CALL_OW 250
31554: PPUSH
31555: LD_VAR 0 17
31559: PUSH
31560: LD_INT 1
31562: ARRAY
31563: PPUSH
31564: CALL_OW 254
31568: PPUSH
31569: LD_INT 5
31571: PPUSH
31572: CALL_OW 272
31576: PUSH
31577: LD_VAR 0 17
31581: PUSH
31582: LD_INT 1
31584: ARRAY
31585: PPUSH
31586: CALL_OW 251
31590: PPUSH
31591: LD_VAR 0 17
31595: PUSH
31596: LD_INT 1
31598: ARRAY
31599: PPUSH
31600: CALL_OW 254
31604: PPUSH
31605: LD_INT 5
31607: PPUSH
31608: CALL_OW 273
31612: PUSH
31613: EMPTY
31614: LIST
31615: LIST
31616: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
31617: LD_VAR 0 16
31621: PUSH
31622: LD_INT 1
31624: ARRAY
31625: PPUSH
31626: LD_VAR 0 16
31630: PUSH
31631: LD_INT 2
31633: ARRAY
31634: PPUSH
31635: CALL_OW 488
31639: IFFALSE 31670
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
31641: LD_VAR 0 13
31645: PPUSH
31646: LD_VAR 0 16
31650: PUSH
31651: LD_INT 1
31653: ARRAY
31654: PPUSH
31655: LD_VAR 0 16
31659: PUSH
31660: LD_INT 2
31662: ARRAY
31663: PPUSH
31664: CALL_OW 111
// continue ;
31668: GO 31160
// end ; end ; r := GetDir ( tmp ) ;
31670: LD_ADDR_VAR 0 15
31674: PUSH
31675: LD_VAR 0 13
31679: PPUSH
31680: CALL_OW 254
31684: ST_TO_ADDR
// if r = 5 then
31685: LD_VAR 0 15
31689: PUSH
31690: LD_INT 5
31692: EQUAL
31693: IFFALSE 31703
// r := 0 ;
31695: LD_ADDR_VAR 0 15
31699: PUSH
31700: LD_INT 0
31702: ST_TO_ADDR
// for j = r to 5 do
31703: LD_ADDR_VAR 0 10
31707: PUSH
31708: DOUBLE
31709: LD_VAR 0 15
31713: DEC
31714: ST_TO_ADDR
31715: LD_INT 5
31717: PUSH
31718: FOR_TO
31719: IFFALSE 31833
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
31721: LD_ADDR_VAR 0 11
31725: PUSH
31726: LD_VAR 0 13
31730: PPUSH
31731: CALL_OW 250
31735: PPUSH
31736: LD_VAR 0 10
31740: PPUSH
31741: LD_INT 2
31743: PPUSH
31744: CALL_OW 272
31748: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
31749: LD_ADDR_VAR 0 12
31753: PUSH
31754: LD_VAR 0 13
31758: PPUSH
31759: CALL_OW 251
31763: PPUSH
31764: LD_VAR 0 10
31768: PPUSH
31769: LD_INT 2
31771: PPUSH
31772: CALL_OW 273
31776: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
31777: LD_VAR 0 11
31781: PPUSH
31782: LD_VAR 0 12
31786: PPUSH
31787: CALL_OW 488
31791: PUSH
31792: LD_VAR 0 11
31796: PPUSH
31797: LD_VAR 0 12
31801: PPUSH
31802: CALL_OW 428
31806: NOT
31807: AND
31808: IFFALSE 31831
// begin ComMoveXY ( tmp , _x , _y ) ;
31810: LD_VAR 0 13
31814: PPUSH
31815: LD_VAR 0 11
31819: PPUSH
31820: LD_VAR 0 12
31824: PPUSH
31825: CALL_OW 111
// break ;
31829: GO 31833
// end ; end ;
31831: GO 31718
31833: POP
31834: POP
// end ; end ;
31835: GO 31160
31837: POP
31838: POP
// end ;
31839: LD_VAR 0 8
31843: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex ; begin
31844: LD_INT 0
31846: PPUSH
31847: PPUSH
31848: PPUSH
31849: PPUSH
31850: PPUSH
31851: PPUSH
31852: PPUSH
31853: PPUSH
31854: PPUSH
31855: PPUSH
// result := false ;
31856: LD_ADDR_VAR 0 6
31860: PUSH
31861: LD_INT 0
31863: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
31864: LD_VAR 0 1
31868: NOT
31869: PUSH
31870: LD_VAR 0 1
31874: PPUSH
31875: CALL_OW 266
31879: PUSH
31880: LD_INT 0
31882: PUSH
31883: LD_INT 1
31885: PUSH
31886: EMPTY
31887: LIST
31888: LIST
31889: IN
31890: NOT
31891: OR
31892: PUSH
31893: LD_VAR 0 2
31897: NOT
31898: OR
31899: PUSH
31900: LD_VAR 0 5
31904: PUSH
31905: LD_INT 0
31907: PUSH
31908: LD_INT 1
31910: PUSH
31911: LD_INT 2
31913: PUSH
31914: LD_INT 3
31916: PUSH
31917: LD_INT 4
31919: PUSH
31920: LD_INT 5
31922: PUSH
31923: EMPTY
31924: LIST
31925: LIST
31926: LIST
31927: LIST
31928: LIST
31929: LIST
31930: IN
31931: NOT
31932: OR
31933: PUSH
31934: LD_VAR 0 3
31938: PPUSH
31939: LD_VAR 0 4
31943: PPUSH
31944: CALL_OW 488
31948: NOT
31949: OR
31950: IFFALSE 31954
// exit ;
31952: GO 32671
// pom := GetBase ( depot ) ;
31954: LD_ADDR_VAR 0 10
31958: PUSH
31959: LD_VAR 0 1
31963: PPUSH
31964: CALL_OW 274
31968: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
31969: LD_ADDR_VAR 0 11
31973: PUSH
31974: LD_VAR 0 2
31978: PPUSH
31979: LD_VAR 0 1
31983: PPUSH
31984: CALL_OW 248
31988: PPUSH
31989: CALL_OW 450
31993: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
31994: LD_VAR 0 10
31998: PPUSH
31999: LD_INT 1
32001: PPUSH
32002: CALL_OW 275
32006: PUSH
32007: LD_VAR 0 11
32011: PUSH
32012: LD_INT 1
32014: ARRAY
32015: GREATEREQUAL
32016: PUSH
32017: LD_VAR 0 10
32021: PPUSH
32022: LD_INT 2
32024: PPUSH
32025: CALL_OW 275
32029: PUSH
32030: LD_VAR 0 11
32034: PUSH
32035: LD_INT 2
32037: ARRAY
32038: GREATEREQUAL
32039: AND
32040: PUSH
32041: LD_VAR 0 10
32045: PPUSH
32046: LD_INT 3
32048: PPUSH
32049: CALL_OW 275
32053: PUSH
32054: LD_VAR 0 11
32058: PUSH
32059: LD_INT 3
32061: ARRAY
32062: GREATEREQUAL
32063: AND
32064: NOT
32065: IFFALSE 32069
// exit ;
32067: GO 32671
// if GetBType ( depot ) = b_depot then
32069: LD_VAR 0 1
32073: PPUSH
32074: CALL_OW 266
32078: PUSH
32079: LD_INT 0
32081: EQUAL
32082: IFFALSE 32094
// dist := 28 else
32084: LD_ADDR_VAR 0 14
32088: PUSH
32089: LD_INT 28
32091: ST_TO_ADDR
32092: GO 32102
// dist := 36 ;
32094: LD_ADDR_VAR 0 14
32098: PUSH
32099: LD_INT 36
32101: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
32102: LD_VAR 0 1
32106: PPUSH
32107: LD_VAR 0 3
32111: PPUSH
32112: LD_VAR 0 4
32116: PPUSH
32117: CALL_OW 297
32121: PUSH
32122: LD_VAR 0 14
32126: GREATER
32127: IFFALSE 32131
// exit ;
32129: GO 32671
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
32131: LD_ADDR_VAR 0 12
32135: PUSH
32136: LD_VAR 0 2
32140: PPUSH
32141: LD_VAR 0 3
32145: PPUSH
32146: LD_VAR 0 4
32150: PPUSH
32151: LD_VAR 0 5
32155: PPUSH
32156: LD_VAR 0 1
32160: PPUSH
32161: CALL_OW 248
32165: PPUSH
32166: LD_INT 0
32168: PPUSH
32169: CALL 32676 0 6
32173: ST_TO_ADDR
// if not hexes then
32174: LD_VAR 0 12
32178: NOT
32179: IFFALSE 32183
// exit ;
32181: GO 32671
// hex := GetHexInfo ( x , y ) ;
32183: LD_ADDR_VAR 0 15
32187: PUSH
32188: LD_VAR 0 3
32192: PPUSH
32193: LD_VAR 0 4
32197: PPUSH
32198: CALL_OW 546
32202: ST_TO_ADDR
// if hex [ 1 ] then
32203: LD_VAR 0 15
32207: PUSH
32208: LD_INT 1
32210: ARRAY
32211: IFFALSE 32215
// exit ;
32213: GO 32671
// height := hex [ 2 ] ;
32215: LD_ADDR_VAR 0 13
32219: PUSH
32220: LD_VAR 0 15
32224: PUSH
32225: LD_INT 2
32227: ARRAY
32228: ST_TO_ADDR
// for i = 1 to hexes do
32229: LD_ADDR_VAR 0 7
32233: PUSH
32234: DOUBLE
32235: LD_INT 1
32237: DEC
32238: ST_TO_ADDR
32239: LD_VAR 0 12
32243: PUSH
32244: FOR_TO
32245: IFFALSE 32575
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
32247: LD_VAR 0 12
32251: PUSH
32252: LD_VAR 0 7
32256: ARRAY
32257: PUSH
32258: LD_INT 1
32260: ARRAY
32261: PPUSH
32262: LD_VAR 0 12
32266: PUSH
32267: LD_VAR 0 7
32271: ARRAY
32272: PUSH
32273: LD_INT 2
32275: ARRAY
32276: PPUSH
32277: CALL_OW 488
32281: NOT
32282: PUSH
32283: LD_VAR 0 12
32287: PUSH
32288: LD_VAR 0 7
32292: ARRAY
32293: PUSH
32294: LD_INT 1
32296: ARRAY
32297: PPUSH
32298: LD_VAR 0 12
32302: PUSH
32303: LD_VAR 0 7
32307: ARRAY
32308: PUSH
32309: LD_INT 2
32311: ARRAY
32312: PPUSH
32313: CALL_OW 428
32317: PUSH
32318: LD_INT 0
32320: GREATER
32321: OR
32322: PUSH
32323: LD_VAR 0 12
32327: PUSH
32328: LD_VAR 0 7
32332: ARRAY
32333: PUSH
32334: LD_INT 1
32336: ARRAY
32337: PPUSH
32338: LD_VAR 0 12
32342: PUSH
32343: LD_VAR 0 7
32347: ARRAY
32348: PUSH
32349: LD_INT 2
32351: ARRAY
32352: PPUSH
32353: CALL_OW 351
32357: OR
32358: IFFALSE 32364
// exit ;
32360: POP
32361: POP
32362: GO 32671
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
32364: LD_ADDR_VAR 0 8
32368: PUSH
32369: LD_VAR 0 12
32373: PUSH
32374: LD_VAR 0 7
32378: ARRAY
32379: PUSH
32380: LD_INT 1
32382: ARRAY
32383: PPUSH
32384: LD_VAR 0 12
32388: PUSH
32389: LD_VAR 0 7
32393: ARRAY
32394: PUSH
32395: LD_INT 2
32397: ARRAY
32398: PPUSH
32399: CALL_OW 546
32403: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
32404: LD_VAR 0 8
32408: PUSH
32409: LD_INT 1
32411: ARRAY
32412: PUSH
32413: LD_VAR 0 8
32417: PUSH
32418: LD_INT 2
32420: ARRAY
32421: PUSH
32422: LD_VAR 0 13
32426: PUSH
32427: LD_INT 2
32429: PLUS
32430: GREATER
32431: OR
32432: PUSH
32433: LD_VAR 0 8
32437: PUSH
32438: LD_INT 2
32440: ARRAY
32441: PUSH
32442: LD_VAR 0 13
32446: PUSH
32447: LD_INT 2
32449: MINUS
32450: LESS
32451: OR
32452: PUSH
32453: LD_VAR 0 8
32457: PUSH
32458: LD_INT 3
32460: ARRAY
32461: PUSH
32462: LD_INT 0
32464: PUSH
32465: LD_INT 8
32467: PUSH
32468: LD_INT 9
32470: PUSH
32471: LD_INT 10
32473: PUSH
32474: LD_INT 11
32476: PUSH
32477: LD_INT 12
32479: PUSH
32480: LD_INT 13
32482: PUSH
32483: LD_INT 16
32485: PUSH
32486: LD_INT 17
32488: PUSH
32489: LD_INT 18
32491: PUSH
32492: LD_INT 19
32494: PUSH
32495: LD_INT 20
32497: PUSH
32498: LD_INT 21
32500: PUSH
32501: EMPTY
32502: LIST
32503: LIST
32504: LIST
32505: LIST
32506: LIST
32507: LIST
32508: LIST
32509: LIST
32510: LIST
32511: LIST
32512: LIST
32513: LIST
32514: LIST
32515: IN
32516: NOT
32517: OR
32518: PUSH
32519: LD_VAR 0 8
32523: PUSH
32524: LD_INT 5
32526: ARRAY
32527: NOT
32528: OR
32529: PUSH
32530: LD_VAR 0 8
32534: PUSH
32535: LD_INT 6
32537: ARRAY
32538: PUSH
32539: LD_INT 1
32541: PUSH
32542: LD_INT 2
32544: PUSH
32545: LD_INT 7
32547: PUSH
32548: LD_INT 9
32550: PUSH
32551: LD_INT 10
32553: PUSH
32554: LD_INT 11
32556: PUSH
32557: EMPTY
32558: LIST
32559: LIST
32560: LIST
32561: LIST
32562: LIST
32563: LIST
32564: IN
32565: NOT
32566: OR
32567: IFFALSE 32573
// exit ;
32569: POP
32570: POP
32571: GO 32671
// end ;
32573: GO 32244
32575: POP
32576: POP
// side := GetSide ( depot ) ;
32577: LD_ADDR_VAR 0 9
32581: PUSH
32582: LD_VAR 0 1
32586: PPUSH
32587: CALL_OW 255
32591: ST_TO_ADDR
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
32592: LD_VAR 0 9
32596: PPUSH
32597: LD_VAR 0 3
32601: PPUSH
32602: LD_VAR 0 4
32606: PPUSH
32607: LD_INT 20
32609: PPUSH
32610: CALL 24992 0 4
32614: PUSH
32615: LD_INT 4
32617: ARRAY
32618: IFFALSE 32622
// exit ;
32620: GO 32671
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
32622: LD_VAR 0 2
32626: PUSH
32627: LD_INT 29
32629: PUSH
32630: LD_INT 30
32632: PUSH
32633: EMPTY
32634: LIST
32635: LIST
32636: IN
32637: PUSH
32638: LD_VAR 0 3
32642: PPUSH
32643: LD_VAR 0 4
32647: PPUSH
32648: LD_VAR 0 9
32652: PPUSH
32653: CALL_OW 440
32657: NOT
32658: AND
32659: IFFALSE 32663
// exit ;
32661: GO 32671
// result := true ;
32663: LD_ADDR_VAR 0 6
32667: PUSH
32668: LD_INT 1
32670: ST_TO_ADDR
// end ;
32671: LD_VAR 0 6
32675: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
32676: LD_INT 0
32678: PPUSH
32679: PPUSH
32680: PPUSH
32681: PPUSH
32682: PPUSH
32683: PPUSH
32684: PPUSH
32685: PPUSH
32686: PPUSH
32687: PPUSH
32688: PPUSH
32689: PPUSH
32690: PPUSH
32691: PPUSH
32692: PPUSH
32693: PPUSH
32694: PPUSH
32695: PPUSH
32696: PPUSH
32697: PPUSH
32698: PPUSH
32699: PPUSH
32700: PPUSH
32701: PPUSH
32702: PPUSH
32703: PPUSH
32704: PPUSH
32705: PPUSH
32706: PPUSH
32707: PPUSH
32708: PPUSH
32709: PPUSH
32710: PPUSH
32711: PPUSH
32712: PPUSH
32713: PPUSH
32714: PPUSH
32715: PPUSH
32716: PPUSH
32717: PPUSH
32718: PPUSH
32719: PPUSH
32720: PPUSH
32721: PPUSH
32722: PPUSH
32723: PPUSH
32724: PPUSH
32725: PPUSH
32726: PPUSH
32727: PPUSH
32728: PPUSH
32729: PPUSH
32730: PPUSH
32731: PPUSH
32732: PPUSH
32733: PPUSH
32734: PPUSH
32735: PPUSH
// result = [ ] ;
32736: LD_ADDR_VAR 0 7
32740: PUSH
32741: EMPTY
32742: ST_TO_ADDR
// temp_list = [ ] ;
32743: LD_ADDR_VAR 0 9
32747: PUSH
32748: EMPTY
32749: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
32750: LD_VAR 0 4
32754: PUSH
32755: LD_INT 0
32757: PUSH
32758: LD_INT 1
32760: PUSH
32761: LD_INT 2
32763: PUSH
32764: LD_INT 3
32766: PUSH
32767: LD_INT 4
32769: PUSH
32770: LD_INT 5
32772: PUSH
32773: EMPTY
32774: LIST
32775: LIST
32776: LIST
32777: LIST
32778: LIST
32779: LIST
32780: IN
32781: NOT
32782: PUSH
32783: LD_VAR 0 1
32787: PUSH
32788: LD_INT 0
32790: PUSH
32791: LD_INT 1
32793: PUSH
32794: EMPTY
32795: LIST
32796: LIST
32797: IN
32798: PUSH
32799: LD_VAR 0 5
32803: PUSH
32804: LD_INT 1
32806: PUSH
32807: LD_INT 2
32809: PUSH
32810: LD_INT 3
32812: PUSH
32813: EMPTY
32814: LIST
32815: LIST
32816: LIST
32817: IN
32818: NOT
32819: AND
32820: OR
32821: IFFALSE 32825
// exit ;
32823: GO 51216
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
32825: LD_VAR 0 1
32829: PUSH
32830: LD_INT 6
32832: PUSH
32833: LD_INT 7
32835: PUSH
32836: LD_INT 8
32838: PUSH
32839: LD_INT 13
32841: PUSH
32842: LD_INT 12
32844: PUSH
32845: LD_INT 15
32847: PUSH
32848: LD_INT 11
32850: PUSH
32851: LD_INT 14
32853: PUSH
32854: LD_INT 10
32856: PUSH
32857: EMPTY
32858: LIST
32859: LIST
32860: LIST
32861: LIST
32862: LIST
32863: LIST
32864: LIST
32865: LIST
32866: LIST
32867: IN
32868: IFFALSE 32878
// btype = b_lab ;
32870: LD_ADDR_VAR 0 1
32874: PUSH
32875: LD_INT 6
32877: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
32878: LD_VAR 0 6
32882: PUSH
32883: LD_INT 0
32885: PUSH
32886: LD_INT 1
32888: PUSH
32889: LD_INT 2
32891: PUSH
32892: EMPTY
32893: LIST
32894: LIST
32895: LIST
32896: IN
32897: NOT
32898: PUSH
32899: LD_VAR 0 1
32903: PUSH
32904: LD_INT 0
32906: PUSH
32907: LD_INT 1
32909: PUSH
32910: LD_INT 2
32912: PUSH
32913: LD_INT 3
32915: PUSH
32916: LD_INT 6
32918: PUSH
32919: LD_INT 36
32921: PUSH
32922: LD_INT 4
32924: PUSH
32925: LD_INT 5
32927: PUSH
32928: LD_INT 31
32930: PUSH
32931: LD_INT 32
32933: PUSH
32934: LD_INT 33
32936: PUSH
32937: EMPTY
32938: LIST
32939: LIST
32940: LIST
32941: LIST
32942: LIST
32943: LIST
32944: LIST
32945: LIST
32946: LIST
32947: LIST
32948: LIST
32949: IN
32950: NOT
32951: PUSH
32952: LD_VAR 0 6
32956: PUSH
32957: LD_INT 1
32959: EQUAL
32960: AND
32961: OR
32962: PUSH
32963: LD_VAR 0 1
32967: PUSH
32968: LD_INT 2
32970: PUSH
32971: LD_INT 3
32973: PUSH
32974: EMPTY
32975: LIST
32976: LIST
32977: IN
32978: NOT
32979: PUSH
32980: LD_VAR 0 6
32984: PUSH
32985: LD_INT 2
32987: EQUAL
32988: AND
32989: OR
32990: IFFALSE 33000
// mode = 0 ;
32992: LD_ADDR_VAR 0 6
32996: PUSH
32997: LD_INT 0
32999: ST_TO_ADDR
// case mode of 0 :
33000: LD_VAR 0 6
33004: PUSH
33005: LD_INT 0
33007: DOUBLE
33008: EQUAL
33009: IFTRUE 33013
33011: GO 44466
33013: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
33014: LD_ADDR_VAR 0 11
33018: PUSH
33019: LD_INT 0
33021: PUSH
33022: LD_INT 0
33024: PUSH
33025: EMPTY
33026: LIST
33027: LIST
33028: PUSH
33029: LD_INT 0
33031: PUSH
33032: LD_INT 1
33034: NEG
33035: PUSH
33036: EMPTY
33037: LIST
33038: LIST
33039: PUSH
33040: LD_INT 1
33042: PUSH
33043: LD_INT 0
33045: PUSH
33046: EMPTY
33047: LIST
33048: LIST
33049: PUSH
33050: LD_INT 1
33052: PUSH
33053: LD_INT 1
33055: PUSH
33056: EMPTY
33057: LIST
33058: LIST
33059: PUSH
33060: LD_INT 0
33062: PUSH
33063: LD_INT 1
33065: PUSH
33066: EMPTY
33067: LIST
33068: LIST
33069: PUSH
33070: LD_INT 1
33072: NEG
33073: PUSH
33074: LD_INT 0
33076: PUSH
33077: EMPTY
33078: LIST
33079: LIST
33080: PUSH
33081: LD_INT 1
33083: NEG
33084: PUSH
33085: LD_INT 1
33087: NEG
33088: PUSH
33089: EMPTY
33090: LIST
33091: LIST
33092: PUSH
33093: LD_INT 1
33095: NEG
33096: PUSH
33097: LD_INT 2
33099: NEG
33100: PUSH
33101: EMPTY
33102: LIST
33103: LIST
33104: PUSH
33105: LD_INT 0
33107: PUSH
33108: LD_INT 2
33110: NEG
33111: PUSH
33112: EMPTY
33113: LIST
33114: LIST
33115: PUSH
33116: LD_INT 1
33118: PUSH
33119: LD_INT 1
33121: NEG
33122: PUSH
33123: EMPTY
33124: LIST
33125: LIST
33126: PUSH
33127: LD_INT 1
33129: PUSH
33130: LD_INT 2
33132: PUSH
33133: EMPTY
33134: LIST
33135: LIST
33136: PUSH
33137: LD_INT 0
33139: PUSH
33140: LD_INT 2
33142: PUSH
33143: EMPTY
33144: LIST
33145: LIST
33146: PUSH
33147: LD_INT 1
33149: NEG
33150: PUSH
33151: LD_INT 1
33153: PUSH
33154: EMPTY
33155: LIST
33156: LIST
33157: PUSH
33158: LD_INT 1
33160: PUSH
33161: LD_INT 3
33163: PUSH
33164: EMPTY
33165: LIST
33166: LIST
33167: PUSH
33168: LD_INT 0
33170: PUSH
33171: LD_INT 3
33173: PUSH
33174: EMPTY
33175: LIST
33176: LIST
33177: PUSH
33178: LD_INT 1
33180: NEG
33181: PUSH
33182: LD_INT 2
33184: PUSH
33185: EMPTY
33186: LIST
33187: LIST
33188: PUSH
33189: EMPTY
33190: LIST
33191: LIST
33192: LIST
33193: LIST
33194: LIST
33195: LIST
33196: LIST
33197: LIST
33198: LIST
33199: LIST
33200: LIST
33201: LIST
33202: LIST
33203: LIST
33204: LIST
33205: LIST
33206: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
33207: LD_ADDR_VAR 0 12
33211: PUSH
33212: LD_INT 0
33214: PUSH
33215: LD_INT 0
33217: PUSH
33218: EMPTY
33219: LIST
33220: LIST
33221: PUSH
33222: LD_INT 0
33224: PUSH
33225: LD_INT 1
33227: NEG
33228: PUSH
33229: EMPTY
33230: LIST
33231: LIST
33232: PUSH
33233: LD_INT 1
33235: PUSH
33236: LD_INT 0
33238: PUSH
33239: EMPTY
33240: LIST
33241: LIST
33242: PUSH
33243: LD_INT 1
33245: PUSH
33246: LD_INT 1
33248: PUSH
33249: EMPTY
33250: LIST
33251: LIST
33252: PUSH
33253: LD_INT 0
33255: PUSH
33256: LD_INT 1
33258: PUSH
33259: EMPTY
33260: LIST
33261: LIST
33262: PUSH
33263: LD_INT 1
33265: NEG
33266: PUSH
33267: LD_INT 0
33269: PUSH
33270: EMPTY
33271: LIST
33272: LIST
33273: PUSH
33274: LD_INT 1
33276: NEG
33277: PUSH
33278: LD_INT 1
33280: NEG
33281: PUSH
33282: EMPTY
33283: LIST
33284: LIST
33285: PUSH
33286: LD_INT 1
33288: PUSH
33289: LD_INT 1
33291: NEG
33292: PUSH
33293: EMPTY
33294: LIST
33295: LIST
33296: PUSH
33297: LD_INT 2
33299: PUSH
33300: LD_INT 0
33302: PUSH
33303: EMPTY
33304: LIST
33305: LIST
33306: PUSH
33307: LD_INT 2
33309: PUSH
33310: LD_INT 1
33312: PUSH
33313: EMPTY
33314: LIST
33315: LIST
33316: PUSH
33317: LD_INT 1
33319: NEG
33320: PUSH
33321: LD_INT 1
33323: PUSH
33324: EMPTY
33325: LIST
33326: LIST
33327: PUSH
33328: LD_INT 2
33330: NEG
33331: PUSH
33332: LD_INT 0
33334: PUSH
33335: EMPTY
33336: LIST
33337: LIST
33338: PUSH
33339: LD_INT 2
33341: NEG
33342: PUSH
33343: LD_INT 1
33345: NEG
33346: PUSH
33347: EMPTY
33348: LIST
33349: LIST
33350: PUSH
33351: LD_INT 2
33353: NEG
33354: PUSH
33355: LD_INT 1
33357: PUSH
33358: EMPTY
33359: LIST
33360: LIST
33361: PUSH
33362: LD_INT 3
33364: NEG
33365: PUSH
33366: LD_INT 0
33368: PUSH
33369: EMPTY
33370: LIST
33371: LIST
33372: PUSH
33373: LD_INT 3
33375: NEG
33376: PUSH
33377: LD_INT 1
33379: NEG
33380: PUSH
33381: EMPTY
33382: LIST
33383: LIST
33384: PUSH
33385: EMPTY
33386: LIST
33387: LIST
33388: LIST
33389: LIST
33390: LIST
33391: LIST
33392: LIST
33393: LIST
33394: LIST
33395: LIST
33396: LIST
33397: LIST
33398: LIST
33399: LIST
33400: LIST
33401: LIST
33402: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
33403: LD_ADDR_VAR 0 13
33407: PUSH
33408: LD_INT 0
33410: PUSH
33411: LD_INT 0
33413: PUSH
33414: EMPTY
33415: LIST
33416: LIST
33417: PUSH
33418: LD_INT 0
33420: PUSH
33421: LD_INT 1
33423: NEG
33424: PUSH
33425: EMPTY
33426: LIST
33427: LIST
33428: PUSH
33429: LD_INT 1
33431: PUSH
33432: LD_INT 0
33434: PUSH
33435: EMPTY
33436: LIST
33437: LIST
33438: PUSH
33439: LD_INT 1
33441: PUSH
33442: LD_INT 1
33444: PUSH
33445: EMPTY
33446: LIST
33447: LIST
33448: PUSH
33449: LD_INT 0
33451: PUSH
33452: LD_INT 1
33454: PUSH
33455: EMPTY
33456: LIST
33457: LIST
33458: PUSH
33459: LD_INT 1
33461: NEG
33462: PUSH
33463: LD_INT 0
33465: PUSH
33466: EMPTY
33467: LIST
33468: LIST
33469: PUSH
33470: LD_INT 1
33472: NEG
33473: PUSH
33474: LD_INT 1
33476: NEG
33477: PUSH
33478: EMPTY
33479: LIST
33480: LIST
33481: PUSH
33482: LD_INT 1
33484: NEG
33485: PUSH
33486: LD_INT 2
33488: NEG
33489: PUSH
33490: EMPTY
33491: LIST
33492: LIST
33493: PUSH
33494: LD_INT 2
33496: PUSH
33497: LD_INT 1
33499: PUSH
33500: EMPTY
33501: LIST
33502: LIST
33503: PUSH
33504: LD_INT 2
33506: PUSH
33507: LD_INT 2
33509: PUSH
33510: EMPTY
33511: LIST
33512: LIST
33513: PUSH
33514: LD_INT 1
33516: PUSH
33517: LD_INT 2
33519: PUSH
33520: EMPTY
33521: LIST
33522: LIST
33523: PUSH
33524: LD_INT 2
33526: NEG
33527: PUSH
33528: LD_INT 1
33530: NEG
33531: PUSH
33532: EMPTY
33533: LIST
33534: LIST
33535: PUSH
33536: LD_INT 2
33538: NEG
33539: PUSH
33540: LD_INT 2
33542: NEG
33543: PUSH
33544: EMPTY
33545: LIST
33546: LIST
33547: PUSH
33548: LD_INT 2
33550: NEG
33551: PUSH
33552: LD_INT 3
33554: NEG
33555: PUSH
33556: EMPTY
33557: LIST
33558: LIST
33559: PUSH
33560: LD_INT 3
33562: NEG
33563: PUSH
33564: LD_INT 2
33566: NEG
33567: PUSH
33568: EMPTY
33569: LIST
33570: LIST
33571: PUSH
33572: LD_INT 3
33574: NEG
33575: PUSH
33576: LD_INT 3
33578: NEG
33579: PUSH
33580: EMPTY
33581: LIST
33582: LIST
33583: PUSH
33584: EMPTY
33585: LIST
33586: LIST
33587: LIST
33588: LIST
33589: LIST
33590: LIST
33591: LIST
33592: LIST
33593: LIST
33594: LIST
33595: LIST
33596: LIST
33597: LIST
33598: LIST
33599: LIST
33600: LIST
33601: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
33602: LD_ADDR_VAR 0 14
33606: PUSH
33607: LD_INT 0
33609: PUSH
33610: LD_INT 0
33612: PUSH
33613: EMPTY
33614: LIST
33615: LIST
33616: PUSH
33617: LD_INT 0
33619: PUSH
33620: LD_INT 1
33622: NEG
33623: PUSH
33624: EMPTY
33625: LIST
33626: LIST
33627: PUSH
33628: LD_INT 1
33630: PUSH
33631: LD_INT 0
33633: PUSH
33634: EMPTY
33635: LIST
33636: LIST
33637: PUSH
33638: LD_INT 1
33640: PUSH
33641: LD_INT 1
33643: PUSH
33644: EMPTY
33645: LIST
33646: LIST
33647: PUSH
33648: LD_INT 0
33650: PUSH
33651: LD_INT 1
33653: PUSH
33654: EMPTY
33655: LIST
33656: LIST
33657: PUSH
33658: LD_INT 1
33660: NEG
33661: PUSH
33662: LD_INT 0
33664: PUSH
33665: EMPTY
33666: LIST
33667: LIST
33668: PUSH
33669: LD_INT 1
33671: NEG
33672: PUSH
33673: LD_INT 1
33675: NEG
33676: PUSH
33677: EMPTY
33678: LIST
33679: LIST
33680: PUSH
33681: LD_INT 1
33683: NEG
33684: PUSH
33685: LD_INT 2
33687: NEG
33688: PUSH
33689: EMPTY
33690: LIST
33691: LIST
33692: PUSH
33693: LD_INT 0
33695: PUSH
33696: LD_INT 2
33698: NEG
33699: PUSH
33700: EMPTY
33701: LIST
33702: LIST
33703: PUSH
33704: LD_INT 1
33706: PUSH
33707: LD_INT 1
33709: NEG
33710: PUSH
33711: EMPTY
33712: LIST
33713: LIST
33714: PUSH
33715: LD_INT 1
33717: PUSH
33718: LD_INT 2
33720: PUSH
33721: EMPTY
33722: LIST
33723: LIST
33724: PUSH
33725: LD_INT 0
33727: PUSH
33728: LD_INT 2
33730: PUSH
33731: EMPTY
33732: LIST
33733: LIST
33734: PUSH
33735: LD_INT 1
33737: NEG
33738: PUSH
33739: LD_INT 1
33741: PUSH
33742: EMPTY
33743: LIST
33744: LIST
33745: PUSH
33746: LD_INT 1
33748: NEG
33749: PUSH
33750: LD_INT 3
33752: NEG
33753: PUSH
33754: EMPTY
33755: LIST
33756: LIST
33757: PUSH
33758: LD_INT 0
33760: PUSH
33761: LD_INT 3
33763: NEG
33764: PUSH
33765: EMPTY
33766: LIST
33767: LIST
33768: PUSH
33769: LD_INT 1
33771: PUSH
33772: LD_INT 2
33774: NEG
33775: PUSH
33776: EMPTY
33777: LIST
33778: LIST
33779: PUSH
33780: EMPTY
33781: LIST
33782: LIST
33783: LIST
33784: LIST
33785: LIST
33786: LIST
33787: LIST
33788: LIST
33789: LIST
33790: LIST
33791: LIST
33792: LIST
33793: LIST
33794: LIST
33795: LIST
33796: LIST
33797: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
33798: LD_ADDR_VAR 0 15
33802: PUSH
33803: LD_INT 0
33805: PUSH
33806: LD_INT 0
33808: PUSH
33809: EMPTY
33810: LIST
33811: LIST
33812: PUSH
33813: LD_INT 0
33815: PUSH
33816: LD_INT 1
33818: NEG
33819: PUSH
33820: EMPTY
33821: LIST
33822: LIST
33823: PUSH
33824: LD_INT 1
33826: PUSH
33827: LD_INT 0
33829: PUSH
33830: EMPTY
33831: LIST
33832: LIST
33833: PUSH
33834: LD_INT 1
33836: PUSH
33837: LD_INT 1
33839: PUSH
33840: EMPTY
33841: LIST
33842: LIST
33843: PUSH
33844: LD_INT 0
33846: PUSH
33847: LD_INT 1
33849: PUSH
33850: EMPTY
33851: LIST
33852: LIST
33853: PUSH
33854: LD_INT 1
33856: NEG
33857: PUSH
33858: LD_INT 0
33860: PUSH
33861: EMPTY
33862: LIST
33863: LIST
33864: PUSH
33865: LD_INT 1
33867: NEG
33868: PUSH
33869: LD_INT 1
33871: NEG
33872: PUSH
33873: EMPTY
33874: LIST
33875: LIST
33876: PUSH
33877: LD_INT 1
33879: PUSH
33880: LD_INT 1
33882: NEG
33883: PUSH
33884: EMPTY
33885: LIST
33886: LIST
33887: PUSH
33888: LD_INT 2
33890: PUSH
33891: LD_INT 0
33893: PUSH
33894: EMPTY
33895: LIST
33896: LIST
33897: PUSH
33898: LD_INT 2
33900: PUSH
33901: LD_INT 1
33903: PUSH
33904: EMPTY
33905: LIST
33906: LIST
33907: PUSH
33908: LD_INT 1
33910: NEG
33911: PUSH
33912: LD_INT 1
33914: PUSH
33915: EMPTY
33916: LIST
33917: LIST
33918: PUSH
33919: LD_INT 2
33921: NEG
33922: PUSH
33923: LD_INT 0
33925: PUSH
33926: EMPTY
33927: LIST
33928: LIST
33929: PUSH
33930: LD_INT 2
33932: NEG
33933: PUSH
33934: LD_INT 1
33936: NEG
33937: PUSH
33938: EMPTY
33939: LIST
33940: LIST
33941: PUSH
33942: LD_INT 2
33944: PUSH
33945: LD_INT 1
33947: NEG
33948: PUSH
33949: EMPTY
33950: LIST
33951: LIST
33952: PUSH
33953: LD_INT 3
33955: PUSH
33956: LD_INT 0
33958: PUSH
33959: EMPTY
33960: LIST
33961: LIST
33962: PUSH
33963: LD_INT 3
33965: PUSH
33966: LD_INT 1
33968: PUSH
33969: EMPTY
33970: LIST
33971: LIST
33972: PUSH
33973: EMPTY
33974: LIST
33975: LIST
33976: LIST
33977: LIST
33978: LIST
33979: LIST
33980: LIST
33981: LIST
33982: LIST
33983: LIST
33984: LIST
33985: LIST
33986: LIST
33987: LIST
33988: LIST
33989: LIST
33990: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
33991: LD_ADDR_VAR 0 16
33995: PUSH
33996: LD_INT 0
33998: PUSH
33999: LD_INT 0
34001: PUSH
34002: EMPTY
34003: LIST
34004: LIST
34005: PUSH
34006: LD_INT 0
34008: PUSH
34009: LD_INT 1
34011: NEG
34012: PUSH
34013: EMPTY
34014: LIST
34015: LIST
34016: PUSH
34017: LD_INT 1
34019: PUSH
34020: LD_INT 0
34022: PUSH
34023: EMPTY
34024: LIST
34025: LIST
34026: PUSH
34027: LD_INT 1
34029: PUSH
34030: LD_INT 1
34032: PUSH
34033: EMPTY
34034: LIST
34035: LIST
34036: PUSH
34037: LD_INT 0
34039: PUSH
34040: LD_INT 1
34042: PUSH
34043: EMPTY
34044: LIST
34045: LIST
34046: PUSH
34047: LD_INT 1
34049: NEG
34050: PUSH
34051: LD_INT 0
34053: PUSH
34054: EMPTY
34055: LIST
34056: LIST
34057: PUSH
34058: LD_INT 1
34060: NEG
34061: PUSH
34062: LD_INT 1
34064: NEG
34065: PUSH
34066: EMPTY
34067: LIST
34068: LIST
34069: PUSH
34070: LD_INT 1
34072: NEG
34073: PUSH
34074: LD_INT 2
34076: NEG
34077: PUSH
34078: EMPTY
34079: LIST
34080: LIST
34081: PUSH
34082: LD_INT 2
34084: PUSH
34085: LD_INT 1
34087: PUSH
34088: EMPTY
34089: LIST
34090: LIST
34091: PUSH
34092: LD_INT 2
34094: PUSH
34095: LD_INT 2
34097: PUSH
34098: EMPTY
34099: LIST
34100: LIST
34101: PUSH
34102: LD_INT 1
34104: PUSH
34105: LD_INT 2
34107: PUSH
34108: EMPTY
34109: LIST
34110: LIST
34111: PUSH
34112: LD_INT 2
34114: NEG
34115: PUSH
34116: LD_INT 1
34118: NEG
34119: PUSH
34120: EMPTY
34121: LIST
34122: LIST
34123: PUSH
34124: LD_INT 2
34126: NEG
34127: PUSH
34128: LD_INT 2
34130: NEG
34131: PUSH
34132: EMPTY
34133: LIST
34134: LIST
34135: PUSH
34136: LD_INT 3
34138: PUSH
34139: LD_INT 2
34141: PUSH
34142: EMPTY
34143: LIST
34144: LIST
34145: PUSH
34146: LD_INT 3
34148: PUSH
34149: LD_INT 3
34151: PUSH
34152: EMPTY
34153: LIST
34154: LIST
34155: PUSH
34156: LD_INT 2
34158: PUSH
34159: LD_INT 3
34161: PUSH
34162: EMPTY
34163: LIST
34164: LIST
34165: PUSH
34166: EMPTY
34167: LIST
34168: LIST
34169: LIST
34170: LIST
34171: LIST
34172: LIST
34173: LIST
34174: LIST
34175: LIST
34176: LIST
34177: LIST
34178: LIST
34179: LIST
34180: LIST
34181: LIST
34182: LIST
34183: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
34184: LD_ADDR_VAR 0 17
34188: PUSH
34189: LD_INT 0
34191: PUSH
34192: LD_INT 0
34194: PUSH
34195: EMPTY
34196: LIST
34197: LIST
34198: PUSH
34199: LD_INT 0
34201: PUSH
34202: LD_INT 1
34204: NEG
34205: PUSH
34206: EMPTY
34207: LIST
34208: LIST
34209: PUSH
34210: LD_INT 1
34212: PUSH
34213: LD_INT 0
34215: PUSH
34216: EMPTY
34217: LIST
34218: LIST
34219: PUSH
34220: LD_INT 1
34222: PUSH
34223: LD_INT 1
34225: PUSH
34226: EMPTY
34227: LIST
34228: LIST
34229: PUSH
34230: LD_INT 0
34232: PUSH
34233: LD_INT 1
34235: PUSH
34236: EMPTY
34237: LIST
34238: LIST
34239: PUSH
34240: LD_INT 1
34242: NEG
34243: PUSH
34244: LD_INT 0
34246: PUSH
34247: EMPTY
34248: LIST
34249: LIST
34250: PUSH
34251: LD_INT 1
34253: NEG
34254: PUSH
34255: LD_INT 1
34257: NEG
34258: PUSH
34259: EMPTY
34260: LIST
34261: LIST
34262: PUSH
34263: LD_INT 1
34265: NEG
34266: PUSH
34267: LD_INT 2
34269: NEG
34270: PUSH
34271: EMPTY
34272: LIST
34273: LIST
34274: PUSH
34275: LD_INT 0
34277: PUSH
34278: LD_INT 2
34280: NEG
34281: PUSH
34282: EMPTY
34283: LIST
34284: LIST
34285: PUSH
34286: LD_INT 1
34288: PUSH
34289: LD_INT 1
34291: NEG
34292: PUSH
34293: EMPTY
34294: LIST
34295: LIST
34296: PUSH
34297: LD_INT 2
34299: PUSH
34300: LD_INT 0
34302: PUSH
34303: EMPTY
34304: LIST
34305: LIST
34306: PUSH
34307: LD_INT 2
34309: PUSH
34310: LD_INT 1
34312: PUSH
34313: EMPTY
34314: LIST
34315: LIST
34316: PUSH
34317: LD_INT 2
34319: PUSH
34320: LD_INT 2
34322: PUSH
34323: EMPTY
34324: LIST
34325: LIST
34326: PUSH
34327: LD_INT 1
34329: PUSH
34330: LD_INT 2
34332: PUSH
34333: EMPTY
34334: LIST
34335: LIST
34336: PUSH
34337: LD_INT 0
34339: PUSH
34340: LD_INT 2
34342: PUSH
34343: EMPTY
34344: LIST
34345: LIST
34346: PUSH
34347: LD_INT 1
34349: NEG
34350: PUSH
34351: LD_INT 1
34353: PUSH
34354: EMPTY
34355: LIST
34356: LIST
34357: PUSH
34358: LD_INT 2
34360: NEG
34361: PUSH
34362: LD_INT 0
34364: PUSH
34365: EMPTY
34366: LIST
34367: LIST
34368: PUSH
34369: LD_INT 2
34371: NEG
34372: PUSH
34373: LD_INT 1
34375: NEG
34376: PUSH
34377: EMPTY
34378: LIST
34379: LIST
34380: PUSH
34381: LD_INT 2
34383: NEG
34384: PUSH
34385: LD_INT 2
34387: NEG
34388: PUSH
34389: EMPTY
34390: LIST
34391: LIST
34392: PUSH
34393: EMPTY
34394: LIST
34395: LIST
34396: LIST
34397: LIST
34398: LIST
34399: LIST
34400: LIST
34401: LIST
34402: LIST
34403: LIST
34404: LIST
34405: LIST
34406: LIST
34407: LIST
34408: LIST
34409: LIST
34410: LIST
34411: LIST
34412: LIST
34413: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
34414: LD_ADDR_VAR 0 18
34418: PUSH
34419: LD_INT 0
34421: PUSH
34422: LD_INT 0
34424: PUSH
34425: EMPTY
34426: LIST
34427: LIST
34428: PUSH
34429: LD_INT 0
34431: PUSH
34432: LD_INT 1
34434: NEG
34435: PUSH
34436: EMPTY
34437: LIST
34438: LIST
34439: PUSH
34440: LD_INT 1
34442: PUSH
34443: LD_INT 0
34445: PUSH
34446: EMPTY
34447: LIST
34448: LIST
34449: PUSH
34450: LD_INT 1
34452: PUSH
34453: LD_INT 1
34455: PUSH
34456: EMPTY
34457: LIST
34458: LIST
34459: PUSH
34460: LD_INT 0
34462: PUSH
34463: LD_INT 1
34465: PUSH
34466: EMPTY
34467: LIST
34468: LIST
34469: PUSH
34470: LD_INT 1
34472: NEG
34473: PUSH
34474: LD_INT 0
34476: PUSH
34477: EMPTY
34478: LIST
34479: LIST
34480: PUSH
34481: LD_INT 1
34483: NEG
34484: PUSH
34485: LD_INT 1
34487: NEG
34488: PUSH
34489: EMPTY
34490: LIST
34491: LIST
34492: PUSH
34493: LD_INT 1
34495: NEG
34496: PUSH
34497: LD_INT 2
34499: NEG
34500: PUSH
34501: EMPTY
34502: LIST
34503: LIST
34504: PUSH
34505: LD_INT 0
34507: PUSH
34508: LD_INT 2
34510: NEG
34511: PUSH
34512: EMPTY
34513: LIST
34514: LIST
34515: PUSH
34516: LD_INT 1
34518: PUSH
34519: LD_INT 1
34521: NEG
34522: PUSH
34523: EMPTY
34524: LIST
34525: LIST
34526: PUSH
34527: LD_INT 2
34529: PUSH
34530: LD_INT 0
34532: PUSH
34533: EMPTY
34534: LIST
34535: LIST
34536: PUSH
34537: LD_INT 2
34539: PUSH
34540: LD_INT 1
34542: PUSH
34543: EMPTY
34544: LIST
34545: LIST
34546: PUSH
34547: LD_INT 2
34549: PUSH
34550: LD_INT 2
34552: PUSH
34553: EMPTY
34554: LIST
34555: LIST
34556: PUSH
34557: LD_INT 1
34559: PUSH
34560: LD_INT 2
34562: PUSH
34563: EMPTY
34564: LIST
34565: LIST
34566: PUSH
34567: LD_INT 0
34569: PUSH
34570: LD_INT 2
34572: PUSH
34573: EMPTY
34574: LIST
34575: LIST
34576: PUSH
34577: LD_INT 1
34579: NEG
34580: PUSH
34581: LD_INT 1
34583: PUSH
34584: EMPTY
34585: LIST
34586: LIST
34587: PUSH
34588: LD_INT 2
34590: NEG
34591: PUSH
34592: LD_INT 0
34594: PUSH
34595: EMPTY
34596: LIST
34597: LIST
34598: PUSH
34599: LD_INT 2
34601: NEG
34602: PUSH
34603: LD_INT 1
34605: NEG
34606: PUSH
34607: EMPTY
34608: LIST
34609: LIST
34610: PUSH
34611: LD_INT 2
34613: NEG
34614: PUSH
34615: LD_INT 2
34617: NEG
34618: PUSH
34619: EMPTY
34620: LIST
34621: LIST
34622: PUSH
34623: EMPTY
34624: LIST
34625: LIST
34626: LIST
34627: LIST
34628: LIST
34629: LIST
34630: LIST
34631: LIST
34632: LIST
34633: LIST
34634: LIST
34635: LIST
34636: LIST
34637: LIST
34638: LIST
34639: LIST
34640: LIST
34641: LIST
34642: LIST
34643: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
34644: LD_ADDR_VAR 0 19
34648: PUSH
34649: LD_INT 0
34651: PUSH
34652: LD_INT 0
34654: PUSH
34655: EMPTY
34656: LIST
34657: LIST
34658: PUSH
34659: LD_INT 0
34661: PUSH
34662: LD_INT 1
34664: NEG
34665: PUSH
34666: EMPTY
34667: LIST
34668: LIST
34669: PUSH
34670: LD_INT 1
34672: PUSH
34673: LD_INT 0
34675: PUSH
34676: EMPTY
34677: LIST
34678: LIST
34679: PUSH
34680: LD_INT 1
34682: PUSH
34683: LD_INT 1
34685: PUSH
34686: EMPTY
34687: LIST
34688: LIST
34689: PUSH
34690: LD_INT 0
34692: PUSH
34693: LD_INT 1
34695: PUSH
34696: EMPTY
34697: LIST
34698: LIST
34699: PUSH
34700: LD_INT 1
34702: NEG
34703: PUSH
34704: LD_INT 0
34706: PUSH
34707: EMPTY
34708: LIST
34709: LIST
34710: PUSH
34711: LD_INT 1
34713: NEG
34714: PUSH
34715: LD_INT 1
34717: NEG
34718: PUSH
34719: EMPTY
34720: LIST
34721: LIST
34722: PUSH
34723: LD_INT 1
34725: NEG
34726: PUSH
34727: LD_INT 2
34729: NEG
34730: PUSH
34731: EMPTY
34732: LIST
34733: LIST
34734: PUSH
34735: LD_INT 0
34737: PUSH
34738: LD_INT 2
34740: NEG
34741: PUSH
34742: EMPTY
34743: LIST
34744: LIST
34745: PUSH
34746: LD_INT 1
34748: PUSH
34749: LD_INT 1
34751: NEG
34752: PUSH
34753: EMPTY
34754: LIST
34755: LIST
34756: PUSH
34757: LD_INT 2
34759: PUSH
34760: LD_INT 0
34762: PUSH
34763: EMPTY
34764: LIST
34765: LIST
34766: PUSH
34767: LD_INT 2
34769: PUSH
34770: LD_INT 1
34772: PUSH
34773: EMPTY
34774: LIST
34775: LIST
34776: PUSH
34777: LD_INT 2
34779: PUSH
34780: LD_INT 2
34782: PUSH
34783: EMPTY
34784: LIST
34785: LIST
34786: PUSH
34787: LD_INT 1
34789: PUSH
34790: LD_INT 2
34792: PUSH
34793: EMPTY
34794: LIST
34795: LIST
34796: PUSH
34797: LD_INT 0
34799: PUSH
34800: LD_INT 2
34802: PUSH
34803: EMPTY
34804: LIST
34805: LIST
34806: PUSH
34807: LD_INT 1
34809: NEG
34810: PUSH
34811: LD_INT 1
34813: PUSH
34814: EMPTY
34815: LIST
34816: LIST
34817: PUSH
34818: LD_INT 2
34820: NEG
34821: PUSH
34822: LD_INT 0
34824: PUSH
34825: EMPTY
34826: LIST
34827: LIST
34828: PUSH
34829: LD_INT 2
34831: NEG
34832: PUSH
34833: LD_INT 1
34835: NEG
34836: PUSH
34837: EMPTY
34838: LIST
34839: LIST
34840: PUSH
34841: LD_INT 2
34843: NEG
34844: PUSH
34845: LD_INT 2
34847: NEG
34848: PUSH
34849: EMPTY
34850: LIST
34851: LIST
34852: PUSH
34853: EMPTY
34854: LIST
34855: LIST
34856: LIST
34857: LIST
34858: LIST
34859: LIST
34860: LIST
34861: LIST
34862: LIST
34863: LIST
34864: LIST
34865: LIST
34866: LIST
34867: LIST
34868: LIST
34869: LIST
34870: LIST
34871: LIST
34872: LIST
34873: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
34874: LD_ADDR_VAR 0 20
34878: PUSH
34879: LD_INT 0
34881: PUSH
34882: LD_INT 0
34884: PUSH
34885: EMPTY
34886: LIST
34887: LIST
34888: PUSH
34889: LD_INT 0
34891: PUSH
34892: LD_INT 1
34894: NEG
34895: PUSH
34896: EMPTY
34897: LIST
34898: LIST
34899: PUSH
34900: LD_INT 1
34902: PUSH
34903: LD_INT 0
34905: PUSH
34906: EMPTY
34907: LIST
34908: LIST
34909: PUSH
34910: LD_INT 1
34912: PUSH
34913: LD_INT 1
34915: PUSH
34916: EMPTY
34917: LIST
34918: LIST
34919: PUSH
34920: LD_INT 0
34922: PUSH
34923: LD_INT 1
34925: PUSH
34926: EMPTY
34927: LIST
34928: LIST
34929: PUSH
34930: LD_INT 1
34932: NEG
34933: PUSH
34934: LD_INT 0
34936: PUSH
34937: EMPTY
34938: LIST
34939: LIST
34940: PUSH
34941: LD_INT 1
34943: NEG
34944: PUSH
34945: LD_INT 1
34947: NEG
34948: PUSH
34949: EMPTY
34950: LIST
34951: LIST
34952: PUSH
34953: LD_INT 1
34955: NEG
34956: PUSH
34957: LD_INT 2
34959: NEG
34960: PUSH
34961: EMPTY
34962: LIST
34963: LIST
34964: PUSH
34965: LD_INT 0
34967: PUSH
34968: LD_INT 2
34970: NEG
34971: PUSH
34972: EMPTY
34973: LIST
34974: LIST
34975: PUSH
34976: LD_INT 1
34978: PUSH
34979: LD_INT 1
34981: NEG
34982: PUSH
34983: EMPTY
34984: LIST
34985: LIST
34986: PUSH
34987: LD_INT 2
34989: PUSH
34990: LD_INT 0
34992: PUSH
34993: EMPTY
34994: LIST
34995: LIST
34996: PUSH
34997: LD_INT 2
34999: PUSH
35000: LD_INT 1
35002: PUSH
35003: EMPTY
35004: LIST
35005: LIST
35006: PUSH
35007: LD_INT 2
35009: PUSH
35010: LD_INT 2
35012: PUSH
35013: EMPTY
35014: LIST
35015: LIST
35016: PUSH
35017: LD_INT 1
35019: PUSH
35020: LD_INT 2
35022: PUSH
35023: EMPTY
35024: LIST
35025: LIST
35026: PUSH
35027: LD_INT 0
35029: PUSH
35030: LD_INT 2
35032: PUSH
35033: EMPTY
35034: LIST
35035: LIST
35036: PUSH
35037: LD_INT 1
35039: NEG
35040: PUSH
35041: LD_INT 1
35043: PUSH
35044: EMPTY
35045: LIST
35046: LIST
35047: PUSH
35048: LD_INT 2
35050: NEG
35051: PUSH
35052: LD_INT 0
35054: PUSH
35055: EMPTY
35056: LIST
35057: LIST
35058: PUSH
35059: LD_INT 2
35061: NEG
35062: PUSH
35063: LD_INT 1
35065: NEG
35066: PUSH
35067: EMPTY
35068: LIST
35069: LIST
35070: PUSH
35071: LD_INT 2
35073: NEG
35074: PUSH
35075: LD_INT 2
35077: NEG
35078: PUSH
35079: EMPTY
35080: LIST
35081: LIST
35082: PUSH
35083: EMPTY
35084: LIST
35085: LIST
35086: LIST
35087: LIST
35088: LIST
35089: LIST
35090: LIST
35091: LIST
35092: LIST
35093: LIST
35094: LIST
35095: LIST
35096: LIST
35097: LIST
35098: LIST
35099: LIST
35100: LIST
35101: LIST
35102: LIST
35103: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
35104: LD_ADDR_VAR 0 21
35108: PUSH
35109: LD_INT 0
35111: PUSH
35112: LD_INT 0
35114: PUSH
35115: EMPTY
35116: LIST
35117: LIST
35118: PUSH
35119: LD_INT 0
35121: PUSH
35122: LD_INT 1
35124: NEG
35125: PUSH
35126: EMPTY
35127: LIST
35128: LIST
35129: PUSH
35130: LD_INT 1
35132: PUSH
35133: LD_INT 0
35135: PUSH
35136: EMPTY
35137: LIST
35138: LIST
35139: PUSH
35140: LD_INT 1
35142: PUSH
35143: LD_INT 1
35145: PUSH
35146: EMPTY
35147: LIST
35148: LIST
35149: PUSH
35150: LD_INT 0
35152: PUSH
35153: LD_INT 1
35155: PUSH
35156: EMPTY
35157: LIST
35158: LIST
35159: PUSH
35160: LD_INT 1
35162: NEG
35163: PUSH
35164: LD_INT 0
35166: PUSH
35167: EMPTY
35168: LIST
35169: LIST
35170: PUSH
35171: LD_INT 1
35173: NEG
35174: PUSH
35175: LD_INT 1
35177: NEG
35178: PUSH
35179: EMPTY
35180: LIST
35181: LIST
35182: PUSH
35183: LD_INT 1
35185: NEG
35186: PUSH
35187: LD_INT 2
35189: NEG
35190: PUSH
35191: EMPTY
35192: LIST
35193: LIST
35194: PUSH
35195: LD_INT 0
35197: PUSH
35198: LD_INT 2
35200: NEG
35201: PUSH
35202: EMPTY
35203: LIST
35204: LIST
35205: PUSH
35206: LD_INT 1
35208: PUSH
35209: LD_INT 1
35211: NEG
35212: PUSH
35213: EMPTY
35214: LIST
35215: LIST
35216: PUSH
35217: LD_INT 2
35219: PUSH
35220: LD_INT 0
35222: PUSH
35223: EMPTY
35224: LIST
35225: LIST
35226: PUSH
35227: LD_INT 2
35229: PUSH
35230: LD_INT 1
35232: PUSH
35233: EMPTY
35234: LIST
35235: LIST
35236: PUSH
35237: LD_INT 2
35239: PUSH
35240: LD_INT 2
35242: PUSH
35243: EMPTY
35244: LIST
35245: LIST
35246: PUSH
35247: LD_INT 1
35249: PUSH
35250: LD_INT 2
35252: PUSH
35253: EMPTY
35254: LIST
35255: LIST
35256: PUSH
35257: LD_INT 0
35259: PUSH
35260: LD_INT 2
35262: PUSH
35263: EMPTY
35264: LIST
35265: LIST
35266: PUSH
35267: LD_INT 1
35269: NEG
35270: PUSH
35271: LD_INT 1
35273: PUSH
35274: EMPTY
35275: LIST
35276: LIST
35277: PUSH
35278: LD_INT 2
35280: NEG
35281: PUSH
35282: LD_INT 0
35284: PUSH
35285: EMPTY
35286: LIST
35287: LIST
35288: PUSH
35289: LD_INT 2
35291: NEG
35292: PUSH
35293: LD_INT 1
35295: NEG
35296: PUSH
35297: EMPTY
35298: LIST
35299: LIST
35300: PUSH
35301: LD_INT 2
35303: NEG
35304: PUSH
35305: LD_INT 2
35307: NEG
35308: PUSH
35309: EMPTY
35310: LIST
35311: LIST
35312: PUSH
35313: EMPTY
35314: LIST
35315: LIST
35316: LIST
35317: LIST
35318: LIST
35319: LIST
35320: LIST
35321: LIST
35322: LIST
35323: LIST
35324: LIST
35325: LIST
35326: LIST
35327: LIST
35328: LIST
35329: LIST
35330: LIST
35331: LIST
35332: LIST
35333: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
35334: LD_ADDR_VAR 0 22
35338: PUSH
35339: LD_INT 0
35341: PUSH
35342: LD_INT 0
35344: PUSH
35345: EMPTY
35346: LIST
35347: LIST
35348: PUSH
35349: LD_INT 0
35351: PUSH
35352: LD_INT 1
35354: NEG
35355: PUSH
35356: EMPTY
35357: LIST
35358: LIST
35359: PUSH
35360: LD_INT 1
35362: PUSH
35363: LD_INT 0
35365: PUSH
35366: EMPTY
35367: LIST
35368: LIST
35369: PUSH
35370: LD_INT 1
35372: PUSH
35373: LD_INT 1
35375: PUSH
35376: EMPTY
35377: LIST
35378: LIST
35379: PUSH
35380: LD_INT 0
35382: PUSH
35383: LD_INT 1
35385: PUSH
35386: EMPTY
35387: LIST
35388: LIST
35389: PUSH
35390: LD_INT 1
35392: NEG
35393: PUSH
35394: LD_INT 0
35396: PUSH
35397: EMPTY
35398: LIST
35399: LIST
35400: PUSH
35401: LD_INT 1
35403: NEG
35404: PUSH
35405: LD_INT 1
35407: NEG
35408: PUSH
35409: EMPTY
35410: LIST
35411: LIST
35412: PUSH
35413: LD_INT 1
35415: NEG
35416: PUSH
35417: LD_INT 2
35419: NEG
35420: PUSH
35421: EMPTY
35422: LIST
35423: LIST
35424: PUSH
35425: LD_INT 0
35427: PUSH
35428: LD_INT 2
35430: NEG
35431: PUSH
35432: EMPTY
35433: LIST
35434: LIST
35435: PUSH
35436: LD_INT 1
35438: PUSH
35439: LD_INT 1
35441: NEG
35442: PUSH
35443: EMPTY
35444: LIST
35445: LIST
35446: PUSH
35447: LD_INT 2
35449: PUSH
35450: LD_INT 0
35452: PUSH
35453: EMPTY
35454: LIST
35455: LIST
35456: PUSH
35457: LD_INT 2
35459: PUSH
35460: LD_INT 1
35462: PUSH
35463: EMPTY
35464: LIST
35465: LIST
35466: PUSH
35467: LD_INT 2
35469: PUSH
35470: LD_INT 2
35472: PUSH
35473: EMPTY
35474: LIST
35475: LIST
35476: PUSH
35477: LD_INT 1
35479: PUSH
35480: LD_INT 2
35482: PUSH
35483: EMPTY
35484: LIST
35485: LIST
35486: PUSH
35487: LD_INT 0
35489: PUSH
35490: LD_INT 2
35492: PUSH
35493: EMPTY
35494: LIST
35495: LIST
35496: PUSH
35497: LD_INT 1
35499: NEG
35500: PUSH
35501: LD_INT 1
35503: PUSH
35504: EMPTY
35505: LIST
35506: LIST
35507: PUSH
35508: LD_INT 2
35510: NEG
35511: PUSH
35512: LD_INT 0
35514: PUSH
35515: EMPTY
35516: LIST
35517: LIST
35518: PUSH
35519: LD_INT 2
35521: NEG
35522: PUSH
35523: LD_INT 1
35525: NEG
35526: PUSH
35527: EMPTY
35528: LIST
35529: LIST
35530: PUSH
35531: LD_INT 2
35533: NEG
35534: PUSH
35535: LD_INT 2
35537: NEG
35538: PUSH
35539: EMPTY
35540: LIST
35541: LIST
35542: PUSH
35543: EMPTY
35544: LIST
35545: LIST
35546: LIST
35547: LIST
35548: LIST
35549: LIST
35550: LIST
35551: LIST
35552: LIST
35553: LIST
35554: LIST
35555: LIST
35556: LIST
35557: LIST
35558: LIST
35559: LIST
35560: LIST
35561: LIST
35562: LIST
35563: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
35564: LD_ADDR_VAR 0 23
35568: PUSH
35569: LD_INT 0
35571: PUSH
35572: LD_INT 0
35574: PUSH
35575: EMPTY
35576: LIST
35577: LIST
35578: PUSH
35579: LD_INT 0
35581: PUSH
35582: LD_INT 1
35584: NEG
35585: PUSH
35586: EMPTY
35587: LIST
35588: LIST
35589: PUSH
35590: LD_INT 1
35592: PUSH
35593: LD_INT 0
35595: PUSH
35596: EMPTY
35597: LIST
35598: LIST
35599: PUSH
35600: LD_INT 1
35602: PUSH
35603: LD_INT 1
35605: PUSH
35606: EMPTY
35607: LIST
35608: LIST
35609: PUSH
35610: LD_INT 0
35612: PUSH
35613: LD_INT 1
35615: PUSH
35616: EMPTY
35617: LIST
35618: LIST
35619: PUSH
35620: LD_INT 1
35622: NEG
35623: PUSH
35624: LD_INT 0
35626: PUSH
35627: EMPTY
35628: LIST
35629: LIST
35630: PUSH
35631: LD_INT 1
35633: NEG
35634: PUSH
35635: LD_INT 1
35637: NEG
35638: PUSH
35639: EMPTY
35640: LIST
35641: LIST
35642: PUSH
35643: LD_INT 1
35645: NEG
35646: PUSH
35647: LD_INT 2
35649: NEG
35650: PUSH
35651: EMPTY
35652: LIST
35653: LIST
35654: PUSH
35655: LD_INT 0
35657: PUSH
35658: LD_INT 2
35660: NEG
35661: PUSH
35662: EMPTY
35663: LIST
35664: LIST
35665: PUSH
35666: LD_INT 1
35668: PUSH
35669: LD_INT 1
35671: NEG
35672: PUSH
35673: EMPTY
35674: LIST
35675: LIST
35676: PUSH
35677: LD_INT 2
35679: PUSH
35680: LD_INT 0
35682: PUSH
35683: EMPTY
35684: LIST
35685: LIST
35686: PUSH
35687: LD_INT 2
35689: PUSH
35690: LD_INT 1
35692: PUSH
35693: EMPTY
35694: LIST
35695: LIST
35696: PUSH
35697: LD_INT 2
35699: PUSH
35700: LD_INT 2
35702: PUSH
35703: EMPTY
35704: LIST
35705: LIST
35706: PUSH
35707: LD_INT 1
35709: PUSH
35710: LD_INT 2
35712: PUSH
35713: EMPTY
35714: LIST
35715: LIST
35716: PUSH
35717: LD_INT 0
35719: PUSH
35720: LD_INT 2
35722: PUSH
35723: EMPTY
35724: LIST
35725: LIST
35726: PUSH
35727: LD_INT 1
35729: NEG
35730: PUSH
35731: LD_INT 1
35733: PUSH
35734: EMPTY
35735: LIST
35736: LIST
35737: PUSH
35738: LD_INT 2
35740: NEG
35741: PUSH
35742: LD_INT 0
35744: PUSH
35745: EMPTY
35746: LIST
35747: LIST
35748: PUSH
35749: LD_INT 2
35751: NEG
35752: PUSH
35753: LD_INT 1
35755: NEG
35756: PUSH
35757: EMPTY
35758: LIST
35759: LIST
35760: PUSH
35761: LD_INT 2
35763: NEG
35764: PUSH
35765: LD_INT 2
35767: NEG
35768: PUSH
35769: EMPTY
35770: LIST
35771: LIST
35772: PUSH
35773: LD_INT 2
35775: NEG
35776: PUSH
35777: LD_INT 3
35779: NEG
35780: PUSH
35781: EMPTY
35782: LIST
35783: LIST
35784: PUSH
35785: LD_INT 1
35787: NEG
35788: PUSH
35789: LD_INT 3
35791: NEG
35792: PUSH
35793: EMPTY
35794: LIST
35795: LIST
35796: PUSH
35797: LD_INT 1
35799: PUSH
35800: LD_INT 2
35802: NEG
35803: PUSH
35804: EMPTY
35805: LIST
35806: LIST
35807: PUSH
35808: LD_INT 2
35810: PUSH
35811: LD_INT 1
35813: NEG
35814: PUSH
35815: EMPTY
35816: LIST
35817: LIST
35818: PUSH
35819: EMPTY
35820: LIST
35821: LIST
35822: LIST
35823: LIST
35824: LIST
35825: LIST
35826: LIST
35827: LIST
35828: LIST
35829: LIST
35830: LIST
35831: LIST
35832: LIST
35833: LIST
35834: LIST
35835: LIST
35836: LIST
35837: LIST
35838: LIST
35839: LIST
35840: LIST
35841: LIST
35842: LIST
35843: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
35844: LD_ADDR_VAR 0 24
35848: PUSH
35849: LD_INT 0
35851: PUSH
35852: LD_INT 0
35854: PUSH
35855: EMPTY
35856: LIST
35857: LIST
35858: PUSH
35859: LD_INT 0
35861: PUSH
35862: LD_INT 1
35864: NEG
35865: PUSH
35866: EMPTY
35867: LIST
35868: LIST
35869: PUSH
35870: LD_INT 1
35872: PUSH
35873: LD_INT 0
35875: PUSH
35876: EMPTY
35877: LIST
35878: LIST
35879: PUSH
35880: LD_INT 1
35882: PUSH
35883: LD_INT 1
35885: PUSH
35886: EMPTY
35887: LIST
35888: LIST
35889: PUSH
35890: LD_INT 0
35892: PUSH
35893: LD_INT 1
35895: PUSH
35896: EMPTY
35897: LIST
35898: LIST
35899: PUSH
35900: LD_INT 1
35902: NEG
35903: PUSH
35904: LD_INT 0
35906: PUSH
35907: EMPTY
35908: LIST
35909: LIST
35910: PUSH
35911: LD_INT 1
35913: NEG
35914: PUSH
35915: LD_INT 1
35917: NEG
35918: PUSH
35919: EMPTY
35920: LIST
35921: LIST
35922: PUSH
35923: LD_INT 1
35925: NEG
35926: PUSH
35927: LD_INT 2
35929: NEG
35930: PUSH
35931: EMPTY
35932: LIST
35933: LIST
35934: PUSH
35935: LD_INT 0
35937: PUSH
35938: LD_INT 2
35940: NEG
35941: PUSH
35942: EMPTY
35943: LIST
35944: LIST
35945: PUSH
35946: LD_INT 1
35948: PUSH
35949: LD_INT 1
35951: NEG
35952: PUSH
35953: EMPTY
35954: LIST
35955: LIST
35956: PUSH
35957: LD_INT 2
35959: PUSH
35960: LD_INT 0
35962: PUSH
35963: EMPTY
35964: LIST
35965: LIST
35966: PUSH
35967: LD_INT 2
35969: PUSH
35970: LD_INT 1
35972: PUSH
35973: EMPTY
35974: LIST
35975: LIST
35976: PUSH
35977: LD_INT 2
35979: PUSH
35980: LD_INT 2
35982: PUSH
35983: EMPTY
35984: LIST
35985: LIST
35986: PUSH
35987: LD_INT 1
35989: PUSH
35990: LD_INT 2
35992: PUSH
35993: EMPTY
35994: LIST
35995: LIST
35996: PUSH
35997: LD_INT 0
35999: PUSH
36000: LD_INT 2
36002: PUSH
36003: EMPTY
36004: LIST
36005: LIST
36006: PUSH
36007: LD_INT 1
36009: NEG
36010: PUSH
36011: LD_INT 1
36013: PUSH
36014: EMPTY
36015: LIST
36016: LIST
36017: PUSH
36018: LD_INT 2
36020: NEG
36021: PUSH
36022: LD_INT 0
36024: PUSH
36025: EMPTY
36026: LIST
36027: LIST
36028: PUSH
36029: LD_INT 2
36031: NEG
36032: PUSH
36033: LD_INT 1
36035: NEG
36036: PUSH
36037: EMPTY
36038: LIST
36039: LIST
36040: PUSH
36041: LD_INT 2
36043: NEG
36044: PUSH
36045: LD_INT 2
36047: NEG
36048: PUSH
36049: EMPTY
36050: LIST
36051: LIST
36052: PUSH
36053: LD_INT 1
36055: PUSH
36056: LD_INT 2
36058: NEG
36059: PUSH
36060: EMPTY
36061: LIST
36062: LIST
36063: PUSH
36064: LD_INT 2
36066: PUSH
36067: LD_INT 1
36069: NEG
36070: PUSH
36071: EMPTY
36072: LIST
36073: LIST
36074: PUSH
36075: LD_INT 3
36077: PUSH
36078: LD_INT 1
36080: PUSH
36081: EMPTY
36082: LIST
36083: LIST
36084: PUSH
36085: LD_INT 3
36087: PUSH
36088: LD_INT 2
36090: PUSH
36091: EMPTY
36092: LIST
36093: LIST
36094: PUSH
36095: EMPTY
36096: LIST
36097: LIST
36098: LIST
36099: LIST
36100: LIST
36101: LIST
36102: LIST
36103: LIST
36104: LIST
36105: LIST
36106: LIST
36107: LIST
36108: LIST
36109: LIST
36110: LIST
36111: LIST
36112: LIST
36113: LIST
36114: LIST
36115: LIST
36116: LIST
36117: LIST
36118: LIST
36119: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
36120: LD_ADDR_VAR 0 25
36124: PUSH
36125: LD_INT 0
36127: PUSH
36128: LD_INT 0
36130: PUSH
36131: EMPTY
36132: LIST
36133: LIST
36134: PUSH
36135: LD_INT 0
36137: PUSH
36138: LD_INT 1
36140: NEG
36141: PUSH
36142: EMPTY
36143: LIST
36144: LIST
36145: PUSH
36146: LD_INT 1
36148: PUSH
36149: LD_INT 0
36151: PUSH
36152: EMPTY
36153: LIST
36154: LIST
36155: PUSH
36156: LD_INT 1
36158: PUSH
36159: LD_INT 1
36161: PUSH
36162: EMPTY
36163: LIST
36164: LIST
36165: PUSH
36166: LD_INT 0
36168: PUSH
36169: LD_INT 1
36171: PUSH
36172: EMPTY
36173: LIST
36174: LIST
36175: PUSH
36176: LD_INT 1
36178: NEG
36179: PUSH
36180: LD_INT 0
36182: PUSH
36183: EMPTY
36184: LIST
36185: LIST
36186: PUSH
36187: LD_INT 1
36189: NEG
36190: PUSH
36191: LD_INT 1
36193: NEG
36194: PUSH
36195: EMPTY
36196: LIST
36197: LIST
36198: PUSH
36199: LD_INT 1
36201: NEG
36202: PUSH
36203: LD_INT 2
36205: NEG
36206: PUSH
36207: EMPTY
36208: LIST
36209: LIST
36210: PUSH
36211: LD_INT 0
36213: PUSH
36214: LD_INT 2
36216: NEG
36217: PUSH
36218: EMPTY
36219: LIST
36220: LIST
36221: PUSH
36222: LD_INT 1
36224: PUSH
36225: LD_INT 1
36227: NEG
36228: PUSH
36229: EMPTY
36230: LIST
36231: LIST
36232: PUSH
36233: LD_INT 2
36235: PUSH
36236: LD_INT 0
36238: PUSH
36239: EMPTY
36240: LIST
36241: LIST
36242: PUSH
36243: LD_INT 2
36245: PUSH
36246: LD_INT 1
36248: PUSH
36249: EMPTY
36250: LIST
36251: LIST
36252: PUSH
36253: LD_INT 2
36255: PUSH
36256: LD_INT 2
36258: PUSH
36259: EMPTY
36260: LIST
36261: LIST
36262: PUSH
36263: LD_INT 1
36265: PUSH
36266: LD_INT 2
36268: PUSH
36269: EMPTY
36270: LIST
36271: LIST
36272: PUSH
36273: LD_INT 0
36275: PUSH
36276: LD_INT 2
36278: PUSH
36279: EMPTY
36280: LIST
36281: LIST
36282: PUSH
36283: LD_INT 1
36285: NEG
36286: PUSH
36287: LD_INT 1
36289: PUSH
36290: EMPTY
36291: LIST
36292: LIST
36293: PUSH
36294: LD_INT 2
36296: NEG
36297: PUSH
36298: LD_INT 0
36300: PUSH
36301: EMPTY
36302: LIST
36303: LIST
36304: PUSH
36305: LD_INT 2
36307: NEG
36308: PUSH
36309: LD_INT 1
36311: NEG
36312: PUSH
36313: EMPTY
36314: LIST
36315: LIST
36316: PUSH
36317: LD_INT 2
36319: NEG
36320: PUSH
36321: LD_INT 2
36323: NEG
36324: PUSH
36325: EMPTY
36326: LIST
36327: LIST
36328: PUSH
36329: LD_INT 3
36331: PUSH
36332: LD_INT 1
36334: PUSH
36335: EMPTY
36336: LIST
36337: LIST
36338: PUSH
36339: LD_INT 3
36341: PUSH
36342: LD_INT 2
36344: PUSH
36345: EMPTY
36346: LIST
36347: LIST
36348: PUSH
36349: LD_INT 2
36351: PUSH
36352: LD_INT 3
36354: PUSH
36355: EMPTY
36356: LIST
36357: LIST
36358: PUSH
36359: LD_INT 1
36361: PUSH
36362: LD_INT 3
36364: PUSH
36365: EMPTY
36366: LIST
36367: LIST
36368: PUSH
36369: EMPTY
36370: LIST
36371: LIST
36372: LIST
36373: LIST
36374: LIST
36375: LIST
36376: LIST
36377: LIST
36378: LIST
36379: LIST
36380: LIST
36381: LIST
36382: LIST
36383: LIST
36384: LIST
36385: LIST
36386: LIST
36387: LIST
36388: LIST
36389: LIST
36390: LIST
36391: LIST
36392: LIST
36393: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
36394: LD_ADDR_VAR 0 26
36398: PUSH
36399: LD_INT 0
36401: PUSH
36402: LD_INT 0
36404: PUSH
36405: EMPTY
36406: LIST
36407: LIST
36408: PUSH
36409: LD_INT 0
36411: PUSH
36412: LD_INT 1
36414: NEG
36415: PUSH
36416: EMPTY
36417: LIST
36418: LIST
36419: PUSH
36420: LD_INT 1
36422: PUSH
36423: LD_INT 0
36425: PUSH
36426: EMPTY
36427: LIST
36428: LIST
36429: PUSH
36430: LD_INT 1
36432: PUSH
36433: LD_INT 1
36435: PUSH
36436: EMPTY
36437: LIST
36438: LIST
36439: PUSH
36440: LD_INT 0
36442: PUSH
36443: LD_INT 1
36445: PUSH
36446: EMPTY
36447: LIST
36448: LIST
36449: PUSH
36450: LD_INT 1
36452: NEG
36453: PUSH
36454: LD_INT 0
36456: PUSH
36457: EMPTY
36458: LIST
36459: LIST
36460: PUSH
36461: LD_INT 1
36463: NEG
36464: PUSH
36465: LD_INT 1
36467: NEG
36468: PUSH
36469: EMPTY
36470: LIST
36471: LIST
36472: PUSH
36473: LD_INT 1
36475: NEG
36476: PUSH
36477: LD_INT 2
36479: NEG
36480: PUSH
36481: EMPTY
36482: LIST
36483: LIST
36484: PUSH
36485: LD_INT 0
36487: PUSH
36488: LD_INT 2
36490: NEG
36491: PUSH
36492: EMPTY
36493: LIST
36494: LIST
36495: PUSH
36496: LD_INT 1
36498: PUSH
36499: LD_INT 1
36501: NEG
36502: PUSH
36503: EMPTY
36504: LIST
36505: LIST
36506: PUSH
36507: LD_INT 2
36509: PUSH
36510: LD_INT 0
36512: PUSH
36513: EMPTY
36514: LIST
36515: LIST
36516: PUSH
36517: LD_INT 2
36519: PUSH
36520: LD_INT 1
36522: PUSH
36523: EMPTY
36524: LIST
36525: LIST
36526: PUSH
36527: LD_INT 2
36529: PUSH
36530: LD_INT 2
36532: PUSH
36533: EMPTY
36534: LIST
36535: LIST
36536: PUSH
36537: LD_INT 1
36539: PUSH
36540: LD_INT 2
36542: PUSH
36543: EMPTY
36544: LIST
36545: LIST
36546: PUSH
36547: LD_INT 0
36549: PUSH
36550: LD_INT 2
36552: PUSH
36553: EMPTY
36554: LIST
36555: LIST
36556: PUSH
36557: LD_INT 1
36559: NEG
36560: PUSH
36561: LD_INT 1
36563: PUSH
36564: EMPTY
36565: LIST
36566: LIST
36567: PUSH
36568: LD_INT 2
36570: NEG
36571: PUSH
36572: LD_INT 0
36574: PUSH
36575: EMPTY
36576: LIST
36577: LIST
36578: PUSH
36579: LD_INT 2
36581: NEG
36582: PUSH
36583: LD_INT 1
36585: NEG
36586: PUSH
36587: EMPTY
36588: LIST
36589: LIST
36590: PUSH
36591: LD_INT 2
36593: NEG
36594: PUSH
36595: LD_INT 2
36597: NEG
36598: PUSH
36599: EMPTY
36600: LIST
36601: LIST
36602: PUSH
36603: LD_INT 2
36605: PUSH
36606: LD_INT 3
36608: PUSH
36609: EMPTY
36610: LIST
36611: LIST
36612: PUSH
36613: LD_INT 1
36615: PUSH
36616: LD_INT 3
36618: PUSH
36619: EMPTY
36620: LIST
36621: LIST
36622: PUSH
36623: LD_INT 1
36625: NEG
36626: PUSH
36627: LD_INT 2
36629: PUSH
36630: EMPTY
36631: LIST
36632: LIST
36633: PUSH
36634: LD_INT 2
36636: NEG
36637: PUSH
36638: LD_INT 1
36640: PUSH
36641: EMPTY
36642: LIST
36643: LIST
36644: PUSH
36645: EMPTY
36646: LIST
36647: LIST
36648: LIST
36649: LIST
36650: LIST
36651: LIST
36652: LIST
36653: LIST
36654: LIST
36655: LIST
36656: LIST
36657: LIST
36658: LIST
36659: LIST
36660: LIST
36661: LIST
36662: LIST
36663: LIST
36664: LIST
36665: LIST
36666: LIST
36667: LIST
36668: LIST
36669: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
36670: LD_ADDR_VAR 0 27
36674: PUSH
36675: LD_INT 0
36677: PUSH
36678: LD_INT 0
36680: PUSH
36681: EMPTY
36682: LIST
36683: LIST
36684: PUSH
36685: LD_INT 0
36687: PUSH
36688: LD_INT 1
36690: NEG
36691: PUSH
36692: EMPTY
36693: LIST
36694: LIST
36695: PUSH
36696: LD_INT 1
36698: PUSH
36699: LD_INT 0
36701: PUSH
36702: EMPTY
36703: LIST
36704: LIST
36705: PUSH
36706: LD_INT 1
36708: PUSH
36709: LD_INT 1
36711: PUSH
36712: EMPTY
36713: LIST
36714: LIST
36715: PUSH
36716: LD_INT 0
36718: PUSH
36719: LD_INT 1
36721: PUSH
36722: EMPTY
36723: LIST
36724: LIST
36725: PUSH
36726: LD_INT 1
36728: NEG
36729: PUSH
36730: LD_INT 0
36732: PUSH
36733: EMPTY
36734: LIST
36735: LIST
36736: PUSH
36737: LD_INT 1
36739: NEG
36740: PUSH
36741: LD_INT 1
36743: NEG
36744: PUSH
36745: EMPTY
36746: LIST
36747: LIST
36748: PUSH
36749: LD_INT 1
36751: NEG
36752: PUSH
36753: LD_INT 2
36755: NEG
36756: PUSH
36757: EMPTY
36758: LIST
36759: LIST
36760: PUSH
36761: LD_INT 0
36763: PUSH
36764: LD_INT 2
36766: NEG
36767: PUSH
36768: EMPTY
36769: LIST
36770: LIST
36771: PUSH
36772: LD_INT 1
36774: PUSH
36775: LD_INT 1
36777: NEG
36778: PUSH
36779: EMPTY
36780: LIST
36781: LIST
36782: PUSH
36783: LD_INT 2
36785: PUSH
36786: LD_INT 0
36788: PUSH
36789: EMPTY
36790: LIST
36791: LIST
36792: PUSH
36793: LD_INT 2
36795: PUSH
36796: LD_INT 1
36798: PUSH
36799: EMPTY
36800: LIST
36801: LIST
36802: PUSH
36803: LD_INT 2
36805: PUSH
36806: LD_INT 2
36808: PUSH
36809: EMPTY
36810: LIST
36811: LIST
36812: PUSH
36813: LD_INT 1
36815: PUSH
36816: LD_INT 2
36818: PUSH
36819: EMPTY
36820: LIST
36821: LIST
36822: PUSH
36823: LD_INT 0
36825: PUSH
36826: LD_INT 2
36828: PUSH
36829: EMPTY
36830: LIST
36831: LIST
36832: PUSH
36833: LD_INT 1
36835: NEG
36836: PUSH
36837: LD_INT 1
36839: PUSH
36840: EMPTY
36841: LIST
36842: LIST
36843: PUSH
36844: LD_INT 2
36846: NEG
36847: PUSH
36848: LD_INT 0
36850: PUSH
36851: EMPTY
36852: LIST
36853: LIST
36854: PUSH
36855: LD_INT 2
36857: NEG
36858: PUSH
36859: LD_INT 1
36861: NEG
36862: PUSH
36863: EMPTY
36864: LIST
36865: LIST
36866: PUSH
36867: LD_INT 2
36869: NEG
36870: PUSH
36871: LD_INT 2
36873: NEG
36874: PUSH
36875: EMPTY
36876: LIST
36877: LIST
36878: PUSH
36879: LD_INT 1
36881: NEG
36882: PUSH
36883: LD_INT 2
36885: PUSH
36886: EMPTY
36887: LIST
36888: LIST
36889: PUSH
36890: LD_INT 2
36892: NEG
36893: PUSH
36894: LD_INT 1
36896: PUSH
36897: EMPTY
36898: LIST
36899: LIST
36900: PUSH
36901: LD_INT 3
36903: NEG
36904: PUSH
36905: LD_INT 1
36907: NEG
36908: PUSH
36909: EMPTY
36910: LIST
36911: LIST
36912: PUSH
36913: LD_INT 3
36915: NEG
36916: PUSH
36917: LD_INT 2
36919: NEG
36920: PUSH
36921: EMPTY
36922: LIST
36923: LIST
36924: PUSH
36925: EMPTY
36926: LIST
36927: LIST
36928: LIST
36929: LIST
36930: LIST
36931: LIST
36932: LIST
36933: LIST
36934: LIST
36935: LIST
36936: LIST
36937: LIST
36938: LIST
36939: LIST
36940: LIST
36941: LIST
36942: LIST
36943: LIST
36944: LIST
36945: LIST
36946: LIST
36947: LIST
36948: LIST
36949: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
36950: LD_ADDR_VAR 0 28
36954: PUSH
36955: LD_INT 0
36957: PUSH
36958: LD_INT 0
36960: PUSH
36961: EMPTY
36962: LIST
36963: LIST
36964: PUSH
36965: LD_INT 0
36967: PUSH
36968: LD_INT 1
36970: NEG
36971: PUSH
36972: EMPTY
36973: LIST
36974: LIST
36975: PUSH
36976: LD_INT 1
36978: PUSH
36979: LD_INT 0
36981: PUSH
36982: EMPTY
36983: LIST
36984: LIST
36985: PUSH
36986: LD_INT 1
36988: PUSH
36989: LD_INT 1
36991: PUSH
36992: EMPTY
36993: LIST
36994: LIST
36995: PUSH
36996: LD_INT 0
36998: PUSH
36999: LD_INT 1
37001: PUSH
37002: EMPTY
37003: LIST
37004: LIST
37005: PUSH
37006: LD_INT 1
37008: NEG
37009: PUSH
37010: LD_INT 0
37012: PUSH
37013: EMPTY
37014: LIST
37015: LIST
37016: PUSH
37017: LD_INT 1
37019: NEG
37020: PUSH
37021: LD_INT 1
37023: NEG
37024: PUSH
37025: EMPTY
37026: LIST
37027: LIST
37028: PUSH
37029: LD_INT 1
37031: NEG
37032: PUSH
37033: LD_INT 2
37035: NEG
37036: PUSH
37037: EMPTY
37038: LIST
37039: LIST
37040: PUSH
37041: LD_INT 0
37043: PUSH
37044: LD_INT 2
37046: NEG
37047: PUSH
37048: EMPTY
37049: LIST
37050: LIST
37051: PUSH
37052: LD_INT 1
37054: PUSH
37055: LD_INT 1
37057: NEG
37058: PUSH
37059: EMPTY
37060: LIST
37061: LIST
37062: PUSH
37063: LD_INT 2
37065: PUSH
37066: LD_INT 0
37068: PUSH
37069: EMPTY
37070: LIST
37071: LIST
37072: PUSH
37073: LD_INT 2
37075: PUSH
37076: LD_INT 1
37078: PUSH
37079: EMPTY
37080: LIST
37081: LIST
37082: PUSH
37083: LD_INT 2
37085: PUSH
37086: LD_INT 2
37088: PUSH
37089: EMPTY
37090: LIST
37091: LIST
37092: PUSH
37093: LD_INT 1
37095: PUSH
37096: LD_INT 2
37098: PUSH
37099: EMPTY
37100: LIST
37101: LIST
37102: PUSH
37103: LD_INT 0
37105: PUSH
37106: LD_INT 2
37108: PUSH
37109: EMPTY
37110: LIST
37111: LIST
37112: PUSH
37113: LD_INT 1
37115: NEG
37116: PUSH
37117: LD_INT 1
37119: PUSH
37120: EMPTY
37121: LIST
37122: LIST
37123: PUSH
37124: LD_INT 2
37126: NEG
37127: PUSH
37128: LD_INT 0
37130: PUSH
37131: EMPTY
37132: LIST
37133: LIST
37134: PUSH
37135: LD_INT 2
37137: NEG
37138: PUSH
37139: LD_INT 1
37141: NEG
37142: PUSH
37143: EMPTY
37144: LIST
37145: LIST
37146: PUSH
37147: LD_INT 2
37149: NEG
37150: PUSH
37151: LD_INT 2
37153: NEG
37154: PUSH
37155: EMPTY
37156: LIST
37157: LIST
37158: PUSH
37159: LD_INT 2
37161: NEG
37162: PUSH
37163: LD_INT 3
37165: NEG
37166: PUSH
37167: EMPTY
37168: LIST
37169: LIST
37170: PUSH
37171: LD_INT 1
37173: NEG
37174: PUSH
37175: LD_INT 3
37177: NEG
37178: PUSH
37179: EMPTY
37180: LIST
37181: LIST
37182: PUSH
37183: LD_INT 3
37185: NEG
37186: PUSH
37187: LD_INT 1
37189: NEG
37190: PUSH
37191: EMPTY
37192: LIST
37193: LIST
37194: PUSH
37195: LD_INT 3
37197: NEG
37198: PUSH
37199: LD_INT 2
37201: NEG
37202: PUSH
37203: EMPTY
37204: LIST
37205: LIST
37206: PUSH
37207: EMPTY
37208: LIST
37209: LIST
37210: LIST
37211: LIST
37212: LIST
37213: LIST
37214: LIST
37215: LIST
37216: LIST
37217: LIST
37218: LIST
37219: LIST
37220: LIST
37221: LIST
37222: LIST
37223: LIST
37224: LIST
37225: LIST
37226: LIST
37227: LIST
37228: LIST
37229: LIST
37230: LIST
37231: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
37232: LD_ADDR_VAR 0 29
37236: PUSH
37237: LD_INT 0
37239: PUSH
37240: LD_INT 0
37242: PUSH
37243: EMPTY
37244: LIST
37245: LIST
37246: PUSH
37247: LD_INT 0
37249: PUSH
37250: LD_INT 1
37252: NEG
37253: PUSH
37254: EMPTY
37255: LIST
37256: LIST
37257: PUSH
37258: LD_INT 1
37260: PUSH
37261: LD_INT 0
37263: PUSH
37264: EMPTY
37265: LIST
37266: LIST
37267: PUSH
37268: LD_INT 1
37270: PUSH
37271: LD_INT 1
37273: PUSH
37274: EMPTY
37275: LIST
37276: LIST
37277: PUSH
37278: LD_INT 0
37280: PUSH
37281: LD_INT 1
37283: PUSH
37284: EMPTY
37285: LIST
37286: LIST
37287: PUSH
37288: LD_INT 1
37290: NEG
37291: PUSH
37292: LD_INT 0
37294: PUSH
37295: EMPTY
37296: LIST
37297: LIST
37298: PUSH
37299: LD_INT 1
37301: NEG
37302: PUSH
37303: LD_INT 1
37305: NEG
37306: PUSH
37307: EMPTY
37308: LIST
37309: LIST
37310: PUSH
37311: LD_INT 1
37313: NEG
37314: PUSH
37315: LD_INT 2
37317: NEG
37318: PUSH
37319: EMPTY
37320: LIST
37321: LIST
37322: PUSH
37323: LD_INT 0
37325: PUSH
37326: LD_INT 2
37328: NEG
37329: PUSH
37330: EMPTY
37331: LIST
37332: LIST
37333: PUSH
37334: LD_INT 1
37336: PUSH
37337: LD_INT 1
37339: NEG
37340: PUSH
37341: EMPTY
37342: LIST
37343: LIST
37344: PUSH
37345: LD_INT 2
37347: PUSH
37348: LD_INT 0
37350: PUSH
37351: EMPTY
37352: LIST
37353: LIST
37354: PUSH
37355: LD_INT 2
37357: PUSH
37358: LD_INT 1
37360: PUSH
37361: EMPTY
37362: LIST
37363: LIST
37364: PUSH
37365: LD_INT 1
37367: PUSH
37368: LD_INT 2
37370: PUSH
37371: EMPTY
37372: LIST
37373: LIST
37374: PUSH
37375: LD_INT 0
37377: PUSH
37378: LD_INT 2
37380: PUSH
37381: EMPTY
37382: LIST
37383: LIST
37384: PUSH
37385: LD_INT 1
37387: NEG
37388: PUSH
37389: LD_INT 1
37391: PUSH
37392: EMPTY
37393: LIST
37394: LIST
37395: PUSH
37396: LD_INT 2
37398: NEG
37399: PUSH
37400: LD_INT 1
37402: NEG
37403: PUSH
37404: EMPTY
37405: LIST
37406: LIST
37407: PUSH
37408: LD_INT 2
37410: NEG
37411: PUSH
37412: LD_INT 2
37414: NEG
37415: PUSH
37416: EMPTY
37417: LIST
37418: LIST
37419: PUSH
37420: LD_INT 2
37422: NEG
37423: PUSH
37424: LD_INT 3
37426: NEG
37427: PUSH
37428: EMPTY
37429: LIST
37430: LIST
37431: PUSH
37432: LD_INT 2
37434: PUSH
37435: LD_INT 1
37437: NEG
37438: PUSH
37439: EMPTY
37440: LIST
37441: LIST
37442: PUSH
37443: LD_INT 3
37445: PUSH
37446: LD_INT 1
37448: PUSH
37449: EMPTY
37450: LIST
37451: LIST
37452: PUSH
37453: LD_INT 1
37455: PUSH
37456: LD_INT 3
37458: PUSH
37459: EMPTY
37460: LIST
37461: LIST
37462: PUSH
37463: LD_INT 1
37465: NEG
37466: PUSH
37467: LD_INT 2
37469: PUSH
37470: EMPTY
37471: LIST
37472: LIST
37473: PUSH
37474: LD_INT 3
37476: NEG
37477: PUSH
37478: LD_INT 2
37480: NEG
37481: PUSH
37482: EMPTY
37483: LIST
37484: LIST
37485: PUSH
37486: EMPTY
37487: LIST
37488: LIST
37489: LIST
37490: LIST
37491: LIST
37492: LIST
37493: LIST
37494: LIST
37495: LIST
37496: LIST
37497: LIST
37498: LIST
37499: LIST
37500: LIST
37501: LIST
37502: LIST
37503: LIST
37504: LIST
37505: LIST
37506: LIST
37507: LIST
37508: LIST
37509: LIST
37510: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
37511: LD_ADDR_VAR 0 30
37515: PUSH
37516: LD_INT 0
37518: PUSH
37519: LD_INT 0
37521: PUSH
37522: EMPTY
37523: LIST
37524: LIST
37525: PUSH
37526: LD_INT 0
37528: PUSH
37529: LD_INT 1
37531: NEG
37532: PUSH
37533: EMPTY
37534: LIST
37535: LIST
37536: PUSH
37537: LD_INT 1
37539: PUSH
37540: LD_INT 0
37542: PUSH
37543: EMPTY
37544: LIST
37545: LIST
37546: PUSH
37547: LD_INT 1
37549: PUSH
37550: LD_INT 1
37552: PUSH
37553: EMPTY
37554: LIST
37555: LIST
37556: PUSH
37557: LD_INT 0
37559: PUSH
37560: LD_INT 1
37562: PUSH
37563: EMPTY
37564: LIST
37565: LIST
37566: PUSH
37567: LD_INT 1
37569: NEG
37570: PUSH
37571: LD_INT 0
37573: PUSH
37574: EMPTY
37575: LIST
37576: LIST
37577: PUSH
37578: LD_INT 1
37580: NEG
37581: PUSH
37582: LD_INT 1
37584: NEG
37585: PUSH
37586: EMPTY
37587: LIST
37588: LIST
37589: PUSH
37590: LD_INT 1
37592: NEG
37593: PUSH
37594: LD_INT 2
37596: NEG
37597: PUSH
37598: EMPTY
37599: LIST
37600: LIST
37601: PUSH
37602: LD_INT 0
37604: PUSH
37605: LD_INT 2
37607: NEG
37608: PUSH
37609: EMPTY
37610: LIST
37611: LIST
37612: PUSH
37613: LD_INT 1
37615: PUSH
37616: LD_INT 1
37618: NEG
37619: PUSH
37620: EMPTY
37621: LIST
37622: LIST
37623: PUSH
37624: LD_INT 2
37626: PUSH
37627: LD_INT 0
37629: PUSH
37630: EMPTY
37631: LIST
37632: LIST
37633: PUSH
37634: LD_INT 2
37636: PUSH
37637: LD_INT 1
37639: PUSH
37640: EMPTY
37641: LIST
37642: LIST
37643: PUSH
37644: LD_INT 2
37646: PUSH
37647: LD_INT 2
37649: PUSH
37650: EMPTY
37651: LIST
37652: LIST
37653: PUSH
37654: LD_INT 1
37656: PUSH
37657: LD_INT 2
37659: PUSH
37660: EMPTY
37661: LIST
37662: LIST
37663: PUSH
37664: LD_INT 1
37666: NEG
37667: PUSH
37668: LD_INT 1
37670: PUSH
37671: EMPTY
37672: LIST
37673: LIST
37674: PUSH
37675: LD_INT 2
37677: NEG
37678: PUSH
37679: LD_INT 0
37681: PUSH
37682: EMPTY
37683: LIST
37684: LIST
37685: PUSH
37686: LD_INT 2
37688: NEG
37689: PUSH
37690: LD_INT 1
37692: NEG
37693: PUSH
37694: EMPTY
37695: LIST
37696: LIST
37697: PUSH
37698: LD_INT 1
37700: NEG
37701: PUSH
37702: LD_INT 3
37704: NEG
37705: PUSH
37706: EMPTY
37707: LIST
37708: LIST
37709: PUSH
37710: LD_INT 1
37712: PUSH
37713: LD_INT 2
37715: NEG
37716: PUSH
37717: EMPTY
37718: LIST
37719: LIST
37720: PUSH
37721: LD_INT 3
37723: PUSH
37724: LD_INT 2
37726: PUSH
37727: EMPTY
37728: LIST
37729: LIST
37730: PUSH
37731: LD_INT 2
37733: PUSH
37734: LD_INT 3
37736: PUSH
37737: EMPTY
37738: LIST
37739: LIST
37740: PUSH
37741: LD_INT 2
37743: NEG
37744: PUSH
37745: LD_INT 1
37747: PUSH
37748: EMPTY
37749: LIST
37750: LIST
37751: PUSH
37752: LD_INT 3
37754: NEG
37755: PUSH
37756: LD_INT 1
37758: NEG
37759: PUSH
37760: EMPTY
37761: LIST
37762: LIST
37763: PUSH
37764: EMPTY
37765: LIST
37766: LIST
37767: LIST
37768: LIST
37769: LIST
37770: LIST
37771: LIST
37772: LIST
37773: LIST
37774: LIST
37775: LIST
37776: LIST
37777: LIST
37778: LIST
37779: LIST
37780: LIST
37781: LIST
37782: LIST
37783: LIST
37784: LIST
37785: LIST
37786: LIST
37787: LIST
37788: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
37789: LD_ADDR_VAR 0 31
37793: PUSH
37794: LD_INT 0
37796: PUSH
37797: LD_INT 0
37799: PUSH
37800: EMPTY
37801: LIST
37802: LIST
37803: PUSH
37804: LD_INT 0
37806: PUSH
37807: LD_INT 1
37809: NEG
37810: PUSH
37811: EMPTY
37812: LIST
37813: LIST
37814: PUSH
37815: LD_INT 1
37817: PUSH
37818: LD_INT 0
37820: PUSH
37821: EMPTY
37822: LIST
37823: LIST
37824: PUSH
37825: LD_INT 1
37827: PUSH
37828: LD_INT 1
37830: PUSH
37831: EMPTY
37832: LIST
37833: LIST
37834: PUSH
37835: LD_INT 0
37837: PUSH
37838: LD_INT 1
37840: PUSH
37841: EMPTY
37842: LIST
37843: LIST
37844: PUSH
37845: LD_INT 1
37847: NEG
37848: PUSH
37849: LD_INT 0
37851: PUSH
37852: EMPTY
37853: LIST
37854: LIST
37855: PUSH
37856: LD_INT 1
37858: NEG
37859: PUSH
37860: LD_INT 1
37862: NEG
37863: PUSH
37864: EMPTY
37865: LIST
37866: LIST
37867: PUSH
37868: LD_INT 1
37870: NEG
37871: PUSH
37872: LD_INT 2
37874: NEG
37875: PUSH
37876: EMPTY
37877: LIST
37878: LIST
37879: PUSH
37880: LD_INT 1
37882: PUSH
37883: LD_INT 1
37885: NEG
37886: PUSH
37887: EMPTY
37888: LIST
37889: LIST
37890: PUSH
37891: LD_INT 2
37893: PUSH
37894: LD_INT 0
37896: PUSH
37897: EMPTY
37898: LIST
37899: LIST
37900: PUSH
37901: LD_INT 2
37903: PUSH
37904: LD_INT 1
37906: PUSH
37907: EMPTY
37908: LIST
37909: LIST
37910: PUSH
37911: LD_INT 2
37913: PUSH
37914: LD_INT 2
37916: PUSH
37917: EMPTY
37918: LIST
37919: LIST
37920: PUSH
37921: LD_INT 1
37923: PUSH
37924: LD_INT 2
37926: PUSH
37927: EMPTY
37928: LIST
37929: LIST
37930: PUSH
37931: LD_INT 0
37933: PUSH
37934: LD_INT 2
37936: PUSH
37937: EMPTY
37938: LIST
37939: LIST
37940: PUSH
37941: LD_INT 1
37943: NEG
37944: PUSH
37945: LD_INT 1
37947: PUSH
37948: EMPTY
37949: LIST
37950: LIST
37951: PUSH
37952: LD_INT 2
37954: NEG
37955: PUSH
37956: LD_INT 1
37958: NEG
37959: PUSH
37960: EMPTY
37961: LIST
37962: LIST
37963: PUSH
37964: LD_INT 2
37966: NEG
37967: PUSH
37968: LD_INT 2
37970: NEG
37971: PUSH
37972: EMPTY
37973: LIST
37974: LIST
37975: PUSH
37976: LD_INT 2
37978: NEG
37979: PUSH
37980: LD_INT 3
37982: NEG
37983: PUSH
37984: EMPTY
37985: LIST
37986: LIST
37987: PUSH
37988: LD_INT 2
37990: PUSH
37991: LD_INT 1
37993: NEG
37994: PUSH
37995: EMPTY
37996: LIST
37997: LIST
37998: PUSH
37999: LD_INT 3
38001: PUSH
38002: LD_INT 1
38004: PUSH
38005: EMPTY
38006: LIST
38007: LIST
38008: PUSH
38009: LD_INT 1
38011: PUSH
38012: LD_INT 3
38014: PUSH
38015: EMPTY
38016: LIST
38017: LIST
38018: PUSH
38019: LD_INT 1
38021: NEG
38022: PUSH
38023: LD_INT 2
38025: PUSH
38026: EMPTY
38027: LIST
38028: LIST
38029: PUSH
38030: LD_INT 3
38032: NEG
38033: PUSH
38034: LD_INT 2
38036: NEG
38037: PUSH
38038: EMPTY
38039: LIST
38040: LIST
38041: PUSH
38042: EMPTY
38043: LIST
38044: LIST
38045: LIST
38046: LIST
38047: LIST
38048: LIST
38049: LIST
38050: LIST
38051: LIST
38052: LIST
38053: LIST
38054: LIST
38055: LIST
38056: LIST
38057: LIST
38058: LIST
38059: LIST
38060: LIST
38061: LIST
38062: LIST
38063: LIST
38064: LIST
38065: LIST
38066: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
38067: LD_ADDR_VAR 0 32
38071: PUSH
38072: LD_INT 0
38074: PUSH
38075: LD_INT 0
38077: PUSH
38078: EMPTY
38079: LIST
38080: LIST
38081: PUSH
38082: LD_INT 0
38084: PUSH
38085: LD_INT 1
38087: NEG
38088: PUSH
38089: EMPTY
38090: LIST
38091: LIST
38092: PUSH
38093: LD_INT 1
38095: PUSH
38096: LD_INT 0
38098: PUSH
38099: EMPTY
38100: LIST
38101: LIST
38102: PUSH
38103: LD_INT 1
38105: PUSH
38106: LD_INT 1
38108: PUSH
38109: EMPTY
38110: LIST
38111: LIST
38112: PUSH
38113: LD_INT 0
38115: PUSH
38116: LD_INT 1
38118: PUSH
38119: EMPTY
38120: LIST
38121: LIST
38122: PUSH
38123: LD_INT 1
38125: NEG
38126: PUSH
38127: LD_INT 0
38129: PUSH
38130: EMPTY
38131: LIST
38132: LIST
38133: PUSH
38134: LD_INT 1
38136: NEG
38137: PUSH
38138: LD_INT 1
38140: NEG
38141: PUSH
38142: EMPTY
38143: LIST
38144: LIST
38145: PUSH
38146: LD_INT 1
38148: NEG
38149: PUSH
38150: LD_INT 2
38152: NEG
38153: PUSH
38154: EMPTY
38155: LIST
38156: LIST
38157: PUSH
38158: LD_INT 0
38160: PUSH
38161: LD_INT 2
38163: NEG
38164: PUSH
38165: EMPTY
38166: LIST
38167: LIST
38168: PUSH
38169: LD_INT 1
38171: PUSH
38172: LD_INT 1
38174: NEG
38175: PUSH
38176: EMPTY
38177: LIST
38178: LIST
38179: PUSH
38180: LD_INT 2
38182: PUSH
38183: LD_INT 1
38185: PUSH
38186: EMPTY
38187: LIST
38188: LIST
38189: PUSH
38190: LD_INT 2
38192: PUSH
38193: LD_INT 2
38195: PUSH
38196: EMPTY
38197: LIST
38198: LIST
38199: PUSH
38200: LD_INT 1
38202: PUSH
38203: LD_INT 2
38205: PUSH
38206: EMPTY
38207: LIST
38208: LIST
38209: PUSH
38210: LD_INT 0
38212: PUSH
38213: LD_INT 2
38215: PUSH
38216: EMPTY
38217: LIST
38218: LIST
38219: PUSH
38220: LD_INT 1
38222: NEG
38223: PUSH
38224: LD_INT 1
38226: PUSH
38227: EMPTY
38228: LIST
38229: LIST
38230: PUSH
38231: LD_INT 2
38233: NEG
38234: PUSH
38235: LD_INT 0
38237: PUSH
38238: EMPTY
38239: LIST
38240: LIST
38241: PUSH
38242: LD_INT 2
38244: NEG
38245: PUSH
38246: LD_INT 1
38248: NEG
38249: PUSH
38250: EMPTY
38251: LIST
38252: LIST
38253: PUSH
38254: LD_INT 1
38256: NEG
38257: PUSH
38258: LD_INT 3
38260: NEG
38261: PUSH
38262: EMPTY
38263: LIST
38264: LIST
38265: PUSH
38266: LD_INT 1
38268: PUSH
38269: LD_INT 2
38271: NEG
38272: PUSH
38273: EMPTY
38274: LIST
38275: LIST
38276: PUSH
38277: LD_INT 3
38279: PUSH
38280: LD_INT 2
38282: PUSH
38283: EMPTY
38284: LIST
38285: LIST
38286: PUSH
38287: LD_INT 2
38289: PUSH
38290: LD_INT 3
38292: PUSH
38293: EMPTY
38294: LIST
38295: LIST
38296: PUSH
38297: LD_INT 2
38299: NEG
38300: PUSH
38301: LD_INT 1
38303: PUSH
38304: EMPTY
38305: LIST
38306: LIST
38307: PUSH
38308: LD_INT 3
38310: NEG
38311: PUSH
38312: LD_INT 1
38314: NEG
38315: PUSH
38316: EMPTY
38317: LIST
38318: LIST
38319: PUSH
38320: EMPTY
38321: LIST
38322: LIST
38323: LIST
38324: LIST
38325: LIST
38326: LIST
38327: LIST
38328: LIST
38329: LIST
38330: LIST
38331: LIST
38332: LIST
38333: LIST
38334: LIST
38335: LIST
38336: LIST
38337: LIST
38338: LIST
38339: LIST
38340: LIST
38341: LIST
38342: LIST
38343: LIST
38344: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
38345: LD_ADDR_VAR 0 33
38349: PUSH
38350: LD_INT 0
38352: PUSH
38353: LD_INT 0
38355: PUSH
38356: EMPTY
38357: LIST
38358: LIST
38359: PUSH
38360: LD_INT 0
38362: PUSH
38363: LD_INT 1
38365: NEG
38366: PUSH
38367: EMPTY
38368: LIST
38369: LIST
38370: PUSH
38371: LD_INT 1
38373: PUSH
38374: LD_INT 0
38376: PUSH
38377: EMPTY
38378: LIST
38379: LIST
38380: PUSH
38381: LD_INT 1
38383: PUSH
38384: LD_INT 1
38386: PUSH
38387: EMPTY
38388: LIST
38389: LIST
38390: PUSH
38391: LD_INT 0
38393: PUSH
38394: LD_INT 1
38396: PUSH
38397: EMPTY
38398: LIST
38399: LIST
38400: PUSH
38401: LD_INT 1
38403: NEG
38404: PUSH
38405: LD_INT 0
38407: PUSH
38408: EMPTY
38409: LIST
38410: LIST
38411: PUSH
38412: LD_INT 1
38414: NEG
38415: PUSH
38416: LD_INT 1
38418: NEG
38419: PUSH
38420: EMPTY
38421: LIST
38422: LIST
38423: PUSH
38424: LD_INT 1
38426: NEG
38427: PUSH
38428: LD_INT 2
38430: NEG
38431: PUSH
38432: EMPTY
38433: LIST
38434: LIST
38435: PUSH
38436: LD_INT 1
38438: PUSH
38439: LD_INT 1
38441: NEG
38442: PUSH
38443: EMPTY
38444: LIST
38445: LIST
38446: PUSH
38447: LD_INT 2
38449: PUSH
38450: LD_INT 0
38452: PUSH
38453: EMPTY
38454: LIST
38455: LIST
38456: PUSH
38457: LD_INT 2
38459: PUSH
38460: LD_INT 1
38462: PUSH
38463: EMPTY
38464: LIST
38465: LIST
38466: PUSH
38467: LD_INT 1
38469: PUSH
38470: LD_INT 2
38472: PUSH
38473: EMPTY
38474: LIST
38475: LIST
38476: PUSH
38477: LD_INT 0
38479: PUSH
38480: LD_INT 2
38482: PUSH
38483: EMPTY
38484: LIST
38485: LIST
38486: PUSH
38487: LD_INT 1
38489: NEG
38490: PUSH
38491: LD_INT 1
38493: PUSH
38494: EMPTY
38495: LIST
38496: LIST
38497: PUSH
38498: LD_INT 2
38500: NEG
38501: PUSH
38502: LD_INT 0
38504: PUSH
38505: EMPTY
38506: LIST
38507: LIST
38508: PUSH
38509: LD_INT 2
38511: NEG
38512: PUSH
38513: LD_INT 1
38515: NEG
38516: PUSH
38517: EMPTY
38518: LIST
38519: LIST
38520: PUSH
38521: LD_INT 2
38523: NEG
38524: PUSH
38525: LD_INT 2
38527: NEG
38528: PUSH
38529: EMPTY
38530: LIST
38531: LIST
38532: PUSH
38533: LD_INT 2
38535: NEG
38536: PUSH
38537: LD_INT 3
38539: NEG
38540: PUSH
38541: EMPTY
38542: LIST
38543: LIST
38544: PUSH
38545: LD_INT 2
38547: PUSH
38548: LD_INT 1
38550: NEG
38551: PUSH
38552: EMPTY
38553: LIST
38554: LIST
38555: PUSH
38556: LD_INT 3
38558: PUSH
38559: LD_INT 1
38561: PUSH
38562: EMPTY
38563: LIST
38564: LIST
38565: PUSH
38566: LD_INT 1
38568: PUSH
38569: LD_INT 3
38571: PUSH
38572: EMPTY
38573: LIST
38574: LIST
38575: PUSH
38576: LD_INT 1
38578: NEG
38579: PUSH
38580: LD_INT 2
38582: PUSH
38583: EMPTY
38584: LIST
38585: LIST
38586: PUSH
38587: LD_INT 3
38589: NEG
38590: PUSH
38591: LD_INT 2
38593: NEG
38594: PUSH
38595: EMPTY
38596: LIST
38597: LIST
38598: PUSH
38599: EMPTY
38600: LIST
38601: LIST
38602: LIST
38603: LIST
38604: LIST
38605: LIST
38606: LIST
38607: LIST
38608: LIST
38609: LIST
38610: LIST
38611: LIST
38612: LIST
38613: LIST
38614: LIST
38615: LIST
38616: LIST
38617: LIST
38618: LIST
38619: LIST
38620: LIST
38621: LIST
38622: LIST
38623: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
38624: LD_ADDR_VAR 0 34
38628: PUSH
38629: LD_INT 0
38631: PUSH
38632: LD_INT 0
38634: PUSH
38635: EMPTY
38636: LIST
38637: LIST
38638: PUSH
38639: LD_INT 0
38641: PUSH
38642: LD_INT 1
38644: NEG
38645: PUSH
38646: EMPTY
38647: LIST
38648: LIST
38649: PUSH
38650: LD_INT 1
38652: PUSH
38653: LD_INT 0
38655: PUSH
38656: EMPTY
38657: LIST
38658: LIST
38659: PUSH
38660: LD_INT 1
38662: PUSH
38663: LD_INT 1
38665: PUSH
38666: EMPTY
38667: LIST
38668: LIST
38669: PUSH
38670: LD_INT 0
38672: PUSH
38673: LD_INT 1
38675: PUSH
38676: EMPTY
38677: LIST
38678: LIST
38679: PUSH
38680: LD_INT 1
38682: NEG
38683: PUSH
38684: LD_INT 0
38686: PUSH
38687: EMPTY
38688: LIST
38689: LIST
38690: PUSH
38691: LD_INT 1
38693: NEG
38694: PUSH
38695: LD_INT 1
38697: NEG
38698: PUSH
38699: EMPTY
38700: LIST
38701: LIST
38702: PUSH
38703: LD_INT 1
38705: NEG
38706: PUSH
38707: LD_INT 2
38709: NEG
38710: PUSH
38711: EMPTY
38712: LIST
38713: LIST
38714: PUSH
38715: LD_INT 0
38717: PUSH
38718: LD_INT 2
38720: NEG
38721: PUSH
38722: EMPTY
38723: LIST
38724: LIST
38725: PUSH
38726: LD_INT 1
38728: PUSH
38729: LD_INT 1
38731: NEG
38732: PUSH
38733: EMPTY
38734: LIST
38735: LIST
38736: PUSH
38737: LD_INT 2
38739: PUSH
38740: LD_INT 1
38742: PUSH
38743: EMPTY
38744: LIST
38745: LIST
38746: PUSH
38747: LD_INT 2
38749: PUSH
38750: LD_INT 2
38752: PUSH
38753: EMPTY
38754: LIST
38755: LIST
38756: PUSH
38757: LD_INT 1
38759: PUSH
38760: LD_INT 2
38762: PUSH
38763: EMPTY
38764: LIST
38765: LIST
38766: PUSH
38767: LD_INT 1
38769: NEG
38770: PUSH
38771: LD_INT 1
38773: PUSH
38774: EMPTY
38775: LIST
38776: LIST
38777: PUSH
38778: LD_INT 2
38780: NEG
38781: PUSH
38782: LD_INT 0
38784: PUSH
38785: EMPTY
38786: LIST
38787: LIST
38788: PUSH
38789: LD_INT 2
38791: NEG
38792: PUSH
38793: LD_INT 1
38795: NEG
38796: PUSH
38797: EMPTY
38798: LIST
38799: LIST
38800: PUSH
38801: LD_INT 2
38803: NEG
38804: PUSH
38805: LD_INT 2
38807: NEG
38808: PUSH
38809: EMPTY
38810: LIST
38811: LIST
38812: PUSH
38813: LD_INT 1
38815: NEG
38816: PUSH
38817: LD_INT 3
38819: NEG
38820: PUSH
38821: EMPTY
38822: LIST
38823: LIST
38824: PUSH
38825: LD_INT 1
38827: PUSH
38828: LD_INT 2
38830: NEG
38831: PUSH
38832: EMPTY
38833: LIST
38834: LIST
38835: PUSH
38836: LD_INT 3
38838: PUSH
38839: LD_INT 2
38841: PUSH
38842: EMPTY
38843: LIST
38844: LIST
38845: PUSH
38846: LD_INT 2
38848: PUSH
38849: LD_INT 3
38851: PUSH
38852: EMPTY
38853: LIST
38854: LIST
38855: PUSH
38856: LD_INT 2
38858: NEG
38859: PUSH
38860: LD_INT 1
38862: PUSH
38863: EMPTY
38864: LIST
38865: LIST
38866: PUSH
38867: LD_INT 3
38869: NEG
38870: PUSH
38871: LD_INT 1
38873: NEG
38874: PUSH
38875: EMPTY
38876: LIST
38877: LIST
38878: PUSH
38879: EMPTY
38880: LIST
38881: LIST
38882: LIST
38883: LIST
38884: LIST
38885: LIST
38886: LIST
38887: LIST
38888: LIST
38889: LIST
38890: LIST
38891: LIST
38892: LIST
38893: LIST
38894: LIST
38895: LIST
38896: LIST
38897: LIST
38898: LIST
38899: LIST
38900: LIST
38901: LIST
38902: LIST
38903: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
38904: LD_ADDR_VAR 0 35
38908: PUSH
38909: LD_INT 0
38911: PUSH
38912: LD_INT 0
38914: PUSH
38915: EMPTY
38916: LIST
38917: LIST
38918: PUSH
38919: LD_INT 0
38921: PUSH
38922: LD_INT 1
38924: NEG
38925: PUSH
38926: EMPTY
38927: LIST
38928: LIST
38929: PUSH
38930: LD_INT 1
38932: PUSH
38933: LD_INT 0
38935: PUSH
38936: EMPTY
38937: LIST
38938: LIST
38939: PUSH
38940: LD_INT 1
38942: PUSH
38943: LD_INT 1
38945: PUSH
38946: EMPTY
38947: LIST
38948: LIST
38949: PUSH
38950: LD_INT 0
38952: PUSH
38953: LD_INT 1
38955: PUSH
38956: EMPTY
38957: LIST
38958: LIST
38959: PUSH
38960: LD_INT 1
38962: NEG
38963: PUSH
38964: LD_INT 0
38966: PUSH
38967: EMPTY
38968: LIST
38969: LIST
38970: PUSH
38971: LD_INT 1
38973: NEG
38974: PUSH
38975: LD_INT 1
38977: NEG
38978: PUSH
38979: EMPTY
38980: LIST
38981: LIST
38982: PUSH
38983: LD_INT 2
38985: PUSH
38986: LD_INT 1
38988: PUSH
38989: EMPTY
38990: LIST
38991: LIST
38992: PUSH
38993: LD_INT 2
38995: NEG
38996: PUSH
38997: LD_INT 1
38999: NEG
39000: PUSH
39001: EMPTY
39002: LIST
39003: LIST
39004: PUSH
39005: EMPTY
39006: LIST
39007: LIST
39008: LIST
39009: LIST
39010: LIST
39011: LIST
39012: LIST
39013: LIST
39014: LIST
39015: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
39016: LD_ADDR_VAR 0 36
39020: PUSH
39021: LD_INT 0
39023: PUSH
39024: LD_INT 0
39026: PUSH
39027: EMPTY
39028: LIST
39029: LIST
39030: PUSH
39031: LD_INT 0
39033: PUSH
39034: LD_INT 1
39036: NEG
39037: PUSH
39038: EMPTY
39039: LIST
39040: LIST
39041: PUSH
39042: LD_INT 1
39044: PUSH
39045: LD_INT 0
39047: PUSH
39048: EMPTY
39049: LIST
39050: LIST
39051: PUSH
39052: LD_INT 1
39054: PUSH
39055: LD_INT 1
39057: PUSH
39058: EMPTY
39059: LIST
39060: LIST
39061: PUSH
39062: LD_INT 0
39064: PUSH
39065: LD_INT 1
39067: PUSH
39068: EMPTY
39069: LIST
39070: LIST
39071: PUSH
39072: LD_INT 1
39074: NEG
39075: PUSH
39076: LD_INT 0
39078: PUSH
39079: EMPTY
39080: LIST
39081: LIST
39082: PUSH
39083: LD_INT 1
39085: NEG
39086: PUSH
39087: LD_INT 1
39089: NEG
39090: PUSH
39091: EMPTY
39092: LIST
39093: LIST
39094: PUSH
39095: LD_INT 1
39097: NEG
39098: PUSH
39099: LD_INT 2
39101: NEG
39102: PUSH
39103: EMPTY
39104: LIST
39105: LIST
39106: PUSH
39107: LD_INT 1
39109: PUSH
39110: LD_INT 2
39112: PUSH
39113: EMPTY
39114: LIST
39115: LIST
39116: PUSH
39117: EMPTY
39118: LIST
39119: LIST
39120: LIST
39121: LIST
39122: LIST
39123: LIST
39124: LIST
39125: LIST
39126: LIST
39127: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
39128: LD_ADDR_VAR 0 37
39132: PUSH
39133: LD_INT 0
39135: PUSH
39136: LD_INT 0
39138: PUSH
39139: EMPTY
39140: LIST
39141: LIST
39142: PUSH
39143: LD_INT 0
39145: PUSH
39146: LD_INT 1
39148: NEG
39149: PUSH
39150: EMPTY
39151: LIST
39152: LIST
39153: PUSH
39154: LD_INT 1
39156: PUSH
39157: LD_INT 0
39159: PUSH
39160: EMPTY
39161: LIST
39162: LIST
39163: PUSH
39164: LD_INT 1
39166: PUSH
39167: LD_INT 1
39169: PUSH
39170: EMPTY
39171: LIST
39172: LIST
39173: PUSH
39174: LD_INT 0
39176: PUSH
39177: LD_INT 1
39179: PUSH
39180: EMPTY
39181: LIST
39182: LIST
39183: PUSH
39184: LD_INT 1
39186: NEG
39187: PUSH
39188: LD_INT 0
39190: PUSH
39191: EMPTY
39192: LIST
39193: LIST
39194: PUSH
39195: LD_INT 1
39197: NEG
39198: PUSH
39199: LD_INT 1
39201: NEG
39202: PUSH
39203: EMPTY
39204: LIST
39205: LIST
39206: PUSH
39207: LD_INT 1
39209: PUSH
39210: LD_INT 1
39212: NEG
39213: PUSH
39214: EMPTY
39215: LIST
39216: LIST
39217: PUSH
39218: LD_INT 1
39220: NEG
39221: PUSH
39222: LD_INT 1
39224: PUSH
39225: EMPTY
39226: LIST
39227: LIST
39228: PUSH
39229: EMPTY
39230: LIST
39231: LIST
39232: LIST
39233: LIST
39234: LIST
39235: LIST
39236: LIST
39237: LIST
39238: LIST
39239: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
39240: LD_ADDR_VAR 0 38
39244: PUSH
39245: LD_INT 0
39247: PUSH
39248: LD_INT 0
39250: PUSH
39251: EMPTY
39252: LIST
39253: LIST
39254: PUSH
39255: LD_INT 0
39257: PUSH
39258: LD_INT 1
39260: NEG
39261: PUSH
39262: EMPTY
39263: LIST
39264: LIST
39265: PUSH
39266: LD_INT 1
39268: PUSH
39269: LD_INT 0
39271: PUSH
39272: EMPTY
39273: LIST
39274: LIST
39275: PUSH
39276: LD_INT 1
39278: PUSH
39279: LD_INT 1
39281: PUSH
39282: EMPTY
39283: LIST
39284: LIST
39285: PUSH
39286: LD_INT 0
39288: PUSH
39289: LD_INT 1
39291: PUSH
39292: EMPTY
39293: LIST
39294: LIST
39295: PUSH
39296: LD_INT 1
39298: NEG
39299: PUSH
39300: LD_INT 0
39302: PUSH
39303: EMPTY
39304: LIST
39305: LIST
39306: PUSH
39307: LD_INT 1
39309: NEG
39310: PUSH
39311: LD_INT 1
39313: NEG
39314: PUSH
39315: EMPTY
39316: LIST
39317: LIST
39318: PUSH
39319: LD_INT 2
39321: PUSH
39322: LD_INT 1
39324: PUSH
39325: EMPTY
39326: LIST
39327: LIST
39328: PUSH
39329: LD_INT 2
39331: NEG
39332: PUSH
39333: LD_INT 1
39335: NEG
39336: PUSH
39337: EMPTY
39338: LIST
39339: LIST
39340: PUSH
39341: EMPTY
39342: LIST
39343: LIST
39344: LIST
39345: LIST
39346: LIST
39347: LIST
39348: LIST
39349: LIST
39350: LIST
39351: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
39352: LD_ADDR_VAR 0 39
39356: PUSH
39357: LD_INT 0
39359: PUSH
39360: LD_INT 0
39362: PUSH
39363: EMPTY
39364: LIST
39365: LIST
39366: PUSH
39367: LD_INT 0
39369: PUSH
39370: LD_INT 1
39372: NEG
39373: PUSH
39374: EMPTY
39375: LIST
39376: LIST
39377: PUSH
39378: LD_INT 1
39380: PUSH
39381: LD_INT 0
39383: PUSH
39384: EMPTY
39385: LIST
39386: LIST
39387: PUSH
39388: LD_INT 1
39390: PUSH
39391: LD_INT 1
39393: PUSH
39394: EMPTY
39395: LIST
39396: LIST
39397: PUSH
39398: LD_INT 0
39400: PUSH
39401: LD_INT 1
39403: PUSH
39404: EMPTY
39405: LIST
39406: LIST
39407: PUSH
39408: LD_INT 1
39410: NEG
39411: PUSH
39412: LD_INT 0
39414: PUSH
39415: EMPTY
39416: LIST
39417: LIST
39418: PUSH
39419: LD_INT 1
39421: NEG
39422: PUSH
39423: LD_INT 1
39425: NEG
39426: PUSH
39427: EMPTY
39428: LIST
39429: LIST
39430: PUSH
39431: LD_INT 1
39433: NEG
39434: PUSH
39435: LD_INT 2
39437: NEG
39438: PUSH
39439: EMPTY
39440: LIST
39441: LIST
39442: PUSH
39443: LD_INT 1
39445: PUSH
39446: LD_INT 2
39448: PUSH
39449: EMPTY
39450: LIST
39451: LIST
39452: PUSH
39453: EMPTY
39454: LIST
39455: LIST
39456: LIST
39457: LIST
39458: LIST
39459: LIST
39460: LIST
39461: LIST
39462: LIST
39463: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
39464: LD_ADDR_VAR 0 40
39468: PUSH
39469: LD_INT 0
39471: PUSH
39472: LD_INT 0
39474: PUSH
39475: EMPTY
39476: LIST
39477: LIST
39478: PUSH
39479: LD_INT 0
39481: PUSH
39482: LD_INT 1
39484: NEG
39485: PUSH
39486: EMPTY
39487: LIST
39488: LIST
39489: PUSH
39490: LD_INT 1
39492: PUSH
39493: LD_INT 0
39495: PUSH
39496: EMPTY
39497: LIST
39498: LIST
39499: PUSH
39500: LD_INT 1
39502: PUSH
39503: LD_INT 1
39505: PUSH
39506: EMPTY
39507: LIST
39508: LIST
39509: PUSH
39510: LD_INT 0
39512: PUSH
39513: LD_INT 1
39515: PUSH
39516: EMPTY
39517: LIST
39518: LIST
39519: PUSH
39520: LD_INT 1
39522: NEG
39523: PUSH
39524: LD_INT 0
39526: PUSH
39527: EMPTY
39528: LIST
39529: LIST
39530: PUSH
39531: LD_INT 1
39533: NEG
39534: PUSH
39535: LD_INT 1
39537: NEG
39538: PUSH
39539: EMPTY
39540: LIST
39541: LIST
39542: PUSH
39543: LD_INT 1
39545: PUSH
39546: LD_INT 1
39548: NEG
39549: PUSH
39550: EMPTY
39551: LIST
39552: LIST
39553: PUSH
39554: LD_INT 1
39556: NEG
39557: PUSH
39558: LD_INT 1
39560: PUSH
39561: EMPTY
39562: LIST
39563: LIST
39564: PUSH
39565: EMPTY
39566: LIST
39567: LIST
39568: LIST
39569: LIST
39570: LIST
39571: LIST
39572: LIST
39573: LIST
39574: LIST
39575: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
39576: LD_ADDR_VAR 0 41
39580: PUSH
39581: LD_INT 0
39583: PUSH
39584: LD_INT 0
39586: PUSH
39587: EMPTY
39588: LIST
39589: LIST
39590: PUSH
39591: LD_INT 0
39593: PUSH
39594: LD_INT 1
39596: NEG
39597: PUSH
39598: EMPTY
39599: LIST
39600: LIST
39601: PUSH
39602: LD_INT 1
39604: PUSH
39605: LD_INT 0
39607: PUSH
39608: EMPTY
39609: LIST
39610: LIST
39611: PUSH
39612: LD_INT 1
39614: PUSH
39615: LD_INT 1
39617: PUSH
39618: EMPTY
39619: LIST
39620: LIST
39621: PUSH
39622: LD_INT 0
39624: PUSH
39625: LD_INT 1
39627: PUSH
39628: EMPTY
39629: LIST
39630: LIST
39631: PUSH
39632: LD_INT 1
39634: NEG
39635: PUSH
39636: LD_INT 0
39638: PUSH
39639: EMPTY
39640: LIST
39641: LIST
39642: PUSH
39643: LD_INT 1
39645: NEG
39646: PUSH
39647: LD_INT 1
39649: NEG
39650: PUSH
39651: EMPTY
39652: LIST
39653: LIST
39654: PUSH
39655: LD_INT 1
39657: NEG
39658: PUSH
39659: LD_INT 2
39661: NEG
39662: PUSH
39663: EMPTY
39664: LIST
39665: LIST
39666: PUSH
39667: LD_INT 1
39669: PUSH
39670: LD_INT 1
39672: NEG
39673: PUSH
39674: EMPTY
39675: LIST
39676: LIST
39677: PUSH
39678: LD_INT 2
39680: PUSH
39681: LD_INT 0
39683: PUSH
39684: EMPTY
39685: LIST
39686: LIST
39687: PUSH
39688: LD_INT 2
39690: PUSH
39691: LD_INT 1
39693: PUSH
39694: EMPTY
39695: LIST
39696: LIST
39697: PUSH
39698: LD_INT 2
39700: PUSH
39701: LD_INT 2
39703: PUSH
39704: EMPTY
39705: LIST
39706: LIST
39707: PUSH
39708: LD_INT 1
39710: PUSH
39711: LD_INT 2
39713: PUSH
39714: EMPTY
39715: LIST
39716: LIST
39717: PUSH
39718: LD_INT 1
39720: NEG
39721: PUSH
39722: LD_INT 1
39724: PUSH
39725: EMPTY
39726: LIST
39727: LIST
39728: PUSH
39729: LD_INT 2
39731: NEG
39732: PUSH
39733: LD_INT 0
39735: PUSH
39736: EMPTY
39737: LIST
39738: LIST
39739: PUSH
39740: LD_INT 2
39742: NEG
39743: PUSH
39744: LD_INT 1
39746: NEG
39747: PUSH
39748: EMPTY
39749: LIST
39750: LIST
39751: PUSH
39752: LD_INT 2
39754: NEG
39755: PUSH
39756: LD_INT 2
39758: NEG
39759: PUSH
39760: EMPTY
39761: LIST
39762: LIST
39763: PUSH
39764: LD_INT 2
39766: NEG
39767: PUSH
39768: LD_INT 3
39770: NEG
39771: PUSH
39772: EMPTY
39773: LIST
39774: LIST
39775: PUSH
39776: LD_INT 2
39778: PUSH
39779: LD_INT 1
39781: NEG
39782: PUSH
39783: EMPTY
39784: LIST
39785: LIST
39786: PUSH
39787: LD_INT 3
39789: PUSH
39790: LD_INT 0
39792: PUSH
39793: EMPTY
39794: LIST
39795: LIST
39796: PUSH
39797: LD_INT 3
39799: PUSH
39800: LD_INT 1
39802: PUSH
39803: EMPTY
39804: LIST
39805: LIST
39806: PUSH
39807: LD_INT 3
39809: PUSH
39810: LD_INT 2
39812: PUSH
39813: EMPTY
39814: LIST
39815: LIST
39816: PUSH
39817: LD_INT 3
39819: PUSH
39820: LD_INT 3
39822: PUSH
39823: EMPTY
39824: LIST
39825: LIST
39826: PUSH
39827: LD_INT 2
39829: PUSH
39830: LD_INT 3
39832: PUSH
39833: EMPTY
39834: LIST
39835: LIST
39836: PUSH
39837: LD_INT 2
39839: NEG
39840: PUSH
39841: LD_INT 1
39843: PUSH
39844: EMPTY
39845: LIST
39846: LIST
39847: PUSH
39848: LD_INT 3
39850: NEG
39851: PUSH
39852: LD_INT 0
39854: PUSH
39855: EMPTY
39856: LIST
39857: LIST
39858: PUSH
39859: LD_INT 3
39861: NEG
39862: PUSH
39863: LD_INT 1
39865: NEG
39866: PUSH
39867: EMPTY
39868: LIST
39869: LIST
39870: PUSH
39871: LD_INT 3
39873: NEG
39874: PUSH
39875: LD_INT 2
39877: NEG
39878: PUSH
39879: EMPTY
39880: LIST
39881: LIST
39882: PUSH
39883: LD_INT 3
39885: NEG
39886: PUSH
39887: LD_INT 3
39889: NEG
39890: PUSH
39891: EMPTY
39892: LIST
39893: LIST
39894: PUSH
39895: EMPTY
39896: LIST
39897: LIST
39898: LIST
39899: LIST
39900: LIST
39901: LIST
39902: LIST
39903: LIST
39904: LIST
39905: LIST
39906: LIST
39907: LIST
39908: LIST
39909: LIST
39910: LIST
39911: LIST
39912: LIST
39913: LIST
39914: LIST
39915: LIST
39916: LIST
39917: LIST
39918: LIST
39919: LIST
39920: LIST
39921: LIST
39922: LIST
39923: LIST
39924: LIST
39925: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
39926: LD_ADDR_VAR 0 42
39930: PUSH
39931: LD_INT 0
39933: PUSH
39934: LD_INT 0
39936: PUSH
39937: EMPTY
39938: LIST
39939: LIST
39940: PUSH
39941: LD_INT 0
39943: PUSH
39944: LD_INT 1
39946: NEG
39947: PUSH
39948: EMPTY
39949: LIST
39950: LIST
39951: PUSH
39952: LD_INT 1
39954: PUSH
39955: LD_INT 0
39957: PUSH
39958: EMPTY
39959: LIST
39960: LIST
39961: PUSH
39962: LD_INT 1
39964: PUSH
39965: LD_INT 1
39967: PUSH
39968: EMPTY
39969: LIST
39970: LIST
39971: PUSH
39972: LD_INT 0
39974: PUSH
39975: LD_INT 1
39977: PUSH
39978: EMPTY
39979: LIST
39980: LIST
39981: PUSH
39982: LD_INT 1
39984: NEG
39985: PUSH
39986: LD_INT 0
39988: PUSH
39989: EMPTY
39990: LIST
39991: LIST
39992: PUSH
39993: LD_INT 1
39995: NEG
39996: PUSH
39997: LD_INT 1
39999: NEG
40000: PUSH
40001: EMPTY
40002: LIST
40003: LIST
40004: PUSH
40005: LD_INT 1
40007: NEG
40008: PUSH
40009: LD_INT 2
40011: NEG
40012: PUSH
40013: EMPTY
40014: LIST
40015: LIST
40016: PUSH
40017: LD_INT 0
40019: PUSH
40020: LD_INT 2
40022: NEG
40023: PUSH
40024: EMPTY
40025: LIST
40026: LIST
40027: PUSH
40028: LD_INT 1
40030: PUSH
40031: LD_INT 1
40033: NEG
40034: PUSH
40035: EMPTY
40036: LIST
40037: LIST
40038: PUSH
40039: LD_INT 2
40041: PUSH
40042: LD_INT 1
40044: PUSH
40045: EMPTY
40046: LIST
40047: LIST
40048: PUSH
40049: LD_INT 2
40051: PUSH
40052: LD_INT 2
40054: PUSH
40055: EMPTY
40056: LIST
40057: LIST
40058: PUSH
40059: LD_INT 1
40061: PUSH
40062: LD_INT 2
40064: PUSH
40065: EMPTY
40066: LIST
40067: LIST
40068: PUSH
40069: LD_INT 0
40071: PUSH
40072: LD_INT 2
40074: PUSH
40075: EMPTY
40076: LIST
40077: LIST
40078: PUSH
40079: LD_INT 1
40081: NEG
40082: PUSH
40083: LD_INT 1
40085: PUSH
40086: EMPTY
40087: LIST
40088: LIST
40089: PUSH
40090: LD_INT 2
40092: NEG
40093: PUSH
40094: LD_INT 1
40096: NEG
40097: PUSH
40098: EMPTY
40099: LIST
40100: LIST
40101: PUSH
40102: LD_INT 2
40104: NEG
40105: PUSH
40106: LD_INT 2
40108: NEG
40109: PUSH
40110: EMPTY
40111: LIST
40112: LIST
40113: PUSH
40114: LD_INT 2
40116: NEG
40117: PUSH
40118: LD_INT 3
40120: NEG
40121: PUSH
40122: EMPTY
40123: LIST
40124: LIST
40125: PUSH
40126: LD_INT 1
40128: NEG
40129: PUSH
40130: LD_INT 3
40132: NEG
40133: PUSH
40134: EMPTY
40135: LIST
40136: LIST
40137: PUSH
40138: LD_INT 0
40140: PUSH
40141: LD_INT 3
40143: NEG
40144: PUSH
40145: EMPTY
40146: LIST
40147: LIST
40148: PUSH
40149: LD_INT 1
40151: PUSH
40152: LD_INT 2
40154: NEG
40155: PUSH
40156: EMPTY
40157: LIST
40158: LIST
40159: PUSH
40160: LD_INT 3
40162: PUSH
40163: LD_INT 2
40165: PUSH
40166: EMPTY
40167: LIST
40168: LIST
40169: PUSH
40170: LD_INT 3
40172: PUSH
40173: LD_INT 3
40175: PUSH
40176: EMPTY
40177: LIST
40178: LIST
40179: PUSH
40180: LD_INT 2
40182: PUSH
40183: LD_INT 3
40185: PUSH
40186: EMPTY
40187: LIST
40188: LIST
40189: PUSH
40190: LD_INT 1
40192: PUSH
40193: LD_INT 3
40195: PUSH
40196: EMPTY
40197: LIST
40198: LIST
40199: PUSH
40200: LD_INT 0
40202: PUSH
40203: LD_INT 3
40205: PUSH
40206: EMPTY
40207: LIST
40208: LIST
40209: PUSH
40210: LD_INT 1
40212: NEG
40213: PUSH
40214: LD_INT 2
40216: PUSH
40217: EMPTY
40218: LIST
40219: LIST
40220: PUSH
40221: LD_INT 3
40223: NEG
40224: PUSH
40225: LD_INT 2
40227: NEG
40228: PUSH
40229: EMPTY
40230: LIST
40231: LIST
40232: PUSH
40233: LD_INT 3
40235: NEG
40236: PUSH
40237: LD_INT 3
40239: NEG
40240: PUSH
40241: EMPTY
40242: LIST
40243: LIST
40244: PUSH
40245: EMPTY
40246: LIST
40247: LIST
40248: LIST
40249: LIST
40250: LIST
40251: LIST
40252: LIST
40253: LIST
40254: LIST
40255: LIST
40256: LIST
40257: LIST
40258: LIST
40259: LIST
40260: LIST
40261: LIST
40262: LIST
40263: LIST
40264: LIST
40265: LIST
40266: LIST
40267: LIST
40268: LIST
40269: LIST
40270: LIST
40271: LIST
40272: LIST
40273: LIST
40274: LIST
40275: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
40276: LD_ADDR_VAR 0 43
40280: PUSH
40281: LD_INT 0
40283: PUSH
40284: LD_INT 0
40286: PUSH
40287: EMPTY
40288: LIST
40289: LIST
40290: PUSH
40291: LD_INT 0
40293: PUSH
40294: LD_INT 1
40296: NEG
40297: PUSH
40298: EMPTY
40299: LIST
40300: LIST
40301: PUSH
40302: LD_INT 1
40304: PUSH
40305: LD_INT 0
40307: PUSH
40308: EMPTY
40309: LIST
40310: LIST
40311: PUSH
40312: LD_INT 1
40314: PUSH
40315: LD_INT 1
40317: PUSH
40318: EMPTY
40319: LIST
40320: LIST
40321: PUSH
40322: LD_INT 0
40324: PUSH
40325: LD_INT 1
40327: PUSH
40328: EMPTY
40329: LIST
40330: LIST
40331: PUSH
40332: LD_INT 1
40334: NEG
40335: PUSH
40336: LD_INT 0
40338: PUSH
40339: EMPTY
40340: LIST
40341: LIST
40342: PUSH
40343: LD_INT 1
40345: NEG
40346: PUSH
40347: LD_INT 1
40349: NEG
40350: PUSH
40351: EMPTY
40352: LIST
40353: LIST
40354: PUSH
40355: LD_INT 1
40357: NEG
40358: PUSH
40359: LD_INT 2
40361: NEG
40362: PUSH
40363: EMPTY
40364: LIST
40365: LIST
40366: PUSH
40367: LD_INT 0
40369: PUSH
40370: LD_INT 2
40372: NEG
40373: PUSH
40374: EMPTY
40375: LIST
40376: LIST
40377: PUSH
40378: LD_INT 1
40380: PUSH
40381: LD_INT 1
40383: NEG
40384: PUSH
40385: EMPTY
40386: LIST
40387: LIST
40388: PUSH
40389: LD_INT 2
40391: PUSH
40392: LD_INT 0
40394: PUSH
40395: EMPTY
40396: LIST
40397: LIST
40398: PUSH
40399: LD_INT 2
40401: PUSH
40402: LD_INT 1
40404: PUSH
40405: EMPTY
40406: LIST
40407: LIST
40408: PUSH
40409: LD_INT 1
40411: PUSH
40412: LD_INT 2
40414: PUSH
40415: EMPTY
40416: LIST
40417: LIST
40418: PUSH
40419: LD_INT 0
40421: PUSH
40422: LD_INT 2
40424: PUSH
40425: EMPTY
40426: LIST
40427: LIST
40428: PUSH
40429: LD_INT 1
40431: NEG
40432: PUSH
40433: LD_INT 1
40435: PUSH
40436: EMPTY
40437: LIST
40438: LIST
40439: PUSH
40440: LD_INT 2
40442: NEG
40443: PUSH
40444: LD_INT 0
40446: PUSH
40447: EMPTY
40448: LIST
40449: LIST
40450: PUSH
40451: LD_INT 2
40453: NEG
40454: PUSH
40455: LD_INT 1
40457: NEG
40458: PUSH
40459: EMPTY
40460: LIST
40461: LIST
40462: PUSH
40463: LD_INT 1
40465: NEG
40466: PUSH
40467: LD_INT 3
40469: NEG
40470: PUSH
40471: EMPTY
40472: LIST
40473: LIST
40474: PUSH
40475: LD_INT 0
40477: PUSH
40478: LD_INT 3
40480: NEG
40481: PUSH
40482: EMPTY
40483: LIST
40484: LIST
40485: PUSH
40486: LD_INT 1
40488: PUSH
40489: LD_INT 2
40491: NEG
40492: PUSH
40493: EMPTY
40494: LIST
40495: LIST
40496: PUSH
40497: LD_INT 2
40499: PUSH
40500: LD_INT 1
40502: NEG
40503: PUSH
40504: EMPTY
40505: LIST
40506: LIST
40507: PUSH
40508: LD_INT 3
40510: PUSH
40511: LD_INT 0
40513: PUSH
40514: EMPTY
40515: LIST
40516: LIST
40517: PUSH
40518: LD_INT 3
40520: PUSH
40521: LD_INT 1
40523: PUSH
40524: EMPTY
40525: LIST
40526: LIST
40527: PUSH
40528: LD_INT 1
40530: PUSH
40531: LD_INT 3
40533: PUSH
40534: EMPTY
40535: LIST
40536: LIST
40537: PUSH
40538: LD_INT 0
40540: PUSH
40541: LD_INT 3
40543: PUSH
40544: EMPTY
40545: LIST
40546: LIST
40547: PUSH
40548: LD_INT 1
40550: NEG
40551: PUSH
40552: LD_INT 2
40554: PUSH
40555: EMPTY
40556: LIST
40557: LIST
40558: PUSH
40559: LD_INT 2
40561: NEG
40562: PUSH
40563: LD_INT 1
40565: PUSH
40566: EMPTY
40567: LIST
40568: LIST
40569: PUSH
40570: LD_INT 3
40572: NEG
40573: PUSH
40574: LD_INT 0
40576: PUSH
40577: EMPTY
40578: LIST
40579: LIST
40580: PUSH
40581: LD_INT 3
40583: NEG
40584: PUSH
40585: LD_INT 1
40587: NEG
40588: PUSH
40589: EMPTY
40590: LIST
40591: LIST
40592: PUSH
40593: EMPTY
40594: LIST
40595: LIST
40596: LIST
40597: LIST
40598: LIST
40599: LIST
40600: LIST
40601: LIST
40602: LIST
40603: LIST
40604: LIST
40605: LIST
40606: LIST
40607: LIST
40608: LIST
40609: LIST
40610: LIST
40611: LIST
40612: LIST
40613: LIST
40614: LIST
40615: LIST
40616: LIST
40617: LIST
40618: LIST
40619: LIST
40620: LIST
40621: LIST
40622: LIST
40623: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
40624: LD_ADDR_VAR 0 44
40628: PUSH
40629: LD_INT 0
40631: PUSH
40632: LD_INT 0
40634: PUSH
40635: EMPTY
40636: LIST
40637: LIST
40638: PUSH
40639: LD_INT 0
40641: PUSH
40642: LD_INT 1
40644: NEG
40645: PUSH
40646: EMPTY
40647: LIST
40648: LIST
40649: PUSH
40650: LD_INT 1
40652: PUSH
40653: LD_INT 0
40655: PUSH
40656: EMPTY
40657: LIST
40658: LIST
40659: PUSH
40660: LD_INT 1
40662: PUSH
40663: LD_INT 1
40665: PUSH
40666: EMPTY
40667: LIST
40668: LIST
40669: PUSH
40670: LD_INT 0
40672: PUSH
40673: LD_INT 1
40675: PUSH
40676: EMPTY
40677: LIST
40678: LIST
40679: PUSH
40680: LD_INT 1
40682: NEG
40683: PUSH
40684: LD_INT 0
40686: PUSH
40687: EMPTY
40688: LIST
40689: LIST
40690: PUSH
40691: LD_INT 1
40693: NEG
40694: PUSH
40695: LD_INT 1
40697: NEG
40698: PUSH
40699: EMPTY
40700: LIST
40701: LIST
40702: PUSH
40703: LD_INT 1
40705: NEG
40706: PUSH
40707: LD_INT 2
40709: NEG
40710: PUSH
40711: EMPTY
40712: LIST
40713: LIST
40714: PUSH
40715: LD_INT 1
40717: PUSH
40718: LD_INT 1
40720: NEG
40721: PUSH
40722: EMPTY
40723: LIST
40724: LIST
40725: PUSH
40726: LD_INT 2
40728: PUSH
40729: LD_INT 0
40731: PUSH
40732: EMPTY
40733: LIST
40734: LIST
40735: PUSH
40736: LD_INT 2
40738: PUSH
40739: LD_INT 1
40741: PUSH
40742: EMPTY
40743: LIST
40744: LIST
40745: PUSH
40746: LD_INT 2
40748: PUSH
40749: LD_INT 2
40751: PUSH
40752: EMPTY
40753: LIST
40754: LIST
40755: PUSH
40756: LD_INT 1
40758: PUSH
40759: LD_INT 2
40761: PUSH
40762: EMPTY
40763: LIST
40764: LIST
40765: PUSH
40766: LD_INT 1
40768: NEG
40769: PUSH
40770: LD_INT 1
40772: PUSH
40773: EMPTY
40774: LIST
40775: LIST
40776: PUSH
40777: LD_INT 2
40779: NEG
40780: PUSH
40781: LD_INT 0
40783: PUSH
40784: EMPTY
40785: LIST
40786: LIST
40787: PUSH
40788: LD_INT 2
40790: NEG
40791: PUSH
40792: LD_INT 1
40794: NEG
40795: PUSH
40796: EMPTY
40797: LIST
40798: LIST
40799: PUSH
40800: LD_INT 2
40802: NEG
40803: PUSH
40804: LD_INT 2
40806: NEG
40807: PUSH
40808: EMPTY
40809: LIST
40810: LIST
40811: PUSH
40812: LD_INT 2
40814: NEG
40815: PUSH
40816: LD_INT 3
40818: NEG
40819: PUSH
40820: EMPTY
40821: LIST
40822: LIST
40823: PUSH
40824: LD_INT 2
40826: PUSH
40827: LD_INT 1
40829: NEG
40830: PUSH
40831: EMPTY
40832: LIST
40833: LIST
40834: PUSH
40835: LD_INT 3
40837: PUSH
40838: LD_INT 0
40840: PUSH
40841: EMPTY
40842: LIST
40843: LIST
40844: PUSH
40845: LD_INT 3
40847: PUSH
40848: LD_INT 1
40850: PUSH
40851: EMPTY
40852: LIST
40853: LIST
40854: PUSH
40855: LD_INT 3
40857: PUSH
40858: LD_INT 2
40860: PUSH
40861: EMPTY
40862: LIST
40863: LIST
40864: PUSH
40865: LD_INT 3
40867: PUSH
40868: LD_INT 3
40870: PUSH
40871: EMPTY
40872: LIST
40873: LIST
40874: PUSH
40875: LD_INT 2
40877: PUSH
40878: LD_INT 3
40880: PUSH
40881: EMPTY
40882: LIST
40883: LIST
40884: PUSH
40885: LD_INT 2
40887: NEG
40888: PUSH
40889: LD_INT 1
40891: PUSH
40892: EMPTY
40893: LIST
40894: LIST
40895: PUSH
40896: LD_INT 3
40898: NEG
40899: PUSH
40900: LD_INT 0
40902: PUSH
40903: EMPTY
40904: LIST
40905: LIST
40906: PUSH
40907: LD_INT 3
40909: NEG
40910: PUSH
40911: LD_INT 1
40913: NEG
40914: PUSH
40915: EMPTY
40916: LIST
40917: LIST
40918: PUSH
40919: LD_INT 3
40921: NEG
40922: PUSH
40923: LD_INT 2
40925: NEG
40926: PUSH
40927: EMPTY
40928: LIST
40929: LIST
40930: PUSH
40931: LD_INT 3
40933: NEG
40934: PUSH
40935: LD_INT 3
40937: NEG
40938: PUSH
40939: EMPTY
40940: LIST
40941: LIST
40942: PUSH
40943: EMPTY
40944: LIST
40945: LIST
40946: LIST
40947: LIST
40948: LIST
40949: LIST
40950: LIST
40951: LIST
40952: LIST
40953: LIST
40954: LIST
40955: LIST
40956: LIST
40957: LIST
40958: LIST
40959: LIST
40960: LIST
40961: LIST
40962: LIST
40963: LIST
40964: LIST
40965: LIST
40966: LIST
40967: LIST
40968: LIST
40969: LIST
40970: LIST
40971: LIST
40972: LIST
40973: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
40974: LD_ADDR_VAR 0 45
40978: PUSH
40979: LD_INT 0
40981: PUSH
40982: LD_INT 0
40984: PUSH
40985: EMPTY
40986: LIST
40987: LIST
40988: PUSH
40989: LD_INT 0
40991: PUSH
40992: LD_INT 1
40994: NEG
40995: PUSH
40996: EMPTY
40997: LIST
40998: LIST
40999: PUSH
41000: LD_INT 1
41002: PUSH
41003: LD_INT 0
41005: PUSH
41006: EMPTY
41007: LIST
41008: LIST
41009: PUSH
41010: LD_INT 1
41012: PUSH
41013: LD_INT 1
41015: PUSH
41016: EMPTY
41017: LIST
41018: LIST
41019: PUSH
41020: LD_INT 0
41022: PUSH
41023: LD_INT 1
41025: PUSH
41026: EMPTY
41027: LIST
41028: LIST
41029: PUSH
41030: LD_INT 1
41032: NEG
41033: PUSH
41034: LD_INT 0
41036: PUSH
41037: EMPTY
41038: LIST
41039: LIST
41040: PUSH
41041: LD_INT 1
41043: NEG
41044: PUSH
41045: LD_INT 1
41047: NEG
41048: PUSH
41049: EMPTY
41050: LIST
41051: LIST
41052: PUSH
41053: LD_INT 1
41055: NEG
41056: PUSH
41057: LD_INT 2
41059: NEG
41060: PUSH
41061: EMPTY
41062: LIST
41063: LIST
41064: PUSH
41065: LD_INT 0
41067: PUSH
41068: LD_INT 2
41070: NEG
41071: PUSH
41072: EMPTY
41073: LIST
41074: LIST
41075: PUSH
41076: LD_INT 1
41078: PUSH
41079: LD_INT 1
41081: NEG
41082: PUSH
41083: EMPTY
41084: LIST
41085: LIST
41086: PUSH
41087: LD_INT 2
41089: PUSH
41090: LD_INT 1
41092: PUSH
41093: EMPTY
41094: LIST
41095: LIST
41096: PUSH
41097: LD_INT 2
41099: PUSH
41100: LD_INT 2
41102: PUSH
41103: EMPTY
41104: LIST
41105: LIST
41106: PUSH
41107: LD_INT 1
41109: PUSH
41110: LD_INT 2
41112: PUSH
41113: EMPTY
41114: LIST
41115: LIST
41116: PUSH
41117: LD_INT 0
41119: PUSH
41120: LD_INT 2
41122: PUSH
41123: EMPTY
41124: LIST
41125: LIST
41126: PUSH
41127: LD_INT 1
41129: NEG
41130: PUSH
41131: LD_INT 1
41133: PUSH
41134: EMPTY
41135: LIST
41136: LIST
41137: PUSH
41138: LD_INT 2
41140: NEG
41141: PUSH
41142: LD_INT 1
41144: NEG
41145: PUSH
41146: EMPTY
41147: LIST
41148: LIST
41149: PUSH
41150: LD_INT 2
41152: NEG
41153: PUSH
41154: LD_INT 2
41156: NEG
41157: PUSH
41158: EMPTY
41159: LIST
41160: LIST
41161: PUSH
41162: LD_INT 2
41164: NEG
41165: PUSH
41166: LD_INT 3
41168: NEG
41169: PUSH
41170: EMPTY
41171: LIST
41172: LIST
41173: PUSH
41174: LD_INT 1
41176: NEG
41177: PUSH
41178: LD_INT 3
41180: NEG
41181: PUSH
41182: EMPTY
41183: LIST
41184: LIST
41185: PUSH
41186: LD_INT 0
41188: PUSH
41189: LD_INT 3
41191: NEG
41192: PUSH
41193: EMPTY
41194: LIST
41195: LIST
41196: PUSH
41197: LD_INT 1
41199: PUSH
41200: LD_INT 2
41202: NEG
41203: PUSH
41204: EMPTY
41205: LIST
41206: LIST
41207: PUSH
41208: LD_INT 3
41210: PUSH
41211: LD_INT 2
41213: PUSH
41214: EMPTY
41215: LIST
41216: LIST
41217: PUSH
41218: LD_INT 3
41220: PUSH
41221: LD_INT 3
41223: PUSH
41224: EMPTY
41225: LIST
41226: LIST
41227: PUSH
41228: LD_INT 2
41230: PUSH
41231: LD_INT 3
41233: PUSH
41234: EMPTY
41235: LIST
41236: LIST
41237: PUSH
41238: LD_INT 1
41240: PUSH
41241: LD_INT 3
41243: PUSH
41244: EMPTY
41245: LIST
41246: LIST
41247: PUSH
41248: LD_INT 0
41250: PUSH
41251: LD_INT 3
41253: PUSH
41254: EMPTY
41255: LIST
41256: LIST
41257: PUSH
41258: LD_INT 1
41260: NEG
41261: PUSH
41262: LD_INT 2
41264: PUSH
41265: EMPTY
41266: LIST
41267: LIST
41268: PUSH
41269: LD_INT 3
41271: NEG
41272: PUSH
41273: LD_INT 2
41275: NEG
41276: PUSH
41277: EMPTY
41278: LIST
41279: LIST
41280: PUSH
41281: LD_INT 3
41283: NEG
41284: PUSH
41285: LD_INT 3
41287: NEG
41288: PUSH
41289: EMPTY
41290: LIST
41291: LIST
41292: PUSH
41293: EMPTY
41294: LIST
41295: LIST
41296: LIST
41297: LIST
41298: LIST
41299: LIST
41300: LIST
41301: LIST
41302: LIST
41303: LIST
41304: LIST
41305: LIST
41306: LIST
41307: LIST
41308: LIST
41309: LIST
41310: LIST
41311: LIST
41312: LIST
41313: LIST
41314: LIST
41315: LIST
41316: LIST
41317: LIST
41318: LIST
41319: LIST
41320: LIST
41321: LIST
41322: LIST
41323: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
41324: LD_ADDR_VAR 0 46
41328: PUSH
41329: LD_INT 0
41331: PUSH
41332: LD_INT 0
41334: PUSH
41335: EMPTY
41336: LIST
41337: LIST
41338: PUSH
41339: LD_INT 0
41341: PUSH
41342: LD_INT 1
41344: NEG
41345: PUSH
41346: EMPTY
41347: LIST
41348: LIST
41349: PUSH
41350: LD_INT 1
41352: PUSH
41353: LD_INT 0
41355: PUSH
41356: EMPTY
41357: LIST
41358: LIST
41359: PUSH
41360: LD_INT 1
41362: PUSH
41363: LD_INT 1
41365: PUSH
41366: EMPTY
41367: LIST
41368: LIST
41369: PUSH
41370: LD_INT 0
41372: PUSH
41373: LD_INT 1
41375: PUSH
41376: EMPTY
41377: LIST
41378: LIST
41379: PUSH
41380: LD_INT 1
41382: NEG
41383: PUSH
41384: LD_INT 0
41386: PUSH
41387: EMPTY
41388: LIST
41389: LIST
41390: PUSH
41391: LD_INT 1
41393: NEG
41394: PUSH
41395: LD_INT 1
41397: NEG
41398: PUSH
41399: EMPTY
41400: LIST
41401: LIST
41402: PUSH
41403: LD_INT 1
41405: NEG
41406: PUSH
41407: LD_INT 2
41409: NEG
41410: PUSH
41411: EMPTY
41412: LIST
41413: LIST
41414: PUSH
41415: LD_INT 0
41417: PUSH
41418: LD_INT 2
41420: NEG
41421: PUSH
41422: EMPTY
41423: LIST
41424: LIST
41425: PUSH
41426: LD_INT 1
41428: PUSH
41429: LD_INT 1
41431: NEG
41432: PUSH
41433: EMPTY
41434: LIST
41435: LIST
41436: PUSH
41437: LD_INT 2
41439: PUSH
41440: LD_INT 0
41442: PUSH
41443: EMPTY
41444: LIST
41445: LIST
41446: PUSH
41447: LD_INT 2
41449: PUSH
41450: LD_INT 1
41452: PUSH
41453: EMPTY
41454: LIST
41455: LIST
41456: PUSH
41457: LD_INT 1
41459: PUSH
41460: LD_INT 2
41462: PUSH
41463: EMPTY
41464: LIST
41465: LIST
41466: PUSH
41467: LD_INT 0
41469: PUSH
41470: LD_INT 2
41472: PUSH
41473: EMPTY
41474: LIST
41475: LIST
41476: PUSH
41477: LD_INT 1
41479: NEG
41480: PUSH
41481: LD_INT 1
41483: PUSH
41484: EMPTY
41485: LIST
41486: LIST
41487: PUSH
41488: LD_INT 2
41490: NEG
41491: PUSH
41492: LD_INT 0
41494: PUSH
41495: EMPTY
41496: LIST
41497: LIST
41498: PUSH
41499: LD_INT 2
41501: NEG
41502: PUSH
41503: LD_INT 1
41505: NEG
41506: PUSH
41507: EMPTY
41508: LIST
41509: LIST
41510: PUSH
41511: LD_INT 1
41513: NEG
41514: PUSH
41515: LD_INT 3
41517: NEG
41518: PUSH
41519: EMPTY
41520: LIST
41521: LIST
41522: PUSH
41523: LD_INT 0
41525: PUSH
41526: LD_INT 3
41528: NEG
41529: PUSH
41530: EMPTY
41531: LIST
41532: LIST
41533: PUSH
41534: LD_INT 1
41536: PUSH
41537: LD_INT 2
41539: NEG
41540: PUSH
41541: EMPTY
41542: LIST
41543: LIST
41544: PUSH
41545: LD_INT 2
41547: PUSH
41548: LD_INT 1
41550: NEG
41551: PUSH
41552: EMPTY
41553: LIST
41554: LIST
41555: PUSH
41556: LD_INT 3
41558: PUSH
41559: LD_INT 0
41561: PUSH
41562: EMPTY
41563: LIST
41564: LIST
41565: PUSH
41566: LD_INT 3
41568: PUSH
41569: LD_INT 1
41571: PUSH
41572: EMPTY
41573: LIST
41574: LIST
41575: PUSH
41576: LD_INT 1
41578: PUSH
41579: LD_INT 3
41581: PUSH
41582: EMPTY
41583: LIST
41584: LIST
41585: PUSH
41586: LD_INT 0
41588: PUSH
41589: LD_INT 3
41591: PUSH
41592: EMPTY
41593: LIST
41594: LIST
41595: PUSH
41596: LD_INT 1
41598: NEG
41599: PUSH
41600: LD_INT 2
41602: PUSH
41603: EMPTY
41604: LIST
41605: LIST
41606: PUSH
41607: LD_INT 2
41609: NEG
41610: PUSH
41611: LD_INT 1
41613: PUSH
41614: EMPTY
41615: LIST
41616: LIST
41617: PUSH
41618: LD_INT 3
41620: NEG
41621: PUSH
41622: LD_INT 0
41624: PUSH
41625: EMPTY
41626: LIST
41627: LIST
41628: PUSH
41629: LD_INT 3
41631: NEG
41632: PUSH
41633: LD_INT 1
41635: NEG
41636: PUSH
41637: EMPTY
41638: LIST
41639: LIST
41640: PUSH
41641: EMPTY
41642: LIST
41643: LIST
41644: LIST
41645: LIST
41646: LIST
41647: LIST
41648: LIST
41649: LIST
41650: LIST
41651: LIST
41652: LIST
41653: LIST
41654: LIST
41655: LIST
41656: LIST
41657: LIST
41658: LIST
41659: LIST
41660: LIST
41661: LIST
41662: LIST
41663: LIST
41664: LIST
41665: LIST
41666: LIST
41667: LIST
41668: LIST
41669: LIST
41670: LIST
41671: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
41672: LD_ADDR_VAR 0 47
41676: PUSH
41677: LD_INT 0
41679: PUSH
41680: LD_INT 0
41682: PUSH
41683: EMPTY
41684: LIST
41685: LIST
41686: PUSH
41687: LD_INT 0
41689: PUSH
41690: LD_INT 1
41692: NEG
41693: PUSH
41694: EMPTY
41695: LIST
41696: LIST
41697: PUSH
41698: LD_INT 1
41700: PUSH
41701: LD_INT 0
41703: PUSH
41704: EMPTY
41705: LIST
41706: LIST
41707: PUSH
41708: LD_INT 1
41710: PUSH
41711: LD_INT 1
41713: PUSH
41714: EMPTY
41715: LIST
41716: LIST
41717: PUSH
41718: LD_INT 0
41720: PUSH
41721: LD_INT 1
41723: PUSH
41724: EMPTY
41725: LIST
41726: LIST
41727: PUSH
41728: LD_INT 1
41730: NEG
41731: PUSH
41732: LD_INT 0
41734: PUSH
41735: EMPTY
41736: LIST
41737: LIST
41738: PUSH
41739: LD_INT 1
41741: NEG
41742: PUSH
41743: LD_INT 1
41745: NEG
41746: PUSH
41747: EMPTY
41748: LIST
41749: LIST
41750: PUSH
41751: LD_INT 1
41753: NEG
41754: PUSH
41755: LD_INT 2
41757: NEG
41758: PUSH
41759: EMPTY
41760: LIST
41761: LIST
41762: PUSH
41763: LD_INT 0
41765: PUSH
41766: LD_INT 2
41768: NEG
41769: PUSH
41770: EMPTY
41771: LIST
41772: LIST
41773: PUSH
41774: LD_INT 1
41776: PUSH
41777: LD_INT 1
41779: NEG
41780: PUSH
41781: EMPTY
41782: LIST
41783: LIST
41784: PUSH
41785: LD_INT 2
41787: NEG
41788: PUSH
41789: LD_INT 1
41791: NEG
41792: PUSH
41793: EMPTY
41794: LIST
41795: LIST
41796: PUSH
41797: LD_INT 2
41799: NEG
41800: PUSH
41801: LD_INT 2
41803: NEG
41804: PUSH
41805: EMPTY
41806: LIST
41807: LIST
41808: PUSH
41809: EMPTY
41810: LIST
41811: LIST
41812: LIST
41813: LIST
41814: LIST
41815: LIST
41816: LIST
41817: LIST
41818: LIST
41819: LIST
41820: LIST
41821: LIST
41822: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
41823: LD_ADDR_VAR 0 48
41827: PUSH
41828: LD_INT 0
41830: PUSH
41831: LD_INT 0
41833: PUSH
41834: EMPTY
41835: LIST
41836: LIST
41837: PUSH
41838: LD_INT 0
41840: PUSH
41841: LD_INT 1
41843: NEG
41844: PUSH
41845: EMPTY
41846: LIST
41847: LIST
41848: PUSH
41849: LD_INT 1
41851: PUSH
41852: LD_INT 0
41854: PUSH
41855: EMPTY
41856: LIST
41857: LIST
41858: PUSH
41859: LD_INT 1
41861: PUSH
41862: LD_INT 1
41864: PUSH
41865: EMPTY
41866: LIST
41867: LIST
41868: PUSH
41869: LD_INT 0
41871: PUSH
41872: LD_INT 1
41874: PUSH
41875: EMPTY
41876: LIST
41877: LIST
41878: PUSH
41879: LD_INT 1
41881: NEG
41882: PUSH
41883: LD_INT 0
41885: PUSH
41886: EMPTY
41887: LIST
41888: LIST
41889: PUSH
41890: LD_INT 1
41892: NEG
41893: PUSH
41894: LD_INT 1
41896: NEG
41897: PUSH
41898: EMPTY
41899: LIST
41900: LIST
41901: PUSH
41902: LD_INT 1
41904: NEG
41905: PUSH
41906: LD_INT 2
41908: NEG
41909: PUSH
41910: EMPTY
41911: LIST
41912: LIST
41913: PUSH
41914: LD_INT 0
41916: PUSH
41917: LD_INT 2
41919: NEG
41920: PUSH
41921: EMPTY
41922: LIST
41923: LIST
41924: PUSH
41925: LD_INT 1
41927: PUSH
41928: LD_INT 1
41930: NEG
41931: PUSH
41932: EMPTY
41933: LIST
41934: LIST
41935: PUSH
41936: LD_INT 2
41938: PUSH
41939: LD_INT 0
41941: PUSH
41942: EMPTY
41943: LIST
41944: LIST
41945: PUSH
41946: LD_INT 2
41948: PUSH
41949: LD_INT 1
41951: PUSH
41952: EMPTY
41953: LIST
41954: LIST
41955: PUSH
41956: EMPTY
41957: LIST
41958: LIST
41959: LIST
41960: LIST
41961: LIST
41962: LIST
41963: LIST
41964: LIST
41965: LIST
41966: LIST
41967: LIST
41968: LIST
41969: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
41970: LD_ADDR_VAR 0 49
41974: PUSH
41975: LD_INT 0
41977: PUSH
41978: LD_INT 0
41980: PUSH
41981: EMPTY
41982: LIST
41983: LIST
41984: PUSH
41985: LD_INT 0
41987: PUSH
41988: LD_INT 1
41990: NEG
41991: PUSH
41992: EMPTY
41993: LIST
41994: LIST
41995: PUSH
41996: LD_INT 1
41998: PUSH
41999: LD_INT 0
42001: PUSH
42002: EMPTY
42003: LIST
42004: LIST
42005: PUSH
42006: LD_INT 1
42008: PUSH
42009: LD_INT 1
42011: PUSH
42012: EMPTY
42013: LIST
42014: LIST
42015: PUSH
42016: LD_INT 0
42018: PUSH
42019: LD_INT 1
42021: PUSH
42022: EMPTY
42023: LIST
42024: LIST
42025: PUSH
42026: LD_INT 1
42028: NEG
42029: PUSH
42030: LD_INT 0
42032: PUSH
42033: EMPTY
42034: LIST
42035: LIST
42036: PUSH
42037: LD_INT 1
42039: NEG
42040: PUSH
42041: LD_INT 1
42043: NEG
42044: PUSH
42045: EMPTY
42046: LIST
42047: LIST
42048: PUSH
42049: LD_INT 1
42051: PUSH
42052: LD_INT 1
42054: NEG
42055: PUSH
42056: EMPTY
42057: LIST
42058: LIST
42059: PUSH
42060: LD_INT 2
42062: PUSH
42063: LD_INT 0
42065: PUSH
42066: EMPTY
42067: LIST
42068: LIST
42069: PUSH
42070: LD_INT 2
42072: PUSH
42073: LD_INT 1
42075: PUSH
42076: EMPTY
42077: LIST
42078: LIST
42079: PUSH
42080: LD_INT 2
42082: PUSH
42083: LD_INT 2
42085: PUSH
42086: EMPTY
42087: LIST
42088: LIST
42089: PUSH
42090: LD_INT 1
42092: PUSH
42093: LD_INT 2
42095: PUSH
42096: EMPTY
42097: LIST
42098: LIST
42099: PUSH
42100: EMPTY
42101: LIST
42102: LIST
42103: LIST
42104: LIST
42105: LIST
42106: LIST
42107: LIST
42108: LIST
42109: LIST
42110: LIST
42111: LIST
42112: LIST
42113: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
42114: LD_ADDR_VAR 0 50
42118: PUSH
42119: LD_INT 0
42121: PUSH
42122: LD_INT 0
42124: PUSH
42125: EMPTY
42126: LIST
42127: LIST
42128: PUSH
42129: LD_INT 0
42131: PUSH
42132: LD_INT 1
42134: NEG
42135: PUSH
42136: EMPTY
42137: LIST
42138: LIST
42139: PUSH
42140: LD_INT 1
42142: PUSH
42143: LD_INT 0
42145: PUSH
42146: EMPTY
42147: LIST
42148: LIST
42149: PUSH
42150: LD_INT 1
42152: PUSH
42153: LD_INT 1
42155: PUSH
42156: EMPTY
42157: LIST
42158: LIST
42159: PUSH
42160: LD_INT 0
42162: PUSH
42163: LD_INT 1
42165: PUSH
42166: EMPTY
42167: LIST
42168: LIST
42169: PUSH
42170: LD_INT 1
42172: NEG
42173: PUSH
42174: LD_INT 0
42176: PUSH
42177: EMPTY
42178: LIST
42179: LIST
42180: PUSH
42181: LD_INT 1
42183: NEG
42184: PUSH
42185: LD_INT 1
42187: NEG
42188: PUSH
42189: EMPTY
42190: LIST
42191: LIST
42192: PUSH
42193: LD_INT 2
42195: PUSH
42196: LD_INT 1
42198: PUSH
42199: EMPTY
42200: LIST
42201: LIST
42202: PUSH
42203: LD_INT 2
42205: PUSH
42206: LD_INT 2
42208: PUSH
42209: EMPTY
42210: LIST
42211: LIST
42212: PUSH
42213: LD_INT 1
42215: PUSH
42216: LD_INT 2
42218: PUSH
42219: EMPTY
42220: LIST
42221: LIST
42222: PUSH
42223: LD_INT 0
42225: PUSH
42226: LD_INT 2
42228: PUSH
42229: EMPTY
42230: LIST
42231: LIST
42232: PUSH
42233: LD_INT 1
42235: NEG
42236: PUSH
42237: LD_INT 1
42239: PUSH
42240: EMPTY
42241: LIST
42242: LIST
42243: PUSH
42244: EMPTY
42245: LIST
42246: LIST
42247: LIST
42248: LIST
42249: LIST
42250: LIST
42251: LIST
42252: LIST
42253: LIST
42254: LIST
42255: LIST
42256: LIST
42257: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
42258: LD_ADDR_VAR 0 51
42262: PUSH
42263: LD_INT 0
42265: PUSH
42266: LD_INT 0
42268: PUSH
42269: EMPTY
42270: LIST
42271: LIST
42272: PUSH
42273: LD_INT 0
42275: PUSH
42276: LD_INT 1
42278: NEG
42279: PUSH
42280: EMPTY
42281: LIST
42282: LIST
42283: PUSH
42284: LD_INT 1
42286: PUSH
42287: LD_INT 0
42289: PUSH
42290: EMPTY
42291: LIST
42292: LIST
42293: PUSH
42294: LD_INT 1
42296: PUSH
42297: LD_INT 1
42299: PUSH
42300: EMPTY
42301: LIST
42302: LIST
42303: PUSH
42304: LD_INT 0
42306: PUSH
42307: LD_INT 1
42309: PUSH
42310: EMPTY
42311: LIST
42312: LIST
42313: PUSH
42314: LD_INT 1
42316: NEG
42317: PUSH
42318: LD_INT 0
42320: PUSH
42321: EMPTY
42322: LIST
42323: LIST
42324: PUSH
42325: LD_INT 1
42327: NEG
42328: PUSH
42329: LD_INT 1
42331: NEG
42332: PUSH
42333: EMPTY
42334: LIST
42335: LIST
42336: PUSH
42337: LD_INT 1
42339: PUSH
42340: LD_INT 2
42342: PUSH
42343: EMPTY
42344: LIST
42345: LIST
42346: PUSH
42347: LD_INT 0
42349: PUSH
42350: LD_INT 2
42352: PUSH
42353: EMPTY
42354: LIST
42355: LIST
42356: PUSH
42357: LD_INT 1
42359: NEG
42360: PUSH
42361: LD_INT 1
42363: PUSH
42364: EMPTY
42365: LIST
42366: LIST
42367: PUSH
42368: LD_INT 2
42370: NEG
42371: PUSH
42372: LD_INT 0
42374: PUSH
42375: EMPTY
42376: LIST
42377: LIST
42378: PUSH
42379: LD_INT 2
42381: NEG
42382: PUSH
42383: LD_INT 1
42385: NEG
42386: PUSH
42387: EMPTY
42388: LIST
42389: LIST
42390: PUSH
42391: EMPTY
42392: LIST
42393: LIST
42394: LIST
42395: LIST
42396: LIST
42397: LIST
42398: LIST
42399: LIST
42400: LIST
42401: LIST
42402: LIST
42403: LIST
42404: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
42405: LD_ADDR_VAR 0 52
42409: PUSH
42410: LD_INT 0
42412: PUSH
42413: LD_INT 0
42415: PUSH
42416: EMPTY
42417: LIST
42418: LIST
42419: PUSH
42420: LD_INT 0
42422: PUSH
42423: LD_INT 1
42425: NEG
42426: PUSH
42427: EMPTY
42428: LIST
42429: LIST
42430: PUSH
42431: LD_INT 1
42433: PUSH
42434: LD_INT 0
42436: PUSH
42437: EMPTY
42438: LIST
42439: LIST
42440: PUSH
42441: LD_INT 1
42443: PUSH
42444: LD_INT 1
42446: PUSH
42447: EMPTY
42448: LIST
42449: LIST
42450: PUSH
42451: LD_INT 0
42453: PUSH
42454: LD_INT 1
42456: PUSH
42457: EMPTY
42458: LIST
42459: LIST
42460: PUSH
42461: LD_INT 1
42463: NEG
42464: PUSH
42465: LD_INT 0
42467: PUSH
42468: EMPTY
42469: LIST
42470: LIST
42471: PUSH
42472: LD_INT 1
42474: NEG
42475: PUSH
42476: LD_INT 1
42478: NEG
42479: PUSH
42480: EMPTY
42481: LIST
42482: LIST
42483: PUSH
42484: LD_INT 1
42486: NEG
42487: PUSH
42488: LD_INT 2
42490: NEG
42491: PUSH
42492: EMPTY
42493: LIST
42494: LIST
42495: PUSH
42496: LD_INT 1
42498: NEG
42499: PUSH
42500: LD_INT 1
42502: PUSH
42503: EMPTY
42504: LIST
42505: LIST
42506: PUSH
42507: LD_INT 2
42509: NEG
42510: PUSH
42511: LD_INT 0
42513: PUSH
42514: EMPTY
42515: LIST
42516: LIST
42517: PUSH
42518: LD_INT 2
42520: NEG
42521: PUSH
42522: LD_INT 1
42524: NEG
42525: PUSH
42526: EMPTY
42527: LIST
42528: LIST
42529: PUSH
42530: LD_INT 2
42532: NEG
42533: PUSH
42534: LD_INT 2
42536: NEG
42537: PUSH
42538: EMPTY
42539: LIST
42540: LIST
42541: PUSH
42542: EMPTY
42543: LIST
42544: LIST
42545: LIST
42546: LIST
42547: LIST
42548: LIST
42549: LIST
42550: LIST
42551: LIST
42552: LIST
42553: LIST
42554: LIST
42555: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
42556: LD_ADDR_VAR 0 53
42560: PUSH
42561: LD_INT 0
42563: PUSH
42564: LD_INT 0
42566: PUSH
42567: EMPTY
42568: LIST
42569: LIST
42570: PUSH
42571: LD_INT 0
42573: PUSH
42574: LD_INT 1
42576: NEG
42577: PUSH
42578: EMPTY
42579: LIST
42580: LIST
42581: PUSH
42582: LD_INT 1
42584: PUSH
42585: LD_INT 0
42587: PUSH
42588: EMPTY
42589: LIST
42590: LIST
42591: PUSH
42592: LD_INT 1
42594: PUSH
42595: LD_INT 1
42597: PUSH
42598: EMPTY
42599: LIST
42600: LIST
42601: PUSH
42602: LD_INT 0
42604: PUSH
42605: LD_INT 1
42607: PUSH
42608: EMPTY
42609: LIST
42610: LIST
42611: PUSH
42612: LD_INT 1
42614: NEG
42615: PUSH
42616: LD_INT 0
42618: PUSH
42619: EMPTY
42620: LIST
42621: LIST
42622: PUSH
42623: LD_INT 1
42625: NEG
42626: PUSH
42627: LD_INT 1
42629: NEG
42630: PUSH
42631: EMPTY
42632: LIST
42633: LIST
42634: PUSH
42635: LD_INT 1
42637: NEG
42638: PUSH
42639: LD_INT 2
42641: NEG
42642: PUSH
42643: EMPTY
42644: LIST
42645: LIST
42646: PUSH
42647: LD_INT 0
42649: PUSH
42650: LD_INT 2
42652: NEG
42653: PUSH
42654: EMPTY
42655: LIST
42656: LIST
42657: PUSH
42658: LD_INT 1
42660: PUSH
42661: LD_INT 1
42663: NEG
42664: PUSH
42665: EMPTY
42666: LIST
42667: LIST
42668: PUSH
42669: LD_INT 2
42671: PUSH
42672: LD_INT 0
42674: PUSH
42675: EMPTY
42676: LIST
42677: LIST
42678: PUSH
42679: LD_INT 2
42681: PUSH
42682: LD_INT 1
42684: PUSH
42685: EMPTY
42686: LIST
42687: LIST
42688: PUSH
42689: LD_INT 2
42691: PUSH
42692: LD_INT 2
42694: PUSH
42695: EMPTY
42696: LIST
42697: LIST
42698: PUSH
42699: LD_INT 1
42701: PUSH
42702: LD_INT 2
42704: PUSH
42705: EMPTY
42706: LIST
42707: LIST
42708: PUSH
42709: LD_INT 0
42711: PUSH
42712: LD_INT 2
42714: PUSH
42715: EMPTY
42716: LIST
42717: LIST
42718: PUSH
42719: LD_INT 1
42721: NEG
42722: PUSH
42723: LD_INT 1
42725: PUSH
42726: EMPTY
42727: LIST
42728: LIST
42729: PUSH
42730: LD_INT 2
42732: NEG
42733: PUSH
42734: LD_INT 0
42736: PUSH
42737: EMPTY
42738: LIST
42739: LIST
42740: PUSH
42741: LD_INT 2
42743: NEG
42744: PUSH
42745: LD_INT 1
42747: NEG
42748: PUSH
42749: EMPTY
42750: LIST
42751: LIST
42752: PUSH
42753: LD_INT 2
42755: NEG
42756: PUSH
42757: LD_INT 2
42759: NEG
42760: PUSH
42761: EMPTY
42762: LIST
42763: LIST
42764: PUSH
42765: EMPTY
42766: LIST
42767: LIST
42768: LIST
42769: LIST
42770: LIST
42771: LIST
42772: LIST
42773: LIST
42774: LIST
42775: LIST
42776: LIST
42777: LIST
42778: LIST
42779: LIST
42780: LIST
42781: LIST
42782: LIST
42783: LIST
42784: LIST
42785: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
42786: LD_ADDR_VAR 0 54
42790: PUSH
42791: LD_INT 0
42793: PUSH
42794: LD_INT 0
42796: PUSH
42797: EMPTY
42798: LIST
42799: LIST
42800: PUSH
42801: LD_INT 0
42803: PUSH
42804: LD_INT 1
42806: NEG
42807: PUSH
42808: EMPTY
42809: LIST
42810: LIST
42811: PUSH
42812: LD_INT 1
42814: PUSH
42815: LD_INT 0
42817: PUSH
42818: EMPTY
42819: LIST
42820: LIST
42821: PUSH
42822: LD_INT 1
42824: PUSH
42825: LD_INT 1
42827: PUSH
42828: EMPTY
42829: LIST
42830: LIST
42831: PUSH
42832: LD_INT 0
42834: PUSH
42835: LD_INT 1
42837: PUSH
42838: EMPTY
42839: LIST
42840: LIST
42841: PUSH
42842: LD_INT 1
42844: NEG
42845: PUSH
42846: LD_INT 0
42848: PUSH
42849: EMPTY
42850: LIST
42851: LIST
42852: PUSH
42853: LD_INT 1
42855: NEG
42856: PUSH
42857: LD_INT 1
42859: NEG
42860: PUSH
42861: EMPTY
42862: LIST
42863: LIST
42864: PUSH
42865: LD_INT 1
42867: NEG
42868: PUSH
42869: LD_INT 2
42871: NEG
42872: PUSH
42873: EMPTY
42874: LIST
42875: LIST
42876: PUSH
42877: LD_INT 0
42879: PUSH
42880: LD_INT 2
42882: NEG
42883: PUSH
42884: EMPTY
42885: LIST
42886: LIST
42887: PUSH
42888: LD_INT 1
42890: PUSH
42891: LD_INT 1
42893: NEG
42894: PUSH
42895: EMPTY
42896: LIST
42897: LIST
42898: PUSH
42899: LD_INT 2
42901: PUSH
42902: LD_INT 0
42904: PUSH
42905: EMPTY
42906: LIST
42907: LIST
42908: PUSH
42909: LD_INT 2
42911: PUSH
42912: LD_INT 1
42914: PUSH
42915: EMPTY
42916: LIST
42917: LIST
42918: PUSH
42919: LD_INT 2
42921: PUSH
42922: LD_INT 2
42924: PUSH
42925: EMPTY
42926: LIST
42927: LIST
42928: PUSH
42929: LD_INT 1
42931: PUSH
42932: LD_INT 2
42934: PUSH
42935: EMPTY
42936: LIST
42937: LIST
42938: PUSH
42939: LD_INT 0
42941: PUSH
42942: LD_INT 2
42944: PUSH
42945: EMPTY
42946: LIST
42947: LIST
42948: PUSH
42949: LD_INT 1
42951: NEG
42952: PUSH
42953: LD_INT 1
42955: PUSH
42956: EMPTY
42957: LIST
42958: LIST
42959: PUSH
42960: LD_INT 2
42962: NEG
42963: PUSH
42964: LD_INT 0
42966: PUSH
42967: EMPTY
42968: LIST
42969: LIST
42970: PUSH
42971: LD_INT 2
42973: NEG
42974: PUSH
42975: LD_INT 1
42977: NEG
42978: PUSH
42979: EMPTY
42980: LIST
42981: LIST
42982: PUSH
42983: LD_INT 2
42985: NEG
42986: PUSH
42987: LD_INT 2
42989: NEG
42990: PUSH
42991: EMPTY
42992: LIST
42993: LIST
42994: PUSH
42995: EMPTY
42996: LIST
42997: LIST
42998: LIST
42999: LIST
43000: LIST
43001: LIST
43002: LIST
43003: LIST
43004: LIST
43005: LIST
43006: LIST
43007: LIST
43008: LIST
43009: LIST
43010: LIST
43011: LIST
43012: LIST
43013: LIST
43014: LIST
43015: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
43016: LD_ADDR_VAR 0 55
43020: PUSH
43021: LD_INT 0
43023: PUSH
43024: LD_INT 0
43026: PUSH
43027: EMPTY
43028: LIST
43029: LIST
43030: PUSH
43031: LD_INT 0
43033: PUSH
43034: LD_INT 1
43036: NEG
43037: PUSH
43038: EMPTY
43039: LIST
43040: LIST
43041: PUSH
43042: LD_INT 1
43044: PUSH
43045: LD_INT 0
43047: PUSH
43048: EMPTY
43049: LIST
43050: LIST
43051: PUSH
43052: LD_INT 1
43054: PUSH
43055: LD_INT 1
43057: PUSH
43058: EMPTY
43059: LIST
43060: LIST
43061: PUSH
43062: LD_INT 0
43064: PUSH
43065: LD_INT 1
43067: PUSH
43068: EMPTY
43069: LIST
43070: LIST
43071: PUSH
43072: LD_INT 1
43074: NEG
43075: PUSH
43076: LD_INT 0
43078: PUSH
43079: EMPTY
43080: LIST
43081: LIST
43082: PUSH
43083: LD_INT 1
43085: NEG
43086: PUSH
43087: LD_INT 1
43089: NEG
43090: PUSH
43091: EMPTY
43092: LIST
43093: LIST
43094: PUSH
43095: LD_INT 1
43097: NEG
43098: PUSH
43099: LD_INT 2
43101: NEG
43102: PUSH
43103: EMPTY
43104: LIST
43105: LIST
43106: PUSH
43107: LD_INT 0
43109: PUSH
43110: LD_INT 2
43112: NEG
43113: PUSH
43114: EMPTY
43115: LIST
43116: LIST
43117: PUSH
43118: LD_INT 1
43120: PUSH
43121: LD_INT 1
43123: NEG
43124: PUSH
43125: EMPTY
43126: LIST
43127: LIST
43128: PUSH
43129: LD_INT 2
43131: PUSH
43132: LD_INT 0
43134: PUSH
43135: EMPTY
43136: LIST
43137: LIST
43138: PUSH
43139: LD_INT 2
43141: PUSH
43142: LD_INT 1
43144: PUSH
43145: EMPTY
43146: LIST
43147: LIST
43148: PUSH
43149: LD_INT 2
43151: PUSH
43152: LD_INT 2
43154: PUSH
43155: EMPTY
43156: LIST
43157: LIST
43158: PUSH
43159: LD_INT 1
43161: PUSH
43162: LD_INT 2
43164: PUSH
43165: EMPTY
43166: LIST
43167: LIST
43168: PUSH
43169: LD_INT 0
43171: PUSH
43172: LD_INT 2
43174: PUSH
43175: EMPTY
43176: LIST
43177: LIST
43178: PUSH
43179: LD_INT 1
43181: NEG
43182: PUSH
43183: LD_INT 1
43185: PUSH
43186: EMPTY
43187: LIST
43188: LIST
43189: PUSH
43190: LD_INT 2
43192: NEG
43193: PUSH
43194: LD_INT 0
43196: PUSH
43197: EMPTY
43198: LIST
43199: LIST
43200: PUSH
43201: LD_INT 2
43203: NEG
43204: PUSH
43205: LD_INT 1
43207: NEG
43208: PUSH
43209: EMPTY
43210: LIST
43211: LIST
43212: PUSH
43213: LD_INT 2
43215: NEG
43216: PUSH
43217: LD_INT 2
43219: NEG
43220: PUSH
43221: EMPTY
43222: LIST
43223: LIST
43224: PUSH
43225: EMPTY
43226: LIST
43227: LIST
43228: LIST
43229: LIST
43230: LIST
43231: LIST
43232: LIST
43233: LIST
43234: LIST
43235: LIST
43236: LIST
43237: LIST
43238: LIST
43239: LIST
43240: LIST
43241: LIST
43242: LIST
43243: LIST
43244: LIST
43245: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
43246: LD_ADDR_VAR 0 56
43250: PUSH
43251: LD_INT 0
43253: PUSH
43254: LD_INT 0
43256: PUSH
43257: EMPTY
43258: LIST
43259: LIST
43260: PUSH
43261: LD_INT 0
43263: PUSH
43264: LD_INT 1
43266: NEG
43267: PUSH
43268: EMPTY
43269: LIST
43270: LIST
43271: PUSH
43272: LD_INT 1
43274: PUSH
43275: LD_INT 0
43277: PUSH
43278: EMPTY
43279: LIST
43280: LIST
43281: PUSH
43282: LD_INT 1
43284: PUSH
43285: LD_INT 1
43287: PUSH
43288: EMPTY
43289: LIST
43290: LIST
43291: PUSH
43292: LD_INT 0
43294: PUSH
43295: LD_INT 1
43297: PUSH
43298: EMPTY
43299: LIST
43300: LIST
43301: PUSH
43302: LD_INT 1
43304: NEG
43305: PUSH
43306: LD_INT 0
43308: PUSH
43309: EMPTY
43310: LIST
43311: LIST
43312: PUSH
43313: LD_INT 1
43315: NEG
43316: PUSH
43317: LD_INT 1
43319: NEG
43320: PUSH
43321: EMPTY
43322: LIST
43323: LIST
43324: PUSH
43325: LD_INT 1
43327: NEG
43328: PUSH
43329: LD_INT 2
43331: NEG
43332: PUSH
43333: EMPTY
43334: LIST
43335: LIST
43336: PUSH
43337: LD_INT 0
43339: PUSH
43340: LD_INT 2
43342: NEG
43343: PUSH
43344: EMPTY
43345: LIST
43346: LIST
43347: PUSH
43348: LD_INT 1
43350: PUSH
43351: LD_INT 1
43353: NEG
43354: PUSH
43355: EMPTY
43356: LIST
43357: LIST
43358: PUSH
43359: LD_INT 2
43361: PUSH
43362: LD_INT 0
43364: PUSH
43365: EMPTY
43366: LIST
43367: LIST
43368: PUSH
43369: LD_INT 2
43371: PUSH
43372: LD_INT 1
43374: PUSH
43375: EMPTY
43376: LIST
43377: LIST
43378: PUSH
43379: LD_INT 2
43381: PUSH
43382: LD_INT 2
43384: PUSH
43385: EMPTY
43386: LIST
43387: LIST
43388: PUSH
43389: LD_INT 1
43391: PUSH
43392: LD_INT 2
43394: PUSH
43395: EMPTY
43396: LIST
43397: LIST
43398: PUSH
43399: LD_INT 0
43401: PUSH
43402: LD_INT 2
43404: PUSH
43405: EMPTY
43406: LIST
43407: LIST
43408: PUSH
43409: LD_INT 1
43411: NEG
43412: PUSH
43413: LD_INT 1
43415: PUSH
43416: EMPTY
43417: LIST
43418: LIST
43419: PUSH
43420: LD_INT 2
43422: NEG
43423: PUSH
43424: LD_INT 0
43426: PUSH
43427: EMPTY
43428: LIST
43429: LIST
43430: PUSH
43431: LD_INT 2
43433: NEG
43434: PUSH
43435: LD_INT 1
43437: NEG
43438: PUSH
43439: EMPTY
43440: LIST
43441: LIST
43442: PUSH
43443: LD_INT 2
43445: NEG
43446: PUSH
43447: LD_INT 2
43449: NEG
43450: PUSH
43451: EMPTY
43452: LIST
43453: LIST
43454: PUSH
43455: EMPTY
43456: LIST
43457: LIST
43458: LIST
43459: LIST
43460: LIST
43461: LIST
43462: LIST
43463: LIST
43464: LIST
43465: LIST
43466: LIST
43467: LIST
43468: LIST
43469: LIST
43470: LIST
43471: LIST
43472: LIST
43473: LIST
43474: LIST
43475: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
43476: LD_ADDR_VAR 0 57
43480: PUSH
43481: LD_INT 0
43483: PUSH
43484: LD_INT 0
43486: PUSH
43487: EMPTY
43488: LIST
43489: LIST
43490: PUSH
43491: LD_INT 0
43493: PUSH
43494: LD_INT 1
43496: NEG
43497: PUSH
43498: EMPTY
43499: LIST
43500: LIST
43501: PUSH
43502: LD_INT 1
43504: PUSH
43505: LD_INT 0
43507: PUSH
43508: EMPTY
43509: LIST
43510: LIST
43511: PUSH
43512: LD_INT 1
43514: PUSH
43515: LD_INT 1
43517: PUSH
43518: EMPTY
43519: LIST
43520: LIST
43521: PUSH
43522: LD_INT 0
43524: PUSH
43525: LD_INT 1
43527: PUSH
43528: EMPTY
43529: LIST
43530: LIST
43531: PUSH
43532: LD_INT 1
43534: NEG
43535: PUSH
43536: LD_INT 0
43538: PUSH
43539: EMPTY
43540: LIST
43541: LIST
43542: PUSH
43543: LD_INT 1
43545: NEG
43546: PUSH
43547: LD_INT 1
43549: NEG
43550: PUSH
43551: EMPTY
43552: LIST
43553: LIST
43554: PUSH
43555: LD_INT 1
43557: NEG
43558: PUSH
43559: LD_INT 2
43561: NEG
43562: PUSH
43563: EMPTY
43564: LIST
43565: LIST
43566: PUSH
43567: LD_INT 0
43569: PUSH
43570: LD_INT 2
43572: NEG
43573: PUSH
43574: EMPTY
43575: LIST
43576: LIST
43577: PUSH
43578: LD_INT 1
43580: PUSH
43581: LD_INT 1
43583: NEG
43584: PUSH
43585: EMPTY
43586: LIST
43587: LIST
43588: PUSH
43589: LD_INT 2
43591: PUSH
43592: LD_INT 0
43594: PUSH
43595: EMPTY
43596: LIST
43597: LIST
43598: PUSH
43599: LD_INT 2
43601: PUSH
43602: LD_INT 1
43604: PUSH
43605: EMPTY
43606: LIST
43607: LIST
43608: PUSH
43609: LD_INT 2
43611: PUSH
43612: LD_INT 2
43614: PUSH
43615: EMPTY
43616: LIST
43617: LIST
43618: PUSH
43619: LD_INT 1
43621: PUSH
43622: LD_INT 2
43624: PUSH
43625: EMPTY
43626: LIST
43627: LIST
43628: PUSH
43629: LD_INT 0
43631: PUSH
43632: LD_INT 2
43634: PUSH
43635: EMPTY
43636: LIST
43637: LIST
43638: PUSH
43639: LD_INT 1
43641: NEG
43642: PUSH
43643: LD_INT 1
43645: PUSH
43646: EMPTY
43647: LIST
43648: LIST
43649: PUSH
43650: LD_INT 2
43652: NEG
43653: PUSH
43654: LD_INT 0
43656: PUSH
43657: EMPTY
43658: LIST
43659: LIST
43660: PUSH
43661: LD_INT 2
43663: NEG
43664: PUSH
43665: LD_INT 1
43667: NEG
43668: PUSH
43669: EMPTY
43670: LIST
43671: LIST
43672: PUSH
43673: LD_INT 2
43675: NEG
43676: PUSH
43677: LD_INT 2
43679: NEG
43680: PUSH
43681: EMPTY
43682: LIST
43683: LIST
43684: PUSH
43685: EMPTY
43686: LIST
43687: LIST
43688: LIST
43689: LIST
43690: LIST
43691: LIST
43692: LIST
43693: LIST
43694: LIST
43695: LIST
43696: LIST
43697: LIST
43698: LIST
43699: LIST
43700: LIST
43701: LIST
43702: LIST
43703: LIST
43704: LIST
43705: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
43706: LD_ADDR_VAR 0 58
43710: PUSH
43711: LD_INT 0
43713: PUSH
43714: LD_INT 0
43716: PUSH
43717: EMPTY
43718: LIST
43719: LIST
43720: PUSH
43721: LD_INT 0
43723: PUSH
43724: LD_INT 1
43726: NEG
43727: PUSH
43728: EMPTY
43729: LIST
43730: LIST
43731: PUSH
43732: LD_INT 1
43734: PUSH
43735: LD_INT 0
43737: PUSH
43738: EMPTY
43739: LIST
43740: LIST
43741: PUSH
43742: LD_INT 1
43744: PUSH
43745: LD_INT 1
43747: PUSH
43748: EMPTY
43749: LIST
43750: LIST
43751: PUSH
43752: LD_INT 0
43754: PUSH
43755: LD_INT 1
43757: PUSH
43758: EMPTY
43759: LIST
43760: LIST
43761: PUSH
43762: LD_INT 1
43764: NEG
43765: PUSH
43766: LD_INT 0
43768: PUSH
43769: EMPTY
43770: LIST
43771: LIST
43772: PUSH
43773: LD_INT 1
43775: NEG
43776: PUSH
43777: LD_INT 1
43779: NEG
43780: PUSH
43781: EMPTY
43782: LIST
43783: LIST
43784: PUSH
43785: LD_INT 1
43787: NEG
43788: PUSH
43789: LD_INT 2
43791: NEG
43792: PUSH
43793: EMPTY
43794: LIST
43795: LIST
43796: PUSH
43797: LD_INT 0
43799: PUSH
43800: LD_INT 2
43802: NEG
43803: PUSH
43804: EMPTY
43805: LIST
43806: LIST
43807: PUSH
43808: LD_INT 1
43810: PUSH
43811: LD_INT 1
43813: NEG
43814: PUSH
43815: EMPTY
43816: LIST
43817: LIST
43818: PUSH
43819: LD_INT 2
43821: PUSH
43822: LD_INT 0
43824: PUSH
43825: EMPTY
43826: LIST
43827: LIST
43828: PUSH
43829: LD_INT 2
43831: PUSH
43832: LD_INT 1
43834: PUSH
43835: EMPTY
43836: LIST
43837: LIST
43838: PUSH
43839: LD_INT 2
43841: PUSH
43842: LD_INT 2
43844: PUSH
43845: EMPTY
43846: LIST
43847: LIST
43848: PUSH
43849: LD_INT 1
43851: PUSH
43852: LD_INT 2
43854: PUSH
43855: EMPTY
43856: LIST
43857: LIST
43858: PUSH
43859: LD_INT 0
43861: PUSH
43862: LD_INT 2
43864: PUSH
43865: EMPTY
43866: LIST
43867: LIST
43868: PUSH
43869: LD_INT 1
43871: NEG
43872: PUSH
43873: LD_INT 1
43875: PUSH
43876: EMPTY
43877: LIST
43878: LIST
43879: PUSH
43880: LD_INT 2
43882: NEG
43883: PUSH
43884: LD_INT 0
43886: PUSH
43887: EMPTY
43888: LIST
43889: LIST
43890: PUSH
43891: LD_INT 2
43893: NEG
43894: PUSH
43895: LD_INT 1
43897: NEG
43898: PUSH
43899: EMPTY
43900: LIST
43901: LIST
43902: PUSH
43903: LD_INT 2
43905: NEG
43906: PUSH
43907: LD_INT 2
43909: NEG
43910: PUSH
43911: EMPTY
43912: LIST
43913: LIST
43914: PUSH
43915: EMPTY
43916: LIST
43917: LIST
43918: LIST
43919: LIST
43920: LIST
43921: LIST
43922: LIST
43923: LIST
43924: LIST
43925: LIST
43926: LIST
43927: LIST
43928: LIST
43929: LIST
43930: LIST
43931: LIST
43932: LIST
43933: LIST
43934: LIST
43935: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
43936: LD_ADDR_VAR 0 59
43940: PUSH
43941: LD_INT 0
43943: PUSH
43944: LD_INT 0
43946: PUSH
43947: EMPTY
43948: LIST
43949: LIST
43950: PUSH
43951: LD_INT 0
43953: PUSH
43954: LD_INT 1
43956: NEG
43957: PUSH
43958: EMPTY
43959: LIST
43960: LIST
43961: PUSH
43962: LD_INT 1
43964: PUSH
43965: LD_INT 0
43967: PUSH
43968: EMPTY
43969: LIST
43970: LIST
43971: PUSH
43972: LD_INT 1
43974: PUSH
43975: LD_INT 1
43977: PUSH
43978: EMPTY
43979: LIST
43980: LIST
43981: PUSH
43982: LD_INT 0
43984: PUSH
43985: LD_INT 1
43987: PUSH
43988: EMPTY
43989: LIST
43990: LIST
43991: PUSH
43992: LD_INT 1
43994: NEG
43995: PUSH
43996: LD_INT 0
43998: PUSH
43999: EMPTY
44000: LIST
44001: LIST
44002: PUSH
44003: LD_INT 1
44005: NEG
44006: PUSH
44007: LD_INT 1
44009: NEG
44010: PUSH
44011: EMPTY
44012: LIST
44013: LIST
44014: PUSH
44015: EMPTY
44016: LIST
44017: LIST
44018: LIST
44019: LIST
44020: LIST
44021: LIST
44022: LIST
44023: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
44024: LD_ADDR_VAR 0 60
44028: PUSH
44029: LD_INT 0
44031: PUSH
44032: LD_INT 0
44034: PUSH
44035: EMPTY
44036: LIST
44037: LIST
44038: PUSH
44039: LD_INT 0
44041: PUSH
44042: LD_INT 1
44044: NEG
44045: PUSH
44046: EMPTY
44047: LIST
44048: LIST
44049: PUSH
44050: LD_INT 1
44052: PUSH
44053: LD_INT 0
44055: PUSH
44056: EMPTY
44057: LIST
44058: LIST
44059: PUSH
44060: LD_INT 1
44062: PUSH
44063: LD_INT 1
44065: PUSH
44066: EMPTY
44067: LIST
44068: LIST
44069: PUSH
44070: LD_INT 0
44072: PUSH
44073: LD_INT 1
44075: PUSH
44076: EMPTY
44077: LIST
44078: LIST
44079: PUSH
44080: LD_INT 1
44082: NEG
44083: PUSH
44084: LD_INT 0
44086: PUSH
44087: EMPTY
44088: LIST
44089: LIST
44090: PUSH
44091: LD_INT 1
44093: NEG
44094: PUSH
44095: LD_INT 1
44097: NEG
44098: PUSH
44099: EMPTY
44100: LIST
44101: LIST
44102: PUSH
44103: EMPTY
44104: LIST
44105: LIST
44106: LIST
44107: LIST
44108: LIST
44109: LIST
44110: LIST
44111: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
44112: LD_ADDR_VAR 0 61
44116: PUSH
44117: LD_INT 0
44119: PUSH
44120: LD_INT 0
44122: PUSH
44123: EMPTY
44124: LIST
44125: LIST
44126: PUSH
44127: LD_INT 0
44129: PUSH
44130: LD_INT 1
44132: NEG
44133: PUSH
44134: EMPTY
44135: LIST
44136: LIST
44137: PUSH
44138: LD_INT 1
44140: PUSH
44141: LD_INT 0
44143: PUSH
44144: EMPTY
44145: LIST
44146: LIST
44147: PUSH
44148: LD_INT 1
44150: PUSH
44151: LD_INT 1
44153: PUSH
44154: EMPTY
44155: LIST
44156: LIST
44157: PUSH
44158: LD_INT 0
44160: PUSH
44161: LD_INT 1
44163: PUSH
44164: EMPTY
44165: LIST
44166: LIST
44167: PUSH
44168: LD_INT 1
44170: NEG
44171: PUSH
44172: LD_INT 0
44174: PUSH
44175: EMPTY
44176: LIST
44177: LIST
44178: PUSH
44179: LD_INT 1
44181: NEG
44182: PUSH
44183: LD_INT 1
44185: NEG
44186: PUSH
44187: EMPTY
44188: LIST
44189: LIST
44190: PUSH
44191: EMPTY
44192: LIST
44193: LIST
44194: LIST
44195: LIST
44196: LIST
44197: LIST
44198: LIST
44199: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
44200: LD_ADDR_VAR 0 62
44204: PUSH
44205: LD_INT 0
44207: PUSH
44208: LD_INT 0
44210: PUSH
44211: EMPTY
44212: LIST
44213: LIST
44214: PUSH
44215: LD_INT 0
44217: PUSH
44218: LD_INT 1
44220: NEG
44221: PUSH
44222: EMPTY
44223: LIST
44224: LIST
44225: PUSH
44226: LD_INT 1
44228: PUSH
44229: LD_INT 0
44231: PUSH
44232: EMPTY
44233: LIST
44234: LIST
44235: PUSH
44236: LD_INT 1
44238: PUSH
44239: LD_INT 1
44241: PUSH
44242: EMPTY
44243: LIST
44244: LIST
44245: PUSH
44246: LD_INT 0
44248: PUSH
44249: LD_INT 1
44251: PUSH
44252: EMPTY
44253: LIST
44254: LIST
44255: PUSH
44256: LD_INT 1
44258: NEG
44259: PUSH
44260: LD_INT 0
44262: PUSH
44263: EMPTY
44264: LIST
44265: LIST
44266: PUSH
44267: LD_INT 1
44269: NEG
44270: PUSH
44271: LD_INT 1
44273: NEG
44274: PUSH
44275: EMPTY
44276: LIST
44277: LIST
44278: PUSH
44279: EMPTY
44280: LIST
44281: LIST
44282: LIST
44283: LIST
44284: LIST
44285: LIST
44286: LIST
44287: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
44288: LD_ADDR_VAR 0 63
44292: PUSH
44293: LD_INT 0
44295: PUSH
44296: LD_INT 0
44298: PUSH
44299: EMPTY
44300: LIST
44301: LIST
44302: PUSH
44303: LD_INT 0
44305: PUSH
44306: LD_INT 1
44308: NEG
44309: PUSH
44310: EMPTY
44311: LIST
44312: LIST
44313: PUSH
44314: LD_INT 1
44316: PUSH
44317: LD_INT 0
44319: PUSH
44320: EMPTY
44321: LIST
44322: LIST
44323: PUSH
44324: LD_INT 1
44326: PUSH
44327: LD_INT 1
44329: PUSH
44330: EMPTY
44331: LIST
44332: LIST
44333: PUSH
44334: LD_INT 0
44336: PUSH
44337: LD_INT 1
44339: PUSH
44340: EMPTY
44341: LIST
44342: LIST
44343: PUSH
44344: LD_INT 1
44346: NEG
44347: PUSH
44348: LD_INT 0
44350: PUSH
44351: EMPTY
44352: LIST
44353: LIST
44354: PUSH
44355: LD_INT 1
44357: NEG
44358: PUSH
44359: LD_INT 1
44361: NEG
44362: PUSH
44363: EMPTY
44364: LIST
44365: LIST
44366: PUSH
44367: EMPTY
44368: LIST
44369: LIST
44370: LIST
44371: LIST
44372: LIST
44373: LIST
44374: LIST
44375: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
44376: LD_ADDR_VAR 0 64
44380: PUSH
44381: LD_INT 0
44383: PUSH
44384: LD_INT 0
44386: PUSH
44387: EMPTY
44388: LIST
44389: LIST
44390: PUSH
44391: LD_INT 0
44393: PUSH
44394: LD_INT 1
44396: NEG
44397: PUSH
44398: EMPTY
44399: LIST
44400: LIST
44401: PUSH
44402: LD_INT 1
44404: PUSH
44405: LD_INT 0
44407: PUSH
44408: EMPTY
44409: LIST
44410: LIST
44411: PUSH
44412: LD_INT 1
44414: PUSH
44415: LD_INT 1
44417: PUSH
44418: EMPTY
44419: LIST
44420: LIST
44421: PUSH
44422: LD_INT 0
44424: PUSH
44425: LD_INT 1
44427: PUSH
44428: EMPTY
44429: LIST
44430: LIST
44431: PUSH
44432: LD_INT 1
44434: NEG
44435: PUSH
44436: LD_INT 0
44438: PUSH
44439: EMPTY
44440: LIST
44441: LIST
44442: PUSH
44443: LD_INT 1
44445: NEG
44446: PUSH
44447: LD_INT 1
44449: NEG
44450: PUSH
44451: EMPTY
44452: LIST
44453: LIST
44454: PUSH
44455: EMPTY
44456: LIST
44457: LIST
44458: LIST
44459: LIST
44460: LIST
44461: LIST
44462: LIST
44463: ST_TO_ADDR
// end ; 1 :
44464: GO 50361
44466: LD_INT 1
44468: DOUBLE
44469: EQUAL
44470: IFTRUE 44474
44472: GO 47097
44474: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
44475: LD_ADDR_VAR 0 11
44479: PUSH
44480: LD_INT 1
44482: NEG
44483: PUSH
44484: LD_INT 3
44486: NEG
44487: PUSH
44488: EMPTY
44489: LIST
44490: LIST
44491: PUSH
44492: LD_INT 0
44494: PUSH
44495: LD_INT 3
44497: NEG
44498: PUSH
44499: EMPTY
44500: LIST
44501: LIST
44502: PUSH
44503: LD_INT 1
44505: PUSH
44506: LD_INT 2
44508: NEG
44509: PUSH
44510: EMPTY
44511: LIST
44512: LIST
44513: PUSH
44514: EMPTY
44515: LIST
44516: LIST
44517: LIST
44518: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
44519: LD_ADDR_VAR 0 12
44523: PUSH
44524: LD_INT 2
44526: PUSH
44527: LD_INT 1
44529: NEG
44530: PUSH
44531: EMPTY
44532: LIST
44533: LIST
44534: PUSH
44535: LD_INT 3
44537: PUSH
44538: LD_INT 0
44540: PUSH
44541: EMPTY
44542: LIST
44543: LIST
44544: PUSH
44545: LD_INT 3
44547: PUSH
44548: LD_INT 1
44550: PUSH
44551: EMPTY
44552: LIST
44553: LIST
44554: PUSH
44555: EMPTY
44556: LIST
44557: LIST
44558: LIST
44559: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
44560: LD_ADDR_VAR 0 13
44564: PUSH
44565: LD_INT 3
44567: PUSH
44568: LD_INT 2
44570: PUSH
44571: EMPTY
44572: LIST
44573: LIST
44574: PUSH
44575: LD_INT 3
44577: PUSH
44578: LD_INT 3
44580: PUSH
44581: EMPTY
44582: LIST
44583: LIST
44584: PUSH
44585: LD_INT 2
44587: PUSH
44588: LD_INT 3
44590: PUSH
44591: EMPTY
44592: LIST
44593: LIST
44594: PUSH
44595: EMPTY
44596: LIST
44597: LIST
44598: LIST
44599: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
44600: LD_ADDR_VAR 0 14
44604: PUSH
44605: LD_INT 1
44607: PUSH
44608: LD_INT 3
44610: PUSH
44611: EMPTY
44612: LIST
44613: LIST
44614: PUSH
44615: LD_INT 0
44617: PUSH
44618: LD_INT 3
44620: PUSH
44621: EMPTY
44622: LIST
44623: LIST
44624: PUSH
44625: LD_INT 1
44627: NEG
44628: PUSH
44629: LD_INT 2
44631: PUSH
44632: EMPTY
44633: LIST
44634: LIST
44635: PUSH
44636: EMPTY
44637: LIST
44638: LIST
44639: LIST
44640: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
44641: LD_ADDR_VAR 0 15
44645: PUSH
44646: LD_INT 2
44648: NEG
44649: PUSH
44650: LD_INT 1
44652: PUSH
44653: EMPTY
44654: LIST
44655: LIST
44656: PUSH
44657: LD_INT 3
44659: NEG
44660: PUSH
44661: LD_INT 0
44663: PUSH
44664: EMPTY
44665: LIST
44666: LIST
44667: PUSH
44668: LD_INT 3
44670: NEG
44671: PUSH
44672: LD_INT 1
44674: NEG
44675: PUSH
44676: EMPTY
44677: LIST
44678: LIST
44679: PUSH
44680: EMPTY
44681: LIST
44682: LIST
44683: LIST
44684: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
44685: LD_ADDR_VAR 0 16
44689: PUSH
44690: LD_INT 2
44692: NEG
44693: PUSH
44694: LD_INT 3
44696: NEG
44697: PUSH
44698: EMPTY
44699: LIST
44700: LIST
44701: PUSH
44702: LD_INT 3
44704: NEG
44705: PUSH
44706: LD_INT 2
44708: NEG
44709: PUSH
44710: EMPTY
44711: LIST
44712: LIST
44713: PUSH
44714: LD_INT 3
44716: NEG
44717: PUSH
44718: LD_INT 3
44720: NEG
44721: PUSH
44722: EMPTY
44723: LIST
44724: LIST
44725: PUSH
44726: EMPTY
44727: LIST
44728: LIST
44729: LIST
44730: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
44731: LD_ADDR_VAR 0 17
44735: PUSH
44736: LD_INT 1
44738: NEG
44739: PUSH
44740: LD_INT 3
44742: NEG
44743: PUSH
44744: EMPTY
44745: LIST
44746: LIST
44747: PUSH
44748: LD_INT 0
44750: PUSH
44751: LD_INT 3
44753: NEG
44754: PUSH
44755: EMPTY
44756: LIST
44757: LIST
44758: PUSH
44759: LD_INT 1
44761: PUSH
44762: LD_INT 2
44764: NEG
44765: PUSH
44766: EMPTY
44767: LIST
44768: LIST
44769: PUSH
44770: EMPTY
44771: LIST
44772: LIST
44773: LIST
44774: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
44775: LD_ADDR_VAR 0 18
44779: PUSH
44780: LD_INT 2
44782: PUSH
44783: LD_INT 1
44785: NEG
44786: PUSH
44787: EMPTY
44788: LIST
44789: LIST
44790: PUSH
44791: LD_INT 3
44793: PUSH
44794: LD_INT 0
44796: PUSH
44797: EMPTY
44798: LIST
44799: LIST
44800: PUSH
44801: LD_INT 3
44803: PUSH
44804: LD_INT 1
44806: PUSH
44807: EMPTY
44808: LIST
44809: LIST
44810: PUSH
44811: EMPTY
44812: LIST
44813: LIST
44814: LIST
44815: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
44816: LD_ADDR_VAR 0 19
44820: PUSH
44821: LD_INT 3
44823: PUSH
44824: LD_INT 2
44826: PUSH
44827: EMPTY
44828: LIST
44829: LIST
44830: PUSH
44831: LD_INT 3
44833: PUSH
44834: LD_INT 3
44836: PUSH
44837: EMPTY
44838: LIST
44839: LIST
44840: PUSH
44841: LD_INT 2
44843: PUSH
44844: LD_INT 3
44846: PUSH
44847: EMPTY
44848: LIST
44849: LIST
44850: PUSH
44851: EMPTY
44852: LIST
44853: LIST
44854: LIST
44855: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
44856: LD_ADDR_VAR 0 20
44860: PUSH
44861: LD_INT 1
44863: PUSH
44864: LD_INT 3
44866: PUSH
44867: EMPTY
44868: LIST
44869: LIST
44870: PUSH
44871: LD_INT 0
44873: PUSH
44874: LD_INT 3
44876: PUSH
44877: EMPTY
44878: LIST
44879: LIST
44880: PUSH
44881: LD_INT 1
44883: NEG
44884: PUSH
44885: LD_INT 2
44887: PUSH
44888: EMPTY
44889: LIST
44890: LIST
44891: PUSH
44892: EMPTY
44893: LIST
44894: LIST
44895: LIST
44896: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
44897: LD_ADDR_VAR 0 21
44901: PUSH
44902: LD_INT 2
44904: NEG
44905: PUSH
44906: LD_INT 1
44908: PUSH
44909: EMPTY
44910: LIST
44911: LIST
44912: PUSH
44913: LD_INT 3
44915: NEG
44916: PUSH
44917: LD_INT 0
44919: PUSH
44920: EMPTY
44921: LIST
44922: LIST
44923: PUSH
44924: LD_INT 3
44926: NEG
44927: PUSH
44928: LD_INT 1
44930: NEG
44931: PUSH
44932: EMPTY
44933: LIST
44934: LIST
44935: PUSH
44936: EMPTY
44937: LIST
44938: LIST
44939: LIST
44940: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
44941: LD_ADDR_VAR 0 22
44945: PUSH
44946: LD_INT 2
44948: NEG
44949: PUSH
44950: LD_INT 3
44952: NEG
44953: PUSH
44954: EMPTY
44955: LIST
44956: LIST
44957: PUSH
44958: LD_INT 3
44960: NEG
44961: PUSH
44962: LD_INT 2
44964: NEG
44965: PUSH
44966: EMPTY
44967: LIST
44968: LIST
44969: PUSH
44970: LD_INT 3
44972: NEG
44973: PUSH
44974: LD_INT 3
44976: NEG
44977: PUSH
44978: EMPTY
44979: LIST
44980: LIST
44981: PUSH
44982: EMPTY
44983: LIST
44984: LIST
44985: LIST
44986: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
44987: LD_ADDR_VAR 0 23
44991: PUSH
44992: LD_INT 0
44994: PUSH
44995: LD_INT 3
44997: NEG
44998: PUSH
44999: EMPTY
45000: LIST
45001: LIST
45002: PUSH
45003: LD_INT 1
45005: NEG
45006: PUSH
45007: LD_INT 4
45009: NEG
45010: PUSH
45011: EMPTY
45012: LIST
45013: LIST
45014: PUSH
45015: LD_INT 1
45017: PUSH
45018: LD_INT 3
45020: NEG
45021: PUSH
45022: EMPTY
45023: LIST
45024: LIST
45025: PUSH
45026: EMPTY
45027: LIST
45028: LIST
45029: LIST
45030: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
45031: LD_ADDR_VAR 0 24
45035: PUSH
45036: LD_INT 3
45038: PUSH
45039: LD_INT 0
45041: PUSH
45042: EMPTY
45043: LIST
45044: LIST
45045: PUSH
45046: LD_INT 3
45048: PUSH
45049: LD_INT 1
45051: NEG
45052: PUSH
45053: EMPTY
45054: LIST
45055: LIST
45056: PUSH
45057: LD_INT 4
45059: PUSH
45060: LD_INT 1
45062: PUSH
45063: EMPTY
45064: LIST
45065: LIST
45066: PUSH
45067: EMPTY
45068: LIST
45069: LIST
45070: LIST
45071: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
45072: LD_ADDR_VAR 0 25
45076: PUSH
45077: LD_INT 3
45079: PUSH
45080: LD_INT 3
45082: PUSH
45083: EMPTY
45084: LIST
45085: LIST
45086: PUSH
45087: LD_INT 4
45089: PUSH
45090: LD_INT 3
45092: PUSH
45093: EMPTY
45094: LIST
45095: LIST
45096: PUSH
45097: LD_INT 3
45099: PUSH
45100: LD_INT 4
45102: PUSH
45103: EMPTY
45104: LIST
45105: LIST
45106: PUSH
45107: EMPTY
45108: LIST
45109: LIST
45110: LIST
45111: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
45112: LD_ADDR_VAR 0 26
45116: PUSH
45117: LD_INT 0
45119: PUSH
45120: LD_INT 3
45122: PUSH
45123: EMPTY
45124: LIST
45125: LIST
45126: PUSH
45127: LD_INT 1
45129: PUSH
45130: LD_INT 4
45132: PUSH
45133: EMPTY
45134: LIST
45135: LIST
45136: PUSH
45137: LD_INT 1
45139: NEG
45140: PUSH
45141: LD_INT 3
45143: PUSH
45144: EMPTY
45145: LIST
45146: LIST
45147: PUSH
45148: EMPTY
45149: LIST
45150: LIST
45151: LIST
45152: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
45153: LD_ADDR_VAR 0 27
45157: PUSH
45158: LD_INT 3
45160: NEG
45161: PUSH
45162: LD_INT 0
45164: PUSH
45165: EMPTY
45166: LIST
45167: LIST
45168: PUSH
45169: LD_INT 3
45171: NEG
45172: PUSH
45173: LD_INT 1
45175: PUSH
45176: EMPTY
45177: LIST
45178: LIST
45179: PUSH
45180: LD_INT 4
45182: NEG
45183: PUSH
45184: LD_INT 1
45186: NEG
45187: PUSH
45188: EMPTY
45189: LIST
45190: LIST
45191: PUSH
45192: EMPTY
45193: LIST
45194: LIST
45195: LIST
45196: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
45197: LD_ADDR_VAR 0 28
45201: PUSH
45202: LD_INT 3
45204: NEG
45205: PUSH
45206: LD_INT 3
45208: NEG
45209: PUSH
45210: EMPTY
45211: LIST
45212: LIST
45213: PUSH
45214: LD_INT 3
45216: NEG
45217: PUSH
45218: LD_INT 4
45220: NEG
45221: PUSH
45222: EMPTY
45223: LIST
45224: LIST
45225: PUSH
45226: LD_INT 4
45228: NEG
45229: PUSH
45230: LD_INT 3
45232: NEG
45233: PUSH
45234: EMPTY
45235: LIST
45236: LIST
45237: PUSH
45238: EMPTY
45239: LIST
45240: LIST
45241: LIST
45242: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
45243: LD_ADDR_VAR 0 29
45247: PUSH
45248: LD_INT 1
45250: NEG
45251: PUSH
45252: LD_INT 3
45254: NEG
45255: PUSH
45256: EMPTY
45257: LIST
45258: LIST
45259: PUSH
45260: LD_INT 0
45262: PUSH
45263: LD_INT 3
45265: NEG
45266: PUSH
45267: EMPTY
45268: LIST
45269: LIST
45270: PUSH
45271: LD_INT 1
45273: PUSH
45274: LD_INT 2
45276: NEG
45277: PUSH
45278: EMPTY
45279: LIST
45280: LIST
45281: PUSH
45282: LD_INT 1
45284: NEG
45285: PUSH
45286: LD_INT 4
45288: NEG
45289: PUSH
45290: EMPTY
45291: LIST
45292: LIST
45293: PUSH
45294: LD_INT 0
45296: PUSH
45297: LD_INT 4
45299: NEG
45300: PUSH
45301: EMPTY
45302: LIST
45303: LIST
45304: PUSH
45305: LD_INT 1
45307: PUSH
45308: LD_INT 3
45310: NEG
45311: PUSH
45312: EMPTY
45313: LIST
45314: LIST
45315: PUSH
45316: LD_INT 1
45318: NEG
45319: PUSH
45320: LD_INT 5
45322: NEG
45323: PUSH
45324: EMPTY
45325: LIST
45326: LIST
45327: PUSH
45328: LD_INT 0
45330: PUSH
45331: LD_INT 5
45333: NEG
45334: PUSH
45335: EMPTY
45336: LIST
45337: LIST
45338: PUSH
45339: LD_INT 1
45341: PUSH
45342: LD_INT 4
45344: NEG
45345: PUSH
45346: EMPTY
45347: LIST
45348: LIST
45349: PUSH
45350: LD_INT 1
45352: NEG
45353: PUSH
45354: LD_INT 6
45356: NEG
45357: PUSH
45358: EMPTY
45359: LIST
45360: LIST
45361: PUSH
45362: LD_INT 0
45364: PUSH
45365: LD_INT 6
45367: NEG
45368: PUSH
45369: EMPTY
45370: LIST
45371: LIST
45372: PUSH
45373: LD_INT 1
45375: PUSH
45376: LD_INT 5
45378: NEG
45379: PUSH
45380: EMPTY
45381: LIST
45382: LIST
45383: PUSH
45384: EMPTY
45385: LIST
45386: LIST
45387: LIST
45388: LIST
45389: LIST
45390: LIST
45391: LIST
45392: LIST
45393: LIST
45394: LIST
45395: LIST
45396: LIST
45397: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
45398: LD_ADDR_VAR 0 30
45402: PUSH
45403: LD_INT 2
45405: PUSH
45406: LD_INT 1
45408: NEG
45409: PUSH
45410: EMPTY
45411: LIST
45412: LIST
45413: PUSH
45414: LD_INT 3
45416: PUSH
45417: LD_INT 0
45419: PUSH
45420: EMPTY
45421: LIST
45422: LIST
45423: PUSH
45424: LD_INT 3
45426: PUSH
45427: LD_INT 1
45429: PUSH
45430: EMPTY
45431: LIST
45432: LIST
45433: PUSH
45434: LD_INT 3
45436: PUSH
45437: LD_INT 1
45439: NEG
45440: PUSH
45441: EMPTY
45442: LIST
45443: LIST
45444: PUSH
45445: LD_INT 4
45447: PUSH
45448: LD_INT 0
45450: PUSH
45451: EMPTY
45452: LIST
45453: LIST
45454: PUSH
45455: LD_INT 4
45457: PUSH
45458: LD_INT 1
45460: PUSH
45461: EMPTY
45462: LIST
45463: LIST
45464: PUSH
45465: LD_INT 4
45467: PUSH
45468: LD_INT 1
45470: NEG
45471: PUSH
45472: EMPTY
45473: LIST
45474: LIST
45475: PUSH
45476: LD_INT 5
45478: PUSH
45479: LD_INT 0
45481: PUSH
45482: EMPTY
45483: LIST
45484: LIST
45485: PUSH
45486: LD_INT 5
45488: PUSH
45489: LD_INT 1
45491: PUSH
45492: EMPTY
45493: LIST
45494: LIST
45495: PUSH
45496: LD_INT 5
45498: PUSH
45499: LD_INT 1
45501: NEG
45502: PUSH
45503: EMPTY
45504: LIST
45505: LIST
45506: PUSH
45507: LD_INT 6
45509: PUSH
45510: LD_INT 0
45512: PUSH
45513: EMPTY
45514: LIST
45515: LIST
45516: PUSH
45517: LD_INT 6
45519: PUSH
45520: LD_INT 1
45522: PUSH
45523: EMPTY
45524: LIST
45525: LIST
45526: PUSH
45527: EMPTY
45528: LIST
45529: LIST
45530: LIST
45531: LIST
45532: LIST
45533: LIST
45534: LIST
45535: LIST
45536: LIST
45537: LIST
45538: LIST
45539: LIST
45540: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
45541: LD_ADDR_VAR 0 31
45545: PUSH
45546: LD_INT 3
45548: PUSH
45549: LD_INT 2
45551: PUSH
45552: EMPTY
45553: LIST
45554: LIST
45555: PUSH
45556: LD_INT 3
45558: PUSH
45559: LD_INT 3
45561: PUSH
45562: EMPTY
45563: LIST
45564: LIST
45565: PUSH
45566: LD_INT 2
45568: PUSH
45569: LD_INT 3
45571: PUSH
45572: EMPTY
45573: LIST
45574: LIST
45575: PUSH
45576: LD_INT 4
45578: PUSH
45579: LD_INT 3
45581: PUSH
45582: EMPTY
45583: LIST
45584: LIST
45585: PUSH
45586: LD_INT 4
45588: PUSH
45589: LD_INT 4
45591: PUSH
45592: EMPTY
45593: LIST
45594: LIST
45595: PUSH
45596: LD_INT 3
45598: PUSH
45599: LD_INT 4
45601: PUSH
45602: EMPTY
45603: LIST
45604: LIST
45605: PUSH
45606: LD_INT 5
45608: PUSH
45609: LD_INT 4
45611: PUSH
45612: EMPTY
45613: LIST
45614: LIST
45615: PUSH
45616: LD_INT 5
45618: PUSH
45619: LD_INT 5
45621: PUSH
45622: EMPTY
45623: LIST
45624: LIST
45625: PUSH
45626: LD_INT 4
45628: PUSH
45629: LD_INT 5
45631: PUSH
45632: EMPTY
45633: LIST
45634: LIST
45635: PUSH
45636: LD_INT 6
45638: PUSH
45639: LD_INT 5
45641: PUSH
45642: EMPTY
45643: LIST
45644: LIST
45645: PUSH
45646: LD_INT 6
45648: PUSH
45649: LD_INT 6
45651: PUSH
45652: EMPTY
45653: LIST
45654: LIST
45655: PUSH
45656: LD_INT 5
45658: PUSH
45659: LD_INT 6
45661: PUSH
45662: EMPTY
45663: LIST
45664: LIST
45665: PUSH
45666: EMPTY
45667: LIST
45668: LIST
45669: LIST
45670: LIST
45671: LIST
45672: LIST
45673: LIST
45674: LIST
45675: LIST
45676: LIST
45677: LIST
45678: LIST
45679: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
45680: LD_ADDR_VAR 0 32
45684: PUSH
45685: LD_INT 1
45687: PUSH
45688: LD_INT 3
45690: PUSH
45691: EMPTY
45692: LIST
45693: LIST
45694: PUSH
45695: LD_INT 0
45697: PUSH
45698: LD_INT 3
45700: PUSH
45701: EMPTY
45702: LIST
45703: LIST
45704: PUSH
45705: LD_INT 1
45707: NEG
45708: PUSH
45709: LD_INT 2
45711: PUSH
45712: EMPTY
45713: LIST
45714: LIST
45715: PUSH
45716: LD_INT 1
45718: PUSH
45719: LD_INT 4
45721: PUSH
45722: EMPTY
45723: LIST
45724: LIST
45725: PUSH
45726: LD_INT 0
45728: PUSH
45729: LD_INT 4
45731: PUSH
45732: EMPTY
45733: LIST
45734: LIST
45735: PUSH
45736: LD_INT 1
45738: NEG
45739: PUSH
45740: LD_INT 3
45742: PUSH
45743: EMPTY
45744: LIST
45745: LIST
45746: PUSH
45747: LD_INT 1
45749: PUSH
45750: LD_INT 5
45752: PUSH
45753: EMPTY
45754: LIST
45755: LIST
45756: PUSH
45757: LD_INT 0
45759: PUSH
45760: LD_INT 5
45762: PUSH
45763: EMPTY
45764: LIST
45765: LIST
45766: PUSH
45767: LD_INT 1
45769: NEG
45770: PUSH
45771: LD_INT 4
45773: PUSH
45774: EMPTY
45775: LIST
45776: LIST
45777: PUSH
45778: LD_INT 1
45780: PUSH
45781: LD_INT 6
45783: PUSH
45784: EMPTY
45785: LIST
45786: LIST
45787: PUSH
45788: LD_INT 0
45790: PUSH
45791: LD_INT 6
45793: PUSH
45794: EMPTY
45795: LIST
45796: LIST
45797: PUSH
45798: LD_INT 1
45800: NEG
45801: PUSH
45802: LD_INT 5
45804: PUSH
45805: EMPTY
45806: LIST
45807: LIST
45808: PUSH
45809: EMPTY
45810: LIST
45811: LIST
45812: LIST
45813: LIST
45814: LIST
45815: LIST
45816: LIST
45817: LIST
45818: LIST
45819: LIST
45820: LIST
45821: LIST
45822: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
45823: LD_ADDR_VAR 0 33
45827: PUSH
45828: LD_INT 2
45830: NEG
45831: PUSH
45832: LD_INT 1
45834: PUSH
45835: EMPTY
45836: LIST
45837: LIST
45838: PUSH
45839: LD_INT 3
45841: NEG
45842: PUSH
45843: LD_INT 0
45845: PUSH
45846: EMPTY
45847: LIST
45848: LIST
45849: PUSH
45850: LD_INT 3
45852: NEG
45853: PUSH
45854: LD_INT 1
45856: NEG
45857: PUSH
45858: EMPTY
45859: LIST
45860: LIST
45861: PUSH
45862: LD_INT 3
45864: NEG
45865: PUSH
45866: LD_INT 1
45868: PUSH
45869: EMPTY
45870: LIST
45871: LIST
45872: PUSH
45873: LD_INT 4
45875: NEG
45876: PUSH
45877: LD_INT 0
45879: PUSH
45880: EMPTY
45881: LIST
45882: LIST
45883: PUSH
45884: LD_INT 4
45886: NEG
45887: PUSH
45888: LD_INT 1
45890: NEG
45891: PUSH
45892: EMPTY
45893: LIST
45894: LIST
45895: PUSH
45896: LD_INT 4
45898: NEG
45899: PUSH
45900: LD_INT 1
45902: PUSH
45903: EMPTY
45904: LIST
45905: LIST
45906: PUSH
45907: LD_INT 5
45909: NEG
45910: PUSH
45911: LD_INT 0
45913: PUSH
45914: EMPTY
45915: LIST
45916: LIST
45917: PUSH
45918: LD_INT 5
45920: NEG
45921: PUSH
45922: LD_INT 1
45924: NEG
45925: PUSH
45926: EMPTY
45927: LIST
45928: LIST
45929: PUSH
45930: LD_INT 5
45932: NEG
45933: PUSH
45934: LD_INT 1
45936: PUSH
45937: EMPTY
45938: LIST
45939: LIST
45940: PUSH
45941: LD_INT 6
45943: NEG
45944: PUSH
45945: LD_INT 0
45947: PUSH
45948: EMPTY
45949: LIST
45950: LIST
45951: PUSH
45952: LD_INT 6
45954: NEG
45955: PUSH
45956: LD_INT 1
45958: NEG
45959: PUSH
45960: EMPTY
45961: LIST
45962: LIST
45963: PUSH
45964: EMPTY
45965: LIST
45966: LIST
45967: LIST
45968: LIST
45969: LIST
45970: LIST
45971: LIST
45972: LIST
45973: LIST
45974: LIST
45975: LIST
45976: LIST
45977: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
45978: LD_ADDR_VAR 0 34
45982: PUSH
45983: LD_INT 2
45985: NEG
45986: PUSH
45987: LD_INT 3
45989: NEG
45990: PUSH
45991: EMPTY
45992: LIST
45993: LIST
45994: PUSH
45995: LD_INT 3
45997: NEG
45998: PUSH
45999: LD_INT 2
46001: NEG
46002: PUSH
46003: EMPTY
46004: LIST
46005: LIST
46006: PUSH
46007: LD_INT 3
46009: NEG
46010: PUSH
46011: LD_INT 3
46013: NEG
46014: PUSH
46015: EMPTY
46016: LIST
46017: LIST
46018: PUSH
46019: LD_INT 3
46021: NEG
46022: PUSH
46023: LD_INT 4
46025: NEG
46026: PUSH
46027: EMPTY
46028: LIST
46029: LIST
46030: PUSH
46031: LD_INT 4
46033: NEG
46034: PUSH
46035: LD_INT 3
46037: NEG
46038: PUSH
46039: EMPTY
46040: LIST
46041: LIST
46042: PUSH
46043: LD_INT 4
46045: NEG
46046: PUSH
46047: LD_INT 4
46049: NEG
46050: PUSH
46051: EMPTY
46052: LIST
46053: LIST
46054: PUSH
46055: LD_INT 4
46057: NEG
46058: PUSH
46059: LD_INT 5
46061: NEG
46062: PUSH
46063: EMPTY
46064: LIST
46065: LIST
46066: PUSH
46067: LD_INT 5
46069: NEG
46070: PUSH
46071: LD_INT 4
46073: NEG
46074: PUSH
46075: EMPTY
46076: LIST
46077: LIST
46078: PUSH
46079: LD_INT 5
46081: NEG
46082: PUSH
46083: LD_INT 5
46085: NEG
46086: PUSH
46087: EMPTY
46088: LIST
46089: LIST
46090: PUSH
46091: LD_INT 5
46093: NEG
46094: PUSH
46095: LD_INT 6
46097: NEG
46098: PUSH
46099: EMPTY
46100: LIST
46101: LIST
46102: PUSH
46103: LD_INT 6
46105: NEG
46106: PUSH
46107: LD_INT 5
46109: NEG
46110: PUSH
46111: EMPTY
46112: LIST
46113: LIST
46114: PUSH
46115: LD_INT 6
46117: NEG
46118: PUSH
46119: LD_INT 6
46121: NEG
46122: PUSH
46123: EMPTY
46124: LIST
46125: LIST
46126: PUSH
46127: EMPTY
46128: LIST
46129: LIST
46130: LIST
46131: LIST
46132: LIST
46133: LIST
46134: LIST
46135: LIST
46136: LIST
46137: LIST
46138: LIST
46139: LIST
46140: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
46141: LD_ADDR_VAR 0 41
46145: PUSH
46146: LD_INT 0
46148: PUSH
46149: LD_INT 2
46151: NEG
46152: PUSH
46153: EMPTY
46154: LIST
46155: LIST
46156: PUSH
46157: LD_INT 1
46159: NEG
46160: PUSH
46161: LD_INT 3
46163: NEG
46164: PUSH
46165: EMPTY
46166: LIST
46167: LIST
46168: PUSH
46169: LD_INT 1
46171: PUSH
46172: LD_INT 2
46174: NEG
46175: PUSH
46176: EMPTY
46177: LIST
46178: LIST
46179: PUSH
46180: EMPTY
46181: LIST
46182: LIST
46183: LIST
46184: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
46185: LD_ADDR_VAR 0 42
46189: PUSH
46190: LD_INT 2
46192: PUSH
46193: LD_INT 0
46195: PUSH
46196: EMPTY
46197: LIST
46198: LIST
46199: PUSH
46200: LD_INT 2
46202: PUSH
46203: LD_INT 1
46205: NEG
46206: PUSH
46207: EMPTY
46208: LIST
46209: LIST
46210: PUSH
46211: LD_INT 3
46213: PUSH
46214: LD_INT 1
46216: PUSH
46217: EMPTY
46218: LIST
46219: LIST
46220: PUSH
46221: EMPTY
46222: LIST
46223: LIST
46224: LIST
46225: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
46226: LD_ADDR_VAR 0 43
46230: PUSH
46231: LD_INT 2
46233: PUSH
46234: LD_INT 2
46236: PUSH
46237: EMPTY
46238: LIST
46239: LIST
46240: PUSH
46241: LD_INT 3
46243: PUSH
46244: LD_INT 2
46246: PUSH
46247: EMPTY
46248: LIST
46249: LIST
46250: PUSH
46251: LD_INT 2
46253: PUSH
46254: LD_INT 3
46256: PUSH
46257: EMPTY
46258: LIST
46259: LIST
46260: PUSH
46261: EMPTY
46262: LIST
46263: LIST
46264: LIST
46265: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
46266: LD_ADDR_VAR 0 44
46270: PUSH
46271: LD_INT 0
46273: PUSH
46274: LD_INT 2
46276: PUSH
46277: EMPTY
46278: LIST
46279: LIST
46280: PUSH
46281: LD_INT 1
46283: PUSH
46284: LD_INT 3
46286: PUSH
46287: EMPTY
46288: LIST
46289: LIST
46290: PUSH
46291: LD_INT 1
46293: NEG
46294: PUSH
46295: LD_INT 2
46297: PUSH
46298: EMPTY
46299: LIST
46300: LIST
46301: PUSH
46302: EMPTY
46303: LIST
46304: LIST
46305: LIST
46306: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
46307: LD_ADDR_VAR 0 45
46311: PUSH
46312: LD_INT 2
46314: NEG
46315: PUSH
46316: LD_INT 0
46318: PUSH
46319: EMPTY
46320: LIST
46321: LIST
46322: PUSH
46323: LD_INT 2
46325: NEG
46326: PUSH
46327: LD_INT 1
46329: PUSH
46330: EMPTY
46331: LIST
46332: LIST
46333: PUSH
46334: LD_INT 3
46336: NEG
46337: PUSH
46338: LD_INT 1
46340: NEG
46341: PUSH
46342: EMPTY
46343: LIST
46344: LIST
46345: PUSH
46346: EMPTY
46347: LIST
46348: LIST
46349: LIST
46350: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
46351: LD_ADDR_VAR 0 46
46355: PUSH
46356: LD_INT 2
46358: NEG
46359: PUSH
46360: LD_INT 2
46362: NEG
46363: PUSH
46364: EMPTY
46365: LIST
46366: LIST
46367: PUSH
46368: LD_INT 2
46370: NEG
46371: PUSH
46372: LD_INT 3
46374: NEG
46375: PUSH
46376: EMPTY
46377: LIST
46378: LIST
46379: PUSH
46380: LD_INT 3
46382: NEG
46383: PUSH
46384: LD_INT 2
46386: NEG
46387: PUSH
46388: EMPTY
46389: LIST
46390: LIST
46391: PUSH
46392: EMPTY
46393: LIST
46394: LIST
46395: LIST
46396: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
46397: LD_ADDR_VAR 0 47
46401: PUSH
46402: LD_INT 2
46404: NEG
46405: PUSH
46406: LD_INT 3
46408: NEG
46409: PUSH
46410: EMPTY
46411: LIST
46412: LIST
46413: PUSH
46414: LD_INT 1
46416: NEG
46417: PUSH
46418: LD_INT 3
46420: NEG
46421: PUSH
46422: EMPTY
46423: LIST
46424: LIST
46425: PUSH
46426: EMPTY
46427: LIST
46428: LIST
46429: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
46430: LD_ADDR_VAR 0 48
46434: PUSH
46435: LD_INT 1
46437: PUSH
46438: LD_INT 2
46440: NEG
46441: PUSH
46442: EMPTY
46443: LIST
46444: LIST
46445: PUSH
46446: LD_INT 2
46448: PUSH
46449: LD_INT 1
46451: NEG
46452: PUSH
46453: EMPTY
46454: LIST
46455: LIST
46456: PUSH
46457: EMPTY
46458: LIST
46459: LIST
46460: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
46461: LD_ADDR_VAR 0 49
46465: PUSH
46466: LD_INT 3
46468: PUSH
46469: LD_INT 1
46471: PUSH
46472: EMPTY
46473: LIST
46474: LIST
46475: PUSH
46476: LD_INT 3
46478: PUSH
46479: LD_INT 2
46481: PUSH
46482: EMPTY
46483: LIST
46484: LIST
46485: PUSH
46486: EMPTY
46487: LIST
46488: LIST
46489: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
46490: LD_ADDR_VAR 0 50
46494: PUSH
46495: LD_INT 2
46497: PUSH
46498: LD_INT 3
46500: PUSH
46501: EMPTY
46502: LIST
46503: LIST
46504: PUSH
46505: LD_INT 1
46507: PUSH
46508: LD_INT 3
46510: PUSH
46511: EMPTY
46512: LIST
46513: LIST
46514: PUSH
46515: EMPTY
46516: LIST
46517: LIST
46518: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
46519: LD_ADDR_VAR 0 51
46523: PUSH
46524: LD_INT 1
46526: NEG
46527: PUSH
46528: LD_INT 2
46530: PUSH
46531: EMPTY
46532: LIST
46533: LIST
46534: PUSH
46535: LD_INT 2
46537: NEG
46538: PUSH
46539: LD_INT 1
46541: PUSH
46542: EMPTY
46543: LIST
46544: LIST
46545: PUSH
46546: EMPTY
46547: LIST
46548: LIST
46549: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
46550: LD_ADDR_VAR 0 52
46554: PUSH
46555: LD_INT 3
46557: NEG
46558: PUSH
46559: LD_INT 1
46561: NEG
46562: PUSH
46563: EMPTY
46564: LIST
46565: LIST
46566: PUSH
46567: LD_INT 3
46569: NEG
46570: PUSH
46571: LD_INT 2
46573: NEG
46574: PUSH
46575: EMPTY
46576: LIST
46577: LIST
46578: PUSH
46579: EMPTY
46580: LIST
46581: LIST
46582: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
46583: LD_ADDR_VAR 0 53
46587: PUSH
46588: LD_INT 1
46590: NEG
46591: PUSH
46592: LD_INT 3
46594: NEG
46595: PUSH
46596: EMPTY
46597: LIST
46598: LIST
46599: PUSH
46600: LD_INT 0
46602: PUSH
46603: LD_INT 3
46605: NEG
46606: PUSH
46607: EMPTY
46608: LIST
46609: LIST
46610: PUSH
46611: LD_INT 1
46613: PUSH
46614: LD_INT 2
46616: NEG
46617: PUSH
46618: EMPTY
46619: LIST
46620: LIST
46621: PUSH
46622: EMPTY
46623: LIST
46624: LIST
46625: LIST
46626: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
46627: LD_ADDR_VAR 0 54
46631: PUSH
46632: LD_INT 2
46634: PUSH
46635: LD_INT 1
46637: NEG
46638: PUSH
46639: EMPTY
46640: LIST
46641: LIST
46642: PUSH
46643: LD_INT 3
46645: PUSH
46646: LD_INT 0
46648: PUSH
46649: EMPTY
46650: LIST
46651: LIST
46652: PUSH
46653: LD_INT 3
46655: PUSH
46656: LD_INT 1
46658: PUSH
46659: EMPTY
46660: LIST
46661: LIST
46662: PUSH
46663: EMPTY
46664: LIST
46665: LIST
46666: LIST
46667: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
46668: LD_ADDR_VAR 0 55
46672: PUSH
46673: LD_INT 3
46675: PUSH
46676: LD_INT 2
46678: PUSH
46679: EMPTY
46680: LIST
46681: LIST
46682: PUSH
46683: LD_INT 3
46685: PUSH
46686: LD_INT 3
46688: PUSH
46689: EMPTY
46690: LIST
46691: LIST
46692: PUSH
46693: LD_INT 2
46695: PUSH
46696: LD_INT 3
46698: PUSH
46699: EMPTY
46700: LIST
46701: LIST
46702: PUSH
46703: EMPTY
46704: LIST
46705: LIST
46706: LIST
46707: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
46708: LD_ADDR_VAR 0 56
46712: PUSH
46713: LD_INT 1
46715: PUSH
46716: LD_INT 3
46718: PUSH
46719: EMPTY
46720: LIST
46721: LIST
46722: PUSH
46723: LD_INT 0
46725: PUSH
46726: LD_INT 3
46728: PUSH
46729: EMPTY
46730: LIST
46731: LIST
46732: PUSH
46733: LD_INT 1
46735: NEG
46736: PUSH
46737: LD_INT 2
46739: PUSH
46740: EMPTY
46741: LIST
46742: LIST
46743: PUSH
46744: EMPTY
46745: LIST
46746: LIST
46747: LIST
46748: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
46749: LD_ADDR_VAR 0 57
46753: PUSH
46754: LD_INT 2
46756: NEG
46757: PUSH
46758: LD_INT 1
46760: PUSH
46761: EMPTY
46762: LIST
46763: LIST
46764: PUSH
46765: LD_INT 3
46767: NEG
46768: PUSH
46769: LD_INT 0
46771: PUSH
46772: EMPTY
46773: LIST
46774: LIST
46775: PUSH
46776: LD_INT 3
46778: NEG
46779: PUSH
46780: LD_INT 1
46782: NEG
46783: PUSH
46784: EMPTY
46785: LIST
46786: LIST
46787: PUSH
46788: EMPTY
46789: LIST
46790: LIST
46791: LIST
46792: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
46793: LD_ADDR_VAR 0 58
46797: PUSH
46798: LD_INT 2
46800: NEG
46801: PUSH
46802: LD_INT 3
46804: NEG
46805: PUSH
46806: EMPTY
46807: LIST
46808: LIST
46809: PUSH
46810: LD_INT 3
46812: NEG
46813: PUSH
46814: LD_INT 2
46816: NEG
46817: PUSH
46818: EMPTY
46819: LIST
46820: LIST
46821: PUSH
46822: LD_INT 3
46824: NEG
46825: PUSH
46826: LD_INT 3
46828: NEG
46829: PUSH
46830: EMPTY
46831: LIST
46832: LIST
46833: PUSH
46834: EMPTY
46835: LIST
46836: LIST
46837: LIST
46838: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
46839: LD_ADDR_VAR 0 59
46843: PUSH
46844: LD_INT 1
46846: NEG
46847: PUSH
46848: LD_INT 2
46850: NEG
46851: PUSH
46852: EMPTY
46853: LIST
46854: LIST
46855: PUSH
46856: LD_INT 0
46858: PUSH
46859: LD_INT 2
46861: NEG
46862: PUSH
46863: EMPTY
46864: LIST
46865: LIST
46866: PUSH
46867: LD_INT 1
46869: PUSH
46870: LD_INT 1
46872: NEG
46873: PUSH
46874: EMPTY
46875: LIST
46876: LIST
46877: PUSH
46878: EMPTY
46879: LIST
46880: LIST
46881: LIST
46882: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
46883: LD_ADDR_VAR 0 60
46887: PUSH
46888: LD_INT 1
46890: PUSH
46891: LD_INT 1
46893: NEG
46894: PUSH
46895: EMPTY
46896: LIST
46897: LIST
46898: PUSH
46899: LD_INT 2
46901: PUSH
46902: LD_INT 0
46904: PUSH
46905: EMPTY
46906: LIST
46907: LIST
46908: PUSH
46909: LD_INT 2
46911: PUSH
46912: LD_INT 1
46914: PUSH
46915: EMPTY
46916: LIST
46917: LIST
46918: PUSH
46919: EMPTY
46920: LIST
46921: LIST
46922: LIST
46923: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
46924: LD_ADDR_VAR 0 61
46928: PUSH
46929: LD_INT 2
46931: PUSH
46932: LD_INT 1
46934: PUSH
46935: EMPTY
46936: LIST
46937: LIST
46938: PUSH
46939: LD_INT 2
46941: PUSH
46942: LD_INT 2
46944: PUSH
46945: EMPTY
46946: LIST
46947: LIST
46948: PUSH
46949: LD_INT 1
46951: PUSH
46952: LD_INT 2
46954: PUSH
46955: EMPTY
46956: LIST
46957: LIST
46958: PUSH
46959: EMPTY
46960: LIST
46961: LIST
46962: LIST
46963: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
46964: LD_ADDR_VAR 0 62
46968: PUSH
46969: LD_INT 1
46971: PUSH
46972: LD_INT 2
46974: PUSH
46975: EMPTY
46976: LIST
46977: LIST
46978: PUSH
46979: LD_INT 0
46981: PUSH
46982: LD_INT 2
46984: PUSH
46985: EMPTY
46986: LIST
46987: LIST
46988: PUSH
46989: LD_INT 1
46991: NEG
46992: PUSH
46993: LD_INT 1
46995: PUSH
46996: EMPTY
46997: LIST
46998: LIST
46999: PUSH
47000: EMPTY
47001: LIST
47002: LIST
47003: LIST
47004: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
47005: LD_ADDR_VAR 0 63
47009: PUSH
47010: LD_INT 1
47012: NEG
47013: PUSH
47014: LD_INT 1
47016: PUSH
47017: EMPTY
47018: LIST
47019: LIST
47020: PUSH
47021: LD_INT 2
47023: NEG
47024: PUSH
47025: LD_INT 0
47027: PUSH
47028: EMPTY
47029: LIST
47030: LIST
47031: PUSH
47032: LD_INT 2
47034: NEG
47035: PUSH
47036: LD_INT 1
47038: NEG
47039: PUSH
47040: EMPTY
47041: LIST
47042: LIST
47043: PUSH
47044: EMPTY
47045: LIST
47046: LIST
47047: LIST
47048: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
47049: LD_ADDR_VAR 0 64
47053: PUSH
47054: LD_INT 1
47056: NEG
47057: PUSH
47058: LD_INT 2
47060: NEG
47061: PUSH
47062: EMPTY
47063: LIST
47064: LIST
47065: PUSH
47066: LD_INT 2
47068: NEG
47069: PUSH
47070: LD_INT 1
47072: NEG
47073: PUSH
47074: EMPTY
47075: LIST
47076: LIST
47077: PUSH
47078: LD_INT 2
47080: NEG
47081: PUSH
47082: LD_INT 2
47084: NEG
47085: PUSH
47086: EMPTY
47087: LIST
47088: LIST
47089: PUSH
47090: EMPTY
47091: LIST
47092: LIST
47093: LIST
47094: ST_TO_ADDR
// end ; 2 :
47095: GO 50361
47097: LD_INT 2
47099: DOUBLE
47100: EQUAL
47101: IFTRUE 47105
47103: GO 50360
47105: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
47106: LD_ADDR_VAR 0 29
47110: PUSH
47111: LD_INT 4
47113: PUSH
47114: LD_INT 0
47116: PUSH
47117: EMPTY
47118: LIST
47119: LIST
47120: PUSH
47121: LD_INT 4
47123: PUSH
47124: LD_INT 1
47126: NEG
47127: PUSH
47128: EMPTY
47129: LIST
47130: LIST
47131: PUSH
47132: LD_INT 5
47134: PUSH
47135: LD_INT 0
47137: PUSH
47138: EMPTY
47139: LIST
47140: LIST
47141: PUSH
47142: LD_INT 5
47144: PUSH
47145: LD_INT 1
47147: PUSH
47148: EMPTY
47149: LIST
47150: LIST
47151: PUSH
47152: LD_INT 4
47154: PUSH
47155: LD_INT 1
47157: PUSH
47158: EMPTY
47159: LIST
47160: LIST
47161: PUSH
47162: LD_INT 3
47164: PUSH
47165: LD_INT 0
47167: PUSH
47168: EMPTY
47169: LIST
47170: LIST
47171: PUSH
47172: LD_INT 3
47174: PUSH
47175: LD_INT 1
47177: NEG
47178: PUSH
47179: EMPTY
47180: LIST
47181: LIST
47182: PUSH
47183: LD_INT 3
47185: PUSH
47186: LD_INT 2
47188: NEG
47189: PUSH
47190: EMPTY
47191: LIST
47192: LIST
47193: PUSH
47194: LD_INT 5
47196: PUSH
47197: LD_INT 2
47199: PUSH
47200: EMPTY
47201: LIST
47202: LIST
47203: PUSH
47204: LD_INT 3
47206: PUSH
47207: LD_INT 3
47209: PUSH
47210: EMPTY
47211: LIST
47212: LIST
47213: PUSH
47214: LD_INT 3
47216: PUSH
47217: LD_INT 2
47219: PUSH
47220: EMPTY
47221: LIST
47222: LIST
47223: PUSH
47224: LD_INT 4
47226: PUSH
47227: LD_INT 3
47229: PUSH
47230: EMPTY
47231: LIST
47232: LIST
47233: PUSH
47234: LD_INT 4
47236: PUSH
47237: LD_INT 4
47239: PUSH
47240: EMPTY
47241: LIST
47242: LIST
47243: PUSH
47244: LD_INT 3
47246: PUSH
47247: LD_INT 4
47249: PUSH
47250: EMPTY
47251: LIST
47252: LIST
47253: PUSH
47254: LD_INT 2
47256: PUSH
47257: LD_INT 3
47259: PUSH
47260: EMPTY
47261: LIST
47262: LIST
47263: PUSH
47264: LD_INT 2
47266: PUSH
47267: LD_INT 2
47269: PUSH
47270: EMPTY
47271: LIST
47272: LIST
47273: PUSH
47274: LD_INT 4
47276: PUSH
47277: LD_INT 2
47279: PUSH
47280: EMPTY
47281: LIST
47282: LIST
47283: PUSH
47284: LD_INT 2
47286: PUSH
47287: LD_INT 4
47289: PUSH
47290: EMPTY
47291: LIST
47292: LIST
47293: PUSH
47294: LD_INT 0
47296: PUSH
47297: LD_INT 4
47299: PUSH
47300: EMPTY
47301: LIST
47302: LIST
47303: PUSH
47304: LD_INT 0
47306: PUSH
47307: LD_INT 3
47309: PUSH
47310: EMPTY
47311: LIST
47312: LIST
47313: PUSH
47314: LD_INT 1
47316: PUSH
47317: LD_INT 4
47319: PUSH
47320: EMPTY
47321: LIST
47322: LIST
47323: PUSH
47324: LD_INT 1
47326: PUSH
47327: LD_INT 5
47329: PUSH
47330: EMPTY
47331: LIST
47332: LIST
47333: PUSH
47334: LD_INT 0
47336: PUSH
47337: LD_INT 5
47339: PUSH
47340: EMPTY
47341: LIST
47342: LIST
47343: PUSH
47344: LD_INT 1
47346: NEG
47347: PUSH
47348: LD_INT 4
47350: PUSH
47351: EMPTY
47352: LIST
47353: LIST
47354: PUSH
47355: LD_INT 1
47357: NEG
47358: PUSH
47359: LD_INT 3
47361: PUSH
47362: EMPTY
47363: LIST
47364: LIST
47365: PUSH
47366: LD_INT 2
47368: PUSH
47369: LD_INT 5
47371: PUSH
47372: EMPTY
47373: LIST
47374: LIST
47375: PUSH
47376: LD_INT 2
47378: NEG
47379: PUSH
47380: LD_INT 3
47382: PUSH
47383: EMPTY
47384: LIST
47385: LIST
47386: PUSH
47387: LD_INT 3
47389: NEG
47390: PUSH
47391: LD_INT 0
47393: PUSH
47394: EMPTY
47395: LIST
47396: LIST
47397: PUSH
47398: LD_INT 3
47400: NEG
47401: PUSH
47402: LD_INT 1
47404: NEG
47405: PUSH
47406: EMPTY
47407: LIST
47408: LIST
47409: PUSH
47410: LD_INT 2
47412: NEG
47413: PUSH
47414: LD_INT 0
47416: PUSH
47417: EMPTY
47418: LIST
47419: LIST
47420: PUSH
47421: LD_INT 2
47423: NEG
47424: PUSH
47425: LD_INT 1
47427: PUSH
47428: EMPTY
47429: LIST
47430: LIST
47431: PUSH
47432: LD_INT 3
47434: NEG
47435: PUSH
47436: LD_INT 1
47438: PUSH
47439: EMPTY
47440: LIST
47441: LIST
47442: PUSH
47443: LD_INT 4
47445: NEG
47446: PUSH
47447: LD_INT 0
47449: PUSH
47450: EMPTY
47451: LIST
47452: LIST
47453: PUSH
47454: LD_INT 4
47456: NEG
47457: PUSH
47458: LD_INT 1
47460: NEG
47461: PUSH
47462: EMPTY
47463: LIST
47464: LIST
47465: PUSH
47466: LD_INT 4
47468: NEG
47469: PUSH
47470: LD_INT 2
47472: NEG
47473: PUSH
47474: EMPTY
47475: LIST
47476: LIST
47477: PUSH
47478: LD_INT 2
47480: NEG
47481: PUSH
47482: LD_INT 2
47484: PUSH
47485: EMPTY
47486: LIST
47487: LIST
47488: PUSH
47489: LD_INT 4
47491: NEG
47492: PUSH
47493: LD_INT 4
47495: NEG
47496: PUSH
47497: EMPTY
47498: LIST
47499: LIST
47500: PUSH
47501: LD_INT 4
47503: NEG
47504: PUSH
47505: LD_INT 5
47507: NEG
47508: PUSH
47509: EMPTY
47510: LIST
47511: LIST
47512: PUSH
47513: LD_INT 3
47515: NEG
47516: PUSH
47517: LD_INT 4
47519: NEG
47520: PUSH
47521: EMPTY
47522: LIST
47523: LIST
47524: PUSH
47525: LD_INT 3
47527: NEG
47528: PUSH
47529: LD_INT 3
47531: NEG
47532: PUSH
47533: EMPTY
47534: LIST
47535: LIST
47536: PUSH
47537: LD_INT 4
47539: NEG
47540: PUSH
47541: LD_INT 3
47543: NEG
47544: PUSH
47545: EMPTY
47546: LIST
47547: LIST
47548: PUSH
47549: LD_INT 5
47551: NEG
47552: PUSH
47553: LD_INT 4
47555: NEG
47556: PUSH
47557: EMPTY
47558: LIST
47559: LIST
47560: PUSH
47561: LD_INT 5
47563: NEG
47564: PUSH
47565: LD_INT 5
47567: NEG
47568: PUSH
47569: EMPTY
47570: LIST
47571: LIST
47572: PUSH
47573: LD_INT 3
47575: NEG
47576: PUSH
47577: LD_INT 5
47579: NEG
47580: PUSH
47581: EMPTY
47582: LIST
47583: LIST
47584: PUSH
47585: LD_INT 5
47587: NEG
47588: PUSH
47589: LD_INT 3
47591: NEG
47592: PUSH
47593: EMPTY
47594: LIST
47595: LIST
47596: PUSH
47597: EMPTY
47598: LIST
47599: LIST
47600: LIST
47601: LIST
47602: LIST
47603: LIST
47604: LIST
47605: LIST
47606: LIST
47607: LIST
47608: LIST
47609: LIST
47610: LIST
47611: LIST
47612: LIST
47613: LIST
47614: LIST
47615: LIST
47616: LIST
47617: LIST
47618: LIST
47619: LIST
47620: LIST
47621: LIST
47622: LIST
47623: LIST
47624: LIST
47625: LIST
47626: LIST
47627: LIST
47628: LIST
47629: LIST
47630: LIST
47631: LIST
47632: LIST
47633: LIST
47634: LIST
47635: LIST
47636: LIST
47637: LIST
47638: LIST
47639: LIST
47640: LIST
47641: LIST
47642: LIST
47643: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
47644: LD_ADDR_VAR 0 30
47648: PUSH
47649: LD_INT 4
47651: PUSH
47652: LD_INT 4
47654: PUSH
47655: EMPTY
47656: LIST
47657: LIST
47658: PUSH
47659: LD_INT 4
47661: PUSH
47662: LD_INT 3
47664: PUSH
47665: EMPTY
47666: LIST
47667: LIST
47668: PUSH
47669: LD_INT 5
47671: PUSH
47672: LD_INT 4
47674: PUSH
47675: EMPTY
47676: LIST
47677: LIST
47678: PUSH
47679: LD_INT 5
47681: PUSH
47682: LD_INT 5
47684: PUSH
47685: EMPTY
47686: LIST
47687: LIST
47688: PUSH
47689: LD_INT 4
47691: PUSH
47692: LD_INT 5
47694: PUSH
47695: EMPTY
47696: LIST
47697: LIST
47698: PUSH
47699: LD_INT 3
47701: PUSH
47702: LD_INT 4
47704: PUSH
47705: EMPTY
47706: LIST
47707: LIST
47708: PUSH
47709: LD_INT 3
47711: PUSH
47712: LD_INT 3
47714: PUSH
47715: EMPTY
47716: LIST
47717: LIST
47718: PUSH
47719: LD_INT 5
47721: PUSH
47722: LD_INT 3
47724: PUSH
47725: EMPTY
47726: LIST
47727: LIST
47728: PUSH
47729: LD_INT 3
47731: PUSH
47732: LD_INT 5
47734: PUSH
47735: EMPTY
47736: LIST
47737: LIST
47738: PUSH
47739: LD_INT 0
47741: PUSH
47742: LD_INT 3
47744: PUSH
47745: EMPTY
47746: LIST
47747: LIST
47748: PUSH
47749: LD_INT 0
47751: PUSH
47752: LD_INT 2
47754: PUSH
47755: EMPTY
47756: LIST
47757: LIST
47758: PUSH
47759: LD_INT 1
47761: PUSH
47762: LD_INT 3
47764: PUSH
47765: EMPTY
47766: LIST
47767: LIST
47768: PUSH
47769: LD_INT 1
47771: PUSH
47772: LD_INT 4
47774: PUSH
47775: EMPTY
47776: LIST
47777: LIST
47778: PUSH
47779: LD_INT 0
47781: PUSH
47782: LD_INT 4
47784: PUSH
47785: EMPTY
47786: LIST
47787: LIST
47788: PUSH
47789: LD_INT 1
47791: NEG
47792: PUSH
47793: LD_INT 3
47795: PUSH
47796: EMPTY
47797: LIST
47798: LIST
47799: PUSH
47800: LD_INT 1
47802: NEG
47803: PUSH
47804: LD_INT 2
47806: PUSH
47807: EMPTY
47808: LIST
47809: LIST
47810: PUSH
47811: LD_INT 2
47813: PUSH
47814: LD_INT 4
47816: PUSH
47817: EMPTY
47818: LIST
47819: LIST
47820: PUSH
47821: LD_INT 2
47823: NEG
47824: PUSH
47825: LD_INT 2
47827: PUSH
47828: EMPTY
47829: LIST
47830: LIST
47831: PUSH
47832: LD_INT 4
47834: NEG
47835: PUSH
47836: LD_INT 0
47838: PUSH
47839: EMPTY
47840: LIST
47841: LIST
47842: PUSH
47843: LD_INT 4
47845: NEG
47846: PUSH
47847: LD_INT 1
47849: NEG
47850: PUSH
47851: EMPTY
47852: LIST
47853: LIST
47854: PUSH
47855: LD_INT 3
47857: NEG
47858: PUSH
47859: LD_INT 0
47861: PUSH
47862: EMPTY
47863: LIST
47864: LIST
47865: PUSH
47866: LD_INT 3
47868: NEG
47869: PUSH
47870: LD_INT 1
47872: PUSH
47873: EMPTY
47874: LIST
47875: LIST
47876: PUSH
47877: LD_INT 4
47879: NEG
47880: PUSH
47881: LD_INT 1
47883: PUSH
47884: EMPTY
47885: LIST
47886: LIST
47887: PUSH
47888: LD_INT 5
47890: NEG
47891: PUSH
47892: LD_INT 0
47894: PUSH
47895: EMPTY
47896: LIST
47897: LIST
47898: PUSH
47899: LD_INT 5
47901: NEG
47902: PUSH
47903: LD_INT 1
47905: NEG
47906: PUSH
47907: EMPTY
47908: LIST
47909: LIST
47910: PUSH
47911: LD_INT 5
47913: NEG
47914: PUSH
47915: LD_INT 2
47917: NEG
47918: PUSH
47919: EMPTY
47920: LIST
47921: LIST
47922: PUSH
47923: LD_INT 3
47925: NEG
47926: PUSH
47927: LD_INT 2
47929: PUSH
47930: EMPTY
47931: LIST
47932: LIST
47933: PUSH
47934: LD_INT 3
47936: NEG
47937: PUSH
47938: LD_INT 3
47940: NEG
47941: PUSH
47942: EMPTY
47943: LIST
47944: LIST
47945: PUSH
47946: LD_INT 3
47948: NEG
47949: PUSH
47950: LD_INT 4
47952: NEG
47953: PUSH
47954: EMPTY
47955: LIST
47956: LIST
47957: PUSH
47958: LD_INT 2
47960: NEG
47961: PUSH
47962: LD_INT 3
47964: NEG
47965: PUSH
47966: EMPTY
47967: LIST
47968: LIST
47969: PUSH
47970: LD_INT 2
47972: NEG
47973: PUSH
47974: LD_INT 2
47976: NEG
47977: PUSH
47978: EMPTY
47979: LIST
47980: LIST
47981: PUSH
47982: LD_INT 3
47984: NEG
47985: PUSH
47986: LD_INT 2
47988: NEG
47989: PUSH
47990: EMPTY
47991: LIST
47992: LIST
47993: PUSH
47994: LD_INT 4
47996: NEG
47997: PUSH
47998: LD_INT 3
48000: NEG
48001: PUSH
48002: EMPTY
48003: LIST
48004: LIST
48005: PUSH
48006: LD_INT 4
48008: NEG
48009: PUSH
48010: LD_INT 4
48012: NEG
48013: PUSH
48014: EMPTY
48015: LIST
48016: LIST
48017: PUSH
48018: LD_INT 2
48020: NEG
48021: PUSH
48022: LD_INT 4
48024: NEG
48025: PUSH
48026: EMPTY
48027: LIST
48028: LIST
48029: PUSH
48030: LD_INT 4
48032: NEG
48033: PUSH
48034: LD_INT 2
48036: NEG
48037: PUSH
48038: EMPTY
48039: LIST
48040: LIST
48041: PUSH
48042: LD_INT 0
48044: PUSH
48045: LD_INT 4
48047: NEG
48048: PUSH
48049: EMPTY
48050: LIST
48051: LIST
48052: PUSH
48053: LD_INT 0
48055: PUSH
48056: LD_INT 5
48058: NEG
48059: PUSH
48060: EMPTY
48061: LIST
48062: LIST
48063: PUSH
48064: LD_INT 1
48066: PUSH
48067: LD_INT 4
48069: NEG
48070: PUSH
48071: EMPTY
48072: LIST
48073: LIST
48074: PUSH
48075: LD_INT 1
48077: PUSH
48078: LD_INT 3
48080: NEG
48081: PUSH
48082: EMPTY
48083: LIST
48084: LIST
48085: PUSH
48086: LD_INT 0
48088: PUSH
48089: LD_INT 3
48091: NEG
48092: PUSH
48093: EMPTY
48094: LIST
48095: LIST
48096: PUSH
48097: LD_INT 1
48099: NEG
48100: PUSH
48101: LD_INT 4
48103: NEG
48104: PUSH
48105: EMPTY
48106: LIST
48107: LIST
48108: PUSH
48109: LD_INT 1
48111: NEG
48112: PUSH
48113: LD_INT 5
48115: NEG
48116: PUSH
48117: EMPTY
48118: LIST
48119: LIST
48120: PUSH
48121: LD_INT 2
48123: PUSH
48124: LD_INT 3
48126: NEG
48127: PUSH
48128: EMPTY
48129: LIST
48130: LIST
48131: PUSH
48132: LD_INT 2
48134: NEG
48135: PUSH
48136: LD_INT 5
48138: NEG
48139: PUSH
48140: EMPTY
48141: LIST
48142: LIST
48143: PUSH
48144: EMPTY
48145: LIST
48146: LIST
48147: LIST
48148: LIST
48149: LIST
48150: LIST
48151: LIST
48152: LIST
48153: LIST
48154: LIST
48155: LIST
48156: LIST
48157: LIST
48158: LIST
48159: LIST
48160: LIST
48161: LIST
48162: LIST
48163: LIST
48164: LIST
48165: LIST
48166: LIST
48167: LIST
48168: LIST
48169: LIST
48170: LIST
48171: LIST
48172: LIST
48173: LIST
48174: LIST
48175: LIST
48176: LIST
48177: LIST
48178: LIST
48179: LIST
48180: LIST
48181: LIST
48182: LIST
48183: LIST
48184: LIST
48185: LIST
48186: LIST
48187: LIST
48188: LIST
48189: LIST
48190: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
48191: LD_ADDR_VAR 0 31
48195: PUSH
48196: LD_INT 0
48198: PUSH
48199: LD_INT 4
48201: PUSH
48202: EMPTY
48203: LIST
48204: LIST
48205: PUSH
48206: LD_INT 0
48208: PUSH
48209: LD_INT 3
48211: PUSH
48212: EMPTY
48213: LIST
48214: LIST
48215: PUSH
48216: LD_INT 1
48218: PUSH
48219: LD_INT 4
48221: PUSH
48222: EMPTY
48223: LIST
48224: LIST
48225: PUSH
48226: LD_INT 1
48228: PUSH
48229: LD_INT 5
48231: PUSH
48232: EMPTY
48233: LIST
48234: LIST
48235: PUSH
48236: LD_INT 0
48238: PUSH
48239: LD_INT 5
48241: PUSH
48242: EMPTY
48243: LIST
48244: LIST
48245: PUSH
48246: LD_INT 1
48248: NEG
48249: PUSH
48250: LD_INT 4
48252: PUSH
48253: EMPTY
48254: LIST
48255: LIST
48256: PUSH
48257: LD_INT 1
48259: NEG
48260: PUSH
48261: LD_INT 3
48263: PUSH
48264: EMPTY
48265: LIST
48266: LIST
48267: PUSH
48268: LD_INT 2
48270: PUSH
48271: LD_INT 5
48273: PUSH
48274: EMPTY
48275: LIST
48276: LIST
48277: PUSH
48278: LD_INT 2
48280: NEG
48281: PUSH
48282: LD_INT 3
48284: PUSH
48285: EMPTY
48286: LIST
48287: LIST
48288: PUSH
48289: LD_INT 3
48291: NEG
48292: PUSH
48293: LD_INT 0
48295: PUSH
48296: EMPTY
48297: LIST
48298: LIST
48299: PUSH
48300: LD_INT 3
48302: NEG
48303: PUSH
48304: LD_INT 1
48306: NEG
48307: PUSH
48308: EMPTY
48309: LIST
48310: LIST
48311: PUSH
48312: LD_INT 2
48314: NEG
48315: PUSH
48316: LD_INT 0
48318: PUSH
48319: EMPTY
48320: LIST
48321: LIST
48322: PUSH
48323: LD_INT 2
48325: NEG
48326: PUSH
48327: LD_INT 1
48329: PUSH
48330: EMPTY
48331: LIST
48332: LIST
48333: PUSH
48334: LD_INT 3
48336: NEG
48337: PUSH
48338: LD_INT 1
48340: PUSH
48341: EMPTY
48342: LIST
48343: LIST
48344: PUSH
48345: LD_INT 4
48347: NEG
48348: PUSH
48349: LD_INT 0
48351: PUSH
48352: EMPTY
48353: LIST
48354: LIST
48355: PUSH
48356: LD_INT 4
48358: NEG
48359: PUSH
48360: LD_INT 1
48362: NEG
48363: PUSH
48364: EMPTY
48365: LIST
48366: LIST
48367: PUSH
48368: LD_INT 4
48370: NEG
48371: PUSH
48372: LD_INT 2
48374: NEG
48375: PUSH
48376: EMPTY
48377: LIST
48378: LIST
48379: PUSH
48380: LD_INT 2
48382: NEG
48383: PUSH
48384: LD_INT 2
48386: PUSH
48387: EMPTY
48388: LIST
48389: LIST
48390: PUSH
48391: LD_INT 4
48393: NEG
48394: PUSH
48395: LD_INT 4
48397: NEG
48398: PUSH
48399: EMPTY
48400: LIST
48401: LIST
48402: PUSH
48403: LD_INT 4
48405: NEG
48406: PUSH
48407: LD_INT 5
48409: NEG
48410: PUSH
48411: EMPTY
48412: LIST
48413: LIST
48414: PUSH
48415: LD_INT 3
48417: NEG
48418: PUSH
48419: LD_INT 4
48421: NEG
48422: PUSH
48423: EMPTY
48424: LIST
48425: LIST
48426: PUSH
48427: LD_INT 3
48429: NEG
48430: PUSH
48431: LD_INT 3
48433: NEG
48434: PUSH
48435: EMPTY
48436: LIST
48437: LIST
48438: PUSH
48439: LD_INT 4
48441: NEG
48442: PUSH
48443: LD_INT 3
48445: NEG
48446: PUSH
48447: EMPTY
48448: LIST
48449: LIST
48450: PUSH
48451: LD_INT 5
48453: NEG
48454: PUSH
48455: LD_INT 4
48457: NEG
48458: PUSH
48459: EMPTY
48460: LIST
48461: LIST
48462: PUSH
48463: LD_INT 5
48465: NEG
48466: PUSH
48467: LD_INT 5
48469: NEG
48470: PUSH
48471: EMPTY
48472: LIST
48473: LIST
48474: PUSH
48475: LD_INT 3
48477: NEG
48478: PUSH
48479: LD_INT 5
48481: NEG
48482: PUSH
48483: EMPTY
48484: LIST
48485: LIST
48486: PUSH
48487: LD_INT 5
48489: NEG
48490: PUSH
48491: LD_INT 3
48493: NEG
48494: PUSH
48495: EMPTY
48496: LIST
48497: LIST
48498: PUSH
48499: LD_INT 0
48501: PUSH
48502: LD_INT 3
48504: NEG
48505: PUSH
48506: EMPTY
48507: LIST
48508: LIST
48509: PUSH
48510: LD_INT 0
48512: PUSH
48513: LD_INT 4
48515: NEG
48516: PUSH
48517: EMPTY
48518: LIST
48519: LIST
48520: PUSH
48521: LD_INT 1
48523: PUSH
48524: LD_INT 3
48526: NEG
48527: PUSH
48528: EMPTY
48529: LIST
48530: LIST
48531: PUSH
48532: LD_INT 1
48534: PUSH
48535: LD_INT 2
48537: NEG
48538: PUSH
48539: EMPTY
48540: LIST
48541: LIST
48542: PUSH
48543: LD_INT 0
48545: PUSH
48546: LD_INT 2
48548: NEG
48549: PUSH
48550: EMPTY
48551: LIST
48552: LIST
48553: PUSH
48554: LD_INT 1
48556: NEG
48557: PUSH
48558: LD_INT 3
48560: NEG
48561: PUSH
48562: EMPTY
48563: LIST
48564: LIST
48565: PUSH
48566: LD_INT 1
48568: NEG
48569: PUSH
48570: LD_INT 4
48572: NEG
48573: PUSH
48574: EMPTY
48575: LIST
48576: LIST
48577: PUSH
48578: LD_INT 2
48580: PUSH
48581: LD_INT 2
48583: NEG
48584: PUSH
48585: EMPTY
48586: LIST
48587: LIST
48588: PUSH
48589: LD_INT 2
48591: NEG
48592: PUSH
48593: LD_INT 4
48595: NEG
48596: PUSH
48597: EMPTY
48598: LIST
48599: LIST
48600: PUSH
48601: LD_INT 4
48603: PUSH
48604: LD_INT 0
48606: PUSH
48607: EMPTY
48608: LIST
48609: LIST
48610: PUSH
48611: LD_INT 4
48613: PUSH
48614: LD_INT 1
48616: NEG
48617: PUSH
48618: EMPTY
48619: LIST
48620: LIST
48621: PUSH
48622: LD_INT 5
48624: PUSH
48625: LD_INT 0
48627: PUSH
48628: EMPTY
48629: LIST
48630: LIST
48631: PUSH
48632: LD_INT 5
48634: PUSH
48635: LD_INT 1
48637: PUSH
48638: EMPTY
48639: LIST
48640: LIST
48641: PUSH
48642: LD_INT 4
48644: PUSH
48645: LD_INT 1
48647: PUSH
48648: EMPTY
48649: LIST
48650: LIST
48651: PUSH
48652: LD_INT 3
48654: PUSH
48655: LD_INT 0
48657: PUSH
48658: EMPTY
48659: LIST
48660: LIST
48661: PUSH
48662: LD_INT 3
48664: PUSH
48665: LD_INT 1
48667: NEG
48668: PUSH
48669: EMPTY
48670: LIST
48671: LIST
48672: PUSH
48673: LD_INT 3
48675: PUSH
48676: LD_INT 2
48678: NEG
48679: PUSH
48680: EMPTY
48681: LIST
48682: LIST
48683: PUSH
48684: LD_INT 5
48686: PUSH
48687: LD_INT 2
48689: PUSH
48690: EMPTY
48691: LIST
48692: LIST
48693: PUSH
48694: EMPTY
48695: LIST
48696: LIST
48697: LIST
48698: LIST
48699: LIST
48700: LIST
48701: LIST
48702: LIST
48703: LIST
48704: LIST
48705: LIST
48706: LIST
48707: LIST
48708: LIST
48709: LIST
48710: LIST
48711: LIST
48712: LIST
48713: LIST
48714: LIST
48715: LIST
48716: LIST
48717: LIST
48718: LIST
48719: LIST
48720: LIST
48721: LIST
48722: LIST
48723: LIST
48724: LIST
48725: LIST
48726: LIST
48727: LIST
48728: LIST
48729: LIST
48730: LIST
48731: LIST
48732: LIST
48733: LIST
48734: LIST
48735: LIST
48736: LIST
48737: LIST
48738: LIST
48739: LIST
48740: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
48741: LD_ADDR_VAR 0 32
48745: PUSH
48746: LD_INT 4
48748: NEG
48749: PUSH
48750: LD_INT 0
48752: PUSH
48753: EMPTY
48754: LIST
48755: LIST
48756: PUSH
48757: LD_INT 4
48759: NEG
48760: PUSH
48761: LD_INT 1
48763: NEG
48764: PUSH
48765: EMPTY
48766: LIST
48767: LIST
48768: PUSH
48769: LD_INT 3
48771: NEG
48772: PUSH
48773: LD_INT 0
48775: PUSH
48776: EMPTY
48777: LIST
48778: LIST
48779: PUSH
48780: LD_INT 3
48782: NEG
48783: PUSH
48784: LD_INT 1
48786: PUSH
48787: EMPTY
48788: LIST
48789: LIST
48790: PUSH
48791: LD_INT 4
48793: NEG
48794: PUSH
48795: LD_INT 1
48797: PUSH
48798: EMPTY
48799: LIST
48800: LIST
48801: PUSH
48802: LD_INT 5
48804: NEG
48805: PUSH
48806: LD_INT 0
48808: PUSH
48809: EMPTY
48810: LIST
48811: LIST
48812: PUSH
48813: LD_INT 5
48815: NEG
48816: PUSH
48817: LD_INT 1
48819: NEG
48820: PUSH
48821: EMPTY
48822: LIST
48823: LIST
48824: PUSH
48825: LD_INT 5
48827: NEG
48828: PUSH
48829: LD_INT 2
48831: NEG
48832: PUSH
48833: EMPTY
48834: LIST
48835: LIST
48836: PUSH
48837: LD_INT 3
48839: NEG
48840: PUSH
48841: LD_INT 2
48843: PUSH
48844: EMPTY
48845: LIST
48846: LIST
48847: PUSH
48848: LD_INT 3
48850: NEG
48851: PUSH
48852: LD_INT 3
48854: NEG
48855: PUSH
48856: EMPTY
48857: LIST
48858: LIST
48859: PUSH
48860: LD_INT 3
48862: NEG
48863: PUSH
48864: LD_INT 4
48866: NEG
48867: PUSH
48868: EMPTY
48869: LIST
48870: LIST
48871: PUSH
48872: LD_INT 2
48874: NEG
48875: PUSH
48876: LD_INT 3
48878: NEG
48879: PUSH
48880: EMPTY
48881: LIST
48882: LIST
48883: PUSH
48884: LD_INT 2
48886: NEG
48887: PUSH
48888: LD_INT 2
48890: NEG
48891: PUSH
48892: EMPTY
48893: LIST
48894: LIST
48895: PUSH
48896: LD_INT 3
48898: NEG
48899: PUSH
48900: LD_INT 2
48902: NEG
48903: PUSH
48904: EMPTY
48905: LIST
48906: LIST
48907: PUSH
48908: LD_INT 4
48910: NEG
48911: PUSH
48912: LD_INT 3
48914: NEG
48915: PUSH
48916: EMPTY
48917: LIST
48918: LIST
48919: PUSH
48920: LD_INT 4
48922: NEG
48923: PUSH
48924: LD_INT 4
48926: NEG
48927: PUSH
48928: EMPTY
48929: LIST
48930: LIST
48931: PUSH
48932: LD_INT 2
48934: NEG
48935: PUSH
48936: LD_INT 4
48938: NEG
48939: PUSH
48940: EMPTY
48941: LIST
48942: LIST
48943: PUSH
48944: LD_INT 4
48946: NEG
48947: PUSH
48948: LD_INT 2
48950: NEG
48951: PUSH
48952: EMPTY
48953: LIST
48954: LIST
48955: PUSH
48956: LD_INT 0
48958: PUSH
48959: LD_INT 4
48961: NEG
48962: PUSH
48963: EMPTY
48964: LIST
48965: LIST
48966: PUSH
48967: LD_INT 0
48969: PUSH
48970: LD_INT 5
48972: NEG
48973: PUSH
48974: EMPTY
48975: LIST
48976: LIST
48977: PUSH
48978: LD_INT 1
48980: PUSH
48981: LD_INT 4
48983: NEG
48984: PUSH
48985: EMPTY
48986: LIST
48987: LIST
48988: PUSH
48989: LD_INT 1
48991: PUSH
48992: LD_INT 3
48994: NEG
48995: PUSH
48996: EMPTY
48997: LIST
48998: LIST
48999: PUSH
49000: LD_INT 0
49002: PUSH
49003: LD_INT 3
49005: NEG
49006: PUSH
49007: EMPTY
49008: LIST
49009: LIST
49010: PUSH
49011: LD_INT 1
49013: NEG
49014: PUSH
49015: LD_INT 4
49017: NEG
49018: PUSH
49019: EMPTY
49020: LIST
49021: LIST
49022: PUSH
49023: LD_INT 1
49025: NEG
49026: PUSH
49027: LD_INT 5
49029: NEG
49030: PUSH
49031: EMPTY
49032: LIST
49033: LIST
49034: PUSH
49035: LD_INT 2
49037: PUSH
49038: LD_INT 3
49040: NEG
49041: PUSH
49042: EMPTY
49043: LIST
49044: LIST
49045: PUSH
49046: LD_INT 2
49048: NEG
49049: PUSH
49050: LD_INT 5
49052: NEG
49053: PUSH
49054: EMPTY
49055: LIST
49056: LIST
49057: PUSH
49058: LD_INT 3
49060: PUSH
49061: LD_INT 0
49063: PUSH
49064: EMPTY
49065: LIST
49066: LIST
49067: PUSH
49068: LD_INT 3
49070: PUSH
49071: LD_INT 1
49073: NEG
49074: PUSH
49075: EMPTY
49076: LIST
49077: LIST
49078: PUSH
49079: LD_INT 4
49081: PUSH
49082: LD_INT 0
49084: PUSH
49085: EMPTY
49086: LIST
49087: LIST
49088: PUSH
49089: LD_INT 4
49091: PUSH
49092: LD_INT 1
49094: PUSH
49095: EMPTY
49096: LIST
49097: LIST
49098: PUSH
49099: LD_INT 3
49101: PUSH
49102: LD_INT 1
49104: PUSH
49105: EMPTY
49106: LIST
49107: LIST
49108: PUSH
49109: LD_INT 2
49111: PUSH
49112: LD_INT 0
49114: PUSH
49115: EMPTY
49116: LIST
49117: LIST
49118: PUSH
49119: LD_INT 2
49121: PUSH
49122: LD_INT 1
49124: NEG
49125: PUSH
49126: EMPTY
49127: LIST
49128: LIST
49129: PUSH
49130: LD_INT 2
49132: PUSH
49133: LD_INT 2
49135: NEG
49136: PUSH
49137: EMPTY
49138: LIST
49139: LIST
49140: PUSH
49141: LD_INT 4
49143: PUSH
49144: LD_INT 2
49146: PUSH
49147: EMPTY
49148: LIST
49149: LIST
49150: PUSH
49151: LD_INT 4
49153: PUSH
49154: LD_INT 4
49156: PUSH
49157: EMPTY
49158: LIST
49159: LIST
49160: PUSH
49161: LD_INT 4
49163: PUSH
49164: LD_INT 3
49166: PUSH
49167: EMPTY
49168: LIST
49169: LIST
49170: PUSH
49171: LD_INT 5
49173: PUSH
49174: LD_INT 4
49176: PUSH
49177: EMPTY
49178: LIST
49179: LIST
49180: PUSH
49181: LD_INT 5
49183: PUSH
49184: LD_INT 5
49186: PUSH
49187: EMPTY
49188: LIST
49189: LIST
49190: PUSH
49191: LD_INT 4
49193: PUSH
49194: LD_INT 5
49196: PUSH
49197: EMPTY
49198: LIST
49199: LIST
49200: PUSH
49201: LD_INT 3
49203: PUSH
49204: LD_INT 4
49206: PUSH
49207: EMPTY
49208: LIST
49209: LIST
49210: PUSH
49211: LD_INT 3
49213: PUSH
49214: LD_INT 3
49216: PUSH
49217: EMPTY
49218: LIST
49219: LIST
49220: PUSH
49221: LD_INT 5
49223: PUSH
49224: LD_INT 3
49226: PUSH
49227: EMPTY
49228: LIST
49229: LIST
49230: PUSH
49231: LD_INT 3
49233: PUSH
49234: LD_INT 5
49236: PUSH
49237: EMPTY
49238: LIST
49239: LIST
49240: PUSH
49241: EMPTY
49242: LIST
49243: LIST
49244: LIST
49245: LIST
49246: LIST
49247: LIST
49248: LIST
49249: LIST
49250: LIST
49251: LIST
49252: LIST
49253: LIST
49254: LIST
49255: LIST
49256: LIST
49257: LIST
49258: LIST
49259: LIST
49260: LIST
49261: LIST
49262: LIST
49263: LIST
49264: LIST
49265: LIST
49266: LIST
49267: LIST
49268: LIST
49269: LIST
49270: LIST
49271: LIST
49272: LIST
49273: LIST
49274: LIST
49275: LIST
49276: LIST
49277: LIST
49278: LIST
49279: LIST
49280: LIST
49281: LIST
49282: LIST
49283: LIST
49284: LIST
49285: LIST
49286: LIST
49287: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
49288: LD_ADDR_VAR 0 33
49292: PUSH
49293: LD_INT 4
49295: NEG
49296: PUSH
49297: LD_INT 4
49299: NEG
49300: PUSH
49301: EMPTY
49302: LIST
49303: LIST
49304: PUSH
49305: LD_INT 4
49307: NEG
49308: PUSH
49309: LD_INT 5
49311: NEG
49312: PUSH
49313: EMPTY
49314: LIST
49315: LIST
49316: PUSH
49317: LD_INT 3
49319: NEG
49320: PUSH
49321: LD_INT 4
49323: NEG
49324: PUSH
49325: EMPTY
49326: LIST
49327: LIST
49328: PUSH
49329: LD_INT 3
49331: NEG
49332: PUSH
49333: LD_INT 3
49335: NEG
49336: PUSH
49337: EMPTY
49338: LIST
49339: LIST
49340: PUSH
49341: LD_INT 4
49343: NEG
49344: PUSH
49345: LD_INT 3
49347: NEG
49348: PUSH
49349: EMPTY
49350: LIST
49351: LIST
49352: PUSH
49353: LD_INT 5
49355: NEG
49356: PUSH
49357: LD_INT 4
49359: NEG
49360: PUSH
49361: EMPTY
49362: LIST
49363: LIST
49364: PUSH
49365: LD_INT 5
49367: NEG
49368: PUSH
49369: LD_INT 5
49371: NEG
49372: PUSH
49373: EMPTY
49374: LIST
49375: LIST
49376: PUSH
49377: LD_INT 3
49379: NEG
49380: PUSH
49381: LD_INT 5
49383: NEG
49384: PUSH
49385: EMPTY
49386: LIST
49387: LIST
49388: PUSH
49389: LD_INT 5
49391: NEG
49392: PUSH
49393: LD_INT 3
49395: NEG
49396: PUSH
49397: EMPTY
49398: LIST
49399: LIST
49400: PUSH
49401: LD_INT 0
49403: PUSH
49404: LD_INT 3
49406: NEG
49407: PUSH
49408: EMPTY
49409: LIST
49410: LIST
49411: PUSH
49412: LD_INT 0
49414: PUSH
49415: LD_INT 4
49417: NEG
49418: PUSH
49419: EMPTY
49420: LIST
49421: LIST
49422: PUSH
49423: LD_INT 1
49425: PUSH
49426: LD_INT 3
49428: NEG
49429: PUSH
49430: EMPTY
49431: LIST
49432: LIST
49433: PUSH
49434: LD_INT 1
49436: PUSH
49437: LD_INT 2
49439: NEG
49440: PUSH
49441: EMPTY
49442: LIST
49443: LIST
49444: PUSH
49445: LD_INT 0
49447: PUSH
49448: LD_INT 2
49450: NEG
49451: PUSH
49452: EMPTY
49453: LIST
49454: LIST
49455: PUSH
49456: LD_INT 1
49458: NEG
49459: PUSH
49460: LD_INT 3
49462: NEG
49463: PUSH
49464: EMPTY
49465: LIST
49466: LIST
49467: PUSH
49468: LD_INT 1
49470: NEG
49471: PUSH
49472: LD_INT 4
49474: NEG
49475: PUSH
49476: EMPTY
49477: LIST
49478: LIST
49479: PUSH
49480: LD_INT 2
49482: PUSH
49483: LD_INT 2
49485: NEG
49486: PUSH
49487: EMPTY
49488: LIST
49489: LIST
49490: PUSH
49491: LD_INT 2
49493: NEG
49494: PUSH
49495: LD_INT 4
49497: NEG
49498: PUSH
49499: EMPTY
49500: LIST
49501: LIST
49502: PUSH
49503: LD_INT 4
49505: PUSH
49506: LD_INT 0
49508: PUSH
49509: EMPTY
49510: LIST
49511: LIST
49512: PUSH
49513: LD_INT 4
49515: PUSH
49516: LD_INT 1
49518: NEG
49519: PUSH
49520: EMPTY
49521: LIST
49522: LIST
49523: PUSH
49524: LD_INT 5
49526: PUSH
49527: LD_INT 0
49529: PUSH
49530: EMPTY
49531: LIST
49532: LIST
49533: PUSH
49534: LD_INT 5
49536: PUSH
49537: LD_INT 1
49539: PUSH
49540: EMPTY
49541: LIST
49542: LIST
49543: PUSH
49544: LD_INT 4
49546: PUSH
49547: LD_INT 1
49549: PUSH
49550: EMPTY
49551: LIST
49552: LIST
49553: PUSH
49554: LD_INT 3
49556: PUSH
49557: LD_INT 0
49559: PUSH
49560: EMPTY
49561: LIST
49562: LIST
49563: PUSH
49564: LD_INT 3
49566: PUSH
49567: LD_INT 1
49569: NEG
49570: PUSH
49571: EMPTY
49572: LIST
49573: LIST
49574: PUSH
49575: LD_INT 3
49577: PUSH
49578: LD_INT 2
49580: NEG
49581: PUSH
49582: EMPTY
49583: LIST
49584: LIST
49585: PUSH
49586: LD_INT 5
49588: PUSH
49589: LD_INT 2
49591: PUSH
49592: EMPTY
49593: LIST
49594: LIST
49595: PUSH
49596: LD_INT 3
49598: PUSH
49599: LD_INT 3
49601: PUSH
49602: EMPTY
49603: LIST
49604: LIST
49605: PUSH
49606: LD_INT 3
49608: PUSH
49609: LD_INT 2
49611: PUSH
49612: EMPTY
49613: LIST
49614: LIST
49615: PUSH
49616: LD_INT 4
49618: PUSH
49619: LD_INT 3
49621: PUSH
49622: EMPTY
49623: LIST
49624: LIST
49625: PUSH
49626: LD_INT 4
49628: PUSH
49629: LD_INT 4
49631: PUSH
49632: EMPTY
49633: LIST
49634: LIST
49635: PUSH
49636: LD_INT 3
49638: PUSH
49639: LD_INT 4
49641: PUSH
49642: EMPTY
49643: LIST
49644: LIST
49645: PUSH
49646: LD_INT 2
49648: PUSH
49649: LD_INT 3
49651: PUSH
49652: EMPTY
49653: LIST
49654: LIST
49655: PUSH
49656: LD_INT 2
49658: PUSH
49659: LD_INT 2
49661: PUSH
49662: EMPTY
49663: LIST
49664: LIST
49665: PUSH
49666: LD_INT 4
49668: PUSH
49669: LD_INT 2
49671: PUSH
49672: EMPTY
49673: LIST
49674: LIST
49675: PUSH
49676: LD_INT 2
49678: PUSH
49679: LD_INT 4
49681: PUSH
49682: EMPTY
49683: LIST
49684: LIST
49685: PUSH
49686: LD_INT 0
49688: PUSH
49689: LD_INT 4
49691: PUSH
49692: EMPTY
49693: LIST
49694: LIST
49695: PUSH
49696: LD_INT 0
49698: PUSH
49699: LD_INT 3
49701: PUSH
49702: EMPTY
49703: LIST
49704: LIST
49705: PUSH
49706: LD_INT 1
49708: PUSH
49709: LD_INT 4
49711: PUSH
49712: EMPTY
49713: LIST
49714: LIST
49715: PUSH
49716: LD_INT 1
49718: PUSH
49719: LD_INT 5
49721: PUSH
49722: EMPTY
49723: LIST
49724: LIST
49725: PUSH
49726: LD_INT 0
49728: PUSH
49729: LD_INT 5
49731: PUSH
49732: EMPTY
49733: LIST
49734: LIST
49735: PUSH
49736: LD_INT 1
49738: NEG
49739: PUSH
49740: LD_INT 4
49742: PUSH
49743: EMPTY
49744: LIST
49745: LIST
49746: PUSH
49747: LD_INT 1
49749: NEG
49750: PUSH
49751: LD_INT 3
49753: PUSH
49754: EMPTY
49755: LIST
49756: LIST
49757: PUSH
49758: LD_INT 2
49760: PUSH
49761: LD_INT 5
49763: PUSH
49764: EMPTY
49765: LIST
49766: LIST
49767: PUSH
49768: LD_INT 2
49770: NEG
49771: PUSH
49772: LD_INT 3
49774: PUSH
49775: EMPTY
49776: LIST
49777: LIST
49778: PUSH
49779: EMPTY
49780: LIST
49781: LIST
49782: LIST
49783: LIST
49784: LIST
49785: LIST
49786: LIST
49787: LIST
49788: LIST
49789: LIST
49790: LIST
49791: LIST
49792: LIST
49793: LIST
49794: LIST
49795: LIST
49796: LIST
49797: LIST
49798: LIST
49799: LIST
49800: LIST
49801: LIST
49802: LIST
49803: LIST
49804: LIST
49805: LIST
49806: LIST
49807: LIST
49808: LIST
49809: LIST
49810: LIST
49811: LIST
49812: LIST
49813: LIST
49814: LIST
49815: LIST
49816: LIST
49817: LIST
49818: LIST
49819: LIST
49820: LIST
49821: LIST
49822: LIST
49823: LIST
49824: LIST
49825: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
49826: LD_ADDR_VAR 0 34
49830: PUSH
49831: LD_INT 0
49833: PUSH
49834: LD_INT 4
49836: NEG
49837: PUSH
49838: EMPTY
49839: LIST
49840: LIST
49841: PUSH
49842: LD_INT 0
49844: PUSH
49845: LD_INT 5
49847: NEG
49848: PUSH
49849: EMPTY
49850: LIST
49851: LIST
49852: PUSH
49853: LD_INT 1
49855: PUSH
49856: LD_INT 4
49858: NEG
49859: PUSH
49860: EMPTY
49861: LIST
49862: LIST
49863: PUSH
49864: LD_INT 1
49866: PUSH
49867: LD_INT 3
49869: NEG
49870: PUSH
49871: EMPTY
49872: LIST
49873: LIST
49874: PUSH
49875: LD_INT 0
49877: PUSH
49878: LD_INT 3
49880: NEG
49881: PUSH
49882: EMPTY
49883: LIST
49884: LIST
49885: PUSH
49886: LD_INT 1
49888: NEG
49889: PUSH
49890: LD_INT 4
49892: NEG
49893: PUSH
49894: EMPTY
49895: LIST
49896: LIST
49897: PUSH
49898: LD_INT 1
49900: NEG
49901: PUSH
49902: LD_INT 5
49904: NEG
49905: PUSH
49906: EMPTY
49907: LIST
49908: LIST
49909: PUSH
49910: LD_INT 2
49912: PUSH
49913: LD_INT 3
49915: NEG
49916: PUSH
49917: EMPTY
49918: LIST
49919: LIST
49920: PUSH
49921: LD_INT 2
49923: NEG
49924: PUSH
49925: LD_INT 5
49927: NEG
49928: PUSH
49929: EMPTY
49930: LIST
49931: LIST
49932: PUSH
49933: LD_INT 3
49935: PUSH
49936: LD_INT 0
49938: PUSH
49939: EMPTY
49940: LIST
49941: LIST
49942: PUSH
49943: LD_INT 3
49945: PUSH
49946: LD_INT 1
49948: NEG
49949: PUSH
49950: EMPTY
49951: LIST
49952: LIST
49953: PUSH
49954: LD_INT 4
49956: PUSH
49957: LD_INT 0
49959: PUSH
49960: EMPTY
49961: LIST
49962: LIST
49963: PUSH
49964: LD_INT 4
49966: PUSH
49967: LD_INT 1
49969: PUSH
49970: EMPTY
49971: LIST
49972: LIST
49973: PUSH
49974: LD_INT 3
49976: PUSH
49977: LD_INT 1
49979: PUSH
49980: EMPTY
49981: LIST
49982: LIST
49983: PUSH
49984: LD_INT 2
49986: PUSH
49987: LD_INT 0
49989: PUSH
49990: EMPTY
49991: LIST
49992: LIST
49993: PUSH
49994: LD_INT 2
49996: PUSH
49997: LD_INT 1
49999: NEG
50000: PUSH
50001: EMPTY
50002: LIST
50003: LIST
50004: PUSH
50005: LD_INT 2
50007: PUSH
50008: LD_INT 2
50010: NEG
50011: PUSH
50012: EMPTY
50013: LIST
50014: LIST
50015: PUSH
50016: LD_INT 4
50018: PUSH
50019: LD_INT 2
50021: PUSH
50022: EMPTY
50023: LIST
50024: LIST
50025: PUSH
50026: LD_INT 4
50028: PUSH
50029: LD_INT 4
50031: PUSH
50032: EMPTY
50033: LIST
50034: LIST
50035: PUSH
50036: LD_INT 4
50038: PUSH
50039: LD_INT 3
50041: PUSH
50042: EMPTY
50043: LIST
50044: LIST
50045: PUSH
50046: LD_INT 5
50048: PUSH
50049: LD_INT 4
50051: PUSH
50052: EMPTY
50053: LIST
50054: LIST
50055: PUSH
50056: LD_INT 5
50058: PUSH
50059: LD_INT 5
50061: PUSH
50062: EMPTY
50063: LIST
50064: LIST
50065: PUSH
50066: LD_INT 4
50068: PUSH
50069: LD_INT 5
50071: PUSH
50072: EMPTY
50073: LIST
50074: LIST
50075: PUSH
50076: LD_INT 3
50078: PUSH
50079: LD_INT 4
50081: PUSH
50082: EMPTY
50083: LIST
50084: LIST
50085: PUSH
50086: LD_INT 3
50088: PUSH
50089: LD_INT 3
50091: PUSH
50092: EMPTY
50093: LIST
50094: LIST
50095: PUSH
50096: LD_INT 5
50098: PUSH
50099: LD_INT 3
50101: PUSH
50102: EMPTY
50103: LIST
50104: LIST
50105: PUSH
50106: LD_INT 3
50108: PUSH
50109: LD_INT 5
50111: PUSH
50112: EMPTY
50113: LIST
50114: LIST
50115: PUSH
50116: LD_INT 0
50118: PUSH
50119: LD_INT 3
50121: PUSH
50122: EMPTY
50123: LIST
50124: LIST
50125: PUSH
50126: LD_INT 0
50128: PUSH
50129: LD_INT 2
50131: PUSH
50132: EMPTY
50133: LIST
50134: LIST
50135: PUSH
50136: LD_INT 1
50138: PUSH
50139: LD_INT 3
50141: PUSH
50142: EMPTY
50143: LIST
50144: LIST
50145: PUSH
50146: LD_INT 1
50148: PUSH
50149: LD_INT 4
50151: PUSH
50152: EMPTY
50153: LIST
50154: LIST
50155: PUSH
50156: LD_INT 0
50158: PUSH
50159: LD_INT 4
50161: PUSH
50162: EMPTY
50163: LIST
50164: LIST
50165: PUSH
50166: LD_INT 1
50168: NEG
50169: PUSH
50170: LD_INT 3
50172: PUSH
50173: EMPTY
50174: LIST
50175: LIST
50176: PUSH
50177: LD_INT 1
50179: NEG
50180: PUSH
50181: LD_INT 2
50183: PUSH
50184: EMPTY
50185: LIST
50186: LIST
50187: PUSH
50188: LD_INT 2
50190: PUSH
50191: LD_INT 4
50193: PUSH
50194: EMPTY
50195: LIST
50196: LIST
50197: PUSH
50198: LD_INT 2
50200: NEG
50201: PUSH
50202: LD_INT 2
50204: PUSH
50205: EMPTY
50206: LIST
50207: LIST
50208: PUSH
50209: LD_INT 4
50211: NEG
50212: PUSH
50213: LD_INT 0
50215: PUSH
50216: EMPTY
50217: LIST
50218: LIST
50219: PUSH
50220: LD_INT 4
50222: NEG
50223: PUSH
50224: LD_INT 1
50226: NEG
50227: PUSH
50228: EMPTY
50229: LIST
50230: LIST
50231: PUSH
50232: LD_INT 3
50234: NEG
50235: PUSH
50236: LD_INT 0
50238: PUSH
50239: EMPTY
50240: LIST
50241: LIST
50242: PUSH
50243: LD_INT 3
50245: NEG
50246: PUSH
50247: LD_INT 1
50249: PUSH
50250: EMPTY
50251: LIST
50252: LIST
50253: PUSH
50254: LD_INT 4
50256: NEG
50257: PUSH
50258: LD_INT 1
50260: PUSH
50261: EMPTY
50262: LIST
50263: LIST
50264: PUSH
50265: LD_INT 5
50267: NEG
50268: PUSH
50269: LD_INT 0
50271: PUSH
50272: EMPTY
50273: LIST
50274: LIST
50275: PUSH
50276: LD_INT 5
50278: NEG
50279: PUSH
50280: LD_INT 1
50282: NEG
50283: PUSH
50284: EMPTY
50285: LIST
50286: LIST
50287: PUSH
50288: LD_INT 5
50290: NEG
50291: PUSH
50292: LD_INT 2
50294: NEG
50295: PUSH
50296: EMPTY
50297: LIST
50298: LIST
50299: PUSH
50300: LD_INT 3
50302: NEG
50303: PUSH
50304: LD_INT 2
50306: PUSH
50307: EMPTY
50308: LIST
50309: LIST
50310: PUSH
50311: EMPTY
50312: LIST
50313: LIST
50314: LIST
50315: LIST
50316: LIST
50317: LIST
50318: LIST
50319: LIST
50320: LIST
50321: LIST
50322: LIST
50323: LIST
50324: LIST
50325: LIST
50326: LIST
50327: LIST
50328: LIST
50329: LIST
50330: LIST
50331: LIST
50332: LIST
50333: LIST
50334: LIST
50335: LIST
50336: LIST
50337: LIST
50338: LIST
50339: LIST
50340: LIST
50341: LIST
50342: LIST
50343: LIST
50344: LIST
50345: LIST
50346: LIST
50347: LIST
50348: LIST
50349: LIST
50350: LIST
50351: LIST
50352: LIST
50353: LIST
50354: LIST
50355: LIST
50356: LIST
50357: ST_TO_ADDR
// end ; end ;
50358: GO 50361
50360: POP
// case btype of b_depot , b_warehouse :
50361: LD_VAR 0 1
50365: PUSH
50366: LD_INT 0
50368: DOUBLE
50369: EQUAL
50370: IFTRUE 50380
50372: LD_INT 1
50374: DOUBLE
50375: EQUAL
50376: IFTRUE 50380
50378: GO 50581
50380: POP
// case nation of nation_american :
50381: LD_VAR 0 5
50385: PUSH
50386: LD_INT 1
50388: DOUBLE
50389: EQUAL
50390: IFTRUE 50394
50392: GO 50450
50394: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
50395: LD_ADDR_VAR 0 9
50399: PUSH
50400: LD_VAR 0 11
50404: PUSH
50405: LD_VAR 0 12
50409: PUSH
50410: LD_VAR 0 13
50414: PUSH
50415: LD_VAR 0 14
50419: PUSH
50420: LD_VAR 0 15
50424: PUSH
50425: LD_VAR 0 16
50429: PUSH
50430: EMPTY
50431: LIST
50432: LIST
50433: LIST
50434: LIST
50435: LIST
50436: LIST
50437: PUSH
50438: LD_VAR 0 4
50442: PUSH
50443: LD_INT 1
50445: PLUS
50446: ARRAY
50447: ST_TO_ADDR
50448: GO 50579
50450: LD_INT 2
50452: DOUBLE
50453: EQUAL
50454: IFTRUE 50458
50456: GO 50514
50458: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
50459: LD_ADDR_VAR 0 9
50463: PUSH
50464: LD_VAR 0 17
50468: PUSH
50469: LD_VAR 0 18
50473: PUSH
50474: LD_VAR 0 19
50478: PUSH
50479: LD_VAR 0 20
50483: PUSH
50484: LD_VAR 0 21
50488: PUSH
50489: LD_VAR 0 22
50493: PUSH
50494: EMPTY
50495: LIST
50496: LIST
50497: LIST
50498: LIST
50499: LIST
50500: LIST
50501: PUSH
50502: LD_VAR 0 4
50506: PUSH
50507: LD_INT 1
50509: PLUS
50510: ARRAY
50511: ST_TO_ADDR
50512: GO 50579
50514: LD_INT 3
50516: DOUBLE
50517: EQUAL
50518: IFTRUE 50522
50520: GO 50578
50522: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
50523: LD_ADDR_VAR 0 9
50527: PUSH
50528: LD_VAR 0 23
50532: PUSH
50533: LD_VAR 0 24
50537: PUSH
50538: LD_VAR 0 25
50542: PUSH
50543: LD_VAR 0 26
50547: PUSH
50548: LD_VAR 0 27
50552: PUSH
50553: LD_VAR 0 28
50557: PUSH
50558: EMPTY
50559: LIST
50560: LIST
50561: LIST
50562: LIST
50563: LIST
50564: LIST
50565: PUSH
50566: LD_VAR 0 4
50570: PUSH
50571: LD_INT 1
50573: PLUS
50574: ARRAY
50575: ST_TO_ADDR
50576: GO 50579
50578: POP
50579: GO 51134
50581: LD_INT 2
50583: DOUBLE
50584: EQUAL
50585: IFTRUE 50595
50587: LD_INT 3
50589: DOUBLE
50590: EQUAL
50591: IFTRUE 50595
50593: GO 50651
50595: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
50596: LD_ADDR_VAR 0 9
50600: PUSH
50601: LD_VAR 0 29
50605: PUSH
50606: LD_VAR 0 30
50610: PUSH
50611: LD_VAR 0 31
50615: PUSH
50616: LD_VAR 0 32
50620: PUSH
50621: LD_VAR 0 33
50625: PUSH
50626: LD_VAR 0 34
50630: PUSH
50631: EMPTY
50632: LIST
50633: LIST
50634: LIST
50635: LIST
50636: LIST
50637: LIST
50638: PUSH
50639: LD_VAR 0 4
50643: PUSH
50644: LD_INT 1
50646: PLUS
50647: ARRAY
50648: ST_TO_ADDR
50649: GO 51134
50651: LD_INT 16
50653: DOUBLE
50654: EQUAL
50655: IFTRUE 50713
50657: LD_INT 17
50659: DOUBLE
50660: EQUAL
50661: IFTRUE 50713
50663: LD_INT 18
50665: DOUBLE
50666: EQUAL
50667: IFTRUE 50713
50669: LD_INT 19
50671: DOUBLE
50672: EQUAL
50673: IFTRUE 50713
50675: LD_INT 22
50677: DOUBLE
50678: EQUAL
50679: IFTRUE 50713
50681: LD_INT 20
50683: DOUBLE
50684: EQUAL
50685: IFTRUE 50713
50687: LD_INT 21
50689: DOUBLE
50690: EQUAL
50691: IFTRUE 50713
50693: LD_INT 23
50695: DOUBLE
50696: EQUAL
50697: IFTRUE 50713
50699: LD_INT 24
50701: DOUBLE
50702: EQUAL
50703: IFTRUE 50713
50705: LD_INT 25
50707: DOUBLE
50708: EQUAL
50709: IFTRUE 50713
50711: GO 50769
50713: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
50714: LD_ADDR_VAR 0 9
50718: PUSH
50719: LD_VAR 0 35
50723: PUSH
50724: LD_VAR 0 36
50728: PUSH
50729: LD_VAR 0 37
50733: PUSH
50734: LD_VAR 0 38
50738: PUSH
50739: LD_VAR 0 39
50743: PUSH
50744: LD_VAR 0 40
50748: PUSH
50749: EMPTY
50750: LIST
50751: LIST
50752: LIST
50753: LIST
50754: LIST
50755: LIST
50756: PUSH
50757: LD_VAR 0 4
50761: PUSH
50762: LD_INT 1
50764: PLUS
50765: ARRAY
50766: ST_TO_ADDR
50767: GO 51134
50769: LD_INT 6
50771: DOUBLE
50772: EQUAL
50773: IFTRUE 50825
50775: LD_INT 7
50777: DOUBLE
50778: EQUAL
50779: IFTRUE 50825
50781: LD_INT 8
50783: DOUBLE
50784: EQUAL
50785: IFTRUE 50825
50787: LD_INT 13
50789: DOUBLE
50790: EQUAL
50791: IFTRUE 50825
50793: LD_INT 12
50795: DOUBLE
50796: EQUAL
50797: IFTRUE 50825
50799: LD_INT 15
50801: DOUBLE
50802: EQUAL
50803: IFTRUE 50825
50805: LD_INT 11
50807: DOUBLE
50808: EQUAL
50809: IFTRUE 50825
50811: LD_INT 14
50813: DOUBLE
50814: EQUAL
50815: IFTRUE 50825
50817: LD_INT 10
50819: DOUBLE
50820: EQUAL
50821: IFTRUE 50825
50823: GO 50881
50825: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
50826: LD_ADDR_VAR 0 9
50830: PUSH
50831: LD_VAR 0 41
50835: PUSH
50836: LD_VAR 0 42
50840: PUSH
50841: LD_VAR 0 43
50845: PUSH
50846: LD_VAR 0 44
50850: PUSH
50851: LD_VAR 0 45
50855: PUSH
50856: LD_VAR 0 46
50860: PUSH
50861: EMPTY
50862: LIST
50863: LIST
50864: LIST
50865: LIST
50866: LIST
50867: LIST
50868: PUSH
50869: LD_VAR 0 4
50873: PUSH
50874: LD_INT 1
50876: PLUS
50877: ARRAY
50878: ST_TO_ADDR
50879: GO 51134
50881: LD_INT 36
50883: DOUBLE
50884: EQUAL
50885: IFTRUE 50889
50887: GO 50945
50889: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
50890: LD_ADDR_VAR 0 9
50894: PUSH
50895: LD_VAR 0 47
50899: PUSH
50900: LD_VAR 0 48
50904: PUSH
50905: LD_VAR 0 49
50909: PUSH
50910: LD_VAR 0 50
50914: PUSH
50915: LD_VAR 0 51
50919: PUSH
50920: LD_VAR 0 52
50924: PUSH
50925: EMPTY
50926: LIST
50927: LIST
50928: LIST
50929: LIST
50930: LIST
50931: LIST
50932: PUSH
50933: LD_VAR 0 4
50937: PUSH
50938: LD_INT 1
50940: PLUS
50941: ARRAY
50942: ST_TO_ADDR
50943: GO 51134
50945: LD_INT 4
50947: DOUBLE
50948: EQUAL
50949: IFTRUE 50971
50951: LD_INT 5
50953: DOUBLE
50954: EQUAL
50955: IFTRUE 50971
50957: LD_INT 34
50959: DOUBLE
50960: EQUAL
50961: IFTRUE 50971
50963: LD_INT 37
50965: DOUBLE
50966: EQUAL
50967: IFTRUE 50971
50969: GO 51027
50971: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
50972: LD_ADDR_VAR 0 9
50976: PUSH
50977: LD_VAR 0 53
50981: PUSH
50982: LD_VAR 0 54
50986: PUSH
50987: LD_VAR 0 55
50991: PUSH
50992: LD_VAR 0 56
50996: PUSH
50997: LD_VAR 0 57
51001: PUSH
51002: LD_VAR 0 58
51006: PUSH
51007: EMPTY
51008: LIST
51009: LIST
51010: LIST
51011: LIST
51012: LIST
51013: LIST
51014: PUSH
51015: LD_VAR 0 4
51019: PUSH
51020: LD_INT 1
51022: PLUS
51023: ARRAY
51024: ST_TO_ADDR
51025: GO 51134
51027: LD_INT 31
51029: DOUBLE
51030: EQUAL
51031: IFTRUE 51077
51033: LD_INT 32
51035: DOUBLE
51036: EQUAL
51037: IFTRUE 51077
51039: LD_INT 33
51041: DOUBLE
51042: EQUAL
51043: IFTRUE 51077
51045: LD_INT 27
51047: DOUBLE
51048: EQUAL
51049: IFTRUE 51077
51051: LD_INT 26
51053: DOUBLE
51054: EQUAL
51055: IFTRUE 51077
51057: LD_INT 28
51059: DOUBLE
51060: EQUAL
51061: IFTRUE 51077
51063: LD_INT 29
51065: DOUBLE
51066: EQUAL
51067: IFTRUE 51077
51069: LD_INT 30
51071: DOUBLE
51072: EQUAL
51073: IFTRUE 51077
51075: GO 51133
51077: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
51078: LD_ADDR_VAR 0 9
51082: PUSH
51083: LD_VAR 0 59
51087: PUSH
51088: LD_VAR 0 60
51092: PUSH
51093: LD_VAR 0 61
51097: PUSH
51098: LD_VAR 0 62
51102: PUSH
51103: LD_VAR 0 63
51107: PUSH
51108: LD_VAR 0 64
51112: PUSH
51113: EMPTY
51114: LIST
51115: LIST
51116: LIST
51117: LIST
51118: LIST
51119: LIST
51120: PUSH
51121: LD_VAR 0 4
51125: PUSH
51126: LD_INT 1
51128: PLUS
51129: ARRAY
51130: ST_TO_ADDR
51131: GO 51134
51133: POP
// temp_list2 = [ ] ;
51134: LD_ADDR_VAR 0 10
51138: PUSH
51139: EMPTY
51140: ST_TO_ADDR
// for i in temp_list do
51141: LD_ADDR_VAR 0 8
51145: PUSH
51146: LD_VAR 0 9
51150: PUSH
51151: FOR_IN
51152: IFFALSE 51204
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
51154: LD_ADDR_VAR 0 10
51158: PUSH
51159: LD_VAR 0 10
51163: PUSH
51164: LD_VAR 0 8
51168: PUSH
51169: LD_INT 1
51171: ARRAY
51172: PUSH
51173: LD_VAR 0 2
51177: PLUS
51178: PUSH
51179: LD_VAR 0 8
51183: PUSH
51184: LD_INT 2
51186: ARRAY
51187: PUSH
51188: LD_VAR 0 3
51192: PLUS
51193: PUSH
51194: EMPTY
51195: LIST
51196: LIST
51197: PUSH
51198: EMPTY
51199: LIST
51200: ADD
51201: ST_TO_ADDR
51202: GO 51151
51204: POP
51205: POP
// result = temp_list2 ;
51206: LD_ADDR_VAR 0 7
51210: PUSH
51211: LD_VAR 0 10
51215: ST_TO_ADDR
// end ;
51216: LD_VAR 0 7
51220: RET
// export function EnemyInRange ( unit , dist ) ; begin
51221: LD_INT 0
51223: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
51224: LD_ADDR_VAR 0 3
51228: PUSH
51229: LD_VAR 0 1
51233: PPUSH
51234: CALL_OW 255
51238: PPUSH
51239: LD_VAR 0 1
51243: PPUSH
51244: CALL_OW 250
51248: PPUSH
51249: LD_VAR 0 1
51253: PPUSH
51254: CALL_OW 251
51258: PPUSH
51259: LD_VAR 0 2
51263: PPUSH
51264: CALL 24992 0 4
51268: PUSH
51269: LD_INT 4
51271: ARRAY
51272: ST_TO_ADDR
// end ;
51273: LD_VAR 0 3
51277: RET
// export function PlayerSeeMe ( unit ) ; begin
51278: LD_INT 0
51280: PPUSH
// result := See ( your_side , unit ) ;
51281: LD_ADDR_VAR 0 2
51285: PUSH
51286: LD_OWVAR 2
51290: PPUSH
51291: LD_VAR 0 1
51295: PPUSH
51296: CALL_OW 292
51300: ST_TO_ADDR
// end ;
51301: LD_VAR 0 2
51305: RET
// export function ReverseDir ( unit ) ; begin
51306: LD_INT 0
51308: PPUSH
// if not unit then
51309: LD_VAR 0 1
51313: NOT
51314: IFFALSE 51318
// exit ;
51316: GO 51341
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
51318: LD_ADDR_VAR 0 2
51322: PUSH
51323: LD_VAR 0 1
51327: PPUSH
51328: CALL_OW 254
51332: PUSH
51333: LD_INT 3
51335: PLUS
51336: PUSH
51337: LD_INT 6
51339: MOD
51340: ST_TO_ADDR
// end ;
51341: LD_VAR 0 2
51345: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
51346: LD_INT 0
51348: PPUSH
51349: PPUSH
51350: PPUSH
51351: PPUSH
51352: PPUSH
// if not hexes then
51353: LD_VAR 0 2
51357: NOT
51358: IFFALSE 51362
// exit ;
51360: GO 51510
// dist := 9999 ;
51362: LD_ADDR_VAR 0 5
51366: PUSH
51367: LD_INT 9999
51369: ST_TO_ADDR
// for i = 1 to hexes do
51370: LD_ADDR_VAR 0 4
51374: PUSH
51375: DOUBLE
51376: LD_INT 1
51378: DEC
51379: ST_TO_ADDR
51380: LD_VAR 0 2
51384: PUSH
51385: FOR_TO
51386: IFFALSE 51498
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
51388: LD_VAR 0 1
51392: PPUSH
51393: LD_VAR 0 2
51397: PUSH
51398: LD_VAR 0 4
51402: ARRAY
51403: PUSH
51404: LD_INT 1
51406: ARRAY
51407: PPUSH
51408: LD_VAR 0 2
51412: PUSH
51413: LD_VAR 0 4
51417: ARRAY
51418: PUSH
51419: LD_INT 2
51421: ARRAY
51422: PPUSH
51423: CALL_OW 297
51427: PUSH
51428: LD_VAR 0 5
51432: LESS
51433: IFFALSE 51496
// begin hex := hexes [ i ] ;
51435: LD_ADDR_VAR 0 7
51439: PUSH
51440: LD_VAR 0 2
51444: PUSH
51445: LD_VAR 0 4
51449: ARRAY
51450: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
51451: LD_ADDR_VAR 0 5
51455: PUSH
51456: LD_VAR 0 1
51460: PPUSH
51461: LD_VAR 0 2
51465: PUSH
51466: LD_VAR 0 4
51470: ARRAY
51471: PUSH
51472: LD_INT 1
51474: ARRAY
51475: PPUSH
51476: LD_VAR 0 2
51480: PUSH
51481: LD_VAR 0 4
51485: ARRAY
51486: PUSH
51487: LD_INT 2
51489: ARRAY
51490: PPUSH
51491: CALL_OW 297
51495: ST_TO_ADDR
// end ; end ;
51496: GO 51385
51498: POP
51499: POP
// result := hex ;
51500: LD_ADDR_VAR 0 3
51504: PUSH
51505: LD_VAR 0 7
51509: ST_TO_ADDR
// end ;
51510: LD_VAR 0 3
51514: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
51515: LD_INT 0
51517: PPUSH
51518: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
51519: LD_VAR 0 1
51523: NOT
51524: PUSH
51525: LD_VAR 0 1
51529: PUSH
51530: LD_INT 21
51532: PUSH
51533: LD_INT 2
51535: PUSH
51536: EMPTY
51537: LIST
51538: LIST
51539: PUSH
51540: LD_INT 23
51542: PUSH
51543: LD_INT 2
51545: PUSH
51546: EMPTY
51547: LIST
51548: LIST
51549: PUSH
51550: EMPTY
51551: LIST
51552: LIST
51553: PPUSH
51554: CALL_OW 69
51558: IN
51559: NOT
51560: OR
51561: IFFALSE 51565
// exit ;
51563: GO 51612
// for i = 1 to 3 do
51565: LD_ADDR_VAR 0 3
51569: PUSH
51570: DOUBLE
51571: LD_INT 1
51573: DEC
51574: ST_TO_ADDR
51575: LD_INT 3
51577: PUSH
51578: FOR_TO
51579: IFFALSE 51610
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
51581: LD_VAR 0 1
51585: PPUSH
51586: CALL_OW 250
51590: PPUSH
51591: LD_VAR 0 1
51595: PPUSH
51596: CALL_OW 251
51600: PPUSH
51601: LD_INT 1
51603: PPUSH
51604: CALL_OW 453
51608: GO 51578
51610: POP
51611: POP
// end ;
51612: LD_VAR 0 2
51616: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
51617: LD_INT 0
51619: PPUSH
51620: PPUSH
51621: PPUSH
51622: PPUSH
51623: PPUSH
51624: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
51625: LD_VAR 0 1
51629: NOT
51630: PUSH
51631: LD_VAR 0 2
51635: NOT
51636: OR
51637: PUSH
51638: LD_VAR 0 1
51642: PPUSH
51643: CALL_OW 314
51647: OR
51648: IFFALSE 51652
// exit ;
51650: GO 52093
// x := GetX ( enemy_unit ) ;
51652: LD_ADDR_VAR 0 7
51656: PUSH
51657: LD_VAR 0 2
51661: PPUSH
51662: CALL_OW 250
51666: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
51667: LD_ADDR_VAR 0 8
51671: PUSH
51672: LD_VAR 0 2
51676: PPUSH
51677: CALL_OW 251
51681: ST_TO_ADDR
// if not x or not y then
51682: LD_VAR 0 7
51686: NOT
51687: PUSH
51688: LD_VAR 0 8
51692: NOT
51693: OR
51694: IFFALSE 51698
// exit ;
51696: GO 52093
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
51698: LD_ADDR_VAR 0 6
51702: PUSH
51703: LD_VAR 0 7
51707: PPUSH
51708: LD_INT 0
51710: PPUSH
51711: LD_INT 4
51713: PPUSH
51714: CALL_OW 272
51718: PUSH
51719: LD_VAR 0 8
51723: PPUSH
51724: LD_INT 0
51726: PPUSH
51727: LD_INT 4
51729: PPUSH
51730: CALL_OW 273
51734: PUSH
51735: EMPTY
51736: LIST
51737: LIST
51738: PUSH
51739: LD_VAR 0 7
51743: PPUSH
51744: LD_INT 1
51746: PPUSH
51747: LD_INT 4
51749: PPUSH
51750: CALL_OW 272
51754: PUSH
51755: LD_VAR 0 8
51759: PPUSH
51760: LD_INT 1
51762: PPUSH
51763: LD_INT 4
51765: PPUSH
51766: CALL_OW 273
51770: PUSH
51771: EMPTY
51772: LIST
51773: LIST
51774: PUSH
51775: LD_VAR 0 7
51779: PPUSH
51780: LD_INT 2
51782: PPUSH
51783: LD_INT 4
51785: PPUSH
51786: CALL_OW 272
51790: PUSH
51791: LD_VAR 0 8
51795: PPUSH
51796: LD_INT 2
51798: PPUSH
51799: LD_INT 4
51801: PPUSH
51802: CALL_OW 273
51806: PUSH
51807: EMPTY
51808: LIST
51809: LIST
51810: PUSH
51811: LD_VAR 0 7
51815: PPUSH
51816: LD_INT 3
51818: PPUSH
51819: LD_INT 4
51821: PPUSH
51822: CALL_OW 272
51826: PUSH
51827: LD_VAR 0 8
51831: PPUSH
51832: LD_INT 3
51834: PPUSH
51835: LD_INT 4
51837: PPUSH
51838: CALL_OW 273
51842: PUSH
51843: EMPTY
51844: LIST
51845: LIST
51846: PUSH
51847: LD_VAR 0 7
51851: PPUSH
51852: LD_INT 4
51854: PPUSH
51855: LD_INT 4
51857: PPUSH
51858: CALL_OW 272
51862: PUSH
51863: LD_VAR 0 8
51867: PPUSH
51868: LD_INT 4
51870: PPUSH
51871: LD_INT 4
51873: PPUSH
51874: CALL_OW 273
51878: PUSH
51879: EMPTY
51880: LIST
51881: LIST
51882: PUSH
51883: LD_VAR 0 7
51887: PPUSH
51888: LD_INT 5
51890: PPUSH
51891: LD_INT 4
51893: PPUSH
51894: CALL_OW 272
51898: PUSH
51899: LD_VAR 0 8
51903: PPUSH
51904: LD_INT 5
51906: PPUSH
51907: LD_INT 4
51909: PPUSH
51910: CALL_OW 273
51914: PUSH
51915: EMPTY
51916: LIST
51917: LIST
51918: PUSH
51919: EMPTY
51920: LIST
51921: LIST
51922: LIST
51923: LIST
51924: LIST
51925: LIST
51926: ST_TO_ADDR
// for i = tmp downto 1 do
51927: LD_ADDR_VAR 0 4
51931: PUSH
51932: DOUBLE
51933: LD_VAR 0 6
51937: INC
51938: ST_TO_ADDR
51939: LD_INT 1
51941: PUSH
51942: FOR_DOWNTO
51943: IFFALSE 52044
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
51945: LD_VAR 0 6
51949: PUSH
51950: LD_VAR 0 4
51954: ARRAY
51955: PUSH
51956: LD_INT 1
51958: ARRAY
51959: PPUSH
51960: LD_VAR 0 6
51964: PUSH
51965: LD_VAR 0 4
51969: ARRAY
51970: PUSH
51971: LD_INT 2
51973: ARRAY
51974: PPUSH
51975: CALL_OW 488
51979: NOT
51980: PUSH
51981: LD_VAR 0 6
51985: PUSH
51986: LD_VAR 0 4
51990: ARRAY
51991: PUSH
51992: LD_INT 1
51994: ARRAY
51995: PPUSH
51996: LD_VAR 0 6
52000: PUSH
52001: LD_VAR 0 4
52005: ARRAY
52006: PUSH
52007: LD_INT 2
52009: ARRAY
52010: PPUSH
52011: CALL_OW 428
52015: PUSH
52016: LD_INT 0
52018: NONEQUAL
52019: OR
52020: IFFALSE 52042
// tmp := Delete ( tmp , i ) ;
52022: LD_ADDR_VAR 0 6
52026: PUSH
52027: LD_VAR 0 6
52031: PPUSH
52032: LD_VAR 0 4
52036: PPUSH
52037: CALL_OW 3
52041: ST_TO_ADDR
52042: GO 51942
52044: POP
52045: POP
// j := GetClosestHex ( unit , tmp ) ;
52046: LD_ADDR_VAR 0 5
52050: PUSH
52051: LD_VAR 0 1
52055: PPUSH
52056: LD_VAR 0 6
52060: PPUSH
52061: CALL 51346 0 2
52065: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
52066: LD_VAR 0 1
52070: PPUSH
52071: LD_VAR 0 5
52075: PUSH
52076: LD_INT 1
52078: ARRAY
52079: PPUSH
52080: LD_VAR 0 5
52084: PUSH
52085: LD_INT 2
52087: ARRAY
52088: PPUSH
52089: CALL_OW 111
// end ;
52093: LD_VAR 0 3
52097: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
52098: LD_INT 0
52100: PPUSH
52101: PPUSH
52102: PPUSH
// uc_side = 0 ;
52103: LD_ADDR_OWVAR 20
52107: PUSH
52108: LD_INT 0
52110: ST_TO_ADDR
// uc_nation = 0 ;
52111: LD_ADDR_OWVAR 21
52115: PUSH
52116: LD_INT 0
52118: ST_TO_ADDR
// InitHc_All ( ) ;
52119: CALL_OW 584
// InitVc ;
52123: CALL_OW 20
// if mastodonts then
52127: LD_VAR 0 6
52131: IFFALSE 52198
// for i = 1 to mastodonts do
52133: LD_ADDR_VAR 0 11
52137: PUSH
52138: DOUBLE
52139: LD_INT 1
52141: DEC
52142: ST_TO_ADDR
52143: LD_VAR 0 6
52147: PUSH
52148: FOR_TO
52149: IFFALSE 52196
// begin vc_chassis := 31 ;
52151: LD_ADDR_OWVAR 37
52155: PUSH
52156: LD_INT 31
52158: ST_TO_ADDR
// vc_control := control_rider ;
52159: LD_ADDR_OWVAR 38
52163: PUSH
52164: LD_INT 4
52166: ST_TO_ADDR
// animal := CreateVehicle ;
52167: LD_ADDR_VAR 0 12
52171: PUSH
52172: CALL_OW 45
52176: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
52177: LD_VAR 0 12
52181: PPUSH
52182: LD_VAR 0 8
52186: PPUSH
52187: LD_INT 0
52189: PPUSH
52190: CALL 54386 0 3
// end ;
52194: GO 52148
52196: POP
52197: POP
// if horses then
52198: LD_VAR 0 5
52202: IFFALSE 52269
// for i = 1 to horses do
52204: LD_ADDR_VAR 0 11
52208: PUSH
52209: DOUBLE
52210: LD_INT 1
52212: DEC
52213: ST_TO_ADDR
52214: LD_VAR 0 5
52218: PUSH
52219: FOR_TO
52220: IFFALSE 52267
// begin hc_class := 21 ;
52222: LD_ADDR_OWVAR 28
52226: PUSH
52227: LD_INT 21
52229: ST_TO_ADDR
// hc_gallery :=  ;
52230: LD_ADDR_OWVAR 33
52234: PUSH
52235: LD_STRING 
52237: ST_TO_ADDR
// animal := CreateHuman ;
52238: LD_ADDR_VAR 0 12
52242: PUSH
52243: CALL_OW 44
52247: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
52248: LD_VAR 0 12
52252: PPUSH
52253: LD_VAR 0 8
52257: PPUSH
52258: LD_INT 0
52260: PPUSH
52261: CALL 54386 0 3
// end ;
52265: GO 52219
52267: POP
52268: POP
// if birds then
52269: LD_VAR 0 1
52273: IFFALSE 52340
// for i = 1 to birds do
52275: LD_ADDR_VAR 0 11
52279: PUSH
52280: DOUBLE
52281: LD_INT 1
52283: DEC
52284: ST_TO_ADDR
52285: LD_VAR 0 1
52289: PUSH
52290: FOR_TO
52291: IFFALSE 52338
// begin hc_class = 18 ;
52293: LD_ADDR_OWVAR 28
52297: PUSH
52298: LD_INT 18
52300: ST_TO_ADDR
// hc_gallery =  ;
52301: LD_ADDR_OWVAR 33
52305: PUSH
52306: LD_STRING 
52308: ST_TO_ADDR
// animal := CreateHuman ;
52309: LD_ADDR_VAR 0 12
52313: PUSH
52314: CALL_OW 44
52318: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
52319: LD_VAR 0 12
52323: PPUSH
52324: LD_VAR 0 8
52328: PPUSH
52329: LD_INT 0
52331: PPUSH
52332: CALL 54386 0 3
// end ;
52336: GO 52290
52338: POP
52339: POP
// if tigers then
52340: LD_VAR 0 2
52344: IFFALSE 52428
// for i = 1 to tigers do
52346: LD_ADDR_VAR 0 11
52350: PUSH
52351: DOUBLE
52352: LD_INT 1
52354: DEC
52355: ST_TO_ADDR
52356: LD_VAR 0 2
52360: PUSH
52361: FOR_TO
52362: IFFALSE 52426
// begin hc_class = class_tiger ;
52364: LD_ADDR_OWVAR 28
52368: PUSH
52369: LD_INT 14
52371: ST_TO_ADDR
// hc_gallery =  ;
52372: LD_ADDR_OWVAR 33
52376: PUSH
52377: LD_STRING 
52379: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
52380: LD_ADDR_OWVAR 35
52384: PUSH
52385: LD_INT 7
52387: NEG
52388: PPUSH
52389: LD_INT 7
52391: PPUSH
52392: CALL_OW 12
52396: ST_TO_ADDR
// animal := CreateHuman ;
52397: LD_ADDR_VAR 0 12
52401: PUSH
52402: CALL_OW 44
52406: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
52407: LD_VAR 0 12
52411: PPUSH
52412: LD_VAR 0 8
52416: PPUSH
52417: LD_INT 0
52419: PPUSH
52420: CALL 54386 0 3
// end ;
52424: GO 52361
52426: POP
52427: POP
// if apemans then
52428: LD_VAR 0 3
52432: IFFALSE 52555
// for i = 1 to apemans do
52434: LD_ADDR_VAR 0 11
52438: PUSH
52439: DOUBLE
52440: LD_INT 1
52442: DEC
52443: ST_TO_ADDR
52444: LD_VAR 0 3
52448: PUSH
52449: FOR_TO
52450: IFFALSE 52553
// begin hc_class = class_apeman ;
52452: LD_ADDR_OWVAR 28
52456: PUSH
52457: LD_INT 12
52459: ST_TO_ADDR
// hc_gallery =  ;
52460: LD_ADDR_OWVAR 33
52464: PUSH
52465: LD_STRING 
52467: ST_TO_ADDR
// hc_agressivity = rand ( - 5 , 5 ) ;
52468: LD_ADDR_OWVAR 35
52472: PUSH
52473: LD_INT 5
52475: NEG
52476: PPUSH
52477: LD_INT 5
52479: PPUSH
52480: CALL_OW 12
52484: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
52485: LD_ADDR_OWVAR 31
52489: PUSH
52490: LD_INT 1
52492: PPUSH
52493: LD_INT 3
52495: PPUSH
52496: CALL_OW 12
52500: PUSH
52501: LD_INT 1
52503: PPUSH
52504: LD_INT 3
52506: PPUSH
52507: CALL_OW 12
52511: PUSH
52512: LD_INT 0
52514: PUSH
52515: LD_INT 0
52517: PUSH
52518: EMPTY
52519: LIST
52520: LIST
52521: LIST
52522: LIST
52523: ST_TO_ADDR
// animal := CreateHuman ;
52524: LD_ADDR_VAR 0 12
52528: PUSH
52529: CALL_OW 44
52533: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
52534: LD_VAR 0 12
52538: PPUSH
52539: LD_VAR 0 8
52543: PPUSH
52544: LD_INT 0
52546: PPUSH
52547: CALL 54386 0 3
// end ;
52551: GO 52449
52553: POP
52554: POP
// if enchidnas then
52555: LD_VAR 0 4
52559: IFFALSE 52626
// for i = 1 to enchidnas do
52561: LD_ADDR_VAR 0 11
52565: PUSH
52566: DOUBLE
52567: LD_INT 1
52569: DEC
52570: ST_TO_ADDR
52571: LD_VAR 0 4
52575: PUSH
52576: FOR_TO
52577: IFFALSE 52624
// begin hc_class = 13 ;
52579: LD_ADDR_OWVAR 28
52583: PUSH
52584: LD_INT 13
52586: ST_TO_ADDR
// hc_gallery =  ;
52587: LD_ADDR_OWVAR 33
52591: PUSH
52592: LD_STRING 
52594: ST_TO_ADDR
// animal := CreateHuman ;
52595: LD_ADDR_VAR 0 12
52599: PUSH
52600: CALL_OW 44
52604: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
52605: LD_VAR 0 12
52609: PPUSH
52610: LD_VAR 0 8
52614: PPUSH
52615: LD_INT 0
52617: PPUSH
52618: CALL 54386 0 3
// end ;
52622: GO 52576
52624: POP
52625: POP
// if fishes then
52626: LD_VAR 0 7
52630: IFFALSE 52697
// for i = 1 to fishes do
52632: LD_ADDR_VAR 0 11
52636: PUSH
52637: DOUBLE
52638: LD_INT 1
52640: DEC
52641: ST_TO_ADDR
52642: LD_VAR 0 7
52646: PUSH
52647: FOR_TO
52648: IFFALSE 52695
// begin hc_class = 20 ;
52650: LD_ADDR_OWVAR 28
52654: PUSH
52655: LD_INT 20
52657: ST_TO_ADDR
// hc_gallery =  ;
52658: LD_ADDR_OWVAR 33
52662: PUSH
52663: LD_STRING 
52665: ST_TO_ADDR
// animal := CreateHuman ;
52666: LD_ADDR_VAR 0 12
52670: PUSH
52671: CALL_OW 44
52675: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
52676: LD_VAR 0 12
52680: PPUSH
52681: LD_VAR 0 9
52685: PPUSH
52686: LD_INT 0
52688: PPUSH
52689: CALL 54386 0 3
// end ;
52693: GO 52647
52695: POP
52696: POP
// end ;
52697: LD_VAR 0 10
52701: RET
// export function WantHeal ( sci , unit ) ; begin
52702: LD_INT 0
52704: PPUSH
// if GetTaskList ( sci ) > 0 then
52705: LD_VAR 0 1
52709: PPUSH
52710: CALL_OW 437
52714: PUSH
52715: LD_INT 0
52717: GREATER
52718: IFFALSE 52788
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
52720: LD_VAR 0 1
52724: PPUSH
52725: CALL_OW 437
52729: PUSH
52730: LD_INT 1
52732: ARRAY
52733: PUSH
52734: LD_INT 1
52736: ARRAY
52737: PUSH
52738: LD_STRING l
52740: EQUAL
52741: PUSH
52742: LD_VAR 0 1
52746: PPUSH
52747: CALL_OW 437
52751: PUSH
52752: LD_INT 1
52754: ARRAY
52755: PUSH
52756: LD_INT 4
52758: ARRAY
52759: PUSH
52760: LD_VAR 0 2
52764: EQUAL
52765: AND
52766: IFFALSE 52778
// result := true else
52768: LD_ADDR_VAR 0 3
52772: PUSH
52773: LD_INT 1
52775: ST_TO_ADDR
52776: GO 52786
// result := false ;
52778: LD_ADDR_VAR 0 3
52782: PUSH
52783: LD_INT 0
52785: ST_TO_ADDR
// end else
52786: GO 52796
// result := false ;
52788: LD_ADDR_VAR 0 3
52792: PUSH
52793: LD_INT 0
52795: ST_TO_ADDR
// end ;
52796: LD_VAR 0 3
52800: RET
// export function HealTarget ( sci ) ; begin
52801: LD_INT 0
52803: PPUSH
// if not sci then
52804: LD_VAR 0 1
52808: NOT
52809: IFFALSE 52813
// exit ;
52811: GO 52878
// result := 0 ;
52813: LD_ADDR_VAR 0 2
52817: PUSH
52818: LD_INT 0
52820: ST_TO_ADDR
// if GetTaskList ( sci ) then
52821: LD_VAR 0 1
52825: PPUSH
52826: CALL_OW 437
52830: IFFALSE 52878
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
52832: LD_VAR 0 1
52836: PPUSH
52837: CALL_OW 437
52841: PUSH
52842: LD_INT 1
52844: ARRAY
52845: PUSH
52846: LD_INT 1
52848: ARRAY
52849: PUSH
52850: LD_STRING l
52852: EQUAL
52853: IFFALSE 52878
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
52855: LD_ADDR_VAR 0 2
52859: PUSH
52860: LD_VAR 0 1
52864: PPUSH
52865: CALL_OW 437
52869: PUSH
52870: LD_INT 1
52872: ARRAY
52873: PUSH
52874: LD_INT 4
52876: ARRAY
52877: ST_TO_ADDR
// end ;
52878: LD_VAR 0 2
52882: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
52883: LD_INT 0
52885: PPUSH
52886: PPUSH
52887: PPUSH
52888: PPUSH
// if not base_units then
52889: LD_VAR 0 1
52893: NOT
52894: IFFALSE 52898
// exit ;
52896: GO 52985
// result := false ;
52898: LD_ADDR_VAR 0 2
52902: PUSH
52903: LD_INT 0
52905: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
52906: LD_ADDR_VAR 0 5
52910: PUSH
52911: LD_VAR 0 1
52915: PPUSH
52916: LD_INT 21
52918: PUSH
52919: LD_INT 3
52921: PUSH
52922: EMPTY
52923: LIST
52924: LIST
52925: PPUSH
52926: CALL_OW 72
52930: ST_TO_ADDR
// if not tmp then
52931: LD_VAR 0 5
52935: NOT
52936: IFFALSE 52940
// exit ;
52938: GO 52985
// for i in tmp do
52940: LD_ADDR_VAR 0 3
52944: PUSH
52945: LD_VAR 0 5
52949: PUSH
52950: FOR_IN
52951: IFFALSE 52983
// begin result := EnemyInRange ( i , 22 ) ;
52953: LD_ADDR_VAR 0 2
52957: PUSH
52958: LD_VAR 0 3
52962: PPUSH
52963: LD_INT 22
52965: PPUSH
52966: CALL 51221 0 2
52970: ST_TO_ADDR
// if result then
52971: LD_VAR 0 2
52975: IFFALSE 52981
// exit ;
52977: POP
52978: POP
52979: GO 52985
// end ;
52981: GO 52950
52983: POP
52984: POP
// end ;
52985: LD_VAR 0 2
52989: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
52990: LD_INT 0
52992: PPUSH
52993: PPUSH
// if not units then
52994: LD_VAR 0 1
52998: NOT
52999: IFFALSE 53003
// exit ;
53001: GO 53073
// result := [ ] ;
53003: LD_ADDR_VAR 0 3
53007: PUSH
53008: EMPTY
53009: ST_TO_ADDR
// for i in units do
53010: LD_ADDR_VAR 0 4
53014: PUSH
53015: LD_VAR 0 1
53019: PUSH
53020: FOR_IN
53021: IFFALSE 53071
// if GetTag ( i ) = tag then
53023: LD_VAR 0 4
53027: PPUSH
53028: CALL_OW 110
53032: PUSH
53033: LD_VAR 0 2
53037: EQUAL
53038: IFFALSE 53069
// result := Insert ( result , result + 1 , i ) ;
53040: LD_ADDR_VAR 0 3
53044: PUSH
53045: LD_VAR 0 3
53049: PPUSH
53050: LD_VAR 0 3
53054: PUSH
53055: LD_INT 1
53057: PLUS
53058: PPUSH
53059: LD_VAR 0 4
53063: PPUSH
53064: CALL_OW 2
53068: ST_TO_ADDR
53069: GO 53020
53071: POP
53072: POP
// end ;
53073: LD_VAR 0 3
53077: RET
// export function IsDriver ( un ) ; begin
53078: LD_INT 0
53080: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
53081: LD_ADDR_VAR 0 2
53085: PUSH
53086: LD_VAR 0 1
53090: PUSH
53091: LD_INT 55
53093: PUSH
53094: EMPTY
53095: LIST
53096: PPUSH
53097: CALL_OW 69
53101: IN
53102: ST_TO_ADDR
// end ;
53103: LD_VAR 0 2
53107: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
53108: LD_INT 0
53110: PPUSH
53111: PPUSH
// list := [ ] ;
53112: LD_ADDR_VAR 0 5
53116: PUSH
53117: EMPTY
53118: ST_TO_ADDR
// case d of 0 :
53119: LD_VAR 0 3
53123: PUSH
53124: LD_INT 0
53126: DOUBLE
53127: EQUAL
53128: IFTRUE 53132
53130: GO 53265
53132: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
53133: LD_ADDR_VAR 0 5
53137: PUSH
53138: LD_VAR 0 1
53142: PUSH
53143: LD_INT 4
53145: MINUS
53146: PUSH
53147: LD_VAR 0 2
53151: PUSH
53152: LD_INT 4
53154: MINUS
53155: PUSH
53156: LD_INT 2
53158: PUSH
53159: EMPTY
53160: LIST
53161: LIST
53162: LIST
53163: PUSH
53164: LD_VAR 0 1
53168: PUSH
53169: LD_INT 3
53171: MINUS
53172: PUSH
53173: LD_VAR 0 2
53177: PUSH
53178: LD_INT 1
53180: PUSH
53181: EMPTY
53182: LIST
53183: LIST
53184: LIST
53185: PUSH
53186: LD_VAR 0 1
53190: PUSH
53191: LD_INT 4
53193: PLUS
53194: PUSH
53195: LD_VAR 0 2
53199: PUSH
53200: LD_INT 4
53202: PUSH
53203: EMPTY
53204: LIST
53205: LIST
53206: LIST
53207: PUSH
53208: LD_VAR 0 1
53212: PUSH
53213: LD_INT 3
53215: PLUS
53216: PUSH
53217: LD_VAR 0 2
53221: PUSH
53222: LD_INT 3
53224: PLUS
53225: PUSH
53226: LD_INT 5
53228: PUSH
53229: EMPTY
53230: LIST
53231: LIST
53232: LIST
53233: PUSH
53234: LD_VAR 0 1
53238: PUSH
53239: LD_VAR 0 2
53243: PUSH
53244: LD_INT 4
53246: PLUS
53247: PUSH
53248: LD_INT 0
53250: PUSH
53251: EMPTY
53252: LIST
53253: LIST
53254: LIST
53255: PUSH
53256: EMPTY
53257: LIST
53258: LIST
53259: LIST
53260: LIST
53261: LIST
53262: ST_TO_ADDR
// end ; 1 :
53263: GO 53963
53265: LD_INT 1
53267: DOUBLE
53268: EQUAL
53269: IFTRUE 53273
53271: GO 53406
53273: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
53274: LD_ADDR_VAR 0 5
53278: PUSH
53279: LD_VAR 0 1
53283: PUSH
53284: LD_VAR 0 2
53288: PUSH
53289: LD_INT 4
53291: MINUS
53292: PUSH
53293: LD_INT 3
53295: PUSH
53296: EMPTY
53297: LIST
53298: LIST
53299: LIST
53300: PUSH
53301: LD_VAR 0 1
53305: PUSH
53306: LD_INT 3
53308: MINUS
53309: PUSH
53310: LD_VAR 0 2
53314: PUSH
53315: LD_INT 3
53317: MINUS
53318: PUSH
53319: LD_INT 2
53321: PUSH
53322: EMPTY
53323: LIST
53324: LIST
53325: LIST
53326: PUSH
53327: LD_VAR 0 1
53331: PUSH
53332: LD_INT 4
53334: MINUS
53335: PUSH
53336: LD_VAR 0 2
53340: PUSH
53341: LD_INT 1
53343: PUSH
53344: EMPTY
53345: LIST
53346: LIST
53347: LIST
53348: PUSH
53349: LD_VAR 0 1
53353: PUSH
53354: LD_VAR 0 2
53358: PUSH
53359: LD_INT 3
53361: PLUS
53362: PUSH
53363: LD_INT 0
53365: PUSH
53366: EMPTY
53367: LIST
53368: LIST
53369: LIST
53370: PUSH
53371: LD_VAR 0 1
53375: PUSH
53376: LD_INT 4
53378: PLUS
53379: PUSH
53380: LD_VAR 0 2
53384: PUSH
53385: LD_INT 4
53387: PLUS
53388: PUSH
53389: LD_INT 5
53391: PUSH
53392: EMPTY
53393: LIST
53394: LIST
53395: LIST
53396: PUSH
53397: EMPTY
53398: LIST
53399: LIST
53400: LIST
53401: LIST
53402: LIST
53403: ST_TO_ADDR
// end ; 2 :
53404: GO 53963
53406: LD_INT 2
53408: DOUBLE
53409: EQUAL
53410: IFTRUE 53414
53412: GO 53543
53414: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
53415: LD_ADDR_VAR 0 5
53419: PUSH
53420: LD_VAR 0 1
53424: PUSH
53425: LD_VAR 0 2
53429: PUSH
53430: LD_INT 3
53432: MINUS
53433: PUSH
53434: LD_INT 3
53436: PUSH
53437: EMPTY
53438: LIST
53439: LIST
53440: LIST
53441: PUSH
53442: LD_VAR 0 1
53446: PUSH
53447: LD_INT 4
53449: PLUS
53450: PUSH
53451: LD_VAR 0 2
53455: PUSH
53456: LD_INT 4
53458: PUSH
53459: EMPTY
53460: LIST
53461: LIST
53462: LIST
53463: PUSH
53464: LD_VAR 0 1
53468: PUSH
53469: LD_VAR 0 2
53473: PUSH
53474: LD_INT 4
53476: PLUS
53477: PUSH
53478: LD_INT 0
53480: PUSH
53481: EMPTY
53482: LIST
53483: LIST
53484: LIST
53485: PUSH
53486: LD_VAR 0 1
53490: PUSH
53491: LD_INT 3
53493: MINUS
53494: PUSH
53495: LD_VAR 0 2
53499: PUSH
53500: LD_INT 1
53502: PUSH
53503: EMPTY
53504: LIST
53505: LIST
53506: LIST
53507: PUSH
53508: LD_VAR 0 1
53512: PUSH
53513: LD_INT 4
53515: MINUS
53516: PUSH
53517: LD_VAR 0 2
53521: PUSH
53522: LD_INT 4
53524: MINUS
53525: PUSH
53526: LD_INT 2
53528: PUSH
53529: EMPTY
53530: LIST
53531: LIST
53532: LIST
53533: PUSH
53534: EMPTY
53535: LIST
53536: LIST
53537: LIST
53538: LIST
53539: LIST
53540: ST_TO_ADDR
// end ; 3 :
53541: GO 53963
53543: LD_INT 3
53545: DOUBLE
53546: EQUAL
53547: IFTRUE 53551
53549: GO 53684
53551: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
53552: LD_ADDR_VAR 0 5
53556: PUSH
53557: LD_VAR 0 1
53561: PUSH
53562: LD_INT 3
53564: PLUS
53565: PUSH
53566: LD_VAR 0 2
53570: PUSH
53571: LD_INT 4
53573: PUSH
53574: EMPTY
53575: LIST
53576: LIST
53577: LIST
53578: PUSH
53579: LD_VAR 0 1
53583: PUSH
53584: LD_INT 4
53586: PLUS
53587: PUSH
53588: LD_VAR 0 2
53592: PUSH
53593: LD_INT 4
53595: PLUS
53596: PUSH
53597: LD_INT 5
53599: PUSH
53600: EMPTY
53601: LIST
53602: LIST
53603: LIST
53604: PUSH
53605: LD_VAR 0 1
53609: PUSH
53610: LD_INT 4
53612: MINUS
53613: PUSH
53614: LD_VAR 0 2
53618: PUSH
53619: LD_INT 1
53621: PUSH
53622: EMPTY
53623: LIST
53624: LIST
53625: LIST
53626: PUSH
53627: LD_VAR 0 1
53631: PUSH
53632: LD_VAR 0 2
53636: PUSH
53637: LD_INT 4
53639: MINUS
53640: PUSH
53641: LD_INT 3
53643: PUSH
53644: EMPTY
53645: LIST
53646: LIST
53647: LIST
53648: PUSH
53649: LD_VAR 0 1
53653: PUSH
53654: LD_INT 3
53656: MINUS
53657: PUSH
53658: LD_VAR 0 2
53662: PUSH
53663: LD_INT 3
53665: MINUS
53666: PUSH
53667: LD_INT 2
53669: PUSH
53670: EMPTY
53671: LIST
53672: LIST
53673: LIST
53674: PUSH
53675: EMPTY
53676: LIST
53677: LIST
53678: LIST
53679: LIST
53680: LIST
53681: ST_TO_ADDR
// end ; 4 :
53682: GO 53963
53684: LD_INT 4
53686: DOUBLE
53687: EQUAL
53688: IFTRUE 53692
53690: GO 53825
53692: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
53693: LD_ADDR_VAR 0 5
53697: PUSH
53698: LD_VAR 0 1
53702: PUSH
53703: LD_VAR 0 2
53707: PUSH
53708: LD_INT 4
53710: PLUS
53711: PUSH
53712: LD_INT 0
53714: PUSH
53715: EMPTY
53716: LIST
53717: LIST
53718: LIST
53719: PUSH
53720: LD_VAR 0 1
53724: PUSH
53725: LD_INT 3
53727: PLUS
53728: PUSH
53729: LD_VAR 0 2
53733: PUSH
53734: LD_INT 3
53736: PLUS
53737: PUSH
53738: LD_INT 5
53740: PUSH
53741: EMPTY
53742: LIST
53743: LIST
53744: LIST
53745: PUSH
53746: LD_VAR 0 1
53750: PUSH
53751: LD_INT 4
53753: PLUS
53754: PUSH
53755: LD_VAR 0 2
53759: PUSH
53760: LD_INT 4
53762: PUSH
53763: EMPTY
53764: LIST
53765: LIST
53766: LIST
53767: PUSH
53768: LD_VAR 0 1
53772: PUSH
53773: LD_VAR 0 2
53777: PUSH
53778: LD_INT 3
53780: MINUS
53781: PUSH
53782: LD_INT 3
53784: PUSH
53785: EMPTY
53786: LIST
53787: LIST
53788: LIST
53789: PUSH
53790: LD_VAR 0 1
53794: PUSH
53795: LD_INT 4
53797: MINUS
53798: PUSH
53799: LD_VAR 0 2
53803: PUSH
53804: LD_INT 4
53806: MINUS
53807: PUSH
53808: LD_INT 2
53810: PUSH
53811: EMPTY
53812: LIST
53813: LIST
53814: LIST
53815: PUSH
53816: EMPTY
53817: LIST
53818: LIST
53819: LIST
53820: LIST
53821: LIST
53822: ST_TO_ADDR
// end ; 5 :
53823: GO 53963
53825: LD_INT 5
53827: DOUBLE
53828: EQUAL
53829: IFTRUE 53833
53831: GO 53962
53833: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
53834: LD_ADDR_VAR 0 5
53838: PUSH
53839: LD_VAR 0 1
53843: PUSH
53844: LD_INT 4
53846: MINUS
53847: PUSH
53848: LD_VAR 0 2
53852: PUSH
53853: LD_INT 1
53855: PUSH
53856: EMPTY
53857: LIST
53858: LIST
53859: LIST
53860: PUSH
53861: LD_VAR 0 1
53865: PUSH
53866: LD_VAR 0 2
53870: PUSH
53871: LD_INT 4
53873: MINUS
53874: PUSH
53875: LD_INT 3
53877: PUSH
53878: EMPTY
53879: LIST
53880: LIST
53881: LIST
53882: PUSH
53883: LD_VAR 0 1
53887: PUSH
53888: LD_INT 4
53890: PLUS
53891: PUSH
53892: LD_VAR 0 2
53896: PUSH
53897: LD_INT 4
53899: PLUS
53900: PUSH
53901: LD_INT 5
53903: PUSH
53904: EMPTY
53905: LIST
53906: LIST
53907: LIST
53908: PUSH
53909: LD_VAR 0 1
53913: PUSH
53914: LD_INT 3
53916: PLUS
53917: PUSH
53918: LD_VAR 0 2
53922: PUSH
53923: LD_INT 4
53925: PUSH
53926: EMPTY
53927: LIST
53928: LIST
53929: LIST
53930: PUSH
53931: LD_VAR 0 1
53935: PUSH
53936: LD_VAR 0 2
53940: PUSH
53941: LD_INT 3
53943: PLUS
53944: PUSH
53945: LD_INT 0
53947: PUSH
53948: EMPTY
53949: LIST
53950: LIST
53951: LIST
53952: PUSH
53953: EMPTY
53954: LIST
53955: LIST
53956: LIST
53957: LIST
53958: LIST
53959: ST_TO_ADDR
// end ; end ;
53960: GO 53963
53962: POP
// result := list ;
53963: LD_ADDR_VAR 0 4
53967: PUSH
53968: LD_VAR 0 5
53972: ST_TO_ADDR
// end ;
53973: LD_VAR 0 4
53977: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
53978: LD_INT 0
53980: PPUSH
53981: PPUSH
53982: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
53983: LD_VAR 0 1
53987: NOT
53988: PUSH
53989: LD_VAR 0 2
53993: PUSH
53994: LD_INT 1
53996: PUSH
53997: LD_INT 2
53999: PUSH
54000: LD_INT 3
54002: PUSH
54003: LD_INT 4
54005: PUSH
54006: EMPTY
54007: LIST
54008: LIST
54009: LIST
54010: LIST
54011: IN
54012: NOT
54013: OR
54014: IFFALSE 54018
// exit ;
54016: GO 54110
// tmp := [ ] ;
54018: LD_ADDR_VAR 0 5
54022: PUSH
54023: EMPTY
54024: ST_TO_ADDR
// for i in units do
54025: LD_ADDR_VAR 0 4
54029: PUSH
54030: LD_VAR 0 1
54034: PUSH
54035: FOR_IN
54036: IFFALSE 54079
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
54038: LD_ADDR_VAR 0 5
54042: PUSH
54043: LD_VAR 0 5
54047: PPUSH
54048: LD_VAR 0 5
54052: PUSH
54053: LD_INT 1
54055: PLUS
54056: PPUSH
54057: LD_VAR 0 4
54061: PPUSH
54062: LD_VAR 0 2
54066: PPUSH
54067: CALL_OW 259
54071: PPUSH
54072: CALL_OW 2
54076: ST_TO_ADDR
54077: GO 54035
54079: POP
54080: POP
// if not tmp then
54081: LD_VAR 0 5
54085: NOT
54086: IFFALSE 54090
// exit ;
54088: GO 54110
// result := SortListByListDesc ( units , tmp ) ;
54090: LD_ADDR_VAR 0 3
54094: PUSH
54095: LD_VAR 0 1
54099: PPUSH
54100: LD_VAR 0 5
54104: PPUSH
54105: CALL_OW 77
54109: ST_TO_ADDR
// end ;
54110: LD_VAR 0 3
54114: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
54115: LD_INT 0
54117: PPUSH
54118: PPUSH
54119: PPUSH
// result := false ;
54120: LD_ADDR_VAR 0 3
54124: PUSH
54125: LD_INT 0
54127: ST_TO_ADDR
// x := GetX ( building ) ;
54128: LD_ADDR_VAR 0 4
54132: PUSH
54133: LD_VAR 0 2
54137: PPUSH
54138: CALL_OW 250
54142: ST_TO_ADDR
// y := GetY ( building ) ;
54143: LD_ADDR_VAR 0 5
54147: PUSH
54148: LD_VAR 0 2
54152: PPUSH
54153: CALL_OW 251
54157: ST_TO_ADDR
// if not building or not x or not y then
54158: LD_VAR 0 2
54162: NOT
54163: PUSH
54164: LD_VAR 0 4
54168: NOT
54169: OR
54170: PUSH
54171: LD_VAR 0 5
54175: NOT
54176: OR
54177: IFFALSE 54181
// exit ;
54179: GO 54273
// if GetTaskList ( unit ) then
54181: LD_VAR 0 1
54185: PPUSH
54186: CALL_OW 437
54190: IFFALSE 54273
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
54192: LD_STRING e
54194: PUSH
54195: LD_VAR 0 1
54199: PPUSH
54200: CALL_OW 437
54204: PUSH
54205: LD_INT 1
54207: ARRAY
54208: PUSH
54209: LD_INT 1
54211: ARRAY
54212: EQUAL
54213: PUSH
54214: LD_VAR 0 4
54218: PUSH
54219: LD_VAR 0 1
54223: PPUSH
54224: CALL_OW 437
54228: PUSH
54229: LD_INT 1
54231: ARRAY
54232: PUSH
54233: LD_INT 2
54235: ARRAY
54236: EQUAL
54237: AND
54238: PUSH
54239: LD_VAR 0 5
54243: PUSH
54244: LD_VAR 0 1
54248: PPUSH
54249: CALL_OW 437
54253: PUSH
54254: LD_INT 1
54256: ARRAY
54257: PUSH
54258: LD_INT 3
54260: ARRAY
54261: EQUAL
54262: AND
54263: IFFALSE 54273
// result := true end ;
54265: LD_ADDR_VAR 0 3
54269: PUSH
54270: LD_INT 1
54272: ST_TO_ADDR
// end ;
54273: LD_VAR 0 3
54277: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
54278: LD_INT 0
54280: PPUSH
// result := false ;
54281: LD_ADDR_VAR 0 4
54285: PUSH
54286: LD_INT 0
54288: ST_TO_ADDR
// if GetTaskList ( unit ) then
54289: LD_VAR 0 1
54293: PPUSH
54294: CALL_OW 437
54298: IFFALSE 54381
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
54300: LD_STRING M
54302: PUSH
54303: LD_VAR 0 1
54307: PPUSH
54308: CALL_OW 437
54312: PUSH
54313: LD_INT 1
54315: ARRAY
54316: PUSH
54317: LD_INT 1
54319: ARRAY
54320: EQUAL
54321: PUSH
54322: LD_VAR 0 2
54326: PUSH
54327: LD_VAR 0 1
54331: PPUSH
54332: CALL_OW 437
54336: PUSH
54337: LD_INT 1
54339: ARRAY
54340: PUSH
54341: LD_INT 2
54343: ARRAY
54344: EQUAL
54345: AND
54346: PUSH
54347: LD_VAR 0 3
54351: PUSH
54352: LD_VAR 0 1
54356: PPUSH
54357: CALL_OW 437
54361: PUSH
54362: LD_INT 1
54364: ARRAY
54365: PUSH
54366: LD_INT 3
54368: ARRAY
54369: EQUAL
54370: AND
54371: IFFALSE 54381
// result := true ;
54373: LD_ADDR_VAR 0 4
54377: PUSH
54378: LD_INT 1
54380: ST_TO_ADDR
// end ; end ;
54381: LD_VAR 0 4
54385: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
54386: LD_INT 0
54388: PPUSH
54389: PPUSH
54390: PPUSH
54391: PPUSH
// if not unit or not area then
54392: LD_VAR 0 1
54396: NOT
54397: PUSH
54398: LD_VAR 0 2
54402: NOT
54403: OR
54404: IFFALSE 54408
// exit ;
54406: GO 54572
// tmp := AreaToList ( area , i ) ;
54408: LD_ADDR_VAR 0 6
54412: PUSH
54413: LD_VAR 0 2
54417: PPUSH
54418: LD_VAR 0 5
54422: PPUSH
54423: CALL_OW 517
54427: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
54428: LD_ADDR_VAR 0 5
54432: PUSH
54433: DOUBLE
54434: LD_INT 1
54436: DEC
54437: ST_TO_ADDR
54438: LD_VAR 0 6
54442: PUSH
54443: LD_INT 1
54445: ARRAY
54446: PUSH
54447: FOR_TO
54448: IFFALSE 54570
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
54450: LD_ADDR_VAR 0 7
54454: PUSH
54455: LD_VAR 0 6
54459: PUSH
54460: LD_INT 1
54462: ARRAY
54463: PUSH
54464: LD_VAR 0 5
54468: ARRAY
54469: PUSH
54470: LD_VAR 0 6
54474: PUSH
54475: LD_INT 2
54477: ARRAY
54478: PUSH
54479: LD_VAR 0 5
54483: ARRAY
54484: PUSH
54485: EMPTY
54486: LIST
54487: LIST
54488: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
54489: LD_VAR 0 7
54493: PUSH
54494: LD_INT 1
54496: ARRAY
54497: PPUSH
54498: LD_VAR 0 7
54502: PUSH
54503: LD_INT 2
54505: ARRAY
54506: PPUSH
54507: CALL_OW 428
54511: PUSH
54512: LD_INT 0
54514: EQUAL
54515: IFFALSE 54568
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
54517: LD_VAR 0 1
54521: PPUSH
54522: LD_VAR 0 7
54526: PUSH
54527: LD_INT 1
54529: ARRAY
54530: PPUSH
54531: LD_VAR 0 7
54535: PUSH
54536: LD_INT 2
54538: ARRAY
54539: PPUSH
54540: LD_VAR 0 3
54544: PPUSH
54545: CALL_OW 48
// result := IsPlaced ( unit ) ;
54549: LD_ADDR_VAR 0 4
54553: PUSH
54554: LD_VAR 0 1
54558: PPUSH
54559: CALL_OW 305
54563: ST_TO_ADDR
// exit ;
54564: POP
54565: POP
54566: GO 54572
// end ; end ;
54568: GO 54447
54570: POP
54571: POP
// end ;
54572: LD_VAR 0 4
54576: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
54577: LD_INT 0
54579: PPUSH
54580: PPUSH
54581: PPUSH
// if not side or side > 8 then
54582: LD_VAR 0 1
54586: NOT
54587: PUSH
54588: LD_VAR 0 1
54592: PUSH
54593: LD_INT 8
54595: GREATER
54596: OR
54597: IFFALSE 54601
// exit ;
54599: GO 54788
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
54601: LD_ADDR_VAR 0 4
54605: PUSH
54606: LD_INT 22
54608: PUSH
54609: LD_VAR 0 1
54613: PUSH
54614: EMPTY
54615: LIST
54616: LIST
54617: PUSH
54618: LD_INT 21
54620: PUSH
54621: LD_INT 3
54623: PUSH
54624: EMPTY
54625: LIST
54626: LIST
54627: PUSH
54628: EMPTY
54629: LIST
54630: LIST
54631: PPUSH
54632: CALL_OW 69
54636: ST_TO_ADDR
// if not tmp then
54637: LD_VAR 0 4
54641: NOT
54642: IFFALSE 54646
// exit ;
54644: GO 54788
// enable_addtolog := true ;
54646: LD_ADDR_OWVAR 81
54650: PUSH
54651: LD_INT 1
54653: ST_TO_ADDR
// AddToLog ( [ ) ;
54654: LD_STRING [
54656: PPUSH
54657: CALL_OW 561
// for i in tmp do
54661: LD_ADDR_VAR 0 3
54665: PUSH
54666: LD_VAR 0 4
54670: PUSH
54671: FOR_IN
54672: IFFALSE 54779
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
54674: LD_STRING [
54676: PUSH
54677: LD_VAR 0 3
54681: PPUSH
54682: CALL_OW 266
54686: STR
54687: PUSH
54688: LD_STRING , 
54690: STR
54691: PUSH
54692: LD_VAR 0 3
54696: PPUSH
54697: CALL_OW 250
54701: STR
54702: PUSH
54703: LD_STRING , 
54705: STR
54706: PUSH
54707: LD_VAR 0 3
54711: PPUSH
54712: CALL_OW 251
54716: STR
54717: PUSH
54718: LD_STRING , 
54720: STR
54721: PUSH
54722: LD_VAR 0 3
54726: PPUSH
54727: CALL_OW 254
54731: STR
54732: PUSH
54733: LD_STRING , 
54735: STR
54736: PUSH
54737: LD_VAR 0 3
54741: PPUSH
54742: LD_INT 1
54744: PPUSH
54745: CALL_OW 268
54749: STR
54750: PUSH
54751: LD_STRING , 
54753: STR
54754: PUSH
54755: LD_VAR 0 3
54759: PPUSH
54760: LD_INT 2
54762: PPUSH
54763: CALL_OW 268
54767: STR
54768: PUSH
54769: LD_STRING ],
54771: STR
54772: PPUSH
54773: CALL_OW 561
// end ;
54777: GO 54671
54779: POP
54780: POP
// AddToLog ( ]; ) ;
54781: LD_STRING ];
54783: PPUSH
54784: CALL_OW 561
// end ;
54788: LD_VAR 0 2
54792: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
54793: LD_INT 0
54795: PPUSH
54796: PPUSH
54797: PPUSH
54798: PPUSH
54799: PPUSH
// if not area or not rate or not max then
54800: LD_VAR 0 1
54804: NOT
54805: PUSH
54806: LD_VAR 0 2
54810: NOT
54811: OR
54812: PUSH
54813: LD_VAR 0 4
54817: NOT
54818: OR
54819: IFFALSE 54823
// exit ;
54821: GO 55015
// while 1 do
54823: LD_INT 1
54825: IFFALSE 55015
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
54827: LD_ADDR_VAR 0 9
54831: PUSH
54832: LD_VAR 0 1
54836: PPUSH
54837: LD_INT 1
54839: PPUSH
54840: CALL_OW 287
54844: PUSH
54845: LD_INT 10
54847: MUL
54848: ST_TO_ADDR
// r := rate / 10 ;
54849: LD_ADDR_VAR 0 7
54853: PUSH
54854: LD_VAR 0 2
54858: PUSH
54859: LD_INT 10
54861: DIVREAL
54862: ST_TO_ADDR
// time := 1 1$00 ;
54863: LD_ADDR_VAR 0 8
54867: PUSH
54868: LD_INT 2100
54870: ST_TO_ADDR
// if amount < min then
54871: LD_VAR 0 9
54875: PUSH
54876: LD_VAR 0 3
54880: LESS
54881: IFFALSE 54899
// r := r * 2 else
54883: LD_ADDR_VAR 0 7
54887: PUSH
54888: LD_VAR 0 7
54892: PUSH
54893: LD_INT 2
54895: MUL
54896: ST_TO_ADDR
54897: GO 54925
// if amount > max then
54899: LD_VAR 0 9
54903: PUSH
54904: LD_VAR 0 4
54908: GREATER
54909: IFFALSE 54925
// r := r / 2 ;
54911: LD_ADDR_VAR 0 7
54915: PUSH
54916: LD_VAR 0 7
54920: PUSH
54921: LD_INT 2
54923: DIVREAL
54924: ST_TO_ADDR
// time := time / r ;
54925: LD_ADDR_VAR 0 8
54929: PUSH
54930: LD_VAR 0 8
54934: PUSH
54935: LD_VAR 0 7
54939: DIVREAL
54940: ST_TO_ADDR
// if time < 0 then
54941: LD_VAR 0 8
54945: PUSH
54946: LD_INT 0
54948: LESS
54949: IFFALSE 54966
// time := time * - 1 ;
54951: LD_ADDR_VAR 0 8
54955: PUSH
54956: LD_VAR 0 8
54960: PUSH
54961: LD_INT 1
54963: NEG
54964: MUL
54965: ST_TO_ADDR
// wait ( time ) ;
54966: LD_VAR 0 8
54970: PPUSH
54971: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
54975: LD_INT 35
54977: PPUSH
54978: LD_INT 875
54980: PPUSH
54981: CALL_OW 12
54985: PPUSH
54986: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
54990: LD_INT 1
54992: PPUSH
54993: LD_INT 5
54995: PPUSH
54996: CALL_OW 12
55000: PPUSH
55001: LD_VAR 0 1
55005: PPUSH
55006: LD_INT 1
55008: PPUSH
55009: CALL_OW 55
// end ;
55013: GO 54823
// end ;
55015: LD_VAR 0 5
55019: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
55020: LD_INT 0
55022: PPUSH
55023: PPUSH
55024: PPUSH
55025: PPUSH
55026: PPUSH
55027: PPUSH
55028: PPUSH
55029: PPUSH
// if not turrets or not factories then
55030: LD_VAR 0 1
55034: NOT
55035: PUSH
55036: LD_VAR 0 2
55040: NOT
55041: OR
55042: IFFALSE 55046
// exit ;
55044: GO 55353
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
55046: LD_ADDR_VAR 0 10
55050: PUSH
55051: LD_INT 5
55053: PUSH
55054: LD_INT 6
55056: PUSH
55057: EMPTY
55058: LIST
55059: LIST
55060: PUSH
55061: LD_INT 2
55063: PUSH
55064: LD_INT 4
55066: PUSH
55067: EMPTY
55068: LIST
55069: LIST
55070: PUSH
55071: LD_INT 3
55073: PUSH
55074: LD_INT 5
55076: PUSH
55077: EMPTY
55078: LIST
55079: LIST
55080: PUSH
55081: EMPTY
55082: LIST
55083: LIST
55084: LIST
55085: PUSH
55086: LD_INT 24
55088: PUSH
55089: LD_INT 25
55091: PUSH
55092: EMPTY
55093: LIST
55094: LIST
55095: PUSH
55096: LD_INT 23
55098: PUSH
55099: LD_INT 27
55101: PUSH
55102: EMPTY
55103: LIST
55104: LIST
55105: PUSH
55106: EMPTY
55107: LIST
55108: LIST
55109: PUSH
55110: LD_INT 42
55112: PUSH
55113: LD_INT 43
55115: PUSH
55116: EMPTY
55117: LIST
55118: LIST
55119: PUSH
55120: LD_INT 44
55122: PUSH
55123: LD_INT 46
55125: PUSH
55126: EMPTY
55127: LIST
55128: LIST
55129: PUSH
55130: LD_INT 45
55132: PUSH
55133: LD_INT 47
55135: PUSH
55136: EMPTY
55137: LIST
55138: LIST
55139: PUSH
55140: EMPTY
55141: LIST
55142: LIST
55143: LIST
55144: PUSH
55145: EMPTY
55146: LIST
55147: LIST
55148: LIST
55149: ST_TO_ADDR
// result := [ ] ;
55150: LD_ADDR_VAR 0 3
55154: PUSH
55155: EMPTY
55156: ST_TO_ADDR
// for i in turrets do
55157: LD_ADDR_VAR 0 4
55161: PUSH
55162: LD_VAR 0 1
55166: PUSH
55167: FOR_IN
55168: IFFALSE 55351
// begin nat := GetNation ( i ) ;
55170: LD_ADDR_VAR 0 7
55174: PUSH
55175: LD_VAR 0 4
55179: PPUSH
55180: CALL_OW 248
55184: ST_TO_ADDR
// weapon := 0 ;
55185: LD_ADDR_VAR 0 8
55189: PUSH
55190: LD_INT 0
55192: ST_TO_ADDR
// if not nat then
55193: LD_VAR 0 7
55197: NOT
55198: IFFALSE 55202
// continue ;
55200: GO 55167
// for j in list [ nat ] do
55202: LD_ADDR_VAR 0 5
55206: PUSH
55207: LD_VAR 0 10
55211: PUSH
55212: LD_VAR 0 7
55216: ARRAY
55217: PUSH
55218: FOR_IN
55219: IFFALSE 55260
// if GetBWeapon ( i ) = j [ 1 ] then
55221: LD_VAR 0 4
55225: PPUSH
55226: CALL_OW 269
55230: PUSH
55231: LD_VAR 0 5
55235: PUSH
55236: LD_INT 1
55238: ARRAY
55239: EQUAL
55240: IFFALSE 55258
// begin weapon := j [ 2 ] ;
55242: LD_ADDR_VAR 0 8
55246: PUSH
55247: LD_VAR 0 5
55251: PUSH
55252: LD_INT 2
55254: ARRAY
55255: ST_TO_ADDR
// break ;
55256: GO 55260
// end ;
55258: GO 55218
55260: POP
55261: POP
// if not weapon then
55262: LD_VAR 0 8
55266: NOT
55267: IFFALSE 55271
// continue ;
55269: GO 55167
// for k in factories do
55271: LD_ADDR_VAR 0 6
55275: PUSH
55276: LD_VAR 0 2
55280: PUSH
55281: FOR_IN
55282: IFFALSE 55347
// begin weapons := AvailableWeaponList ( k ) ;
55284: LD_ADDR_VAR 0 9
55288: PUSH
55289: LD_VAR 0 6
55293: PPUSH
55294: CALL_OW 478
55298: ST_TO_ADDR
// if not weapons then
55299: LD_VAR 0 9
55303: NOT
55304: IFFALSE 55308
// continue ;
55306: GO 55281
// if weapon in weapons then
55308: LD_VAR 0 8
55312: PUSH
55313: LD_VAR 0 9
55317: IN
55318: IFFALSE 55345
// begin result := [ i , weapon ] ;
55320: LD_ADDR_VAR 0 3
55324: PUSH
55325: LD_VAR 0 4
55329: PUSH
55330: LD_VAR 0 8
55334: PUSH
55335: EMPTY
55336: LIST
55337: LIST
55338: ST_TO_ADDR
// exit ;
55339: POP
55340: POP
55341: POP
55342: POP
55343: GO 55353
// end ; end ;
55345: GO 55281
55347: POP
55348: POP
// end ;
55349: GO 55167
55351: POP
55352: POP
// end ;
55353: LD_VAR 0 3
55357: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
55358: LD_INT 0
55360: PPUSH
// if not side or side > 8 then
55361: LD_VAR 0 3
55365: NOT
55366: PUSH
55367: LD_VAR 0 3
55371: PUSH
55372: LD_INT 8
55374: GREATER
55375: OR
55376: IFFALSE 55380
// exit ;
55378: GO 55439
// if not range then
55380: LD_VAR 0 4
55384: NOT
55385: IFFALSE 55396
// range := - 12 ;
55387: LD_ADDR_VAR 0 4
55391: PUSH
55392: LD_INT 12
55394: NEG
55395: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
55396: LD_VAR 0 1
55400: PPUSH
55401: LD_VAR 0 2
55405: PPUSH
55406: LD_VAR 0 3
55410: PPUSH
55411: LD_VAR 0 4
55415: PPUSH
55416: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
55420: LD_VAR 0 1
55424: PPUSH
55425: LD_VAR 0 2
55429: PPUSH
55430: LD_VAR 0 3
55434: PPUSH
55435: CALL_OW 331
// end ;
55439: LD_VAR 0 5
55443: RET
// export function Video ( mode ) ; begin
55444: LD_INT 0
55446: PPUSH
// ingame_video = mode ;
55447: LD_ADDR_OWVAR 52
55451: PUSH
55452: LD_VAR 0 1
55456: ST_TO_ADDR
// interface_hidden = mode ;
55457: LD_ADDR_OWVAR 54
55461: PUSH
55462: LD_VAR 0 1
55466: ST_TO_ADDR
// end ;
55467: LD_VAR 0 2
55471: RET
// export function Join ( array , element ) ; begin
55472: LD_INT 0
55474: PPUSH
// result := Replace ( array , array + 1 , element ) ;
55475: LD_ADDR_VAR 0 3
55479: PUSH
55480: LD_VAR 0 1
55484: PPUSH
55485: LD_VAR 0 1
55489: PUSH
55490: LD_INT 1
55492: PLUS
55493: PPUSH
55494: LD_VAR 0 2
55498: PPUSH
55499: CALL_OW 1
55503: ST_TO_ADDR
// end ;
55504: LD_VAR 0 3
55508: RET
// export function JoinUnion ( array , element ) ; begin
55509: LD_INT 0
55511: PPUSH
// result := array union element ;
55512: LD_ADDR_VAR 0 3
55516: PUSH
55517: LD_VAR 0 1
55521: PUSH
55522: LD_VAR 0 2
55526: UNION
55527: ST_TO_ADDR
// end ;
55528: LD_VAR 0 3
55532: RET
// export function GetBehemoths ( side ) ; begin
55533: LD_INT 0
55535: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
55536: LD_ADDR_VAR 0 2
55540: PUSH
55541: LD_INT 22
55543: PUSH
55544: LD_VAR 0 1
55548: PUSH
55549: EMPTY
55550: LIST
55551: LIST
55552: PUSH
55553: LD_INT 31
55555: PUSH
55556: LD_INT 25
55558: PUSH
55559: EMPTY
55560: LIST
55561: LIST
55562: PUSH
55563: EMPTY
55564: LIST
55565: LIST
55566: PPUSH
55567: CALL_OW 69
55571: ST_TO_ADDR
// end ;
55572: LD_VAR 0 2
55576: RET
// export function Shuffle ( array ) ; var i , index ; begin
55577: LD_INT 0
55579: PPUSH
55580: PPUSH
55581: PPUSH
// result := [ ] ;
55582: LD_ADDR_VAR 0 2
55586: PUSH
55587: EMPTY
55588: ST_TO_ADDR
// if not array then
55589: LD_VAR 0 1
55593: NOT
55594: IFFALSE 55598
// exit ;
55596: GO 55697
// Randomize ;
55598: CALL_OW 10
// for i = array downto 1 do
55602: LD_ADDR_VAR 0 3
55606: PUSH
55607: DOUBLE
55608: LD_VAR 0 1
55612: INC
55613: ST_TO_ADDR
55614: LD_INT 1
55616: PUSH
55617: FOR_DOWNTO
55618: IFFALSE 55695
// begin index := rand ( 1 , array ) ;
55620: LD_ADDR_VAR 0 4
55624: PUSH
55625: LD_INT 1
55627: PPUSH
55628: LD_VAR 0 1
55632: PPUSH
55633: CALL_OW 12
55637: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
55638: LD_ADDR_VAR 0 2
55642: PUSH
55643: LD_VAR 0 2
55647: PPUSH
55648: LD_VAR 0 2
55652: PUSH
55653: LD_INT 1
55655: PLUS
55656: PPUSH
55657: LD_VAR 0 1
55661: PUSH
55662: LD_VAR 0 4
55666: ARRAY
55667: PPUSH
55668: CALL_OW 2
55672: ST_TO_ADDR
// array := Delete ( array , index ) ;
55673: LD_ADDR_VAR 0 1
55677: PUSH
55678: LD_VAR 0 1
55682: PPUSH
55683: LD_VAR 0 4
55687: PPUSH
55688: CALL_OW 3
55692: ST_TO_ADDR
// end ;
55693: GO 55617
55695: POP
55696: POP
// end ;
55697: LD_VAR 0 2
55701: RET
// export function GetBaseMaterials ( base ) ; begin
55702: LD_INT 0
55704: PPUSH
// result := [ 0 , 0 , 0 ] ;
55705: LD_ADDR_VAR 0 2
55709: PUSH
55710: LD_INT 0
55712: PUSH
55713: LD_INT 0
55715: PUSH
55716: LD_INT 0
55718: PUSH
55719: EMPTY
55720: LIST
55721: LIST
55722: LIST
55723: ST_TO_ADDR
// if not base then
55724: LD_VAR 0 1
55728: NOT
55729: IFFALSE 55733
// exit ;
55731: GO 55782
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
55733: LD_ADDR_VAR 0 2
55737: PUSH
55738: LD_VAR 0 1
55742: PPUSH
55743: LD_INT 1
55745: PPUSH
55746: CALL_OW 275
55750: PUSH
55751: LD_VAR 0 1
55755: PPUSH
55756: LD_INT 2
55758: PPUSH
55759: CALL_OW 275
55763: PUSH
55764: LD_VAR 0 1
55768: PPUSH
55769: LD_INT 3
55771: PPUSH
55772: CALL_OW 275
55776: PUSH
55777: EMPTY
55778: LIST
55779: LIST
55780: LIST
55781: ST_TO_ADDR
// end ;
55782: LD_VAR 0 2
55786: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
55787: LD_INT 0
55789: PPUSH
55790: PPUSH
// result := array ;
55791: LD_ADDR_VAR 0 3
55795: PUSH
55796: LD_VAR 0 1
55800: ST_TO_ADDR
// if size > 0 then
55801: LD_VAR 0 2
55805: PUSH
55806: LD_INT 0
55808: GREATER
55809: IFFALSE 55855
// for i := array downto size do
55811: LD_ADDR_VAR 0 4
55815: PUSH
55816: DOUBLE
55817: LD_VAR 0 1
55821: INC
55822: ST_TO_ADDR
55823: LD_VAR 0 2
55827: PUSH
55828: FOR_DOWNTO
55829: IFFALSE 55853
// result := Delete ( result , result ) ;
55831: LD_ADDR_VAR 0 3
55835: PUSH
55836: LD_VAR 0 3
55840: PPUSH
55841: LD_VAR 0 3
55845: PPUSH
55846: CALL_OW 3
55850: ST_TO_ADDR
55851: GO 55828
55853: POP
55854: POP
// end ;
55855: LD_VAR 0 3
55859: RET
// export function ComExit ( unit ) ; var tmp ; begin
55860: LD_INT 0
55862: PPUSH
55863: PPUSH
// if not IsInUnit ( unit ) then
55864: LD_VAR 0 1
55868: PPUSH
55869: CALL_OW 310
55873: NOT
55874: IFFALSE 55878
// exit ;
55876: GO 55938
// tmp := IsInUnit ( unit ) ;
55878: LD_ADDR_VAR 0 3
55882: PUSH
55883: LD_VAR 0 1
55887: PPUSH
55888: CALL_OW 310
55892: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
55893: LD_VAR 0 3
55897: PPUSH
55898: CALL_OW 247
55902: PUSH
55903: LD_INT 2
55905: EQUAL
55906: IFFALSE 55919
// ComExitVehicle ( unit ) else
55908: LD_VAR 0 1
55912: PPUSH
55913: CALL_OW 121
55917: GO 55928
// ComExitBuilding ( unit ) ;
55919: LD_VAR 0 1
55923: PPUSH
55924: CALL_OW 122
// result := tmp ;
55928: LD_ADDR_VAR 0 2
55932: PUSH
55933: LD_VAR 0 3
55937: ST_TO_ADDR
// end ;
55938: LD_VAR 0 2
55942: RET
// export function ComExitAll ( units ) ; var i ; begin
55943: LD_INT 0
55945: PPUSH
55946: PPUSH
// if not units then
55947: LD_VAR 0 1
55951: NOT
55952: IFFALSE 55956
// exit ;
55954: GO 55982
// for i in units do
55956: LD_ADDR_VAR 0 3
55960: PUSH
55961: LD_VAR 0 1
55965: PUSH
55966: FOR_IN
55967: IFFALSE 55980
// ComExit ( i ) ;
55969: LD_VAR 0 3
55973: PPUSH
55974: CALL 55860 0 1
55978: GO 55966
55980: POP
55981: POP
// end ;
55982: LD_VAR 0 2
55986: RET
// export function ResetHc ; begin
55987: LD_INT 0
55989: PPUSH
// InitHc ;
55990: CALL_OW 19
// hc_importance := 0 ;
55994: LD_ADDR_OWVAR 32
55998: PUSH
55999: LD_INT 0
56001: ST_TO_ADDR
// end ;
56002: LD_VAR 0 1
56006: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
56007: LD_INT 0
56009: PPUSH
56010: PPUSH
56011: PPUSH
// _x := ( x1 + x2 ) div 2 ;
56012: LD_ADDR_VAR 0 6
56016: PUSH
56017: LD_VAR 0 1
56021: PUSH
56022: LD_VAR 0 3
56026: PLUS
56027: PUSH
56028: LD_INT 2
56030: DIV
56031: ST_TO_ADDR
// if _x < 0 then
56032: LD_VAR 0 6
56036: PUSH
56037: LD_INT 0
56039: LESS
56040: IFFALSE 56057
// _x := _x * - 1 ;
56042: LD_ADDR_VAR 0 6
56046: PUSH
56047: LD_VAR 0 6
56051: PUSH
56052: LD_INT 1
56054: NEG
56055: MUL
56056: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
56057: LD_ADDR_VAR 0 7
56061: PUSH
56062: LD_VAR 0 2
56066: PUSH
56067: LD_VAR 0 4
56071: PLUS
56072: PUSH
56073: LD_INT 2
56075: DIV
56076: ST_TO_ADDR
// if _y < 0 then
56077: LD_VAR 0 7
56081: PUSH
56082: LD_INT 0
56084: LESS
56085: IFFALSE 56102
// _y := _y * - 1 ;
56087: LD_ADDR_VAR 0 7
56091: PUSH
56092: LD_VAR 0 7
56096: PUSH
56097: LD_INT 1
56099: NEG
56100: MUL
56101: ST_TO_ADDR
// result := [ _x , _y ] ;
56102: LD_ADDR_VAR 0 5
56106: PUSH
56107: LD_VAR 0 6
56111: PUSH
56112: LD_VAR 0 7
56116: PUSH
56117: EMPTY
56118: LIST
56119: LIST
56120: ST_TO_ADDR
// end ;
56121: LD_VAR 0 5
56125: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
56126: LD_INT 0
56128: PPUSH
56129: PPUSH
56130: PPUSH
56131: PPUSH
// task := GetTaskList ( unit ) ;
56132: LD_ADDR_VAR 0 7
56136: PUSH
56137: LD_VAR 0 1
56141: PPUSH
56142: CALL_OW 437
56146: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
56147: LD_VAR 0 7
56151: NOT
56152: PUSH
56153: LD_VAR 0 1
56157: PPUSH
56158: LD_VAR 0 2
56162: PPUSH
56163: CALL_OW 308
56167: NOT
56168: AND
56169: IFFALSE 56173
// exit ;
56171: GO 56291
// if IsInArea ( unit , area ) then
56173: LD_VAR 0 1
56177: PPUSH
56178: LD_VAR 0 2
56182: PPUSH
56183: CALL_OW 308
56187: IFFALSE 56205
// begin ComMoveToArea ( unit , goAway ) ;
56189: LD_VAR 0 1
56193: PPUSH
56194: LD_VAR 0 3
56198: PPUSH
56199: CALL_OW 113
// exit ;
56203: GO 56291
// end ; if task [ 1 ] [ 1 ] <> M then
56205: LD_VAR 0 7
56209: PUSH
56210: LD_INT 1
56212: ARRAY
56213: PUSH
56214: LD_INT 1
56216: ARRAY
56217: PUSH
56218: LD_STRING M
56220: NONEQUAL
56221: IFFALSE 56225
// exit ;
56223: GO 56291
// x := task [ 1 ] [ 2 ] ;
56225: LD_ADDR_VAR 0 5
56229: PUSH
56230: LD_VAR 0 7
56234: PUSH
56235: LD_INT 1
56237: ARRAY
56238: PUSH
56239: LD_INT 2
56241: ARRAY
56242: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
56243: LD_ADDR_VAR 0 6
56247: PUSH
56248: LD_VAR 0 7
56252: PUSH
56253: LD_INT 1
56255: ARRAY
56256: PUSH
56257: LD_INT 3
56259: ARRAY
56260: ST_TO_ADDR
// if InArea ( x , y , area ) then
56261: LD_VAR 0 5
56265: PPUSH
56266: LD_VAR 0 6
56270: PPUSH
56271: LD_VAR 0 2
56275: PPUSH
56276: CALL_OW 309
56280: IFFALSE 56291
// ComStop ( unit ) ;
56282: LD_VAR 0 1
56286: PPUSH
56287: CALL_OW 141
// end ;
56291: LD_VAR 0 4
56295: RET
// export function Abs ( value ) ; begin
56296: LD_INT 0
56298: PPUSH
// result := value ;
56299: LD_ADDR_VAR 0 2
56303: PUSH
56304: LD_VAR 0 1
56308: ST_TO_ADDR
// if value < 0 then
56309: LD_VAR 0 1
56313: PUSH
56314: LD_INT 0
56316: LESS
56317: IFFALSE 56334
// result := value * - 1 ;
56319: LD_ADDR_VAR 0 2
56323: PUSH
56324: LD_VAR 0 1
56328: PUSH
56329: LD_INT 1
56331: NEG
56332: MUL
56333: ST_TO_ADDR
// end ;
56334: LD_VAR 0 2
56338: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
56339: LD_INT 0
56341: PPUSH
56342: PPUSH
56343: PPUSH
56344: PPUSH
56345: PPUSH
56346: PPUSH
56347: PPUSH
56348: PPUSH
// if not unit or not building then
56349: LD_VAR 0 1
56353: NOT
56354: PUSH
56355: LD_VAR 0 2
56359: NOT
56360: OR
56361: IFFALSE 56365
// exit ;
56363: GO 56591
// x := GetX ( building ) ;
56365: LD_ADDR_VAR 0 4
56369: PUSH
56370: LD_VAR 0 2
56374: PPUSH
56375: CALL_OW 250
56379: ST_TO_ADDR
// y := GetY ( building ) ;
56380: LD_ADDR_VAR 0 6
56384: PUSH
56385: LD_VAR 0 2
56389: PPUSH
56390: CALL_OW 251
56394: ST_TO_ADDR
// d := GetDir ( building ) ;
56395: LD_ADDR_VAR 0 8
56399: PUSH
56400: LD_VAR 0 2
56404: PPUSH
56405: CALL_OW 254
56409: ST_TO_ADDR
// r := 4 ;
56410: LD_ADDR_VAR 0 9
56414: PUSH
56415: LD_INT 4
56417: ST_TO_ADDR
// for i := 1 to 5 do
56418: LD_ADDR_VAR 0 10
56422: PUSH
56423: DOUBLE
56424: LD_INT 1
56426: DEC
56427: ST_TO_ADDR
56428: LD_INT 5
56430: PUSH
56431: FOR_TO
56432: IFFALSE 56589
// begin _x := ShiftX ( x , d , r + i ) ;
56434: LD_ADDR_VAR 0 5
56438: PUSH
56439: LD_VAR 0 4
56443: PPUSH
56444: LD_VAR 0 8
56448: PPUSH
56449: LD_VAR 0 9
56453: PUSH
56454: LD_VAR 0 10
56458: PLUS
56459: PPUSH
56460: CALL_OW 272
56464: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
56465: LD_ADDR_VAR 0 7
56469: PUSH
56470: LD_VAR 0 6
56474: PPUSH
56475: LD_VAR 0 8
56479: PPUSH
56480: LD_VAR 0 9
56484: PUSH
56485: LD_VAR 0 10
56489: PLUS
56490: PPUSH
56491: CALL_OW 273
56495: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
56496: LD_VAR 0 5
56500: PPUSH
56501: LD_VAR 0 7
56505: PPUSH
56506: CALL_OW 488
56510: PUSH
56511: LD_VAR 0 5
56515: PPUSH
56516: LD_VAR 0 7
56520: PPUSH
56521: CALL_OW 428
56525: PPUSH
56526: CALL_OW 247
56530: PUSH
56531: LD_INT 3
56533: PUSH
56534: LD_INT 2
56536: PUSH
56537: EMPTY
56538: LIST
56539: LIST
56540: IN
56541: NOT
56542: AND
56543: IFFALSE 56587
// begin ComMoveXY ( unit , _x , _y ) ;
56545: LD_VAR 0 1
56549: PPUSH
56550: LD_VAR 0 5
56554: PPUSH
56555: LD_VAR 0 7
56559: PPUSH
56560: CALL_OW 111
// result := [ _x , _y ] ;
56564: LD_ADDR_VAR 0 3
56568: PUSH
56569: LD_VAR 0 5
56573: PUSH
56574: LD_VAR 0 7
56578: PUSH
56579: EMPTY
56580: LIST
56581: LIST
56582: ST_TO_ADDR
// exit ;
56583: POP
56584: POP
56585: GO 56591
// end ; end ;
56587: GO 56431
56589: POP
56590: POP
// end ;
56591: LD_VAR 0 3
56595: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
56596: LD_INT 0
56598: PPUSH
56599: PPUSH
56600: PPUSH
// result := 0 ;
56601: LD_ADDR_VAR 0 3
56605: PUSH
56606: LD_INT 0
56608: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
56609: LD_VAR 0 1
56613: PUSH
56614: LD_INT 0
56616: LESS
56617: PUSH
56618: LD_VAR 0 1
56622: PUSH
56623: LD_INT 8
56625: GREATER
56626: OR
56627: PUSH
56628: LD_VAR 0 2
56632: PUSH
56633: LD_INT 0
56635: LESS
56636: OR
56637: PUSH
56638: LD_VAR 0 2
56642: PUSH
56643: LD_INT 8
56645: GREATER
56646: OR
56647: IFFALSE 56651
// exit ;
56649: GO 56726
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
56651: LD_ADDR_VAR 0 4
56655: PUSH
56656: LD_INT 22
56658: PUSH
56659: LD_VAR 0 2
56663: PUSH
56664: EMPTY
56665: LIST
56666: LIST
56667: PPUSH
56668: CALL_OW 69
56672: PUSH
56673: FOR_IN
56674: IFFALSE 56724
// begin un := UnitShoot ( i ) ;
56676: LD_ADDR_VAR 0 5
56680: PUSH
56681: LD_VAR 0 4
56685: PPUSH
56686: CALL_OW 504
56690: ST_TO_ADDR
// if GetSide ( un ) = side1 then
56691: LD_VAR 0 5
56695: PPUSH
56696: CALL_OW 255
56700: PUSH
56701: LD_VAR 0 1
56705: EQUAL
56706: IFFALSE 56722
// begin result := un ;
56708: LD_ADDR_VAR 0 3
56712: PUSH
56713: LD_VAR 0 5
56717: ST_TO_ADDR
// exit ;
56718: POP
56719: POP
56720: GO 56726
// end ; end ;
56722: GO 56673
56724: POP
56725: POP
// end ;
56726: LD_VAR 0 3
56730: RET
// export function GetCargoBay ( units ) ; begin
56731: LD_INT 0
56733: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
56734: LD_ADDR_VAR 0 2
56738: PUSH
56739: LD_VAR 0 1
56743: PPUSH
56744: LD_INT 2
56746: PUSH
56747: LD_INT 34
56749: PUSH
56750: LD_INT 12
56752: PUSH
56753: EMPTY
56754: LIST
56755: LIST
56756: PUSH
56757: LD_INT 34
56759: PUSH
56760: LD_INT 51
56762: PUSH
56763: EMPTY
56764: LIST
56765: LIST
56766: PUSH
56767: LD_INT 34
56769: PUSH
56770: LD_INT 32
56772: PUSH
56773: EMPTY
56774: LIST
56775: LIST
56776: PUSH
56777: LD_INT 34
56779: PUSH
56780: LD_EXP 155
56784: PUSH
56785: EMPTY
56786: LIST
56787: LIST
56788: PUSH
56789: EMPTY
56790: LIST
56791: LIST
56792: LIST
56793: LIST
56794: LIST
56795: PPUSH
56796: CALL_OW 72
56800: ST_TO_ADDR
// end ; end_of_file
56801: LD_VAR 0 2
56805: RET
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
56806: LD_INT 0
56808: PPUSH
56809: PPUSH
56810: PPUSH
56811: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
56812: LD_VAR 0 1
56816: PPUSH
56817: CALL_OW 264
56821: PUSH
56822: LD_EXP 158
56826: EQUAL
56827: IFFALSE 56899
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
56829: LD_INT 68
56831: PPUSH
56832: LD_VAR 0 1
56836: PPUSH
56837: CALL_OW 255
56841: PPUSH
56842: CALL_OW 321
56846: PUSH
56847: LD_INT 2
56849: EQUAL
56850: IFFALSE 56862
// eff := 70 else
56852: LD_ADDR_VAR 0 4
56856: PUSH
56857: LD_INT 70
56859: ST_TO_ADDR
56860: GO 56870
// eff := 30 ;
56862: LD_ADDR_VAR 0 4
56866: PUSH
56867: LD_INT 30
56869: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
56870: LD_VAR 0 1
56874: PPUSH
56875: CALL_OW 250
56879: PPUSH
56880: LD_VAR 0 1
56884: PPUSH
56885: CALL_OW 251
56889: PPUSH
56890: LD_VAR 0 4
56894: PPUSH
56895: CALL_OW 495
// end ; end ;
56899: LD_VAR 0 2
56903: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
56904: LD_INT 0
56906: PPUSH
// end ;
56907: LD_VAR 0 4
56911: RET
// export function SOS_Command ( cmd ) ; begin
56912: LD_INT 0
56914: PPUSH
// end ;
56915: LD_VAR 0 2
56919: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
56920: LD_INT 0
56922: PPUSH
// if cmd = 121 then
56923: LD_VAR 0 1
56927: PUSH
56928: LD_INT 121
56930: EQUAL
56931: IFFALSE 56933
// end ;
56933: LD_VAR 0 6
56937: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
56938: LD_INT 0
56940: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
56941: LD_VAR 0 1
56945: PUSH
56946: LD_INT 250
56948: EQUAL
56949: PUSH
56950: LD_VAR 0 2
56954: PPUSH
56955: CALL_OW 264
56959: PUSH
56960: LD_EXP 161
56964: EQUAL
56965: AND
56966: IFFALSE 56987
// MinerPlaceMine ( unit , x , y ) ;
56968: LD_VAR 0 2
56972: PPUSH
56973: LD_VAR 0 4
56977: PPUSH
56978: LD_VAR 0 5
56982: PPUSH
56983: CALL 59336 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
56987: LD_VAR 0 1
56991: PUSH
56992: LD_INT 251
56994: EQUAL
56995: PUSH
56996: LD_VAR 0 2
57000: PPUSH
57001: CALL_OW 264
57005: PUSH
57006: LD_EXP 161
57010: EQUAL
57011: AND
57012: IFFALSE 57033
// MinerDetonateMine ( unit , x , y ) ;
57014: LD_VAR 0 2
57018: PPUSH
57019: LD_VAR 0 4
57023: PPUSH
57024: LD_VAR 0 5
57028: PPUSH
57029: CALL 59613 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
57033: LD_VAR 0 1
57037: PUSH
57038: LD_INT 252
57040: EQUAL
57041: PUSH
57042: LD_VAR 0 2
57046: PPUSH
57047: CALL_OW 264
57051: PUSH
57052: LD_EXP 161
57056: EQUAL
57057: AND
57058: IFFALSE 57079
// MinerCreateMinefield ( unit , x , y ) ;
57060: LD_VAR 0 2
57064: PPUSH
57065: LD_VAR 0 4
57069: PPUSH
57070: LD_VAR 0 5
57074: PPUSH
57075: CALL 60030 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
57079: LD_VAR 0 1
57083: PUSH
57084: LD_INT 253
57086: EQUAL
57087: PUSH
57088: LD_VAR 0 2
57092: PPUSH
57093: CALL_OW 257
57097: PUSH
57098: LD_INT 5
57100: EQUAL
57101: AND
57102: IFFALSE 57123
// ComBinocular ( unit , x , y ) ;
57104: LD_VAR 0 2
57108: PPUSH
57109: LD_VAR 0 4
57113: PPUSH
57114: LD_VAR 0 5
57118: PPUSH
57119: CALL 60401 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
57123: LD_VAR 0 1
57127: PUSH
57128: LD_INT 254
57130: EQUAL
57131: PUSH
57132: LD_VAR 0 2
57136: PPUSH
57137: CALL_OW 264
57141: PUSH
57142: LD_EXP 156
57146: EQUAL
57147: AND
57148: PUSH
57149: LD_VAR 0 3
57153: PPUSH
57154: CALL_OW 263
57158: PUSH
57159: LD_INT 3
57161: EQUAL
57162: AND
57163: IFFALSE 57179
// HackDestroyVehicle ( unit , selectedUnit ) ;
57165: LD_VAR 0 2
57169: PPUSH
57170: LD_VAR 0 3
57174: PPUSH
57175: CALL 58696 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
57179: LD_VAR 0 1
57183: PUSH
57184: LD_INT 255
57186: EQUAL
57187: PUSH
57188: LD_VAR 0 2
57192: PPUSH
57193: CALL_OW 264
57197: PUSH
57198: LD_INT 14
57200: PUSH
57201: LD_INT 53
57203: PUSH
57204: EMPTY
57205: LIST
57206: LIST
57207: IN
57208: AND
57209: PUSH
57210: LD_VAR 0 4
57214: PPUSH
57215: LD_VAR 0 5
57219: PPUSH
57220: CALL_OW 488
57224: AND
57225: IFFALSE 57249
// CutTreeXYR ( unit , x , y , 12 ) ;
57227: LD_VAR 0 2
57231: PPUSH
57232: LD_VAR 0 4
57236: PPUSH
57237: LD_VAR 0 5
57241: PPUSH
57242: LD_INT 12
57244: PPUSH
57245: CALL 57262 0 4
// end ;
57249: LD_VAR 0 6
57253: RET
// export initPlantMineScript , plantMineList ; export function ComGroupPlantMineXY ( units , x , y ) ; begin
57254: LD_INT 0
57256: PPUSH
// end ;
57257: LD_VAR 0 4
57261: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
57262: LD_INT 0
57264: PPUSH
57265: PPUSH
57266: PPUSH
57267: PPUSH
57268: PPUSH
57269: PPUSH
57270: PPUSH
57271: PPUSH
57272: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
57273: LD_VAR 0 1
57277: NOT
57278: PUSH
57279: LD_VAR 0 2
57283: PPUSH
57284: LD_VAR 0 3
57288: PPUSH
57289: CALL_OW 488
57293: NOT
57294: OR
57295: PUSH
57296: LD_VAR 0 4
57300: NOT
57301: OR
57302: IFFALSE 57306
// exit ;
57304: GO 57646
// list := [ ] ;
57306: LD_ADDR_VAR 0 13
57310: PUSH
57311: EMPTY
57312: ST_TO_ADDR
// if x - r < 0 then
57313: LD_VAR 0 2
57317: PUSH
57318: LD_VAR 0 4
57322: MINUS
57323: PUSH
57324: LD_INT 0
57326: LESS
57327: IFFALSE 57339
// min_x := 0 else
57329: LD_ADDR_VAR 0 7
57333: PUSH
57334: LD_INT 0
57336: ST_TO_ADDR
57337: GO 57355
// min_x := x - r ;
57339: LD_ADDR_VAR 0 7
57343: PUSH
57344: LD_VAR 0 2
57348: PUSH
57349: LD_VAR 0 4
57353: MINUS
57354: ST_TO_ADDR
// if y - r < 0 then
57355: LD_VAR 0 3
57359: PUSH
57360: LD_VAR 0 4
57364: MINUS
57365: PUSH
57366: LD_INT 0
57368: LESS
57369: IFFALSE 57381
// min_y := 0 else
57371: LD_ADDR_VAR 0 8
57375: PUSH
57376: LD_INT 0
57378: ST_TO_ADDR
57379: GO 57397
// min_y := y - r ;
57381: LD_ADDR_VAR 0 8
57385: PUSH
57386: LD_VAR 0 3
57390: PUSH
57391: LD_VAR 0 4
57395: MINUS
57396: ST_TO_ADDR
// max_x := x + r ;
57397: LD_ADDR_VAR 0 9
57401: PUSH
57402: LD_VAR 0 2
57406: PUSH
57407: LD_VAR 0 4
57411: PLUS
57412: ST_TO_ADDR
// max_y := y + r ;
57413: LD_ADDR_VAR 0 10
57417: PUSH
57418: LD_VAR 0 3
57422: PUSH
57423: LD_VAR 0 4
57427: PLUS
57428: ST_TO_ADDR
// for _x = min_x to max_x do
57429: LD_ADDR_VAR 0 11
57433: PUSH
57434: DOUBLE
57435: LD_VAR 0 7
57439: DEC
57440: ST_TO_ADDR
57441: LD_VAR 0 9
57445: PUSH
57446: FOR_TO
57447: IFFALSE 57564
// for _y = min_y to max_y do
57449: LD_ADDR_VAR 0 12
57453: PUSH
57454: DOUBLE
57455: LD_VAR 0 8
57459: DEC
57460: ST_TO_ADDR
57461: LD_VAR 0 10
57465: PUSH
57466: FOR_TO
57467: IFFALSE 57560
// begin if not ValidHex ( _x , _y ) then
57469: LD_VAR 0 11
57473: PPUSH
57474: LD_VAR 0 12
57478: PPUSH
57479: CALL_OW 488
57483: NOT
57484: IFFALSE 57488
// continue ;
57486: GO 57466
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
57488: LD_VAR 0 11
57492: PPUSH
57493: LD_VAR 0 12
57497: PPUSH
57498: CALL_OW 351
57502: PUSH
57503: LD_VAR 0 11
57507: PPUSH
57508: LD_VAR 0 12
57512: PPUSH
57513: CALL_OW 554
57517: AND
57518: IFFALSE 57558
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
57520: LD_ADDR_VAR 0 13
57524: PUSH
57525: LD_VAR 0 13
57529: PPUSH
57530: LD_VAR 0 13
57534: PUSH
57535: LD_INT 1
57537: PLUS
57538: PPUSH
57539: LD_VAR 0 11
57543: PUSH
57544: LD_VAR 0 12
57548: PUSH
57549: EMPTY
57550: LIST
57551: LIST
57552: PPUSH
57553: CALL_OW 2
57557: ST_TO_ADDR
// end ;
57558: GO 57466
57560: POP
57561: POP
57562: GO 57446
57564: POP
57565: POP
// if not list then
57566: LD_VAR 0 13
57570: NOT
57571: IFFALSE 57575
// exit ;
57573: GO 57646
// for i in list do
57575: LD_ADDR_VAR 0 6
57579: PUSH
57580: LD_VAR 0 13
57584: PUSH
57585: FOR_IN
57586: IFFALSE 57644
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
57588: LD_VAR 0 1
57592: PPUSH
57593: LD_STRING M
57595: PUSH
57596: LD_VAR 0 6
57600: PUSH
57601: LD_INT 1
57603: ARRAY
57604: PUSH
57605: LD_VAR 0 6
57609: PUSH
57610: LD_INT 2
57612: ARRAY
57613: PUSH
57614: LD_INT 0
57616: PUSH
57617: LD_INT 0
57619: PUSH
57620: LD_INT 0
57622: PUSH
57623: LD_INT 0
57625: PUSH
57626: EMPTY
57627: LIST
57628: LIST
57629: LIST
57630: LIST
57631: LIST
57632: LIST
57633: LIST
57634: PUSH
57635: EMPTY
57636: LIST
57637: PPUSH
57638: CALL_OW 447
57642: GO 57585
57644: POP
57645: POP
// end ;
57646: LD_VAR 0 5
57650: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
57651: LD_EXP 89
57655: NOT
57656: IFFALSE 57706
57658: GO 57660
57660: DISABLE
// begin initHack := true ;
57661: LD_ADDR_EXP 89
57665: PUSH
57666: LD_INT 1
57668: ST_TO_ADDR
// hackTanks := [ ] ;
57669: LD_ADDR_EXP 90
57673: PUSH
57674: EMPTY
57675: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
57676: LD_ADDR_EXP 91
57680: PUSH
57681: EMPTY
57682: ST_TO_ADDR
// hackLimit := 3 ;
57683: LD_ADDR_EXP 92
57687: PUSH
57688: LD_INT 3
57690: ST_TO_ADDR
// hackDist := 12 ;
57691: LD_ADDR_EXP 93
57695: PUSH
57696: LD_INT 12
57698: ST_TO_ADDR
// hackCounter := [ ] ;
57699: LD_ADDR_EXP 94
57703: PUSH
57704: EMPTY
57705: ST_TO_ADDR
// end ;
57706: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
57707: LD_EXP 89
57711: PUSH
57712: LD_INT 34
57714: PUSH
57715: LD_EXP 156
57719: PUSH
57720: EMPTY
57721: LIST
57722: LIST
57723: PPUSH
57724: CALL_OW 69
57728: AND
57729: IFFALSE 57984
57731: GO 57733
57733: DISABLE
57734: LD_INT 0
57736: PPUSH
57737: PPUSH
// begin enable ;
57738: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
57739: LD_ADDR_VAR 0 1
57743: PUSH
57744: LD_INT 34
57746: PUSH
57747: LD_EXP 156
57751: PUSH
57752: EMPTY
57753: LIST
57754: LIST
57755: PPUSH
57756: CALL_OW 69
57760: PUSH
57761: FOR_IN
57762: IFFALSE 57982
// begin if not i in hackTanks then
57764: LD_VAR 0 1
57768: PUSH
57769: LD_EXP 90
57773: IN
57774: NOT
57775: IFFALSE 57858
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
57777: LD_ADDR_EXP 90
57781: PUSH
57782: LD_EXP 90
57786: PPUSH
57787: LD_EXP 90
57791: PUSH
57792: LD_INT 1
57794: PLUS
57795: PPUSH
57796: LD_VAR 0 1
57800: PPUSH
57801: CALL_OW 1
57805: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
57806: LD_ADDR_EXP 91
57810: PUSH
57811: LD_EXP 91
57815: PPUSH
57816: LD_EXP 91
57820: PUSH
57821: LD_INT 1
57823: PLUS
57824: PPUSH
57825: EMPTY
57826: PPUSH
57827: CALL_OW 1
57831: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
57832: LD_ADDR_EXP 94
57836: PUSH
57837: LD_EXP 94
57841: PPUSH
57842: LD_EXP 94
57846: PUSH
57847: LD_INT 1
57849: PLUS
57850: PPUSH
57851: EMPTY
57852: PPUSH
57853: CALL_OW 1
57857: ST_TO_ADDR
// end ; if not IsOk ( i ) then
57858: LD_VAR 0 1
57862: PPUSH
57863: CALL_OW 302
57867: NOT
57868: IFFALSE 57881
// begin HackUnlinkAll ( i ) ;
57870: LD_VAR 0 1
57874: PPUSH
57875: CALL 57987 0 1
// continue ;
57879: GO 57761
// end ; HackCheckCapturedStatus ( i ) ;
57881: LD_VAR 0 1
57885: PPUSH
57886: CALL 58430 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
57890: LD_ADDR_VAR 0 2
57894: PUSH
57895: LD_INT 81
57897: PUSH
57898: LD_VAR 0 1
57902: PPUSH
57903: CALL_OW 255
57907: PUSH
57908: EMPTY
57909: LIST
57910: LIST
57911: PUSH
57912: LD_INT 33
57914: PUSH
57915: LD_INT 3
57917: PUSH
57918: EMPTY
57919: LIST
57920: LIST
57921: PUSH
57922: LD_INT 91
57924: PUSH
57925: LD_VAR 0 1
57929: PUSH
57930: LD_EXP 93
57934: PUSH
57935: EMPTY
57936: LIST
57937: LIST
57938: LIST
57939: PUSH
57940: LD_INT 50
57942: PUSH
57943: EMPTY
57944: LIST
57945: PUSH
57946: EMPTY
57947: LIST
57948: LIST
57949: LIST
57950: LIST
57951: PPUSH
57952: CALL_OW 69
57956: ST_TO_ADDR
// if not tmp then
57957: LD_VAR 0 2
57961: NOT
57962: IFFALSE 57966
// continue ;
57964: GO 57761
// HackLink ( i , tmp ) ;
57966: LD_VAR 0 1
57970: PPUSH
57971: LD_VAR 0 2
57975: PPUSH
57976: CALL 58123 0 2
// end ;
57980: GO 57761
57982: POP
57983: POP
// end ;
57984: PPOPN 2
57986: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
57987: LD_INT 0
57989: PPUSH
57990: PPUSH
57991: PPUSH
// if not hack in hackTanks then
57992: LD_VAR 0 1
57996: PUSH
57997: LD_EXP 90
58001: IN
58002: NOT
58003: IFFALSE 58007
// exit ;
58005: GO 58118
// index := GetElementIndex ( hackTanks , hack ) ;
58007: LD_ADDR_VAR 0 4
58011: PUSH
58012: LD_EXP 90
58016: PPUSH
58017: LD_VAR 0 1
58021: PPUSH
58022: CALL 23881 0 2
58026: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
58027: LD_EXP 91
58031: PUSH
58032: LD_VAR 0 4
58036: ARRAY
58037: IFFALSE 58118
// begin for i in hackTanksCaptured [ index ] do
58039: LD_ADDR_VAR 0 3
58043: PUSH
58044: LD_EXP 91
58048: PUSH
58049: LD_VAR 0 4
58053: ARRAY
58054: PUSH
58055: FOR_IN
58056: IFFALSE 58082
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
58058: LD_VAR 0 3
58062: PUSH
58063: LD_INT 1
58065: ARRAY
58066: PPUSH
58067: LD_VAR 0 3
58071: PUSH
58072: LD_INT 2
58074: ARRAY
58075: PPUSH
58076: CALL_OW 235
58080: GO 58055
58082: POP
58083: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
58084: LD_ADDR_EXP 91
58088: PUSH
58089: LD_EXP 91
58093: PPUSH
58094: LD_VAR 0 4
58098: PPUSH
58099: EMPTY
58100: PPUSH
58101: CALL_OW 1
58105: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
58106: LD_VAR 0 1
58110: PPUSH
58111: LD_INT 0
58113: PPUSH
58114: CALL_OW 505
// end ; end ;
58118: LD_VAR 0 2
58122: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
58123: LD_INT 0
58125: PPUSH
58126: PPUSH
58127: PPUSH
// if not hack in hackTanks or not vehicles then
58128: LD_VAR 0 1
58132: PUSH
58133: LD_EXP 90
58137: IN
58138: NOT
58139: PUSH
58140: LD_VAR 0 2
58144: NOT
58145: OR
58146: IFFALSE 58150
// exit ;
58148: GO 58425
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
58150: LD_ADDR_VAR 0 2
58154: PUSH
58155: LD_VAR 0 1
58159: PPUSH
58160: LD_VAR 0 2
58164: PPUSH
58165: LD_INT 1
58167: PPUSH
58168: LD_INT 1
58170: PPUSH
58171: CALL 24531 0 4
58175: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
58176: LD_ADDR_VAR 0 5
58180: PUSH
58181: LD_EXP 90
58185: PPUSH
58186: LD_VAR 0 1
58190: PPUSH
58191: CALL 23881 0 2
58195: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
58196: LD_EXP 91
58200: PUSH
58201: LD_VAR 0 5
58205: ARRAY
58206: PUSH
58207: LD_EXP 92
58211: LESS
58212: IFFALSE 58401
// begin for i := 1 to vehicles do
58214: LD_ADDR_VAR 0 4
58218: PUSH
58219: DOUBLE
58220: LD_INT 1
58222: DEC
58223: ST_TO_ADDR
58224: LD_VAR 0 2
58228: PUSH
58229: FOR_TO
58230: IFFALSE 58399
// begin if hackTanksCaptured [ index ] = hackLimit then
58232: LD_EXP 91
58236: PUSH
58237: LD_VAR 0 5
58241: ARRAY
58242: PUSH
58243: LD_EXP 92
58247: EQUAL
58248: IFFALSE 58252
// break ;
58250: GO 58399
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
58252: LD_ADDR_EXP 94
58256: PUSH
58257: LD_EXP 94
58261: PPUSH
58262: LD_VAR 0 5
58266: PPUSH
58267: LD_EXP 94
58271: PUSH
58272: LD_VAR 0 5
58276: ARRAY
58277: PUSH
58278: LD_INT 1
58280: PLUS
58281: PPUSH
58282: CALL_OW 1
58286: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
58287: LD_ADDR_EXP 91
58291: PUSH
58292: LD_EXP 91
58296: PPUSH
58297: LD_VAR 0 5
58301: PUSH
58302: LD_EXP 91
58306: PUSH
58307: LD_VAR 0 5
58311: ARRAY
58312: PUSH
58313: LD_INT 1
58315: PLUS
58316: PUSH
58317: EMPTY
58318: LIST
58319: LIST
58320: PPUSH
58321: LD_VAR 0 2
58325: PUSH
58326: LD_VAR 0 4
58330: ARRAY
58331: PUSH
58332: LD_VAR 0 2
58336: PUSH
58337: LD_VAR 0 4
58341: ARRAY
58342: PPUSH
58343: CALL_OW 255
58347: PUSH
58348: EMPTY
58349: LIST
58350: LIST
58351: PPUSH
58352: CALL 24096 0 3
58356: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
58357: LD_VAR 0 2
58361: PUSH
58362: LD_VAR 0 4
58366: ARRAY
58367: PPUSH
58368: LD_VAR 0 1
58372: PPUSH
58373: CALL_OW 255
58377: PPUSH
58378: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
58382: LD_VAR 0 2
58386: PUSH
58387: LD_VAR 0 4
58391: ARRAY
58392: PPUSH
58393: CALL_OW 141
// end ;
58397: GO 58229
58399: POP
58400: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
58401: LD_VAR 0 1
58405: PPUSH
58406: LD_EXP 91
58410: PUSH
58411: LD_VAR 0 5
58415: ARRAY
58416: PUSH
58417: LD_INT 0
58419: PLUS
58420: PPUSH
58421: CALL_OW 505
// end ;
58425: LD_VAR 0 3
58429: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
58430: LD_INT 0
58432: PPUSH
58433: PPUSH
58434: PPUSH
58435: PPUSH
// if not hack in hackTanks then
58436: LD_VAR 0 1
58440: PUSH
58441: LD_EXP 90
58445: IN
58446: NOT
58447: IFFALSE 58451
// exit ;
58449: GO 58691
// index := GetElementIndex ( hackTanks , hack ) ;
58451: LD_ADDR_VAR 0 4
58455: PUSH
58456: LD_EXP 90
58460: PPUSH
58461: LD_VAR 0 1
58465: PPUSH
58466: CALL 23881 0 2
58470: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
58471: LD_ADDR_VAR 0 3
58475: PUSH
58476: DOUBLE
58477: LD_EXP 91
58481: PUSH
58482: LD_VAR 0 4
58486: ARRAY
58487: INC
58488: ST_TO_ADDR
58489: LD_INT 1
58491: PUSH
58492: FOR_DOWNTO
58493: IFFALSE 58665
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
58495: LD_ADDR_VAR 0 5
58499: PUSH
58500: LD_EXP 91
58504: PUSH
58505: LD_VAR 0 4
58509: ARRAY
58510: PUSH
58511: LD_VAR 0 3
58515: ARRAY
58516: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
58517: LD_VAR 0 5
58521: PUSH
58522: LD_INT 1
58524: ARRAY
58525: PPUSH
58526: CALL_OW 302
58530: NOT
58531: PUSH
58532: LD_VAR 0 5
58536: PUSH
58537: LD_INT 1
58539: ARRAY
58540: PPUSH
58541: CALL_OW 255
58545: PUSH
58546: LD_VAR 0 1
58550: PPUSH
58551: CALL_OW 255
58555: NONEQUAL
58556: OR
58557: IFFALSE 58663
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
58559: LD_VAR 0 5
58563: PUSH
58564: LD_INT 1
58566: ARRAY
58567: PPUSH
58568: CALL_OW 305
58572: PUSH
58573: LD_VAR 0 5
58577: PUSH
58578: LD_INT 1
58580: ARRAY
58581: PPUSH
58582: CALL_OW 255
58586: PUSH
58587: LD_VAR 0 1
58591: PPUSH
58592: CALL_OW 255
58596: EQUAL
58597: AND
58598: IFFALSE 58622
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
58600: LD_VAR 0 5
58604: PUSH
58605: LD_INT 1
58607: ARRAY
58608: PPUSH
58609: LD_VAR 0 5
58613: PUSH
58614: LD_INT 2
58616: ARRAY
58617: PPUSH
58618: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
58622: LD_ADDR_EXP 91
58626: PUSH
58627: LD_EXP 91
58631: PPUSH
58632: LD_VAR 0 4
58636: PPUSH
58637: LD_EXP 91
58641: PUSH
58642: LD_VAR 0 4
58646: ARRAY
58647: PPUSH
58648: LD_VAR 0 3
58652: PPUSH
58653: CALL_OW 3
58657: PPUSH
58658: CALL_OW 1
58662: ST_TO_ADDR
// end ; end ;
58663: GO 58492
58665: POP
58666: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
58667: LD_VAR 0 1
58671: PPUSH
58672: LD_EXP 91
58676: PUSH
58677: LD_VAR 0 4
58681: ARRAY
58682: PUSH
58683: LD_INT 0
58685: PLUS
58686: PPUSH
58687: CALL_OW 505
// end ;
58691: LD_VAR 0 2
58695: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
58696: LD_INT 0
58698: PPUSH
58699: PPUSH
58700: PPUSH
58701: PPUSH
// if not hack in hackTanks then
58702: LD_VAR 0 1
58706: PUSH
58707: LD_EXP 90
58711: IN
58712: NOT
58713: IFFALSE 58717
// exit ;
58715: GO 58802
// index := GetElementIndex ( hackTanks , hack ) ;
58717: LD_ADDR_VAR 0 5
58721: PUSH
58722: LD_EXP 90
58726: PPUSH
58727: LD_VAR 0 1
58731: PPUSH
58732: CALL 23881 0 2
58736: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
58737: LD_ADDR_VAR 0 4
58741: PUSH
58742: DOUBLE
58743: LD_INT 1
58745: DEC
58746: ST_TO_ADDR
58747: LD_EXP 91
58751: PUSH
58752: LD_VAR 0 5
58756: ARRAY
58757: PUSH
58758: FOR_TO
58759: IFFALSE 58800
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
58761: LD_EXP 91
58765: PUSH
58766: LD_VAR 0 5
58770: ARRAY
58771: PUSH
58772: LD_VAR 0 4
58776: ARRAY
58777: PUSH
58778: LD_INT 1
58780: ARRAY
58781: PUSH
58782: LD_VAR 0 2
58786: EQUAL
58787: IFFALSE 58798
// KillUnit ( vehicle ) ;
58789: LD_VAR 0 2
58793: PPUSH
58794: CALL_OW 66
58798: GO 58758
58800: POP
58801: POP
// end ;
58802: LD_VAR 0 3
58806: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
58807: LD_EXP 95
58811: NOT
58812: IFFALSE 58847
58814: GO 58816
58816: DISABLE
// begin initMiner := true ;
58817: LD_ADDR_EXP 95
58821: PUSH
58822: LD_INT 1
58824: ST_TO_ADDR
// minersList := [ ] ;
58825: LD_ADDR_EXP 96
58829: PUSH
58830: EMPTY
58831: ST_TO_ADDR
// minerMinesList := [ ] ;
58832: LD_ADDR_EXP 97
58836: PUSH
58837: EMPTY
58838: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
58839: LD_ADDR_EXP 98
58843: PUSH
58844: LD_INT 5
58846: ST_TO_ADDR
// end ;
58847: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
58848: LD_EXP 95
58852: PUSH
58853: LD_INT 34
58855: PUSH
58856: LD_EXP 161
58860: PUSH
58861: EMPTY
58862: LIST
58863: LIST
58864: PPUSH
58865: CALL_OW 69
58869: AND
58870: IFFALSE 59333
58872: GO 58874
58874: DISABLE
58875: LD_INT 0
58877: PPUSH
58878: PPUSH
58879: PPUSH
58880: PPUSH
// begin enable ;
58881: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
58882: LD_ADDR_VAR 0 1
58886: PUSH
58887: LD_INT 34
58889: PUSH
58890: LD_EXP 161
58894: PUSH
58895: EMPTY
58896: LIST
58897: LIST
58898: PPUSH
58899: CALL_OW 69
58903: PUSH
58904: FOR_IN
58905: IFFALSE 58977
// begin if not i in minersList then
58907: LD_VAR 0 1
58911: PUSH
58912: LD_EXP 96
58916: IN
58917: NOT
58918: IFFALSE 58975
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
58920: LD_ADDR_EXP 96
58924: PUSH
58925: LD_EXP 96
58929: PPUSH
58930: LD_EXP 96
58934: PUSH
58935: LD_INT 1
58937: PLUS
58938: PPUSH
58939: LD_VAR 0 1
58943: PPUSH
58944: CALL_OW 1
58948: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
58949: LD_ADDR_EXP 97
58953: PUSH
58954: LD_EXP 97
58958: PPUSH
58959: LD_EXP 97
58963: PUSH
58964: LD_INT 1
58966: PLUS
58967: PPUSH
58968: EMPTY
58969: PPUSH
58970: CALL_OW 1
58974: ST_TO_ADDR
// end end ;
58975: GO 58904
58977: POP
58978: POP
// for i := minerMinesList downto 1 do
58979: LD_ADDR_VAR 0 1
58983: PUSH
58984: DOUBLE
58985: LD_EXP 97
58989: INC
58990: ST_TO_ADDR
58991: LD_INT 1
58993: PUSH
58994: FOR_DOWNTO
58995: IFFALSE 59331
// begin if IsLive ( minersList [ i ] ) then
58997: LD_EXP 96
59001: PUSH
59002: LD_VAR 0 1
59006: ARRAY
59007: PPUSH
59008: CALL_OW 300
59012: IFFALSE 59040
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
59014: LD_EXP 96
59018: PUSH
59019: LD_VAR 0 1
59023: ARRAY
59024: PPUSH
59025: LD_EXP 97
59029: PUSH
59030: LD_VAR 0 1
59034: ARRAY
59035: PPUSH
59036: CALL_OW 505
// if not minerMinesList [ i ] then
59040: LD_EXP 97
59044: PUSH
59045: LD_VAR 0 1
59049: ARRAY
59050: NOT
59051: IFFALSE 59055
// continue ;
59053: GO 58994
// for j := minerMinesList [ i ] downto 1 do
59055: LD_ADDR_VAR 0 2
59059: PUSH
59060: DOUBLE
59061: LD_EXP 97
59065: PUSH
59066: LD_VAR 0 1
59070: ARRAY
59071: INC
59072: ST_TO_ADDR
59073: LD_INT 1
59075: PUSH
59076: FOR_DOWNTO
59077: IFFALSE 59327
// begin side := GetSide ( minersList [ i ] ) ;
59079: LD_ADDR_VAR 0 3
59083: PUSH
59084: LD_EXP 96
59088: PUSH
59089: LD_VAR 0 1
59093: ARRAY
59094: PPUSH
59095: CALL_OW 255
59099: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
59100: LD_ADDR_VAR 0 4
59104: PUSH
59105: LD_EXP 97
59109: PUSH
59110: LD_VAR 0 1
59114: ARRAY
59115: PUSH
59116: LD_VAR 0 2
59120: ARRAY
59121: PUSH
59122: LD_INT 1
59124: ARRAY
59125: PPUSH
59126: LD_EXP 97
59130: PUSH
59131: LD_VAR 0 1
59135: ARRAY
59136: PUSH
59137: LD_VAR 0 2
59141: ARRAY
59142: PUSH
59143: LD_INT 2
59145: ARRAY
59146: PPUSH
59147: CALL_OW 428
59151: ST_TO_ADDR
// if not tmp then
59152: LD_VAR 0 4
59156: NOT
59157: IFFALSE 59161
// continue ;
59159: GO 59076
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
59161: LD_VAR 0 4
59165: PUSH
59166: LD_INT 81
59168: PUSH
59169: LD_VAR 0 3
59173: PUSH
59174: EMPTY
59175: LIST
59176: LIST
59177: PPUSH
59178: CALL_OW 69
59182: IN
59183: PUSH
59184: LD_EXP 97
59188: PUSH
59189: LD_VAR 0 1
59193: ARRAY
59194: PUSH
59195: LD_VAR 0 2
59199: ARRAY
59200: PUSH
59201: LD_INT 1
59203: ARRAY
59204: PPUSH
59205: LD_EXP 97
59209: PUSH
59210: LD_VAR 0 1
59214: ARRAY
59215: PUSH
59216: LD_VAR 0 2
59220: ARRAY
59221: PUSH
59222: LD_INT 2
59224: ARRAY
59225: PPUSH
59226: CALL_OW 458
59230: AND
59231: IFFALSE 59325
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
59233: LD_EXP 97
59237: PUSH
59238: LD_VAR 0 1
59242: ARRAY
59243: PUSH
59244: LD_VAR 0 2
59248: ARRAY
59249: PUSH
59250: LD_INT 1
59252: ARRAY
59253: PPUSH
59254: LD_EXP 97
59258: PUSH
59259: LD_VAR 0 1
59263: ARRAY
59264: PUSH
59265: LD_VAR 0 2
59269: ARRAY
59270: PUSH
59271: LD_INT 2
59273: ARRAY
59274: PPUSH
59275: LD_VAR 0 3
59279: PPUSH
59280: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
59284: LD_ADDR_EXP 97
59288: PUSH
59289: LD_EXP 97
59293: PPUSH
59294: LD_VAR 0 1
59298: PPUSH
59299: LD_EXP 97
59303: PUSH
59304: LD_VAR 0 1
59308: ARRAY
59309: PPUSH
59310: LD_VAR 0 2
59314: PPUSH
59315: CALL_OW 3
59319: PPUSH
59320: CALL_OW 1
59324: ST_TO_ADDR
// end ; end ;
59325: GO 59076
59327: POP
59328: POP
// end ;
59329: GO 58994
59331: POP
59332: POP
// end ;
59333: PPOPN 4
59335: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
59336: LD_INT 0
59338: PPUSH
59339: PPUSH
// result := false ;
59340: LD_ADDR_VAR 0 4
59344: PUSH
59345: LD_INT 0
59347: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
59348: LD_VAR 0 1
59352: PPUSH
59353: CALL_OW 264
59357: PUSH
59358: LD_EXP 161
59362: EQUAL
59363: NOT
59364: IFFALSE 59368
// exit ;
59366: GO 59608
// index := GetElementIndex ( minersList , unit ) ;
59368: LD_ADDR_VAR 0 5
59372: PUSH
59373: LD_EXP 96
59377: PPUSH
59378: LD_VAR 0 1
59382: PPUSH
59383: CALL 23881 0 2
59387: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
59388: LD_EXP 97
59392: PUSH
59393: LD_VAR 0 5
59397: ARRAY
59398: PUSH
59399: LD_EXP 98
59403: GREATEREQUAL
59404: IFFALSE 59408
// exit ;
59406: GO 59608
// ComMoveXY ( unit , x , y ) ;
59408: LD_VAR 0 1
59412: PPUSH
59413: LD_VAR 0 2
59417: PPUSH
59418: LD_VAR 0 3
59422: PPUSH
59423: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
59427: LD_INT 35
59429: PPUSH
59430: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
59434: LD_VAR 0 1
59438: PPUSH
59439: LD_VAR 0 2
59443: PPUSH
59444: LD_VAR 0 3
59448: PPUSH
59449: CALL 54278 0 3
59453: NOT
59454: PUSH
59455: LD_VAR 0 1
59459: PPUSH
59460: CALL_OW 314
59464: AND
59465: IFFALSE 59469
// exit ;
59467: GO 59608
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
59469: LD_VAR 0 2
59473: PPUSH
59474: LD_VAR 0 3
59478: PPUSH
59479: CALL_OW 428
59483: PUSH
59484: LD_VAR 0 1
59488: EQUAL
59489: PUSH
59490: LD_VAR 0 1
59494: PPUSH
59495: CALL_OW 314
59499: NOT
59500: AND
59501: IFFALSE 59427
// PlaySoundXY ( x , y , PlantMine ) ;
59503: LD_VAR 0 2
59507: PPUSH
59508: LD_VAR 0 3
59512: PPUSH
59513: LD_STRING PlantMine
59515: PPUSH
59516: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
59520: LD_VAR 0 2
59524: PPUSH
59525: LD_VAR 0 3
59529: PPUSH
59530: LD_VAR 0 1
59534: PPUSH
59535: CALL_OW 255
59539: PPUSH
59540: LD_INT 0
59542: PPUSH
59543: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
59547: LD_ADDR_EXP 97
59551: PUSH
59552: LD_EXP 97
59556: PPUSH
59557: LD_VAR 0 5
59561: PUSH
59562: LD_EXP 97
59566: PUSH
59567: LD_VAR 0 5
59571: ARRAY
59572: PUSH
59573: LD_INT 1
59575: PLUS
59576: PUSH
59577: EMPTY
59578: LIST
59579: LIST
59580: PPUSH
59581: LD_VAR 0 2
59585: PUSH
59586: LD_VAR 0 3
59590: PUSH
59591: EMPTY
59592: LIST
59593: LIST
59594: PPUSH
59595: CALL 24096 0 3
59599: ST_TO_ADDR
// result := true ;
59600: LD_ADDR_VAR 0 4
59604: PUSH
59605: LD_INT 1
59607: ST_TO_ADDR
// end ;
59608: LD_VAR 0 4
59612: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
59613: LD_INT 0
59615: PPUSH
59616: PPUSH
59617: PPUSH
// if not unit in minersList then
59618: LD_VAR 0 1
59622: PUSH
59623: LD_EXP 96
59627: IN
59628: NOT
59629: IFFALSE 59633
// exit ;
59631: GO 60025
// index := GetElementIndex ( minersList , unit ) ;
59633: LD_ADDR_VAR 0 6
59637: PUSH
59638: LD_EXP 96
59642: PPUSH
59643: LD_VAR 0 1
59647: PPUSH
59648: CALL 23881 0 2
59652: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
59653: LD_ADDR_VAR 0 5
59657: PUSH
59658: DOUBLE
59659: LD_EXP 97
59663: PUSH
59664: LD_VAR 0 6
59668: ARRAY
59669: INC
59670: ST_TO_ADDR
59671: LD_INT 1
59673: PUSH
59674: FOR_DOWNTO
59675: IFFALSE 59836
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
59677: LD_EXP 97
59681: PUSH
59682: LD_VAR 0 6
59686: ARRAY
59687: PUSH
59688: LD_VAR 0 5
59692: ARRAY
59693: PUSH
59694: LD_INT 1
59696: ARRAY
59697: PUSH
59698: LD_VAR 0 2
59702: EQUAL
59703: PUSH
59704: LD_EXP 97
59708: PUSH
59709: LD_VAR 0 6
59713: ARRAY
59714: PUSH
59715: LD_VAR 0 5
59719: ARRAY
59720: PUSH
59721: LD_INT 2
59723: ARRAY
59724: PUSH
59725: LD_VAR 0 3
59729: EQUAL
59730: AND
59731: IFFALSE 59834
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
59733: LD_EXP 97
59737: PUSH
59738: LD_VAR 0 6
59742: ARRAY
59743: PUSH
59744: LD_VAR 0 5
59748: ARRAY
59749: PUSH
59750: LD_INT 1
59752: ARRAY
59753: PPUSH
59754: LD_EXP 97
59758: PUSH
59759: LD_VAR 0 6
59763: ARRAY
59764: PUSH
59765: LD_VAR 0 5
59769: ARRAY
59770: PUSH
59771: LD_INT 2
59773: ARRAY
59774: PPUSH
59775: LD_VAR 0 1
59779: PPUSH
59780: CALL_OW 255
59784: PPUSH
59785: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
59789: LD_ADDR_EXP 97
59793: PUSH
59794: LD_EXP 97
59798: PPUSH
59799: LD_VAR 0 6
59803: PPUSH
59804: LD_EXP 97
59808: PUSH
59809: LD_VAR 0 6
59813: ARRAY
59814: PPUSH
59815: LD_VAR 0 5
59819: PPUSH
59820: CALL_OW 3
59824: PPUSH
59825: CALL_OW 1
59829: ST_TO_ADDR
// exit ;
59830: POP
59831: POP
59832: GO 60025
// end ; end ;
59834: GO 59674
59836: POP
59837: POP
// for i := minerMinesList [ index ] downto 1 do
59838: LD_ADDR_VAR 0 5
59842: PUSH
59843: DOUBLE
59844: LD_EXP 97
59848: PUSH
59849: LD_VAR 0 6
59853: ARRAY
59854: INC
59855: ST_TO_ADDR
59856: LD_INT 1
59858: PUSH
59859: FOR_DOWNTO
59860: IFFALSE 60023
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
59862: LD_EXP 97
59866: PUSH
59867: LD_VAR 0 6
59871: ARRAY
59872: PUSH
59873: LD_VAR 0 5
59877: ARRAY
59878: PUSH
59879: LD_INT 1
59881: ARRAY
59882: PPUSH
59883: LD_EXP 97
59887: PUSH
59888: LD_VAR 0 6
59892: ARRAY
59893: PUSH
59894: LD_VAR 0 5
59898: ARRAY
59899: PUSH
59900: LD_INT 2
59902: ARRAY
59903: PPUSH
59904: LD_VAR 0 2
59908: PPUSH
59909: LD_VAR 0 3
59913: PPUSH
59914: CALL_OW 298
59918: PUSH
59919: LD_INT 6
59921: LESS
59922: IFFALSE 60021
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
59924: LD_EXP 97
59928: PUSH
59929: LD_VAR 0 6
59933: ARRAY
59934: PUSH
59935: LD_VAR 0 5
59939: ARRAY
59940: PUSH
59941: LD_INT 1
59943: ARRAY
59944: PPUSH
59945: LD_EXP 97
59949: PUSH
59950: LD_VAR 0 6
59954: ARRAY
59955: PUSH
59956: LD_VAR 0 5
59960: ARRAY
59961: PUSH
59962: LD_INT 2
59964: ARRAY
59965: PPUSH
59966: LD_VAR 0 1
59970: PPUSH
59971: CALL_OW 255
59975: PPUSH
59976: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
59980: LD_ADDR_EXP 97
59984: PUSH
59985: LD_EXP 97
59989: PPUSH
59990: LD_VAR 0 6
59994: PPUSH
59995: LD_EXP 97
59999: PUSH
60000: LD_VAR 0 6
60004: ARRAY
60005: PPUSH
60006: LD_VAR 0 5
60010: PPUSH
60011: CALL_OW 3
60015: PPUSH
60016: CALL_OW 1
60020: ST_TO_ADDR
// end ; end ;
60021: GO 59859
60023: POP
60024: POP
// end ;
60025: LD_VAR 0 4
60029: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
60030: LD_INT 0
60032: PPUSH
60033: PPUSH
60034: PPUSH
60035: PPUSH
60036: PPUSH
60037: PPUSH
60038: PPUSH
60039: PPUSH
60040: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
60041: LD_VAR 0 1
60045: PPUSH
60046: CALL_OW 264
60050: PUSH
60051: LD_EXP 161
60055: EQUAL
60056: NOT
60057: PUSH
60058: LD_VAR 0 1
60062: PUSH
60063: LD_EXP 96
60067: IN
60068: NOT
60069: OR
60070: IFFALSE 60074
// exit ;
60072: GO 60396
// index := GetElementIndex ( minersList , unit ) ;
60074: LD_ADDR_VAR 0 6
60078: PUSH
60079: LD_EXP 96
60083: PPUSH
60084: LD_VAR 0 1
60088: PPUSH
60089: CALL 23881 0 2
60093: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
60094: LD_ADDR_VAR 0 8
60098: PUSH
60099: LD_EXP 98
60103: PUSH
60104: LD_EXP 97
60108: PUSH
60109: LD_VAR 0 6
60113: ARRAY
60114: MINUS
60115: ST_TO_ADDR
// if not minesFreeAmount then
60116: LD_VAR 0 8
60120: NOT
60121: IFFALSE 60125
// exit ;
60123: GO 60396
// tmp := [ ] ;
60125: LD_ADDR_VAR 0 7
60129: PUSH
60130: EMPTY
60131: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
60132: LD_ADDR_VAR 0 5
60136: PUSH
60137: DOUBLE
60138: LD_INT 1
60140: DEC
60141: ST_TO_ADDR
60142: LD_VAR 0 8
60146: PUSH
60147: FOR_TO
60148: IFFALSE 60343
// begin _d := rand ( 0 , 5 ) ;
60150: LD_ADDR_VAR 0 11
60154: PUSH
60155: LD_INT 0
60157: PPUSH
60158: LD_INT 5
60160: PPUSH
60161: CALL_OW 12
60165: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
60166: LD_ADDR_VAR 0 12
60170: PUSH
60171: LD_INT 2
60173: PPUSH
60174: LD_INT 6
60176: PPUSH
60177: CALL_OW 12
60181: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
60182: LD_ADDR_VAR 0 9
60186: PUSH
60187: LD_VAR 0 2
60191: PPUSH
60192: LD_VAR 0 11
60196: PPUSH
60197: LD_VAR 0 12
60201: PPUSH
60202: CALL_OW 272
60206: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
60207: LD_ADDR_VAR 0 10
60211: PUSH
60212: LD_VAR 0 3
60216: PPUSH
60217: LD_VAR 0 11
60221: PPUSH
60222: LD_VAR 0 12
60226: PPUSH
60227: CALL_OW 273
60231: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
60232: LD_VAR 0 9
60236: PPUSH
60237: LD_VAR 0 10
60241: PPUSH
60242: CALL_OW 488
60246: PUSH
60247: LD_VAR 0 9
60251: PUSH
60252: LD_VAR 0 10
60256: PUSH
60257: EMPTY
60258: LIST
60259: LIST
60260: PUSH
60261: LD_VAR 0 7
60265: IN
60266: NOT
60267: AND
60268: PUSH
60269: LD_VAR 0 9
60273: PPUSH
60274: LD_VAR 0 10
60278: PPUSH
60279: CALL_OW 458
60283: NOT
60284: AND
60285: IFFALSE 60327
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
60287: LD_ADDR_VAR 0 7
60291: PUSH
60292: LD_VAR 0 7
60296: PPUSH
60297: LD_VAR 0 7
60301: PUSH
60302: LD_INT 1
60304: PLUS
60305: PPUSH
60306: LD_VAR 0 9
60310: PUSH
60311: LD_VAR 0 10
60315: PUSH
60316: EMPTY
60317: LIST
60318: LIST
60319: PPUSH
60320: CALL_OW 1
60324: ST_TO_ADDR
60325: GO 60341
// i := i - 1 ;
60327: LD_ADDR_VAR 0 5
60331: PUSH
60332: LD_VAR 0 5
60336: PUSH
60337: LD_INT 1
60339: MINUS
60340: ST_TO_ADDR
// end ;
60341: GO 60147
60343: POP
60344: POP
// for i in tmp do
60345: LD_ADDR_VAR 0 5
60349: PUSH
60350: LD_VAR 0 7
60354: PUSH
60355: FOR_IN
60356: IFFALSE 60394
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
60358: LD_VAR 0 1
60362: PPUSH
60363: LD_VAR 0 5
60367: PUSH
60368: LD_INT 1
60370: ARRAY
60371: PPUSH
60372: LD_VAR 0 5
60376: PUSH
60377: LD_INT 2
60379: ARRAY
60380: PPUSH
60381: CALL 59336 0 3
60385: NOT
60386: IFFALSE 60392
// exit ;
60388: POP
60389: POP
60390: GO 60396
60392: GO 60355
60394: POP
60395: POP
// end ;
60396: LD_VAR 0 4
60400: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
60401: LD_INT 0
60403: PPUSH
60404: PPUSH
60405: PPUSH
60406: PPUSH
60407: PPUSH
60408: PPUSH
60409: PPUSH
// if not GetClass ( unit ) = class_sniper then
60410: LD_VAR 0 1
60414: PPUSH
60415: CALL_OW 257
60419: PUSH
60420: LD_INT 5
60422: EQUAL
60423: NOT
60424: IFFALSE 60428
// exit ;
60426: GO 60816
// dist := 8 ;
60428: LD_ADDR_VAR 0 5
60432: PUSH
60433: LD_INT 8
60435: ST_TO_ADDR
// viewRange := 12 ;
60436: LD_ADDR_VAR 0 7
60440: PUSH
60441: LD_INT 12
60443: ST_TO_ADDR
// side := GetSide ( unit ) ;
60444: LD_ADDR_VAR 0 6
60448: PUSH
60449: LD_VAR 0 1
60453: PPUSH
60454: CALL_OW 255
60458: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
60459: LD_INT 61
60461: PPUSH
60462: LD_VAR 0 6
60466: PPUSH
60467: CALL_OW 321
60471: PUSH
60472: LD_INT 2
60474: EQUAL
60475: IFFALSE 60485
// viewRange := 16 ;
60477: LD_ADDR_VAR 0 7
60481: PUSH
60482: LD_INT 16
60484: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
60485: LD_VAR 0 1
60489: PPUSH
60490: LD_VAR 0 2
60494: PPUSH
60495: LD_VAR 0 3
60499: PPUSH
60500: CALL_OW 297
60504: PUSH
60505: LD_VAR 0 5
60509: GREATER
60510: IFFALSE 60589
// begin ComMoveXY ( unit , x , y ) ;
60512: LD_VAR 0 1
60516: PPUSH
60517: LD_VAR 0 2
60521: PPUSH
60522: LD_VAR 0 3
60526: PPUSH
60527: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
60531: LD_INT 35
60533: PPUSH
60534: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
60538: LD_VAR 0 1
60542: PPUSH
60543: LD_VAR 0 2
60547: PPUSH
60548: LD_VAR 0 3
60552: PPUSH
60553: CALL 54278 0 3
60557: NOT
60558: IFFALSE 60562
// exit ;
60560: GO 60816
// until GetDistUnitXY ( unit , x , y ) < dist ;
60562: LD_VAR 0 1
60566: PPUSH
60567: LD_VAR 0 2
60571: PPUSH
60572: LD_VAR 0 3
60576: PPUSH
60577: CALL_OW 297
60581: PUSH
60582: LD_VAR 0 5
60586: LESS
60587: IFFALSE 60531
// end ; ComTurnXY ( unit , x , y ) ;
60589: LD_VAR 0 1
60593: PPUSH
60594: LD_VAR 0 2
60598: PPUSH
60599: LD_VAR 0 3
60603: PPUSH
60604: CALL_OW 118
// wait ( 5 ) ;
60608: LD_INT 5
60610: PPUSH
60611: CALL_OW 67
// _d := GetDir ( unit ) ;
60615: LD_ADDR_VAR 0 10
60619: PUSH
60620: LD_VAR 0 1
60624: PPUSH
60625: CALL_OW 254
60629: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
60630: LD_ADDR_VAR 0 8
60634: PUSH
60635: LD_VAR 0 1
60639: PPUSH
60640: CALL_OW 250
60644: PPUSH
60645: LD_VAR 0 10
60649: PPUSH
60650: LD_VAR 0 5
60654: PPUSH
60655: CALL_OW 272
60659: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
60660: LD_ADDR_VAR 0 9
60664: PUSH
60665: LD_VAR 0 1
60669: PPUSH
60670: CALL_OW 251
60674: PPUSH
60675: LD_VAR 0 10
60679: PPUSH
60680: LD_VAR 0 5
60684: PPUSH
60685: CALL_OW 273
60689: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
60690: LD_VAR 0 8
60694: PPUSH
60695: LD_VAR 0 9
60699: PPUSH
60700: CALL_OW 488
60704: NOT
60705: IFFALSE 60709
// exit ;
60707: GO 60816
// ComAnimCustom ( unit , 1 ) ;
60709: LD_VAR 0 1
60713: PPUSH
60714: LD_INT 1
60716: PPUSH
60717: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
60721: LD_VAR 0 8
60725: PPUSH
60726: LD_VAR 0 9
60730: PPUSH
60731: LD_VAR 0 6
60735: PPUSH
60736: LD_VAR 0 7
60740: PPUSH
60741: CALL_OW 330
// repeat wait ( 1 ) ;
60745: LD_INT 1
60747: PPUSH
60748: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
60752: LD_VAR 0 1
60756: PPUSH
60757: CALL_OW 316
60761: PUSH
60762: LD_VAR 0 1
60766: PPUSH
60767: CALL_OW 314
60771: OR
60772: PUSH
60773: LD_VAR 0 1
60777: PPUSH
60778: CALL_OW 302
60782: NOT
60783: OR
60784: PUSH
60785: LD_VAR 0 1
60789: PPUSH
60790: CALL_OW 301
60794: OR
60795: IFFALSE 60745
// RemoveSeeing ( _x , _y , side ) ;
60797: LD_VAR 0 8
60801: PPUSH
60802: LD_VAR 0 9
60806: PPUSH
60807: LD_VAR 0 6
60811: PPUSH
60812: CALL_OW 331
// end ; end_of_file
60816: LD_VAR 0 4
60820: RET
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin if p2 = 100 then
60821: LD_VAR 0 2
60825: PUSH
60826: LD_INT 100
60828: EQUAL
60829: IFFALSE 61778
// begin if not StreamModeActive then
60831: LD_EXP 99
60835: NOT
60836: IFFALSE 60846
// StreamModeActive := true ;
60838: LD_ADDR_EXP 99
60842: PUSH
60843: LD_INT 1
60845: ST_TO_ADDR
// if p3 = 0 then
60846: LD_VAR 0 3
60850: PUSH
60851: LD_INT 0
60853: EQUAL
60854: IFFALSE 60860
// InitStreamMode ;
60856: CALL 61936 0 0
// if p3 = 1 then
60860: LD_VAR 0 3
60864: PUSH
60865: LD_INT 1
60867: EQUAL
60868: IFFALSE 60878
// sRocket := true ;
60870: LD_ADDR_EXP 104
60874: PUSH
60875: LD_INT 1
60877: ST_TO_ADDR
// if p3 = 2 then
60878: LD_VAR 0 3
60882: PUSH
60883: LD_INT 2
60885: EQUAL
60886: IFFALSE 60896
// sSpeed := true ;
60888: LD_ADDR_EXP 103
60892: PUSH
60893: LD_INT 1
60895: ST_TO_ADDR
// if p3 = 3 then
60896: LD_VAR 0 3
60900: PUSH
60901: LD_INT 3
60903: EQUAL
60904: IFFALSE 60914
// sEngine := true ;
60906: LD_ADDR_EXP 105
60910: PUSH
60911: LD_INT 1
60913: ST_TO_ADDR
// if p3 = 4 then
60914: LD_VAR 0 3
60918: PUSH
60919: LD_INT 4
60921: EQUAL
60922: IFFALSE 60932
// sSpec := true ;
60924: LD_ADDR_EXP 102
60928: PUSH
60929: LD_INT 1
60931: ST_TO_ADDR
// if p3 = 5 then
60932: LD_VAR 0 3
60936: PUSH
60937: LD_INT 5
60939: EQUAL
60940: IFFALSE 60950
// sLevel := true ;
60942: LD_ADDR_EXP 106
60946: PUSH
60947: LD_INT 1
60949: ST_TO_ADDR
// if p3 = 6 then
60950: LD_VAR 0 3
60954: PUSH
60955: LD_INT 6
60957: EQUAL
60958: IFFALSE 60968
// sArmoury := true ;
60960: LD_ADDR_EXP 107
60964: PUSH
60965: LD_INT 1
60967: ST_TO_ADDR
// if p3 = 7 then
60968: LD_VAR 0 3
60972: PUSH
60973: LD_INT 7
60975: EQUAL
60976: IFFALSE 60986
// sRadar := true ;
60978: LD_ADDR_EXP 108
60982: PUSH
60983: LD_INT 1
60985: ST_TO_ADDR
// if p3 = 8 then
60986: LD_VAR 0 3
60990: PUSH
60991: LD_INT 8
60993: EQUAL
60994: IFFALSE 61004
// sBunker := true ;
60996: LD_ADDR_EXP 109
61000: PUSH
61001: LD_INT 1
61003: ST_TO_ADDR
// if p3 = 9 then
61004: LD_VAR 0 3
61008: PUSH
61009: LD_INT 9
61011: EQUAL
61012: IFFALSE 61022
// sHack := true ;
61014: LD_ADDR_EXP 110
61018: PUSH
61019: LD_INT 1
61021: ST_TO_ADDR
// if p3 = 10 then
61022: LD_VAR 0 3
61026: PUSH
61027: LD_INT 10
61029: EQUAL
61030: IFFALSE 61040
// sFire := true ;
61032: LD_ADDR_EXP 111
61036: PUSH
61037: LD_INT 1
61039: ST_TO_ADDR
// if p3 = 11 then
61040: LD_VAR 0 3
61044: PUSH
61045: LD_INT 11
61047: EQUAL
61048: IFFALSE 61058
// sRefresh := true ;
61050: LD_ADDR_EXP 112
61054: PUSH
61055: LD_INT 1
61057: ST_TO_ADDR
// if p3 = 12 then
61058: LD_VAR 0 3
61062: PUSH
61063: LD_INT 12
61065: EQUAL
61066: IFFALSE 61076
// sExp := true ;
61068: LD_ADDR_EXP 113
61072: PUSH
61073: LD_INT 1
61075: ST_TO_ADDR
// if p3 = 13 then
61076: LD_VAR 0 3
61080: PUSH
61081: LD_INT 13
61083: EQUAL
61084: IFFALSE 61094
// sDepot := true ;
61086: LD_ADDR_EXP 114
61090: PUSH
61091: LD_INT 1
61093: ST_TO_ADDR
// if p3 = 14 then
61094: LD_VAR 0 3
61098: PUSH
61099: LD_INT 14
61101: EQUAL
61102: IFFALSE 61112
// sFlag := true ;
61104: LD_ADDR_EXP 115
61108: PUSH
61109: LD_INT 1
61111: ST_TO_ADDR
// if p3 = 15 then
61112: LD_VAR 0 3
61116: PUSH
61117: LD_INT 15
61119: EQUAL
61120: IFFALSE 61130
// sKamikadze := true ;
61122: LD_ADDR_EXP 123
61126: PUSH
61127: LD_INT 1
61129: ST_TO_ADDR
// if p3 = 16 then
61130: LD_VAR 0 3
61134: PUSH
61135: LD_INT 16
61137: EQUAL
61138: IFFALSE 61148
// sTroll := true ;
61140: LD_ADDR_EXP 124
61144: PUSH
61145: LD_INT 1
61147: ST_TO_ADDR
// if p3 = 17 then
61148: LD_VAR 0 3
61152: PUSH
61153: LD_INT 17
61155: EQUAL
61156: IFFALSE 61166
// sSlow := true ;
61158: LD_ADDR_EXP 125
61162: PUSH
61163: LD_INT 1
61165: ST_TO_ADDR
// if p3 = 18 then
61166: LD_VAR 0 3
61170: PUSH
61171: LD_INT 18
61173: EQUAL
61174: IFFALSE 61184
// sLack := true ;
61176: LD_ADDR_EXP 126
61180: PUSH
61181: LD_INT 1
61183: ST_TO_ADDR
// if p3 = 19 then
61184: LD_VAR 0 3
61188: PUSH
61189: LD_INT 19
61191: EQUAL
61192: IFFALSE 61202
// sTank := true ;
61194: LD_ADDR_EXP 128
61198: PUSH
61199: LD_INT 1
61201: ST_TO_ADDR
// if p3 = 20 then
61202: LD_VAR 0 3
61206: PUSH
61207: LD_INT 20
61209: EQUAL
61210: IFFALSE 61220
// sRemote := true ;
61212: LD_ADDR_EXP 129
61216: PUSH
61217: LD_INT 1
61219: ST_TO_ADDR
// if p3 = 21 then
61220: LD_VAR 0 3
61224: PUSH
61225: LD_INT 21
61227: EQUAL
61228: IFFALSE 61238
// sPowell := true ;
61230: LD_ADDR_EXP 130
61234: PUSH
61235: LD_INT 1
61237: ST_TO_ADDR
// if p3 = 22 then
61238: LD_VAR 0 3
61242: PUSH
61243: LD_INT 22
61245: EQUAL
61246: IFFALSE 61256
// sTeleport := true ;
61248: LD_ADDR_EXP 133
61252: PUSH
61253: LD_INT 1
61255: ST_TO_ADDR
// if p3 = 23 then
61256: LD_VAR 0 3
61260: PUSH
61261: LD_INT 23
61263: EQUAL
61264: IFFALSE 61274
// sOilTower := true ;
61266: LD_ADDR_EXP 135
61270: PUSH
61271: LD_INT 1
61273: ST_TO_ADDR
// if p3 = 24 then
61274: LD_VAR 0 3
61278: PUSH
61279: LD_INT 24
61281: EQUAL
61282: IFFALSE 61292
// sShovel := true ;
61284: LD_ADDR_EXP 136
61288: PUSH
61289: LD_INT 1
61291: ST_TO_ADDR
// if p3 = 25 then
61292: LD_VAR 0 3
61296: PUSH
61297: LD_INT 25
61299: EQUAL
61300: IFFALSE 61310
// sSheik := true ;
61302: LD_ADDR_EXP 137
61306: PUSH
61307: LD_INT 1
61309: ST_TO_ADDR
// if p3 = 26 then
61310: LD_VAR 0 3
61314: PUSH
61315: LD_INT 26
61317: EQUAL
61318: IFFALSE 61328
// sEarthquake := true ;
61320: LD_ADDR_EXP 139
61324: PUSH
61325: LD_INT 1
61327: ST_TO_ADDR
// if p3 = 27 then
61328: LD_VAR 0 3
61332: PUSH
61333: LD_INT 27
61335: EQUAL
61336: IFFALSE 61346
// sAI := true ;
61338: LD_ADDR_EXP 140
61342: PUSH
61343: LD_INT 1
61345: ST_TO_ADDR
// if p3 = 28 then
61346: LD_VAR 0 3
61350: PUSH
61351: LD_INT 28
61353: EQUAL
61354: IFFALSE 61364
// sCargo := true ;
61356: LD_ADDR_EXP 143
61360: PUSH
61361: LD_INT 1
61363: ST_TO_ADDR
// if p3 = 29 then
61364: LD_VAR 0 3
61368: PUSH
61369: LD_INT 29
61371: EQUAL
61372: IFFALSE 61382
// sDLaser := true ;
61374: LD_ADDR_EXP 144
61378: PUSH
61379: LD_INT 1
61381: ST_TO_ADDR
// if p3 = 30 then
61382: LD_VAR 0 3
61386: PUSH
61387: LD_INT 30
61389: EQUAL
61390: IFFALSE 61400
// sExchange := true ;
61392: LD_ADDR_EXP 145
61396: PUSH
61397: LD_INT 1
61399: ST_TO_ADDR
// if p3 = 31 then
61400: LD_VAR 0 3
61404: PUSH
61405: LD_INT 31
61407: EQUAL
61408: IFFALSE 61418
// sFac := true ;
61410: LD_ADDR_EXP 146
61414: PUSH
61415: LD_INT 1
61417: ST_TO_ADDR
// if p3 = 32 then
61418: LD_VAR 0 3
61422: PUSH
61423: LD_INT 32
61425: EQUAL
61426: IFFALSE 61436
// sPower := true ;
61428: LD_ADDR_EXP 147
61432: PUSH
61433: LD_INT 1
61435: ST_TO_ADDR
// if p3 = 33 then
61436: LD_VAR 0 3
61440: PUSH
61441: LD_INT 33
61443: EQUAL
61444: IFFALSE 61454
// sRandom := true ;
61446: LD_ADDR_EXP 148
61450: PUSH
61451: LD_INT 1
61453: ST_TO_ADDR
// if p3 = 34 then
61454: LD_VAR 0 3
61458: PUSH
61459: LD_INT 34
61461: EQUAL
61462: IFFALSE 61472
// sShield := true ;
61464: LD_ADDR_EXP 149
61468: PUSH
61469: LD_INT 1
61471: ST_TO_ADDR
// if p3 = 35 then
61472: LD_VAR 0 3
61476: PUSH
61477: LD_INT 35
61479: EQUAL
61480: IFFALSE 61490
// sTime := true ;
61482: LD_ADDR_EXP 150
61486: PUSH
61487: LD_INT 1
61489: ST_TO_ADDR
// if p3 = 36 then
61490: LD_VAR 0 3
61494: PUSH
61495: LD_INT 36
61497: EQUAL
61498: IFFALSE 61508
// sTools := true ;
61500: LD_ADDR_EXP 151
61504: PUSH
61505: LD_INT 1
61507: ST_TO_ADDR
// if p3 = 101 then
61508: LD_VAR 0 3
61512: PUSH
61513: LD_INT 101
61515: EQUAL
61516: IFFALSE 61526
// sSold := true ;
61518: LD_ADDR_EXP 116
61522: PUSH
61523: LD_INT 1
61525: ST_TO_ADDR
// if p3 = 102 then
61526: LD_VAR 0 3
61530: PUSH
61531: LD_INT 102
61533: EQUAL
61534: IFFALSE 61544
// sDiff := true ;
61536: LD_ADDR_EXP 117
61540: PUSH
61541: LD_INT 1
61543: ST_TO_ADDR
// if p3 = 103 then
61544: LD_VAR 0 3
61548: PUSH
61549: LD_INT 103
61551: EQUAL
61552: IFFALSE 61562
// sFog := true ;
61554: LD_ADDR_EXP 120
61558: PUSH
61559: LD_INT 1
61561: ST_TO_ADDR
// if p3 = 104 then
61562: LD_VAR 0 3
61566: PUSH
61567: LD_INT 104
61569: EQUAL
61570: IFFALSE 61580
// sReset := true ;
61572: LD_ADDR_EXP 121
61576: PUSH
61577: LD_INT 1
61579: ST_TO_ADDR
// if p3 = 105 then
61580: LD_VAR 0 3
61584: PUSH
61585: LD_INT 105
61587: EQUAL
61588: IFFALSE 61598
// sSun := true ;
61590: LD_ADDR_EXP 122
61594: PUSH
61595: LD_INT 1
61597: ST_TO_ADDR
// if p3 = 106 then
61598: LD_VAR 0 3
61602: PUSH
61603: LD_INT 106
61605: EQUAL
61606: IFFALSE 61616
// sTiger := true ;
61608: LD_ADDR_EXP 118
61612: PUSH
61613: LD_INT 1
61615: ST_TO_ADDR
// if p3 = 107 then
61616: LD_VAR 0 3
61620: PUSH
61621: LD_INT 107
61623: EQUAL
61624: IFFALSE 61634
// sBomb := true ;
61626: LD_ADDR_EXP 119
61630: PUSH
61631: LD_INT 1
61633: ST_TO_ADDR
// if p3 = 108 then
61634: LD_VAR 0 3
61638: PUSH
61639: LD_INT 108
61641: EQUAL
61642: IFFALSE 61652
// sWound := true ;
61644: LD_ADDR_EXP 127
61648: PUSH
61649: LD_INT 1
61651: ST_TO_ADDR
// if p3 = 109 then
61652: LD_VAR 0 3
61656: PUSH
61657: LD_INT 109
61659: EQUAL
61660: IFFALSE 61670
// sBetray := true ;
61662: LD_ADDR_EXP 131
61666: PUSH
61667: LD_INT 1
61669: ST_TO_ADDR
// if p3 = 110 then
61670: LD_VAR 0 3
61674: PUSH
61675: LD_INT 110
61677: EQUAL
61678: IFFALSE 61688
// sContamin := true ;
61680: LD_ADDR_EXP 132
61684: PUSH
61685: LD_INT 1
61687: ST_TO_ADDR
// if p3 = 111 then
61688: LD_VAR 0 3
61692: PUSH
61693: LD_INT 111
61695: EQUAL
61696: IFFALSE 61706
// sOil := true ;
61698: LD_ADDR_EXP 134
61702: PUSH
61703: LD_INT 1
61705: ST_TO_ADDR
// if p3 = 112 then
61706: LD_VAR 0 3
61710: PUSH
61711: LD_INT 112
61713: EQUAL
61714: IFFALSE 61724
// sStu := true ;
61716: LD_ADDR_EXP 138
61720: PUSH
61721: LD_INT 1
61723: ST_TO_ADDR
// if p3 = 113 then
61724: LD_VAR 0 3
61728: PUSH
61729: LD_INT 113
61731: EQUAL
61732: IFFALSE 61742
// sBazooka := true ;
61734: LD_ADDR_EXP 141
61738: PUSH
61739: LD_INT 1
61741: ST_TO_ADDR
// if p3 = 114 then
61742: LD_VAR 0 3
61746: PUSH
61747: LD_INT 114
61749: EQUAL
61750: IFFALSE 61760
// sMortar := true ;
61752: LD_ADDR_EXP 142
61756: PUSH
61757: LD_INT 1
61759: ST_TO_ADDR
// if p3 = 115 then
61760: LD_VAR 0 3
61764: PUSH
61765: LD_INT 115
61767: EQUAL
61768: IFFALSE 61778
// sRanger := true ;
61770: LD_ADDR_EXP 152
61774: PUSH
61775: LD_INT 1
61777: ST_TO_ADDR
// end ; if p2 = 101 then
61778: LD_VAR 0 2
61782: PUSH
61783: LD_INT 101
61785: EQUAL
61786: IFFALSE 61914
// begin case p3 of 1 :
61788: LD_VAR 0 3
61792: PUSH
61793: LD_INT 1
61795: DOUBLE
61796: EQUAL
61797: IFTRUE 61801
61799: GO 61808
61801: POP
// hHackUnlimitedResources ; 2 :
61802: CALL 72949 0 0
61806: GO 61914
61808: LD_INT 2
61810: DOUBLE
61811: EQUAL
61812: IFTRUE 61816
61814: GO 61823
61816: POP
// hHackSetLevel10 ; 3 :
61817: CALL 73082 0 0
61821: GO 61914
61823: LD_INT 3
61825: DOUBLE
61826: EQUAL
61827: IFTRUE 61831
61829: GO 61838
61831: POP
// hHackSetLevel10YourUnits ; 4 :
61832: CALL 73167 0 0
61836: GO 61914
61838: LD_INT 4
61840: DOUBLE
61841: EQUAL
61842: IFTRUE 61846
61844: GO 61853
61846: POP
// hHackInvincible ; 5 :
61847: CALL 73615 0 0
61851: GO 61914
61853: LD_INT 5
61855: DOUBLE
61856: EQUAL
61857: IFTRUE 61861
61859: GO 61868
61861: POP
// hHackInvisible ; 6 :
61862: CALL 73726 0 0
61866: GO 61914
61868: LD_INT 6
61870: DOUBLE
61871: EQUAL
61872: IFTRUE 61876
61874: GO 61883
61876: POP
// hHackChangeYourSide ; 7 :
61877: CALL 73783 0 0
61881: GO 61914
61883: LD_INT 7
61885: DOUBLE
61886: EQUAL
61887: IFTRUE 61891
61889: GO 61898
61891: POP
// hHackChangeUnitSide ; 8 :
61892: CALL 73825 0 0
61896: GO 61914
61898: LD_INT 8
61900: DOUBLE
61901: EQUAL
61902: IFTRUE 61906
61904: GO 61913
61906: POP
// hHackFog ; end ;
61907: CALL 73926 0 0
61911: GO 61914
61913: POP
// end ; end ;
61914: PPOPN 6
61916: END
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger ; every 0 0$1 do
61917: GO 61919
61919: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
61920: LD_STRING initStreamRollete();
61922: PPUSH
61923: CALL_OW 559
// InitStreamMode ;
61927: CALL 61936 0 0
// DefineStreamItems ( ) ;
61931: CALL 62376 0 0
// end ;
61935: END
// function InitStreamMode ; begin
61936: LD_INT 0
61938: PPUSH
// streamModeActive := false ;
61939: LD_ADDR_EXP 99
61943: PUSH
61944: LD_INT 0
61946: ST_TO_ADDR
// normalCounter := 36 ;
61947: LD_ADDR_EXP 100
61951: PUSH
61952: LD_INT 36
61954: ST_TO_ADDR
// hardcoreCounter := 16 ;
61955: LD_ADDR_EXP 101
61959: PUSH
61960: LD_INT 16
61962: ST_TO_ADDR
// sRocket := false ;
61963: LD_ADDR_EXP 104
61967: PUSH
61968: LD_INT 0
61970: ST_TO_ADDR
// sSpeed := false ;
61971: LD_ADDR_EXP 103
61975: PUSH
61976: LD_INT 0
61978: ST_TO_ADDR
// sEngine := false ;
61979: LD_ADDR_EXP 105
61983: PUSH
61984: LD_INT 0
61986: ST_TO_ADDR
// sSpec := false ;
61987: LD_ADDR_EXP 102
61991: PUSH
61992: LD_INT 0
61994: ST_TO_ADDR
// sLevel := false ;
61995: LD_ADDR_EXP 106
61999: PUSH
62000: LD_INT 0
62002: ST_TO_ADDR
// sArmoury := false ;
62003: LD_ADDR_EXP 107
62007: PUSH
62008: LD_INT 0
62010: ST_TO_ADDR
// sRadar := false ;
62011: LD_ADDR_EXP 108
62015: PUSH
62016: LD_INT 0
62018: ST_TO_ADDR
// sBunker := false ;
62019: LD_ADDR_EXP 109
62023: PUSH
62024: LD_INT 0
62026: ST_TO_ADDR
// sHack := false ;
62027: LD_ADDR_EXP 110
62031: PUSH
62032: LD_INT 0
62034: ST_TO_ADDR
// sFire := false ;
62035: LD_ADDR_EXP 111
62039: PUSH
62040: LD_INT 0
62042: ST_TO_ADDR
// sRefresh := false ;
62043: LD_ADDR_EXP 112
62047: PUSH
62048: LD_INT 0
62050: ST_TO_ADDR
// sExp := false ;
62051: LD_ADDR_EXP 113
62055: PUSH
62056: LD_INT 0
62058: ST_TO_ADDR
// sDepot := false ;
62059: LD_ADDR_EXP 114
62063: PUSH
62064: LD_INT 0
62066: ST_TO_ADDR
// sFlag := false ;
62067: LD_ADDR_EXP 115
62071: PUSH
62072: LD_INT 0
62074: ST_TO_ADDR
// sKamikadze := false ;
62075: LD_ADDR_EXP 123
62079: PUSH
62080: LD_INT 0
62082: ST_TO_ADDR
// sTroll := false ;
62083: LD_ADDR_EXP 124
62087: PUSH
62088: LD_INT 0
62090: ST_TO_ADDR
// sSlow := false ;
62091: LD_ADDR_EXP 125
62095: PUSH
62096: LD_INT 0
62098: ST_TO_ADDR
// sLack := false ;
62099: LD_ADDR_EXP 126
62103: PUSH
62104: LD_INT 0
62106: ST_TO_ADDR
// sTank := false ;
62107: LD_ADDR_EXP 128
62111: PUSH
62112: LD_INT 0
62114: ST_TO_ADDR
// sRemote := false ;
62115: LD_ADDR_EXP 129
62119: PUSH
62120: LD_INT 0
62122: ST_TO_ADDR
// sPowell := false ;
62123: LD_ADDR_EXP 130
62127: PUSH
62128: LD_INT 0
62130: ST_TO_ADDR
// sTeleport := false ;
62131: LD_ADDR_EXP 133
62135: PUSH
62136: LD_INT 0
62138: ST_TO_ADDR
// sOilTower := false ;
62139: LD_ADDR_EXP 135
62143: PUSH
62144: LD_INT 0
62146: ST_TO_ADDR
// sShovel := false ;
62147: LD_ADDR_EXP 136
62151: PUSH
62152: LD_INT 0
62154: ST_TO_ADDR
// sSheik := false ;
62155: LD_ADDR_EXP 137
62159: PUSH
62160: LD_INT 0
62162: ST_TO_ADDR
// sEarthquake := false ;
62163: LD_ADDR_EXP 139
62167: PUSH
62168: LD_INT 0
62170: ST_TO_ADDR
// sAI := false ;
62171: LD_ADDR_EXP 140
62175: PUSH
62176: LD_INT 0
62178: ST_TO_ADDR
// sCargo := false ;
62179: LD_ADDR_EXP 143
62183: PUSH
62184: LD_INT 0
62186: ST_TO_ADDR
// sDLaser := false ;
62187: LD_ADDR_EXP 144
62191: PUSH
62192: LD_INT 0
62194: ST_TO_ADDR
// sExchange := false ;
62195: LD_ADDR_EXP 145
62199: PUSH
62200: LD_INT 0
62202: ST_TO_ADDR
// sFac := false ;
62203: LD_ADDR_EXP 146
62207: PUSH
62208: LD_INT 0
62210: ST_TO_ADDR
// sPower := false ;
62211: LD_ADDR_EXP 147
62215: PUSH
62216: LD_INT 0
62218: ST_TO_ADDR
// sRandom := false ;
62219: LD_ADDR_EXP 148
62223: PUSH
62224: LD_INT 0
62226: ST_TO_ADDR
// sShield := false ;
62227: LD_ADDR_EXP 149
62231: PUSH
62232: LD_INT 0
62234: ST_TO_ADDR
// sTime := false ;
62235: LD_ADDR_EXP 150
62239: PUSH
62240: LD_INT 0
62242: ST_TO_ADDR
// sTools := false ;
62243: LD_ADDR_EXP 151
62247: PUSH
62248: LD_INT 0
62250: ST_TO_ADDR
// sSold := false ;
62251: LD_ADDR_EXP 116
62255: PUSH
62256: LD_INT 0
62258: ST_TO_ADDR
// sDiff := false ;
62259: LD_ADDR_EXP 117
62263: PUSH
62264: LD_INT 0
62266: ST_TO_ADDR
// sFog := false ;
62267: LD_ADDR_EXP 120
62271: PUSH
62272: LD_INT 0
62274: ST_TO_ADDR
// sReset := false ;
62275: LD_ADDR_EXP 121
62279: PUSH
62280: LD_INT 0
62282: ST_TO_ADDR
// sSun := false ;
62283: LD_ADDR_EXP 122
62287: PUSH
62288: LD_INT 0
62290: ST_TO_ADDR
// sTiger := false ;
62291: LD_ADDR_EXP 118
62295: PUSH
62296: LD_INT 0
62298: ST_TO_ADDR
// sBomb := false ;
62299: LD_ADDR_EXP 119
62303: PUSH
62304: LD_INT 0
62306: ST_TO_ADDR
// sWound := false ;
62307: LD_ADDR_EXP 127
62311: PUSH
62312: LD_INT 0
62314: ST_TO_ADDR
// sBetray := false ;
62315: LD_ADDR_EXP 131
62319: PUSH
62320: LD_INT 0
62322: ST_TO_ADDR
// sContamin := false ;
62323: LD_ADDR_EXP 132
62327: PUSH
62328: LD_INT 0
62330: ST_TO_ADDR
// sOil := false ;
62331: LD_ADDR_EXP 134
62335: PUSH
62336: LD_INT 0
62338: ST_TO_ADDR
// sStu := false ;
62339: LD_ADDR_EXP 138
62343: PUSH
62344: LD_INT 0
62346: ST_TO_ADDR
// sBazooka := false ;
62347: LD_ADDR_EXP 141
62351: PUSH
62352: LD_INT 0
62354: ST_TO_ADDR
// sMortar := false ;
62355: LD_ADDR_EXP 142
62359: PUSH
62360: LD_INT 0
62362: ST_TO_ADDR
// sRanger := false ;
62363: LD_ADDR_EXP 152
62367: PUSH
62368: LD_INT 0
62370: ST_TO_ADDR
// end ;
62371: LD_VAR 0 1
62375: RET
// function DefineStreamItems ( ) ; var tmp , normal , hardcore , i ; begin
62376: LD_INT 0
62378: PPUSH
62379: PPUSH
62380: PPUSH
62381: PPUSH
62382: PPUSH
// result := [ ] ;
62383: LD_ADDR_VAR 0 1
62387: PUSH
62388: EMPTY
62389: ST_TO_ADDR
// if campaign_id = 1 then
62390: LD_OWVAR 69
62394: PUSH
62395: LD_INT 1
62397: EQUAL
62398: IFFALSE 65336
// begin case mission_number of 1 :
62400: LD_OWVAR 70
62404: PUSH
62405: LD_INT 1
62407: DOUBLE
62408: EQUAL
62409: IFTRUE 62413
62411: GO 62477
62413: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 ] ] ; 2 :
62414: LD_ADDR_VAR 0 1
62418: PUSH
62419: LD_INT 2
62421: PUSH
62422: LD_INT 4
62424: PUSH
62425: LD_INT 11
62427: PUSH
62428: LD_INT 12
62430: PUSH
62431: LD_INT 15
62433: PUSH
62434: LD_INT 16
62436: PUSH
62437: LD_INT 22
62439: PUSH
62440: LD_INT 23
62442: PUSH
62443: LD_INT 26
62445: PUSH
62446: EMPTY
62447: LIST
62448: LIST
62449: LIST
62450: LIST
62451: LIST
62452: LIST
62453: LIST
62454: LIST
62455: LIST
62456: PUSH
62457: LD_INT 101
62459: PUSH
62460: LD_INT 102
62462: PUSH
62463: LD_INT 106
62465: PUSH
62466: EMPTY
62467: LIST
62468: LIST
62469: LIST
62470: PUSH
62471: EMPTY
62472: LIST
62473: LIST
62474: ST_TO_ADDR
62475: GO 65334
62477: LD_INT 2
62479: DOUBLE
62480: EQUAL
62481: IFTRUE 62485
62483: GO 62557
62485: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 3 :
62486: LD_ADDR_VAR 0 1
62490: PUSH
62491: LD_INT 2
62493: PUSH
62494: LD_INT 4
62496: PUSH
62497: LD_INT 11
62499: PUSH
62500: LD_INT 12
62502: PUSH
62503: LD_INT 15
62505: PUSH
62506: LD_INT 16
62508: PUSH
62509: LD_INT 22
62511: PUSH
62512: LD_INT 23
62514: PUSH
62515: LD_INT 26
62517: PUSH
62518: EMPTY
62519: LIST
62520: LIST
62521: LIST
62522: LIST
62523: LIST
62524: LIST
62525: LIST
62526: LIST
62527: LIST
62528: PUSH
62529: LD_INT 101
62531: PUSH
62532: LD_INT 102
62534: PUSH
62535: LD_INT 105
62537: PUSH
62538: LD_INT 106
62540: PUSH
62541: LD_INT 108
62543: PUSH
62544: EMPTY
62545: LIST
62546: LIST
62547: LIST
62548: LIST
62549: LIST
62550: PUSH
62551: EMPTY
62552: LIST
62553: LIST
62554: ST_TO_ADDR
62555: GO 65334
62557: LD_INT 3
62559: DOUBLE
62560: EQUAL
62561: IFTRUE 62565
62563: GO 62641
62565: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 4 :
62566: LD_ADDR_VAR 0 1
62570: PUSH
62571: LD_INT 2
62573: PUSH
62574: LD_INT 4
62576: PUSH
62577: LD_INT 5
62579: PUSH
62580: LD_INT 11
62582: PUSH
62583: LD_INT 12
62585: PUSH
62586: LD_INT 15
62588: PUSH
62589: LD_INT 16
62591: PUSH
62592: LD_INT 22
62594: PUSH
62595: LD_INT 26
62597: PUSH
62598: LD_INT 36
62600: PUSH
62601: EMPTY
62602: LIST
62603: LIST
62604: LIST
62605: LIST
62606: LIST
62607: LIST
62608: LIST
62609: LIST
62610: LIST
62611: LIST
62612: PUSH
62613: LD_INT 101
62615: PUSH
62616: LD_INT 102
62618: PUSH
62619: LD_INT 105
62621: PUSH
62622: LD_INT 106
62624: PUSH
62625: LD_INT 108
62627: PUSH
62628: EMPTY
62629: LIST
62630: LIST
62631: LIST
62632: LIST
62633: LIST
62634: PUSH
62635: EMPTY
62636: LIST
62637: LIST
62638: ST_TO_ADDR
62639: GO 65334
62641: LD_INT 4
62643: DOUBLE
62644: EQUAL
62645: IFTRUE 62649
62647: GO 62733
62649: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 5 :
62650: LD_ADDR_VAR 0 1
62654: PUSH
62655: LD_INT 2
62657: PUSH
62658: LD_INT 4
62660: PUSH
62661: LD_INT 5
62663: PUSH
62664: LD_INT 8
62666: PUSH
62667: LD_INT 11
62669: PUSH
62670: LD_INT 12
62672: PUSH
62673: LD_INT 15
62675: PUSH
62676: LD_INT 16
62678: PUSH
62679: LD_INT 22
62681: PUSH
62682: LD_INT 23
62684: PUSH
62685: LD_INT 26
62687: PUSH
62688: LD_INT 36
62690: PUSH
62691: EMPTY
62692: LIST
62693: LIST
62694: LIST
62695: LIST
62696: LIST
62697: LIST
62698: LIST
62699: LIST
62700: LIST
62701: LIST
62702: LIST
62703: LIST
62704: PUSH
62705: LD_INT 101
62707: PUSH
62708: LD_INT 102
62710: PUSH
62711: LD_INT 105
62713: PUSH
62714: LD_INT 106
62716: PUSH
62717: LD_INT 108
62719: PUSH
62720: EMPTY
62721: LIST
62722: LIST
62723: LIST
62724: LIST
62725: LIST
62726: PUSH
62727: EMPTY
62728: LIST
62729: LIST
62730: ST_TO_ADDR
62731: GO 65334
62733: LD_INT 5
62735: DOUBLE
62736: EQUAL
62737: IFTRUE 62741
62739: GO 62841
62741: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 6 :
62742: LD_ADDR_VAR 0 1
62746: PUSH
62747: LD_INT 2
62749: PUSH
62750: LD_INT 4
62752: PUSH
62753: LD_INT 5
62755: PUSH
62756: LD_INT 6
62758: PUSH
62759: LD_INT 8
62761: PUSH
62762: LD_INT 11
62764: PUSH
62765: LD_INT 12
62767: PUSH
62768: LD_INT 15
62770: PUSH
62771: LD_INT 16
62773: PUSH
62774: LD_INT 22
62776: PUSH
62777: LD_INT 23
62779: PUSH
62780: LD_INT 25
62782: PUSH
62783: LD_INT 26
62785: PUSH
62786: LD_INT 36
62788: PUSH
62789: EMPTY
62790: LIST
62791: LIST
62792: LIST
62793: LIST
62794: LIST
62795: LIST
62796: LIST
62797: LIST
62798: LIST
62799: LIST
62800: LIST
62801: LIST
62802: LIST
62803: LIST
62804: PUSH
62805: LD_INT 101
62807: PUSH
62808: LD_INT 102
62810: PUSH
62811: LD_INT 105
62813: PUSH
62814: LD_INT 106
62816: PUSH
62817: LD_INT 108
62819: PUSH
62820: LD_INT 109
62822: PUSH
62823: LD_INT 112
62825: PUSH
62826: EMPTY
62827: LIST
62828: LIST
62829: LIST
62830: LIST
62831: LIST
62832: LIST
62833: LIST
62834: PUSH
62835: EMPTY
62836: LIST
62837: LIST
62838: ST_TO_ADDR
62839: GO 65334
62841: LD_INT 6
62843: DOUBLE
62844: EQUAL
62845: IFTRUE 62849
62847: GO 62969
62849: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 7 :
62850: LD_ADDR_VAR 0 1
62854: PUSH
62855: LD_INT 2
62857: PUSH
62858: LD_INT 4
62860: PUSH
62861: LD_INT 5
62863: PUSH
62864: LD_INT 6
62866: PUSH
62867: LD_INT 8
62869: PUSH
62870: LD_INT 11
62872: PUSH
62873: LD_INT 12
62875: PUSH
62876: LD_INT 15
62878: PUSH
62879: LD_INT 16
62881: PUSH
62882: LD_INT 20
62884: PUSH
62885: LD_INT 21
62887: PUSH
62888: LD_INT 22
62890: PUSH
62891: LD_INT 23
62893: PUSH
62894: LD_INT 25
62896: PUSH
62897: LD_INT 26
62899: PUSH
62900: LD_INT 30
62902: PUSH
62903: LD_INT 31
62905: PUSH
62906: LD_INT 32
62908: PUSH
62909: LD_INT 36
62911: PUSH
62912: EMPTY
62913: LIST
62914: LIST
62915: LIST
62916: LIST
62917: LIST
62918: LIST
62919: LIST
62920: LIST
62921: LIST
62922: LIST
62923: LIST
62924: LIST
62925: LIST
62926: LIST
62927: LIST
62928: LIST
62929: LIST
62930: LIST
62931: LIST
62932: PUSH
62933: LD_INT 101
62935: PUSH
62936: LD_INT 102
62938: PUSH
62939: LD_INT 105
62941: PUSH
62942: LD_INT 106
62944: PUSH
62945: LD_INT 108
62947: PUSH
62948: LD_INT 109
62950: PUSH
62951: LD_INT 112
62953: PUSH
62954: EMPTY
62955: LIST
62956: LIST
62957: LIST
62958: LIST
62959: LIST
62960: LIST
62961: LIST
62962: PUSH
62963: EMPTY
62964: LIST
62965: LIST
62966: ST_TO_ADDR
62967: GO 65334
62969: LD_INT 7
62971: DOUBLE
62972: EQUAL
62973: IFTRUE 62977
62975: GO 63077
62977: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 ] ] ; 8 :
62978: LD_ADDR_VAR 0 1
62982: PUSH
62983: LD_INT 2
62985: PUSH
62986: LD_INT 4
62988: PUSH
62989: LD_INT 5
62991: PUSH
62992: LD_INT 7
62994: PUSH
62995: LD_INT 11
62997: PUSH
62998: LD_INT 12
63000: PUSH
63001: LD_INT 15
63003: PUSH
63004: LD_INT 16
63006: PUSH
63007: LD_INT 20
63009: PUSH
63010: LD_INT 21
63012: PUSH
63013: LD_INT 22
63015: PUSH
63016: LD_INT 23
63018: PUSH
63019: LD_INT 25
63021: PUSH
63022: LD_INT 26
63024: PUSH
63025: EMPTY
63026: LIST
63027: LIST
63028: LIST
63029: LIST
63030: LIST
63031: LIST
63032: LIST
63033: LIST
63034: LIST
63035: LIST
63036: LIST
63037: LIST
63038: LIST
63039: LIST
63040: PUSH
63041: LD_INT 101
63043: PUSH
63044: LD_INT 102
63046: PUSH
63047: LD_INT 103
63049: PUSH
63050: LD_INT 105
63052: PUSH
63053: LD_INT 106
63055: PUSH
63056: LD_INT 108
63058: PUSH
63059: LD_INT 112
63061: PUSH
63062: EMPTY
63063: LIST
63064: LIST
63065: LIST
63066: LIST
63067: LIST
63068: LIST
63069: LIST
63070: PUSH
63071: EMPTY
63072: LIST
63073: LIST
63074: ST_TO_ADDR
63075: GO 65334
63077: LD_INT 8
63079: DOUBLE
63080: EQUAL
63081: IFTRUE 63085
63083: GO 63213
63085: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 ] ] ; 9 :
63086: LD_ADDR_VAR 0 1
63090: PUSH
63091: LD_INT 2
63093: PUSH
63094: LD_INT 4
63096: PUSH
63097: LD_INT 5
63099: PUSH
63100: LD_INT 6
63102: PUSH
63103: LD_INT 7
63105: PUSH
63106: LD_INT 8
63108: PUSH
63109: LD_INT 11
63111: PUSH
63112: LD_INT 12
63114: PUSH
63115: LD_INT 15
63117: PUSH
63118: LD_INT 16
63120: PUSH
63121: LD_INT 20
63123: PUSH
63124: LD_INT 21
63126: PUSH
63127: LD_INT 22
63129: PUSH
63130: LD_INT 23
63132: PUSH
63133: LD_INT 25
63135: PUSH
63136: LD_INT 26
63138: PUSH
63139: LD_INT 30
63141: PUSH
63142: LD_INT 31
63144: PUSH
63145: LD_INT 32
63147: PUSH
63148: LD_INT 36
63150: PUSH
63151: EMPTY
63152: LIST
63153: LIST
63154: LIST
63155: LIST
63156: LIST
63157: LIST
63158: LIST
63159: LIST
63160: LIST
63161: LIST
63162: LIST
63163: LIST
63164: LIST
63165: LIST
63166: LIST
63167: LIST
63168: LIST
63169: LIST
63170: LIST
63171: LIST
63172: PUSH
63173: LD_INT 101
63175: PUSH
63176: LD_INT 102
63178: PUSH
63179: LD_INT 103
63181: PUSH
63182: LD_INT 105
63184: PUSH
63185: LD_INT 106
63187: PUSH
63188: LD_INT 108
63190: PUSH
63191: LD_INT 109
63193: PUSH
63194: LD_INT 112
63196: PUSH
63197: EMPTY
63198: LIST
63199: LIST
63200: LIST
63201: LIST
63202: LIST
63203: LIST
63204: LIST
63205: LIST
63206: PUSH
63207: EMPTY
63208: LIST
63209: LIST
63210: ST_TO_ADDR
63211: GO 65334
63213: LD_INT 9
63215: DOUBLE
63216: EQUAL
63217: IFTRUE 63221
63219: GO 63357
63221: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 ] ] ; 10 :
63222: LD_ADDR_VAR 0 1
63226: PUSH
63227: LD_INT 2
63229: PUSH
63230: LD_INT 4
63232: PUSH
63233: LD_INT 5
63235: PUSH
63236: LD_INT 6
63238: PUSH
63239: LD_INT 7
63241: PUSH
63242: LD_INT 8
63244: PUSH
63245: LD_INT 11
63247: PUSH
63248: LD_INT 12
63250: PUSH
63251: LD_INT 15
63253: PUSH
63254: LD_INT 16
63256: PUSH
63257: LD_INT 20
63259: PUSH
63260: LD_INT 21
63262: PUSH
63263: LD_INT 22
63265: PUSH
63266: LD_INT 23
63268: PUSH
63269: LD_INT 25
63271: PUSH
63272: LD_INT 26
63274: PUSH
63275: LD_INT 28
63277: PUSH
63278: LD_INT 30
63280: PUSH
63281: LD_INT 31
63283: PUSH
63284: LD_INT 32
63286: PUSH
63287: LD_INT 36
63289: PUSH
63290: EMPTY
63291: LIST
63292: LIST
63293: LIST
63294: LIST
63295: LIST
63296: LIST
63297: LIST
63298: LIST
63299: LIST
63300: LIST
63301: LIST
63302: LIST
63303: LIST
63304: LIST
63305: LIST
63306: LIST
63307: LIST
63308: LIST
63309: LIST
63310: LIST
63311: LIST
63312: PUSH
63313: LD_INT 101
63315: PUSH
63316: LD_INT 102
63318: PUSH
63319: LD_INT 103
63321: PUSH
63322: LD_INT 105
63324: PUSH
63325: LD_INT 106
63327: PUSH
63328: LD_INT 108
63330: PUSH
63331: LD_INT 109
63333: PUSH
63334: LD_INT 112
63336: PUSH
63337: LD_INT 114
63339: PUSH
63340: EMPTY
63341: LIST
63342: LIST
63343: LIST
63344: LIST
63345: LIST
63346: LIST
63347: LIST
63348: LIST
63349: LIST
63350: PUSH
63351: EMPTY
63352: LIST
63353: LIST
63354: ST_TO_ADDR
63355: GO 65334
63357: LD_INT 10
63359: DOUBLE
63360: EQUAL
63361: IFTRUE 63365
63363: GO 63549
63365: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 11 :
63366: LD_ADDR_VAR 0 1
63370: PUSH
63371: LD_INT 2
63373: PUSH
63374: LD_INT 4
63376: PUSH
63377: LD_INT 5
63379: PUSH
63380: LD_INT 6
63382: PUSH
63383: LD_INT 7
63385: PUSH
63386: LD_INT 8
63388: PUSH
63389: LD_INT 9
63391: PUSH
63392: LD_INT 10
63394: PUSH
63395: LD_INT 11
63397: PUSH
63398: LD_INT 12
63400: PUSH
63401: LD_INT 13
63403: PUSH
63404: LD_INT 14
63406: PUSH
63407: LD_INT 15
63409: PUSH
63410: LD_INT 16
63412: PUSH
63413: LD_INT 17
63415: PUSH
63416: LD_INT 18
63418: PUSH
63419: LD_INT 19
63421: PUSH
63422: LD_INT 20
63424: PUSH
63425: LD_INT 21
63427: PUSH
63428: LD_INT 22
63430: PUSH
63431: LD_INT 23
63433: PUSH
63434: LD_INT 24
63436: PUSH
63437: LD_INT 25
63439: PUSH
63440: LD_INT 26
63442: PUSH
63443: LD_INT 28
63445: PUSH
63446: LD_INT 30
63448: PUSH
63449: LD_INT 31
63451: PUSH
63452: LD_INT 32
63454: PUSH
63455: LD_INT 36
63457: PUSH
63458: EMPTY
63459: LIST
63460: LIST
63461: LIST
63462: LIST
63463: LIST
63464: LIST
63465: LIST
63466: LIST
63467: LIST
63468: LIST
63469: LIST
63470: LIST
63471: LIST
63472: LIST
63473: LIST
63474: LIST
63475: LIST
63476: LIST
63477: LIST
63478: LIST
63479: LIST
63480: LIST
63481: LIST
63482: LIST
63483: LIST
63484: LIST
63485: LIST
63486: LIST
63487: LIST
63488: PUSH
63489: LD_INT 101
63491: PUSH
63492: LD_INT 102
63494: PUSH
63495: LD_INT 103
63497: PUSH
63498: LD_INT 104
63500: PUSH
63501: LD_INT 105
63503: PUSH
63504: LD_INT 106
63506: PUSH
63507: LD_INT 107
63509: PUSH
63510: LD_INT 108
63512: PUSH
63513: LD_INT 109
63515: PUSH
63516: LD_INT 110
63518: PUSH
63519: LD_INT 111
63521: PUSH
63522: LD_INT 112
63524: PUSH
63525: LD_INT 114
63527: PUSH
63528: EMPTY
63529: LIST
63530: LIST
63531: LIST
63532: LIST
63533: LIST
63534: LIST
63535: LIST
63536: LIST
63537: LIST
63538: LIST
63539: LIST
63540: LIST
63541: LIST
63542: PUSH
63543: EMPTY
63544: LIST
63545: LIST
63546: ST_TO_ADDR
63547: GO 65334
63549: LD_INT 11
63551: DOUBLE
63552: EQUAL
63553: IFTRUE 63557
63555: GO 63749
63557: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 12 :
63558: LD_ADDR_VAR 0 1
63562: PUSH
63563: LD_INT 2
63565: PUSH
63566: LD_INT 3
63568: PUSH
63569: LD_INT 4
63571: PUSH
63572: LD_INT 5
63574: PUSH
63575: LD_INT 6
63577: PUSH
63578: LD_INT 7
63580: PUSH
63581: LD_INT 8
63583: PUSH
63584: LD_INT 9
63586: PUSH
63587: LD_INT 10
63589: PUSH
63590: LD_INT 11
63592: PUSH
63593: LD_INT 12
63595: PUSH
63596: LD_INT 13
63598: PUSH
63599: LD_INT 14
63601: PUSH
63602: LD_INT 15
63604: PUSH
63605: LD_INT 16
63607: PUSH
63608: LD_INT 17
63610: PUSH
63611: LD_INT 18
63613: PUSH
63614: LD_INT 19
63616: PUSH
63617: LD_INT 20
63619: PUSH
63620: LD_INT 21
63622: PUSH
63623: LD_INT 22
63625: PUSH
63626: LD_INT 23
63628: PUSH
63629: LD_INT 24
63631: PUSH
63632: LD_INT 25
63634: PUSH
63635: LD_INT 26
63637: PUSH
63638: LD_INT 28
63640: PUSH
63641: LD_INT 30
63643: PUSH
63644: LD_INT 31
63646: PUSH
63647: LD_INT 32
63649: PUSH
63650: LD_INT 34
63652: PUSH
63653: LD_INT 36
63655: PUSH
63656: EMPTY
63657: LIST
63658: LIST
63659: LIST
63660: LIST
63661: LIST
63662: LIST
63663: LIST
63664: LIST
63665: LIST
63666: LIST
63667: LIST
63668: LIST
63669: LIST
63670: LIST
63671: LIST
63672: LIST
63673: LIST
63674: LIST
63675: LIST
63676: LIST
63677: LIST
63678: LIST
63679: LIST
63680: LIST
63681: LIST
63682: LIST
63683: LIST
63684: LIST
63685: LIST
63686: LIST
63687: LIST
63688: PUSH
63689: LD_INT 101
63691: PUSH
63692: LD_INT 102
63694: PUSH
63695: LD_INT 103
63697: PUSH
63698: LD_INT 104
63700: PUSH
63701: LD_INT 105
63703: PUSH
63704: LD_INT 106
63706: PUSH
63707: LD_INT 107
63709: PUSH
63710: LD_INT 108
63712: PUSH
63713: LD_INT 109
63715: PUSH
63716: LD_INT 110
63718: PUSH
63719: LD_INT 111
63721: PUSH
63722: LD_INT 112
63724: PUSH
63725: LD_INT 114
63727: PUSH
63728: EMPTY
63729: LIST
63730: LIST
63731: LIST
63732: LIST
63733: LIST
63734: LIST
63735: LIST
63736: LIST
63737: LIST
63738: LIST
63739: LIST
63740: LIST
63741: LIST
63742: PUSH
63743: EMPTY
63744: LIST
63745: LIST
63746: ST_TO_ADDR
63747: GO 65334
63749: LD_INT 12
63751: DOUBLE
63752: EQUAL
63753: IFTRUE 63757
63755: GO 63965
63757: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 13 :
63758: LD_ADDR_VAR 0 1
63762: PUSH
63763: LD_INT 1
63765: PUSH
63766: LD_INT 2
63768: PUSH
63769: LD_INT 3
63771: PUSH
63772: LD_INT 4
63774: PUSH
63775: LD_INT 5
63777: PUSH
63778: LD_INT 6
63780: PUSH
63781: LD_INT 7
63783: PUSH
63784: LD_INT 8
63786: PUSH
63787: LD_INT 9
63789: PUSH
63790: LD_INT 10
63792: PUSH
63793: LD_INT 11
63795: PUSH
63796: LD_INT 12
63798: PUSH
63799: LD_INT 13
63801: PUSH
63802: LD_INT 14
63804: PUSH
63805: LD_INT 15
63807: PUSH
63808: LD_INT 16
63810: PUSH
63811: LD_INT 17
63813: PUSH
63814: LD_INT 18
63816: PUSH
63817: LD_INT 19
63819: PUSH
63820: LD_INT 20
63822: PUSH
63823: LD_INT 21
63825: PUSH
63826: LD_INT 22
63828: PUSH
63829: LD_INT 23
63831: PUSH
63832: LD_INT 24
63834: PUSH
63835: LD_INT 25
63837: PUSH
63838: LD_INT 26
63840: PUSH
63841: LD_INT 27
63843: PUSH
63844: LD_INT 28
63846: PUSH
63847: LD_INT 30
63849: PUSH
63850: LD_INT 31
63852: PUSH
63853: LD_INT 32
63855: PUSH
63856: LD_INT 33
63858: PUSH
63859: LD_INT 34
63861: PUSH
63862: LD_INT 36
63864: PUSH
63865: EMPTY
63866: LIST
63867: LIST
63868: LIST
63869: LIST
63870: LIST
63871: LIST
63872: LIST
63873: LIST
63874: LIST
63875: LIST
63876: LIST
63877: LIST
63878: LIST
63879: LIST
63880: LIST
63881: LIST
63882: LIST
63883: LIST
63884: LIST
63885: LIST
63886: LIST
63887: LIST
63888: LIST
63889: LIST
63890: LIST
63891: LIST
63892: LIST
63893: LIST
63894: LIST
63895: LIST
63896: LIST
63897: LIST
63898: LIST
63899: LIST
63900: PUSH
63901: LD_INT 101
63903: PUSH
63904: LD_INT 102
63906: PUSH
63907: LD_INT 103
63909: PUSH
63910: LD_INT 104
63912: PUSH
63913: LD_INT 105
63915: PUSH
63916: LD_INT 106
63918: PUSH
63919: LD_INT 107
63921: PUSH
63922: LD_INT 108
63924: PUSH
63925: LD_INT 109
63927: PUSH
63928: LD_INT 110
63930: PUSH
63931: LD_INT 111
63933: PUSH
63934: LD_INT 112
63936: PUSH
63937: LD_INT 113
63939: PUSH
63940: LD_INT 114
63942: PUSH
63943: EMPTY
63944: LIST
63945: LIST
63946: LIST
63947: LIST
63948: LIST
63949: LIST
63950: LIST
63951: LIST
63952: LIST
63953: LIST
63954: LIST
63955: LIST
63956: LIST
63957: LIST
63958: PUSH
63959: EMPTY
63960: LIST
63961: LIST
63962: ST_TO_ADDR
63963: GO 65334
63965: LD_INT 13
63967: DOUBLE
63968: EQUAL
63969: IFTRUE 63973
63971: GO 64169
63973: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 14 :
63974: LD_ADDR_VAR 0 1
63978: PUSH
63979: LD_INT 1
63981: PUSH
63982: LD_INT 2
63984: PUSH
63985: LD_INT 3
63987: PUSH
63988: LD_INT 4
63990: PUSH
63991: LD_INT 5
63993: PUSH
63994: LD_INT 8
63996: PUSH
63997: LD_INT 9
63999: PUSH
64000: LD_INT 10
64002: PUSH
64003: LD_INT 11
64005: PUSH
64006: LD_INT 12
64008: PUSH
64009: LD_INT 14
64011: PUSH
64012: LD_INT 15
64014: PUSH
64015: LD_INT 16
64017: PUSH
64018: LD_INT 17
64020: PUSH
64021: LD_INT 18
64023: PUSH
64024: LD_INT 19
64026: PUSH
64027: LD_INT 20
64029: PUSH
64030: LD_INT 21
64032: PUSH
64033: LD_INT 22
64035: PUSH
64036: LD_INT 23
64038: PUSH
64039: LD_INT 24
64041: PUSH
64042: LD_INT 25
64044: PUSH
64045: LD_INT 26
64047: PUSH
64048: LD_INT 27
64050: PUSH
64051: LD_INT 28
64053: PUSH
64054: LD_INT 30
64056: PUSH
64057: LD_INT 31
64059: PUSH
64060: LD_INT 32
64062: PUSH
64063: LD_INT 33
64065: PUSH
64066: LD_INT 34
64068: PUSH
64069: LD_INT 36
64071: PUSH
64072: EMPTY
64073: LIST
64074: LIST
64075: LIST
64076: LIST
64077: LIST
64078: LIST
64079: LIST
64080: LIST
64081: LIST
64082: LIST
64083: LIST
64084: LIST
64085: LIST
64086: LIST
64087: LIST
64088: LIST
64089: LIST
64090: LIST
64091: LIST
64092: LIST
64093: LIST
64094: LIST
64095: LIST
64096: LIST
64097: LIST
64098: LIST
64099: LIST
64100: LIST
64101: LIST
64102: LIST
64103: LIST
64104: PUSH
64105: LD_INT 101
64107: PUSH
64108: LD_INT 102
64110: PUSH
64111: LD_INT 103
64113: PUSH
64114: LD_INT 104
64116: PUSH
64117: LD_INT 105
64119: PUSH
64120: LD_INT 106
64122: PUSH
64123: LD_INT 107
64125: PUSH
64126: LD_INT 108
64128: PUSH
64129: LD_INT 109
64131: PUSH
64132: LD_INT 110
64134: PUSH
64135: LD_INT 111
64137: PUSH
64138: LD_INT 112
64140: PUSH
64141: LD_INT 113
64143: PUSH
64144: LD_INT 114
64146: PUSH
64147: EMPTY
64148: LIST
64149: LIST
64150: LIST
64151: LIST
64152: LIST
64153: LIST
64154: LIST
64155: LIST
64156: LIST
64157: LIST
64158: LIST
64159: LIST
64160: LIST
64161: LIST
64162: PUSH
64163: EMPTY
64164: LIST
64165: LIST
64166: ST_TO_ADDR
64167: GO 65334
64169: LD_INT 14
64171: DOUBLE
64172: EQUAL
64173: IFTRUE 64177
64175: GO 64389
64177: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 15 :
64178: LD_ADDR_VAR 0 1
64182: PUSH
64183: LD_INT 1
64185: PUSH
64186: LD_INT 2
64188: PUSH
64189: LD_INT 3
64191: PUSH
64192: LD_INT 4
64194: PUSH
64195: LD_INT 5
64197: PUSH
64198: LD_INT 6
64200: PUSH
64201: LD_INT 7
64203: PUSH
64204: LD_INT 8
64206: PUSH
64207: LD_INT 9
64209: PUSH
64210: LD_INT 10
64212: PUSH
64213: LD_INT 11
64215: PUSH
64216: LD_INT 12
64218: PUSH
64219: LD_INT 13
64221: PUSH
64222: LD_INT 14
64224: PUSH
64225: LD_INT 15
64227: PUSH
64228: LD_INT 16
64230: PUSH
64231: LD_INT 17
64233: PUSH
64234: LD_INT 18
64236: PUSH
64237: LD_INT 19
64239: PUSH
64240: LD_INT 20
64242: PUSH
64243: LD_INT 21
64245: PUSH
64246: LD_INT 22
64248: PUSH
64249: LD_INT 23
64251: PUSH
64252: LD_INT 24
64254: PUSH
64255: LD_INT 25
64257: PUSH
64258: LD_INT 26
64260: PUSH
64261: LD_INT 27
64263: PUSH
64264: LD_INT 28
64266: PUSH
64267: LD_INT 29
64269: PUSH
64270: LD_INT 30
64272: PUSH
64273: LD_INT 31
64275: PUSH
64276: LD_INT 32
64278: PUSH
64279: LD_INT 33
64281: PUSH
64282: LD_INT 34
64284: PUSH
64285: LD_INT 36
64287: PUSH
64288: EMPTY
64289: LIST
64290: LIST
64291: LIST
64292: LIST
64293: LIST
64294: LIST
64295: LIST
64296: LIST
64297: LIST
64298: LIST
64299: LIST
64300: LIST
64301: LIST
64302: LIST
64303: LIST
64304: LIST
64305: LIST
64306: LIST
64307: LIST
64308: LIST
64309: LIST
64310: LIST
64311: LIST
64312: LIST
64313: LIST
64314: LIST
64315: LIST
64316: LIST
64317: LIST
64318: LIST
64319: LIST
64320: LIST
64321: LIST
64322: LIST
64323: LIST
64324: PUSH
64325: LD_INT 101
64327: PUSH
64328: LD_INT 102
64330: PUSH
64331: LD_INT 103
64333: PUSH
64334: LD_INT 104
64336: PUSH
64337: LD_INT 105
64339: PUSH
64340: LD_INT 106
64342: PUSH
64343: LD_INT 107
64345: PUSH
64346: LD_INT 108
64348: PUSH
64349: LD_INT 109
64351: PUSH
64352: LD_INT 110
64354: PUSH
64355: LD_INT 111
64357: PUSH
64358: LD_INT 112
64360: PUSH
64361: LD_INT 113
64363: PUSH
64364: LD_INT 114
64366: PUSH
64367: EMPTY
64368: LIST
64369: LIST
64370: LIST
64371: LIST
64372: LIST
64373: LIST
64374: LIST
64375: LIST
64376: LIST
64377: LIST
64378: LIST
64379: LIST
64380: LIST
64381: LIST
64382: PUSH
64383: EMPTY
64384: LIST
64385: LIST
64386: ST_TO_ADDR
64387: GO 65334
64389: LD_INT 15
64391: DOUBLE
64392: EQUAL
64393: IFTRUE 64397
64395: GO 64609
64397: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 16 :
64398: LD_ADDR_VAR 0 1
64402: PUSH
64403: LD_INT 1
64405: PUSH
64406: LD_INT 2
64408: PUSH
64409: LD_INT 3
64411: PUSH
64412: LD_INT 4
64414: PUSH
64415: LD_INT 5
64417: PUSH
64418: LD_INT 6
64420: PUSH
64421: LD_INT 7
64423: PUSH
64424: LD_INT 8
64426: PUSH
64427: LD_INT 9
64429: PUSH
64430: LD_INT 10
64432: PUSH
64433: LD_INT 11
64435: PUSH
64436: LD_INT 12
64438: PUSH
64439: LD_INT 13
64441: PUSH
64442: LD_INT 14
64444: PUSH
64445: LD_INT 15
64447: PUSH
64448: LD_INT 16
64450: PUSH
64451: LD_INT 17
64453: PUSH
64454: LD_INT 18
64456: PUSH
64457: LD_INT 19
64459: PUSH
64460: LD_INT 20
64462: PUSH
64463: LD_INT 21
64465: PUSH
64466: LD_INT 22
64468: PUSH
64469: LD_INT 23
64471: PUSH
64472: LD_INT 24
64474: PUSH
64475: LD_INT 25
64477: PUSH
64478: LD_INT 26
64480: PUSH
64481: LD_INT 27
64483: PUSH
64484: LD_INT 28
64486: PUSH
64487: LD_INT 29
64489: PUSH
64490: LD_INT 30
64492: PUSH
64493: LD_INT 31
64495: PUSH
64496: LD_INT 32
64498: PUSH
64499: LD_INT 33
64501: PUSH
64502: LD_INT 34
64504: PUSH
64505: LD_INT 36
64507: PUSH
64508: EMPTY
64509: LIST
64510: LIST
64511: LIST
64512: LIST
64513: LIST
64514: LIST
64515: LIST
64516: LIST
64517: LIST
64518: LIST
64519: LIST
64520: LIST
64521: LIST
64522: LIST
64523: LIST
64524: LIST
64525: LIST
64526: LIST
64527: LIST
64528: LIST
64529: LIST
64530: LIST
64531: LIST
64532: LIST
64533: LIST
64534: LIST
64535: LIST
64536: LIST
64537: LIST
64538: LIST
64539: LIST
64540: LIST
64541: LIST
64542: LIST
64543: LIST
64544: PUSH
64545: LD_INT 101
64547: PUSH
64548: LD_INT 102
64550: PUSH
64551: LD_INT 103
64553: PUSH
64554: LD_INT 104
64556: PUSH
64557: LD_INT 105
64559: PUSH
64560: LD_INT 106
64562: PUSH
64563: LD_INT 107
64565: PUSH
64566: LD_INT 108
64568: PUSH
64569: LD_INT 109
64571: PUSH
64572: LD_INT 110
64574: PUSH
64575: LD_INT 111
64577: PUSH
64578: LD_INT 112
64580: PUSH
64581: LD_INT 113
64583: PUSH
64584: LD_INT 114
64586: PUSH
64587: EMPTY
64588: LIST
64589: LIST
64590: LIST
64591: LIST
64592: LIST
64593: LIST
64594: LIST
64595: LIST
64596: LIST
64597: LIST
64598: LIST
64599: LIST
64600: LIST
64601: LIST
64602: PUSH
64603: EMPTY
64604: LIST
64605: LIST
64606: ST_TO_ADDR
64607: GO 65334
64609: LD_INT 16
64611: DOUBLE
64612: EQUAL
64613: IFTRUE 64617
64615: GO 64741
64617: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 ] ] ; 17 :
64618: LD_ADDR_VAR 0 1
64622: PUSH
64623: LD_INT 2
64625: PUSH
64626: LD_INT 4
64628: PUSH
64629: LD_INT 5
64631: PUSH
64632: LD_INT 7
64634: PUSH
64635: LD_INT 11
64637: PUSH
64638: LD_INT 12
64640: PUSH
64641: LD_INT 15
64643: PUSH
64644: LD_INT 16
64646: PUSH
64647: LD_INT 20
64649: PUSH
64650: LD_INT 21
64652: PUSH
64653: LD_INT 22
64655: PUSH
64656: LD_INT 23
64658: PUSH
64659: LD_INT 25
64661: PUSH
64662: LD_INT 26
64664: PUSH
64665: LD_INT 30
64667: PUSH
64668: LD_INT 31
64670: PUSH
64671: LD_INT 32
64673: PUSH
64674: LD_INT 33
64676: PUSH
64677: LD_INT 34
64679: PUSH
64680: EMPTY
64681: LIST
64682: LIST
64683: LIST
64684: LIST
64685: LIST
64686: LIST
64687: LIST
64688: LIST
64689: LIST
64690: LIST
64691: LIST
64692: LIST
64693: LIST
64694: LIST
64695: LIST
64696: LIST
64697: LIST
64698: LIST
64699: LIST
64700: PUSH
64701: LD_INT 101
64703: PUSH
64704: LD_INT 102
64706: PUSH
64707: LD_INT 103
64709: PUSH
64710: LD_INT 106
64712: PUSH
64713: LD_INT 108
64715: PUSH
64716: LD_INT 112
64718: PUSH
64719: LD_INT 113
64721: PUSH
64722: LD_INT 114
64724: PUSH
64725: EMPTY
64726: LIST
64727: LIST
64728: LIST
64729: LIST
64730: LIST
64731: LIST
64732: LIST
64733: LIST
64734: PUSH
64735: EMPTY
64736: LIST
64737: LIST
64738: ST_TO_ADDR
64739: GO 65334
64741: LD_INT 17
64743: DOUBLE
64744: EQUAL
64745: IFTRUE 64749
64747: GO 64961
64749: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 18 :
64750: LD_ADDR_VAR 0 1
64754: PUSH
64755: LD_INT 1
64757: PUSH
64758: LD_INT 2
64760: PUSH
64761: LD_INT 3
64763: PUSH
64764: LD_INT 4
64766: PUSH
64767: LD_INT 5
64769: PUSH
64770: LD_INT 6
64772: PUSH
64773: LD_INT 7
64775: PUSH
64776: LD_INT 8
64778: PUSH
64779: LD_INT 9
64781: PUSH
64782: LD_INT 10
64784: PUSH
64785: LD_INT 11
64787: PUSH
64788: LD_INT 12
64790: PUSH
64791: LD_INT 13
64793: PUSH
64794: LD_INT 14
64796: PUSH
64797: LD_INT 15
64799: PUSH
64800: LD_INT 16
64802: PUSH
64803: LD_INT 17
64805: PUSH
64806: LD_INT 18
64808: PUSH
64809: LD_INT 19
64811: PUSH
64812: LD_INT 20
64814: PUSH
64815: LD_INT 21
64817: PUSH
64818: LD_INT 22
64820: PUSH
64821: LD_INT 23
64823: PUSH
64824: LD_INT 24
64826: PUSH
64827: LD_INT 25
64829: PUSH
64830: LD_INT 26
64832: PUSH
64833: LD_INT 27
64835: PUSH
64836: LD_INT 28
64838: PUSH
64839: LD_INT 29
64841: PUSH
64842: LD_INT 30
64844: PUSH
64845: LD_INT 31
64847: PUSH
64848: LD_INT 32
64850: PUSH
64851: LD_INT 33
64853: PUSH
64854: LD_INT 34
64856: PUSH
64857: LD_INT 36
64859: PUSH
64860: EMPTY
64861: LIST
64862: LIST
64863: LIST
64864: LIST
64865: LIST
64866: LIST
64867: LIST
64868: LIST
64869: LIST
64870: LIST
64871: LIST
64872: LIST
64873: LIST
64874: LIST
64875: LIST
64876: LIST
64877: LIST
64878: LIST
64879: LIST
64880: LIST
64881: LIST
64882: LIST
64883: LIST
64884: LIST
64885: LIST
64886: LIST
64887: LIST
64888: LIST
64889: LIST
64890: LIST
64891: LIST
64892: LIST
64893: LIST
64894: LIST
64895: LIST
64896: PUSH
64897: LD_INT 101
64899: PUSH
64900: LD_INT 102
64902: PUSH
64903: LD_INT 103
64905: PUSH
64906: LD_INT 104
64908: PUSH
64909: LD_INT 105
64911: PUSH
64912: LD_INT 106
64914: PUSH
64915: LD_INT 107
64917: PUSH
64918: LD_INT 108
64920: PUSH
64921: LD_INT 109
64923: PUSH
64924: LD_INT 110
64926: PUSH
64927: LD_INT 111
64929: PUSH
64930: LD_INT 112
64932: PUSH
64933: LD_INT 113
64935: PUSH
64936: LD_INT 114
64938: PUSH
64939: EMPTY
64940: LIST
64941: LIST
64942: LIST
64943: LIST
64944: LIST
64945: LIST
64946: LIST
64947: LIST
64948: LIST
64949: LIST
64950: LIST
64951: LIST
64952: LIST
64953: LIST
64954: PUSH
64955: EMPTY
64956: LIST
64957: LIST
64958: ST_TO_ADDR
64959: GO 65334
64961: LD_INT 18
64963: DOUBLE
64964: EQUAL
64965: IFTRUE 64969
64967: GO 65105
64969: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 ] ] ; 19 :
64970: LD_ADDR_VAR 0 1
64974: PUSH
64975: LD_INT 2
64977: PUSH
64978: LD_INT 4
64980: PUSH
64981: LD_INT 5
64983: PUSH
64984: LD_INT 7
64986: PUSH
64987: LD_INT 11
64989: PUSH
64990: LD_INT 12
64992: PUSH
64993: LD_INT 15
64995: PUSH
64996: LD_INT 16
64998: PUSH
64999: LD_INT 20
65001: PUSH
65002: LD_INT 21
65004: PUSH
65005: LD_INT 22
65007: PUSH
65008: LD_INT 23
65010: PUSH
65011: LD_INT 25
65013: PUSH
65014: LD_INT 26
65016: PUSH
65017: LD_INT 30
65019: PUSH
65020: LD_INT 31
65022: PUSH
65023: LD_INT 32
65025: PUSH
65026: LD_INT 33
65028: PUSH
65029: LD_INT 34
65031: PUSH
65032: LD_INT 35
65034: PUSH
65035: LD_INT 36
65037: PUSH
65038: EMPTY
65039: LIST
65040: LIST
65041: LIST
65042: LIST
65043: LIST
65044: LIST
65045: LIST
65046: LIST
65047: LIST
65048: LIST
65049: LIST
65050: LIST
65051: LIST
65052: LIST
65053: LIST
65054: LIST
65055: LIST
65056: LIST
65057: LIST
65058: LIST
65059: LIST
65060: PUSH
65061: LD_INT 101
65063: PUSH
65064: LD_INT 102
65066: PUSH
65067: LD_INT 103
65069: PUSH
65070: LD_INT 106
65072: PUSH
65073: LD_INT 108
65075: PUSH
65076: LD_INT 112
65078: PUSH
65079: LD_INT 113
65081: PUSH
65082: LD_INT 114
65084: PUSH
65085: LD_INT 115
65087: PUSH
65088: EMPTY
65089: LIST
65090: LIST
65091: LIST
65092: LIST
65093: LIST
65094: LIST
65095: LIST
65096: LIST
65097: LIST
65098: PUSH
65099: EMPTY
65100: LIST
65101: LIST
65102: ST_TO_ADDR
65103: GO 65334
65105: LD_INT 19
65107: DOUBLE
65108: EQUAL
65109: IFTRUE 65113
65111: GO 65333
65113: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ; end ;
65114: LD_ADDR_VAR 0 1
65118: PUSH
65119: LD_INT 1
65121: PUSH
65122: LD_INT 2
65124: PUSH
65125: LD_INT 3
65127: PUSH
65128: LD_INT 4
65130: PUSH
65131: LD_INT 5
65133: PUSH
65134: LD_INT 6
65136: PUSH
65137: LD_INT 7
65139: PUSH
65140: LD_INT 8
65142: PUSH
65143: LD_INT 9
65145: PUSH
65146: LD_INT 10
65148: PUSH
65149: LD_INT 11
65151: PUSH
65152: LD_INT 12
65154: PUSH
65155: LD_INT 13
65157: PUSH
65158: LD_INT 14
65160: PUSH
65161: LD_INT 15
65163: PUSH
65164: LD_INT 16
65166: PUSH
65167: LD_INT 17
65169: PUSH
65170: LD_INT 18
65172: PUSH
65173: LD_INT 19
65175: PUSH
65176: LD_INT 20
65178: PUSH
65179: LD_INT 21
65181: PUSH
65182: LD_INT 22
65184: PUSH
65185: LD_INT 23
65187: PUSH
65188: LD_INT 24
65190: PUSH
65191: LD_INT 25
65193: PUSH
65194: LD_INT 26
65196: PUSH
65197: LD_INT 27
65199: PUSH
65200: LD_INT 28
65202: PUSH
65203: LD_INT 29
65205: PUSH
65206: LD_INT 30
65208: PUSH
65209: LD_INT 31
65211: PUSH
65212: LD_INT 32
65214: PUSH
65215: LD_INT 33
65217: PUSH
65218: LD_INT 34
65220: PUSH
65221: LD_INT 35
65223: PUSH
65224: LD_INT 36
65226: PUSH
65227: EMPTY
65228: LIST
65229: LIST
65230: LIST
65231: LIST
65232: LIST
65233: LIST
65234: LIST
65235: LIST
65236: LIST
65237: LIST
65238: LIST
65239: LIST
65240: LIST
65241: LIST
65242: LIST
65243: LIST
65244: LIST
65245: LIST
65246: LIST
65247: LIST
65248: LIST
65249: LIST
65250: LIST
65251: LIST
65252: LIST
65253: LIST
65254: LIST
65255: LIST
65256: LIST
65257: LIST
65258: LIST
65259: LIST
65260: LIST
65261: LIST
65262: LIST
65263: LIST
65264: PUSH
65265: LD_INT 101
65267: PUSH
65268: LD_INT 102
65270: PUSH
65271: LD_INT 103
65273: PUSH
65274: LD_INT 104
65276: PUSH
65277: LD_INT 105
65279: PUSH
65280: LD_INT 106
65282: PUSH
65283: LD_INT 107
65285: PUSH
65286: LD_INT 108
65288: PUSH
65289: LD_INT 109
65291: PUSH
65292: LD_INT 110
65294: PUSH
65295: LD_INT 111
65297: PUSH
65298: LD_INT 112
65300: PUSH
65301: LD_INT 113
65303: PUSH
65304: LD_INT 114
65306: PUSH
65307: LD_INT 115
65309: PUSH
65310: EMPTY
65311: LIST
65312: LIST
65313: LIST
65314: LIST
65315: LIST
65316: LIST
65317: LIST
65318: LIST
65319: LIST
65320: LIST
65321: LIST
65322: LIST
65323: LIST
65324: LIST
65325: LIST
65326: PUSH
65327: EMPTY
65328: LIST
65329: LIST
65330: ST_TO_ADDR
65331: GO 65334
65333: POP
// end else
65334: GO 65553
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ;
65336: LD_ADDR_VAR 0 1
65340: PUSH
65341: LD_INT 1
65343: PUSH
65344: LD_INT 2
65346: PUSH
65347: LD_INT 3
65349: PUSH
65350: LD_INT 4
65352: PUSH
65353: LD_INT 5
65355: PUSH
65356: LD_INT 6
65358: PUSH
65359: LD_INT 7
65361: PUSH
65362: LD_INT 8
65364: PUSH
65365: LD_INT 9
65367: PUSH
65368: LD_INT 10
65370: PUSH
65371: LD_INT 11
65373: PUSH
65374: LD_INT 12
65376: PUSH
65377: LD_INT 13
65379: PUSH
65380: LD_INT 14
65382: PUSH
65383: LD_INT 15
65385: PUSH
65386: LD_INT 16
65388: PUSH
65389: LD_INT 17
65391: PUSH
65392: LD_INT 18
65394: PUSH
65395: LD_INT 19
65397: PUSH
65398: LD_INT 20
65400: PUSH
65401: LD_INT 21
65403: PUSH
65404: LD_INT 22
65406: PUSH
65407: LD_INT 23
65409: PUSH
65410: LD_INT 24
65412: PUSH
65413: LD_INT 25
65415: PUSH
65416: LD_INT 26
65418: PUSH
65419: LD_INT 27
65421: PUSH
65422: LD_INT 28
65424: PUSH
65425: LD_INT 29
65427: PUSH
65428: LD_INT 30
65430: PUSH
65431: LD_INT 31
65433: PUSH
65434: LD_INT 32
65436: PUSH
65437: LD_INT 33
65439: PUSH
65440: LD_INT 34
65442: PUSH
65443: LD_INT 35
65445: PUSH
65446: LD_INT 36
65448: PUSH
65449: EMPTY
65450: LIST
65451: LIST
65452: LIST
65453: LIST
65454: LIST
65455: LIST
65456: LIST
65457: LIST
65458: LIST
65459: LIST
65460: LIST
65461: LIST
65462: LIST
65463: LIST
65464: LIST
65465: LIST
65466: LIST
65467: LIST
65468: LIST
65469: LIST
65470: LIST
65471: LIST
65472: LIST
65473: LIST
65474: LIST
65475: LIST
65476: LIST
65477: LIST
65478: LIST
65479: LIST
65480: LIST
65481: LIST
65482: LIST
65483: LIST
65484: LIST
65485: LIST
65486: PUSH
65487: LD_INT 101
65489: PUSH
65490: LD_INT 102
65492: PUSH
65493: LD_INT 103
65495: PUSH
65496: LD_INT 104
65498: PUSH
65499: LD_INT 105
65501: PUSH
65502: LD_INT 106
65504: PUSH
65505: LD_INT 107
65507: PUSH
65508: LD_INT 108
65510: PUSH
65511: LD_INT 109
65513: PUSH
65514: LD_INT 110
65516: PUSH
65517: LD_INT 111
65519: PUSH
65520: LD_INT 112
65522: PUSH
65523: LD_INT 113
65525: PUSH
65526: LD_INT 114
65528: PUSH
65529: LD_INT 115
65531: PUSH
65532: EMPTY
65533: LIST
65534: LIST
65535: LIST
65536: LIST
65537: LIST
65538: LIST
65539: LIST
65540: LIST
65541: LIST
65542: LIST
65543: LIST
65544: LIST
65545: LIST
65546: LIST
65547: LIST
65548: PUSH
65549: EMPTY
65550: LIST
65551: LIST
65552: ST_TO_ADDR
// if result then
65553: LD_VAR 0 1
65557: IFFALSE 65846
// begin normal :=  ;
65559: LD_ADDR_VAR 0 3
65563: PUSH
65564: LD_STRING 
65566: ST_TO_ADDR
// hardcore :=  ;
65567: LD_ADDR_VAR 0 4
65571: PUSH
65572: LD_STRING 
65574: ST_TO_ADDR
// for i = 1 to normalCounter do
65575: LD_ADDR_VAR 0 5
65579: PUSH
65580: DOUBLE
65581: LD_INT 1
65583: DEC
65584: ST_TO_ADDR
65585: LD_EXP 100
65589: PUSH
65590: FOR_TO
65591: IFFALSE 65692
// begin tmp := 0 ;
65593: LD_ADDR_VAR 0 2
65597: PUSH
65598: LD_STRING 0
65600: ST_TO_ADDR
// if result [ 1 ] then
65601: LD_VAR 0 1
65605: PUSH
65606: LD_INT 1
65608: ARRAY
65609: IFFALSE 65674
// if result [ 1 ] [ 1 ] = i then
65611: LD_VAR 0 1
65615: PUSH
65616: LD_INT 1
65618: ARRAY
65619: PUSH
65620: LD_INT 1
65622: ARRAY
65623: PUSH
65624: LD_VAR 0 5
65628: EQUAL
65629: IFFALSE 65674
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
65631: LD_ADDR_VAR 0 1
65635: PUSH
65636: LD_VAR 0 1
65640: PPUSH
65641: LD_INT 1
65643: PPUSH
65644: LD_VAR 0 1
65648: PUSH
65649: LD_INT 1
65651: ARRAY
65652: PPUSH
65653: LD_INT 1
65655: PPUSH
65656: CALL_OW 3
65660: PPUSH
65661: CALL_OW 1
65665: ST_TO_ADDR
// tmp := 1 ;
65666: LD_ADDR_VAR 0 2
65670: PUSH
65671: LD_STRING 1
65673: ST_TO_ADDR
// end ; normal := normal & tmp ;
65674: LD_ADDR_VAR 0 3
65678: PUSH
65679: LD_VAR 0 3
65683: PUSH
65684: LD_VAR 0 2
65688: STR
65689: ST_TO_ADDR
// end ;
65690: GO 65590
65692: POP
65693: POP
// for i = 1 to hardcoreCounter do
65694: LD_ADDR_VAR 0 5
65698: PUSH
65699: DOUBLE
65700: LD_INT 1
65702: DEC
65703: ST_TO_ADDR
65704: LD_EXP 101
65708: PUSH
65709: FOR_TO
65710: IFFALSE 65815
// begin tmp := 0 ;
65712: LD_ADDR_VAR 0 2
65716: PUSH
65717: LD_STRING 0
65719: ST_TO_ADDR
// if result [ 2 ] then
65720: LD_VAR 0 1
65724: PUSH
65725: LD_INT 2
65727: ARRAY
65728: IFFALSE 65797
// if result [ 2 ] [ 1 ] = 100 + i then
65730: LD_VAR 0 1
65734: PUSH
65735: LD_INT 2
65737: ARRAY
65738: PUSH
65739: LD_INT 1
65741: ARRAY
65742: PUSH
65743: LD_INT 100
65745: PUSH
65746: LD_VAR 0 5
65750: PLUS
65751: EQUAL
65752: IFFALSE 65797
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
65754: LD_ADDR_VAR 0 1
65758: PUSH
65759: LD_VAR 0 1
65763: PPUSH
65764: LD_INT 2
65766: PPUSH
65767: LD_VAR 0 1
65771: PUSH
65772: LD_INT 2
65774: ARRAY
65775: PPUSH
65776: LD_INT 1
65778: PPUSH
65779: CALL_OW 3
65783: PPUSH
65784: CALL_OW 1
65788: ST_TO_ADDR
// tmp := 1 ;
65789: LD_ADDR_VAR 0 2
65793: PUSH
65794: LD_STRING 1
65796: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
65797: LD_ADDR_VAR 0 4
65801: PUSH
65802: LD_VAR 0 4
65806: PUSH
65807: LD_VAR 0 2
65811: STR
65812: ST_TO_ADDR
// end ;
65813: GO 65709
65815: POP
65816: POP
// ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & ") ) ;
65817: LD_STRING getStreamItemsFromMission("
65819: PUSH
65820: LD_VAR 0 3
65824: STR
65825: PUSH
65826: LD_STRING ","
65828: STR
65829: PUSH
65830: LD_VAR 0 4
65834: STR
65835: PUSH
65836: LD_STRING ")
65838: STR
65839: PPUSH
65840: CALL_OW 559
// end else
65844: GO 65853
// ToLua ( getStreamItemsFromMission("","") ) ;
65846: LD_STRING getStreamItemsFromMission("","")
65848: PPUSH
65849: CALL_OW 559
// end ;
65853: LD_VAR 0 1
65857: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
65858: LD_EXP 99
65862: PUSH
65863: LD_EXP 104
65867: AND
65868: IFFALSE 65992
65870: GO 65872
65872: DISABLE
65873: LD_INT 0
65875: PPUSH
65876: PPUSH
// begin enable ;
65877: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
65878: LD_ADDR_VAR 0 2
65882: PUSH
65883: LD_INT 22
65885: PUSH
65886: LD_OWVAR 2
65890: PUSH
65891: EMPTY
65892: LIST
65893: LIST
65894: PUSH
65895: LD_INT 2
65897: PUSH
65898: LD_INT 34
65900: PUSH
65901: LD_INT 7
65903: PUSH
65904: EMPTY
65905: LIST
65906: LIST
65907: PUSH
65908: LD_INT 34
65910: PUSH
65911: LD_INT 45
65913: PUSH
65914: EMPTY
65915: LIST
65916: LIST
65917: PUSH
65918: LD_INT 34
65920: PUSH
65921: LD_INT 28
65923: PUSH
65924: EMPTY
65925: LIST
65926: LIST
65927: PUSH
65928: LD_INT 34
65930: PUSH
65931: LD_INT 47
65933: PUSH
65934: EMPTY
65935: LIST
65936: LIST
65937: PUSH
65938: EMPTY
65939: LIST
65940: LIST
65941: LIST
65942: LIST
65943: LIST
65944: PUSH
65945: EMPTY
65946: LIST
65947: LIST
65948: PPUSH
65949: CALL_OW 69
65953: ST_TO_ADDR
// if not tmp then
65954: LD_VAR 0 2
65958: NOT
65959: IFFALSE 65963
// exit ;
65961: GO 65992
// for i in tmp do
65963: LD_ADDR_VAR 0 1
65967: PUSH
65968: LD_VAR 0 2
65972: PUSH
65973: FOR_IN
65974: IFFALSE 65990
// begin SetLives ( i , 0 ) ;
65976: LD_VAR 0 1
65980: PPUSH
65981: LD_INT 0
65983: PPUSH
65984: CALL_OW 234
// end ;
65988: GO 65973
65990: POP
65991: POP
// end ;
65992: PPOPN 2
65994: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
65995: LD_EXP 99
65999: PUSH
66000: LD_EXP 105
66004: AND
66005: IFFALSE 66089
66007: GO 66009
66009: DISABLE
66010: LD_INT 0
66012: PPUSH
66013: PPUSH
// begin enable ;
66014: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
66015: LD_ADDR_VAR 0 2
66019: PUSH
66020: LD_INT 22
66022: PUSH
66023: LD_OWVAR 2
66027: PUSH
66028: EMPTY
66029: LIST
66030: LIST
66031: PUSH
66032: LD_INT 32
66034: PUSH
66035: LD_INT 3
66037: PUSH
66038: EMPTY
66039: LIST
66040: LIST
66041: PUSH
66042: EMPTY
66043: LIST
66044: LIST
66045: PPUSH
66046: CALL_OW 69
66050: ST_TO_ADDR
// if not tmp then
66051: LD_VAR 0 2
66055: NOT
66056: IFFALSE 66060
// exit ;
66058: GO 66089
// for i in tmp do
66060: LD_ADDR_VAR 0 1
66064: PUSH
66065: LD_VAR 0 2
66069: PUSH
66070: FOR_IN
66071: IFFALSE 66087
// begin SetLives ( i , 0 ) ;
66073: LD_VAR 0 1
66077: PPUSH
66078: LD_INT 0
66080: PPUSH
66081: CALL_OW 234
// end ;
66085: GO 66070
66087: POP
66088: POP
// end ;
66089: PPOPN 2
66091: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
66092: LD_EXP 99
66096: PUSH
66097: LD_EXP 102
66101: AND
66102: IFFALSE 66195
66104: GO 66106
66106: DISABLE
66107: LD_INT 0
66109: PPUSH
// begin enable ;
66110: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
66111: LD_ADDR_VAR 0 1
66115: PUSH
66116: LD_INT 22
66118: PUSH
66119: LD_OWVAR 2
66123: PUSH
66124: EMPTY
66125: LIST
66126: LIST
66127: PUSH
66128: LD_INT 2
66130: PUSH
66131: LD_INT 25
66133: PUSH
66134: LD_INT 5
66136: PUSH
66137: EMPTY
66138: LIST
66139: LIST
66140: PUSH
66141: LD_INT 25
66143: PUSH
66144: LD_INT 9
66146: PUSH
66147: EMPTY
66148: LIST
66149: LIST
66150: PUSH
66151: LD_INT 25
66153: PUSH
66154: LD_INT 8
66156: PUSH
66157: EMPTY
66158: LIST
66159: LIST
66160: PUSH
66161: EMPTY
66162: LIST
66163: LIST
66164: LIST
66165: LIST
66166: PUSH
66167: EMPTY
66168: LIST
66169: LIST
66170: PPUSH
66171: CALL_OW 69
66175: PUSH
66176: FOR_IN
66177: IFFALSE 66193
// begin SetClass ( i , 1 ) ;
66179: LD_VAR 0 1
66183: PPUSH
66184: LD_INT 1
66186: PPUSH
66187: CALL_OW 336
// end ;
66191: GO 66176
66193: POP
66194: POP
// end ;
66195: PPOPN 1
66197: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
66198: LD_EXP 99
66202: PUSH
66203: LD_EXP 103
66207: AND
66208: PUSH
66209: LD_OWVAR 65
66213: PUSH
66214: LD_INT 7
66216: LESS
66217: AND
66218: IFFALSE 66232
66220: GO 66222
66222: DISABLE
// begin enable ;
66223: ENABLE
// game_speed := 7 ;
66224: LD_ADDR_OWVAR 65
66228: PUSH
66229: LD_INT 7
66231: ST_TO_ADDR
// end ;
66232: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
66233: LD_EXP 99
66237: PUSH
66238: LD_EXP 106
66242: AND
66243: IFFALSE 66445
66245: GO 66247
66247: DISABLE
66248: LD_INT 0
66250: PPUSH
66251: PPUSH
66252: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
66253: LD_ADDR_VAR 0 3
66257: PUSH
66258: LD_INT 81
66260: PUSH
66261: LD_OWVAR 2
66265: PUSH
66266: EMPTY
66267: LIST
66268: LIST
66269: PUSH
66270: LD_INT 21
66272: PUSH
66273: LD_INT 1
66275: PUSH
66276: EMPTY
66277: LIST
66278: LIST
66279: PUSH
66280: EMPTY
66281: LIST
66282: LIST
66283: PPUSH
66284: CALL_OW 69
66288: ST_TO_ADDR
// if not tmp then
66289: LD_VAR 0 3
66293: NOT
66294: IFFALSE 66298
// exit ;
66296: GO 66445
// if tmp > 5 then
66298: LD_VAR 0 3
66302: PUSH
66303: LD_INT 5
66305: GREATER
66306: IFFALSE 66318
// k := 5 else
66308: LD_ADDR_VAR 0 2
66312: PUSH
66313: LD_INT 5
66315: ST_TO_ADDR
66316: GO 66328
// k := tmp ;
66318: LD_ADDR_VAR 0 2
66322: PUSH
66323: LD_VAR 0 3
66327: ST_TO_ADDR
// for i := 1 to k do
66328: LD_ADDR_VAR 0 1
66332: PUSH
66333: DOUBLE
66334: LD_INT 1
66336: DEC
66337: ST_TO_ADDR
66338: LD_VAR 0 2
66342: PUSH
66343: FOR_TO
66344: IFFALSE 66443
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
66346: LD_VAR 0 3
66350: PUSH
66351: LD_VAR 0 1
66355: ARRAY
66356: PPUSH
66357: LD_VAR 0 1
66361: PUSH
66362: LD_INT 4
66364: MOD
66365: PUSH
66366: LD_INT 1
66368: PLUS
66369: PPUSH
66370: CALL_OW 259
66374: PUSH
66375: LD_INT 10
66377: LESS
66378: IFFALSE 66441
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
66380: LD_VAR 0 3
66384: PUSH
66385: LD_VAR 0 1
66389: ARRAY
66390: PPUSH
66391: LD_VAR 0 1
66395: PUSH
66396: LD_INT 4
66398: MOD
66399: PUSH
66400: LD_INT 1
66402: PLUS
66403: PPUSH
66404: LD_VAR 0 3
66408: PUSH
66409: LD_VAR 0 1
66413: ARRAY
66414: PPUSH
66415: LD_VAR 0 1
66419: PUSH
66420: LD_INT 4
66422: MOD
66423: PUSH
66424: LD_INT 1
66426: PLUS
66427: PPUSH
66428: CALL_OW 259
66432: PUSH
66433: LD_INT 1
66435: PLUS
66436: PPUSH
66437: CALL_OW 237
66441: GO 66343
66443: POP
66444: POP
// end ;
66445: PPOPN 3
66447: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
66448: LD_EXP 99
66452: PUSH
66453: LD_EXP 107
66457: AND
66458: IFFALSE 66478
66460: GO 66462
66462: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
66463: LD_INT 4
66465: PPUSH
66466: LD_OWVAR 2
66470: PPUSH
66471: LD_INT 0
66473: PPUSH
66474: CALL_OW 324
66478: END
// every 0 0$1 trigger StreamModeActive and sShovel do
66479: LD_EXP 99
66483: PUSH
66484: LD_EXP 136
66488: AND
66489: IFFALSE 66509
66491: GO 66493
66493: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
66494: LD_INT 19
66496: PPUSH
66497: LD_OWVAR 2
66501: PPUSH
66502: LD_INT 0
66504: PPUSH
66505: CALL_OW 324
66509: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
66510: LD_EXP 99
66514: PUSH
66515: LD_EXP 108
66519: AND
66520: IFFALSE 66622
66522: GO 66524
66524: DISABLE
66525: LD_INT 0
66527: PPUSH
66528: PPUSH
// begin enable ;
66529: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
66530: LD_ADDR_VAR 0 2
66534: PUSH
66535: LD_INT 22
66537: PUSH
66538: LD_OWVAR 2
66542: PUSH
66543: EMPTY
66544: LIST
66545: LIST
66546: PUSH
66547: LD_INT 2
66549: PUSH
66550: LD_INT 34
66552: PUSH
66553: LD_INT 11
66555: PUSH
66556: EMPTY
66557: LIST
66558: LIST
66559: PUSH
66560: LD_INT 34
66562: PUSH
66563: LD_INT 30
66565: PUSH
66566: EMPTY
66567: LIST
66568: LIST
66569: PUSH
66570: EMPTY
66571: LIST
66572: LIST
66573: LIST
66574: PUSH
66575: EMPTY
66576: LIST
66577: LIST
66578: PPUSH
66579: CALL_OW 69
66583: ST_TO_ADDR
// if not tmp then
66584: LD_VAR 0 2
66588: NOT
66589: IFFALSE 66593
// exit ;
66591: GO 66622
// for i in tmp do
66593: LD_ADDR_VAR 0 1
66597: PUSH
66598: LD_VAR 0 2
66602: PUSH
66603: FOR_IN
66604: IFFALSE 66620
// begin SetLives ( i , 0 ) ;
66606: LD_VAR 0 1
66610: PPUSH
66611: LD_INT 0
66613: PPUSH
66614: CALL_OW 234
// end ;
66618: GO 66603
66620: POP
66621: POP
// end ;
66622: PPOPN 2
66624: END
// every 0 0$1 trigger StreamModeActive and sBunker do
66625: LD_EXP 99
66629: PUSH
66630: LD_EXP 109
66634: AND
66635: IFFALSE 66655
66637: GO 66639
66639: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
66640: LD_INT 32
66642: PPUSH
66643: LD_OWVAR 2
66647: PPUSH
66648: LD_INT 0
66650: PPUSH
66651: CALL_OW 324
66655: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
66656: LD_EXP 99
66660: PUSH
66661: LD_EXP 110
66665: AND
66666: IFFALSE 66847
66668: GO 66670
66670: DISABLE
66671: LD_INT 0
66673: PPUSH
66674: PPUSH
66675: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
66676: LD_ADDR_VAR 0 2
66680: PUSH
66681: LD_INT 22
66683: PUSH
66684: LD_OWVAR 2
66688: PUSH
66689: EMPTY
66690: LIST
66691: LIST
66692: PUSH
66693: LD_INT 33
66695: PUSH
66696: LD_INT 3
66698: PUSH
66699: EMPTY
66700: LIST
66701: LIST
66702: PUSH
66703: EMPTY
66704: LIST
66705: LIST
66706: PPUSH
66707: CALL_OW 69
66711: ST_TO_ADDR
// if not tmp then
66712: LD_VAR 0 2
66716: NOT
66717: IFFALSE 66721
// exit ;
66719: GO 66847
// side := 0 ;
66721: LD_ADDR_VAR 0 3
66725: PUSH
66726: LD_INT 0
66728: ST_TO_ADDR
// for i := 1 to 8 do
66729: LD_ADDR_VAR 0 1
66733: PUSH
66734: DOUBLE
66735: LD_INT 1
66737: DEC
66738: ST_TO_ADDR
66739: LD_INT 8
66741: PUSH
66742: FOR_TO
66743: IFFALSE 66791
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
66745: LD_OWVAR 2
66749: PUSH
66750: LD_VAR 0 1
66754: NONEQUAL
66755: PUSH
66756: LD_OWVAR 2
66760: PPUSH
66761: LD_VAR 0 1
66765: PPUSH
66766: CALL_OW 81
66770: PUSH
66771: LD_INT 2
66773: EQUAL
66774: AND
66775: IFFALSE 66789
// begin side := i ;
66777: LD_ADDR_VAR 0 3
66781: PUSH
66782: LD_VAR 0 1
66786: ST_TO_ADDR
// break ;
66787: GO 66791
// end ;
66789: GO 66742
66791: POP
66792: POP
// if not side then
66793: LD_VAR 0 3
66797: NOT
66798: IFFALSE 66802
// exit ;
66800: GO 66847
// for i := 1 to tmp do
66802: LD_ADDR_VAR 0 1
66806: PUSH
66807: DOUBLE
66808: LD_INT 1
66810: DEC
66811: ST_TO_ADDR
66812: LD_VAR 0 2
66816: PUSH
66817: FOR_TO
66818: IFFALSE 66845
// if Prob ( 60 ) then
66820: LD_INT 60
66822: PPUSH
66823: CALL_OW 13
66827: IFFALSE 66843
// SetSide ( i , side ) ;
66829: LD_VAR 0 1
66833: PPUSH
66834: LD_VAR 0 3
66838: PPUSH
66839: CALL_OW 235
66843: GO 66817
66845: POP
66846: POP
// end ;
66847: PPOPN 3
66849: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
66850: LD_EXP 99
66854: PUSH
66855: LD_EXP 112
66859: AND
66860: IFFALSE 66979
66862: GO 66864
66864: DISABLE
66865: LD_INT 0
66867: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
66868: LD_ADDR_VAR 0 1
66872: PUSH
66873: LD_INT 22
66875: PUSH
66876: LD_OWVAR 2
66880: PUSH
66881: EMPTY
66882: LIST
66883: LIST
66884: PUSH
66885: LD_INT 21
66887: PUSH
66888: LD_INT 1
66890: PUSH
66891: EMPTY
66892: LIST
66893: LIST
66894: PUSH
66895: LD_INT 3
66897: PUSH
66898: LD_INT 23
66900: PUSH
66901: LD_INT 0
66903: PUSH
66904: EMPTY
66905: LIST
66906: LIST
66907: PUSH
66908: EMPTY
66909: LIST
66910: LIST
66911: PUSH
66912: EMPTY
66913: LIST
66914: LIST
66915: LIST
66916: PPUSH
66917: CALL_OW 69
66921: PUSH
66922: FOR_IN
66923: IFFALSE 66977
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
66925: LD_VAR 0 1
66929: PPUSH
66930: CALL_OW 257
66934: PUSH
66935: LD_INT 1
66937: PUSH
66938: LD_INT 2
66940: PUSH
66941: LD_INT 3
66943: PUSH
66944: LD_INT 4
66946: PUSH
66947: EMPTY
66948: LIST
66949: LIST
66950: LIST
66951: LIST
66952: IN
66953: IFFALSE 66975
// SetClass ( un , rand ( 1 , 4 ) ) ;
66955: LD_VAR 0 1
66959: PPUSH
66960: LD_INT 1
66962: PPUSH
66963: LD_INT 4
66965: PPUSH
66966: CALL_OW 12
66970: PPUSH
66971: CALL_OW 336
66975: GO 66922
66977: POP
66978: POP
// end ;
66979: PPOPN 1
66981: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
66982: LD_EXP 99
66986: PUSH
66987: LD_EXP 111
66991: AND
66992: IFFALSE 67071
66994: GO 66996
66996: DISABLE
66997: LD_INT 0
66999: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
67000: LD_ADDR_VAR 0 1
67004: PUSH
67005: LD_INT 22
67007: PUSH
67008: LD_OWVAR 2
67012: PUSH
67013: EMPTY
67014: LIST
67015: LIST
67016: PUSH
67017: LD_INT 21
67019: PUSH
67020: LD_INT 3
67022: PUSH
67023: EMPTY
67024: LIST
67025: LIST
67026: PUSH
67027: EMPTY
67028: LIST
67029: LIST
67030: PPUSH
67031: CALL_OW 69
67035: ST_TO_ADDR
// if not tmp then
67036: LD_VAR 0 1
67040: NOT
67041: IFFALSE 67045
// exit ;
67043: GO 67071
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
67045: LD_VAR 0 1
67049: PUSH
67050: LD_INT 1
67052: PPUSH
67053: LD_VAR 0 1
67057: PPUSH
67058: CALL_OW 12
67062: ARRAY
67063: PPUSH
67064: LD_INT 100
67066: PPUSH
67067: CALL_OW 234
// end ;
67071: PPOPN 1
67073: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
67074: LD_EXP 99
67078: PUSH
67079: LD_EXP 113
67083: AND
67084: IFFALSE 67182
67086: GO 67088
67088: DISABLE
67089: LD_INT 0
67091: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
67092: LD_ADDR_VAR 0 1
67096: PUSH
67097: LD_INT 22
67099: PUSH
67100: LD_OWVAR 2
67104: PUSH
67105: EMPTY
67106: LIST
67107: LIST
67108: PUSH
67109: LD_INT 21
67111: PUSH
67112: LD_INT 1
67114: PUSH
67115: EMPTY
67116: LIST
67117: LIST
67118: PUSH
67119: EMPTY
67120: LIST
67121: LIST
67122: PPUSH
67123: CALL_OW 69
67127: ST_TO_ADDR
// if not tmp then
67128: LD_VAR 0 1
67132: NOT
67133: IFFALSE 67137
// exit ;
67135: GO 67182
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
67137: LD_VAR 0 1
67141: PUSH
67142: LD_INT 1
67144: PPUSH
67145: LD_VAR 0 1
67149: PPUSH
67150: CALL_OW 12
67154: ARRAY
67155: PPUSH
67156: LD_INT 1
67158: PPUSH
67159: LD_INT 4
67161: PPUSH
67162: CALL_OW 12
67166: PPUSH
67167: LD_INT 3000
67169: PPUSH
67170: LD_INT 9000
67172: PPUSH
67173: CALL_OW 12
67177: PPUSH
67178: CALL_OW 492
// end ;
67182: PPOPN 1
67184: END
// every 0 0$1 trigger StreamModeActive and sDepot do
67185: LD_EXP 99
67189: PUSH
67190: LD_EXP 114
67194: AND
67195: IFFALSE 67215
67197: GO 67199
67199: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
67200: LD_INT 1
67202: PPUSH
67203: LD_OWVAR 2
67207: PPUSH
67208: LD_INT 0
67210: PPUSH
67211: CALL_OW 324
67215: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
67216: LD_EXP 99
67220: PUSH
67221: LD_EXP 115
67225: AND
67226: IFFALSE 67309
67228: GO 67230
67230: DISABLE
67231: LD_INT 0
67233: PPUSH
67234: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
67235: LD_ADDR_VAR 0 2
67239: PUSH
67240: LD_INT 22
67242: PUSH
67243: LD_OWVAR 2
67247: PUSH
67248: EMPTY
67249: LIST
67250: LIST
67251: PUSH
67252: LD_INT 21
67254: PUSH
67255: LD_INT 3
67257: PUSH
67258: EMPTY
67259: LIST
67260: LIST
67261: PUSH
67262: EMPTY
67263: LIST
67264: LIST
67265: PPUSH
67266: CALL_OW 69
67270: ST_TO_ADDR
// if not tmp then
67271: LD_VAR 0 2
67275: NOT
67276: IFFALSE 67280
// exit ;
67278: GO 67309
// for i in tmp do
67280: LD_ADDR_VAR 0 1
67284: PUSH
67285: LD_VAR 0 2
67289: PUSH
67290: FOR_IN
67291: IFFALSE 67307
// SetBLevel ( i , 10 ) ;
67293: LD_VAR 0 1
67297: PPUSH
67298: LD_INT 10
67300: PPUSH
67301: CALL_OW 241
67305: GO 67290
67307: POP
67308: POP
// end ;
67309: PPOPN 2
67311: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
67312: LD_EXP 99
67316: PUSH
67317: LD_EXP 116
67321: AND
67322: IFFALSE 67433
67324: GO 67326
67326: DISABLE
67327: LD_INT 0
67329: PPUSH
67330: PPUSH
67331: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
67332: LD_ADDR_VAR 0 3
67336: PUSH
67337: LD_INT 22
67339: PUSH
67340: LD_OWVAR 2
67344: PUSH
67345: EMPTY
67346: LIST
67347: LIST
67348: PUSH
67349: LD_INT 25
67351: PUSH
67352: LD_INT 1
67354: PUSH
67355: EMPTY
67356: LIST
67357: LIST
67358: PUSH
67359: EMPTY
67360: LIST
67361: LIST
67362: PPUSH
67363: CALL_OW 69
67367: ST_TO_ADDR
// if not tmp then
67368: LD_VAR 0 3
67372: NOT
67373: IFFALSE 67377
// exit ;
67375: GO 67433
// un := tmp [ rand ( 1 , tmp ) ] ;
67377: LD_ADDR_VAR 0 2
67381: PUSH
67382: LD_VAR 0 3
67386: PUSH
67387: LD_INT 1
67389: PPUSH
67390: LD_VAR 0 3
67394: PPUSH
67395: CALL_OW 12
67399: ARRAY
67400: ST_TO_ADDR
// if Crawls ( un ) then
67401: LD_VAR 0 2
67405: PPUSH
67406: CALL_OW 318
67410: IFFALSE 67421
// ComWalk ( un ) ;
67412: LD_VAR 0 2
67416: PPUSH
67417: CALL_OW 138
// SetClass ( un , class_sniper ) ;
67421: LD_VAR 0 2
67425: PPUSH
67426: LD_INT 5
67428: PPUSH
67429: CALL_OW 336
// end ;
67433: PPOPN 3
67435: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
67436: LD_EXP 99
67440: PUSH
67441: LD_EXP 117
67445: AND
67446: PUSH
67447: LD_OWVAR 67
67451: PUSH
67452: LD_INT 3
67454: LESS
67455: AND
67456: IFFALSE 67475
67458: GO 67460
67460: DISABLE
// Difficulty := Difficulty + 1 ;
67461: LD_ADDR_OWVAR 67
67465: PUSH
67466: LD_OWVAR 67
67470: PUSH
67471: LD_INT 1
67473: PLUS
67474: ST_TO_ADDR
67475: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
67476: LD_EXP 99
67480: PUSH
67481: LD_EXP 118
67485: AND
67486: IFFALSE 67589
67488: GO 67490
67490: DISABLE
67491: LD_INT 0
67493: PPUSH
// begin for i := 1 to 5 do
67494: LD_ADDR_VAR 0 1
67498: PUSH
67499: DOUBLE
67500: LD_INT 1
67502: DEC
67503: ST_TO_ADDR
67504: LD_INT 5
67506: PUSH
67507: FOR_TO
67508: IFFALSE 67587
// begin uc_nation := nation_nature ;
67510: LD_ADDR_OWVAR 21
67514: PUSH
67515: LD_INT 0
67517: ST_TO_ADDR
// uc_side := 0 ;
67518: LD_ADDR_OWVAR 20
67522: PUSH
67523: LD_INT 0
67525: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
67526: LD_ADDR_OWVAR 29
67530: PUSH
67531: LD_INT 12
67533: PUSH
67534: LD_INT 12
67536: PUSH
67537: EMPTY
67538: LIST
67539: LIST
67540: ST_TO_ADDR
// hc_agressivity := 20 ;
67541: LD_ADDR_OWVAR 35
67545: PUSH
67546: LD_INT 20
67548: ST_TO_ADDR
// hc_class := class_tiger ;
67549: LD_ADDR_OWVAR 28
67553: PUSH
67554: LD_INT 14
67556: ST_TO_ADDR
// hc_gallery :=  ;
67557: LD_ADDR_OWVAR 33
67561: PUSH
67562: LD_STRING 
67564: ST_TO_ADDR
// hc_name :=  ;
67565: LD_ADDR_OWVAR 26
67569: PUSH
67570: LD_STRING 
67572: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
67573: CALL_OW 44
67577: PPUSH
67578: LD_INT 0
67580: PPUSH
67581: CALL_OW 51
// end ;
67585: GO 67507
67587: POP
67588: POP
// end ;
67589: PPOPN 1
67591: END
// every 0 0$1 trigger StreamModeActive and sBomb do
67592: LD_EXP 99
67596: PUSH
67597: LD_EXP 119
67601: AND
67602: IFFALSE 67611
67604: GO 67606
67606: DISABLE
// StreamSibBomb ;
67607: CALL 67612 0 0
67611: END
// export function StreamSibBomb ; var i , x , y ; begin
67612: LD_INT 0
67614: PPUSH
67615: PPUSH
67616: PPUSH
67617: PPUSH
// result := false ;
67618: LD_ADDR_VAR 0 1
67622: PUSH
67623: LD_INT 0
67625: ST_TO_ADDR
// for i := 1 to 16 do
67626: LD_ADDR_VAR 0 2
67630: PUSH
67631: DOUBLE
67632: LD_INT 1
67634: DEC
67635: ST_TO_ADDR
67636: LD_INT 16
67638: PUSH
67639: FOR_TO
67640: IFFALSE 67839
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
67642: LD_ADDR_VAR 0 3
67646: PUSH
67647: LD_INT 10
67649: PUSH
67650: LD_INT 20
67652: PUSH
67653: LD_INT 30
67655: PUSH
67656: LD_INT 40
67658: PUSH
67659: LD_INT 50
67661: PUSH
67662: LD_INT 60
67664: PUSH
67665: LD_INT 70
67667: PUSH
67668: LD_INT 80
67670: PUSH
67671: LD_INT 90
67673: PUSH
67674: LD_INT 100
67676: PUSH
67677: LD_INT 110
67679: PUSH
67680: LD_INT 120
67682: PUSH
67683: LD_INT 130
67685: PUSH
67686: LD_INT 140
67688: PUSH
67689: LD_INT 150
67691: PUSH
67692: EMPTY
67693: LIST
67694: LIST
67695: LIST
67696: LIST
67697: LIST
67698: LIST
67699: LIST
67700: LIST
67701: LIST
67702: LIST
67703: LIST
67704: LIST
67705: LIST
67706: LIST
67707: LIST
67708: PUSH
67709: LD_INT 1
67711: PPUSH
67712: LD_INT 15
67714: PPUSH
67715: CALL_OW 12
67719: ARRAY
67720: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
67721: LD_ADDR_VAR 0 4
67725: PUSH
67726: LD_INT 10
67728: PUSH
67729: LD_INT 20
67731: PUSH
67732: LD_INT 30
67734: PUSH
67735: LD_INT 40
67737: PUSH
67738: LD_INT 50
67740: PUSH
67741: LD_INT 60
67743: PUSH
67744: LD_INT 70
67746: PUSH
67747: LD_INT 80
67749: PUSH
67750: LD_INT 90
67752: PUSH
67753: LD_INT 100
67755: PUSH
67756: LD_INT 110
67758: PUSH
67759: LD_INT 120
67761: PUSH
67762: LD_INT 130
67764: PUSH
67765: LD_INT 140
67767: PUSH
67768: LD_INT 150
67770: PUSH
67771: EMPTY
67772: LIST
67773: LIST
67774: LIST
67775: LIST
67776: LIST
67777: LIST
67778: LIST
67779: LIST
67780: LIST
67781: LIST
67782: LIST
67783: LIST
67784: LIST
67785: LIST
67786: LIST
67787: PUSH
67788: LD_INT 1
67790: PPUSH
67791: LD_INT 15
67793: PPUSH
67794: CALL_OW 12
67798: ARRAY
67799: ST_TO_ADDR
// if ValidHex ( x , y ) then
67800: LD_VAR 0 3
67804: PPUSH
67805: LD_VAR 0 4
67809: PPUSH
67810: CALL_OW 488
67814: IFFALSE 67837
// begin result := [ x , y ] ;
67816: LD_ADDR_VAR 0 1
67820: PUSH
67821: LD_VAR 0 3
67825: PUSH
67826: LD_VAR 0 4
67830: PUSH
67831: EMPTY
67832: LIST
67833: LIST
67834: ST_TO_ADDR
// break ;
67835: GO 67839
// end ; end ;
67837: GO 67639
67839: POP
67840: POP
// if result then
67841: LD_VAR 0 1
67845: IFFALSE 67905
// begin ToLua ( playSibBomb() ) ;
67847: LD_STRING playSibBomb()
67849: PPUSH
67850: CALL_OW 559
// wait ( 0 0$14 ) ;
67854: LD_INT 490
67856: PPUSH
67857: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
67861: LD_VAR 0 1
67865: PUSH
67866: LD_INT 1
67868: ARRAY
67869: PPUSH
67870: LD_VAR 0 1
67874: PUSH
67875: LD_INT 2
67877: ARRAY
67878: PPUSH
67879: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
67883: LD_VAR 0 1
67887: PUSH
67888: LD_INT 1
67890: ARRAY
67891: PPUSH
67892: LD_VAR 0 1
67896: PUSH
67897: LD_INT 2
67899: ARRAY
67900: PPUSH
67901: CALL_OW 429
// end ; end ;
67905: LD_VAR 0 1
67909: RET
// every 0 0$1 trigger StreamModeActive and sReset do
67910: LD_EXP 99
67914: PUSH
67915: LD_EXP 121
67919: AND
67920: IFFALSE 67932
67922: GO 67924
67924: DISABLE
// YouLost (  ) ;
67925: LD_STRING 
67927: PPUSH
67928: CALL_OW 104
67932: END
// every 0 0$1 trigger StreamModeActive and sFog do
67933: LD_EXP 99
67937: PUSH
67938: LD_EXP 120
67942: AND
67943: IFFALSE 67957
67945: GO 67947
67947: DISABLE
// FogOff ( your_side ) ;
67948: LD_OWVAR 2
67952: PPUSH
67953: CALL_OW 344
67957: END
// every 0 0$1 trigger StreamModeActive and sSun do
67958: LD_EXP 99
67962: PUSH
67963: LD_EXP 122
67967: AND
67968: IFFALSE 67996
67970: GO 67972
67972: DISABLE
// begin solar_recharge_percent := 0 ;
67973: LD_ADDR_OWVAR 79
67977: PUSH
67978: LD_INT 0
67980: ST_TO_ADDR
// wait ( 5 5$00 ) ;
67981: LD_INT 10500
67983: PPUSH
67984: CALL_OW 67
// solar_recharge_percent := 100 ;
67988: LD_ADDR_OWVAR 79
67992: PUSH
67993: LD_INT 100
67995: ST_TO_ADDR
// end ;
67996: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
67997: LD_EXP 99
68001: PUSH
68002: LD_EXP 123
68006: AND
68007: IFFALSE 68246
68009: GO 68011
68011: DISABLE
68012: LD_INT 0
68014: PPUSH
68015: PPUSH
68016: PPUSH
// begin tmp := [ ] ;
68017: LD_ADDR_VAR 0 3
68021: PUSH
68022: EMPTY
68023: ST_TO_ADDR
// for i := 1 to 6 do
68024: LD_ADDR_VAR 0 1
68028: PUSH
68029: DOUBLE
68030: LD_INT 1
68032: DEC
68033: ST_TO_ADDR
68034: LD_INT 6
68036: PUSH
68037: FOR_TO
68038: IFFALSE 68143
// begin uc_nation := nation_nature ;
68040: LD_ADDR_OWVAR 21
68044: PUSH
68045: LD_INT 0
68047: ST_TO_ADDR
// uc_side := 0 ;
68048: LD_ADDR_OWVAR 20
68052: PUSH
68053: LD_INT 0
68055: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
68056: LD_ADDR_OWVAR 29
68060: PUSH
68061: LD_INT 12
68063: PUSH
68064: LD_INT 12
68066: PUSH
68067: EMPTY
68068: LIST
68069: LIST
68070: ST_TO_ADDR
// hc_agressivity := 20 ;
68071: LD_ADDR_OWVAR 35
68075: PUSH
68076: LD_INT 20
68078: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
68079: LD_ADDR_OWVAR 28
68083: PUSH
68084: LD_INT 17
68086: ST_TO_ADDR
// hc_gallery :=  ;
68087: LD_ADDR_OWVAR 33
68091: PUSH
68092: LD_STRING 
68094: ST_TO_ADDR
// hc_name :=  ;
68095: LD_ADDR_OWVAR 26
68099: PUSH
68100: LD_STRING 
68102: ST_TO_ADDR
// un := CreateHuman ;
68103: LD_ADDR_VAR 0 2
68107: PUSH
68108: CALL_OW 44
68112: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
68113: LD_VAR 0 2
68117: PPUSH
68118: LD_INT 1
68120: PPUSH
68121: CALL_OW 51
// tmp := tmp ^ un ;
68125: LD_ADDR_VAR 0 3
68129: PUSH
68130: LD_VAR 0 3
68134: PUSH
68135: LD_VAR 0 2
68139: ADD
68140: ST_TO_ADDR
// end ;
68141: GO 68037
68143: POP
68144: POP
// repeat wait ( 0 0$1 ) ;
68145: LD_INT 35
68147: PPUSH
68148: CALL_OW 67
// for un in tmp do
68152: LD_ADDR_VAR 0 2
68156: PUSH
68157: LD_VAR 0 3
68161: PUSH
68162: FOR_IN
68163: IFFALSE 68237
// begin if IsDead ( un ) then
68165: LD_VAR 0 2
68169: PPUSH
68170: CALL_OW 301
68174: IFFALSE 68194
// begin tmp := tmp diff un ;
68176: LD_ADDR_VAR 0 3
68180: PUSH
68181: LD_VAR 0 3
68185: PUSH
68186: LD_VAR 0 2
68190: DIFF
68191: ST_TO_ADDR
// continue ;
68192: GO 68162
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
68194: LD_VAR 0 2
68198: PPUSH
68199: LD_INT 3
68201: PUSH
68202: LD_INT 22
68204: PUSH
68205: LD_INT 0
68207: PUSH
68208: EMPTY
68209: LIST
68210: LIST
68211: PUSH
68212: EMPTY
68213: LIST
68214: LIST
68215: PPUSH
68216: CALL_OW 69
68220: PPUSH
68221: LD_VAR 0 2
68225: PPUSH
68226: CALL_OW 74
68230: PPUSH
68231: CALL_OW 115
// end ;
68235: GO 68162
68237: POP
68238: POP
// until not tmp ;
68239: LD_VAR 0 3
68243: NOT
68244: IFFALSE 68145
// end ;
68246: PPOPN 3
68248: END
// every 0 0$1 trigger StreamModeActive and sTroll do
68249: LD_EXP 99
68253: PUSH
68254: LD_EXP 124
68258: AND
68259: IFFALSE 68313
68261: GO 68263
68263: DISABLE
// begin ToLua ( displayTroll(); ) ;
68264: LD_STRING displayTroll();
68266: PPUSH
68267: CALL_OW 559
// wait ( 3 3$00 ) ;
68271: LD_INT 6300
68273: PPUSH
68274: CALL_OW 67
// ToLua ( hideTroll(); ) ;
68278: LD_STRING hideTroll();
68280: PPUSH
68281: CALL_OW 559
// wait ( 1 1$00 ) ;
68285: LD_INT 2100
68287: PPUSH
68288: CALL_OW 67
// ToLua ( displayTroll(); ) ;
68292: LD_STRING displayTroll();
68294: PPUSH
68295: CALL_OW 559
// wait ( 1 1$00 ) ;
68299: LD_INT 2100
68301: PPUSH
68302: CALL_OW 67
// ToLua ( hideTroll(); ) ;
68306: LD_STRING hideTroll();
68308: PPUSH
68309: CALL_OW 559
// end ;
68313: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
68314: LD_EXP 99
68318: PUSH
68319: LD_EXP 125
68323: AND
68324: IFFALSE 68387
68326: GO 68328
68328: DISABLE
68329: LD_INT 0
68331: PPUSH
// begin p := 0 ;
68332: LD_ADDR_VAR 0 1
68336: PUSH
68337: LD_INT 0
68339: ST_TO_ADDR
// repeat game_speed := 1 ;
68340: LD_ADDR_OWVAR 65
68344: PUSH
68345: LD_INT 1
68347: ST_TO_ADDR
// wait ( 0 0$1 ) ;
68348: LD_INT 35
68350: PPUSH
68351: CALL_OW 67
// p := p + 1 ;
68355: LD_ADDR_VAR 0 1
68359: PUSH
68360: LD_VAR 0 1
68364: PUSH
68365: LD_INT 1
68367: PLUS
68368: ST_TO_ADDR
// until p >= 60 ;
68369: LD_VAR 0 1
68373: PUSH
68374: LD_INT 60
68376: GREATEREQUAL
68377: IFFALSE 68340
// game_speed := 4 ;
68379: LD_ADDR_OWVAR 65
68383: PUSH
68384: LD_INT 4
68386: ST_TO_ADDR
// end ;
68387: PPOPN 1
68389: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
68390: LD_EXP 99
68394: PUSH
68395: LD_EXP 126
68399: AND
68400: IFFALSE 68546
68402: GO 68404
68404: DISABLE
68405: LD_INT 0
68407: PPUSH
68408: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
68409: LD_ADDR_VAR 0 1
68413: PUSH
68414: LD_INT 22
68416: PUSH
68417: LD_OWVAR 2
68421: PUSH
68422: EMPTY
68423: LIST
68424: LIST
68425: PUSH
68426: LD_INT 2
68428: PUSH
68429: LD_INT 30
68431: PUSH
68432: LD_INT 0
68434: PUSH
68435: EMPTY
68436: LIST
68437: LIST
68438: PUSH
68439: LD_INT 30
68441: PUSH
68442: LD_INT 1
68444: PUSH
68445: EMPTY
68446: LIST
68447: LIST
68448: PUSH
68449: EMPTY
68450: LIST
68451: LIST
68452: LIST
68453: PUSH
68454: EMPTY
68455: LIST
68456: LIST
68457: PPUSH
68458: CALL_OW 69
68462: ST_TO_ADDR
// if not depot then
68463: LD_VAR 0 1
68467: NOT
68468: IFFALSE 68472
// exit ;
68470: GO 68546
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
68472: LD_ADDR_VAR 0 2
68476: PUSH
68477: LD_VAR 0 1
68481: PUSH
68482: LD_INT 1
68484: PPUSH
68485: LD_VAR 0 1
68489: PPUSH
68490: CALL_OW 12
68494: ARRAY
68495: PPUSH
68496: CALL_OW 274
68500: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
68501: LD_VAR 0 2
68505: PPUSH
68506: LD_INT 1
68508: PPUSH
68509: LD_INT 0
68511: PPUSH
68512: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
68516: LD_VAR 0 2
68520: PPUSH
68521: LD_INT 2
68523: PPUSH
68524: LD_INT 0
68526: PPUSH
68527: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
68531: LD_VAR 0 2
68535: PPUSH
68536: LD_INT 3
68538: PPUSH
68539: LD_INT 0
68541: PPUSH
68542: CALL_OW 277
// end ;
68546: PPOPN 2
68548: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
68549: LD_EXP 99
68553: PUSH
68554: LD_EXP 127
68558: AND
68559: IFFALSE 68656
68561: GO 68563
68563: DISABLE
68564: LD_INT 0
68566: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
68567: LD_ADDR_VAR 0 1
68571: PUSH
68572: LD_INT 22
68574: PUSH
68575: LD_OWVAR 2
68579: PUSH
68580: EMPTY
68581: LIST
68582: LIST
68583: PUSH
68584: LD_INT 21
68586: PUSH
68587: LD_INT 1
68589: PUSH
68590: EMPTY
68591: LIST
68592: LIST
68593: PUSH
68594: LD_INT 3
68596: PUSH
68597: LD_INT 23
68599: PUSH
68600: LD_INT 0
68602: PUSH
68603: EMPTY
68604: LIST
68605: LIST
68606: PUSH
68607: EMPTY
68608: LIST
68609: LIST
68610: PUSH
68611: EMPTY
68612: LIST
68613: LIST
68614: LIST
68615: PPUSH
68616: CALL_OW 69
68620: ST_TO_ADDR
// if not tmp then
68621: LD_VAR 0 1
68625: NOT
68626: IFFALSE 68630
// exit ;
68628: GO 68656
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
68630: LD_VAR 0 1
68634: PUSH
68635: LD_INT 1
68637: PPUSH
68638: LD_VAR 0 1
68642: PPUSH
68643: CALL_OW 12
68647: ARRAY
68648: PPUSH
68649: LD_INT 200
68651: PPUSH
68652: CALL_OW 234
// end ;
68656: PPOPN 1
68658: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
68659: LD_EXP 99
68663: PUSH
68664: LD_EXP 128
68668: AND
68669: IFFALSE 68748
68671: GO 68673
68673: DISABLE
68674: LD_INT 0
68676: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
68677: LD_ADDR_VAR 0 1
68681: PUSH
68682: LD_INT 22
68684: PUSH
68685: LD_OWVAR 2
68689: PUSH
68690: EMPTY
68691: LIST
68692: LIST
68693: PUSH
68694: LD_INT 21
68696: PUSH
68697: LD_INT 2
68699: PUSH
68700: EMPTY
68701: LIST
68702: LIST
68703: PUSH
68704: EMPTY
68705: LIST
68706: LIST
68707: PPUSH
68708: CALL_OW 69
68712: ST_TO_ADDR
// if not tmp then
68713: LD_VAR 0 1
68717: NOT
68718: IFFALSE 68722
// exit ;
68720: GO 68748
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
68722: LD_VAR 0 1
68726: PUSH
68727: LD_INT 1
68729: PPUSH
68730: LD_VAR 0 1
68734: PPUSH
68735: CALL_OW 12
68739: ARRAY
68740: PPUSH
68741: LD_INT 60
68743: PPUSH
68744: CALL_OW 234
// end ;
68748: PPOPN 1
68750: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
68751: LD_EXP 99
68755: PUSH
68756: LD_EXP 129
68760: AND
68761: IFFALSE 68860
68763: GO 68765
68765: DISABLE
68766: LD_INT 0
68768: PPUSH
68769: PPUSH
// begin enable ;
68770: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
68771: LD_ADDR_VAR 0 1
68775: PUSH
68776: LD_INT 22
68778: PUSH
68779: LD_OWVAR 2
68783: PUSH
68784: EMPTY
68785: LIST
68786: LIST
68787: PUSH
68788: LD_INT 61
68790: PUSH
68791: EMPTY
68792: LIST
68793: PUSH
68794: LD_INT 33
68796: PUSH
68797: LD_INT 2
68799: PUSH
68800: EMPTY
68801: LIST
68802: LIST
68803: PUSH
68804: EMPTY
68805: LIST
68806: LIST
68807: LIST
68808: PPUSH
68809: CALL_OW 69
68813: ST_TO_ADDR
// if not tmp then
68814: LD_VAR 0 1
68818: NOT
68819: IFFALSE 68823
// exit ;
68821: GO 68860
// for i in tmp do
68823: LD_ADDR_VAR 0 2
68827: PUSH
68828: LD_VAR 0 1
68832: PUSH
68833: FOR_IN
68834: IFFALSE 68858
// if IsControledBy ( i ) then
68836: LD_VAR 0 2
68840: PPUSH
68841: CALL_OW 312
68845: IFFALSE 68856
// ComUnlink ( i ) ;
68847: LD_VAR 0 2
68851: PPUSH
68852: CALL_OW 136
68856: GO 68833
68858: POP
68859: POP
// end ;
68860: PPOPN 2
68862: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
68863: LD_EXP 99
68867: PUSH
68868: LD_EXP 130
68872: AND
68873: IFFALSE 69013
68875: GO 68877
68877: DISABLE
68878: LD_INT 0
68880: PPUSH
68881: PPUSH
// begin ToLua ( displayPowell(); ) ;
68882: LD_STRING displayPowell();
68884: PPUSH
68885: CALL_OW 559
// uc_side := 0 ;
68889: LD_ADDR_OWVAR 20
68893: PUSH
68894: LD_INT 0
68896: ST_TO_ADDR
// uc_nation := 2 ;
68897: LD_ADDR_OWVAR 21
68901: PUSH
68902: LD_INT 2
68904: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
68905: LD_ADDR_OWVAR 37
68909: PUSH
68910: LD_INT 14
68912: ST_TO_ADDR
// vc_engine := engine_siberite ;
68913: LD_ADDR_OWVAR 39
68917: PUSH
68918: LD_INT 3
68920: ST_TO_ADDR
// vc_control := control_apeman ;
68921: LD_ADDR_OWVAR 38
68925: PUSH
68926: LD_INT 5
68928: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
68929: LD_ADDR_OWVAR 40
68933: PUSH
68934: LD_INT 29
68936: ST_TO_ADDR
// un := CreateVehicle ;
68937: LD_ADDR_VAR 0 2
68941: PUSH
68942: CALL_OW 45
68946: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
68947: LD_VAR 0 2
68951: PPUSH
68952: LD_INT 1
68954: PPUSH
68955: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
68959: LD_INT 35
68961: PPUSH
68962: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
68966: LD_VAR 0 2
68970: PPUSH
68971: LD_INT 22
68973: PUSH
68974: LD_OWVAR 2
68978: PUSH
68979: EMPTY
68980: LIST
68981: LIST
68982: PPUSH
68983: CALL_OW 69
68987: PPUSH
68988: LD_VAR 0 2
68992: PPUSH
68993: CALL_OW 74
68997: PPUSH
68998: CALL_OW 115
// until IsDead ( un ) ;
69002: LD_VAR 0 2
69006: PPUSH
69007: CALL_OW 301
69011: IFFALSE 68959
// end ;
69013: PPOPN 2
69015: END
// every 0 0$1 trigger StreamModeActive and sStu do
69016: LD_EXP 99
69020: PUSH
69021: LD_EXP 138
69025: AND
69026: IFFALSE 69042
69028: GO 69030
69030: DISABLE
// begin ToLua ( displayStucuk(); ) ;
69031: LD_STRING displayStucuk();
69033: PPUSH
69034: CALL_OW 559
// ResetFog ;
69038: CALL_OW 335
// end ;
69042: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
69043: LD_EXP 99
69047: PUSH
69048: LD_EXP 131
69052: AND
69053: IFFALSE 69194
69055: GO 69057
69057: DISABLE
69058: LD_INT 0
69060: PPUSH
69061: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
69062: LD_ADDR_VAR 0 2
69066: PUSH
69067: LD_INT 22
69069: PUSH
69070: LD_OWVAR 2
69074: PUSH
69075: EMPTY
69076: LIST
69077: LIST
69078: PUSH
69079: LD_INT 21
69081: PUSH
69082: LD_INT 1
69084: PUSH
69085: EMPTY
69086: LIST
69087: LIST
69088: PUSH
69089: EMPTY
69090: LIST
69091: LIST
69092: PPUSH
69093: CALL_OW 69
69097: ST_TO_ADDR
// if not tmp then
69098: LD_VAR 0 2
69102: NOT
69103: IFFALSE 69107
// exit ;
69105: GO 69194
// un := tmp [ rand ( 1 , tmp ) ] ;
69107: LD_ADDR_VAR 0 1
69111: PUSH
69112: LD_VAR 0 2
69116: PUSH
69117: LD_INT 1
69119: PPUSH
69120: LD_VAR 0 2
69124: PPUSH
69125: CALL_OW 12
69129: ARRAY
69130: ST_TO_ADDR
// SetSide ( un , 0 ) ;
69131: LD_VAR 0 1
69135: PPUSH
69136: LD_INT 0
69138: PPUSH
69139: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
69143: LD_VAR 0 1
69147: PPUSH
69148: LD_OWVAR 3
69152: PUSH
69153: LD_VAR 0 1
69157: DIFF
69158: PPUSH
69159: LD_VAR 0 1
69163: PPUSH
69164: CALL_OW 74
69168: PPUSH
69169: CALL_OW 115
// wait ( 0 0$20 ) ;
69173: LD_INT 700
69175: PPUSH
69176: CALL_OW 67
// SetSide ( un , your_side ) ;
69180: LD_VAR 0 1
69184: PPUSH
69185: LD_OWVAR 2
69189: PPUSH
69190: CALL_OW 235
// end ;
69194: PPOPN 2
69196: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
69197: LD_EXP 99
69201: PUSH
69202: LD_EXP 132
69206: AND
69207: IFFALSE 69313
69209: GO 69211
69211: DISABLE
69212: LD_INT 0
69214: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
69215: LD_ADDR_VAR 0 1
69219: PUSH
69220: LD_INT 22
69222: PUSH
69223: LD_OWVAR 2
69227: PUSH
69228: EMPTY
69229: LIST
69230: LIST
69231: PUSH
69232: LD_INT 2
69234: PUSH
69235: LD_INT 30
69237: PUSH
69238: LD_INT 0
69240: PUSH
69241: EMPTY
69242: LIST
69243: LIST
69244: PUSH
69245: LD_INT 30
69247: PUSH
69248: LD_INT 1
69250: PUSH
69251: EMPTY
69252: LIST
69253: LIST
69254: PUSH
69255: EMPTY
69256: LIST
69257: LIST
69258: LIST
69259: PUSH
69260: EMPTY
69261: LIST
69262: LIST
69263: PPUSH
69264: CALL_OW 69
69268: ST_TO_ADDR
// if not depot then
69269: LD_VAR 0 1
69273: NOT
69274: IFFALSE 69278
// exit ;
69276: GO 69313
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
69278: LD_VAR 0 1
69282: PUSH
69283: LD_INT 1
69285: ARRAY
69286: PPUSH
69287: CALL_OW 250
69291: PPUSH
69292: LD_VAR 0 1
69296: PUSH
69297: LD_INT 1
69299: ARRAY
69300: PPUSH
69301: CALL_OW 251
69305: PPUSH
69306: LD_INT 70
69308: PPUSH
69309: CALL_OW 495
// end ;
69313: PPOPN 1
69315: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
69316: LD_EXP 99
69320: PUSH
69321: LD_EXP 133
69325: AND
69326: IFFALSE 69537
69328: GO 69330
69330: DISABLE
69331: LD_INT 0
69333: PPUSH
69334: PPUSH
69335: PPUSH
69336: PPUSH
69337: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
69338: LD_ADDR_VAR 0 5
69342: PUSH
69343: LD_INT 22
69345: PUSH
69346: LD_OWVAR 2
69350: PUSH
69351: EMPTY
69352: LIST
69353: LIST
69354: PUSH
69355: LD_INT 21
69357: PUSH
69358: LD_INT 1
69360: PUSH
69361: EMPTY
69362: LIST
69363: LIST
69364: PUSH
69365: EMPTY
69366: LIST
69367: LIST
69368: PPUSH
69369: CALL_OW 69
69373: ST_TO_ADDR
// if not tmp then
69374: LD_VAR 0 5
69378: NOT
69379: IFFALSE 69383
// exit ;
69381: GO 69537
// for i in tmp do
69383: LD_ADDR_VAR 0 1
69387: PUSH
69388: LD_VAR 0 5
69392: PUSH
69393: FOR_IN
69394: IFFALSE 69535
// begin d := rand ( 0 , 5 ) ;
69396: LD_ADDR_VAR 0 4
69400: PUSH
69401: LD_INT 0
69403: PPUSH
69404: LD_INT 5
69406: PPUSH
69407: CALL_OW 12
69411: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
69412: LD_ADDR_VAR 0 2
69416: PUSH
69417: LD_VAR 0 1
69421: PPUSH
69422: CALL_OW 250
69426: PPUSH
69427: LD_VAR 0 4
69431: PPUSH
69432: LD_INT 3
69434: PPUSH
69435: LD_INT 12
69437: PPUSH
69438: CALL_OW 12
69442: PPUSH
69443: CALL_OW 272
69447: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
69448: LD_ADDR_VAR 0 3
69452: PUSH
69453: LD_VAR 0 1
69457: PPUSH
69458: CALL_OW 251
69462: PPUSH
69463: LD_VAR 0 4
69467: PPUSH
69468: LD_INT 3
69470: PPUSH
69471: LD_INT 12
69473: PPUSH
69474: CALL_OW 12
69478: PPUSH
69479: CALL_OW 273
69483: ST_TO_ADDR
// if ValidHex ( x , y ) then
69484: LD_VAR 0 2
69488: PPUSH
69489: LD_VAR 0 3
69493: PPUSH
69494: CALL_OW 488
69498: IFFALSE 69533
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
69500: LD_VAR 0 1
69504: PPUSH
69505: LD_VAR 0 2
69509: PPUSH
69510: LD_VAR 0 3
69514: PPUSH
69515: LD_INT 3
69517: PPUSH
69518: LD_INT 6
69520: PPUSH
69521: CALL_OW 12
69525: PPUSH
69526: LD_INT 1
69528: PPUSH
69529: CALL_OW 483
// end ;
69533: GO 69393
69535: POP
69536: POP
// end ;
69537: PPOPN 5
69539: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
69540: LD_EXP 99
69544: PUSH
69545: LD_EXP 134
69549: AND
69550: IFFALSE 69644
69552: GO 69554
69554: DISABLE
69555: LD_INT 0
69557: PPUSH
69558: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
69559: LD_ADDR_VAR 0 2
69563: PUSH
69564: LD_INT 22
69566: PUSH
69567: LD_OWVAR 2
69571: PUSH
69572: EMPTY
69573: LIST
69574: LIST
69575: PUSH
69576: LD_INT 32
69578: PUSH
69579: LD_INT 1
69581: PUSH
69582: EMPTY
69583: LIST
69584: LIST
69585: PUSH
69586: LD_INT 21
69588: PUSH
69589: LD_INT 2
69591: PUSH
69592: EMPTY
69593: LIST
69594: LIST
69595: PUSH
69596: EMPTY
69597: LIST
69598: LIST
69599: LIST
69600: PPUSH
69601: CALL_OW 69
69605: ST_TO_ADDR
// if not tmp then
69606: LD_VAR 0 2
69610: NOT
69611: IFFALSE 69615
// exit ;
69613: GO 69644
// for i in tmp do
69615: LD_ADDR_VAR 0 1
69619: PUSH
69620: LD_VAR 0 2
69624: PUSH
69625: FOR_IN
69626: IFFALSE 69642
// SetFuel ( i , 0 ) ;
69628: LD_VAR 0 1
69632: PPUSH
69633: LD_INT 0
69635: PPUSH
69636: CALL_OW 240
69640: GO 69625
69642: POP
69643: POP
// end ;
69644: PPOPN 2
69646: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
69647: LD_EXP 99
69651: PUSH
69652: LD_EXP 135
69656: AND
69657: IFFALSE 69723
69659: GO 69661
69661: DISABLE
69662: LD_INT 0
69664: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
69665: LD_ADDR_VAR 0 1
69669: PUSH
69670: LD_INT 22
69672: PUSH
69673: LD_OWVAR 2
69677: PUSH
69678: EMPTY
69679: LIST
69680: LIST
69681: PUSH
69682: LD_INT 30
69684: PUSH
69685: LD_INT 29
69687: PUSH
69688: EMPTY
69689: LIST
69690: LIST
69691: PUSH
69692: EMPTY
69693: LIST
69694: LIST
69695: PPUSH
69696: CALL_OW 69
69700: ST_TO_ADDR
// if not tmp then
69701: LD_VAR 0 1
69705: NOT
69706: IFFALSE 69710
// exit ;
69708: GO 69723
// DestroyUnit ( tmp [ 1 ] ) ;
69710: LD_VAR 0 1
69714: PUSH
69715: LD_INT 1
69717: ARRAY
69718: PPUSH
69719: CALL_OW 65
// end ;
69723: PPOPN 1
69725: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
69726: LD_EXP 99
69730: PUSH
69731: LD_EXP 137
69735: AND
69736: IFFALSE 69865
69738: GO 69740
69740: DISABLE
69741: LD_INT 0
69743: PPUSH
// begin uc_side := 0 ;
69744: LD_ADDR_OWVAR 20
69748: PUSH
69749: LD_INT 0
69751: ST_TO_ADDR
// uc_nation := nation_arabian ;
69752: LD_ADDR_OWVAR 21
69756: PUSH
69757: LD_INT 2
69759: ST_TO_ADDR
// hc_gallery :=  ;
69760: LD_ADDR_OWVAR 33
69764: PUSH
69765: LD_STRING 
69767: ST_TO_ADDR
// hc_name :=  ;
69768: LD_ADDR_OWVAR 26
69772: PUSH
69773: LD_STRING 
69775: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
69776: LD_INT 1
69778: PPUSH
69779: LD_INT 11
69781: PPUSH
69782: LD_INT 10
69784: PPUSH
69785: CALL_OW 380
// un := CreateHuman ;
69789: LD_ADDR_VAR 0 1
69793: PUSH
69794: CALL_OW 44
69798: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
69799: LD_VAR 0 1
69803: PPUSH
69804: LD_INT 1
69806: PPUSH
69807: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
69811: LD_INT 35
69813: PPUSH
69814: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
69818: LD_VAR 0 1
69822: PPUSH
69823: LD_INT 22
69825: PUSH
69826: LD_OWVAR 2
69830: PUSH
69831: EMPTY
69832: LIST
69833: LIST
69834: PPUSH
69835: CALL_OW 69
69839: PPUSH
69840: LD_VAR 0 1
69844: PPUSH
69845: CALL_OW 74
69849: PPUSH
69850: CALL_OW 115
// until IsDead ( un ) ;
69854: LD_VAR 0 1
69858: PPUSH
69859: CALL_OW 301
69863: IFFALSE 69811
// end ;
69865: PPOPN 1
69867: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
69868: LD_EXP 99
69872: PUSH
69873: LD_EXP 139
69877: AND
69878: IFFALSE 69890
69880: GO 69882
69882: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
69883: LD_STRING earthquake(getX(game), 0, 32)
69885: PPUSH
69886: CALL_OW 559
69890: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
69891: LD_EXP 99
69895: PUSH
69896: LD_EXP 140
69900: AND
69901: IFFALSE 69992
69903: GO 69905
69905: DISABLE
69906: LD_INT 0
69908: PPUSH
// begin enable ;
69909: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
69910: LD_ADDR_VAR 0 1
69914: PUSH
69915: LD_INT 22
69917: PUSH
69918: LD_OWVAR 2
69922: PUSH
69923: EMPTY
69924: LIST
69925: LIST
69926: PUSH
69927: LD_INT 21
69929: PUSH
69930: LD_INT 2
69932: PUSH
69933: EMPTY
69934: LIST
69935: LIST
69936: PUSH
69937: LD_INT 33
69939: PUSH
69940: LD_INT 3
69942: PUSH
69943: EMPTY
69944: LIST
69945: LIST
69946: PUSH
69947: EMPTY
69948: LIST
69949: LIST
69950: LIST
69951: PPUSH
69952: CALL_OW 69
69956: ST_TO_ADDR
// if not tmp then
69957: LD_VAR 0 1
69961: NOT
69962: IFFALSE 69966
// exit ;
69964: GO 69992
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
69966: LD_VAR 0 1
69970: PUSH
69971: LD_INT 1
69973: PPUSH
69974: LD_VAR 0 1
69978: PPUSH
69979: CALL_OW 12
69983: ARRAY
69984: PPUSH
69985: LD_INT 1
69987: PPUSH
69988: CALL_OW 234
// end ;
69992: PPOPN 1
69994: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
69995: LD_EXP 99
69999: PUSH
70000: LD_EXP 141
70004: AND
70005: IFFALSE 70146
70007: GO 70009
70009: DISABLE
70010: LD_INT 0
70012: PPUSH
70013: PPUSH
70014: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
70015: LD_ADDR_VAR 0 3
70019: PUSH
70020: LD_INT 22
70022: PUSH
70023: LD_OWVAR 2
70027: PUSH
70028: EMPTY
70029: LIST
70030: LIST
70031: PUSH
70032: LD_INT 25
70034: PUSH
70035: LD_INT 1
70037: PUSH
70038: EMPTY
70039: LIST
70040: LIST
70041: PUSH
70042: EMPTY
70043: LIST
70044: LIST
70045: PPUSH
70046: CALL_OW 69
70050: ST_TO_ADDR
// if not tmp then
70051: LD_VAR 0 3
70055: NOT
70056: IFFALSE 70060
// exit ;
70058: GO 70146
// un := tmp [ rand ( 1 , tmp ) ] ;
70060: LD_ADDR_VAR 0 2
70064: PUSH
70065: LD_VAR 0 3
70069: PUSH
70070: LD_INT 1
70072: PPUSH
70073: LD_VAR 0 3
70077: PPUSH
70078: CALL_OW 12
70082: ARRAY
70083: ST_TO_ADDR
// if Crawls ( un ) then
70084: LD_VAR 0 2
70088: PPUSH
70089: CALL_OW 318
70093: IFFALSE 70104
// ComWalk ( un ) ;
70095: LD_VAR 0 2
70099: PPUSH
70100: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
70104: LD_VAR 0 2
70108: PPUSH
70109: LD_INT 9
70111: PPUSH
70112: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
70116: LD_INT 28
70118: PPUSH
70119: LD_OWVAR 2
70123: PPUSH
70124: LD_INT 2
70126: PPUSH
70127: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
70131: LD_INT 29
70133: PPUSH
70134: LD_OWVAR 2
70138: PPUSH
70139: LD_INT 2
70141: PPUSH
70142: CALL_OW 322
// end ;
70146: PPOPN 3
70148: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
70149: LD_EXP 99
70153: PUSH
70154: LD_EXP 142
70158: AND
70159: IFFALSE 70270
70161: GO 70163
70163: DISABLE
70164: LD_INT 0
70166: PPUSH
70167: PPUSH
70168: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
70169: LD_ADDR_VAR 0 3
70173: PUSH
70174: LD_INT 22
70176: PUSH
70177: LD_OWVAR 2
70181: PUSH
70182: EMPTY
70183: LIST
70184: LIST
70185: PUSH
70186: LD_INT 25
70188: PUSH
70189: LD_INT 1
70191: PUSH
70192: EMPTY
70193: LIST
70194: LIST
70195: PUSH
70196: EMPTY
70197: LIST
70198: LIST
70199: PPUSH
70200: CALL_OW 69
70204: ST_TO_ADDR
// if not tmp then
70205: LD_VAR 0 3
70209: NOT
70210: IFFALSE 70214
// exit ;
70212: GO 70270
// un := tmp [ rand ( 1 , tmp ) ] ;
70214: LD_ADDR_VAR 0 2
70218: PUSH
70219: LD_VAR 0 3
70223: PUSH
70224: LD_INT 1
70226: PPUSH
70227: LD_VAR 0 3
70231: PPUSH
70232: CALL_OW 12
70236: ARRAY
70237: ST_TO_ADDR
// if Crawls ( un ) then
70238: LD_VAR 0 2
70242: PPUSH
70243: CALL_OW 318
70247: IFFALSE 70258
// ComWalk ( un ) ;
70249: LD_VAR 0 2
70253: PPUSH
70254: CALL_OW 138
// SetClass ( un , class_mortar ) ;
70258: LD_VAR 0 2
70262: PPUSH
70263: LD_INT 8
70265: PPUSH
70266: CALL_OW 336
// end ;
70270: PPOPN 3
70272: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
70273: LD_EXP 99
70277: PUSH
70278: LD_EXP 143
70282: AND
70283: IFFALSE 70427
70285: GO 70287
70287: DISABLE
70288: LD_INT 0
70290: PPUSH
70291: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
70292: LD_ADDR_VAR 0 2
70296: PUSH
70297: LD_INT 22
70299: PUSH
70300: LD_OWVAR 2
70304: PUSH
70305: EMPTY
70306: LIST
70307: LIST
70308: PUSH
70309: LD_INT 21
70311: PUSH
70312: LD_INT 2
70314: PUSH
70315: EMPTY
70316: LIST
70317: LIST
70318: PUSH
70319: LD_INT 2
70321: PUSH
70322: LD_INT 34
70324: PUSH
70325: LD_INT 12
70327: PUSH
70328: EMPTY
70329: LIST
70330: LIST
70331: PUSH
70332: LD_INT 34
70334: PUSH
70335: LD_INT 51
70337: PUSH
70338: EMPTY
70339: LIST
70340: LIST
70341: PUSH
70342: LD_INT 34
70344: PUSH
70345: LD_INT 32
70347: PUSH
70348: EMPTY
70349: LIST
70350: LIST
70351: PUSH
70352: EMPTY
70353: LIST
70354: LIST
70355: LIST
70356: LIST
70357: PUSH
70358: EMPTY
70359: LIST
70360: LIST
70361: LIST
70362: PPUSH
70363: CALL_OW 69
70367: ST_TO_ADDR
// if not tmp then
70368: LD_VAR 0 2
70372: NOT
70373: IFFALSE 70377
// exit ;
70375: GO 70427
// for i in tmp do
70377: LD_ADDR_VAR 0 1
70381: PUSH
70382: LD_VAR 0 2
70386: PUSH
70387: FOR_IN
70388: IFFALSE 70425
// if GetCargo ( i , mat_artifact ) = 0 then
70390: LD_VAR 0 1
70394: PPUSH
70395: LD_INT 4
70397: PPUSH
70398: CALL_OW 289
70402: PUSH
70403: LD_INT 0
70405: EQUAL
70406: IFFALSE 70423
// SetCargo ( i , mat_siberit , 100 ) ;
70408: LD_VAR 0 1
70412: PPUSH
70413: LD_INT 3
70415: PPUSH
70416: LD_INT 100
70418: PPUSH
70419: CALL_OW 290
70423: GO 70387
70425: POP
70426: POP
// end ;
70427: PPOPN 2
70429: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
70430: LD_EXP 99
70434: PUSH
70435: LD_EXP 144
70439: AND
70440: IFFALSE 70623
70442: GO 70444
70444: DISABLE
70445: LD_INT 0
70447: PPUSH
70448: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
70449: LD_ADDR_VAR 0 2
70453: PUSH
70454: LD_INT 22
70456: PUSH
70457: LD_OWVAR 2
70461: PUSH
70462: EMPTY
70463: LIST
70464: LIST
70465: PPUSH
70466: CALL_OW 69
70470: ST_TO_ADDR
// if not tmp then
70471: LD_VAR 0 2
70475: NOT
70476: IFFALSE 70480
// exit ;
70478: GO 70623
// for i := 1 to 2 do
70480: LD_ADDR_VAR 0 1
70484: PUSH
70485: DOUBLE
70486: LD_INT 1
70488: DEC
70489: ST_TO_ADDR
70490: LD_INT 2
70492: PUSH
70493: FOR_TO
70494: IFFALSE 70621
// begin uc_side := your_side ;
70496: LD_ADDR_OWVAR 20
70500: PUSH
70501: LD_OWVAR 2
70505: ST_TO_ADDR
// uc_nation := nation_american ;
70506: LD_ADDR_OWVAR 21
70510: PUSH
70511: LD_INT 1
70513: ST_TO_ADDR
// vc_chassis := us_morphling ;
70514: LD_ADDR_OWVAR 37
70518: PUSH
70519: LD_INT 5
70521: ST_TO_ADDR
// vc_engine := engine_siberite ;
70522: LD_ADDR_OWVAR 39
70526: PUSH
70527: LD_INT 3
70529: ST_TO_ADDR
// vc_control := control_computer ;
70530: LD_ADDR_OWVAR 38
70534: PUSH
70535: LD_INT 3
70537: ST_TO_ADDR
// vc_weapon := us_double_laser ;
70538: LD_ADDR_OWVAR 40
70542: PUSH
70543: LD_INT 10
70545: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
70546: LD_VAR 0 2
70550: PUSH
70551: LD_INT 1
70553: ARRAY
70554: PPUSH
70555: CALL_OW 310
70559: NOT
70560: IFFALSE 70607
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
70562: CALL_OW 45
70566: PPUSH
70567: LD_VAR 0 2
70571: PUSH
70572: LD_INT 1
70574: ARRAY
70575: PPUSH
70576: CALL_OW 250
70580: PPUSH
70581: LD_VAR 0 2
70585: PUSH
70586: LD_INT 1
70588: ARRAY
70589: PPUSH
70590: CALL_OW 251
70594: PPUSH
70595: LD_INT 12
70597: PPUSH
70598: LD_INT 1
70600: PPUSH
70601: CALL_OW 50
70605: GO 70619
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
70607: CALL_OW 45
70611: PPUSH
70612: LD_INT 1
70614: PPUSH
70615: CALL_OW 51
// end ;
70619: GO 70493
70621: POP
70622: POP
// end ;
70623: PPOPN 2
70625: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
70626: LD_EXP 99
70630: PUSH
70631: LD_EXP 145
70635: AND
70636: IFFALSE 70858
70638: GO 70640
70640: DISABLE
70641: LD_INT 0
70643: PPUSH
70644: PPUSH
70645: PPUSH
70646: PPUSH
70647: PPUSH
70648: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
70649: LD_ADDR_VAR 0 6
70653: PUSH
70654: LD_INT 22
70656: PUSH
70657: LD_OWVAR 2
70661: PUSH
70662: EMPTY
70663: LIST
70664: LIST
70665: PUSH
70666: LD_INT 21
70668: PUSH
70669: LD_INT 1
70671: PUSH
70672: EMPTY
70673: LIST
70674: LIST
70675: PUSH
70676: LD_INT 3
70678: PUSH
70679: LD_INT 23
70681: PUSH
70682: LD_INT 0
70684: PUSH
70685: EMPTY
70686: LIST
70687: LIST
70688: PUSH
70689: EMPTY
70690: LIST
70691: LIST
70692: PUSH
70693: EMPTY
70694: LIST
70695: LIST
70696: LIST
70697: PPUSH
70698: CALL_OW 69
70702: ST_TO_ADDR
// if not tmp then
70703: LD_VAR 0 6
70707: NOT
70708: IFFALSE 70712
// exit ;
70710: GO 70858
// s1 := rand ( 1 , 4 ) ;
70712: LD_ADDR_VAR 0 2
70716: PUSH
70717: LD_INT 1
70719: PPUSH
70720: LD_INT 4
70722: PPUSH
70723: CALL_OW 12
70727: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
70728: LD_ADDR_VAR 0 4
70732: PUSH
70733: LD_VAR 0 6
70737: PUSH
70738: LD_INT 1
70740: ARRAY
70741: PPUSH
70742: LD_VAR 0 2
70746: PPUSH
70747: CALL_OW 259
70751: ST_TO_ADDR
// if s1 = 1 then
70752: LD_VAR 0 2
70756: PUSH
70757: LD_INT 1
70759: EQUAL
70760: IFFALSE 70780
// s2 := rand ( 2 , 4 ) else
70762: LD_ADDR_VAR 0 3
70766: PUSH
70767: LD_INT 2
70769: PPUSH
70770: LD_INT 4
70772: PPUSH
70773: CALL_OW 12
70777: ST_TO_ADDR
70778: GO 70788
// s2 := 1 ;
70780: LD_ADDR_VAR 0 3
70784: PUSH
70785: LD_INT 1
70787: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
70788: LD_ADDR_VAR 0 5
70792: PUSH
70793: LD_VAR 0 6
70797: PUSH
70798: LD_INT 1
70800: ARRAY
70801: PPUSH
70802: LD_VAR 0 3
70806: PPUSH
70807: CALL_OW 259
70811: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
70812: LD_VAR 0 6
70816: PUSH
70817: LD_INT 1
70819: ARRAY
70820: PPUSH
70821: LD_VAR 0 2
70825: PPUSH
70826: LD_VAR 0 5
70830: PPUSH
70831: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
70835: LD_VAR 0 6
70839: PUSH
70840: LD_INT 1
70842: ARRAY
70843: PPUSH
70844: LD_VAR 0 3
70848: PPUSH
70849: LD_VAR 0 4
70853: PPUSH
70854: CALL_OW 237
// end ;
70858: PPOPN 6
70860: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
70861: LD_EXP 99
70865: PUSH
70866: LD_EXP 146
70870: AND
70871: IFFALSE 70950
70873: GO 70875
70875: DISABLE
70876: LD_INT 0
70878: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
70879: LD_ADDR_VAR 0 1
70883: PUSH
70884: LD_INT 22
70886: PUSH
70887: LD_OWVAR 2
70891: PUSH
70892: EMPTY
70893: LIST
70894: LIST
70895: PUSH
70896: LD_INT 30
70898: PUSH
70899: LD_INT 3
70901: PUSH
70902: EMPTY
70903: LIST
70904: LIST
70905: PUSH
70906: EMPTY
70907: LIST
70908: LIST
70909: PPUSH
70910: CALL_OW 69
70914: ST_TO_ADDR
// if not tmp then
70915: LD_VAR 0 1
70919: NOT
70920: IFFALSE 70924
// exit ;
70922: GO 70950
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
70924: LD_VAR 0 1
70928: PUSH
70929: LD_INT 1
70931: PPUSH
70932: LD_VAR 0 1
70936: PPUSH
70937: CALL_OW 12
70941: ARRAY
70942: PPUSH
70943: LD_INT 1
70945: PPUSH
70946: CALL_OW 234
// end ;
70950: PPOPN 1
70952: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
70953: LD_EXP 99
70957: PUSH
70958: LD_EXP 147
70962: AND
70963: IFFALSE 71075
70965: GO 70967
70967: DISABLE
70968: LD_INT 0
70970: PPUSH
70971: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
70972: LD_ADDR_VAR 0 2
70976: PUSH
70977: LD_INT 22
70979: PUSH
70980: LD_OWVAR 2
70984: PUSH
70985: EMPTY
70986: LIST
70987: LIST
70988: PUSH
70989: LD_INT 2
70991: PUSH
70992: LD_INT 30
70994: PUSH
70995: LD_INT 27
70997: PUSH
70998: EMPTY
70999: LIST
71000: LIST
71001: PUSH
71002: LD_INT 30
71004: PUSH
71005: LD_INT 26
71007: PUSH
71008: EMPTY
71009: LIST
71010: LIST
71011: PUSH
71012: LD_INT 30
71014: PUSH
71015: LD_INT 28
71017: PUSH
71018: EMPTY
71019: LIST
71020: LIST
71021: PUSH
71022: EMPTY
71023: LIST
71024: LIST
71025: LIST
71026: LIST
71027: PUSH
71028: EMPTY
71029: LIST
71030: LIST
71031: PPUSH
71032: CALL_OW 69
71036: ST_TO_ADDR
// if not tmp then
71037: LD_VAR 0 2
71041: NOT
71042: IFFALSE 71046
// exit ;
71044: GO 71075
// for i in tmp do
71046: LD_ADDR_VAR 0 1
71050: PUSH
71051: LD_VAR 0 2
71055: PUSH
71056: FOR_IN
71057: IFFALSE 71073
// SetLives ( i , 1 ) ;
71059: LD_VAR 0 1
71063: PPUSH
71064: LD_INT 1
71066: PPUSH
71067: CALL_OW 234
71071: GO 71056
71073: POP
71074: POP
// end ;
71075: PPOPN 2
71077: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
71078: LD_EXP 99
71082: PUSH
71083: LD_EXP 148
71087: AND
71088: IFFALSE 71362
71090: GO 71092
71092: DISABLE
71093: LD_INT 0
71095: PPUSH
71096: PPUSH
71097: PPUSH
// begin i := rand ( 1 , 7 ) ;
71098: LD_ADDR_VAR 0 1
71102: PUSH
71103: LD_INT 1
71105: PPUSH
71106: LD_INT 7
71108: PPUSH
71109: CALL_OW 12
71113: ST_TO_ADDR
// case i of 1 :
71114: LD_VAR 0 1
71118: PUSH
71119: LD_INT 1
71121: DOUBLE
71122: EQUAL
71123: IFTRUE 71127
71125: GO 71137
71127: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
71128: LD_STRING earthquake(getX(game), 0, 32)
71130: PPUSH
71131: CALL_OW 559
71135: GO 71362
71137: LD_INT 2
71139: DOUBLE
71140: EQUAL
71141: IFTRUE 71145
71143: GO 71159
71145: POP
// begin ToLua ( displayStucuk(); ) ;
71146: LD_STRING displayStucuk();
71148: PPUSH
71149: CALL_OW 559
// ResetFog ;
71153: CALL_OW 335
// end ; 3 :
71157: GO 71362
71159: LD_INT 3
71161: DOUBLE
71162: EQUAL
71163: IFTRUE 71167
71165: GO 71271
71167: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
71168: LD_ADDR_VAR 0 2
71172: PUSH
71173: LD_INT 22
71175: PUSH
71176: LD_OWVAR 2
71180: PUSH
71181: EMPTY
71182: LIST
71183: LIST
71184: PUSH
71185: LD_INT 25
71187: PUSH
71188: LD_INT 1
71190: PUSH
71191: EMPTY
71192: LIST
71193: LIST
71194: PUSH
71195: EMPTY
71196: LIST
71197: LIST
71198: PPUSH
71199: CALL_OW 69
71203: ST_TO_ADDR
// if not tmp then
71204: LD_VAR 0 2
71208: NOT
71209: IFFALSE 71213
// exit ;
71211: GO 71362
// un := tmp [ rand ( 1 , tmp ) ] ;
71213: LD_ADDR_VAR 0 3
71217: PUSH
71218: LD_VAR 0 2
71222: PUSH
71223: LD_INT 1
71225: PPUSH
71226: LD_VAR 0 2
71230: PPUSH
71231: CALL_OW 12
71235: ARRAY
71236: ST_TO_ADDR
// if Crawls ( un ) then
71237: LD_VAR 0 3
71241: PPUSH
71242: CALL_OW 318
71246: IFFALSE 71257
// ComWalk ( un ) ;
71248: LD_VAR 0 3
71252: PPUSH
71253: CALL_OW 138
// SetClass ( un , class_mortar ) ;
71257: LD_VAR 0 3
71261: PPUSH
71262: LD_INT 8
71264: PPUSH
71265: CALL_OW 336
// end ; 4 :
71269: GO 71362
71271: LD_INT 4
71273: DOUBLE
71274: EQUAL
71275: IFTRUE 71279
71277: GO 71340
71279: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
71280: LD_ADDR_VAR 0 2
71284: PUSH
71285: LD_INT 22
71287: PUSH
71288: LD_OWVAR 2
71292: PUSH
71293: EMPTY
71294: LIST
71295: LIST
71296: PUSH
71297: LD_INT 30
71299: PUSH
71300: LD_INT 29
71302: PUSH
71303: EMPTY
71304: LIST
71305: LIST
71306: PUSH
71307: EMPTY
71308: LIST
71309: LIST
71310: PPUSH
71311: CALL_OW 69
71315: ST_TO_ADDR
// if not tmp then
71316: LD_VAR 0 2
71320: NOT
71321: IFFALSE 71325
// exit ;
71323: GO 71362
// DestroyUnit ( tmp [ 1 ] ) ;
71325: LD_VAR 0 2
71329: PUSH
71330: LD_INT 1
71332: ARRAY
71333: PPUSH
71334: CALL_OW 65
// end ; 5 .. 7 :
71338: GO 71362
71340: LD_INT 5
71342: DOUBLE
71343: GREATEREQUAL
71344: IFFALSE 71352
71346: LD_INT 7
71348: DOUBLE
71349: LESSEQUAL
71350: IFTRUE 71354
71352: GO 71361
71354: POP
// StreamSibBomb ; end ;
71355: CALL 67612 0 0
71359: GO 71362
71361: POP
// end ;
71362: PPOPN 3
71364: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
71365: LD_EXP 99
71369: PUSH
71370: LD_EXP 149
71374: AND
71375: IFFALSE 71531
71377: GO 71379
71379: DISABLE
71380: LD_INT 0
71382: PPUSH
71383: PPUSH
71384: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
71385: LD_ADDR_VAR 0 2
71389: PUSH
71390: LD_INT 81
71392: PUSH
71393: LD_OWVAR 2
71397: PUSH
71398: EMPTY
71399: LIST
71400: LIST
71401: PUSH
71402: LD_INT 2
71404: PUSH
71405: LD_INT 21
71407: PUSH
71408: LD_INT 1
71410: PUSH
71411: EMPTY
71412: LIST
71413: LIST
71414: PUSH
71415: LD_INT 21
71417: PUSH
71418: LD_INT 2
71420: PUSH
71421: EMPTY
71422: LIST
71423: LIST
71424: PUSH
71425: EMPTY
71426: LIST
71427: LIST
71428: LIST
71429: PUSH
71430: EMPTY
71431: LIST
71432: LIST
71433: PPUSH
71434: CALL_OW 69
71438: ST_TO_ADDR
// if not tmp then
71439: LD_VAR 0 2
71443: NOT
71444: IFFALSE 71448
// exit ;
71446: GO 71531
// p := 0 ;
71448: LD_ADDR_VAR 0 3
71452: PUSH
71453: LD_INT 0
71455: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
71456: LD_INT 35
71458: PPUSH
71459: CALL_OW 67
// p := p + 1 ;
71463: LD_ADDR_VAR 0 3
71467: PUSH
71468: LD_VAR 0 3
71472: PUSH
71473: LD_INT 1
71475: PLUS
71476: ST_TO_ADDR
// for i in tmp do
71477: LD_ADDR_VAR 0 1
71481: PUSH
71482: LD_VAR 0 2
71486: PUSH
71487: FOR_IN
71488: IFFALSE 71519
// if GetLives ( i ) < 1000 then
71490: LD_VAR 0 1
71494: PPUSH
71495: CALL_OW 256
71499: PUSH
71500: LD_INT 1000
71502: LESS
71503: IFFALSE 71517
// SetLives ( i , 1000 ) ;
71505: LD_VAR 0 1
71509: PPUSH
71510: LD_INT 1000
71512: PPUSH
71513: CALL_OW 234
71517: GO 71487
71519: POP
71520: POP
// until p > 20 ;
71521: LD_VAR 0 3
71525: PUSH
71526: LD_INT 20
71528: GREATER
71529: IFFALSE 71456
// end ;
71531: PPOPN 3
71533: END
// every 0 0$1 trigger StreamModeActive and sTime do
71534: LD_EXP 99
71538: PUSH
71539: LD_EXP 150
71543: AND
71544: IFFALSE 71579
71546: GO 71548
71548: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
71549: LD_INT 28
71551: PPUSH
71552: LD_OWVAR 2
71556: PPUSH
71557: LD_INT 2
71559: PPUSH
71560: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
71564: LD_INT 30
71566: PPUSH
71567: LD_OWVAR 2
71571: PPUSH
71572: LD_INT 2
71574: PPUSH
71575: CALL_OW 322
// end ;
71579: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
71580: LD_EXP 99
71584: PUSH
71585: LD_EXP 151
71589: AND
71590: IFFALSE 71711
71592: GO 71594
71594: DISABLE
71595: LD_INT 0
71597: PPUSH
71598: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
71599: LD_ADDR_VAR 0 2
71603: PUSH
71604: LD_INT 22
71606: PUSH
71607: LD_OWVAR 2
71611: PUSH
71612: EMPTY
71613: LIST
71614: LIST
71615: PUSH
71616: LD_INT 21
71618: PUSH
71619: LD_INT 1
71621: PUSH
71622: EMPTY
71623: LIST
71624: LIST
71625: PUSH
71626: LD_INT 3
71628: PUSH
71629: LD_INT 23
71631: PUSH
71632: LD_INT 0
71634: PUSH
71635: EMPTY
71636: LIST
71637: LIST
71638: PUSH
71639: EMPTY
71640: LIST
71641: LIST
71642: PUSH
71643: EMPTY
71644: LIST
71645: LIST
71646: LIST
71647: PPUSH
71648: CALL_OW 69
71652: ST_TO_ADDR
// if not tmp then
71653: LD_VAR 0 2
71657: NOT
71658: IFFALSE 71662
// exit ;
71660: GO 71711
// for i in tmp do
71662: LD_ADDR_VAR 0 1
71666: PUSH
71667: LD_VAR 0 2
71671: PUSH
71672: FOR_IN
71673: IFFALSE 71709
// begin if Crawls ( i ) then
71675: LD_VAR 0 1
71679: PPUSH
71680: CALL_OW 318
71684: IFFALSE 71695
// ComWalk ( i ) ;
71686: LD_VAR 0 1
71690: PPUSH
71691: CALL_OW 138
// SetClass ( i , 2 ) ;
71695: LD_VAR 0 1
71699: PPUSH
71700: LD_INT 2
71702: PPUSH
71703: CALL_OW 336
// end ;
71707: GO 71672
71709: POP
71710: POP
// end ;
71711: PPOPN 2
71713: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
71714: LD_EXP 99
71718: PUSH
71719: LD_EXP 152
71723: AND
71724: IFFALSE 72005
71726: GO 71728
71728: DISABLE
71729: LD_INT 0
71731: PPUSH
71732: PPUSH
71733: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
71734: LD_OWVAR 2
71738: PPUSH
71739: LD_INT 9
71741: PPUSH
71742: LD_INT 1
71744: PPUSH
71745: LD_INT 1
71747: PPUSH
71748: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
71752: LD_INT 9
71754: PPUSH
71755: LD_OWVAR 2
71759: PPUSH
71760: CALL_OW 343
// uc_side := 9 ;
71764: LD_ADDR_OWVAR 20
71768: PUSH
71769: LD_INT 9
71771: ST_TO_ADDR
// uc_nation := 2 ;
71772: LD_ADDR_OWVAR 21
71776: PUSH
71777: LD_INT 2
71779: ST_TO_ADDR
// hc_name := Dark Warrior ;
71780: LD_ADDR_OWVAR 26
71784: PUSH
71785: LD_STRING Dark Warrior
71787: ST_TO_ADDR
// hc_gallery :=  ;
71788: LD_ADDR_OWVAR 33
71792: PUSH
71793: LD_STRING 
71795: ST_TO_ADDR
// hc_noskilllimit := true ;
71796: LD_ADDR_OWVAR 76
71800: PUSH
71801: LD_INT 1
71803: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
71804: LD_ADDR_OWVAR 31
71808: PUSH
71809: LD_INT 30
71811: PUSH
71812: LD_INT 30
71814: PUSH
71815: LD_INT 30
71817: PUSH
71818: LD_INT 30
71820: PUSH
71821: EMPTY
71822: LIST
71823: LIST
71824: LIST
71825: LIST
71826: ST_TO_ADDR
// un := CreateHuman ;
71827: LD_ADDR_VAR 0 3
71831: PUSH
71832: CALL_OW 44
71836: ST_TO_ADDR
// hc_noskilllimit := false ;
71837: LD_ADDR_OWVAR 76
71841: PUSH
71842: LD_INT 0
71844: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
71845: LD_VAR 0 3
71849: PPUSH
71850: LD_INT 1
71852: PPUSH
71853: CALL_OW 51
// p := 0 ;
71857: LD_ADDR_VAR 0 2
71861: PUSH
71862: LD_INT 0
71864: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
71865: LD_INT 35
71867: PPUSH
71868: CALL_OW 67
// p := p + 1 ;
71872: LD_ADDR_VAR 0 2
71876: PUSH
71877: LD_VAR 0 2
71881: PUSH
71882: LD_INT 1
71884: PLUS
71885: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
71886: LD_VAR 0 3
71890: PPUSH
71891: CALL_OW 256
71895: PUSH
71896: LD_INT 1000
71898: LESS
71899: IFFALSE 71913
// SetLives ( un , 1000 ) ;
71901: LD_VAR 0 3
71905: PPUSH
71906: LD_INT 1000
71908: PPUSH
71909: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
71913: LD_VAR 0 3
71917: PPUSH
71918: LD_INT 81
71920: PUSH
71921: LD_OWVAR 2
71925: PUSH
71926: EMPTY
71927: LIST
71928: LIST
71929: PUSH
71930: LD_INT 91
71932: PUSH
71933: LD_VAR 0 3
71937: PUSH
71938: LD_INT 30
71940: PUSH
71941: EMPTY
71942: LIST
71943: LIST
71944: LIST
71945: PUSH
71946: EMPTY
71947: LIST
71948: LIST
71949: PPUSH
71950: CALL_OW 69
71954: PPUSH
71955: LD_VAR 0 3
71959: PPUSH
71960: CALL_OW 74
71964: PPUSH
71965: CALL_OW 115
// until p > 60 or IsDead ( un ) ;
71969: LD_VAR 0 2
71973: PUSH
71974: LD_INT 60
71976: GREATER
71977: PUSH
71978: LD_VAR 0 3
71982: PPUSH
71983: CALL_OW 301
71987: OR
71988: IFFALSE 71865
// if un then
71990: LD_VAR 0 3
71994: IFFALSE 72005
// RemoveUnit ( un ) ;
71996: LD_VAR 0 3
72000: PPUSH
72001: CALL_OW 64
// end ;
72005: PPOPN 3
72007: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
72008: LD_INT 0
72010: PPUSH
// case cmd of 301 :
72011: LD_VAR 0 1
72015: PUSH
72016: LD_INT 301
72018: DOUBLE
72019: EQUAL
72020: IFTRUE 72024
72022: GO 72056
72024: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
72025: LD_VAR 0 6
72029: PPUSH
72030: LD_VAR 0 7
72034: PPUSH
72035: LD_VAR 0 8
72039: PPUSH
72040: LD_VAR 0 4
72044: PPUSH
72045: LD_VAR 0 5
72049: PPUSH
72050: CALL 73257 0 5
72054: GO 72177
72056: LD_INT 302
72058: DOUBLE
72059: EQUAL
72060: IFTRUE 72064
72062: GO 72101
72064: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
72065: LD_VAR 0 6
72069: PPUSH
72070: LD_VAR 0 7
72074: PPUSH
72075: LD_VAR 0 8
72079: PPUSH
72080: LD_VAR 0 9
72084: PPUSH
72085: LD_VAR 0 4
72089: PPUSH
72090: LD_VAR 0 5
72094: PPUSH
72095: CALL 73348 0 6
72099: GO 72177
72101: LD_INT 303
72103: DOUBLE
72104: EQUAL
72105: IFTRUE 72109
72107: GO 72146
72109: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
72110: LD_VAR 0 6
72114: PPUSH
72115: LD_VAR 0 7
72119: PPUSH
72120: LD_VAR 0 8
72124: PPUSH
72125: LD_VAR 0 9
72129: PPUSH
72130: LD_VAR 0 4
72134: PPUSH
72135: LD_VAR 0 5
72139: PPUSH
72140: CALL 72182 0 6
72144: GO 72177
72146: LD_INT 304
72148: DOUBLE
72149: EQUAL
72150: IFTRUE 72154
72152: GO 72176
72154: POP
// hHackTeleport ( unit , x , y ) ; end ;
72155: LD_VAR 0 2
72159: PPUSH
72160: LD_VAR 0 4
72164: PPUSH
72165: LD_VAR 0 5
72169: PPUSH
72170: CALL 73941 0 3
72174: GO 72177
72176: POP
// end ;
72177: LD_VAR 0 12
72181: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
72182: LD_INT 0
72184: PPUSH
72185: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
72186: LD_VAR 0 1
72190: PUSH
72191: LD_INT 1
72193: LESS
72194: PUSH
72195: LD_VAR 0 1
72199: PUSH
72200: LD_INT 3
72202: GREATER
72203: OR
72204: PUSH
72205: LD_VAR 0 5
72209: PPUSH
72210: LD_VAR 0 6
72214: PPUSH
72215: CALL_OW 428
72219: OR
72220: IFFALSE 72224
// exit ;
72222: GO 72944
// uc_side := your_side ;
72224: LD_ADDR_OWVAR 20
72228: PUSH
72229: LD_OWVAR 2
72233: ST_TO_ADDR
// uc_nation := nation ;
72234: LD_ADDR_OWVAR 21
72238: PUSH
72239: LD_VAR 0 1
72243: ST_TO_ADDR
// bc_level = 1 ;
72244: LD_ADDR_OWVAR 43
72248: PUSH
72249: LD_INT 1
72251: ST_TO_ADDR
// case btype of 1 :
72252: LD_VAR 0 2
72256: PUSH
72257: LD_INT 1
72259: DOUBLE
72260: EQUAL
72261: IFTRUE 72265
72263: GO 72276
72265: POP
// bc_type := b_depot ; 2 :
72266: LD_ADDR_OWVAR 42
72270: PUSH
72271: LD_INT 0
72273: ST_TO_ADDR
72274: GO 72888
72276: LD_INT 2
72278: DOUBLE
72279: EQUAL
72280: IFTRUE 72284
72282: GO 72295
72284: POP
// bc_type := b_warehouse ; 3 :
72285: LD_ADDR_OWVAR 42
72289: PUSH
72290: LD_INT 1
72292: ST_TO_ADDR
72293: GO 72888
72295: LD_INT 3
72297: DOUBLE
72298: EQUAL
72299: IFTRUE 72303
72301: GO 72314
72303: POP
// bc_type := b_lab ; 4 .. 9 :
72304: LD_ADDR_OWVAR 42
72308: PUSH
72309: LD_INT 6
72311: ST_TO_ADDR
72312: GO 72888
72314: LD_INT 4
72316: DOUBLE
72317: GREATEREQUAL
72318: IFFALSE 72326
72320: LD_INT 9
72322: DOUBLE
72323: LESSEQUAL
72324: IFTRUE 72328
72326: GO 72380
72328: POP
// begin bc_type := b_lab_half ;
72329: LD_ADDR_OWVAR 42
72333: PUSH
72334: LD_INT 7
72336: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
72337: LD_ADDR_OWVAR 44
72341: PUSH
72342: LD_INT 10
72344: PUSH
72345: LD_INT 11
72347: PUSH
72348: LD_INT 12
72350: PUSH
72351: LD_INT 15
72353: PUSH
72354: LD_INT 14
72356: PUSH
72357: LD_INT 13
72359: PUSH
72360: EMPTY
72361: LIST
72362: LIST
72363: LIST
72364: LIST
72365: LIST
72366: LIST
72367: PUSH
72368: LD_VAR 0 2
72372: PUSH
72373: LD_INT 3
72375: MINUS
72376: ARRAY
72377: ST_TO_ADDR
// end ; 10 .. 13 :
72378: GO 72888
72380: LD_INT 10
72382: DOUBLE
72383: GREATEREQUAL
72384: IFFALSE 72392
72386: LD_INT 13
72388: DOUBLE
72389: LESSEQUAL
72390: IFTRUE 72394
72392: GO 72471
72394: POP
// begin bc_type := b_lab_full ;
72395: LD_ADDR_OWVAR 42
72399: PUSH
72400: LD_INT 8
72402: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
72403: LD_ADDR_OWVAR 44
72407: PUSH
72408: LD_INT 10
72410: PUSH
72411: LD_INT 12
72413: PUSH
72414: LD_INT 14
72416: PUSH
72417: LD_INT 13
72419: PUSH
72420: EMPTY
72421: LIST
72422: LIST
72423: LIST
72424: LIST
72425: PUSH
72426: LD_VAR 0 2
72430: PUSH
72431: LD_INT 9
72433: MINUS
72434: ARRAY
72435: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
72436: LD_ADDR_OWVAR 45
72440: PUSH
72441: LD_INT 11
72443: PUSH
72444: LD_INT 15
72446: PUSH
72447: LD_INT 12
72449: PUSH
72450: LD_INT 15
72452: PUSH
72453: EMPTY
72454: LIST
72455: LIST
72456: LIST
72457: LIST
72458: PUSH
72459: LD_VAR 0 2
72463: PUSH
72464: LD_INT 9
72466: MINUS
72467: ARRAY
72468: ST_TO_ADDR
// end ; 14 :
72469: GO 72888
72471: LD_INT 14
72473: DOUBLE
72474: EQUAL
72475: IFTRUE 72479
72477: GO 72490
72479: POP
// bc_type := b_workshop ; 15 :
72480: LD_ADDR_OWVAR 42
72484: PUSH
72485: LD_INT 2
72487: ST_TO_ADDR
72488: GO 72888
72490: LD_INT 15
72492: DOUBLE
72493: EQUAL
72494: IFTRUE 72498
72496: GO 72509
72498: POP
// bc_type := b_factory ; 16 :
72499: LD_ADDR_OWVAR 42
72503: PUSH
72504: LD_INT 3
72506: ST_TO_ADDR
72507: GO 72888
72509: LD_INT 16
72511: DOUBLE
72512: EQUAL
72513: IFTRUE 72517
72515: GO 72528
72517: POP
// bc_type := b_ext_gun ; 17 :
72518: LD_ADDR_OWVAR 42
72522: PUSH
72523: LD_INT 17
72525: ST_TO_ADDR
72526: GO 72888
72528: LD_INT 17
72530: DOUBLE
72531: EQUAL
72532: IFTRUE 72536
72534: GO 72564
72536: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
72537: LD_ADDR_OWVAR 42
72541: PUSH
72542: LD_INT 19
72544: PUSH
72545: LD_INT 23
72547: PUSH
72548: LD_INT 19
72550: PUSH
72551: EMPTY
72552: LIST
72553: LIST
72554: LIST
72555: PUSH
72556: LD_VAR 0 1
72560: ARRAY
72561: ST_TO_ADDR
72562: GO 72888
72564: LD_INT 18
72566: DOUBLE
72567: EQUAL
72568: IFTRUE 72572
72570: GO 72583
72572: POP
// bc_type := b_ext_radar ; 19 :
72573: LD_ADDR_OWVAR 42
72577: PUSH
72578: LD_INT 20
72580: ST_TO_ADDR
72581: GO 72888
72583: LD_INT 19
72585: DOUBLE
72586: EQUAL
72587: IFTRUE 72591
72589: GO 72602
72591: POP
// bc_type := b_ext_radio ; 20 :
72592: LD_ADDR_OWVAR 42
72596: PUSH
72597: LD_INT 22
72599: ST_TO_ADDR
72600: GO 72888
72602: LD_INT 20
72604: DOUBLE
72605: EQUAL
72606: IFTRUE 72610
72608: GO 72621
72610: POP
// bc_type := b_ext_siberium ; 21 :
72611: LD_ADDR_OWVAR 42
72615: PUSH
72616: LD_INT 21
72618: ST_TO_ADDR
72619: GO 72888
72621: LD_INT 21
72623: DOUBLE
72624: EQUAL
72625: IFTRUE 72629
72627: GO 72640
72629: POP
// bc_type := b_ext_computer ; 22 :
72630: LD_ADDR_OWVAR 42
72634: PUSH
72635: LD_INT 24
72637: ST_TO_ADDR
72638: GO 72888
72640: LD_INT 22
72642: DOUBLE
72643: EQUAL
72644: IFTRUE 72648
72646: GO 72659
72648: POP
// bc_type := b_ext_track ; 23 :
72649: LD_ADDR_OWVAR 42
72653: PUSH
72654: LD_INT 16
72656: ST_TO_ADDR
72657: GO 72888
72659: LD_INT 23
72661: DOUBLE
72662: EQUAL
72663: IFTRUE 72667
72665: GO 72678
72667: POP
// bc_type := b_ext_laser ; 24 :
72668: LD_ADDR_OWVAR 42
72672: PUSH
72673: LD_INT 25
72675: ST_TO_ADDR
72676: GO 72888
72678: LD_INT 24
72680: DOUBLE
72681: EQUAL
72682: IFTRUE 72686
72684: GO 72697
72686: POP
// bc_type := b_control_tower ; 25 :
72687: LD_ADDR_OWVAR 42
72691: PUSH
72692: LD_INT 36
72694: ST_TO_ADDR
72695: GO 72888
72697: LD_INT 25
72699: DOUBLE
72700: EQUAL
72701: IFTRUE 72705
72703: GO 72716
72705: POP
// bc_type := b_breastwork ; 26 :
72706: LD_ADDR_OWVAR 42
72710: PUSH
72711: LD_INT 31
72713: ST_TO_ADDR
72714: GO 72888
72716: LD_INT 26
72718: DOUBLE
72719: EQUAL
72720: IFTRUE 72724
72722: GO 72735
72724: POP
// bc_type := b_bunker ; 27 :
72725: LD_ADDR_OWVAR 42
72729: PUSH
72730: LD_INT 32
72732: ST_TO_ADDR
72733: GO 72888
72735: LD_INT 27
72737: DOUBLE
72738: EQUAL
72739: IFTRUE 72743
72741: GO 72754
72743: POP
// bc_type := b_turret ; 28 :
72744: LD_ADDR_OWVAR 42
72748: PUSH
72749: LD_INT 33
72751: ST_TO_ADDR
72752: GO 72888
72754: LD_INT 28
72756: DOUBLE
72757: EQUAL
72758: IFTRUE 72762
72760: GO 72773
72762: POP
// bc_type := b_armoury ; 29 :
72763: LD_ADDR_OWVAR 42
72767: PUSH
72768: LD_INT 4
72770: ST_TO_ADDR
72771: GO 72888
72773: LD_INT 29
72775: DOUBLE
72776: EQUAL
72777: IFTRUE 72781
72779: GO 72792
72781: POP
// bc_type := b_barracks ; 30 :
72782: LD_ADDR_OWVAR 42
72786: PUSH
72787: LD_INT 5
72789: ST_TO_ADDR
72790: GO 72888
72792: LD_INT 30
72794: DOUBLE
72795: EQUAL
72796: IFTRUE 72800
72798: GO 72811
72800: POP
// bc_type := b_solar_power ; 31 :
72801: LD_ADDR_OWVAR 42
72805: PUSH
72806: LD_INT 27
72808: ST_TO_ADDR
72809: GO 72888
72811: LD_INT 31
72813: DOUBLE
72814: EQUAL
72815: IFTRUE 72819
72817: GO 72830
72819: POP
// bc_type := b_oil_power ; 32 :
72820: LD_ADDR_OWVAR 42
72824: PUSH
72825: LD_INT 26
72827: ST_TO_ADDR
72828: GO 72888
72830: LD_INT 32
72832: DOUBLE
72833: EQUAL
72834: IFTRUE 72838
72836: GO 72849
72838: POP
// bc_type := b_siberite_power ; 33 :
72839: LD_ADDR_OWVAR 42
72843: PUSH
72844: LD_INT 28
72846: ST_TO_ADDR
72847: GO 72888
72849: LD_INT 33
72851: DOUBLE
72852: EQUAL
72853: IFTRUE 72857
72855: GO 72868
72857: POP
// bc_type := b_oil_mine ; 34 :
72858: LD_ADDR_OWVAR 42
72862: PUSH
72863: LD_INT 29
72865: ST_TO_ADDR
72866: GO 72888
72868: LD_INT 34
72870: DOUBLE
72871: EQUAL
72872: IFTRUE 72876
72874: GO 72887
72876: POP
// bc_type := b_siberite_mine ; end ;
72877: LD_ADDR_OWVAR 42
72881: PUSH
72882: LD_INT 30
72884: ST_TO_ADDR
72885: GO 72888
72887: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
72888: LD_ADDR_VAR 0 8
72892: PUSH
72893: LD_VAR 0 5
72897: PPUSH
72898: LD_VAR 0 6
72902: PPUSH
72903: LD_VAR 0 3
72907: PPUSH
72908: CALL_OW 47
72912: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
72913: LD_OWVAR 42
72917: PUSH
72918: LD_INT 32
72920: PUSH
72921: LD_INT 33
72923: PUSH
72924: EMPTY
72925: LIST
72926: LIST
72927: IN
72928: IFFALSE 72944
// PlaceWeaponTurret ( b , weapon ) ;
72930: LD_VAR 0 8
72934: PPUSH
72935: LD_VAR 0 4
72939: PPUSH
72940: CALL_OW 431
// end ;
72944: LD_VAR 0 7
72948: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
72949: LD_INT 0
72951: PPUSH
72952: PPUSH
72953: PPUSH
72954: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
72955: LD_ADDR_VAR 0 4
72959: PUSH
72960: LD_INT 22
72962: PUSH
72963: LD_OWVAR 2
72967: PUSH
72968: EMPTY
72969: LIST
72970: LIST
72971: PUSH
72972: LD_INT 2
72974: PUSH
72975: LD_INT 30
72977: PUSH
72978: LD_INT 0
72980: PUSH
72981: EMPTY
72982: LIST
72983: LIST
72984: PUSH
72985: LD_INT 30
72987: PUSH
72988: LD_INT 1
72990: PUSH
72991: EMPTY
72992: LIST
72993: LIST
72994: PUSH
72995: EMPTY
72996: LIST
72997: LIST
72998: LIST
72999: PUSH
73000: EMPTY
73001: LIST
73002: LIST
73003: PPUSH
73004: CALL_OW 69
73008: ST_TO_ADDR
// if not tmp then
73009: LD_VAR 0 4
73013: NOT
73014: IFFALSE 73018
// exit ;
73016: GO 73077
// for i in tmp do
73018: LD_ADDR_VAR 0 2
73022: PUSH
73023: LD_VAR 0 4
73027: PUSH
73028: FOR_IN
73029: IFFALSE 73075
// for j = 1 to 3 do
73031: LD_ADDR_VAR 0 3
73035: PUSH
73036: DOUBLE
73037: LD_INT 1
73039: DEC
73040: ST_TO_ADDR
73041: LD_INT 3
73043: PUSH
73044: FOR_TO
73045: IFFALSE 73071
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
73047: LD_VAR 0 2
73051: PPUSH
73052: CALL_OW 274
73056: PPUSH
73057: LD_VAR 0 3
73061: PPUSH
73062: LD_INT 99999
73064: PPUSH
73065: CALL_OW 277
73069: GO 73044
73071: POP
73072: POP
73073: GO 73028
73075: POP
73076: POP
// end ;
73077: LD_VAR 0 1
73081: RET
// export function hHackSetLevel10 ; var i , j ; begin
73082: LD_INT 0
73084: PPUSH
73085: PPUSH
73086: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
73087: LD_ADDR_VAR 0 2
73091: PUSH
73092: LD_INT 21
73094: PUSH
73095: LD_INT 1
73097: PUSH
73098: EMPTY
73099: LIST
73100: LIST
73101: PPUSH
73102: CALL_OW 69
73106: PUSH
73107: FOR_IN
73108: IFFALSE 73160
// if IsSelected ( i ) then
73110: LD_VAR 0 2
73114: PPUSH
73115: CALL_OW 306
73119: IFFALSE 73158
// begin for j := 1 to 4 do
73121: LD_ADDR_VAR 0 3
73125: PUSH
73126: DOUBLE
73127: LD_INT 1
73129: DEC
73130: ST_TO_ADDR
73131: LD_INT 4
73133: PUSH
73134: FOR_TO
73135: IFFALSE 73156
// SetSkill ( i , j , 10 ) ;
73137: LD_VAR 0 2
73141: PPUSH
73142: LD_VAR 0 3
73146: PPUSH
73147: LD_INT 10
73149: PPUSH
73150: CALL_OW 237
73154: GO 73134
73156: POP
73157: POP
// end ;
73158: GO 73107
73160: POP
73161: POP
// end ;
73162: LD_VAR 0 1
73166: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
73167: LD_INT 0
73169: PPUSH
73170: PPUSH
73171: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
73172: LD_ADDR_VAR 0 2
73176: PUSH
73177: LD_INT 22
73179: PUSH
73180: LD_OWVAR 2
73184: PUSH
73185: EMPTY
73186: LIST
73187: LIST
73188: PUSH
73189: LD_INT 21
73191: PUSH
73192: LD_INT 1
73194: PUSH
73195: EMPTY
73196: LIST
73197: LIST
73198: PUSH
73199: EMPTY
73200: LIST
73201: LIST
73202: PPUSH
73203: CALL_OW 69
73207: PUSH
73208: FOR_IN
73209: IFFALSE 73250
// begin for j := 1 to 4 do
73211: LD_ADDR_VAR 0 3
73215: PUSH
73216: DOUBLE
73217: LD_INT 1
73219: DEC
73220: ST_TO_ADDR
73221: LD_INT 4
73223: PUSH
73224: FOR_TO
73225: IFFALSE 73246
// SetSkill ( i , j , 10 ) ;
73227: LD_VAR 0 2
73231: PPUSH
73232: LD_VAR 0 3
73236: PPUSH
73237: LD_INT 10
73239: PPUSH
73240: CALL_OW 237
73244: GO 73224
73246: POP
73247: POP
// end ;
73248: GO 73208
73250: POP
73251: POP
// end ;
73252: LD_VAR 0 1
73256: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
73257: LD_INT 0
73259: PPUSH
// uc_side := your_side ;
73260: LD_ADDR_OWVAR 20
73264: PUSH
73265: LD_OWVAR 2
73269: ST_TO_ADDR
// uc_nation := nation ;
73270: LD_ADDR_OWVAR 21
73274: PUSH
73275: LD_VAR 0 1
73279: ST_TO_ADDR
// InitHc ;
73280: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
73284: LD_INT 0
73286: PPUSH
73287: LD_VAR 0 2
73291: PPUSH
73292: LD_VAR 0 3
73296: PPUSH
73297: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
73301: LD_VAR 0 4
73305: PPUSH
73306: LD_VAR 0 5
73310: PPUSH
73311: CALL_OW 428
73315: PUSH
73316: LD_INT 0
73318: EQUAL
73319: IFFALSE 73343
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
73321: CALL_OW 44
73325: PPUSH
73326: LD_VAR 0 4
73330: PPUSH
73331: LD_VAR 0 5
73335: PPUSH
73336: LD_INT 1
73338: PPUSH
73339: CALL_OW 48
// end ;
73343: LD_VAR 0 6
73347: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
73348: LD_INT 0
73350: PPUSH
73351: PPUSH
// uc_side := your_side ;
73352: LD_ADDR_OWVAR 20
73356: PUSH
73357: LD_OWVAR 2
73361: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
73362: LD_VAR 0 1
73366: PUSH
73367: LD_INT 1
73369: PUSH
73370: LD_INT 2
73372: PUSH
73373: LD_INT 3
73375: PUSH
73376: LD_INT 4
73378: PUSH
73379: LD_INT 5
73381: PUSH
73382: EMPTY
73383: LIST
73384: LIST
73385: LIST
73386: LIST
73387: LIST
73388: IN
73389: IFFALSE 73401
// uc_nation := nation_american else
73391: LD_ADDR_OWVAR 21
73395: PUSH
73396: LD_INT 1
73398: ST_TO_ADDR
73399: GO 73444
// if chassis in [ 11 , 12 , 13 , 14 ] then
73401: LD_VAR 0 1
73405: PUSH
73406: LD_INT 11
73408: PUSH
73409: LD_INT 12
73411: PUSH
73412: LD_INT 13
73414: PUSH
73415: LD_INT 14
73417: PUSH
73418: EMPTY
73419: LIST
73420: LIST
73421: LIST
73422: LIST
73423: IN
73424: IFFALSE 73436
// uc_nation := nation_arabian else
73426: LD_ADDR_OWVAR 21
73430: PUSH
73431: LD_INT 2
73433: ST_TO_ADDR
73434: GO 73444
// uc_nation := nation_russian ;
73436: LD_ADDR_OWVAR 21
73440: PUSH
73441: LD_INT 3
73443: ST_TO_ADDR
// vc_chassis := chassis ;
73444: LD_ADDR_OWVAR 37
73448: PUSH
73449: LD_VAR 0 1
73453: ST_TO_ADDR
// vc_engine := engine ;
73454: LD_ADDR_OWVAR 39
73458: PUSH
73459: LD_VAR 0 2
73463: ST_TO_ADDR
// vc_control := control ;
73464: LD_ADDR_OWVAR 38
73468: PUSH
73469: LD_VAR 0 3
73473: ST_TO_ADDR
// vc_weapon := weapon ;
73474: LD_ADDR_OWVAR 40
73478: PUSH
73479: LD_VAR 0 4
73483: ST_TO_ADDR
// un := CreateVehicle ;
73484: LD_ADDR_VAR 0 8
73488: PUSH
73489: CALL_OW 45
73493: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
73494: LD_VAR 0 8
73498: PPUSH
73499: LD_INT 0
73501: PPUSH
73502: LD_INT 5
73504: PPUSH
73505: CALL_OW 12
73509: PPUSH
73510: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
73514: LD_VAR 0 8
73518: PPUSH
73519: LD_VAR 0 5
73523: PPUSH
73524: LD_VAR 0 6
73528: PPUSH
73529: LD_INT 1
73531: PPUSH
73532: CALL_OW 48
// end ;
73536: LD_VAR 0 7
73540: RET
// export hInvincible ; every 1 do
73541: GO 73543
73543: DISABLE
// hInvincible := [ ] ;
73544: LD_ADDR_EXP 153
73548: PUSH
73549: EMPTY
73550: ST_TO_ADDR
73551: END
// every 10 do var i ;
73552: GO 73554
73554: DISABLE
73555: LD_INT 0
73557: PPUSH
// begin enable ;
73558: ENABLE
// if not hInvincible then
73559: LD_EXP 153
73563: NOT
73564: IFFALSE 73568
// exit ;
73566: GO 73612
// for i in hInvincible do
73568: LD_ADDR_VAR 0 1
73572: PUSH
73573: LD_EXP 153
73577: PUSH
73578: FOR_IN
73579: IFFALSE 73610
// if GetLives ( i ) < 1000 then
73581: LD_VAR 0 1
73585: PPUSH
73586: CALL_OW 256
73590: PUSH
73591: LD_INT 1000
73593: LESS
73594: IFFALSE 73608
// SetLives ( i , 1000 ) ;
73596: LD_VAR 0 1
73600: PPUSH
73601: LD_INT 1000
73603: PPUSH
73604: CALL_OW 234
73608: GO 73578
73610: POP
73611: POP
// end ;
73612: PPOPN 1
73614: END
// export function hHackInvincible ; var i ; begin
73615: LD_INT 0
73617: PPUSH
73618: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
73619: LD_ADDR_VAR 0 2
73623: PUSH
73624: LD_INT 2
73626: PUSH
73627: LD_INT 21
73629: PUSH
73630: LD_INT 1
73632: PUSH
73633: EMPTY
73634: LIST
73635: LIST
73636: PUSH
73637: LD_INT 21
73639: PUSH
73640: LD_INT 2
73642: PUSH
73643: EMPTY
73644: LIST
73645: LIST
73646: PUSH
73647: EMPTY
73648: LIST
73649: LIST
73650: LIST
73651: PPUSH
73652: CALL_OW 69
73656: PUSH
73657: FOR_IN
73658: IFFALSE 73719
// if IsSelected ( i ) then
73660: LD_VAR 0 2
73664: PPUSH
73665: CALL_OW 306
73669: IFFALSE 73717
// begin if i in hInvincible then
73671: LD_VAR 0 2
73675: PUSH
73676: LD_EXP 153
73680: IN
73681: IFFALSE 73701
// hInvincible := hInvincible diff i else
73683: LD_ADDR_EXP 153
73687: PUSH
73688: LD_EXP 153
73692: PUSH
73693: LD_VAR 0 2
73697: DIFF
73698: ST_TO_ADDR
73699: GO 73717
// hInvincible := hInvincible union i ;
73701: LD_ADDR_EXP 153
73705: PUSH
73706: LD_EXP 153
73710: PUSH
73711: LD_VAR 0 2
73715: UNION
73716: ST_TO_ADDR
// end ;
73717: GO 73657
73719: POP
73720: POP
// end ;
73721: LD_VAR 0 1
73725: RET
// export function hHackInvisible ; var i , j ; begin
73726: LD_INT 0
73728: PPUSH
73729: PPUSH
73730: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
73731: LD_ADDR_VAR 0 2
73735: PUSH
73736: LD_INT 21
73738: PUSH
73739: LD_INT 1
73741: PUSH
73742: EMPTY
73743: LIST
73744: LIST
73745: PPUSH
73746: CALL_OW 69
73750: PUSH
73751: FOR_IN
73752: IFFALSE 73776
// if IsSelected ( i ) then
73754: LD_VAR 0 2
73758: PPUSH
73759: CALL_OW 306
73763: IFFALSE 73774
// ComForceInvisible ( i ) ;
73765: LD_VAR 0 2
73769: PPUSH
73770: CALL_OW 496
73774: GO 73751
73776: POP
73777: POP
// end ;
73778: LD_VAR 0 1
73782: RET
// export function hHackChangeYourSide ; begin
73783: LD_INT 0
73785: PPUSH
// if your_side = 8 then
73786: LD_OWVAR 2
73790: PUSH
73791: LD_INT 8
73793: EQUAL
73794: IFFALSE 73806
// your_side := 0 else
73796: LD_ADDR_OWVAR 2
73800: PUSH
73801: LD_INT 0
73803: ST_TO_ADDR
73804: GO 73820
// your_side := your_side + 1 ;
73806: LD_ADDR_OWVAR 2
73810: PUSH
73811: LD_OWVAR 2
73815: PUSH
73816: LD_INT 1
73818: PLUS
73819: ST_TO_ADDR
// end ;
73820: LD_VAR 0 1
73824: RET
// export function hHackChangeUnitSide ; var i , j ; begin
73825: LD_INT 0
73827: PPUSH
73828: PPUSH
73829: PPUSH
// for i in all_units do
73830: LD_ADDR_VAR 0 2
73834: PUSH
73835: LD_OWVAR 3
73839: PUSH
73840: FOR_IN
73841: IFFALSE 73919
// if IsSelected ( i ) then
73843: LD_VAR 0 2
73847: PPUSH
73848: CALL_OW 306
73852: IFFALSE 73917
// begin j := GetSide ( i ) ;
73854: LD_ADDR_VAR 0 3
73858: PUSH
73859: LD_VAR 0 2
73863: PPUSH
73864: CALL_OW 255
73868: ST_TO_ADDR
// if j = 8 then
73869: LD_VAR 0 3
73873: PUSH
73874: LD_INT 8
73876: EQUAL
73877: IFFALSE 73889
// j := 0 else
73879: LD_ADDR_VAR 0 3
73883: PUSH
73884: LD_INT 0
73886: ST_TO_ADDR
73887: GO 73903
// j := j + 1 ;
73889: LD_ADDR_VAR 0 3
73893: PUSH
73894: LD_VAR 0 3
73898: PUSH
73899: LD_INT 1
73901: PLUS
73902: ST_TO_ADDR
// SetSide ( i , j ) ;
73903: LD_VAR 0 2
73907: PPUSH
73908: LD_VAR 0 3
73912: PPUSH
73913: CALL_OW 235
// end ;
73917: GO 73840
73919: POP
73920: POP
// end ;
73921: LD_VAR 0 1
73925: RET
// export function hHackFog ; begin
73926: LD_INT 0
73928: PPUSH
// FogOff ( true ) ;
73929: LD_INT 1
73931: PPUSH
73932: CALL_OW 344
// end ;
73936: LD_VAR 0 1
73940: RET
// export function hHackTeleport ( unit , x , y ) ; begin
73941: LD_INT 0
73943: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
73944: LD_VAR 0 1
73948: PPUSH
73949: LD_VAR 0 2
73953: PPUSH
73954: LD_VAR 0 3
73958: PPUSH
73959: LD_INT 1
73961: PPUSH
73962: LD_INT 1
73964: PPUSH
73965: CALL_OW 483
// CenterOnXY ( x , y ) ;
73969: LD_VAR 0 2
73973: PPUSH
73974: LD_VAR 0 3
73978: PPUSH
73979: CALL_OW 84
// end ; end_of_file
73983: LD_VAR 0 4
73987: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb , ar_heavy_mortar , ar_crane , ar_miner ; export tech_Artillery , tech_RadMat , tech_BasicTools , tech_Cargo , tech_Track , tech_Crane , tech_Bulldozer , tech_Hovercraft ; export function InitGlobalVariables ; begin
73988: LD_INT 0
73990: PPUSH
// ar_miner := 81 ;
73991: LD_ADDR_EXP 161
73995: PUSH
73996: LD_INT 81
73998: ST_TO_ADDR
// ar_crane := 88 ;
73999: LD_ADDR_EXP 160
74003: PUSH
74004: LD_INT 88
74006: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
74007: LD_ADDR_EXP 155
74011: PUSH
74012: LD_INT 89
74014: ST_TO_ADDR
// us_hack := 99 ;
74015: LD_ADDR_EXP 156
74019: PUSH
74020: LD_INT 99
74022: ST_TO_ADDR
// us_artillery := 97 ;
74023: LD_ADDR_EXP 157
74027: PUSH
74028: LD_INT 97
74030: ST_TO_ADDR
// ar_bio_bomb := 91 ;
74031: LD_ADDR_EXP 158
74035: PUSH
74036: LD_INT 91
74038: ST_TO_ADDR
// ar_heavy_mortar := 92 ;
74039: LD_ADDR_EXP 159
74043: PUSH
74044: LD_INT 92
74046: ST_TO_ADDR
// ru_radar := 98 ;
74047: LD_ADDR_EXP 154
74051: PUSH
74052: LD_INT 98
74054: ST_TO_ADDR
// tech_Artillery := 80 ;
74055: LD_ADDR_EXP 162
74059: PUSH
74060: LD_INT 80
74062: ST_TO_ADDR
// tech_RadMat := 81 ;
74063: LD_ADDR_EXP 163
74067: PUSH
74068: LD_INT 81
74070: ST_TO_ADDR
// tech_BasicTools := 82 ;
74071: LD_ADDR_EXP 164
74075: PUSH
74076: LD_INT 82
74078: ST_TO_ADDR
// tech_Cargo := 83 ;
74079: LD_ADDR_EXP 165
74083: PUSH
74084: LD_INT 83
74086: ST_TO_ADDR
// tech_Track := 84 ;
74087: LD_ADDR_EXP 166
74091: PUSH
74092: LD_INT 84
74094: ST_TO_ADDR
// tech_Crane := 85 ;
74095: LD_ADDR_EXP 167
74099: PUSH
74100: LD_INT 85
74102: ST_TO_ADDR
// tech_Bulldozer := 86 ;
74103: LD_ADDR_EXP 168
74107: PUSH
74108: LD_INT 86
74110: ST_TO_ADDR
// tech_Hovercraft := 87 ;
74111: LD_ADDR_EXP 169
74115: PUSH
74116: LD_INT 87
74118: ST_TO_ADDR
// end ;
74119: LD_VAR 0 1
74123: RET
// every 1 do
74124: GO 74126
74126: DISABLE
// InitGlobalVariables ; end_of_file
74127: CALL 73988 0 0
74131: END
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
74132: LD_VAR 0 1
74136: PUSH
74137: LD_INT 200
74139: DOUBLE
74140: GREATEREQUAL
74141: IFFALSE 74149
74143: LD_INT 299
74145: DOUBLE
74146: LESSEQUAL
74147: IFTRUE 74151
74149: GO 74183
74151: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
74152: LD_VAR 0 1
74156: PPUSH
74157: LD_VAR 0 2
74161: PPUSH
74162: LD_VAR 0 3
74166: PPUSH
74167: LD_VAR 0 4
74171: PPUSH
74172: LD_VAR 0 5
74176: PPUSH
74177: CALL 56938 0 5
74181: GO 74260
74183: LD_INT 300
74185: DOUBLE
74186: GREATEREQUAL
74187: IFFALSE 74195
74189: LD_INT 399
74191: DOUBLE
74192: LESSEQUAL
74193: IFTRUE 74197
74195: GO 74259
74197: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
74198: LD_VAR 0 1
74202: PPUSH
74203: LD_VAR 0 2
74207: PPUSH
74208: LD_VAR 0 3
74212: PPUSH
74213: LD_VAR 0 4
74217: PPUSH
74218: LD_VAR 0 5
74222: PPUSH
74223: LD_VAR 0 6
74227: PPUSH
74228: LD_VAR 0 7
74232: PPUSH
74233: LD_VAR 0 8
74237: PPUSH
74238: LD_VAR 0 9
74242: PPUSH
74243: LD_VAR 0 10
74247: PPUSH
74248: LD_VAR 0 11
74252: PPUSH
74253: CALL 72008 0 11
74257: GO 74260
74259: POP
// end ;
74260: PPOPN 11
74262: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
74263: LD_VAR 0 1
74267: PPUSH
74268: LD_VAR 0 2
74272: PPUSH
74273: LD_VAR 0 3
74277: PPUSH
74278: LD_VAR 0 4
74282: PPUSH
74283: LD_VAR 0 5
74287: PPUSH
74288: CALL 56920 0 5
// end ; end_of_file
74292: PPOPN 5
74294: END
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
74295: LD_INT 0
74297: PPUSH
74298: PPUSH
74299: PPUSH
74300: PPUSH
74301: PPUSH
74302: PPUSH
74303: PPUSH
74304: PPUSH
74305: PPUSH
74306: PPUSH
74307: PPUSH
74308: PPUSH
74309: PPUSH
74310: PPUSH
74311: PPUSH
74312: PPUSH
74313: PPUSH
74314: PPUSH
74315: PPUSH
74316: PPUSH
74317: PPUSH
74318: PPUSH
74319: PPUSH
74320: PPUSH
74321: PPUSH
74322: PPUSH
74323: PPUSH
74324: PPUSH
74325: PPUSH
74326: PPUSH
74327: PPUSH
74328: PPUSH
74329: PPUSH
74330: PPUSH
// if not list then
74331: LD_VAR 0 1
74335: NOT
74336: IFFALSE 74340
// exit ;
74338: GO 78999
// base := list [ 1 ] ;
74340: LD_ADDR_VAR 0 3
74344: PUSH
74345: LD_VAR 0 1
74349: PUSH
74350: LD_INT 1
74352: ARRAY
74353: ST_TO_ADDR
// group := list [ 2 ] ;
74354: LD_ADDR_VAR 0 4
74358: PUSH
74359: LD_VAR 0 1
74363: PUSH
74364: LD_INT 2
74366: ARRAY
74367: ST_TO_ADDR
// path := list [ 3 ] ;
74368: LD_ADDR_VAR 0 5
74372: PUSH
74373: LD_VAR 0 1
74377: PUSH
74378: LD_INT 3
74380: ARRAY
74381: ST_TO_ADDR
// flags := list [ 4 ] ;
74382: LD_ADDR_VAR 0 6
74386: PUSH
74387: LD_VAR 0 1
74391: PUSH
74392: LD_INT 4
74394: ARRAY
74395: ST_TO_ADDR
// mined := [ ] ;
74396: LD_ADDR_VAR 0 27
74400: PUSH
74401: EMPTY
74402: ST_TO_ADDR
// bombed := [ ] ;
74403: LD_ADDR_VAR 0 28
74407: PUSH
74408: EMPTY
74409: ST_TO_ADDR
// healers := [ ] ;
74410: LD_ADDR_VAR 0 31
74414: PUSH
74415: EMPTY
74416: ST_TO_ADDR
// to_heal := [ ] ;
74417: LD_ADDR_VAR 0 30
74421: PUSH
74422: EMPTY
74423: ST_TO_ADDR
// repairs := [ ] ;
74424: LD_ADDR_VAR 0 33
74428: PUSH
74429: EMPTY
74430: ST_TO_ADDR
// to_repair := [ ] ;
74431: LD_ADDR_VAR 0 32
74435: PUSH
74436: EMPTY
74437: ST_TO_ADDR
// if not group or not path then
74438: LD_VAR 0 4
74442: NOT
74443: PUSH
74444: LD_VAR 0 5
74448: NOT
74449: OR
74450: IFFALSE 74454
// exit ;
74452: GO 78999
// side := GetSide ( group [ 1 ] ) ;
74454: LD_ADDR_VAR 0 35
74458: PUSH
74459: LD_VAR 0 4
74463: PUSH
74464: LD_INT 1
74466: ARRAY
74467: PPUSH
74468: CALL_OW 255
74472: ST_TO_ADDR
// if flags then
74473: LD_VAR 0 6
74477: IFFALSE 74621
// begin f_ignore_area := flags [ 1 ] ;
74479: LD_ADDR_VAR 0 17
74483: PUSH
74484: LD_VAR 0 6
74488: PUSH
74489: LD_INT 1
74491: ARRAY
74492: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
74493: LD_ADDR_VAR 0 18
74497: PUSH
74498: LD_VAR 0 6
74502: PUSH
74503: LD_INT 2
74505: ARRAY
74506: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
74507: LD_ADDR_VAR 0 19
74511: PUSH
74512: LD_VAR 0 6
74516: PUSH
74517: LD_INT 3
74519: ARRAY
74520: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
74521: LD_ADDR_VAR 0 20
74525: PUSH
74526: LD_VAR 0 6
74530: PUSH
74531: LD_INT 4
74533: ARRAY
74534: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
74535: LD_ADDR_VAR 0 21
74539: PUSH
74540: LD_VAR 0 6
74544: PUSH
74545: LD_INT 5
74547: ARRAY
74548: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
74549: LD_ADDR_VAR 0 22
74553: PUSH
74554: LD_VAR 0 6
74558: PUSH
74559: LD_INT 6
74561: ARRAY
74562: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
74563: LD_ADDR_VAR 0 23
74567: PUSH
74568: LD_VAR 0 6
74572: PUSH
74573: LD_INT 7
74575: ARRAY
74576: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
74577: LD_ADDR_VAR 0 24
74581: PUSH
74582: LD_VAR 0 6
74586: PUSH
74587: LD_INT 8
74589: ARRAY
74590: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
74591: LD_ADDR_VAR 0 25
74595: PUSH
74596: LD_VAR 0 6
74600: PUSH
74601: LD_INT 9
74603: ARRAY
74604: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
74605: LD_ADDR_VAR 0 26
74609: PUSH
74610: LD_VAR 0 6
74614: PUSH
74615: LD_INT 10
74617: ARRAY
74618: ST_TO_ADDR
// end else
74619: GO 74701
// begin f_ignore_area := false ;
74621: LD_ADDR_VAR 0 17
74625: PUSH
74626: LD_INT 0
74628: ST_TO_ADDR
// f_capture := false ;
74629: LD_ADDR_VAR 0 18
74633: PUSH
74634: LD_INT 0
74636: ST_TO_ADDR
// f_ignore_civ := false ;
74637: LD_ADDR_VAR 0 19
74641: PUSH
74642: LD_INT 0
74644: ST_TO_ADDR
// f_murder := false ;
74645: LD_ADDR_VAR 0 20
74649: PUSH
74650: LD_INT 0
74652: ST_TO_ADDR
// f_mines := false ;
74653: LD_ADDR_VAR 0 21
74657: PUSH
74658: LD_INT 0
74660: ST_TO_ADDR
// f_repair := false ;
74661: LD_ADDR_VAR 0 22
74665: PUSH
74666: LD_INT 0
74668: ST_TO_ADDR
// f_heal := false ;
74669: LD_ADDR_VAR 0 23
74673: PUSH
74674: LD_INT 0
74676: ST_TO_ADDR
// f_spacetime := false ;
74677: LD_ADDR_VAR 0 24
74681: PUSH
74682: LD_INT 0
74684: ST_TO_ADDR
// f_attack_depot := false ;
74685: LD_ADDR_VAR 0 25
74689: PUSH
74690: LD_INT 0
74692: ST_TO_ADDR
// f_crawl := false ;
74693: LD_ADDR_VAR 0 26
74697: PUSH
74698: LD_INT 0
74700: ST_TO_ADDR
// end ; if f_heal then
74701: LD_VAR 0 23
74705: IFFALSE 74732
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
74707: LD_ADDR_VAR 0 31
74711: PUSH
74712: LD_VAR 0 4
74716: PPUSH
74717: LD_INT 25
74719: PUSH
74720: LD_INT 4
74722: PUSH
74723: EMPTY
74724: LIST
74725: LIST
74726: PPUSH
74727: CALL_OW 72
74731: ST_TO_ADDR
// if f_repair then
74732: LD_VAR 0 22
74736: IFFALSE 74763
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
74738: LD_ADDR_VAR 0 33
74742: PUSH
74743: LD_VAR 0 4
74747: PPUSH
74748: LD_INT 25
74750: PUSH
74751: LD_INT 3
74753: PUSH
74754: EMPTY
74755: LIST
74756: LIST
74757: PPUSH
74758: CALL_OW 72
74762: ST_TO_ADDR
// units_path := [ ] ;
74763: LD_ADDR_VAR 0 16
74767: PUSH
74768: EMPTY
74769: ST_TO_ADDR
// for i = 1 to group do
74770: LD_ADDR_VAR 0 7
74774: PUSH
74775: DOUBLE
74776: LD_INT 1
74778: DEC
74779: ST_TO_ADDR
74780: LD_VAR 0 4
74784: PUSH
74785: FOR_TO
74786: IFFALSE 74815
// units_path := Replace ( units_path , i , path ) ;
74788: LD_ADDR_VAR 0 16
74792: PUSH
74793: LD_VAR 0 16
74797: PPUSH
74798: LD_VAR 0 7
74802: PPUSH
74803: LD_VAR 0 5
74807: PPUSH
74808: CALL_OW 1
74812: ST_TO_ADDR
74813: GO 74785
74815: POP
74816: POP
// repeat for i = group downto 1 do
74817: LD_ADDR_VAR 0 7
74821: PUSH
74822: DOUBLE
74823: LD_VAR 0 4
74827: INC
74828: ST_TO_ADDR
74829: LD_INT 1
74831: PUSH
74832: FOR_DOWNTO
74833: IFFALSE 78955
// begin wait ( 5 ) ;
74835: LD_INT 5
74837: PPUSH
74838: CALL_OW 67
// tmp := [ ] ;
74842: LD_ADDR_VAR 0 14
74846: PUSH
74847: EMPTY
74848: ST_TO_ADDR
// attacking := false ;
74849: LD_ADDR_VAR 0 29
74853: PUSH
74854: LD_INT 0
74856: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
74857: LD_VAR 0 4
74861: PUSH
74862: LD_VAR 0 7
74866: ARRAY
74867: PPUSH
74868: CALL_OW 301
74872: PUSH
74873: LD_VAR 0 4
74877: PUSH
74878: LD_VAR 0 7
74882: ARRAY
74883: NOT
74884: OR
74885: IFFALSE 74994
// begin if GetType ( group [ i ] ) = unit_human then
74887: LD_VAR 0 4
74891: PUSH
74892: LD_VAR 0 7
74896: ARRAY
74897: PPUSH
74898: CALL_OW 247
74902: PUSH
74903: LD_INT 1
74905: EQUAL
74906: IFFALSE 74952
// begin to_heal := to_heal diff group [ i ] ;
74908: LD_ADDR_VAR 0 30
74912: PUSH
74913: LD_VAR 0 30
74917: PUSH
74918: LD_VAR 0 4
74922: PUSH
74923: LD_VAR 0 7
74927: ARRAY
74928: DIFF
74929: ST_TO_ADDR
// healers := healers diff group [ i ] ;
74930: LD_ADDR_VAR 0 31
74934: PUSH
74935: LD_VAR 0 31
74939: PUSH
74940: LD_VAR 0 4
74944: PUSH
74945: LD_VAR 0 7
74949: ARRAY
74950: DIFF
74951: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
74952: LD_ADDR_VAR 0 4
74956: PUSH
74957: LD_VAR 0 4
74961: PPUSH
74962: LD_VAR 0 7
74966: PPUSH
74967: CALL_OW 3
74971: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
74972: LD_ADDR_VAR 0 16
74976: PUSH
74977: LD_VAR 0 16
74981: PPUSH
74982: LD_VAR 0 7
74986: PPUSH
74987: CALL_OW 3
74991: ST_TO_ADDR
// continue ;
74992: GO 74832
// end ; if f_repair then
74994: LD_VAR 0 22
74998: IFFALSE 75487
// begin if GetType ( group [ i ] ) = unit_vehicle then
75000: LD_VAR 0 4
75004: PUSH
75005: LD_VAR 0 7
75009: ARRAY
75010: PPUSH
75011: CALL_OW 247
75015: PUSH
75016: LD_INT 2
75018: EQUAL
75019: IFFALSE 75209
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
75021: LD_VAR 0 4
75025: PUSH
75026: LD_VAR 0 7
75030: ARRAY
75031: PPUSH
75032: CALL_OW 256
75036: PUSH
75037: LD_INT 700
75039: LESS
75040: PUSH
75041: LD_VAR 0 4
75045: PUSH
75046: LD_VAR 0 7
75050: ARRAY
75051: PUSH
75052: LD_VAR 0 32
75056: IN
75057: NOT
75058: AND
75059: IFFALSE 75083
// to_repair := to_repair union group [ i ] ;
75061: LD_ADDR_VAR 0 32
75065: PUSH
75066: LD_VAR 0 32
75070: PUSH
75071: LD_VAR 0 4
75075: PUSH
75076: LD_VAR 0 7
75080: ARRAY
75081: UNION
75082: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
75083: LD_VAR 0 4
75087: PUSH
75088: LD_VAR 0 7
75092: ARRAY
75093: PPUSH
75094: CALL_OW 256
75098: PUSH
75099: LD_INT 1000
75101: EQUAL
75102: PUSH
75103: LD_VAR 0 4
75107: PUSH
75108: LD_VAR 0 7
75112: ARRAY
75113: PUSH
75114: LD_VAR 0 32
75118: IN
75119: AND
75120: IFFALSE 75144
// to_repair := to_repair diff group [ i ] ;
75122: LD_ADDR_VAR 0 32
75126: PUSH
75127: LD_VAR 0 32
75131: PUSH
75132: LD_VAR 0 4
75136: PUSH
75137: LD_VAR 0 7
75141: ARRAY
75142: DIFF
75143: ST_TO_ADDR
// if group [ i ] in to_repair then
75144: LD_VAR 0 4
75148: PUSH
75149: LD_VAR 0 7
75153: ARRAY
75154: PUSH
75155: LD_VAR 0 32
75159: IN
75160: IFFALSE 75207
// begin if not IsInArea ( group [ i ] , f_repair ) then
75162: LD_VAR 0 4
75166: PUSH
75167: LD_VAR 0 7
75171: ARRAY
75172: PPUSH
75173: LD_VAR 0 22
75177: PPUSH
75178: CALL_OW 308
75182: NOT
75183: IFFALSE 75205
// ComMoveToArea ( group [ i ] , f_repair ) ;
75185: LD_VAR 0 4
75189: PUSH
75190: LD_VAR 0 7
75194: ARRAY
75195: PPUSH
75196: LD_VAR 0 22
75200: PPUSH
75201: CALL_OW 113
// continue ;
75205: GO 74832
// end ; end else
75207: GO 75487
// if group [ i ] in repairs then
75209: LD_VAR 0 4
75213: PUSH
75214: LD_VAR 0 7
75218: ARRAY
75219: PUSH
75220: LD_VAR 0 33
75224: IN
75225: IFFALSE 75487
// begin if IsInUnit ( group [ i ] ) then
75227: LD_VAR 0 4
75231: PUSH
75232: LD_VAR 0 7
75236: ARRAY
75237: PPUSH
75238: CALL_OW 310
75242: IFFALSE 75310
// begin z := IsInUnit ( group [ i ] ) ;
75244: LD_ADDR_VAR 0 13
75248: PUSH
75249: LD_VAR 0 4
75253: PUSH
75254: LD_VAR 0 7
75258: ARRAY
75259: PPUSH
75260: CALL_OW 310
75264: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
75265: LD_VAR 0 13
75269: PUSH
75270: LD_VAR 0 32
75274: IN
75275: PUSH
75276: LD_VAR 0 13
75280: PPUSH
75281: LD_VAR 0 22
75285: PPUSH
75286: CALL_OW 308
75290: AND
75291: IFFALSE 75308
// ComExitVehicle ( group [ i ] ) ;
75293: LD_VAR 0 4
75297: PUSH
75298: LD_VAR 0 7
75302: ARRAY
75303: PPUSH
75304: CALL_OW 121
// end else
75308: GO 75487
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
75310: LD_ADDR_VAR 0 13
75314: PUSH
75315: LD_VAR 0 4
75319: PPUSH
75320: LD_INT 95
75322: PUSH
75323: LD_VAR 0 22
75327: PUSH
75328: EMPTY
75329: LIST
75330: LIST
75331: PUSH
75332: LD_INT 58
75334: PUSH
75335: EMPTY
75336: LIST
75337: PUSH
75338: EMPTY
75339: LIST
75340: LIST
75341: PPUSH
75342: CALL_OW 72
75346: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
75347: LD_VAR 0 4
75351: PUSH
75352: LD_VAR 0 7
75356: ARRAY
75357: PPUSH
75358: CALL_OW 314
75362: NOT
75363: IFFALSE 75485
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
75365: LD_ADDR_VAR 0 10
75369: PUSH
75370: LD_VAR 0 13
75374: PPUSH
75375: LD_VAR 0 4
75379: PUSH
75380: LD_VAR 0 7
75384: ARRAY
75385: PPUSH
75386: CALL_OW 74
75390: ST_TO_ADDR
// if not x then
75391: LD_VAR 0 10
75395: NOT
75396: IFFALSE 75400
// continue ;
75398: GO 74832
// if GetLives ( x ) < 1000 then
75400: LD_VAR 0 10
75404: PPUSH
75405: CALL_OW 256
75409: PUSH
75410: LD_INT 1000
75412: LESS
75413: IFFALSE 75437
// ComRepairVehicle ( group [ i ] , x ) else
75415: LD_VAR 0 4
75419: PUSH
75420: LD_VAR 0 7
75424: ARRAY
75425: PPUSH
75426: LD_VAR 0 10
75430: PPUSH
75431: CALL_OW 129
75435: GO 75485
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
75437: LD_VAR 0 23
75441: PUSH
75442: LD_VAR 0 4
75446: PUSH
75447: LD_VAR 0 7
75451: ARRAY
75452: PPUSH
75453: CALL_OW 256
75457: PUSH
75458: LD_INT 1000
75460: LESS
75461: AND
75462: NOT
75463: IFFALSE 75485
// ComEnterUnit ( group [ i ] , x ) ;
75465: LD_VAR 0 4
75469: PUSH
75470: LD_VAR 0 7
75474: ARRAY
75475: PPUSH
75476: LD_VAR 0 10
75480: PPUSH
75481: CALL_OW 120
// end ; continue ;
75485: GO 74832
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
75487: LD_VAR 0 23
75491: PUSH
75492: LD_VAR 0 4
75496: PUSH
75497: LD_VAR 0 7
75501: ARRAY
75502: PPUSH
75503: CALL_OW 247
75507: PUSH
75508: LD_INT 1
75510: EQUAL
75511: AND
75512: IFFALSE 75990
// begin if group [ i ] in healers then
75514: LD_VAR 0 4
75518: PUSH
75519: LD_VAR 0 7
75523: ARRAY
75524: PUSH
75525: LD_VAR 0 31
75529: IN
75530: IFFALSE 75803
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
75532: LD_VAR 0 4
75536: PUSH
75537: LD_VAR 0 7
75541: ARRAY
75542: PPUSH
75543: LD_VAR 0 23
75547: PPUSH
75548: CALL_OW 308
75552: NOT
75553: PUSH
75554: LD_VAR 0 4
75558: PUSH
75559: LD_VAR 0 7
75563: ARRAY
75564: PPUSH
75565: CALL_OW 314
75569: NOT
75570: AND
75571: IFFALSE 75595
// ComMoveToArea ( group [ i ] , f_heal ) else
75573: LD_VAR 0 4
75577: PUSH
75578: LD_VAR 0 7
75582: ARRAY
75583: PPUSH
75584: LD_VAR 0 23
75588: PPUSH
75589: CALL_OW 113
75593: GO 75801
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
75595: LD_VAR 0 4
75599: PUSH
75600: LD_VAR 0 7
75604: ARRAY
75605: PPUSH
75606: CALL 52801 0 1
75610: PPUSH
75611: CALL_OW 256
75615: PUSH
75616: LD_INT 1000
75618: EQUAL
75619: IFFALSE 75638
// ComStop ( group [ i ] ) else
75621: LD_VAR 0 4
75625: PUSH
75626: LD_VAR 0 7
75630: ARRAY
75631: PPUSH
75632: CALL_OW 141
75636: GO 75801
// if not HasTask ( group [ i ] ) and to_heal then
75638: LD_VAR 0 4
75642: PUSH
75643: LD_VAR 0 7
75647: ARRAY
75648: PPUSH
75649: CALL_OW 314
75653: NOT
75654: PUSH
75655: LD_VAR 0 30
75659: AND
75660: IFFALSE 75801
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
75662: LD_ADDR_VAR 0 13
75666: PUSH
75667: LD_VAR 0 30
75671: PPUSH
75672: LD_INT 3
75674: PUSH
75675: LD_INT 54
75677: PUSH
75678: EMPTY
75679: LIST
75680: PUSH
75681: EMPTY
75682: LIST
75683: LIST
75684: PPUSH
75685: CALL_OW 72
75689: PPUSH
75690: LD_VAR 0 4
75694: PUSH
75695: LD_VAR 0 7
75699: ARRAY
75700: PPUSH
75701: CALL_OW 74
75705: ST_TO_ADDR
// if z then
75706: LD_VAR 0 13
75710: IFFALSE 75801
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
75712: LD_INT 91
75714: PUSH
75715: LD_VAR 0 13
75719: PUSH
75720: LD_INT 10
75722: PUSH
75723: EMPTY
75724: LIST
75725: LIST
75726: LIST
75727: PUSH
75728: LD_INT 81
75730: PUSH
75731: LD_VAR 0 13
75735: PPUSH
75736: CALL_OW 255
75740: PUSH
75741: EMPTY
75742: LIST
75743: LIST
75744: PUSH
75745: EMPTY
75746: LIST
75747: LIST
75748: PPUSH
75749: CALL_OW 69
75753: PUSH
75754: LD_INT 0
75756: EQUAL
75757: IFFALSE 75781
// ComHeal ( group [ i ] , z ) else
75759: LD_VAR 0 4
75763: PUSH
75764: LD_VAR 0 7
75768: ARRAY
75769: PPUSH
75770: LD_VAR 0 13
75774: PPUSH
75775: CALL_OW 128
75779: GO 75801
// ComMoveToArea ( group [ i ] , f_heal ) ;
75781: LD_VAR 0 4
75785: PUSH
75786: LD_VAR 0 7
75790: ARRAY
75791: PPUSH
75792: LD_VAR 0 23
75796: PPUSH
75797: CALL_OW 113
// end ; continue ;
75801: GO 74832
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
75803: LD_VAR 0 4
75807: PUSH
75808: LD_VAR 0 7
75812: ARRAY
75813: PPUSH
75814: CALL_OW 256
75818: PUSH
75819: LD_INT 700
75821: LESS
75822: PUSH
75823: LD_VAR 0 4
75827: PUSH
75828: LD_VAR 0 7
75832: ARRAY
75833: PUSH
75834: LD_VAR 0 30
75838: IN
75839: NOT
75840: AND
75841: IFFALSE 75865
// to_heal := to_heal union group [ i ] ;
75843: LD_ADDR_VAR 0 30
75847: PUSH
75848: LD_VAR 0 30
75852: PUSH
75853: LD_VAR 0 4
75857: PUSH
75858: LD_VAR 0 7
75862: ARRAY
75863: UNION
75864: ST_TO_ADDR
// if group [ i ] in to_heal then
75865: LD_VAR 0 4
75869: PUSH
75870: LD_VAR 0 7
75874: ARRAY
75875: PUSH
75876: LD_VAR 0 30
75880: IN
75881: IFFALSE 75990
// begin if GetLives ( group [ i ] ) = 1000 then
75883: LD_VAR 0 4
75887: PUSH
75888: LD_VAR 0 7
75892: ARRAY
75893: PPUSH
75894: CALL_OW 256
75898: PUSH
75899: LD_INT 1000
75901: EQUAL
75902: IFFALSE 75928
// to_heal := to_heal diff group [ i ] else
75904: LD_ADDR_VAR 0 30
75908: PUSH
75909: LD_VAR 0 30
75913: PUSH
75914: LD_VAR 0 4
75918: PUSH
75919: LD_VAR 0 7
75923: ARRAY
75924: DIFF
75925: ST_TO_ADDR
75926: GO 75990
// begin if not IsInArea ( group [ i ] , to_heal ) then
75928: LD_VAR 0 4
75932: PUSH
75933: LD_VAR 0 7
75937: ARRAY
75938: PPUSH
75939: LD_VAR 0 30
75943: PPUSH
75944: CALL_OW 308
75948: NOT
75949: IFFALSE 75973
// ComMoveToArea ( group [ i ] , f_heal ) else
75951: LD_VAR 0 4
75955: PUSH
75956: LD_VAR 0 7
75960: ARRAY
75961: PPUSH
75962: LD_VAR 0 23
75966: PPUSH
75967: CALL_OW 113
75971: GO 75988
// ComHold ( group [ i ] ) ;
75973: LD_VAR 0 4
75977: PUSH
75978: LD_VAR 0 7
75982: ARRAY
75983: PPUSH
75984: CALL_OW 140
// continue ;
75988: GO 74832
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
75990: LD_VAR 0 4
75994: PUSH
75995: LD_VAR 0 7
75999: ARRAY
76000: PPUSH
76001: LD_INT 10
76003: PPUSH
76004: CALL 51221 0 2
76008: NOT
76009: PUSH
76010: LD_VAR 0 16
76014: PUSH
76015: LD_VAR 0 7
76019: ARRAY
76020: PUSH
76021: EMPTY
76022: EQUAL
76023: NOT
76024: AND
76025: IFFALSE 76291
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
76027: LD_VAR 0 4
76031: PUSH
76032: LD_VAR 0 7
76036: ARRAY
76037: PPUSH
76038: CALL_OW 262
76042: PUSH
76043: LD_INT 1
76045: PUSH
76046: LD_INT 2
76048: PUSH
76049: EMPTY
76050: LIST
76051: LIST
76052: IN
76053: IFFALSE 76094
// if GetFuel ( group [ i ] ) < 10 then
76055: LD_VAR 0 4
76059: PUSH
76060: LD_VAR 0 7
76064: ARRAY
76065: PPUSH
76066: CALL_OW 261
76070: PUSH
76071: LD_INT 10
76073: LESS
76074: IFFALSE 76094
// SetFuel ( group [ i ] , 12 ) ;
76076: LD_VAR 0 4
76080: PUSH
76081: LD_VAR 0 7
76085: ARRAY
76086: PPUSH
76087: LD_INT 12
76089: PPUSH
76090: CALL_OW 240
// if units_path [ i ] then
76094: LD_VAR 0 16
76098: PUSH
76099: LD_VAR 0 7
76103: ARRAY
76104: IFFALSE 76289
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
76106: LD_VAR 0 4
76110: PUSH
76111: LD_VAR 0 7
76115: ARRAY
76116: PPUSH
76117: LD_VAR 0 16
76121: PUSH
76122: LD_VAR 0 7
76126: ARRAY
76127: PUSH
76128: LD_INT 1
76130: ARRAY
76131: PUSH
76132: LD_INT 1
76134: ARRAY
76135: PPUSH
76136: LD_VAR 0 16
76140: PUSH
76141: LD_VAR 0 7
76145: ARRAY
76146: PUSH
76147: LD_INT 1
76149: ARRAY
76150: PUSH
76151: LD_INT 2
76153: ARRAY
76154: PPUSH
76155: CALL_OW 297
76159: PUSH
76160: LD_INT 6
76162: GREATER
76163: IFFALSE 76238
// begin if not HasTask ( group [ i ] ) then
76165: LD_VAR 0 4
76169: PUSH
76170: LD_VAR 0 7
76174: ARRAY
76175: PPUSH
76176: CALL_OW 314
76180: NOT
76181: IFFALSE 76236
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
76183: LD_VAR 0 4
76187: PUSH
76188: LD_VAR 0 7
76192: ARRAY
76193: PPUSH
76194: LD_VAR 0 16
76198: PUSH
76199: LD_VAR 0 7
76203: ARRAY
76204: PUSH
76205: LD_INT 1
76207: ARRAY
76208: PUSH
76209: LD_INT 1
76211: ARRAY
76212: PPUSH
76213: LD_VAR 0 16
76217: PUSH
76218: LD_VAR 0 7
76222: ARRAY
76223: PUSH
76224: LD_INT 1
76226: ARRAY
76227: PUSH
76228: LD_INT 2
76230: ARRAY
76231: PPUSH
76232: CALL_OW 114
// end else
76236: GO 76289
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
76238: LD_ADDR_VAR 0 15
76242: PUSH
76243: LD_VAR 0 16
76247: PUSH
76248: LD_VAR 0 7
76252: ARRAY
76253: PPUSH
76254: LD_INT 1
76256: PPUSH
76257: CALL_OW 3
76261: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
76262: LD_ADDR_VAR 0 16
76266: PUSH
76267: LD_VAR 0 16
76271: PPUSH
76272: LD_VAR 0 7
76276: PPUSH
76277: LD_VAR 0 15
76281: PPUSH
76282: CALL_OW 1
76286: ST_TO_ADDR
// continue ;
76287: GO 74832
// end ; end ; end else
76289: GO 78953
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
76291: LD_ADDR_VAR 0 14
76295: PUSH
76296: LD_INT 81
76298: PUSH
76299: LD_VAR 0 4
76303: PUSH
76304: LD_VAR 0 7
76308: ARRAY
76309: PPUSH
76310: CALL_OW 255
76314: PUSH
76315: EMPTY
76316: LIST
76317: LIST
76318: PPUSH
76319: CALL_OW 69
76323: ST_TO_ADDR
// if not tmp then
76324: LD_VAR 0 14
76328: NOT
76329: IFFALSE 76333
// continue ;
76331: GO 74832
// if f_ignore_area then
76333: LD_VAR 0 17
76337: IFFALSE 76425
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
76339: LD_ADDR_VAR 0 15
76343: PUSH
76344: LD_VAR 0 14
76348: PPUSH
76349: LD_INT 3
76351: PUSH
76352: LD_INT 92
76354: PUSH
76355: LD_VAR 0 17
76359: PUSH
76360: LD_INT 1
76362: ARRAY
76363: PUSH
76364: LD_VAR 0 17
76368: PUSH
76369: LD_INT 2
76371: ARRAY
76372: PUSH
76373: LD_VAR 0 17
76377: PUSH
76378: LD_INT 3
76380: ARRAY
76381: PUSH
76382: EMPTY
76383: LIST
76384: LIST
76385: LIST
76386: LIST
76387: PUSH
76388: EMPTY
76389: LIST
76390: LIST
76391: PPUSH
76392: CALL_OW 72
76396: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
76397: LD_VAR 0 14
76401: PUSH
76402: LD_VAR 0 15
76406: DIFF
76407: IFFALSE 76425
// tmp := tmp diff tmp2 ;
76409: LD_ADDR_VAR 0 14
76413: PUSH
76414: LD_VAR 0 14
76418: PUSH
76419: LD_VAR 0 15
76423: DIFF
76424: ST_TO_ADDR
// end ; if not f_murder then
76425: LD_VAR 0 20
76429: NOT
76430: IFFALSE 76488
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
76432: LD_ADDR_VAR 0 15
76436: PUSH
76437: LD_VAR 0 14
76441: PPUSH
76442: LD_INT 3
76444: PUSH
76445: LD_INT 50
76447: PUSH
76448: EMPTY
76449: LIST
76450: PUSH
76451: EMPTY
76452: LIST
76453: LIST
76454: PPUSH
76455: CALL_OW 72
76459: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
76460: LD_VAR 0 14
76464: PUSH
76465: LD_VAR 0 15
76469: DIFF
76470: IFFALSE 76488
// tmp := tmp diff tmp2 ;
76472: LD_ADDR_VAR 0 14
76476: PUSH
76477: LD_VAR 0 14
76481: PUSH
76482: LD_VAR 0 15
76486: DIFF
76487: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
76488: LD_ADDR_VAR 0 14
76492: PUSH
76493: LD_VAR 0 4
76497: PUSH
76498: LD_VAR 0 7
76502: ARRAY
76503: PPUSH
76504: LD_VAR 0 14
76508: PPUSH
76509: LD_INT 1
76511: PPUSH
76512: LD_INT 1
76514: PPUSH
76515: CALL 24531 0 4
76519: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
76520: LD_VAR 0 4
76524: PUSH
76525: LD_VAR 0 7
76529: ARRAY
76530: PPUSH
76531: CALL_OW 257
76535: PUSH
76536: LD_INT 1
76538: EQUAL
76539: IFFALSE 76987
// begin if WantPlant ( group [ i ] ) then
76541: LD_VAR 0 4
76545: PUSH
76546: LD_VAR 0 7
76550: ARRAY
76551: PPUSH
76552: CALL 24032 0 1
76556: IFFALSE 76560
// continue ;
76558: GO 74832
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
76560: LD_VAR 0 18
76564: PUSH
76565: LD_VAR 0 4
76569: PUSH
76570: LD_VAR 0 7
76574: ARRAY
76575: PPUSH
76576: CALL_OW 310
76580: NOT
76581: AND
76582: PUSH
76583: LD_VAR 0 14
76587: PUSH
76588: LD_INT 1
76590: ARRAY
76591: PUSH
76592: LD_VAR 0 14
76596: PPUSH
76597: LD_INT 21
76599: PUSH
76600: LD_INT 2
76602: PUSH
76603: EMPTY
76604: LIST
76605: LIST
76606: PUSH
76607: LD_INT 58
76609: PUSH
76610: EMPTY
76611: LIST
76612: PUSH
76613: EMPTY
76614: LIST
76615: LIST
76616: PPUSH
76617: CALL_OW 72
76621: IN
76622: AND
76623: IFFALSE 76659
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
76625: LD_VAR 0 4
76629: PUSH
76630: LD_VAR 0 7
76634: ARRAY
76635: PPUSH
76636: LD_VAR 0 14
76640: PUSH
76641: LD_INT 1
76643: ARRAY
76644: PPUSH
76645: CALL_OW 120
// attacking := true ;
76649: LD_ADDR_VAR 0 29
76653: PUSH
76654: LD_INT 1
76656: ST_TO_ADDR
// continue ;
76657: GO 74832
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
76659: LD_VAR 0 26
76663: PUSH
76664: LD_VAR 0 4
76668: PUSH
76669: LD_VAR 0 7
76673: ARRAY
76674: PPUSH
76675: CALL_OW 257
76679: PUSH
76680: LD_INT 1
76682: EQUAL
76683: AND
76684: PUSH
76685: LD_VAR 0 4
76689: PUSH
76690: LD_VAR 0 7
76694: ARRAY
76695: PPUSH
76696: CALL_OW 256
76700: PUSH
76701: LD_INT 800
76703: LESS
76704: AND
76705: PUSH
76706: LD_VAR 0 4
76710: PUSH
76711: LD_VAR 0 7
76715: ARRAY
76716: PPUSH
76717: CALL_OW 318
76721: NOT
76722: AND
76723: IFFALSE 76740
// ComCrawl ( group [ i ] ) ;
76725: LD_VAR 0 4
76729: PUSH
76730: LD_VAR 0 7
76734: ARRAY
76735: PPUSH
76736: CALL_OW 137
// if f_mines then
76740: LD_VAR 0 21
76744: IFFALSE 76987
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
76746: LD_VAR 0 14
76750: PUSH
76751: LD_INT 1
76753: ARRAY
76754: PPUSH
76755: CALL_OW 247
76759: PUSH
76760: LD_INT 3
76762: EQUAL
76763: PUSH
76764: LD_VAR 0 14
76768: PUSH
76769: LD_INT 1
76771: ARRAY
76772: PUSH
76773: LD_VAR 0 27
76777: IN
76778: NOT
76779: AND
76780: IFFALSE 76987
// begin x := GetX ( tmp [ 1 ] ) ;
76782: LD_ADDR_VAR 0 10
76786: PUSH
76787: LD_VAR 0 14
76791: PUSH
76792: LD_INT 1
76794: ARRAY
76795: PPUSH
76796: CALL_OW 250
76800: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
76801: LD_ADDR_VAR 0 11
76805: PUSH
76806: LD_VAR 0 14
76810: PUSH
76811: LD_INT 1
76813: ARRAY
76814: PPUSH
76815: CALL_OW 251
76819: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
76820: LD_ADDR_VAR 0 12
76824: PUSH
76825: LD_VAR 0 4
76829: PUSH
76830: LD_VAR 0 7
76834: ARRAY
76835: PPUSH
76836: CALL 51306 0 1
76840: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
76841: LD_VAR 0 4
76845: PUSH
76846: LD_VAR 0 7
76850: ARRAY
76851: PPUSH
76852: LD_VAR 0 10
76856: PPUSH
76857: LD_VAR 0 11
76861: PPUSH
76862: LD_VAR 0 14
76866: PUSH
76867: LD_INT 1
76869: ARRAY
76870: PPUSH
76871: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
76875: LD_VAR 0 4
76879: PUSH
76880: LD_VAR 0 7
76884: ARRAY
76885: PPUSH
76886: LD_VAR 0 10
76890: PPUSH
76891: LD_VAR 0 12
76895: PPUSH
76896: LD_INT 7
76898: PPUSH
76899: CALL_OW 272
76903: PPUSH
76904: LD_VAR 0 11
76908: PPUSH
76909: LD_VAR 0 12
76913: PPUSH
76914: LD_INT 7
76916: PPUSH
76917: CALL_OW 273
76921: PPUSH
76922: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
76926: LD_VAR 0 4
76930: PUSH
76931: LD_VAR 0 7
76935: ARRAY
76936: PPUSH
76937: LD_INT 71
76939: PPUSH
76940: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
76944: LD_ADDR_VAR 0 27
76948: PUSH
76949: LD_VAR 0 27
76953: PPUSH
76954: LD_VAR 0 27
76958: PUSH
76959: LD_INT 1
76961: PLUS
76962: PPUSH
76963: LD_VAR 0 14
76967: PUSH
76968: LD_INT 1
76970: ARRAY
76971: PPUSH
76972: CALL_OW 1
76976: ST_TO_ADDR
// attacking := true ;
76977: LD_ADDR_VAR 0 29
76981: PUSH
76982: LD_INT 1
76984: ST_TO_ADDR
// continue ;
76985: GO 74832
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
76987: LD_VAR 0 4
76991: PUSH
76992: LD_VAR 0 7
76996: ARRAY
76997: PPUSH
76998: CALL_OW 257
77002: PUSH
77003: LD_INT 17
77005: EQUAL
77006: PUSH
77007: LD_VAR 0 4
77011: PUSH
77012: LD_VAR 0 7
77016: ARRAY
77017: PPUSH
77018: CALL_OW 110
77022: PUSH
77023: LD_INT 71
77025: EQUAL
77026: NOT
77027: AND
77028: IFFALSE 77174
// begin attacking := false ;
77030: LD_ADDR_VAR 0 29
77034: PUSH
77035: LD_INT 0
77037: ST_TO_ADDR
// k := 5 ;
77038: LD_ADDR_VAR 0 9
77042: PUSH
77043: LD_INT 5
77045: ST_TO_ADDR
// if tmp < k then
77046: LD_VAR 0 14
77050: PUSH
77051: LD_VAR 0 9
77055: LESS
77056: IFFALSE 77068
// k := tmp ;
77058: LD_ADDR_VAR 0 9
77062: PUSH
77063: LD_VAR 0 14
77067: ST_TO_ADDR
// for j = 1 to k do
77068: LD_ADDR_VAR 0 8
77072: PUSH
77073: DOUBLE
77074: LD_INT 1
77076: DEC
77077: ST_TO_ADDR
77078: LD_VAR 0 9
77082: PUSH
77083: FOR_TO
77084: IFFALSE 77172
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
77086: LD_VAR 0 14
77090: PUSH
77091: LD_VAR 0 8
77095: ARRAY
77096: PUSH
77097: LD_VAR 0 14
77101: PPUSH
77102: LD_INT 58
77104: PUSH
77105: EMPTY
77106: LIST
77107: PPUSH
77108: CALL_OW 72
77112: IN
77113: NOT
77114: IFFALSE 77170
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
77116: LD_VAR 0 4
77120: PUSH
77121: LD_VAR 0 7
77125: ARRAY
77126: PPUSH
77127: LD_VAR 0 14
77131: PUSH
77132: LD_VAR 0 8
77136: ARRAY
77137: PPUSH
77138: CALL_OW 115
// attacking := true ;
77142: LD_ADDR_VAR 0 29
77146: PUSH
77147: LD_INT 1
77149: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
77150: LD_VAR 0 4
77154: PUSH
77155: LD_VAR 0 7
77159: ARRAY
77160: PPUSH
77161: LD_INT 71
77163: PPUSH
77164: CALL_OW 109
// continue ;
77168: GO 77083
// end ; end ;
77170: GO 77083
77172: POP
77173: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
77174: LD_VAR 0 4
77178: PUSH
77179: LD_VAR 0 7
77183: ARRAY
77184: PPUSH
77185: CALL_OW 257
77189: PUSH
77190: LD_INT 8
77192: EQUAL
77193: PUSH
77194: LD_VAR 0 4
77198: PUSH
77199: LD_VAR 0 7
77203: ARRAY
77204: PPUSH
77205: CALL_OW 264
77209: PUSH
77210: LD_INT 28
77212: PUSH
77213: LD_INT 45
77215: PUSH
77216: LD_INT 7
77218: PUSH
77219: LD_INT 47
77221: PUSH
77222: EMPTY
77223: LIST
77224: LIST
77225: LIST
77226: LIST
77227: IN
77228: OR
77229: IFFALSE 77485
// begin attacking := false ;
77231: LD_ADDR_VAR 0 29
77235: PUSH
77236: LD_INT 0
77238: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
77239: LD_VAR 0 14
77243: PUSH
77244: LD_INT 1
77246: ARRAY
77247: PPUSH
77248: CALL_OW 266
77252: PUSH
77253: LD_INT 32
77255: PUSH
77256: LD_INT 31
77258: PUSH
77259: LD_INT 33
77261: PUSH
77262: LD_INT 4
77264: PUSH
77265: LD_INT 5
77267: PUSH
77268: EMPTY
77269: LIST
77270: LIST
77271: LIST
77272: LIST
77273: LIST
77274: IN
77275: IFFALSE 77461
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
77277: LD_ADDR_VAR 0 9
77281: PUSH
77282: LD_VAR 0 14
77286: PUSH
77287: LD_INT 1
77289: ARRAY
77290: PPUSH
77291: CALL_OW 266
77295: PPUSH
77296: LD_VAR 0 14
77300: PUSH
77301: LD_INT 1
77303: ARRAY
77304: PPUSH
77305: CALL_OW 250
77309: PPUSH
77310: LD_VAR 0 14
77314: PUSH
77315: LD_INT 1
77317: ARRAY
77318: PPUSH
77319: CALL_OW 251
77323: PPUSH
77324: LD_VAR 0 14
77328: PUSH
77329: LD_INT 1
77331: ARRAY
77332: PPUSH
77333: CALL_OW 254
77337: PPUSH
77338: LD_VAR 0 14
77342: PUSH
77343: LD_INT 1
77345: ARRAY
77346: PPUSH
77347: CALL_OW 248
77351: PPUSH
77352: LD_INT 0
77354: PPUSH
77355: CALL 32676 0 6
77359: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
77360: LD_ADDR_VAR 0 8
77364: PUSH
77365: LD_VAR 0 4
77369: PUSH
77370: LD_VAR 0 7
77374: ARRAY
77375: PPUSH
77376: LD_VAR 0 9
77380: PPUSH
77381: CALL 51346 0 2
77385: ST_TO_ADDR
// if j then
77386: LD_VAR 0 8
77390: IFFALSE 77459
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
77392: LD_VAR 0 8
77396: PUSH
77397: LD_INT 1
77399: ARRAY
77400: PPUSH
77401: LD_VAR 0 8
77405: PUSH
77406: LD_INT 2
77408: ARRAY
77409: PPUSH
77410: CALL_OW 488
77414: IFFALSE 77459
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
77416: LD_VAR 0 4
77420: PUSH
77421: LD_VAR 0 7
77425: ARRAY
77426: PPUSH
77427: LD_VAR 0 8
77431: PUSH
77432: LD_INT 1
77434: ARRAY
77435: PPUSH
77436: LD_VAR 0 8
77440: PUSH
77441: LD_INT 2
77443: ARRAY
77444: PPUSH
77445: CALL_OW 116
// attacking := true ;
77449: LD_ADDR_VAR 0 29
77453: PUSH
77454: LD_INT 1
77456: ST_TO_ADDR
// continue ;
77457: GO 74832
// end ; end else
77459: GO 77485
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
77461: LD_VAR 0 4
77465: PUSH
77466: LD_VAR 0 7
77470: ARRAY
77471: PPUSH
77472: LD_VAR 0 14
77476: PUSH
77477: LD_INT 1
77479: ARRAY
77480: PPUSH
77481: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
77485: LD_VAR 0 4
77489: PUSH
77490: LD_VAR 0 7
77494: ARRAY
77495: PPUSH
77496: CALL_OW 265
77500: PUSH
77501: LD_INT 11
77503: EQUAL
77504: IFFALSE 77782
// begin k := 10 ;
77506: LD_ADDR_VAR 0 9
77510: PUSH
77511: LD_INT 10
77513: ST_TO_ADDR
// x := 0 ;
77514: LD_ADDR_VAR 0 10
77518: PUSH
77519: LD_INT 0
77521: ST_TO_ADDR
// if tmp < k then
77522: LD_VAR 0 14
77526: PUSH
77527: LD_VAR 0 9
77531: LESS
77532: IFFALSE 77544
// k := tmp ;
77534: LD_ADDR_VAR 0 9
77538: PUSH
77539: LD_VAR 0 14
77543: ST_TO_ADDR
// for j = k downto 1 do
77544: LD_ADDR_VAR 0 8
77548: PUSH
77549: DOUBLE
77550: LD_VAR 0 9
77554: INC
77555: ST_TO_ADDR
77556: LD_INT 1
77558: PUSH
77559: FOR_DOWNTO
77560: IFFALSE 77635
// begin if GetType ( tmp [ j ] ) = unit_human then
77562: LD_VAR 0 14
77566: PUSH
77567: LD_VAR 0 8
77571: ARRAY
77572: PPUSH
77573: CALL_OW 247
77577: PUSH
77578: LD_INT 1
77580: EQUAL
77581: IFFALSE 77633
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
77583: LD_VAR 0 4
77587: PUSH
77588: LD_VAR 0 7
77592: ARRAY
77593: PPUSH
77594: LD_VAR 0 14
77598: PUSH
77599: LD_VAR 0 8
77603: ARRAY
77604: PPUSH
77605: CALL 51617 0 2
// x := tmp [ j ] ;
77609: LD_ADDR_VAR 0 10
77613: PUSH
77614: LD_VAR 0 14
77618: PUSH
77619: LD_VAR 0 8
77623: ARRAY
77624: ST_TO_ADDR
// attacking := true ;
77625: LD_ADDR_VAR 0 29
77629: PUSH
77630: LD_INT 1
77632: ST_TO_ADDR
// end ; end ;
77633: GO 77559
77635: POP
77636: POP
// if not x then
77637: LD_VAR 0 10
77641: NOT
77642: IFFALSE 77782
// begin attacking := true ;
77644: LD_ADDR_VAR 0 29
77648: PUSH
77649: LD_INT 1
77651: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
77652: LD_VAR 0 4
77656: PUSH
77657: LD_VAR 0 7
77661: ARRAY
77662: PPUSH
77663: CALL_OW 250
77667: PPUSH
77668: LD_VAR 0 4
77672: PUSH
77673: LD_VAR 0 7
77677: ARRAY
77678: PPUSH
77679: CALL_OW 251
77683: PPUSH
77684: CALL_OW 546
77688: PUSH
77689: LD_INT 2
77691: ARRAY
77692: PUSH
77693: LD_VAR 0 14
77697: PUSH
77698: LD_INT 1
77700: ARRAY
77701: PPUSH
77702: CALL_OW 250
77706: PPUSH
77707: LD_VAR 0 14
77711: PUSH
77712: LD_INT 1
77714: ARRAY
77715: PPUSH
77716: CALL_OW 251
77720: PPUSH
77721: CALL_OW 546
77725: PUSH
77726: LD_INT 2
77728: ARRAY
77729: EQUAL
77730: IFFALSE 77758
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
77732: LD_VAR 0 4
77736: PUSH
77737: LD_VAR 0 7
77741: ARRAY
77742: PPUSH
77743: LD_VAR 0 14
77747: PUSH
77748: LD_INT 1
77750: ARRAY
77751: PPUSH
77752: CALL 51617 0 2
77756: GO 77782
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
77758: LD_VAR 0 4
77762: PUSH
77763: LD_VAR 0 7
77767: ARRAY
77768: PPUSH
77769: LD_VAR 0 14
77773: PUSH
77774: LD_INT 1
77776: ARRAY
77777: PPUSH
77778: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
77782: LD_VAR 0 4
77786: PUSH
77787: LD_VAR 0 7
77791: ARRAY
77792: PPUSH
77793: CALL_OW 264
77797: PUSH
77798: LD_INT 29
77800: EQUAL
77801: IFFALSE 78167
// begin if WantsToAttack ( group [ i ] ) in bombed then
77803: LD_VAR 0 4
77807: PUSH
77808: LD_VAR 0 7
77812: ARRAY
77813: PPUSH
77814: CALL_OW 319
77818: PUSH
77819: LD_VAR 0 28
77823: IN
77824: IFFALSE 77828
// continue ;
77826: GO 74832
// k := 8 ;
77828: LD_ADDR_VAR 0 9
77832: PUSH
77833: LD_INT 8
77835: ST_TO_ADDR
// x := 0 ;
77836: LD_ADDR_VAR 0 10
77840: PUSH
77841: LD_INT 0
77843: ST_TO_ADDR
// if tmp < k then
77844: LD_VAR 0 14
77848: PUSH
77849: LD_VAR 0 9
77853: LESS
77854: IFFALSE 77866
// k := tmp ;
77856: LD_ADDR_VAR 0 9
77860: PUSH
77861: LD_VAR 0 14
77865: ST_TO_ADDR
// for j = 1 to k do
77866: LD_ADDR_VAR 0 8
77870: PUSH
77871: DOUBLE
77872: LD_INT 1
77874: DEC
77875: ST_TO_ADDR
77876: LD_VAR 0 9
77880: PUSH
77881: FOR_TO
77882: IFFALSE 78014
// begin if GetType ( tmp [ j ] ) = unit_building then
77884: LD_VAR 0 14
77888: PUSH
77889: LD_VAR 0 8
77893: ARRAY
77894: PPUSH
77895: CALL_OW 247
77899: PUSH
77900: LD_INT 3
77902: EQUAL
77903: IFFALSE 78012
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
77905: LD_VAR 0 14
77909: PUSH
77910: LD_VAR 0 8
77914: ARRAY
77915: PUSH
77916: LD_VAR 0 28
77920: IN
77921: NOT
77922: PUSH
77923: LD_VAR 0 14
77927: PUSH
77928: LD_VAR 0 8
77932: ARRAY
77933: PPUSH
77934: CALL_OW 313
77938: AND
77939: IFFALSE 78012
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
77941: LD_VAR 0 4
77945: PUSH
77946: LD_VAR 0 7
77950: ARRAY
77951: PPUSH
77952: LD_VAR 0 14
77956: PUSH
77957: LD_VAR 0 8
77961: ARRAY
77962: PPUSH
77963: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
77967: LD_ADDR_VAR 0 28
77971: PUSH
77972: LD_VAR 0 28
77976: PPUSH
77977: LD_VAR 0 28
77981: PUSH
77982: LD_INT 1
77984: PLUS
77985: PPUSH
77986: LD_VAR 0 14
77990: PUSH
77991: LD_VAR 0 8
77995: ARRAY
77996: PPUSH
77997: CALL_OW 1
78001: ST_TO_ADDR
// attacking := true ;
78002: LD_ADDR_VAR 0 29
78006: PUSH
78007: LD_INT 1
78009: ST_TO_ADDR
// break ;
78010: GO 78014
// end ; end ;
78012: GO 77881
78014: POP
78015: POP
// if not attacking and f_attack_depot then
78016: LD_VAR 0 29
78020: NOT
78021: PUSH
78022: LD_VAR 0 25
78026: AND
78027: IFFALSE 78122
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
78029: LD_ADDR_VAR 0 13
78033: PUSH
78034: LD_VAR 0 14
78038: PPUSH
78039: LD_INT 2
78041: PUSH
78042: LD_INT 30
78044: PUSH
78045: LD_INT 0
78047: PUSH
78048: EMPTY
78049: LIST
78050: LIST
78051: PUSH
78052: LD_INT 30
78054: PUSH
78055: LD_INT 1
78057: PUSH
78058: EMPTY
78059: LIST
78060: LIST
78061: PUSH
78062: EMPTY
78063: LIST
78064: LIST
78065: LIST
78066: PPUSH
78067: CALL_OW 72
78071: ST_TO_ADDR
// if z then
78072: LD_VAR 0 13
78076: IFFALSE 78122
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
78078: LD_VAR 0 4
78082: PUSH
78083: LD_VAR 0 7
78087: ARRAY
78088: PPUSH
78089: LD_VAR 0 13
78093: PPUSH
78094: LD_VAR 0 4
78098: PUSH
78099: LD_VAR 0 7
78103: ARRAY
78104: PPUSH
78105: CALL_OW 74
78109: PPUSH
78110: CALL_OW 115
// attacking := true ;
78114: LD_ADDR_VAR 0 29
78118: PUSH
78119: LD_INT 1
78121: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
78122: LD_VAR 0 4
78126: PUSH
78127: LD_VAR 0 7
78131: ARRAY
78132: PPUSH
78133: CALL_OW 256
78137: PUSH
78138: LD_INT 500
78140: LESS
78141: IFFALSE 78167
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
78143: LD_VAR 0 4
78147: PUSH
78148: LD_VAR 0 7
78152: ARRAY
78153: PPUSH
78154: LD_VAR 0 14
78158: PUSH
78159: LD_INT 1
78161: ARRAY
78162: PPUSH
78163: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
78167: LD_VAR 0 4
78171: PUSH
78172: LD_VAR 0 7
78176: ARRAY
78177: PPUSH
78178: CALL_OW 264
78182: PUSH
78183: LD_INT 49
78185: EQUAL
78186: IFFALSE 78307
// begin if not HasTask ( group [ i ] ) then
78188: LD_VAR 0 4
78192: PUSH
78193: LD_VAR 0 7
78197: ARRAY
78198: PPUSH
78199: CALL_OW 314
78203: NOT
78204: IFFALSE 78307
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
78206: LD_ADDR_VAR 0 9
78210: PUSH
78211: LD_INT 81
78213: PUSH
78214: LD_VAR 0 4
78218: PUSH
78219: LD_VAR 0 7
78223: ARRAY
78224: PPUSH
78225: CALL_OW 255
78229: PUSH
78230: EMPTY
78231: LIST
78232: LIST
78233: PPUSH
78234: CALL_OW 69
78238: PPUSH
78239: LD_VAR 0 4
78243: PUSH
78244: LD_VAR 0 7
78248: ARRAY
78249: PPUSH
78250: CALL_OW 74
78254: ST_TO_ADDR
// if k then
78255: LD_VAR 0 9
78259: IFFALSE 78307
// if GetDistUnits ( group [ i ] , k ) > 10 then
78261: LD_VAR 0 4
78265: PUSH
78266: LD_VAR 0 7
78270: ARRAY
78271: PPUSH
78272: LD_VAR 0 9
78276: PPUSH
78277: CALL_OW 296
78281: PUSH
78282: LD_INT 10
78284: GREATER
78285: IFFALSE 78307
// ComMoveUnit ( group [ i ] , k ) ;
78287: LD_VAR 0 4
78291: PUSH
78292: LD_VAR 0 7
78296: ARRAY
78297: PPUSH
78298: LD_VAR 0 9
78302: PPUSH
78303: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
78307: LD_VAR 0 4
78311: PUSH
78312: LD_VAR 0 7
78316: ARRAY
78317: PPUSH
78318: CALL_OW 256
78322: PUSH
78323: LD_INT 250
78325: LESS
78326: PUSH
78327: LD_VAR 0 4
78331: PUSH
78332: LD_VAR 0 7
78336: ARRAY
78337: PUSH
78338: LD_INT 21
78340: PUSH
78341: LD_INT 2
78343: PUSH
78344: EMPTY
78345: LIST
78346: LIST
78347: PUSH
78348: LD_INT 23
78350: PUSH
78351: LD_INT 2
78353: PUSH
78354: EMPTY
78355: LIST
78356: LIST
78357: PUSH
78358: EMPTY
78359: LIST
78360: LIST
78361: PPUSH
78362: CALL_OW 69
78366: IN
78367: AND
78368: IFFALSE 78493
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
78370: LD_ADDR_VAR 0 9
78374: PUSH
78375: LD_OWVAR 3
78379: PUSH
78380: LD_VAR 0 4
78384: PUSH
78385: LD_VAR 0 7
78389: ARRAY
78390: DIFF
78391: PPUSH
78392: LD_VAR 0 4
78396: PUSH
78397: LD_VAR 0 7
78401: ARRAY
78402: PPUSH
78403: CALL_OW 74
78407: ST_TO_ADDR
// if not k then
78408: LD_VAR 0 9
78412: NOT
78413: IFFALSE 78417
// continue ;
78415: GO 74832
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
78417: LD_VAR 0 9
78421: PUSH
78422: LD_INT 81
78424: PUSH
78425: LD_VAR 0 4
78429: PUSH
78430: LD_VAR 0 7
78434: ARRAY
78435: PPUSH
78436: CALL_OW 255
78440: PUSH
78441: EMPTY
78442: LIST
78443: LIST
78444: PPUSH
78445: CALL_OW 69
78449: IN
78450: PUSH
78451: LD_VAR 0 9
78455: PPUSH
78456: LD_VAR 0 4
78460: PUSH
78461: LD_VAR 0 7
78465: ARRAY
78466: PPUSH
78467: CALL_OW 296
78471: PUSH
78472: LD_INT 5
78474: LESS
78475: AND
78476: IFFALSE 78493
// ComAutodestruct ( group [ i ] ) ;
78478: LD_VAR 0 4
78482: PUSH
78483: LD_VAR 0 7
78487: ARRAY
78488: PPUSH
78489: CALL 51515 0 1
// end ; if f_attack_depot then
78493: LD_VAR 0 25
78497: IFFALSE 78609
// begin k := 6 ;
78499: LD_ADDR_VAR 0 9
78503: PUSH
78504: LD_INT 6
78506: ST_TO_ADDR
// if tmp < k then
78507: LD_VAR 0 14
78511: PUSH
78512: LD_VAR 0 9
78516: LESS
78517: IFFALSE 78529
// k := tmp ;
78519: LD_ADDR_VAR 0 9
78523: PUSH
78524: LD_VAR 0 14
78528: ST_TO_ADDR
// for j = 1 to k do
78529: LD_ADDR_VAR 0 8
78533: PUSH
78534: DOUBLE
78535: LD_INT 1
78537: DEC
78538: ST_TO_ADDR
78539: LD_VAR 0 9
78543: PUSH
78544: FOR_TO
78545: IFFALSE 78607
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
78547: LD_VAR 0 8
78551: PPUSH
78552: CALL_OW 266
78556: PUSH
78557: LD_INT 0
78559: PUSH
78560: LD_INT 1
78562: PUSH
78563: EMPTY
78564: LIST
78565: LIST
78566: IN
78567: IFFALSE 78605
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
78569: LD_VAR 0 4
78573: PUSH
78574: LD_VAR 0 7
78578: ARRAY
78579: PPUSH
78580: LD_VAR 0 14
78584: PUSH
78585: LD_VAR 0 8
78589: ARRAY
78590: PPUSH
78591: CALL_OW 115
// attacking := true ;
78595: LD_ADDR_VAR 0 29
78599: PUSH
78600: LD_INT 1
78602: ST_TO_ADDR
// break ;
78603: GO 78607
// end ;
78605: GO 78544
78607: POP
78608: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
78609: LD_VAR 0 4
78613: PUSH
78614: LD_VAR 0 7
78618: ARRAY
78619: PPUSH
78620: CALL_OW 302
78624: PUSH
78625: LD_VAR 0 29
78629: NOT
78630: AND
78631: IFFALSE 78953
// begin if GetTag ( group [ i ] ) = 71 then
78633: LD_VAR 0 4
78637: PUSH
78638: LD_VAR 0 7
78642: ARRAY
78643: PPUSH
78644: CALL_OW 110
78648: PUSH
78649: LD_INT 71
78651: EQUAL
78652: IFFALSE 78693
// begin if HasTask ( group [ i ] ) then
78654: LD_VAR 0 4
78658: PUSH
78659: LD_VAR 0 7
78663: ARRAY
78664: PPUSH
78665: CALL_OW 314
78669: IFFALSE 78675
// continue else
78671: GO 74832
78673: GO 78693
// SetTag ( group [ i ] , 0 ) ;
78675: LD_VAR 0 4
78679: PUSH
78680: LD_VAR 0 7
78684: ARRAY
78685: PPUSH
78686: LD_INT 0
78688: PPUSH
78689: CALL_OW 109
// end ; k := 8 ;
78693: LD_ADDR_VAR 0 9
78697: PUSH
78698: LD_INT 8
78700: ST_TO_ADDR
// x := 0 ;
78701: LD_ADDR_VAR 0 10
78705: PUSH
78706: LD_INT 0
78708: ST_TO_ADDR
// if tmp < k then
78709: LD_VAR 0 14
78713: PUSH
78714: LD_VAR 0 9
78718: LESS
78719: IFFALSE 78731
// k := tmp ;
78721: LD_ADDR_VAR 0 9
78725: PUSH
78726: LD_VAR 0 14
78730: ST_TO_ADDR
// for j = 1 to k do
78731: LD_ADDR_VAR 0 8
78735: PUSH
78736: DOUBLE
78737: LD_INT 1
78739: DEC
78740: ST_TO_ADDR
78741: LD_VAR 0 9
78745: PUSH
78746: FOR_TO
78747: IFFALSE 78845
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
78749: LD_VAR 0 14
78753: PUSH
78754: LD_VAR 0 8
78758: ARRAY
78759: PPUSH
78760: CALL_OW 247
78764: PUSH
78765: LD_INT 1
78767: EQUAL
78768: PUSH
78769: LD_VAR 0 14
78773: PUSH
78774: LD_VAR 0 8
78778: ARRAY
78779: PPUSH
78780: CALL_OW 256
78784: PUSH
78785: LD_INT 250
78787: LESS
78788: PUSH
78789: LD_VAR 0 20
78793: AND
78794: PUSH
78795: LD_VAR 0 20
78799: NOT
78800: PUSH
78801: LD_VAR 0 14
78805: PUSH
78806: LD_VAR 0 8
78810: ARRAY
78811: PPUSH
78812: CALL_OW 256
78816: PUSH
78817: LD_INT 250
78819: GREATEREQUAL
78820: AND
78821: OR
78822: AND
78823: IFFALSE 78843
// begin x := tmp [ j ] ;
78825: LD_ADDR_VAR 0 10
78829: PUSH
78830: LD_VAR 0 14
78834: PUSH
78835: LD_VAR 0 8
78839: ARRAY
78840: ST_TO_ADDR
// break ;
78841: GO 78845
// end ;
78843: GO 78746
78845: POP
78846: POP
// if x then
78847: LD_VAR 0 10
78851: IFFALSE 78875
// ComAttackUnit ( group [ i ] , x ) else
78853: LD_VAR 0 4
78857: PUSH
78858: LD_VAR 0 7
78862: ARRAY
78863: PPUSH
78864: LD_VAR 0 10
78868: PPUSH
78869: CALL_OW 115
78873: GO 78899
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
78875: LD_VAR 0 4
78879: PUSH
78880: LD_VAR 0 7
78884: ARRAY
78885: PPUSH
78886: LD_VAR 0 14
78890: PUSH
78891: LD_INT 1
78893: ARRAY
78894: PPUSH
78895: CALL_OW 115
// if not HasTask ( group [ i ] ) then
78899: LD_VAR 0 4
78903: PUSH
78904: LD_VAR 0 7
78908: ARRAY
78909: PPUSH
78910: CALL_OW 314
78914: NOT
78915: IFFALSE 78953
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
78917: LD_VAR 0 4
78921: PUSH
78922: LD_VAR 0 7
78926: ARRAY
78927: PPUSH
78928: LD_VAR 0 14
78932: PPUSH
78933: LD_VAR 0 4
78937: PUSH
78938: LD_VAR 0 7
78942: ARRAY
78943: PPUSH
78944: CALL_OW 74
78948: PPUSH
78949: CALL_OW 115
// end ; end ; end ;
78953: GO 74832
78955: POP
78956: POP
// wait ( 0 0$2 ) ;
78957: LD_INT 70
78959: PPUSH
78960: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
78964: LD_VAR 0 4
78968: NOT
78969: PUSH
78970: LD_VAR 0 4
78974: PUSH
78975: EMPTY
78976: EQUAL
78977: OR
78978: PUSH
78979: LD_INT 81
78981: PUSH
78982: LD_VAR 0 35
78986: PUSH
78987: EMPTY
78988: LIST
78989: LIST
78990: PPUSH
78991: CALL_OW 69
78995: NOT
78996: OR
78997: IFFALSE 74817
// end ;
78999: LD_VAR 0 2
79003: RET
// export function BasicDefend ( base , solds , area ) ; var enemy , side , i , hex ; begin
79004: LD_INT 0
79006: PPUSH
79007: PPUSH
79008: PPUSH
79009: PPUSH
79010: PPUSH
// if not base or not mc_bases [ base ] or not solds or not area then
79011: LD_VAR 0 1
79015: NOT
79016: PUSH
79017: LD_EXP 172
79021: PUSH
79022: LD_VAR 0 1
79026: ARRAY
79027: NOT
79028: OR
79029: PUSH
79030: LD_VAR 0 2
79034: NOT
79035: OR
79036: PUSH
79037: LD_VAR 0 3
79041: NOT
79042: OR
79043: IFFALSE 79047
// exit ;
79045: GO 79560
// side := mc_sides [ base ] ;
79047: LD_ADDR_VAR 0 6
79051: PUSH
79052: LD_EXP 198
79056: PUSH
79057: LD_VAR 0 1
79061: ARRAY
79062: ST_TO_ADDR
// if not side then
79063: LD_VAR 0 6
79067: NOT
79068: IFFALSE 79072
// exit ;
79070: GO 79560
// for i in solds do
79072: LD_ADDR_VAR 0 7
79076: PUSH
79077: LD_VAR 0 2
79081: PUSH
79082: FOR_IN
79083: IFFALSE 79144
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
79085: LD_VAR 0 7
79089: PPUSH
79090: CALL_OW 310
79094: PPUSH
79095: CALL_OW 266
79099: PUSH
79100: LD_INT 32
79102: PUSH
79103: LD_INT 31
79105: PUSH
79106: EMPTY
79107: LIST
79108: LIST
79109: IN
79110: IFFALSE 79130
// solds := solds diff i else
79112: LD_ADDR_VAR 0 2
79116: PUSH
79117: LD_VAR 0 2
79121: PUSH
79122: LD_VAR 0 7
79126: DIFF
79127: ST_TO_ADDR
79128: GO 79142
// SetTag ( i , 18 ) ;
79130: LD_VAR 0 7
79134: PPUSH
79135: LD_INT 18
79137: PPUSH
79138: CALL_OW 109
79142: GO 79082
79144: POP
79145: POP
// if not solds then
79146: LD_VAR 0 2
79150: NOT
79151: IFFALSE 79155
// exit ;
79153: GO 79560
// repeat wait ( 0 0$2 ) ;
79155: LD_INT 70
79157: PPUSH
79158: CALL_OW 67
// enemy := ScanBase ( side , area ) ;
79162: LD_ADDR_VAR 0 5
79166: PUSH
79167: LD_VAR 0 6
79171: PPUSH
79172: LD_VAR 0 3
79176: PPUSH
79177: CALL 20897 0 2
79181: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
79182: LD_EXP 172
79186: PUSH
79187: LD_VAR 0 1
79191: ARRAY
79192: NOT
79193: PUSH
79194: LD_EXP 172
79198: PUSH
79199: LD_VAR 0 1
79203: ARRAY
79204: PUSH
79205: EMPTY
79206: EQUAL
79207: OR
79208: IFFALSE 79245
// begin for i in solds do
79210: LD_ADDR_VAR 0 7
79214: PUSH
79215: LD_VAR 0 2
79219: PUSH
79220: FOR_IN
79221: IFFALSE 79234
// ComStop ( i ) ;
79223: LD_VAR 0 7
79227: PPUSH
79228: CALL_OW 141
79232: GO 79220
79234: POP
79235: POP
// solds := [ ] ;
79236: LD_ADDR_VAR 0 2
79240: PUSH
79241: EMPTY
79242: ST_TO_ADDR
// exit ;
79243: GO 79560
// end ; if not enemy or enemy > 3 or mc_defender [ base ] then
79245: LD_VAR 0 5
79249: NOT
79250: PUSH
79251: LD_VAR 0 5
79255: PUSH
79256: LD_INT 3
79258: GREATER
79259: OR
79260: PUSH
79261: LD_EXP 194
79265: PUSH
79266: LD_VAR 0 1
79270: ARRAY
79271: OR
79272: IFFALSE 79313
// begin for i in solds do
79274: LD_ADDR_VAR 0 7
79278: PUSH
79279: LD_VAR 0 2
79283: PUSH
79284: FOR_IN
79285: IFFALSE 79309
// if HasTask ( i ) then
79287: LD_VAR 0 7
79291: PPUSH
79292: CALL_OW 314
79296: IFFALSE 79307
// ComStop ( i ) ;
79298: LD_VAR 0 7
79302: PPUSH
79303: CALL_OW 141
79307: GO 79284
79309: POP
79310: POP
// break ;
79311: GO 79548
// end ; for i in solds do
79313: LD_ADDR_VAR 0 7
79317: PUSH
79318: LD_VAR 0 2
79322: PUSH
79323: FOR_IN
79324: IFFALSE 79540
// begin if IsInUnit ( i ) then
79326: LD_VAR 0 7
79330: PPUSH
79331: CALL_OW 310
79335: IFFALSE 79346
// ComExitBuilding ( i ) ;
79337: LD_VAR 0 7
79341: PPUSH
79342: CALL_OW 122
// if GetLives ( i ) > 333 then
79346: LD_VAR 0 7
79350: PPUSH
79351: CALL_OW 256
79355: PUSH
79356: LD_INT 333
79358: GREATER
79359: IFFALSE 79387
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
79361: LD_VAR 0 7
79365: PPUSH
79366: LD_VAR 0 5
79370: PPUSH
79371: LD_VAR 0 7
79375: PPUSH
79376: CALL_OW 74
79380: PPUSH
79381: CALL_OW 115
79385: GO 79538
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
79387: LD_ADDR_VAR 0 8
79391: PUSH
79392: LD_EXP 172
79396: PUSH
79397: LD_VAR 0 1
79401: ARRAY
79402: PPUSH
79403: LD_INT 2
79405: PUSH
79406: LD_INT 30
79408: PUSH
79409: LD_INT 0
79411: PUSH
79412: EMPTY
79413: LIST
79414: LIST
79415: PUSH
79416: LD_INT 30
79418: PUSH
79419: LD_INT 1
79421: PUSH
79422: EMPTY
79423: LIST
79424: LIST
79425: PUSH
79426: LD_INT 30
79428: PUSH
79429: LD_INT 6
79431: PUSH
79432: EMPTY
79433: LIST
79434: LIST
79435: PUSH
79436: EMPTY
79437: LIST
79438: LIST
79439: LIST
79440: LIST
79441: PPUSH
79442: CALL_OW 72
79446: PPUSH
79447: LD_VAR 0 7
79451: PPUSH
79452: CALL_OW 74
79456: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
79457: LD_VAR 0 7
79461: PPUSH
79462: LD_VAR 0 8
79466: PPUSH
79467: CALL_OW 250
79471: PPUSH
79472: LD_INT 3
79474: PPUSH
79475: LD_INT 5
79477: PPUSH
79478: CALL_OW 272
79482: PPUSH
79483: LD_VAR 0 8
79487: PPUSH
79488: CALL_OW 251
79492: PPUSH
79493: LD_INT 3
79495: PPUSH
79496: LD_INT 5
79498: PPUSH
79499: CALL_OW 273
79503: PPUSH
79504: CALL_OW 111
// SetTag ( i , 0 ) ;
79508: LD_VAR 0 7
79512: PPUSH
79513: LD_INT 0
79515: PPUSH
79516: CALL_OW 109
// solds := solds diff i ;
79520: LD_ADDR_VAR 0 2
79524: PUSH
79525: LD_VAR 0 2
79529: PUSH
79530: LD_VAR 0 7
79534: DIFF
79535: ST_TO_ADDR
// continue ;
79536: GO 79323
// end ; end ;
79538: GO 79323
79540: POP
79541: POP
// until solds ;
79542: LD_VAR 0 2
79546: IFFALSE 79155
// MC_Reset ( base , 18 ) ;
79548: LD_VAR 0 1
79552: PPUSH
79553: LD_INT 18
79555: PPUSH
79556: CALL 85610 0 2
// end ;
79560: LD_VAR 0 4
79564: RET
// export function Defend ( base , defenders , enemy ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend ; begin
79565: LD_INT 0
79567: PPUSH
79568: PPUSH
79569: PPUSH
79570: PPUSH
79571: PPUSH
79572: PPUSH
79573: PPUSH
79574: PPUSH
79575: PPUSH
79576: PPUSH
79577: PPUSH
79578: PPUSH
79579: PPUSH
79580: PPUSH
79581: PPUSH
79582: PPUSH
79583: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
79584: LD_ADDR_VAR 0 13
79588: PUSH
79589: LD_EXP 172
79593: PUSH
79594: LD_VAR 0 1
79598: ARRAY
79599: PPUSH
79600: LD_INT 25
79602: PUSH
79603: LD_INT 3
79605: PUSH
79606: EMPTY
79607: LIST
79608: LIST
79609: PPUSH
79610: CALL_OW 72
79614: ST_TO_ADDR
// if mc_remote_driver [ base ] then
79615: LD_EXP 212
79619: PUSH
79620: LD_VAR 0 1
79624: ARRAY
79625: IFFALSE 79649
// mechs := mechs diff mc_remote_driver [ base ] ;
79627: LD_ADDR_VAR 0 13
79631: PUSH
79632: LD_VAR 0 13
79636: PUSH
79637: LD_EXP 212
79641: PUSH
79642: LD_VAR 0 1
79646: ARRAY
79647: DIFF
79648: ST_TO_ADDR
// for i in mechs do
79649: LD_ADDR_VAR 0 5
79653: PUSH
79654: LD_VAR 0 13
79658: PUSH
79659: FOR_IN
79660: IFFALSE 79695
// if GetTag ( i ) > 0 then
79662: LD_VAR 0 5
79666: PPUSH
79667: CALL_OW 110
79671: PUSH
79672: LD_INT 0
79674: GREATER
79675: IFFALSE 79693
// mechs := mechs diff i ;
79677: LD_ADDR_VAR 0 13
79681: PUSH
79682: LD_VAR 0 13
79686: PUSH
79687: LD_VAR 0 5
79691: DIFF
79692: ST_TO_ADDR
79693: GO 79659
79695: POP
79696: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
79697: LD_ADDR_VAR 0 9
79701: PUSH
79702: LD_EXP 172
79706: PUSH
79707: LD_VAR 0 1
79711: ARRAY
79712: PPUSH
79713: LD_INT 2
79715: PUSH
79716: LD_INT 25
79718: PUSH
79719: LD_INT 1
79721: PUSH
79722: EMPTY
79723: LIST
79724: LIST
79725: PUSH
79726: LD_INT 25
79728: PUSH
79729: LD_INT 5
79731: PUSH
79732: EMPTY
79733: LIST
79734: LIST
79735: PUSH
79736: LD_INT 25
79738: PUSH
79739: LD_INT 8
79741: PUSH
79742: EMPTY
79743: LIST
79744: LIST
79745: PUSH
79746: LD_INT 25
79748: PUSH
79749: LD_INT 9
79751: PUSH
79752: EMPTY
79753: LIST
79754: LIST
79755: PUSH
79756: EMPTY
79757: LIST
79758: LIST
79759: LIST
79760: LIST
79761: LIST
79762: PPUSH
79763: CALL_OW 72
79767: ST_TO_ADDR
// if not defenders and not solds then
79768: LD_VAR 0 2
79772: NOT
79773: PUSH
79774: LD_VAR 0 9
79778: NOT
79779: AND
79780: IFFALSE 79784
// exit ;
79782: GO 81474
// depot_under_attack := false ;
79784: LD_ADDR_VAR 0 17
79788: PUSH
79789: LD_INT 0
79791: ST_TO_ADDR
// sold_defenders := [ ] ;
79792: LD_ADDR_VAR 0 18
79796: PUSH
79797: EMPTY
79798: ST_TO_ADDR
// if mechs then
79799: LD_VAR 0 13
79803: IFFALSE 79956
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
79805: LD_ADDR_VAR 0 5
79809: PUSH
79810: LD_VAR 0 2
79814: PPUSH
79815: LD_INT 21
79817: PUSH
79818: LD_INT 2
79820: PUSH
79821: EMPTY
79822: LIST
79823: LIST
79824: PPUSH
79825: CALL_OW 72
79829: PUSH
79830: FOR_IN
79831: IFFALSE 79954
// begin if GetTag ( i ) <> 20 then
79833: LD_VAR 0 5
79837: PPUSH
79838: CALL_OW 110
79842: PUSH
79843: LD_INT 20
79845: NONEQUAL
79846: IFFALSE 79860
// SetTag ( i , 20 ) ;
79848: LD_VAR 0 5
79852: PPUSH
79853: LD_INT 20
79855: PPUSH
79856: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
79860: LD_VAR 0 5
79864: PPUSH
79865: CALL_OW 263
79869: PUSH
79870: LD_INT 1
79872: EQUAL
79873: PUSH
79874: LD_VAR 0 5
79878: PPUSH
79879: CALL_OW 311
79883: NOT
79884: AND
79885: IFFALSE 79952
// begin un := mechs [ 1 ] ;
79887: LD_ADDR_VAR 0 11
79891: PUSH
79892: LD_VAR 0 13
79896: PUSH
79897: LD_INT 1
79899: ARRAY
79900: ST_TO_ADDR
// ComExit ( un ) ;
79901: LD_VAR 0 11
79905: PPUSH
79906: CALL 55860 0 1
// AddComEnterUnit ( un , i ) ;
79910: LD_VAR 0 11
79914: PPUSH
79915: LD_VAR 0 5
79919: PPUSH
79920: CALL_OW 180
// SetTag ( un , 19 ) ;
79924: LD_VAR 0 11
79928: PPUSH
79929: LD_INT 19
79931: PPUSH
79932: CALL_OW 109
// mechs := mechs diff un ;
79936: LD_ADDR_VAR 0 13
79940: PUSH
79941: LD_VAR 0 13
79945: PUSH
79946: LD_VAR 0 11
79950: DIFF
79951: ST_TO_ADDR
// end ; end ;
79952: GO 79830
79954: POP
79955: POP
// if solds then
79956: LD_VAR 0 9
79960: IFFALSE 80019
// for i in solds do
79962: LD_ADDR_VAR 0 5
79966: PUSH
79967: LD_VAR 0 9
79971: PUSH
79972: FOR_IN
79973: IFFALSE 80017
// if not GetTag ( i ) then
79975: LD_VAR 0 5
79979: PPUSH
79980: CALL_OW 110
79984: NOT
79985: IFFALSE 80015
// begin defenders := defenders union i ;
79987: LD_ADDR_VAR 0 2
79991: PUSH
79992: LD_VAR 0 2
79996: PUSH
79997: LD_VAR 0 5
80001: UNION
80002: ST_TO_ADDR
// SetTag ( i , 18 ) ;
80003: LD_VAR 0 5
80007: PPUSH
80008: LD_INT 18
80010: PPUSH
80011: CALL_OW 109
// end ;
80015: GO 79972
80017: POP
80018: POP
// repeat wait ( 0 0$2 ) ;
80019: LD_INT 70
80021: PPUSH
80022: CALL_OW 67
// enemy := mc_scan [ base ] ;
80026: LD_ADDR_VAR 0 3
80030: PUSH
80031: LD_EXP 195
80035: PUSH
80036: LD_VAR 0 1
80040: ARRAY
80041: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
80042: LD_EXP 172
80046: PUSH
80047: LD_VAR 0 1
80051: ARRAY
80052: NOT
80053: PUSH
80054: LD_EXP 172
80058: PUSH
80059: LD_VAR 0 1
80063: ARRAY
80064: PUSH
80065: EMPTY
80066: EQUAL
80067: OR
80068: IFFALSE 80105
// begin for i in defenders do
80070: LD_ADDR_VAR 0 5
80074: PUSH
80075: LD_VAR 0 2
80079: PUSH
80080: FOR_IN
80081: IFFALSE 80094
// ComStop ( i ) ;
80083: LD_VAR 0 5
80087: PPUSH
80088: CALL_OW 141
80092: GO 80080
80094: POP
80095: POP
// defenders := [ ] ;
80096: LD_ADDR_VAR 0 2
80100: PUSH
80101: EMPTY
80102: ST_TO_ADDR
// exit ;
80103: GO 81474
// end ; for i in defenders do
80105: LD_ADDR_VAR 0 5
80109: PUSH
80110: LD_VAR 0 2
80114: PUSH
80115: FOR_IN
80116: IFFALSE 80934
// begin e := NearestUnitToUnit ( enemy , i ) ;
80118: LD_ADDR_VAR 0 14
80122: PUSH
80123: LD_VAR 0 3
80127: PPUSH
80128: LD_VAR 0 5
80132: PPUSH
80133: CALL_OW 74
80137: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
80138: LD_ADDR_VAR 0 8
80142: PUSH
80143: LD_EXP 172
80147: PUSH
80148: LD_VAR 0 1
80152: ARRAY
80153: PPUSH
80154: LD_INT 2
80156: PUSH
80157: LD_INT 30
80159: PUSH
80160: LD_INT 0
80162: PUSH
80163: EMPTY
80164: LIST
80165: LIST
80166: PUSH
80167: LD_INT 30
80169: PUSH
80170: LD_INT 1
80172: PUSH
80173: EMPTY
80174: LIST
80175: LIST
80176: PUSH
80177: EMPTY
80178: LIST
80179: LIST
80180: LIST
80181: PPUSH
80182: CALL_OW 72
80186: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
80187: LD_ADDR_VAR 0 17
80191: PUSH
80192: LD_VAR 0 8
80196: NOT
80197: PUSH
80198: LD_VAR 0 8
80202: PPUSH
80203: LD_INT 3
80205: PUSH
80206: LD_INT 24
80208: PUSH
80209: LD_INT 600
80211: PUSH
80212: EMPTY
80213: LIST
80214: LIST
80215: PUSH
80216: EMPTY
80217: LIST
80218: LIST
80219: PPUSH
80220: CALL_OW 72
80224: OR
80225: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
80226: LD_VAR 0 5
80230: PPUSH
80231: CALL_OW 247
80235: PUSH
80236: LD_INT 2
80238: DOUBLE
80239: EQUAL
80240: IFTRUE 80244
80242: GO 80640
80244: POP
// begin if GetLives ( i ) = 1000 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
80245: LD_VAR 0 5
80249: PPUSH
80250: CALL_OW 256
80254: PUSH
80255: LD_INT 1000
80257: EQUAL
80258: PUSH
80259: LD_VAR 0 5
80263: PPUSH
80264: LD_VAR 0 14
80268: PPUSH
80269: CALL_OW 296
80273: PUSH
80274: LD_INT 40
80276: LESS
80277: PUSH
80278: LD_VAR 0 14
80282: PPUSH
80283: LD_EXP 197
80287: PUSH
80288: LD_VAR 0 1
80292: ARRAY
80293: PPUSH
80294: CALL_OW 308
80298: OR
80299: AND
80300: IFFALSE 80422
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
80302: LD_VAR 0 5
80306: PPUSH
80307: CALL_OW 262
80311: PUSH
80312: LD_INT 1
80314: EQUAL
80315: PUSH
80316: LD_VAR 0 5
80320: PPUSH
80321: CALL_OW 261
80325: PUSH
80326: LD_INT 30
80328: LESS
80329: AND
80330: PUSH
80331: LD_VAR 0 8
80335: AND
80336: IFFALSE 80406
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
80338: LD_VAR 0 5
80342: PPUSH
80343: LD_VAR 0 8
80347: PPUSH
80348: LD_VAR 0 5
80352: PPUSH
80353: CALL_OW 74
80357: PPUSH
80358: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
80362: LD_VAR 0 5
80366: PPUSH
80367: LD_VAR 0 8
80371: PPUSH
80372: LD_VAR 0 5
80376: PPUSH
80377: CALL_OW 74
80381: PPUSH
80382: CALL_OW 296
80386: PUSH
80387: LD_INT 6
80389: LESS
80390: IFFALSE 80404
// SetFuel ( i , 100 ) ;
80392: LD_VAR 0 5
80396: PPUSH
80397: LD_INT 100
80399: PPUSH
80400: CALL_OW 240
// end else
80404: GO 80420
// ComAttackUnit ( i , e ) ;
80406: LD_VAR 0 5
80410: PPUSH
80411: LD_VAR 0 14
80415: PPUSH
80416: CALL_OW 115
// end else
80420: GO 80523
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
80422: LD_VAR 0 14
80426: PPUSH
80427: LD_EXP 197
80431: PUSH
80432: LD_VAR 0 1
80436: ARRAY
80437: PPUSH
80438: CALL_OW 308
80442: NOT
80443: PUSH
80444: LD_VAR 0 5
80448: PPUSH
80449: LD_VAR 0 14
80453: PPUSH
80454: CALL_OW 296
80458: PUSH
80459: LD_INT 40
80461: GREATEREQUAL
80462: AND
80463: PUSH
80464: LD_VAR 0 5
80468: PPUSH
80469: CALL_OW 256
80473: PUSH
80474: LD_INT 650
80476: LESSEQUAL
80477: OR
80478: PUSH
80479: LD_VAR 0 5
80483: PPUSH
80484: LD_EXP 196
80488: PUSH
80489: LD_VAR 0 1
80493: ARRAY
80494: PPUSH
80495: CALL_OW 308
80499: NOT
80500: AND
80501: IFFALSE 80523
// ComMoveToArea ( i , mc_parking [ base ] ) ;
80503: LD_VAR 0 5
80507: PPUSH
80508: LD_EXP 196
80512: PUSH
80513: LD_VAR 0 1
80517: ARRAY
80518: PPUSH
80519: CALL_OW 113
// if GetLives ( i ) < 1000 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
80523: LD_VAR 0 5
80527: PPUSH
80528: CALL_OW 256
80532: PUSH
80533: LD_INT 1000
80535: LESS
80536: PUSH
80537: LD_VAR 0 5
80541: PPUSH
80542: CALL_OW 263
80546: PUSH
80547: LD_INT 1
80549: EQUAL
80550: AND
80551: PUSH
80552: LD_VAR 0 5
80556: PPUSH
80557: CALL_OW 311
80561: AND
80562: PUSH
80563: LD_VAR 0 5
80567: PPUSH
80568: LD_EXP 196
80572: PUSH
80573: LD_VAR 0 1
80577: ARRAY
80578: PPUSH
80579: CALL_OW 308
80583: AND
80584: IFFALSE 80638
// begin mech := IsDrivenBy ( i ) ;
80586: LD_ADDR_VAR 0 10
80590: PUSH
80591: LD_VAR 0 5
80595: PPUSH
80596: CALL_OW 311
80600: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
80601: LD_VAR 0 10
80605: PPUSH
80606: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
80610: LD_VAR 0 10
80614: PPUSH
80615: LD_VAR 0 5
80619: PPUSH
80620: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
80624: LD_VAR 0 10
80628: PPUSH
80629: LD_VAR 0 5
80633: PPUSH
80634: CALL_OW 180
// end ; end ; unit_human :
80638: GO 80905
80640: LD_INT 1
80642: DOUBLE
80643: EQUAL
80644: IFTRUE 80648
80646: GO 80904
80648: POP
// begin b := IsInUnit ( i ) ;
80649: LD_ADDR_VAR 0 19
80653: PUSH
80654: LD_VAR 0 5
80658: PPUSH
80659: CALL_OW 310
80663: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
80664: LD_ADDR_VAR 0 20
80668: PUSH
80669: LD_VAR 0 19
80673: NOT
80674: PUSH
80675: LD_VAR 0 19
80679: PPUSH
80680: CALL_OW 266
80684: PUSH
80685: LD_INT 32
80687: PUSH
80688: LD_INT 31
80690: PUSH
80691: EMPTY
80692: LIST
80693: LIST
80694: IN
80695: OR
80696: ST_TO_ADDR
// if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
80697: LD_VAR 0 17
80701: PUSH
80702: LD_VAR 0 2
80706: PPUSH
80707: LD_INT 21
80709: PUSH
80710: LD_INT 2
80712: PUSH
80713: EMPTY
80714: LIST
80715: LIST
80716: PPUSH
80717: CALL_OW 72
80721: PUSH
80722: LD_INT 1
80724: LESSEQUAL
80725: OR
80726: PUSH
80727: LD_VAR 0 20
80731: AND
80732: PUSH
80733: LD_VAR 0 5
80737: PUSH
80738: LD_VAR 0 18
80742: IN
80743: NOT
80744: AND
80745: IFFALSE 80838
// begin if b then
80747: LD_VAR 0 19
80751: IFFALSE 80800
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
80753: LD_VAR 0 19
80757: PPUSH
80758: LD_VAR 0 3
80762: PPUSH
80763: LD_VAR 0 19
80767: PPUSH
80768: CALL_OW 74
80772: PPUSH
80773: CALL_OW 296
80777: PUSH
80778: LD_INT 10
80780: LESS
80781: PUSH
80782: LD_VAR 0 19
80786: PPUSH
80787: CALL_OW 461
80791: PUSH
80792: LD_INT 7
80794: NONEQUAL
80795: AND
80796: IFFALSE 80800
// continue ;
80798: GO 80115
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
80800: LD_ADDR_VAR 0 18
80804: PUSH
80805: LD_VAR 0 18
80809: PPUSH
80810: LD_VAR 0 18
80814: PUSH
80815: LD_INT 1
80817: PLUS
80818: PPUSH
80819: LD_VAR 0 5
80823: PPUSH
80824: CALL_OW 1
80828: ST_TO_ADDR
// ComExitBuilding ( i ) ;
80829: LD_VAR 0 5
80833: PPUSH
80834: CALL_OW 122
// end ; if sold_defenders then
80838: LD_VAR 0 18
80842: IFFALSE 80902
// if i in sold_defenders then
80844: LD_VAR 0 5
80848: PUSH
80849: LD_VAR 0 18
80853: IN
80854: IFFALSE 80902
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
80856: LD_VAR 0 5
80860: PPUSH
80861: CALL_OW 314
80865: NOT
80866: PUSH
80867: LD_VAR 0 5
80871: PPUSH
80872: LD_VAR 0 14
80876: PPUSH
80877: CALL_OW 296
80881: PUSH
80882: LD_INT 30
80884: LESS
80885: AND
80886: IFFALSE 80902
// ComAttackUnit ( i , e ) ;
80888: LD_VAR 0 5
80892: PPUSH
80893: LD_VAR 0 14
80897: PPUSH
80898: CALL_OW 115
// end ; end ; end ;
80902: GO 80905
80904: POP
// if IsDead ( i ) then
80905: LD_VAR 0 5
80909: PPUSH
80910: CALL_OW 301
80914: IFFALSE 80932
// defenders := defenders diff i ;
80916: LD_ADDR_VAR 0 2
80920: PUSH
80921: LD_VAR 0 2
80925: PUSH
80926: LD_VAR 0 5
80930: DIFF
80931: ST_TO_ADDR
// end ;
80932: GO 80115
80934: POP
80935: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
80936: LD_VAR 0 3
80940: NOT
80941: PUSH
80942: LD_VAR 0 2
80946: NOT
80947: OR
80948: PUSH
80949: LD_EXP 172
80953: PUSH
80954: LD_VAR 0 1
80958: ARRAY
80959: NOT
80960: OR
80961: IFFALSE 80019
// MC_Reset ( base , 18 ) ;
80963: LD_VAR 0 1
80967: PPUSH
80968: LD_INT 18
80970: PPUSH
80971: CALL 85610 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
80975: LD_ADDR_VAR 0 2
80979: PUSH
80980: LD_VAR 0 2
80984: PUSH
80985: LD_VAR 0 2
80989: PPUSH
80990: LD_INT 2
80992: PUSH
80993: LD_INT 25
80995: PUSH
80996: LD_INT 1
80998: PUSH
80999: EMPTY
81000: LIST
81001: LIST
81002: PUSH
81003: LD_INT 25
81005: PUSH
81006: LD_INT 5
81008: PUSH
81009: EMPTY
81010: LIST
81011: LIST
81012: PUSH
81013: LD_INT 25
81015: PUSH
81016: LD_INT 8
81018: PUSH
81019: EMPTY
81020: LIST
81021: LIST
81022: PUSH
81023: LD_INT 25
81025: PUSH
81026: LD_INT 9
81028: PUSH
81029: EMPTY
81030: LIST
81031: LIST
81032: PUSH
81033: EMPTY
81034: LIST
81035: LIST
81036: LIST
81037: LIST
81038: LIST
81039: PPUSH
81040: CALL_OW 72
81044: DIFF
81045: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
81046: LD_VAR 0 3
81050: NOT
81051: PUSH
81052: LD_VAR 0 2
81056: PPUSH
81057: LD_INT 21
81059: PUSH
81060: LD_INT 2
81062: PUSH
81063: EMPTY
81064: LIST
81065: LIST
81066: PPUSH
81067: CALL_OW 72
81071: AND
81072: IFFALSE 81410
// begin tmp := FilterByTag ( defenders , 19 ) ;
81074: LD_ADDR_VAR 0 12
81078: PUSH
81079: LD_VAR 0 2
81083: PPUSH
81084: LD_INT 19
81086: PPUSH
81087: CALL 52990 0 2
81091: ST_TO_ADDR
// if tmp then
81092: LD_VAR 0 12
81096: IFFALSE 81166
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
81098: LD_ADDR_VAR 0 12
81102: PUSH
81103: LD_VAR 0 12
81107: PPUSH
81108: LD_INT 25
81110: PUSH
81111: LD_INT 3
81113: PUSH
81114: EMPTY
81115: LIST
81116: LIST
81117: PPUSH
81118: CALL_OW 72
81122: ST_TO_ADDR
// if tmp then
81123: LD_VAR 0 12
81127: IFFALSE 81166
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
81129: LD_ADDR_EXP 184
81133: PUSH
81134: LD_EXP 184
81138: PPUSH
81139: LD_VAR 0 1
81143: PPUSH
81144: LD_EXP 184
81148: PUSH
81149: LD_VAR 0 1
81153: ARRAY
81154: PUSH
81155: LD_VAR 0 12
81159: UNION
81160: PPUSH
81161: CALL_OW 1
81165: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
81166: LD_VAR 0 1
81170: PPUSH
81171: LD_INT 19
81173: PPUSH
81174: CALL 85610 0 2
// repeat wait ( 0 0$1 ) ;
81178: LD_INT 35
81180: PPUSH
81181: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
81185: LD_EXP 172
81189: PUSH
81190: LD_VAR 0 1
81194: ARRAY
81195: NOT
81196: PUSH
81197: LD_EXP 172
81201: PUSH
81202: LD_VAR 0 1
81206: ARRAY
81207: PUSH
81208: EMPTY
81209: EQUAL
81210: OR
81211: IFFALSE 81248
// begin for i in defenders do
81213: LD_ADDR_VAR 0 5
81217: PUSH
81218: LD_VAR 0 2
81222: PUSH
81223: FOR_IN
81224: IFFALSE 81237
// ComStop ( i ) ;
81226: LD_VAR 0 5
81230: PPUSH
81231: CALL_OW 141
81235: GO 81223
81237: POP
81238: POP
// defenders := [ ] ;
81239: LD_ADDR_VAR 0 2
81243: PUSH
81244: EMPTY
81245: ST_TO_ADDR
// exit ;
81246: GO 81474
// end ; for i in defenders do
81248: LD_ADDR_VAR 0 5
81252: PUSH
81253: LD_VAR 0 2
81257: PUSH
81258: FOR_IN
81259: IFFALSE 81348
// begin if not IsInArea ( i , mc_parking [ base ] ) then
81261: LD_VAR 0 5
81265: PPUSH
81266: LD_EXP 196
81270: PUSH
81271: LD_VAR 0 1
81275: ARRAY
81276: PPUSH
81277: CALL_OW 308
81281: NOT
81282: IFFALSE 81306
// ComMoveToArea ( i , mc_parking [ base ] ) else
81284: LD_VAR 0 5
81288: PPUSH
81289: LD_EXP 196
81293: PUSH
81294: LD_VAR 0 1
81298: ARRAY
81299: PPUSH
81300: CALL_OW 113
81304: GO 81346
// if GetControl ( i ) = control_manual then
81306: LD_VAR 0 5
81310: PPUSH
81311: CALL_OW 263
81315: PUSH
81316: LD_INT 1
81318: EQUAL
81319: IFFALSE 81346
// if IsDrivenBy ( i ) then
81321: LD_VAR 0 5
81325: PPUSH
81326: CALL_OW 311
81330: IFFALSE 81346
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
81332: LD_VAR 0 5
81336: PPUSH
81337: CALL_OW 311
81341: PPUSH
81342: CALL_OW 121
// end ;
81346: GO 81258
81348: POP
81349: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
81350: LD_VAR 0 2
81354: PPUSH
81355: LD_INT 95
81357: PUSH
81358: LD_EXP 196
81362: PUSH
81363: LD_VAR 0 1
81367: ARRAY
81368: PUSH
81369: EMPTY
81370: LIST
81371: LIST
81372: PPUSH
81373: CALL_OW 72
81377: PUSH
81378: LD_VAR 0 2
81382: EQUAL
81383: PUSH
81384: LD_EXP 195
81388: PUSH
81389: LD_VAR 0 1
81393: ARRAY
81394: OR
81395: PUSH
81396: LD_EXP 172
81400: PUSH
81401: LD_VAR 0 1
81405: ARRAY
81406: NOT
81407: OR
81408: IFFALSE 81178
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
81410: LD_ADDR_EXP 194
81414: PUSH
81415: LD_EXP 194
81419: PPUSH
81420: LD_VAR 0 1
81424: PPUSH
81425: LD_VAR 0 2
81429: PPUSH
81430: LD_INT 21
81432: PUSH
81433: LD_INT 2
81435: PUSH
81436: EMPTY
81437: LIST
81438: LIST
81439: PPUSH
81440: CALL_OW 72
81444: PPUSH
81445: CALL_OW 1
81449: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
81450: LD_VAR 0 1
81454: PPUSH
81455: LD_INT 19
81457: PPUSH
81458: CALL 85610 0 2
// MC_Reset ( base , 20 ) ;
81462: LD_VAR 0 1
81466: PPUSH
81467: LD_INT 20
81469: PPUSH
81470: CALL 85610 0 2
// end ; end_of_file
81474: LD_VAR 0 4
81478: RET
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use , mc_is_defending ; export function InitMacro ; var i ; begin
81479: LD_INT 0
81481: PPUSH
81482: PPUSH
// skirmish := false ;
81483: LD_ADDR_EXP 170
81487: PUSH
81488: LD_INT 0
81490: ST_TO_ADDR
// debug_mc := false ;
81491: LD_ADDR_EXP 171
81495: PUSH
81496: LD_INT 0
81498: ST_TO_ADDR
// mc_bases := [ ] ;
81499: LD_ADDR_EXP 172
81503: PUSH
81504: EMPTY
81505: ST_TO_ADDR
// mc_sides := [ ] ;
81506: LD_ADDR_EXP 198
81510: PUSH
81511: EMPTY
81512: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
81513: LD_ADDR_EXP 173
81517: PUSH
81518: EMPTY
81519: ST_TO_ADDR
// mc_building_repairs := [ ] ;
81520: LD_ADDR_EXP 174
81524: PUSH
81525: EMPTY
81526: ST_TO_ADDR
// mc_need_heal := [ ] ;
81527: LD_ADDR_EXP 175
81531: PUSH
81532: EMPTY
81533: ST_TO_ADDR
// mc_healers := [ ] ;
81534: LD_ADDR_EXP 176
81538: PUSH
81539: EMPTY
81540: ST_TO_ADDR
// mc_build_list := [ ] ;
81541: LD_ADDR_EXP 177
81545: PUSH
81546: EMPTY
81547: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
81548: LD_ADDR_EXP 204
81552: PUSH
81553: EMPTY
81554: ST_TO_ADDR
// mc_builders := [ ] ;
81555: LD_ADDR_EXP 178
81559: PUSH
81560: EMPTY
81561: ST_TO_ADDR
// mc_construct_list := [ ] ;
81562: LD_ADDR_EXP 179
81566: PUSH
81567: EMPTY
81568: ST_TO_ADDR
// mc_turret_list := [ ] ;
81569: LD_ADDR_EXP 180
81573: PUSH
81574: EMPTY
81575: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
81576: LD_ADDR_EXP 181
81580: PUSH
81581: EMPTY
81582: ST_TO_ADDR
// mc_miners := [ ] ;
81583: LD_ADDR_EXP 186
81587: PUSH
81588: EMPTY
81589: ST_TO_ADDR
// mc_mines := [ ] ;
81590: LD_ADDR_EXP 185
81594: PUSH
81595: EMPTY
81596: ST_TO_ADDR
// mc_minefields := [ ] ;
81597: LD_ADDR_EXP 187
81601: PUSH
81602: EMPTY
81603: ST_TO_ADDR
// mc_crates := [ ] ;
81604: LD_ADDR_EXP 188
81608: PUSH
81609: EMPTY
81610: ST_TO_ADDR
// mc_crates_collector := [ ] ;
81611: LD_ADDR_EXP 189
81615: PUSH
81616: EMPTY
81617: ST_TO_ADDR
// mc_crates_area := [ ] ;
81618: LD_ADDR_EXP 190
81622: PUSH
81623: EMPTY
81624: ST_TO_ADDR
// mc_vehicles := [ ] ;
81625: LD_ADDR_EXP 191
81629: PUSH
81630: EMPTY
81631: ST_TO_ADDR
// mc_attack := [ ] ;
81632: LD_ADDR_EXP 192
81636: PUSH
81637: EMPTY
81638: ST_TO_ADDR
// mc_produce := [ ] ;
81639: LD_ADDR_EXP 193
81643: PUSH
81644: EMPTY
81645: ST_TO_ADDR
// mc_defender := [ ] ;
81646: LD_ADDR_EXP 194
81650: PUSH
81651: EMPTY
81652: ST_TO_ADDR
// mc_parking := [ ] ;
81653: LD_ADDR_EXP 196
81657: PUSH
81658: EMPTY
81659: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
81660: LD_ADDR_EXP 182
81664: PUSH
81665: EMPTY
81666: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
81667: LD_ADDR_EXP 184
81671: PUSH
81672: EMPTY
81673: ST_TO_ADDR
// mc_scan := [ ] ;
81674: LD_ADDR_EXP 195
81678: PUSH
81679: EMPTY
81680: ST_TO_ADDR
// mc_scan_area := [ ] ;
81681: LD_ADDR_EXP 197
81685: PUSH
81686: EMPTY
81687: ST_TO_ADDR
// mc_tech := [ ] ;
81688: LD_ADDR_EXP 199
81692: PUSH
81693: EMPTY
81694: ST_TO_ADDR
// mc_class := [ ] ;
81695: LD_ADDR_EXP 213
81699: PUSH
81700: EMPTY
81701: ST_TO_ADDR
// mc_class_case_use := [ ] ;
81702: LD_ADDR_EXP 214
81706: PUSH
81707: EMPTY
81708: ST_TO_ADDR
// mc_is_defending := [ ] ;
81709: LD_ADDR_EXP 215
81713: PUSH
81714: EMPTY
81715: ST_TO_ADDR
// end ;
81716: LD_VAR 0 1
81720: RET
// export function MC_Kill ( base ) ; begin
81721: LD_INT 0
81723: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
81724: LD_ADDR_EXP 172
81728: PUSH
81729: LD_EXP 172
81733: PPUSH
81734: LD_VAR 0 1
81738: PPUSH
81739: EMPTY
81740: PPUSH
81741: CALL_OW 1
81745: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
81746: LD_ADDR_EXP 173
81750: PUSH
81751: LD_EXP 173
81755: PPUSH
81756: LD_VAR 0 1
81760: PPUSH
81761: EMPTY
81762: PPUSH
81763: CALL_OW 1
81767: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
81768: LD_ADDR_EXP 174
81772: PUSH
81773: LD_EXP 174
81777: PPUSH
81778: LD_VAR 0 1
81782: PPUSH
81783: EMPTY
81784: PPUSH
81785: CALL_OW 1
81789: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
81790: LD_ADDR_EXP 175
81794: PUSH
81795: LD_EXP 175
81799: PPUSH
81800: LD_VAR 0 1
81804: PPUSH
81805: EMPTY
81806: PPUSH
81807: CALL_OW 1
81811: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
81812: LD_ADDR_EXP 176
81816: PUSH
81817: LD_EXP 176
81821: PPUSH
81822: LD_VAR 0 1
81826: PPUSH
81827: EMPTY
81828: PPUSH
81829: CALL_OW 1
81833: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
81834: LD_ADDR_EXP 177
81838: PUSH
81839: LD_EXP 177
81843: PPUSH
81844: LD_VAR 0 1
81848: PPUSH
81849: EMPTY
81850: PPUSH
81851: CALL_OW 1
81855: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
81856: LD_ADDR_EXP 178
81860: PUSH
81861: LD_EXP 178
81865: PPUSH
81866: LD_VAR 0 1
81870: PPUSH
81871: EMPTY
81872: PPUSH
81873: CALL_OW 1
81877: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
81878: LD_ADDR_EXP 179
81882: PUSH
81883: LD_EXP 179
81887: PPUSH
81888: LD_VAR 0 1
81892: PPUSH
81893: EMPTY
81894: PPUSH
81895: CALL_OW 1
81899: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
81900: LD_ADDR_EXP 180
81904: PUSH
81905: LD_EXP 180
81909: PPUSH
81910: LD_VAR 0 1
81914: PPUSH
81915: EMPTY
81916: PPUSH
81917: CALL_OW 1
81921: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
81922: LD_ADDR_EXP 181
81926: PUSH
81927: LD_EXP 181
81931: PPUSH
81932: LD_VAR 0 1
81936: PPUSH
81937: EMPTY
81938: PPUSH
81939: CALL_OW 1
81943: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
81944: LD_ADDR_EXP 182
81948: PUSH
81949: LD_EXP 182
81953: PPUSH
81954: LD_VAR 0 1
81958: PPUSH
81959: EMPTY
81960: PPUSH
81961: CALL_OW 1
81965: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
81966: LD_ADDR_EXP 183
81970: PUSH
81971: LD_EXP 183
81975: PPUSH
81976: LD_VAR 0 1
81980: PPUSH
81981: LD_INT 0
81983: PPUSH
81984: CALL_OW 1
81988: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
81989: LD_ADDR_EXP 184
81993: PUSH
81994: LD_EXP 184
81998: PPUSH
81999: LD_VAR 0 1
82003: PPUSH
82004: EMPTY
82005: PPUSH
82006: CALL_OW 1
82010: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
82011: LD_ADDR_EXP 185
82015: PUSH
82016: LD_EXP 185
82020: PPUSH
82021: LD_VAR 0 1
82025: PPUSH
82026: EMPTY
82027: PPUSH
82028: CALL_OW 1
82032: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
82033: LD_ADDR_EXP 186
82037: PUSH
82038: LD_EXP 186
82042: PPUSH
82043: LD_VAR 0 1
82047: PPUSH
82048: EMPTY
82049: PPUSH
82050: CALL_OW 1
82054: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
82055: LD_ADDR_EXP 187
82059: PUSH
82060: LD_EXP 187
82064: PPUSH
82065: LD_VAR 0 1
82069: PPUSH
82070: EMPTY
82071: PPUSH
82072: CALL_OW 1
82076: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
82077: LD_ADDR_EXP 188
82081: PUSH
82082: LD_EXP 188
82086: PPUSH
82087: LD_VAR 0 1
82091: PPUSH
82092: EMPTY
82093: PPUSH
82094: CALL_OW 1
82098: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
82099: LD_ADDR_EXP 189
82103: PUSH
82104: LD_EXP 189
82108: PPUSH
82109: LD_VAR 0 1
82113: PPUSH
82114: EMPTY
82115: PPUSH
82116: CALL_OW 1
82120: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
82121: LD_ADDR_EXP 190
82125: PUSH
82126: LD_EXP 190
82130: PPUSH
82131: LD_VAR 0 1
82135: PPUSH
82136: EMPTY
82137: PPUSH
82138: CALL_OW 1
82142: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
82143: LD_ADDR_EXP 191
82147: PUSH
82148: LD_EXP 191
82152: PPUSH
82153: LD_VAR 0 1
82157: PPUSH
82158: EMPTY
82159: PPUSH
82160: CALL_OW 1
82164: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
82165: LD_ADDR_EXP 192
82169: PUSH
82170: LD_EXP 192
82174: PPUSH
82175: LD_VAR 0 1
82179: PPUSH
82180: EMPTY
82181: PPUSH
82182: CALL_OW 1
82186: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
82187: LD_ADDR_EXP 193
82191: PUSH
82192: LD_EXP 193
82196: PPUSH
82197: LD_VAR 0 1
82201: PPUSH
82202: EMPTY
82203: PPUSH
82204: CALL_OW 1
82208: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
82209: LD_ADDR_EXP 194
82213: PUSH
82214: LD_EXP 194
82218: PPUSH
82219: LD_VAR 0 1
82223: PPUSH
82224: EMPTY
82225: PPUSH
82226: CALL_OW 1
82230: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
82231: LD_ADDR_EXP 195
82235: PUSH
82236: LD_EXP 195
82240: PPUSH
82241: LD_VAR 0 1
82245: PPUSH
82246: EMPTY
82247: PPUSH
82248: CALL_OW 1
82252: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
82253: LD_ADDR_EXP 196
82257: PUSH
82258: LD_EXP 196
82262: PPUSH
82263: LD_VAR 0 1
82267: PPUSH
82268: EMPTY
82269: PPUSH
82270: CALL_OW 1
82274: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
82275: LD_ADDR_EXP 197
82279: PUSH
82280: LD_EXP 197
82284: PPUSH
82285: LD_VAR 0 1
82289: PPUSH
82290: EMPTY
82291: PPUSH
82292: CALL_OW 1
82296: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
82297: LD_ADDR_EXP 199
82301: PUSH
82302: LD_EXP 199
82306: PPUSH
82307: LD_VAR 0 1
82311: PPUSH
82312: EMPTY
82313: PPUSH
82314: CALL_OW 1
82318: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
82319: LD_ADDR_EXP 201
82323: PUSH
82324: LD_EXP 201
82328: PPUSH
82329: LD_VAR 0 1
82333: PPUSH
82334: EMPTY
82335: PPUSH
82336: CALL_OW 1
82340: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
82341: LD_ADDR_EXP 202
82345: PUSH
82346: LD_EXP 202
82350: PPUSH
82351: LD_VAR 0 1
82355: PPUSH
82356: EMPTY
82357: PPUSH
82358: CALL_OW 1
82362: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
82363: LD_ADDR_EXP 203
82367: PUSH
82368: LD_EXP 203
82372: PPUSH
82373: LD_VAR 0 1
82377: PPUSH
82378: EMPTY
82379: PPUSH
82380: CALL_OW 1
82384: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
82385: LD_ADDR_EXP 204
82389: PUSH
82390: LD_EXP 204
82394: PPUSH
82395: LD_VAR 0 1
82399: PPUSH
82400: EMPTY
82401: PPUSH
82402: CALL_OW 1
82406: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
82407: LD_ADDR_EXP 205
82411: PUSH
82412: LD_EXP 205
82416: PPUSH
82417: LD_VAR 0 1
82421: PPUSH
82422: EMPTY
82423: PPUSH
82424: CALL_OW 1
82428: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
82429: LD_ADDR_EXP 206
82433: PUSH
82434: LD_EXP 206
82438: PPUSH
82439: LD_VAR 0 1
82443: PPUSH
82444: EMPTY
82445: PPUSH
82446: CALL_OW 1
82450: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
82451: LD_ADDR_EXP 207
82455: PUSH
82456: LD_EXP 207
82460: PPUSH
82461: LD_VAR 0 1
82465: PPUSH
82466: EMPTY
82467: PPUSH
82468: CALL_OW 1
82472: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
82473: LD_ADDR_EXP 208
82477: PUSH
82478: LD_EXP 208
82482: PPUSH
82483: LD_VAR 0 1
82487: PPUSH
82488: EMPTY
82489: PPUSH
82490: CALL_OW 1
82494: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
82495: LD_ADDR_EXP 209
82499: PUSH
82500: LD_EXP 209
82504: PPUSH
82505: LD_VAR 0 1
82509: PPUSH
82510: EMPTY
82511: PPUSH
82512: CALL_OW 1
82516: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
82517: LD_ADDR_EXP 210
82521: PUSH
82522: LD_EXP 210
82526: PPUSH
82527: LD_VAR 0 1
82531: PPUSH
82532: EMPTY
82533: PPUSH
82534: CALL_OW 1
82538: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
82539: LD_ADDR_EXP 211
82543: PUSH
82544: LD_EXP 211
82548: PPUSH
82549: LD_VAR 0 1
82553: PPUSH
82554: EMPTY
82555: PPUSH
82556: CALL_OW 1
82560: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
82561: LD_ADDR_EXP 212
82565: PUSH
82566: LD_EXP 212
82570: PPUSH
82571: LD_VAR 0 1
82575: PPUSH
82576: EMPTY
82577: PPUSH
82578: CALL_OW 1
82582: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
82583: LD_ADDR_EXP 213
82587: PUSH
82588: LD_EXP 213
82592: PPUSH
82593: LD_VAR 0 1
82597: PPUSH
82598: EMPTY
82599: PPUSH
82600: CALL_OW 1
82604: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
82605: LD_ADDR_EXP 214
82609: PUSH
82610: LD_EXP 214
82614: PPUSH
82615: LD_VAR 0 1
82619: PPUSH
82620: LD_INT 0
82622: PPUSH
82623: CALL_OW 1
82627: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
82628: LD_ADDR_EXP 215
82632: PUSH
82633: LD_EXP 215
82637: PPUSH
82638: LD_VAR 0 1
82642: PPUSH
82643: LD_INT 0
82645: PPUSH
82646: CALL_OW 1
82650: ST_TO_ADDR
// end ;
82651: LD_VAR 0 2
82655: RET
// export function MC_Add ( side , units ) ; var base ; begin
82656: LD_INT 0
82658: PPUSH
82659: PPUSH
// base := mc_bases + 1 ;
82660: LD_ADDR_VAR 0 4
82664: PUSH
82665: LD_EXP 172
82669: PUSH
82670: LD_INT 1
82672: PLUS
82673: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
82674: LD_ADDR_EXP 198
82678: PUSH
82679: LD_EXP 198
82683: PPUSH
82684: LD_VAR 0 4
82688: PPUSH
82689: LD_VAR 0 1
82693: PPUSH
82694: CALL_OW 1
82698: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
82699: LD_ADDR_EXP 172
82703: PUSH
82704: LD_EXP 172
82708: PPUSH
82709: LD_VAR 0 4
82713: PPUSH
82714: LD_VAR 0 2
82718: PPUSH
82719: CALL_OW 1
82723: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
82724: LD_ADDR_EXP 173
82728: PUSH
82729: LD_EXP 173
82733: PPUSH
82734: LD_VAR 0 4
82738: PPUSH
82739: EMPTY
82740: PPUSH
82741: CALL_OW 1
82745: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
82746: LD_ADDR_EXP 174
82750: PUSH
82751: LD_EXP 174
82755: PPUSH
82756: LD_VAR 0 4
82760: PPUSH
82761: EMPTY
82762: PPUSH
82763: CALL_OW 1
82767: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
82768: LD_ADDR_EXP 175
82772: PUSH
82773: LD_EXP 175
82777: PPUSH
82778: LD_VAR 0 4
82782: PPUSH
82783: EMPTY
82784: PPUSH
82785: CALL_OW 1
82789: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
82790: LD_ADDR_EXP 176
82794: PUSH
82795: LD_EXP 176
82799: PPUSH
82800: LD_VAR 0 4
82804: PPUSH
82805: EMPTY
82806: PPUSH
82807: CALL_OW 1
82811: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
82812: LD_ADDR_EXP 177
82816: PUSH
82817: LD_EXP 177
82821: PPUSH
82822: LD_VAR 0 4
82826: PPUSH
82827: EMPTY
82828: PPUSH
82829: CALL_OW 1
82833: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
82834: LD_ADDR_EXP 178
82838: PUSH
82839: LD_EXP 178
82843: PPUSH
82844: LD_VAR 0 4
82848: PPUSH
82849: EMPTY
82850: PPUSH
82851: CALL_OW 1
82855: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
82856: LD_ADDR_EXP 179
82860: PUSH
82861: LD_EXP 179
82865: PPUSH
82866: LD_VAR 0 4
82870: PPUSH
82871: EMPTY
82872: PPUSH
82873: CALL_OW 1
82877: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
82878: LD_ADDR_EXP 180
82882: PUSH
82883: LD_EXP 180
82887: PPUSH
82888: LD_VAR 0 4
82892: PPUSH
82893: EMPTY
82894: PPUSH
82895: CALL_OW 1
82899: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
82900: LD_ADDR_EXP 181
82904: PUSH
82905: LD_EXP 181
82909: PPUSH
82910: LD_VAR 0 4
82914: PPUSH
82915: EMPTY
82916: PPUSH
82917: CALL_OW 1
82921: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
82922: LD_ADDR_EXP 182
82926: PUSH
82927: LD_EXP 182
82931: PPUSH
82932: LD_VAR 0 4
82936: PPUSH
82937: EMPTY
82938: PPUSH
82939: CALL_OW 1
82943: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
82944: LD_ADDR_EXP 183
82948: PUSH
82949: LD_EXP 183
82953: PPUSH
82954: LD_VAR 0 4
82958: PPUSH
82959: LD_INT 0
82961: PPUSH
82962: CALL_OW 1
82966: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
82967: LD_ADDR_EXP 184
82971: PUSH
82972: LD_EXP 184
82976: PPUSH
82977: LD_VAR 0 4
82981: PPUSH
82982: EMPTY
82983: PPUSH
82984: CALL_OW 1
82988: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
82989: LD_ADDR_EXP 185
82993: PUSH
82994: LD_EXP 185
82998: PPUSH
82999: LD_VAR 0 4
83003: PPUSH
83004: EMPTY
83005: PPUSH
83006: CALL_OW 1
83010: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
83011: LD_ADDR_EXP 186
83015: PUSH
83016: LD_EXP 186
83020: PPUSH
83021: LD_VAR 0 4
83025: PPUSH
83026: EMPTY
83027: PPUSH
83028: CALL_OW 1
83032: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
83033: LD_ADDR_EXP 187
83037: PUSH
83038: LD_EXP 187
83042: PPUSH
83043: LD_VAR 0 4
83047: PPUSH
83048: EMPTY
83049: PPUSH
83050: CALL_OW 1
83054: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
83055: LD_ADDR_EXP 188
83059: PUSH
83060: LD_EXP 188
83064: PPUSH
83065: LD_VAR 0 4
83069: PPUSH
83070: EMPTY
83071: PPUSH
83072: CALL_OW 1
83076: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
83077: LD_ADDR_EXP 189
83081: PUSH
83082: LD_EXP 189
83086: PPUSH
83087: LD_VAR 0 4
83091: PPUSH
83092: EMPTY
83093: PPUSH
83094: CALL_OW 1
83098: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
83099: LD_ADDR_EXP 190
83103: PUSH
83104: LD_EXP 190
83108: PPUSH
83109: LD_VAR 0 4
83113: PPUSH
83114: EMPTY
83115: PPUSH
83116: CALL_OW 1
83120: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
83121: LD_ADDR_EXP 191
83125: PUSH
83126: LD_EXP 191
83130: PPUSH
83131: LD_VAR 0 4
83135: PPUSH
83136: EMPTY
83137: PPUSH
83138: CALL_OW 1
83142: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
83143: LD_ADDR_EXP 192
83147: PUSH
83148: LD_EXP 192
83152: PPUSH
83153: LD_VAR 0 4
83157: PPUSH
83158: EMPTY
83159: PPUSH
83160: CALL_OW 1
83164: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
83165: LD_ADDR_EXP 193
83169: PUSH
83170: LD_EXP 193
83174: PPUSH
83175: LD_VAR 0 4
83179: PPUSH
83180: EMPTY
83181: PPUSH
83182: CALL_OW 1
83186: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
83187: LD_ADDR_EXP 194
83191: PUSH
83192: LD_EXP 194
83196: PPUSH
83197: LD_VAR 0 4
83201: PPUSH
83202: EMPTY
83203: PPUSH
83204: CALL_OW 1
83208: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
83209: LD_ADDR_EXP 195
83213: PUSH
83214: LD_EXP 195
83218: PPUSH
83219: LD_VAR 0 4
83223: PPUSH
83224: EMPTY
83225: PPUSH
83226: CALL_OW 1
83230: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
83231: LD_ADDR_EXP 196
83235: PUSH
83236: LD_EXP 196
83240: PPUSH
83241: LD_VAR 0 4
83245: PPUSH
83246: EMPTY
83247: PPUSH
83248: CALL_OW 1
83252: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
83253: LD_ADDR_EXP 197
83257: PUSH
83258: LD_EXP 197
83262: PPUSH
83263: LD_VAR 0 4
83267: PPUSH
83268: EMPTY
83269: PPUSH
83270: CALL_OW 1
83274: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
83275: LD_ADDR_EXP 199
83279: PUSH
83280: LD_EXP 199
83284: PPUSH
83285: LD_VAR 0 4
83289: PPUSH
83290: EMPTY
83291: PPUSH
83292: CALL_OW 1
83296: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
83297: LD_ADDR_EXP 201
83301: PUSH
83302: LD_EXP 201
83306: PPUSH
83307: LD_VAR 0 4
83311: PPUSH
83312: EMPTY
83313: PPUSH
83314: CALL_OW 1
83318: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
83319: LD_ADDR_EXP 202
83323: PUSH
83324: LD_EXP 202
83328: PPUSH
83329: LD_VAR 0 4
83333: PPUSH
83334: EMPTY
83335: PPUSH
83336: CALL_OW 1
83340: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
83341: LD_ADDR_EXP 203
83345: PUSH
83346: LD_EXP 203
83350: PPUSH
83351: LD_VAR 0 4
83355: PPUSH
83356: EMPTY
83357: PPUSH
83358: CALL_OW 1
83362: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
83363: LD_ADDR_EXP 204
83367: PUSH
83368: LD_EXP 204
83372: PPUSH
83373: LD_VAR 0 4
83377: PPUSH
83378: EMPTY
83379: PPUSH
83380: CALL_OW 1
83384: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
83385: LD_ADDR_EXP 205
83389: PUSH
83390: LD_EXP 205
83394: PPUSH
83395: LD_VAR 0 4
83399: PPUSH
83400: EMPTY
83401: PPUSH
83402: CALL_OW 1
83406: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
83407: LD_ADDR_EXP 206
83411: PUSH
83412: LD_EXP 206
83416: PPUSH
83417: LD_VAR 0 4
83421: PPUSH
83422: EMPTY
83423: PPUSH
83424: CALL_OW 1
83428: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
83429: LD_ADDR_EXP 207
83433: PUSH
83434: LD_EXP 207
83438: PPUSH
83439: LD_VAR 0 4
83443: PPUSH
83444: EMPTY
83445: PPUSH
83446: CALL_OW 1
83450: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
83451: LD_ADDR_EXP 208
83455: PUSH
83456: LD_EXP 208
83460: PPUSH
83461: LD_VAR 0 4
83465: PPUSH
83466: EMPTY
83467: PPUSH
83468: CALL_OW 1
83472: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
83473: LD_ADDR_EXP 209
83477: PUSH
83478: LD_EXP 209
83482: PPUSH
83483: LD_VAR 0 4
83487: PPUSH
83488: EMPTY
83489: PPUSH
83490: CALL_OW 1
83494: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
83495: LD_ADDR_EXP 210
83499: PUSH
83500: LD_EXP 210
83504: PPUSH
83505: LD_VAR 0 4
83509: PPUSH
83510: EMPTY
83511: PPUSH
83512: CALL_OW 1
83516: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
83517: LD_ADDR_EXP 211
83521: PUSH
83522: LD_EXP 211
83526: PPUSH
83527: LD_VAR 0 4
83531: PPUSH
83532: EMPTY
83533: PPUSH
83534: CALL_OW 1
83538: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
83539: LD_ADDR_EXP 212
83543: PUSH
83544: LD_EXP 212
83548: PPUSH
83549: LD_VAR 0 4
83553: PPUSH
83554: EMPTY
83555: PPUSH
83556: CALL_OW 1
83560: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
83561: LD_ADDR_EXP 213
83565: PUSH
83566: LD_EXP 213
83570: PPUSH
83571: LD_VAR 0 4
83575: PPUSH
83576: EMPTY
83577: PPUSH
83578: CALL_OW 1
83582: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
83583: LD_ADDR_EXP 214
83587: PUSH
83588: LD_EXP 214
83592: PPUSH
83593: LD_VAR 0 4
83597: PPUSH
83598: LD_INT 0
83600: PPUSH
83601: CALL_OW 1
83605: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
83606: LD_ADDR_EXP 215
83610: PUSH
83611: LD_EXP 215
83615: PPUSH
83616: LD_VAR 0 4
83620: PPUSH
83621: LD_INT 0
83623: PPUSH
83624: CALL_OW 1
83628: ST_TO_ADDR
// result := base ;
83629: LD_ADDR_VAR 0 3
83633: PUSH
83634: LD_VAR 0 4
83638: ST_TO_ADDR
// end ;
83639: LD_VAR 0 3
83643: RET
// export function MC_Start ( ) ; var i ; begin
83644: LD_INT 0
83646: PPUSH
83647: PPUSH
// for i = 1 to mc_bases do
83648: LD_ADDR_VAR 0 2
83652: PUSH
83653: DOUBLE
83654: LD_INT 1
83656: DEC
83657: ST_TO_ADDR
83658: LD_EXP 172
83662: PUSH
83663: FOR_TO
83664: IFFALSE 84741
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
83666: LD_ADDR_EXP 172
83670: PUSH
83671: LD_EXP 172
83675: PPUSH
83676: LD_VAR 0 2
83680: PPUSH
83681: LD_EXP 172
83685: PUSH
83686: LD_VAR 0 2
83690: ARRAY
83691: PUSH
83692: LD_INT 0
83694: DIFF
83695: PPUSH
83696: CALL_OW 1
83700: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
83701: LD_ADDR_EXP 173
83705: PUSH
83706: LD_EXP 173
83710: PPUSH
83711: LD_VAR 0 2
83715: PPUSH
83716: EMPTY
83717: PPUSH
83718: CALL_OW 1
83722: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
83723: LD_ADDR_EXP 174
83727: PUSH
83728: LD_EXP 174
83732: PPUSH
83733: LD_VAR 0 2
83737: PPUSH
83738: EMPTY
83739: PPUSH
83740: CALL_OW 1
83744: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
83745: LD_ADDR_EXP 175
83749: PUSH
83750: LD_EXP 175
83754: PPUSH
83755: LD_VAR 0 2
83759: PPUSH
83760: EMPTY
83761: PPUSH
83762: CALL_OW 1
83766: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
83767: LD_ADDR_EXP 176
83771: PUSH
83772: LD_EXP 176
83776: PPUSH
83777: LD_VAR 0 2
83781: PPUSH
83782: EMPTY
83783: PUSH
83784: EMPTY
83785: PUSH
83786: EMPTY
83787: LIST
83788: LIST
83789: PPUSH
83790: CALL_OW 1
83794: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
83795: LD_ADDR_EXP 177
83799: PUSH
83800: LD_EXP 177
83804: PPUSH
83805: LD_VAR 0 2
83809: PPUSH
83810: EMPTY
83811: PPUSH
83812: CALL_OW 1
83816: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
83817: LD_ADDR_EXP 204
83821: PUSH
83822: LD_EXP 204
83826: PPUSH
83827: LD_VAR 0 2
83831: PPUSH
83832: EMPTY
83833: PPUSH
83834: CALL_OW 1
83838: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
83839: LD_ADDR_EXP 178
83843: PUSH
83844: LD_EXP 178
83848: PPUSH
83849: LD_VAR 0 2
83853: PPUSH
83854: EMPTY
83855: PPUSH
83856: CALL_OW 1
83860: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
83861: LD_ADDR_EXP 179
83865: PUSH
83866: LD_EXP 179
83870: PPUSH
83871: LD_VAR 0 2
83875: PPUSH
83876: EMPTY
83877: PPUSH
83878: CALL_OW 1
83882: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
83883: LD_ADDR_EXP 180
83887: PUSH
83888: LD_EXP 180
83892: PPUSH
83893: LD_VAR 0 2
83897: PPUSH
83898: LD_EXP 172
83902: PUSH
83903: LD_VAR 0 2
83907: ARRAY
83908: PPUSH
83909: LD_INT 2
83911: PUSH
83912: LD_INT 30
83914: PUSH
83915: LD_INT 32
83917: PUSH
83918: EMPTY
83919: LIST
83920: LIST
83921: PUSH
83922: LD_INT 30
83924: PUSH
83925: LD_INT 33
83927: PUSH
83928: EMPTY
83929: LIST
83930: LIST
83931: PUSH
83932: EMPTY
83933: LIST
83934: LIST
83935: LIST
83936: PPUSH
83937: CALL_OW 72
83941: PPUSH
83942: CALL_OW 1
83946: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
83947: LD_ADDR_EXP 181
83951: PUSH
83952: LD_EXP 181
83956: PPUSH
83957: LD_VAR 0 2
83961: PPUSH
83962: LD_EXP 172
83966: PUSH
83967: LD_VAR 0 2
83971: ARRAY
83972: PPUSH
83973: LD_INT 2
83975: PUSH
83976: LD_INT 30
83978: PUSH
83979: LD_INT 32
83981: PUSH
83982: EMPTY
83983: LIST
83984: LIST
83985: PUSH
83986: LD_INT 30
83988: PUSH
83989: LD_INT 31
83991: PUSH
83992: EMPTY
83993: LIST
83994: LIST
83995: PUSH
83996: EMPTY
83997: LIST
83998: LIST
83999: LIST
84000: PUSH
84001: LD_INT 58
84003: PUSH
84004: EMPTY
84005: LIST
84006: PUSH
84007: EMPTY
84008: LIST
84009: LIST
84010: PPUSH
84011: CALL_OW 72
84015: PPUSH
84016: CALL_OW 1
84020: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
84021: LD_ADDR_EXP 182
84025: PUSH
84026: LD_EXP 182
84030: PPUSH
84031: LD_VAR 0 2
84035: PPUSH
84036: EMPTY
84037: PPUSH
84038: CALL_OW 1
84042: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
84043: LD_ADDR_EXP 186
84047: PUSH
84048: LD_EXP 186
84052: PPUSH
84053: LD_VAR 0 2
84057: PPUSH
84058: EMPTY
84059: PPUSH
84060: CALL_OW 1
84064: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
84065: LD_ADDR_EXP 185
84069: PUSH
84070: LD_EXP 185
84074: PPUSH
84075: LD_VAR 0 2
84079: PPUSH
84080: EMPTY
84081: PPUSH
84082: CALL_OW 1
84086: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
84087: LD_ADDR_EXP 187
84091: PUSH
84092: LD_EXP 187
84096: PPUSH
84097: LD_VAR 0 2
84101: PPUSH
84102: EMPTY
84103: PPUSH
84104: CALL_OW 1
84108: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
84109: LD_ADDR_EXP 188
84113: PUSH
84114: LD_EXP 188
84118: PPUSH
84119: LD_VAR 0 2
84123: PPUSH
84124: EMPTY
84125: PPUSH
84126: CALL_OW 1
84130: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
84131: LD_ADDR_EXP 189
84135: PUSH
84136: LD_EXP 189
84140: PPUSH
84141: LD_VAR 0 2
84145: PPUSH
84146: EMPTY
84147: PPUSH
84148: CALL_OW 1
84152: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
84153: LD_ADDR_EXP 190
84157: PUSH
84158: LD_EXP 190
84162: PPUSH
84163: LD_VAR 0 2
84167: PPUSH
84168: EMPTY
84169: PPUSH
84170: CALL_OW 1
84174: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
84175: LD_ADDR_EXP 191
84179: PUSH
84180: LD_EXP 191
84184: PPUSH
84185: LD_VAR 0 2
84189: PPUSH
84190: EMPTY
84191: PPUSH
84192: CALL_OW 1
84196: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
84197: LD_ADDR_EXP 192
84201: PUSH
84202: LD_EXP 192
84206: PPUSH
84207: LD_VAR 0 2
84211: PPUSH
84212: EMPTY
84213: PPUSH
84214: CALL_OW 1
84218: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
84219: LD_ADDR_EXP 193
84223: PUSH
84224: LD_EXP 193
84228: PPUSH
84229: LD_VAR 0 2
84233: PPUSH
84234: EMPTY
84235: PPUSH
84236: CALL_OW 1
84240: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
84241: LD_ADDR_EXP 194
84245: PUSH
84246: LD_EXP 194
84250: PPUSH
84251: LD_VAR 0 2
84255: PPUSH
84256: EMPTY
84257: PPUSH
84258: CALL_OW 1
84262: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
84263: LD_ADDR_EXP 183
84267: PUSH
84268: LD_EXP 183
84272: PPUSH
84273: LD_VAR 0 2
84277: PPUSH
84278: LD_INT 0
84280: PPUSH
84281: CALL_OW 1
84285: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
84286: LD_ADDR_EXP 196
84290: PUSH
84291: LD_EXP 196
84295: PPUSH
84296: LD_VAR 0 2
84300: PPUSH
84301: LD_INT 0
84303: PPUSH
84304: CALL_OW 1
84308: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
84309: LD_ADDR_EXP 184
84313: PUSH
84314: LD_EXP 184
84318: PPUSH
84319: LD_VAR 0 2
84323: PPUSH
84324: EMPTY
84325: PPUSH
84326: CALL_OW 1
84330: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
84331: LD_ADDR_EXP 195
84335: PUSH
84336: LD_EXP 195
84340: PPUSH
84341: LD_VAR 0 2
84345: PPUSH
84346: LD_INT 0
84348: PPUSH
84349: CALL_OW 1
84353: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
84354: LD_ADDR_EXP 197
84358: PUSH
84359: LD_EXP 197
84363: PPUSH
84364: LD_VAR 0 2
84368: PPUSH
84369: EMPTY
84370: PPUSH
84371: CALL_OW 1
84375: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
84376: LD_ADDR_EXP 200
84380: PUSH
84381: LD_EXP 200
84385: PPUSH
84386: LD_VAR 0 2
84390: PPUSH
84391: LD_INT 0
84393: PPUSH
84394: CALL_OW 1
84398: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
84399: LD_ADDR_EXP 201
84403: PUSH
84404: LD_EXP 201
84408: PPUSH
84409: LD_VAR 0 2
84413: PPUSH
84414: EMPTY
84415: PPUSH
84416: CALL_OW 1
84420: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
84421: LD_ADDR_EXP 202
84425: PUSH
84426: LD_EXP 202
84430: PPUSH
84431: LD_VAR 0 2
84435: PPUSH
84436: EMPTY
84437: PPUSH
84438: CALL_OW 1
84442: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
84443: LD_ADDR_EXP 203
84447: PUSH
84448: LD_EXP 203
84452: PPUSH
84453: LD_VAR 0 2
84457: PPUSH
84458: EMPTY
84459: PPUSH
84460: CALL_OW 1
84464: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
84465: LD_ADDR_EXP 205
84469: PUSH
84470: LD_EXP 205
84474: PPUSH
84475: LD_VAR 0 2
84479: PPUSH
84480: LD_EXP 172
84484: PUSH
84485: LD_VAR 0 2
84489: ARRAY
84490: PPUSH
84491: LD_INT 2
84493: PUSH
84494: LD_INT 30
84496: PUSH
84497: LD_INT 6
84499: PUSH
84500: EMPTY
84501: LIST
84502: LIST
84503: PUSH
84504: LD_INT 30
84506: PUSH
84507: LD_INT 7
84509: PUSH
84510: EMPTY
84511: LIST
84512: LIST
84513: PUSH
84514: LD_INT 30
84516: PUSH
84517: LD_INT 8
84519: PUSH
84520: EMPTY
84521: LIST
84522: LIST
84523: PUSH
84524: EMPTY
84525: LIST
84526: LIST
84527: LIST
84528: LIST
84529: PPUSH
84530: CALL_OW 72
84534: PPUSH
84535: CALL_OW 1
84539: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
84540: LD_ADDR_EXP 206
84544: PUSH
84545: LD_EXP 206
84549: PPUSH
84550: LD_VAR 0 2
84554: PPUSH
84555: EMPTY
84556: PPUSH
84557: CALL_OW 1
84561: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
84562: LD_ADDR_EXP 207
84566: PUSH
84567: LD_EXP 207
84571: PPUSH
84572: LD_VAR 0 2
84576: PPUSH
84577: EMPTY
84578: PPUSH
84579: CALL_OW 1
84583: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
84584: LD_ADDR_EXP 208
84588: PUSH
84589: LD_EXP 208
84593: PPUSH
84594: LD_VAR 0 2
84598: PPUSH
84599: EMPTY
84600: PPUSH
84601: CALL_OW 1
84605: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
84606: LD_ADDR_EXP 209
84610: PUSH
84611: LD_EXP 209
84615: PPUSH
84616: LD_VAR 0 2
84620: PPUSH
84621: EMPTY
84622: PPUSH
84623: CALL_OW 1
84627: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
84628: LD_ADDR_EXP 210
84632: PUSH
84633: LD_EXP 210
84637: PPUSH
84638: LD_VAR 0 2
84642: PPUSH
84643: EMPTY
84644: PPUSH
84645: CALL_OW 1
84649: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
84650: LD_ADDR_EXP 211
84654: PUSH
84655: LD_EXP 211
84659: PPUSH
84660: LD_VAR 0 2
84664: PPUSH
84665: EMPTY
84666: PPUSH
84667: CALL_OW 1
84671: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
84672: LD_ADDR_EXP 212
84676: PUSH
84677: LD_EXP 212
84681: PPUSH
84682: LD_VAR 0 2
84686: PPUSH
84687: EMPTY
84688: PPUSH
84689: CALL_OW 1
84693: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
84694: LD_ADDR_EXP 213
84698: PUSH
84699: LD_EXP 213
84703: PPUSH
84704: LD_VAR 0 2
84708: PPUSH
84709: EMPTY
84710: PPUSH
84711: CALL_OW 1
84715: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
84716: LD_ADDR_EXP 214
84720: PUSH
84721: LD_EXP 214
84725: PPUSH
84726: LD_VAR 0 2
84730: PPUSH
84731: LD_INT 0
84733: PPUSH
84734: CALL_OW 1
84738: ST_TO_ADDR
// end ;
84739: GO 83663
84741: POP
84742: POP
// MC_InitSides ( ) ;
84743: CALL 85029 0 0
// MC_InitResearch ( ) ;
84747: CALL 84768 0 0
// CustomInitMacro ( ) ;
84751: CALL 350 0 0
// skirmish := true ;
84755: LD_ADDR_EXP 170
84759: PUSH
84760: LD_INT 1
84762: ST_TO_ADDR
// end ;
84763: LD_VAR 0 1
84767: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
84768: LD_INT 0
84770: PPUSH
84771: PPUSH
84772: PPUSH
84773: PPUSH
84774: PPUSH
84775: PPUSH
// if not mc_bases then
84776: LD_EXP 172
84780: NOT
84781: IFFALSE 84785
// exit ;
84783: GO 85024
// for i = 1 to 8 do
84785: LD_ADDR_VAR 0 2
84789: PUSH
84790: DOUBLE
84791: LD_INT 1
84793: DEC
84794: ST_TO_ADDR
84795: LD_INT 8
84797: PUSH
84798: FOR_TO
84799: IFFALSE 84825
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
84801: LD_ADDR_EXP 199
84805: PUSH
84806: LD_EXP 199
84810: PPUSH
84811: LD_VAR 0 2
84815: PPUSH
84816: EMPTY
84817: PPUSH
84818: CALL_OW 1
84822: ST_TO_ADDR
84823: GO 84798
84825: POP
84826: POP
// tmp := [ ] ;
84827: LD_ADDR_VAR 0 5
84831: PUSH
84832: EMPTY
84833: ST_TO_ADDR
// for i = 1 to mc_sides do
84834: LD_ADDR_VAR 0 2
84838: PUSH
84839: DOUBLE
84840: LD_INT 1
84842: DEC
84843: ST_TO_ADDR
84844: LD_EXP 198
84848: PUSH
84849: FOR_TO
84850: IFFALSE 84908
// if not mc_sides [ i ] in tmp then
84852: LD_EXP 198
84856: PUSH
84857: LD_VAR 0 2
84861: ARRAY
84862: PUSH
84863: LD_VAR 0 5
84867: IN
84868: NOT
84869: IFFALSE 84906
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
84871: LD_ADDR_VAR 0 5
84875: PUSH
84876: LD_VAR 0 5
84880: PPUSH
84881: LD_VAR 0 5
84885: PUSH
84886: LD_INT 1
84888: PLUS
84889: PPUSH
84890: LD_EXP 198
84894: PUSH
84895: LD_VAR 0 2
84899: ARRAY
84900: PPUSH
84901: CALL_OW 2
84905: ST_TO_ADDR
84906: GO 84849
84908: POP
84909: POP
// if not tmp then
84910: LD_VAR 0 5
84914: NOT
84915: IFFALSE 84919
// exit ;
84917: GO 85024
// for j in tmp do
84919: LD_ADDR_VAR 0 3
84923: PUSH
84924: LD_VAR 0 5
84928: PUSH
84929: FOR_IN
84930: IFFALSE 85022
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
84932: LD_ADDR_VAR 0 6
84936: PUSH
84937: LD_INT 22
84939: PUSH
84940: LD_VAR 0 3
84944: PUSH
84945: EMPTY
84946: LIST
84947: LIST
84948: PPUSH
84949: CALL_OW 69
84953: ST_TO_ADDR
// if not un then
84954: LD_VAR 0 6
84958: NOT
84959: IFFALSE 84963
// continue ;
84961: GO 84929
// nation := GetNation ( un [ 1 ] ) ;
84963: LD_ADDR_VAR 0 4
84967: PUSH
84968: LD_VAR 0 6
84972: PUSH
84973: LD_INT 1
84975: ARRAY
84976: PPUSH
84977: CALL_OW 248
84981: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
84982: LD_ADDR_EXP 199
84986: PUSH
84987: LD_EXP 199
84991: PPUSH
84992: LD_VAR 0 3
84996: PPUSH
84997: LD_VAR 0 3
85001: PPUSH
85002: LD_VAR 0 4
85006: PPUSH
85007: LD_INT 1
85009: PPUSH
85010: CALL 19213 0 3
85014: PPUSH
85015: CALL_OW 1
85019: ST_TO_ADDR
// end ;
85020: GO 84929
85022: POP
85023: POP
// end ;
85024: LD_VAR 0 1
85028: RET
// export function MC_InitSides ( ) ; var i ; begin
85029: LD_INT 0
85031: PPUSH
85032: PPUSH
// if not mc_bases then
85033: LD_EXP 172
85037: NOT
85038: IFFALSE 85042
// exit ;
85040: GO 85116
// for i = 1 to mc_bases do
85042: LD_ADDR_VAR 0 2
85046: PUSH
85047: DOUBLE
85048: LD_INT 1
85050: DEC
85051: ST_TO_ADDR
85052: LD_EXP 172
85056: PUSH
85057: FOR_TO
85058: IFFALSE 85114
// if mc_bases [ i ] then
85060: LD_EXP 172
85064: PUSH
85065: LD_VAR 0 2
85069: ARRAY
85070: IFFALSE 85112
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
85072: LD_ADDR_EXP 198
85076: PUSH
85077: LD_EXP 198
85081: PPUSH
85082: LD_VAR 0 2
85086: PPUSH
85087: LD_EXP 172
85091: PUSH
85092: LD_VAR 0 2
85096: ARRAY
85097: PUSH
85098: LD_INT 1
85100: ARRAY
85101: PPUSH
85102: CALL_OW 255
85106: PPUSH
85107: CALL_OW 1
85111: ST_TO_ADDR
85112: GO 85057
85114: POP
85115: POP
// end ;
85116: LD_VAR 0 1
85120: RET
// every 0 0$03 trigger skirmish do
85121: LD_EXP 170
85125: IFFALSE 85279
85127: GO 85129
85129: DISABLE
// begin enable ;
85130: ENABLE
// MC_CheckBuildings ( ) ;
85131: CALL 89777 0 0
// MC_CheckPeopleLife ( ) ;
85135: CALL 89902 0 0
// RaiseSailEvent ( 100 ) ;
85139: LD_INT 100
85141: PPUSH
85142: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
85146: LD_INT 103
85148: PPUSH
85149: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
85153: LD_INT 104
85155: PPUSH
85156: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
85160: LD_INT 105
85162: PPUSH
85163: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
85167: LD_INT 106
85169: PPUSH
85170: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
85174: LD_INT 107
85176: PPUSH
85177: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
85181: LD_INT 108
85183: PPUSH
85184: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
85188: LD_INT 109
85190: PPUSH
85191: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
85195: LD_INT 110
85197: PPUSH
85198: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
85202: LD_INT 111
85204: PPUSH
85205: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
85209: LD_INT 112
85211: PPUSH
85212: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
85216: LD_INT 113
85218: PPUSH
85219: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
85223: LD_INT 120
85225: PPUSH
85226: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
85230: LD_INT 121
85232: PPUSH
85233: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
85237: LD_INT 122
85239: PPUSH
85240: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
85244: LD_INT 123
85246: PPUSH
85247: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
85251: LD_INT 124
85253: PPUSH
85254: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
85258: LD_INT 125
85260: PPUSH
85261: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
85265: LD_INT 126
85267: PPUSH
85268: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
85272: LD_INT 200
85274: PPUSH
85275: CALL_OW 427
// end ;
85279: END
// on SailEvent ( event ) do begin if event < 100 then
85280: LD_VAR 0 1
85284: PUSH
85285: LD_INT 100
85287: LESS
85288: IFFALSE 85299
// CustomEvent ( event ) ;
85290: LD_VAR 0 1
85294: PPUSH
85295: CALL 16084 0 1
// if event = 100 then
85299: LD_VAR 0 1
85303: PUSH
85304: LD_INT 100
85306: EQUAL
85307: IFFALSE 85313
// MC_ClassManager ( ) ;
85309: CALL 85705 0 0
// if event = 101 then
85313: LD_VAR 0 1
85317: PUSH
85318: LD_INT 101
85320: EQUAL
85321: IFFALSE 85327
// MC_RepairBuildings ( ) ;
85323: CALL 90487 0 0
// if event = 102 then
85327: LD_VAR 0 1
85331: PUSH
85332: LD_INT 102
85334: EQUAL
85335: IFFALSE 85341
// MC_Heal ( ) ;
85337: CALL 91372 0 0
// if event = 103 then
85341: LD_VAR 0 1
85345: PUSH
85346: LD_INT 103
85348: EQUAL
85349: IFFALSE 85355
// MC_Build ( ) ;
85351: CALL 91794 0 0
// if event = 104 then
85355: LD_VAR 0 1
85359: PUSH
85360: LD_INT 104
85362: EQUAL
85363: IFFALSE 85369
// MC_TurretWeapon ( ) ;
85365: CALL 93435 0 0
// if event = 105 then
85369: LD_VAR 0 1
85373: PUSH
85374: LD_INT 105
85376: EQUAL
85377: IFFALSE 85383
// MC_BuildUpgrade ( ) ;
85379: CALL 92986 0 0
// if event = 106 then
85383: LD_VAR 0 1
85387: PUSH
85388: LD_INT 106
85390: EQUAL
85391: IFFALSE 85397
// MC_PlantMines ( ) ;
85393: CALL 93865 0 0
// if event = 107 then
85397: LD_VAR 0 1
85401: PUSH
85402: LD_INT 107
85404: EQUAL
85405: IFFALSE 85411
// MC_CollectCrates ( ) ;
85407: CALL 94656 0 0
// if event = 108 then
85411: LD_VAR 0 1
85415: PUSH
85416: LD_INT 108
85418: EQUAL
85419: IFFALSE 85425
// MC_LinkRemoteControl ( ) ;
85421: CALL 96432 0 0
// if event = 109 then
85425: LD_VAR 0 1
85429: PUSH
85430: LD_INT 109
85432: EQUAL
85433: IFFALSE 85439
// MC_ProduceVehicle ( ) ;
85435: CALL 96613 0 0
// if event = 110 then
85439: LD_VAR 0 1
85443: PUSH
85444: LD_INT 110
85446: EQUAL
85447: IFFALSE 85453
// MC_SendAttack ( ) ;
85449: CALL 97079 0 0
// if event = 111 then
85453: LD_VAR 0 1
85457: PUSH
85458: LD_INT 111
85460: EQUAL
85461: IFFALSE 85467
// MC_Defend ( ) ;
85463: CALL 97187 0 0
// if event = 112 then
85467: LD_VAR 0 1
85471: PUSH
85472: LD_INT 112
85474: EQUAL
85475: IFFALSE 85481
// MC_Research ( ) ;
85477: CALL 97909 0 0
// if event = 113 then
85481: LD_VAR 0 1
85485: PUSH
85486: LD_INT 113
85488: EQUAL
85489: IFFALSE 85495
// MC_MinesTrigger ( ) ;
85491: CALL 99023 0 0
// if event = 120 then
85495: LD_VAR 0 1
85499: PUSH
85500: LD_INT 120
85502: EQUAL
85503: IFFALSE 85509
// MC_RepairVehicle ( ) ;
85505: CALL 99122 0 0
// if event = 121 then
85509: LD_VAR 0 1
85513: PUSH
85514: LD_INT 121
85516: EQUAL
85517: IFFALSE 85523
// MC_TameApe ( ) ;
85519: CALL 99852 0 0
// if event = 122 then
85523: LD_VAR 0 1
85527: PUSH
85528: LD_INT 122
85530: EQUAL
85531: IFFALSE 85537
// MC_ChangeApeClass ( ) ;
85533: CALL 100681 0 0
// if event = 123 then
85537: LD_VAR 0 1
85541: PUSH
85542: LD_INT 123
85544: EQUAL
85545: IFFALSE 85551
// MC_Bazooka ( ) ;
85547: CALL 101331 0 0
// if event = 124 then
85551: LD_VAR 0 1
85555: PUSH
85556: LD_INT 124
85558: EQUAL
85559: IFFALSE 85565
// MC_TeleportExit ( ) ;
85561: CALL 101529 0 0
// if event = 125 then
85565: LD_VAR 0 1
85569: PUSH
85570: LD_INT 125
85572: EQUAL
85573: IFFALSE 85579
// MC_Deposits ( ) ;
85575: CALL 102176 0 0
// if event = 126 then
85579: LD_VAR 0 1
85583: PUSH
85584: LD_INT 126
85586: EQUAL
85587: IFFALSE 85593
// MC_RemoteDriver ( ) ;
85589: CALL 102801 0 0
// if event = 200 then
85593: LD_VAR 0 1
85597: PUSH
85598: LD_INT 200
85600: EQUAL
85601: IFFALSE 85607
// MC_Idle ( ) ;
85603: CALL 104750 0 0
// end ;
85607: PPOPN 1
85609: END
// export function MC_Reset ( base , tag ) ; var i ; begin
85610: LD_INT 0
85612: PPUSH
85613: PPUSH
// if not mc_bases [ base ] or not tag then
85614: LD_EXP 172
85618: PUSH
85619: LD_VAR 0 1
85623: ARRAY
85624: NOT
85625: PUSH
85626: LD_VAR 0 2
85630: NOT
85631: OR
85632: IFFALSE 85636
// exit ;
85634: GO 85700
// for i in mc_bases [ base ] union mc_ape [ base ] do
85636: LD_ADDR_VAR 0 4
85640: PUSH
85641: LD_EXP 172
85645: PUSH
85646: LD_VAR 0 1
85650: ARRAY
85651: PUSH
85652: LD_EXP 201
85656: PUSH
85657: LD_VAR 0 1
85661: ARRAY
85662: UNION
85663: PUSH
85664: FOR_IN
85665: IFFALSE 85698
// if GetTag ( i ) = tag then
85667: LD_VAR 0 4
85671: PPUSH
85672: CALL_OW 110
85676: PUSH
85677: LD_VAR 0 2
85681: EQUAL
85682: IFFALSE 85696
// SetTag ( i , 0 ) ;
85684: LD_VAR 0 4
85688: PPUSH
85689: LD_INT 0
85691: PPUSH
85692: CALL_OW 109
85696: GO 85664
85698: POP
85699: POP
// end ;
85700: LD_VAR 0 3
85704: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
85705: LD_INT 0
85707: PPUSH
85708: PPUSH
85709: PPUSH
85710: PPUSH
85711: PPUSH
85712: PPUSH
85713: PPUSH
85714: PPUSH
// if not mc_bases then
85715: LD_EXP 172
85719: NOT
85720: IFFALSE 85724
// exit ;
85722: GO 86182
// for i = 1 to mc_bases do
85724: LD_ADDR_VAR 0 2
85728: PUSH
85729: DOUBLE
85730: LD_INT 1
85732: DEC
85733: ST_TO_ADDR
85734: LD_EXP 172
85738: PUSH
85739: FOR_TO
85740: IFFALSE 86180
// begin tmp := MC_ClassCheckReq ( i ) ;
85742: LD_ADDR_VAR 0 4
85746: PUSH
85747: LD_VAR 0 2
85751: PPUSH
85752: CALL 86187 0 1
85756: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
85757: LD_ADDR_EXP 213
85761: PUSH
85762: LD_EXP 213
85766: PPUSH
85767: LD_VAR 0 2
85771: PPUSH
85772: LD_VAR 0 4
85776: PPUSH
85777: CALL_OW 1
85781: ST_TO_ADDR
// if not tmp then
85782: LD_VAR 0 4
85786: NOT
85787: IFFALSE 85791
// continue ;
85789: GO 85739
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
85791: LD_ADDR_VAR 0 6
85795: PUSH
85796: LD_EXP 172
85800: PUSH
85801: LD_VAR 0 2
85805: ARRAY
85806: PPUSH
85807: LD_INT 2
85809: PUSH
85810: LD_INT 30
85812: PUSH
85813: LD_INT 4
85815: PUSH
85816: EMPTY
85817: LIST
85818: LIST
85819: PUSH
85820: LD_INT 30
85822: PUSH
85823: LD_INT 5
85825: PUSH
85826: EMPTY
85827: LIST
85828: LIST
85829: PUSH
85830: EMPTY
85831: LIST
85832: LIST
85833: LIST
85834: PPUSH
85835: CALL_OW 72
85839: PUSH
85840: LD_EXP 172
85844: PUSH
85845: LD_VAR 0 2
85849: ARRAY
85850: PPUSH
85851: LD_INT 2
85853: PUSH
85854: LD_INT 30
85856: PUSH
85857: LD_INT 0
85859: PUSH
85860: EMPTY
85861: LIST
85862: LIST
85863: PUSH
85864: LD_INT 30
85866: PUSH
85867: LD_INT 1
85869: PUSH
85870: EMPTY
85871: LIST
85872: LIST
85873: PUSH
85874: EMPTY
85875: LIST
85876: LIST
85877: LIST
85878: PPUSH
85879: CALL_OW 72
85883: PUSH
85884: LD_EXP 172
85888: PUSH
85889: LD_VAR 0 2
85893: ARRAY
85894: PPUSH
85895: LD_INT 30
85897: PUSH
85898: LD_INT 3
85900: PUSH
85901: EMPTY
85902: LIST
85903: LIST
85904: PPUSH
85905: CALL_OW 72
85909: PUSH
85910: LD_EXP 172
85914: PUSH
85915: LD_VAR 0 2
85919: ARRAY
85920: PPUSH
85921: LD_INT 2
85923: PUSH
85924: LD_INT 30
85926: PUSH
85927: LD_INT 6
85929: PUSH
85930: EMPTY
85931: LIST
85932: LIST
85933: PUSH
85934: LD_INT 30
85936: PUSH
85937: LD_INT 7
85939: PUSH
85940: EMPTY
85941: LIST
85942: LIST
85943: PUSH
85944: LD_INT 30
85946: PUSH
85947: LD_INT 8
85949: PUSH
85950: EMPTY
85951: LIST
85952: LIST
85953: PUSH
85954: EMPTY
85955: LIST
85956: LIST
85957: LIST
85958: LIST
85959: PPUSH
85960: CALL_OW 72
85964: PUSH
85965: EMPTY
85966: LIST
85967: LIST
85968: LIST
85969: LIST
85970: ST_TO_ADDR
// for j = 1 to 4 do
85971: LD_ADDR_VAR 0 3
85975: PUSH
85976: DOUBLE
85977: LD_INT 1
85979: DEC
85980: ST_TO_ADDR
85981: LD_INT 4
85983: PUSH
85984: FOR_TO
85985: IFFALSE 86176
// begin if not tmp [ j ] then
85987: LD_VAR 0 4
85991: PUSH
85992: LD_VAR 0 3
85996: ARRAY
85997: NOT
85998: IFFALSE 86002
// continue ;
86000: GO 85984
// for p in tmp [ j ] do
86002: LD_ADDR_VAR 0 5
86006: PUSH
86007: LD_VAR 0 4
86011: PUSH
86012: LD_VAR 0 3
86016: ARRAY
86017: PUSH
86018: FOR_IN
86019: IFFALSE 86172
// begin if not b [ j ] then
86021: LD_VAR 0 6
86025: PUSH
86026: LD_VAR 0 3
86030: ARRAY
86031: NOT
86032: IFFALSE 86036
// break ;
86034: GO 86172
// e := 0 ;
86036: LD_ADDR_VAR 0 7
86040: PUSH
86041: LD_INT 0
86043: ST_TO_ADDR
// for k in b [ j ] do
86044: LD_ADDR_VAR 0 8
86048: PUSH
86049: LD_VAR 0 6
86053: PUSH
86054: LD_VAR 0 3
86058: ARRAY
86059: PUSH
86060: FOR_IN
86061: IFFALSE 86088
// if IsNotFull ( k ) then
86063: LD_VAR 0 8
86067: PPUSH
86068: CALL 21362 0 1
86072: IFFALSE 86086
// begin e := k ;
86074: LD_ADDR_VAR 0 7
86078: PUSH
86079: LD_VAR 0 8
86083: ST_TO_ADDR
// break ;
86084: GO 86088
// end ;
86086: GO 86060
86088: POP
86089: POP
// if e and not UnitGoingToBuilding ( p , e ) then
86090: LD_VAR 0 7
86094: PUSH
86095: LD_VAR 0 5
86099: PPUSH
86100: LD_VAR 0 7
86104: PPUSH
86105: CALL 54115 0 2
86109: NOT
86110: AND
86111: IFFALSE 86170
// begin if IsInUnit ( p ) then
86113: LD_VAR 0 5
86117: PPUSH
86118: CALL_OW 310
86122: IFFALSE 86133
// ComExitBuilding ( p ) ;
86124: LD_VAR 0 5
86128: PPUSH
86129: CALL_OW 122
// ComEnterUnit ( p , e ) ;
86133: LD_VAR 0 5
86137: PPUSH
86138: LD_VAR 0 7
86142: PPUSH
86143: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
86147: LD_VAR 0 5
86151: PPUSH
86152: LD_VAR 0 3
86156: PPUSH
86157: CALL_OW 183
// AddComExitBuilding ( p ) ;
86161: LD_VAR 0 5
86165: PPUSH
86166: CALL_OW 182
// end ; end ;
86170: GO 86018
86172: POP
86173: POP
// end ;
86174: GO 85984
86176: POP
86177: POP
// end ;
86178: GO 85739
86180: POP
86181: POP
// end ;
86182: LD_VAR 0 1
86186: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
86187: LD_INT 0
86189: PPUSH
86190: PPUSH
86191: PPUSH
86192: PPUSH
86193: PPUSH
86194: PPUSH
86195: PPUSH
86196: PPUSH
86197: PPUSH
86198: PPUSH
86199: PPUSH
86200: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
86201: LD_VAR 0 1
86205: NOT
86206: PUSH
86207: LD_EXP 172
86211: PUSH
86212: LD_VAR 0 1
86216: ARRAY
86217: NOT
86218: OR
86219: PUSH
86220: LD_EXP 172
86224: PUSH
86225: LD_VAR 0 1
86229: ARRAY
86230: PPUSH
86231: LD_INT 2
86233: PUSH
86234: LD_INT 30
86236: PUSH
86237: LD_INT 0
86239: PUSH
86240: EMPTY
86241: LIST
86242: LIST
86243: PUSH
86244: LD_INT 30
86246: PUSH
86247: LD_INT 1
86249: PUSH
86250: EMPTY
86251: LIST
86252: LIST
86253: PUSH
86254: EMPTY
86255: LIST
86256: LIST
86257: LIST
86258: PPUSH
86259: CALL_OW 72
86263: NOT
86264: OR
86265: IFFALSE 86269
// exit ;
86267: GO 89772
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
86269: LD_ADDR_VAR 0 4
86273: PUSH
86274: LD_EXP 172
86278: PUSH
86279: LD_VAR 0 1
86283: ARRAY
86284: PPUSH
86285: LD_INT 2
86287: PUSH
86288: LD_INT 25
86290: PUSH
86291: LD_INT 1
86293: PUSH
86294: EMPTY
86295: LIST
86296: LIST
86297: PUSH
86298: LD_INT 25
86300: PUSH
86301: LD_INT 2
86303: PUSH
86304: EMPTY
86305: LIST
86306: LIST
86307: PUSH
86308: LD_INT 25
86310: PUSH
86311: LD_INT 3
86313: PUSH
86314: EMPTY
86315: LIST
86316: LIST
86317: PUSH
86318: LD_INT 25
86320: PUSH
86321: LD_INT 4
86323: PUSH
86324: EMPTY
86325: LIST
86326: LIST
86327: PUSH
86328: LD_INT 25
86330: PUSH
86331: LD_INT 5
86333: PUSH
86334: EMPTY
86335: LIST
86336: LIST
86337: PUSH
86338: LD_INT 25
86340: PUSH
86341: LD_INT 8
86343: PUSH
86344: EMPTY
86345: LIST
86346: LIST
86347: PUSH
86348: LD_INT 25
86350: PUSH
86351: LD_INT 9
86353: PUSH
86354: EMPTY
86355: LIST
86356: LIST
86357: PUSH
86358: EMPTY
86359: LIST
86360: LIST
86361: LIST
86362: LIST
86363: LIST
86364: LIST
86365: LIST
86366: LIST
86367: PPUSH
86368: CALL_OW 72
86372: ST_TO_ADDR
// if not tmp then
86373: LD_VAR 0 4
86377: NOT
86378: IFFALSE 86382
// exit ;
86380: GO 89772
// for i in tmp do
86382: LD_ADDR_VAR 0 3
86386: PUSH
86387: LD_VAR 0 4
86391: PUSH
86392: FOR_IN
86393: IFFALSE 86424
// if GetTag ( i ) then
86395: LD_VAR 0 3
86399: PPUSH
86400: CALL_OW 110
86404: IFFALSE 86422
// tmp := tmp diff i ;
86406: LD_ADDR_VAR 0 4
86410: PUSH
86411: LD_VAR 0 4
86415: PUSH
86416: LD_VAR 0 3
86420: DIFF
86421: ST_TO_ADDR
86422: GO 86392
86424: POP
86425: POP
// if not tmp then
86426: LD_VAR 0 4
86430: NOT
86431: IFFALSE 86435
// exit ;
86433: GO 89772
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
86435: LD_ADDR_VAR 0 5
86439: PUSH
86440: LD_EXP 172
86444: PUSH
86445: LD_VAR 0 1
86449: ARRAY
86450: PPUSH
86451: LD_INT 2
86453: PUSH
86454: LD_INT 25
86456: PUSH
86457: LD_INT 1
86459: PUSH
86460: EMPTY
86461: LIST
86462: LIST
86463: PUSH
86464: LD_INT 25
86466: PUSH
86467: LD_INT 5
86469: PUSH
86470: EMPTY
86471: LIST
86472: LIST
86473: PUSH
86474: LD_INT 25
86476: PUSH
86477: LD_INT 8
86479: PUSH
86480: EMPTY
86481: LIST
86482: LIST
86483: PUSH
86484: LD_INT 25
86486: PUSH
86487: LD_INT 9
86489: PUSH
86490: EMPTY
86491: LIST
86492: LIST
86493: PUSH
86494: EMPTY
86495: LIST
86496: LIST
86497: LIST
86498: LIST
86499: LIST
86500: PPUSH
86501: CALL_OW 72
86505: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
86506: LD_ADDR_VAR 0 6
86510: PUSH
86511: LD_EXP 172
86515: PUSH
86516: LD_VAR 0 1
86520: ARRAY
86521: PPUSH
86522: LD_INT 25
86524: PUSH
86525: LD_INT 2
86527: PUSH
86528: EMPTY
86529: LIST
86530: LIST
86531: PPUSH
86532: CALL_OW 72
86536: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
86537: LD_ADDR_VAR 0 7
86541: PUSH
86542: LD_EXP 172
86546: PUSH
86547: LD_VAR 0 1
86551: ARRAY
86552: PPUSH
86553: LD_INT 25
86555: PUSH
86556: LD_INT 3
86558: PUSH
86559: EMPTY
86560: LIST
86561: LIST
86562: PPUSH
86563: CALL_OW 72
86567: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
86568: LD_ADDR_VAR 0 8
86572: PUSH
86573: LD_EXP 172
86577: PUSH
86578: LD_VAR 0 1
86582: ARRAY
86583: PPUSH
86584: LD_INT 25
86586: PUSH
86587: LD_INT 4
86589: PUSH
86590: EMPTY
86591: LIST
86592: LIST
86593: PUSH
86594: LD_INT 24
86596: PUSH
86597: LD_INT 251
86599: PUSH
86600: EMPTY
86601: LIST
86602: LIST
86603: PUSH
86604: EMPTY
86605: LIST
86606: LIST
86607: PPUSH
86608: CALL_OW 72
86612: ST_TO_ADDR
// if mc_scan [ base ] then
86613: LD_EXP 195
86617: PUSH
86618: LD_VAR 0 1
86622: ARRAY
86623: IFFALSE 87084
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
86625: LD_ADDR_EXP 214
86629: PUSH
86630: LD_EXP 214
86634: PPUSH
86635: LD_VAR 0 1
86639: PPUSH
86640: LD_INT 4
86642: PPUSH
86643: CALL_OW 1
86647: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
86648: LD_ADDR_VAR 0 12
86652: PUSH
86653: LD_EXP 172
86657: PUSH
86658: LD_VAR 0 1
86662: ARRAY
86663: PPUSH
86664: LD_INT 2
86666: PUSH
86667: LD_INT 30
86669: PUSH
86670: LD_INT 4
86672: PUSH
86673: EMPTY
86674: LIST
86675: LIST
86676: PUSH
86677: LD_INT 30
86679: PUSH
86680: LD_INT 5
86682: PUSH
86683: EMPTY
86684: LIST
86685: LIST
86686: PUSH
86687: EMPTY
86688: LIST
86689: LIST
86690: LIST
86691: PPUSH
86692: CALL_OW 72
86696: ST_TO_ADDR
// if not b then
86697: LD_VAR 0 12
86701: NOT
86702: IFFALSE 86706
// exit ;
86704: GO 89772
// p := [ ] ;
86706: LD_ADDR_VAR 0 11
86710: PUSH
86711: EMPTY
86712: ST_TO_ADDR
// if sci >= 2 then
86713: LD_VAR 0 8
86717: PUSH
86718: LD_INT 2
86720: GREATEREQUAL
86721: IFFALSE 86752
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
86723: LD_ADDR_VAR 0 8
86727: PUSH
86728: LD_VAR 0 8
86732: PUSH
86733: LD_INT 1
86735: ARRAY
86736: PUSH
86737: LD_VAR 0 8
86741: PUSH
86742: LD_INT 2
86744: ARRAY
86745: PUSH
86746: EMPTY
86747: LIST
86748: LIST
86749: ST_TO_ADDR
86750: GO 86813
// if sci = 1 then
86752: LD_VAR 0 8
86756: PUSH
86757: LD_INT 1
86759: EQUAL
86760: IFFALSE 86781
// sci := [ sci [ 1 ] ] else
86762: LD_ADDR_VAR 0 8
86766: PUSH
86767: LD_VAR 0 8
86771: PUSH
86772: LD_INT 1
86774: ARRAY
86775: PUSH
86776: EMPTY
86777: LIST
86778: ST_TO_ADDR
86779: GO 86813
// if sci = 0 then
86781: LD_VAR 0 8
86785: PUSH
86786: LD_INT 0
86788: EQUAL
86789: IFFALSE 86813
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
86791: LD_ADDR_VAR 0 11
86795: PUSH
86796: LD_VAR 0 4
86800: PPUSH
86801: LD_INT 4
86803: PPUSH
86804: CALL 53978 0 2
86808: PUSH
86809: LD_INT 1
86811: ARRAY
86812: ST_TO_ADDR
// if eng > 4 then
86813: LD_VAR 0 6
86817: PUSH
86818: LD_INT 4
86820: GREATER
86821: IFFALSE 86867
// for i = eng downto 4 do
86823: LD_ADDR_VAR 0 3
86827: PUSH
86828: DOUBLE
86829: LD_VAR 0 6
86833: INC
86834: ST_TO_ADDR
86835: LD_INT 4
86837: PUSH
86838: FOR_DOWNTO
86839: IFFALSE 86865
// eng := eng diff eng [ i ] ;
86841: LD_ADDR_VAR 0 6
86845: PUSH
86846: LD_VAR 0 6
86850: PUSH
86851: LD_VAR 0 6
86855: PUSH
86856: LD_VAR 0 3
86860: ARRAY
86861: DIFF
86862: ST_TO_ADDR
86863: GO 86838
86865: POP
86866: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
86867: LD_ADDR_VAR 0 4
86871: PUSH
86872: LD_VAR 0 4
86876: PUSH
86877: LD_VAR 0 5
86881: PUSH
86882: LD_VAR 0 6
86886: UNION
86887: PUSH
86888: LD_VAR 0 7
86892: UNION
86893: PUSH
86894: LD_VAR 0 8
86898: UNION
86899: DIFF
86900: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
86901: LD_ADDR_VAR 0 13
86905: PUSH
86906: LD_EXP 172
86910: PUSH
86911: LD_VAR 0 1
86915: ARRAY
86916: PPUSH
86917: LD_INT 2
86919: PUSH
86920: LD_INT 30
86922: PUSH
86923: LD_INT 32
86925: PUSH
86926: EMPTY
86927: LIST
86928: LIST
86929: PUSH
86930: LD_INT 30
86932: PUSH
86933: LD_INT 31
86935: PUSH
86936: EMPTY
86937: LIST
86938: LIST
86939: PUSH
86940: EMPTY
86941: LIST
86942: LIST
86943: LIST
86944: PPUSH
86945: CALL_OW 72
86949: PUSH
86950: LD_EXP 172
86954: PUSH
86955: LD_VAR 0 1
86959: ARRAY
86960: PPUSH
86961: LD_INT 2
86963: PUSH
86964: LD_INT 30
86966: PUSH
86967: LD_INT 4
86969: PUSH
86970: EMPTY
86971: LIST
86972: LIST
86973: PUSH
86974: LD_INT 30
86976: PUSH
86977: LD_INT 5
86979: PUSH
86980: EMPTY
86981: LIST
86982: LIST
86983: PUSH
86984: EMPTY
86985: LIST
86986: LIST
86987: LIST
86988: PPUSH
86989: CALL_OW 72
86993: PUSH
86994: LD_INT 6
86996: MUL
86997: PLUS
86998: ST_TO_ADDR
// if bcount < tmp then
86999: LD_VAR 0 13
87003: PUSH
87004: LD_VAR 0 4
87008: LESS
87009: IFFALSE 87055
// for i = tmp downto bcount do
87011: LD_ADDR_VAR 0 3
87015: PUSH
87016: DOUBLE
87017: LD_VAR 0 4
87021: INC
87022: ST_TO_ADDR
87023: LD_VAR 0 13
87027: PUSH
87028: FOR_DOWNTO
87029: IFFALSE 87053
// tmp := Delete ( tmp , tmp ) ;
87031: LD_ADDR_VAR 0 4
87035: PUSH
87036: LD_VAR 0 4
87040: PPUSH
87041: LD_VAR 0 4
87045: PPUSH
87046: CALL_OW 3
87050: ST_TO_ADDR
87051: GO 87028
87053: POP
87054: POP
// result := [ tmp , 0 , 0 , p ] ;
87055: LD_ADDR_VAR 0 2
87059: PUSH
87060: LD_VAR 0 4
87064: PUSH
87065: LD_INT 0
87067: PUSH
87068: LD_INT 0
87070: PUSH
87071: LD_VAR 0 11
87075: PUSH
87076: EMPTY
87077: LIST
87078: LIST
87079: LIST
87080: LIST
87081: ST_TO_ADDR
// exit ;
87082: GO 89772
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
87084: LD_EXP 172
87088: PUSH
87089: LD_VAR 0 1
87093: ARRAY
87094: PPUSH
87095: LD_INT 2
87097: PUSH
87098: LD_INT 30
87100: PUSH
87101: LD_INT 6
87103: PUSH
87104: EMPTY
87105: LIST
87106: LIST
87107: PUSH
87108: LD_INT 30
87110: PUSH
87111: LD_INT 7
87113: PUSH
87114: EMPTY
87115: LIST
87116: LIST
87117: PUSH
87118: LD_INT 30
87120: PUSH
87121: LD_INT 8
87123: PUSH
87124: EMPTY
87125: LIST
87126: LIST
87127: PUSH
87128: EMPTY
87129: LIST
87130: LIST
87131: LIST
87132: LIST
87133: PPUSH
87134: CALL_OW 72
87138: NOT
87139: PUSH
87140: LD_EXP 172
87144: PUSH
87145: LD_VAR 0 1
87149: ARRAY
87150: PPUSH
87151: LD_INT 30
87153: PUSH
87154: LD_INT 3
87156: PUSH
87157: EMPTY
87158: LIST
87159: LIST
87160: PPUSH
87161: CALL_OW 72
87165: NOT
87166: AND
87167: IFFALSE 87239
// begin if eng = tmp then
87169: LD_VAR 0 6
87173: PUSH
87174: LD_VAR 0 4
87178: EQUAL
87179: IFFALSE 87183
// exit ;
87181: GO 89772
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
87183: LD_ADDR_EXP 214
87187: PUSH
87188: LD_EXP 214
87192: PPUSH
87193: LD_VAR 0 1
87197: PPUSH
87198: LD_INT 1
87200: PPUSH
87201: CALL_OW 1
87205: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
87206: LD_ADDR_VAR 0 2
87210: PUSH
87211: LD_INT 0
87213: PUSH
87214: LD_VAR 0 4
87218: PUSH
87219: LD_VAR 0 6
87223: DIFF
87224: PUSH
87225: LD_INT 0
87227: PUSH
87228: LD_INT 0
87230: PUSH
87231: EMPTY
87232: LIST
87233: LIST
87234: LIST
87235: LIST
87236: ST_TO_ADDR
// exit ;
87237: GO 89772
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
87239: LD_EXP 199
87243: PUSH
87244: LD_EXP 198
87248: PUSH
87249: LD_VAR 0 1
87253: ARRAY
87254: ARRAY
87255: PUSH
87256: LD_EXP 172
87260: PUSH
87261: LD_VAR 0 1
87265: ARRAY
87266: PPUSH
87267: LD_INT 2
87269: PUSH
87270: LD_INT 30
87272: PUSH
87273: LD_INT 6
87275: PUSH
87276: EMPTY
87277: LIST
87278: LIST
87279: PUSH
87280: LD_INT 30
87282: PUSH
87283: LD_INT 7
87285: PUSH
87286: EMPTY
87287: LIST
87288: LIST
87289: PUSH
87290: LD_INT 30
87292: PUSH
87293: LD_INT 8
87295: PUSH
87296: EMPTY
87297: LIST
87298: LIST
87299: PUSH
87300: EMPTY
87301: LIST
87302: LIST
87303: LIST
87304: LIST
87305: PPUSH
87306: CALL_OW 72
87310: AND
87311: PUSH
87312: LD_EXP 172
87316: PUSH
87317: LD_VAR 0 1
87321: ARRAY
87322: PPUSH
87323: LD_INT 30
87325: PUSH
87326: LD_INT 3
87328: PUSH
87329: EMPTY
87330: LIST
87331: LIST
87332: PPUSH
87333: CALL_OW 72
87337: NOT
87338: AND
87339: IFFALSE 87553
// begin if sci >= 6 then
87341: LD_VAR 0 8
87345: PUSH
87346: LD_INT 6
87348: GREATEREQUAL
87349: IFFALSE 87353
// exit ;
87351: GO 89772
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
87353: LD_ADDR_EXP 214
87357: PUSH
87358: LD_EXP 214
87362: PPUSH
87363: LD_VAR 0 1
87367: PPUSH
87368: LD_INT 2
87370: PPUSH
87371: CALL_OW 1
87375: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
87376: LD_ADDR_VAR 0 9
87380: PUSH
87381: LD_VAR 0 4
87385: PUSH
87386: LD_VAR 0 8
87390: DIFF
87391: PPUSH
87392: LD_INT 4
87394: PPUSH
87395: CALL 53978 0 2
87399: ST_TO_ADDR
// p := [ ] ;
87400: LD_ADDR_VAR 0 11
87404: PUSH
87405: EMPTY
87406: ST_TO_ADDR
// if sci < 6 and sort > 6 then
87407: LD_VAR 0 8
87411: PUSH
87412: LD_INT 6
87414: LESS
87415: PUSH
87416: LD_VAR 0 9
87420: PUSH
87421: LD_INT 6
87423: GREATER
87424: AND
87425: IFFALSE 87506
// begin for i = 1 to 6 - sci do
87427: LD_ADDR_VAR 0 3
87431: PUSH
87432: DOUBLE
87433: LD_INT 1
87435: DEC
87436: ST_TO_ADDR
87437: LD_INT 6
87439: PUSH
87440: LD_VAR 0 8
87444: MINUS
87445: PUSH
87446: FOR_TO
87447: IFFALSE 87502
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
87449: LD_ADDR_VAR 0 11
87453: PUSH
87454: LD_VAR 0 11
87458: PPUSH
87459: LD_VAR 0 11
87463: PUSH
87464: LD_INT 1
87466: PLUS
87467: PPUSH
87468: LD_VAR 0 9
87472: PUSH
87473: LD_INT 1
87475: ARRAY
87476: PPUSH
87477: CALL_OW 2
87481: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
87482: LD_ADDR_VAR 0 9
87486: PUSH
87487: LD_VAR 0 9
87491: PPUSH
87492: LD_INT 1
87494: PPUSH
87495: CALL_OW 3
87499: ST_TO_ADDR
// end ;
87500: GO 87446
87502: POP
87503: POP
// end else
87504: GO 87526
// if sort then
87506: LD_VAR 0 9
87510: IFFALSE 87526
// p := sort [ 1 ] ;
87512: LD_ADDR_VAR 0 11
87516: PUSH
87517: LD_VAR 0 9
87521: PUSH
87522: LD_INT 1
87524: ARRAY
87525: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
87526: LD_ADDR_VAR 0 2
87530: PUSH
87531: LD_INT 0
87533: PUSH
87534: LD_INT 0
87536: PUSH
87537: LD_INT 0
87539: PUSH
87540: LD_VAR 0 11
87544: PUSH
87545: EMPTY
87546: LIST
87547: LIST
87548: LIST
87549: LIST
87550: ST_TO_ADDR
// exit ;
87551: GO 89772
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
87553: LD_EXP 199
87557: PUSH
87558: LD_EXP 198
87562: PUSH
87563: LD_VAR 0 1
87567: ARRAY
87568: ARRAY
87569: PUSH
87570: LD_EXP 172
87574: PUSH
87575: LD_VAR 0 1
87579: ARRAY
87580: PPUSH
87581: LD_INT 2
87583: PUSH
87584: LD_INT 30
87586: PUSH
87587: LD_INT 6
87589: PUSH
87590: EMPTY
87591: LIST
87592: LIST
87593: PUSH
87594: LD_INT 30
87596: PUSH
87597: LD_INT 7
87599: PUSH
87600: EMPTY
87601: LIST
87602: LIST
87603: PUSH
87604: LD_INT 30
87606: PUSH
87607: LD_INT 8
87609: PUSH
87610: EMPTY
87611: LIST
87612: LIST
87613: PUSH
87614: EMPTY
87615: LIST
87616: LIST
87617: LIST
87618: LIST
87619: PPUSH
87620: CALL_OW 72
87624: AND
87625: PUSH
87626: LD_EXP 172
87630: PUSH
87631: LD_VAR 0 1
87635: ARRAY
87636: PPUSH
87637: LD_INT 30
87639: PUSH
87640: LD_INT 3
87642: PUSH
87643: EMPTY
87644: LIST
87645: LIST
87646: PPUSH
87647: CALL_OW 72
87651: AND
87652: IFFALSE 88386
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
87654: LD_ADDR_EXP 214
87658: PUSH
87659: LD_EXP 214
87663: PPUSH
87664: LD_VAR 0 1
87668: PPUSH
87669: LD_INT 3
87671: PPUSH
87672: CALL_OW 1
87676: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
87677: LD_ADDR_VAR 0 2
87681: PUSH
87682: LD_INT 0
87684: PUSH
87685: LD_INT 0
87687: PUSH
87688: LD_INT 0
87690: PUSH
87691: LD_INT 0
87693: PUSH
87694: EMPTY
87695: LIST
87696: LIST
87697: LIST
87698: LIST
87699: ST_TO_ADDR
// if not eng then
87700: LD_VAR 0 6
87704: NOT
87705: IFFALSE 87768
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
87707: LD_ADDR_VAR 0 11
87711: PUSH
87712: LD_VAR 0 4
87716: PPUSH
87717: LD_INT 2
87719: PPUSH
87720: CALL 53978 0 2
87724: PUSH
87725: LD_INT 1
87727: ARRAY
87728: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
87729: LD_ADDR_VAR 0 2
87733: PUSH
87734: LD_VAR 0 2
87738: PPUSH
87739: LD_INT 2
87741: PPUSH
87742: LD_VAR 0 11
87746: PPUSH
87747: CALL_OW 1
87751: ST_TO_ADDR
// tmp := tmp diff p ;
87752: LD_ADDR_VAR 0 4
87756: PUSH
87757: LD_VAR 0 4
87761: PUSH
87762: LD_VAR 0 11
87766: DIFF
87767: ST_TO_ADDR
// end ; if tmp and sci < 6 then
87768: LD_VAR 0 4
87772: PUSH
87773: LD_VAR 0 8
87777: PUSH
87778: LD_INT 6
87780: LESS
87781: AND
87782: IFFALSE 87970
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
87784: LD_ADDR_VAR 0 9
87788: PUSH
87789: LD_VAR 0 4
87793: PUSH
87794: LD_VAR 0 8
87798: PUSH
87799: LD_VAR 0 7
87803: UNION
87804: DIFF
87805: PPUSH
87806: LD_INT 4
87808: PPUSH
87809: CALL 53978 0 2
87813: ST_TO_ADDR
// p := [ ] ;
87814: LD_ADDR_VAR 0 11
87818: PUSH
87819: EMPTY
87820: ST_TO_ADDR
// if sort then
87821: LD_VAR 0 9
87825: IFFALSE 87941
// for i = 1 to 6 - sci do
87827: LD_ADDR_VAR 0 3
87831: PUSH
87832: DOUBLE
87833: LD_INT 1
87835: DEC
87836: ST_TO_ADDR
87837: LD_INT 6
87839: PUSH
87840: LD_VAR 0 8
87844: MINUS
87845: PUSH
87846: FOR_TO
87847: IFFALSE 87939
// begin if i = sort then
87849: LD_VAR 0 3
87853: PUSH
87854: LD_VAR 0 9
87858: EQUAL
87859: IFFALSE 87863
// break ;
87861: GO 87939
// if GetClass ( i ) = 4 then
87863: LD_VAR 0 3
87867: PPUSH
87868: CALL_OW 257
87872: PUSH
87873: LD_INT 4
87875: EQUAL
87876: IFFALSE 87880
// continue ;
87878: GO 87846
// p := Insert ( p , p + 1 , sort [ i ] ) ;
87880: LD_ADDR_VAR 0 11
87884: PUSH
87885: LD_VAR 0 11
87889: PPUSH
87890: LD_VAR 0 11
87894: PUSH
87895: LD_INT 1
87897: PLUS
87898: PPUSH
87899: LD_VAR 0 9
87903: PUSH
87904: LD_VAR 0 3
87908: ARRAY
87909: PPUSH
87910: CALL_OW 2
87914: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
87915: LD_ADDR_VAR 0 4
87919: PUSH
87920: LD_VAR 0 4
87924: PUSH
87925: LD_VAR 0 9
87929: PUSH
87930: LD_VAR 0 3
87934: ARRAY
87935: DIFF
87936: ST_TO_ADDR
// end ;
87937: GO 87846
87939: POP
87940: POP
// if p then
87941: LD_VAR 0 11
87945: IFFALSE 87970
// result := Replace ( result , 4 , p ) ;
87947: LD_ADDR_VAR 0 2
87951: PUSH
87952: LD_VAR 0 2
87956: PPUSH
87957: LD_INT 4
87959: PPUSH
87960: LD_VAR 0 11
87964: PPUSH
87965: CALL_OW 1
87969: ST_TO_ADDR
// end ; if tmp and mech < 6 then
87970: LD_VAR 0 4
87974: PUSH
87975: LD_VAR 0 7
87979: PUSH
87980: LD_INT 6
87982: LESS
87983: AND
87984: IFFALSE 88172
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
87986: LD_ADDR_VAR 0 9
87990: PUSH
87991: LD_VAR 0 4
87995: PUSH
87996: LD_VAR 0 8
88000: PUSH
88001: LD_VAR 0 7
88005: UNION
88006: DIFF
88007: PPUSH
88008: LD_INT 3
88010: PPUSH
88011: CALL 53978 0 2
88015: ST_TO_ADDR
// p := [ ] ;
88016: LD_ADDR_VAR 0 11
88020: PUSH
88021: EMPTY
88022: ST_TO_ADDR
// if sort then
88023: LD_VAR 0 9
88027: IFFALSE 88143
// for i = 1 to 6 - mech do
88029: LD_ADDR_VAR 0 3
88033: PUSH
88034: DOUBLE
88035: LD_INT 1
88037: DEC
88038: ST_TO_ADDR
88039: LD_INT 6
88041: PUSH
88042: LD_VAR 0 7
88046: MINUS
88047: PUSH
88048: FOR_TO
88049: IFFALSE 88141
// begin if i = sort then
88051: LD_VAR 0 3
88055: PUSH
88056: LD_VAR 0 9
88060: EQUAL
88061: IFFALSE 88065
// break ;
88063: GO 88141
// if GetClass ( i ) = 3 then
88065: LD_VAR 0 3
88069: PPUSH
88070: CALL_OW 257
88074: PUSH
88075: LD_INT 3
88077: EQUAL
88078: IFFALSE 88082
// continue ;
88080: GO 88048
// p := Insert ( p , p + 1 , sort [ i ] ) ;
88082: LD_ADDR_VAR 0 11
88086: PUSH
88087: LD_VAR 0 11
88091: PPUSH
88092: LD_VAR 0 11
88096: PUSH
88097: LD_INT 1
88099: PLUS
88100: PPUSH
88101: LD_VAR 0 9
88105: PUSH
88106: LD_VAR 0 3
88110: ARRAY
88111: PPUSH
88112: CALL_OW 2
88116: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
88117: LD_ADDR_VAR 0 4
88121: PUSH
88122: LD_VAR 0 4
88126: PUSH
88127: LD_VAR 0 9
88131: PUSH
88132: LD_VAR 0 3
88136: ARRAY
88137: DIFF
88138: ST_TO_ADDR
// end ;
88139: GO 88048
88141: POP
88142: POP
// if p then
88143: LD_VAR 0 11
88147: IFFALSE 88172
// result := Replace ( result , 3 , p ) ;
88149: LD_ADDR_VAR 0 2
88153: PUSH
88154: LD_VAR 0 2
88158: PPUSH
88159: LD_INT 3
88161: PPUSH
88162: LD_VAR 0 11
88166: PPUSH
88167: CALL_OW 1
88171: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
88172: LD_VAR 0 4
88176: PUSH
88177: LD_INT 6
88179: GREATER
88180: PUSH
88181: LD_VAR 0 6
88185: PUSH
88186: LD_INT 6
88188: LESS
88189: AND
88190: IFFALSE 88384
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
88192: LD_ADDR_VAR 0 9
88196: PUSH
88197: LD_VAR 0 4
88201: PUSH
88202: LD_VAR 0 8
88206: PUSH
88207: LD_VAR 0 7
88211: UNION
88212: PUSH
88213: LD_VAR 0 6
88217: UNION
88218: DIFF
88219: PPUSH
88220: LD_INT 2
88222: PPUSH
88223: CALL 53978 0 2
88227: ST_TO_ADDR
// p := [ ] ;
88228: LD_ADDR_VAR 0 11
88232: PUSH
88233: EMPTY
88234: ST_TO_ADDR
// if sort then
88235: LD_VAR 0 9
88239: IFFALSE 88355
// for i = 1 to 6 - eng do
88241: LD_ADDR_VAR 0 3
88245: PUSH
88246: DOUBLE
88247: LD_INT 1
88249: DEC
88250: ST_TO_ADDR
88251: LD_INT 6
88253: PUSH
88254: LD_VAR 0 6
88258: MINUS
88259: PUSH
88260: FOR_TO
88261: IFFALSE 88353
// begin if i = sort then
88263: LD_VAR 0 3
88267: PUSH
88268: LD_VAR 0 9
88272: EQUAL
88273: IFFALSE 88277
// break ;
88275: GO 88353
// if GetClass ( i ) = 2 then
88277: LD_VAR 0 3
88281: PPUSH
88282: CALL_OW 257
88286: PUSH
88287: LD_INT 2
88289: EQUAL
88290: IFFALSE 88294
// continue ;
88292: GO 88260
// p := Insert ( p , p + 1 , sort [ i ] ) ;
88294: LD_ADDR_VAR 0 11
88298: PUSH
88299: LD_VAR 0 11
88303: PPUSH
88304: LD_VAR 0 11
88308: PUSH
88309: LD_INT 1
88311: PLUS
88312: PPUSH
88313: LD_VAR 0 9
88317: PUSH
88318: LD_VAR 0 3
88322: ARRAY
88323: PPUSH
88324: CALL_OW 2
88328: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
88329: LD_ADDR_VAR 0 4
88333: PUSH
88334: LD_VAR 0 4
88338: PUSH
88339: LD_VAR 0 9
88343: PUSH
88344: LD_VAR 0 3
88348: ARRAY
88349: DIFF
88350: ST_TO_ADDR
// end ;
88351: GO 88260
88353: POP
88354: POP
// if p then
88355: LD_VAR 0 11
88359: IFFALSE 88384
// result := Replace ( result , 2 , p ) ;
88361: LD_ADDR_VAR 0 2
88365: PUSH
88366: LD_VAR 0 2
88370: PPUSH
88371: LD_INT 2
88373: PPUSH
88374: LD_VAR 0 11
88378: PPUSH
88379: CALL_OW 1
88383: ST_TO_ADDR
// end ; exit ;
88384: GO 89772
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
88386: LD_EXP 199
88390: PUSH
88391: LD_EXP 198
88395: PUSH
88396: LD_VAR 0 1
88400: ARRAY
88401: ARRAY
88402: NOT
88403: PUSH
88404: LD_EXP 172
88408: PUSH
88409: LD_VAR 0 1
88413: ARRAY
88414: PPUSH
88415: LD_INT 30
88417: PUSH
88418: LD_INT 3
88420: PUSH
88421: EMPTY
88422: LIST
88423: LIST
88424: PPUSH
88425: CALL_OW 72
88429: AND
88430: PUSH
88431: LD_EXP 177
88435: PUSH
88436: LD_VAR 0 1
88440: ARRAY
88441: AND
88442: IFFALSE 89050
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
88444: LD_ADDR_EXP 214
88448: PUSH
88449: LD_EXP 214
88453: PPUSH
88454: LD_VAR 0 1
88458: PPUSH
88459: LD_INT 5
88461: PPUSH
88462: CALL_OW 1
88466: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
88467: LD_ADDR_VAR 0 2
88471: PUSH
88472: LD_INT 0
88474: PUSH
88475: LD_INT 0
88477: PUSH
88478: LD_INT 0
88480: PUSH
88481: LD_INT 0
88483: PUSH
88484: EMPTY
88485: LIST
88486: LIST
88487: LIST
88488: LIST
88489: ST_TO_ADDR
// if sci > 1 then
88490: LD_VAR 0 8
88494: PUSH
88495: LD_INT 1
88497: GREATER
88498: IFFALSE 88526
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
88500: LD_ADDR_VAR 0 4
88504: PUSH
88505: LD_VAR 0 4
88509: PUSH
88510: LD_VAR 0 8
88514: PUSH
88515: LD_VAR 0 8
88519: PUSH
88520: LD_INT 1
88522: ARRAY
88523: DIFF
88524: DIFF
88525: ST_TO_ADDR
// if tmp and not sci then
88526: LD_VAR 0 4
88530: PUSH
88531: LD_VAR 0 8
88535: NOT
88536: AND
88537: IFFALSE 88606
// begin sort := SortBySkill ( tmp , 4 ) ;
88539: LD_ADDR_VAR 0 9
88543: PUSH
88544: LD_VAR 0 4
88548: PPUSH
88549: LD_INT 4
88551: PPUSH
88552: CALL 53978 0 2
88556: ST_TO_ADDR
// if sort then
88557: LD_VAR 0 9
88561: IFFALSE 88577
// p := sort [ 1 ] ;
88563: LD_ADDR_VAR 0 11
88567: PUSH
88568: LD_VAR 0 9
88572: PUSH
88573: LD_INT 1
88575: ARRAY
88576: ST_TO_ADDR
// if p then
88577: LD_VAR 0 11
88581: IFFALSE 88606
// result := Replace ( result , 4 , p ) ;
88583: LD_ADDR_VAR 0 2
88587: PUSH
88588: LD_VAR 0 2
88592: PPUSH
88593: LD_INT 4
88595: PPUSH
88596: LD_VAR 0 11
88600: PPUSH
88601: CALL_OW 1
88605: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
88606: LD_ADDR_VAR 0 4
88610: PUSH
88611: LD_VAR 0 4
88615: PUSH
88616: LD_VAR 0 7
88620: DIFF
88621: ST_TO_ADDR
// if tmp and mech < 6 then
88622: LD_VAR 0 4
88626: PUSH
88627: LD_VAR 0 7
88631: PUSH
88632: LD_INT 6
88634: LESS
88635: AND
88636: IFFALSE 88824
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
88638: LD_ADDR_VAR 0 9
88642: PUSH
88643: LD_VAR 0 4
88647: PUSH
88648: LD_VAR 0 8
88652: PUSH
88653: LD_VAR 0 7
88657: UNION
88658: DIFF
88659: PPUSH
88660: LD_INT 3
88662: PPUSH
88663: CALL 53978 0 2
88667: ST_TO_ADDR
// p := [ ] ;
88668: LD_ADDR_VAR 0 11
88672: PUSH
88673: EMPTY
88674: ST_TO_ADDR
// if sort then
88675: LD_VAR 0 9
88679: IFFALSE 88795
// for i = 1 to 6 - mech do
88681: LD_ADDR_VAR 0 3
88685: PUSH
88686: DOUBLE
88687: LD_INT 1
88689: DEC
88690: ST_TO_ADDR
88691: LD_INT 6
88693: PUSH
88694: LD_VAR 0 7
88698: MINUS
88699: PUSH
88700: FOR_TO
88701: IFFALSE 88793
// begin if i = sort then
88703: LD_VAR 0 3
88707: PUSH
88708: LD_VAR 0 9
88712: EQUAL
88713: IFFALSE 88717
// break ;
88715: GO 88793
// if GetClass ( i ) = 3 then
88717: LD_VAR 0 3
88721: PPUSH
88722: CALL_OW 257
88726: PUSH
88727: LD_INT 3
88729: EQUAL
88730: IFFALSE 88734
// continue ;
88732: GO 88700
// p := Insert ( p , p + 1 , sort [ i ] ) ;
88734: LD_ADDR_VAR 0 11
88738: PUSH
88739: LD_VAR 0 11
88743: PPUSH
88744: LD_VAR 0 11
88748: PUSH
88749: LD_INT 1
88751: PLUS
88752: PPUSH
88753: LD_VAR 0 9
88757: PUSH
88758: LD_VAR 0 3
88762: ARRAY
88763: PPUSH
88764: CALL_OW 2
88768: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
88769: LD_ADDR_VAR 0 4
88773: PUSH
88774: LD_VAR 0 4
88778: PUSH
88779: LD_VAR 0 9
88783: PUSH
88784: LD_VAR 0 3
88788: ARRAY
88789: DIFF
88790: ST_TO_ADDR
// end ;
88791: GO 88700
88793: POP
88794: POP
// if p then
88795: LD_VAR 0 11
88799: IFFALSE 88824
// result := Replace ( result , 3 , p ) ;
88801: LD_ADDR_VAR 0 2
88805: PUSH
88806: LD_VAR 0 2
88810: PPUSH
88811: LD_INT 3
88813: PPUSH
88814: LD_VAR 0 11
88818: PPUSH
88819: CALL_OW 1
88823: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
88824: LD_ADDR_VAR 0 4
88828: PUSH
88829: LD_VAR 0 4
88833: PUSH
88834: LD_VAR 0 6
88838: DIFF
88839: ST_TO_ADDR
// if tmp and eng < 6 then
88840: LD_VAR 0 4
88844: PUSH
88845: LD_VAR 0 6
88849: PUSH
88850: LD_INT 6
88852: LESS
88853: AND
88854: IFFALSE 89048
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
88856: LD_ADDR_VAR 0 9
88860: PUSH
88861: LD_VAR 0 4
88865: PUSH
88866: LD_VAR 0 8
88870: PUSH
88871: LD_VAR 0 7
88875: UNION
88876: PUSH
88877: LD_VAR 0 6
88881: UNION
88882: DIFF
88883: PPUSH
88884: LD_INT 2
88886: PPUSH
88887: CALL 53978 0 2
88891: ST_TO_ADDR
// p := [ ] ;
88892: LD_ADDR_VAR 0 11
88896: PUSH
88897: EMPTY
88898: ST_TO_ADDR
// if sort then
88899: LD_VAR 0 9
88903: IFFALSE 89019
// for i = 1 to 6 - eng do
88905: LD_ADDR_VAR 0 3
88909: PUSH
88910: DOUBLE
88911: LD_INT 1
88913: DEC
88914: ST_TO_ADDR
88915: LD_INT 6
88917: PUSH
88918: LD_VAR 0 6
88922: MINUS
88923: PUSH
88924: FOR_TO
88925: IFFALSE 89017
// begin if i = sort then
88927: LD_VAR 0 3
88931: PUSH
88932: LD_VAR 0 9
88936: EQUAL
88937: IFFALSE 88941
// break ;
88939: GO 89017
// if GetClass ( i ) = 2 then
88941: LD_VAR 0 3
88945: PPUSH
88946: CALL_OW 257
88950: PUSH
88951: LD_INT 2
88953: EQUAL
88954: IFFALSE 88958
// continue ;
88956: GO 88924
// p := Insert ( p , p + 1 , sort [ i ] ) ;
88958: LD_ADDR_VAR 0 11
88962: PUSH
88963: LD_VAR 0 11
88967: PPUSH
88968: LD_VAR 0 11
88972: PUSH
88973: LD_INT 1
88975: PLUS
88976: PPUSH
88977: LD_VAR 0 9
88981: PUSH
88982: LD_VAR 0 3
88986: ARRAY
88987: PPUSH
88988: CALL_OW 2
88992: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
88993: LD_ADDR_VAR 0 4
88997: PUSH
88998: LD_VAR 0 4
89002: PUSH
89003: LD_VAR 0 9
89007: PUSH
89008: LD_VAR 0 3
89012: ARRAY
89013: DIFF
89014: ST_TO_ADDR
// end ;
89015: GO 88924
89017: POP
89018: POP
// if p then
89019: LD_VAR 0 11
89023: IFFALSE 89048
// result := Replace ( result , 2 , p ) ;
89025: LD_ADDR_VAR 0 2
89029: PUSH
89030: LD_VAR 0 2
89034: PPUSH
89035: LD_INT 2
89037: PPUSH
89038: LD_VAR 0 11
89042: PPUSH
89043: CALL_OW 1
89047: ST_TO_ADDR
// end ; exit ;
89048: GO 89772
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
89050: LD_EXP 199
89054: PUSH
89055: LD_EXP 198
89059: PUSH
89060: LD_VAR 0 1
89064: ARRAY
89065: ARRAY
89066: NOT
89067: PUSH
89068: LD_EXP 172
89072: PUSH
89073: LD_VAR 0 1
89077: ARRAY
89078: PPUSH
89079: LD_INT 30
89081: PUSH
89082: LD_INT 3
89084: PUSH
89085: EMPTY
89086: LIST
89087: LIST
89088: PPUSH
89089: CALL_OW 72
89093: AND
89094: PUSH
89095: LD_EXP 177
89099: PUSH
89100: LD_VAR 0 1
89104: ARRAY
89105: NOT
89106: AND
89107: IFFALSE 89772
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
89109: LD_ADDR_EXP 214
89113: PUSH
89114: LD_EXP 214
89118: PPUSH
89119: LD_VAR 0 1
89123: PPUSH
89124: LD_INT 6
89126: PPUSH
89127: CALL_OW 1
89131: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
89132: LD_ADDR_VAR 0 2
89136: PUSH
89137: LD_INT 0
89139: PUSH
89140: LD_INT 0
89142: PUSH
89143: LD_INT 0
89145: PUSH
89146: LD_INT 0
89148: PUSH
89149: EMPTY
89150: LIST
89151: LIST
89152: LIST
89153: LIST
89154: ST_TO_ADDR
// if sci >= 1 then
89155: LD_VAR 0 8
89159: PUSH
89160: LD_INT 1
89162: GREATEREQUAL
89163: IFFALSE 89185
// tmp := tmp diff sci [ 1 ] ;
89165: LD_ADDR_VAR 0 4
89169: PUSH
89170: LD_VAR 0 4
89174: PUSH
89175: LD_VAR 0 8
89179: PUSH
89180: LD_INT 1
89182: ARRAY
89183: DIFF
89184: ST_TO_ADDR
// if tmp and not sci then
89185: LD_VAR 0 4
89189: PUSH
89190: LD_VAR 0 8
89194: NOT
89195: AND
89196: IFFALSE 89265
// begin sort := SortBySkill ( tmp , 4 ) ;
89198: LD_ADDR_VAR 0 9
89202: PUSH
89203: LD_VAR 0 4
89207: PPUSH
89208: LD_INT 4
89210: PPUSH
89211: CALL 53978 0 2
89215: ST_TO_ADDR
// if sort then
89216: LD_VAR 0 9
89220: IFFALSE 89236
// p := sort [ 1 ] ;
89222: LD_ADDR_VAR 0 11
89226: PUSH
89227: LD_VAR 0 9
89231: PUSH
89232: LD_INT 1
89234: ARRAY
89235: ST_TO_ADDR
// if p then
89236: LD_VAR 0 11
89240: IFFALSE 89265
// result := Replace ( result , 4 , p ) ;
89242: LD_ADDR_VAR 0 2
89246: PUSH
89247: LD_VAR 0 2
89251: PPUSH
89252: LD_INT 4
89254: PPUSH
89255: LD_VAR 0 11
89259: PPUSH
89260: CALL_OW 1
89264: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
89265: LD_ADDR_VAR 0 4
89269: PUSH
89270: LD_VAR 0 4
89274: PUSH
89275: LD_VAR 0 7
89279: DIFF
89280: ST_TO_ADDR
// if tmp and mech < 6 then
89281: LD_VAR 0 4
89285: PUSH
89286: LD_VAR 0 7
89290: PUSH
89291: LD_INT 6
89293: LESS
89294: AND
89295: IFFALSE 89477
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
89297: LD_ADDR_VAR 0 9
89301: PUSH
89302: LD_VAR 0 4
89306: PUSH
89307: LD_VAR 0 7
89311: DIFF
89312: PPUSH
89313: LD_INT 3
89315: PPUSH
89316: CALL 53978 0 2
89320: ST_TO_ADDR
// p := [ ] ;
89321: LD_ADDR_VAR 0 11
89325: PUSH
89326: EMPTY
89327: ST_TO_ADDR
// if sort then
89328: LD_VAR 0 9
89332: IFFALSE 89448
// for i = 1 to 6 - mech do
89334: LD_ADDR_VAR 0 3
89338: PUSH
89339: DOUBLE
89340: LD_INT 1
89342: DEC
89343: ST_TO_ADDR
89344: LD_INT 6
89346: PUSH
89347: LD_VAR 0 7
89351: MINUS
89352: PUSH
89353: FOR_TO
89354: IFFALSE 89446
// begin if i = sort then
89356: LD_VAR 0 3
89360: PUSH
89361: LD_VAR 0 9
89365: EQUAL
89366: IFFALSE 89370
// break ;
89368: GO 89446
// if GetClass ( i ) = 3 then
89370: LD_VAR 0 3
89374: PPUSH
89375: CALL_OW 257
89379: PUSH
89380: LD_INT 3
89382: EQUAL
89383: IFFALSE 89387
// continue ;
89385: GO 89353
// p := Insert ( p , p + 1 , sort [ i ] ) ;
89387: LD_ADDR_VAR 0 11
89391: PUSH
89392: LD_VAR 0 11
89396: PPUSH
89397: LD_VAR 0 11
89401: PUSH
89402: LD_INT 1
89404: PLUS
89405: PPUSH
89406: LD_VAR 0 9
89410: PUSH
89411: LD_VAR 0 3
89415: ARRAY
89416: PPUSH
89417: CALL_OW 2
89421: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
89422: LD_ADDR_VAR 0 4
89426: PUSH
89427: LD_VAR 0 4
89431: PUSH
89432: LD_VAR 0 9
89436: PUSH
89437: LD_VAR 0 3
89441: ARRAY
89442: DIFF
89443: ST_TO_ADDR
// end ;
89444: GO 89353
89446: POP
89447: POP
// if p then
89448: LD_VAR 0 11
89452: IFFALSE 89477
// result := Replace ( result , 3 , p ) ;
89454: LD_ADDR_VAR 0 2
89458: PUSH
89459: LD_VAR 0 2
89463: PPUSH
89464: LD_INT 3
89466: PPUSH
89467: LD_VAR 0 11
89471: PPUSH
89472: CALL_OW 1
89476: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
89477: LD_ADDR_VAR 0 4
89481: PUSH
89482: LD_VAR 0 4
89486: PUSH
89487: LD_VAR 0 6
89491: DIFF
89492: ST_TO_ADDR
// if tmp and eng < 4 then
89493: LD_VAR 0 4
89497: PUSH
89498: LD_VAR 0 6
89502: PUSH
89503: LD_INT 4
89505: LESS
89506: AND
89507: IFFALSE 89697
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
89509: LD_ADDR_VAR 0 9
89513: PUSH
89514: LD_VAR 0 4
89518: PUSH
89519: LD_VAR 0 7
89523: PUSH
89524: LD_VAR 0 6
89528: UNION
89529: DIFF
89530: PPUSH
89531: LD_INT 2
89533: PPUSH
89534: CALL 53978 0 2
89538: ST_TO_ADDR
// p := [ ] ;
89539: LD_ADDR_VAR 0 11
89543: PUSH
89544: EMPTY
89545: ST_TO_ADDR
// if sort then
89546: LD_VAR 0 9
89550: IFFALSE 89666
// for i = 1 to 4 - eng do
89552: LD_ADDR_VAR 0 3
89556: PUSH
89557: DOUBLE
89558: LD_INT 1
89560: DEC
89561: ST_TO_ADDR
89562: LD_INT 4
89564: PUSH
89565: LD_VAR 0 6
89569: MINUS
89570: PUSH
89571: FOR_TO
89572: IFFALSE 89664
// begin if i = sort then
89574: LD_VAR 0 3
89578: PUSH
89579: LD_VAR 0 9
89583: EQUAL
89584: IFFALSE 89588
// break ;
89586: GO 89664
// if GetClass ( i ) = 2 then
89588: LD_VAR 0 3
89592: PPUSH
89593: CALL_OW 257
89597: PUSH
89598: LD_INT 2
89600: EQUAL
89601: IFFALSE 89605
// continue ;
89603: GO 89571
// p := Insert ( p , p + 1 , sort [ i ] ) ;
89605: LD_ADDR_VAR 0 11
89609: PUSH
89610: LD_VAR 0 11
89614: PPUSH
89615: LD_VAR 0 11
89619: PUSH
89620: LD_INT 1
89622: PLUS
89623: PPUSH
89624: LD_VAR 0 9
89628: PUSH
89629: LD_VAR 0 3
89633: ARRAY
89634: PPUSH
89635: CALL_OW 2
89639: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
89640: LD_ADDR_VAR 0 4
89644: PUSH
89645: LD_VAR 0 4
89649: PUSH
89650: LD_VAR 0 9
89654: PUSH
89655: LD_VAR 0 3
89659: ARRAY
89660: DIFF
89661: ST_TO_ADDR
// end ;
89662: GO 89571
89664: POP
89665: POP
// if p then
89666: LD_VAR 0 11
89670: IFFALSE 89695
// result := Replace ( result , 2 , p ) ;
89672: LD_ADDR_VAR 0 2
89676: PUSH
89677: LD_VAR 0 2
89681: PPUSH
89682: LD_INT 2
89684: PPUSH
89685: LD_VAR 0 11
89689: PPUSH
89690: CALL_OW 1
89694: ST_TO_ADDR
// end else
89695: GO 89741
// for i = eng downto 5 do
89697: LD_ADDR_VAR 0 3
89701: PUSH
89702: DOUBLE
89703: LD_VAR 0 6
89707: INC
89708: ST_TO_ADDR
89709: LD_INT 5
89711: PUSH
89712: FOR_DOWNTO
89713: IFFALSE 89739
// tmp := tmp union eng [ i ] ;
89715: LD_ADDR_VAR 0 4
89719: PUSH
89720: LD_VAR 0 4
89724: PUSH
89725: LD_VAR 0 6
89729: PUSH
89730: LD_VAR 0 3
89734: ARRAY
89735: UNION
89736: ST_TO_ADDR
89737: GO 89712
89739: POP
89740: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
89741: LD_ADDR_VAR 0 2
89745: PUSH
89746: LD_VAR 0 2
89750: PPUSH
89751: LD_INT 1
89753: PPUSH
89754: LD_VAR 0 4
89758: PUSH
89759: LD_VAR 0 5
89763: DIFF
89764: PPUSH
89765: CALL_OW 1
89769: ST_TO_ADDR
// exit ;
89770: GO 89772
// end ; end ;
89772: LD_VAR 0 2
89776: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
89777: LD_INT 0
89779: PPUSH
89780: PPUSH
89781: PPUSH
// if not mc_bases then
89782: LD_EXP 172
89786: NOT
89787: IFFALSE 89791
// exit ;
89789: GO 89897
// for i = 1 to mc_bases do
89791: LD_ADDR_VAR 0 2
89795: PUSH
89796: DOUBLE
89797: LD_INT 1
89799: DEC
89800: ST_TO_ADDR
89801: LD_EXP 172
89805: PUSH
89806: FOR_TO
89807: IFFALSE 89888
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
89809: LD_ADDR_VAR 0 3
89813: PUSH
89814: LD_EXP 172
89818: PUSH
89819: LD_VAR 0 2
89823: ARRAY
89824: PPUSH
89825: LD_INT 21
89827: PUSH
89828: LD_INT 3
89830: PUSH
89831: EMPTY
89832: LIST
89833: LIST
89834: PUSH
89835: LD_INT 3
89837: PUSH
89838: LD_INT 24
89840: PUSH
89841: LD_INT 1000
89843: PUSH
89844: EMPTY
89845: LIST
89846: LIST
89847: PUSH
89848: EMPTY
89849: LIST
89850: LIST
89851: PUSH
89852: EMPTY
89853: LIST
89854: LIST
89855: PPUSH
89856: CALL_OW 72
89860: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
89861: LD_ADDR_EXP 173
89865: PUSH
89866: LD_EXP 173
89870: PPUSH
89871: LD_VAR 0 2
89875: PPUSH
89876: LD_VAR 0 3
89880: PPUSH
89881: CALL_OW 1
89885: ST_TO_ADDR
// end ;
89886: GO 89806
89888: POP
89889: POP
// RaiseSailEvent ( 101 ) ;
89890: LD_INT 101
89892: PPUSH
89893: CALL_OW 427
// end ;
89897: LD_VAR 0 1
89901: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
89902: LD_INT 0
89904: PPUSH
89905: PPUSH
89906: PPUSH
89907: PPUSH
89908: PPUSH
89909: PPUSH
89910: PPUSH
// if not mc_bases then
89911: LD_EXP 172
89915: NOT
89916: IFFALSE 89920
// exit ;
89918: GO 90482
// for i = 1 to mc_bases do
89920: LD_ADDR_VAR 0 2
89924: PUSH
89925: DOUBLE
89926: LD_INT 1
89928: DEC
89929: ST_TO_ADDR
89930: LD_EXP 172
89934: PUSH
89935: FOR_TO
89936: IFFALSE 90473
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
89938: LD_ADDR_VAR 0 5
89942: PUSH
89943: LD_EXP 172
89947: PUSH
89948: LD_VAR 0 2
89952: ARRAY
89953: PUSH
89954: LD_EXP 201
89958: PUSH
89959: LD_VAR 0 2
89963: ARRAY
89964: UNION
89965: PPUSH
89966: LD_INT 21
89968: PUSH
89969: LD_INT 1
89971: PUSH
89972: EMPTY
89973: LIST
89974: LIST
89975: PUSH
89976: LD_INT 1
89978: PUSH
89979: LD_INT 3
89981: PUSH
89982: LD_INT 54
89984: PUSH
89985: EMPTY
89986: LIST
89987: PUSH
89988: EMPTY
89989: LIST
89990: LIST
89991: PUSH
89992: LD_INT 3
89994: PUSH
89995: LD_INT 24
89997: PUSH
89998: LD_INT 1000
90000: PUSH
90001: EMPTY
90002: LIST
90003: LIST
90004: PUSH
90005: EMPTY
90006: LIST
90007: LIST
90008: PUSH
90009: EMPTY
90010: LIST
90011: LIST
90012: LIST
90013: PUSH
90014: EMPTY
90015: LIST
90016: LIST
90017: PPUSH
90018: CALL_OW 72
90022: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
90023: LD_ADDR_VAR 0 6
90027: PUSH
90028: LD_EXP 172
90032: PUSH
90033: LD_VAR 0 2
90037: ARRAY
90038: PPUSH
90039: LD_INT 21
90041: PUSH
90042: LD_INT 1
90044: PUSH
90045: EMPTY
90046: LIST
90047: LIST
90048: PUSH
90049: LD_INT 1
90051: PUSH
90052: LD_INT 3
90054: PUSH
90055: LD_INT 54
90057: PUSH
90058: EMPTY
90059: LIST
90060: PUSH
90061: EMPTY
90062: LIST
90063: LIST
90064: PUSH
90065: LD_INT 3
90067: PUSH
90068: LD_INT 24
90070: PUSH
90071: LD_INT 250
90073: PUSH
90074: EMPTY
90075: LIST
90076: LIST
90077: PUSH
90078: EMPTY
90079: LIST
90080: LIST
90081: PUSH
90082: EMPTY
90083: LIST
90084: LIST
90085: LIST
90086: PUSH
90087: EMPTY
90088: LIST
90089: LIST
90090: PPUSH
90091: CALL_OW 72
90095: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
90096: LD_ADDR_VAR 0 7
90100: PUSH
90101: LD_VAR 0 5
90105: PUSH
90106: LD_VAR 0 6
90110: DIFF
90111: ST_TO_ADDR
// if not need_heal_1 then
90112: LD_VAR 0 6
90116: NOT
90117: IFFALSE 90150
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
90119: LD_ADDR_EXP 175
90123: PUSH
90124: LD_EXP 175
90128: PPUSH
90129: LD_VAR 0 2
90133: PUSH
90134: LD_INT 1
90136: PUSH
90137: EMPTY
90138: LIST
90139: LIST
90140: PPUSH
90141: EMPTY
90142: PPUSH
90143: CALL 24096 0 3
90147: ST_TO_ADDR
90148: GO 90220
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
90150: LD_ADDR_EXP 175
90154: PUSH
90155: LD_EXP 175
90159: PPUSH
90160: LD_VAR 0 2
90164: PUSH
90165: LD_INT 1
90167: PUSH
90168: EMPTY
90169: LIST
90170: LIST
90171: PPUSH
90172: LD_EXP 175
90176: PUSH
90177: LD_VAR 0 2
90181: ARRAY
90182: PUSH
90183: LD_INT 1
90185: ARRAY
90186: PPUSH
90187: LD_INT 3
90189: PUSH
90190: LD_INT 24
90192: PUSH
90193: LD_INT 1000
90195: PUSH
90196: EMPTY
90197: LIST
90198: LIST
90199: PUSH
90200: EMPTY
90201: LIST
90202: LIST
90203: PPUSH
90204: CALL_OW 72
90208: PUSH
90209: LD_VAR 0 6
90213: UNION
90214: PPUSH
90215: CALL 24096 0 3
90219: ST_TO_ADDR
// if not need_heal_2 then
90220: LD_VAR 0 7
90224: NOT
90225: IFFALSE 90258
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
90227: LD_ADDR_EXP 175
90231: PUSH
90232: LD_EXP 175
90236: PPUSH
90237: LD_VAR 0 2
90241: PUSH
90242: LD_INT 2
90244: PUSH
90245: EMPTY
90246: LIST
90247: LIST
90248: PPUSH
90249: EMPTY
90250: PPUSH
90251: CALL 24096 0 3
90255: ST_TO_ADDR
90256: GO 90290
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
90258: LD_ADDR_EXP 175
90262: PUSH
90263: LD_EXP 175
90267: PPUSH
90268: LD_VAR 0 2
90272: PUSH
90273: LD_INT 2
90275: PUSH
90276: EMPTY
90277: LIST
90278: LIST
90279: PPUSH
90280: LD_VAR 0 7
90284: PPUSH
90285: CALL 24096 0 3
90289: ST_TO_ADDR
// if need_heal_2 then
90290: LD_VAR 0 7
90294: IFFALSE 90455
// for j in need_heal_2 do
90296: LD_ADDR_VAR 0 3
90300: PUSH
90301: LD_VAR 0 7
90305: PUSH
90306: FOR_IN
90307: IFFALSE 90453
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
90309: LD_ADDR_VAR 0 5
90313: PUSH
90314: LD_EXP 172
90318: PUSH
90319: LD_VAR 0 2
90323: ARRAY
90324: PPUSH
90325: LD_INT 2
90327: PUSH
90328: LD_INT 30
90330: PUSH
90331: LD_INT 6
90333: PUSH
90334: EMPTY
90335: LIST
90336: LIST
90337: PUSH
90338: LD_INT 30
90340: PUSH
90341: LD_INT 7
90343: PUSH
90344: EMPTY
90345: LIST
90346: LIST
90347: PUSH
90348: LD_INT 30
90350: PUSH
90351: LD_INT 8
90353: PUSH
90354: EMPTY
90355: LIST
90356: LIST
90357: PUSH
90358: LD_INT 30
90360: PUSH
90361: LD_INT 0
90363: PUSH
90364: EMPTY
90365: LIST
90366: LIST
90367: PUSH
90368: LD_INT 30
90370: PUSH
90371: LD_INT 1
90373: PUSH
90374: EMPTY
90375: LIST
90376: LIST
90377: PUSH
90378: EMPTY
90379: LIST
90380: LIST
90381: LIST
90382: LIST
90383: LIST
90384: LIST
90385: PPUSH
90386: CALL_OW 72
90390: ST_TO_ADDR
// if tmp then
90391: LD_VAR 0 5
90395: IFFALSE 90451
// begin k := NearestUnitToUnit ( tmp , j ) ;
90397: LD_ADDR_VAR 0 4
90401: PUSH
90402: LD_VAR 0 5
90406: PPUSH
90407: LD_VAR 0 3
90411: PPUSH
90412: CALL_OW 74
90416: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
90417: LD_VAR 0 3
90421: PPUSH
90422: LD_VAR 0 4
90426: PPUSH
90427: CALL_OW 296
90431: PUSH
90432: LD_INT 5
90434: GREATER
90435: IFFALSE 90451
// ComMoveToNearbyEntrance ( j , k ) ;
90437: LD_VAR 0 3
90441: PPUSH
90442: LD_VAR 0 4
90446: PPUSH
90447: CALL 56339 0 2
// end ; end ;
90451: GO 90306
90453: POP
90454: POP
// if not need_heal_1 and not need_heal_2 then
90455: LD_VAR 0 6
90459: NOT
90460: PUSH
90461: LD_VAR 0 7
90465: NOT
90466: AND
90467: IFFALSE 90471
// continue ;
90469: GO 89935
// end ;
90471: GO 89935
90473: POP
90474: POP
// RaiseSailEvent ( 102 ) ;
90475: LD_INT 102
90477: PPUSH
90478: CALL_OW 427
// end ;
90482: LD_VAR 0 1
90486: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
90487: LD_INT 0
90489: PPUSH
90490: PPUSH
90491: PPUSH
90492: PPUSH
90493: PPUSH
90494: PPUSH
90495: PPUSH
90496: PPUSH
// if not mc_bases then
90497: LD_EXP 172
90501: NOT
90502: IFFALSE 90506
// exit ;
90504: GO 91367
// for i = 1 to mc_bases do
90506: LD_ADDR_VAR 0 2
90510: PUSH
90511: DOUBLE
90512: LD_INT 1
90514: DEC
90515: ST_TO_ADDR
90516: LD_EXP 172
90520: PUSH
90521: FOR_TO
90522: IFFALSE 91365
// begin if not mc_building_need_repair [ i ] then
90524: LD_EXP 173
90528: PUSH
90529: LD_VAR 0 2
90533: ARRAY
90534: NOT
90535: IFFALSE 90722
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
90537: LD_ADDR_VAR 0 6
90541: PUSH
90542: LD_EXP 191
90546: PUSH
90547: LD_VAR 0 2
90551: ARRAY
90552: PPUSH
90553: LD_INT 3
90555: PUSH
90556: LD_INT 24
90558: PUSH
90559: LD_INT 1000
90561: PUSH
90562: EMPTY
90563: LIST
90564: LIST
90565: PUSH
90566: EMPTY
90567: LIST
90568: LIST
90569: PUSH
90570: LD_INT 2
90572: PUSH
90573: LD_INT 34
90575: PUSH
90576: LD_INT 13
90578: PUSH
90579: EMPTY
90580: LIST
90581: LIST
90582: PUSH
90583: LD_INT 34
90585: PUSH
90586: LD_INT 52
90588: PUSH
90589: EMPTY
90590: LIST
90591: LIST
90592: PUSH
90593: LD_INT 34
90595: PUSH
90596: LD_EXP 160
90600: PUSH
90601: EMPTY
90602: LIST
90603: LIST
90604: PUSH
90605: EMPTY
90606: LIST
90607: LIST
90608: LIST
90609: LIST
90610: PUSH
90611: EMPTY
90612: LIST
90613: LIST
90614: PPUSH
90615: CALL_OW 72
90619: ST_TO_ADDR
// if cranes then
90620: LD_VAR 0 6
90624: IFFALSE 90686
// for j in cranes do
90626: LD_ADDR_VAR 0 3
90630: PUSH
90631: LD_VAR 0 6
90635: PUSH
90636: FOR_IN
90637: IFFALSE 90684
// if not IsInArea ( j , mc_parking [ i ] ) then
90639: LD_VAR 0 3
90643: PPUSH
90644: LD_EXP 196
90648: PUSH
90649: LD_VAR 0 2
90653: ARRAY
90654: PPUSH
90655: CALL_OW 308
90659: NOT
90660: IFFALSE 90682
// ComMoveToArea ( j , mc_parking [ i ] ) ;
90662: LD_VAR 0 3
90666: PPUSH
90667: LD_EXP 196
90671: PUSH
90672: LD_VAR 0 2
90676: ARRAY
90677: PPUSH
90678: CALL_OW 113
90682: GO 90636
90684: POP
90685: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
90686: LD_ADDR_EXP 174
90690: PUSH
90691: LD_EXP 174
90695: PPUSH
90696: LD_VAR 0 2
90700: PPUSH
90701: EMPTY
90702: PPUSH
90703: CALL_OW 1
90707: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
90708: LD_VAR 0 2
90712: PPUSH
90713: LD_INT 101
90715: PPUSH
90716: CALL 85610 0 2
// continue ;
90720: GO 90521
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
90722: LD_ADDR_EXP 178
90726: PUSH
90727: LD_EXP 178
90731: PPUSH
90732: LD_VAR 0 2
90736: PPUSH
90737: EMPTY
90738: PPUSH
90739: CALL_OW 1
90743: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
90744: LD_VAR 0 2
90748: PPUSH
90749: LD_INT 103
90751: PPUSH
90752: CALL 85610 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
90756: LD_ADDR_VAR 0 5
90760: PUSH
90761: LD_EXP 172
90765: PUSH
90766: LD_VAR 0 2
90770: ARRAY
90771: PUSH
90772: LD_EXP 201
90776: PUSH
90777: LD_VAR 0 2
90781: ARRAY
90782: UNION
90783: PPUSH
90784: LD_INT 2
90786: PUSH
90787: LD_INT 25
90789: PUSH
90790: LD_INT 2
90792: PUSH
90793: EMPTY
90794: LIST
90795: LIST
90796: PUSH
90797: LD_INT 25
90799: PUSH
90800: LD_INT 16
90802: PUSH
90803: EMPTY
90804: LIST
90805: LIST
90806: PUSH
90807: EMPTY
90808: LIST
90809: LIST
90810: LIST
90811: PUSH
90812: EMPTY
90813: LIST
90814: PPUSH
90815: CALL_OW 72
90819: PUSH
90820: LD_EXP 175
90824: PUSH
90825: LD_VAR 0 2
90829: ARRAY
90830: PUSH
90831: LD_INT 1
90833: ARRAY
90834: PUSH
90835: LD_EXP 175
90839: PUSH
90840: LD_VAR 0 2
90844: ARRAY
90845: PUSH
90846: LD_INT 2
90848: ARRAY
90849: UNION
90850: DIFF
90851: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
90852: LD_ADDR_VAR 0 6
90856: PUSH
90857: LD_EXP 191
90861: PUSH
90862: LD_VAR 0 2
90866: ARRAY
90867: PPUSH
90868: LD_INT 2
90870: PUSH
90871: LD_INT 34
90873: PUSH
90874: LD_INT 13
90876: PUSH
90877: EMPTY
90878: LIST
90879: LIST
90880: PUSH
90881: LD_INT 34
90883: PUSH
90884: LD_INT 52
90886: PUSH
90887: EMPTY
90888: LIST
90889: LIST
90890: PUSH
90891: LD_INT 34
90893: PUSH
90894: LD_EXP 160
90898: PUSH
90899: EMPTY
90900: LIST
90901: LIST
90902: PUSH
90903: EMPTY
90904: LIST
90905: LIST
90906: LIST
90907: LIST
90908: PPUSH
90909: CALL_OW 72
90913: ST_TO_ADDR
// if cranes then
90914: LD_VAR 0 6
90918: IFFALSE 91054
// begin for j in cranes do
90920: LD_ADDR_VAR 0 3
90924: PUSH
90925: LD_VAR 0 6
90929: PUSH
90930: FOR_IN
90931: IFFALSE 91052
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
90933: LD_VAR 0 3
90937: PPUSH
90938: CALL_OW 256
90942: PUSH
90943: LD_INT 1000
90945: EQUAL
90946: PUSH
90947: LD_VAR 0 3
90951: PPUSH
90952: CALL_OW 314
90956: NOT
90957: AND
90958: IFFALSE 90992
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) else
90960: LD_VAR 0 3
90964: PPUSH
90965: LD_EXP 173
90969: PUSH
90970: LD_VAR 0 2
90974: ARRAY
90975: PPUSH
90976: LD_VAR 0 3
90980: PPUSH
90981: CALL_OW 74
90985: PPUSH
90986: CALL_OW 130
90990: GO 91050
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
90992: LD_VAR 0 3
90996: PPUSH
90997: CALL_OW 256
91001: PUSH
91002: LD_INT 500
91004: LESS
91005: PUSH
91006: LD_VAR 0 3
91010: PPUSH
91011: LD_EXP 196
91015: PUSH
91016: LD_VAR 0 2
91020: ARRAY
91021: PPUSH
91022: CALL_OW 308
91026: NOT
91027: AND
91028: IFFALSE 91050
// ComMoveToArea ( j , mc_parking [ i ] ) ;
91030: LD_VAR 0 3
91034: PPUSH
91035: LD_EXP 196
91039: PUSH
91040: LD_VAR 0 2
91044: ARRAY
91045: PPUSH
91046: CALL_OW 113
// end ;
91050: GO 90930
91052: POP
91053: POP
// end ; if tmp > 3 then
91054: LD_VAR 0 5
91058: PUSH
91059: LD_INT 3
91061: GREATER
91062: IFFALSE 91082
// tmp := ShrinkArray ( tmp , 4 ) ;
91064: LD_ADDR_VAR 0 5
91068: PUSH
91069: LD_VAR 0 5
91073: PPUSH
91074: LD_INT 4
91076: PPUSH
91077: CALL 55787 0 2
91081: ST_TO_ADDR
// if not tmp then
91082: LD_VAR 0 5
91086: NOT
91087: IFFALSE 91091
// continue ;
91089: GO 90521
// for j in tmp do
91091: LD_ADDR_VAR 0 3
91095: PUSH
91096: LD_VAR 0 5
91100: PUSH
91101: FOR_IN
91102: IFFALSE 91361
// begin if IsInUnit ( j ) then
91104: LD_VAR 0 3
91108: PPUSH
91109: CALL_OW 310
91113: IFFALSE 91124
// ComExitBuilding ( j ) ;
91115: LD_VAR 0 3
91119: PPUSH
91120: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
91124: LD_VAR 0 3
91128: PUSH
91129: LD_EXP 174
91133: PUSH
91134: LD_VAR 0 2
91138: ARRAY
91139: IN
91140: NOT
91141: IFFALSE 91199
// begin SetTag ( j , 101 ) ;
91143: LD_VAR 0 3
91147: PPUSH
91148: LD_INT 101
91150: PPUSH
91151: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
91155: LD_ADDR_EXP 174
91159: PUSH
91160: LD_EXP 174
91164: PPUSH
91165: LD_VAR 0 2
91169: PUSH
91170: LD_EXP 174
91174: PUSH
91175: LD_VAR 0 2
91179: ARRAY
91180: PUSH
91181: LD_INT 1
91183: PLUS
91184: PUSH
91185: EMPTY
91186: LIST
91187: LIST
91188: PPUSH
91189: LD_VAR 0 3
91193: PPUSH
91194: CALL 24096 0 3
91198: ST_TO_ADDR
// end ; wait ( 1 ) ;
91199: LD_INT 1
91201: PPUSH
91202: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
91206: LD_ADDR_VAR 0 7
91210: PUSH
91211: LD_EXP 173
91215: PUSH
91216: LD_VAR 0 2
91220: ARRAY
91221: ST_TO_ADDR
// if mc_scan [ i ] then
91222: LD_EXP 195
91226: PUSH
91227: LD_VAR 0 2
91231: ARRAY
91232: IFFALSE 91294
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
91234: LD_ADDR_VAR 0 7
91238: PUSH
91239: LD_EXP 173
91243: PUSH
91244: LD_VAR 0 2
91248: ARRAY
91249: PPUSH
91250: LD_INT 3
91252: PUSH
91253: LD_INT 30
91255: PUSH
91256: LD_INT 32
91258: PUSH
91259: EMPTY
91260: LIST
91261: LIST
91262: PUSH
91263: LD_INT 30
91265: PUSH
91266: LD_INT 33
91268: PUSH
91269: EMPTY
91270: LIST
91271: LIST
91272: PUSH
91273: LD_INT 30
91275: PUSH
91276: LD_INT 31
91278: PUSH
91279: EMPTY
91280: LIST
91281: LIST
91282: PUSH
91283: EMPTY
91284: LIST
91285: LIST
91286: LIST
91287: LIST
91288: PPUSH
91289: CALL_OW 72
91293: ST_TO_ADDR
// if not to_repair_tmp then
91294: LD_VAR 0 7
91298: NOT
91299: IFFALSE 91303
// continue ;
91301: GO 91101
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
91303: LD_ADDR_VAR 0 8
91307: PUSH
91308: LD_VAR 0 7
91312: PPUSH
91313: LD_VAR 0 3
91317: PPUSH
91318: CALL_OW 74
91322: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
91323: LD_VAR 0 8
91327: PPUSH
91328: LD_INT 16
91330: PPUSH
91331: CALL 26689 0 2
91335: PUSH
91336: LD_INT 4
91338: ARRAY
91339: PUSH
91340: LD_INT 10
91342: LESS
91343: IFFALSE 91359
// ComRepairBuilding ( j , to_repair ) ;
91345: LD_VAR 0 3
91349: PPUSH
91350: LD_VAR 0 8
91354: PPUSH
91355: CALL_OW 130
// end ;
91359: GO 91101
91361: POP
91362: POP
// end ;
91363: GO 90521
91365: POP
91366: POP
// end ;
91367: LD_VAR 0 1
91371: RET
// export function MC_Heal ; var i , j , tmp ; begin
91372: LD_INT 0
91374: PPUSH
91375: PPUSH
91376: PPUSH
91377: PPUSH
// if not mc_bases then
91378: LD_EXP 172
91382: NOT
91383: IFFALSE 91387
// exit ;
91385: GO 91789
// for i = 1 to mc_bases do
91387: LD_ADDR_VAR 0 2
91391: PUSH
91392: DOUBLE
91393: LD_INT 1
91395: DEC
91396: ST_TO_ADDR
91397: LD_EXP 172
91401: PUSH
91402: FOR_TO
91403: IFFALSE 91787
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
91405: LD_EXP 175
91409: PUSH
91410: LD_VAR 0 2
91414: ARRAY
91415: PUSH
91416: LD_INT 1
91418: ARRAY
91419: NOT
91420: PUSH
91421: LD_EXP 175
91425: PUSH
91426: LD_VAR 0 2
91430: ARRAY
91431: PUSH
91432: LD_INT 2
91434: ARRAY
91435: NOT
91436: AND
91437: IFFALSE 91475
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
91439: LD_ADDR_EXP 176
91443: PUSH
91444: LD_EXP 176
91448: PPUSH
91449: LD_VAR 0 2
91453: PPUSH
91454: EMPTY
91455: PPUSH
91456: CALL_OW 1
91460: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
91461: LD_VAR 0 2
91465: PPUSH
91466: LD_INT 102
91468: PPUSH
91469: CALL 85610 0 2
// continue ;
91473: GO 91402
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
91475: LD_ADDR_VAR 0 4
91479: PUSH
91480: LD_EXP 172
91484: PUSH
91485: LD_VAR 0 2
91489: ARRAY
91490: PPUSH
91491: LD_INT 25
91493: PUSH
91494: LD_INT 4
91496: PUSH
91497: EMPTY
91498: LIST
91499: LIST
91500: PPUSH
91501: CALL_OW 72
91505: ST_TO_ADDR
// if not tmp then
91506: LD_VAR 0 4
91510: NOT
91511: IFFALSE 91515
// continue ;
91513: GO 91402
// if mc_taming [ i ] then
91515: LD_EXP 203
91519: PUSH
91520: LD_VAR 0 2
91524: ARRAY
91525: IFFALSE 91549
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
91527: LD_ADDR_EXP 203
91531: PUSH
91532: LD_EXP 203
91536: PPUSH
91537: LD_VAR 0 2
91541: PPUSH
91542: EMPTY
91543: PPUSH
91544: CALL_OW 1
91548: ST_TO_ADDR
// for j in tmp do
91549: LD_ADDR_VAR 0 3
91553: PUSH
91554: LD_VAR 0 4
91558: PUSH
91559: FOR_IN
91560: IFFALSE 91783
// begin if IsInUnit ( j ) then
91562: LD_VAR 0 3
91566: PPUSH
91567: CALL_OW 310
91571: IFFALSE 91582
// ComExitBuilding ( j ) ;
91573: LD_VAR 0 3
91577: PPUSH
91578: CALL_OW 122
// if not j in mc_healers [ i ] then
91582: LD_VAR 0 3
91586: PUSH
91587: LD_EXP 176
91591: PUSH
91592: LD_VAR 0 2
91596: ARRAY
91597: IN
91598: NOT
91599: IFFALSE 91645
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
91601: LD_ADDR_EXP 176
91605: PUSH
91606: LD_EXP 176
91610: PPUSH
91611: LD_VAR 0 2
91615: PUSH
91616: LD_EXP 176
91620: PUSH
91621: LD_VAR 0 2
91625: ARRAY
91626: PUSH
91627: LD_INT 1
91629: PLUS
91630: PUSH
91631: EMPTY
91632: LIST
91633: LIST
91634: PPUSH
91635: LD_VAR 0 3
91639: PPUSH
91640: CALL 24096 0 3
91644: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
91645: LD_VAR 0 3
91649: PPUSH
91650: CALL_OW 110
91654: PUSH
91655: LD_INT 102
91657: NONEQUAL
91658: IFFALSE 91672
// SetTag ( j , 102 ) ;
91660: LD_VAR 0 3
91664: PPUSH
91665: LD_INT 102
91667: PPUSH
91668: CALL_OW 109
// Wait ( 3 ) ;
91672: LD_INT 3
91674: PPUSH
91675: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
91679: LD_EXP 175
91683: PUSH
91684: LD_VAR 0 2
91688: ARRAY
91689: PUSH
91690: LD_INT 1
91692: ARRAY
91693: IFFALSE 91725
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
91695: LD_VAR 0 3
91699: PPUSH
91700: LD_EXP 175
91704: PUSH
91705: LD_VAR 0 2
91709: ARRAY
91710: PUSH
91711: LD_INT 1
91713: ARRAY
91714: PUSH
91715: LD_INT 1
91717: ARRAY
91718: PPUSH
91719: CALL_OW 128
91723: GO 91781
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
91725: LD_VAR 0 3
91729: PPUSH
91730: CALL_OW 314
91734: NOT
91735: PUSH
91736: LD_EXP 175
91740: PUSH
91741: LD_VAR 0 2
91745: ARRAY
91746: PUSH
91747: LD_INT 2
91749: ARRAY
91750: AND
91751: IFFALSE 91781
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
91753: LD_VAR 0 3
91757: PPUSH
91758: LD_EXP 175
91762: PUSH
91763: LD_VAR 0 2
91767: ARRAY
91768: PUSH
91769: LD_INT 2
91771: ARRAY
91772: PUSH
91773: LD_INT 1
91775: ARRAY
91776: PPUSH
91777: CALL_OW 128
// end ;
91781: GO 91559
91783: POP
91784: POP
// end ;
91785: GO 91402
91787: POP
91788: POP
// end ;
91789: LD_VAR 0 1
91793: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
91794: LD_INT 0
91796: PPUSH
91797: PPUSH
91798: PPUSH
91799: PPUSH
91800: PPUSH
// if not mc_bases then
91801: LD_EXP 172
91805: NOT
91806: IFFALSE 91810
// exit ;
91808: GO 92981
// for i = 1 to mc_bases do
91810: LD_ADDR_VAR 0 2
91814: PUSH
91815: DOUBLE
91816: LD_INT 1
91818: DEC
91819: ST_TO_ADDR
91820: LD_EXP 172
91824: PUSH
91825: FOR_TO
91826: IFFALSE 92979
// begin if mc_scan [ i ] then
91828: LD_EXP 195
91832: PUSH
91833: LD_VAR 0 2
91837: ARRAY
91838: IFFALSE 91842
// continue ;
91840: GO 91825
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
91842: LD_EXP 177
91846: PUSH
91847: LD_VAR 0 2
91851: ARRAY
91852: NOT
91853: PUSH
91854: LD_EXP 179
91858: PUSH
91859: LD_VAR 0 2
91863: ARRAY
91864: NOT
91865: AND
91866: PUSH
91867: LD_EXP 178
91871: PUSH
91872: LD_VAR 0 2
91876: ARRAY
91877: AND
91878: IFFALSE 91916
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
91880: LD_ADDR_EXP 178
91884: PUSH
91885: LD_EXP 178
91889: PPUSH
91890: LD_VAR 0 2
91894: PPUSH
91895: EMPTY
91896: PPUSH
91897: CALL_OW 1
91901: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
91902: LD_VAR 0 2
91906: PPUSH
91907: LD_INT 103
91909: PPUSH
91910: CALL 85610 0 2
// continue ;
91914: GO 91825
// end ; if mc_construct_list [ i ] then
91916: LD_EXP 179
91920: PUSH
91921: LD_VAR 0 2
91925: ARRAY
91926: IFFALSE 92146
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
91928: LD_ADDR_VAR 0 4
91932: PUSH
91933: LD_EXP 172
91937: PUSH
91938: LD_VAR 0 2
91942: ARRAY
91943: PPUSH
91944: LD_INT 25
91946: PUSH
91947: LD_INT 2
91949: PUSH
91950: EMPTY
91951: LIST
91952: LIST
91953: PPUSH
91954: CALL_OW 72
91958: PUSH
91959: LD_EXP 174
91963: PUSH
91964: LD_VAR 0 2
91968: ARRAY
91969: DIFF
91970: ST_TO_ADDR
// if not tmp then
91971: LD_VAR 0 4
91975: NOT
91976: IFFALSE 91980
// continue ;
91978: GO 91825
// for j in tmp do
91980: LD_ADDR_VAR 0 3
91984: PUSH
91985: LD_VAR 0 4
91989: PUSH
91990: FOR_IN
91991: IFFALSE 92142
// begin if not mc_builders [ i ] then
91993: LD_EXP 178
91997: PUSH
91998: LD_VAR 0 2
92002: ARRAY
92003: NOT
92004: IFFALSE 92062
// begin SetTag ( j , 103 ) ;
92006: LD_VAR 0 3
92010: PPUSH
92011: LD_INT 103
92013: PPUSH
92014: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
92018: LD_ADDR_EXP 178
92022: PUSH
92023: LD_EXP 178
92027: PPUSH
92028: LD_VAR 0 2
92032: PUSH
92033: LD_EXP 178
92037: PUSH
92038: LD_VAR 0 2
92042: ARRAY
92043: PUSH
92044: LD_INT 1
92046: PLUS
92047: PUSH
92048: EMPTY
92049: LIST
92050: LIST
92051: PPUSH
92052: LD_VAR 0 3
92056: PPUSH
92057: CALL 24096 0 3
92061: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
92062: LD_VAR 0 3
92066: PPUSH
92067: CALL_OW 310
92071: IFFALSE 92082
// ComExitBuilding ( j ) ;
92073: LD_VAR 0 3
92077: PPUSH
92078: CALL_OW 122
// wait ( 3 ) ;
92082: LD_INT 3
92084: PPUSH
92085: CALL_OW 67
// if not mc_construct_list [ i ] then
92089: LD_EXP 179
92093: PUSH
92094: LD_VAR 0 2
92098: ARRAY
92099: NOT
92100: IFFALSE 92104
// break ;
92102: GO 92142
// if not HasTask ( j ) then
92104: LD_VAR 0 3
92108: PPUSH
92109: CALL_OW 314
92113: NOT
92114: IFFALSE 92140
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
92116: LD_VAR 0 3
92120: PPUSH
92121: LD_EXP 179
92125: PUSH
92126: LD_VAR 0 2
92130: ARRAY
92131: PUSH
92132: LD_INT 1
92134: ARRAY
92135: PPUSH
92136: CALL 26953 0 2
// end ;
92140: GO 91990
92142: POP
92143: POP
// end else
92144: GO 92977
// if mc_build_list [ i ] then
92146: LD_EXP 177
92150: PUSH
92151: LD_VAR 0 2
92155: ARRAY
92156: IFFALSE 92977
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
92158: LD_ADDR_VAR 0 5
92162: PUSH
92163: LD_EXP 172
92167: PUSH
92168: LD_VAR 0 2
92172: ARRAY
92173: PPUSH
92174: LD_INT 2
92176: PUSH
92177: LD_INT 30
92179: PUSH
92180: LD_INT 0
92182: PUSH
92183: EMPTY
92184: LIST
92185: LIST
92186: PUSH
92187: LD_INT 30
92189: PUSH
92190: LD_INT 1
92192: PUSH
92193: EMPTY
92194: LIST
92195: LIST
92196: PUSH
92197: EMPTY
92198: LIST
92199: LIST
92200: LIST
92201: PPUSH
92202: CALL_OW 72
92206: ST_TO_ADDR
// if depot then
92207: LD_VAR 0 5
92211: IFFALSE 92229
// depot := depot [ 1 ] else
92213: LD_ADDR_VAR 0 5
92217: PUSH
92218: LD_VAR 0 5
92222: PUSH
92223: LD_INT 1
92225: ARRAY
92226: ST_TO_ADDR
92227: GO 92237
// depot := 0 ;
92229: LD_ADDR_VAR 0 5
92233: PUSH
92234: LD_INT 0
92236: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
92237: LD_EXP 177
92241: PUSH
92242: LD_VAR 0 2
92246: ARRAY
92247: PUSH
92248: LD_INT 1
92250: ARRAY
92251: PUSH
92252: LD_INT 1
92254: ARRAY
92255: PPUSH
92256: CALL 26777 0 1
92260: PUSH
92261: LD_EXP 172
92265: PUSH
92266: LD_VAR 0 2
92270: ARRAY
92271: PPUSH
92272: LD_INT 2
92274: PUSH
92275: LD_INT 30
92277: PUSH
92278: LD_INT 2
92280: PUSH
92281: EMPTY
92282: LIST
92283: LIST
92284: PUSH
92285: LD_INT 30
92287: PUSH
92288: LD_INT 3
92290: PUSH
92291: EMPTY
92292: LIST
92293: LIST
92294: PUSH
92295: EMPTY
92296: LIST
92297: LIST
92298: LIST
92299: PPUSH
92300: CALL_OW 72
92304: NOT
92305: AND
92306: IFFALSE 92411
// begin for j = 1 to mc_build_list [ i ] do
92308: LD_ADDR_VAR 0 3
92312: PUSH
92313: DOUBLE
92314: LD_INT 1
92316: DEC
92317: ST_TO_ADDR
92318: LD_EXP 177
92322: PUSH
92323: LD_VAR 0 2
92327: ARRAY
92328: PUSH
92329: FOR_TO
92330: IFFALSE 92409
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
92332: LD_EXP 177
92336: PUSH
92337: LD_VAR 0 2
92341: ARRAY
92342: PUSH
92343: LD_VAR 0 3
92347: ARRAY
92348: PUSH
92349: LD_INT 1
92351: ARRAY
92352: PUSH
92353: LD_INT 2
92355: EQUAL
92356: IFFALSE 92407
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
92358: LD_ADDR_EXP 177
92362: PUSH
92363: LD_EXP 177
92367: PPUSH
92368: LD_VAR 0 2
92372: PPUSH
92373: LD_EXP 177
92377: PUSH
92378: LD_VAR 0 2
92382: ARRAY
92383: PPUSH
92384: LD_VAR 0 3
92388: PPUSH
92389: LD_INT 1
92391: PPUSH
92392: LD_INT 0
92394: PPUSH
92395: CALL 23514 0 4
92399: PPUSH
92400: CALL_OW 1
92404: ST_TO_ADDR
// break ;
92405: GO 92409
// end ;
92407: GO 92329
92409: POP
92410: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
92411: LD_EXP 177
92415: PUSH
92416: LD_VAR 0 2
92420: ARRAY
92421: PUSH
92422: LD_INT 1
92424: ARRAY
92425: PUSH
92426: LD_INT 1
92428: ARRAY
92429: PUSH
92430: LD_INT 0
92432: EQUAL
92433: PUSH
92434: LD_VAR 0 5
92438: PUSH
92439: LD_VAR 0 5
92443: PPUSH
92444: LD_EXP 177
92448: PUSH
92449: LD_VAR 0 2
92453: ARRAY
92454: PUSH
92455: LD_INT 1
92457: ARRAY
92458: PUSH
92459: LD_INT 1
92461: ARRAY
92462: PPUSH
92463: LD_EXP 177
92467: PUSH
92468: LD_VAR 0 2
92472: ARRAY
92473: PUSH
92474: LD_INT 1
92476: ARRAY
92477: PUSH
92478: LD_INT 2
92480: ARRAY
92481: PPUSH
92482: LD_EXP 177
92486: PUSH
92487: LD_VAR 0 2
92491: ARRAY
92492: PUSH
92493: LD_INT 1
92495: ARRAY
92496: PUSH
92497: LD_INT 3
92499: ARRAY
92500: PPUSH
92501: LD_EXP 177
92505: PUSH
92506: LD_VAR 0 2
92510: ARRAY
92511: PUSH
92512: LD_INT 1
92514: ARRAY
92515: PUSH
92516: LD_INT 4
92518: ARRAY
92519: PPUSH
92520: CALL 31844 0 5
92524: AND
92525: OR
92526: IFFALSE 92807
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
92528: LD_ADDR_VAR 0 4
92532: PUSH
92533: LD_EXP 172
92537: PUSH
92538: LD_VAR 0 2
92542: ARRAY
92543: PPUSH
92544: LD_INT 25
92546: PUSH
92547: LD_INT 2
92549: PUSH
92550: EMPTY
92551: LIST
92552: LIST
92553: PPUSH
92554: CALL_OW 72
92558: PUSH
92559: LD_EXP 174
92563: PUSH
92564: LD_VAR 0 2
92568: ARRAY
92569: DIFF
92570: ST_TO_ADDR
// if not tmp then
92571: LD_VAR 0 4
92575: NOT
92576: IFFALSE 92580
// continue ;
92578: GO 91825
// for j in tmp do
92580: LD_ADDR_VAR 0 3
92584: PUSH
92585: LD_VAR 0 4
92589: PUSH
92590: FOR_IN
92591: IFFALSE 92803
// begin if not mc_builders [ i ] then
92593: LD_EXP 178
92597: PUSH
92598: LD_VAR 0 2
92602: ARRAY
92603: NOT
92604: IFFALSE 92662
// begin SetTag ( j , 103 ) ;
92606: LD_VAR 0 3
92610: PPUSH
92611: LD_INT 103
92613: PPUSH
92614: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
92618: LD_ADDR_EXP 178
92622: PUSH
92623: LD_EXP 178
92627: PPUSH
92628: LD_VAR 0 2
92632: PUSH
92633: LD_EXP 178
92637: PUSH
92638: LD_VAR 0 2
92642: ARRAY
92643: PUSH
92644: LD_INT 1
92646: PLUS
92647: PUSH
92648: EMPTY
92649: LIST
92650: LIST
92651: PPUSH
92652: LD_VAR 0 3
92656: PPUSH
92657: CALL 24096 0 3
92661: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
92662: LD_VAR 0 3
92666: PPUSH
92667: CALL_OW 310
92671: IFFALSE 92682
// ComExitBuilding ( j ) ;
92673: LD_VAR 0 3
92677: PPUSH
92678: CALL_OW 122
// wait ( 3 ) ;
92682: LD_INT 3
92684: PPUSH
92685: CALL_OW 67
// if not mc_build_list [ i ] then
92689: LD_EXP 177
92693: PUSH
92694: LD_VAR 0 2
92698: ARRAY
92699: NOT
92700: IFFALSE 92704
// break ;
92702: GO 92803
// if not HasTask ( j ) then
92704: LD_VAR 0 3
92708: PPUSH
92709: CALL_OW 314
92713: NOT
92714: IFFALSE 92801
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
92716: LD_VAR 0 3
92720: PPUSH
92721: LD_EXP 177
92725: PUSH
92726: LD_VAR 0 2
92730: ARRAY
92731: PUSH
92732: LD_INT 1
92734: ARRAY
92735: PUSH
92736: LD_INT 1
92738: ARRAY
92739: PPUSH
92740: LD_EXP 177
92744: PUSH
92745: LD_VAR 0 2
92749: ARRAY
92750: PUSH
92751: LD_INT 1
92753: ARRAY
92754: PUSH
92755: LD_INT 2
92757: ARRAY
92758: PPUSH
92759: LD_EXP 177
92763: PUSH
92764: LD_VAR 0 2
92768: ARRAY
92769: PUSH
92770: LD_INT 1
92772: ARRAY
92773: PUSH
92774: LD_INT 3
92776: ARRAY
92777: PPUSH
92778: LD_EXP 177
92782: PUSH
92783: LD_VAR 0 2
92787: ARRAY
92788: PUSH
92789: LD_INT 1
92791: ARRAY
92792: PUSH
92793: LD_INT 4
92795: ARRAY
92796: PPUSH
92797: CALL_OW 145
// end ;
92801: GO 92590
92803: POP
92804: POP
// end else
92805: GO 92977
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
92807: LD_EXP 172
92811: PUSH
92812: LD_VAR 0 2
92816: ARRAY
92817: PPUSH
92818: LD_EXP 177
92822: PUSH
92823: LD_VAR 0 2
92827: ARRAY
92828: PUSH
92829: LD_INT 1
92831: ARRAY
92832: PUSH
92833: LD_INT 1
92835: ARRAY
92836: PPUSH
92837: LD_EXP 177
92841: PUSH
92842: LD_VAR 0 2
92846: ARRAY
92847: PUSH
92848: LD_INT 1
92850: ARRAY
92851: PUSH
92852: LD_INT 2
92854: ARRAY
92855: PPUSH
92856: LD_EXP 177
92860: PUSH
92861: LD_VAR 0 2
92865: ARRAY
92866: PUSH
92867: LD_INT 1
92869: ARRAY
92870: PUSH
92871: LD_INT 3
92873: ARRAY
92874: PPUSH
92875: LD_EXP 177
92879: PUSH
92880: LD_VAR 0 2
92884: ARRAY
92885: PUSH
92886: LD_INT 1
92888: ARRAY
92889: PUSH
92890: LD_INT 4
92892: ARRAY
92893: PPUSH
92894: LD_EXP 172
92898: PUSH
92899: LD_VAR 0 2
92903: ARRAY
92904: PPUSH
92905: LD_INT 21
92907: PUSH
92908: LD_INT 3
92910: PUSH
92911: EMPTY
92912: LIST
92913: LIST
92914: PPUSH
92915: CALL_OW 72
92919: PPUSH
92920: EMPTY
92921: PPUSH
92922: CALL 30974 0 7
92926: NOT
92927: IFFALSE 92977
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
92929: LD_ADDR_EXP 177
92933: PUSH
92934: LD_EXP 177
92938: PPUSH
92939: LD_VAR 0 2
92943: PPUSH
92944: LD_EXP 177
92948: PUSH
92949: LD_VAR 0 2
92953: ARRAY
92954: PPUSH
92955: LD_INT 1
92957: PPUSH
92958: LD_INT 1
92960: NEG
92961: PPUSH
92962: LD_INT 0
92964: PPUSH
92965: CALL 23514 0 4
92969: PPUSH
92970: CALL_OW 1
92974: ST_TO_ADDR
// continue ;
92975: GO 91825
// end ; end ; end ;
92977: GO 91825
92979: POP
92980: POP
// end ;
92981: LD_VAR 0 1
92985: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
92986: LD_INT 0
92988: PPUSH
92989: PPUSH
92990: PPUSH
92991: PPUSH
92992: PPUSH
92993: PPUSH
// if not mc_bases then
92994: LD_EXP 172
92998: NOT
92999: IFFALSE 93003
// exit ;
93001: GO 93430
// for i = 1 to mc_bases do
93003: LD_ADDR_VAR 0 2
93007: PUSH
93008: DOUBLE
93009: LD_INT 1
93011: DEC
93012: ST_TO_ADDR
93013: LD_EXP 172
93017: PUSH
93018: FOR_TO
93019: IFFALSE 93428
// begin tmp := mc_build_upgrade [ i ] ;
93021: LD_ADDR_VAR 0 4
93025: PUSH
93026: LD_EXP 204
93030: PUSH
93031: LD_VAR 0 2
93035: ARRAY
93036: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
93037: LD_ADDR_VAR 0 6
93041: PUSH
93042: LD_EXP 205
93046: PUSH
93047: LD_VAR 0 2
93051: ARRAY
93052: PPUSH
93053: LD_INT 2
93055: PUSH
93056: LD_INT 30
93058: PUSH
93059: LD_INT 6
93061: PUSH
93062: EMPTY
93063: LIST
93064: LIST
93065: PUSH
93066: LD_INT 30
93068: PUSH
93069: LD_INT 7
93071: PUSH
93072: EMPTY
93073: LIST
93074: LIST
93075: PUSH
93076: EMPTY
93077: LIST
93078: LIST
93079: LIST
93080: PPUSH
93081: CALL_OW 72
93085: ST_TO_ADDR
// if not tmp and not lab then
93086: LD_VAR 0 4
93090: NOT
93091: PUSH
93092: LD_VAR 0 6
93096: NOT
93097: AND
93098: IFFALSE 93102
// continue ;
93100: GO 93018
// if tmp then
93102: LD_VAR 0 4
93106: IFFALSE 93226
// for j in tmp do
93108: LD_ADDR_VAR 0 3
93112: PUSH
93113: LD_VAR 0 4
93117: PUSH
93118: FOR_IN
93119: IFFALSE 93224
// begin if UpgradeCost ( j ) then
93121: LD_VAR 0 3
93125: PPUSH
93126: CALL 30634 0 1
93130: IFFALSE 93222
// begin ComUpgrade ( j ) ;
93132: LD_VAR 0 3
93136: PPUSH
93137: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
93141: LD_ADDR_EXP 204
93145: PUSH
93146: LD_EXP 204
93150: PPUSH
93151: LD_VAR 0 2
93155: PPUSH
93156: LD_EXP 204
93160: PUSH
93161: LD_VAR 0 2
93165: ARRAY
93166: PUSH
93167: LD_VAR 0 3
93171: DIFF
93172: PPUSH
93173: CALL_OW 1
93177: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
93178: LD_ADDR_EXP 179
93182: PUSH
93183: LD_EXP 179
93187: PPUSH
93188: LD_VAR 0 2
93192: PUSH
93193: LD_EXP 179
93197: PUSH
93198: LD_VAR 0 2
93202: ARRAY
93203: PUSH
93204: LD_INT 1
93206: PLUS
93207: PUSH
93208: EMPTY
93209: LIST
93210: LIST
93211: PPUSH
93212: LD_VAR 0 3
93216: PPUSH
93217: CALL 24096 0 3
93221: ST_TO_ADDR
// end ; end ;
93222: GO 93118
93224: POP
93225: POP
// if not lab or not mc_lab_upgrade [ i ] then
93226: LD_VAR 0 6
93230: NOT
93231: PUSH
93232: LD_EXP 206
93236: PUSH
93237: LD_VAR 0 2
93241: ARRAY
93242: NOT
93243: OR
93244: IFFALSE 93248
// continue ;
93246: GO 93018
// for j in lab do
93248: LD_ADDR_VAR 0 3
93252: PUSH
93253: LD_VAR 0 6
93257: PUSH
93258: FOR_IN
93259: IFFALSE 93424
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
93261: LD_VAR 0 3
93265: PPUSH
93266: CALL_OW 266
93270: PUSH
93271: LD_INT 6
93273: PUSH
93274: LD_INT 7
93276: PUSH
93277: EMPTY
93278: LIST
93279: LIST
93280: IN
93281: PUSH
93282: LD_VAR 0 3
93286: PPUSH
93287: CALL_OW 461
93291: PUSH
93292: LD_INT 1
93294: NONEQUAL
93295: AND
93296: IFFALSE 93422
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
93298: LD_VAR 0 3
93302: PPUSH
93303: LD_EXP 206
93307: PUSH
93308: LD_VAR 0 2
93312: ARRAY
93313: PUSH
93314: LD_INT 1
93316: ARRAY
93317: PPUSH
93318: CALL 30839 0 2
93322: IFFALSE 93422
// begin ComCancel ( j ) ;
93324: LD_VAR 0 3
93328: PPUSH
93329: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
93333: LD_VAR 0 3
93337: PPUSH
93338: LD_EXP 206
93342: PUSH
93343: LD_VAR 0 2
93347: ARRAY
93348: PUSH
93349: LD_INT 1
93351: ARRAY
93352: PPUSH
93353: CALL_OW 207
// if not j in mc_construct_list [ i ] then
93357: LD_VAR 0 3
93361: PUSH
93362: LD_EXP 179
93366: PUSH
93367: LD_VAR 0 2
93371: ARRAY
93372: IN
93373: NOT
93374: IFFALSE 93420
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
93376: LD_ADDR_EXP 179
93380: PUSH
93381: LD_EXP 179
93385: PPUSH
93386: LD_VAR 0 2
93390: PUSH
93391: LD_EXP 179
93395: PUSH
93396: LD_VAR 0 2
93400: ARRAY
93401: PUSH
93402: LD_INT 1
93404: PLUS
93405: PUSH
93406: EMPTY
93407: LIST
93408: LIST
93409: PPUSH
93410: LD_VAR 0 3
93414: PPUSH
93415: CALL 24096 0 3
93419: ST_TO_ADDR
// break ;
93420: GO 93424
// end ; end ; end ;
93422: GO 93258
93424: POP
93425: POP
// end ;
93426: GO 93018
93428: POP
93429: POP
// end ;
93430: LD_VAR 0 1
93434: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
93435: LD_INT 0
93437: PPUSH
93438: PPUSH
93439: PPUSH
93440: PPUSH
93441: PPUSH
93442: PPUSH
93443: PPUSH
93444: PPUSH
93445: PPUSH
// if not mc_bases then
93446: LD_EXP 172
93450: NOT
93451: IFFALSE 93455
// exit ;
93453: GO 93860
// for i = 1 to mc_bases do
93455: LD_ADDR_VAR 0 2
93459: PUSH
93460: DOUBLE
93461: LD_INT 1
93463: DEC
93464: ST_TO_ADDR
93465: LD_EXP 172
93469: PUSH
93470: FOR_TO
93471: IFFALSE 93858
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
93473: LD_EXP 180
93477: PUSH
93478: LD_VAR 0 2
93482: ARRAY
93483: NOT
93484: PUSH
93485: LD_EXP 172
93489: PUSH
93490: LD_VAR 0 2
93494: ARRAY
93495: PPUSH
93496: LD_INT 30
93498: PUSH
93499: LD_INT 3
93501: PUSH
93502: EMPTY
93503: LIST
93504: LIST
93505: PPUSH
93506: CALL_OW 72
93510: NOT
93511: OR
93512: IFFALSE 93516
// continue ;
93514: GO 93470
// busy := false ;
93516: LD_ADDR_VAR 0 8
93520: PUSH
93521: LD_INT 0
93523: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
93524: LD_ADDR_VAR 0 4
93528: PUSH
93529: LD_EXP 172
93533: PUSH
93534: LD_VAR 0 2
93538: ARRAY
93539: PPUSH
93540: LD_INT 30
93542: PUSH
93543: LD_INT 3
93545: PUSH
93546: EMPTY
93547: LIST
93548: LIST
93549: PPUSH
93550: CALL_OW 72
93554: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
93555: LD_ADDR_VAR 0 6
93559: PUSH
93560: LD_EXP 180
93564: PUSH
93565: LD_VAR 0 2
93569: ARRAY
93570: PPUSH
93571: LD_INT 2
93573: PUSH
93574: LD_INT 30
93576: PUSH
93577: LD_INT 32
93579: PUSH
93580: EMPTY
93581: LIST
93582: LIST
93583: PUSH
93584: LD_INT 30
93586: PUSH
93587: LD_INT 33
93589: PUSH
93590: EMPTY
93591: LIST
93592: LIST
93593: PUSH
93594: EMPTY
93595: LIST
93596: LIST
93597: LIST
93598: PPUSH
93599: CALL_OW 72
93603: ST_TO_ADDR
// if not t then
93604: LD_VAR 0 6
93608: NOT
93609: IFFALSE 93613
// continue ;
93611: GO 93470
// for j in tmp do
93613: LD_ADDR_VAR 0 3
93617: PUSH
93618: LD_VAR 0 4
93622: PUSH
93623: FOR_IN
93624: IFFALSE 93654
// if not BuildingStatus ( j ) = bs_idle then
93626: LD_VAR 0 3
93630: PPUSH
93631: CALL_OW 461
93635: PUSH
93636: LD_INT 2
93638: EQUAL
93639: NOT
93640: IFFALSE 93652
// begin busy := true ;
93642: LD_ADDR_VAR 0 8
93646: PUSH
93647: LD_INT 1
93649: ST_TO_ADDR
// break ;
93650: GO 93654
// end ;
93652: GO 93623
93654: POP
93655: POP
// if busy then
93656: LD_VAR 0 8
93660: IFFALSE 93664
// continue ;
93662: GO 93470
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
93664: LD_ADDR_VAR 0 7
93668: PUSH
93669: LD_VAR 0 6
93673: PPUSH
93674: LD_INT 35
93676: PUSH
93677: LD_INT 0
93679: PUSH
93680: EMPTY
93681: LIST
93682: LIST
93683: PPUSH
93684: CALL_OW 72
93688: ST_TO_ADDR
// if tw then
93689: LD_VAR 0 7
93693: IFFALSE 93770
// begin tw := tw [ 1 ] ;
93695: LD_ADDR_VAR 0 7
93699: PUSH
93700: LD_VAR 0 7
93704: PUSH
93705: LD_INT 1
93707: ARRAY
93708: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
93709: LD_ADDR_VAR 0 9
93713: PUSH
93714: LD_VAR 0 7
93718: PPUSH
93719: LD_EXP 197
93723: PUSH
93724: LD_VAR 0 2
93728: ARRAY
93729: PPUSH
93730: CALL 29101 0 2
93734: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
93735: LD_EXP 211
93739: PUSH
93740: LD_VAR 0 2
93744: ARRAY
93745: IFFALSE 93768
// if not weapon in mc_allowed_tower_weapons [ i ] then
93747: LD_VAR 0 9
93751: PUSH
93752: LD_EXP 211
93756: PUSH
93757: LD_VAR 0 2
93761: ARRAY
93762: IN
93763: NOT
93764: IFFALSE 93768
// continue ;
93766: GO 93470
// end else
93768: GO 93833
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
93770: LD_ADDR_VAR 0 5
93774: PUSH
93775: LD_EXP 180
93779: PUSH
93780: LD_VAR 0 2
93784: ARRAY
93785: PPUSH
93786: LD_VAR 0 4
93790: PPUSH
93791: CALL 55020 0 2
93795: ST_TO_ADDR
// if not tmp2 then
93796: LD_VAR 0 5
93800: NOT
93801: IFFALSE 93805
// continue ;
93803: GO 93470
// tw := tmp2 [ 1 ] ;
93805: LD_ADDR_VAR 0 7
93809: PUSH
93810: LD_VAR 0 5
93814: PUSH
93815: LD_INT 1
93817: ARRAY
93818: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
93819: LD_ADDR_VAR 0 9
93823: PUSH
93824: LD_VAR 0 5
93828: PUSH
93829: LD_INT 2
93831: ARRAY
93832: ST_TO_ADDR
// end ; if not weapon then
93833: LD_VAR 0 9
93837: NOT
93838: IFFALSE 93842
// continue ;
93840: GO 93470
// ComPlaceWeapon ( tw , weapon ) ;
93842: LD_VAR 0 7
93846: PPUSH
93847: LD_VAR 0 9
93851: PPUSH
93852: CALL_OW 148
// end ;
93856: GO 93470
93858: POP
93859: POP
// end ;
93860: LD_VAR 0 1
93864: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
93865: LD_INT 0
93867: PPUSH
93868: PPUSH
93869: PPUSH
93870: PPUSH
93871: PPUSH
93872: PPUSH
93873: PPUSH
// if not mc_bases then
93874: LD_EXP 172
93878: NOT
93879: IFFALSE 93883
// exit ;
93881: GO 94651
// for i = 1 to mc_bases do
93883: LD_ADDR_VAR 0 2
93887: PUSH
93888: DOUBLE
93889: LD_INT 1
93891: DEC
93892: ST_TO_ADDR
93893: LD_EXP 172
93897: PUSH
93898: FOR_TO
93899: IFFALSE 94649
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
93901: LD_EXP 185
93905: PUSH
93906: LD_VAR 0 2
93910: ARRAY
93911: NOT
93912: PUSH
93913: LD_EXP 185
93917: PUSH
93918: LD_VAR 0 2
93922: ARRAY
93923: PUSH
93924: LD_EXP 186
93928: PUSH
93929: LD_VAR 0 2
93933: ARRAY
93934: EQUAL
93935: OR
93936: PUSH
93937: LD_EXP 195
93941: PUSH
93942: LD_VAR 0 2
93946: ARRAY
93947: OR
93948: IFFALSE 93952
// continue ;
93950: GO 93898
// if mc_miners [ i ] then
93952: LD_EXP 186
93956: PUSH
93957: LD_VAR 0 2
93961: ARRAY
93962: IFFALSE 94336
// begin for j = mc_miners [ i ] downto 1 do
93964: LD_ADDR_VAR 0 3
93968: PUSH
93969: DOUBLE
93970: LD_EXP 186
93974: PUSH
93975: LD_VAR 0 2
93979: ARRAY
93980: INC
93981: ST_TO_ADDR
93982: LD_INT 1
93984: PUSH
93985: FOR_DOWNTO
93986: IFFALSE 94334
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
93988: LD_EXP 186
93992: PUSH
93993: LD_VAR 0 2
93997: ARRAY
93998: PUSH
93999: LD_VAR 0 3
94003: ARRAY
94004: PPUSH
94005: CALL_OW 301
94009: PUSH
94010: LD_EXP 186
94014: PUSH
94015: LD_VAR 0 2
94019: ARRAY
94020: PUSH
94021: LD_VAR 0 3
94025: ARRAY
94026: PPUSH
94027: CALL_OW 257
94031: PUSH
94032: LD_INT 1
94034: NONEQUAL
94035: OR
94036: IFFALSE 94099
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
94038: LD_ADDR_VAR 0 5
94042: PUSH
94043: LD_EXP 186
94047: PUSH
94048: LD_VAR 0 2
94052: ARRAY
94053: PUSH
94054: LD_EXP 186
94058: PUSH
94059: LD_VAR 0 2
94063: ARRAY
94064: PUSH
94065: LD_VAR 0 3
94069: ARRAY
94070: DIFF
94071: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
94072: LD_ADDR_EXP 186
94076: PUSH
94077: LD_EXP 186
94081: PPUSH
94082: LD_VAR 0 2
94086: PPUSH
94087: LD_VAR 0 5
94091: PPUSH
94092: CALL_OW 1
94096: ST_TO_ADDR
// continue ;
94097: GO 93985
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
94099: LD_EXP 186
94103: PUSH
94104: LD_VAR 0 2
94108: ARRAY
94109: PUSH
94110: LD_VAR 0 3
94114: ARRAY
94115: PPUSH
94116: CALL_OW 257
94120: PUSH
94121: LD_INT 1
94123: EQUAL
94124: PUSH
94125: LD_EXP 186
94129: PUSH
94130: LD_VAR 0 2
94134: ARRAY
94135: PUSH
94136: LD_VAR 0 3
94140: ARRAY
94141: PPUSH
94142: CALL_OW 459
94146: NOT
94147: AND
94148: PUSH
94149: LD_EXP 186
94153: PUSH
94154: LD_VAR 0 2
94158: ARRAY
94159: PUSH
94160: LD_VAR 0 3
94164: ARRAY
94165: PPUSH
94166: CALL_OW 314
94170: NOT
94171: AND
94172: IFFALSE 94332
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
94174: LD_EXP 186
94178: PUSH
94179: LD_VAR 0 2
94183: ARRAY
94184: PUSH
94185: LD_VAR 0 3
94189: ARRAY
94190: PPUSH
94191: CALL_OW 310
94195: IFFALSE 94218
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
94197: LD_EXP 186
94201: PUSH
94202: LD_VAR 0 2
94206: ARRAY
94207: PUSH
94208: LD_VAR 0 3
94212: ARRAY
94213: PPUSH
94214: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
94218: LD_EXP 186
94222: PUSH
94223: LD_VAR 0 2
94227: ARRAY
94228: PUSH
94229: LD_VAR 0 3
94233: ARRAY
94234: PPUSH
94235: CALL_OW 314
94239: NOT
94240: IFFALSE 94332
// begin r := rand ( 1 , mc_mines [ i ] ) ;
94242: LD_ADDR_VAR 0 7
94246: PUSH
94247: LD_INT 1
94249: PPUSH
94250: LD_EXP 185
94254: PUSH
94255: LD_VAR 0 2
94259: ARRAY
94260: PPUSH
94261: CALL_OW 12
94265: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
94266: LD_EXP 186
94270: PUSH
94271: LD_VAR 0 2
94275: ARRAY
94276: PUSH
94277: LD_VAR 0 3
94281: ARRAY
94282: PPUSH
94283: LD_EXP 185
94287: PUSH
94288: LD_VAR 0 2
94292: ARRAY
94293: PUSH
94294: LD_VAR 0 7
94298: ARRAY
94299: PUSH
94300: LD_INT 1
94302: ARRAY
94303: PPUSH
94304: LD_EXP 185
94308: PUSH
94309: LD_VAR 0 2
94313: ARRAY
94314: PUSH
94315: LD_VAR 0 7
94319: ARRAY
94320: PUSH
94321: LD_INT 2
94323: ARRAY
94324: PPUSH
94325: LD_INT 0
94327: PPUSH
94328: CALL_OW 193
// end ; end ; end ;
94332: GO 93985
94334: POP
94335: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
94336: LD_ADDR_VAR 0 5
94340: PUSH
94341: LD_EXP 172
94345: PUSH
94346: LD_VAR 0 2
94350: ARRAY
94351: PPUSH
94352: LD_INT 2
94354: PUSH
94355: LD_INT 30
94357: PUSH
94358: LD_INT 4
94360: PUSH
94361: EMPTY
94362: LIST
94363: LIST
94364: PUSH
94365: LD_INT 30
94367: PUSH
94368: LD_INT 5
94370: PUSH
94371: EMPTY
94372: LIST
94373: LIST
94374: PUSH
94375: LD_INT 30
94377: PUSH
94378: LD_INT 32
94380: PUSH
94381: EMPTY
94382: LIST
94383: LIST
94384: PUSH
94385: EMPTY
94386: LIST
94387: LIST
94388: LIST
94389: LIST
94390: PPUSH
94391: CALL_OW 72
94395: ST_TO_ADDR
// if not tmp then
94396: LD_VAR 0 5
94400: NOT
94401: IFFALSE 94405
// continue ;
94403: GO 93898
// list := [ ] ;
94405: LD_ADDR_VAR 0 6
94409: PUSH
94410: EMPTY
94411: ST_TO_ADDR
// for j in tmp do
94412: LD_ADDR_VAR 0 3
94416: PUSH
94417: LD_VAR 0 5
94421: PUSH
94422: FOR_IN
94423: IFFALSE 94492
// begin for k in UnitsInside ( j ) do
94425: LD_ADDR_VAR 0 4
94429: PUSH
94430: LD_VAR 0 3
94434: PPUSH
94435: CALL_OW 313
94439: PUSH
94440: FOR_IN
94441: IFFALSE 94488
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
94443: LD_VAR 0 4
94447: PPUSH
94448: CALL_OW 257
94452: PUSH
94453: LD_INT 1
94455: EQUAL
94456: PUSH
94457: LD_VAR 0 4
94461: PPUSH
94462: CALL_OW 459
94466: NOT
94467: AND
94468: IFFALSE 94486
// list := list ^ k ;
94470: LD_ADDR_VAR 0 6
94474: PUSH
94475: LD_VAR 0 6
94479: PUSH
94480: LD_VAR 0 4
94484: ADD
94485: ST_TO_ADDR
94486: GO 94440
94488: POP
94489: POP
// end ;
94490: GO 94422
94492: POP
94493: POP
// list := list diff mc_miners [ i ] ;
94494: LD_ADDR_VAR 0 6
94498: PUSH
94499: LD_VAR 0 6
94503: PUSH
94504: LD_EXP 186
94508: PUSH
94509: LD_VAR 0 2
94513: ARRAY
94514: DIFF
94515: ST_TO_ADDR
// if not list then
94516: LD_VAR 0 6
94520: NOT
94521: IFFALSE 94525
// continue ;
94523: GO 93898
// k := mc_mines [ i ] - mc_miners [ i ] ;
94525: LD_ADDR_VAR 0 4
94529: PUSH
94530: LD_EXP 185
94534: PUSH
94535: LD_VAR 0 2
94539: ARRAY
94540: PUSH
94541: LD_EXP 186
94545: PUSH
94546: LD_VAR 0 2
94550: ARRAY
94551: MINUS
94552: ST_TO_ADDR
// if k > list then
94553: LD_VAR 0 4
94557: PUSH
94558: LD_VAR 0 6
94562: GREATER
94563: IFFALSE 94575
// k := list ;
94565: LD_ADDR_VAR 0 4
94569: PUSH
94570: LD_VAR 0 6
94574: ST_TO_ADDR
// for j = 1 to k do
94575: LD_ADDR_VAR 0 3
94579: PUSH
94580: DOUBLE
94581: LD_INT 1
94583: DEC
94584: ST_TO_ADDR
94585: LD_VAR 0 4
94589: PUSH
94590: FOR_TO
94591: IFFALSE 94645
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
94593: LD_ADDR_EXP 186
94597: PUSH
94598: LD_EXP 186
94602: PPUSH
94603: LD_VAR 0 2
94607: PUSH
94608: LD_EXP 186
94612: PUSH
94613: LD_VAR 0 2
94617: ARRAY
94618: PUSH
94619: LD_INT 1
94621: PLUS
94622: PUSH
94623: EMPTY
94624: LIST
94625: LIST
94626: PPUSH
94627: LD_VAR 0 6
94631: PUSH
94632: LD_VAR 0 3
94636: ARRAY
94637: PPUSH
94638: CALL 24096 0 3
94642: ST_TO_ADDR
94643: GO 94590
94645: POP
94646: POP
// end ;
94647: GO 93898
94649: POP
94650: POP
// end ;
94651: LD_VAR 0 1
94655: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , target , cargo , depot , fac , components ; begin
94656: LD_INT 0
94658: PPUSH
94659: PPUSH
94660: PPUSH
94661: PPUSH
94662: PPUSH
94663: PPUSH
94664: PPUSH
94665: PPUSH
94666: PPUSH
94667: PPUSH
// if not mc_bases then
94668: LD_EXP 172
94672: NOT
94673: IFFALSE 94677
// exit ;
94675: GO 96427
// for i = 1 to mc_bases do
94677: LD_ADDR_VAR 0 2
94681: PUSH
94682: DOUBLE
94683: LD_INT 1
94685: DEC
94686: ST_TO_ADDR
94687: LD_EXP 172
94691: PUSH
94692: FOR_TO
94693: IFFALSE 96425
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
94695: LD_EXP 172
94699: PUSH
94700: LD_VAR 0 2
94704: ARRAY
94705: NOT
94706: PUSH
94707: LD_EXP 179
94711: PUSH
94712: LD_VAR 0 2
94716: ARRAY
94717: OR
94718: IFFALSE 94722
// continue ;
94720: GO 94692
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
94722: LD_EXP 188
94726: PUSH
94727: LD_VAR 0 2
94731: ARRAY
94732: NOT
94733: PUSH
94734: LD_EXP 189
94738: PUSH
94739: LD_VAR 0 2
94743: ARRAY
94744: AND
94745: IFFALSE 94783
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
94747: LD_ADDR_EXP 189
94751: PUSH
94752: LD_EXP 189
94756: PPUSH
94757: LD_VAR 0 2
94761: PPUSH
94762: EMPTY
94763: PPUSH
94764: CALL_OW 1
94768: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
94769: LD_VAR 0 2
94773: PPUSH
94774: LD_INT 107
94776: PPUSH
94777: CALL 85610 0 2
// continue ;
94781: GO 94692
// end ; target := [ ] ;
94783: LD_ADDR_VAR 0 6
94787: PUSH
94788: EMPTY
94789: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
94790: LD_ADDR_VAR 0 3
94794: PUSH
94795: DOUBLE
94796: LD_EXP 188
94800: PUSH
94801: LD_VAR 0 2
94805: ARRAY
94806: INC
94807: ST_TO_ADDR
94808: LD_INT 1
94810: PUSH
94811: FOR_DOWNTO
94812: IFFALSE 95072
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
94814: LD_EXP 188
94818: PUSH
94819: LD_VAR 0 2
94823: ARRAY
94824: PUSH
94825: LD_VAR 0 3
94829: ARRAY
94830: PUSH
94831: LD_INT 2
94833: ARRAY
94834: PPUSH
94835: LD_EXP 188
94839: PUSH
94840: LD_VAR 0 2
94844: ARRAY
94845: PUSH
94846: LD_VAR 0 3
94850: ARRAY
94851: PUSH
94852: LD_INT 3
94854: ARRAY
94855: PPUSH
94856: CALL_OW 488
94860: PUSH
94861: LD_EXP 188
94865: PUSH
94866: LD_VAR 0 2
94870: ARRAY
94871: PUSH
94872: LD_VAR 0 3
94876: ARRAY
94877: PUSH
94878: LD_INT 2
94880: ARRAY
94881: PPUSH
94882: LD_EXP 188
94886: PUSH
94887: LD_VAR 0 2
94891: ARRAY
94892: PUSH
94893: LD_VAR 0 3
94897: ARRAY
94898: PUSH
94899: LD_INT 3
94901: ARRAY
94902: PPUSH
94903: CALL_OW 284
94907: PUSH
94908: LD_INT 0
94910: EQUAL
94911: AND
94912: IFFALSE 94967
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
94914: LD_ADDR_VAR 0 5
94918: PUSH
94919: LD_EXP 188
94923: PUSH
94924: LD_VAR 0 2
94928: ARRAY
94929: PPUSH
94930: LD_VAR 0 3
94934: PPUSH
94935: CALL_OW 3
94939: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
94940: LD_ADDR_EXP 188
94944: PUSH
94945: LD_EXP 188
94949: PPUSH
94950: LD_VAR 0 2
94954: PPUSH
94955: LD_VAR 0 5
94959: PPUSH
94960: CALL_OW 1
94964: ST_TO_ADDR
// continue ;
94965: GO 94811
// end ; if DangerAtRangeXY ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
94967: LD_EXP 172
94971: PUSH
94972: LD_VAR 0 2
94976: ARRAY
94977: PUSH
94978: LD_INT 1
94980: ARRAY
94981: PPUSH
94982: CALL_OW 255
94986: PPUSH
94987: LD_EXP 188
94991: PUSH
94992: LD_VAR 0 2
94996: ARRAY
94997: PUSH
94998: LD_VAR 0 3
95002: ARRAY
95003: PUSH
95004: LD_INT 2
95006: ARRAY
95007: PPUSH
95008: LD_EXP 188
95012: PUSH
95013: LD_VAR 0 2
95017: ARRAY
95018: PUSH
95019: LD_VAR 0 3
95023: ARRAY
95024: PUSH
95025: LD_INT 3
95027: ARRAY
95028: PPUSH
95029: LD_INT 30
95031: PPUSH
95032: CALL 24992 0 4
95036: PUSH
95037: LD_INT 4
95039: ARRAY
95040: PUSH
95041: LD_INT 0
95043: EQUAL
95044: IFFALSE 95070
// begin target := mc_crates [ i ] [ j ] ;
95046: LD_ADDR_VAR 0 6
95050: PUSH
95051: LD_EXP 188
95055: PUSH
95056: LD_VAR 0 2
95060: ARRAY
95061: PUSH
95062: LD_VAR 0 3
95066: ARRAY
95067: ST_TO_ADDR
// break ;
95068: GO 95072
// end ; end ;
95070: GO 94811
95072: POP
95073: POP
// if not target then
95074: LD_VAR 0 6
95078: NOT
95079: IFFALSE 95083
// continue ;
95081: GO 94692
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
95083: LD_ADDR_VAR 0 7
95087: PUSH
95088: LD_EXP 191
95092: PUSH
95093: LD_VAR 0 2
95097: ARRAY
95098: PPUSH
95099: LD_INT 2
95101: PUSH
95102: LD_INT 3
95104: PUSH
95105: LD_INT 58
95107: PUSH
95108: EMPTY
95109: LIST
95110: PUSH
95111: EMPTY
95112: LIST
95113: LIST
95114: PUSH
95115: LD_INT 61
95117: PUSH
95118: EMPTY
95119: LIST
95120: PUSH
95121: LD_INT 33
95123: PUSH
95124: LD_INT 5
95126: PUSH
95127: EMPTY
95128: LIST
95129: LIST
95130: PUSH
95131: LD_INT 33
95133: PUSH
95134: LD_INT 3
95136: PUSH
95137: EMPTY
95138: LIST
95139: LIST
95140: PUSH
95141: EMPTY
95142: LIST
95143: LIST
95144: LIST
95145: LIST
95146: LIST
95147: PUSH
95148: LD_INT 2
95150: PUSH
95151: LD_INT 34
95153: PUSH
95154: LD_INT 32
95156: PUSH
95157: EMPTY
95158: LIST
95159: LIST
95160: PUSH
95161: LD_INT 34
95163: PUSH
95164: LD_INT 51
95166: PUSH
95167: EMPTY
95168: LIST
95169: LIST
95170: PUSH
95171: LD_INT 34
95173: PUSH
95174: LD_INT 12
95176: PUSH
95177: EMPTY
95178: LIST
95179: LIST
95180: PUSH
95181: EMPTY
95182: LIST
95183: LIST
95184: LIST
95185: LIST
95186: PUSH
95187: EMPTY
95188: LIST
95189: LIST
95190: PPUSH
95191: CALL_OW 72
95195: ST_TO_ADDR
// if not cargo then
95196: LD_VAR 0 7
95200: NOT
95201: IFFALSE 95844
// begin if mc_crates_collector [ i ] < 5 then
95203: LD_EXP 189
95207: PUSH
95208: LD_VAR 0 2
95212: ARRAY
95213: PUSH
95214: LD_INT 5
95216: LESS
95217: IFFALSE 95583
// begin if mc_ape [ i ] then
95219: LD_EXP 201
95223: PUSH
95224: LD_VAR 0 2
95228: ARRAY
95229: IFFALSE 95276
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
95231: LD_ADDR_VAR 0 5
95235: PUSH
95236: LD_EXP 201
95240: PUSH
95241: LD_VAR 0 2
95245: ARRAY
95246: PPUSH
95247: LD_INT 25
95249: PUSH
95250: LD_INT 16
95252: PUSH
95253: EMPTY
95254: LIST
95255: LIST
95256: PUSH
95257: LD_INT 24
95259: PUSH
95260: LD_INT 750
95262: PUSH
95263: EMPTY
95264: LIST
95265: LIST
95266: PUSH
95267: EMPTY
95268: LIST
95269: LIST
95270: PPUSH
95271: CALL_OW 72
95275: ST_TO_ADDR
// if not tmp then
95276: LD_VAR 0 5
95280: NOT
95281: IFFALSE 95328
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
95283: LD_ADDR_VAR 0 5
95287: PUSH
95288: LD_EXP 172
95292: PUSH
95293: LD_VAR 0 2
95297: ARRAY
95298: PPUSH
95299: LD_INT 25
95301: PUSH
95302: LD_INT 2
95304: PUSH
95305: EMPTY
95306: LIST
95307: LIST
95308: PUSH
95309: LD_INT 24
95311: PUSH
95312: LD_INT 750
95314: PUSH
95315: EMPTY
95316: LIST
95317: LIST
95318: PUSH
95319: EMPTY
95320: LIST
95321: LIST
95322: PPUSH
95323: CALL_OW 72
95327: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
95328: LD_EXP 201
95332: PUSH
95333: LD_VAR 0 2
95337: ARRAY
95338: PUSH
95339: LD_EXP 172
95343: PUSH
95344: LD_VAR 0 2
95348: ARRAY
95349: PPUSH
95350: LD_INT 25
95352: PUSH
95353: LD_INT 2
95355: PUSH
95356: EMPTY
95357: LIST
95358: LIST
95359: PUSH
95360: LD_INT 24
95362: PUSH
95363: LD_INT 750
95365: PUSH
95366: EMPTY
95367: LIST
95368: LIST
95369: PUSH
95370: EMPTY
95371: LIST
95372: LIST
95373: PPUSH
95374: CALL_OW 72
95378: AND
95379: PUSH
95380: LD_VAR 0 5
95384: PUSH
95385: LD_INT 5
95387: LESS
95388: AND
95389: IFFALSE 95471
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
95391: LD_ADDR_VAR 0 3
95395: PUSH
95396: LD_EXP 172
95400: PUSH
95401: LD_VAR 0 2
95405: ARRAY
95406: PPUSH
95407: LD_INT 25
95409: PUSH
95410: LD_INT 2
95412: PUSH
95413: EMPTY
95414: LIST
95415: LIST
95416: PUSH
95417: LD_INT 24
95419: PUSH
95420: LD_INT 750
95422: PUSH
95423: EMPTY
95424: LIST
95425: LIST
95426: PUSH
95427: EMPTY
95428: LIST
95429: LIST
95430: PPUSH
95431: CALL_OW 72
95435: PUSH
95436: FOR_IN
95437: IFFALSE 95469
// begin tmp := tmp union j ;
95439: LD_ADDR_VAR 0 5
95443: PUSH
95444: LD_VAR 0 5
95448: PUSH
95449: LD_VAR 0 3
95453: UNION
95454: ST_TO_ADDR
// if tmp >= 5 then
95455: LD_VAR 0 5
95459: PUSH
95460: LD_INT 5
95462: GREATEREQUAL
95463: IFFALSE 95467
// break ;
95465: GO 95469
// end ;
95467: GO 95436
95469: POP
95470: POP
// end ; if not tmp then
95471: LD_VAR 0 5
95475: NOT
95476: IFFALSE 95480
// continue ;
95478: GO 94692
// for j in tmp do
95480: LD_ADDR_VAR 0 3
95484: PUSH
95485: LD_VAR 0 5
95489: PUSH
95490: FOR_IN
95491: IFFALSE 95581
// if not GetTag ( j ) then
95493: LD_VAR 0 3
95497: PPUSH
95498: CALL_OW 110
95502: NOT
95503: IFFALSE 95579
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
95505: LD_ADDR_EXP 189
95509: PUSH
95510: LD_EXP 189
95514: PPUSH
95515: LD_VAR 0 2
95519: PUSH
95520: LD_EXP 189
95524: PUSH
95525: LD_VAR 0 2
95529: ARRAY
95530: PUSH
95531: LD_INT 1
95533: PLUS
95534: PUSH
95535: EMPTY
95536: LIST
95537: LIST
95538: PPUSH
95539: LD_VAR 0 3
95543: PPUSH
95544: CALL 24096 0 3
95548: ST_TO_ADDR
// SetTag ( j , 107 ) ;
95549: LD_VAR 0 3
95553: PPUSH
95554: LD_INT 107
95556: PPUSH
95557: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
95561: LD_EXP 189
95565: PUSH
95566: LD_VAR 0 2
95570: ARRAY
95571: PUSH
95572: LD_INT 5
95574: GREATEREQUAL
95575: IFFALSE 95579
// break ;
95577: GO 95581
// end ;
95579: GO 95490
95581: POP
95582: POP
// end ; if mc_crates_collector [ i ] and target then
95583: LD_EXP 189
95587: PUSH
95588: LD_VAR 0 2
95592: ARRAY
95593: PUSH
95594: LD_VAR 0 6
95598: AND
95599: IFFALSE 95842
// begin if mc_crates_collector [ i ] < target [ 1 ] then
95601: LD_EXP 189
95605: PUSH
95606: LD_VAR 0 2
95610: ARRAY
95611: PUSH
95612: LD_VAR 0 6
95616: PUSH
95617: LD_INT 1
95619: ARRAY
95620: LESS
95621: IFFALSE 95641
// tmp := mc_crates_collector [ i ] else
95623: LD_ADDR_VAR 0 5
95627: PUSH
95628: LD_EXP 189
95632: PUSH
95633: LD_VAR 0 2
95637: ARRAY
95638: ST_TO_ADDR
95639: GO 95655
// tmp := target [ 1 ] ;
95641: LD_ADDR_VAR 0 5
95645: PUSH
95646: LD_VAR 0 6
95650: PUSH
95651: LD_INT 1
95653: ARRAY
95654: ST_TO_ADDR
// k := 0 ;
95655: LD_ADDR_VAR 0 4
95659: PUSH
95660: LD_INT 0
95662: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
95663: LD_ADDR_VAR 0 3
95667: PUSH
95668: LD_EXP 189
95672: PUSH
95673: LD_VAR 0 2
95677: ARRAY
95678: PUSH
95679: FOR_IN
95680: IFFALSE 95840
// begin k := k + 1 ;
95682: LD_ADDR_VAR 0 4
95686: PUSH
95687: LD_VAR 0 4
95691: PUSH
95692: LD_INT 1
95694: PLUS
95695: ST_TO_ADDR
// if k > tmp then
95696: LD_VAR 0 4
95700: PUSH
95701: LD_VAR 0 5
95705: GREATER
95706: IFFALSE 95710
// break ;
95708: GO 95840
// if not GetClass ( j ) in [ 2 , 16 ] then
95710: LD_VAR 0 3
95714: PPUSH
95715: CALL_OW 257
95719: PUSH
95720: LD_INT 2
95722: PUSH
95723: LD_INT 16
95725: PUSH
95726: EMPTY
95727: LIST
95728: LIST
95729: IN
95730: NOT
95731: IFFALSE 95784
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
95733: LD_ADDR_EXP 189
95737: PUSH
95738: LD_EXP 189
95742: PPUSH
95743: LD_VAR 0 2
95747: PPUSH
95748: LD_EXP 189
95752: PUSH
95753: LD_VAR 0 2
95757: ARRAY
95758: PUSH
95759: LD_VAR 0 3
95763: DIFF
95764: PPUSH
95765: CALL_OW 1
95769: ST_TO_ADDR
// SetTag ( j , 0 ) ;
95770: LD_VAR 0 3
95774: PPUSH
95775: LD_INT 0
95777: PPUSH
95778: CALL_OW 109
// continue ;
95782: GO 95679
// end ; if IsInUnit ( j ) then
95784: LD_VAR 0 3
95788: PPUSH
95789: CALL_OW 310
95793: IFFALSE 95804
// ComExitBuilding ( j ) ;
95795: LD_VAR 0 3
95799: PPUSH
95800: CALL_OW 122
// wait ( 3 ) ;
95804: LD_INT 3
95806: PPUSH
95807: CALL_OW 67
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
95811: LD_VAR 0 3
95815: PPUSH
95816: LD_VAR 0 6
95820: PUSH
95821: LD_INT 2
95823: ARRAY
95824: PPUSH
95825: LD_VAR 0 6
95829: PUSH
95830: LD_INT 3
95832: ARRAY
95833: PPUSH
95834: CALL_OW 117
// end ;
95838: GO 95679
95840: POP
95841: POP
// end ; end else
95842: GO 96423
// begin for j in cargo do
95844: LD_ADDR_VAR 0 3
95848: PUSH
95849: LD_VAR 0 7
95853: PUSH
95854: FOR_IN
95855: IFFALSE 96421
// begin if GetTag ( j ) <> 0 then
95857: LD_VAR 0 3
95861: PPUSH
95862: CALL_OW 110
95866: PUSH
95867: LD_INT 0
95869: NONEQUAL
95870: IFFALSE 95874
// continue ;
95872: GO 95854
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
95874: LD_VAR 0 3
95878: PPUSH
95879: CALL_OW 256
95883: PUSH
95884: LD_INT 1000
95886: LESS
95887: PUSH
95888: LD_VAR 0 3
95892: PPUSH
95893: LD_EXP 196
95897: PUSH
95898: LD_VAR 0 2
95902: ARRAY
95903: PPUSH
95904: CALL_OW 308
95908: NOT
95909: AND
95910: IFFALSE 95932
// ComMoveToArea ( j , mc_parking [ i ] ) ;
95912: LD_VAR 0 3
95916: PPUSH
95917: LD_EXP 196
95921: PUSH
95922: LD_VAR 0 2
95926: ARRAY
95927: PPUSH
95928: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
95932: LD_VAR 0 3
95936: PPUSH
95937: CALL_OW 256
95941: PUSH
95942: LD_INT 1000
95944: LESS
95945: PUSH
95946: LD_VAR 0 3
95950: PPUSH
95951: LD_EXP 196
95955: PUSH
95956: LD_VAR 0 2
95960: ARRAY
95961: PPUSH
95962: CALL_OW 308
95966: AND
95967: IFFALSE 95971
// continue ;
95969: GO 95854
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
95971: LD_VAR 0 3
95975: PPUSH
95976: CALL_OW 262
95980: PUSH
95981: LD_INT 2
95983: EQUAL
95984: PUSH
95985: LD_VAR 0 3
95989: PPUSH
95990: CALL_OW 261
95994: PUSH
95995: LD_INT 15
95997: LESS
95998: AND
95999: IFFALSE 96003
// continue ;
96001: GO 95854
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
96003: LD_VAR 0 3
96007: PPUSH
96008: CALL_OW 262
96012: PUSH
96013: LD_INT 1
96015: EQUAL
96016: PUSH
96017: LD_VAR 0 3
96021: PPUSH
96022: CALL_OW 261
96026: PUSH
96027: LD_INT 10
96029: LESS
96030: AND
96031: IFFALSE 96360
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
96033: LD_ADDR_VAR 0 8
96037: PUSH
96038: LD_EXP 172
96042: PUSH
96043: LD_VAR 0 2
96047: ARRAY
96048: PPUSH
96049: LD_INT 2
96051: PUSH
96052: LD_INT 30
96054: PUSH
96055: LD_INT 0
96057: PUSH
96058: EMPTY
96059: LIST
96060: LIST
96061: PUSH
96062: LD_INT 30
96064: PUSH
96065: LD_INT 1
96067: PUSH
96068: EMPTY
96069: LIST
96070: LIST
96071: PUSH
96072: EMPTY
96073: LIST
96074: LIST
96075: LIST
96076: PPUSH
96077: CALL_OW 72
96081: ST_TO_ADDR
// if not depot then
96082: LD_VAR 0 8
96086: NOT
96087: IFFALSE 96091
// continue ;
96089: GO 95854
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
96091: LD_VAR 0 3
96095: PPUSH
96096: LD_VAR 0 8
96100: PPUSH
96101: LD_VAR 0 3
96105: PPUSH
96106: CALL_OW 74
96110: PPUSH
96111: CALL_OW 296
96115: PUSH
96116: LD_INT 6
96118: LESS
96119: IFFALSE 96135
// SetFuel ( j , 100 ) else
96121: LD_VAR 0 3
96125: PPUSH
96126: LD_INT 100
96128: PPUSH
96129: CALL_OW 240
96133: GO 96360
// if GetFuel ( j ) = 0 then
96135: LD_VAR 0 3
96139: PPUSH
96140: CALL_OW 261
96144: PUSH
96145: LD_INT 0
96147: EQUAL
96148: IFFALSE 96360
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
96150: LD_ADDR_EXP 191
96154: PUSH
96155: LD_EXP 191
96159: PPUSH
96160: LD_VAR 0 2
96164: PPUSH
96165: LD_EXP 191
96169: PUSH
96170: LD_VAR 0 2
96174: ARRAY
96175: PUSH
96176: LD_VAR 0 3
96180: DIFF
96181: PPUSH
96182: CALL_OW 1
96186: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
96187: LD_VAR 0 3
96191: PPUSH
96192: CALL_OW 263
96196: PUSH
96197: LD_INT 1
96199: EQUAL
96200: IFFALSE 96216
// ComExitVehicle ( IsInUnit ( j ) ) ;
96202: LD_VAR 0 3
96206: PPUSH
96207: CALL_OW 310
96211: PPUSH
96212: CALL_OW 121
// if GetControl ( j ) = control_remote then
96216: LD_VAR 0 3
96220: PPUSH
96221: CALL_OW 263
96225: PUSH
96226: LD_INT 2
96228: EQUAL
96229: IFFALSE 96240
// ComUnlink ( j ) ;
96231: LD_VAR 0 3
96235: PPUSH
96236: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
96240: LD_ADDR_VAR 0 9
96244: PUSH
96245: LD_VAR 0 2
96249: PPUSH
96250: LD_INT 3
96252: PPUSH
96253: CALL 105830 0 2
96257: ST_TO_ADDR
// if fac then
96258: LD_VAR 0 9
96262: IFFALSE 96358
// begin for k in fac do
96264: LD_ADDR_VAR 0 4
96268: PUSH
96269: LD_VAR 0 9
96273: PUSH
96274: FOR_IN
96275: IFFALSE 96356
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
96277: LD_ADDR_VAR 0 10
96281: PUSH
96282: LD_VAR 0 9
96286: PPUSH
96287: LD_VAR 0 3
96291: PPUSH
96292: CALL_OW 265
96296: PPUSH
96297: LD_VAR 0 3
96301: PPUSH
96302: CALL_OW 262
96306: PPUSH
96307: LD_VAR 0 3
96311: PPUSH
96312: CALL_OW 263
96316: PPUSH
96317: LD_VAR 0 3
96321: PPUSH
96322: CALL_OW 264
96326: PPUSH
96327: CALL 21628 0 5
96331: ST_TO_ADDR
// if components then
96332: LD_VAR 0 10
96336: IFFALSE 96354
// begin MC_InsertProduceList ( i , components ) ;
96338: LD_VAR 0 2
96342: PPUSH
96343: LD_VAR 0 10
96347: PPUSH
96348: CALL 105375 0 2
// break ;
96352: GO 96356
// end ; end ;
96354: GO 96274
96356: POP
96357: POP
// end ; continue ;
96358: GO 95854
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
96360: LD_VAR 0 3
96364: PPUSH
96365: LD_INT 1
96367: PPUSH
96368: CALL_OW 289
96372: PUSH
96373: LD_INT 100
96375: LESS
96376: PUSH
96377: LD_VAR 0 3
96381: PPUSH
96382: CALL_OW 314
96386: NOT
96387: AND
96388: IFFALSE 96417
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
96390: LD_VAR 0 3
96394: PPUSH
96395: LD_VAR 0 6
96399: PUSH
96400: LD_INT 2
96402: ARRAY
96403: PPUSH
96404: LD_VAR 0 6
96408: PUSH
96409: LD_INT 3
96411: ARRAY
96412: PPUSH
96413: CALL_OW 117
// break ;
96417: GO 96421
// end ;
96419: GO 95854
96421: POP
96422: POP
// end ; end ;
96423: GO 94692
96425: POP
96426: POP
// end ;
96427: LD_VAR 0 1
96431: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
96432: LD_INT 0
96434: PPUSH
96435: PPUSH
96436: PPUSH
96437: PPUSH
// if not mc_bases then
96438: LD_EXP 172
96442: NOT
96443: IFFALSE 96447
// exit ;
96445: GO 96608
// for i = 1 to mc_bases do
96447: LD_ADDR_VAR 0 2
96451: PUSH
96452: DOUBLE
96453: LD_INT 1
96455: DEC
96456: ST_TO_ADDR
96457: LD_EXP 172
96461: PUSH
96462: FOR_TO
96463: IFFALSE 96606
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
96465: LD_ADDR_VAR 0 4
96469: PUSH
96470: LD_EXP 191
96474: PUSH
96475: LD_VAR 0 2
96479: ARRAY
96480: PUSH
96481: LD_EXP 194
96485: PUSH
96486: LD_VAR 0 2
96490: ARRAY
96491: UNION
96492: PPUSH
96493: LD_INT 33
96495: PUSH
96496: LD_INT 2
96498: PUSH
96499: EMPTY
96500: LIST
96501: LIST
96502: PPUSH
96503: CALL_OW 72
96507: ST_TO_ADDR
// if tmp then
96508: LD_VAR 0 4
96512: IFFALSE 96604
// for j in tmp do
96514: LD_ADDR_VAR 0 3
96518: PUSH
96519: LD_VAR 0 4
96523: PUSH
96524: FOR_IN
96525: IFFALSE 96602
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
96527: LD_VAR 0 3
96531: PPUSH
96532: CALL_OW 312
96536: NOT
96537: PUSH
96538: LD_VAR 0 3
96542: PPUSH
96543: CALL_OW 256
96547: PUSH
96548: LD_INT 250
96550: GREATEREQUAL
96551: AND
96552: IFFALSE 96565
// Connect ( j ) else
96554: LD_VAR 0 3
96558: PPUSH
96559: CALL 27061 0 1
96563: GO 96600
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
96565: LD_VAR 0 3
96569: PPUSH
96570: CALL_OW 256
96574: PUSH
96575: LD_INT 250
96577: LESS
96578: PUSH
96579: LD_VAR 0 3
96583: PPUSH
96584: CALL_OW 312
96588: AND
96589: IFFALSE 96600
// ComUnlink ( j ) ;
96591: LD_VAR 0 3
96595: PPUSH
96596: CALL_OW 136
96600: GO 96524
96602: POP
96603: POP
// end ;
96604: GO 96462
96606: POP
96607: POP
// end ;
96608: LD_VAR 0 1
96612: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
96613: LD_INT 0
96615: PPUSH
96616: PPUSH
96617: PPUSH
96618: PPUSH
96619: PPUSH
// if not mc_bases then
96620: LD_EXP 172
96624: NOT
96625: IFFALSE 96629
// exit ;
96627: GO 97074
// for i = 1 to mc_bases do
96629: LD_ADDR_VAR 0 2
96633: PUSH
96634: DOUBLE
96635: LD_INT 1
96637: DEC
96638: ST_TO_ADDR
96639: LD_EXP 172
96643: PUSH
96644: FOR_TO
96645: IFFALSE 97072
// begin if not mc_produce [ i ] then
96647: LD_EXP 193
96651: PUSH
96652: LD_VAR 0 2
96656: ARRAY
96657: NOT
96658: IFFALSE 96662
// continue ;
96660: GO 96644
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
96662: LD_ADDR_VAR 0 5
96666: PUSH
96667: LD_EXP 172
96671: PUSH
96672: LD_VAR 0 2
96676: ARRAY
96677: PPUSH
96678: LD_INT 30
96680: PUSH
96681: LD_INT 3
96683: PUSH
96684: EMPTY
96685: LIST
96686: LIST
96687: PPUSH
96688: CALL_OW 72
96692: ST_TO_ADDR
// if not fac then
96693: LD_VAR 0 5
96697: NOT
96698: IFFALSE 96702
// continue ;
96700: GO 96644
// for j in fac do
96702: LD_ADDR_VAR 0 3
96706: PUSH
96707: LD_VAR 0 5
96711: PUSH
96712: FOR_IN
96713: IFFALSE 97068
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
96715: LD_VAR 0 3
96719: PPUSH
96720: CALL_OW 461
96724: PUSH
96725: LD_INT 2
96727: NONEQUAL
96728: PUSH
96729: LD_VAR 0 3
96733: PPUSH
96734: LD_INT 15
96736: PPUSH
96737: CALL 26689 0 2
96741: PUSH
96742: LD_INT 4
96744: ARRAY
96745: OR
96746: IFFALSE 96750
// continue ;
96748: GO 96712
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
96750: LD_VAR 0 3
96754: PPUSH
96755: LD_EXP 193
96759: PUSH
96760: LD_VAR 0 2
96764: ARRAY
96765: PUSH
96766: LD_INT 1
96768: ARRAY
96769: PUSH
96770: LD_INT 1
96772: ARRAY
96773: PPUSH
96774: LD_EXP 193
96778: PUSH
96779: LD_VAR 0 2
96783: ARRAY
96784: PUSH
96785: LD_INT 1
96787: ARRAY
96788: PUSH
96789: LD_INT 2
96791: ARRAY
96792: PPUSH
96793: LD_EXP 193
96797: PUSH
96798: LD_VAR 0 2
96802: ARRAY
96803: PUSH
96804: LD_INT 1
96806: ARRAY
96807: PUSH
96808: LD_INT 3
96810: ARRAY
96811: PPUSH
96812: LD_EXP 193
96816: PUSH
96817: LD_VAR 0 2
96821: ARRAY
96822: PUSH
96823: LD_INT 1
96825: ARRAY
96826: PUSH
96827: LD_INT 4
96829: ARRAY
96830: PPUSH
96831: CALL_OW 448
96835: PUSH
96836: LD_VAR 0 3
96840: PPUSH
96841: LD_EXP 193
96845: PUSH
96846: LD_VAR 0 2
96850: ARRAY
96851: PUSH
96852: LD_INT 1
96854: ARRAY
96855: PUSH
96856: LD_INT 1
96858: ARRAY
96859: PUSH
96860: LD_EXP 193
96864: PUSH
96865: LD_VAR 0 2
96869: ARRAY
96870: PUSH
96871: LD_INT 1
96873: ARRAY
96874: PUSH
96875: LD_INT 2
96877: ARRAY
96878: PUSH
96879: LD_EXP 193
96883: PUSH
96884: LD_VAR 0 2
96888: ARRAY
96889: PUSH
96890: LD_INT 1
96892: ARRAY
96893: PUSH
96894: LD_INT 3
96896: ARRAY
96897: PUSH
96898: LD_EXP 193
96902: PUSH
96903: LD_VAR 0 2
96907: ARRAY
96908: PUSH
96909: LD_INT 1
96911: ARRAY
96912: PUSH
96913: LD_INT 4
96915: ARRAY
96916: PUSH
96917: EMPTY
96918: LIST
96919: LIST
96920: LIST
96921: LIST
96922: PPUSH
96923: CALL 30487 0 2
96927: AND
96928: IFFALSE 97066
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
96930: LD_VAR 0 3
96934: PPUSH
96935: LD_EXP 193
96939: PUSH
96940: LD_VAR 0 2
96944: ARRAY
96945: PUSH
96946: LD_INT 1
96948: ARRAY
96949: PUSH
96950: LD_INT 1
96952: ARRAY
96953: PPUSH
96954: LD_EXP 193
96958: PUSH
96959: LD_VAR 0 2
96963: ARRAY
96964: PUSH
96965: LD_INT 1
96967: ARRAY
96968: PUSH
96969: LD_INT 2
96971: ARRAY
96972: PPUSH
96973: LD_EXP 193
96977: PUSH
96978: LD_VAR 0 2
96982: ARRAY
96983: PUSH
96984: LD_INT 1
96986: ARRAY
96987: PUSH
96988: LD_INT 3
96990: ARRAY
96991: PPUSH
96992: LD_EXP 193
96996: PUSH
96997: LD_VAR 0 2
97001: ARRAY
97002: PUSH
97003: LD_INT 1
97005: ARRAY
97006: PUSH
97007: LD_INT 4
97009: ARRAY
97010: PPUSH
97011: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
97015: LD_ADDR_VAR 0 4
97019: PUSH
97020: LD_EXP 193
97024: PUSH
97025: LD_VAR 0 2
97029: ARRAY
97030: PPUSH
97031: LD_INT 1
97033: PPUSH
97034: CALL_OW 3
97038: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
97039: LD_ADDR_EXP 193
97043: PUSH
97044: LD_EXP 193
97048: PPUSH
97049: LD_VAR 0 2
97053: PPUSH
97054: LD_VAR 0 4
97058: PPUSH
97059: CALL_OW 1
97063: ST_TO_ADDR
// break ;
97064: GO 97068
// end ; end ;
97066: GO 96712
97068: POP
97069: POP
// end ;
97070: GO 96644
97072: POP
97073: POP
// end ;
97074: LD_VAR 0 1
97078: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
97079: LD_INT 0
97081: PPUSH
97082: PPUSH
97083: PPUSH
// if not mc_bases then
97084: LD_EXP 172
97088: NOT
97089: IFFALSE 97093
// exit ;
97091: GO 97182
// for i = 1 to mc_bases do
97093: LD_ADDR_VAR 0 2
97097: PUSH
97098: DOUBLE
97099: LD_INT 1
97101: DEC
97102: ST_TO_ADDR
97103: LD_EXP 172
97107: PUSH
97108: FOR_TO
97109: IFFALSE 97180
// begin if mc_attack [ i ] then
97111: LD_EXP 192
97115: PUSH
97116: LD_VAR 0 2
97120: ARRAY
97121: IFFALSE 97178
// begin tmp := mc_attack [ i ] [ 1 ] ;
97123: LD_ADDR_VAR 0 3
97127: PUSH
97128: LD_EXP 192
97132: PUSH
97133: LD_VAR 0 2
97137: ARRAY
97138: PUSH
97139: LD_INT 1
97141: ARRAY
97142: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
97143: LD_ADDR_EXP 192
97147: PUSH
97148: LD_EXP 192
97152: PPUSH
97153: LD_VAR 0 2
97157: PPUSH
97158: EMPTY
97159: PPUSH
97160: CALL_OW 1
97164: ST_TO_ADDR
// Attack ( tmp ) ;
97165: LD_VAR 0 3
97169: PPUSH
97170: CALL 74295 0 1
// exit ;
97174: POP
97175: POP
97176: GO 97182
// end ; end ;
97178: GO 97108
97180: POP
97181: POP
// end ;
97182: LD_VAR 0 1
97186: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
97187: LD_INT 0
97189: PPUSH
97190: PPUSH
97191: PPUSH
97192: PPUSH
97193: PPUSH
97194: PPUSH
97195: PPUSH
// if not mc_bases then
97196: LD_EXP 172
97200: NOT
97201: IFFALSE 97205
// exit ;
97203: GO 97904
// for i = 1 to mc_bases do
97205: LD_ADDR_VAR 0 2
97209: PUSH
97210: DOUBLE
97211: LD_INT 1
97213: DEC
97214: ST_TO_ADDR
97215: LD_EXP 172
97219: PUSH
97220: FOR_TO
97221: IFFALSE 97902
// begin if not mc_bases [ i ] then
97223: LD_EXP 172
97227: PUSH
97228: LD_VAR 0 2
97232: ARRAY
97233: NOT
97234: IFFALSE 97238
// continue ;
97236: GO 97220
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
97238: LD_ADDR_VAR 0 7
97242: PUSH
97243: LD_EXP 172
97247: PUSH
97248: LD_VAR 0 2
97252: ARRAY
97253: PUSH
97254: LD_INT 1
97256: ARRAY
97257: PPUSH
97258: CALL 20932 0 1
97262: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
97263: LD_ADDR_EXP 195
97267: PUSH
97268: LD_EXP 195
97272: PPUSH
97273: LD_VAR 0 2
97277: PPUSH
97278: LD_EXP 172
97282: PUSH
97283: LD_VAR 0 2
97287: ARRAY
97288: PUSH
97289: LD_INT 1
97291: ARRAY
97292: PPUSH
97293: CALL_OW 255
97297: PPUSH
97298: LD_EXP 197
97302: PUSH
97303: LD_VAR 0 2
97307: ARRAY
97308: PPUSH
97309: CALL 20897 0 2
97313: PPUSH
97314: CALL_OW 1
97318: ST_TO_ADDR
// if not mc_scan [ i ] then
97319: LD_EXP 195
97323: PUSH
97324: LD_VAR 0 2
97328: ARRAY
97329: NOT
97330: IFFALSE 97508
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
97332: LD_ADDR_VAR 0 4
97336: PUSH
97337: LD_EXP 172
97341: PUSH
97342: LD_VAR 0 2
97346: ARRAY
97347: PPUSH
97348: LD_INT 2
97350: PUSH
97351: LD_INT 25
97353: PUSH
97354: LD_INT 5
97356: PUSH
97357: EMPTY
97358: LIST
97359: LIST
97360: PUSH
97361: LD_INT 25
97363: PUSH
97364: LD_INT 8
97366: PUSH
97367: EMPTY
97368: LIST
97369: LIST
97370: PUSH
97371: LD_INT 25
97373: PUSH
97374: LD_INT 9
97376: PUSH
97377: EMPTY
97378: LIST
97379: LIST
97380: PUSH
97381: EMPTY
97382: LIST
97383: LIST
97384: LIST
97385: LIST
97386: PPUSH
97387: CALL_OW 72
97391: ST_TO_ADDR
// if not tmp then
97392: LD_VAR 0 4
97396: NOT
97397: IFFALSE 97401
// continue ;
97399: GO 97220
// for j in tmp do
97401: LD_ADDR_VAR 0 3
97405: PUSH
97406: LD_VAR 0 4
97410: PUSH
97411: FOR_IN
97412: IFFALSE 97483
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
97414: LD_VAR 0 3
97418: PPUSH
97419: CALL_OW 310
97423: PPUSH
97424: CALL_OW 266
97428: PUSH
97429: LD_INT 5
97431: EQUAL
97432: PUSH
97433: LD_VAR 0 3
97437: PPUSH
97438: CALL_OW 257
97442: PUSH
97443: LD_INT 1
97445: EQUAL
97446: AND
97447: PUSH
97448: LD_VAR 0 3
97452: PPUSH
97453: CALL_OW 459
97457: NOT
97458: AND
97459: PUSH
97460: LD_VAR 0 7
97464: AND
97465: IFFALSE 97481
// ComChangeProfession ( j , class ) ;
97467: LD_VAR 0 3
97471: PPUSH
97472: LD_VAR 0 7
97476: PPUSH
97477: CALL_OW 123
97481: GO 97411
97483: POP
97484: POP
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
97485: LD_ADDR_EXP 215
97489: PUSH
97490: LD_EXP 215
97494: PPUSH
97495: LD_VAR 0 2
97499: PPUSH
97500: LD_INT 0
97502: PPUSH
97503: CALL_OW 1
97507: ST_TO_ADDR
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and not mc_defender [ i ] and not UnitFilter ( mc_bases [ i ] , [ f_btype , b_bunker ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
97508: LD_EXP 195
97512: PUSH
97513: LD_VAR 0 2
97517: ARRAY
97518: PUSH
97519: LD_EXP 215
97523: PUSH
97524: LD_VAR 0 2
97528: ARRAY
97529: NOT
97530: AND
97531: PUSH
97532: LD_EXP 194
97536: PUSH
97537: LD_VAR 0 2
97541: ARRAY
97542: NOT
97543: AND
97544: PUSH
97545: LD_EXP 172
97549: PUSH
97550: LD_VAR 0 2
97554: ARRAY
97555: PPUSH
97556: LD_INT 30
97558: PUSH
97559: LD_INT 32
97561: PUSH
97562: EMPTY
97563: LIST
97564: LIST
97565: PPUSH
97566: CALL_OW 72
97570: NOT
97571: AND
97572: PUSH
97573: LD_EXP 172
97577: PUSH
97578: LD_VAR 0 2
97582: ARRAY
97583: PPUSH
97584: LD_INT 2
97586: PUSH
97587: LD_INT 30
97589: PUSH
97590: LD_INT 4
97592: PUSH
97593: EMPTY
97594: LIST
97595: LIST
97596: PUSH
97597: LD_INT 30
97599: PUSH
97600: LD_INT 5
97602: PUSH
97603: EMPTY
97604: LIST
97605: LIST
97606: PUSH
97607: EMPTY
97608: LIST
97609: LIST
97610: LIST
97611: PPUSH
97612: CALL_OW 72
97616: NOT
97617: AND
97618: IFFALSE 97773
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
97620: LD_ADDR_VAR 0 4
97624: PUSH
97625: LD_EXP 172
97629: PUSH
97630: LD_VAR 0 2
97634: ARRAY
97635: PPUSH
97636: LD_INT 2
97638: PUSH
97639: LD_INT 25
97641: PUSH
97642: LD_INT 1
97644: PUSH
97645: EMPTY
97646: LIST
97647: LIST
97648: PUSH
97649: LD_INT 25
97651: PUSH
97652: LD_INT 5
97654: PUSH
97655: EMPTY
97656: LIST
97657: LIST
97658: PUSH
97659: LD_INT 25
97661: PUSH
97662: LD_INT 8
97664: PUSH
97665: EMPTY
97666: LIST
97667: LIST
97668: PUSH
97669: LD_INT 25
97671: PUSH
97672: LD_INT 9
97674: PUSH
97675: EMPTY
97676: LIST
97677: LIST
97678: PUSH
97679: EMPTY
97680: LIST
97681: LIST
97682: LIST
97683: LIST
97684: LIST
97685: PPUSH
97686: CALL_OW 72
97690: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
97691: LD_ADDR_VAR 0 4
97695: PUSH
97696: LD_VAR 0 4
97700: PUSH
97701: LD_VAR 0 4
97705: PPUSH
97706: LD_INT 18
97708: PPUSH
97709: CALL 52990 0 2
97713: DIFF
97714: ST_TO_ADDR
// if tmp then
97715: LD_VAR 0 4
97719: IFFALSE 97773
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
97721: LD_ADDR_EXP 215
97725: PUSH
97726: LD_EXP 215
97730: PPUSH
97731: LD_VAR 0 2
97735: PPUSH
97736: LD_INT 1
97738: PPUSH
97739: CALL_OW 1
97743: ST_TO_ADDR
// BasicDefend ( i , tmp , mc_scan_area [ i ] ) ;
97744: LD_VAR 0 2
97748: PPUSH
97749: LD_VAR 0 4
97753: PPUSH
97754: LD_EXP 197
97758: PUSH
97759: LD_VAR 0 2
97763: ARRAY
97764: PPUSH
97765: CALL 79004 0 3
// exit ;
97769: POP
97770: POP
97771: GO 97904
// end ; end ; if mc_scan [ i ] and not mc_is_defending [ i ] and mc_defender [ i ] then
97773: LD_EXP 195
97777: PUSH
97778: LD_VAR 0 2
97782: ARRAY
97783: PUSH
97784: LD_EXP 215
97788: PUSH
97789: LD_VAR 0 2
97793: ARRAY
97794: NOT
97795: AND
97796: PUSH
97797: LD_EXP 194
97801: PUSH
97802: LD_VAR 0 2
97806: ARRAY
97807: AND
97808: IFFALSE 97900
// begin tmp := mc_defender [ i ] ;
97810: LD_ADDR_VAR 0 4
97814: PUSH
97815: LD_EXP 194
97819: PUSH
97820: LD_VAR 0 2
97824: ARRAY
97825: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
97826: LD_ADDR_EXP 194
97830: PUSH
97831: LD_EXP 194
97835: PPUSH
97836: LD_VAR 0 2
97840: PPUSH
97841: EMPTY
97842: PPUSH
97843: CALL_OW 1
97847: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , true ) ;
97848: LD_ADDR_EXP 215
97852: PUSH
97853: LD_EXP 215
97857: PPUSH
97858: LD_VAR 0 2
97862: PPUSH
97863: LD_INT 1
97865: PPUSH
97866: CALL_OW 1
97870: ST_TO_ADDR
// Defend ( i , tmp , mc_scan [ i ] ) ;
97871: LD_VAR 0 2
97875: PPUSH
97876: LD_VAR 0 4
97880: PPUSH
97881: LD_EXP 195
97885: PUSH
97886: LD_VAR 0 2
97890: ARRAY
97891: PPUSH
97892: CALL 79565 0 3
// exit ;
97896: POP
97897: POP
97898: GO 97904
// end ; end ;
97900: GO 97220
97902: POP
97903: POP
// end ;
97904: LD_VAR 0 1
97908: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
97909: LD_INT 0
97911: PPUSH
97912: PPUSH
97913: PPUSH
97914: PPUSH
97915: PPUSH
97916: PPUSH
97917: PPUSH
97918: PPUSH
97919: PPUSH
97920: PPUSH
97921: PPUSH
// if not mc_bases then
97922: LD_EXP 172
97926: NOT
97927: IFFALSE 97931
// exit ;
97929: GO 99018
// for i = 1 to mc_bases do
97931: LD_ADDR_VAR 0 2
97935: PUSH
97936: DOUBLE
97937: LD_INT 1
97939: DEC
97940: ST_TO_ADDR
97941: LD_EXP 172
97945: PUSH
97946: FOR_TO
97947: IFFALSE 99016
// begin tmp := mc_lab [ i ] ;
97949: LD_ADDR_VAR 0 6
97953: PUSH
97954: LD_EXP 205
97958: PUSH
97959: LD_VAR 0 2
97963: ARRAY
97964: ST_TO_ADDR
// if not tmp then
97965: LD_VAR 0 6
97969: NOT
97970: IFFALSE 97974
// continue ;
97972: GO 97946
// idle_lab := 0 ;
97974: LD_ADDR_VAR 0 11
97978: PUSH
97979: LD_INT 0
97981: ST_TO_ADDR
// for j in tmp do
97982: LD_ADDR_VAR 0 3
97986: PUSH
97987: LD_VAR 0 6
97991: PUSH
97992: FOR_IN
97993: IFFALSE 99012
// begin researching := false ;
97995: LD_ADDR_VAR 0 10
97999: PUSH
98000: LD_INT 0
98002: ST_TO_ADDR
// side := GetSide ( j ) ;
98003: LD_ADDR_VAR 0 4
98007: PUSH
98008: LD_VAR 0 3
98012: PPUSH
98013: CALL_OW 255
98017: ST_TO_ADDR
// if not mc_tech [ side ] then
98018: LD_EXP 199
98022: PUSH
98023: LD_VAR 0 4
98027: ARRAY
98028: NOT
98029: IFFALSE 98033
// continue ;
98031: GO 97992
// if BuildingStatus ( j ) = bs_idle then
98033: LD_VAR 0 3
98037: PPUSH
98038: CALL_OW 461
98042: PUSH
98043: LD_INT 2
98045: EQUAL
98046: IFFALSE 98234
// begin if idle_lab and UnitsInside ( j ) < 6 then
98048: LD_VAR 0 11
98052: PUSH
98053: LD_VAR 0 3
98057: PPUSH
98058: CALL_OW 313
98062: PUSH
98063: LD_INT 6
98065: LESS
98066: AND
98067: IFFALSE 98138
// begin tmp2 := UnitsInside ( idle_lab ) ;
98069: LD_ADDR_VAR 0 9
98073: PUSH
98074: LD_VAR 0 11
98078: PPUSH
98079: CALL_OW 313
98083: ST_TO_ADDR
// if tmp2 then
98084: LD_VAR 0 9
98088: IFFALSE 98130
// for x in tmp2 do
98090: LD_ADDR_VAR 0 7
98094: PUSH
98095: LD_VAR 0 9
98099: PUSH
98100: FOR_IN
98101: IFFALSE 98128
// begin ComExitBuilding ( x ) ;
98103: LD_VAR 0 7
98107: PPUSH
98108: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
98112: LD_VAR 0 7
98116: PPUSH
98117: LD_VAR 0 3
98121: PPUSH
98122: CALL_OW 180
// end ;
98126: GO 98100
98128: POP
98129: POP
// idle_lab := 0 ;
98130: LD_ADDR_VAR 0 11
98134: PUSH
98135: LD_INT 0
98137: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
98138: LD_ADDR_VAR 0 5
98142: PUSH
98143: LD_EXP 199
98147: PUSH
98148: LD_VAR 0 4
98152: ARRAY
98153: PUSH
98154: FOR_IN
98155: IFFALSE 98215
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
98157: LD_VAR 0 3
98161: PPUSH
98162: LD_VAR 0 5
98166: PPUSH
98167: CALL_OW 430
98171: PUSH
98172: LD_VAR 0 4
98176: PPUSH
98177: LD_VAR 0 5
98181: PPUSH
98182: CALL 20002 0 2
98186: AND
98187: IFFALSE 98213
// begin researching := true ;
98189: LD_ADDR_VAR 0 10
98193: PUSH
98194: LD_INT 1
98196: ST_TO_ADDR
// ComResearch ( j , t ) ;
98197: LD_VAR 0 3
98201: PPUSH
98202: LD_VAR 0 5
98206: PPUSH
98207: CALL_OW 124
// break ;
98211: GO 98215
// end ;
98213: GO 98154
98215: POP
98216: POP
// if not researching then
98217: LD_VAR 0 10
98221: NOT
98222: IFFALSE 98234
// idle_lab := j ;
98224: LD_ADDR_VAR 0 11
98228: PUSH
98229: LD_VAR 0 3
98233: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
98234: LD_VAR 0 3
98238: PPUSH
98239: CALL_OW 461
98243: PUSH
98244: LD_INT 10
98246: EQUAL
98247: IFFALSE 98835
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
98249: LD_EXP 201
98253: PUSH
98254: LD_VAR 0 2
98258: ARRAY
98259: NOT
98260: PUSH
98261: LD_EXP 202
98265: PUSH
98266: LD_VAR 0 2
98270: ARRAY
98271: NOT
98272: AND
98273: PUSH
98274: LD_EXP 199
98278: PUSH
98279: LD_VAR 0 4
98283: ARRAY
98284: PUSH
98285: LD_INT 1
98287: GREATER
98288: AND
98289: IFFALSE 98420
// begin ComCancel ( j ) ;
98291: LD_VAR 0 3
98295: PPUSH
98296: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
98300: LD_ADDR_EXP 199
98304: PUSH
98305: LD_EXP 199
98309: PPUSH
98310: LD_VAR 0 4
98314: PPUSH
98315: LD_EXP 199
98319: PUSH
98320: LD_VAR 0 4
98324: ARRAY
98325: PPUSH
98326: LD_EXP 199
98330: PUSH
98331: LD_VAR 0 4
98335: ARRAY
98336: PUSH
98337: LD_INT 1
98339: MINUS
98340: PPUSH
98341: LD_EXP 199
98345: PUSH
98346: LD_VAR 0 4
98350: ARRAY
98351: PPUSH
98352: LD_INT 0
98354: PPUSH
98355: CALL 23514 0 4
98359: PPUSH
98360: CALL_OW 1
98364: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
98365: LD_ADDR_EXP 199
98369: PUSH
98370: LD_EXP 199
98374: PPUSH
98375: LD_VAR 0 4
98379: PPUSH
98380: LD_EXP 199
98384: PUSH
98385: LD_VAR 0 4
98389: ARRAY
98390: PPUSH
98391: LD_EXP 199
98395: PUSH
98396: LD_VAR 0 4
98400: ARRAY
98401: PPUSH
98402: LD_INT 1
98404: PPUSH
98405: LD_INT 0
98407: PPUSH
98408: CALL 23514 0 4
98412: PPUSH
98413: CALL_OW 1
98417: ST_TO_ADDR
// continue ;
98418: GO 97992
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
98420: LD_EXP 201
98424: PUSH
98425: LD_VAR 0 2
98429: ARRAY
98430: PUSH
98431: LD_EXP 202
98435: PUSH
98436: LD_VAR 0 2
98440: ARRAY
98441: NOT
98442: AND
98443: IFFALSE 98570
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
98445: LD_ADDR_EXP 202
98449: PUSH
98450: LD_EXP 202
98454: PPUSH
98455: LD_VAR 0 2
98459: PUSH
98460: LD_EXP 202
98464: PUSH
98465: LD_VAR 0 2
98469: ARRAY
98470: PUSH
98471: LD_INT 1
98473: PLUS
98474: PUSH
98475: EMPTY
98476: LIST
98477: LIST
98478: PPUSH
98479: LD_EXP 201
98483: PUSH
98484: LD_VAR 0 2
98488: ARRAY
98489: PUSH
98490: LD_INT 1
98492: ARRAY
98493: PPUSH
98494: CALL 24096 0 3
98498: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
98499: LD_EXP 201
98503: PUSH
98504: LD_VAR 0 2
98508: ARRAY
98509: PUSH
98510: LD_INT 1
98512: ARRAY
98513: PPUSH
98514: LD_INT 112
98516: PPUSH
98517: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
98521: LD_ADDR_VAR 0 9
98525: PUSH
98526: LD_EXP 201
98530: PUSH
98531: LD_VAR 0 2
98535: ARRAY
98536: PPUSH
98537: LD_INT 1
98539: PPUSH
98540: CALL_OW 3
98544: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
98545: LD_ADDR_EXP 201
98549: PUSH
98550: LD_EXP 201
98554: PPUSH
98555: LD_VAR 0 2
98559: PPUSH
98560: LD_VAR 0 9
98564: PPUSH
98565: CALL_OW 1
98569: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
98570: LD_EXP 201
98574: PUSH
98575: LD_VAR 0 2
98579: ARRAY
98580: PUSH
98581: LD_EXP 202
98585: PUSH
98586: LD_VAR 0 2
98590: ARRAY
98591: AND
98592: PUSH
98593: LD_EXP 202
98597: PUSH
98598: LD_VAR 0 2
98602: ARRAY
98603: PUSH
98604: LD_INT 1
98606: ARRAY
98607: PPUSH
98608: CALL_OW 310
98612: NOT
98613: AND
98614: PUSH
98615: LD_VAR 0 3
98619: PPUSH
98620: CALL_OW 313
98624: PUSH
98625: LD_INT 6
98627: EQUAL
98628: AND
98629: IFFALSE 98685
// begin tmp2 := UnitsInside ( j ) ;
98631: LD_ADDR_VAR 0 9
98635: PUSH
98636: LD_VAR 0 3
98640: PPUSH
98641: CALL_OW 313
98645: ST_TO_ADDR
// if tmp2 = 6 then
98646: LD_VAR 0 9
98650: PUSH
98651: LD_INT 6
98653: EQUAL
98654: IFFALSE 98685
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
98656: LD_VAR 0 9
98660: PUSH
98661: LD_INT 1
98663: ARRAY
98664: PPUSH
98665: LD_INT 112
98667: PPUSH
98668: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
98672: LD_VAR 0 9
98676: PUSH
98677: LD_INT 1
98679: ARRAY
98680: PPUSH
98681: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
98685: LD_EXP 202
98689: PUSH
98690: LD_VAR 0 2
98694: ARRAY
98695: PUSH
98696: LD_EXP 202
98700: PUSH
98701: LD_VAR 0 2
98705: ARRAY
98706: PUSH
98707: LD_INT 1
98709: ARRAY
98710: PPUSH
98711: CALL_OW 314
98715: NOT
98716: AND
98717: PUSH
98718: LD_EXP 202
98722: PUSH
98723: LD_VAR 0 2
98727: ARRAY
98728: PUSH
98729: LD_INT 1
98731: ARRAY
98732: PPUSH
98733: CALL_OW 310
98737: NOT
98738: AND
98739: IFFALSE 98765
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
98741: LD_EXP 202
98745: PUSH
98746: LD_VAR 0 2
98750: ARRAY
98751: PUSH
98752: LD_INT 1
98754: ARRAY
98755: PPUSH
98756: LD_VAR 0 3
98760: PPUSH
98761: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
98765: LD_EXP 202
98769: PUSH
98770: LD_VAR 0 2
98774: ARRAY
98775: PUSH
98776: LD_INT 1
98778: ARRAY
98779: PPUSH
98780: CALL_OW 310
98784: PUSH
98785: LD_EXP 202
98789: PUSH
98790: LD_VAR 0 2
98794: ARRAY
98795: PUSH
98796: LD_INT 1
98798: ARRAY
98799: PPUSH
98800: CALL_OW 310
98804: PPUSH
98805: CALL_OW 461
98809: PUSH
98810: LD_INT 3
98812: NONEQUAL
98813: AND
98814: IFFALSE 98835
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
98816: LD_EXP 202
98820: PUSH
98821: LD_VAR 0 2
98825: ARRAY
98826: PUSH
98827: LD_INT 1
98829: ARRAY
98830: PPUSH
98831: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
98835: LD_VAR 0 3
98839: PPUSH
98840: CALL_OW 461
98844: PUSH
98845: LD_INT 6
98847: EQUAL
98848: PUSH
98849: LD_VAR 0 6
98853: PUSH
98854: LD_INT 1
98856: GREATER
98857: AND
98858: IFFALSE 99010
// begin sci := [ ] ;
98860: LD_ADDR_VAR 0 8
98864: PUSH
98865: EMPTY
98866: ST_TO_ADDR
// for x in ( tmp diff j ) do
98867: LD_ADDR_VAR 0 7
98871: PUSH
98872: LD_VAR 0 6
98876: PUSH
98877: LD_VAR 0 3
98881: DIFF
98882: PUSH
98883: FOR_IN
98884: IFFALSE 98936
// begin if sci = 6 then
98886: LD_VAR 0 8
98890: PUSH
98891: LD_INT 6
98893: EQUAL
98894: IFFALSE 98898
// break ;
98896: GO 98936
// if BuildingStatus ( x ) = bs_idle then
98898: LD_VAR 0 7
98902: PPUSH
98903: CALL_OW 461
98907: PUSH
98908: LD_INT 2
98910: EQUAL
98911: IFFALSE 98934
// sci := sci ^ UnitsInside ( x ) ;
98913: LD_ADDR_VAR 0 8
98917: PUSH
98918: LD_VAR 0 8
98922: PUSH
98923: LD_VAR 0 7
98927: PPUSH
98928: CALL_OW 313
98932: ADD
98933: ST_TO_ADDR
// end ;
98934: GO 98883
98936: POP
98937: POP
// if not sci then
98938: LD_VAR 0 8
98942: NOT
98943: IFFALSE 98947
// continue ;
98945: GO 97992
// for x in sci do
98947: LD_ADDR_VAR 0 7
98951: PUSH
98952: LD_VAR 0 8
98956: PUSH
98957: FOR_IN
98958: IFFALSE 99008
// if IsInUnit ( x ) and not HasTask ( x ) then
98960: LD_VAR 0 7
98964: PPUSH
98965: CALL_OW 310
98969: PUSH
98970: LD_VAR 0 7
98974: PPUSH
98975: CALL_OW 314
98979: NOT
98980: AND
98981: IFFALSE 99006
// begin ComExitBuilding ( x ) ;
98983: LD_VAR 0 7
98987: PPUSH
98988: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
98992: LD_VAR 0 7
98996: PPUSH
98997: LD_VAR 0 3
99001: PPUSH
99002: CALL_OW 180
// end ;
99006: GO 98957
99008: POP
99009: POP
// end ; end ;
99010: GO 97992
99012: POP
99013: POP
// end ;
99014: GO 97946
99016: POP
99017: POP
// end ;
99018: LD_VAR 0 1
99022: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
99023: LD_INT 0
99025: PPUSH
99026: PPUSH
// if not mc_bases then
99027: LD_EXP 172
99031: NOT
99032: IFFALSE 99036
// exit ;
99034: GO 99117
// for i = 1 to mc_bases do
99036: LD_ADDR_VAR 0 2
99040: PUSH
99041: DOUBLE
99042: LD_INT 1
99044: DEC
99045: ST_TO_ADDR
99046: LD_EXP 172
99050: PUSH
99051: FOR_TO
99052: IFFALSE 99115
// if mc_mines [ i ] and mc_miners [ i ] then
99054: LD_EXP 185
99058: PUSH
99059: LD_VAR 0 2
99063: ARRAY
99064: PUSH
99065: LD_EXP 186
99069: PUSH
99070: LD_VAR 0 2
99074: ARRAY
99075: AND
99076: IFFALSE 99113
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
99078: LD_EXP 186
99082: PUSH
99083: LD_VAR 0 2
99087: ARRAY
99088: PUSH
99089: LD_INT 1
99091: ARRAY
99092: PPUSH
99093: CALL_OW 255
99097: PPUSH
99098: LD_EXP 185
99102: PUSH
99103: LD_VAR 0 2
99107: ARRAY
99108: PPUSH
99109: CALL 21085 0 2
99113: GO 99051
99115: POP
99116: POP
// end ;
99117: LD_VAR 0 1
99121: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
99122: LD_INT 0
99124: PPUSH
99125: PPUSH
99126: PPUSH
99127: PPUSH
99128: PPUSH
99129: PPUSH
99130: PPUSH
99131: PPUSH
// if not mc_bases or not mc_parking then
99132: LD_EXP 172
99136: NOT
99137: PUSH
99138: LD_EXP 196
99142: NOT
99143: OR
99144: IFFALSE 99148
// exit ;
99146: GO 99847
// for i = 1 to mc_bases do
99148: LD_ADDR_VAR 0 2
99152: PUSH
99153: DOUBLE
99154: LD_INT 1
99156: DEC
99157: ST_TO_ADDR
99158: LD_EXP 172
99162: PUSH
99163: FOR_TO
99164: IFFALSE 99845
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
99166: LD_EXP 172
99170: PUSH
99171: LD_VAR 0 2
99175: ARRAY
99176: NOT
99177: PUSH
99178: LD_EXP 196
99182: PUSH
99183: LD_VAR 0 2
99187: ARRAY
99188: NOT
99189: OR
99190: IFFALSE 99194
// continue ;
99192: GO 99163
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
99194: LD_ADDR_VAR 0 5
99198: PUSH
99199: LD_EXP 172
99203: PUSH
99204: LD_VAR 0 2
99208: ARRAY
99209: PUSH
99210: LD_INT 1
99212: ARRAY
99213: PPUSH
99214: CALL_OW 255
99218: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
99219: LD_ADDR_VAR 0 6
99223: PUSH
99224: LD_EXP 172
99228: PUSH
99229: LD_VAR 0 2
99233: ARRAY
99234: PPUSH
99235: LD_INT 30
99237: PUSH
99238: LD_INT 3
99240: PUSH
99241: EMPTY
99242: LIST
99243: LIST
99244: PPUSH
99245: CALL_OW 72
99249: ST_TO_ADDR
// if not fac then
99250: LD_VAR 0 6
99254: NOT
99255: IFFALSE 99306
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
99257: LD_ADDR_VAR 0 6
99261: PUSH
99262: LD_EXP 172
99266: PUSH
99267: LD_VAR 0 2
99271: ARRAY
99272: PPUSH
99273: LD_INT 2
99275: PUSH
99276: LD_INT 30
99278: PUSH
99279: LD_INT 0
99281: PUSH
99282: EMPTY
99283: LIST
99284: LIST
99285: PUSH
99286: LD_INT 30
99288: PUSH
99289: LD_INT 1
99291: PUSH
99292: EMPTY
99293: LIST
99294: LIST
99295: PUSH
99296: EMPTY
99297: LIST
99298: LIST
99299: LIST
99300: PPUSH
99301: CALL_OW 72
99305: ST_TO_ADDR
// if not fac then
99306: LD_VAR 0 6
99310: NOT
99311: IFFALSE 99315
// continue ;
99313: GO 99163
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
99315: LD_ADDR_VAR 0 7
99319: PUSH
99320: LD_EXP 196
99324: PUSH
99325: LD_VAR 0 2
99329: ARRAY
99330: PPUSH
99331: LD_INT 22
99333: PUSH
99334: LD_VAR 0 5
99338: PUSH
99339: EMPTY
99340: LIST
99341: LIST
99342: PUSH
99343: LD_INT 21
99345: PUSH
99346: LD_INT 2
99348: PUSH
99349: EMPTY
99350: LIST
99351: LIST
99352: PUSH
99353: LD_INT 3
99355: PUSH
99356: LD_INT 24
99358: PUSH
99359: LD_INT 1000
99361: PUSH
99362: EMPTY
99363: LIST
99364: LIST
99365: PUSH
99366: EMPTY
99367: LIST
99368: LIST
99369: PUSH
99370: EMPTY
99371: LIST
99372: LIST
99373: LIST
99374: PPUSH
99375: CALL_OW 70
99379: ST_TO_ADDR
// for j in fac do
99380: LD_ADDR_VAR 0 3
99384: PUSH
99385: LD_VAR 0 6
99389: PUSH
99390: FOR_IN
99391: IFFALSE 99472
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
99393: LD_ADDR_VAR 0 7
99397: PUSH
99398: LD_VAR 0 7
99402: PUSH
99403: LD_INT 22
99405: PUSH
99406: LD_VAR 0 5
99410: PUSH
99411: EMPTY
99412: LIST
99413: LIST
99414: PUSH
99415: LD_INT 91
99417: PUSH
99418: LD_VAR 0 3
99422: PUSH
99423: LD_INT 15
99425: PUSH
99426: EMPTY
99427: LIST
99428: LIST
99429: LIST
99430: PUSH
99431: LD_INT 21
99433: PUSH
99434: LD_INT 2
99436: PUSH
99437: EMPTY
99438: LIST
99439: LIST
99440: PUSH
99441: LD_INT 3
99443: PUSH
99444: LD_INT 24
99446: PUSH
99447: LD_INT 1000
99449: PUSH
99450: EMPTY
99451: LIST
99452: LIST
99453: PUSH
99454: EMPTY
99455: LIST
99456: LIST
99457: PUSH
99458: EMPTY
99459: LIST
99460: LIST
99461: LIST
99462: LIST
99463: PPUSH
99464: CALL_OW 69
99468: UNION
99469: ST_TO_ADDR
99470: GO 99390
99472: POP
99473: POP
// if not vehs then
99474: LD_VAR 0 7
99478: NOT
99479: IFFALSE 99505
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
99481: LD_ADDR_EXP 184
99485: PUSH
99486: LD_EXP 184
99490: PPUSH
99491: LD_VAR 0 2
99495: PPUSH
99496: EMPTY
99497: PPUSH
99498: CALL_OW 1
99502: ST_TO_ADDR
// continue ;
99503: GO 99163
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
99505: LD_ADDR_VAR 0 8
99509: PUSH
99510: LD_EXP 172
99514: PUSH
99515: LD_VAR 0 2
99519: ARRAY
99520: PPUSH
99521: LD_INT 30
99523: PUSH
99524: LD_INT 3
99526: PUSH
99527: EMPTY
99528: LIST
99529: LIST
99530: PPUSH
99531: CALL_OW 72
99535: ST_TO_ADDR
// if tmp then
99536: LD_VAR 0 8
99540: IFFALSE 99643
// begin for j in tmp do
99542: LD_ADDR_VAR 0 3
99546: PUSH
99547: LD_VAR 0 8
99551: PUSH
99552: FOR_IN
99553: IFFALSE 99641
// for k in UnitsInside ( j ) do
99555: LD_ADDR_VAR 0 4
99559: PUSH
99560: LD_VAR 0 3
99564: PPUSH
99565: CALL_OW 313
99569: PUSH
99570: FOR_IN
99571: IFFALSE 99637
// if k then
99573: LD_VAR 0 4
99577: IFFALSE 99635
// if not k in mc_repair_vehicle [ i ] then
99579: LD_VAR 0 4
99583: PUSH
99584: LD_EXP 184
99588: PUSH
99589: LD_VAR 0 2
99593: ARRAY
99594: IN
99595: NOT
99596: IFFALSE 99635
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
99598: LD_ADDR_EXP 184
99602: PUSH
99603: LD_EXP 184
99607: PPUSH
99608: LD_VAR 0 2
99612: PPUSH
99613: LD_EXP 184
99617: PUSH
99618: LD_VAR 0 2
99622: ARRAY
99623: PUSH
99624: LD_VAR 0 4
99628: UNION
99629: PPUSH
99630: CALL_OW 1
99634: ST_TO_ADDR
99635: GO 99570
99637: POP
99638: POP
99639: GO 99552
99641: POP
99642: POP
// end ; if not mc_repair_vehicle [ i ] then
99643: LD_EXP 184
99647: PUSH
99648: LD_VAR 0 2
99652: ARRAY
99653: NOT
99654: IFFALSE 99658
// continue ;
99656: GO 99163
// for j in mc_repair_vehicle [ i ] do
99658: LD_ADDR_VAR 0 3
99662: PUSH
99663: LD_EXP 184
99667: PUSH
99668: LD_VAR 0 2
99672: ARRAY
99673: PUSH
99674: FOR_IN
99675: IFFALSE 99841
// begin if GetClass ( j ) <> 3 then
99677: LD_VAR 0 3
99681: PPUSH
99682: CALL_OW 257
99686: PUSH
99687: LD_INT 3
99689: NONEQUAL
99690: IFFALSE 99731
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
99692: LD_ADDR_EXP 184
99696: PUSH
99697: LD_EXP 184
99701: PPUSH
99702: LD_VAR 0 2
99706: PPUSH
99707: LD_EXP 184
99711: PUSH
99712: LD_VAR 0 2
99716: ARRAY
99717: PUSH
99718: LD_VAR 0 3
99722: DIFF
99723: PPUSH
99724: CALL_OW 1
99728: ST_TO_ADDR
// continue ;
99729: GO 99674
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
99731: LD_VAR 0 3
99735: PPUSH
99736: CALL_OW 311
99740: NOT
99741: PUSH
99742: LD_VAR 0 3
99746: PUSH
99747: LD_EXP 175
99751: PUSH
99752: LD_VAR 0 2
99756: ARRAY
99757: PUSH
99758: LD_INT 1
99760: ARRAY
99761: IN
99762: NOT
99763: AND
99764: PUSH
99765: LD_VAR 0 3
99769: PUSH
99770: LD_EXP 175
99774: PUSH
99775: LD_VAR 0 2
99779: ARRAY
99780: PUSH
99781: LD_INT 2
99783: ARRAY
99784: IN
99785: NOT
99786: AND
99787: IFFALSE 99839
// begin if IsInUnit ( j ) then
99789: LD_VAR 0 3
99793: PPUSH
99794: CALL_OW 310
99798: IFFALSE 99809
// ComExitBuilding ( j ) ;
99800: LD_VAR 0 3
99804: PPUSH
99805: CALL_OW 122
// if not HasTask ( j ) then
99809: LD_VAR 0 3
99813: PPUSH
99814: CALL_OW 314
99818: NOT
99819: IFFALSE 99839
// AddComRepairVehicle ( j , vehs [ 1 ] ) ;
99821: LD_VAR 0 3
99825: PPUSH
99826: LD_VAR 0 7
99830: PUSH
99831: LD_INT 1
99833: ARRAY
99834: PPUSH
99835: CALL_OW 189
// end ; end ;
99839: GO 99674
99841: POP
99842: POP
// end ;
99843: GO 99163
99845: POP
99846: POP
// end ;
99847: LD_VAR 0 1
99851: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
99852: LD_INT 0
99854: PPUSH
99855: PPUSH
99856: PPUSH
99857: PPUSH
99858: PPUSH
99859: PPUSH
99860: PPUSH
99861: PPUSH
99862: PPUSH
99863: PPUSH
99864: PPUSH
// if not mc_bases then
99865: LD_EXP 172
99869: NOT
99870: IFFALSE 99874
// exit ;
99872: GO 100676
// for i = 1 to mc_bases do
99874: LD_ADDR_VAR 0 2
99878: PUSH
99879: DOUBLE
99880: LD_INT 1
99882: DEC
99883: ST_TO_ADDR
99884: LD_EXP 172
99888: PUSH
99889: FOR_TO
99890: IFFALSE 100674
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
99892: LD_EXP 200
99896: PUSH
99897: LD_VAR 0 2
99901: ARRAY
99902: NOT
99903: PUSH
99904: LD_EXP 175
99908: PUSH
99909: LD_VAR 0 2
99913: ARRAY
99914: PUSH
99915: LD_INT 1
99917: ARRAY
99918: OR
99919: PUSH
99920: LD_EXP 175
99924: PUSH
99925: LD_VAR 0 2
99929: ARRAY
99930: PUSH
99931: LD_INT 2
99933: ARRAY
99934: OR
99935: PUSH
99936: LD_EXP 198
99940: PUSH
99941: LD_VAR 0 2
99945: ARRAY
99946: PPUSH
99947: LD_INT 1
99949: PPUSH
99950: CALL_OW 325
99954: NOT
99955: OR
99956: PUSH
99957: LD_EXP 195
99961: PUSH
99962: LD_VAR 0 2
99966: ARRAY
99967: OR
99968: IFFALSE 99972
// continue ;
99970: GO 99889
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
99972: LD_ADDR_VAR 0 8
99976: PUSH
99977: LD_EXP 172
99981: PUSH
99982: LD_VAR 0 2
99986: ARRAY
99987: PPUSH
99988: LD_INT 25
99990: PUSH
99991: LD_INT 4
99993: PUSH
99994: EMPTY
99995: LIST
99996: LIST
99997: PUSH
99998: LD_INT 50
100000: PUSH
100001: EMPTY
100002: LIST
100003: PUSH
100004: LD_INT 3
100006: PUSH
100007: LD_INT 60
100009: PUSH
100010: EMPTY
100011: LIST
100012: PUSH
100013: EMPTY
100014: LIST
100015: LIST
100016: PUSH
100017: EMPTY
100018: LIST
100019: LIST
100020: LIST
100021: PPUSH
100022: CALL_OW 72
100026: PUSH
100027: LD_EXP 176
100031: PUSH
100032: LD_VAR 0 2
100036: ARRAY
100037: DIFF
100038: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
100039: LD_ADDR_VAR 0 9
100043: PUSH
100044: LD_EXP 172
100048: PUSH
100049: LD_VAR 0 2
100053: ARRAY
100054: PPUSH
100055: LD_INT 2
100057: PUSH
100058: LD_INT 30
100060: PUSH
100061: LD_INT 0
100063: PUSH
100064: EMPTY
100065: LIST
100066: LIST
100067: PUSH
100068: LD_INT 30
100070: PUSH
100071: LD_INT 1
100073: PUSH
100074: EMPTY
100075: LIST
100076: LIST
100077: PUSH
100078: EMPTY
100079: LIST
100080: LIST
100081: LIST
100082: PPUSH
100083: CALL_OW 72
100087: ST_TO_ADDR
// if not tmp or not dep then
100088: LD_VAR 0 8
100092: NOT
100093: PUSH
100094: LD_VAR 0 9
100098: NOT
100099: OR
100100: IFFALSE 100104
// continue ;
100102: GO 99889
// side := GetSide ( tmp [ 1 ] ) ;
100104: LD_ADDR_VAR 0 11
100108: PUSH
100109: LD_VAR 0 8
100113: PUSH
100114: LD_INT 1
100116: ARRAY
100117: PPUSH
100118: CALL_OW 255
100122: ST_TO_ADDR
// dep := dep [ 1 ] ;
100123: LD_ADDR_VAR 0 9
100127: PUSH
100128: LD_VAR 0 9
100132: PUSH
100133: LD_INT 1
100135: ARRAY
100136: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
100137: LD_ADDR_VAR 0 7
100141: PUSH
100142: LD_EXP 200
100146: PUSH
100147: LD_VAR 0 2
100151: ARRAY
100152: PPUSH
100153: LD_INT 22
100155: PUSH
100156: LD_INT 0
100158: PUSH
100159: EMPTY
100160: LIST
100161: LIST
100162: PUSH
100163: LD_INT 25
100165: PUSH
100166: LD_INT 12
100168: PUSH
100169: EMPTY
100170: LIST
100171: LIST
100172: PUSH
100173: EMPTY
100174: LIST
100175: LIST
100176: PPUSH
100177: CALL_OW 70
100181: PUSH
100182: LD_INT 22
100184: PUSH
100185: LD_INT 0
100187: PUSH
100188: EMPTY
100189: LIST
100190: LIST
100191: PUSH
100192: LD_INT 25
100194: PUSH
100195: LD_INT 12
100197: PUSH
100198: EMPTY
100199: LIST
100200: LIST
100201: PUSH
100202: LD_INT 91
100204: PUSH
100205: LD_VAR 0 9
100209: PUSH
100210: LD_INT 20
100212: PUSH
100213: EMPTY
100214: LIST
100215: LIST
100216: LIST
100217: PUSH
100218: EMPTY
100219: LIST
100220: LIST
100221: LIST
100222: PPUSH
100223: CALL_OW 69
100227: UNION
100228: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
100229: LD_ADDR_VAR 0 10
100233: PUSH
100234: LD_EXP 200
100238: PUSH
100239: LD_VAR 0 2
100243: ARRAY
100244: PPUSH
100245: LD_INT 81
100247: PUSH
100248: LD_VAR 0 11
100252: PUSH
100253: EMPTY
100254: LIST
100255: LIST
100256: PPUSH
100257: CALL_OW 70
100261: ST_TO_ADDR
// if not apes or danger_at_area then
100262: LD_VAR 0 7
100266: NOT
100267: PUSH
100268: LD_VAR 0 10
100272: OR
100273: IFFALSE 100323
// begin if mc_taming [ i ] then
100275: LD_EXP 203
100279: PUSH
100280: LD_VAR 0 2
100284: ARRAY
100285: IFFALSE 100321
// begin MC_Reset ( i , 121 ) ;
100287: LD_VAR 0 2
100291: PPUSH
100292: LD_INT 121
100294: PPUSH
100295: CALL 85610 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
100299: LD_ADDR_EXP 203
100303: PUSH
100304: LD_EXP 203
100308: PPUSH
100309: LD_VAR 0 2
100313: PPUSH
100314: EMPTY
100315: PPUSH
100316: CALL_OW 1
100320: ST_TO_ADDR
// end ; continue ;
100321: GO 99889
// end ; for j in tmp do
100323: LD_ADDR_VAR 0 3
100327: PUSH
100328: LD_VAR 0 8
100332: PUSH
100333: FOR_IN
100334: IFFALSE 100670
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
100336: LD_VAR 0 3
100340: PUSH
100341: LD_EXP 203
100345: PUSH
100346: LD_VAR 0 2
100350: ARRAY
100351: IN
100352: NOT
100353: PUSH
100354: LD_EXP 203
100358: PUSH
100359: LD_VAR 0 2
100363: ARRAY
100364: PUSH
100365: LD_INT 3
100367: LESS
100368: AND
100369: IFFALSE 100427
// begin SetTag ( j , 121 ) ;
100371: LD_VAR 0 3
100375: PPUSH
100376: LD_INT 121
100378: PPUSH
100379: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
100383: LD_ADDR_EXP 203
100387: PUSH
100388: LD_EXP 203
100392: PPUSH
100393: LD_VAR 0 2
100397: PUSH
100398: LD_EXP 203
100402: PUSH
100403: LD_VAR 0 2
100407: ARRAY
100408: PUSH
100409: LD_INT 1
100411: PLUS
100412: PUSH
100413: EMPTY
100414: LIST
100415: LIST
100416: PPUSH
100417: LD_VAR 0 3
100421: PPUSH
100422: CALL 24096 0 3
100426: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
100427: LD_VAR 0 3
100431: PUSH
100432: LD_EXP 203
100436: PUSH
100437: LD_VAR 0 2
100441: ARRAY
100442: IN
100443: IFFALSE 100668
// begin if GetClass ( j ) <> 4 then
100445: LD_VAR 0 3
100449: PPUSH
100450: CALL_OW 257
100454: PUSH
100455: LD_INT 4
100457: NONEQUAL
100458: IFFALSE 100511
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
100460: LD_ADDR_EXP 203
100464: PUSH
100465: LD_EXP 203
100469: PPUSH
100470: LD_VAR 0 2
100474: PPUSH
100475: LD_EXP 203
100479: PUSH
100480: LD_VAR 0 2
100484: ARRAY
100485: PUSH
100486: LD_VAR 0 3
100490: DIFF
100491: PPUSH
100492: CALL_OW 1
100496: ST_TO_ADDR
// SetTag ( j , 0 ) ;
100497: LD_VAR 0 3
100501: PPUSH
100502: LD_INT 0
100504: PPUSH
100505: CALL_OW 109
// continue ;
100509: GO 100333
// end ; if IsInUnit ( j ) then
100511: LD_VAR 0 3
100515: PPUSH
100516: CALL_OW 310
100520: IFFALSE 100531
// ComExitBuilding ( j ) ;
100522: LD_VAR 0 3
100526: PPUSH
100527: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
100531: LD_ADDR_VAR 0 6
100535: PUSH
100536: LD_VAR 0 7
100540: PPUSH
100541: LD_VAR 0 3
100545: PPUSH
100546: CALL_OW 74
100550: ST_TO_ADDR
// if not ape then
100551: LD_VAR 0 6
100555: NOT
100556: IFFALSE 100560
// break ;
100558: GO 100670
// x := GetX ( ape ) ;
100560: LD_ADDR_VAR 0 4
100564: PUSH
100565: LD_VAR 0 6
100569: PPUSH
100570: CALL_OW 250
100574: ST_TO_ADDR
// y := GetY ( ape ) ;
100575: LD_ADDR_VAR 0 5
100579: PUSH
100580: LD_VAR 0 6
100584: PPUSH
100585: CALL_OW 251
100589: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
100590: LD_VAR 0 4
100594: PPUSH
100595: LD_VAR 0 5
100599: PPUSH
100600: CALL_OW 488
100604: NOT
100605: PUSH
100606: LD_VAR 0 11
100610: PPUSH
100611: LD_VAR 0 4
100615: PPUSH
100616: LD_VAR 0 5
100620: PPUSH
100621: LD_INT 20
100623: PPUSH
100624: CALL 24992 0 4
100628: PUSH
100629: LD_INT 4
100631: ARRAY
100632: OR
100633: IFFALSE 100637
// break ;
100635: GO 100670
// if not HasTask ( j ) then
100637: LD_VAR 0 3
100641: PPUSH
100642: CALL_OW 314
100646: NOT
100647: IFFALSE 100668
// ComTameXY ( j , x , y ) ;
100649: LD_VAR 0 3
100653: PPUSH
100654: LD_VAR 0 4
100658: PPUSH
100659: LD_VAR 0 5
100663: PPUSH
100664: CALL_OW 131
// end ; end ;
100668: GO 100333
100670: POP
100671: POP
// end ;
100672: GO 99889
100674: POP
100675: POP
// end ;
100676: LD_VAR 0 1
100680: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
100681: LD_INT 0
100683: PPUSH
100684: PPUSH
100685: PPUSH
100686: PPUSH
100687: PPUSH
100688: PPUSH
100689: PPUSH
100690: PPUSH
// if not mc_bases then
100691: LD_EXP 172
100695: NOT
100696: IFFALSE 100700
// exit ;
100698: GO 101326
// for i = 1 to mc_bases do
100700: LD_ADDR_VAR 0 2
100704: PUSH
100705: DOUBLE
100706: LD_INT 1
100708: DEC
100709: ST_TO_ADDR
100710: LD_EXP 172
100714: PUSH
100715: FOR_TO
100716: IFFALSE 101324
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
100718: LD_EXP 201
100722: PUSH
100723: LD_VAR 0 2
100727: ARRAY
100728: NOT
100729: PUSH
100730: LD_EXP 201
100734: PUSH
100735: LD_VAR 0 2
100739: ARRAY
100740: PPUSH
100741: LD_INT 25
100743: PUSH
100744: LD_INT 12
100746: PUSH
100747: EMPTY
100748: LIST
100749: LIST
100750: PPUSH
100751: CALL_OW 72
100755: NOT
100756: OR
100757: IFFALSE 100761
// continue ;
100759: GO 100715
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
100761: LD_ADDR_VAR 0 5
100765: PUSH
100766: LD_EXP 201
100770: PUSH
100771: LD_VAR 0 2
100775: ARRAY
100776: PUSH
100777: LD_INT 1
100779: ARRAY
100780: PPUSH
100781: CALL_OW 255
100785: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
100786: LD_VAR 0 5
100790: PPUSH
100791: LD_INT 2
100793: PPUSH
100794: CALL_OW 325
100798: IFFALSE 101051
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
100800: LD_ADDR_VAR 0 4
100804: PUSH
100805: LD_EXP 201
100809: PUSH
100810: LD_VAR 0 2
100814: ARRAY
100815: PPUSH
100816: LD_INT 25
100818: PUSH
100819: LD_INT 16
100821: PUSH
100822: EMPTY
100823: LIST
100824: LIST
100825: PPUSH
100826: CALL_OW 72
100830: ST_TO_ADDR
// if tmp < 6 then
100831: LD_VAR 0 4
100835: PUSH
100836: LD_INT 6
100838: LESS
100839: IFFALSE 101051
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
100841: LD_ADDR_VAR 0 6
100845: PUSH
100846: LD_EXP 172
100850: PUSH
100851: LD_VAR 0 2
100855: ARRAY
100856: PPUSH
100857: LD_INT 2
100859: PUSH
100860: LD_INT 30
100862: PUSH
100863: LD_INT 0
100865: PUSH
100866: EMPTY
100867: LIST
100868: LIST
100869: PUSH
100870: LD_INT 30
100872: PUSH
100873: LD_INT 1
100875: PUSH
100876: EMPTY
100877: LIST
100878: LIST
100879: PUSH
100880: EMPTY
100881: LIST
100882: LIST
100883: LIST
100884: PPUSH
100885: CALL_OW 72
100889: ST_TO_ADDR
// if depot then
100890: LD_VAR 0 6
100894: IFFALSE 101051
// begin selected := 0 ;
100896: LD_ADDR_VAR 0 7
100900: PUSH
100901: LD_INT 0
100903: ST_TO_ADDR
// for j in depot do
100904: LD_ADDR_VAR 0 3
100908: PUSH
100909: LD_VAR 0 6
100913: PUSH
100914: FOR_IN
100915: IFFALSE 100946
// begin if UnitsInside ( j ) < 6 then
100917: LD_VAR 0 3
100921: PPUSH
100922: CALL_OW 313
100926: PUSH
100927: LD_INT 6
100929: LESS
100930: IFFALSE 100944
// begin selected := j ;
100932: LD_ADDR_VAR 0 7
100936: PUSH
100937: LD_VAR 0 3
100941: ST_TO_ADDR
// break ;
100942: GO 100946
// end ; end ;
100944: GO 100914
100946: POP
100947: POP
// if selected then
100948: LD_VAR 0 7
100952: IFFALSE 101051
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
100954: LD_ADDR_VAR 0 3
100958: PUSH
100959: LD_EXP 201
100963: PUSH
100964: LD_VAR 0 2
100968: ARRAY
100969: PPUSH
100970: LD_INT 25
100972: PUSH
100973: LD_INT 12
100975: PUSH
100976: EMPTY
100977: LIST
100978: LIST
100979: PPUSH
100980: CALL_OW 72
100984: PUSH
100985: FOR_IN
100986: IFFALSE 101049
// if not HasTask ( j ) then
100988: LD_VAR 0 3
100992: PPUSH
100993: CALL_OW 314
100997: NOT
100998: IFFALSE 101047
// begin if not IsInUnit ( j ) then
101000: LD_VAR 0 3
101004: PPUSH
101005: CALL_OW 310
101009: NOT
101010: IFFALSE 101026
// ComEnterUnit ( j , selected ) ;
101012: LD_VAR 0 3
101016: PPUSH
101017: LD_VAR 0 7
101021: PPUSH
101022: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
101026: LD_VAR 0 3
101030: PPUSH
101031: LD_INT 16
101033: PPUSH
101034: CALL_OW 183
// AddComExitBuilding ( j ) ;
101038: LD_VAR 0 3
101042: PPUSH
101043: CALL_OW 182
// end ;
101047: GO 100985
101049: POP
101050: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
101051: LD_VAR 0 5
101055: PPUSH
101056: LD_INT 11
101058: PPUSH
101059: CALL_OW 325
101063: IFFALSE 101322
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
101065: LD_ADDR_VAR 0 4
101069: PUSH
101070: LD_EXP 201
101074: PUSH
101075: LD_VAR 0 2
101079: ARRAY
101080: PPUSH
101081: LD_INT 25
101083: PUSH
101084: LD_INT 16
101086: PUSH
101087: EMPTY
101088: LIST
101089: LIST
101090: PPUSH
101091: CALL_OW 72
101095: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
101096: LD_VAR 0 4
101100: PUSH
101101: LD_INT 6
101103: GREATEREQUAL
101104: PUSH
101105: LD_VAR 0 5
101109: PPUSH
101110: LD_INT 2
101112: PPUSH
101113: CALL_OW 325
101117: NOT
101118: OR
101119: IFFALSE 101322
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
101121: LD_ADDR_VAR 0 8
101125: PUSH
101126: LD_EXP 172
101130: PUSH
101131: LD_VAR 0 2
101135: ARRAY
101136: PPUSH
101137: LD_INT 2
101139: PUSH
101140: LD_INT 30
101142: PUSH
101143: LD_INT 4
101145: PUSH
101146: EMPTY
101147: LIST
101148: LIST
101149: PUSH
101150: LD_INT 30
101152: PUSH
101153: LD_INT 5
101155: PUSH
101156: EMPTY
101157: LIST
101158: LIST
101159: PUSH
101160: EMPTY
101161: LIST
101162: LIST
101163: LIST
101164: PPUSH
101165: CALL_OW 72
101169: ST_TO_ADDR
// if barracks then
101170: LD_VAR 0 8
101174: IFFALSE 101322
// begin selected := 0 ;
101176: LD_ADDR_VAR 0 7
101180: PUSH
101181: LD_INT 0
101183: ST_TO_ADDR
// for j in barracks do
101184: LD_ADDR_VAR 0 3
101188: PUSH
101189: LD_VAR 0 8
101193: PUSH
101194: FOR_IN
101195: IFFALSE 101226
// begin if UnitsInside ( j ) < 6 then
101197: LD_VAR 0 3
101201: PPUSH
101202: CALL_OW 313
101206: PUSH
101207: LD_INT 6
101209: LESS
101210: IFFALSE 101224
// begin selected := j ;
101212: LD_ADDR_VAR 0 7
101216: PUSH
101217: LD_VAR 0 3
101221: ST_TO_ADDR
// break ;
101222: GO 101226
// end ; end ;
101224: GO 101194
101226: POP
101227: POP
// if selected then
101228: LD_VAR 0 7
101232: IFFALSE 101322
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
101234: LD_ADDR_VAR 0 3
101238: PUSH
101239: LD_EXP 201
101243: PUSH
101244: LD_VAR 0 2
101248: ARRAY
101249: PPUSH
101250: LD_INT 25
101252: PUSH
101253: LD_INT 12
101255: PUSH
101256: EMPTY
101257: LIST
101258: LIST
101259: PPUSH
101260: CALL_OW 72
101264: PUSH
101265: FOR_IN
101266: IFFALSE 101320
// if not IsInUnit ( j ) and not HasTask ( j ) then
101268: LD_VAR 0 3
101272: PPUSH
101273: CALL_OW 310
101277: NOT
101278: PUSH
101279: LD_VAR 0 3
101283: PPUSH
101284: CALL_OW 314
101288: NOT
101289: AND
101290: IFFALSE 101318
// begin ComEnterUnit ( j , selected ) ;
101292: LD_VAR 0 3
101296: PPUSH
101297: LD_VAR 0 7
101301: PPUSH
101302: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
101306: LD_VAR 0 3
101310: PPUSH
101311: LD_INT 15
101313: PPUSH
101314: CALL_OW 183
// end ;
101318: GO 101265
101320: POP
101321: POP
// end ; end ; end ; end ; end ;
101322: GO 100715
101324: POP
101325: POP
// end ;
101326: LD_VAR 0 1
101330: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
101331: LD_INT 0
101333: PPUSH
101334: PPUSH
101335: PPUSH
101336: PPUSH
// if not mc_bases then
101337: LD_EXP 172
101341: NOT
101342: IFFALSE 101346
// exit ;
101344: GO 101524
// for i = 1 to mc_bases do
101346: LD_ADDR_VAR 0 2
101350: PUSH
101351: DOUBLE
101352: LD_INT 1
101354: DEC
101355: ST_TO_ADDR
101356: LD_EXP 172
101360: PUSH
101361: FOR_TO
101362: IFFALSE 101522
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
101364: LD_ADDR_VAR 0 4
101368: PUSH
101369: LD_EXP 172
101373: PUSH
101374: LD_VAR 0 2
101378: ARRAY
101379: PPUSH
101380: LD_INT 25
101382: PUSH
101383: LD_INT 9
101385: PUSH
101386: EMPTY
101387: LIST
101388: LIST
101389: PPUSH
101390: CALL_OW 72
101394: ST_TO_ADDR
// if not tmp then
101395: LD_VAR 0 4
101399: NOT
101400: IFFALSE 101404
// continue ;
101402: GO 101361
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
101404: LD_EXP 198
101408: PUSH
101409: LD_VAR 0 2
101413: ARRAY
101414: PPUSH
101415: LD_INT 29
101417: PPUSH
101418: CALL_OW 325
101422: NOT
101423: PUSH
101424: LD_EXP 198
101428: PUSH
101429: LD_VAR 0 2
101433: ARRAY
101434: PPUSH
101435: LD_INT 28
101437: PPUSH
101438: CALL_OW 325
101442: NOT
101443: AND
101444: IFFALSE 101448
// continue ;
101446: GO 101361
// for j in tmp do
101448: LD_ADDR_VAR 0 3
101452: PUSH
101453: LD_VAR 0 4
101457: PUSH
101458: FOR_IN
101459: IFFALSE 101518
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
101461: LD_VAR 0 3
101465: PUSH
101466: LD_EXP 175
101470: PUSH
101471: LD_VAR 0 2
101475: ARRAY
101476: PUSH
101477: LD_INT 1
101479: ARRAY
101480: IN
101481: NOT
101482: PUSH
101483: LD_VAR 0 3
101487: PUSH
101488: LD_EXP 175
101492: PUSH
101493: LD_VAR 0 2
101497: ARRAY
101498: PUSH
101499: LD_INT 2
101501: ARRAY
101502: IN
101503: NOT
101504: AND
101505: IFFALSE 101516
// ComSpaceTimeShoot ( j ) ;
101507: LD_VAR 0 3
101511: PPUSH
101512: CALL 20093 0 1
101516: GO 101458
101518: POP
101519: POP
// end ;
101520: GO 101361
101522: POP
101523: POP
// end ;
101524: LD_VAR 0 1
101528: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
101529: LD_INT 0
101531: PPUSH
101532: PPUSH
101533: PPUSH
101534: PPUSH
101535: PPUSH
101536: PPUSH
101537: PPUSH
101538: PPUSH
101539: PPUSH
// if not mc_bases then
101540: LD_EXP 172
101544: NOT
101545: IFFALSE 101549
// exit ;
101547: GO 102171
// for i = 1 to mc_bases do
101549: LD_ADDR_VAR 0 2
101553: PUSH
101554: DOUBLE
101555: LD_INT 1
101557: DEC
101558: ST_TO_ADDR
101559: LD_EXP 172
101563: PUSH
101564: FOR_TO
101565: IFFALSE 102169
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
101567: LD_EXP 207
101571: PUSH
101572: LD_VAR 0 2
101576: ARRAY
101577: NOT
101578: PUSH
101579: LD_INT 38
101581: PPUSH
101582: LD_EXP 198
101586: PUSH
101587: LD_VAR 0 2
101591: ARRAY
101592: PPUSH
101593: CALL_OW 321
101597: PUSH
101598: LD_INT 2
101600: NONEQUAL
101601: OR
101602: IFFALSE 101606
// continue ;
101604: GO 101564
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
101606: LD_ADDR_VAR 0 8
101610: PUSH
101611: LD_EXP 172
101615: PUSH
101616: LD_VAR 0 2
101620: ARRAY
101621: PPUSH
101622: LD_INT 30
101624: PUSH
101625: LD_INT 34
101627: PUSH
101628: EMPTY
101629: LIST
101630: LIST
101631: PPUSH
101632: CALL_OW 72
101636: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
101637: LD_ADDR_VAR 0 9
101641: PUSH
101642: LD_EXP 172
101646: PUSH
101647: LD_VAR 0 2
101651: ARRAY
101652: PPUSH
101653: LD_INT 25
101655: PUSH
101656: LD_INT 4
101658: PUSH
101659: EMPTY
101660: LIST
101661: LIST
101662: PPUSH
101663: CALL_OW 72
101667: PPUSH
101668: LD_INT 0
101670: PPUSH
101671: CALL 52990 0 2
101675: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
101676: LD_VAR 0 9
101680: NOT
101681: PUSH
101682: LD_VAR 0 8
101686: NOT
101687: OR
101688: PUSH
101689: LD_EXP 172
101693: PUSH
101694: LD_VAR 0 2
101698: ARRAY
101699: PPUSH
101700: LD_INT 124
101702: PPUSH
101703: CALL 52990 0 2
101707: OR
101708: IFFALSE 101712
// continue ;
101710: GO 101564
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
101712: LD_EXP 208
101716: PUSH
101717: LD_VAR 0 2
101721: ARRAY
101722: PUSH
101723: LD_EXP 207
101727: PUSH
101728: LD_VAR 0 2
101732: ARRAY
101733: LESS
101734: PUSH
101735: LD_EXP 208
101739: PUSH
101740: LD_VAR 0 2
101744: ARRAY
101745: PUSH
101746: LD_VAR 0 8
101750: LESS
101751: AND
101752: IFFALSE 102167
// begin tmp := sci [ 1 ] ;
101754: LD_ADDR_VAR 0 7
101758: PUSH
101759: LD_VAR 0 9
101763: PUSH
101764: LD_INT 1
101766: ARRAY
101767: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
101768: LD_VAR 0 7
101772: PPUSH
101773: LD_INT 124
101775: PPUSH
101776: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
101780: LD_ADDR_VAR 0 3
101784: PUSH
101785: DOUBLE
101786: LD_EXP 207
101790: PUSH
101791: LD_VAR 0 2
101795: ARRAY
101796: INC
101797: ST_TO_ADDR
101798: LD_EXP 207
101802: PUSH
101803: LD_VAR 0 2
101807: ARRAY
101808: PUSH
101809: FOR_DOWNTO
101810: IFFALSE 102153
// begin if IsInUnit ( tmp ) then
101812: LD_VAR 0 7
101816: PPUSH
101817: CALL_OW 310
101821: IFFALSE 101832
// ComExitBuilding ( tmp ) ;
101823: LD_VAR 0 7
101827: PPUSH
101828: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
101832: LD_INT 35
101834: PPUSH
101835: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
101839: LD_VAR 0 7
101843: PPUSH
101844: CALL_OW 310
101848: NOT
101849: PUSH
101850: LD_VAR 0 7
101854: PPUSH
101855: CALL_OW 314
101859: NOT
101860: AND
101861: IFFALSE 101832
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
101863: LD_ADDR_VAR 0 6
101867: PUSH
101868: LD_VAR 0 7
101872: PPUSH
101873: CALL_OW 250
101877: PUSH
101878: LD_VAR 0 7
101882: PPUSH
101883: CALL_OW 251
101887: PUSH
101888: EMPTY
101889: LIST
101890: LIST
101891: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
101892: LD_INT 35
101894: PPUSH
101895: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
101899: LD_ADDR_VAR 0 4
101903: PUSH
101904: LD_EXP 207
101908: PUSH
101909: LD_VAR 0 2
101913: ARRAY
101914: PUSH
101915: LD_VAR 0 3
101919: ARRAY
101920: PUSH
101921: LD_INT 1
101923: ARRAY
101924: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
101925: LD_ADDR_VAR 0 5
101929: PUSH
101930: LD_EXP 207
101934: PUSH
101935: LD_VAR 0 2
101939: ARRAY
101940: PUSH
101941: LD_VAR 0 3
101945: ARRAY
101946: PUSH
101947: LD_INT 2
101949: ARRAY
101950: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
101951: LD_VAR 0 7
101955: PPUSH
101956: LD_INT 10
101958: PPUSH
101959: CALL 26689 0 2
101963: PUSH
101964: LD_INT 4
101966: ARRAY
101967: IFFALSE 102005
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
101969: LD_VAR 0 7
101973: PPUSH
101974: LD_VAR 0 6
101978: PUSH
101979: LD_INT 1
101981: ARRAY
101982: PPUSH
101983: LD_VAR 0 6
101987: PUSH
101988: LD_INT 2
101990: ARRAY
101991: PPUSH
101992: CALL_OW 111
// wait ( 0 0$10 ) ;
101996: LD_INT 350
101998: PPUSH
101999: CALL_OW 67
// end else
102003: GO 102031
// begin ComMoveXY ( tmp , x , y ) ;
102005: LD_VAR 0 7
102009: PPUSH
102010: LD_VAR 0 4
102014: PPUSH
102015: LD_VAR 0 5
102019: PPUSH
102020: CALL_OW 111
// wait ( 0 0$3 ) ;
102024: LD_INT 105
102026: PPUSH
102027: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
102031: LD_VAR 0 7
102035: PPUSH
102036: LD_VAR 0 4
102040: PPUSH
102041: LD_VAR 0 5
102045: PPUSH
102046: CALL_OW 307
102050: IFFALSE 101892
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
102052: LD_VAR 0 7
102056: PPUSH
102057: LD_VAR 0 4
102061: PPUSH
102062: LD_VAR 0 5
102066: PPUSH
102067: LD_VAR 0 8
102071: PUSH
102072: LD_VAR 0 3
102076: ARRAY
102077: PPUSH
102078: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
102082: LD_INT 35
102084: PPUSH
102085: CALL_OW 67
// until not HasTask ( tmp ) ;
102089: LD_VAR 0 7
102093: PPUSH
102094: CALL_OW 314
102098: NOT
102099: IFFALSE 102082
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
102101: LD_ADDR_EXP 208
102105: PUSH
102106: LD_EXP 208
102110: PPUSH
102111: LD_VAR 0 2
102115: PUSH
102116: LD_EXP 208
102120: PUSH
102121: LD_VAR 0 2
102125: ARRAY
102126: PUSH
102127: LD_INT 1
102129: PLUS
102130: PUSH
102131: EMPTY
102132: LIST
102133: LIST
102134: PPUSH
102135: LD_VAR 0 8
102139: PUSH
102140: LD_VAR 0 3
102144: ARRAY
102145: PPUSH
102146: CALL 24096 0 3
102150: ST_TO_ADDR
// end ;
102151: GO 101809
102153: POP
102154: POP
// MC_Reset ( i , 124 ) ;
102155: LD_VAR 0 2
102159: PPUSH
102160: LD_INT 124
102162: PPUSH
102163: CALL 85610 0 2
// end ; end ;
102167: GO 101564
102169: POP
102170: POP
// end ;
102171: LD_VAR 0 1
102175: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
102176: LD_INT 0
102178: PPUSH
102179: PPUSH
102180: PPUSH
// if not mc_bases then
102181: LD_EXP 172
102185: NOT
102186: IFFALSE 102190
// exit ;
102188: GO 102796
// for i = 1 to mc_bases do
102190: LD_ADDR_VAR 0 2
102194: PUSH
102195: DOUBLE
102196: LD_INT 1
102198: DEC
102199: ST_TO_ADDR
102200: LD_EXP 172
102204: PUSH
102205: FOR_TO
102206: IFFALSE 102794
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
102208: LD_ADDR_VAR 0 3
102212: PUSH
102213: LD_EXP 172
102217: PUSH
102218: LD_VAR 0 2
102222: ARRAY
102223: PPUSH
102224: LD_INT 25
102226: PUSH
102227: LD_INT 4
102229: PUSH
102230: EMPTY
102231: LIST
102232: LIST
102233: PPUSH
102234: CALL_OW 72
102238: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
102239: LD_VAR 0 3
102243: NOT
102244: PUSH
102245: LD_EXP 209
102249: PUSH
102250: LD_VAR 0 2
102254: ARRAY
102255: NOT
102256: OR
102257: PUSH
102258: LD_EXP 172
102262: PUSH
102263: LD_VAR 0 2
102267: ARRAY
102268: PPUSH
102269: LD_INT 2
102271: PUSH
102272: LD_INT 30
102274: PUSH
102275: LD_INT 0
102277: PUSH
102278: EMPTY
102279: LIST
102280: LIST
102281: PUSH
102282: LD_INT 30
102284: PUSH
102285: LD_INT 1
102287: PUSH
102288: EMPTY
102289: LIST
102290: LIST
102291: PUSH
102292: EMPTY
102293: LIST
102294: LIST
102295: LIST
102296: PPUSH
102297: CALL_OW 72
102301: NOT
102302: OR
102303: IFFALSE 102353
// begin if mc_deposits_finder [ i ] then
102305: LD_EXP 210
102309: PUSH
102310: LD_VAR 0 2
102314: ARRAY
102315: IFFALSE 102351
// begin MC_Reset ( i , 125 ) ;
102317: LD_VAR 0 2
102321: PPUSH
102322: LD_INT 125
102324: PPUSH
102325: CALL 85610 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
102329: LD_ADDR_EXP 210
102333: PUSH
102334: LD_EXP 210
102338: PPUSH
102339: LD_VAR 0 2
102343: PPUSH
102344: EMPTY
102345: PPUSH
102346: CALL_OW 1
102350: ST_TO_ADDR
// end ; continue ;
102351: GO 102205
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
102353: LD_EXP 209
102357: PUSH
102358: LD_VAR 0 2
102362: ARRAY
102363: PUSH
102364: LD_INT 1
102366: ARRAY
102367: PUSH
102368: LD_INT 3
102370: ARRAY
102371: PUSH
102372: LD_INT 1
102374: EQUAL
102375: PUSH
102376: LD_INT 20
102378: PPUSH
102379: LD_EXP 198
102383: PUSH
102384: LD_VAR 0 2
102388: ARRAY
102389: PPUSH
102390: CALL_OW 321
102394: PUSH
102395: LD_INT 2
102397: NONEQUAL
102398: AND
102399: IFFALSE 102449
// begin if mc_deposits_finder [ i ] then
102401: LD_EXP 210
102405: PUSH
102406: LD_VAR 0 2
102410: ARRAY
102411: IFFALSE 102447
// begin MC_Reset ( i , 125 ) ;
102413: LD_VAR 0 2
102417: PPUSH
102418: LD_INT 125
102420: PPUSH
102421: CALL 85610 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
102425: LD_ADDR_EXP 210
102429: PUSH
102430: LD_EXP 210
102434: PPUSH
102435: LD_VAR 0 2
102439: PPUSH
102440: EMPTY
102441: PPUSH
102442: CALL_OW 1
102446: ST_TO_ADDR
// end ; continue ;
102447: GO 102205
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
102449: LD_EXP 209
102453: PUSH
102454: LD_VAR 0 2
102458: ARRAY
102459: PUSH
102460: LD_INT 1
102462: ARRAY
102463: PUSH
102464: LD_INT 1
102466: ARRAY
102467: PPUSH
102468: LD_EXP 209
102472: PUSH
102473: LD_VAR 0 2
102477: ARRAY
102478: PUSH
102479: LD_INT 1
102481: ARRAY
102482: PUSH
102483: LD_INT 2
102485: ARRAY
102486: PPUSH
102487: LD_EXP 198
102491: PUSH
102492: LD_VAR 0 2
102496: ARRAY
102497: PPUSH
102498: CALL_OW 440
102502: IFFALSE 102545
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
102504: LD_ADDR_EXP 209
102508: PUSH
102509: LD_EXP 209
102513: PPUSH
102514: LD_VAR 0 2
102518: PPUSH
102519: LD_EXP 209
102523: PUSH
102524: LD_VAR 0 2
102528: ARRAY
102529: PPUSH
102530: LD_INT 1
102532: PPUSH
102533: CALL_OW 3
102537: PPUSH
102538: CALL_OW 1
102542: ST_TO_ADDR
102543: GO 102792
// begin if not mc_deposits_finder [ i ] then
102545: LD_EXP 210
102549: PUSH
102550: LD_VAR 0 2
102554: ARRAY
102555: NOT
102556: IFFALSE 102608
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
102558: LD_ADDR_EXP 210
102562: PUSH
102563: LD_EXP 210
102567: PPUSH
102568: LD_VAR 0 2
102572: PPUSH
102573: LD_VAR 0 3
102577: PUSH
102578: LD_INT 1
102580: ARRAY
102581: PUSH
102582: EMPTY
102583: LIST
102584: PPUSH
102585: CALL_OW 1
102589: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
102590: LD_VAR 0 3
102594: PUSH
102595: LD_INT 1
102597: ARRAY
102598: PPUSH
102599: LD_INT 125
102601: PPUSH
102602: CALL_OW 109
// end else
102606: GO 102792
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
102608: LD_EXP 210
102612: PUSH
102613: LD_VAR 0 2
102617: ARRAY
102618: PUSH
102619: LD_INT 1
102621: ARRAY
102622: PPUSH
102623: CALL_OW 310
102627: IFFALSE 102650
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
102629: LD_EXP 210
102633: PUSH
102634: LD_VAR 0 2
102638: ARRAY
102639: PUSH
102640: LD_INT 1
102642: ARRAY
102643: PPUSH
102644: CALL_OW 122
102648: GO 102792
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
102650: LD_EXP 210
102654: PUSH
102655: LD_VAR 0 2
102659: ARRAY
102660: PUSH
102661: LD_INT 1
102663: ARRAY
102664: PPUSH
102665: CALL_OW 314
102669: NOT
102670: PUSH
102671: LD_EXP 210
102675: PUSH
102676: LD_VAR 0 2
102680: ARRAY
102681: PUSH
102682: LD_INT 1
102684: ARRAY
102685: PPUSH
102686: LD_EXP 209
102690: PUSH
102691: LD_VAR 0 2
102695: ARRAY
102696: PUSH
102697: LD_INT 1
102699: ARRAY
102700: PUSH
102701: LD_INT 1
102703: ARRAY
102704: PPUSH
102705: LD_EXP 209
102709: PUSH
102710: LD_VAR 0 2
102714: ARRAY
102715: PUSH
102716: LD_INT 1
102718: ARRAY
102719: PUSH
102720: LD_INT 2
102722: ARRAY
102723: PPUSH
102724: CALL_OW 297
102728: PUSH
102729: LD_INT 6
102731: GREATER
102732: AND
102733: IFFALSE 102792
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
102735: LD_EXP 210
102739: PUSH
102740: LD_VAR 0 2
102744: ARRAY
102745: PUSH
102746: LD_INT 1
102748: ARRAY
102749: PPUSH
102750: LD_EXP 209
102754: PUSH
102755: LD_VAR 0 2
102759: ARRAY
102760: PUSH
102761: LD_INT 1
102763: ARRAY
102764: PUSH
102765: LD_INT 1
102767: ARRAY
102768: PPUSH
102769: LD_EXP 209
102773: PUSH
102774: LD_VAR 0 2
102778: ARRAY
102779: PUSH
102780: LD_INT 1
102782: ARRAY
102783: PUSH
102784: LD_INT 2
102786: ARRAY
102787: PPUSH
102788: CALL_OW 111
// end ; end ; end ;
102792: GO 102205
102794: POP
102795: POP
// end ;
102796: LD_VAR 0 1
102800: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
102801: LD_INT 0
102803: PPUSH
102804: PPUSH
102805: PPUSH
102806: PPUSH
102807: PPUSH
102808: PPUSH
102809: PPUSH
102810: PPUSH
102811: PPUSH
102812: PPUSH
102813: PPUSH
// if not mc_bases then
102814: LD_EXP 172
102818: NOT
102819: IFFALSE 102823
// exit ;
102821: GO 103763
// for i = 1 to mc_bases do
102823: LD_ADDR_VAR 0 2
102827: PUSH
102828: DOUBLE
102829: LD_INT 1
102831: DEC
102832: ST_TO_ADDR
102833: LD_EXP 172
102837: PUSH
102838: FOR_TO
102839: IFFALSE 103761
// begin if not mc_bases [ i ] or mc_scan [ i ] then
102841: LD_EXP 172
102845: PUSH
102846: LD_VAR 0 2
102850: ARRAY
102851: NOT
102852: PUSH
102853: LD_EXP 195
102857: PUSH
102858: LD_VAR 0 2
102862: ARRAY
102863: OR
102864: IFFALSE 102868
// continue ;
102866: GO 102838
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
102868: LD_ADDR_VAR 0 7
102872: PUSH
102873: LD_EXP 172
102877: PUSH
102878: LD_VAR 0 2
102882: ARRAY
102883: PUSH
102884: LD_INT 1
102886: ARRAY
102887: PPUSH
102888: CALL_OW 248
102892: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
102893: LD_VAR 0 7
102897: PUSH
102898: LD_INT 3
102900: EQUAL
102901: PUSH
102902: LD_EXP 191
102906: PUSH
102907: LD_VAR 0 2
102911: ARRAY
102912: PUSH
102913: LD_EXP 194
102917: PUSH
102918: LD_VAR 0 2
102922: ARRAY
102923: UNION
102924: PPUSH
102925: LD_INT 33
102927: PUSH
102928: LD_INT 2
102930: PUSH
102931: EMPTY
102932: LIST
102933: LIST
102934: PPUSH
102935: CALL_OW 72
102939: NOT
102940: OR
102941: IFFALSE 102945
// continue ;
102943: GO 102838
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
102945: LD_ADDR_VAR 0 9
102949: PUSH
102950: LD_EXP 172
102954: PUSH
102955: LD_VAR 0 2
102959: ARRAY
102960: PPUSH
102961: LD_INT 30
102963: PUSH
102964: LD_INT 36
102966: PUSH
102967: EMPTY
102968: LIST
102969: LIST
102970: PPUSH
102971: CALL_OW 72
102975: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
102976: LD_ADDR_VAR 0 10
102980: PUSH
102981: LD_EXP 191
102985: PUSH
102986: LD_VAR 0 2
102990: ARRAY
102991: PPUSH
102992: LD_INT 34
102994: PUSH
102995: LD_INT 31
102997: PUSH
102998: EMPTY
102999: LIST
103000: LIST
103001: PPUSH
103002: CALL_OW 72
103006: ST_TO_ADDR
// if not cts and not mcts then
103007: LD_VAR 0 9
103011: NOT
103012: PUSH
103013: LD_VAR 0 10
103017: NOT
103018: AND
103019: IFFALSE 103023
// continue ;
103021: GO 102838
// x := cts ;
103023: LD_ADDR_VAR 0 11
103027: PUSH
103028: LD_VAR 0 9
103032: ST_TO_ADDR
// if not x then
103033: LD_VAR 0 11
103037: NOT
103038: IFFALSE 103050
// x := mcts ;
103040: LD_ADDR_VAR 0 11
103044: PUSH
103045: LD_VAR 0 10
103049: ST_TO_ADDR
// if not x then
103050: LD_VAR 0 11
103054: NOT
103055: IFFALSE 103059
// continue ;
103057: GO 102838
// if mc_remote_driver [ i ] then
103059: LD_EXP 212
103063: PUSH
103064: LD_VAR 0 2
103068: ARRAY
103069: IFFALSE 103456
// for j in mc_remote_driver [ i ] do
103071: LD_ADDR_VAR 0 3
103075: PUSH
103076: LD_EXP 212
103080: PUSH
103081: LD_VAR 0 2
103085: ARRAY
103086: PUSH
103087: FOR_IN
103088: IFFALSE 103454
// begin if GetClass ( j ) <> 3 then
103090: LD_VAR 0 3
103094: PPUSH
103095: CALL_OW 257
103099: PUSH
103100: LD_INT 3
103102: NONEQUAL
103103: IFFALSE 103156
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
103105: LD_ADDR_EXP 212
103109: PUSH
103110: LD_EXP 212
103114: PPUSH
103115: LD_VAR 0 2
103119: PPUSH
103120: LD_EXP 212
103124: PUSH
103125: LD_VAR 0 2
103129: ARRAY
103130: PUSH
103131: LD_VAR 0 3
103135: DIFF
103136: PPUSH
103137: CALL_OW 1
103141: ST_TO_ADDR
// SetTag ( j , 0 ) ;
103142: LD_VAR 0 3
103146: PPUSH
103147: LD_INT 0
103149: PPUSH
103150: CALL_OW 109
// continue ;
103154: GO 103087
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
103156: LD_EXP 191
103160: PUSH
103161: LD_VAR 0 2
103165: ARRAY
103166: PPUSH
103167: LD_INT 34
103169: PUSH
103170: LD_INT 31
103172: PUSH
103173: EMPTY
103174: LIST
103175: LIST
103176: PUSH
103177: LD_INT 58
103179: PUSH
103180: EMPTY
103181: LIST
103182: PUSH
103183: EMPTY
103184: LIST
103185: LIST
103186: PPUSH
103187: CALL_OW 72
103191: PUSH
103192: LD_VAR 0 3
103196: PPUSH
103197: CALL 53078 0 1
103201: NOT
103202: AND
103203: IFFALSE 103274
// begin if IsInUnit ( j ) then
103205: LD_VAR 0 3
103209: PPUSH
103210: CALL_OW 310
103214: IFFALSE 103225
// ComExitBuilding ( j ) ;
103216: LD_VAR 0 3
103220: PPUSH
103221: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
103225: LD_VAR 0 3
103229: PPUSH
103230: LD_EXP 191
103234: PUSH
103235: LD_VAR 0 2
103239: ARRAY
103240: PPUSH
103241: LD_INT 34
103243: PUSH
103244: LD_INT 31
103246: PUSH
103247: EMPTY
103248: LIST
103249: LIST
103250: PUSH
103251: LD_INT 58
103253: PUSH
103254: EMPTY
103255: LIST
103256: PUSH
103257: EMPTY
103258: LIST
103259: LIST
103260: PPUSH
103261: CALL_OW 72
103265: PUSH
103266: LD_INT 1
103268: ARRAY
103269: PPUSH
103270: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
103274: LD_VAR 0 3
103278: PPUSH
103279: CALL_OW 310
103283: NOT
103284: PUSH
103285: LD_VAR 0 3
103289: PPUSH
103290: CALL_OW 310
103294: PPUSH
103295: CALL_OW 266
103299: PUSH
103300: LD_INT 36
103302: NONEQUAL
103303: PUSH
103304: LD_VAR 0 3
103308: PPUSH
103309: CALL 53078 0 1
103313: NOT
103314: AND
103315: OR
103316: IFFALSE 103452
// begin if IsInUnit ( j ) then
103318: LD_VAR 0 3
103322: PPUSH
103323: CALL_OW 310
103327: IFFALSE 103338
// ComExitBuilding ( j ) ;
103329: LD_VAR 0 3
103333: PPUSH
103334: CALL_OW 122
// ct := 0 ;
103338: LD_ADDR_VAR 0 8
103342: PUSH
103343: LD_INT 0
103345: ST_TO_ADDR
// for k in x do
103346: LD_ADDR_VAR 0 4
103350: PUSH
103351: LD_VAR 0 11
103355: PUSH
103356: FOR_IN
103357: IFFALSE 103430
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
103359: LD_VAR 0 4
103363: PPUSH
103364: CALL_OW 264
103368: PUSH
103369: LD_INT 31
103371: EQUAL
103372: PUSH
103373: LD_VAR 0 4
103377: PPUSH
103378: CALL_OW 311
103382: NOT
103383: AND
103384: PUSH
103385: LD_VAR 0 4
103389: PPUSH
103390: CALL_OW 266
103394: PUSH
103395: LD_INT 36
103397: EQUAL
103398: PUSH
103399: LD_VAR 0 4
103403: PPUSH
103404: CALL_OW 313
103408: PUSH
103409: LD_INT 3
103411: LESS
103412: AND
103413: OR
103414: IFFALSE 103428
// begin ct := k ;
103416: LD_ADDR_VAR 0 8
103420: PUSH
103421: LD_VAR 0 4
103425: ST_TO_ADDR
// break ;
103426: GO 103430
// end ;
103428: GO 103356
103430: POP
103431: POP
// if ct then
103432: LD_VAR 0 8
103436: IFFALSE 103452
// ComEnterUnit ( j , ct ) ;
103438: LD_VAR 0 3
103442: PPUSH
103443: LD_VAR 0 8
103447: PPUSH
103448: CALL_OW 120
// end ; end ;
103452: GO 103087
103454: POP
103455: POP
// places := 0 ;
103456: LD_ADDR_VAR 0 5
103460: PUSH
103461: LD_INT 0
103463: ST_TO_ADDR
// for j = 1 to x do
103464: LD_ADDR_VAR 0 3
103468: PUSH
103469: DOUBLE
103470: LD_INT 1
103472: DEC
103473: ST_TO_ADDR
103474: LD_VAR 0 11
103478: PUSH
103479: FOR_TO
103480: IFFALSE 103556
// if GetWeapon ( x [ j ] ) = ar_control_tower then
103482: LD_VAR 0 11
103486: PUSH
103487: LD_VAR 0 3
103491: ARRAY
103492: PPUSH
103493: CALL_OW 264
103497: PUSH
103498: LD_INT 31
103500: EQUAL
103501: IFFALSE 103519
// places := places + 1 else
103503: LD_ADDR_VAR 0 5
103507: PUSH
103508: LD_VAR 0 5
103512: PUSH
103513: LD_INT 1
103515: PLUS
103516: ST_TO_ADDR
103517: GO 103554
// if GetBType ( x [ j ] ) = b_control_tower then
103519: LD_VAR 0 11
103523: PUSH
103524: LD_VAR 0 3
103528: ARRAY
103529: PPUSH
103530: CALL_OW 266
103534: PUSH
103535: LD_INT 36
103537: EQUAL
103538: IFFALSE 103554
// places := places + 3 ;
103540: LD_ADDR_VAR 0 5
103544: PUSH
103545: LD_VAR 0 5
103549: PUSH
103550: LD_INT 3
103552: PLUS
103553: ST_TO_ADDR
103554: GO 103479
103556: POP
103557: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
103558: LD_VAR 0 5
103562: PUSH
103563: LD_INT 0
103565: EQUAL
103566: PUSH
103567: LD_VAR 0 5
103571: PUSH
103572: LD_EXP 212
103576: PUSH
103577: LD_VAR 0 2
103581: ARRAY
103582: LESSEQUAL
103583: OR
103584: IFFALSE 103588
// continue ;
103586: GO 102838
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
103588: LD_ADDR_VAR 0 6
103592: PUSH
103593: LD_EXP 172
103597: PUSH
103598: LD_VAR 0 2
103602: ARRAY
103603: PPUSH
103604: LD_INT 25
103606: PUSH
103607: LD_INT 3
103609: PUSH
103610: EMPTY
103611: LIST
103612: LIST
103613: PPUSH
103614: CALL_OW 72
103618: PUSH
103619: LD_EXP 212
103623: PUSH
103624: LD_VAR 0 2
103628: ARRAY
103629: DIFF
103630: PPUSH
103631: LD_INT 3
103633: PPUSH
103634: CALL 53978 0 2
103638: ST_TO_ADDR
// for j in tmp do
103639: LD_ADDR_VAR 0 3
103643: PUSH
103644: LD_VAR 0 6
103648: PUSH
103649: FOR_IN
103650: IFFALSE 103685
// if GetTag ( j ) > 0 then
103652: LD_VAR 0 3
103656: PPUSH
103657: CALL_OW 110
103661: PUSH
103662: LD_INT 0
103664: GREATER
103665: IFFALSE 103683
// tmp := tmp diff j ;
103667: LD_ADDR_VAR 0 6
103671: PUSH
103672: LD_VAR 0 6
103676: PUSH
103677: LD_VAR 0 3
103681: DIFF
103682: ST_TO_ADDR
103683: GO 103649
103685: POP
103686: POP
// if not tmp then
103687: LD_VAR 0 6
103691: NOT
103692: IFFALSE 103696
// continue ;
103694: GO 102838
// if places then
103696: LD_VAR 0 5
103700: IFFALSE 103759
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
103702: LD_ADDR_EXP 212
103706: PUSH
103707: LD_EXP 212
103711: PPUSH
103712: LD_VAR 0 2
103716: PPUSH
103717: LD_EXP 212
103721: PUSH
103722: LD_VAR 0 2
103726: ARRAY
103727: PUSH
103728: LD_VAR 0 6
103732: PUSH
103733: LD_INT 1
103735: ARRAY
103736: UNION
103737: PPUSH
103738: CALL_OW 1
103742: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
103743: LD_VAR 0 6
103747: PUSH
103748: LD_INT 1
103750: ARRAY
103751: PPUSH
103752: LD_INT 126
103754: PPUSH
103755: CALL_OW 109
// end ; end ;
103759: GO 102838
103761: POP
103762: POP
// end ;
103763: LD_VAR 0 1
103767: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
103768: LD_INT 0
103770: PPUSH
103771: PPUSH
103772: PPUSH
103773: PPUSH
103774: PPUSH
103775: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
103776: LD_VAR 0 1
103780: NOT
103781: PUSH
103782: LD_VAR 0 2
103786: NOT
103787: OR
103788: PUSH
103789: LD_VAR 0 3
103793: NOT
103794: OR
103795: PUSH
103796: LD_VAR 0 4
103800: PUSH
103801: LD_INT 1
103803: PUSH
103804: LD_INT 2
103806: PUSH
103807: LD_INT 3
103809: PUSH
103810: LD_INT 4
103812: PUSH
103813: LD_INT 5
103815: PUSH
103816: LD_INT 8
103818: PUSH
103819: LD_INT 9
103821: PUSH
103822: LD_INT 15
103824: PUSH
103825: LD_INT 16
103827: PUSH
103828: EMPTY
103829: LIST
103830: LIST
103831: LIST
103832: LIST
103833: LIST
103834: LIST
103835: LIST
103836: LIST
103837: LIST
103838: IN
103839: NOT
103840: OR
103841: IFFALSE 103845
// exit ;
103843: GO 104745
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
103845: LD_ADDR_VAR 0 2
103849: PUSH
103850: LD_VAR 0 2
103854: PPUSH
103855: LD_INT 21
103857: PUSH
103858: LD_INT 3
103860: PUSH
103861: EMPTY
103862: LIST
103863: LIST
103864: PUSH
103865: LD_INT 24
103867: PUSH
103868: LD_INT 250
103870: PUSH
103871: EMPTY
103872: LIST
103873: LIST
103874: PUSH
103875: EMPTY
103876: LIST
103877: LIST
103878: PPUSH
103879: CALL_OW 72
103883: ST_TO_ADDR
// case class of 1 , 15 :
103884: LD_VAR 0 4
103888: PUSH
103889: LD_INT 1
103891: DOUBLE
103892: EQUAL
103893: IFTRUE 103903
103895: LD_INT 15
103897: DOUBLE
103898: EQUAL
103899: IFTRUE 103903
103901: GO 103988
103903: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
103904: LD_ADDR_VAR 0 8
103908: PUSH
103909: LD_VAR 0 2
103913: PPUSH
103914: LD_INT 2
103916: PUSH
103917: LD_INT 30
103919: PUSH
103920: LD_INT 32
103922: PUSH
103923: EMPTY
103924: LIST
103925: LIST
103926: PUSH
103927: LD_INT 30
103929: PUSH
103930: LD_INT 31
103932: PUSH
103933: EMPTY
103934: LIST
103935: LIST
103936: PUSH
103937: EMPTY
103938: LIST
103939: LIST
103940: LIST
103941: PPUSH
103942: CALL_OW 72
103946: PUSH
103947: LD_VAR 0 2
103951: PPUSH
103952: LD_INT 2
103954: PUSH
103955: LD_INT 30
103957: PUSH
103958: LD_INT 4
103960: PUSH
103961: EMPTY
103962: LIST
103963: LIST
103964: PUSH
103965: LD_INT 30
103967: PUSH
103968: LD_INT 5
103970: PUSH
103971: EMPTY
103972: LIST
103973: LIST
103974: PUSH
103975: EMPTY
103976: LIST
103977: LIST
103978: LIST
103979: PPUSH
103980: CALL_OW 72
103984: ADD
103985: ST_TO_ADDR
103986: GO 104234
103988: LD_INT 2
103990: DOUBLE
103991: EQUAL
103992: IFTRUE 104002
103994: LD_INT 16
103996: DOUBLE
103997: EQUAL
103998: IFTRUE 104002
104000: GO 104048
104002: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
104003: LD_ADDR_VAR 0 8
104007: PUSH
104008: LD_VAR 0 2
104012: PPUSH
104013: LD_INT 2
104015: PUSH
104016: LD_INT 30
104018: PUSH
104019: LD_INT 0
104021: PUSH
104022: EMPTY
104023: LIST
104024: LIST
104025: PUSH
104026: LD_INT 30
104028: PUSH
104029: LD_INT 1
104031: PUSH
104032: EMPTY
104033: LIST
104034: LIST
104035: PUSH
104036: EMPTY
104037: LIST
104038: LIST
104039: LIST
104040: PPUSH
104041: CALL_OW 72
104045: ST_TO_ADDR
104046: GO 104234
104048: LD_INT 3
104050: DOUBLE
104051: EQUAL
104052: IFTRUE 104056
104054: GO 104102
104056: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
104057: LD_ADDR_VAR 0 8
104061: PUSH
104062: LD_VAR 0 2
104066: PPUSH
104067: LD_INT 2
104069: PUSH
104070: LD_INT 30
104072: PUSH
104073: LD_INT 2
104075: PUSH
104076: EMPTY
104077: LIST
104078: LIST
104079: PUSH
104080: LD_INT 30
104082: PUSH
104083: LD_INT 3
104085: PUSH
104086: EMPTY
104087: LIST
104088: LIST
104089: PUSH
104090: EMPTY
104091: LIST
104092: LIST
104093: LIST
104094: PPUSH
104095: CALL_OW 72
104099: ST_TO_ADDR
104100: GO 104234
104102: LD_INT 4
104104: DOUBLE
104105: EQUAL
104106: IFTRUE 104110
104108: GO 104167
104110: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
104111: LD_ADDR_VAR 0 8
104115: PUSH
104116: LD_VAR 0 2
104120: PPUSH
104121: LD_INT 2
104123: PUSH
104124: LD_INT 30
104126: PUSH
104127: LD_INT 6
104129: PUSH
104130: EMPTY
104131: LIST
104132: LIST
104133: PUSH
104134: LD_INT 30
104136: PUSH
104137: LD_INT 7
104139: PUSH
104140: EMPTY
104141: LIST
104142: LIST
104143: PUSH
104144: LD_INT 30
104146: PUSH
104147: LD_INT 8
104149: PUSH
104150: EMPTY
104151: LIST
104152: LIST
104153: PUSH
104154: EMPTY
104155: LIST
104156: LIST
104157: LIST
104158: LIST
104159: PPUSH
104160: CALL_OW 72
104164: ST_TO_ADDR
104165: GO 104234
104167: LD_INT 5
104169: DOUBLE
104170: EQUAL
104171: IFTRUE 104187
104173: LD_INT 8
104175: DOUBLE
104176: EQUAL
104177: IFTRUE 104187
104179: LD_INT 9
104181: DOUBLE
104182: EQUAL
104183: IFTRUE 104187
104185: GO 104233
104187: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
104188: LD_ADDR_VAR 0 8
104192: PUSH
104193: LD_VAR 0 2
104197: PPUSH
104198: LD_INT 2
104200: PUSH
104201: LD_INT 30
104203: PUSH
104204: LD_INT 4
104206: PUSH
104207: EMPTY
104208: LIST
104209: LIST
104210: PUSH
104211: LD_INT 30
104213: PUSH
104214: LD_INT 5
104216: PUSH
104217: EMPTY
104218: LIST
104219: LIST
104220: PUSH
104221: EMPTY
104222: LIST
104223: LIST
104224: LIST
104225: PPUSH
104226: CALL_OW 72
104230: ST_TO_ADDR
104231: GO 104234
104233: POP
// if not tmp then
104234: LD_VAR 0 8
104238: NOT
104239: IFFALSE 104243
// exit ;
104241: GO 104745
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
104243: LD_VAR 0 4
104247: PUSH
104248: LD_INT 1
104250: PUSH
104251: LD_INT 15
104253: PUSH
104254: EMPTY
104255: LIST
104256: LIST
104257: IN
104258: PUSH
104259: LD_EXP 181
104263: PUSH
104264: LD_VAR 0 1
104268: ARRAY
104269: AND
104270: IFFALSE 104426
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
104272: LD_ADDR_VAR 0 9
104276: PUSH
104277: LD_EXP 181
104281: PUSH
104282: LD_VAR 0 1
104286: ARRAY
104287: PUSH
104288: LD_INT 1
104290: ARRAY
104291: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
104292: LD_VAR 0 9
104296: PUSH
104297: LD_EXP 182
104301: PUSH
104302: LD_VAR 0 1
104306: ARRAY
104307: IN
104308: NOT
104309: IFFALSE 104424
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
104311: LD_ADDR_EXP 182
104315: PUSH
104316: LD_EXP 182
104320: PPUSH
104321: LD_VAR 0 1
104325: PUSH
104326: LD_EXP 182
104330: PUSH
104331: LD_VAR 0 1
104335: ARRAY
104336: PUSH
104337: LD_INT 1
104339: PLUS
104340: PUSH
104341: EMPTY
104342: LIST
104343: LIST
104344: PPUSH
104345: LD_VAR 0 9
104349: PPUSH
104350: CALL 24096 0 3
104354: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
104355: LD_ADDR_EXP 181
104359: PUSH
104360: LD_EXP 181
104364: PPUSH
104365: LD_VAR 0 1
104369: PPUSH
104370: LD_EXP 181
104374: PUSH
104375: LD_VAR 0 1
104379: ARRAY
104380: PUSH
104381: LD_VAR 0 9
104385: DIFF
104386: PPUSH
104387: CALL_OW 1
104391: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
104392: LD_VAR 0 3
104396: PPUSH
104397: LD_EXP 182
104401: PUSH
104402: LD_VAR 0 1
104406: ARRAY
104407: PUSH
104408: LD_EXP 182
104412: PUSH
104413: LD_VAR 0 1
104417: ARRAY
104418: ARRAY
104419: PPUSH
104420: CALL_OW 120
// end ; exit ;
104424: GO 104745
// end ; if tmp > 1 then
104426: LD_VAR 0 8
104430: PUSH
104431: LD_INT 1
104433: GREATER
104434: IFFALSE 104538
// for i = 2 to tmp do
104436: LD_ADDR_VAR 0 6
104440: PUSH
104441: DOUBLE
104442: LD_INT 2
104444: DEC
104445: ST_TO_ADDR
104446: LD_VAR 0 8
104450: PUSH
104451: FOR_TO
104452: IFFALSE 104536
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
104454: LD_VAR 0 8
104458: PUSH
104459: LD_VAR 0 6
104463: ARRAY
104464: PPUSH
104465: CALL_OW 461
104469: PUSH
104470: LD_INT 6
104472: EQUAL
104473: IFFALSE 104534
// begin x := tmp [ i ] ;
104475: LD_ADDR_VAR 0 9
104479: PUSH
104480: LD_VAR 0 8
104484: PUSH
104485: LD_VAR 0 6
104489: ARRAY
104490: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
104491: LD_ADDR_VAR 0 8
104495: PUSH
104496: LD_VAR 0 8
104500: PPUSH
104501: LD_VAR 0 6
104505: PPUSH
104506: CALL_OW 3
104510: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
104511: LD_ADDR_VAR 0 8
104515: PUSH
104516: LD_VAR 0 8
104520: PPUSH
104521: LD_INT 1
104523: PPUSH
104524: LD_VAR 0 9
104528: PPUSH
104529: CALL_OW 2
104533: ST_TO_ADDR
// end ;
104534: GO 104451
104536: POP
104537: POP
// for i in tmp do
104538: LD_ADDR_VAR 0 6
104542: PUSH
104543: LD_VAR 0 8
104547: PUSH
104548: FOR_IN
104549: IFFALSE 104618
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
104551: LD_VAR 0 6
104555: PPUSH
104556: CALL_OW 313
104560: PUSH
104561: LD_INT 6
104563: LESS
104564: PUSH
104565: LD_VAR 0 6
104569: PPUSH
104570: CALL_OW 266
104574: PUSH
104575: LD_INT 31
104577: PUSH
104578: LD_INT 32
104580: PUSH
104581: EMPTY
104582: LIST
104583: LIST
104584: IN
104585: NOT
104586: AND
104587: PUSH
104588: LD_VAR 0 6
104592: PPUSH
104593: CALL_OW 313
104597: PUSH
104598: LD_INT 0
104600: EQUAL
104601: OR
104602: IFFALSE 104616
// begin j := i ;
104604: LD_ADDR_VAR 0 7
104608: PUSH
104609: LD_VAR 0 6
104613: ST_TO_ADDR
// break ;
104614: GO 104618
// end ; end ;
104616: GO 104548
104618: POP
104619: POP
// if j then
104620: LD_VAR 0 7
104624: IFFALSE 104642
// ComEnterUnit ( unit , j ) else
104626: LD_VAR 0 3
104630: PPUSH
104631: LD_VAR 0 7
104635: PPUSH
104636: CALL_OW 120
104640: GO 104745
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
104642: LD_ADDR_VAR 0 10
104646: PUSH
104647: LD_VAR 0 2
104651: PPUSH
104652: LD_INT 2
104654: PUSH
104655: LD_INT 30
104657: PUSH
104658: LD_INT 0
104660: PUSH
104661: EMPTY
104662: LIST
104663: LIST
104664: PUSH
104665: LD_INT 30
104667: PUSH
104668: LD_INT 1
104670: PUSH
104671: EMPTY
104672: LIST
104673: LIST
104674: PUSH
104675: EMPTY
104676: LIST
104677: LIST
104678: LIST
104679: PPUSH
104680: CALL_OW 72
104684: ST_TO_ADDR
// if depot then
104685: LD_VAR 0 10
104689: IFFALSE 104745
// begin depot := NearestUnitToUnit ( depot , unit ) ;
104691: LD_ADDR_VAR 0 10
104695: PUSH
104696: LD_VAR 0 10
104700: PPUSH
104701: LD_VAR 0 3
104705: PPUSH
104706: CALL_OW 74
104710: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
104711: LD_VAR 0 3
104715: PPUSH
104716: LD_VAR 0 10
104720: PPUSH
104721: CALL_OW 296
104725: PUSH
104726: LD_INT 10
104728: GREATER
104729: IFFALSE 104745
// ComStandNearbyBuilding ( unit , depot ) ;
104731: LD_VAR 0 3
104735: PPUSH
104736: LD_VAR 0 10
104740: PPUSH
104741: CALL 20710 0 2
// end ; end ; end ;
104745: LD_VAR 0 5
104749: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
104750: LD_INT 0
104752: PPUSH
104753: PPUSH
104754: PPUSH
104755: PPUSH
// if not mc_bases then
104756: LD_EXP 172
104760: NOT
104761: IFFALSE 104765
// exit ;
104763: GO 105004
// for i = 1 to mc_bases do
104765: LD_ADDR_VAR 0 2
104769: PUSH
104770: DOUBLE
104771: LD_INT 1
104773: DEC
104774: ST_TO_ADDR
104775: LD_EXP 172
104779: PUSH
104780: FOR_TO
104781: IFFALSE 105002
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
104783: LD_ADDR_VAR 0 4
104787: PUSH
104788: LD_EXP 172
104792: PUSH
104793: LD_VAR 0 2
104797: ARRAY
104798: PPUSH
104799: LD_INT 21
104801: PUSH
104802: LD_INT 1
104804: PUSH
104805: EMPTY
104806: LIST
104807: LIST
104808: PPUSH
104809: CALL_OW 72
104813: PUSH
104814: LD_EXP 201
104818: PUSH
104819: LD_VAR 0 2
104823: ARRAY
104824: UNION
104825: ST_TO_ADDR
// if not tmp then
104826: LD_VAR 0 4
104830: NOT
104831: IFFALSE 104835
// continue ;
104833: GO 104780
// for j in tmp do
104835: LD_ADDR_VAR 0 3
104839: PUSH
104840: LD_VAR 0 4
104844: PUSH
104845: FOR_IN
104846: IFFALSE 104998
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
104848: LD_VAR 0 3
104852: PPUSH
104853: CALL_OW 110
104857: NOT
104858: PUSH
104859: LD_VAR 0 3
104863: PPUSH
104864: CALL_OW 314
104868: NOT
104869: AND
104870: PUSH
104871: LD_VAR 0 3
104875: PPUSH
104876: CALL_OW 311
104880: NOT
104881: AND
104882: PUSH
104883: LD_VAR 0 3
104887: PPUSH
104888: CALL_OW 310
104892: NOT
104893: AND
104894: PUSH
104895: LD_VAR 0 3
104899: PUSH
104900: LD_EXP 175
104904: PUSH
104905: LD_VAR 0 2
104909: ARRAY
104910: PUSH
104911: LD_INT 1
104913: ARRAY
104914: IN
104915: NOT
104916: AND
104917: PUSH
104918: LD_VAR 0 3
104922: PUSH
104923: LD_EXP 175
104927: PUSH
104928: LD_VAR 0 2
104932: ARRAY
104933: PUSH
104934: LD_INT 2
104936: ARRAY
104937: IN
104938: NOT
104939: AND
104940: PUSH
104941: LD_VAR 0 3
104945: PUSH
104946: LD_EXP 184
104950: PUSH
104951: LD_VAR 0 2
104955: ARRAY
104956: IN
104957: NOT
104958: AND
104959: IFFALSE 104996
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
104961: LD_VAR 0 2
104965: PPUSH
104966: LD_EXP 172
104970: PUSH
104971: LD_VAR 0 2
104975: ARRAY
104976: PPUSH
104977: LD_VAR 0 3
104981: PPUSH
104982: LD_VAR 0 3
104986: PPUSH
104987: CALL_OW 257
104991: PPUSH
104992: CALL 103768 0 4
// end ;
104996: GO 104845
104998: POP
104999: POP
// end ;
105000: GO 104780
105002: POP
105003: POP
// end ;
105004: LD_VAR 0 1
105008: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
105009: LD_INT 0
105011: PPUSH
105012: PPUSH
105013: PPUSH
105014: PPUSH
105015: PPUSH
105016: PPUSH
// if not mc_bases [ base ] then
105017: LD_EXP 172
105021: PUSH
105022: LD_VAR 0 1
105026: ARRAY
105027: NOT
105028: IFFALSE 105032
// exit ;
105030: GO 105214
// tmp := [ ] ;
105032: LD_ADDR_VAR 0 6
105036: PUSH
105037: EMPTY
105038: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
105039: LD_ADDR_VAR 0 7
105043: PUSH
105044: LD_VAR 0 3
105048: PPUSH
105049: LD_INT 0
105051: PPUSH
105052: CALL_OW 517
105056: ST_TO_ADDR
// if not list then
105057: LD_VAR 0 7
105061: NOT
105062: IFFALSE 105066
// exit ;
105064: GO 105214
// for i = 1 to amount do
105066: LD_ADDR_VAR 0 5
105070: PUSH
105071: DOUBLE
105072: LD_INT 1
105074: DEC
105075: ST_TO_ADDR
105076: LD_VAR 0 2
105080: PUSH
105081: FOR_TO
105082: IFFALSE 105162
// begin x := rand ( 1 , list [ 1 ] ) ;
105084: LD_ADDR_VAR 0 8
105088: PUSH
105089: LD_INT 1
105091: PPUSH
105092: LD_VAR 0 7
105096: PUSH
105097: LD_INT 1
105099: ARRAY
105100: PPUSH
105101: CALL_OW 12
105105: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
105106: LD_ADDR_VAR 0 6
105110: PUSH
105111: LD_VAR 0 6
105115: PPUSH
105116: LD_VAR 0 5
105120: PPUSH
105121: LD_VAR 0 7
105125: PUSH
105126: LD_INT 1
105128: ARRAY
105129: PUSH
105130: LD_VAR 0 8
105134: ARRAY
105135: PUSH
105136: LD_VAR 0 7
105140: PUSH
105141: LD_INT 2
105143: ARRAY
105144: PUSH
105145: LD_VAR 0 8
105149: ARRAY
105150: PUSH
105151: EMPTY
105152: LIST
105153: LIST
105154: PPUSH
105155: CALL_OW 1
105159: ST_TO_ADDR
// end ;
105160: GO 105081
105162: POP
105163: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
105164: LD_ADDR_EXP 185
105168: PUSH
105169: LD_EXP 185
105173: PPUSH
105174: LD_VAR 0 1
105178: PPUSH
105179: LD_VAR 0 6
105183: PPUSH
105184: CALL_OW 1
105188: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
105189: LD_ADDR_EXP 187
105193: PUSH
105194: LD_EXP 187
105198: PPUSH
105199: LD_VAR 0 1
105203: PPUSH
105204: LD_VAR 0 3
105208: PPUSH
105209: CALL_OW 1
105213: ST_TO_ADDR
// end ;
105214: LD_VAR 0 4
105218: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
105219: LD_INT 0
105221: PPUSH
// if not mc_bases [ base ] then
105222: LD_EXP 172
105226: PUSH
105227: LD_VAR 0 1
105231: ARRAY
105232: NOT
105233: IFFALSE 105237
// exit ;
105235: GO 105262
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
105237: LD_ADDR_EXP 177
105241: PUSH
105242: LD_EXP 177
105246: PPUSH
105247: LD_VAR 0 1
105251: PPUSH
105252: LD_VAR 0 2
105256: PPUSH
105257: CALL_OW 1
105261: ST_TO_ADDR
// end ;
105262: LD_VAR 0 3
105266: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
105267: LD_INT 0
105269: PPUSH
// if not mc_bases [ base ] then
105270: LD_EXP 172
105274: PUSH
105275: LD_VAR 0 1
105279: ARRAY
105280: NOT
105281: IFFALSE 105285
// exit ;
105283: GO 105322
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
105285: LD_ADDR_EXP 177
105289: PUSH
105290: LD_EXP 177
105294: PPUSH
105295: LD_VAR 0 1
105299: PPUSH
105300: LD_EXP 177
105304: PUSH
105305: LD_VAR 0 1
105309: ARRAY
105310: PUSH
105311: LD_VAR 0 2
105315: UNION
105316: PPUSH
105317: CALL_OW 1
105321: ST_TO_ADDR
// end ;
105322: LD_VAR 0 3
105326: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
105327: LD_INT 0
105329: PPUSH
// if not mc_bases [ base ] then
105330: LD_EXP 172
105334: PUSH
105335: LD_VAR 0 1
105339: ARRAY
105340: NOT
105341: IFFALSE 105345
// exit ;
105343: GO 105370
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
105345: LD_ADDR_EXP 193
105349: PUSH
105350: LD_EXP 193
105354: PPUSH
105355: LD_VAR 0 1
105359: PPUSH
105360: LD_VAR 0 2
105364: PPUSH
105365: CALL_OW 1
105369: ST_TO_ADDR
// end ;
105370: LD_VAR 0 3
105374: RET
// export function MC_InsertProduceList ( base , components ) ; begin
105375: LD_INT 0
105377: PPUSH
// if not mc_bases [ base ] then
105378: LD_EXP 172
105382: PUSH
105383: LD_VAR 0 1
105387: ARRAY
105388: NOT
105389: IFFALSE 105393
// exit ;
105391: GO 105430
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
105393: LD_ADDR_EXP 193
105397: PUSH
105398: LD_EXP 193
105402: PPUSH
105403: LD_VAR 0 1
105407: PPUSH
105408: LD_EXP 193
105412: PUSH
105413: LD_VAR 0 1
105417: ARRAY
105418: PUSH
105419: LD_VAR 0 2
105423: ADD
105424: PPUSH
105425: CALL_OW 1
105429: ST_TO_ADDR
// end ;
105430: LD_VAR 0 3
105434: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
105435: LD_INT 0
105437: PPUSH
// if not mc_bases [ base ] then
105438: LD_EXP 172
105442: PUSH
105443: LD_VAR 0 1
105447: ARRAY
105448: NOT
105449: IFFALSE 105453
// exit ;
105451: GO 105507
// mc_defender := Replace ( mc_defender , base , deflist ) ;
105453: LD_ADDR_EXP 194
105457: PUSH
105458: LD_EXP 194
105462: PPUSH
105463: LD_VAR 0 1
105467: PPUSH
105468: LD_VAR 0 2
105472: PPUSH
105473: CALL_OW 1
105477: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
105478: LD_ADDR_EXP 183
105482: PUSH
105483: LD_EXP 183
105487: PPUSH
105488: LD_VAR 0 1
105492: PPUSH
105493: LD_VAR 0 2
105497: PUSH
105498: LD_INT 0
105500: PLUS
105501: PPUSH
105502: CALL_OW 1
105506: ST_TO_ADDR
// end ;
105507: LD_VAR 0 3
105511: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
105512: LD_INT 0
105514: PPUSH
// if not mc_bases [ base ] then
105515: LD_EXP 172
105519: PUSH
105520: LD_VAR 0 1
105524: ARRAY
105525: NOT
105526: IFFALSE 105530
// exit ;
105528: GO 105555
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
105530: LD_ADDR_EXP 183
105534: PUSH
105535: LD_EXP 183
105539: PPUSH
105540: LD_VAR 0 1
105544: PPUSH
105545: LD_VAR 0 2
105549: PPUSH
105550: CALL_OW 1
105554: ST_TO_ADDR
// end ;
105555: LD_VAR 0 3
105559: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
105560: LD_INT 0
105562: PPUSH
105563: PPUSH
105564: PPUSH
105565: PPUSH
// if not mc_bases [ base ] then
105566: LD_EXP 172
105570: PUSH
105571: LD_VAR 0 1
105575: ARRAY
105576: NOT
105577: IFFALSE 105581
// exit ;
105579: GO 105646
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
105581: LD_ADDR_EXP 192
105585: PUSH
105586: LD_EXP 192
105590: PPUSH
105591: LD_VAR 0 1
105595: PUSH
105596: LD_EXP 192
105600: PUSH
105601: LD_VAR 0 1
105605: ARRAY
105606: PUSH
105607: LD_INT 1
105609: PLUS
105610: PUSH
105611: EMPTY
105612: LIST
105613: LIST
105614: PPUSH
105615: LD_VAR 0 1
105619: PUSH
105620: LD_VAR 0 2
105624: PUSH
105625: LD_VAR 0 3
105629: PUSH
105630: LD_VAR 0 4
105634: PUSH
105635: EMPTY
105636: LIST
105637: LIST
105638: LIST
105639: LIST
105640: PPUSH
105641: CALL 24096 0 3
105645: ST_TO_ADDR
// end ;
105646: LD_VAR 0 5
105650: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
105651: LD_INT 0
105653: PPUSH
// if not mc_bases [ base ] then
105654: LD_EXP 172
105658: PUSH
105659: LD_VAR 0 1
105663: ARRAY
105664: NOT
105665: IFFALSE 105669
// exit ;
105667: GO 105694
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
105669: LD_ADDR_EXP 209
105673: PUSH
105674: LD_EXP 209
105678: PPUSH
105679: LD_VAR 0 1
105683: PPUSH
105684: LD_VAR 0 2
105688: PPUSH
105689: CALL_OW 1
105693: ST_TO_ADDR
// end ;
105694: LD_VAR 0 3
105698: RET
// export function MC_GetMinesField ( base ) ; begin
105699: LD_INT 0
105701: PPUSH
// result := mc_mines [ base ] ;
105702: LD_ADDR_VAR 0 2
105706: PUSH
105707: LD_EXP 185
105711: PUSH
105712: LD_VAR 0 1
105716: ARRAY
105717: ST_TO_ADDR
// end ;
105718: LD_VAR 0 2
105722: RET
// export function MC_GetProduceList ( base ) ; begin
105723: LD_INT 0
105725: PPUSH
// result := mc_produce [ base ] ;
105726: LD_ADDR_VAR 0 2
105730: PUSH
105731: LD_EXP 193
105735: PUSH
105736: LD_VAR 0 1
105740: ARRAY
105741: ST_TO_ADDR
// end ;
105742: LD_VAR 0 2
105746: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
105747: LD_INT 0
105749: PPUSH
105750: PPUSH
// if not mc_bases then
105751: LD_EXP 172
105755: NOT
105756: IFFALSE 105760
// exit ;
105758: GO 105825
// if mc_bases [ base ] then
105760: LD_EXP 172
105764: PUSH
105765: LD_VAR 0 1
105769: ARRAY
105770: IFFALSE 105825
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
105772: LD_ADDR_VAR 0 3
105776: PUSH
105777: LD_EXP 172
105781: PUSH
105782: LD_VAR 0 1
105786: ARRAY
105787: PPUSH
105788: LD_INT 30
105790: PUSH
105791: LD_VAR 0 2
105795: PUSH
105796: EMPTY
105797: LIST
105798: LIST
105799: PPUSH
105800: CALL_OW 72
105804: ST_TO_ADDR
// if result then
105805: LD_VAR 0 3
105809: IFFALSE 105825
// result := result [ 1 ] ;
105811: LD_ADDR_VAR 0 3
105815: PUSH
105816: LD_VAR 0 3
105820: PUSH
105821: LD_INT 1
105823: ARRAY
105824: ST_TO_ADDR
// end ; end ;
105825: LD_VAR 0 3
105829: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
105830: LD_INT 0
105832: PPUSH
105833: PPUSH
// if not mc_bases then
105834: LD_EXP 172
105838: NOT
105839: IFFALSE 105843
// exit ;
105841: GO 105888
// if mc_bases [ base ] then
105843: LD_EXP 172
105847: PUSH
105848: LD_VAR 0 1
105852: ARRAY
105853: IFFALSE 105888
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
105855: LD_ADDR_VAR 0 3
105859: PUSH
105860: LD_EXP 172
105864: PUSH
105865: LD_VAR 0 1
105869: ARRAY
105870: PPUSH
105871: LD_INT 30
105873: PUSH
105874: LD_VAR 0 2
105878: PUSH
105879: EMPTY
105880: LIST
105881: LIST
105882: PPUSH
105883: CALL_OW 72
105887: ST_TO_ADDR
// end ;
105888: LD_VAR 0 3
105892: RET
// export function MC_SetTame ( base , area ) ; begin
105893: LD_INT 0
105895: PPUSH
// if not mc_bases or not base then
105896: LD_EXP 172
105900: NOT
105901: PUSH
105902: LD_VAR 0 1
105906: NOT
105907: OR
105908: IFFALSE 105912
// exit ;
105910: GO 105937
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
105912: LD_ADDR_EXP 200
105916: PUSH
105917: LD_EXP 200
105921: PPUSH
105922: LD_VAR 0 1
105926: PPUSH
105927: LD_VAR 0 2
105931: PPUSH
105932: CALL_OW 1
105936: ST_TO_ADDR
// end ;
105937: LD_VAR 0 3
105941: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
105942: LD_INT 0
105944: PPUSH
105945: PPUSH
// if not mc_bases or not base then
105946: LD_EXP 172
105950: NOT
105951: PUSH
105952: LD_VAR 0 1
105956: NOT
105957: OR
105958: IFFALSE 105962
// exit ;
105960: GO 106064
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
105962: LD_ADDR_VAR 0 4
105966: PUSH
105967: LD_EXP 172
105971: PUSH
105972: LD_VAR 0 1
105976: ARRAY
105977: PPUSH
105978: LD_INT 30
105980: PUSH
105981: LD_VAR 0 2
105985: PUSH
105986: EMPTY
105987: LIST
105988: LIST
105989: PPUSH
105990: CALL_OW 72
105994: ST_TO_ADDR
// if not tmp then
105995: LD_VAR 0 4
105999: NOT
106000: IFFALSE 106004
// exit ;
106002: GO 106064
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
106004: LD_ADDR_EXP 204
106008: PUSH
106009: LD_EXP 204
106013: PPUSH
106014: LD_VAR 0 1
106018: PPUSH
106019: LD_EXP 204
106023: PUSH
106024: LD_VAR 0 1
106028: ARRAY
106029: PPUSH
106030: LD_EXP 204
106034: PUSH
106035: LD_VAR 0 1
106039: ARRAY
106040: PUSH
106041: LD_INT 1
106043: PLUS
106044: PPUSH
106045: LD_VAR 0 4
106049: PUSH
106050: LD_INT 1
106052: ARRAY
106053: PPUSH
106054: CALL_OW 2
106058: PPUSH
106059: CALL_OW 1
106063: ST_TO_ADDR
// end ;
106064: LD_VAR 0 3
106068: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
106069: LD_INT 0
106071: PPUSH
106072: PPUSH
// if not mc_bases or not base or not kinds then
106073: LD_EXP 172
106077: NOT
106078: PUSH
106079: LD_VAR 0 1
106083: NOT
106084: OR
106085: PUSH
106086: LD_VAR 0 2
106090: NOT
106091: OR
106092: IFFALSE 106096
// exit ;
106094: GO 106157
// for i in kinds do
106096: LD_ADDR_VAR 0 4
106100: PUSH
106101: LD_VAR 0 2
106105: PUSH
106106: FOR_IN
106107: IFFALSE 106155
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
106109: LD_ADDR_EXP 206
106113: PUSH
106114: LD_EXP 206
106118: PPUSH
106119: LD_VAR 0 1
106123: PUSH
106124: LD_EXP 206
106128: PUSH
106129: LD_VAR 0 1
106133: ARRAY
106134: PUSH
106135: LD_INT 1
106137: PLUS
106138: PUSH
106139: EMPTY
106140: LIST
106141: LIST
106142: PPUSH
106143: LD_VAR 0 4
106147: PPUSH
106148: CALL 24096 0 3
106152: ST_TO_ADDR
106153: GO 106106
106155: POP
106156: POP
// end ;
106157: LD_VAR 0 3
106161: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
106162: LD_INT 0
106164: PPUSH
// if not mc_bases or not base or not areas then
106165: LD_EXP 172
106169: NOT
106170: PUSH
106171: LD_VAR 0 1
106175: NOT
106176: OR
106177: PUSH
106178: LD_VAR 0 2
106182: NOT
106183: OR
106184: IFFALSE 106188
// exit ;
106186: GO 106213
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
106188: LD_ADDR_EXP 190
106192: PUSH
106193: LD_EXP 190
106197: PPUSH
106198: LD_VAR 0 1
106202: PPUSH
106203: LD_VAR 0 2
106207: PPUSH
106208: CALL_OW 1
106212: ST_TO_ADDR
// end ;
106213: LD_VAR 0 3
106217: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
106218: LD_INT 0
106220: PPUSH
// if not mc_bases or not base or not teleports_exit then
106221: LD_EXP 172
106225: NOT
106226: PUSH
106227: LD_VAR 0 1
106231: NOT
106232: OR
106233: PUSH
106234: LD_VAR 0 2
106238: NOT
106239: OR
106240: IFFALSE 106244
// exit ;
106242: GO 106269
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
106244: LD_ADDR_EXP 207
106248: PUSH
106249: LD_EXP 207
106253: PPUSH
106254: LD_VAR 0 1
106258: PPUSH
106259: LD_VAR 0 2
106263: PPUSH
106264: CALL_OW 1
106268: ST_TO_ADDR
// end ;
106269: LD_VAR 0 3
106273: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
106274: LD_INT 0
106276: PPUSH
106277: PPUSH
106278: PPUSH
// if not mc_bases or not base or not ext_list then
106279: LD_EXP 172
106283: NOT
106284: PUSH
106285: LD_VAR 0 1
106289: NOT
106290: OR
106291: PUSH
106292: LD_VAR 0 5
106296: NOT
106297: OR
106298: IFFALSE 106302
// exit ;
106300: GO 106475
// tmp := GetFacExtXYD ( x , y , d ) ;
106302: LD_ADDR_VAR 0 8
106306: PUSH
106307: LD_VAR 0 2
106311: PPUSH
106312: LD_VAR 0 3
106316: PPUSH
106317: LD_VAR 0 4
106321: PPUSH
106322: CALL 53108 0 3
106326: ST_TO_ADDR
// if not tmp then
106327: LD_VAR 0 8
106331: NOT
106332: IFFALSE 106336
// exit ;
106334: GO 106475
// for i in tmp do
106336: LD_ADDR_VAR 0 7
106340: PUSH
106341: LD_VAR 0 8
106345: PUSH
106346: FOR_IN
106347: IFFALSE 106473
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
106349: LD_ADDR_EXP 177
106353: PUSH
106354: LD_EXP 177
106358: PPUSH
106359: LD_VAR 0 1
106363: PPUSH
106364: LD_EXP 177
106368: PUSH
106369: LD_VAR 0 1
106373: ARRAY
106374: PPUSH
106375: LD_EXP 177
106379: PUSH
106380: LD_VAR 0 1
106384: ARRAY
106385: PUSH
106386: LD_INT 1
106388: PLUS
106389: PPUSH
106390: LD_VAR 0 5
106394: PUSH
106395: LD_INT 1
106397: ARRAY
106398: PUSH
106399: LD_VAR 0 7
106403: PUSH
106404: LD_INT 1
106406: ARRAY
106407: PUSH
106408: LD_VAR 0 7
106412: PUSH
106413: LD_INT 2
106415: ARRAY
106416: PUSH
106417: LD_VAR 0 7
106421: PUSH
106422: LD_INT 3
106424: ARRAY
106425: PUSH
106426: EMPTY
106427: LIST
106428: LIST
106429: LIST
106430: LIST
106431: PPUSH
106432: CALL_OW 2
106436: PPUSH
106437: CALL_OW 1
106441: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
106442: LD_ADDR_VAR 0 5
106446: PUSH
106447: LD_VAR 0 5
106451: PPUSH
106452: LD_INT 1
106454: PPUSH
106455: CALL_OW 3
106459: ST_TO_ADDR
// if not ext_list then
106460: LD_VAR 0 5
106464: NOT
106465: IFFALSE 106471
// exit ;
106467: POP
106468: POP
106469: GO 106475
// end ;
106471: GO 106346
106473: POP
106474: POP
// end ;
106475: LD_VAR 0 6
106479: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
106480: LD_INT 0
106482: PPUSH
// if not mc_bases or not base or not weapon_list then
106483: LD_EXP 172
106487: NOT
106488: PUSH
106489: LD_VAR 0 1
106493: NOT
106494: OR
106495: PUSH
106496: LD_VAR 0 2
106500: NOT
106501: OR
106502: IFFALSE 106506
// exit ;
106504: GO 106531
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
106506: LD_ADDR_EXP 211
106510: PUSH
106511: LD_EXP 211
106515: PPUSH
106516: LD_VAR 0 1
106520: PPUSH
106521: LD_VAR 0 2
106525: PPUSH
106526: CALL_OW 1
106530: ST_TO_ADDR
// end ;
106531: LD_VAR 0 3
106535: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
106536: LD_INT 0
106538: PPUSH
// if not mc_bases or not base or not tech_list then
106539: LD_EXP 172
106543: NOT
106544: PUSH
106545: LD_VAR 0 1
106549: NOT
106550: OR
106551: PUSH
106552: LD_VAR 0 2
106556: NOT
106557: OR
106558: IFFALSE 106562
// exit ;
106560: GO 106587
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
106562: LD_ADDR_EXP 199
106566: PUSH
106567: LD_EXP 199
106571: PPUSH
106572: LD_VAR 0 1
106576: PPUSH
106577: LD_VAR 0 2
106581: PPUSH
106582: CALL_OW 1
106586: ST_TO_ADDR
// end ;
106587: LD_VAR 0 3
106591: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
106592: LD_INT 0
106594: PPUSH
// if not mc_bases or not parking_area or not base then
106595: LD_EXP 172
106599: NOT
106600: PUSH
106601: LD_VAR 0 2
106605: NOT
106606: OR
106607: PUSH
106608: LD_VAR 0 1
106612: NOT
106613: OR
106614: IFFALSE 106618
// exit ;
106616: GO 106643
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
106618: LD_ADDR_EXP 196
106622: PUSH
106623: LD_EXP 196
106627: PPUSH
106628: LD_VAR 0 1
106632: PPUSH
106633: LD_VAR 0 2
106637: PPUSH
106638: CALL_OW 1
106642: ST_TO_ADDR
// end ;
106643: LD_VAR 0 3
106647: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
106648: LD_INT 0
106650: PPUSH
// if not mc_bases or not base or not scan_area then
106651: LD_EXP 172
106655: NOT
106656: PUSH
106657: LD_VAR 0 1
106661: NOT
106662: OR
106663: PUSH
106664: LD_VAR 0 2
106668: NOT
106669: OR
106670: IFFALSE 106674
// exit ;
106672: GO 106699
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
106674: LD_ADDR_EXP 197
106678: PUSH
106679: LD_EXP 197
106683: PPUSH
106684: LD_VAR 0 1
106688: PPUSH
106689: LD_VAR 0 2
106693: PPUSH
106694: CALL_OW 1
106698: ST_TO_ADDR
// end ;
106699: LD_VAR 0 3
106703: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
106704: LD_INT 0
106706: PPUSH
106707: PPUSH
// if not mc_bases or not base then
106708: LD_EXP 172
106712: NOT
106713: PUSH
106714: LD_VAR 0 1
106718: NOT
106719: OR
106720: IFFALSE 106724
// exit ;
106722: GO 106788
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
106724: LD_ADDR_VAR 0 3
106728: PUSH
106729: LD_INT 1
106731: PUSH
106732: LD_INT 2
106734: PUSH
106735: LD_INT 3
106737: PUSH
106738: LD_INT 4
106740: PUSH
106741: LD_INT 11
106743: PUSH
106744: EMPTY
106745: LIST
106746: LIST
106747: LIST
106748: LIST
106749: LIST
106750: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
106751: LD_ADDR_EXP 199
106755: PUSH
106756: LD_EXP 199
106760: PPUSH
106761: LD_VAR 0 1
106765: PPUSH
106766: LD_EXP 199
106770: PUSH
106771: LD_VAR 0 1
106775: ARRAY
106776: PUSH
106777: LD_VAR 0 3
106781: DIFF
106782: PPUSH
106783: CALL_OW 1
106787: ST_TO_ADDR
// end ;
106788: LD_VAR 0 2
106792: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
106793: LD_INT 0
106795: PPUSH
// result := mc_vehicles [ base ] ;
106796: LD_ADDR_VAR 0 3
106800: PUSH
106801: LD_EXP 191
106805: PUSH
106806: LD_VAR 0 1
106810: ARRAY
106811: ST_TO_ADDR
// if onlyCombat then
106812: LD_VAR 0 2
106816: IFFALSE 106994
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
106818: LD_ADDR_VAR 0 3
106822: PUSH
106823: LD_VAR 0 3
106827: PUSH
106828: LD_VAR 0 3
106832: PPUSH
106833: LD_INT 2
106835: PUSH
106836: LD_INT 34
106838: PUSH
106839: LD_INT 12
106841: PUSH
106842: EMPTY
106843: LIST
106844: LIST
106845: PUSH
106846: LD_INT 34
106848: PUSH
106849: LD_INT 51
106851: PUSH
106852: EMPTY
106853: LIST
106854: LIST
106855: PUSH
106856: LD_INT 34
106858: PUSH
106859: LD_EXP 155
106863: PUSH
106864: EMPTY
106865: LIST
106866: LIST
106867: PUSH
106868: LD_INT 34
106870: PUSH
106871: LD_INT 32
106873: PUSH
106874: EMPTY
106875: LIST
106876: LIST
106877: PUSH
106878: LD_INT 34
106880: PUSH
106881: LD_INT 13
106883: PUSH
106884: EMPTY
106885: LIST
106886: LIST
106887: PUSH
106888: LD_INT 34
106890: PUSH
106891: LD_INT 52
106893: PUSH
106894: EMPTY
106895: LIST
106896: LIST
106897: PUSH
106898: LD_INT 34
106900: PUSH
106901: LD_EXP 160
106905: PUSH
106906: EMPTY
106907: LIST
106908: LIST
106909: PUSH
106910: LD_INT 34
106912: PUSH
106913: LD_INT 14
106915: PUSH
106916: EMPTY
106917: LIST
106918: LIST
106919: PUSH
106920: LD_INT 34
106922: PUSH
106923: LD_INT 53
106925: PUSH
106926: EMPTY
106927: LIST
106928: LIST
106929: PUSH
106930: LD_INT 34
106932: PUSH
106933: LD_EXP 154
106937: PUSH
106938: EMPTY
106939: LIST
106940: LIST
106941: PUSH
106942: LD_INT 34
106944: PUSH
106945: LD_INT 31
106947: PUSH
106948: EMPTY
106949: LIST
106950: LIST
106951: PUSH
106952: LD_INT 34
106954: PUSH
106955: LD_INT 48
106957: PUSH
106958: EMPTY
106959: LIST
106960: LIST
106961: PUSH
106962: LD_INT 34
106964: PUSH
106965: LD_INT 8
106967: PUSH
106968: EMPTY
106969: LIST
106970: LIST
106971: PUSH
106972: EMPTY
106973: LIST
106974: LIST
106975: LIST
106976: LIST
106977: LIST
106978: LIST
106979: LIST
106980: LIST
106981: LIST
106982: LIST
106983: LIST
106984: LIST
106985: LIST
106986: LIST
106987: PPUSH
106988: CALL_OW 72
106992: DIFF
106993: ST_TO_ADDR
// end ; end_of_file
106994: LD_VAR 0 3
106998: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
106999: LD_INT 0
107001: PPUSH
107002: PPUSH
107003: PPUSH
// if not mc_bases or not skirmish then
107004: LD_EXP 172
107008: NOT
107009: PUSH
107010: LD_EXP 170
107014: NOT
107015: OR
107016: IFFALSE 107020
// exit ;
107018: GO 107185
// for i = 1 to mc_bases do
107020: LD_ADDR_VAR 0 4
107024: PUSH
107025: DOUBLE
107026: LD_INT 1
107028: DEC
107029: ST_TO_ADDR
107030: LD_EXP 172
107034: PUSH
107035: FOR_TO
107036: IFFALSE 107183
// begin if sci in mc_bases [ i ] then
107038: LD_VAR 0 2
107042: PUSH
107043: LD_EXP 172
107047: PUSH
107048: LD_VAR 0 4
107052: ARRAY
107053: IN
107054: IFFALSE 107181
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
107056: LD_ADDR_EXP 201
107060: PUSH
107061: LD_EXP 201
107065: PPUSH
107066: LD_VAR 0 4
107070: PUSH
107071: LD_EXP 201
107075: PUSH
107076: LD_VAR 0 4
107080: ARRAY
107081: PUSH
107082: LD_INT 1
107084: PLUS
107085: PUSH
107086: EMPTY
107087: LIST
107088: LIST
107089: PPUSH
107090: LD_VAR 0 1
107094: PPUSH
107095: CALL 24096 0 3
107099: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
107100: LD_ADDR_VAR 0 5
107104: PUSH
107105: LD_EXP 172
107109: PUSH
107110: LD_VAR 0 4
107114: ARRAY
107115: PPUSH
107116: LD_INT 2
107118: PUSH
107119: LD_INT 30
107121: PUSH
107122: LD_INT 0
107124: PUSH
107125: EMPTY
107126: LIST
107127: LIST
107128: PUSH
107129: LD_INT 30
107131: PUSH
107132: LD_INT 1
107134: PUSH
107135: EMPTY
107136: LIST
107137: LIST
107138: PUSH
107139: EMPTY
107140: LIST
107141: LIST
107142: LIST
107143: PPUSH
107144: CALL_OW 72
107148: PPUSH
107149: LD_VAR 0 1
107153: PPUSH
107154: CALL_OW 74
107158: ST_TO_ADDR
// if tmp then
107159: LD_VAR 0 5
107163: IFFALSE 107179
// ComStandNearbyBuilding ( ape , tmp ) ;
107165: LD_VAR 0 1
107169: PPUSH
107170: LD_VAR 0 5
107174: PPUSH
107175: CALL 20710 0 2
// break ;
107179: GO 107183
// end ; end ;
107181: GO 107035
107183: POP
107184: POP
// end ;
107185: LD_VAR 0 3
107189: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
107190: LD_INT 0
107192: PPUSH
107193: PPUSH
107194: PPUSH
// if not mc_bases or not skirmish then
107195: LD_EXP 172
107199: NOT
107200: PUSH
107201: LD_EXP 170
107205: NOT
107206: OR
107207: IFFALSE 107211
// exit ;
107209: GO 107300
// for i = 1 to mc_bases do
107211: LD_ADDR_VAR 0 4
107215: PUSH
107216: DOUBLE
107217: LD_INT 1
107219: DEC
107220: ST_TO_ADDR
107221: LD_EXP 172
107225: PUSH
107226: FOR_TO
107227: IFFALSE 107298
// begin if building in mc_busy_turret_list [ i ] then
107229: LD_VAR 0 1
107233: PUSH
107234: LD_EXP 182
107238: PUSH
107239: LD_VAR 0 4
107243: ARRAY
107244: IN
107245: IFFALSE 107296
// begin tmp := mc_busy_turret_list [ i ] diff building ;
107247: LD_ADDR_VAR 0 5
107251: PUSH
107252: LD_EXP 182
107256: PUSH
107257: LD_VAR 0 4
107261: ARRAY
107262: PUSH
107263: LD_VAR 0 1
107267: DIFF
107268: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
107269: LD_ADDR_EXP 182
107273: PUSH
107274: LD_EXP 182
107278: PPUSH
107279: LD_VAR 0 4
107283: PPUSH
107284: LD_VAR 0 5
107288: PPUSH
107289: CALL_OW 1
107293: ST_TO_ADDR
// break ;
107294: GO 107298
// end ; end ;
107296: GO 107226
107298: POP
107299: POP
// end ;
107300: LD_VAR 0 3
107304: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
107305: LD_INT 0
107307: PPUSH
107308: PPUSH
107309: PPUSH
// if not mc_bases or not skirmish then
107310: LD_EXP 172
107314: NOT
107315: PUSH
107316: LD_EXP 170
107320: NOT
107321: OR
107322: IFFALSE 107326
// exit ;
107324: GO 107525
// for i = 1 to mc_bases do
107326: LD_ADDR_VAR 0 5
107330: PUSH
107331: DOUBLE
107332: LD_INT 1
107334: DEC
107335: ST_TO_ADDR
107336: LD_EXP 172
107340: PUSH
107341: FOR_TO
107342: IFFALSE 107523
// if building in mc_bases [ i ] then
107344: LD_VAR 0 1
107348: PUSH
107349: LD_EXP 172
107353: PUSH
107354: LD_VAR 0 5
107358: ARRAY
107359: IN
107360: IFFALSE 107521
// begin tmp := mc_bases [ i ] diff building ;
107362: LD_ADDR_VAR 0 6
107366: PUSH
107367: LD_EXP 172
107371: PUSH
107372: LD_VAR 0 5
107376: ARRAY
107377: PUSH
107378: LD_VAR 0 1
107382: DIFF
107383: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
107384: LD_ADDR_EXP 172
107388: PUSH
107389: LD_EXP 172
107393: PPUSH
107394: LD_VAR 0 5
107398: PPUSH
107399: LD_VAR 0 6
107403: PPUSH
107404: CALL_OW 1
107408: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
107409: LD_VAR 0 1
107413: PUSH
107414: LD_EXP 180
107418: PUSH
107419: LD_VAR 0 5
107423: ARRAY
107424: IN
107425: IFFALSE 107464
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
107427: LD_ADDR_EXP 180
107431: PUSH
107432: LD_EXP 180
107436: PPUSH
107437: LD_VAR 0 5
107441: PPUSH
107442: LD_EXP 180
107446: PUSH
107447: LD_VAR 0 5
107451: ARRAY
107452: PUSH
107453: LD_VAR 0 1
107457: DIFF
107458: PPUSH
107459: CALL_OW 1
107463: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
107464: LD_VAR 0 1
107468: PUSH
107469: LD_EXP 181
107473: PUSH
107474: LD_VAR 0 5
107478: ARRAY
107479: IN
107480: IFFALSE 107519
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
107482: LD_ADDR_EXP 181
107486: PUSH
107487: LD_EXP 181
107491: PPUSH
107492: LD_VAR 0 5
107496: PPUSH
107497: LD_EXP 181
107501: PUSH
107502: LD_VAR 0 5
107506: ARRAY
107507: PUSH
107508: LD_VAR 0 1
107512: DIFF
107513: PPUSH
107514: CALL_OW 1
107518: ST_TO_ADDR
// break ;
107519: GO 107523
// end ;
107521: GO 107341
107523: POP
107524: POP
// end ;
107525: LD_VAR 0 4
107529: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
107530: LD_INT 0
107532: PPUSH
107533: PPUSH
107534: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
107535: LD_EXP 172
107539: NOT
107540: PUSH
107541: LD_EXP 170
107545: NOT
107546: OR
107547: PUSH
107548: LD_VAR 0 3
107552: PUSH
107553: LD_EXP 198
107557: IN
107558: NOT
107559: OR
107560: IFFALSE 107564
// exit ;
107562: GO 107687
// for i = 1 to mc_vehicles do
107564: LD_ADDR_VAR 0 6
107568: PUSH
107569: DOUBLE
107570: LD_INT 1
107572: DEC
107573: ST_TO_ADDR
107574: LD_EXP 191
107578: PUSH
107579: FOR_TO
107580: IFFALSE 107685
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
107582: LD_VAR 0 2
107586: PUSH
107587: LD_EXP 191
107591: PUSH
107592: LD_VAR 0 6
107596: ARRAY
107597: IN
107598: PUSH
107599: LD_VAR 0 1
107603: PUSH
107604: LD_EXP 191
107608: PUSH
107609: LD_VAR 0 6
107613: ARRAY
107614: IN
107615: OR
107616: IFFALSE 107683
// begin tmp := mc_vehicles [ i ] diff old ;
107618: LD_ADDR_VAR 0 7
107622: PUSH
107623: LD_EXP 191
107627: PUSH
107628: LD_VAR 0 6
107632: ARRAY
107633: PUSH
107634: LD_VAR 0 2
107638: DIFF
107639: ST_TO_ADDR
// tmp := tmp diff new ;
107640: LD_ADDR_VAR 0 7
107644: PUSH
107645: LD_VAR 0 7
107649: PUSH
107650: LD_VAR 0 1
107654: DIFF
107655: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
107656: LD_ADDR_EXP 191
107660: PUSH
107661: LD_EXP 191
107665: PPUSH
107666: LD_VAR 0 6
107670: PPUSH
107671: LD_VAR 0 7
107675: PPUSH
107676: CALL_OW 1
107680: ST_TO_ADDR
// break ;
107681: GO 107685
// end ;
107683: GO 107579
107685: POP
107686: POP
// end ;
107687: LD_VAR 0 5
107691: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
107692: LD_INT 0
107694: PPUSH
107695: PPUSH
107696: PPUSH
107697: PPUSH
// if not mc_bases or not skirmish then
107698: LD_EXP 172
107702: NOT
107703: PUSH
107704: LD_EXP 170
107708: NOT
107709: OR
107710: IFFALSE 107714
// exit ;
107712: GO 108097
// side := GetSide ( vehicle ) ;
107714: LD_ADDR_VAR 0 5
107718: PUSH
107719: LD_VAR 0 1
107723: PPUSH
107724: CALL_OW 255
107728: ST_TO_ADDR
// for i = 1 to mc_bases do
107729: LD_ADDR_VAR 0 4
107733: PUSH
107734: DOUBLE
107735: LD_INT 1
107737: DEC
107738: ST_TO_ADDR
107739: LD_EXP 172
107743: PUSH
107744: FOR_TO
107745: IFFALSE 108095
// begin if factory in mc_bases [ i ] then
107747: LD_VAR 0 2
107751: PUSH
107752: LD_EXP 172
107756: PUSH
107757: LD_VAR 0 4
107761: ARRAY
107762: IN
107763: IFFALSE 108093
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
107765: LD_EXP 194
107769: PUSH
107770: LD_VAR 0 4
107774: ARRAY
107775: PUSH
107776: LD_EXP 183
107780: PUSH
107781: LD_VAR 0 4
107785: ARRAY
107786: LESS
107787: PUSH
107788: LD_VAR 0 1
107792: PPUSH
107793: CALL_OW 264
107797: PUSH
107798: LD_INT 31
107800: PUSH
107801: LD_INT 32
107803: PUSH
107804: LD_INT 51
107806: PUSH
107807: LD_EXP 155
107811: PUSH
107812: LD_INT 12
107814: PUSH
107815: LD_INT 30
107817: PUSH
107818: LD_EXP 154
107822: PUSH
107823: LD_INT 11
107825: PUSH
107826: LD_INT 53
107828: PUSH
107829: LD_INT 14
107831: PUSH
107832: LD_EXP 158
107836: PUSH
107837: LD_INT 29
107839: PUSH
107840: LD_EXP 156
107844: PUSH
107845: LD_INT 13
107847: PUSH
107848: LD_INT 52
107850: PUSH
107851: LD_EXP 160
107855: PUSH
107856: LD_INT 48
107858: PUSH
107859: LD_INT 8
107861: PUSH
107862: EMPTY
107863: LIST
107864: LIST
107865: LIST
107866: LIST
107867: LIST
107868: LIST
107869: LIST
107870: LIST
107871: LIST
107872: LIST
107873: LIST
107874: LIST
107875: LIST
107876: LIST
107877: LIST
107878: LIST
107879: LIST
107880: LIST
107881: IN
107882: NOT
107883: AND
107884: IFFALSE 107932
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
107886: LD_ADDR_EXP 194
107890: PUSH
107891: LD_EXP 194
107895: PPUSH
107896: LD_VAR 0 4
107900: PUSH
107901: LD_EXP 194
107905: PUSH
107906: LD_VAR 0 4
107910: ARRAY
107911: PUSH
107912: LD_INT 1
107914: PLUS
107915: PUSH
107916: EMPTY
107917: LIST
107918: LIST
107919: PPUSH
107920: LD_VAR 0 1
107924: PPUSH
107925: CALL 24096 0 3
107929: ST_TO_ADDR
107930: GO 107976
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
107932: LD_ADDR_EXP 191
107936: PUSH
107937: LD_EXP 191
107941: PPUSH
107942: LD_VAR 0 4
107946: PUSH
107947: LD_EXP 191
107951: PUSH
107952: LD_VAR 0 4
107956: ARRAY
107957: PUSH
107958: LD_INT 1
107960: PLUS
107961: PUSH
107962: EMPTY
107963: LIST
107964: LIST
107965: PPUSH
107966: LD_VAR 0 1
107970: PPUSH
107971: CALL 24096 0 3
107975: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
107976: LD_VAR 0 1
107980: PPUSH
107981: CALL_OW 263
107985: PUSH
107986: LD_INT 2
107988: EQUAL
107989: IFFALSE 108009
// begin repeat wait ( 0 0$1 ) ;
107991: LD_INT 35
107993: PPUSH
107994: CALL_OW 67
// until IsControledBy ( vehicle ) ;
107998: LD_VAR 0 1
108002: PPUSH
108003: CALL_OW 312
108007: IFFALSE 107991
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
108009: LD_VAR 0 1
108013: PPUSH
108014: LD_EXP 196
108018: PUSH
108019: LD_VAR 0 4
108023: ARRAY
108024: PPUSH
108025: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
108029: LD_VAR 0 1
108033: PPUSH
108034: CALL_OW 263
108038: PUSH
108039: LD_INT 1
108041: NONEQUAL
108042: IFFALSE 108046
// break ;
108044: GO 108095
// repeat wait ( 0 0$1 ) ;
108046: LD_INT 35
108048: PPUSH
108049: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
108053: LD_VAR 0 1
108057: PPUSH
108058: LD_EXP 196
108062: PUSH
108063: LD_VAR 0 4
108067: ARRAY
108068: PPUSH
108069: CALL_OW 308
108073: IFFALSE 108046
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
108075: LD_VAR 0 1
108079: PPUSH
108080: CALL_OW 311
108084: PPUSH
108085: CALL_OW 121
// exit ;
108089: POP
108090: POP
108091: GO 108097
// end ; end ;
108093: GO 107744
108095: POP
108096: POP
// end ;
108097: LD_VAR 0 3
108101: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
108102: LD_INT 0
108104: PPUSH
108105: PPUSH
108106: PPUSH
108107: PPUSH
// if not mc_bases or not skirmish then
108108: LD_EXP 172
108112: NOT
108113: PUSH
108114: LD_EXP 170
108118: NOT
108119: OR
108120: IFFALSE 108124
// exit ;
108122: GO 108477
// repeat wait ( 0 0$1 ) ;
108124: LD_INT 35
108126: PPUSH
108127: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
108131: LD_VAR 0 2
108135: PPUSH
108136: LD_VAR 0 3
108140: PPUSH
108141: CALL_OW 284
108145: IFFALSE 108124
// if GetResourceTypeXY ( x , y ) = mat_artefact then
108147: LD_VAR 0 2
108151: PPUSH
108152: LD_VAR 0 3
108156: PPUSH
108157: CALL_OW 283
108161: PUSH
108162: LD_INT 4
108164: EQUAL
108165: IFFALSE 108169
// exit ;
108167: GO 108477
// for i = 1 to mc_bases do
108169: LD_ADDR_VAR 0 7
108173: PUSH
108174: DOUBLE
108175: LD_INT 1
108177: DEC
108178: ST_TO_ADDR
108179: LD_EXP 172
108183: PUSH
108184: FOR_TO
108185: IFFALSE 108475
// begin if mc_crates_area [ i ] then
108187: LD_EXP 190
108191: PUSH
108192: LD_VAR 0 7
108196: ARRAY
108197: IFFALSE 108308
// for j in mc_crates_area [ i ] do
108199: LD_ADDR_VAR 0 8
108203: PUSH
108204: LD_EXP 190
108208: PUSH
108209: LD_VAR 0 7
108213: ARRAY
108214: PUSH
108215: FOR_IN
108216: IFFALSE 108306
// if InArea ( x , y , j ) then
108218: LD_VAR 0 2
108222: PPUSH
108223: LD_VAR 0 3
108227: PPUSH
108228: LD_VAR 0 8
108232: PPUSH
108233: CALL_OW 309
108237: IFFALSE 108304
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
108239: LD_ADDR_EXP 188
108243: PUSH
108244: LD_EXP 188
108248: PPUSH
108249: LD_VAR 0 7
108253: PUSH
108254: LD_EXP 188
108258: PUSH
108259: LD_VAR 0 7
108263: ARRAY
108264: PUSH
108265: LD_INT 1
108267: PLUS
108268: PUSH
108269: EMPTY
108270: LIST
108271: LIST
108272: PPUSH
108273: LD_VAR 0 4
108277: PUSH
108278: LD_VAR 0 2
108282: PUSH
108283: LD_VAR 0 3
108287: PUSH
108288: EMPTY
108289: LIST
108290: LIST
108291: LIST
108292: PPUSH
108293: CALL 24096 0 3
108297: ST_TO_ADDR
// exit ;
108298: POP
108299: POP
108300: POP
108301: POP
108302: GO 108477
// end ;
108304: GO 108215
108306: POP
108307: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
108308: LD_ADDR_VAR 0 9
108312: PUSH
108313: LD_EXP 172
108317: PUSH
108318: LD_VAR 0 7
108322: ARRAY
108323: PPUSH
108324: LD_INT 2
108326: PUSH
108327: LD_INT 30
108329: PUSH
108330: LD_INT 0
108332: PUSH
108333: EMPTY
108334: LIST
108335: LIST
108336: PUSH
108337: LD_INT 30
108339: PUSH
108340: LD_INT 1
108342: PUSH
108343: EMPTY
108344: LIST
108345: LIST
108346: PUSH
108347: EMPTY
108348: LIST
108349: LIST
108350: LIST
108351: PPUSH
108352: CALL_OW 72
108356: ST_TO_ADDR
// if not depot then
108357: LD_VAR 0 9
108361: NOT
108362: IFFALSE 108366
// continue ;
108364: GO 108184
// for j in depot do
108366: LD_ADDR_VAR 0 8
108370: PUSH
108371: LD_VAR 0 9
108375: PUSH
108376: FOR_IN
108377: IFFALSE 108471
// if GetDistUnitXY ( j , x , y ) < 30 then
108379: LD_VAR 0 8
108383: PPUSH
108384: LD_VAR 0 2
108388: PPUSH
108389: LD_VAR 0 3
108393: PPUSH
108394: CALL_OW 297
108398: PUSH
108399: LD_INT 30
108401: LESS
108402: IFFALSE 108469
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
108404: LD_ADDR_EXP 188
108408: PUSH
108409: LD_EXP 188
108413: PPUSH
108414: LD_VAR 0 7
108418: PUSH
108419: LD_EXP 188
108423: PUSH
108424: LD_VAR 0 7
108428: ARRAY
108429: PUSH
108430: LD_INT 1
108432: PLUS
108433: PUSH
108434: EMPTY
108435: LIST
108436: LIST
108437: PPUSH
108438: LD_VAR 0 4
108442: PUSH
108443: LD_VAR 0 2
108447: PUSH
108448: LD_VAR 0 3
108452: PUSH
108453: EMPTY
108454: LIST
108455: LIST
108456: LIST
108457: PPUSH
108458: CALL 24096 0 3
108462: ST_TO_ADDR
// exit ;
108463: POP
108464: POP
108465: POP
108466: POP
108467: GO 108477
// end ;
108469: GO 108376
108471: POP
108472: POP
// end ;
108473: GO 108184
108475: POP
108476: POP
// end ;
108477: LD_VAR 0 6
108481: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
108482: LD_INT 0
108484: PPUSH
108485: PPUSH
108486: PPUSH
108487: PPUSH
// if not mc_bases or not skirmish then
108488: LD_EXP 172
108492: NOT
108493: PUSH
108494: LD_EXP 170
108498: NOT
108499: OR
108500: IFFALSE 108504
// exit ;
108502: GO 108781
// side := GetSide ( lab ) ;
108504: LD_ADDR_VAR 0 4
108508: PUSH
108509: LD_VAR 0 2
108513: PPUSH
108514: CALL_OW 255
108518: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
108519: LD_VAR 0 4
108523: PUSH
108524: LD_EXP 198
108528: IN
108529: NOT
108530: PUSH
108531: LD_EXP 199
108535: NOT
108536: OR
108537: PUSH
108538: LD_EXP 172
108542: NOT
108543: OR
108544: IFFALSE 108548
// exit ;
108546: GO 108781
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
108548: LD_ADDR_EXP 199
108552: PUSH
108553: LD_EXP 199
108557: PPUSH
108558: LD_VAR 0 4
108562: PPUSH
108563: LD_EXP 199
108567: PUSH
108568: LD_VAR 0 4
108572: ARRAY
108573: PUSH
108574: LD_VAR 0 1
108578: DIFF
108579: PPUSH
108580: CALL_OW 1
108584: ST_TO_ADDR
// for i = 1 to mc_bases do
108585: LD_ADDR_VAR 0 5
108589: PUSH
108590: DOUBLE
108591: LD_INT 1
108593: DEC
108594: ST_TO_ADDR
108595: LD_EXP 172
108599: PUSH
108600: FOR_TO
108601: IFFALSE 108779
// begin if lab in mc_bases [ i ] then
108603: LD_VAR 0 2
108607: PUSH
108608: LD_EXP 172
108612: PUSH
108613: LD_VAR 0 5
108617: ARRAY
108618: IN
108619: IFFALSE 108777
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
108621: LD_VAR 0 1
108625: PUSH
108626: LD_INT 11
108628: PUSH
108629: LD_INT 4
108631: PUSH
108632: LD_INT 3
108634: PUSH
108635: LD_INT 2
108637: PUSH
108638: EMPTY
108639: LIST
108640: LIST
108641: LIST
108642: LIST
108643: IN
108644: PUSH
108645: LD_EXP 202
108649: PUSH
108650: LD_VAR 0 5
108654: ARRAY
108655: AND
108656: IFFALSE 108777
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
108658: LD_ADDR_VAR 0 6
108662: PUSH
108663: LD_EXP 202
108667: PUSH
108668: LD_VAR 0 5
108672: ARRAY
108673: PUSH
108674: LD_INT 1
108676: ARRAY
108677: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
108678: LD_ADDR_EXP 202
108682: PUSH
108683: LD_EXP 202
108687: PPUSH
108688: LD_VAR 0 5
108692: PPUSH
108693: EMPTY
108694: PPUSH
108695: CALL_OW 1
108699: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
108700: LD_VAR 0 6
108704: PPUSH
108705: LD_INT 0
108707: PPUSH
108708: CALL_OW 109
// ComExitBuilding ( tmp ) ;
108712: LD_VAR 0 6
108716: PPUSH
108717: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
108721: LD_ADDR_EXP 201
108725: PUSH
108726: LD_EXP 201
108730: PPUSH
108731: LD_VAR 0 5
108735: PPUSH
108736: LD_EXP 201
108740: PUSH
108741: LD_VAR 0 5
108745: ARRAY
108746: PPUSH
108747: LD_INT 1
108749: PPUSH
108750: LD_VAR 0 6
108754: PPUSH
108755: CALL_OW 2
108759: PPUSH
108760: CALL_OW 1
108764: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
108765: LD_VAR 0 5
108769: PPUSH
108770: LD_INT 112
108772: PPUSH
108773: CALL 85610 0 2
// end ; end ; end ;
108777: GO 108600
108779: POP
108780: POP
// end ;
108781: LD_VAR 0 3
108785: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
108786: LD_INT 0
108788: PPUSH
108789: PPUSH
108790: PPUSH
108791: PPUSH
108792: PPUSH
108793: PPUSH
108794: PPUSH
108795: PPUSH
// if not mc_bases or not skirmish then
108796: LD_EXP 172
108800: NOT
108801: PUSH
108802: LD_EXP 170
108806: NOT
108807: OR
108808: IFFALSE 108812
// exit ;
108810: GO 110183
// for i = 1 to mc_bases do
108812: LD_ADDR_VAR 0 3
108816: PUSH
108817: DOUBLE
108818: LD_INT 1
108820: DEC
108821: ST_TO_ADDR
108822: LD_EXP 172
108826: PUSH
108827: FOR_TO
108828: IFFALSE 110181
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
108830: LD_VAR 0 1
108834: PUSH
108835: LD_EXP 172
108839: PUSH
108840: LD_VAR 0 3
108844: ARRAY
108845: IN
108846: PUSH
108847: LD_VAR 0 1
108851: PUSH
108852: LD_EXP 179
108856: PUSH
108857: LD_VAR 0 3
108861: ARRAY
108862: IN
108863: OR
108864: PUSH
108865: LD_VAR 0 1
108869: PUSH
108870: LD_EXP 194
108874: PUSH
108875: LD_VAR 0 3
108879: ARRAY
108880: IN
108881: OR
108882: PUSH
108883: LD_VAR 0 1
108887: PUSH
108888: LD_EXP 191
108892: PUSH
108893: LD_VAR 0 3
108897: ARRAY
108898: IN
108899: OR
108900: PUSH
108901: LD_VAR 0 1
108905: PUSH
108906: LD_EXP 201
108910: PUSH
108911: LD_VAR 0 3
108915: ARRAY
108916: IN
108917: OR
108918: PUSH
108919: LD_VAR 0 1
108923: PUSH
108924: LD_EXP 202
108928: PUSH
108929: LD_VAR 0 3
108933: ARRAY
108934: IN
108935: OR
108936: IFFALSE 110179
// begin if un in mc_ape [ i ] then
108938: LD_VAR 0 1
108942: PUSH
108943: LD_EXP 201
108947: PUSH
108948: LD_VAR 0 3
108952: ARRAY
108953: IN
108954: IFFALSE 108993
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
108956: LD_ADDR_EXP 201
108960: PUSH
108961: LD_EXP 201
108965: PPUSH
108966: LD_VAR 0 3
108970: PPUSH
108971: LD_EXP 201
108975: PUSH
108976: LD_VAR 0 3
108980: ARRAY
108981: PUSH
108982: LD_VAR 0 1
108986: DIFF
108987: PPUSH
108988: CALL_OW 1
108992: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
108993: LD_VAR 0 1
108997: PUSH
108998: LD_EXP 202
109002: PUSH
109003: LD_VAR 0 3
109007: ARRAY
109008: IN
109009: IFFALSE 109033
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
109011: LD_ADDR_EXP 202
109015: PUSH
109016: LD_EXP 202
109020: PPUSH
109021: LD_VAR 0 3
109025: PPUSH
109026: EMPTY
109027: PPUSH
109028: CALL_OW 1
109032: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
109033: LD_VAR 0 1
109037: PPUSH
109038: CALL_OW 247
109042: PUSH
109043: LD_INT 2
109045: EQUAL
109046: PUSH
109047: LD_VAR 0 1
109051: PPUSH
109052: CALL_OW 110
109056: PUSH
109057: LD_INT 20
109059: EQUAL
109060: PUSH
109061: LD_VAR 0 1
109065: PUSH
109066: LD_EXP 194
109070: PUSH
109071: LD_VAR 0 3
109075: ARRAY
109076: IN
109077: OR
109078: PUSH
109079: LD_VAR 0 1
109083: PPUSH
109084: CALL_OW 264
109088: PUSH
109089: LD_INT 12
109091: PUSH
109092: LD_INT 51
109094: PUSH
109095: LD_EXP 155
109099: PUSH
109100: LD_INT 32
109102: PUSH
109103: LD_INT 13
109105: PUSH
109106: LD_INT 52
109108: PUSH
109109: LD_INT 31
109111: PUSH
109112: EMPTY
109113: LIST
109114: LIST
109115: LIST
109116: LIST
109117: LIST
109118: LIST
109119: LIST
109120: IN
109121: OR
109122: AND
109123: IFFALSE 109431
// begin if un in mc_defender [ i ] then
109125: LD_VAR 0 1
109129: PUSH
109130: LD_EXP 194
109134: PUSH
109135: LD_VAR 0 3
109139: ARRAY
109140: IN
109141: IFFALSE 109180
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
109143: LD_ADDR_EXP 194
109147: PUSH
109148: LD_EXP 194
109152: PPUSH
109153: LD_VAR 0 3
109157: PPUSH
109158: LD_EXP 194
109162: PUSH
109163: LD_VAR 0 3
109167: ARRAY
109168: PUSH
109169: LD_VAR 0 1
109173: DIFF
109174: PPUSH
109175: CALL_OW 1
109179: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
109180: LD_ADDR_VAR 0 8
109184: PUSH
109185: LD_VAR 0 3
109189: PPUSH
109190: LD_INT 3
109192: PPUSH
109193: CALL 105830 0 2
109197: ST_TO_ADDR
// if fac then
109198: LD_VAR 0 8
109202: IFFALSE 109431
// begin for j in fac do
109204: LD_ADDR_VAR 0 4
109208: PUSH
109209: LD_VAR 0 8
109213: PUSH
109214: FOR_IN
109215: IFFALSE 109429
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
109217: LD_ADDR_VAR 0 9
109221: PUSH
109222: LD_VAR 0 8
109226: PPUSH
109227: LD_VAR 0 1
109231: PPUSH
109232: CALL_OW 265
109236: PPUSH
109237: LD_VAR 0 1
109241: PPUSH
109242: CALL_OW 262
109246: PPUSH
109247: LD_VAR 0 1
109251: PPUSH
109252: CALL_OW 263
109256: PPUSH
109257: LD_VAR 0 1
109261: PPUSH
109262: CALL_OW 264
109266: PPUSH
109267: CALL 21628 0 5
109271: ST_TO_ADDR
// if components then
109272: LD_VAR 0 9
109276: IFFALSE 109427
// begin if GetWeapon ( un ) = ar_control_tower then
109278: LD_VAR 0 1
109282: PPUSH
109283: CALL_OW 264
109287: PUSH
109288: LD_INT 31
109290: EQUAL
109291: IFFALSE 109408
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
109293: LD_VAR 0 1
109297: PPUSH
109298: CALL_OW 311
109302: PPUSH
109303: LD_INT 0
109305: PPUSH
109306: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
109310: LD_ADDR_EXP 212
109314: PUSH
109315: LD_EXP 212
109319: PPUSH
109320: LD_VAR 0 3
109324: PPUSH
109325: LD_EXP 212
109329: PUSH
109330: LD_VAR 0 3
109334: ARRAY
109335: PUSH
109336: LD_VAR 0 1
109340: PPUSH
109341: CALL_OW 311
109345: DIFF
109346: PPUSH
109347: CALL_OW 1
109351: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
109352: LD_ADDR_VAR 0 7
109356: PUSH
109357: LD_EXP 193
109361: PUSH
109362: LD_VAR 0 3
109366: ARRAY
109367: PPUSH
109368: LD_INT 1
109370: PPUSH
109371: LD_VAR 0 9
109375: PPUSH
109376: CALL_OW 2
109380: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
109381: LD_ADDR_EXP 193
109385: PUSH
109386: LD_EXP 193
109390: PPUSH
109391: LD_VAR 0 3
109395: PPUSH
109396: LD_VAR 0 7
109400: PPUSH
109401: CALL_OW 1
109405: ST_TO_ADDR
// end else
109406: GO 109425
// MC_InsertProduceList ( i , [ components ] ) ;
109408: LD_VAR 0 3
109412: PPUSH
109413: LD_VAR 0 9
109417: PUSH
109418: EMPTY
109419: LIST
109420: PPUSH
109421: CALL 105375 0 2
// break ;
109425: GO 109429
// end ; end ;
109427: GO 109214
109429: POP
109430: POP
// end ; end ; if GetType ( un ) = unit_building then
109431: LD_VAR 0 1
109435: PPUSH
109436: CALL_OW 247
109440: PUSH
109441: LD_INT 3
109443: EQUAL
109444: IFFALSE 109847
// begin btype := GetBType ( un ) ;
109446: LD_ADDR_VAR 0 5
109450: PUSH
109451: LD_VAR 0 1
109455: PPUSH
109456: CALL_OW 266
109460: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
109461: LD_VAR 0 5
109465: PUSH
109466: LD_INT 29
109468: PUSH
109469: LD_INT 30
109471: PUSH
109472: EMPTY
109473: LIST
109474: LIST
109475: IN
109476: IFFALSE 109549
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
109478: LD_VAR 0 1
109482: PPUSH
109483: CALL_OW 250
109487: PPUSH
109488: LD_VAR 0 1
109492: PPUSH
109493: CALL_OW 251
109497: PPUSH
109498: LD_VAR 0 1
109502: PPUSH
109503: CALL_OW 255
109507: PPUSH
109508: CALL_OW 440
109512: NOT
109513: IFFALSE 109549
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
109515: LD_VAR 0 1
109519: PPUSH
109520: CALL_OW 250
109524: PPUSH
109525: LD_VAR 0 1
109529: PPUSH
109530: CALL_OW 251
109534: PPUSH
109535: LD_VAR 0 1
109539: PPUSH
109540: CALL_OW 255
109544: PPUSH
109545: CALL_OW 441
// end ; if btype = b_warehouse then
109549: LD_VAR 0 5
109553: PUSH
109554: LD_INT 1
109556: EQUAL
109557: IFFALSE 109575
// begin btype := b_depot ;
109559: LD_ADDR_VAR 0 5
109563: PUSH
109564: LD_INT 0
109566: ST_TO_ADDR
// pos := 1 ;
109567: LD_ADDR_VAR 0 6
109571: PUSH
109572: LD_INT 1
109574: ST_TO_ADDR
// end ; if btype = b_factory then
109575: LD_VAR 0 5
109579: PUSH
109580: LD_INT 3
109582: EQUAL
109583: IFFALSE 109601
// begin btype := b_workshop ;
109585: LD_ADDR_VAR 0 5
109589: PUSH
109590: LD_INT 2
109592: ST_TO_ADDR
// pos := 1 ;
109593: LD_ADDR_VAR 0 6
109597: PUSH
109598: LD_INT 1
109600: ST_TO_ADDR
// end ; if btype = b_barracks then
109601: LD_VAR 0 5
109605: PUSH
109606: LD_INT 5
109608: EQUAL
109609: IFFALSE 109619
// btype := b_armoury ;
109611: LD_ADDR_VAR 0 5
109615: PUSH
109616: LD_INT 4
109618: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
109619: LD_VAR 0 5
109623: PUSH
109624: LD_INT 7
109626: PUSH
109627: LD_INT 8
109629: PUSH
109630: EMPTY
109631: LIST
109632: LIST
109633: IN
109634: IFFALSE 109644
// btype := b_lab ;
109636: LD_ADDR_VAR 0 5
109640: PUSH
109641: LD_INT 6
109643: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
109644: LD_ADDR_EXP 177
109648: PUSH
109649: LD_EXP 177
109653: PPUSH
109654: LD_VAR 0 3
109658: PUSH
109659: LD_EXP 177
109663: PUSH
109664: LD_VAR 0 3
109668: ARRAY
109669: PUSH
109670: LD_INT 1
109672: PLUS
109673: PUSH
109674: EMPTY
109675: LIST
109676: LIST
109677: PPUSH
109678: LD_VAR 0 5
109682: PUSH
109683: LD_VAR 0 1
109687: PPUSH
109688: CALL_OW 250
109692: PUSH
109693: LD_VAR 0 1
109697: PPUSH
109698: CALL_OW 251
109702: PUSH
109703: LD_VAR 0 1
109707: PPUSH
109708: CALL_OW 254
109712: PUSH
109713: EMPTY
109714: LIST
109715: LIST
109716: LIST
109717: LIST
109718: PPUSH
109719: CALL 24096 0 3
109723: ST_TO_ADDR
// if pos = 1 then
109724: LD_VAR 0 6
109728: PUSH
109729: LD_INT 1
109731: EQUAL
109732: IFFALSE 109847
// begin tmp := mc_build_list [ i ] ;
109734: LD_ADDR_VAR 0 7
109738: PUSH
109739: LD_EXP 177
109743: PUSH
109744: LD_VAR 0 3
109748: ARRAY
109749: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
109750: LD_VAR 0 7
109754: PPUSH
109755: LD_INT 2
109757: PUSH
109758: LD_INT 30
109760: PUSH
109761: LD_INT 0
109763: PUSH
109764: EMPTY
109765: LIST
109766: LIST
109767: PUSH
109768: LD_INT 30
109770: PUSH
109771: LD_INT 1
109773: PUSH
109774: EMPTY
109775: LIST
109776: LIST
109777: PUSH
109778: EMPTY
109779: LIST
109780: LIST
109781: LIST
109782: PPUSH
109783: CALL_OW 72
109787: IFFALSE 109797
// pos := 2 ;
109789: LD_ADDR_VAR 0 6
109793: PUSH
109794: LD_INT 2
109796: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
109797: LD_ADDR_VAR 0 7
109801: PUSH
109802: LD_VAR 0 7
109806: PPUSH
109807: LD_VAR 0 6
109811: PPUSH
109812: LD_VAR 0 7
109816: PPUSH
109817: CALL 24422 0 3
109821: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
109822: LD_ADDR_EXP 177
109826: PUSH
109827: LD_EXP 177
109831: PPUSH
109832: LD_VAR 0 3
109836: PPUSH
109837: LD_VAR 0 7
109841: PPUSH
109842: CALL_OW 1
109846: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
109847: LD_VAR 0 1
109851: PUSH
109852: LD_EXP 172
109856: PUSH
109857: LD_VAR 0 3
109861: ARRAY
109862: IN
109863: IFFALSE 109902
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
109865: LD_ADDR_EXP 172
109869: PUSH
109870: LD_EXP 172
109874: PPUSH
109875: LD_VAR 0 3
109879: PPUSH
109880: LD_EXP 172
109884: PUSH
109885: LD_VAR 0 3
109889: ARRAY
109890: PUSH
109891: LD_VAR 0 1
109895: DIFF
109896: PPUSH
109897: CALL_OW 1
109901: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
109902: LD_VAR 0 1
109906: PUSH
109907: LD_EXP 179
109911: PUSH
109912: LD_VAR 0 3
109916: ARRAY
109917: IN
109918: IFFALSE 109957
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
109920: LD_ADDR_EXP 179
109924: PUSH
109925: LD_EXP 179
109929: PPUSH
109930: LD_VAR 0 3
109934: PPUSH
109935: LD_EXP 179
109939: PUSH
109940: LD_VAR 0 3
109944: ARRAY
109945: PUSH
109946: LD_VAR 0 1
109950: DIFF
109951: PPUSH
109952: CALL_OW 1
109956: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
109957: LD_VAR 0 1
109961: PUSH
109962: LD_EXP 191
109966: PUSH
109967: LD_VAR 0 3
109971: ARRAY
109972: IN
109973: IFFALSE 110012
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
109975: LD_ADDR_EXP 191
109979: PUSH
109980: LD_EXP 191
109984: PPUSH
109985: LD_VAR 0 3
109989: PPUSH
109990: LD_EXP 191
109994: PUSH
109995: LD_VAR 0 3
109999: ARRAY
110000: PUSH
110001: LD_VAR 0 1
110005: DIFF
110006: PPUSH
110007: CALL_OW 1
110011: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
110012: LD_VAR 0 1
110016: PUSH
110017: LD_EXP 194
110021: PUSH
110022: LD_VAR 0 3
110026: ARRAY
110027: IN
110028: IFFALSE 110067
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
110030: LD_ADDR_EXP 194
110034: PUSH
110035: LD_EXP 194
110039: PPUSH
110040: LD_VAR 0 3
110044: PPUSH
110045: LD_EXP 194
110049: PUSH
110050: LD_VAR 0 3
110054: ARRAY
110055: PUSH
110056: LD_VAR 0 1
110060: DIFF
110061: PPUSH
110062: CALL_OW 1
110066: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
110067: LD_VAR 0 1
110071: PUSH
110072: LD_EXP 181
110076: PUSH
110077: LD_VAR 0 3
110081: ARRAY
110082: IN
110083: IFFALSE 110122
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
110085: LD_ADDR_EXP 181
110089: PUSH
110090: LD_EXP 181
110094: PPUSH
110095: LD_VAR 0 3
110099: PPUSH
110100: LD_EXP 181
110104: PUSH
110105: LD_VAR 0 3
110109: ARRAY
110110: PUSH
110111: LD_VAR 0 1
110115: DIFF
110116: PPUSH
110117: CALL_OW 1
110121: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
110122: LD_VAR 0 1
110126: PUSH
110127: LD_EXP 180
110131: PUSH
110132: LD_VAR 0 3
110136: ARRAY
110137: IN
110138: IFFALSE 110177
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
110140: LD_ADDR_EXP 180
110144: PUSH
110145: LD_EXP 180
110149: PPUSH
110150: LD_VAR 0 3
110154: PPUSH
110155: LD_EXP 180
110159: PUSH
110160: LD_VAR 0 3
110164: ARRAY
110165: PUSH
110166: LD_VAR 0 1
110170: DIFF
110171: PPUSH
110172: CALL_OW 1
110176: ST_TO_ADDR
// end ; break ;
110177: GO 110181
// end ;
110179: GO 108827
110181: POP
110182: POP
// end ;
110183: LD_VAR 0 2
110187: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
110188: LD_INT 0
110190: PPUSH
110191: PPUSH
110192: PPUSH
// if not mc_bases or not skirmish then
110193: LD_EXP 172
110197: NOT
110198: PUSH
110199: LD_EXP 170
110203: NOT
110204: OR
110205: IFFALSE 110209
// exit ;
110207: GO 110424
// for i = 1 to mc_bases do
110209: LD_ADDR_VAR 0 3
110213: PUSH
110214: DOUBLE
110215: LD_INT 1
110217: DEC
110218: ST_TO_ADDR
110219: LD_EXP 172
110223: PUSH
110224: FOR_TO
110225: IFFALSE 110422
// begin if building in mc_construct_list [ i ] then
110227: LD_VAR 0 1
110231: PUSH
110232: LD_EXP 179
110236: PUSH
110237: LD_VAR 0 3
110241: ARRAY
110242: IN
110243: IFFALSE 110420
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
110245: LD_ADDR_EXP 179
110249: PUSH
110250: LD_EXP 179
110254: PPUSH
110255: LD_VAR 0 3
110259: PPUSH
110260: LD_EXP 179
110264: PUSH
110265: LD_VAR 0 3
110269: ARRAY
110270: PUSH
110271: LD_VAR 0 1
110275: DIFF
110276: PPUSH
110277: CALL_OW 1
110281: ST_TO_ADDR
// if building in mc_lab [ i ] then
110282: LD_VAR 0 1
110286: PUSH
110287: LD_EXP 205
110291: PUSH
110292: LD_VAR 0 3
110296: ARRAY
110297: IN
110298: IFFALSE 110353
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
110300: LD_ADDR_EXP 206
110304: PUSH
110305: LD_EXP 206
110309: PPUSH
110310: LD_VAR 0 3
110314: PPUSH
110315: LD_EXP 206
110319: PUSH
110320: LD_VAR 0 3
110324: ARRAY
110325: PPUSH
110326: LD_INT 1
110328: PPUSH
110329: LD_EXP 206
110333: PUSH
110334: LD_VAR 0 3
110338: ARRAY
110339: PPUSH
110340: LD_INT 0
110342: PPUSH
110343: CALL 23514 0 4
110347: PPUSH
110348: CALL_OW 1
110352: ST_TO_ADDR
// if not building in mc_bases [ i ] then
110353: LD_VAR 0 1
110357: PUSH
110358: LD_EXP 172
110362: PUSH
110363: LD_VAR 0 3
110367: ARRAY
110368: IN
110369: NOT
110370: IFFALSE 110416
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
110372: LD_ADDR_EXP 172
110376: PUSH
110377: LD_EXP 172
110381: PPUSH
110382: LD_VAR 0 3
110386: PUSH
110387: LD_EXP 172
110391: PUSH
110392: LD_VAR 0 3
110396: ARRAY
110397: PUSH
110398: LD_INT 1
110400: PLUS
110401: PUSH
110402: EMPTY
110403: LIST
110404: LIST
110405: PPUSH
110406: LD_VAR 0 1
110410: PPUSH
110411: CALL 24096 0 3
110415: ST_TO_ADDR
// exit ;
110416: POP
110417: POP
110418: GO 110424
// end ; end ;
110420: GO 110224
110422: POP
110423: POP
// end ;
110424: LD_VAR 0 2
110428: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
110429: LD_INT 0
110431: PPUSH
110432: PPUSH
110433: PPUSH
110434: PPUSH
110435: PPUSH
110436: PPUSH
110437: PPUSH
// if not mc_bases or not skirmish then
110438: LD_EXP 172
110442: NOT
110443: PUSH
110444: LD_EXP 170
110448: NOT
110449: OR
110450: IFFALSE 110454
// exit ;
110452: GO 111115
// for i = 1 to mc_bases do
110454: LD_ADDR_VAR 0 3
110458: PUSH
110459: DOUBLE
110460: LD_INT 1
110462: DEC
110463: ST_TO_ADDR
110464: LD_EXP 172
110468: PUSH
110469: FOR_TO
110470: IFFALSE 111113
// begin if building in mc_construct_list [ i ] then
110472: LD_VAR 0 1
110476: PUSH
110477: LD_EXP 179
110481: PUSH
110482: LD_VAR 0 3
110486: ARRAY
110487: IN
110488: IFFALSE 111111
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
110490: LD_ADDR_EXP 179
110494: PUSH
110495: LD_EXP 179
110499: PPUSH
110500: LD_VAR 0 3
110504: PPUSH
110505: LD_EXP 179
110509: PUSH
110510: LD_VAR 0 3
110514: ARRAY
110515: PUSH
110516: LD_VAR 0 1
110520: DIFF
110521: PPUSH
110522: CALL_OW 1
110526: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
110527: LD_ADDR_EXP 172
110531: PUSH
110532: LD_EXP 172
110536: PPUSH
110537: LD_VAR 0 3
110541: PUSH
110542: LD_EXP 172
110546: PUSH
110547: LD_VAR 0 3
110551: ARRAY
110552: PUSH
110553: LD_INT 1
110555: PLUS
110556: PUSH
110557: EMPTY
110558: LIST
110559: LIST
110560: PPUSH
110561: LD_VAR 0 1
110565: PPUSH
110566: CALL 24096 0 3
110570: ST_TO_ADDR
// btype := GetBType ( building ) ;
110571: LD_ADDR_VAR 0 5
110575: PUSH
110576: LD_VAR 0 1
110580: PPUSH
110581: CALL_OW 266
110585: ST_TO_ADDR
// side := GetSide ( building ) ;
110586: LD_ADDR_VAR 0 8
110590: PUSH
110591: LD_VAR 0 1
110595: PPUSH
110596: CALL_OW 255
110600: ST_TO_ADDR
// if btype = b_lab then
110601: LD_VAR 0 5
110605: PUSH
110606: LD_INT 6
110608: EQUAL
110609: IFFALSE 110659
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
110611: LD_ADDR_EXP 205
110615: PUSH
110616: LD_EXP 205
110620: PPUSH
110621: LD_VAR 0 3
110625: PUSH
110626: LD_EXP 205
110630: PUSH
110631: LD_VAR 0 3
110635: ARRAY
110636: PUSH
110637: LD_INT 1
110639: PLUS
110640: PUSH
110641: EMPTY
110642: LIST
110643: LIST
110644: PPUSH
110645: LD_VAR 0 1
110649: PPUSH
110650: CALL 24096 0 3
110654: ST_TO_ADDR
// exit ;
110655: POP
110656: POP
110657: GO 111115
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
110659: LD_VAR 0 5
110663: PUSH
110664: LD_INT 0
110666: PUSH
110667: LD_INT 2
110669: PUSH
110670: LD_INT 4
110672: PUSH
110673: EMPTY
110674: LIST
110675: LIST
110676: LIST
110677: IN
110678: IFFALSE 110802
// begin if btype = b_armoury then
110680: LD_VAR 0 5
110684: PUSH
110685: LD_INT 4
110687: EQUAL
110688: IFFALSE 110698
// btype := b_barracks ;
110690: LD_ADDR_VAR 0 5
110694: PUSH
110695: LD_INT 5
110697: ST_TO_ADDR
// if btype = b_depot then
110698: LD_VAR 0 5
110702: PUSH
110703: LD_INT 0
110705: EQUAL
110706: IFFALSE 110716
// btype := b_warehouse ;
110708: LD_ADDR_VAR 0 5
110712: PUSH
110713: LD_INT 1
110715: ST_TO_ADDR
// if btype = b_workshop then
110716: LD_VAR 0 5
110720: PUSH
110721: LD_INT 2
110723: EQUAL
110724: IFFALSE 110734
// btype := b_factory ;
110726: LD_ADDR_VAR 0 5
110730: PUSH
110731: LD_INT 3
110733: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
110734: LD_VAR 0 5
110738: PPUSH
110739: LD_VAR 0 8
110743: PPUSH
110744: CALL_OW 323
110748: PUSH
110749: LD_INT 1
110751: EQUAL
110752: IFFALSE 110798
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
110754: LD_ADDR_EXP 204
110758: PUSH
110759: LD_EXP 204
110763: PPUSH
110764: LD_VAR 0 3
110768: PUSH
110769: LD_EXP 204
110773: PUSH
110774: LD_VAR 0 3
110778: ARRAY
110779: PUSH
110780: LD_INT 1
110782: PLUS
110783: PUSH
110784: EMPTY
110785: LIST
110786: LIST
110787: PPUSH
110788: LD_VAR 0 1
110792: PPUSH
110793: CALL 24096 0 3
110797: ST_TO_ADDR
// exit ;
110798: POP
110799: POP
110800: GO 111115
// end ; if btype in [ b_bunker , b_turret ] then
110802: LD_VAR 0 5
110806: PUSH
110807: LD_INT 32
110809: PUSH
110810: LD_INT 33
110812: PUSH
110813: EMPTY
110814: LIST
110815: LIST
110816: IN
110817: IFFALSE 111107
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
110819: LD_ADDR_EXP 180
110823: PUSH
110824: LD_EXP 180
110828: PPUSH
110829: LD_VAR 0 3
110833: PUSH
110834: LD_EXP 180
110838: PUSH
110839: LD_VAR 0 3
110843: ARRAY
110844: PUSH
110845: LD_INT 1
110847: PLUS
110848: PUSH
110849: EMPTY
110850: LIST
110851: LIST
110852: PPUSH
110853: LD_VAR 0 1
110857: PPUSH
110858: CALL 24096 0 3
110862: ST_TO_ADDR
// if btype = b_bunker then
110863: LD_VAR 0 5
110867: PUSH
110868: LD_INT 32
110870: EQUAL
110871: IFFALSE 111107
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
110873: LD_ADDR_EXP 181
110877: PUSH
110878: LD_EXP 181
110882: PPUSH
110883: LD_VAR 0 3
110887: PUSH
110888: LD_EXP 181
110892: PUSH
110893: LD_VAR 0 3
110897: ARRAY
110898: PUSH
110899: LD_INT 1
110901: PLUS
110902: PUSH
110903: EMPTY
110904: LIST
110905: LIST
110906: PPUSH
110907: LD_VAR 0 1
110911: PPUSH
110912: CALL 24096 0 3
110916: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
110917: LD_ADDR_VAR 0 6
110921: PUSH
110922: LD_EXP 172
110926: PUSH
110927: LD_VAR 0 3
110931: ARRAY
110932: PPUSH
110933: LD_INT 25
110935: PUSH
110936: LD_INT 1
110938: PUSH
110939: EMPTY
110940: LIST
110941: LIST
110942: PUSH
110943: LD_INT 3
110945: PUSH
110946: LD_INT 54
110948: PUSH
110949: EMPTY
110950: LIST
110951: PUSH
110952: EMPTY
110953: LIST
110954: LIST
110955: PUSH
110956: EMPTY
110957: LIST
110958: LIST
110959: PPUSH
110960: CALL_OW 72
110964: ST_TO_ADDR
// if tmp then
110965: LD_VAR 0 6
110969: IFFALSE 110975
// exit ;
110971: POP
110972: POP
110973: GO 111115
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
110975: LD_ADDR_VAR 0 6
110979: PUSH
110980: LD_EXP 172
110984: PUSH
110985: LD_VAR 0 3
110989: ARRAY
110990: PPUSH
110991: LD_INT 2
110993: PUSH
110994: LD_INT 30
110996: PUSH
110997: LD_INT 4
110999: PUSH
111000: EMPTY
111001: LIST
111002: LIST
111003: PUSH
111004: LD_INT 30
111006: PUSH
111007: LD_INT 5
111009: PUSH
111010: EMPTY
111011: LIST
111012: LIST
111013: PUSH
111014: EMPTY
111015: LIST
111016: LIST
111017: LIST
111018: PPUSH
111019: CALL_OW 72
111023: ST_TO_ADDR
// if not tmp then
111024: LD_VAR 0 6
111028: NOT
111029: IFFALSE 111035
// exit ;
111031: POP
111032: POP
111033: GO 111115
// for j in tmp do
111035: LD_ADDR_VAR 0 4
111039: PUSH
111040: LD_VAR 0 6
111044: PUSH
111045: FOR_IN
111046: IFFALSE 111105
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
111048: LD_ADDR_VAR 0 7
111052: PUSH
111053: LD_VAR 0 4
111057: PPUSH
111058: CALL_OW 313
111062: PPUSH
111063: LD_INT 25
111065: PUSH
111066: LD_INT 1
111068: PUSH
111069: EMPTY
111070: LIST
111071: LIST
111072: PPUSH
111073: CALL_OW 72
111077: ST_TO_ADDR
// if units then
111078: LD_VAR 0 7
111082: IFFALSE 111103
// begin ComExitBuilding ( units [ 1 ] ) ;
111084: LD_VAR 0 7
111088: PUSH
111089: LD_INT 1
111091: ARRAY
111092: PPUSH
111093: CALL_OW 122
// exit ;
111097: POP
111098: POP
111099: POP
111100: POP
111101: GO 111115
// end ; end ;
111103: GO 111045
111105: POP
111106: POP
// end ; end ; exit ;
111107: POP
111108: POP
111109: GO 111115
// end ; end ;
111111: GO 110469
111113: POP
111114: POP
// end ;
111115: LD_VAR 0 2
111119: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
111120: LD_INT 0
111122: PPUSH
111123: PPUSH
111124: PPUSH
111125: PPUSH
111126: PPUSH
111127: PPUSH
111128: PPUSH
// if not mc_bases or not skirmish then
111129: LD_EXP 172
111133: NOT
111134: PUSH
111135: LD_EXP 170
111139: NOT
111140: OR
111141: IFFALSE 111145
// exit ;
111143: GO 111376
// btype := GetBType ( building ) ;
111145: LD_ADDR_VAR 0 6
111149: PUSH
111150: LD_VAR 0 1
111154: PPUSH
111155: CALL_OW 266
111159: ST_TO_ADDR
// x := GetX ( building ) ;
111160: LD_ADDR_VAR 0 7
111164: PUSH
111165: LD_VAR 0 1
111169: PPUSH
111170: CALL_OW 250
111174: ST_TO_ADDR
// y := GetY ( building ) ;
111175: LD_ADDR_VAR 0 8
111179: PUSH
111180: LD_VAR 0 1
111184: PPUSH
111185: CALL_OW 251
111189: ST_TO_ADDR
// d := GetDir ( building ) ;
111190: LD_ADDR_VAR 0 9
111194: PUSH
111195: LD_VAR 0 1
111199: PPUSH
111200: CALL_OW 254
111204: ST_TO_ADDR
// for i = 1 to mc_bases do
111205: LD_ADDR_VAR 0 4
111209: PUSH
111210: DOUBLE
111211: LD_INT 1
111213: DEC
111214: ST_TO_ADDR
111215: LD_EXP 172
111219: PUSH
111220: FOR_TO
111221: IFFALSE 111374
// begin if not mc_build_list [ i ] then
111223: LD_EXP 177
111227: PUSH
111228: LD_VAR 0 4
111232: ARRAY
111233: NOT
111234: IFFALSE 111238
// continue ;
111236: GO 111220
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ 1 ] ) then
111238: LD_VAR 0 6
111242: PUSH
111243: LD_VAR 0 7
111247: PUSH
111248: LD_VAR 0 8
111252: PUSH
111253: LD_VAR 0 9
111257: PUSH
111258: EMPTY
111259: LIST
111260: LIST
111261: LIST
111262: LIST
111263: PPUSH
111264: LD_EXP 177
111268: PUSH
111269: LD_VAR 0 4
111273: ARRAY
111274: PUSH
111275: LD_INT 1
111277: ARRAY
111278: PPUSH
111279: CALL 30303 0 2
111283: IFFALSE 111372
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , 1 ) ) ;
111285: LD_ADDR_EXP 177
111289: PUSH
111290: LD_EXP 177
111294: PPUSH
111295: LD_VAR 0 4
111299: PPUSH
111300: LD_EXP 177
111304: PUSH
111305: LD_VAR 0 4
111309: ARRAY
111310: PPUSH
111311: LD_INT 1
111313: PPUSH
111314: CALL_OW 3
111318: PPUSH
111319: CALL_OW 1
111323: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
111324: LD_ADDR_EXP 179
111328: PUSH
111329: LD_EXP 179
111333: PPUSH
111334: LD_VAR 0 4
111338: PUSH
111339: LD_EXP 179
111343: PUSH
111344: LD_VAR 0 4
111348: ARRAY
111349: PUSH
111350: LD_INT 1
111352: PLUS
111353: PUSH
111354: EMPTY
111355: LIST
111356: LIST
111357: PPUSH
111358: LD_VAR 0 1
111362: PPUSH
111363: CALL 24096 0 3
111367: ST_TO_ADDR
// exit ;
111368: POP
111369: POP
111370: GO 111376
// end ; end ;
111372: GO 111220
111374: POP
111375: POP
// end ;
111376: LD_VAR 0 3
111380: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
111381: LD_INT 0
111383: PPUSH
111384: PPUSH
111385: PPUSH
// if not mc_bases or not skirmish then
111386: LD_EXP 172
111390: NOT
111391: PUSH
111392: LD_EXP 170
111396: NOT
111397: OR
111398: IFFALSE 111402
// exit ;
111400: GO 111592
// for i = 1 to mc_bases do
111402: LD_ADDR_VAR 0 4
111406: PUSH
111407: DOUBLE
111408: LD_INT 1
111410: DEC
111411: ST_TO_ADDR
111412: LD_EXP 172
111416: PUSH
111417: FOR_TO
111418: IFFALSE 111505
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
111420: LD_VAR 0 1
111424: PUSH
111425: LD_EXP 180
111429: PUSH
111430: LD_VAR 0 4
111434: ARRAY
111435: IN
111436: PUSH
111437: LD_VAR 0 1
111441: PUSH
111442: LD_EXP 181
111446: PUSH
111447: LD_VAR 0 4
111451: ARRAY
111452: IN
111453: NOT
111454: AND
111455: IFFALSE 111503
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
111457: LD_ADDR_EXP 181
111461: PUSH
111462: LD_EXP 181
111466: PPUSH
111467: LD_VAR 0 4
111471: PUSH
111472: LD_EXP 181
111476: PUSH
111477: LD_VAR 0 4
111481: ARRAY
111482: PUSH
111483: LD_INT 1
111485: PLUS
111486: PUSH
111487: EMPTY
111488: LIST
111489: LIST
111490: PPUSH
111491: LD_VAR 0 1
111495: PPUSH
111496: CALL 24096 0 3
111500: ST_TO_ADDR
// break ;
111501: GO 111505
// end ; end ;
111503: GO 111417
111505: POP
111506: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
111507: LD_VAR 0 1
111511: PPUSH
111512: CALL_OW 257
111516: PUSH
111517: LD_EXP 198
111521: IN
111522: PUSH
111523: LD_VAR 0 1
111527: PPUSH
111528: CALL_OW 266
111532: PUSH
111533: LD_INT 5
111535: EQUAL
111536: AND
111537: PUSH
111538: LD_VAR 0 2
111542: PPUSH
111543: CALL_OW 110
111547: PUSH
111548: LD_INT 18
111550: NONEQUAL
111551: AND
111552: IFFALSE 111592
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
111554: LD_VAR 0 2
111558: PPUSH
111559: CALL_OW 257
111563: PUSH
111564: LD_INT 5
111566: PUSH
111567: LD_INT 8
111569: PUSH
111570: LD_INT 9
111572: PUSH
111573: EMPTY
111574: LIST
111575: LIST
111576: LIST
111577: IN
111578: IFFALSE 111592
// SetClass ( unit , 1 ) ;
111580: LD_VAR 0 2
111584: PPUSH
111585: LD_INT 1
111587: PPUSH
111588: CALL_OW 336
// end ;
111592: LD_VAR 0 3
111596: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
111597: LD_INT 0
111599: PPUSH
111600: PPUSH
// if not mc_bases or not skirmish then
111601: LD_EXP 172
111605: NOT
111606: PUSH
111607: LD_EXP 170
111611: NOT
111612: OR
111613: IFFALSE 111617
// exit ;
111615: GO 111733
// if GetLives ( abandoned_vehicle ) > 250 then
111617: LD_VAR 0 2
111621: PPUSH
111622: CALL_OW 256
111626: PUSH
111627: LD_INT 250
111629: GREATER
111630: IFFALSE 111634
// exit ;
111632: GO 111733
// for i = 1 to mc_bases do
111634: LD_ADDR_VAR 0 6
111638: PUSH
111639: DOUBLE
111640: LD_INT 1
111642: DEC
111643: ST_TO_ADDR
111644: LD_EXP 172
111648: PUSH
111649: FOR_TO
111650: IFFALSE 111731
// begin if driver in mc_bases [ i ] then
111652: LD_VAR 0 1
111656: PUSH
111657: LD_EXP 172
111661: PUSH
111662: LD_VAR 0 6
111666: ARRAY
111667: IN
111668: IFFALSE 111729
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
111670: LD_VAR 0 1
111674: PPUSH
111675: LD_EXP 172
111679: PUSH
111680: LD_VAR 0 6
111684: ARRAY
111685: PPUSH
111686: LD_INT 2
111688: PUSH
111689: LD_INT 30
111691: PUSH
111692: LD_INT 0
111694: PUSH
111695: EMPTY
111696: LIST
111697: LIST
111698: PUSH
111699: LD_INT 30
111701: PUSH
111702: LD_INT 1
111704: PUSH
111705: EMPTY
111706: LIST
111707: LIST
111708: PUSH
111709: EMPTY
111710: LIST
111711: LIST
111712: LIST
111713: PPUSH
111714: CALL_OW 72
111718: PUSH
111719: LD_INT 1
111721: ARRAY
111722: PPUSH
111723: CALL 56339 0 2
// break ;
111727: GO 111731
// end ; end ;
111729: GO 111649
111731: POP
111732: POP
// end ;
111733: LD_VAR 0 5
111737: RET
